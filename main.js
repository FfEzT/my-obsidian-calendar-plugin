/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// node_modules/obsidian-dataview/lib/index.js
var require_lib = __commonJS({
  "node_modules/obsidian-dataview/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    require("obsidian");
    var LuxonError = class extends Error {
    };
    var InvalidDateTimeError = class extends LuxonError {
      constructor(reason) {
        super(`Invalid DateTime: ${reason.toMessage()}`);
      }
    };
    var InvalidIntervalError = class extends LuxonError {
      constructor(reason) {
        super(`Invalid Interval: ${reason.toMessage()}`);
      }
    };
    var InvalidDurationError = class extends LuxonError {
      constructor(reason) {
        super(`Invalid Duration: ${reason.toMessage()}`);
      }
    };
    var ConflictingSpecificationError = class extends LuxonError {
    };
    var InvalidUnitError = class extends LuxonError {
      constructor(unit) {
        super(`Invalid unit ${unit}`);
      }
    };
    var InvalidArgumentError = class extends LuxonError {
    };
    var ZoneIsAbstractError = class extends LuxonError {
      constructor() {
        super("Zone is an abstract class");
      }
    };
    var n2 = "numeric";
    var s3 = "short";
    var l3 = "long";
    var DATE_SHORT = {
      year: n2,
      month: n2,
      day: n2
    };
    var DATE_MED = {
      year: n2,
      month: s3,
      day: n2
    };
    var DATE_MED_WITH_WEEKDAY = {
      year: n2,
      month: s3,
      day: n2,
      weekday: s3
    };
    var DATE_FULL = {
      year: n2,
      month: l3,
      day: n2
    };
    var DATE_HUGE = {
      year: n2,
      month: l3,
      day: n2,
      weekday: l3
    };
    var TIME_SIMPLE = {
      hour: n2,
      minute: n2
    };
    var TIME_WITH_SECONDS = {
      hour: n2,
      minute: n2,
      second: n2
    };
    var TIME_WITH_SHORT_OFFSET = {
      hour: n2,
      minute: n2,
      second: n2,
      timeZoneName: s3
    };
    var TIME_WITH_LONG_OFFSET = {
      hour: n2,
      minute: n2,
      second: n2,
      timeZoneName: l3
    };
    var TIME_24_SIMPLE = {
      hour: n2,
      minute: n2,
      hourCycle: "h23"
    };
    var TIME_24_WITH_SECONDS = {
      hour: n2,
      minute: n2,
      second: n2,
      hourCycle: "h23"
    };
    var TIME_24_WITH_SHORT_OFFSET = {
      hour: n2,
      minute: n2,
      second: n2,
      hourCycle: "h23",
      timeZoneName: s3
    };
    var TIME_24_WITH_LONG_OFFSET = {
      hour: n2,
      minute: n2,
      second: n2,
      hourCycle: "h23",
      timeZoneName: l3
    };
    var DATETIME_SHORT = {
      year: n2,
      month: n2,
      day: n2,
      hour: n2,
      minute: n2
    };
    var DATETIME_SHORT_WITH_SECONDS = {
      year: n2,
      month: n2,
      day: n2,
      hour: n2,
      minute: n2,
      second: n2
    };
    var DATETIME_MED = {
      year: n2,
      month: s3,
      day: n2,
      hour: n2,
      minute: n2
    };
    var DATETIME_MED_WITH_SECONDS = {
      year: n2,
      month: s3,
      day: n2,
      hour: n2,
      minute: n2,
      second: n2
    };
    var DATETIME_MED_WITH_WEEKDAY = {
      year: n2,
      month: s3,
      day: n2,
      weekday: s3,
      hour: n2,
      minute: n2
    };
    var DATETIME_FULL = {
      year: n2,
      month: l3,
      day: n2,
      hour: n2,
      minute: n2,
      timeZoneName: s3
    };
    var DATETIME_FULL_WITH_SECONDS = {
      year: n2,
      month: l3,
      day: n2,
      hour: n2,
      minute: n2,
      second: n2,
      timeZoneName: s3
    };
    var DATETIME_HUGE = {
      year: n2,
      month: l3,
      day: n2,
      weekday: l3,
      hour: n2,
      minute: n2,
      timeZoneName: l3
    };
    var DATETIME_HUGE_WITH_SECONDS = {
      year: n2,
      month: l3,
      day: n2,
      weekday: l3,
      hour: n2,
      minute: n2,
      second: n2,
      timeZoneName: l3
    };
    var Zone = class {
      /**
       * The type of zone
       * @abstract
       * @type {string}
       */
      get type() {
        throw new ZoneIsAbstractError();
      }
      /**
       * The name of this zone.
       * @abstract
       * @type {string}
       */
      get name() {
        throw new ZoneIsAbstractError();
      }
      get ianaName() {
        return this.name;
      }
      /**
       * Returns whether the offset is known to be fixed for the whole year.
       * @abstract
       * @type {boolean}
       */
      get isUniversal() {
        throw new ZoneIsAbstractError();
      }
      /**
       * Returns the offset's common name (such as EST) at the specified timestamp
       * @abstract
       * @param {number} ts - Epoch milliseconds for which to get the name
       * @param {Object} opts - Options to affect the format
       * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
       * @param {string} opts.locale - What locale to return the offset name in.
       * @return {string}
       */
      offsetName(ts, opts) {
        throw new ZoneIsAbstractError();
      }
      /**
       * Returns the offset's value as a string
       * @abstract
       * @param {number} ts - Epoch milliseconds for which to get the offset
       * @param {string} format - What style of offset to return.
       *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
       * @return {string}
       */
      formatOffset(ts, format) {
        throw new ZoneIsAbstractError();
      }
      /**
       * Return the offset in minutes for this zone at the specified timestamp.
       * @abstract
       * @param {number} ts - Epoch milliseconds for which to compute the offset
       * @return {number}
       */
      offset(ts) {
        throw new ZoneIsAbstractError();
      }
      /**
       * Return whether this Zone is equal to another zone
       * @abstract
       * @param {Zone} otherZone - the zone to compare
       * @return {boolean}
       */
      equals(otherZone) {
        throw new ZoneIsAbstractError();
      }
      /**
       * Return whether this Zone is valid.
       * @abstract
       * @type {boolean}
       */
      get isValid() {
        throw new ZoneIsAbstractError();
      }
    };
    var singleton$1 = null;
    var SystemZone = class extends Zone {
      /**
       * Get a singleton instance of the local zone
       * @return {SystemZone}
       */
      static get instance() {
        if (singleton$1 === null) {
          singleton$1 = new SystemZone();
        }
        return singleton$1;
      }
      /** @override **/
      get type() {
        return "system";
      }
      /** @override **/
      get name() {
        return new Intl.DateTimeFormat().resolvedOptions().timeZone;
      }
      /** @override **/
      get isUniversal() {
        return false;
      }
      /** @override **/
      offsetName(ts, { format, locale }) {
        return parseZoneInfo(ts, format, locale);
      }
      /** @override **/
      formatOffset(ts, format) {
        return formatOffset(this.offset(ts), format);
      }
      /** @override **/
      offset(ts) {
        return -new Date(ts).getTimezoneOffset();
      }
      /** @override **/
      equals(otherZone) {
        return otherZone.type === "system";
      }
      /** @override **/
      get isValid() {
        return true;
      }
    };
    var dtfCache = {};
    function makeDTF(zone) {
      if (!dtfCache[zone]) {
        dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
          hour12: false,
          timeZone: zone,
          year: "numeric",
          month: "2-digit",
          day: "2-digit",
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit",
          era: "short"
        });
      }
      return dtfCache[zone];
    }
    var typeToPos = {
      year: 0,
      month: 1,
      day: 2,
      era: 3,
      hour: 4,
      minute: 5,
      second: 6
    };
    function hackyOffset(dtf, date) {
      const formatted = dtf.format(date).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted), [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
      return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
    }
    function partsOffset(dtf, date) {
      const formatted = dtf.formatToParts(date);
      const filled = [];
      for (let i3 = 0; i3 < formatted.length; i3++) {
        const { type, value } = formatted[i3];
        const pos = typeToPos[type];
        if (type === "era") {
          filled[pos] = value;
        } else if (!isUndefined(pos)) {
          filled[pos] = parseInt(value, 10);
        }
      }
      return filled;
    }
    var ianaZoneCache = {};
    var IANAZone = class extends Zone {
      /**
       * @param {string} name - Zone name
       * @return {IANAZone}
       */
      static create(name) {
        if (!ianaZoneCache[name]) {
          ianaZoneCache[name] = new IANAZone(name);
        }
        return ianaZoneCache[name];
      }
      /**
       * Reset local caches. Should only be necessary in testing scenarios.
       * @return {void}
       */
      static resetCache() {
        ianaZoneCache = {};
        dtfCache = {};
      }
      /**
       * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
       * @param {string} s - The string to check validity on
       * @example IANAZone.isValidSpecifier("America/New_York") //=> true
       * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
       * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.
       * @return {boolean}
       */
      static isValidSpecifier(s4) {
        return this.isValidZone(s4);
      }
      /**
       * Returns whether the provided string identifies a real zone
       * @param {string} zone - The string to check
       * @example IANAZone.isValidZone("America/New_York") //=> true
       * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
       * @example IANAZone.isValidZone("Sport~~blorp") //=> false
       * @return {boolean}
       */
      static isValidZone(zone) {
        if (!zone) {
          return false;
        }
        try {
          new Intl.DateTimeFormat("en-US", { timeZone: zone }).format();
          return true;
        } catch (e3) {
          return false;
        }
      }
      constructor(name) {
        super();
        this.zoneName = name;
        this.valid = IANAZone.isValidZone(name);
      }
      /** @override **/
      get type() {
        return "iana";
      }
      /** @override **/
      get name() {
        return this.zoneName;
      }
      /** @override **/
      get isUniversal() {
        return false;
      }
      /** @override **/
      offsetName(ts, { format, locale }) {
        return parseZoneInfo(ts, format, locale, this.name);
      }
      /** @override **/
      formatOffset(ts, format) {
        return formatOffset(this.offset(ts), format);
      }
      /** @override **/
      offset(ts) {
        const date = new Date(ts);
        if (isNaN(date))
          return NaN;
        const dtf = makeDTF(this.name);
        let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date);
        if (adOrBc === "BC") {
          year = -Math.abs(year) + 1;
        }
        const adjustedHour = hour === 24 ? 0 : hour;
        const asUTC = objToLocalTS({
          year,
          month,
          day,
          hour: adjustedHour,
          minute,
          second,
          millisecond: 0
        });
        let asTS = +date;
        const over = asTS % 1e3;
        asTS -= over >= 0 ? over : 1e3 + over;
        return (asUTC - asTS) / (60 * 1e3);
      }
      /** @override **/
      equals(otherZone) {
        return otherZone.type === "iana" && otherZone.name === this.name;
      }
      /** @override **/
      get isValid() {
        return this.valid;
      }
    };
    var intlLFCache = {};
    function getCachedLF(locString, opts = {}) {
      const key = JSON.stringify([locString, opts]);
      let dtf = intlLFCache[key];
      if (!dtf) {
        dtf = new Intl.ListFormat(locString, opts);
        intlLFCache[key] = dtf;
      }
      return dtf;
    }
    var intlDTCache = {};
    function getCachedDTF(locString, opts = {}) {
      const key = JSON.stringify([locString, opts]);
      let dtf = intlDTCache[key];
      if (!dtf) {
        dtf = new Intl.DateTimeFormat(locString, opts);
        intlDTCache[key] = dtf;
      }
      return dtf;
    }
    var intlNumCache = {};
    function getCachedINF(locString, opts = {}) {
      const key = JSON.stringify([locString, opts]);
      let inf = intlNumCache[key];
      if (!inf) {
        inf = new Intl.NumberFormat(locString, opts);
        intlNumCache[key] = inf;
      }
      return inf;
    }
    var intlRelCache = {};
    function getCachedRTF(locString, opts = {}) {
      const { base, ...cacheKeyOpts } = opts;
      const key = JSON.stringify([locString, cacheKeyOpts]);
      let inf = intlRelCache[key];
      if (!inf) {
        inf = new Intl.RelativeTimeFormat(locString, opts);
        intlRelCache[key] = inf;
      }
      return inf;
    }
    var sysLocaleCache = null;
    function systemLocale() {
      if (sysLocaleCache) {
        return sysLocaleCache;
      } else {
        sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
        return sysLocaleCache;
      }
    }
    function parseLocaleString(localeStr) {
      const xIndex = localeStr.indexOf("-x-");
      if (xIndex !== -1) {
        localeStr = localeStr.substring(0, xIndex);
      }
      const uIndex = localeStr.indexOf("-u-");
      if (uIndex === -1) {
        return [localeStr];
      } else {
        let options;
        let selectedStr;
        try {
          options = getCachedDTF(localeStr).resolvedOptions();
          selectedStr = localeStr;
        } catch (e3) {
          const smaller = localeStr.substring(0, uIndex);
          options = getCachedDTF(smaller).resolvedOptions();
          selectedStr = smaller;
        }
        const { numberingSystem, calendar } = options;
        return [selectedStr, numberingSystem, calendar];
      }
    }
    function intlConfigString(localeStr, numberingSystem, outputCalendar) {
      if (outputCalendar || numberingSystem) {
        if (!localeStr.includes("-u-")) {
          localeStr += "-u";
        }
        if (outputCalendar) {
          localeStr += `-ca-${outputCalendar}`;
        }
        if (numberingSystem) {
          localeStr += `-nu-${numberingSystem}`;
        }
        return localeStr;
      } else {
        return localeStr;
      }
    }
    function mapMonths(f3) {
      const ms = [];
      for (let i3 = 1; i3 <= 12; i3++) {
        const dt = DateTime2.utc(2009, i3, 1);
        ms.push(f3(dt));
      }
      return ms;
    }
    function mapWeekdays(f3) {
      const ms = [];
      for (let i3 = 1; i3 <= 7; i3++) {
        const dt = DateTime2.utc(2016, 11, 13 + i3);
        ms.push(f3(dt));
      }
      return ms;
    }
    function listStuff(loc, length, englishFn, intlFn) {
      const mode = loc.listingMode();
      if (mode === "error") {
        return null;
      } else if (mode === "en") {
        return englishFn(length);
      } else {
        return intlFn(length);
      }
    }
    function supportsFastNumbers(loc) {
      if (loc.numberingSystem && loc.numberingSystem !== "latn") {
        return false;
      } else {
        return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
      }
    }
    var PolyNumberFormatter = class {
      constructor(intl, forceSimple, opts) {
        this.padTo = opts.padTo || 0;
        this.floor = opts.floor || false;
        const { padTo, floor, ...otherOpts } = opts;
        if (!forceSimple || Object.keys(otherOpts).length > 0) {
          const intlOpts = { useGrouping: false, ...opts };
          if (opts.padTo > 0)
            intlOpts.minimumIntegerDigits = opts.padTo;
          this.inf = getCachedINF(intl, intlOpts);
        }
      }
      format(i3) {
        if (this.inf) {
          const fixed = this.floor ? Math.floor(i3) : i3;
          return this.inf.format(fixed);
        } else {
          const fixed = this.floor ? Math.floor(i3) : roundTo(i3, 3);
          return padStart3(fixed, this.padTo);
        }
      }
    };
    var PolyDateFormatter = class {
      constructor(dt, intl, opts) {
        this.opts = opts;
        this.originalZone = void 0;
        let z3 = void 0;
        if (this.opts.timeZone) {
          this.dt = dt;
        } else if (dt.zone.type === "fixed") {
          const gmtOffset = -1 * (dt.offset / 60);
          const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
          if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
            z3 = offsetZ;
            this.dt = dt;
          } else {
            z3 = "UTC";
            this.dt = dt.offset === 0 ? dt : dt.setZone("UTC").plus({ minutes: dt.offset });
            this.originalZone = dt.zone;
          }
        } else if (dt.zone.type === "system") {
          this.dt = dt;
        } else if (dt.zone.type === "iana") {
          this.dt = dt;
          z3 = dt.zone.name;
        } else {
          z3 = "UTC";
          this.dt = dt.setZone("UTC").plus({ minutes: dt.offset });
          this.originalZone = dt.zone;
        }
        const intlOpts = { ...this.opts };
        intlOpts.timeZone = intlOpts.timeZone || z3;
        this.dtf = getCachedDTF(intl, intlOpts);
      }
      format() {
        if (this.originalZone) {
          return this.formatToParts().map(({ value }) => value).join("");
        }
        return this.dtf.format(this.dt.toJSDate());
      }
      formatToParts() {
        const parts = this.dtf.formatToParts(this.dt.toJSDate());
        if (this.originalZone) {
          return parts.map((part) => {
            if (part.type === "timeZoneName") {
              const offsetName = this.originalZone.offsetName(this.dt.ts, {
                locale: this.dt.locale,
                format: this.opts.timeZoneName
              });
              return {
                ...part,
                value: offsetName
              };
            } else {
              return part;
            }
          });
        }
        return parts;
      }
      resolvedOptions() {
        return this.dtf.resolvedOptions();
      }
    };
    var PolyRelFormatter = class {
      constructor(intl, isEnglish, opts) {
        this.opts = { style: "long", ...opts };
        if (!isEnglish && hasRelative()) {
          this.rtf = getCachedRTF(intl, opts);
        }
      }
      format(count, unit) {
        if (this.rtf) {
          return this.rtf.format(count, unit);
        } else {
          return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
        }
      }
      formatToParts(count, unit) {
        if (this.rtf) {
          return this.rtf.formatToParts(count, unit);
        } else {
          return [];
        }
      }
    };
    var Locale = class {
      static fromOpts(opts) {
        return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);
      }
      static create(locale, numberingSystem, outputCalendar, defaultToEN = false) {
        const specifiedLocale = locale || Settings.defaultLocale;
        const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
        const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
        const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
        return new Locale(localeR, numberingSystemR, outputCalendarR, specifiedLocale);
      }
      static resetCache() {
        sysLocaleCache = null;
        intlDTCache = {};
        intlNumCache = {};
        intlRelCache = {};
      }
      static fromObject({ locale, numberingSystem, outputCalendar } = {}) {
        return Locale.create(locale, numberingSystem, outputCalendar);
      }
      constructor(locale, numbering, outputCalendar, specifiedLocale) {
        const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);
        this.locale = parsedLocale;
        this.numberingSystem = numbering || parsedNumberingSystem || null;
        this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
        this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
        this.weekdaysCache = { format: {}, standalone: {} };
        this.monthsCache = { format: {}, standalone: {} };
        this.meridiemCache = null;
        this.eraCache = {};
        this.specifiedLocale = specifiedLocale;
        this.fastNumbersCached = null;
      }
      get fastNumbers() {
        if (this.fastNumbersCached == null) {
          this.fastNumbersCached = supportsFastNumbers(this);
        }
        return this.fastNumbersCached;
      }
      listingMode() {
        const isActuallyEn = this.isEnglish();
        const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
        return isActuallyEn && hasNoWeirdness ? "en" : "intl";
      }
      clone(alts) {
        if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
          return this;
        } else {
          return Locale.create(
            alts.locale || this.specifiedLocale,
            alts.numberingSystem || this.numberingSystem,
            alts.outputCalendar || this.outputCalendar,
            alts.defaultToEN || false
          );
        }
      }
      redefaultToEN(alts = {}) {
        return this.clone({ ...alts, defaultToEN: true });
      }
      redefaultToSystem(alts = {}) {
        return this.clone({ ...alts, defaultToEN: false });
      }
      months(length, format = false) {
        return listStuff(this, length, months, () => {
          const intl = format ? { month: length, day: "numeric" } : { month: length }, formatStr = format ? "format" : "standalone";
          if (!this.monthsCache[formatStr][length]) {
            this.monthsCache[formatStr][length] = mapMonths((dt) => this.extract(dt, intl, "month"));
          }
          return this.monthsCache[formatStr][length];
        });
      }
      weekdays(length, format = false) {
        return listStuff(this, length, weekdays, () => {
          const intl = format ? { weekday: length, year: "numeric", month: "long", day: "numeric" } : { weekday: length }, formatStr = format ? "format" : "standalone";
          if (!this.weekdaysCache[formatStr][length]) {
            this.weekdaysCache[formatStr][length] = mapWeekdays(
              (dt) => this.extract(dt, intl, "weekday")
            );
          }
          return this.weekdaysCache[formatStr][length];
        });
      }
      meridiems() {
        return listStuff(
          this,
          void 0,
          () => meridiems,
          () => {
            if (!this.meridiemCache) {
              const intl = { hour: "numeric", hourCycle: "h12" };
              this.meridiemCache = [DateTime2.utc(2016, 11, 13, 9), DateTime2.utc(2016, 11, 13, 19)].map(
                (dt) => this.extract(dt, intl, "dayperiod")
              );
            }
            return this.meridiemCache;
          }
        );
      }
      eras(length) {
        return listStuff(this, length, eras, () => {
          const intl = { era: length };
          if (!this.eraCache[length]) {
            this.eraCache[length] = [DateTime2.utc(-40, 1, 1), DateTime2.utc(2017, 1, 1)].map(
              (dt) => this.extract(dt, intl, "era")
            );
          }
          return this.eraCache[length];
        });
      }
      extract(dt, intlOpts, field) {
        const df = this.dtFormatter(dt, intlOpts), results = df.formatToParts(), matching = results.find((m3) => m3.type.toLowerCase() === field);
        return matching ? matching.value : null;
      }
      numberFormatter(opts = {}) {
        return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
      }
      dtFormatter(dt, intlOpts = {}) {
        return new PolyDateFormatter(dt, this.intl, intlOpts);
      }
      relFormatter(opts = {}) {
        return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
      }
      listFormatter(opts = {}) {
        return getCachedLF(this.intl, opts);
      }
      isEnglish() {
        return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
      }
      equals(other) {
        return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
      }
    };
    var singleton = null;
    var FixedOffsetZone = class extends Zone {
      /**
       * Get a singleton instance of UTC
       * @return {FixedOffsetZone}
       */
      static get utcInstance() {
        if (singleton === null) {
          singleton = new FixedOffsetZone(0);
        }
        return singleton;
      }
      /**
       * Get an instance with a specified offset
       * @param {number} offset - The offset in minutes
       * @return {FixedOffsetZone}
       */
      static instance(offset2) {
        return offset2 === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset2);
      }
      /**
       * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
       * @param {string} s - The offset string to parse
       * @example FixedOffsetZone.parseSpecifier("UTC+6")
       * @example FixedOffsetZone.parseSpecifier("UTC+06")
       * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
       * @return {FixedOffsetZone}
       */
      static parseSpecifier(s4) {
        if (s4) {
          const r3 = s4.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
          if (r3) {
            return new FixedOffsetZone(signedOffset(r3[1], r3[2]));
          }
        }
        return null;
      }
      constructor(offset2) {
        super();
        this.fixed = offset2;
      }
      /** @override **/
      get type() {
        return "fixed";
      }
      /** @override **/
      get name() {
        return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`;
      }
      get ianaName() {
        if (this.fixed === 0) {
          return "Etc/UTC";
        } else {
          return `Etc/GMT${formatOffset(-this.fixed, "narrow")}`;
        }
      }
      /** @override **/
      offsetName() {
        return this.name;
      }
      /** @override **/
      formatOffset(ts, format) {
        return formatOffset(this.fixed, format);
      }
      /** @override **/
      get isUniversal() {
        return true;
      }
      /** @override **/
      offset() {
        return this.fixed;
      }
      /** @override **/
      equals(otherZone) {
        return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
      }
      /** @override **/
      get isValid() {
        return true;
      }
    };
    var InvalidZone = class extends Zone {
      constructor(zoneName) {
        super();
        this.zoneName = zoneName;
      }
      /** @override **/
      get type() {
        return "invalid";
      }
      /** @override **/
      get name() {
        return this.zoneName;
      }
      /** @override **/
      get isUniversal() {
        return false;
      }
      /** @override **/
      offsetName() {
        return null;
      }
      /** @override **/
      formatOffset() {
        return "";
      }
      /** @override **/
      offset() {
        return NaN;
      }
      /** @override **/
      equals() {
        return false;
      }
      /** @override **/
      get isValid() {
        return false;
      }
    };
    function normalizeZone(input, defaultZone2) {
      if (isUndefined(input) || input === null) {
        return defaultZone2;
      } else if (input instanceof Zone) {
        return input;
      } else if (isString(input)) {
        const lowered = input.toLowerCase();
        if (lowered === "default")
          return defaultZone2;
        else if (lowered === "local" || lowered === "system")
          return SystemZone.instance;
        else if (lowered === "utc" || lowered === "gmt")
          return FixedOffsetZone.utcInstance;
        else
          return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input);
      } else if (isNumber2(input)) {
        return FixedOffsetZone.instance(input);
      } else if (typeof input === "object" && "offset" in input && typeof input.offset === "function") {
        return input;
      } else {
        return new InvalidZone(input);
      }
    }
    var now = () => Date.now();
    var defaultZone = "system";
    var defaultLocale = null;
    var defaultNumberingSystem = null;
    var defaultOutputCalendar = null;
    var twoDigitCutoffYear = 60;
    var throwOnInvalid;
    var Settings = class {
      /**
       * Get the callback for returning the current timestamp.
       * @type {function}
       */
      static get now() {
        return now;
      }
      /**
       * Set the callback for returning the current timestamp.
       * The function should return a number, which will be interpreted as an Epoch millisecond count
       * @type {function}
       * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
       * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
       */
      static set now(n3) {
        now = n3;
      }
      /**
       * Set the default time zone to create DateTimes in. Does not affect existing instances.
       * Use the value "system" to reset this value to the system's time zone.
       * @type {string}
       */
      static set defaultZone(zone) {
        defaultZone = zone;
      }
      /**
       * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
       * The default value is the system's time zone (the one set on the machine that runs this code).
       * @type {Zone}
       */
      static get defaultZone() {
        return normalizeZone(defaultZone, SystemZone.instance);
      }
      /**
       * Get the default locale to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static get defaultLocale() {
        return defaultLocale;
      }
      /**
       * Set the default locale to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static set defaultLocale(locale) {
        defaultLocale = locale;
      }
      /**
       * Get the default numbering system to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static get defaultNumberingSystem() {
        return defaultNumberingSystem;
      }
      /**
       * Set the default numbering system to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static set defaultNumberingSystem(numberingSystem) {
        defaultNumberingSystem = numberingSystem;
      }
      /**
       * Get the default output calendar to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static get defaultOutputCalendar() {
        return defaultOutputCalendar;
      }
      /**
       * Set the default output calendar to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static set defaultOutputCalendar(outputCalendar) {
        defaultOutputCalendar = outputCalendar;
      }
      /**
       * Get the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
       * @type {number}
       */
      static get twoDigitCutoffYear() {
        return twoDigitCutoffYear;
      }
      /**
       * Set the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
       * @type {number}
       * @example Settings.twoDigitCutoffYear = 0 // cut-off year is 0, so all 'yy' are interpreted as current century
       * @example Settings.twoDigitCutoffYear = 50 // '49' -> 1949; '50' -> 2050
       * @example Settings.twoDigitCutoffYear = 1950 // interpreted as 50
       * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpreted as 50
       */
      static set twoDigitCutoffYear(cutoffYear) {
        twoDigitCutoffYear = cutoffYear % 100;
      }
      /**
       * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
       * @type {boolean}
       */
      static get throwOnInvalid() {
        return throwOnInvalid;
      }
      /**
       * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
       * @type {boolean}
       */
      static set throwOnInvalid(t3) {
        throwOnInvalid = t3;
      }
      /**
       * Reset Luxon's global caches. Should only be necessary in testing scenarios.
       * @return {void}
       */
      static resetCaches() {
        Locale.resetCache();
        IANAZone.resetCache();
      }
    };
    function isUndefined(o2) {
      return typeof o2 === "undefined";
    }
    function isNumber2(o2) {
      return typeof o2 === "number";
    }
    function isInteger(o2) {
      return typeof o2 === "number" && o2 % 1 === 0;
    }
    function isString(o2) {
      return typeof o2 === "string";
    }
    function isDate2(o2) {
      return Object.prototype.toString.call(o2) === "[object Date]";
    }
    function hasRelative() {
      try {
        return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
      } catch (e3) {
        return false;
      }
    }
    function maybeArray(thing) {
      return Array.isArray(thing) ? thing : [thing];
    }
    function bestBy(arr, by, compare) {
      if (arr.length === 0) {
        return void 0;
      }
      return arr.reduce((best, next) => {
        const pair = [by(next), next];
        if (!best) {
          return pair;
        } else if (compare(best[0], pair[0]) === best[0]) {
          return best;
        } else {
          return pair;
        }
      }, null)[1];
    }
    function pick(obj, keys) {
      return keys.reduce((a3, k3) => {
        a3[k3] = obj[k3];
        return a3;
      }, {});
    }
    function hasOwnProperty2(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    function integerBetween(thing, bottom, top) {
      return isInteger(thing) && thing >= bottom && thing <= top;
    }
    function floorMod(x4, n3) {
      return x4 - n3 * Math.floor(x4 / n3);
    }
    function padStart3(input, n3 = 2) {
      const isNeg = input < 0;
      let padded;
      if (isNeg) {
        padded = "-" + ("" + -input).padStart(n3, "0");
      } else {
        padded = ("" + input).padStart(n3, "0");
      }
      return padded;
    }
    function parseInteger(string) {
      if (isUndefined(string) || string === null || string === "") {
        return void 0;
      } else {
        return parseInt(string, 10);
      }
    }
    function parseFloating(string) {
      if (isUndefined(string) || string === null || string === "") {
        return void 0;
      } else {
        return parseFloat(string);
      }
    }
    function parseMillis(fraction) {
      if (isUndefined(fraction) || fraction === null || fraction === "") {
        return void 0;
      } else {
        const f3 = parseFloat("0." + fraction) * 1e3;
        return Math.floor(f3);
      }
    }
    function roundTo(number, digits, towardZero = false) {
      const factor = 10 ** digits, rounder = towardZero ? Math.trunc : Math.round;
      return rounder(number * factor) / factor;
    }
    function isLeapYear2(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    function daysInYear(year) {
      return isLeapYear2(year) ? 366 : 365;
    }
    function daysInMonth(year, month) {
      const modMonth = floorMod(month - 1, 12) + 1, modYear = year + (month - modMonth) / 12;
      if (modMonth === 2) {
        return isLeapYear2(modYear) ? 29 : 28;
      } else {
        return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
      }
    }
    function objToLocalTS(obj) {
      let d2 = Date.UTC(
        obj.year,
        obj.month - 1,
        obj.day,
        obj.hour,
        obj.minute,
        obj.second,
        obj.millisecond
      );
      if (obj.year < 100 && obj.year >= 0) {
        d2 = new Date(d2);
        d2.setUTCFullYear(obj.year, obj.month - 1, obj.day);
      }
      return +d2;
    }
    function weeksInWeekYear(weekYear) {
      const p1 = (weekYear + Math.floor(weekYear / 4) - Math.floor(weekYear / 100) + Math.floor(weekYear / 400)) % 7, last = weekYear - 1, p22 = (last + Math.floor(last / 4) - Math.floor(last / 100) + Math.floor(last / 400)) % 7;
      return p1 === 4 || p22 === 3 ? 53 : 52;
    }
    function untruncateYear(year) {
      if (year > 99) {
        return year;
      } else
        return year > Settings.twoDigitCutoffYear ? 1900 + year : 2e3 + year;
    }
    function parseZoneInfo(ts, offsetFormat, locale, timeZone = null) {
      const date = new Date(ts), intlOpts = {
        hourCycle: "h23",
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit"
      };
      if (timeZone) {
        intlOpts.timeZone = timeZone;
      }
      const modified = { timeZoneName: offsetFormat, ...intlOpts };
      const parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date).find((m3) => m3.type.toLowerCase() === "timezonename");
      return parsed ? parsed.value : null;
    }
    function signedOffset(offHourStr, offMinuteStr) {
      let offHour = parseInt(offHourStr, 10);
      if (Number.isNaN(offHour)) {
        offHour = 0;
      }
      const offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
      return offHour * 60 + offMinSigned;
    }
    function asNumber(value) {
      const numericValue = Number(value);
      if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue))
        throw new InvalidArgumentError(`Invalid unit value ${value}`);
      return numericValue;
    }
    function normalizeObject(obj, normalizer) {
      const normalized = {};
      for (const u3 in obj) {
        if (hasOwnProperty2(obj, u3)) {
          const v3 = obj[u3];
          if (v3 === void 0 || v3 === null)
            continue;
          normalized[normalizer(u3)] = asNumber(v3);
        }
      }
      return normalized;
    }
    function formatOffset(offset2, format) {
      const hours = Math.trunc(Math.abs(offset2 / 60)), minutes = Math.trunc(Math.abs(offset2 % 60)), sign = offset2 >= 0 ? "+" : "-";
      switch (format) {
        case "short":
          return `${sign}${padStart3(hours, 2)}:${padStart3(minutes, 2)}`;
        case "narrow":
          return `${sign}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
        case "techie":
          return `${sign}${padStart3(hours, 2)}${padStart3(minutes, 2)}`;
        default:
          throw new RangeError(`Value format ${format} is out of range for property format`);
      }
    }
    function timeObject(obj) {
      return pick(obj, ["hour", "minute", "second", "millisecond"]);
    }
    var monthsLong = [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ];
    var monthsShort = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    var monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
    function months(length) {
      switch (length) {
        case "narrow":
          return [...monthsNarrow];
        case "short":
          return [...monthsShort];
        case "long":
          return [...monthsLong];
        case "numeric":
          return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
        case "2-digit":
          return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
        default:
          return null;
      }
    }
    var weekdaysLong = [
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday",
      "Sunday"
    ];
    var weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
    var weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
    function weekdays(length) {
      switch (length) {
        case "narrow":
          return [...weekdaysNarrow];
        case "short":
          return [...weekdaysShort];
        case "long":
          return [...weekdaysLong];
        case "numeric":
          return ["1", "2", "3", "4", "5", "6", "7"];
        default:
          return null;
      }
    }
    var meridiems = ["AM", "PM"];
    var erasLong = ["Before Christ", "Anno Domini"];
    var erasShort = ["BC", "AD"];
    var erasNarrow = ["B", "A"];
    function eras(length) {
      switch (length) {
        case "narrow":
          return [...erasNarrow];
        case "short":
          return [...erasShort];
        case "long":
          return [...erasLong];
        default:
          return null;
      }
    }
    function meridiemForDateTime(dt) {
      return meridiems[dt.hour < 12 ? 0 : 1];
    }
    function weekdayForDateTime(dt, length) {
      return weekdays(length)[dt.weekday - 1];
    }
    function monthForDateTime(dt, length) {
      return months(length)[dt.month - 1];
    }
    function eraForDateTime(dt, length) {
      return eras(length)[dt.year < 0 ? 0 : 1];
    }
    function formatRelativeTime(unit, count, numeric = "always", narrow = false) {
      const units = {
        years: ["year", "yr."],
        quarters: ["quarter", "qtr."],
        months: ["month", "mo."],
        weeks: ["week", "wk."],
        days: ["day", "day", "days"],
        hours: ["hour", "hr."],
        minutes: ["minute", "min."],
        seconds: ["second", "sec."]
      };
      const lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;
      if (numeric === "auto" && lastable) {
        const isDay = unit === "days";
        switch (count) {
          case 1:
            return isDay ? "tomorrow" : `next ${units[unit][0]}`;
          case -1:
            return isDay ? "yesterday" : `last ${units[unit][0]}`;
          case 0:
            return isDay ? "today" : `this ${units[unit][0]}`;
        }
      }
      const isInPast = Object.is(count, -0) || count < 0, fmtValue = Math.abs(count), singular = fmtValue === 1, lilUnits = units[unit], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
      return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
    }
    function stringifyTokens(splits, tokenToString) {
      let s4 = "";
      for (const token of splits) {
        if (token.literal) {
          s4 += token.val;
        } else {
          s4 += tokenToString(token.val);
        }
      }
      return s4;
    }
    var macroTokenToFormatOpts = {
      D: DATE_SHORT,
      DD: DATE_MED,
      DDD: DATE_FULL,
      DDDD: DATE_HUGE,
      t: TIME_SIMPLE,
      tt: TIME_WITH_SECONDS,
      ttt: TIME_WITH_SHORT_OFFSET,
      tttt: TIME_WITH_LONG_OFFSET,
      T: TIME_24_SIMPLE,
      TT: TIME_24_WITH_SECONDS,
      TTT: TIME_24_WITH_SHORT_OFFSET,
      TTTT: TIME_24_WITH_LONG_OFFSET,
      f: DATETIME_SHORT,
      ff: DATETIME_MED,
      fff: DATETIME_FULL,
      ffff: DATETIME_HUGE,
      F: DATETIME_SHORT_WITH_SECONDS,
      FF: DATETIME_MED_WITH_SECONDS,
      FFF: DATETIME_FULL_WITH_SECONDS,
      FFFF: DATETIME_HUGE_WITH_SECONDS
    };
    var Formatter = class {
      static create(locale, opts = {}) {
        return new Formatter(locale, opts);
      }
      static parseFormat(fmt) {
        let current = null, currentFull = "", bracketed = false;
        const splits = [];
        for (let i3 = 0; i3 < fmt.length; i3++) {
          const c3 = fmt.charAt(i3);
          if (c3 === "'") {
            if (currentFull.length > 0) {
              splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
            }
            current = null;
            currentFull = "";
            bracketed = !bracketed;
          } else if (bracketed) {
            currentFull += c3;
          } else if (c3 === current) {
            currentFull += c3;
          } else {
            if (currentFull.length > 0) {
              splits.push({ literal: /^\s+$/.test(currentFull), val: currentFull });
            }
            currentFull = c3;
            current = c3;
          }
        }
        if (currentFull.length > 0) {
          splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
        }
        return splits;
      }
      static macroTokenToFormatOpts(token) {
        return macroTokenToFormatOpts[token];
      }
      constructor(locale, formatOpts) {
        this.opts = formatOpts;
        this.loc = locale;
        this.systemLoc = null;
      }
      formatWithSystemDefault(dt, opts) {
        if (this.systemLoc === null) {
          this.systemLoc = this.loc.redefaultToSystem();
        }
        const df = this.systemLoc.dtFormatter(dt, { ...this.opts, ...opts });
        return df.format();
      }
      dtFormatter(dt, opts = {}) {
        return this.loc.dtFormatter(dt, { ...this.opts, ...opts });
      }
      formatDateTime(dt, opts) {
        return this.dtFormatter(dt, opts).format();
      }
      formatDateTimeParts(dt, opts) {
        return this.dtFormatter(dt, opts).formatToParts();
      }
      formatInterval(interval, opts) {
        const df = this.dtFormatter(interval.start, opts);
        return df.dtf.formatRange(interval.start.toJSDate(), interval.end.toJSDate());
      }
      resolvedOptions(dt, opts) {
        return this.dtFormatter(dt, opts).resolvedOptions();
      }
      num(n3, p3 = 0) {
        if (this.opts.forceSimple) {
          return padStart3(n3, p3);
        }
        const opts = { ...this.opts };
        if (p3 > 0) {
          opts.padTo = p3;
        }
        return this.loc.numberFormatter(opts).format(n3);
      }
      formatDateTimeFromString(dt, fmt) {
        const knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", string = (opts, extract) => this.loc.extract(dt, opts, extract), formatOffset2 = (opts) => {
          if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
            return "Z";
          }
          return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
        }, meridiem = () => knownEnglish ? meridiemForDateTime(dt) : string({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), month = (length, standalone) => knownEnglish ? monthForDateTime(dt, length) : string(standalone ? { month: length } : { month: length, day: "numeric" }, "month"), weekday = (length, standalone) => knownEnglish ? weekdayForDateTime(dt, length) : string(
          standalone ? { weekday: length } : { weekday: length, month: "long", day: "numeric" },
          "weekday"
        ), maybeMacro = (token) => {
          const formatOpts = Formatter.macroTokenToFormatOpts(token);
          if (formatOpts) {
            return this.formatWithSystemDefault(dt, formatOpts);
          } else {
            return token;
          }
        }, era = (length) => knownEnglish ? eraForDateTime(dt, length) : string({ era: length }, "era"), tokenToString = (token) => {
          switch (token) {
            case "S":
              return this.num(dt.millisecond);
            case "u":
            case "SSS":
              return this.num(dt.millisecond, 3);
            case "s":
              return this.num(dt.second);
            case "ss":
              return this.num(dt.second, 2);
            case "uu":
              return this.num(Math.floor(dt.millisecond / 10), 2);
            case "uuu":
              return this.num(Math.floor(dt.millisecond / 100));
            case "m":
              return this.num(dt.minute);
            case "mm":
              return this.num(dt.minute, 2);
            case "h":
              return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
            case "hh":
              return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
            case "H":
              return this.num(dt.hour);
            case "HH":
              return this.num(dt.hour, 2);
            case "Z":
              return formatOffset2({ format: "narrow", allowZ: this.opts.allowZ });
            case "ZZ":
              return formatOffset2({ format: "short", allowZ: this.opts.allowZ });
            case "ZZZ":
              return formatOffset2({ format: "techie", allowZ: this.opts.allowZ });
            case "ZZZZ":
              return dt.zone.offsetName(dt.ts, { format: "short", locale: this.loc.locale });
            case "ZZZZZ":
              return dt.zone.offsetName(dt.ts, { format: "long", locale: this.loc.locale });
            case "z":
              return dt.zoneName;
            case "a":
              return meridiem();
            case "d":
              return useDateTimeFormatter ? string({ day: "numeric" }, "day") : this.num(dt.day);
            case "dd":
              return useDateTimeFormatter ? string({ day: "2-digit" }, "day") : this.num(dt.day, 2);
            case "c":
              return this.num(dt.weekday);
            case "ccc":
              return weekday("short", true);
            case "cccc":
              return weekday("long", true);
            case "ccccc":
              return weekday("narrow", true);
            case "E":
              return this.num(dt.weekday);
            case "EEE":
              return weekday("short", false);
            case "EEEE":
              return weekday("long", false);
            case "EEEEE":
              return weekday("narrow", false);
            case "L":
              return useDateTimeFormatter ? string({ month: "numeric", day: "numeric" }, "month") : this.num(dt.month);
            case "LL":
              return useDateTimeFormatter ? string({ month: "2-digit", day: "numeric" }, "month") : this.num(dt.month, 2);
            case "LLL":
              return month("short", true);
            case "LLLL":
              return month("long", true);
            case "LLLLL":
              return month("narrow", true);
            case "M":
              return useDateTimeFormatter ? string({ month: "numeric" }, "month") : this.num(dt.month);
            case "MM":
              return useDateTimeFormatter ? string({ month: "2-digit" }, "month") : this.num(dt.month, 2);
            case "MMM":
              return month("short", false);
            case "MMMM":
              return month("long", false);
            case "MMMMM":
              return month("narrow", false);
            case "y":
              return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year);
            case "yy":
              return useDateTimeFormatter ? string({ year: "2-digit" }, "year") : this.num(dt.year.toString().slice(-2), 2);
            case "yyyy":
              return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 4);
            case "yyyyyy":
              return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 6);
            case "G":
              return era("short");
            case "GG":
              return era("long");
            case "GGGGG":
              return era("narrow");
            case "kk":
              return this.num(dt.weekYear.toString().slice(-2), 2);
            case "kkkk":
              return this.num(dt.weekYear, 4);
            case "W":
              return this.num(dt.weekNumber);
            case "WW":
              return this.num(dt.weekNumber, 2);
            case "o":
              return this.num(dt.ordinal);
            case "ooo":
              return this.num(dt.ordinal, 3);
            case "q":
              return this.num(dt.quarter);
            case "qq":
              return this.num(dt.quarter, 2);
            case "X":
              return this.num(Math.floor(dt.ts / 1e3));
            case "x":
              return this.num(dt.ts);
            default:
              return maybeMacro(token);
          }
        };
        return stringifyTokens(Formatter.parseFormat(fmt), tokenToString);
      }
      formatDurationFromString(dur, fmt) {
        const tokenToField = (token) => {
          switch (token[0]) {
            case "S":
              return "millisecond";
            case "s":
              return "second";
            case "m":
              return "minute";
            case "h":
              return "hour";
            case "d":
              return "day";
            case "w":
              return "week";
            case "M":
              return "month";
            case "y":
              return "year";
            default:
              return null;
          }
        }, tokenToString = (lildur) => (token) => {
          const mapped = tokenToField(token);
          if (mapped) {
            return this.num(lildur.get(mapped), token.length);
          } else {
            return token;
          }
        }, tokens = Formatter.parseFormat(fmt), realTokens = tokens.reduce(
          (found, { literal, val }) => literal ? found : found.concat(val),
          []
        ), collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t3) => t3));
        return stringifyTokens(tokens, tokenToString(collapsed));
      }
    };
    var Invalid = class {
      constructor(reason, explanation) {
        this.reason = reason;
        this.explanation = explanation;
      }
      toMessage() {
        if (this.explanation) {
          return `${this.reason}: ${this.explanation}`;
        } else {
          return this.reason;
        }
      }
    };
    var ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
    function combineRegexes(...regexes) {
      const full = regexes.reduce((f3, r3) => f3 + r3.source, "");
      return RegExp(`^${full}$`);
    }
    function combineExtractors(...extractors) {
      return (m3) => extractors.reduce(
        ([mergedVals, mergedZone, cursor], ex) => {
          const [val, zone, next] = ex(m3, cursor);
          return [{ ...mergedVals, ...val }, zone || mergedZone, next];
        },
        [{}, null, 1]
      ).slice(0, 2);
    }
    function parse3(s4, ...patterns) {
      if (s4 == null) {
        return [null, null];
      }
      for (const [regex, extractor] of patterns) {
        const m3 = regex.exec(s4);
        if (m3) {
          return extractor(m3);
        }
      }
      return [null, null];
    }
    function simpleParse(...keys) {
      return (match2, cursor) => {
        const ret = {};
        let i3;
        for (i3 = 0; i3 < keys.length; i3++) {
          ret[keys[i3]] = parseInteger(match2[cursor + i3]);
        }
        return [ret, null, cursor + i3];
      };
    }
    var offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
    var isoExtendedZone = `(?:${offsetRegex.source}?(?:\\[(${ianaRegex.source})\\])?)?`;
    var isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
    var isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);
    var isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`);
    var isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
    var isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
    var isoOrdinalRegex = /(\d{4})-?(\d{3})/;
    var extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
    var extractISOOrdinalData = simpleParse("year", "ordinal");
    var sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/;
    var sqlTimeRegex = RegExp(
      `${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`
    );
    var sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);
    function int(match2, pos, fallback) {
      const m3 = match2[pos];
      return isUndefined(m3) ? fallback : parseInteger(m3);
    }
    function extractISOYmd(match2, cursor) {
      const item = {
        year: int(match2, cursor),
        month: int(match2, cursor + 1, 1),
        day: int(match2, cursor + 2, 1)
      };
      return [item, null, cursor + 3];
    }
    function extractISOTime(match2, cursor) {
      const item = {
        hours: int(match2, cursor, 0),
        minutes: int(match2, cursor + 1, 0),
        seconds: int(match2, cursor + 2, 0),
        milliseconds: parseMillis(match2[cursor + 3])
      };
      return [item, null, cursor + 4];
    }
    function extractISOOffset(match2, cursor) {
      const local = !match2[cursor] && !match2[cursor + 1], fullOffset = signedOffset(match2[cursor + 1], match2[cursor + 2]), zone = local ? null : FixedOffsetZone.instance(fullOffset);
      return [{}, zone, cursor + 3];
    }
    function extractIANAZone(match2, cursor) {
      const zone = match2[cursor] ? IANAZone.create(match2[cursor]) : null;
      return [{}, zone, cursor + 1];
    }
    var isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);
    var isoDuration = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
    function extractISODuration(match2) {
      const [s4, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] = match2;
      const hasNegativePrefix = s4[0] === "-";
      const negativeSeconds = secondStr && secondStr[0] === "-";
      const maybeNegate = (num, force = false) => num !== void 0 && (force || num && hasNegativePrefix) ? -num : num;
      return [
        {
          years: maybeNegate(parseFloating(yearStr)),
          months: maybeNegate(parseFloating(monthStr)),
          weeks: maybeNegate(parseFloating(weekStr)),
          days: maybeNegate(parseFloating(dayStr)),
          hours: maybeNegate(parseFloating(hourStr)),
          minutes: maybeNegate(parseFloating(minuteStr)),
          seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
          milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
        }
      ];
    }
    var obsOffsets = {
      GMT: 0,
      EDT: -4 * 60,
      EST: -5 * 60,
      CDT: -5 * 60,
      CST: -6 * 60,
      MDT: -6 * 60,
      MST: -7 * 60,
      PDT: -7 * 60,
      PST: -8 * 60
    };
    function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
      const result = {
        year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
        month: monthsShort.indexOf(monthStr) + 1,
        day: parseInteger(dayStr),
        hour: parseInteger(hourStr),
        minute: parseInteger(minuteStr)
      };
      if (secondStr)
        result.second = parseInteger(secondStr);
      if (weekdayStr) {
        result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
      }
      return result;
    }
    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
    function extractRFC2822(match2) {
      const [
        ,
        weekdayStr,
        dayStr,
        monthStr,
        yearStr,
        hourStr,
        minuteStr,
        secondStr,
        obsOffset,
        milOffset,
        offHourStr,
        offMinuteStr
      ] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      let offset2;
      if (obsOffset) {
        offset2 = obsOffsets[obsOffset];
      } else if (milOffset) {
        offset2 = 0;
      } else {
        offset2 = signedOffset(offHourStr, offMinuteStr);
      }
      return [result, new FixedOffsetZone(offset2)];
    }
    function preprocessRFC2822(s4) {
      return s4.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
    }
    var rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/;
    var rfc850 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/;
    var ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
    function extractRFC1123Or850(match2) {
      const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      return [result, FixedOffsetZone.utcInstance];
    }
    function extractASCII(match2) {
      const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      return [result, FixedOffsetZone.utcInstance];
    }
    var isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
    var isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
    var isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
    var isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
    var extractISOYmdTimeAndOffset = combineExtractors(
      extractISOYmd,
      extractISOTime,
      extractISOOffset,
      extractIANAZone
    );
    var extractISOWeekTimeAndOffset = combineExtractors(
      extractISOWeekData,
      extractISOTime,
      extractISOOffset,
      extractIANAZone
    );
    var extractISOOrdinalDateAndTime = combineExtractors(
      extractISOOrdinalData,
      extractISOTime,
      extractISOOffset,
      extractIANAZone
    );
    var extractISOTimeAndOffset = combineExtractors(
      extractISOTime,
      extractISOOffset,
      extractIANAZone
    );
    function parseISODate(s4) {
      return parse3(
        s4,
        [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
        [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset],
        [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime],
        [isoTimeCombinedRegex, extractISOTimeAndOffset]
      );
    }
    function parseRFC2822Date(s4) {
      return parse3(preprocessRFC2822(s4), [rfc2822, extractRFC2822]);
    }
    function parseHTTPDate(s4) {
      return parse3(
        s4,
        [rfc1123, extractRFC1123Or850],
        [rfc850, extractRFC1123Or850],
        [ascii, extractASCII]
      );
    }
    function parseISODuration(s4) {
      return parse3(s4, [isoDuration, extractISODuration]);
    }
    var extractISOTimeOnly = combineExtractors(extractISOTime);
    function parseISOTimeOnly(s4) {
      return parse3(s4, [isoTimeOnly, extractISOTimeOnly]);
    }
    var sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
    var sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
    var extractISOTimeOffsetAndIANAZone = combineExtractors(
      extractISOTime,
      extractISOOffset,
      extractIANAZone
    );
    function parseSQL(s4) {
      return parse3(
        s4,
        [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
        [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]
      );
    }
    var INVALID$2 = "Invalid Duration";
    var lowOrderMatrix = {
      weeks: {
        days: 7,
        hours: 7 * 24,
        minutes: 7 * 24 * 60,
        seconds: 7 * 24 * 60 * 60,
        milliseconds: 7 * 24 * 60 * 60 * 1e3
      },
      days: {
        hours: 24,
        minutes: 24 * 60,
        seconds: 24 * 60 * 60,
        milliseconds: 24 * 60 * 60 * 1e3
      },
      hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
      minutes: { seconds: 60, milliseconds: 60 * 1e3 },
      seconds: { milliseconds: 1e3 }
    };
    var casualMatrix = {
      years: {
        quarters: 4,
        months: 12,
        weeks: 52,
        days: 365,
        hours: 365 * 24,
        minutes: 365 * 24 * 60,
        seconds: 365 * 24 * 60 * 60,
        milliseconds: 365 * 24 * 60 * 60 * 1e3
      },
      quarters: {
        months: 3,
        weeks: 13,
        days: 91,
        hours: 91 * 24,
        minutes: 91 * 24 * 60,
        seconds: 91 * 24 * 60 * 60,
        milliseconds: 91 * 24 * 60 * 60 * 1e3
      },
      months: {
        weeks: 4,
        days: 30,
        hours: 30 * 24,
        minutes: 30 * 24 * 60,
        seconds: 30 * 24 * 60 * 60,
        milliseconds: 30 * 24 * 60 * 60 * 1e3
      },
      ...lowOrderMatrix
    };
    var daysInYearAccurate = 146097 / 400;
    var daysInMonthAccurate = 146097 / 4800;
    var accurateMatrix = {
      years: {
        quarters: 4,
        months: 12,
        weeks: daysInYearAccurate / 7,
        days: daysInYearAccurate,
        hours: daysInYearAccurate * 24,
        minutes: daysInYearAccurate * 24 * 60,
        seconds: daysInYearAccurate * 24 * 60 * 60,
        milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3
      },
      quarters: {
        months: 3,
        weeks: daysInYearAccurate / 28,
        days: daysInYearAccurate / 4,
        hours: daysInYearAccurate * 24 / 4,
        minutes: daysInYearAccurate * 24 * 60 / 4,
        seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
        milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3 / 4
      },
      months: {
        weeks: daysInMonthAccurate / 7,
        days: daysInMonthAccurate,
        hours: daysInMonthAccurate * 24,
        minutes: daysInMonthAccurate * 24 * 60,
        seconds: daysInMonthAccurate * 24 * 60 * 60,
        milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1e3
      },
      ...lowOrderMatrix
    };
    var orderedUnits$1 = [
      "years",
      "quarters",
      "months",
      "weeks",
      "days",
      "hours",
      "minutes",
      "seconds",
      "milliseconds"
    ];
    var reverseUnits = orderedUnits$1.slice(0).reverse();
    function clone$1(dur, alts, clear = false) {
      const conf = {
        values: clear ? alts.values : { ...dur.values, ...alts.values || {} },
        loc: dur.loc.clone(alts.loc),
        conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
        matrix: alts.matrix || dur.matrix
      };
      return new Duration(conf);
    }
    function durationToMillis(matrix, vals) {
      var _a;
      let sum = (_a = vals.milliseconds) != null ? _a : 0;
      for (const unit of reverseUnits.slice(1)) {
        if (vals[unit]) {
          sum += vals[unit] * matrix[unit]["milliseconds"];
        }
      }
      return sum;
    }
    function normalizeValues(matrix, vals) {
      const factor = durationToMillis(matrix, vals) < 0 ? -1 : 1;
      orderedUnits$1.reduceRight((previous, current) => {
        if (!isUndefined(vals[current])) {
          if (previous) {
            const previousVal = vals[previous] * factor;
            const conv = matrix[current][previous];
            const rollUp = Math.floor(previousVal / conv);
            vals[current] += rollUp * factor;
            vals[previous] -= rollUp * conv * factor;
          }
          return current;
        } else {
          return previous;
        }
      }, null);
      orderedUnits$1.reduce((previous, current) => {
        if (!isUndefined(vals[current])) {
          if (previous) {
            const fraction = vals[previous] % 1;
            vals[previous] -= fraction;
            vals[current] += fraction * matrix[previous][current];
          }
          return current;
        } else {
          return previous;
        }
      }, null);
    }
    function removeZeroes(vals) {
      const newVals = {};
      for (const [key, value] of Object.entries(vals)) {
        if (value !== 0) {
          newVals[key] = value;
        }
      }
      return newVals;
    }
    var Duration = class {
      /**
       * @private
       */
      constructor(config2) {
        const accurate = config2.conversionAccuracy === "longterm" || false;
        let matrix = accurate ? accurateMatrix : casualMatrix;
        if (config2.matrix) {
          matrix = config2.matrix;
        }
        this.values = config2.values;
        this.loc = config2.loc || Locale.create();
        this.conversionAccuracy = accurate ? "longterm" : "casual";
        this.invalid = config2.invalid || null;
        this.matrix = matrix;
        this.isLuxonDuration = true;
      }
      /**
       * Create Duration from a number of milliseconds.
       * @param {number} count of milliseconds
       * @param {Object} opts - options for parsing
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @return {Duration}
       */
      static fromMillis(count, opts) {
        return Duration.fromObject({ milliseconds: count }, opts);
      }
      /**
       * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
       * If this object is empty then a zero milliseconds duration is returned.
       * @param {Object} obj - the object to create the DateTime from
       * @param {number} obj.years
       * @param {number} obj.quarters
       * @param {number} obj.months
       * @param {number} obj.weeks
       * @param {number} obj.days
       * @param {number} obj.hours
       * @param {number} obj.minutes
       * @param {number} obj.seconds
       * @param {number} obj.milliseconds
       * @param {Object} [opts=[]] - options for creating this Duration
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
       * @param {string} [opts.matrix=Object] - the custom conversion system to use
       * @return {Duration}
       */
      static fromObject(obj, opts = {}) {
        if (obj == null || typeof obj !== "object") {
          throw new InvalidArgumentError(
            `Duration.fromObject: argument expected to be an object, got ${obj === null ? "null" : typeof obj}`
          );
        }
        return new Duration({
          values: normalizeObject(obj, Duration.normalizeUnit),
          loc: Locale.fromObject(opts),
          conversionAccuracy: opts.conversionAccuracy,
          matrix: opts.matrix
        });
      }
      /**
       * Create a Duration from DurationLike.
       *
       * @param {Object | number | Duration} durationLike
       * One of:
       * - object with keys like 'years' and 'hours'.
       * - number representing milliseconds
       * - Duration instance
       * @return {Duration}
       */
      static fromDurationLike(durationLike) {
        if (isNumber2(durationLike)) {
          return Duration.fromMillis(durationLike);
        } else if (Duration.isDuration(durationLike)) {
          return durationLike;
        } else if (typeof durationLike === "object") {
          return Duration.fromObject(durationLike);
        } else {
          throw new InvalidArgumentError(
            `Unknown duration argument ${durationLike} of type ${typeof durationLike}`
          );
        }
      }
      /**
       * Create a Duration from an ISO 8601 duration string.
       * @param {string} text - text to parse
       * @param {Object} opts - options for parsing
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
       * @param {string} [opts.matrix=Object] - the preset conversion system to use
       * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
       * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
       * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
       * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
       * @return {Duration}
       */
      static fromISO(text, opts) {
        const [parsed] = parseISODuration(text);
        if (parsed) {
          return Duration.fromObject(parsed, opts);
        } else {
          return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
        }
      }
      /**
       * Create a Duration from an ISO 8601 time string.
       * @param {string} text - text to parse
       * @param {Object} opts - options for parsing
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
       * @param {string} [opts.matrix=Object] - the conversion system to use
       * @see https://en.wikipedia.org/wiki/ISO_8601#Times
       * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
       * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @return {Duration}
       */
      static fromISOTime(text, opts) {
        const [parsed] = parseISOTimeOnly(text);
        if (parsed) {
          return Duration.fromObject(parsed, opts);
        } else {
          return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
        }
      }
      /**
       * Create an invalid Duration.
       * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
       * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
       * @return {Duration}
       */
      static invalid(reason, explanation = null) {
        if (!reason) {
          throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
        }
        const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
        if (Settings.throwOnInvalid) {
          throw new InvalidDurationError(invalid);
        } else {
          return new Duration({ invalid });
        }
      }
      /**
       * @private
       */
      static normalizeUnit(unit) {
        const normalized = {
          year: "years",
          years: "years",
          quarter: "quarters",
          quarters: "quarters",
          month: "months",
          months: "months",
          week: "weeks",
          weeks: "weeks",
          day: "days",
          days: "days",
          hour: "hours",
          hours: "hours",
          minute: "minutes",
          minutes: "minutes",
          second: "seconds",
          seconds: "seconds",
          millisecond: "milliseconds",
          milliseconds: "milliseconds"
        }[unit ? unit.toLowerCase() : unit];
        if (!normalized)
          throw new InvalidUnitError(unit);
        return normalized;
      }
      /**
       * Check if an object is a Duration. Works across context boundaries
       * @param {object} o
       * @return {boolean}
       */
      static isDuration(o2) {
        return o2 && o2.isLuxonDuration || false;
      }
      /**
       * Get  the locale of a Duration, such 'en-GB'
       * @type {string}
       */
      get locale() {
        return this.isValid ? this.loc.locale : null;
      }
      /**
       * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
       *
       * @type {string}
       */
      get numberingSystem() {
        return this.isValid ? this.loc.numberingSystem : null;
      }
      /**
       * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
       * * `S` for milliseconds
       * * `s` for seconds
       * * `m` for minutes
       * * `h` for hours
       * * `d` for days
       * * `w` for weeks
       * * `M` for months
       * * `y` for years
       * Notes:
       * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
       * * Tokens can be escaped by wrapping with single quotes.
       * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
       * @param {string} fmt - the format string
       * @param {Object} opts - options
       * @param {boolean} [opts.floor=true] - floor numerical values
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
       * @return {string}
       */
      toFormat(fmt, opts = {}) {
        const fmtOpts = {
          ...opts,
          floor: opts.round !== false && opts.floor !== false
        };
        return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID$2;
      }
      /**
       * Returns a string representation of a Duration with all units included.
       * To modify its behavior use the `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat
       * @param opts - On option object to override the formatting. Accepts the same keys as the options parameter of the native `Int.NumberFormat` constructor, as well as `listStyle`.
       * @example
       * ```js
       * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
       * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
       * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
       * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
       * ```
       */
      toHuman(opts = {}) {
        if (!this.isValid)
          return INVALID$2;
        const l4 = orderedUnits$1.map((unit) => {
          const val = this.values[unit];
          if (isUndefined(val)) {
            return null;
          }
          return this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...opts, unit: unit.slice(0, -1) }).format(val);
        }).filter((n3) => n3);
        return this.loc.listFormatter({ type: "conjunction", style: opts.listStyle || "narrow", ...opts }).format(l4);
      }
      /**
       * Returns a JavaScript object with this Duration's values.
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
       * @return {Object}
       */
      toObject() {
        if (!this.isValid)
          return {};
        return { ...this.values };
      }
      /**
       * Returns an ISO 8601-compliant string representation of this Duration.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
       * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
       * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
       * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
       * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
       * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
       * @return {string}
       */
      toISO() {
        if (!this.isValid)
          return null;
        let s4 = "P";
        if (this.years !== 0)
          s4 += this.years + "Y";
        if (this.months !== 0 || this.quarters !== 0)
          s4 += this.months + this.quarters * 3 + "M";
        if (this.weeks !== 0)
          s4 += this.weeks + "W";
        if (this.days !== 0)
          s4 += this.days + "D";
        if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
          s4 += "T";
        if (this.hours !== 0)
          s4 += this.hours + "H";
        if (this.minutes !== 0)
          s4 += this.minutes + "M";
        if (this.seconds !== 0 || this.milliseconds !== 0)
          s4 += roundTo(this.seconds + this.milliseconds / 1e3, 3) + "S";
        if (s4 === "P")
          s4 += "T0S";
        return s4;
      }
      /**
       * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
       * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Times
       * @param {Object} opts - options
       * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
       * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
       * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
       * @return {string}
       */
      toISOTime(opts = {}) {
        if (!this.isValid)
          return null;
        const millis = this.toMillis();
        if (millis < 0 || millis >= 864e5)
          return null;
        opts = {
          suppressMilliseconds: false,
          suppressSeconds: false,
          includePrefix: false,
          format: "extended",
          ...opts,
          includeOffset: false
        };
        const dateTime = DateTime2.fromMillis(millis, { zone: "UTC" });
        return dateTime.toISOTime(opts);
      }
      /**
       * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
       * @return {string}
       */
      toJSON() {
        return this.toISO();
      }
      /**
       * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
       * @return {string}
       */
      toString() {
        return this.toISO();
      }
      /**
       * Returns an milliseconds value of this Duration.
       * @return {number}
       */
      toMillis() {
        if (!this.isValid)
          return NaN;
        return durationToMillis(this.matrix, this.values);
      }
      /**
       * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
       * @return {number}
       */
      valueOf() {
        return this.toMillis();
      }
      /**
       * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
       * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       * @return {Duration}
       */
      plus(duration) {
        if (!this.isValid)
          return this;
        const dur = Duration.fromDurationLike(duration), result = {};
        for (const k3 of orderedUnits$1) {
          if (hasOwnProperty2(dur.values, k3) || hasOwnProperty2(this.values, k3)) {
            result[k3] = dur.get(k3) + this.get(k3);
          }
        }
        return clone$1(this, { values: result }, true);
      }
      /**
       * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
       * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       * @return {Duration}
       */
      minus(duration) {
        if (!this.isValid)
          return this;
        const dur = Duration.fromDurationLike(duration);
        return this.plus(dur.negate());
      }
      /**
       * Scale this Duration by the specified amount. Return a newly-constructed Duration.
       * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
       * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
       * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hours" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
       * @return {Duration}
       */
      mapUnits(fn) {
        if (!this.isValid)
          return this;
        const result = {};
        for (const k3 of Object.keys(this.values)) {
          result[k3] = asNumber(fn(this.values[k3], k3));
        }
        return clone$1(this, { values: result }, true);
      }
      /**
       * Get the value of unit.
       * @param {string} unit - a unit such as 'minute' or 'day'
       * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
       * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
       * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
       * @return {number}
       */
      get(unit) {
        return this[Duration.normalizeUnit(unit)];
      }
      /**
       * "Set" the values of specified units. Return a newly-constructed Duration.
       * @param {Object} values - a mapping of units to numbers
       * @example dur.set({ years: 2017 })
       * @example dur.set({ hours: 8, minutes: 30 })
       * @return {Duration}
       */
      set(values) {
        if (!this.isValid)
          return this;
        const mixed = { ...this.values, ...normalizeObject(values, Duration.normalizeUnit) };
        return clone$1(this, { values: mixed });
      }
      /**
       * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
       * @example dur.reconfigure({ locale: 'en-GB' })
       * @return {Duration}
       */
      reconfigure({ locale, numberingSystem, conversionAccuracy, matrix } = {}) {
        const loc = this.loc.clone({ locale, numberingSystem });
        const opts = { loc, matrix, conversionAccuracy };
        return clone$1(this, opts);
      }
      /**
       * Return the length of the duration in the specified unit.
       * @param {string} unit - a unit such as 'minutes' or 'days'
       * @example Duration.fromObject({years: 1}).as('days') //=> 365
       * @example Duration.fromObject({years: 1}).as('months') //=> 12
       * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
       * @return {number}
       */
      as(unit) {
        return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
      }
      /**
       * Reduce this Duration to its canonical representation in its current units.
       * Assuming the overall value of the Duration is positive, this means:
       * - excessive values for lower-order units are converted to higher-order units (if possible, see first and second example)
       * - negative lower-order units are converted to higher order units (there must be such a higher order unit, otherwise
       *   the overall value would be negative, see second example)
       * - fractional values for higher-order units are converted to lower-order units (if possible, see fourth example)
       *
       * If the overall value is negative, the result of this method is equivalent to `this.negate().normalize().negate()`.
       * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
       * @example Duration.fromObject({ days: 5000 }).normalize().toObject() //=> { days: 5000 }
       * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
       * @example Duration.fromObject({ years: 2.5, days: 0, hours: 0 }).normalize().toObject() //=> { years: 2, days: 182, hours: 12 }
       * @return {Duration}
       */
      normalize() {
        if (!this.isValid)
          return this;
        const vals = this.toObject();
        normalizeValues(this.matrix, vals);
        return clone$1(this, { values: vals }, true);
      }
      /**
       * Rescale units to its largest representation
       * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }
       * @return {Duration}
       */
      rescale() {
        if (!this.isValid)
          return this;
        const vals = removeZeroes(this.normalize().shiftToAll().toObject());
        return clone$1(this, { values: vals }, true);
      }
      /**
       * Convert this Duration into its representation in a different set of units.
       * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
       * @return {Duration}
       */
      shiftTo(...units) {
        if (!this.isValid)
          return this;
        if (units.length === 0) {
          return this;
        }
        units = units.map((u3) => Duration.normalizeUnit(u3));
        const built = {}, accumulated = {}, vals = this.toObject();
        let lastUnit;
        for (const k3 of orderedUnits$1) {
          if (units.indexOf(k3) >= 0) {
            lastUnit = k3;
            let own = 0;
            for (const ak in accumulated) {
              own += this.matrix[ak][k3] * accumulated[ak];
              accumulated[ak] = 0;
            }
            if (isNumber2(vals[k3])) {
              own += vals[k3];
            }
            const i3 = Math.trunc(own);
            built[k3] = i3;
            accumulated[k3] = (own * 1e3 - i3 * 1e3) / 1e3;
          } else if (isNumber2(vals[k3])) {
            accumulated[k3] = vals[k3];
          }
        }
        for (const key in accumulated) {
          if (accumulated[key] !== 0) {
            built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
          }
        }
        normalizeValues(this.matrix, built);
        return clone$1(this, { values: built }, true);
      }
      /**
       * Shift this Duration to all available units.
       * Same as shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds")
       * @return {Duration}
       */
      shiftToAll() {
        if (!this.isValid)
          return this;
        return this.shiftTo(
          "years",
          "months",
          "weeks",
          "days",
          "hours",
          "minutes",
          "seconds",
          "milliseconds"
        );
      }
      /**
       * Return the negative of this Duration.
       * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
       * @return {Duration}
       */
      negate() {
        if (!this.isValid)
          return this;
        const negated = {};
        for (const k3 of Object.keys(this.values)) {
          negated[k3] = this.values[k3] === 0 ? 0 : -this.values[k3];
        }
        return clone$1(this, { values: negated }, true);
      }
      /**
       * Get the years.
       * @type {number}
       */
      get years() {
        return this.isValid ? this.values.years || 0 : NaN;
      }
      /**
       * Get the quarters.
       * @type {number}
       */
      get quarters() {
        return this.isValid ? this.values.quarters || 0 : NaN;
      }
      /**
       * Get the months.
       * @type {number}
       */
      get months() {
        return this.isValid ? this.values.months || 0 : NaN;
      }
      /**
       * Get the weeks
       * @type {number}
       */
      get weeks() {
        return this.isValid ? this.values.weeks || 0 : NaN;
      }
      /**
       * Get the days.
       * @type {number}
       */
      get days() {
        return this.isValid ? this.values.days || 0 : NaN;
      }
      /**
       * Get the hours.
       * @type {number}
       */
      get hours() {
        return this.isValid ? this.values.hours || 0 : NaN;
      }
      /**
       * Get the minutes.
       * @type {number}
       */
      get minutes() {
        return this.isValid ? this.values.minutes || 0 : NaN;
      }
      /**
       * Get the seconds.
       * @return {number}
       */
      get seconds() {
        return this.isValid ? this.values.seconds || 0 : NaN;
      }
      /**
       * Get the milliseconds.
       * @return {number}
       */
      get milliseconds() {
        return this.isValid ? this.values.milliseconds || 0 : NaN;
      }
      /**
       * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
       * on invalid DateTimes or Intervals.
       * @return {boolean}
       */
      get isValid() {
        return this.invalid === null;
      }
      /**
       * Returns an error code if this Duration became invalid, or null if the Duration is valid
       * @return {string}
       */
      get invalidReason() {
        return this.invalid ? this.invalid.reason : null;
      }
      /**
       * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
       * @type {string}
       */
      get invalidExplanation() {
        return this.invalid ? this.invalid.explanation : null;
      }
      /**
       * Equality check
       * Two Durations are equal iff they have the same units and the same values for each unit.
       * @param {Duration} other
       * @return {boolean}
       */
      equals(other) {
        if (!this.isValid || !other.isValid) {
          return false;
        }
        if (!this.loc.equals(other.loc)) {
          return false;
        }
        function eq(v1, v22) {
          if (v1 === void 0 || v1 === 0)
            return v22 === void 0 || v22 === 0;
          return v1 === v22;
        }
        for (const u3 of orderedUnits$1) {
          if (!eq(this.values[u3], other.values[u3])) {
            return false;
          }
        }
        return true;
      }
    };
    var INVALID$1 = "Invalid Interval";
    function validateStartEnd(start, end) {
      if (!start || !start.isValid) {
        return Interval.invalid("missing or invalid start");
      } else if (!end || !end.isValid) {
        return Interval.invalid("missing or invalid end");
      } else if (end < start) {
        return Interval.invalid(
          "end before start",
          `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`
        );
      } else {
        return null;
      }
    }
    var Interval = class {
      /**
       * @private
       */
      constructor(config2) {
        this.s = config2.start;
        this.e = config2.end;
        this.invalid = config2.invalid || null;
        this.isLuxonInterval = true;
      }
      /**
       * Create an invalid Interval.
       * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
       * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
       * @return {Interval}
       */
      static invalid(reason, explanation = null) {
        if (!reason) {
          throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
        }
        const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
        if (Settings.throwOnInvalid) {
          throw new InvalidIntervalError(invalid);
        } else {
          return new Interval({ invalid });
        }
      }
      /**
       * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
       * @param {DateTime|Date|Object} start
       * @param {DateTime|Date|Object} end
       * @return {Interval}
       */
      static fromDateTimes(start, end) {
        const builtStart = friendlyDateTime(start), builtEnd = friendlyDateTime(end);
        const validateError = validateStartEnd(builtStart, builtEnd);
        if (validateError == null) {
          return new Interval({
            start: builtStart,
            end: builtEnd
          });
        } else {
          return validateError;
        }
      }
      /**
       * Create an Interval from a start DateTime and a Duration to extend to.
       * @param {DateTime|Date|Object} start
       * @param {Duration|Object|number} duration - the length of the Interval.
       * @return {Interval}
       */
      static after(start, duration) {
        const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(start);
        return Interval.fromDateTimes(dt, dt.plus(dur));
      }
      /**
       * Create an Interval from an end DateTime and a Duration to extend backwards to.
       * @param {DateTime|Date|Object} end
       * @param {Duration|Object|number} duration - the length of the Interval.
       * @return {Interval}
       */
      static before(end, duration) {
        const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(end);
        return Interval.fromDateTimes(dt.minus(dur), dt);
      }
      /**
       * Create an Interval from an ISO 8601 string.
       * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
       * @param {string} text - the ISO string to parse
       * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @return {Interval}
       */
      static fromISO(text, opts) {
        const [s4, e3] = (text || "").split("/", 2);
        if (s4 && e3) {
          let start, startIsValid;
          try {
            start = DateTime2.fromISO(s4, opts);
            startIsValid = start.isValid;
          } catch (e4) {
            startIsValid = false;
          }
          let end, endIsValid;
          try {
            end = DateTime2.fromISO(e3, opts);
            endIsValid = end.isValid;
          } catch (e4) {
            endIsValid = false;
          }
          if (startIsValid && endIsValid) {
            return Interval.fromDateTimes(start, end);
          }
          if (startIsValid) {
            const dur = Duration.fromISO(e3, opts);
            if (dur.isValid) {
              return Interval.after(start, dur);
            }
          } else if (endIsValid) {
            const dur = Duration.fromISO(s4, opts);
            if (dur.isValid) {
              return Interval.before(end, dur);
            }
          }
        }
        return Interval.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
      }
      /**
       * Check if an object is an Interval. Works across context boundaries
       * @param {object} o
       * @return {boolean}
       */
      static isInterval(o2) {
        return o2 && o2.isLuxonInterval || false;
      }
      /**
       * Returns the start of the Interval
       * @type {DateTime}
       */
      get start() {
        return this.isValid ? this.s : null;
      }
      /**
       * Returns the end of the Interval
       * @type {DateTime}
       */
      get end() {
        return this.isValid ? this.e : null;
      }
      /**
       * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
       * @type {boolean}
       */
      get isValid() {
        return this.invalidReason === null;
      }
      /**
       * Returns an error code if this Interval is invalid, or null if the Interval is valid
       * @type {string}
       */
      get invalidReason() {
        return this.invalid ? this.invalid.reason : null;
      }
      /**
       * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
       * @type {string}
       */
      get invalidExplanation() {
        return this.invalid ? this.invalid.explanation : null;
      }
      /**
       * Returns the length of the Interval in the specified unit.
       * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
       * @return {number}
       */
      length(unit = "milliseconds") {
        return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;
      }
      /**
       * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
       * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
       * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
       * @param {string} [unit='milliseconds'] - the unit of time to count.
       * @return {number}
       */
      count(unit = "milliseconds") {
        if (!this.isValid)
          return NaN;
        const start = this.start.startOf(unit), end = this.end.startOf(unit);
        return Math.floor(end.diff(start, unit).get(unit)) + (end.valueOf() !== this.end.valueOf());
      }
      /**
       * Returns whether this Interval's start and end are both in the same unit of time
       * @param {string} unit - the unit of time to check sameness on
       * @return {boolean}
       */
      hasSame(unit) {
        return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
      }
      /**
       * Return whether this Interval has the same start and end DateTimes.
       * @return {boolean}
       */
      isEmpty() {
        return this.s.valueOf() === this.e.valueOf();
      }
      /**
       * Return whether this Interval's start is after the specified DateTime.
       * @param {DateTime} dateTime
       * @return {boolean}
       */
      isAfter(dateTime) {
        if (!this.isValid)
          return false;
        return this.s > dateTime;
      }
      /**
       * Return whether this Interval's end is before the specified DateTime.
       * @param {DateTime} dateTime
       * @return {boolean}
       */
      isBefore(dateTime) {
        if (!this.isValid)
          return false;
        return this.e <= dateTime;
      }
      /**
       * Return whether this Interval contains the specified DateTime.
       * @param {DateTime} dateTime
       * @return {boolean}
       */
      contains(dateTime) {
        if (!this.isValid)
          return false;
        return this.s <= dateTime && this.e > dateTime;
      }
      /**
       * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
       * @param {Object} values - the values to set
       * @param {DateTime} values.start - the starting DateTime
       * @param {DateTime} values.end - the ending DateTime
       * @return {Interval}
       */
      set({ start, end } = {}) {
        if (!this.isValid)
          return this;
        return Interval.fromDateTimes(start || this.s, end || this.e);
      }
      /**
       * Split this Interval at each of the specified DateTimes
       * @param {...DateTime} dateTimes - the unit of time to count.
       * @return {Array}
       */
      splitAt(...dateTimes) {
        if (!this.isValid)
          return [];
        const sorted = dateTimes.map(friendlyDateTime).filter((d2) => this.contains(d2)).sort(), results = [];
        let { s: s4 } = this, i3 = 0;
        while (s4 < this.e) {
          const added = sorted[i3] || this.e, next = +added > +this.e ? this.e : added;
          results.push(Interval.fromDateTimes(s4, next));
          s4 = next;
          i3 += 1;
        }
        return results;
      }
      /**
       * Split this Interval into smaller Intervals, each of the specified length.
       * Left over time is grouped into a smaller interval
       * @param {Duration|Object|number} duration - The length of each resulting interval.
       * @return {Array}
       */
      splitBy(duration) {
        const dur = Duration.fromDurationLike(duration);
        if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
          return [];
        }
        let { s: s4 } = this, idx = 1, next;
        const results = [];
        while (s4 < this.e) {
          const added = this.start.plus(dur.mapUnits((x4) => x4 * idx));
          next = +added > +this.e ? this.e : added;
          results.push(Interval.fromDateTimes(s4, next));
          s4 = next;
          idx += 1;
        }
        return results;
      }
      /**
       * Split this Interval into the specified number of smaller intervals.
       * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
       * @return {Array}
       */
      divideEqually(numberOfParts) {
        if (!this.isValid)
          return [];
        return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
      }
      /**
       * Return whether this Interval overlaps with the specified Interval
       * @param {Interval} other
       * @return {boolean}
       */
      overlaps(other) {
        return this.e > other.s && this.s < other.e;
      }
      /**
       * Return whether this Interval's end is adjacent to the specified Interval's start.
       * @param {Interval} other
       * @return {boolean}
       */
      abutsStart(other) {
        if (!this.isValid)
          return false;
        return +this.e === +other.s;
      }
      /**
       * Return whether this Interval's start is adjacent to the specified Interval's end.
       * @param {Interval} other
       * @return {boolean}
       */
      abutsEnd(other) {
        if (!this.isValid)
          return false;
        return +other.e === +this.s;
      }
      /**
       * Return whether this Interval engulfs the start and end of the specified Interval.
       * @param {Interval} other
       * @return {boolean}
       */
      engulfs(other) {
        if (!this.isValid)
          return false;
        return this.s <= other.s && this.e >= other.e;
      }
      /**
       * Return whether this Interval has the same start and end as the specified Interval.
       * @param {Interval} other
       * @return {boolean}
       */
      equals(other) {
        if (!this.isValid || !other.isValid) {
          return false;
        }
        return this.s.equals(other.s) && this.e.equals(other.e);
      }
      /**
       * Return an Interval representing the intersection of this Interval and the specified Interval.
       * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
       * Returns null if the intersection is empty, meaning, the intervals don't intersect.
       * @param {Interval} other
       * @return {Interval}
       */
      intersection(other) {
        if (!this.isValid)
          return this;
        const s4 = this.s > other.s ? this.s : other.s, e3 = this.e < other.e ? this.e : other.e;
        if (s4 >= e3) {
          return null;
        } else {
          return Interval.fromDateTimes(s4, e3);
        }
      }
      /**
       * Return an Interval representing the union of this Interval and the specified Interval.
       * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
       * @param {Interval} other
       * @return {Interval}
       */
      union(other) {
        if (!this.isValid)
          return this;
        const s4 = this.s < other.s ? this.s : other.s, e3 = this.e > other.e ? this.e : other.e;
        return Interval.fromDateTimes(s4, e3);
      }
      /**
       * Merge an array of Intervals into a equivalent minimal set of Intervals.
       * Combines overlapping and adjacent Intervals.
       * @param {Array} intervals
       * @return {Array}
       */
      static merge(intervals) {
        const [found, final] = intervals.sort((a3, b3) => a3.s - b3.s).reduce(
          ([sofar, current], item) => {
            if (!current) {
              return [sofar, item];
            } else if (current.overlaps(item) || current.abutsStart(item)) {
              return [sofar, current.union(item)];
            } else {
              return [sofar.concat([current]), item];
            }
          },
          [[], null]
        );
        if (final) {
          found.push(final);
        }
        return found;
      }
      /**
       * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
       * @param {Array} intervals
       * @return {Array}
       */
      static xor(intervals) {
        let start = null, currentCount = 0;
        const results = [], ends = intervals.map((i3) => [
          { time: i3.s, type: "s" },
          { time: i3.e, type: "e" }
        ]), flattened = Array.prototype.concat(...ends), arr = flattened.sort((a3, b3) => a3.time - b3.time);
        for (const i3 of arr) {
          currentCount += i3.type === "s" ? 1 : -1;
          if (currentCount === 1) {
            start = i3.time;
          } else {
            if (start && +start !== +i3.time) {
              results.push(Interval.fromDateTimes(start, i3.time));
            }
            start = null;
          }
        }
        return Interval.merge(results);
      }
      /**
       * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
       * @param {...Interval} intervals
       * @return {Array}
       */
      difference(...intervals) {
        return Interval.xor([this].concat(intervals)).map((i3) => this.intersection(i3)).filter((i3) => i3 && !i3.isEmpty());
      }
      /**
       * Returns a string representation of this Interval appropriate for debugging.
       * @return {string}
       */
      toString() {
        if (!this.isValid)
          return INVALID$1;
        return `[${this.s.toISO()} \u2013 ${this.e.toISO()})`;
      }
      /**
       * Returns a localized string representing this Interval. Accepts the same options as the
       * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as
       * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method
       * is browser-specific, but in general it will return an appropriate representation of the
       * Interval in the assigned locale. Defaults to the system's locale if no locale has been
       * specified.
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or
       * Intl.DateTimeFormat constructor options.
       * @param {Object} opts - Options to override the configuration of the start DateTime.
       * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022 – 11/8/2022
       * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7 – 8, 2022
       * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 7–8 novembre 2022
       * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00 – 8:00 PM
       * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00 – 8:00 p
       * @return {string}
       */
      toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
        return this.isValid ? Formatter.create(this.s.loc.clone(opts), formatOpts).formatInterval(this) : INVALID$1;
      }
      /**
       * Returns an ISO 8601-compliant string representation of this Interval.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @param {Object} opts - The same options as {@link DateTime#toISO}
       * @return {string}
       */
      toISO(opts) {
        if (!this.isValid)
          return INVALID$1;
        return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
      }
      /**
       * Returns an ISO 8601-compliant string representation of date of this Interval.
       * The time components are ignored.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @return {string}
       */
      toISODate() {
        if (!this.isValid)
          return INVALID$1;
        return `${this.s.toISODate()}/${this.e.toISODate()}`;
      }
      /**
       * Returns an ISO 8601-compliant string representation of time of this Interval.
       * The date components are ignored.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @param {Object} opts - The same options as {@link DateTime#toISO}
       * @return {string}
       */
      toISOTime(opts) {
        if (!this.isValid)
          return INVALID$1;
        return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
      }
      /**
       * Returns a string representation of this Interval formatted according to the specified format
       * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible
       * formatting tool.
       * @param {string} dateFormat - The format string. This string formats the start and end time.
       * See {@link DateTime#toFormat} for details.
       * @param {Object} opts - Options.
       * @param {string} [opts.separator =  ' – '] - A separator to place between the start and end
       * representations.
       * @return {string}
       */
      toFormat(dateFormat, { separator = " \u2013 " } = {}) {
        if (!this.isValid)
          return INVALID$1;
        return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
      }
      /**
       * Return a Duration representing the time spanned by this interval.
       * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
       * @param {Object} opts - options that affect the creation of the Duration
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
       * @return {Duration}
       */
      toDuration(unit, opts) {
        if (!this.isValid) {
          return Duration.invalid(this.invalidReason);
        }
        return this.e.diff(this.s, unit, opts);
      }
      /**
       * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
       * @param {function} mapFn
       * @return {Interval}
       * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
       * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
       */
      mapEndpoints(mapFn) {
        return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
      }
    };
    var Info = class {
      /**
       * Return whether the specified zone contains a DST.
       * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
       * @return {boolean}
       */
      static hasDST(zone = Settings.defaultZone) {
        const proto = DateTime2.now().setZone(zone).set({ month: 12 });
        return !zone.isUniversal && proto.offset !== proto.set({ month: 6 }).offset;
      }
      /**
       * Return whether the specified zone is a valid IANA specifier.
       * @param {string} zone - Zone to check
       * @return {boolean}
       */
      static isValidIANAZone(zone) {
        return IANAZone.isValidZone(zone);
      }
      /**
       * Converts the input into a {@link Zone} instance.
       *
       * * If `input` is already a Zone instance, it is returned unchanged.
       * * If `input` is a string containing a valid time zone name, a Zone instance
       *   with that name is returned.
       * * If `input` is a string that doesn't refer to a known time zone, a Zone
       *   instance with {@link Zone#isValid} == false is returned.
       * * If `input is a number, a Zone instance with the specified fixed offset
       *   in minutes is returned.
       * * If `input` is `null` or `undefined`, the default zone is returned.
       * @param {string|Zone|number} [input] - the value to be converted
       * @return {Zone}
       */
      static normalizeZone(input) {
        return normalizeZone(input, Settings.defaultZone);
      }
      /**
       * Return an array of standalone month names.
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @param {string} [opts.outputCalendar='gregory'] - the calendar
       * @example Info.months()[0] //=> 'January'
       * @example Info.months('short')[0] //=> 'Jan'
       * @example Info.months('numeric')[0] //=> '1'
       * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
       * @example Info.months('numeric', { locale: 'ar' })[0] //=> '١'
       * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabiʻ I'
       * @return {Array}
       */
      static months(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
        return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length);
      }
      /**
       * Return an array of format month names.
       * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
       * changes the string.
       * See {@link Info#months}
       * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @param {string} [opts.outputCalendar='gregory'] - the calendar
       * @return {Array}
       */
      static monthsFormat(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
        return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length, true);
      }
      /**
       * Return an array of standalone week names.
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @example Info.weekdays()[0] //=> 'Monday'
       * @example Info.weekdays('short')[0] //=> 'Mon'
       * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
       * @example Info.weekdays('short', { locale: 'ar' })[0] //=> 'الاثنين'
       * @return {Array}
       */
      static weekdays(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
        return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length);
      }
      /**
       * Return an array of format week names.
       * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
       * changes the string.
       * See {@link Info#weekdays}
       * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
       * @param {Object} opts - options
       * @param {string} [opts.locale=null] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @return {Array}
       */
      static weekdaysFormat(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
        return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length, true);
      }
      /**
       * Return an array of meridiems.
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @example Info.meridiems() //=> [ 'AM', 'PM' ]
       * @example Info.meridiems({ locale: 'my' }) //=> [ 'နံနက်', 'ညနေ' ]
       * @return {Array}
       */
      static meridiems({ locale = null } = {}) {
        return Locale.create(locale).meridiems();
      }
      /**
       * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
       * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @example Info.eras() //=> [ 'BC', 'AD' ]
       * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
       * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jésus-Christ', 'après Jésus-Christ' ]
       * @return {Array}
       */
      static eras(length = "short", { locale = null } = {}) {
        return Locale.create(locale, null, "gregory").eras(length);
      }
      /**
       * Return the set of available features in this environment.
       * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
       * Keys:
       * * `relative`: whether this environment supports relative time formatting
       * @example Info.features() //=> { relative: false }
       * @return {Object}
       */
      static features() {
        return { relative: hasRelative() };
      }
    };
    function dayDiff(earlier, later) {
      const utcDayStart = (dt) => dt.toUTC(0, { keepLocalTime: true }).startOf("day").valueOf(), ms = utcDayStart(later) - utcDayStart(earlier);
      return Math.floor(Duration.fromMillis(ms).as("days"));
    }
    function highOrderDiffs(cursor, later, units) {
      const differs = [
        ["years", (a3, b3) => b3.year - a3.year],
        ["quarters", (a3, b3) => b3.quarter - a3.quarter + (b3.year - a3.year) * 4],
        ["months", (a3, b3) => b3.month - a3.month + (b3.year - a3.year) * 12],
        [
          "weeks",
          (a3, b3) => {
            const days = dayDiff(a3, b3);
            return (days - days % 7) / 7;
          }
        ],
        ["days", dayDiff]
      ];
      const results = {};
      const earlier = cursor;
      let lowestOrder, highWater;
      for (const [unit, differ] of differs) {
        if (units.indexOf(unit) >= 0) {
          lowestOrder = unit;
          results[unit] = differ(cursor, later);
          highWater = earlier.plus(results);
          if (highWater > later) {
            results[unit]--;
            cursor = earlier.plus(results);
            if (cursor > later) {
              highWater = cursor;
              results[unit]--;
              cursor = earlier.plus(results);
            }
          } else {
            cursor = highWater;
          }
        }
      }
      return [cursor, results, highWater, lowestOrder];
    }
    function diff(earlier, later, units, opts) {
      let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);
      const remainingMillis = later - cursor;
      const lowerOrderUnits = units.filter(
        (u3) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u3) >= 0
      );
      if (lowerOrderUnits.length === 0) {
        if (highWater < later) {
          highWater = cursor.plus({ [lowestOrder]: 1 });
        }
        if (highWater !== cursor) {
          results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
        }
      }
      const duration = Duration.fromObject(results, opts);
      if (lowerOrderUnits.length > 0) {
        return Duration.fromMillis(remainingMillis, opts).shiftTo(...lowerOrderUnits).plus(duration);
      } else {
        return duration;
      }
    }
    var numberingSystems = {
      arab: "[\u0660-\u0669]",
      arabext: "[\u06F0-\u06F9]",
      bali: "[\u1B50-\u1B59]",
      beng: "[\u09E6-\u09EF]",
      deva: "[\u0966-\u096F]",
      fullwide: "[\uFF10-\uFF19]",
      gujr: "[\u0AE6-\u0AEF]",
      hanidec: "[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]",
      khmr: "[\u17E0-\u17E9]",
      knda: "[\u0CE6-\u0CEF]",
      laoo: "[\u0ED0-\u0ED9]",
      limb: "[\u1946-\u194F]",
      mlym: "[\u0D66-\u0D6F]",
      mong: "[\u1810-\u1819]",
      mymr: "[\u1040-\u1049]",
      orya: "[\u0B66-\u0B6F]",
      tamldec: "[\u0BE6-\u0BEF]",
      telu: "[\u0C66-\u0C6F]",
      thai: "[\u0E50-\u0E59]",
      tibt: "[\u0F20-\u0F29]",
      latn: "\\d"
    };
    var numberingSystemsUTF16 = {
      arab: [1632, 1641],
      arabext: [1776, 1785],
      bali: [6992, 7001],
      beng: [2534, 2543],
      deva: [2406, 2415],
      fullwide: [65296, 65303],
      gujr: [2790, 2799],
      khmr: [6112, 6121],
      knda: [3302, 3311],
      laoo: [3792, 3801],
      limb: [6470, 6479],
      mlym: [3430, 3439],
      mong: [6160, 6169],
      mymr: [4160, 4169],
      orya: [2918, 2927],
      tamldec: [3046, 3055],
      telu: [3174, 3183],
      thai: [3664, 3673],
      tibt: [3872, 3881]
    };
    var hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
    function parseDigits(str) {
      let value = parseInt(str, 10);
      if (isNaN(value)) {
        value = "";
        for (let i3 = 0; i3 < str.length; i3++) {
          const code = str.charCodeAt(i3);
          if (str[i3].search(numberingSystems.hanidec) !== -1) {
            value += hanidecChars.indexOf(str[i3]);
          } else {
            for (const key in numberingSystemsUTF16) {
              const [min, max] = numberingSystemsUTF16[key];
              if (code >= min && code <= max) {
                value += code - min;
              }
            }
          }
        }
        return parseInt(value, 10);
      } else {
        return value;
      }
    }
    function digitRegex({ numberingSystem }, append = "") {
      return new RegExp(`${numberingSystems[numberingSystem || "latn"]}${append}`);
    }
    var MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
    function intUnit(regex, post = (i3) => i3) {
      return { regex, deser: ([s4]) => post(parseDigits(s4)) };
    }
    var NBSP = String.fromCharCode(160);
    var spaceOrNBSP = `[ ${NBSP}]`;
    var spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
    function fixListRegex(s4) {
      return s4.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
    }
    function stripInsensitivities(s4) {
      return s4.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
    }
    function oneOf(strings, startIndex) {
      if (strings === null) {
        return null;
      } else {
        return {
          regex: RegExp(strings.map(fixListRegex).join("|")),
          deser: ([s4]) => strings.findIndex((i3) => stripInsensitivities(s4) === stripInsensitivities(i3)) + startIndex
        };
      }
    }
    function offset(regex, groups) {
      return { regex, deser: ([, h3, m3]) => signedOffset(h3, m3), groups };
    }
    function simple(regex) {
      return { regex, deser: ([s4]) => s4 };
    }
    function escapeToken(value) {
      return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
    }
    function unitForToken(token, loc) {
      const one = digitRegex(loc), two = digitRegex(loc, "{2}"), three = digitRegex(loc, "{3}"), four = digitRegex(loc, "{4}"), six = digitRegex(loc, "{6}"), oneOrTwo = digitRegex(loc, "{1,2}"), oneToThree = digitRegex(loc, "{1,3}"), oneToSix = digitRegex(loc, "{1,6}"), oneToNine = digitRegex(loc, "{1,9}"), twoToFour = digitRegex(loc, "{2,4}"), fourToSix = digitRegex(loc, "{4,6}"), literal = (t3) => ({ regex: RegExp(escapeToken(t3.val)), deser: ([s4]) => s4, literal: true }), unitate = (t3) => {
        if (token.literal) {
          return literal(t3);
        }
        switch (t3.val) {
          case "G":
            return oneOf(loc.eras("short"), 0);
          case "GG":
            return oneOf(loc.eras("long"), 0);
          case "y":
            return intUnit(oneToSix);
          case "yy":
            return intUnit(twoToFour, untruncateYear);
          case "yyyy":
            return intUnit(four);
          case "yyyyy":
            return intUnit(fourToSix);
          case "yyyyyy":
            return intUnit(six);
          case "M":
            return intUnit(oneOrTwo);
          case "MM":
            return intUnit(two);
          case "MMM":
            return oneOf(loc.months("short", true), 1);
          case "MMMM":
            return oneOf(loc.months("long", true), 1);
          case "L":
            return intUnit(oneOrTwo);
          case "LL":
            return intUnit(two);
          case "LLL":
            return oneOf(loc.months("short", false), 1);
          case "LLLL":
            return oneOf(loc.months("long", false), 1);
          case "d":
            return intUnit(oneOrTwo);
          case "dd":
            return intUnit(two);
          case "o":
            return intUnit(oneToThree);
          case "ooo":
            return intUnit(three);
          case "HH":
            return intUnit(two);
          case "H":
            return intUnit(oneOrTwo);
          case "hh":
            return intUnit(two);
          case "h":
            return intUnit(oneOrTwo);
          case "mm":
            return intUnit(two);
          case "m":
            return intUnit(oneOrTwo);
          case "q":
            return intUnit(oneOrTwo);
          case "qq":
            return intUnit(two);
          case "s":
            return intUnit(oneOrTwo);
          case "ss":
            return intUnit(two);
          case "S":
            return intUnit(oneToThree);
          case "SSS":
            return intUnit(three);
          case "u":
            return simple(oneToNine);
          case "uu":
            return simple(oneOrTwo);
          case "uuu":
            return intUnit(one);
          case "a":
            return oneOf(loc.meridiems(), 0);
          case "kkkk":
            return intUnit(four);
          case "kk":
            return intUnit(twoToFour, untruncateYear);
          case "W":
            return intUnit(oneOrTwo);
          case "WW":
            return intUnit(two);
          case "E":
          case "c":
            return intUnit(one);
          case "EEE":
            return oneOf(loc.weekdays("short", false), 1);
          case "EEEE":
            return oneOf(loc.weekdays("long", false), 1);
          case "ccc":
            return oneOf(loc.weekdays("short", true), 1);
          case "cccc":
            return oneOf(loc.weekdays("long", true), 1);
          case "Z":
          case "ZZ":
            return offset(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
          case "ZZZ":
            return offset(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
          case "z":
            return simple(/[a-z_+-/]{1,256}?/i);
          case " ":
            return simple(/[^\S\n\r]/);
          default:
            return literal(t3);
        }
      };
      const unit = unitate(token) || {
        invalidReason: MISSING_FTP
      };
      unit.token = token;
      return unit;
    }
    var partTypeStyleToTokenVal = {
      year: {
        "2-digit": "yy",
        numeric: "yyyyy"
      },
      month: {
        numeric: "M",
        "2-digit": "MM",
        short: "MMM",
        long: "MMMM"
      },
      day: {
        numeric: "d",
        "2-digit": "dd"
      },
      weekday: {
        short: "EEE",
        long: "EEEE"
      },
      dayperiod: "a",
      dayPeriod: "a",
      hour12: {
        numeric: "h",
        "2-digit": "hh"
      },
      hour24: {
        numeric: "H",
        "2-digit": "HH"
      },
      minute: {
        numeric: "m",
        "2-digit": "mm"
      },
      second: {
        numeric: "s",
        "2-digit": "ss"
      },
      timeZoneName: {
        long: "ZZZZZ",
        short: "ZZZ"
      }
    };
    function tokenForPart(part, formatOpts, resolvedOpts) {
      const { type, value } = part;
      if (type === "literal") {
        const isSpace = /^\s+$/.test(value);
        return {
          literal: !isSpace,
          val: isSpace ? " " : value
        };
      }
      const style = formatOpts[type];
      let actualType = type;
      if (type === "hour") {
        if (formatOpts.hour12 != null) {
          actualType = formatOpts.hour12 ? "hour12" : "hour24";
        } else if (formatOpts.hourCycle != null) {
          if (formatOpts.hourCycle === "h11" || formatOpts.hourCycle === "h12") {
            actualType = "hour12";
          } else {
            actualType = "hour24";
          }
        } else {
          actualType = resolvedOpts.hour12 ? "hour12" : "hour24";
        }
      }
      let val = partTypeStyleToTokenVal[actualType];
      if (typeof val === "object") {
        val = val[style];
      }
      if (val) {
        return {
          literal: false,
          val
        };
      }
      return void 0;
    }
    function buildRegex(units) {
      const re = units.map((u3) => u3.regex).reduce((f3, r3) => `${f3}(${r3.source})`, "");
      return [`^${re}$`, units];
    }
    function match(input, regex, handlers) {
      const matches = input.match(regex);
      if (matches) {
        const all = {};
        let matchIndex = 1;
        for (const i3 in handlers) {
          if (hasOwnProperty2(handlers, i3)) {
            const h3 = handlers[i3], groups = h3.groups ? h3.groups + 1 : 1;
            if (!h3.literal && h3.token) {
              all[h3.token.val[0]] = h3.deser(matches.slice(matchIndex, matchIndex + groups));
            }
            matchIndex += groups;
          }
        }
        return [matches, all];
      } else {
        return [matches, {}];
      }
    }
    function dateTimeFromMatches(matches) {
      const toField = (token) => {
        switch (token) {
          case "S":
            return "millisecond";
          case "s":
            return "second";
          case "m":
            return "minute";
          case "h":
          case "H":
            return "hour";
          case "d":
            return "day";
          case "o":
            return "ordinal";
          case "L":
          case "M":
            return "month";
          case "y":
            return "year";
          case "E":
          case "c":
            return "weekday";
          case "W":
            return "weekNumber";
          case "k":
            return "weekYear";
          case "q":
            return "quarter";
          default:
            return null;
        }
      };
      let zone = null;
      let specificOffset;
      if (!isUndefined(matches.z)) {
        zone = IANAZone.create(matches.z);
      }
      if (!isUndefined(matches.Z)) {
        if (!zone) {
          zone = new FixedOffsetZone(matches.Z);
        }
        specificOffset = matches.Z;
      }
      if (!isUndefined(matches.q)) {
        matches.M = (matches.q - 1) * 3 + 1;
      }
      if (!isUndefined(matches.h)) {
        if (matches.h < 12 && matches.a === 1) {
          matches.h += 12;
        } else if (matches.h === 12 && matches.a === 0) {
          matches.h = 0;
        }
      }
      if (matches.G === 0 && matches.y) {
        matches.y = -matches.y;
      }
      if (!isUndefined(matches.u)) {
        matches.S = parseMillis(matches.u);
      }
      const vals = Object.keys(matches).reduce((r3, k3) => {
        const f3 = toField(k3);
        if (f3) {
          r3[f3] = matches[k3];
        }
        return r3;
      }, {});
      return [vals, zone, specificOffset];
    }
    var dummyDateTimeCache = null;
    function getDummyDateTime() {
      if (!dummyDateTimeCache) {
        dummyDateTimeCache = DateTime2.fromMillis(1555555555555);
      }
      return dummyDateTimeCache;
    }
    function maybeExpandMacroToken(token, locale) {
      if (token.literal) {
        return token;
      }
      const formatOpts = Formatter.macroTokenToFormatOpts(token.val);
      const tokens = formatOptsToTokens(formatOpts, locale);
      if (tokens == null || tokens.includes(void 0)) {
        return token;
      }
      return tokens;
    }
    function expandMacroTokens(tokens, locale) {
      return Array.prototype.concat(...tokens.map((t3) => maybeExpandMacroToken(t3, locale)));
    }
    function explainFromTokens(locale, input, format) {
      const tokens = expandMacroTokens(Formatter.parseFormat(format), locale), units = tokens.map((t3) => unitForToken(t3, locale)), disqualifyingUnit = units.find((t3) => t3.invalidReason);
      if (disqualifyingUnit) {
        return { input, tokens, invalidReason: disqualifyingUnit.invalidReason };
      } else {
        const [regexString, handlers] = buildRegex(units), regex = RegExp(regexString, "i"), [rawMatches, matches] = match(input, regex, handlers), [result, zone, specificOffset] = matches ? dateTimeFromMatches(matches) : [null, null, void 0];
        if (hasOwnProperty2(matches, "a") && hasOwnProperty2(matches, "H")) {
          throw new ConflictingSpecificationError(
            "Can't include meridiem when specifying 24-hour format"
          );
        }
        return { input, tokens, regex, rawMatches, matches, result, zone, specificOffset };
      }
    }
    function parseFromTokens(locale, input, format) {
      const { result, zone, specificOffset, invalidReason } = explainFromTokens(locale, input, format);
      return [result, zone, specificOffset, invalidReason];
    }
    function formatOptsToTokens(formatOpts, locale) {
      if (!formatOpts) {
        return null;
      }
      const formatter = Formatter.create(locale, formatOpts);
      const df = formatter.dtFormatter(getDummyDateTime());
      const parts = df.formatToParts();
      const resolvedOpts = df.resolvedOptions();
      return parts.map((p3) => tokenForPart(p3, formatOpts, resolvedOpts));
    }
    var nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
    var leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
    function unitOutOfRange(unit, value) {
      return new Invalid(
        "unit out of range",
        `you specified ${value} (of type ${typeof value}) as a ${unit}, which is invalid`
      );
    }
    function dayOfWeek(year, month, day) {
      const d2 = new Date(Date.UTC(year, month - 1, day));
      if (year < 100 && year >= 0) {
        d2.setUTCFullYear(d2.getUTCFullYear() - 1900);
      }
      const js = d2.getUTCDay();
      return js === 0 ? 7 : js;
    }
    function computeOrdinal(year, month, day) {
      return day + (isLeapYear2(year) ? leapLadder : nonLeapLadder)[month - 1];
    }
    function uncomputeOrdinal(year, ordinal) {
      const table = isLeapYear2(year) ? leapLadder : nonLeapLadder, month0 = table.findIndex((i3) => i3 < ordinal), day = ordinal - table[month0];
      return { month: month0 + 1, day };
    }
    function gregorianToWeek(gregObj) {
      const { year, month, day } = gregObj, ordinal = computeOrdinal(year, month, day), weekday = dayOfWeek(year, month, day);
      let weekNumber = Math.floor((ordinal - weekday + 10) / 7), weekYear;
      if (weekNumber < 1) {
        weekYear = year - 1;
        weekNumber = weeksInWeekYear(weekYear);
      } else if (weekNumber > weeksInWeekYear(year)) {
        weekYear = year + 1;
        weekNumber = 1;
      } else {
        weekYear = year;
      }
      return { weekYear, weekNumber, weekday, ...timeObject(gregObj) };
    }
    function weekToGregorian(weekData) {
      const { weekYear, weekNumber, weekday } = weekData, weekdayOfJan4 = dayOfWeek(weekYear, 1, 4), yearInDays = daysInYear(weekYear);
      let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 3, year;
      if (ordinal < 1) {
        year = weekYear - 1;
        ordinal += daysInYear(year);
      } else if (ordinal > yearInDays) {
        year = weekYear + 1;
        ordinal -= daysInYear(weekYear);
      } else {
        year = weekYear;
      }
      const { month, day } = uncomputeOrdinal(year, ordinal);
      return { year, month, day, ...timeObject(weekData) };
    }
    function gregorianToOrdinal(gregData) {
      const { year, month, day } = gregData;
      const ordinal = computeOrdinal(year, month, day);
      return { year, ordinal, ...timeObject(gregData) };
    }
    function ordinalToGregorian(ordinalData) {
      const { year, ordinal } = ordinalData;
      const { month, day } = uncomputeOrdinal(year, ordinal);
      return { year, month, day, ...timeObject(ordinalData) };
    }
    function hasInvalidWeekData(obj) {
      const validYear = isInteger(obj.weekYear), validWeek = integerBetween(obj.weekNumber, 1, weeksInWeekYear(obj.weekYear)), validWeekday = integerBetween(obj.weekday, 1, 7);
      if (!validYear) {
        return unitOutOfRange("weekYear", obj.weekYear);
      } else if (!validWeek) {
        return unitOutOfRange("week", obj.week);
      } else if (!validWeekday) {
        return unitOutOfRange("weekday", obj.weekday);
      } else
        return false;
    }
    function hasInvalidOrdinalData(obj) {
      const validYear = isInteger(obj.year), validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
      if (!validYear) {
        return unitOutOfRange("year", obj.year);
      } else if (!validOrdinal) {
        return unitOutOfRange("ordinal", obj.ordinal);
      } else
        return false;
    }
    function hasInvalidGregorianData(obj) {
      const validYear = isInteger(obj.year), validMonth = integerBetween(obj.month, 1, 12), validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
      if (!validYear) {
        return unitOutOfRange("year", obj.year);
      } else if (!validMonth) {
        return unitOutOfRange("month", obj.month);
      } else if (!validDay) {
        return unitOutOfRange("day", obj.day);
      } else
        return false;
    }
    function hasInvalidTimeData(obj) {
      const { hour, minute, second, millisecond } = obj;
      const validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0, validMinute = integerBetween(minute, 0, 59), validSecond = integerBetween(second, 0, 59), validMillisecond = integerBetween(millisecond, 0, 999);
      if (!validHour) {
        return unitOutOfRange("hour", hour);
      } else if (!validMinute) {
        return unitOutOfRange("minute", minute);
      } else if (!validSecond) {
        return unitOutOfRange("second", second);
      } else if (!validMillisecond) {
        return unitOutOfRange("millisecond", millisecond);
      } else
        return false;
    }
    var INVALID = "Invalid DateTime";
    var MAX_DATE = 864e13;
    function unsupportedZone(zone) {
      return new Invalid("unsupported zone", `the zone "${zone.name}" is not supported`);
    }
    function possiblyCachedWeekData(dt) {
      if (dt.weekData === null) {
        dt.weekData = gregorianToWeek(dt.c);
      }
      return dt.weekData;
    }
    function clone2(inst, alts) {
      const current = {
        ts: inst.ts,
        zone: inst.zone,
        c: inst.c,
        o: inst.o,
        loc: inst.loc,
        invalid: inst.invalid
      };
      return new DateTime2({ ...current, ...alts, old: current });
    }
    function fixOffset(localTS, o2, tz) {
      let utcGuess = localTS - o2 * 60 * 1e3;
      const o22 = tz.offset(utcGuess);
      if (o2 === o22) {
        return [utcGuess, o2];
      }
      utcGuess -= (o22 - o2) * 60 * 1e3;
      const o3 = tz.offset(utcGuess);
      if (o22 === o3) {
        return [utcGuess, o22];
      }
      return [localTS - Math.min(o22, o3) * 60 * 1e3, Math.max(o22, o3)];
    }
    function tsToObj(ts, offset2) {
      ts += offset2 * 60 * 1e3;
      const d2 = new Date(ts);
      return {
        year: d2.getUTCFullYear(),
        month: d2.getUTCMonth() + 1,
        day: d2.getUTCDate(),
        hour: d2.getUTCHours(),
        minute: d2.getUTCMinutes(),
        second: d2.getUTCSeconds(),
        millisecond: d2.getUTCMilliseconds()
      };
    }
    function objToTS(obj, offset2, zone) {
      return fixOffset(objToLocalTS(obj), offset2, zone);
    }
    function adjustTime(inst, dur) {
      const oPre = inst.o, year = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c3 = {
        ...inst.c,
        year,
        month,
        day: Math.min(inst.c.day, daysInMonth(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
      }, millisToAdd = Duration.fromObject({
        years: dur.years - Math.trunc(dur.years),
        quarters: dur.quarters - Math.trunc(dur.quarters),
        months: dur.months - Math.trunc(dur.months),
        weeks: dur.weeks - Math.trunc(dur.weeks),
        days: dur.days - Math.trunc(dur.days),
        hours: dur.hours,
        minutes: dur.minutes,
        seconds: dur.seconds,
        milliseconds: dur.milliseconds
      }).as("milliseconds"), localTS = objToLocalTS(c3);
      let [ts, o2] = fixOffset(localTS, oPre, inst.zone);
      if (millisToAdd !== 0) {
        ts += millisToAdd;
        o2 = inst.zone.offset(ts);
      }
      return { ts, o: o2 };
    }
    function parseDataToDateTime(parsed, parsedZone, opts, format, text, specificOffset) {
      const { setZone, zone } = opts;
      if (parsed && Object.keys(parsed).length !== 0 || parsedZone) {
        const interpretationZone = parsedZone || zone, inst = DateTime2.fromObject(parsed, {
          ...opts,
          zone: interpretationZone,
          specificOffset
        });
        return setZone ? inst : inst.setZone(zone);
      } else {
        return DateTime2.invalid(
          new Invalid("unparsable", `the input "${text}" can't be parsed as ${format}`)
        );
      }
    }
    function toTechFormat(dt, format, allowZ = true) {
      return dt.isValid ? Formatter.create(Locale.create("en-US"), {
        allowZ,
        forceSimple: true
      }).formatDateTimeFromString(dt, format) : null;
    }
    function toISODate(o2, extended) {
      const longFormat = o2.c.year > 9999 || o2.c.year < 0;
      let c3 = "";
      if (longFormat && o2.c.year >= 0)
        c3 += "+";
      c3 += padStart3(o2.c.year, longFormat ? 6 : 4);
      if (extended) {
        c3 += "-";
        c3 += padStart3(o2.c.month);
        c3 += "-";
        c3 += padStart3(o2.c.day);
      } else {
        c3 += padStart3(o2.c.month);
        c3 += padStart3(o2.c.day);
      }
      return c3;
    }
    function toISOTime(o2, extended, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone) {
      let c3 = padStart3(o2.c.hour);
      if (extended) {
        c3 += ":";
        c3 += padStart3(o2.c.minute);
        if (o2.c.millisecond !== 0 || o2.c.second !== 0 || !suppressSeconds) {
          c3 += ":";
        }
      } else {
        c3 += padStart3(o2.c.minute);
      }
      if (o2.c.millisecond !== 0 || o2.c.second !== 0 || !suppressSeconds) {
        c3 += padStart3(o2.c.second);
        if (o2.c.millisecond !== 0 || !suppressMilliseconds) {
          c3 += ".";
          c3 += padStart3(o2.c.millisecond, 3);
        }
      }
      if (includeOffset) {
        if (o2.isOffsetFixed && o2.offset === 0 && !extendedZone) {
          c3 += "Z";
        } else if (o2.o < 0) {
          c3 += "-";
          c3 += padStart3(Math.trunc(-o2.o / 60));
          c3 += ":";
          c3 += padStart3(Math.trunc(-o2.o % 60));
        } else {
          c3 += "+";
          c3 += padStart3(Math.trunc(o2.o / 60));
          c3 += ":";
          c3 += padStart3(Math.trunc(o2.o % 60));
        }
      }
      if (extendedZone) {
        c3 += "[" + o2.zone.ianaName + "]";
      }
      return c3;
    }
    var defaultUnitValues = {
      month: 1,
      day: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    };
    var defaultWeekUnitValues = {
      weekNumber: 1,
      weekday: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    };
    var defaultOrdinalUnitValues = {
      ordinal: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    };
    var orderedUnits = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
    var orderedWeekUnits = [
      "weekYear",
      "weekNumber",
      "weekday",
      "hour",
      "minute",
      "second",
      "millisecond"
    ];
    var orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
    function normalizeUnit(unit) {
      const normalized = {
        year: "year",
        years: "year",
        month: "month",
        months: "month",
        day: "day",
        days: "day",
        hour: "hour",
        hours: "hour",
        minute: "minute",
        minutes: "minute",
        quarter: "quarter",
        quarters: "quarter",
        second: "second",
        seconds: "second",
        millisecond: "millisecond",
        milliseconds: "millisecond",
        weekday: "weekday",
        weekdays: "weekday",
        weeknumber: "weekNumber",
        weeksnumber: "weekNumber",
        weeknumbers: "weekNumber",
        weekyear: "weekYear",
        weekyears: "weekYear",
        ordinal: "ordinal"
      }[unit.toLowerCase()];
      if (!normalized)
        throw new InvalidUnitError(unit);
      return normalized;
    }
    function quickDT(obj, opts) {
      const zone = normalizeZone(opts.zone, Settings.defaultZone), loc = Locale.fromObject(opts), tsNow = Settings.now();
      let ts, o2;
      if (!isUndefined(obj.year)) {
        for (const u3 of orderedUnits) {
          if (isUndefined(obj[u3])) {
            obj[u3] = defaultUnitValues[u3];
          }
        }
        const invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
        if (invalid) {
          return DateTime2.invalid(invalid);
        }
        const offsetProvis = zone.offset(tsNow);
        [ts, o2] = objToTS(obj, offsetProvis, zone);
      } else {
        ts = tsNow;
      }
      return new DateTime2({ ts, zone, loc, o: o2 });
    }
    function diffRelative(start, end, opts) {
      const round = isUndefined(opts.round) ? true : opts.round, format = (c3, unit) => {
        c3 = roundTo(c3, round || opts.calendary ? 0 : 2, true);
        const formatter = end.loc.clone(opts).relFormatter(opts);
        return formatter.format(c3, unit);
      }, differ = (unit) => {
        if (opts.calendary) {
          if (!end.hasSame(start, unit)) {
            return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);
          } else
            return 0;
        } else {
          return end.diff(start, unit).get(unit);
        }
      };
      if (opts.unit) {
        return format(differ(opts.unit), opts.unit);
      }
      for (const unit of opts.units) {
        const count = differ(unit);
        if (Math.abs(count) >= 1) {
          return format(count, unit);
        }
      }
      return format(start > end ? -0 : 0, opts.units[opts.units.length - 1]);
    }
    function lastOpts(argList) {
      let opts = {}, args;
      if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
        opts = argList[argList.length - 1];
        args = Array.from(argList).slice(0, argList.length - 1);
      } else {
        args = Array.from(argList);
      }
      return [opts, args];
    }
    var DateTime2 = class {
      /**
       * @access private
       */
      constructor(config2) {
        const zone = config2.zone || Settings.defaultZone;
        let invalid = config2.invalid || (Number.isNaN(config2.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
        this.ts = isUndefined(config2.ts) ? Settings.now() : config2.ts;
        let c3 = null, o2 = null;
        if (!invalid) {
          const unchanged = config2.old && config2.old.ts === this.ts && config2.old.zone.equals(zone);
          if (unchanged) {
            [c3, o2] = [config2.old.c, config2.old.o];
          } else {
            const ot = zone.offset(this.ts);
            c3 = tsToObj(this.ts, ot);
            invalid = Number.isNaN(c3.year) ? new Invalid("invalid input") : null;
            c3 = invalid ? null : c3;
            o2 = invalid ? null : ot;
          }
        }
        this._zone = zone;
        this.loc = config2.loc || Locale.create();
        this.invalid = invalid;
        this.weekData = null;
        this.c = c3;
        this.o = o2;
        this.isLuxonDateTime = true;
      }
      // CONSTRUCT
      /**
       * Create a DateTime for the current instant, in the system's time zone.
       *
       * Use Settings to override these default values if needed.
       * @example DateTime.now().toISO() //~> now in the ISO format
       * @return {DateTime}
       */
      static now() {
        return new DateTime2({});
      }
      /**
       * Create a local DateTime
       * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
       * @param {number} [month=1] - The month, 1-indexed
       * @param {number} [day=1] - The day of the month, 1-indexed
       * @param {number} [hour=0] - The hour of the day, in 24-hour time
       * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
       * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
       * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
       * @example DateTime.local()                                  //~> now
       * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
       * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
       * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
       * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
       * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
       * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
       * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
       * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
       * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
       * @return {DateTime}
       */
      static local() {
        const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
        return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
      }
      /**
       * Create a DateTime in UTC
       * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
       * @param {number} [month=1] - The month, 1-indexed
       * @param {number} [day=1] - The day of the month
       * @param {number} [hour=0] - The hour of the day, in 24-hour time
       * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
       * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
       * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
       * @param {Object} options - configuration options for the DateTime
       * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
       * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
       * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
       * @example DateTime.utc()                                              //~> now
       * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
       * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
       * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
       * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
       * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
       * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
       * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
       * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
       * @return {DateTime}
       */
      static utc() {
        const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
        opts.zone = FixedOffsetZone.utcInstance;
        return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
      }
      /**
       * Create a DateTime from a JavaScript Date object. Uses the default zone.
       * @param {Date} date - a JavaScript Date object
       * @param {Object} options - configuration options for the DateTime
       * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
       * @return {DateTime}
       */
      static fromJSDate(date, options = {}) {
        const ts = isDate2(date) ? date.valueOf() : NaN;
        if (Number.isNaN(ts)) {
          return DateTime2.invalid("invalid input");
        }
        const zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
        if (!zoneToUse.isValid) {
          return DateTime2.invalid(unsupportedZone(zoneToUse));
        }
        return new DateTime2({
          ts,
          zone: zoneToUse,
          loc: Locale.fromObject(options)
        });
      }
      /**
       * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
       * @param {number} milliseconds - a number of milliseconds since 1970 UTC
       * @param {Object} options - configuration options for the DateTime
       * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
       * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
       * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @return {DateTime}
       */
      static fromMillis(milliseconds, options = {}) {
        if (!isNumber2(milliseconds)) {
          throw new InvalidArgumentError(
            `fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`
          );
        } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
          return DateTime2.invalid("Timestamp out of range");
        } else {
          return new DateTime2({
            ts: milliseconds,
            zone: normalizeZone(options.zone, Settings.defaultZone),
            loc: Locale.fromObject(options)
          });
        }
      }
      /**
       * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
       * @param {number} seconds - a number of seconds since 1970 UTC
       * @param {Object} options - configuration options for the DateTime
       * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
       * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
       * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @return {DateTime}
       */
      static fromSeconds(seconds, options = {}) {
        if (!isNumber2(seconds)) {
          throw new InvalidArgumentError("fromSeconds requires a numerical input");
        } else {
          return new DateTime2({
            ts: seconds * 1e3,
            zone: normalizeZone(options.zone, Settings.defaultZone),
            loc: Locale.fromObject(options)
          });
        }
      }
      /**
       * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
       * @param {Object} obj - the object to create the DateTime from
       * @param {number} obj.year - a year, such as 1987
       * @param {number} obj.month - a month, 1-12
       * @param {number} obj.day - a day of the month, 1-31, depending on the month
       * @param {number} obj.ordinal - day of the year, 1-365 or 366
       * @param {number} obj.weekYear - an ISO week year
       * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
       * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
       * @param {number} obj.hour - hour of the day, 0-23
       * @param {number} obj.minute - minute of the hour, 0-59
       * @param {number} obj.second - second of the minute, 0-59
       * @param {number} obj.millisecond - millisecond of the second, 0-999
       * @param {Object} opts - options for creating this DateTime
       * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
       * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
       * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
       * @return {DateTime}
       */
      static fromObject(obj, opts = {}) {
        obj = obj || {};
        const zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
        if (!zoneToUse.isValid) {
          return DateTime2.invalid(unsupportedZone(zoneToUse));
        }
        const tsNow = Settings.now(), offsetProvis = !isUndefined(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow), normalized = normalizeObject(obj, normalizeUnit), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber, loc = Locale.fromObject(opts);
        if ((containsGregor || containsOrdinal) && definiteWeekDef) {
          throw new ConflictingSpecificationError(
            "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
          );
        }
        if (containsGregorMD && containsOrdinal) {
          throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
        }
        const useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
        let units, defaultValues, objNow = tsToObj(tsNow, offsetProvis);
        if (useWeekData) {
          units = orderedWeekUnits;
          defaultValues = defaultWeekUnitValues;
          objNow = gregorianToWeek(objNow);
        } else if (containsOrdinal) {
          units = orderedOrdinalUnits;
          defaultValues = defaultOrdinalUnitValues;
          objNow = gregorianToOrdinal(objNow);
        } else {
          units = orderedUnits;
          defaultValues = defaultUnitValues;
        }
        let foundFirst = false;
        for (const u3 of units) {
          const v3 = normalized[u3];
          if (!isUndefined(v3)) {
            foundFirst = true;
          } else if (foundFirst) {
            normalized[u3] = defaultValues[u3];
          } else {
            normalized[u3] = objNow[u3];
          }
        }
        const higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized), invalid = higherOrderInvalid || hasInvalidTimeData(normalized);
        if (invalid) {
          return DateTime2.invalid(invalid);
        }
        const gregorian = useWeekData ? weekToGregorian(normalized) : containsOrdinal ? ordinalToGregorian(normalized) : normalized, [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse), inst = new DateTime2({
          ts: tsFinal,
          zone: zoneToUse,
          o: offsetFinal,
          loc
        });
        if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
          return DateTime2.invalid(
            "mismatched weekday",
            `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`
          );
        }
        return inst;
      }
      /**
       * Create a DateTime from an ISO 8601 string
       * @param {string} text - the ISO string
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
       * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
       * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
       * @example DateTime.fromISO('2016-05-25T09:08:34.123')
       * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
       * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
       * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
       * @example DateTime.fromISO('2016-W05-4')
       * @return {DateTime}
       */
      static fromISO(text, opts = {}) {
        const [vals, parsedZone] = parseISODate(text);
        return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text);
      }
      /**
       * Create a DateTime from an RFC 2822 string
       * @param {string} text - the RFC 2822 string
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
       * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
       * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
       * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
       * @return {DateTime}
       */
      static fromRFC2822(text, opts = {}) {
        const [vals, parsedZone] = parseRFC2822Date(text);
        return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text);
      }
      /**
       * Create a DateTime from an HTTP header date
       * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
       * @param {string} text - the HTTP header date
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
       * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
       * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
       * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
       * @return {DateTime}
       */
      static fromHTTP(text, opts = {}) {
        const [vals, parsedZone] = parseHTTPDate(text);
        return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
      }
      /**
       * Create a DateTime from an input string and format string.
       * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
       * @param {string} text - the string to parse
       * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
       * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
       * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @return {DateTime}
       */
      static fromFormat(text, fmt, opts = {}) {
        if (isUndefined(text) || isUndefined(fmt)) {
          throw new InvalidArgumentError("fromFormat requires an input string and a format");
        }
        const { locale = null, numberingSystem = null } = opts, localeToUse = Locale.fromOpts({
          locale,
          numberingSystem,
          defaultToEN: true
        }), [vals, parsedZone, specificOffset, invalid] = parseFromTokens(localeToUse, text, fmt);
        if (invalid) {
          return DateTime2.invalid(invalid);
        } else {
          return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text, specificOffset);
        }
      }
      /**
       * @deprecated use fromFormat instead
       */
      static fromString(text, fmt, opts = {}) {
        return DateTime2.fromFormat(text, fmt, opts);
      }
      /**
       * Create a DateTime from a SQL date, time, or datetime
       * Defaults to en-US if no locale has been specified, regardless of the system's locale
       * @param {string} text - the string to parse
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
       * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
       * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @example DateTime.fromSQL('2017-05-15')
       * @example DateTime.fromSQL('2017-05-15 09:12:34')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
       * @example DateTime.fromSQL('09:12:34.342')
       * @return {DateTime}
       */
      static fromSQL(text, opts = {}) {
        const [vals, parsedZone] = parseSQL(text);
        return parseDataToDateTime(vals, parsedZone, opts, "SQL", text);
      }
      /**
       * Create an invalid DateTime.
       * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent.
       * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
       * @return {DateTime}
       */
      static invalid(reason, explanation = null) {
        if (!reason) {
          throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
        }
        const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
        if (Settings.throwOnInvalid) {
          throw new InvalidDateTimeError(invalid);
        } else {
          return new DateTime2({ invalid });
        }
      }
      /**
       * Check if an object is an instance of DateTime. Works across context boundaries
       * @param {object} o
       * @return {boolean}
       */
      static isDateTime(o2) {
        return o2 && o2.isLuxonDateTime || false;
      }
      /**
       * Produce the format string for a set of options
       * @param formatOpts
       * @param localeOpts
       * @returns {string}
       */
      static parseFormatForOpts(formatOpts, localeOpts = {}) {
        const tokenList = formatOptsToTokens(formatOpts, Locale.fromObject(localeOpts));
        return !tokenList ? null : tokenList.map((t3) => t3 ? t3.val : null).join("");
      }
      /**
       * Produce the the fully expanded format token for the locale
       * Does NOT quote characters, so quoted tokens will not round trip correctly
       * @param fmt
       * @param localeOpts
       * @returns {string}
       */
      static expandFormat(fmt, localeOpts = {}) {
        const expanded = expandMacroTokens(Formatter.parseFormat(fmt), Locale.fromObject(localeOpts));
        return expanded.map((t3) => t3.val).join("");
      }
      // INFO
      /**
       * Get the value of unit.
       * @param {string} unit - a unit such as 'minute' or 'day'
       * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
       * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
       * @return {number}
       */
      get(unit) {
        return this[unit];
      }
      /**
       * Returns whether the DateTime is valid. Invalid DateTimes occur when:
       * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
       * * The DateTime was created by an operation on another invalid date
       * @type {boolean}
       */
      get isValid() {
        return this.invalid === null;
      }
      /**
       * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
       * @type {string}
       */
      get invalidReason() {
        return this.invalid ? this.invalid.reason : null;
      }
      /**
       * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
       * @type {string}
       */
      get invalidExplanation() {
        return this.invalid ? this.invalid.explanation : null;
      }
      /**
       * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
       *
       * @type {string}
       */
      get locale() {
        return this.isValid ? this.loc.locale : null;
      }
      /**
       * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
       *
       * @type {string}
       */
      get numberingSystem() {
        return this.isValid ? this.loc.numberingSystem : null;
      }
      /**
       * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
       *
       * @type {string}
       */
      get outputCalendar() {
        return this.isValid ? this.loc.outputCalendar : null;
      }
      /**
       * Get the time zone associated with this DateTime.
       * @type {Zone}
       */
      get zone() {
        return this._zone;
      }
      /**
       * Get the name of the time zone.
       * @type {string}
       */
      get zoneName() {
        return this.isValid ? this.zone.name : null;
      }
      /**
       * Get the year
       * @example DateTime.local(2017, 5, 25).year //=> 2017
       * @type {number}
       */
      get year() {
        return this.isValid ? this.c.year : NaN;
      }
      /**
       * Get the quarter
       * @example DateTime.local(2017, 5, 25).quarter //=> 2
       * @type {number}
       */
      get quarter() {
        return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
      }
      /**
       * Get the month (1-12).
       * @example DateTime.local(2017, 5, 25).month //=> 5
       * @type {number}
       */
      get month() {
        return this.isValid ? this.c.month : NaN;
      }
      /**
       * Get the day of the month (1-30ish).
       * @example DateTime.local(2017, 5, 25).day //=> 25
       * @type {number}
       */
      get day() {
        return this.isValid ? this.c.day : NaN;
      }
      /**
       * Get the hour of the day (0-23).
       * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
       * @type {number}
       */
      get hour() {
        return this.isValid ? this.c.hour : NaN;
      }
      /**
       * Get the minute of the hour (0-59).
       * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
       * @type {number}
       */
      get minute() {
        return this.isValid ? this.c.minute : NaN;
      }
      /**
       * Get the second of the minute (0-59).
       * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
       * @type {number}
       */
      get second() {
        return this.isValid ? this.c.second : NaN;
      }
      /**
       * Get the millisecond of the second (0-999).
       * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
       * @type {number}
       */
      get millisecond() {
        return this.isValid ? this.c.millisecond : NaN;
      }
      /**
       * Get the week year
       * @see https://en.wikipedia.org/wiki/ISO_week_date
       * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
       * @type {number}
       */
      get weekYear() {
        return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
      }
      /**
       * Get the week number of the week year (1-52ish).
       * @see https://en.wikipedia.org/wiki/ISO_week_date
       * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
       * @type {number}
       */
      get weekNumber() {
        return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
      }
      /**
       * Get the day of the week.
       * 1 is Monday and 7 is Sunday
       * @see https://en.wikipedia.org/wiki/ISO_week_date
       * @example DateTime.local(2014, 11, 31).weekday //=> 4
       * @type {number}
       */
      get weekday() {
        return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
      }
      /**
       * Get the ordinal (meaning the day of the year)
       * @example DateTime.local(2017, 5, 25).ordinal //=> 145
       * @type {number|DateTime}
       */
      get ordinal() {
        return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
      }
      /**
       * Get the human readable short month name, such as 'Oct'.
       * Defaults to the system's locale if no locale has been specified
       * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
       * @type {string}
       */
      get monthShort() {
        return this.isValid ? Info.months("short", { locObj: this.loc })[this.month - 1] : null;
      }
      /**
       * Get the human readable long month name, such as 'October'.
       * Defaults to the system's locale if no locale has been specified
       * @example DateTime.local(2017, 10, 30).monthLong //=> October
       * @type {string}
       */
      get monthLong() {
        return this.isValid ? Info.months("long", { locObj: this.loc })[this.month - 1] : null;
      }
      /**
       * Get the human readable short weekday, such as 'Mon'.
       * Defaults to the system's locale if no locale has been specified
       * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
       * @type {string}
       */
      get weekdayShort() {
        return this.isValid ? Info.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
      }
      /**
       * Get the human readable long weekday, such as 'Monday'.
       * Defaults to the system's locale if no locale has been specified
       * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
       * @type {string}
       */
      get weekdayLong() {
        return this.isValid ? Info.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
      }
      /**
       * Get the UTC offset of this DateTime in minutes
       * @example DateTime.now().offset //=> -240
       * @example DateTime.utc().offset //=> 0
       * @type {number}
       */
      get offset() {
        return this.isValid ? +this.o : NaN;
      }
      /**
       * Get the short human name for the zone's current offset, for example "EST" or "EDT".
       * Defaults to the system's locale if no locale has been specified
       * @type {string}
       */
      get offsetNameShort() {
        if (this.isValid) {
          return this.zone.offsetName(this.ts, {
            format: "short",
            locale: this.locale
          });
        } else {
          return null;
        }
      }
      /**
       * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
       * Defaults to the system's locale if no locale has been specified
       * @type {string}
       */
      get offsetNameLong() {
        if (this.isValid) {
          return this.zone.offsetName(this.ts, {
            format: "long",
            locale: this.locale
          });
        } else {
          return null;
        }
      }
      /**
       * Get whether this zone's offset ever changes, as in a DST.
       * @type {boolean}
       */
      get isOffsetFixed() {
        return this.isValid ? this.zone.isUniversal : null;
      }
      /**
       * Get whether the DateTime is in a DST.
       * @type {boolean}
       */
      get isInDST() {
        if (this.isOffsetFixed) {
          return false;
        } else {
          return this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
        }
      }
      /**
       * Get those DateTimes which have the same local time as this DateTime, but a different offset from UTC
       * in this DateTime's zone. During DST changes local time can be ambiguous, for example
       * `2023-10-29T02:30:00` in `Europe/Berlin` can have offset `+01:00` or `+02:00`.
       * This method will return both possible DateTimes if this DateTime's local time is ambiguous.
       * @returns {DateTime[]}
       */
      getPossibleOffsets() {
        if (!this.isValid || this.isOffsetFixed) {
          return [this];
        }
        const dayMs = 864e5;
        const minuteMs = 6e4;
        const localTS = objToLocalTS(this.c);
        const oEarlier = this.zone.offset(localTS - dayMs);
        const oLater = this.zone.offset(localTS + dayMs);
        const o1 = this.zone.offset(localTS - oEarlier * minuteMs);
        const o2 = this.zone.offset(localTS - oLater * minuteMs);
        if (o1 === o2) {
          return [this];
        }
        const ts1 = localTS - o1 * minuteMs;
        const ts2 = localTS - o2 * minuteMs;
        const c1 = tsToObj(ts1, o1);
        const c22 = tsToObj(ts2, o2);
        if (c1.hour === c22.hour && c1.minute === c22.minute && c1.second === c22.second && c1.millisecond === c22.millisecond) {
          return [clone2(this, { ts: ts1 }), clone2(this, { ts: ts2 })];
        }
        return [this];
      }
      /**
       * Returns true if this DateTime is in a leap year, false otherwise
       * @example DateTime.local(2016).isInLeapYear //=> true
       * @example DateTime.local(2013).isInLeapYear //=> false
       * @type {boolean}
       */
      get isInLeapYear() {
        return isLeapYear2(this.year);
      }
      /**
       * Returns the number of days in this DateTime's month
       * @example DateTime.local(2016, 2).daysInMonth //=> 29
       * @example DateTime.local(2016, 3).daysInMonth //=> 31
       * @type {number}
       */
      get daysInMonth() {
        return daysInMonth(this.year, this.month);
      }
      /**
       * Returns the number of days in this DateTime's year
       * @example DateTime.local(2016).daysInYear //=> 366
       * @example DateTime.local(2013).daysInYear //=> 365
       * @type {number}
       */
      get daysInYear() {
        return this.isValid ? daysInYear(this.year) : NaN;
      }
      /**
       * Returns the number of weeks in this DateTime's year
       * @see https://en.wikipedia.org/wiki/ISO_week_date
       * @example DateTime.local(2004).weeksInWeekYear //=> 53
       * @example DateTime.local(2013).weeksInWeekYear //=> 52
       * @type {number}
       */
      get weeksInWeekYear() {
        return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
      }
      /**
       * Returns the resolved Intl options for this DateTime.
       * This is useful in understanding the behavior of formatting methods
       * @param {Object} opts - the same options as toLocaleString
       * @return {Object}
       */
      resolvedLocaleOptions(opts = {}) {
        const { locale, numberingSystem, calendar } = Formatter.create(
          this.loc.clone(opts),
          opts
        ).resolvedOptions(this);
        return { locale, numberingSystem, outputCalendar: calendar };
      }
      // TRANSFORM
      /**
       * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
       *
       * Equivalent to {@link DateTime#setZone}('utc')
       * @param {number} [offset=0] - optionally, an offset from UTC in minutes
       * @param {Object} [opts={}] - options to pass to `setZone()`
       * @return {DateTime}
       */
      toUTC(offset2 = 0, opts = {}) {
        return this.setZone(FixedOffsetZone.instance(offset2), opts);
      }
      /**
       * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
       *
       * Equivalent to `setZone('local')`
       * @return {DateTime}
       */
      toLocal() {
        return this.setZone(Settings.defaultZone);
      }
      /**
       * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
       *
       * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
       * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
       * @param {Object} opts - options
       * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
       * @return {DateTime}
       */
      setZone(zone, { keepLocalTime = false, keepCalendarTime = false } = {}) {
        zone = normalizeZone(zone, Settings.defaultZone);
        if (zone.equals(this.zone)) {
          return this;
        } else if (!zone.isValid) {
          return DateTime2.invalid(unsupportedZone(zone));
        } else {
          let newTS = this.ts;
          if (keepLocalTime || keepCalendarTime) {
            const offsetGuess = zone.offset(this.ts);
            const asObj = this.toObject();
            [newTS] = objToTS(asObj, offsetGuess, zone);
          }
          return clone2(this, { ts: newTS, zone });
        }
      }
      /**
       * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
       * @param {Object} properties - the properties to set
       * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
       * @return {DateTime}
       */
      reconfigure({ locale, numberingSystem, outputCalendar } = {}) {
        const loc = this.loc.clone({ locale, numberingSystem, outputCalendar });
        return clone2(this, { loc });
      }
      /**
       * "Set" the locale. Returns a newly-constructed DateTime.
       * Just a convenient alias for reconfigure({ locale })
       * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
       * @return {DateTime}
       */
      setLocale(locale) {
        return this.reconfigure({ locale });
      }
      /**
       * "Set" the values of specified units. Returns a newly-constructed DateTime.
       * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
       * @param {Object} values - a mapping of units to numbers
       * @example dt.set({ year: 2017 })
       * @example dt.set({ hour: 8, minute: 30 })
       * @example dt.set({ weekday: 5 })
       * @example dt.set({ year: 2005, ordinal: 234 })
       * @return {DateTime}
       */
      set(values) {
        if (!this.isValid)
          return this;
        const normalized = normalizeObject(values, normalizeUnit), settingWeekStuff = !isUndefined(normalized.weekYear) || !isUndefined(normalized.weekNumber) || !isUndefined(normalized.weekday), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
        if ((containsGregor || containsOrdinal) && definiteWeekDef) {
          throw new ConflictingSpecificationError(
            "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
          );
        }
        if (containsGregorMD && containsOrdinal) {
          throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
        }
        let mixed;
        if (settingWeekStuff) {
          mixed = weekToGregorian({ ...gregorianToWeek(this.c), ...normalized });
        } else if (!isUndefined(normalized.ordinal)) {
          mixed = ordinalToGregorian({ ...gregorianToOrdinal(this.c), ...normalized });
        } else {
          mixed = { ...this.toObject(), ...normalized };
          if (isUndefined(normalized.day)) {
            mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
          }
        }
        const [ts, o2] = objToTS(mixed, this.o, this.zone);
        return clone2(this, { ts, o: o2 });
      }
      /**
       * Add a period of time to this DateTime and return the resulting DateTime
       *
       * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
       * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       * @example DateTime.now().plus(123) //~> in 123 milliseconds
       * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
       * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
       * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
       * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
       * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
       * @return {DateTime}
       */
      plus(duration) {
        if (!this.isValid)
          return this;
        const dur = Duration.fromDurationLike(duration);
        return clone2(this, adjustTime(this, dur));
      }
      /**
       * Subtract a period of time to this DateTime and return the resulting DateTime
       * See {@link DateTime#plus}
       * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       @return {DateTime}
       */
      minus(duration) {
        if (!this.isValid)
          return this;
        const dur = Duration.fromDurationLike(duration).negate();
        return clone2(this, adjustTime(this, dur));
      }
      /**
       * "Set" this DateTime to the beginning of a unit of time.
       * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
       * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
       * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
       * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
       * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
       * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
       * @return {DateTime}
       */
      startOf(unit) {
        if (!this.isValid)
          return this;
        const o2 = {}, normalizedUnit = Duration.normalizeUnit(unit);
        switch (normalizedUnit) {
          case "years":
            o2.month = 1;
          case "quarters":
          case "months":
            o2.day = 1;
          case "weeks":
          case "days":
            o2.hour = 0;
          case "hours":
            o2.minute = 0;
          case "minutes":
            o2.second = 0;
          case "seconds":
            o2.millisecond = 0;
            break;
        }
        if (normalizedUnit === "weeks") {
          o2.weekday = 1;
        }
        if (normalizedUnit === "quarters") {
          const q3 = Math.ceil(this.month / 3);
          o2.month = (q3 - 1) * 3 + 1;
        }
        return this.set(o2);
      }
      /**
       * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
       * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
       * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
       * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
       * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
       * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
       * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
       * @return {DateTime}
       */
      endOf(unit) {
        return this.isValid ? this.plus({ [unit]: 1 }).startOf(unit).minus(1) : this;
      }
      // OUTPUT
      /**
       * Returns a string representation of this DateTime formatted according to the specified format string.
       * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
       * Defaults to en-US if no locale has been specified, regardless of the system's locale.
       * @param {string} fmt - the format string
       * @param {Object} opts - opts to override the configuration options on this DateTime
       * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
       * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
       * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
       * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
       * @return {string}
       */
      toFormat(fmt, opts = {}) {
        return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID;
      }
      /**
       * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
       * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
       * of the DateTime in the assigned locale.
       * Defaults to the system's locale if no locale has been specified
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
       * @param {Object} opts - opts to override the configuration options on this DateTime
       * @example DateTime.now().toLocaleString(); //=> 4/20/2017
       * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
       * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
       * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 août 2022'
       * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
       * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
       * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
       * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
       * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
       * @return {string}
       */
      toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
        return this.isValid ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID;
      }
      /**
       * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
       * Defaults to the system's locale if no locale has been specified
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
       * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
       * @example DateTime.now().toLocaleParts(); //=> [
       *                                   //=>   { type: 'day', value: '25' },
       *                                   //=>   { type: 'literal', value: '/' },
       *                                   //=>   { type: 'month', value: '05' },
       *                                   //=>   { type: 'literal', value: '/' },
       *                                   //=>   { type: 'year', value: '1982' }
       *                                   //=> ]
       */
      toLocaleParts(opts = {}) {
        return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime
       * @param {Object} opts - options
       * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
       * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @param {boolean} [opts.extendedZone=false] - add the time zone format extension
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
       * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
       * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
       * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
       * @return {string}
       */
      toISO({
        format = "extended",
        suppressSeconds = false,
        suppressMilliseconds = false,
        includeOffset = true,
        extendedZone = false
      } = {}) {
        if (!this.isValid) {
          return null;
        }
        const ext = format === "extended";
        let c3 = toISODate(this, ext);
        c3 += "T";
        c3 += toISOTime(this, ext, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
        return c3;
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime's date component
       * @param {Object} opts - options
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
       * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
       * @return {string}
       */
      toISODate({ format = "extended" } = {}) {
        if (!this.isValid) {
          return null;
        }
        return toISODate(this, format === "extended");
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime's week date
       * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
       * @return {string}
       */
      toISOWeekDate() {
        return toTechFormat(this, "kkkk-'W'WW-c");
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime's time component
       * @param {Object} opts - options
       * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
       * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
       * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
       * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
       * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
       * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
       * @return {string}
       */
      toISOTime({
        suppressMilliseconds = false,
        suppressSeconds = false,
        includeOffset = true,
        includePrefix = false,
        extendedZone = false,
        format = "extended"
      } = {}) {
        if (!this.isValid) {
          return null;
        }
        let c3 = includePrefix ? "T" : "";
        return c3 + toISOTime(
          this,
          format === "extended",
          suppressSeconds,
          suppressMilliseconds,
          includeOffset,
          extendedZone
        );
      }
      /**
       * Returns an RFC 2822-compatible string representation of this DateTime
       * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
       * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
       * @return {string}
       */
      toRFC2822() {
        return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
       * Specifically, the string conforms to RFC 1123.
       * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
       * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
       * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
       * @return {string}
       */
      toHTTP() {
        return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in SQL Date
       * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
       * @return {string}
       */
      toSQLDate() {
        if (!this.isValid) {
          return null;
        }
        return toISODate(this, true);
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in SQL Time
       * @param {Object} opts - options
       * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
       * @example DateTime.utc().toSQL() //=> '05:15:16.345'
       * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
       * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
       * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
       * @return {string}
       */
      toSQLTime({ includeOffset = true, includeZone = false, includeOffsetSpace = true } = {}) {
        let fmt = "HH:mm:ss.SSS";
        if (includeZone || includeOffset) {
          if (includeOffsetSpace) {
            fmt += " ";
          }
          if (includeZone) {
            fmt += "z";
          } else if (includeOffset) {
            fmt += "ZZ";
          }
        }
        return toTechFormat(this, fmt, true);
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in SQL DateTime
       * @param {Object} opts - options
       * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
       * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
       * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
       * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
       * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
       * @return {string}
       */
      toSQL(opts = {}) {
        if (!this.isValid) {
          return null;
        }
        return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
      }
      /**
       * Returns a string representation of this DateTime appropriate for debugging
       * @return {string}
       */
      toString() {
        return this.isValid ? this.toISO() : INVALID;
      }
      /**
       * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
       * @return {number}
       */
      valueOf() {
        return this.toMillis();
      }
      /**
       * Returns the epoch milliseconds of this DateTime.
       * @return {number}
       */
      toMillis() {
        return this.isValid ? this.ts : NaN;
      }
      /**
       * Returns the epoch seconds of this DateTime.
       * @return {number}
       */
      toSeconds() {
        return this.isValid ? this.ts / 1e3 : NaN;
      }
      /**
       * Returns the epoch seconds (as a whole number) of this DateTime.
       * @return {number}
       */
      toUnixInteger() {
        return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
      }
      /**
       * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
       * @return {string}
       */
      toJSON() {
        return this.toISO();
      }
      /**
       * Returns a BSON serializable equivalent to this DateTime.
       * @return {Date}
       */
      toBSON() {
        return this.toJSDate();
      }
      /**
       * Returns a JavaScript object with this DateTime's year, month, day, and so on.
       * @param opts - options for generating the object
       * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
       * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
       * @return {Object}
       */
      toObject(opts = {}) {
        if (!this.isValid)
          return {};
        const base = { ...this.c };
        if (opts.includeConfig) {
          base.outputCalendar = this.outputCalendar;
          base.numberingSystem = this.loc.numberingSystem;
          base.locale = this.loc.locale;
        }
        return base;
      }
      /**
       * Returns a JavaScript Date equivalent to this DateTime.
       * @return {Date}
       */
      toJSDate() {
        return new Date(this.isValid ? this.ts : NaN);
      }
      // COMPARE
      /**
       * Return the difference between two DateTimes as a Duration.
       * @param {DateTime} otherDateTime - the DateTime to compare this one to
       * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
       * @param {Object} opts - options that affect the creation of the Duration
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @example
       * var i1 = DateTime.fromISO('1982-05-25T09:45'),
       *     i2 = DateTime.fromISO('1983-10-14T10:30');
       * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
       * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
       * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
       * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
       * @return {Duration}
       */
      diff(otherDateTime, unit = "milliseconds", opts = {}) {
        if (!this.isValid || !otherDateTime.isValid) {
          return Duration.invalid("created by diffing an invalid DateTime");
        }
        const durOpts = { locale: this.locale, numberingSystem: this.numberingSystem, ...opts };
        const units = maybeArray(unit).map(Duration.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = diff(earlier, later, units, durOpts);
        return otherIsLater ? diffed.negate() : diffed;
      }
      /**
       * Return the difference between this DateTime and right now.
       * See {@link DateTime#diff}
       * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
       * @param {Object} opts - options that affect the creation of the Duration
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @return {Duration}
       */
      diffNow(unit = "milliseconds", opts = {}) {
        return this.diff(DateTime2.now(), unit, opts);
      }
      /**
       * Return an Interval spanning between this DateTime and another DateTime
       * @param {DateTime} otherDateTime - the other end point of the Interval
       * @return {Interval}
       */
      until(otherDateTime) {
        return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
      }
      /**
       * Return whether this DateTime is in the same unit of time as another DateTime.
       * Higher-order units must also be identical for this function to return `true`.
       * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
       * @param {DateTime} otherDateTime - the other DateTime
       * @param {string} unit - the unit of time to check sameness on
       * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
       * @return {boolean}
       */
      hasSame(otherDateTime, unit) {
        if (!this.isValid)
          return false;
        const inputMs = otherDateTime.valueOf();
        const adjustedToZone = this.setZone(otherDateTime.zone, { keepLocalTime: true });
        return adjustedToZone.startOf(unit) <= inputMs && inputMs <= adjustedToZone.endOf(unit);
      }
      /**
       * Equality check
       * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.
       * To compare just the millisecond values, use `+dt1 === +dt2`.
       * @param {DateTime} other - the other DateTime
       * @return {boolean}
       */
      equals(other) {
        return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
      }
      /**
       * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
       * platform supports Intl.RelativeTimeFormat. Rounds down by default.
       * @param {Object} options - options that affect the output
       * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
       * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
       * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
       * @param {boolean} [options.round=true] - whether to round the numbers in the output.
       * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
       * @param {string} options.locale - override the locale of this DateTime
       * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
       * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
       * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 día"
       * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
       * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
       * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
       * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
       */
      toRelative(options = {}) {
        if (!this.isValid)
          return null;
        const base = options.base || DateTime2.fromObject({}, { zone: this.zone }), padding = options.padding ? this < base ? -options.padding : options.padding : 0;
        let units = ["years", "months", "days", "hours", "minutes", "seconds"];
        let unit = options.unit;
        if (Array.isArray(options.unit)) {
          units = options.unit;
          unit = void 0;
        }
        return diffRelative(base, this.plus(padding), {
          ...options,
          numeric: "always",
          units,
          unit
        });
      }
      /**
       * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
       * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
       * @param {Object} options - options that affect the output
       * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
       * @param {string} options.locale - override the locale of this DateTime
       * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
       * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
       * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
       * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""mañana"
       * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
       * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
       */
      toRelativeCalendar(options = {}) {
        if (!this.isValid)
          return null;
        return diffRelative(options.base || DateTime2.fromObject({}, { zone: this.zone }), this, {
          ...options,
          numeric: "auto",
          units: ["years", "months", "days"],
          calendary: true
        });
      }
      /**
       * Return the min of several date times
       * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
       * @return {DateTime} the min DateTime, or undefined if called with no argument
       */
      static min(...dateTimes) {
        if (!dateTimes.every(DateTime2.isDateTime)) {
          throw new InvalidArgumentError("min requires all arguments be DateTimes");
        }
        return bestBy(dateTimes, (i3) => i3.valueOf(), Math.min);
      }
      /**
       * Return the max of several date times
       * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
       * @return {DateTime} the max DateTime, or undefined if called with no argument
       */
      static max(...dateTimes) {
        if (!dateTimes.every(DateTime2.isDateTime)) {
          throw new InvalidArgumentError("max requires all arguments be DateTimes");
        }
        return bestBy(dateTimes, (i3) => i3.valueOf(), Math.max);
      }
      // MISC
      /**
       * Explain how a string would be parsed by fromFormat()
       * @param {string} text - the string to parse
       * @param {string} fmt - the format the string is expected to be in (see description)
       * @param {Object} options - options taken by fromFormat()
       * @return {Object}
       */
      static fromFormatExplain(text, fmt, options = {}) {
        const { locale = null, numberingSystem = null } = options, localeToUse = Locale.fromOpts({
          locale,
          numberingSystem,
          defaultToEN: true
        });
        return explainFromTokens(localeToUse, text, fmt);
      }
      /**
       * @deprecated use fromFormatExplain instead
       */
      static fromStringExplain(text, fmt, options = {}) {
        return DateTime2.fromFormatExplain(text, fmt, options);
      }
      // FORMAT PRESETS
      /**
       * {@link DateTime#toLocaleString} format like 10/14/1983
       * @type {Object}
       */
      static get DATE_SHORT() {
        return DATE_SHORT;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
       * @type {Object}
       */
      static get DATE_MED() {
        return DATE_MED;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
       * @type {Object}
       */
      static get DATE_MED_WITH_WEEKDAY() {
        return DATE_MED_WITH_WEEKDAY;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'October 14, 1983'
       * @type {Object}
       */
      static get DATE_FULL() {
        return DATE_FULL;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
       * @type {Object}
       */
      static get DATE_HUGE() {
        return DATE_HUGE;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get TIME_SIMPLE() {
        return TIME_SIMPLE;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get TIME_WITH_SECONDS() {
        return TIME_WITH_SECONDS;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get TIME_WITH_SHORT_OFFSET() {
        return TIME_WITH_SHORT_OFFSET;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get TIME_WITH_LONG_OFFSET() {
        return TIME_WITH_LONG_OFFSET;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
       * @type {Object}
       */
      static get TIME_24_SIMPLE() {
        return TIME_24_SIMPLE;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
       * @type {Object}
       */
      static get TIME_24_WITH_SECONDS() {
        return TIME_24_WITH_SECONDS;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
       * @type {Object}
       */
      static get TIME_24_WITH_SHORT_OFFSET() {
        return TIME_24_WITH_SHORT_OFFSET;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
       * @type {Object}
       */
      static get TIME_24_WITH_LONG_OFFSET() {
        return TIME_24_WITH_LONG_OFFSET;
      }
      /**
       * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_SHORT() {
        return DATETIME_SHORT;
      }
      /**
       * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_SHORT_WITH_SECONDS() {
        return DATETIME_SHORT_WITH_SECONDS;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_MED() {
        return DATETIME_MED;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_MED_WITH_SECONDS() {
        return DATETIME_MED_WITH_SECONDS;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_MED_WITH_WEEKDAY() {
        return DATETIME_MED_WITH_WEEKDAY;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_FULL() {
        return DATETIME_FULL;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_FULL_WITH_SECONDS() {
        return DATETIME_FULL_WITH_SECONDS;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_HUGE() {
        return DATETIME_HUGE;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_HUGE_WITH_SECONDS() {
        return DATETIME_HUGE_WITH_SECONDS;
      }
    };
    function friendlyDateTime(dateTimeish) {
      if (DateTime2.isDateTime(dateTimeish)) {
        return dateTimeish;
      } else if (dateTimeish && dateTimeish.valueOf && isNumber2(dateTimeish.valueOf())) {
        return DateTime2.fromJSDate(dateTimeish);
      } else if (dateTimeish && typeof dateTimeish === "object") {
        return DateTime2.fromObject(dateTimeish);
      } else {
        throw new InvalidArgumentError(
          `Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`
        );
      }
    }
    var DEFAULT_QUERY_SETTINGS = {
      renderNullAs: "\\-",
      taskCompletionTracking: false,
      taskCompletionUseEmojiShorthand: false,
      taskCompletionText: "completion",
      taskCompletionDateFormat: "yyyy-MM-dd",
      recursiveSubTaskCompletion: false,
      warnOnEmptyResult: true,
      refreshEnabled: true,
      refreshInterval: 2500,
      defaultDateFormat: "MMMM dd, yyyy",
      defaultDateTimeFormat: "h:mm a - MMMM dd, yyyy",
      maxRecursiveRenderDepth: 4,
      tableIdColumnName: "File",
      tableGroupColumnName: "Group",
      showResultCount: true
    };
    var DEFAULT_EXPORT_SETTINGS = {
      allowHtml: true
    };
    ({
      ...DEFAULT_QUERY_SETTINGS,
      ...DEFAULT_EXPORT_SETTINGS,
      ...{
        inlineQueryPrefix: "=",
        inlineJsQueryPrefix: "$=",
        inlineQueriesInCodeblocks: true,
        enableInlineDataview: true,
        enableDataviewJs: false,
        enableInlineDataviewJs: false,
        prettyRenderInlineFields: true,
        prettyRenderInlineFieldsInLivePreview: true,
        dataviewJsKeyword: "dataviewjs"
      }
    });
    var Success = class {
      constructor(value) {
        __publicField(this, "value");
        __publicField(this, "successful");
        this.value = value;
        this.successful = true;
      }
      map(f3) {
        return new Success(f3(this.value));
      }
      flatMap(f3) {
        return f3(this.value);
      }
      mapErr(f3) {
        return this;
      }
      bimap(succ, _fail) {
        return this.map(succ);
      }
      orElse(_value) {
        return this.value;
      }
      cast() {
        return this;
      }
      orElseThrow(_message) {
        return this.value;
      }
    };
    var Failure = class {
      constructor(error) {
        __publicField(this, "error");
        __publicField(this, "successful");
        this.error = error;
        this.successful = false;
      }
      map(_f) {
        return this;
      }
      flatMap(_f) {
        return this;
      }
      mapErr(f3) {
        return new Failure(f3(this.error));
      }
      bimap(_succ, fail) {
        return this.mapErr(fail);
      }
      orElse(value) {
        return value;
      }
      cast() {
        return this;
      }
      orElseThrow(message) {
        if (message)
          throw new Error(message(this.error));
        else
          throw new Error("" + this.error);
      }
    };
    var Result;
    (function(Result2) {
      function success(value) {
        return new Success(value);
      }
      Result2.success = success;
      function failure(error) {
        return new Failure(error);
      }
      Result2.failure = failure;
      function flatMap2(first, second, f3) {
        if (first.successful) {
          if (second.successful)
            return f3(first.value, second.value);
          else
            return failure(second.error);
        } else {
          return failure(first.error);
        }
      }
      Result2.flatMap2 = flatMap2;
      function map2(first, second, f3) {
        return flatMap2(first, second, (a3, b3) => success(f3(a3, b3)));
      }
      Result2.map2 = map2;
    })(Result || (Result = {}));
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    var parsimmon_umd_min = { exports: {} };
    parsimmon_umd_min.exports;
    (function(module3, exports2) {
      !function(n3, t3) {
        module3.exports = t3();
      }("undefined" != typeof self ? self : commonjsGlobal, function() {
        return function(n3) {
          var t3 = {};
          function r3(e3) {
            if (t3[e3])
              return t3[e3].exports;
            var u3 = t3[e3] = { i: e3, l: false, exports: {} };
            return n3[e3].call(u3.exports, u3, u3.exports, r3), u3.l = true, u3.exports;
          }
          return r3.m = n3, r3.c = t3, r3.d = function(n4, t4, e3) {
            r3.o(n4, t4) || Object.defineProperty(n4, t4, { configurable: false, enumerable: true, get: e3 });
          }, r3.r = function(n4) {
            Object.defineProperty(n4, "__esModule", { value: true });
          }, r3.n = function(n4) {
            var t4 = n4 && n4.__esModule ? function() {
              return n4.default;
            } : function() {
              return n4;
            };
            return r3.d(t4, "a", t4), t4;
          }, r3.o = function(n4, t4) {
            return Object.prototype.hasOwnProperty.call(n4, t4);
          }, r3.p = "", r3(r3.s = 0);
        }([function(n3, t3, r3) {
          function e3(n4) {
            if (!(this instanceof e3))
              return new e3(n4);
            this._ = n4;
          }
          var u3 = e3.prototype;
          function o2(n4, t4) {
            for (var r4 = 0; r4 < n4; r4++)
              t4(r4);
          }
          function i3(n4, t4, r4) {
            return function(n5, t5) {
              o2(t5.length, function(r5) {
                n5(t5[r5], r5, t5);
              });
            }(function(r5, e4, u4) {
              t4 = n4(t4, r5, e4, u4);
            }, r4), t4;
          }
          function a3(n4, t4) {
            return i3(function(t5, r4, e4, u4) {
              return t5.concat([n4(r4, e4, u4)]);
            }, [], t4);
          }
          function f3(n4, t4) {
            var r4 = { v: 0, buf: t4 };
            return o2(n4, function() {
              var n5;
              r4 = { v: r4.v << 1 | (n5 = r4.buf, n5[0] >> 7), buf: function(n6) {
                var t5 = i3(function(n7, t6, r5, e4) {
                  return n7.concat(r5 === e4.length - 1 ? Buffer.from([t6, 0]).readUInt16BE(0) : e4.readUInt16BE(r5));
                }, [], n6);
                return Buffer.from(a3(function(n7) {
                  return (n7 << 1 & 65535) >> 8;
                }, t5));
              }(r4.buf) };
            }), r4;
          }
          function c3() {
            return "undefined" != typeof Buffer;
          }
          function s4() {
            if (!c3())
              throw new Error("Buffer global does not exist; please use webpack if you need to parse Buffers in the browser.");
          }
          function l4(n4) {
            s4();
            var t4 = i3(function(n5, t5) {
              return n5 + t5;
            }, 0, n4);
            if (t4 % 8 != 0)
              throw new Error("The bits [" + n4.join(", ") + "] add up to " + t4 + " which is not an even number of bytes; the total should be divisible by 8");
            var r4, u4 = t4 / 8, o3 = (r4 = function(n5) {
              return n5 > 48;
            }, i3(function(n5, t5) {
              return n5 || (r4(t5) ? t5 : n5);
            }, null, n4));
            if (o3)
              throw new Error(o3 + " bit range requested exceeds 48 bit (6 byte) Number max.");
            return new e3(function(t5, r5) {
              var e4 = u4 + r5;
              return e4 > t5.length ? x4(r5, u4.toString() + " bytes") : b3(e4, i3(function(n5, t6) {
                var r6 = f3(t6, n5.buf);
                return { coll: n5.coll.concat(r6.v), buf: r6.buf };
              }, { coll: [], buf: t5.slice(r5, e4) }, n4).coll);
            });
          }
          function h3(n4, t4) {
            return new e3(function(r4, e4) {
              return s4(), e4 + t4 > r4.length ? x4(e4, t4 + " bytes for " + n4) : b3(e4 + t4, r4.slice(e4, e4 + t4));
            });
          }
          function p3(n4, t4) {
            if ("number" != typeof (r4 = t4) || Math.floor(r4) !== r4 || t4 < 0 || t4 > 6)
              throw new Error(n4 + " requires integer length in range [0, 6].");
            var r4;
          }
          function d2(n4) {
            return p3("uintBE", n4), h3("uintBE(" + n4 + ")", n4).map(function(t4) {
              return t4.readUIntBE(0, n4);
            });
          }
          function v3(n4) {
            return p3("uintLE", n4), h3("uintLE(" + n4 + ")", n4).map(function(t4) {
              return t4.readUIntLE(0, n4);
            });
          }
          function g4(n4) {
            return p3("intBE", n4), h3("intBE(" + n4 + ")", n4).map(function(t4) {
              return t4.readIntBE(0, n4);
            });
          }
          function m3(n4) {
            return p3("intLE", n4), h3("intLE(" + n4 + ")", n4).map(function(t4) {
              return t4.readIntLE(0, n4);
            });
          }
          function y3(n4) {
            return n4 instanceof e3;
          }
          function E2(n4) {
            return "[object Array]" === {}.toString.call(n4);
          }
          function w4(n4) {
            return c3() && Buffer.isBuffer(n4);
          }
          function b3(n4, t4) {
            return { status: true, index: n4, value: t4, furthest: -1, expected: [] };
          }
          function x4(n4, t4) {
            return E2(t4) || (t4 = [t4]), { status: false, index: -1, value: null, furthest: n4, expected: t4 };
          }
          function B3(n4, t4) {
            if (!t4)
              return n4;
            if (n4.furthest > t4.furthest)
              return n4;
            var r4 = n4.furthest === t4.furthest ? function(n5, t5) {
              if (function() {
                if (void 0 !== e3._supportsSet)
                  return e3._supportsSet;
                var n6 = "undefined" != typeof Set;
                return e3._supportsSet = n6, n6;
              }() && Array.from) {
                for (var r5 = new Set(n5), u4 = 0; u4 < t5.length; u4++)
                  r5.add(t5[u4]);
                var o3 = Array.from(r5);
                return o3.sort(), o3;
              }
              for (var i4 = {}, a4 = 0; a4 < n5.length; a4++)
                i4[n5[a4]] = true;
              for (var f4 = 0; f4 < t5.length; f4++)
                i4[t5[f4]] = true;
              var c4 = [];
              for (var s5 in i4)
                ({}).hasOwnProperty.call(i4, s5) && c4.push(s5);
              return c4.sort(), c4;
            }(n4.expected, t4.expected) : t4.expected;
            return { status: n4.status, index: n4.index, value: n4.value, furthest: t4.furthest, expected: r4 };
          }
          var j4 = {};
          function S2(n4, t4) {
            if (w4(n4))
              return { offset: t4, line: -1, column: -1 };
            n4 in j4 || (j4[n4] = {});
            for (var r4 = j4[n4], e4 = 0, u4 = 0, o3 = 0, i4 = t4; i4 >= 0; ) {
              if (i4 in r4) {
                e4 = r4[i4].line, 0 === o3 && (o3 = r4[i4].lineStart);
                break;
              }
              ("\n" === n4.charAt(i4) || "\r" === n4.charAt(i4) && "\n" !== n4.charAt(i4 + 1)) && (u4++, 0 === o3 && (o3 = i4 + 1)), i4--;
            }
            var a4 = e4 + u4, f4 = t4 - o3;
            return r4[t4] = { line: a4, lineStart: o3 }, { offset: t4, line: a4 + 1, column: f4 + 1 };
          }
          function _3(n4) {
            if (!y3(n4))
              throw new Error("not a parser: " + n4);
          }
          function L3(n4, t4) {
            return "string" == typeof n4 ? n4.charAt(t4) : n4[t4];
          }
          function O2(n4) {
            if ("number" != typeof n4)
              throw new Error("not a number: " + n4);
          }
          function k3(n4) {
            if ("function" != typeof n4)
              throw new Error("not a function: " + n4);
          }
          function P3(n4) {
            if ("string" != typeof n4)
              throw new Error("not a string: " + n4);
          }
          var q3 = 2, A3 = 3, I3 = 8, F4 = 5 * I3, M2 = 4 * I3, z3 = "  ";
          function R(n4, t4) {
            return new Array(t4 + 1).join(n4);
          }
          function U2(n4, t4, r4) {
            var e4 = t4 - n4.length;
            return e4 <= 0 ? n4 : R(r4, e4) + n4;
          }
          function W2(n4, t4, r4, e4) {
            return { from: n4 - t4 > 0 ? n4 - t4 : 0, to: n4 + r4 > e4 ? e4 : n4 + r4 };
          }
          function D3(n4, t4) {
            var r4, e4, u4, o3, f4, c4 = t4.index, s5 = c4.offset, l5 = 1;
            if (s5 === n4.length)
              return "Got the end of the input";
            if (w4(n4)) {
              var h4 = s5 - s5 % I3, p4 = s5 - h4, d3 = W2(h4, F4, M2 + I3, n4.length), v4 = a3(function(n5) {
                return a3(function(n6) {
                  return U2(n6.toString(16), 2, "0");
                }, n5);
              }, function(n5, t5) {
                var r5 = n5.length, e5 = [], u5 = 0;
                if (r5 <= t5)
                  return [n5.slice()];
                for (var o4 = 0; o4 < r5; o4++)
                  e5[u5] || e5.push([]), e5[u5].push(n5[o4]), (o4 + 1) % t5 == 0 && u5++;
                return e5;
              }(n4.slice(d3.from, d3.to).toJSON().data, I3));
              o3 = function(n5) {
                return 0 === n5.from && 1 === n5.to ? { from: n5.from, to: n5.to } : { from: n5.from / I3, to: Math.floor(n5.to / I3) };
              }(d3), e4 = h4 / I3, r4 = 3 * p4, p4 >= 4 && (r4 += 1), l5 = 2, u4 = a3(function(n5) {
                return n5.length <= 4 ? n5.join(" ") : n5.slice(0, 4).join(" ") + "  " + n5.slice(4).join(" ");
              }, v4), (f4 = (8 * (o3.to > 0 ? o3.to - 1 : o3.to)).toString(16).length) < 2 && (f4 = 2);
            } else {
              var g5 = n4.split(/\r\n|[\n\r\u2028\u2029]/);
              r4 = c4.column - 1, e4 = c4.line - 1, o3 = W2(e4, q3, A3, g5.length), u4 = g5.slice(o3.from, o3.to), f4 = o3.to.toString().length;
            }
            var m4 = e4 - o3.from;
            return w4(n4) && (f4 = (8 * (o3.to > 0 ? o3.to - 1 : o3.to)).toString(16).length) < 2 && (f4 = 2), i3(function(t5, e5, u5) {
              var i4, a4 = u5 === m4, c5 = a4 ? "> " : z3;
              return i4 = w4(n4) ? U2((8 * (o3.from + u5)).toString(16), f4, "0") : U2((o3.from + u5 + 1).toString(), f4, " "), [].concat(t5, [c5 + i4 + " | " + e5], a4 ? [z3 + R(" ", f4) + " | " + U2("", r4, " ") + R("^", l5)] : []);
            }, [], u4).join("\n");
          }
          function N3(n4, t4) {
            return ["\n", "-- PARSING FAILED " + R("-", 50), "\n\n", D3(n4, t4), "\n\n", (r4 = t4.expected, 1 === r4.length ? "Expected:\n\n" + r4[0] : "Expected one of the following: \n\n" + r4.join(", ")), "\n"].join("");
            var r4;
          }
          function G3(n4) {
            return void 0 !== n4.flags ? n4.flags : [n4.global ? "g" : "", n4.ignoreCase ? "i" : "", n4.multiline ? "m" : "", n4.unicode ? "u" : "", n4.sticky ? "y" : ""].join("");
          }
          function C3() {
            for (var n4 = [].slice.call(arguments), t4 = n4.length, r4 = 0; r4 < t4; r4 += 1)
              _3(n4[r4]);
            return e3(function(r5, e4) {
              for (var u4, o3 = new Array(t4), i4 = 0; i4 < t4; i4 += 1) {
                if (!(u4 = B3(n4[i4]._(r5, e4), u4)).status)
                  return u4;
                o3[i4] = u4.value, e4 = u4.index;
              }
              return B3(b3(e4, o3), u4);
            });
          }
          function J2() {
            var n4 = [].slice.call(arguments);
            if (0 === n4.length)
              throw new Error("seqMap needs at least one argument");
            var t4 = n4.pop();
            return k3(t4), C3.apply(null, n4).map(function(n5) {
              return t4.apply(null, n5);
            });
          }
          function T4() {
            var n4 = [].slice.call(arguments), t4 = n4.length;
            if (0 === t4)
              return Y("zero alternates");
            for (var r4 = 0; r4 < t4; r4 += 1)
              _3(n4[r4]);
            return e3(function(t5, r5) {
              for (var e4, u4 = 0; u4 < n4.length; u4 += 1)
                if ((e4 = B3(n4[u4]._(t5, r5), e4)).status)
                  return e4;
              return e4;
            });
          }
          function V3(n4, t4) {
            return H3(n4, t4).or(X2([]));
          }
          function H3(n4, t4) {
            return _3(n4), _3(t4), J2(n4, t4.then(n4).many(), function(n5, t5) {
              return [n5].concat(t5);
            });
          }
          function K2(n4) {
            P3(n4);
            var t4 = "'" + n4 + "'";
            return e3(function(r4, e4) {
              var u4 = e4 + n4.length, o3 = r4.slice(e4, u4);
              return o3 === n4 ? b3(u4, o3) : x4(e4, t4);
            });
          }
          function Q2(n4, t4) {
            !function(n5) {
              if (!(n5 instanceof RegExp))
                throw new Error("not a regexp: " + n5);
              for (var t5 = G3(n5), r5 = 0; r5 < t5.length; r5++) {
                var e4 = t5.charAt(r5);
                if ("i" !== e4 && "m" !== e4 && "u" !== e4 && "s" !== e4)
                  throw new Error('unsupported regexp flag "' + e4 + '": ' + n5);
              }
            }(n4), arguments.length >= 2 ? O2(t4) : t4 = 0;
            var r4 = function(n5) {
              return RegExp("^(?:" + n5.source + ")", G3(n5));
            }(n4), u4 = "" + n4;
            return e3(function(n5, e4) {
              var o3 = r4.exec(n5.slice(e4));
              if (o3) {
                if (0 <= t4 && t4 <= o3.length) {
                  var i4 = o3[0], a4 = o3[t4];
                  return b3(e4 + i4.length, a4);
                }
                return x4(e4, "valid match group (0 to " + o3.length + ") in " + u4);
              }
              return x4(e4, u4);
            });
          }
          function X2(n4) {
            return e3(function(t4, r4) {
              return b3(r4, n4);
            });
          }
          function Y(n4) {
            return e3(function(t4, r4) {
              return x4(r4, n4);
            });
          }
          function Z2(n4) {
            if (y3(n4))
              return e3(function(t4, r4) {
                var e4 = n4._(t4, r4);
                return e4.index = r4, e4.value = "", e4;
              });
            if ("string" == typeof n4)
              return Z2(K2(n4));
            if (n4 instanceof RegExp)
              return Z2(Q2(n4));
            throw new Error("not a string, regexp, or parser: " + n4);
          }
          function $3(n4) {
            return _3(n4), e3(function(t4, r4) {
              var e4 = n4._(t4, r4), u4 = t4.slice(r4, e4.index);
              return e4.status ? x4(r4, 'not "' + u4 + '"') : b3(r4, null);
            });
          }
          function nn2(n4) {
            return k3(n4), e3(function(t4, r4) {
              var e4 = L3(t4, r4);
              return r4 < t4.length && n4(e4) ? b3(r4 + 1, e4) : x4(r4, "a character/byte matching " + n4);
            });
          }
          function tn2(n4, t4) {
            arguments.length < 2 && (t4 = n4, n4 = void 0);
            var r4 = e3(function(n5, e4) {
              return r4._ = t4()._, r4._(n5, e4);
            });
            return n4 ? r4.desc(n4) : r4;
          }
          function rn() {
            return Y("fantasy-land/empty");
          }
          u3.parse = function(n4) {
            if ("string" != typeof n4 && !w4(n4))
              throw new Error(".parse must be called with a string or Buffer as its argument");
            var t4, r4 = this.skip(an)._(n4, 0);
            return t4 = r4.status ? { status: true, value: r4.value } : { status: false, index: S2(n4, r4.furthest), expected: r4.expected }, delete j4[n4], t4;
          }, u3.tryParse = function(n4) {
            var t4 = this.parse(n4);
            if (t4.status)
              return t4.value;
            var r4 = N3(n4, t4), e4 = new Error(r4);
            throw e4.type = "ParsimmonError", e4.result = t4, e4;
          }, u3.assert = function(n4, t4) {
            return this.chain(function(r4) {
              return n4(r4) ? X2(r4) : Y(t4);
            });
          }, u3.or = function(n4) {
            return T4(this, n4);
          }, u3.trim = function(n4) {
            return this.wrap(n4, n4);
          }, u3.wrap = function(n4, t4) {
            return J2(n4, this, t4, function(n5, t5) {
              return t5;
            });
          }, u3.thru = function(n4) {
            return n4(this);
          }, u3.then = function(n4) {
            return _3(n4), C3(this, n4).map(function(n5) {
              return n5[1];
            });
          }, u3.many = function() {
            var n4 = this;
            return e3(function(t4, r4) {
              for (var e4 = [], u4 = void 0; ; ) {
                if (!(u4 = B3(n4._(t4, r4), u4)).status)
                  return B3(b3(r4, e4), u4);
                if (r4 === u4.index)
                  throw new Error("infinite loop detected in .many() parser --- calling .many() on a parser which can accept zero characters is usually the cause");
                r4 = u4.index, e4.push(u4.value);
              }
            });
          }, u3.tieWith = function(n4) {
            return P3(n4), this.map(function(t4) {
              if (function(n5) {
                if (!E2(n5))
                  throw new Error("not an array: " + n5);
              }(t4), t4.length) {
                P3(t4[0]);
                for (var r4 = t4[0], e4 = 1; e4 < t4.length; e4++)
                  P3(t4[e4]), r4 += n4 + t4[e4];
                return r4;
              }
              return "";
            });
          }, u3.tie = function() {
            return this.tieWith("");
          }, u3.times = function(n4, t4) {
            var r4 = this;
            return arguments.length < 2 && (t4 = n4), O2(n4), O2(t4), e3(function(e4, u4) {
              for (var o3 = [], i4 = void 0, a4 = void 0, f4 = 0; f4 < n4; f4 += 1) {
                if (a4 = B3(i4 = r4._(e4, u4), a4), !i4.status)
                  return a4;
                u4 = i4.index, o3.push(i4.value);
              }
              for (; f4 < t4 && (a4 = B3(i4 = r4._(e4, u4), a4), i4.status); f4 += 1)
                u4 = i4.index, o3.push(i4.value);
              return B3(b3(u4, o3), a4);
            });
          }, u3.result = function(n4) {
            return this.map(function() {
              return n4;
            });
          }, u3.atMost = function(n4) {
            return this.times(0, n4);
          }, u3.atLeast = function(n4) {
            return J2(this.times(n4), this.many(), function(n5, t4) {
              return n5.concat(t4);
            });
          }, u3.map = function(n4) {
            k3(n4);
            var t4 = this;
            return e3(function(r4, e4) {
              var u4 = t4._(r4, e4);
              return u4.status ? B3(b3(u4.index, n4(u4.value)), u4) : u4;
            });
          }, u3.contramap = function(n4) {
            k3(n4);
            var t4 = this;
            return e3(function(r4, e4) {
              var u4 = t4.parse(n4(r4.slice(e4)));
              return u4.status ? b3(e4 + r4.length, u4.value) : u4;
            });
          }, u3.promap = function(n4, t4) {
            return k3(n4), k3(t4), this.contramap(n4).map(t4);
          }, u3.skip = function(n4) {
            return C3(this, n4).map(function(n5) {
              return n5[0];
            });
          }, u3.mark = function() {
            return J2(en2, this, en2, function(n4, t4, r4) {
              return { start: n4, value: t4, end: r4 };
            });
          }, u3.node = function(n4) {
            return J2(en2, this, en2, function(t4, r4, e4) {
              return { name: n4, value: r4, start: t4, end: e4 };
            });
          }, u3.sepBy = function(n4) {
            return V3(this, n4);
          }, u3.sepBy1 = function(n4) {
            return H3(this, n4);
          }, u3.lookahead = function(n4) {
            return this.skip(Z2(n4));
          }, u3.notFollowedBy = function(n4) {
            return this.skip($3(n4));
          }, u3.desc = function(n4) {
            E2(n4) || (n4 = [n4]);
            var t4 = this;
            return e3(function(r4, e4) {
              var u4 = t4._(r4, e4);
              return u4.status || (u4.expected = n4), u4;
            });
          }, u3.fallback = function(n4) {
            return this.or(X2(n4));
          }, u3.ap = function(n4) {
            return J2(n4, this, function(n5, t4) {
              return n5(t4);
            });
          }, u3.chain = function(n4) {
            var t4 = this;
            return e3(function(r4, e4) {
              var u4 = t4._(r4, e4);
              return u4.status ? B3(n4(u4.value)._(r4, u4.index), u4) : u4;
            });
          }, u3.concat = u3.or, u3.empty = rn, u3.of = X2, u3["fantasy-land/ap"] = u3.ap, u3["fantasy-land/chain"] = u3.chain, u3["fantasy-land/concat"] = u3.concat, u3["fantasy-land/empty"] = u3.empty, u3["fantasy-land/of"] = u3.of, u3["fantasy-land/map"] = u3.map;
          var en2 = e3(function(n4, t4) {
            return b3(t4, S2(n4, t4));
          }), un = e3(function(n4, t4) {
            return t4 >= n4.length ? x4(t4, "any character/byte") : b3(t4 + 1, L3(n4, t4));
          }), on = e3(function(n4, t4) {
            return b3(n4.length, n4.slice(t4));
          }), an = e3(function(n4, t4) {
            return t4 < n4.length ? x4(t4, "EOF") : b3(t4, null);
          }), fn = Q2(/[0-9]/).desc("a digit"), cn = Q2(/[0-9]*/).desc("optional digits"), sn = Q2(/[a-z]/i).desc("a letter"), ln = Q2(/[a-z]*/i).desc("optional letters"), hn = Q2(/\s*/).desc("optional whitespace"), pn = Q2(/\s+/).desc("whitespace"), dn = K2("\r"), vn = K2("\n"), gn = K2("\r\n"), mn = T4(gn, vn, dn).desc("newline"), yn = T4(mn, an);
          e3.all = on, e3.alt = T4, e3.any = un, e3.cr = dn, e3.createLanguage = function(n4) {
            var t4 = {};
            for (var r4 in n4)
              ({}).hasOwnProperty.call(n4, r4) && function(r5) {
                t4[r5] = tn2(function() {
                  return n4[r5](t4);
                });
              }(r4);
            return t4;
          }, e3.crlf = gn, e3.custom = function(n4) {
            return e3(n4(b3, x4));
          }, e3.digit = fn, e3.digits = cn, e3.empty = rn, e3.end = yn, e3.eof = an, e3.fail = Y, e3.formatError = N3, e3.index = en2, e3.isParser = y3, e3.lazy = tn2, e3.letter = sn, e3.letters = ln, e3.lf = vn, e3.lookahead = Z2, e3.makeFailure = x4, e3.makeSuccess = b3, e3.newline = mn, e3.noneOf = function(n4) {
            return nn2(function(t4) {
              return n4.indexOf(t4) < 0;
            }).desc("none of '" + n4 + "'");
          }, e3.notFollowedBy = $3, e3.of = X2, e3.oneOf = function(n4) {
            for (var t4 = n4.split(""), r4 = 0; r4 < t4.length; r4++)
              t4[r4] = "'" + t4[r4] + "'";
            return nn2(function(t5) {
              return n4.indexOf(t5) >= 0;
            }).desc(t4);
          }, e3.optWhitespace = hn, e3.Parser = e3, e3.range = function(n4, t4) {
            return nn2(function(r4) {
              return n4 <= r4 && r4 <= t4;
            }).desc(n4 + "-" + t4);
          }, e3.regex = Q2, e3.regexp = Q2, e3.sepBy = V3, e3.sepBy1 = H3, e3.seq = C3, e3.seqMap = J2, e3.seqObj = function() {
            for (var n4, t4 = {}, r4 = 0, u4 = (n4 = arguments, Array.prototype.slice.call(n4)), o3 = u4.length, i4 = 0; i4 < o3; i4 += 1) {
              var a4 = u4[i4];
              if (!y3(a4)) {
                if (E2(a4) && 2 === a4.length && "string" == typeof a4[0] && y3(a4[1])) {
                  var f4 = a4[0];
                  if (Object.prototype.hasOwnProperty.call(t4, f4))
                    throw new Error("seqObj: duplicate key " + f4);
                  t4[f4] = true, r4++;
                  continue;
                }
                throw new Error("seqObj arguments must be parsers or [string, parser] array pairs.");
              }
            }
            if (0 === r4)
              throw new Error("seqObj expects at least one named parser, found zero");
            return e3(function(n5, t5) {
              for (var r5, e4 = {}, i5 = 0; i5 < o3; i5 += 1) {
                var a5, f5;
                if (E2(u4[i5]) ? (a5 = u4[i5][0], f5 = u4[i5][1]) : (a5 = null, f5 = u4[i5]), !(r5 = B3(f5._(n5, t5), r5)).status)
                  return r5;
                a5 && (e4[a5] = r5.value), t5 = r5.index;
              }
              return B3(b3(t5, e4), r5);
            });
          }, e3.string = K2, e3.succeed = X2, e3.takeWhile = function(n4) {
            return k3(n4), e3(function(t4, r4) {
              for (var e4 = r4; e4 < t4.length && n4(L3(t4, e4)); )
                e4++;
              return b3(e4, t4.slice(r4, e4));
            });
          }, e3.test = nn2, e3.whitespace = pn, e3["fantasy-land/empty"] = rn, e3["fantasy-land/of"] = X2, e3.Binary = { bitSeq: l4, bitSeqObj: function(n4) {
            s4();
            var t4 = {}, r4 = 0, e4 = a3(function(n5) {
              if (E2(n5)) {
                var e5 = n5;
                if (2 !== e5.length)
                  throw new Error("[" + e5.join(", ") + "] should be length 2, got length " + e5.length);
                if (P3(e5[0]), O2(e5[1]), Object.prototype.hasOwnProperty.call(t4, e5[0]))
                  throw new Error("duplicate key in bitSeqObj: " + e5[0]);
                return t4[e5[0]] = true, r4++, e5;
              }
              return O2(n5), [null, n5];
            }, n4);
            if (r4 < 1)
              throw new Error("bitSeqObj expects at least one named pair, got [" + n4.join(", ") + "]");
            var u4 = a3(function(n5) {
              return n5[0];
            }, e4);
            return l4(a3(function(n5) {
              return n5[1];
            }, e4)).map(function(n5) {
              return i3(function(n6, t5) {
                return null !== t5[0] && (n6[t5[0]] = t5[1]), n6;
              }, {}, a3(function(t5, r5) {
                return [t5, n5[r5]];
              }, u4));
            });
          }, byte: function(n4) {
            if (s4(), O2(n4), n4 > 255)
              throw new Error("Value specified to byte constructor (" + n4 + "=0x" + n4.toString(16) + ") is larger in value than a single byte.");
            var t4 = (n4 > 15 ? "0x" : "0x0") + n4.toString(16);
            return e3(function(r4, e4) {
              var u4 = L3(r4, e4);
              return u4 === n4 ? b3(e4 + 1, u4) : x4(e4, t4);
            });
          }, buffer: function(n4) {
            return h3("buffer", n4).map(function(n5) {
              return Buffer.from(n5);
            });
          }, encodedString: function(n4, t4) {
            return h3("string", t4).map(function(t5) {
              return t5.toString(n4);
            });
          }, uintBE: d2, uint8BE: d2(1), uint16BE: d2(2), uint32BE: d2(4), uintLE: v3, uint8LE: v3(1), uint16LE: v3(2), uint32LE: v3(4), intBE: g4, int8BE: g4(1), int16BE: g4(2), int32BE: g4(4), intLE: m3, int8LE: m3(1), int16LE: m3(2), int32LE: m3(4), floatBE: h3("floatBE", 4).map(function(n4) {
            return n4.readFloatBE(0);
          }), floatLE: h3("floatLE", 4).map(function(n4) {
            return n4.readFloatLE(0);
          }), doubleBE: h3("doubleBE", 8).map(function(n4) {
            return n4.readDoubleBE(0);
          }), doubleLE: h3("doubleLE", 8).map(function(n4) {
            return n4.readDoubleLE(0);
          }) }, n3.exports = e3;
        }]);
      });
    })(parsimmon_umd_min, parsimmon_umd_min.exports);
    var parsimmon_umd_minExports = parsimmon_umd_min.exports;
    var emojiRegex = () => {
      return /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC3\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC08\uDC26](?:\u200D\u2B1B)?|[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
    };
    function normalizeDuration(dur) {
      if (dur === void 0 || dur === null)
        return dur;
      return dur.shiftToAll().normalize();
    }
    function getFileTitle(path) {
      if (path.includes("/"))
        path = path.substring(path.lastIndexOf("/") + 1);
      if (path.endsWith(".md"))
        path = path.substring(0, path.length - 3);
      return path;
    }
    parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regex(new RegExp(emojiRegex(), "")), parsimmon_umd_minExports.regex(/[0-9\p{Letter}_-]+/u).map((str) => str.toLocaleLowerCase()), parsimmon_umd_minExports.whitespace.map((_3) => "-"), parsimmon_umd_minExports.any.map((_3) => "")).many().map((result) => result.join(""));
    var HEADER_CANONICALIZER = parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regex(new RegExp(emojiRegex(), "")), parsimmon_umd_minExports.regex(/[0-9\p{Letter}_-]+/u), parsimmon_umd_minExports.whitespace.map((_3) => " "), parsimmon_umd_minExports.any.map((_3) => " ")).many().map((result) => {
      return result.join("").split(/\s+/).join(" ").trim();
    });
    function normalizeHeaderForLink(header) {
      return HEADER_CANONICALIZER.tryParse(header);
    }
    function renderMinimalDuration(dur) {
      dur = normalizeDuration(dur);
      dur = Duration.fromObject(Object.fromEntries(Object.entries(dur.toObject()).filter(([, quantity]) => quantity != 0)));
      return dur.toHuman();
    }
    var Values;
    (function(Values2) {
      function toString(field, setting = DEFAULT_QUERY_SETTINGS, recursive = false) {
        let wrapped = wrapValue(field);
        if (!wrapped)
          return setting.renderNullAs;
        switch (wrapped.type) {
          case "null":
            return setting.renderNullAs;
          case "string":
            return wrapped.value;
          case "number":
          case "boolean":
            return "" + wrapped.value;
          case "html":
            return wrapped.value.outerHTML;
          case "widget":
            return wrapped.value.markdown();
          case "link":
            return wrapped.value.markdown();
          case "function":
            return "<function>";
          case "array":
            let result = "";
            if (recursive)
              result += "[";
            result += wrapped.value.map((f3) => toString(f3, setting, true)).join(", ");
            if (recursive)
              result += "]";
            return result;
          case "object":
            return "{ " + Object.entries(wrapped.value).map((e3) => e3[0] + ": " + toString(e3[1], setting, true)).join(", ") + " }";
          case "date":
            if (wrapped.value.second == 0 && wrapped.value.hour == 0 && wrapped.value.minute == 0) {
              return wrapped.value.toFormat(setting.defaultDateFormat);
            }
            return wrapped.value.toFormat(setting.defaultDateTimeFormat);
          case "duration":
            return renderMinimalDuration(wrapped.value);
        }
      }
      Values2.toString = toString;
      function wrapValue(val) {
        if (isNull(val))
          return { type: "null", value: val };
        else if (isNumber3(val))
          return { type: "number", value: val };
        else if (isString2(val))
          return { type: "string", value: val };
        else if (isBoolean(val))
          return { type: "boolean", value: val };
        else if (isDuration(val))
          return { type: "duration", value: val };
        else if (isDate3(val))
          return { type: "date", value: val };
        else if (isWidget(val))
          return { type: "widget", value: val };
        else if (isArray2(val))
          return { type: "array", value: val };
        else if (isLink(val))
          return { type: "link", value: val };
        else if (isFunction(val))
          return { type: "function", value: val };
        else if (isHtml(val))
          return { type: "html", value: val };
        else if (isObject2(val))
          return { type: "object", value: val };
        else
          return void 0;
      }
      Values2.wrapValue = wrapValue;
      function mapLeaves(val, func) {
        if (isObject2(val)) {
          let result = {};
          for (let [key, value] of Object.entries(val))
            result[key] = mapLeaves(value, func);
          return result;
        } else if (isArray2(val)) {
          let result = [];
          for (let value of val)
            result.push(mapLeaves(value, func));
          return result;
        } else {
          return func(val);
        }
      }
      Values2.mapLeaves = mapLeaves;
      function compareValue(val1, val2, linkNormalizer) {
        var _a, _b;
        if (val1 === void 0)
          val1 = null;
        if (val2 === void 0)
          val2 = null;
        if (val1 === null && val2 === null)
          return 0;
        else if (val1 === null)
          return -1;
        else if (val2 === null)
          return 1;
        let wrap1 = wrapValue(val1);
        let wrap2 = wrapValue(val2);
        if (wrap1 === void 0 && wrap2 === void 0)
          return 0;
        else if (wrap1 === void 0)
          return -1;
        else if (wrap2 === void 0)
          return 1;
        if (wrap1.type != wrap2.type)
          return wrap1.type.localeCompare(wrap2.type);
        if (wrap1.value === wrap2.value)
          return 0;
        switch (wrap1.type) {
          case "string":
            return wrap1.value.localeCompare(wrap2.value);
          case "number":
            if (wrap1.value < wrap2.value)
              return -1;
            else if (wrap1.value == wrap2.value)
              return 0;
            return 1;
          case "null":
            return 0;
          case "boolean":
            if (wrap1.value == wrap2.value)
              return 0;
            else
              return wrap1.value ? 1 : -1;
          case "link":
            let link1 = wrap1.value;
            let link2 = wrap2.value;
            let normalize = linkNormalizer != null ? linkNormalizer : (x4) => x4;
            let pathCompare = normalize(link1.path).localeCompare(normalize(link2.path));
            if (pathCompare != 0)
              return pathCompare;
            let typeCompare = link1.type.localeCompare(link2.type);
            if (typeCompare != 0)
              return typeCompare;
            if (link1.subpath && !link2.subpath)
              return 1;
            if (!link1.subpath && link2.subpath)
              return -1;
            if (!link1.subpath && !link2.subpath)
              return 0;
            return ((_a = link1.subpath) != null ? _a : "").localeCompare((_b = link2.subpath) != null ? _b : "");
          case "date":
            return wrap1.value < wrap2.value ? -1 : wrap1.value.equals(wrap2.value) ? 0 : 1;
          case "duration":
            return wrap1.value < wrap2.value ? -1 : wrap1.value.equals(wrap2.value) ? 0 : 1;
          case "array":
            let f1 = wrap1.value;
            let f22 = wrap2.value;
            for (let index8 = 0; index8 < Math.min(f1.length, f22.length); index8++) {
              let comp = compareValue(f1[index8], f22[index8]);
              if (comp != 0)
                return comp;
            }
            return f1.length - f22.length;
          case "object":
            let o1 = wrap1.value;
            let o2 = wrap2.value;
            let k1 = Array.from(Object.keys(o1));
            let k22 = Array.from(Object.keys(o2));
            k1.sort();
            k22.sort();
            let keyCompare = compareValue(k1, k22);
            if (keyCompare != 0)
              return keyCompare;
            for (let key of k1) {
              let comp = compareValue(o1[key], o2[key]);
              if (comp != 0)
                return comp;
            }
            return 0;
          case "widget":
          case "html":
          case "function":
            return 0;
        }
      }
      Values2.compareValue = compareValue;
      function typeOf(val) {
        var _a;
        return (_a = wrapValue(val)) == null ? void 0 : _a.type;
      }
      Values2.typeOf = typeOf;
      function isTruthy2(field) {
        let wrapped = wrapValue(field);
        if (!wrapped)
          return false;
        switch (wrapped.type) {
          case "number":
            return wrapped.value != 0;
          case "string":
            return wrapped.value.length > 0;
          case "boolean":
            return wrapped.value;
          case "link":
            return !!wrapped.value.path;
          case "date":
            return wrapped.value.toMillis() != 0;
          case "duration":
            return wrapped.value.as("seconds") != 0;
          case "object":
            return Object.keys(wrapped.value).length > 0;
          case "array":
            return wrapped.value.length > 0;
          case "null":
            return false;
          case "html":
          case "widget":
          case "function":
            return true;
        }
      }
      Values2.isTruthy = isTruthy2;
      function deepCopy(field) {
        if (field === null || field === void 0)
          return field;
        if (Values2.isArray(field)) {
          return [].concat(field.map((v3) => deepCopy(v3)));
        } else if (Values2.isObject(field)) {
          let result = {};
          for (let [key, value] of Object.entries(field))
            result[key] = deepCopy(value);
          return result;
        } else {
          return field;
        }
      }
      Values2.deepCopy = deepCopy;
      function isString2(val) {
        return typeof val == "string";
      }
      Values2.isString = isString2;
      function isNumber3(val) {
        return typeof val == "number";
      }
      Values2.isNumber = isNumber3;
      function isDate3(val) {
        return val instanceof DateTime2;
      }
      Values2.isDate = isDate3;
      function isDuration(val) {
        return val instanceof Duration;
      }
      Values2.isDuration = isDuration;
      function isNull(val) {
        return val === null || val === void 0;
      }
      Values2.isNull = isNull;
      function isArray2(val) {
        return Array.isArray(val);
      }
      Values2.isArray = isArray2;
      function isBoolean(val) {
        return typeof val === "boolean";
      }
      Values2.isBoolean = isBoolean;
      function isLink(val) {
        return val instanceof Link;
      }
      Values2.isLink = isLink;
      function isWidget(val) {
        return val instanceof Widget;
      }
      Values2.isWidget = isWidget;
      function isHtml(val) {
        if (typeof HTMLElement !== "undefined") {
          return val instanceof HTMLElement;
        } else {
          return false;
        }
      }
      Values2.isHtml = isHtml;
      function isObject2(val) {
        return typeof val == "object" && !isHtml(val) && !isWidget(val) && !isArray2(val) && !isDuration(val) && !isDate3(val) && !isLink(val) && val !== void 0 && !isNull(val);
      }
      Values2.isObject = isObject2;
      function isFunction(val) {
        return typeof val == "function";
      }
      Values2.isFunction = isFunction;
    })(Values || (Values = {}));
    var Groupings;
    (function(Groupings2) {
      function isElementGroup(entry) {
        return Values.isObject(entry) && Object.keys(entry).length == 2 && "key" in entry && "rows" in entry;
      }
      Groupings2.isElementGroup = isElementGroup;
      function isGrouping(entry) {
        for (let element of entry)
          if (!isElementGroup(element))
            return false;
        return true;
      }
      Groupings2.isGrouping = isGrouping;
      function count(elements) {
        if (isGrouping(elements)) {
          let result = 0;
          for (let subgroup of elements)
            result += count(subgroup.rows);
          return result;
        } else {
          return elements.length;
        }
      }
      Groupings2.count = count;
    })(Groupings || (Groupings = {}));
    var Link = class {
      constructor(fields) {
        /** The file path this link points to. */
        __publicField(this, "path");
        /** The display name associated with the link. */
        __publicField(this, "display");
        /** The block ID or header this link points to within a file, if relevant. */
        __publicField(this, "subpath");
        /** Is this link an embedded link (!)? */
        __publicField(this, "embed");
        /** The type of this link, which determines what 'subpath' refers to, if anything. */
        __publicField(this, "type");
        Object.assign(this, fields);
      }
      /** Create a link to a specific file. */
      static file(path, embed = false, display2) {
        return new Link({
          path,
          embed,
          display: display2,
          subpath: void 0,
          type: "file"
        });
      }
      static infer(linkpath, embed = false, display2) {
        if (linkpath.includes("#^")) {
          let split2 = linkpath.split("#^");
          return Link.block(split2[0], split2[1], embed, display2);
        } else if (linkpath.includes("#")) {
          let split2 = linkpath.split("#");
          return Link.header(split2[0], split2[1], embed, display2);
        } else
          return Link.file(linkpath, embed, display2);
      }
      /** Create a link to a specific file and header in that file. */
      static header(path, header, embed, display2) {
        return new Link({
          path,
          embed,
          display: display2,
          subpath: normalizeHeaderForLink(header),
          type: "header"
        });
      }
      /** Create a link to a specific file and block in that file. */
      static block(path, blockId, embed, display2) {
        return new Link({
          path,
          embed,
          display: display2,
          subpath: blockId,
          type: "block"
        });
      }
      static fromObject(object) {
        return new Link(object);
      }
      /** Checks for link equality (i.e., that the links are pointing to the same exact location). */
      equals(other) {
        if (other == void 0 || other == null)
          return false;
        return this.path == other.path && this.type == other.type && this.subpath == other.subpath;
      }
      /** Convert this link to it's markdown representation. */
      toString() {
        return this.markdown();
      }
      /** Convert this link to a raw object which is serialization-friendly. */
      toObject() {
        return { path: this.path, type: this.type, subpath: this.subpath, display: this.display, embed: this.embed };
      }
      /** Update this link with a new path. */
      //@ts-ignore; error appeared after updating Obsidian to 0.15.4; it also updated other packages but didn't say which
      withPath(path) {
        return new Link(Object.assign({}, this, { path }));
      }
      /** Return a new link which points to the same location but with a new display value. */
      withDisplay(display2) {
        return new Link(Object.assign({}, this, { display: display2 }));
      }
      /** Convert a file link into a link to a specific header. */
      withHeader(header) {
        return Link.header(this.path, header, this.embed, this.display);
      }
      /** Convert any link into a link to its file. */
      toFile() {
        return Link.file(this.path, this.embed, this.display);
      }
      /** Convert this link into an embedded link. */
      toEmbed() {
        if (this.embed) {
          return this;
        } else {
          let link = new Link(this);
          link.embed = true;
          return link;
        }
      }
      /** Convert this link into a non-embedded link. */
      fromEmbed() {
        if (!this.embed) {
          return this;
        } else {
          let link = new Link(this);
          link.embed = false;
          return link;
        }
      }
      /** Convert this link to markdown so it can be rendered. */
      markdown() {
        let result = (this.embed ? "!" : "") + "[[" + this.obsidianLink();
        if (this.display) {
          result += "|" + this.display;
        } else {
          result += "|" + getFileTitle(this.path);
          if (this.type == "header" || this.type == "block")
            result += " > " + this.subpath;
        }
        result += "]]";
        return result;
      }
      /** Convert the inner part of the link to something that Obsidian can open / understand. */
      obsidianLink() {
        var _a, _b;
        const escaped = this.path.replaceAll("|", "\\|");
        if (this.type == "header")
          return escaped + "#" + ((_a = this.subpath) == null ? void 0 : _a.replaceAll("|", "\\|"));
        if (this.type == "block")
          return escaped + "#^" + ((_b = this.subpath) == null ? void 0 : _b.replaceAll("|", "\\|"));
        else
          return escaped;
      }
      /** The stripped name of the file this link points to. */
      fileName() {
        return getFileTitle(this.path).replace(".md", "");
      }
    };
    var Widget = class {
      constructor($widget) {
        __publicField(this, "$widget");
        this.$widget = $widget;
      }
    };
    var ListPairWidget = class extends Widget {
      constructor(key, value) {
        super("dataview:list-pair");
        __publicField(this, "key");
        __publicField(this, "value");
        this.key = key;
        this.value = value;
      }
      markdown() {
        return `${Values.toString(this.key)}: ${Values.toString(this.value)}`;
      }
    };
    var ExternalLinkWidget = class extends Widget {
      constructor(url, display2) {
        super("dataview:external-link");
        __publicField(this, "url");
        __publicField(this, "display");
        this.url = url;
        this.display = display2;
      }
      markdown() {
        var _a;
        return `[${(_a = this.display) != null ? _a : this.url}](${this.url})`;
      }
    };
    var Widgets;
    (function(Widgets2) {
      function listPair(key, value) {
        return new ListPairWidget(key, value);
      }
      Widgets2.listPair = listPair;
      function externalLink(url, display2) {
        return new ExternalLinkWidget(url, display2);
      }
      Widgets2.externalLink = externalLink;
      function isListPair(widget) {
        return widget.$widget === "dataview:list-pair";
      }
      Widgets2.isListPair = isListPair;
      function isExternalLink(widget) {
        return widget.$widget === "dataview:external-link";
      }
      Widgets2.isExternalLink = isExternalLink;
      function isBuiltin(widget) {
        return isListPair(widget) || isExternalLink(widget);
      }
      Widgets2.isBuiltin = isBuiltin;
    })(Widgets || (Widgets = {}));
    var Fields;
    (function(Fields2) {
      function variable(name) {
        return { type: "variable", name };
      }
      Fields2.variable = variable;
      function literal(value) {
        return { type: "literal", value };
      }
      Fields2.literal = literal;
      function binaryOp(left, op, right) {
        return { type: "binaryop", left, op, right };
      }
      Fields2.binaryOp = binaryOp;
      function index8(obj, index9) {
        return { type: "index", object: obj, index: index9 };
      }
      Fields2.index = index8;
      function indexVariable(name) {
        let parts = name.split(".");
        let result = Fields2.variable(parts[0]);
        for (let index9 = 1; index9 < parts.length; index9++) {
          result = Fields2.index(result, Fields2.literal(parts[index9]));
        }
        return result;
      }
      Fields2.indexVariable = indexVariable;
      function lambda(args, value) {
        return { type: "lambda", arguments: args, value };
      }
      Fields2.lambda = lambda;
      function func(func2, args) {
        return { type: "function", func: func2, arguments: args };
      }
      Fields2.func = func;
      function list(values) {
        return { type: "list", values };
      }
      Fields2.list = list;
      function object(values) {
        return { type: "object", values };
      }
      Fields2.object = object;
      function negate(child) {
        return { type: "negated", child };
      }
      Fields2.negate = negate;
      function isCompareOp(op) {
        return op == "<=" || op == "<" || op == ">" || op == ">=" || op == "!=" || op == "=";
      }
      Fields2.isCompareOp = isCompareOp;
      Fields2.NULL = Fields2.literal(null);
    })(Fields || (Fields = {}));
    var Sources;
    (function(Sources2) {
      function tag(tag2) {
        return { type: "tag", tag: tag2 };
      }
      Sources2.tag = tag;
      function csv(path) {
        return { type: "csv", path };
      }
      Sources2.csv = csv;
      function folder(prefix) {
        return { type: "folder", folder: prefix };
      }
      Sources2.folder = folder;
      function link(file, incoming) {
        return { type: "link", file, direction: incoming ? "incoming" : "outgoing" };
      }
      Sources2.link = link;
      function binaryOp(left, op, right) {
        return { type: "binaryop", left, op, right };
      }
      Sources2.binaryOp = binaryOp;
      function and(left, right) {
        return { type: "binaryop", left, op: "&", right };
      }
      Sources2.and = and;
      function or(left, right) {
        return { type: "binaryop", left, op: "|", right };
      }
      Sources2.or = or;
      function negate(child) {
        return { type: "negate", child };
      }
      Sources2.negate = negate;
      function empty2() {
        return { type: "empty" };
      }
      Sources2.empty = empty2;
    })(Sources || (Sources = {}));
    var EMOJI_REGEX = new RegExp(emojiRegex(), "");
    var DURATION_TYPES = {
      year: Duration.fromObject({ years: 1 }),
      years: Duration.fromObject({ years: 1 }),
      yr: Duration.fromObject({ years: 1 }),
      yrs: Duration.fromObject({ years: 1 }),
      month: Duration.fromObject({ months: 1 }),
      months: Duration.fromObject({ months: 1 }),
      mo: Duration.fromObject({ months: 1 }),
      mos: Duration.fromObject({ months: 1 }),
      week: Duration.fromObject({ weeks: 1 }),
      weeks: Duration.fromObject({ weeks: 1 }),
      wk: Duration.fromObject({ weeks: 1 }),
      wks: Duration.fromObject({ weeks: 1 }),
      w: Duration.fromObject({ weeks: 1 }),
      day: Duration.fromObject({ days: 1 }),
      days: Duration.fromObject({ days: 1 }),
      d: Duration.fromObject({ days: 1 }),
      hour: Duration.fromObject({ hours: 1 }),
      hours: Duration.fromObject({ hours: 1 }),
      hr: Duration.fromObject({ hours: 1 }),
      hrs: Duration.fromObject({ hours: 1 }),
      h: Duration.fromObject({ hours: 1 }),
      minute: Duration.fromObject({ minutes: 1 }),
      minutes: Duration.fromObject({ minutes: 1 }),
      min: Duration.fromObject({ minutes: 1 }),
      mins: Duration.fromObject({ minutes: 1 }),
      m: Duration.fromObject({ minutes: 1 }),
      second: Duration.fromObject({ seconds: 1 }),
      seconds: Duration.fromObject({ seconds: 1 }),
      sec: Duration.fromObject({ seconds: 1 }),
      secs: Duration.fromObject({ seconds: 1 }),
      s: Duration.fromObject({ seconds: 1 })
    };
    var DATE_SHORTHANDS = {
      now: () => DateTime2.local(),
      today: () => DateTime2.local().startOf("day"),
      yesterday: () => DateTime2.local().startOf("day").minus(Duration.fromObject({ days: 1 })),
      tomorrow: () => DateTime2.local().startOf("day").plus(Duration.fromObject({ days: 1 })),
      sow: () => DateTime2.local().startOf("week"),
      "start-of-week": () => DateTime2.local().startOf("week"),
      eow: () => DateTime2.local().endOf("week"),
      "end-of-week": () => DateTime2.local().endOf("week"),
      soy: () => DateTime2.local().startOf("year"),
      "start-of-year": () => DateTime2.local().startOf("year"),
      eoy: () => DateTime2.local().endOf("year"),
      "end-of-year": () => DateTime2.local().endOf("year"),
      som: () => DateTime2.local().startOf("month"),
      "start-of-month": () => DateTime2.local().startOf("month"),
      eom: () => DateTime2.local().endOf("month"),
      "end-of-month": () => DateTime2.local().endOf("month")
    };
    var KEYWORDS = ["FROM", "WHERE", "LIMIT", "GROUP", "FLATTEN"];
    function splitOnUnescapedPipe(link) {
      let pipe = -1;
      while ((pipe = link.indexOf("|", pipe + 1)) >= 0) {
        if (pipe > 0 && link[pipe - 1] == "\\")
          continue;
        return [link.substring(0, pipe).replace(/\\\|/g, "|"), link.substring(pipe + 1)];
      }
      return [link.replace(/\\\|/g, "|"), void 0];
    }
    function parseInnerLink(rawlink) {
      let [link, display2] = splitOnUnescapedPipe(rawlink);
      return Link.infer(link, false, display2);
    }
    function createBinaryParser(child, sep, combine2) {
      return parsimmon_umd_minExports.seqMap(child, parsimmon_umd_minExports.seq(parsimmon_umd_minExports.optWhitespace, sep, parsimmon_umd_minExports.optWhitespace, child).many(), (first, rest) => {
        if (rest.length == 0)
          return first;
        let node = combine2(first, rest[0][1], rest[0][3]);
        for (let index8 = 1; index8 < rest.length; index8++) {
          node = combine2(node, rest[index8][1], rest[index8][3]);
        }
        return node;
      });
    }
    function chainOpt(base, ...funcs) {
      return parsimmon_umd_minExports.custom((success, failure) => {
        return (input, i3) => {
          let result = base._(input, i3);
          if (!result.status)
            return result;
          for (let func of funcs) {
            let next = func(result.value)._(input, result.index);
            if (!next.status)
              return result;
            result = next;
          }
          return result;
        };
      });
    }
    var EXPRESSION = parsimmon_umd_minExports.createLanguage({
      // A floating point number; the decimal point is optional.
      number: (q3) => parsimmon_umd_minExports.regexp(/-?[0-9]+(\.[0-9]+)?/).map((str) => Number.parseFloat(str)).desc("number"),
      // A quote-surrounded string which supports escape characters ('\').
      string: (q3) => parsimmon_umd_minExports.string('"').then(parsimmon_umd_minExports.alt(q3.escapeCharacter, parsimmon_umd_minExports.noneOf('"\\')).atLeast(0).map((chars) => chars.join(""))).skip(parsimmon_umd_minExports.string('"')).desc("string"),
      escapeCharacter: (_3) => parsimmon_umd_minExports.string("\\").then(parsimmon_umd_minExports.any).map((escaped) => {
        if (escaped === '"')
          return '"';
        if (escaped === "\\")
          return "\\";
        else
          return "\\" + escaped;
      }),
      // A boolean true/false value.
      bool: (_3) => parsimmon_umd_minExports.regexp(/true|false|True|False/).map((str) => str.toLowerCase() == "true").desc("boolean ('true' or 'false')"),
      // A tag of the form '#stuff/hello-there'.
      tag: (_3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("#"), parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regexp(/[^\u2000-\u206F\u2E00-\u2E7F'!"#$%&()*+,.:;<=>?@^`{|}~\[\]\\\s]/).desc("text")).many(), (start, rest) => start + rest.join("")).desc("tag ('#hello/stuff')"),
      // A variable identifier, which is alphanumeric and must start with a letter or... emoji.
      identifier: (_3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regexp(/\p{Letter}/u), parsimmon_umd_minExports.regexp(EMOJI_REGEX).desc("text")), parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regexp(/[0-9\p{Letter}_-]/u), parsimmon_umd_minExports.regexp(EMOJI_REGEX).desc("text")).many(), (first, rest) => first + rest.join("")).desc("variable identifier"),
      // An Obsidian link of the form [[<link>]].
      link: (_3) => parsimmon_umd_minExports.regexp(/\[\[([^\[\]]*?)\]\]/u, 1).map((linkInner) => parseInnerLink(linkInner)).desc("file link"),
      // An embeddable link which can start with '!'. This overlaps with the normal negation operator, so it is only
      // provided for metadata parsing.
      embedLink: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("!").atMost(1), q3.link, (p3, l4) => {
        if (p3.length > 0)
          l4.embed = true;
        return l4;
      }).desc("file link"),
      // Binary plus or minus operator.
      binaryPlusMinus: (_3) => parsimmon_umd_minExports.regexp(/\+|-/).map((str) => str).desc("'+' or '-'"),
      // Binary times or divide operator.
      binaryMulDiv: (_3) => parsimmon_umd_minExports.regexp(/\*|\/|%/).map((str) => str).desc("'*' or '/' or '%'"),
      // Binary comparison operator.
      binaryCompareOp: (_3) => parsimmon_umd_minExports.regexp(/>=|<=|!=|>|<|=/).map((str) => str).desc("'>=' or '<=' or '!=' or '=' or '>' or '<'"),
      // Binary boolean combination operator.
      binaryBooleanOp: (_3) => parsimmon_umd_minExports.regexp(/and|or|&|\|/i).map((str) => {
        if (str.toLowerCase() == "and")
          return "&";
        else if (str.toLowerCase() == "or")
          return "|";
        else
          return str;
      }).desc("'and' or 'or'"),
      // A date which can be YYYY-MM[-DDTHH:mm:ss].
      rootDate: (_3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/\d{4}/), parsimmon_umd_minExports.string("-"), parsimmon_umd_minExports.regexp(/\d{2}/), (year, _4, month) => {
        return DateTime2.fromObject({ year: Number.parseInt(year), month: Number.parseInt(month) });
      }).desc("date in format YYYY-MM[-DDTHH-MM-SS.MS]"),
      dateShorthand: (_3) => parsimmon_umd_minExports.alt(...Object.keys(DATE_SHORTHANDS).sort((a3, b3) => b3.length - a3.length).map(parsimmon_umd_minExports.string)),
      date: (q3) => chainOpt(q3.rootDate, (ym) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("-"), parsimmon_umd_minExports.regexp(/\d{2}/), (_3, day) => ym.set({ day: Number.parseInt(day) })), (ymd) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("T"), parsimmon_umd_minExports.regexp(/\d{2}/), (_3, hour) => ymd.set({ hour: Number.parseInt(hour) })), (ymdh) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string(":"), parsimmon_umd_minExports.regexp(/\d{2}/), (_3, minute) => ymdh.set({ minute: Number.parseInt(minute) })), (ymdhm) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string(":"), parsimmon_umd_minExports.regexp(/\d{2}/), (_3, second) => ymdhm.set({ second: Number.parseInt(second) })), (ymdhms) => parsimmon_umd_minExports.alt(
        parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("."), parsimmon_umd_minExports.regexp(/\d{3}/), (_3, millisecond) => ymdhms.set({ millisecond: Number.parseInt(millisecond) })),
        parsimmon_umd_minExports.succeed(ymdhms)
        // pass
      ), (dt) => parsimmon_umd_minExports.alt(parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("+").or(parsimmon_umd_minExports.string("-")), parsimmon_umd_minExports.regexp(/\d{1,2}(:\d{2})?/), (pm, hr) => dt.setZone("UTC" + pm + hr, { keepLocalTime: true })), parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("Z"), () => dt.setZone("utc", { keepLocalTime: true })), parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("["), parsimmon_umd_minExports.regexp(/[0-9A-Za-z+-\/]+/u), parsimmon_umd_minExports.string("]"), (_a, zone, _b) => dt.setZone(zone, { keepLocalTime: true })))).assert((dt) => dt.isValid, "valid date").desc("date in format YYYY-MM[-DDTHH-MM-SS.MS]"),
      // A date, plus various shorthand times of day it could be.
      datePlus: (q3) => parsimmon_umd_minExports.alt(q3.dateShorthand.map((d2) => DATE_SHORTHANDS[d2]()), q3.date).desc("date in format YYYY-MM[-DDTHH-MM-SS.MS] or in shorthand"),
      // A duration of time.
      durationType: (_3) => parsimmon_umd_minExports.alt(...Object.keys(DURATION_TYPES).sort((a3, b3) => b3.length - a3.length).map(parsimmon_umd_minExports.string)),
      duration: (q3) => parsimmon_umd_minExports.seqMap(q3.number, parsimmon_umd_minExports.optWhitespace, q3.durationType, (count, _3, t3) => DURATION_TYPES[t3].mapUnits((x4) => x4 * count)).sepBy1(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace).or(parsimmon_umd_minExports.optWhitespace)).map((durations) => durations.reduce((p3, c3) => p3.plus(c3))).desc("duration like 4hr2min"),
      // A raw null value.
      rawNull: (_3) => parsimmon_umd_minExports.string("null"),
      // Source parsing.
      tagSource: (q3) => q3.tag.map((tag) => Sources.tag(tag)),
      csvSource: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("csv(").skip(parsimmon_umd_minExports.optWhitespace), q3.string, parsimmon_umd_minExports.string(")"), (_1, path, _22) => Sources.csv(path)),
      linkIncomingSource: (q3) => q3.link.map((link) => Sources.link(link.path, true)),
      linkOutgoingSource: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("outgoing(").skip(parsimmon_umd_minExports.optWhitespace), q3.link, parsimmon_umd_minExports.string(")"), (_1, link, _22) => Sources.link(link.path, false)),
      folderSource: (q3) => q3.string.map((str) => Sources.folder(str)),
      parensSource: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("("), parsimmon_umd_minExports.optWhitespace, q3.source, parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string(")"), (_1, _22, field, _3, _4) => field),
      negateSource: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.alt(parsimmon_umd_minExports.string("-"), parsimmon_umd_minExports.string("!")), q3.atomSource, (_3, source) => Sources.negate(source)),
      atomSource: (q3) => parsimmon_umd_minExports.alt(q3.parensSource, q3.negateSource, q3.linkOutgoingSource, q3.linkIncomingSource, q3.folderSource, q3.tagSource, q3.csvSource),
      binaryOpSource: (q3) => createBinaryParser(q3.atomSource, q3.binaryBooleanOp.map((s4) => s4), Sources.binaryOp),
      source: (q3) => q3.binaryOpSource,
      // Field parsing.
      variableField: (q3) => q3.identifier.chain((r3) => {
        if (KEYWORDS.includes(r3.toUpperCase())) {
          return parsimmon_umd_minExports.fail("Variable fields cannot be a keyword (" + KEYWORDS.join(" or ") + ")");
        } else {
          return parsimmon_umd_minExports.succeed(Fields.variable(r3));
        }
      }).desc("variable"),
      numberField: (q3) => q3.number.map((val) => Fields.literal(val)).desc("number"),
      stringField: (q3) => q3.string.map((val) => Fields.literal(val)).desc("string"),
      boolField: (q3) => q3.bool.map((val) => Fields.literal(val)).desc("boolean"),
      dateField: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("date("), parsimmon_umd_minExports.optWhitespace, q3.datePlus, parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string(")"), (prefix, _1, date, _22, postfix) => Fields.literal(date)).desc("date"),
      durationField: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("dur("), parsimmon_umd_minExports.optWhitespace, q3.duration, parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string(")"), (prefix, _1, dur, _22, postfix) => Fields.literal(dur)).desc("duration"),
      nullField: (q3) => q3.rawNull.map((_3) => Fields.NULL),
      linkField: (q3) => q3.link.map((f3) => Fields.literal(f3)),
      listField: (q3) => q3.field.sepBy(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)).wrap(parsimmon_umd_minExports.string("[").skip(parsimmon_umd_minExports.optWhitespace), parsimmon_umd_minExports.optWhitespace.then(parsimmon_umd_minExports.string("]"))).map((l4) => Fields.list(l4)).desc("list ('[1, 2, 3]')"),
      objectField: (q3) => parsimmon_umd_minExports.seqMap(q3.identifier.or(q3.string), parsimmon_umd_minExports.string(":").trim(parsimmon_umd_minExports.optWhitespace), q3.field, (name, _sep, value) => {
        return { name, value };
      }).sepBy(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)).wrap(parsimmon_umd_minExports.string("{").skip(parsimmon_umd_minExports.optWhitespace), parsimmon_umd_minExports.optWhitespace.then(parsimmon_umd_minExports.string("}"))).map((vals) => {
        let res = {};
        for (let entry of vals)
          res[entry.name] = entry.value;
        return Fields.object(res);
      }).desc("object ('{ a: 1, b: 2 }')"),
      atomInlineField: (q3) => parsimmon_umd_minExports.alt(q3.date, q3.duration.map((d2) => normalizeDuration(d2)), q3.string, q3.tag, q3.embedLink, q3.bool, q3.number, q3.rawNull),
      inlineFieldList: (q3) => q3.atomInlineField.sepBy(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace).lookahead(q3.atomInlineField)),
      inlineField: (q3) => parsimmon_umd_minExports.alt(parsimmon_umd_minExports.seqMap(q3.atomInlineField, parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace), q3.inlineFieldList, (f3, _s, l4) => [f3].concat(l4)), q3.atomInlineField),
      atomField: (q3) => parsimmon_umd_minExports.alt(
        // Place embed links above negated fields as they are the special parser case '![[thing]]' and are generally unambigious.
        q3.embedLink.map((l4) => Fields.literal(l4)),
        q3.negatedField,
        q3.linkField,
        q3.listField,
        q3.objectField,
        q3.lambdaField,
        q3.parensField,
        q3.boolField,
        q3.numberField,
        q3.stringField,
        q3.dateField,
        q3.durationField,
        q3.nullField,
        q3.variableField
      ),
      indexField: (q3) => parsimmon_umd_minExports.seqMap(q3.atomField, parsimmon_umd_minExports.alt(q3.dotPostfix, q3.indexPostfix, q3.functionPostfix).many(), (obj, postfixes) => {
        let result = obj;
        for (let post of postfixes) {
          switch (post.type) {
            case "dot":
              result = Fields.index(result, Fields.literal(post.field));
              break;
            case "index":
              result = Fields.index(result, post.field);
              break;
            case "function":
              result = Fields.func(result, post.fields);
              break;
          }
        }
        return result;
      }),
      negatedField: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("!"), q3.indexField, (_3, field) => Fields.negate(field)).desc("negated field"),
      parensField: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("("), parsimmon_umd_minExports.optWhitespace, q3.field, parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string(")"), (_1, _22, field, _3, _4) => field),
      lambdaField: (q3) => parsimmon_umd_minExports.seqMap(q3.identifier.sepBy(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)).wrap(parsimmon_umd_minExports.string("(").trim(parsimmon_umd_minExports.optWhitespace), parsimmon_umd_minExports.string(")").trim(parsimmon_umd_minExports.optWhitespace)), parsimmon_umd_minExports.string("=>").trim(parsimmon_umd_minExports.optWhitespace), q3.field, (ident, _ignore, value) => {
        return { type: "lambda", arguments: ident, value };
      }),
      dotPostfix: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("."), q3.identifier, (_3, field) => {
        return { type: "dot", field };
      }),
      indexPostfix: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("["), parsimmon_umd_minExports.optWhitespace, q3.field, parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string("]"), (_3, _22, field, _32, _4) => {
        return { type: "index", field };
      }),
      functionPostfix: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("("), parsimmon_umd_minExports.optWhitespace, q3.field.sepBy(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)), parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string(")"), (_3, _1, fields, _22, _32) => {
        return { type: "function", fields };
      }),
      // The precedence hierarchy of operators - multiply/divide, add/subtract, compare, and then boolean operations.
      binaryMulDivField: (q3) => createBinaryParser(q3.indexField, q3.binaryMulDiv, Fields.binaryOp),
      binaryPlusMinusField: (q3) => createBinaryParser(q3.binaryMulDivField, q3.binaryPlusMinus, Fields.binaryOp),
      binaryCompareField: (q3) => createBinaryParser(q3.binaryPlusMinusField, q3.binaryCompareOp, Fields.binaryOp),
      binaryBooleanField: (q3) => createBinaryParser(q3.binaryCompareField, q3.binaryBooleanOp, Fields.binaryOp),
      binaryOpField: (q3) => q3.binaryBooleanField,
      field: (q3) => q3.binaryOpField
    });
    function parseField(text) {
      try {
        return Result.success(EXPRESSION.field.tryParse(text));
      } catch (error) {
        return Result.failure("" + error);
      }
    }
    var QueryFields;
    (function(QueryFields2) {
      function named(name, field) {
        return { name, field };
      }
      QueryFields2.named = named;
      function sortBy(field, dir) {
        return { field, direction: dir };
      }
      QueryFields2.sortBy = sortBy;
    })(QueryFields || (QueryFields = {}));
    function captureRaw(base) {
      return parsimmon_umd_minExports.custom((success, failure) => {
        return (input, i3) => {
          let result = base._(input, i3);
          if (!result.status)
            return result;
          return Object.assign({}, result, { value: [result.value, input.substring(i3, result.index)] });
        };
      });
    }
    function stripNewlines(text) {
      return text.split(/[\r\n]+/).map((t3) => t3.trim()).join("");
    }
    function precededByWhitespaceIfNotEof(if_eof, parser) {
      return parsimmon_umd_minExports.eof.map(if_eof).or(parsimmon_umd_minExports.whitespace.then(parser));
    }
    var QUERY_LANGUAGE = parsimmon_umd_minExports.createLanguage({
      // Simple atom parsing, like words, identifiers, numbers.
      queryType: (q3) => parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regexp(/TABLE|LIST|TASK|CALENDAR/i)).map((str) => str.toLowerCase()).desc("query type ('TABLE', 'LIST', 'TASK', or 'CALENDAR')"),
      explicitNamedField: (q3) => parsimmon_umd_minExports.seqMap(EXPRESSION.field.skip(parsimmon_umd_minExports.whitespace), parsimmon_umd_minExports.regexp(/AS/i).skip(parsimmon_umd_minExports.whitespace), EXPRESSION.identifier.or(EXPRESSION.string), (field, _as, ident) => QueryFields.named(ident, field)),
      comment: () => parsimmon_umd_minExports.Parser((input, i3) => {
        let line = input.substring(i3);
        if (!line.startsWith("//"))
          return parsimmon_umd_minExports.makeFailure(i3, "Not a comment");
        line = line.split("\n")[0];
        let comment = line.substring(2).trim();
        return parsimmon_umd_minExports.makeSuccess(i3 + line.length, comment);
      }),
      namedField: (q3) => parsimmon_umd_minExports.alt(q3.explicitNamedField, captureRaw(EXPRESSION.field).map(([value, text]) => QueryFields.named(stripNewlines(text), value))),
      sortField: (q3) => parsimmon_umd_minExports.seqMap(EXPRESSION.field.skip(parsimmon_umd_minExports.optWhitespace), parsimmon_umd_minExports.regexp(/ASCENDING|DESCENDING|ASC|DESC/i).atMost(1), (field, dir) => {
        let direction = dir.length == 0 ? "ascending" : dir[0].toLowerCase();
        if (direction == "desc")
          direction = "descending";
        if (direction == "asc")
          direction = "ascending";
        return {
          field,
          direction
        };
      }),
      headerClause: (q3) => q3.queryType.chain((type) => {
        switch (type) {
          case "table": {
            return precededByWhitespaceIfNotEof(() => ({ type, fields: [], showId: true }), parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/WITHOUT\s+ID/i).skip(parsimmon_umd_minExports.optWhitespace).atMost(1), parsimmon_umd_minExports.sepBy(q3.namedField, parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)), (withoutId, fields) => {
              return { type, fields, showId: withoutId.length == 0 };
            }));
          }
          case "list":
            return precededByWhitespaceIfNotEof(() => ({ type, format: void 0, showId: true }), parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/WITHOUT\s+ID/i).skip(parsimmon_umd_minExports.optWhitespace).atMost(1), EXPRESSION.field.atMost(1), (withoutId, format) => {
              return {
                type,
                format: format.length == 1 ? format[0] : void 0,
                showId: withoutId.length == 0
              };
            }));
          case "task":
            return parsimmon_umd_minExports.succeed({ type });
          case "calendar":
            return parsimmon_umd_minExports.whitespace.then(parsimmon_umd_minExports.seqMap(q3.namedField, (field) => {
              return {
                type,
                showId: true,
                field
              };
            }));
          default:
            return parsimmon_umd_minExports.fail(`Unrecognized query type '${type}'`);
        }
      }).desc("TABLE or LIST or TASK or CALENDAR"),
      fromClause: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/FROM/i), parsimmon_umd_minExports.whitespace, EXPRESSION.source, (_1, _22, source) => source),
      whereClause: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/WHERE/i), parsimmon_umd_minExports.whitespace, EXPRESSION.field, (where, _3, field) => {
        return { type: "where", clause: field };
      }).desc("WHERE <expression>"),
      sortByClause: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/SORT/i), parsimmon_umd_minExports.whitespace, q3.sortField.sepBy1(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)), (sort2, _1, fields) => {
        return { type: "sort", fields };
      }).desc("SORT field [ASC/DESC]"),
      limitClause: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/LIMIT/i), parsimmon_umd_minExports.whitespace, EXPRESSION.field, (limit, _1, field) => {
        return { type: "limit", amount: field };
      }).desc("LIMIT <value>"),
      flattenClause: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/FLATTEN/i).skip(parsimmon_umd_minExports.whitespace), q3.namedField, (_3, field) => {
        return { type: "flatten", field };
      }).desc("FLATTEN <value> [AS <name>]"),
      groupByClause: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/GROUP BY/i).skip(parsimmon_umd_minExports.whitespace), q3.namedField, (_3, field) => {
        return { type: "group", field };
      }).desc("GROUP BY <value> [AS <name>]"),
      // Full query parsing.
      clause: (q3) => parsimmon_umd_minExports.alt(q3.fromClause, q3.whereClause, q3.sortByClause, q3.limitClause, q3.groupByClause, q3.flattenClause),
      query: (q3) => parsimmon_umd_minExports.seqMap(q3.headerClause.trim(optionalWhitespaceOrComment), q3.fromClause.trim(optionalWhitespaceOrComment).atMost(1), q3.clause.trim(optionalWhitespaceOrComment).many(), (header, from, clauses) => {
        return {
          header,
          source: from.length == 0 ? Sources.folder("") : from[0],
          operations: clauses,
          settings: DEFAULT_QUERY_SETTINGS
        };
      })
    });
    var optionalWhitespaceOrComment = parsimmon_umd_minExports.alt(parsimmon_umd_minExports.whitespace, QUERY_LANGUAGE.comment).many().map((arr) => arr.join(""));
    var getAPI2 = (app) => {
      var _a;
      if (app)
        return (_a = app.plugins.plugins.dataview) == null ? void 0 : _a.api;
      else
        return window.DataviewAPI;
    };
    var isPluginEnabled = (app) => app.plugins.enabledPlugins.has("dataview");
    exports.DATE_SHORTHANDS = DATE_SHORTHANDS;
    exports.DURATION_TYPES = DURATION_TYPES;
    exports.EXPRESSION = EXPRESSION;
    exports.KEYWORDS = KEYWORDS;
    exports.QUERY_LANGUAGE = QUERY_LANGUAGE;
    exports.getAPI = getAPI2;
    exports.isPluginEnabled = isPluginEnabled;
    exports.parseField = parseField;
  }
});

// node_modules/ical.js/build/ical.js
var require_ical = __commonJS({
  "node_modules/ical.js/build/ical.js"(exports, module2) {
    var ICAL2;
    (function() {
      if (typeof module2 === "object") {
        ICAL2 = module2.exports;
      } else if (typeof HTMLScriptElement !== "undefined" && "noModule" in HTMLScriptElement.prototype) {
        window.ICAL = ICAL2 = {};
      } else if (typeof ICAL2 !== "object") {
        ICAL2 = {};
      }
    })();
    ICAL2.foldLength = 75;
    ICAL2.newLineChar = "\r\n";
    ICAL2.helpers = {
      /**
       * Compiles a list of all referenced TZIDs in all subcomponents and
       * removes any extra VTIMEZONE subcomponents. In addition, if any TZIDs
       * are referenced by a component, but a VTIMEZONE does not exist,
       * an attempt will be made to generate a VTIMEZONE using ICAL.TimezoneService.
       *
       * @param {ICAL.Component} vcal     The top-level VCALENDAR component.
       * @return {ICAL.Component}         The ICAL.Component that was passed in.
       */
      updateTimezones: function(vcal) {
        var allsubs, properties, vtimezones, reqTzid, i3, tzid;
        if (!vcal || vcal.name !== "vcalendar") {
          return vcal;
        }
        allsubs = vcal.getAllSubcomponents();
        properties = [];
        vtimezones = {};
        for (i3 = 0; i3 < allsubs.length; i3++) {
          if (allsubs[i3].name === "vtimezone") {
            tzid = allsubs[i3].getFirstProperty("tzid").getFirstValue();
            vtimezones[tzid] = allsubs[i3];
          } else {
            properties = properties.concat(allsubs[i3].getAllProperties());
          }
        }
        reqTzid = {};
        for (i3 = 0; i3 < properties.length; i3++) {
          if (tzid = properties[i3].getParameter("tzid")) {
            reqTzid[tzid] = true;
          }
        }
        for (i3 in vtimezones) {
          if (vtimezones.hasOwnProperty(i3) && !reqTzid[i3]) {
            vcal.removeSubcomponent(vtimezones[i3]);
          }
        }
        for (i3 in reqTzid) {
          if (reqTzid.hasOwnProperty(i3) && !vtimezones[i3] && ICAL2.TimezoneService.has(i3)) {
            vcal.addSubcomponent(ICAL2.TimezoneService.get(i3).component);
          }
        }
        return vcal;
      },
      /**
       * Checks if the given type is of the number type and also NaN.
       *
       * @param {Number} number     The number to check
       * @return {Boolean}          True, if the number is strictly NaN
       */
      isStrictlyNaN: function(number) {
        return typeof number === "number" && isNaN(number);
      },
      /**
       * Parses a string value that is expected to be an integer, when the valid is
       * not an integer throws a decoration error.
       *
       * @param {String} string     Raw string input
       * @return {Number}           Parsed integer
       */
      strictParseInt: function(string) {
        var result = parseInt(string, 10);
        if (ICAL2.helpers.isStrictlyNaN(result)) {
          throw new Error(
            'Could not extract integer from "' + string + '"'
          );
        }
        return result;
      },
      /**
       * Creates or returns a class instance of a given type with the initialization
       * data if the data is not already an instance of the given type.
       *
       * @example
       * var time = new ICAL.Time(...);
       * var result = ICAL.helpers.formatClassType(time, ICAL.Time);
       *
       * (result instanceof ICAL.Time)
       * // => true
       *
       * result = ICAL.helpers.formatClassType({}, ICAL.Time);
       * (result isntanceof ICAL.Time)
       * // => true
       *
       *
       * @param {Object} data       object initialization data
       * @param {Object} type       object type (like ICAL.Time)
       * @return {?}                An instance of the found type.
       */
      formatClassType: function formatClassType(data, type) {
        if (typeof data === "undefined") {
          return void 0;
        }
        if (data instanceof type) {
          return data;
        }
        return new type(data);
      },
      /**
       * Identical to indexOf but will only match values when they are not preceded
       * by a backslash character.
       *
       * @param {String} buffer         String to search
       * @param {String} search         Value to look for
       * @param {Number} pos            Start position
       * @return {Number}               The position, or -1 if not found
       */
      unescapedIndexOf: function(buffer, search, pos) {
        while ((pos = buffer.indexOf(search, pos)) !== -1) {
          if (pos > 0 && buffer[pos - 1] === "\\") {
            pos += 1;
          } else {
            return pos;
          }
        }
        return -1;
      },
      /**
       * Find the index for insertion using binary search.
       *
       * @param {Array} list            The list to search
       * @param {?} seekVal             The value to insert
       * @param {function(?,?)} cmpfunc The comparison func, that can
       *                                  compare two seekVals
       * @return {Number}               The insert position
       */
      binsearchInsert: function(list, seekVal, cmpfunc) {
        if (!list.length)
          return 0;
        var low = 0, high = list.length - 1, mid, cmpval;
        while (low <= high) {
          mid = low + Math.floor((high - low) / 2);
          cmpval = cmpfunc(seekVal, list[mid]);
          if (cmpval < 0)
            high = mid - 1;
          else if (cmpval > 0)
            low = mid + 1;
          else
            break;
        }
        if (cmpval < 0)
          return mid;
        else if (cmpval > 0)
          return mid + 1;
        else
          return mid;
      },
      /**
       * Convenience function for debug output
       * @private
       */
      dumpn: (
        /* istanbul ignore next */
        function() {
          if (!ICAL2.debug) {
            return;
          }
          if (typeof console !== "undefined" && "log" in console) {
            ICAL2.helpers.dumpn = function consoleDumpn(input) {
              console.log(input);
            };
          } else {
            ICAL2.helpers.dumpn = function geckoDumpn(input) {
              dump(input + "\n");
            };
          }
          ICAL2.helpers.dumpn(arguments[0]);
        }
      ),
      /**
       * Clone the passed object or primitive. By default a shallow clone will be
       * executed.
       *
       * @param {*} aSrc            The thing to clone
       * @param {Boolean=} aDeep    If true, a deep clone will be performed
       * @return {*}                The copy of the thing
       */
      clone: function(aSrc, aDeep) {
        if (!aSrc || typeof aSrc != "object") {
          return aSrc;
        } else if (aSrc instanceof Date) {
          return new Date(aSrc.getTime());
        } else if ("clone" in aSrc) {
          return aSrc.clone();
        } else if (Array.isArray(aSrc)) {
          var arr = [];
          for (var i3 = 0; i3 < aSrc.length; i3++) {
            arr.push(aDeep ? ICAL2.helpers.clone(aSrc[i3], true) : aSrc[i3]);
          }
          return arr;
        } else {
          var obj = {};
          for (var name in aSrc) {
            if (Object.prototype.hasOwnProperty.call(aSrc, name)) {
              if (aDeep) {
                obj[name] = ICAL2.helpers.clone(aSrc[name], true);
              } else {
                obj[name] = aSrc[name];
              }
            }
          }
          return obj;
        }
      },
      /**
       * Performs iCalendar line folding. A line ending character is inserted and
       * the next line begins with a whitespace.
       *
       * @example
       * SUMMARY:This line will be fold
       *  ed right in the middle of a word.
       *
       * @param {String} aLine      The line to fold
       * @return {String}           The folded line
       */
      foldline: function foldline(aLine) {
        var result = "";
        var line = aLine || "", pos = 0, line_length = 0;
        while (line.length) {
          var cp = line.codePointAt(pos);
          if (cp < 128)
            ++line_length;
          else if (cp < 2048)
            line_length += 2;
          else if (cp < 65536)
            line_length += 3;
          else
            line_length += 4;
          if (line_length < ICAL2.foldLength + 1)
            pos += cp > 65535 ? 2 : 1;
          else {
            result += ICAL2.newLineChar + " " + line.substring(0, pos);
            line = line.substring(pos);
            pos = line_length = 0;
          }
        }
        return result.substr(ICAL2.newLineChar.length + 1);
      },
      /**
       * Pads the given string or number with zeros so it will have at least two
       * characters.
       *
       * @param {String|Number} data    The string or number to pad
       * @return {String}               The number padded as a string
       */
      pad2: function pad(data) {
        if (typeof data !== "string") {
          if (typeof data === "number") {
            data = parseInt(data);
          }
          data = String(data);
        }
        var len = data.length;
        switch (len) {
          case 0:
            return "00";
          case 1:
            return "0" + data;
          default:
            return data;
        }
      },
      /**
       * Truncates the given number, correctly handling negative numbers.
       *
       * @param {Number} number     The number to truncate
       * @return {Number}           The truncated number
       */
      trunc: function trunc(number) {
        return number < 0 ? Math.ceil(number) : Math.floor(number);
      },
      /**
       * Poor-man's cross-browser inheritance for JavaScript. Doesn't support all
       * the features, but enough for our usage.
       *
       * @param {Function} base     The base class constructor function.
       * @param {Function} child    The child class constructor function.
       * @param {Object} extra      Extends the prototype with extra properties
       *                              and methods
       */
      inherits: function(base, child, extra) {
        function F4() {
        }
        F4.prototype = base.prototype;
        child.prototype = new F4();
        if (extra) {
          ICAL2.helpers.extend(extra, child.prototype);
        }
      },
      /**
       * Poor-man's cross-browser object extension. Doesn't support all the
       * features, but enough for our usage. Note that the target's properties are
       * not overwritten with the source properties.
       *
       * @example
       * var child = ICAL.helpers.extend(parent, {
       *   "bar": 123
       * });
       *
       * @param {Object} source     The object to extend
       * @param {Object} target     The object to extend with
       * @return {Object}           Returns the target.
       */
      extend: function(source, target) {
        for (var key in source) {
          var descr = Object.getOwnPropertyDescriptor(source, key);
          if (descr && !Object.getOwnPropertyDescriptor(target, key)) {
            Object.defineProperty(target, key, descr);
          }
        }
        return target;
      }
    };
    ICAL2.design = function() {
      "use strict";
      var FROM_ICAL_NEWLINE = /\\\\|\\;|\\,|\\[Nn]/g;
      var TO_ICAL_NEWLINE = /\\|;|,|\n/g;
      var FROM_VCARD_NEWLINE = /\\\\|\\,|\\[Nn]/g;
      var TO_VCARD_NEWLINE = /\\|,|\n/g;
      function createTextType(fromNewline, toNewline) {
        var result = {
          matches: /.*/,
          fromICAL: function(aValue, structuredEscape) {
            return replaceNewline(aValue, fromNewline, structuredEscape);
          },
          toICAL: function(aValue, structuredEscape) {
            var regEx = toNewline;
            if (structuredEscape)
              regEx = new RegExp(regEx.source + "|" + structuredEscape);
            return aValue.replace(regEx, function(str) {
              switch (str) {
                case "\\":
                  return "\\\\";
                case ";":
                  return "\\;";
                case ",":
                  return "\\,";
                case "\n":
                  return "\\n";
                default:
                  return str;
              }
            });
          }
        };
        return result;
      }
      var DEFAULT_TYPE_TEXT = { defaultType: "text" };
      var DEFAULT_TYPE_TEXT_MULTI = { defaultType: "text", multiValue: "," };
      var DEFAULT_TYPE_TEXT_STRUCTURED = { defaultType: "text", structuredValue: ";" };
      var DEFAULT_TYPE_INTEGER = { defaultType: "integer" };
      var DEFAULT_TYPE_DATETIME_DATE = { defaultType: "date-time", allowedTypes: ["date-time", "date"] };
      var DEFAULT_TYPE_DATETIME = { defaultType: "date-time" };
      var DEFAULT_TYPE_URI = { defaultType: "uri" };
      var DEFAULT_TYPE_UTCOFFSET = { defaultType: "utc-offset" };
      var DEFAULT_TYPE_RECUR = { defaultType: "recur" };
      var DEFAULT_TYPE_DATE_ANDOR_TIME = { defaultType: "date-and-or-time", allowedTypes: ["date-time", "date", "text"] };
      function replaceNewlineReplace(string) {
        switch (string) {
          case "\\\\":
            return "\\";
          case "\\;":
            return ";";
          case "\\,":
            return ",";
          case "\\n":
          case "\\N":
            return "\n";
          default:
            return string;
        }
      }
      function replaceNewline(value, newline, structuredEscape) {
        if (value.indexOf("\\") === -1) {
          return value;
        }
        if (structuredEscape)
          newline = new RegExp(newline.source + "|\\\\" + structuredEscape);
        return value.replace(newline, replaceNewlineReplace);
      }
      var commonProperties = {
        "categories": DEFAULT_TYPE_TEXT_MULTI,
        "url": DEFAULT_TYPE_URI,
        "version": DEFAULT_TYPE_TEXT,
        "uid": DEFAULT_TYPE_TEXT
      };
      var commonValues = {
        "boolean": {
          values: ["TRUE", "FALSE"],
          fromICAL: function(aValue) {
            switch (aValue) {
              case "TRUE":
                return true;
              case "FALSE":
                return false;
              default:
                return false;
            }
          },
          toICAL: function(aValue) {
            if (aValue) {
              return "TRUE";
            }
            return "FALSE";
          }
        },
        float: {
          matches: /^[+-]?\d+\.\d+$/,
          fromICAL: function(aValue) {
            var parsed = parseFloat(aValue);
            if (ICAL2.helpers.isStrictlyNaN(parsed)) {
              return 0;
            }
            return parsed;
          },
          toICAL: function(aValue) {
            return String(aValue);
          }
        },
        integer: {
          fromICAL: function(aValue) {
            var parsed = parseInt(aValue);
            if (ICAL2.helpers.isStrictlyNaN(parsed)) {
              return 0;
            }
            return parsed;
          },
          toICAL: function(aValue) {
            return String(aValue);
          }
        },
        "utc-offset": {
          toICAL: function(aValue) {
            if (aValue.length < 7) {
              return aValue.substr(0, 3) + aValue.substr(4, 2);
            } else {
              return aValue.substr(0, 3) + aValue.substr(4, 2) + aValue.substr(7, 2);
            }
          },
          fromICAL: function(aValue) {
            if (aValue.length < 6) {
              return aValue.substr(0, 3) + ":" + aValue.substr(3, 2);
            } else {
              return aValue.substr(0, 3) + ":" + aValue.substr(3, 2) + ":" + aValue.substr(5, 2);
            }
          },
          decorate: function(aValue) {
            return ICAL2.UtcOffset.fromString(aValue);
          },
          undecorate: function(aValue) {
            return aValue.toString();
          }
        }
      };
      var icalParams = {
        // Although the syntax is DQUOTE uri DQUOTE, I don't think we should
        // enfoce anything aside from it being a valid content line.
        //
        // At least some params require - if multi values are used - DQUOTEs
        // for each of its values - e.g. delegated-from="uri1","uri2"
        // To indicate this, I introduced the new k/v pair
        // multiValueSeparateDQuote: true
        //
        // "ALTREP": { ... },
        // CN just wants a param-value
        // "CN": { ... }
        "cutype": {
          values: ["INDIVIDUAL", "GROUP", "RESOURCE", "ROOM", "UNKNOWN"],
          allowXName: true,
          allowIanaToken: true
        },
        "delegated-from": {
          valueType: "cal-address",
          multiValue: ",",
          multiValueSeparateDQuote: true
        },
        "delegated-to": {
          valueType: "cal-address",
          multiValue: ",",
          multiValueSeparateDQuote: true
        },
        // "DIR": { ... }, // See ALTREP
        "encoding": {
          values: ["8BIT", "BASE64"]
        },
        // "FMTTYPE": { ... }, // See ALTREP
        "fbtype": {
          values: ["FREE", "BUSY", "BUSY-UNAVAILABLE", "BUSY-TENTATIVE"],
          allowXName: true,
          allowIanaToken: true
        },
        // "LANGUAGE": { ... }, // See ALTREP
        "member": {
          valueType: "cal-address",
          multiValue: ",",
          multiValueSeparateDQuote: true
        },
        "partstat": {
          // TODO These values are actually different per-component
          values: [
            "NEEDS-ACTION",
            "ACCEPTED",
            "DECLINED",
            "TENTATIVE",
            "DELEGATED",
            "COMPLETED",
            "IN-PROCESS"
          ],
          allowXName: true,
          allowIanaToken: true
        },
        "range": {
          values: ["THISANDFUTURE"]
        },
        "related": {
          values: ["START", "END"]
        },
        "reltype": {
          values: ["PARENT", "CHILD", "SIBLING"],
          allowXName: true,
          allowIanaToken: true
        },
        "role": {
          values: [
            "REQ-PARTICIPANT",
            "CHAIR",
            "OPT-PARTICIPANT",
            "NON-PARTICIPANT"
          ],
          allowXName: true,
          allowIanaToken: true
        },
        "rsvp": {
          values: ["TRUE", "FALSE"]
        },
        "sent-by": {
          valueType: "cal-address"
        },
        "tzid": {
          matches: /^\//
        },
        "value": {
          // since the value here is a 'type' lowercase is used.
          values: [
            "binary",
            "boolean",
            "cal-address",
            "date",
            "date-time",
            "duration",
            "float",
            "integer",
            "period",
            "recur",
            "text",
            "time",
            "uri",
            "utc-offset"
          ],
          allowXName: true,
          allowIanaToken: true
        }
      };
      var icalValues = ICAL2.helpers.extend(commonValues, {
        text: createTextType(FROM_ICAL_NEWLINE, TO_ICAL_NEWLINE),
        uri: {
          // TODO
          /* ... */
        },
        "binary": {
          decorate: function(aString) {
            return ICAL2.Binary.fromString(aString);
          },
          undecorate: function(aBinary) {
            return aBinary.toString();
          }
        },
        "cal-address": {
          // needs to be an uri
        },
        "date": {
          decorate: function(aValue, aProp) {
            if (design.strict) {
              return ICAL2.Time.fromDateString(aValue, aProp);
            } else {
              return ICAL2.Time.fromString(aValue, aProp);
            }
          },
          /**
           * undecorates a time object.
           */
          undecorate: function(aValue) {
            return aValue.toString();
          },
          fromICAL: function(aValue) {
            if (!design.strict && aValue.length >= 15) {
              return icalValues["date-time"].fromICAL(aValue);
            } else {
              return aValue.substr(0, 4) + "-" + aValue.substr(4, 2) + "-" + aValue.substr(6, 2);
            }
          },
          toICAL: function(aValue) {
            var len = aValue.length;
            if (len == 10) {
              return aValue.substr(0, 4) + aValue.substr(5, 2) + aValue.substr(8, 2);
            } else if (len >= 19) {
              return icalValues["date-time"].toICAL(aValue);
            } else {
              return aValue;
            }
          }
        },
        "date-time": {
          fromICAL: function(aValue) {
            if (!design.strict && aValue.length == 8) {
              return icalValues.date.fromICAL(aValue);
            } else {
              var result = aValue.substr(0, 4) + "-" + aValue.substr(4, 2) + "-" + aValue.substr(6, 2) + "T" + aValue.substr(9, 2) + ":" + aValue.substr(11, 2) + ":" + aValue.substr(13, 2);
              if (aValue[15] && aValue[15] === "Z") {
                result += "Z";
              }
              return result;
            }
          },
          toICAL: function(aValue) {
            var len = aValue.length;
            if (len == 10 && !design.strict) {
              return icalValues.date.toICAL(aValue);
            } else if (len >= 19) {
              var result = aValue.substr(0, 4) + aValue.substr(5, 2) + // grab the (DDTHH) segment
              aValue.substr(8, 5) + // MM
              aValue.substr(14, 2) + // SS
              aValue.substr(17, 2);
              if (aValue[19] && aValue[19] === "Z") {
                result += "Z";
              }
              return result;
            } else {
              return aValue;
            }
          },
          decorate: function(aValue, aProp) {
            if (design.strict) {
              return ICAL2.Time.fromDateTimeString(aValue, aProp);
            } else {
              return ICAL2.Time.fromString(aValue, aProp);
            }
          },
          undecorate: function(aValue) {
            return aValue.toString();
          }
        },
        duration: {
          decorate: function(aValue) {
            return ICAL2.Duration.fromString(aValue);
          },
          undecorate: function(aValue) {
            return aValue.toString();
          }
        },
        period: {
          fromICAL: function(string) {
            var parts = string.split("/");
            parts[0] = icalValues["date-time"].fromICAL(parts[0]);
            if (!ICAL2.Duration.isValueString(parts[1])) {
              parts[1] = icalValues["date-time"].fromICAL(parts[1]);
            }
            return parts;
          },
          toICAL: function(parts) {
            if (!design.strict && parts[0].length == 10) {
              parts[0] = icalValues.date.toICAL(parts[0]);
            } else {
              parts[0] = icalValues["date-time"].toICAL(parts[0]);
            }
            if (!ICAL2.Duration.isValueString(parts[1])) {
              if (!design.strict && parts[1].length == 10) {
                parts[1] = icalValues.date.toICAL(parts[1]);
              } else {
                parts[1] = icalValues["date-time"].toICAL(parts[1]);
              }
            }
            return parts.join("/");
          },
          decorate: function(aValue, aProp) {
            return ICAL2.Period.fromJSON(aValue, aProp, !design.strict);
          },
          undecorate: function(aValue) {
            return aValue.toJSON();
          }
        },
        recur: {
          fromICAL: function(string) {
            return ICAL2.Recur._stringToData(string, true);
          },
          toICAL: function(data) {
            var str = "";
            for (var k3 in data) {
              if (!Object.prototype.hasOwnProperty.call(data, k3)) {
                continue;
              }
              var val = data[k3];
              if (k3 == "until") {
                if (val.length > 10) {
                  val = icalValues["date-time"].toICAL(val);
                } else {
                  val = icalValues.date.toICAL(val);
                }
              } else if (k3 == "wkst") {
                if (typeof val === "number") {
                  val = ICAL2.Recur.numericDayToIcalDay(val);
                }
              } else if (Array.isArray(val)) {
                val = val.join(",");
              }
              str += k3.toUpperCase() + "=" + val + ";";
            }
            return str.substr(0, str.length - 1);
          },
          decorate: function decorate(aValue) {
            return ICAL2.Recur.fromData(aValue);
          },
          undecorate: function(aRecur) {
            return aRecur.toJSON();
          }
        },
        time: {
          fromICAL: function(aValue) {
            if (aValue.length < 6) {
              return aValue;
            }
            var result = aValue.substr(0, 2) + ":" + aValue.substr(2, 2) + ":" + aValue.substr(4, 2);
            if (aValue[6] === "Z") {
              result += "Z";
            }
            return result;
          },
          toICAL: function(aValue) {
            if (aValue.length < 8) {
              return aValue;
            }
            var result = aValue.substr(0, 2) + aValue.substr(3, 2) + aValue.substr(6, 2);
            if (aValue[8] === "Z") {
              result += "Z";
            }
            return result;
          }
        }
      });
      var icalProperties = ICAL2.helpers.extend(commonProperties, {
        "action": DEFAULT_TYPE_TEXT,
        "attach": { defaultType: "uri" },
        "attendee": { defaultType: "cal-address" },
        "calscale": DEFAULT_TYPE_TEXT,
        "class": DEFAULT_TYPE_TEXT,
        "comment": DEFAULT_TYPE_TEXT,
        "completed": DEFAULT_TYPE_DATETIME,
        "contact": DEFAULT_TYPE_TEXT,
        "created": DEFAULT_TYPE_DATETIME,
        "description": DEFAULT_TYPE_TEXT,
        "dtend": DEFAULT_TYPE_DATETIME_DATE,
        "dtstamp": DEFAULT_TYPE_DATETIME,
        "dtstart": DEFAULT_TYPE_DATETIME_DATE,
        "due": DEFAULT_TYPE_DATETIME_DATE,
        "duration": { defaultType: "duration" },
        "exdate": {
          defaultType: "date-time",
          allowedTypes: ["date-time", "date"],
          multiValue: ","
        },
        "exrule": DEFAULT_TYPE_RECUR,
        "freebusy": { defaultType: "period", multiValue: "," },
        "geo": { defaultType: "float", structuredValue: ";" },
        "last-modified": DEFAULT_TYPE_DATETIME,
        "location": DEFAULT_TYPE_TEXT,
        "method": DEFAULT_TYPE_TEXT,
        "organizer": { defaultType: "cal-address" },
        "percent-complete": DEFAULT_TYPE_INTEGER,
        "priority": DEFAULT_TYPE_INTEGER,
        "prodid": DEFAULT_TYPE_TEXT,
        "related-to": DEFAULT_TYPE_TEXT,
        "repeat": DEFAULT_TYPE_INTEGER,
        "rdate": {
          defaultType: "date-time",
          allowedTypes: ["date-time", "date", "period"],
          multiValue: ",",
          detectType: function(string) {
            if (string.indexOf("/") !== -1) {
              return "period";
            }
            return string.indexOf("T") === -1 ? "date" : "date-time";
          }
        },
        "recurrence-id": DEFAULT_TYPE_DATETIME_DATE,
        "resources": DEFAULT_TYPE_TEXT_MULTI,
        "request-status": DEFAULT_TYPE_TEXT_STRUCTURED,
        "rrule": DEFAULT_TYPE_RECUR,
        "sequence": DEFAULT_TYPE_INTEGER,
        "status": DEFAULT_TYPE_TEXT,
        "summary": DEFAULT_TYPE_TEXT,
        "transp": DEFAULT_TYPE_TEXT,
        "trigger": { defaultType: "duration", allowedTypes: ["duration", "date-time"] },
        "tzoffsetfrom": DEFAULT_TYPE_UTCOFFSET,
        "tzoffsetto": DEFAULT_TYPE_UTCOFFSET,
        "tzurl": DEFAULT_TYPE_URI,
        "tzid": DEFAULT_TYPE_TEXT,
        "tzname": DEFAULT_TYPE_TEXT
      });
      var vcardValues = ICAL2.helpers.extend(commonValues, {
        text: createTextType(FROM_VCARD_NEWLINE, TO_VCARD_NEWLINE),
        uri: createTextType(FROM_VCARD_NEWLINE, TO_VCARD_NEWLINE),
        date: {
          decorate: function(aValue) {
            return ICAL2.VCardTime.fromDateAndOrTimeString(aValue, "date");
          },
          undecorate: function(aValue) {
            return aValue.toString();
          },
          fromICAL: function(aValue) {
            if (aValue.length == 8) {
              return icalValues.date.fromICAL(aValue);
            } else if (aValue[0] == "-" && aValue.length == 6) {
              return aValue.substr(0, 4) + "-" + aValue.substr(4);
            } else {
              return aValue;
            }
          },
          toICAL: function(aValue) {
            if (aValue.length == 10) {
              return icalValues.date.toICAL(aValue);
            } else if (aValue[0] == "-" && aValue.length == 7) {
              return aValue.substr(0, 4) + aValue.substr(5);
            } else {
              return aValue;
            }
          }
        },
        time: {
          decorate: function(aValue) {
            return ICAL2.VCardTime.fromDateAndOrTimeString("T" + aValue, "time");
          },
          undecorate: function(aValue) {
            return aValue.toString();
          },
          fromICAL: function(aValue) {
            var splitzone = vcardValues.time._splitZone(aValue, true);
            var zone = splitzone[0], value = splitzone[1];
            if (value.length == 6) {
              value = value.substr(0, 2) + ":" + value.substr(2, 2) + ":" + value.substr(4, 2);
            } else if (value.length == 4 && value[0] != "-") {
              value = value.substr(0, 2) + ":" + value.substr(2, 2);
            } else if (value.length == 5) {
              value = value.substr(0, 3) + ":" + value.substr(3, 2);
            }
            if (zone.length == 5 && (zone[0] == "-" || zone[0] == "+")) {
              zone = zone.substr(0, 3) + ":" + zone.substr(3);
            }
            return value + zone;
          },
          toICAL: function(aValue) {
            var splitzone = vcardValues.time._splitZone(aValue);
            var zone = splitzone[0], value = splitzone[1];
            if (value.length == 8) {
              value = value.substr(0, 2) + value.substr(3, 2) + value.substr(6, 2);
            } else if (value.length == 5 && value[0] != "-") {
              value = value.substr(0, 2) + value.substr(3, 2);
            } else if (value.length == 6) {
              value = value.substr(0, 3) + value.substr(4, 2);
            }
            if (zone.length == 6 && (zone[0] == "-" || zone[0] == "+")) {
              zone = zone.substr(0, 3) + zone.substr(4);
            }
            return value + zone;
          },
          _splitZone: function(aValue, isFromIcal) {
            var lastChar = aValue.length - 1;
            var signChar = aValue.length - (isFromIcal ? 5 : 6);
            var sign = aValue[signChar];
            var zone, value;
            if (aValue[lastChar] == "Z") {
              zone = aValue[lastChar];
              value = aValue.substr(0, lastChar);
            } else if (aValue.length > 6 && (sign == "-" || sign == "+")) {
              zone = aValue.substr(signChar);
              value = aValue.substr(0, signChar);
            } else {
              zone = "";
              value = aValue;
            }
            return [zone, value];
          }
        },
        "date-time": {
          decorate: function(aValue) {
            return ICAL2.VCardTime.fromDateAndOrTimeString(aValue, "date-time");
          },
          undecorate: function(aValue) {
            return aValue.toString();
          },
          fromICAL: function(aValue) {
            return vcardValues["date-and-or-time"].fromICAL(aValue);
          },
          toICAL: function(aValue) {
            return vcardValues["date-and-or-time"].toICAL(aValue);
          }
        },
        "date-and-or-time": {
          decorate: function(aValue) {
            return ICAL2.VCardTime.fromDateAndOrTimeString(aValue, "date-and-or-time");
          },
          undecorate: function(aValue) {
            return aValue.toString();
          },
          fromICAL: function(aValue) {
            var parts = aValue.split("T");
            return (parts[0] ? vcardValues.date.fromICAL(parts[0]) : "") + (parts[1] ? "T" + vcardValues.time.fromICAL(parts[1]) : "");
          },
          toICAL: function(aValue) {
            var parts = aValue.split("T");
            return vcardValues.date.toICAL(parts[0]) + (parts[1] ? "T" + vcardValues.time.toICAL(parts[1]) : "");
          }
        },
        timestamp: icalValues["date-time"],
        "language-tag": {
          matches: /^[a-zA-Z0-9-]+$/
          // Could go with a more strict regex here
        }
      });
      var vcardParams = {
        "type": {
          valueType: "text",
          multiValue: ","
        },
        "value": {
          // since the value here is a 'type' lowercase is used.
          values: [
            "text",
            "uri",
            "date",
            "time",
            "date-time",
            "date-and-or-time",
            "timestamp",
            "boolean",
            "integer",
            "float",
            "utc-offset",
            "language-tag"
          ],
          allowXName: true,
          allowIanaToken: true
        }
      };
      var vcardProperties = ICAL2.helpers.extend(commonProperties, {
        "adr": { defaultType: "text", structuredValue: ";", multiValue: "," },
        "anniversary": DEFAULT_TYPE_DATE_ANDOR_TIME,
        "bday": DEFAULT_TYPE_DATE_ANDOR_TIME,
        "caladruri": DEFAULT_TYPE_URI,
        "caluri": DEFAULT_TYPE_URI,
        "clientpidmap": DEFAULT_TYPE_TEXT_STRUCTURED,
        "email": DEFAULT_TYPE_TEXT,
        "fburl": DEFAULT_TYPE_URI,
        "fn": DEFAULT_TYPE_TEXT,
        "gender": DEFAULT_TYPE_TEXT_STRUCTURED,
        "geo": DEFAULT_TYPE_URI,
        "impp": DEFAULT_TYPE_URI,
        "key": DEFAULT_TYPE_URI,
        "kind": DEFAULT_TYPE_TEXT,
        "lang": { defaultType: "language-tag" },
        "logo": DEFAULT_TYPE_URI,
        "member": DEFAULT_TYPE_URI,
        "n": { defaultType: "text", structuredValue: ";", multiValue: "," },
        "nickname": DEFAULT_TYPE_TEXT_MULTI,
        "note": DEFAULT_TYPE_TEXT,
        "org": { defaultType: "text", structuredValue: ";" },
        "photo": DEFAULT_TYPE_URI,
        "related": DEFAULT_TYPE_URI,
        "rev": { defaultType: "timestamp" },
        "role": DEFAULT_TYPE_TEXT,
        "sound": DEFAULT_TYPE_URI,
        "source": DEFAULT_TYPE_URI,
        "tel": { defaultType: "uri", allowedTypes: ["uri", "text"] },
        "title": DEFAULT_TYPE_TEXT,
        "tz": { defaultType: "text", allowedTypes: ["text", "utc-offset", "uri"] },
        "xml": DEFAULT_TYPE_TEXT
      });
      var vcard3Values = ICAL2.helpers.extend(commonValues, {
        binary: icalValues.binary,
        date: vcardValues.date,
        "date-time": vcardValues["date-time"],
        "phone-number": {
          // TODO
          /* ... */
        },
        uri: icalValues.uri,
        text: icalValues.text,
        time: icalValues.time,
        vcard: icalValues.text,
        "utc-offset": {
          toICAL: function(aValue) {
            return aValue.substr(0, 7);
          },
          fromICAL: function(aValue) {
            return aValue.substr(0, 7);
          },
          decorate: function(aValue) {
            return ICAL2.UtcOffset.fromString(aValue);
          },
          undecorate: function(aValue) {
            return aValue.toString();
          }
        }
      });
      var vcard3Params = {
        "type": {
          valueType: "text",
          multiValue: ","
        },
        "value": {
          // since the value here is a 'type' lowercase is used.
          values: [
            "text",
            "uri",
            "date",
            "date-time",
            "phone-number",
            "time",
            "boolean",
            "integer",
            "float",
            "utc-offset",
            "vcard",
            "binary"
          ],
          allowXName: true,
          allowIanaToken: true
        }
      };
      var vcard3Properties = ICAL2.helpers.extend(commonProperties, {
        fn: DEFAULT_TYPE_TEXT,
        n: { defaultType: "text", structuredValue: ";", multiValue: "," },
        nickname: DEFAULT_TYPE_TEXT_MULTI,
        photo: { defaultType: "binary", allowedTypes: ["binary", "uri"] },
        bday: {
          defaultType: "date-time",
          allowedTypes: ["date-time", "date"],
          detectType: function(string) {
            return string.indexOf("T") === -1 ? "date" : "date-time";
          }
        },
        adr: { defaultType: "text", structuredValue: ";", multiValue: "," },
        label: DEFAULT_TYPE_TEXT,
        tel: { defaultType: "phone-number" },
        email: DEFAULT_TYPE_TEXT,
        mailer: DEFAULT_TYPE_TEXT,
        tz: { defaultType: "utc-offset", allowedTypes: ["utc-offset", "text"] },
        geo: { defaultType: "float", structuredValue: ";" },
        title: DEFAULT_TYPE_TEXT,
        role: DEFAULT_TYPE_TEXT,
        logo: { defaultType: "binary", allowedTypes: ["binary", "uri"] },
        agent: { defaultType: "vcard", allowedTypes: ["vcard", "text", "uri"] },
        org: DEFAULT_TYPE_TEXT_STRUCTURED,
        note: DEFAULT_TYPE_TEXT_MULTI,
        prodid: DEFAULT_TYPE_TEXT,
        rev: {
          defaultType: "date-time",
          allowedTypes: ["date-time", "date"],
          detectType: function(string) {
            return string.indexOf("T") === -1 ? "date" : "date-time";
          }
        },
        "sort-string": DEFAULT_TYPE_TEXT,
        sound: { defaultType: "binary", allowedTypes: ["binary", "uri"] },
        class: DEFAULT_TYPE_TEXT,
        key: { defaultType: "binary", allowedTypes: ["binary", "text"] }
      });
      var icalSet = {
        value: icalValues,
        param: icalParams,
        property: icalProperties
      };
      var vcardSet = {
        value: vcardValues,
        param: vcardParams,
        property: vcardProperties
      };
      var vcard3Set = {
        value: vcard3Values,
        param: vcard3Params,
        property: vcard3Properties
      };
      var design = {
        /**
         * A designSet describes value, parameter and property data. It is used by
         * ther parser and stringifier in components and properties to determine they
         * should be represented.
         *
         * @typedef {Object} designSet
         * @memberOf ICAL.design
         * @property {Object} value       Definitions for value types, keys are type names
         * @property {Object} param       Definitions for params, keys are param names
         * @property {Object} property    Defintions for properties, keys are property names
         */
        /**
         * Can be set to false to make the parser more lenient.
         */
        strict: true,
        /**
         * The default set for new properties and components if none is specified.
         * @type {ICAL.design.designSet}
         */
        defaultSet: icalSet,
        /**
         * The default type for unknown properties
         * @type {String}
         */
        defaultType: "unknown",
        /**
         * Holds the design set for known top-level components
         *
         * @type {Object}
         * @property {ICAL.design.designSet} vcard       vCard VCARD
         * @property {ICAL.design.designSet} vevent      iCalendar VEVENT
         * @property {ICAL.design.designSet} vtodo       iCalendar VTODO
         * @property {ICAL.design.designSet} vjournal    iCalendar VJOURNAL
         * @property {ICAL.design.designSet} valarm      iCalendar VALARM
         * @property {ICAL.design.designSet} vtimezone   iCalendar VTIMEZONE
         * @property {ICAL.design.designSet} daylight    iCalendar DAYLIGHT
         * @property {ICAL.design.designSet} standard    iCalendar STANDARD
         *
         * @example
         * var propertyName = 'fn';
         * var componentDesign = ICAL.design.components.vcard;
         * var propertyDetails = componentDesign.property[propertyName];
         * if (propertyDetails.defaultType == 'text') {
         *   // Yep, sure is...
         * }
         */
        components: {
          vcard: vcardSet,
          vcard3: vcard3Set,
          vevent: icalSet,
          vtodo: icalSet,
          vjournal: icalSet,
          valarm: icalSet,
          vtimezone: icalSet,
          daylight: icalSet,
          standard: icalSet
        },
        /**
         * The design set for iCalendar (rfc5545/rfc7265) components.
         * @type {ICAL.design.designSet}
         */
        icalendar: icalSet,
        /**
         * The design set for vCard (rfc6350/rfc7095) components.
         * @type {ICAL.design.designSet}
         */
        vcard: vcardSet,
        /**
         * The design set for vCard (rfc2425/rfc2426/rfc7095) components.
         * @type {ICAL.design.designSet}
         */
        vcard3: vcard3Set,
        /**
         * Gets the design set for the given component name.
         *
         * @param {String} componentName        The name of the component
         * @return {ICAL.design.designSet}      The design set for the component
         */
        getDesignSet: function(componentName) {
          var isInDesign = componentName && componentName in design.components;
          return isInDesign ? design.components[componentName] : design.defaultSet;
        }
      };
      return design;
    }();
    ICAL2.stringify = function() {
      "use strict";
      var LINE_ENDING = "\r\n";
      var DEFAULT_VALUE_TYPE = "unknown";
      var design = ICAL2.design;
      var helpers = ICAL2.helpers;
      function stringify(jCal) {
        if (typeof jCal[0] == "string") {
          jCal = [jCal];
        }
        var i3 = 0;
        var len = jCal.length;
        var result = "";
        for (; i3 < len; i3++) {
          result += stringify.component(jCal[i3]) + LINE_ENDING;
        }
        return result;
      }
      stringify.component = function(component, designSet) {
        var name = component[0].toUpperCase();
        var result = "BEGIN:" + name + LINE_ENDING;
        var props = component[1];
        var propIdx = 0;
        var propLen = props.length;
        var designSetName = component[0];
        if (designSetName === "vcard" && component[1].length > 0 && !(component[1][0][0] === "version" && component[1][0][3] === "4.0")) {
          designSetName = "vcard3";
        }
        designSet = designSet || design.getDesignSet(designSetName);
        for (; propIdx < propLen; propIdx++) {
          result += stringify.property(props[propIdx], designSet) + LINE_ENDING;
        }
        var comps = component[2] || [];
        var compIdx = 0;
        var compLen = comps.length;
        for (; compIdx < compLen; compIdx++) {
          result += stringify.component(comps[compIdx], designSet) + LINE_ENDING;
        }
        result += "END:" + name;
        return result;
      };
      stringify.property = function(property, designSet, noFold) {
        var name = property[0].toUpperCase();
        var jsName = property[0];
        var params = property[1];
        var line = name;
        var paramName;
        for (paramName in params) {
          var value = params[paramName];
          if (params.hasOwnProperty(paramName)) {
            var multiValue = paramName in designSet.param && designSet.param[paramName].multiValue;
            if (multiValue && Array.isArray(value)) {
              if (designSet.param[paramName].multiValueSeparateDQuote) {
                multiValue = '"' + multiValue + '"';
              }
              value = value.map(stringify._rfc6868Unescape);
              value = stringify.multiValue(value, multiValue, "unknown", null, designSet);
            } else {
              value = stringify._rfc6868Unescape(value);
            }
            line += ";" + paramName.toUpperCase();
            line += "=" + stringify.propertyValue(value);
          }
        }
        if (property.length === 3) {
          return line + ":";
        }
        var valueType = property[2];
        if (!designSet) {
          designSet = design.defaultSet;
        }
        var propDetails;
        var multiValue = false;
        var structuredValue = false;
        var isDefault = false;
        if (jsName in designSet.property) {
          propDetails = designSet.property[jsName];
          if ("multiValue" in propDetails) {
            multiValue = propDetails.multiValue;
          }
          if ("structuredValue" in propDetails && Array.isArray(property[3])) {
            structuredValue = propDetails.structuredValue;
          }
          if ("defaultType" in propDetails) {
            if (valueType === propDetails.defaultType) {
              isDefault = true;
            }
          } else {
            if (valueType === DEFAULT_VALUE_TYPE) {
              isDefault = true;
            }
          }
        } else {
          if (valueType === DEFAULT_VALUE_TYPE) {
            isDefault = true;
          }
        }
        if (!isDefault) {
          line += ";VALUE=" + valueType.toUpperCase();
        }
        line += ":";
        if (multiValue && structuredValue) {
          line += stringify.multiValue(
            property[3],
            structuredValue,
            valueType,
            multiValue,
            designSet,
            structuredValue
          );
        } else if (multiValue) {
          line += stringify.multiValue(
            property.slice(3),
            multiValue,
            valueType,
            null,
            designSet,
            false
          );
        } else if (structuredValue) {
          line += stringify.multiValue(
            property[3],
            structuredValue,
            valueType,
            null,
            designSet,
            structuredValue
          );
        } else {
          line += stringify.value(property[3], valueType, designSet, false);
        }
        return noFold ? line : ICAL2.helpers.foldline(line);
      };
      stringify.propertyValue = function(value) {
        if (helpers.unescapedIndexOf(value, ",") === -1 && helpers.unescapedIndexOf(value, ":") === -1 && helpers.unescapedIndexOf(value, ";") === -1) {
          return value;
        }
        return '"' + value + '"';
      };
      stringify.multiValue = function(values, delim, type, innerMulti, designSet, structuredValue) {
        var result = "";
        var len = values.length;
        var i3 = 0;
        for (; i3 < len; i3++) {
          if (innerMulti && Array.isArray(values[i3])) {
            result += stringify.multiValue(values[i3], innerMulti, type, null, designSet, structuredValue);
          } else {
            result += stringify.value(values[i3], type, designSet, structuredValue);
          }
          if (i3 !== len - 1) {
            result += delim;
          }
        }
        return result;
      };
      stringify.value = function(value, type, designSet, structuredValue) {
        if (type in designSet.value && "toICAL" in designSet.value[type]) {
          return designSet.value[type].toICAL(value, structuredValue);
        }
        return value;
      };
      stringify._rfc6868Unescape = function(val) {
        return val.replace(/[\n^"]/g, function(x4) {
          return RFC6868_REPLACE_MAP[x4];
        });
      };
      var RFC6868_REPLACE_MAP = { '"': "^'", "\n": "^n", "^": "^^" };
      return stringify;
    }();
    ICAL2.parse = function() {
      "use strict";
      var CHAR = /[^ \t]/;
      var MULTIVALUE_DELIMITER = ",";
      var VALUE_DELIMITER = ":";
      var PARAM_DELIMITER = ";";
      var PARAM_NAME_DELIMITER = "=";
      var DEFAULT_VALUE_TYPE = "unknown";
      var DEFAULT_PARAM_TYPE = "text";
      var design = ICAL2.design;
      var helpers = ICAL2.helpers;
      function ParserError(message) {
        this.message = message;
        this.name = "ParserError";
        try {
          throw new Error();
        } catch (e3) {
          if (e3.stack) {
            var split2 = e3.stack.split("\n");
            split2.shift();
            this.stack = split2.join("\n");
          }
        }
      }
      ParserError.prototype = Error.prototype;
      function parser(input) {
        var state = {};
        var root = state.component = [];
        state.stack = [root];
        parser._eachLine(input, function(err, line) {
          parser._handleContentLine(line, state);
        });
        if (state.stack.length > 1) {
          throw new ParserError(
            "invalid ical body. component began but did not end"
          );
        }
        state = null;
        return root.length == 1 ? root[0] : root;
      }
      parser.property = function(str, designSet) {
        var state = {
          component: [[], []],
          designSet: designSet || design.defaultSet
        };
        parser._handleContentLine(str, state);
        return state.component[1][0];
      };
      parser.component = function(str) {
        return parser(str);
      };
      parser.ParserError = ParserError;
      parser._handleContentLine = function(line, state) {
        var valuePos = line.indexOf(VALUE_DELIMITER);
        var paramPos = line.indexOf(PARAM_DELIMITER);
        var lastParamIndex;
        var lastValuePos;
        var name;
        var value;
        var params = {};
        if (paramPos !== -1 && valuePos !== -1) {
          if (paramPos > valuePos) {
            paramPos = -1;
          }
        }
        var parsedParams;
        if (paramPos !== -1) {
          name = line.substring(0, paramPos).toLowerCase();
          parsedParams = parser._parseParameters(line.substring(paramPos), 0, state.designSet);
          if (parsedParams[2] == -1) {
            throw new ParserError("Invalid parameters in '" + line + "'");
          }
          params = parsedParams[0];
          lastParamIndex = parsedParams[1].length + parsedParams[2] + paramPos;
          if ((lastValuePos = line.substring(lastParamIndex).indexOf(VALUE_DELIMITER)) !== -1) {
            value = line.substring(lastParamIndex + lastValuePos + 1);
          } else {
            throw new ParserError("Missing parameter value in '" + line + "'");
          }
        } else if (valuePos !== -1) {
          name = line.substring(0, valuePos).toLowerCase();
          value = line.substring(valuePos + 1);
          if (name === "begin") {
            var newComponent = [value.toLowerCase(), [], []];
            if (state.stack.length === 1) {
              state.component.push(newComponent);
            } else {
              state.component[2].push(newComponent);
            }
            state.stack.push(state.component);
            state.component = newComponent;
            if (!state.designSet) {
              state.designSet = design.getDesignSet(state.component[0]);
            }
            return;
          } else if (name === "end") {
            state.component = state.stack.pop();
            return;
          }
        } else {
          throw new ParserError(
            'invalid line (no token ";" or ":") "' + line + '"'
          );
        }
        var valueType;
        var multiValue = false;
        var structuredValue = false;
        var propertyDetails;
        if (name in state.designSet.property) {
          propertyDetails = state.designSet.property[name];
          if ("multiValue" in propertyDetails) {
            multiValue = propertyDetails.multiValue;
          }
          if ("structuredValue" in propertyDetails) {
            structuredValue = propertyDetails.structuredValue;
          }
          if (value && "detectType" in propertyDetails) {
            valueType = propertyDetails.detectType(value);
          }
        }
        if (!valueType) {
          if (!("value" in params)) {
            if (propertyDetails) {
              valueType = propertyDetails.defaultType;
            } else {
              valueType = DEFAULT_VALUE_TYPE;
            }
          } else {
            valueType = params.value.toLowerCase();
          }
        }
        delete params.value;
        var result;
        if (multiValue && structuredValue) {
          value = parser._parseMultiValue(value, structuredValue, valueType, [], multiValue, state.designSet, structuredValue);
          result = [name, params, valueType, value];
        } else if (multiValue) {
          result = [name, params, valueType];
          parser._parseMultiValue(value, multiValue, valueType, result, null, state.designSet, false);
        } else if (structuredValue) {
          value = parser._parseMultiValue(value, structuredValue, valueType, [], null, state.designSet, structuredValue);
          result = [name, params, valueType, value];
        } else {
          value = parser._parseValue(value, valueType, state.designSet, false);
          result = [name, params, valueType, value];
        }
        if (state.component[0] === "vcard" && state.component[1].length === 0 && !(name === "version" && value === "4.0")) {
          state.designSet = design.getDesignSet("vcard3");
        }
        state.component[1].push(result);
      };
      parser._parseValue = function(value, type, designSet, structuredValue) {
        if (type in designSet.value && "fromICAL" in designSet.value[type]) {
          return designSet.value[type].fromICAL(value, structuredValue);
        }
        return value;
      };
      parser._parseParameters = function(line, start, designSet) {
        var lastParam = start;
        var pos = 0;
        var delim = PARAM_NAME_DELIMITER;
        var result = {};
        var name, lcname;
        var value, valuePos = -1;
        var type, multiValue, mvdelim;
        while (pos !== false && (pos = helpers.unescapedIndexOf(line, delim, pos + 1)) !== -1) {
          name = line.substr(lastParam + 1, pos - lastParam - 1);
          if (name.length == 0) {
            throw new ParserError("Empty parameter name in '" + line + "'");
          }
          lcname = name.toLowerCase();
          mvdelim = false;
          multiValue = false;
          if (lcname in designSet.param && designSet.param[lcname].valueType) {
            type = designSet.param[lcname].valueType;
          } else {
            type = DEFAULT_PARAM_TYPE;
          }
          if (lcname in designSet.param) {
            multiValue = designSet.param[lcname].multiValue;
            if (designSet.param[lcname].multiValueSeparateDQuote) {
              mvdelim = parser._rfc6868Escape('"' + multiValue + '"');
            }
          }
          var nextChar = line[pos + 1];
          if (nextChar === '"') {
            valuePos = pos + 2;
            pos = helpers.unescapedIndexOf(line, '"', valuePos);
            if (multiValue && pos != -1) {
              var extendedValue = true;
              while (extendedValue) {
                if (line[pos + 1] == multiValue && line[pos + 2] == '"') {
                  pos = helpers.unescapedIndexOf(line, '"', pos + 3);
                } else {
                  extendedValue = false;
                }
              }
            }
            if (pos === -1) {
              throw new ParserError(
                'invalid line (no matching double quote) "' + line + '"'
              );
            }
            value = line.substr(valuePos, pos - valuePos);
            lastParam = helpers.unescapedIndexOf(line, PARAM_DELIMITER, pos);
            if (lastParam === -1) {
              pos = false;
            }
          } else {
            valuePos = pos + 1;
            var nextPos = helpers.unescapedIndexOf(line, PARAM_DELIMITER, valuePos);
            var propValuePos = helpers.unescapedIndexOf(line, VALUE_DELIMITER, valuePos);
            if (propValuePos !== -1 && nextPos > propValuePos) {
              nextPos = propValuePos;
              pos = false;
            } else if (nextPos === -1) {
              if (propValuePos === -1) {
                nextPos = line.length;
              } else {
                nextPos = propValuePos;
              }
              pos = false;
            } else {
              lastParam = nextPos;
              pos = nextPos;
            }
            value = line.substr(valuePos, nextPos - valuePos);
          }
          value = parser._rfc6868Escape(value);
          if (multiValue) {
            var delimiter = mvdelim || multiValue;
            value = parser._parseMultiValue(value, delimiter, type, [], null, designSet);
          } else {
            value = parser._parseValue(value, type, designSet);
          }
          if (multiValue && lcname in result) {
            if (Array.isArray(result[lcname])) {
              result[lcname].push(value);
            } else {
              result[lcname] = [
                result[lcname],
                value
              ];
            }
          } else {
            result[lcname] = value;
          }
        }
        return [result, value, valuePos];
      };
      parser._rfc6868Escape = function(val) {
        return val.replace(/\^['n^]/g, function(x4) {
          return RFC6868_REPLACE_MAP[x4];
        });
      };
      var RFC6868_REPLACE_MAP = { "^'": '"', "^n": "\n", "^^": "^" };
      parser._parseMultiValue = function(buffer, delim, type, result, innerMulti, designSet, structuredValue) {
        var pos = 0;
        var lastPos = 0;
        var value;
        if (delim.length === 0) {
          return buffer;
        }
        while ((pos = helpers.unescapedIndexOf(buffer, delim, lastPos)) !== -1) {
          value = buffer.substr(lastPos, pos - lastPos);
          if (innerMulti) {
            value = parser._parseMultiValue(value, innerMulti, type, [], null, designSet, structuredValue);
          } else {
            value = parser._parseValue(value, type, designSet, structuredValue);
          }
          result.push(value);
          lastPos = pos + delim.length;
        }
        value = buffer.substr(lastPos);
        if (innerMulti) {
          value = parser._parseMultiValue(value, innerMulti, type, [], null, designSet, structuredValue);
        } else {
          value = parser._parseValue(value, type, designSet, structuredValue);
        }
        result.push(value);
        return result.length == 1 ? result[0] : result;
      };
      parser._eachLine = function(buffer, callback) {
        var len = buffer.length;
        var lastPos = buffer.search(CHAR);
        var pos = lastPos;
        var line;
        var firstChar;
        var newlineOffset;
        do {
          pos = buffer.indexOf("\n", lastPos) + 1;
          if (pos > 1 && buffer[pos - 2] === "\r") {
            newlineOffset = 2;
          } else {
            newlineOffset = 1;
          }
          if (pos === 0) {
            pos = len;
            newlineOffset = 0;
          }
          firstChar = buffer[lastPos];
          if (firstChar === " " || firstChar === "	") {
            line += buffer.substr(
              lastPos + 1,
              pos - lastPos - (newlineOffset + 1)
            );
          } else {
            if (line)
              callback(null, line);
            line = buffer.substr(
              lastPos,
              pos - lastPos - newlineOffset
            );
          }
          lastPos = pos;
        } while (pos !== len);
        line = line.trim();
        if (line.length)
          callback(null, line);
      };
      return parser;
    }();
    ICAL2.Component = function() {
      "use strict";
      var PROPERTY_INDEX = 1;
      var COMPONENT_INDEX = 2;
      var NAME_INDEX = 0;
      function Component3(jCal, parent) {
        if (typeof jCal === "string") {
          jCal = [jCal, [], []];
        }
        this.jCal = jCal;
        this.parent = parent || null;
      }
      Component3.prototype = {
        /**
         * Hydrated properties are inserted into the _properties array at the same
         * position as in the jCal array, so it is possible that the array contains
         * undefined values for unhydrdated properties. To avoid iterating the
         * array when checking if all properties have been hydrated, we save the
         * count here.
         *
         * @type {Number}
         * @private
         */
        _hydratedPropertyCount: 0,
        /**
         * The same count as for _hydratedPropertyCount, but for subcomponents
         *
         * @type {Number}
         * @private
         */
        _hydratedComponentCount: 0,
        /**
         * The name of this component
         * @readonly
         */
        get name() {
          return this.jCal[NAME_INDEX];
        },
        /**
         * The design set for this component, e.g. icalendar vs vcard
         *
         * @type {ICAL.design.designSet}
         * @private
         */
        get _designSet() {
          var parentDesign = this.parent && this.parent._designSet;
          return parentDesign || ICAL2.design.getDesignSet(this.name);
        },
        _hydrateComponent: function(index8) {
          if (!this._components) {
            this._components = [];
            this._hydratedComponentCount = 0;
          }
          if (this._components[index8]) {
            return this._components[index8];
          }
          var comp = new Component3(
            this.jCal[COMPONENT_INDEX][index8],
            this
          );
          this._hydratedComponentCount++;
          return this._components[index8] = comp;
        },
        _hydrateProperty: function(index8) {
          if (!this._properties) {
            this._properties = [];
            this._hydratedPropertyCount = 0;
          }
          if (this._properties[index8]) {
            return this._properties[index8];
          }
          var prop = new ICAL2.Property(
            this.jCal[PROPERTY_INDEX][index8],
            this
          );
          this._hydratedPropertyCount++;
          return this._properties[index8] = prop;
        },
        /**
         * Finds first sub component, optionally filtered by name.
         *
         * @param {String=} name        Optional name to filter by
         * @return {?ICAL.Component}     The found subcomponent
         */
        getFirstSubcomponent: function(name) {
          if (name) {
            var i3 = 0;
            var comps = this.jCal[COMPONENT_INDEX];
            var len = comps.length;
            for (; i3 < len; i3++) {
              if (comps[i3][NAME_INDEX] === name) {
                var result = this._hydrateComponent(i3);
                return result;
              }
            }
          } else {
            if (this.jCal[COMPONENT_INDEX].length) {
              return this._hydrateComponent(0);
            }
          }
          return null;
        },
        /**
         * Finds all sub components, optionally filtering by name.
         *
         * @param {String=} name            Optional name to filter by
         * @return {ICAL.Component[]}       The found sub components
         */
        getAllSubcomponents: function(name) {
          var jCalLen = this.jCal[COMPONENT_INDEX].length;
          var i3 = 0;
          if (name) {
            var comps = this.jCal[COMPONENT_INDEX];
            var result = [];
            for (; i3 < jCalLen; i3++) {
              if (name === comps[i3][NAME_INDEX]) {
                result.push(
                  this._hydrateComponent(i3)
                );
              }
            }
            return result;
          } else {
            if (!this._components || this._hydratedComponentCount !== jCalLen) {
              for (; i3 < jCalLen; i3++) {
                this._hydrateComponent(i3);
              }
            }
            return this._components || [];
          }
        },
        /**
         * Returns true when a named property exists.
         *
         * @param {String} name     The property name
         * @return {Boolean}        True, when property is found
         */
        hasProperty: function(name) {
          var props = this.jCal[PROPERTY_INDEX];
          var len = props.length;
          var i3 = 0;
          for (; i3 < len; i3++) {
            if (props[i3][NAME_INDEX] === name) {
              return true;
            }
          }
          return false;
        },
        /**
         * Finds the first property, optionally with the given name.
         *
         * @param {String=} name        Lowercase property name
         * @return {?ICAL.Property}     The found property
         */
        getFirstProperty: function(name) {
          if (name) {
            var i3 = 0;
            var props = this.jCal[PROPERTY_INDEX];
            var len = props.length;
            for (; i3 < len; i3++) {
              if (props[i3][NAME_INDEX] === name) {
                var result = this._hydrateProperty(i3);
                return result;
              }
            }
          } else {
            if (this.jCal[PROPERTY_INDEX].length) {
              return this._hydrateProperty(0);
            }
          }
          return null;
        },
        /**
         * Returns first property's value, if available.
         *
         * @param {String=} name    Lowercase property name
         * @return {?String}        The found property value.
         */
        getFirstPropertyValue: function(name) {
          var prop = this.getFirstProperty(name);
          if (prop) {
            return prop.getFirstValue();
          }
          return null;
        },
        /**
         * Get all properties in the component, optionally filtered by name.
         *
         * @param {String=} name        Lowercase property name
         * @return {ICAL.Property[]}    List of properties
         */
        getAllProperties: function(name) {
          var jCalLen = this.jCal[PROPERTY_INDEX].length;
          var i3 = 0;
          if (name) {
            var props = this.jCal[PROPERTY_INDEX];
            var result = [];
            for (; i3 < jCalLen; i3++) {
              if (name === props[i3][NAME_INDEX]) {
                result.push(
                  this._hydrateProperty(i3)
                );
              }
            }
            return result;
          } else {
            if (!this._properties || this._hydratedPropertyCount !== jCalLen) {
              for (; i3 < jCalLen; i3++) {
                this._hydrateProperty(i3);
              }
            }
            return this._properties || [];
          }
        },
        _removeObjectByIndex: function(jCalIndex, cache, index8) {
          cache = cache || [];
          if (cache[index8]) {
            var obj = cache[index8];
            if ("parent" in obj) {
              obj.parent = null;
            }
          }
          cache.splice(index8, 1);
          this.jCal[jCalIndex].splice(index8, 1);
        },
        _removeObject: function(jCalIndex, cache, nameOrObject) {
          var i3 = 0;
          var objects = this.jCal[jCalIndex];
          var len = objects.length;
          var cached = this[cache];
          if (typeof nameOrObject === "string") {
            for (; i3 < len; i3++) {
              if (objects[i3][NAME_INDEX] === nameOrObject) {
                this._removeObjectByIndex(jCalIndex, cached, i3);
                return true;
              }
            }
          } else if (cached) {
            for (; i3 < len; i3++) {
              if (cached[i3] && cached[i3] === nameOrObject) {
                this._removeObjectByIndex(jCalIndex, cached, i3);
                return true;
              }
            }
          }
          return false;
        },
        _removeAllObjects: function(jCalIndex, cache, name) {
          var cached = this[cache];
          var objects = this.jCal[jCalIndex];
          var i3 = objects.length - 1;
          for (; i3 >= 0; i3--) {
            if (!name || objects[i3][NAME_INDEX] === name) {
              this._removeObjectByIndex(jCalIndex, cached, i3);
            }
          }
        },
        /**
         * Adds a single sub component.
         *
         * @param {ICAL.Component} component        The component to add
         * @return {ICAL.Component}                 The passed in component
         */
        addSubcomponent: function(component) {
          if (!this._components) {
            this._components = [];
            this._hydratedComponentCount = 0;
          }
          if (component.parent) {
            component.parent.removeSubcomponent(component);
          }
          var idx = this.jCal[COMPONENT_INDEX].push(component.jCal);
          this._components[idx - 1] = component;
          this._hydratedComponentCount++;
          component.parent = this;
          return component;
        },
        /**
         * Removes a single component by name or the instance of a specific
         * component.
         *
         * @param {ICAL.Component|String} nameOrComp    Name of component, or component
         * @return {Boolean}                            True when comp is removed
         */
        removeSubcomponent: function(nameOrComp) {
          var removed = this._removeObject(COMPONENT_INDEX, "_components", nameOrComp);
          if (removed) {
            this._hydratedComponentCount--;
          }
          return removed;
        },
        /**
         * Removes all components or (if given) all components by a particular
         * name.
         *
         * @param {String=} name            Lowercase component name
         */
        removeAllSubcomponents: function(name) {
          var removed = this._removeAllObjects(COMPONENT_INDEX, "_components", name);
          this._hydratedComponentCount = 0;
          return removed;
        },
        /**
         * Adds an {@link ICAL.Property} to the component.
         *
         * @param {ICAL.Property} property      The property to add
         * @return {ICAL.Property}              The passed in property
         */
        addProperty: function(property) {
          if (!(property instanceof ICAL2.Property)) {
            throw new TypeError("must instance of ICAL.Property");
          }
          if (!this._properties) {
            this._properties = [];
            this._hydratedPropertyCount = 0;
          }
          if (property.parent) {
            property.parent.removeProperty(property);
          }
          var idx = this.jCal[PROPERTY_INDEX].push(property.jCal);
          this._properties[idx - 1] = property;
          this._hydratedPropertyCount++;
          property.parent = this;
          return property;
        },
        /**
         * Helper method to add a property with a value to the component.
         *
         * @param {String}               name         Property name to add
         * @param {String|Number|Object} value        Property value
         * @return {ICAL.Property}                    The created property
         */
        addPropertyWithValue: function(name, value) {
          var prop = new ICAL2.Property(name);
          prop.setValue(value);
          this.addProperty(prop);
          return prop;
        },
        /**
         * Helper method that will update or create a property of the given name
         * and sets its value. If multiple properties with the given name exist,
         * only the first is updated.
         *
         * @param {String}               name         Property name to update
         * @param {String|Number|Object} value        Property value
         * @return {ICAL.Property}                    The created property
         */
        updatePropertyWithValue: function(name, value) {
          var prop = this.getFirstProperty(name);
          if (prop) {
            prop.setValue(value);
          } else {
            prop = this.addPropertyWithValue(name, value);
          }
          return prop;
        },
        /**
         * Removes a single property by name or the instance of the specific
         * property.
         *
         * @param {String|ICAL.Property} nameOrProp     Property name or instance to remove
         * @return {Boolean}                            True, when deleted
         */
        removeProperty: function(nameOrProp) {
          var removed = this._removeObject(PROPERTY_INDEX, "_properties", nameOrProp);
          if (removed) {
            this._hydratedPropertyCount--;
          }
          return removed;
        },
        /**
         * Removes all properties associated with this component, optionally
         * filtered by name.
         *
         * @param {String=} name        Lowercase property name
         * @return {Boolean}            True, when deleted
         */
        removeAllProperties: function(name) {
          var removed = this._removeAllObjects(PROPERTY_INDEX, "_properties", name);
          this._hydratedPropertyCount = 0;
          return removed;
        },
        /**
         * Returns the Object representation of this component. The returned object
         * is a live jCal object and should be cloned if modified.
         * @return {Object}
         */
        toJSON: function() {
          return this.jCal;
        },
        /**
         * The string representation of this component.
         * @return {String}
         */
        toString: function() {
          return ICAL2.stringify.component(
            this.jCal,
            this._designSet
          );
        }
      };
      Component3.fromString = function(str) {
        return new Component3(ICAL2.parse.component(str));
      };
      return Component3;
    }();
    ICAL2.Property = function() {
      "use strict";
      var NAME_INDEX = 0;
      var PROP_INDEX = 1;
      var TYPE_INDEX = 2;
      var VALUE_INDEX = 3;
      var design = ICAL2.design;
      function Property(jCal, parent) {
        this._parent = parent || null;
        if (typeof jCal === "string") {
          this.jCal = [jCal, {}, design.defaultType];
          this.jCal[TYPE_INDEX] = this.getDefaultType();
        } else {
          this.jCal = jCal;
        }
        this._updateType();
      }
      Property.prototype = {
        /**
         * The value type for this property
         * @readonly
         * @type {String}
         */
        get type() {
          return this.jCal[TYPE_INDEX];
        },
        /**
         * The name of this property, in lowercase.
         * @readonly
         * @type {String}
         */
        get name() {
          return this.jCal[NAME_INDEX];
        },
        /**
         * The parent component for this property.
         * @type {ICAL.Component}
         */
        get parent() {
          return this._parent;
        },
        set parent(p3) {
          var designSetChanged = !this._parent || p3 && p3._designSet != this._parent._designSet;
          this._parent = p3;
          if (this.type == design.defaultType && designSetChanged) {
            this.jCal[TYPE_INDEX] = this.getDefaultType();
            this._updateType();
          }
          return p3;
        },
        /**
         * The design set for this property, e.g. icalendar vs vcard
         *
         * @type {ICAL.design.designSet}
         * @private
         */
        get _designSet() {
          return this.parent ? this.parent._designSet : design.defaultSet;
        },
        /**
         * Updates the type metadata from the current jCal type and design set.
         *
         * @private
         */
        _updateType: function() {
          var designSet = this._designSet;
          if (this.type in designSet.value) {
            var designType = designSet.value[this.type];
            if ("decorate" in designSet.value[this.type]) {
              this.isDecorated = true;
            } else {
              this.isDecorated = false;
            }
            if (this.name in designSet.property) {
              this.isMultiValue = "multiValue" in designSet.property[this.name];
              this.isStructuredValue = "structuredValue" in designSet.property[this.name];
            }
          }
        },
        /**
         * Hydrate a single value. The act of hydrating means turning the raw jCal
         * value into a potentially wrapped object, for example {@link ICAL.Time}.
         *
         * @private
         * @param {Number} index        The index of the value to hydrate
         * @return {Object}             The decorated value.
         */
        _hydrateValue: function(index8) {
          if (this._values && this._values[index8]) {
            return this._values[index8];
          }
          if (this.jCal.length <= VALUE_INDEX + index8) {
            return null;
          }
          if (this.isDecorated) {
            if (!this._values) {
              this._values = [];
            }
            return this._values[index8] = this._decorate(
              this.jCal[VALUE_INDEX + index8]
            );
          } else {
            return this.jCal[VALUE_INDEX + index8];
          }
        },
        /**
         * Decorate a single value, returning its wrapped object. This is used by
         * the hydrate function to actually wrap the value.
         *
         * @private
         * @param {?} value         The value to decorate
         * @return {Object}         The decorated value
         */
        _decorate: function(value) {
          return this._designSet.value[this.type].decorate(value, this);
        },
        /**
         * Undecorate a single value, returning its raw jCal data.
         *
         * @private
         * @param {Object} value         The value to undecorate
         * @return {?}                   The undecorated value
         */
        _undecorate: function(value) {
          return this._designSet.value[this.type].undecorate(value, this);
        },
        /**
         * Sets the value at the given index while also hydrating it. The passed
         * value can either be a decorated or undecorated value.
         *
         * @private
         * @param {?} value             The value to set
         * @param {Number} index        The index to set it at
         */
        _setDecoratedValue: function(value, index8) {
          if (!this._values) {
            this._values = [];
          }
          if (typeof value === "object" && "icaltype" in value) {
            this.jCal[VALUE_INDEX + index8] = this._undecorate(value);
            this._values[index8] = value;
          } else {
            this.jCal[VALUE_INDEX + index8] = value;
            this._values[index8] = this._decorate(value);
          }
        },
        /**
         * Gets a parameter on the property.
         *
         * @param {String}        name   Parameter name (lowercase)
         * @return {Array|String}        Parameter value
         */
        getParameter: function(name) {
          if (name in this.jCal[PROP_INDEX]) {
            return this.jCal[PROP_INDEX][name];
          } else {
            return void 0;
          }
        },
        /**
         * Gets first parameter on the property.
         *
         * @param {String}        name   Parameter name (lowercase)
         * @return {String}        Parameter value
         */
        getFirstParameter: function(name) {
          var parameters = this.getParameter(name);
          if (Array.isArray(parameters)) {
            return parameters[0];
          }
          return parameters;
        },
        /**
         * Sets a parameter on the property.
         *
         * @param {String}       name     The parameter name
         * @param {Array|String} value    The parameter value
         */
        setParameter: function(name, value) {
          var lcname = name.toLowerCase();
          if (typeof value === "string" && lcname in this._designSet.param && "multiValue" in this._designSet.param[lcname]) {
            value = [value];
          }
          this.jCal[PROP_INDEX][name] = value;
        },
        /**
         * Removes a parameter
         *
         * @param {String} name     The parameter name
         */
        removeParameter: function(name) {
          delete this.jCal[PROP_INDEX][name];
        },
        /**
         * Get the default type based on this property's name.
         *
         * @return {String}     The default type for this property
         */
        getDefaultType: function() {
          var name = this.jCal[NAME_INDEX];
          var designSet = this._designSet;
          if (name in designSet.property) {
            var details = designSet.property[name];
            if ("defaultType" in details) {
              return details.defaultType;
            }
          }
          return design.defaultType;
        },
        /**
         * Sets type of property and clears out any existing values of the current
         * type.
         *
         * @param {String} type     New iCAL type (see design.*.values)
         */
        resetType: function(type) {
          this.removeAllValues();
          this.jCal[TYPE_INDEX] = type;
          this._updateType();
        },
        /**
         * Finds the first property value.
         *
         * @return {String}         First property value
         */
        getFirstValue: function() {
          return this._hydrateValue(0);
        },
        /**
         * Gets all values on the property.
         *
         * NOTE: this creates an array during each call.
         *
         * @return {Array}          List of values
         */
        getValues: function() {
          var len = this.jCal.length - VALUE_INDEX;
          if (len < 1) {
            return [];
          }
          var i3 = 0;
          var result = [];
          for (; i3 < len; i3++) {
            result[i3] = this._hydrateValue(i3);
          }
          return result;
        },
        /**
         * Removes all values from this property
         */
        removeAllValues: function() {
          if (this._values) {
            this._values.length = 0;
          }
          this.jCal.length = 3;
        },
        /**
         * Sets the values of the property.  Will overwrite the existing values.
         * This can only be used for multi-value properties.
         *
         * @param {Array} values    An array of values
         */
        setValues: function(values) {
          if (!this.isMultiValue) {
            throw new Error(
              this.name + ": does not not support mulitValue.\noverride isMultiValue"
            );
          }
          var len = values.length;
          var i3 = 0;
          this.removeAllValues();
          if (len > 0 && typeof values[0] === "object" && "icaltype" in values[0]) {
            this.resetType(values[0].icaltype);
          }
          if (this.isDecorated) {
            for (; i3 < len; i3++) {
              this._setDecoratedValue(values[i3], i3);
            }
          } else {
            for (; i3 < len; i3++) {
              this.jCal[VALUE_INDEX + i3] = values[i3];
            }
          }
        },
        /**
         * Sets the current value of the property. If this is a multi-value
         * property, all other values will be removed.
         *
         * @param {String|Object} value     New property value.
         */
        setValue: function(value) {
          this.removeAllValues();
          if (typeof value === "object" && "icaltype" in value) {
            this.resetType(value.icaltype);
          }
          if (this.isDecorated) {
            this._setDecoratedValue(value, 0);
          } else {
            this.jCal[VALUE_INDEX] = value;
          }
        },
        /**
         * Returns the Object representation of this component. The returned object
         * is a live jCal object and should be cloned if modified.
         * @return {Object}
         */
        toJSON: function() {
          return this.jCal;
        },
        /**
         * The string representation of this component.
         * @return {String}
         */
        toICALString: function() {
          return ICAL2.stringify.property(
            this.jCal,
            this._designSet,
            true
          );
        }
      };
      Property.fromString = function(str, designSet) {
        return new Property(ICAL2.parse.property(str, designSet));
      };
      return Property;
    }();
    ICAL2.UtcOffset = function() {
      function UtcOffset(aData) {
        this.fromData(aData);
      }
      UtcOffset.prototype = {
        /**
         * The hours in the utc-offset
         * @type {Number}
         */
        hours: 0,
        /**
         * The minutes in the utc-offset
         * @type {Number}
         */
        minutes: 0,
        /**
         * The sign of the utc offset, 1 for positive offset, -1 for negative
         * offsets.
         * @type {Number}
         */
        factor: 1,
        /**
         * The type name, to be used in the jCal object.
         * @constant
         * @type {String}
         * @default "utc-offset"
         */
        icaltype: "utc-offset",
        /**
         * Returns a clone of the utc offset object.
         *
         * @return {ICAL.UtcOffset}     The cloned object
         */
        clone: function() {
          return ICAL2.UtcOffset.fromSeconds(this.toSeconds());
        },
        /**
         * Sets up the current instance using members from the passed data object.
         *
         * @param {Object} aData          An object with members of the utc offset
         * @param {Number=} aData.hours   The hours for the utc offset
         * @param {Number=} aData.minutes The minutes in the utc offset
         * @param {Number=} aData.factor  The factor for the utc-offset, either -1 or 1
         */
        fromData: function(aData) {
          if (aData) {
            for (var key in aData) {
              if (aData.hasOwnProperty(key)) {
                this[key] = aData[key];
              }
            }
          }
          this._normalize();
        },
        /**
         * Sets up the current instance from the given seconds value. The seconds
         * value is truncated to the minute. Offsets are wrapped when the world
         * ends, the hour after UTC+14:00 is UTC-12:00.
         *
         * @param {Number} aSeconds         The seconds to convert into an offset
         */
        fromSeconds: function(aSeconds) {
          var secs = Math.abs(aSeconds);
          this.factor = aSeconds < 0 ? -1 : 1;
          this.hours = ICAL2.helpers.trunc(secs / 3600);
          secs -= this.hours * 3600;
          this.minutes = ICAL2.helpers.trunc(secs / 60);
          return this;
        },
        /**
         * Convert the current offset to a value in seconds
         *
         * @return {Number}                 The offset in seconds
         */
        toSeconds: function() {
          return this.factor * (60 * this.minutes + 3600 * this.hours);
        },
        /**
         * Compare this utc offset with another one.
         *
         * @param {ICAL.UtcOffset} other        The other offset to compare with
         * @return {Number}                     -1, 0 or 1 for less/equal/greater
         */
        compare: function icaltime_compare(other) {
          var a3 = this.toSeconds();
          var b3 = other.toSeconds();
          return (a3 > b3) - (b3 > a3);
        },
        _normalize: function() {
          var secs = this.toSeconds();
          var factor = this.factor;
          while (secs < -43200) {
            secs += 97200;
          }
          while (secs > 50400) {
            secs -= 97200;
          }
          this.fromSeconds(secs);
          if (secs == 0) {
            this.factor = factor;
          }
        },
        /**
         * The iCalendar string representation of this utc-offset.
         * @return {String}
         */
        toICALString: function() {
          return ICAL2.design.icalendar.value["utc-offset"].toICAL(this.toString());
        },
        /**
         * The string representation of this utc-offset.
         * @return {String}
         */
        toString: function toString() {
          return (this.factor == 1 ? "+" : "-") + ICAL2.helpers.pad2(this.hours) + ":" + ICAL2.helpers.pad2(this.minutes);
        }
      };
      UtcOffset.fromString = function(aString) {
        var options = {};
        options.factor = aString[0] === "+" ? 1 : -1;
        options.hours = ICAL2.helpers.strictParseInt(aString.substr(1, 2));
        options.minutes = ICAL2.helpers.strictParseInt(aString.substr(4, 2));
        return new ICAL2.UtcOffset(options);
      };
      UtcOffset.fromSeconds = function(aSeconds) {
        var instance = new UtcOffset();
        instance.fromSeconds(aSeconds);
        return instance;
      };
      return UtcOffset;
    }();
    ICAL2.Binary = function() {
      function Binary(aValue) {
        this.value = aValue;
      }
      Binary.prototype = {
        /**
         * The type name, to be used in the jCal object.
         * @default "binary"
         * @constant
         */
        icaltype: "binary",
        /**
         * Base64 decode the current value
         *
         * @return {String}         The base64-decoded value
         */
        decodeValue: function decodeValue() {
          return this._b64_decode(this.value);
        },
        /**
         * Encodes the passed parameter with base64 and sets the internal
         * value to the result.
         *
         * @param {String} aValue      The raw binary value to encode
         */
        setEncodedValue: function setEncodedValue(aValue) {
          this.value = this._b64_encode(aValue);
        },
        _b64_encode: function base64_encode(data) {
          var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
          var o1, o2, o3, h1, h22, h3, h4, bits, i3 = 0, ac = 0, enc = "", tmp_arr = [];
          if (!data) {
            return data;
          }
          do {
            o1 = data.charCodeAt(i3++);
            o2 = data.charCodeAt(i3++);
            o3 = data.charCodeAt(i3++);
            bits = o1 << 16 | o2 << 8 | o3;
            h1 = bits >> 18 & 63;
            h22 = bits >> 12 & 63;
            h3 = bits >> 6 & 63;
            h4 = bits & 63;
            tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h22) + b64.charAt(h3) + b64.charAt(h4);
          } while (i3 < data.length);
          enc = tmp_arr.join("");
          var r3 = data.length % 3;
          return (r3 ? enc.slice(0, r3 - 3) : enc) + "===".slice(r3 || 3);
        },
        _b64_decode: function base64_decode(data) {
          var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
          var o1, o2, o3, h1, h22, h3, h4, bits, i3 = 0, ac = 0, dec = "", tmp_arr = [];
          if (!data) {
            return data;
          }
          data += "";
          do {
            h1 = b64.indexOf(data.charAt(i3++));
            h22 = b64.indexOf(data.charAt(i3++));
            h3 = b64.indexOf(data.charAt(i3++));
            h4 = b64.indexOf(data.charAt(i3++));
            bits = h1 << 18 | h22 << 12 | h3 << 6 | h4;
            o1 = bits >> 16 & 255;
            o2 = bits >> 8 & 255;
            o3 = bits & 255;
            if (h3 == 64) {
              tmp_arr[ac++] = String.fromCharCode(o1);
            } else if (h4 == 64) {
              tmp_arr[ac++] = String.fromCharCode(o1, o2);
            } else {
              tmp_arr[ac++] = String.fromCharCode(o1, o2, o3);
            }
          } while (i3 < data.length);
          dec = tmp_arr.join("");
          return dec;
        },
        /**
         * The string representation of this value
         * @return {String}
         */
        toString: function() {
          return this.value;
        }
      };
      Binary.fromString = function(aString) {
        return new Binary(aString);
      };
      return Binary;
    }();
    (function() {
      ICAL2.Period = function icalperiod(aData) {
        this.wrappedJSObject = this;
        if (aData && "start" in aData) {
          if (aData.start && !(aData.start instanceof ICAL2.Time)) {
            throw new TypeError(".start must be an instance of ICAL.Time");
          }
          this.start = aData.start;
        }
        if (aData && aData.end && aData.duration) {
          throw new Error("cannot accept both end and duration");
        }
        if (aData && "end" in aData) {
          if (aData.end && !(aData.end instanceof ICAL2.Time)) {
            throw new TypeError(".end must be an instance of ICAL.Time");
          }
          this.end = aData.end;
        }
        if (aData && "duration" in aData) {
          if (aData.duration && !(aData.duration instanceof ICAL2.Duration)) {
            throw new TypeError(".duration must be an instance of ICAL.Duration");
          }
          this.duration = aData.duration;
        }
      };
      ICAL2.Period.prototype = {
        /**
         * The start of the period
         * @type {ICAL.Time}
         */
        start: null,
        /**
         * The end of the period
         * @type {ICAL.Time}
         */
        end: null,
        /**
         * The duration of the period
         * @type {ICAL.Duration}
         */
        duration: null,
        /**
         * The class identifier.
         * @constant
         * @type {String}
         * @default "icalperiod"
         */
        icalclass: "icalperiod",
        /**
         * The type name, to be used in the jCal object.
         * @constant
         * @type {String}
         * @default "period"
         */
        icaltype: "period",
        /**
         * Returns a clone of the duration object.
         *
         * @return {ICAL.Period}      The cloned object
         */
        clone: function() {
          return ICAL2.Period.fromData({
            start: this.start ? this.start.clone() : null,
            end: this.end ? this.end.clone() : null,
            duration: this.duration ? this.duration.clone() : null
          });
        },
        /**
         * Calculates the duration of the period, either directly or by subtracting
         * start from end date.
         *
         * @return {ICAL.Duration}      The calculated duration
         */
        getDuration: function duration() {
          if (this.duration) {
            return this.duration;
          } else {
            return this.end.subtractDate(this.start);
          }
        },
        /**
         * Calculates the end date of the period, either directly or by adding
         * duration to start date.
         *
         * @return {ICAL.Time}          The calculated end date
         */
        getEnd: function() {
          if (this.end) {
            return this.end;
          } else {
            var end = this.start.clone();
            end.addDuration(this.duration);
            return end;
          }
        },
        /**
         * The string representation of this period.
         * @return {String}
         */
        toString: function toString() {
          return this.start + "/" + (this.end || this.duration);
        },
        /**
         * The jCal representation of this period type.
         * @return {Object}
         */
        toJSON: function() {
          return [this.start.toString(), (this.end || this.duration).toString()];
        },
        /**
         * The iCalendar string representation of this period.
         * @return {String}
         */
        toICALString: function() {
          return this.start.toICALString() + "/" + (this.end || this.duration).toICALString();
        }
      };
      ICAL2.Period.fromString = function fromString(str, prop) {
        var parts = str.split("/");
        if (parts.length !== 2) {
          throw new Error(
            'Invalid string value: "' + str + '" must contain a "/" char.'
          );
        }
        var options = {
          start: ICAL2.Time.fromDateTimeString(parts[0], prop)
        };
        var end = parts[1];
        if (ICAL2.Duration.isValueString(end)) {
          options.duration = ICAL2.Duration.fromString(end);
        } else {
          options.end = ICAL2.Time.fromDateTimeString(end, prop);
        }
        return new ICAL2.Period(options);
      };
      ICAL2.Period.fromData = function fromData(aData) {
        return new ICAL2.Period(aData);
      };
      ICAL2.Period.fromJSON = function(aData, aProp, aLenient) {
        function fromDateOrDateTimeString(aValue, aProp2) {
          if (aLenient) {
            return ICAL2.Time.fromString(aValue, aProp2);
          } else {
            return ICAL2.Time.fromDateTimeString(aValue, aProp2);
          }
        }
        if (ICAL2.Duration.isValueString(aData[1])) {
          return ICAL2.Period.fromData({
            start: fromDateOrDateTimeString(aData[0], aProp),
            duration: ICAL2.Duration.fromString(aData[1])
          });
        } else {
          return ICAL2.Period.fromData({
            start: fromDateOrDateTimeString(aData[0], aProp),
            end: fromDateOrDateTimeString(aData[1], aProp)
          });
        }
      };
    })();
    (function() {
      var DURATION_LETTERS = /([PDWHMTS]{1,1})/;
      ICAL2.Duration = function icalduration(data) {
        this.wrappedJSObject = this;
        this.fromData(data);
      };
      ICAL2.Duration.prototype = {
        /**
         * The weeks in this duration
         * @type {Number}
         * @default 0
         */
        weeks: 0,
        /**
         * The days in this duration
         * @type {Number}
         * @default 0
         */
        days: 0,
        /**
         * The days in this duration
         * @type {Number}
         * @default 0
         */
        hours: 0,
        /**
         * The minutes in this duration
         * @type {Number}
         * @default 0
         */
        minutes: 0,
        /**
         * The seconds in this duration
         * @type {Number}
         * @default 0
         */
        seconds: 0,
        /**
         * The seconds in this duration
         * @type {Boolean}
         * @default false
         */
        isNegative: false,
        /**
         * The class identifier.
         * @constant
         * @type {String}
         * @default "icalduration"
         */
        icalclass: "icalduration",
        /**
         * The type name, to be used in the jCal object.
         * @constant
         * @type {String}
         * @default "duration"
         */
        icaltype: "duration",
        /**
         * Returns a clone of the duration object.
         *
         * @return {ICAL.Duration}      The cloned object
         */
        clone: function clone2() {
          return ICAL2.Duration.fromData(this);
        },
        /**
         * The duration value expressed as a number of seconds.
         *
         * @return {Number}             The duration value in seconds
         */
        toSeconds: function toSeconds() {
          var seconds = this.seconds + 60 * this.minutes + 3600 * this.hours + 86400 * this.days + 7 * 86400 * this.weeks;
          return this.isNegative ? -seconds : seconds;
        },
        /**
         * Reads the passed seconds value into this duration object. Afterwards,
         * members like {@link ICAL.Duration#days days} and {@link ICAL.Duration#weeks weeks} will be set up
         * accordingly.
         *
         * @param {Number} aSeconds     The duration value in seconds
         * @return {ICAL.Duration}      Returns this instance
         */
        fromSeconds: function fromSeconds(aSeconds) {
          var secs = Math.abs(aSeconds);
          this.isNegative = aSeconds < 0;
          this.days = ICAL2.helpers.trunc(secs / 86400);
          if (this.days % 7 == 0) {
            this.weeks = this.days / 7;
            this.days = 0;
          } else {
            this.weeks = 0;
          }
          secs -= (this.days + 7 * this.weeks) * 86400;
          this.hours = ICAL2.helpers.trunc(secs / 3600);
          secs -= this.hours * 3600;
          this.minutes = ICAL2.helpers.trunc(secs / 60);
          secs -= this.minutes * 60;
          this.seconds = secs;
          return this;
        },
        /**
         * Sets up the current instance using members from the passed data object.
         *
         * @param {Object} aData               An object with members of the duration
         * @param {Number} aData.weeks         Duration in weeks
         * @param {Number} aData.days          Duration in days
         * @param {Number} aData.hours         Duration in hours
         * @param {Number} aData.minutes       Duration in minutes
         * @param {Number} aData.seconds       Duration in seconds
         * @param {Boolean} aData.isNegative   If true, the duration is negative
         */
        fromData: function fromData(aData) {
          var propsToCopy = [
            "weeks",
            "days",
            "hours",
            "minutes",
            "seconds",
            "isNegative"
          ];
          for (var key in propsToCopy) {
            if (!propsToCopy.hasOwnProperty(key)) {
              continue;
            }
            var prop = propsToCopy[key];
            if (aData && prop in aData) {
              this[prop] = aData[prop];
            } else {
              this[prop] = 0;
            }
          }
        },
        /**
         * Resets the duration instance to the default values, i.e. PT0S
         */
        reset: function reset() {
          this.isNegative = false;
          this.weeks = 0;
          this.days = 0;
          this.hours = 0;
          this.minutes = 0;
          this.seconds = 0;
        },
        /**
         * Compares the duration instance with another one.
         *
         * @param {ICAL.Duration} aOther        The instance to compare with
         * @return {Number}                     -1, 0 or 1 for less/equal/greater
         */
        compare: function compare(aOther) {
          var thisSeconds = this.toSeconds();
          var otherSeconds = aOther.toSeconds();
          return (thisSeconds > otherSeconds) - (thisSeconds < otherSeconds);
        },
        /**
         * Normalizes the duration instance. For example, a duration with a value
         * of 61 seconds will be normalized to 1 minute and 1 second.
         */
        normalize: function normalize() {
          this.fromSeconds(this.toSeconds());
        },
        /**
         * The string representation of this duration.
         * @return {String}
         */
        toString: function toString() {
          if (this.toSeconds() == 0) {
            return "PT0S";
          } else {
            var str = "";
            if (this.isNegative)
              str += "-";
            str += "P";
            if (this.weeks)
              str += this.weeks + "W";
            if (this.days)
              str += this.days + "D";
            if (this.hours || this.minutes || this.seconds) {
              str += "T";
              if (this.hours)
                str += this.hours + "H";
              if (this.minutes)
                str += this.minutes + "M";
              if (this.seconds)
                str += this.seconds + "S";
            }
            return str;
          }
        },
        /**
         * The iCalendar string representation of this duration.
         * @return {String}
         */
        toICALString: function() {
          return this.toString();
        }
      };
      ICAL2.Duration.fromSeconds = function icalduration_from_seconds(aSeconds) {
        return new ICAL2.Duration().fromSeconds(aSeconds);
      };
      function parseDurationChunk(letter, number, object) {
        var type;
        switch (letter) {
          case "P":
            if (number && number === "-") {
              object.isNegative = true;
            } else {
              object.isNegative = false;
            }
            break;
          case "D":
            type = "days";
            break;
          case "W":
            type = "weeks";
            break;
          case "H":
            type = "hours";
            break;
          case "M":
            type = "minutes";
            break;
          case "S":
            type = "seconds";
            break;
          default:
            return 0;
        }
        if (type) {
          if (!number && number !== 0) {
            throw new Error(
              'invalid duration value: Missing number before "' + letter + '"'
            );
          }
          var num = parseInt(number, 10);
          if (ICAL2.helpers.isStrictlyNaN(num)) {
            throw new Error(
              'invalid duration value: Invalid number "' + number + '" before "' + letter + '"'
            );
          }
          object[type] = num;
        }
        return 1;
      }
      ICAL2.Duration.isValueString = function(string) {
        return string[0] === "P" || string[1] === "P";
      };
      ICAL2.Duration.fromString = function icalduration_from_string(aStr) {
        var pos = 0;
        var dict = /* @__PURE__ */ Object.create(null);
        var chunks = 0;
        while ((pos = aStr.search(DURATION_LETTERS)) !== -1) {
          var type = aStr[pos];
          var numeric = aStr.substr(0, pos);
          aStr = aStr.substr(pos + 1);
          chunks += parseDurationChunk(type, numeric, dict);
        }
        if (chunks < 2) {
          throw new Error(
            'invalid duration value: Not enough duration components in "' + aStr + '"'
          );
        }
        return new ICAL2.Duration(dict);
      };
      ICAL2.Duration.fromData = function icalduration_from_data(aData) {
        return new ICAL2.Duration(aData);
      };
    })();
    (function() {
      var OPTIONS = [
        "tzid",
        "location",
        "tznames",
        "latitude",
        "longitude"
      ];
      ICAL2.Timezone = function icaltimezone(data) {
        this.wrappedJSObject = this;
        this.fromData(data);
      };
      ICAL2.Timezone.prototype = {
        /**
         * Timezone identifier
         * @type {String}
         */
        tzid: "",
        /**
         * Timezone location
         * @type {String}
         */
        location: "",
        /**
         * Alternative timezone name, for the string representation
         * @type {String}
         */
        tznames: "",
        /**
         * The primary latitude for the timezone.
         * @type {Number}
         */
        latitude: 0,
        /**
         * The primary longitude for the timezone.
         * @type {Number}
         */
        longitude: 0,
        /**
         * The vtimezone component for this timezone.
         * @type {ICAL.Component}
         */
        component: null,
        /**
         * The year this timezone has been expanded to. All timezone transition
         * dates until this year are known and can be used for calculation
         *
         * @private
         * @type {Number}
         */
        expandedUntilYear: 0,
        /**
         * The class identifier.
         * @constant
         * @type {String}
         * @default "icaltimezone"
         */
        icalclass: "icaltimezone",
        /**
         * Sets up the current instance using members from the passed data object.
         *
         * @param {ICAL.Component|Object} aData options for class
         * @param {String|ICAL.Component} aData.component
         *        If aData is a simple object, then this member can be set to either a
         *        string containing the component data, or an already parsed
         *        ICAL.Component
         * @param {String} aData.tzid      The timezone identifier
         * @param {String} aData.location  The timezone locationw
         * @param {String} aData.tznames   An alternative string representation of the
         *                                  timezone
         * @param {Number} aData.latitude  The latitude of the timezone
         * @param {Number} aData.longitude The longitude of the timezone
         */
        fromData: function fromData(aData) {
          this.expandedUntilYear = 0;
          this.changes = [];
          if (aData instanceof ICAL2.Component) {
            this.component = aData;
          } else {
            if (aData && "component" in aData) {
              if (typeof aData.component == "string") {
                var jCal = ICAL2.parse(aData.component);
                this.component = new ICAL2.Component(jCal);
              } else if (aData.component instanceof ICAL2.Component) {
                this.component = aData.component;
              } else {
                this.component = null;
              }
            }
            for (var key in OPTIONS) {
              if (OPTIONS.hasOwnProperty(key)) {
                var prop = OPTIONS[key];
                if (aData && prop in aData) {
                  this[prop] = aData[prop];
                }
              }
            }
          }
          if (this.component instanceof ICAL2.Component && !this.tzid) {
            this.tzid = this.component.getFirstPropertyValue("tzid");
          }
          return this;
        },
        /**
         * Finds the utcOffset the given time would occur in this timezone.
         *
         * @param {ICAL.Time} tt        The time to check for
         * @return {Number} utc offset in seconds
         */
        utcOffset: function utcOffset(tt) {
          if (this == ICAL2.Timezone.utcTimezone || this == ICAL2.Timezone.localTimezone) {
            return 0;
          }
          this._ensureCoverage(tt.year);
          if (!this.changes.length) {
            return 0;
          }
          var tt_change = {
            year: tt.year,
            month: tt.month,
            day: tt.day,
            hour: tt.hour,
            minute: tt.minute,
            second: tt.second
          };
          var change_num = this._findNearbyChange(tt_change);
          var change_num_to_use = -1;
          var step = 1;
          for (; ; ) {
            var change = ICAL2.helpers.clone(this.changes[change_num], true);
            if (change.utcOffset < change.prevUtcOffset) {
              ICAL2.Timezone.adjust_change(change, 0, 0, 0, change.utcOffset);
            } else {
              ICAL2.Timezone.adjust_change(
                change,
                0,
                0,
                0,
                change.prevUtcOffset
              );
            }
            var cmp = ICAL2.Timezone._compare_change_fn(tt_change, change);
            if (cmp >= 0) {
              change_num_to_use = change_num;
            } else {
              step = -1;
            }
            if (step == -1 && change_num_to_use != -1) {
              break;
            }
            change_num += step;
            if (change_num < 0) {
              return 0;
            }
            if (change_num >= this.changes.length) {
              break;
            }
          }
          var zone_change = this.changes[change_num_to_use];
          var utcOffset_change = zone_change.utcOffset - zone_change.prevUtcOffset;
          if (utcOffset_change < 0 && change_num_to_use > 0) {
            var tmp_change = ICAL2.helpers.clone(zone_change, true);
            ICAL2.Timezone.adjust_change(
              tmp_change,
              0,
              0,
              0,
              tmp_change.prevUtcOffset
            );
            if (ICAL2.Timezone._compare_change_fn(tt_change, tmp_change) < 0) {
              var prev_zone_change = this.changes[change_num_to_use - 1];
              var want_daylight = false;
              if (zone_change.is_daylight != want_daylight && prev_zone_change.is_daylight == want_daylight) {
                zone_change = prev_zone_change;
              }
            }
          }
          return zone_change.utcOffset;
        },
        _findNearbyChange: function icaltimezone_find_nearby_change(change) {
          var idx = ICAL2.helpers.binsearchInsert(
            this.changes,
            change,
            ICAL2.Timezone._compare_change_fn
          );
          if (idx >= this.changes.length) {
            return this.changes.length - 1;
          }
          return idx;
        },
        _ensureCoverage: function(aYear) {
          if (ICAL2.Timezone._minimumExpansionYear == -1) {
            var today = ICAL2.Time.now();
            ICAL2.Timezone._minimumExpansionYear = today.year;
          }
          var changesEndYear = aYear;
          if (changesEndYear < ICAL2.Timezone._minimumExpansionYear) {
            changesEndYear = ICAL2.Timezone._minimumExpansionYear;
          }
          changesEndYear += ICAL2.Timezone.EXTRA_COVERAGE;
          if (changesEndYear > ICAL2.Timezone.MAX_YEAR) {
            changesEndYear = ICAL2.Timezone.MAX_YEAR;
          }
          if (!this.changes.length || this.expandedUntilYear < aYear) {
            var subcomps = this.component.getAllSubcomponents();
            var compLen = subcomps.length;
            var compIdx = 0;
            for (; compIdx < compLen; compIdx++) {
              this._expandComponent(
                subcomps[compIdx],
                changesEndYear,
                this.changes
              );
            }
            this.changes.sort(ICAL2.Timezone._compare_change_fn);
            this.expandedUntilYear = changesEndYear;
          }
        },
        _expandComponent: function(aComponent, aYear, changes) {
          if (!aComponent.hasProperty("dtstart") || !aComponent.hasProperty("tzoffsetto") || !aComponent.hasProperty("tzoffsetfrom")) {
            return null;
          }
          var dtstart = aComponent.getFirstProperty("dtstart").getFirstValue();
          var change;
          function convert_tzoffset(offset) {
            return offset.factor * (offset.hours * 3600 + offset.minutes * 60);
          }
          function init_changes() {
            var changebase = {};
            changebase.is_daylight = aComponent.name == "daylight";
            changebase.utcOffset = convert_tzoffset(
              aComponent.getFirstProperty("tzoffsetto").getFirstValue()
            );
            changebase.prevUtcOffset = convert_tzoffset(
              aComponent.getFirstProperty("tzoffsetfrom").getFirstValue()
            );
            return changebase;
          }
          if (!aComponent.hasProperty("rrule") && !aComponent.hasProperty("rdate")) {
            change = init_changes();
            change.year = dtstart.year;
            change.month = dtstart.month;
            change.day = dtstart.day;
            change.hour = dtstart.hour;
            change.minute = dtstart.minute;
            change.second = dtstart.second;
            ICAL2.Timezone.adjust_change(
              change,
              0,
              0,
              0,
              -change.prevUtcOffset
            );
            changes.push(change);
          } else {
            var props = aComponent.getAllProperties("rdate");
            for (var rdatekey in props) {
              if (!props.hasOwnProperty(rdatekey)) {
                continue;
              }
              var rdate = props[rdatekey];
              var time = rdate.getFirstValue();
              change = init_changes();
              change.year = time.year;
              change.month = time.month;
              change.day = time.day;
              if (time.isDate) {
                change.hour = dtstart.hour;
                change.minute = dtstart.minute;
                change.second = dtstart.second;
                if (dtstart.zone != ICAL2.Timezone.utcTimezone) {
                  ICAL2.Timezone.adjust_change(
                    change,
                    0,
                    0,
                    0,
                    -change.prevUtcOffset
                  );
                }
              } else {
                change.hour = time.hour;
                change.minute = time.minute;
                change.second = time.second;
                if (time.zone != ICAL2.Timezone.utcTimezone) {
                  ICAL2.Timezone.adjust_change(
                    change,
                    0,
                    0,
                    0,
                    -change.prevUtcOffset
                  );
                }
              }
              changes.push(change);
            }
            var rrule = aComponent.getFirstProperty("rrule");
            if (rrule) {
              rrule = rrule.getFirstValue();
              change = init_changes();
              if (rrule.until && rrule.until.zone == ICAL2.Timezone.utcTimezone) {
                rrule.until.adjust(0, 0, 0, change.prevUtcOffset);
                rrule.until.zone = ICAL2.Timezone.localTimezone;
              }
              var iterator = rrule.iterator(dtstart);
              var occ;
              while (occ = iterator.next()) {
                change = init_changes();
                if (occ.year > aYear || !occ) {
                  break;
                }
                change.year = occ.year;
                change.month = occ.month;
                change.day = occ.day;
                change.hour = occ.hour;
                change.minute = occ.minute;
                change.second = occ.second;
                change.isDate = occ.isDate;
                ICAL2.Timezone.adjust_change(
                  change,
                  0,
                  0,
                  0,
                  -change.prevUtcOffset
                );
                changes.push(change);
              }
            }
          }
          return changes;
        },
        /**
         * The string representation of this timezone.
         * @return {String}
         */
        toString: function toString() {
          return this.tznames ? this.tznames : this.tzid;
        }
      };
      ICAL2.Timezone._compare_change_fn = function icaltimezone_compare_change_fn(a3, b3) {
        if (a3.year < b3.year)
          return -1;
        else if (a3.year > b3.year)
          return 1;
        if (a3.month < b3.month)
          return -1;
        else if (a3.month > b3.month)
          return 1;
        if (a3.day < b3.day)
          return -1;
        else if (a3.day > b3.day)
          return 1;
        if (a3.hour < b3.hour)
          return -1;
        else if (a3.hour > b3.hour)
          return 1;
        if (a3.minute < b3.minute)
          return -1;
        else if (a3.minute > b3.minute)
          return 1;
        if (a3.second < b3.second)
          return -1;
        else if (a3.second > b3.second)
          return 1;
        return 0;
      };
      ICAL2.Timezone.convert_time = function icaltimezone_convert_time(tt, from_zone, to_zone) {
        if (tt.isDate || from_zone.tzid == to_zone.tzid || from_zone == ICAL2.Timezone.localTimezone || to_zone == ICAL2.Timezone.localTimezone) {
          tt.zone = to_zone;
          return tt;
        }
        var utcOffset = from_zone.utcOffset(tt);
        tt.adjust(0, 0, 0, -utcOffset);
        utcOffset = to_zone.utcOffset(tt);
        tt.adjust(0, 0, 0, utcOffset);
        return null;
      };
      ICAL2.Timezone.fromData = function icaltimezone_fromData(aData) {
        var tt = new ICAL2.Timezone();
        return tt.fromData(aData);
      };
      ICAL2.Timezone.utcTimezone = ICAL2.Timezone.fromData({
        tzid: "UTC"
      });
      ICAL2.Timezone.localTimezone = ICAL2.Timezone.fromData({
        tzid: "floating"
      });
      ICAL2.Timezone.adjust_change = function icaltimezone_adjust_change(change, days, hours, minutes, seconds) {
        return ICAL2.Time.prototype.adjust.call(
          change,
          days,
          hours,
          minutes,
          seconds,
          change
        );
      };
      ICAL2.Timezone._minimumExpansionYear = -1;
      ICAL2.Timezone.MAX_YEAR = 2035;
      ICAL2.Timezone.EXTRA_COVERAGE = 5;
    })();
    ICAL2.TimezoneService = function() {
      var zones;
      var TimezoneService = {
        get count() {
          return Object.keys(zones).length;
        },
        reset: function() {
          zones = /* @__PURE__ */ Object.create(null);
          var utc = ICAL2.Timezone.utcTimezone;
          zones.Z = utc;
          zones.UTC = utc;
          zones.GMT = utc;
        },
        /**
         * Checks if timezone id has been registered.
         *
         * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)
         * @return {Boolean}        False, when not present
         */
        has: function(tzid) {
          return !!zones[tzid];
        },
        /**
         * Returns a timezone by its tzid if present.
         *
         * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)
         * @return {?ICAL.Timezone} The timezone, or null if not found
         */
        get: function(tzid) {
          return zones[tzid];
        },
        /**
         * Registers a timezone object or component.
         *
         * @param {String=} name
         *        The name of the timezone. Defaults to the component's TZID if not
         *        passed.
         * @param {ICAL.Component|ICAL.Timezone} zone
         *        The initialized zone or vtimezone.
         */
        register: function(name, timezone) {
          if (name instanceof ICAL2.Component) {
            if (name.name === "vtimezone") {
              timezone = new ICAL2.Timezone(name);
              name = timezone.tzid;
            }
          }
          if (timezone instanceof ICAL2.Timezone) {
            zones[name] = timezone;
          } else {
            throw new TypeError("timezone must be ICAL.Timezone or ICAL.Component");
          }
        },
        /**
         * Removes a timezone by its tzid from the list.
         *
         * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)
         * @return {?ICAL.Timezone} The removed timezone, or null if not registered
         */
        remove: function(tzid) {
          return delete zones[tzid];
        }
      };
      TimezoneService.reset();
      return TimezoneService;
    }();
    (function() {
      ICAL2.Time = function icaltime(data, zone) {
        this.wrappedJSObject = this;
        var time = this._time = /* @__PURE__ */ Object.create(null);
        time.year = 0;
        time.month = 1;
        time.day = 1;
        time.hour = 0;
        time.minute = 0;
        time.second = 0;
        time.isDate = false;
        this.fromData(data, zone);
      };
      ICAL2.Time._dowCache = {};
      ICAL2.Time._wnCache = {};
      ICAL2.Time.prototype = {
        /**
         * The class identifier.
         * @constant
         * @type {String}
         * @default "icaltime"
         */
        icalclass: "icaltime",
        _cachedUnixTime: null,
        /**
         * The type name, to be used in the jCal object. This value may change and
         * is strictly defined by the {@link ICAL.Time#isDate isDate} member.
         * @readonly
         * @type {String}
         * @default "date-time"
         */
        get icaltype() {
          return this.isDate ? "date" : "date-time";
        },
        /**
         * The timezone for this time.
         * @type {ICAL.Timezone}
         */
        zone: null,
        /**
         * Internal uses to indicate that a change has been made and the next read
         * operation must attempt to normalize the value (for example changing the
         * day to 33).
         *
         * @type {Boolean}
         * @private
         */
        _pendingNormalization: false,
        /**
         * Returns a clone of the time object.
         *
         * @return {ICAL.Time}              The cloned object
         */
        clone: function() {
          return new ICAL2.Time(this._time, this.zone);
        },
        /**
         * Reset the time instance to epoch time
         */
        reset: function icaltime_reset() {
          this.fromData(ICAL2.Time.epochTime);
          this.zone = ICAL2.Timezone.utcTimezone;
        },
        /**
         * Reset the time instance to the given date/time values.
         *
         * @param {Number} year             The year to set
         * @param {Number} month            The month to set
         * @param {Number} day              The day to set
         * @param {Number} hour             The hour to set
         * @param {Number} minute           The minute to set
         * @param {Number} second           The second to set
         * @param {ICAL.Timezone} timezone  The timezone to set
         */
        resetTo: function icaltime_resetTo(year, month, day, hour, minute, second, timezone) {
          this.fromData({
            year,
            month,
            day,
            hour,
            minute,
            second,
            zone: timezone
          });
        },
        /**
         * Set up the current instance from the Javascript date value.
         *
         * @param {?Date} aDate     The Javascript Date to read, or null to reset
         * @param {Boolean} useUTC  If true, the UTC values of the date will be used
         */
        fromJSDate: function icaltime_fromJSDate(aDate, useUTC) {
          if (!aDate) {
            this.reset();
          } else {
            if (useUTC) {
              this.zone = ICAL2.Timezone.utcTimezone;
              this.year = aDate.getUTCFullYear();
              this.month = aDate.getUTCMonth() + 1;
              this.day = aDate.getUTCDate();
              this.hour = aDate.getUTCHours();
              this.minute = aDate.getUTCMinutes();
              this.second = aDate.getUTCSeconds();
            } else {
              this.zone = ICAL2.Timezone.localTimezone;
              this.year = aDate.getFullYear();
              this.month = aDate.getMonth() + 1;
              this.day = aDate.getDate();
              this.hour = aDate.getHours();
              this.minute = aDate.getMinutes();
              this.second = aDate.getSeconds();
            }
          }
          this._cachedUnixTime = null;
          return this;
        },
        /**
         * Sets up the current instance using members from the passed data object.
         *
         * @param {Object} aData            Time initialization
         * @param {Number=} aData.year      The year for this date
         * @param {Number=} aData.month     The month for this date
         * @param {Number=} aData.day       The day for this date
         * @param {Number=} aData.hour      The hour for this date
         * @param {Number=} aData.minute    The minute for this date
         * @param {Number=} aData.second    The second for this date
         * @param {Boolean=} aData.isDate   If true, the instance represents a date
         *                                    (as opposed to a date-time)
         * @param {ICAL.Timezone=} aZone    Timezone this position occurs in
         */
        fromData: function fromData(aData, aZone) {
          if (aData) {
            for (var key in aData) {
              if (Object.prototype.hasOwnProperty.call(aData, key)) {
                if (key === "icaltype")
                  continue;
                this[key] = aData[key];
              }
            }
          }
          if (aZone) {
            this.zone = aZone;
          }
          if (aData && !("isDate" in aData)) {
            this.isDate = !("hour" in aData);
          } else if (aData && "isDate" in aData) {
            this.isDate = aData.isDate;
          }
          if (aData && "timezone" in aData) {
            var zone = ICAL2.TimezoneService.get(
              aData.timezone
            );
            this.zone = zone || ICAL2.Timezone.localTimezone;
          }
          if (aData && "zone" in aData) {
            this.zone = aData.zone;
          }
          if (!this.zone) {
            this.zone = ICAL2.Timezone.localTimezone;
          }
          this._cachedUnixTime = null;
          return this;
        },
        /**
         * Calculate the day of week.
         * @param {ICAL.Time.weekDay=} aWeekStart
         *        The week start weekday, defaults to SUNDAY
         * @return {ICAL.Time.weekDay}
         */
        dayOfWeek: function icaltime_dayOfWeek(aWeekStart) {
          var firstDow = aWeekStart || ICAL2.Time.SUNDAY;
          var dowCacheKey = (this.year << 12) + (this.month << 8) + (this.day << 3) + firstDow;
          if (dowCacheKey in ICAL2.Time._dowCache) {
            return ICAL2.Time._dowCache[dowCacheKey];
          }
          var q3 = this.day;
          var m3 = this.month + (this.month < 3 ? 12 : 0);
          var Y = this.year - (this.month < 3 ? 1 : 0);
          var h3 = q3 + Y + ICAL2.helpers.trunc((m3 + 1) * 26 / 10) + ICAL2.helpers.trunc(Y / 4);
          if (true) {
            h3 += ICAL2.helpers.trunc(Y / 100) * 6 + ICAL2.helpers.trunc(Y / 400);
          } else {
            h3 += 5;
          }
          h3 = (h3 + 7 - firstDow) % 7 + 1;
          ICAL2.Time._dowCache[dowCacheKey] = h3;
          return h3;
        },
        /**
         * Calculate the day of year.
         * @return {Number}
         */
        dayOfYear: function dayOfYear() {
          var is_leap = ICAL2.Time.isLeapYear(this.year) ? 1 : 0;
          var diypm = ICAL2.Time.daysInYearPassedMonth;
          return diypm[is_leap][this.month - 1] + this.day;
        },
        /**
         * Returns a copy of the current date/time, rewound to the start of the
         * week. The resulting ICAL.Time instance is of icaltype date, even if this
         * is a date-time.
         *
         * @param {ICAL.Time.weekDay=} aWeekStart
         *        The week start weekday, defaults to SUNDAY
         * @return {ICAL.Time}      The start of the week (cloned)
         */
        startOfWeek: function startOfWeek(aWeekStart) {
          var firstDow = aWeekStart || ICAL2.Time.SUNDAY;
          var result = this.clone();
          result.day -= (this.dayOfWeek() + 7 - firstDow) % 7;
          result.isDate = true;
          result.hour = 0;
          result.minute = 0;
          result.second = 0;
          return result;
        },
        /**
         * Returns a copy of the current date/time, shifted to the end of the week.
         * The resulting ICAL.Time instance is of icaltype date, even if this is a
         * date-time.
         *
         * @param {ICAL.Time.weekDay=} aWeekStart
         *        The week start weekday, defaults to SUNDAY
         * @return {ICAL.Time}      The end of the week (cloned)
         */
        endOfWeek: function endOfWeek(aWeekStart) {
          var firstDow = aWeekStart || ICAL2.Time.SUNDAY;
          var result = this.clone();
          result.day += (7 - this.dayOfWeek() + firstDow - ICAL2.Time.SUNDAY) % 7;
          result.isDate = true;
          result.hour = 0;
          result.minute = 0;
          result.second = 0;
          return result;
        },
        /**
         * Returns a copy of the current date/time, rewound to the start of the
         * month. The resulting ICAL.Time instance is of icaltype date, even if
         * this is a date-time.
         *
         * @return {ICAL.Time}      The start of the month (cloned)
         */
        startOfMonth: function startOfMonth() {
          var result = this.clone();
          result.day = 1;
          result.isDate = true;
          result.hour = 0;
          result.minute = 0;
          result.second = 0;
          return result;
        },
        /**
         * Returns a copy of the current date/time, shifted to the end of the
         * month.  The resulting ICAL.Time instance is of icaltype date, even if
         * this is a date-time.
         *
         * @return {ICAL.Time}      The end of the month (cloned)
         */
        endOfMonth: function endOfMonth() {
          var result = this.clone();
          result.day = ICAL2.Time.daysInMonth(result.month, result.year);
          result.isDate = true;
          result.hour = 0;
          result.minute = 0;
          result.second = 0;
          return result;
        },
        /**
         * Returns a copy of the current date/time, rewound to the start of the
         * year. The resulting ICAL.Time instance is of icaltype date, even if
         * this is a date-time.
         *
         * @return {ICAL.Time}      The start of the year (cloned)
         */
        startOfYear: function startOfYear() {
          var result = this.clone();
          result.day = 1;
          result.month = 1;
          result.isDate = true;
          result.hour = 0;
          result.minute = 0;
          result.second = 0;
          return result;
        },
        /**
         * Returns a copy of the current date/time, shifted to the end of the
         * year.  The resulting ICAL.Time instance is of icaltype date, even if
         * this is a date-time.
         *
         * @return {ICAL.Time}      The end of the year (cloned)
         */
        endOfYear: function endOfYear() {
          var result = this.clone();
          result.day = 31;
          result.month = 12;
          result.isDate = true;
          result.hour = 0;
          result.minute = 0;
          result.second = 0;
          return result;
        },
        /**
         * First calculates the start of the week, then returns the day of year for
         * this date. If the day falls into the previous year, the day is zero or negative.
         *
         * @param {ICAL.Time.weekDay=} aFirstDayOfWeek
         *        The week start weekday, defaults to SUNDAY
         * @return {Number}     The calculated day of year
         */
        startDoyWeek: function startDoyWeek(aFirstDayOfWeek) {
          var firstDow = aFirstDayOfWeek || ICAL2.Time.SUNDAY;
          var delta = this.dayOfWeek() - firstDow;
          if (delta < 0)
            delta += 7;
          return this.dayOfYear() - delta;
        },
        /**
         * Get the dominical letter for the current year. Letters range from A - G
         * for common years, and AG to GF for leap years.
         *
         * @param {Number} yr           The year to retrieve the letter for
         * @return {String}             The dominical letter.
         */
        getDominicalLetter: function() {
          return ICAL2.Time.getDominicalLetter(this.year);
        },
        /**
         * Finds the nthWeekDay relative to the current month (not day).  The
         * returned value is a day relative the month that this month belongs to so
         * 1 would indicate the first of the month and 40 would indicate a day in
         * the following month.
         *
         * @param {Number} aDayOfWeek   Day of the week see the day name constants
         * @param {Number} aPos         Nth occurrence of a given week day values
         *        of 1 and 0 both indicate the first weekday of that type. aPos may
         *        be either positive or negative
         *
         * @return {Number} numeric value indicating a day relative
         *                   to the current month of this time object
         */
        nthWeekDay: function icaltime_nthWeekDay(aDayOfWeek, aPos) {
          var daysInMonth = ICAL2.Time.daysInMonth(this.month, this.year);
          var weekday;
          var pos = aPos;
          var start = 0;
          var otherDay = this.clone();
          if (pos >= 0) {
            otherDay.day = 1;
            if (pos != 0) {
              pos--;
            }
            start = otherDay.day;
            var startDow = otherDay.dayOfWeek();
            var offset = aDayOfWeek - startDow;
            if (offset < 0)
              offset += 7;
            start += offset;
            start -= aDayOfWeek;
            weekday = aDayOfWeek;
          } else {
            otherDay.day = daysInMonth;
            var endDow = otherDay.dayOfWeek();
            pos++;
            weekday = endDow - aDayOfWeek;
            if (weekday < 0) {
              weekday += 7;
            }
            weekday = daysInMonth - weekday;
          }
          weekday += pos * 7;
          return start + weekday;
        },
        /**
         * Checks if current time is the nth weekday, relative to the current
         * month.  Will always return false when rule resolves outside of current
         * month.
         *
         * @param {ICAL.Time.weekDay} aDayOfWeek       Day of week to check
         * @param {Number} aPos                        Relative position
         * @return {Boolean}                           True, if it is the nth weekday
         */
        isNthWeekDay: function(aDayOfWeek, aPos) {
          var dow = this.dayOfWeek();
          if (aPos === 0 && dow === aDayOfWeek) {
            return true;
          }
          var day = this.nthWeekDay(aDayOfWeek, aPos);
          if (day === this.day) {
            return true;
          }
          return false;
        },
        /**
         * Calculates the ISO 8601 week number. The first week of a year is the
         * week that contains the first Thursday. The year can have 53 weeks, if
         * January 1st is a Friday.
         *
         * Note there are regions where the first week of the year is the one that
         * starts on January 1st, which may offset the week number. Also, if a
         * different week start is specified, this will also affect the week
         * number.
         *
         * @see ICAL.Time.weekOneStarts
         * @param {ICAL.Time.weekDay} aWeekStart        The weekday the week starts with
         * @return {Number}                             The ISO week number
         */
        weekNumber: function weekNumber(aWeekStart) {
          var wnCacheKey = (this.year << 12) + (this.month << 8) + (this.day << 3) + aWeekStart;
          if (wnCacheKey in ICAL2.Time._wnCache) {
            return ICAL2.Time._wnCache[wnCacheKey];
          }
          var week1;
          var dt = this.clone();
          dt.isDate = true;
          var isoyear = this.year;
          if (dt.month == 12 && dt.day > 25) {
            week1 = ICAL2.Time.weekOneStarts(isoyear + 1, aWeekStart);
            if (dt.compare(week1) < 0) {
              week1 = ICAL2.Time.weekOneStarts(isoyear, aWeekStart);
            } else {
              isoyear++;
            }
          } else {
            week1 = ICAL2.Time.weekOneStarts(isoyear, aWeekStart);
            if (dt.compare(week1) < 0) {
              week1 = ICAL2.Time.weekOneStarts(--isoyear, aWeekStart);
            }
          }
          var daysBetween2 = dt.subtractDate(week1).toSeconds() / 86400;
          var answer = ICAL2.helpers.trunc(daysBetween2 / 7) + 1;
          ICAL2.Time._wnCache[wnCacheKey] = answer;
          return answer;
        },
        /**
         * Adds the duration to the current time. The instance is modified in
         * place.
         *
         * @param {ICAL.Duration} aDuration         The duration to add
         */
        addDuration: function icaltime_add(aDuration) {
          var mult = aDuration.isNegative ? -1 : 1;
          var second = this.second;
          var minute = this.minute;
          var hour = this.hour;
          var day = this.day;
          second += mult * aDuration.seconds;
          minute += mult * aDuration.minutes;
          hour += mult * aDuration.hours;
          day += mult * aDuration.days;
          day += mult * 7 * aDuration.weeks;
          this.second = second;
          this.minute = minute;
          this.hour = hour;
          this.day = day;
          this._cachedUnixTime = null;
        },
        /**
         * Subtract the date details (_excluding_ timezone).  Useful for finding
         * the relative difference between two time objects excluding their
         * timezone differences.
         *
         * @param {ICAL.Time} aDate     The date to substract
         * @return {ICAL.Duration}      The difference as a duration
         */
        subtractDate: function icaltime_subtract(aDate) {
          var unixTime = this.toUnixTime() + this.utcOffset();
          var other = aDate.toUnixTime() + aDate.utcOffset();
          return ICAL2.Duration.fromSeconds(unixTime - other);
        },
        /**
         * Subtract the date details, taking timezones into account.
         *
         * @param {ICAL.Time} aDate  The date to subtract
         * @return {ICAL.Duration}  The difference in duration
         */
        subtractDateTz: function icaltime_subtract_abs(aDate) {
          var unixTime = this.toUnixTime();
          var other = aDate.toUnixTime();
          return ICAL2.Duration.fromSeconds(unixTime - other);
        },
        /**
         * Compares the ICAL.Time instance with another one.
         *
         * @param {ICAL.Duration} aOther        The instance to compare with
         * @return {Number}                     -1, 0 or 1 for less/equal/greater
         */
        compare: function icaltime_compare(other) {
          var a3 = this.toUnixTime();
          var b3 = other.toUnixTime();
          if (a3 > b3)
            return 1;
          if (b3 > a3)
            return -1;
          return 0;
        },
        /**
         * Compares only the date part of this instance with another one.
         *
         * @param {ICAL.Duration} other         The instance to compare with
         * @param {ICAL.Timezone} tz            The timezone to compare in
         * @return {Number}                     -1, 0 or 1 for less/equal/greater
         */
        compareDateOnlyTz: function icaltime_compareDateOnlyTz(other, tz) {
          function cmp(attr) {
            return ICAL2.Time._cmp_attr(a3, b3, attr);
          }
          var a3 = this.convertToZone(tz);
          var b3 = other.convertToZone(tz);
          var rc = 0;
          if ((rc = cmp("year")) != 0)
            return rc;
          if ((rc = cmp("month")) != 0)
            return rc;
          if ((rc = cmp("day")) != 0)
            return rc;
          return rc;
        },
        /**
         * Convert the instance into another timezone. The returned ICAL.Time
         * instance is always a copy.
         *
         * @param {ICAL.Timezone} zone      The zone to convert to
         * @return {ICAL.Time}              The copy, converted to the zone
         */
        convertToZone: function convertToZone(zone) {
          var copy = this.clone();
          var zone_equals = this.zone.tzid == zone.tzid;
          if (!this.isDate && !zone_equals) {
            ICAL2.Timezone.convert_time(copy, this.zone, zone);
          }
          copy.zone = zone;
          return copy;
        },
        /**
         * Calculates the UTC offset of the current date/time in the timezone it is
         * in.
         *
         * @return {Number}     UTC offset in seconds
         */
        utcOffset: function utc_offset() {
          if (this.zone == ICAL2.Timezone.localTimezone || this.zone == ICAL2.Timezone.utcTimezone) {
            return 0;
          } else {
            return this.zone.utcOffset(this);
          }
        },
        /**
         * Returns an RFC 5545 compliant ical representation of this object.
         *
         * @return {String} ical date/date-time
         */
        toICALString: function() {
          var string = this.toString();
          if (string.length > 10) {
            return ICAL2.design.icalendar.value["date-time"].toICAL(string);
          } else {
            return ICAL2.design.icalendar.value.date.toICAL(string);
          }
        },
        /**
         * The string representation of this date/time, in jCal form
         * (including : and - separators).
         * @return {String}
         */
        toString: function toString() {
          var result = this.year + "-" + ICAL2.helpers.pad2(this.month) + "-" + ICAL2.helpers.pad2(this.day);
          if (!this.isDate) {
            result += "T" + ICAL2.helpers.pad2(this.hour) + ":" + ICAL2.helpers.pad2(this.minute) + ":" + ICAL2.helpers.pad2(this.second);
            if (this.zone === ICAL2.Timezone.utcTimezone) {
              result += "Z";
            }
          }
          return result;
        },
        /**
         * Converts the current instance to a Javascript date
         * @return {Date}
         */
        toJSDate: function toJSDate() {
          if (this.zone == ICAL2.Timezone.localTimezone) {
            if (this.isDate) {
              return new Date(this.year, this.month - 1, this.day);
            } else {
              return new Date(
                this.year,
                this.month - 1,
                this.day,
                this.hour,
                this.minute,
                this.second,
                0
              );
            }
          } else {
            return new Date(this.toUnixTime() * 1e3);
          }
        },
        _normalize: function icaltime_normalize() {
          var isDate2 = this._time.isDate;
          if (this._time.isDate) {
            this._time.hour = 0;
            this._time.minute = 0;
            this._time.second = 0;
          }
          this.adjust(0, 0, 0, 0);
          return this;
        },
        /**
         * Adjust the date/time by the given offset
         *
         * @param {Number} aExtraDays       The extra amount of days
         * @param {Number} aExtraHours      The extra amount of hours
         * @param {Number} aExtraMinutes    The extra amount of minutes
         * @param {Number} aExtraSeconds    The extra amount of seconds
         * @param {Number=} aTime           The time to adjust, defaults to the
         *                                    current instance.
         */
        adjust: function icaltime_adjust(aExtraDays, aExtraHours, aExtraMinutes, aExtraSeconds, aTime) {
          var minutesOverflow, hoursOverflow, daysOverflow = 0, yearsOverflow = 0;
          var second, minute, hour, day;
          var daysInMonth;
          var time = aTime || this._time;
          if (!time.isDate) {
            second = time.second + aExtraSeconds;
            time.second = second % 60;
            minutesOverflow = ICAL2.helpers.trunc(second / 60);
            if (time.second < 0) {
              time.second += 60;
              minutesOverflow--;
            }
            minute = time.minute + aExtraMinutes + minutesOverflow;
            time.minute = minute % 60;
            hoursOverflow = ICAL2.helpers.trunc(minute / 60);
            if (time.minute < 0) {
              time.minute += 60;
              hoursOverflow--;
            }
            hour = time.hour + aExtraHours + hoursOverflow;
            time.hour = hour % 24;
            daysOverflow = ICAL2.helpers.trunc(hour / 24);
            if (time.hour < 0) {
              time.hour += 24;
              daysOverflow--;
            }
          }
          if (time.month > 12) {
            yearsOverflow = ICAL2.helpers.trunc((time.month - 1) / 12);
          } else if (time.month < 1) {
            yearsOverflow = ICAL2.helpers.trunc(time.month / 12) - 1;
          }
          time.year += yearsOverflow;
          time.month -= 12 * yearsOverflow;
          day = time.day + aExtraDays + daysOverflow;
          if (day > 0) {
            for (; ; ) {
              daysInMonth = ICAL2.Time.daysInMonth(time.month, time.year);
              if (day <= daysInMonth) {
                break;
              }
              time.month++;
              if (time.month > 12) {
                time.year++;
                time.month = 1;
              }
              day -= daysInMonth;
            }
          } else {
            while (day <= 0) {
              if (time.month == 1) {
                time.year--;
                time.month = 12;
              } else {
                time.month--;
              }
              day += ICAL2.Time.daysInMonth(time.month, time.year);
            }
          }
          time.day = day;
          this._cachedUnixTime = null;
          return this;
        },
        /**
         * Sets up the current instance from unix time, the number of seconds since
         * January 1st, 1970.
         *
         * @param {Number} seconds      The seconds to set up with
         */
        fromUnixTime: function fromUnixTime(seconds) {
          this.zone = ICAL2.Timezone.utcTimezone;
          var epoch = ICAL2.Time.epochTime.clone();
          epoch.adjust(0, 0, 0, seconds);
          this.year = epoch.year;
          this.month = epoch.month;
          this.day = epoch.day;
          this.hour = epoch.hour;
          this.minute = epoch.minute;
          this.second = Math.floor(epoch.second);
          this._cachedUnixTime = null;
        },
        /**
         * Converts the current instance to seconds since January 1st 1970.
         *
         * @return {Number}         Seconds since 1970
         */
        toUnixTime: function toUnixTime() {
          if (this._cachedUnixTime !== null) {
            return this._cachedUnixTime;
          }
          var offset = this.utcOffset();
          var ms = Date.UTC(
            this.year,
            this.month - 1,
            this.day,
            this.hour,
            this.minute,
            this.second - offset
          );
          this._cachedUnixTime = ms / 1e3;
          return this._cachedUnixTime;
        },
        /**
         * Converts time to into Object which can be serialized then re-created
         * using the constructor.
         *
         * @example
         * // toJSON will automatically be called
         * var json = JSON.stringify(mytime);
         *
         * var deserialized = JSON.parse(json);
         *
         * var time = new ICAL.Time(deserialized);
         *
         * @return {Object}
         */
        toJSON: function() {
          var copy = [
            "year",
            "month",
            "day",
            "hour",
            "minute",
            "second",
            "isDate"
          ];
          var result = /* @__PURE__ */ Object.create(null);
          var i3 = 0;
          var len = copy.length;
          var prop;
          for (; i3 < len; i3++) {
            prop = copy[i3];
            result[prop] = this[prop];
          }
          if (this.zone) {
            result.timezone = this.zone.tzid;
          }
          return result;
        }
      };
      (function setupNormalizeAttributes() {
        function defineAttr(attr) {
          Object.defineProperty(ICAL2.Time.prototype, attr, {
            get: function getTimeAttr() {
              if (this._pendingNormalization) {
                this._normalize();
                this._pendingNormalization = false;
              }
              return this._time[attr];
            },
            set: function setTimeAttr(val) {
              if (attr === "isDate" && val && !this._time.isDate) {
                this.adjust(0, 0, 0, 0);
              }
              this._cachedUnixTime = null;
              this._pendingNormalization = true;
              this._time[attr] = val;
              return val;
            }
          });
        }
        if ("defineProperty" in Object) {
          defineAttr("year");
          defineAttr("month");
          defineAttr("day");
          defineAttr("hour");
          defineAttr("minute");
          defineAttr("second");
          defineAttr("isDate");
        }
      })();
      ICAL2.Time.daysInMonth = function icaltime_daysInMonth(month, year) {
        var _daysInMonth = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        var days = 30;
        if (month < 1 || month > 12)
          return days;
        days = _daysInMonth[month];
        if (month == 2) {
          days += ICAL2.Time.isLeapYear(year);
        }
        return days;
      };
      ICAL2.Time.isLeapYear = function isLeapYear2(year) {
        if (year <= 1752) {
          return year % 4 == 0;
        } else {
          return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
        }
      };
      ICAL2.Time.fromDayOfYear = function icaltime_fromDayOfYear(aDayOfYear, aYear) {
        var year = aYear;
        var doy = aDayOfYear;
        var tt = new ICAL2.Time();
        tt.auto_normalize = false;
        var is_leap = ICAL2.Time.isLeapYear(year) ? 1 : 0;
        if (doy < 1) {
          year--;
          is_leap = ICAL2.Time.isLeapYear(year) ? 1 : 0;
          doy += ICAL2.Time.daysInYearPassedMonth[is_leap][12];
          return ICAL2.Time.fromDayOfYear(doy, year);
        } else if (doy > ICAL2.Time.daysInYearPassedMonth[is_leap][12]) {
          is_leap = ICAL2.Time.isLeapYear(year) ? 1 : 0;
          doy -= ICAL2.Time.daysInYearPassedMonth[is_leap][12];
          year++;
          return ICAL2.Time.fromDayOfYear(doy, year);
        }
        tt.year = year;
        tt.isDate = true;
        for (var month = 11; month >= 0; month--) {
          if (doy > ICAL2.Time.daysInYearPassedMonth[is_leap][month]) {
            tt.month = month + 1;
            tt.day = doy - ICAL2.Time.daysInYearPassedMonth[is_leap][month];
            break;
          }
        }
        tt.auto_normalize = true;
        return tt;
      };
      ICAL2.Time.fromStringv2 = function fromString(str) {
        return new ICAL2.Time({
          year: parseInt(str.substr(0, 4), 10),
          month: parseInt(str.substr(5, 2), 10),
          day: parseInt(str.substr(8, 2), 10),
          isDate: true
        });
      };
      ICAL2.Time.fromDateString = function(aValue) {
        return new ICAL2.Time({
          year: ICAL2.helpers.strictParseInt(aValue.substr(0, 4)),
          month: ICAL2.helpers.strictParseInt(aValue.substr(5, 2)),
          day: ICAL2.helpers.strictParseInt(aValue.substr(8, 2)),
          isDate: true
        });
      };
      ICAL2.Time.fromDateTimeString = function(aValue, prop) {
        if (aValue.length < 19) {
          throw new Error(
            'invalid date-time value: "' + aValue + '"'
          );
        }
        var zone;
        if (aValue[19] && aValue[19] === "Z") {
          zone = "Z";
        } else if (prop) {
          zone = prop.getParameter("tzid");
        }
        var time = new ICAL2.Time({
          year: ICAL2.helpers.strictParseInt(aValue.substr(0, 4)),
          month: ICAL2.helpers.strictParseInt(aValue.substr(5, 2)),
          day: ICAL2.helpers.strictParseInt(aValue.substr(8, 2)),
          hour: ICAL2.helpers.strictParseInt(aValue.substr(11, 2)),
          minute: ICAL2.helpers.strictParseInt(aValue.substr(14, 2)),
          second: ICAL2.helpers.strictParseInt(aValue.substr(17, 2)),
          timezone: zone
        });
        return time;
      };
      ICAL2.Time.fromString = function fromString(aValue, aProperty) {
        if (aValue.length > 10) {
          return ICAL2.Time.fromDateTimeString(aValue, aProperty);
        } else {
          return ICAL2.Time.fromDateString(aValue);
        }
      };
      ICAL2.Time.fromJSDate = function fromJSDate(aDate, useUTC) {
        var tt = new ICAL2.Time();
        return tt.fromJSDate(aDate, useUTC);
      };
      ICAL2.Time.fromData = function fromData(aData, aZone) {
        var t3 = new ICAL2.Time();
        return t3.fromData(aData, aZone);
      };
      ICAL2.Time.now = function icaltime_now() {
        return ICAL2.Time.fromJSDate(new Date(), false);
      };
      ICAL2.Time.weekOneStarts = function weekOneStarts(aYear, aWeekStart) {
        var t3 = ICAL2.Time.fromData({
          year: aYear,
          month: 1,
          day: 1,
          isDate: true
        });
        var dow = t3.dayOfWeek();
        var wkst = aWeekStart || ICAL2.Time.DEFAULT_WEEK_START;
        if (dow > ICAL2.Time.THURSDAY) {
          t3.day += 7;
        }
        if (wkst > ICAL2.Time.THURSDAY) {
          t3.day -= 7;
        }
        t3.day -= dow - wkst;
        return t3;
      };
      ICAL2.Time.getDominicalLetter = function(yr) {
        var LTRS = "GFEDCBA";
        var dom = (yr + (yr / 4 | 0) + (yr / 400 | 0) - (yr / 100 | 0) - 1) % 7;
        var isLeap = ICAL2.Time.isLeapYear(yr);
        if (isLeap) {
          return LTRS[(dom + 6) % 7] + LTRS[dom];
        } else {
          return LTRS[dom];
        }
      };
      ICAL2.Time.epochTime = ICAL2.Time.fromData({
        year: 1970,
        month: 1,
        day: 1,
        hour: 0,
        minute: 0,
        second: 0,
        isDate: false,
        timezone: "Z"
      });
      ICAL2.Time._cmp_attr = function _cmp_attr(a3, b3, attr) {
        if (a3[attr] > b3[attr])
          return 1;
        if (a3[attr] < b3[attr])
          return -1;
        return 0;
      };
      ICAL2.Time.daysInYearPassedMonth = [
        [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365],
        [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366]
      ];
      ICAL2.Time.SUNDAY = 1;
      ICAL2.Time.MONDAY = 2;
      ICAL2.Time.TUESDAY = 3;
      ICAL2.Time.WEDNESDAY = 4;
      ICAL2.Time.THURSDAY = 5;
      ICAL2.Time.FRIDAY = 6;
      ICAL2.Time.SATURDAY = 7;
      ICAL2.Time.DEFAULT_WEEK_START = ICAL2.Time.MONDAY;
    })();
    (function() {
      ICAL2.VCardTime = function(data, zone, icaltype) {
        this.wrappedJSObject = this;
        var time = this._time = /* @__PURE__ */ Object.create(null);
        time.year = null;
        time.month = null;
        time.day = null;
        time.hour = null;
        time.minute = null;
        time.second = null;
        this.icaltype = icaltype || "date-and-or-time";
        this.fromData(data, zone);
      };
      ICAL2.helpers.inherits(
        ICAL2.Time,
        ICAL2.VCardTime,
        /** @lends ICAL.VCardTime */
        {
          /**
           * The class identifier.
           * @constant
           * @type {String}
           * @default "vcardtime"
           */
          icalclass: "vcardtime",
          /**
           * The type name, to be used in the jCal object.
           * @type {String}
           * @default "date-and-or-time"
           */
          icaltype: "date-and-or-time",
          /**
           * The timezone. This can either be floating, UTC, or an instance of
           * ICAL.UtcOffset.
           * @type {ICAL.Timezone|ICAL.UtcOFfset}
           */
          zone: null,
          /**
           * Returns a clone of the vcard date/time object.
           *
           * @return {ICAL.VCardTime}     The cloned object
           */
          clone: function() {
            return new ICAL2.VCardTime(this._time, this.zone, this.icaltype);
          },
          _normalize: function() {
            return this;
          },
          /**
           * @inheritdoc
           */
          utcOffset: function() {
            if (this.zone instanceof ICAL2.UtcOffset) {
              return this.zone.toSeconds();
            } else {
              return ICAL2.Time.prototype.utcOffset.apply(this, arguments);
            }
          },
          /**
           * Returns an RFC 6350 compliant representation of this object.
           *
           * @return {String}         vcard date/time string
           */
          toICALString: function() {
            return ICAL2.design.vcard.value[this.icaltype].toICAL(this.toString());
          },
          /**
           * The string representation of this date/time, in jCard form
           * (including : and - separators).
           * @return {String}
           */
          toString: function toString() {
            var p22 = ICAL2.helpers.pad2;
            var y3 = this.year, m3 = this.month, d2 = this.day;
            var h3 = this.hour, mm = this.minute, s3 = this.second;
            var hasYear = y3 !== null, hasMonth = m3 !== null, hasDay = d2 !== null;
            var hasHour = h3 !== null, hasMinute = mm !== null, hasSecond = s3 !== null;
            var datepart = (hasYear ? p22(y3) + (hasMonth || hasDay ? "-" : "") : hasMonth || hasDay ? "--" : "") + (hasMonth ? p22(m3) : "") + (hasDay ? "-" + p22(d2) : "");
            var timepart = (hasHour ? p22(h3) : "-") + (hasHour && hasMinute ? ":" : "") + (hasMinute ? p22(mm) : "") + (!hasHour && !hasMinute ? "-" : "") + (hasMinute && hasSecond ? ":" : "") + (hasSecond ? p22(s3) : "");
            var zone;
            if (this.zone === ICAL2.Timezone.utcTimezone) {
              zone = "Z";
            } else if (this.zone instanceof ICAL2.UtcOffset) {
              zone = this.zone.toString();
            } else if (this.zone === ICAL2.Timezone.localTimezone) {
              zone = "";
            } else if (this.zone instanceof ICAL2.Timezone) {
              var offset = ICAL2.UtcOffset.fromSeconds(this.zone.utcOffset(this));
              zone = offset.toString();
            } else {
              zone = "";
            }
            switch (this.icaltype) {
              case "time":
                return timepart + zone;
              case "date-and-or-time":
              case "date-time":
                return datepart + (timepart == "--" ? "" : "T" + timepart + zone);
              case "date":
                return datepart;
            }
            return null;
          }
        }
      );
      ICAL2.VCardTime.fromDateAndOrTimeString = function(aValue, aIcalType) {
        function part(v3, s3, e3) {
          return v3 ? ICAL2.helpers.strictParseInt(v3.substr(s3, e3)) : null;
        }
        var parts = aValue.split("T");
        var dt = parts[0], tmz = parts[1];
        var splitzone = tmz ? ICAL2.design.vcard.value.time._splitZone(tmz) : [];
        var zone = splitzone[0], tm = splitzone[1];
        var stoi = ICAL2.helpers.strictParseInt;
        var dtlen = dt ? dt.length : 0;
        var tmlen = tm ? tm.length : 0;
        var hasDashDate = dt && dt[0] == "-" && dt[1] == "-";
        var hasDashTime = tm && tm[0] == "-";
        var o2 = {
          year: hasDashDate ? null : part(dt, 0, 4),
          month: hasDashDate && (dtlen == 4 || dtlen == 7) ? part(dt, 2, 2) : dtlen == 7 ? part(dt, 5, 2) : dtlen == 10 ? part(dt, 5, 2) : null,
          day: dtlen == 5 ? part(dt, 3, 2) : dtlen == 7 && hasDashDate ? part(dt, 5, 2) : dtlen == 10 ? part(dt, 8, 2) : null,
          hour: hasDashTime ? null : part(tm, 0, 2),
          minute: hasDashTime && tmlen == 3 ? part(tm, 1, 2) : tmlen > 4 ? hasDashTime ? part(tm, 1, 2) : part(tm, 3, 2) : null,
          second: tmlen == 4 ? part(tm, 2, 2) : tmlen == 6 ? part(tm, 4, 2) : tmlen == 8 ? part(tm, 6, 2) : null
        };
        if (zone == "Z") {
          zone = ICAL2.Timezone.utcTimezone;
        } else if (zone && zone[3] == ":") {
          zone = ICAL2.UtcOffset.fromString(zone);
        } else {
          zone = null;
        }
        return new ICAL2.VCardTime(o2, zone, aIcalType);
      };
    })();
    (function() {
      var DOW_MAP = {
        SU: ICAL2.Time.SUNDAY,
        MO: ICAL2.Time.MONDAY,
        TU: ICAL2.Time.TUESDAY,
        WE: ICAL2.Time.WEDNESDAY,
        TH: ICAL2.Time.THURSDAY,
        FR: ICAL2.Time.FRIDAY,
        SA: ICAL2.Time.SATURDAY
      };
      var REVERSE_DOW_MAP = {};
      for (var key in DOW_MAP) {
        if (DOW_MAP.hasOwnProperty(key)) {
          REVERSE_DOW_MAP[DOW_MAP[key]] = key;
        }
      }
      var COPY_PARTS = [
        "BYSECOND",
        "BYMINUTE",
        "BYHOUR",
        "BYDAY",
        "BYMONTHDAY",
        "BYYEARDAY",
        "BYWEEKNO",
        "BYMONTH",
        "BYSETPOS"
      ];
      ICAL2.Recur = function icalrecur(data) {
        this.wrappedJSObject = this;
        this.parts = {};
        if (data && typeof data === "object") {
          this.fromData(data);
        }
      };
      ICAL2.Recur.prototype = {
        /**
         * An object holding the BY-parts of the recurrence rule
         * @type {Object}
         */
        parts: null,
        /**
         * The interval value for the recurrence rule.
         * @type {Number}
         */
        interval: 1,
        /**
         * The week start day
         *
         * @type {ICAL.Time.weekDay}
         * @default ICAL.Time.MONDAY
         */
        wkst: ICAL2.Time.MONDAY,
        /**
         * The end of the recurrence
         * @type {?ICAL.Time}
         */
        until: null,
        /**
         * The maximum number of occurrences
         * @type {?Number}
         */
        count: null,
        /**
         * The frequency value.
         * @type {ICAL.Recur.frequencyValues}
         */
        freq: null,
        /**
         * The class identifier.
         * @constant
         * @type {String}
         * @default "icalrecur"
         */
        icalclass: "icalrecur",
        /**
         * The type name, to be used in the jCal object.
         * @constant
         * @type {String}
         * @default "recur"
         */
        icaltype: "recur",
        /**
         * Create a new iterator for this recurrence rule. The passed start date
         * must be the start date of the event, not the start of the range to
         * search in.
         *
         * @example
         * var recur = comp.getFirstPropertyValue('rrule');
         * var dtstart = comp.getFirstPropertyValue('dtstart');
         * var iter = recur.iterator(dtstart);
         * for (var next = iter.next(); next; next = iter.next()) {
         *   if (next.compare(rangeStart) < 0) {
         *     continue;
         *   }
         *   console.log(next.toString());
         * }
         *
         * @param {ICAL.Time} aStart        The item's start date
         * @return {ICAL.RecurIterator}     The recurrence iterator
         */
        iterator: function(aStart) {
          return new ICAL2.RecurIterator({
            rule: this,
            dtstart: aStart
          });
        },
        /**
         * Returns a clone of the recurrence object.
         *
         * @return {ICAL.Recur}      The cloned object
         */
        clone: function clone2() {
          return new ICAL2.Recur(this.toJSON());
        },
        /**
         * Checks if the current rule is finite, i.e. has a count or until part.
         *
         * @return {Boolean}        True, if the rule is finite
         */
        isFinite: function isfinite() {
          return !!(this.count || this.until);
        },
        /**
         * Checks if the current rule has a count part, and not limited by an until
         * part.
         *
         * @return {Boolean}        True, if the rule is by count
         */
        isByCount: function isbycount() {
          return !!(this.count && !this.until);
        },
        /**
         * Adds a component (part) to the recurrence rule. This is not a component
         * in the sense of {@link ICAL.Component}, but a part of the recurrence
         * rule, i.e. BYMONTH.
         *
         * @param {String} aType            The name of the component part
         * @param {Array|String} aValue     The component value
         */
        addComponent: function addPart(aType, aValue) {
          var ucname = aType.toUpperCase();
          if (ucname in this.parts) {
            this.parts[ucname].push(aValue);
          } else {
            this.parts[ucname] = [aValue];
          }
        },
        /**
         * Sets the component value for the given by-part.
         *
         * @param {String} aType        The component part name
         * @param {Array} aValues       The component values
         */
        setComponent: function setComponent(aType, aValues) {
          this.parts[aType.toUpperCase()] = aValues.slice();
        },
        /**
         * Gets (a copy) of the requested component value.
         *
         * @param {String} aType        The component part name
         * @return {Array}              The component part value
         */
        getComponent: function getComponent(aType) {
          var ucname = aType.toUpperCase();
          return ucname in this.parts ? this.parts[ucname].slice() : [];
        },
        /**
         * Retrieves the next occurrence after the given recurrence id. See the
         * guide on {@tutorial terminology} for more details.
         *
         * NOTE: Currently, this method iterates all occurrences from the start
         * date. It should not be called in a loop for performance reasons. If you
         * would like to get more than one occurrence, you can iterate the
         * occurrences manually, see the example on the
         * {@link ICAL.Recur#iterator iterator} method.
         *
         * @param {ICAL.Time} aStartTime        The start of the event series
         * @param {ICAL.Time} aRecurrenceId     The date of the last occurrence
         * @return {ICAL.Time}                  The next occurrence after
         */
        getNextOccurrence: function getNextOccurrence(aStartTime, aRecurrenceId) {
          var iter2 = this.iterator(aStartTime);
          var next, cdt;
          do {
            next = iter2.next();
          } while (next && next.compare(aRecurrenceId) <= 0);
          if (next && aRecurrenceId.zone) {
            next.zone = aRecurrenceId.zone;
          }
          return next;
        },
        /**
         * Sets up the current instance using members from the passed data object.
         *
         * @param {Object} data                               An object with members of the recurrence
         * @param {ICAL.Recur.frequencyValues=} data.freq     The frequency value
         * @param {Number=} data.interval                     The INTERVAL value
         * @param {ICAL.Time.weekDay=} data.wkst              The week start value
         * @param {ICAL.Time=} data.until                     The end of the recurrence set
         * @param {Number=} data.count                        The number of occurrences
         * @param {Array.<Number>=} data.bysecond             The seconds for the BYSECOND part
         * @param {Array.<Number>=} data.byminute             The minutes for the BYMINUTE part
         * @param {Array.<Number>=} data.byhour               The hours for the BYHOUR part
         * @param {Array.<String>=} data.byday                The BYDAY values
         * @param {Array.<Number>=} data.bymonthday           The days for the BYMONTHDAY part
         * @param {Array.<Number>=} data.byyearday            The days for the BYYEARDAY part
         * @param {Array.<Number>=} data.byweekno             The weeks for the BYWEEKNO part
         * @param {Array.<Number>=} data.bymonth              The month for the BYMONTH part
         * @param {Array.<Number>=} data.bysetpos             The positionals for the BYSETPOS part
         */
        fromData: function(data) {
          for (var key2 in data) {
            var uckey = key2.toUpperCase();
            if (uckey in partDesign) {
              if (Array.isArray(data[key2])) {
                this.parts[uckey] = data[key2];
              } else {
                this.parts[uckey] = [data[key2]];
              }
            } else {
              this[key2] = data[key2];
            }
          }
          if (this.interval && typeof this.interval != "number") {
            optionDesign.INTERVAL(this.interval, this);
          }
          if (this.wkst && typeof this.wkst != "number") {
            this.wkst = ICAL2.Recur.icalDayToNumericDay(this.wkst);
          }
          if (this.until && !(this.until instanceof ICAL2.Time)) {
            this.until = ICAL2.Time.fromString(this.until);
          }
        },
        /**
         * The jCal representation of this recurrence type.
         * @return {Object}
         */
        toJSON: function() {
          var res = /* @__PURE__ */ Object.create(null);
          res.freq = this.freq;
          if (this.count) {
            res.count = this.count;
          }
          if (this.interval > 1) {
            res.interval = this.interval;
          }
          for (var k3 in this.parts) {
            if (!this.parts.hasOwnProperty(k3)) {
              continue;
            }
            var kparts = this.parts[k3];
            if (Array.isArray(kparts) && kparts.length == 1) {
              res[k3.toLowerCase()] = kparts[0];
            } else {
              res[k3.toLowerCase()] = ICAL2.helpers.clone(this.parts[k3]);
            }
          }
          if (this.until) {
            res.until = this.until.toString();
          }
          if ("wkst" in this && this.wkst !== ICAL2.Time.DEFAULT_WEEK_START) {
            res.wkst = ICAL2.Recur.numericDayToIcalDay(this.wkst);
          }
          return res;
        },
        /**
         * The string representation of this recurrence rule.
         * @return {String}
         */
        toString: function icalrecur_toString() {
          var str = "FREQ=" + this.freq;
          if (this.count) {
            str += ";COUNT=" + this.count;
          }
          if (this.interval > 1) {
            str += ";INTERVAL=" + this.interval;
          }
          for (var k3 in this.parts) {
            if (this.parts.hasOwnProperty(k3)) {
              str += ";" + k3 + "=" + this.parts[k3];
            }
          }
          if (this.until) {
            str += ";UNTIL=" + this.until.toICALString();
          }
          if ("wkst" in this && this.wkst !== ICAL2.Time.DEFAULT_WEEK_START) {
            str += ";WKST=" + ICAL2.Recur.numericDayToIcalDay(this.wkst);
          }
          return str;
        }
      };
      function parseNumericValue(type, min, max, value) {
        var result = value;
        if (value[0] === "+") {
          result = value.substr(1);
        }
        result = ICAL2.helpers.strictParseInt(result);
        if (min !== void 0 && value < min) {
          throw new Error(
            type + ': invalid value "' + value + '" must be > ' + min
          );
        }
        if (max !== void 0 && value > max) {
          throw new Error(
            type + ': invalid value "' + value + '" must be < ' + min
          );
        }
        return result;
      }
      ICAL2.Recur.icalDayToNumericDay = function toNumericDay(string, aWeekStart) {
        var firstDow = aWeekStart || ICAL2.Time.SUNDAY;
        return (DOW_MAP[string] - firstDow + 7) % 7 + 1;
      };
      ICAL2.Recur.numericDayToIcalDay = function toIcalDay(num, aWeekStart) {
        var firstDow = aWeekStart || ICAL2.Time.SUNDAY;
        var dow = num + firstDow - ICAL2.Time.SUNDAY;
        if (dow > 7) {
          dow -= 7;
        }
        return REVERSE_DOW_MAP[dow];
      };
      var VALID_DAY_NAMES = /^(SU|MO|TU|WE|TH|FR|SA)$/;
      var VALID_BYDAY_PART = /^([+-])?(5[0-3]|[1-4][0-9]|[1-9])?(SU|MO|TU|WE|TH|FR|SA)$/;
      var ALLOWED_FREQ = [
        "SECONDLY",
        "MINUTELY",
        "HOURLY",
        "DAILY",
        "WEEKLY",
        "MONTHLY",
        "YEARLY"
      ];
      var optionDesign = {
        FREQ: function(value, dict, fmtIcal) {
          if (ALLOWED_FREQ.indexOf(value) !== -1) {
            dict.freq = value;
          } else {
            throw new Error(
              'invalid frequency "' + value + '" expected: "' + ALLOWED_FREQ.join(", ") + '"'
            );
          }
        },
        COUNT: function(value, dict, fmtIcal) {
          dict.count = ICAL2.helpers.strictParseInt(value);
        },
        INTERVAL: function(value, dict, fmtIcal) {
          dict.interval = ICAL2.helpers.strictParseInt(value);
          if (dict.interval < 1) {
            dict.interval = 1;
          }
        },
        UNTIL: function(value, dict, fmtIcal) {
          if (value.length > 10) {
            dict.until = ICAL2.design.icalendar.value["date-time"].fromICAL(value);
          } else {
            dict.until = ICAL2.design.icalendar.value.date.fromICAL(value);
          }
          if (!fmtIcal) {
            dict.until = ICAL2.Time.fromString(dict.until);
          }
        },
        WKST: function(value, dict, fmtIcal) {
          if (VALID_DAY_NAMES.test(value)) {
            dict.wkst = ICAL2.Recur.icalDayToNumericDay(value);
          } else {
            throw new Error('invalid WKST value "' + value + '"');
          }
        }
      };
      var partDesign = {
        BYSECOND: parseNumericValue.bind(this, "BYSECOND", 0, 60),
        BYMINUTE: parseNumericValue.bind(this, "BYMINUTE", 0, 59),
        BYHOUR: parseNumericValue.bind(this, "BYHOUR", 0, 23),
        BYDAY: function(value) {
          if (VALID_BYDAY_PART.test(value)) {
            return value;
          } else {
            throw new Error('invalid BYDAY value "' + value + '"');
          }
        },
        BYMONTHDAY: parseNumericValue.bind(this, "BYMONTHDAY", -31, 31),
        BYYEARDAY: parseNumericValue.bind(this, "BYYEARDAY", -366, 366),
        BYWEEKNO: parseNumericValue.bind(this, "BYWEEKNO", -53, 53),
        BYMONTH: parseNumericValue.bind(this, "BYMONTH", 1, 12),
        BYSETPOS: parseNumericValue.bind(this, "BYSETPOS", -366, 366)
      };
      ICAL2.Recur.fromString = function(string) {
        var data = ICAL2.Recur._stringToData(string, false);
        return new ICAL2.Recur(data);
      };
      ICAL2.Recur.fromData = function(aData) {
        return new ICAL2.Recur(aData);
      };
      ICAL2.Recur._stringToData = function(string, fmtIcal) {
        var dict = /* @__PURE__ */ Object.create(null);
        var values = string.split(";");
        var len = values.length;
        for (var i3 = 0; i3 < len; i3++) {
          var parts = values[i3].split("=");
          var ucname = parts[0].toUpperCase();
          var lcname = parts[0].toLowerCase();
          var name = fmtIcal ? lcname : ucname;
          var value = parts[1];
          if (ucname in partDesign) {
            var partArr = value.split(",");
            var partArrIdx = 0;
            var partArrLen = partArr.length;
            for (; partArrIdx < partArrLen; partArrIdx++) {
              partArr[partArrIdx] = partDesign[ucname](partArr[partArrIdx]);
            }
            dict[name] = partArr.length == 1 ? partArr[0] : partArr;
          } else if (ucname in optionDesign) {
            optionDesign[ucname](value, dict, fmtIcal);
          } else {
            dict[lcname] = value;
          }
        }
        return dict;
      };
    })();
    ICAL2.RecurIterator = function() {
      function icalrecur_iterator(options) {
        this.fromData(options);
      }
      icalrecur_iterator.prototype = {
        /**
         * True when iteration is finished.
         * @type {Boolean}
         */
        completed: false,
        /**
         * The rule that is being iterated
         * @type {ICAL.Recur}
         */
        rule: null,
        /**
         * The start date of the event being iterated.
         * @type {ICAL.Time}
         */
        dtstart: null,
        /**
         * The last occurrence that was returned from the
         * {@link ICAL.RecurIterator#next} method.
         * @type {ICAL.Time}
         */
        last: null,
        /**
         * The sequence number from the occurrence
         * @type {Number}
         */
        occurrence_number: 0,
        /**
         * The indices used for the {@link ICAL.RecurIterator#by_data} object.
         * @type {Object}
         * @private
         */
        by_indices: null,
        /**
         * If true, the iterator has already been initialized
         * @type {Boolean}
         * @private
         */
        initialized: false,
        /**
         * The initializd by-data.
         * @type {Object}
         * @private
         */
        by_data: null,
        /**
         * The expanded yeardays
         * @type {Array}
         * @private
         */
        days: null,
        /**
         * The index in the {@link ICAL.RecurIterator#days} array.
         * @type {Number}
         * @private
         */
        days_index: 0,
        /**
         * Initialize the recurrence iterator from the passed data object. This
         * method is usually not called directly, you can initialize the iterator
         * through the constructor.
         *
         * @param {Object} options                The iterator options
         * @param {ICAL.Recur} options.rule       The rule to iterate.
         * @param {ICAL.Time} options.dtstart     The start date of the event.
         * @param {Boolean=} options.initialized  When true, assume that options are
         *        from a previously constructed iterator. Initialization will not be
         *        repeated.
         */
        fromData: function(options) {
          this.rule = ICAL2.helpers.formatClassType(options.rule, ICAL2.Recur);
          if (!this.rule) {
            throw new Error("iterator requires a (ICAL.Recur) rule");
          }
          this.dtstart = ICAL2.helpers.formatClassType(options.dtstart, ICAL2.Time);
          if (!this.dtstart) {
            throw new Error("iterator requires a (ICAL.Time) dtstart");
          }
          if (options.by_data) {
            this.by_data = options.by_data;
          } else {
            this.by_data = ICAL2.helpers.clone(this.rule.parts, true);
          }
          if (options.occurrence_number)
            this.occurrence_number = options.occurrence_number;
          this.days = options.days || [];
          if (options.last) {
            this.last = ICAL2.helpers.formatClassType(options.last, ICAL2.Time);
          }
          this.by_indices = options.by_indices;
          if (!this.by_indices) {
            this.by_indices = {
              "BYSECOND": 0,
              "BYMINUTE": 0,
              "BYHOUR": 0,
              "BYDAY": 0,
              "BYMONTH": 0,
              "BYWEEKNO": 0,
              "BYMONTHDAY": 0
            };
          }
          this.initialized = options.initialized || false;
          if (!this.initialized) {
            this.init();
          }
        },
        /**
         * Intialize the iterator
         * @private
         */
        init: function icalrecur_iterator_init() {
          this.initialized = true;
          this.last = this.dtstart.clone();
          var parts = this.by_data;
          if ("BYDAY" in parts) {
            this.sort_byday_rules(parts.BYDAY);
          }
          if ("BYYEARDAY" in parts) {
            if ("BYMONTH" in parts || "BYWEEKNO" in parts || "BYMONTHDAY" in parts || "BYDAY" in parts) {
              throw new Error("Invalid BYYEARDAY rule");
            }
          }
          if ("BYWEEKNO" in parts && "BYMONTHDAY" in parts) {
            throw new Error("BYWEEKNO does not fit to BYMONTHDAY");
          }
          if (this.rule.freq == "MONTHLY" && ("BYYEARDAY" in parts || "BYWEEKNO" in parts)) {
            throw new Error("For MONTHLY recurrences neither BYYEARDAY nor BYWEEKNO may appear");
          }
          if (this.rule.freq == "WEEKLY" && ("BYYEARDAY" in parts || "BYMONTHDAY" in parts)) {
            throw new Error("For WEEKLY recurrences neither BYMONTHDAY nor BYYEARDAY may appear");
          }
          if (this.rule.freq != "YEARLY" && "BYYEARDAY" in parts) {
            throw new Error("BYYEARDAY may only appear in YEARLY rules");
          }
          this.last.second = this.setup_defaults("BYSECOND", "SECONDLY", this.dtstart.second);
          this.last.minute = this.setup_defaults("BYMINUTE", "MINUTELY", this.dtstart.minute);
          this.last.hour = this.setup_defaults("BYHOUR", "HOURLY", this.dtstart.hour);
          this.last.day = this.setup_defaults("BYMONTHDAY", "DAILY", this.dtstart.day);
          this.last.month = this.setup_defaults("BYMONTH", "MONTHLY", this.dtstart.month);
          if (this.rule.freq == "WEEKLY") {
            if ("BYDAY" in parts) {
              var bydayParts = this.ruleDayOfWeek(parts.BYDAY[0], this.rule.wkst);
              var pos = bydayParts[0];
              var dow = bydayParts[1];
              var wkdy = dow - this.last.dayOfWeek(this.rule.wkst);
              if (this.last.dayOfWeek(this.rule.wkst) < dow && wkdy >= 0 || wkdy < 0) {
                this.last.day += wkdy;
              }
            } else {
              var dayName = ICAL2.Recur.numericDayToIcalDay(this.dtstart.dayOfWeek());
              parts.BYDAY = [dayName];
            }
          }
          if (this.rule.freq == "YEARLY") {
            for (; ; ) {
              this.expand_year_days(this.last.year);
              if (this.days.length > 0) {
                break;
              }
              this.increment_year(this.rule.interval);
            }
            this._nextByYearDay();
          }
          if (this.rule.freq == "MONTHLY" && this.has_by_data("BYDAY")) {
            var tempLast = null;
            var initLast = this.last.clone();
            var daysInMonth = ICAL2.Time.daysInMonth(this.last.month, this.last.year);
            for (var i3 in this.by_data.BYDAY) {
              if (!this.by_data.BYDAY.hasOwnProperty(i3)) {
                continue;
              }
              this.last = initLast.clone();
              var bydayParts = this.ruleDayOfWeek(this.by_data.BYDAY[i3]);
              var pos = bydayParts[0];
              var dow = bydayParts[1];
              var dayOfMonth = this.last.nthWeekDay(dow, pos);
              if (pos >= 6 || pos <= -6) {
                throw new Error("Malformed values in BYDAY part");
              }
              if (dayOfMonth > daysInMonth || dayOfMonth <= 0) {
                if (tempLast && tempLast.month == initLast.month) {
                  continue;
                }
                while (dayOfMonth > daysInMonth || dayOfMonth <= 0) {
                  this.increment_month();
                  daysInMonth = ICAL2.Time.daysInMonth(this.last.month, this.last.year);
                  dayOfMonth = this.last.nthWeekDay(dow, pos);
                }
              }
              this.last.day = dayOfMonth;
              if (!tempLast || this.last.compare(tempLast) < 0) {
                tempLast = this.last.clone();
              }
            }
            this.last = tempLast.clone();
            if (this.has_by_data("BYMONTHDAY")) {
              this._byDayAndMonthDay(true);
            }
            if (this.last.day > daysInMonth || this.last.day == 0) {
              throw new Error("Malformed values in BYDAY part");
            }
          } else if (this.has_by_data("BYMONTHDAY")) {
            if (this.last.day < 0) {
              var daysInMonth = ICAL2.Time.daysInMonth(this.last.month, this.last.year);
              this.last.day = daysInMonth + this.last.day + 1;
            }
          }
        },
        /**
         * Retrieve the next occurrence from the iterator.
         * @return {ICAL.Time}
         */
        next: function icalrecur_iterator_next() {
          var before = this.last ? this.last.clone() : null;
          if (this.rule.count && this.occurrence_number >= this.rule.count || this.rule.until && this.last.compare(this.rule.until) > 0) {
            this.completed = true;
            return null;
          }
          if (this.occurrence_number == 0 && this.last.compare(this.dtstart) >= 0) {
            this.occurrence_number++;
            return this.last;
          }
          var valid;
          do {
            valid = 1;
            switch (this.rule.freq) {
              case "SECONDLY":
                this.next_second();
                break;
              case "MINUTELY":
                this.next_minute();
                break;
              case "HOURLY":
                this.next_hour();
                break;
              case "DAILY":
                this.next_day();
                break;
              case "WEEKLY":
                this.next_week();
                break;
              case "MONTHLY":
                valid = this.next_month();
                break;
              case "YEARLY":
                this.next_year();
                break;
              default:
                return null;
            }
          } while (!this.check_contracting_rules() || this.last.compare(this.dtstart) < 0 || !valid);
          if (this.last.compare(before) == 0) {
            throw new Error("Same occurrence found twice, protecting you from death by recursion");
          }
          if (this.rule.until && this.last.compare(this.rule.until) > 0) {
            this.completed = true;
            return null;
          } else {
            this.occurrence_number++;
            return this.last;
          }
        },
        next_second: function next_second() {
          return this.next_generic("BYSECOND", "SECONDLY", "second", "minute");
        },
        increment_second: function increment_second(inc) {
          return this.increment_generic(inc, "second", 60, "minute");
        },
        next_minute: function next_minute() {
          return this.next_generic(
            "BYMINUTE",
            "MINUTELY",
            "minute",
            "hour",
            "next_second"
          );
        },
        increment_minute: function increment_minute(inc) {
          return this.increment_generic(inc, "minute", 60, "hour");
        },
        next_hour: function next_hour() {
          return this.next_generic(
            "BYHOUR",
            "HOURLY",
            "hour",
            "monthday",
            "next_minute"
          );
        },
        increment_hour: function increment_hour(inc) {
          this.increment_generic(inc, "hour", 24, "monthday");
        },
        next_day: function next_day() {
          var has_by_day = "BYDAY" in this.by_data;
          var this_freq = this.rule.freq == "DAILY";
          if (this.next_hour() == 0) {
            return 0;
          }
          if (this_freq) {
            this.increment_monthday(this.rule.interval);
          } else {
            this.increment_monthday(1);
          }
          return 0;
        },
        next_week: function next_week() {
          var end_of_data = 0;
          if (this.next_weekday_by_week() == 0) {
            return end_of_data;
          }
          if (this.has_by_data("BYWEEKNO")) {
            var idx = ++this.by_indices.BYWEEKNO;
            if (this.by_indices.BYWEEKNO == this.by_data.BYWEEKNO.length) {
              this.by_indices.BYWEEKNO = 0;
              end_of_data = 1;
            }
            this.last.month = 1;
            this.last.day = 1;
            var week_no = this.by_data.BYWEEKNO[this.by_indices.BYWEEKNO];
            this.last.day += 7 * week_no;
            if (end_of_data) {
              this.increment_year(1);
            }
          } else {
            this.increment_monthday(7 * this.rule.interval);
          }
          return end_of_data;
        },
        /**
         * Normalize each by day rule for a given year/month.
         * Takes into account ordering and negative rules
         *
         * @private
         * @param {Number} year         Current year.
         * @param {Number} month        Current month.
         * @param {Array}  rules        Array of rules.
         *
         * @return {Array} sorted and normalized rules.
         *                 Negative rules will be expanded to their
         *                 correct positive values for easier processing.
         */
        normalizeByMonthDayRules: function(year, month, rules) {
          var daysInMonth = ICAL2.Time.daysInMonth(month, year);
          var newRules = [];
          var ruleIdx = 0;
          var len = rules.length;
          var rule;
          for (; ruleIdx < len; ruleIdx++) {
            rule = rules[ruleIdx];
            if (Math.abs(rule) > daysInMonth) {
              continue;
            }
            if (rule < 0) {
              rule = daysInMonth + (rule + 1);
            } else if (rule === 0) {
              continue;
            }
            if (newRules.indexOf(rule) === -1) {
              newRules.push(rule);
            }
          }
          return newRules.sort(function(a3, b3) {
            return a3 - b3;
          });
        },
        /**
         * NOTES:
         * We are given a list of dates in the month (BYMONTHDAY) (23, etc..)
         * Also we are given a list of days (BYDAY) (MO, 2SU, etc..) when
         * both conditions match a given date (this.last.day) iteration stops.
         *
         * @private
         * @param {Boolean=} isInit     When given true will not increment the
         *                                current day (this.last).
         */
        _byDayAndMonthDay: function(isInit) {
          var byMonthDay;
          var byDay = this.by_data.BYDAY;
          var date;
          var dateIdx = 0;
          var dateLen;
          var dayLen = byDay.length;
          var dataIsValid = 0;
          var daysInMonth;
          var self2 = this;
          var lastDay = this.last.day;
          function initMonth() {
            daysInMonth = ICAL2.Time.daysInMonth(
              self2.last.month,
              self2.last.year
            );
            byMonthDay = self2.normalizeByMonthDayRules(
              self2.last.year,
              self2.last.month,
              self2.by_data.BYMONTHDAY
            );
            dateLen = byMonthDay.length;
            while (byMonthDay[dateIdx] <= lastDay && !(isInit && byMonthDay[dateIdx] == lastDay) && dateIdx < dateLen - 1) {
              dateIdx++;
            }
          }
          function nextMonth() {
            lastDay = 0;
            self2.increment_month();
            dateIdx = 0;
            initMonth();
          }
          initMonth();
          if (isInit) {
            lastDay -= 1;
          }
          var monthsCounter = 48;
          while (!dataIsValid && monthsCounter) {
            monthsCounter--;
            date = lastDay + 1;
            if (date > daysInMonth) {
              nextMonth();
              continue;
            }
            var next = byMonthDay[dateIdx++];
            if (next >= date) {
              lastDay = next;
            } else {
              nextMonth();
              continue;
            }
            for (var dayIdx = 0; dayIdx < dayLen; dayIdx++) {
              var parts = this.ruleDayOfWeek(byDay[dayIdx]);
              var pos = parts[0];
              var dow = parts[1];
              this.last.day = lastDay;
              if (this.last.isNthWeekDay(dow, pos)) {
                dataIsValid = 1;
                break;
              }
            }
            if (!dataIsValid && dateIdx === dateLen) {
              nextMonth();
              continue;
            }
          }
          if (monthsCounter <= 0) {
            throw new Error("Malformed values in BYDAY combined with BYMONTHDAY parts");
          }
          return dataIsValid;
        },
        next_month: function next_month() {
          var this_freq = this.rule.freq == "MONTHLY";
          var data_valid = 1;
          if (this.next_hour() == 0) {
            return data_valid;
          }
          if (this.has_by_data("BYDAY") && this.has_by_data("BYMONTHDAY")) {
            data_valid = this._byDayAndMonthDay();
          } else if (this.has_by_data("BYDAY")) {
            var daysInMonth = ICAL2.Time.daysInMonth(this.last.month, this.last.year);
            var setpos = 0;
            var setpos_total = 0;
            if (this.has_by_data("BYSETPOS")) {
              var last_day = this.last.day;
              for (var day = 1; day <= daysInMonth; day++) {
                this.last.day = day;
                if (this.is_day_in_byday(this.last)) {
                  setpos_total++;
                  if (day <= last_day) {
                    setpos++;
                  }
                }
              }
              this.last.day = last_day;
            }
            data_valid = 0;
            for (var day = this.last.day + 1; day <= daysInMonth; day++) {
              this.last.day = day;
              if (this.is_day_in_byday(this.last)) {
                if (!this.has_by_data("BYSETPOS") || this.check_set_position(++setpos) || this.check_set_position(setpos - setpos_total - 1)) {
                  data_valid = 1;
                  break;
                }
              }
            }
            if (day > daysInMonth) {
              this.last.day = 1;
              this.increment_month();
              if (this.is_day_in_byday(this.last)) {
                if (!this.has_by_data("BYSETPOS") || this.check_set_position(1)) {
                  data_valid = 1;
                }
              } else {
                data_valid = 0;
              }
            }
          } else if (this.has_by_data("BYMONTHDAY")) {
            this.by_indices.BYMONTHDAY++;
            if (this.by_indices.BYMONTHDAY >= this.by_data.BYMONTHDAY.length) {
              this.by_indices.BYMONTHDAY = 0;
              this.increment_month();
            }
            var daysInMonth = ICAL2.Time.daysInMonth(this.last.month, this.last.year);
            var day = this.by_data.BYMONTHDAY[this.by_indices.BYMONTHDAY];
            if (day < 0) {
              day = daysInMonth + day + 1;
            }
            if (day > daysInMonth) {
              this.last.day = 1;
              data_valid = this.is_day_in_byday(this.last);
            } else {
              this.last.day = day;
            }
          } else {
            this.increment_month();
            var daysInMonth = ICAL2.Time.daysInMonth(this.last.month, this.last.year);
            if (this.by_data.BYMONTHDAY[0] > daysInMonth) {
              data_valid = 0;
            } else {
              this.last.day = this.by_data.BYMONTHDAY[0];
            }
          }
          return data_valid;
        },
        next_weekday_by_week: function next_weekday_by_week() {
          var end_of_data = 0;
          if (this.next_hour() == 0) {
            return end_of_data;
          }
          if (!this.has_by_data("BYDAY")) {
            return 1;
          }
          for (; ; ) {
            var tt = new ICAL2.Time();
            this.by_indices.BYDAY++;
            if (this.by_indices.BYDAY == Object.keys(this.by_data.BYDAY).length) {
              this.by_indices.BYDAY = 0;
              end_of_data = 1;
            }
            var coded_day = this.by_data.BYDAY[this.by_indices.BYDAY];
            var parts = this.ruleDayOfWeek(coded_day);
            var dow = parts[1];
            dow -= this.rule.wkst;
            if (dow < 0) {
              dow += 7;
            }
            tt.year = this.last.year;
            tt.month = this.last.month;
            tt.day = this.last.day;
            var startOfWeek = tt.startDoyWeek(this.rule.wkst);
            if (dow + startOfWeek < 1) {
              if (!end_of_data) {
                continue;
              }
            }
            var next = ICAL2.Time.fromDayOfYear(
              startOfWeek + dow,
              this.last.year
            );
            this.last.year = next.year;
            this.last.month = next.month;
            this.last.day = next.day;
            return end_of_data;
          }
        },
        next_year: function next_year() {
          if (this.next_hour() == 0) {
            return 0;
          }
          if (++this.days_index == this.days.length) {
            this.days_index = 0;
            do {
              this.increment_year(this.rule.interval);
              this.expand_year_days(this.last.year);
            } while (this.days.length == 0);
          }
          this._nextByYearDay();
          return 1;
        },
        _nextByYearDay: function _nextByYearDay() {
          var doy = this.days[this.days_index];
          var year = this.last.year;
          if (doy < 1) {
            doy += 1;
            year += 1;
          }
          var next = ICAL2.Time.fromDayOfYear(doy, year);
          this.last.day = next.day;
          this.last.month = next.month;
        },
        /**
         * @param dow (eg: '1TU', '-1MO')
         * @param {ICAL.Time.weekDay=} aWeekStart The week start weekday
         * @return [pos, numericDow] (eg: [1, 3]) numericDow is relative to aWeekStart
         */
        ruleDayOfWeek: function ruleDayOfWeek(dow, aWeekStart) {
          var matches = dow.match(/([+-]?[0-9])?(MO|TU|WE|TH|FR|SA|SU)/);
          if (matches) {
            var pos = parseInt(matches[1] || 0, 10);
            dow = ICAL2.Recur.icalDayToNumericDay(matches[2], aWeekStart);
            return [pos, dow];
          } else {
            return [0, 0];
          }
        },
        next_generic: function next_generic(aRuleType, aInterval, aDateAttr, aFollowingAttr, aPreviousIncr) {
          var has_by_rule = aRuleType in this.by_data;
          var this_freq = this.rule.freq == aInterval;
          var end_of_data = 0;
          if (aPreviousIncr && this[aPreviousIncr]() == 0) {
            return end_of_data;
          }
          if (has_by_rule) {
            this.by_indices[aRuleType]++;
            var idx = this.by_indices[aRuleType];
            var dta = this.by_data[aRuleType];
            if (this.by_indices[aRuleType] == dta.length) {
              this.by_indices[aRuleType] = 0;
              end_of_data = 1;
            }
            this.last[aDateAttr] = dta[this.by_indices[aRuleType]];
          } else if (this_freq) {
            this["increment_" + aDateAttr](this.rule.interval);
          }
          if (has_by_rule && end_of_data && this_freq) {
            this["increment_" + aFollowingAttr](1);
          }
          return end_of_data;
        },
        increment_monthday: function increment_monthday(inc) {
          for (var i3 = 0; i3 < inc; i3++) {
            var daysInMonth = ICAL2.Time.daysInMonth(this.last.month, this.last.year);
            this.last.day++;
            if (this.last.day > daysInMonth) {
              this.last.day -= daysInMonth;
              this.increment_month();
            }
          }
        },
        increment_month: function increment_month() {
          this.last.day = 1;
          if (this.has_by_data("BYMONTH")) {
            this.by_indices.BYMONTH++;
            if (this.by_indices.BYMONTH == this.by_data.BYMONTH.length) {
              this.by_indices.BYMONTH = 0;
              this.increment_year(1);
            }
            this.last.month = this.by_data.BYMONTH[this.by_indices.BYMONTH];
          } else {
            if (this.rule.freq == "MONTHLY") {
              this.last.month += this.rule.interval;
            } else {
              this.last.month++;
            }
            this.last.month--;
            var years = ICAL2.helpers.trunc(this.last.month / 12);
            this.last.month %= 12;
            this.last.month++;
            if (years != 0) {
              this.increment_year(years);
            }
          }
        },
        increment_year: function increment_year(inc) {
          this.last.year += inc;
        },
        increment_generic: function increment_generic(inc, aDateAttr, aFactor, aNextIncrement) {
          this.last[aDateAttr] += inc;
          var nextunit = ICAL2.helpers.trunc(this.last[aDateAttr] / aFactor);
          this.last[aDateAttr] %= aFactor;
          if (nextunit != 0) {
            this["increment_" + aNextIncrement](nextunit);
          }
        },
        has_by_data: function has_by_data(aRuleType) {
          return aRuleType in this.rule.parts;
        },
        expand_year_days: function expand_year_days(aYear) {
          var t3 = new ICAL2.Time();
          this.days = [];
          var parts = {};
          var rules = ["BYDAY", "BYWEEKNO", "BYMONTHDAY", "BYMONTH", "BYYEARDAY"];
          for (var p3 in rules) {
            if (rules.hasOwnProperty(p3)) {
              var part = rules[p3];
              if (part in this.rule.parts) {
                parts[part] = this.rule.parts[part];
              }
            }
          }
          if ("BYMONTH" in parts && "BYWEEKNO" in parts) {
            var valid = 1;
            var validWeeks = {};
            t3.year = aYear;
            t3.isDate = true;
            for (var monthIdx = 0; monthIdx < this.by_data.BYMONTH.length; monthIdx++) {
              var month = this.by_data.BYMONTH[monthIdx];
              t3.month = month;
              t3.day = 1;
              var first_week = t3.weekNumber(this.rule.wkst);
              t3.day = ICAL2.Time.daysInMonth(month, aYear);
              var last_week = t3.weekNumber(this.rule.wkst);
              for (monthIdx = first_week; monthIdx < last_week; monthIdx++) {
                validWeeks[monthIdx] = 1;
              }
            }
            for (var weekIdx = 0; weekIdx < this.by_data.BYWEEKNO.length && valid; weekIdx++) {
              var weekno = this.by_data.BYWEEKNO[weekIdx];
              if (weekno < 52) {
                valid &= validWeeks[weekIdx];
              } else {
                valid = 0;
              }
            }
            if (valid) {
              delete parts.BYMONTH;
            } else {
              delete parts.BYWEEKNO;
            }
          }
          var partCount = Object.keys(parts).length;
          if (partCount == 0) {
            var t1 = this.dtstart.clone();
            t1.year = this.last.year;
            this.days.push(t1.dayOfYear());
          } else if (partCount == 1 && "BYMONTH" in parts) {
            for (var monthkey in this.by_data.BYMONTH) {
              if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {
                continue;
              }
              var t22 = this.dtstart.clone();
              t22.year = aYear;
              t22.month = this.by_data.BYMONTH[monthkey];
              t22.isDate = true;
              this.days.push(t22.dayOfYear());
            }
          } else if (partCount == 1 && "BYMONTHDAY" in parts) {
            for (var monthdaykey in this.by_data.BYMONTHDAY) {
              if (!this.by_data.BYMONTHDAY.hasOwnProperty(monthdaykey)) {
                continue;
              }
              var t32 = this.dtstart.clone();
              var day_ = this.by_data.BYMONTHDAY[monthdaykey];
              if (day_ < 0) {
                var daysInMonth = ICAL2.Time.daysInMonth(t32.month, aYear);
                day_ = day_ + daysInMonth + 1;
              }
              t32.day = day_;
              t32.year = aYear;
              t32.isDate = true;
              this.days.push(t32.dayOfYear());
            }
          } else if (partCount == 2 && "BYMONTHDAY" in parts && "BYMONTH" in parts) {
            for (var monthkey in this.by_data.BYMONTH) {
              if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {
                continue;
              }
              var month_ = this.by_data.BYMONTH[monthkey];
              var daysInMonth = ICAL2.Time.daysInMonth(month_, aYear);
              for (var monthdaykey in this.by_data.BYMONTHDAY) {
                if (!this.by_data.BYMONTHDAY.hasOwnProperty(monthdaykey)) {
                  continue;
                }
                var day_ = this.by_data.BYMONTHDAY[monthdaykey];
                if (day_ < 0) {
                  day_ = day_ + daysInMonth + 1;
                }
                t3.day = day_;
                t3.month = month_;
                t3.year = aYear;
                t3.isDate = true;
                this.days.push(t3.dayOfYear());
              }
            }
          } else if (partCount == 1 && "BYWEEKNO" in parts) {
          } else if (partCount == 2 && "BYWEEKNO" in parts && "BYMONTHDAY" in parts) {
          } else if (partCount == 1 && "BYDAY" in parts) {
            this.days = this.days.concat(this.expand_by_day(aYear));
          } else if (partCount == 2 && "BYDAY" in parts && "BYMONTH" in parts) {
            for (var monthkey in this.by_data.BYMONTH) {
              if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {
                continue;
              }
              var month = this.by_data.BYMONTH[monthkey];
              var daysInMonth = ICAL2.Time.daysInMonth(month, aYear);
              t3.year = aYear;
              t3.month = this.by_data.BYMONTH[monthkey];
              t3.day = 1;
              t3.isDate = true;
              var first_dow = t3.dayOfWeek();
              var doy_offset = t3.dayOfYear() - 1;
              t3.day = daysInMonth;
              var last_dow = t3.dayOfWeek();
              if (this.has_by_data("BYSETPOS")) {
                var set_pos_counter = 0;
                var by_month_day = [];
                for (var day = 1; day <= daysInMonth; day++) {
                  t3.day = day;
                  if (this.is_day_in_byday(t3)) {
                    by_month_day.push(day);
                  }
                }
                for (var spIndex = 0; spIndex < by_month_day.length; spIndex++) {
                  if (this.check_set_position(spIndex + 1) || this.check_set_position(spIndex - by_month_day.length)) {
                    this.days.push(doy_offset + by_month_day[spIndex]);
                  }
                }
              } else {
                for (var daycodedkey in this.by_data.BYDAY) {
                  if (!this.by_data.BYDAY.hasOwnProperty(daycodedkey)) {
                    continue;
                  }
                  var coded_day = this.by_data.BYDAY[daycodedkey];
                  var bydayParts = this.ruleDayOfWeek(coded_day);
                  var pos = bydayParts[0];
                  var dow = bydayParts[1];
                  var month_day;
                  var first_matching_day = (dow + 7 - first_dow) % 7 + 1;
                  var last_matching_day = daysInMonth - (last_dow + 7 - dow) % 7;
                  if (pos == 0) {
                    for (var day = first_matching_day; day <= daysInMonth; day += 7) {
                      this.days.push(doy_offset + day);
                    }
                  } else if (pos > 0) {
                    month_day = first_matching_day + (pos - 1) * 7;
                    if (month_day <= daysInMonth) {
                      this.days.push(doy_offset + month_day);
                    }
                  } else {
                    month_day = last_matching_day + (pos + 1) * 7;
                    if (month_day > 0) {
                      this.days.push(doy_offset + month_day);
                    }
                  }
                }
              }
            }
            this.days.sort(function(a3, b3) {
              return a3 - b3;
            });
          } else if (partCount == 2 && "BYDAY" in parts && "BYMONTHDAY" in parts) {
            var expandedDays = this.expand_by_day(aYear);
            for (var daykey in expandedDays) {
              if (!expandedDays.hasOwnProperty(daykey)) {
                continue;
              }
              var day = expandedDays[daykey];
              var tt = ICAL2.Time.fromDayOfYear(day, aYear);
              if (this.by_data.BYMONTHDAY.indexOf(tt.day) >= 0) {
                this.days.push(day);
              }
            }
          } else if (partCount == 3 && "BYDAY" in parts && "BYMONTHDAY" in parts && "BYMONTH" in parts) {
            var expandedDays = this.expand_by_day(aYear);
            for (var daykey in expandedDays) {
              if (!expandedDays.hasOwnProperty(daykey)) {
                continue;
              }
              var day = expandedDays[daykey];
              var tt = ICAL2.Time.fromDayOfYear(day, aYear);
              if (this.by_data.BYMONTH.indexOf(tt.month) >= 0 && this.by_data.BYMONTHDAY.indexOf(tt.day) >= 0) {
                this.days.push(day);
              }
            }
          } else if (partCount == 2 && "BYDAY" in parts && "BYWEEKNO" in parts) {
            var expandedDays = this.expand_by_day(aYear);
            for (var daykey in expandedDays) {
              if (!expandedDays.hasOwnProperty(daykey)) {
                continue;
              }
              var day = expandedDays[daykey];
              var tt = ICAL2.Time.fromDayOfYear(day, aYear);
              var weekno = tt.weekNumber(this.rule.wkst);
              if (this.by_data.BYWEEKNO.indexOf(weekno)) {
                this.days.push(day);
              }
            }
          } else if (partCount == 3 && "BYDAY" in parts && "BYWEEKNO" in parts && "BYMONTHDAY" in parts) {
          } else if (partCount == 1 && "BYYEARDAY" in parts) {
            this.days = this.days.concat(this.by_data.BYYEARDAY);
          } else {
            this.days = [];
          }
          return 0;
        },
        expand_by_day: function expand_by_day(aYear) {
          var days_list = [];
          var tmp = this.last.clone();
          tmp.year = aYear;
          tmp.month = 1;
          tmp.day = 1;
          tmp.isDate = true;
          var start_dow = tmp.dayOfWeek();
          tmp.month = 12;
          tmp.day = 31;
          tmp.isDate = true;
          var end_dow = tmp.dayOfWeek();
          var end_year_day = tmp.dayOfYear();
          for (var daykey in this.by_data.BYDAY) {
            if (!this.by_data.BYDAY.hasOwnProperty(daykey)) {
              continue;
            }
            var day = this.by_data.BYDAY[daykey];
            var parts = this.ruleDayOfWeek(day);
            var pos = parts[0];
            var dow = parts[1];
            if (pos == 0) {
              var tmp_start_doy = (dow + 7 - start_dow) % 7 + 1;
              for (var doy = tmp_start_doy; doy <= end_year_day; doy += 7) {
                days_list.push(doy);
              }
            } else if (pos > 0) {
              var first;
              if (dow >= start_dow) {
                first = dow - start_dow + 1;
              } else {
                first = dow - start_dow + 8;
              }
              days_list.push(first + (pos - 1) * 7);
            } else {
              var last;
              pos = -pos;
              if (dow <= end_dow) {
                last = end_year_day - end_dow + dow;
              } else {
                last = end_year_day - end_dow + dow - 7;
              }
              days_list.push(last - (pos - 1) * 7);
            }
          }
          return days_list;
        },
        is_day_in_byday: function is_day_in_byday(tt) {
          for (var daykey in this.by_data.BYDAY) {
            if (!this.by_data.BYDAY.hasOwnProperty(daykey)) {
              continue;
            }
            var day = this.by_data.BYDAY[daykey];
            var parts = this.ruleDayOfWeek(day);
            var pos = parts[0];
            var dow = parts[1];
            var this_dow = tt.dayOfWeek();
            if (pos == 0 && dow == this_dow || tt.nthWeekDay(dow, pos) == tt.day) {
              return 1;
            }
          }
          return 0;
        },
        /**
         * Checks if given value is in BYSETPOS.
         *
         * @private
         * @param {Numeric} aPos position to check for.
         * @return {Boolean} false unless BYSETPOS rules exist
         *                   and the given value is present in rules.
         */
        check_set_position: function check_set_position(aPos) {
          if (this.has_by_data("BYSETPOS")) {
            var idx = this.by_data.BYSETPOS.indexOf(aPos);
            return idx !== -1;
          }
          return false;
        },
        sort_byday_rules: function icalrecur_sort_byday_rules(aRules) {
          for (var i3 = 0; i3 < aRules.length; i3++) {
            for (var j4 = 0; j4 < i3; j4++) {
              var one = this.ruleDayOfWeek(aRules[j4], this.rule.wkst)[1];
              var two = this.ruleDayOfWeek(aRules[i3], this.rule.wkst)[1];
              if (one > two) {
                var tmp = aRules[i3];
                aRules[i3] = aRules[j4];
                aRules[j4] = tmp;
              }
            }
          }
        },
        check_contract_restriction: function check_contract_restriction(aRuleType, v3) {
          var indexMapValue = icalrecur_iterator._indexMap[aRuleType];
          var ruleMapValue = icalrecur_iterator._expandMap[this.rule.freq][indexMapValue];
          var pass = false;
          if (aRuleType in this.by_data && ruleMapValue == icalrecur_iterator.CONTRACT) {
            var ruleType = this.by_data[aRuleType];
            for (var bydatakey in ruleType) {
              if (ruleType.hasOwnProperty(bydatakey)) {
                if (ruleType[bydatakey] == v3) {
                  pass = true;
                  break;
                }
              }
            }
          } else {
            pass = true;
          }
          return pass;
        },
        check_contracting_rules: function check_contracting_rules() {
          var dow = this.last.dayOfWeek();
          var weekNo = this.last.weekNumber(this.rule.wkst);
          var doy = this.last.dayOfYear();
          return this.check_contract_restriction("BYSECOND", this.last.second) && this.check_contract_restriction("BYMINUTE", this.last.minute) && this.check_contract_restriction("BYHOUR", this.last.hour) && this.check_contract_restriction("BYDAY", ICAL2.Recur.numericDayToIcalDay(dow)) && this.check_contract_restriction("BYWEEKNO", weekNo) && this.check_contract_restriction("BYMONTHDAY", this.last.day) && this.check_contract_restriction("BYMONTH", this.last.month) && this.check_contract_restriction("BYYEARDAY", doy);
        },
        setup_defaults: function setup_defaults(aRuleType, req, deftime) {
          var indexMapValue = icalrecur_iterator._indexMap[aRuleType];
          var ruleMapValue = icalrecur_iterator._expandMap[this.rule.freq][indexMapValue];
          if (ruleMapValue != icalrecur_iterator.CONTRACT) {
            if (!(aRuleType in this.by_data)) {
              this.by_data[aRuleType] = [deftime];
            }
            if (this.rule.freq != req) {
              return this.by_data[aRuleType][0];
            }
          }
          return deftime;
        },
        /**
         * Convert iterator into a serialize-able object.  Will preserve current
         * iteration sequence to ensure the seamless continuation of the recurrence
         * rule.
         * @return {Object}
         */
        toJSON: function() {
          var result = /* @__PURE__ */ Object.create(null);
          result.initialized = this.initialized;
          result.rule = this.rule.toJSON();
          result.dtstart = this.dtstart.toJSON();
          result.by_data = this.by_data;
          result.days = this.days;
          result.last = this.last.toJSON();
          result.by_indices = this.by_indices;
          result.occurrence_number = this.occurrence_number;
          return result;
        }
      };
      icalrecur_iterator._indexMap = {
        "BYSECOND": 0,
        "BYMINUTE": 1,
        "BYHOUR": 2,
        "BYDAY": 3,
        "BYMONTHDAY": 4,
        "BYYEARDAY": 5,
        "BYWEEKNO": 6,
        "BYMONTH": 7,
        "BYSETPOS": 8
      };
      icalrecur_iterator._expandMap = {
        "SECONDLY": [1, 1, 1, 1, 1, 1, 1, 1],
        "MINUTELY": [2, 1, 1, 1, 1, 1, 1, 1],
        "HOURLY": [2, 2, 1, 1, 1, 1, 1, 1],
        "DAILY": [2, 2, 2, 1, 1, 1, 1, 1],
        "WEEKLY": [2, 2, 2, 2, 3, 3, 1, 1],
        "MONTHLY": [2, 2, 2, 2, 2, 3, 3, 1],
        "YEARLY": [2, 2, 2, 2, 2, 2, 2, 2]
      };
      icalrecur_iterator.UNKNOWN = 0;
      icalrecur_iterator.CONTRACT = 1;
      icalrecur_iterator.EXPAND = 2;
      icalrecur_iterator.ILLEGAL = 3;
      return icalrecur_iterator;
    }();
    ICAL2.RecurExpansion = function() {
      function formatTime(item) {
        return ICAL2.helpers.formatClassType(item, ICAL2.Time);
      }
      function compareTime(a3, b3) {
        return a3.compare(b3);
      }
      function isRecurringComponent(comp) {
        return comp.hasProperty("rdate") || comp.hasProperty("rrule") || comp.hasProperty("recurrence-id");
      }
      function RecurExpansion(options) {
        this.ruleDates = [];
        this.exDates = [];
        this.fromData(options);
      }
      RecurExpansion.prototype = {
        /**
         * True when iteration is fully completed.
         * @type {Boolean}
         */
        complete: false,
        /**
         * Array of rrule iterators.
         *
         * @type {ICAL.RecurIterator[]}
         * @private
         */
        ruleIterators: null,
        /**
         * Array of rdate instances.
         *
         * @type {ICAL.Time[]}
         * @private
         */
        ruleDates: null,
        /**
         * Array of exdate instances.
         *
         * @type {ICAL.Time[]}
         * @private
         */
        exDates: null,
        /**
         * Current position in ruleDates array.
         * @type {Number}
         * @private
         */
        ruleDateInc: 0,
        /**
         * Current position in exDates array
         * @type {Number}
         * @private
         */
        exDateInc: 0,
        /**
         * Current negative date.
         *
         * @type {ICAL.Time}
         * @private
         */
        exDate: null,
        /**
         * Current additional date.
         *
         * @type {ICAL.Time}
         * @private
         */
        ruleDate: null,
        /**
         * Start date of recurring rules.
         *
         * @type {ICAL.Time}
         */
        dtstart: null,
        /**
         * Last expanded time
         *
         * @type {ICAL.Time}
         */
        last: null,
        /**
         * Initialize the recurrence expansion from the data object. The options
         * object may also contain additional members, see the
         * {@link ICAL.RecurExpansion constructor} for more details.
         *
         * @param {Object} options
         *        Recurrence expansion options
         * @param {ICAL.Time} options.dtstart
         *        Start time of the event
         * @param {ICAL.Component=} options.component
         *        Component for expansion, required if not resuming.
         */
        fromData: function(options) {
          var start = ICAL2.helpers.formatClassType(options.dtstart, ICAL2.Time);
          if (!start) {
            throw new Error(".dtstart (ICAL.Time) must be given");
          } else {
            this.dtstart = start;
          }
          if (options.component) {
            this._init(options.component);
          } else {
            this.last = formatTime(options.last) || start.clone();
            if (!options.ruleIterators) {
              throw new Error(".ruleIterators or .component must be given");
            }
            this.ruleIterators = options.ruleIterators.map(function(item) {
              return ICAL2.helpers.formatClassType(item, ICAL2.RecurIterator);
            });
            this.ruleDateInc = options.ruleDateInc;
            this.exDateInc = options.exDateInc;
            if (options.ruleDates) {
              this.ruleDates = options.ruleDates.map(formatTime);
              this.ruleDate = this.ruleDates[this.ruleDateInc];
            }
            if (options.exDates) {
              this.exDates = options.exDates.map(formatTime);
              this.exDate = this.exDates[this.exDateInc];
            }
            if (typeof options.complete !== "undefined") {
              this.complete = options.complete;
            }
          }
        },
        /**
         * Retrieve the next occurrence in the series.
         * @return {ICAL.Time}
         */
        next: function() {
          var iter2;
          var ruleOfDay;
          var next;
          var compare;
          var maxTries = 500;
          var currentTry = 0;
          while (true) {
            if (currentTry++ > maxTries) {
              throw new Error(
                "max tries have occured, rule may be impossible to forfill."
              );
            }
            next = this.ruleDate;
            iter2 = this._nextRecurrenceIter(this.last);
            if (!next && !iter2) {
              this.complete = true;
              break;
            }
            if (!next || iter2 && next.compare(iter2.last) > 0) {
              next = iter2.last.clone();
              iter2.next();
            }
            if (this.ruleDate === next) {
              this._nextRuleDay();
            }
            this.last = next;
            if (this.exDate) {
              compare = this.exDate.compare(this.last);
              if (compare < 0) {
                this._nextExDay();
              }
              if (compare === 0) {
                this._nextExDay();
                continue;
              }
            }
            return this.last;
          }
        },
        /**
         * Converts object into a serialize-able format. This format can be passed
         * back into the expansion to resume iteration.
         * @return {Object}
         */
        toJSON: function() {
          function toJSON(item) {
            return item.toJSON();
          }
          var result = /* @__PURE__ */ Object.create(null);
          result.ruleIterators = this.ruleIterators.map(toJSON);
          if (this.ruleDates) {
            result.ruleDates = this.ruleDates.map(toJSON);
          }
          if (this.exDates) {
            result.exDates = this.exDates.map(toJSON);
          }
          result.ruleDateInc = this.ruleDateInc;
          result.exDateInc = this.exDateInc;
          result.last = this.last.toJSON();
          result.dtstart = this.dtstart.toJSON();
          result.complete = this.complete;
          return result;
        },
        /**
         * Extract all dates from the properties in the given component. The
         * properties will be filtered by the property name.
         *
         * @private
         * @param {ICAL.Component} component        The component to search in
         * @param {String} propertyName             The property name to search for
         * @return {ICAL.Time[]}                    The extracted dates.
         */
        _extractDates: function(component, propertyName) {
          function handleProp(prop2) {
            idx = ICAL2.helpers.binsearchInsert(
              result,
              prop2,
              compareTime
            );
            result.splice(idx, 0, prop2);
          }
          var result = [];
          var props = component.getAllProperties(propertyName);
          var len = props.length;
          var i3 = 0;
          var prop;
          var idx;
          for (; i3 < len; i3++) {
            props[i3].getValues().forEach(handleProp);
          }
          return result;
        },
        /**
         * Initialize the recurrence expansion.
         *
         * @private
         * @param {ICAL.Component} component    The component to initialize from.
         */
        _init: function(component) {
          this.ruleIterators = [];
          this.last = this.dtstart.clone();
          if (!isRecurringComponent(component)) {
            this.ruleDate = this.last.clone();
            this.complete = true;
            return;
          }
          if (component.hasProperty("rdate")) {
            this.ruleDates = this._extractDates(component, "rdate");
            if (this.ruleDates[0] && this.ruleDates[0].compare(this.dtstart) < 0) {
              this.ruleDateInc = 0;
              this.last = this.ruleDates[0].clone();
            } else {
              this.ruleDateInc = ICAL2.helpers.binsearchInsert(
                this.ruleDates,
                this.last,
                compareTime
              );
            }
            this.ruleDate = this.ruleDates[this.ruleDateInc];
          }
          if (component.hasProperty("rrule")) {
            var rules = component.getAllProperties("rrule");
            var i3 = 0;
            var len = rules.length;
            var rule;
            var iter2;
            for (; i3 < len; i3++) {
              rule = rules[i3].getFirstValue();
              iter2 = rule.iterator(this.dtstart);
              this.ruleIterators.push(iter2);
              iter2.next();
            }
          }
          if (component.hasProperty("exdate")) {
            this.exDates = this._extractDates(component, "exdate");
            this.exDateInc = ICAL2.helpers.binsearchInsert(
              this.exDates,
              this.last,
              compareTime
            );
            this.exDate = this.exDates[this.exDateInc];
          }
        },
        /**
         * Advance to the next exdate
         * @private
         */
        _nextExDay: function() {
          this.exDate = this.exDates[++this.exDateInc];
        },
        /**
         * Advance to the next rule date
         * @private
         */
        _nextRuleDay: function() {
          this.ruleDate = this.ruleDates[++this.ruleDateInc];
        },
        /**
         * Find and return the recurrence rule with the most recent event and
         * return it.
         *
         * @private
         * @return {?ICAL.RecurIterator}    Found iterator.
         */
        _nextRecurrenceIter: function() {
          var iters = this.ruleIterators;
          if (iters.length === 0) {
            return null;
          }
          var len = iters.length;
          var iter2;
          var iterTime;
          var iterIdx = 0;
          var chosenIter;
          for (; iterIdx < len; iterIdx++) {
            iter2 = iters[iterIdx];
            iterTime = iter2.last;
            if (iter2.completed) {
              len--;
              if (iterIdx !== 0) {
                iterIdx--;
              }
              iters.splice(iterIdx, 1);
              continue;
            }
            if (!chosenIter || chosenIter.last.compare(iterTime) > 0) {
              chosenIter = iter2;
            }
          }
          return chosenIter;
        }
      };
      return RecurExpansion;
    }();
    ICAL2.Event = function() {
      function Event2(component, options) {
        if (!(component instanceof ICAL2.Component)) {
          options = component;
          component = null;
        }
        if (component) {
          this.component = component;
        } else {
          this.component = new ICAL2.Component("vevent");
        }
        this._rangeExceptionCache = /* @__PURE__ */ Object.create(null);
        this.exceptions = /* @__PURE__ */ Object.create(null);
        this.rangeExceptions = [];
        if (options && options.strictExceptions) {
          this.strictExceptions = options.strictExceptions;
        }
        if (options && options.exceptions) {
          options.exceptions.forEach(this.relateException, this);
        } else if (this.component.parent && !this.isRecurrenceException()) {
          this.component.parent.getAllSubcomponents("vevent").forEach(function(event) {
            if (event.hasProperty("recurrence-id")) {
              this.relateException(event);
            }
          }, this);
        }
      }
      Event2.prototype = {
        THISANDFUTURE: "THISANDFUTURE",
        /**
         * List of related event exceptions.
         *
         * @type {ICAL.Event[]}
         */
        exceptions: null,
        /**
         * When true, will verify exceptions are related by their UUID.
         *
         * @type {Boolean}
         */
        strictExceptions: false,
        /**
         * Relates a given event exception to this object.  If the given component
         * does not share the UID of this event it cannot be related and will throw
         * an exception.
         *
         * If this component is an exception it cannot have other exceptions
         * related to it.
         *
         * @param {ICAL.Component|ICAL.Event} obj       Component or event
         */
        relateException: function(obj) {
          if (this.isRecurrenceException()) {
            throw new Error("cannot relate exception to exceptions");
          }
          if (obj instanceof ICAL2.Component) {
            obj = new ICAL2.Event(obj);
          }
          if (this.strictExceptions && obj.uid !== this.uid) {
            throw new Error("attempted to relate unrelated exception");
          }
          var id = obj.recurrenceId.toString();
          this.exceptions[id] = obj;
          if (obj.modifiesFuture()) {
            var item = [
              obj.recurrenceId.toUnixTime(),
              id
            ];
            var idx = ICAL2.helpers.binsearchInsert(
              this.rangeExceptions,
              item,
              compareRangeException
            );
            this.rangeExceptions.splice(idx, 0, item);
          }
        },
        /**
         * Checks if this record is an exception and has the RANGE=THISANDFUTURE
         * value.
         *
         * @return {Boolean}        True, when exception is within range
         */
        modifiesFuture: function() {
          if (!this.component.hasProperty("recurrence-id")) {
            return false;
          }
          var range2 = this.component.getFirstProperty("recurrence-id").getParameter("range");
          return range2 === this.THISANDFUTURE;
        },
        /**
         * Finds the range exception nearest to the given date.
         *
         * @param {ICAL.Time} time usually an occurrence time of an event
         * @return {?ICAL.Event} the related event/exception or null
         */
        findRangeException: function(time) {
          if (!this.rangeExceptions.length) {
            return null;
          }
          var utc = time.toUnixTime();
          var idx = ICAL2.helpers.binsearchInsert(
            this.rangeExceptions,
            [utc],
            compareRangeException
          );
          idx -= 1;
          if (idx < 0) {
            return null;
          }
          var rangeItem = this.rangeExceptions[idx];
          if (utc < rangeItem[0]) {
            return null;
          }
          return rangeItem[1];
        },
        /**
         * This object is returned by {@link ICAL.Event#getOccurrenceDetails getOccurrenceDetails}
         *
         * @typedef {Object} occurrenceDetails
         * @memberof ICAL.Event
         * @property {ICAL.Time} recurrenceId       The passed in recurrence id
         * @property {ICAL.Event} item              The occurrence
         * @property {ICAL.Time} startDate          The start of the occurrence
         * @property {ICAL.Time} endDate            The end of the occurrence
         */
        /**
         * Returns the occurrence details based on its start time.  If the
         * occurrence has an exception will return the details for that exception.
         *
         * NOTE: this method is intend to be used in conjunction
         *       with the {@link ICAL.Event#iterator iterator} method.
         *
         * @param {ICAL.Time} occurrence time occurrence
         * @return {ICAL.Event.occurrenceDetails} Information about the occurrence
         */
        getOccurrenceDetails: function(occurrence) {
          var id = occurrence.toString();
          var utcId = occurrence.convertToZone(ICAL2.Timezone.utcTimezone).toString();
          var item;
          var result = {
            //XXX: Clone?
            recurrenceId: occurrence
          };
          if (id in this.exceptions) {
            item = result.item = this.exceptions[id];
            result.startDate = item.startDate;
            result.endDate = item.endDate;
            result.item = item;
          } else if (utcId in this.exceptions) {
            item = this.exceptions[utcId];
            result.startDate = item.startDate;
            result.endDate = item.endDate;
            result.item = item;
          } else {
            var rangeExceptionId = this.findRangeException(
              occurrence
            );
            var end;
            if (rangeExceptionId) {
              var exception = this.exceptions[rangeExceptionId];
              result.item = exception;
              var startDiff = this._rangeExceptionCache[rangeExceptionId];
              if (!startDiff) {
                var original = exception.recurrenceId.clone();
                var newStart = exception.startDate.clone();
                original.zone = newStart.zone;
                startDiff = newStart.subtractDate(original);
                this._rangeExceptionCache[rangeExceptionId] = startDiff;
              }
              var start = occurrence.clone();
              start.zone = exception.startDate.zone;
              start.addDuration(startDiff);
              end = start.clone();
              end.addDuration(exception.duration);
              result.startDate = start;
              result.endDate = end;
            } else {
              end = occurrence.clone();
              end.addDuration(this.duration);
              result.endDate = end;
              result.startDate = occurrence;
              result.item = this;
            }
          }
          return result;
        },
        /**
         * Builds a recur expansion instance for a specific point in time (defaults
         * to startDate).
         *
         * @param {ICAL.Time} startTime     Starting point for expansion
         * @return {ICAL.RecurExpansion}    Expansion object
         */
        iterator: function(startTime) {
          return new ICAL2.RecurExpansion({
            component: this.component,
            dtstart: startTime || this.startDate
          });
        },
        /**
         * Checks if the event is recurring
         *
         * @return {Boolean}        True, if event is recurring
         */
        isRecurring: function() {
          var comp = this.component;
          return comp.hasProperty("rrule") || comp.hasProperty("rdate");
        },
        /**
         * Checks if the event describes a recurrence exception. See
         * {@tutorial terminology} for details.
         *
         * @return {Boolean}    True, if the event describes a recurrence exception
         */
        isRecurrenceException: function() {
          return this.component.hasProperty("recurrence-id");
        },
        /**
         * Returns the types of recurrences this event may have.
         *
         * Returned as an object with the following possible keys:
         *
         *    - YEARLY
         *    - MONTHLY
         *    - WEEKLY
         *    - DAILY
         *    - MINUTELY
         *    - SECONDLY
         *
         * @return {Object.<ICAL.Recur.frequencyValues, Boolean>}
         *          Object of recurrence flags
         */
        getRecurrenceTypes: function() {
          var rules = this.component.getAllProperties("rrule");
          var i3 = 0;
          var len = rules.length;
          var result = /* @__PURE__ */ Object.create(null);
          for (; i3 < len; i3++) {
            var value = rules[i3].getFirstValue();
            result[value.freq] = true;
          }
          return result;
        },
        /**
         * The uid of this event
         * @type {String}
         */
        get uid() {
          return this._firstProp("uid");
        },
        set uid(value) {
          this._setProp("uid", value);
        },
        /**
         * The start date
         * @type {ICAL.Time}
         */
        get startDate() {
          return this._firstProp("dtstart");
        },
        set startDate(value) {
          this._setTime("dtstart", value);
        },
        /**
         * The end date. This can be the result directly from the property, or the
         * end date calculated from start date and duration. Setting the property
         * will remove any duration properties.
         * @type {ICAL.Time}
         */
        get endDate() {
          var endDate = this._firstProp("dtend");
          if (!endDate) {
            var duration = this._firstProp("duration");
            endDate = this.startDate.clone();
            if (duration) {
              endDate.addDuration(duration);
            } else if (endDate.isDate) {
              endDate.day += 1;
            }
          }
          return endDate;
        },
        set endDate(value) {
          if (this.component.hasProperty("duration")) {
            this.component.removeProperty("duration");
          }
          this._setTime("dtend", value);
        },
        /**
         * The duration. This can be the result directly from the property, or the
         * duration calculated from start date and end date. Setting the property
         * will remove any `dtend` properties.
         * @type {ICAL.Duration}
         */
        get duration() {
          var duration = this._firstProp("duration");
          if (!duration) {
            return this.endDate.subtractDateTz(this.startDate);
          }
          return duration;
        },
        set duration(value) {
          if (this.component.hasProperty("dtend")) {
            this.component.removeProperty("dtend");
          }
          this._setProp("duration", value);
        },
        /**
         * The location of the event.
         * @type {String}
         */
        get location() {
          return this._firstProp("location");
        },
        set location(value) {
          return this._setProp("location", value);
        },
        /**
         * The attendees in the event
         * @type {ICAL.Property[]}
         * @readonly
         */
        get attendees() {
          return this.component.getAllProperties("attendee");
        },
        /**
         * The event summary
         * @type {String}
         */
        get summary() {
          return this._firstProp("summary");
        },
        set summary(value) {
          this._setProp("summary", value);
        },
        /**
         * The event description.
         * @type {String}
         */
        get description() {
          return this._firstProp("description");
        },
        set description(value) {
          this._setProp("description", value);
        },
        /**
         * The event color from [rfc7986](https://datatracker.ietf.org/doc/html/rfc7986)
         * @type {String}
         */
        get color() {
          return this._firstProp("color");
        },
        set color(value) {
          this._setProp("color", value);
        },
        /**
         * The organizer value as an uri. In most cases this is a mailto: uri, but
         * it can also be something else, like urn:uuid:...
         * @type {String}
         */
        get organizer() {
          return this._firstProp("organizer");
        },
        set organizer(value) {
          this._setProp("organizer", value);
        },
        /**
         * The sequence value for this event. Used for scheduling
         * see {@tutorial terminology}.
         * @type {Number}
         */
        get sequence() {
          return this._firstProp("sequence");
        },
        set sequence(value) {
          this._setProp("sequence", value);
        },
        /**
         * The recurrence id for this event. See {@tutorial terminology} for details.
         * @type {ICAL.Time}
         */
        get recurrenceId() {
          return this._firstProp("recurrence-id");
        },
        set recurrenceId(value) {
          this._setTime("recurrence-id", value);
        },
        /**
         * Set/update a time property's value.
         * This will also update the TZID of the property.
         *
         * TODO: this method handles the case where we are switching
         * from a known timezone to an implied timezone (one without TZID).
         * This does _not_ handle the case of moving between a known
         *  (by TimezoneService) timezone to an unknown timezone...
         *
         * We will not add/remove/update the VTIMEZONE subcomponents
         *  leading to invalid ICAL data...
         * @private
         * @param {String} propName     The property name
         * @param {ICAL.Time} time      The time to set
         */
        _setTime: function(propName, time) {
          var prop = this.component.getFirstProperty(propName);
          if (!prop) {
            prop = new ICAL2.Property(propName);
            this.component.addProperty(prop);
          }
          if (time.zone === ICAL2.Timezone.localTimezone || time.zone === ICAL2.Timezone.utcTimezone) {
            prop.removeParameter("tzid");
          } else {
            prop.setParameter("tzid", time.zone.tzid);
          }
          prop.setValue(time);
        },
        _setProp: function(name, value) {
          this.component.updatePropertyWithValue(name, value);
        },
        _firstProp: function(name) {
          return this.component.getFirstPropertyValue(name);
        },
        /**
         * The string representation of this event.
         * @return {String}
         */
        toString: function() {
          return this.component.toString();
        }
      };
      function compareRangeException(a3, b3) {
        if (a3[0] > b3[0])
          return 1;
        if (b3[0] > a3[0])
          return -1;
        return 0;
      }
      return Event2;
    }();
    ICAL2.ComponentParser = function() {
      function ComponentParser(options) {
        if (typeof options === "undefined") {
          options = {};
        }
        var key;
        for (key in options) {
          if (options.hasOwnProperty(key)) {
            this[key] = options[key];
          }
        }
      }
      ComponentParser.prototype = {
        /**
         * When true, parse events
         *
         * @type {Boolean}
         */
        parseEvent: true,
        /**
         * When true, parse timezones
         *
         * @type {Boolean}
         */
        parseTimezone: true,
        /* SAX like events here for reference */
        /**
         * Fired when parsing is complete
         * @callback
         */
        oncomplete: (
          /* istanbul ignore next */
          function() {
          }
        ),
        /**
         * Fired if an error occurs during parsing.
         *
         * @callback
         * @param {Error} err details of error
         */
        onerror: (
          /* istanbul ignore next */
          function(err) {
          }
        ),
        /**
         * Fired when a top level component (VTIMEZONE) is found
         *
         * @callback
         * @param {ICAL.Timezone} component     Timezone object
         */
        ontimezone: (
          /* istanbul ignore next */
          function(component) {
          }
        ),
        /**
         * Fired when a top level component (VEVENT) is found.
         *
         * @callback
         * @param {ICAL.Event} component    Top level component
         */
        onevent: (
          /* istanbul ignore next */
          function(component) {
          }
        ),
        /**
         * Process a string or parse ical object.  This function itself will return
         * nothing but will start the parsing process.
         *
         * Events must be registered prior to calling this method.
         *
         * @param {ICAL.Component|String|Object} ical      The component to process,
         *        either in its final form, as a jCal Object, or string representation
         */
        process: function(ical) {
          if (typeof ical === "string") {
            ical = ICAL2.parse(ical);
          }
          if (!(ical instanceof ICAL2.Component)) {
            ical = new ICAL2.Component(ical);
          }
          var components = ical.getAllSubcomponents();
          var i3 = 0;
          var len = components.length;
          var component;
          for (; i3 < len; i3++) {
            component = components[i3];
            switch (component.name) {
              case "vtimezone":
                if (this.parseTimezone) {
                  var tzid = component.getFirstPropertyValue("tzid");
                  if (tzid) {
                    this.ontimezone(new ICAL2.Timezone({
                      tzid,
                      component
                    }));
                  }
                }
                break;
              case "vevent":
                if (this.parseEvent) {
                  this.onevent(new ICAL2.Event(component));
                }
                break;
              default:
                continue;
            }
          }
          this.oncomplete();
        }
      };
      return ComponentParser;
    }();
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MyPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// src/views/CalendarView.ts
var import_obsidian = require("obsidian");

// src/types.ts
var Src = class {
  constructor(path) {
    this._path = path;
    this._excludes = [];
  }
  addExcludes(excludes) {
    const isOk = excludes.every(
      (exclude) => {
        if (!exclude.startsWith(this._path))
          return false;
        if (exclude !== this._path)
          return false;
        return true;
      }
    );
    if (!isOk)
      return false;
    this._excludes.push(...excludes);
    this._excludes = this._excludes.unique();
    return true;
  }
  includes(path) {
    if (!path.startsWith(this._path)) {
      return false;
    }
    if (!this._excludes.length)
      return true;
    return this._excludes.some(
      (exclude) => {
        path.startsWith(exclude);
      }
    );
  }
  get path() {
    return this._path;
  }
  get excludes() {
    return structuredClone(this._excludes);
  }
};

// src/constants.ts
var MSG_PLG_NAME = "MyCalendar";
var EVENT_SRC = "databases";
var PLACE_FOR_CREATING_NOTE = "databases";
var daysOfWeek = ["1", "2", "3", "4", "5", "6", "0"];
var display = "background";
var COLOUR_REST = "#305B60";
var COLOUR_SLEEP = "#cc0000";
var DEFAULT_SETTINGS = {
  statusCorrector: {
    isOn: true,
    startOnStartUp: true
  },
  calendar: {
    slotDuration: "00:30:00",
    colours: {
      frequency: "#8A1717",
      done: "#008E04",
      tick: "#457E7E",
      default: "#5e3fa8"
    },
    restTime: [
      {
        daysOfWeek,
        display,
        startTime: "0:00:00",
        endTime: "8:00:00",
        color: COLOUR_SLEEP
      },
      {
        daysOfWeek,
        display,
        startTime: "24:00:00",
        endTime: "24:00:00",
        color: COLOUR_SLEEP
      },
      {
        daysOfWeek,
        display,
        startTime: "0:00:00",
        endTime: "8:30:00",
        color: COLOUR_REST
      },
      {
        daysOfWeek,
        display,
        startTime: "23:00:00",
        endTime: "24:00:00",
        color: COLOUR_REST
      }
    ]
  },
  source: {
    noteSources: [new Src(EVENT_SRC)],
    // NOTE default path where note will be created
    defaultCreatePath: PLACE_FOR_CREATING_NOTE
  }
};
var VIEW_TYPE = "my-obsidian-calendar-plugin";
var TEXT_DONE = "\u{1F7E2}done";
var TEXT_IN_PROGRESS = "\u{1F535}in progress";
var TEXT_SOON = "\u{1F7E3}soon";
var TEXT_CHILD_IN_PROGRESS = "\u{1F7E1}\u{1F7E6}child in progress";
var TEXT_BLOCKED = "\u{1F7E1}blocked";
var FORMAT_DAY = "d";
var FORMAT_HOUR = "h";
var FORMAT_MINUTE = "m";
var BACKGROUND_COLOUR = {
  hue: {
    shift: 0,
    min: 0,
    max: 360
  },
  saturation: {
    shift: 0,
    min: 70,
    max: 90
  },
  lightness: {
    shift: 0,
    min: 30,
    max: 50
  }
};
var MillisecsInSecond = 1e3;
var SecsInMinute = 60;
var MinutesInHour = 60;
var HoursInDay = 24;
var MillisecsInMinute = MillisecsInSecond * SecsInMinute;
var MillisecsInHour = MillisecsInMinute * MinutesInHour;
var MillisecsInDay = MillisecsInHour * HoursInDay;

// src/util.ts
var import_obsidian_dataview = __toESM(require_lib());
var SLEEP_TIME = 1e3;
var dv = (0, import_obsidian_dataview.getAPI)();
function pathToFileWithoutFileName(path) {
  const path_separator = path.lastIndexOf("/");
  if (path_separator !== -1)
    return path.slice(0, path_separator);
  return "";
}
function IDateToCalendarEvent(args) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
  const structure = {
    start: new Date(args.ff_date),
    allDay: false
  };
  if (args.ff_duration) {
    structure.start.setHours(((_b = (_a = args.ff_timeStart) == null ? void 0 : _a.values) == null ? void 0 : _b.hours) || 0);
    structure.start.setMinutes(((_d = (_c = args.ff_timeStart) == null ? void 0 : _c.values) == null ? void 0 : _d.minutes) || 0);
    let tmpTime = new Date(structure.start);
    if (((_f = (_e = args.ff_duration) == null ? void 0 : _e.values) == null ? void 0 : _f.minutes) || ((_h = (_g = args.ff_duration) == null ? void 0 : _g.values) == null ? void 0 : _h.hours) || ((_j = (_i = args.ff_duration) == null ? void 0 : _i.values) == null ? void 0 : _j.days)) {
      const duration = args.ff_duration.values;
      tmpTime.setMinutes(
        tmpTime.getMinutes() + (duration.minutes || 0)
      );
      tmpTime.setHours(
        tmpTime.getHours() + (duration.hours || 0)
      );
      tmpTime.setDate(
        tmpTime.getDate() + (duration.days || 0)
      );
    } else {
      structure.allDay = true;
    }
    if (!((_k = args.ff_timeStart) == null ? void 0 : _k.values))
      structure.allDay = true;
    structure.end = tmpTime;
  } else if (args.ff_duration) {
    structure.allDay = true;
  } else
    structure.allDay = true;
  return structure;
}
function CalendarEventToIDate(event) {
  const { start, end, allDay } = event;
  start.setMinutes(
    start.getMinutes() - start.getTimezoneOffset()
  );
  const result = {
    ff_duration: "",
    ff_timeStart: "",
    ff_date: new Date(start)
  };
  start.setMinutes(
    start.getMinutes() + start.getTimezoneOffset()
  );
  let srcMillisec = end ? end - start : MillisecsInHour;
  if (allDay) {
    result["ff_timeStart"] = "";
    if (srcMillisec <= MillisecsInDay)
      srcMillisec = 0;
  } else
    result["ff_timeStart"] = start.getHours() + "h" + start.getMinutes() + "m";
  result["ff_duration"] = millisecToString(srcMillisec);
  return result;
}
function getTicksFromText(text) {
  var _a, _b, _c, _d, _e;
  const result = [];
  const regExpTicks = /\[t::.+\]/gm;
  const matches = text.match(regExpTicks);
  if (matches)
    for (let match of matches) {
      const args = match.slice(1, -1).split("::")[1].split(",");
      if (!args)
        continue;
      const name = (_a = args[0]) == null ? void 0 : _a.trim();
      const ff_date = dv.date((_b = args[1]) == null ? void 0 : _b.trim());
      const ff_timeStart = dv.duration((_c = args[2]) == null ? void 0 : _c.trim());
      const tempDuration = (_d = args[3]) == null ? void 0 : _d.trim();
      const ff_duration = tempDuration == "x" ? "x" : dv.duration((_e = args[3]) == null ? void 0 : _e.trim());
      if (name == "")
        continue;
      result.push(
        { name, ff_date, ff_timeStart, ff_duration }
      );
    }
  return result;
}
function millisecToString(millisec) {
  const days = Math.floor(
    millisec / MillisecsInDay
  );
  millisec -= days * MillisecsInDay;
  const hours = Math.floor(
    millisec / MillisecsInHour
  );
  millisec -= hours * MillisecsInHour;
  const minutes = Math.floor(
    millisec / MillisecsInMinute
  );
  millisec -= minutes * MillisecsInMinute;
  let resString = "";
  if (days)
    resString += days.toString() + FORMAT_DAY;
  if (hours)
    resString += hours.toString() + FORMAT_HOUR;
  if (minutes)
    resString += minutes.toString() + FORMAT_MINUTE;
  return resString;
}
function isEqualObj(object1, object2) {
  const keys1 = Object.keys(object1);
  const keys2 = Object.keys(object2);
  if (keys1.length !== keys2.length) {
    return false;
  }
  for (const key of keys1) {
    const val1 = object1[key];
    const val2 = object2[key];
    const areObjects = isObject(val1) && isObject(val2);
    if (areObjects && !isEqualObj(val1, val2) || !areObjects && val1 !== val2) {
      return false;
    }
  }
  return true;
}
function isObject(object) {
  return object != null && typeof object === "object";
}
function templateIDTick(path, tickName) {
  return path + tickName;
}
function templateNameTick(fileName, tickName) {
  return "(" + fileName + ")" + tickName;
}
function hashString(str) {
  let hash = 0;
  for (let i3 = 0; i3 < str.length; i3++) {
    hash = (hash << 5) - hash + str.charCodeAt(i3);
    hash |= 0;
  }
  return hash;
}
function toRange(src, min, max) {
  max -= min;
  src %= max + 1;
  return src + min;
}
function getColourFromPath(path) {
  const str = pathToFileWithoutFileName(path);
  const str1 = hashString([...str].filter((_3, index8) => (index8 + 1) % 3 !== 0).join(""));
  const str2 = hashString([...str].filter((_3, index8) => (index8 + 2) % 3 !== 0).join(""));
  const str3 = hashString([...str].filter((_3, index8) => (index8 + 3) % 3 !== 0).join(""));
  const hue = toRange(
    str1 + BACKGROUND_COLOUR.hue.shift,
    BACKGROUND_COLOUR.hue.min,
    BACKGROUND_COLOUR.hue.max
  );
  const saturation = toRange(
    str2 + BACKGROUND_COLOUR.saturation.shift,
    BACKGROUND_COLOUR.saturation.min,
    BACKGROUND_COLOUR.saturation.max
  );
  const lightness = toRange(
    str3 + BACKGROUND_COLOUR.lightness.shift,
    BACKGROUND_COLOUR.lightness.min,
    BACKGROUND_COLOUR.lightness.max
  );
  return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
}
async function waitDvInit() {
  while (!dv.index.initialized)
    await sleep(SLEEP_TIME);
}
async function getNotesWithoutParent(src) {
  await waitDvInit();
  const child = dv.pages(`"${src}"`).where(
    (page) => !page.ff_parent
  ).array();
  return child;
}
async function getProgress(cache, noteManager, page) {
  const result = { done: 0, all: 0 };
  await waitDvInit();
  const pages = /* @__PURE__ */ new Set();
  const stack = [page.file.path];
  while (stack.length > 0) {
    const path = stack.pop();
    const page2 = cache.getPage(path);
    const meta = dv.page(path);
    if (!page2 || !meta)
      continue;
    const tasks = noteManager.getTaskCount(page2);
    result.all += tasks.all;
    result.done += tasks.done;
    const inlinks = meta.file.inlinks.array();
    if (page2.ff_status) {
      ++result.all;
      if (page2.ff_status == TEXT_DONE)
        ++result.done;
    }
    for (let inlink of inlinks) {
      if (pages.has(inlink.path))
        continue;
      pages.add(inlink.path);
      stack.push(inlink.path);
    }
  }
  return result;
}
async function getChildNotePaths(path) {
  await waitDvInit();
  const meta = dv.page(path);
  const inlinks = meta == null ? void 0 : meta.file.inlinks.array();
  const result = [];
  for (let inlink of inlinks) {
    result.push(inlink.path);
  }
  return result;
}
async function getParentNote(page) {
  await waitDvInit();
  const meta = dv.page(page.file.path);
  const outlinks = meta == null ? void 0 : meta.file.outlinks.array();
  const result = [];
  for (let outlink of outlinks) {
    result.push(dv.page(outlink.path));
  }
  return result;
}
function safeParseInt(str) {
  const num = Number(str);
  return Number.isInteger(num) ? num : NaN;
}
function timeAdd(start, duration) {
  const dur = duration.as("minutes");
  const result = new Date(start);
  result.setMinutes(result.getMinutes() + dur);
  return result;
}

// node_modules/@fullcalendar/core/node_modules/preact/dist/preact.module.js
var n;
var l;
var u;
var i;
var t;
var r;
var o;
var f;
var e;
var c = {};
var s = [];
var a = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
function h(n2, l3) {
  for (var u3 in l3)
    n2[u3] = l3[u3];
  return n2;
}
function v(n2) {
  var l3 = n2.parentNode;
  l3 && l3.removeChild(n2);
}
function y(l3, u3, i3) {
  var t3, r3, o2, f3 = {};
  for (o2 in u3)
    "key" == o2 ? t3 = u3[o2] : "ref" == o2 ? r3 = u3[o2] : f3[o2] = u3[o2];
  if (arguments.length > 2 && (f3.children = arguments.length > 3 ? n.call(arguments, 2) : i3), "function" == typeof l3 && null != l3.defaultProps)
    for (o2 in l3.defaultProps)
      void 0 === f3[o2] && (f3[o2] = l3.defaultProps[o2]);
  return p(l3, f3, t3, r3, null);
}
function p(n2, i3, t3, r3, o2) {
  var f3 = { type: n2, props: i3, key: t3, ref: r3, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: null == o2 ? ++u : o2 };
  return null == o2 && null != l.vnode && l.vnode(f3), f3;
}
function d() {
  return { current: null };
}
function _(n2) {
  return n2.children;
}
function k(n2, l3, u3, i3, t3) {
  var r3;
  for (r3 in u3)
    "children" === r3 || "key" === r3 || r3 in l3 || g(n2, r3, null, u3[r3], i3);
  for (r3 in l3)
    t3 && "function" != typeof l3[r3] || "children" === r3 || "key" === r3 || "value" === r3 || "checked" === r3 || u3[r3] === l3[r3] || g(n2, r3, l3[r3], u3[r3], i3);
}
function b(n2, l3, u3) {
  "-" === l3[0] ? n2.setProperty(l3, null == u3 ? "" : u3) : n2[l3] = null == u3 ? "" : "number" != typeof u3 || a.test(l3) ? u3 : u3 + "px";
}
function g(n2, l3, u3, i3, t3) {
  var r3;
  n:
    if ("style" === l3)
      if ("string" == typeof u3)
        n2.style.cssText = u3;
      else {
        if ("string" == typeof i3 && (n2.style.cssText = i3 = ""), i3)
          for (l3 in i3)
            u3 && l3 in u3 || b(n2.style, l3, "");
        if (u3)
          for (l3 in u3)
            i3 && u3[l3] === i3[l3] || b(n2.style, l3, u3[l3]);
      }
    else if ("o" === l3[0] && "n" === l3[1])
      r3 = l3 !== (l3 = l3.replace(/Capture$/, "")), l3 = l3.toLowerCase() in n2 ? l3.toLowerCase().slice(2) : l3.slice(2), n2.l || (n2.l = {}), n2.l[l3 + r3] = u3, u3 ? i3 || n2.addEventListener(l3, r3 ? w : m, r3) : n2.removeEventListener(l3, r3 ? w : m, r3);
    else if ("dangerouslySetInnerHTML" !== l3) {
      if (t3)
        l3 = l3.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
      else if ("width" !== l3 && "height" !== l3 && "href" !== l3 && "list" !== l3 && "form" !== l3 && "tabIndex" !== l3 && "download" !== l3 && l3 in n2)
        try {
          n2[l3] = null == u3 ? "" : u3;
          break n;
        } catch (n3) {
        }
      "function" == typeof u3 || (null == u3 || false === u3 && -1 == l3.indexOf("-") ? n2.removeAttribute(l3) : n2.setAttribute(l3, u3));
    }
}
function m(n2) {
  t = true;
  try {
    return this.l[n2.type + false](l.event ? l.event(n2) : n2);
  } finally {
    t = false;
  }
}
function w(n2) {
  t = true;
  try {
    return this.l[n2.type + true](l.event ? l.event(n2) : n2);
  } finally {
    t = false;
  }
}
function x(n2, l3) {
  this.props = n2, this.context = l3;
}
function A(n2, l3) {
  if (null == l3)
    return n2.__ ? A(n2.__, n2.__.__k.indexOf(n2) + 1) : null;
  for (var u3; l3 < n2.__k.length; l3++)
    if (null != (u3 = n2.__k[l3]) && null != u3.__e)
      return u3.__e;
  return "function" == typeof n2.type ? A(n2) : null;
}
function P(n2) {
  var l3, u3;
  if (null != (n2 = n2.__) && null != n2.__c) {
    for (n2.__e = n2.__c.base = null, l3 = 0; l3 < n2.__k.length; l3++)
      if (null != (u3 = n2.__k[l3]) && null != u3.__e) {
        n2.__e = n2.__c.base = u3.__e;
        break;
      }
    return P(n2);
  }
}
function C(n2) {
  t ? setTimeout(n2) : f(n2);
}
function T(n2) {
  (!n2.__d && (n2.__d = true) && r.push(n2) && !$.__r++ || o !== l.debounceRendering) && ((o = l.debounceRendering) || C)($);
}
function $() {
  var n2, l3, u3, i3, t3, o2, f3, e3;
  for (r.sort(function(n3, l4) {
    return n3.__v.__b - l4.__v.__b;
  }); n2 = r.shift(); )
    n2.__d && (l3 = r.length, i3 = void 0, t3 = void 0, f3 = (o2 = (u3 = n2).__v).__e, (e3 = u3.__P) && (i3 = [], (t3 = h({}, o2)).__v = o2.__v + 1, M(e3, o2, t3, u3.__n, void 0 !== e3.ownerSVGElement, null != o2.__h ? [f3] : null, i3, null == f3 ? A(o2) : f3, o2.__h), N(i3, o2), o2.__e != f3 && P(o2)), r.length > l3 && r.sort(function(n3, l4) {
      return n3.__v.__b - l4.__v.__b;
    }));
  $.__r = 0;
}
function H(n2, l3, u3, i3, t3, r3, o2, f3, e3, a3) {
  var h3, v3, y3, d2, k3, b3, g4, m3 = i3 && i3.__k || s, w4 = m3.length;
  for (u3.__k = [], h3 = 0; h3 < l3.length; h3++)
    if (null != (d2 = u3.__k[h3] = null == (d2 = l3[h3]) || "boolean" == typeof d2 ? null : "string" == typeof d2 || "number" == typeof d2 || "bigint" == typeof d2 ? p(null, d2, null, null, d2) : Array.isArray(d2) ? p(_, { children: d2 }, null, null, null) : d2.__b > 0 ? p(d2.type, d2.props, d2.key, d2.ref ? d2.ref : null, d2.__v) : d2)) {
      if (d2.__ = u3, d2.__b = u3.__b + 1, null === (y3 = m3[h3]) || y3 && d2.key == y3.key && d2.type === y3.type)
        m3[h3] = void 0;
      else
        for (v3 = 0; v3 < w4; v3++) {
          if ((y3 = m3[v3]) && d2.key == y3.key && d2.type === y3.type) {
            m3[v3] = void 0;
            break;
          }
          y3 = null;
        }
      M(n2, d2, y3 = y3 || c, t3, r3, o2, f3, e3, a3), k3 = d2.__e, (v3 = d2.ref) && y3.ref != v3 && (g4 || (g4 = []), y3.ref && g4.push(y3.ref, null, d2), g4.push(v3, d2.__c || k3, d2)), null != k3 ? (null == b3 && (b3 = k3), "function" == typeof d2.type && d2.__k === y3.__k ? d2.__d = e3 = I(d2, e3, n2) : e3 = z(n2, d2, y3, m3, k3, e3), "function" == typeof u3.type && (u3.__d = e3)) : e3 && y3.__e == e3 && e3.parentNode != n2 && (e3 = A(y3));
    }
  for (u3.__e = b3, h3 = w4; h3--; )
    null != m3[h3] && ("function" == typeof u3.type && null != m3[h3].__e && m3[h3].__e == u3.__d && (u3.__d = L(i3).nextSibling), q(m3[h3], m3[h3]));
  if (g4)
    for (h3 = 0; h3 < g4.length; h3++)
      S(g4[h3], g4[++h3], g4[++h3]);
}
function I(n2, l3, u3) {
  for (var i3, t3 = n2.__k, r3 = 0; t3 && r3 < t3.length; r3++)
    (i3 = t3[r3]) && (i3.__ = n2, l3 = "function" == typeof i3.type ? I(i3, l3, u3) : z(u3, i3, i3, t3, i3.__e, l3));
  return l3;
}
function j(n2, l3) {
  return l3 = l3 || [], null == n2 || "boolean" == typeof n2 || (Array.isArray(n2) ? n2.some(function(n3) {
    j(n3, l3);
  }) : l3.push(n2)), l3;
}
function z(n2, l3, u3, i3, t3, r3) {
  var o2, f3, e3;
  if (void 0 !== l3.__d)
    o2 = l3.__d, l3.__d = void 0;
  else if (null == u3 || t3 != r3 || null == t3.parentNode)
    n:
      if (null == r3 || r3.parentNode !== n2)
        n2.appendChild(t3), o2 = null;
      else {
        for (f3 = r3, e3 = 0; (f3 = f3.nextSibling) && e3 < i3.length; e3 += 1)
          if (f3 == t3)
            break n;
        n2.insertBefore(t3, r3), o2 = r3;
      }
  return void 0 !== o2 ? o2 : t3.nextSibling;
}
function L(n2) {
  var l3, u3, i3;
  if (null == n2.type || "string" == typeof n2.type)
    return n2.__e;
  if (n2.__k) {
    for (l3 = n2.__k.length - 1; l3 >= 0; l3--)
      if ((u3 = n2.__k[l3]) && (i3 = L(u3)))
        return i3;
  }
  return null;
}
function M(n2, u3, i3, t3, r3, o2, f3, e3, c3) {
  var s3, a3, v3, y3, p3, d2, k3, b3, g4, m3, w4, A3, P3, C3, T4, $3 = u3.type;
  if (void 0 !== u3.constructor)
    return null;
  null != i3.__h && (c3 = i3.__h, e3 = u3.__e = i3.__e, u3.__h = null, o2 = [e3]), (s3 = l.__b) && s3(u3);
  try {
    n:
      if ("function" == typeof $3) {
        if (b3 = u3.props, g4 = (s3 = $3.contextType) && t3[s3.__c], m3 = s3 ? g4 ? g4.props.value : s3.__ : t3, i3.__c ? k3 = (a3 = u3.__c = i3.__c).__ = a3.__E : ("prototype" in $3 && $3.prototype.render ? u3.__c = a3 = new $3(b3, m3) : (u3.__c = a3 = new x(b3, m3), a3.constructor = $3, a3.render = B), g4 && g4.sub(a3), a3.props = b3, a3.state || (a3.state = {}), a3.context = m3, a3.__n = t3, v3 = a3.__d = true, a3.__h = [], a3._sb = []), null == a3.__s && (a3.__s = a3.state), null != $3.getDerivedStateFromProps && (a3.__s == a3.state && (a3.__s = h({}, a3.__s)), h(a3.__s, $3.getDerivedStateFromProps(b3, a3.__s))), y3 = a3.props, p3 = a3.state, a3.__v = u3, v3)
          null == $3.getDerivedStateFromProps && null != a3.componentWillMount && a3.componentWillMount(), null != a3.componentDidMount && a3.__h.push(a3.componentDidMount);
        else {
          if (null == $3.getDerivedStateFromProps && b3 !== y3 && null != a3.componentWillReceiveProps && a3.componentWillReceiveProps(b3, m3), !a3.__e && null != a3.shouldComponentUpdate && false === a3.shouldComponentUpdate(b3, a3.__s, m3) || u3.__v === i3.__v) {
            for (u3.__v !== i3.__v && (a3.props = b3, a3.state = a3.__s, a3.__d = false), u3.__e = i3.__e, u3.__k = i3.__k, u3.__k.forEach(function(n3) {
              n3 && (n3.__ = u3);
            }), w4 = 0; w4 < a3._sb.length; w4++)
              a3.__h.push(a3._sb[w4]);
            a3._sb = [], a3.__h.length && f3.push(a3);
            break n;
          }
          null != a3.componentWillUpdate && a3.componentWillUpdate(b3, a3.__s, m3), null != a3.componentDidUpdate && a3.__h.push(function() {
            a3.componentDidUpdate(y3, p3, d2);
          });
        }
        if (a3.context = m3, a3.props = b3, a3.__P = n2, A3 = l.__r, P3 = 0, "prototype" in $3 && $3.prototype.render) {
          for (a3.state = a3.__s, a3.__d = false, A3 && A3(u3), s3 = a3.render(a3.props, a3.state, a3.context), C3 = 0; C3 < a3._sb.length; C3++)
            a3.__h.push(a3._sb[C3]);
          a3._sb = [];
        } else
          do {
            a3.__d = false, A3 && A3(u3), s3 = a3.render(a3.props, a3.state, a3.context), a3.state = a3.__s;
          } while (a3.__d && ++P3 < 25);
        a3.state = a3.__s, null != a3.getChildContext && (t3 = h(h({}, t3), a3.getChildContext())), v3 || null == a3.getSnapshotBeforeUpdate || (d2 = a3.getSnapshotBeforeUpdate(y3, p3)), T4 = null != s3 && s3.type === _ && null == s3.key ? s3.props.children : s3, H(n2, Array.isArray(T4) ? T4 : [T4], u3, i3, t3, r3, o2, f3, e3, c3), a3.base = u3.__e, u3.__h = null, a3.__h.length && f3.push(a3), k3 && (a3.__E = a3.__ = null), a3.__e = false;
      } else
        null == o2 && u3.__v === i3.__v ? (u3.__k = i3.__k, u3.__e = i3.__e) : u3.__e = O(i3.__e, u3, i3, t3, r3, o2, f3, c3);
    (s3 = l.diffed) && s3(u3);
  } catch (n3) {
    u3.__v = null, (c3 || null != o2) && (u3.__e = e3, u3.__h = !!c3, o2[o2.indexOf(e3)] = null), l.__e(n3, u3, i3);
  }
}
function N(n2, u3) {
  l.__c && l.__c(u3, n2), n2.some(function(u4) {
    try {
      n2 = u4.__h, u4.__h = [], n2.some(function(n3) {
        n3.call(u4);
      });
    } catch (n3) {
      l.__e(n3, u4.__v);
    }
  });
}
function O(l3, u3, i3, t3, r3, o2, f3, e3) {
  var s3, a3, h3, y3 = i3.props, p3 = u3.props, d2 = u3.type, _3 = 0;
  if ("svg" === d2 && (r3 = true), null != o2) {
    for (; _3 < o2.length; _3++)
      if ((s3 = o2[_3]) && "setAttribute" in s3 == !!d2 && (d2 ? s3.localName === d2 : 3 === s3.nodeType)) {
        l3 = s3, o2[_3] = null;
        break;
      }
  }
  if (null == l3) {
    if (null === d2)
      return document.createTextNode(p3);
    l3 = r3 ? document.createElementNS("http://www.w3.org/2000/svg", d2) : document.createElement(d2, p3.is && p3), o2 = null, e3 = false;
  }
  if (null === d2)
    y3 === p3 || e3 && l3.data === p3 || (l3.data = p3);
  else {
    if (o2 = o2 && n.call(l3.childNodes), a3 = (y3 = i3.props || c).dangerouslySetInnerHTML, h3 = p3.dangerouslySetInnerHTML, !e3) {
      if (null != o2)
        for (y3 = {}, _3 = 0; _3 < l3.attributes.length; _3++)
          y3[l3.attributes[_3].name] = l3.attributes[_3].value;
      (h3 || a3) && (h3 && (a3 && h3.__html == a3.__html || h3.__html === l3.innerHTML) || (l3.innerHTML = h3 && h3.__html || ""));
    }
    if (k(l3, p3, y3, r3, e3), h3)
      u3.__k = [];
    else if (_3 = u3.props.children, H(l3, Array.isArray(_3) ? _3 : [_3], u3, i3, t3, r3 && "foreignObject" !== d2, o2, f3, o2 ? o2[0] : i3.__k && A(i3, 0), e3), null != o2)
      for (_3 = o2.length; _3--; )
        null != o2[_3] && v(o2[_3]);
    e3 || ("value" in p3 && void 0 !== (_3 = p3.value) && (_3 !== l3.value || "progress" === d2 && !_3 || "option" === d2 && _3 !== y3.value) && g(l3, "value", _3, y3.value, false), "checked" in p3 && void 0 !== (_3 = p3.checked) && _3 !== l3.checked && g(l3, "checked", _3, y3.checked, false));
  }
  return l3;
}
function S(n2, u3, i3) {
  try {
    "function" == typeof n2 ? n2(u3) : n2.current = u3;
  } catch (n3) {
    l.__e(n3, i3);
  }
}
function q(n2, u3, i3) {
  var t3, r3;
  if (l.unmount && l.unmount(n2), (t3 = n2.ref) && (t3.current && t3.current !== n2.__e || S(t3, null, u3)), null != (t3 = n2.__c)) {
    if (t3.componentWillUnmount)
      try {
        t3.componentWillUnmount();
      } catch (n3) {
        l.__e(n3, u3);
      }
    t3.base = t3.__P = null, n2.__c = void 0;
  }
  if (t3 = n2.__k)
    for (r3 = 0; r3 < t3.length; r3++)
      t3[r3] && q(t3[r3], u3, i3 || "function" != typeof n2.type);
  i3 || null == n2.__e || v(n2.__e), n2.__ = n2.__e = n2.__d = void 0;
}
function B(n2, l3, u3) {
  return this.constructor(n2, u3);
}
function D(u3, i3, t3) {
  var r3, o2, f3;
  l.__ && l.__(u3, i3), o2 = (r3 = "function" == typeof t3) ? null : t3 && t3.__k || i3.__k, f3 = [], M(i3, u3 = (!r3 && t3 || i3).__k = y(_, null, [u3]), o2 || c, c, void 0 !== i3.ownerSVGElement, !r3 && t3 ? [t3] : o2 ? null : i3.firstChild ? n.call(i3.childNodes) : null, f3, !r3 && t3 ? t3 : o2 ? o2.__e : i3.firstChild, r3), N(f3, u3);
}
function G(n2, l3) {
  var u3 = { __c: l3 = "__cC" + e++, __: n2, Consumer: function(n3, l4) {
    return n3.children(l4);
  }, Provider: function(n3) {
    var u4, i3;
    return this.getChildContext || (u4 = [], (i3 = {})[l3] = this, this.getChildContext = function() {
      return i3;
    }, this.shouldComponentUpdate = function(n4) {
      this.props.value !== n4.value && u4.some(function(n5) {
        n5.__e = true, T(n5);
      });
    }, this.sub = function(n4) {
      u4.push(n4);
      var l4 = n4.componentWillUnmount;
      n4.componentWillUnmount = function() {
        u4.splice(u4.indexOf(n4), 1), l4 && l4.call(n4);
      };
    }), n3.children;
  } };
  return u3.Provider.__ = u3.Consumer.contextType = u3;
}
n = s.slice, l = { __e: function(n2, l3, u3, i3) {
  for (var t3, r3, o2; l3 = l3.__; )
    if ((t3 = l3.__c) && !t3.__)
      try {
        if ((r3 = t3.constructor) && null != r3.getDerivedStateFromError && (t3.setState(r3.getDerivedStateFromError(n2)), o2 = t3.__d), null != t3.componentDidCatch && (t3.componentDidCatch(n2, i3 || {}), o2 = t3.__d), o2)
          return t3.__E = t3;
      } catch (l4) {
        n2 = l4;
      }
  throw n2;
} }, u = 0, i = function(n2) {
  return null != n2 && void 0 === n2.constructor;
}, t = false, x.prototype.setState = function(n2, l3) {
  var u3;
  u3 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = h({}, this.state), "function" == typeof n2 && (n2 = n2(h({}, u3), this.props)), n2 && h(u3, n2), null != n2 && this.__v && (l3 && this._sb.push(l3), T(this));
}, x.prototype.forceUpdate = function(n2) {
  this.__v && (this.__e = true, n2 && this.__h.push(n2), T(this));
}, x.prototype.render = _, r = [], f = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, $.__r = 0, e = 0;

// node_modules/@fullcalendar/core/node_modules/preact/hooks/dist/hooks.module.js
var t2;
var r2;
var u2;
var i2;
var f2 = [];
var c2 = [];
var e2 = l.__b;
var a2 = l.__r;
var v2 = l.diffed;
var l2 = l.__c;
var m2 = l.unmount;
function b2() {
  for (var t3; t3 = f2.shift(); )
    if (t3.__P && t3.__H)
      try {
        t3.__H.__h.forEach(k2), t3.__H.__h.forEach(w2), t3.__H.__h = [];
      } catch (r3) {
        t3.__H.__h = [], l.__e(r3, t3.__v);
      }
}
l.__b = function(n2) {
  r2 = null, e2 && e2(n2);
}, l.__r = function(n2) {
  a2 && a2(n2), t2 = 0;
  var i3 = (r2 = n2.__c).__H;
  i3 && (u2 === r2 ? (i3.__h = [], r2.__h = [], i3.__.forEach(function(n3) {
    n3.__N && (n3.__ = n3.__N), n3.__V = c2, n3.__N = n3.i = void 0;
  })) : (i3.__h.forEach(k2), i3.__h.forEach(w2), i3.__h = [])), u2 = r2;
}, l.diffed = function(t3) {
  v2 && v2(t3);
  var o2 = t3.__c;
  o2 && o2.__H && (o2.__H.__h.length && (1 !== f2.push(o2) && i2 === l.requestAnimationFrame || ((i2 = l.requestAnimationFrame) || j2)(b2)), o2.__H.__.forEach(function(n2) {
    n2.i && (n2.__H = n2.i), n2.__V !== c2 && (n2.__ = n2.__V), n2.i = void 0, n2.__V = c2;
  })), u2 = r2 = null;
}, l.__c = function(t3, r3) {
  r3.some(function(t4) {
    try {
      t4.__h.forEach(k2), t4.__h = t4.__h.filter(function(n2) {
        return !n2.__ || w2(n2);
      });
    } catch (u3) {
      r3.some(function(n2) {
        n2.__h && (n2.__h = []);
      }), r3 = [], l.__e(u3, t4.__v);
    }
  }), l2 && l2(t3, r3);
}, l.unmount = function(t3) {
  m2 && m2(t3);
  var r3, u3 = t3.__c;
  u3 && u3.__H && (u3.__H.__.forEach(function(n2) {
    try {
      k2(n2);
    } catch (n3) {
      r3 = n3;
    }
  }), u3.__H = void 0, r3 && l.__e(r3, u3.__v));
};
var g2 = "function" == typeof requestAnimationFrame;
function j2(n2) {
  var t3, r3 = function() {
    clearTimeout(u3), g2 && cancelAnimationFrame(t3), setTimeout(n2);
  }, u3 = setTimeout(r3, 100);
  g2 && (t3 = requestAnimationFrame(r3));
}
function k2(n2) {
  var t3 = r2, u3 = n2.__c;
  "function" == typeof u3 && (n2.__c = void 0, u3()), r2 = t3;
}
function w2(n2) {
  var t3 = r2;
  n2.__c = n2.__(), r2 = t3;
}

// node_modules/@fullcalendar/core/node_modules/preact/compat/dist/compat.module.js
function g3(n2, t3) {
  for (var e3 in t3)
    n2[e3] = t3[e3];
  return n2;
}
function C2(n2, t3) {
  for (var e3 in n2)
    if ("__source" !== e3 && !(e3 in t3))
      return true;
  for (var r3 in t3)
    if ("__source" !== r3 && n2[r3] !== t3[r3])
      return true;
  return false;
}
function w3(n2) {
  this.props = n2;
}
(w3.prototype = new x()).isPureReactComponent = true, w3.prototype.shouldComponentUpdate = function(n2, t3) {
  return C2(this.props, n2) || C2(this.state, t3);
};
var x3 = l.__b;
l.__b = function(n2) {
  n2.type && n2.type.__f && n2.ref && (n2.props.ref = n2.ref, n2.ref = null), x3 && x3(n2);
};
var N2 = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.forward_ref") || 3911;
var T3 = l.__e;
l.__e = function(n2, t3, e3, r3) {
  if (n2.then) {
    for (var u3, o2 = t3; o2 = o2.__; )
      if ((u3 = o2.__c) && u3.__c)
        return null == t3.__e && (t3.__e = e3.__e, t3.__k = e3.__k), u3.__c(n2, t3);
  }
  T3(n2, t3, e3, r3);
};
var I2 = l.unmount;
function L2(n2, t3, e3) {
  return n2 && (n2.__c && n2.__c.__H && (n2.__c.__H.__.forEach(function(n3) {
    "function" == typeof n3.__c && n3.__c();
  }), n2.__c.__H = null), null != (n2 = g3({}, n2)).__c && (n2.__c.__P === e3 && (n2.__c.__P = t3), n2.__c = null), n2.__k = n2.__k && n2.__k.map(function(n3) {
    return L2(n3, t3, e3);
  })), n2;
}
function U(n2, t3, e3) {
  return n2 && (n2.__v = null, n2.__k = n2.__k && n2.__k.map(function(n3) {
    return U(n3, t3, e3);
  }), n2.__c && n2.__c.__P === t3 && (n2.__e && e3.insertBefore(n2.__e, n2.__d), n2.__c.__e = true, n2.__c.__P = e3)), n2;
}
function D2() {
  this.__u = 0, this.t = null, this.__b = null;
}
function F3(n2) {
  var t3 = n2.__.__c;
  return t3 && t3.__a && t3.__a(n2);
}
function V2() {
  this.u = null, this.o = null;
}
l.unmount = function(n2) {
  var t3 = n2.__c;
  t3 && t3.__R && t3.__R(), t3 && true === n2.__h && (n2.type = null), I2 && I2(n2);
}, (D2.prototype = new x()).__c = function(n2, t3) {
  var e3 = t3.__c, r3 = this;
  null == r3.t && (r3.t = []), r3.t.push(e3);
  var u3 = F3(r3.__v), o2 = false, i3 = function() {
    o2 || (o2 = true, e3.__R = null, u3 ? u3(l3) : l3());
  };
  e3.__R = i3;
  var l3 = function() {
    if (!--r3.__u) {
      if (r3.state.__a) {
        var n3 = r3.state.__a;
        r3.__v.__k[0] = U(n3, n3.__c.__P, n3.__c.__O);
      }
      var t4;
      for (r3.setState({ __a: r3.__b = null }); t4 = r3.t.pop(); )
        t4.forceUpdate();
    }
  }, c3 = true === t3.__h;
  r3.__u++ || c3 || r3.setState({ __a: r3.__b = r3.__v.__k[0] }), n2.then(i3, i3);
}, D2.prototype.componentWillUnmount = function() {
  this.t = [];
}, D2.prototype.render = function(n2, e3) {
  if (this.__b) {
    if (this.__v.__k) {
      var r3 = document.createElement("div"), o2 = this.__v.__k[0].__c;
      this.__v.__k[0] = L2(this.__b, r3, o2.__O = o2.__P);
    }
    this.__b = null;
  }
  var i3 = e3.__a && y(_, null, n2.fallback);
  return i3 && (i3.__h = null), [y(_, null, e3.__a ? null : n2.children), i3];
};
var W = function(n2, t3, e3) {
  if (++e3[1] === e3[0] && n2.o.delete(t3), n2.props.revealOrder && ("t" !== n2.props.revealOrder[0] || !n2.o.size))
    for (e3 = n2.u; e3; ) {
      for (; e3.length > 3; )
        e3.pop()();
      if (e3[1] < e3[0])
        break;
      n2.u = e3 = e3[2];
    }
};
function P2(n2) {
  return this.getChildContext = function() {
    return n2.context;
  }, n2.children;
}
function $2(n2) {
  var e3 = this, r3 = n2.i;
  e3.componentWillUnmount = function() {
    D(null, e3.l), e3.l = null, e3.i = null;
  }, e3.i && e3.i !== r3 && e3.componentWillUnmount(), n2.__v ? (e3.l || (e3.i = r3, e3.l = { nodeType: 1, parentNode: r3, childNodes: [], appendChild: function(n3) {
    this.childNodes.push(n3), e3.i.appendChild(n3);
  }, insertBefore: function(n3, t3) {
    this.childNodes.push(n3), e3.i.appendChild(n3);
  }, removeChild: function(n3) {
    this.childNodes.splice(this.childNodes.indexOf(n3) >>> 1, 1), e3.i.removeChild(n3);
  } }), D(y(P2, { context: e3.context }, n2.__v), e3.l)) : e3.l && e3.componentWillUnmount();
}
function j3(n2, e3) {
  var r3 = y($2, { __v: n2, i: e3 });
  return r3.containerInfo = e3, r3;
}
(V2.prototype = new x()).__a = function(n2) {
  var t3 = this, e3 = F3(t3.__v), r3 = t3.o.get(n2);
  return r3[0]++, function(u3) {
    var o2 = function() {
      t3.props.revealOrder ? (r3.push(u3), W(t3, n2, r3)) : u3();
    };
    e3 ? e3(o2) : o2();
  };
}, V2.prototype.render = function(n2) {
  this.u = null, this.o = /* @__PURE__ */ new Map();
  var t3 = j(n2.children);
  n2.revealOrder && "b" === n2.revealOrder[0] && t3.reverse();
  for (var e3 = t3.length; e3--; )
    this.o.set(t3[e3], this.u = [1, 0, this.u]);
  return n2.children;
}, V2.prototype.componentDidUpdate = V2.prototype.componentDidMount = function() {
  var n2 = this;
  this.o.forEach(function(t3, e3) {
    W(n2, e3, t3);
  });
};
var z2 = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103;
var B2 = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;
var H2 = "undefined" != typeof document;
var Z = function(n2) {
  return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/i : /fil|che|ra/i).test(n2);
};
x.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function(t3) {
  Object.defineProperty(x.prototype, t3, { configurable: true, get: function() {
    return this["UNSAFE_" + t3];
  }, set: function(n2) {
    Object.defineProperty(this, t3, { configurable: true, writable: true, value: n2 });
  } });
});
var G2 = l.event;
function J() {
}
function K() {
  return this.cancelBubble;
}
function Q() {
  return this.defaultPrevented;
}
l.event = function(n2) {
  return G2 && (n2 = G2(n2)), n2.persist = J, n2.isPropagationStopped = K, n2.isDefaultPrevented = Q, n2.nativeEvent = n2;
};
var X;
var nn = { configurable: true, get: function() {
  return this.class;
} };
var tn = l.vnode;
l.vnode = function(n2) {
  var t3 = n2.type, e3 = n2.props, u3 = e3;
  if ("string" == typeof t3) {
    var o2 = -1 === t3.indexOf("-");
    for (var i3 in u3 = {}, e3) {
      var l3 = e3[i3];
      H2 && "children" === i3 && "noscript" === t3 || "value" === i3 && "defaultValue" in e3 && null == l3 || ("defaultValue" === i3 && "value" in e3 && null == e3.value ? i3 = "value" : "download" === i3 && true === l3 ? l3 = "" : /ondoubleclick/i.test(i3) ? i3 = "ondblclick" : /^onchange(textarea|input)/i.test(i3 + t3) && !Z(e3.type) ? i3 = "oninput" : /^onfocus$/i.test(i3) ? i3 = "onfocusin" : /^onblur$/i.test(i3) ? i3 = "onfocusout" : /^on(Ani|Tra|Tou|BeforeInp|Compo)/.test(i3) ? i3 = i3.toLowerCase() : o2 && B2.test(i3) ? i3 = i3.replace(/[A-Z0-9]/g, "-$&").toLowerCase() : null === l3 && (l3 = void 0), /^oninput$/i.test(i3) && (i3 = i3.toLowerCase(), u3[i3] && (i3 = "oninputCapture")), u3[i3] = l3);
    }
    "select" == t3 && u3.multiple && Array.isArray(u3.value) && (u3.value = j(e3.children).forEach(function(n3) {
      n3.props.selected = -1 != u3.value.indexOf(n3.props.value);
    })), "select" == t3 && null != u3.defaultValue && (u3.value = j(e3.children).forEach(function(n3) {
      n3.props.selected = u3.multiple ? -1 != u3.defaultValue.indexOf(n3.props.value) : u3.defaultValue == n3.props.value;
    })), n2.props = u3, e3.class != e3.className && (nn.enumerable = "className" in e3, null != e3.className && (u3.class = e3.className), Object.defineProperty(u3, "className", nn));
  }
  n2.$$typeof = z2, tn && tn(n2);
};
var en = l.__r;
l.__r = function(n2) {
  en && en(n2), X = n2.__c;
};

// node_modules/@fullcalendar/core/internal-common.js
var styleTexts = [];
var styleEls = /* @__PURE__ */ new Map();
function injectStyles(styleText) {
  styleTexts.push(styleText);
  styleEls.forEach((styleEl) => {
    appendStylesTo(styleEl, styleText);
  });
}
function ensureElHasStyles(el) {
  if (el.isConnected && // sometimes true if SSR system simulates DOM
  el.getRootNode) {
    registerStylesRoot(el.getRootNode());
  }
}
function registerStylesRoot(rootNode) {
  let styleEl = styleEls.get(rootNode);
  if (!styleEl || !styleEl.isConnected) {
    styleEl = rootNode.querySelector("style[data-fullcalendar]");
    if (!styleEl) {
      styleEl = document.createElement("style");
      styleEl.setAttribute("data-fullcalendar", "");
      const nonce = getNonceValue();
      if (nonce) {
        styleEl.nonce = nonce;
      }
      const parentEl = rootNode === document ? document.head : rootNode;
      const insertBefore = rootNode === document ? parentEl.querySelector("script,link[rel=stylesheet],link[as=style],style") : parentEl.firstChild;
      parentEl.insertBefore(styleEl, insertBefore);
    }
    styleEls.set(rootNode, styleEl);
    hydrateStylesRoot(styleEl);
  }
}
function hydrateStylesRoot(styleEl) {
  for (const styleText of styleTexts) {
    appendStylesTo(styleEl, styleText);
  }
}
function appendStylesTo(styleEl, styleText) {
  const { sheet } = styleEl;
  const ruleCnt = sheet.cssRules.length;
  styleText.split("}").forEach((styleStr, i3) => {
    styleStr = styleStr.trim();
    if (styleStr) {
      sheet.insertRule(styleStr + "}", ruleCnt + i3);
    }
  });
}
var queriedNonceValue;
function getNonceValue() {
  if (queriedNonceValue === void 0) {
    queriedNonceValue = queryNonceValue();
  }
  return queriedNonceValue;
}
function queryNonceValue() {
  const metaWithNonce = document.querySelector('meta[name="csp-nonce"]');
  if (metaWithNonce && metaWithNonce.hasAttribute("content")) {
    return metaWithNonce.getAttribute("content");
  }
  const elWithNonce = document.querySelector("script[nonce]");
  if (elWithNonce) {
    return elWithNonce.nonce || "";
  }
  return "";
}
if (typeof document !== "undefined") {
  registerStylesRoot(document);
}
var css_248z = ':root{--fc-small-font-size:.85em;--fc-page-bg-color:#fff;--fc-neutral-bg-color:hsla(0,0%,82%,.3);--fc-neutral-text-color:grey;--fc-border-color:#ddd;--fc-button-text-color:#fff;--fc-button-bg-color:#2c3e50;--fc-button-border-color:#2c3e50;--fc-button-hover-bg-color:#1e2b37;--fc-button-hover-border-color:#1a252f;--fc-button-active-bg-color:#1a252f;--fc-button-active-border-color:#151e27;--fc-event-bg-color:#3788d8;--fc-event-border-color:#3788d8;--fc-event-text-color:#fff;--fc-event-selected-overlay-color:rgba(0,0,0,.25);--fc-more-link-bg-color:#d0d0d0;--fc-more-link-text-color:inherit;--fc-event-resizer-thickness:8px;--fc-event-resizer-dot-total-width:8px;--fc-event-resizer-dot-border-width:1px;--fc-non-business-color:hsla(0,0%,84%,.3);--fc-bg-event-color:#8fdf82;--fc-bg-event-opacity:0.3;--fc-highlight-color:rgba(188,232,241,.3);--fc-today-bg-color:rgba(255,220,40,.15);--fc-now-indicator-color:red}.fc-not-allowed,.fc-not-allowed .fc-event{cursor:not-allowed}.fc{display:flex;flex-direction:column;font-size:1em}.fc,.fc *,.fc :after,.fc :before{box-sizing:border-box}.fc table{border-collapse:collapse;border-spacing:0;font-size:1em}.fc th{text-align:center}.fc td,.fc th{padding:0;vertical-align:top}.fc a[data-navlink]{cursor:pointer}.fc a[data-navlink]:hover{text-decoration:underline}.fc-direction-ltr{direction:ltr;text-align:left}.fc-direction-rtl{direction:rtl;text-align:right}.fc-theme-standard td,.fc-theme-standard th{border:1px solid var(--fc-border-color)}.fc-liquid-hack td,.fc-liquid-hack th{position:relative}@font-face{font-family:fcicons;font-style:normal;font-weight:400;src:url("data:application/x-font-ttf;charset=utf-8;base64,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") format("truetype")}.fc-icon{speak:none;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;display:inline-block;font-family:fcicons!important;font-style:normal;font-variant:normal;font-weight:400;height:1em;line-height:1;text-align:center;text-transform:none;-moz-user-select:none;user-select:none;width:1em}.fc-icon-chevron-left:before{content:"\\e900"}.fc-icon-chevron-right:before{content:"\\e901"}.fc-icon-chevrons-left:before{content:"\\e902"}.fc-icon-chevrons-right:before{content:"\\e903"}.fc-icon-minus-square:before{content:"\\e904"}.fc-icon-plus-square:before{content:"\\e905"}.fc-icon-x:before{content:"\\e906"}.fc .fc-button{border-radius:0;font-family:inherit;font-size:inherit;line-height:inherit;margin:0;overflow:visible;text-transform:none}.fc .fc-button:focus{outline:1px dotted;outline:5px auto -webkit-focus-ring-color}.fc .fc-button{-webkit-appearance:button}.fc .fc-button:not(:disabled){cursor:pointer}.fc .fc-button{background-color:transparent;border:1px solid transparent;border-radius:.25em;display:inline-block;font-size:1em;font-weight:400;line-height:1.5;padding:.4em .65em;text-align:center;-moz-user-select:none;user-select:none;vertical-align:middle}.fc .fc-button:hover{text-decoration:none}.fc .fc-button:focus{box-shadow:0 0 0 .2rem rgba(44,62,80,.25);outline:0}.fc .fc-button:disabled{opacity:.65}.fc .fc-button-primary{background-color:var(--fc-button-bg-color);border-color:var(--fc-button-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:hover{background-color:var(--fc-button-hover-bg-color);border-color:var(--fc-button-hover-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:disabled{background-color:var(--fc-button-bg-color);border-color:var(--fc-button-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:focus{box-shadow:0 0 0 .2rem rgba(76,91,106,.5)}.fc .fc-button-primary:not(:disabled).fc-button-active,.fc .fc-button-primary:not(:disabled):active{background-color:var(--fc-button-active-bg-color);border-color:var(--fc-button-active-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:not(:disabled).fc-button-active:focus,.fc .fc-button-primary:not(:disabled):active:focus{box-shadow:0 0 0 .2rem rgba(76,91,106,.5)}.fc .fc-button .fc-icon{font-size:1.5em;vertical-align:middle}.fc .fc-button-group{display:inline-flex;position:relative;vertical-align:middle}.fc .fc-button-group>.fc-button{flex:1 1 auto;position:relative}.fc .fc-button-group>.fc-button.fc-button-active,.fc .fc-button-group>.fc-button:active,.fc .fc-button-group>.fc-button:focus,.fc .fc-button-group>.fc-button:hover{z-index:1}.fc-direction-ltr .fc-button-group>.fc-button:not(:first-child){border-bottom-left-radius:0;border-top-left-radius:0;margin-left:-1px}.fc-direction-ltr .fc-button-group>.fc-button:not(:last-child){border-bottom-right-radius:0;border-top-right-radius:0}.fc-direction-rtl .fc-button-group>.fc-button:not(:first-child){border-bottom-right-radius:0;border-top-right-radius:0;margin-right:-1px}.fc-direction-rtl .fc-button-group>.fc-button:not(:last-child){border-bottom-left-radius:0;border-top-left-radius:0}.fc .fc-toolbar{align-items:center;display:flex;justify-content:space-between}.fc .fc-toolbar.fc-header-toolbar{margin-bottom:1.5em}.fc .fc-toolbar.fc-footer-toolbar{margin-top:1.5em}.fc .fc-toolbar-title{font-size:1.75em;margin:0}.fc-direction-ltr .fc-toolbar>*>:not(:first-child){margin-left:.75em}.fc-direction-rtl .fc-toolbar>*>:not(:first-child){margin-right:.75em}.fc-direction-rtl .fc-toolbar-ltr{flex-direction:row-reverse}.fc .fc-scroller{-webkit-overflow-scrolling:touch;position:relative}.fc .fc-scroller-liquid{height:100%}.fc .fc-scroller-liquid-absolute{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-scroller-harness{direction:ltr;overflow:hidden;position:relative}.fc .fc-scroller-harness-liquid{height:100%}.fc-direction-rtl .fc-scroller-harness>.fc-scroller{direction:rtl}.fc-theme-standard .fc-scrollgrid{border:1px solid var(--fc-border-color)}.fc .fc-scrollgrid,.fc .fc-scrollgrid table{table-layout:fixed;width:100%}.fc .fc-scrollgrid table{border-left-style:hidden;border-right-style:hidden;border-top-style:hidden}.fc .fc-scrollgrid{border-bottom-width:0;border-collapse:separate;border-right-width:0}.fc .fc-scrollgrid-liquid{height:100%}.fc .fc-scrollgrid-section,.fc .fc-scrollgrid-section table,.fc .fc-scrollgrid-section>td{height:1px}.fc .fc-scrollgrid-section-liquid>td{height:100%}.fc .fc-scrollgrid-section>*{border-left-width:0;border-top-width:0}.fc .fc-scrollgrid-section-footer>*,.fc .fc-scrollgrid-section-header>*{border-bottom-width:0}.fc .fc-scrollgrid-section-body table,.fc .fc-scrollgrid-section-footer table{border-bottom-style:hidden}.fc .fc-scrollgrid-section-sticky>*{background:var(--fc-page-bg-color);position:sticky;z-index:3}.fc .fc-scrollgrid-section-header.fc-scrollgrid-section-sticky>*{top:0}.fc .fc-scrollgrid-section-footer.fc-scrollgrid-section-sticky>*{bottom:0}.fc .fc-scrollgrid-sticky-shim{height:1px;margin-bottom:-1px}.fc-sticky{position:sticky}.fc .fc-view-harness{flex-grow:1;position:relative}.fc .fc-view-harness-active>.fc-view{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-col-header-cell-cushion{display:inline-block;padding:2px 4px}.fc .fc-bg-event,.fc .fc-highlight,.fc .fc-non-business{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-non-business{background:var(--fc-non-business-color)}.fc .fc-bg-event{background:var(--fc-bg-event-color);opacity:var(--fc-bg-event-opacity)}.fc .fc-bg-event .fc-event-title{font-size:var(--fc-small-font-size);font-style:italic;margin:.5em}.fc .fc-highlight{background:var(--fc-highlight-color)}.fc .fc-cell-shaded,.fc .fc-day-disabled{background:var(--fc-neutral-bg-color)}a.fc-event,a.fc-event:hover{text-decoration:none}.fc-event.fc-event-draggable,.fc-event[href]{cursor:pointer}.fc-event .fc-event-main{position:relative;z-index:2}.fc-event-dragging:not(.fc-event-selected){opacity:.75}.fc-event-dragging.fc-event-selected{box-shadow:0 2px 7px rgba(0,0,0,.3)}.fc-event .fc-event-resizer{display:none;position:absolute;z-index:4}.fc-event-selected .fc-event-resizer,.fc-event:hover .fc-event-resizer{display:block}.fc-event-selected .fc-event-resizer{background:var(--fc-page-bg-color);border-color:inherit;border-radius:calc(var(--fc-event-resizer-dot-total-width)/2);border-style:solid;border-width:var(--fc-event-resizer-dot-border-width);height:var(--fc-event-resizer-dot-total-width);width:var(--fc-event-resizer-dot-total-width)}.fc-event-selected .fc-event-resizer:before{bottom:-20px;content:"";left:-20px;position:absolute;right:-20px;top:-20px}.fc-event-selected,.fc-event:focus{box-shadow:0 2px 5px rgba(0,0,0,.2)}.fc-event-selected:before,.fc-event:focus:before{bottom:0;content:"";left:0;position:absolute;right:0;top:0;z-index:3}.fc-event-selected:after,.fc-event:focus:after{background:var(--fc-event-selected-overlay-color);bottom:-1px;content:"";left:-1px;position:absolute;right:-1px;top:-1px;z-index:1}.fc-h-event{background-color:var(--fc-event-bg-color);border:1px solid var(--fc-event-border-color);display:block}.fc-h-event .fc-event-main{color:var(--fc-event-text-color)}.fc-h-event .fc-event-main-frame{display:flex}.fc-h-event .fc-event-time{max-width:100%;overflow:hidden}.fc-h-event .fc-event-title-container{flex-grow:1;flex-shrink:1;min-width:0}.fc-h-event .fc-event-title{display:inline-block;left:0;max-width:100%;overflow:hidden;right:0;vertical-align:top}.fc-h-event.fc-event-selected:before{bottom:-10px;top:-10px}.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-start),.fc-direction-rtl .fc-daygrid-block-event:not(.fc-event-end){border-bottom-left-radius:0;border-left-width:0;border-top-left-radius:0}.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-end),.fc-direction-rtl .fc-daygrid-block-event:not(.fc-event-start){border-bottom-right-radius:0;border-right-width:0;border-top-right-radius:0}.fc-h-event:not(.fc-event-selected) .fc-event-resizer{bottom:0;top:0;width:var(--fc-event-resizer-thickness)}.fc-direction-ltr .fc-h-event:not(.fc-event-selected) .fc-event-resizer-start,.fc-direction-rtl .fc-h-event:not(.fc-event-selected) .fc-event-resizer-end{cursor:w-resize;left:calc(var(--fc-event-resizer-thickness)*-.5)}.fc-direction-ltr .fc-h-event:not(.fc-event-selected) .fc-event-resizer-end,.fc-direction-rtl .fc-h-event:not(.fc-event-selected) .fc-event-resizer-start{cursor:e-resize;right:calc(var(--fc-event-resizer-thickness)*-.5)}.fc-h-event.fc-event-selected .fc-event-resizer{margin-top:calc(var(--fc-event-resizer-dot-total-width)*-.5);top:50%}.fc-direction-ltr .fc-h-event.fc-event-selected .fc-event-resizer-start,.fc-direction-rtl .fc-h-event.fc-event-selected .fc-event-resizer-end{left:calc(var(--fc-event-resizer-dot-total-width)*-.5)}.fc-direction-ltr .fc-h-event.fc-event-selected .fc-event-resizer-end,.fc-direction-rtl .fc-h-event.fc-event-selected .fc-event-resizer-start{right:calc(var(--fc-event-resizer-dot-total-width)*-.5)}.fc .fc-popover{box-shadow:0 2px 6px rgba(0,0,0,.15);position:absolute;z-index:9999}.fc .fc-popover-header{align-items:center;display:flex;flex-direction:row;justify-content:space-between;padding:3px 4px}.fc .fc-popover-title{margin:0 2px}.fc .fc-popover-close{cursor:pointer;font-size:1.1em;opacity:.65}.fc-theme-standard .fc-popover{background:var(--fc-page-bg-color);border:1px solid var(--fc-border-color)}.fc-theme-standard .fc-popover-header{background:var(--fc-neutral-bg-color)}';
injectStyles(css_248z);
var DelayedRunner = class {
  constructor(drainedOption) {
    this.drainedOption = drainedOption;
    this.isRunning = false;
    this.isDirty = false;
    this.pauseDepths = {};
    this.timeoutId = 0;
  }
  request(delay) {
    this.isDirty = true;
    if (!this.isPaused()) {
      this.clearTimeout();
      if (delay == null) {
        this.tryDrain();
      } else {
        this.timeoutId = setTimeout(
          // NOT OPTIMAL! TODO: look at debounce
          this.tryDrain.bind(this),
          delay
        );
      }
    }
  }
  pause(scope = "") {
    let { pauseDepths } = this;
    pauseDepths[scope] = (pauseDepths[scope] || 0) + 1;
    this.clearTimeout();
  }
  resume(scope = "", force) {
    let { pauseDepths } = this;
    if (scope in pauseDepths) {
      if (force) {
        delete pauseDepths[scope];
      } else {
        pauseDepths[scope] -= 1;
        let depth = pauseDepths[scope];
        if (depth <= 0) {
          delete pauseDepths[scope];
        }
      }
      this.tryDrain();
    }
  }
  isPaused() {
    return Object.keys(this.pauseDepths).length;
  }
  tryDrain() {
    if (!this.isRunning && !this.isPaused()) {
      this.isRunning = true;
      while (this.isDirty) {
        this.isDirty = false;
        this.drained();
      }
      this.isRunning = false;
    }
  }
  clear() {
    this.clearTimeout();
    this.isDirty = false;
    this.pauseDepths = {};
  }
  clearTimeout() {
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
      this.timeoutId = 0;
    }
  }
  drained() {
    if (this.drainedOption) {
      this.drainedOption();
    }
  }
};
function removeElement(el) {
  if (el.parentNode) {
    el.parentNode.removeChild(el);
  }
}
function elementClosest(el, selector) {
  if (el.closest) {
    return el.closest(selector);
  }
  if (!document.documentElement.contains(el)) {
    return null;
  }
  do {
    if (elementMatches(el, selector)) {
      return el;
    }
    el = el.parentElement || el.parentNode;
  } while (el !== null && el.nodeType === 1);
  return null;
}
function elementMatches(el, selector) {
  let method = el.matches || el.matchesSelector || el.msMatchesSelector;
  return method.call(el, selector);
}
function findElements(container, selector) {
  let containers = container instanceof HTMLElement ? [container] : container;
  let allMatches = [];
  for (let i3 = 0; i3 < containers.length; i3 += 1) {
    let matches = containers[i3].querySelectorAll(selector);
    for (let j4 = 0; j4 < matches.length; j4 += 1) {
      allMatches.push(matches[j4]);
    }
  }
  return allMatches;
}
var PIXEL_PROP_RE = /(top|left|right|bottom|width|height)$/i;
function applyStyle(el, props) {
  for (let propName in props) {
    applyStyleProp(el, propName, props[propName]);
  }
}
function applyStyleProp(el, name, val) {
  if (val == null) {
    el.style[name] = "";
  } else if (typeof val === "number" && PIXEL_PROP_RE.test(name)) {
    el.style[name] = `${val}px`;
  } else {
    el.style[name] = val;
  }
}
function getEventTargetViaRoot(ev) {
  var _a, _b;
  return (_b = (_a = ev.composedPath) === null || _a === void 0 ? void 0 : _a.call(ev)[0]) !== null && _b !== void 0 ? _b : ev.target;
}
var guid$1 = 0;
function getUniqueDomId() {
  guid$1 += 1;
  return "fc-dom-" + guid$1;
}
function preventDefault(ev) {
  ev.preventDefault();
}
function buildDelegationHandler(selector, handler) {
  return (ev) => {
    let matchedChild = elementClosest(ev.target, selector);
    if (matchedChild) {
      handler.call(matchedChild, ev, matchedChild);
    }
  };
}
function listenBySelector(container, eventType, selector, handler) {
  let attachedHandler = buildDelegationHandler(selector, handler);
  container.addEventListener(eventType, attachedHandler);
  return () => {
    container.removeEventListener(eventType, attachedHandler);
  };
}
function listenToHoverBySelector(container, selector, onMouseEnter, onMouseLeave) {
  let currentMatchedChild;
  return listenBySelector(container, "mouseover", selector, (mouseOverEv, matchedChild) => {
    if (matchedChild !== currentMatchedChild) {
      currentMatchedChild = matchedChild;
      onMouseEnter(mouseOverEv, matchedChild);
      let realOnMouseLeave = (mouseLeaveEv) => {
        currentMatchedChild = null;
        onMouseLeave(mouseLeaveEv, matchedChild);
        matchedChild.removeEventListener("mouseleave", realOnMouseLeave);
      };
      matchedChild.addEventListener("mouseleave", realOnMouseLeave);
    }
  });
}
var transitionEventNames = [
  "webkitTransitionEnd",
  "otransitionend",
  "oTransitionEnd",
  "msTransitionEnd",
  "transitionend"
];
function whenTransitionDone(el, callback) {
  let realCallback = (ev) => {
    callback(ev);
    transitionEventNames.forEach((eventName) => {
      el.removeEventListener(eventName, realCallback);
    });
  };
  transitionEventNames.forEach((eventName) => {
    el.addEventListener(eventName, realCallback);
  });
}
function createAriaClickAttrs(handler) {
  return Object.assign({ onClick: handler }, createAriaKeyboardAttrs(handler));
}
function createAriaKeyboardAttrs(handler) {
  return {
    tabIndex: 0,
    onKeyDown(ev) {
      if (ev.key === "Enter" || ev.key === " ") {
        handler(ev);
        ev.preventDefault();
      }
    }
  };
}
var guidNumber = 0;
function guid() {
  guidNumber += 1;
  return String(guidNumber);
}
function disableCursor() {
  document.body.classList.add("fc-not-allowed");
}
function enableCursor() {
  document.body.classList.remove("fc-not-allowed");
}
function preventSelection(el) {
  el.style.userSelect = "none";
  el.style.webkitUserSelect = "none";
  el.addEventListener("selectstart", preventDefault);
}
function allowSelection(el) {
  el.style.userSelect = "";
  el.style.webkitUserSelect = "";
  el.removeEventListener("selectstart", preventDefault);
}
function preventContextMenu(el) {
  el.addEventListener("contextmenu", preventDefault);
}
function allowContextMenu(el) {
  el.removeEventListener("contextmenu", preventDefault);
}
function parseFieldSpecs(input) {
  let specs = [];
  let tokens = [];
  let i3;
  let token;
  if (typeof input === "string") {
    tokens = input.split(/\s*,\s*/);
  } else if (typeof input === "function") {
    tokens = [input];
  } else if (Array.isArray(input)) {
    tokens = input;
  }
  for (i3 = 0; i3 < tokens.length; i3 += 1) {
    token = tokens[i3];
    if (typeof token === "string") {
      specs.push(token.charAt(0) === "-" ? { field: token.substring(1), order: -1 } : { field: token, order: 1 });
    } else if (typeof token === "function") {
      specs.push({ func: token });
    }
  }
  return specs;
}
function compareByFieldSpecs(obj0, obj1, fieldSpecs) {
  let i3;
  let cmp;
  for (i3 = 0; i3 < fieldSpecs.length; i3 += 1) {
    cmp = compareByFieldSpec(obj0, obj1, fieldSpecs[i3]);
    if (cmp) {
      return cmp;
    }
  }
  return 0;
}
function compareByFieldSpec(obj0, obj1, fieldSpec) {
  if (fieldSpec.func) {
    return fieldSpec.func(obj0, obj1);
  }
  return flexibleCompare(obj0[fieldSpec.field], obj1[fieldSpec.field]) * (fieldSpec.order || 1);
}
function flexibleCompare(a3, b3) {
  if (!a3 && !b3) {
    return 0;
  }
  if (b3 == null) {
    return -1;
  }
  if (a3 == null) {
    return 1;
  }
  if (typeof a3 === "string" || typeof b3 === "string") {
    return String(a3).localeCompare(String(b3));
  }
  return a3 - b3;
}
function padStart(val, len) {
  let s3 = String(val);
  return "000".substr(0, len - s3.length) + s3;
}
function formatWithOrdinals(formatter, args, fallbackText) {
  if (typeof formatter === "function") {
    return formatter(...args);
  }
  if (typeof formatter === "string") {
    return args.reduce((str, arg, index8) => str.replace("$" + index8, arg || ""), formatter);
  }
  return fallbackText;
}
function compareNumbers(a3, b3) {
  return a3 - b3;
}
function isInt(n2) {
  return n2 % 1 === 0;
}
function computeSmallestCellWidth(cellEl) {
  let allWidthEl = cellEl.querySelector(".fc-scrollgrid-shrink-frame");
  let contentWidthEl = cellEl.querySelector(".fc-scrollgrid-shrink-cushion");
  if (!allWidthEl) {
    throw new Error("needs fc-scrollgrid-shrink-frame className");
  }
  if (!contentWidthEl) {
    throw new Error("needs fc-scrollgrid-shrink-cushion className");
  }
  return cellEl.getBoundingClientRect().width - allWidthEl.getBoundingClientRect().width + // the cell padding+border
  contentWidthEl.getBoundingClientRect().width;
}
var INTERNAL_UNITS = ["years", "months", "days", "milliseconds"];
var PARSE_RE = /^(-?)(?:(\d+)\.)?(\d+):(\d\d)(?::(\d\d)(?:\.(\d\d\d))?)?/;
function createDuration(input, unit) {
  if (typeof input === "string") {
    return parseString(input);
  }
  if (typeof input === "object" && input) {
    return parseObject(input);
  }
  if (typeof input === "number") {
    return parseObject({ [unit || "milliseconds"]: input });
  }
  return null;
}
function parseString(s3) {
  let m3 = PARSE_RE.exec(s3);
  if (m3) {
    let sign = m3[1] ? -1 : 1;
    return {
      years: 0,
      months: 0,
      days: sign * (m3[2] ? parseInt(m3[2], 10) : 0),
      milliseconds: sign * ((m3[3] ? parseInt(m3[3], 10) : 0) * 60 * 60 * 1e3 + // hours
      (m3[4] ? parseInt(m3[4], 10) : 0) * 60 * 1e3 + // minutes
      (m3[5] ? parseInt(m3[5], 10) : 0) * 1e3 + // seconds
      (m3[6] ? parseInt(m3[6], 10) : 0))
    };
  }
  return null;
}
function parseObject(obj) {
  let duration = {
    years: obj.years || obj.year || 0,
    months: obj.months || obj.month || 0,
    days: obj.days || obj.day || 0,
    milliseconds: (obj.hours || obj.hour || 0) * 60 * 60 * 1e3 + // hours
    (obj.minutes || obj.minute || 0) * 60 * 1e3 + // minutes
    (obj.seconds || obj.second || 0) * 1e3 + // seconds
    (obj.milliseconds || obj.millisecond || obj.ms || 0)
    // ms
  };
  let weeks = obj.weeks || obj.week;
  if (weeks) {
    duration.days += weeks * 7;
    duration.specifiedWeeks = true;
  }
  return duration;
}
function durationsEqual(d0, d1) {
  return d0.years === d1.years && d0.months === d1.months && d0.days === d1.days && d0.milliseconds === d1.milliseconds;
}
function addDurations(d0, d1) {
  return {
    years: d0.years + d1.years,
    months: d0.months + d1.months,
    days: d0.days + d1.days,
    milliseconds: d0.milliseconds + d1.milliseconds
  };
}
function subtractDurations(d1, d0) {
  return {
    years: d1.years - d0.years,
    months: d1.months - d0.months,
    days: d1.days - d0.days,
    milliseconds: d1.milliseconds - d0.milliseconds
  };
}
function multiplyDuration(d2, n2) {
  return {
    years: d2.years * n2,
    months: d2.months * n2,
    days: d2.days * n2,
    milliseconds: d2.milliseconds * n2
  };
}
function asRoughYears(dur) {
  return asRoughDays(dur) / 365;
}
function asRoughMonths(dur) {
  return asRoughDays(dur) / 30;
}
function asRoughDays(dur) {
  return asRoughMs(dur) / 864e5;
}
function asRoughMs(dur) {
  return dur.years * (365 * 864e5) + dur.months * (30 * 864e5) + dur.days * 864e5 + dur.milliseconds;
}
function wholeDivideDurations(numerator, denominator) {
  let res = null;
  for (let i3 = 0; i3 < INTERNAL_UNITS.length; i3 += 1) {
    let unit = INTERNAL_UNITS[i3];
    if (denominator[unit]) {
      let localRes = numerator[unit] / denominator[unit];
      if (!isInt(localRes) || res !== null && res !== localRes) {
        return null;
      }
      res = localRes;
    } else if (numerator[unit]) {
      return null;
    }
  }
  return res;
}
function greatestDurationDenominator(dur) {
  let ms = dur.milliseconds;
  if (ms) {
    if (ms % 1e3 !== 0) {
      return { unit: "millisecond", value: ms };
    }
    if (ms % (1e3 * 60) !== 0) {
      return { unit: "second", value: ms / 1e3 };
    }
    if (ms % (1e3 * 60 * 60) !== 0) {
      return { unit: "minute", value: ms / (1e3 * 60) };
    }
    if (ms) {
      return { unit: "hour", value: ms / (1e3 * 60 * 60) };
    }
  }
  if (dur.days) {
    if (dur.specifiedWeeks && dur.days % 7 === 0) {
      return { unit: "week", value: dur.days / 7 };
    }
    return { unit: "day", value: dur.days };
  }
  if (dur.months) {
    return { unit: "month", value: dur.months };
  }
  if (dur.years) {
    return { unit: "year", value: dur.years };
  }
  return { unit: "millisecond", value: 0 };
}
function isArraysEqual(a0, a1, equalityFunc) {
  if (a0 === a1) {
    return true;
  }
  let len = a0.length;
  let i3;
  if (len !== a1.length) {
    return false;
  }
  for (i3 = 0; i3 < len; i3 += 1) {
    if (!(equalityFunc ? equalityFunc(a0[i3], a1[i3]) : a0[i3] === a1[i3])) {
      return false;
    }
  }
  return true;
}
var DAY_IDS = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];
function addWeeks(m3, n2) {
  let a3 = dateToUtcArray(m3);
  a3[2] += n2 * 7;
  return arrayToUtcDate(a3);
}
function addDays(m3, n2) {
  let a3 = dateToUtcArray(m3);
  a3[2] += n2;
  return arrayToUtcDate(a3);
}
function addMs(m3, n2) {
  let a3 = dateToUtcArray(m3);
  a3[6] += n2;
  return arrayToUtcDate(a3);
}
function diffWeeks(m0, m1) {
  return diffDays(m0, m1) / 7;
}
function diffDays(m0, m1) {
  return (m1.valueOf() - m0.valueOf()) / (1e3 * 60 * 60 * 24);
}
function diffHours(m0, m1) {
  return (m1.valueOf() - m0.valueOf()) / (1e3 * 60 * 60);
}
function diffMinutes(m0, m1) {
  return (m1.valueOf() - m0.valueOf()) / (1e3 * 60);
}
function diffSeconds(m0, m1) {
  return (m1.valueOf() - m0.valueOf()) / 1e3;
}
function diffDayAndTime(m0, m1) {
  let m0day = startOfDay(m0);
  let m1day = startOfDay(m1);
  return {
    years: 0,
    months: 0,
    days: Math.round(diffDays(m0day, m1day)),
    milliseconds: m1.valueOf() - m1day.valueOf() - (m0.valueOf() - m0day.valueOf())
  };
}
function diffWholeWeeks(m0, m1) {
  let d2 = diffWholeDays(m0, m1);
  if (d2 !== null && d2 % 7 === 0) {
    return d2 / 7;
  }
  return null;
}
function diffWholeDays(m0, m1) {
  if (timeAsMs(m0) === timeAsMs(m1)) {
    return Math.round(diffDays(m0, m1));
  }
  return null;
}
function startOfDay(m3) {
  return arrayToUtcDate([
    m3.getUTCFullYear(),
    m3.getUTCMonth(),
    m3.getUTCDate()
  ]);
}
function startOfHour(m3) {
  return arrayToUtcDate([
    m3.getUTCFullYear(),
    m3.getUTCMonth(),
    m3.getUTCDate(),
    m3.getUTCHours()
  ]);
}
function startOfMinute(m3) {
  return arrayToUtcDate([
    m3.getUTCFullYear(),
    m3.getUTCMonth(),
    m3.getUTCDate(),
    m3.getUTCHours(),
    m3.getUTCMinutes()
  ]);
}
function startOfSecond(m3) {
  return arrayToUtcDate([
    m3.getUTCFullYear(),
    m3.getUTCMonth(),
    m3.getUTCDate(),
    m3.getUTCHours(),
    m3.getUTCMinutes(),
    m3.getUTCSeconds()
  ]);
}
function weekOfYear(marker, dow, doy) {
  let y3 = marker.getUTCFullYear();
  let w4 = weekOfGivenYear(marker, y3, dow, doy);
  if (w4 < 1) {
    return weekOfGivenYear(marker, y3 - 1, dow, doy);
  }
  let nextW = weekOfGivenYear(marker, y3 + 1, dow, doy);
  if (nextW >= 1) {
    return Math.min(w4, nextW);
  }
  return w4;
}
function weekOfGivenYear(marker, year, dow, doy) {
  let firstWeekStart = arrayToUtcDate([year, 0, 1 + firstWeekOffset(year, dow, doy)]);
  let dayStart = startOfDay(marker);
  let days = Math.round(diffDays(firstWeekStart, dayStart));
  return Math.floor(days / 7) + 1;
}
function firstWeekOffset(year, dow, doy) {
  let fwd = 7 + dow - doy;
  let fwdlw = (7 + arrayToUtcDate([year, 0, fwd]).getUTCDay() - dow) % 7;
  return -fwdlw + fwd - 1;
}
function dateToLocalArray(date) {
  return [
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    date.getHours(),
    date.getMinutes(),
    date.getSeconds(),
    date.getMilliseconds()
  ];
}
function arrayToLocalDate(a3) {
  return new Date(
    a3[0],
    a3[1] || 0,
    a3[2] == null ? 1 : a3[2],
    // day of month
    a3[3] || 0,
    a3[4] || 0,
    a3[5] || 0
  );
}
function dateToUtcArray(date) {
  return [
    date.getUTCFullYear(),
    date.getUTCMonth(),
    date.getUTCDate(),
    date.getUTCHours(),
    date.getUTCMinutes(),
    date.getUTCSeconds(),
    date.getUTCMilliseconds()
  ];
}
function arrayToUtcDate(a3) {
  if (a3.length === 1) {
    a3 = a3.concat([0]);
  }
  return new Date(Date.UTC(...a3));
}
function isValidDate(m3) {
  return !isNaN(m3.valueOf());
}
function timeAsMs(m3) {
  return m3.getUTCHours() * 1e3 * 60 * 60 + m3.getUTCMinutes() * 1e3 * 60 + m3.getUTCSeconds() * 1e3 + m3.getUTCMilliseconds();
}
function buildIsoString(marker, timeZoneOffset, stripZeroTime = false) {
  let s3 = marker.toISOString();
  s3 = s3.replace(".000", "");
  if (stripZeroTime) {
    s3 = s3.replace("T00:00:00Z", "");
  }
  if (s3.length > 10) {
    if (timeZoneOffset == null) {
      s3 = s3.replace("Z", "");
    } else if (timeZoneOffset !== 0) {
      s3 = s3.replace("Z", formatTimeZoneOffset(timeZoneOffset, true));
    }
  }
  return s3;
}
function formatDayString(marker) {
  return marker.toISOString().replace(/T.*$/, "");
}
function formatIsoMonthStr(marker) {
  return marker.toISOString().match(/^\d{4}-\d{2}/)[0];
}
function formatIsoTimeString(marker) {
  return padStart(marker.getUTCHours(), 2) + ":" + padStart(marker.getUTCMinutes(), 2) + ":" + padStart(marker.getUTCSeconds(), 2);
}
function formatTimeZoneOffset(minutes, doIso = false) {
  let sign = minutes < 0 ? "-" : "+";
  let abs = Math.abs(minutes);
  let hours = Math.floor(abs / 60);
  let mins = Math.round(abs % 60);
  if (doIso) {
    return `${sign + padStart(hours, 2)}:${padStart(mins, 2)}`;
  }
  return `GMT${sign}${hours}${mins ? `:${padStart(mins, 2)}` : ""}`;
}
function memoize(workerFunc, resEquality, teardownFunc) {
  let currentArgs;
  let currentRes;
  return function(...newArgs) {
    if (!currentArgs) {
      currentRes = workerFunc.apply(this, newArgs);
    } else if (!isArraysEqual(currentArgs, newArgs)) {
      if (teardownFunc) {
        teardownFunc(currentRes);
      }
      let res = workerFunc.apply(this, newArgs);
      if (!resEquality || !resEquality(res, currentRes)) {
        currentRes = res;
      }
    }
    currentArgs = newArgs;
    return currentRes;
  };
}
function memoizeObjArg(workerFunc, resEquality, teardownFunc) {
  let currentArg;
  let currentRes;
  return (newArg) => {
    if (!currentArg) {
      currentRes = workerFunc.call(this, newArg);
    } else if (!isPropsEqual(currentArg, newArg)) {
      if (teardownFunc) {
        teardownFunc(currentRes);
      }
      let res = workerFunc.call(this, newArg);
      if (!resEquality || !resEquality(res, currentRes)) {
        currentRes = res;
      }
    }
    currentArg = newArg;
    return currentRes;
  };
}
var EXTENDED_SETTINGS_AND_SEVERITIES = {
  week: 3,
  separator: 0,
  omitZeroMinute: 0,
  meridiem: 0,
  omitCommas: 0
};
var STANDARD_DATE_PROP_SEVERITIES = {
  timeZoneName: 7,
  era: 6,
  year: 5,
  month: 4,
  day: 2,
  weekday: 2,
  hour: 1,
  minute: 1,
  second: 1
};
var MERIDIEM_RE = /\s*([ap])\.?m\.?/i;
var COMMA_RE = /,/g;
var MULTI_SPACE_RE = /\s+/g;
var LTR_RE = /\u200e/g;
var UTC_RE = /UTC|GMT/;
var NativeFormatter = class {
  constructor(formatSettings) {
    let standardDateProps = {};
    let extendedSettings = {};
    let severity = 0;
    for (let name in formatSettings) {
      if (name in EXTENDED_SETTINGS_AND_SEVERITIES) {
        extendedSettings[name] = formatSettings[name];
        severity = Math.max(EXTENDED_SETTINGS_AND_SEVERITIES[name], severity);
      } else {
        standardDateProps[name] = formatSettings[name];
        if (name in STANDARD_DATE_PROP_SEVERITIES) {
          severity = Math.max(STANDARD_DATE_PROP_SEVERITIES[name], severity);
        }
      }
    }
    this.standardDateProps = standardDateProps;
    this.extendedSettings = extendedSettings;
    this.severity = severity;
    this.buildFormattingFunc = memoize(buildFormattingFunc);
  }
  format(date, context) {
    return this.buildFormattingFunc(this.standardDateProps, this.extendedSettings, context)(date);
  }
  formatRange(start, end, context, betterDefaultSeparator) {
    let { standardDateProps, extendedSettings } = this;
    let diffSeverity = computeMarkerDiffSeverity(start.marker, end.marker, context.calendarSystem);
    if (!diffSeverity) {
      return this.format(start, context);
    }
    let biggestUnitForPartial = diffSeverity;
    if (biggestUnitForPartial > 1 && // the two dates are different in a way that's larger scale than time
    (standardDateProps.year === "numeric" || standardDateProps.year === "2-digit") && (standardDateProps.month === "numeric" || standardDateProps.month === "2-digit") && (standardDateProps.day === "numeric" || standardDateProps.day === "2-digit")) {
      biggestUnitForPartial = 1;
    }
    let full0 = this.format(start, context);
    let full1 = this.format(end, context);
    if (full0 === full1) {
      return full0;
    }
    let partialDateProps = computePartialFormattingOptions(standardDateProps, biggestUnitForPartial);
    let partialFormattingFunc = buildFormattingFunc(partialDateProps, extendedSettings, context);
    let partial0 = partialFormattingFunc(start);
    let partial1 = partialFormattingFunc(end);
    let insertion = findCommonInsertion(full0, partial0, full1, partial1);
    let separator = extendedSettings.separator || betterDefaultSeparator || context.defaultSeparator || "";
    if (insertion) {
      return insertion.before + partial0 + separator + partial1 + insertion.after;
    }
    return full0 + separator + full1;
  }
  getLargestUnit() {
    switch (this.severity) {
      case 7:
      case 6:
      case 5:
        return "year";
      case 4:
        return "month";
      case 3:
        return "week";
      case 2:
        return "day";
      default:
        return "time";
    }
  }
};
function buildFormattingFunc(standardDateProps, extendedSettings, context) {
  let standardDatePropCnt = Object.keys(standardDateProps).length;
  if (standardDatePropCnt === 1 && standardDateProps.timeZoneName === "short") {
    return (date) => formatTimeZoneOffset(date.timeZoneOffset);
  }
  if (standardDatePropCnt === 0 && extendedSettings.week) {
    return (date) => formatWeekNumber(context.computeWeekNumber(date.marker), context.weekText, context.weekTextLong, context.locale, extendedSettings.week);
  }
  return buildNativeFormattingFunc(standardDateProps, extendedSettings, context);
}
function buildNativeFormattingFunc(standardDateProps, extendedSettings, context) {
  standardDateProps = Object.assign({}, standardDateProps);
  extendedSettings = Object.assign({}, extendedSettings);
  sanitizeSettings(standardDateProps, extendedSettings);
  standardDateProps.timeZone = "UTC";
  let normalFormat = new Intl.DateTimeFormat(context.locale.codes, standardDateProps);
  let zeroFormat;
  if (extendedSettings.omitZeroMinute) {
    let zeroProps = Object.assign({}, standardDateProps);
    delete zeroProps.minute;
    zeroFormat = new Intl.DateTimeFormat(context.locale.codes, zeroProps);
  }
  return (date) => {
    let { marker } = date;
    let format;
    if (zeroFormat && !marker.getUTCMinutes()) {
      format = zeroFormat;
    } else {
      format = normalFormat;
    }
    let s3 = format.format(marker);
    return postProcess(s3, date, standardDateProps, extendedSettings, context);
  };
}
function sanitizeSettings(standardDateProps, extendedSettings) {
  if (standardDateProps.timeZoneName) {
    if (!standardDateProps.hour) {
      standardDateProps.hour = "2-digit";
    }
    if (!standardDateProps.minute) {
      standardDateProps.minute = "2-digit";
    }
  }
  if (standardDateProps.timeZoneName === "long") {
    standardDateProps.timeZoneName = "short";
  }
  if (extendedSettings.omitZeroMinute && (standardDateProps.second || standardDateProps.millisecond)) {
    delete extendedSettings.omitZeroMinute;
  }
}
function postProcess(s3, date, standardDateProps, extendedSettings, context) {
  s3 = s3.replace(LTR_RE, "");
  if (standardDateProps.timeZoneName === "short") {
    s3 = injectTzoStr(s3, context.timeZone === "UTC" || date.timeZoneOffset == null ? "UTC" : (
      // important to normalize for IE, which does "GMT"
      formatTimeZoneOffset(date.timeZoneOffset)
    ));
  }
  if (extendedSettings.omitCommas) {
    s3 = s3.replace(COMMA_RE, "").trim();
  }
  if (extendedSettings.omitZeroMinute) {
    s3 = s3.replace(":00", "");
  }
  if (extendedSettings.meridiem === false) {
    s3 = s3.replace(MERIDIEM_RE, "").trim();
  } else if (extendedSettings.meridiem === "narrow") {
    s3 = s3.replace(MERIDIEM_RE, (m0, m1) => m1.toLocaleLowerCase());
  } else if (extendedSettings.meridiem === "short") {
    s3 = s3.replace(MERIDIEM_RE, (m0, m1) => `${m1.toLocaleLowerCase()}m`);
  } else if (extendedSettings.meridiem === "lowercase") {
    s3 = s3.replace(MERIDIEM_RE, (m0) => m0.toLocaleLowerCase());
  }
  s3 = s3.replace(MULTI_SPACE_RE, " ");
  s3 = s3.trim();
  return s3;
}
function injectTzoStr(s3, tzoStr) {
  let replaced = false;
  s3 = s3.replace(UTC_RE, () => {
    replaced = true;
    return tzoStr;
  });
  if (!replaced) {
    s3 += ` ${tzoStr}`;
  }
  return s3;
}
function formatWeekNumber(num, weekText, weekTextLong, locale, display2) {
  let parts = [];
  if (display2 === "long") {
    parts.push(weekTextLong);
  } else if (display2 === "short" || display2 === "narrow") {
    parts.push(weekText);
  }
  if (display2 === "long" || display2 === "short") {
    parts.push(" ");
  }
  parts.push(locale.simpleNumberFormat.format(num));
  if (locale.options.direction === "rtl") {
    parts.reverse();
  }
  return parts.join("");
}
function computeMarkerDiffSeverity(d0, d1, ca) {
  if (ca.getMarkerYear(d0) !== ca.getMarkerYear(d1)) {
    return 5;
  }
  if (ca.getMarkerMonth(d0) !== ca.getMarkerMonth(d1)) {
    return 4;
  }
  if (ca.getMarkerDay(d0) !== ca.getMarkerDay(d1)) {
    return 2;
  }
  if (timeAsMs(d0) !== timeAsMs(d1)) {
    return 1;
  }
  return 0;
}
function computePartialFormattingOptions(options, biggestUnit) {
  let partialOptions = {};
  for (let name in options) {
    if (!(name in STANDARD_DATE_PROP_SEVERITIES) || // not a date part prop (like timeZone)
    STANDARD_DATE_PROP_SEVERITIES[name] <= biggestUnit) {
      partialOptions[name] = options[name];
    }
  }
  return partialOptions;
}
function findCommonInsertion(full0, partial0, full1, partial1) {
  let i0 = 0;
  while (i0 < full0.length) {
    let found0 = full0.indexOf(partial0, i0);
    if (found0 === -1) {
      break;
    }
    let before0 = full0.substr(0, found0);
    i0 = found0 + partial0.length;
    let after0 = full0.substr(i0);
    let i1 = 0;
    while (i1 < full1.length) {
      let found1 = full1.indexOf(partial1, i1);
      if (found1 === -1) {
        break;
      }
      let before1 = full1.substr(0, found1);
      i1 = found1 + partial1.length;
      let after1 = full1.substr(i1);
      if (before0 === before1 && after0 === after1) {
        return {
          before: before0,
          after: after0
        };
      }
    }
  }
  return null;
}
function expandZonedMarker(dateInfo, calendarSystem) {
  let a3 = calendarSystem.markerToArray(dateInfo.marker);
  return {
    marker: dateInfo.marker,
    timeZoneOffset: dateInfo.timeZoneOffset,
    array: a3,
    year: a3[0],
    month: a3[1],
    day: a3[2],
    hour: a3[3],
    minute: a3[4],
    second: a3[5],
    millisecond: a3[6]
  };
}
function createVerboseFormattingArg(start, end, context, betterDefaultSeparator) {
  let startInfo = expandZonedMarker(start, context.calendarSystem);
  let endInfo = end ? expandZonedMarker(end, context.calendarSystem) : null;
  return {
    date: startInfo,
    start: startInfo,
    end: endInfo,
    timeZone: context.timeZone,
    localeCodes: context.locale.codes,
    defaultSeparator: betterDefaultSeparator || context.defaultSeparator
  };
}
var CmdFormatter = class {
  constructor(cmdStr) {
    this.cmdStr = cmdStr;
  }
  format(date, context, betterDefaultSeparator) {
    return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(date, null, context, betterDefaultSeparator));
  }
  formatRange(start, end, context, betterDefaultSeparator) {
    return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(start, end, context, betterDefaultSeparator));
  }
};
var FuncFormatter = class {
  constructor(func) {
    this.func = func;
  }
  format(date, context, betterDefaultSeparator) {
    return this.func(createVerboseFormattingArg(date, null, context, betterDefaultSeparator));
  }
  formatRange(start, end, context, betterDefaultSeparator) {
    return this.func(createVerboseFormattingArg(start, end, context, betterDefaultSeparator));
  }
};
function createFormatter(input) {
  if (typeof input === "object" && input) {
    return new NativeFormatter(input);
  }
  if (typeof input === "string") {
    return new CmdFormatter(input);
  }
  if (typeof input === "function") {
    return new FuncFormatter(input);
  }
  return null;
}
var BASE_OPTION_REFINERS = {
  navLinkDayClick: identity,
  navLinkWeekClick: identity,
  duration: createDuration,
  bootstrapFontAwesome: identity,
  buttonIcons: identity,
  customButtons: identity,
  defaultAllDayEventDuration: createDuration,
  defaultTimedEventDuration: createDuration,
  nextDayThreshold: createDuration,
  scrollTime: createDuration,
  scrollTimeReset: Boolean,
  slotMinTime: createDuration,
  slotMaxTime: createDuration,
  dayPopoverFormat: createFormatter,
  slotDuration: createDuration,
  snapDuration: createDuration,
  headerToolbar: identity,
  footerToolbar: identity,
  defaultRangeSeparator: String,
  titleRangeSeparator: String,
  forceEventDuration: Boolean,
  dayHeaders: Boolean,
  dayHeaderFormat: createFormatter,
  dayHeaderClassNames: identity,
  dayHeaderContent: identity,
  dayHeaderDidMount: identity,
  dayHeaderWillUnmount: identity,
  dayCellClassNames: identity,
  dayCellContent: identity,
  dayCellDidMount: identity,
  dayCellWillUnmount: identity,
  initialView: String,
  aspectRatio: Number,
  weekends: Boolean,
  weekNumberCalculation: identity,
  weekNumbers: Boolean,
  weekNumberClassNames: identity,
  weekNumberContent: identity,
  weekNumberDidMount: identity,
  weekNumberWillUnmount: identity,
  editable: Boolean,
  viewClassNames: identity,
  viewDidMount: identity,
  viewWillUnmount: identity,
  nowIndicator: Boolean,
  nowIndicatorClassNames: identity,
  nowIndicatorContent: identity,
  nowIndicatorDidMount: identity,
  nowIndicatorWillUnmount: identity,
  showNonCurrentDates: Boolean,
  lazyFetching: Boolean,
  startParam: String,
  endParam: String,
  timeZoneParam: String,
  timeZone: String,
  locales: identity,
  locale: identity,
  themeSystem: String,
  dragRevertDuration: Number,
  dragScroll: Boolean,
  allDayMaintainDuration: Boolean,
  unselectAuto: Boolean,
  dropAccept: identity,
  eventOrder: parseFieldSpecs,
  eventOrderStrict: Boolean,
  handleWindowResize: Boolean,
  windowResizeDelay: Number,
  longPressDelay: Number,
  eventDragMinDistance: Number,
  expandRows: Boolean,
  height: identity,
  contentHeight: identity,
  direction: String,
  weekNumberFormat: createFormatter,
  eventResizableFromStart: Boolean,
  displayEventTime: Boolean,
  displayEventEnd: Boolean,
  weekText: String,
  weekTextLong: String,
  progressiveEventRendering: Boolean,
  businessHours: identity,
  initialDate: identity,
  now: identity,
  eventDataTransform: identity,
  stickyHeaderDates: identity,
  stickyFooterScrollbar: identity,
  viewHeight: identity,
  defaultAllDay: Boolean,
  eventSourceFailure: identity,
  eventSourceSuccess: identity,
  eventDisplay: String,
  eventStartEditable: Boolean,
  eventDurationEditable: Boolean,
  eventOverlap: identity,
  eventConstraint: identity,
  eventAllow: identity,
  eventBackgroundColor: String,
  eventBorderColor: String,
  eventTextColor: String,
  eventColor: String,
  eventClassNames: identity,
  eventContent: identity,
  eventDidMount: identity,
  eventWillUnmount: identity,
  selectConstraint: identity,
  selectOverlap: identity,
  selectAllow: identity,
  droppable: Boolean,
  unselectCancel: String,
  slotLabelFormat: identity,
  slotLaneClassNames: identity,
  slotLaneContent: identity,
  slotLaneDidMount: identity,
  slotLaneWillUnmount: identity,
  slotLabelClassNames: identity,
  slotLabelContent: identity,
  slotLabelDidMount: identity,
  slotLabelWillUnmount: identity,
  dayMaxEvents: identity,
  dayMaxEventRows: identity,
  dayMinWidth: Number,
  slotLabelInterval: createDuration,
  allDayText: String,
  allDayClassNames: identity,
  allDayContent: identity,
  allDayDidMount: identity,
  allDayWillUnmount: identity,
  slotMinWidth: Number,
  navLinks: Boolean,
  eventTimeFormat: createFormatter,
  rerenderDelay: Number,
  moreLinkText: identity,
  moreLinkHint: identity,
  selectMinDistance: Number,
  selectable: Boolean,
  selectLongPressDelay: Number,
  eventLongPressDelay: Number,
  selectMirror: Boolean,
  eventMaxStack: Number,
  eventMinHeight: Number,
  eventMinWidth: Number,
  eventShortHeight: Number,
  slotEventOverlap: Boolean,
  plugins: identity,
  firstDay: Number,
  dayCount: Number,
  dateAlignment: String,
  dateIncrement: createDuration,
  hiddenDays: identity,
  fixedWeekCount: Boolean,
  validRange: identity,
  visibleRange: identity,
  titleFormat: identity,
  eventInteractive: Boolean,
  // only used by list-view, but languages define the value, so we need it in base options
  noEventsText: String,
  viewHint: identity,
  navLinkHint: identity,
  closeHint: String,
  timeHint: String,
  eventHint: String,
  moreLinkClick: identity,
  moreLinkClassNames: identity,
  moreLinkContent: identity,
  moreLinkDidMount: identity,
  moreLinkWillUnmount: identity,
  monthStartFormat: createFormatter,
  // for connectors
  // (can't be part of plugin system b/c must be provided at runtime)
  handleCustomRendering: identity,
  customRenderingMetaMap: identity,
  customRenderingReplaces: Boolean
};
var BASE_OPTION_DEFAULTS = {
  eventDisplay: "auto",
  defaultRangeSeparator: " - ",
  titleRangeSeparator: " \u2013 ",
  defaultTimedEventDuration: "01:00:00",
  defaultAllDayEventDuration: { day: 1 },
  forceEventDuration: false,
  nextDayThreshold: "00:00:00",
  dayHeaders: true,
  initialView: "",
  aspectRatio: 1.35,
  headerToolbar: {
    start: "title",
    center: "",
    end: "today prev,next"
  },
  weekends: true,
  weekNumbers: false,
  weekNumberCalculation: "local",
  editable: false,
  nowIndicator: false,
  scrollTime: "06:00:00",
  scrollTimeReset: true,
  slotMinTime: "00:00:00",
  slotMaxTime: "24:00:00",
  showNonCurrentDates: true,
  lazyFetching: true,
  startParam: "start",
  endParam: "end",
  timeZoneParam: "timeZone",
  timeZone: "local",
  locales: [],
  locale: "",
  themeSystem: "standard",
  dragRevertDuration: 500,
  dragScroll: true,
  allDayMaintainDuration: false,
  unselectAuto: true,
  dropAccept: "*",
  eventOrder: "start,-duration,allDay,title",
  dayPopoverFormat: { month: "long", day: "numeric", year: "numeric" },
  handleWindowResize: true,
  windowResizeDelay: 100,
  longPressDelay: 1e3,
  eventDragMinDistance: 5,
  expandRows: false,
  navLinks: false,
  selectable: false,
  eventMinHeight: 15,
  eventMinWidth: 30,
  eventShortHeight: 30,
  monthStartFormat: { month: "long", day: "numeric" }
};
var CALENDAR_LISTENER_REFINERS = {
  datesSet: identity,
  eventsSet: identity,
  eventAdd: identity,
  eventChange: identity,
  eventRemove: identity,
  windowResize: identity,
  eventClick: identity,
  eventMouseEnter: identity,
  eventMouseLeave: identity,
  select: identity,
  unselect: identity,
  loading: identity,
  // internal
  _unmount: identity,
  _beforeprint: identity,
  _afterprint: identity,
  _noEventDrop: identity,
  _noEventResize: identity,
  _resize: identity,
  _scrollRequest: identity
};
var CALENDAR_OPTION_REFINERS = {
  buttonText: identity,
  buttonHints: identity,
  views: identity,
  plugins: identity,
  initialEvents: identity,
  events: identity,
  eventSources: identity
};
var COMPLEX_OPTION_COMPARATORS = {
  headerToolbar: isMaybeObjectsEqual,
  footerToolbar: isMaybeObjectsEqual,
  buttonText: isMaybeObjectsEqual,
  buttonHints: isMaybeObjectsEqual,
  buttonIcons: isMaybeObjectsEqual,
  dateIncrement: isMaybeObjectsEqual,
  plugins: isMaybeArraysEqual,
  events: isMaybeArraysEqual,
  eventSources: isMaybeArraysEqual,
  ["resources"]: isMaybeArraysEqual
};
function isMaybeObjectsEqual(a3, b3) {
  if (typeof a3 === "object" && typeof b3 === "object" && a3 && b3) {
    return isPropsEqual(a3, b3);
  }
  return a3 === b3;
}
function isMaybeArraysEqual(a3, b3) {
  if (Array.isArray(a3) && Array.isArray(b3)) {
    return isArraysEqual(a3, b3);
  }
  return a3 === b3;
}
var VIEW_OPTION_REFINERS = {
  type: String,
  component: identity,
  buttonText: String,
  buttonTextKey: String,
  dateProfileGeneratorClass: identity,
  usesMinMaxTime: Boolean,
  classNames: identity,
  content: identity,
  didMount: identity,
  willUnmount: identity
};
function mergeRawOptions(optionSets) {
  return mergeProps(optionSets, COMPLEX_OPTION_COMPARATORS);
}
function refineProps(input, refiners) {
  let refined = {};
  let extra = {};
  for (let propName in refiners) {
    if (propName in input) {
      refined[propName] = refiners[propName](input[propName]);
    }
  }
  for (let propName in input) {
    if (!(propName in refiners)) {
      extra[propName] = input[propName];
    }
  }
  return { refined, extra };
}
function identity(raw) {
  return raw;
}
var { hasOwnProperty } = Object.prototype;
function mergeProps(propObjs, complexPropsMap) {
  let dest = {};
  if (complexPropsMap) {
    for (let name in complexPropsMap) {
      if (complexPropsMap[name] === isMaybeObjectsEqual) {
        let complexObjs = [];
        for (let i3 = propObjs.length - 1; i3 >= 0; i3 -= 1) {
          let val = propObjs[i3][name];
          if (typeof val === "object" && val) {
            complexObjs.unshift(val);
          } else if (val !== void 0) {
            dest[name] = val;
            break;
          }
        }
        if (complexObjs.length) {
          dest[name] = mergeProps(complexObjs);
        }
      }
    }
  }
  for (let i3 = propObjs.length - 1; i3 >= 0; i3 -= 1) {
    let props = propObjs[i3];
    for (let name in props) {
      if (!(name in dest)) {
        dest[name] = props[name];
      }
    }
  }
  return dest;
}
function filterHash(hash, func) {
  let filtered = {};
  for (let key in hash) {
    if (func(hash[key], key)) {
      filtered[key] = hash[key];
    }
  }
  return filtered;
}
function mapHash(hash, func) {
  let newHash = {};
  for (let key in hash) {
    newHash[key] = func(hash[key], key);
  }
  return newHash;
}
function arrayToHash(a3) {
  let hash = {};
  for (let item of a3) {
    hash[item] = true;
  }
  return hash;
}
function hashValuesToArray(obj) {
  let a3 = [];
  for (let key in obj) {
    a3.push(obj[key]);
  }
  return a3;
}
function isPropsEqual(obj0, obj1) {
  if (obj0 === obj1) {
    return true;
  }
  for (let key in obj0) {
    if (hasOwnProperty.call(obj0, key)) {
      if (!(key in obj1)) {
        return false;
      }
    }
  }
  for (let key in obj1) {
    if (hasOwnProperty.call(obj1, key)) {
      if (obj0[key] !== obj1[key]) {
        return false;
      }
    }
  }
  return true;
}
var HANDLER_RE = /^on[A-Z]/;
function isNonHandlerPropsEqual(obj0, obj1) {
  const keys = getUnequalProps(obj0, obj1);
  for (let key of keys) {
    if (!HANDLER_RE.test(key)) {
      return false;
    }
  }
  return true;
}
function getUnequalProps(obj0, obj1) {
  let keys = [];
  for (let key in obj0) {
    if (hasOwnProperty.call(obj0, key)) {
      if (!(key in obj1)) {
        keys.push(key);
      }
    }
  }
  for (let key in obj1) {
    if (hasOwnProperty.call(obj1, key)) {
      if (obj0[key] !== obj1[key]) {
        keys.push(key);
      }
    }
  }
  return keys;
}
function compareObjs(oldProps, newProps, equalityFuncs = {}) {
  if (oldProps === newProps) {
    return true;
  }
  for (let key in newProps) {
    if (key in oldProps && isObjValsEqual(oldProps[key], newProps[key], equalityFuncs[key]))
      ;
    else {
      return false;
    }
  }
  for (let key in oldProps) {
    if (!(key in newProps)) {
      return false;
    }
  }
  return true;
}
function isObjValsEqual(val0, val1, comparator) {
  if (val0 === val1 || comparator === true) {
    return true;
  }
  if (comparator) {
    return comparator(val0, val1);
  }
  return false;
}
function collectFromHash(hash, startIndex = 0, endIndex, step = 1) {
  let res = [];
  if (endIndex == null) {
    endIndex = Object.keys(hash).length;
  }
  for (let i3 = startIndex; i3 < endIndex; i3 += step) {
    let val = hash[i3];
    if (val !== void 0) {
      res.push(val);
    }
  }
  return res;
}
var calendarSystemClassMap = {};
function registerCalendarSystem(name, theClass) {
  calendarSystemClassMap[name] = theClass;
}
function createCalendarSystem(name) {
  return new calendarSystemClassMap[name]();
}
var GregorianCalendarSystem = class {
  getMarkerYear(d2) {
    return d2.getUTCFullYear();
  }
  getMarkerMonth(d2) {
    return d2.getUTCMonth();
  }
  getMarkerDay(d2) {
    return d2.getUTCDate();
  }
  arrayToMarker(arr) {
    return arrayToUtcDate(arr);
  }
  markerToArray(marker) {
    return dateToUtcArray(marker);
  }
};
registerCalendarSystem("gregory", GregorianCalendarSystem);
var ISO_RE = /^\s*(\d{4})(-?(\d{2})(-?(\d{2})([T ](\d{2}):?(\d{2})(:?(\d{2})(\.(\d+))?)?(Z|(([-+])(\d{2})(:?(\d{2}))?))?)?)?)?$/;
function parse(str) {
  let m3 = ISO_RE.exec(str);
  if (m3) {
    let marker = new Date(Date.UTC(Number(m3[1]), m3[3] ? Number(m3[3]) - 1 : 0, Number(m3[5] || 1), Number(m3[7] || 0), Number(m3[8] || 0), Number(m3[10] || 0), m3[12] ? Number(`0.${m3[12]}`) * 1e3 : 0));
    if (isValidDate(marker)) {
      let timeZoneOffset = null;
      if (m3[13]) {
        timeZoneOffset = (m3[15] === "-" ? -1 : 1) * (Number(m3[16] || 0) * 60 + Number(m3[18] || 0));
      }
      return {
        marker,
        isTimeUnspecified: !m3[6],
        timeZoneOffset
      };
    }
  }
  return null;
}
var DateEnv = class {
  constructor(settings) {
    let timeZone = this.timeZone = settings.timeZone;
    let isNamedTimeZone = timeZone !== "local" && timeZone !== "UTC";
    if (settings.namedTimeZoneImpl && isNamedTimeZone) {
      this.namedTimeZoneImpl = new settings.namedTimeZoneImpl(timeZone);
    }
    this.canComputeOffset = Boolean(!isNamedTimeZone || this.namedTimeZoneImpl);
    this.calendarSystem = createCalendarSystem(settings.calendarSystem);
    this.locale = settings.locale;
    this.weekDow = settings.locale.week.dow;
    this.weekDoy = settings.locale.week.doy;
    if (settings.weekNumberCalculation === "ISO") {
      this.weekDow = 1;
      this.weekDoy = 4;
    }
    if (typeof settings.firstDay === "number") {
      this.weekDow = settings.firstDay;
    }
    if (typeof settings.weekNumberCalculation === "function") {
      this.weekNumberFunc = settings.weekNumberCalculation;
    }
    this.weekText = settings.weekText != null ? settings.weekText : settings.locale.options.weekText;
    this.weekTextLong = (settings.weekTextLong != null ? settings.weekTextLong : settings.locale.options.weekTextLong) || this.weekText;
    this.cmdFormatter = settings.cmdFormatter;
    this.defaultSeparator = settings.defaultSeparator;
  }
  // Creating / Parsing
  createMarker(input) {
    let meta = this.createMarkerMeta(input);
    if (meta === null) {
      return null;
    }
    return meta.marker;
  }
  createNowMarker() {
    if (this.canComputeOffset) {
      return this.timestampToMarker(new Date().valueOf());
    }
    return arrayToUtcDate(dateToLocalArray(new Date()));
  }
  createMarkerMeta(input) {
    if (typeof input === "string") {
      return this.parse(input);
    }
    let marker = null;
    if (typeof input === "number") {
      marker = this.timestampToMarker(input);
    } else if (input instanceof Date) {
      input = input.valueOf();
      if (!isNaN(input)) {
        marker = this.timestampToMarker(input);
      }
    } else if (Array.isArray(input)) {
      marker = arrayToUtcDate(input);
    }
    if (marker === null || !isValidDate(marker)) {
      return null;
    }
    return { marker, isTimeUnspecified: false, forcedTzo: null };
  }
  parse(s3) {
    let parts = parse(s3);
    if (parts === null) {
      return null;
    }
    let { marker } = parts;
    let forcedTzo = null;
    if (parts.timeZoneOffset !== null) {
      if (this.canComputeOffset) {
        marker = this.timestampToMarker(marker.valueOf() - parts.timeZoneOffset * 60 * 1e3);
      } else {
        forcedTzo = parts.timeZoneOffset;
      }
    }
    return { marker, isTimeUnspecified: parts.isTimeUnspecified, forcedTzo };
  }
  // Accessors
  getYear(marker) {
    return this.calendarSystem.getMarkerYear(marker);
  }
  getMonth(marker) {
    return this.calendarSystem.getMarkerMonth(marker);
  }
  getDay(marker) {
    return this.calendarSystem.getMarkerDay(marker);
  }
  // Adding / Subtracting
  add(marker, dur) {
    let a3 = this.calendarSystem.markerToArray(marker);
    a3[0] += dur.years;
    a3[1] += dur.months;
    a3[2] += dur.days;
    a3[6] += dur.milliseconds;
    return this.calendarSystem.arrayToMarker(a3);
  }
  subtract(marker, dur) {
    let a3 = this.calendarSystem.markerToArray(marker);
    a3[0] -= dur.years;
    a3[1] -= dur.months;
    a3[2] -= dur.days;
    a3[6] -= dur.milliseconds;
    return this.calendarSystem.arrayToMarker(a3);
  }
  addYears(marker, n2) {
    let a3 = this.calendarSystem.markerToArray(marker);
    a3[0] += n2;
    return this.calendarSystem.arrayToMarker(a3);
  }
  addMonths(marker, n2) {
    let a3 = this.calendarSystem.markerToArray(marker);
    a3[1] += n2;
    return this.calendarSystem.arrayToMarker(a3);
  }
  // Diffing Whole Units
  diffWholeYears(m0, m1) {
    let { calendarSystem } = this;
    if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1) && calendarSystem.getMarkerMonth(m0) === calendarSystem.getMarkerMonth(m1)) {
      return calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0);
    }
    return null;
  }
  diffWholeMonths(m0, m1) {
    let { calendarSystem } = this;
    if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1)) {
      return calendarSystem.getMarkerMonth(m1) - calendarSystem.getMarkerMonth(m0) + (calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0)) * 12;
    }
    return null;
  }
  // Range / Duration
  greatestWholeUnit(m0, m1) {
    let n2 = this.diffWholeYears(m0, m1);
    if (n2 !== null) {
      return { unit: "year", value: n2 };
    }
    n2 = this.diffWholeMonths(m0, m1);
    if (n2 !== null) {
      return { unit: "month", value: n2 };
    }
    n2 = diffWholeWeeks(m0, m1);
    if (n2 !== null) {
      return { unit: "week", value: n2 };
    }
    n2 = diffWholeDays(m0, m1);
    if (n2 !== null) {
      return { unit: "day", value: n2 };
    }
    n2 = diffHours(m0, m1);
    if (isInt(n2)) {
      return { unit: "hour", value: n2 };
    }
    n2 = diffMinutes(m0, m1);
    if (isInt(n2)) {
      return { unit: "minute", value: n2 };
    }
    n2 = diffSeconds(m0, m1);
    if (isInt(n2)) {
      return { unit: "second", value: n2 };
    }
    return { unit: "millisecond", value: m1.valueOf() - m0.valueOf() };
  }
  countDurationsBetween(m0, m1, d2) {
    let diff;
    if (d2.years) {
      diff = this.diffWholeYears(m0, m1);
      if (diff !== null) {
        return diff / asRoughYears(d2);
      }
    }
    if (d2.months) {
      diff = this.diffWholeMonths(m0, m1);
      if (diff !== null) {
        return diff / asRoughMonths(d2);
      }
    }
    if (d2.days) {
      diff = diffWholeDays(m0, m1);
      if (diff !== null) {
        return diff / asRoughDays(d2);
      }
    }
    return (m1.valueOf() - m0.valueOf()) / asRoughMs(d2);
  }
  // Start-Of
  // these DON'T return zoned-dates. only UTC start-of dates
  startOf(m3, unit) {
    if (unit === "year") {
      return this.startOfYear(m3);
    }
    if (unit === "month") {
      return this.startOfMonth(m3);
    }
    if (unit === "week") {
      return this.startOfWeek(m3);
    }
    if (unit === "day") {
      return startOfDay(m3);
    }
    if (unit === "hour") {
      return startOfHour(m3);
    }
    if (unit === "minute") {
      return startOfMinute(m3);
    }
    if (unit === "second") {
      return startOfSecond(m3);
    }
    return null;
  }
  startOfYear(m3) {
    return this.calendarSystem.arrayToMarker([
      this.calendarSystem.getMarkerYear(m3)
    ]);
  }
  startOfMonth(m3) {
    return this.calendarSystem.arrayToMarker([
      this.calendarSystem.getMarkerYear(m3),
      this.calendarSystem.getMarkerMonth(m3)
    ]);
  }
  startOfWeek(m3) {
    return this.calendarSystem.arrayToMarker([
      this.calendarSystem.getMarkerYear(m3),
      this.calendarSystem.getMarkerMonth(m3),
      m3.getUTCDate() - (m3.getUTCDay() - this.weekDow + 7) % 7
    ]);
  }
  // Week Number
  computeWeekNumber(marker) {
    if (this.weekNumberFunc) {
      return this.weekNumberFunc(this.toDate(marker));
    }
    return weekOfYear(marker, this.weekDow, this.weekDoy);
  }
  // TODO: choke on timeZoneName: long
  format(marker, formatter, dateOptions = {}) {
    return formatter.format({
      marker,
      timeZoneOffset: dateOptions.forcedTzo != null ? dateOptions.forcedTzo : this.offsetForMarker(marker)
    }, this);
  }
  formatRange(start, end, formatter, dateOptions = {}) {
    if (dateOptions.isEndExclusive) {
      end = addMs(end, -1);
    }
    return formatter.formatRange({
      marker: start,
      timeZoneOffset: dateOptions.forcedStartTzo != null ? dateOptions.forcedStartTzo : this.offsetForMarker(start)
    }, {
      marker: end,
      timeZoneOffset: dateOptions.forcedEndTzo != null ? dateOptions.forcedEndTzo : this.offsetForMarker(end)
    }, this, dateOptions.defaultSeparator);
  }
  /*
  DUMB: the omitTime arg is dumb. if we omit the time, we want to omit the timezone offset. and if we do that,
  might as well use buildIsoString or some other util directly
  */
  formatIso(marker, extraOptions = {}) {
    let timeZoneOffset = null;
    if (!extraOptions.omitTimeZoneOffset) {
      if (extraOptions.forcedTzo != null) {
        timeZoneOffset = extraOptions.forcedTzo;
      } else {
        timeZoneOffset = this.offsetForMarker(marker);
      }
    }
    return buildIsoString(marker, timeZoneOffset, extraOptions.omitTime);
  }
  // TimeZone
  timestampToMarker(ms) {
    if (this.timeZone === "local") {
      return arrayToUtcDate(dateToLocalArray(new Date(ms)));
    }
    if (this.timeZone === "UTC" || !this.namedTimeZoneImpl) {
      return new Date(ms);
    }
    return arrayToUtcDate(this.namedTimeZoneImpl.timestampToArray(ms));
  }
  offsetForMarker(m3) {
    if (this.timeZone === "local") {
      return -arrayToLocalDate(dateToUtcArray(m3)).getTimezoneOffset();
    }
    if (this.timeZone === "UTC") {
      return 0;
    }
    if (this.namedTimeZoneImpl) {
      return this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m3));
    }
    return null;
  }
  // Conversion
  toDate(m3, forcedTzo) {
    if (this.timeZone === "local") {
      return arrayToLocalDate(dateToUtcArray(m3));
    }
    if (this.timeZone === "UTC") {
      return new Date(m3.valueOf());
    }
    if (!this.namedTimeZoneImpl) {
      return new Date(m3.valueOf() - (forcedTzo || 0));
    }
    return new Date(m3.valueOf() - this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m3)) * 1e3 * 60);
  }
};
var Theme = class {
  constructor(calendarOptions) {
    if (this.iconOverrideOption) {
      this.setIconOverride(calendarOptions[this.iconOverrideOption]);
    }
  }
  setIconOverride(iconOverrideHash) {
    let iconClassesCopy;
    let buttonName;
    if (typeof iconOverrideHash === "object" && iconOverrideHash) {
      iconClassesCopy = Object.assign({}, this.iconClasses);
      for (buttonName in iconOverrideHash) {
        iconClassesCopy[buttonName] = this.applyIconOverridePrefix(iconOverrideHash[buttonName]);
      }
      this.iconClasses = iconClassesCopy;
    } else if (iconOverrideHash === false) {
      this.iconClasses = {};
    }
  }
  applyIconOverridePrefix(className) {
    let prefix = this.iconOverridePrefix;
    if (prefix && className.indexOf(prefix) !== 0) {
      className = prefix + className;
    }
    return className;
  }
  getClass(key) {
    return this.classes[key] || "";
  }
  getIconClass(buttonName, isRtl) {
    let className;
    if (isRtl && this.rtlIconClasses) {
      className = this.rtlIconClasses[buttonName] || this.iconClasses[buttonName];
    } else {
      className = this.iconClasses[buttonName];
    }
    if (className) {
      return `${this.baseIconClass} ${className}`;
    }
    return "";
  }
  getCustomButtonIconClass(customButtonProps) {
    let className;
    if (this.iconOverrideCustomButtonOption) {
      className = customButtonProps[this.iconOverrideCustomButtonOption];
      if (className) {
        return `${this.baseIconClass} ${this.applyIconOverridePrefix(className)}`;
      }
    }
    return "";
  }
};
Theme.prototype.classes = {};
Theme.prototype.iconClasses = {};
Theme.prototype.baseIconClass = "";
Theme.prototype.iconOverridePrefix = "";
function flushSync(runBeforeFlush) {
  runBeforeFlush();
  let oldDebounceRendering = l.debounceRendering;
  let callbackQ = [];
  function execCallbackSync(callback) {
    callbackQ.push(callback);
  }
  l.debounceRendering = execCallbackSync;
  D(y(FakeComponent, {}), document.createElement("div"));
  while (callbackQ.length) {
    callbackQ.shift()();
  }
  l.debounceRendering = oldDebounceRendering;
}
var FakeComponent = class extends x {
  render() {
    return y("div", {});
  }
  componentDidMount() {
    this.setState({});
  }
};
function createContext(defaultValue) {
  let ContextType = G(defaultValue);
  let origProvider = ContextType.Provider;
  ContextType.Provider = function() {
    let isNew = !this.getChildContext;
    let children = origProvider.apply(this, arguments);
    if (isNew) {
      let subs = [];
      this.shouldComponentUpdate = (_props) => {
        if (this.props.value !== _props.value) {
          subs.forEach((c3) => {
            c3.context = _props.value;
            c3.forceUpdate();
          });
        }
      };
      this.sub = (c3) => {
        subs.push(c3);
        let old = c3.componentWillUnmount;
        c3.componentWillUnmount = () => {
          subs.splice(subs.indexOf(c3), 1);
          old && old.call(c3);
        };
      };
    }
    return children;
  };
  return ContextType;
}
var ScrollResponder = class {
  constructor(execFunc, emitter, scrollTime, scrollTimeReset) {
    this.execFunc = execFunc;
    this.emitter = emitter;
    this.scrollTime = scrollTime;
    this.scrollTimeReset = scrollTimeReset;
    this.handleScrollRequest = (request) => {
      this.queuedRequest = Object.assign({}, this.queuedRequest || {}, request);
      this.drain();
    };
    emitter.on("_scrollRequest", this.handleScrollRequest);
    this.fireInitialScroll();
  }
  detach() {
    this.emitter.off("_scrollRequest", this.handleScrollRequest);
  }
  update(isDatesNew) {
    if (isDatesNew && this.scrollTimeReset) {
      this.fireInitialScroll();
    } else {
      this.drain();
    }
  }
  fireInitialScroll() {
    this.handleScrollRequest({
      time: this.scrollTime
    });
  }
  drain() {
    if (this.queuedRequest && this.execFunc(this.queuedRequest)) {
      this.queuedRequest = null;
    }
  }
};
var ViewContextType = createContext({});
function buildViewContext(viewSpec, viewApi, viewOptions, dateProfileGenerator, dateEnv, theme, pluginHooks, dispatch, getCurrentData, emitter, calendarApi, registerInteractiveComponent, unregisterInteractiveComponent) {
  return {
    dateEnv,
    options: viewOptions,
    pluginHooks,
    emitter,
    dispatch,
    getCurrentData,
    calendarApi,
    viewSpec,
    viewApi,
    dateProfileGenerator,
    theme,
    isRtl: viewOptions.direction === "rtl",
    addResizeHandler(handler) {
      emitter.on("_resize", handler);
    },
    removeResizeHandler(handler) {
      emitter.off("_resize", handler);
    },
    createScrollResponder(execFunc) {
      return new ScrollResponder(execFunc, emitter, createDuration(viewOptions.scrollTime), viewOptions.scrollTimeReset);
    },
    registerInteractiveComponent,
    unregisterInteractiveComponent
  };
}
var PureComponent = class extends x {
  shouldComponentUpdate(nextProps, nextState) {
    if (this.debug) {
      console.log(getUnequalProps(nextProps, this.props), getUnequalProps(nextState, this.state));
    }
    return !compareObjs(this.props, nextProps, this.propEquality) || !compareObjs(this.state, nextState, this.stateEquality);
  }
  // HACK for freakin' React StrictMode
  safeSetState(newState) {
    if (!compareObjs(this.state, Object.assign(Object.assign({}, this.state), newState), this.stateEquality)) {
      this.setState(newState);
    }
  }
};
PureComponent.addPropsEquality = addPropsEquality;
PureComponent.addStateEquality = addStateEquality;
PureComponent.contextType = ViewContextType;
PureComponent.prototype.propEquality = {};
PureComponent.prototype.stateEquality = {};
var BaseComponent = class extends PureComponent {
};
BaseComponent.contextType = ViewContextType;
function addPropsEquality(propEquality) {
  let hash = Object.create(this.prototype.propEquality);
  Object.assign(hash, propEquality);
  this.prototype.propEquality = hash;
}
function addStateEquality(stateEquality) {
  let hash = Object.create(this.prototype.stateEquality);
  Object.assign(hash, stateEquality);
  this.prototype.stateEquality = hash;
}
function setRef(ref, current) {
  if (typeof ref === "function") {
    ref(current);
  } else if (ref) {
    ref.current = current;
  }
}
var ContentInjector = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.id = guid();
    this.queuedDomNodes = [];
    this.currentDomNodes = [];
    this.handleEl = (el) => {
      const { options } = this.context;
      const { generatorName } = this.props;
      if (!options.customRenderingReplaces || !hasCustomRenderingHandler(generatorName, options)) {
        this.updateElRef(el);
      }
    };
    this.updateElRef = (el) => {
      if (this.props.elRef) {
        setRef(this.props.elRef, el);
      }
    };
  }
  render() {
    const { props, context } = this;
    const { options } = context;
    const { customGenerator, defaultGenerator, renderProps } = props;
    const attrs = buildElAttrs(props, [], this.handleEl);
    let useDefault = false;
    let innerContent;
    let queuedDomNodes = [];
    let currentGeneratorMeta;
    if (customGenerator != null) {
      const customGeneratorRes = typeof customGenerator === "function" ? customGenerator(renderProps, y) : customGenerator;
      if (customGeneratorRes === true) {
        useDefault = true;
      } else {
        const isObject2 = customGeneratorRes && typeof customGeneratorRes === "object";
        if (isObject2 && "html" in customGeneratorRes) {
          attrs.dangerouslySetInnerHTML = { __html: customGeneratorRes.html };
        } else if (isObject2 && "domNodes" in customGeneratorRes) {
          queuedDomNodes = Array.prototype.slice.call(customGeneratorRes.domNodes);
        } else if (isObject2 ? i(customGeneratorRes) : typeof customGeneratorRes !== "function") {
          innerContent = customGeneratorRes;
        } else {
          currentGeneratorMeta = customGeneratorRes;
        }
      }
    } else {
      useDefault = !hasCustomRenderingHandler(props.generatorName, options);
    }
    if (useDefault && defaultGenerator) {
      innerContent = defaultGenerator(renderProps);
    }
    this.queuedDomNodes = queuedDomNodes;
    this.currentGeneratorMeta = currentGeneratorMeta;
    return y(props.elTag, attrs, innerContent);
  }
  componentDidMount() {
    this.applyQueueudDomNodes();
    this.triggerCustomRendering(true);
  }
  componentDidUpdate() {
    this.applyQueueudDomNodes();
    this.triggerCustomRendering(true);
  }
  componentWillUnmount() {
    this.triggerCustomRendering(false);
  }
  triggerCustomRendering(isActive) {
    var _a;
    const { props, context } = this;
    const { handleCustomRendering, customRenderingMetaMap } = context.options;
    if (handleCustomRendering) {
      const generatorMeta = (_a = this.currentGeneratorMeta) !== null && _a !== void 0 ? _a : customRenderingMetaMap === null || customRenderingMetaMap === void 0 ? void 0 : customRenderingMetaMap[props.generatorName];
      if (generatorMeta) {
        handleCustomRendering(Object.assign(Object.assign({
          id: this.id,
          isActive,
          containerEl: this.base,
          reportNewContainerEl: this.updateElRef,
          // front-end framework tells us about new container els
          generatorMeta
        }, props), { elClasses: (props.elClasses || []).filter(isTruthy) }));
      }
    }
  }
  applyQueueudDomNodes() {
    const { queuedDomNodes, currentDomNodes } = this;
    const el = this.base;
    if (!isArraysEqual(queuedDomNodes, currentDomNodes)) {
      currentDomNodes.forEach(removeElement);
      for (let newNode of queuedDomNodes) {
        el.appendChild(newNode);
      }
      this.currentDomNodes = queuedDomNodes;
    }
  }
};
ContentInjector.addPropsEquality({
  elClasses: isArraysEqual,
  elStyle: isPropsEqual,
  elAttrs: isNonHandlerPropsEqual,
  renderProps: isPropsEqual
});
function hasCustomRenderingHandler(generatorName, options) {
  var _a;
  return Boolean(options.handleCustomRendering && generatorName && ((_a = options.customRenderingMetaMap) === null || _a === void 0 ? void 0 : _a[generatorName]));
}
function buildElAttrs(props, extraClassNames, elRef) {
  const attrs = Object.assign(Object.assign({}, props.elAttrs), { ref: elRef });
  if (props.elClasses || extraClassNames) {
    attrs.className = (props.elClasses || []).concat(extraClassNames || []).concat(attrs.className || []).filter(Boolean).join(" ");
  }
  if (props.elStyle) {
    attrs.style = props.elStyle;
  }
  return attrs;
}
function isTruthy(val) {
  return Boolean(val);
}
var RenderId = createContext(0);
var ContentContainer = class extends x {
  constructor() {
    super(...arguments);
    this.InnerContent = InnerContentInjector.bind(void 0, this);
    this.handleEl = (el) => {
      this.el = el;
      if (this.props.elRef) {
        setRef(this.props.elRef, el);
        if (el && this.didMountMisfire) {
          this.componentDidMount();
        }
      }
    };
  }
  render() {
    const { props } = this;
    const generatedClassNames = generateClassNames(props.classNameGenerator, props.renderProps);
    if (props.children) {
      const elAttrs = buildElAttrs(props, generatedClassNames, this.handleEl);
      const children = props.children(this.InnerContent, props.renderProps, elAttrs);
      if (props.elTag) {
        return y(props.elTag, elAttrs, children);
      } else {
        return children;
      }
    } else {
      return y(ContentInjector, Object.assign(Object.assign({}, props), { elRef: this.handleEl, elTag: props.elTag || "div", elClasses: (props.elClasses || []).concat(generatedClassNames), renderId: this.context }));
    }
  }
  componentDidMount() {
    var _a, _b;
    if (this.el) {
      (_b = (_a = this.props).didMount) === null || _b === void 0 ? void 0 : _b.call(_a, Object.assign(Object.assign({}, this.props.renderProps), { el: this.el }));
    } else {
      this.didMountMisfire = true;
    }
  }
  componentWillUnmount() {
    var _a, _b;
    (_b = (_a = this.props).willUnmount) === null || _b === void 0 ? void 0 : _b.call(_a, Object.assign(Object.assign({}, this.props.renderProps), { el: this.el }));
  }
};
ContentContainer.contextType = RenderId;
function InnerContentInjector(containerComponent, props) {
  const parentProps = containerComponent.props;
  return y(ContentInjector, Object.assign({ renderProps: parentProps.renderProps, generatorName: parentProps.generatorName, customGenerator: parentProps.customGenerator, defaultGenerator: parentProps.defaultGenerator, renderId: containerComponent.context }, props));
}
function generateClassNames(classNameGenerator, renderProps) {
  const classNames = typeof classNameGenerator === "function" ? classNameGenerator(renderProps) : classNameGenerator || [];
  return typeof classNames === "string" ? [classNames] : classNames;
}
var ViewContainer = class extends BaseComponent {
  render() {
    let { props, context } = this;
    let { options } = context;
    let renderProps = { view: context.viewApi };
    return y(ContentContainer, Object.assign({}, props, { elTag: props.elTag || "div", elClasses: [
      ...buildViewClassNames(props.viewSpec),
      ...props.elClasses || []
    ], renderProps, classNameGenerator: options.viewClassNames, generatorName: void 0, didMount: options.viewDidMount, willUnmount: options.viewWillUnmount }), () => props.children);
  }
};
function buildViewClassNames(viewSpec) {
  return [
    `fc-${viewSpec.type}-view`,
    "fc-view"
  ];
}
function parseRange(input, dateEnv) {
  let start = null;
  let end = null;
  if (input.start) {
    start = dateEnv.createMarker(input.start);
  }
  if (input.end) {
    end = dateEnv.createMarker(input.end);
  }
  if (!start && !end) {
    return null;
  }
  if (start && end && end < start) {
    return null;
  }
  return { start, end };
}
function invertRanges(ranges, constraintRange) {
  let invertedRanges = [];
  let { start } = constraintRange;
  let i3;
  let dateRange;
  ranges.sort(compareRanges);
  for (i3 = 0; i3 < ranges.length; i3 += 1) {
    dateRange = ranges[i3];
    if (dateRange.start > start) {
      invertedRanges.push({ start, end: dateRange.start });
    }
    if (dateRange.end > start) {
      start = dateRange.end;
    }
  }
  if (start < constraintRange.end) {
    invertedRanges.push({ start, end: constraintRange.end });
  }
  return invertedRanges;
}
function compareRanges(range0, range1) {
  return range0.start.valueOf() - range1.start.valueOf();
}
function intersectRanges(range0, range1) {
  let { start, end } = range0;
  let newRange = null;
  if (range1.start !== null) {
    if (start === null) {
      start = range1.start;
    } else {
      start = new Date(Math.max(start.valueOf(), range1.start.valueOf()));
    }
  }
  if (range1.end != null) {
    if (end === null) {
      end = range1.end;
    } else {
      end = new Date(Math.min(end.valueOf(), range1.end.valueOf()));
    }
  }
  if (start === null || end === null || start < end) {
    newRange = { start, end };
  }
  return newRange;
}
function rangesEqual(range0, range1) {
  return (range0.start === null ? null : range0.start.valueOf()) === (range1.start === null ? null : range1.start.valueOf()) && (range0.end === null ? null : range0.end.valueOf()) === (range1.end === null ? null : range1.end.valueOf());
}
function rangesIntersect(range0, range1) {
  return (range0.end === null || range1.start === null || range0.end > range1.start) && (range0.start === null || range1.end === null || range0.start < range1.end);
}
function rangeContainsRange(outerRange, innerRange) {
  return (outerRange.start === null || innerRange.start !== null && innerRange.start >= outerRange.start) && (outerRange.end === null || innerRange.end !== null && innerRange.end <= outerRange.end);
}
function rangeContainsMarker(range2, date) {
  return (range2.start === null || date >= range2.start) && (range2.end === null || date < range2.end);
}
function constrainMarkerToRange(date, range2) {
  if (range2.start != null && date < range2.start) {
    return range2.start;
  }
  if (range2.end != null && date >= range2.end) {
    return new Date(range2.end.valueOf() - 1);
  }
  return date;
}
function computeAlignedDayRange(timedRange) {
  let dayCnt = Math.floor(diffDays(timedRange.start, timedRange.end)) || 1;
  let start = startOfDay(timedRange.start);
  let end = addDays(start, dayCnt);
  return { start, end };
}
function computeVisibleDayRange(timedRange, nextDayThreshold = createDuration(0)) {
  let startDay = null;
  let endDay = null;
  if (timedRange.end) {
    endDay = startOfDay(timedRange.end);
    let endTimeMS = timedRange.end.valueOf() - endDay.valueOf();
    if (endTimeMS && endTimeMS >= asRoughMs(nextDayThreshold)) {
      endDay = addDays(endDay, 1);
    }
  }
  if (timedRange.start) {
    startDay = startOfDay(timedRange.start);
    if (endDay && endDay <= startDay) {
      endDay = addDays(startDay, 1);
    }
  }
  return { start: startDay, end: endDay };
}
function isMultiDayRange(range2) {
  let visibleRange = computeVisibleDayRange(range2);
  return diffDays(visibleRange.start, visibleRange.end) > 1;
}
function diffDates(date0, date1, dateEnv, largeUnit) {
  if (largeUnit === "year") {
    return createDuration(dateEnv.diffWholeYears(date0, date1), "year");
  }
  if (largeUnit === "month") {
    return createDuration(dateEnv.diffWholeMonths(date0, date1), "month");
  }
  return diffDayAndTime(date0, date1);
}
function reduceCurrentDate(currentDate, action) {
  switch (action.type) {
    case "CHANGE_DATE":
      return action.dateMarker;
    default:
      return currentDate;
  }
}
function getInitialDate(options, dateEnv) {
  let initialDateInput = options.initialDate;
  if (initialDateInput != null) {
    return dateEnv.createMarker(initialDateInput);
  }
  return getNow(options.now, dateEnv);
}
function getNow(nowInput, dateEnv) {
  if (typeof nowInput === "function") {
    nowInput = nowInput();
  }
  if (nowInput == null) {
    return dateEnv.createNowMarker();
  }
  return dateEnv.createMarker(nowInput);
}
var DateProfileGenerator = class {
  constructor(props) {
    this.props = props;
    this.nowDate = getNow(props.nowInput, props.dateEnv);
    this.initHiddenDays();
  }
  /* Date Range Computation
  ------------------------------------------------------------------------------------------------------------------*/
  // Builds a structure with info about what the dates/ranges will be for the "prev" view.
  buildPrev(currentDateProfile, currentDate, forceToValid) {
    let { dateEnv } = this.props;
    let prevDate = dateEnv.subtract(
      dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit),
      // important for start-of-month
      currentDateProfile.dateIncrement
    );
    return this.build(prevDate, -1, forceToValid);
  }
  // Builds a structure with info about what the dates/ranges will be for the "next" view.
  buildNext(currentDateProfile, currentDate, forceToValid) {
    let { dateEnv } = this.props;
    let nextDate = dateEnv.add(
      dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit),
      // important for start-of-month
      currentDateProfile.dateIncrement
    );
    return this.build(nextDate, 1, forceToValid);
  }
  // Builds a structure holding dates/ranges for rendering around the given date.
  // Optional direction param indicates whether the date is being incremented/decremented
  // from its previous value. decremented = -1, incremented = 1 (default).
  build(currentDate, direction, forceToValid = true) {
    let { props } = this;
    let validRange;
    let currentInfo;
    let isRangeAllDay;
    let renderRange;
    let activeRange;
    let isValid;
    validRange = this.buildValidRange();
    validRange = this.trimHiddenDays(validRange);
    if (forceToValid) {
      currentDate = constrainMarkerToRange(currentDate, validRange);
    }
    currentInfo = this.buildCurrentRangeInfo(currentDate, direction);
    isRangeAllDay = /^(year|month|week|day)$/.test(currentInfo.unit);
    renderRange = this.buildRenderRange(this.trimHiddenDays(currentInfo.range), currentInfo.unit, isRangeAllDay);
    renderRange = this.trimHiddenDays(renderRange);
    activeRange = renderRange;
    if (!props.showNonCurrentDates) {
      activeRange = intersectRanges(activeRange, currentInfo.range);
    }
    activeRange = this.adjustActiveRange(activeRange);
    activeRange = intersectRanges(activeRange, validRange);
    isValid = rangesIntersect(currentInfo.range, validRange);
    if (!rangeContainsMarker(renderRange, currentDate)) {
      currentDate = renderRange.start;
    }
    return {
      currentDate,
      // constraint for where prev/next operations can go and where events can be dragged/resized to.
      // an object with optional start and end properties.
      validRange,
      // range the view is formally responsible for.
      // for example, a month view might have 1st-31st, excluding padded dates
      currentRange: currentInfo.range,
      // name of largest unit being displayed, like "month" or "week"
      currentRangeUnit: currentInfo.unit,
      isRangeAllDay,
      // dates that display events and accept drag-n-drop
      // will be `null` if no dates accept events
      activeRange,
      // date range with a rendered skeleton
      // includes not-active days that need some sort of DOM
      renderRange,
      // Duration object that denotes the first visible time of any given day
      slotMinTime: props.slotMinTime,
      // Duration object that denotes the exclusive visible end time of any given day
      slotMaxTime: props.slotMaxTime,
      isValid,
      // how far the current date will move for a prev/next operation
      dateIncrement: this.buildDateIncrement(currentInfo.duration)
      // pass a fallback (might be null) ^
    };
  }
  // Builds an object with optional start/end properties.
  // Indicates the minimum/maximum dates to display.
  // not responsible for trimming hidden days.
  buildValidRange() {
    let input = this.props.validRangeInput;
    let simpleInput = typeof input === "function" ? input.call(this.props.calendarApi, this.nowDate) : input;
    return this.refineRange(simpleInput) || { start: null, end: null };
  }
  // Builds a structure with info about the "current" range, the range that is
  // highlighted as being the current month for example.
  // See build() for a description of `direction`.
  // Guaranteed to have `range` and `unit` properties. `duration` is optional.
  buildCurrentRangeInfo(date, direction) {
    let { props } = this;
    let duration = null;
    let unit = null;
    let range2 = null;
    let dayCount;
    if (props.duration) {
      duration = props.duration;
      unit = props.durationUnit;
      range2 = this.buildRangeFromDuration(date, direction, duration, unit);
    } else if (dayCount = this.props.dayCount) {
      unit = "day";
      range2 = this.buildRangeFromDayCount(date, direction, dayCount);
    } else if (range2 = this.buildCustomVisibleRange(date)) {
      unit = props.dateEnv.greatestWholeUnit(range2.start, range2.end).unit;
    } else {
      duration = this.getFallbackDuration();
      unit = greatestDurationDenominator(duration).unit;
      range2 = this.buildRangeFromDuration(date, direction, duration, unit);
    }
    return { duration, unit, range: range2 };
  }
  getFallbackDuration() {
    return createDuration({ day: 1 });
  }
  // Returns a new activeRange to have time values (un-ambiguate)
  // slotMinTime or slotMaxTime causes the range to expand.
  adjustActiveRange(range2) {
    let { dateEnv, usesMinMaxTime, slotMinTime, slotMaxTime } = this.props;
    let { start, end } = range2;
    if (usesMinMaxTime) {
      if (asRoughDays(slotMinTime) < 0) {
        start = startOfDay(start);
        start = dateEnv.add(start, slotMinTime);
      }
      if (asRoughDays(slotMaxTime) > 1) {
        end = startOfDay(end);
        end = addDays(end, -1);
        end = dateEnv.add(end, slotMaxTime);
      }
    }
    return { start, end };
  }
  // Builds the "current" range when it is specified as an explicit duration.
  // `unit` is the already-computed greatestDurationDenominator unit of duration.
  buildRangeFromDuration(date, direction, duration, unit) {
    let { dateEnv, dateAlignment } = this.props;
    let start;
    let end;
    let res;
    if (!dateAlignment) {
      let { dateIncrement } = this.props;
      if (dateIncrement) {
        if (asRoughMs(dateIncrement) < asRoughMs(duration)) {
          dateAlignment = greatestDurationDenominator(dateIncrement).unit;
        } else {
          dateAlignment = unit;
        }
      } else {
        dateAlignment = unit;
      }
    }
    if (asRoughDays(duration) <= 1) {
      if (this.isHiddenDay(start)) {
        start = this.skipHiddenDays(start, direction);
        start = startOfDay(start);
      }
    }
    function computeRes() {
      start = dateEnv.startOf(date, dateAlignment);
      end = dateEnv.add(start, duration);
      res = { start, end };
    }
    computeRes();
    if (!this.trimHiddenDays(res)) {
      date = this.skipHiddenDays(date, direction);
      computeRes();
    }
    return res;
  }
  // Builds the "current" range when a dayCount is specified.
  buildRangeFromDayCount(date, direction, dayCount) {
    let { dateEnv, dateAlignment } = this.props;
    let runningCount = 0;
    let start = date;
    let end;
    if (dateAlignment) {
      start = dateEnv.startOf(start, dateAlignment);
    }
    start = startOfDay(start);
    start = this.skipHiddenDays(start, direction);
    end = start;
    do {
      end = addDays(end, 1);
      if (!this.isHiddenDay(end)) {
        runningCount += 1;
      }
    } while (runningCount < dayCount);
    return { start, end };
  }
  // Builds a normalized range object for the "visible" range,
  // which is a way to define the currentRange and activeRange at the same time.
  buildCustomVisibleRange(date) {
    let { props } = this;
    let input = props.visibleRangeInput;
    let simpleInput = typeof input === "function" ? input.call(props.calendarApi, props.dateEnv.toDate(date)) : input;
    let range2 = this.refineRange(simpleInput);
    if (range2 && (range2.start == null || range2.end == null)) {
      return null;
    }
    return range2;
  }
  // Computes the range that will represent the element/cells for *rendering*,
  // but which may have voided days/times.
  // not responsible for trimming hidden days.
  buildRenderRange(currentRange, currentRangeUnit, isRangeAllDay) {
    return currentRange;
  }
  // Compute the duration value that should be added/substracted to the current date
  // when a prev/next operation happens.
  buildDateIncrement(fallback) {
    let { dateIncrement } = this.props;
    let customAlignment;
    if (dateIncrement) {
      return dateIncrement;
    }
    if (customAlignment = this.props.dateAlignment) {
      return createDuration(1, customAlignment);
    }
    if (fallback) {
      return fallback;
    }
    return createDuration({ days: 1 });
  }
  refineRange(rangeInput) {
    if (rangeInput) {
      let range2 = parseRange(rangeInput, this.props.dateEnv);
      if (range2) {
        range2 = computeVisibleDayRange(range2);
      }
      return range2;
    }
    return null;
  }
  /* Hidden Days
  ------------------------------------------------------------------------------------------------------------------*/
  // Initializes internal variables related to calculating hidden days-of-week
  initHiddenDays() {
    let hiddenDays = this.props.hiddenDays || [];
    let isHiddenDayHash = [];
    let dayCnt = 0;
    let i3;
    if (this.props.weekends === false) {
      hiddenDays.push(0, 6);
    }
    for (i3 = 0; i3 < 7; i3 += 1) {
      if (!(isHiddenDayHash[i3] = hiddenDays.indexOf(i3) !== -1)) {
        dayCnt += 1;
      }
    }
    if (!dayCnt) {
      throw new Error("invalid hiddenDays");
    }
    this.isHiddenDayHash = isHiddenDayHash;
  }
  // Remove days from the beginning and end of the range that are computed as hidden.
  // If the whole range is trimmed off, returns null
  trimHiddenDays(range2) {
    let { start, end } = range2;
    if (start) {
      start = this.skipHiddenDays(start);
    }
    if (end) {
      end = this.skipHiddenDays(end, -1, true);
    }
    if (start == null || end == null || start < end) {
      return { start, end };
    }
    return null;
  }
  // Is the current day hidden?
  // `day` is a day-of-week index (0-6), or a Date (used for UTC)
  isHiddenDay(day) {
    if (day instanceof Date) {
      day = day.getUTCDay();
    }
    return this.isHiddenDayHash[day];
  }
  // Incrementing the current day until it is no longer a hidden day, returning a copy.
  // DOES NOT CONSIDER validRange!
  // If the initial value of `date` is not a hidden day, don't do anything.
  // Pass `isExclusive` as `true` if you are dealing with an end date.
  // `inc` defaults to `1` (increment one day forward each time)
  skipHiddenDays(date, inc = 1, isExclusive = false) {
    while (this.isHiddenDayHash[(date.getUTCDay() + (isExclusive ? inc : 0) + 7) % 7]) {
      date = addDays(date, inc);
    }
    return date;
  }
};
function createEventInstance(defId, range2, forcedStartTzo, forcedEndTzo) {
  return {
    instanceId: guid(),
    defId,
    range: range2,
    forcedStartTzo: forcedStartTzo == null ? null : forcedStartTzo,
    forcedEndTzo: forcedEndTzo == null ? null : forcedEndTzo
  };
}
function parseRecurring(refined, defaultAllDay, dateEnv, recurringTypes) {
  for (let i3 = 0; i3 < recurringTypes.length; i3 += 1) {
    let parsed = recurringTypes[i3].parse(refined, dateEnv);
    if (parsed) {
      let { allDay } = refined;
      if (allDay == null) {
        allDay = defaultAllDay;
        if (allDay == null) {
          allDay = parsed.allDayGuess;
          if (allDay == null) {
            allDay = false;
          }
        }
      }
      return {
        allDay,
        duration: parsed.duration,
        typeData: parsed.typeData,
        typeId: i3
      };
    }
  }
  return null;
}
function expandRecurring(eventStore, framingRange, context) {
  let { dateEnv, pluginHooks, options } = context;
  let { defs, instances } = eventStore;
  instances = filterHash(instances, (instance) => !defs[instance.defId].recurringDef);
  for (let defId in defs) {
    let def = defs[defId];
    if (def.recurringDef) {
      let { duration } = def.recurringDef;
      if (!duration) {
        duration = def.allDay ? options.defaultAllDayEventDuration : options.defaultTimedEventDuration;
      }
      let starts = expandRecurringRanges(def, duration, framingRange, dateEnv, pluginHooks.recurringTypes);
      for (let start of starts) {
        let instance = createEventInstance(defId, {
          start,
          end: dateEnv.add(start, duration)
        });
        instances[instance.instanceId] = instance;
      }
    }
  }
  return { defs, instances };
}
function expandRecurringRanges(eventDef, duration, framingRange, dateEnv, recurringTypes) {
  let typeDef = recurringTypes[eventDef.recurringDef.typeId];
  let markers = typeDef.expand(eventDef.recurringDef.typeData, {
    start: dateEnv.subtract(framingRange.start, duration),
    end: framingRange.end
  }, dateEnv);
  if (eventDef.allDay) {
    markers = markers.map(startOfDay);
  }
  return markers;
}
var EVENT_NON_DATE_REFINERS = {
  id: String,
  groupId: String,
  title: String,
  url: String,
  interactive: Boolean
};
var EVENT_DATE_REFINERS = {
  start: identity,
  end: identity,
  date: identity,
  allDay: Boolean
};
var EVENT_REFINERS = Object.assign(Object.assign(Object.assign({}, EVENT_NON_DATE_REFINERS), EVENT_DATE_REFINERS), { extendedProps: identity });
function parseEvent(raw, eventSource, context, allowOpenRange, refiners = buildEventRefiners(context), defIdMap, instanceIdMap) {
  let { refined, extra } = refineEventDef(raw, context, refiners);
  let defaultAllDay = computeIsDefaultAllDay(eventSource, context);
  let recurringRes = parseRecurring(refined, defaultAllDay, context.dateEnv, context.pluginHooks.recurringTypes);
  if (recurringRes) {
    let def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : "", recurringRes.allDay, Boolean(recurringRes.duration), context, defIdMap);
    def.recurringDef = {
      typeId: recurringRes.typeId,
      typeData: recurringRes.typeData,
      duration: recurringRes.duration
    };
    return { def, instance: null };
  }
  let singleRes = parseSingle(refined, defaultAllDay, context, allowOpenRange);
  if (singleRes) {
    let def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : "", singleRes.allDay, singleRes.hasEnd, context, defIdMap);
    let instance = createEventInstance(def.defId, singleRes.range, singleRes.forcedStartTzo, singleRes.forcedEndTzo);
    if (instanceIdMap && def.publicId && instanceIdMap[def.publicId]) {
      instance.instanceId = instanceIdMap[def.publicId];
    }
    return { def, instance };
  }
  return null;
}
function refineEventDef(raw, context, refiners = buildEventRefiners(context)) {
  return refineProps(raw, refiners);
}
function buildEventRefiners(context) {
  return Object.assign(Object.assign(Object.assign({}, EVENT_UI_REFINERS), EVENT_REFINERS), context.pluginHooks.eventRefiners);
}
function parseEventDef(refined, extra, sourceId, allDay, hasEnd, context, defIdMap) {
  let def = {
    title: refined.title || "",
    groupId: refined.groupId || "",
    publicId: refined.id || "",
    url: refined.url || "",
    recurringDef: null,
    defId: (defIdMap && refined.id ? defIdMap[refined.id] : "") || guid(),
    sourceId,
    allDay,
    hasEnd,
    interactive: refined.interactive,
    ui: createEventUi(refined, context),
    extendedProps: Object.assign(Object.assign({}, refined.extendedProps || {}), extra)
  };
  for (let memberAdder of context.pluginHooks.eventDefMemberAdders) {
    Object.assign(def, memberAdder(refined));
  }
  Object.freeze(def.ui.classNames);
  Object.freeze(def.extendedProps);
  return def;
}
function parseSingle(refined, defaultAllDay, context, allowOpenRange) {
  let { allDay } = refined;
  let startMeta;
  let startMarker = null;
  let hasEnd = false;
  let endMeta;
  let endMarker = null;
  let startInput = refined.start != null ? refined.start : refined.date;
  startMeta = context.dateEnv.createMarkerMeta(startInput);
  if (startMeta) {
    startMarker = startMeta.marker;
  } else if (!allowOpenRange) {
    return null;
  }
  if (refined.end != null) {
    endMeta = context.dateEnv.createMarkerMeta(refined.end);
  }
  if (allDay == null) {
    if (defaultAllDay != null) {
      allDay = defaultAllDay;
    } else {
      allDay = (!startMeta || startMeta.isTimeUnspecified) && (!endMeta || endMeta.isTimeUnspecified);
    }
  }
  if (allDay && startMarker) {
    startMarker = startOfDay(startMarker);
  }
  if (endMeta) {
    endMarker = endMeta.marker;
    if (allDay) {
      endMarker = startOfDay(endMarker);
    }
    if (startMarker && endMarker <= startMarker) {
      endMarker = null;
    }
  }
  if (endMarker) {
    hasEnd = true;
  } else if (!allowOpenRange) {
    hasEnd = context.options.forceEventDuration || false;
    endMarker = context.dateEnv.add(startMarker, allDay ? context.options.defaultAllDayEventDuration : context.options.defaultTimedEventDuration);
  }
  return {
    allDay,
    hasEnd,
    range: { start: startMarker, end: endMarker },
    forcedStartTzo: startMeta ? startMeta.forcedTzo : null,
    forcedEndTzo: endMeta ? endMeta.forcedTzo : null
  };
}
function computeIsDefaultAllDay(eventSource, context) {
  let res = null;
  if (eventSource) {
    res = eventSource.defaultAllDay;
  }
  if (res == null) {
    res = context.options.defaultAllDay;
  }
  return res;
}
function parseEvents(rawEvents, eventSource, context, allowOpenRange, defIdMap, instanceIdMap) {
  let eventStore = createEmptyEventStore();
  let eventRefiners = buildEventRefiners(context);
  for (let rawEvent of rawEvents) {
    let tuple = parseEvent(rawEvent, eventSource, context, allowOpenRange, eventRefiners, defIdMap, instanceIdMap);
    if (tuple) {
      eventTupleToStore(tuple, eventStore);
    }
  }
  return eventStore;
}
function eventTupleToStore(tuple, eventStore = createEmptyEventStore()) {
  eventStore.defs[tuple.def.defId] = tuple.def;
  if (tuple.instance) {
    eventStore.instances[tuple.instance.instanceId] = tuple.instance;
  }
  return eventStore;
}
function getRelevantEvents(eventStore, instanceId) {
  let instance = eventStore.instances[instanceId];
  if (instance) {
    let def = eventStore.defs[instance.defId];
    let newStore = filterEventStoreDefs(eventStore, (lookDef) => isEventDefsGrouped(def, lookDef));
    newStore.defs[def.defId] = def;
    newStore.instances[instance.instanceId] = instance;
    return newStore;
  }
  return createEmptyEventStore();
}
function isEventDefsGrouped(def0, def1) {
  return Boolean(def0.groupId && def0.groupId === def1.groupId);
}
function createEmptyEventStore() {
  return { defs: {}, instances: {} };
}
function mergeEventStores(store0, store1) {
  return {
    defs: Object.assign(Object.assign({}, store0.defs), store1.defs),
    instances: Object.assign(Object.assign({}, store0.instances), store1.instances)
  };
}
function filterEventStoreDefs(eventStore, filterFunc) {
  let defs = filterHash(eventStore.defs, filterFunc);
  let instances = filterHash(eventStore.instances, (instance) => defs[instance.defId]);
  return { defs, instances };
}
function excludeSubEventStore(master, sub) {
  let { defs, instances } = master;
  let filteredDefs = {};
  let filteredInstances = {};
  for (let defId in defs) {
    if (!sub.defs[defId]) {
      filteredDefs[defId] = defs[defId];
    }
  }
  for (let instanceId in instances) {
    if (!sub.instances[instanceId] && // not explicitly excluded
    filteredDefs[instances[instanceId].defId]) {
      filteredInstances[instanceId] = instances[instanceId];
    }
  }
  return {
    defs: filteredDefs,
    instances: filteredInstances
  };
}
function normalizeConstraint(input, context) {
  if (Array.isArray(input)) {
    return parseEvents(input, null, context, true);
  }
  if (typeof input === "object" && input) {
    return parseEvents([input], null, context, true);
  }
  if (input != null) {
    return String(input);
  }
  return null;
}
function parseClassNames(raw) {
  if (Array.isArray(raw)) {
    return raw;
  }
  if (typeof raw === "string") {
    return raw.split(/\s+/);
  }
  return [];
}
var EVENT_UI_REFINERS = {
  display: String,
  editable: Boolean,
  startEditable: Boolean,
  durationEditable: Boolean,
  constraint: identity,
  overlap: identity,
  allow: identity,
  className: parseClassNames,
  classNames: parseClassNames,
  color: String,
  backgroundColor: String,
  borderColor: String,
  textColor: String
};
var EMPTY_EVENT_UI = {
  display: null,
  startEditable: null,
  durationEditable: null,
  constraints: [],
  overlap: null,
  allows: [],
  backgroundColor: "",
  borderColor: "",
  textColor: "",
  classNames: []
};
function createEventUi(refined, context) {
  let constraint = normalizeConstraint(refined.constraint, context);
  return {
    display: refined.display || null,
    startEditable: refined.startEditable != null ? refined.startEditable : refined.editable,
    durationEditable: refined.durationEditable != null ? refined.durationEditable : refined.editable,
    constraints: constraint != null ? [constraint] : [],
    overlap: refined.overlap != null ? refined.overlap : null,
    allows: refined.allow != null ? [refined.allow] : [],
    backgroundColor: refined.backgroundColor || refined.color || "",
    borderColor: refined.borderColor || refined.color || "",
    textColor: refined.textColor || "",
    classNames: (refined.className || []).concat(refined.classNames || [])
    // join singular and plural
  };
}
function combineEventUis(uis) {
  return uis.reduce(combineTwoEventUis, EMPTY_EVENT_UI);
}
function combineTwoEventUis(item0, item1) {
  return {
    display: item1.display != null ? item1.display : item0.display,
    startEditable: item1.startEditable != null ? item1.startEditable : item0.startEditable,
    durationEditable: item1.durationEditable != null ? item1.durationEditable : item0.durationEditable,
    constraints: item0.constraints.concat(item1.constraints),
    overlap: typeof item1.overlap === "boolean" ? item1.overlap : item0.overlap,
    allows: item0.allows.concat(item1.allows),
    backgroundColor: item1.backgroundColor || item0.backgroundColor,
    borderColor: item1.borderColor || item0.borderColor,
    textColor: item1.textColor || item0.textColor,
    classNames: item0.classNames.concat(item1.classNames)
  };
}
var EVENT_SOURCE_REFINERS = {
  id: String,
  defaultAllDay: Boolean,
  url: String,
  format: String,
  events: identity,
  eventDataTransform: identity,
  // for any network-related sources
  success: identity,
  failure: identity
};
function parseEventSource(raw, context, refiners = buildEventSourceRefiners(context)) {
  let rawObj;
  if (typeof raw === "string") {
    rawObj = { url: raw };
  } else if (typeof raw === "function" || Array.isArray(raw)) {
    rawObj = { events: raw };
  } else if (typeof raw === "object" && raw) {
    rawObj = raw;
  }
  if (rawObj) {
    let { refined, extra } = refineProps(rawObj, refiners);
    let metaRes = buildEventSourceMeta(refined, context);
    if (metaRes) {
      return {
        _raw: raw,
        isFetching: false,
        latestFetchId: "",
        fetchRange: null,
        defaultAllDay: refined.defaultAllDay,
        eventDataTransform: refined.eventDataTransform,
        success: refined.success,
        failure: refined.failure,
        publicId: refined.id || "",
        sourceId: guid(),
        sourceDefId: metaRes.sourceDefId,
        meta: metaRes.meta,
        ui: createEventUi(refined, context),
        extendedProps: extra
      };
    }
  }
  return null;
}
function buildEventSourceRefiners(context) {
  return Object.assign(Object.assign(Object.assign({}, EVENT_UI_REFINERS), EVENT_SOURCE_REFINERS), context.pluginHooks.eventSourceRefiners);
}
function buildEventSourceMeta(raw, context) {
  let defs = context.pluginHooks.eventSourceDefs;
  for (let i3 = defs.length - 1; i3 >= 0; i3 -= 1) {
    let def = defs[i3];
    let meta = def.parseMeta(raw);
    if (meta) {
      return { sourceDefId: i3, meta };
    }
  }
  return null;
}
function reduceEventStore(eventStore, action, eventSources, dateProfile, context) {
  switch (action.type) {
    case "RECEIVE_EVENTS":
      return receiveRawEvents(eventStore, eventSources[action.sourceId], action.fetchId, action.fetchRange, action.rawEvents, context);
    case "RESET_RAW_EVENTS":
      return resetRawEvents(eventStore, eventSources[action.sourceId], action.rawEvents, dateProfile.activeRange, context);
    case "ADD_EVENTS":
      return addEvent(
        eventStore,
        action.eventStore,
        // new ones
        dateProfile ? dateProfile.activeRange : null,
        context
      );
    case "RESET_EVENTS":
      return action.eventStore;
    case "MERGE_EVENTS":
      return mergeEventStores(eventStore, action.eventStore);
    case "PREV":
    case "NEXT":
    case "CHANGE_DATE":
    case "CHANGE_VIEW_TYPE":
      if (dateProfile) {
        return expandRecurring(eventStore, dateProfile.activeRange, context);
      }
      return eventStore;
    case "REMOVE_EVENTS":
      return excludeSubEventStore(eventStore, action.eventStore);
    case "REMOVE_EVENT_SOURCE":
      return excludeEventsBySourceId(eventStore, action.sourceId);
    case "REMOVE_ALL_EVENT_SOURCES":
      return filterEventStoreDefs(eventStore, (eventDef) => !eventDef.sourceId);
    case "REMOVE_ALL_EVENTS":
      return createEmptyEventStore();
    default:
      return eventStore;
  }
}
function receiveRawEvents(eventStore, eventSource, fetchId, fetchRange, rawEvents, context) {
  if (eventSource && // not already removed
  fetchId === eventSource.latestFetchId) {
    let subset = parseEvents(transformRawEvents(rawEvents, eventSource, context), eventSource, context);
    if (fetchRange) {
      subset = expandRecurring(subset, fetchRange, context);
    }
    return mergeEventStores(excludeEventsBySourceId(eventStore, eventSource.sourceId), subset);
  }
  return eventStore;
}
function resetRawEvents(existingEventStore, eventSource, rawEvents, activeRange, context) {
  const { defIdMap, instanceIdMap } = buildPublicIdMaps(existingEventStore);
  let newEventStore = parseEvents(transformRawEvents(rawEvents, eventSource, context), eventSource, context, false, defIdMap, instanceIdMap);
  return expandRecurring(newEventStore, activeRange, context);
}
function transformRawEvents(rawEvents, eventSource, context) {
  let calEachTransform = context.options.eventDataTransform;
  let sourceEachTransform = eventSource ? eventSource.eventDataTransform : null;
  if (sourceEachTransform) {
    rawEvents = transformEachRawEvent(rawEvents, sourceEachTransform);
  }
  if (calEachTransform) {
    rawEvents = transformEachRawEvent(rawEvents, calEachTransform);
  }
  return rawEvents;
}
function transformEachRawEvent(rawEvents, func) {
  let refinedEvents;
  if (!func) {
    refinedEvents = rawEvents;
  } else {
    refinedEvents = [];
    for (let rawEvent of rawEvents) {
      let refinedEvent = func(rawEvent);
      if (refinedEvent) {
        refinedEvents.push(refinedEvent);
      } else if (refinedEvent == null) {
        refinedEvents.push(rawEvent);
      }
    }
  }
  return refinedEvents;
}
function addEvent(eventStore, subset, expandRange, context) {
  if (expandRange) {
    subset = expandRecurring(subset, expandRange, context);
  }
  return mergeEventStores(eventStore, subset);
}
function rezoneEventStoreDates(eventStore, oldDateEnv, newDateEnv) {
  let { defs } = eventStore;
  let instances = mapHash(eventStore.instances, (instance) => {
    let def = defs[instance.defId];
    if (def.allDay) {
      return instance;
    }
    return Object.assign(Object.assign({}, instance), { range: {
      start: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.start, instance.forcedStartTzo)),
      end: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.end, instance.forcedEndTzo))
    }, forcedStartTzo: newDateEnv.canComputeOffset ? null : instance.forcedStartTzo, forcedEndTzo: newDateEnv.canComputeOffset ? null : instance.forcedEndTzo });
  });
  return { defs, instances };
}
function excludeEventsBySourceId(eventStore, sourceId) {
  return filterEventStoreDefs(eventStore, (eventDef) => eventDef.sourceId !== sourceId);
}
function excludeInstances(eventStore, removals) {
  return {
    defs: eventStore.defs,
    instances: filterHash(eventStore.instances, (instance) => !removals[instance.instanceId])
  };
}
function buildPublicIdMaps(eventStore) {
  const { defs, instances } = eventStore;
  const defIdMap = {};
  const instanceIdMap = {};
  for (let defId in defs) {
    const def = defs[defId];
    const { publicId } = def;
    if (publicId) {
      defIdMap[publicId] = defId;
    }
  }
  for (let instanceId in instances) {
    const instance = instances[instanceId];
    const def = defs[instance.defId];
    const { publicId } = def;
    if (publicId) {
      instanceIdMap[publicId] = instanceId;
    }
  }
  return { defIdMap, instanceIdMap };
}
var Emitter = class {
  constructor() {
    this.handlers = {};
    this.thisContext = null;
  }
  setThisContext(thisContext) {
    this.thisContext = thisContext;
  }
  setOptions(options) {
    this.options = options;
  }
  on(type, handler) {
    addToHash(this.handlers, type, handler);
  }
  off(type, handler) {
    removeFromHash(this.handlers, type, handler);
  }
  trigger(type, ...args) {
    let attachedHandlers = this.handlers[type] || [];
    let optionHandler = this.options && this.options[type];
    let handlers = [].concat(optionHandler || [], attachedHandlers);
    for (let handler of handlers) {
      handler.apply(this.thisContext, args);
    }
  }
  hasHandlers(type) {
    return Boolean(this.handlers[type] && this.handlers[type].length || this.options && this.options[type]);
  }
};
function addToHash(hash, type, handler) {
  (hash[type] || (hash[type] = [])).push(handler);
}
function removeFromHash(hash, type, handler) {
  if (handler) {
    if (hash[type]) {
      hash[type] = hash[type].filter((func) => func !== handler);
    }
  } else {
    delete hash[type];
  }
}
var DEF_DEFAULTS = {
  startTime: "09:00",
  endTime: "17:00",
  daysOfWeek: [1, 2, 3, 4, 5],
  display: "inverse-background",
  classNames: "fc-non-business",
  groupId: "_businessHours"
  // so multiple defs get grouped
};
function parseBusinessHours(input, context) {
  return parseEvents(refineInputs(input), null, context);
}
function refineInputs(input) {
  let rawDefs;
  if (input === true) {
    rawDefs = [{}];
  } else if (Array.isArray(input)) {
    rawDefs = input.filter((rawDef) => rawDef.daysOfWeek);
  } else if (typeof input === "object" && input) {
    rawDefs = [input];
  } else {
    rawDefs = [];
  }
  rawDefs = rawDefs.map((rawDef) => Object.assign(Object.assign({}, DEF_DEFAULTS), rawDef));
  return rawDefs;
}
function triggerDateSelect(selection, pev, context) {
  context.emitter.trigger("select", Object.assign(Object.assign({}, buildDateSpanApiWithContext(selection, context)), { jsEvent: pev ? pev.origEvent : null, view: context.viewApi || context.calendarApi.view }));
}
function triggerDateUnselect(pev, context) {
  context.emitter.trigger("unselect", {
    jsEvent: pev ? pev.origEvent : null,
    view: context.viewApi || context.calendarApi.view
  });
}
function buildDateSpanApiWithContext(dateSpan, context) {
  let props = {};
  for (let transform of context.pluginHooks.dateSpanTransforms) {
    Object.assign(props, transform(dateSpan, context));
  }
  Object.assign(props, buildDateSpanApi(dateSpan, context.dateEnv));
  return props;
}
function getDefaultEventEnd(allDay, marker, context) {
  let { dateEnv, options } = context;
  let end = marker;
  if (allDay) {
    end = startOfDay(end);
    end = dateEnv.add(end, options.defaultAllDayEventDuration);
  } else {
    end = dateEnv.add(end, options.defaultTimedEventDuration);
  }
  return end;
}
function applyMutationToEventStore(eventStore, eventConfigBase, mutation, context) {
  let eventConfigs = compileEventUis(eventStore.defs, eventConfigBase);
  let dest = createEmptyEventStore();
  for (let defId in eventStore.defs) {
    let def = eventStore.defs[defId];
    dest.defs[defId] = applyMutationToEventDef(def, eventConfigs[defId], mutation, context);
  }
  for (let instanceId in eventStore.instances) {
    let instance = eventStore.instances[instanceId];
    let def = dest.defs[instance.defId];
    dest.instances[instanceId] = applyMutationToEventInstance(instance, def, eventConfigs[instance.defId], mutation, context);
  }
  return dest;
}
function applyMutationToEventDef(eventDef, eventConfig, mutation, context) {
  let standardProps = mutation.standardProps || {};
  if (standardProps.hasEnd == null && eventConfig.durationEditable && (mutation.startDelta || mutation.endDelta)) {
    standardProps.hasEnd = true;
  }
  let copy = Object.assign(Object.assign(Object.assign({}, eventDef), standardProps), { ui: Object.assign(Object.assign({}, eventDef.ui), standardProps.ui) });
  if (mutation.extendedProps) {
    copy.extendedProps = Object.assign(Object.assign({}, copy.extendedProps), mutation.extendedProps);
  }
  for (let applier of context.pluginHooks.eventDefMutationAppliers) {
    applier(copy, mutation, context);
  }
  if (!copy.hasEnd && context.options.forceEventDuration) {
    copy.hasEnd = true;
  }
  return copy;
}
function applyMutationToEventInstance(eventInstance, eventDef, eventConfig, mutation, context) {
  let { dateEnv } = context;
  let forceAllDay = mutation.standardProps && mutation.standardProps.allDay === true;
  let clearEnd = mutation.standardProps && mutation.standardProps.hasEnd === false;
  let copy = Object.assign({}, eventInstance);
  if (forceAllDay) {
    copy.range = computeAlignedDayRange(copy.range);
  }
  if (mutation.datesDelta && eventConfig.startEditable) {
    copy.range = {
      start: dateEnv.add(copy.range.start, mutation.datesDelta),
      end: dateEnv.add(copy.range.end, mutation.datesDelta)
    };
  }
  if (mutation.startDelta && eventConfig.durationEditable) {
    copy.range = {
      start: dateEnv.add(copy.range.start, mutation.startDelta),
      end: copy.range.end
    };
  }
  if (mutation.endDelta && eventConfig.durationEditable) {
    copy.range = {
      start: copy.range.start,
      end: dateEnv.add(copy.range.end, mutation.endDelta)
    };
  }
  if (clearEnd) {
    copy.range = {
      start: copy.range.start,
      end: getDefaultEventEnd(eventDef.allDay, copy.range.start, context)
    };
  }
  if (eventDef.allDay) {
    copy.range = {
      start: startOfDay(copy.range.start),
      end: startOfDay(copy.range.end)
    };
  }
  if (copy.range.end < copy.range.start) {
    copy.range.end = getDefaultEventEnd(eventDef.allDay, copy.range.start, context);
  }
  return copy;
}
var EventSourceImpl = class {
  constructor(context, internalEventSource) {
    this.context = context;
    this.internalEventSource = internalEventSource;
  }
  remove() {
    this.context.dispatch({
      type: "REMOVE_EVENT_SOURCE",
      sourceId: this.internalEventSource.sourceId
    });
  }
  refetch() {
    this.context.dispatch({
      type: "FETCH_EVENT_SOURCES",
      sourceIds: [this.internalEventSource.sourceId],
      isRefetch: true
    });
  }
  get id() {
    return this.internalEventSource.publicId;
  }
  get url() {
    return this.internalEventSource.meta.url;
  }
  get format() {
    return this.internalEventSource.meta.format;
  }
};
var EventImpl = class {
  // instance will be null if expressing a recurring event that has no current instances,
  // OR if trying to validate an incoming external event that has no dates assigned
  constructor(context, def, instance) {
    this._context = context;
    this._def = def;
    this._instance = instance || null;
  }
  /*
  TODO: make event struct more responsible for this
  */
  setProp(name, val) {
    if (name in EVENT_DATE_REFINERS) {
      console.warn("Could not set date-related prop 'name'. Use one of the date-related methods instead.");
    } else if (name === "id") {
      val = EVENT_NON_DATE_REFINERS[name](val);
      this.mutate({
        standardProps: { publicId: val }
        // hardcoded internal name
      });
    } else if (name in EVENT_NON_DATE_REFINERS) {
      val = EVENT_NON_DATE_REFINERS[name](val);
      this.mutate({
        standardProps: { [name]: val }
      });
    } else if (name in EVENT_UI_REFINERS) {
      let ui = EVENT_UI_REFINERS[name](val);
      if (name === "color") {
        ui = { backgroundColor: val, borderColor: val };
      } else if (name === "editable") {
        ui = { startEditable: val, durationEditable: val };
      } else {
        ui = { [name]: val };
      }
      this.mutate({
        standardProps: { ui }
      });
    } else {
      console.warn(`Could not set prop '${name}'. Use setExtendedProp instead.`);
    }
  }
  setExtendedProp(name, val) {
    this.mutate({
      extendedProps: { [name]: val }
    });
  }
  setStart(startInput, options = {}) {
    let { dateEnv } = this._context;
    let start = dateEnv.createMarker(startInput);
    if (start && this._instance) {
      let instanceRange = this._instance.range;
      let startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity);
      if (options.maintainDuration) {
        this.mutate({ datesDelta: startDelta });
      } else {
        this.mutate({ startDelta });
      }
    }
  }
  setEnd(endInput, options = {}) {
    let { dateEnv } = this._context;
    let end;
    if (endInput != null) {
      end = dateEnv.createMarker(endInput);
      if (!end) {
        return;
      }
    }
    if (this._instance) {
      if (end) {
        let endDelta = diffDates(this._instance.range.end, end, dateEnv, options.granularity);
        this.mutate({ endDelta });
      } else {
        this.mutate({ standardProps: { hasEnd: false } });
      }
    }
  }
  setDates(startInput, endInput, options = {}) {
    let { dateEnv } = this._context;
    let standardProps = { allDay: options.allDay };
    let start = dateEnv.createMarker(startInput);
    let end;
    if (!start) {
      return;
    }
    if (endInput != null) {
      end = dateEnv.createMarker(endInput);
      if (!end) {
        return;
      }
    }
    if (this._instance) {
      let instanceRange = this._instance.range;
      if (options.allDay === true) {
        instanceRange = computeAlignedDayRange(instanceRange);
      }
      let startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity);
      if (end) {
        let endDelta = diffDates(instanceRange.end, end, dateEnv, options.granularity);
        if (durationsEqual(startDelta, endDelta)) {
          this.mutate({ datesDelta: startDelta, standardProps });
        } else {
          this.mutate({ startDelta, endDelta, standardProps });
        }
      } else {
        standardProps.hasEnd = false;
        this.mutate({ datesDelta: startDelta, standardProps });
      }
    }
  }
  moveStart(deltaInput) {
    let delta = createDuration(deltaInput);
    if (delta) {
      this.mutate({ startDelta: delta });
    }
  }
  moveEnd(deltaInput) {
    let delta = createDuration(deltaInput);
    if (delta) {
      this.mutate({ endDelta: delta });
    }
  }
  moveDates(deltaInput) {
    let delta = createDuration(deltaInput);
    if (delta) {
      this.mutate({ datesDelta: delta });
    }
  }
  setAllDay(allDay, options = {}) {
    let standardProps = { allDay };
    let { maintainDuration } = options;
    if (maintainDuration == null) {
      maintainDuration = this._context.options.allDayMaintainDuration;
    }
    if (this._def.allDay !== allDay) {
      standardProps.hasEnd = maintainDuration;
    }
    this.mutate({ standardProps });
  }
  formatRange(formatInput) {
    let { dateEnv } = this._context;
    let instance = this._instance;
    let formatter = createFormatter(formatInput);
    if (this._def.hasEnd) {
      return dateEnv.formatRange(instance.range.start, instance.range.end, formatter, {
        forcedStartTzo: instance.forcedStartTzo,
        forcedEndTzo: instance.forcedEndTzo
      });
    }
    return dateEnv.format(instance.range.start, formatter, {
      forcedTzo: instance.forcedStartTzo
    });
  }
  mutate(mutation) {
    let instance = this._instance;
    if (instance) {
      let def = this._def;
      let context = this._context;
      let { eventStore } = context.getCurrentData();
      let relevantEvents = getRelevantEvents(eventStore, instance.instanceId);
      let eventConfigBase = {
        "": {
          display: "",
          startEditable: true,
          durationEditable: true,
          constraints: [],
          overlap: null,
          allows: [],
          backgroundColor: "",
          borderColor: "",
          textColor: "",
          classNames: []
        }
      };
      relevantEvents = applyMutationToEventStore(relevantEvents, eventConfigBase, mutation, context);
      let oldEvent = new EventImpl(context, def, instance);
      this._def = relevantEvents.defs[def.defId];
      this._instance = relevantEvents.instances[instance.instanceId];
      context.dispatch({
        type: "MERGE_EVENTS",
        eventStore: relevantEvents
      });
      context.emitter.trigger("eventChange", {
        oldEvent,
        event: this,
        relatedEvents: buildEventApis(relevantEvents, context, instance),
        revert() {
          context.dispatch({
            type: "RESET_EVENTS",
            eventStore
            // the ORIGINAL store
          });
        }
      });
    }
  }
  remove() {
    let context = this._context;
    let asStore = eventApiToStore(this);
    context.dispatch({
      type: "REMOVE_EVENTS",
      eventStore: asStore
    });
    context.emitter.trigger("eventRemove", {
      event: this,
      relatedEvents: [],
      revert() {
        context.dispatch({
          type: "MERGE_EVENTS",
          eventStore: asStore
        });
      }
    });
  }
  get source() {
    let { sourceId } = this._def;
    if (sourceId) {
      return new EventSourceImpl(this._context, this._context.getCurrentData().eventSources[sourceId]);
    }
    return null;
  }
  get start() {
    return this._instance ? this._context.dateEnv.toDate(this._instance.range.start) : null;
  }
  get end() {
    return this._instance && this._def.hasEnd ? this._context.dateEnv.toDate(this._instance.range.end) : null;
  }
  get startStr() {
    let instance = this._instance;
    if (instance) {
      return this._context.dateEnv.formatIso(instance.range.start, {
        omitTime: this._def.allDay,
        forcedTzo: instance.forcedStartTzo
      });
    }
    return "";
  }
  get endStr() {
    let instance = this._instance;
    if (instance && this._def.hasEnd) {
      return this._context.dateEnv.formatIso(instance.range.end, {
        omitTime: this._def.allDay,
        forcedTzo: instance.forcedEndTzo
      });
    }
    return "";
  }
  // computable props that all access the def
  // TODO: find a TypeScript-compatible way to do this at scale
  get id() {
    return this._def.publicId;
  }
  get groupId() {
    return this._def.groupId;
  }
  get allDay() {
    return this._def.allDay;
  }
  get title() {
    return this._def.title;
  }
  get url() {
    return this._def.url;
  }
  get display() {
    return this._def.ui.display || "auto";
  }
  // bad. just normalize the type earlier
  get startEditable() {
    return this._def.ui.startEditable;
  }
  get durationEditable() {
    return this._def.ui.durationEditable;
  }
  get constraint() {
    return this._def.ui.constraints[0] || null;
  }
  get overlap() {
    return this._def.ui.overlap;
  }
  get allow() {
    return this._def.ui.allows[0] || null;
  }
  get backgroundColor() {
    return this._def.ui.backgroundColor;
  }
  get borderColor() {
    return this._def.ui.borderColor;
  }
  get textColor() {
    return this._def.ui.textColor;
  }
  // NOTE: user can't modify these because Object.freeze was called in event-def parsing
  get classNames() {
    return this._def.ui.classNames;
  }
  get extendedProps() {
    return this._def.extendedProps;
  }
  toPlainObject(settings = {}) {
    let def = this._def;
    let { ui } = def;
    let { startStr, endStr } = this;
    let res = {
      allDay: def.allDay
    };
    if (def.title) {
      res.title = def.title;
    }
    if (startStr) {
      res.start = startStr;
    }
    if (endStr) {
      res.end = endStr;
    }
    if (def.publicId) {
      res.id = def.publicId;
    }
    if (def.groupId) {
      res.groupId = def.groupId;
    }
    if (def.url) {
      res.url = def.url;
    }
    if (ui.display && ui.display !== "auto") {
      res.display = ui.display;
    }
    if (settings.collapseColor && ui.backgroundColor && ui.backgroundColor === ui.borderColor) {
      res.color = ui.backgroundColor;
    } else {
      if (ui.backgroundColor) {
        res.backgroundColor = ui.backgroundColor;
      }
      if (ui.borderColor) {
        res.borderColor = ui.borderColor;
      }
    }
    if (ui.textColor) {
      res.textColor = ui.textColor;
    }
    if (ui.classNames.length) {
      res.classNames = ui.classNames;
    }
    if (Object.keys(def.extendedProps).length) {
      if (settings.collapseExtendedProps) {
        Object.assign(res, def.extendedProps);
      } else {
        res.extendedProps = def.extendedProps;
      }
    }
    return res;
  }
  toJSON() {
    return this.toPlainObject();
  }
};
function eventApiToStore(eventApi) {
  let def = eventApi._def;
  let instance = eventApi._instance;
  return {
    defs: { [def.defId]: def },
    instances: instance ? { [instance.instanceId]: instance } : {}
  };
}
function buildEventApis(eventStore, context, excludeInstance) {
  let { defs, instances } = eventStore;
  let eventApis = [];
  let excludeInstanceId = excludeInstance ? excludeInstance.instanceId : "";
  for (let id in instances) {
    let instance = instances[id];
    let def = defs[instance.defId];
    if (instance.instanceId !== excludeInstanceId) {
      eventApis.push(new EventImpl(context, def, instance));
    }
  }
  return eventApis;
}
function sliceEventStore(eventStore, eventUiBases, framingRange, nextDayThreshold) {
  let inverseBgByGroupId = {};
  let inverseBgByDefId = {};
  let defByGroupId = {};
  let bgRanges = [];
  let fgRanges = [];
  let eventUis = compileEventUis(eventStore.defs, eventUiBases);
  for (let defId in eventStore.defs) {
    let def = eventStore.defs[defId];
    let ui = eventUis[def.defId];
    if (ui.display === "inverse-background") {
      if (def.groupId) {
        inverseBgByGroupId[def.groupId] = [];
        if (!defByGroupId[def.groupId]) {
          defByGroupId[def.groupId] = def;
        }
      } else {
        inverseBgByDefId[defId] = [];
      }
    }
  }
  for (let instanceId in eventStore.instances) {
    let instance = eventStore.instances[instanceId];
    let def = eventStore.defs[instance.defId];
    let ui = eventUis[def.defId];
    let origRange = instance.range;
    let normalRange = !def.allDay && nextDayThreshold ? computeVisibleDayRange(origRange, nextDayThreshold) : origRange;
    let slicedRange = intersectRanges(normalRange, framingRange);
    if (slicedRange) {
      if (ui.display === "inverse-background") {
        if (def.groupId) {
          inverseBgByGroupId[def.groupId].push(slicedRange);
        } else {
          inverseBgByDefId[instance.defId].push(slicedRange);
        }
      } else if (ui.display !== "none") {
        (ui.display === "background" ? bgRanges : fgRanges).push({
          def,
          ui,
          instance,
          range: slicedRange,
          isStart: normalRange.start && normalRange.start.valueOf() === slicedRange.start.valueOf(),
          isEnd: normalRange.end && normalRange.end.valueOf() === slicedRange.end.valueOf()
        });
      }
    }
  }
  for (let groupId in inverseBgByGroupId) {
    let ranges = inverseBgByGroupId[groupId];
    let invertedRanges = invertRanges(ranges, framingRange);
    for (let invertedRange of invertedRanges) {
      let def = defByGroupId[groupId];
      let ui = eventUis[def.defId];
      bgRanges.push({
        def,
        ui,
        instance: null,
        range: invertedRange,
        isStart: false,
        isEnd: false
      });
    }
  }
  for (let defId in inverseBgByDefId) {
    let ranges = inverseBgByDefId[defId];
    let invertedRanges = invertRanges(ranges, framingRange);
    for (let invertedRange of invertedRanges) {
      bgRanges.push({
        def: eventStore.defs[defId],
        ui: eventUis[defId],
        instance: null,
        range: invertedRange,
        isStart: false,
        isEnd: false
      });
    }
  }
  return { bg: bgRanges, fg: fgRanges };
}
function hasBgRendering(def) {
  return def.ui.display === "background" || def.ui.display === "inverse-background";
}
function setElSeg(el, seg) {
  el.fcSeg = seg;
}
function getElSeg(el) {
  return el.fcSeg || el.parentNode.fcSeg || // for the harness
  null;
}
function compileEventUis(eventDefs, eventUiBases) {
  return mapHash(eventDefs, (eventDef) => compileEventUi(eventDef, eventUiBases));
}
function compileEventUi(eventDef, eventUiBases) {
  let uis = [];
  if (eventUiBases[""]) {
    uis.push(eventUiBases[""]);
  }
  if (eventUiBases[eventDef.defId]) {
    uis.push(eventUiBases[eventDef.defId]);
  }
  uis.push(eventDef.ui);
  return combineEventUis(uis);
}
function sortEventSegs(segs, eventOrderSpecs) {
  let objs = segs.map(buildSegCompareObj);
  objs.sort((obj0, obj1) => compareByFieldSpecs(obj0, obj1, eventOrderSpecs));
  return objs.map((c3) => c3._seg);
}
function buildSegCompareObj(seg) {
  let { eventRange } = seg;
  let eventDef = eventRange.def;
  let range2 = eventRange.instance ? eventRange.instance.range : eventRange.range;
  let start = range2.start ? range2.start.valueOf() : 0;
  let end = range2.end ? range2.end.valueOf() : 0;
  return Object.assign(Object.assign(Object.assign({}, eventDef.extendedProps), eventDef), {
    id: eventDef.publicId,
    start,
    end,
    duration: end - start,
    allDay: Number(eventDef.allDay),
    _seg: seg
  });
}
function computeSegDraggable(seg, context) {
  let { pluginHooks } = context;
  let transformers = pluginHooks.isDraggableTransformers;
  let { def, ui } = seg.eventRange;
  let val = ui.startEditable;
  for (let transformer of transformers) {
    val = transformer(val, def, ui, context);
  }
  return val;
}
function computeSegStartResizable(seg, context) {
  return seg.isStart && seg.eventRange.ui.durationEditable && context.options.eventResizableFromStart;
}
function computeSegEndResizable(seg, context) {
  return seg.isEnd && seg.eventRange.ui.durationEditable;
}
function buildSegTimeText(seg, timeFormat, context, defaultDisplayEventTime, defaultDisplayEventEnd, startOverride, endOverride) {
  let { dateEnv, options } = context;
  let { displayEventTime, displayEventEnd } = options;
  let eventDef = seg.eventRange.def;
  let eventInstance = seg.eventRange.instance;
  if (displayEventTime == null) {
    displayEventTime = defaultDisplayEventTime !== false;
  }
  if (displayEventEnd == null) {
    displayEventEnd = defaultDisplayEventEnd !== false;
  }
  let wholeEventStart = eventInstance.range.start;
  let wholeEventEnd = eventInstance.range.end;
  let segStart = startOverride || seg.start || seg.eventRange.range.start;
  let segEnd = endOverride || seg.end || seg.eventRange.range.end;
  let isStartDay = startOfDay(wholeEventStart).valueOf() === startOfDay(segStart).valueOf();
  let isEndDay = startOfDay(addMs(wholeEventEnd, -1)).valueOf() === startOfDay(addMs(segEnd, -1)).valueOf();
  if (displayEventTime && !eventDef.allDay && (isStartDay || isEndDay)) {
    segStart = isStartDay ? wholeEventStart : segStart;
    segEnd = isEndDay ? wholeEventEnd : segEnd;
    if (displayEventEnd && eventDef.hasEnd) {
      return dateEnv.formatRange(segStart, segEnd, timeFormat, {
        forcedStartTzo: startOverride ? null : eventInstance.forcedStartTzo,
        forcedEndTzo: endOverride ? null : eventInstance.forcedEndTzo
      });
    }
    return dateEnv.format(segStart, timeFormat, {
      forcedTzo: startOverride ? null : eventInstance.forcedStartTzo
      // nooooo, same
    });
  }
  return "";
}
function getSegMeta(seg, todayRange, nowDate) {
  let segRange = seg.eventRange.range;
  return {
    isPast: segRange.end <= (nowDate || todayRange.start),
    isFuture: segRange.start >= (nowDate || todayRange.end),
    isToday: todayRange && rangeContainsMarker(todayRange, segRange.start)
  };
}
function getEventClassNames(props) {
  let classNames = ["fc-event"];
  if (props.isMirror) {
    classNames.push("fc-event-mirror");
  }
  if (props.isDraggable) {
    classNames.push("fc-event-draggable");
  }
  if (props.isStartResizable || props.isEndResizable) {
    classNames.push("fc-event-resizable");
  }
  if (props.isDragging) {
    classNames.push("fc-event-dragging");
  }
  if (props.isResizing) {
    classNames.push("fc-event-resizing");
  }
  if (props.isSelected) {
    classNames.push("fc-event-selected");
  }
  if (props.isStart) {
    classNames.push("fc-event-start");
  }
  if (props.isEnd) {
    classNames.push("fc-event-end");
  }
  if (props.isPast) {
    classNames.push("fc-event-past");
  }
  if (props.isToday) {
    classNames.push("fc-event-today");
  }
  if (props.isFuture) {
    classNames.push("fc-event-future");
  }
  return classNames;
}
function buildEventRangeKey(eventRange) {
  return eventRange.instance ? eventRange.instance.instanceId : `${eventRange.def.defId}:${eventRange.range.start.toISOString()}`;
}
function getSegAnchorAttrs(seg, context) {
  let { def, instance } = seg.eventRange;
  let { url } = def;
  if (url) {
    return { href: url };
  }
  let { emitter, options } = context;
  let { eventInteractive } = options;
  if (eventInteractive == null) {
    eventInteractive = def.interactive;
    if (eventInteractive == null) {
      eventInteractive = Boolean(emitter.hasHandlers("eventClick"));
    }
  }
  if (eventInteractive) {
    return createAriaKeyboardAttrs((ev) => {
      emitter.trigger("eventClick", {
        el: ev.target,
        event: new EventImpl(context, def, instance),
        jsEvent: ev,
        view: context.viewApi
      });
    });
  }
  return {};
}
var STANDARD_PROPS = {
  start: identity,
  end: identity,
  allDay: Boolean
};
function parseDateSpan(raw, dateEnv, defaultDuration) {
  let span = parseOpenDateSpan(raw, dateEnv);
  let { range: range2 } = span;
  if (!range2.start) {
    return null;
  }
  if (!range2.end) {
    if (defaultDuration == null) {
      return null;
    }
    range2.end = dateEnv.add(range2.start, defaultDuration);
  }
  return span;
}
function parseOpenDateSpan(raw, dateEnv) {
  let { refined: standardProps, extra } = refineProps(raw, STANDARD_PROPS);
  let startMeta = standardProps.start ? dateEnv.createMarkerMeta(standardProps.start) : null;
  let endMeta = standardProps.end ? dateEnv.createMarkerMeta(standardProps.end) : null;
  let { allDay } = standardProps;
  if (allDay == null) {
    allDay = startMeta && startMeta.isTimeUnspecified && (!endMeta || endMeta.isTimeUnspecified);
  }
  return Object.assign({ range: {
    start: startMeta ? startMeta.marker : null,
    end: endMeta ? endMeta.marker : null
  }, allDay }, extra);
}
function isDateSpansEqual(span0, span1) {
  return rangesEqual(span0.range, span1.range) && span0.allDay === span1.allDay && isSpanPropsEqual(span0, span1);
}
function isSpanPropsEqual(span0, span1) {
  for (let propName in span1) {
    if (propName !== "range" && propName !== "allDay") {
      if (span0[propName] !== span1[propName]) {
        return false;
      }
    }
  }
  for (let propName in span0) {
    if (!(propName in span1)) {
      return false;
    }
  }
  return true;
}
function buildDateSpanApi(span, dateEnv) {
  return Object.assign(Object.assign({}, buildRangeApi(span.range, dateEnv, span.allDay)), { allDay: span.allDay });
}
function buildRangeApiWithTimeZone(range2, dateEnv, omitTime) {
  return Object.assign(Object.assign({}, buildRangeApi(range2, dateEnv, omitTime)), { timeZone: dateEnv.timeZone });
}
function buildRangeApi(range2, dateEnv, omitTime) {
  return {
    start: dateEnv.toDate(range2.start),
    end: dateEnv.toDate(range2.end),
    startStr: dateEnv.formatIso(range2.start, { omitTime }),
    endStr: dateEnv.formatIso(range2.end, { omitTime })
  };
}
function fabricateEventRange(dateSpan, eventUiBases, context) {
  let res = refineEventDef({ editable: false }, context);
  let def = parseEventDef(
    res.refined,
    res.extra,
    "",
    // sourceId
    dateSpan.allDay,
    true,
    // hasEnd
    context
  );
  return {
    def,
    ui: compileEventUi(def, eventUiBases),
    instance: createEventInstance(def.defId, dateSpan.range),
    range: dateSpan.range,
    isStart: true,
    isEnd: true
  };
}
function unpromisify(func, normalizedSuccessCallback, normalizedFailureCallback) {
  let isResolved = false;
  let wrappedSuccess = function(res2) {
    if (!isResolved) {
      isResolved = true;
      normalizedSuccessCallback(res2);
    }
  };
  let wrappedFailure = function(error) {
    if (!isResolved) {
      isResolved = true;
      normalizedFailureCallback(error);
    }
  };
  let res = func(wrappedSuccess, wrappedFailure);
  if (res && typeof res.then === "function") {
    res.then(wrappedSuccess, wrappedFailure);
  }
}
var JsonRequestError = class extends Error {
  constructor(message, response) {
    super(message);
    this.response = response;
  }
};
function requestJson(method, url, params) {
  method = method.toUpperCase();
  const fetchOptions = {
    method
  };
  if (method === "GET") {
    url += (url.indexOf("?") === -1 ? "?" : "&") + new URLSearchParams(params);
  } else {
    fetchOptions.body = new URLSearchParams(params);
    fetchOptions.headers = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
  }
  return fetch(url, fetchOptions).then((fetchRes) => {
    if (fetchRes.ok) {
      return fetchRes.json().then((parsedResponse) => {
        return [parsedResponse, fetchRes];
      }, () => {
        throw new JsonRequestError("Failure parsing JSON", fetchRes);
      });
    } else {
      throw new JsonRequestError("Request failed", fetchRes);
    }
  });
}
var canVGrowWithinCell;
function getCanVGrowWithinCell() {
  if (canVGrowWithinCell == null) {
    canVGrowWithinCell = computeCanVGrowWithinCell();
  }
  return canVGrowWithinCell;
}
function computeCanVGrowWithinCell() {
  if (typeof document === "undefined") {
    return true;
  }
  let el = document.createElement("div");
  el.style.position = "absolute";
  el.style.top = "0px";
  el.style.left = "0px";
  el.innerHTML = "<table><tr><td><div></div></td></tr></table>";
  el.querySelector("table").style.height = "100px";
  el.querySelector("div").style.height = "100%";
  document.body.appendChild(el);
  let div = el.querySelector("div");
  let possible = div.offsetHeight > 0;
  document.body.removeChild(el);
  return possible;
}
var CalendarRoot = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.state = {
      forPrint: false
    };
    this.handleBeforePrint = () => {
      flushSync(() => {
        this.setState({ forPrint: true });
      });
    };
    this.handleAfterPrint = () => {
      flushSync(() => {
        this.setState({ forPrint: false });
      });
    };
  }
  render() {
    let { props } = this;
    let { options } = props;
    let { forPrint } = this.state;
    let isHeightAuto = forPrint || options.height === "auto" || options.contentHeight === "auto";
    let height = !isHeightAuto && options.height != null ? options.height : "";
    let classNames = [
      "fc",
      forPrint ? "fc-media-print" : "fc-media-screen",
      `fc-direction-${options.direction}`,
      props.theme.getClass("root")
    ];
    if (!getCanVGrowWithinCell()) {
      classNames.push("fc-liquid-hack");
    }
    return props.children(classNames, height, isHeightAuto, forPrint);
  }
  componentDidMount() {
    let { emitter } = this.props;
    emitter.on("_beforeprint", this.handleBeforePrint);
    emitter.on("_afterprint", this.handleAfterPrint);
  }
  componentWillUnmount() {
    let { emitter } = this.props;
    emitter.off("_beforeprint", this.handleBeforePrint);
    emitter.off("_afterprint", this.handleAfterPrint);
  }
};
var Interaction = class {
  constructor(settings) {
    this.component = settings.component;
    this.isHitComboAllowed = settings.isHitComboAllowed || null;
  }
  destroy() {
  }
};
function parseInteractionSettings(component, input) {
  return {
    component,
    el: input.el,
    useEventCenter: input.useEventCenter != null ? input.useEventCenter : true,
    isHitComboAllowed: input.isHitComboAllowed || null
  };
}
function interactionSettingsToStore(settings) {
  return {
    [settings.component.uid]: settings
  };
}
var interactionSettingsStore = {};
var CalendarImpl = class {
  getCurrentData() {
    return this.currentDataManager.getCurrentData();
  }
  dispatch(action) {
    this.currentDataManager.dispatch(action);
  }
  get view() {
    return this.getCurrentData().viewApi;
  }
  batchRendering(callback) {
    callback();
  }
  updateSize() {
    this.trigger("_resize", true);
  }
  // Options
  // -----------------------------------------------------------------------------------------------------------------
  setOption(name, val) {
    this.dispatch({
      type: "SET_OPTION",
      optionName: name,
      rawOptionValue: val
    });
  }
  getOption(name) {
    return this.currentDataManager.currentCalendarOptionsInput[name];
  }
  getAvailableLocaleCodes() {
    return Object.keys(this.getCurrentData().availableRawLocales);
  }
  // Trigger
  // -----------------------------------------------------------------------------------------------------------------
  on(handlerName, handler) {
    let { currentDataManager } = this;
    if (currentDataManager.currentCalendarOptionsRefiners[handlerName]) {
      currentDataManager.emitter.on(handlerName, handler);
    } else {
      console.warn(`Unknown listener name '${handlerName}'`);
    }
  }
  off(handlerName, handler) {
    this.currentDataManager.emitter.off(handlerName, handler);
  }
  // not meant for public use
  trigger(handlerName, ...args) {
    this.currentDataManager.emitter.trigger(handlerName, ...args);
  }
  // View
  // -----------------------------------------------------------------------------------------------------------------
  changeView(viewType, dateOrRange) {
    this.batchRendering(() => {
      this.unselect();
      if (dateOrRange) {
        if (dateOrRange.start && dateOrRange.end) {
          this.dispatch({
            type: "CHANGE_VIEW_TYPE",
            viewType
          });
          this.dispatch({
            type: "SET_OPTION",
            optionName: "visibleRange",
            rawOptionValue: dateOrRange
          });
        } else {
          let { dateEnv } = this.getCurrentData();
          this.dispatch({
            type: "CHANGE_VIEW_TYPE",
            viewType,
            dateMarker: dateEnv.createMarker(dateOrRange)
          });
        }
      } else {
        this.dispatch({
          type: "CHANGE_VIEW_TYPE",
          viewType
        });
      }
    });
  }
  // Forces navigation to a view for the given date.
  // `viewType` can be a specific view name or a generic one like "week" or "day".
  // needs to change
  zoomTo(dateMarker, viewType) {
    let state = this.getCurrentData();
    let spec;
    viewType = viewType || "day";
    spec = state.viewSpecs[viewType] || this.getUnitViewSpec(viewType);
    this.unselect();
    if (spec) {
      this.dispatch({
        type: "CHANGE_VIEW_TYPE",
        viewType: spec.type,
        dateMarker
      });
    } else {
      this.dispatch({
        type: "CHANGE_DATE",
        dateMarker
      });
    }
  }
  // Given a duration singular unit, like "week" or "day", finds a matching view spec.
  // Preference is given to views that have corresponding buttons.
  getUnitViewSpec(unit) {
    let { viewSpecs, toolbarConfig } = this.getCurrentData();
    let viewTypes = [].concat(toolbarConfig.header ? toolbarConfig.header.viewsWithButtons : [], toolbarConfig.footer ? toolbarConfig.footer.viewsWithButtons : []);
    let i3;
    let spec;
    for (let viewType in viewSpecs) {
      viewTypes.push(viewType);
    }
    for (i3 = 0; i3 < viewTypes.length; i3 += 1) {
      spec = viewSpecs[viewTypes[i3]];
      if (spec) {
        if (spec.singleUnit === unit) {
          return spec;
        }
      }
    }
    return null;
  }
  // Current Date
  // -----------------------------------------------------------------------------------------------------------------
  prev() {
    this.unselect();
    this.dispatch({ type: "PREV" });
  }
  next() {
    this.unselect();
    this.dispatch({ type: "NEXT" });
  }
  prevYear() {
    let state = this.getCurrentData();
    this.unselect();
    this.dispatch({
      type: "CHANGE_DATE",
      dateMarker: state.dateEnv.addYears(state.currentDate, -1)
    });
  }
  nextYear() {
    let state = this.getCurrentData();
    this.unselect();
    this.dispatch({
      type: "CHANGE_DATE",
      dateMarker: state.dateEnv.addYears(state.currentDate, 1)
    });
  }
  today() {
    let state = this.getCurrentData();
    this.unselect();
    this.dispatch({
      type: "CHANGE_DATE",
      dateMarker: getNow(state.calendarOptions.now, state.dateEnv)
    });
  }
  gotoDate(zonedDateInput) {
    let state = this.getCurrentData();
    this.unselect();
    this.dispatch({
      type: "CHANGE_DATE",
      dateMarker: state.dateEnv.createMarker(zonedDateInput)
    });
  }
  incrementDate(deltaInput) {
    let state = this.getCurrentData();
    let delta = createDuration(deltaInput);
    if (delta) {
      this.unselect();
      this.dispatch({
        type: "CHANGE_DATE",
        dateMarker: state.dateEnv.add(state.currentDate, delta)
      });
    }
  }
  getDate() {
    let state = this.getCurrentData();
    return state.dateEnv.toDate(state.currentDate);
  }
  // Date Formatting Utils
  // -----------------------------------------------------------------------------------------------------------------
  formatDate(d2, formatter) {
    let { dateEnv } = this.getCurrentData();
    return dateEnv.format(dateEnv.createMarker(d2), createFormatter(formatter));
  }
  // `settings` is for formatter AND isEndExclusive
  formatRange(d0, d1, settings) {
    let { dateEnv } = this.getCurrentData();
    return dateEnv.formatRange(dateEnv.createMarker(d0), dateEnv.createMarker(d1), createFormatter(settings), settings);
  }
  formatIso(d2, omitTime) {
    let { dateEnv } = this.getCurrentData();
    return dateEnv.formatIso(dateEnv.createMarker(d2), { omitTime });
  }
  // Date Selection / Event Selection / DayClick
  // -----------------------------------------------------------------------------------------------------------------
  select(dateOrObj, endDate) {
    let selectionInput;
    if (endDate == null) {
      if (dateOrObj.start != null) {
        selectionInput = dateOrObj;
      } else {
        selectionInput = {
          start: dateOrObj,
          end: null
        };
      }
    } else {
      selectionInput = {
        start: dateOrObj,
        end: endDate
      };
    }
    let state = this.getCurrentData();
    let selection = parseDateSpan(selectionInput, state.dateEnv, createDuration({ days: 1 }));
    if (selection) {
      this.dispatch({ type: "SELECT_DATES", selection });
      triggerDateSelect(selection, null, state);
    }
  }
  unselect(pev) {
    let state = this.getCurrentData();
    if (state.dateSelection) {
      this.dispatch({ type: "UNSELECT_DATES" });
      triggerDateUnselect(pev, state);
    }
  }
  // Public Events API
  // -----------------------------------------------------------------------------------------------------------------
  addEvent(eventInput, sourceInput) {
    if (eventInput instanceof EventImpl) {
      let def = eventInput._def;
      let instance = eventInput._instance;
      let currentData = this.getCurrentData();
      if (!currentData.eventStore.defs[def.defId]) {
        this.dispatch({
          type: "ADD_EVENTS",
          eventStore: eventTupleToStore({ def, instance })
          // TODO: better util for two args?
        });
        this.triggerEventAdd(eventInput);
      }
      return eventInput;
    }
    let state = this.getCurrentData();
    let eventSource;
    if (sourceInput instanceof EventSourceImpl) {
      eventSource = sourceInput.internalEventSource;
    } else if (typeof sourceInput === "boolean") {
      if (sourceInput) {
        [eventSource] = hashValuesToArray(state.eventSources);
      }
    } else if (sourceInput != null) {
      let sourceApi = this.getEventSourceById(sourceInput);
      if (!sourceApi) {
        console.warn(`Could not find an event source with ID "${sourceInput}"`);
        return null;
      }
      eventSource = sourceApi.internalEventSource;
    }
    let tuple = parseEvent(eventInput, eventSource, state, false);
    if (tuple) {
      let newEventApi = new EventImpl(state, tuple.def, tuple.def.recurringDef ? null : tuple.instance);
      this.dispatch({
        type: "ADD_EVENTS",
        eventStore: eventTupleToStore(tuple)
      });
      this.triggerEventAdd(newEventApi);
      return newEventApi;
    }
    return null;
  }
  triggerEventAdd(eventApi) {
    let { emitter } = this.getCurrentData();
    emitter.trigger("eventAdd", {
      event: eventApi,
      relatedEvents: [],
      revert: () => {
        this.dispatch({
          type: "REMOVE_EVENTS",
          eventStore: eventApiToStore(eventApi)
        });
      }
    });
  }
  // TODO: optimize
  getEventById(id) {
    let state = this.getCurrentData();
    let { defs, instances } = state.eventStore;
    id = String(id);
    for (let defId in defs) {
      let def = defs[defId];
      if (def.publicId === id) {
        if (def.recurringDef) {
          return new EventImpl(state, def, null);
        }
        for (let instanceId in instances) {
          let instance = instances[instanceId];
          if (instance.defId === def.defId) {
            return new EventImpl(state, def, instance);
          }
        }
      }
    }
    return null;
  }
  getEvents() {
    let currentData = this.getCurrentData();
    return buildEventApis(currentData.eventStore, currentData);
  }
  removeAllEvents() {
    this.dispatch({ type: "REMOVE_ALL_EVENTS" });
  }
  // Public Event Sources API
  // -----------------------------------------------------------------------------------------------------------------
  getEventSources() {
    let state = this.getCurrentData();
    let sourceHash = state.eventSources;
    let sourceApis = [];
    for (let internalId in sourceHash) {
      sourceApis.push(new EventSourceImpl(state, sourceHash[internalId]));
    }
    return sourceApis;
  }
  getEventSourceById(id) {
    let state = this.getCurrentData();
    let sourceHash = state.eventSources;
    id = String(id);
    for (let sourceId in sourceHash) {
      if (sourceHash[sourceId].publicId === id) {
        return new EventSourceImpl(state, sourceHash[sourceId]);
      }
    }
    return null;
  }
  addEventSource(sourceInput) {
    let state = this.getCurrentData();
    if (sourceInput instanceof EventSourceImpl) {
      if (!state.eventSources[sourceInput.internalEventSource.sourceId]) {
        this.dispatch({
          type: "ADD_EVENT_SOURCES",
          sources: [sourceInput.internalEventSource]
        });
      }
      return sourceInput;
    }
    let eventSource = parseEventSource(sourceInput, state);
    if (eventSource) {
      this.dispatch({ type: "ADD_EVENT_SOURCES", sources: [eventSource] });
      return new EventSourceImpl(state, eventSource);
    }
    return null;
  }
  removeAllEventSources() {
    this.dispatch({ type: "REMOVE_ALL_EVENT_SOURCES" });
  }
  refetchEvents() {
    this.dispatch({ type: "FETCH_EVENT_SOURCES", isRefetch: true });
  }
  // Scroll
  // -----------------------------------------------------------------------------------------------------------------
  scrollToTime(timeInput) {
    let time = createDuration(timeInput);
    if (time) {
      this.trigger("_scrollRequest", { time });
    }
  }
};
function pointInsideRect(point, rect) {
  return point.left >= rect.left && point.left < rect.right && point.top >= rect.top && point.top < rect.bottom;
}
function intersectRects(rect1, rect2) {
  let res = {
    left: Math.max(rect1.left, rect2.left),
    right: Math.min(rect1.right, rect2.right),
    top: Math.max(rect1.top, rect2.top),
    bottom: Math.min(rect1.bottom, rect2.bottom)
  };
  if (res.left < res.right && res.top < res.bottom) {
    return res;
  }
  return false;
}
function constrainPoint(point, rect) {
  return {
    left: Math.min(Math.max(point.left, rect.left), rect.right),
    top: Math.min(Math.max(point.top, rect.top), rect.bottom)
  };
}
function getRectCenter(rect) {
  return {
    left: (rect.left + rect.right) / 2,
    top: (rect.top + rect.bottom) / 2
  };
}
function diffPoints(point1, point2) {
  return {
    left: point1.left - point2.left,
    top: point1.top - point2.top
  };
}
var EMPTY_EVENT_STORE = createEmptyEventStore();
var Splitter = class {
  constructor() {
    this.getKeysForEventDefs = memoize(this._getKeysForEventDefs);
    this.splitDateSelection = memoize(this._splitDateSpan);
    this.splitEventStore = memoize(this._splitEventStore);
    this.splitIndividualUi = memoize(this._splitIndividualUi);
    this.splitEventDrag = memoize(this._splitInteraction);
    this.splitEventResize = memoize(this._splitInteraction);
    this.eventUiBuilders = {};
  }
  splitProps(props) {
    let keyInfos = this.getKeyInfo(props);
    let defKeys = this.getKeysForEventDefs(props.eventStore);
    let dateSelections = this.splitDateSelection(props.dateSelection);
    let individualUi = this.splitIndividualUi(props.eventUiBases, defKeys);
    let eventStores = this.splitEventStore(props.eventStore, defKeys);
    let eventDrags = this.splitEventDrag(props.eventDrag);
    let eventResizes = this.splitEventResize(props.eventResize);
    let splitProps = {};
    this.eventUiBuilders = mapHash(keyInfos, (info, key) => this.eventUiBuilders[key] || memoize(buildEventUiForKey));
    for (let key in keyInfos) {
      let keyInfo = keyInfos[key];
      let eventStore = eventStores[key] || EMPTY_EVENT_STORE;
      let buildEventUi = this.eventUiBuilders[key];
      splitProps[key] = {
        businessHours: keyInfo.businessHours || props.businessHours,
        dateSelection: dateSelections[key] || null,
        eventStore,
        eventUiBases: buildEventUi(props.eventUiBases[""], keyInfo.ui, individualUi[key]),
        eventSelection: eventStore.instances[props.eventSelection] ? props.eventSelection : "",
        eventDrag: eventDrags[key] || null,
        eventResize: eventResizes[key] || null
      };
    }
    return splitProps;
  }
  _splitDateSpan(dateSpan) {
    let dateSpans = {};
    if (dateSpan) {
      let keys = this.getKeysForDateSpan(dateSpan);
      for (let key of keys) {
        dateSpans[key] = dateSpan;
      }
    }
    return dateSpans;
  }
  _getKeysForEventDefs(eventStore) {
    return mapHash(eventStore.defs, (eventDef) => this.getKeysForEventDef(eventDef));
  }
  _splitEventStore(eventStore, defKeys) {
    let { defs, instances } = eventStore;
    let splitStores = {};
    for (let defId in defs) {
      for (let key of defKeys[defId]) {
        if (!splitStores[key]) {
          splitStores[key] = createEmptyEventStore();
        }
        splitStores[key].defs[defId] = defs[defId];
      }
    }
    for (let instanceId in instances) {
      let instance = instances[instanceId];
      for (let key of defKeys[instance.defId]) {
        if (splitStores[key]) {
          splitStores[key].instances[instanceId] = instance;
        }
      }
    }
    return splitStores;
  }
  _splitIndividualUi(eventUiBases, defKeys) {
    let splitHashes = {};
    for (let defId in eventUiBases) {
      if (defId) {
        for (let key of defKeys[defId]) {
          if (!splitHashes[key]) {
            splitHashes[key] = {};
          }
          splitHashes[key][defId] = eventUiBases[defId];
        }
      }
    }
    return splitHashes;
  }
  _splitInteraction(interaction) {
    let splitStates = {};
    if (interaction) {
      let affectedStores = this._splitEventStore(interaction.affectedEvents, this._getKeysForEventDefs(interaction.affectedEvents));
      let mutatedKeysByDefId = this._getKeysForEventDefs(interaction.mutatedEvents);
      let mutatedStores = this._splitEventStore(interaction.mutatedEvents, mutatedKeysByDefId);
      let populate = (key) => {
        if (!splitStates[key]) {
          splitStates[key] = {
            affectedEvents: affectedStores[key] || EMPTY_EVENT_STORE,
            mutatedEvents: mutatedStores[key] || EMPTY_EVENT_STORE,
            isEvent: interaction.isEvent
          };
        }
      };
      for (let key in affectedStores) {
        populate(key);
      }
      for (let key in mutatedStores) {
        populate(key);
      }
    }
    return splitStates;
  }
};
function buildEventUiForKey(allUi, eventUiForKey, individualUi) {
  let baseParts = [];
  if (allUi) {
    baseParts.push(allUi);
  }
  if (eventUiForKey) {
    baseParts.push(eventUiForKey);
  }
  let stuff = {
    "": combineEventUis(baseParts)
  };
  if (individualUi) {
    Object.assign(stuff, individualUi);
  }
  return stuff;
}
function getDateMeta(date, todayRange, nowDate, dateProfile) {
  return {
    dow: date.getUTCDay(),
    isDisabled: Boolean(dateProfile && !rangeContainsMarker(dateProfile.activeRange, date)),
    isOther: Boolean(dateProfile && !rangeContainsMarker(dateProfile.currentRange, date)),
    isToday: Boolean(todayRange && rangeContainsMarker(todayRange, date)),
    isPast: Boolean(nowDate ? date < nowDate : todayRange ? date < todayRange.start : false),
    isFuture: Boolean(nowDate ? date > nowDate : todayRange ? date >= todayRange.end : false)
  };
}
function getDayClassNames(meta, theme) {
  let classNames = [
    "fc-day",
    `fc-day-${DAY_IDS[meta.dow]}`
  ];
  if (meta.isDisabled) {
    classNames.push("fc-day-disabled");
  } else {
    if (meta.isToday) {
      classNames.push("fc-day-today");
      classNames.push(theme.getClass("today"));
    }
    if (meta.isPast) {
      classNames.push("fc-day-past");
    }
    if (meta.isFuture) {
      classNames.push("fc-day-future");
    }
    if (meta.isOther) {
      classNames.push("fc-day-other");
    }
  }
  return classNames;
}
var DAY_FORMAT = createFormatter({ year: "numeric", month: "long", day: "numeric" });
var WEEK_FORMAT = createFormatter({ week: "long" });
function buildNavLinkAttrs(context, dateMarker, viewType = "day", isTabbable = true) {
  const { dateEnv, options, calendarApi } = context;
  let dateStr = dateEnv.format(dateMarker, viewType === "week" ? WEEK_FORMAT : DAY_FORMAT);
  if (options.navLinks) {
    let zonedDate = dateEnv.toDate(dateMarker);
    const handleInteraction = (ev) => {
      let customAction = viewType === "day" ? options.navLinkDayClick : viewType === "week" ? options.navLinkWeekClick : null;
      if (typeof customAction === "function") {
        customAction.call(calendarApi, dateEnv.toDate(dateMarker), ev);
      } else {
        if (typeof customAction === "string") {
          viewType = customAction;
        }
        calendarApi.zoomTo(dateMarker, viewType);
      }
    };
    return Object.assign({ title: formatWithOrdinals(options.navLinkHint, [dateStr, zonedDate], dateStr), "data-navlink": "" }, isTabbable ? createAriaClickAttrs(handleInteraction) : { onClick: handleInteraction });
  }
  return { "aria-label": dateStr };
}
var _isRtlScrollbarOnLeft = null;
function getIsRtlScrollbarOnLeft() {
  if (_isRtlScrollbarOnLeft === null) {
    _isRtlScrollbarOnLeft = computeIsRtlScrollbarOnLeft();
  }
  return _isRtlScrollbarOnLeft;
}
function computeIsRtlScrollbarOnLeft() {
  let outerEl = document.createElement("div");
  applyStyle(outerEl, {
    position: "absolute",
    top: -1e3,
    left: 0,
    border: 0,
    padding: 0,
    overflow: "scroll",
    direction: "rtl"
  });
  outerEl.innerHTML = "<div></div>";
  document.body.appendChild(outerEl);
  let innerEl = outerEl.firstChild;
  let res = innerEl.getBoundingClientRect().left > outerEl.getBoundingClientRect().left;
  removeElement(outerEl);
  return res;
}
var _scrollbarWidths;
function getScrollbarWidths() {
  if (!_scrollbarWidths) {
    _scrollbarWidths = computeScrollbarWidths();
  }
  return _scrollbarWidths;
}
function computeScrollbarWidths() {
  let el = document.createElement("div");
  el.style.overflow = "scroll";
  el.style.position = "absolute";
  el.style.top = "-9999px";
  el.style.left = "-9999px";
  document.body.appendChild(el);
  let res = computeScrollbarWidthsForEl(el);
  document.body.removeChild(el);
  return res;
}
function computeScrollbarWidthsForEl(el) {
  return {
    x: el.offsetHeight - el.clientHeight,
    y: el.offsetWidth - el.clientWidth
  };
}
function computeEdges(el, getPadding = false) {
  let computedStyle = window.getComputedStyle(el);
  let borderLeft = parseInt(computedStyle.borderLeftWidth, 10) || 0;
  let borderRight = parseInt(computedStyle.borderRightWidth, 10) || 0;
  let borderTop = parseInt(computedStyle.borderTopWidth, 10) || 0;
  let borderBottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;
  let badScrollbarWidths = computeScrollbarWidthsForEl(el);
  let scrollbarLeftRight = badScrollbarWidths.y - borderLeft - borderRight;
  let scrollbarBottom = badScrollbarWidths.x - borderTop - borderBottom;
  let res = {
    borderLeft,
    borderRight,
    borderTop,
    borderBottom,
    scrollbarBottom,
    scrollbarLeft: 0,
    scrollbarRight: 0
  };
  if (getIsRtlScrollbarOnLeft() && computedStyle.direction === "rtl") {
    res.scrollbarLeft = scrollbarLeftRight;
  } else {
    res.scrollbarRight = scrollbarLeftRight;
  }
  if (getPadding) {
    res.paddingLeft = parseInt(computedStyle.paddingLeft, 10) || 0;
    res.paddingRight = parseInt(computedStyle.paddingRight, 10) || 0;
    res.paddingTop = parseInt(computedStyle.paddingTop, 10) || 0;
    res.paddingBottom = parseInt(computedStyle.paddingBottom, 10) || 0;
  }
  return res;
}
function computeInnerRect(el, goWithinPadding = false, doFromWindowViewport) {
  let outerRect = doFromWindowViewport ? el.getBoundingClientRect() : computeRect(el);
  let edges = computeEdges(el, goWithinPadding);
  let res = {
    left: outerRect.left + edges.borderLeft + edges.scrollbarLeft,
    right: outerRect.right - edges.borderRight - edges.scrollbarRight,
    top: outerRect.top + edges.borderTop,
    bottom: outerRect.bottom - edges.borderBottom - edges.scrollbarBottom
  };
  if (goWithinPadding) {
    res.left += edges.paddingLeft;
    res.right -= edges.paddingRight;
    res.top += edges.paddingTop;
    res.bottom -= edges.paddingBottom;
  }
  return res;
}
function computeRect(el) {
  let rect = el.getBoundingClientRect();
  return {
    left: rect.left + window.scrollX,
    top: rect.top + window.scrollY,
    right: rect.right + window.scrollX,
    bottom: rect.bottom + window.scrollY
  };
}
function computeClippedClientRect(el) {
  let clippingParents = getClippingParents(el);
  let rect = el.getBoundingClientRect();
  for (let clippingParent of clippingParents) {
    let intersection = intersectRects(rect, clippingParent.getBoundingClientRect());
    if (intersection) {
      rect = intersection;
    } else {
      return null;
    }
  }
  return rect;
}
function getClippingParents(el) {
  let parents = [];
  while (el instanceof HTMLElement) {
    let computedStyle = window.getComputedStyle(el);
    if (computedStyle.position === "fixed") {
      break;
    }
    if (/(auto|scroll)/.test(computedStyle.overflow + computedStyle.overflowY + computedStyle.overflowX)) {
      parents.push(el);
    }
    el = el.parentNode;
  }
  return parents;
}
var PositionCache = class {
  constructor(originEl, els, isHorizontal, isVertical) {
    this.els = els;
    let originClientRect = this.originClientRect = originEl.getBoundingClientRect();
    if (isHorizontal) {
      this.buildElHorizontals(originClientRect.left);
    }
    if (isVertical) {
      this.buildElVerticals(originClientRect.top);
    }
  }
  // Populates the left/right internal coordinate arrays
  buildElHorizontals(originClientLeft) {
    let lefts = [];
    let rights = [];
    for (let el of this.els) {
      let rect = el.getBoundingClientRect();
      lefts.push(rect.left - originClientLeft);
      rights.push(rect.right - originClientLeft);
    }
    this.lefts = lefts;
    this.rights = rights;
  }
  // Populates the top/bottom internal coordinate arrays
  buildElVerticals(originClientTop) {
    let tops = [];
    let bottoms = [];
    for (let el of this.els) {
      let rect = el.getBoundingClientRect();
      tops.push(rect.top - originClientTop);
      bottoms.push(rect.bottom - originClientTop);
    }
    this.tops = tops;
    this.bottoms = bottoms;
  }
  // Given a left offset (from document left), returns the index of the el that it horizontally intersects.
  // If no intersection is made, returns undefined.
  leftToIndex(leftPosition) {
    let { lefts, rights } = this;
    let len = lefts.length;
    let i3;
    for (i3 = 0; i3 < len; i3 += 1) {
      if (leftPosition >= lefts[i3] && leftPosition < rights[i3]) {
        return i3;
      }
    }
    return void 0;
  }
  // Given a top offset (from document top), returns the index of the el that it vertically intersects.
  // If no intersection is made, returns undefined.
  topToIndex(topPosition) {
    let { tops, bottoms } = this;
    let len = tops.length;
    let i3;
    for (i3 = 0; i3 < len; i3 += 1) {
      if (topPosition >= tops[i3] && topPosition < bottoms[i3]) {
        return i3;
      }
    }
    return void 0;
  }
  // Gets the width of the element at the given index
  getWidth(leftIndex) {
    return this.rights[leftIndex] - this.lefts[leftIndex];
  }
  // Gets the height of the element at the given index
  getHeight(topIndex) {
    return this.bottoms[topIndex] - this.tops[topIndex];
  }
  similarTo(otherCache) {
    return similarNumArrays(this.tops || [], otherCache.tops || []) && similarNumArrays(this.bottoms || [], otherCache.bottoms || []) && similarNumArrays(this.lefts || [], otherCache.lefts || []) && similarNumArrays(this.rights || [], otherCache.rights || []);
  }
};
function similarNumArrays(a3, b3) {
  const len = a3.length;
  if (len !== b3.length) {
    return false;
  }
  for (let i3 = 0; i3 < len; i3++) {
    if (Math.round(a3[i3]) !== Math.round(b3[i3])) {
      return false;
    }
  }
  return true;
}
var ScrollController = class {
  getMaxScrollTop() {
    return this.getScrollHeight() - this.getClientHeight();
  }
  getMaxScrollLeft() {
    return this.getScrollWidth() - this.getClientWidth();
  }
  canScrollVertically() {
    return this.getMaxScrollTop() > 0;
  }
  canScrollHorizontally() {
    return this.getMaxScrollLeft() > 0;
  }
  canScrollUp() {
    return this.getScrollTop() > 0;
  }
  canScrollDown() {
    return this.getScrollTop() < this.getMaxScrollTop();
  }
  canScrollLeft() {
    return this.getScrollLeft() > 0;
  }
  canScrollRight() {
    return this.getScrollLeft() < this.getMaxScrollLeft();
  }
};
var ElementScrollController = class extends ScrollController {
  constructor(el) {
    super();
    this.el = el;
  }
  getScrollTop() {
    return this.el.scrollTop;
  }
  getScrollLeft() {
    return this.el.scrollLeft;
  }
  setScrollTop(top) {
    this.el.scrollTop = top;
  }
  setScrollLeft(left) {
    this.el.scrollLeft = left;
  }
  getScrollWidth() {
    return this.el.scrollWidth;
  }
  getScrollHeight() {
    return this.el.scrollHeight;
  }
  getClientHeight() {
    return this.el.clientHeight;
  }
  getClientWidth() {
    return this.el.clientWidth;
  }
};
var WindowScrollController = class extends ScrollController {
  getScrollTop() {
    return window.scrollY;
  }
  getScrollLeft() {
    return window.scrollX;
  }
  setScrollTop(n2) {
    window.scroll(window.scrollX, n2);
  }
  setScrollLeft(n2) {
    window.scroll(n2, window.scrollY);
  }
  getScrollWidth() {
    return document.documentElement.scrollWidth;
  }
  getScrollHeight() {
    return document.documentElement.scrollHeight;
  }
  getClientHeight() {
    return document.documentElement.clientHeight;
  }
  getClientWidth() {
    return document.documentElement.clientWidth;
  }
};
var DateComponent = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.uid = guid();
  }
  // Hit System
  // -----------------------------------------------------------------------------------------------------------------
  prepareHits() {
  }
  queryHit(positionLeft, positionTop, elWidth, elHeight) {
    return null;
  }
  // Pointer Interaction Utils
  // -----------------------------------------------------------------------------------------------------------------
  isValidSegDownEl(el) {
    return !this.props.eventDrag && // HACK
    !this.props.eventResize && // HACK
    !elementClosest(el, ".fc-event-mirror");
  }
  isValidDateDownEl(el) {
    return !elementClosest(el, ".fc-event:not(.fc-bg-event)") && !elementClosest(el, ".fc-more-link") && // a "more.." link
    !elementClosest(el, "a[data-navlink]") && // a clickable nav link
    !elementClosest(el, ".fc-popover");
  }
};
var SegHierarchy = class {
  constructor(getEntryThickness = (entry) => {
    return entry.thickness || 1;
  }) {
    this.getEntryThickness = getEntryThickness;
    this.strictOrder = false;
    this.allowReslicing = false;
    this.maxCoord = -1;
    this.maxStackCnt = -1;
    this.levelCoords = [];
    this.entriesByLevel = [];
    this.stackCnts = {};
  }
  addSegs(inputs) {
    let hiddenEntries = [];
    for (let input of inputs) {
      this.insertEntry(input, hiddenEntries);
    }
    return hiddenEntries;
  }
  insertEntry(entry, hiddenEntries) {
    let insertion = this.findInsertion(entry);
    if (this.isInsertionValid(insertion, entry)) {
      this.insertEntryAt(entry, insertion);
    } else {
      this.handleInvalidInsertion(insertion, entry, hiddenEntries);
    }
  }
  isInsertionValid(insertion, entry) {
    return (this.maxCoord === -1 || insertion.levelCoord + this.getEntryThickness(entry) <= this.maxCoord) && (this.maxStackCnt === -1 || insertion.stackCnt < this.maxStackCnt);
  }
  handleInvalidInsertion(insertion, entry, hiddenEntries) {
    if (this.allowReslicing && insertion.touchingEntry) {
      const hiddenEntry = Object.assign(Object.assign({}, entry), { span: intersectSpans(entry.span, insertion.touchingEntry.span) });
      hiddenEntries.push(hiddenEntry);
      this.splitEntry(entry, insertion.touchingEntry, hiddenEntries);
    } else {
      hiddenEntries.push(entry);
    }
  }
  /*
  Does NOT add what hit the `barrier` into hiddenEntries. Should already be done.
  */
  splitEntry(entry, barrier, hiddenEntries) {
    let entrySpan = entry.span;
    let barrierSpan = barrier.span;
    if (entrySpan.start < barrierSpan.start) {
      this.insertEntry({
        index: entry.index,
        thickness: entry.thickness,
        span: { start: entrySpan.start, end: barrierSpan.start }
      }, hiddenEntries);
    }
    if (entrySpan.end > barrierSpan.end) {
      this.insertEntry({
        index: entry.index,
        thickness: entry.thickness,
        span: { start: barrierSpan.end, end: entrySpan.end }
      }, hiddenEntries);
    }
  }
  insertEntryAt(entry, insertion) {
    let { entriesByLevel, levelCoords } = this;
    if (insertion.lateral === -1) {
      insertAt(levelCoords, insertion.level, insertion.levelCoord);
      insertAt(entriesByLevel, insertion.level, [entry]);
    } else {
      insertAt(entriesByLevel[insertion.level], insertion.lateral, entry);
    }
    this.stackCnts[buildEntryKey(entry)] = insertion.stackCnt;
  }
  /*
  does not care about limits
  */
  findInsertion(newEntry) {
    let { levelCoords, entriesByLevel, strictOrder, stackCnts } = this;
    let levelCnt = levelCoords.length;
    let candidateCoord = 0;
    let touchingLevel = -1;
    let touchingLateral = -1;
    let touchingEntry = null;
    let stackCnt = 0;
    for (let trackingLevel = 0; trackingLevel < levelCnt; trackingLevel += 1) {
      const trackingCoord = levelCoords[trackingLevel];
      if (!strictOrder && trackingCoord >= candidateCoord + this.getEntryThickness(newEntry)) {
        break;
      }
      let trackingEntries = entriesByLevel[trackingLevel];
      let trackingEntry;
      let searchRes = binarySearch(trackingEntries, newEntry.span.start, getEntrySpanEnd);
      let lateralIndex = searchRes[0] + searchRes[1];
      while (
        // loop through entries that horizontally intersect
        (trackingEntry = trackingEntries[lateralIndex]) && // but not past the whole entry list
        trackingEntry.span.start < newEntry.span.end
      ) {
        let trackingEntryBottom = trackingCoord + this.getEntryThickness(trackingEntry);
        if (trackingEntryBottom > candidateCoord) {
          candidateCoord = trackingEntryBottom;
          touchingEntry = trackingEntry;
          touchingLevel = trackingLevel;
          touchingLateral = lateralIndex;
        }
        if (trackingEntryBottom === candidateCoord) {
          stackCnt = Math.max(stackCnt, stackCnts[buildEntryKey(trackingEntry)] + 1);
        }
        lateralIndex += 1;
      }
    }
    let destLevel = 0;
    if (touchingEntry) {
      destLevel = touchingLevel + 1;
      while (destLevel < levelCnt && levelCoords[destLevel] < candidateCoord) {
        destLevel += 1;
      }
    }
    let destLateral = -1;
    if (destLevel < levelCnt && levelCoords[destLevel] === candidateCoord) {
      destLateral = binarySearch(entriesByLevel[destLevel], newEntry.span.end, getEntrySpanEnd)[0];
    }
    return {
      touchingLevel,
      touchingLateral,
      touchingEntry,
      stackCnt,
      levelCoord: candidateCoord,
      level: destLevel,
      lateral: destLateral
    };
  }
  // sorted by levelCoord (lowest to highest)
  toRects() {
    let { entriesByLevel, levelCoords } = this;
    let levelCnt = entriesByLevel.length;
    let rects = [];
    for (let level = 0; level < levelCnt; level += 1) {
      let entries = entriesByLevel[level];
      let levelCoord = levelCoords[level];
      for (let entry of entries) {
        rects.push(Object.assign(Object.assign({}, entry), { thickness: this.getEntryThickness(entry), levelCoord }));
      }
    }
    return rects;
  }
};
function getEntrySpanEnd(entry) {
  return entry.span.end;
}
function buildEntryKey(entry) {
  return entry.index + ":" + entry.span.start;
}
function groupIntersectingEntries(entries) {
  let merges = [];
  for (let entry of entries) {
    let filteredMerges = [];
    let hungryMerge = {
      span: entry.span,
      entries: [entry]
    };
    for (let merge of merges) {
      if (intersectSpans(merge.span, hungryMerge.span)) {
        hungryMerge = {
          entries: merge.entries.concat(hungryMerge.entries),
          span: joinSpans(merge.span, hungryMerge.span)
        };
      } else {
        filteredMerges.push(merge);
      }
    }
    filteredMerges.push(hungryMerge);
    merges = filteredMerges;
  }
  return merges;
}
function joinSpans(span0, span1) {
  return {
    start: Math.min(span0.start, span1.start),
    end: Math.max(span0.end, span1.end)
  };
}
function intersectSpans(span0, span1) {
  let start = Math.max(span0.start, span1.start);
  let end = Math.min(span0.end, span1.end);
  if (start < end) {
    return { start, end };
  }
  return null;
}
function insertAt(arr, index8, item) {
  arr.splice(index8, 0, item);
}
function binarySearch(a3, searchVal, getItemVal) {
  let startIndex = 0;
  let endIndex = a3.length;
  if (!endIndex || searchVal < getItemVal(a3[startIndex])) {
    return [0, 0];
  }
  if (searchVal > getItemVal(a3[endIndex - 1])) {
    return [endIndex, 0];
  }
  while (startIndex < endIndex) {
    let middleIndex = Math.floor(startIndex + (endIndex - startIndex) / 2);
    let middleVal = getItemVal(a3[middleIndex]);
    if (searchVal < middleVal) {
      endIndex = middleIndex;
    } else if (searchVal > middleVal) {
      startIndex = middleIndex + 1;
    } else {
      return [middleIndex, 1];
    }
  }
  return [startIndex, 0];
}
var ElementDragging = class {
  constructor(el, selector) {
    this.emitter = new Emitter();
  }
  destroy() {
  }
  setMirrorIsVisible(bool) {
  }
  setMirrorNeedsRevert(bool) {
  }
  setAutoScrollEnabled(bool) {
  }
};
var config = {};
function computeFallbackHeaderFormat(datesRepDistinctDays, dayCnt) {
  if (!datesRepDistinctDays || dayCnt > 10) {
    return createFormatter({ weekday: "short" });
  }
  if (dayCnt > 1) {
    return createFormatter({ weekday: "short", month: "numeric", day: "numeric", omitCommas: true });
  }
  return createFormatter({ weekday: "long" });
}
var CLASS_NAME = "fc-col-header-cell";
function renderInner$1(renderProps) {
  return renderProps.text;
}
var TableDateCell = class extends BaseComponent {
  render() {
    let { dateEnv, options, theme, viewApi } = this.context;
    let { props } = this;
    let { date, dateProfile } = props;
    let dayMeta = getDateMeta(date, props.todayRange, null, dateProfile);
    let classNames = [CLASS_NAME].concat(getDayClassNames(dayMeta, theme));
    let text = dateEnv.format(date, props.dayHeaderFormat);
    let navLinkAttrs = !dayMeta.isDisabled && props.colCnt > 1 ? buildNavLinkAttrs(this.context, date) : {};
    let renderProps = Object.assign(Object.assign(Object.assign({ date: dateEnv.toDate(date), view: viewApi }, props.extraRenderProps), { text }), dayMeta);
    return y(ContentContainer, { elTag: "th", elClasses: classNames, elAttrs: Object.assign({ role: "columnheader", colSpan: props.colSpan, "data-date": !dayMeta.isDisabled ? formatDayString(date) : void 0 }, props.extraDataAttrs), renderProps, generatorName: "dayHeaderContent", customGenerator: options.dayHeaderContent, defaultGenerator: renderInner$1, classNameGenerator: options.dayHeaderClassNames, didMount: options.dayHeaderDidMount, willUnmount: options.dayHeaderWillUnmount }, (InnerContainer) => y("div", { className: "fc-scrollgrid-sync-inner" }, !dayMeta.isDisabled && y(InnerContainer, { elTag: "a", elAttrs: navLinkAttrs, elClasses: [
      "fc-col-header-cell-cushion",
      props.isSticky && "fc-sticky"
    ] })));
  }
};
var WEEKDAY_FORMAT = createFormatter({ weekday: "long" });
var TableDowCell = class extends BaseComponent {
  render() {
    let { props } = this;
    let { dateEnv, theme, viewApi, options } = this.context;
    let date = addDays(new Date(2592e5), props.dow);
    let dateMeta = {
      dow: props.dow,
      isDisabled: false,
      isFuture: false,
      isPast: false,
      isToday: false,
      isOther: false
    };
    let text = dateEnv.format(date, props.dayHeaderFormat);
    let renderProps = Object.assign(Object.assign(Object.assign(Object.assign({
      // TODO: make this public?
      date
    }, dateMeta), { view: viewApi }), props.extraRenderProps), { text });
    return y(ContentContainer, { elTag: "th", elClasses: [
      CLASS_NAME,
      ...getDayClassNames(dateMeta, theme),
      ...props.extraClassNames || []
    ], elAttrs: Object.assign({ role: "columnheader", colSpan: props.colSpan }, props.extraDataAttrs), renderProps, generatorName: "dayHeaderContent", customGenerator: options.dayHeaderContent, defaultGenerator: renderInner$1, classNameGenerator: options.dayHeaderClassNames, didMount: options.dayHeaderDidMount, willUnmount: options.dayHeaderWillUnmount }, (InnerContent) => y(
      "div",
      { className: "fc-scrollgrid-sync-inner" },
      y(InnerContent, { elTag: "a", elClasses: [
        "fc-col-header-cell-cushion",
        props.isSticky && "fc-sticky"
      ], elAttrs: {
        "aria-label": dateEnv.format(date, WEEKDAY_FORMAT)
      } })
    ));
  }
};
var NowTimer = class extends x {
  constructor(props, context) {
    super(props, context);
    this.initialNowDate = getNow(context.options.now, context.dateEnv);
    this.initialNowQueriedMs = new Date().valueOf();
    this.state = this.computeTiming().currentState;
  }
  render() {
    let { props, state } = this;
    return props.children(state.nowDate, state.todayRange);
  }
  componentDidMount() {
    this.setTimeout();
  }
  componentDidUpdate(prevProps) {
    if (prevProps.unit !== this.props.unit) {
      this.clearTimeout();
      this.setTimeout();
    }
  }
  componentWillUnmount() {
    this.clearTimeout();
  }
  computeTiming() {
    let { props, context } = this;
    let unroundedNow = addMs(this.initialNowDate, new Date().valueOf() - this.initialNowQueriedMs);
    let currentUnitStart = context.dateEnv.startOf(unroundedNow, props.unit);
    let nextUnitStart = context.dateEnv.add(currentUnitStart, createDuration(1, props.unit));
    let waitMs = nextUnitStart.valueOf() - unroundedNow.valueOf();
    waitMs = Math.min(1e3 * 60 * 60 * 24, waitMs);
    return {
      currentState: { nowDate: currentUnitStart, todayRange: buildDayRange(currentUnitStart) },
      nextState: { nowDate: nextUnitStart, todayRange: buildDayRange(nextUnitStart) },
      waitMs
    };
  }
  setTimeout() {
    let { nextState, waitMs } = this.computeTiming();
    this.timeoutId = setTimeout(() => {
      this.setState(nextState, () => {
        this.setTimeout();
      });
    }, waitMs);
  }
  clearTimeout() {
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
    }
  }
};
NowTimer.contextType = ViewContextType;
function buildDayRange(date) {
  let start = startOfDay(date);
  let end = addDays(start, 1);
  return { start, end };
}
var DayHeader = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.createDayHeaderFormatter = memoize(createDayHeaderFormatter);
  }
  render() {
    let { context } = this;
    let { dates, dateProfile, datesRepDistinctDays, renderIntro } = this.props;
    let dayHeaderFormat = this.createDayHeaderFormatter(context.options.dayHeaderFormat, datesRepDistinctDays, dates.length);
    return y(NowTimer, { unit: "day" }, (nowDate, todayRange) => y(
      "tr",
      { role: "row" },
      renderIntro && renderIntro("day"),
      dates.map((date) => datesRepDistinctDays ? y(TableDateCell, { key: date.toISOString(), date, dateProfile, todayRange, colCnt: dates.length, dayHeaderFormat }) : y(TableDowCell, { key: date.getUTCDay(), dow: date.getUTCDay(), dayHeaderFormat }))
    ));
  }
};
function createDayHeaderFormatter(explicitFormat, datesRepDistinctDays, dateCnt) {
  return explicitFormat || computeFallbackHeaderFormat(datesRepDistinctDays, dateCnt);
}
var DaySeriesModel = class {
  constructor(range2, dateProfileGenerator) {
    let date = range2.start;
    let { end } = range2;
    let indices = [];
    let dates = [];
    let dayIndex = -1;
    while (date < end) {
      if (dateProfileGenerator.isHiddenDay(date)) {
        indices.push(dayIndex + 0.5);
      } else {
        dayIndex += 1;
        indices.push(dayIndex);
        dates.push(date);
      }
      date = addDays(date, 1);
    }
    this.dates = dates;
    this.indices = indices;
    this.cnt = dates.length;
  }
  sliceRange(range2) {
    let firstIndex = this.getDateDayIndex(range2.start);
    let lastIndex = this.getDateDayIndex(addDays(range2.end, -1));
    let clippedFirstIndex = Math.max(0, firstIndex);
    let clippedLastIndex = Math.min(this.cnt - 1, lastIndex);
    clippedFirstIndex = Math.ceil(clippedFirstIndex);
    clippedLastIndex = Math.floor(clippedLastIndex);
    if (clippedFirstIndex <= clippedLastIndex) {
      return {
        firstIndex: clippedFirstIndex,
        lastIndex: clippedLastIndex,
        isStart: firstIndex === clippedFirstIndex,
        isEnd: lastIndex === clippedLastIndex
      };
    }
    return null;
  }
  // Given a date, returns its chronolocial cell-index from the first cell of the grid.
  // If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.
  // If before the first offset, returns a negative number.
  // If after the last offset, returns an offset past the last cell offset.
  // Only works for *start* dates of cells. Will not work for exclusive end dates for cells.
  getDateDayIndex(date) {
    let { indices } = this;
    let dayOffset = Math.floor(diffDays(this.dates[0], date));
    if (dayOffset < 0) {
      return indices[0] - 1;
    }
    if (dayOffset >= indices.length) {
      return indices[indices.length - 1] + 1;
    }
    return indices[dayOffset];
  }
};
var DayTableModel = class {
  constructor(daySeries, breakOnWeeks) {
    let { dates } = daySeries;
    let daysPerRow;
    let firstDay;
    let rowCnt;
    if (breakOnWeeks) {
      firstDay = dates[0].getUTCDay();
      for (daysPerRow = 1; daysPerRow < dates.length; daysPerRow += 1) {
        if (dates[daysPerRow].getUTCDay() === firstDay) {
          break;
        }
      }
      rowCnt = Math.ceil(dates.length / daysPerRow);
    } else {
      rowCnt = 1;
      daysPerRow = dates.length;
    }
    this.rowCnt = rowCnt;
    this.colCnt = daysPerRow;
    this.daySeries = daySeries;
    this.cells = this.buildCells();
    this.headerDates = this.buildHeaderDates();
  }
  buildCells() {
    let rows = [];
    for (let row = 0; row < this.rowCnt; row += 1) {
      let cells = [];
      for (let col = 0; col < this.colCnt; col += 1) {
        cells.push(this.buildCell(row, col));
      }
      rows.push(cells);
    }
    return rows;
  }
  buildCell(row, col) {
    let date = this.daySeries.dates[row * this.colCnt + col];
    return {
      key: date.toISOString(),
      date
    };
  }
  buildHeaderDates() {
    let dates = [];
    for (let col = 0; col < this.colCnt; col += 1) {
      dates.push(this.cells[0][col].date);
    }
    return dates;
  }
  sliceRange(range2) {
    let { colCnt } = this;
    let seriesSeg = this.daySeries.sliceRange(range2);
    let segs = [];
    if (seriesSeg) {
      let { firstIndex, lastIndex } = seriesSeg;
      let index8 = firstIndex;
      while (index8 <= lastIndex) {
        let row = Math.floor(index8 / colCnt);
        let nextIndex = Math.min((row + 1) * colCnt, lastIndex + 1);
        segs.push({
          row,
          firstCol: index8 % colCnt,
          lastCol: (nextIndex - 1) % colCnt,
          isStart: seriesSeg.isStart && index8 === firstIndex,
          isEnd: seriesSeg.isEnd && nextIndex - 1 === lastIndex
        });
        index8 = nextIndex;
      }
    }
    return segs;
  }
};
var Slicer = class {
  constructor() {
    this.sliceBusinessHours = memoize(this._sliceBusinessHours);
    this.sliceDateSelection = memoize(this._sliceDateSpan);
    this.sliceEventStore = memoize(this._sliceEventStore);
    this.sliceEventDrag = memoize(this._sliceInteraction);
    this.sliceEventResize = memoize(this._sliceInteraction);
    this.forceDayIfListItem = false;
  }
  sliceProps(props, dateProfile, nextDayThreshold, context, ...extraArgs) {
    let { eventUiBases } = props;
    let eventSegs = this.sliceEventStore(props.eventStore, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs);
    return {
      dateSelectionSegs: this.sliceDateSelection(props.dateSelection, dateProfile, nextDayThreshold, eventUiBases, context, ...extraArgs),
      businessHourSegs: this.sliceBusinessHours(props.businessHours, dateProfile, nextDayThreshold, context, ...extraArgs),
      fgEventSegs: eventSegs.fg,
      bgEventSegs: eventSegs.bg,
      eventDrag: this.sliceEventDrag(props.eventDrag, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs),
      eventResize: this.sliceEventResize(props.eventResize, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs),
      eventSelection: props.eventSelection
    };
  }
  sliceNowDate(date, dateProfile, nextDayThreshold, context, ...extraArgs) {
    return this._sliceDateSpan(
      { range: { start: date, end: addMs(date, 1) }, allDay: false },
      // add 1 ms, protect against null range
      dateProfile,
      nextDayThreshold,
      {},
      context,
      ...extraArgs
    );
  }
  _sliceBusinessHours(businessHours, dateProfile, nextDayThreshold, context, ...extraArgs) {
    if (!businessHours) {
      return [];
    }
    return this._sliceEventStore(expandRecurring(businessHours, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), context), {}, dateProfile, nextDayThreshold, ...extraArgs).bg;
  }
  _sliceEventStore(eventStore, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs) {
    if (eventStore) {
      let rangeRes = sliceEventStore(eventStore, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);
      return {
        bg: this.sliceEventRanges(rangeRes.bg, extraArgs),
        fg: this.sliceEventRanges(rangeRes.fg, extraArgs)
      };
    }
    return { bg: [], fg: [] };
  }
  _sliceInteraction(interaction, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs) {
    if (!interaction) {
      return null;
    }
    let rangeRes = sliceEventStore(interaction.mutatedEvents, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);
    return {
      segs: this.sliceEventRanges(rangeRes.fg, extraArgs),
      affectedInstances: interaction.affectedEvents.instances,
      isEvent: interaction.isEvent
    };
  }
  _sliceDateSpan(dateSpan, dateProfile, nextDayThreshold, eventUiBases, context, ...extraArgs) {
    if (!dateSpan) {
      return [];
    }
    let activeRange = computeActiveRange(dateProfile, Boolean(nextDayThreshold));
    let activeDateSpanRange = intersectRanges(dateSpan.range, activeRange);
    if (activeDateSpanRange) {
      dateSpan = Object.assign(Object.assign({}, dateSpan), { range: activeDateSpanRange });
      let eventRange = fabricateEventRange(dateSpan, eventUiBases, context);
      let segs = this.sliceRange(dateSpan.range, ...extraArgs);
      for (let seg of segs) {
        seg.eventRange = eventRange;
      }
      return segs;
    }
    return [];
  }
  /*
  "complete" seg means it has component and eventRange
  */
  sliceEventRanges(eventRanges, extraArgs) {
    let segs = [];
    for (let eventRange of eventRanges) {
      segs.push(...this.sliceEventRange(eventRange, extraArgs));
    }
    return segs;
  }
  /*
  "complete" seg means it has component and eventRange
  */
  sliceEventRange(eventRange, extraArgs) {
    let dateRange = eventRange.range;
    if (this.forceDayIfListItem && eventRange.ui.display === "list-item") {
      dateRange = {
        start: dateRange.start,
        end: addDays(dateRange.start, 1)
      };
    }
    let segs = this.sliceRange(dateRange, ...extraArgs);
    for (let seg of segs) {
      seg.eventRange = eventRange;
      seg.isStart = eventRange.isStart && seg.isStart;
      seg.isEnd = eventRange.isEnd && seg.isEnd;
    }
    return segs;
  }
};
function computeActiveRange(dateProfile, isComponentAllDay) {
  let range2 = dateProfile.activeRange;
  if (isComponentAllDay) {
    return range2;
  }
  return {
    start: addMs(range2.start, dateProfile.slotMinTime.milliseconds),
    end: addMs(range2.end, dateProfile.slotMaxTime.milliseconds - 864e5)
    // 864e5 = ms in a day
  };
}
function isInteractionValid(interaction, dateProfile, context) {
  let { instances } = interaction.mutatedEvents;
  for (let instanceId in instances) {
    if (!rangeContainsRange(dateProfile.validRange, instances[instanceId].range)) {
      return false;
    }
  }
  return isNewPropsValid({ eventDrag: interaction }, context);
}
function isDateSelectionValid(dateSelection, dateProfile, context) {
  if (!rangeContainsRange(dateProfile.validRange, dateSelection.range)) {
    return false;
  }
  return isNewPropsValid({ dateSelection }, context);
}
function isNewPropsValid(newProps, context) {
  let calendarState = context.getCurrentData();
  let props = Object.assign({ businessHours: calendarState.businessHours, dateSelection: "", eventStore: calendarState.eventStore, eventUiBases: calendarState.eventUiBases, eventSelection: "", eventDrag: null, eventResize: null }, newProps);
  return (context.pluginHooks.isPropsValid || isPropsValid)(props, context);
}
function isPropsValid(state, context, dateSpanMeta = {}, filterConfig) {
  if (state.eventDrag && !isInteractionPropsValid(state, context, dateSpanMeta, filterConfig)) {
    return false;
  }
  if (state.dateSelection && !isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig)) {
    return false;
  }
  return true;
}
function isInteractionPropsValid(state, context, dateSpanMeta, filterConfig) {
  let currentState = context.getCurrentData();
  let interaction = state.eventDrag;
  let subjectEventStore = interaction.mutatedEvents;
  let subjectDefs = subjectEventStore.defs;
  let subjectInstances = subjectEventStore.instances;
  let subjectConfigs = compileEventUis(subjectDefs, interaction.isEvent ? state.eventUiBases : { "": currentState.selectionConfig });
  if (filterConfig) {
    subjectConfigs = mapHash(subjectConfigs, filterConfig);
  }
  let otherEventStore = excludeInstances(state.eventStore, interaction.affectedEvents.instances);
  let otherDefs = otherEventStore.defs;
  let otherInstances = otherEventStore.instances;
  let otherConfigs = compileEventUis(otherDefs, state.eventUiBases);
  for (let subjectInstanceId in subjectInstances) {
    let subjectInstance = subjectInstances[subjectInstanceId];
    let subjectRange = subjectInstance.range;
    let subjectConfig = subjectConfigs[subjectInstance.defId];
    let subjectDef = subjectDefs[subjectInstance.defId];
    if (!allConstraintsPass(subjectConfig.constraints, subjectRange, otherEventStore, state.businessHours, context)) {
      return false;
    }
    let { eventOverlap } = context.options;
    let eventOverlapFunc = typeof eventOverlap === "function" ? eventOverlap : null;
    for (let otherInstanceId in otherInstances) {
      let otherInstance = otherInstances[otherInstanceId];
      if (rangesIntersect(subjectRange, otherInstance.range)) {
        let otherOverlap = otherConfigs[otherInstance.defId].overlap;
        if (otherOverlap === false && interaction.isEvent) {
          return false;
        }
        if (subjectConfig.overlap === false) {
          return false;
        }
        if (eventOverlapFunc && !eventOverlapFunc(
          new EventImpl(context, otherDefs[otherInstance.defId], otherInstance),
          // still event
          new EventImpl(context, subjectDef, subjectInstance)
        )) {
          return false;
        }
      }
    }
    let calendarEventStore = currentState.eventStore;
    for (let subjectAllow of subjectConfig.allows) {
      let subjectDateSpan = Object.assign(Object.assign({}, dateSpanMeta), { range: subjectInstance.range, allDay: subjectDef.allDay });
      let origDef = calendarEventStore.defs[subjectDef.defId];
      let origInstance = calendarEventStore.instances[subjectInstanceId];
      let eventApi;
      if (origDef) {
        eventApi = new EventImpl(context, origDef, origInstance);
      } else {
        eventApi = new EventImpl(context, subjectDef);
      }
      if (!subjectAllow(buildDateSpanApiWithContext(subjectDateSpan, context), eventApi)) {
        return false;
      }
    }
  }
  return true;
}
function isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig) {
  let relevantEventStore = state.eventStore;
  let relevantDefs = relevantEventStore.defs;
  let relevantInstances = relevantEventStore.instances;
  let selection = state.dateSelection;
  let selectionRange = selection.range;
  let { selectionConfig } = context.getCurrentData();
  if (filterConfig) {
    selectionConfig = filterConfig(selectionConfig);
  }
  if (!allConstraintsPass(selectionConfig.constraints, selectionRange, relevantEventStore, state.businessHours, context)) {
    return false;
  }
  let { selectOverlap } = context.options;
  let selectOverlapFunc = typeof selectOverlap === "function" ? selectOverlap : null;
  for (let relevantInstanceId in relevantInstances) {
    let relevantInstance = relevantInstances[relevantInstanceId];
    if (rangesIntersect(selectionRange, relevantInstance.range)) {
      if (selectionConfig.overlap === false) {
        return false;
      }
      if (selectOverlapFunc && !selectOverlapFunc(new EventImpl(context, relevantDefs[relevantInstance.defId], relevantInstance), null)) {
        return false;
      }
    }
  }
  for (let selectionAllow of selectionConfig.allows) {
    let fullDateSpan = Object.assign(Object.assign({}, dateSpanMeta), selection);
    if (!selectionAllow(buildDateSpanApiWithContext(fullDateSpan, context), null)) {
      return false;
    }
  }
  return true;
}
function allConstraintsPass(constraints, subjectRange, otherEventStore, businessHoursUnexpanded, context) {
  for (let constraint of constraints) {
    if (!anyRangesContainRange(constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, context), subjectRange)) {
      return false;
    }
  }
  return true;
}
function constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, context) {
  if (constraint === "businessHours") {
    return eventStoreToRanges(expandRecurring(businessHoursUnexpanded, subjectRange, context));
  }
  if (typeof constraint === "string") {
    return eventStoreToRanges(filterEventStoreDefs(otherEventStore, (eventDef) => eventDef.groupId === constraint));
  }
  if (typeof constraint === "object" && constraint) {
    return eventStoreToRanges(expandRecurring(constraint, subjectRange, context));
  }
  return [];
}
function eventStoreToRanges(eventStore) {
  let { instances } = eventStore;
  let ranges = [];
  for (let instanceId in instances) {
    ranges.push(instances[instanceId].range);
  }
  return ranges;
}
function anyRangesContainRange(outerRanges, innerRange) {
  for (let outerRange of outerRanges) {
    if (rangeContainsRange(outerRange, innerRange)) {
      return true;
    }
  }
  return false;
}
var VISIBLE_HIDDEN_RE = /^(visible|hidden)$/;
var Scroller = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.handleEl = (el) => {
      this.el = el;
      setRef(this.props.elRef, el);
    };
  }
  render() {
    let { props } = this;
    let { liquid, liquidIsAbsolute } = props;
    let isAbsolute = liquid && liquidIsAbsolute;
    let className = ["fc-scroller"];
    if (liquid) {
      if (liquidIsAbsolute) {
        className.push("fc-scroller-liquid-absolute");
      } else {
        className.push("fc-scroller-liquid");
      }
    }
    return y("div", { ref: this.handleEl, className: className.join(" "), style: {
      overflowX: props.overflowX,
      overflowY: props.overflowY,
      left: isAbsolute && -(props.overcomeLeft || 0) || "",
      right: isAbsolute && -(props.overcomeRight || 0) || "",
      bottom: isAbsolute && -(props.overcomeBottom || 0) || "",
      marginLeft: !isAbsolute && -(props.overcomeLeft || 0) || "",
      marginRight: !isAbsolute && -(props.overcomeRight || 0) || "",
      marginBottom: !isAbsolute && -(props.overcomeBottom || 0) || "",
      maxHeight: props.maxHeight || ""
    } }, props.children);
  }
  needsXScrolling() {
    if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {
      return false;
    }
    let { el } = this;
    let realClientWidth = this.el.getBoundingClientRect().width - this.getYScrollbarWidth();
    let { children } = el;
    for (let i3 = 0; i3 < children.length; i3 += 1) {
      let childEl = children[i3];
      if (childEl.getBoundingClientRect().width > realClientWidth) {
        return true;
      }
    }
    return false;
  }
  needsYScrolling() {
    if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {
      return false;
    }
    let { el } = this;
    let realClientHeight = this.el.getBoundingClientRect().height - this.getXScrollbarWidth();
    let { children } = el;
    for (let i3 = 0; i3 < children.length; i3 += 1) {
      let childEl = children[i3];
      if (childEl.getBoundingClientRect().height > realClientHeight) {
        return true;
      }
    }
    return false;
  }
  getXScrollbarWidth() {
    if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {
      return 0;
    }
    return this.el.offsetHeight - this.el.clientHeight;
  }
  getYScrollbarWidth() {
    if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {
      return 0;
    }
    return this.el.offsetWidth - this.el.clientWidth;
  }
};
var RefMap = class {
  constructor(masterCallback) {
    this.masterCallback = masterCallback;
    this.currentMap = {};
    this.depths = {};
    this.callbackMap = {};
    this.handleValue = (val, key) => {
      let { depths, currentMap } = this;
      let removed = false;
      let added = false;
      if (val !== null) {
        removed = key in currentMap;
        currentMap[key] = val;
        depths[key] = (depths[key] || 0) + 1;
        added = true;
      } else {
        depths[key] -= 1;
        if (!depths[key]) {
          delete currentMap[key];
          delete this.callbackMap[key];
          removed = true;
        }
      }
      if (this.masterCallback) {
        if (removed) {
          this.masterCallback(null, String(key));
        }
        if (added) {
          this.masterCallback(val, String(key));
        }
      }
    };
  }
  createRef(key) {
    let refCallback = this.callbackMap[key];
    if (!refCallback) {
      refCallback = this.callbackMap[key] = (val) => {
        this.handleValue(val, String(key));
      };
    }
    return refCallback;
  }
  // TODO: check callers that don't care about order. should use getAll instead
  // NOTE: this method has become less valuable now that we are encouraged to map order by some other index
  // TODO: provide ONE array-export function, buildArray, which fails on non-numeric indexes. caller can manipulate and "collect"
  collect(startIndex, endIndex, step) {
    return collectFromHash(this.currentMap, startIndex, endIndex, step);
  }
  getAll() {
    return hashValuesToArray(this.currentMap);
  }
};
function computeShrinkWidth(chunkEls) {
  let shrinkCells = findElements(chunkEls, ".fc-scrollgrid-shrink");
  let largestWidth = 0;
  for (let shrinkCell of shrinkCells) {
    largestWidth = Math.max(largestWidth, computeSmallestCellWidth(shrinkCell));
  }
  return Math.ceil(largestWidth);
}
function getSectionHasLiquidHeight(props, sectionConfig) {
  return props.liquid && sectionConfig.liquid;
}
function getAllowYScrolling(props, sectionConfig) {
  return sectionConfig.maxHeight != null || // if its possible for the height to max out, we might need scrollbars
  getSectionHasLiquidHeight(props, sectionConfig);
}
function renderChunkContent(sectionConfig, chunkConfig, arg, isHeader) {
  let { expandRows } = arg;
  let content = typeof chunkConfig.content === "function" ? chunkConfig.content(arg) : y("table", {
    role: "presentation",
    className: [
      chunkConfig.tableClassName,
      sectionConfig.syncRowHeights ? "fc-scrollgrid-sync-table" : ""
    ].join(" "),
    style: {
      minWidth: arg.tableMinWidth,
      width: arg.clientWidth,
      height: expandRows ? arg.clientHeight : ""
      // css `height` on a <table> serves as a min-height
    }
  }, arg.tableColGroupNode, y(isHeader ? "thead" : "tbody", {
    role: "presentation"
  }, typeof chunkConfig.rowContent === "function" ? chunkConfig.rowContent(arg) : chunkConfig.rowContent));
  return content;
}
function isColPropsEqual(cols0, cols1) {
  return isArraysEqual(cols0, cols1, isPropsEqual);
}
function renderMicroColGroup(cols, shrinkWidth) {
  let colNodes = [];
  for (let colProps of cols) {
    let span = colProps.span || 1;
    for (let i3 = 0; i3 < span; i3 += 1) {
      colNodes.push(y("col", { style: {
        width: colProps.width === "shrink" ? sanitizeShrinkWidth(shrinkWidth) : colProps.width || "",
        minWidth: colProps.minWidth || ""
      } }));
    }
  }
  return y("colgroup", {}, ...colNodes);
}
function sanitizeShrinkWidth(shrinkWidth) {
  return shrinkWidth == null ? 4 : shrinkWidth;
}
function hasShrinkWidth(cols) {
  for (let col of cols) {
    if (col.width === "shrink") {
      return true;
    }
  }
  return false;
}
function getScrollGridClassNames(liquid, context) {
  let classNames = [
    "fc-scrollgrid",
    context.theme.getClass("table")
  ];
  if (liquid) {
    classNames.push("fc-scrollgrid-liquid");
  }
  return classNames;
}
function getSectionClassNames(sectionConfig, wholeTableVGrow) {
  let classNames = [
    "fc-scrollgrid-section",
    `fc-scrollgrid-section-${sectionConfig.type}`,
    sectionConfig.className
    // used?
  ];
  if (wholeTableVGrow && sectionConfig.liquid && sectionConfig.maxHeight == null) {
    classNames.push("fc-scrollgrid-section-liquid");
  }
  if (sectionConfig.isSticky) {
    classNames.push("fc-scrollgrid-section-sticky");
  }
  return classNames;
}
function renderScrollShim(arg) {
  return y("div", { className: "fc-scrollgrid-sticky-shim", style: {
    width: arg.clientWidth,
    minWidth: arg.tableMinWidth
  } });
}
function getStickyHeaderDates(options) {
  let { stickyHeaderDates } = options;
  if (stickyHeaderDates == null || stickyHeaderDates === "auto") {
    stickyHeaderDates = options.height === "auto" || options.viewHeight === "auto";
  }
  return stickyHeaderDates;
}
function getStickyFooterScrollbar(options) {
  let { stickyFooterScrollbar } = options;
  if (stickyFooterScrollbar == null || stickyFooterScrollbar === "auto") {
    stickyFooterScrollbar = options.height === "auto" || options.viewHeight === "auto";
  }
  return stickyFooterScrollbar;
}
var SimpleScrollGrid = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.processCols = memoize((a3) => a3, isColPropsEqual);
    this.renderMicroColGroup = memoize(renderMicroColGroup);
    this.scrollerRefs = new RefMap();
    this.scrollerElRefs = new RefMap(this._handleScrollerEl.bind(this));
    this.state = {
      shrinkWidth: null,
      forceYScrollbars: false,
      scrollerClientWidths: {},
      scrollerClientHeights: {}
    };
    this.handleSizing = () => {
      this.safeSetState(Object.assign({ shrinkWidth: this.computeShrinkWidth() }, this.computeScrollerDims()));
    };
  }
  render() {
    let { props, state, context } = this;
    let sectionConfigs = props.sections || [];
    let cols = this.processCols(props.cols);
    let microColGroupNode = this.renderMicroColGroup(cols, state.shrinkWidth);
    let classNames = getScrollGridClassNames(props.liquid, context);
    if (props.collapsibleWidth) {
      classNames.push("fc-scrollgrid-collapsible");
    }
    let configCnt = sectionConfigs.length;
    let configI = 0;
    let currentConfig;
    let headSectionNodes = [];
    let bodySectionNodes = [];
    let footSectionNodes = [];
    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === "header") {
      headSectionNodes.push(this.renderSection(currentConfig, microColGroupNode, true));
      configI += 1;
    }
    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === "body") {
      bodySectionNodes.push(this.renderSection(currentConfig, microColGroupNode, false));
      configI += 1;
    }
    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === "footer") {
      footSectionNodes.push(this.renderSection(currentConfig, microColGroupNode, true));
      configI += 1;
    }
    let isBuggy = !getCanVGrowWithinCell();
    const roleAttrs = { role: "rowgroup" };
    return y("table", {
      role: "grid",
      className: classNames.join(" "),
      style: { height: props.height }
    }, Boolean(!isBuggy && headSectionNodes.length) && y("thead", roleAttrs, ...headSectionNodes), Boolean(!isBuggy && bodySectionNodes.length) && y("tbody", roleAttrs, ...bodySectionNodes), Boolean(!isBuggy && footSectionNodes.length) && y("tfoot", roleAttrs, ...footSectionNodes), isBuggy && y("tbody", roleAttrs, ...headSectionNodes, ...bodySectionNodes, ...footSectionNodes));
  }
  renderSection(sectionConfig, microColGroupNode, isHeader) {
    if ("outerContent" in sectionConfig) {
      return y(_, { key: sectionConfig.key }, sectionConfig.outerContent);
    }
    return y("tr", { key: sectionConfig.key, role: "presentation", className: getSectionClassNames(sectionConfig, this.props.liquid).join(" ") }, this.renderChunkTd(sectionConfig, microColGroupNode, sectionConfig.chunk, isHeader));
  }
  renderChunkTd(sectionConfig, microColGroupNode, chunkConfig, isHeader) {
    if ("outerContent" in chunkConfig) {
      return chunkConfig.outerContent;
    }
    let { props } = this;
    let { forceYScrollbars, scrollerClientWidths, scrollerClientHeights } = this.state;
    let needsYScrolling = getAllowYScrolling(props, sectionConfig);
    let isLiquid = getSectionHasLiquidHeight(props, sectionConfig);
    let overflowY = !props.liquid ? "visible" : forceYScrollbars ? "scroll" : !needsYScrolling ? "hidden" : "auto";
    let sectionKey = sectionConfig.key;
    let content = renderChunkContent(sectionConfig, chunkConfig, {
      tableColGroupNode: microColGroupNode,
      tableMinWidth: "",
      clientWidth: !props.collapsibleWidth && scrollerClientWidths[sectionKey] !== void 0 ? scrollerClientWidths[sectionKey] : null,
      clientHeight: scrollerClientHeights[sectionKey] !== void 0 ? scrollerClientHeights[sectionKey] : null,
      expandRows: sectionConfig.expandRows,
      syncRowHeights: false,
      rowSyncHeights: [],
      reportRowHeightChange: () => {
      }
    }, isHeader);
    return y(isHeader ? "th" : "td", {
      ref: chunkConfig.elRef,
      role: "presentation"
    }, y(
      "div",
      { className: `fc-scroller-harness${isLiquid ? " fc-scroller-harness-liquid" : ""}` },
      y(Scroller, { ref: this.scrollerRefs.createRef(sectionKey), elRef: this.scrollerElRefs.createRef(sectionKey), overflowY, overflowX: !props.liquid ? "visible" : "hidden", maxHeight: sectionConfig.maxHeight, liquid: isLiquid, liquidIsAbsolute: true }, content)
    ));
  }
  _handleScrollerEl(scrollerEl, key) {
    let section = getSectionByKey(this.props.sections, key);
    if (section) {
      setRef(section.chunk.scrollerElRef, scrollerEl);
    }
  }
  componentDidMount() {
    this.handleSizing();
    this.context.addResizeHandler(this.handleSizing);
  }
  componentDidUpdate() {
    this.handleSizing();
  }
  componentWillUnmount() {
    this.context.removeResizeHandler(this.handleSizing);
  }
  computeShrinkWidth() {
    return hasShrinkWidth(this.props.cols) ? computeShrinkWidth(this.scrollerElRefs.getAll()) : 0;
  }
  computeScrollerDims() {
    let scrollbarWidth = getScrollbarWidths();
    let { scrollerRefs, scrollerElRefs } = this;
    let forceYScrollbars = false;
    let scrollerClientWidths = {};
    let scrollerClientHeights = {};
    for (let sectionKey in scrollerRefs.currentMap) {
      let scroller = scrollerRefs.currentMap[sectionKey];
      if (scroller && scroller.needsYScrolling()) {
        forceYScrollbars = true;
        break;
      }
    }
    for (let section of this.props.sections) {
      let sectionKey = section.key;
      let scrollerEl = scrollerElRefs.currentMap[sectionKey];
      if (scrollerEl) {
        let harnessEl = scrollerEl.parentNode;
        scrollerClientWidths[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().width - (forceYScrollbars ? scrollbarWidth.y : 0));
        scrollerClientHeights[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().height);
      }
    }
    return { forceYScrollbars, scrollerClientWidths, scrollerClientHeights };
  }
};
SimpleScrollGrid.addStateEquality({
  scrollerClientWidths: isPropsEqual,
  scrollerClientHeights: isPropsEqual
});
function getSectionByKey(sections, key) {
  for (let section of sections) {
    if (section.key === key) {
      return section;
    }
  }
  return null;
}
var EventContainer = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.handleEl = (el) => {
      this.el = el;
      if (el) {
        setElSeg(el, this.props.seg);
      }
    };
  }
  render() {
    const { props, context } = this;
    const { options } = context;
    const { seg } = props;
    const { eventRange } = seg;
    const { ui } = eventRange;
    const renderProps = {
      event: new EventImpl(context, eventRange.def, eventRange.instance),
      view: context.viewApi,
      timeText: props.timeText,
      textColor: ui.textColor,
      backgroundColor: ui.backgroundColor,
      borderColor: ui.borderColor,
      isDraggable: !props.disableDragging && computeSegDraggable(seg, context),
      isStartResizable: !props.disableResizing && computeSegStartResizable(seg, context),
      isEndResizable: !props.disableResizing && computeSegEndResizable(seg),
      isMirror: Boolean(props.isDragging || props.isResizing || props.isDateSelecting),
      isStart: Boolean(seg.isStart),
      isEnd: Boolean(seg.isEnd),
      isPast: Boolean(props.isPast),
      isFuture: Boolean(props.isFuture),
      isToday: Boolean(props.isToday),
      isSelected: Boolean(props.isSelected),
      isDragging: Boolean(props.isDragging),
      isResizing: Boolean(props.isResizing)
    };
    return y(ContentContainer, Object.assign({}, props, { elRef: this.handleEl, elClasses: [
      ...getEventClassNames(renderProps),
      ...seg.eventRange.ui.classNames,
      ...props.elClasses || []
    ], renderProps, generatorName: "eventContent", customGenerator: options.eventContent, defaultGenerator: props.defaultGenerator, classNameGenerator: options.eventClassNames, didMount: options.eventDidMount, willUnmount: options.eventWillUnmount }));
  }
  componentDidUpdate(prevProps) {
    if (this.el && this.props.seg !== prevProps.seg) {
      setElSeg(this.el, this.props.seg);
    }
  }
};
var StandardEvent = class extends BaseComponent {
  render() {
    let { props, context } = this;
    let { options } = context;
    let { seg } = props;
    let { ui } = seg.eventRange;
    let timeFormat = options.eventTimeFormat || props.defaultTimeFormat;
    let timeText = buildSegTimeText(seg, timeFormat, context, props.defaultDisplayEventTime, props.defaultDisplayEventEnd);
    return y(EventContainer, Object.assign({}, props, { elTag: "a", elStyle: {
      borderColor: ui.borderColor,
      backgroundColor: ui.backgroundColor
    }, elAttrs: getSegAnchorAttrs(seg, context), defaultGenerator: renderInnerContent$1, timeText }), (InnerContent, eventContentArg) => y(
      _,
      null,
      y(InnerContent, { elTag: "div", elClasses: ["fc-event-main"], elStyle: { color: eventContentArg.textColor } }),
      Boolean(eventContentArg.isStartResizable) && y("div", { className: "fc-event-resizer fc-event-resizer-start" }),
      Boolean(eventContentArg.isEndResizable) && y("div", { className: "fc-event-resizer fc-event-resizer-end" })
    ));
  }
};
function renderInnerContent$1(innerProps) {
  return y(
    "div",
    { className: "fc-event-main-frame" },
    innerProps.timeText && y("div", { className: "fc-event-time" }, innerProps.timeText),
    y(
      "div",
      { className: "fc-event-title-container" },
      y("div", { className: "fc-event-title fc-sticky" }, innerProps.event.title || y(_, null, "\xA0"))
    )
  );
}
var NowIndicatorContainer = (props) => y(ViewContextType.Consumer, null, (context) => {
  let { options } = context;
  let renderProps = {
    isAxis: props.isAxis,
    date: context.dateEnv.toDate(props.date),
    view: context.viewApi
  };
  return y(ContentContainer, Object.assign({}, props, { elTag: props.elTag || "div", renderProps, generatorName: "nowIndicatorContent", customGenerator: options.nowIndicatorContent, classNameGenerator: options.nowIndicatorClassNames, didMount: options.nowIndicatorDidMount, willUnmount: options.nowIndicatorWillUnmount }));
});
var DAY_NUM_FORMAT = createFormatter({ day: "numeric" });
var DayCellContainer = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.refineRenderProps = memoizeObjArg(refineRenderProps);
  }
  render() {
    let { props, context } = this;
    let { options } = context;
    let renderProps = this.refineRenderProps({
      date: props.date,
      dateProfile: props.dateProfile,
      todayRange: props.todayRange,
      isMonthStart: props.isMonthStart || false,
      showDayNumber: props.showDayNumber,
      extraRenderProps: props.extraRenderProps,
      viewApi: context.viewApi,
      dateEnv: context.dateEnv,
      monthStartFormat: options.monthStartFormat
    });
    return y(ContentContainer, Object.assign({}, props, { elClasses: [
      ...getDayClassNames(renderProps, context.theme),
      ...props.elClasses || []
    ], elAttrs: Object.assign(Object.assign({}, props.elAttrs), renderProps.isDisabled ? {} : { "data-date": formatDayString(props.date) }), renderProps, generatorName: "dayCellContent", customGenerator: options.dayCellContent, defaultGenerator: props.defaultGenerator, classNameGenerator: (
      // don't use custom classNames if disabled
      renderProps.isDisabled ? void 0 : options.dayCellClassNames
    ), didMount: options.dayCellDidMount, willUnmount: options.dayCellWillUnmount }));
  }
};
function hasCustomDayCellContent(options) {
  return Boolean(options.dayCellContent || hasCustomRenderingHandler("dayCellContent", options));
}
function refineRenderProps(raw) {
  let { date, dateEnv, dateProfile, isMonthStart } = raw;
  let dayMeta = getDateMeta(date, raw.todayRange, null, dateProfile);
  let dayNumberText = raw.showDayNumber ? dateEnv.format(date, isMonthStart ? raw.monthStartFormat : DAY_NUM_FORMAT) : "";
  return Object.assign(Object.assign(Object.assign({ date: dateEnv.toDate(date), view: raw.viewApi }, dayMeta), {
    isMonthStart,
    dayNumberText
  }), raw.extraRenderProps);
}
var BgEvent = class extends BaseComponent {
  render() {
    let { props } = this;
    let { seg } = props;
    return y(EventContainer, { elTag: "div", elClasses: ["fc-bg-event"], elStyle: { backgroundColor: seg.eventRange.ui.backgroundColor }, defaultGenerator: renderInnerContent, seg, timeText: "", isDragging: false, isResizing: false, isDateSelecting: false, isSelected: false, isPast: props.isPast, isFuture: props.isFuture, isToday: props.isToday, disableDragging: true, disableResizing: true });
  }
};
function renderInnerContent(props) {
  let { title } = props.event;
  return title && y("div", { className: "fc-event-title" }, props.event.title);
}
function renderFill(fillType) {
  return y("div", { className: `fc-${fillType}` });
}
var WeekNumberContainer = (props) => y(ViewContextType.Consumer, null, (context) => {
  let { dateEnv, options } = context;
  let { date } = props;
  let format = options.weekNumberFormat || props.defaultFormat;
  let num = dateEnv.computeWeekNumber(date);
  let text = dateEnv.format(date, format);
  let renderProps = { num, text, date };
  return y(
    ContentContainer,
    Object.assign({}, props, { renderProps, generatorName: "weekNumberContent", customGenerator: options.weekNumberContent, defaultGenerator: renderInner, classNameGenerator: options.weekNumberClassNames, didMount: options.weekNumberDidMount, willUnmount: options.weekNumberWillUnmount })
  );
});
function renderInner(innerProps) {
  return innerProps.text;
}
var PADDING_FROM_VIEWPORT = 10;
var Popover = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.state = {
      titleId: getUniqueDomId()
    };
    this.handleRootEl = (el) => {
      this.rootEl = el;
      if (this.props.elRef) {
        setRef(this.props.elRef, el);
      }
    };
    this.handleDocumentMouseDown = (ev) => {
      const target = getEventTargetViaRoot(ev);
      if (!this.rootEl.contains(target)) {
        this.handleCloseClick();
      }
    };
    this.handleDocumentKeyDown = (ev) => {
      if (ev.key === "Escape") {
        this.handleCloseClick();
      }
    };
    this.handleCloseClick = () => {
      let { onClose } = this.props;
      if (onClose) {
        onClose();
      }
    };
  }
  render() {
    let { theme, options } = this.context;
    let { props, state } = this;
    let classNames = [
      "fc-popover",
      theme.getClass("popover")
    ].concat(props.extraClassNames || []);
    return j3(y(
      "div",
      Object.assign({}, props.extraAttrs, { id: props.id, className: classNames.join(" "), "aria-labelledby": state.titleId, ref: this.handleRootEl }),
      y(
        "div",
        { className: "fc-popover-header " + theme.getClass("popoverHeader") },
        y("span", { className: "fc-popover-title", id: state.titleId }, props.title),
        y("span", { className: "fc-popover-close " + theme.getIconClass("close"), title: options.closeHint, onClick: this.handleCloseClick })
      ),
      y("div", { className: "fc-popover-body " + theme.getClass("popoverContent") }, props.children)
    ), props.parentEl);
  }
  componentDidMount() {
    document.addEventListener("mousedown", this.handleDocumentMouseDown);
    document.addEventListener("keydown", this.handleDocumentKeyDown);
    this.updateSize();
  }
  componentWillUnmount() {
    document.removeEventListener("mousedown", this.handleDocumentMouseDown);
    document.removeEventListener("keydown", this.handleDocumentKeyDown);
  }
  updateSize() {
    let { isRtl } = this.context;
    let { alignmentEl, alignGridTop } = this.props;
    let { rootEl } = this;
    let alignmentRect = computeClippedClientRect(alignmentEl);
    if (alignmentRect) {
      let popoverDims = rootEl.getBoundingClientRect();
      let popoverTop = alignGridTop ? elementClosest(alignmentEl, ".fc-scrollgrid").getBoundingClientRect().top : alignmentRect.top;
      let popoverLeft = isRtl ? alignmentRect.right - popoverDims.width : alignmentRect.left;
      popoverTop = Math.max(popoverTop, PADDING_FROM_VIEWPORT);
      popoverLeft = Math.min(popoverLeft, document.documentElement.clientWidth - PADDING_FROM_VIEWPORT - popoverDims.width);
      popoverLeft = Math.max(popoverLeft, PADDING_FROM_VIEWPORT);
      let origin = rootEl.offsetParent.getBoundingClientRect();
      applyStyle(rootEl, {
        top: popoverTop - origin.top,
        left: popoverLeft - origin.left
      });
    }
  }
};
var MorePopover = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.handleRootEl = (rootEl) => {
      this.rootEl = rootEl;
      if (rootEl) {
        this.context.registerInteractiveComponent(this, {
          el: rootEl,
          useEventCenter: false
        });
      } else {
        this.context.unregisterInteractiveComponent(this);
      }
    };
  }
  render() {
    let { options, dateEnv } = this.context;
    let { props } = this;
    let { startDate, todayRange, dateProfile } = props;
    let title = dateEnv.format(startDate, options.dayPopoverFormat);
    return y(DayCellContainer, { elRef: this.handleRootEl, date: startDate, dateProfile, todayRange }, (InnerContent, renderProps, elAttrs) => y(
      Popover,
      { elRef: elAttrs.ref, id: props.id, title, extraClassNames: ["fc-more-popover"].concat(elAttrs.className || []), extraAttrs: elAttrs, parentEl: props.parentEl, alignmentEl: props.alignmentEl, alignGridTop: props.alignGridTop, onClose: props.onClose },
      hasCustomDayCellContent(options) && y(InnerContent, { elTag: "div", elClasses: ["fc-more-popover-misc"] }),
      props.children
    ));
  }
  queryHit(positionLeft, positionTop, elWidth, elHeight) {
    let { rootEl, props } = this;
    if (positionLeft >= 0 && positionLeft < elWidth && positionTop >= 0 && positionTop < elHeight) {
      return {
        dateProfile: props.dateProfile,
        dateSpan: Object.assign({ allDay: !props.forceTimed, range: {
          start: props.startDate,
          end: props.endDate
        } }, props.extraDateSpan),
        dayEl: rootEl,
        rect: {
          left: 0,
          top: 0,
          right: elWidth,
          bottom: elHeight
        },
        layer: 1
        // important when comparing with hits from other components
      };
    }
    return null;
  }
};
var MoreLinkContainer = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.state = {
      isPopoverOpen: false,
      popoverId: getUniqueDomId()
    };
    this.handleLinkEl = (linkEl) => {
      this.linkEl = linkEl;
      if (this.props.elRef) {
        setRef(this.props.elRef, linkEl);
      }
    };
    this.handleClick = (ev) => {
      let { props, context } = this;
      let { moreLinkClick } = context.options;
      let date = computeRange(props).start;
      function buildPublicSeg(seg) {
        let { def, instance, range: range2 } = seg.eventRange;
        return {
          event: new EventImpl(context, def, instance),
          start: context.dateEnv.toDate(range2.start),
          end: context.dateEnv.toDate(range2.end),
          isStart: seg.isStart,
          isEnd: seg.isEnd
        };
      }
      if (typeof moreLinkClick === "function") {
        moreLinkClick = moreLinkClick({
          date,
          allDay: Boolean(props.allDayDate),
          allSegs: props.allSegs.map(buildPublicSeg),
          hiddenSegs: props.hiddenSegs.map(buildPublicSeg),
          jsEvent: ev,
          view: context.viewApi
        });
      }
      if (!moreLinkClick || moreLinkClick === "popover") {
        this.setState({ isPopoverOpen: true });
      } else if (typeof moreLinkClick === "string") {
        context.calendarApi.zoomTo(date, moreLinkClick);
      }
    };
    this.handlePopoverClose = () => {
      this.setState({ isPopoverOpen: false });
    };
  }
  render() {
    let { props, state } = this;
    return y(ViewContextType.Consumer, null, (context) => {
      let { viewApi, options, calendarApi } = context;
      let { moreLinkText } = options;
      let { moreCnt } = props;
      let range2 = computeRange(props);
      let text = typeof moreLinkText === "function" ? moreLinkText.call(calendarApi, moreCnt) : `+${moreCnt} ${moreLinkText}`;
      let hint = formatWithOrdinals(options.moreLinkHint, [moreCnt], text);
      let renderProps = {
        num: moreCnt,
        shortText: `+${moreCnt}`,
        text,
        view: viewApi
      };
      return y(
        _,
        null,
        Boolean(props.moreCnt) && y(ContentContainer, { elTag: props.elTag || "a", elRef: this.handleLinkEl, elClasses: [
          ...props.elClasses || [],
          "fc-more-link"
        ], elStyle: props.elStyle, elAttrs: Object.assign(Object.assign(Object.assign({}, props.elAttrs), createAriaClickAttrs(this.handleClick)), { title: hint, "aria-expanded": state.isPopoverOpen, "aria-controls": state.isPopoverOpen ? state.popoverId : "" }), renderProps, generatorName: "moreLinkContent", customGenerator: options.moreLinkContent, defaultGenerator: props.defaultGenerator || renderMoreLinkInner, classNameGenerator: options.moreLinkClassNames, didMount: options.moreLinkDidMount, willUnmount: options.moreLinkWillUnmount }, props.children),
        state.isPopoverOpen && y(MorePopover, { id: state.popoverId, startDate: range2.start, endDate: range2.end, dateProfile: props.dateProfile, todayRange: props.todayRange, extraDateSpan: props.extraDateSpan, parentEl: this.parentEl, alignmentEl: props.alignmentElRef ? props.alignmentElRef.current : this.linkEl, alignGridTop: props.alignGridTop, forceTimed: props.forceTimed, onClose: this.handlePopoverClose }, props.popoverContent())
      );
    });
  }
  componentDidMount() {
    this.updateParentEl();
  }
  componentDidUpdate() {
    this.updateParentEl();
  }
  updateParentEl() {
    if (this.linkEl) {
      this.parentEl = elementClosest(this.linkEl, ".fc-view-harness");
    }
  }
};
function renderMoreLinkInner(props) {
  return props.text;
}
function computeRange(props) {
  if (props.allDayDate) {
    return {
      start: props.allDayDate,
      end: addDays(props.allDayDate, 1)
    };
  }
  let { hiddenSegs } = props;
  return {
    start: computeEarliestSegStart(hiddenSegs),
    end: computeLatestSegEnd(hiddenSegs)
  };
}
function computeEarliestSegStart(segs) {
  return segs.reduce(pickEarliestStart).eventRange.range.start;
}
function pickEarliestStart(seg0, seg1) {
  return seg0.eventRange.range.start < seg1.eventRange.range.start ? seg0 : seg1;
}
function computeLatestSegEnd(segs) {
  return segs.reduce(pickLatestEnd).eventRange.range.end;
}
function pickLatestEnd(seg0, seg1) {
  return seg0.eventRange.range.end > seg1.eventRange.range.end ? seg0 : seg1;
}

// node_modules/@fullcalendar/core/index.js
var globalLocales = [];
var MINIMAL_RAW_EN_LOCALE = {
  code: "en",
  week: {
    dow: 0,
    doy: 4
    // 4 days need to be within the year to be considered the first week
  },
  direction: "ltr",
  buttonText: {
    prev: "prev",
    next: "next",
    prevYear: "prev year",
    nextYear: "next year",
    year: "year",
    today: "today",
    month: "month",
    week: "week",
    day: "day",
    list: "list"
  },
  weekText: "W",
  weekTextLong: "Week",
  closeHint: "Close",
  timeHint: "Time",
  eventHint: "Event",
  allDayText: "all-day",
  moreLinkText: "more",
  noEventsText: "No events to display"
};
var RAW_EN_LOCALE = Object.assign(Object.assign({}, MINIMAL_RAW_EN_LOCALE), {
  // Includes things we don't want other locales to inherit,
  // things that derive from other translatable strings.
  buttonHints: {
    prev: "Previous $0",
    next: "Next $0",
    today(buttonText, unit) {
      return unit === "day" ? "Today" : `This ${buttonText}`;
    }
  },
  viewHint: "$0 view",
  navLinkHint: "Go to $0",
  moreLinkHint(eventCnt) {
    return `Show ${eventCnt} more event${eventCnt === 1 ? "" : "s"}`;
  }
});
function organizeRawLocales(explicitRawLocales) {
  let defaultCode = explicitRawLocales.length > 0 ? explicitRawLocales[0].code : "en";
  let allRawLocales = globalLocales.concat(explicitRawLocales);
  let rawLocaleMap = {
    en: RAW_EN_LOCALE
  };
  for (let rawLocale of allRawLocales) {
    rawLocaleMap[rawLocale.code] = rawLocale;
  }
  return {
    map: rawLocaleMap,
    defaultCode
  };
}
function buildLocale(inputSingular, available) {
  if (typeof inputSingular === "object" && !Array.isArray(inputSingular)) {
    return parseLocale(inputSingular.code, [inputSingular.code], inputSingular);
  }
  return queryLocale(inputSingular, available);
}
function queryLocale(codeArg, available) {
  let codes = [].concat(codeArg || []);
  let raw = queryRawLocale(codes, available) || RAW_EN_LOCALE;
  return parseLocale(codeArg, codes, raw);
}
function queryRawLocale(codes, available) {
  for (let i3 = 0; i3 < codes.length; i3 += 1) {
    let parts = codes[i3].toLocaleLowerCase().split("-");
    for (let j4 = parts.length; j4 > 0; j4 -= 1) {
      let simpleId = parts.slice(0, j4).join("-");
      if (available[simpleId]) {
        return available[simpleId];
      }
    }
  }
  return null;
}
function parseLocale(codeArg, codes, raw) {
  let merged = mergeProps([MINIMAL_RAW_EN_LOCALE, raw], ["buttonText"]);
  delete merged.code;
  let { week } = merged;
  delete merged.week;
  return {
    codeArg,
    codes,
    week,
    simpleNumberFormat: new Intl.NumberFormat(codeArg),
    options: merged
  };
}
function createPlugin(input) {
  return {
    id: guid(),
    name: input.name,
    premiumReleaseDate: input.premiumReleaseDate ? new Date(input.premiumReleaseDate) : void 0,
    deps: input.deps || [],
    reducers: input.reducers || [],
    isLoadingFuncs: input.isLoadingFuncs || [],
    contextInit: [].concat(input.contextInit || []),
    eventRefiners: input.eventRefiners || {},
    eventDefMemberAdders: input.eventDefMemberAdders || [],
    eventSourceRefiners: input.eventSourceRefiners || {},
    isDraggableTransformers: input.isDraggableTransformers || [],
    eventDragMutationMassagers: input.eventDragMutationMassagers || [],
    eventDefMutationAppliers: input.eventDefMutationAppliers || [],
    dateSelectionTransformers: input.dateSelectionTransformers || [],
    datePointTransforms: input.datePointTransforms || [],
    dateSpanTransforms: input.dateSpanTransforms || [],
    views: input.views || {},
    viewPropsTransformers: input.viewPropsTransformers || [],
    isPropsValid: input.isPropsValid || null,
    externalDefTransforms: input.externalDefTransforms || [],
    viewContainerAppends: input.viewContainerAppends || [],
    eventDropTransformers: input.eventDropTransformers || [],
    componentInteractions: input.componentInteractions || [],
    calendarInteractions: input.calendarInteractions || [],
    themeClasses: input.themeClasses || {},
    eventSourceDefs: input.eventSourceDefs || [],
    cmdFormatter: input.cmdFormatter,
    recurringTypes: input.recurringTypes || [],
    namedTimeZonedImpl: input.namedTimeZonedImpl,
    initialView: input.initialView || "",
    elementDraggingImpl: input.elementDraggingImpl,
    optionChangeHandlers: input.optionChangeHandlers || {},
    scrollGridImpl: input.scrollGridImpl || null,
    listenerRefiners: input.listenerRefiners || {},
    optionRefiners: input.optionRefiners || {},
    propSetHandlers: input.propSetHandlers || {}
  };
}
function buildPluginHooks(pluginDefs, globalDefs) {
  let currentPluginIds = {};
  let hooks = {
    premiumReleaseDate: void 0,
    reducers: [],
    isLoadingFuncs: [],
    contextInit: [],
    eventRefiners: {},
    eventDefMemberAdders: [],
    eventSourceRefiners: {},
    isDraggableTransformers: [],
    eventDragMutationMassagers: [],
    eventDefMutationAppliers: [],
    dateSelectionTransformers: [],
    datePointTransforms: [],
    dateSpanTransforms: [],
    views: {},
    viewPropsTransformers: [],
    isPropsValid: null,
    externalDefTransforms: [],
    viewContainerAppends: [],
    eventDropTransformers: [],
    componentInteractions: [],
    calendarInteractions: [],
    themeClasses: {},
    eventSourceDefs: [],
    cmdFormatter: null,
    recurringTypes: [],
    namedTimeZonedImpl: null,
    initialView: "",
    elementDraggingImpl: null,
    optionChangeHandlers: {},
    scrollGridImpl: null,
    listenerRefiners: {},
    optionRefiners: {},
    propSetHandlers: {}
  };
  function addDefs(defs) {
    for (let def of defs) {
      const pluginName = def.name;
      const currentId = currentPluginIds[pluginName];
      if (currentId === void 0) {
        currentPluginIds[pluginName] = def.id;
        addDefs(def.deps);
        hooks = combineHooks(hooks, def);
      } else if (currentId !== def.id) {
        console.warn(`Duplicate plugin '${pluginName}'`);
      }
    }
  }
  if (pluginDefs) {
    addDefs(pluginDefs);
  }
  addDefs(globalDefs);
  return hooks;
}
function buildBuildPluginHooks() {
  let currentOverrideDefs = [];
  let currentGlobalDefs = [];
  let currentHooks;
  return (overrideDefs, globalDefs) => {
    if (!currentHooks || !isArraysEqual(overrideDefs, currentOverrideDefs) || !isArraysEqual(globalDefs, currentGlobalDefs)) {
      currentHooks = buildPluginHooks(overrideDefs, globalDefs);
    }
    currentOverrideDefs = overrideDefs;
    currentGlobalDefs = globalDefs;
    return currentHooks;
  };
}
function combineHooks(hooks0, hooks1) {
  return {
    premiumReleaseDate: compareOptionalDates(hooks0.premiumReleaseDate, hooks1.premiumReleaseDate),
    reducers: hooks0.reducers.concat(hooks1.reducers),
    isLoadingFuncs: hooks0.isLoadingFuncs.concat(hooks1.isLoadingFuncs),
    contextInit: hooks0.contextInit.concat(hooks1.contextInit),
    eventRefiners: Object.assign(Object.assign({}, hooks0.eventRefiners), hooks1.eventRefiners),
    eventDefMemberAdders: hooks0.eventDefMemberAdders.concat(hooks1.eventDefMemberAdders),
    eventSourceRefiners: Object.assign(Object.assign({}, hooks0.eventSourceRefiners), hooks1.eventSourceRefiners),
    isDraggableTransformers: hooks0.isDraggableTransformers.concat(hooks1.isDraggableTransformers),
    eventDragMutationMassagers: hooks0.eventDragMutationMassagers.concat(hooks1.eventDragMutationMassagers),
    eventDefMutationAppliers: hooks0.eventDefMutationAppliers.concat(hooks1.eventDefMutationAppliers),
    dateSelectionTransformers: hooks0.dateSelectionTransformers.concat(hooks1.dateSelectionTransformers),
    datePointTransforms: hooks0.datePointTransforms.concat(hooks1.datePointTransforms),
    dateSpanTransforms: hooks0.dateSpanTransforms.concat(hooks1.dateSpanTransforms),
    views: Object.assign(Object.assign({}, hooks0.views), hooks1.views),
    viewPropsTransformers: hooks0.viewPropsTransformers.concat(hooks1.viewPropsTransformers),
    isPropsValid: hooks1.isPropsValid || hooks0.isPropsValid,
    externalDefTransforms: hooks0.externalDefTransforms.concat(hooks1.externalDefTransforms),
    viewContainerAppends: hooks0.viewContainerAppends.concat(hooks1.viewContainerAppends),
    eventDropTransformers: hooks0.eventDropTransformers.concat(hooks1.eventDropTransformers),
    calendarInteractions: hooks0.calendarInteractions.concat(hooks1.calendarInteractions),
    componentInteractions: hooks0.componentInteractions.concat(hooks1.componentInteractions),
    themeClasses: Object.assign(Object.assign({}, hooks0.themeClasses), hooks1.themeClasses),
    eventSourceDefs: hooks0.eventSourceDefs.concat(hooks1.eventSourceDefs),
    cmdFormatter: hooks1.cmdFormatter || hooks0.cmdFormatter,
    recurringTypes: hooks0.recurringTypes.concat(hooks1.recurringTypes),
    namedTimeZonedImpl: hooks1.namedTimeZonedImpl || hooks0.namedTimeZonedImpl,
    initialView: hooks0.initialView || hooks1.initialView,
    elementDraggingImpl: hooks0.elementDraggingImpl || hooks1.elementDraggingImpl,
    optionChangeHandlers: Object.assign(Object.assign({}, hooks0.optionChangeHandlers), hooks1.optionChangeHandlers),
    scrollGridImpl: hooks1.scrollGridImpl || hooks0.scrollGridImpl,
    listenerRefiners: Object.assign(Object.assign({}, hooks0.listenerRefiners), hooks1.listenerRefiners),
    optionRefiners: Object.assign(Object.assign({}, hooks0.optionRefiners), hooks1.optionRefiners),
    propSetHandlers: Object.assign(Object.assign({}, hooks0.propSetHandlers), hooks1.propSetHandlers)
  };
}
function compareOptionalDates(date0, date1) {
  if (date0 === void 0) {
    return date1;
  }
  if (date1 === void 0) {
    return date0;
  }
  return new Date(Math.max(date0.valueOf(), date1.valueOf()));
}
var StandardTheme = class extends Theme {
};
StandardTheme.prototype.classes = {
  root: "fc-theme-standard",
  tableCellShaded: "fc-cell-shaded",
  buttonGroup: "fc-button-group",
  button: "fc-button fc-button-primary",
  buttonActive: "fc-button-active"
};
StandardTheme.prototype.baseIconClass = "fc-icon";
StandardTheme.prototype.iconClasses = {
  close: "fc-icon-x",
  prev: "fc-icon-chevron-left",
  next: "fc-icon-chevron-right",
  prevYear: "fc-icon-chevrons-left",
  nextYear: "fc-icon-chevrons-right"
};
StandardTheme.prototype.rtlIconClasses = {
  prev: "fc-icon-chevron-right",
  next: "fc-icon-chevron-left",
  prevYear: "fc-icon-chevrons-right",
  nextYear: "fc-icon-chevrons-left"
};
StandardTheme.prototype.iconOverrideOption = "buttonIcons";
StandardTheme.prototype.iconOverrideCustomButtonOption = "icon";
StandardTheme.prototype.iconOverridePrefix = "fc-icon-";
function compileViewDefs(defaultConfigs, overrideConfigs) {
  let hash = {};
  let viewType;
  for (viewType in defaultConfigs) {
    ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);
  }
  for (viewType in overrideConfigs) {
    ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);
  }
  return hash;
}
function ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs) {
  if (hash[viewType]) {
    return hash[viewType];
  }
  let viewDef = buildViewDef(viewType, hash, defaultConfigs, overrideConfigs);
  if (viewDef) {
    hash[viewType] = viewDef;
  }
  return viewDef;
}
function buildViewDef(viewType, hash, defaultConfigs, overrideConfigs) {
  let defaultConfig = defaultConfigs[viewType];
  let overrideConfig = overrideConfigs[viewType];
  let queryProp = (name) => defaultConfig && defaultConfig[name] !== null ? defaultConfig[name] : overrideConfig && overrideConfig[name] !== null ? overrideConfig[name] : null;
  let theComponent = queryProp("component");
  let superType = queryProp("superType");
  let superDef = null;
  if (superType) {
    if (superType === viewType) {
      throw new Error("Can't have a custom view type that references itself");
    }
    superDef = ensureViewDef(superType, hash, defaultConfigs, overrideConfigs);
  }
  if (!theComponent && superDef) {
    theComponent = superDef.component;
  }
  if (!theComponent) {
    return null;
  }
  return {
    type: viewType,
    component: theComponent,
    defaults: Object.assign(Object.assign({}, superDef ? superDef.defaults : {}), defaultConfig ? defaultConfig.rawOptions : {}),
    overrides: Object.assign(Object.assign({}, superDef ? superDef.overrides : {}), overrideConfig ? overrideConfig.rawOptions : {})
  };
}
function parseViewConfigs(inputs) {
  return mapHash(inputs, parseViewConfig);
}
function parseViewConfig(input) {
  let rawOptions = typeof input === "function" ? { component: input } : input;
  let { component } = rawOptions;
  if (rawOptions.content) {
    component = createViewHookComponent(rawOptions);
  } else if (component && !(component.prototype instanceof BaseComponent)) {
    component = createViewHookComponent(Object.assign(Object.assign({}, rawOptions), { content: component }));
  }
  return {
    superType: rawOptions.type,
    component,
    rawOptions
    // includes type and component too :(
  };
}
function createViewHookComponent(options) {
  return (viewProps) => y(ViewContextType.Consumer, null, (context) => y(ContentContainer, { elTag: "div", elClasses: buildViewClassNames(context.viewSpec), renderProps: Object.assign(Object.assign({}, viewProps), { nextDayThreshold: context.options.nextDayThreshold }), generatorName: void 0, customGenerator: options.content, classNameGenerator: options.classNames, didMount: options.didMount, willUnmount: options.willUnmount }));
}
function buildViewSpecs(defaultInputs, optionOverrides, dynamicOptionOverrides, localeDefaults) {
  let defaultConfigs = parseViewConfigs(defaultInputs);
  let overrideConfigs = parseViewConfigs(optionOverrides.views);
  let viewDefs = compileViewDefs(defaultConfigs, overrideConfigs);
  return mapHash(viewDefs, (viewDef) => buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults));
}
function buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults) {
  let durationInput = viewDef.overrides.duration || viewDef.defaults.duration || dynamicOptionOverrides.duration || optionOverrides.duration;
  let duration = null;
  let durationUnit = "";
  let singleUnit = "";
  let singleUnitOverrides = {};
  if (durationInput) {
    duration = createDurationCached(durationInput);
    if (duration) {
      let denom = greatestDurationDenominator(duration);
      durationUnit = denom.unit;
      if (denom.value === 1) {
        singleUnit = durationUnit;
        singleUnitOverrides = overrideConfigs[durationUnit] ? overrideConfigs[durationUnit].rawOptions : {};
      }
    }
  }
  let queryButtonText = (optionsSubset) => {
    let buttonTextMap = optionsSubset.buttonText || {};
    let buttonTextKey = viewDef.defaults.buttonTextKey;
    if (buttonTextKey != null && buttonTextMap[buttonTextKey] != null) {
      return buttonTextMap[buttonTextKey];
    }
    if (buttonTextMap[viewDef.type] != null) {
      return buttonTextMap[viewDef.type];
    }
    if (buttonTextMap[singleUnit] != null) {
      return buttonTextMap[singleUnit];
    }
    return null;
  };
  let queryButtonTitle = (optionsSubset) => {
    let buttonHints = optionsSubset.buttonHints || {};
    let buttonKey = viewDef.defaults.buttonTextKey;
    if (buttonKey != null && buttonHints[buttonKey] != null) {
      return buttonHints[buttonKey];
    }
    if (buttonHints[viewDef.type] != null) {
      return buttonHints[viewDef.type];
    }
    if (buttonHints[singleUnit] != null) {
      return buttonHints[singleUnit];
    }
    return null;
  };
  return {
    type: viewDef.type,
    component: viewDef.component,
    duration,
    durationUnit,
    singleUnit,
    optionDefaults: viewDef.defaults,
    optionOverrides: Object.assign(Object.assign({}, singleUnitOverrides), viewDef.overrides),
    buttonTextOverride: queryButtonText(dynamicOptionOverrides) || queryButtonText(optionOverrides) || // constructor-specified buttonText lookup hash takes precedence
    viewDef.overrides.buttonText,
    buttonTextDefault: queryButtonText(localeDefaults) || viewDef.defaults.buttonText || queryButtonText(BASE_OPTION_DEFAULTS) || viewDef.type,
    // not DRY
    buttonTitleOverride: queryButtonTitle(dynamicOptionOverrides) || queryButtonTitle(optionOverrides) || viewDef.overrides.buttonHint,
    buttonTitleDefault: queryButtonTitle(localeDefaults) || viewDef.defaults.buttonHint || queryButtonTitle(BASE_OPTION_DEFAULTS)
    // will eventually fall back to buttonText
  };
}
var durationInputMap = {};
function createDurationCached(durationInput) {
  let json = JSON.stringify(durationInput);
  let res = durationInputMap[json];
  if (res === void 0) {
    res = createDuration(durationInput);
    durationInputMap[json] = res;
  }
  return res;
}
function reduceViewType(viewType, action) {
  switch (action.type) {
    case "CHANGE_VIEW_TYPE":
      viewType = action.viewType;
  }
  return viewType;
}
function reduceDynamicOptionOverrides(dynamicOptionOverrides, action) {
  switch (action.type) {
    case "SET_OPTION":
      return Object.assign(Object.assign({}, dynamicOptionOverrides), { [action.optionName]: action.rawOptionValue });
    default:
      return dynamicOptionOverrides;
  }
}
function reduceDateProfile(currentDateProfile, action, currentDate, dateProfileGenerator) {
  let dp;
  switch (action.type) {
    case "CHANGE_VIEW_TYPE":
      return dateProfileGenerator.build(action.dateMarker || currentDate);
    case "CHANGE_DATE":
      return dateProfileGenerator.build(action.dateMarker);
    case "PREV":
      dp = dateProfileGenerator.buildPrev(currentDateProfile, currentDate);
      if (dp.isValid) {
        return dp;
      }
      break;
    case "NEXT":
      dp = dateProfileGenerator.buildNext(currentDateProfile, currentDate);
      if (dp.isValid) {
        return dp;
      }
      break;
  }
  return currentDateProfile;
}
function initEventSources(calendarOptions, dateProfile, context) {
  let activeRange = dateProfile ? dateProfile.activeRange : null;
  return addSources({}, parseInitialSources(calendarOptions, context), activeRange, context);
}
function reduceEventSources(eventSources, action, dateProfile, context) {
  let activeRange = dateProfile ? dateProfile.activeRange : null;
  switch (action.type) {
    case "ADD_EVENT_SOURCES":
      return addSources(eventSources, action.sources, activeRange, context);
    case "REMOVE_EVENT_SOURCE":
      return removeSource(eventSources, action.sourceId);
    case "PREV":
    case "NEXT":
    case "CHANGE_DATE":
    case "CHANGE_VIEW_TYPE":
      if (dateProfile) {
        return fetchDirtySources(eventSources, activeRange, context);
      }
      return eventSources;
    case "FETCH_EVENT_SOURCES":
      return fetchSourcesByIds(eventSources, action.sourceIds ? (
        // why no type?
        arrayToHash(action.sourceIds)
      ) : excludeStaticSources(eventSources, context), activeRange, action.isRefetch || false, context);
    case "RECEIVE_EVENTS":
    case "RECEIVE_EVENT_ERROR":
      return receiveResponse(eventSources, action.sourceId, action.fetchId, action.fetchRange);
    case "REMOVE_ALL_EVENT_SOURCES":
      return {};
    default:
      return eventSources;
  }
}
function reduceEventSourcesNewTimeZone(eventSources, dateProfile, context) {
  let activeRange = dateProfile ? dateProfile.activeRange : null;
  return fetchSourcesByIds(eventSources, excludeStaticSources(eventSources, context), activeRange, true, context);
}
function computeEventSourcesLoading(eventSources) {
  for (let sourceId in eventSources) {
    if (eventSources[sourceId].isFetching) {
      return true;
    }
  }
  return false;
}
function addSources(eventSourceHash, sources, fetchRange, context) {
  let hash = {};
  for (let source of sources) {
    hash[source.sourceId] = source;
  }
  if (fetchRange) {
    hash = fetchDirtySources(hash, fetchRange, context);
  }
  return Object.assign(Object.assign({}, eventSourceHash), hash);
}
function removeSource(eventSourceHash, sourceId) {
  return filterHash(eventSourceHash, (eventSource) => eventSource.sourceId !== sourceId);
}
function fetchDirtySources(sourceHash, fetchRange, context) {
  return fetchSourcesByIds(sourceHash, filterHash(sourceHash, (eventSource) => isSourceDirty(eventSource, fetchRange, context)), fetchRange, false, context);
}
function isSourceDirty(eventSource, fetchRange, context) {
  if (!doesSourceNeedRange(eventSource, context)) {
    return !eventSource.latestFetchId;
  }
  return !context.options.lazyFetching || !eventSource.fetchRange || eventSource.isFetching || // always cancel outdated in-progress fetches
  fetchRange.start < eventSource.fetchRange.start || fetchRange.end > eventSource.fetchRange.end;
}
function fetchSourcesByIds(prevSources, sourceIdHash, fetchRange, isRefetch, context) {
  let nextSources = {};
  for (let sourceId in prevSources) {
    let source = prevSources[sourceId];
    if (sourceIdHash[sourceId]) {
      nextSources[sourceId] = fetchSource(source, fetchRange, isRefetch, context);
    } else {
      nextSources[sourceId] = source;
    }
  }
  return nextSources;
}
function fetchSource(eventSource, fetchRange, isRefetch, context) {
  let { options, calendarApi } = context;
  let sourceDef = context.pluginHooks.eventSourceDefs[eventSource.sourceDefId];
  let fetchId = guid();
  sourceDef.fetch({
    eventSource,
    range: fetchRange,
    isRefetch,
    context
  }, (res) => {
    let { rawEvents } = res;
    if (options.eventSourceSuccess) {
      rawEvents = options.eventSourceSuccess.call(calendarApi, rawEvents, res.response) || rawEvents;
    }
    if (eventSource.success) {
      rawEvents = eventSource.success.call(calendarApi, rawEvents, res.response) || rawEvents;
    }
    context.dispatch({
      type: "RECEIVE_EVENTS",
      sourceId: eventSource.sourceId,
      fetchId,
      fetchRange,
      rawEvents
    });
  }, (error) => {
    let errorHandled = false;
    if (options.eventSourceFailure) {
      options.eventSourceFailure.call(calendarApi, error);
      errorHandled = true;
    }
    if (eventSource.failure) {
      eventSource.failure(error);
      errorHandled = true;
    }
    if (!errorHandled) {
      console.warn(error.message, error);
    }
    context.dispatch({
      type: "RECEIVE_EVENT_ERROR",
      sourceId: eventSource.sourceId,
      fetchId,
      fetchRange,
      error
    });
  });
  return Object.assign(Object.assign({}, eventSource), { isFetching: true, latestFetchId: fetchId });
}
function receiveResponse(sourceHash, sourceId, fetchId, fetchRange) {
  let eventSource = sourceHash[sourceId];
  if (eventSource && // not already removed
  fetchId === eventSource.latestFetchId) {
    return Object.assign(Object.assign({}, sourceHash), { [sourceId]: Object.assign(Object.assign({}, eventSource), { isFetching: false, fetchRange }) });
  }
  return sourceHash;
}
function excludeStaticSources(eventSources, context) {
  return filterHash(eventSources, (eventSource) => doesSourceNeedRange(eventSource, context));
}
function parseInitialSources(rawOptions, context) {
  let refiners = buildEventSourceRefiners(context);
  let rawSources = [].concat(rawOptions.eventSources || []);
  let sources = [];
  if (rawOptions.initialEvents) {
    rawSources.unshift(rawOptions.initialEvents);
  }
  if (rawOptions.events) {
    rawSources.unshift(rawOptions.events);
  }
  for (let rawSource of rawSources) {
    let source = parseEventSource(rawSource, context, refiners);
    if (source) {
      sources.push(source);
    }
  }
  return sources;
}
function doesSourceNeedRange(eventSource, context) {
  let defs = context.pluginHooks.eventSourceDefs;
  return !defs[eventSource.sourceDefId].ignoreRange;
}
function reduceDateSelection(currentSelection, action) {
  switch (action.type) {
    case "UNSELECT_DATES":
      return null;
    case "SELECT_DATES":
      return action.selection;
    default:
      return currentSelection;
  }
}
function reduceSelectedEvent(currentInstanceId, action) {
  switch (action.type) {
    case "UNSELECT_EVENT":
      return "";
    case "SELECT_EVENT":
      return action.eventInstanceId;
    default:
      return currentInstanceId;
  }
}
function reduceEventDrag(currentDrag, action) {
  let newDrag;
  switch (action.type) {
    case "UNSET_EVENT_DRAG":
      return null;
    case "SET_EVENT_DRAG":
      newDrag = action.state;
      return {
        affectedEvents: newDrag.affectedEvents,
        mutatedEvents: newDrag.mutatedEvents,
        isEvent: newDrag.isEvent
      };
    default:
      return currentDrag;
  }
}
function reduceEventResize(currentResize, action) {
  let newResize;
  switch (action.type) {
    case "UNSET_EVENT_RESIZE":
      return null;
    case "SET_EVENT_RESIZE":
      newResize = action.state;
      return {
        affectedEvents: newResize.affectedEvents,
        mutatedEvents: newResize.mutatedEvents,
        isEvent: newResize.isEvent
      };
    default:
      return currentResize;
  }
}
function parseToolbars(calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {
  let header = calendarOptions.headerToolbar ? parseToolbar(calendarOptions.headerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) : null;
  let footer = calendarOptions.footerToolbar ? parseToolbar(calendarOptions.footerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) : null;
  return { header, footer };
}
function parseToolbar(sectionStrHash, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {
  let sectionWidgets = {};
  let viewsWithButtons = [];
  let hasTitle = false;
  for (let sectionName in sectionStrHash) {
    let sectionStr = sectionStrHash[sectionName];
    let sectionRes = parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi);
    sectionWidgets[sectionName] = sectionRes.widgets;
    viewsWithButtons.push(...sectionRes.viewsWithButtons);
    hasTitle = hasTitle || sectionRes.hasTitle;
  }
  return { sectionWidgets, viewsWithButtons, hasTitle };
}
function parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {
  let isRtl = calendarOptions.direction === "rtl";
  let calendarCustomButtons = calendarOptions.customButtons || {};
  let calendarButtonTextOverrides = calendarOptionOverrides.buttonText || {};
  let calendarButtonText = calendarOptions.buttonText || {};
  let calendarButtonHintOverrides = calendarOptionOverrides.buttonHints || {};
  let calendarButtonHints = calendarOptions.buttonHints || {};
  let sectionSubstrs = sectionStr ? sectionStr.split(" ") : [];
  let viewsWithButtons = [];
  let hasTitle = false;
  let widgets = sectionSubstrs.map((buttonGroupStr) => buttonGroupStr.split(",").map((buttonName) => {
    if (buttonName === "title") {
      hasTitle = true;
      return { buttonName };
    }
    let customButtonProps;
    let viewSpec;
    let buttonClick;
    let buttonIcon;
    let buttonText;
    let buttonHint;
    if (customButtonProps = calendarCustomButtons[buttonName]) {
      buttonClick = (ev) => {
        if (customButtonProps.click) {
          customButtonProps.click.call(ev.target, ev, ev.target);
        }
      };
      (buttonIcon = theme.getCustomButtonIconClass(customButtonProps)) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = customButtonProps.text);
      buttonHint = customButtonProps.hint || customButtonProps.text;
    } else if (viewSpec = viewSpecs[buttonName]) {
      viewsWithButtons.push(buttonName);
      buttonClick = () => {
        calendarApi.changeView(buttonName);
      };
      (buttonText = viewSpec.buttonTextOverride) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = viewSpec.buttonTextDefault);
      let textFallback = viewSpec.buttonTextOverride || viewSpec.buttonTextDefault;
      buttonHint = formatWithOrdinals(
        viewSpec.buttonTitleOverride || viewSpec.buttonTitleDefault || calendarOptions.viewHint,
        [textFallback, buttonName],
        // view-name = buttonName
        textFallback
      );
    } else if (calendarApi[buttonName]) {
      buttonClick = () => {
        calendarApi[buttonName]();
      };
      (buttonText = calendarButtonTextOverrides[buttonName]) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = calendarButtonText[buttonName]);
      if (buttonName === "prevYear" || buttonName === "nextYear") {
        let prevOrNext = buttonName === "prevYear" ? "prev" : "next";
        buttonHint = formatWithOrdinals(calendarButtonHintOverrides[prevOrNext] || calendarButtonHints[prevOrNext], [
          calendarButtonText.year || "year",
          "year"
        ], calendarButtonText[buttonName]);
      } else {
        buttonHint = (navUnit) => formatWithOrdinals(calendarButtonHintOverrides[buttonName] || calendarButtonHints[buttonName], [
          calendarButtonText[navUnit] || navUnit,
          navUnit
        ], calendarButtonText[buttonName]);
      }
    }
    return { buttonName, buttonClick, buttonIcon, buttonText, buttonHint };
  }));
  return { widgets, viewsWithButtons, hasTitle };
}
var ViewImpl = class {
  constructor(type, getCurrentData, dateEnv) {
    this.type = type;
    this.getCurrentData = getCurrentData;
    this.dateEnv = dateEnv;
  }
  get calendar() {
    return this.getCurrentData().calendarApi;
  }
  get title() {
    return this.getCurrentData().viewTitle;
  }
  get activeStart() {
    return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.start);
  }
  get activeEnd() {
    return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.end);
  }
  get currentStart() {
    return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.start);
  }
  get currentEnd() {
    return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.end);
  }
  getOption(name) {
    return this.getCurrentData().options[name];
  }
};
var eventSourceDef$2 = {
  ignoreRange: true,
  parseMeta(refined) {
    if (Array.isArray(refined.events)) {
      return refined.events;
    }
    return null;
  },
  fetch(arg, successCallback) {
    successCallback({
      rawEvents: arg.eventSource.meta
    });
  }
};
var arrayEventSourcePlugin = createPlugin({
  name: "array-event-source",
  eventSourceDefs: [eventSourceDef$2]
});
var eventSourceDef$1 = {
  parseMeta(refined) {
    if (typeof refined.events === "function") {
      return refined.events;
    }
    return null;
  },
  fetch(arg, successCallback, errorCallback) {
    const { dateEnv } = arg.context;
    const func = arg.eventSource.meta;
    unpromisify(func.bind(null, buildRangeApiWithTimeZone(arg.range, dateEnv)), (rawEvents) => successCallback({ rawEvents }), errorCallback);
  }
};
var funcEventSourcePlugin = createPlugin({
  name: "func-event-source",
  eventSourceDefs: [eventSourceDef$1]
});
var JSON_FEED_EVENT_SOURCE_REFINERS = {
  method: String,
  extraParams: identity,
  startParam: String,
  endParam: String,
  timeZoneParam: String
};
var eventSourceDef = {
  parseMeta(refined) {
    if (refined.url && (refined.format === "json" || !refined.format)) {
      return {
        url: refined.url,
        format: "json",
        method: (refined.method || "GET").toUpperCase(),
        extraParams: refined.extraParams,
        startParam: refined.startParam,
        endParam: refined.endParam,
        timeZoneParam: refined.timeZoneParam
      };
    }
    return null;
  },
  fetch(arg, successCallback, errorCallback) {
    const { meta } = arg.eventSource;
    const requestParams = buildRequestParams(meta, arg.range, arg.context);
    requestJson(meta.method, meta.url, requestParams).then(([rawEvents, response]) => {
      successCallback({ rawEvents, response });
    }, errorCallback);
  }
};
var jsonFeedEventSourcePlugin = createPlugin({
  name: "json-event-source",
  eventSourceRefiners: JSON_FEED_EVENT_SOURCE_REFINERS,
  eventSourceDefs: [eventSourceDef]
});
function buildRequestParams(meta, range2, context) {
  let { dateEnv, options } = context;
  let startParam;
  let endParam;
  let timeZoneParam;
  let customRequestParams;
  let params = {};
  startParam = meta.startParam;
  if (startParam == null) {
    startParam = options.startParam;
  }
  endParam = meta.endParam;
  if (endParam == null) {
    endParam = options.endParam;
  }
  timeZoneParam = meta.timeZoneParam;
  if (timeZoneParam == null) {
    timeZoneParam = options.timeZoneParam;
  }
  if (typeof meta.extraParams === "function") {
    customRequestParams = meta.extraParams();
  } else {
    customRequestParams = meta.extraParams || {};
  }
  Object.assign(params, customRequestParams);
  params[startParam] = dateEnv.formatIso(range2.start);
  params[endParam] = dateEnv.formatIso(range2.end);
  if (dateEnv.timeZone !== "local") {
    params[timeZoneParam] = dateEnv.timeZone;
  }
  return params;
}
var SIMPLE_RECURRING_REFINERS = {
  daysOfWeek: identity,
  startTime: createDuration,
  endTime: createDuration,
  duration: createDuration,
  startRecur: identity,
  endRecur: identity
};
var recurring = {
  parse(refined, dateEnv) {
    if (refined.daysOfWeek || refined.startTime || refined.endTime || refined.startRecur || refined.endRecur) {
      let recurringData = {
        daysOfWeek: refined.daysOfWeek || null,
        startTime: refined.startTime || null,
        endTime: refined.endTime || null,
        startRecur: refined.startRecur ? dateEnv.createMarker(refined.startRecur) : null,
        endRecur: refined.endRecur ? dateEnv.createMarker(refined.endRecur) : null
      };
      let duration;
      if (refined.duration) {
        duration = refined.duration;
      }
      if (!duration && refined.startTime && refined.endTime) {
        duration = subtractDurations(refined.endTime, refined.startTime);
      }
      return {
        allDayGuess: Boolean(!refined.startTime && !refined.endTime),
        duration,
        typeData: recurringData
        // doesn't need endTime anymore but oh well
      };
    }
    return null;
  },
  expand(typeData, framingRange, dateEnv) {
    let clippedFramingRange = intersectRanges(framingRange, { start: typeData.startRecur, end: typeData.endRecur });
    if (clippedFramingRange) {
      return expandRanges(typeData.daysOfWeek, typeData.startTime, clippedFramingRange, dateEnv);
    }
    return [];
  }
};
var simpleRecurringEventsPlugin = createPlugin({
  name: "simple-recurring-event",
  recurringTypes: [recurring],
  eventRefiners: SIMPLE_RECURRING_REFINERS
});
function expandRanges(daysOfWeek2, startTime, framingRange, dateEnv) {
  let dowHash = daysOfWeek2 ? arrayToHash(daysOfWeek2) : null;
  let dayMarker = startOfDay(framingRange.start);
  let endMarker = framingRange.end;
  let instanceStarts = [];
  while (dayMarker < endMarker) {
    let instanceStart;
    if (!dowHash || dowHash[dayMarker.getUTCDay()]) {
      if (startTime) {
        instanceStart = dateEnv.add(dayMarker, startTime);
      } else {
        instanceStart = dayMarker;
      }
      instanceStarts.push(instanceStart);
    }
    dayMarker = addDays(dayMarker, 1);
  }
  return instanceStarts;
}
var changeHandlerPlugin = createPlugin({
  name: "change-handler",
  optionChangeHandlers: {
    events(events, context) {
      handleEventSources([events], context);
    },
    eventSources: handleEventSources
  }
});
function handleEventSources(inputs, context) {
  let unfoundSources = hashValuesToArray(context.getCurrentData().eventSources);
  if (unfoundSources.length === 1 && inputs.length === 1 && Array.isArray(unfoundSources[0]._raw) && Array.isArray(inputs[0])) {
    context.dispatch({
      type: "RESET_RAW_EVENTS",
      sourceId: unfoundSources[0].sourceId,
      rawEvents: inputs[0]
    });
    return;
  }
  let newInputs = [];
  for (let input of inputs) {
    let inputFound = false;
    for (let i3 = 0; i3 < unfoundSources.length; i3 += 1) {
      if (unfoundSources[i3]._raw === input) {
        unfoundSources.splice(i3, 1);
        inputFound = true;
        break;
      }
    }
    if (!inputFound) {
      newInputs.push(input);
    }
  }
  for (let unfoundSource of unfoundSources) {
    context.dispatch({
      type: "REMOVE_EVENT_SOURCE",
      sourceId: unfoundSource.sourceId
    });
  }
  for (let newInput of newInputs) {
    context.calendarApi.addEventSource(newInput);
  }
}
function handleDateProfile(dateProfile, context) {
  context.emitter.trigger("datesSet", Object.assign(Object.assign({}, buildRangeApiWithTimeZone(dateProfile.activeRange, context.dateEnv)), { view: context.viewApi }));
}
function handleEventStore(eventStore, context) {
  let { emitter } = context;
  if (emitter.hasHandlers("eventsSet")) {
    emitter.trigger("eventsSet", buildEventApis(eventStore, context));
  }
}
var globalPlugins = [
  arrayEventSourcePlugin,
  funcEventSourcePlugin,
  jsonFeedEventSourcePlugin,
  simpleRecurringEventsPlugin,
  changeHandlerPlugin,
  createPlugin({
    name: "misc",
    isLoadingFuncs: [
      (state) => computeEventSourcesLoading(state.eventSources)
    ],
    propSetHandlers: {
      dateProfile: handleDateProfile,
      eventStore: handleEventStore
    }
  })
];
var TaskRunner = class {
  constructor(runTaskOption, drainedOption) {
    this.runTaskOption = runTaskOption;
    this.drainedOption = drainedOption;
    this.queue = [];
    this.delayedRunner = new DelayedRunner(this.drain.bind(this));
  }
  request(task, delay) {
    this.queue.push(task);
    this.delayedRunner.request(delay);
  }
  pause(scope) {
    this.delayedRunner.pause(scope);
  }
  resume(scope, force) {
    this.delayedRunner.resume(scope, force);
  }
  drain() {
    let { queue } = this;
    while (queue.length) {
      let completedTasks = [];
      let task;
      while (task = queue.shift()) {
        this.runTask(task);
        completedTasks.push(task);
      }
      this.drained(completedTasks);
    }
  }
  runTask(task) {
    if (this.runTaskOption) {
      this.runTaskOption(task);
    }
  }
  drained(completedTasks) {
    if (this.drainedOption) {
      this.drainedOption(completedTasks);
    }
  }
};
function buildTitle(dateProfile, viewOptions, dateEnv) {
  let range2;
  if (/^(year|month)$/.test(dateProfile.currentRangeUnit)) {
    range2 = dateProfile.currentRange;
  } else {
    range2 = dateProfile.activeRange;
  }
  return dateEnv.formatRange(range2.start, range2.end, createFormatter(viewOptions.titleFormat || buildTitleFormat(dateProfile)), {
    isEndExclusive: dateProfile.isRangeAllDay,
    defaultSeparator: viewOptions.titleRangeSeparator
  });
}
function buildTitleFormat(dateProfile) {
  let { currentRangeUnit } = dateProfile;
  if (currentRangeUnit === "year") {
    return { year: "numeric" };
  }
  if (currentRangeUnit === "month") {
    return { year: "numeric", month: "long" };
  }
  let days = diffWholeDays(dateProfile.currentRange.start, dateProfile.currentRange.end);
  if (days !== null && days > 1) {
    return { year: "numeric", month: "short", day: "numeric" };
  }
  return { year: "numeric", month: "long", day: "numeric" };
}
var CalendarDataManager = class {
  constructor(props) {
    this.computeCurrentViewData = memoize(this._computeCurrentViewData);
    this.organizeRawLocales = memoize(organizeRawLocales);
    this.buildLocale = memoize(buildLocale);
    this.buildPluginHooks = buildBuildPluginHooks();
    this.buildDateEnv = memoize(buildDateEnv$1);
    this.buildTheme = memoize(buildTheme);
    this.parseToolbars = memoize(parseToolbars);
    this.buildViewSpecs = memoize(buildViewSpecs);
    this.buildDateProfileGenerator = memoizeObjArg(buildDateProfileGenerator);
    this.buildViewApi = memoize(buildViewApi);
    this.buildViewUiProps = memoizeObjArg(buildViewUiProps);
    this.buildEventUiBySource = memoize(buildEventUiBySource, isPropsEqual);
    this.buildEventUiBases = memoize(buildEventUiBases);
    this.parseContextBusinessHours = memoizeObjArg(parseContextBusinessHours);
    this.buildTitle = memoize(buildTitle);
    this.emitter = new Emitter();
    this.actionRunner = new TaskRunner(this._handleAction.bind(this), this.updateData.bind(this));
    this.currentCalendarOptionsInput = {};
    this.currentCalendarOptionsRefined = {};
    this.currentViewOptionsInput = {};
    this.currentViewOptionsRefined = {};
    this.currentCalendarOptionsRefiners = {};
    this.optionsForRefining = [];
    this.optionsForHandling = [];
    this.getCurrentData = () => this.data;
    this.dispatch = (action) => {
      this.actionRunner.request(action);
    };
    this.props = props;
    this.actionRunner.pause();
    let dynamicOptionOverrides = {};
    let optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);
    let currentViewType = optionsData.calendarOptions.initialView || optionsData.pluginHooks.initialView;
    let currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides);
    props.calendarApi.currentDataManager = this;
    this.emitter.setThisContext(props.calendarApi);
    this.emitter.setOptions(currentViewData.options);
    let currentDate = getInitialDate(optionsData.calendarOptions, optionsData.dateEnv);
    let dateProfile = currentViewData.dateProfileGenerator.build(currentDate);
    if (!rangeContainsMarker(dateProfile.activeRange, currentDate)) {
      currentDate = dateProfile.currentRange.start;
    }
    let calendarContext = {
      dateEnv: optionsData.dateEnv,
      options: optionsData.calendarOptions,
      pluginHooks: optionsData.pluginHooks,
      calendarApi: props.calendarApi,
      dispatch: this.dispatch,
      emitter: this.emitter,
      getCurrentData: this.getCurrentData
    };
    for (let callback of optionsData.pluginHooks.contextInit) {
      callback(calendarContext);
    }
    let eventSources = initEventSources(optionsData.calendarOptions, dateProfile, calendarContext);
    let initialState = {
      dynamicOptionOverrides,
      currentViewType,
      currentDate,
      dateProfile,
      businessHours: this.parseContextBusinessHours(calendarContext),
      eventSources,
      eventUiBases: {},
      eventStore: createEmptyEventStore(),
      renderableEventStore: createEmptyEventStore(),
      dateSelection: null,
      eventSelection: "",
      eventDrag: null,
      eventResize: null,
      selectionConfig: this.buildViewUiProps(calendarContext).selectionConfig
    };
    let contextAndState = Object.assign(Object.assign({}, calendarContext), initialState);
    for (let reducer of optionsData.pluginHooks.reducers) {
      Object.assign(initialState, reducer(null, null, contextAndState));
    }
    if (computeIsLoading(initialState, calendarContext)) {
      this.emitter.trigger("loading", true);
    }
    this.state = initialState;
    this.updateData();
    this.actionRunner.resume();
  }
  resetOptions(optionOverrides, changedOptionNames) {
    let { props } = this;
    if (changedOptionNames === void 0) {
      props.optionOverrides = optionOverrides;
    } else {
      props.optionOverrides = Object.assign(Object.assign({}, props.optionOverrides || {}), optionOverrides);
      this.optionsForRefining.push(...changedOptionNames);
    }
    if (changedOptionNames === void 0 || changedOptionNames.length) {
      this.actionRunner.request({
        type: "NOTHING"
      });
    }
  }
  _handleAction(action) {
    let { props, state, emitter } = this;
    let dynamicOptionOverrides = reduceDynamicOptionOverrides(state.dynamicOptionOverrides, action);
    let optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);
    let currentViewType = reduceViewType(state.currentViewType, action);
    let currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides);
    props.calendarApi.currentDataManager = this;
    emitter.setThisContext(props.calendarApi);
    emitter.setOptions(currentViewData.options);
    let calendarContext = {
      dateEnv: optionsData.dateEnv,
      options: optionsData.calendarOptions,
      pluginHooks: optionsData.pluginHooks,
      calendarApi: props.calendarApi,
      dispatch: this.dispatch,
      emitter,
      getCurrentData: this.getCurrentData
    };
    let { currentDate, dateProfile } = state;
    if (this.data && this.data.dateProfileGenerator !== currentViewData.dateProfileGenerator) {
      dateProfile = currentViewData.dateProfileGenerator.build(currentDate);
    }
    currentDate = reduceCurrentDate(currentDate, action);
    dateProfile = reduceDateProfile(dateProfile, action, currentDate, currentViewData.dateProfileGenerator);
    if (action.type === "PREV" || // TODO: move this logic into DateProfileGenerator
    action.type === "NEXT" || // "
    !rangeContainsMarker(dateProfile.currentRange, currentDate)) {
      currentDate = dateProfile.currentRange.start;
    }
    let eventSources = reduceEventSources(state.eventSources, action, dateProfile, calendarContext);
    let eventStore = reduceEventStore(state.eventStore, action, eventSources, dateProfile, calendarContext);
    let isEventsLoading = computeEventSourcesLoading(eventSources);
    let renderableEventStore = isEventsLoading && !currentViewData.options.progressiveEventRendering ? state.renderableEventStore || eventStore : (
      // try from previous state
      eventStore
    );
    let { eventUiSingleBase, selectionConfig } = this.buildViewUiProps(calendarContext);
    let eventUiBySource = this.buildEventUiBySource(eventSources);
    let eventUiBases = this.buildEventUiBases(renderableEventStore.defs, eventUiSingleBase, eventUiBySource);
    let newState = {
      dynamicOptionOverrides,
      currentViewType,
      currentDate,
      dateProfile,
      eventSources,
      eventStore,
      renderableEventStore,
      selectionConfig,
      eventUiBases,
      businessHours: this.parseContextBusinessHours(calendarContext),
      dateSelection: reduceDateSelection(state.dateSelection, action),
      eventSelection: reduceSelectedEvent(state.eventSelection, action),
      eventDrag: reduceEventDrag(state.eventDrag, action),
      eventResize: reduceEventResize(state.eventResize, action)
    };
    let contextAndState = Object.assign(Object.assign({}, calendarContext), newState);
    for (let reducer of optionsData.pluginHooks.reducers) {
      Object.assign(newState, reducer(state, action, contextAndState));
    }
    let wasLoading = computeIsLoading(state, calendarContext);
    let isLoading = computeIsLoading(newState, calendarContext);
    if (!wasLoading && isLoading) {
      emitter.trigger("loading", true);
    } else if (wasLoading && !isLoading) {
      emitter.trigger("loading", false);
    }
    this.state = newState;
    if (props.onAction) {
      props.onAction(action);
    }
  }
  updateData() {
    let { props, state } = this;
    let oldData = this.data;
    let optionsData = this.computeOptionsData(props.optionOverrides, state.dynamicOptionOverrides, props.calendarApi);
    let currentViewData = this.computeCurrentViewData(state.currentViewType, optionsData, props.optionOverrides, state.dynamicOptionOverrides);
    let data = this.data = Object.assign(Object.assign(Object.assign({ viewTitle: this.buildTitle(state.dateProfile, currentViewData.options, optionsData.dateEnv), calendarApi: props.calendarApi, dispatch: this.dispatch, emitter: this.emitter, getCurrentData: this.getCurrentData }, optionsData), currentViewData), state);
    let changeHandlers = optionsData.pluginHooks.optionChangeHandlers;
    let oldCalendarOptions = oldData && oldData.calendarOptions;
    let newCalendarOptions = optionsData.calendarOptions;
    if (oldCalendarOptions && oldCalendarOptions !== newCalendarOptions) {
      if (oldCalendarOptions.timeZone !== newCalendarOptions.timeZone) {
        state.eventSources = data.eventSources = reduceEventSourcesNewTimeZone(data.eventSources, state.dateProfile, data);
        state.eventStore = data.eventStore = rezoneEventStoreDates(data.eventStore, oldData.dateEnv, data.dateEnv);
        state.renderableEventStore = data.renderableEventStore = rezoneEventStoreDates(data.renderableEventStore, oldData.dateEnv, data.dateEnv);
      }
      for (let optionName in changeHandlers) {
        if (this.optionsForHandling.indexOf(optionName) !== -1 || oldCalendarOptions[optionName] !== newCalendarOptions[optionName]) {
          changeHandlers[optionName](newCalendarOptions[optionName], data);
        }
      }
    }
    this.optionsForHandling = [];
    if (props.onData) {
      props.onData(data);
    }
  }
  computeOptionsData(optionOverrides, dynamicOptionOverrides, calendarApi) {
    if (!this.optionsForRefining.length && optionOverrides === this.stableOptionOverrides && dynamicOptionOverrides === this.stableDynamicOptionOverrides) {
      return this.stableCalendarOptionsData;
    }
    let { refinedOptions, pluginHooks, localeDefaults, availableLocaleData, extra } = this.processRawCalendarOptions(optionOverrides, dynamicOptionOverrides);
    warnUnknownOptions(extra);
    let dateEnv = this.buildDateEnv(refinedOptions.timeZone, refinedOptions.locale, refinedOptions.weekNumberCalculation, refinedOptions.firstDay, refinedOptions.weekText, pluginHooks, availableLocaleData, refinedOptions.defaultRangeSeparator);
    let viewSpecs = this.buildViewSpecs(pluginHooks.views, this.stableOptionOverrides, this.stableDynamicOptionOverrides, localeDefaults);
    let theme = this.buildTheme(refinedOptions, pluginHooks);
    let toolbarConfig = this.parseToolbars(refinedOptions, this.stableOptionOverrides, theme, viewSpecs, calendarApi);
    return this.stableCalendarOptionsData = {
      calendarOptions: refinedOptions,
      pluginHooks,
      dateEnv,
      viewSpecs,
      theme,
      toolbarConfig,
      localeDefaults,
      availableRawLocales: availableLocaleData.map
    };
  }
  // always called from behind a memoizer
  processRawCalendarOptions(optionOverrides, dynamicOptionOverrides) {
    let { locales, locale } = mergeRawOptions([
      BASE_OPTION_DEFAULTS,
      optionOverrides,
      dynamicOptionOverrides
    ]);
    let availableLocaleData = this.organizeRawLocales(locales);
    let availableRawLocales = availableLocaleData.map;
    let localeDefaults = this.buildLocale(locale || availableLocaleData.defaultCode, availableRawLocales).options;
    let pluginHooks = this.buildPluginHooks(optionOverrides.plugins || [], globalPlugins);
    let refiners = this.currentCalendarOptionsRefiners = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);
    let extra = {};
    let raw = mergeRawOptions([
      BASE_OPTION_DEFAULTS,
      localeDefaults,
      optionOverrides,
      dynamicOptionOverrides
    ]);
    let refined = {};
    let currentRaw = this.currentCalendarOptionsInput;
    let currentRefined = this.currentCalendarOptionsRefined;
    let anyChanges = false;
    for (let optionName in raw) {
      if (this.optionsForRefining.indexOf(optionName) === -1 && (raw[optionName] === currentRaw[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && optionName in currentRaw && COMPLEX_OPTION_COMPARATORS[optionName](currentRaw[optionName], raw[optionName]))) {
        refined[optionName] = currentRefined[optionName];
      } else if (refiners[optionName]) {
        refined[optionName] = refiners[optionName](raw[optionName]);
        anyChanges = true;
      } else {
        extra[optionName] = currentRaw[optionName];
      }
    }
    if (anyChanges) {
      this.currentCalendarOptionsInput = raw;
      this.currentCalendarOptionsRefined = refined;
      this.stableOptionOverrides = optionOverrides;
      this.stableDynamicOptionOverrides = dynamicOptionOverrides;
    }
    this.optionsForHandling.push(...this.optionsForRefining);
    this.optionsForRefining = [];
    return {
      rawOptions: this.currentCalendarOptionsInput,
      refinedOptions: this.currentCalendarOptionsRefined,
      pluginHooks,
      availableLocaleData,
      localeDefaults,
      extra
    };
  }
  _computeCurrentViewData(viewType, optionsData, optionOverrides, dynamicOptionOverrides) {
    let viewSpec = optionsData.viewSpecs[viewType];
    if (!viewSpec) {
      throw new Error(`viewType "${viewType}" is not available. Please make sure you've loaded all neccessary plugins`);
    }
    let { refinedOptions, extra } = this.processRawViewOptions(viewSpec, optionsData.pluginHooks, optionsData.localeDefaults, optionOverrides, dynamicOptionOverrides);
    warnUnknownOptions(extra);
    let dateProfileGenerator = this.buildDateProfileGenerator({
      dateProfileGeneratorClass: viewSpec.optionDefaults.dateProfileGeneratorClass,
      duration: viewSpec.duration,
      durationUnit: viewSpec.durationUnit,
      usesMinMaxTime: viewSpec.optionDefaults.usesMinMaxTime,
      dateEnv: optionsData.dateEnv,
      calendarApi: this.props.calendarApi,
      slotMinTime: refinedOptions.slotMinTime,
      slotMaxTime: refinedOptions.slotMaxTime,
      showNonCurrentDates: refinedOptions.showNonCurrentDates,
      dayCount: refinedOptions.dayCount,
      dateAlignment: refinedOptions.dateAlignment,
      dateIncrement: refinedOptions.dateIncrement,
      hiddenDays: refinedOptions.hiddenDays,
      weekends: refinedOptions.weekends,
      nowInput: refinedOptions.now,
      validRangeInput: refinedOptions.validRange,
      visibleRangeInput: refinedOptions.visibleRange,
      fixedWeekCount: refinedOptions.fixedWeekCount
    });
    let viewApi = this.buildViewApi(viewType, this.getCurrentData, optionsData.dateEnv);
    return { viewSpec, options: refinedOptions, dateProfileGenerator, viewApi };
  }
  processRawViewOptions(viewSpec, pluginHooks, localeDefaults, optionOverrides, dynamicOptionOverrides) {
    let raw = mergeRawOptions([
      BASE_OPTION_DEFAULTS,
      viewSpec.optionDefaults,
      localeDefaults,
      optionOverrides,
      viewSpec.optionOverrides,
      dynamicOptionOverrides
    ]);
    let refiners = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), VIEW_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);
    let refined = {};
    let currentRaw = this.currentViewOptionsInput;
    let currentRefined = this.currentViewOptionsRefined;
    let anyChanges = false;
    let extra = {};
    for (let optionName in raw) {
      if (raw[optionName] === currentRaw[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && COMPLEX_OPTION_COMPARATORS[optionName](raw[optionName], currentRaw[optionName])) {
        refined[optionName] = currentRefined[optionName];
      } else {
        if (raw[optionName] === this.currentCalendarOptionsInput[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && COMPLEX_OPTION_COMPARATORS[optionName](raw[optionName], this.currentCalendarOptionsInput[optionName])) {
          if (optionName in this.currentCalendarOptionsRefined) {
            refined[optionName] = this.currentCalendarOptionsRefined[optionName];
          }
        } else if (refiners[optionName]) {
          refined[optionName] = refiners[optionName](raw[optionName]);
        } else {
          extra[optionName] = raw[optionName];
        }
        anyChanges = true;
      }
    }
    if (anyChanges) {
      this.currentViewOptionsInput = raw;
      this.currentViewOptionsRefined = refined;
    }
    return {
      rawOptions: this.currentViewOptionsInput,
      refinedOptions: this.currentViewOptionsRefined,
      extra
    };
  }
};
function buildDateEnv$1(timeZone, explicitLocale, weekNumberCalculation, firstDay, weekText, pluginHooks, availableLocaleData, defaultSeparator) {
  let locale = buildLocale(explicitLocale || availableLocaleData.defaultCode, availableLocaleData.map);
  return new DateEnv({
    calendarSystem: "gregory",
    timeZone,
    namedTimeZoneImpl: pluginHooks.namedTimeZonedImpl,
    locale,
    weekNumberCalculation,
    firstDay,
    weekText,
    cmdFormatter: pluginHooks.cmdFormatter,
    defaultSeparator
  });
}
function buildTheme(options, pluginHooks) {
  let ThemeClass = pluginHooks.themeClasses[options.themeSystem] || StandardTheme;
  return new ThemeClass(options);
}
function buildDateProfileGenerator(props) {
  let DateProfileGeneratorClass = props.dateProfileGeneratorClass || DateProfileGenerator;
  return new DateProfileGeneratorClass(props);
}
function buildViewApi(type, getCurrentData, dateEnv) {
  return new ViewImpl(type, getCurrentData, dateEnv);
}
function buildEventUiBySource(eventSources) {
  return mapHash(eventSources, (eventSource) => eventSource.ui);
}
function buildEventUiBases(eventDefs, eventUiSingleBase, eventUiBySource) {
  let eventUiBases = { "": eventUiSingleBase };
  for (let defId in eventDefs) {
    let def = eventDefs[defId];
    if (def.sourceId && eventUiBySource[def.sourceId]) {
      eventUiBases[defId] = eventUiBySource[def.sourceId];
    }
  }
  return eventUiBases;
}
function buildViewUiProps(calendarContext) {
  let { options } = calendarContext;
  return {
    eventUiSingleBase: createEventUi({
      display: options.eventDisplay,
      editable: options.editable,
      startEditable: options.eventStartEditable,
      durationEditable: options.eventDurationEditable,
      constraint: options.eventConstraint,
      overlap: typeof options.eventOverlap === "boolean" ? options.eventOverlap : void 0,
      allow: options.eventAllow,
      backgroundColor: options.eventBackgroundColor,
      borderColor: options.eventBorderColor,
      textColor: options.eventTextColor,
      color: options.eventColor
      // classNames: options.eventClassNames // render hook will handle this
    }, calendarContext),
    selectionConfig: createEventUi({
      constraint: options.selectConstraint,
      overlap: typeof options.selectOverlap === "boolean" ? options.selectOverlap : void 0,
      allow: options.selectAllow
    }, calendarContext)
  };
}
function computeIsLoading(state, context) {
  for (let isLoadingFunc of context.pluginHooks.isLoadingFuncs) {
    if (isLoadingFunc(state)) {
      return true;
    }
  }
  return false;
}
function parseContextBusinessHours(calendarContext) {
  return parseBusinessHours(calendarContext.options.businessHours, calendarContext);
}
function warnUnknownOptions(options, viewName) {
  for (let optionName in options) {
    console.warn(`Unknown option '${optionName}'` + (viewName ? ` for view '${viewName}'` : ""));
  }
}
var ToolbarSection = class extends BaseComponent {
  render() {
    let children = this.props.widgetGroups.map((widgetGroup) => this.renderWidgetGroup(widgetGroup));
    return y("div", { className: "fc-toolbar-chunk" }, ...children);
  }
  renderWidgetGroup(widgetGroup) {
    let { props } = this;
    let { theme } = this.context;
    let children = [];
    let isOnlyButtons = true;
    for (let widget of widgetGroup) {
      let { buttonName, buttonClick, buttonText, buttonIcon, buttonHint } = widget;
      if (buttonName === "title") {
        isOnlyButtons = false;
        children.push(y("h2", { className: "fc-toolbar-title", id: props.titleId }, props.title));
      } else {
        let isPressed = buttonName === props.activeButton;
        let isDisabled = !props.isTodayEnabled && buttonName === "today" || !props.isPrevEnabled && buttonName === "prev" || !props.isNextEnabled && buttonName === "next";
        let buttonClasses = [`fc-${buttonName}-button`, theme.getClass("button")];
        if (isPressed) {
          buttonClasses.push(theme.getClass("buttonActive"));
        }
        children.push(y("button", { type: "button", title: typeof buttonHint === "function" ? buttonHint(props.navUnit) : buttonHint, disabled: isDisabled, "aria-pressed": isPressed, className: buttonClasses.join(" "), onClick: buttonClick }, buttonText || (buttonIcon ? y("span", { className: buttonIcon, role: "img" }) : "")));
      }
    }
    if (children.length > 1) {
      let groupClassName = isOnlyButtons && theme.getClass("buttonGroup") || "";
      return y("div", { className: groupClassName }, ...children);
    }
    return children[0];
  }
};
var Toolbar = class extends BaseComponent {
  render() {
    let { model, extraClassName } = this.props;
    let forceLtr = false;
    let startContent;
    let endContent;
    let sectionWidgets = model.sectionWidgets;
    let centerContent = sectionWidgets.center;
    if (sectionWidgets.left) {
      forceLtr = true;
      startContent = sectionWidgets.left;
    } else {
      startContent = sectionWidgets.start;
    }
    if (sectionWidgets.right) {
      forceLtr = true;
      endContent = sectionWidgets.right;
    } else {
      endContent = sectionWidgets.end;
    }
    let classNames = [
      extraClassName || "",
      "fc-toolbar",
      forceLtr ? "fc-toolbar-ltr" : ""
    ];
    return y(
      "div",
      { className: classNames.join(" ") },
      this.renderSection("start", startContent || []),
      this.renderSection("center", centerContent || []),
      this.renderSection("end", endContent || [])
    );
  }
  renderSection(key, widgetGroups) {
    let { props } = this;
    return y(ToolbarSection, { key, widgetGroups, title: props.title, navUnit: props.navUnit, activeButton: props.activeButton, isTodayEnabled: props.isTodayEnabled, isPrevEnabled: props.isPrevEnabled, isNextEnabled: props.isNextEnabled, titleId: props.titleId });
  }
};
var ViewHarness = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.state = {
      availableWidth: null
    };
    this.handleEl = (el) => {
      this.el = el;
      setRef(this.props.elRef, el);
      this.updateAvailableWidth();
    };
    this.handleResize = () => {
      this.updateAvailableWidth();
    };
  }
  render() {
    let { props, state } = this;
    let { aspectRatio } = props;
    let classNames = [
      "fc-view-harness",
      aspectRatio || props.liquid || props.height ? "fc-view-harness-active" : "fc-view-harness-passive"
      // let the view do the height
    ];
    let height = "";
    let paddingBottom = "";
    if (aspectRatio) {
      if (state.availableWidth !== null) {
        height = state.availableWidth / aspectRatio;
      } else {
        paddingBottom = `${1 / aspectRatio * 100}%`;
      }
    } else {
      height = props.height || "";
    }
    return y("div", { "aria-labelledby": props.labeledById, ref: this.handleEl, className: classNames.join(" "), style: { height, paddingBottom } }, props.children);
  }
  componentDidMount() {
    this.context.addResizeHandler(this.handleResize);
  }
  componentWillUnmount() {
    this.context.removeResizeHandler(this.handleResize);
  }
  updateAvailableWidth() {
    if (this.el && // needed. but why?
    this.props.aspectRatio) {
      this.setState({ availableWidth: this.el.offsetWidth });
    }
  }
};
var EventClicking = class extends Interaction {
  constructor(settings) {
    super(settings);
    this.handleSegClick = (ev, segEl) => {
      let { component } = this;
      let { context } = component;
      let seg = getElSeg(segEl);
      if (seg && // might be the <div> surrounding the more link
      component.isValidSegDownEl(ev.target)) {
        let hasUrlContainer = elementClosest(ev.target, ".fc-event-forced-url");
        let url = hasUrlContainer ? hasUrlContainer.querySelector("a[href]").href : "";
        context.emitter.trigger("eventClick", {
          el: segEl,
          event: new EventImpl(component.context, seg.eventRange.def, seg.eventRange.instance),
          jsEvent: ev,
          view: context.viewApi
        });
        if (url && !ev.defaultPrevented) {
          window.location.href = url;
        }
      }
    };
    this.destroy = listenBySelector(
      settings.el,
      "click",
      ".fc-event",
      // on both fg and bg events
      this.handleSegClick
    );
  }
};
var EventHovering = class extends Interaction {
  constructor(settings) {
    super(settings);
    this.handleEventElRemove = (el) => {
      if (el === this.currentSegEl) {
        this.handleSegLeave(null, this.currentSegEl);
      }
    };
    this.handleSegEnter = (ev, segEl) => {
      if (getElSeg(segEl)) {
        this.currentSegEl = segEl;
        this.triggerEvent("eventMouseEnter", ev, segEl);
      }
    };
    this.handleSegLeave = (ev, segEl) => {
      if (this.currentSegEl) {
        this.currentSegEl = null;
        this.triggerEvent("eventMouseLeave", ev, segEl);
      }
    };
    this.removeHoverListeners = listenToHoverBySelector(
      settings.el,
      ".fc-event",
      // on both fg and bg events
      this.handleSegEnter,
      this.handleSegLeave
    );
  }
  destroy() {
    this.removeHoverListeners();
  }
  triggerEvent(publicEvName, ev, segEl) {
    let { component } = this;
    let { context } = component;
    let seg = getElSeg(segEl);
    if (!ev || component.isValidSegDownEl(ev.target)) {
      context.emitter.trigger(publicEvName, {
        el: segEl,
        event: new EventImpl(context, seg.eventRange.def, seg.eventRange.instance),
        jsEvent: ev,
        view: context.viewApi
      });
    }
  }
};
var CalendarContent = class extends PureComponent {
  constructor() {
    super(...arguments);
    this.buildViewContext = memoize(buildViewContext);
    this.buildViewPropTransformers = memoize(buildViewPropTransformers);
    this.buildToolbarProps = memoize(buildToolbarProps);
    this.headerRef = d();
    this.footerRef = d();
    this.interactionsStore = {};
    this.state = {
      viewLabelId: getUniqueDomId()
    };
    this.registerInteractiveComponent = (component, settingsInput) => {
      let settings = parseInteractionSettings(component, settingsInput);
      let DEFAULT_INTERACTIONS = [
        EventClicking,
        EventHovering
      ];
      let interactionClasses = DEFAULT_INTERACTIONS.concat(this.props.pluginHooks.componentInteractions);
      let interactions = interactionClasses.map((TheInteractionClass) => new TheInteractionClass(settings));
      this.interactionsStore[component.uid] = interactions;
      interactionSettingsStore[component.uid] = settings;
    };
    this.unregisterInteractiveComponent = (component) => {
      let listeners = this.interactionsStore[component.uid];
      if (listeners) {
        for (let listener of listeners) {
          listener.destroy();
        }
        delete this.interactionsStore[component.uid];
      }
      delete interactionSettingsStore[component.uid];
    };
    this.resizeRunner = new DelayedRunner(() => {
      this.props.emitter.trigger("_resize", true);
      this.props.emitter.trigger("windowResize", { view: this.props.viewApi });
    });
    this.handleWindowResize = (ev) => {
      let { options } = this.props;
      if (options.handleWindowResize && ev.target === window) {
        this.resizeRunner.request(options.windowResizeDelay);
      }
    };
  }
  /*
  renders INSIDE of an outer div
  */
  render() {
    let { props } = this;
    let { toolbarConfig, options } = props;
    let toolbarProps = this.buildToolbarProps(
      props.viewSpec,
      props.dateProfile,
      props.dateProfileGenerator,
      props.currentDate,
      getNow(props.options.now, props.dateEnv),
      // TODO: use NowTimer????
      props.viewTitle
    );
    let viewVGrow = false;
    let viewHeight = "";
    let viewAspectRatio;
    if (props.isHeightAuto || props.forPrint) {
      viewHeight = "";
    } else if (options.height != null) {
      viewVGrow = true;
    } else if (options.contentHeight != null) {
      viewHeight = options.contentHeight;
    } else {
      viewAspectRatio = Math.max(options.aspectRatio, 0.5);
    }
    let viewContext = this.buildViewContext(props.viewSpec, props.viewApi, props.options, props.dateProfileGenerator, props.dateEnv, props.theme, props.pluginHooks, props.dispatch, props.getCurrentData, props.emitter, props.calendarApi, this.registerInteractiveComponent, this.unregisterInteractiveComponent);
    let viewLabelId = toolbarConfig.header && toolbarConfig.header.hasTitle ? this.state.viewLabelId : void 0;
    return y(
      ViewContextType.Provider,
      { value: viewContext },
      toolbarConfig.header && y(Toolbar, Object.assign({ ref: this.headerRef, extraClassName: "fc-header-toolbar", model: toolbarConfig.header, titleId: viewLabelId }, toolbarProps)),
      y(
        ViewHarness,
        { liquid: viewVGrow, height: viewHeight, aspectRatio: viewAspectRatio, labeledById: viewLabelId },
        this.renderView(props),
        this.buildAppendContent()
      ),
      toolbarConfig.footer && y(Toolbar, Object.assign({ ref: this.footerRef, extraClassName: "fc-footer-toolbar", model: toolbarConfig.footer, titleId: "" }, toolbarProps))
    );
  }
  componentDidMount() {
    let { props } = this;
    this.calendarInteractions = props.pluginHooks.calendarInteractions.map((CalendarInteractionClass) => new CalendarInteractionClass(props));
    window.addEventListener("resize", this.handleWindowResize);
    let { propSetHandlers } = props.pluginHooks;
    for (let propName in propSetHandlers) {
      propSetHandlers[propName](props[propName], props);
    }
  }
  componentDidUpdate(prevProps) {
    let { props } = this;
    let { propSetHandlers } = props.pluginHooks;
    for (let propName in propSetHandlers) {
      if (props[propName] !== prevProps[propName]) {
        propSetHandlers[propName](props[propName], props);
      }
    }
  }
  componentWillUnmount() {
    window.removeEventListener("resize", this.handleWindowResize);
    this.resizeRunner.clear();
    for (let interaction of this.calendarInteractions) {
      interaction.destroy();
    }
    this.props.emitter.trigger("_unmount");
  }
  buildAppendContent() {
    let { props } = this;
    let children = props.pluginHooks.viewContainerAppends.map((buildAppendContent) => buildAppendContent(props));
    return y(_, {}, ...children);
  }
  renderView(props) {
    let { pluginHooks } = props;
    let { viewSpec } = props;
    let viewProps = {
      dateProfile: props.dateProfile,
      businessHours: props.businessHours,
      eventStore: props.renderableEventStore,
      eventUiBases: props.eventUiBases,
      dateSelection: props.dateSelection,
      eventSelection: props.eventSelection,
      eventDrag: props.eventDrag,
      eventResize: props.eventResize,
      isHeightAuto: props.isHeightAuto,
      forPrint: props.forPrint
    };
    let transformers = this.buildViewPropTransformers(pluginHooks.viewPropsTransformers);
    for (let transformer of transformers) {
      Object.assign(viewProps, transformer.transform(viewProps, props));
    }
    let ViewComponent = viewSpec.component;
    return y(ViewComponent, Object.assign({}, viewProps));
  }
};
function buildToolbarProps(viewSpec, dateProfile, dateProfileGenerator, currentDate, now, title) {
  let todayInfo = dateProfileGenerator.build(now, void 0, false);
  let prevInfo = dateProfileGenerator.buildPrev(dateProfile, currentDate, false);
  let nextInfo = dateProfileGenerator.buildNext(dateProfile, currentDate, false);
  return {
    title,
    activeButton: viewSpec.type,
    navUnit: viewSpec.singleUnit,
    isTodayEnabled: todayInfo.isValid && !rangeContainsMarker(dateProfile.currentRange, now),
    isPrevEnabled: prevInfo.isValid,
    isNextEnabled: nextInfo.isValid
  };
}
function buildViewPropTransformers(theClasses) {
  return theClasses.map((TheClass) => new TheClass());
}
var Calendar = class extends CalendarImpl {
  constructor(el, optionOverrides = {}) {
    super();
    this.isRendering = false;
    this.isRendered = false;
    this.currentClassNames = [];
    this.customContentRenderId = 0;
    this.handleAction = (action) => {
      switch (action.type) {
        case "SET_EVENT_DRAG":
        case "SET_EVENT_RESIZE":
          this.renderRunner.tryDrain();
      }
    };
    this.handleData = (data) => {
      this.currentData = data;
      this.renderRunner.request(data.calendarOptions.rerenderDelay);
    };
    this.handleRenderRequest = () => {
      if (this.isRendering) {
        this.isRendered = true;
        let { currentData } = this;
        flushSync(() => {
          D(y(CalendarRoot, { options: currentData.calendarOptions, theme: currentData.theme, emitter: currentData.emitter }, (classNames, height, isHeightAuto, forPrint) => {
            this.setClassNames(classNames);
            this.setHeight(height);
            return y(
              RenderId.Provider,
              { value: this.customContentRenderId },
              y(CalendarContent, Object.assign({ isHeightAuto, forPrint }, currentData))
            );
          }), this.el);
        });
      } else if (this.isRendered) {
        this.isRendered = false;
        D(null, this.el);
        this.setClassNames([]);
        this.setHeight("");
      }
    };
    ensureElHasStyles(el);
    this.el = el;
    this.renderRunner = new DelayedRunner(this.handleRenderRequest);
    new CalendarDataManager({
      optionOverrides,
      calendarApi: this,
      onAction: this.handleAction,
      onData: this.handleData
    });
  }
  render() {
    let wasRendering = this.isRendering;
    if (!wasRendering) {
      this.isRendering = true;
    } else {
      this.customContentRenderId += 1;
    }
    this.renderRunner.request();
    if (wasRendering) {
      this.updateSize();
    }
  }
  destroy() {
    if (this.isRendering) {
      this.isRendering = false;
      this.renderRunner.request();
    }
  }
  updateSize() {
    flushSync(() => {
      super.updateSize();
    });
  }
  batchRendering(func) {
    this.renderRunner.pause("batchRendering");
    func();
    this.renderRunner.resume("batchRendering");
  }
  pauseRendering() {
    this.renderRunner.pause("pauseRendering");
  }
  resumeRendering() {
    this.renderRunner.resume("pauseRendering", true);
  }
  resetOptions(optionOverrides, changedOptionNames) {
    this.currentDataManager.resetOptions(optionOverrides, changedOptionNames);
  }
  setClassNames(classNames) {
    if (!isArraysEqual(classNames, this.currentClassNames)) {
      let { classList } = this.el;
      for (let className of this.currentClassNames) {
        classList.remove(className);
      }
      for (let className of classNames) {
        classList.add(className);
      }
      this.currentClassNames = classNames;
    }
  }
  setHeight(height) {
    applyStyleProp(this.el, "height", height);
  }
};

// node_modules/@fullcalendar/daygrid/internal.js
var TableView = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.headerElRef = d();
  }
  renderSimpleLayout(headerRowContent, bodyContent) {
    let { props, context } = this;
    let sections = [];
    let stickyHeaderDates = getStickyHeaderDates(context.options);
    if (headerRowContent) {
      sections.push({
        type: "header",
        key: "header",
        isSticky: stickyHeaderDates,
        chunk: {
          elRef: this.headerElRef,
          tableClassName: "fc-col-header",
          rowContent: headerRowContent
        }
      });
    }
    sections.push({
      type: "body",
      key: "body",
      liquid: true,
      chunk: { content: bodyContent }
    });
    return y(
      ViewContainer,
      { elClasses: ["fc-daygrid"], viewSpec: context.viewSpec },
      y(SimpleScrollGrid, { liquid: !props.isHeightAuto && !props.forPrint, collapsibleWidth: props.forPrint, cols: [], sections })
    );
  }
  renderHScrollLayout(headerRowContent, bodyContent, colCnt, dayMinWidth) {
    let ScrollGrid = this.context.pluginHooks.scrollGridImpl;
    if (!ScrollGrid) {
      throw new Error("No ScrollGrid implementation");
    }
    let { props, context } = this;
    let stickyHeaderDates = !props.forPrint && getStickyHeaderDates(context.options);
    let stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(context.options);
    let sections = [];
    if (headerRowContent) {
      sections.push({
        type: "header",
        key: "header",
        isSticky: stickyHeaderDates,
        chunks: [{
          key: "main",
          elRef: this.headerElRef,
          tableClassName: "fc-col-header",
          rowContent: headerRowContent
        }]
      });
    }
    sections.push({
      type: "body",
      key: "body",
      liquid: true,
      chunks: [{
        key: "main",
        content: bodyContent
      }]
    });
    if (stickyFooterScrollbar) {
      sections.push({
        type: "footer",
        key: "footer",
        isSticky: true,
        chunks: [{
          key: "main",
          content: renderScrollShim
        }]
      });
    }
    return y(
      ViewContainer,
      { elClasses: ["fc-daygrid"], viewSpec: context.viewSpec },
      y(ScrollGrid, { liquid: !props.isHeightAuto && !props.forPrint, forPrint: props.forPrint, collapsibleWidth: props.forPrint, colGroups: [{ cols: [{ span: colCnt, minWidth: dayMinWidth }] }], sections })
    );
  }
};
function splitSegsByRow(segs, rowCnt) {
  let byRow = [];
  for (let i3 = 0; i3 < rowCnt; i3 += 1) {
    byRow[i3] = [];
  }
  for (let seg of segs) {
    byRow[seg.row].push(seg);
  }
  return byRow;
}
function splitSegsByFirstCol(segs, colCnt) {
  let byCol = [];
  for (let i3 = 0; i3 < colCnt; i3 += 1) {
    byCol[i3] = [];
  }
  for (let seg of segs) {
    byCol[seg.firstCol].push(seg);
  }
  return byCol;
}
function splitInteractionByRow(ui, rowCnt) {
  let byRow = [];
  if (!ui) {
    for (let i3 = 0; i3 < rowCnt; i3 += 1) {
      byRow[i3] = null;
    }
  } else {
    for (let i3 = 0; i3 < rowCnt; i3 += 1) {
      byRow[i3] = {
        affectedInstances: ui.affectedInstances,
        isEvent: ui.isEvent,
        segs: []
      };
    }
    for (let seg of ui.segs) {
      byRow[seg.row].segs.push(seg);
    }
  }
  return byRow;
}
var DEFAULT_TABLE_EVENT_TIME_FORMAT = createFormatter({
  hour: "numeric",
  minute: "2-digit",
  omitZeroMinute: true,
  meridiem: "narrow"
});
function hasListItemDisplay(seg) {
  let { display: display2 } = seg.eventRange.ui;
  return display2 === "list-item" || display2 === "auto" && !seg.eventRange.def.allDay && seg.firstCol === seg.lastCol && // can't be multi-day
  seg.isStart && // "
  seg.isEnd;
}
var TableBlockEvent = class extends BaseComponent {
  render() {
    let { props } = this;
    return y(StandardEvent, Object.assign({}, props, { elClasses: ["fc-daygrid-event", "fc-daygrid-block-event", "fc-h-event"], defaultTimeFormat: DEFAULT_TABLE_EVENT_TIME_FORMAT, defaultDisplayEventEnd: props.defaultDisplayEventEnd, disableResizing: !props.seg.eventRange.def.allDay }));
  }
};
var TableListItemEvent = class extends BaseComponent {
  render() {
    let { props, context } = this;
    let { options } = context;
    let { seg } = props;
    let timeFormat = options.eventTimeFormat || DEFAULT_TABLE_EVENT_TIME_FORMAT;
    let timeText = buildSegTimeText(seg, timeFormat, context, true, props.defaultDisplayEventEnd);
    return y(EventContainer, Object.assign({}, props, { elTag: "a", elClasses: ["fc-daygrid-event", "fc-daygrid-dot-event"], elAttrs: getSegAnchorAttrs(props.seg, context), defaultGenerator: renderInnerContent2, timeText, isResizing: false, isDateSelecting: false }));
  }
};
function renderInnerContent2(renderProps) {
  return y(
    _,
    null,
    y("div", { className: "fc-daygrid-event-dot", style: { borderColor: renderProps.borderColor || renderProps.backgroundColor } }),
    renderProps.timeText && y("div", { className: "fc-event-time" }, renderProps.timeText),
    y("div", { className: "fc-event-title" }, renderProps.event.title || y(_, null, "\xA0"))
  );
}
var TableCellMoreLink = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.compileSegs = memoize(compileSegs);
  }
  render() {
    let { props } = this;
    let { allSegs, invisibleSegs } = this.compileSegs(props.singlePlacements);
    return y(MoreLinkContainer, { elClasses: ["fc-daygrid-more-link"], dateProfile: props.dateProfile, todayRange: props.todayRange, allDayDate: props.allDayDate, moreCnt: props.moreCnt, allSegs, hiddenSegs: invisibleSegs, alignmentElRef: props.alignmentElRef, alignGridTop: props.alignGridTop, extraDateSpan: props.extraDateSpan, popoverContent: () => {
      let isForcedInvisible = (props.eventDrag ? props.eventDrag.affectedInstances : null) || (props.eventResize ? props.eventResize.affectedInstances : null) || {};
      return y(_, null, allSegs.map((seg) => {
        let instanceId = seg.eventRange.instance.instanceId;
        return y("div", { className: "fc-daygrid-event-harness", key: instanceId, style: {
          visibility: isForcedInvisible[instanceId] ? "hidden" : ""
        } }, hasListItemDisplay(seg) ? y(TableListItemEvent, Object.assign({ seg, isDragging: false, isSelected: instanceId === props.eventSelection, defaultDisplayEventEnd: false }, getSegMeta(seg, props.todayRange))) : y(TableBlockEvent, Object.assign({ seg, isDragging: false, isResizing: false, isDateSelecting: false, isSelected: instanceId === props.eventSelection, defaultDisplayEventEnd: false }, getSegMeta(seg, props.todayRange))));
      }));
    } });
  }
};
function compileSegs(singlePlacements) {
  let allSegs = [];
  let invisibleSegs = [];
  for (let placement of singlePlacements) {
    allSegs.push(placement.seg);
    if (!placement.isVisible) {
      invisibleSegs.push(placement.seg);
    }
  }
  return { allSegs, invisibleSegs };
}
var DEFAULT_WEEK_NUM_FORMAT = createFormatter({ week: "narrow" });
var TableCell = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.rootElRef = d();
    this.state = {
      dayNumberId: getUniqueDomId()
    };
    this.handleRootEl = (el) => {
      setRef(this.rootElRef, el);
      setRef(this.props.elRef, el);
    };
  }
  render() {
    let { context, props, state, rootElRef } = this;
    let { options, dateEnv } = context;
    let { date, dateProfile } = props;
    const isMonthStart = props.showDayNumber && shouldDisplayMonthStart(date, dateProfile.currentRange, dateEnv);
    return y(DayCellContainer, { elTag: "td", elRef: this.handleRootEl, elClasses: [
      "fc-daygrid-day",
      ...props.extraClassNames || []
    ], elAttrs: Object.assign(Object.assign(Object.assign({}, props.extraDataAttrs), props.showDayNumber ? { "aria-labelledby": state.dayNumberId } : {}), { role: "gridcell" }), defaultGenerator: renderTopInner, date, dateProfile, todayRange: props.todayRange, showDayNumber: props.showDayNumber, isMonthStart, extraRenderProps: props.extraRenderProps }, (InnerContent, renderProps) => y(
      "div",
      { ref: props.innerElRef, className: "fc-daygrid-day-frame fc-scrollgrid-sync-inner", style: { minHeight: props.minHeight } },
      props.showWeekNumber && y(WeekNumberContainer, { elTag: "a", elClasses: ["fc-daygrid-week-number"], elAttrs: buildNavLinkAttrs(context, date, "week"), date, defaultFormat: DEFAULT_WEEK_NUM_FORMAT }),
      !renderProps.isDisabled && (props.showDayNumber || hasCustomDayCellContent(options) || props.forceDayTop) ? y(
        "div",
        { className: "fc-daygrid-day-top" },
        y(InnerContent, { elTag: "a", elClasses: [
          "fc-daygrid-day-number",
          isMonthStart && "fc-daygrid-month-start"
        ], elAttrs: Object.assign(Object.assign({}, buildNavLinkAttrs(context, date)), { id: state.dayNumberId }) })
      ) : props.showDayNumber ? (
        // for creating correct amount of space (see issue #7162)
        y(
          "div",
          { className: "fc-daygrid-day-top", style: { visibility: "hidden" } },
          y("a", { className: "fc-daygrid-day-number" }, "\xA0")
        )
      ) : void 0,
      y(
        "div",
        { className: "fc-daygrid-day-events", ref: props.fgContentElRef },
        props.fgContent,
        y(
          "div",
          { className: "fc-daygrid-day-bottom", style: { marginTop: props.moreMarginTop } },
          y(TableCellMoreLink, { allDayDate: date, singlePlacements: props.singlePlacements, moreCnt: props.moreCnt, alignmentElRef: rootElRef, alignGridTop: !props.showDayNumber, extraDateSpan: props.extraDateSpan, dateProfile: props.dateProfile, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, todayRange: props.todayRange })
        )
      ),
      y("div", { className: "fc-daygrid-day-bg" }, props.bgContent)
    ));
  }
};
function renderTopInner(props) {
  return props.dayNumberText || y(_, null, "\xA0");
}
function shouldDisplayMonthStart(date, currentRange, dateEnv) {
  const { start: currentStart, end: currentEnd } = currentRange;
  const currentEndIncl = addMs(currentEnd, -1);
  const currentFirstYear = dateEnv.getYear(currentStart);
  const currentFirstMonth = dateEnv.getMonth(currentStart);
  const currentLastYear = dateEnv.getYear(currentEndIncl);
  const currentLastMonth = dateEnv.getMonth(currentEndIncl);
  return !(currentFirstYear === currentLastYear && currentFirstMonth === currentLastMonth) && Boolean(
    // first date in current view?
    date.valueOf() === currentStart.valueOf() || // a month-start that's within the current range?
    dateEnv.getDay(date) === 1 && date.valueOf() < currentEnd.valueOf()
  );
}
function generateSegKey(seg) {
  return seg.eventRange.instance.instanceId + ":" + seg.firstCol;
}
function generateSegUid(seg) {
  return generateSegKey(seg) + ":" + seg.lastCol;
}
function computeFgSegPlacement(segs, dayMaxEvents, dayMaxEventRows, strictOrder, segHeights, maxContentHeight, cells) {
  let hierarchy = new DayGridSegHierarchy((segEntry) => {
    let segUid = segs[segEntry.index].eventRange.instance.instanceId + ":" + segEntry.span.start + ":" + (segEntry.span.end - 1);
    return segHeights[segUid] || 1;
  });
  hierarchy.allowReslicing = true;
  hierarchy.strictOrder = strictOrder;
  if (dayMaxEvents === true || dayMaxEventRows === true) {
    hierarchy.maxCoord = maxContentHeight;
    hierarchy.hiddenConsumes = true;
  } else if (typeof dayMaxEvents === "number") {
    hierarchy.maxStackCnt = dayMaxEvents;
  } else if (typeof dayMaxEventRows === "number") {
    hierarchy.maxStackCnt = dayMaxEventRows;
    hierarchy.hiddenConsumes = true;
  }
  let segInputs = [];
  let unknownHeightSegs = [];
  for (let i3 = 0; i3 < segs.length; i3 += 1) {
    let seg = segs[i3];
    let segUid = generateSegUid(seg);
    let eventHeight = segHeights[segUid];
    if (eventHeight != null) {
      segInputs.push({
        index: i3,
        span: {
          start: seg.firstCol,
          end: seg.lastCol + 1
        }
      });
    } else {
      unknownHeightSegs.push(seg);
    }
  }
  let hiddenEntries = hierarchy.addSegs(segInputs);
  let segRects = hierarchy.toRects();
  let { singleColPlacements, multiColPlacements, leftoverMargins } = placeRects(segRects, segs, cells);
  let moreCnts = [];
  let moreMarginTops = [];
  for (let seg of unknownHeightSegs) {
    multiColPlacements[seg.firstCol].push({
      seg,
      isVisible: false,
      isAbsolute: true,
      absoluteTop: 0,
      marginTop: 0
    });
    for (let col = seg.firstCol; col <= seg.lastCol; col += 1) {
      singleColPlacements[col].push({
        seg: resliceSeg(seg, col, col + 1, cells),
        isVisible: false,
        isAbsolute: false,
        absoluteTop: 0,
        marginTop: 0
      });
    }
  }
  for (let col = 0; col < cells.length; col += 1) {
    moreCnts.push(0);
  }
  for (let hiddenEntry of hiddenEntries) {
    let seg = segs[hiddenEntry.index];
    let hiddenSpan = hiddenEntry.span;
    multiColPlacements[hiddenSpan.start].push({
      seg: resliceSeg(seg, hiddenSpan.start, hiddenSpan.end, cells),
      isVisible: false,
      isAbsolute: true,
      absoluteTop: 0,
      marginTop: 0
    });
    for (let col = hiddenSpan.start; col < hiddenSpan.end; col += 1) {
      moreCnts[col] += 1;
      singleColPlacements[col].push({
        seg: resliceSeg(seg, col, col + 1, cells),
        isVisible: false,
        isAbsolute: false,
        absoluteTop: 0,
        marginTop: 0
      });
    }
  }
  for (let col = 0; col < cells.length; col += 1) {
    moreMarginTops.push(leftoverMargins[col]);
  }
  return { singleColPlacements, multiColPlacements, moreCnts, moreMarginTops };
}
function placeRects(allRects, segs, cells) {
  let rectsByEachCol = groupRectsByEachCol(allRects, cells.length);
  let singleColPlacements = [];
  let multiColPlacements = [];
  let leftoverMargins = [];
  for (let col = 0; col < cells.length; col += 1) {
    let rects = rectsByEachCol[col];
    let singlePlacements = [];
    let currentHeight = 0;
    let currentMarginTop = 0;
    for (let rect of rects) {
      let seg = segs[rect.index];
      singlePlacements.push({
        seg: resliceSeg(seg, col, col + 1, cells),
        isVisible: true,
        isAbsolute: false,
        absoluteTop: rect.levelCoord,
        marginTop: rect.levelCoord - currentHeight
      });
      currentHeight = rect.levelCoord + rect.thickness;
    }
    let multiPlacements = [];
    currentHeight = 0;
    currentMarginTop = 0;
    for (let rect of rects) {
      let seg = segs[rect.index];
      let isAbsolute = rect.span.end - rect.span.start > 1;
      let isFirstCol = rect.span.start === col;
      currentMarginTop += rect.levelCoord - currentHeight;
      currentHeight = rect.levelCoord + rect.thickness;
      if (isAbsolute) {
        currentMarginTop += rect.thickness;
        if (isFirstCol) {
          multiPlacements.push({
            seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),
            isVisible: true,
            isAbsolute: true,
            absoluteTop: rect.levelCoord,
            marginTop: 0
          });
        }
      } else if (isFirstCol) {
        multiPlacements.push({
          seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),
          isVisible: true,
          isAbsolute: false,
          absoluteTop: rect.levelCoord,
          marginTop: currentMarginTop
          // claim the margin
        });
        currentMarginTop = 0;
      }
    }
    singleColPlacements.push(singlePlacements);
    multiColPlacements.push(multiPlacements);
    leftoverMargins.push(currentMarginTop);
  }
  return { singleColPlacements, multiColPlacements, leftoverMargins };
}
function groupRectsByEachCol(rects, colCnt) {
  let rectsByEachCol = [];
  for (let col = 0; col < colCnt; col += 1) {
    rectsByEachCol.push([]);
  }
  for (let rect of rects) {
    for (let col = rect.span.start; col < rect.span.end; col += 1) {
      rectsByEachCol[col].push(rect);
    }
  }
  return rectsByEachCol;
}
function resliceSeg(seg, spanStart, spanEnd, cells) {
  if (seg.firstCol === spanStart && seg.lastCol === spanEnd - 1) {
    return seg;
  }
  let eventRange = seg.eventRange;
  let origRange = eventRange.range;
  let slicedRange = intersectRanges(origRange, {
    start: cells[spanStart].date,
    end: addDays(cells[spanEnd - 1].date, 1)
  });
  return Object.assign(Object.assign({}, seg), { firstCol: spanStart, lastCol: spanEnd - 1, eventRange: {
    def: eventRange.def,
    ui: Object.assign(Object.assign({}, eventRange.ui), { durationEditable: false }),
    instance: eventRange.instance,
    range: slicedRange
  }, isStart: seg.isStart && slicedRange.start.valueOf() === origRange.start.valueOf(), isEnd: seg.isEnd && slicedRange.end.valueOf() === origRange.end.valueOf() });
}
var DayGridSegHierarchy = class extends SegHierarchy {
  constructor() {
    super(...arguments);
    this.hiddenConsumes = false;
    this.forceHidden = {};
  }
  addSegs(segInputs) {
    const hiddenSegs = super.addSegs(segInputs);
    const { entriesByLevel } = this;
    const excludeHidden = (entry) => !this.forceHidden[buildEntryKey(entry)];
    for (let level = 0; level < entriesByLevel.length; level += 1) {
      entriesByLevel[level] = entriesByLevel[level].filter(excludeHidden);
    }
    return hiddenSegs;
  }
  handleInvalidInsertion(insertion, entry, hiddenEntries) {
    const { entriesByLevel, forceHidden } = this;
    const { touchingEntry, touchingLevel, touchingLateral } = insertion;
    if (this.hiddenConsumes && touchingEntry) {
      const touchingEntryId = buildEntryKey(touchingEntry);
      if (!forceHidden[touchingEntryId]) {
        if (this.allowReslicing) {
          const hiddenEntry = Object.assign(Object.assign({}, touchingEntry), { span: intersectSpans(touchingEntry.span, entry.span) });
          const hiddenEntryId = buildEntryKey(hiddenEntry);
          forceHidden[hiddenEntryId] = true;
          entriesByLevel[touchingLevel][touchingLateral] = hiddenEntry;
          hiddenEntries.push(hiddenEntry);
          this.splitEntry(touchingEntry, entry, hiddenEntries);
        } else {
          forceHidden[touchingEntryId] = true;
          hiddenEntries.push(touchingEntry);
        }
      }
    }
    super.handleInvalidInsertion(insertion, entry, hiddenEntries);
  }
};
var TableRow = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.cellElRefs = new RefMap();
    this.frameElRefs = new RefMap();
    this.fgElRefs = new RefMap();
    this.segHarnessRefs = new RefMap();
    this.rootElRef = d();
    this.state = {
      framePositions: null,
      maxContentHeight: null,
      segHeights: {}
    };
    this.handleResize = (isForced) => {
      if (isForced) {
        this.updateSizing(true);
      }
    };
  }
  render() {
    let { props, state, context } = this;
    let { options } = context;
    let colCnt = props.cells.length;
    let businessHoursByCol = splitSegsByFirstCol(props.businessHourSegs, colCnt);
    let bgEventSegsByCol = splitSegsByFirstCol(props.bgEventSegs, colCnt);
    let highlightSegsByCol = splitSegsByFirstCol(this.getHighlightSegs(), colCnt);
    let mirrorSegsByCol = splitSegsByFirstCol(this.getMirrorSegs(), colCnt);
    let { singleColPlacements, multiColPlacements, moreCnts, moreMarginTops } = computeFgSegPlacement(sortEventSegs(props.fgEventSegs, options.eventOrder), props.dayMaxEvents, props.dayMaxEventRows, options.eventOrderStrict, state.segHeights, state.maxContentHeight, props.cells);
    let isForcedInvisible = (
      // TODO: messy way to compute this
      props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {}
    );
    return y(
      "tr",
      { ref: this.rootElRef, role: "row" },
      props.renderIntro && props.renderIntro(),
      props.cells.map((cell, col) => {
        let normalFgNodes = this.renderFgSegs(col, props.forPrint ? singleColPlacements[col] : multiColPlacements[col], props.todayRange, isForcedInvisible);
        let mirrorFgNodes = this.renderFgSegs(col, buildMirrorPlacements(mirrorSegsByCol[col], multiColPlacements), props.todayRange, {}, Boolean(props.eventDrag), Boolean(props.eventResize), false);
        return y(TableCell, { key: cell.key, elRef: this.cellElRefs.createRef(cell.key), innerElRef: this.frameElRefs.createRef(cell.key), dateProfile: props.dateProfile, date: cell.date, showDayNumber: props.showDayNumbers, showWeekNumber: props.showWeekNumbers && col === 0, forceDayTop: props.showWeekNumbers, todayRange: props.todayRange, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, extraRenderProps: cell.extraRenderProps, extraDataAttrs: cell.extraDataAttrs, extraClassNames: cell.extraClassNames, extraDateSpan: cell.extraDateSpan, moreCnt: moreCnts[col], moreMarginTop: moreMarginTops[col], singlePlacements: singleColPlacements[col], fgContentElRef: this.fgElRefs.createRef(cell.key), fgContent: (
          // Fragment scopes the keys
          y(
            _,
            null,
            y(_, null, normalFgNodes),
            y(_, null, mirrorFgNodes)
          )
        ), bgContent: (
          // Fragment scopes the keys
          y(
            _,
            null,
            this.renderFillSegs(highlightSegsByCol[col], "highlight"),
            this.renderFillSegs(businessHoursByCol[col], "non-business"),
            this.renderFillSegs(bgEventSegsByCol[col], "bg-event")
          )
        ), minHeight: props.cellMinHeight });
      })
    );
  }
  componentDidMount() {
    this.updateSizing(true);
    this.context.addResizeHandler(this.handleResize);
  }
  componentDidUpdate(prevProps, prevState) {
    let currentProps = this.props;
    this.updateSizing(!isPropsEqual(prevProps, currentProps));
  }
  componentWillUnmount() {
    this.context.removeResizeHandler(this.handleResize);
  }
  getHighlightSegs() {
    let { props } = this;
    if (props.eventDrag && props.eventDrag.segs.length) {
      return props.eventDrag.segs;
    }
    if (props.eventResize && props.eventResize.segs.length) {
      return props.eventResize.segs;
    }
    return props.dateSelectionSegs;
  }
  getMirrorSegs() {
    let { props } = this;
    if (props.eventResize && props.eventResize.segs.length) {
      return props.eventResize.segs;
    }
    return [];
  }
  renderFgSegs(col, segPlacements, todayRange, isForcedInvisible, isDragging, isResizing, isDateSelecting) {
    let { context } = this;
    let { eventSelection } = this.props;
    let { framePositions } = this.state;
    let defaultDisplayEventEnd = this.props.cells.length === 1;
    let isMirror = isDragging || isResizing || isDateSelecting;
    let nodes = [];
    if (framePositions) {
      for (let placement of segPlacements) {
        let { seg } = placement;
        let { instanceId } = seg.eventRange.instance;
        let isVisible = placement.isVisible && !isForcedInvisible[instanceId];
        let isAbsolute = placement.isAbsolute;
        let left = "";
        let right = "";
        if (isAbsolute) {
          if (context.isRtl) {
            right = 0;
            left = framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol];
          } else {
            left = 0;
            right = framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol];
          }
        }
        nodes.push(y("div", { className: "fc-daygrid-event-harness" + (isAbsolute ? " fc-daygrid-event-harness-abs" : ""), key: generateSegKey(seg), ref: isMirror ? null : this.segHarnessRefs.createRef(generateSegUid(seg)), style: {
          visibility: isVisible ? "" : "hidden",
          marginTop: isAbsolute ? "" : placement.marginTop,
          top: isAbsolute ? placement.absoluteTop : "",
          left,
          right
        } }, hasListItemDisplay(seg) ? y(TableListItemEvent, Object.assign({ seg, isDragging, isSelected: instanceId === eventSelection, defaultDisplayEventEnd }, getSegMeta(seg, todayRange))) : y(TableBlockEvent, Object.assign({ seg, isDragging, isResizing, isDateSelecting, isSelected: instanceId === eventSelection, defaultDisplayEventEnd }, getSegMeta(seg, todayRange)))));
      }
    }
    return nodes;
  }
  renderFillSegs(segs, fillType) {
    let { isRtl } = this.context;
    let { todayRange } = this.props;
    let { framePositions } = this.state;
    let nodes = [];
    if (framePositions) {
      for (let seg of segs) {
        let leftRightCss = isRtl ? {
          right: 0,
          left: framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol]
        } : {
          left: 0,
          right: framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol]
        };
        nodes.push(y("div", { key: buildEventRangeKey(seg.eventRange), className: "fc-daygrid-bg-harness", style: leftRightCss }, fillType === "bg-event" ? y(BgEvent, Object.assign({ seg }, getSegMeta(seg, todayRange))) : renderFill(fillType)));
      }
    }
    return y(_, {}, ...nodes);
  }
  updateSizing(isExternalSizingChange) {
    let { props, state, frameElRefs } = this;
    if (!props.forPrint && props.clientWidth !== null) {
      if (isExternalSizingChange) {
        let frameEls = props.cells.map((cell) => frameElRefs.currentMap[cell.key]);
        if (frameEls.length) {
          let originEl = this.rootElRef.current;
          let newPositionCache = new PositionCache(
            originEl,
            frameEls,
            true,
            // isHorizontal
            false
          );
          if (!state.framePositions || !state.framePositions.similarTo(newPositionCache)) {
            this.setState({
              framePositions: new PositionCache(
                originEl,
                frameEls,
                true,
                // isHorizontal
                false
              )
            });
          }
        }
      }
      const oldSegHeights = this.state.segHeights;
      const newSegHeights = this.querySegHeights();
      const limitByContentHeight = props.dayMaxEvents === true || props.dayMaxEventRows === true;
      this.safeSetState({
        // HACK to prevent oscillations of events being shown/hidden from max-event-rows
        // Essentially, once you compute an element's height, never null-out.
        // TODO: always display all events, as visibility:hidden?
        segHeights: Object.assign(Object.assign({}, oldSegHeights), newSegHeights),
        maxContentHeight: limitByContentHeight ? this.computeMaxContentHeight() : null
      });
    }
  }
  querySegHeights() {
    let segElMap = this.segHarnessRefs.currentMap;
    let segHeights = {};
    for (let segUid in segElMap) {
      let height = Math.round(segElMap[segUid].getBoundingClientRect().height);
      segHeights[segUid] = Math.max(segHeights[segUid] || 0, height);
    }
    return segHeights;
  }
  computeMaxContentHeight() {
    let firstKey = this.props.cells[0].key;
    let cellEl = this.cellElRefs.currentMap[firstKey];
    let fcContainerEl = this.fgElRefs.currentMap[firstKey];
    return cellEl.getBoundingClientRect().bottom - fcContainerEl.getBoundingClientRect().top;
  }
  getCellEls() {
    let elMap = this.cellElRefs.currentMap;
    return this.props.cells.map((cell) => elMap[cell.key]);
  }
};
TableRow.addStateEquality({
  segHeights: isPropsEqual
});
function buildMirrorPlacements(mirrorSegs, colPlacements) {
  if (!mirrorSegs.length) {
    return [];
  }
  let topsByInstanceId = buildAbsoluteTopHash(colPlacements);
  return mirrorSegs.map((seg) => ({
    seg,
    isVisible: true,
    isAbsolute: true,
    absoluteTop: topsByInstanceId[seg.eventRange.instance.instanceId],
    marginTop: 0
  }));
}
function buildAbsoluteTopHash(colPlacements) {
  let topsByInstanceId = {};
  for (let placements of colPlacements) {
    for (let placement of placements) {
      topsByInstanceId[placement.seg.eventRange.instance.instanceId] = placement.absoluteTop;
    }
  }
  return topsByInstanceId;
}
var TableRows = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.splitBusinessHourSegs = memoize(splitSegsByRow);
    this.splitBgEventSegs = memoize(splitSegsByRow);
    this.splitFgEventSegs = memoize(splitSegsByRow);
    this.splitDateSelectionSegs = memoize(splitSegsByRow);
    this.splitEventDrag = memoize(splitInteractionByRow);
    this.splitEventResize = memoize(splitInteractionByRow);
    this.rowRefs = new RefMap();
  }
  render() {
    let { props, context } = this;
    let rowCnt = props.cells.length;
    let businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, rowCnt);
    let bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, rowCnt);
    let fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, rowCnt);
    let dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, rowCnt);
    let eventDragByRow = this.splitEventDrag(props.eventDrag, rowCnt);
    let eventResizeByRow = this.splitEventResize(props.eventResize, rowCnt);
    let cellMinHeight = rowCnt >= 7 && props.clientWidth ? props.clientWidth / context.options.aspectRatio / 6 : null;
    return y(NowTimer, { unit: "day" }, (nowDate, todayRange) => y(_, null, props.cells.map((cells, row) => y(TableRow, {
      ref: this.rowRefs.createRef(row),
      key: cells.length ? cells[0].date.toISOString() : row,
      showDayNumbers: rowCnt > 1,
      showWeekNumbers: props.showWeekNumbers,
      todayRange,
      dateProfile: props.dateProfile,
      cells,
      renderIntro: props.renderRowIntro,
      businessHourSegs: businessHourSegsByRow[row],
      eventSelection: props.eventSelection,
      bgEventSegs: bgEventSegsByRow[row].filter(isSegAllDay),
      fgEventSegs: fgEventSegsByRow[row],
      dateSelectionSegs: dateSelectionSegsByRow[row],
      eventDrag: eventDragByRow[row],
      eventResize: eventResizeByRow[row],
      dayMaxEvents: props.dayMaxEvents,
      dayMaxEventRows: props.dayMaxEventRows,
      clientWidth: props.clientWidth,
      clientHeight: props.clientHeight,
      cellMinHeight,
      forPrint: props.forPrint
    }))));
  }
  componentDidMount() {
    this.registerInteractiveComponent();
  }
  componentDidUpdate() {
    this.registerInteractiveComponent();
  }
  registerInteractiveComponent() {
    if (!this.rootEl) {
      const firstCellEl = this.rowRefs.currentMap[0].getCellEls()[0];
      const rootEl = firstCellEl ? firstCellEl.closest(".fc-daygrid-body") : null;
      if (rootEl) {
        this.rootEl = rootEl;
        this.context.registerInteractiveComponent(this, {
          el: rootEl,
          isHitComboAllowed: this.props.isHitComboAllowed
        });
      }
    }
  }
  componentWillUnmount() {
    if (this.rootEl) {
      this.context.unregisterInteractiveComponent(this);
      this.rootEl = null;
    }
  }
  // Hit System
  // ----------------------------------------------------------------------------------------------------
  prepareHits() {
    this.rowPositions = new PositionCache(
      this.rootEl,
      this.rowRefs.collect().map((rowObj) => rowObj.getCellEls()[0]),
      // first cell el in each row. TODO: not optimal
      false,
      true
    );
    this.colPositions = new PositionCache(
      this.rootEl,
      this.rowRefs.currentMap[0].getCellEls(),
      // cell els in first row
      true,
      // horizontal
      false
    );
  }
  queryHit(positionLeft, positionTop) {
    let { colPositions, rowPositions } = this;
    let col = colPositions.leftToIndex(positionLeft);
    let row = rowPositions.topToIndex(positionTop);
    if (row != null && col != null) {
      let cell = this.props.cells[row][col];
      return {
        dateProfile: this.props.dateProfile,
        dateSpan: Object.assign({ range: this.getCellRange(row, col), allDay: true }, cell.extraDateSpan),
        dayEl: this.getCellEl(row, col),
        rect: {
          left: colPositions.lefts[col],
          right: colPositions.rights[col],
          top: rowPositions.tops[row],
          bottom: rowPositions.bottoms[row]
        },
        layer: 0
      };
    }
    return null;
  }
  getCellEl(row, col) {
    return this.rowRefs.currentMap[row].getCellEls()[col];
  }
  getCellRange(row, col) {
    let start = this.props.cells[row][col].date;
    let end = addDays(start, 1);
    return { start, end };
  }
};
function isSegAllDay(seg) {
  return seg.eventRange.def.allDay;
}
var Table = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.elRef = d();
    this.needsScrollReset = false;
  }
  render() {
    let { props } = this;
    let { dayMaxEventRows, dayMaxEvents, expandRows } = props;
    let limitViaBalanced = dayMaxEvents === true || dayMaxEventRows === true;
    if (limitViaBalanced && !expandRows) {
      limitViaBalanced = false;
      dayMaxEventRows = null;
      dayMaxEvents = null;
    }
    let classNames = [
      "fc-daygrid-body",
      limitViaBalanced ? "fc-daygrid-body-balanced" : "fc-daygrid-body-unbalanced",
      expandRows ? "" : "fc-daygrid-body-natural"
      // will height of one row depend on the others?
    ];
    return y(
      "div",
      { ref: this.elRef, className: classNames.join(" "), style: {
        // these props are important to give this wrapper correct dimensions for interactions
        // TODO: if we set it here, can we avoid giving to inner tables?
        width: props.clientWidth,
        minWidth: props.tableMinWidth
      } },
      y(
        "table",
        { role: "presentation", className: "fc-scrollgrid-sync-table", style: {
          width: props.clientWidth,
          minWidth: props.tableMinWidth,
          height: expandRows ? props.clientHeight : ""
        } },
        props.colGroupNode,
        y(
          "tbody",
          { role: "presentation" },
          y(TableRows, { dateProfile: props.dateProfile, cells: props.cells, renderRowIntro: props.renderRowIntro, showWeekNumbers: props.showWeekNumbers, clientWidth: props.clientWidth, clientHeight: props.clientHeight, businessHourSegs: props.businessHourSegs, bgEventSegs: props.bgEventSegs, fgEventSegs: props.fgEventSegs, dateSelectionSegs: props.dateSelectionSegs, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, dayMaxEvents, dayMaxEventRows, forPrint: props.forPrint, isHitComboAllowed: props.isHitComboAllowed })
        )
      )
    );
  }
  componentDidMount() {
    this.requestScrollReset();
  }
  componentDidUpdate(prevProps) {
    if (prevProps.dateProfile !== this.props.dateProfile) {
      this.requestScrollReset();
    } else {
      this.flushScrollReset();
    }
  }
  requestScrollReset() {
    this.needsScrollReset = true;
    this.flushScrollReset();
  }
  flushScrollReset() {
    if (this.needsScrollReset && this.props.clientWidth) {
      const subjectEl = getScrollSubjectEl(this.elRef.current, this.props.dateProfile);
      if (subjectEl) {
        const originEl = subjectEl.closest(".fc-daygrid-body");
        const scrollEl = originEl.closest(".fc-scroller");
        const scrollTop = subjectEl.getBoundingClientRect().top - originEl.getBoundingClientRect().top;
        scrollEl.scrollTop = scrollTop ? scrollTop + 1 : 0;
      }
      this.needsScrollReset = false;
    }
  }
};
function getScrollSubjectEl(containerEl, dateProfile) {
  let el;
  if (dateProfile.currentRangeUnit.match(/year|month/)) {
    el = containerEl.querySelector(`[data-date="${formatIsoMonthStr(dateProfile.currentDate)}-01"]`);
  }
  if (!el) {
    el = containerEl.querySelector(`[data-date="${formatDayString(dateProfile.currentDate)}"]`);
  }
  return el;
}
var DayTableSlicer = class extends Slicer {
  constructor() {
    super(...arguments);
    this.forceDayIfListItem = true;
  }
  sliceRange(dateRange, dayTableModel) {
    return dayTableModel.sliceRange(dateRange);
  }
};
var DayTable = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.slicer = new DayTableSlicer();
    this.tableRef = d();
  }
  render() {
    let { props, context } = this;
    return y(Table, Object.assign({ ref: this.tableRef }, this.slicer.sliceProps(props, props.dateProfile, props.nextDayThreshold, context, props.dayTableModel), { dateProfile: props.dateProfile, cells: props.dayTableModel.cells, colGroupNode: props.colGroupNode, tableMinWidth: props.tableMinWidth, renderRowIntro: props.renderRowIntro, dayMaxEvents: props.dayMaxEvents, dayMaxEventRows: props.dayMaxEventRows, showWeekNumbers: props.showWeekNumbers, expandRows: props.expandRows, headerAlignElRef: props.headerAlignElRef, clientWidth: props.clientWidth, clientHeight: props.clientHeight, forPrint: props.forPrint }));
  }
};
var DayTableView = class extends TableView {
  constructor() {
    super(...arguments);
    this.buildDayTableModel = memoize(buildDayTableModel);
    this.headerRef = d();
    this.tableRef = d();
  }
  render() {
    let { options, dateProfileGenerator } = this.context;
    let { props } = this;
    let dayTableModel = this.buildDayTableModel(props.dateProfile, dateProfileGenerator);
    let headerContent = options.dayHeaders && y(DayHeader, { ref: this.headerRef, dateProfile: props.dateProfile, dates: dayTableModel.headerDates, datesRepDistinctDays: dayTableModel.rowCnt === 1 });
    let bodyContent = (contentArg) => y(DayTable, { ref: this.tableRef, dateProfile: props.dateProfile, dayTableModel, businessHours: props.businessHours, dateSelection: props.dateSelection, eventStore: props.eventStore, eventUiBases: props.eventUiBases, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, nextDayThreshold: options.nextDayThreshold, colGroupNode: contentArg.tableColGroupNode, tableMinWidth: contentArg.tableMinWidth, dayMaxEvents: options.dayMaxEvents, dayMaxEventRows: options.dayMaxEventRows, showWeekNumbers: options.weekNumbers, expandRows: !props.isHeightAuto, headerAlignElRef: this.headerElRef, clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, forPrint: props.forPrint });
    return options.dayMinWidth ? this.renderHScrollLayout(headerContent, bodyContent, dayTableModel.colCnt, options.dayMinWidth) : this.renderSimpleLayout(headerContent, bodyContent);
  }
};
function buildDayTableModel(dateProfile, dateProfileGenerator) {
  let daySeries = new DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);
  return new DayTableModel(daySeries, /year|month|week/.test(dateProfile.currentRangeUnit));
}
var TableDateProfileGenerator = class extends DateProfileGenerator {
  // Computes the date range that will be rendered
  buildRenderRange(currentRange, currentRangeUnit, isRangeAllDay) {
    let renderRange = super.buildRenderRange(currentRange, currentRangeUnit, isRangeAllDay);
    let { props } = this;
    return buildDayTableRenderRange({
      currentRange: renderRange,
      snapToWeek: /^(year|month)$/.test(currentRangeUnit),
      fixedWeekCount: props.fixedWeekCount,
      dateEnv: props.dateEnv
    });
  }
};
function buildDayTableRenderRange(props) {
  let { dateEnv, currentRange } = props;
  let { start, end } = currentRange;
  let endOfWeek;
  if (props.snapToWeek) {
    start = dateEnv.startOfWeek(start);
    endOfWeek = dateEnv.startOfWeek(end);
    if (endOfWeek.valueOf() !== end.valueOf()) {
      end = addWeeks(endOfWeek, 1);
    }
  }
  if (props.fixedWeekCount) {
    let lastMonthRenderStart = dateEnv.startOfWeek(dateEnv.startOfMonth(addDays(currentRange.end, -1)));
    let rowCnt = Math.ceil(
      // could be partial weeks due to hiddenDays
      diffWeeks(lastMonthRenderStart, end)
    );
    end = addWeeks(end, 6 - rowCnt);
  }
  return { start, end };
}
var css_248z2 = ':root{--fc-daygrid-event-dot-width:8px}.fc-daygrid-day-events:after,.fc-daygrid-day-events:before,.fc-daygrid-day-frame:after,.fc-daygrid-day-frame:before,.fc-daygrid-event-harness:after,.fc-daygrid-event-harness:before{clear:both;content:"";display:table}.fc .fc-daygrid-body{position:relative;z-index:1}.fc .fc-daygrid-day.fc-day-today{background-color:var(--fc-today-bg-color)}.fc .fc-daygrid-day-frame{min-height:100%;position:relative}.fc .fc-daygrid-day-top{display:flex;flex-direction:row-reverse}.fc .fc-day-other .fc-daygrid-day-top{opacity:.3}.fc .fc-daygrid-day-number{padding:4px;position:relative;z-index:4}.fc .fc-daygrid-month-start{font-size:1.1em;font-weight:700}.fc .fc-daygrid-day-events{margin-top:1px}.fc .fc-daygrid-body-balanced .fc-daygrid-day-events{left:0;position:absolute;right:0}.fc .fc-daygrid-body-unbalanced .fc-daygrid-day-events{min-height:2em;position:relative}.fc .fc-daygrid-body-natural .fc-daygrid-day-events{margin-bottom:1em}.fc .fc-daygrid-event-harness{position:relative}.fc .fc-daygrid-event-harness-abs{left:0;position:absolute;right:0;top:0}.fc .fc-daygrid-bg-harness{bottom:0;position:absolute;top:0}.fc .fc-daygrid-day-bg .fc-non-business{z-index:1}.fc .fc-daygrid-day-bg .fc-bg-event{z-index:2}.fc .fc-daygrid-day-bg .fc-highlight{z-index:3}.fc .fc-daygrid-event{margin-top:1px;z-index:6}.fc .fc-daygrid-event.fc-event-mirror{z-index:7}.fc .fc-daygrid-day-bottom{font-size:.85em;margin:0 2px}.fc .fc-daygrid-day-bottom:after,.fc .fc-daygrid-day-bottom:before{clear:both;content:"";display:table}.fc .fc-daygrid-more-link{border-radius:3px;cursor:pointer;line-height:1;margin-top:1px;max-width:100%;overflow:hidden;padding:2px;position:relative;white-space:nowrap;z-index:4}.fc .fc-daygrid-more-link:hover{background-color:rgba(0,0,0,.1)}.fc .fc-daygrid-week-number{background-color:var(--fc-neutral-bg-color);color:var(--fc-neutral-text-color);min-width:1.5em;padding:2px;position:absolute;text-align:center;top:0;z-index:5}.fc .fc-more-popover .fc-popover-body{min-width:220px;padding:10px}.fc-direction-ltr .fc-daygrid-event.fc-event-start,.fc-direction-rtl .fc-daygrid-event.fc-event-end{margin-left:2px}.fc-direction-ltr .fc-daygrid-event.fc-event-end,.fc-direction-rtl .fc-daygrid-event.fc-event-start{margin-right:2px}.fc-direction-ltr .fc-daygrid-more-link{float:left}.fc-direction-ltr .fc-daygrid-week-number{border-radius:0 0 3px 0;left:0}.fc-direction-rtl .fc-daygrid-more-link{float:right}.fc-direction-rtl .fc-daygrid-week-number{border-radius:0 0 0 3px;right:0}.fc-liquid-hack .fc-daygrid-day-frame{position:static}.fc-daygrid-event{border-radius:3px;font-size:var(--fc-small-font-size);position:relative;white-space:nowrap}.fc-daygrid-block-event .fc-event-time{font-weight:700}.fc-daygrid-block-event .fc-event-time,.fc-daygrid-block-event .fc-event-title{padding:1px}.fc-daygrid-dot-event{align-items:center;display:flex;padding:2px 0}.fc-daygrid-dot-event .fc-event-title{flex-grow:1;flex-shrink:1;font-weight:700;min-width:0;overflow:hidden}.fc-daygrid-dot-event.fc-event-mirror,.fc-daygrid-dot-event:hover{background:rgba(0,0,0,.1)}.fc-daygrid-dot-event.fc-event-selected:before{bottom:-10px;top:-10px}.fc-daygrid-event-dot{border:calc(var(--fc-daygrid-event-dot-width)/2) solid var(--fc-event-border-color);border-radius:calc(var(--fc-daygrid-event-dot-width)/2);box-sizing:content-box;height:0;margin:0 4px;width:0}.fc-direction-ltr .fc-daygrid-event .fc-event-time{margin-right:3px}.fc-direction-rtl .fc-daygrid-event .fc-event-time{margin-left:3px}';
injectStyles(css_248z2);

// node_modules/@fullcalendar/daygrid/index.js
var index = createPlugin({
  name: "@fullcalendar/daygrid",
  initialView: "dayGridMonth",
  views: {
    dayGrid: {
      component: DayTableView,
      dateProfileGeneratorClass: TableDateProfileGenerator
    },
    dayGridDay: {
      type: "dayGrid",
      duration: { days: 1 }
    },
    dayGridWeek: {
      type: "dayGrid",
      duration: { weeks: 1 }
    },
    dayGridMonth: {
      type: "dayGrid",
      duration: { months: 1 },
      fixedWeekCount: true
    },
    dayGridYear: {
      type: "dayGrid",
      duration: { years: 1 }
    }
  }
});

// node_modules/@fullcalendar/timegrid/internal.js
var AllDaySplitter = class extends Splitter {
  getKeyInfo() {
    return {
      allDay: {},
      timed: {}
    };
  }
  getKeysForDateSpan(dateSpan) {
    if (dateSpan.allDay) {
      return ["allDay"];
    }
    return ["timed"];
  }
  getKeysForEventDef(eventDef) {
    if (!eventDef.allDay) {
      return ["timed"];
    }
    if (hasBgRendering(eventDef)) {
      return ["timed", "allDay"];
    }
    return ["allDay"];
  }
};
var DEFAULT_SLAT_LABEL_FORMAT = createFormatter({
  hour: "numeric",
  minute: "2-digit",
  omitZeroMinute: true,
  meridiem: "short"
});
function TimeColsAxisCell(props) {
  let classNames = [
    "fc-timegrid-slot",
    "fc-timegrid-slot-label",
    props.isLabeled ? "fc-scrollgrid-shrink" : "fc-timegrid-slot-minor"
  ];
  return y(ViewContextType.Consumer, null, (context) => {
    if (!props.isLabeled) {
      return y("td", { className: classNames.join(" "), "data-time": props.isoTimeStr });
    }
    let { dateEnv, options, viewApi } = context;
    let labelFormat = (
      // TODO: fully pre-parse
      options.slotLabelFormat == null ? DEFAULT_SLAT_LABEL_FORMAT : Array.isArray(options.slotLabelFormat) ? createFormatter(options.slotLabelFormat[0]) : createFormatter(options.slotLabelFormat)
    );
    let renderProps = {
      level: 0,
      time: props.time,
      date: dateEnv.toDate(props.date),
      view: viewApi,
      text: dateEnv.format(props.date, labelFormat)
    };
    return y(ContentContainer, { elTag: "td", elClasses: classNames, elAttrs: {
      "data-time": props.isoTimeStr
    }, renderProps, generatorName: "slotLabelContent", customGenerator: options.slotLabelContent, defaultGenerator: renderInnerContent3, classNameGenerator: options.slotLabelClassNames, didMount: options.slotLabelDidMount, willUnmount: options.slotLabelWillUnmount }, (InnerContent) => y(
      "div",
      { className: "fc-timegrid-slot-label-frame fc-scrollgrid-shrink-frame" },
      y(InnerContent, { elTag: "div", elClasses: [
        "fc-timegrid-slot-label-cushion",
        "fc-scrollgrid-shrink-cushion"
      ] })
    ));
  });
}
function renderInnerContent3(props) {
  return props.text;
}
var TimeBodyAxis = class extends BaseComponent {
  render() {
    return this.props.slatMetas.map((slatMeta) => y(
      "tr",
      { key: slatMeta.key },
      y(TimeColsAxisCell, Object.assign({}, slatMeta))
    ));
  }
};
var DEFAULT_WEEK_NUM_FORMAT2 = createFormatter({ week: "short" });
var AUTO_ALL_DAY_MAX_EVENT_ROWS = 5;
var TimeColsView = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.allDaySplitter = new AllDaySplitter();
    this.headerElRef = d();
    this.rootElRef = d();
    this.scrollerElRef = d();
    this.state = {
      slatCoords: null
    };
    this.handleScrollTopRequest = (scrollTop) => {
      let scrollerEl = this.scrollerElRef.current;
      if (scrollerEl) {
        scrollerEl.scrollTop = scrollTop;
      }
    };
    this.renderHeadAxis = (rowKey, frameHeight = "") => {
      let { options } = this.context;
      let { dateProfile } = this.props;
      let range2 = dateProfile.renderRange;
      let dayCnt = diffDays(range2.start, range2.end);
      let navLinkAttrs = dayCnt === 1 ? buildNavLinkAttrs(this.context, range2.start, "week") : {};
      if (options.weekNumbers && rowKey === "day") {
        return y(WeekNumberContainer, { elTag: "th", elClasses: [
          "fc-timegrid-axis",
          "fc-scrollgrid-shrink"
        ], elAttrs: {
          "aria-hidden": true
        }, date: range2.start, defaultFormat: DEFAULT_WEEK_NUM_FORMAT2 }, (InnerContent) => y(
          "div",
          { className: [
            "fc-timegrid-axis-frame",
            "fc-scrollgrid-shrink-frame",
            "fc-timegrid-axis-frame-liquid"
          ].join(" "), style: { height: frameHeight } },
          y(InnerContent, { elTag: "a", elClasses: [
            "fc-timegrid-axis-cushion",
            "fc-scrollgrid-shrink-cushion",
            "fc-scrollgrid-sync-inner"
          ], elAttrs: navLinkAttrs })
        ));
      }
      return y(
        "th",
        { "aria-hidden": true, className: "fc-timegrid-axis" },
        y("div", { className: "fc-timegrid-axis-frame", style: { height: frameHeight } })
      );
    };
    this.renderTableRowAxis = (rowHeight) => {
      let { options, viewApi } = this.context;
      let renderProps = {
        text: options.allDayText,
        view: viewApi
      };
      return (
        // TODO: make reusable hook. used in list view too
        y(ContentContainer, { elTag: "td", elClasses: [
          "fc-timegrid-axis",
          "fc-scrollgrid-shrink"
        ], elAttrs: {
          "aria-hidden": true
        }, renderProps, generatorName: "allDayContent", customGenerator: options.allDayContent, defaultGenerator: renderAllDayInner, classNameGenerator: options.allDayClassNames, didMount: options.allDayDidMount, willUnmount: options.allDayWillUnmount }, (InnerContent) => y(
          "div",
          { className: [
            "fc-timegrid-axis-frame",
            "fc-scrollgrid-shrink-frame",
            rowHeight == null ? " fc-timegrid-axis-frame-liquid" : ""
          ].join(" "), style: { height: rowHeight } },
          y(InnerContent, { elTag: "span", elClasses: [
            "fc-timegrid-axis-cushion",
            "fc-scrollgrid-shrink-cushion",
            "fc-scrollgrid-sync-inner"
          ] })
        ))
      );
    };
    this.handleSlatCoords = (slatCoords) => {
      this.setState({ slatCoords });
    };
  }
  // rendering
  // ----------------------------------------------------------------------------------------------------
  renderSimpleLayout(headerRowContent, allDayContent, timeContent) {
    let { context, props } = this;
    let sections = [];
    let stickyHeaderDates = getStickyHeaderDates(context.options);
    if (headerRowContent) {
      sections.push({
        type: "header",
        key: "header",
        isSticky: stickyHeaderDates,
        chunk: {
          elRef: this.headerElRef,
          tableClassName: "fc-col-header",
          rowContent: headerRowContent
        }
      });
    }
    if (allDayContent) {
      sections.push({
        type: "body",
        key: "all-day",
        chunk: { content: allDayContent }
      });
      sections.push({
        type: "body",
        key: "all-day-divider",
        outerContent: (
          // TODO: rename to cellContent so don't need to define <tr>?
          y(
            "tr",
            { role: "presentation", className: "fc-scrollgrid-section" },
            y("td", { className: "fc-timegrid-divider " + context.theme.getClass("tableCellShaded") })
          )
        )
      });
    }
    sections.push({
      type: "body",
      key: "body",
      liquid: true,
      expandRows: Boolean(context.options.expandRows),
      chunk: {
        scrollerElRef: this.scrollerElRef,
        content: timeContent
      }
    });
    return y(
      ViewContainer,
      { elRef: this.rootElRef, elClasses: ["fc-timegrid"], viewSpec: context.viewSpec },
      y(SimpleScrollGrid, { liquid: !props.isHeightAuto && !props.forPrint, collapsibleWidth: props.forPrint, cols: [{ width: "shrink" }], sections })
    );
  }
  renderHScrollLayout(headerRowContent, allDayContent, timeContent, colCnt, dayMinWidth, slatMetas, slatCoords) {
    let ScrollGrid = this.context.pluginHooks.scrollGridImpl;
    if (!ScrollGrid) {
      throw new Error("No ScrollGrid implementation");
    }
    let { context, props } = this;
    let stickyHeaderDates = !props.forPrint && getStickyHeaderDates(context.options);
    let stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(context.options);
    let sections = [];
    if (headerRowContent) {
      sections.push({
        type: "header",
        key: "header",
        isSticky: stickyHeaderDates,
        syncRowHeights: true,
        chunks: [
          {
            key: "axis",
            rowContent: (arg) => y("tr", { role: "presentation" }, this.renderHeadAxis("day", arg.rowSyncHeights[0]))
          },
          {
            key: "cols",
            elRef: this.headerElRef,
            tableClassName: "fc-col-header",
            rowContent: headerRowContent
          }
        ]
      });
    }
    if (allDayContent) {
      sections.push({
        type: "body",
        key: "all-day",
        syncRowHeights: true,
        chunks: [
          {
            key: "axis",
            rowContent: (contentArg) => y("tr", { role: "presentation" }, this.renderTableRowAxis(contentArg.rowSyncHeights[0]))
          },
          {
            key: "cols",
            content: allDayContent
          }
        ]
      });
      sections.push({
        key: "all-day-divider",
        type: "body",
        outerContent: (
          // TODO: rename to cellContent so don't need to define <tr>?
          y(
            "tr",
            { role: "presentation", className: "fc-scrollgrid-section" },
            y("td", { colSpan: 2, className: "fc-timegrid-divider " + context.theme.getClass("tableCellShaded") })
          )
        )
      });
    }
    let isNowIndicator = context.options.nowIndicator;
    sections.push({
      type: "body",
      key: "body",
      liquid: true,
      expandRows: Boolean(context.options.expandRows),
      chunks: [
        {
          key: "axis",
          content: (arg) => (
            // TODO: make this now-indicator arrow more DRY with TimeColsContent
            y(
              "div",
              { className: "fc-timegrid-axis-chunk" },
              y(
                "table",
                { "aria-hidden": true, style: { height: arg.expandRows ? arg.clientHeight : "" } },
                arg.tableColGroupNode,
                y(
                  "tbody",
                  null,
                  y(TimeBodyAxis, { slatMetas })
                )
              ),
              y(
                "div",
                { className: "fc-timegrid-now-indicator-container" },
                y(NowTimer, {
                  unit: isNowIndicator ? "minute" : "day"
                  /* hacky */
                }, (nowDate) => {
                  let nowIndicatorTop = isNowIndicator && slatCoords && slatCoords.safeComputeTop(nowDate);
                  if (typeof nowIndicatorTop === "number") {
                    return y(NowIndicatorContainer, { elClasses: ["fc-timegrid-now-indicator-arrow"], elStyle: { top: nowIndicatorTop }, isAxis: true, date: nowDate });
                  }
                  return null;
                })
              )
            )
          )
        },
        {
          key: "cols",
          scrollerElRef: this.scrollerElRef,
          content: timeContent
        }
      ]
    });
    if (stickyFooterScrollbar) {
      sections.push({
        key: "footer",
        type: "footer",
        isSticky: true,
        chunks: [
          {
            key: "axis",
            content: renderScrollShim
          },
          {
            key: "cols",
            content: renderScrollShim
          }
        ]
      });
    }
    return y(
      ViewContainer,
      { elRef: this.rootElRef, elClasses: ["fc-timegrid"], viewSpec: context.viewSpec },
      y(ScrollGrid, { liquid: !props.isHeightAuto && !props.forPrint, forPrint: props.forPrint, collapsibleWidth: false, colGroups: [
        { width: "shrink", cols: [{ width: "shrink" }] },
        { cols: [{ span: colCnt, minWidth: dayMinWidth }] }
      ], sections })
    );
  }
  /* Dimensions
  ------------------------------------------------------------------------------------------------------------------*/
  getAllDayMaxEventProps() {
    let { dayMaxEvents, dayMaxEventRows } = this.context.options;
    if (dayMaxEvents === true || dayMaxEventRows === true) {
      dayMaxEvents = void 0;
      dayMaxEventRows = AUTO_ALL_DAY_MAX_EVENT_ROWS;
    }
    return { dayMaxEvents, dayMaxEventRows };
  }
};
function renderAllDayInner(renderProps) {
  return renderProps.text;
}
var TimeColsSlatsCoords = class {
  constructor(positions, dateProfile, slotDuration) {
    this.positions = positions;
    this.dateProfile = dateProfile;
    this.slotDuration = slotDuration;
  }
  safeComputeTop(date) {
    let { dateProfile } = this;
    if (rangeContainsMarker(dateProfile.currentRange, date)) {
      let startOfDayDate = startOfDay(date);
      let timeMs = date.valueOf() - startOfDayDate.valueOf();
      if (timeMs >= asRoughMs(dateProfile.slotMinTime) && timeMs < asRoughMs(dateProfile.slotMaxTime)) {
        return this.computeTimeTop(createDuration(timeMs));
      }
    }
    return null;
  }
  // Computes the top coordinate, relative to the bounds of the grid, of the given date.
  // A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.
  computeDateTop(when, startOfDayDate) {
    if (!startOfDayDate) {
      startOfDayDate = startOfDay(when);
    }
    return this.computeTimeTop(createDuration(when.valueOf() - startOfDayDate.valueOf()));
  }
  // Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).
  // This is a makeshify way to compute the time-top. Assumes all slatMetas dates are uniform.
  // Eventually allow computation with arbirary slat dates.
  computeTimeTop(duration) {
    let { positions, dateProfile } = this;
    let len = positions.els.length;
    let slatCoverage = (duration.milliseconds - asRoughMs(dateProfile.slotMinTime)) / asRoughMs(this.slotDuration);
    let slatIndex;
    let slatRemainder;
    slatCoverage = Math.max(0, slatCoverage);
    slatCoverage = Math.min(len, slatCoverage);
    slatIndex = Math.floor(slatCoverage);
    slatIndex = Math.min(slatIndex, len - 1);
    slatRemainder = slatCoverage - slatIndex;
    return positions.tops[slatIndex] + positions.getHeight(slatIndex) * slatRemainder;
  }
};
var TimeColsSlatsBody = class extends BaseComponent {
  render() {
    let { props, context } = this;
    let { options } = context;
    let { slatElRefs } = props;
    return y("tbody", null, props.slatMetas.map((slatMeta, i3) => {
      let renderProps = {
        time: slatMeta.time,
        date: context.dateEnv.toDate(slatMeta.date),
        view: context.viewApi
      };
      return y(
        "tr",
        { key: slatMeta.key, ref: slatElRefs.createRef(slatMeta.key) },
        props.axis && y(TimeColsAxisCell, Object.assign({}, slatMeta)),
        y(ContentContainer, { elTag: "td", elClasses: [
          "fc-timegrid-slot",
          "fc-timegrid-slot-lane",
          !slatMeta.isLabeled && "fc-timegrid-slot-minor"
        ], elAttrs: {
          "data-time": slatMeta.isoTimeStr
        }, renderProps, generatorName: "slotLaneContent", customGenerator: options.slotLaneContent, classNameGenerator: options.slotLaneClassNames, didMount: options.slotLaneDidMount, willUnmount: options.slotLaneWillUnmount })
      );
    }));
  }
};
var TimeColsSlats = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.rootElRef = d();
    this.slatElRefs = new RefMap();
  }
  render() {
    let { props, context } = this;
    return y(
      "div",
      { ref: this.rootElRef, className: "fc-timegrid-slots" },
      y(
        "table",
        { "aria-hidden": true, className: context.theme.getClass("table"), style: {
          minWidth: props.tableMinWidth,
          width: props.clientWidth,
          height: props.minHeight
        } },
        props.tableColGroupNode,
        y(TimeColsSlatsBody, { slatElRefs: this.slatElRefs, axis: props.axis, slatMetas: props.slatMetas })
      )
    );
  }
  componentDidMount() {
    this.updateSizing();
  }
  componentDidUpdate() {
    this.updateSizing();
  }
  componentWillUnmount() {
    if (this.props.onCoords) {
      this.props.onCoords(null);
    }
  }
  updateSizing() {
    let { context, props } = this;
    if (props.onCoords && props.clientWidth !== null) {
      let rootEl = this.rootElRef.current;
      if (rootEl.offsetHeight) {
        props.onCoords(new TimeColsSlatsCoords(new PositionCache(this.rootElRef.current, collectSlatEls(this.slatElRefs.currentMap, props.slatMetas), false, true), this.props.dateProfile, context.options.slotDuration));
      }
    }
  }
};
function collectSlatEls(elMap, slatMetas) {
  return slatMetas.map((slatMeta) => elMap[slatMeta.key]);
}
function splitSegsByCol(segs, colCnt) {
  let segsByCol = [];
  let i3;
  for (i3 = 0; i3 < colCnt; i3 += 1) {
    segsByCol.push([]);
  }
  if (segs) {
    for (i3 = 0; i3 < segs.length; i3 += 1) {
      segsByCol[segs[i3].col].push(segs[i3]);
    }
  }
  return segsByCol;
}
function splitInteractionByCol(ui, colCnt) {
  let byRow = [];
  if (!ui) {
    for (let i3 = 0; i3 < colCnt; i3 += 1) {
      byRow[i3] = null;
    }
  } else {
    for (let i3 = 0; i3 < colCnt; i3 += 1) {
      byRow[i3] = {
        affectedInstances: ui.affectedInstances,
        isEvent: ui.isEvent,
        segs: []
      };
    }
    for (let seg of ui.segs) {
      byRow[seg.col].segs.push(seg);
    }
  }
  return byRow;
}
var TimeColMoreLink = class extends BaseComponent {
  render() {
    let { props } = this;
    return y(MoreLinkContainer, { elClasses: ["fc-timegrid-more-link"], elStyle: {
      top: props.top,
      bottom: props.bottom
    }, allDayDate: null, moreCnt: props.hiddenSegs.length, allSegs: props.hiddenSegs, hiddenSegs: props.hiddenSegs, extraDateSpan: props.extraDateSpan, dateProfile: props.dateProfile, todayRange: props.todayRange, popoverContent: () => renderPlainFgSegs(props.hiddenSegs, props), defaultGenerator: renderMoreLinkInner2, forceTimed: true }, (InnerContent) => y(InnerContent, { elTag: "div", elClasses: ["fc-timegrid-more-link-inner", "fc-sticky"] }));
  }
};
function renderMoreLinkInner2(props) {
  return props.shortText;
}
function buildPositioning(segInputs, strictOrder, maxStackCnt) {
  let hierarchy = new SegHierarchy();
  if (strictOrder != null) {
    hierarchy.strictOrder = strictOrder;
  }
  if (maxStackCnt != null) {
    hierarchy.maxStackCnt = maxStackCnt;
  }
  let hiddenEntries = hierarchy.addSegs(segInputs);
  let hiddenGroups = groupIntersectingEntries(hiddenEntries);
  let web = buildWeb(hierarchy);
  web = stretchWeb(web, 1);
  let segRects = webToRects(web);
  return { segRects, hiddenGroups };
}
function buildWeb(hierarchy) {
  const { entriesByLevel } = hierarchy;
  const buildNode = cacheable((level, lateral) => level + ":" + lateral, (level, lateral) => {
    let siblingRange = findNextLevelSegs(hierarchy, level, lateral);
    let nextLevelRes = buildNodes(siblingRange, buildNode);
    let entry = entriesByLevel[level][lateral];
    return [
      Object.assign(Object.assign({}, entry), { nextLevelNodes: nextLevelRes[0] }),
      entry.thickness + nextLevelRes[1]
      // the pressure builds
    ];
  });
  return buildNodes(entriesByLevel.length ? { level: 0, lateralStart: 0, lateralEnd: entriesByLevel[0].length } : null, buildNode)[0];
}
function buildNodes(siblingRange, buildNode) {
  if (!siblingRange) {
    return [[], 0];
  }
  let { level, lateralStart, lateralEnd } = siblingRange;
  let lateral = lateralStart;
  let pairs = [];
  while (lateral < lateralEnd) {
    pairs.push(buildNode(level, lateral));
    lateral += 1;
  }
  pairs.sort(cmpDescPressures);
  return [
    pairs.map(extractNode),
    pairs[0][1]
    // first item's pressure
  ];
}
function cmpDescPressures(a3, b3) {
  return b3[1] - a3[1];
}
function extractNode(a3) {
  return a3[0];
}
function findNextLevelSegs(hierarchy, subjectLevel, subjectLateral) {
  let { levelCoords, entriesByLevel } = hierarchy;
  let subjectEntry = entriesByLevel[subjectLevel][subjectLateral];
  let afterSubject = levelCoords[subjectLevel] + subjectEntry.thickness;
  let levelCnt = levelCoords.length;
  let level = subjectLevel;
  for (; level < levelCnt && levelCoords[level] < afterSubject; level += 1)
    ;
  for (; level < levelCnt; level += 1) {
    let entries = entriesByLevel[level];
    let entry;
    let searchIndex = binarySearch(entries, subjectEntry.span.start, getEntrySpanEnd);
    let lateralStart = searchIndex[0] + searchIndex[1];
    let lateralEnd = lateralStart;
    while (
      // loop through entries that horizontally intersect
      (entry = entries[lateralEnd]) && // but not past the whole seg list
      entry.span.start < subjectEntry.span.end
    ) {
      lateralEnd += 1;
    }
    if (lateralStart < lateralEnd) {
      return { level, lateralStart, lateralEnd };
    }
  }
  return null;
}
function stretchWeb(topLevelNodes, totalThickness) {
  const stretchNode = cacheable((node, startCoord, prevThickness) => buildEntryKey(node), (node, startCoord, prevThickness) => {
    let { nextLevelNodes, thickness } = node;
    let allThickness = thickness + prevThickness;
    let thicknessFraction = thickness / allThickness;
    let endCoord;
    let newChildren = [];
    if (!nextLevelNodes.length) {
      endCoord = totalThickness;
    } else {
      for (let childNode of nextLevelNodes) {
        if (endCoord === void 0) {
          let res = stretchNode(childNode, startCoord, allThickness);
          endCoord = res[0];
          newChildren.push(res[1]);
        } else {
          let res = stretchNode(childNode, endCoord, 0);
          newChildren.push(res[1]);
        }
      }
    }
    let newThickness = (endCoord - startCoord) * thicknessFraction;
    return [endCoord - newThickness, Object.assign(Object.assign({}, node), { thickness: newThickness, nextLevelNodes: newChildren })];
  });
  return topLevelNodes.map((node) => stretchNode(node, 0, 0)[1]);
}
function webToRects(topLevelNodes) {
  let rects = [];
  const processNode = cacheable((node, levelCoord, stackDepth) => buildEntryKey(node), (node, levelCoord, stackDepth) => {
    let rect = Object.assign(Object.assign({}, node), {
      levelCoord,
      stackDepth,
      stackForward: 0
    });
    rects.push(rect);
    return rect.stackForward = processNodes(node.nextLevelNodes, levelCoord + node.thickness, stackDepth + 1) + 1;
  });
  function processNodes(nodes, levelCoord, stackDepth) {
    let stackForward = 0;
    for (let node of nodes) {
      stackForward = Math.max(processNode(node, levelCoord, stackDepth), stackForward);
    }
    return stackForward;
  }
  processNodes(topLevelNodes, 0, 0);
  return rects;
}
function cacheable(keyFunc, workFunc) {
  const cache = {};
  return (...args) => {
    let key = keyFunc(...args);
    return key in cache ? cache[key] : cache[key] = workFunc(...args);
  };
}
function computeSegVCoords(segs, colDate, slatCoords = null, eventMinHeight = 0) {
  let vcoords = [];
  if (slatCoords) {
    for (let i3 = 0; i3 < segs.length; i3 += 1) {
      let seg = segs[i3];
      let spanStart = slatCoords.computeDateTop(seg.start, colDate);
      let spanEnd = Math.max(
        spanStart + (eventMinHeight || 0),
        // :(
        slatCoords.computeDateTop(seg.end, colDate)
      );
      vcoords.push({
        start: Math.round(spanStart),
        end: Math.round(spanEnd)
        //
      });
    }
  }
  return vcoords;
}
function computeFgSegPlacements(segs, segVCoords, eventOrderStrict, eventMaxStack) {
  let segInputs = [];
  let dumbSegs = [];
  for (let i3 = 0; i3 < segs.length; i3 += 1) {
    let vcoords = segVCoords[i3];
    if (vcoords) {
      segInputs.push({
        index: i3,
        thickness: 1,
        span: vcoords
      });
    } else {
      dumbSegs.push(segs[i3]);
    }
  }
  let { segRects, hiddenGroups } = buildPositioning(segInputs, eventOrderStrict, eventMaxStack);
  let segPlacements = [];
  for (let segRect of segRects) {
    segPlacements.push({
      seg: segs[segRect.index],
      rect: segRect
    });
  }
  for (let dumbSeg of dumbSegs) {
    segPlacements.push({ seg: dumbSeg, rect: null });
  }
  return { segPlacements, hiddenGroups };
}
var DEFAULT_TIME_FORMAT = createFormatter({
  hour: "numeric",
  minute: "2-digit",
  meridiem: false
});
var TimeColEvent = class extends BaseComponent {
  render() {
    return y(StandardEvent, Object.assign({}, this.props, { elClasses: [
      "fc-timegrid-event",
      "fc-v-event",
      this.props.isShort && "fc-timegrid-event-short"
    ], defaultTimeFormat: DEFAULT_TIME_FORMAT }));
  }
};
var TimeCol = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.sortEventSegs = memoize(sortEventSegs);
  }
  // TODO: memoize event-placement?
  render() {
    let { props, context } = this;
    let { options } = context;
    let isSelectMirror = options.selectMirror;
    let mirrorSegs = (
      // yuck
      props.eventDrag && props.eventDrag.segs || props.eventResize && props.eventResize.segs || isSelectMirror && props.dateSelectionSegs || []
    );
    let interactionAffectedInstances = (
      // TODO: messy way to compute this
      props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {}
    );
    let sortedFgSegs = this.sortEventSegs(props.fgEventSegs, options.eventOrder);
    return y(DayCellContainer, { elTag: "td", elRef: props.elRef, elClasses: [
      "fc-timegrid-col",
      ...props.extraClassNames || []
    ], elAttrs: Object.assign({ role: "gridcell" }, props.extraDataAttrs), date: props.date, dateProfile: props.dateProfile, todayRange: props.todayRange, extraRenderProps: props.extraRenderProps }, (InnerContent) => y(
      "div",
      { className: "fc-timegrid-col-frame" },
      y(
        "div",
        { className: "fc-timegrid-col-bg" },
        this.renderFillSegs(props.businessHourSegs, "non-business"),
        this.renderFillSegs(props.bgEventSegs, "bg-event"),
        this.renderFillSegs(props.dateSelectionSegs, "highlight")
      ),
      y("div", { className: "fc-timegrid-col-events" }, this.renderFgSegs(sortedFgSegs, interactionAffectedInstances, false, false, false)),
      y("div", { className: "fc-timegrid-col-events" }, this.renderFgSegs(mirrorSegs, {}, Boolean(props.eventDrag), Boolean(props.eventResize), Boolean(isSelectMirror), "mirror")),
      y("div", { className: "fc-timegrid-now-indicator-container" }, this.renderNowIndicator(props.nowIndicatorSegs)),
      hasCustomDayCellContent(options) && y(InnerContent, { elTag: "div", elClasses: ["fc-timegrid-col-misc"] })
    ));
  }
  renderFgSegs(sortedFgSegs, segIsInvisible, isDragging, isResizing, isDateSelecting, forcedKey) {
    let { props } = this;
    if (props.forPrint) {
      return renderPlainFgSegs(sortedFgSegs, props);
    }
    return this.renderPositionedFgSegs(sortedFgSegs, segIsInvisible, isDragging, isResizing, isDateSelecting, forcedKey);
  }
  renderPositionedFgSegs(segs, segIsInvisible, isDragging, isResizing, isDateSelecting, forcedKey) {
    let { eventMaxStack, eventShortHeight, eventOrderStrict, eventMinHeight } = this.context.options;
    let { date, slatCoords, eventSelection, todayRange, nowDate } = this.props;
    let isMirror = isDragging || isResizing || isDateSelecting;
    let segVCoords = computeSegVCoords(segs, date, slatCoords, eventMinHeight);
    let { segPlacements, hiddenGroups } = computeFgSegPlacements(segs, segVCoords, eventOrderStrict, eventMaxStack);
    return y(
      _,
      null,
      this.renderHiddenGroups(hiddenGroups, segs),
      segPlacements.map((segPlacement) => {
        let { seg, rect } = segPlacement;
        let instanceId = seg.eventRange.instance.instanceId;
        let isVisible = isMirror || Boolean(!segIsInvisible[instanceId] && rect);
        let vStyle = computeSegVStyle(rect && rect.span);
        let hStyle = !isMirror && rect ? this.computeSegHStyle(rect) : { left: 0, right: 0 };
        let isInset = Boolean(rect) && rect.stackForward > 0;
        let isShort = Boolean(rect) && rect.span.end - rect.span.start < eventShortHeight;
        return y(
          "div",
          { className: "fc-timegrid-event-harness" + (isInset ? " fc-timegrid-event-harness-inset" : ""), key: forcedKey || instanceId, style: Object.assign(Object.assign({ visibility: isVisible ? "" : "hidden" }, vStyle), hStyle) },
          y(TimeColEvent, Object.assign({ seg, isDragging, isResizing, isDateSelecting, isSelected: instanceId === eventSelection, isShort }, getSegMeta(seg, todayRange, nowDate)))
        );
      })
    );
  }
  // will already have eventMinHeight applied because segInputs already had it
  renderHiddenGroups(hiddenGroups, segs) {
    let { extraDateSpan, dateProfile, todayRange, nowDate, eventSelection, eventDrag, eventResize } = this.props;
    return y(_, null, hiddenGroups.map((hiddenGroup) => {
      let positionCss = computeSegVStyle(hiddenGroup.span);
      let hiddenSegs = compileSegsFromEntries(hiddenGroup.entries, segs);
      return y(TimeColMoreLink, { key: buildIsoString(computeEarliestSegStart(hiddenSegs)), hiddenSegs, top: positionCss.top, bottom: positionCss.bottom, extraDateSpan, dateProfile, todayRange, nowDate, eventSelection, eventDrag, eventResize });
    }));
  }
  renderFillSegs(segs, fillType) {
    let { props, context } = this;
    let segVCoords = computeSegVCoords(segs, props.date, props.slatCoords, context.options.eventMinHeight);
    let children = segVCoords.map((vcoords, i3) => {
      let seg = segs[i3];
      return y("div", { key: buildEventRangeKey(seg.eventRange), className: "fc-timegrid-bg-harness", style: computeSegVStyle(vcoords) }, fillType === "bg-event" ? y(BgEvent, Object.assign({ seg }, getSegMeta(seg, props.todayRange, props.nowDate))) : renderFill(fillType));
    });
    return y(_, null, children);
  }
  renderNowIndicator(segs) {
    let { slatCoords, date } = this.props;
    if (!slatCoords) {
      return null;
    }
    return segs.map((seg, i3) => y(
      NowIndicatorContainer,
      {
        // key doesn't matter. will only ever be one
        key: i3,
        elClasses: ["fc-timegrid-now-indicator-line"],
        elStyle: {
          top: slatCoords.computeDateTop(seg.start, date)
        },
        isAxis: false,
        date
      }
    ));
  }
  computeSegHStyle(segHCoords) {
    let { isRtl, options } = this.context;
    let shouldOverlap = options.slotEventOverlap;
    let nearCoord = segHCoords.levelCoord;
    let farCoord = segHCoords.levelCoord + segHCoords.thickness;
    let left;
    let right;
    if (shouldOverlap) {
      farCoord = Math.min(1, nearCoord + (farCoord - nearCoord) * 2);
    }
    if (isRtl) {
      left = 1 - farCoord;
      right = nearCoord;
    } else {
      left = nearCoord;
      right = 1 - farCoord;
    }
    let props = {
      zIndex: segHCoords.stackDepth + 1,
      left: left * 100 + "%",
      right: right * 100 + "%"
    };
    if (shouldOverlap && !segHCoords.stackForward) {
      props[isRtl ? "marginLeft" : "marginRight"] = 10 * 2;
    }
    return props;
  }
};
function renderPlainFgSegs(sortedFgSegs, { todayRange, nowDate, eventSelection, eventDrag, eventResize }) {
  let hiddenInstances = (eventDrag ? eventDrag.affectedInstances : null) || (eventResize ? eventResize.affectedInstances : null) || {};
  return y(_, null, sortedFgSegs.map((seg) => {
    let instanceId = seg.eventRange.instance.instanceId;
    return y(
      "div",
      { key: instanceId, style: { visibility: hiddenInstances[instanceId] ? "hidden" : "" } },
      y(TimeColEvent, Object.assign({ seg, isDragging: false, isResizing: false, isDateSelecting: false, isSelected: instanceId === eventSelection, isShort: false }, getSegMeta(seg, todayRange, nowDate)))
    );
  }));
}
function computeSegVStyle(segVCoords) {
  if (!segVCoords) {
    return { top: "", bottom: "" };
  }
  return {
    top: segVCoords.start,
    bottom: -segVCoords.end
  };
}
function compileSegsFromEntries(segEntries, allSegs) {
  return segEntries.map((segEntry) => allSegs[segEntry.index]);
}
var TimeColsContent = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.splitFgEventSegs = memoize(splitSegsByCol);
    this.splitBgEventSegs = memoize(splitSegsByCol);
    this.splitBusinessHourSegs = memoize(splitSegsByCol);
    this.splitNowIndicatorSegs = memoize(splitSegsByCol);
    this.splitDateSelectionSegs = memoize(splitSegsByCol);
    this.splitEventDrag = memoize(splitInteractionByCol);
    this.splitEventResize = memoize(splitInteractionByCol);
    this.rootElRef = d();
    this.cellElRefs = new RefMap();
  }
  render() {
    let { props, context } = this;
    let nowIndicatorTop = context.options.nowIndicator && props.slatCoords && props.slatCoords.safeComputeTop(props.nowDate);
    let colCnt = props.cells.length;
    let fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, colCnt);
    let bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, colCnt);
    let businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, colCnt);
    let nowIndicatorSegsByRow = this.splitNowIndicatorSegs(props.nowIndicatorSegs, colCnt);
    let dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, colCnt);
    let eventDragByRow = this.splitEventDrag(props.eventDrag, colCnt);
    let eventResizeByRow = this.splitEventResize(props.eventResize, colCnt);
    return y(
      "div",
      { className: "fc-timegrid-cols", ref: this.rootElRef },
      y(
        "table",
        { role: "presentation", style: {
          minWidth: props.tableMinWidth,
          width: props.clientWidth
        } },
        props.tableColGroupNode,
        y(
          "tbody",
          { role: "presentation" },
          y(
            "tr",
            { role: "row" },
            props.axis && y(
              "td",
              { "aria-hidden": true, className: "fc-timegrid-col fc-timegrid-axis" },
              y(
                "div",
                { className: "fc-timegrid-col-frame" },
                y("div", { className: "fc-timegrid-now-indicator-container" }, typeof nowIndicatorTop === "number" && y(NowIndicatorContainer, { elClasses: ["fc-timegrid-now-indicator-arrow"], elStyle: { top: nowIndicatorTop }, isAxis: true, date: props.nowDate }))
              )
            ),
            props.cells.map((cell, i3) => y(TimeCol, { key: cell.key, elRef: this.cellElRefs.createRef(cell.key), dateProfile: props.dateProfile, date: cell.date, nowDate: props.nowDate, todayRange: props.todayRange, extraRenderProps: cell.extraRenderProps, extraDataAttrs: cell.extraDataAttrs, extraClassNames: cell.extraClassNames, extraDateSpan: cell.extraDateSpan, fgEventSegs: fgEventSegsByRow[i3], bgEventSegs: bgEventSegsByRow[i3], businessHourSegs: businessHourSegsByRow[i3], nowIndicatorSegs: nowIndicatorSegsByRow[i3], dateSelectionSegs: dateSelectionSegsByRow[i3], eventDrag: eventDragByRow[i3], eventResize: eventResizeByRow[i3], slatCoords: props.slatCoords, eventSelection: props.eventSelection, forPrint: props.forPrint }))
          )
        )
      )
    );
  }
  componentDidMount() {
    this.updateCoords();
  }
  componentDidUpdate() {
    this.updateCoords();
  }
  updateCoords() {
    let { props } = this;
    if (props.onColCoords && props.clientWidth !== null) {
      props.onColCoords(new PositionCache(
        this.rootElRef.current,
        collectCellEls(this.cellElRefs.currentMap, props.cells),
        true,
        // horizontal
        false
      ));
    }
  }
};
function collectCellEls(elMap, cells) {
  return cells.map((cell) => elMap[cell.key]);
}
var TimeCols = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.processSlotOptions = memoize(processSlotOptions);
    this.state = {
      slatCoords: null
    };
    this.handleRootEl = (el) => {
      if (el) {
        this.context.registerInteractiveComponent(this, {
          el,
          isHitComboAllowed: this.props.isHitComboAllowed
        });
      } else {
        this.context.unregisterInteractiveComponent(this);
      }
    };
    this.handleScrollRequest = (request) => {
      let { onScrollTopRequest } = this.props;
      let { slatCoords } = this.state;
      if (onScrollTopRequest && slatCoords) {
        if (request.time) {
          let top = slatCoords.computeTimeTop(request.time);
          top = Math.ceil(top);
          if (top) {
            top += 1;
          }
          onScrollTopRequest(top);
        }
        return true;
      }
      return false;
    };
    this.handleColCoords = (colCoords) => {
      this.colCoords = colCoords;
    };
    this.handleSlatCoords = (slatCoords) => {
      this.setState({ slatCoords });
      if (this.props.onSlatCoords) {
        this.props.onSlatCoords(slatCoords);
      }
    };
  }
  render() {
    let { props, state } = this;
    return y(
      "div",
      { className: "fc-timegrid-body", ref: this.handleRootEl, style: {
        // these props are important to give this wrapper correct dimensions for interactions
        // TODO: if we set it here, can we avoid giving to inner tables?
        width: props.clientWidth,
        minWidth: props.tableMinWidth
      } },
      y(TimeColsSlats, { axis: props.axis, dateProfile: props.dateProfile, slatMetas: props.slatMetas, clientWidth: props.clientWidth, minHeight: props.expandRows ? props.clientHeight : "", tableMinWidth: props.tableMinWidth, tableColGroupNode: props.axis ? props.tableColGroupNode : null, onCoords: this.handleSlatCoords }),
      y(TimeColsContent, { cells: props.cells, axis: props.axis, dateProfile: props.dateProfile, businessHourSegs: props.businessHourSegs, bgEventSegs: props.bgEventSegs, fgEventSegs: props.fgEventSegs, dateSelectionSegs: props.dateSelectionSegs, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, todayRange: props.todayRange, nowDate: props.nowDate, nowIndicatorSegs: props.nowIndicatorSegs, clientWidth: props.clientWidth, tableMinWidth: props.tableMinWidth, tableColGroupNode: props.tableColGroupNode, slatCoords: state.slatCoords, onColCoords: this.handleColCoords, forPrint: props.forPrint })
    );
  }
  componentDidMount() {
    this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest);
  }
  componentDidUpdate(prevProps) {
    this.scrollResponder.update(prevProps.dateProfile !== this.props.dateProfile);
  }
  componentWillUnmount() {
    this.scrollResponder.detach();
  }
  queryHit(positionLeft, positionTop) {
    let { dateEnv, options } = this.context;
    let { colCoords } = this;
    let { dateProfile } = this.props;
    let { slatCoords } = this.state;
    let { snapDuration, snapsPerSlot } = this.processSlotOptions(this.props.slotDuration, options.snapDuration);
    let colIndex = colCoords.leftToIndex(positionLeft);
    let slatIndex = slatCoords.positions.topToIndex(positionTop);
    if (colIndex != null && slatIndex != null) {
      let cell = this.props.cells[colIndex];
      let slatTop = slatCoords.positions.tops[slatIndex];
      let slatHeight = slatCoords.positions.getHeight(slatIndex);
      let partial = (positionTop - slatTop) / slatHeight;
      let localSnapIndex = Math.floor(partial * snapsPerSlot);
      let snapIndex = slatIndex * snapsPerSlot + localSnapIndex;
      let dayDate = this.props.cells[colIndex].date;
      let time = addDurations(dateProfile.slotMinTime, multiplyDuration(snapDuration, snapIndex));
      let start = dateEnv.add(dayDate, time);
      let end = dateEnv.add(start, snapDuration);
      return {
        dateProfile,
        dateSpan: Object.assign({ range: { start, end }, allDay: false }, cell.extraDateSpan),
        dayEl: colCoords.els[colIndex],
        rect: {
          left: colCoords.lefts[colIndex],
          right: colCoords.rights[colIndex],
          top: slatTop,
          bottom: slatTop + slatHeight
        },
        layer: 0
      };
    }
    return null;
  }
};
function processSlotOptions(slotDuration, snapDurationOverride) {
  let snapDuration = snapDurationOverride || slotDuration;
  let snapsPerSlot = wholeDivideDurations(slotDuration, snapDuration);
  if (snapsPerSlot === null) {
    snapDuration = slotDuration;
    snapsPerSlot = 1;
  }
  return { snapDuration, snapsPerSlot };
}
var DayTimeColsSlicer = class extends Slicer {
  sliceRange(range2, dayRanges) {
    let segs = [];
    for (let col = 0; col < dayRanges.length; col += 1) {
      let segRange = intersectRanges(range2, dayRanges[col]);
      if (segRange) {
        segs.push({
          start: segRange.start,
          end: segRange.end,
          isStart: segRange.start.valueOf() === range2.start.valueOf(),
          isEnd: segRange.end.valueOf() === range2.end.valueOf(),
          col
        });
      }
    }
    return segs;
  }
};
var DayTimeCols = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.buildDayRanges = memoize(buildDayRanges);
    this.slicer = new DayTimeColsSlicer();
    this.timeColsRef = d();
  }
  render() {
    let { props, context } = this;
    let { dateProfile, dayTableModel } = props;
    let { nowIndicator, nextDayThreshold } = context.options;
    let dayRanges = this.buildDayRanges(dayTableModel, dateProfile, context.dateEnv);
    return y(NowTimer, { unit: nowIndicator ? "minute" : "day" }, (nowDate, todayRange) => y(TimeCols, Object.assign({ ref: this.timeColsRef }, this.slicer.sliceProps(props, dateProfile, null, context, dayRanges), { forPrint: props.forPrint, axis: props.axis, dateProfile, slatMetas: props.slatMetas, slotDuration: props.slotDuration, cells: dayTableModel.cells[0], tableColGroupNode: props.tableColGroupNode, tableMinWidth: props.tableMinWidth, clientWidth: props.clientWidth, clientHeight: props.clientHeight, expandRows: props.expandRows, nowDate, nowIndicatorSegs: nowIndicator && this.slicer.sliceNowDate(nowDate, dateProfile, nextDayThreshold, context, dayRanges), todayRange, onScrollTopRequest: props.onScrollTopRequest, onSlatCoords: props.onSlatCoords })));
  }
};
function buildDayRanges(dayTableModel, dateProfile, dateEnv) {
  let ranges = [];
  for (let date of dayTableModel.headerDates) {
    ranges.push({
      start: dateEnv.add(date, dateProfile.slotMinTime),
      end: dateEnv.add(date, dateProfile.slotMaxTime)
    });
  }
  return ranges;
}
var STOCK_SUB_DURATIONS = [
  { hours: 1 },
  { minutes: 30 },
  { minutes: 15 },
  { seconds: 30 },
  { seconds: 15 }
];
function buildSlatMetas(slotMinTime, slotMaxTime, explicitLabelInterval, slotDuration, dateEnv) {
  let dayStart = new Date(0);
  let slatTime = slotMinTime;
  let slatIterator = createDuration(0);
  let labelInterval = explicitLabelInterval || computeLabelInterval(slotDuration);
  let metas = [];
  while (asRoughMs(slatTime) < asRoughMs(slotMaxTime)) {
    let date = dateEnv.add(dayStart, slatTime);
    let isLabeled = wholeDivideDurations(slatIterator, labelInterval) !== null;
    metas.push({
      date,
      time: slatTime,
      key: date.toISOString(),
      isoTimeStr: formatIsoTimeString(date),
      isLabeled
    });
    slatTime = addDurations(slatTime, slotDuration);
    slatIterator = addDurations(slatIterator, slotDuration);
  }
  return metas;
}
function computeLabelInterval(slotDuration) {
  let i3;
  let labelInterval;
  let slotsPerLabel;
  for (i3 = STOCK_SUB_DURATIONS.length - 1; i3 >= 0; i3 -= 1) {
    labelInterval = createDuration(STOCK_SUB_DURATIONS[i3]);
    slotsPerLabel = wholeDivideDurations(labelInterval, slotDuration);
    if (slotsPerLabel !== null && slotsPerLabel > 1) {
      return labelInterval;
    }
  }
  return slotDuration;
}
var DayTimeColsView = class extends TimeColsView {
  constructor() {
    super(...arguments);
    this.buildTimeColsModel = memoize(buildTimeColsModel);
    this.buildSlatMetas = memoize(buildSlatMetas);
  }
  render() {
    let { options, dateEnv, dateProfileGenerator } = this.context;
    let { props } = this;
    let { dateProfile } = props;
    let dayTableModel = this.buildTimeColsModel(dateProfile, dateProfileGenerator);
    let splitProps = this.allDaySplitter.splitProps(props);
    let slatMetas = this.buildSlatMetas(dateProfile.slotMinTime, dateProfile.slotMaxTime, options.slotLabelInterval, options.slotDuration, dateEnv);
    let { dayMinWidth } = options;
    let hasAttachedAxis = !dayMinWidth;
    let hasDetachedAxis = dayMinWidth;
    let headerContent = options.dayHeaders && y(DayHeader, { dates: dayTableModel.headerDates, dateProfile, datesRepDistinctDays: true, renderIntro: hasAttachedAxis ? this.renderHeadAxis : null });
    let allDayContent = options.allDaySlot !== false && ((contentArg) => y(DayTable, Object.assign({}, splitProps.allDay, { dateProfile, dayTableModel, nextDayThreshold: options.nextDayThreshold, tableMinWidth: contentArg.tableMinWidth, colGroupNode: contentArg.tableColGroupNode, renderRowIntro: hasAttachedAxis ? this.renderTableRowAxis : null, showWeekNumbers: false, expandRows: false, headerAlignElRef: this.headerElRef, clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, forPrint: props.forPrint }, this.getAllDayMaxEventProps())));
    let timeGridContent = (contentArg) => y(DayTimeCols, Object.assign({}, splitProps.timed, { dayTableModel, dateProfile, axis: hasAttachedAxis, slotDuration: options.slotDuration, slatMetas, forPrint: props.forPrint, tableColGroupNode: contentArg.tableColGroupNode, tableMinWidth: contentArg.tableMinWidth, clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, onSlatCoords: this.handleSlatCoords, expandRows: contentArg.expandRows, onScrollTopRequest: this.handleScrollTopRequest }));
    return hasDetachedAxis ? this.renderHScrollLayout(headerContent, allDayContent, timeGridContent, dayTableModel.colCnt, dayMinWidth, slatMetas, this.state.slatCoords) : this.renderSimpleLayout(headerContent, allDayContent, timeGridContent);
  }
};
function buildTimeColsModel(dateProfile, dateProfileGenerator) {
  let daySeries = new DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);
  return new DayTableModel(daySeries, false);
}
var css_248z3 = '.fc-v-event{background-color:var(--fc-event-bg-color);border:1px solid var(--fc-event-border-color);display:block}.fc-v-event .fc-event-main{color:var(--fc-event-text-color);height:100%}.fc-v-event .fc-event-main-frame{display:flex;flex-direction:column;height:100%}.fc-v-event .fc-event-time{flex-grow:0;flex-shrink:0;max-height:100%;overflow:hidden}.fc-v-event .fc-event-title-container{flex-grow:1;flex-shrink:1;min-height:0}.fc-v-event .fc-event-title{bottom:0;max-height:100%;overflow:hidden;top:0}.fc-v-event:not(.fc-event-start){border-top-left-radius:0;border-top-right-radius:0;border-top-width:0}.fc-v-event:not(.fc-event-end){border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom-width:0}.fc-v-event.fc-event-selected:before{left:-10px;right:-10px}.fc-v-event .fc-event-resizer-start{cursor:n-resize}.fc-v-event .fc-event-resizer-end{cursor:s-resize}.fc-v-event:not(.fc-event-selected) .fc-event-resizer{height:var(--fc-event-resizer-thickness);left:0;right:0}.fc-v-event:not(.fc-event-selected) .fc-event-resizer-start{top:calc(var(--fc-event-resizer-thickness)/-2)}.fc-v-event:not(.fc-event-selected) .fc-event-resizer-end{bottom:calc(var(--fc-event-resizer-thickness)/-2)}.fc-v-event.fc-event-selected .fc-event-resizer{left:50%;margin-left:calc(var(--fc-event-resizer-dot-total-width)/-2)}.fc-v-event.fc-event-selected .fc-event-resizer-start{top:calc(var(--fc-event-resizer-dot-total-width)/-2)}.fc-v-event.fc-event-selected .fc-event-resizer-end{bottom:calc(var(--fc-event-resizer-dot-total-width)/-2)}.fc .fc-timegrid .fc-daygrid-body{z-index:2}.fc .fc-timegrid-divider{padding:0 0 2px}.fc .fc-timegrid-body{min-height:100%;position:relative;z-index:1}.fc .fc-timegrid-axis-chunk{position:relative}.fc .fc-timegrid-axis-chunk>table,.fc .fc-timegrid-slots{position:relative;z-index:1}.fc .fc-timegrid-slot{border-bottom:0;height:1.5em}.fc .fc-timegrid-slot:empty:before{content:"\\00a0"}.fc .fc-timegrid-slot-minor{border-top-style:dotted}.fc .fc-timegrid-slot-label-cushion{display:inline-block;white-space:nowrap}.fc .fc-timegrid-slot-label{vertical-align:middle}.fc .fc-timegrid-axis-cushion,.fc .fc-timegrid-slot-label-cushion{padding:0 4px}.fc .fc-timegrid-axis-frame-liquid{height:100%}.fc .fc-timegrid-axis-frame{align-items:center;display:flex;justify-content:flex-end;overflow:hidden}.fc .fc-timegrid-axis-cushion{flex-shrink:0;max-width:60px}.fc-direction-ltr .fc-timegrid-slot-label-frame{text-align:right}.fc-direction-rtl .fc-timegrid-slot-label-frame{text-align:left}.fc-liquid-hack .fc-timegrid-axis-frame-liquid{bottom:0;height:auto;left:0;position:absolute;right:0;top:0}.fc .fc-timegrid-col.fc-day-today{background-color:var(--fc-today-bg-color)}.fc .fc-timegrid-col-frame{min-height:100%;position:relative}.fc-media-screen.fc-liquid-hack .fc-timegrid-col-frame{bottom:0;height:auto;left:0;position:absolute;right:0;top:0}.fc-media-screen .fc-timegrid-cols{bottom:0;left:0;position:absolute;right:0;top:0}.fc-media-screen .fc-timegrid-cols>table{height:100%}.fc-media-screen .fc-timegrid-col-bg,.fc-media-screen .fc-timegrid-col-events,.fc-media-screen .fc-timegrid-now-indicator-container{left:0;position:absolute;right:0;top:0}.fc .fc-timegrid-col-bg{z-index:2}.fc .fc-timegrid-col-bg .fc-non-business{z-index:1}.fc .fc-timegrid-col-bg .fc-bg-event{z-index:2}.fc .fc-timegrid-col-bg .fc-highlight{z-index:3}.fc .fc-timegrid-bg-harness{left:0;position:absolute;right:0}.fc .fc-timegrid-col-events{z-index:3}.fc .fc-timegrid-now-indicator-container{bottom:0;overflow:hidden}.fc-direction-ltr .fc-timegrid-col-events{margin:0 2.5% 0 2px}.fc-direction-rtl .fc-timegrid-col-events{margin:0 2px 0 2.5%}.fc-timegrid-event-harness{position:absolute}.fc-timegrid-event-harness>.fc-timegrid-event{bottom:0;left:0;position:absolute;right:0;top:0}.fc-timegrid-event-harness-inset .fc-timegrid-event,.fc-timegrid-event.fc-event-mirror,.fc-timegrid-more-link{box-shadow:0 0 0 1px var(--fc-page-bg-color)}.fc-timegrid-event,.fc-timegrid-more-link{border-radius:3px;font-size:var(--fc-small-font-size)}.fc-timegrid-event{margin-bottom:1px}.fc-timegrid-event .fc-event-main{padding:1px 1px 0}.fc-timegrid-event .fc-event-time{font-size:var(--fc-small-font-size);margin-bottom:1px;white-space:nowrap}.fc-timegrid-event-short .fc-event-main-frame{flex-direction:row;overflow:hidden}.fc-timegrid-event-short .fc-event-time:after{content:"\\00a0-\\00a0"}.fc-timegrid-event-short .fc-event-title{font-size:var(--fc-small-font-size)}.fc-timegrid-more-link{background:var(--fc-more-link-bg-color);color:var(--fc-more-link-text-color);cursor:pointer;margin-bottom:1px;position:absolute;z-index:9999}.fc-timegrid-more-link-inner{padding:3px 2px;top:0}.fc-direction-ltr .fc-timegrid-more-link{right:0}.fc-direction-rtl .fc-timegrid-more-link{left:0}.fc .fc-timegrid-now-indicator-arrow,.fc .fc-timegrid-now-indicator-line{pointer-events:none}.fc .fc-timegrid-now-indicator-line{border-color:var(--fc-now-indicator-color);border-style:solid;border-width:1px 0 0;left:0;position:absolute;right:0;z-index:4}.fc .fc-timegrid-now-indicator-arrow{border-color:var(--fc-now-indicator-color);border-style:solid;margin-top:-5px;position:absolute;z-index:4}.fc-direction-ltr .fc-timegrid-now-indicator-arrow{border-bottom-color:transparent;border-top-color:transparent;border-width:5px 0 5px 6px;left:0}.fc-direction-rtl .fc-timegrid-now-indicator-arrow{border-bottom-color:transparent;border-top-color:transparent;border-width:5px 6px 5px 0;right:0}';
injectStyles(css_248z3);

// node_modules/@fullcalendar/timegrid/index.js
var OPTION_REFINERS = {
  allDaySlot: Boolean
};
var index2 = createPlugin({
  name: "@fullcalendar/timegrid",
  initialView: "timeGridWeek",
  optionRefiners: OPTION_REFINERS,
  views: {
    timeGrid: {
      component: DayTimeColsView,
      usesMinMaxTime: true,
      allDaySlot: true,
      slotDuration: "00:30:00",
      slotEventOverlap: true
      // a bad name. confused with overlap/constraint system
    },
    timeGridDay: {
      type: "timeGrid",
      duration: { days: 1 }
    },
    timeGridWeek: {
      type: "timeGrid",
      duration: { weeks: 1 }
    }
  }
});

// node_modules/rrule/dist/esm/weekday.js
var ALL_WEEKDAYS = [
  "MO",
  "TU",
  "WE",
  "TH",
  "FR",
  "SA",
  "SU"
];
var Weekday = (
  /** @class */
  function() {
    function Weekday2(weekday, n2) {
      if (n2 === 0)
        throw new Error("Can't create weekday with n == 0");
      this.weekday = weekday;
      this.n = n2;
    }
    Weekday2.fromStr = function(str) {
      return new Weekday2(ALL_WEEKDAYS.indexOf(str));
    };
    Weekday2.prototype.nth = function(n2) {
      return this.n === n2 ? this : new Weekday2(this.weekday, n2);
    };
    Weekday2.prototype.equals = function(other) {
      return this.weekday === other.weekday && this.n === other.n;
    };
    Weekday2.prototype.toString = function() {
      var s3 = ALL_WEEKDAYS[this.weekday];
      if (this.n)
        s3 = (this.n > 0 ? "+" : "") + String(this.n) + s3;
      return s3;
    };
    Weekday2.prototype.getJsWeekday = function() {
      return this.weekday === 6 ? 0 : this.weekday + 1;
    };
    return Weekday2;
  }()
);

// node_modules/rrule/dist/esm/helpers.js
var isPresent = function(value) {
  return value !== null && value !== void 0;
};
var isNumber = function(value) {
  return typeof value === "number";
};
var isWeekdayStr = function(value) {
  return typeof value === "string" && ALL_WEEKDAYS.includes(value);
};
var isArray = Array.isArray;
var range = function(start, end) {
  if (end === void 0) {
    end = start;
  }
  if (arguments.length === 1) {
    end = start;
    start = 0;
  }
  var rang = [];
  for (var i3 = start; i3 < end; i3++)
    rang.push(i3);
  return rang;
};
var repeat = function(value, times) {
  var i3 = 0;
  var array = [];
  if (isArray(value)) {
    for (; i3 < times; i3++)
      array[i3] = [].concat(value);
  } else {
    for (; i3 < times; i3++)
      array[i3] = value;
  }
  return array;
};
var toArray = function(item) {
  if (isArray(item)) {
    return item;
  }
  return [item];
};
function padStart2(item, targetLength, padString) {
  if (padString === void 0) {
    padString = " ";
  }
  var str = String(item);
  targetLength = targetLength >> 0;
  if (str.length > targetLength) {
    return String(str);
  }
  targetLength = targetLength - str.length;
  if (targetLength > padString.length) {
    padString += repeat(padString, targetLength / padString.length);
  }
  return padString.slice(0, targetLength) + String(str);
}
var split = function(str, sep, num) {
  var splits = str.split(sep);
  return num ? splits.slice(0, num).concat([splits.slice(num).join(sep)]) : splits;
};
var pymod = function(a3, b3) {
  var r3 = a3 % b3;
  return r3 * b3 < 0 ? r3 + b3 : r3;
};
var divmod = function(a3, b3) {
  return { div: Math.floor(a3 / b3), mod: pymod(a3, b3) };
};
var empty = function(obj) {
  return !isPresent(obj) || obj.length === 0;
};
var notEmpty = function(obj) {
  return !empty(obj);
};
var includes = function(arr, val) {
  return notEmpty(arr) && arr.indexOf(val) !== -1;
};

// node_modules/rrule/dist/esm/dateutil.js
var datetime = function(y3, m3, d2, h3, i3, s3) {
  if (h3 === void 0) {
    h3 = 0;
  }
  if (i3 === void 0) {
    i3 = 0;
  }
  if (s3 === void 0) {
    s3 = 0;
  }
  return new Date(Date.UTC(y3, m3 - 1, d2, h3, i3, s3));
};
var MONTH_DAYS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var ONE_DAY = 1e3 * 60 * 60 * 24;
var MAXYEAR = 9999;
var ORDINAL_BASE = datetime(1970, 1, 1);
var PY_WEEKDAYS = [6, 0, 1, 2, 3, 4, 5];
var isLeapYear = function(year) {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
};
var isDate = function(value) {
  return value instanceof Date;
};
var isValidDate2 = function(value) {
  return isDate(value) && !isNaN(value.getTime());
};
var daysBetween = function(date1, date2) {
  var date1ms = date1.getTime();
  var date2ms = date2.getTime();
  var differencems = date1ms - date2ms;
  return Math.round(differencems / ONE_DAY);
};
var toOrdinal = function(date) {
  return daysBetween(date, ORDINAL_BASE);
};
var fromOrdinal = function(ordinal) {
  return new Date(ORDINAL_BASE.getTime() + ordinal * ONE_DAY);
};
var getMonthDays = function(date) {
  var month = date.getUTCMonth();
  return month === 1 && isLeapYear(date.getUTCFullYear()) ? 29 : MONTH_DAYS[month];
};
var getWeekday = function(date) {
  return PY_WEEKDAYS[date.getUTCDay()];
};
var monthRange = function(year, month) {
  var date = datetime(year, month + 1, 1);
  return [getWeekday(date), getMonthDays(date)];
};
var combine = function(date, time) {
  time = time || date;
  return new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds()));
};
var clone = function(date) {
  var dolly = new Date(date.getTime());
  return dolly;
};
var cloneDates = function(dates) {
  var clones = [];
  for (var i3 = 0; i3 < dates.length; i3++) {
    clones.push(clone(dates[i3]));
  }
  return clones;
};
var sort = function(dates) {
  dates.sort(function(a3, b3) {
    return a3.getTime() - b3.getTime();
  });
};
var timeToUntilString = function(time, utc) {
  if (utc === void 0) {
    utc = true;
  }
  var date = new Date(time);
  return [
    padStart2(date.getUTCFullYear().toString(), 4, "0"),
    padStart2(date.getUTCMonth() + 1, 2, "0"),
    padStart2(date.getUTCDate(), 2, "0"),
    "T",
    padStart2(date.getUTCHours(), 2, "0"),
    padStart2(date.getUTCMinutes(), 2, "0"),
    padStart2(date.getUTCSeconds(), 2, "0"),
    utc ? "Z" : ""
  ].join("");
};
var untilStringToDate = function(until) {
  var re = /^(\d{4})(\d{2})(\d{2})(T(\d{2})(\d{2})(\d{2})Z?)?$/;
  var bits = re.exec(until);
  if (!bits)
    throw new Error("Invalid UNTIL value: ".concat(until));
  return new Date(Date.UTC(parseInt(bits[1], 10), parseInt(bits[2], 10) - 1, parseInt(bits[3], 10), parseInt(bits[5], 10) || 0, parseInt(bits[6], 10) || 0, parseInt(bits[7], 10) || 0));
};
var dateTZtoISO8601 = function(date, timeZone) {
  var dateStr = date.toLocaleString("sv-SE", { timeZone });
  return dateStr.replace(" ", "T") + "Z";
};
var dateInTimeZone = function(date, timeZone) {
  var localTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
  var dateInLocalTZ = new Date(dateTZtoISO8601(date, localTimeZone));
  var dateInTargetTZ = new Date(dateTZtoISO8601(date, timeZone !== null && timeZone !== void 0 ? timeZone : "UTC"));
  var tzOffset = dateInTargetTZ.getTime() - dateInLocalTZ.getTime();
  return new Date(date.getTime() - tzOffset);
};

// node_modules/rrule/dist/esm/iterresult.js
var IterResult = (
  /** @class */
  function() {
    function IterResult2(method, args) {
      this.minDate = null;
      this.maxDate = null;
      this._result = [];
      this.total = 0;
      this.method = method;
      this.args = args;
      if (method === "between") {
        this.maxDate = args.inc ? args.before : new Date(args.before.getTime() - 1);
        this.minDate = args.inc ? args.after : new Date(args.after.getTime() + 1);
      } else if (method === "before") {
        this.maxDate = args.inc ? args.dt : new Date(args.dt.getTime() - 1);
      } else if (method === "after") {
        this.minDate = args.inc ? args.dt : new Date(args.dt.getTime() + 1);
      }
    }
    IterResult2.prototype.accept = function(date) {
      ++this.total;
      var tooEarly = this.minDate && date < this.minDate;
      var tooLate = this.maxDate && date > this.maxDate;
      if (this.method === "between") {
        if (tooEarly)
          return true;
        if (tooLate)
          return false;
      } else if (this.method === "before") {
        if (tooLate)
          return false;
      } else if (this.method === "after") {
        if (tooEarly)
          return true;
        this.add(date);
        return false;
      }
      return this.add(date);
    };
    IterResult2.prototype.add = function(date) {
      this._result.push(date);
      return true;
    };
    IterResult2.prototype.getValue = function() {
      var res = this._result;
      switch (this.method) {
        case "all":
        case "between":
          return res;
        case "before":
        case "after":
        default:
          return res.length ? res[res.length - 1] : null;
      }
    };
    IterResult2.prototype.clone = function() {
      return new IterResult2(this.method, this.args);
    };
    return IterResult2;
  }()
);
var iterresult_default = IterResult;

// node_modules/tslib/tslib.es6.js
var extendStatics = function(d2, b3) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b4) {
    d3.__proto__ = b4;
  } || function(d3, b4) {
    for (var p3 in b4)
      if (Object.prototype.hasOwnProperty.call(b4, p3))
        d3[p3] = b4[p3];
  };
  return extendStatics(d2, b3);
};
function __extends(d2, b3) {
  if (typeof b3 !== "function" && b3 !== null)
    throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
  extendStatics(d2, b3);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t3) {
    for (var s3, i3 = 1, n2 = arguments.length; i3 < n2; i3++) {
      s3 = arguments[i3];
      for (var p3 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p3))
          t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign.apply(this, arguments);
};
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i3 = 0, l3 = from.length, ar; i3 < l3; i3++) {
      if (ar || !(i3 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i3);
        ar[i3] = from[i3];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}

// node_modules/rrule/dist/esm/callbackiterresult.js
var CallbackIterResult = (
  /** @class */
  function(_super) {
    __extends(CallbackIterResult2, _super);
    function CallbackIterResult2(method, args, iterator) {
      var _this = _super.call(this, method, args) || this;
      _this.iterator = iterator;
      return _this;
    }
    CallbackIterResult2.prototype.add = function(date) {
      if (this.iterator(date, this._result.length)) {
        this._result.push(date);
        return true;
      }
      return false;
    };
    return CallbackIterResult2;
  }(iterresult_default)
);
var callbackiterresult_default = CallbackIterResult;

// node_modules/rrule/dist/esm/nlp/i18n.js
var ENGLISH = {
  dayNames: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ],
  monthNames: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ],
  tokens: {
    SKIP: /^[ \r\n\t]+|^\.$/,
    number: /^[1-9][0-9]*/,
    numberAsText: /^(one|two|three)/i,
    every: /^every/i,
    "day(s)": /^days?/i,
    "weekday(s)": /^weekdays?/i,
    "week(s)": /^weeks?/i,
    "hour(s)": /^hours?/i,
    "minute(s)": /^minutes?/i,
    "month(s)": /^months?/i,
    "year(s)": /^years?/i,
    on: /^(on|in)/i,
    at: /^(at)/i,
    the: /^the/i,
    first: /^first/i,
    second: /^second/i,
    third: /^third/i,
    nth: /^([1-9][0-9]*)(\.|th|nd|rd|st)/i,
    last: /^last/i,
    for: /^for/i,
    "time(s)": /^times?/i,
    until: /^(un)?til/i,
    monday: /^mo(n(day)?)?/i,
    tuesday: /^tu(e(s(day)?)?)?/i,
    wednesday: /^we(d(n(esday)?)?)?/i,
    thursday: /^th(u(r(sday)?)?)?/i,
    friday: /^fr(i(day)?)?/i,
    saturday: /^sa(t(urday)?)?/i,
    sunday: /^su(n(day)?)?/i,
    january: /^jan(uary)?/i,
    february: /^feb(ruary)?/i,
    march: /^mar(ch)?/i,
    april: /^apr(il)?/i,
    may: /^may/i,
    june: /^june?/i,
    july: /^july?/i,
    august: /^aug(ust)?/i,
    september: /^sep(t(ember)?)?/i,
    october: /^oct(ober)?/i,
    november: /^nov(ember)?/i,
    december: /^dec(ember)?/i,
    comma: /^(,\s*|(and|or)\s*)+/i
  }
};
var i18n_default = ENGLISH;

// node_modules/rrule/dist/esm/nlp/totext.js
var contains = function(arr, val) {
  return arr.indexOf(val) !== -1;
};
var defaultGetText = function(id) {
  return id.toString();
};
var defaultDateFormatter = function(year, month, day) {
  return "".concat(month, " ").concat(day, ", ").concat(year);
};
var ToText = (
  /** @class */
  function() {
    function ToText2(rrule, gettext, language, dateFormatter) {
      if (gettext === void 0) {
        gettext = defaultGetText;
      }
      if (language === void 0) {
        language = i18n_default;
      }
      if (dateFormatter === void 0) {
        dateFormatter = defaultDateFormatter;
      }
      this.text = [];
      this.language = language || i18n_default;
      this.gettext = gettext;
      this.dateFormatter = dateFormatter;
      this.rrule = rrule;
      this.options = rrule.options;
      this.origOptions = rrule.origOptions;
      if (this.origOptions.bymonthday) {
        var bymonthday = [].concat(this.options.bymonthday);
        var bynmonthday = [].concat(this.options.bynmonthday);
        bymonthday.sort(function(a3, b3) {
          return a3 - b3;
        });
        bynmonthday.sort(function(a3, b3) {
          return b3 - a3;
        });
        this.bymonthday = bymonthday.concat(bynmonthday);
        if (!this.bymonthday.length)
          this.bymonthday = null;
      }
      if (isPresent(this.origOptions.byweekday)) {
        var byweekday = !isArray(this.origOptions.byweekday) ? [this.origOptions.byweekday] : this.origOptions.byweekday;
        var days = String(byweekday);
        this.byweekday = {
          allWeeks: byweekday.filter(function(weekday) {
            return !weekday.n;
          }),
          someWeeks: byweekday.filter(function(weekday) {
            return Boolean(weekday.n);
          }),
          isWeekdays: days.indexOf("MO") !== -1 && days.indexOf("TU") !== -1 && days.indexOf("WE") !== -1 && days.indexOf("TH") !== -1 && days.indexOf("FR") !== -1 && days.indexOf("SA") === -1 && days.indexOf("SU") === -1,
          isEveryDay: days.indexOf("MO") !== -1 && days.indexOf("TU") !== -1 && days.indexOf("WE") !== -1 && days.indexOf("TH") !== -1 && days.indexOf("FR") !== -1 && days.indexOf("SA") !== -1 && days.indexOf("SU") !== -1
        };
        var sortWeekDays = function(a3, b3) {
          return a3.weekday - b3.weekday;
        };
        this.byweekday.allWeeks.sort(sortWeekDays);
        this.byweekday.someWeeks.sort(sortWeekDays);
        if (!this.byweekday.allWeeks.length)
          this.byweekday.allWeeks = null;
        if (!this.byweekday.someWeeks.length)
          this.byweekday.someWeeks = null;
      } else {
        this.byweekday = null;
      }
    }
    ToText2.isFullyConvertible = function(rrule) {
      var canConvert = true;
      if (!(rrule.options.freq in ToText2.IMPLEMENTED))
        return false;
      if (rrule.origOptions.until && rrule.origOptions.count)
        return false;
      for (var key in rrule.origOptions) {
        if (contains(["dtstart", "tzid", "wkst", "freq"], key))
          return true;
        if (!contains(ToText2.IMPLEMENTED[rrule.options.freq], key))
          return false;
      }
      return canConvert;
    };
    ToText2.prototype.isFullyConvertible = function() {
      return ToText2.isFullyConvertible(this.rrule);
    };
    ToText2.prototype.toString = function() {
      var gettext = this.gettext;
      if (!(this.options.freq in ToText2.IMPLEMENTED)) {
        return gettext("RRule error: Unable to fully convert this rrule to text");
      }
      this.text = [gettext("every")];
      this[RRule.FREQUENCIES[this.options.freq]]();
      if (this.options.until) {
        this.add(gettext("until"));
        var until = this.options.until;
        this.add(this.dateFormatter(until.getUTCFullYear(), this.language.monthNames[until.getUTCMonth()], until.getUTCDate()));
      } else if (this.options.count) {
        this.add(gettext("for")).add(this.options.count.toString()).add(this.plural(this.options.count) ? gettext("times") : gettext("time"));
      }
      if (!this.isFullyConvertible())
        this.add(gettext("(~ approximate)"));
      return this.text.join("");
    };
    ToText2.prototype.HOURLY = function() {
      var gettext = this.gettext;
      if (this.options.interval !== 1)
        this.add(this.options.interval.toString());
      this.add(this.plural(this.options.interval) ? gettext("hours") : gettext("hour"));
    };
    ToText2.prototype.MINUTELY = function() {
      var gettext = this.gettext;
      if (this.options.interval !== 1)
        this.add(this.options.interval.toString());
      this.add(this.plural(this.options.interval) ? gettext("minutes") : gettext("minute"));
    };
    ToText2.prototype.DAILY = function() {
      var gettext = this.gettext;
      if (this.options.interval !== 1)
        this.add(this.options.interval.toString());
      if (this.byweekday && this.byweekday.isWeekdays) {
        this.add(this.plural(this.options.interval) ? gettext("weekdays") : gettext("weekday"));
      } else {
        this.add(this.plural(this.options.interval) ? gettext("days") : gettext("day"));
      }
      if (this.origOptions.bymonth) {
        this.add(gettext("in"));
        this._bymonth();
      }
      if (this.bymonthday) {
        this._bymonthday();
      } else if (this.byweekday) {
        this._byweekday();
      } else if (this.origOptions.byhour) {
        this._byhour();
      }
    };
    ToText2.prototype.WEEKLY = function() {
      var gettext = this.gettext;
      if (this.options.interval !== 1) {
        this.add(this.options.interval.toString()).add(this.plural(this.options.interval) ? gettext("weeks") : gettext("week"));
      }
      if (this.byweekday && this.byweekday.isWeekdays) {
        if (this.options.interval === 1) {
          this.add(this.plural(this.options.interval) ? gettext("weekdays") : gettext("weekday"));
        } else {
          this.add(gettext("on")).add(gettext("weekdays"));
        }
      } else if (this.byweekday && this.byweekday.isEveryDay) {
        this.add(this.plural(this.options.interval) ? gettext("days") : gettext("day"));
      } else {
        if (this.options.interval === 1)
          this.add(gettext("week"));
        if (this.origOptions.bymonth) {
          this.add(gettext("in"));
          this._bymonth();
        }
        if (this.bymonthday) {
          this._bymonthday();
        } else if (this.byweekday) {
          this._byweekday();
        }
        if (this.origOptions.byhour) {
          this._byhour();
        }
      }
    };
    ToText2.prototype.MONTHLY = function() {
      var gettext = this.gettext;
      if (this.origOptions.bymonth) {
        if (this.options.interval !== 1) {
          this.add(this.options.interval.toString()).add(gettext("months"));
          if (this.plural(this.options.interval))
            this.add(gettext("in"));
        } else {
        }
        this._bymonth();
      } else {
        if (this.options.interval !== 1) {
          this.add(this.options.interval.toString());
        }
        this.add(this.plural(this.options.interval) ? gettext("months") : gettext("month"));
      }
      if (this.bymonthday) {
        this._bymonthday();
      } else if (this.byweekday && this.byweekday.isWeekdays) {
        this.add(gettext("on")).add(gettext("weekdays"));
      } else if (this.byweekday) {
        this._byweekday();
      }
    };
    ToText2.prototype.YEARLY = function() {
      var gettext = this.gettext;
      if (this.origOptions.bymonth) {
        if (this.options.interval !== 1) {
          this.add(this.options.interval.toString());
          this.add(gettext("years"));
        } else {
        }
        this._bymonth();
      } else {
        if (this.options.interval !== 1) {
          this.add(this.options.interval.toString());
        }
        this.add(this.plural(this.options.interval) ? gettext("years") : gettext("year"));
      }
      if (this.bymonthday) {
        this._bymonthday();
      } else if (this.byweekday) {
        this._byweekday();
      }
      if (this.options.byyearday) {
        this.add(gettext("on the")).add(this.list(this.options.byyearday, this.nth, gettext("and"))).add(gettext("day"));
      }
      if (this.options.byweekno) {
        this.add(gettext("in")).add(this.plural(this.options.byweekno.length) ? gettext("weeks") : gettext("week")).add(this.list(this.options.byweekno, void 0, gettext("and")));
      }
    };
    ToText2.prototype._bymonthday = function() {
      var gettext = this.gettext;
      if (this.byweekday && this.byweekday.allWeeks) {
        this.add(gettext("on")).add(this.list(this.byweekday.allWeeks, this.weekdaytext, gettext("or"))).add(gettext("the")).add(this.list(this.bymonthday, this.nth, gettext("or")));
      } else {
        this.add(gettext("on the")).add(this.list(this.bymonthday, this.nth, gettext("and")));
      }
    };
    ToText2.prototype._byweekday = function() {
      var gettext = this.gettext;
      if (this.byweekday.allWeeks && !this.byweekday.isWeekdays) {
        this.add(gettext("on")).add(this.list(this.byweekday.allWeeks, this.weekdaytext));
      }
      if (this.byweekday.someWeeks) {
        if (this.byweekday.allWeeks)
          this.add(gettext("and"));
        this.add(gettext("on the")).add(this.list(this.byweekday.someWeeks, this.weekdaytext, gettext("and")));
      }
    };
    ToText2.prototype._byhour = function() {
      var gettext = this.gettext;
      this.add(gettext("at")).add(this.list(this.origOptions.byhour, void 0, gettext("and")));
    };
    ToText2.prototype._bymonth = function() {
      this.add(this.list(this.options.bymonth, this.monthtext, this.gettext("and")));
    };
    ToText2.prototype.nth = function(n2) {
      n2 = parseInt(n2.toString(), 10);
      var nth;
      var gettext = this.gettext;
      if (n2 === -1)
        return gettext("last");
      var npos = Math.abs(n2);
      switch (npos) {
        case 1:
        case 21:
        case 31:
          nth = npos + gettext("st");
          break;
        case 2:
        case 22:
          nth = npos + gettext("nd");
          break;
        case 3:
        case 23:
          nth = npos + gettext("rd");
          break;
        default:
          nth = npos + gettext("th");
      }
      return n2 < 0 ? nth + " " + gettext("last") : nth;
    };
    ToText2.prototype.monthtext = function(m3) {
      return this.language.monthNames[m3 - 1];
    };
    ToText2.prototype.weekdaytext = function(wday) {
      var weekday = isNumber(wday) ? (wday + 1) % 7 : wday.getJsWeekday();
      return (wday.n ? this.nth(wday.n) + " " : "") + this.language.dayNames[weekday];
    };
    ToText2.prototype.plural = function(n2) {
      return n2 % 100 !== 1;
    };
    ToText2.prototype.add = function(s3) {
      this.text.push(" ");
      this.text.push(s3);
      return this;
    };
    ToText2.prototype.list = function(arr, callback, finalDelim, delim) {
      var _this = this;
      if (delim === void 0) {
        delim = ",";
      }
      if (!isArray(arr)) {
        arr = [arr];
      }
      var delimJoin = function(array, delimiter, finalDelimiter) {
        var list = "";
        for (var i3 = 0; i3 < array.length; i3++) {
          if (i3 !== 0) {
            if (i3 === array.length - 1) {
              list += " " + finalDelimiter + " ";
            } else {
              list += delimiter + " ";
            }
          }
          list += array[i3];
        }
        return list;
      };
      callback = callback || function(o2) {
        return o2.toString();
      };
      var realCallback = function(arg) {
        return callback && callback.call(_this, arg);
      };
      if (finalDelim) {
        return delimJoin(arr.map(realCallback), delim, finalDelim);
      } else {
        return arr.map(realCallback).join(delim + " ");
      }
    };
    return ToText2;
  }()
);
var totext_default = ToText;

// node_modules/rrule/dist/esm/nlp/parsetext.js
var Parser = (
  /** @class */
  function() {
    function Parser2(rules) {
      this.done = true;
      this.rules = rules;
    }
    Parser2.prototype.start = function(text) {
      this.text = text;
      this.done = false;
      return this.nextSymbol();
    };
    Parser2.prototype.isDone = function() {
      return this.done && this.symbol === null;
    };
    Parser2.prototype.nextSymbol = function() {
      var best;
      var bestSymbol;
      this.symbol = null;
      this.value = null;
      do {
        if (this.done)
          return false;
        var rule = void 0;
        best = null;
        for (var name_1 in this.rules) {
          rule = this.rules[name_1];
          var match = rule.exec(this.text);
          if (match) {
            if (best === null || match[0].length > best[0].length) {
              best = match;
              bestSymbol = name_1;
            }
          }
        }
        if (best != null) {
          this.text = this.text.substr(best[0].length);
          if (this.text === "")
            this.done = true;
        }
        if (best == null) {
          this.done = true;
          this.symbol = null;
          this.value = null;
          return;
        }
      } while (bestSymbol === "SKIP");
      this.symbol = bestSymbol;
      this.value = best;
      return true;
    };
    Parser2.prototype.accept = function(name) {
      if (this.symbol === name) {
        if (this.value) {
          var v3 = this.value;
          this.nextSymbol();
          return v3;
        }
        this.nextSymbol();
        return true;
      }
      return false;
    };
    Parser2.prototype.acceptNumber = function() {
      return this.accept("number");
    };
    Parser2.prototype.expect = function(name) {
      if (this.accept(name))
        return true;
      throw new Error("expected " + name + " but found " + this.symbol);
    };
    return Parser2;
  }()
);
function parseText(text, language) {
  if (language === void 0) {
    language = i18n_default;
  }
  var options = {};
  var ttr = new Parser(language.tokens);
  if (!ttr.start(text))
    return null;
  S2();
  return options;
  function S2() {
    ttr.expect("every");
    var n2 = ttr.acceptNumber();
    if (n2)
      options.interval = parseInt(n2[0], 10);
    if (ttr.isDone())
      throw new Error("Unexpected end");
    switch (ttr.symbol) {
      case "day(s)":
        options.freq = RRule.DAILY;
        if (ttr.nextSymbol()) {
          AT();
          F4();
        }
        break;
      case "weekday(s)":
        options.freq = RRule.WEEKLY;
        options.byweekday = [RRule.MO, RRule.TU, RRule.WE, RRule.TH, RRule.FR];
        ttr.nextSymbol();
        AT();
        F4();
        break;
      case "week(s)":
        options.freq = RRule.WEEKLY;
        if (ttr.nextSymbol()) {
          ON();
          AT();
          F4();
        }
        break;
      case "hour(s)":
        options.freq = RRule.HOURLY;
        if (ttr.nextSymbol()) {
          ON();
          F4();
        }
        break;
      case "minute(s)":
        options.freq = RRule.MINUTELY;
        if (ttr.nextSymbol()) {
          ON();
          F4();
        }
        break;
      case "month(s)":
        options.freq = RRule.MONTHLY;
        if (ttr.nextSymbol()) {
          ON();
          F4();
        }
        break;
      case "year(s)":
        options.freq = RRule.YEARLY;
        if (ttr.nextSymbol()) {
          ON();
          F4();
        }
        break;
      case "monday":
      case "tuesday":
      case "wednesday":
      case "thursday":
      case "friday":
      case "saturday":
      case "sunday":
        options.freq = RRule.WEEKLY;
        var key = ttr.symbol.substr(0, 2).toUpperCase();
        options.byweekday = [RRule[key]];
        if (!ttr.nextSymbol())
          return;
        while (ttr.accept("comma")) {
          if (ttr.isDone())
            throw new Error("Unexpected end");
          var wkd = decodeWKD();
          if (!wkd) {
            throw new Error("Unexpected symbol " + ttr.symbol + ", expected weekday");
          }
          options.byweekday.push(RRule[wkd]);
          ttr.nextSymbol();
        }
        AT();
        MDAYs();
        F4();
        break;
      case "january":
      case "february":
      case "march":
      case "april":
      case "may":
      case "june":
      case "july":
      case "august":
      case "september":
      case "october":
      case "november":
      case "december":
        options.freq = RRule.YEARLY;
        options.bymonth = [decodeM()];
        if (!ttr.nextSymbol())
          return;
        while (ttr.accept("comma")) {
          if (ttr.isDone())
            throw new Error("Unexpected end");
          var m3 = decodeM();
          if (!m3) {
            throw new Error("Unexpected symbol " + ttr.symbol + ", expected month");
          }
          options.bymonth.push(m3);
          ttr.nextSymbol();
        }
        ON();
        F4();
        break;
      default:
        throw new Error("Unknown symbol");
    }
  }
  function ON() {
    var on = ttr.accept("on");
    var the = ttr.accept("the");
    if (!(on || the))
      return;
    do {
      var nth = decodeNTH();
      var wkd = decodeWKD();
      var m3 = decodeM();
      if (nth) {
        if (wkd) {
          ttr.nextSymbol();
          if (!options.byweekday)
            options.byweekday = [];
          options.byweekday.push(RRule[wkd].nth(nth));
        } else {
          if (!options.bymonthday)
            options.bymonthday = [];
          options.bymonthday.push(nth);
          ttr.accept("day(s)");
        }
      } else if (wkd) {
        ttr.nextSymbol();
        if (!options.byweekday)
          options.byweekday = [];
        options.byweekday.push(RRule[wkd]);
      } else if (ttr.symbol === "weekday(s)") {
        ttr.nextSymbol();
        if (!options.byweekday) {
          options.byweekday = [RRule.MO, RRule.TU, RRule.WE, RRule.TH, RRule.FR];
        }
      } else if (ttr.symbol === "week(s)") {
        ttr.nextSymbol();
        var n2 = ttr.acceptNumber();
        if (!n2) {
          throw new Error("Unexpected symbol " + ttr.symbol + ", expected week number");
        }
        options.byweekno = [parseInt(n2[0], 10)];
        while (ttr.accept("comma")) {
          n2 = ttr.acceptNumber();
          if (!n2) {
            throw new Error("Unexpected symbol " + ttr.symbol + "; expected monthday");
          }
          options.byweekno.push(parseInt(n2[0], 10));
        }
      } else if (m3) {
        ttr.nextSymbol();
        if (!options.bymonth)
          options.bymonth = [];
        options.bymonth.push(m3);
      } else {
        return;
      }
    } while (ttr.accept("comma") || ttr.accept("the") || ttr.accept("on"));
  }
  function AT() {
    var at = ttr.accept("at");
    if (!at)
      return;
    do {
      var n2 = ttr.acceptNumber();
      if (!n2) {
        throw new Error("Unexpected symbol " + ttr.symbol + ", expected hour");
      }
      options.byhour = [parseInt(n2[0], 10)];
      while (ttr.accept("comma")) {
        n2 = ttr.acceptNumber();
        if (!n2) {
          throw new Error("Unexpected symbol " + ttr.symbol + "; expected hour");
        }
        options.byhour.push(parseInt(n2[0], 10));
      }
    } while (ttr.accept("comma") || ttr.accept("at"));
  }
  function decodeM() {
    switch (ttr.symbol) {
      case "january":
        return 1;
      case "february":
        return 2;
      case "march":
        return 3;
      case "april":
        return 4;
      case "may":
        return 5;
      case "june":
        return 6;
      case "july":
        return 7;
      case "august":
        return 8;
      case "september":
        return 9;
      case "october":
        return 10;
      case "november":
        return 11;
      case "december":
        return 12;
      default:
        return false;
    }
  }
  function decodeWKD() {
    switch (ttr.symbol) {
      case "monday":
      case "tuesday":
      case "wednesday":
      case "thursday":
      case "friday":
      case "saturday":
      case "sunday":
        return ttr.symbol.substr(0, 2).toUpperCase();
      default:
        return false;
    }
  }
  function decodeNTH() {
    switch (ttr.symbol) {
      case "last":
        ttr.nextSymbol();
        return -1;
      case "first":
        ttr.nextSymbol();
        return 1;
      case "second":
        ttr.nextSymbol();
        return ttr.accept("last") ? -2 : 2;
      case "third":
        ttr.nextSymbol();
        return ttr.accept("last") ? -3 : 3;
      case "nth":
        var v3 = parseInt(ttr.value[1], 10);
        if (v3 < -366 || v3 > 366)
          throw new Error("Nth out of range: " + v3);
        ttr.nextSymbol();
        return ttr.accept("last") ? -v3 : v3;
      default:
        return false;
    }
  }
  function MDAYs() {
    ttr.accept("on");
    ttr.accept("the");
    var nth = decodeNTH();
    if (!nth)
      return;
    options.bymonthday = [nth];
    ttr.nextSymbol();
    while (ttr.accept("comma")) {
      nth = decodeNTH();
      if (!nth) {
        throw new Error("Unexpected symbol " + ttr.symbol + "; expected monthday");
      }
      options.bymonthday.push(nth);
      ttr.nextSymbol();
    }
  }
  function F4() {
    if (ttr.symbol === "until") {
      var date = Date.parse(ttr.text);
      if (!date)
        throw new Error("Cannot parse until date:" + ttr.text);
      options.until = new Date(date);
    } else if (ttr.accept("for")) {
      options.count = parseInt(ttr.value[0], 10);
      ttr.expect("number");
    }
  }
}

// node_modules/rrule/dist/esm/types.js
var Frequency;
(function(Frequency2) {
  Frequency2[Frequency2["YEARLY"] = 0] = "YEARLY";
  Frequency2[Frequency2["MONTHLY"] = 1] = "MONTHLY";
  Frequency2[Frequency2["WEEKLY"] = 2] = "WEEKLY";
  Frequency2[Frequency2["DAILY"] = 3] = "DAILY";
  Frequency2[Frequency2["HOURLY"] = 4] = "HOURLY";
  Frequency2[Frequency2["MINUTELY"] = 5] = "MINUTELY";
  Frequency2[Frequency2["SECONDLY"] = 6] = "SECONDLY";
})(Frequency || (Frequency = {}));
function freqIsDailyOrGreater(freq) {
  return freq < Frequency.HOURLY;
}

// node_modules/rrule/dist/esm/nlp/index.js
var fromText = function(text, language) {
  if (language === void 0) {
    language = i18n_default;
  }
  return new RRule(parseText(text, language) || void 0);
};
var common = [
  "count",
  "until",
  "interval",
  "byweekday",
  "bymonthday",
  "bymonth"
];
totext_default.IMPLEMENTED = [];
totext_default.IMPLEMENTED[Frequency.HOURLY] = common;
totext_default.IMPLEMENTED[Frequency.MINUTELY] = common;
totext_default.IMPLEMENTED[Frequency.DAILY] = ["byhour"].concat(common);
totext_default.IMPLEMENTED[Frequency.WEEKLY] = common;
totext_default.IMPLEMENTED[Frequency.MONTHLY] = common;
totext_default.IMPLEMENTED[Frequency.YEARLY] = ["byweekno", "byyearday"].concat(common);
var toText = function(rrule, gettext, language, dateFormatter) {
  return new totext_default(rrule, gettext, language, dateFormatter).toString();
};
var isFullyConvertible = totext_default.isFullyConvertible;

// node_modules/rrule/dist/esm/datetime.js
var Time = (
  /** @class */
  function() {
    function Time2(hour, minute, second, millisecond) {
      this.hour = hour;
      this.minute = minute;
      this.second = second;
      this.millisecond = millisecond || 0;
    }
    Time2.prototype.getHours = function() {
      return this.hour;
    };
    Time2.prototype.getMinutes = function() {
      return this.minute;
    };
    Time2.prototype.getSeconds = function() {
      return this.second;
    };
    Time2.prototype.getMilliseconds = function() {
      return this.millisecond;
    };
    Time2.prototype.getTime = function() {
      return (this.hour * 60 * 60 + this.minute * 60 + this.second) * 1e3 + this.millisecond;
    };
    return Time2;
  }()
);
var DateTime = (
  /** @class */
  function(_super) {
    __extends(DateTime2, _super);
    function DateTime2(year, month, day, hour, minute, second, millisecond) {
      var _this = _super.call(this, hour, minute, second, millisecond) || this;
      _this.year = year;
      _this.month = month;
      _this.day = day;
      return _this;
    }
    DateTime2.fromDate = function(date) {
      return new this(date.getUTCFullYear(), date.getUTCMonth() + 1, date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.valueOf() % 1e3);
    };
    DateTime2.prototype.getWeekday = function() {
      return getWeekday(new Date(this.getTime()));
    };
    DateTime2.prototype.getTime = function() {
      return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond)).getTime();
    };
    DateTime2.prototype.getDay = function() {
      return this.day;
    };
    DateTime2.prototype.getMonth = function() {
      return this.month;
    };
    DateTime2.prototype.getYear = function() {
      return this.year;
    };
    DateTime2.prototype.addYears = function(years) {
      this.year += years;
    };
    DateTime2.prototype.addMonths = function(months) {
      this.month += months;
      if (this.month > 12) {
        var yearDiv = Math.floor(this.month / 12);
        var monthMod = pymod(this.month, 12);
        this.month = monthMod;
        this.year += yearDiv;
        if (this.month === 0) {
          this.month = 12;
          --this.year;
        }
      }
    };
    DateTime2.prototype.addWeekly = function(days, wkst) {
      if (wkst > this.getWeekday()) {
        this.day += -(this.getWeekday() + 1 + (6 - wkst)) + days * 7;
      } else {
        this.day += -(this.getWeekday() - wkst) + days * 7;
      }
      this.fixDay();
    };
    DateTime2.prototype.addDaily = function(days) {
      this.day += days;
      this.fixDay();
    };
    DateTime2.prototype.addHours = function(hours, filtered, byhour) {
      if (filtered) {
        this.hour += Math.floor((23 - this.hour) / hours) * hours;
      }
      for (; ; ) {
        this.hour += hours;
        var _a = divmod(this.hour, 24), dayDiv = _a.div, hourMod = _a.mod;
        if (dayDiv) {
          this.hour = hourMod;
          this.addDaily(dayDiv);
        }
        if (empty(byhour) || includes(byhour, this.hour))
          break;
      }
    };
    DateTime2.prototype.addMinutes = function(minutes, filtered, byhour, byminute) {
      if (filtered) {
        this.minute += Math.floor((1439 - (this.hour * 60 + this.minute)) / minutes) * minutes;
      }
      for (; ; ) {
        this.minute += minutes;
        var _a = divmod(this.minute, 60), hourDiv = _a.div, minuteMod = _a.mod;
        if (hourDiv) {
          this.minute = minuteMod;
          this.addHours(hourDiv, false, byhour);
        }
        if ((empty(byhour) || includes(byhour, this.hour)) && (empty(byminute) || includes(byminute, this.minute))) {
          break;
        }
      }
    };
    DateTime2.prototype.addSeconds = function(seconds, filtered, byhour, byminute, bysecond) {
      if (filtered) {
        this.second += Math.floor((86399 - (this.hour * 3600 + this.minute * 60 + this.second)) / seconds) * seconds;
      }
      for (; ; ) {
        this.second += seconds;
        var _a = divmod(this.second, 60), minuteDiv = _a.div, secondMod = _a.mod;
        if (minuteDiv) {
          this.second = secondMod;
          this.addMinutes(minuteDiv, false, byhour, byminute);
        }
        if ((empty(byhour) || includes(byhour, this.hour)) && (empty(byminute) || includes(byminute, this.minute)) && (empty(bysecond) || includes(bysecond, this.second))) {
          break;
        }
      }
    };
    DateTime2.prototype.fixDay = function() {
      if (this.day <= 28) {
        return;
      }
      var daysinmonth = monthRange(this.year, this.month - 1)[1];
      if (this.day <= daysinmonth) {
        return;
      }
      while (this.day > daysinmonth) {
        this.day -= daysinmonth;
        ++this.month;
        if (this.month === 13) {
          this.month = 1;
          ++this.year;
          if (this.year > MAXYEAR) {
            return;
          }
        }
        daysinmonth = monthRange(this.year, this.month - 1)[1];
      }
    };
    DateTime2.prototype.add = function(options, filtered) {
      var freq = options.freq, interval = options.interval, wkst = options.wkst, byhour = options.byhour, byminute = options.byminute, bysecond = options.bysecond;
      switch (freq) {
        case Frequency.YEARLY:
          return this.addYears(interval);
        case Frequency.MONTHLY:
          return this.addMonths(interval);
        case Frequency.WEEKLY:
          return this.addWeekly(interval, wkst);
        case Frequency.DAILY:
          return this.addDaily(interval);
        case Frequency.HOURLY:
          return this.addHours(interval, filtered, byhour);
        case Frequency.MINUTELY:
          return this.addMinutes(interval, filtered, byhour, byminute);
        case Frequency.SECONDLY:
          return this.addSeconds(interval, filtered, byhour, byminute, bysecond);
      }
    };
    return DateTime2;
  }(Time)
);

// node_modules/rrule/dist/esm/parseoptions.js
function initializeOptions(options) {
  var invalid = [];
  var keys = Object.keys(options);
  for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
    var key = keys_1[_i];
    if (!includes(defaultKeys, key))
      invalid.push(key);
    if (isDate(options[key]) && !isValidDate2(options[key])) {
      invalid.push(key);
    }
  }
  if (invalid.length) {
    throw new Error("Invalid options: " + invalid.join(", "));
  }
  return __assign({}, options);
}
function parseOptions(options) {
  var opts = __assign(__assign({}, DEFAULT_OPTIONS), initializeOptions(options));
  if (isPresent(opts.byeaster))
    opts.freq = RRule.YEARLY;
  if (!(isPresent(opts.freq) && RRule.FREQUENCIES[opts.freq])) {
    throw new Error("Invalid frequency: ".concat(opts.freq, " ").concat(options.freq));
  }
  if (!opts.dtstart)
    opts.dtstart = new Date(new Date().setMilliseconds(0));
  if (!isPresent(opts.wkst)) {
    opts.wkst = RRule.MO.weekday;
  } else if (isNumber(opts.wkst)) {
  } else {
    opts.wkst = opts.wkst.weekday;
  }
  if (isPresent(opts.bysetpos)) {
    if (isNumber(opts.bysetpos))
      opts.bysetpos = [opts.bysetpos];
    for (var i3 = 0; i3 < opts.bysetpos.length; i3++) {
      var v3 = opts.bysetpos[i3];
      if (v3 === 0 || !(v3 >= -366 && v3 <= 366)) {
        throw new Error("bysetpos must be between 1 and 366, or between -366 and -1");
      }
    }
  }
  if (!(Boolean(opts.byweekno) || notEmpty(opts.byweekno) || notEmpty(opts.byyearday) || Boolean(opts.bymonthday) || notEmpty(opts.bymonthday) || isPresent(opts.byweekday) || isPresent(opts.byeaster))) {
    switch (opts.freq) {
      case RRule.YEARLY:
        if (!opts.bymonth)
          opts.bymonth = opts.dtstart.getUTCMonth() + 1;
        opts.bymonthday = opts.dtstart.getUTCDate();
        break;
      case RRule.MONTHLY:
        opts.bymonthday = opts.dtstart.getUTCDate();
        break;
      case RRule.WEEKLY:
        opts.byweekday = [getWeekday(opts.dtstart)];
        break;
    }
  }
  if (isPresent(opts.bymonth) && !isArray(opts.bymonth)) {
    opts.bymonth = [opts.bymonth];
  }
  if (isPresent(opts.byyearday) && !isArray(opts.byyearday) && isNumber(opts.byyearday)) {
    opts.byyearday = [opts.byyearday];
  }
  if (!isPresent(opts.bymonthday)) {
    opts.bymonthday = [];
    opts.bynmonthday = [];
  } else if (isArray(opts.bymonthday)) {
    var bymonthday = [];
    var bynmonthday = [];
    for (var i3 = 0; i3 < opts.bymonthday.length; i3++) {
      var v3 = opts.bymonthday[i3];
      if (v3 > 0) {
        bymonthday.push(v3);
      } else if (v3 < 0) {
        bynmonthday.push(v3);
      }
    }
    opts.bymonthday = bymonthday;
    opts.bynmonthday = bynmonthday;
  } else if (opts.bymonthday < 0) {
    opts.bynmonthday = [opts.bymonthday];
    opts.bymonthday = [];
  } else {
    opts.bynmonthday = [];
    opts.bymonthday = [opts.bymonthday];
  }
  if (isPresent(opts.byweekno) && !isArray(opts.byweekno)) {
    opts.byweekno = [opts.byweekno];
  }
  if (!isPresent(opts.byweekday)) {
    opts.bynweekday = null;
  } else if (isNumber(opts.byweekday)) {
    opts.byweekday = [opts.byweekday];
    opts.bynweekday = null;
  } else if (isWeekdayStr(opts.byweekday)) {
    opts.byweekday = [Weekday.fromStr(opts.byweekday).weekday];
    opts.bynweekday = null;
  } else if (opts.byweekday instanceof Weekday) {
    if (!opts.byweekday.n || opts.freq > RRule.MONTHLY) {
      opts.byweekday = [opts.byweekday.weekday];
      opts.bynweekday = null;
    } else {
      opts.bynweekday = [[opts.byweekday.weekday, opts.byweekday.n]];
      opts.byweekday = null;
    }
  } else {
    var byweekday = [];
    var bynweekday = [];
    for (var i3 = 0; i3 < opts.byweekday.length; i3++) {
      var wday = opts.byweekday[i3];
      if (isNumber(wday)) {
        byweekday.push(wday);
        continue;
      } else if (isWeekdayStr(wday)) {
        byweekday.push(Weekday.fromStr(wday).weekday);
        continue;
      }
      if (!wday.n || opts.freq > RRule.MONTHLY) {
        byweekday.push(wday.weekday);
      } else {
        bynweekday.push([wday.weekday, wday.n]);
      }
    }
    opts.byweekday = notEmpty(byweekday) ? byweekday : null;
    opts.bynweekday = notEmpty(bynweekday) ? bynweekday : null;
  }
  if (!isPresent(opts.byhour)) {
    opts.byhour = opts.freq < RRule.HOURLY ? [opts.dtstart.getUTCHours()] : null;
  } else if (isNumber(opts.byhour)) {
    opts.byhour = [opts.byhour];
  }
  if (!isPresent(opts.byminute)) {
    opts.byminute = opts.freq < RRule.MINUTELY ? [opts.dtstart.getUTCMinutes()] : null;
  } else if (isNumber(opts.byminute)) {
    opts.byminute = [opts.byminute];
  }
  if (!isPresent(opts.bysecond)) {
    opts.bysecond = opts.freq < RRule.SECONDLY ? [opts.dtstart.getUTCSeconds()] : null;
  } else if (isNumber(opts.bysecond)) {
    opts.bysecond = [opts.bysecond];
  }
  return { parsedOptions: opts };
}
function buildTimeset(opts) {
  var millisecondModulo = opts.dtstart.getTime() % 1e3;
  if (!freqIsDailyOrGreater(opts.freq)) {
    return [];
  }
  var timeset = [];
  opts.byhour.forEach(function(hour) {
    opts.byminute.forEach(function(minute) {
      opts.bysecond.forEach(function(second) {
        timeset.push(new Time(hour, minute, second, millisecondModulo));
      });
    });
  });
  return timeset;
}

// node_modules/rrule/dist/esm/parsestring.js
function parseString2(rfcString) {
  var options = rfcString.split("\n").map(parseLine).filter(function(x4) {
    return x4 !== null;
  });
  return __assign(__assign({}, options[0]), options[1]);
}
function parseDtstart(line) {
  var options = {};
  var dtstartWithZone = /DTSTART(?:;TZID=([^:=]+?))?(?::|=)([^;\s]+)/i.exec(line);
  if (!dtstartWithZone) {
    return options;
  }
  var tzid = dtstartWithZone[1], dtstart = dtstartWithZone[2];
  if (tzid) {
    options.tzid = tzid;
  }
  options.dtstart = untilStringToDate(dtstart);
  return options;
}
function parseLine(rfcString) {
  rfcString = rfcString.replace(/^\s+|\s+$/, "");
  if (!rfcString.length)
    return null;
  var header = /^([A-Z]+?)[:;]/.exec(rfcString.toUpperCase());
  if (!header) {
    return parseRrule(rfcString);
  }
  var key = header[1];
  switch (key.toUpperCase()) {
    case "RRULE":
    case "EXRULE":
      return parseRrule(rfcString);
    case "DTSTART":
      return parseDtstart(rfcString);
    default:
      throw new Error("Unsupported RFC prop ".concat(key, " in ").concat(rfcString));
  }
}
function parseRrule(line) {
  var strippedLine = line.replace(/^RRULE:/i, "");
  var options = parseDtstart(strippedLine);
  var attrs = line.replace(/^(?:RRULE|EXRULE):/i, "").split(";");
  attrs.forEach(function(attr) {
    var _a = attr.split("="), key = _a[0], value = _a[1];
    switch (key.toUpperCase()) {
      case "FREQ":
        options.freq = Frequency[value.toUpperCase()];
        break;
      case "WKST":
        options.wkst = Days[value.toUpperCase()];
        break;
      case "COUNT":
      case "INTERVAL":
      case "BYSETPOS":
      case "BYMONTH":
      case "BYMONTHDAY":
      case "BYYEARDAY":
      case "BYWEEKNO":
      case "BYHOUR":
      case "BYMINUTE":
      case "BYSECOND":
        var num = parseNumber(value);
        var optionKey = key.toLowerCase();
        options[optionKey] = num;
        break;
      case "BYWEEKDAY":
      case "BYDAY":
        options.byweekday = parseWeekday(value);
        break;
      case "DTSTART":
      case "TZID":
        var dtstart = parseDtstart(line);
        options.tzid = dtstart.tzid;
        options.dtstart = dtstart.dtstart;
        break;
      case "UNTIL":
        options.until = untilStringToDate(value);
        break;
      case "BYEASTER":
        options.byeaster = Number(value);
        break;
      default:
        throw new Error("Unknown RRULE property '" + key + "'");
    }
  });
  return options;
}
function parseNumber(value) {
  if (value.indexOf(",") !== -1) {
    var values = value.split(",");
    return values.map(parseIndividualNumber);
  }
  return parseIndividualNumber(value);
}
function parseIndividualNumber(value) {
  if (/^[+-]?\d+$/.test(value)) {
    return Number(value);
  }
  return value;
}
function parseWeekday(value) {
  var days = value.split(",");
  return days.map(function(day) {
    if (day.length === 2) {
      return Days[day];
    }
    var parts = day.match(/^([+-]?\d{1,2})([A-Z]{2})$/);
    if (!parts || parts.length < 3) {
      throw new SyntaxError("Invalid weekday string: ".concat(day));
    }
    var n2 = Number(parts[1]);
    var wdaypart = parts[2];
    var wday = Days[wdaypart].weekday;
    return new Weekday(wday, n2);
  });
}

// node_modules/rrule/dist/esm/datewithzone.js
var DateWithZone = (
  /** @class */
  function() {
    function DateWithZone2(date, tzid) {
      if (isNaN(date.getTime())) {
        throw new RangeError("Invalid date passed to DateWithZone");
      }
      this.date = date;
      this.tzid = tzid;
    }
    Object.defineProperty(DateWithZone2.prototype, "isUTC", {
      get: function() {
        return !this.tzid || this.tzid.toUpperCase() === "UTC";
      },
      enumerable: false,
      configurable: true
    });
    DateWithZone2.prototype.toString = function() {
      var datestr = timeToUntilString(this.date.getTime(), this.isUTC);
      if (!this.isUTC) {
        return ";TZID=".concat(this.tzid, ":").concat(datestr);
      }
      return ":".concat(datestr);
    };
    DateWithZone2.prototype.getTime = function() {
      return this.date.getTime();
    };
    DateWithZone2.prototype.rezonedDate = function() {
      if (this.isUTC) {
        return this.date;
      }
      return dateInTimeZone(this.date, this.tzid);
    };
    return DateWithZone2;
  }()
);

// node_modules/rrule/dist/esm/optionstostring.js
function optionsToString(options) {
  var rrule = [];
  var dtstart = "";
  var keys = Object.keys(options);
  var defaultKeys2 = Object.keys(DEFAULT_OPTIONS);
  for (var i3 = 0; i3 < keys.length; i3++) {
    if (keys[i3] === "tzid")
      continue;
    if (!includes(defaultKeys2, keys[i3]))
      continue;
    var key = keys[i3].toUpperCase();
    var value = options[keys[i3]];
    var outValue = "";
    if (!isPresent(value) || isArray(value) && !value.length)
      continue;
    switch (key) {
      case "FREQ":
        outValue = RRule.FREQUENCIES[options.freq];
        break;
      case "WKST":
        if (isNumber(value)) {
          outValue = new Weekday(value).toString();
        } else {
          outValue = value.toString();
        }
        break;
      case "BYWEEKDAY":
        key = "BYDAY";
        outValue = toArray(value).map(function(wday) {
          if (wday instanceof Weekday) {
            return wday;
          }
          if (isArray(wday)) {
            return new Weekday(wday[0], wday[1]);
          }
          return new Weekday(wday);
        }).toString();
        break;
      case "DTSTART":
        dtstart = buildDtstart(value, options.tzid);
        break;
      case "UNTIL":
        outValue = timeToUntilString(value, !options.tzid);
        break;
      default:
        if (isArray(value)) {
          var strValues = [];
          for (var j4 = 0; j4 < value.length; j4++) {
            strValues[j4] = String(value[j4]);
          }
          outValue = strValues.toString();
        } else {
          outValue = String(value);
        }
    }
    if (outValue) {
      rrule.push([key, outValue]);
    }
  }
  var rules = rrule.map(function(_a) {
    var key2 = _a[0], value2 = _a[1];
    return "".concat(key2, "=").concat(value2.toString());
  }).join(";");
  var ruleString = "";
  if (rules !== "") {
    ruleString = "RRULE:".concat(rules);
  }
  return [dtstart, ruleString].filter(function(x4) {
    return !!x4;
  }).join("\n");
}
function buildDtstart(dtstart, tzid) {
  if (!dtstart) {
    return "";
  }
  return "DTSTART" + new DateWithZone(new Date(dtstart), tzid).toString();
}

// node_modules/rrule/dist/esm/cache.js
function argsMatch(left, right) {
  if (Array.isArray(left)) {
    if (!Array.isArray(right))
      return false;
    if (left.length !== right.length)
      return false;
    return left.every(function(date, i3) {
      return date.getTime() === right[i3].getTime();
    });
  }
  if (left instanceof Date) {
    return right instanceof Date && left.getTime() === right.getTime();
  }
  return left === right;
}
var Cache = (
  /** @class */
  function() {
    function Cache3() {
      this.all = false;
      this.before = [];
      this.after = [];
      this.between = [];
    }
    Cache3.prototype._cacheAdd = function(what, value, args) {
      if (value) {
        value = value instanceof Date ? clone(value) : cloneDates(value);
      }
      if (what === "all") {
        this.all = value;
      } else {
        args._value = value;
        this[what].push(args);
      }
    };
    Cache3.prototype._cacheGet = function(what, args) {
      var cached = false;
      var argsKeys = args ? Object.keys(args) : [];
      var findCacheDiff = function(item2) {
        for (var i4 = 0; i4 < argsKeys.length; i4++) {
          var key = argsKeys[i4];
          if (!argsMatch(args[key], item2[key])) {
            return true;
          }
        }
        return false;
      };
      var cachedObject = this[what];
      if (what === "all") {
        cached = this.all;
      } else if (isArray(cachedObject)) {
        for (var i3 = 0; i3 < cachedObject.length; i3++) {
          var item = cachedObject[i3];
          if (argsKeys.length && findCacheDiff(item))
            continue;
          cached = item._value;
          break;
        }
      }
      if (!cached && this.all) {
        var iterResult = new iterresult_default(what, args);
        for (var i3 = 0; i3 < this.all.length; i3++) {
          if (!iterResult.accept(this.all[i3]))
            break;
        }
        cached = iterResult.getValue();
        this._cacheAdd(what, cached, args);
      }
      return isArray(cached) ? cloneDates(cached) : cached instanceof Date ? clone(cached) : cached;
    };
    return Cache3;
  }()
);

// node_modules/rrule/dist/esm/masks.js
var M365MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], repeat(1, 31), true), repeat(2, 28), true), repeat(3, 31), true), repeat(4, 30), true), repeat(5, 31), true), repeat(6, 30), true), repeat(7, 31), true), repeat(8, 31), true), repeat(9, 30), true), repeat(10, 31), true), repeat(11, 30), true), repeat(12, 31), true), repeat(1, 7), true);
var M366MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], repeat(1, 31), true), repeat(2, 29), true), repeat(3, 31), true), repeat(4, 30), true), repeat(5, 31), true), repeat(6, 30), true), repeat(7, 31), true), repeat(8, 31), true), repeat(9, 30), true), repeat(10, 31), true), repeat(11, 30), true), repeat(12, 31), true), repeat(1, 7), true);
var M28 = range(1, 29);
var M29 = range(1, 30);
var M30 = range(1, 31);
var M31 = range(1, 32);
var MDAY366MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], M31, true), M29, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31.slice(0, 7), true);
var MDAY365MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], M31, true), M28, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31.slice(0, 7), true);
var NM28 = range(-28, 0);
var NM29 = range(-29, 0);
var NM30 = range(-30, 0);
var NM31 = range(-31, 0);
var NMDAY366MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], NM31, true), NM29, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31.slice(0, 7), true);
var NMDAY365MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], NM31, true), NM28, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31.slice(0, 7), true);
var M366RANGE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366];
var M365RANGE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365];
var WDAYMASK = function() {
  var wdaymask = [];
  for (var i3 = 0; i3 < 55; i3++)
    wdaymask = wdaymask.concat(range(7));
  return wdaymask;
}();

// node_modules/rrule/dist/esm/iterinfo/yearinfo.js
function rebuildYear(year, options) {
  var firstyday = datetime(year, 1, 1);
  var yearlen = isLeapYear(year) ? 366 : 365;
  var nextyearlen = isLeapYear(year + 1) ? 366 : 365;
  var yearordinal = toOrdinal(firstyday);
  var yearweekday = getWeekday(firstyday);
  var result = __assign(__assign({ yearlen, nextyearlen, yearordinal, yearweekday }, baseYearMasks(year)), { wnomask: null });
  if (empty(options.byweekno)) {
    return result;
  }
  result.wnomask = repeat(0, yearlen + 7);
  var firstwkst;
  var wyearlen;
  var no1wkst = firstwkst = pymod(7 - yearweekday + options.wkst, 7);
  if (no1wkst >= 4) {
    no1wkst = 0;
    wyearlen = result.yearlen + pymod(yearweekday - options.wkst, 7);
  } else {
    wyearlen = yearlen - no1wkst;
  }
  var div = Math.floor(wyearlen / 7);
  var mod = pymod(wyearlen, 7);
  var numweeks = Math.floor(div + mod / 4);
  for (var j4 = 0; j4 < options.byweekno.length; j4++) {
    var n2 = options.byweekno[j4];
    if (n2 < 0) {
      n2 += numweeks + 1;
    }
    if (!(n2 > 0 && n2 <= numweeks)) {
      continue;
    }
    var i3 = void 0;
    if (n2 > 1) {
      i3 = no1wkst + (n2 - 1) * 7;
      if (no1wkst !== firstwkst) {
        i3 -= 7 - firstwkst;
      }
    } else {
      i3 = no1wkst;
    }
    for (var k3 = 0; k3 < 7; k3++) {
      result.wnomask[i3] = 1;
      i3++;
      if (result.wdaymask[i3] === options.wkst)
        break;
    }
  }
  if (includes(options.byweekno, 1)) {
    var i3 = no1wkst + numweeks * 7;
    if (no1wkst !== firstwkst)
      i3 -= 7 - firstwkst;
    if (i3 < yearlen) {
      for (var j4 = 0; j4 < 7; j4++) {
        result.wnomask[i3] = 1;
        i3 += 1;
        if (result.wdaymask[i3] === options.wkst)
          break;
      }
    }
  }
  if (no1wkst) {
    var lnumweeks = void 0;
    if (!includes(options.byweekno, -1)) {
      var lyearweekday = getWeekday(datetime(year - 1, 1, 1));
      var lno1wkst = pymod(7 - lyearweekday.valueOf() + options.wkst, 7);
      var lyearlen = isLeapYear(year - 1) ? 366 : 365;
      var weekst = void 0;
      if (lno1wkst >= 4) {
        lno1wkst = 0;
        weekst = lyearlen + pymod(lyearweekday - options.wkst, 7);
      } else {
        weekst = yearlen - no1wkst;
      }
      lnumweeks = Math.floor(52 + pymod(weekst, 7) / 4);
    } else {
      lnumweeks = -1;
    }
    if (includes(options.byweekno, lnumweeks)) {
      for (var i3 = 0; i3 < no1wkst; i3++)
        result.wnomask[i3] = 1;
    }
  }
  return result;
}
function baseYearMasks(year) {
  var yearlen = isLeapYear(year) ? 366 : 365;
  var firstyday = datetime(year, 1, 1);
  var wday = getWeekday(firstyday);
  if (yearlen === 365) {
    return {
      mmask: M365MASK,
      mdaymask: MDAY365MASK,
      nmdaymask: NMDAY365MASK,
      wdaymask: WDAYMASK.slice(wday),
      mrange: M365RANGE
    };
  }
  return {
    mmask: M366MASK,
    mdaymask: MDAY366MASK,
    nmdaymask: NMDAY366MASK,
    wdaymask: WDAYMASK.slice(wday),
    mrange: M366RANGE
  };
}

// node_modules/rrule/dist/esm/iterinfo/monthinfo.js
function rebuildMonth(year, month, yearlen, mrange, wdaymask, options) {
  var result = {
    lastyear: year,
    lastmonth: month,
    nwdaymask: []
  };
  var ranges = [];
  if (options.freq === RRule.YEARLY) {
    if (empty(options.bymonth)) {
      ranges = [[0, yearlen]];
    } else {
      for (var j4 = 0; j4 < options.bymonth.length; j4++) {
        month = options.bymonth[j4];
        ranges.push(mrange.slice(month - 1, month + 1));
      }
    }
  } else if (options.freq === RRule.MONTHLY) {
    ranges = [mrange.slice(month - 1, month + 1)];
  }
  if (empty(ranges)) {
    return result;
  }
  result.nwdaymask = repeat(0, yearlen);
  for (var j4 = 0; j4 < ranges.length; j4++) {
    var rang = ranges[j4];
    var first = rang[0];
    var last = rang[1] - 1;
    for (var k3 = 0; k3 < options.bynweekday.length; k3++) {
      var i3 = void 0;
      var _a = options.bynweekday[k3], wday = _a[0], n2 = _a[1];
      if (n2 < 0) {
        i3 = last + (n2 + 1) * 7;
        i3 -= pymod(wdaymask[i3] - wday, 7);
      } else {
        i3 = first + (n2 - 1) * 7;
        i3 += pymod(7 - wdaymask[i3] + wday, 7);
      }
      if (first <= i3 && i3 <= last)
        result.nwdaymask[i3] = 1;
    }
  }
  return result;
}

// node_modules/rrule/dist/esm/iterinfo/easter.js
function easter(y3, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var a3 = y3 % 19;
  var b3 = Math.floor(y3 / 100);
  var c3 = y3 % 100;
  var d2 = Math.floor(b3 / 4);
  var e3 = b3 % 4;
  var f3 = Math.floor((b3 + 8) / 25);
  var g4 = Math.floor((b3 - f3 + 1) / 3);
  var h3 = Math.floor(19 * a3 + b3 - d2 - g4 + 15) % 30;
  var i3 = Math.floor(c3 / 4);
  var k3 = c3 % 4;
  var l3 = Math.floor(32 + 2 * e3 + 2 * i3 - h3 - k3) % 7;
  var m3 = Math.floor((a3 + 11 * h3 + 22 * l3) / 451);
  var month = Math.floor((h3 + l3 - 7 * m3 + 114) / 31);
  var day = (h3 + l3 - 7 * m3 + 114) % 31 + 1;
  var date = Date.UTC(y3, month - 1, day + offset);
  var yearStart = Date.UTC(y3, 0, 1);
  return [Math.ceil((date - yearStart) / (1e3 * 60 * 60 * 24))];
}

// node_modules/rrule/dist/esm/iterinfo/index.js
var Iterinfo = (
  /** @class */
  function() {
    function Iterinfo2(options) {
      this.options = options;
    }
    Iterinfo2.prototype.rebuild = function(year, month) {
      var options = this.options;
      if (year !== this.lastyear) {
        this.yearinfo = rebuildYear(year, options);
      }
      if (notEmpty(options.bynweekday) && (month !== this.lastmonth || year !== this.lastyear)) {
        var _a = this.yearinfo, yearlen = _a.yearlen, mrange = _a.mrange, wdaymask = _a.wdaymask;
        this.monthinfo = rebuildMonth(year, month, yearlen, mrange, wdaymask, options);
      }
      if (isPresent(options.byeaster)) {
        this.eastermask = easter(year, options.byeaster);
      }
    };
    Object.defineProperty(Iterinfo2.prototype, "lastyear", {
      get: function() {
        return this.monthinfo ? this.monthinfo.lastyear : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "lastmonth", {
      get: function() {
        return this.monthinfo ? this.monthinfo.lastmonth : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "yearlen", {
      get: function() {
        return this.yearinfo.yearlen;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "yearordinal", {
      get: function() {
        return this.yearinfo.yearordinal;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "mrange", {
      get: function() {
        return this.yearinfo.mrange;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "wdaymask", {
      get: function() {
        return this.yearinfo.wdaymask;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "mmask", {
      get: function() {
        return this.yearinfo.mmask;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "wnomask", {
      get: function() {
        return this.yearinfo.wnomask;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "nwdaymask", {
      get: function() {
        return this.monthinfo ? this.monthinfo.nwdaymask : [];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "nextyearlen", {
      get: function() {
        return this.yearinfo.nextyearlen;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "mdaymask", {
      get: function() {
        return this.yearinfo.mdaymask;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "nmdaymask", {
      get: function() {
        return this.yearinfo.nmdaymask;
      },
      enumerable: false,
      configurable: true
    });
    Iterinfo2.prototype.ydayset = function() {
      return [range(this.yearlen), 0, this.yearlen];
    };
    Iterinfo2.prototype.mdayset = function(_3, month) {
      var start = this.mrange[month - 1];
      var end = this.mrange[month];
      var set = repeat(null, this.yearlen);
      for (var i3 = start; i3 < end; i3++)
        set[i3] = i3;
      return [set, start, end];
    };
    Iterinfo2.prototype.wdayset = function(year, month, day) {
      var set = repeat(null, this.yearlen + 7);
      var i3 = toOrdinal(datetime(year, month, day)) - this.yearordinal;
      var start = i3;
      for (var j4 = 0; j4 < 7; j4++) {
        set[i3] = i3;
        ++i3;
        if (this.wdaymask[i3] === this.options.wkst)
          break;
      }
      return [set, start, i3];
    };
    Iterinfo2.prototype.ddayset = function(year, month, day) {
      var set = repeat(null, this.yearlen);
      var i3 = toOrdinal(datetime(year, month, day)) - this.yearordinal;
      set[i3] = i3;
      return [set, i3, i3 + 1];
    };
    Iterinfo2.prototype.htimeset = function(hour, _3, second, millisecond) {
      var _this = this;
      var set = [];
      this.options.byminute.forEach(function(minute) {
        set = set.concat(_this.mtimeset(hour, minute, second, millisecond));
      });
      sort(set);
      return set;
    };
    Iterinfo2.prototype.mtimeset = function(hour, minute, _3, millisecond) {
      var set = this.options.bysecond.map(function(second) {
        return new Time(hour, minute, second, millisecond);
      });
      sort(set);
      return set;
    };
    Iterinfo2.prototype.stimeset = function(hour, minute, second, millisecond) {
      return [new Time(hour, minute, second, millisecond)];
    };
    Iterinfo2.prototype.getdayset = function(freq) {
      switch (freq) {
        case Frequency.YEARLY:
          return this.ydayset.bind(this);
        case Frequency.MONTHLY:
          return this.mdayset.bind(this);
        case Frequency.WEEKLY:
          return this.wdayset.bind(this);
        case Frequency.DAILY:
          return this.ddayset.bind(this);
        default:
          return this.ddayset.bind(this);
      }
    };
    Iterinfo2.prototype.gettimeset = function(freq) {
      switch (freq) {
        case Frequency.HOURLY:
          return this.htimeset.bind(this);
        case Frequency.MINUTELY:
          return this.mtimeset.bind(this);
        case Frequency.SECONDLY:
          return this.stimeset.bind(this);
      }
    };
    return Iterinfo2;
  }()
);
var iterinfo_default = Iterinfo;

// node_modules/rrule/dist/esm/iter/poslist.js
function buildPoslist(bysetpos, timeset, start, end, ii, dayset) {
  var poslist = [];
  for (var j4 = 0; j4 < bysetpos.length; j4++) {
    var daypos = void 0;
    var timepos = void 0;
    var pos = bysetpos[j4];
    if (pos < 0) {
      daypos = Math.floor(pos / timeset.length);
      timepos = pymod(pos, timeset.length);
    } else {
      daypos = Math.floor((pos - 1) / timeset.length);
      timepos = pymod(pos - 1, timeset.length);
    }
    var tmp = [];
    for (var k3 = start; k3 < end; k3++) {
      var val = dayset[k3];
      if (!isPresent(val))
        continue;
      tmp.push(val);
    }
    var i3 = void 0;
    if (daypos < 0) {
      i3 = tmp.slice(daypos)[0];
    } else {
      i3 = tmp[daypos];
    }
    var time = timeset[timepos];
    var date = fromOrdinal(ii.yearordinal + i3);
    var res = combine(date, time);
    if (!includes(poslist, res))
      poslist.push(res);
  }
  sort(poslist);
  return poslist;
}

// node_modules/rrule/dist/esm/iter/index.js
function iter(iterResult, options) {
  var dtstart = options.dtstart, freq = options.freq, interval = options.interval, until = options.until, bysetpos = options.bysetpos;
  var count = options.count;
  if (count === 0 || interval === 0) {
    return emitResult(iterResult);
  }
  var counterDate = DateTime.fromDate(dtstart);
  var ii = new iterinfo_default(options);
  ii.rebuild(counterDate.year, counterDate.month);
  var timeset = makeTimeset(ii, counterDate, options);
  for (; ; ) {
    var _a = ii.getdayset(freq)(counterDate.year, counterDate.month, counterDate.day), dayset = _a[0], start = _a[1], end = _a[2];
    var filtered = removeFilteredDays(dayset, start, end, ii, options);
    if (notEmpty(bysetpos)) {
      var poslist = buildPoslist(bysetpos, timeset, start, end, ii, dayset);
      for (var j4 = 0; j4 < poslist.length; j4++) {
        var res = poslist[j4];
        if (until && res > until) {
          return emitResult(iterResult);
        }
        if (res >= dtstart) {
          var rezonedDate = rezoneIfNeeded(res, options);
          if (!iterResult.accept(rezonedDate)) {
            return emitResult(iterResult);
          }
          if (count) {
            --count;
            if (!count) {
              return emitResult(iterResult);
            }
          }
        }
      }
    } else {
      for (var j4 = start; j4 < end; j4++) {
        var currentDay = dayset[j4];
        if (!isPresent(currentDay)) {
          continue;
        }
        var date = fromOrdinal(ii.yearordinal + currentDay);
        for (var k3 = 0; k3 < timeset.length; k3++) {
          var time = timeset[k3];
          var res = combine(date, time);
          if (until && res > until) {
            return emitResult(iterResult);
          }
          if (res >= dtstart) {
            var rezonedDate = rezoneIfNeeded(res, options);
            if (!iterResult.accept(rezonedDate)) {
              return emitResult(iterResult);
            }
            if (count) {
              --count;
              if (!count) {
                return emitResult(iterResult);
              }
            }
          }
        }
      }
    }
    if (options.interval === 0) {
      return emitResult(iterResult);
    }
    counterDate.add(options, filtered);
    if (counterDate.year > MAXYEAR) {
      return emitResult(iterResult);
    }
    if (!freqIsDailyOrGreater(freq)) {
      timeset = ii.gettimeset(freq)(counterDate.hour, counterDate.minute, counterDate.second, 0);
    }
    ii.rebuild(counterDate.year, counterDate.month);
  }
}
function isFiltered(ii, currentDay, options) {
  var bymonth = options.bymonth, byweekno = options.byweekno, byweekday = options.byweekday, byeaster = options.byeaster, bymonthday = options.bymonthday, bynmonthday = options.bynmonthday, byyearday = options.byyearday;
  return notEmpty(bymonth) && !includes(bymonth, ii.mmask[currentDay]) || notEmpty(byweekno) && !ii.wnomask[currentDay] || notEmpty(byweekday) && !includes(byweekday, ii.wdaymask[currentDay]) || notEmpty(ii.nwdaymask) && !ii.nwdaymask[currentDay] || byeaster !== null && !includes(ii.eastermask, currentDay) || (notEmpty(bymonthday) || notEmpty(bynmonthday)) && !includes(bymonthday, ii.mdaymask[currentDay]) && !includes(bynmonthday, ii.nmdaymask[currentDay]) || notEmpty(byyearday) && (currentDay < ii.yearlen && !includes(byyearday, currentDay + 1) && !includes(byyearday, -ii.yearlen + currentDay) || currentDay >= ii.yearlen && !includes(byyearday, currentDay + 1 - ii.yearlen) && !includes(byyearday, -ii.nextyearlen + currentDay - ii.yearlen));
}
function rezoneIfNeeded(date, options) {
  return new DateWithZone(date, options.tzid).rezonedDate();
}
function emitResult(iterResult) {
  return iterResult.getValue();
}
function removeFilteredDays(dayset, start, end, ii, options) {
  var filtered = false;
  for (var dayCounter = start; dayCounter < end; dayCounter++) {
    var currentDay = dayset[dayCounter];
    filtered = isFiltered(ii, currentDay, options);
    if (filtered)
      dayset[currentDay] = null;
  }
  return filtered;
}
function makeTimeset(ii, counterDate, options) {
  var freq = options.freq, byhour = options.byhour, byminute = options.byminute, bysecond = options.bysecond;
  if (freqIsDailyOrGreater(freq)) {
    return buildTimeset(options);
  }
  if (freq >= RRule.HOURLY && notEmpty(byhour) && !includes(byhour, counterDate.hour) || freq >= RRule.MINUTELY && notEmpty(byminute) && !includes(byminute, counterDate.minute) || freq >= RRule.SECONDLY && notEmpty(bysecond) && !includes(bysecond, counterDate.second)) {
    return [];
  }
  return ii.gettimeset(freq)(counterDate.hour, counterDate.minute, counterDate.second, counterDate.millisecond);
}

// node_modules/rrule/dist/esm/rrule.js
var Days = {
  MO: new Weekday(0),
  TU: new Weekday(1),
  WE: new Weekday(2),
  TH: new Weekday(3),
  FR: new Weekday(4),
  SA: new Weekday(5),
  SU: new Weekday(6)
};
var DEFAULT_OPTIONS = {
  freq: Frequency.YEARLY,
  dtstart: null,
  interval: 1,
  wkst: Days.MO,
  count: null,
  until: null,
  tzid: null,
  bysetpos: null,
  bymonth: null,
  bymonthday: null,
  bynmonthday: null,
  byyearday: null,
  byweekno: null,
  byweekday: null,
  bynweekday: null,
  byhour: null,
  byminute: null,
  bysecond: null,
  byeaster: null
};
var defaultKeys = Object.keys(DEFAULT_OPTIONS);
var RRule = (
  /** @class */
  function() {
    function RRule2(options, noCache) {
      if (options === void 0) {
        options = {};
      }
      if (noCache === void 0) {
        noCache = false;
      }
      this._cache = noCache ? null : new Cache();
      this.origOptions = initializeOptions(options);
      var parsedOptions = parseOptions(options).parsedOptions;
      this.options = parsedOptions;
    }
    RRule2.parseText = function(text, language) {
      return parseText(text, language);
    };
    RRule2.fromText = function(text, language) {
      return fromText(text, language);
    };
    RRule2.fromString = function(str) {
      return new RRule2(RRule2.parseString(str) || void 0);
    };
    RRule2.prototype._iter = function(iterResult) {
      return iter(iterResult, this.options);
    };
    RRule2.prototype._cacheGet = function(what, args) {
      if (!this._cache)
        return false;
      return this._cache._cacheGet(what, args);
    };
    RRule2.prototype._cacheAdd = function(what, value, args) {
      if (!this._cache)
        return;
      return this._cache._cacheAdd(what, value, args);
    };
    RRule2.prototype.all = function(iterator) {
      if (iterator) {
        return this._iter(new callbackiterresult_default("all", {}, iterator));
      }
      var result = this._cacheGet("all");
      if (result === false) {
        result = this._iter(new iterresult_default("all", {}));
        this._cacheAdd("all", result);
      }
      return result;
    };
    RRule2.prototype.between = function(after, before, inc, iterator) {
      if (inc === void 0) {
        inc = false;
      }
      if (!isValidDate2(after) || !isValidDate2(before)) {
        throw new Error("Invalid date passed in to RRule.between");
      }
      var args = {
        before,
        after,
        inc
      };
      if (iterator) {
        return this._iter(new callbackiterresult_default("between", args, iterator));
      }
      var result = this._cacheGet("between", args);
      if (result === false) {
        result = this._iter(new iterresult_default("between", args));
        this._cacheAdd("between", result, args);
      }
      return result;
    };
    RRule2.prototype.before = function(dt, inc) {
      if (inc === void 0) {
        inc = false;
      }
      if (!isValidDate2(dt)) {
        throw new Error("Invalid date passed in to RRule.before");
      }
      var args = { dt, inc };
      var result = this._cacheGet("before", args);
      if (result === false) {
        result = this._iter(new iterresult_default("before", args));
        this._cacheAdd("before", result, args);
      }
      return result;
    };
    RRule2.prototype.after = function(dt, inc) {
      if (inc === void 0) {
        inc = false;
      }
      if (!isValidDate2(dt)) {
        throw new Error("Invalid date passed in to RRule.after");
      }
      var args = { dt, inc };
      var result = this._cacheGet("after", args);
      if (result === false) {
        result = this._iter(new iterresult_default("after", args));
        this._cacheAdd("after", result, args);
      }
      return result;
    };
    RRule2.prototype.count = function() {
      return this.all().length;
    };
    RRule2.prototype.toString = function() {
      return optionsToString(this.origOptions);
    };
    RRule2.prototype.toText = function(gettext, language, dateFormatter) {
      return toText(this, gettext, language, dateFormatter);
    };
    RRule2.prototype.isFullyConvertibleToText = function() {
      return isFullyConvertible(this);
    };
    RRule2.prototype.clone = function() {
      return new RRule2(this.origOptions);
    };
    RRule2.FREQUENCIES = [
      "YEARLY",
      "MONTHLY",
      "WEEKLY",
      "DAILY",
      "HOURLY",
      "MINUTELY",
      "SECONDLY"
    ];
    RRule2.YEARLY = Frequency.YEARLY;
    RRule2.MONTHLY = Frequency.MONTHLY;
    RRule2.WEEKLY = Frequency.WEEKLY;
    RRule2.DAILY = Frequency.DAILY;
    RRule2.HOURLY = Frequency.HOURLY;
    RRule2.MINUTELY = Frequency.MINUTELY;
    RRule2.SECONDLY = Frequency.SECONDLY;
    RRule2.MO = Days.MO;
    RRule2.TU = Days.TU;
    RRule2.WE = Days.WE;
    RRule2.TH = Days.TH;
    RRule2.FR = Days.FR;
    RRule2.SA = Days.SA;
    RRule2.SU = Days.SU;
    RRule2.parseString = parseString2;
    RRule2.optionsToString = optionsToString;
    return RRule2;
  }()
);

// node_modules/rrule/dist/esm/iterset.js
function iterSet(iterResult, _rrule, _exrule, _rdate, _exdate, tzid) {
  var _exdateHash = {};
  var _accept = iterResult.accept;
  function evalExdate(after, before) {
    _exrule.forEach(function(rrule) {
      rrule.between(after, before, true).forEach(function(date) {
        _exdateHash[Number(date)] = true;
      });
    });
  }
  _exdate.forEach(function(date) {
    var zonedDate2 = new DateWithZone(date, tzid).rezonedDate();
    _exdateHash[Number(zonedDate2)] = true;
  });
  iterResult.accept = function(date) {
    var dt = Number(date);
    if (isNaN(dt))
      return _accept.call(this, date);
    if (!_exdateHash[dt]) {
      evalExdate(new Date(dt - 1), new Date(dt + 1));
      if (!_exdateHash[dt]) {
        _exdateHash[dt] = true;
        return _accept.call(this, date);
      }
    }
    return true;
  };
  if (iterResult.method === "between") {
    evalExdate(iterResult.args.after, iterResult.args.before);
    iterResult.accept = function(date) {
      var dt = Number(date);
      if (!_exdateHash[dt]) {
        _exdateHash[dt] = true;
        return _accept.call(this, date);
      }
      return true;
    };
  }
  for (var i3 = 0; i3 < _rdate.length; i3++) {
    var zonedDate = new DateWithZone(_rdate[i3], tzid).rezonedDate();
    if (!iterResult.accept(new Date(zonedDate.getTime())))
      break;
  }
  _rrule.forEach(function(rrule) {
    iter(iterResult, rrule.options);
  });
  var res = iterResult._result;
  sort(res);
  switch (iterResult.method) {
    case "all":
    case "between":
      return res;
    case "before":
      return res.length && res[res.length - 1] || null;
    case "after":
    default:
      return res.length && res[0] || null;
  }
}

// node_modules/rrule/dist/esm/rrulestr.js
var DEFAULT_OPTIONS2 = {
  dtstart: null,
  cache: false,
  unfold: false,
  forceset: false,
  compatible: false,
  tzid: null
};
function parseInput(s3, options) {
  var rrulevals = [];
  var rdatevals = [];
  var exrulevals = [];
  var exdatevals = [];
  var parsedDtstart = parseDtstart(s3);
  var dtstart = parsedDtstart.dtstart;
  var tzid = parsedDtstart.tzid;
  var lines = splitIntoLines(s3, options.unfold);
  lines.forEach(function(line) {
    var _a;
    if (!line)
      return;
    var _b = breakDownLine(line), name = _b.name, parms = _b.parms, value = _b.value;
    switch (name.toUpperCase()) {
      case "RRULE":
        if (parms.length) {
          throw new Error("unsupported RRULE parm: ".concat(parms.join(",")));
        }
        rrulevals.push(parseString2(line));
        break;
      case "RDATE":
        var _c = (_a = /RDATE(?:;TZID=([^:=]+))?/i.exec(line)) !== null && _a !== void 0 ? _a : [], rdateTzid = _c[1];
        if (rdateTzid && !tzid) {
          tzid = rdateTzid;
        }
        rdatevals = rdatevals.concat(parseRDate(value, parms));
        break;
      case "EXRULE":
        if (parms.length) {
          throw new Error("unsupported EXRULE parm: ".concat(parms.join(",")));
        }
        exrulevals.push(parseString2(value));
        break;
      case "EXDATE":
        exdatevals = exdatevals.concat(parseRDate(value, parms));
        break;
      case "DTSTART":
        break;
      default:
        throw new Error("unsupported property: " + name);
    }
  });
  return {
    dtstart,
    tzid,
    rrulevals,
    rdatevals,
    exrulevals,
    exdatevals
  };
}
function buildRule(s3, options) {
  var _a = parseInput(s3, options), rrulevals = _a.rrulevals, rdatevals = _a.rdatevals, exrulevals = _a.exrulevals, exdatevals = _a.exdatevals, dtstart = _a.dtstart, tzid = _a.tzid;
  var noCache = options.cache === false;
  if (options.compatible) {
    options.forceset = true;
    options.unfold = true;
  }
  if (options.forceset || rrulevals.length > 1 || rdatevals.length || exrulevals.length || exdatevals.length) {
    var rset_1 = new RRuleSet(noCache);
    rset_1.dtstart(dtstart);
    rset_1.tzid(tzid || void 0);
    rrulevals.forEach(function(val2) {
      rset_1.rrule(new RRule(groomRruleOptions(val2, dtstart, tzid), noCache));
    });
    rdatevals.forEach(function(date) {
      rset_1.rdate(date);
    });
    exrulevals.forEach(function(val2) {
      rset_1.exrule(new RRule(groomRruleOptions(val2, dtstart, tzid), noCache));
    });
    exdatevals.forEach(function(date) {
      rset_1.exdate(date);
    });
    if (options.compatible && options.dtstart)
      rset_1.rdate(dtstart);
    return rset_1;
  }
  var val = rrulevals[0] || {};
  return new RRule(groomRruleOptions(val, val.dtstart || options.dtstart || dtstart, val.tzid || options.tzid || tzid), noCache);
}
function rrulestr(s3, options) {
  if (options === void 0) {
    options = {};
  }
  return buildRule(s3, initializeOptions2(options));
}
function groomRruleOptions(val, dtstart, tzid) {
  return __assign(__assign({}, val), { dtstart, tzid });
}
function initializeOptions2(options) {
  var invalid = [];
  var keys = Object.keys(options);
  var defaultKeys2 = Object.keys(DEFAULT_OPTIONS2);
  keys.forEach(function(key) {
    if (!includes(defaultKeys2, key))
      invalid.push(key);
  });
  if (invalid.length) {
    throw new Error("Invalid options: " + invalid.join(", "));
  }
  return __assign(__assign({}, DEFAULT_OPTIONS2), options);
}
function extractName(line) {
  if (line.indexOf(":") === -1) {
    return {
      name: "RRULE",
      value: line
    };
  }
  var _a = split(line, ":", 1), name = _a[0], value = _a[1];
  return {
    name,
    value
  };
}
function breakDownLine(line) {
  var _a = extractName(line), name = _a.name, value = _a.value;
  var parms = name.split(";");
  if (!parms)
    throw new Error("empty property name");
  return {
    name: parms[0].toUpperCase(),
    parms: parms.slice(1),
    value
  };
}
function splitIntoLines(s3, unfold) {
  if (unfold === void 0) {
    unfold = false;
  }
  s3 = s3 && s3.trim();
  if (!s3)
    throw new Error("Invalid empty string");
  if (!unfold) {
    return s3.split(/\s/);
  }
  var lines = s3.split("\n");
  var i3 = 0;
  while (i3 < lines.length) {
    var line = lines[i3] = lines[i3].replace(/\s+$/g, "");
    if (!line) {
      lines.splice(i3, 1);
    } else if (i3 > 0 && line[0] === " ") {
      lines[i3 - 1] += line.slice(1);
      lines.splice(i3, 1);
    } else {
      i3 += 1;
    }
  }
  return lines;
}
function validateDateParm(parms) {
  parms.forEach(function(parm) {
    if (!/(VALUE=DATE(-TIME)?)|(TZID=)/.test(parm)) {
      throw new Error("unsupported RDATE/EXDATE parm: " + parm);
    }
  });
}
function parseRDate(rdateval, parms) {
  validateDateParm(parms);
  return rdateval.split(",").map(function(datestr) {
    return untilStringToDate(datestr);
  });
}

// node_modules/rrule/dist/esm/rruleset.js
function createGetterSetter(fieldName) {
  var _this = this;
  return function(field) {
    if (field !== void 0) {
      _this["_".concat(fieldName)] = field;
    }
    if (_this["_".concat(fieldName)] !== void 0) {
      return _this["_".concat(fieldName)];
    }
    for (var i3 = 0; i3 < _this._rrule.length; i3++) {
      var field_1 = _this._rrule[i3].origOptions[fieldName];
      if (field_1) {
        return field_1;
      }
    }
  };
}
var RRuleSet = (
  /** @class */
  function(_super) {
    __extends(RRuleSet2, _super);
    function RRuleSet2(noCache) {
      if (noCache === void 0) {
        noCache = false;
      }
      var _this = _super.call(this, {}, noCache) || this;
      _this.dtstart = createGetterSetter.apply(_this, ["dtstart"]);
      _this.tzid = createGetterSetter.apply(_this, ["tzid"]);
      _this._rrule = [];
      _this._rdate = [];
      _this._exrule = [];
      _this._exdate = [];
      return _this;
    }
    RRuleSet2.prototype._iter = function(iterResult) {
      return iterSet(iterResult, this._rrule, this._exrule, this._rdate, this._exdate, this.tzid());
    };
    RRuleSet2.prototype.rrule = function(rrule) {
      _addRule(rrule, this._rrule);
    };
    RRuleSet2.prototype.exrule = function(rrule) {
      _addRule(rrule, this._exrule);
    };
    RRuleSet2.prototype.rdate = function(date) {
      _addDate(date, this._rdate);
    };
    RRuleSet2.prototype.exdate = function(date) {
      _addDate(date, this._exdate);
    };
    RRuleSet2.prototype.rrules = function() {
      return this._rrule.map(function(e3) {
        return rrulestr(e3.toString());
      });
    };
    RRuleSet2.prototype.exrules = function() {
      return this._exrule.map(function(e3) {
        return rrulestr(e3.toString());
      });
    };
    RRuleSet2.prototype.rdates = function() {
      return this._rdate.map(function(e3) {
        return new Date(e3.getTime());
      });
    };
    RRuleSet2.prototype.exdates = function() {
      return this._exdate.map(function(e3) {
        return new Date(e3.getTime());
      });
    };
    RRuleSet2.prototype.valueOf = function() {
      var result = [];
      if (!this._rrule.length && this._dtstart) {
        result = result.concat(optionsToString({ dtstart: this._dtstart }));
      }
      this._rrule.forEach(function(rrule) {
        result = result.concat(rrule.toString().split("\n"));
      });
      this._exrule.forEach(function(exrule) {
        result = result.concat(exrule.toString().split("\n").map(function(line) {
          return line.replace(/^RRULE:/, "EXRULE:");
        }).filter(function(line) {
          return !/^DTSTART/.test(line);
        }));
      });
      if (this._rdate.length) {
        result.push(rdatesToString("RDATE", this._rdate, this.tzid()));
      }
      if (this._exdate.length) {
        result.push(rdatesToString("EXDATE", this._exdate, this.tzid()));
      }
      return result;
    };
    RRuleSet2.prototype.toString = function() {
      return this.valueOf().join("\n");
    };
    RRuleSet2.prototype.clone = function() {
      var rrs = new RRuleSet2(!!this._cache);
      this._rrule.forEach(function(rule) {
        return rrs.rrule(rule.clone());
      });
      this._exrule.forEach(function(rule) {
        return rrs.exrule(rule.clone());
      });
      this._rdate.forEach(function(date) {
        return rrs.rdate(new Date(date.getTime()));
      });
      this._exdate.forEach(function(date) {
        return rrs.exdate(new Date(date.getTime()));
      });
      return rrs;
    };
    return RRuleSet2;
  }(RRule)
);
function _addRule(rrule, collection) {
  if (!(rrule instanceof RRule)) {
    throw new TypeError(String(rrule) + " is not RRule instance");
  }
  if (!includes(collection.map(String), String(rrule))) {
    collection.push(rrule);
  }
}
function _addDate(date, collection) {
  if (!(date instanceof Date)) {
    throw new TypeError(String(date) + " is not Date instance");
  }
  if (!includes(collection.map(Number), Number(date))) {
    collection.push(date);
    sort(collection);
  }
}
function rdatesToString(param, rdates, tzid) {
  var isUTC = !tzid || tzid.toUpperCase() === "UTC";
  var header = isUTC ? "".concat(param, ":") : "".concat(param, ";TZID=").concat(tzid, ":");
  var dateString = rdates.map(function(rdate) {
    return timeToUntilString(rdate.valueOf(), isUTC);
  }).join(",");
  return "".concat(header).concat(dateString);
}

// node_modules/@fullcalendar/rrule/index.js
var recurringType = {
  parse(eventProps, dateEnv) {
    if (eventProps.rrule != null) {
      let eventRRuleData = parseEventRRule(eventProps, dateEnv);
      if (eventRRuleData) {
        return {
          typeData: { rruleSet: eventRRuleData.rruleSet, isTimeZoneSpecified: eventRRuleData.isTimeZoneSpecified },
          allDayGuess: !eventRRuleData.isTimeSpecified,
          duration: eventProps.duration
        };
      }
    }
    return null;
  },
  expand(eventRRuleData, framingRange, dateEnv) {
    let dates;
    if (eventRRuleData.isTimeZoneSpecified) {
      dates = eventRRuleData.rruleSet.between(
        dateEnv.toDate(framingRange.start),
        // rrule lib will treat as UTC-zoned
        dateEnv.toDate(framingRange.end),
        // (same)
        true
      ).map((date) => dateEnv.createMarker(date));
    } else {
      dates = eventRRuleData.rruleSet.between(framingRange.start, framingRange.end, true);
    }
    return dates;
  }
};
function parseEventRRule(eventProps, dateEnv) {
  let rruleSet;
  let isTimeSpecified = false;
  let isTimeZoneSpecified = false;
  if (typeof eventProps.rrule === "string") {
    let res = parseRRuleString(eventProps.rrule);
    rruleSet = res.rruleSet;
    isTimeSpecified = res.isTimeSpecified;
    isTimeZoneSpecified = res.isTimeZoneSpecified;
  }
  if (typeof eventProps.rrule === "object" && eventProps.rrule) {
    let res = parseRRuleObject(eventProps.rrule, dateEnv);
    rruleSet = new RRuleSet();
    rruleSet.rrule(res.rrule);
    isTimeSpecified = res.isTimeSpecified;
    isTimeZoneSpecified = res.isTimeZoneSpecified;
  }
  let exdateInputs = [].concat(eventProps.exdate || []);
  let exruleInputs = [].concat(eventProps.exrule || []);
  for (let exdateInput of exdateInputs) {
    let res = parse(exdateInput);
    isTimeSpecified = isTimeSpecified || !res.isTimeUnspecified;
    isTimeZoneSpecified = isTimeZoneSpecified || res.timeZoneOffset !== null;
    rruleSet.exdate(new Date(res.marker.valueOf() - (res.timeZoneOffset || 0) * 60 * 1e3));
  }
  for (let exruleInput of exruleInputs) {
    let res = parseRRuleObject(exruleInput, dateEnv);
    isTimeSpecified = isTimeSpecified || res.isTimeSpecified;
    isTimeZoneSpecified = isTimeZoneSpecified || res.isTimeZoneSpecified;
    rruleSet.exrule(res.rrule);
  }
  return { rruleSet, isTimeSpecified, isTimeZoneSpecified };
}
function parseRRuleObject(rruleInput, dateEnv) {
  let isTimeSpecified = false;
  let isTimeZoneSpecified = false;
  function processDateInput(dateInput) {
    if (typeof dateInput === "string") {
      let markerData = parse(dateInput);
      if (markerData) {
        isTimeSpecified = isTimeSpecified || !markerData.isTimeUnspecified;
        isTimeZoneSpecified = isTimeZoneSpecified || markerData.timeZoneOffset !== null;
        return new Date(markerData.marker.valueOf() - (markerData.timeZoneOffset || 0) * 60 * 1e3);
      }
      return null;
    }
    return dateInput;
  }
  let rruleOptions = Object.assign(Object.assign({}, rruleInput), { dtstart: processDateInput(rruleInput.dtstart), until: processDateInput(rruleInput.until), freq: convertConstant(rruleInput.freq), wkst: rruleInput.wkst == null ? (dateEnv.weekDow - 1 + 7) % 7 : convertConstant(rruleInput.wkst), byweekday: convertConstants(rruleInput.byweekday) });
  return { rrule: new RRule(rruleOptions), isTimeSpecified, isTimeZoneSpecified };
}
function parseRRuleString(str) {
  let rruleSet = rrulestr(str, { forceset: true });
  let analysis = analyzeRRuleString(str);
  return Object.assign({ rruleSet }, analysis);
}
function analyzeRRuleString(str) {
  let isTimeSpecified = false;
  let isTimeZoneSpecified = false;
  function processMatch(whole, introPart, datePart) {
    let result = parse(datePart);
    isTimeSpecified = isTimeSpecified || !result.isTimeUnspecified;
    isTimeZoneSpecified = isTimeZoneSpecified || result.timeZoneOffset !== null;
  }
  str.replace(/\b(DTSTART:)([^\n]*)/, processMatch);
  str.replace(/\b(EXDATE:)([^\n]*)/, processMatch);
  str.replace(/\b(UNTIL=)([^;\n]*)/, processMatch);
  return { isTimeSpecified, isTimeZoneSpecified };
}
function convertConstants(input) {
  if (Array.isArray(input)) {
    return input.map(convertConstant);
  }
  return convertConstant(input);
}
function convertConstant(input) {
  if (typeof input === "string") {
    return RRule[input.toUpperCase()];
  }
  return input;
}
var RRULE_EVENT_REFINERS = {
  rrule: identity,
  exrule: identity,
  exdate: identity,
  duration: createDuration
};
var index3 = createPlugin({
  name: "@fullcalendar/rrule",
  recurringTypes: [recurringType],
  eventRefiners: RRULE_EVENT_REFINERS
});

// node_modules/@fullcalendar/list/internal.js
var ListViewHeaderRow = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.state = {
      textId: getUniqueDomId()
    };
  }
  render() {
    let { theme, dateEnv, options, viewApi } = this.context;
    let { cellId, dayDate, todayRange } = this.props;
    let { textId } = this.state;
    let dayMeta = getDateMeta(dayDate, todayRange);
    let text = options.listDayFormat ? dateEnv.format(dayDate, options.listDayFormat) : "";
    let sideText = options.listDaySideFormat ? dateEnv.format(dayDate, options.listDaySideFormat) : "";
    let renderProps = Object.assign({
      date: dateEnv.toDate(dayDate),
      view: viewApi,
      textId,
      text,
      sideText,
      navLinkAttrs: buildNavLinkAttrs(this.context, dayDate),
      sideNavLinkAttrs: buildNavLinkAttrs(this.context, dayDate, "day", false)
    }, dayMeta);
    return y(ContentContainer, { elTag: "tr", elClasses: [
      "fc-list-day",
      ...getDayClassNames(dayMeta, theme)
    ], elAttrs: {
      "data-date": formatDayString(dayDate)
    }, renderProps, generatorName: "dayHeaderContent", customGenerator: options.dayHeaderContent, defaultGenerator: renderInnerContent4, classNameGenerator: options.dayHeaderClassNames, didMount: options.dayHeaderDidMount, willUnmount: options.dayHeaderWillUnmount }, (InnerContent) => (
      // TODO: force-hide top border based on :first-child
      y(
        "th",
        { scope: "colgroup", colSpan: 3, id: cellId, "aria-labelledby": textId },
        y(InnerContent, { elTag: "div", elClasses: [
          "fc-list-day-cushion",
          theme.getClass("tableCellShaded")
        ] })
      )
    ));
  }
};
function renderInnerContent4(props) {
  return y(
    _,
    null,
    props.text && y("a", Object.assign({ id: props.textId, className: "fc-list-day-text" }, props.navLinkAttrs), props.text),
    props.sideText && /* not keyboard tabbable */
    y("a", Object.assign({ "aria-hidden": true, className: "fc-list-day-side-text" }, props.sideNavLinkAttrs), props.sideText)
  );
}
var DEFAULT_TIME_FORMAT2 = createFormatter({
  hour: "numeric",
  minute: "2-digit",
  meridiem: "short"
});
var ListViewEventRow = class extends BaseComponent {
  render() {
    let { props, context } = this;
    let { options } = context;
    let { seg, timeHeaderId, eventHeaderId, dateHeaderId } = props;
    let timeFormat = options.eventTimeFormat || DEFAULT_TIME_FORMAT2;
    return y(EventContainer, Object.assign({}, props, { elTag: "tr", elClasses: [
      "fc-list-event",
      seg.eventRange.def.url && "fc-event-forced-url"
    ], defaultGenerator: () => renderEventInnerContent(seg, context), seg, timeText: "", disableDragging: true, disableResizing: true }), (InnerContent, eventContentArg) => y(
      _,
      null,
      buildTimeContent(seg, timeFormat, context, timeHeaderId, dateHeaderId),
      y(
        "td",
        { "aria-hidden": true, className: "fc-list-event-graphic" },
        y("span", { className: "fc-list-event-dot", style: {
          borderColor: eventContentArg.borderColor || eventContentArg.backgroundColor
        } })
      ),
      y(InnerContent, { elTag: "td", elClasses: ["fc-list-event-title"], elAttrs: { headers: `${eventHeaderId} ${dateHeaderId}` } })
    ));
  }
};
function renderEventInnerContent(seg, context) {
  let interactiveAttrs = getSegAnchorAttrs(seg, context);
  return y("a", Object.assign({}, interactiveAttrs), seg.eventRange.def.title);
}
function buildTimeContent(seg, timeFormat, context, timeHeaderId, dateHeaderId) {
  let { options } = context;
  if (options.displayEventTime !== false) {
    let eventDef = seg.eventRange.def;
    let eventInstance = seg.eventRange.instance;
    let doAllDay = false;
    let timeText;
    if (eventDef.allDay) {
      doAllDay = true;
    } else if (isMultiDayRange(seg.eventRange.range)) {
      if (seg.isStart) {
        timeText = buildSegTimeText(seg, timeFormat, context, null, null, eventInstance.range.start, seg.end);
      } else if (seg.isEnd) {
        timeText = buildSegTimeText(seg, timeFormat, context, null, null, seg.start, eventInstance.range.end);
      } else {
        doAllDay = true;
      }
    } else {
      timeText = buildSegTimeText(seg, timeFormat, context);
    }
    if (doAllDay) {
      let renderProps = {
        text: context.options.allDayText,
        view: context.viewApi
      };
      return y(ContentContainer, { elTag: "td", elClasses: ["fc-list-event-time"], elAttrs: {
        headers: `${timeHeaderId} ${dateHeaderId}`
      }, renderProps, generatorName: "allDayContent", customGenerator: options.allDayContent, defaultGenerator: renderAllDayInner2, classNameGenerator: options.allDayClassNames, didMount: options.allDayDidMount, willUnmount: options.allDayWillUnmount });
    }
    return y("td", { className: "fc-list-event-time" }, timeText);
  }
  return null;
}
function renderAllDayInner2(renderProps) {
  return renderProps.text;
}
var ListView = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.computeDateVars = memoize(computeDateVars);
    this.eventStoreToSegs = memoize(this._eventStoreToSegs);
    this.state = {
      timeHeaderId: getUniqueDomId(),
      eventHeaderId: getUniqueDomId(),
      dateHeaderIdRoot: getUniqueDomId()
    };
    this.setRootEl = (rootEl) => {
      if (rootEl) {
        this.context.registerInteractiveComponent(this, {
          el: rootEl
        });
      } else {
        this.context.unregisterInteractiveComponent(this);
      }
    };
  }
  render() {
    let { props, context } = this;
    let { dayDates, dayRanges } = this.computeDateVars(props.dateProfile);
    let eventSegs = this.eventStoreToSegs(props.eventStore, props.eventUiBases, dayRanges);
    return y(
      ViewContainer,
      { elRef: this.setRootEl, elClasses: [
        "fc-list",
        context.theme.getClass("table"),
        context.options.stickyHeaderDates !== false ? "fc-list-sticky" : ""
      ], viewSpec: context.viewSpec },
      y(Scroller, { liquid: !props.isHeightAuto, overflowX: props.isHeightAuto ? "visible" : "hidden", overflowY: props.isHeightAuto ? "visible" : "auto" }, eventSegs.length > 0 ? this.renderSegList(eventSegs, dayDates) : this.renderEmptyMessage())
    );
  }
  renderEmptyMessage() {
    let { options, viewApi } = this.context;
    let renderProps = {
      text: options.noEventsText,
      view: viewApi
    };
    return y(ContentContainer, { elTag: "div", elClasses: ["fc-list-empty"], renderProps, generatorName: "noEventsContent", customGenerator: options.noEventsContent, defaultGenerator: renderNoEventsInner, classNameGenerator: options.noEventsClassNames, didMount: options.noEventsDidMount, willUnmount: options.noEventsWillUnmount }, (InnerContent) => y(InnerContent, { elTag: "div", elClasses: ["fc-list-empty-cushion"] }));
  }
  renderSegList(allSegs, dayDates) {
    let { theme, options } = this.context;
    let { timeHeaderId, eventHeaderId, dateHeaderIdRoot } = this.state;
    let segsByDay = groupSegsByDay(allSegs);
    return y(NowTimer, { unit: "day" }, (nowDate, todayRange) => {
      let innerNodes = [];
      for (let dayIndex = 0; dayIndex < segsByDay.length; dayIndex += 1) {
        let daySegs = segsByDay[dayIndex];
        if (daySegs) {
          let dayStr = formatDayString(dayDates[dayIndex]);
          let dateHeaderId = dateHeaderIdRoot + "-" + dayStr;
          innerNodes.push(y(ListViewHeaderRow, { key: dayStr, cellId: dateHeaderId, dayDate: dayDates[dayIndex], todayRange }));
          daySegs = sortEventSegs(daySegs, options.eventOrder);
          for (let seg of daySegs) {
            innerNodes.push(y(ListViewEventRow, Object.assign({ key: dayStr + ":" + seg.eventRange.instance.instanceId, seg, isDragging: false, isResizing: false, isDateSelecting: false, isSelected: false, timeHeaderId, eventHeaderId, dateHeaderId }, getSegMeta(seg, todayRange, nowDate))));
          }
        }
      }
      return y(
        "table",
        { className: "fc-list-table " + theme.getClass("table") },
        y(
          "thead",
          null,
          y(
            "tr",
            null,
            y("th", { scope: "col", id: timeHeaderId }, options.timeHint),
            y("th", { scope: "col", "aria-hidden": true }),
            y("th", { scope: "col", id: eventHeaderId }, options.eventHint)
          )
        ),
        y("tbody", null, innerNodes)
      );
    });
  }
  _eventStoreToSegs(eventStore, eventUiBases, dayRanges) {
    return this.eventRangesToSegs(sliceEventStore(eventStore, eventUiBases, this.props.dateProfile.activeRange, this.context.options.nextDayThreshold).fg, dayRanges);
  }
  eventRangesToSegs(eventRanges, dayRanges) {
    let segs = [];
    for (let eventRange of eventRanges) {
      segs.push(...this.eventRangeToSegs(eventRange, dayRanges));
    }
    return segs;
  }
  eventRangeToSegs(eventRange, dayRanges) {
    let { dateEnv } = this.context;
    let { nextDayThreshold } = this.context.options;
    let range2 = eventRange.range;
    let allDay = eventRange.def.allDay;
    let dayIndex;
    let segRange;
    let seg;
    let segs = [];
    for (dayIndex = 0; dayIndex < dayRanges.length; dayIndex += 1) {
      segRange = intersectRanges(range2, dayRanges[dayIndex]);
      if (segRange) {
        seg = {
          component: this,
          eventRange,
          start: segRange.start,
          end: segRange.end,
          isStart: eventRange.isStart && segRange.start.valueOf() === range2.start.valueOf(),
          isEnd: eventRange.isEnd && segRange.end.valueOf() === range2.end.valueOf(),
          dayIndex
        };
        segs.push(seg);
        if (!seg.isEnd && !allDay && dayIndex + 1 < dayRanges.length && range2.end < dateEnv.add(dayRanges[dayIndex + 1].start, nextDayThreshold)) {
          seg.end = range2.end;
          seg.isEnd = true;
          break;
        }
      }
    }
    return segs;
  }
};
function renderNoEventsInner(renderProps) {
  return renderProps.text;
}
function computeDateVars(dateProfile) {
  let dayStart = startOfDay(dateProfile.renderRange.start);
  let viewEnd = dateProfile.renderRange.end;
  let dayDates = [];
  let dayRanges = [];
  while (dayStart < viewEnd) {
    dayDates.push(dayStart);
    dayRanges.push({
      start: dayStart,
      end: addDays(dayStart, 1)
    });
    dayStart = addDays(dayStart, 1);
  }
  return { dayDates, dayRanges };
}
function groupSegsByDay(segs) {
  let segsByDay = [];
  let i3;
  let seg;
  for (i3 = 0; i3 < segs.length; i3 += 1) {
    seg = segs[i3];
    (segsByDay[seg.dayIndex] || (segsByDay[seg.dayIndex] = [])).push(seg);
  }
  return segsByDay;
}
var css_248z4 = ':root{--fc-list-event-dot-width:10px;--fc-list-event-hover-bg-color:#f5f5f5}.fc-theme-standard .fc-list{border:1px solid var(--fc-border-color)}.fc .fc-list-empty{align-items:center;background-color:var(--fc-neutral-bg-color);display:flex;height:100%;justify-content:center}.fc .fc-list-empty-cushion{margin:5em 0}.fc .fc-list-table{border-style:hidden;width:100%}.fc .fc-list-table tr>*{border-left:0;border-right:0}.fc .fc-list-sticky .fc-list-day>*{background:var(--fc-page-bg-color);position:sticky;top:0}.fc .fc-list-table thead{left:-10000px;position:absolute}.fc .fc-list-table tbody>tr:first-child th{border-top:0}.fc .fc-list-table th{padding:0}.fc .fc-list-day-cushion,.fc .fc-list-table td{padding:8px 14px}.fc .fc-list-day-cushion:after{clear:both;content:"";display:table}.fc-theme-standard .fc-list-day-cushion{background-color:var(--fc-neutral-bg-color)}.fc-direction-ltr .fc-list-day-text,.fc-direction-rtl .fc-list-day-side-text{float:left}.fc-direction-ltr .fc-list-day-side-text,.fc-direction-rtl .fc-list-day-text{float:right}.fc-direction-ltr .fc-list-table .fc-list-event-graphic{padding-right:0}.fc-direction-rtl .fc-list-table .fc-list-event-graphic{padding-left:0}.fc .fc-list-event.fc-event-forced-url{cursor:pointer}.fc .fc-list-event:hover td{background-color:var(--fc-list-event-hover-bg-color)}.fc .fc-list-event-graphic,.fc .fc-list-event-time{white-space:nowrap;width:1px}.fc .fc-list-event-dot{border:calc(var(--fc-list-event-dot-width)/2) solid var(--fc-event-border-color);border-radius:calc(var(--fc-list-event-dot-width)/2);box-sizing:content-box;display:inline-block;height:0;width:0}.fc .fc-list-event-title a{color:inherit;text-decoration:none}.fc .fc-list-event.fc-event-forced-url:hover a{text-decoration:underline}';
injectStyles(css_248z4);

// node_modules/@fullcalendar/list/index.js
var OPTION_REFINERS2 = {
  listDayFormat: createFalsableFormatter,
  listDaySideFormat: createFalsableFormatter,
  noEventsClassNames: identity,
  noEventsContent: identity,
  noEventsDidMount: identity,
  noEventsWillUnmount: identity
  // noEventsText is defined in base options
};
function createFalsableFormatter(input) {
  return input === false ? null : createFormatter(input);
}
var index4 = createPlugin({
  name: "@fullcalendar/list",
  optionRefiners: OPTION_REFINERS2,
  views: {
    list: {
      component: ListView,
      buttonTextKey: "list",
      listDayFormat: { month: "long", day: "numeric", year: "numeric" }
      // like "January 1, 2016"
    },
    listDay: {
      type: "list",
      duration: { days: 1 },
      listDayFormat: { weekday: "long" }
      // day-of-week is all we need. full date is probably in headerToolbar
    },
    listWeek: {
      type: "list",
      duration: { weeks: 1 },
      listDayFormat: { weekday: "long" },
      listDaySideFormat: { month: "long", day: "numeric", year: "numeric" }
    },
    listMonth: {
      type: "list",
      duration: { month: 1 },
      listDaySideFormat: { weekday: "long" }
      // day-of-week is nice-to-have
    },
    listYear: {
      type: "list",
      duration: { year: 1 },
      listDaySideFormat: { weekday: "long" }
      // day-of-week is nice-to-have
    }
  }
});

// node_modules/@fullcalendar/interaction/index.js
config.touchMouseIgnoreWait = 500;
var ignoreMouseDepth = 0;
var listenerCnt = 0;
var isWindowTouchMoveCancelled = false;
var PointerDragging = class {
  constructor(containerEl) {
    this.subjectEl = null;
    this.selector = "";
    this.handleSelector = "";
    this.shouldIgnoreMove = false;
    this.shouldWatchScroll = true;
    this.isDragging = false;
    this.isTouchDragging = false;
    this.wasTouchScroll = false;
    this.handleMouseDown = (ev) => {
      if (!this.shouldIgnoreMouse() && isPrimaryMouseButton(ev) && this.tryStart(ev)) {
        let pev = this.createEventFromMouse(ev, true);
        this.emitter.trigger("pointerdown", pev);
        this.initScrollWatch(pev);
        if (!this.shouldIgnoreMove) {
          document.addEventListener("mousemove", this.handleMouseMove);
        }
        document.addEventListener("mouseup", this.handleMouseUp);
      }
    };
    this.handleMouseMove = (ev) => {
      let pev = this.createEventFromMouse(ev);
      this.recordCoords(pev);
      this.emitter.trigger("pointermove", pev);
    };
    this.handleMouseUp = (ev) => {
      document.removeEventListener("mousemove", this.handleMouseMove);
      document.removeEventListener("mouseup", this.handleMouseUp);
      this.emitter.trigger("pointerup", this.createEventFromMouse(ev));
      this.cleanup();
    };
    this.handleTouchStart = (ev) => {
      if (this.tryStart(ev)) {
        this.isTouchDragging = true;
        let pev = this.createEventFromTouch(ev, true);
        this.emitter.trigger("pointerdown", pev);
        this.initScrollWatch(pev);
        let targetEl = ev.target;
        if (!this.shouldIgnoreMove) {
          targetEl.addEventListener("touchmove", this.handleTouchMove);
        }
        targetEl.addEventListener("touchend", this.handleTouchEnd);
        targetEl.addEventListener("touchcancel", this.handleTouchEnd);
        window.addEventListener("scroll", this.handleTouchScroll, true);
      }
    };
    this.handleTouchMove = (ev) => {
      let pev = this.createEventFromTouch(ev);
      this.recordCoords(pev);
      this.emitter.trigger("pointermove", pev);
    };
    this.handleTouchEnd = (ev) => {
      if (this.isDragging) {
        let targetEl = ev.target;
        targetEl.removeEventListener("touchmove", this.handleTouchMove);
        targetEl.removeEventListener("touchend", this.handleTouchEnd);
        targetEl.removeEventListener("touchcancel", this.handleTouchEnd);
        window.removeEventListener("scroll", this.handleTouchScroll, true);
        this.emitter.trigger("pointerup", this.createEventFromTouch(ev));
        this.cleanup();
        this.isTouchDragging = false;
        startIgnoringMouse();
      }
    };
    this.handleTouchScroll = () => {
      this.wasTouchScroll = true;
    };
    this.handleScroll = (ev) => {
      if (!this.shouldIgnoreMove) {
        let pageX = window.scrollX - this.prevScrollX + this.prevPageX;
        let pageY = window.scrollY - this.prevScrollY + this.prevPageY;
        this.emitter.trigger("pointermove", {
          origEvent: ev,
          isTouch: this.isTouchDragging,
          subjectEl: this.subjectEl,
          pageX,
          pageY,
          deltaX: pageX - this.origPageX,
          deltaY: pageY - this.origPageY
        });
      }
    };
    this.containerEl = containerEl;
    this.emitter = new Emitter();
    containerEl.addEventListener("mousedown", this.handleMouseDown);
    containerEl.addEventListener("touchstart", this.handleTouchStart, { passive: true });
    listenerCreated();
  }
  destroy() {
    this.containerEl.removeEventListener("mousedown", this.handleMouseDown);
    this.containerEl.removeEventListener("touchstart", this.handleTouchStart, { passive: true });
    listenerDestroyed();
  }
  tryStart(ev) {
    let subjectEl = this.querySubjectEl(ev);
    let downEl = ev.target;
    if (subjectEl && (!this.handleSelector || elementClosest(downEl, this.handleSelector))) {
      this.subjectEl = subjectEl;
      this.isDragging = true;
      this.wasTouchScroll = false;
      return true;
    }
    return false;
  }
  cleanup() {
    isWindowTouchMoveCancelled = false;
    this.isDragging = false;
    this.subjectEl = null;
    this.destroyScrollWatch();
  }
  querySubjectEl(ev) {
    if (this.selector) {
      return elementClosest(ev.target, this.selector);
    }
    return this.containerEl;
  }
  shouldIgnoreMouse() {
    return ignoreMouseDepth || this.isTouchDragging;
  }
  // can be called by user of this class, to cancel touch-based scrolling for the current drag
  cancelTouchScroll() {
    if (this.isDragging) {
      isWindowTouchMoveCancelled = true;
    }
  }
  // Scrolling that simulates pointermoves
  // ----------------------------------------------------------------------------------------------------
  initScrollWatch(ev) {
    if (this.shouldWatchScroll) {
      this.recordCoords(ev);
      window.addEventListener("scroll", this.handleScroll, true);
    }
  }
  recordCoords(ev) {
    if (this.shouldWatchScroll) {
      this.prevPageX = ev.pageX;
      this.prevPageY = ev.pageY;
      this.prevScrollX = window.scrollX;
      this.prevScrollY = window.scrollY;
    }
  }
  destroyScrollWatch() {
    if (this.shouldWatchScroll) {
      window.removeEventListener("scroll", this.handleScroll, true);
    }
  }
  // Event Normalization
  // ----------------------------------------------------------------------------------------------------
  createEventFromMouse(ev, isFirst) {
    let deltaX = 0;
    let deltaY = 0;
    if (isFirst) {
      this.origPageX = ev.pageX;
      this.origPageY = ev.pageY;
    } else {
      deltaX = ev.pageX - this.origPageX;
      deltaY = ev.pageY - this.origPageY;
    }
    return {
      origEvent: ev,
      isTouch: false,
      subjectEl: this.subjectEl,
      pageX: ev.pageX,
      pageY: ev.pageY,
      deltaX,
      deltaY
    };
  }
  createEventFromTouch(ev, isFirst) {
    let touches = ev.touches;
    let pageX;
    let pageY;
    let deltaX = 0;
    let deltaY = 0;
    if (touches && touches.length) {
      pageX = touches[0].pageX;
      pageY = touches[0].pageY;
    } else {
      pageX = ev.pageX;
      pageY = ev.pageY;
    }
    if (isFirst) {
      this.origPageX = pageX;
      this.origPageY = pageY;
    } else {
      deltaX = pageX - this.origPageX;
      deltaY = pageY - this.origPageY;
    }
    return {
      origEvent: ev,
      isTouch: true,
      subjectEl: this.subjectEl,
      pageX,
      pageY,
      deltaX,
      deltaY
    };
  }
};
function isPrimaryMouseButton(ev) {
  return ev.button === 0 && !ev.ctrlKey;
}
function startIgnoringMouse() {
  ignoreMouseDepth += 1;
  setTimeout(() => {
    ignoreMouseDepth -= 1;
  }, config.touchMouseIgnoreWait);
}
function listenerCreated() {
  listenerCnt += 1;
  if (listenerCnt === 1) {
    window.addEventListener("touchmove", onWindowTouchMove, { passive: false });
  }
}
function listenerDestroyed() {
  listenerCnt -= 1;
  if (!listenerCnt) {
    window.removeEventListener("touchmove", onWindowTouchMove, { passive: false });
  }
}
function onWindowTouchMove(ev) {
  if (isWindowTouchMoveCancelled) {
    ev.preventDefault();
  }
}
var ElementMirror = class {
  constructor() {
    this.isVisible = false;
    this.sourceEl = null;
    this.mirrorEl = null;
    this.sourceElRect = null;
    this.parentNode = document.body;
    this.zIndex = 9999;
    this.revertDuration = 0;
  }
  start(sourceEl, pageX, pageY) {
    this.sourceEl = sourceEl;
    this.sourceElRect = this.sourceEl.getBoundingClientRect();
    this.origScreenX = pageX - window.scrollX;
    this.origScreenY = pageY - window.scrollY;
    this.deltaX = 0;
    this.deltaY = 0;
    this.updateElPosition();
  }
  handleMove(pageX, pageY) {
    this.deltaX = pageX - window.scrollX - this.origScreenX;
    this.deltaY = pageY - window.scrollY - this.origScreenY;
    this.updateElPosition();
  }
  // can be called before start
  setIsVisible(bool) {
    if (bool) {
      if (!this.isVisible) {
        if (this.mirrorEl) {
          this.mirrorEl.style.display = "";
        }
        this.isVisible = bool;
        this.updateElPosition();
      }
    } else if (this.isVisible) {
      if (this.mirrorEl) {
        this.mirrorEl.style.display = "none";
      }
      this.isVisible = bool;
    }
  }
  // always async
  stop(needsRevertAnimation, callback) {
    let done = () => {
      this.cleanup();
      callback();
    };
    if (needsRevertAnimation && this.mirrorEl && this.isVisible && this.revertDuration && // if 0, transition won't work
    (this.deltaX || this.deltaY)) {
      this.doRevertAnimation(done, this.revertDuration);
    } else {
      setTimeout(done, 0);
    }
  }
  doRevertAnimation(callback, revertDuration) {
    let mirrorEl = this.mirrorEl;
    let finalSourceElRect = this.sourceEl.getBoundingClientRect();
    mirrorEl.style.transition = "top " + revertDuration + "ms,left " + revertDuration + "ms";
    applyStyle(mirrorEl, {
      left: finalSourceElRect.left,
      top: finalSourceElRect.top
    });
    whenTransitionDone(mirrorEl, () => {
      mirrorEl.style.transition = "";
      callback();
    });
  }
  cleanup() {
    if (this.mirrorEl) {
      removeElement(this.mirrorEl);
      this.mirrorEl = null;
    }
    this.sourceEl = null;
  }
  updateElPosition() {
    if (this.sourceEl && this.isVisible) {
      applyStyle(this.getMirrorEl(), {
        left: this.sourceElRect.left + this.deltaX,
        top: this.sourceElRect.top + this.deltaY
      });
    }
  }
  getMirrorEl() {
    let sourceElRect = this.sourceElRect;
    let mirrorEl = this.mirrorEl;
    if (!mirrorEl) {
      mirrorEl = this.mirrorEl = this.sourceEl.cloneNode(true);
      mirrorEl.style.userSelect = "none";
      mirrorEl.style.webkitUserSelect = "none";
      mirrorEl.style.pointerEvents = "none";
      mirrorEl.classList.add("fc-event-dragging");
      applyStyle(mirrorEl, {
        position: "fixed",
        zIndex: this.zIndex,
        visibility: "",
        boxSizing: "border-box",
        width: sourceElRect.right - sourceElRect.left,
        height: sourceElRect.bottom - sourceElRect.top,
        right: "auto",
        bottom: "auto",
        margin: 0
      });
      this.parentNode.appendChild(mirrorEl);
    }
    return mirrorEl;
  }
};
var ScrollGeomCache = class extends ScrollController {
  constructor(scrollController, doesListening) {
    super();
    this.handleScroll = () => {
      this.scrollTop = this.scrollController.getScrollTop();
      this.scrollLeft = this.scrollController.getScrollLeft();
      this.handleScrollChange();
    };
    this.scrollController = scrollController;
    this.doesListening = doesListening;
    this.scrollTop = this.origScrollTop = scrollController.getScrollTop();
    this.scrollLeft = this.origScrollLeft = scrollController.getScrollLeft();
    this.scrollWidth = scrollController.getScrollWidth();
    this.scrollHeight = scrollController.getScrollHeight();
    this.clientWidth = scrollController.getClientWidth();
    this.clientHeight = scrollController.getClientHeight();
    this.clientRect = this.computeClientRect();
    if (this.doesListening) {
      this.getEventTarget().addEventListener("scroll", this.handleScroll);
    }
  }
  destroy() {
    if (this.doesListening) {
      this.getEventTarget().removeEventListener("scroll", this.handleScroll);
    }
  }
  getScrollTop() {
    return this.scrollTop;
  }
  getScrollLeft() {
    return this.scrollLeft;
  }
  setScrollTop(top) {
    this.scrollController.setScrollTop(top);
    if (!this.doesListening) {
      this.scrollTop = Math.max(Math.min(top, this.getMaxScrollTop()), 0);
      this.handleScrollChange();
    }
  }
  setScrollLeft(top) {
    this.scrollController.setScrollLeft(top);
    if (!this.doesListening) {
      this.scrollLeft = Math.max(Math.min(top, this.getMaxScrollLeft()), 0);
      this.handleScrollChange();
    }
  }
  getClientWidth() {
    return this.clientWidth;
  }
  getClientHeight() {
    return this.clientHeight;
  }
  getScrollWidth() {
    return this.scrollWidth;
  }
  getScrollHeight() {
    return this.scrollHeight;
  }
  handleScrollChange() {
  }
};
var ElementScrollGeomCache = class extends ScrollGeomCache {
  constructor(el, doesListening) {
    super(new ElementScrollController(el), doesListening);
  }
  getEventTarget() {
    return this.scrollController.el;
  }
  computeClientRect() {
    return computeInnerRect(this.scrollController.el);
  }
};
var WindowScrollGeomCache = class extends ScrollGeomCache {
  constructor(doesListening) {
    super(new WindowScrollController(), doesListening);
  }
  getEventTarget() {
    return window;
  }
  computeClientRect() {
    return {
      left: this.scrollLeft,
      right: this.scrollLeft + this.clientWidth,
      top: this.scrollTop,
      bottom: this.scrollTop + this.clientHeight
    };
  }
  // the window is the only scroll object that changes it's rectangle relative
  // to the document's topleft as it scrolls
  handleScrollChange() {
    this.clientRect = this.computeClientRect();
  }
};
var getTime = typeof performance === "function" ? performance.now : Date.now;
var AutoScroller = class {
  constructor() {
    this.isEnabled = true;
    this.scrollQuery = [window, ".fc-scroller"];
    this.edgeThreshold = 50;
    this.maxVelocity = 300;
    this.pointerScreenX = null;
    this.pointerScreenY = null;
    this.isAnimating = false;
    this.scrollCaches = null;
    this.everMovedUp = false;
    this.everMovedDown = false;
    this.everMovedLeft = false;
    this.everMovedRight = false;
    this.animate = () => {
      if (this.isAnimating) {
        let edge = this.computeBestEdge(this.pointerScreenX + window.scrollX, this.pointerScreenY + window.scrollY);
        if (edge) {
          let now = getTime();
          this.handleSide(edge, (now - this.msSinceRequest) / 1e3);
          this.requestAnimation(now);
        } else {
          this.isAnimating = false;
        }
      }
    };
  }
  start(pageX, pageY, scrollStartEl) {
    if (this.isEnabled) {
      this.scrollCaches = this.buildCaches(scrollStartEl);
      this.pointerScreenX = null;
      this.pointerScreenY = null;
      this.everMovedUp = false;
      this.everMovedDown = false;
      this.everMovedLeft = false;
      this.everMovedRight = false;
      this.handleMove(pageX, pageY);
    }
  }
  handleMove(pageX, pageY) {
    if (this.isEnabled) {
      let pointerScreenX = pageX - window.scrollX;
      let pointerScreenY = pageY - window.scrollY;
      let yDelta = this.pointerScreenY === null ? 0 : pointerScreenY - this.pointerScreenY;
      let xDelta = this.pointerScreenX === null ? 0 : pointerScreenX - this.pointerScreenX;
      if (yDelta < 0) {
        this.everMovedUp = true;
      } else if (yDelta > 0) {
        this.everMovedDown = true;
      }
      if (xDelta < 0) {
        this.everMovedLeft = true;
      } else if (xDelta > 0) {
        this.everMovedRight = true;
      }
      this.pointerScreenX = pointerScreenX;
      this.pointerScreenY = pointerScreenY;
      if (!this.isAnimating) {
        this.isAnimating = true;
        this.requestAnimation(getTime());
      }
    }
  }
  stop() {
    if (this.isEnabled) {
      this.isAnimating = false;
      for (let scrollCache of this.scrollCaches) {
        scrollCache.destroy();
      }
      this.scrollCaches = null;
    }
  }
  requestAnimation(now) {
    this.msSinceRequest = now;
    requestAnimationFrame(this.animate);
  }
  handleSide(edge, seconds) {
    let { scrollCache } = edge;
    let { edgeThreshold } = this;
    let invDistance = edgeThreshold - edge.distance;
    let velocity = (
      // the closer to the edge, the faster we scroll
      invDistance * invDistance / (edgeThreshold * edgeThreshold) * // quadratic
      this.maxVelocity * seconds
    );
    let sign = 1;
    switch (edge.name) {
      case "left":
        sign = -1;
      case "right":
        scrollCache.setScrollLeft(scrollCache.getScrollLeft() + velocity * sign);
        break;
      case "top":
        sign = -1;
      case "bottom":
        scrollCache.setScrollTop(scrollCache.getScrollTop() + velocity * sign);
        break;
    }
  }
  // left/top are relative to document topleft
  computeBestEdge(left, top) {
    let { edgeThreshold } = this;
    let bestSide = null;
    let scrollCaches = this.scrollCaches || [];
    for (let scrollCache of scrollCaches) {
      let rect = scrollCache.clientRect;
      let leftDist = left - rect.left;
      let rightDist = rect.right - left;
      let topDist = top - rect.top;
      let bottomDist = rect.bottom - top;
      if (leftDist >= 0 && rightDist >= 0 && topDist >= 0 && bottomDist >= 0) {
        if (topDist <= edgeThreshold && this.everMovedUp && scrollCache.canScrollUp() && (!bestSide || bestSide.distance > topDist)) {
          bestSide = { scrollCache, name: "top", distance: topDist };
        }
        if (bottomDist <= edgeThreshold && this.everMovedDown && scrollCache.canScrollDown() && (!bestSide || bestSide.distance > bottomDist)) {
          bestSide = { scrollCache, name: "bottom", distance: bottomDist };
        }
        if (leftDist <= edgeThreshold && this.everMovedLeft && scrollCache.canScrollLeft() && (!bestSide || bestSide.distance > leftDist)) {
          bestSide = { scrollCache, name: "left", distance: leftDist };
        }
        if (rightDist <= edgeThreshold && this.everMovedRight && scrollCache.canScrollRight() && (!bestSide || bestSide.distance > rightDist)) {
          bestSide = { scrollCache, name: "right", distance: rightDist };
        }
      }
    }
    return bestSide;
  }
  buildCaches(scrollStartEl) {
    return this.queryScrollEls(scrollStartEl).map((el) => {
      if (el === window) {
        return new WindowScrollGeomCache(false);
      }
      return new ElementScrollGeomCache(el, false);
    });
  }
  queryScrollEls(scrollStartEl) {
    let els = [];
    for (let query of this.scrollQuery) {
      if (typeof query === "object") {
        els.push(query);
      } else {
        els.push(...Array.prototype.slice.call(scrollStartEl.getRootNode().querySelectorAll(query)));
      }
    }
    return els;
  }
};
var FeaturefulElementDragging = class extends ElementDragging {
  constructor(containerEl, selector) {
    super(containerEl);
    this.containerEl = containerEl;
    this.delay = null;
    this.minDistance = 0;
    this.touchScrollAllowed = true;
    this.mirrorNeedsRevert = false;
    this.isInteracting = false;
    this.isDragging = false;
    this.isDelayEnded = false;
    this.isDistanceSurpassed = false;
    this.delayTimeoutId = null;
    this.onPointerDown = (ev) => {
      if (!this.isDragging) {
        this.isInteracting = true;
        this.isDelayEnded = false;
        this.isDistanceSurpassed = false;
        preventSelection(document.body);
        preventContextMenu(document.body);
        if (!ev.isTouch) {
          ev.origEvent.preventDefault();
        }
        this.emitter.trigger("pointerdown", ev);
        if (this.isInteracting && // not destroyed via pointerdown handler
        !this.pointer.shouldIgnoreMove) {
          this.mirror.setIsVisible(false);
          this.mirror.start(ev.subjectEl, ev.pageX, ev.pageY);
          this.startDelay(ev);
          if (!this.minDistance) {
            this.handleDistanceSurpassed(ev);
          }
        }
      }
    };
    this.onPointerMove = (ev) => {
      if (this.isInteracting) {
        this.emitter.trigger("pointermove", ev);
        if (!this.isDistanceSurpassed) {
          let minDistance = this.minDistance;
          let distanceSq;
          let { deltaX, deltaY } = ev;
          distanceSq = deltaX * deltaX + deltaY * deltaY;
          if (distanceSq >= minDistance * minDistance) {
            this.handleDistanceSurpassed(ev);
          }
        }
        if (this.isDragging) {
          if (ev.origEvent.type !== "scroll") {
            this.mirror.handleMove(ev.pageX, ev.pageY);
            this.autoScroller.handleMove(ev.pageX, ev.pageY);
          }
          this.emitter.trigger("dragmove", ev);
        }
      }
    };
    this.onPointerUp = (ev) => {
      if (this.isInteracting) {
        this.isInteracting = false;
        allowSelection(document.body);
        allowContextMenu(document.body);
        this.emitter.trigger("pointerup", ev);
        if (this.isDragging) {
          this.autoScroller.stop();
          this.tryStopDrag(ev);
        }
        if (this.delayTimeoutId) {
          clearTimeout(this.delayTimeoutId);
          this.delayTimeoutId = null;
        }
      }
    };
    let pointer = this.pointer = new PointerDragging(containerEl);
    pointer.emitter.on("pointerdown", this.onPointerDown);
    pointer.emitter.on("pointermove", this.onPointerMove);
    pointer.emitter.on("pointerup", this.onPointerUp);
    if (selector) {
      pointer.selector = selector;
    }
    this.mirror = new ElementMirror();
    this.autoScroller = new AutoScroller();
  }
  destroy() {
    this.pointer.destroy();
    this.onPointerUp({});
  }
  startDelay(ev) {
    if (typeof this.delay === "number") {
      this.delayTimeoutId = setTimeout(() => {
        this.delayTimeoutId = null;
        this.handleDelayEnd(ev);
      }, this.delay);
    } else {
      this.handleDelayEnd(ev);
    }
  }
  handleDelayEnd(ev) {
    this.isDelayEnded = true;
    this.tryStartDrag(ev);
  }
  handleDistanceSurpassed(ev) {
    this.isDistanceSurpassed = true;
    this.tryStartDrag(ev);
  }
  tryStartDrag(ev) {
    if (this.isDelayEnded && this.isDistanceSurpassed) {
      if (!this.pointer.wasTouchScroll || this.touchScrollAllowed) {
        this.isDragging = true;
        this.mirrorNeedsRevert = false;
        this.autoScroller.start(ev.pageX, ev.pageY, this.containerEl);
        this.emitter.trigger("dragstart", ev);
        if (this.touchScrollAllowed === false) {
          this.pointer.cancelTouchScroll();
        }
      }
    }
  }
  tryStopDrag(ev) {
    this.mirror.stop(this.mirrorNeedsRevert, this.stopDrag.bind(this, ev));
  }
  stopDrag(ev) {
    this.isDragging = false;
    this.emitter.trigger("dragend", ev);
  }
  // fill in the implementations...
  setIgnoreMove(bool) {
    this.pointer.shouldIgnoreMove = bool;
  }
  setMirrorIsVisible(bool) {
    this.mirror.setIsVisible(bool);
  }
  setMirrorNeedsRevert(bool) {
    this.mirrorNeedsRevert = bool;
  }
  setAutoScrollEnabled(bool) {
    this.autoScroller.isEnabled = bool;
  }
};
var OffsetTracker = class {
  constructor(el) {
    this.el = el;
    this.origRect = computeRect(el);
    this.scrollCaches = getClippingParents(el).map((scrollEl) => new ElementScrollGeomCache(scrollEl, true));
  }
  destroy() {
    for (let scrollCache of this.scrollCaches) {
      scrollCache.destroy();
    }
  }
  computeLeft() {
    let left = this.origRect.left;
    for (let scrollCache of this.scrollCaches) {
      left += scrollCache.origScrollLeft - scrollCache.getScrollLeft();
    }
    return left;
  }
  computeTop() {
    let top = this.origRect.top;
    for (let scrollCache of this.scrollCaches) {
      top += scrollCache.origScrollTop - scrollCache.getScrollTop();
    }
    return top;
  }
  isWithinClipping(pageX, pageY) {
    let point = { left: pageX, top: pageY };
    for (let scrollCache of this.scrollCaches) {
      if (!isIgnoredClipping(scrollCache.getEventTarget()) && !pointInsideRect(point, scrollCache.clientRect)) {
        return false;
      }
    }
    return true;
  }
};
function isIgnoredClipping(node) {
  let tagName = node.tagName;
  return tagName === "HTML" || tagName === "BODY";
}
var HitDragging = class {
  constructor(dragging, droppableStore) {
    this.useSubjectCenter = false;
    this.requireInitial = true;
    this.disablePointCheck = false;
    this.initialHit = null;
    this.movingHit = null;
    this.finalHit = null;
    this.handlePointerDown = (ev) => {
      let { dragging: dragging2 } = this;
      this.initialHit = null;
      this.movingHit = null;
      this.finalHit = null;
      this.prepareHits();
      this.processFirstCoord(ev);
      if (this.initialHit || !this.requireInitial) {
        dragging2.setIgnoreMove(false);
        this.emitter.trigger("pointerdown", ev);
      } else {
        dragging2.setIgnoreMove(true);
      }
    };
    this.handleDragStart = (ev) => {
      this.emitter.trigger("dragstart", ev);
      this.handleMove(ev, true);
    };
    this.handleDragMove = (ev) => {
      this.emitter.trigger("dragmove", ev);
      this.handleMove(ev);
    };
    this.handlePointerUp = (ev) => {
      this.releaseHits();
      this.emitter.trigger("pointerup", ev);
    };
    this.handleDragEnd = (ev) => {
      if (this.movingHit) {
        this.emitter.trigger("hitupdate", null, true, ev);
      }
      this.finalHit = this.movingHit;
      this.movingHit = null;
      this.emitter.trigger("dragend", ev);
    };
    this.droppableStore = droppableStore;
    dragging.emitter.on("pointerdown", this.handlePointerDown);
    dragging.emitter.on("dragstart", this.handleDragStart);
    dragging.emitter.on("dragmove", this.handleDragMove);
    dragging.emitter.on("pointerup", this.handlePointerUp);
    dragging.emitter.on("dragend", this.handleDragEnd);
    this.dragging = dragging;
    this.emitter = new Emitter();
  }
  // sets initialHit
  // sets coordAdjust
  processFirstCoord(ev) {
    let origPoint = { left: ev.pageX, top: ev.pageY };
    let adjustedPoint = origPoint;
    let subjectEl = ev.subjectEl;
    let subjectRect;
    if (subjectEl instanceof HTMLElement) {
      subjectRect = computeRect(subjectEl);
      adjustedPoint = constrainPoint(adjustedPoint, subjectRect);
    }
    let initialHit = this.initialHit = this.queryHitForOffset(adjustedPoint.left, adjustedPoint.top);
    if (initialHit) {
      if (this.useSubjectCenter && subjectRect) {
        let slicedSubjectRect = intersectRects(subjectRect, initialHit.rect);
        if (slicedSubjectRect) {
          adjustedPoint = getRectCenter(slicedSubjectRect);
        }
      }
      this.coordAdjust = diffPoints(adjustedPoint, origPoint);
    } else {
      this.coordAdjust = { left: 0, top: 0 };
    }
  }
  handleMove(ev, forceHandle) {
    let hit = this.queryHitForOffset(ev.pageX + this.coordAdjust.left, ev.pageY + this.coordAdjust.top);
    if (forceHandle || !isHitsEqual(this.movingHit, hit)) {
      this.movingHit = hit;
      this.emitter.trigger("hitupdate", hit, false, ev);
    }
  }
  prepareHits() {
    this.offsetTrackers = mapHash(this.droppableStore, (interactionSettings) => {
      interactionSettings.component.prepareHits();
      return new OffsetTracker(interactionSettings.el);
    });
  }
  releaseHits() {
    let { offsetTrackers } = this;
    for (let id in offsetTrackers) {
      offsetTrackers[id].destroy();
    }
    this.offsetTrackers = {};
  }
  queryHitForOffset(offsetLeft, offsetTop) {
    let { droppableStore, offsetTrackers } = this;
    let bestHit = null;
    for (let id in droppableStore) {
      let component = droppableStore[id].component;
      let offsetTracker = offsetTrackers[id];
      if (offsetTracker && // wasn't destroyed mid-drag
      offsetTracker.isWithinClipping(offsetLeft, offsetTop)) {
        let originLeft = offsetTracker.computeLeft();
        let originTop = offsetTracker.computeTop();
        let positionLeft = offsetLeft - originLeft;
        let positionTop = offsetTop - originTop;
        let { origRect } = offsetTracker;
        let width = origRect.right - origRect.left;
        let height = origRect.bottom - origRect.top;
        if (
          // must be within the element's bounds
          positionLeft >= 0 && positionLeft < width && positionTop >= 0 && positionTop < height
        ) {
          let hit = component.queryHit(positionLeft, positionTop, width, height);
          if (hit && // make sure the hit is within activeRange, meaning it's not a dead cell
          rangeContainsRange(hit.dateProfile.activeRange, hit.dateSpan.range) && // Ensure the component we are querying for the hit is accessibly my the pointer
          // Prevents obscured calendars (ex: under a modal dialog) from accepting hit
          // https://github.com/fullcalendar/fullcalendar/issues/5026
          (this.disablePointCheck || offsetTracker.el.contains(offsetTracker.el.getRootNode().elementFromPoint(
            // add-back origins to get coordinate relative to top-left of window viewport
            positionLeft + originLeft - window.scrollX,
            positionTop + originTop - window.scrollY
          ))) && (!bestHit || hit.layer > bestHit.layer)) {
            hit.componentId = id;
            hit.context = component.context;
            hit.rect.left += originLeft;
            hit.rect.right += originLeft;
            hit.rect.top += originTop;
            hit.rect.bottom += originTop;
            bestHit = hit;
          }
        }
      }
    }
    return bestHit;
  }
};
function isHitsEqual(hit0, hit1) {
  if (!hit0 && !hit1) {
    return true;
  }
  if (Boolean(hit0) !== Boolean(hit1)) {
    return false;
  }
  return isDateSpansEqual(hit0.dateSpan, hit1.dateSpan);
}
function buildDatePointApiWithContext(dateSpan, context) {
  let props = {};
  for (let transform of context.pluginHooks.datePointTransforms) {
    Object.assign(props, transform(dateSpan, context));
  }
  Object.assign(props, buildDatePointApi(dateSpan, context.dateEnv));
  return props;
}
function buildDatePointApi(span, dateEnv) {
  return {
    date: dateEnv.toDate(span.range.start),
    dateStr: dateEnv.formatIso(span.range.start, { omitTime: span.allDay }),
    allDay: span.allDay
  };
}
var DateClicking = class extends Interaction {
  constructor(settings) {
    super(settings);
    this.handlePointerDown = (pev) => {
      let { dragging } = this;
      let downEl = pev.origEvent.target;
      dragging.setIgnoreMove(!this.component.isValidDateDownEl(downEl));
    };
    this.handleDragEnd = (ev) => {
      let { component } = this;
      let { pointer } = this.dragging;
      if (!pointer.wasTouchScroll) {
        let { initialHit, finalHit } = this.hitDragging;
        if (initialHit && finalHit && isHitsEqual(initialHit, finalHit)) {
          let { context } = component;
          let arg = Object.assign(Object.assign({}, buildDatePointApiWithContext(initialHit.dateSpan, context)), { dayEl: initialHit.dayEl, jsEvent: ev.origEvent, view: context.viewApi || context.calendarApi.view });
          context.emitter.trigger("dateClick", arg);
        }
      }
    };
    this.dragging = new FeaturefulElementDragging(settings.el);
    this.dragging.autoScroller.isEnabled = false;
    let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsToStore(settings));
    hitDragging.emitter.on("pointerdown", this.handlePointerDown);
    hitDragging.emitter.on("dragend", this.handleDragEnd);
  }
  destroy() {
    this.dragging.destroy();
  }
};
var DateSelecting = class extends Interaction {
  constructor(settings) {
    super(settings);
    this.dragSelection = null;
    this.handlePointerDown = (ev) => {
      let { component: component2, dragging: dragging2 } = this;
      let { options: options2 } = component2.context;
      let canSelect = options2.selectable && component2.isValidDateDownEl(ev.origEvent.target);
      dragging2.setIgnoreMove(!canSelect);
      dragging2.delay = ev.isTouch ? getComponentTouchDelay$1(component2) : null;
    };
    this.handleDragStart = (ev) => {
      this.component.context.calendarApi.unselect(ev);
    };
    this.handleHitUpdate = (hit, isFinal) => {
      let { context } = this.component;
      let dragSelection = null;
      let isInvalid = false;
      if (hit) {
        let initialHit = this.hitDragging.initialHit;
        let disallowed = hit.componentId === initialHit.componentId && this.isHitComboAllowed && !this.isHitComboAllowed(initialHit, hit);
        if (!disallowed) {
          dragSelection = joinHitsIntoSelection(initialHit, hit, context.pluginHooks.dateSelectionTransformers);
        }
        if (!dragSelection || !isDateSelectionValid(dragSelection, hit.dateProfile, context)) {
          isInvalid = true;
          dragSelection = null;
        }
      }
      if (dragSelection) {
        context.dispatch({ type: "SELECT_DATES", selection: dragSelection });
      } else if (!isFinal) {
        context.dispatch({ type: "UNSELECT_DATES" });
      }
      if (!isInvalid) {
        enableCursor();
      } else {
        disableCursor();
      }
      if (!isFinal) {
        this.dragSelection = dragSelection;
      }
    };
    this.handlePointerUp = (pev) => {
      if (this.dragSelection) {
        triggerDateSelect(this.dragSelection, pev, this.component.context);
        this.dragSelection = null;
      }
    };
    let { component } = settings;
    let { options } = component.context;
    let dragging = this.dragging = new FeaturefulElementDragging(settings.el);
    dragging.touchScrollAllowed = false;
    dragging.minDistance = options.selectMinDistance || 0;
    dragging.autoScroller.isEnabled = options.dragScroll;
    let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsToStore(settings));
    hitDragging.emitter.on("pointerdown", this.handlePointerDown);
    hitDragging.emitter.on("dragstart", this.handleDragStart);
    hitDragging.emitter.on("hitupdate", this.handleHitUpdate);
    hitDragging.emitter.on("pointerup", this.handlePointerUp);
  }
  destroy() {
    this.dragging.destroy();
  }
};
function getComponentTouchDelay$1(component) {
  let { options } = component.context;
  let delay = options.selectLongPressDelay;
  if (delay == null) {
    delay = options.longPressDelay;
  }
  return delay;
}
function joinHitsIntoSelection(hit0, hit1, dateSelectionTransformers) {
  let dateSpan0 = hit0.dateSpan;
  let dateSpan1 = hit1.dateSpan;
  let ms = [
    dateSpan0.range.start,
    dateSpan0.range.end,
    dateSpan1.range.start,
    dateSpan1.range.end
  ];
  ms.sort(compareNumbers);
  let props = {};
  for (let transformer of dateSelectionTransformers) {
    let res = transformer(hit0, hit1);
    if (res === false) {
      return null;
    }
    if (res) {
      Object.assign(props, res);
    }
  }
  props.range = { start: ms[0], end: ms[3] };
  props.allDay = dateSpan0.allDay;
  return props;
}
var EventDragging = class extends Interaction {
  constructor(settings) {
    super(settings);
    this.subjectEl = null;
    this.subjectSeg = null;
    this.isDragging = false;
    this.eventRange = null;
    this.relevantEvents = null;
    this.receivingContext = null;
    this.validMutation = null;
    this.mutatedRelevantEvents = null;
    this.handlePointerDown = (ev) => {
      let origTarget = ev.origEvent.target;
      let { component: component2, dragging: dragging2 } = this;
      let { mirror } = dragging2;
      let { options: options2 } = component2.context;
      let initialContext = component2.context;
      this.subjectEl = ev.subjectEl;
      let subjectSeg = this.subjectSeg = getElSeg(ev.subjectEl);
      let eventRange = this.eventRange = subjectSeg.eventRange;
      let eventInstanceId = eventRange.instance.instanceId;
      this.relevantEvents = getRelevantEvents(initialContext.getCurrentData().eventStore, eventInstanceId);
      dragging2.minDistance = ev.isTouch ? 0 : options2.eventDragMinDistance;
      dragging2.delay = // only do a touch delay if touch and this event hasn't been selected yet
      ev.isTouch && eventInstanceId !== component2.props.eventSelection ? getComponentTouchDelay(component2) : null;
      if (options2.fixedMirrorParent) {
        mirror.parentNode = options2.fixedMirrorParent;
      } else {
        mirror.parentNode = elementClosest(origTarget, ".fc");
      }
      mirror.revertDuration = options2.dragRevertDuration;
      let isValid = component2.isValidSegDownEl(origTarget) && !elementClosest(origTarget, ".fc-event-resizer");
      dragging2.setIgnoreMove(!isValid);
      this.isDragging = isValid && ev.subjectEl.classList.contains("fc-event-draggable");
    };
    this.handleDragStart = (ev) => {
      let initialContext = this.component.context;
      let eventRange = this.eventRange;
      let eventInstanceId = eventRange.instance.instanceId;
      if (ev.isTouch) {
        if (eventInstanceId !== this.component.props.eventSelection) {
          initialContext.dispatch({ type: "SELECT_EVENT", eventInstanceId });
        }
      } else {
        initialContext.dispatch({ type: "UNSELECT_EVENT" });
      }
      if (this.isDragging) {
        initialContext.calendarApi.unselect(ev);
        initialContext.emitter.trigger("eventDragStart", {
          el: this.subjectEl,
          event: new EventImpl(initialContext, eventRange.def, eventRange.instance),
          jsEvent: ev.origEvent,
          view: initialContext.viewApi
        });
      }
    };
    this.handleHitUpdate = (hit, isFinal) => {
      if (!this.isDragging) {
        return;
      }
      let relevantEvents = this.relevantEvents;
      let initialHit = this.hitDragging.initialHit;
      let initialContext = this.component.context;
      let receivingContext = null;
      let mutation = null;
      let mutatedRelevantEvents = null;
      let isInvalid = false;
      let interaction = {
        affectedEvents: relevantEvents,
        mutatedEvents: createEmptyEventStore(),
        isEvent: true
      };
      if (hit) {
        receivingContext = hit.context;
        let receivingOptions = receivingContext.options;
        if (initialContext === receivingContext || receivingOptions.editable && receivingOptions.droppable) {
          mutation = computeEventMutation(initialHit, hit, this.eventRange.instance.range.start, receivingContext.getCurrentData().pluginHooks.eventDragMutationMassagers);
          if (mutation) {
            mutatedRelevantEvents = applyMutationToEventStore(relevantEvents, receivingContext.getCurrentData().eventUiBases, mutation, receivingContext);
            interaction.mutatedEvents = mutatedRelevantEvents;
            if (!isInteractionValid(interaction, hit.dateProfile, receivingContext)) {
              isInvalid = true;
              mutation = null;
              mutatedRelevantEvents = null;
              interaction.mutatedEvents = createEmptyEventStore();
            }
          }
        } else {
          receivingContext = null;
        }
      }
      this.displayDrag(receivingContext, interaction);
      if (!isInvalid) {
        enableCursor();
      } else {
        disableCursor();
      }
      if (!isFinal) {
        if (initialContext === receivingContext && // TODO: write test for this
        isHitsEqual(initialHit, hit)) {
          mutation = null;
        }
        this.dragging.setMirrorNeedsRevert(!mutation);
        this.dragging.setMirrorIsVisible(!hit || !this.subjectEl.getRootNode().querySelector(".fc-event-mirror"));
        this.receivingContext = receivingContext;
        this.validMutation = mutation;
        this.mutatedRelevantEvents = mutatedRelevantEvents;
      }
    };
    this.handlePointerUp = () => {
      if (!this.isDragging) {
        this.cleanup();
      }
    };
    this.handleDragEnd = (ev) => {
      if (this.isDragging) {
        let initialContext = this.component.context;
        let initialView = initialContext.viewApi;
        let { receivingContext, validMutation } = this;
        let eventDef = this.eventRange.def;
        let eventInstance = this.eventRange.instance;
        let eventApi = new EventImpl(initialContext, eventDef, eventInstance);
        let relevantEvents = this.relevantEvents;
        let mutatedRelevantEvents = this.mutatedRelevantEvents;
        let { finalHit } = this.hitDragging;
        this.clearDrag();
        initialContext.emitter.trigger("eventDragStop", {
          el: this.subjectEl,
          event: eventApi,
          jsEvent: ev.origEvent,
          view: initialView
        });
        if (validMutation) {
          if (receivingContext === initialContext) {
            let updatedEventApi = new EventImpl(initialContext, mutatedRelevantEvents.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents.instances[eventInstance.instanceId] : null);
            initialContext.dispatch({
              type: "MERGE_EVENTS",
              eventStore: mutatedRelevantEvents
            });
            let eventChangeArg = {
              oldEvent: eventApi,
              event: updatedEventApi,
              relatedEvents: buildEventApis(mutatedRelevantEvents, initialContext, eventInstance),
              revert() {
                initialContext.dispatch({
                  type: "MERGE_EVENTS",
                  eventStore: relevantEvents
                  // the pre-change data
                });
              }
            };
            let transformed = {};
            for (let transformer of initialContext.getCurrentData().pluginHooks.eventDropTransformers) {
              Object.assign(transformed, transformer(validMutation, initialContext));
            }
            initialContext.emitter.trigger("eventDrop", Object.assign(Object.assign(Object.assign({}, eventChangeArg), transformed), { el: ev.subjectEl, delta: validMutation.datesDelta, jsEvent: ev.origEvent, view: initialView }));
            initialContext.emitter.trigger("eventChange", eventChangeArg);
          } else if (receivingContext) {
            let eventRemoveArg = {
              event: eventApi,
              relatedEvents: buildEventApis(relevantEvents, initialContext, eventInstance),
              revert() {
                initialContext.dispatch({
                  type: "MERGE_EVENTS",
                  eventStore: relevantEvents
                });
              }
            };
            initialContext.emitter.trigger("eventLeave", Object.assign(Object.assign({}, eventRemoveArg), { draggedEl: ev.subjectEl, view: initialView }));
            initialContext.dispatch({
              type: "REMOVE_EVENTS",
              eventStore: relevantEvents
            });
            initialContext.emitter.trigger("eventRemove", eventRemoveArg);
            let addedEventDef = mutatedRelevantEvents.defs[eventDef.defId];
            let addedEventInstance = mutatedRelevantEvents.instances[eventInstance.instanceId];
            let addedEventApi = new EventImpl(receivingContext, addedEventDef, addedEventInstance);
            receivingContext.dispatch({
              type: "MERGE_EVENTS",
              eventStore: mutatedRelevantEvents
            });
            let eventAddArg = {
              event: addedEventApi,
              relatedEvents: buildEventApis(mutatedRelevantEvents, receivingContext, addedEventInstance),
              revert() {
                receivingContext.dispatch({
                  type: "REMOVE_EVENTS",
                  eventStore: mutatedRelevantEvents
                });
              }
            };
            receivingContext.emitter.trigger("eventAdd", eventAddArg);
            if (ev.isTouch) {
              receivingContext.dispatch({
                type: "SELECT_EVENT",
                eventInstanceId: eventInstance.instanceId
              });
            }
            receivingContext.emitter.trigger("drop", Object.assign(Object.assign({}, buildDatePointApiWithContext(finalHit.dateSpan, receivingContext)), { draggedEl: ev.subjectEl, jsEvent: ev.origEvent, view: finalHit.context.viewApi }));
            receivingContext.emitter.trigger("eventReceive", Object.assign(Object.assign({}, eventAddArg), { draggedEl: ev.subjectEl, view: finalHit.context.viewApi }));
          }
        } else {
          initialContext.emitter.trigger("_noEventDrop");
        }
      }
      this.cleanup();
    };
    let { component } = this;
    let { options } = component.context;
    let dragging = this.dragging = new FeaturefulElementDragging(settings.el);
    dragging.pointer.selector = EventDragging.SELECTOR;
    dragging.touchScrollAllowed = false;
    dragging.autoScroller.isEnabled = options.dragScroll;
    let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsStore);
    hitDragging.useSubjectCenter = settings.useEventCenter;
    hitDragging.emitter.on("pointerdown", this.handlePointerDown);
    hitDragging.emitter.on("dragstart", this.handleDragStart);
    hitDragging.emitter.on("hitupdate", this.handleHitUpdate);
    hitDragging.emitter.on("pointerup", this.handlePointerUp);
    hitDragging.emitter.on("dragend", this.handleDragEnd);
  }
  destroy() {
    this.dragging.destroy();
  }
  // render a drag state on the next receivingCalendar
  displayDrag(nextContext, state) {
    let initialContext = this.component.context;
    let prevContext = this.receivingContext;
    if (prevContext && prevContext !== nextContext) {
      if (prevContext === initialContext) {
        prevContext.dispatch({
          type: "SET_EVENT_DRAG",
          state: {
            affectedEvents: state.affectedEvents,
            mutatedEvents: createEmptyEventStore(),
            isEvent: true
          }
        });
      } else {
        prevContext.dispatch({ type: "UNSET_EVENT_DRAG" });
      }
    }
    if (nextContext) {
      nextContext.dispatch({ type: "SET_EVENT_DRAG", state });
    }
  }
  clearDrag() {
    let initialCalendar = this.component.context;
    let { receivingContext } = this;
    if (receivingContext) {
      receivingContext.dispatch({ type: "UNSET_EVENT_DRAG" });
    }
    if (initialCalendar !== receivingContext) {
      initialCalendar.dispatch({ type: "UNSET_EVENT_DRAG" });
    }
  }
  cleanup() {
    this.subjectSeg = null;
    this.isDragging = false;
    this.eventRange = null;
    this.relevantEvents = null;
    this.receivingContext = null;
    this.validMutation = null;
    this.mutatedRelevantEvents = null;
  }
};
EventDragging.SELECTOR = ".fc-event-draggable, .fc-event-resizable";
function computeEventMutation(hit0, hit1, eventInstanceStart, massagers) {
  let dateSpan0 = hit0.dateSpan;
  let dateSpan1 = hit1.dateSpan;
  let date0 = dateSpan0.range.start;
  let date1 = dateSpan1.range.start;
  let standardProps = {};
  if (dateSpan0.allDay !== dateSpan1.allDay) {
    standardProps.allDay = dateSpan1.allDay;
    standardProps.hasEnd = hit1.context.options.allDayMaintainDuration;
    if (dateSpan1.allDay) {
      date0 = startOfDay(eventInstanceStart);
    } else {
      date0 = eventInstanceStart;
    }
  }
  let delta = diffDates(date0, date1, hit0.context.dateEnv, hit0.componentId === hit1.componentId ? hit0.largeUnit : null);
  if (delta.milliseconds) {
    standardProps.allDay = false;
  }
  let mutation = {
    datesDelta: delta,
    standardProps
  };
  for (let massager of massagers) {
    massager(mutation, hit0, hit1);
  }
  return mutation;
}
function getComponentTouchDelay(component) {
  let { options } = component.context;
  let delay = options.eventLongPressDelay;
  if (delay == null) {
    delay = options.longPressDelay;
  }
  return delay;
}
var EventResizing = class extends Interaction {
  constructor(settings) {
    super(settings);
    this.draggingSegEl = null;
    this.draggingSeg = null;
    this.eventRange = null;
    this.relevantEvents = null;
    this.validMutation = null;
    this.mutatedRelevantEvents = null;
    this.handlePointerDown = (ev) => {
      let { component: component2 } = this;
      let segEl = this.querySegEl(ev);
      let seg = getElSeg(segEl);
      let eventRange = this.eventRange = seg.eventRange;
      this.dragging.minDistance = component2.context.options.eventDragMinDistance;
      this.dragging.setIgnoreMove(!this.component.isValidSegDownEl(ev.origEvent.target) || ev.isTouch && this.component.props.eventSelection !== eventRange.instance.instanceId);
    };
    this.handleDragStart = (ev) => {
      let { context } = this.component;
      let eventRange = this.eventRange;
      this.relevantEvents = getRelevantEvents(context.getCurrentData().eventStore, this.eventRange.instance.instanceId);
      let segEl = this.querySegEl(ev);
      this.draggingSegEl = segEl;
      this.draggingSeg = getElSeg(segEl);
      context.calendarApi.unselect();
      context.emitter.trigger("eventResizeStart", {
        el: segEl,
        event: new EventImpl(context, eventRange.def, eventRange.instance),
        jsEvent: ev.origEvent,
        view: context.viewApi
      });
    };
    this.handleHitUpdate = (hit, isFinal, ev) => {
      let { context } = this.component;
      let relevantEvents = this.relevantEvents;
      let initialHit = this.hitDragging.initialHit;
      let eventInstance = this.eventRange.instance;
      let mutation = null;
      let mutatedRelevantEvents = null;
      let isInvalid = false;
      let interaction = {
        affectedEvents: relevantEvents,
        mutatedEvents: createEmptyEventStore(),
        isEvent: true
      };
      if (hit) {
        let disallowed = hit.componentId === initialHit.componentId && this.isHitComboAllowed && !this.isHitComboAllowed(initialHit, hit);
        if (!disallowed) {
          mutation = computeMutation(initialHit, hit, ev.subjectEl.classList.contains("fc-event-resizer-start"), eventInstance.range);
        }
      }
      if (mutation) {
        mutatedRelevantEvents = applyMutationToEventStore(relevantEvents, context.getCurrentData().eventUiBases, mutation, context);
        interaction.mutatedEvents = mutatedRelevantEvents;
        if (!isInteractionValid(interaction, hit.dateProfile, context)) {
          isInvalid = true;
          mutation = null;
          mutatedRelevantEvents = null;
          interaction.mutatedEvents = null;
        }
      }
      if (mutatedRelevantEvents) {
        context.dispatch({
          type: "SET_EVENT_RESIZE",
          state: interaction
        });
      } else {
        context.dispatch({ type: "UNSET_EVENT_RESIZE" });
      }
      if (!isInvalid) {
        enableCursor();
      } else {
        disableCursor();
      }
      if (!isFinal) {
        if (mutation && isHitsEqual(initialHit, hit)) {
          mutation = null;
        }
        this.validMutation = mutation;
        this.mutatedRelevantEvents = mutatedRelevantEvents;
      }
    };
    this.handleDragEnd = (ev) => {
      let { context } = this.component;
      let eventDef = this.eventRange.def;
      let eventInstance = this.eventRange.instance;
      let eventApi = new EventImpl(context, eventDef, eventInstance);
      let relevantEvents = this.relevantEvents;
      let mutatedRelevantEvents = this.mutatedRelevantEvents;
      context.emitter.trigger("eventResizeStop", {
        el: this.draggingSegEl,
        event: eventApi,
        jsEvent: ev.origEvent,
        view: context.viewApi
      });
      if (this.validMutation) {
        let updatedEventApi = new EventImpl(context, mutatedRelevantEvents.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents.instances[eventInstance.instanceId] : null);
        context.dispatch({
          type: "MERGE_EVENTS",
          eventStore: mutatedRelevantEvents
        });
        let eventChangeArg = {
          oldEvent: eventApi,
          event: updatedEventApi,
          relatedEvents: buildEventApis(mutatedRelevantEvents, context, eventInstance),
          revert() {
            context.dispatch({
              type: "MERGE_EVENTS",
              eventStore: relevantEvents
              // the pre-change events
            });
          }
        };
        context.emitter.trigger("eventResize", Object.assign(Object.assign({}, eventChangeArg), { el: this.draggingSegEl, startDelta: this.validMutation.startDelta || createDuration(0), endDelta: this.validMutation.endDelta || createDuration(0), jsEvent: ev.origEvent, view: context.viewApi }));
        context.emitter.trigger("eventChange", eventChangeArg);
      } else {
        context.emitter.trigger("_noEventResize");
      }
      this.draggingSeg = null;
      this.relevantEvents = null;
      this.validMutation = null;
    };
    let { component } = settings;
    let dragging = this.dragging = new FeaturefulElementDragging(settings.el);
    dragging.pointer.selector = ".fc-event-resizer";
    dragging.touchScrollAllowed = false;
    dragging.autoScroller.isEnabled = component.context.options.dragScroll;
    let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsToStore(settings));
    hitDragging.emitter.on("pointerdown", this.handlePointerDown);
    hitDragging.emitter.on("dragstart", this.handleDragStart);
    hitDragging.emitter.on("hitupdate", this.handleHitUpdate);
    hitDragging.emitter.on("dragend", this.handleDragEnd);
  }
  destroy() {
    this.dragging.destroy();
  }
  querySegEl(ev) {
    return elementClosest(ev.subjectEl, ".fc-event");
  }
};
function computeMutation(hit0, hit1, isFromStart, instanceRange) {
  let dateEnv = hit0.context.dateEnv;
  let date0 = hit0.dateSpan.range.start;
  let date1 = hit1.dateSpan.range.start;
  let delta = diffDates(date0, date1, dateEnv, hit0.largeUnit);
  if (isFromStart) {
    if (dateEnv.add(instanceRange.start, delta) < instanceRange.end) {
      return { startDelta: delta };
    }
  } else if (dateEnv.add(instanceRange.end, delta) > instanceRange.start) {
    return { endDelta: delta };
  }
  return null;
}
var UnselectAuto = class {
  constructor(context) {
    this.context = context;
    this.isRecentPointerDateSelect = false;
    this.matchesCancel = false;
    this.matchesEvent = false;
    this.onSelect = (selectInfo) => {
      if (selectInfo.jsEvent) {
        this.isRecentPointerDateSelect = true;
      }
    };
    this.onDocumentPointerDown = (pev) => {
      let unselectCancel = this.context.options.unselectCancel;
      let downEl = getEventTargetViaRoot(pev.origEvent);
      this.matchesCancel = !!elementClosest(downEl, unselectCancel);
      this.matchesEvent = !!elementClosest(downEl, EventDragging.SELECTOR);
    };
    this.onDocumentPointerUp = (pev) => {
      let { context: context2 } = this;
      let { documentPointer: documentPointer2 } = this;
      let calendarState = context2.getCurrentData();
      if (!documentPointer2.wasTouchScroll) {
        if (calendarState.dateSelection && // an existing date selection?
        !this.isRecentPointerDateSelect) {
          let unselectAuto = context2.options.unselectAuto;
          if (unselectAuto && (!unselectAuto || !this.matchesCancel)) {
            context2.calendarApi.unselect(pev);
          }
        }
        if (calendarState.eventSelection && // an existing event selected?
        !this.matchesEvent) {
          context2.dispatch({ type: "UNSELECT_EVENT" });
        }
      }
      this.isRecentPointerDateSelect = false;
    };
    let documentPointer = this.documentPointer = new PointerDragging(document);
    documentPointer.shouldIgnoreMove = true;
    documentPointer.shouldWatchScroll = false;
    documentPointer.emitter.on("pointerdown", this.onDocumentPointerDown);
    documentPointer.emitter.on("pointerup", this.onDocumentPointerUp);
    context.emitter.on("select", this.onSelect);
  }
  destroy() {
    this.context.emitter.off("select", this.onSelect);
    this.documentPointer.destroy();
  }
};
var OPTION_REFINERS3 = {
  fixedMirrorParent: identity
};
var LISTENER_REFINERS = {
  dateClick: identity,
  eventDragStart: identity,
  eventDragStop: identity,
  eventDrop: identity,
  eventResizeStart: identity,
  eventResizeStop: identity,
  eventResize: identity,
  drop: identity,
  eventReceive: identity,
  eventLeave: identity
};
config.dataAttrPrefix = "";
var index5 = createPlugin({
  name: "@fullcalendar/interaction",
  componentInteractions: [DateClicking, DateSelecting, EventDragging, EventResizing],
  calendarInteractions: [UnselectAuto],
  elementDraggingImpl: FeaturefulElementDragging,
  optionRefiners: OPTION_REFINERS3,
  listenerRefiners: LISTENER_REFINERS
});

// node_modules/@fullcalendar/google-calendar/index.js
var API_BASE = "https://www.googleapis.com/calendar/v3/calendars";
var eventSourceDef2 = {
  parseMeta(refined) {
    let { googleCalendarId } = refined;
    if (!googleCalendarId && refined.url) {
      googleCalendarId = parseGoogleCalendarId(refined.url);
    }
    if (googleCalendarId) {
      return {
        googleCalendarId,
        googleCalendarApiKey: refined.googleCalendarApiKey,
        googleCalendarApiBase: refined.googleCalendarApiBase,
        extraParams: refined.extraParams
      };
    }
    return null;
  },
  fetch(arg, successCallback, errorCallback) {
    let { dateEnv, options } = arg.context;
    let meta = arg.eventSource.meta;
    let apiKey = meta.googleCalendarApiKey || options.googleCalendarApiKey;
    if (!apiKey) {
      errorCallback(new Error("Specify a googleCalendarApiKey. See https://fullcalendar.io/docs/google-calendar"));
    } else {
      let url = buildUrl(meta);
      let { extraParams } = meta;
      let extraParamsObj = typeof extraParams === "function" ? extraParams() : extraParams;
      let requestParams = buildRequestParams2(arg.range, apiKey, extraParamsObj, dateEnv);
      return requestJson("GET", url, requestParams).then(([body, response]) => {
        if (body.error) {
          errorCallback(new JsonRequestError("Google Calendar API: " + body.error.message, response));
        } else {
          successCallback({
            rawEvents: gcalItemsToRawEventDefs(body.items, requestParams.timeZone),
            response
          });
        }
      }, errorCallback);
    }
  }
};
function parseGoogleCalendarId(url) {
  let match;
  if (/^[^/]+@([^/.]+\.)*(google|googlemail|gmail)\.com$/.test(url)) {
    return url;
  }
  if ((match = /^https:\/\/www.googleapis.com\/calendar\/v3\/calendars\/([^/]*)/.exec(url)) || (match = /^https?:\/\/www.google.com\/calendar\/feeds\/([^/]*)/.exec(url))) {
    return decodeURIComponent(match[1]);
  }
  return null;
}
function buildUrl(meta) {
  let apiBase = meta.googleCalendarApiBase;
  if (!apiBase) {
    apiBase = API_BASE;
  }
  return apiBase + "/" + encodeURIComponent(meta.googleCalendarId) + "/events";
}
function buildRequestParams2(range2, apiKey, extraParams, dateEnv) {
  let params;
  let startStr;
  let endStr;
  if (dateEnv.canComputeOffset) {
    startStr = dateEnv.formatIso(range2.start);
    endStr = dateEnv.formatIso(range2.end);
  } else {
    startStr = addDays(range2.start, -1).toISOString();
    endStr = addDays(range2.end, 1).toISOString();
  }
  params = Object.assign(Object.assign({}, extraParams || {}), { key: apiKey, timeMin: startStr, timeMax: endStr, singleEvents: true, maxResults: 9999 });
  if (dateEnv.timeZone !== "local") {
    params.timeZone = dateEnv.timeZone;
  }
  return params;
}
function gcalItemsToRawEventDefs(items, gcalTimezone) {
  return items.map((item) => gcalItemToRawEventDef(item, gcalTimezone));
}
function gcalItemToRawEventDef(item, gcalTimezone) {
  let url = item.htmlLink || null;
  if (url && gcalTimezone) {
    url = injectQsComponent(url, "ctz=" + gcalTimezone);
  }
  return {
    id: item.id,
    title: item.summary,
    start: item.start.dateTime || item.start.date,
    end: item.end.dateTime || item.end.date,
    url,
    location: item.location,
    description: item.description,
    attachments: item.attachments || [],
    extendedProps: (item.extendedProperties || {}).shared || {}
  };
}
function injectQsComponent(url, component) {
  return url.replace(/(\?.*?)?(#|$)/, (whole, qs, hash) => (qs ? qs + "&" : "?") + component + hash);
}
var OPTION_REFINERS4 = {
  googleCalendarApiKey: String
};
var EVENT_SOURCE_REFINERS2 = {
  googleCalendarApiKey: String,
  googleCalendarId: String,
  googleCalendarApiBase: String,
  extraParams: identity
};
var index6 = createPlugin({
  name: "@fullcalendar/google-calendar",
  eventSourceDefs: [eventSourceDef2],
  optionRefiners: OPTION_REFINERS4,
  eventSourceRefiners: EVENT_SOURCE_REFINERS2
});

// node_modules/@fullcalendar/icalendar/index.js
var ICAL = __toESM(require_ical(), 1);
var IcalExpander = class {
  constructor(opts) {
    this.maxIterations = opts.maxIterations != null ? opts.maxIterations : 1e3;
    this.skipInvalidDates = opts.skipInvalidDates != null ? opts.skipInvalidDates : false;
    this.jCalData = ICAL.parse(opts.ics);
    this.component = new ICAL.Component(this.jCalData);
    this.events = this.component.getAllSubcomponents("vevent").map((vevent) => new ICAL.Event(vevent));
    if (this.skipInvalidDates) {
      this.events = this.events.filter((evt) => {
        try {
          evt.startDate.toJSDate();
          evt.endDate.toJSDate();
          return true;
        } catch (err) {
          return false;
        }
      });
    }
  }
  between(after, before) {
    function isEventWithinRange(startTime, endTime) {
      return (!after || endTime >= after.getTime()) && (!before || startTime <= before.getTime());
    }
    function getTimes(eventOrOccurrence) {
      const startTime = eventOrOccurrence.startDate.toJSDate().getTime();
      let endTime = eventOrOccurrence.endDate.toJSDate().getTime();
      if (eventOrOccurrence.endDate.isDate && endTime > startTime) {
        endTime -= 1;
      }
      return { startTime, endTime };
    }
    const exceptions = [];
    this.events.forEach((event) => {
      if (event.isRecurrenceException())
        exceptions.push(event);
    });
    const ret = {
      events: [],
      occurrences: []
    };
    this.events.filter((e3) => !e3.isRecurrenceException()).forEach((event) => {
      const exdates = [];
      event.component.getAllProperties("exdate").forEach((exdateProp) => {
        const exdate = exdateProp.getFirstValue();
        exdates.push(exdate.toJSDate().getTime());
      });
      if (event.isRecurring()) {
        const iterator = event.iterator();
        let next;
        let i3 = 0;
        do {
          i3 += 1;
          next = iterator.next();
          if (next) {
            const occurrence = event.getOccurrenceDetails(next);
            const { startTime: startTime2, endTime: endTime2 } = getTimes(occurrence);
            const isOccurrenceExcluded = exdates.indexOf(startTime2) !== -1;
            const exception = exceptions.find((ex) => ex.uid === event.uid && ex.recurrenceId.toJSDate().getTime() === occurrence.startDate.toJSDate().getTime());
            if (before && startTime2 > before.getTime())
              break;
            if (isEventWithinRange(startTime2, endTime2)) {
              if (exception) {
                ret.events.push(exception);
              } else if (!isOccurrenceExcluded) {
                ret.occurrences.push(occurrence);
              }
            }
          }
        } while (next && (!this.maxIterations || i3 < this.maxIterations));
        return;
      }
      const { startTime, endTime } = getTimes(event);
      if (isEventWithinRange(startTime, endTime))
        ret.events.push(event);
    });
    return ret;
  }
  before(before) {
    return this.between(void 0, before);
  }
  after(after) {
    return this.between(after);
  }
  all() {
    return this.between();
  }
};
var eventSourceDef3 = {
  parseMeta(refined) {
    if (refined.url && refined.format === "ics") {
      return {
        url: refined.url,
        format: "ics"
      };
    }
    return null;
  },
  fetch(arg, successCallback, errorCallback) {
    let meta = arg.eventSource.meta;
    let { internalState } = meta;
    if (!internalState || arg.isRefetch) {
      internalState = meta.internalState = {
        response: null,
        iCalExpanderPromise: fetch(meta.url, { method: "GET" }).then((response) => {
          return response.text().then((icsText) => {
            internalState.response = response;
            return new IcalExpander({
              ics: icsText,
              skipInvalidDates: true
            });
          });
        })
      };
    }
    internalState.iCalExpanderPromise.then((iCalExpander) => {
      successCallback({
        rawEvents: expandICalEvents(iCalExpander, arg.range),
        response: internalState.response
      });
    }, errorCallback);
  }
};
function expandICalEvents(iCalExpander, range2) {
  let rangeStart = addDays(range2.start, -1);
  let rangeEnd = addDays(range2.end, 1);
  let iCalRes = iCalExpander.between(rangeStart, rangeEnd);
  let expanded = [];
  for (let iCalEvent of iCalRes.events) {
    expanded.push(Object.assign(Object.assign({}, buildNonDateProps(iCalEvent)), { start: iCalEvent.startDate.toString(), end: specifiesEnd(iCalEvent) && iCalEvent.endDate ? iCalEvent.endDate.toString() : null }));
  }
  for (let iCalOccurence of iCalRes.occurrences) {
    let iCalEvent = iCalOccurence.item;
    expanded.push(Object.assign(Object.assign({}, buildNonDateProps(iCalEvent)), { start: iCalOccurence.startDate.toString(), end: specifiesEnd(iCalEvent) && iCalOccurence.endDate ? iCalOccurence.endDate.toString() : null }));
  }
  return expanded;
}
function buildNonDateProps(iCalEvent) {
  return {
    title: iCalEvent.summary,
    url: extractEventUrl(iCalEvent),
    extendedProps: {
      location: iCalEvent.location,
      organizer: iCalEvent.organizer,
      description: iCalEvent.description
    }
  };
}
function extractEventUrl(iCalEvent) {
  let urlProp = iCalEvent.component.getFirstProperty("url");
  return urlProp ? urlProp.getFirstValue() : "";
}
function specifiesEnd(iCalEvent) {
  return Boolean(iCalEvent.component.getFirstProperty("dtend")) || Boolean(iCalEvent.component.getFirstProperty("duration"));
}
var index7 = createPlugin({
  name: "@fullcalendar/icalendar",
  eventSourceDefs: [eventSourceDef3]
});

// lib/obsidian-full-calendar/calendar.ts
index3.recurringTypes[0].expand = function(errd, fr, de) {
  const hours = errd.rruleSet._dtstart.getHours();
  return errd.rruleSet.between(de.toDate(fr.start), de.toDate(fr.end), true).map((d2) => {
    return new Date(
      Date.UTC(
        d2.getFullYear(),
        d2.getMonth(),
        d2.getDate(),
        hours,
        d2.getMinutes()
      )
    );
  });
};
function renderCalendar(containerEl, eventSources, settings) {
  var _a;
  const isMobile = window.innerWidth < 500;
  const isNarrow = (settings == null ? void 0 : settings.forceNarrow) || isMobile;
  const {
    eventClick,
    select,
    modifyEvent,
    eventMouseEnter,
    openContextMenuForEvent,
    toggleTask
  } = settings || {};
  const modifyEventCallback = modifyEvent && (async ({
    event,
    oldEvent,
    revert
  }) => {
    const success = await modifyEvent(event, oldEvent);
    if (!success) {
      revert();
    }
  });
  const cal = new Calendar(containerEl, {
    plugins: [
      // View plugins
      index,
      index2,
      index4,
      // multiMonthPlugin,
      // Drag + drop and editing
      index5,
      // Remote sources
      index6,
      index7,
      index3
    ],
    googleCalendarApiKey: "AIzaSyDIiklFwJXaLWuT_4y6I9ZRVVsPuf4xGrk",
    initialView: ((_a = settings == null ? void 0 : settings.initialView) == null ? void 0 : _a[isNarrow ? "mobile" : "desktop"]) || (isNarrow ? "timeGrid3Days" : "timeGridWeek"),
    nowIndicator: true,
    scrollTimeReset: false,
    dayMaxEvents: true,
    expandRows: true,
    slotDuration: (settings == null ? void 0 : settings.slotDuration) || "00:30:00",
    // multiMonthMaxColumns: 1,
    headerToolbar: !isNarrow ? {
      left: "prev,next today",
      center: "title",
      right: "timeGrid5Days,timeGridWeek,listWeek,dayGridMonth,dayGridYear"
    } : !isMobile ? {
      right: "today,prev,next",
      left: "dayGridMonth,timeGrid3Days,listWeek,dayGridYear"
    } : false,
    footerToolbar: isMobile ? {
      right: "today,prev,next",
      left: "timeGrid3Days,dayGridMonth,dayGridYear,timeGridWeek,listWeek"
    } : false,
    views: {
      timeGrid3Days: {
        type: "timeGrid",
        duration: { days: 3 },
        buttonText: "3"
      },
      timeGrid5Days: {
        type: "timeGrid",
        duration: { days: 5 },
        buttonText: "5"
      },
      dayGridMonth: {
        dayMaxEvents: false
      },
      dayGridYear: {
        dayMaxEvents: false
      }
    },
    firstDay: settings == null ? void 0 : settings.firstDay,
    ...(settings == null ? void 0 : settings.timeFormat24h) && {
      eventTimeFormat: {
        hour: "numeric",
        minute: "2-digit",
        hour12: false
      },
      slotLabelFormat: {
        hour: "numeric",
        minute: "2-digit",
        hour12: false
      }
    },
    eventSources,
    eventClick,
    selectable: select && true,
    selectMirror: select && true,
    select: select && (async (info) => {
      await select(info.start, info.end, info.allDay, info.view.type);
      info.view.calendar.unselect();
    }),
    editable: modifyEvent && true,
    eventDrop: modifyEventCallback,
    eventResize: modifyEventCallback,
    eventMouseEnter,
    eventDidMount: ({ event, el, textColor }) => {
      el.addEventListener("contextmenu", (e3) => {
        e3.preventDefault();
        openContextMenuForEvent && openContextMenuForEvent(event, e3);
      });
      if (toggleTask) {
        if (event.extendedProps.isTask) {
          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.checked = event.extendedProps.taskCompleted !== false;
          checkbox.onclick = async (e3) => {
            e3.stopPropagation();
            if (e3.target) {
              let ret = await toggleTask(
                event,
                e3.target.checked
              );
              if (!ret) {
                e3.target.checked = !e3.target.checked;
              }
            }
          };
          if (textColor == "black") {
            checkbox.addClass("ofc-checkbox-black");
          } else {
            checkbox.addClass("ofc-checkbox-white");
          }
          if (checkbox.checked) {
            el.addClass("ofc-task-completed");
          }
          const container = el.querySelector(".fc-event-time") || el.querySelector(".fc-event-title") || el.querySelector(".fc-list-event-title");
          container == null ? void 0 : container.addClass("ofc-has-checkbox");
          container == null ? void 0 : container.prepend(checkbox);
        }
      }
    },
    longPressDelay: 250
  });
  cal.render();
  return cal;
}

// src/views/CalendarView.ts
var CalendarView = class extends import_obsidian.ItemView {
  constructor(leaf, idForCache, eventSrc, calendarSettings, cache, noteManager, placeForCreatingNote) {
    super(leaf);
    this.calendar = null;
    this.selectedSrcPaths = /* @__PURE__ */ new Set();
    this.cache = cache;
    this.idForCache = idForCache;
    this.eventSrc = eventSrc;
    this.noteManager = noteManager;
    this.calendarSettings = calendarSettings;
    this.placeForCreatingNote = placeForCreatingNote;
    for (let src of eventSrc) {
      this.selectedSrcPaths.add(src.path);
    }
  }
  getViewType() {
    return VIEW_TYPE;
  }
  getDisplayText() {
    return "Calendar";
  }
  async onOpen() {
    if (import_obsidian.Platform.isMobile)
      this.containerEl.style.height = "95vh";
    const { containerEl } = this;
    const container = containerEl.children[1];
    container.empty();
    const calendarContainer = container.createDiv(
      /*{cls: 'class'}*/
    );
    const checkBoxContainer = container.createDiv({ cls: "calendar-src-checkboxes" });
    this.render(calendarContainer).then(
      () => this.renderSrcCheckboxes(checkBoxContainer)
    );
  }
  onResize() {
    var _a;
    (_a = this.calendar) == null ? void 0 : _a.render();
  }
  addFile(data) {
    var _a;
    this.localStorage.push(data);
    if (!this.isPathInActiveSrc(data.file.path)) {
      return;
    }
    const events = this.pageToEvents(data);
    for (let event of events)
      (_a = this.calendar) == null ? void 0 : _a.addEvent(event);
  }
  changeFile(newPage, oldPage) {
    var _a, _b;
    (_a = this.calendar) == null ? void 0 : _a.pauseRendering();
    this.deleteFile(oldPage);
    this.addFile(newPage);
    (_b = this.calendar) == null ? void 0 : _b.resumeRendering();
  }
  renameFile(newPage, oldPage) {
    this.changeFile(newPage, oldPage);
  }
  deleteFile(page) {
    var _a, _b;
    const el = this.localStorage.find(
      (value) => page.file.path == value.file.path
    );
    if (el)
      this.localStorage.remove(el);
    if (!this.calendar)
      return;
    if (!this.isPathInActiveSrc(page.file.path))
      return;
    (_a = this.calendar.getEventById(page.file.path)) == null ? void 0 : _a.remove();
    for (let tick of page.ticks) {
      (_b = this.calendar.getEventById(
        templateIDTick(page.file.path, tick.name)
      )) == null ? void 0 : _b.remove();
    }
  }
  reset() {
    this.onunload();
    this.onOpen();
  }
  onunload() {
    if (!this.calendar)
      return;
    this.calendar.destroy();
    this.calendar = null;
    this.cache.unsubscribe(this.idForCache);
  }
  pageToEvents(page) {
    const result = [];
    const colours = this.calendarSettings.colours;
    const structureTemplate = {
      id: "",
      title: "",
      borderColor: colours.default,
      color: getColourFromPath(page.file.path),
      editable: true
    };
    if (page.ff_date) {
      const structure = {
        ...structureTemplate,
        id: page.file.path,
        title: page.file.name,
        ...IDateToCalendarEvent(page)
      };
      if (page.ff_frequency)
        structure.borderColor = colours.frequency;
      if (page.ff_status == TEXT_DONE)
        structure.borderColor = colours.done;
      result.push(structure);
    }
    for (let tick of page.ticks) {
      const structure = {
        ...structureTemplate,
        id: templateIDTick(page.file.path, tick.name),
        title: templateNameTick(page.file.name, tick.name),
        borderColor: colours.tick,
        extendedProps: {
          tickName: tick.name,
          notePath: page.file.path
        },
        ...IDateToCalendarEvent(tick)
      };
      result.push(structure);
    }
    return result;
  }
  renderSrcCheckboxes(srcCheckboxContainer) {
    srcCheckboxContainer.empty();
    srcCheckboxContainer.addClass("calendar-src-checkboxes");
    for (let src of this.eventSrc) {
      const checkboxContainer = srcCheckboxContainer.createDiv({ cls: "src-checkbox-item" });
      const checkbox = checkboxContainer.createEl("input", {
        type: "checkbox",
        attr: {
          id: `src-checkbox-${src.path}`,
          checked: this.selectedSrcPaths.has(src.path) ? "checked" : null
        }
      });
      checkbox.addEventListener("change", () => {
        if (checkbox.checked) {
          this.selectedSrcPaths.add(src.path);
        } else {
          this.selectedSrcPaths.delete(src.path);
        }
        this.refreshCalendar();
      });
      checkboxContainer.createEl("label", {
        text: src.path,
        attr: { for: `src-checkbox-${src.path}` }
      });
    }
  }
  isPathInActiveSrc(pagePath) {
    const eventSrc = this.eventSrc.filter(
      (el) => this.selectedSrcPaths.has(el.path)
    );
    return eventSrc.some(
      (src) => src.includes(pagePath)
    );
  }
  refreshCalendar() {
    if (!this.calendar)
      return;
    this.calendar.removeAllEvents();
    const events = [...this.calendarSettings.restTime];
    for (let page of this.localStorage) {
      if (!this.isPathInActiveSrc(page.file.path))
        continue;
      events.push(...this.pageToEvents(page));
    }
    for (let event of events) {
      this.calendar.addEvent(event);
    }
  }
  async render(container) {
    const subscribedData = await this.cache.subscribe(this.idForCache, this.eventSrc, this);
    this.localStorage = subscribedData;
    const events = [];
    for (const page of subscribedData) {
      if (!this.isPathInActiveSrc(page.file.path))
        continue;
      events.push(...this.pageToEvents(page));
    }
    this.calendar = renderCalendar(
      container,
      {
        //@ts-ignore // TODO remove
        events: [
          ...this.calendarSettings.restTime,
          ...events
        ]
      },
      // as EventSource,
      this.getSettingsCalendar()
    );
    this.calendar.setOption("weekNumbers", true);
    window.setTimeout(
      (_3) => {
        var _a, _b;
        if (import_obsidian.Platform.isMobile)
          (_a = this.calendar) == null ? void 0 : _a.changeView("timeGrid3Days");
        else
          (_b = this.calendar) == null ? void 0 : _b.changeView("timeGridWeek");
      },
      1
    );
    this.calendar.render();
  }
  getSettingsCalendar() {
    const result = {
      firstDay: 1,
      weekNumbers: true,
      timeFormat24h: true,
      // TODO remove any
      eventClick: (arg) => {
        const { event, jsEvent } = arg;
        this.noteManager.openNote(event);
      },
      // TODO remove any
      modifyEvent: async (newPos, oldPos) => {
        var _a, _b;
        const props = newPos.extendedProps;
        const event = {
          start: newPos.start,
          end: newPos.end,
          allDay: newPos.allDay
        };
        if (props.notePath) {
          const page = this.cache.getPage(props.notePath);
          if (!page) {
            console.warn(`${MSG_PLG_NAME}: can't find page by Event. eventID: ${props.notePath}`);
            return false;
          }
          const tick = page.ticks.find(
            (el) => el.name == props.tickName
          );
          if (!tick) {
            console.warn(`${MSG_PLG_NAME}: can't find tick by page. Page - tickName: ${props.notePath} - ${props.tickName}`);
            return false;
          }
          if (tick.ff_duration && oldPos.allDay && !newPos.allDay) {
            event.end = timeAdd(newPos.start, tick.ff_duration);
            newPos.setEnd(event.end);
          }
          const newProp = CalendarEventToIDate(event);
          if (newPos.allDay) {
            newProp["ff_duration"] = millisecToString(
              (_a = tick.ff_duration) == null ? void 0 : _a.as("milliseconds")
            );
          }
          this.noteManager.changeTickFile(props.notePath, props.tickName, newProp);
        } else {
          const page = this.cache.getPage(newPos.id);
          if (!page) {
            console.warn(`${MSG_PLG_NAME}: can't find page by Event. eventID: ${newPos.id}`);
            return false;
          }
          if (page.ff_duration && oldPos.allDay && !newPos.allDay) {
            event.end = timeAdd(newPos.start, page.ff_duration);
            newPos.setEnd(event.end);
          }
          const newProp = CalendarEventToIDate(event);
          if (newPos.allDay) {
            newProp["ff_duration"] = millisecToString(
              (_b = page.ff_duration) == null ? void 0 : _b.as("milliseconds")
            );
          }
          this.noteManager.changePropertyFile(newPos.id, newProp);
        }
        return true;
      },
      select: (start, end, allDay, __viewMode) => {
        new nameModal(
          this.app,
          async (nameOfFile) => {
            try {
              if (!nameOfFile)
                throw 1;
              const pathOfFile = this.placeForCreatingNote + `/${nameOfFile}.md`;
              await this.noteManager.createFile(pathOfFile);
              setTimeout(
                () => this.noteManager.changePropertyFile(
                  pathOfFile,
                  CalendarEventToIDate({ start, end, allDay })
                ),
                1500
              );
            } catch (e3) {
              console.error(e3);
              new import_obsidian.Notice("Hm... error...");
            }
          }
        ).open();
      },
      openContextMenuForEvent: (e3, mouseEvent) => {
        this.contextMenuForEvent(e3, mouseEvent);
      },
      slotDuration: this.calendarSettings.slotDuration
    };
    if (import_obsidian.Platform.isMobile) {
      result.eventClick = (arg) => {
        const { event, jsEvent } = arg;
        this.contextMenuForEvent(event, jsEvent);
      };
      result.openContextMenuForEvent = (_3, __) => {
      };
    }
    return result;
  }
  contextMenuForEvent(event, mouseEvent) {
    const menu = new import_obsidian.Menu();
    menu.addItem(
      (item) => item.setTitle(event.id).onClick(async () => this.noteManager.openNote(event))
    );
    menu.showAtMouseEvent(mouseEvent);
  }
};
var nameModal = class extends import_obsidian.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h1", { text: "Name of task" });
    new import_obsidian.Setting(contentEl).setName("Name").addText(
      (text) => text.onChange((value) => this.result = value)
    );
    new import_obsidian.Setting(contentEl).addButton(
      (btn) => btn.setButtonText("Submit").setCta().onClick(() => {
        this.close();
        this.onSubmit(this.result);
      })
    );
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/cache.ts
var import_obsidian2 = require("obsidian");
var Cache2 = class {
  constructor(noteManager, vault) {
    this.storage = /* @__PURE__ */ new Map();
    this.subscribers = /* @__PURE__ */ new Map();
    this.initSync = new Promise(
      (resolve) => this.initSyncResolve = resolve
    );
    this.isInited = false;
    this.noteManager = noteManager;
    this.vault = vault;
  }
  async init() {
    if (this.isInited)
      return;
    await this.initStorage();
    this.initSyncResolve();
    this.isInited = true;
  }
  getPage(path) {
    return this.storage.get(path);
  }
  log() {
    console.log("storage", this.storage);
    console.log("subscribers", this.subscribers);
  }
  async subscribe(id, paths, subscriber) {
    this.subscribers.set(
      id,
      {
        paths,
        subscriber
      }
    );
    if (!this.isInited)
      await this.initSync;
    const result = [];
    for (let [key, value] of this.storage) {
      const isOk = paths.some(
        (el) => el.includes(key)
      );
      if (isOk) {
        result.push(value);
      }
    }
    return result;
  }
  unsubscribe(id) {
    this.subscribers.delete(id);
  }
  async renameFile(file, oldPath) {
    if (!this.isInited)
      return;
    const oldPage = this.storage.get(oldPath);
    const page = { ...oldPage };
    page.file = { ...oldPage.file };
    page.file.path = file.path;
    page.file.name = file.basename;
    this.storage.delete(oldPath);
    this.storage.set(file.path, page);
    for (let [_3, { paths, subscriber }] of this.subscribers) {
      const isOk1 = paths.some((el) => el.includes(file.path));
      const isOk2 = paths.some((el) => el.includes(oldPath));
      for (let path of paths) {
        if (isOk1 && isOk2)
          subscriber.renameFile(page, oldPage);
        else if (isOk2)
          subscriber.deleteFile(oldPage);
        else if (isOk1)
          subscriber.addFile(page);
      }
    }
  }
  async addFile(file) {
    if (!this.isInited)
      return;
    const page = await this.noteManager.getPage(file);
    this.storage.set(file.path, page);
    for (let [_3, { paths, subscriber }] of this.subscribers) {
      const isOk = paths.some((el) => el.includes(file.path));
      if (isOk)
        subscriber.addFile(page);
    }
  }
  async changeFile(file) {
    if (!this.isInited)
      return;
    const page = await this.noteManager.getPage(file);
    const oldPage = this.storage.get(file.path);
    if (isEqualObj(page, oldPage))
      return;
    this.storage.set(file.path, page);
    for (let [_3, { paths, subscriber }] of this.subscribers) {
      const isOk = paths.some((el) => el.includes(file.path));
      if (isOk)
        subscriber.changeFile(page, oldPage);
    }
  }
  async deleteFile(file) {
    if (!this.isInited)
      return;
    const page = this.storage.get(file.path);
    this.storage.delete(file.path);
    for (let [_3, { paths, subscriber }] of this.subscribers) {
      const isOk = paths.some((el) => el.includes(file.path));
      if (isOk)
        subscriber.deleteFile(page);
    }
  }
  async reset() {
    this.isInited = false;
    this.storage.clear();
    const tmp = this.subscribers;
    this.subscribers = /* @__PURE__ */ new Map();
    await this.init();
    for (let [_3, { subscriber }] of tmp)
      subscriber.reset();
  }
  async initStorage() {
    const tFiles = this.vault.getMarkdownFiles();
    const notice = new import_obsidian2.Notice(
      `${MSG_PLG_NAME}: there are ${tFiles.length} notes`,
      1e3 * 60
      // 60 seconds
    );
    for (let i3 in tFiles) {
      const tFile = tFiles[i3];
      notice.setMessage(`${MSG_PLG_NAME}: (${i3}/${tFiles.length}) added ${tFile.path}`);
      this.storage.set(
        tFile.path,
        await this.noteManager.getPage(tFile)
      );
    }
    notice.hide();
    new import_obsidian2.Notice(`${MSG_PLG_NAME}: cache has been inited`);
  }
};

// src/setting.ts
var import_obsidian3 = require("obsidian");
var MySettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    let { containerEl } = this;
    containerEl.empty();
    const settings = this.plugin.getSettings();
    new import_obsidian3.Setting(containerEl).setHeading().setName("It's recommended to reload ObsidianApp after changing the settings");
    new import_obsidian3.Setting(containerEl).addButton(
      (btn) => {
        btn.setButtonText("Set Default Values").onClick(
          () => {
            this.plugin.saveSettings(DEFAULT_SETTINGS);
            new import_obsidian3.Notice(MSG_PLG_NAME + "The default settings has been applied");
          }
        );
      }
    );
    new import_obsidian3.Setting(containerEl).setHeading();
    new import_obsidian3.Setting(containerEl).setName("Calendar").setHeading();
    new import_obsidian3.Setting(containerEl).setName("Slot duration").setDesc(`Default: ${DEFAULT_SETTINGS.calendar.slotDuration}`).addText(
      (component) => {
        component.setPlaceholder("hh:mm:ss").setValue(settings.calendar.slotDuration).onChange(
          (value) => {
            settings.calendar.slotDuration = value;
            this.plugin.saveSettings(settings);
          }
        );
      }
    );
    new import_obsidian3.Setting(containerEl).setName("Colours").setHeading();
    for (let key of Object.keys(settings.calendar.colours)) {
      this.addColourSetting(
        containerEl,
        key,
        DEFAULT_SETTINGS.calendar.colours[key],
        settings.calendar.colours[key],
        (val) => {
          settings.calendar.colours[key] = val;
          this.plugin.saveSettings(settings);
        }
      );
    }
    new import_obsidian3.Setting(containerEl).setName("RestTime").setHeading();
    for (let index8 in settings.calendar.restTime) {
      const el = settings.calendar.restTime[index8];
      let name = "";
      if (el.color === COLOUR_REST) {
        name = "Rest time";
      } else if (el.color === COLOUR_SLEEP) {
        name = "Sleep time";
      } else
        continue;
      new import_obsidian3.Setting(containerEl).setName(`Start of ${name} (${index8})`).addText(
        (text) => {
          text.setValue(el.startTime).setPlaceholder("hh:mm:ss").onChange(
            (val) => {
              settings.calendar.restTime[index8].startTime = val;
              this.plugin.saveSettings(settings);
            }
          );
        }
      );
      new import_obsidian3.Setting(containerEl).setName(`End of ${name} (${index8})`).addText(
        (text) => {
          text.setValue(el.endTime).setPlaceholder("hh:mm:ss").onChange(
            (val) => {
              settings.calendar.restTime[index8].endTime = val;
              this.plugin.saveSettings(settings);
            }
          );
        }
      );
    }
    new import_obsidian3.Setting(containerEl).setHeading();
    new import_obsidian3.Setting(containerEl).setName("StatusCorrector").setHeading();
    const statusCorrector = settings.statusCorrector.isOn;
    new import_obsidian3.Setting(containerEl).setName("Enable tool").addToggle(
      (toggle) => toggle.setValue(statusCorrector).onChange(
        (value) => {
          settings.statusCorrector.isOn = value;
          this.plugin.saveSettings(settings);
          this.display();
        }
      )
    );
    if (statusCorrector) {
      new import_obsidian3.Setting(containerEl).setName("Start on Start Up").addToggle(
        (toggle) => toggle.setValue(settings.statusCorrector.startOnStartUp).onChange(
          (val) => {
            settings.statusCorrector.startOnStartUp = val;
            this.plugin.saveSettings(settings);
          }
        )
      );
    }
  }
  addColourSetting(containerEl, name, defaultValue, currentValue, callback) {
    new import_obsidian3.Setting(containerEl).setName(name).setDesc(`Default: ${defaultValue}`).addText(
      (component) => {
        component.setPlaceholder("#0f0f0f").setValue(currentValue).onChange((val) => callback(val));
      }
    );
  }
};

// src/views/statusCorrector.ts
var import_obsidian4 = require("obsidian");
var StatusCorrector = class {
  constructor(idForCache, eventSrc, cache, noteManager) {
    this.subscribed = false;
    this.whileSubscribing = new Promise(
      (resolve) => this.resolveSubscribing = resolve
    );
    this.cache = cache;
    this.idForCache = idForCache;
    this.eventSrc = eventSrc;
    this.noteManager = noteManager;
  }
  async init() {
    await this.cache.subscribe(this.idForCache, this.eventSrc, this);
    this.subscribed = true;
    this.resolveSubscribing();
  }
  async correctNote(page) {
    let status = page.ff_status;
    if (!status)
      return false;
    checkProgress: {
      const tasks = await getProgress(this.cache, this.noteManager, page);
      if (status == TEXT_DONE && tasks.all != tasks.done) {
        status = TEXT_IN_PROGRESS;
      } else if (status == TEXT_SOON && tasks.done != 0) {
        status = TEXT_BLOCKED;
      } else if (status != TEXT_IN_PROGRESS && tasks.done == 0 && tasks.all != 0) {
        status = TEXT_SOON;
      }
    }
    checkDate: {
      const checks = [TEXT_SOON, TEXT_BLOCKED, TEXT_CHILD_IN_PROGRESS];
      if (page.ff_date && checks.indexOf(status) != -1) {
        status = TEXT_IN_PROGRESS;
      }
    }
    checkStatus: {
      const child_ = await getChildNotePaths(page.file.path);
      const statuses = new Array();
      for (let children_ of child_) {
        const children = this.cache.getPage(children_);
        if (!(children == null ? void 0 : children.ff_status))
          continue;
        statuses.push(children.ff_status);
      }
      switch (status) {
        case TEXT_SOON: {
          if (statuses.indexOf(TEXT_IN_PROGRESS) != -1)
            status = TEXT_CHILD_IN_PROGRESS;
          else if (statuses.indexOf(TEXT_CHILD_IN_PROGRESS) != -1)
            status = TEXT_CHILD_IN_PROGRESS;
          else if (statuses.indexOf(TEXT_BLOCKED) != -1)
            status = TEXT_BLOCKED;
          else if (statuses.indexOf(TEXT_DONE) != -1)
            status = TEXT_BLOCKED;
          break;
        }
        case TEXT_BLOCKED: {
          if (statuses.indexOf(TEXT_IN_PROGRESS) != -1)
            status = TEXT_CHILD_IN_PROGRESS;
          else if (statuses.indexOf(TEXT_CHILD_IN_PROGRESS) != -1)
            status = TEXT_CHILD_IN_PROGRESS;
          break;
        }
        case TEXT_CHILD_IN_PROGRESS: {
          status = TEXT_BLOCKED;
          if (statuses.indexOf(TEXT_IN_PROGRESS) != -1)
            status = TEXT_CHILD_IN_PROGRESS;
          else if (statuses.indexOf(TEXT_CHILD_IN_PROGRESS) != -1)
            status = TEXT_CHILD_IN_PROGRESS;
          else if (statuses.indexOf(TEXT_DONE) != -1)
            status = TEXT_IN_PROGRESS;
          break;
        }
        case TEXT_DONE: {
          if (statuses.indexOf(TEXT_SOON) != -1)
            status = TEXT_BLOCKED;
          else if (statuses.indexOf(TEXT_BLOCKED) != -1)
            status = TEXT_BLOCKED;
          else if (statuses.indexOf(TEXT_IN_PROGRESS) != -1)
            status = TEXT_CHILD_IN_PROGRESS;
          else if (statuses.indexOf(TEXT_CHILD_IN_PROGRESS) != -1)
            status = TEXT_CHILD_IN_PROGRESS;
          break;
        }
      }
    }
    if (status == page.ff_status)
      return false;
    page.ff_status = status;
    await this.noteManager.changeStatusFile(page.file.path, status);
    return true;
  }
  async correctAllNotes() {
    const notice = new import_obsidian4.Notice(
      MSG_PLG_NAME + ": Start checking status of notes",
      1e3 * 60
      // 60 seconds
    );
    if (!this.subscribed) {
      await this.whileSubscribing;
    }
    const queuePaths = [];
    const set = /* @__PURE__ */ new Set();
    const computes = [];
    for (let el of this.eventSrc) {
      computes.push(
        getNotesWithoutParent(el.path)
      );
    }
    let parents_ = await Promise.all(computes);
    let parents = [];
    for (let el of parents_) {
      parents.push(...el);
    }
    parents = parents.unique().filter(
      (el) => this.eventSrc.some((src) => src.includes(el.file.path))
    );
    for (let parent of parents) {
      queuePaths.push(parent.file.path);
      set.add(parent.file.path);
    }
    for (let leftPointer = 0; leftPointer < queuePaths.length; ++leftPointer) {
      let path = queuePaths[leftPointer];
      const child = await getChildNotePaths(path);
      for (let children of child) {
        if (set.has(children))
          continue;
        set.add(children);
        queuePaths.push(children);
      }
    }
    for (let pointer = queuePaths.length - 1; pointer > 0; --pointer) {
      let i3 = queuePaths.length - pointer - 1;
      notice.setMessage(`${MSG_PLG_NAME}(status) ${i3}/${queuePaths.length}`);
      await this.correctNote(
        this.cache.getPage(
          queuePaths[pointer]
        )
      );
    }
    notice.setMessage(MSG_PLG_NAME + ": Status of Notes has been checked");
    setTimeout(
      () => notice.hide(),
      3e3
    );
    new import_obsidian4.Notice(`${MSG_PLG_NAME}: Notes has been checked`);
  }
  destroy() {
    this.cache.unsubscribe(this.idForCache);
  }
  renameFile(newPage, oldPage) {
  }
  deleteFile(page) {
  }
  reset() {
  }
  async addFile(page) {
    await this.changeFile(page, page);
  }
  async changeFile(page, oldPage) {
    const queuePaths = [];
    const set = /* @__PURE__ */ new Set();
    queuePaths.push(page.file.path);
    set.add(page.file.path);
    for (let leftPointer = 0; leftPointer < queuePaths.length; ++leftPointer) {
      const path = queuePaths[leftPointer];
      const page2 = this.cache.getPage(path);
      const oldStatus = page2.ff_status;
      const isChanged = await this.correctNote(page2);
      if (!isChanged && page2.ff_status == oldPage.ff_status)
        continue;
      new import_obsidian4.Notice(
        `${page2.file.name} - change status: ${oldStatus} => ${page2.ff_status}`
      );
      const child = await getParentNote(page2);
      for (let children of child) {
        if (!children)
          continue;
        const newPath = children.file.path;
        if (set.has(newPath))
          continue;
        set.add(newPath);
        queuePaths.push(newPath);
      }
    }
  }
};

// src/views/TickCheker.ts
var import_obsidian5 = require("obsidian");
var TickChecker = class {
  constructor(idForCache, eventSrc, cache, noteManager) {
    this.cache = cache;
    this.idForCache = idForCache;
    this.eventSrc = eventSrc;
    this.noteManager = noteManager;
  }
  async init() {
    const data = await this.cache.subscribe(this.idForCache, this.eventSrc, this);
    const calcs = data.map(
      (el) => this.process(el)
    );
    await Promise.all(calcs);
    this.cache.unsubscribe(this.idForCache);
  }
  async process(page) {
    for (let tick of page.ticks) {
      if (isNaN(safeParseInt(tick.name)))
        continue;
      let text = await this.noteManager.getText(page.file.path);
      const regExp = new RegExp(`\\[t::\\s*${tick.name}(,[^\\]]*|)\\]`, "gm");
      await this.noteManager.setText(
        page.file.path,
        text.replace(regExp, `[t::${tick.name}_$1]`)
      );
      new import_obsidian5.Notice(`${MSG_PLG_NAME}: change tickname in ${page.file.name}: ${tick.name}`);
    }
  }
  renameFile(newPage, oldPage) {
  }
  deleteFile(page) {
  }
  addFile(page) {
  }
  changeFile(newPage, oldPage) {
  }
  reset() {
  }
};

// src/NoteManager.ts
var import_obsidian6 = require("obsidian");
var NoteManager = class {
  constructor(vault, metadataCache, fileManager, workspace) {
    this.vault = vault;
    this.metadataCache = metadataCache;
    this.fileManager = fileManager;
    this.workspace = workspace;
  }
  async createFile(path) {
    await this.vault.create(path, "");
    new import_obsidian6.Notice(MSG_PLG_NAME + "created " + path);
  }
  async changePropertyFile(path, event) {
    const tFile = this.metadataCache.getFirstLinkpathDest(path, "");
    await this.fileManager.processFrontMatter(
      tFile,
      (property) => {
        property["ff_date"] = event["ff_date"].toISOString().slice(0, -14);
        property["ff_timeStart"] = event["ff_timeStart"];
        property["ff_duration"] = event["ff_duration"];
      }
    );
  }
  async changeStatusFile(path, status) {
    const tFile = this.metadataCache.getFirstLinkpathDest(path, "");
    await this.fileManager.processFrontMatter(
      tFile,
      (property) => {
        property["ff_status"] = status;
      }
    );
  }
  async changeTickFile(path, tickname, event) {
    const tFile = this.metadataCache.getFirstLinkpathDest(path, "");
    const text = await this.vault.read(tFile);
    const regExp = new RegExp(`\\[t::\\s*${tickname}(,[^\\]]*|)\\]`, "gm");
    const date = event["ff_date"].toISOString().slice(0, -14);
    const newString = `[t::${tickname},${date},${event["ff_timeStart"]},${event["ff_duration"]}]`;
    await this.vault.modify(
      tFile,
      text.replace(regExp, newString)
    );
  }
  openNote(event) {
    var _a;
    const tFile = this.metadataCache.getFirstLinkpathDest(
      ((_a = event == null ? void 0 : event.extendedProps) == null ? void 0 : _a.notePath) || event.id,
      ""
    );
    const leaf = this.workspace.getLeaf(true);
    tFile && leaf.openFile(tFile);
  }
  async getPage(file) {
    var _a;
    const result = {
      file: {
        path: file.path,
        name: file.basename
      },
      ticks: getTicksFromText(await this.vault.cachedRead(file)),
      ff_duration: "",
      ff_timeStart: "",
      // TODO из-за того, что не все заметки имеют ff_date, он должен возвращать null, но это bad practice
      //@ts-ignore
      ff_date: null
    };
    const property = (_a = this.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
    if (!property) {
      return result;
    }
    const added = {
      ff_duration: dv.duration(property.ff_duration),
      ff_timeStart: dv.duration(property.ff_timeStart),
      ff_date: dv.date(property.ff_date),
      ff_status: property.ff_status
    };
    return {
      ...result,
      ...added
    };
  }
  getTaskCount(page) {
    var _a;
    const result = {
      done: 0,
      all: 0
    };
    const tFile = this.vault.getFileByPath(page.file.path);
    if (!tFile)
      return result;
    const items = (_a = this.metadataCache.getFileCache(tFile)) == null ? void 0 : _a.listItems;
    if (items)
      for (let item of items) {
        if (item.task == void 0)
          continue;
        if (item.task == "x") {
          ++result.done;
        }
        ++result.all;
      }
    return result;
  }
  async getText(path) {
    const tFile = this.metadataCache.getFirstLinkpathDest(path, "");
    const text = await this.vault.read(tFile);
    return text;
  }
  async setText(path, text) {
    const tFile = this.metadataCache.getFirstLinkpathDest(path, "");
    await this.vault.modify(tFile, text);
  }
};

// src/main.ts
var MyPlugin = class extends import_obsidian7.Plugin {
  constructor(app, manifest) {
    super(app, manifest);
    const noteManager = new NoteManager(
      this.app.vault,
      this.app.metadataCache,
      this.app.fileManager,
      this.app.workspace
    );
    this.noteManager = noteManager;
    this.cache = new Cache2(this.noteManager, this.app.vault);
  }
  async onload() {
    await this.loadSettings();
    this.initRegister();
    this.tickChecker = new TickChecker(
      3 /* TICK_CHECKER */,
      this.settings.source.noteSources,
      this.cache,
      this.noteManager
    );
    if (this.settings.statusCorrector.isOn) {
      this.statusCorrector = new StatusCorrector(
        2 /* STATUS_CORRECTOR */,
        this.settings.source.noteSources,
        this.cache,
        this.noteManager
      );
      if (this.settings.statusCorrector.startOnStartUp)
        this.statusCorrector.correctAllNotes();
      this.addCommand({
        id: "fullStatusCorrect",
        name: MSG_PLG_NAME + "Full StatusCorrector",
        callback: () => {
          this.statusCorrector.correctAllNotes();
        }
      });
    }
    this.app.workspace.onLayoutReady(() => this.init());
    this.registerView(
      VIEW_TYPE,
      (leaf) => {
        this.calendar = new CalendarView(
          leaf,
          1 /* CALENDAR */,
          this.settings.source.noteSources,
          this.settings.calendar,
          this.cache,
          this.noteManager,
          this.settings.source.defaultCreatePath
        );
        return this.calendar;
      }
    );
    this.addRibbonIcon("info", MSG_PLG_NAME + "Open Calendar", () => this.activateView());
    this.addCommand({
      id: "reset-cache",
      name: MSG_PLG_NAME + "Reset Cache",
      callback: () => {
        this.cache.reset();
      }
    });
    this.addCommand({
      id: "log-cache",
      name: MSG_PLG_NAME + "Log Cache",
      callback: () => {
        this.cache.log();
      }
    });
  }
  onunload() {
    var _a;
    (_a = this.statusCorrector) == null ? void 0 : _a.destroy();
  }
  async init() {
    var _a, _b;
    await this.cache.init();
    (_a = this.tickChecker) == null ? void 0 : _a.init();
    (_b = this.statusCorrector) == null ? void 0 : _b.init();
  }
  initRegister() {
    this.registerEvent(
      this.app.metadataCache.on("changed", (file) => {
        this.cache.changeFile(file);
      })
    );
    this.registerEvent(
      this.app.vault.on(
        "rename",
        (file, oldPath) => {
          if (!file.basename)
            return;
          this.cache.renameFile(file, oldPath);
        }
      )
    );
    this.registerEvent(
      this.app.vault.on(
        "delete",
        (file) => this.cache.deleteFile(file)
      )
    );
    this.registerEvent(
      this.app.vault.on(
        "create",
        (file) => {
          if (!file.basename)
            return;
          this.cache.addFile(file);
        }
      )
    );
  }
  async activateView() {
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE);
    if (leaves.length === 0) {
      const leaf = this.app.workspace.getLeaf(false);
      await leaf.setViewState({
        type: VIEW_TYPE,
        active: true
      });
    } else if (leaves.length === 1) {
      leaves[0].view.onOpen();
      this.app.workspace.setActiveLeaf(leaves[0]);
    } else
      for (let leaf of leaves)
        leaf.detach();
  }
  // Settings
  getSettings() {
    return JSON.parse(
      JSON.stringify(this.settings)
    );
  }
  async saveSettings(settings) {
    this.settings = settings;
    await this.saveData(this.settings);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    this.addSettingTab(new MySettingTab(this.app, this));
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvZXJyb3JzLmpzIiwgIm5vZGVfbW9kdWxlcy9vYnNpZGlhbi1kYXRhdmlldy9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvZm9ybWF0cy5qcyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy96b25lLmpzIiwgIm5vZGVfbW9kdWxlcy9vYnNpZGlhbi1kYXRhdmlldy9ub2RlX21vZHVsZXMvbHV4b24vc3JjL3pvbmVzL3N5c3RlbVpvbmUuanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvem9uZXMvSUFOQVpvbmUuanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9sb2NhbGUuanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvem9uZXMvZml4ZWRPZmZzZXRab25lLmpzIiwgIm5vZGVfbW9kdWxlcy9vYnNpZGlhbi1kYXRhdmlldy9ub2RlX21vZHVsZXMvbHV4b24vc3JjL3pvbmVzL2ludmFsaWRab25lLmpzIiwgIm5vZGVfbW9kdWxlcy9vYnNpZGlhbi1kYXRhdmlldy9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvem9uZVV0aWwuanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvc2V0dGluZ3MuanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC91dGlsLmpzIiwgIm5vZGVfbW9kdWxlcy9vYnNpZGlhbi1kYXRhdmlldy9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvZW5nbGlzaC5qcyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2Zvcm1hdHRlci5qcyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2ludmFsaWQuanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9yZWdleFBhcnNlci5qcyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9kdXJhdGlvbi5qcyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbnRlcnZhbC5qcyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbmZvLmpzIiwgIm5vZGVfbW9kdWxlcy9vYnNpZGlhbi1kYXRhdmlldy9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvZGlmZi5qcyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2RpZ2l0cy5qcyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL3Rva2VuUGFyc2VyLmpzIiwgIm5vZGVfbW9kdWxlcy9vYnNpZGlhbi1kYXRhdmlldy9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvY29udmVyc2lvbnMuanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvZGF0ZXRpbWUuanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L3NyYy9zZXR0aW5ncy50cyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvc3JjL2FwaS9yZXN1bHQudHMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9wYXJzaW1tb24vYnVpbGQvcGFyc2ltbW9uLnVtZC5taW4uanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9lbW9qaS1yZWdleC9pbmRleC5tanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L3NyYy91dGlsL25vcm1hbGl6ZS50cyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvc3JjL2RhdGEtbW9kZWwvdmFsdWUudHMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L3NyYy9leHByZXNzaW9uL2ZpZWxkLnRzIiwgIm5vZGVfbW9kdWxlcy9vYnNpZGlhbi1kYXRhdmlldy9zcmMvZGF0YS1pbmRleC9zb3VyY2UudHMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L3NyYy9leHByZXNzaW9uL3BhcnNlLnRzIiwgIm5vZGVfbW9kdWxlcy9vYnNpZGlhbi1kYXRhdmlldy9zcmMvcXVlcnkvcXVlcnkudHMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L3NyYy9xdWVyeS9wYXJzZS50cyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvc3JjL2luZGV4LnRzIiwgIm5vZGVfbW9kdWxlcy9pY2FsLmpzL2J1aWxkL2ljYWwuanMiLCAic3JjL21haW4udHMiLCAic3JjL3ZpZXdzL0NhbGVuZGFyVmlldy50cyIsICJzcmMvdHlwZXMudHMiLCAic3JjL2NvbnN0YW50cy50cyIsICJzcmMvdXRpbC50cyIsICJub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL25vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL3V0aWwuanMiLCAibm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvY29yZS9ub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9vcHRpb25zLmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvbm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvY3JlYXRlLWVsZW1lbnQuanMiLCAibm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvY29yZS9ub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9kaWZmL3Byb3BzLmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvbm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvY29tcG9uZW50LmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvbm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvY3JlYXRlLWNvbnRleHQuanMiLCAibm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvY29yZS9ub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9jb25zdGFudHMuanMiLCAibm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvY29yZS9ub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9kaWZmL2NoaWxkcmVuLmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvbm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvZGlmZi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL25vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL3JlbmRlci5qcyIsICJub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL25vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL2Nsb25lLWVsZW1lbnQuanMiLCAibm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvY29yZS9ub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9kaWZmL2NhdGNoLWVycm9yLmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvbm9kZV9tb2R1bGVzL3ByZWFjdC9ob29rcy9zcmMvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvY29yZS9ub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvdXRpbC5qcyIsICJub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL25vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy9QdXJlQ29tcG9uZW50LmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvbm9kZV9tb2R1bGVzL3ByZWFjdC9jb21wYXQvc3JjL21lbW8uanMiLCAibm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvY29yZS9ub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvZm9yd2FyZFJlZi5qcyIsICJub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL25vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy9DaGlsZHJlbi5qcyIsICJub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL25vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy9zdXNwZW5zZS5qcyIsICJub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL25vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy9zdXNwZW5zZS1saXN0LmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvbm9kZV9tb2R1bGVzL3ByZWFjdC9jb21wYXQvc3JjL3BvcnRhbHMuanMiLCAibm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvY29yZS9ub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvcmVuZGVyLmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvbm9kZV9tb2R1bGVzL3ByZWFjdC9jb21wYXQvc3JjL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvaW50ZXJuYWwtY29tbW9uLmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvZGF5Z3JpZC9pbnRlcm5hbC5qcyIsICJub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9kYXlncmlkL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL3RpbWVncmlkL2ludGVybmFsLmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL3RpbWVncmlkL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvd2Vla2RheS50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2hlbHBlcnMudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9kYXRldXRpbC50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2l0ZXJyZXN1bHQudHMiLCAibm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2NhbGxiYWNraXRlcnJlc3VsdC50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL25scC9pMThuLnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvbmxwL3RvdGV4dC50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL25scC9wYXJzZXRleHQudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy90eXBlcy50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL25scC9pbmRleC50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2RhdGV0aW1lLnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvcGFyc2VvcHRpb25zLnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvcGFyc2VzdHJpbmcudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9kYXRld2l0aHpvbmUudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9vcHRpb25zdG9zdHJpbmcudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9jYWNoZS50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL21hc2tzLnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvaXRlcmluZm8veWVhcmluZm8udHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9pdGVyaW5mby9tb250aGluZm8udHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9pdGVyaW5mby9lYXN0ZXIudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9pdGVyaW5mby9pbmRleC50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2l0ZXIvcG9zbGlzdC50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2l0ZXIvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9ycnVsZS50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2l0ZXJzZXQudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9ycnVsZXN0ci50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL3JydWxlc2V0LnRzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL3JydWxlL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2xpc3QvaW50ZXJuYWwuanMiLCAibm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvbGlzdC9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9pbnRlcmFjdGlvbi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9nb29nbGUtY2FsZW5kYXIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvaWNhbGVuZGFyL2luZGV4LmpzIiwgImxpYi9vYnNpZGlhbi1mdWxsLWNhbGVuZGFyL2NhbGVuZGFyLnRzIiwgInNyYy9jYWNoZS50cyIsICJzcmMvc2V0dGluZy50cyIsICJzcmMvdmlld3Mvc3RhdHVzQ29ycmVjdG9yLnRzIiwgInNyYy92aWV3cy9UaWNrQ2hla2VyLnRzIiwgInNyYy9Ob3RlTWFuYWdlci50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiLy8gdGhlc2UgYXJlbid0IHJlYWxseSBwcml2YXRlLCBidXQgbm9yIGFyZSB0aGV5IHJlYWxseSB1c2VmdWwgdG8gZG9jdW1lbnRcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBMdXhvbkVycm9yIGV4dGVuZHMgRXJyb3Ige31cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZERhdGVUaW1lRXJyb3IgZXh0ZW5kcyBMdXhvbkVycm9yIHtcbiAgY29uc3RydWN0b3IocmVhc29uKSB7XG4gICAgc3VwZXIoYEludmFsaWQgRGF0ZVRpbWU6ICR7cmVhc29uLnRvTWVzc2FnZSgpfWApO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRJbnRlcnZhbEVycm9yIGV4dGVuZHMgTHV4b25FcnJvciB7XG4gIGNvbnN0cnVjdG9yKHJlYXNvbikge1xuICAgIHN1cGVyKGBJbnZhbGlkIEludGVydmFsOiAke3JlYXNvbi50b01lc3NhZ2UoKX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkRHVyYXRpb25FcnJvciBleHRlbmRzIEx1eG9uRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihyZWFzb24pIHtcbiAgICBzdXBlcihgSW52YWxpZCBEdXJhdGlvbjogJHtyZWFzb24udG9NZXNzYWdlKCl9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IgZXh0ZW5kcyBMdXhvbkVycm9yIHt9XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRVbml0RXJyb3IgZXh0ZW5kcyBMdXhvbkVycm9yIHtcbiAgY29uc3RydWN0b3IodW5pdCkge1xuICAgIHN1cGVyKGBJbnZhbGlkIHVuaXQgJHt1bml0fWApO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRBcmd1bWVudEVycm9yIGV4dGVuZHMgTHV4b25FcnJvciB7fVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBab25lSXNBYnN0cmFjdEVycm9yIGV4dGVuZHMgTHV4b25FcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiWm9uZSBpcyBhbiBhYnN0cmFjdCBjbGFzc1wiKTtcbiAgfVxufVxuIiwgIi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5jb25zdCBuID0gXCJudW1lcmljXCIsXG4gIHMgPSBcInNob3J0XCIsXG4gIGwgPSBcImxvbmdcIjtcblxuZXhwb3J0IGNvbnN0IERBVEVfU0hPUlQgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBuLFxuICBkYXk6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgREFURV9NRUQgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBzLFxuICBkYXk6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgREFURV9NRURfV0lUSF9XRUVLREFZID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogcyxcbiAgZGF5OiBuLFxuICB3ZWVrZGF5OiBzLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVfRlVMTCA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IGwsXG4gIGRheTogbixcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFX0hVR0UgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBsLFxuICBkYXk6IG4sXG4gIHdlZWtkYXk6IGwsXG59O1xuXG5leHBvcnQgY29uc3QgVElNRV9TSU1QTEUgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbn07XG5cbmV4cG9ydCBjb25zdCBUSU1FX1dJVEhfU0VDT05EUyA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgVElNRV9XSVRIX1NIT1JUX09GRlNFVCA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG4gIHRpbWVab25lTmFtZTogcyxcbn07XG5cbmV4cG9ydCBjb25zdCBUSU1FX1dJVEhfTE9OR19PRkZTRVQgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxuICB0aW1lWm9uZU5hbWU6IGwsXG59O1xuXG5leHBvcnQgY29uc3QgVElNRV8yNF9TSU1QTEUgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgaG91ckN5Y2xlOiBcImgyM1wiLFxufTtcblxuZXhwb3J0IGNvbnN0IFRJTUVfMjRfV0lUSF9TRUNPTkRTID0ge1xuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbiAgaG91ckN5Y2xlOiBcImgyM1wiLFxufTtcblxuZXhwb3J0IGNvbnN0IFRJTUVfMjRfV0lUSF9TSE9SVF9PRkZTRVQgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxuICBob3VyQ3ljbGU6IFwiaDIzXCIsXG4gIHRpbWVab25lTmFtZTogcyxcbn07XG5cbmV4cG9ydCBjb25zdCBUSU1FXzI0X1dJVEhfTE9OR19PRkZTRVQgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxuICBob3VyQ3ljbGU6IFwiaDIzXCIsXG4gIHRpbWVab25lTmFtZTogbCxcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFVElNRV9TSE9SVCA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IG4sXG4gIGRheTogbixcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX1NIT1JUX1dJVEhfU0VDT05EUyA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IG4sXG4gIGRheTogbixcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfTUVEID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogcyxcbiAgZGF5OiBuLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfTUVEX1dJVEhfU0VDT05EUyA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IHMsXG4gIGRheTogbixcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfTUVEX1dJVEhfV0VFS0RBWSA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IHMsXG4gIGRheTogbixcbiAgd2Vla2RheTogcyxcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX0ZVTEwgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBsLFxuICBkYXk6IG4sXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgdGltZVpvbmVOYW1lOiBzLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX0ZVTExfV0lUSF9TRUNPTkRTID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbCxcbiAgZGF5OiBuLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbiAgdGltZVpvbmVOYW1lOiBzLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX0hVR0UgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBsLFxuICBkYXk6IG4sXG4gIHdlZWtkYXk6IGwsXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgdGltZVpvbmVOYW1lOiBsLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX0hVR0VfV0lUSF9TRUNPTkRTID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbCxcbiAgZGF5OiBuLFxuICB3ZWVrZGF5OiBsLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbiAgdGltZVpvbmVOYW1lOiBsLFxufTtcbiIsICJpbXBvcnQgeyBab25lSXNBYnN0cmFjdEVycm9yIH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5cbi8qKlxuICogQGludGVyZmFjZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBab25lIHtcbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHpvbmVcbiAgICogQGFic3RyYWN0XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgdHlwZSgpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoaXMgem9uZS5cbiAgICogQGFic3RyYWN0XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgbmFtZSgpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG5cbiAgZ2V0IGlhbmFOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBvZmZzZXQgaXMga25vd24gdG8gYmUgZml4ZWQgZm9yIHRoZSB3aG9sZSB5ZWFyLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNVbml2ZXJzYWwoKSB7XG4gICAgdGhyb3cgbmV3IFpvbmVJc0Fic3RyYWN0RXJyb3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvZmZzZXQncyBjb21tb24gbmFtZSAoc3VjaCBhcyBFU1QpIGF0IHRoZSBzcGVjaWZpZWQgdGltZXN0YW1wXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge251bWJlcn0gdHMgLSBFcG9jaCBtaWxsaXNlY29uZHMgZm9yIHdoaWNoIHRvIGdldCB0aGUgbmFtZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIE9wdGlvbnMgdG8gYWZmZWN0IHRoZSBmb3JtYXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMuZm9ybWF0IC0gV2hhdCBzdHlsZSBvZiBvZmZzZXQgdG8gcmV0dXJuLiBBY2NlcHRzICdsb25nJyBvciAnc2hvcnQnLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5sb2NhbGUgLSBXaGF0IGxvY2FsZSB0byByZXR1cm4gdGhlIG9mZnNldCBuYW1lIGluLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBvZmZzZXROYW1lKHRzLCBvcHRzKSB7XG4gICAgdGhyb3cgbmV3IFpvbmVJc0Fic3RyYWN0RXJyb3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvZmZzZXQncyB2YWx1ZSBhcyBhIHN0cmluZ1xuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRzIC0gRXBvY2ggbWlsbGlzZWNvbmRzIGZvciB3aGljaCB0byBnZXQgdGhlIG9mZnNldFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0IC0gV2hhdCBzdHlsZSBvZiBvZmZzZXQgdG8gcmV0dXJuLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgQWNjZXB0cyAnbmFycm93JywgJ3Nob3J0Jywgb3IgJ3RlY2hpZScuIFJldHVybmluZyAnKzYnLCAnKzA2OjAwJywgb3IgJyswNjAwJyByZXNwZWN0aXZlbHlcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZm9ybWF0T2Zmc2V0KHRzLCBmb3JtYXQpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgb2Zmc2V0IGluIG1pbnV0ZXMgZm9yIHRoaXMgem9uZSBhdCB0aGUgc3BlY2lmaWVkIHRpbWVzdGFtcC5cbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0cyAtIEVwb2NoIG1pbGxpc2Vjb25kcyBmb3Igd2hpY2ggdG8gY29tcHV0ZSB0aGUgb2Zmc2V0XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIG9mZnNldCh0cykge1xuICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBab25lIGlzIGVxdWFsIHRvIGFub3RoZXIgem9uZVxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtab25lfSBvdGhlclpvbmUgLSB0aGUgem9uZSB0byBjb21wYXJlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBlcXVhbHMob3RoZXJab25lKSB7XG4gICAgdGhyb3cgbmV3IFpvbmVJc0Fic3RyYWN0RXJyb3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIFpvbmUgaXMgdmFsaWQuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBmb3JtYXRPZmZzZXQsIHBhcnNlWm9uZUluZm8gfSBmcm9tIFwiLi4vaW1wbC91dGlsLmpzXCI7XG5pbXBvcnQgWm9uZSBmcm9tIFwiLi4vem9uZS5qc1wiO1xuXG5sZXQgc2luZ2xldG9uID0gbnVsbDtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBsb2NhbCB6b25lIGZvciB0aGlzIEphdmFTY3JpcHQgZW52aXJvbm1lbnQuXG4gKiBAaW1wbGVtZW50cyB7Wm9uZX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3lzdGVtWm9uZSBleHRlbmRzIFpvbmUge1xuICAvKipcbiAgICogR2V0IGEgc2luZ2xldG9uIGluc3RhbmNlIG9mIHRoZSBsb2NhbCB6b25lXG4gICAqIEByZXR1cm4ge1N5c3RlbVpvbmV9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGluc3RhbmNlKCkge1xuICAgIGlmIChzaW5nbGV0b24gPT09IG51bGwpIHtcbiAgICAgIHNpbmdsZXRvbiA9IG5ldyBTeXN0ZW1ab25lKCk7XG4gICAgfVxuICAgIHJldHVybiBzaW5nbGV0b247XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gXCJzeXN0ZW1cIjtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCgpLnJlc29sdmVkT3B0aW9ucygpLnRpbWVab25lO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IGlzVW5pdmVyc2FsKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIG9mZnNldE5hbWUodHMsIHsgZm9ybWF0LCBsb2NhbGUgfSkge1xuICAgIHJldHVybiBwYXJzZVpvbmVJbmZvKHRzLCBmb3JtYXQsIGxvY2FsZSk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBmb3JtYXRPZmZzZXQodHMsIGZvcm1hdCkge1xuICAgIHJldHVybiBmb3JtYXRPZmZzZXQodGhpcy5vZmZzZXQodHMpLCBmb3JtYXQpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgb2Zmc2V0KHRzKSB7XG4gICAgcmV0dXJuIC1uZXcgRGF0ZSh0cykuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGVxdWFscyhvdGhlclpvbmUpIHtcbiAgICByZXR1cm4gb3RoZXJab25lLnR5cGUgPT09IFwic3lzdGVtXCI7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuIiwgImltcG9ydCB7IGZvcm1hdE9mZnNldCwgcGFyc2Vab25lSW5mbywgaXNVbmRlZmluZWQsIG9ialRvTG9jYWxUUyB9IGZyb20gXCIuLi9pbXBsL3V0aWwuanNcIjtcbmltcG9ydCBab25lIGZyb20gXCIuLi96b25lLmpzXCI7XG5cbmxldCBkdGZDYWNoZSA9IHt9O1xuZnVuY3Rpb24gbWFrZURURih6b25lKSB7XG4gIGlmICghZHRmQ2FjaGVbem9uZV0pIHtcbiAgICBkdGZDYWNoZVt6b25lXSA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KFwiZW4tVVNcIiwge1xuICAgICAgaG91cjEyOiBmYWxzZSxcbiAgICAgIHRpbWVab25lOiB6b25lLFxuICAgICAgeWVhcjogXCJudW1lcmljXCIsXG4gICAgICBtb250aDogXCIyLWRpZ2l0XCIsXG4gICAgICBkYXk6IFwiMi1kaWdpdFwiLFxuICAgICAgaG91cjogXCIyLWRpZ2l0XCIsXG4gICAgICBtaW51dGU6IFwiMi1kaWdpdFwiLFxuICAgICAgc2Vjb25kOiBcIjItZGlnaXRcIixcbiAgICAgIGVyYTogXCJzaG9ydFwiLFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBkdGZDYWNoZVt6b25lXTtcbn1cblxuY29uc3QgdHlwZVRvUG9zID0ge1xuICB5ZWFyOiAwLFxuICBtb250aDogMSxcbiAgZGF5OiAyLFxuICBlcmE6IDMsXG4gIGhvdXI6IDQsXG4gIG1pbnV0ZTogNSxcbiAgc2Vjb25kOiA2LFxufTtcblxuZnVuY3Rpb24gaGFja3lPZmZzZXQoZHRmLCBkYXRlKSB7XG4gIGNvbnN0IGZvcm1hdHRlZCA9IGR0Zi5mb3JtYXQoZGF0ZSkucmVwbGFjZSgvXFx1MjAwRS9nLCBcIlwiKSxcbiAgICBwYXJzZWQgPSAvKFxcZCspXFwvKFxcZCspXFwvKFxcZCspIChBRHxCQyksPyAoXFxkKyk6KFxcZCspOihcXGQrKS8uZXhlYyhmb3JtYXR0ZWQpLFxuICAgIFssIGZNb250aCwgZkRheSwgZlllYXIsIGZhZE9yQmMsIGZIb3VyLCBmTWludXRlLCBmU2Vjb25kXSA9IHBhcnNlZDtcbiAgcmV0dXJuIFtmWWVhciwgZk1vbnRoLCBmRGF5LCBmYWRPckJjLCBmSG91ciwgZk1pbnV0ZSwgZlNlY29uZF07XG59XG5cbmZ1bmN0aW9uIHBhcnRzT2Zmc2V0KGR0ZiwgZGF0ZSkge1xuICBjb25zdCBmb3JtYXR0ZWQgPSBkdGYuZm9ybWF0VG9QYXJ0cyhkYXRlKTtcbiAgY29uc3QgZmlsbGVkID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZm9ybWF0dGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgeyB0eXBlLCB2YWx1ZSB9ID0gZm9ybWF0dGVkW2ldO1xuICAgIGNvbnN0IHBvcyA9IHR5cGVUb1Bvc1t0eXBlXTtcblxuICAgIGlmICh0eXBlID09PSBcImVyYVwiKSB7XG4gICAgICBmaWxsZWRbcG9zXSA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAoIWlzVW5kZWZpbmVkKHBvcykpIHtcbiAgICAgIGZpbGxlZFtwb3NdID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZpbGxlZDtcbn1cblxubGV0IGlhbmFab25lQ2FjaGUgPSB7fTtcbi8qKlxuICogQSB6b25lIGlkZW50aWZpZWQgYnkgYW4gSUFOQSBpZGVudGlmaWVyLCBsaWtlIEFtZXJpY2EvTmV3X1lvcmtcbiAqIEBpbXBsZW1lbnRzIHtab25lfVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJQU5BWm9uZSBleHRlbmRzIFpvbmUge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBab25lIG5hbWVcbiAgICogQHJldHVybiB7SUFOQVpvbmV9XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlKG5hbWUpIHtcbiAgICBpZiAoIWlhbmFab25lQ2FjaGVbbmFtZV0pIHtcbiAgICAgIGlhbmFab25lQ2FjaGVbbmFtZV0gPSBuZXcgSUFOQVpvbmUobmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBpYW5hWm9uZUNhY2hlW25hbWVdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IGxvY2FsIGNhY2hlcy4gU2hvdWxkIG9ubHkgYmUgbmVjZXNzYXJ5IGluIHRlc3Rpbmcgc2NlbmFyaW9zLlxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgc3RhdGljIHJlc2V0Q2FjaGUoKSB7XG4gICAgaWFuYVpvbmVDYWNoZSA9IHt9O1xuICAgIGR0ZkNhY2hlID0ge307XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBwcm92aWRlZCBzdHJpbmcgaXMgYSB2YWxpZCBzcGVjaWZpZXIuIFRoaXMgb25seSBjaGVja3MgdGhlIHN0cmluZydzIGZvcm1hdCwgbm90IHRoYXQgdGhlIHNwZWNpZmllciBpZGVudGlmaWVzIGEga25vd24gem9uZTsgc2VlIGlzVmFsaWRab25lIGZvciB0aGF0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcyAtIFRoZSBzdHJpbmcgdG8gY2hlY2sgdmFsaWRpdHkgb25cbiAgICogQGV4YW1wbGUgSUFOQVpvbmUuaXNWYWxpZFNwZWNpZmllcihcIkFtZXJpY2EvTmV3X1lvcmtcIikgLy89PiB0cnVlXG4gICAqIEBleGFtcGxlIElBTkFab25lLmlzVmFsaWRTcGVjaWZpZXIoXCJTcG9ydH5+YmxvcnBcIikgLy89PiBmYWxzZVxuICAgKiBAZGVwcmVjYXRlZCBUaGlzIG1ldGhvZCByZXR1cm5zIGZhbHNlIGZvciBzb21lIHZhbGlkIElBTkEgbmFtZXMuIFVzZSBpc1ZhbGlkWm9uZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzVmFsaWRTcGVjaWZpZXIocykge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWRab25lKHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZWQgc3RyaW5nIGlkZW50aWZpZXMgYSByZWFsIHpvbmVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHpvbmUgLSBUaGUgc3RyaW5nIHRvIGNoZWNrXG4gICAqIEBleGFtcGxlIElBTkFab25lLmlzVmFsaWRab25lKFwiQW1lcmljYS9OZXdfWW9ya1wiKSAvLz0+IHRydWVcbiAgICogQGV4YW1wbGUgSUFOQVpvbmUuaXNWYWxpZFpvbmUoXCJGYW50YXNpYS9DYXN0bGVcIikgLy89PiBmYWxzZVxuICAgKiBAZXhhbXBsZSBJQU5BWm9uZS5pc1ZhbGlkWm9uZShcIlNwb3J0fn5ibG9ycFwiKSAvLz0+IGZhbHNlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNWYWxpZFpvbmUoem9uZSkge1xuICAgIGlmICghem9uZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoXCJlbi1VU1wiLCB7IHRpbWVab25lOiB6b25lIH0pLmZvcm1hdCgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKiBAcHJpdmF0ZSAqKi9cbiAgICB0aGlzLnpvbmVOYW1lID0gbmFtZTtcbiAgICAvKiogQHByaXZhdGUgKiovXG4gICAgdGhpcy52YWxpZCA9IElBTkFab25lLmlzVmFsaWRab25lKG5hbWUpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIFwiaWFuYVwiO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuem9uZU5hbWU7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgaXNVbml2ZXJzYWwoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgb2Zmc2V0TmFtZSh0cywgeyBmb3JtYXQsIGxvY2FsZSB9KSB7XG4gICAgcmV0dXJuIHBhcnNlWm9uZUluZm8odHMsIGZvcm1hdCwgbG9jYWxlLCB0aGlzLm5hbWUpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZm9ybWF0T2Zmc2V0KHRzLCBmb3JtYXQpIHtcbiAgICByZXR1cm4gZm9ybWF0T2Zmc2V0KHRoaXMub2Zmc2V0KHRzKSwgZm9ybWF0KTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIG9mZnNldCh0cykge1xuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh0cyk7XG5cbiAgICBpZiAoaXNOYU4oZGF0ZSkpIHJldHVybiBOYU47XG5cbiAgICBjb25zdCBkdGYgPSBtYWtlRFRGKHRoaXMubmFtZSk7XG4gICAgbGV0IFt5ZWFyLCBtb250aCwgZGF5LCBhZE9yQmMsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kXSA9IGR0Zi5mb3JtYXRUb1BhcnRzXG4gICAgICA/IHBhcnRzT2Zmc2V0KGR0ZiwgZGF0ZSlcbiAgICAgIDogaGFja3lPZmZzZXQoZHRmLCBkYXRlKTtcblxuICAgIGlmIChhZE9yQmMgPT09IFwiQkNcIikge1xuICAgICAgeWVhciA9IC1NYXRoLmFicyh5ZWFyKSArIDE7XG4gICAgfVxuXG4gICAgLy8gYmVjYXVzZSB3ZSdyZSB1c2luZyBob3VyMTIgYW5kIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTEwMjU1NjQmY2FuPTImcT0lMjIyNCUzQTAwJTIyJTIwZGF0ZXRpbWVmb3JtYXRcbiAgICBjb25zdCBhZGp1c3RlZEhvdXIgPSBob3VyID09PSAyNCA/IDAgOiBob3VyO1xuXG4gICAgY29uc3QgYXNVVEMgPSBvYmpUb0xvY2FsVFMoe1xuICAgICAgeWVhcixcbiAgICAgIG1vbnRoLFxuICAgICAgZGF5LFxuICAgICAgaG91cjogYWRqdXN0ZWRIb3VyLFxuICAgICAgbWludXRlLFxuICAgICAgc2Vjb25kLFxuICAgICAgbWlsbGlzZWNvbmQ6IDAsXG4gICAgfSk7XG5cbiAgICBsZXQgYXNUUyA9ICtkYXRlO1xuICAgIGNvbnN0IG92ZXIgPSBhc1RTICUgMTAwMDtcbiAgICBhc1RTIC09IG92ZXIgPj0gMCA/IG92ZXIgOiAxMDAwICsgb3ZlcjtcbiAgICByZXR1cm4gKGFzVVRDIC0gYXNUUykgLyAoNjAgKiAxMDAwKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGVxdWFscyhvdGhlclpvbmUpIHtcbiAgICByZXR1cm4gb3RoZXJab25lLnR5cGUgPT09IFwiaWFuYVwiICYmIG90aGVyWm9uZS5uYW1lID09PSB0aGlzLm5hbWU7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy52YWxpZDtcbiAgfVxufVxuIiwgImltcG9ydCB7IHBhZFN0YXJ0LCByb3VuZFRvLCBoYXNSZWxhdGl2ZSwgZm9ybWF0T2Zmc2V0IH0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuaW1wb3J0ICogYXMgRW5nbGlzaCBmcm9tIFwiLi9lbmdsaXNoLmpzXCI7XG5pbXBvcnQgU2V0dGluZ3MgZnJvbSBcIi4uL3NldHRpbmdzLmpzXCI7XG5pbXBvcnQgRGF0ZVRpbWUgZnJvbSBcIi4uL2RhdGV0aW1lLmpzXCI7XG5pbXBvcnQgSUFOQVpvbmUgZnJvbSBcIi4uL3pvbmVzL0lBTkFab25lLmpzXCI7XG5cbi8vIHRvZG8gLSByZW1hcCBjYWNoaW5nXG5cbmxldCBpbnRsTEZDYWNoZSA9IHt9O1xuZnVuY3Rpb24gZ2V0Q2FjaGVkTEYobG9jU3RyaW5nLCBvcHRzID0ge30pIHtcbiAgY29uc3Qga2V5ID0gSlNPTi5zdHJpbmdpZnkoW2xvY1N0cmluZywgb3B0c10pO1xuICBsZXQgZHRmID0gaW50bExGQ2FjaGVba2V5XTtcbiAgaWYgKCFkdGYpIHtcbiAgICBkdGYgPSBuZXcgSW50bC5MaXN0Rm9ybWF0KGxvY1N0cmluZywgb3B0cyk7XG4gICAgaW50bExGQ2FjaGVba2V5XSA9IGR0ZjtcbiAgfVxuICByZXR1cm4gZHRmO1xufVxuXG5sZXQgaW50bERUQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGdldENhY2hlZERURihsb2NTdHJpbmcsIG9wdHMgPSB7fSkge1xuICBjb25zdCBrZXkgPSBKU09OLnN0cmluZ2lmeShbbG9jU3RyaW5nLCBvcHRzXSk7XG4gIGxldCBkdGYgPSBpbnRsRFRDYWNoZVtrZXldO1xuICBpZiAoIWR0Zikge1xuICAgIGR0ZiA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY1N0cmluZywgb3B0cyk7XG4gICAgaW50bERUQ2FjaGVba2V5XSA9IGR0ZjtcbiAgfVxuICByZXR1cm4gZHRmO1xufVxuXG5sZXQgaW50bE51bUNhY2hlID0ge307XG5mdW5jdGlvbiBnZXRDYWNoZWRJTkYobG9jU3RyaW5nLCBvcHRzID0ge30pIHtcbiAgY29uc3Qga2V5ID0gSlNPTi5zdHJpbmdpZnkoW2xvY1N0cmluZywgb3B0c10pO1xuICBsZXQgaW5mID0gaW50bE51bUNhY2hlW2tleV07XG4gIGlmICghaW5mKSB7XG4gICAgaW5mID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KGxvY1N0cmluZywgb3B0cyk7XG4gICAgaW50bE51bUNhY2hlW2tleV0gPSBpbmY7XG4gIH1cbiAgcmV0dXJuIGluZjtcbn1cblxubGV0IGludGxSZWxDYWNoZSA9IHt9O1xuZnVuY3Rpb24gZ2V0Q2FjaGVkUlRGKGxvY1N0cmluZywgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHsgYmFzZSwgLi4uY2FjaGVLZXlPcHRzIH0gPSBvcHRzOyAvLyBleGNsdWRlIGBiYXNlYCBmcm9tIHRoZSBvcHRpb25zXG4gIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KFtsb2NTdHJpbmcsIGNhY2hlS2V5T3B0c10pO1xuICBsZXQgaW5mID0gaW50bFJlbENhY2hlW2tleV07XG4gIGlmICghaW5mKSB7XG4gICAgaW5mID0gbmV3IEludGwuUmVsYXRpdmVUaW1lRm9ybWF0KGxvY1N0cmluZywgb3B0cyk7XG4gICAgaW50bFJlbENhY2hlW2tleV0gPSBpbmY7XG4gIH1cbiAgcmV0dXJuIGluZjtcbn1cblxubGV0IHN5c0xvY2FsZUNhY2hlID0gbnVsbDtcbmZ1bmN0aW9uIHN5c3RlbUxvY2FsZSgpIHtcbiAgaWYgKHN5c0xvY2FsZUNhY2hlKSB7XG4gICAgcmV0dXJuIHN5c0xvY2FsZUNhY2hlO1xuICB9IGVsc2Uge1xuICAgIHN5c0xvY2FsZUNhY2hlID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoKS5yZXNvbHZlZE9wdGlvbnMoKS5sb2NhbGU7XG4gICAgcmV0dXJuIHN5c0xvY2FsZUNhY2hlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlTG9jYWxlU3RyaW5nKGxvY2FsZVN0cikge1xuICAvLyBJIHJlYWxseSB3YW50IHRvIGF2b2lkIHdyaXRpbmcgYSBCQ1AgNDcgcGFyc2VyXG4gIC8vIHNlZSwgZS5nLiBodHRwczovL2dpdGh1Yi5jb20vd29vb3JtL2JjcC00N1xuICAvLyBJbnN0ZWFkLCB3ZSdsbCBkbyB0aGlzOlxuXG4gIC8vIGEpIGlmIHRoZSBzdHJpbmcgaGFzIG5vIC11IGV4dGVuc2lvbnMsIGp1c3QgbGVhdmUgaXQgYWxvbmVcbiAgLy8gYikgaWYgaXQgZG9lcywgdXNlIEludGwgdG8gcmVzb2x2ZSBldmVyeXRoaW5nXG4gIC8vIGMpIGlmIEludGwgZmFpbHMsIHRyeSBhZ2FpbiB3aXRob3V0IHRoZSAtdVxuXG4gIC8vIHByaXZhdGUgc3VidGFncyBhbmQgdW5pY29kZSBzdWJ0YWdzIGhhdmUgb3JkZXJpbmcgcmVxdWlyZW1lbnRzLFxuICAvLyBhbmQgd2UncmUgbm90IHByb3Blcmx5IHBhcnNpbmcgdGhpcywgc28ganVzdCBzdHJpcCBvdXQgdGhlXG4gIC8vIHByaXZhdGUgb25lcyBpZiB0aGV5IGV4aXN0LlxuICBjb25zdCB4SW5kZXggPSBsb2NhbGVTdHIuaW5kZXhPZihcIi14LVwiKTtcbiAgaWYgKHhJbmRleCAhPT0gLTEpIHtcbiAgICBsb2NhbGVTdHIgPSBsb2NhbGVTdHIuc3Vic3RyaW5nKDAsIHhJbmRleCk7XG4gIH1cblxuICBjb25zdCB1SW5kZXggPSBsb2NhbGVTdHIuaW5kZXhPZihcIi11LVwiKTtcbiAgaWYgKHVJbmRleCA9PT0gLTEpIHtcbiAgICByZXR1cm4gW2xvY2FsZVN0cl07XG4gIH0gZWxzZSB7XG4gICAgbGV0IG9wdGlvbnM7XG4gICAgbGV0IHNlbGVjdGVkU3RyO1xuICAgIHRyeSB7XG4gICAgICBvcHRpb25zID0gZ2V0Q2FjaGVkRFRGKGxvY2FsZVN0cikucmVzb2x2ZWRPcHRpb25zKCk7XG4gICAgICBzZWxlY3RlZFN0ciA9IGxvY2FsZVN0cjtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zdCBzbWFsbGVyID0gbG9jYWxlU3RyLnN1YnN0cmluZygwLCB1SW5kZXgpO1xuICAgICAgb3B0aW9ucyA9IGdldENhY2hlZERURihzbWFsbGVyKS5yZXNvbHZlZE9wdGlvbnMoKTtcbiAgICAgIHNlbGVjdGVkU3RyID0gc21hbGxlcjtcbiAgICB9XG5cbiAgICBjb25zdCB7IG51bWJlcmluZ1N5c3RlbSwgY2FsZW5kYXIgfSA9IG9wdGlvbnM7XG4gICAgcmV0dXJuIFtzZWxlY3RlZFN0ciwgbnVtYmVyaW5nU3lzdGVtLCBjYWxlbmRhcl07XG4gIH1cbn1cblxuZnVuY3Rpb24gaW50bENvbmZpZ1N0cmluZyhsb2NhbGVTdHIsIG51bWJlcmluZ1N5c3RlbSwgb3V0cHV0Q2FsZW5kYXIpIHtcbiAgaWYgKG91dHB1dENhbGVuZGFyIHx8IG51bWJlcmluZ1N5c3RlbSkge1xuICAgIGlmICghbG9jYWxlU3RyLmluY2x1ZGVzKFwiLXUtXCIpKSB7XG4gICAgICBsb2NhbGVTdHIgKz0gXCItdVwiO1xuICAgIH1cblxuICAgIGlmIChvdXRwdXRDYWxlbmRhcikge1xuICAgICAgbG9jYWxlU3RyICs9IGAtY2EtJHtvdXRwdXRDYWxlbmRhcn1gO1xuICAgIH1cblxuICAgIGlmIChudW1iZXJpbmdTeXN0ZW0pIHtcbiAgICAgIGxvY2FsZVN0ciArPSBgLW51LSR7bnVtYmVyaW5nU3lzdGVtfWA7XG4gICAgfVxuICAgIHJldHVybiBsb2NhbGVTdHI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxvY2FsZVN0cjtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXBNb250aHMoZikge1xuICBjb25zdCBtcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMTsgaSA8PSAxMjsgaSsrKSB7XG4gICAgY29uc3QgZHQgPSBEYXRlVGltZS51dGMoMjAwOSwgaSwgMSk7XG4gICAgbXMucHVzaChmKGR0KSk7XG4gIH1cbiAgcmV0dXJuIG1zO1xufVxuXG5mdW5jdGlvbiBtYXBXZWVrZGF5cyhmKSB7XG4gIGNvbnN0IG1zID0gW107XG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IDc7IGkrKykge1xuICAgIGNvbnN0IGR0ID0gRGF0ZVRpbWUudXRjKDIwMTYsIDExLCAxMyArIGkpO1xuICAgIG1zLnB1c2goZihkdCkpO1xuICB9XG4gIHJldHVybiBtcztcbn1cblxuZnVuY3Rpb24gbGlzdFN0dWZmKGxvYywgbGVuZ3RoLCBlbmdsaXNoRm4sIGludGxGbikge1xuICBjb25zdCBtb2RlID0gbG9jLmxpc3RpbmdNb2RlKCk7XG5cbiAgaWYgKG1vZGUgPT09IFwiZXJyb3JcIikge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2UgaWYgKG1vZGUgPT09IFwiZW5cIikge1xuICAgIHJldHVybiBlbmdsaXNoRm4obGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaW50bEZuKGxlbmd0aCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3VwcG9ydHNGYXN0TnVtYmVycyhsb2MpIHtcbiAgaWYgKGxvYy5udW1iZXJpbmdTeXN0ZW0gJiYgbG9jLm51bWJlcmluZ1N5c3RlbSAhPT0gXCJsYXRuXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGxvYy5udW1iZXJpbmdTeXN0ZW0gPT09IFwibGF0blwiIHx8XG4gICAgICAhbG9jLmxvY2FsZSB8fFxuICAgICAgbG9jLmxvY2FsZS5zdGFydHNXaXRoKFwiZW5cIikgfHxcbiAgICAgIG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvYy5pbnRsKS5yZXNvbHZlZE9wdGlvbnMoKS5udW1iZXJpbmdTeXN0ZW0gPT09IFwibGF0blwiXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuY2xhc3MgUG9seU51bWJlckZvcm1hdHRlciB7XG4gIGNvbnN0cnVjdG9yKGludGwsIGZvcmNlU2ltcGxlLCBvcHRzKSB7XG4gICAgdGhpcy5wYWRUbyA9IG9wdHMucGFkVG8gfHwgMDtcbiAgICB0aGlzLmZsb29yID0gb3B0cy5mbG9vciB8fCBmYWxzZTtcblxuICAgIGNvbnN0IHsgcGFkVG8sIGZsb29yLCAuLi5vdGhlck9wdHMgfSA9IG9wdHM7XG5cbiAgICBpZiAoIWZvcmNlU2ltcGxlIHx8IE9iamVjdC5rZXlzKG90aGVyT3B0cykubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgaW50bE9wdHMgPSB7IHVzZUdyb3VwaW5nOiBmYWxzZSwgLi4ub3B0cyB9O1xuICAgICAgaWYgKG9wdHMucGFkVG8gPiAwKSBpbnRsT3B0cy5taW5pbXVtSW50ZWdlckRpZ2l0cyA9IG9wdHMucGFkVG87XG4gICAgICB0aGlzLmluZiA9IGdldENhY2hlZElORihpbnRsLCBpbnRsT3B0cyk7XG4gICAgfVxuICB9XG5cbiAgZm9ybWF0KGkpIHtcbiAgICBpZiAodGhpcy5pbmYpIHtcbiAgICAgIGNvbnN0IGZpeGVkID0gdGhpcy5mbG9vciA/IE1hdGguZmxvb3IoaSkgOiBpO1xuICAgICAgcmV0dXJuIHRoaXMuaW5mLmZvcm1hdChmaXhlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRvIG1hdGNoIHRoZSBicm93c2VyJ3MgbnVtYmVyZm9ybWF0dGVyIGRlZmF1bHRzXG4gICAgICBjb25zdCBmaXhlZCA9IHRoaXMuZmxvb3IgPyBNYXRoLmZsb29yKGkpIDogcm91bmRUbyhpLCAzKTtcbiAgICAgIHJldHVybiBwYWRTdGFydChmaXhlZCwgdGhpcy5wYWRUbyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5jbGFzcyBQb2x5RGF0ZUZvcm1hdHRlciB7XG4gIGNvbnN0cnVjdG9yKGR0LCBpbnRsLCBvcHRzKSB7XG4gICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICB0aGlzLm9yaWdpbmFsWm9uZSA9IHVuZGVmaW5lZDtcblxuICAgIGxldCB6ID0gdW5kZWZpbmVkO1xuICAgIGlmICh0aGlzLm9wdHMudGltZVpvbmUpIHtcbiAgICAgIC8vIERvbid0IGFwcGx5IGFueSB3b3JrYXJvdW5kcyBpZiBhIHRpbWVab25lIGlzIGV4cGxpY2l0bHkgcHJvdmlkZWQgaW4gb3B0c1xuICAgICAgdGhpcy5kdCA9IGR0O1xuICAgIH0gZWxzZSBpZiAoZHQuem9uZS50eXBlID09PSBcImZpeGVkXCIpIHtcbiAgICAgIC8vIFVUQy04IG9yIEV0Yy9VVEMtOCBhcmUgbm90IHBhcnQgb2YgdHpkYXRhLCBvbmx5IEV0Yy9HTVQrOCBhbmQgdGhlIGxpa2UuXG4gICAgICAvLyBUaGF0IGlzIHdoeSBmaXhlZC1vZmZzZXQgVFogaXMgc2V0IHRvIHRoYXQgdW5sZXNzIGl0IGlzOlxuICAgICAgLy8gMS4gUmVwcmVzZW50aW5nIG9mZnNldCAwIHdoZW4gVVRDIGlzIHVzZWQgdG8gbWFpbnRhaW4gcHJldmlvdXMgYmVoYXZpb3IgYW5kIGRvZXMgbm90IGJlY29tZSBHTVQuXG4gICAgICAvLyAyLiBVbnN1cHBvcnRlZCBieSB0aGUgYnJvd3NlcjpcbiAgICAgIC8vICAgIC0gc29tZSBkbyBub3Qgc3VwcG9ydCBFdGMvXG4gICAgICAvLyAgICAtIDwgRXRjL0dNVC0xNCwgPiBFdGMvR01UKzEyLCBhbmQgMzAtbWludXRlIG9yIDQ1LW1pbnV0ZSBvZmZzZXRzIGFyZSBub3QgcGFydCBvZiB0emRhdGFcbiAgICAgIGNvbnN0IGdtdE9mZnNldCA9IC0xICogKGR0Lm9mZnNldCAvIDYwKTtcbiAgICAgIGNvbnN0IG9mZnNldFogPSBnbXRPZmZzZXQgPj0gMCA/IGBFdGMvR01UKyR7Z210T2Zmc2V0fWAgOiBgRXRjL0dNVCR7Z210T2Zmc2V0fWA7XG4gICAgICBpZiAoZHQub2Zmc2V0ICE9PSAwICYmIElBTkFab25lLmNyZWF0ZShvZmZzZXRaKS52YWxpZCkge1xuICAgICAgICB6ID0gb2Zmc2V0WjtcbiAgICAgICAgdGhpcy5kdCA9IGR0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm90IGFsbCBmaXhlZC1vZmZzZXQgem9uZXMgbGlrZSBFdGMvKzQ6MzAgYXJlIHByZXNlbnQgaW4gdHpkYXRhIHNvXG4gICAgICAgIC8vIHdlIG1hbnVhbGx5IGFwcGx5IHRoZSBvZmZzZXQgYW5kIHN1YnN0aXR1dGUgdGhlIHpvbmUgYXMgbmVlZGVkLlxuICAgICAgICB6ID0gXCJVVENcIjtcbiAgICAgICAgdGhpcy5kdCA9IGR0Lm9mZnNldCA9PT0gMCA/IGR0IDogZHQuc2V0Wm9uZShcIlVUQ1wiKS5wbHVzKHsgbWludXRlczogZHQub2Zmc2V0IH0pO1xuICAgICAgICB0aGlzLm9yaWdpbmFsWm9uZSA9IGR0LnpvbmU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkdC56b25lLnR5cGUgPT09IFwic3lzdGVtXCIpIHtcbiAgICAgIHRoaXMuZHQgPSBkdDtcbiAgICB9IGVsc2UgaWYgKGR0LnpvbmUudHlwZSA9PT0gXCJpYW5hXCIpIHtcbiAgICAgIHRoaXMuZHQgPSBkdDtcbiAgICAgIHogPSBkdC56b25lLm5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEN1c3RvbSB6b25lcyBjYW4gaGF2ZSBhbnkgb2Zmc2V0IC8gb2Zmc2V0TmFtZSBzbyB3ZSBqdXN0IG1hbnVhbGx5XG4gICAgICAvLyBhcHBseSB0aGUgb2Zmc2V0IGFuZCBzdWJzdGl0dXRlIHRoZSB6b25lIGFzIG5lZWRlZC5cbiAgICAgIHogPSBcIlVUQ1wiO1xuICAgICAgdGhpcy5kdCA9IGR0LnNldFpvbmUoXCJVVENcIikucGx1cyh7IG1pbnV0ZXM6IGR0Lm9mZnNldCB9KTtcbiAgICAgIHRoaXMub3JpZ2luYWxab25lID0gZHQuem9uZTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnRsT3B0cyA9IHsgLi4udGhpcy5vcHRzIH07XG4gICAgaW50bE9wdHMudGltZVpvbmUgPSBpbnRsT3B0cy50aW1lWm9uZSB8fCB6O1xuICAgIHRoaXMuZHRmID0gZ2V0Q2FjaGVkRFRGKGludGwsIGludGxPcHRzKTtcbiAgfVxuXG4gIGZvcm1hdCgpIHtcbiAgICBpZiAodGhpcy5vcmlnaW5hbFpvbmUpIHtcbiAgICAgIC8vIElmIHdlIGhhdmUgdG8gc3Vic3RpdHV0ZSBpbiB0aGUgYWN0dWFsIHpvbmUgbmFtZSwgd2UgaGF2ZSB0byB1c2VcbiAgICAgIC8vIGZvcm1hdFRvUGFydHMgc28gdGhhdCB0aGUgdGltZXpvbmUgY2FuIGJlIHJlcGxhY2VkLlxuICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0VG9QYXJ0cygpXG4gICAgICAgIC5tYXAoKHsgdmFsdWUgfSkgPT4gdmFsdWUpXG4gICAgICAgIC5qb2luKFwiXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kdGYuZm9ybWF0KHRoaXMuZHQudG9KU0RhdGUoKSk7XG4gIH1cblxuICBmb3JtYXRUb1BhcnRzKCkge1xuICAgIGNvbnN0IHBhcnRzID0gdGhpcy5kdGYuZm9ybWF0VG9QYXJ0cyh0aGlzLmR0LnRvSlNEYXRlKCkpO1xuICAgIGlmICh0aGlzLm9yaWdpbmFsWm9uZSkge1xuICAgICAgcmV0dXJuIHBhcnRzLm1hcCgocGFydCkgPT4ge1xuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInRpbWVab25lTmFtZVwiKSB7XG4gICAgICAgICAgY29uc3Qgb2Zmc2V0TmFtZSA9IHRoaXMub3JpZ2luYWxab25lLm9mZnNldE5hbWUodGhpcy5kdC50cywge1xuICAgICAgICAgICAgbG9jYWxlOiB0aGlzLmR0LmxvY2FsZSxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5vcHRzLnRpbWVab25lTmFtZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ucGFydCxcbiAgICAgICAgICAgIHZhbHVlOiBvZmZzZXROYW1lLFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcGFydHM7XG4gIH1cblxuICByZXNvbHZlZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZHRmLnJlc29sdmVkT3B0aW9ucygpO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgUG9seVJlbEZvcm1hdHRlciB7XG4gIGNvbnN0cnVjdG9yKGludGwsIGlzRW5nbGlzaCwgb3B0cykge1xuICAgIHRoaXMub3B0cyA9IHsgc3R5bGU6IFwibG9uZ1wiLCAuLi5vcHRzIH07XG4gICAgaWYgKCFpc0VuZ2xpc2ggJiYgaGFzUmVsYXRpdmUoKSkge1xuICAgICAgdGhpcy5ydGYgPSBnZXRDYWNoZWRSVEYoaW50bCwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgZm9ybWF0KGNvdW50LCB1bml0KSB7XG4gICAgaWYgKHRoaXMucnRmKSB7XG4gICAgICByZXR1cm4gdGhpcy5ydGYuZm9ybWF0KGNvdW50LCB1bml0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIEVuZ2xpc2guZm9ybWF0UmVsYXRpdmVUaW1lKHVuaXQsIGNvdW50LCB0aGlzLm9wdHMubnVtZXJpYywgdGhpcy5vcHRzLnN0eWxlICE9PSBcImxvbmdcIik7XG4gICAgfVxuICB9XG5cbiAgZm9ybWF0VG9QYXJ0cyhjb3VudCwgdW5pdCkge1xuICAgIGlmICh0aGlzLnJ0Zikge1xuICAgICAgcmV0dXJuIHRoaXMucnRmLmZvcm1hdFRvUGFydHMoY291bnQsIHVuaXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMb2NhbGUge1xuICBzdGF0aWMgZnJvbU9wdHMob3B0cykge1xuICAgIHJldHVybiBMb2NhbGUuY3JlYXRlKG9wdHMubG9jYWxlLCBvcHRzLm51bWJlcmluZ1N5c3RlbSwgb3B0cy5vdXRwdXRDYWxlbmRhciwgb3B0cy5kZWZhdWx0VG9FTik7XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhciwgZGVmYXVsdFRvRU4gPSBmYWxzZSkge1xuICAgIGNvbnN0IHNwZWNpZmllZExvY2FsZSA9IGxvY2FsZSB8fCBTZXR0aW5ncy5kZWZhdWx0TG9jYWxlO1xuICAgIC8vIHRoZSBzeXN0ZW0gbG9jYWxlIGlzIHVzZWZ1bCBmb3IgaHVtYW4gcmVhZGFibGUgc3RyaW5ncyBidXQgYW5ub3lpbmcgZm9yIHBhcnNpbmcvZm9ybWF0dGluZyBrbm93biBmb3JtYXRzXG4gICAgY29uc3QgbG9jYWxlUiA9IHNwZWNpZmllZExvY2FsZSB8fCAoZGVmYXVsdFRvRU4gPyBcImVuLVVTXCIgOiBzeXN0ZW1Mb2NhbGUoKSk7XG4gICAgY29uc3QgbnVtYmVyaW5nU3lzdGVtUiA9IG51bWJlcmluZ1N5c3RlbSB8fCBTZXR0aW5ncy5kZWZhdWx0TnVtYmVyaW5nU3lzdGVtO1xuICAgIGNvbnN0IG91dHB1dENhbGVuZGFyUiA9IG91dHB1dENhbGVuZGFyIHx8IFNldHRpbmdzLmRlZmF1bHRPdXRwdXRDYWxlbmRhcjtcbiAgICByZXR1cm4gbmV3IExvY2FsZShsb2NhbGVSLCBudW1iZXJpbmdTeXN0ZW1SLCBvdXRwdXRDYWxlbmRhclIsIHNwZWNpZmllZExvY2FsZSk7XG4gIH1cblxuICBzdGF0aWMgcmVzZXRDYWNoZSgpIHtcbiAgICBzeXNMb2NhbGVDYWNoZSA9IG51bGw7XG4gICAgaW50bERUQ2FjaGUgPSB7fTtcbiAgICBpbnRsTnVtQ2FjaGUgPSB7fTtcbiAgICBpbnRsUmVsQ2FjaGUgPSB7fTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tT2JqZWN0KHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyIH0gPSB7fSkge1xuICAgIHJldHVybiBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhcik7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihsb2NhbGUsIG51bWJlcmluZywgb3V0cHV0Q2FsZW5kYXIsIHNwZWNpZmllZExvY2FsZSkge1xuICAgIGNvbnN0IFtwYXJzZWRMb2NhbGUsIHBhcnNlZE51bWJlcmluZ1N5c3RlbSwgcGFyc2VkT3V0cHV0Q2FsZW5kYXJdID0gcGFyc2VMb2NhbGVTdHJpbmcobG9jYWxlKTtcblxuICAgIHRoaXMubG9jYWxlID0gcGFyc2VkTG9jYWxlO1xuICAgIHRoaXMubnVtYmVyaW5nU3lzdGVtID0gbnVtYmVyaW5nIHx8IHBhcnNlZE51bWJlcmluZ1N5c3RlbSB8fCBudWxsO1xuICAgIHRoaXMub3V0cHV0Q2FsZW5kYXIgPSBvdXRwdXRDYWxlbmRhciB8fCBwYXJzZWRPdXRwdXRDYWxlbmRhciB8fCBudWxsO1xuICAgIHRoaXMuaW50bCA9IGludGxDb25maWdTdHJpbmcodGhpcy5sb2NhbGUsIHRoaXMubnVtYmVyaW5nU3lzdGVtLCB0aGlzLm91dHB1dENhbGVuZGFyKTtcblxuICAgIHRoaXMud2Vla2RheXNDYWNoZSA9IHsgZm9ybWF0OiB7fSwgc3RhbmRhbG9uZToge30gfTtcbiAgICB0aGlzLm1vbnRoc0NhY2hlID0geyBmb3JtYXQ6IHt9LCBzdGFuZGFsb25lOiB7fSB9O1xuICAgIHRoaXMubWVyaWRpZW1DYWNoZSA9IG51bGw7XG4gICAgdGhpcy5lcmFDYWNoZSA9IHt9O1xuXG4gICAgdGhpcy5zcGVjaWZpZWRMb2NhbGUgPSBzcGVjaWZpZWRMb2NhbGU7XG4gICAgdGhpcy5mYXN0TnVtYmVyc0NhY2hlZCA9IG51bGw7XG4gIH1cblxuICBnZXQgZmFzdE51bWJlcnMoKSB7XG4gICAgaWYgKHRoaXMuZmFzdE51bWJlcnNDYWNoZWQgPT0gbnVsbCkge1xuICAgICAgdGhpcy5mYXN0TnVtYmVyc0NhY2hlZCA9IHN1cHBvcnRzRmFzdE51bWJlcnModGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZmFzdE51bWJlcnNDYWNoZWQ7XG4gIH1cblxuICBsaXN0aW5nTW9kZSgpIHtcbiAgICBjb25zdCBpc0FjdHVhbGx5RW4gPSB0aGlzLmlzRW5nbGlzaCgpO1xuICAgIGNvbnN0IGhhc05vV2VpcmRuZXNzID1cbiAgICAgICh0aGlzLm51bWJlcmluZ1N5c3RlbSA9PT0gbnVsbCB8fCB0aGlzLm51bWJlcmluZ1N5c3RlbSA9PT0gXCJsYXRuXCIpICYmXG4gICAgICAodGhpcy5vdXRwdXRDYWxlbmRhciA9PT0gbnVsbCB8fCB0aGlzLm91dHB1dENhbGVuZGFyID09PSBcImdyZWdvcnlcIik7XG4gICAgcmV0dXJuIGlzQWN0dWFsbHlFbiAmJiBoYXNOb1dlaXJkbmVzcyA/IFwiZW5cIiA6IFwiaW50bFwiO1xuICB9XG5cbiAgY2xvbmUoYWx0cykge1xuICAgIGlmICghYWx0cyB8fCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhbHRzKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTG9jYWxlLmNyZWF0ZShcbiAgICAgICAgYWx0cy5sb2NhbGUgfHwgdGhpcy5zcGVjaWZpZWRMb2NhbGUsXG4gICAgICAgIGFsdHMubnVtYmVyaW5nU3lzdGVtIHx8IHRoaXMubnVtYmVyaW5nU3lzdGVtLFxuICAgICAgICBhbHRzLm91dHB1dENhbGVuZGFyIHx8IHRoaXMub3V0cHV0Q2FsZW5kYXIsXG4gICAgICAgIGFsdHMuZGVmYXVsdFRvRU4gfHwgZmFsc2VcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcmVkZWZhdWx0VG9FTihhbHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSh7IC4uLmFsdHMsIGRlZmF1bHRUb0VOOiB0cnVlIH0pO1xuICB9XG5cbiAgcmVkZWZhdWx0VG9TeXN0ZW0oYWx0cyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoeyAuLi5hbHRzLCBkZWZhdWx0VG9FTjogZmFsc2UgfSk7XG4gIH1cblxuICBtb250aHMobGVuZ3RoLCBmb3JtYXQgPSBmYWxzZSkge1xuICAgIHJldHVybiBsaXN0U3R1ZmYodGhpcywgbGVuZ3RoLCBFbmdsaXNoLm1vbnRocywgKCkgPT4ge1xuICAgICAgY29uc3QgaW50bCA9IGZvcm1hdCA/IHsgbW9udGg6IGxlbmd0aCwgZGF5OiBcIm51bWVyaWNcIiB9IDogeyBtb250aDogbGVuZ3RoIH0sXG4gICAgICAgIGZvcm1hdFN0ciA9IGZvcm1hdCA/IFwiZm9ybWF0XCIgOiBcInN0YW5kYWxvbmVcIjtcbiAgICAgIGlmICghdGhpcy5tb250aHNDYWNoZVtmb3JtYXRTdHJdW2xlbmd0aF0pIHtcbiAgICAgICAgdGhpcy5tb250aHNDYWNoZVtmb3JtYXRTdHJdW2xlbmd0aF0gPSBtYXBNb250aHMoKGR0KSA9PiB0aGlzLmV4dHJhY3QoZHQsIGludGwsIFwibW9udGhcIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMubW9udGhzQ2FjaGVbZm9ybWF0U3RyXVtsZW5ndGhdO1xuICAgIH0pO1xuICB9XG5cbiAgd2Vla2RheXMobGVuZ3RoLCBmb3JtYXQgPSBmYWxzZSkge1xuICAgIHJldHVybiBsaXN0U3R1ZmYodGhpcywgbGVuZ3RoLCBFbmdsaXNoLndlZWtkYXlzLCAoKSA9PiB7XG4gICAgICBjb25zdCBpbnRsID0gZm9ybWF0XG4gICAgICAgICAgPyB7IHdlZWtkYXk6IGxlbmd0aCwgeWVhcjogXCJudW1lcmljXCIsIG1vbnRoOiBcImxvbmdcIiwgZGF5OiBcIm51bWVyaWNcIiB9XG4gICAgICAgICAgOiB7IHdlZWtkYXk6IGxlbmd0aCB9LFxuICAgICAgICBmb3JtYXRTdHIgPSBmb3JtYXQgPyBcImZvcm1hdFwiIDogXCJzdGFuZGFsb25lXCI7XG4gICAgICBpZiAoIXRoaXMud2Vla2RheXNDYWNoZVtmb3JtYXRTdHJdW2xlbmd0aF0pIHtcbiAgICAgICAgdGhpcy53ZWVrZGF5c0NhY2hlW2Zvcm1hdFN0cl1bbGVuZ3RoXSA9IG1hcFdlZWtkYXlzKChkdCkgPT5cbiAgICAgICAgICB0aGlzLmV4dHJhY3QoZHQsIGludGwsIFwid2Vla2RheVwiKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud2Vla2RheXNDYWNoZVtmb3JtYXRTdHJdW2xlbmd0aF07XG4gICAgfSk7XG4gIH1cblxuICBtZXJpZGllbXMoKSB7XG4gICAgcmV0dXJuIGxpc3RTdHVmZihcbiAgICAgIHRoaXMsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICAoKSA9PiBFbmdsaXNoLm1lcmlkaWVtcyxcbiAgICAgICgpID0+IHtcbiAgICAgICAgLy8gSW4gdGhlb3J5IHRoZXJlIGNvdWxkIGJlIGFyaWJpdHJhcnkgZGF5IHBlcmlvZHMuIFdlJ3JlIGdvbm5hIGFzc3VtZSB0aGVyZSBhcmUgZXhhY3RseSB0d29cbiAgICAgICAgLy8gZm9yIEFNIGFuZCBQTS4gVGhpcyBpcyBwcm9iYWJseSB3cm9uZywgYnV0IGl0J3MgbWFrZXMgcGFyc2luZyB3YXkgZWFzaWVyLlxuICAgICAgICBpZiAoIXRoaXMubWVyaWRpZW1DYWNoZSkge1xuICAgICAgICAgIGNvbnN0IGludGwgPSB7IGhvdXI6IFwibnVtZXJpY1wiLCBob3VyQ3ljbGU6IFwiaDEyXCIgfTtcbiAgICAgICAgICB0aGlzLm1lcmlkaWVtQ2FjaGUgPSBbRGF0ZVRpbWUudXRjKDIwMTYsIDExLCAxMywgOSksIERhdGVUaW1lLnV0YygyMDE2LCAxMSwgMTMsIDE5KV0ubWFwKFxuICAgICAgICAgICAgKGR0KSA9PiB0aGlzLmV4dHJhY3QoZHQsIGludGwsIFwiZGF5cGVyaW9kXCIpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLm1lcmlkaWVtQ2FjaGU7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIGVyYXMobGVuZ3RoKSB7XG4gICAgcmV0dXJuIGxpc3RTdHVmZih0aGlzLCBsZW5ndGgsIEVuZ2xpc2guZXJhcywgKCkgPT4ge1xuICAgICAgY29uc3QgaW50bCA9IHsgZXJhOiBsZW5ndGggfTtcblxuICAgICAgLy8gVGhpcyBpcyBwcm9ibGVtYXRpYy4gRGlmZmVyZW50IGNhbGVuZGFycyBhcmUgZ29pbmcgdG8gZGVmaW5lIGVyYXMgdG90YWxseSBkaWZmZXJlbnRseS4gV2hhdCBJIG5lZWQgaXMgdGhlIG1pbmltdW0gc2V0IG9mIGRhdGVzXG4gICAgICAvLyB0byBkZWZpbml0ZWx5IGVudW1lcmF0ZSB0aGVtLlxuICAgICAgaWYgKCF0aGlzLmVyYUNhY2hlW2xlbmd0aF0pIHtcbiAgICAgICAgdGhpcy5lcmFDYWNoZVtsZW5ndGhdID0gW0RhdGVUaW1lLnV0YygtNDAsIDEsIDEpLCBEYXRlVGltZS51dGMoMjAxNywgMSwgMSldLm1hcCgoZHQpID0+XG4gICAgICAgICAgdGhpcy5leHRyYWN0KGR0LCBpbnRsLCBcImVyYVwiKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5lcmFDYWNoZVtsZW5ndGhdO1xuICAgIH0pO1xuICB9XG5cbiAgZXh0cmFjdChkdCwgaW50bE9wdHMsIGZpZWxkKSB7XG4gICAgY29uc3QgZGYgPSB0aGlzLmR0Rm9ybWF0dGVyKGR0LCBpbnRsT3B0cyksXG4gICAgICByZXN1bHRzID0gZGYuZm9ybWF0VG9QYXJ0cygpLFxuICAgICAgbWF0Y2hpbmcgPSByZXN1bHRzLmZpbmQoKG0pID0+IG0udHlwZS50b0xvd2VyQ2FzZSgpID09PSBmaWVsZCk7XG4gICAgcmV0dXJuIG1hdGNoaW5nID8gbWF0Y2hpbmcudmFsdWUgOiBudWxsO1xuICB9XG5cbiAgbnVtYmVyRm9ybWF0dGVyKG9wdHMgPSB7fSkge1xuICAgIC8vIHRoaXMgZm9yY2VzaW1wbGUgb3B0aW9uIGlzIG5ldmVyIHVzZWQgKHRoZSBvbmx5IGNhbGxlciBzaG9ydC1jaXJjdWl0cyBvbiBpdCwgYnV0IGl0IHNlZW1zIHNhZmVyIHRvIGxlYXZlKVxuICAgIC8vIChpbiBjb250cmFzdCwgdGhlIHJlc3Qgb2YgdGhlIGNvbmRpdGlvbiBpcyB1c2VkIGhlYXZpbHkpXG4gICAgcmV0dXJuIG5ldyBQb2x5TnVtYmVyRm9ybWF0dGVyKHRoaXMuaW50bCwgb3B0cy5mb3JjZVNpbXBsZSB8fCB0aGlzLmZhc3ROdW1iZXJzLCBvcHRzKTtcbiAgfVxuXG4gIGR0Rm9ybWF0dGVyKGR0LCBpbnRsT3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBQb2x5RGF0ZUZvcm1hdHRlcihkdCwgdGhpcy5pbnRsLCBpbnRsT3B0cyk7XG4gIH1cblxuICByZWxGb3JtYXR0ZXIob3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBQb2x5UmVsRm9ybWF0dGVyKHRoaXMuaW50bCwgdGhpcy5pc0VuZ2xpc2goKSwgb3B0cyk7XG4gIH1cblxuICBsaXN0Rm9ybWF0dGVyKG9wdHMgPSB7fSkge1xuICAgIHJldHVybiBnZXRDYWNoZWRMRih0aGlzLmludGwsIG9wdHMpO1xuICB9XG5cbiAgaXNFbmdsaXNoKCkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmxvY2FsZSA9PT0gXCJlblwiIHx8XG4gICAgICB0aGlzLmxvY2FsZS50b0xvd2VyQ2FzZSgpID09PSBcImVuLXVzXCIgfHxcbiAgICAgIG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KHRoaXMuaW50bCkucmVzb2x2ZWRPcHRpb25zKCkubG9jYWxlLnN0YXJ0c1dpdGgoXCJlbi11c1wiKVxuICAgICk7XG4gIH1cblxuICBlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5sb2NhbGUgPT09IG90aGVyLmxvY2FsZSAmJlxuICAgICAgdGhpcy5udW1iZXJpbmdTeXN0ZW0gPT09IG90aGVyLm51bWJlcmluZ1N5c3RlbSAmJlxuICAgICAgdGhpcy5vdXRwdXRDYWxlbmRhciA9PT0gb3RoZXIub3V0cHV0Q2FsZW5kYXJcbiAgICApO1xuICB9XG59XG4iLCAiaW1wb3J0IHsgZm9ybWF0T2Zmc2V0LCBzaWduZWRPZmZzZXQgfSBmcm9tIFwiLi4vaW1wbC91dGlsLmpzXCI7XG5pbXBvcnQgWm9uZSBmcm9tIFwiLi4vem9uZS5qc1wiO1xuXG5sZXQgc2luZ2xldG9uID0gbnVsbDtcblxuLyoqXG4gKiBBIHpvbmUgd2l0aCBhIGZpeGVkIG9mZnNldCAobWVhbmluZyBubyBEU1QpXG4gKiBAaW1wbGVtZW50cyB7Wm9uZX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRml4ZWRPZmZzZXRab25lIGV4dGVuZHMgWm9uZSB7XG4gIC8qKlxuICAgKiBHZXQgYSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgVVRDXG4gICAqIEByZXR1cm4ge0ZpeGVkT2Zmc2V0Wm9uZX1cbiAgICovXG4gIHN0YXRpYyBnZXQgdXRjSW5zdGFuY2UoKSB7XG4gICAgaWYgKHNpbmdsZXRvbiA9PT0gbnVsbCkge1xuICAgICAgc2luZ2xldG9uID0gbmV3IEZpeGVkT2Zmc2V0Wm9uZSgwKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpbmdsZXRvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gaW5zdGFuY2Ugd2l0aCBhIHNwZWNpZmllZCBvZmZzZXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtIFRoZSBvZmZzZXQgaW4gbWludXRlc1xuICAgKiBAcmV0dXJuIHtGaXhlZE9mZnNldFpvbmV9XG4gICAqL1xuICBzdGF0aWMgaW5zdGFuY2Uob2Zmc2V0KSB7XG4gICAgcmV0dXJuIG9mZnNldCA9PT0gMCA/IEZpeGVkT2Zmc2V0Wm9uZS51dGNJbnN0YW5jZSA6IG5ldyBGaXhlZE9mZnNldFpvbmUob2Zmc2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gaW5zdGFuY2Ugb2YgRml4ZWRPZmZzZXRab25lIGZyb20gYSBVVEMgb2Zmc2V0IHN0cmluZywgbGlrZSBcIlVUQys2XCJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHMgLSBUaGUgb2Zmc2V0IHN0cmluZyB0byBwYXJzZVxuICAgKiBAZXhhbXBsZSBGaXhlZE9mZnNldFpvbmUucGFyc2VTcGVjaWZpZXIoXCJVVEMrNlwiKVxuICAgKiBAZXhhbXBsZSBGaXhlZE9mZnNldFpvbmUucGFyc2VTcGVjaWZpZXIoXCJVVEMrMDZcIilcbiAgICogQGV4YW1wbGUgRml4ZWRPZmZzZXRab25lLnBhcnNlU3BlY2lmaWVyKFwiVVRDLTY6MDBcIilcbiAgICogQHJldHVybiB7Rml4ZWRPZmZzZXRab25lfVxuICAgKi9cbiAgc3RhdGljIHBhcnNlU3BlY2lmaWVyKHMpIHtcbiAgICBpZiAocykge1xuICAgICAgY29uc3QgciA9IHMubWF0Y2goL151dGMoPzooWystXVxcZHsxLDJ9KSg/OjooXFxkezJ9KSk/KT8kL2kpO1xuICAgICAgaWYgKHIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGaXhlZE9mZnNldFpvbmUoc2lnbmVkT2Zmc2V0KHJbMV0sIHJbMl0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihvZmZzZXQpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKiBAcHJpdmF0ZSAqKi9cbiAgICB0aGlzLmZpeGVkID0gb2Zmc2V0O1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIFwiZml4ZWRcIjtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmZpeGVkID09PSAwID8gXCJVVENcIiA6IGBVVEMke2Zvcm1hdE9mZnNldCh0aGlzLmZpeGVkLCBcIm5hcnJvd1wiKX1gO1xuICB9XG5cbiAgZ2V0IGlhbmFOYW1lKCkge1xuICAgIGlmICh0aGlzLmZpeGVkID09PSAwKSB7XG4gICAgICByZXR1cm4gXCJFdGMvVVRDXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBgRXRjL0dNVCR7Zm9ybWF0T2Zmc2V0KC10aGlzLmZpeGVkLCBcIm5hcnJvd1wiKX1gO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIG9mZnNldE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGZvcm1hdE9mZnNldCh0cywgZm9ybWF0KSB7XG4gICAgcmV0dXJuIGZvcm1hdE9mZnNldCh0aGlzLmZpeGVkLCBmb3JtYXQpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IGlzVW5pdmVyc2FsKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgb2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLmZpeGVkO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZXF1YWxzKG90aGVyWm9uZSkge1xuICAgIHJldHVybiBvdGhlclpvbmUudHlwZSA9PT0gXCJmaXhlZFwiICYmIG90aGVyWm9uZS5maXhlZCA9PT0gdGhpcy5maXhlZDtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG4iLCAiaW1wb3J0IFpvbmUgZnJvbSBcIi4uL3pvbmUuanNcIjtcblxuLyoqXG4gKiBBIHpvbmUgdGhhdCBmYWlsZWQgdG8gcGFyc2UuIFlvdSBzaG91bGQgbmV2ZXIgbmVlZCB0byBpbnN0YW50aWF0ZSB0aGlzLlxuICogQGltcGxlbWVudHMge1pvbmV9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEludmFsaWRab25lIGV4dGVuZHMgWm9uZSB7XG4gIGNvbnN0cnVjdG9yKHpvbmVOYW1lKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKiogIEBwcml2YXRlICovXG4gICAgdGhpcy56b25lTmFtZSA9IHpvbmVOYW1lO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIFwiaW52YWxpZFwiO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuem9uZU5hbWU7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgaXNVbml2ZXJzYWwoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgb2Zmc2V0TmFtZSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGZvcm1hdE9mZnNldCgpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIG9mZnNldCgpIHtcbiAgICByZXR1cm4gTmFOO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZXF1YWxzKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuIiwgIi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5pbXBvcnQgWm9uZSBmcm9tIFwiLi4vem9uZS5qc1wiO1xuaW1wb3J0IElBTkFab25lIGZyb20gXCIuLi96b25lcy9JQU5BWm9uZS5qc1wiO1xuaW1wb3J0IEZpeGVkT2Zmc2V0Wm9uZSBmcm9tIFwiLi4vem9uZXMvZml4ZWRPZmZzZXRab25lLmpzXCI7XG5pbXBvcnQgSW52YWxpZFpvbmUgZnJvbSBcIi4uL3pvbmVzL2ludmFsaWRab25lLmpzXCI7XG5cbmltcG9ydCB7IGlzVW5kZWZpbmVkLCBpc1N0cmluZywgaXNOdW1iZXIgfSBmcm9tIFwiLi91dGlsLmpzXCI7XG5pbXBvcnQgU3lzdGVtWm9uZSBmcm9tIFwiLi4vem9uZXMvc3lzdGVtWm9uZS5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplWm9uZShpbnB1dCwgZGVmYXVsdFpvbmUpIHtcbiAgbGV0IG9mZnNldDtcbiAgaWYgKGlzVW5kZWZpbmVkKGlucHV0KSB8fCBpbnB1dCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBkZWZhdWx0Wm9uZTtcbiAgfSBlbHNlIGlmIChpbnB1dCBpbnN0YW5jZW9mIFpvbmUpIHtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH0gZWxzZSBpZiAoaXNTdHJpbmcoaW5wdXQpKSB7XG4gICAgY29uc3QgbG93ZXJlZCA9IGlucHV0LnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGxvd2VyZWQgPT09IFwiZGVmYXVsdFwiKSByZXR1cm4gZGVmYXVsdFpvbmU7XG4gICAgZWxzZSBpZiAobG93ZXJlZCA9PT0gXCJsb2NhbFwiIHx8IGxvd2VyZWQgPT09IFwic3lzdGVtXCIpIHJldHVybiBTeXN0ZW1ab25lLmluc3RhbmNlO1xuICAgIGVsc2UgaWYgKGxvd2VyZWQgPT09IFwidXRjXCIgfHwgbG93ZXJlZCA9PT0gXCJnbXRcIikgcmV0dXJuIEZpeGVkT2Zmc2V0Wm9uZS51dGNJbnN0YW5jZTtcbiAgICBlbHNlIHJldHVybiBGaXhlZE9mZnNldFpvbmUucGFyc2VTcGVjaWZpZXIobG93ZXJlZCkgfHwgSUFOQVpvbmUuY3JlYXRlKGlucHV0KTtcbiAgfSBlbHNlIGlmIChpc051bWJlcihpbnB1dCkpIHtcbiAgICByZXR1cm4gRml4ZWRPZmZzZXRab25lLmluc3RhbmNlKGlucHV0KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09IFwib2JqZWN0XCIgJiYgXCJvZmZzZXRcIiBpbiBpbnB1dCAmJiB0eXBlb2YgaW5wdXQub2Zmc2V0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAvLyBUaGlzIGlzIGR1bWIsIGJ1dCB0aGUgaW5zdGFuY2VvZiBjaGVjayBhYm92ZSBkb2Vzbid0IHNlZW0gdG8gcmVhbGx5IHdvcmtcbiAgICAvLyBzbyB3ZSdyZSBkdWNrIGNoZWNraW5nIGl0XG4gICAgcmV0dXJuIGlucHV0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgSW52YWxpZFpvbmUoaW5wdXQpO1xuICB9XG59XG4iLCAiaW1wb3J0IFN5c3RlbVpvbmUgZnJvbSBcIi4vem9uZXMvc3lzdGVtWm9uZS5qc1wiO1xuaW1wb3J0IElBTkFab25lIGZyb20gXCIuL3pvbmVzL0lBTkFab25lLmpzXCI7XG5pbXBvcnQgTG9jYWxlIGZyb20gXCIuL2ltcGwvbG9jYWxlLmpzXCI7XG5cbmltcG9ydCB7IG5vcm1hbGl6ZVpvbmUgfSBmcm9tIFwiLi9pbXBsL3pvbmVVdGlsLmpzXCI7XG5cbmxldCBub3cgPSAoKSA9PiBEYXRlLm5vdygpLFxuICBkZWZhdWx0Wm9uZSA9IFwic3lzdGVtXCIsXG4gIGRlZmF1bHRMb2NhbGUgPSBudWxsLFxuICBkZWZhdWx0TnVtYmVyaW5nU3lzdGVtID0gbnVsbCxcbiAgZGVmYXVsdE91dHB1dENhbGVuZGFyID0gbnVsbCxcbiAgdHdvRGlnaXRDdXRvZmZZZWFyID0gNjAsXG4gIHRocm93T25JbnZhbGlkO1xuXG4vKipcbiAqIFNldHRpbmdzIGNvbnRhaW5zIHN0YXRpYyBnZXR0ZXJzIGFuZCBzZXR0ZXJzIHRoYXQgY29udHJvbCBMdXhvbidzIG92ZXJhbGwgYmVoYXZpb3IuIEx1eG9uIGlzIGEgc2ltcGxlIGxpYnJhcnkgd2l0aCBmZXcgb3B0aW9ucywgYnV0IHRoZSBvbmVzIGl0IGRvZXMgaGF2ZSBsaXZlIGhlcmUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNldHRpbmdzIHtcbiAgLyoqXG4gICAqIEdldCB0aGUgY2FsbGJhY2sgZm9yIHJldHVybmluZyB0aGUgY3VycmVudCB0aW1lc3RhbXAuXG4gICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICovXG4gIHN0YXRpYyBnZXQgbm93KCkge1xuICAgIHJldHVybiBub3c7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBjYWxsYmFjayBmb3IgcmV0dXJuaW5nIHRoZSBjdXJyZW50IHRpbWVzdGFtcC5cbiAgICogVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBudW1iZXIsIHdoaWNoIHdpbGwgYmUgaW50ZXJwcmV0ZWQgYXMgYW4gRXBvY2ggbWlsbGlzZWNvbmQgY291bnRcbiAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgKiBAZXhhbXBsZSBTZXR0aW5ncy5ub3cgPSAoKSA9PiBEYXRlLm5vdygpICsgMzAwMCAvLyBwcmV0ZW5kIGl0IGlzIDMgc2Vjb25kcyBpbiB0aGUgZnV0dXJlXG4gICAqIEBleGFtcGxlIFNldHRpbmdzLm5vdyA9ICgpID0+IDAgLy8gYWx3YXlzIHByZXRlbmQgaXQncyBKYW4gMSwgMTk3MCBhdCBtaWRuaWdodCBpbiBVVEMgdGltZVxuICAgKi9cbiAgc3RhdGljIHNldCBub3cobikge1xuICAgIG5vdyA9IG47XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBkZWZhdWx0IHRpbWUgem9uZSB0byBjcmVhdGUgRGF0ZVRpbWVzIGluLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgKiBVc2UgdGhlIHZhbHVlIFwic3lzdGVtXCIgdG8gcmVzZXQgdGhpcyB2YWx1ZSB0byB0aGUgc3lzdGVtJ3MgdGltZSB6b25lLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIHNldCBkZWZhdWx0Wm9uZSh6b25lKSB7XG4gICAgZGVmYXVsdFpvbmUgPSB6b25lO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGVmYXVsdCB0aW1lIHpvbmUgb2JqZWN0IGN1cnJlbnRseSB1c2VkIHRvIGNyZWF0ZSBEYXRlVGltZXMuIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRoZSBzeXN0ZW0ncyB0aW1lIHpvbmUgKHRoZSBvbmUgc2V0IG9uIHRoZSBtYWNoaW5lIHRoYXQgcnVucyB0aGlzIGNvZGUpLlxuICAgKiBAdHlwZSB7Wm9uZX1cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdFpvbmUoKSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZVpvbmUoZGVmYXVsdFpvbmUsIFN5c3RlbVpvbmUuaW5zdGFuY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGVmYXVsdCBsb2NhbGUgdG8gY3JlYXRlIERhdGVUaW1lcyB3aXRoLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0TG9jYWxlKCkge1xuICAgIHJldHVybiBkZWZhdWx0TG9jYWxlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZGVmYXVsdCBsb2NhbGUgdG8gY3JlYXRlIERhdGVUaW1lcyB3aXRoLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIHNldCBkZWZhdWx0TG9jYWxlKGxvY2FsZSkge1xuICAgIGRlZmF1bHRMb2NhbGUgPSBsb2NhbGU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkZWZhdWx0IG51bWJlcmluZyBzeXN0ZW0gdG8gY3JlYXRlIERhdGVUaW1lcyB3aXRoLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0TnVtYmVyaW5nU3lzdGVtKCkge1xuICAgIHJldHVybiBkZWZhdWx0TnVtYmVyaW5nU3lzdGVtO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZGVmYXVsdCBudW1iZXJpbmcgc3lzdGVtIHRvIGNyZWF0ZSBEYXRlVGltZXMgd2l0aC4gRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBzZXQgZGVmYXVsdE51bWJlcmluZ1N5c3RlbShudW1iZXJpbmdTeXN0ZW0pIHtcbiAgICBkZWZhdWx0TnVtYmVyaW5nU3lzdGVtID0gbnVtYmVyaW5nU3lzdGVtO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGVmYXVsdCBvdXRwdXQgY2FsZW5kYXIgdG8gY3JlYXRlIERhdGVUaW1lcyB3aXRoLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0T3V0cHV0Q2FsZW5kYXIoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRPdXRwdXRDYWxlbmRhcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGRlZmF1bHQgb3V0cHV0IGNhbGVuZGFyIHRvIGNyZWF0ZSBEYXRlVGltZXMgd2l0aC4gRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBzZXQgZGVmYXVsdE91dHB1dENhbGVuZGFyKG91dHB1dENhbGVuZGFyKSB7XG4gICAgZGVmYXVsdE91dHB1dENhbGVuZGFyID0gb3V0cHV0Q2FsZW5kYXI7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXRvZmYgeWVhciBhZnRlciB3aGljaCBhIHN0cmluZyBlbmNvZGluZyBhIHllYXIgYXMgdHdvIGRpZ2l0cyBpcyBpbnRlcnByZXRlZCB0byBvY2N1ciBpbiB0aGUgY3VycmVudCBjZW50dXJ5LlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgc3RhdGljIGdldCB0d29EaWdpdEN1dG9mZlllYXIoKSB7XG4gICAgcmV0dXJuIHR3b0RpZ2l0Q3V0b2ZmWWVhcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGN1dG9mZiB5ZWFyIGFmdGVyIHdoaWNoIGEgc3RyaW5nIGVuY29kaW5nIGEgeWVhciBhcyB0d28gZGlnaXRzIGlzIGludGVycHJldGVkIHRvIG9jY3VyIGluIHRoZSBjdXJyZW50IGNlbnR1cnkuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBleGFtcGxlIFNldHRpbmdzLnR3b0RpZ2l0Q3V0b2ZmWWVhciA9IDAgLy8gY3V0LW9mZiB5ZWFyIGlzIDAsIHNvIGFsbCAneXknIGFyZSBpbnRlcnByZXRlZCBhcyBjdXJyZW50IGNlbnR1cnlcbiAgICogQGV4YW1wbGUgU2V0dGluZ3MudHdvRGlnaXRDdXRvZmZZZWFyID0gNTAgLy8gJzQ5JyAtPiAxOTQ5OyAnNTAnIC0+IDIwNTBcbiAgICogQGV4YW1wbGUgU2V0dGluZ3MudHdvRGlnaXRDdXRvZmZZZWFyID0gMTk1MCAvLyBpbnRlcnByZXRlZCBhcyA1MFxuICAgKiBAZXhhbXBsZSBTZXR0aW5ncy50d29EaWdpdEN1dG9mZlllYXIgPSAyMDUwIC8vIEFMU08gaW50ZXJwcmV0ZWQgYXMgNTBcbiAgICovXG4gIHN0YXRpYyBzZXQgdHdvRGlnaXRDdXRvZmZZZWFyKGN1dG9mZlllYXIpIHtcbiAgICB0d29EaWdpdEN1dG9mZlllYXIgPSBjdXRvZmZZZWFyICUgMTAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB3aGV0aGVyIEx1eG9uIHdpbGwgdGhyb3cgd2hlbiBpdCBlbmNvdW50ZXJzIGludmFsaWQgRGF0ZVRpbWVzLCBEdXJhdGlvbnMsIG9yIEludGVydmFsc1xuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBnZXQgdGhyb3dPbkludmFsaWQoKSB7XG4gICAgcmV0dXJuIHRocm93T25JbnZhbGlkO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB3aGV0aGVyIEx1eG9uIHdpbGwgdGhyb3cgd2hlbiBpdCBlbmNvdW50ZXJzIGludmFsaWQgRGF0ZVRpbWVzLCBEdXJhdGlvbnMsIG9yIEludGVydmFsc1xuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBzZXQgdGhyb3dPbkludmFsaWQodCkge1xuICAgIHRocm93T25JbnZhbGlkID0gdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCBMdXhvbidzIGdsb2JhbCBjYWNoZXMuIFNob3VsZCBvbmx5IGJlIG5lY2Vzc2FyeSBpbiB0ZXN0aW5nIHNjZW5hcmlvcy5cbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIHN0YXRpYyByZXNldENhY2hlcygpIHtcbiAgICBMb2NhbGUucmVzZXRDYWNoZSgpO1xuICAgIElBTkFab25lLnJlc2V0Q2FjaGUoKTtcbiAgfVxufVxuIiwgIi8qXG4gIFRoaXMgaXMganVzdCBhIGp1bmsgZHJhd2VyLCBjb250YWluaW5nIGFueXRoaW5nIHVzZWQgYWNyb3NzIG11bHRpcGxlIGNsYXNzZXMuXG4gIEJlY2F1c2UgTHV4b24gaXMgc21hbGwoaXNoKSwgdGhpcyBzaG91bGQgc3RheSBzbWFsbCBhbmQgd2Ugd29uJ3Qgd29ycnkgYWJvdXQgc3BsaXR0aW5nXG4gIGl0IHVwIGludG8sIHNheSwgcGFyc2luZ1V0aWwuanMgYW5kIGJhc2ljVXRpbC5qcyBhbmQgc28gb24uIEJ1dCB0aGV5IGFyZSBkaXZpZGVkIHVwIGJ5IGZlYXR1cmUgYXJlYS5cbiovXG5cbmltcG9ydCB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gZnJvbSBcIi4uL2Vycm9ycy5qc1wiO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gXCIuLi9zZXR0aW5ncy5qc1wiO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuLy8gVFlQRVNcblxuZXhwb3J0IGZ1bmN0aW9uIGlzVW5kZWZpbmVkKG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSBcInVuZGVmaW5lZFwiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNOdW1iZXIobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09IFwibnVtYmVyXCI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0ludGVnZXIobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09IFwibnVtYmVyXCIgJiYgbyAlIDEgPT09IDA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZyhvKSB7XG4gIHJldHVybiB0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRGF0ZShvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykgPT09IFwiW29iamVjdCBEYXRlXVwiO1xufVxuXG4vLyBDQVBBQklMSVRJRVNcblxuZXhwb3J0IGZ1bmN0aW9uIGhhc1JlbGF0aXZlKCkge1xuICB0cnkge1xuICAgIHJldHVybiB0eXBlb2YgSW50bCAhPT0gXCJ1bmRlZmluZWRcIiAmJiAhIUludGwuUmVsYXRpdmVUaW1lRm9ybWF0O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8vIE9CSkVDVFMgQU5EIEFSUkFZU1xuXG5leHBvcnQgZnVuY3Rpb24gbWF5YmVBcnJheSh0aGluZykge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh0aGluZykgPyB0aGluZyA6IFt0aGluZ107XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiZXN0QnkoYXJyLCBieSwgY29tcGFyZSkge1xuICBpZiAoYXJyLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIGFyci5yZWR1Y2UoKGJlc3QsIG5leHQpID0+IHtcbiAgICBjb25zdCBwYWlyID0gW2J5KG5leHQpLCBuZXh0XTtcbiAgICBpZiAoIWJlc3QpIHtcbiAgICAgIHJldHVybiBwYWlyO1xuICAgIH0gZWxzZSBpZiAoY29tcGFyZShiZXN0WzBdLCBwYWlyWzBdKSA9PT0gYmVzdFswXSkge1xuICAgICAgcmV0dXJuIGJlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwYWlyO1xuICAgIH1cbiAgfSwgbnVsbClbMV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwaWNrKG9iaiwga2V5cykge1xuICByZXR1cm4ga2V5cy5yZWR1Y2UoKGEsIGspID0+IHtcbiAgICBhW2tdID0gb2JqW2tdO1xuICAgIHJldHVybiBhO1xuICB9LCB7fSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG4vLyBOVU1CRVJTIEFORCBTVFJJTkdTXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnRlZ2VyQmV0d2Vlbih0aGluZywgYm90dG9tLCB0b3ApIHtcbiAgcmV0dXJuIGlzSW50ZWdlcih0aGluZykgJiYgdGhpbmcgPj0gYm90dG9tICYmIHRoaW5nIDw9IHRvcDtcbn1cblxuLy8geCAlIG4gYnV0IHRha2VzIHRoZSBzaWduIG9mIG4gaW5zdGVhZCBvZiB4XG5leHBvcnQgZnVuY3Rpb24gZmxvb3JNb2QoeCwgbikge1xuICByZXR1cm4geCAtIG4gKiBNYXRoLmZsb29yKHggLyBuKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhZFN0YXJ0KGlucHV0LCBuID0gMikge1xuICBjb25zdCBpc05lZyA9IGlucHV0IDwgMDtcbiAgbGV0IHBhZGRlZDtcbiAgaWYgKGlzTmVnKSB7XG4gICAgcGFkZGVkID0gXCItXCIgKyAoXCJcIiArIC1pbnB1dCkucGFkU3RhcnQobiwgXCIwXCIpO1xuICB9IGVsc2Uge1xuICAgIHBhZGRlZCA9IChcIlwiICsgaW5wdXQpLnBhZFN0YXJ0KG4sIFwiMFwiKTtcbiAgfVxuICByZXR1cm4gcGFkZGVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VJbnRlZ2VyKHN0cmluZykge1xuICBpZiAoaXNVbmRlZmluZWQoc3RyaW5nKSB8fCBzdHJpbmcgPT09IG51bGwgfHwgc3RyaW5nID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcGFyc2VJbnQoc3RyaW5nLCAxMCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRmxvYXRpbmcoc3RyaW5nKSB7XG4gIGlmIChpc1VuZGVmaW5lZChzdHJpbmcpIHx8IHN0cmluZyA9PT0gbnVsbCB8fCBzdHJpbmcgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHN0cmluZyk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlTWlsbGlzKGZyYWN0aW9uKSB7XG4gIC8vIFJldHVybiB1bmRlZmluZWQgKGluc3RlYWQgb2YgMCkgaW4gdGhlc2UgY2FzZXMsIHdoZXJlIGZyYWN0aW9uIGlzIG5vdCBzZXRcbiAgaWYgKGlzVW5kZWZpbmVkKGZyYWN0aW9uKSB8fCBmcmFjdGlvbiA9PT0gbnVsbCB8fCBmcmFjdGlvbiA9PT0gXCJcIikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZiA9IHBhcnNlRmxvYXQoXCIwLlwiICsgZnJhY3Rpb24pICogMTAwMDtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihmKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcm91bmRUbyhudW1iZXIsIGRpZ2l0cywgdG93YXJkWmVybyA9IGZhbHNlKSB7XG4gIGNvbnN0IGZhY3RvciA9IDEwICoqIGRpZ2l0cyxcbiAgICByb3VuZGVyID0gdG93YXJkWmVybyA/IE1hdGgudHJ1bmMgOiBNYXRoLnJvdW5kO1xuICByZXR1cm4gcm91bmRlcihudW1iZXIgKiBmYWN0b3IpIC8gZmFjdG9yO1xufVxuXG4vLyBEQVRFIEJBU0lDU1xuXG5leHBvcnQgZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gIHJldHVybiB5ZWFyICUgNCA9PT0gMCAmJiAoeWVhciAlIDEwMCAhPT0gMCB8fCB5ZWFyICUgNDAwID09PSAwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRheXNJblllYXIoeWVhcikge1xuICByZXR1cm4gaXNMZWFwWWVhcih5ZWFyKSA/IDM2NiA6IDM2NTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRheXNJbk1vbnRoKHllYXIsIG1vbnRoKSB7XG4gIGNvbnN0IG1vZE1vbnRoID0gZmxvb3JNb2QobW9udGggLSAxLCAxMikgKyAxLFxuICAgIG1vZFllYXIgPSB5ZWFyICsgKG1vbnRoIC0gbW9kTW9udGgpIC8gMTI7XG5cbiAgaWYgKG1vZE1vbnRoID09PSAyKSB7XG4gICAgcmV0dXJuIGlzTGVhcFllYXIobW9kWWVhcikgPyAyOSA6IDI4O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbMzEsIG51bGwsIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXVttb2RNb250aCAtIDFdO1xuICB9XG59XG5cbi8vIGNvbnZlcnQgYSBjYWxlbmRhciBvYmplY3QgdG8gYSBsb2NhbCB0aW1lc3RhbXAgKGVwb2NoLCBidXQgd2l0aCB0aGUgb2Zmc2V0IGJha2VkIGluKVxuZXhwb3J0IGZ1bmN0aW9uIG9ialRvTG9jYWxUUyhvYmopIHtcbiAgbGV0IGQgPSBEYXRlLlVUQyhcbiAgICBvYmoueWVhcixcbiAgICBvYmoubW9udGggLSAxLFxuICAgIG9iai5kYXksXG4gICAgb2JqLmhvdXIsXG4gICAgb2JqLm1pbnV0ZSxcbiAgICBvYmouc2Vjb25kLFxuICAgIG9iai5taWxsaXNlY29uZFxuICApO1xuXG4gIC8vIGZvciBsZWdhY3kgcmVhc29ucywgeWVhcnMgYmV0d2VlbiAwIGFuZCA5OSBhcmUgaW50ZXJwcmV0ZWQgYXMgMTlYWDsgcmV2ZXJ0IHRoYXRcbiAgaWYgKG9iai55ZWFyIDwgMTAwICYmIG9iai55ZWFyID49IDApIHtcbiAgICBkID0gbmV3IERhdGUoZCk7XG4gICAgLy8gc2V0IHRoZSBtb250aCBhbmQgZGF5IGFnYWluLCB0aGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHllYXIgMjAwMCBpcyBhIGxlYXAgeWVhciwgYnV0IHllYXIgMTAwIGlzIG5vdFxuICAgIC8vIHNvIGlmIG9iai55ZWFyIGlzIGluIDk5LCBidXQgb2JqLmRheSBtYWtlcyBpdCByb2xsIG92ZXIgaW50byB5ZWFyIDEwMCxcbiAgICAvLyB0aGUgY2FsY3VsYXRpb25zIGRvbmUgYnkgRGF0ZS5VVEMgYXJlIHVzaW5nIHllYXIgMjAwMCAtIHdoaWNoIGlzIGluY29ycmVjdFxuICAgIGQuc2V0VVRDRnVsbFllYXIob2JqLnllYXIsIG9iai5tb250aCAtIDEsIG9iai5kYXkpO1xuICB9XG4gIHJldHVybiArZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdlZWtzSW5XZWVrWWVhcih3ZWVrWWVhcikge1xuICBjb25zdCBwMSA9XG4gICAgICAod2Vla1llYXIgK1xuICAgICAgICBNYXRoLmZsb29yKHdlZWtZZWFyIC8gNCkgLVxuICAgICAgICBNYXRoLmZsb29yKHdlZWtZZWFyIC8gMTAwKSArXG4gICAgICAgIE1hdGguZmxvb3Iod2Vla1llYXIgLyA0MDApKSAlXG4gICAgICA3LFxuICAgIGxhc3QgPSB3ZWVrWWVhciAtIDEsXG4gICAgcDIgPSAobGFzdCArIE1hdGguZmxvb3IobGFzdCAvIDQpIC0gTWF0aC5mbG9vcihsYXN0IC8gMTAwKSArIE1hdGguZmxvb3IobGFzdCAvIDQwMCkpICUgNztcbiAgcmV0dXJuIHAxID09PSA0IHx8IHAyID09PSAzID8gNTMgOiA1Mjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVudHJ1bmNhdGVZZWFyKHllYXIpIHtcbiAgaWYgKHllYXIgPiA5OSkge1xuICAgIHJldHVybiB5ZWFyO1xuICB9IGVsc2UgcmV0dXJuIHllYXIgPiBTZXR0aW5ncy50d29EaWdpdEN1dG9mZlllYXIgPyAxOTAwICsgeWVhciA6IDIwMDAgKyB5ZWFyO1xufVxuXG4vLyBQQVJTSU5HXG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVpvbmVJbmZvKHRzLCBvZmZzZXRGb3JtYXQsIGxvY2FsZSwgdGltZVpvbmUgPSBudWxsKSB7XG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh0cyksXG4gICAgaW50bE9wdHMgPSB7XG4gICAgICBob3VyQ3ljbGU6IFwiaDIzXCIsXG4gICAgICB5ZWFyOiBcIm51bWVyaWNcIixcbiAgICAgIG1vbnRoOiBcIjItZGlnaXRcIixcbiAgICAgIGRheTogXCIyLWRpZ2l0XCIsXG4gICAgICBob3VyOiBcIjItZGlnaXRcIixcbiAgICAgIG1pbnV0ZTogXCIyLWRpZ2l0XCIsXG4gICAgfTtcblxuICBpZiAodGltZVpvbmUpIHtcbiAgICBpbnRsT3B0cy50aW1lWm9uZSA9IHRpbWVab25lO1xuICB9XG5cbiAgY29uc3QgbW9kaWZpZWQgPSB7IHRpbWVab25lTmFtZTogb2Zmc2V0Rm9ybWF0LCAuLi5pbnRsT3B0cyB9O1xuXG4gIGNvbnN0IHBhcnNlZCA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSwgbW9kaWZpZWQpXG4gICAgLmZvcm1hdFRvUGFydHMoZGF0ZSlcbiAgICAuZmluZCgobSkgPT4gbS50eXBlLnRvTG93ZXJDYXNlKCkgPT09IFwidGltZXpvbmVuYW1lXCIpO1xuICByZXR1cm4gcGFyc2VkID8gcGFyc2VkLnZhbHVlIDogbnVsbDtcbn1cblxuLy8gc2lnbmVkT2Zmc2V0KCctNScsICczMCcpIC0+IC0zMzBcbmV4cG9ydCBmdW5jdGlvbiBzaWduZWRPZmZzZXQob2ZmSG91clN0ciwgb2ZmTWludXRlU3RyKSB7XG4gIGxldCBvZmZIb3VyID0gcGFyc2VJbnQob2ZmSG91clN0ciwgMTApO1xuXG4gIC8vIGRvbid0IHx8IHRoaXMgYmVjYXVzZSB3ZSB3YW50IHRvIHByZXNlcnZlIC0wXG4gIGlmIChOdW1iZXIuaXNOYU4ob2ZmSG91cikpIHtcbiAgICBvZmZIb3VyID0gMDtcbiAgfVxuXG4gIGNvbnN0IG9mZk1pbiA9IHBhcnNlSW50KG9mZk1pbnV0ZVN0ciwgMTApIHx8IDAsXG4gICAgb2ZmTWluU2lnbmVkID0gb2ZmSG91ciA8IDAgfHwgT2JqZWN0LmlzKG9mZkhvdXIsIC0wKSA/IC1vZmZNaW4gOiBvZmZNaW47XG4gIHJldHVybiBvZmZIb3VyICogNjAgKyBvZmZNaW5TaWduZWQ7XG59XG5cbi8vIENPRVJDSU9OXG5cbmV4cG9ydCBmdW5jdGlvbiBhc051bWJlcih2YWx1ZSkge1xuICBjb25zdCBudW1lcmljVmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIiB8fCB2YWx1ZSA9PT0gXCJcIiB8fCBOdW1iZXIuaXNOYU4obnVtZXJpY1ZhbHVlKSlcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoYEludmFsaWQgdW5pdCB2YWx1ZSAke3ZhbHVlfWApO1xuICByZXR1cm4gbnVtZXJpY1ZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplT2JqZWN0KG9iaiwgbm9ybWFsaXplcikge1xuICBjb25zdCBub3JtYWxpemVkID0ge307XG4gIGZvciAoY29uc3QgdSBpbiBvYmopIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkob2JqLCB1KSkge1xuICAgICAgY29uc3QgdiA9IG9ialt1XTtcbiAgICAgIGlmICh2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gbnVsbCkgY29udGludWU7XG4gICAgICBub3JtYWxpemVkW25vcm1hbGl6ZXIodSldID0gYXNOdW1iZXIodik7XG4gICAgfVxuICB9XG4gIHJldHVybiBub3JtYWxpemVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0T2Zmc2V0KG9mZnNldCwgZm9ybWF0KSB7XG4gIGNvbnN0IGhvdXJzID0gTWF0aC50cnVuYyhNYXRoLmFicyhvZmZzZXQgLyA2MCkpLFxuICAgIG1pbnV0ZXMgPSBNYXRoLnRydW5jKE1hdGguYWJzKG9mZnNldCAlIDYwKSksXG4gICAgc2lnbiA9IG9mZnNldCA+PSAwID8gXCIrXCIgOiBcIi1cIjtcblxuICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgIGNhc2UgXCJzaG9ydFwiOlxuICAgICAgcmV0dXJuIGAke3NpZ259JHtwYWRTdGFydChob3VycywgMil9OiR7cGFkU3RhcnQobWludXRlcywgMil9YDtcbiAgICBjYXNlIFwibmFycm93XCI6XG4gICAgICByZXR1cm4gYCR7c2lnbn0ke2hvdXJzfSR7bWludXRlcyA+IDAgPyBgOiR7bWludXRlc31gIDogXCJcIn1gO1xuICAgIGNhc2UgXCJ0ZWNoaWVcIjpcbiAgICAgIHJldHVybiBgJHtzaWdufSR7cGFkU3RhcnQoaG91cnMsIDIpfSR7cGFkU3RhcnQobWludXRlcywgMil9YDtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFZhbHVlIGZvcm1hdCAke2Zvcm1hdH0gaXMgb3V0IG9mIHJhbmdlIGZvciBwcm9wZXJ0eSBmb3JtYXRgKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdGltZU9iamVjdChvYmopIHtcbiAgcmV0dXJuIHBpY2sob2JqLCBbXCJob3VyXCIsIFwibWludXRlXCIsIFwic2Vjb25kXCIsIFwibWlsbGlzZWNvbmRcIl0pO1xufVxuIiwgImltcG9ydCAqIGFzIEZvcm1hdHMgZnJvbSBcIi4vZm9ybWF0cy5qc1wiO1xuaW1wb3J0IHsgcGljayB9IGZyb20gXCIuL3V0aWwuanNcIjtcblxuZnVuY3Rpb24gc3RyaW5naWZ5KG9iaikge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqLCBPYmplY3Qua2V5cyhvYmopLnNvcnQoKSk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5leHBvcnQgY29uc3QgbW9udGhzTG9uZyA9IFtcbiAgXCJKYW51YXJ5XCIsXG4gIFwiRmVicnVhcnlcIixcbiAgXCJNYXJjaFwiLFxuICBcIkFwcmlsXCIsXG4gIFwiTWF5XCIsXG4gIFwiSnVuZVwiLFxuICBcIkp1bHlcIixcbiAgXCJBdWd1c3RcIixcbiAgXCJTZXB0ZW1iZXJcIixcbiAgXCJPY3RvYmVyXCIsXG4gIFwiTm92ZW1iZXJcIixcbiAgXCJEZWNlbWJlclwiLFxuXTtcblxuZXhwb3J0IGNvbnN0IG1vbnRoc1Nob3J0ID0gW1xuICBcIkphblwiLFxuICBcIkZlYlwiLFxuICBcIk1hclwiLFxuICBcIkFwclwiLFxuICBcIk1heVwiLFxuICBcIkp1blwiLFxuICBcIkp1bFwiLFxuICBcIkF1Z1wiLFxuICBcIlNlcFwiLFxuICBcIk9jdFwiLFxuICBcIk5vdlwiLFxuICBcIkRlY1wiLFxuXTtcblxuZXhwb3J0IGNvbnN0IG1vbnRoc05hcnJvdyA9IFtcIkpcIiwgXCJGXCIsIFwiTVwiLCBcIkFcIiwgXCJNXCIsIFwiSlwiLCBcIkpcIiwgXCJBXCIsIFwiU1wiLCBcIk9cIiwgXCJOXCIsIFwiRFwiXTtcblxuZXhwb3J0IGZ1bmN0aW9uIG1vbnRocyhsZW5ndGgpIHtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIFwibmFycm93XCI6XG4gICAgICByZXR1cm4gWy4uLm1vbnRoc05hcnJvd107XG4gICAgY2FzZSBcInNob3J0XCI6XG4gICAgICByZXR1cm4gWy4uLm1vbnRoc1Nob3J0XTtcbiAgICBjYXNlIFwibG9uZ1wiOlxuICAgICAgcmV0dXJuIFsuLi5tb250aHNMb25nXTtcbiAgICBjYXNlIFwibnVtZXJpY1wiOlxuICAgICAgcmV0dXJuIFtcIjFcIiwgXCIyXCIsIFwiM1wiLCBcIjRcIiwgXCI1XCIsIFwiNlwiLCBcIjdcIiwgXCI4XCIsIFwiOVwiLCBcIjEwXCIsIFwiMTFcIiwgXCIxMlwiXTtcbiAgICBjYXNlIFwiMi1kaWdpdFwiOlxuICAgICAgcmV0dXJuIFtcIjAxXCIsIFwiMDJcIiwgXCIwM1wiLCBcIjA0XCIsIFwiMDVcIiwgXCIwNlwiLCBcIjA3XCIsIFwiMDhcIiwgXCIwOVwiLCBcIjEwXCIsIFwiMTFcIiwgXCIxMlwiXTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHdlZWtkYXlzTG9uZyA9IFtcbiAgXCJNb25kYXlcIixcbiAgXCJUdWVzZGF5XCIsXG4gIFwiV2VkbmVzZGF5XCIsXG4gIFwiVGh1cnNkYXlcIixcbiAgXCJGcmlkYXlcIixcbiAgXCJTYXR1cmRheVwiLFxuICBcIlN1bmRheVwiLFxuXTtcblxuZXhwb3J0IGNvbnN0IHdlZWtkYXlzU2hvcnQgPSBbXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIiwgXCJTdW5cIl07XG5cbmV4cG9ydCBjb25zdCB3ZWVrZGF5c05hcnJvdyA9IFtcIk1cIiwgXCJUXCIsIFwiV1wiLCBcIlRcIiwgXCJGXCIsIFwiU1wiLCBcIlNcIl07XG5cbmV4cG9ydCBmdW5jdGlvbiB3ZWVrZGF5cyhsZW5ndGgpIHtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIFwibmFycm93XCI6XG4gICAgICByZXR1cm4gWy4uLndlZWtkYXlzTmFycm93XTtcbiAgICBjYXNlIFwic2hvcnRcIjpcbiAgICAgIHJldHVybiBbLi4ud2Vla2RheXNTaG9ydF07XG4gICAgY2FzZSBcImxvbmdcIjpcbiAgICAgIHJldHVybiBbLi4ud2Vla2RheXNMb25nXTtcbiAgICBjYXNlIFwibnVtZXJpY1wiOlxuICAgICAgcmV0dXJuIFtcIjFcIiwgXCIyXCIsIFwiM1wiLCBcIjRcIiwgXCI1XCIsIFwiNlwiLCBcIjdcIl07XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBtZXJpZGllbXMgPSBbXCJBTVwiLCBcIlBNXCJdO1xuXG5leHBvcnQgY29uc3QgZXJhc0xvbmcgPSBbXCJCZWZvcmUgQ2hyaXN0XCIsIFwiQW5ubyBEb21pbmlcIl07XG5cbmV4cG9ydCBjb25zdCBlcmFzU2hvcnQgPSBbXCJCQ1wiLCBcIkFEXCJdO1xuXG5leHBvcnQgY29uc3QgZXJhc05hcnJvdyA9IFtcIkJcIiwgXCJBXCJdO1xuXG5leHBvcnQgZnVuY3Rpb24gZXJhcyhsZW5ndGgpIHtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIFwibmFycm93XCI6XG4gICAgICByZXR1cm4gWy4uLmVyYXNOYXJyb3ddO1xuICAgIGNhc2UgXCJzaG9ydFwiOlxuICAgICAgcmV0dXJuIFsuLi5lcmFzU2hvcnRdO1xuICAgIGNhc2UgXCJsb25nXCI6XG4gICAgICByZXR1cm4gWy4uLmVyYXNMb25nXTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmlkaWVtRm9yRGF0ZVRpbWUoZHQpIHtcbiAgcmV0dXJuIG1lcmlkaWVtc1tkdC5ob3VyIDwgMTIgPyAwIDogMV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3ZWVrZGF5Rm9yRGF0ZVRpbWUoZHQsIGxlbmd0aCkge1xuICByZXR1cm4gd2Vla2RheXMobGVuZ3RoKVtkdC53ZWVrZGF5IC0gMV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtb250aEZvckRhdGVUaW1lKGR0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIG1vbnRocyhsZW5ndGgpW2R0Lm1vbnRoIC0gMV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlcmFGb3JEYXRlVGltZShkdCwgbGVuZ3RoKSB7XG4gIHJldHVybiBlcmFzKGxlbmd0aClbZHQueWVhciA8IDAgPyAwIDogMV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRSZWxhdGl2ZVRpbWUodW5pdCwgY291bnQsIG51bWVyaWMgPSBcImFsd2F5c1wiLCBuYXJyb3cgPSBmYWxzZSkge1xuICBjb25zdCB1bml0cyA9IHtcbiAgICB5ZWFyczogW1wieWVhclwiLCBcInlyLlwiXSxcbiAgICBxdWFydGVyczogW1wicXVhcnRlclwiLCBcInF0ci5cIl0sXG4gICAgbW9udGhzOiBbXCJtb250aFwiLCBcIm1vLlwiXSxcbiAgICB3ZWVrczogW1wid2Vla1wiLCBcIndrLlwiXSxcbiAgICBkYXlzOiBbXCJkYXlcIiwgXCJkYXlcIiwgXCJkYXlzXCJdLFxuICAgIGhvdXJzOiBbXCJob3VyXCIsIFwiaHIuXCJdLFxuICAgIG1pbnV0ZXM6IFtcIm1pbnV0ZVwiLCBcIm1pbi5cIl0sXG4gICAgc2Vjb25kczogW1wic2Vjb25kXCIsIFwic2VjLlwiXSxcbiAgfTtcblxuICBjb25zdCBsYXN0YWJsZSA9IFtcImhvdXJzXCIsIFwibWludXRlc1wiLCBcInNlY29uZHNcIl0uaW5kZXhPZih1bml0KSA9PT0gLTE7XG5cbiAgaWYgKG51bWVyaWMgPT09IFwiYXV0b1wiICYmIGxhc3RhYmxlKSB7XG4gICAgY29uc3QgaXNEYXkgPSB1bml0ID09PSBcImRheXNcIjtcbiAgICBzd2l0Y2ggKGNvdW50KSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBpc0RheSA/IFwidG9tb3Jyb3dcIiA6IGBuZXh0ICR7dW5pdHNbdW5pdF1bMF19YDtcbiAgICAgIGNhc2UgLTE6XG4gICAgICAgIHJldHVybiBpc0RheSA/IFwieWVzdGVyZGF5XCIgOiBgbGFzdCAke3VuaXRzW3VuaXRdWzBdfWA7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiBpc0RheSA/IFwidG9kYXlcIiA6IGB0aGlzICR7dW5pdHNbdW5pdF1bMF19YDtcbiAgICAgIGRlZmF1bHQ6IC8vIGZhbGwgdGhyb3VnaFxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGlzSW5QYXN0ID0gT2JqZWN0LmlzKGNvdW50LCAtMCkgfHwgY291bnQgPCAwLFxuICAgIGZtdFZhbHVlID0gTWF0aC5hYnMoY291bnQpLFxuICAgIHNpbmd1bGFyID0gZm10VmFsdWUgPT09IDEsXG4gICAgbGlsVW5pdHMgPSB1bml0c1t1bml0XSxcbiAgICBmbXRVbml0ID0gbmFycm93XG4gICAgICA/IHNpbmd1bGFyXG4gICAgICAgID8gbGlsVW5pdHNbMV1cbiAgICAgICAgOiBsaWxVbml0c1syXSB8fCBsaWxVbml0c1sxXVxuICAgICAgOiBzaW5ndWxhclxuICAgICAgPyB1bml0c1t1bml0XVswXVxuICAgICAgOiB1bml0O1xuICByZXR1cm4gaXNJblBhc3QgPyBgJHtmbXRWYWx1ZX0gJHtmbXRVbml0fSBhZ29gIDogYGluICR7Zm10VmFsdWV9ICR7Zm10VW5pdH1gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0U3RyaW5nKGtub3duRm9ybWF0KSB7XG4gIC8vIHRoZXNlIGFsbCBoYXZlIHRoZSBvZmZzZXRzIHJlbW92ZWQgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIGFjY2VzcyB0byB0aGVtXG4gIC8vIHdpdGhvdXQgYWxsIHRoZSBpbnRsIHN0dWZmIHRoaXMgaXMgYmFja2ZpbGxpbmdcbiAgY29uc3QgZmlsdGVyZWQgPSBwaWNrKGtub3duRm9ybWF0LCBbXG4gICAgICBcIndlZWtkYXlcIixcbiAgICAgIFwiZXJhXCIsXG4gICAgICBcInllYXJcIixcbiAgICAgIFwibW9udGhcIixcbiAgICAgIFwiZGF5XCIsXG4gICAgICBcImhvdXJcIixcbiAgICAgIFwibWludXRlXCIsXG4gICAgICBcInNlY29uZFwiLFxuICAgICAgXCJ0aW1lWm9uZU5hbWVcIixcbiAgICAgIFwiaG91ckN5Y2xlXCIsXG4gICAgXSksXG4gICAga2V5ID0gc3RyaW5naWZ5KGZpbHRlcmVkKSxcbiAgICBkYXRlVGltZUh1Z2UgPSBcIkVFRUUsIExMTEwgZCwgeXl5eSwgaDptbSBhXCI7XG4gIHN3aXRjaCAoa2V5KSB7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFX1NIT1JUKTpcbiAgICAgIHJldHVybiBcIk0vZC95eXl5XCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFX01FRCk6XG4gICAgICByZXR1cm4gXCJMTEwgZCwgeXl5eVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURV9NRURfV0lUSF9XRUVLREFZKTpcbiAgICAgIHJldHVybiBcIkVFRSwgTExMIGQsIHl5eXlcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVfRlVMTCk6XG4gICAgICByZXR1cm4gXCJMTExMIGQsIHl5eXlcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVfSFVHRSk6XG4gICAgICByZXR1cm4gXCJFRUVFLCBMTExMIGQsIHl5eXlcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLlRJTUVfU0lNUExFKTpcbiAgICAgIHJldHVybiBcImg6bW0gYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuVElNRV9XSVRIX1NFQ09ORFMpOlxuICAgICAgcmV0dXJuIFwiaDptbTpzcyBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5USU1FX1dJVEhfU0hPUlRfT0ZGU0VUKTpcbiAgICAgIHJldHVybiBcImg6bW0gYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuVElNRV9XSVRIX0xPTkdfT0ZGU0VUKTpcbiAgICAgIHJldHVybiBcImg6bW0gYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuVElNRV8yNF9TSU1QTEUpOlxuICAgICAgcmV0dXJuIFwiSEg6bW1cIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLlRJTUVfMjRfV0lUSF9TRUNPTkRTKTpcbiAgICAgIHJldHVybiBcIkhIOm1tOnNzXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5USU1FXzI0X1dJVEhfU0hPUlRfT0ZGU0VUKTpcbiAgICAgIHJldHVybiBcIkhIOm1tXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5USU1FXzI0X1dJVEhfTE9OR19PRkZTRVQpOlxuICAgICAgcmV0dXJuIFwiSEg6bW1cIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX1NIT1JUKTpcbiAgICAgIHJldHVybiBcIk0vZC95eXl5LCBoOm1tIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX01FRCk6XG4gICAgICByZXR1cm4gXCJMTEwgZCwgeXl5eSwgaDptbSBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9GVUxMKTpcbiAgICAgIHJldHVybiBcIkxMTEwgZCwgeXl5eSwgaDptbSBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9IVUdFKTpcbiAgICAgIHJldHVybiBkYXRlVGltZUh1Z2U7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9TSE9SVF9XSVRIX1NFQ09ORFMpOlxuICAgICAgcmV0dXJuIFwiTS9kL3l5eXksIGg6bW06c3MgYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfTUVEX1dJVEhfU0VDT05EUyk6XG4gICAgICByZXR1cm4gXCJMTEwgZCwgeXl5eSwgaDptbTpzcyBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9NRURfV0lUSF9XRUVLREFZKTpcbiAgICAgIHJldHVybiBcIkVFRSwgZCBMTEwgeXl5eSwgaDptbSBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9GVUxMX1dJVEhfU0VDT05EUyk6XG4gICAgICByZXR1cm4gXCJMTExMIGQsIHl5eXksIGg6bW06c3MgYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfSFVHRV9XSVRIX1NFQ09ORFMpOlxuICAgICAgcmV0dXJuIFwiRUVFRSwgTExMTCBkLCB5eXl5LCBoOm1tOnNzIGFcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGRhdGVUaW1lSHVnZTtcbiAgfVxufVxuIiwgImltcG9ydCAqIGFzIEVuZ2xpc2ggZnJvbSBcIi4vZW5nbGlzaC5qc1wiO1xuaW1wb3J0ICogYXMgRm9ybWF0cyBmcm9tIFwiLi9mb3JtYXRzLmpzXCI7XG5pbXBvcnQgeyBwYWRTdGFydCB9IGZyb20gXCIuL3V0aWwuanNcIjtcblxuZnVuY3Rpb24gc3RyaW5naWZ5VG9rZW5zKHNwbGl0cywgdG9rZW5Ub1N0cmluZykge1xuICBsZXQgcyA9IFwiXCI7XG4gIGZvciAoY29uc3QgdG9rZW4gb2Ygc3BsaXRzKSB7XG4gICAgaWYgKHRva2VuLmxpdGVyYWwpIHtcbiAgICAgIHMgKz0gdG9rZW4udmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzICs9IHRva2VuVG9TdHJpbmcodG9rZW4udmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHM7XG59XG5cbmNvbnN0IG1hY3JvVG9rZW5Ub0Zvcm1hdE9wdHMgPSB7XG4gIEQ6IEZvcm1hdHMuREFURV9TSE9SVCxcbiAgREQ6IEZvcm1hdHMuREFURV9NRUQsXG4gIERERDogRm9ybWF0cy5EQVRFX0ZVTEwsXG4gIEREREQ6IEZvcm1hdHMuREFURV9IVUdFLFxuICB0OiBGb3JtYXRzLlRJTUVfU0lNUExFLFxuICB0dDogRm9ybWF0cy5USU1FX1dJVEhfU0VDT05EUyxcbiAgdHR0OiBGb3JtYXRzLlRJTUVfV0lUSF9TSE9SVF9PRkZTRVQsXG4gIHR0dHQ6IEZvcm1hdHMuVElNRV9XSVRIX0xPTkdfT0ZGU0VULFxuICBUOiBGb3JtYXRzLlRJTUVfMjRfU0lNUExFLFxuICBUVDogRm9ybWF0cy5USU1FXzI0X1dJVEhfU0VDT05EUyxcbiAgVFRUOiBGb3JtYXRzLlRJTUVfMjRfV0lUSF9TSE9SVF9PRkZTRVQsXG4gIFRUVFQ6IEZvcm1hdHMuVElNRV8yNF9XSVRIX0xPTkdfT0ZGU0VULFxuICBmOiBGb3JtYXRzLkRBVEVUSU1FX1NIT1JULFxuICBmZjogRm9ybWF0cy5EQVRFVElNRV9NRUQsXG4gIGZmZjogRm9ybWF0cy5EQVRFVElNRV9GVUxMLFxuICBmZmZmOiBGb3JtYXRzLkRBVEVUSU1FX0hVR0UsXG4gIEY6IEZvcm1hdHMuREFURVRJTUVfU0hPUlRfV0lUSF9TRUNPTkRTLFxuICBGRjogRm9ybWF0cy5EQVRFVElNRV9NRURfV0lUSF9TRUNPTkRTLFxuICBGRkY6IEZvcm1hdHMuREFURVRJTUVfRlVMTF9XSVRIX1NFQ09ORFMsXG4gIEZGRkY6IEZvcm1hdHMuREFURVRJTUVfSFVHRV9XSVRIX1NFQ09ORFMsXG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRm9ybWF0dGVyIHtcbiAgc3RhdGljIGNyZWF0ZShsb2NhbGUsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgRm9ybWF0dGVyKGxvY2FsZSwgb3B0cyk7XG4gIH1cblxuICBzdGF0aWMgcGFyc2VGb3JtYXQoZm10KSB7XG4gICAgLy8gd2hpdGUtc3BhY2UgaXMgYWx3YXlzIGNvbnNpZGVyZWQgYSBsaXRlcmFsIGluIHVzZXItcHJvdmlkZWQgZm9ybWF0c1xuICAgIC8vIHRoZSBcIiBcIiB0b2tlbiBoYXMgYSBzcGVjaWFsIG1lYW5pbmcgKHNlZSB1bml0Rm9yVG9rZW4pXG5cbiAgICBsZXQgY3VycmVudCA9IG51bGwsXG4gICAgICBjdXJyZW50RnVsbCA9IFwiXCIsXG4gICAgICBicmFja2V0ZWQgPSBmYWxzZTtcbiAgICBjb25zdCBzcGxpdHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZtdC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYyA9IGZtdC5jaGFyQXQoaSk7XG4gICAgICBpZiAoYyA9PT0gXCInXCIpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRGdWxsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzcGxpdHMucHVzaCh7IGxpdGVyYWw6IGJyYWNrZXRlZCB8fCAvXlxccyskLy50ZXN0KGN1cnJlbnRGdWxsKSwgdmFsOiBjdXJyZW50RnVsbCB9KTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gbnVsbDtcbiAgICAgICAgY3VycmVudEZ1bGwgPSBcIlwiO1xuICAgICAgICBicmFja2V0ZWQgPSAhYnJhY2tldGVkO1xuICAgICAgfSBlbHNlIGlmIChicmFja2V0ZWQpIHtcbiAgICAgICAgY3VycmVudEZ1bGwgKz0gYztcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gY3VycmVudCkge1xuICAgICAgICBjdXJyZW50RnVsbCArPSBjO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGN1cnJlbnRGdWxsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzcGxpdHMucHVzaCh7IGxpdGVyYWw6IC9eXFxzKyQvLnRlc3QoY3VycmVudEZ1bGwpLCB2YWw6IGN1cnJlbnRGdWxsIH0pO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRGdWxsID0gYztcbiAgICAgICAgY3VycmVudCA9IGM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRGdWxsLmxlbmd0aCA+IDApIHtcbiAgICAgIHNwbGl0cy5wdXNoKHsgbGl0ZXJhbDogYnJhY2tldGVkIHx8IC9eXFxzKyQvLnRlc3QoY3VycmVudEZ1bGwpLCB2YWw6IGN1cnJlbnRGdWxsIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBzcGxpdHM7XG4gIH1cblxuICBzdGF0aWMgbWFjcm9Ub2tlblRvRm9ybWF0T3B0cyh0b2tlbikge1xuICAgIHJldHVybiBtYWNyb1Rva2VuVG9Gb3JtYXRPcHRzW3Rva2VuXTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGxvY2FsZSwgZm9ybWF0T3B0cykge1xuICAgIHRoaXMub3B0cyA9IGZvcm1hdE9wdHM7XG4gICAgdGhpcy5sb2MgPSBsb2NhbGU7XG4gICAgdGhpcy5zeXN0ZW1Mb2MgPSBudWxsO1xuICB9XG5cbiAgZm9ybWF0V2l0aFN5c3RlbURlZmF1bHQoZHQsIG9wdHMpIHtcbiAgICBpZiAodGhpcy5zeXN0ZW1Mb2MgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuc3lzdGVtTG9jID0gdGhpcy5sb2MucmVkZWZhdWx0VG9TeXN0ZW0oKTtcbiAgICB9XG4gICAgY29uc3QgZGYgPSB0aGlzLnN5c3RlbUxvYy5kdEZvcm1hdHRlcihkdCwgeyAuLi50aGlzLm9wdHMsIC4uLm9wdHMgfSk7XG4gICAgcmV0dXJuIGRmLmZvcm1hdCgpO1xuICB9XG5cbiAgZHRGb3JtYXR0ZXIoZHQsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmxvYy5kdEZvcm1hdHRlcihkdCwgeyAuLi50aGlzLm9wdHMsIC4uLm9wdHMgfSk7XG4gIH1cblxuICBmb3JtYXREYXRlVGltZShkdCwgb3B0cykge1xuICAgIHJldHVybiB0aGlzLmR0Rm9ybWF0dGVyKGR0LCBvcHRzKS5mb3JtYXQoKTtcbiAgfVxuXG4gIGZvcm1hdERhdGVUaW1lUGFydHMoZHQsIG9wdHMpIHtcbiAgICByZXR1cm4gdGhpcy5kdEZvcm1hdHRlcihkdCwgb3B0cykuZm9ybWF0VG9QYXJ0cygpO1xuICB9XG5cbiAgZm9ybWF0SW50ZXJ2YWwoaW50ZXJ2YWwsIG9wdHMpIHtcbiAgICBjb25zdCBkZiA9IHRoaXMuZHRGb3JtYXR0ZXIoaW50ZXJ2YWwuc3RhcnQsIG9wdHMpO1xuICAgIHJldHVybiBkZi5kdGYuZm9ybWF0UmFuZ2UoaW50ZXJ2YWwuc3RhcnQudG9KU0RhdGUoKSwgaW50ZXJ2YWwuZW5kLnRvSlNEYXRlKCkpO1xuICB9XG5cbiAgcmVzb2x2ZWRPcHRpb25zKGR0LCBvcHRzKSB7XG4gICAgcmV0dXJuIHRoaXMuZHRGb3JtYXR0ZXIoZHQsIG9wdHMpLnJlc29sdmVkT3B0aW9ucygpO1xuICB9XG5cbiAgbnVtKG4sIHAgPSAwKSB7XG4gICAgLy8gd2UgZ2V0IHNvbWUgcGVyZiBvdXQgb2YgZG9pbmcgdGhpcyBoZXJlLCBhbm5veWluZ2x5XG4gICAgaWYgKHRoaXMub3B0cy5mb3JjZVNpbXBsZSkge1xuICAgICAgcmV0dXJuIHBhZFN0YXJ0KG4sIHApO1xuICAgIH1cblxuICAgIGNvbnN0IG9wdHMgPSB7IC4uLnRoaXMub3B0cyB9O1xuXG4gICAgaWYgKHAgPiAwKSB7XG4gICAgICBvcHRzLnBhZFRvID0gcDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5sb2MubnVtYmVyRm9ybWF0dGVyKG9wdHMpLmZvcm1hdChuKTtcbiAgfVxuXG4gIGZvcm1hdERhdGVUaW1lRnJvbVN0cmluZyhkdCwgZm10KSB7XG4gICAgY29uc3Qga25vd25FbmdsaXNoID0gdGhpcy5sb2MubGlzdGluZ01vZGUoKSA9PT0gXCJlblwiLFxuICAgICAgdXNlRGF0ZVRpbWVGb3JtYXR0ZXIgPSB0aGlzLmxvYy5vdXRwdXRDYWxlbmRhciAmJiB0aGlzLmxvYy5vdXRwdXRDYWxlbmRhciAhPT0gXCJncmVnb3J5XCIsXG4gICAgICBzdHJpbmcgPSAob3B0cywgZXh0cmFjdCkgPT4gdGhpcy5sb2MuZXh0cmFjdChkdCwgb3B0cywgZXh0cmFjdCksXG4gICAgICBmb3JtYXRPZmZzZXQgPSAob3B0cykgPT4ge1xuICAgICAgICBpZiAoZHQuaXNPZmZzZXRGaXhlZCAmJiBkdC5vZmZzZXQgPT09IDAgJiYgb3B0cy5hbGxvd1opIHtcbiAgICAgICAgICByZXR1cm4gXCJaXCI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZHQuaXNWYWxpZCA/IGR0LnpvbmUuZm9ybWF0T2Zmc2V0KGR0LnRzLCBvcHRzLmZvcm1hdCkgOiBcIlwiO1xuICAgICAgfSxcbiAgICAgIG1lcmlkaWVtID0gKCkgPT5cbiAgICAgICAga25vd25FbmdsaXNoXG4gICAgICAgICAgPyBFbmdsaXNoLm1lcmlkaWVtRm9yRGF0ZVRpbWUoZHQpXG4gICAgICAgICAgOiBzdHJpbmcoeyBob3VyOiBcIm51bWVyaWNcIiwgaG91ckN5Y2xlOiBcImgxMlwiIH0sIFwiZGF5cGVyaW9kXCIpLFxuICAgICAgbW9udGggPSAobGVuZ3RoLCBzdGFuZGFsb25lKSA9PlxuICAgICAgICBrbm93bkVuZ2xpc2hcbiAgICAgICAgICA/IEVuZ2xpc2gubW9udGhGb3JEYXRlVGltZShkdCwgbGVuZ3RoKVxuICAgICAgICAgIDogc3RyaW5nKHN0YW5kYWxvbmUgPyB7IG1vbnRoOiBsZW5ndGggfSA6IHsgbW9udGg6IGxlbmd0aCwgZGF5OiBcIm51bWVyaWNcIiB9LCBcIm1vbnRoXCIpLFxuICAgICAgd2Vla2RheSA9IChsZW5ndGgsIHN0YW5kYWxvbmUpID0+XG4gICAgICAgIGtub3duRW5nbGlzaFxuICAgICAgICAgID8gRW5nbGlzaC53ZWVrZGF5Rm9yRGF0ZVRpbWUoZHQsIGxlbmd0aClcbiAgICAgICAgICA6IHN0cmluZyhcbiAgICAgICAgICAgICAgc3RhbmRhbG9uZSA/IHsgd2Vla2RheTogbGVuZ3RoIH0gOiB7IHdlZWtkYXk6IGxlbmd0aCwgbW9udGg6IFwibG9uZ1wiLCBkYXk6IFwibnVtZXJpY1wiIH0sXG4gICAgICAgICAgICAgIFwid2Vla2RheVwiXG4gICAgICAgICAgICApLFxuICAgICAgbWF5YmVNYWNybyA9ICh0b2tlbikgPT4ge1xuICAgICAgICBjb25zdCBmb3JtYXRPcHRzID0gRm9ybWF0dGVyLm1hY3JvVG9rZW5Ub0Zvcm1hdE9wdHModG9rZW4pO1xuICAgICAgICBpZiAoZm9ybWF0T3B0cykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdFdpdGhTeXN0ZW1EZWZhdWx0KGR0LCBmb3JtYXRPcHRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBlcmEgPSAobGVuZ3RoKSA9PlxuICAgICAgICBrbm93bkVuZ2xpc2ggPyBFbmdsaXNoLmVyYUZvckRhdGVUaW1lKGR0LCBsZW5ndGgpIDogc3RyaW5nKHsgZXJhOiBsZW5ndGggfSwgXCJlcmFcIiksXG4gICAgICB0b2tlblRvU3RyaW5nID0gKHRva2VuKSA9PiB7XG4gICAgICAgIC8vIFdoZXJlIHBvc3NpYmxlOiBodHRwczovL2NsZHIudW5pY29kZS5vcmcvdHJhbnNsYXRpb24vZGF0ZS10aW1lL2RhdGUtdGltZS1zeW1ib2xzXG4gICAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgICAvLyBtc1xuICAgICAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQubWlsbGlzZWNvbmQpO1xuICAgICAgICAgIGNhc2UgXCJ1XCI6XG4gICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICAgIGNhc2UgXCJTU1NcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5taWxsaXNlY29uZCwgMyk7XG4gICAgICAgICAgLy8gc2Vjb25kc1xuICAgICAgICAgIGNhc2UgXCJzXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQuc2Vjb25kKTtcbiAgICAgICAgICBjYXNlIFwic3NcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5zZWNvbmQsIDIpO1xuICAgICAgICAgIC8vIGZyYWN0aW9uYWwgc2Vjb25kc1xuICAgICAgICAgIGNhc2UgXCJ1dVwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKE1hdGguZmxvb3IoZHQubWlsbGlzZWNvbmQgLyAxMCksIDIpO1xuICAgICAgICAgIGNhc2UgXCJ1dXVcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShNYXRoLmZsb29yKGR0Lm1pbGxpc2Vjb25kIC8gMTAwKSk7XG4gICAgICAgICAgLy8gbWludXRlc1xuICAgICAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQubWludXRlKTtcbiAgICAgICAgICBjYXNlIFwibW1cIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5taW51dGUsIDIpO1xuICAgICAgICAgIC8vIGhvdXJzXG4gICAgICAgICAgY2FzZSBcImhcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5ob3VyICUgMTIgPT09IDAgPyAxMiA6IGR0LmhvdXIgJSAxMik7XG4gICAgICAgICAgY2FzZSBcImhoXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQuaG91ciAlIDEyID09PSAwID8gMTIgOiBkdC5ob3VyICUgMTIsIDIpO1xuICAgICAgICAgIGNhc2UgXCJIXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQuaG91cik7XG4gICAgICAgICAgY2FzZSBcIkhIXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQuaG91ciwgMik7XG4gICAgICAgICAgLy8gb2Zmc2V0XG4gICAgICAgICAgY2FzZSBcIlpcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgKzZcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRPZmZzZXQoeyBmb3JtYXQ6IFwibmFycm93XCIsIGFsbG93WjogdGhpcy5vcHRzLmFsbG93WiB9KTtcbiAgICAgICAgICBjYXNlIFwiWlpcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgKzA2OjAwXG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0T2Zmc2V0KHsgZm9ybWF0OiBcInNob3J0XCIsIGFsbG93WjogdGhpcy5vcHRzLmFsbG93WiB9KTtcbiAgICAgICAgICBjYXNlIFwiWlpaXCI6XG4gICAgICAgICAgICAvLyBsaWtlICswNjAwXG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0T2Zmc2V0KHsgZm9ybWF0OiBcInRlY2hpZVwiLCBhbGxvd1o6IHRoaXMub3B0cy5hbGxvd1ogfSk7XG4gICAgICAgICAgY2FzZSBcIlpaWlpcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgRVNUXG4gICAgICAgICAgICByZXR1cm4gZHQuem9uZS5vZmZzZXROYW1lKGR0LnRzLCB7IGZvcm1hdDogXCJzaG9ydFwiLCBsb2NhbGU6IHRoaXMubG9jLmxvY2FsZSB9KTtcbiAgICAgICAgICBjYXNlIFwiWlpaWlpcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgRWFzdGVybiBTdGFuZGFyZCBUaW1lXG4gICAgICAgICAgICByZXR1cm4gZHQuem9uZS5vZmZzZXROYW1lKGR0LnRzLCB7IGZvcm1hdDogXCJsb25nXCIsIGxvY2FsZTogdGhpcy5sb2MubG9jYWxlIH0pO1xuICAgICAgICAgIC8vIHpvbmVcbiAgICAgICAgICBjYXNlIFwielwiOlxuICAgICAgICAgICAgLy8gbGlrZSBBbWVyaWNhL05ld19Zb3JrXG4gICAgICAgICAgICByZXR1cm4gZHQuem9uZU5hbWU7XG4gICAgICAgICAgLy8gbWVyaWRpZW1zXG4gICAgICAgICAgY2FzZSBcImFcIjpcbiAgICAgICAgICAgIHJldHVybiBtZXJpZGllbSgpO1xuICAgICAgICAgIC8vIGRhdGVzXG4gICAgICAgICAgY2FzZSBcImRcIjpcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlciA/IHN0cmluZyh7IGRheTogXCJudW1lcmljXCIgfSwgXCJkYXlcIikgOiB0aGlzLm51bShkdC5kYXkpO1xuICAgICAgICAgIGNhc2UgXCJkZFwiOlxuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyID8gc3RyaW5nKHsgZGF5OiBcIjItZGlnaXRcIiB9LCBcImRheVwiKSA6IHRoaXMubnVtKGR0LmRheSwgMik7XG4gICAgICAgICAgLy8gd2Vla2RheXMgLSBzdGFuZGFsb25lXG4gICAgICAgICAgY2FzZSBcImNcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LndlZWtkYXkpO1xuICAgICAgICAgIGNhc2UgXCJjY2NcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgJ1R1ZXMnXG4gICAgICAgICAgICByZXR1cm4gd2Vla2RheShcInNob3J0XCIsIHRydWUpO1xuICAgICAgICAgIGNhc2UgXCJjY2NjXCI6XG4gICAgICAgICAgICAvLyBsaWtlICdUdWVzZGF5J1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtkYXkoXCJsb25nXCIsIHRydWUpO1xuICAgICAgICAgIGNhc2UgXCJjY2NjY1wiOlxuICAgICAgICAgICAgLy8gbGlrZSAnVCdcbiAgICAgICAgICAgIHJldHVybiB3ZWVrZGF5KFwibmFycm93XCIsIHRydWUpO1xuICAgICAgICAgIC8vIHdlZWtkYXlzIC0gZm9ybWF0XG4gICAgICAgICAgY2FzZSBcIkVcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LndlZWtkYXkpO1xuICAgICAgICAgIGNhc2UgXCJFRUVcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgJ1R1ZXMnXG4gICAgICAgICAgICByZXR1cm4gd2Vla2RheShcInNob3J0XCIsIGZhbHNlKTtcbiAgICAgICAgICBjYXNlIFwiRUVFRVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAnVHVlc2RheSdcbiAgICAgICAgICAgIHJldHVybiB3ZWVrZGF5KFwibG9uZ1wiLCBmYWxzZSk7XG4gICAgICAgICAgY2FzZSBcIkVFRUVFXCI6XG4gICAgICAgICAgICAvLyBsaWtlICdUJ1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtkYXkoXCJuYXJyb3dcIiwgZmFsc2UpO1xuICAgICAgICAgIC8vIG1vbnRocyAtIHN0YW5kYWxvbmVcbiAgICAgICAgICBjYXNlIFwiTFwiOlxuICAgICAgICAgICAgLy8gbGlrZSAxXG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXJcbiAgICAgICAgICAgICAgPyBzdHJpbmcoeyBtb250aDogXCJudW1lcmljXCIsIGRheTogXCJudW1lcmljXCIgfSwgXCJtb250aFwiKVxuICAgICAgICAgICAgICA6IHRoaXMubnVtKGR0Lm1vbnRoKTtcbiAgICAgICAgICBjYXNlIFwiTExcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMDEsIGRvZXNuJ3Qgc2VlbSB0byB3b3JrXG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXJcbiAgICAgICAgICAgICAgPyBzdHJpbmcoeyBtb250aDogXCIyLWRpZ2l0XCIsIGRheTogXCJudW1lcmljXCIgfSwgXCJtb250aFwiKVxuICAgICAgICAgICAgICA6IHRoaXMubnVtKGR0Lm1vbnRoLCAyKTtcbiAgICAgICAgICBjYXNlIFwiTExMXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEphblxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoKFwic2hvcnRcIiwgdHJ1ZSk7XG4gICAgICAgICAgY2FzZSBcIkxMTExcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgSmFudWFyeVxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoKFwibG9uZ1wiLCB0cnVlKTtcbiAgICAgICAgICBjYXNlIFwiTExMTExcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgSlxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoKFwibmFycm93XCIsIHRydWUpO1xuICAgICAgICAgIC8vIG1vbnRocyAtIGZvcm1hdFxuICAgICAgICAgIGNhc2UgXCJNXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDFcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlclxuICAgICAgICAgICAgICA/IHN0cmluZyh7IG1vbnRoOiBcIm51bWVyaWNcIiB9LCBcIm1vbnRoXCIpXG4gICAgICAgICAgICAgIDogdGhpcy5udW0oZHQubW9udGgpO1xuICAgICAgICAgIGNhc2UgXCJNTVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAwMVxuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyXG4gICAgICAgICAgICAgID8gc3RyaW5nKHsgbW9udGg6IFwiMi1kaWdpdFwiIH0sIFwibW9udGhcIilcbiAgICAgICAgICAgICAgOiB0aGlzLm51bShkdC5tb250aCwgMik7XG4gICAgICAgICAgY2FzZSBcIk1NTVwiOlxuICAgICAgICAgICAgLy8gbGlrZSBKYW5cbiAgICAgICAgICAgIHJldHVybiBtb250aChcInNob3J0XCIsIGZhbHNlKTtcbiAgICAgICAgICBjYXNlIFwiTU1NTVwiOlxuICAgICAgICAgICAgLy8gbGlrZSBKYW51YXJ5XG4gICAgICAgICAgICByZXR1cm4gbW9udGgoXCJsb25nXCIsIGZhbHNlKTtcbiAgICAgICAgICBjYXNlIFwiTU1NTU1cIjpcbiAgICAgICAgICAgIC8vIGxpa2UgSlxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoKFwibmFycm93XCIsIGZhbHNlKTtcbiAgICAgICAgICAvLyB5ZWFyc1xuICAgICAgICAgIGNhc2UgXCJ5XCI6XG4gICAgICAgICAgICAvLyBsaWtlIDIwMTRcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlciA/IHN0cmluZyh7IHllYXI6IFwibnVtZXJpY1wiIH0sIFwieWVhclwiKSA6IHRoaXMubnVtKGR0LnllYXIpO1xuICAgICAgICAgIGNhc2UgXCJ5eVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAxNFxuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyXG4gICAgICAgICAgICAgID8gc3RyaW5nKHsgeWVhcjogXCIyLWRpZ2l0XCIgfSwgXCJ5ZWFyXCIpXG4gICAgICAgICAgICAgIDogdGhpcy5udW0oZHQueWVhci50b1N0cmluZygpLnNsaWNlKC0yKSwgMik7XG4gICAgICAgICAgY2FzZSBcInl5eXlcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMDAxMlxuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyXG4gICAgICAgICAgICAgID8gc3RyaW5nKHsgeWVhcjogXCJudW1lcmljXCIgfSwgXCJ5ZWFyXCIpXG4gICAgICAgICAgICAgIDogdGhpcy5udW0oZHQueWVhciwgNCk7XG4gICAgICAgICAgY2FzZSBcInl5eXl5eVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAwMDAwMTJcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlclxuICAgICAgICAgICAgICA/IHN0cmluZyh7IHllYXI6IFwibnVtZXJpY1wiIH0sIFwieWVhclwiKVxuICAgICAgICAgICAgICA6IHRoaXMubnVtKGR0LnllYXIsIDYpO1xuICAgICAgICAgIC8vIGVyYXNcbiAgICAgICAgICBjYXNlIFwiR1wiOlxuICAgICAgICAgICAgLy8gbGlrZSBBRFxuICAgICAgICAgICAgcmV0dXJuIGVyYShcInNob3J0XCIpO1xuICAgICAgICAgIGNhc2UgXCJHR1wiOlxuICAgICAgICAgICAgLy8gbGlrZSBBbm5vIERvbWluaVxuICAgICAgICAgICAgcmV0dXJuIGVyYShcImxvbmdcIik7XG4gICAgICAgICAgY2FzZSBcIkdHR0dHXCI6XG4gICAgICAgICAgICByZXR1cm4gZXJhKFwibmFycm93XCIpO1xuICAgICAgICAgIGNhc2UgXCJra1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LndlZWtZZWFyLnRvU3RyaW5nKCkuc2xpY2UoLTIpLCAyKTtcbiAgICAgICAgICBjYXNlIFwia2tra1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LndlZWtZZWFyLCA0KTtcbiAgICAgICAgICBjYXNlIFwiV1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LndlZWtOdW1iZXIpO1xuICAgICAgICAgIGNhc2UgXCJXV1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LndlZWtOdW1iZXIsIDIpO1xuICAgICAgICAgIGNhc2UgXCJvXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQub3JkaW5hbCk7XG4gICAgICAgICAgY2FzZSBcIm9vb1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0Lm9yZGluYWwsIDMpO1xuICAgICAgICAgIGNhc2UgXCJxXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDFcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5xdWFydGVyKTtcbiAgICAgICAgICBjYXNlIFwicXFcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMDFcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5xdWFydGVyLCAyKTtcbiAgICAgICAgICBjYXNlIFwiWFwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKE1hdGguZmxvb3IoZHQudHMgLyAxMDAwKSk7XG4gICAgICAgICAgY2FzZSBcInhcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC50cyk7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBtYXliZU1hY3JvKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgIHJldHVybiBzdHJpbmdpZnlUb2tlbnMoRm9ybWF0dGVyLnBhcnNlRm9ybWF0KGZtdCksIHRva2VuVG9TdHJpbmcpO1xuICB9XG5cbiAgZm9ybWF0RHVyYXRpb25Gcm9tU3RyaW5nKGR1ciwgZm10KSB7XG4gICAgY29uc3QgdG9rZW5Ub0ZpZWxkID0gKHRva2VuKSA9PiB7XG4gICAgICAgIHN3aXRjaCAodG9rZW5bMF0pIHtcbiAgICAgICAgICBjYXNlIFwiU1wiOlxuICAgICAgICAgICAgcmV0dXJuIFwibWlsbGlzZWNvbmRcIjtcbiAgICAgICAgICBjYXNlIFwic1wiOlxuICAgICAgICAgICAgcmV0dXJuIFwic2Vjb25kXCI7XG4gICAgICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgICAgIHJldHVybiBcIm1pbnV0ZVwiO1xuICAgICAgICAgIGNhc2UgXCJoXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJob3VyXCI7XG4gICAgICAgICAgY2FzZSBcImRcIjpcbiAgICAgICAgICAgIHJldHVybiBcImRheVwiO1xuICAgICAgICAgIGNhc2UgXCJ3XCI6XG4gICAgICAgICAgICByZXR1cm4gXCJ3ZWVrXCI7XG4gICAgICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgICAgIHJldHVybiBcIm1vbnRoXCI7XG4gICAgICAgICAgY2FzZSBcInlcIjpcbiAgICAgICAgICAgIHJldHVybiBcInllYXJcIjtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0b2tlblRvU3RyaW5nID0gKGxpbGR1cikgPT4gKHRva2VuKSA9PiB7XG4gICAgICAgIGNvbnN0IG1hcHBlZCA9IHRva2VuVG9GaWVsZCh0b2tlbik7XG4gICAgICAgIGlmIChtYXBwZWQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5udW0obGlsZHVyLmdldChtYXBwZWQpLCB0b2tlbi5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRva2VucyA9IEZvcm1hdHRlci5wYXJzZUZvcm1hdChmbXQpLFxuICAgICAgcmVhbFRva2VucyA9IHRva2Vucy5yZWR1Y2UoXG4gICAgICAgIChmb3VuZCwgeyBsaXRlcmFsLCB2YWwgfSkgPT4gKGxpdGVyYWwgPyBmb3VuZCA6IGZvdW5kLmNvbmNhdCh2YWwpKSxcbiAgICAgICAgW11cbiAgICAgICksXG4gICAgICBjb2xsYXBzZWQgPSBkdXIuc2hpZnRUbyguLi5yZWFsVG9rZW5zLm1hcCh0b2tlblRvRmllbGQpLmZpbHRlcigodCkgPT4gdCkpO1xuICAgIHJldHVybiBzdHJpbmdpZnlUb2tlbnModG9rZW5zLCB0b2tlblRvU3RyaW5nKGNvbGxhcHNlZCkpO1xuICB9XG59XG4iLCAiZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW52YWxpZCB7XG4gIGNvbnN0cnVjdG9yKHJlYXNvbiwgZXhwbGFuYXRpb24pIHtcbiAgICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgICB0aGlzLmV4cGxhbmF0aW9uID0gZXhwbGFuYXRpb247XG4gIH1cblxuICB0b01lc3NhZ2UoKSB7XG4gICAgaWYgKHRoaXMuZXhwbGFuYXRpb24pIHtcbiAgICAgIHJldHVybiBgJHt0aGlzLnJlYXNvbn06ICR7dGhpcy5leHBsYW5hdGlvbn1gO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWFzb247XG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgdW50cnVuY2F0ZVllYXIsXG4gIHNpZ25lZE9mZnNldCxcbiAgcGFyc2VJbnRlZ2VyLFxuICBwYXJzZU1pbGxpcyxcbiAgaXNVbmRlZmluZWQsXG4gIHBhcnNlRmxvYXRpbmcsXG59IGZyb20gXCIuL3V0aWwuanNcIjtcbmltcG9ydCAqIGFzIEVuZ2xpc2ggZnJvbSBcIi4vZW5nbGlzaC5qc1wiO1xuaW1wb3J0IEZpeGVkT2Zmc2V0Wm9uZSBmcm9tIFwiLi4vem9uZXMvZml4ZWRPZmZzZXRab25lLmpzXCI7XG5pbXBvcnQgSUFOQVpvbmUgZnJvbSBcIi4uL3pvbmVzL0lBTkFab25lLmpzXCI7XG5cbi8qXG4gKiBUaGlzIGZpbGUgaGFuZGxlcyBwYXJzaW5nIGZvciB3ZWxsLXNwZWNpZmllZCBmb3JtYXRzLiBIZXJlJ3MgaG93IGl0IHdvcmtzOlxuICogVHdvIHRoaW5ncyBnbyBpbnRvIHBhcnNpbmc6IGEgcmVnZXggdG8gbWF0Y2ggd2l0aCBhbmQgYW4gZXh0cmFjdG9yIHRvIHRha2UgYXBhcnQgdGhlIGdyb3VwcyBpbiB0aGUgbWF0Y2guXG4gKiBBbiBleHRyYWN0b3IgaXMganVzdCBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSByZWdleCBtYXRjaCBhcnJheSBhbmQgcmV0dXJucyBhIHsgeWVhcjogLi4uLCBtb250aDogLi4uIH0gb2JqZWN0XG4gKiBwYXJzZSgpIGRvZXMgdGhlIHdvcmsgb2YgZXhlY3V0aW5nIHRoZSByZWdleCBhbmQgYXBwbHlpbmcgdGhlIGV4dHJhY3Rvci4gSXQgdGFrZXMgbXVsdGlwbGUgcmVnZXgvZXh0cmFjdG9yIHBhaXJzIHRvIHRyeSBpbiBzZXF1ZW5jZS5cbiAqIEV4dHJhY3RvcnMgY2FuIHRha2UgYSBcImN1cnNvclwiIHJlcHJlc2VudGluZyB0aGUgb2Zmc2V0IGluIHRoZSBtYXRjaCB0byBsb29rIGF0LiBUaGlzIG1ha2VzIGl0IGVhc3kgdG8gY29tYmluZSBleHRyYWN0b3JzLlxuICogY29tYmluZUV4dHJhY3RvcnMoKSBkb2VzIHRoZSB3b3JrIG9mIGNvbWJpbmluZyB0aGVtLCBrZWVwaW5nIHRyYWNrIG9mIHRoZSBjdXJzb3IgdGhyb3VnaCBtdWx0aXBsZSBleHRyYWN0aW9ucy5cbiAqIFNvbWUgZXh0cmFjdGlvbnMgYXJlIHN1cGVyIGR1bWIgYW5kIHNpbXBsZVBhcnNlIGFuZCBmcm9tU3RyaW5ncyBoZWxwIERSWSB0aGVtLlxuICovXG5cbmNvbnN0IGlhbmFSZWdleCA9IC9bQS1aYS16XystXXsxLDI1Nn0oPzo6P1xcL1tBLVphLXowLTlfKy1dezEsMjU2fSg/OlxcL1tBLVphLXowLTlfKy1dezEsMjU2fSk/KT8vO1xuXG5mdW5jdGlvbiBjb21iaW5lUmVnZXhlcyguLi5yZWdleGVzKSB7XG4gIGNvbnN0IGZ1bGwgPSByZWdleGVzLnJlZHVjZSgoZiwgcikgPT4gZiArIHIuc291cmNlLCBcIlwiKTtcbiAgcmV0dXJuIFJlZ0V4cChgXiR7ZnVsbH0kYCk7XG59XG5cbmZ1bmN0aW9uIGNvbWJpbmVFeHRyYWN0b3JzKC4uLmV4dHJhY3RvcnMpIHtcbiAgcmV0dXJuIChtKSA9PlxuICAgIGV4dHJhY3RvcnNcbiAgICAgIC5yZWR1Y2UoXG4gICAgICAgIChbbWVyZ2VkVmFscywgbWVyZ2VkWm9uZSwgY3Vyc29yXSwgZXgpID0+IHtcbiAgICAgICAgICBjb25zdCBbdmFsLCB6b25lLCBuZXh0XSA9IGV4KG0sIGN1cnNvcik7XG4gICAgICAgICAgcmV0dXJuIFt7IC4uLm1lcmdlZFZhbHMsIC4uLnZhbCB9LCB6b25lIHx8IG1lcmdlZFpvbmUsIG5leHRdO1xuICAgICAgICB9LFxuICAgICAgICBbe30sIG51bGwsIDFdXG4gICAgICApXG4gICAgICAuc2xpY2UoMCwgMik7XG59XG5cbmZ1bmN0aW9uIHBhcnNlKHMsIC4uLnBhdHRlcm5zKSB7XG4gIGlmIChzID09IG51bGwpIHtcbiAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICB9XG5cbiAgZm9yIChjb25zdCBbcmVnZXgsIGV4dHJhY3Rvcl0gb2YgcGF0dGVybnMpIHtcbiAgICBjb25zdCBtID0gcmVnZXguZXhlYyhzKTtcbiAgICBpZiAobSkge1xuICAgICAgcmV0dXJuIGV4dHJhY3RvcihtKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtudWxsLCBudWxsXTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlUGFyc2UoLi4ua2V5cykge1xuICByZXR1cm4gKG1hdGNoLCBjdXJzb3IpID0+IHtcbiAgICBjb25zdCByZXQgPSB7fTtcbiAgICBsZXQgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXRba2V5c1tpXV0gPSBwYXJzZUludGVnZXIobWF0Y2hbY3Vyc29yICsgaV0pO1xuICAgIH1cbiAgICByZXR1cm4gW3JldCwgbnVsbCwgY3Vyc29yICsgaV07XG4gIH07XG59XG5cbi8vIElTTyBhbmQgU1FMIHBhcnNpbmdcbmNvbnN0IG9mZnNldFJlZ2V4ID0gLyg/OihaKXwoWystXVxcZFxcZCkoPzo6PyhcXGRcXGQpKT8pLztcbmNvbnN0IGlzb0V4dGVuZGVkWm9uZSA9IGAoPzoke29mZnNldFJlZ2V4LnNvdXJjZX0/KD86XFxcXFsoJHtpYW5hUmVnZXguc291cmNlfSlcXFxcXSk/KT9gO1xuY29uc3QgaXNvVGltZUJhc2VSZWdleCA9IC8oXFxkXFxkKSg/Ojo/KFxcZFxcZCkoPzo6PyhcXGRcXGQpKD86Wy4sXShcXGR7MSwzMH0pKT8pPyk/LztcbmNvbnN0IGlzb1RpbWVSZWdleCA9IFJlZ0V4cChgJHtpc29UaW1lQmFzZVJlZ2V4LnNvdXJjZX0ke2lzb0V4dGVuZGVkWm9uZX1gKTtcbmNvbnN0IGlzb1RpbWVFeHRlbnNpb25SZWdleCA9IFJlZ0V4cChgKD86VCR7aXNvVGltZVJlZ2V4LnNvdXJjZX0pP2ApO1xuY29uc3QgaXNvWW1kUmVnZXggPSAvKFsrLV1cXGR7Nn18XFxkezR9KSg/Oi0/KFxcZFxcZCkoPzotPyhcXGRcXGQpKT8pPy87XG5jb25zdCBpc29XZWVrUmVnZXggPSAvKFxcZHs0fSktP1coXFxkXFxkKSg/Oi0/KFxcZCkpPy87XG5jb25zdCBpc29PcmRpbmFsUmVnZXggPSAvKFxcZHs0fSktPyhcXGR7M30pLztcbmNvbnN0IGV4dHJhY3RJU09XZWVrRGF0YSA9IHNpbXBsZVBhcnNlKFwid2Vla1llYXJcIiwgXCJ3ZWVrTnVtYmVyXCIsIFwid2Vla0RheVwiKTtcbmNvbnN0IGV4dHJhY3RJU09PcmRpbmFsRGF0YSA9IHNpbXBsZVBhcnNlKFwieWVhclwiLCBcIm9yZGluYWxcIik7XG5jb25zdCBzcWxZbWRSZWdleCA9IC8oXFxkezR9KS0oXFxkXFxkKS0oXFxkXFxkKS87IC8vIGR1bWJlZC1kb3duIHZlcnNpb24gb2YgdGhlIElTTyBvbmVcbmNvbnN0IHNxbFRpbWVSZWdleCA9IFJlZ0V4cChcbiAgYCR7aXNvVGltZUJhc2VSZWdleC5zb3VyY2V9ID8oPzoke29mZnNldFJlZ2V4LnNvdXJjZX18KCR7aWFuYVJlZ2V4LnNvdXJjZX0pKT9gXG4pO1xuY29uc3Qgc3FsVGltZUV4dGVuc2lvblJlZ2V4ID0gUmVnRXhwKGAoPzogJHtzcWxUaW1lUmVnZXguc291cmNlfSk/YCk7XG5cbmZ1bmN0aW9uIGludChtYXRjaCwgcG9zLCBmYWxsYmFjaykge1xuICBjb25zdCBtID0gbWF0Y2hbcG9zXTtcbiAgcmV0dXJuIGlzVW5kZWZpbmVkKG0pID8gZmFsbGJhY2sgOiBwYXJzZUludGVnZXIobSk7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RJU09ZbWQobWF0Y2gsIGN1cnNvcikge1xuICBjb25zdCBpdGVtID0ge1xuICAgIHllYXI6IGludChtYXRjaCwgY3Vyc29yKSxcbiAgICBtb250aDogaW50KG1hdGNoLCBjdXJzb3IgKyAxLCAxKSxcbiAgICBkYXk6IGludChtYXRjaCwgY3Vyc29yICsgMiwgMSksXG4gIH07XG5cbiAgcmV0dXJuIFtpdGVtLCBudWxsLCBjdXJzb3IgKyAzXTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdElTT1RpbWUobWF0Y2gsIGN1cnNvcikge1xuICBjb25zdCBpdGVtID0ge1xuICAgIGhvdXJzOiBpbnQobWF0Y2gsIGN1cnNvciwgMCksXG4gICAgbWludXRlczogaW50KG1hdGNoLCBjdXJzb3IgKyAxLCAwKSxcbiAgICBzZWNvbmRzOiBpbnQobWF0Y2gsIGN1cnNvciArIDIsIDApLFxuICAgIG1pbGxpc2Vjb25kczogcGFyc2VNaWxsaXMobWF0Y2hbY3Vyc29yICsgM10pLFxuICB9O1xuXG4gIHJldHVybiBbaXRlbSwgbnVsbCwgY3Vyc29yICsgNF07XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RJU09PZmZzZXQobWF0Y2gsIGN1cnNvcikge1xuICBjb25zdCBsb2NhbCA9ICFtYXRjaFtjdXJzb3JdICYmICFtYXRjaFtjdXJzb3IgKyAxXSxcbiAgICBmdWxsT2Zmc2V0ID0gc2lnbmVkT2Zmc2V0KG1hdGNoW2N1cnNvciArIDFdLCBtYXRjaFtjdXJzb3IgKyAyXSksXG4gICAgem9uZSA9IGxvY2FsID8gbnVsbCA6IEZpeGVkT2Zmc2V0Wm9uZS5pbnN0YW5jZShmdWxsT2Zmc2V0KTtcbiAgcmV0dXJuIFt7fSwgem9uZSwgY3Vyc29yICsgM107XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RJQU5BWm9uZShtYXRjaCwgY3Vyc29yKSB7XG4gIGNvbnN0IHpvbmUgPSBtYXRjaFtjdXJzb3JdID8gSUFOQVpvbmUuY3JlYXRlKG1hdGNoW2N1cnNvcl0pIDogbnVsbDtcbiAgcmV0dXJuIFt7fSwgem9uZSwgY3Vyc29yICsgMV07XG59XG5cbi8vIElTTyB0aW1lIHBhcnNpbmdcblxuY29uc3QgaXNvVGltZU9ubHkgPSBSZWdFeHAoYF5UPyR7aXNvVGltZUJhc2VSZWdleC5zb3VyY2V9JGApO1xuXG4vLyBJU08gZHVyYXRpb24gcGFyc2luZ1xuXG5jb25zdCBpc29EdXJhdGlvbiA9XG4gIC9eLT9QKD86KD86KC0/XFxkezEsMjB9KD86XFwuXFxkezEsMjB9KT8pWSk/KD86KC0/XFxkezEsMjB9KD86XFwuXFxkezEsMjB9KT8pTSk/KD86KC0/XFxkezEsMjB9KD86XFwuXFxkezEsMjB9KT8pVyk/KD86KC0/XFxkezEsMjB9KD86XFwuXFxkezEsMjB9KT8pRCk/KD86VCg/OigtP1xcZHsxLDIwfSg/OlxcLlxcZHsxLDIwfSk/KUgpPyg/OigtP1xcZHsxLDIwfSg/OlxcLlxcZHsxLDIwfSk/KU0pPyg/OigtP1xcZHsxLDIwfSkoPzpbLixdKC0/XFxkezEsMjB9KSk/Uyk/KT8pJC87XG5cbmZ1bmN0aW9uIGV4dHJhY3RJU09EdXJhdGlvbihtYXRjaCkge1xuICBjb25zdCBbcywgeWVhclN0ciwgbW9udGhTdHIsIHdlZWtTdHIsIGRheVN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHIsIG1pbGxpc2Vjb25kc1N0cl0gPVxuICAgIG1hdGNoO1xuXG4gIGNvbnN0IGhhc05lZ2F0aXZlUHJlZml4ID0gc1swXSA9PT0gXCItXCI7XG4gIGNvbnN0IG5lZ2F0aXZlU2Vjb25kcyA9IHNlY29uZFN0ciAmJiBzZWNvbmRTdHJbMF0gPT09IFwiLVwiO1xuXG4gIGNvbnN0IG1heWJlTmVnYXRlID0gKG51bSwgZm9yY2UgPSBmYWxzZSkgPT5cbiAgICBudW0gIT09IHVuZGVmaW5lZCAmJiAoZm9yY2UgfHwgKG51bSAmJiBoYXNOZWdhdGl2ZVByZWZpeCkpID8gLW51bSA6IG51bTtcblxuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIHllYXJzOiBtYXliZU5lZ2F0ZShwYXJzZUZsb2F0aW5nKHllYXJTdHIpKSxcbiAgICAgIG1vbnRoczogbWF5YmVOZWdhdGUocGFyc2VGbG9hdGluZyhtb250aFN0cikpLFxuICAgICAgd2Vla3M6IG1heWJlTmVnYXRlKHBhcnNlRmxvYXRpbmcod2Vla1N0cikpLFxuICAgICAgZGF5czogbWF5YmVOZWdhdGUocGFyc2VGbG9hdGluZyhkYXlTdHIpKSxcbiAgICAgIGhvdXJzOiBtYXliZU5lZ2F0ZShwYXJzZUZsb2F0aW5nKGhvdXJTdHIpKSxcbiAgICAgIG1pbnV0ZXM6IG1heWJlTmVnYXRlKHBhcnNlRmxvYXRpbmcobWludXRlU3RyKSksXG4gICAgICBzZWNvbmRzOiBtYXliZU5lZ2F0ZShwYXJzZUZsb2F0aW5nKHNlY29uZFN0ciksIHNlY29uZFN0ciA9PT0gXCItMFwiKSxcbiAgICAgIG1pbGxpc2Vjb25kczogbWF5YmVOZWdhdGUocGFyc2VNaWxsaXMobWlsbGlzZWNvbmRzU3RyKSwgbmVnYXRpdmVTZWNvbmRzKSxcbiAgICB9LFxuICBdO1xufVxuXG4vLyBUaGVzZSBhcmUgYSBsaXR0bGUgYnJhaW5kZWFkLiBFRFQgKnNob3VsZCogdGVsbCB1cyB0aGF0IHdlJ3JlIGluLCBzYXksIEFtZXJpY2EvTmV3X1lvcmtcbi8vIGFuZCBub3QganVzdCB0aGF0IHdlJ3JlIGluIC0yNDAgKnJpZ2h0IG5vdyouIEJ1dCBzaW5jZSBJIGRvbid0IHRoaW5rIHRoZXNlIGFyZSB1c2VkIHRoYXQgb2Z0ZW5cbi8vIEknbSBqdXN0IGdvaW5nIHRvIGlnbm9yZSB0aGF0XG5jb25zdCBvYnNPZmZzZXRzID0ge1xuICBHTVQ6IDAsXG4gIEVEVDogLTQgKiA2MCxcbiAgRVNUOiAtNSAqIDYwLFxuICBDRFQ6IC01ICogNjAsXG4gIENTVDogLTYgKiA2MCxcbiAgTURUOiAtNiAqIDYwLFxuICBNU1Q6IC03ICogNjAsXG4gIFBEVDogLTcgKiA2MCxcbiAgUFNUOiAtOCAqIDYwLFxufTtcblxuZnVuY3Rpb24gZnJvbVN0cmluZ3Mod2Vla2RheVN0ciwgeWVhclN0ciwgbW9udGhTdHIsIGRheVN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHIpIHtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIHllYXI6IHllYXJTdHIubGVuZ3RoID09PSAyID8gdW50cnVuY2F0ZVllYXIocGFyc2VJbnRlZ2VyKHllYXJTdHIpKSA6IHBhcnNlSW50ZWdlcih5ZWFyU3RyKSxcbiAgICBtb250aDogRW5nbGlzaC5tb250aHNTaG9ydC5pbmRleE9mKG1vbnRoU3RyKSArIDEsXG4gICAgZGF5OiBwYXJzZUludGVnZXIoZGF5U3RyKSxcbiAgICBob3VyOiBwYXJzZUludGVnZXIoaG91clN0ciksXG4gICAgbWludXRlOiBwYXJzZUludGVnZXIobWludXRlU3RyKSxcbiAgfTtcblxuICBpZiAoc2Vjb25kU3RyKSByZXN1bHQuc2Vjb25kID0gcGFyc2VJbnRlZ2VyKHNlY29uZFN0cik7XG4gIGlmICh3ZWVrZGF5U3RyKSB7XG4gICAgcmVzdWx0LndlZWtkYXkgPVxuICAgICAgd2Vla2RheVN0ci5sZW5ndGggPiAzXG4gICAgICAgID8gRW5nbGlzaC53ZWVrZGF5c0xvbmcuaW5kZXhPZih3ZWVrZGF5U3RyKSArIDFcbiAgICAgICAgOiBFbmdsaXNoLndlZWtkYXlzU2hvcnQuaW5kZXhPZih3ZWVrZGF5U3RyKSArIDE7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBSRkMgMjgyMi81MzIyXG5jb25zdCByZmMyODIyID1cbiAgL14oPzooTW9ufFR1ZXxXZWR8VGh1fEZyaXxTYXR8U3VuKSxcXHMpPyhcXGR7MSwyfSlcXHMoSmFufEZlYnxNYXJ8QXByfE1heXxKdW58SnVsfEF1Z3xTZXB8T2N0fE5vdnxEZWMpXFxzKFxcZHsyLDR9KVxccyhcXGRcXGQpOihcXGRcXGQpKD86OihcXGRcXGQpKT9cXHMoPzooVVR8R01UfFtFQ01QXVtTRF1UKXwoW1p6XSl8KD86KFsrLV1cXGRcXGQpKFxcZFxcZCkpKSQvO1xuXG5mdW5jdGlvbiBleHRyYWN0UkZDMjgyMihtYXRjaCkge1xuICBjb25zdCBbXG4gICAgICAsXG4gICAgICB3ZWVrZGF5U3RyLFxuICAgICAgZGF5U3RyLFxuICAgICAgbW9udGhTdHIsXG4gICAgICB5ZWFyU3RyLFxuICAgICAgaG91clN0cixcbiAgICAgIG1pbnV0ZVN0cixcbiAgICAgIHNlY29uZFN0cixcbiAgICAgIG9ic09mZnNldCxcbiAgICAgIG1pbE9mZnNldCxcbiAgICAgIG9mZkhvdXJTdHIsXG4gICAgICBvZmZNaW51dGVTdHIsXG4gICAgXSA9IG1hdGNoLFxuICAgIHJlc3VsdCA9IGZyb21TdHJpbmdzKHdlZWtkYXlTdHIsIHllYXJTdHIsIG1vbnRoU3RyLCBkYXlTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyKTtcblxuICBsZXQgb2Zmc2V0O1xuICBpZiAob2JzT2Zmc2V0KSB7XG4gICAgb2Zmc2V0ID0gb2JzT2Zmc2V0c1tvYnNPZmZzZXRdO1xuICB9IGVsc2UgaWYgKG1pbE9mZnNldCkge1xuICAgIG9mZnNldCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgb2Zmc2V0ID0gc2lnbmVkT2Zmc2V0KG9mZkhvdXJTdHIsIG9mZk1pbnV0ZVN0cik7XG4gIH1cblxuICByZXR1cm4gW3Jlc3VsdCwgbmV3IEZpeGVkT2Zmc2V0Wm9uZShvZmZzZXQpXTtcbn1cblxuZnVuY3Rpb24gcHJlcHJvY2Vzc1JGQzI4MjIocykge1xuICAvLyBSZW1vdmUgY29tbWVudHMgYW5kIGZvbGRpbmcgd2hpdGVzcGFjZSBhbmQgcmVwbGFjZSBtdWx0aXBsZS1zcGFjZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuICByZXR1cm4gc1xuICAgIC5yZXBsYWNlKC9cXChbXigpXSpcXCl8W1xcblxcdF0vZywgXCIgXCIpXG4gICAgLnJlcGxhY2UoLyhcXHNcXHMrKS9nLCBcIiBcIilcbiAgICAudHJpbSgpO1xufVxuXG4vLyBodHRwIGRhdGVcblxuY29uc3QgcmZjMTEyMyA9XG4gICAgL14oTW9ufFR1ZXxXZWR8VGh1fEZyaXxTYXR8U3VuKSwgKFxcZFxcZCkgKEphbnxGZWJ8TWFyfEFwcnxNYXl8SnVufEp1bHxBdWd8U2VwfE9jdHxOb3Z8RGVjKSAoXFxkezR9KSAoXFxkXFxkKTooXFxkXFxkKTooXFxkXFxkKSBHTVQkLyxcbiAgcmZjODUwID1cbiAgICAvXihNb25kYXl8VHVlc2RheXxXZWRuZXNkYXl8VGh1cnNkYXl8RnJpZGF5fFNhdHVyZGF5fFN1bmRheSksIChcXGRcXGQpLShKYW58RmVifE1hcnxBcHJ8TWF5fEp1bnxKdWx8QXVnfFNlcHxPY3R8Tm92fERlYyktKFxcZFxcZCkgKFxcZFxcZCk6KFxcZFxcZCk6KFxcZFxcZCkgR01UJC8sXG4gIGFzY2lpID1cbiAgICAvXihNb258VHVlfFdlZHxUaHV8RnJpfFNhdHxTdW4pIChKYW58RmVifE1hcnxBcHJ8TWF5fEp1bnxKdWx8QXVnfFNlcHxPY3R8Tm92fERlYykgKCBcXGR8XFxkXFxkKSAoXFxkXFxkKTooXFxkXFxkKTooXFxkXFxkKSAoXFxkezR9KSQvO1xuXG5mdW5jdGlvbiBleHRyYWN0UkZDMTEyM09yODUwKG1hdGNoKSB7XG4gIGNvbnN0IFssIHdlZWtkYXlTdHIsIGRheVN0ciwgbW9udGhTdHIsIHllYXJTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyXSA9IG1hdGNoLFxuICAgIHJlc3VsdCA9IGZyb21TdHJpbmdzKHdlZWtkYXlTdHIsIHllYXJTdHIsIG1vbnRoU3RyLCBkYXlTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyKTtcbiAgcmV0dXJuIFtyZXN1bHQsIEZpeGVkT2Zmc2V0Wm9uZS51dGNJbnN0YW5jZV07XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RBU0NJSShtYXRjaCkge1xuICBjb25zdCBbLCB3ZWVrZGF5U3RyLCBtb250aFN0ciwgZGF5U3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0ciwgeWVhclN0cl0gPSBtYXRjaCxcbiAgICByZXN1bHQgPSBmcm9tU3RyaW5ncyh3ZWVrZGF5U3RyLCB5ZWFyU3RyLCBtb250aFN0ciwgZGF5U3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0cik7XG4gIHJldHVybiBbcmVzdWx0LCBGaXhlZE9mZnNldFpvbmUudXRjSW5zdGFuY2VdO1xufVxuXG5jb25zdCBpc29ZbWRXaXRoVGltZUV4dGVuc2lvblJlZ2V4ID0gY29tYmluZVJlZ2V4ZXMoaXNvWW1kUmVnZXgsIGlzb1RpbWVFeHRlbnNpb25SZWdleCk7XG5jb25zdCBpc29XZWVrV2l0aFRpbWVFeHRlbnNpb25SZWdleCA9IGNvbWJpbmVSZWdleGVzKGlzb1dlZWtSZWdleCwgaXNvVGltZUV4dGVuc2lvblJlZ2V4KTtcbmNvbnN0IGlzb09yZGluYWxXaXRoVGltZUV4dGVuc2lvblJlZ2V4ID0gY29tYmluZVJlZ2V4ZXMoaXNvT3JkaW5hbFJlZ2V4LCBpc29UaW1lRXh0ZW5zaW9uUmVnZXgpO1xuY29uc3QgaXNvVGltZUNvbWJpbmVkUmVnZXggPSBjb21iaW5lUmVnZXhlcyhpc29UaW1lUmVnZXgpO1xuXG5jb25zdCBleHRyYWN0SVNPWW1kVGltZUFuZE9mZnNldCA9IGNvbWJpbmVFeHRyYWN0b3JzKFxuICBleHRyYWN0SVNPWW1kLFxuICBleHRyYWN0SVNPVGltZSxcbiAgZXh0cmFjdElTT09mZnNldCxcbiAgZXh0cmFjdElBTkFab25lXG4pO1xuY29uc3QgZXh0cmFjdElTT1dlZWtUaW1lQW5kT2Zmc2V0ID0gY29tYmluZUV4dHJhY3RvcnMoXG4gIGV4dHJhY3RJU09XZWVrRGF0YSxcbiAgZXh0cmFjdElTT1RpbWUsXG4gIGV4dHJhY3RJU09PZmZzZXQsXG4gIGV4dHJhY3RJQU5BWm9uZVxuKTtcbmNvbnN0IGV4dHJhY3RJU09PcmRpbmFsRGF0ZUFuZFRpbWUgPSBjb21iaW5lRXh0cmFjdG9ycyhcbiAgZXh0cmFjdElTT09yZGluYWxEYXRhLFxuICBleHRyYWN0SVNPVGltZSxcbiAgZXh0cmFjdElTT09mZnNldCxcbiAgZXh0cmFjdElBTkFab25lXG4pO1xuY29uc3QgZXh0cmFjdElTT1RpbWVBbmRPZmZzZXQgPSBjb21iaW5lRXh0cmFjdG9ycyhcbiAgZXh0cmFjdElTT1RpbWUsXG4gIGV4dHJhY3RJU09PZmZzZXQsXG4gIGV4dHJhY3RJQU5BWm9uZVxuKTtcblxuLypcbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSVNPRGF0ZShzKSB7XG4gIHJldHVybiBwYXJzZShcbiAgICBzLFxuICAgIFtpc29ZbWRXaXRoVGltZUV4dGVuc2lvblJlZ2V4LCBleHRyYWN0SVNPWW1kVGltZUFuZE9mZnNldF0sXG4gICAgW2lzb1dlZWtXaXRoVGltZUV4dGVuc2lvblJlZ2V4LCBleHRyYWN0SVNPV2Vla1RpbWVBbmRPZmZzZXRdLFxuICAgIFtpc29PcmRpbmFsV2l0aFRpbWVFeHRlbnNpb25SZWdleCwgZXh0cmFjdElTT09yZGluYWxEYXRlQW5kVGltZV0sXG4gICAgW2lzb1RpbWVDb21iaW5lZFJlZ2V4LCBleHRyYWN0SVNPVGltZUFuZE9mZnNldF1cbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUkZDMjgyMkRhdGUocykge1xuICByZXR1cm4gcGFyc2UocHJlcHJvY2Vzc1JGQzI4MjIocyksIFtyZmMyODIyLCBleHRyYWN0UkZDMjgyMl0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VIVFRQRGF0ZShzKSB7XG4gIHJldHVybiBwYXJzZShcbiAgICBzLFxuICAgIFtyZmMxMTIzLCBleHRyYWN0UkZDMTEyM09yODUwXSxcbiAgICBbcmZjODUwLCBleHRyYWN0UkZDMTEyM09yODUwXSxcbiAgICBbYXNjaWksIGV4dHJhY3RBU0NJSV1cbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSVNPRHVyYXRpb24ocykge1xuICByZXR1cm4gcGFyc2UocywgW2lzb0R1cmF0aW9uLCBleHRyYWN0SVNPRHVyYXRpb25dKTtcbn1cblxuY29uc3QgZXh0cmFjdElTT1RpbWVPbmx5ID0gY29tYmluZUV4dHJhY3RvcnMoZXh0cmFjdElTT1RpbWUpO1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VJU09UaW1lT25seShzKSB7XG4gIHJldHVybiBwYXJzZShzLCBbaXNvVGltZU9ubHksIGV4dHJhY3RJU09UaW1lT25seV0pO1xufVxuXG5jb25zdCBzcWxZbWRXaXRoVGltZUV4dGVuc2lvblJlZ2V4ID0gY29tYmluZVJlZ2V4ZXMoc3FsWW1kUmVnZXgsIHNxbFRpbWVFeHRlbnNpb25SZWdleCk7XG5jb25zdCBzcWxUaW1lQ29tYmluZWRSZWdleCA9IGNvbWJpbmVSZWdleGVzKHNxbFRpbWVSZWdleCk7XG5cbmNvbnN0IGV4dHJhY3RJU09UaW1lT2Zmc2V0QW5kSUFOQVpvbmUgPSBjb21iaW5lRXh0cmFjdG9ycyhcbiAgZXh0cmFjdElTT1RpbWUsXG4gIGV4dHJhY3RJU09PZmZzZXQsXG4gIGV4dHJhY3RJQU5BWm9uZVxuKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU1FMKHMpIHtcbiAgcmV0dXJuIHBhcnNlKFxuICAgIHMsXG4gICAgW3NxbFltZFdpdGhUaW1lRXh0ZW5zaW9uUmVnZXgsIGV4dHJhY3RJU09ZbWRUaW1lQW5kT2Zmc2V0XSxcbiAgICBbc3FsVGltZUNvbWJpbmVkUmVnZXgsIGV4dHJhY3RJU09UaW1lT2Zmc2V0QW5kSUFOQVpvbmVdXG4gICk7XG59XG4iLCAiaW1wb3J0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IsIEludmFsaWREdXJhdGlvbkVycm9yLCBJbnZhbGlkVW5pdEVycm9yIH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgRm9ybWF0dGVyIGZyb20gXCIuL2ltcGwvZm9ybWF0dGVyLmpzXCI7XG5pbXBvcnQgSW52YWxpZCBmcm9tIFwiLi9pbXBsL2ludmFsaWQuanNcIjtcbmltcG9ydCBMb2NhbGUgZnJvbSBcIi4vaW1wbC9sb2NhbGUuanNcIjtcbmltcG9ydCB7IHBhcnNlSVNPRHVyYXRpb24sIHBhcnNlSVNPVGltZU9ubHkgfSBmcm9tIFwiLi9pbXBsL3JlZ2V4UGFyc2VyLmpzXCI7XG5pbXBvcnQge1xuICBhc051bWJlcixcbiAgaGFzT3duUHJvcGVydHksXG4gIGlzTnVtYmVyLFxuICBpc1VuZGVmaW5lZCxcbiAgbm9ybWFsaXplT2JqZWN0LFxuICByb3VuZFRvLFxufSBmcm9tIFwiLi9pbXBsL3V0aWwuanNcIjtcbmltcG9ydCBTZXR0aW5ncyBmcm9tIFwiLi9zZXR0aW5ncy5qc1wiO1xuaW1wb3J0IERhdGVUaW1lIGZyb20gXCIuL2RhdGV0aW1lLmpzXCI7XG5cbmNvbnN0IElOVkFMSUQgPSBcIkludmFsaWQgRHVyYXRpb25cIjtcblxuLy8gdW5pdCBjb252ZXJzaW9uIGNvbnN0YW50c1xuZXhwb3J0IGNvbnN0IGxvd09yZGVyTWF0cml4ID0ge1xuICAgIHdlZWtzOiB7XG4gICAgICBkYXlzOiA3LFxuICAgICAgaG91cnM6IDcgKiAyNCxcbiAgICAgIG1pbnV0ZXM6IDcgKiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogNyAqIDI0ICogNjAgKiA2MCxcbiAgICAgIG1pbGxpc2Vjb25kczogNyAqIDI0ICogNjAgKiA2MCAqIDEwMDAsXG4gICAgfSxcbiAgICBkYXlzOiB7XG4gICAgICBob3VyczogMjQsXG4gICAgICBtaW51dGVzOiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogMjQgKiA2MCAqIDYwLFxuICAgICAgbWlsbGlzZWNvbmRzOiAyNCAqIDYwICogNjAgKiAxMDAwLFxuICAgIH0sXG4gICAgaG91cnM6IHsgbWludXRlczogNjAsIHNlY29uZHM6IDYwICogNjAsIG1pbGxpc2Vjb25kczogNjAgKiA2MCAqIDEwMDAgfSxcbiAgICBtaW51dGVzOiB7IHNlY29uZHM6IDYwLCBtaWxsaXNlY29uZHM6IDYwICogMTAwMCB9LFxuICAgIHNlY29uZHM6IHsgbWlsbGlzZWNvbmRzOiAxMDAwIH0sXG4gIH0sXG4gIGNhc3VhbE1hdHJpeCA9IHtcbiAgICB5ZWFyczoge1xuICAgICAgcXVhcnRlcnM6IDQsXG4gICAgICBtb250aHM6IDEyLFxuICAgICAgd2Vla3M6IDUyLFxuICAgICAgZGF5czogMzY1LFxuICAgICAgaG91cnM6IDM2NSAqIDI0LFxuICAgICAgbWludXRlczogMzY1ICogMjQgKiA2MCxcbiAgICAgIHNlY29uZHM6IDM2NSAqIDI0ICogNjAgKiA2MCxcbiAgICAgIG1pbGxpc2Vjb25kczogMzY1ICogMjQgKiA2MCAqIDYwICogMTAwMCxcbiAgICB9LFxuICAgIHF1YXJ0ZXJzOiB7XG4gICAgICBtb250aHM6IDMsXG4gICAgICB3ZWVrczogMTMsXG4gICAgICBkYXlzOiA5MSxcbiAgICAgIGhvdXJzOiA5MSAqIDI0LFxuICAgICAgbWludXRlczogOTEgKiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogOTEgKiAyNCAqIDYwICogNjAsXG4gICAgICBtaWxsaXNlY29uZHM6IDkxICogMjQgKiA2MCAqIDYwICogMTAwMCxcbiAgICB9LFxuICAgIG1vbnRoczoge1xuICAgICAgd2Vla3M6IDQsXG4gICAgICBkYXlzOiAzMCxcbiAgICAgIGhvdXJzOiAzMCAqIDI0LFxuICAgICAgbWludXRlczogMzAgKiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogMzAgKiAyNCAqIDYwICogNjAsXG4gICAgICBtaWxsaXNlY29uZHM6IDMwICogMjQgKiA2MCAqIDYwICogMTAwMCxcbiAgICB9LFxuXG4gICAgLi4ubG93T3JkZXJNYXRyaXgsXG4gIH0sXG4gIGRheXNJblllYXJBY2N1cmF0ZSA9IDE0NjA5Ny4wIC8gNDAwLFxuICBkYXlzSW5Nb250aEFjY3VyYXRlID0gMTQ2MDk3LjAgLyA0ODAwLFxuICBhY2N1cmF0ZU1hdHJpeCA9IHtcbiAgICB5ZWFyczoge1xuICAgICAgcXVhcnRlcnM6IDQsXG4gICAgICBtb250aHM6IDEyLFxuICAgICAgd2Vla3M6IGRheXNJblllYXJBY2N1cmF0ZSAvIDcsXG4gICAgICBkYXlzOiBkYXlzSW5ZZWFyQWNjdXJhdGUsXG4gICAgICBob3VyczogZGF5c0luWWVhckFjY3VyYXRlICogMjQsXG4gICAgICBtaW51dGVzOiBkYXlzSW5ZZWFyQWNjdXJhdGUgKiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogZGF5c0luWWVhckFjY3VyYXRlICogMjQgKiA2MCAqIDYwLFxuICAgICAgbWlsbGlzZWNvbmRzOiBkYXlzSW5ZZWFyQWNjdXJhdGUgKiAyNCAqIDYwICogNjAgKiAxMDAwLFxuICAgIH0sXG4gICAgcXVhcnRlcnM6IHtcbiAgICAgIG1vbnRoczogMyxcbiAgICAgIHdlZWtzOiBkYXlzSW5ZZWFyQWNjdXJhdGUgLyAyOCxcbiAgICAgIGRheXM6IGRheXNJblllYXJBY2N1cmF0ZSAvIDQsXG4gICAgICBob3VyczogKGRheXNJblllYXJBY2N1cmF0ZSAqIDI0KSAvIDQsXG4gICAgICBtaW51dGVzOiAoZGF5c0luWWVhckFjY3VyYXRlICogMjQgKiA2MCkgLyA0LFxuICAgICAgc2Vjb25kczogKGRheXNJblllYXJBY2N1cmF0ZSAqIDI0ICogNjAgKiA2MCkgLyA0LFxuICAgICAgbWlsbGlzZWNvbmRzOiAoZGF5c0luWWVhckFjY3VyYXRlICogMjQgKiA2MCAqIDYwICogMTAwMCkgLyA0LFxuICAgIH0sXG4gICAgbW9udGhzOiB7XG4gICAgICB3ZWVrczogZGF5c0luTW9udGhBY2N1cmF0ZSAvIDcsXG4gICAgICBkYXlzOiBkYXlzSW5Nb250aEFjY3VyYXRlLFxuICAgICAgaG91cnM6IGRheXNJbk1vbnRoQWNjdXJhdGUgKiAyNCxcbiAgICAgIG1pbnV0ZXM6IGRheXNJbk1vbnRoQWNjdXJhdGUgKiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogZGF5c0luTW9udGhBY2N1cmF0ZSAqIDI0ICogNjAgKiA2MCxcbiAgICAgIG1pbGxpc2Vjb25kczogZGF5c0luTW9udGhBY2N1cmF0ZSAqIDI0ICogNjAgKiA2MCAqIDEwMDAsXG4gICAgfSxcbiAgICAuLi5sb3dPcmRlck1hdHJpeCxcbiAgfTtcblxuLy8gdW5pdHMgb3JkZXJlZCBieSBzaXplXG5jb25zdCBvcmRlcmVkVW5pdHMgPSBbXG4gIFwieWVhcnNcIixcbiAgXCJxdWFydGVyc1wiLFxuICBcIm1vbnRoc1wiLFxuICBcIndlZWtzXCIsXG4gIFwiZGF5c1wiLFxuICBcImhvdXJzXCIsXG4gIFwibWludXRlc1wiLFxuICBcInNlY29uZHNcIixcbiAgXCJtaWxsaXNlY29uZHNcIixcbl07XG5cbmNvbnN0IHJldmVyc2VVbml0cyA9IG9yZGVyZWRVbml0cy5zbGljZSgwKS5yZXZlcnNlKCk7XG5cbi8vIGNsb25lIHJlYWxseSBtZWFucyBcImNyZWF0ZSBhbm90aGVyIGluc3RhbmNlIGp1c3QgbGlrZSB0aGlzIG9uZSwgYnV0IHdpdGggdGhlc2UgY2hhbmdlc1wiXG5mdW5jdGlvbiBjbG9uZShkdXIsIGFsdHMsIGNsZWFyID0gZmFsc2UpIHtcbiAgLy8gZGVlcCBtZXJnZSBmb3IgdmFsc1xuICBjb25zdCBjb25mID0ge1xuICAgIHZhbHVlczogY2xlYXIgPyBhbHRzLnZhbHVlcyA6IHsgLi4uZHVyLnZhbHVlcywgLi4uKGFsdHMudmFsdWVzIHx8IHt9KSB9LFxuICAgIGxvYzogZHVyLmxvYy5jbG9uZShhbHRzLmxvYyksXG4gICAgY29udmVyc2lvbkFjY3VyYWN5OiBhbHRzLmNvbnZlcnNpb25BY2N1cmFjeSB8fCBkdXIuY29udmVyc2lvbkFjY3VyYWN5LFxuICAgIG1hdHJpeDogYWx0cy5tYXRyaXggfHwgZHVyLm1hdHJpeCxcbiAgfTtcbiAgcmV0dXJuIG5ldyBEdXJhdGlvbihjb25mKTtcbn1cblxuZnVuY3Rpb24gZHVyYXRpb25Ub01pbGxpcyhtYXRyaXgsIHZhbHMpIHtcbiAgbGV0IHN1bSA9IHZhbHMubWlsbGlzZWNvbmRzID8/IDA7XG4gIGZvciAoY29uc3QgdW5pdCBvZiByZXZlcnNlVW5pdHMuc2xpY2UoMSkpIHtcbiAgICBpZiAodmFsc1t1bml0XSkge1xuICAgICAgc3VtICs9IHZhbHNbdW5pdF0gKiBtYXRyaXhbdW5pdF1bXCJtaWxsaXNlY29uZHNcIl07XG4gICAgfVxuICB9XG4gIHJldHVybiBzdW07XG59XG5cbi8vIE5COiBtdXRhdGVzIHBhcmFtZXRlcnNcbmZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlcyhtYXRyaXgsIHZhbHMpIHtcbiAgLy8gdGhlIGxvZ2ljIGJlbG93IGFzc3VtZXMgdGhlIG92ZXJhbGwgdmFsdWUgb2YgdGhlIGR1cmF0aW9uIGlzIHBvc2l0aXZlXG4gIC8vIGlmIHRoaXMgaXMgbm90IHRoZSBjYXNlLCBmYWN0b3IgaXMgdXNlZCB0byBtYWtlIGl0IHNvXG4gIGNvbnN0IGZhY3RvciA9IGR1cmF0aW9uVG9NaWxsaXMobWF0cml4LCB2YWxzKSA8IDAgPyAtMSA6IDE7XG5cbiAgb3JkZXJlZFVuaXRzLnJlZHVjZVJpZ2h0KChwcmV2aW91cywgY3VycmVudCkgPT4ge1xuICAgIGlmICghaXNVbmRlZmluZWQodmFsc1tjdXJyZW50XSkpIHtcbiAgICAgIGlmIChwcmV2aW91cykge1xuICAgICAgICBjb25zdCBwcmV2aW91c1ZhbCA9IHZhbHNbcHJldmlvdXNdICogZmFjdG9yO1xuICAgICAgICBjb25zdCBjb252ID0gbWF0cml4W2N1cnJlbnRdW3ByZXZpb3VzXTtcblxuICAgICAgICAvLyBpZiAocHJldmlvdXNWYWwgPCAwKTpcbiAgICAgICAgLy8gbG93ZXIgb3JkZXIgdW5pdCBpcyBuZWdhdGl2ZSAoZS5nLiB7IHllYXJzOiAyLCBkYXlzOiAtMiB9KVxuICAgICAgICAvLyBub3JtYWxpemUgdGhpcyBieSByZWR1Y2luZyB0aGUgaGlnaGVyIG9yZGVyIHVuaXQgYnkgdGhlIGFwcHJvcHJpYXRlIGFtb3VudFxuICAgICAgICAvLyBhbmQgaW5jcmVhc2luZyB0aGUgbG93ZXIgb3JkZXIgdW5pdFxuICAgICAgICAvLyB0aGlzIGNhbiBuZXZlciBtYWtlIHRoZSBoaWdoZXIgb3JkZXIgdW5pdCBuZWdhdGl2ZSwgYmVjYXVzZSB0aGlzIGZ1bmN0aW9uIG9ubHkgb3BlcmF0ZXNcbiAgICAgICAgLy8gb24gcG9zaXRpdmUgZHVyYXRpb25zLCBzbyB0aGUgYW1vdW50IG9mIHRpbWUgcmVwcmVzZW50ZWQgYnkgdGhlIGxvd2VyIG9yZGVyIHVuaXQgY2Fubm90XG4gICAgICAgIC8vIGJlIGxhcmdlciB0aGFuIHRoZSBoaWdoZXIgb3JkZXIgdW5pdFxuICAgICAgICAvLyBlbHNlOlxuICAgICAgICAvLyBsb3dlciBvcmRlciB1bml0IGlzIHBvc2l0aXZlIChlLmcuIHsgeWVhcnM6IDIsIGRheXM6IDQ1MCB9IG9yIHsgeWVhcnM6IC0yLCBkYXlzOiA0NTAgfSlcbiAgICAgICAgLy8gaW4gdGhpcyBjYXNlIHdlIGF0dGVtcHQgdG8gY29udmVydCBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIGxvd2VyIG9yZGVyIHVuaXQgaW50b1xuICAgICAgICAvLyB0aGUgaGlnaGVyIG9yZGVyIG9uZVxuICAgICAgICAvL1xuICAgICAgICAvLyBNYXRoLmZsb29yIHRha2VzIGNhcmUgb2YgYm90aCBvZiB0aGVzZSBjYXNlcywgcm91bmRpbmcgYXdheSBmcm9tIDBcbiAgICAgICAgLy8gaWYgcHJldmlvdXNWYWwgPCAwIGl0IG1ha2VzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBsYXJnZXJcbiAgICAgICAgLy8gaWYgcHJldmlvdXNWYWwgPj0gaXQgbWFrZXMgdGhlIGFic29sdXRlIHZhbHVlIHNtYWxsZXJcbiAgICAgICAgY29uc3Qgcm9sbFVwID0gTWF0aC5mbG9vcihwcmV2aW91c1ZhbCAvIGNvbnYpO1xuICAgICAgICB2YWxzW2N1cnJlbnRdICs9IHJvbGxVcCAqIGZhY3RvcjtcbiAgICAgICAgdmFsc1twcmV2aW91c10gLT0gcm9sbFVwICogY29udiAqIGZhY3RvcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcHJldmlvdXM7XG4gICAgfVxuICB9LCBudWxsKTtcblxuICAvLyB0cnkgdG8gY29udmVydCBhbnkgZGVjaW1hbHMgaW50byBzbWFsbGVyIHVuaXRzIGlmIHBvc3NpYmxlXG4gIC8vIGZvciBleGFtcGxlIGZvciB7IHllYXJzOiAyLjUsIGRheXM6IDAsIHNlY29uZHM6IDAgfSB3ZSB3YW50IHRvIGdldCB7IHllYXJzOiAyLCBkYXlzOiAxODIsIGhvdXJzOiAxMiB9XG4gIG9yZGVyZWRVbml0cy5yZWR1Y2UoKHByZXZpb3VzLCBjdXJyZW50KSA9PiB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh2YWxzW2N1cnJlbnRdKSkge1xuICAgICAgaWYgKHByZXZpb3VzKSB7XG4gICAgICAgIGNvbnN0IGZyYWN0aW9uID0gdmFsc1twcmV2aW91c10gJSAxO1xuICAgICAgICB2YWxzW3ByZXZpb3VzXSAtPSBmcmFjdGlvbjtcbiAgICAgICAgdmFsc1tjdXJyZW50XSArPSBmcmFjdGlvbiAqIG1hdHJpeFtwcmV2aW91c11bY3VycmVudF07XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHByZXZpb3VzO1xuICAgIH1cbiAgfSwgbnVsbCk7XG59XG5cbi8vIFJlbW92ZSBhbGwgcHJvcGVydGllcyB3aXRoIGEgdmFsdWUgb2YgMCBmcm9tIGFuIG9iamVjdFxuZnVuY3Rpb24gcmVtb3ZlWmVyb2VzKHZhbHMpIHtcbiAgY29uc3QgbmV3VmFscyA9IHt9O1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh2YWxzKSkge1xuICAgIGlmICh2YWx1ZSAhPT0gMCkge1xuICAgICAgbmV3VmFsc1trZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXdWYWxzO1xufVxuXG4vKipcbiAqIEEgRHVyYXRpb24gb2JqZWN0IHJlcHJlc2VudHMgYSBwZXJpb2Qgb2YgdGltZSwgbGlrZSBcIjIgbW9udGhzXCIgb3IgXCIxIGRheSwgMSBob3VyXCIuIENvbmNlcHR1YWxseSwgaXQncyBqdXN0IGEgbWFwIG9mIHVuaXRzIHRvIHRoZWlyIHF1YW50aXRpZXMsIGFjY29tcGFuaWVkIGJ5IHNvbWUgYWRkaXRpb25hbCBjb25maWd1cmF0aW9uIGFuZCBtZXRob2RzIGZvciBjcmVhdGluZywgcGFyc2luZywgaW50ZXJyb2dhdGluZywgdHJhbnNmb3JtaW5nLCBhbmQgZm9ybWF0dGluZyB0aGVtLiBUaGV5IGNhbiBiZSB1c2VkIG9uIHRoZWlyIG93biBvciBpbiBjb25qdW5jdGlvbiB3aXRoIG90aGVyIEx1eG9uIHR5cGVzOyBmb3IgZXhhbXBsZSwgeW91IGNhbiB1c2Uge0BsaW5rIERhdGVUaW1lI3BsdXN9IHRvIGFkZCBhIER1cmF0aW9uIG9iamVjdCB0byBhIERhdGVUaW1lLCBwcm9kdWNpbmcgYW5vdGhlciBEYXRlVGltZS5cbiAqXG4gKiBIZXJlIGlzIGEgYnJpZWYgb3ZlcnZpZXcgb2YgY29tbW9ubHkgdXNlZCBtZXRob2RzIGFuZCBnZXR0ZXJzIGluIER1cmF0aW9uOlxuICpcbiAqICogKipDcmVhdGlvbioqIFRvIGNyZWF0ZSBhIER1cmF0aW9uLCB1c2Uge0BsaW5rIER1cmF0aW9uLmZyb21NaWxsaXN9LCB7QGxpbmsgRHVyYXRpb24uZnJvbU9iamVjdH0sIG9yIHtAbGluayBEdXJhdGlvbi5mcm9tSVNPfS5cbiAqICogKipVbml0IHZhbHVlcyoqIFNlZSB0aGUge0BsaW5rIER1cmF0aW9uI3llYXJzfSwge0BsaW5rIER1cmF0aW9uI21vbnRoc30sIHtAbGluayBEdXJhdGlvbiN3ZWVrc30sIHtAbGluayBEdXJhdGlvbiNkYXlzfSwge0BsaW5rIER1cmF0aW9uI2hvdXJzfSwge0BsaW5rIER1cmF0aW9uI21pbnV0ZXN9LCB7QGxpbmsgRHVyYXRpb24jc2Vjb25kc30sIHtAbGluayBEdXJhdGlvbiNtaWxsaXNlY29uZHN9IGFjY2Vzc29ycy5cbiAqICogKipDb25maWd1cmF0aW9uKiogU2VlICB7QGxpbmsgRHVyYXRpb24jbG9jYWxlfSBhbmQge0BsaW5rIER1cmF0aW9uI251bWJlcmluZ1N5c3RlbX0gYWNjZXNzb3JzLlxuICogKiAqKlRyYW5zZm9ybWF0aW9uKiogVG8gY3JlYXRlIG5ldyBEdXJhdGlvbnMgb3V0IG9mIG9sZCBvbmVzIHVzZSB7QGxpbmsgRHVyYXRpb24jcGx1c30sIHtAbGluayBEdXJhdGlvbiNtaW51c30sIHtAbGluayBEdXJhdGlvbiNub3JtYWxpemV9LCB7QGxpbmsgRHVyYXRpb24jc2V0fSwge0BsaW5rIER1cmF0aW9uI3JlY29uZmlndXJlfSwge0BsaW5rIER1cmF0aW9uI3NoaWZ0VG99LCBhbmQge0BsaW5rIER1cmF0aW9uI25lZ2F0ZX0uXG4gKiAqICoqT3V0cHV0KiogVG8gY29udmVydCB0aGUgRHVyYXRpb24gaW50byBvdGhlciByZXByZXNlbnRhdGlvbnMsIHNlZSB7QGxpbmsgRHVyYXRpb24jYXN9LCB7QGxpbmsgRHVyYXRpb24jdG9JU099LCB7QGxpbmsgRHVyYXRpb24jdG9Gb3JtYXR9LCBhbmQge0BsaW5rIER1cmF0aW9uI3RvSlNPTn1cbiAqXG4gKiBUaGVyZSdzIGFyZSBtb3JlIG1ldGhvZHMgZG9jdW1lbnRlZCBiZWxvdy4gSW4gYWRkaXRpb24sIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHN1YnRsZXIgdG9waWNzIGxpa2UgaW50ZXJuYXRpb25hbGl6YXRpb24gYW5kIHZhbGlkaXR5LCBzZWUgdGhlIGV4dGVybmFsIGRvY3VtZW50YXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIER1cmF0aW9uIHtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBjb25zdCBhY2N1cmF0ZSA9IGNvbmZpZy5jb252ZXJzaW9uQWNjdXJhY3kgPT09IFwibG9uZ3Rlcm1cIiB8fCBmYWxzZTtcbiAgICBsZXQgbWF0cml4ID0gYWNjdXJhdGUgPyBhY2N1cmF0ZU1hdHJpeCA6IGNhc3VhbE1hdHJpeDtcblxuICAgIGlmIChjb25maWcubWF0cml4KSB7XG4gICAgICBtYXRyaXggPSBjb25maWcubWF0cml4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudmFsdWVzID0gY29uZmlnLnZhbHVlcztcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmxvYyA9IGNvbmZpZy5sb2MgfHwgTG9jYWxlLmNyZWF0ZSgpO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuY29udmVyc2lvbkFjY3VyYWN5ID0gYWNjdXJhdGUgPyBcImxvbmd0ZXJtXCIgOiBcImNhc3VhbFwiO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaW52YWxpZCA9IGNvbmZpZy5pbnZhbGlkIHx8IG51bGw7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5tYXRyaXggPSBtYXRyaXg7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5pc0x1eG9uRHVyYXRpb24gPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBEdXJhdGlvbiBmcm9tIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IG9mIG1pbGxpc2Vjb25kc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgZm9yIHBhcnNpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nZW4tVVMnXSAtIHRoZSBsb2NhbGUgdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29udmVyc2lvbkFjY3VyYWN5PSdjYXN1YWwnXSAtIHRoZSBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzdGF0aWMgZnJvbU1pbGxpcyhjb3VudCwgb3B0cykge1xuICAgIHJldHVybiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbWlsbGlzZWNvbmRzOiBjb3VudCB9LCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEdXJhdGlvbiBmcm9tIGEgSmF2YVNjcmlwdCBvYmplY3Qgd2l0aCBrZXlzIGxpa2UgJ3llYXJzJyBhbmQgJ2hvdXJzJy5cbiAgICogSWYgdGhpcyBvYmplY3QgaXMgZW1wdHkgdGhlbiBhIHplcm8gbWlsbGlzZWNvbmRzIGR1cmF0aW9uIGlzIHJldHVybmVkLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gdGhlIG9iamVjdCB0byBjcmVhdGUgdGhlIERhdGVUaW1lIGZyb21cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai55ZWFyc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLnF1YXJ0ZXJzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoubW9udGhzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoud2Vla3NcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5kYXlzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmouaG91cnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5taW51dGVzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmouc2Vjb25kc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLm1pbGxpc2Vjb25kc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHM9W11dIC0gb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGhpcyBEdXJhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdlbi1VUyddIC0gdGhlIGxvY2FsZSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5jb252ZXJzaW9uQWNjdXJhY3k9J2Nhc3VhbCddIC0gdGhlIHByZXNldCBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm1hdHJpeD1PYmplY3RdIC0gdGhlIGN1c3RvbSBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzdGF0aWMgZnJvbU9iamVjdChvYmosIG9wdHMgPSB7fSkge1xuICAgIGlmIChvYmogPT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXG4gICAgICAgIGBEdXJhdGlvbi5mcm9tT2JqZWN0OiBhcmd1bWVudCBleHBlY3RlZCB0byBiZSBhbiBvYmplY3QsIGdvdCAke1xuICAgICAgICAgIG9iaiA9PT0gbnVsbCA/IFwibnVsbFwiIDogdHlwZW9mIG9ialxuICAgICAgICB9YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IER1cmF0aW9uKHtcbiAgICAgIHZhbHVlczogbm9ybWFsaXplT2JqZWN0KG9iaiwgRHVyYXRpb24ubm9ybWFsaXplVW5pdCksXG4gICAgICBsb2M6IExvY2FsZS5mcm9tT2JqZWN0KG9wdHMpLFxuICAgICAgY29udmVyc2lvbkFjY3VyYWN5OiBvcHRzLmNvbnZlcnNpb25BY2N1cmFjeSxcbiAgICAgIG1hdHJpeDogb3B0cy5tYXRyaXgsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRHVyYXRpb24gZnJvbSBEdXJhdGlvbkxpa2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0IHwgbnVtYmVyIHwgRHVyYXRpb259IGR1cmF0aW9uTGlrZVxuICAgKiBPbmUgb2Y6XG4gICAqIC0gb2JqZWN0IHdpdGgga2V5cyBsaWtlICd5ZWFycycgYW5kICdob3VycycuXG4gICAqIC0gbnVtYmVyIHJlcHJlc2VudGluZyBtaWxsaXNlY29uZHNcbiAgICogLSBEdXJhdGlvbiBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHN0YXRpYyBmcm9tRHVyYXRpb25MaWtlKGR1cmF0aW9uTGlrZSkge1xuICAgIGlmIChpc051bWJlcihkdXJhdGlvbkxpa2UpKSB7XG4gICAgICByZXR1cm4gRHVyYXRpb24uZnJvbU1pbGxpcyhkdXJhdGlvbkxpa2UpO1xuICAgIH0gZWxzZSBpZiAoRHVyYXRpb24uaXNEdXJhdGlvbihkdXJhdGlvbkxpa2UpKSB7XG4gICAgICByZXR1cm4gZHVyYXRpb25MaWtlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGR1cmF0aW9uTGlrZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmZyb21PYmplY3QoZHVyYXRpb25MaWtlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFxuICAgICAgICBgVW5rbm93biBkdXJhdGlvbiBhcmd1bWVudCAke2R1cmF0aW9uTGlrZX0gb2YgdHlwZSAke3R5cGVvZiBkdXJhdGlvbkxpa2V9YFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRHVyYXRpb24gZnJvbSBhbiBJU08gODYwMSBkdXJhdGlvbiBzdHJpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGV4dCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgZm9yIHBhcnNpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nZW4tVVMnXSAtIHRoZSBsb2NhbGUgdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29udmVyc2lvbkFjY3VyYWN5PSdjYXN1YWwnXSAtIHRoZSBwcmVzZXQgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5tYXRyaXg9T2JqZWN0XSAtIHRoZSBwcmVzZXQgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjRHVyYXRpb25zXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU08oJ1AzWTZNMVc0RFQxMkgzME01UycpLnRvT2JqZWN0KCkgLy89PiB7IHllYXJzOiAzLCBtb250aHM6IDYsIHdlZWtzOiAxLCBkYXlzOiA0LCBob3VyczogMTIsIG1pbnV0ZXM6IDMwLCBzZWNvbmRzOiA1IH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTTygnUFQyM0gnKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMjMgfVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tSVNPKCdQNVkzTScpLnRvT2JqZWN0KCkgLy89PiB7IHllYXJzOiA1LCBtb250aHM6IDMgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHN0YXRpYyBmcm9tSVNPKHRleHQsIG9wdHMpIHtcbiAgICBjb25zdCBbcGFyc2VkXSA9IHBhcnNlSVNPRHVyYXRpb24odGV4dCk7XG4gICAgaWYgKHBhcnNlZCkge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmZyb21PYmplY3QocGFyc2VkLCBvcHRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmludmFsaWQoXCJ1bnBhcnNhYmxlXCIsIGB0aGUgaW5wdXQgXCIke3RleHR9XCIgY2FuJ3QgYmUgcGFyc2VkIGFzIElTTyA4NjAxYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIER1cmF0aW9uIGZyb20gYW4gSVNPIDg2MDEgdGltZSBzdHJpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGV4dCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgZm9yIHBhcnNpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nZW4tVVMnXSAtIHRoZSBsb2NhbGUgdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29udmVyc2lvbkFjY3VyYWN5PSdjYXN1YWwnXSAtIHRoZSBwcmVzZXQgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5tYXRyaXg9T2JqZWN0XSAtIHRoZSBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSNUaW1lc1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tSVNPVGltZSgnMTE6MjI6MzMuNDQ0JykudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDExLCBtaW51dGVzOiAyMiwgc2Vjb25kczogMzMsIG1pbGxpc2Vjb25kczogNDQ0IH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTT1RpbWUoJzExOjAwJykudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDExLCBtaW51dGVzOiAwLCBzZWNvbmRzOiAwIH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTT1RpbWUoJ1QxMTowMCcpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMSwgbWludXRlczogMCwgc2Vjb25kczogMCB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU09UaW1lKCcxMTAwJykudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDExLCBtaW51dGVzOiAwLCBzZWNvbmRzOiAwIH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTT1RpbWUoJ1QxMTAwJykudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDExLCBtaW51dGVzOiAwLCBzZWNvbmRzOiAwIH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzdGF0aWMgZnJvbUlTT1RpbWUodGV4dCwgb3B0cykge1xuICAgIGNvbnN0IFtwYXJzZWRdID0gcGFyc2VJU09UaW1lT25seSh0ZXh0KTtcbiAgICBpZiAocGFyc2VkKSB7XG4gICAgICByZXR1cm4gRHVyYXRpb24uZnJvbU9iamVjdChwYXJzZWQsIG9wdHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gRHVyYXRpb24uaW52YWxpZChcInVucGFyc2FibGVcIiwgYHRoZSBpbnB1dCBcIiR7dGV4dH1cIiBjYW4ndCBiZSBwYXJzZWQgYXMgSVNPIDg2MDFgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGludmFsaWQgRHVyYXRpb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb24gLSBzaW1wbGUgc3RyaW5nIG9mIHdoeSB0aGlzIGRhdGV0aW1lIGlzIGludmFsaWQuIFNob3VsZCBub3QgY29udGFpbiBwYXJhbWV0ZXJzIG9yIGFueXRoaW5nIGVsc2UgZGF0YS1kZXBlbmRlbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtleHBsYW5hdGlvbj1udWxsXSAtIGxvbmdlciBleHBsYW5hdGlvbiwgbWF5IGluY2x1ZGUgcGFyYW1ldGVycyBhbmQgb3RoZXIgdXNlZnVsIGRlYnVnZ2luZyBpbmZvcm1hdGlvblxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHN0YXRpYyBpbnZhbGlkKHJlYXNvbiwgZXhwbGFuYXRpb24gPSBudWxsKSB7XG4gICAgaWYgKCFyZWFzb24pIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIm5lZWQgdG8gc3BlY2lmeSBhIHJlYXNvbiB0aGUgRHVyYXRpb24gaXMgaW52YWxpZFwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnZhbGlkID0gcmVhc29uIGluc3RhbmNlb2YgSW52YWxpZCA/IHJlYXNvbiA6IG5ldyBJbnZhbGlkKHJlYXNvbiwgZXhwbGFuYXRpb24pO1xuXG4gICAgaWYgKFNldHRpbmdzLnRocm93T25JbnZhbGlkKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZER1cmF0aW9uRXJyb3IoaW52YWxpZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgRHVyYXRpb24oeyBpbnZhbGlkIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhdGljIG5vcm1hbGl6ZVVuaXQodW5pdCkge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSB7XG4gICAgICB5ZWFyOiBcInllYXJzXCIsXG4gICAgICB5ZWFyczogXCJ5ZWFyc1wiLFxuICAgICAgcXVhcnRlcjogXCJxdWFydGVyc1wiLFxuICAgICAgcXVhcnRlcnM6IFwicXVhcnRlcnNcIixcbiAgICAgIG1vbnRoOiBcIm1vbnRoc1wiLFxuICAgICAgbW9udGhzOiBcIm1vbnRoc1wiLFxuICAgICAgd2VlazogXCJ3ZWVrc1wiLFxuICAgICAgd2Vla3M6IFwid2Vla3NcIixcbiAgICAgIGRheTogXCJkYXlzXCIsXG4gICAgICBkYXlzOiBcImRheXNcIixcbiAgICAgIGhvdXI6IFwiaG91cnNcIixcbiAgICAgIGhvdXJzOiBcImhvdXJzXCIsXG4gICAgICBtaW51dGU6IFwibWludXRlc1wiLFxuICAgICAgbWludXRlczogXCJtaW51dGVzXCIsXG4gICAgICBzZWNvbmQ6IFwic2Vjb25kc1wiLFxuICAgICAgc2Vjb25kczogXCJzZWNvbmRzXCIsXG4gICAgICBtaWxsaXNlY29uZDogXCJtaWxsaXNlY29uZHNcIixcbiAgICAgIG1pbGxpc2Vjb25kczogXCJtaWxsaXNlY29uZHNcIixcbiAgICB9W3VuaXQgPyB1bml0LnRvTG93ZXJDYXNlKCkgOiB1bml0XTtcblxuICAgIGlmICghbm9ybWFsaXplZCkgdGhyb3cgbmV3IEludmFsaWRVbml0RXJyb3IodW5pdCk7XG5cbiAgICByZXR1cm4gbm9ybWFsaXplZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBvYmplY3QgaXMgYSBEdXJhdGlvbi4gV29ya3MgYWNyb3NzIGNvbnRleHQgYm91bmRhcmllc1xuICAgKiBAcGFyYW0ge29iamVjdH0gb1xuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzRHVyYXRpb24obykge1xuICAgIHJldHVybiAobyAmJiBvLmlzTHV4b25EdXJhdGlvbikgfHwgZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0ICB0aGUgbG9jYWxlIG9mIGEgRHVyYXRpb24sIHN1Y2ggJ2VuLUdCJ1xuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGxvY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5sb2MubG9jYWxlIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG51bWJlcmluZyBzeXN0ZW0gb2YgYSBEdXJhdGlvbiwgc3VjaCAnYmVuZycuIFRoZSBudW1iZXJpbmcgc3lzdGVtIGlzIHVzZWQgd2hlbiBmb3JtYXR0aW5nIHRoZSBEdXJhdGlvblxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG51bWJlcmluZ1N5c3RlbSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5sb2MubnVtYmVyaW5nU3lzdGVtIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRHVyYXRpb24gZm9ybWF0dGVkIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIGZvcm1hdCBzdHJpbmcuIFlvdSBtYXkgdXNlIHRoZXNlIHRva2VuczpcbiAgICogKiBgU2AgZm9yIG1pbGxpc2Vjb25kc1xuICAgKiAqIGBzYCBmb3Igc2Vjb25kc1xuICAgKiAqIGBtYCBmb3IgbWludXRlc1xuICAgKiAqIGBoYCBmb3IgaG91cnNcbiAgICogKiBgZGAgZm9yIGRheXNcbiAgICogKiBgd2AgZm9yIHdlZWtzXG4gICAqICogYE1gIGZvciBtb250aHNcbiAgICogKiBgeWAgZm9yIHllYXJzXG4gICAqIE5vdGVzOlxuICAgKiAqIEFkZCBwYWRkaW5nIGJ5IHJlcGVhdGluZyB0aGUgdG9rZW4sIGUuZy4gXCJ5eVwiIHBhZHMgdGhlIHllYXJzIHRvIHR3byBkaWdpdHMsIFwiaGhoaFwiIHBhZHMgdGhlIGhvdXJzIG91dCB0byBmb3VyIGRpZ2l0c1xuICAgKiAqIFRva2VucyBjYW4gYmUgZXNjYXBlZCBieSB3cmFwcGluZyB3aXRoIHNpbmdsZSBxdW90ZXMuXG4gICAqICogVGhlIGR1cmF0aW9uIHdpbGwgYmUgY29udmVydGVkIHRvIHRoZSBzZXQgb2YgdW5pdHMgaW4gdGhlIGZvcm1hdCBzdHJpbmcgdXNpbmcge0BsaW5rIER1cmF0aW9uI3NoaWZ0VG99IGFuZCB0aGUgRHVyYXRpb25zJ3MgY29udmVyc2lvbiBhY2N1cmFjeSBzZXR0aW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm10IC0gdGhlIGZvcm1hdCBzdHJpbmdcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuZmxvb3I9dHJ1ZV0gLSBmbG9vciBudW1lcmljYWwgdmFsdWVzXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMSwgZGF5czogNiwgc2Vjb25kczogMiB9KS50b0Zvcm1hdChcInkgZCBzXCIpIC8vPT4gXCIxIDYgMlwiXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMSwgZGF5czogNiwgc2Vjb25kczogMiB9KS50b0Zvcm1hdChcInl5IGRkIHNzc1wiKSAvLz0+IFwiMDEgMDYgMDAyXCJcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IHllYXJzOiAxLCBkYXlzOiA2LCBzZWNvbmRzOiAyIH0pLnRvRm9ybWF0KFwiTSBTXCIpIC8vPT4gXCIxMiA1MTg0MDIwMDBcIlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0Zvcm1hdChmbXQsIG9wdHMgPSB7fSkge1xuICAgIC8vIHJldmVyc2UtY29tcGF0IHNpbmNlIDEuMjsgd2UgYWx3YXlzIHJvdW5kIGRvd24gbm93LCBuZXZlciB1cCwgYW5kIHdlIGRvIGl0IGJ5IGRlZmF1bHRcbiAgICBjb25zdCBmbXRPcHRzID0ge1xuICAgICAgLi4ub3B0cyxcbiAgICAgIGZsb29yOiBvcHRzLnJvdW5kICE9PSBmYWxzZSAmJiBvcHRzLmZsb29yICE9PSBmYWxzZSxcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWRcbiAgICAgID8gRm9ybWF0dGVyLmNyZWF0ZSh0aGlzLmxvYywgZm10T3B0cykuZm9ybWF0RHVyYXRpb25Gcm9tU3RyaW5nKHRoaXMsIGZtdClcbiAgICAgIDogSU5WQUxJRDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgRHVyYXRpb24gd2l0aCBhbGwgdW5pdHMgaW5jbHVkZWQuXG4gICAqIFRvIG1vZGlmeSBpdHMgYmVoYXZpb3IgdXNlIHRoZSBgbGlzdFN0eWxlYCBhbmQgYW55IEludGwuTnVtYmVyRm9ybWF0IG9wdGlvbiwgdGhvdWdoIGB1bml0RGlzcGxheWAgaXMgZXNwZWNpYWxseSByZWxldmFudC5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9JbnRsL051bWJlckZvcm1hdFxuICAgKiBAcGFyYW0gb3B0cyAtIE9uIG9wdGlvbiBvYmplY3QgdG8gb3ZlcnJpZGUgdGhlIGZvcm1hdHRpbmcuIEFjY2VwdHMgdGhlIHNhbWUga2V5cyBhcyB0aGUgb3B0aW9ucyBwYXJhbWV0ZXIgb2YgdGhlIG5hdGl2ZSBgSW50Lk51bWJlckZvcm1hdGAgY29uc3RydWN0b3IsIGFzIHdlbGwgYXMgYGxpc3RTdHlsZWAuXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIHZhciBkdXIgPSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgZGF5czogMSwgaG91cnM6IDUsIG1pbnV0ZXM6IDYgfSlcbiAgICogZHVyLnRvSHVtYW4oKSAvLz0+ICcxIGRheSwgNSBob3VycywgNiBtaW51dGVzJ1xuICAgKiBkdXIudG9IdW1hbih7IGxpc3RTdHlsZTogXCJsb25nXCIgfSkgLy89PiAnMSBkYXksIDUgaG91cnMsIGFuZCA2IG1pbnV0ZXMnXG4gICAqIGR1ci50b0h1bWFuKHsgdW5pdERpc3BsYXk6IFwic2hvcnRcIiB9KSAvLz0+ICcxIGRheSwgNSBociwgNiBtaW4nXG4gICAqIGBgYFxuICAgKi9cbiAgdG9IdW1hbihvcHRzID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIElOVkFMSUQ7XG5cbiAgICBjb25zdCBsID0gb3JkZXJlZFVuaXRzXG4gICAgICAubWFwKCh1bml0KSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbCA9IHRoaXMudmFsdWVzW3VuaXRdO1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxvY1xuICAgICAgICAgIC5udW1iZXJGb3JtYXR0ZXIoeyBzdHlsZTogXCJ1bml0XCIsIHVuaXREaXNwbGF5OiBcImxvbmdcIiwgLi4ub3B0cywgdW5pdDogdW5pdC5zbGljZSgwLCAtMSkgfSlcbiAgICAgICAgICAuZm9ybWF0KHZhbCk7XG4gICAgICB9KVxuICAgICAgLmZpbHRlcigobikgPT4gbik7XG5cbiAgICByZXR1cm4gdGhpcy5sb2NcbiAgICAgIC5saXN0Rm9ybWF0dGVyKHsgdHlwZTogXCJjb25qdW5jdGlvblwiLCBzdHlsZTogb3B0cy5saXN0U3R5bGUgfHwgXCJuYXJyb3dcIiwgLi4ub3B0cyB9KVxuICAgICAgLmZvcm1hdChsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgSmF2YVNjcmlwdCBvYmplY3Qgd2l0aCB0aGlzIER1cmF0aW9uJ3MgdmFsdWVzLlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgeWVhcnM6IDEsIGRheXM6IDYsIHNlY29uZHM6IDIgfSkudG9PYmplY3QoKSAvLz0+IHsgeWVhcnM6IDEsIGRheXM6IDYsIHNlY29uZHM6IDIgfVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICB0b09iamVjdCgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHt9O1xuICAgIHJldHVybiB7IC4uLnRoaXMudmFsdWVzIH07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRHVyYXRpb24uXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjRHVyYXRpb25zXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMywgc2Vjb25kczogNDUgfSkudG9JU08oKSAvLz0+ICdQM1lUNDVTJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbW9udGhzOiA0LCBzZWNvbmRzOiA0NSB9KS50b0lTTygpIC8vPT4gJ1A0TVQ0NVMnXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBtb250aHM6IDUgfSkudG9JU08oKSAvLz0+ICdQNU0nXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBtaW51dGVzOiA1IH0pLnRvSVNPKCkgLy89PiAnUFQ1TSdcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IG1pbGxpc2Vjb25kczogNiB9KS50b0lTTygpIC8vPT4gJ1BUMC4wMDZTJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0lTTygpIHtcbiAgICAvLyB3ZSBjb3VsZCB1c2UgdGhlIGZvcm1hdHRlciwgYnV0IHRoaXMgaXMgYW4gZWFzaWVyIHdheSB0byBnZXQgdGhlIG1pbmltdW0gc3RyaW5nXG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBudWxsO1xuXG4gICAgbGV0IHMgPSBcIlBcIjtcbiAgICBpZiAodGhpcy55ZWFycyAhPT0gMCkgcyArPSB0aGlzLnllYXJzICsgXCJZXCI7XG4gICAgaWYgKHRoaXMubW9udGhzICE9PSAwIHx8IHRoaXMucXVhcnRlcnMgIT09IDApIHMgKz0gdGhpcy5tb250aHMgKyB0aGlzLnF1YXJ0ZXJzICogMyArIFwiTVwiO1xuICAgIGlmICh0aGlzLndlZWtzICE9PSAwKSBzICs9IHRoaXMud2Vla3MgKyBcIldcIjtcbiAgICBpZiAodGhpcy5kYXlzICE9PSAwKSBzICs9IHRoaXMuZGF5cyArIFwiRFwiO1xuICAgIGlmICh0aGlzLmhvdXJzICE9PSAwIHx8IHRoaXMubWludXRlcyAhPT0gMCB8fCB0aGlzLnNlY29uZHMgIT09IDAgfHwgdGhpcy5taWxsaXNlY29uZHMgIT09IDApXG4gICAgICBzICs9IFwiVFwiO1xuICAgIGlmICh0aGlzLmhvdXJzICE9PSAwKSBzICs9IHRoaXMuaG91cnMgKyBcIkhcIjtcbiAgICBpZiAodGhpcy5taW51dGVzICE9PSAwKSBzICs9IHRoaXMubWludXRlcyArIFwiTVwiO1xuICAgIGlmICh0aGlzLnNlY29uZHMgIT09IDAgfHwgdGhpcy5taWxsaXNlY29uZHMgIT09IDApXG4gICAgICAvLyB0aGlzIHdpbGwgaGFuZGxlIFwiZmxvYXRpbmcgcG9pbnQgbWFkbmVzc1wiIGJ5IHJlbW92aW5nIGV4dHJhIGRlY2ltYWwgcGxhY2VzXG4gICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81ODgwMDQvaXMtZmxvYXRpbmctcG9pbnQtbWF0aC1icm9rZW5cbiAgICAgIHMgKz0gcm91bmRUbyh0aGlzLnNlY29uZHMgKyB0aGlzLm1pbGxpc2Vjb25kcyAvIDEwMDAsIDMpICsgXCJTXCI7XG4gICAgaWYgKHMgPT09IFwiUFwiKSBzICs9IFwiVDBTXCI7XG4gICAgcmV0dXJuIHM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRHVyYXRpb24sIGZvcm1hdHRlZCBhcyBhIHRpbWUgb2YgZGF5LlxuICAgKiBOb3RlIHRoYXQgdGhpcyB3aWxsIHJldHVybiBudWxsIGlmIHRoZSBkdXJhdGlvbiBpcyBpbnZhbGlkLCBuZWdhdGl2ZSwgb3IgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIDI0IGhvdXJzLlxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI1RpbWVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnN1cHByZXNzTWlsbGlzZWNvbmRzPWZhbHNlXSAtIGV4Y2x1ZGUgbWlsbGlzZWNvbmRzIGZyb20gdGhlIGZvcm1hdCBpZiB0aGV5J3JlIDBcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zdXBwcmVzc1NlY29uZHM9ZmFsc2VdIC0gZXhjbHVkZSBzZWNvbmRzIGZyb20gdGhlIGZvcm1hdCBpZiB0aGV5J3JlIDBcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlUHJlZml4PWZhbHNlXSAtIGluY2x1ZGUgdGhlIGBUYCBwcmVmaXhcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmZvcm1hdD0nZXh0ZW5kZWQnXSAtIGNob29zZSBiZXR3ZWVuIHRoZSBiYXNpYyBhbmQgZXh0ZW5kZWQgZm9ybWF0XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMTEgfSkudG9JU09UaW1lKCkgLy89PiAnMTE6MDA6MDAuMDAwJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDExIH0pLnRvSVNPVGltZSh7IHN1cHByZXNzTWlsbGlzZWNvbmRzOiB0cnVlIH0pIC8vPT4gJzExOjAwOjAwJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDExIH0pLnRvSVNPVGltZSh7IHN1cHByZXNzU2Vjb25kczogdHJ1ZSB9KSAvLz0+ICcxMTowMCdcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxMSB9KS50b0lTT1RpbWUoeyBpbmNsdWRlUHJlZml4OiB0cnVlIH0pIC8vPT4gJ1QxMTowMDowMC4wMDAnXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMTEgfSkudG9JU09UaW1lKHsgZm9ybWF0OiAnYmFzaWMnIH0pIC8vPT4gJzExMDAwMC4wMDAnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSVNPVGltZShvcHRzID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIG51bGw7XG5cbiAgICBjb25zdCBtaWxsaXMgPSB0aGlzLnRvTWlsbGlzKCk7XG4gICAgaWYgKG1pbGxpcyA8IDAgfHwgbWlsbGlzID49IDg2NDAwMDAwKSByZXR1cm4gbnVsbDtcblxuICAgIG9wdHMgPSB7XG4gICAgICBzdXBwcmVzc01pbGxpc2Vjb25kczogZmFsc2UsXG4gICAgICBzdXBwcmVzc1NlY29uZHM6IGZhbHNlLFxuICAgICAgaW5jbHVkZVByZWZpeDogZmFsc2UsXG4gICAgICBmb3JtYXQ6IFwiZXh0ZW5kZWRcIixcbiAgICAgIC4uLm9wdHMsXG4gICAgICBpbmNsdWRlT2Zmc2V0OiBmYWxzZSxcbiAgICB9O1xuXG4gICAgY29uc3QgZGF0ZVRpbWUgPSBEYXRlVGltZS5mcm9tTWlsbGlzKG1pbGxpcywgeyB6b25lOiBcIlVUQ1wiIH0pO1xuICAgIHJldHVybiBkYXRlVGltZS50b0lTT1RpbWUob3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIER1cmF0aW9uIGFwcHJvcHJpYXRlIGZvciB1c2UgaW4gSlNPTi5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvSVNPKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIER1cmF0aW9uIGFwcHJvcHJpYXRlIGZvciB1c2UgaW4gZGVidWdnaW5nLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy50b0lTTygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gbWlsbGlzZWNvbmRzIHZhbHVlIG9mIHRoaXMgRHVyYXRpb24uXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHRvTWlsbGlzKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gTmFOO1xuXG4gICAgcmV0dXJuIGR1cmF0aW9uVG9NaWxsaXModGhpcy5tYXRyaXgsIHRoaXMudmFsdWVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG1pbGxpc2Vjb25kcyB2YWx1ZSBvZiB0aGlzIER1cmF0aW9uLiBBbGlhcyBvZiB7QGxpbmsgdG9NaWxsaXN9XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHZhbHVlT2YoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9NaWxsaXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIHRoaXMgRHVyYXRpb24gbG9uZ2VyIGJ5IHRoZSBzcGVjaWZpZWQgYW1vdW50LiBSZXR1cm4gYSBuZXdseS1jb25zdHJ1Y3RlZCBEdXJhdGlvbi5cbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSBhbW91bnQgdG8gYWRkLiBFaXRoZXIgYSBMdXhvbiBEdXJhdGlvbiwgYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCB0aGUgb2JqZWN0IGFyZ3VtZW50IHRvIER1cmF0aW9uLmZyb21PYmplY3QoKVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHBsdXMoZHVyYXRpb24pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG5cbiAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tRHVyYXRpb25MaWtlKGR1cmF0aW9uKSxcbiAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgZm9yIChjb25zdCBrIG9mIG9yZGVyZWRVbml0cykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5KGR1ci52YWx1ZXMsIGspIHx8IGhhc093blByb3BlcnR5KHRoaXMudmFsdWVzLCBrKSkge1xuICAgICAgICByZXN1bHRba10gPSBkdXIuZ2V0KGspICsgdGhpcy5nZXQoayk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIHsgdmFsdWVzOiByZXN1bHQgfSwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogTWFrZSB0aGlzIER1cmF0aW9uIHNob3J0ZXIgYnkgdGhlIHNwZWNpZmllZCBhbW91bnQuIFJldHVybiBhIG5ld2x5LWNvbnN0cnVjdGVkIER1cmF0aW9uLlxuICAgKiBAcGFyYW0ge0R1cmF0aW9ufE9iamVjdHxudW1iZXJ9IGR1cmF0aW9uIC0gVGhlIGFtb3VudCB0byBzdWJ0cmFjdC4gRWl0aGVyIGEgTHV4b24gRHVyYXRpb24sIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgdGhlIG9iamVjdCBhcmd1bWVudCB0byBEdXJhdGlvbi5mcm9tT2JqZWN0KClcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBtaW51cyhkdXJhdGlvbikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcblxuICAgIGNvbnN0IGR1ciA9IER1cmF0aW9uLmZyb21EdXJhdGlvbkxpa2UoZHVyYXRpb24pO1xuICAgIHJldHVybiB0aGlzLnBsdXMoZHVyLm5lZ2F0ZSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTY2FsZSB0aGlzIER1cmF0aW9uIGJ5IHRoZSBzcGVjaWZpZWQgYW1vdW50LiBSZXR1cm4gYSBuZXdseS1jb25zdHJ1Y3RlZCBEdXJhdGlvbi5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gLSBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCB1bml0LiBBcml0eSBpcyAxIG9yIDI6IHRoZSB2YWx1ZSBvZiB0aGUgdW5pdCBhbmQsIG9wdGlvbmFsbHksIHRoZSB1bml0IG5hbWUuIE11c3QgcmV0dXJuIGEgbnVtYmVyLlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDEsIG1pbnV0ZXM6IDMwIH0pLm1hcFVuaXRzKHggPT4geCAqIDIpIC8vPT4geyBob3VyczogMiwgbWludXRlczogNjAgfVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDEsIG1pbnV0ZXM6IDMwIH0pLm1hcFVuaXRzKCh4LCB1KSA9PiB1ID09PSBcImhvdXJzXCIgPyB4ICogMiA6IHgpIC8vPT4geyBob3VyczogMiwgbWludXRlczogMzAgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIG1hcFVuaXRzKGZuKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyh0aGlzLnZhbHVlcykpIHtcbiAgICAgIHJlc3VsdFtrXSA9IGFzTnVtYmVyKGZuKHRoaXMudmFsdWVzW2tdLCBrKSk7XG4gICAgfVxuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHZhbHVlczogcmVzdWx0IH0sIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgb2YgdW5pdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSBhIHVuaXQgc3VjaCBhcyAnbWludXRlJyBvciAnZGF5J1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHt5ZWFyczogMiwgZGF5czogM30pLmdldCgneWVhcnMnKSAvLz0+IDJcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7eWVhcnM6IDIsIGRheXM6IDN9KS5nZXQoJ21vbnRocycpIC8vPT4gMFxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHt5ZWFyczogMiwgZGF5czogM30pLmdldCgnZGF5cycpIC8vPT4gM1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXQodW5pdCkge1xuICAgIHJldHVybiB0aGlzW0R1cmF0aW9uLm5vcm1hbGl6ZVVuaXQodW5pdCldO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhlIHZhbHVlcyBvZiBzcGVjaWZpZWQgdW5pdHMuIFJldHVybiBhIG5ld2x5LWNvbnN0cnVjdGVkIER1cmF0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzIC0gYSBtYXBwaW5nIG9mIHVuaXRzIHRvIG51bWJlcnNcbiAgICogQGV4YW1wbGUgZHVyLnNldCh7IHllYXJzOiAyMDE3IH0pXG4gICAqIEBleGFtcGxlIGR1ci5zZXQoeyBob3VyczogOCwgbWludXRlczogMzAgfSlcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzZXQodmFsdWVzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuXG4gICAgY29uc3QgbWl4ZWQgPSB7IC4uLnRoaXMudmFsdWVzLCAuLi5ub3JtYWxpemVPYmplY3QodmFsdWVzLCBEdXJhdGlvbi5ub3JtYWxpemVVbml0KSB9O1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHZhbHVlczogbWl4ZWQgfSk7XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGUgbG9jYWxlIGFuZC9vciBudW1iZXJpbmdTeXN0ZW0uICBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRHVyYXRpb24uXG4gICAqIEBleGFtcGxlIGR1ci5yZWNvbmZpZ3VyZSh7IGxvY2FsZTogJ2VuLUdCJyB9KVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHJlY29uZmlndXJlKHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIGNvbnZlcnNpb25BY2N1cmFjeSwgbWF0cml4IH0gPSB7fSkge1xuICAgIGNvbnN0IGxvYyA9IHRoaXMubG9jLmNsb25lKHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0gfSk7XG4gICAgY29uc3Qgb3B0cyA9IHsgbG9jLCBtYXRyaXgsIGNvbnZlcnNpb25BY2N1cmFjeSB9O1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgZHVyYXRpb24gaW4gdGhlIHNwZWNpZmllZCB1bml0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIGEgdW5pdCBzdWNoIGFzICdtaW51dGVzJyBvciAnZGF5cydcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7eWVhcnM6IDF9KS5hcygnZGF5cycpIC8vPT4gMzY1XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3Qoe3llYXJzOiAxfSkuYXMoJ21vbnRocycpIC8vPT4gMTJcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7aG91cnM6IDYwfSkuYXMoJ2RheXMnKSAvLz0+IDIuNVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBhcyh1bml0KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuc2hpZnRUbyh1bml0KS5nZXQodW5pdCkgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmVkdWNlIHRoaXMgRHVyYXRpb24gdG8gaXRzIGNhbm9uaWNhbCByZXByZXNlbnRhdGlvbiBpbiBpdHMgY3VycmVudCB1bml0cy5cbiAgICogQXNzdW1pbmcgdGhlIG92ZXJhbGwgdmFsdWUgb2YgdGhlIER1cmF0aW9uIGlzIHBvc2l0aXZlLCB0aGlzIG1lYW5zOlxuICAgKiAtIGV4Y2Vzc2l2ZSB2YWx1ZXMgZm9yIGxvd2VyLW9yZGVyIHVuaXRzIGFyZSBjb252ZXJ0ZWQgdG8gaGlnaGVyLW9yZGVyIHVuaXRzIChpZiBwb3NzaWJsZSwgc2VlIGZpcnN0IGFuZCBzZWNvbmQgZXhhbXBsZSlcbiAgICogLSBuZWdhdGl2ZSBsb3dlci1vcmRlciB1bml0cyBhcmUgY29udmVydGVkIHRvIGhpZ2hlciBvcmRlciB1bml0cyAodGhlcmUgbXVzdCBiZSBzdWNoIGEgaGlnaGVyIG9yZGVyIHVuaXQsIG90aGVyd2lzZVxuICAgKiAgIHRoZSBvdmVyYWxsIHZhbHVlIHdvdWxkIGJlIG5lZ2F0aXZlLCBzZWUgc2Vjb25kIGV4YW1wbGUpXG4gICAqIC0gZnJhY3Rpb25hbCB2YWx1ZXMgZm9yIGhpZ2hlci1vcmRlciB1bml0cyBhcmUgY29udmVydGVkIHRvIGxvd2VyLW9yZGVyIHVuaXRzIChpZiBwb3NzaWJsZSwgc2VlIGZvdXJ0aCBleGFtcGxlKVxuICAgKlxuICAgKiBJZiB0aGUgb3ZlcmFsbCB2YWx1ZSBpcyBuZWdhdGl2ZSwgdGhlIHJlc3VsdCBvZiB0aGlzIG1ldGhvZCBpcyBlcXVpdmFsZW50IHRvIGB0aGlzLm5lZ2F0ZSgpLm5vcm1hbGl6ZSgpLm5lZ2F0ZSgpYC5cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IHllYXJzOiAyLCBkYXlzOiA1MDAwIH0pLm5vcm1hbGl6ZSgpLnRvT2JqZWN0KCkgLy89PiB7IHllYXJzOiAxNSwgZGF5czogMjU1IH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGRheXM6IDUwMDAgfSkubm9ybWFsaXplKCkudG9PYmplY3QoKSAvLz0+IHsgZGF5czogNTAwMCB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMTIsIG1pbnV0ZXM6IC00NSB9KS5ub3JtYWxpemUoKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMTEsIG1pbnV0ZXM6IDE1IH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IHllYXJzOiAyLjUsIGRheXM6IDAsIGhvdXJzOiAwIH0pLm5vcm1hbGl6ZSgpLnRvT2JqZWN0KCkgLy89PiB7IHllYXJzOiAyLCBkYXlzOiAxODIsIGhvdXJzOiAxMiB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgbm9ybWFsaXplKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCB2YWxzID0gdGhpcy50b09iamVjdCgpO1xuICAgIG5vcm1hbGl6ZVZhbHVlcyh0aGlzLm1hdHJpeCwgdmFscyk7XG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIHsgdmFsdWVzOiB2YWxzIH0sIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2NhbGUgdW5pdHMgdG8gaXRzIGxhcmdlc3QgcmVwcmVzZW50YXRpb25cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IG1pbGxpc2Vjb25kczogOTAwMDAgfSkucmVzY2FsZSgpLnRvT2JqZWN0KCkgLy89PiB7IG1pbnV0ZXM6IDEsIHNlY29uZHM6IDMwIH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICByZXNjYWxlKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCB2YWxzID0gcmVtb3ZlWmVyb2VzKHRoaXMubm9ybWFsaXplKCkuc2hpZnRUb0FsbCgpLnRvT2JqZWN0KCkpO1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHZhbHVlczogdmFscyB9LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHRoaXMgRHVyYXRpb24gaW50byBpdHMgcmVwcmVzZW50YXRpb24gaW4gYSBkaWZmZXJlbnQgc2V0IG9mIHVuaXRzLlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDEsIHNlY29uZHM6IDMwIH0pLnNoaWZ0VG8oJ21pbnV0ZXMnLCAnbWlsbGlzZWNvbmRzJykudG9PYmplY3QoKSAvLz0+IHsgbWludXRlczogNjAsIG1pbGxpc2Vjb25kczogMzAwMDAgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHNoaWZ0VG8oLi4udW5pdHMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAodW5pdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB1bml0cyA9IHVuaXRzLm1hcCgodSkgPT4gRHVyYXRpb24ubm9ybWFsaXplVW5pdCh1KSk7XG5cbiAgICBjb25zdCBidWlsdCA9IHt9LFxuICAgICAgYWNjdW11bGF0ZWQgPSB7fSxcbiAgICAgIHZhbHMgPSB0aGlzLnRvT2JqZWN0KCk7XG4gICAgbGV0IGxhc3RVbml0O1xuXG4gICAgZm9yIChjb25zdCBrIG9mIG9yZGVyZWRVbml0cykge1xuICAgICAgaWYgKHVuaXRzLmluZGV4T2YoaykgPj0gMCkge1xuICAgICAgICBsYXN0VW5pdCA9IGs7XG5cbiAgICAgICAgbGV0IG93biA9IDA7XG5cbiAgICAgICAgLy8gYW55dGhpbmcgd2UgaGF2ZW4ndCBib2lsZWQgZG93biB5ZXQgc2hvdWxkIGdldCBib2lsZWQgdG8gdGhpcyB1bml0XG4gICAgICAgIGZvciAoY29uc3QgYWsgaW4gYWNjdW11bGF0ZWQpIHtcbiAgICAgICAgICBvd24gKz0gdGhpcy5tYXRyaXhbYWtdW2tdICogYWNjdW11bGF0ZWRbYWtdO1xuICAgICAgICAgIGFjY3VtdWxhdGVkW2FrXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwbHVzIGFueXRoaW5nIHRoYXQncyBhbHJlYWR5IGluIHRoaXMgdW5pdFxuICAgICAgICBpZiAoaXNOdW1iZXIodmFsc1trXSkpIHtcbiAgICAgICAgICBvd24gKz0gdmFsc1trXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG9ubHkga2VlcCB0aGUgaW50ZWdlciBwYXJ0IGZvciBub3cgaW4gdGhlIGhvcGVzIG9mIHB1dHRpbmcgYW55IGRlY2ltYWwgcGFydFxuICAgICAgICAvLyBpbnRvIGEgc21hbGxlciB1bml0IGxhdGVyXG4gICAgICAgIGNvbnN0IGkgPSBNYXRoLnRydW5jKG93bik7XG4gICAgICAgIGJ1aWx0W2tdID0gaTtcbiAgICAgICAgYWNjdW11bGF0ZWRba10gPSAob3duICogMTAwMCAtIGkgKiAxMDAwKSAvIDEwMDA7XG5cbiAgICAgICAgLy8gb3RoZXJ3aXNlLCBrZWVwIGl0IGluIHRoZSB3aW5ncyB0byBib2lsIGl0IGxhdGVyXG4gICAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKHZhbHNba10pKSB7XG4gICAgICAgIGFjY3VtdWxhdGVkW2tdID0gdmFsc1trXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhbnl0aGluZyBsZWZ0b3ZlciBiZWNvbWVzIHRoZSBkZWNpbWFsIGZvciB0aGUgbGFzdCB1bml0XG4gICAgLy8gbGFzdFVuaXQgbXVzdCBiZSBkZWZpbmVkIHNpbmNlIHVuaXRzIGlzIG5vdCBlbXB0eVxuICAgIGZvciAoY29uc3Qga2V5IGluIGFjY3VtdWxhdGVkKSB7XG4gICAgICBpZiAoYWNjdW11bGF0ZWRba2V5XSAhPT0gMCkge1xuICAgICAgICBidWlsdFtsYXN0VW5pdF0gKz1cbiAgICAgICAgICBrZXkgPT09IGxhc3RVbml0ID8gYWNjdW11bGF0ZWRba2V5XSA6IGFjY3VtdWxhdGVkW2tleV0gLyB0aGlzLm1hdHJpeFtsYXN0VW5pdF1ba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBub3JtYWxpemVWYWx1ZXModGhpcy5tYXRyaXgsIGJ1aWx0KTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyB2YWx1ZXM6IGJ1aWx0IH0sIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNoaWZ0IHRoaXMgRHVyYXRpb24gdG8gYWxsIGF2YWlsYWJsZSB1bml0cy5cbiAgICogU2FtZSBhcyBzaGlmdFRvKFwieWVhcnNcIiwgXCJtb250aHNcIiwgXCJ3ZWVrc1wiLCBcImRheXNcIiwgXCJob3Vyc1wiLCBcIm1pbnV0ZXNcIiwgXCJzZWNvbmRzXCIsIFwibWlsbGlzZWNvbmRzXCIpXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgc2hpZnRUb0FsbCgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgcmV0dXJuIHRoaXMuc2hpZnRUbyhcbiAgICAgIFwieWVhcnNcIixcbiAgICAgIFwibW9udGhzXCIsXG4gICAgICBcIndlZWtzXCIsXG4gICAgICBcImRheXNcIixcbiAgICAgIFwiaG91cnNcIixcbiAgICAgIFwibWludXRlc1wiLFxuICAgICAgXCJzZWNvbmRzXCIsXG4gICAgICBcIm1pbGxpc2Vjb25kc1wiXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG5lZ2F0aXZlIG9mIHRoaXMgRHVyYXRpb24uXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMSwgc2Vjb25kczogMzAgfSkubmVnYXRlKCkudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IC0xLCBzZWNvbmRzOiAtMzAgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIG5lZ2F0ZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgbmVnYXRlZCA9IHt9O1xuICAgIGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyh0aGlzLnZhbHVlcykpIHtcbiAgICAgIG5lZ2F0ZWRba10gPSB0aGlzLnZhbHVlc1trXSA9PT0gMCA/IDAgOiAtdGhpcy52YWx1ZXNba107XG4gICAgfVxuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHZhbHVlczogbmVnYXRlZCB9LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHllYXJzLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHllYXJzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy55ZWFycyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcXVhcnRlcnMuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgcXVhcnRlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLnF1YXJ0ZXJzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtb250aHMuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbW9udGhzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy5tb250aHMgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHdlZWtzXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgd2Vla3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLndlZWtzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkYXlzLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGRheXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLmRheXMgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGhvdXJzLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGhvdXJzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy5ob3VycyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWludXRlcy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBtaW51dGVzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy5taW51dGVzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzZWNvbmRzLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgc2Vjb25kcygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMuc2Vjb25kcyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWlsbGlzZWNvbmRzLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbWlsbGlzZWNvbmRzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy5taWxsaXNlY29uZHMgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIER1cmF0aW9uIGlzIGludmFsaWQuIEludmFsaWQgZHVyYXRpb25zIGFyZSByZXR1cm5lZCBieSBkaWZmIG9wZXJhdGlvbnNcbiAgICogb24gaW52YWxpZCBEYXRlVGltZXMgb3IgSW50ZXJ2YWxzLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZCA9PT0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGVycm9yIGNvZGUgaWYgdGhpcyBEdXJhdGlvbiBiZWNhbWUgaW52YWxpZCwgb3IgbnVsbCBpZiB0aGUgRHVyYXRpb24gaXMgdmFsaWRcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGludmFsaWRSZWFzb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZCA/IHRoaXMuaW52YWxpZC5yZWFzb24gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZXhwbGFuYXRpb24gb2Ygd2h5IHRoaXMgRHVyYXRpb24gYmVjYW1lIGludmFsaWQsIG9yIG51bGwgaWYgdGhlIER1cmF0aW9uIGlzIHZhbGlkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgaW52YWxpZEV4cGxhbmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmludmFsaWQgPyB0aGlzLmludmFsaWQuZXhwbGFuYXRpb24gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEVxdWFsaXR5IGNoZWNrXG4gICAqIFR3byBEdXJhdGlvbnMgYXJlIGVxdWFsIGlmZiB0aGV5IGhhdmUgdGhlIHNhbWUgdW5pdHMgYW5kIHRoZSBzYW1lIHZhbHVlcyBmb3IgZWFjaCB1bml0LlxuICAgKiBAcGFyYW0ge0R1cmF0aW9ufSBvdGhlclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQgfHwgIW90aGVyLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMubG9jLmVxdWFscyhvdGhlci5sb2MpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXEodjEsIHYyKSB7XG4gICAgICAvLyBDb25zaWRlciAwIGFuZCB1bmRlZmluZWQgYXMgZXF1YWxcbiAgICAgIGlmICh2MSA9PT0gdW5kZWZpbmVkIHx8IHYxID09PSAwKSByZXR1cm4gdjIgPT09IHVuZGVmaW5lZCB8fCB2MiA9PT0gMDtcbiAgICAgIHJldHVybiB2MSA9PT0gdjI7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCB1IG9mIG9yZGVyZWRVbml0cykge1xuICAgICAgaWYgKCFlcSh0aGlzLnZhbHVlc1t1XSwgb3RoZXIudmFsdWVzW3VdKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG4iLCAiaW1wb3J0IERhdGVUaW1lLCB7IGZyaWVuZGx5RGF0ZVRpbWUgfSBmcm9tIFwiLi9kYXRldGltZS5qc1wiO1xuaW1wb3J0IER1cmF0aW9uIGZyb20gXCIuL2R1cmF0aW9uLmpzXCI7XG5pbXBvcnQgU2V0dGluZ3MgZnJvbSBcIi4vc2V0dGluZ3MuanNcIjtcbmltcG9ydCB7IEludmFsaWRBcmd1bWVudEVycm9yLCBJbnZhbGlkSW50ZXJ2YWxFcnJvciB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IEludmFsaWQgZnJvbSBcIi4vaW1wbC9pbnZhbGlkLmpzXCI7XG5pbXBvcnQgRm9ybWF0dGVyIGZyb20gXCIuL2ltcGwvZm9ybWF0dGVyLmpzXCI7XG5pbXBvcnQgKiBhcyBGb3JtYXRzIGZyb20gXCIuL2ltcGwvZm9ybWF0cy5qc1wiO1xuXG5jb25zdCBJTlZBTElEID0gXCJJbnZhbGlkIEludGVydmFsXCI7XG5cbi8vIGNoZWNrcyBpZiB0aGUgc3RhcnQgaXMgZXF1YWwgdG8gb3IgYmVmb3JlIHRoZSBlbmRcbmZ1bmN0aW9uIHZhbGlkYXRlU3RhcnRFbmQoc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0IHx8ICFzdGFydC5pc1ZhbGlkKSB7XG4gICAgcmV0dXJuIEludGVydmFsLmludmFsaWQoXCJtaXNzaW5nIG9yIGludmFsaWQgc3RhcnRcIik7XG4gIH0gZWxzZSBpZiAoIWVuZCB8fCAhZW5kLmlzVmFsaWQpIHtcbiAgICByZXR1cm4gSW50ZXJ2YWwuaW52YWxpZChcIm1pc3Npbmcgb3IgaW52YWxpZCBlbmRcIik7XG4gIH0gZWxzZSBpZiAoZW5kIDwgc3RhcnQpIHtcbiAgICByZXR1cm4gSW50ZXJ2YWwuaW52YWxpZChcbiAgICAgIFwiZW5kIGJlZm9yZSBzdGFydFwiLFxuICAgICAgYFRoZSBlbmQgb2YgYW4gaW50ZXJ2YWwgbXVzdCBiZSBhZnRlciBpdHMgc3RhcnQsIGJ1dCB5b3UgaGFkIHN0YXJ0PSR7c3RhcnQudG9JU08oKX0gYW5kIGVuZD0ke2VuZC50b0lTTygpfWBcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogQW4gSW50ZXJ2YWwgb2JqZWN0IHJlcHJlc2VudHMgYSBoYWxmLW9wZW4gaW50ZXJ2YWwgb2YgdGltZSwgd2hlcmUgZWFjaCBlbmRwb2ludCBpcyBhIHtAbGluayBEYXRlVGltZX0uIENvbmNlcHR1YWxseSwgaXQncyBhIGNvbnRhaW5lciBmb3IgdGhvc2UgdHdvIGVuZHBvaW50cywgYWNjb21wYW5pZWQgYnkgbWV0aG9kcyBmb3IgY3JlYXRpbmcsIHBhcnNpbmcsIGludGVycm9nYXRpbmcsIGNvbXBhcmluZywgdHJhbnNmb3JtaW5nLCBhbmQgZm9ybWF0dGluZyB0aGVtLlxuICpcbiAqIEhlcmUgaXMgYSBicmllZiBvdmVydmlldyBvZiB0aGUgbW9zdCBjb21tb25seSB1c2VkIG1ldGhvZHMgYW5kIGdldHRlcnMgaW4gSW50ZXJ2YWw6XG4gKlxuICogKiAqKkNyZWF0aW9uKiogVG8gY3JlYXRlIGFuIEludGVydmFsLCB1c2Uge0BsaW5rIEludGVydmFsLmZyb21EYXRlVGltZXN9LCB7QGxpbmsgSW50ZXJ2YWwuYWZ0ZXJ9LCB7QGxpbmsgSW50ZXJ2YWwuYmVmb3JlfSwgb3Ige0BsaW5rIEludGVydmFsLmZyb21JU099LlxuICogKiAqKkFjY2Vzc29ycyoqIFVzZSB7QGxpbmsgSW50ZXJ2YWwjc3RhcnR9IGFuZCB7QGxpbmsgSW50ZXJ2YWwjZW5kfSB0byBnZXQgdGhlIHN0YXJ0IGFuZCBlbmQuXG4gKiAqICoqSW50ZXJyb2dhdGlvbioqIFRvIGFuYWx5emUgdGhlIEludGVydmFsLCB1c2Uge0BsaW5rIEludGVydmFsI2NvdW50fSwge0BsaW5rIEludGVydmFsI2xlbmd0aH0sIHtAbGluayBJbnRlcnZhbCNoYXNTYW1lfSwge0BsaW5rIEludGVydmFsI2NvbnRhaW5zfSwge0BsaW5rIEludGVydmFsI2lzQWZ0ZXJ9LCBvciB7QGxpbmsgSW50ZXJ2YWwjaXNCZWZvcmV9LlxuICogKiAqKlRyYW5zZm9ybWF0aW9uKiogVG8gY3JlYXRlIG90aGVyIEludGVydmFscyBvdXQgb2YgdGhpcyBvbmUsIHVzZSB7QGxpbmsgSW50ZXJ2YWwjc2V0fSwge0BsaW5rIEludGVydmFsI3NwbGl0QXR9LCB7QGxpbmsgSW50ZXJ2YWwjc3BsaXRCeX0sIHtAbGluayBJbnRlcnZhbCNkaXZpZGVFcXVhbGx5fSwge0BsaW5rIEludGVydmFsLm1lcmdlfSwge0BsaW5rIEludGVydmFsLnhvcn0sIHtAbGluayBJbnRlcnZhbCN1bmlvbn0sIHtAbGluayBJbnRlcnZhbCNpbnRlcnNlY3Rpb259LCBvciB7QGxpbmsgSW50ZXJ2YWwjZGlmZmVyZW5jZX0uXG4gKiAqICoqQ29tcGFyaXNvbioqIFRvIGNvbXBhcmUgdGhpcyBJbnRlcnZhbCB0byBhbm90aGVyIG9uZSwgdXNlIHtAbGluayBJbnRlcnZhbCNlcXVhbHN9LCB7QGxpbmsgSW50ZXJ2YWwjb3ZlcmxhcHN9LCB7QGxpbmsgSW50ZXJ2YWwjYWJ1dHNTdGFydH0sIHtAbGluayBJbnRlcnZhbCNhYnV0c0VuZH0sIHtAbGluayBJbnRlcnZhbCNlbmd1bGZzfVxuICogKiAqKk91dHB1dCoqIFRvIGNvbnZlcnQgdGhlIEludGVydmFsIGludG8gb3RoZXIgcmVwcmVzZW50YXRpb25zLCBzZWUge0BsaW5rIEludGVydmFsI3RvU3RyaW5nfSwge0BsaW5rIEludGVydmFsI3RvTG9jYWxlU3RyaW5nfSwge0BsaW5rIEludGVydmFsI3RvSVNPfSwge0BsaW5rIEludGVydmFsI3RvSVNPRGF0ZX0sIHtAbGluayBJbnRlcnZhbCN0b0lTT1RpbWV9LCB7QGxpbmsgSW50ZXJ2YWwjdG9Gb3JtYXR9LCBhbmQge0BsaW5rIEludGVydmFsI3RvRHVyYXRpb259LlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbnRlcnZhbCB7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5zID0gY29uZmlnLnN0YXJ0O1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZSA9IGNvbmZpZy5lbmQ7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5pbnZhbGlkID0gY29uZmlnLmludmFsaWQgfHwgbnVsbDtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmlzTHV4b25JbnRlcnZhbCA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGludmFsaWQgSW50ZXJ2YWwuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb24gLSBzaW1wbGUgc3RyaW5nIG9mIHdoeSB0aGlzIEludGVydmFsIGlzIGludmFsaWQuIFNob3VsZCBub3QgY29udGFpbiBwYXJhbWV0ZXJzIG9yIGFueXRoaW5nIGVsc2UgZGF0YS1kZXBlbmRlbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtleHBsYW5hdGlvbj1udWxsXSAtIGxvbmdlciBleHBsYW5hdGlvbiwgbWF5IGluY2x1ZGUgcGFyYW1ldGVycyBhbmQgb3RoZXIgdXNlZnVsIGRlYnVnZ2luZyBpbmZvcm1hdGlvblxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIHN0YXRpYyBpbnZhbGlkKHJlYXNvbiwgZXhwbGFuYXRpb24gPSBudWxsKSB7XG4gICAgaWYgKCFyZWFzb24pIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIm5lZWQgdG8gc3BlY2lmeSBhIHJlYXNvbiB0aGUgSW50ZXJ2YWwgaXMgaW52YWxpZFwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnZhbGlkID0gcmVhc29uIGluc3RhbmNlb2YgSW52YWxpZCA/IHJlYXNvbiA6IG5ldyBJbnZhbGlkKHJlYXNvbiwgZXhwbGFuYXRpb24pO1xuXG4gICAgaWYgKFNldHRpbmdzLnRocm93T25JbnZhbGlkKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEludGVydmFsRXJyb3IoaW52YWxpZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgSW50ZXJ2YWwoeyBpbnZhbGlkIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gSW50ZXJ2YWwgZnJvbSBhIHN0YXJ0IERhdGVUaW1lIGFuZCBhbiBlbmQgRGF0ZVRpbWUuIEluY2x1c2l2ZSBvZiB0aGUgc3RhcnQgYnV0IG5vdCB0aGUgZW5kLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfERhdGV8T2JqZWN0fSBzdGFydFxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfERhdGV8T2JqZWN0fSBlbmRcbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICBzdGF0aWMgZnJvbURhdGVUaW1lcyhzdGFydCwgZW5kKSB7XG4gICAgY29uc3QgYnVpbHRTdGFydCA9IGZyaWVuZGx5RGF0ZVRpbWUoc3RhcnQpLFxuICAgICAgYnVpbHRFbmQgPSBmcmllbmRseURhdGVUaW1lKGVuZCk7XG5cbiAgICBjb25zdCB2YWxpZGF0ZUVycm9yID0gdmFsaWRhdGVTdGFydEVuZChidWlsdFN0YXJ0LCBidWlsdEVuZCk7XG5cbiAgICBpZiAodmFsaWRhdGVFcnJvciA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbmV3IEludGVydmFsKHtcbiAgICAgICAgc3RhcnQ6IGJ1aWx0U3RhcnQsXG4gICAgICAgIGVuZDogYnVpbHRFbmQsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZhbGlkYXRlRXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBJbnRlcnZhbCBmcm9tIGEgc3RhcnQgRGF0ZVRpbWUgYW5kIGEgRHVyYXRpb24gdG8gZXh0ZW5kIHRvLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfERhdGV8T2JqZWN0fSBzdGFydFxuICAgKiBAcGFyYW0ge0R1cmF0aW9ufE9iamVjdHxudW1iZXJ9IGR1cmF0aW9uIC0gdGhlIGxlbmd0aCBvZiB0aGUgSW50ZXJ2YWwuXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgc3RhdGljIGFmdGVyKHN0YXJ0LCBkdXJhdGlvbikge1xuICAgIGNvbnN0IGR1ciA9IER1cmF0aW9uLmZyb21EdXJhdGlvbkxpa2UoZHVyYXRpb24pLFxuICAgICAgZHQgPSBmcmllbmRseURhdGVUaW1lKHN0YXJ0KTtcbiAgICByZXR1cm4gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdCwgZHQucGx1cyhkdXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gSW50ZXJ2YWwgZnJvbSBhbiBlbmQgRGF0ZVRpbWUgYW5kIGEgRHVyYXRpb24gdG8gZXh0ZW5kIGJhY2t3YXJkcyB0by5cbiAgICogQHBhcmFtIHtEYXRlVGltZXxEYXRlfE9iamVjdH0gZW5kXG4gICAqIEBwYXJhbSB7RHVyYXRpb258T2JqZWN0fG51bWJlcn0gZHVyYXRpb24gLSB0aGUgbGVuZ3RoIG9mIHRoZSBJbnRlcnZhbC5cbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICBzdGF0aWMgYmVmb3JlKGVuZCwgZHVyYXRpb24pIHtcbiAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tRHVyYXRpb25MaWtlKGR1cmF0aW9uKSxcbiAgICAgIGR0ID0gZnJpZW5kbHlEYXRlVGltZShlbmQpO1xuICAgIHJldHVybiBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0Lm1pbnVzKGR1ciksIGR0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gSW50ZXJ2YWwgZnJvbSBhbiBJU08gODYwMSBzdHJpbmcuXG4gICAqIEFjY2VwdHMgYDxzdGFydD4vPGVuZD5gLCBgPHN0YXJ0Pi88ZHVyYXRpb24+YCwgYW5kIGA8ZHVyYXRpb24+LzxlbmQ+YCBmb3JtYXRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSBJU08gc3RyaW5nIHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gLSBvcHRpb25zIHRvIHBhc3Mge0BsaW5rIERhdGVUaW1lI2Zyb21JU099IGFuZCBvcHRpb25hbGx5IHtAbGluayBEdXJhdGlvbiNmcm9tSVNPfVxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI1RpbWVfaW50ZXJ2YWxzXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgc3RhdGljIGZyb21JU08odGV4dCwgb3B0cykge1xuICAgIGNvbnN0IFtzLCBlXSA9ICh0ZXh0IHx8IFwiXCIpLnNwbGl0KFwiL1wiLCAyKTtcbiAgICBpZiAocyAmJiBlKSB7XG4gICAgICBsZXQgc3RhcnQsIHN0YXJ0SXNWYWxpZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0YXJ0ID0gRGF0ZVRpbWUuZnJvbUlTTyhzLCBvcHRzKTtcbiAgICAgICAgc3RhcnRJc1ZhbGlkID0gc3RhcnQuaXNWYWxpZDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc3RhcnRJc1ZhbGlkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGxldCBlbmQsIGVuZElzVmFsaWQ7XG4gICAgICB0cnkge1xuICAgICAgICBlbmQgPSBEYXRlVGltZS5mcm9tSVNPKGUsIG9wdHMpO1xuICAgICAgICBlbmRJc1ZhbGlkID0gZW5kLmlzVmFsaWQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVuZElzVmFsaWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXJ0SXNWYWxpZCAmJiBlbmRJc1ZhbGlkKSB7XG4gICAgICAgIHJldHVybiBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhcnRJc1ZhbGlkKSB7XG4gICAgICAgIGNvbnN0IGR1ciA9IER1cmF0aW9uLmZyb21JU08oZSwgb3B0cyk7XG4gICAgICAgIGlmIChkdXIuaXNWYWxpZCkge1xuICAgICAgICAgIHJldHVybiBJbnRlcnZhbC5hZnRlcihzdGFydCwgZHVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlbmRJc1ZhbGlkKSB7XG4gICAgICAgIGNvbnN0IGR1ciA9IER1cmF0aW9uLmZyb21JU08ocywgb3B0cyk7XG4gICAgICAgIGlmIChkdXIuaXNWYWxpZCkge1xuICAgICAgICAgIHJldHVybiBJbnRlcnZhbC5iZWZvcmUoZW5kLCBkdXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBJbnRlcnZhbC5pbnZhbGlkKFwidW5wYXJzYWJsZVwiLCBgdGhlIGlucHV0IFwiJHt0ZXh0fVwiIGNhbid0IGJlIHBhcnNlZCBhcyBJU08gODYwMWApO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIG9iamVjdCBpcyBhbiBJbnRlcnZhbC4gV29ya3MgYWNyb3NzIGNvbnRleHQgYm91bmRhcmllc1xuICAgKiBAcGFyYW0ge29iamVjdH0gb1xuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzSW50ZXJ2YWwobykge1xuICAgIHJldHVybiAobyAmJiBvLmlzTHV4b25JbnRlcnZhbCkgfHwgZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RhcnQgb2YgdGhlIEludGVydmFsXG4gICAqIEB0eXBlIHtEYXRlVGltZX1cbiAgICovXG4gIGdldCBzdGFydCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5zIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlbmQgb2YgdGhlIEludGVydmFsXG4gICAqIEB0eXBlIHtEYXRlVGltZX1cbiAgICovXG4gIGdldCBlbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuZSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwncyBlbmQgaXMgYXQgbGVhc3QgaXRzIHN0YXJ0LCBtZWFuaW5nIHRoYXQgdGhlIEludGVydmFsIGlzbid0ICdiYWNrd2FyZHMnLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiB0aGlzLmludmFsaWRSZWFzb24gPT09IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBlcnJvciBjb2RlIGlmIHRoaXMgSW50ZXJ2YWwgaXMgaW52YWxpZCwgb3IgbnVsbCBpZiB0aGUgSW50ZXJ2YWwgaXMgdmFsaWRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBpbnZhbGlkUmVhc29uKCkge1xuICAgIHJldHVybiB0aGlzLmludmFsaWQgPyB0aGlzLmludmFsaWQucmVhc29uIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGV4cGxhbmF0aW9uIG9mIHdoeSB0aGlzIEludGVydmFsIGJlY2FtZSBpbnZhbGlkLCBvciBudWxsIGlmIHRoZSBJbnRlcnZhbCBpcyB2YWxpZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGludmFsaWRFeHBsYW5hdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZhbGlkID8gdGhpcy5pbnZhbGlkLmV4cGxhbmF0aW9uIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIEludGVydmFsIGluIHRoZSBzcGVjaWZpZWQgdW5pdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSB0aGUgdW5pdCAoc3VjaCBhcyAnaG91cnMnIG9yICdkYXlzJykgdG8gcmV0dXJuIHRoZSBsZW5ndGggaW4uXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGxlbmd0aCh1bml0ID0gXCJtaWxsaXNlY29uZHNcIikge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnRvRHVyYXRpb24oLi4uW3VuaXRdKS5nZXQodW5pdCkgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY291bnQgb2YgbWludXRlcywgaG91cnMsIGRheXMsIG1vbnRocywgb3IgeWVhcnMgaW5jbHVkZWQgaW4gdGhlIEludGVydmFsLCBldmVuIGluIHBhcnQuXG4gICAqIFVubGlrZSB7QGxpbmsgSW50ZXJ2YWwjbGVuZ3RofSB0aGlzIGNvdW50cyBzZWN0aW9ucyBvZiB0aGUgY2FsZW5kYXIsIG5vdCBwZXJpb2RzIG9mIHRpbWUsIGUuZy4gc3BlY2lmeWluZyAnZGF5J1xuICAgKiBhc2tzICd3aGF0IGRhdGVzIGFyZSBpbmNsdWRlZCBpbiB0aGlzIGludGVydmFsPycsIG5vdCAnaG93IG1hbnkgZGF5cyBsb25nIGlzIHRoaXMgaW50ZXJ2YWw/J1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW3VuaXQ9J21pbGxpc2Vjb25kcyddIC0gdGhlIHVuaXQgb2YgdGltZSB0byBjb3VudC5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgY291bnQodW5pdCA9IFwibWlsbGlzZWNvbmRzXCIpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIE5hTjtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuc3RhcnQuc3RhcnRPZih1bml0KSxcbiAgICAgIGVuZCA9IHRoaXMuZW5kLnN0YXJ0T2YodW5pdCk7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoZW5kLmRpZmYoc3RhcnQsIHVuaXQpLmdldCh1bml0KSkgKyAoZW5kLnZhbHVlT2YoKSAhPT0gdGhpcy5lbmQudmFsdWVPZigpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIHN0YXJ0IGFuZCBlbmQgYXJlIGJvdGggaW4gdGhlIHNhbWUgdW5pdCBvZiB0aW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1bml0IC0gdGhlIHVuaXQgb2YgdGltZSB0byBjaGVjayBzYW1lbmVzcyBvblxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzU2FtZSh1bml0KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuaXNFbXB0eSgpIHx8IHRoaXMuZS5taW51cygxKS5oYXNTYW1lKHRoaXMucywgdW5pdCkgOiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIEludGVydmFsIGhhcyB0aGUgc2FtZSBzdGFydCBhbmQgZW5kIERhdGVUaW1lcy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMucy52YWx1ZU9mKCkgPT09IHRoaXMuZS52YWx1ZU9mKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIHN0YXJ0IGlzIGFmdGVyIHRoZSBzcGVjaWZpZWQgRGF0ZVRpbWUuXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IGRhdGVUaW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0FmdGVyKGRhdGVUaW1lKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5zID4gZGF0ZVRpbWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIGVuZCBpcyBiZWZvcmUgdGhlIHNwZWNpZmllZCBEYXRlVGltZS5cbiAgICogQHBhcmFtIHtEYXRlVGltZX0gZGF0ZVRpbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQmVmb3JlKGRhdGVUaW1lKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5lIDw9IGRhdGVUaW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwgY29udGFpbnMgdGhlIHNwZWNpZmllZCBEYXRlVGltZS5cbiAgICogQHBhcmFtIHtEYXRlVGltZX0gZGF0ZVRpbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGNvbnRhaW5zKGRhdGVUaW1lKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5zIDw9IGRhdGVUaW1lICYmIHRoaXMuZSA+IGRhdGVUaW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0c1wiIHRoZSBzdGFydCBhbmQvb3IgZW5kIGRhdGVzLiBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgSW50ZXJ2YWwuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXMgLSB0aGUgdmFsdWVzIHRvIHNldFxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSB2YWx1ZXMuc3RhcnQgLSB0aGUgc3RhcnRpbmcgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtEYXRlVGltZX0gdmFsdWVzLmVuZCAtIHRoZSBlbmRpbmcgRGF0ZVRpbWVcbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICBzZXQoeyBzdGFydCwgZW5kIH0gPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICByZXR1cm4gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhzdGFydCB8fCB0aGlzLnMsIGVuZCB8fCB0aGlzLmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0IHRoaXMgSW50ZXJ2YWwgYXQgZWFjaCBvZiB0aGUgc3BlY2lmaWVkIERhdGVUaW1lc1xuICAgKiBAcGFyYW0gey4uLkRhdGVUaW1lfSBkYXRlVGltZXMgLSB0aGUgdW5pdCBvZiB0aW1lIHRvIGNvdW50LlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHNwbGl0QXQoLi4uZGF0ZVRpbWVzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBbXTtcbiAgICBjb25zdCBzb3J0ZWQgPSBkYXRlVGltZXNcbiAgICAgICAgLm1hcChmcmllbmRseURhdGVUaW1lKVxuICAgICAgICAuZmlsdGVyKChkKSA9PiB0aGlzLmNvbnRhaW5zKGQpKVxuICAgICAgICAuc29ydCgpLFxuICAgICAgcmVzdWx0cyA9IFtdO1xuICAgIGxldCB7IHMgfSA9IHRoaXMsXG4gICAgICBpID0gMDtcblxuICAgIHdoaWxlIChzIDwgdGhpcy5lKSB7XG4gICAgICBjb25zdCBhZGRlZCA9IHNvcnRlZFtpXSB8fCB0aGlzLmUsXG4gICAgICAgIG5leHQgPSArYWRkZWQgPiArdGhpcy5lID8gdGhpcy5lIDogYWRkZWQ7XG4gICAgICByZXN1bHRzLnB1c2goSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhzLCBuZXh0KSk7XG4gICAgICBzID0gbmV4dDtcbiAgICAgIGkgKz0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdCB0aGlzIEludGVydmFsIGludG8gc21hbGxlciBJbnRlcnZhbHMsIGVhY2ggb2YgdGhlIHNwZWNpZmllZCBsZW5ndGguXG4gICAqIExlZnQgb3ZlciB0aW1lIGlzIGdyb3VwZWQgaW50byBhIHNtYWxsZXIgaW50ZXJ2YWxcbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSBsZW5ndGggb2YgZWFjaCByZXN1bHRpbmcgaW50ZXJ2YWwuXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3BsaXRCeShkdXJhdGlvbikge1xuICAgIGNvbnN0IGR1ciA9IER1cmF0aW9uLmZyb21EdXJhdGlvbkxpa2UoZHVyYXRpb24pO1xuXG4gICAgaWYgKCF0aGlzLmlzVmFsaWQgfHwgIWR1ci5pc1ZhbGlkIHx8IGR1ci5hcyhcIm1pbGxpc2Vjb25kc1wiKSA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGxldCB7IHMgfSA9IHRoaXMsXG4gICAgICBpZHggPSAxLFxuICAgICAgbmV4dDtcblxuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICB3aGlsZSAocyA8IHRoaXMuZSkge1xuICAgICAgY29uc3QgYWRkZWQgPSB0aGlzLnN0YXJ0LnBsdXMoZHVyLm1hcFVuaXRzKCh4KSA9PiB4ICogaWR4KSk7XG4gICAgICBuZXh0ID0gK2FkZGVkID4gK3RoaXMuZSA/IHRoaXMuZSA6IGFkZGVkO1xuICAgICAgcmVzdWx0cy5wdXNoKEludGVydmFsLmZyb21EYXRlVGltZXMocywgbmV4dCkpO1xuICAgICAgcyA9IG5leHQ7XG4gICAgICBpZHggKz0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdCB0aGlzIEludGVydmFsIGludG8gdGhlIHNwZWNpZmllZCBudW1iZXIgb2Ygc21hbGxlciBpbnRlcnZhbHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJPZlBhcnRzIC0gVGhlIG51bWJlciBvZiBJbnRlcnZhbHMgdG8gZGl2aWRlIHRoZSBJbnRlcnZhbCBpbnRvLlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIGRpdmlkZUVxdWFsbHkobnVtYmVyT2ZQYXJ0cykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gW107XG4gICAgcmV0dXJuIHRoaXMuc3BsaXRCeSh0aGlzLmxlbmd0aCgpIC8gbnVtYmVyT2ZQYXJ0cykuc2xpY2UoMCwgbnVtYmVyT2ZQYXJ0cyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCBvdmVybGFwcyB3aXRoIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWxcbiAgICogQHBhcmFtIHtJbnRlcnZhbH0gb3RoZXJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIG92ZXJsYXBzKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZSA+IG90aGVyLnMgJiYgdGhpcy5zIDwgb3RoZXIuZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIEludGVydmFsJ3MgZW5kIGlzIGFkamFjZW50IHRvIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWwncyBzdGFydC5cbiAgICogQHBhcmFtIHtJbnRlcnZhbH0gb3RoZXJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGFidXRzU3RhcnQob3RoZXIpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiArdGhpcy5lID09PSArb3RoZXIucztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIEludGVydmFsJ3Mgc3RhcnQgaXMgYWRqYWNlbnQgdG8gdGhlIHNwZWNpZmllZCBJbnRlcnZhbCdzIGVuZC5cbiAgICogQHBhcmFtIHtJbnRlcnZhbH0gb3RoZXJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGFidXRzRW5kKG90aGVyKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gK290aGVyLmUgPT09ICt0aGlzLnM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCBlbmd1bGZzIHRoZSBzdGFydCBhbmQgZW5kIG9mIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWwuXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBlbmd1bGZzKG90aGVyKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5zIDw9IG90aGVyLnMgJiYgdGhpcy5lID49IG90aGVyLmU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCBoYXMgdGhlIHNhbWUgc3RhcnQgYW5kIGVuZCBhcyB0aGUgc3BlY2lmaWVkIEludGVydmFsLlxuICAgKiBAcGFyYW0ge0ludGVydmFsfSBvdGhlclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQgfHwgIW90aGVyLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zLmVxdWFscyhvdGhlci5zKSAmJiB0aGlzLmUuZXF1YWxzKG90aGVyLmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBJbnRlcnZhbCByZXByZXNlbnRpbmcgdGhlIGludGVyc2VjdGlvbiBvZiB0aGlzIEludGVydmFsIGFuZCB0aGUgc3BlY2lmaWVkIEludGVydmFsLlxuICAgKiBTcGVjaWZpY2FsbHksIHRoZSByZXN1bHRpbmcgSW50ZXJ2YWwgaGFzIHRoZSBtYXhpbXVtIHN0YXJ0IHRpbWUgYW5kIHRoZSBtaW5pbXVtIGVuZCB0aW1lIG9mIHRoZSB0d28gSW50ZXJ2YWxzLlxuICAgKiBSZXR1cm5zIG51bGwgaWYgdGhlIGludGVyc2VjdGlvbiBpcyBlbXB0eSwgbWVhbmluZywgdGhlIGludGVydmFscyBkb24ndCBpbnRlcnNlY3QuXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgaW50ZXJzZWN0aW9uKG90aGVyKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IHMgPSB0aGlzLnMgPiBvdGhlci5zID8gdGhpcy5zIDogb3RoZXIucyxcbiAgICAgIGUgPSB0aGlzLmUgPCBvdGhlci5lID8gdGhpcy5lIDogb3RoZXIuZTtcblxuICAgIGlmIChzID49IGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhzLCBlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIEludGVydmFsIHJlcHJlc2VudGluZyB0aGUgdW5pb24gb2YgdGhpcyBJbnRlcnZhbCBhbmQgdGhlIHNwZWNpZmllZCBJbnRlcnZhbC5cbiAgICogU3BlY2lmaWNhbGx5LCB0aGUgcmVzdWx0aW5nIEludGVydmFsIGhhcyB0aGUgbWluaW11bSBzdGFydCB0aW1lIGFuZCB0aGUgbWF4aW11bSBlbmQgdGltZSBvZiB0aGUgdHdvIEludGVydmFscy5cbiAgICogQHBhcmFtIHtJbnRlcnZhbH0gb3RoZXJcbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICB1bmlvbihvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCBzID0gdGhpcy5zIDwgb3RoZXIucyA/IHRoaXMucyA6IG90aGVyLnMsXG4gICAgICBlID0gdGhpcy5lID4gb3RoZXIuZSA/IHRoaXMuZSA6IG90aGVyLmU7XG4gICAgcmV0dXJuIEludGVydmFsLmZyb21EYXRlVGltZXMocywgZSk7XG4gIH1cblxuICAvKipcbiAgICogTWVyZ2UgYW4gYXJyYXkgb2YgSW50ZXJ2YWxzIGludG8gYSBlcXVpdmFsZW50IG1pbmltYWwgc2V0IG9mIEludGVydmFscy5cbiAgICogQ29tYmluZXMgb3ZlcmxhcHBpbmcgYW5kIGFkamFjZW50IEludGVydmFscy5cbiAgICogQHBhcmFtIHtBcnJheX0gaW50ZXJ2YWxzXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3RhdGljIG1lcmdlKGludGVydmFscykge1xuICAgIGNvbnN0IFtmb3VuZCwgZmluYWxdID0gaW50ZXJ2YWxzXG4gICAgICAuc29ydCgoYSwgYikgPT4gYS5zIC0gYi5zKVxuICAgICAgLnJlZHVjZShcbiAgICAgICAgKFtzb2ZhciwgY3VycmVudF0sIGl0ZW0pID0+IHtcbiAgICAgICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBbc29mYXIsIGl0ZW1dO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudC5vdmVybGFwcyhpdGVtKSB8fCBjdXJyZW50LmFidXRzU3RhcnQoaXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbc29mYXIsIGN1cnJlbnQudW5pb24oaXRlbSldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW3NvZmFyLmNvbmNhdChbY3VycmVudF0pLCBpdGVtXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFtbXSwgbnVsbF1cbiAgICAgICk7XG4gICAgaWYgKGZpbmFsKSB7XG4gICAgICBmb3VuZC5wdXNoKGZpbmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIGZvdW5kO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBhcnJheSBvZiBJbnRlcnZhbHMgcmVwcmVzZW50aW5nIHRoZSBzcGFucyBvZiB0aW1lIHRoYXQgb25seSBhcHBlYXIgaW4gb25lIG9mIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWxzLlxuICAgKiBAcGFyYW0ge0FycmF5fSBpbnRlcnZhbHNcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzdGF0aWMgeG9yKGludGVydmFscykge1xuICAgIGxldCBzdGFydCA9IG51bGwsXG4gICAgICBjdXJyZW50Q291bnQgPSAwO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXSxcbiAgICAgIGVuZHMgPSBpbnRlcnZhbHMubWFwKChpKSA9PiBbXG4gICAgICAgIHsgdGltZTogaS5zLCB0eXBlOiBcInNcIiB9LFxuICAgICAgICB7IHRpbWU6IGkuZSwgdHlwZTogXCJlXCIgfSxcbiAgICAgIF0pLFxuICAgICAgZmxhdHRlbmVkID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdCguLi5lbmRzKSxcbiAgICAgIGFyciA9IGZsYXR0ZW5lZC5zb3J0KChhLCBiKSA9PiBhLnRpbWUgLSBiLnRpbWUpO1xuXG4gICAgZm9yIChjb25zdCBpIG9mIGFycikge1xuICAgICAgY3VycmVudENvdW50ICs9IGkudHlwZSA9PT0gXCJzXCIgPyAxIDogLTE7XG5cbiAgICAgIGlmIChjdXJyZW50Q291bnQgPT09IDEpIHtcbiAgICAgICAgc3RhcnQgPSBpLnRpbWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc3RhcnQgJiYgK3N0YXJ0ICE9PSAraS50aW1lKSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKEludGVydmFsLmZyb21EYXRlVGltZXMoc3RhcnQsIGkudGltZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBJbnRlcnZhbC5tZXJnZShyZXN1bHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gSW50ZXJ2YWwgcmVwcmVzZW50aW5nIHRoZSBzcGFuIG9mIHRpbWUgaW4gdGhpcyBJbnRlcnZhbCB0aGF0IGRvZXNuJ3Qgb3ZlcmxhcCB3aXRoIGFueSBvZiB0aGUgc3BlY2lmaWVkIEludGVydmFscy5cbiAgICogQHBhcmFtIHsuLi5JbnRlcnZhbH0gaW50ZXJ2YWxzXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgZGlmZmVyZW5jZSguLi5pbnRlcnZhbHMpIHtcbiAgICByZXR1cm4gSW50ZXJ2YWwueG9yKFt0aGlzXS5jb25jYXQoaW50ZXJ2YWxzKSlcbiAgICAgIC5tYXAoKGkpID0+IHRoaXMuaW50ZXJzZWN0aW9uKGkpKVxuICAgICAgLmZpbHRlcigoaSkgPT4gaSAmJiAhaS5pc0VtcHR5KCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBJbnRlcnZhbCBhcHByb3ByaWF0ZSBmb3IgZGVidWdnaW5nLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIElOVkFMSUQ7XG4gICAgcmV0dXJuIGBbJHt0aGlzLnMudG9JU08oKX0g4oCTICR7dGhpcy5lLnRvSVNPKCl9KWA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxvY2FsaXplZCBzdHJpbmcgcmVwcmVzZW50aW5nIHRoaXMgSW50ZXJ2YWwuIEFjY2VwdHMgdGhlIHNhbWUgb3B0aW9ucyBhcyB0aGVcbiAgICogSW50bC5EYXRlVGltZUZvcm1hdCBjb25zdHJ1Y3RvciBhbmQgYW55IHByZXNldHMgZGVmaW5lZCBieSBMdXhvbiwgc3VjaCBhc1xuICAgKiB7QGxpbmsgRGF0ZVRpbWUuREFURV9GVUxMfSBvciB7QGxpbmsgRGF0ZVRpbWUuVElNRV9TSU1QTEV9LiBUaGUgZXhhY3QgYmVoYXZpb3Igb2YgdGhpcyBtZXRob2RcbiAgICogaXMgYnJvd3Nlci1zcGVjaWZpYywgYnV0IGluIGdlbmVyYWwgaXQgd2lsbCByZXR1cm4gYW4gYXBwcm9wcmlhdGUgcmVwcmVzZW50YXRpb24gb2YgdGhlXG4gICAqIEludGVydmFsIGluIHRoZSBhc3NpZ25lZCBsb2NhbGUuIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuXG4gICAqIHNwZWNpZmllZC5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlVGltZUZvcm1hdFxuICAgKiBAcGFyYW0ge09iamVjdH0gW2Zvcm1hdE9wdHM9RGF0ZVRpbWUuREFURV9TSE9SVF0gLSBFaXRoZXIgYSBEYXRlVGltZSBwcmVzZXQgb3JcbiAgICogSW50bC5EYXRlVGltZUZvcm1hdCBjb25zdHJ1Y3RvciBvcHRpb25zLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIE9wdGlvbnMgdG8gb3ZlcnJpZGUgdGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIHN0YXJ0IERhdGVUaW1lLlxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tSVNPKCcyMDIyLTExLTA3VDA5OjAwWi8yMDIyLTExLTA4VDA5OjAwWicpLnRvTG9jYWxlU3RyaW5nKCk7IC8vPT4gMTEvNy8yMDIyIOKAkyAxMS84LzIwMjJcbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbUlTTygnMjAyMi0xMS0wN1QwOTowMFovMjAyMi0xMS0wOFQwOTowMFonKS50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5EQVRFX0ZVTEwpOyAvLz0+IE5vdmVtYmVyIDcg4oCTIDgsIDIwMjJcbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbUlTTygnMjAyMi0xMS0wN1QwOTowMFovMjAyMi0xMS0wOFQwOTowMFonKS50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5EQVRFX0ZVTEwsIHsgbG9jYWxlOiAnZnItRlInIH0pOyAvLz0+IDfigJM4IG5vdmVtYnJlIDIwMjJcbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbUlTTygnMjAyMi0xMS0wN1QxNzowMFovMjAyMi0xMS0wN1QxOTowMFonKS50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5USU1FX1NJTVBMRSk7IC8vPT4gNjowMCDigJMgODowMCBQTVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tSVNPKCcyMDIyLTExLTA3VDE3OjAwWi8yMDIyLTExLTA3VDE5OjAwWicpLnRvTG9jYWxlU3RyaW5nKHsgd2Vla2RheTogJ3Nob3J0JywgbW9udGg6ICdzaG9ydCcsIGRheTogJzItZGlnaXQnLCBob3VyOiAnMi1kaWdpdCcsIG1pbnV0ZTogJzItZGlnaXQnIH0pOyAvLz0+IE1vbiwgTm92IDA3LCA2OjAwIOKAkyA4OjAwIHBcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9Mb2NhbGVTdHJpbmcoZm9ybWF0T3B0cyA9IEZvcm1hdHMuREFURV9TSE9SVCwgb3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZFxuICAgICAgPyBGb3JtYXR0ZXIuY3JlYXRlKHRoaXMucy5sb2MuY2xvbmUob3B0cyksIGZvcm1hdE9wdHMpLmZvcm1hdEludGVydmFsKHRoaXMpXG4gICAgICA6IElOVkFMSUQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgSW50ZXJ2YWwuXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjVGltZV9pbnRlcnZhbHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBUaGUgc2FtZSBvcHRpb25zIGFzIHtAbGluayBEYXRlVGltZSN0b0lTT31cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9JU08ob3B0cykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gSU5WQUxJRDtcbiAgICByZXR1cm4gYCR7dGhpcy5zLnRvSVNPKG9wdHMpfS8ke3RoaXMuZS50b0lTTyhvcHRzKX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBkYXRlIG9mIHRoaXMgSW50ZXJ2YWwuXG4gICAqIFRoZSB0aW1lIGNvbXBvbmVudHMgYXJlIGlnbm9yZWQuXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjVGltZV9pbnRlcnZhbHNcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9JU09EYXRlKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gSU5WQUxJRDtcbiAgICByZXR1cm4gYCR7dGhpcy5zLnRvSVNPRGF0ZSgpfS8ke3RoaXMuZS50b0lTT0RhdGUoKX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aW1lIG9mIHRoaXMgSW50ZXJ2YWwuXG4gICAqIFRoZSBkYXRlIGNvbXBvbmVudHMgYXJlIGlnbm9yZWQuXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjVGltZV9pbnRlcnZhbHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBUaGUgc2FtZSBvcHRpb25zIGFzIHtAbGluayBEYXRlVGltZSN0b0lTT31cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9JU09UaW1lKG9wdHMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIElOVkFMSUQ7XG4gICAgcmV0dXJuIGAke3RoaXMucy50b0lTT1RpbWUob3B0cyl9LyR7dGhpcy5lLnRvSVNPVGltZShvcHRzKX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBJbnRlcnZhbCBmb3JtYXR0ZWQgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgZm9ybWF0XG4gICAqIHN0cmluZy4gKipZb3UgbWF5IG5vdCB3YW50IHRoaXMuKiogU2VlIHtAbGluayBJbnRlcnZhbCN0b0xvY2FsZVN0cmluZ30gZm9yIGEgbW9yZSBmbGV4aWJsZVxuICAgKiBmb3JtYXR0aW5nIHRvb2wuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRlRm9ybWF0IC0gVGhlIGZvcm1hdCBzdHJpbmcuIFRoaXMgc3RyaW5nIGZvcm1hdHMgdGhlIHN0YXJ0IGFuZCBlbmQgdGltZS5cbiAgICogU2VlIHtAbGluayBEYXRlVGltZSN0b0Zvcm1hdH0gZm9yIGRldGFpbHMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gT3B0aW9ucy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnNlcGFyYXRvciA9ICAnIOKAkyAnXSAtIEEgc2VwYXJhdG9yIHRvIHBsYWNlIGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBlbmRcbiAgICogcmVwcmVzZW50YXRpb25zLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0Zvcm1hdChkYXRlRm9ybWF0LCB7IHNlcGFyYXRvciA9IFwiIOKAkyBcIiB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIElOVkFMSUQ7XG4gICAgcmV0dXJuIGAke3RoaXMucy50b0Zvcm1hdChkYXRlRm9ybWF0KX0ke3NlcGFyYXRvcn0ke3RoaXMuZS50b0Zvcm1hdChkYXRlRm9ybWF0KX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIER1cmF0aW9uIHJlcHJlc2VudGluZyB0aGUgdGltZSBzcGFubmVkIGJ5IHRoaXMgaW50ZXJ2YWwuXG4gICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBbdW5pdD1bJ21pbGxpc2Vjb25kcyddXSAtIHRoZSB1bml0IG9yIHVuaXRzIChzdWNoIGFzICdob3Vycycgb3IgJ2RheXMnKSB0byBpbmNsdWRlIGluIHRoZSBkdXJhdGlvbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRoYXQgYWZmZWN0IHRoZSBjcmVhdGlvbiBvZiB0aGUgRHVyYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmNvbnZlcnNpb25BY2N1cmFjeT0nY2FzdWFsJ10gLSB0aGUgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQxLCBkdDIpLnRvRHVyYXRpb24oKS50b09iamVjdCgpIC8vPT4geyBtaWxsaXNlY29uZHM6IDg4NDg5MjU3IH1cbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdDEsIGR0MikudG9EdXJhdGlvbignZGF5cycpLnRvT2JqZWN0KCkgLy89PiB7IGRheXM6IDEuMDI0MTgxMjE1Mjc3Nzc3OCB9XG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQxLCBkdDIpLnRvRHVyYXRpb24oWydob3VycycsICdtaW51dGVzJ10pLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAyNCwgbWludXRlczogMzQuODIwOTUgfVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0MSwgZHQyKS50b0R1cmF0aW9uKFsnaG91cnMnLCAnbWludXRlcycsICdzZWNvbmRzJ10pLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAyNCwgbWludXRlczogMzQsIHNlY29uZHM6IDQ5LjI1NyB9XG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQxLCBkdDIpLnRvRHVyYXRpb24oJ3NlY29uZHMnKS50b09iamVjdCgpIC8vPT4geyBzZWNvbmRzOiA4ODQ4OS4yNTcgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHRvRHVyYXRpb24odW5pdCwgb3B0cykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gRHVyYXRpb24uaW52YWxpZCh0aGlzLmludmFsaWRSZWFzb24pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lLmRpZmYodGhpcy5zLCB1bml0LCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW4gbWFwRm4gb24gdGhlIGludGVydmFsIHN0YXJ0IGFuZCBlbmQsIHJldHVybmluZyBhIG5ldyBJbnRlcnZhbCBmcm9tIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWVzXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG1hcEZuXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0MSwgZHQyKS5tYXBFbmRwb2ludHMoZW5kcG9pbnQgPT4gZW5kcG9pbnQudG9VVEMoKSlcbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdDEsIGR0MikubWFwRW5kcG9pbnRzKGVuZHBvaW50ID0+IGVuZHBvaW50LnBsdXMoeyBob3VyczogMiB9KSlcbiAgICovXG4gIG1hcEVuZHBvaW50cyhtYXBGbikge1xuICAgIHJldHVybiBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKG1hcEZuKHRoaXMucyksIG1hcEZuKHRoaXMuZSkpO1xuICB9XG59XG4iLCAiaW1wb3J0IERhdGVUaW1lIGZyb20gXCIuL2RhdGV0aW1lLmpzXCI7XG5pbXBvcnQgU2V0dGluZ3MgZnJvbSBcIi4vc2V0dGluZ3MuanNcIjtcbmltcG9ydCBMb2NhbGUgZnJvbSBcIi4vaW1wbC9sb2NhbGUuanNcIjtcbmltcG9ydCBJQU5BWm9uZSBmcm9tIFwiLi96b25lcy9JQU5BWm9uZS5qc1wiO1xuaW1wb3J0IHsgbm9ybWFsaXplWm9uZSB9IGZyb20gXCIuL2ltcGwvem9uZVV0aWwuanNcIjtcblxuaW1wb3J0IHsgaGFzUmVsYXRpdmUgfSBmcm9tIFwiLi9pbXBsL3V0aWwuanNcIjtcblxuLyoqXG4gKiBUaGUgSW5mbyBjbGFzcyBjb250YWlucyBzdGF0aWMgbWV0aG9kcyBmb3IgcmV0cmlldmluZyBnZW5lcmFsIHRpbWUgYW5kIGRhdGUgcmVsYXRlZCBkYXRhLiBGb3IgZXhhbXBsZSwgaXQgaGFzIG1ldGhvZHMgZm9yIGZpbmRpbmcgb3V0IGlmIGEgdGltZSB6b25lIGhhcyBhIERTVCwgZm9yIGxpc3RpbmcgdGhlIG1vbnRocyBpbiBhbnkgc3VwcG9ydGVkIGxvY2FsZSwgYW5kIGZvciBkaXNjb3ZlcmluZyB3aGljaCBvZiBMdXhvbiBmZWF0dXJlcyBhcmUgYXZhaWxhYmxlIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50LlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbmZvIHtcbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgem9uZSBjb250YWlucyBhIERTVC5cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW3pvbmU9J2xvY2FsJ10gLSBab25lIHRvIGNoZWNrLiBEZWZhdWx0cyB0byB0aGUgZW52aXJvbm1lbnQncyBsb2NhbCB6b25lLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGhhc0RTVCh6b25lID0gU2V0dGluZ3MuZGVmYXVsdFpvbmUpIHtcbiAgICBjb25zdCBwcm90byA9IERhdGVUaW1lLm5vdygpLnNldFpvbmUoem9uZSkuc2V0KHsgbW9udGg6IDEyIH0pO1xuXG4gICAgcmV0dXJuICF6b25lLmlzVW5pdmVyc2FsICYmIHByb3RvLm9mZnNldCAhPT0gcHJvdG8uc2V0KHsgbW9udGg6IDYgfSkub2Zmc2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgem9uZSBpcyBhIHZhbGlkIElBTkEgc3BlY2lmaWVyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gem9uZSAtIFpvbmUgdG8gY2hlY2tcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc1ZhbGlkSUFOQVpvbmUoem9uZSkge1xuICAgIHJldHVybiBJQU5BWm9uZS5pc1ZhbGlkWm9uZSh6b25lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgaW5wdXQgaW50byBhIHtAbGluayBab25lfSBpbnN0YW5jZS5cbiAgICpcbiAgICogKiBJZiBgaW5wdXRgIGlzIGFscmVhZHkgYSBab25lIGluc3RhbmNlLCBpdCBpcyByZXR1cm5lZCB1bmNoYW5nZWQuXG4gICAqICogSWYgYGlucHV0YCBpcyBhIHN0cmluZyBjb250YWluaW5nIGEgdmFsaWQgdGltZSB6b25lIG5hbWUsIGEgWm9uZSBpbnN0YW5jZVxuICAgKiAgIHdpdGggdGhhdCBuYW1lIGlzIHJldHVybmVkLlxuICAgKiAqIElmIGBpbnB1dGAgaXMgYSBzdHJpbmcgdGhhdCBkb2Vzbid0IHJlZmVyIHRvIGEga25vd24gdGltZSB6b25lLCBhIFpvbmVcbiAgICogICBpbnN0YW5jZSB3aXRoIHtAbGluayBab25lI2lzVmFsaWR9ID09IGZhbHNlIGlzIHJldHVybmVkLlxuICAgKiAqIElmIGBpbnB1dCBpcyBhIG51bWJlciwgYSBab25lIGluc3RhbmNlIHdpdGggdGhlIHNwZWNpZmllZCBmaXhlZCBvZmZzZXRcbiAgICogICBpbiBtaW51dGVzIGlzIHJldHVybmVkLlxuICAgKiAqIElmIGBpbnB1dGAgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgLCB0aGUgZGVmYXVsdCB6b25lIGlzIHJldHVybmVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfG51bWJlcn0gW2lucHV0XSAtIHRoZSB2YWx1ZSB0byBiZSBjb252ZXJ0ZWRcbiAgICogQHJldHVybiB7Wm9uZX1cbiAgICovXG4gIHN0YXRpYyBub3JtYWxpemVab25lKGlucHV0KSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZVpvbmUoaW5wdXQsIFNldHRpbmdzLmRlZmF1bHRab25lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2Ygc3RhbmRhbG9uZSBtb250aCBuYW1lcy5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlVGltZUZvcm1hdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xlbmd0aD0nbG9uZyddIC0gdGhlIGxlbmd0aCBvZiB0aGUgbW9udGggcmVwcmVzZW50YXRpb24sIHN1Y2ggYXMgXCJudW1lcmljXCIsIFwiMi1kaWdpdFwiLCBcIm5hcnJvd1wiLCBcInNob3J0XCIsIFwibG9uZ1wiXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlXSAtIHRoZSBsb2NhbGUgY29kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubnVtYmVyaW5nU3lzdGVtPW51bGxdIC0gdGhlIG51bWJlcmluZyBzeXN0ZW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY09iaj1udWxsXSAtIGFuIGV4aXN0aW5nIGxvY2FsZSBvYmplY3QgdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5vdXRwdXRDYWxlbmRhcj0nZ3JlZ29yeSddIC0gdGhlIGNhbGVuZGFyXG4gICAqIEBleGFtcGxlIEluZm8ubW9udGhzKClbMF0gLy89PiAnSmFudWFyeSdcbiAgICogQGV4YW1wbGUgSW5mby5tb250aHMoJ3Nob3J0JylbMF0gLy89PiAnSmFuJ1xuICAgKiBAZXhhbXBsZSBJbmZvLm1vbnRocygnbnVtZXJpYycpWzBdIC8vPT4gJzEnXG4gICAqIEBleGFtcGxlIEluZm8ubW9udGhzKCdzaG9ydCcsIHsgbG9jYWxlOiAnZnItQ0EnIH0gKVswXSAvLz0+ICdqYW52LidcbiAgICogQGV4YW1wbGUgSW5mby5tb250aHMoJ251bWVyaWMnLCB7IGxvY2FsZTogJ2FyJyB9KVswXSAvLz0+ICfZoSdcbiAgICogQGV4YW1wbGUgSW5mby5tb250aHMoJ2xvbmcnLCB7IG91dHB1dENhbGVuZGFyOiAnaXNsYW1pYycgfSlbMF0gLy89PiAnUmFiacq7IEknXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3RhdGljIG1vbnRocyhcbiAgICBsZW5ndGggPSBcImxvbmdcIixcbiAgICB7IGxvY2FsZSA9IG51bGwsIG51bWJlcmluZ1N5c3RlbSA9IG51bGwsIGxvY09iaiA9IG51bGwsIG91dHB1dENhbGVuZGFyID0gXCJncmVnb3J5XCIgfSA9IHt9XG4gICkge1xuICAgIHJldHVybiAobG9jT2JqIHx8IExvY2FsZS5jcmVhdGUobG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyKSkubW9udGhzKGxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGFycmF5IG9mIGZvcm1hdCBtb250aCBuYW1lcy5cbiAgICogRm9ybWF0IG1vbnRocyBkaWZmZXIgZnJvbSBzdGFuZGFsb25lIG1vbnRocyBpbiB0aGF0IHRoZXkncmUgbWVhbnQgdG8gYXBwZWFyIG5leHQgdG8gdGhlIGRheSBvZiB0aGUgbW9udGguIEluIHNvbWUgbGFuZ3VhZ2VzLCB0aGF0XG4gICAqIGNoYW5nZXMgdGhlIHN0cmluZy5cbiAgICogU2VlIHtAbGluayBJbmZvI21vbnRoc31cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsZW5ndGg9J2xvbmcnXSAtIHRoZSBsZW5ndGggb2YgdGhlIG1vbnRoIHJlcHJlc2VudGF0aW9uLCBzdWNoIGFzIFwibnVtZXJpY1wiLCBcIjItZGlnaXRcIiwgXCJuYXJyb3dcIiwgXCJzaG9ydFwiLCBcImxvbmdcIlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZV0gLSB0aGUgbG9jYWxlIGNvZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm51bWJlcmluZ1N5c3RlbT1udWxsXSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NPYmo9bnVsbF0gLSBhbiBleGlzdGluZyBsb2NhbGUgb2JqZWN0IHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMub3V0cHV0Q2FsZW5kYXI9J2dyZWdvcnknXSAtIHRoZSBjYWxlbmRhclxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyBtb250aHNGb3JtYXQoXG4gICAgbGVuZ3RoID0gXCJsb25nXCIsXG4gICAgeyBsb2NhbGUgPSBudWxsLCBudW1iZXJpbmdTeXN0ZW0gPSBudWxsLCBsb2NPYmogPSBudWxsLCBvdXRwdXRDYWxlbmRhciA9IFwiZ3JlZ29yeVwiIH0gPSB7fVxuICApIHtcbiAgICByZXR1cm4gKGxvY09iaiB8fCBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhcikpLm1vbnRocyhsZW5ndGgsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBhcnJheSBvZiBzdGFuZGFsb25lIHdlZWsgbmFtZXMuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZVRpbWVGb3JtYXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsZW5ndGg9J2xvbmcnXSAtIHRoZSBsZW5ndGggb2YgdGhlIHdlZWtkYXkgcmVwcmVzZW50YXRpb24sIHN1Y2ggYXMgXCJuYXJyb3dcIiwgXCJzaG9ydFwiLCBcImxvbmdcIi5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGVdIC0gdGhlIGxvY2FsZSBjb2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5udW1iZXJpbmdTeXN0ZW09bnVsbF0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jT2JqPW51bGxdIC0gYW4gZXhpc3RpbmcgbG9jYWxlIG9iamVjdCB0byB1c2VcbiAgICogQGV4YW1wbGUgSW5mby53ZWVrZGF5cygpWzBdIC8vPT4gJ01vbmRheSdcbiAgICogQGV4YW1wbGUgSW5mby53ZWVrZGF5cygnc2hvcnQnKVswXSAvLz0+ICdNb24nXG4gICAqIEBleGFtcGxlIEluZm8ud2Vla2RheXMoJ3Nob3J0JywgeyBsb2NhbGU6ICdmci1DQScgfSlbMF0gLy89PiAnbHVuLidcbiAgICogQGV4YW1wbGUgSW5mby53ZWVrZGF5cygnc2hvcnQnLCB7IGxvY2FsZTogJ2FyJyB9KVswXSAvLz0+ICfYp9mE2KfYq9mG2YrZhidcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzdGF0aWMgd2Vla2RheXMobGVuZ3RoID0gXCJsb25nXCIsIHsgbG9jYWxlID0gbnVsbCwgbnVtYmVyaW5nU3lzdGVtID0gbnVsbCwgbG9jT2JqID0gbnVsbCB9ID0ge30pIHtcbiAgICByZXR1cm4gKGxvY09iaiB8fCBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBudWxsKSkud2Vla2RheXMobGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgZm9ybWF0IHdlZWsgbmFtZXMuXG4gICAqIEZvcm1hdCB3ZWVrZGF5cyBkaWZmZXIgZnJvbSBzdGFuZGFsb25lIHdlZWtkYXlzIGluIHRoYXQgdGhleSdyZSBtZWFudCB0byBhcHBlYXIgbmV4dCB0byBtb3JlIGRhdGUgaW5mb3JtYXRpb24uIEluIHNvbWUgbGFuZ3VhZ2VzLCB0aGF0XG4gICAqIGNoYW5nZXMgdGhlIHN0cmluZy5cbiAgICogU2VlIHtAbGluayBJbmZvI3dlZWtkYXlzfVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xlbmd0aD0nbG9uZyddIC0gdGhlIGxlbmd0aCBvZiB0aGUgbW9udGggcmVwcmVzZW50YXRpb24sIHN1Y2ggYXMgXCJuYXJyb3dcIiwgXCJzaG9ydFwiLCBcImxvbmdcIi5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9bnVsbF0gLSB0aGUgbG9jYWxlIGNvZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm51bWJlcmluZ1N5c3RlbT1udWxsXSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NPYmo9bnVsbF0gLSBhbiBleGlzdGluZyBsb2NhbGUgb2JqZWN0IHRvIHVzZVxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyB3ZWVrZGF5c0Zvcm1hdChcbiAgICBsZW5ndGggPSBcImxvbmdcIixcbiAgICB7IGxvY2FsZSA9IG51bGwsIG51bWJlcmluZ1N5c3RlbSA9IG51bGwsIGxvY09iaiA9IG51bGwgfSA9IHt9XG4gICkge1xuICAgIHJldHVybiAobG9jT2JqIHx8IExvY2FsZS5jcmVhdGUobG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG51bGwpKS53ZWVrZGF5cyhsZW5ndGgsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBhcnJheSBvZiBtZXJpZGllbXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlXSAtIHRoZSBsb2NhbGUgY29kZVxuICAgKiBAZXhhbXBsZSBJbmZvLm1lcmlkaWVtcygpIC8vPT4gWyAnQU0nLCAnUE0nIF1cbiAgICogQGV4YW1wbGUgSW5mby5tZXJpZGllbXMoeyBsb2NhbGU6ICdteScgfSkgLy89PiBbICfhgJThgLbhgJThgIDhgLonLCAn4YCK4YCU4YCxJyBdXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3RhdGljIG1lcmlkaWVtcyh7IGxvY2FsZSA9IG51bGwgfSA9IHt9KSB7XG4gICAgcmV0dXJuIExvY2FsZS5jcmVhdGUobG9jYWxlKS5tZXJpZGllbXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgZXJhcywgc3VjaCBhcyBbJ0JDJywgJ0FEJ10uIFRoZSBsb2NhbGUgY2FuIGJlIHNwZWNpZmllZCwgYnV0IHRoZSBjYWxlbmRhciBzeXN0ZW0gaXMgYWx3YXlzIEdyZWdvcmlhbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsZW5ndGg9J3Nob3J0J10gLSB0aGUgbGVuZ3RoIG9mIHRoZSBlcmEgcmVwcmVzZW50YXRpb24sIHN1Y2ggYXMgXCJzaG9ydFwiIG9yIFwibG9uZ1wiLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZV0gLSB0aGUgbG9jYWxlIGNvZGVcbiAgICogQGV4YW1wbGUgSW5mby5lcmFzKCkgLy89PiBbICdCQycsICdBRCcgXVxuICAgKiBAZXhhbXBsZSBJbmZvLmVyYXMoJ2xvbmcnKSAvLz0+IFsgJ0JlZm9yZSBDaHJpc3QnLCAnQW5ubyBEb21pbmknIF1cbiAgICogQGV4YW1wbGUgSW5mby5lcmFzKCdsb25nJywgeyBsb2NhbGU6ICdmcicgfSkgLy89PiBbICdhdmFudCBKw6lzdXMtQ2hyaXN0JywgJ2FwcsOocyBKw6lzdXMtQ2hyaXN0JyBdXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3RhdGljIGVyYXMobGVuZ3RoID0gXCJzaG9ydFwiLCB7IGxvY2FsZSA9IG51bGwgfSA9IHt9KSB7XG4gICAgcmV0dXJuIExvY2FsZS5jcmVhdGUobG9jYWxlLCBudWxsLCBcImdyZWdvcnlcIikuZXJhcyhsZW5ndGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgc2V0IG9mIGF2YWlsYWJsZSBmZWF0dXJlcyBpbiB0aGlzIGVudmlyb25tZW50LlxuICAgKiBTb21lIGZlYXR1cmVzIG9mIEx1eG9uIGFyZSBub3QgYXZhaWxhYmxlIGluIGFsbCBlbnZpcm9ubWVudHMuIEZvciBleGFtcGxlLCBvbiBvbGRlciBicm93c2VycywgcmVsYXRpdmUgdGltZSBmb3JtYXR0aW5nIHN1cHBvcnQgaXMgbm90IGF2YWlsYWJsZS4gVXNlIHRoaXMgZnVuY3Rpb24gdG8gZmlndXJlIG91dCBpZiB0aGF0J3MgdGhlIGNhc2UuXG4gICAqIEtleXM6XG4gICAqICogYHJlbGF0aXZlYDogd2hldGhlciB0aGlzIGVudmlyb25tZW50IHN1cHBvcnRzIHJlbGF0aXZlIHRpbWUgZm9ybWF0dGluZ1xuICAgKiBAZXhhbXBsZSBJbmZvLmZlYXR1cmVzKCkgLy89PiB7IHJlbGF0aXZlOiBmYWxzZSB9XG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBmZWF0dXJlcygpIHtcbiAgICByZXR1cm4geyByZWxhdGl2ZTogaGFzUmVsYXRpdmUoKSB9O1xuICB9XG59XG4iLCAiaW1wb3J0IER1cmF0aW9uIGZyb20gXCIuLi9kdXJhdGlvbi5qc1wiO1xuXG5mdW5jdGlvbiBkYXlEaWZmKGVhcmxpZXIsIGxhdGVyKSB7XG4gIGNvbnN0IHV0Y0RheVN0YXJ0ID0gKGR0KSA9PiBkdC50b1VUQygwLCB7IGtlZXBMb2NhbFRpbWU6IHRydWUgfSkuc3RhcnRPZihcImRheVwiKS52YWx1ZU9mKCksXG4gICAgbXMgPSB1dGNEYXlTdGFydChsYXRlcikgLSB1dGNEYXlTdGFydChlYXJsaWVyKTtcbiAgcmV0dXJuIE1hdGguZmxvb3IoRHVyYXRpb24uZnJvbU1pbGxpcyhtcykuYXMoXCJkYXlzXCIpKTtcbn1cblxuZnVuY3Rpb24gaGlnaE9yZGVyRGlmZnMoY3Vyc29yLCBsYXRlciwgdW5pdHMpIHtcbiAgY29uc3QgZGlmZmVycyA9IFtcbiAgICBbXCJ5ZWFyc1wiLCAoYSwgYikgPT4gYi55ZWFyIC0gYS55ZWFyXSxcbiAgICBbXCJxdWFydGVyc1wiLCAoYSwgYikgPT4gYi5xdWFydGVyIC0gYS5xdWFydGVyICsgKGIueWVhciAtIGEueWVhcikgKiA0XSxcbiAgICBbXCJtb250aHNcIiwgKGEsIGIpID0+IGIubW9udGggLSBhLm1vbnRoICsgKGIueWVhciAtIGEueWVhcikgKiAxMl0sXG4gICAgW1xuICAgICAgXCJ3ZWVrc1wiLFxuICAgICAgKGEsIGIpID0+IHtcbiAgICAgICAgY29uc3QgZGF5cyA9IGRheURpZmYoYSwgYik7XG4gICAgICAgIHJldHVybiAoZGF5cyAtIChkYXlzICUgNykpIC8gNztcbiAgICAgIH0sXG4gICAgXSxcbiAgICBbXCJkYXlzXCIsIGRheURpZmZdLFxuICBdO1xuXG4gIGNvbnN0IHJlc3VsdHMgPSB7fTtcbiAgY29uc3QgZWFybGllciA9IGN1cnNvcjtcbiAgbGV0IGxvd2VzdE9yZGVyLCBoaWdoV2F0ZXI7XG5cbiAgLyogVGhpcyBsb29wIHRyaWVzIHRvIGRpZmYgdXNpbmcgbGFyZ2VyIHVuaXRzIGZpcnN0LlxuICAgICBJZiB3ZSBvdmVyc2hvb3QsIHdlIGJhY2t0cmFjayBhbmQgdHJ5IHRoZSBuZXh0IHNtYWxsZXIgdW5pdC5cbiAgICAgXCJjdXJzb3JcIiBzdGFydHMgb3V0IGF0IHRoZSBlYXJsaWVyIHRpbWVzdGFtcCBhbmQgbW92ZXMgY2xvc2VyIGFuZCBjbG9zZXIgdG8gXCJsYXRlclwiXG4gICAgIGFzIHdlIHVzZSBzbWFsbGVyIGFuZCBzbWFsbGVyIHVuaXRzLlxuICAgICBoaWdoV2F0ZXIga2VlcHMgdHJhY2sgb2Ygd2hlcmUgd2Ugd291bGQgYmUgaWYgd2UgYWRkZWQgb25lIG1vcmUgb2YgdGhlIHNtYWxsZXN0IHVuaXQsXG4gICAgIHRoaXMgaXMgdXNlZCBsYXRlciB0byBwb3RlbnRpYWxseSBjb252ZXJ0IGFueSBkaWZmZXJlbmNlIHNtYWxsZXIgdGhhbiB0aGUgc21hbGxlc3QgaGlnaGVyIG9yZGVyIHVuaXRcbiAgICAgaW50byBhIGZyYWN0aW9uIG9mIHRoYXQgc21hbGxlc3QgaGlnaGVyIG9yZGVyIHVuaXRcbiAgKi9cbiAgZm9yIChjb25zdCBbdW5pdCwgZGlmZmVyXSBvZiBkaWZmZXJzKSB7XG4gICAgaWYgKHVuaXRzLmluZGV4T2YodW5pdCkgPj0gMCkge1xuICAgICAgbG93ZXN0T3JkZXIgPSB1bml0O1xuXG4gICAgICByZXN1bHRzW3VuaXRdID0gZGlmZmVyKGN1cnNvciwgbGF0ZXIpO1xuICAgICAgaGlnaFdhdGVyID0gZWFybGllci5wbHVzKHJlc3VsdHMpO1xuXG4gICAgICBpZiAoaGlnaFdhdGVyID4gbGF0ZXIpIHtcbiAgICAgICAgLy8gd2Ugb3ZlcnNob3QgdGhlIGVuZCBwb2ludCwgYmFja3RyYWNrIGN1cnNvciBieSAxXG4gICAgICAgIHJlc3VsdHNbdW5pdF0tLTtcbiAgICAgICAgY3Vyc29yID0gZWFybGllci5wbHVzKHJlc3VsdHMpO1xuXG4gICAgICAgIC8vIGlmIHdlIGFyZSBzdGlsbCBvdmVyc2hvb3Rpbmcgbm93LCB3ZSBuZWVkIHRvIGJhY2t0cmFjayBhZ2FpblxuICAgICAgICAvLyB0aGlzIGhhcHBlbnMgaW4gY2VydGFpbiBzaXR1YXRpb25zIHdoZW4gZGlmZmluZyB0aW1lcyBpbiBkaWZmZXJlbnQgem9uZXMsXG4gICAgICAgIC8vIGJlY2F1c2UgdGhpcyBjYWxjdWxhdGlvbiBpZ25vcmVzIHRpbWUgem9uZXNcbiAgICAgICAgaWYgKGN1cnNvciA+IGxhdGVyKSB7XG4gICAgICAgICAgLy8ga2VlcCB0aGUgXCJvdmVyc2hvdCBieSAxXCIgYXJvdW5kIGFzIGhpZ2hXYXRlclxuICAgICAgICAgIGhpZ2hXYXRlciA9IGN1cnNvcjtcbiAgICAgICAgICAvLyBiYWNrdHJhY2sgY3Vyc29yIGJ5IDFcbiAgICAgICAgICByZXN1bHRzW3VuaXRdLS07XG4gICAgICAgICAgY3Vyc29yID0gZWFybGllci5wbHVzKHJlc3VsdHMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJzb3IgPSBoaWdoV2F0ZXI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFtjdXJzb3IsIHJlc3VsdHMsIGhpZ2hXYXRlciwgbG93ZXN0T3JkZXJdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoZWFybGllciwgbGF0ZXIsIHVuaXRzLCBvcHRzKSB7XG4gIGxldCBbY3Vyc29yLCByZXN1bHRzLCBoaWdoV2F0ZXIsIGxvd2VzdE9yZGVyXSA9IGhpZ2hPcmRlckRpZmZzKGVhcmxpZXIsIGxhdGVyLCB1bml0cyk7XG5cbiAgY29uc3QgcmVtYWluaW5nTWlsbGlzID0gbGF0ZXIgLSBjdXJzb3I7XG5cbiAgY29uc3QgbG93ZXJPcmRlclVuaXRzID0gdW5pdHMuZmlsdGVyKFxuICAgICh1KSA9PiBbXCJob3Vyc1wiLCBcIm1pbnV0ZXNcIiwgXCJzZWNvbmRzXCIsIFwibWlsbGlzZWNvbmRzXCJdLmluZGV4T2YodSkgPj0gMFxuICApO1xuXG4gIGlmIChsb3dlck9yZGVyVW5pdHMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGhpZ2hXYXRlciA8IGxhdGVyKSB7XG4gICAgICBoaWdoV2F0ZXIgPSBjdXJzb3IucGx1cyh7IFtsb3dlc3RPcmRlcl06IDEgfSk7XG4gICAgfVxuXG4gICAgaWYgKGhpZ2hXYXRlciAhPT0gY3Vyc29yKSB7XG4gICAgICByZXN1bHRzW2xvd2VzdE9yZGVyXSA9IChyZXN1bHRzW2xvd2VzdE9yZGVyXSB8fCAwKSArIHJlbWFpbmluZ01pbGxpcyAvIChoaWdoV2F0ZXIgLSBjdXJzb3IpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGR1cmF0aW9uID0gRHVyYXRpb24uZnJvbU9iamVjdChyZXN1bHRzLCBvcHRzKTtcblxuICBpZiAobG93ZXJPcmRlclVuaXRzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gRHVyYXRpb24uZnJvbU1pbGxpcyhyZW1haW5pbmdNaWxsaXMsIG9wdHMpXG4gICAgICAuc2hpZnRUbyguLi5sb3dlck9yZGVyVW5pdHMpXG4gICAgICAucGx1cyhkdXJhdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGR1cmF0aW9uO1xuICB9XG59XG4iLCAiY29uc3QgbnVtYmVyaW5nU3lzdGVtcyA9IHtcbiAgYXJhYjogXCJbXFx1MDY2MC1cXHUwNjY5XVwiLFxuICBhcmFiZXh0OiBcIltcXHUwNkYwLVxcdTA2RjldXCIsXG4gIGJhbGk6IFwiW1xcdTFCNTAtXFx1MUI1OV1cIixcbiAgYmVuZzogXCJbXFx1MDlFNi1cXHUwOUVGXVwiLFxuICBkZXZhOiBcIltcXHUwOTY2LVxcdTA5NkZdXCIsXG4gIGZ1bGx3aWRlOiBcIltcXHVGRjEwLVxcdUZGMTldXCIsXG4gIGd1anI6IFwiW1xcdTBBRTYtXFx1MEFFRl1cIixcbiAgaGFuaWRlYzogXCJb44CHfOS4gHzkuox85LiJfOWbm3zkupR85YWtfOS4g3zlhat85LmdXVwiLFxuICBraG1yOiBcIltcXHUxN0UwLVxcdTE3RTldXCIsXG4gIGtuZGE6IFwiW1xcdTBDRTYtXFx1MENFRl1cIixcbiAgbGFvbzogXCJbXFx1MEVEMC1cXHUwRUQ5XVwiLFxuICBsaW1iOiBcIltcXHUxOTQ2LVxcdTE5NEZdXCIsXG4gIG1seW06IFwiW1xcdTBENjYtXFx1MEQ2Rl1cIixcbiAgbW9uZzogXCJbXFx1MTgxMC1cXHUxODE5XVwiLFxuICBteW1yOiBcIltcXHUxMDQwLVxcdTEwNDldXCIsXG4gIG9yeWE6IFwiW1xcdTBCNjYtXFx1MEI2Rl1cIixcbiAgdGFtbGRlYzogXCJbXFx1MEJFNi1cXHUwQkVGXVwiLFxuICB0ZWx1OiBcIltcXHUwQzY2LVxcdTBDNkZdXCIsXG4gIHRoYWk6IFwiW1xcdTBFNTAtXFx1MEU1OV1cIixcbiAgdGlidDogXCJbXFx1MEYyMC1cXHUwRjI5XVwiLFxuICBsYXRuOiBcIlxcXFxkXCIsXG59O1xuXG5jb25zdCBudW1iZXJpbmdTeXN0ZW1zVVRGMTYgPSB7XG4gIGFyYWI6IFsxNjMyLCAxNjQxXSxcbiAgYXJhYmV4dDogWzE3NzYsIDE3ODVdLFxuICBiYWxpOiBbNjk5MiwgNzAwMV0sXG4gIGJlbmc6IFsyNTM0LCAyNTQzXSxcbiAgZGV2YTogWzI0MDYsIDI0MTVdLFxuICBmdWxsd2lkZTogWzY1Mjk2LCA2NTMwM10sXG4gIGd1anI6IFsyNzkwLCAyNzk5XSxcbiAga2htcjogWzYxMTIsIDYxMjFdLFxuICBrbmRhOiBbMzMwMiwgMzMxMV0sXG4gIGxhb286IFszNzkyLCAzODAxXSxcbiAgbGltYjogWzY0NzAsIDY0NzldLFxuICBtbHltOiBbMzQzMCwgMzQzOV0sXG4gIG1vbmc6IFs2MTYwLCA2MTY5XSxcbiAgbXltcjogWzQxNjAsIDQxNjldLFxuICBvcnlhOiBbMjkxOCwgMjkyN10sXG4gIHRhbWxkZWM6IFszMDQ2LCAzMDU1XSxcbiAgdGVsdTogWzMxNzQsIDMxODNdLFxuICB0aGFpOiBbMzY2NCwgMzY3M10sXG4gIHRpYnQ6IFszODcyLCAzODgxXSxcbn07XG5cbmNvbnN0IGhhbmlkZWNDaGFycyA9IG51bWJlcmluZ1N5c3RlbXMuaGFuaWRlYy5yZXBsYWNlKC9bXFxbfFxcXV0vZywgXCJcIikuc3BsaXQoXCJcIik7XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZURpZ2l0cyhzdHIpIHtcbiAgbGV0IHZhbHVlID0gcGFyc2VJbnQoc3RyLCAxMCk7XG4gIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcblxuICAgICAgaWYgKHN0cltpXS5zZWFyY2gobnVtYmVyaW5nU3lzdGVtcy5oYW5pZGVjKSAhPT0gLTEpIHtcbiAgICAgICAgdmFsdWUgKz0gaGFuaWRlY0NoYXJzLmluZGV4T2Yoc3RyW2ldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG51bWJlcmluZ1N5c3RlbXNVVEYxNikge1xuICAgICAgICAgIGNvbnN0IFttaW4sIG1heF0gPSBudW1iZXJpbmdTeXN0ZW1zVVRGMTZba2V5XTtcbiAgICAgICAgICBpZiAoY29kZSA+PSBtaW4gJiYgY29kZSA8PSBtYXgpIHtcbiAgICAgICAgICAgIHZhbHVlICs9IGNvZGUgLSBtaW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlnaXRSZWdleCh7IG51bWJlcmluZ1N5c3RlbSB9LCBhcHBlbmQgPSBcIlwiKSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKGAke251bWJlcmluZ1N5c3RlbXNbbnVtYmVyaW5nU3lzdGVtIHx8IFwibGF0blwiXX0ke2FwcGVuZH1gKTtcbn1cbiIsICJpbXBvcnQgeyBwYXJzZU1pbGxpcywgaXNVbmRlZmluZWQsIHVudHJ1bmNhdGVZZWFyLCBzaWduZWRPZmZzZXQsIGhhc093blByb3BlcnR5IH0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuaW1wb3J0IEZvcm1hdHRlciBmcm9tIFwiLi9mb3JtYXR0ZXIuanNcIjtcbmltcG9ydCBGaXhlZE9mZnNldFpvbmUgZnJvbSBcIi4uL3pvbmVzL2ZpeGVkT2Zmc2V0Wm9uZS5qc1wiO1xuaW1wb3J0IElBTkFab25lIGZyb20gXCIuLi96b25lcy9JQU5BWm9uZS5qc1wiO1xuaW1wb3J0IERhdGVUaW1lIGZyb20gXCIuLi9kYXRldGltZS5qc1wiO1xuaW1wb3J0IHsgZGlnaXRSZWdleCwgcGFyc2VEaWdpdHMgfSBmcm9tIFwiLi9kaWdpdHMuanNcIjtcbmltcG9ydCB7IENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yIH0gZnJvbSBcIi4uL2Vycm9ycy5qc1wiO1xuXG5jb25zdCBNSVNTSU5HX0ZUUCA9IFwibWlzc2luZyBJbnRsLkRhdGVUaW1lRm9ybWF0LmZvcm1hdFRvUGFydHMgc3VwcG9ydFwiO1xuXG5mdW5jdGlvbiBpbnRVbml0KHJlZ2V4LCBwb3N0ID0gKGkpID0+IGkpIHtcbiAgcmV0dXJuIHsgcmVnZXgsIGRlc2VyOiAoW3NdKSA9PiBwb3N0KHBhcnNlRGlnaXRzKHMpKSB9O1xufVxuXG5jb25zdCBOQlNQID0gU3RyaW5nLmZyb21DaGFyQ29kZSgxNjApO1xuY29uc3Qgc3BhY2VPck5CU1AgPSBgWyAke05CU1B9XWA7XG5jb25zdCBzcGFjZU9yTkJTUFJlZ0V4cCA9IG5ldyBSZWdFeHAoc3BhY2VPck5CU1AsIFwiZ1wiKTtcblxuZnVuY3Rpb24gZml4TGlzdFJlZ2V4KHMpIHtcbiAgLy8gbWFrZSBkb3RzIG9wdGlvbmFsIGFuZCBhbHNvIG1ha2UgdGhlbSBsaXRlcmFsXG4gIC8vIG1ha2Ugc3BhY2UgYW5kIG5vbiBicmVha2FibGUgc3BhY2UgY2hhcmFjdGVycyBpbnRlcmNoYW5nZWFibGVcbiAgcmV0dXJuIHMucmVwbGFjZSgvXFwuL2csIFwiXFxcXC4/XCIpLnJlcGxhY2Uoc3BhY2VPck5CU1BSZWdFeHAsIHNwYWNlT3JOQlNQKTtcbn1cblxuZnVuY3Rpb24gc3RyaXBJbnNlbnNpdGl2aXRpZXMocykge1xuICByZXR1cm4gc1xuICAgIC5yZXBsYWNlKC9cXC4vZywgXCJcIikgLy8gaWdub3JlIGRvdHMgdGhhdCB3ZXJlIG1hZGUgb3B0aW9uYWxcbiAgICAucmVwbGFjZShzcGFjZU9yTkJTUFJlZ0V4cCwgXCIgXCIpIC8vIGludGVyY2hhbmdlIHNwYWNlIGFuZCBuYnNwXG4gICAgLnRvTG93ZXJDYXNlKCk7XG59XG5cbmZ1bmN0aW9uIG9uZU9mKHN0cmluZ3MsIHN0YXJ0SW5kZXgpIHtcbiAgaWYgKHN0cmluZ3MgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVnZXg6IFJlZ0V4cChzdHJpbmdzLm1hcChmaXhMaXN0UmVnZXgpLmpvaW4oXCJ8XCIpKSxcbiAgICAgIGRlc2VyOiAoW3NdKSA9PlxuICAgICAgICBzdHJpbmdzLmZpbmRJbmRleCgoaSkgPT4gc3RyaXBJbnNlbnNpdGl2aXRpZXMocykgPT09IHN0cmlwSW5zZW5zaXRpdml0aWVzKGkpKSArIHN0YXJ0SW5kZXgsXG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvZmZzZXQocmVnZXgsIGdyb3Vwcykge1xuICByZXR1cm4geyByZWdleCwgZGVzZXI6IChbLCBoLCBtXSkgPT4gc2lnbmVkT2Zmc2V0KGgsIG0pLCBncm91cHMgfTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlKHJlZ2V4KSB7XG4gIHJldHVybiB7IHJlZ2V4LCBkZXNlcjogKFtzXSkgPT4gcyB9O1xufVxuXG5mdW5jdGlvbiBlc2NhcGVUb2tlbih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUucmVwbGFjZSgvW1xcLVxcW1xcXXt9KCkqKz8uLFxcXFxcXF4kfCNcXHNdL2csIFwiXFxcXCQmXCIpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB0b2tlblxuICogQHBhcmFtIHtMb2NhbGV9IGxvY1xuICovXG5mdW5jdGlvbiB1bml0Rm9yVG9rZW4odG9rZW4sIGxvYykge1xuICBjb25zdCBvbmUgPSBkaWdpdFJlZ2V4KGxvYyksXG4gICAgdHdvID0gZGlnaXRSZWdleChsb2MsIFwiezJ9XCIpLFxuICAgIHRocmVlID0gZGlnaXRSZWdleChsb2MsIFwiezN9XCIpLFxuICAgIGZvdXIgPSBkaWdpdFJlZ2V4KGxvYywgXCJ7NH1cIiksXG4gICAgc2l4ID0gZGlnaXRSZWdleChsb2MsIFwiezZ9XCIpLFxuICAgIG9uZU9yVHdvID0gZGlnaXRSZWdleChsb2MsIFwiezEsMn1cIiksXG4gICAgb25lVG9UaHJlZSA9IGRpZ2l0UmVnZXgobG9jLCBcInsxLDN9XCIpLFxuICAgIG9uZVRvU2l4ID0gZGlnaXRSZWdleChsb2MsIFwiezEsNn1cIiksXG4gICAgb25lVG9OaW5lID0gZGlnaXRSZWdleChsb2MsIFwiezEsOX1cIiksXG4gICAgdHdvVG9Gb3VyID0gZGlnaXRSZWdleChsb2MsIFwiezIsNH1cIiksXG4gICAgZm91clRvU2l4ID0gZGlnaXRSZWdleChsb2MsIFwiezQsNn1cIiksXG4gICAgbGl0ZXJhbCA9ICh0KSA9PiAoeyByZWdleDogUmVnRXhwKGVzY2FwZVRva2VuKHQudmFsKSksIGRlc2VyOiAoW3NdKSA9PiBzLCBsaXRlcmFsOiB0cnVlIH0pLFxuICAgIHVuaXRhdGUgPSAodCkgPT4ge1xuICAgICAgaWYgKHRva2VuLmxpdGVyYWwpIHtcbiAgICAgICAgcmV0dXJuIGxpdGVyYWwodCk7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHQudmFsKSB7XG4gICAgICAgIC8vIGVyYVxuICAgICAgICBjYXNlIFwiR1wiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2MuZXJhcyhcInNob3J0XCIpLCAwKTtcbiAgICAgICAgY2FzZSBcIkdHXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy5lcmFzKFwibG9uZ1wiKSwgMCk7XG4gICAgICAgIC8vIHllYXJzXG4gICAgICAgIGNhc2UgXCJ5XCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lVG9TaXgpO1xuICAgICAgICBjYXNlIFwieXlcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d29Ub0ZvdXIsIHVudHJ1bmNhdGVZZWFyKTtcbiAgICAgICAgY2FzZSBcInl5eXlcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChmb3VyKTtcbiAgICAgICAgY2FzZSBcInl5eXl5XCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQoZm91clRvU2l4KTtcbiAgICAgICAgY2FzZSBcInl5eXl5eVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHNpeCk7XG4gICAgICAgIC8vIG1vbnRoc1xuICAgICAgICBjYXNlIFwiTVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcIk1NXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgICAgY2FzZSBcIk1NTVwiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2MubW9udGhzKFwic2hvcnRcIiwgdHJ1ZSksIDEpO1xuICAgICAgICBjYXNlIFwiTU1NTVwiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2MubW9udGhzKFwibG9uZ1wiLCB0cnVlKSwgMSk7XG4gICAgICAgIGNhc2UgXCJMXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwiTExcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICBjYXNlIFwiTExMXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy5tb250aHMoXCJzaG9ydFwiLCBmYWxzZSksIDEpO1xuICAgICAgICBjYXNlIFwiTExMTFwiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2MubW9udGhzKFwibG9uZ1wiLCBmYWxzZSksIDEpO1xuICAgICAgICAvLyBkYXRlc1xuICAgICAgICBjYXNlIFwiZFwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcImRkXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgICAgLy8gb3JkaW5hbHNcbiAgICAgICAgY2FzZSBcIm9cIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVUb1RocmVlKTtcbiAgICAgICAgY2FzZSBcIm9vb1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHRocmVlKTtcbiAgICAgICAgLy8gdGltZVxuICAgICAgICBjYXNlIFwiSEhcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICBjYXNlIFwiSFwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcImhoXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgICAgY2FzZSBcImhcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJtbVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwicVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcInFxXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgICAgY2FzZSBcInNcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJzc1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lVG9UaHJlZSk7XG4gICAgICAgIGNhc2UgXCJTU1NcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0aHJlZSk7XG4gICAgICAgIGNhc2UgXCJ1XCI6XG4gICAgICAgICAgcmV0dXJuIHNpbXBsZShvbmVUb05pbmUpO1xuICAgICAgICBjYXNlIFwidXVcIjpcbiAgICAgICAgICByZXR1cm4gc2ltcGxlKG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcInV1dVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZSk7XG4gICAgICAgIC8vIG1lcmlkaWVtXG4gICAgICAgIGNhc2UgXCJhXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy5tZXJpZGllbXMoKSwgMCk7XG4gICAgICAgIC8vIHdlZWtZZWFyIChrKVxuICAgICAgICBjYXNlIFwia2tra1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KGZvdXIpO1xuICAgICAgICBjYXNlIFwia2tcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d29Ub0ZvdXIsIHVudHJ1bmNhdGVZZWFyKTtcbiAgICAgICAgLy8gd2Vla051bWJlciAoVylcbiAgICAgICAgY2FzZSBcIldcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJXV1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIC8vIHdlZWtkYXlzXG4gICAgICAgIGNhc2UgXCJFXCI6XG4gICAgICAgIGNhc2UgXCJjXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lKTtcbiAgICAgICAgY2FzZSBcIkVFRVwiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2Mud2Vla2RheXMoXCJzaG9ydFwiLCBmYWxzZSksIDEpO1xuICAgICAgICBjYXNlIFwiRUVFRVwiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2Mud2Vla2RheXMoXCJsb25nXCIsIGZhbHNlKSwgMSk7XG4gICAgICAgIGNhc2UgXCJjY2NcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLndlZWtkYXlzKFwic2hvcnRcIiwgdHJ1ZSksIDEpO1xuICAgICAgICBjYXNlIFwiY2NjY1wiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2Mud2Vla2RheXMoXCJsb25nXCIsIHRydWUpLCAxKTtcbiAgICAgICAgLy8gb2Zmc2V0L3pvbmVcbiAgICAgICAgY2FzZSBcIlpcIjpcbiAgICAgICAgY2FzZSBcIlpaXCI6XG4gICAgICAgICAgcmV0dXJuIG9mZnNldChuZXcgUmVnRXhwKGAoWystXSR7b25lT3JUd28uc291cmNlfSkoPzo6KCR7dHdvLnNvdXJjZX0pKT9gKSwgMik7XG4gICAgICAgIGNhc2UgXCJaWlpcIjpcbiAgICAgICAgICByZXR1cm4gb2Zmc2V0KG5ldyBSZWdFeHAoYChbKy1dJHtvbmVPclR3by5zb3VyY2V9KSgke3R3by5zb3VyY2V9KT9gKSwgMik7XG4gICAgICAgIC8vIHdlIGRvbid0IHN1cHBvcnQgWlpaWiAoUFNUKSBvciBaWlpaWiAoUGFjaWZpYyBTdGFuZGFyZCBUaW1lKSBpbiBwYXJzaW5nXG4gICAgICAgIC8vIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBhbnkgd2F5IHRvIGZpZ3VyZSBvdXQgd2hhdCB0aGV5IGFyZVxuICAgICAgICBjYXNlIFwielwiOlxuICAgICAgICAgIHJldHVybiBzaW1wbGUoL1thLXpfKy0vXXsxLDI1Nn0/L2kpO1xuICAgICAgICAvLyB0aGlzIHNwZWNpYWwtY2FzZSBcInRva2VuXCIgcmVwcmVzZW50cyBhIHBsYWNlIHdoZXJlIGEgbWFjcm8tdG9rZW4gZXhwYW5kZWQgaW50byBhIHdoaXRlLXNwYWNlIGxpdGVyYWxcbiAgICAgICAgLy8gaW4gdGhpcyBjYXNlIHdlIGFjY2VwdCBhbnkgbm9uLW5ld2xpbmUgd2hpdGUtc3BhY2VcbiAgICAgICAgY2FzZSBcIiBcIjpcbiAgICAgICAgICByZXR1cm4gc2ltcGxlKC9bXlxcU1xcblxccl0vKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbGl0ZXJhbCh0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIGNvbnN0IHVuaXQgPSB1bml0YXRlKHRva2VuKSB8fCB7XG4gICAgaW52YWxpZFJlYXNvbjogTUlTU0lOR19GVFAsXG4gIH07XG5cbiAgdW5pdC50b2tlbiA9IHRva2VuO1xuXG4gIHJldHVybiB1bml0O1xufVxuXG5jb25zdCBwYXJ0VHlwZVN0eWxlVG9Ub2tlblZhbCA9IHtcbiAgeWVhcjoge1xuICAgIFwiMi1kaWdpdFwiOiBcInl5XCIsXG4gICAgbnVtZXJpYzogXCJ5eXl5eVwiLFxuICB9LFxuICBtb250aDoge1xuICAgIG51bWVyaWM6IFwiTVwiLFxuICAgIFwiMi1kaWdpdFwiOiBcIk1NXCIsXG4gICAgc2hvcnQ6IFwiTU1NXCIsXG4gICAgbG9uZzogXCJNTU1NXCIsXG4gIH0sXG4gIGRheToge1xuICAgIG51bWVyaWM6IFwiZFwiLFxuICAgIFwiMi1kaWdpdFwiOiBcImRkXCIsXG4gIH0sXG4gIHdlZWtkYXk6IHtcbiAgICBzaG9ydDogXCJFRUVcIixcbiAgICBsb25nOiBcIkVFRUVcIixcbiAgfSxcbiAgZGF5cGVyaW9kOiBcImFcIixcbiAgZGF5UGVyaW9kOiBcImFcIixcbiAgaG91cjEyOiB7XG4gICAgbnVtZXJpYzogXCJoXCIsXG4gICAgXCIyLWRpZ2l0XCI6IFwiaGhcIixcbiAgfSxcbiAgaG91cjI0OiB7XG4gICAgbnVtZXJpYzogXCJIXCIsXG4gICAgXCIyLWRpZ2l0XCI6IFwiSEhcIixcbiAgfSxcbiAgbWludXRlOiB7XG4gICAgbnVtZXJpYzogXCJtXCIsXG4gICAgXCIyLWRpZ2l0XCI6IFwibW1cIixcbiAgfSxcbiAgc2Vjb25kOiB7XG4gICAgbnVtZXJpYzogXCJzXCIsXG4gICAgXCIyLWRpZ2l0XCI6IFwic3NcIixcbiAgfSxcbiAgdGltZVpvbmVOYW1lOiB7XG4gICAgbG9uZzogXCJaWlpaWlwiLFxuICAgIHNob3J0OiBcIlpaWlwiLFxuICB9LFxufTtcblxuZnVuY3Rpb24gdG9rZW5Gb3JQYXJ0KHBhcnQsIGZvcm1hdE9wdHMsIHJlc29sdmVkT3B0cykge1xuICBjb25zdCB7IHR5cGUsIHZhbHVlIH0gPSBwYXJ0O1xuXG4gIGlmICh0eXBlID09PSBcImxpdGVyYWxcIikge1xuICAgIGNvbnN0IGlzU3BhY2UgPSAvXlxccyskLy50ZXN0KHZhbHVlKTtcbiAgICByZXR1cm4ge1xuICAgICAgbGl0ZXJhbDogIWlzU3BhY2UsXG4gICAgICB2YWw6IGlzU3BhY2UgPyBcIiBcIiA6IHZhbHVlLFxuICAgIH07XG4gIH1cblxuICBjb25zdCBzdHlsZSA9IGZvcm1hdE9wdHNbdHlwZV07XG5cbiAgLy8gVGhlIHVzZXIgbWlnaHQgaGF2ZSBleHBsaWNpdGx5IHNwZWNpZmllZCBob3VyMTIgb3IgaG91ckN5Y2xlXG4gIC8vIGlmIHNvLCByZXNwZWN0IHRoZWlyIGRlY2lzaW9uXG4gIC8vIGlmIG5vdCwgcmVmZXIgYmFjayB0byB0aGUgcmVzb2x2ZWRPcHRzLCB3aGljaCBhcmUgYmFzZWQgb24gdGhlIGxvY2FsZVxuICBsZXQgYWN0dWFsVHlwZSA9IHR5cGU7XG4gIGlmICh0eXBlID09PSBcImhvdXJcIikge1xuICAgIGlmIChmb3JtYXRPcHRzLmhvdXIxMiAhPSBudWxsKSB7XG4gICAgICBhY3R1YWxUeXBlID0gZm9ybWF0T3B0cy5ob3VyMTIgPyBcImhvdXIxMlwiIDogXCJob3VyMjRcIjtcbiAgICB9IGVsc2UgaWYgKGZvcm1hdE9wdHMuaG91ckN5Y2xlICE9IG51bGwpIHtcbiAgICAgIGlmIChmb3JtYXRPcHRzLmhvdXJDeWNsZSA9PT0gXCJoMTFcIiB8fCBmb3JtYXRPcHRzLmhvdXJDeWNsZSA9PT0gXCJoMTJcIikge1xuICAgICAgICBhY3R1YWxUeXBlID0gXCJob3VyMTJcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdHVhbFR5cGUgPSBcImhvdXIyNFwiO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0b2tlbnMgb25seSBkaWZmZXJlbnRpYXRlIGJldHdlZW4gMjQgaG91cnMgb3Igbm90LFxuICAgICAgLy8gc28gd2UgZG8gbm90IG5lZWQgdG8gY2hlY2sgaG91ckN5Y2xlIGhlcmUsIHdoaWNoIGlzIGxlc3Mgc3VwcG9ydGVkIGFueXdheXNcbiAgICAgIGFjdHVhbFR5cGUgPSByZXNvbHZlZE9wdHMuaG91cjEyID8gXCJob3VyMTJcIiA6IFwiaG91cjI0XCI7XG4gICAgfVxuICB9XG4gIGxldCB2YWwgPSBwYXJ0VHlwZVN0eWxlVG9Ub2tlblZhbFthY3R1YWxUeXBlXTtcbiAgaWYgKHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIpIHtcbiAgICB2YWwgPSB2YWxbc3R5bGVdO1xuICB9XG5cbiAgaWYgKHZhbCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaXRlcmFsOiBmYWxzZSxcbiAgICAgIHZhbCxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gYnVpbGRSZWdleCh1bml0cykge1xuICBjb25zdCByZSA9IHVuaXRzLm1hcCgodSkgPT4gdS5yZWdleCkucmVkdWNlKChmLCByKSA9PiBgJHtmfSgke3Iuc291cmNlfSlgLCBcIlwiKTtcbiAgcmV0dXJuIFtgXiR7cmV9JGAsIHVuaXRzXTtcbn1cblxuZnVuY3Rpb24gbWF0Y2goaW5wdXQsIHJlZ2V4LCBoYW5kbGVycykge1xuICBjb25zdCBtYXRjaGVzID0gaW5wdXQubWF0Y2gocmVnZXgpO1xuXG4gIGlmIChtYXRjaGVzKSB7XG4gICAgY29uc3QgYWxsID0ge307XG4gICAgbGV0IG1hdGNoSW5kZXggPSAxO1xuICAgIGZvciAoY29uc3QgaSBpbiBoYW5kbGVycykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5KGhhbmRsZXJzLCBpKSkge1xuICAgICAgICBjb25zdCBoID0gaGFuZGxlcnNbaV0sXG4gICAgICAgICAgZ3JvdXBzID0gaC5ncm91cHMgPyBoLmdyb3VwcyArIDEgOiAxO1xuICAgICAgICBpZiAoIWgubGl0ZXJhbCAmJiBoLnRva2VuKSB7XG4gICAgICAgICAgYWxsW2gudG9rZW4udmFsWzBdXSA9IGguZGVzZXIobWF0Y2hlcy5zbGljZShtYXRjaEluZGV4LCBtYXRjaEluZGV4ICsgZ3JvdXBzKSk7XG4gICAgICAgIH1cbiAgICAgICAgbWF0Y2hJbmRleCArPSBncm91cHM7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbbWF0Y2hlcywgYWxsXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW21hdGNoZXMsIHt9XTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkYXRlVGltZUZyb21NYXRjaGVzKG1hdGNoZXMpIHtcbiAgY29uc3QgdG9GaWVsZCA9ICh0b2tlbikgPT4ge1xuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgIHJldHVybiBcIm1pbGxpc2Vjb25kXCI7XG4gICAgICBjYXNlIFwic1wiOlxuICAgICAgICByZXR1cm4gXCJzZWNvbmRcIjtcbiAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgIHJldHVybiBcIm1pbnV0ZVwiO1xuICAgICAgY2FzZSBcImhcIjpcbiAgICAgIGNhc2UgXCJIXCI6XG4gICAgICAgIHJldHVybiBcImhvdXJcIjtcbiAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgIHJldHVybiBcImRheVwiO1xuICAgICAgY2FzZSBcIm9cIjpcbiAgICAgICAgcmV0dXJuIFwib3JkaW5hbFwiO1xuICAgICAgY2FzZSBcIkxcIjpcbiAgICAgIGNhc2UgXCJNXCI6XG4gICAgICAgIHJldHVybiBcIm1vbnRoXCI7XG4gICAgICBjYXNlIFwieVwiOlxuICAgICAgICByZXR1cm4gXCJ5ZWFyXCI7XG4gICAgICBjYXNlIFwiRVwiOlxuICAgICAgY2FzZSBcImNcIjpcbiAgICAgICAgcmV0dXJuIFwid2Vla2RheVwiO1xuICAgICAgY2FzZSBcIldcIjpcbiAgICAgICAgcmV0dXJuIFwid2Vla051bWJlclwiO1xuICAgICAgY2FzZSBcImtcIjpcbiAgICAgICAgcmV0dXJuIFwid2Vla1llYXJcIjtcbiAgICAgIGNhc2UgXCJxXCI6XG4gICAgICAgIHJldHVybiBcInF1YXJ0ZXJcIjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcblxuICBsZXQgem9uZSA9IG51bGw7XG4gIGxldCBzcGVjaWZpY09mZnNldDtcbiAgaWYgKCFpc1VuZGVmaW5lZChtYXRjaGVzLnopKSB7XG4gICAgem9uZSA9IElBTkFab25lLmNyZWF0ZShtYXRjaGVzLnopO1xuICB9XG5cbiAgaWYgKCFpc1VuZGVmaW5lZChtYXRjaGVzLlopKSB7XG4gICAgaWYgKCF6b25lKSB7XG4gICAgICB6b25lID0gbmV3IEZpeGVkT2Zmc2V0Wm9uZShtYXRjaGVzLlopO1xuICAgIH1cbiAgICBzcGVjaWZpY09mZnNldCA9IG1hdGNoZXMuWjtcbiAgfVxuXG4gIGlmICghaXNVbmRlZmluZWQobWF0Y2hlcy5xKSkge1xuICAgIG1hdGNoZXMuTSA9IChtYXRjaGVzLnEgLSAxKSAqIDMgKyAxO1xuICB9XG5cbiAgaWYgKCFpc1VuZGVmaW5lZChtYXRjaGVzLmgpKSB7XG4gICAgaWYgKG1hdGNoZXMuaCA8IDEyICYmIG1hdGNoZXMuYSA9PT0gMSkge1xuICAgICAgbWF0Y2hlcy5oICs9IDEyO1xuICAgIH0gZWxzZSBpZiAobWF0Y2hlcy5oID09PSAxMiAmJiBtYXRjaGVzLmEgPT09IDApIHtcbiAgICAgIG1hdGNoZXMuaCA9IDA7XG4gICAgfVxuICB9XG5cbiAgaWYgKG1hdGNoZXMuRyA9PT0gMCAmJiBtYXRjaGVzLnkpIHtcbiAgICBtYXRjaGVzLnkgPSAtbWF0Y2hlcy55O1xuICB9XG5cbiAgaWYgKCFpc1VuZGVmaW5lZChtYXRjaGVzLnUpKSB7XG4gICAgbWF0Y2hlcy5TID0gcGFyc2VNaWxsaXMobWF0Y2hlcy51KTtcbiAgfVxuXG4gIGNvbnN0IHZhbHMgPSBPYmplY3Qua2V5cyhtYXRjaGVzKS5yZWR1Y2UoKHIsIGspID0+IHtcbiAgICBjb25zdCBmID0gdG9GaWVsZChrKTtcbiAgICBpZiAoZikge1xuICAgICAgcltmXSA9IG1hdGNoZXNba107XG4gICAgfVxuXG4gICAgcmV0dXJuIHI7XG4gIH0sIHt9KTtcblxuICByZXR1cm4gW3ZhbHMsIHpvbmUsIHNwZWNpZmljT2Zmc2V0XTtcbn1cblxubGV0IGR1bW15RGF0ZVRpbWVDYWNoZSA9IG51bGw7XG5cbmZ1bmN0aW9uIGdldER1bW15RGF0ZVRpbWUoKSB7XG4gIGlmICghZHVtbXlEYXRlVGltZUNhY2hlKSB7XG4gICAgZHVtbXlEYXRlVGltZUNhY2hlID0gRGF0ZVRpbWUuZnJvbU1pbGxpcygxNTU1NTU1NTU1NTU1KTtcbiAgfVxuXG4gIHJldHVybiBkdW1teURhdGVUaW1lQ2FjaGU7XG59XG5cbmZ1bmN0aW9uIG1heWJlRXhwYW5kTWFjcm9Ub2tlbih0b2tlbiwgbG9jYWxlKSB7XG4gIGlmICh0b2tlbi5saXRlcmFsKSB7XG4gICAgcmV0dXJuIHRva2VuO1xuICB9XG5cbiAgY29uc3QgZm9ybWF0T3B0cyA9IEZvcm1hdHRlci5tYWNyb1Rva2VuVG9Gb3JtYXRPcHRzKHRva2VuLnZhbCk7XG4gIGNvbnN0IHRva2VucyA9IGZvcm1hdE9wdHNUb1Rva2Vucyhmb3JtYXRPcHRzLCBsb2NhbGUpO1xuXG4gIGlmICh0b2tlbnMgPT0gbnVsbCB8fCB0b2tlbnMuaW5jbHVkZXModW5kZWZpbmVkKSkge1xuICAgIHJldHVybiB0b2tlbjtcbiAgfVxuXG4gIHJldHVybiB0b2tlbnM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRNYWNyb1Rva2Vucyh0b2tlbnMsIGxvY2FsZSkge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdCguLi50b2tlbnMubWFwKCh0KSA9PiBtYXliZUV4cGFuZE1hY3JvVG9rZW4odCwgbG9jYWxlKSkpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGV4cGxhaW5Gcm9tVG9rZW5zKGxvY2FsZSwgaW5wdXQsIGZvcm1hdCkge1xuICBjb25zdCB0b2tlbnMgPSBleHBhbmRNYWNyb1Rva2VucyhGb3JtYXR0ZXIucGFyc2VGb3JtYXQoZm9ybWF0KSwgbG9jYWxlKSxcbiAgICB1bml0cyA9IHRva2Vucy5tYXAoKHQpID0+IHVuaXRGb3JUb2tlbih0LCBsb2NhbGUpKSxcbiAgICBkaXNxdWFsaWZ5aW5nVW5pdCA9IHVuaXRzLmZpbmQoKHQpID0+IHQuaW52YWxpZFJlYXNvbik7XG5cbiAgaWYgKGRpc3F1YWxpZnlpbmdVbml0KSB7XG4gICAgcmV0dXJuIHsgaW5wdXQsIHRva2VucywgaW52YWxpZFJlYXNvbjogZGlzcXVhbGlmeWluZ1VuaXQuaW52YWxpZFJlYXNvbiB9O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IFtyZWdleFN0cmluZywgaGFuZGxlcnNdID0gYnVpbGRSZWdleCh1bml0cyksXG4gICAgICByZWdleCA9IFJlZ0V4cChyZWdleFN0cmluZywgXCJpXCIpLFxuICAgICAgW3Jhd01hdGNoZXMsIG1hdGNoZXNdID0gbWF0Y2goaW5wdXQsIHJlZ2V4LCBoYW5kbGVycyksXG4gICAgICBbcmVzdWx0LCB6b25lLCBzcGVjaWZpY09mZnNldF0gPSBtYXRjaGVzXG4gICAgICAgID8gZGF0ZVRpbWVGcm9tTWF0Y2hlcyhtYXRjaGVzKVxuICAgICAgICA6IFtudWxsLCBudWxsLCB1bmRlZmluZWRdO1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eShtYXRjaGVzLCBcImFcIikgJiYgaGFzT3duUHJvcGVydHkobWF0Y2hlcywgXCJIXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IoXG4gICAgICAgIFwiQ2FuJ3QgaW5jbHVkZSBtZXJpZGllbSB3aGVuIHNwZWNpZnlpbmcgMjQtaG91ciBmb3JtYXRcIlxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgaW5wdXQsIHRva2VucywgcmVnZXgsIHJhd01hdGNoZXMsIG1hdGNoZXMsIHJlc3VsdCwgem9uZSwgc3BlY2lmaWNPZmZzZXQgfTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VGcm9tVG9rZW5zKGxvY2FsZSwgaW5wdXQsIGZvcm1hdCkge1xuICBjb25zdCB7IHJlc3VsdCwgem9uZSwgc3BlY2lmaWNPZmZzZXQsIGludmFsaWRSZWFzb24gfSA9IGV4cGxhaW5Gcm9tVG9rZW5zKGxvY2FsZSwgaW5wdXQsIGZvcm1hdCk7XG4gIHJldHVybiBbcmVzdWx0LCB6b25lLCBzcGVjaWZpY09mZnNldCwgaW52YWxpZFJlYXNvbl07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRPcHRzVG9Ub2tlbnMoZm9ybWF0T3B0cywgbG9jYWxlKSB7XG4gIGlmICghZm9ybWF0T3B0cykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgZm9ybWF0dGVyID0gRm9ybWF0dGVyLmNyZWF0ZShsb2NhbGUsIGZvcm1hdE9wdHMpO1xuICBjb25zdCBkZiA9IGZvcm1hdHRlci5kdEZvcm1hdHRlcihnZXREdW1teURhdGVUaW1lKCkpO1xuICBjb25zdCBwYXJ0cyA9IGRmLmZvcm1hdFRvUGFydHMoKTtcbiAgY29uc3QgcmVzb2x2ZWRPcHRzID0gZGYucmVzb2x2ZWRPcHRpb25zKCk7XG4gIHJldHVybiBwYXJ0cy5tYXAoKHApID0+IHRva2VuRm9yUGFydChwLCBmb3JtYXRPcHRzLCByZXNvbHZlZE9wdHMpKTtcbn1cbiIsICJpbXBvcnQge1xuICBpbnRlZ2VyQmV0d2VlbixcbiAgaXNMZWFwWWVhcixcbiAgdGltZU9iamVjdCxcbiAgZGF5c0luWWVhcixcbiAgZGF5c0luTW9udGgsXG4gIHdlZWtzSW5XZWVrWWVhcixcbiAgaXNJbnRlZ2VyLFxufSBmcm9tIFwiLi91dGlsLmpzXCI7XG5pbXBvcnQgSW52YWxpZCBmcm9tIFwiLi9pbnZhbGlkLmpzXCI7XG5cbmNvbnN0IG5vbkxlYXBMYWRkZXIgPSBbMCwgMzEsIDU5LCA5MCwgMTIwLCAxNTEsIDE4MSwgMjEyLCAyNDMsIDI3MywgMzA0LCAzMzRdLFxuICBsZWFwTGFkZGVyID0gWzAsIDMxLCA2MCwgOTEsIDEyMSwgMTUyLCAxODIsIDIxMywgMjQ0LCAyNzQsIDMwNSwgMzM1XTtcblxuZnVuY3Rpb24gdW5pdE91dE9mUmFuZ2UodW5pdCwgdmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBJbnZhbGlkKFxuICAgIFwidW5pdCBvdXQgb2YgcmFuZ2VcIixcbiAgICBgeW91IHNwZWNpZmllZCAke3ZhbHVlfSAob2YgdHlwZSAke3R5cGVvZiB2YWx1ZX0pIGFzIGEgJHt1bml0fSwgd2hpY2ggaXMgaW52YWxpZGBcbiAgKTtcbn1cblxuZnVuY3Rpb24gZGF5T2ZXZWVrKHllYXIsIG1vbnRoLCBkYXkpIHtcbiAgY29uc3QgZCA9IG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoIC0gMSwgZGF5KSk7XG5cbiAgaWYgKHllYXIgPCAxMDAgJiYgeWVhciA+PSAwKSB7XG4gICAgZC5zZXRVVENGdWxsWWVhcihkLmdldFVUQ0Z1bGxZZWFyKCkgLSAxOTAwKTtcbiAgfVxuXG4gIGNvbnN0IGpzID0gZC5nZXRVVENEYXkoKTtcblxuICByZXR1cm4ganMgPT09IDAgPyA3IDoganM7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVPcmRpbmFsKHllYXIsIG1vbnRoLCBkYXkpIHtcbiAgcmV0dXJuIGRheSArIChpc0xlYXBZZWFyKHllYXIpID8gbGVhcExhZGRlciA6IG5vbkxlYXBMYWRkZXIpW21vbnRoIC0gMV07XG59XG5cbmZ1bmN0aW9uIHVuY29tcHV0ZU9yZGluYWwoeWVhciwgb3JkaW5hbCkge1xuICBjb25zdCB0YWJsZSA9IGlzTGVhcFllYXIoeWVhcikgPyBsZWFwTGFkZGVyIDogbm9uTGVhcExhZGRlcixcbiAgICBtb250aDAgPSB0YWJsZS5maW5kSW5kZXgoKGkpID0+IGkgPCBvcmRpbmFsKSxcbiAgICBkYXkgPSBvcmRpbmFsIC0gdGFibGVbbW9udGgwXTtcbiAgcmV0dXJuIHsgbW9udGg6IG1vbnRoMCArIDEsIGRheSB9O1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGdyZWdvcmlhblRvV2VlayhncmVnT2JqKSB7XG4gIGNvbnN0IHsgeWVhciwgbW9udGgsIGRheSB9ID0gZ3JlZ09iaixcbiAgICBvcmRpbmFsID0gY29tcHV0ZU9yZGluYWwoeWVhciwgbW9udGgsIGRheSksXG4gICAgd2Vla2RheSA9IGRheU9mV2Vlayh5ZWFyLCBtb250aCwgZGF5KTtcblxuICBsZXQgd2Vla051bWJlciA9IE1hdGguZmxvb3IoKG9yZGluYWwgLSB3ZWVrZGF5ICsgMTApIC8gNyksXG4gICAgd2Vla1llYXI7XG5cbiAgaWYgKHdlZWtOdW1iZXIgPCAxKSB7XG4gICAgd2Vla1llYXIgPSB5ZWFyIC0gMTtcbiAgICB3ZWVrTnVtYmVyID0gd2Vla3NJbldlZWtZZWFyKHdlZWtZZWFyKTtcbiAgfSBlbHNlIGlmICh3ZWVrTnVtYmVyID4gd2Vla3NJbldlZWtZZWFyKHllYXIpKSB7XG4gICAgd2Vla1llYXIgPSB5ZWFyICsgMTtcbiAgICB3ZWVrTnVtYmVyID0gMTtcbiAgfSBlbHNlIHtcbiAgICB3ZWVrWWVhciA9IHllYXI7XG4gIH1cblxuICByZXR1cm4geyB3ZWVrWWVhciwgd2Vla051bWJlciwgd2Vla2RheSwgLi4udGltZU9iamVjdChncmVnT2JqKSB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2Vla1RvR3JlZ29yaWFuKHdlZWtEYXRhKSB7XG4gIGNvbnN0IHsgd2Vla1llYXIsIHdlZWtOdW1iZXIsIHdlZWtkYXkgfSA9IHdlZWtEYXRhLFxuICAgIHdlZWtkYXlPZkphbjQgPSBkYXlPZldlZWsod2Vla1llYXIsIDEsIDQpLFxuICAgIHllYXJJbkRheXMgPSBkYXlzSW5ZZWFyKHdlZWtZZWFyKTtcblxuICBsZXQgb3JkaW5hbCA9IHdlZWtOdW1iZXIgKiA3ICsgd2Vla2RheSAtIHdlZWtkYXlPZkphbjQgLSAzLFxuICAgIHllYXI7XG5cbiAgaWYgKG9yZGluYWwgPCAxKSB7XG4gICAgeWVhciA9IHdlZWtZZWFyIC0gMTtcbiAgICBvcmRpbmFsICs9IGRheXNJblllYXIoeWVhcik7XG4gIH0gZWxzZSBpZiAob3JkaW5hbCA+IHllYXJJbkRheXMpIHtcbiAgICB5ZWFyID0gd2Vla1llYXIgKyAxO1xuICAgIG9yZGluYWwgLT0gZGF5c0luWWVhcih3ZWVrWWVhcik7XG4gIH0gZWxzZSB7XG4gICAgeWVhciA9IHdlZWtZZWFyO1xuICB9XG5cbiAgY29uc3QgeyBtb250aCwgZGF5IH0gPSB1bmNvbXB1dGVPcmRpbmFsKHllYXIsIG9yZGluYWwpO1xuICByZXR1cm4geyB5ZWFyLCBtb250aCwgZGF5LCAuLi50aW1lT2JqZWN0KHdlZWtEYXRhKSB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ3JlZ29yaWFuVG9PcmRpbmFsKGdyZWdEYXRhKSB7XG4gIGNvbnN0IHsgeWVhciwgbW9udGgsIGRheSB9ID0gZ3JlZ0RhdGE7XG4gIGNvbnN0IG9yZGluYWwgPSBjb21wdXRlT3JkaW5hbCh5ZWFyLCBtb250aCwgZGF5KTtcbiAgcmV0dXJuIHsgeWVhciwgb3JkaW5hbCwgLi4udGltZU9iamVjdChncmVnRGF0YSkgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9yZGluYWxUb0dyZWdvcmlhbihvcmRpbmFsRGF0YSkge1xuICBjb25zdCB7IHllYXIsIG9yZGluYWwgfSA9IG9yZGluYWxEYXRhO1xuICBjb25zdCB7IG1vbnRoLCBkYXkgfSA9IHVuY29tcHV0ZU9yZGluYWwoeWVhciwgb3JkaW5hbCk7XG4gIHJldHVybiB7IHllYXIsIG1vbnRoLCBkYXksIC4uLnRpbWVPYmplY3Qob3JkaW5hbERhdGEpIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNJbnZhbGlkV2Vla0RhdGEob2JqKSB7XG4gIGNvbnN0IHZhbGlkWWVhciA9IGlzSW50ZWdlcihvYmoud2Vla1llYXIpLFxuICAgIHZhbGlkV2VlayA9IGludGVnZXJCZXR3ZWVuKG9iai53ZWVrTnVtYmVyLCAxLCB3ZWVrc0luV2Vla1llYXIob2JqLndlZWtZZWFyKSksXG4gICAgdmFsaWRXZWVrZGF5ID0gaW50ZWdlckJldHdlZW4ob2JqLndlZWtkYXksIDEsIDcpO1xuXG4gIGlmICghdmFsaWRZZWFyKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwid2Vla1llYXJcIiwgb2JqLndlZWtZZWFyKTtcbiAgfSBlbHNlIGlmICghdmFsaWRXZWVrKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwid2Vla1wiLCBvYmoud2Vlayk7XG4gIH0gZWxzZSBpZiAoIXZhbGlkV2Vla2RheSkge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcIndlZWtkYXlcIiwgb2JqLndlZWtkYXkpO1xuICB9IGVsc2UgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzSW52YWxpZE9yZGluYWxEYXRhKG9iaikge1xuICBjb25zdCB2YWxpZFllYXIgPSBpc0ludGVnZXIob2JqLnllYXIpLFxuICAgIHZhbGlkT3JkaW5hbCA9IGludGVnZXJCZXR3ZWVuKG9iai5vcmRpbmFsLCAxLCBkYXlzSW5ZZWFyKG9iai55ZWFyKSk7XG5cbiAgaWYgKCF2YWxpZFllYXIpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJ5ZWFyXCIsIG9iai55ZWFyKTtcbiAgfSBlbHNlIGlmICghdmFsaWRPcmRpbmFsKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwib3JkaW5hbFwiLCBvYmoub3JkaW5hbCk7XG4gIH0gZWxzZSByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNJbnZhbGlkR3JlZ29yaWFuRGF0YShvYmopIHtcbiAgY29uc3QgdmFsaWRZZWFyID0gaXNJbnRlZ2VyKG9iai55ZWFyKSxcbiAgICB2YWxpZE1vbnRoID0gaW50ZWdlckJldHdlZW4ob2JqLm1vbnRoLCAxLCAxMiksXG4gICAgdmFsaWREYXkgPSBpbnRlZ2VyQmV0d2VlbihvYmouZGF5LCAxLCBkYXlzSW5Nb250aChvYmoueWVhciwgb2JqLm1vbnRoKSk7XG5cbiAgaWYgKCF2YWxpZFllYXIpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJ5ZWFyXCIsIG9iai55ZWFyKTtcbiAgfSBlbHNlIGlmICghdmFsaWRNb250aCkge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcIm1vbnRoXCIsIG9iai5tb250aCk7XG4gIH0gZWxzZSBpZiAoIXZhbGlkRGF5KSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwiZGF5XCIsIG9iai5kYXkpO1xuICB9IGVsc2UgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzSW52YWxpZFRpbWVEYXRhKG9iaikge1xuICBjb25zdCB7IGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCB9ID0gb2JqO1xuICBjb25zdCB2YWxpZEhvdXIgPVxuICAgICAgaW50ZWdlckJldHdlZW4oaG91ciwgMCwgMjMpIHx8XG4gICAgICAoaG91ciA9PT0gMjQgJiYgbWludXRlID09PSAwICYmIHNlY29uZCA9PT0gMCAmJiBtaWxsaXNlY29uZCA9PT0gMCksXG4gICAgdmFsaWRNaW51dGUgPSBpbnRlZ2VyQmV0d2VlbihtaW51dGUsIDAsIDU5KSxcbiAgICB2YWxpZFNlY29uZCA9IGludGVnZXJCZXR3ZWVuKHNlY29uZCwgMCwgNTkpLFxuICAgIHZhbGlkTWlsbGlzZWNvbmQgPSBpbnRlZ2VyQmV0d2VlbihtaWxsaXNlY29uZCwgMCwgOTk5KTtcblxuICBpZiAoIXZhbGlkSG91cikge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcImhvdXJcIiwgaG91cik7XG4gIH0gZWxzZSBpZiAoIXZhbGlkTWludXRlKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwibWludXRlXCIsIG1pbnV0ZSk7XG4gIH0gZWxzZSBpZiAoIXZhbGlkU2Vjb25kKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwic2Vjb25kXCIsIHNlY29uZCk7XG4gIH0gZWxzZSBpZiAoIXZhbGlkTWlsbGlzZWNvbmQpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJtaWxsaXNlY29uZFwiLCBtaWxsaXNlY29uZCk7XG4gIH0gZWxzZSByZXR1cm4gZmFsc2U7XG59XG4iLCAiaW1wb3J0IER1cmF0aW9uIGZyb20gXCIuL2R1cmF0aW9uLmpzXCI7XG5pbXBvcnQgSW50ZXJ2YWwgZnJvbSBcIi4vaW50ZXJ2YWwuanNcIjtcbmltcG9ydCBTZXR0aW5ncyBmcm9tIFwiLi9zZXR0aW5ncy5qc1wiO1xuaW1wb3J0IEluZm8gZnJvbSBcIi4vaW5mby5qc1wiO1xuaW1wb3J0IEZvcm1hdHRlciBmcm9tIFwiLi9pbXBsL2Zvcm1hdHRlci5qc1wiO1xuaW1wb3J0IEZpeGVkT2Zmc2V0Wm9uZSBmcm9tIFwiLi96b25lcy9maXhlZE9mZnNldFpvbmUuanNcIjtcbmltcG9ydCBMb2NhbGUgZnJvbSBcIi4vaW1wbC9sb2NhbGUuanNcIjtcbmltcG9ydCB7XG4gIGlzVW5kZWZpbmVkLFxuICBtYXliZUFycmF5LFxuICBpc0RhdGUsXG4gIGlzTnVtYmVyLFxuICBiZXN0QnksXG4gIGRheXNJbk1vbnRoLFxuICBkYXlzSW5ZZWFyLFxuICBpc0xlYXBZZWFyLFxuICB3ZWVrc0luV2Vla1llYXIsXG4gIG5vcm1hbGl6ZU9iamVjdCxcbiAgcm91bmRUbyxcbiAgb2JqVG9Mb2NhbFRTLFxuICBwYWRTdGFydCxcbn0gZnJvbSBcIi4vaW1wbC91dGlsLmpzXCI7XG5pbXBvcnQgeyBub3JtYWxpemVab25lIH0gZnJvbSBcIi4vaW1wbC96b25lVXRpbC5qc1wiO1xuaW1wb3J0IGRpZmYgZnJvbSBcIi4vaW1wbC9kaWZmLmpzXCI7XG5pbXBvcnQgeyBwYXJzZVJGQzI4MjJEYXRlLCBwYXJzZUlTT0RhdGUsIHBhcnNlSFRUUERhdGUsIHBhcnNlU1FMIH0gZnJvbSBcIi4vaW1wbC9yZWdleFBhcnNlci5qc1wiO1xuaW1wb3J0IHtcbiAgcGFyc2VGcm9tVG9rZW5zLFxuICBleHBsYWluRnJvbVRva2VucyxcbiAgZm9ybWF0T3B0c1RvVG9rZW5zLFxuICBleHBhbmRNYWNyb1Rva2Vucyxcbn0gZnJvbSBcIi4vaW1wbC90b2tlblBhcnNlci5qc1wiO1xuaW1wb3J0IHtcbiAgZ3JlZ29yaWFuVG9XZWVrLFxuICB3ZWVrVG9HcmVnb3JpYW4sXG4gIGdyZWdvcmlhblRvT3JkaW5hbCxcbiAgb3JkaW5hbFRvR3JlZ29yaWFuLFxuICBoYXNJbnZhbGlkR3JlZ29yaWFuRGF0YSxcbiAgaGFzSW52YWxpZFdlZWtEYXRhLFxuICBoYXNJbnZhbGlkT3JkaW5hbERhdGEsXG4gIGhhc0ludmFsaWRUaW1lRGF0YSxcbn0gZnJvbSBcIi4vaW1wbC9jb252ZXJzaW9ucy5qc1wiO1xuaW1wb3J0ICogYXMgRm9ybWF0cyBmcm9tIFwiLi9pbXBsL2Zvcm1hdHMuanNcIjtcbmltcG9ydCB7XG4gIEludmFsaWRBcmd1bWVudEVycm9yLFxuICBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvcixcbiAgSW52YWxpZFVuaXRFcnJvcixcbiAgSW52YWxpZERhdGVUaW1lRXJyb3IsXG59IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IEludmFsaWQgZnJvbSBcIi4vaW1wbC9pbnZhbGlkLmpzXCI7XG5cbmNvbnN0IElOVkFMSUQgPSBcIkludmFsaWQgRGF0ZVRpbWVcIjtcbmNvbnN0IE1BWF9EQVRFID0gOC42NGUxNTtcblxuZnVuY3Rpb24gdW5zdXBwb3J0ZWRab25lKHpvbmUpIHtcbiAgcmV0dXJuIG5ldyBJbnZhbGlkKFwidW5zdXBwb3J0ZWQgem9uZVwiLCBgdGhlIHpvbmUgXCIke3pvbmUubmFtZX1cIiBpcyBub3Qgc3VwcG9ydGVkYCk7XG59XG5cbi8vIHdlIGNhY2hlIHdlZWsgZGF0YSBvbiB0aGUgRFQgb2JqZWN0IGFuZCB0aGlzIGludGVybWVkaWF0ZXMgdGhlIGNhY2hlXG5mdW5jdGlvbiBwb3NzaWJseUNhY2hlZFdlZWtEYXRhKGR0KSB7XG4gIGlmIChkdC53ZWVrRGF0YSA9PT0gbnVsbCkge1xuICAgIGR0LndlZWtEYXRhID0gZ3JlZ29yaWFuVG9XZWVrKGR0LmMpO1xuICB9XG4gIHJldHVybiBkdC53ZWVrRGF0YTtcbn1cblxuLy8gY2xvbmUgcmVhbGx5IG1lYW5zLCBcIm1ha2UgYSBuZXcgb2JqZWN0IHdpdGggdGhlc2UgbW9kaWZpY2F0aW9uc1wiLiBhbGwgXCJzZXR0ZXJzXCIgcmVhbGx5IHVzZSB0aGlzXG4vLyB0byBjcmVhdGUgYSBuZXcgb2JqZWN0IHdoaWxlIG9ubHkgY2hhbmdpbmcgc29tZSBvZiB0aGUgcHJvcGVydGllc1xuZnVuY3Rpb24gY2xvbmUoaW5zdCwgYWx0cykge1xuICBjb25zdCBjdXJyZW50ID0ge1xuICAgIHRzOiBpbnN0LnRzLFxuICAgIHpvbmU6IGluc3Quem9uZSxcbiAgICBjOiBpbnN0LmMsXG4gICAgbzogaW5zdC5vLFxuICAgIGxvYzogaW5zdC5sb2MsXG4gICAgaW52YWxpZDogaW5zdC5pbnZhbGlkLFxuICB9O1xuICByZXR1cm4gbmV3IERhdGVUaW1lKHsgLi4uY3VycmVudCwgLi4uYWx0cywgb2xkOiBjdXJyZW50IH0pO1xufVxuXG4vLyBmaW5kIHRoZSByaWdodCBvZmZzZXQgYSBnaXZlbiBsb2NhbCB0aW1lLiBUaGUgbyBpbnB1dCBpcyBvdXIgZ3Vlc3MsIHdoaWNoIGRldGVybWluZXMgd2hpY2hcbi8vIG9mZnNldCB3ZSdsbCBwaWNrIGluIGFtYmlndW91cyBjYXNlcyAoZS5nLiB0aGVyZSBhcmUgdHdvIDMgQU1zIGIvYyBGYWxsYmFjayBEU1QpXG5mdW5jdGlvbiBmaXhPZmZzZXQobG9jYWxUUywgbywgdHopIHtcbiAgLy8gT3VyIFVUQyB0aW1lIGlzIGp1c3QgYSBndWVzcyBiZWNhdXNlIG91ciBvZmZzZXQgaXMganVzdCBhIGd1ZXNzXG4gIGxldCB1dGNHdWVzcyA9IGxvY2FsVFMgLSBvICogNjAgKiAxMDAwO1xuXG4gIC8vIFRlc3Qgd2hldGhlciB0aGUgem9uZSBtYXRjaGVzIHRoZSBvZmZzZXQgZm9yIHRoaXMgdHNcbiAgY29uc3QgbzIgPSB0ei5vZmZzZXQodXRjR3Vlc3MpO1xuXG4gIC8vIElmIHNvLCBvZmZzZXQgZGlkbid0IGNoYW5nZSBhbmQgd2UncmUgZG9uZVxuICBpZiAobyA9PT0gbzIpIHtcbiAgICByZXR1cm4gW3V0Y0d1ZXNzLCBvXTtcbiAgfVxuXG4gIC8vIElmIG5vdCwgY2hhbmdlIHRoZSB0cyBieSB0aGUgZGlmZmVyZW5jZSBpbiB0aGUgb2Zmc2V0XG4gIHV0Y0d1ZXNzIC09IChvMiAtIG8pICogNjAgKiAxMDAwO1xuXG4gIC8vIElmIHRoYXQgZ2l2ZXMgdXMgdGhlIGxvY2FsIHRpbWUgd2Ugd2FudCwgd2UncmUgZG9uZVxuICBjb25zdCBvMyA9IHR6Lm9mZnNldCh1dGNHdWVzcyk7XG4gIGlmIChvMiA9PT0gbzMpIHtcbiAgICByZXR1cm4gW3V0Y0d1ZXNzLCBvMl07XG4gIH1cblxuICAvLyBJZiBpdCdzIGRpZmZlcmVudCwgd2UncmUgaW4gYSBob2xlIHRpbWUuIFRoZSBvZmZzZXQgaGFzIGNoYW5nZWQsIGJ1dCB0aGUgd2UgZG9uJ3QgYWRqdXN0IHRoZSB0aW1lXG4gIHJldHVybiBbbG9jYWxUUyAtIE1hdGgubWluKG8yLCBvMykgKiA2MCAqIDEwMDAsIE1hdGgubWF4KG8yLCBvMyldO1xufVxuXG4vLyBjb252ZXJ0IGFuIGVwb2NoIHRpbWVzdGFtcCBpbnRvIGEgY2FsZW5kYXIgb2JqZWN0IHdpdGggdGhlIGdpdmVuIG9mZnNldFxuZnVuY3Rpb24gdHNUb09iaih0cywgb2Zmc2V0KSB7XG4gIHRzICs9IG9mZnNldCAqIDYwICogMTAwMDtcblxuICBjb25zdCBkID0gbmV3IERhdGUodHMpO1xuXG4gIHJldHVybiB7XG4gICAgeWVhcjogZC5nZXRVVENGdWxsWWVhcigpLFxuICAgIG1vbnRoOiBkLmdldFVUQ01vbnRoKCkgKyAxLFxuICAgIGRheTogZC5nZXRVVENEYXRlKCksXG4gICAgaG91cjogZC5nZXRVVENIb3VycygpLFxuICAgIG1pbnV0ZTogZC5nZXRVVENNaW51dGVzKCksXG4gICAgc2Vjb25kOiBkLmdldFVUQ1NlY29uZHMoKSxcbiAgICBtaWxsaXNlY29uZDogZC5nZXRVVENNaWxsaXNlY29uZHMoKSxcbiAgfTtcbn1cblxuLy8gY29udmVydCBhIGNhbGVuZGFyIG9iamVjdCB0byBhIGVwb2NoIHRpbWVzdGFtcFxuZnVuY3Rpb24gb2JqVG9UUyhvYmosIG9mZnNldCwgem9uZSkge1xuICByZXR1cm4gZml4T2Zmc2V0KG9ialRvTG9jYWxUUyhvYmopLCBvZmZzZXQsIHpvbmUpO1xufVxuXG4vLyBjcmVhdGUgYSBuZXcgRFQgaW5zdGFuY2UgYnkgYWRkaW5nIGEgZHVyYXRpb24sIGFkanVzdGluZyBmb3IgRFNUc1xuZnVuY3Rpb24gYWRqdXN0VGltZShpbnN0LCBkdXIpIHtcbiAgY29uc3Qgb1ByZSA9IGluc3QubyxcbiAgICB5ZWFyID0gaW5zdC5jLnllYXIgKyBNYXRoLnRydW5jKGR1ci55ZWFycyksXG4gICAgbW9udGggPSBpbnN0LmMubW9udGggKyBNYXRoLnRydW5jKGR1ci5tb250aHMpICsgTWF0aC50cnVuYyhkdXIucXVhcnRlcnMpICogMyxcbiAgICBjID0ge1xuICAgICAgLi4uaW5zdC5jLFxuICAgICAgeWVhcixcbiAgICAgIG1vbnRoLFxuICAgICAgZGF5OlxuICAgICAgICBNYXRoLm1pbihpbnN0LmMuZGF5LCBkYXlzSW5Nb250aCh5ZWFyLCBtb250aCkpICtcbiAgICAgICAgTWF0aC50cnVuYyhkdXIuZGF5cykgK1xuICAgICAgICBNYXRoLnRydW5jKGR1ci53ZWVrcykgKiA3LFxuICAgIH0sXG4gICAgbWlsbGlzVG9BZGQgPSBEdXJhdGlvbi5mcm9tT2JqZWN0KHtcbiAgICAgIHllYXJzOiBkdXIueWVhcnMgLSBNYXRoLnRydW5jKGR1ci55ZWFycyksXG4gICAgICBxdWFydGVyczogZHVyLnF1YXJ0ZXJzIC0gTWF0aC50cnVuYyhkdXIucXVhcnRlcnMpLFxuICAgICAgbW9udGhzOiBkdXIubW9udGhzIC0gTWF0aC50cnVuYyhkdXIubW9udGhzKSxcbiAgICAgIHdlZWtzOiBkdXIud2Vla3MgLSBNYXRoLnRydW5jKGR1ci53ZWVrcyksXG4gICAgICBkYXlzOiBkdXIuZGF5cyAtIE1hdGgudHJ1bmMoZHVyLmRheXMpLFxuICAgICAgaG91cnM6IGR1ci5ob3VycyxcbiAgICAgIG1pbnV0ZXM6IGR1ci5taW51dGVzLFxuICAgICAgc2Vjb25kczogZHVyLnNlY29uZHMsXG4gICAgICBtaWxsaXNlY29uZHM6IGR1ci5taWxsaXNlY29uZHMsXG4gICAgfSkuYXMoXCJtaWxsaXNlY29uZHNcIiksXG4gICAgbG9jYWxUUyA9IG9ialRvTG9jYWxUUyhjKTtcblxuICBsZXQgW3RzLCBvXSA9IGZpeE9mZnNldChsb2NhbFRTLCBvUHJlLCBpbnN0LnpvbmUpO1xuXG4gIGlmIChtaWxsaXNUb0FkZCAhPT0gMCkge1xuICAgIHRzICs9IG1pbGxpc1RvQWRkO1xuICAgIC8vIHRoYXQgY291bGQgaGF2ZSBjaGFuZ2VkIHRoZSBvZmZzZXQgYnkgZ29pbmcgb3ZlciBhIERTVCwgYnV0IHdlIHdhbnQgdG8ga2VlcCB0aGUgdHMgdGhlIHNhbWVcbiAgICBvID0gaW5zdC56b25lLm9mZnNldCh0cyk7XG4gIH1cblxuICByZXR1cm4geyB0cywgbyB9O1xufVxuXG4vLyBoZWxwZXIgdXNlZnVsIGluIHR1cm5pbmcgdGhlIHJlc3VsdHMgb2YgcGFyc2luZyBpbnRvIHJlYWwgZGF0ZXNcbi8vIGJ5IGhhbmRsaW5nIHRoZSB6b25lIG9wdGlvbnNcbmZ1bmN0aW9uIHBhcnNlRGF0YVRvRGF0ZVRpbWUocGFyc2VkLCBwYXJzZWRab25lLCBvcHRzLCBmb3JtYXQsIHRleHQsIHNwZWNpZmljT2Zmc2V0KSB7XG4gIGNvbnN0IHsgc2V0Wm9uZSwgem9uZSB9ID0gb3B0cztcbiAgaWYgKChwYXJzZWQgJiYgT2JqZWN0LmtleXMocGFyc2VkKS5sZW5ndGggIT09IDApIHx8IHBhcnNlZFpvbmUpIHtcbiAgICBjb25zdCBpbnRlcnByZXRhdGlvblpvbmUgPSBwYXJzZWRab25lIHx8IHpvbmUsXG4gICAgICBpbnN0ID0gRGF0ZVRpbWUuZnJvbU9iamVjdChwYXJzZWQsIHtcbiAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgem9uZTogaW50ZXJwcmV0YXRpb25ab25lLFxuICAgICAgICBzcGVjaWZpY09mZnNldCxcbiAgICAgIH0pO1xuICAgIHJldHVybiBzZXRab25lID8gaW5zdCA6IGluc3Quc2V0Wm9uZSh6b25lKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChcbiAgICAgIG5ldyBJbnZhbGlkKFwidW5wYXJzYWJsZVwiLCBgdGhlIGlucHV0IFwiJHt0ZXh0fVwiIGNhbid0IGJlIHBhcnNlZCBhcyAke2Zvcm1hdH1gKVxuICAgICk7XG4gIH1cbn1cblxuLy8gaWYgeW91IHdhbnQgdG8gb3V0cHV0IGEgdGVjaG5pY2FsIGZvcm1hdCAoZS5nLiBSRkMgMjgyMiksIHRoaXMgaGVscGVyXG4vLyBoZWxwcyBoYW5kbGUgdGhlIGRldGFpbHNcbmZ1bmN0aW9uIHRvVGVjaEZvcm1hdChkdCwgZm9ybWF0LCBhbGxvd1ogPSB0cnVlKSB7XG4gIHJldHVybiBkdC5pc1ZhbGlkXG4gICAgPyBGb3JtYXR0ZXIuY3JlYXRlKExvY2FsZS5jcmVhdGUoXCJlbi1VU1wiKSwge1xuICAgICAgICBhbGxvd1osXG4gICAgICAgIGZvcmNlU2ltcGxlOiB0cnVlLFxuICAgICAgfSkuZm9ybWF0RGF0ZVRpbWVGcm9tU3RyaW5nKGR0LCBmb3JtYXQpXG4gICAgOiBudWxsO1xufVxuXG5mdW5jdGlvbiB0b0lTT0RhdGUobywgZXh0ZW5kZWQpIHtcbiAgY29uc3QgbG9uZ0Zvcm1hdCA9IG8uYy55ZWFyID4gOTk5OSB8fCBvLmMueWVhciA8IDA7XG4gIGxldCBjID0gXCJcIjtcbiAgaWYgKGxvbmdGb3JtYXQgJiYgby5jLnllYXIgPj0gMCkgYyArPSBcIitcIjtcbiAgYyArPSBwYWRTdGFydChvLmMueWVhciwgbG9uZ0Zvcm1hdCA/IDYgOiA0KTtcblxuICBpZiAoZXh0ZW5kZWQpIHtcbiAgICBjICs9IFwiLVwiO1xuICAgIGMgKz0gcGFkU3RhcnQoby5jLm1vbnRoKTtcbiAgICBjICs9IFwiLVwiO1xuICAgIGMgKz0gcGFkU3RhcnQoby5jLmRheSk7XG4gIH0gZWxzZSB7XG4gICAgYyArPSBwYWRTdGFydChvLmMubW9udGgpO1xuICAgIGMgKz0gcGFkU3RhcnQoby5jLmRheSk7XG4gIH1cbiAgcmV0dXJuIGM7XG59XG5cbmZ1bmN0aW9uIHRvSVNPVGltZShcbiAgbyxcbiAgZXh0ZW5kZWQsXG4gIHN1cHByZXNzU2Vjb25kcyxcbiAgc3VwcHJlc3NNaWxsaXNlY29uZHMsXG4gIGluY2x1ZGVPZmZzZXQsXG4gIGV4dGVuZGVkWm9uZVxuKSB7XG4gIGxldCBjID0gcGFkU3RhcnQoby5jLmhvdXIpO1xuICBpZiAoZXh0ZW5kZWQpIHtcbiAgICBjICs9IFwiOlwiO1xuICAgIGMgKz0gcGFkU3RhcnQoby5jLm1pbnV0ZSk7XG4gICAgaWYgKG8uYy5taWxsaXNlY29uZCAhPT0gMCB8fCBvLmMuc2Vjb25kICE9PSAwIHx8ICFzdXBwcmVzc1NlY29uZHMpIHtcbiAgICAgIGMgKz0gXCI6XCI7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGMgKz0gcGFkU3RhcnQoby5jLm1pbnV0ZSk7XG4gIH1cblxuICBpZiAoby5jLm1pbGxpc2Vjb25kICE9PSAwIHx8IG8uYy5zZWNvbmQgIT09IDAgfHwgIXN1cHByZXNzU2Vjb25kcykge1xuICAgIGMgKz0gcGFkU3RhcnQoby5jLnNlY29uZCk7XG5cbiAgICBpZiAoby5jLm1pbGxpc2Vjb25kICE9PSAwIHx8ICFzdXBwcmVzc01pbGxpc2Vjb25kcykge1xuICAgICAgYyArPSBcIi5cIjtcbiAgICAgIGMgKz0gcGFkU3RhcnQoby5jLm1pbGxpc2Vjb25kLCAzKTtcbiAgICB9XG4gIH1cblxuICBpZiAoaW5jbHVkZU9mZnNldCkge1xuICAgIGlmIChvLmlzT2Zmc2V0Rml4ZWQgJiYgby5vZmZzZXQgPT09IDAgJiYgIWV4dGVuZGVkWm9uZSkge1xuICAgICAgYyArPSBcIlpcIjtcbiAgICB9IGVsc2UgaWYgKG8ubyA8IDApIHtcbiAgICAgIGMgKz0gXCItXCI7XG4gICAgICBjICs9IHBhZFN0YXJ0KE1hdGgudHJ1bmMoLW8ubyAvIDYwKSk7XG4gICAgICBjICs9IFwiOlwiO1xuICAgICAgYyArPSBwYWRTdGFydChNYXRoLnRydW5jKC1vLm8gJSA2MCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjICs9IFwiK1wiO1xuICAgICAgYyArPSBwYWRTdGFydChNYXRoLnRydW5jKG8ubyAvIDYwKSk7XG4gICAgICBjICs9IFwiOlwiO1xuICAgICAgYyArPSBwYWRTdGFydChNYXRoLnRydW5jKG8ubyAlIDYwKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGV4dGVuZGVkWm9uZSkge1xuICAgIGMgKz0gXCJbXCIgKyBvLnpvbmUuaWFuYU5hbWUgKyBcIl1cIjtcbiAgfVxuICByZXR1cm4gYztcbn1cblxuLy8gZGVmYXVsdHMgZm9yIHVuc3BlY2lmaWVkIHVuaXRzIGluIHRoZSBzdXBwb3J0ZWQgY2FsZW5kYXJzXG5jb25zdCBkZWZhdWx0VW5pdFZhbHVlcyA9IHtcbiAgICBtb250aDogMSxcbiAgICBkYXk6IDEsXG4gICAgaG91cjogMCxcbiAgICBtaW51dGU6IDAsXG4gICAgc2Vjb25kOiAwLFxuICAgIG1pbGxpc2Vjb25kOiAwLFxuICB9LFxuICBkZWZhdWx0V2Vla1VuaXRWYWx1ZXMgPSB7XG4gICAgd2Vla051bWJlcjogMSxcbiAgICB3ZWVrZGF5OiAxLFxuICAgIGhvdXI6IDAsXG4gICAgbWludXRlOiAwLFxuICAgIHNlY29uZDogMCxcbiAgICBtaWxsaXNlY29uZDogMCxcbiAgfSxcbiAgZGVmYXVsdE9yZGluYWxVbml0VmFsdWVzID0ge1xuICAgIG9yZGluYWw6IDEsXG4gICAgaG91cjogMCxcbiAgICBtaW51dGU6IDAsXG4gICAgc2Vjb25kOiAwLFxuICAgIG1pbGxpc2Vjb25kOiAwLFxuICB9O1xuXG4vLyBVbml0cyBpbiB0aGUgc3VwcG9ydGVkIGNhbGVuZGFycywgc29ydGVkIGJ5IGJpZ25lc3NcbmNvbnN0IG9yZGVyZWRVbml0cyA9IFtcInllYXJcIiwgXCJtb250aFwiLCBcImRheVwiLCBcImhvdXJcIiwgXCJtaW51dGVcIiwgXCJzZWNvbmRcIiwgXCJtaWxsaXNlY29uZFwiXSxcbiAgb3JkZXJlZFdlZWtVbml0cyA9IFtcbiAgICBcIndlZWtZZWFyXCIsXG4gICAgXCJ3ZWVrTnVtYmVyXCIsXG4gICAgXCJ3ZWVrZGF5XCIsXG4gICAgXCJob3VyXCIsXG4gICAgXCJtaW51dGVcIixcbiAgICBcInNlY29uZFwiLFxuICAgIFwibWlsbGlzZWNvbmRcIixcbiAgXSxcbiAgb3JkZXJlZE9yZGluYWxVbml0cyA9IFtcInllYXJcIiwgXCJvcmRpbmFsXCIsIFwiaG91clwiLCBcIm1pbnV0ZVwiLCBcInNlY29uZFwiLCBcIm1pbGxpc2Vjb25kXCJdO1xuXG4vLyBzdGFuZGFyZGl6ZSBjYXNlIGFuZCBwbHVyYWxpdHkgaW4gdW5pdHNcbmZ1bmN0aW9uIG5vcm1hbGl6ZVVuaXQodW5pdCkge1xuICBjb25zdCBub3JtYWxpemVkID0ge1xuICAgIHllYXI6IFwieWVhclwiLFxuICAgIHllYXJzOiBcInllYXJcIixcbiAgICBtb250aDogXCJtb250aFwiLFxuICAgIG1vbnRoczogXCJtb250aFwiLFxuICAgIGRheTogXCJkYXlcIixcbiAgICBkYXlzOiBcImRheVwiLFxuICAgIGhvdXI6IFwiaG91clwiLFxuICAgIGhvdXJzOiBcImhvdXJcIixcbiAgICBtaW51dGU6IFwibWludXRlXCIsXG4gICAgbWludXRlczogXCJtaW51dGVcIixcbiAgICBxdWFydGVyOiBcInF1YXJ0ZXJcIixcbiAgICBxdWFydGVyczogXCJxdWFydGVyXCIsXG4gICAgc2Vjb25kOiBcInNlY29uZFwiLFxuICAgIHNlY29uZHM6IFwic2Vjb25kXCIsXG4gICAgbWlsbGlzZWNvbmQ6IFwibWlsbGlzZWNvbmRcIixcbiAgICBtaWxsaXNlY29uZHM6IFwibWlsbGlzZWNvbmRcIixcbiAgICB3ZWVrZGF5OiBcIndlZWtkYXlcIixcbiAgICB3ZWVrZGF5czogXCJ3ZWVrZGF5XCIsXG4gICAgd2Vla251bWJlcjogXCJ3ZWVrTnVtYmVyXCIsXG4gICAgd2Vla3NudW1iZXI6IFwid2Vla051bWJlclwiLFxuICAgIHdlZWtudW1iZXJzOiBcIndlZWtOdW1iZXJcIixcbiAgICB3ZWVreWVhcjogXCJ3ZWVrWWVhclwiLFxuICAgIHdlZWt5ZWFyczogXCJ3ZWVrWWVhclwiLFxuICAgIG9yZGluYWw6IFwib3JkaW5hbFwiLFxuICB9W3VuaXQudG9Mb3dlckNhc2UoKV07XG5cbiAgaWYgKCFub3JtYWxpemVkKSB0aHJvdyBuZXcgSW52YWxpZFVuaXRFcnJvcih1bml0KTtcblxuICByZXR1cm4gbm9ybWFsaXplZDtcbn1cblxuLy8gdGhpcyBpcyBhIGR1bWJlZCBkb3duIHZlcnNpb24gb2YgZnJvbU9iamVjdCgpIHRoYXQgcnVucyBhYm91dCA2MCUgZmFzdGVyXG4vLyBidXQgZG9lc24ndCBkbyBhbnkgdmFsaWRhdGlvbiwgbWFrZXMgYSBidW5jaCBvZiBhc3N1bXB0aW9ucyBhYm91dCB3aGF0IHVuaXRzXG4vLyBhcmUgcHJlc2VudCwgYW5kIHNvIG9uLlxuZnVuY3Rpb24gcXVpY2tEVChvYmosIG9wdHMpIHtcbiAgY29uc3Qgem9uZSA9IG5vcm1hbGl6ZVpvbmUob3B0cy56b25lLCBTZXR0aW5ncy5kZWZhdWx0Wm9uZSksXG4gICAgbG9jID0gTG9jYWxlLmZyb21PYmplY3Qob3B0cyksXG4gICAgdHNOb3cgPSBTZXR0aW5ncy5ub3coKTtcblxuICBsZXQgdHMsIG87XG5cbiAgLy8gYXNzdW1lIHdlIGhhdmUgdGhlIGhpZ2hlci1vcmRlciB1bml0c1xuICBpZiAoIWlzVW5kZWZpbmVkKG9iai55ZWFyKSkge1xuICAgIGZvciAoY29uc3QgdSBvZiBvcmRlcmVkVW5pdHMpIHtcbiAgICAgIGlmIChpc1VuZGVmaW5lZChvYmpbdV0pKSB7XG4gICAgICAgIG9ialt1XSA9IGRlZmF1bHRVbml0VmFsdWVzW3VdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGludmFsaWQgPSBoYXNJbnZhbGlkR3JlZ29yaWFuRGF0YShvYmopIHx8IGhhc0ludmFsaWRUaW1lRGF0YShvYmopO1xuICAgIGlmIChpbnZhbGlkKSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChpbnZhbGlkKTtcbiAgICB9XG5cbiAgICBjb25zdCBvZmZzZXRQcm92aXMgPSB6b25lLm9mZnNldCh0c05vdyk7XG4gICAgW3RzLCBvXSA9IG9ialRvVFMob2JqLCBvZmZzZXRQcm92aXMsIHpvbmUpO1xuICB9IGVsc2Uge1xuICAgIHRzID0gdHNOb3c7XG4gIH1cblxuICByZXR1cm4gbmV3IERhdGVUaW1lKHsgdHMsIHpvbmUsIGxvYywgbyB9KTtcbn1cblxuZnVuY3Rpb24gZGlmZlJlbGF0aXZlKHN0YXJ0LCBlbmQsIG9wdHMpIHtcbiAgY29uc3Qgcm91bmQgPSBpc1VuZGVmaW5lZChvcHRzLnJvdW5kKSA/IHRydWUgOiBvcHRzLnJvdW5kLFxuICAgIGZvcm1hdCA9IChjLCB1bml0KSA9PiB7XG4gICAgICBjID0gcm91bmRUbyhjLCByb3VuZCB8fCBvcHRzLmNhbGVuZGFyeSA/IDAgOiAyLCB0cnVlKTtcbiAgICAgIGNvbnN0IGZvcm1hdHRlciA9IGVuZC5sb2MuY2xvbmUob3B0cykucmVsRm9ybWF0dGVyKG9wdHMpO1xuICAgICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXQoYywgdW5pdCk7XG4gICAgfSxcbiAgICBkaWZmZXIgPSAodW5pdCkgPT4ge1xuICAgICAgaWYgKG9wdHMuY2FsZW5kYXJ5KSB7XG4gICAgICAgIGlmICghZW5kLmhhc1NhbWUoc3RhcnQsIHVuaXQpKSB7XG4gICAgICAgICAgcmV0dXJuIGVuZC5zdGFydE9mKHVuaXQpLmRpZmYoc3RhcnQuc3RhcnRPZih1bml0KSwgdW5pdCkuZ2V0KHVuaXQpO1xuICAgICAgICB9IGVsc2UgcmV0dXJuIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZW5kLmRpZmYoc3RhcnQsIHVuaXQpLmdldCh1bml0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIGlmIChvcHRzLnVuaXQpIHtcbiAgICByZXR1cm4gZm9ybWF0KGRpZmZlcihvcHRzLnVuaXQpLCBvcHRzLnVuaXQpO1xuICB9XG5cbiAgZm9yIChjb25zdCB1bml0IG9mIG9wdHMudW5pdHMpIHtcbiAgICBjb25zdCBjb3VudCA9IGRpZmZlcih1bml0KTtcbiAgICBpZiAoTWF0aC5hYnMoY291bnQpID49IDEpIHtcbiAgICAgIHJldHVybiBmb3JtYXQoY291bnQsIHVuaXQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZm9ybWF0KHN0YXJ0ID4gZW5kID8gLTAgOiAwLCBvcHRzLnVuaXRzW29wdHMudW5pdHMubGVuZ3RoIC0gMV0pO1xufVxuXG5mdW5jdGlvbiBsYXN0T3B0cyhhcmdMaXN0KSB7XG4gIGxldCBvcHRzID0ge30sXG4gICAgYXJncztcbiAgaWYgKGFyZ0xpc3QubGVuZ3RoID4gMCAmJiB0eXBlb2YgYXJnTGlzdFthcmdMaXN0Lmxlbmd0aCAtIDFdID09PSBcIm9iamVjdFwiKSB7XG4gICAgb3B0cyA9IGFyZ0xpc3RbYXJnTGlzdC5sZW5ndGggLSAxXTtcbiAgICBhcmdzID0gQXJyYXkuZnJvbShhcmdMaXN0KS5zbGljZSgwLCBhcmdMaXN0Lmxlbmd0aCAtIDEpO1xuICB9IGVsc2Uge1xuICAgIGFyZ3MgPSBBcnJheS5mcm9tKGFyZ0xpc3QpO1xuICB9XG4gIHJldHVybiBbb3B0cywgYXJnc107XG59XG5cbi8qKlxuICogQSBEYXRlVGltZSBpcyBhbiBpbW11dGFibGUgZGF0YSBzdHJ1Y3R1cmUgcmVwcmVzZW50aW5nIGEgc3BlY2lmaWMgZGF0ZSBhbmQgdGltZSBhbmQgYWNjb21wYW55aW5nIG1ldGhvZHMuIEl0IGNvbnRhaW5zIGNsYXNzIGFuZCBpbnN0YW5jZSBtZXRob2RzIGZvciBjcmVhdGluZywgcGFyc2luZywgaW50ZXJyb2dhdGluZywgdHJhbnNmb3JtaW5nLCBhbmQgZm9ybWF0dGluZyB0aGVtLlxuICpcbiAqIEEgRGF0ZVRpbWUgY29tcHJpc2VzIG9mOlxuICogKiBBIHRpbWVzdGFtcC4gRWFjaCBEYXRlVGltZSBpbnN0YW5jZSByZWZlcnMgdG8gYSBzcGVjaWZpYyBtaWxsaXNlY29uZCBvZiB0aGUgVW5peCBlcG9jaC5cbiAqICogQSB0aW1lIHpvbmUuIEVhY2ggaW5zdGFuY2UgaXMgY29uc2lkZXJlZCBpbiB0aGUgY29udGV4dCBvZiBhIHNwZWNpZmljIHpvbmUgKGJ5IGRlZmF1bHQgdGhlIGxvY2FsIHN5c3RlbSdzIHpvbmUpLlxuICogKiBDb25maWd1cmF0aW9uIHByb3BlcnRpZXMgdGhhdCBlZmZlY3QgaG93IG91dHB1dCBzdHJpbmdzIGFyZSBmb3JtYXR0ZWQsIHN1Y2ggYXMgYGxvY2FsZWAsIGBudW1iZXJpbmdTeXN0ZW1gLCBhbmQgYG91dHB1dENhbGVuZGFyYC5cbiAqXG4gKiBIZXJlIGlzIGEgYnJpZWYgb3ZlcnZpZXcgb2YgdGhlIG1vc3QgY29tbW9ubHkgdXNlZCBmdW5jdGlvbmFsaXR5IGl0IHByb3ZpZGVzOlxuICpcbiAqICogKipDcmVhdGlvbioqOiBUbyBjcmVhdGUgYSBEYXRlVGltZSBmcm9tIGl0cyBjb21wb25lbnRzLCB1c2Ugb25lIG9mIGl0cyBmYWN0b3J5IGNsYXNzIG1ldGhvZHM6IHtAbGluayBEYXRlVGltZS5sb2NhbH0sIHtAbGluayBEYXRlVGltZS51dGN9LCBhbmQgKG1vc3QgZmxleGlibHkpIHtAbGluayBEYXRlVGltZS5mcm9tT2JqZWN0fS4gVG8gY3JlYXRlIG9uZSBmcm9tIGEgc3RhbmRhcmQgc3RyaW5nIGZvcm1hdCwgdXNlIHtAbGluayBEYXRlVGltZS5mcm9tSVNPfSwge0BsaW5rIERhdGVUaW1lLmZyb21IVFRQfSwgYW5kIHtAbGluayBEYXRlVGltZS5mcm9tUkZDMjgyMn0uIFRvIGNyZWF0ZSBvbmUgZnJvbSBhIGN1c3RvbSBzdHJpbmcgZm9ybWF0LCB1c2Uge0BsaW5rIERhdGVUaW1lLmZyb21Gb3JtYXR9LiBUbyBjcmVhdGUgb25lIGZyb20gYSBuYXRpdmUgSlMgZGF0ZSwgdXNlIHtAbGluayBEYXRlVGltZS5mcm9tSlNEYXRlfS5cbiAqICogKipHcmVnb3JpYW4gY2FsZW5kYXIgYW5kIHRpbWUqKjogVG8gZXhhbWluZSB0aGUgR3JlZ29yaWFuIHByb3BlcnRpZXMgb2YgYSBEYXRlVGltZSBpbmRpdmlkdWFsbHkgKGkuZSBhcyBvcHBvc2VkIHRvIGNvbGxlY3RpdmVseSB0aHJvdWdoIHtAbGluayBEYXRlVGltZSN0b09iamVjdH0pLCB1c2UgdGhlIHtAbGluayBEYXRlVGltZSN5ZWFyfSwge0BsaW5rIERhdGVUaW1lI21vbnRofSxcbiAqIHtAbGluayBEYXRlVGltZSNkYXl9LCB7QGxpbmsgRGF0ZVRpbWUjaG91cn0sIHtAbGluayBEYXRlVGltZSNtaW51dGV9LCB7QGxpbmsgRGF0ZVRpbWUjc2Vjb25kfSwge0BsaW5rIERhdGVUaW1lI21pbGxpc2Vjb25kfSBhY2Nlc3NvcnMuXG4gKiAqICoqV2VlayBjYWxlbmRhcioqOiBGb3IgSVNPIHdlZWsgY2FsZW5kYXIgYXR0cmlidXRlcywgc2VlIHRoZSB7QGxpbmsgRGF0ZVRpbWUjd2Vla1llYXJ9LCB7QGxpbmsgRGF0ZVRpbWUjd2Vla051bWJlcn0sIGFuZCB7QGxpbmsgRGF0ZVRpbWUjd2Vla2RheX0gYWNjZXNzb3JzLlxuICogKiAqKkNvbmZpZ3VyYXRpb24qKiBTZWUgdGhlIHtAbGluayBEYXRlVGltZSNsb2NhbGV9IGFuZCB7QGxpbmsgRGF0ZVRpbWUjbnVtYmVyaW5nU3lzdGVtfSBhY2Nlc3NvcnMuXG4gKiAqICoqVHJhbnNmb3JtYXRpb24qKjogVG8gdHJhbnNmb3JtIHRoZSBEYXRlVGltZSBpbnRvIG90aGVyIERhdGVUaW1lcywgdXNlIHtAbGluayBEYXRlVGltZSNzZXR9LCB7QGxpbmsgRGF0ZVRpbWUjcmVjb25maWd1cmV9LCB7QGxpbmsgRGF0ZVRpbWUjc2V0Wm9uZX0sIHtAbGluayBEYXRlVGltZSNzZXRMb2NhbGV9LCB7QGxpbmsgRGF0ZVRpbWUucGx1c30sIHtAbGluayBEYXRlVGltZSNtaW51c30sIHtAbGluayBEYXRlVGltZSNlbmRPZn0sIHtAbGluayBEYXRlVGltZSNzdGFydE9mfSwge0BsaW5rIERhdGVUaW1lI3RvVVRDfSwgYW5kIHtAbGluayBEYXRlVGltZSN0b0xvY2FsfS5cbiAqICogKipPdXRwdXQqKjogVG8gY29udmVydCB0aGUgRGF0ZVRpbWUgdG8gb3RoZXIgcmVwcmVzZW50YXRpb25zLCB1c2UgdGhlIHtAbGluayBEYXRlVGltZSN0b1JlbGF0aXZlfSwge0BsaW5rIERhdGVUaW1lI3RvUmVsYXRpdmVDYWxlbmRhcn0sIHtAbGluayBEYXRlVGltZSN0b0pTT059LCB7QGxpbmsgRGF0ZVRpbWUjdG9JU099LCB7QGxpbmsgRGF0ZVRpbWUjdG9IVFRQfSwge0BsaW5rIERhdGVUaW1lI3RvT2JqZWN0fSwge0BsaW5rIERhdGVUaW1lI3RvUkZDMjgyMn0sIHtAbGluayBEYXRlVGltZSN0b1N0cmluZ30sIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30sIHtAbGluayBEYXRlVGltZSN0b0Zvcm1hdH0sIHtAbGluayBEYXRlVGltZSN0b01pbGxpc30gYW5kIHtAbGluayBEYXRlVGltZSN0b0pTRGF0ZX0uXG4gKlxuICogVGhlcmUncyBwbGVudHkgb3RoZXJzIGRvY3VtZW50ZWQgYmVsb3cuIEluIGFkZGl0aW9uLCBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBzdWJ0bGVyIHRvcGljcyBsaWtlIGludGVybmF0aW9uYWxpemF0aW9uLCB0aW1lIHpvbmVzLCBhbHRlcm5hdGl2ZSBjYWxlbmRhcnMsIHZhbGlkaXR5LCBhbmQgc28gb24sIHNlZSB0aGUgZXh0ZXJuYWwgZG9jdW1lbnRhdGlvbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGF0ZVRpbWUge1xuICAvKipcbiAgICogQGFjY2VzcyBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBjb25zdCB6b25lID0gY29uZmlnLnpvbmUgfHwgU2V0dGluZ3MuZGVmYXVsdFpvbmU7XG5cbiAgICBsZXQgaW52YWxpZCA9XG4gICAgICBjb25maWcuaW52YWxpZCB8fFxuICAgICAgKE51bWJlci5pc05hTihjb25maWcudHMpID8gbmV3IEludmFsaWQoXCJpbnZhbGlkIGlucHV0XCIpIDogbnVsbCkgfHxcbiAgICAgICghem9uZS5pc1ZhbGlkID8gdW5zdXBwb3J0ZWRab25lKHpvbmUpIDogbnVsbCk7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy50cyA9IGlzVW5kZWZpbmVkKGNvbmZpZy50cykgPyBTZXR0aW5ncy5ub3coKSA6IGNvbmZpZy50cztcblxuICAgIGxldCBjID0gbnVsbCxcbiAgICAgIG8gPSBudWxsO1xuICAgIGlmICghaW52YWxpZCkge1xuICAgICAgY29uc3QgdW5jaGFuZ2VkID0gY29uZmlnLm9sZCAmJiBjb25maWcub2xkLnRzID09PSB0aGlzLnRzICYmIGNvbmZpZy5vbGQuem9uZS5lcXVhbHMoem9uZSk7XG5cbiAgICAgIGlmICh1bmNoYW5nZWQpIHtcbiAgICAgICAgW2MsIG9dID0gW2NvbmZpZy5vbGQuYywgY29uZmlnLm9sZC5vXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG90ID0gem9uZS5vZmZzZXQodGhpcy50cyk7XG4gICAgICAgIGMgPSB0c1RvT2JqKHRoaXMudHMsIG90KTtcbiAgICAgICAgaW52YWxpZCA9IE51bWJlci5pc05hTihjLnllYXIpID8gbmV3IEludmFsaWQoXCJpbnZhbGlkIGlucHV0XCIpIDogbnVsbDtcbiAgICAgICAgYyA9IGludmFsaWQgPyBudWxsIDogYztcbiAgICAgICAgbyA9IGludmFsaWQgPyBudWxsIDogb3Q7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fem9uZSA9IHpvbmU7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5sb2MgPSBjb25maWcubG9jIHx8IExvY2FsZS5jcmVhdGUoKTtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmludmFsaWQgPSBpbnZhbGlkO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMud2Vla0RhdGEgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuYyA9IGM7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5vID0gbztcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmlzTHV4b25EYXRlVGltZSA9IHRydWU7XG4gIH1cblxuICAvLyBDT05TVFJVQ1RcblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZm9yIHRoZSBjdXJyZW50IGluc3RhbnQsIGluIHRoZSBzeXN0ZW0ncyB0aW1lIHpvbmUuXG4gICAqXG4gICAqIFVzZSBTZXR0aW5ncyB0byBvdmVycmlkZSB0aGVzZSBkZWZhdWx0IHZhbHVlcyBpZiBuZWVkZWQuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvSVNPKCkgLy9+PiBub3cgaW4gdGhlIElTTyBmb3JtYXRcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgbm93KCkge1xuICAgIHJldHVybiBuZXcgRGF0ZVRpbWUoe30pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGxvY2FsIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeWVhcl0gLSBUaGUgY2FsZW5kYXIgeWVhci4gSWYgb21pdHRlZCAoYXMgaW4sIGNhbGwgYGxvY2FsKClgIHdpdGggbm8gYXJndW1lbnRzKSwgdGhlIGN1cnJlbnQgdGltZSB3aWxsIGJlIHVzZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttb250aD0xXSAtIFRoZSBtb250aCwgMS1pbmRleGVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZGF5PTFdIC0gVGhlIGRheSBvZiB0aGUgbW9udGgsIDEtaW5kZXhlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2hvdXI9MF0gLSBUaGUgaG91ciBvZiB0aGUgZGF5LCBpbiAyNC1ob3VyIHRpbWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttaW51dGU9MF0gLSBUaGUgbWludXRlIG9mIHRoZSBob3VyLCBtZWFuaW5nIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgNTlcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzZWNvbmQ9MF0gLSBUaGUgc2Vjb25kIG9mIHRoZSBtaW51dGUsIG1lYW5pbmcgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCA1OVxuICAgKiBAcGFyYW0ge251bWJlcn0gW21pbGxpc2Vjb25kPTBdIC0gVGhlIG1pbGxpc2Vjb25kIG9mIHRoZSBzZWNvbmQsIG1lYW5pbmcgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCA5OTlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IG5vd1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCh7IHpvbmU6IFwiQW1lcmljYS9OZXdfWW9ya1wiIH0pICAgICAgLy9+PiBub3csIGluIFVTIGVhc3QgY29hc3QgdGltZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3KSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMS0wMVQwMDowMDowMFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAzKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0wMVQwMDowMDowMFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAzLCAxMiwgeyBsb2NhbGU6IFwiZnJcIiB9KSAgICAgLy9+PiAyMDE3LTAzLTEyVDAwOjAwOjAwLCB3aXRoIGEgRnJlbmNoIGxvY2FsZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAzLCAxMiwgNSkgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwNTowMDowMFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAzLCAxMiwgNSwgeyB6b25lOiBcInV0Y1wiIH0pICAgLy9+PiAyMDE3LTAzLTEyVDA1OjAwOjAwLCBpbiBVVENcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMywgMTIsIDUsIDQ1KSAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6NDU6MDBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMywgMTIsIDUsIDQ1LCAxMCkgICAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6NDU6MTBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMywgMTIsIDUsIDQ1LCAxMCwgNzY1KSAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6NDU6MTAuNzY1XG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGxvY2FsKCkge1xuICAgIGNvbnN0IFtvcHRzLCBhcmdzXSA9IGxhc3RPcHRzKGFyZ3VtZW50cyksXG4gICAgICBbeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kXSA9IGFyZ3M7XG4gICAgcmV0dXJuIHF1aWNrRFQoeyB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQgfSwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgaW4gVVRDXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeWVhcl0gLSBUaGUgY2FsZW5kYXIgeWVhci4gSWYgb21pdHRlZCAoYXMgaW4sIGNhbGwgYHV0YygpYCB3aXRoIG5vIGFyZ3VtZW50cyksIHRoZSBjdXJyZW50IHRpbWUgd2lsbCBiZSB1c2VkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbW9udGg9MV0gLSBUaGUgbW9udGgsIDEtaW5kZXhlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RheT0xXSAtIFRoZSBkYXkgb2YgdGhlIG1vbnRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbaG91cj0wXSAtIFRoZSBob3VyIG9mIHRoZSBkYXksIGluIDI0LWhvdXIgdGltZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW21pbnV0ZT0wXSAtIFRoZSBtaW51dGUgb2YgdGhlIGhvdXIsIG1lYW5pbmcgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCA1OVxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NlY29uZD0wXSAtIFRoZSBzZWNvbmQgb2YgdGhlIG1pbnV0ZSwgbWVhbmluZyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDU5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbWlsbGlzZWNvbmQ9MF0gLSBUaGUgbWlsbGlzZWNvbmQgb2YgdGhlIHNlY29uZCwgbWVhbmluZyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDk5OVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sb2NhbGVdIC0gYSBsb2NhbGUgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm91dHB1dENhbGVuZGFyXSAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm51bWJlcmluZ1N5c3RlbV0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IG5vd1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNykgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDEtMDFUMDA6MDA6MDBaXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3LCAzKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0wMVQwMDowMDowMFpcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTcsIDMsIDEyKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9+PiAyMDE3LTAzLTEyVDAwOjAwOjAwWlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNywgMywgMTIsIDUpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6MDA6MDBaXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3LCAzLCAxMiwgNSwgNDUpICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwNTo0NTowMFpcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTcsIDMsIDEyLCA1LCA0NSwgeyBsb2NhbGU6IFwiZnJcIiB9KSAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6NDU6MDBaIHdpdGggYSBGcmVuY2ggbG9jYWxlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3LCAzLCAxMiwgNSwgNDUsIDEwKSAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwNTo0NToxMFpcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTcsIDMsIDEyLCA1LCA0NSwgMTAsIDc2NSwgeyBsb2NhbGU6IFwiZnJcIiB9KSAvL34+IDIwMTctMDMtMTJUMDU6NDU6MTAuNzY1WiB3aXRoIGEgRnJlbmNoIGxvY2FsZVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyB1dGMoKSB7XG4gICAgY29uc3QgW29wdHMsIGFyZ3NdID0gbGFzdE9wdHMoYXJndW1lbnRzKSxcbiAgICAgIFt5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmRdID0gYXJncztcblxuICAgIG9wdHMuem9uZSA9IEZpeGVkT2Zmc2V0Wm9uZS51dGNJbnN0YW5jZTtcbiAgICByZXR1cm4gcXVpY2tEVCh7IHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCB9LCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGEgSmF2YVNjcmlwdCBEYXRlIG9iamVjdC4gVXNlcyB0aGUgZGVmYXVsdCB6b25lLlxuICAgKiBAcGFyYW0ge0RhdGV9IGRhdGUgLSBhIEphdmFTY3JpcHQgRGF0ZSBvYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBEYXRlVGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0aW9ucy56b25lPSdsb2NhbCddIC0gdGhlIHpvbmUgdG8gcGxhY2UgdGhlIERhdGVUaW1lIGludG9cbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbUpTRGF0ZShkYXRlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB0cyA9IGlzRGF0ZShkYXRlKSA/IGRhdGUudmFsdWVPZigpIDogTmFOO1xuICAgIGlmIChOdW1iZXIuaXNOYU4odHMpKSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChcImludmFsaWQgaW5wdXRcIik7XG4gICAgfVxuXG4gICAgY29uc3Qgem9uZVRvVXNlID0gbm9ybWFsaXplWm9uZShvcHRpb25zLnpvbmUsIFNldHRpbmdzLmRlZmF1bHRab25lKTtcbiAgICBpZiAoIXpvbmVUb1VzZS5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZCh1bnN1cHBvcnRlZFpvbmUoem9uZVRvVXNlKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBEYXRlVGltZSh7XG4gICAgICB0czogdHMsXG4gICAgICB6b25lOiB6b25lVG9Vc2UsXG4gICAgICBsb2M6IExvY2FsZS5mcm9tT2JqZWN0KG9wdGlvbnMpLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBlcG9jaCAobWVhbmluZyBzaW5jZSAxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLiBVc2VzIHRoZSBkZWZhdWx0IHpvbmUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaWxsaXNlY29uZHMgLSBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2UgMTk3MCBVVENcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBEYXRlVGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0aW9ucy56b25lPSdsb2NhbCddIC0gdGhlIHpvbmUgdG8gcGxhY2UgdGhlIERhdGVUaW1lIGludG9cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxvY2FsZV0gLSBhIGxvY2FsZSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5vdXRwdXRDYWxlbmRhciAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbU1pbGxpcyhtaWxsaXNlY29uZHMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghaXNOdW1iZXIobWlsbGlzZWNvbmRzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFxuICAgICAgICBgZnJvbU1pbGxpcyByZXF1aXJlcyBhIG51bWVyaWNhbCBpbnB1dCwgYnV0IHJlY2VpdmVkIGEgJHt0eXBlb2YgbWlsbGlzZWNvbmRzfSB3aXRoIHZhbHVlICR7bWlsbGlzZWNvbmRzfWBcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChtaWxsaXNlY29uZHMgPCAtTUFYX0RBVEUgfHwgbWlsbGlzZWNvbmRzID4gTUFYX0RBVEUpIHtcbiAgICAgIC8vIHRoaXMgaXNuJ3QgcGVyZmVjdCBiZWNhdXNlIGJlY2F1c2Ugd2UgY2FuIHN0aWxsIGVuZCB1cCBvdXQgb2YgcmFuZ2UgYmVjYXVzZSBvZiBhZGRpdGlvbmFsIHNoaWZ0aW5nLCBidXQgaXQncyBhIHN0YXJ0XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChcIlRpbWVzdGFtcCBvdXQgb2YgcmFuZ2VcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZVRpbWUoe1xuICAgICAgICB0czogbWlsbGlzZWNvbmRzLFxuICAgICAgICB6b25lOiBub3JtYWxpemVab25lKG9wdGlvbnMuem9uZSwgU2V0dGluZ3MuZGVmYXVsdFpvbmUpLFxuICAgICAgICBsb2M6IExvY2FsZS5mcm9tT2JqZWN0KG9wdGlvbnMpLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYSBudW1iZXIgb2Ygc2Vjb25kcyBzaW5jZSB0aGUgZXBvY2ggKG1lYW5pbmcgc2luY2UgMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS4gVXNlcyB0aGUgZGVmYXVsdCB6b25lLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Vjb25kcyAtIGEgbnVtYmVyIG9mIHNlY29uZHMgc2luY2UgMTk3MCBVVENcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBEYXRlVGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0aW9ucy56b25lPSdsb2NhbCddIC0gdGhlIHpvbmUgdG8gcGxhY2UgdGhlIERhdGVUaW1lIGludG9cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxvY2FsZV0gLSBhIGxvY2FsZSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5vdXRwdXRDYWxlbmRhciAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbVNlY29uZHMoc2Vjb25kcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFpc051bWJlcihzZWNvbmRzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiZnJvbVNlY29uZHMgcmVxdWlyZXMgYSBudW1lcmljYWwgaW5wdXRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZVRpbWUoe1xuICAgICAgICB0czogc2Vjb25kcyAqIDEwMDAsXG4gICAgICAgIHpvbmU6IG5vcm1hbGl6ZVpvbmUob3B0aW9ucy56b25lLCBTZXR0aW5ncy5kZWZhdWx0Wm9uZSksXG4gICAgICAgIGxvYzogTG9jYWxlLmZyb21PYmplY3Qob3B0aW9ucyksXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhIEphdmFTY3JpcHQgb2JqZWN0IHdpdGgga2V5cyBsaWtlICd5ZWFyJyBhbmQgJ2hvdXInIHdpdGggcmVhc29uYWJsZSBkZWZhdWx0cy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIHRoZSBvYmplY3QgdG8gY3JlYXRlIHRoZSBEYXRlVGltZSBmcm9tXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoueWVhciAtIGEgeWVhciwgc3VjaCBhcyAxOTg3XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoubW9udGggLSBhIG1vbnRoLCAxLTEyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmouZGF5IC0gYSBkYXkgb2YgdGhlIG1vbnRoLCAxLTMxLCBkZXBlbmRpbmcgb24gdGhlIG1vbnRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoub3JkaW5hbCAtIGRheSBvZiB0aGUgeWVhciwgMS0zNjUgb3IgMzY2XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoud2Vla1llYXIgLSBhbiBJU08gd2VlayB5ZWFyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoud2Vla051bWJlciAtIGFuIElTTyB3ZWVrIG51bWJlciwgYmV0d2VlbiAxIGFuZCA1MiBvciA1MywgZGVwZW5kaW5nIG9uIHRoZSB5ZWFyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoud2Vla2RheSAtIGFuIElTTyB3ZWVrZGF5LCAxLTcsIHdoZXJlIDEgaXMgTW9uZGF5IGFuZCA3IGlzIFN1bmRheVxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLmhvdXIgLSBob3VyIG9mIHRoZSBkYXksIDAtMjNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5taW51dGUgLSBtaW51dGUgb2YgdGhlIGhvdXIsIDAtNTlcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5zZWNvbmQgLSBzZWNvbmQgb2YgdGhlIG1pbnV0ZSwgMC01OVxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLm1pbGxpc2Vjb25kIC0gbWlsbGlzZWNvbmQgb2YgdGhlIHNlY29uZCwgMC05OTlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIGZvciBjcmVhdGluZyB0aGlzIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFtvcHRzLnpvbmU9J2xvY2FsJ10gLSBpbnRlcnByZXQgdGhlIG51bWJlcnMgaW4gdGhlIGNvbnRleHQgb2YgYSBwYXJ0aWN1bGFyIHpvbmUuIENhbiB0YWtlIGFueSB2YWx1ZSB0YWtlbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gc2V0Wm9uZSgpXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J3N5c3RlbSdzIGxvY2FsZSddIC0gYSBsb2NhbGUgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMub3V0cHV0Q2FsZW5kYXIgLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyB5ZWFyOiAxOTgyLCBtb250aDogNSwgZGF5OiAyNX0pLnRvSVNPRGF0ZSgpIC8vPT4gJzE5ODItMDUtMjUnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyB5ZWFyOiAxOTgyIH0pLnRvSVNPRGF0ZSgpIC8vPT4gJzE5ODItMDEtMDEnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyBob3VyOiAxMCwgbWludXRlOiAyNiwgc2Vjb25kOiA2IH0pIC8vfj4gdG9kYXkgYXQgMTA6MjY6MDZcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbU9iamVjdCh7IGhvdXI6IDEwLCBtaW51dGU6IDI2LCBzZWNvbmQ6IDYgfSwgeyB6b25lOiAndXRjJyB9KSxcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbU9iamVjdCh7IGhvdXI6IDEwLCBtaW51dGU6IDI2LCBzZWNvbmQ6IDYgfSwgeyB6b25lOiAnbG9jYWwnIH0pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyBob3VyOiAxMCwgbWludXRlOiAyNiwgc2Vjb25kOiA2IH0sIHsgem9uZTogJ0FtZXJpY2EvTmV3X1lvcmsnIH0pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyB3ZWVrWWVhcjogMjAxNiwgd2Vla051bWJlcjogMiwgd2Vla2RheTogMyB9KS50b0lTT0RhdGUoKSAvLz0+ICcyMDE2LTAxLTEzJ1xuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tT2JqZWN0KG9iaiwgb3B0cyA9IHt9KSB7XG4gICAgb2JqID0gb2JqIHx8IHt9O1xuICAgIGNvbnN0IHpvbmVUb1VzZSA9IG5vcm1hbGl6ZVpvbmUob3B0cy56b25lLCBTZXR0aW5ncy5kZWZhdWx0Wm9uZSk7XG4gICAgaWYgKCF6b25lVG9Vc2UuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQodW5zdXBwb3J0ZWRab25lKHpvbmVUb1VzZSkpO1xuICAgIH1cblxuICAgIGNvbnN0IHRzTm93ID0gU2V0dGluZ3Mubm93KCksXG4gICAgICBvZmZzZXRQcm92aXMgPSAhaXNVbmRlZmluZWQob3B0cy5zcGVjaWZpY09mZnNldClcbiAgICAgICAgPyBvcHRzLnNwZWNpZmljT2Zmc2V0XG4gICAgICAgIDogem9uZVRvVXNlLm9mZnNldCh0c05vdyksXG4gICAgICBub3JtYWxpemVkID0gbm9ybWFsaXplT2JqZWN0KG9iaiwgbm9ybWFsaXplVW5pdCksXG4gICAgICBjb250YWluc09yZGluYWwgPSAhaXNVbmRlZmluZWQobm9ybWFsaXplZC5vcmRpbmFsKSxcbiAgICAgIGNvbnRhaW5zR3JlZ29yWWVhciA9ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLnllYXIpLFxuICAgICAgY29udGFpbnNHcmVnb3JNRCA9ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLm1vbnRoKSB8fCAhaXNVbmRlZmluZWQobm9ybWFsaXplZC5kYXkpLFxuICAgICAgY29udGFpbnNHcmVnb3IgPSBjb250YWluc0dyZWdvclllYXIgfHwgY29udGFpbnNHcmVnb3JNRCxcbiAgICAgIGRlZmluaXRlV2Vla0RlZiA9IG5vcm1hbGl6ZWQud2Vla1llYXIgfHwgbm9ybWFsaXplZC53ZWVrTnVtYmVyLFxuICAgICAgbG9jID0gTG9jYWxlLmZyb21PYmplY3Qob3B0cyk7XG5cbiAgICAvLyBjYXNlczpcbiAgICAvLyBqdXN0IGEgd2Vla2RheSAtPiB0aGlzIHdlZWsncyBpbnN0YW5jZSBvZiB0aGF0IHdlZWtkYXksIG5vIHdvcnJpZXNcbiAgICAvLyAoZ3JlZ29yaWFuIGRhdGEgb3Igb3JkaW5hbCkgKyAod2Vla1llYXIgb3Igd2Vla051bWJlcikgLT4gZXJyb3JcbiAgICAvLyAoZ3JlZ29yaWFuIG1vbnRoIG9yIGRheSkgKyBvcmRpbmFsIC0+IGVycm9yXG4gICAgLy8gb3RoZXJ3aXNlIGp1c3QgdXNlIHdlZWtzIG9yIG9yZGluYWxzIG9yIGdyZWdvcmlhbiwgZGVwZW5kaW5nIG9uIHdoYXQncyBzcGVjaWZpZWRcblxuICAgIGlmICgoY29udGFpbnNHcmVnb3IgfHwgY29udGFpbnNPcmRpbmFsKSAmJiBkZWZpbml0ZVdlZWtEZWYpIHtcbiAgICAgIHRocm93IG5ldyBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvcihcbiAgICAgICAgXCJDYW4ndCBtaXggd2Vla1llYXIvd2Vla051bWJlciB1bml0cyB3aXRoIHllYXIvbW9udGgvZGF5IG9yIG9yZGluYWxzXCJcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRhaW5zR3JlZ29yTUQgJiYgY29udGFpbnNPcmRpbmFsKSB7XG4gICAgICB0aHJvdyBuZXcgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IoXCJDYW4ndCBtaXggb3JkaW5hbCBkYXRlcyB3aXRoIG1vbnRoL2RheVwiKTtcbiAgICB9XG5cbiAgICBjb25zdCB1c2VXZWVrRGF0YSA9IGRlZmluaXRlV2Vla0RlZiB8fCAobm9ybWFsaXplZC53ZWVrZGF5ICYmICFjb250YWluc0dyZWdvcik7XG5cbiAgICAvLyBjb25maWd1cmUgb3Vyc2VsdmVzIHRvIGRlYWwgd2l0aCBncmVnb3JpYW4gZGF0ZXMgb3Igd2VlayBzdHVmZlxuICAgIGxldCB1bml0cyxcbiAgICAgIGRlZmF1bHRWYWx1ZXMsXG4gICAgICBvYmpOb3cgPSB0c1RvT2JqKHRzTm93LCBvZmZzZXRQcm92aXMpO1xuICAgIGlmICh1c2VXZWVrRGF0YSkge1xuICAgICAgdW5pdHMgPSBvcmRlcmVkV2Vla1VuaXRzO1xuICAgICAgZGVmYXVsdFZhbHVlcyA9IGRlZmF1bHRXZWVrVW5pdFZhbHVlcztcbiAgICAgIG9iak5vdyA9IGdyZWdvcmlhblRvV2VlayhvYmpOb3cpO1xuICAgIH0gZWxzZSBpZiAoY29udGFpbnNPcmRpbmFsKSB7XG4gICAgICB1bml0cyA9IG9yZGVyZWRPcmRpbmFsVW5pdHM7XG4gICAgICBkZWZhdWx0VmFsdWVzID0gZGVmYXVsdE9yZGluYWxVbml0VmFsdWVzO1xuICAgICAgb2JqTm93ID0gZ3JlZ29yaWFuVG9PcmRpbmFsKG9iak5vdyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVuaXRzID0gb3JkZXJlZFVuaXRzO1xuICAgICAgZGVmYXVsdFZhbHVlcyA9IGRlZmF1bHRVbml0VmFsdWVzO1xuICAgIH1cblxuICAgIC8vIHNldCBkZWZhdWx0IHZhbHVlcyBmb3IgbWlzc2luZyBzdHVmZlxuICAgIGxldCBmb3VuZEZpcnN0ID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCB1IG9mIHVuaXRzKSB7XG4gICAgICBjb25zdCB2ID0gbm9ybWFsaXplZFt1XTtcbiAgICAgIGlmICghaXNVbmRlZmluZWQodikpIHtcbiAgICAgICAgZm91bmRGaXJzdCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGZvdW5kRmlyc3QpIHtcbiAgICAgICAgbm9ybWFsaXplZFt1XSA9IGRlZmF1bHRWYWx1ZXNbdV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub3JtYWxpemVkW3VdID0gb2JqTm93W3VdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG1ha2Ugc3VyZSB0aGUgdmFsdWVzIHdlIGhhdmUgYXJlIGluIHJhbmdlXG4gICAgY29uc3QgaGlnaGVyT3JkZXJJbnZhbGlkID0gdXNlV2Vla0RhdGFcbiAgICAgICAgPyBoYXNJbnZhbGlkV2Vla0RhdGEobm9ybWFsaXplZClcbiAgICAgICAgOiBjb250YWluc09yZGluYWxcbiAgICAgICAgPyBoYXNJbnZhbGlkT3JkaW5hbERhdGEobm9ybWFsaXplZClcbiAgICAgICAgOiBoYXNJbnZhbGlkR3JlZ29yaWFuRGF0YShub3JtYWxpemVkKSxcbiAgICAgIGludmFsaWQgPSBoaWdoZXJPcmRlckludmFsaWQgfHwgaGFzSW52YWxpZFRpbWVEYXRhKG5vcm1hbGl6ZWQpO1xuXG4gICAgaWYgKGludmFsaWQpIHtcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKGludmFsaWQpO1xuICAgIH1cblxuICAgIC8vIGNvbXB1dGUgdGhlIGFjdHVhbCB0aW1lXG4gICAgY29uc3QgZ3JlZ29yaWFuID0gdXNlV2Vla0RhdGFcbiAgICAgICAgPyB3ZWVrVG9HcmVnb3JpYW4obm9ybWFsaXplZClcbiAgICAgICAgOiBjb250YWluc09yZGluYWxcbiAgICAgICAgPyBvcmRpbmFsVG9HcmVnb3JpYW4obm9ybWFsaXplZClcbiAgICAgICAgOiBub3JtYWxpemVkLFxuICAgICAgW3RzRmluYWwsIG9mZnNldEZpbmFsXSA9IG9ialRvVFMoZ3JlZ29yaWFuLCBvZmZzZXRQcm92aXMsIHpvbmVUb1VzZSksXG4gICAgICBpbnN0ID0gbmV3IERhdGVUaW1lKHtcbiAgICAgICAgdHM6IHRzRmluYWwsXG4gICAgICAgIHpvbmU6IHpvbmVUb1VzZSxcbiAgICAgICAgbzogb2Zmc2V0RmluYWwsXG4gICAgICAgIGxvYyxcbiAgICAgIH0pO1xuXG4gICAgLy8gZ3JlZ29yaWFuIGRhdGEgKyB3ZWVrZGF5IHNlcnZlcyBvbmx5IHRvIHZhbGlkYXRlXG4gICAgaWYgKG5vcm1hbGl6ZWQud2Vla2RheSAmJiBjb250YWluc0dyZWdvciAmJiBvYmoud2Vla2RheSAhPT0gaW5zdC53ZWVrZGF5KSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChcbiAgICAgICAgXCJtaXNtYXRjaGVkIHdlZWtkYXlcIixcbiAgICAgICAgYHlvdSBjYW4ndCBzcGVjaWZ5IGJvdGggYSB3ZWVrZGF5IG9mICR7bm9ybWFsaXplZC53ZWVrZGF5fSBhbmQgYSBkYXRlIG9mICR7aW5zdC50b0lTTygpfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3Q7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhbiBJU08gODYwMSBzdHJpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0aGUgSVNPIHN0cmluZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdG8gYWZmZWN0IHRoZSBjcmVhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0cy56b25lPSdsb2NhbCddIC0gdXNlIHRoaXMgem9uZSBpZiBubyBvZmZzZXQgaXMgc3BlY2lmaWVkIGluIHRoZSBpbnB1dCBzdHJpbmcgaXRzZWxmLiBXaWxsIGFsc28gY29udmVydCB0aGUgdGltZSB0byB0aGlzIHpvbmVcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zZXRab25lPWZhbHNlXSAtIG92ZXJyaWRlIHRoZSB6b25lIHdpdGggYSBmaXhlZC1vZmZzZXQgem9uZSBzcGVjaWZpZWQgaW4gdGhlIHN0cmluZyBpdHNlbGYsIGlmIGl0IHNwZWNpZmllcyBvbmVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nc3lzdGVtJ3MgbG9jYWxlJ10gLSBhIGxvY2FsZSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMub3V0cHV0Q2FsZW5kYXJdIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubnVtYmVyaW5nU3lzdGVtXSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21JU08oJzIwMTYtMDUtMjVUMDk6MDg6MzQuMTIzJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUlTTygnMjAxNi0wNS0yNVQwOTowODozNC4xMjMrMDY6MDAnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSVNPKCcyMDE2LTA1LTI1VDA5OjA4OjM0LjEyMyswNjowMCcsIHtzZXRab25lOiB0cnVlfSlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUlTTygnMjAxNi0wNS0yNVQwOTowODozNC4xMjMnLCB7em9uZTogJ3V0Yyd9KVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSVNPKCcyMDE2LVcwNS00JylcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbUlTTyh0ZXh0LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBbdmFscywgcGFyc2VkWm9uZV0gPSBwYXJzZUlTT0RhdGUodGV4dCk7XG4gICAgcmV0dXJuIHBhcnNlRGF0YVRvRGF0ZVRpbWUodmFscywgcGFyc2VkWm9uZSwgb3B0cywgXCJJU08gODYwMVwiLCB0ZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGFuIFJGQyAyODIyIHN0cmluZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSBSRkMgMjgyMiBzdHJpbmdcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRvIGFmZmVjdCB0aGUgY3JlYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdHMuem9uZT0nbG9jYWwnXSAtIGNvbnZlcnQgdGhlIHRpbWUgdG8gdGhpcyB6b25lLiBTaW5jZSB0aGUgb2Zmc2V0IGlzIGFsd2F5cyBzcGVjaWZpZWQgaW4gdGhlIHN0cmluZyBpdHNlbGYsIHRoaXMgaGFzIG5vIGVmZmVjdCBvbiB0aGUgaW50ZXJwcmV0YXRpb24gb2Ygc3RyaW5nLCBtZXJlbHkgdGhlIHpvbmUgdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpcyBleHByZXNzZWQgaW4uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc2V0Wm9uZT1mYWxzZV0gLSBvdmVycmlkZSB0aGUgem9uZSB3aXRoIGEgZml4ZWQtb2Zmc2V0IHpvbmUgc3BlY2lmaWVkIGluIHRoZSBzdHJpbmcgaXRzZWxmLCBpZiBpdCBzcGVjaWZpZXMgb25lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J3N5c3RlbSdzIGxvY2FsZSddIC0gYSBsb2NhbGUgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMub3V0cHV0Q2FsZW5kYXIgLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21SRkMyODIyKCcyNSBOb3YgMjAxNiAxMzoyMzoxMiBHTVQnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tUkZDMjgyMignRnJpLCAyNSBOb3YgMjAxNiAxMzoyMzoxMiArMDYwMCcpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21SRkMyODIyKCcyNSBOb3YgMjAxNiAxMzoyMyBaJylcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbVJGQzI4MjIodGV4dCwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgW3ZhbHMsIHBhcnNlZFpvbmVdID0gcGFyc2VSRkMyODIyRGF0ZSh0ZXh0KTtcbiAgICByZXR1cm4gcGFyc2VEYXRhVG9EYXRlVGltZSh2YWxzLCBwYXJzZWRab25lLCBvcHRzLCBcIlJGQyAyODIyXCIsIHRleHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYW4gSFRUUCBoZWFkZXIgZGF0ZVxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9Qcm90b2NvbHMvcmZjMjYxNi9yZmMyNjE2LXNlYzMuaHRtbCNzZWMzLjMuMVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSBIVFRQIGhlYWRlciBkYXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0byBhZmZlY3QgdGhlIGNyZWF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFtvcHRzLnpvbmU9J2xvY2FsJ10gLSBjb252ZXJ0IHRoZSB0aW1lIHRvIHRoaXMgem9uZS4gU2luY2UgSFRUUCBkYXRlcyBhcmUgYWx3YXlzIGluIFVUQywgdGhpcyBoYXMgbm8gZWZmZWN0IG9uIHRoZSBpbnRlcnByZXRhdGlvbiBvZiBzdHJpbmcsIG1lcmVseSB0aGUgem9uZSB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGlzIGV4cHJlc3NlZCBpbi5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zZXRab25lPWZhbHNlXSAtIG92ZXJyaWRlIHRoZSB6b25lIHdpdGggdGhlIGZpeGVkLW9mZnNldCB6b25lIHNwZWNpZmllZCBpbiB0aGUgc3RyaW5nLiBGb3IgSFRUUCBkYXRlcywgdGhpcyBpcyBhbHdheXMgVVRDLCBzbyB0aGlzIG9wdGlvbiBpcyBlcXVpdmFsZW50IHRvIHNldHRpbmcgdGhlIGB6b25lYCBvcHRpb24gdG8gJ3V0YycsIGJ1dCB0aGlzIG9wdGlvbiBpcyBpbmNsdWRlZCBmb3IgY29uc2lzdGVuY3kgd2l0aCBzaW1pbGFyIG1ldGhvZHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J3N5c3RlbSdzIGxvY2FsZSddIC0gYSBsb2NhbGUgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMub3V0cHV0Q2FsZW5kYXIgLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21IVFRQKCdTdW4sIDA2IE5vdiAxOTk0IDA4OjQ5OjM3IEdNVCcpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21IVFRQKCdTdW5kYXksIDA2LU5vdi05NCAwODo0OTozNyBHTVQnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSFRUUCgnU3VuIE5vdiAgNiAwODo0OTozNyAxOTk0JylcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbUhUVFAodGV4dCwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgW3ZhbHMsIHBhcnNlZFpvbmVdID0gcGFyc2VIVFRQRGF0ZSh0ZXh0KTtcbiAgICByZXR1cm4gcGFyc2VEYXRhVG9EYXRlVGltZSh2YWxzLCBwYXJzZWRab25lLCBvcHRzLCBcIkhUVFBcIiwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhbiBpbnB1dCBzdHJpbmcgYW5kIGZvcm1hdCBzdHJpbmcuXG4gICAqIERlZmF1bHRzIHRvIGVuLVVTIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWQsIHJlZ2FyZGxlc3Mgb2YgdGhlIHN5c3RlbSdzIGxvY2FsZS4gRm9yIGEgdGFibGUgb2YgdG9rZW5zIGFuZCB0aGVpciBpbnRlcnByZXRhdGlvbnMsIHNlZSBbaGVyZV0oaHR0cHM6Ly9tb21lbnQuZ2l0aHViLmlvL2x1eG9uLyMvcGFyc2luZz9pZD10YWJsZS1vZi10b2tlbnMpLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZtdCAtIHRoZSBmb3JtYXQgdGhlIHN0cmluZyBpcyBleHBlY3RlZCB0byBiZSBpbiAoc2VlIHRoZSBsaW5rIGJlbG93IGZvciB0aGUgZm9ybWF0cylcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRvIGFmZmVjdCB0aGUgY3JlYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdHMuem9uZT0nbG9jYWwnXSAtIHVzZSB0aGlzIHpvbmUgaWYgbm8gb2Zmc2V0IGlzIHNwZWNpZmllZCBpbiB0aGUgaW5wdXQgc3RyaW5nIGl0c2VsZi4gV2lsbCBhbHNvIGNvbnZlcnQgdGhlIERhdGVUaW1lIHRvIHRoaXMgem9uZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnNldFpvbmU9ZmFsc2VdIC0gb3ZlcnJpZGUgdGhlIHpvbmUgd2l0aCBhIHpvbmUgc3BlY2lmaWVkIGluIHRoZSBzdHJpbmcgaXRzZWxmLCBpZiBpdCBzcGVjaWZpZXMgb25lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J2VuLVVTJ10gLSBhIGxvY2FsZSBzdHJpbmcgdG8gdXNlIHdoZW4gcGFyc2luZy4gV2lsbCBhbHNvIHNldCB0aGUgRGF0ZVRpbWUgdG8gdGhpcyBsb2NhbGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gdXNlIHdoZW4gcGFyc2luZy4gV2lsbCBhbHNvIHNldCB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIHRvIHRoaXMgbnVtYmVyaW5nIHN5c3RlbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5vdXRwdXRDYWxlbmRhciAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbUZvcm1hdCh0ZXh0LCBmbXQsIG9wdHMgPSB7fSkge1xuICAgIGlmIChpc1VuZGVmaW5lZCh0ZXh0KSB8fCBpc1VuZGVmaW5lZChmbXQpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJmcm9tRm9ybWF0IHJlcXVpcmVzIGFuIGlucHV0IHN0cmluZyBhbmQgYSBmb3JtYXRcIik7XG4gICAgfVxuXG4gICAgY29uc3QgeyBsb2NhbGUgPSBudWxsLCBudW1iZXJpbmdTeXN0ZW0gPSBudWxsIH0gPSBvcHRzLFxuICAgICAgbG9jYWxlVG9Vc2UgPSBMb2NhbGUuZnJvbU9wdHMoe1xuICAgICAgICBsb2NhbGUsXG4gICAgICAgIG51bWJlcmluZ1N5c3RlbSxcbiAgICAgICAgZGVmYXVsdFRvRU46IHRydWUsXG4gICAgICB9KSxcbiAgICAgIFt2YWxzLCBwYXJzZWRab25lLCBzcGVjaWZpY09mZnNldCwgaW52YWxpZF0gPSBwYXJzZUZyb21Ub2tlbnMobG9jYWxlVG9Vc2UsIHRleHQsIGZtdCk7XG4gICAgaWYgKGludmFsaWQpIHtcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKGludmFsaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcGFyc2VEYXRhVG9EYXRlVGltZSh2YWxzLCBwYXJzZWRab25lLCBvcHRzLCBgZm9ybWF0ICR7Zm10fWAsIHRleHQsIHNwZWNpZmljT2Zmc2V0KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGZyb21Gb3JtYXQgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGZyb21TdHJpbmcodGV4dCwgZm10LCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gRGF0ZVRpbWUuZnJvbUZvcm1hdCh0ZXh0LCBmbXQsIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYSBTUUwgZGF0ZSwgdGltZSwgb3IgZGF0ZXRpbWVcbiAgICogRGVmYXVsdHMgdG8gZW4tVVMgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZCwgcmVnYXJkbGVzcyBvZiB0aGUgc3lzdGVtJ3MgbG9jYWxlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGhlIHN0cmluZyB0byBwYXJzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdG8gYWZmZWN0IHRoZSBjcmVhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0cy56b25lPSdsb2NhbCddIC0gdXNlIHRoaXMgem9uZSBpZiBubyBvZmZzZXQgaXMgc3BlY2lmaWVkIGluIHRoZSBpbnB1dCBzdHJpbmcgaXRzZWxmLiBXaWxsIGFsc28gY29udmVydCB0aGUgRGF0ZVRpbWUgdG8gdGhpcyB6b25lXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc2V0Wm9uZT1mYWxzZV0gLSBvdmVycmlkZSB0aGUgem9uZSB3aXRoIGEgem9uZSBzcGVjaWZpZWQgaW4gdGhlIHN0cmluZyBpdHNlbGYsIGlmIGl0IHNwZWNpZmllcyBvbmVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nZW4tVVMnXSAtIGEgbG9jYWxlIHN0cmluZyB0byB1c2Ugd2hlbiBwYXJzaW5nLiBXaWxsIGFsc28gc2V0IHRoZSBEYXRlVGltZSB0byB0aGlzIGxvY2FsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byB1c2Ugd2hlbiBwYXJzaW5nLiBXaWxsIGFsc28gc2V0IHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgdG8gdGhpcyBudW1iZXJpbmcgc3lzdGVtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm91dHB1dENhbGVuZGFyIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcyMDE3LTA1LTE1JylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMjAxNy0wNS0xNSAwOToxMjozNCcpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzIwMTctMDUtMTUgMDk6MTI6MzQuMzQyJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMjAxNy0wNS0xNSAwOToxMjozNC4zNDIrMDY6MDAnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcyMDE3LTA1LTE1IDA5OjEyOjM0LjM0MiBBbWVyaWNhL0xvc19BbmdlbGVzJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMjAxNy0wNS0xNSAwOToxMjozNC4zNDIgQW1lcmljYS9Mb3NfQW5nZWxlcycsIHsgc2V0Wm9uZTogdHJ1ZSB9KVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcyMDE3LTA1LTE1IDA5OjEyOjM0LjM0MicsIHsgem9uZTogJ0FtZXJpY2EvTG9zX0FuZ2VsZXMnIH0pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzA5OjEyOjM0LjM0MicpXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21TUUwodGV4dCwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgW3ZhbHMsIHBhcnNlZFpvbmVdID0gcGFyc2VTUUwodGV4dCk7XG4gICAgcmV0dXJuIHBhcnNlRGF0YVRvRGF0ZVRpbWUodmFscywgcGFyc2VkWm9uZSwgb3B0cywgXCJTUUxcIiwgdGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGludmFsaWQgRGF0ZVRpbWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb24gLSBzaW1wbGUgc3RyaW5nIG9mIHdoeSB0aGlzIERhdGVUaW1lIGlzIGludmFsaWQuIFNob3VsZCBub3QgY29udGFpbiBwYXJhbWV0ZXJzIG9yIGFueXRoaW5nIGVsc2UgZGF0YS1kZXBlbmRlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZXhwbGFuYXRpb249bnVsbF0gLSBsb25nZXIgZXhwbGFuYXRpb24sIG1heSBpbmNsdWRlIHBhcmFtZXRlcnMgYW5kIG90aGVyIHVzZWZ1bCBkZWJ1Z2dpbmcgaW5mb3JtYXRpb25cbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgaW52YWxpZChyZWFzb24sIGV4cGxhbmF0aW9uID0gbnVsbCkge1xuICAgIGlmICghcmVhc29uKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJuZWVkIHRvIHNwZWNpZnkgYSByZWFzb24gdGhlIERhdGVUaW1lIGlzIGludmFsaWRcIik7XG4gICAgfVxuXG4gICAgY29uc3QgaW52YWxpZCA9IHJlYXNvbiBpbnN0YW5jZW9mIEludmFsaWQgPyByZWFzb24gOiBuZXcgSW52YWxpZChyZWFzb24sIGV4cGxhbmF0aW9uKTtcblxuICAgIGlmIChTZXR0aW5ncy50aHJvd09uSW52YWxpZCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWREYXRlVGltZUVycm9yKGludmFsaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IERhdGVUaW1lKHsgaW52YWxpZCB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gb2JqZWN0IGlzIGFuIGluc3RhbmNlIG9mIERhdGVUaW1lLiBXb3JrcyBhY3Jvc3MgY29udGV4dCBib3VuZGFyaWVzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNEYXRlVGltZShvKSB7XG4gICAgcmV0dXJuIChvICYmIG8uaXNMdXhvbkRhdGVUaW1lKSB8fCBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9kdWNlIHRoZSBmb3JtYXQgc3RyaW5nIGZvciBhIHNldCBvZiBvcHRpb25zXG4gICAqIEBwYXJhbSBmb3JtYXRPcHRzXG4gICAqIEBwYXJhbSBsb2NhbGVPcHRzXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgcGFyc2VGb3JtYXRGb3JPcHRzKGZvcm1hdE9wdHMsIGxvY2FsZU9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHRva2VuTGlzdCA9IGZvcm1hdE9wdHNUb1Rva2Vucyhmb3JtYXRPcHRzLCBMb2NhbGUuZnJvbU9iamVjdChsb2NhbGVPcHRzKSk7XG4gICAgcmV0dXJuICF0b2tlbkxpc3QgPyBudWxsIDogdG9rZW5MaXN0Lm1hcCgodCkgPT4gKHQgPyB0LnZhbCA6IG51bGwpKS5qb2luKFwiXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2R1Y2UgdGhlIHRoZSBmdWxseSBleHBhbmRlZCBmb3JtYXQgdG9rZW4gZm9yIHRoZSBsb2NhbGVcbiAgICogRG9lcyBOT1QgcXVvdGUgY2hhcmFjdGVycywgc28gcXVvdGVkIHRva2VucyB3aWxsIG5vdCByb3VuZCB0cmlwIGNvcnJlY3RseVxuICAgKiBAcGFyYW0gZm10XG4gICAqIEBwYXJhbSBsb2NhbGVPcHRzXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZXhwYW5kRm9ybWF0KGZtdCwgbG9jYWxlT3B0cyA9IHt9KSB7XG4gICAgY29uc3QgZXhwYW5kZWQgPSBleHBhbmRNYWNyb1Rva2VucyhGb3JtYXR0ZXIucGFyc2VGb3JtYXQoZm10KSwgTG9jYWxlLmZyb21PYmplY3QobG9jYWxlT3B0cykpO1xuICAgIHJldHVybiBleHBhbmRlZC5tYXAoKHQpID0+IHQudmFsKS5qb2luKFwiXCIpO1xuICB9XG5cbiAgLy8gSU5GT1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbHVlIG9mIHVuaXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1bml0IC0gYSB1bml0IHN1Y2ggYXMgJ21pbnV0ZScgb3IgJ2RheSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNywgNCkuZ2V0KCdtb250aCcpOyAvLz0+IDdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNywgNCkuZ2V0KCdkYXknKTsgLy89PiA0XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldCh1bml0KSB7XG4gICAgcmV0dXJuIHRoaXNbdW5pdF07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBEYXRlVGltZSBpcyB2YWxpZC4gSW52YWxpZCBEYXRlVGltZXMgb2NjdXIgd2hlbjpcbiAgICogKiBUaGUgRGF0ZVRpbWUgd2FzIGNyZWF0ZWQgZnJvbSBpbnZhbGlkIGNhbGVuZGFyIGluZm9ybWF0aW9uLCBzdWNoIGFzIHRoZSAxM3RoIG1vbnRoIG9yIEZlYnJ1YXJ5IDMwXG4gICAqICogVGhlIERhdGVUaW1lIHdhcyBjcmVhdGVkIGJ5IGFuIG9wZXJhdGlvbiBvbiBhbm90aGVyIGludmFsaWQgZGF0ZVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiB0aGlzLmludmFsaWQgPT09IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBlcnJvciBjb2RlIGlmIHRoaXMgRGF0ZVRpbWUgaXMgaW52YWxpZCwgb3IgbnVsbCBpZiB0aGUgRGF0ZVRpbWUgaXMgdmFsaWRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBpbnZhbGlkUmVhc29uKCkge1xuICAgIHJldHVybiB0aGlzLmludmFsaWQgPyB0aGlzLmludmFsaWQucmVhc29uIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGV4cGxhbmF0aW9uIG9mIHdoeSB0aGlzIERhdGVUaW1lIGJlY2FtZSBpbnZhbGlkLCBvciBudWxsIGlmIHRoZSBEYXRlVGltZSBpcyB2YWxpZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGludmFsaWRFeHBsYW5hdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZhbGlkID8gdGhpcy5pbnZhbGlkLmV4cGxhbmF0aW9uIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxvY2FsZSBvZiBhIERhdGVUaW1lLCBzdWNoICdlbi1HQicuIFRoZSBsb2NhbGUgaXMgdXNlZCB3aGVuIGZvcm1hdHRpbmcgdGhlIERhdGVUaW1lXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgbG9jYWxlKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmxvYy5sb2NhbGUgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbnVtYmVyaW5nIHN5c3RlbSBvZiBhIERhdGVUaW1lLCBzdWNoICdiZW5nJy4gVGhlIG51bWJlcmluZyBzeXN0ZW0gaXMgdXNlZCB3aGVuIGZvcm1hdHRpbmcgdGhlIERhdGVUaW1lXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgbnVtYmVyaW5nU3lzdGVtKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmxvYy5udW1iZXJpbmdTeXN0ZW0gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgb3V0cHV0IGNhbGVuZGFyIG9mIGEgRGF0ZVRpbWUsIHN1Y2ggJ2lzbGFtaWMnLiBUaGUgb3V0cHV0IGNhbGVuZGFyIGlzIHVzZWQgd2hlbiBmb3JtYXR0aW5nIHRoZSBEYXRlVGltZVxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG91dHB1dENhbGVuZGFyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmxvYy5vdXRwdXRDYWxlbmRhciA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0aW1lIHpvbmUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgRGF0ZVRpbWUuXG4gICAqIEB0eXBlIHtab25lfVxuICAgKi9cbiAgZ2V0IHpvbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3pvbmU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBuYW1lIG9mIHRoZSB0aW1lIHpvbmUuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgem9uZU5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuem9uZS5uYW1lIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHllYXJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLnllYXIgLy89PiAyMDE3XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgeWVhcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5jLnllYXIgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBxdWFydGVyXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS5xdWFydGVyIC8vPT4gMlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHF1YXJ0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IE1hdGguY2VpbCh0aGlzLmMubW9udGggLyAzKSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1vbnRoICgxLTEyKS5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLm1vbnRoIC8vPT4gNVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1vbnRoKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmMubW9udGggOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkYXkgb2YgdGhlIG1vbnRoICgxLTMwaXNoKS5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLmRheSAvLz0+IDI1XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgZGF5KCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmMuZGF5IDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaG91ciBvZiB0aGUgZGF5ICgwLTIzKS5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUsIDkpLmhvdXIgLy89PiA5XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgaG91cigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5jLmhvdXIgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtaW51dGUgb2YgdGhlIGhvdXIgKDAtNTkpLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSwgOSwgMzApLm1pbnV0ZSAvLz0+IDMwXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbWludXRlKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmMubWludXRlIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2Vjb25kIG9mIHRoZSBtaW51dGUgKDAtNTkpLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSwgOSwgMzAsIDUyKS5zZWNvbmQgLy89PiA1MlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHNlY29uZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5jLnNlY29uZCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1pbGxpc2Vjb25kIG9mIHRoZSBzZWNvbmQgKDAtOTk5KS5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUsIDksIDMwLCA1MiwgNjU0KS5taWxsaXNlY29uZCAvLz0+IDY1NFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1pbGxpc2Vjb25kKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmMubWlsbGlzZWNvbmQgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB3ZWVrIHllYXJcbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDEyLCAzMSkud2Vla1llYXIgLy89PiAyMDE1XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgd2Vla1llYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHBvc3NpYmx5Q2FjaGVkV2Vla0RhdGEodGhpcykud2Vla1llYXIgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB3ZWVrIG51bWJlciBvZiB0aGUgd2VlayB5ZWFyICgxLTUyaXNoKS5cbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS53ZWVrTnVtYmVyIC8vPT4gMjFcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB3ZWVrTnVtYmVyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBwb3NzaWJseUNhY2hlZFdlZWtEYXRhKHRoaXMpLndlZWtOdW1iZXIgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkYXkgb2YgdGhlIHdlZWsuXG4gICAqIDEgaXMgTW9uZGF5IGFuZCA3IGlzIFN1bmRheVxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMTEsIDMxKS53ZWVrZGF5IC8vPT4gNFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdlZWtkYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHBvc3NpYmx5Q2FjaGVkV2Vla0RhdGEodGhpcykud2Vla2RheSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG9yZGluYWwgKG1lYW5pbmcgdGhlIGRheSBvZiB0aGUgeWVhcilcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLm9yZGluYWwgLy89PiAxNDVcbiAgICogQHR5cGUge251bWJlcnxEYXRlVGltZX1cbiAgICovXG4gIGdldCBvcmRpbmFsKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBncmVnb3JpYW5Ub09yZGluYWwodGhpcy5jKS5vcmRpbmFsIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaHVtYW4gcmVhZGFibGUgc2hvcnQgbW9udGggbmFtZSwgc3VjaCBhcyAnT2N0Jy5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDEwLCAzMCkubW9udGhTaG9ydCAvLz0+IE9jdFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG1vbnRoU2hvcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IEluZm8ubW9udGhzKFwic2hvcnRcIiwgeyBsb2NPYmo6IHRoaXMubG9jIH0pW3RoaXMubW9udGggLSAxXSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBodW1hbiByZWFkYWJsZSBsb25nIG1vbnRoIG5hbWUsIHN1Y2ggYXMgJ09jdG9iZXInLlxuICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMTAsIDMwKS5tb250aExvbmcgLy89PiBPY3RvYmVyXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgbW9udGhMb25nKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBJbmZvLm1vbnRocyhcImxvbmdcIiwgeyBsb2NPYmo6IHRoaXMubG9jIH0pW3RoaXMubW9udGggLSAxXSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBodW1hbiByZWFkYWJsZSBzaG9ydCB3ZWVrZGF5LCBzdWNoIGFzICdNb24nLlxuICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMTAsIDMwKS53ZWVrZGF5U2hvcnQgLy89PiBNb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCB3ZWVrZGF5U2hvcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IEluZm8ud2Vla2RheXMoXCJzaG9ydFwiLCB7IGxvY09iajogdGhpcy5sb2MgfSlbdGhpcy53ZWVrZGF5IC0gMV0gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaHVtYW4gcmVhZGFibGUgbG9uZyB3ZWVrZGF5LCBzdWNoIGFzICdNb25kYXknLlxuICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMTAsIDMwKS53ZWVrZGF5TG9uZyAvLz0+IE1vbmRheVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IHdlZWtkYXlMb25nKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBJbmZvLndlZWtkYXlzKFwibG9uZ1wiLCB7IGxvY09iajogdGhpcy5sb2MgfSlbdGhpcy53ZWVrZGF5IC0gMV0gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgVVRDIG9mZnNldCBvZiB0aGlzIERhdGVUaW1lIGluIG1pbnV0ZXNcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkub2Zmc2V0IC8vPT4gLTI0MFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoKS5vZmZzZXQgLy89PiAwXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgb2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyArdGhpcy5vIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2hvcnQgaHVtYW4gbmFtZSBmb3IgdGhlIHpvbmUncyBjdXJyZW50IG9mZnNldCwgZm9yIGV4YW1wbGUgXCJFU1RcIiBvciBcIkVEVFwiLlxuICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBvZmZzZXROYW1lU2hvcnQoKSB7XG4gICAgaWYgKHRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIHRoaXMuem9uZS5vZmZzZXROYW1lKHRoaXMudHMsIHtcbiAgICAgICAgZm9ybWF0OiBcInNob3J0XCIsXG4gICAgICAgIGxvY2FsZTogdGhpcy5sb2NhbGUsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbG9uZyBodW1hbiBuYW1lIGZvciB0aGUgem9uZSdzIGN1cnJlbnQgb2Zmc2V0LCBmb3IgZXhhbXBsZSBcIkVhc3Rlcm4gU3RhbmRhcmQgVGltZVwiIG9yIFwiRWFzdGVybiBEYXlsaWdodCBUaW1lXCIuXG4gICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG9mZnNldE5hbWVMb25nKCkge1xuICAgIGlmICh0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnpvbmUub2Zmc2V0TmFtZSh0aGlzLnRzLCB7XG4gICAgICAgIGZvcm1hdDogXCJsb25nXCIsXG4gICAgICAgIGxvY2FsZTogdGhpcy5sb2NhbGUsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB3aGV0aGVyIHRoaXMgem9uZSdzIG9mZnNldCBldmVyIGNoYW5nZXMsIGFzIGluIGEgRFNULlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc09mZnNldEZpeGVkKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnpvbmUuaXNVbml2ZXJzYWwgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB3aGV0aGVyIHRoZSBEYXRlVGltZSBpcyBpbiBhIERTVC5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNJbkRTVCgpIHtcbiAgICBpZiAodGhpcy5pc09mZnNldEZpeGVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMub2Zmc2V0ID4gdGhpcy5zZXQoeyBtb250aDogMSwgZGF5OiAxIH0pLm9mZnNldCB8fFxuICAgICAgICB0aGlzLm9mZnNldCA+IHRoaXMuc2V0KHsgbW9udGg6IDUgfSkub2Zmc2V0XG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhvc2UgRGF0ZVRpbWVzIHdoaWNoIGhhdmUgdGhlIHNhbWUgbG9jYWwgdGltZSBhcyB0aGlzIERhdGVUaW1lLCBidXQgYSBkaWZmZXJlbnQgb2Zmc2V0IGZyb20gVVRDXG4gICAqIGluIHRoaXMgRGF0ZVRpbWUncyB6b25lLiBEdXJpbmcgRFNUIGNoYW5nZXMgbG9jYWwgdGltZSBjYW4gYmUgYW1iaWd1b3VzLCBmb3IgZXhhbXBsZVxuICAgKiBgMjAyMy0xMC0yOVQwMjozMDowMGAgaW4gYEV1cm9wZS9CZXJsaW5gIGNhbiBoYXZlIG9mZnNldCBgKzAxOjAwYCBvciBgKzAyOjAwYC5cbiAgICogVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gYm90aCBwb3NzaWJsZSBEYXRlVGltZXMgaWYgdGhpcyBEYXRlVGltZSdzIGxvY2FsIHRpbWUgaXMgYW1iaWd1b3VzLlxuICAgKiBAcmV0dXJucyB7RGF0ZVRpbWVbXX1cbiAgICovXG4gIGdldFBvc3NpYmxlT2Zmc2V0cygpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCB8fCB0aGlzLmlzT2Zmc2V0Rml4ZWQpIHtcbiAgICAgIHJldHVybiBbdGhpc107XG4gICAgfVxuICAgIGNvbnN0IGRheU1zID0gODY0MDAwMDA7XG4gICAgY29uc3QgbWludXRlTXMgPSA2MDAwMDtcbiAgICBjb25zdCBsb2NhbFRTID0gb2JqVG9Mb2NhbFRTKHRoaXMuYyk7XG4gICAgY29uc3Qgb0VhcmxpZXIgPSB0aGlzLnpvbmUub2Zmc2V0KGxvY2FsVFMgLSBkYXlNcyk7XG4gICAgY29uc3Qgb0xhdGVyID0gdGhpcy56b25lLm9mZnNldChsb2NhbFRTICsgZGF5TXMpO1xuXG4gICAgY29uc3QgbzEgPSB0aGlzLnpvbmUub2Zmc2V0KGxvY2FsVFMgLSBvRWFybGllciAqIG1pbnV0ZU1zKTtcbiAgICBjb25zdCBvMiA9IHRoaXMuem9uZS5vZmZzZXQobG9jYWxUUyAtIG9MYXRlciAqIG1pbnV0ZU1zKTtcbiAgICBpZiAobzEgPT09IG8yKSB7XG4gICAgICByZXR1cm4gW3RoaXNdO1xuICAgIH1cbiAgICBjb25zdCB0czEgPSBsb2NhbFRTIC0gbzEgKiBtaW51dGVNcztcbiAgICBjb25zdCB0czIgPSBsb2NhbFRTIC0gbzIgKiBtaW51dGVNcztcbiAgICBjb25zdCBjMSA9IHRzVG9PYmoodHMxLCBvMSk7XG4gICAgY29uc3QgYzIgPSB0c1RvT2JqKHRzMiwgbzIpO1xuICAgIGlmIChcbiAgICAgIGMxLmhvdXIgPT09IGMyLmhvdXIgJiZcbiAgICAgIGMxLm1pbnV0ZSA9PT0gYzIubWludXRlICYmXG4gICAgICBjMS5zZWNvbmQgPT09IGMyLnNlY29uZCAmJlxuICAgICAgYzEubWlsbGlzZWNvbmQgPT09IGMyLm1pbGxpc2Vjb25kXG4gICAgKSB7XG4gICAgICByZXR1cm4gW2Nsb25lKHRoaXMsIHsgdHM6IHRzMSB9KSwgY2xvbmUodGhpcywgeyB0czogdHMyIH0pXTtcbiAgICB9XG4gICAgcmV0dXJuIFt0aGlzXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBEYXRlVGltZSBpcyBpbiBhIGxlYXAgeWVhciwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTYpLmlzSW5MZWFwWWVhciAvLz0+IHRydWVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxMykuaXNJbkxlYXBZZWFyIC8vPT4gZmFsc2VcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNJbkxlYXBZZWFyKCkge1xuICAgIHJldHVybiBpc0xlYXBZZWFyKHRoaXMueWVhcik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGRheXMgaW4gdGhpcyBEYXRlVGltZSdzIG1vbnRoXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTYsIDIpLmRheXNJbk1vbnRoIC8vPT4gMjlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNiwgMykuZGF5c0luTW9udGggLy89PiAzMVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGRheXNJbk1vbnRoKCkge1xuICAgIHJldHVybiBkYXlzSW5Nb250aCh0aGlzLnllYXIsIHRoaXMubW9udGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBkYXlzIGluIHRoaXMgRGF0ZVRpbWUncyB5ZWFyXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTYpLmRheXNJblllYXIgLy89PiAzNjZcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxMykuZGF5c0luWWVhciAvLz0+IDM2NVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGRheXNJblllYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IGRheXNJblllYXIodGhpcy55ZWFyKSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygd2Vla3MgaW4gdGhpcyBEYXRlVGltZSdzIHllYXJcbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMDQpLndlZWtzSW5XZWVrWWVhciAvLz0+IDUzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTMpLndlZWtzSW5XZWVrWWVhciAvLz0+IDUyXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgd2Vla3NJbldlZWtZZWFyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB3ZWVrc0luV2Vla1llYXIodGhpcy53ZWVrWWVhcikgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVzb2x2ZWQgSW50bCBvcHRpb25zIGZvciB0aGlzIERhdGVUaW1lLlxuICAgKiBUaGlzIGlzIHVzZWZ1bCBpbiB1bmRlcnN0YW5kaW5nIHRoZSBiZWhhdmlvciBvZiBmb3JtYXR0aW5nIG1ldGhvZHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSB0aGUgc2FtZSBvcHRpb25zIGFzIHRvTG9jYWxlU3RyaW5nXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHJlc29sdmVkTG9jYWxlT3B0aW9ucyhvcHRzID0ge30pIHtcbiAgICBjb25zdCB7IGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBjYWxlbmRhciB9ID0gRm9ybWF0dGVyLmNyZWF0ZShcbiAgICAgIHRoaXMubG9jLmNsb25lKG9wdHMpLFxuICAgICAgb3B0c1xuICAgICkucmVzb2x2ZWRPcHRpb25zKHRoaXMpO1xuICAgIHJldHVybiB7IGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhcjogY2FsZW5kYXIgfTtcbiAgfVxuXG4gIC8vIFRSQU5TRk9STVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBEYXRlVGltZSdzIHpvbmUgdG8gVVRDLiBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRGF0ZVRpbWUuXG4gICAqXG4gICAqIEVxdWl2YWxlbnQgdG8ge0BsaW5rIERhdGVUaW1lI3NldFpvbmV9KCd1dGMnKVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29mZnNldD0wXSAtIG9wdGlvbmFsbHksIGFuIG9mZnNldCBmcm9tIFVUQyBpbiBtaW51dGVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cz17fV0gLSBvcHRpb25zIHRvIHBhc3MgdG8gYHNldFpvbmUoKWBcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICB0b1VUQyhvZmZzZXQgPSAwLCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5zZXRab25lKEZpeGVkT2Zmc2V0Wm9uZS5pbnN0YW5jZShvZmZzZXQpLCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBEYXRlVGltZSdzIHpvbmUgdG8gdGhlIGhvc3QncyBsb2NhbCB6b25lLiBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRGF0ZVRpbWUuXG4gICAqXG4gICAqIEVxdWl2YWxlbnQgdG8gYHNldFpvbmUoJ2xvY2FsJylgXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgdG9Mb2NhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRab25lKFNldHRpbmdzLmRlZmF1bHRab25lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBEYXRlVGltZSdzIHpvbmUgdG8gc3BlY2lmaWVkIHpvbmUuIFJldHVybnMgYSBuZXdseS1jb25zdHJ1Y3RlZCBEYXRlVGltZS5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdGhlIHNldHRlciBrZWVwcyB0aGUgdW5kZXJseWluZyB0aW1lIHRoZSBzYW1lIChhcyBpbiwgdGhlIHNhbWUgdGltZXN0YW1wKSwgYnV0IHRoZSBuZXcgaW5zdGFuY2Ugd2lsbCByZXBvcnQgZGlmZmVyZW50IGxvY2FsIHRpbWVzIGFuZCBjb25zaWRlciBEU1RzIHdoZW4gbWFraW5nIGNvbXB1dGF0aW9ucywgYXMgd2l0aCB7QGxpbmsgRGF0ZVRpbWUjcGx1c30uIFlvdSBtYXkgd2lzaCB0byB1c2Uge0BsaW5rIERhdGVUaW1lI3RvTG9jYWx9IGFuZCB7QGxpbmsgRGF0ZVRpbWUjdG9VVEN9IHdoaWNoIHByb3ZpZGUgc2ltcGxlIGNvbnZlbmllbmNlIHdyYXBwZXJzIGZvciBjb21tb25seSB1c2VkIHpvbmVzLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbem9uZT0nbG9jYWwnXSAtIGEgem9uZSBpZGVudGlmaWVyLiBBcyBhIHN0cmluZywgdGhhdCBjYW4gYmUgYW55IElBTkEgem9uZSBzdXBwb3J0ZWQgYnkgdGhlIGhvc3QgZW52aXJvbm1lbnQsIG9yIGEgZml4ZWQtb2Zmc2V0IG5hbWUgb2YgdGhlIGZvcm0gJ1VUQyszJywgb3IgdGhlIHN0cmluZ3MgJ2xvY2FsJyBvciAndXRjJy4gWW91IG1heSBhbHNvIHN1cHBseSBhbiBpbnN0YW5jZSBvZiBhIHtAbGluayBEYXRlVGltZSNab25lfSBjbGFzcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMua2VlcExvY2FsVGltZT1mYWxzZV0gLSBJZiB0cnVlLCBhZGp1c3QgdGhlIHVuZGVybHlpbmcgdGltZSBzbyB0aGF0IHRoZSBsb2NhbCB0aW1lIHN0YXlzIHRoZSBzYW1lLCBidXQgaW4gdGhlIHRhcmdldCB6b25lLiBZb3Ugc2hvdWxkIHJhcmVseSBuZWVkIHRoaXMuXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc2V0Wm9uZSh6b25lLCB7IGtlZXBMb2NhbFRpbWUgPSBmYWxzZSwga2VlcENhbGVuZGFyVGltZSA9IGZhbHNlIH0gPSB7fSkge1xuICAgIHpvbmUgPSBub3JtYWxpemVab25lKHpvbmUsIFNldHRpbmdzLmRlZmF1bHRab25lKTtcbiAgICBpZiAoem9uZS5lcXVhbHModGhpcy56b25lKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIGlmICghem9uZS5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZCh1bnN1cHBvcnRlZFpvbmUoem9uZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbmV3VFMgPSB0aGlzLnRzO1xuICAgICAgaWYgKGtlZXBMb2NhbFRpbWUgfHwga2VlcENhbGVuZGFyVGltZSkge1xuICAgICAgICBjb25zdCBvZmZzZXRHdWVzcyA9IHpvbmUub2Zmc2V0KHRoaXMudHMpO1xuICAgICAgICBjb25zdCBhc09iaiA9IHRoaXMudG9PYmplY3QoKTtcbiAgICAgICAgW25ld1RTXSA9IG9ialRvVFMoYXNPYmosIG9mZnNldEd1ZXNzLCB6b25lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHRzOiBuZXdUUywgem9uZSB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGUgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG9yIG91dHB1dENhbGVuZGFyLiBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRGF0ZVRpbWUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIC0gdGhlIHByb3BlcnRpZXMgdG8gc2V0XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS5yZWNvbmZpZ3VyZSh7IGxvY2FsZTogJ2VuLUdCJyB9KVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHJlY29uZmlndXJlKHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyIH0gPSB7fSkge1xuICAgIGNvbnN0IGxvYyA9IHRoaXMubG9jLmNsb25lKHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyIH0pO1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IGxvYyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBsb2NhbGUuIFJldHVybnMgYSBuZXdseS1jb25zdHJ1Y3RlZCBEYXRlVGltZS5cbiAgICogSnVzdCBhIGNvbnZlbmllbnQgYWxpYXMgZm9yIHJlY29uZmlndXJlKHsgbG9jYWxlIH0pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS5zZXRMb2NhbGUoJ2VuLUdCJylcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzZXRMb2NhbGUobG9jYWxlKSB7XG4gICAgcmV0dXJuIHRoaXMucmVjb25maWd1cmUoeyBsb2NhbGUgfSk7XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGUgdmFsdWVzIG9mIHNwZWNpZmllZCB1bml0cy4gUmV0dXJucyBhIG5ld2x5LWNvbnN0cnVjdGVkIERhdGVUaW1lLlxuICAgKiBZb3UgY2FuIG9ubHkgc2V0IHVuaXRzIHdpdGggdGhpcyBtZXRob2Q7IGZvciBcInNldHRpbmdcIiBtZXRhZGF0YSwgc2VlIHtAbGluayBEYXRlVGltZSNyZWNvbmZpZ3VyZX0gYW5kIHtAbGluayBEYXRlVGltZSNzZXRab25lfS5cbiAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlcyAtIGEgbWFwcGluZyBvZiB1bml0cyB0byBudW1iZXJzXG4gICAqIEBleGFtcGxlIGR0LnNldCh7IHllYXI6IDIwMTcgfSlcbiAgICogQGV4YW1wbGUgZHQuc2V0KHsgaG91cjogOCwgbWludXRlOiAzMCB9KVxuICAgKiBAZXhhbXBsZSBkdC5zZXQoeyB3ZWVrZGF5OiA1IH0pXG4gICAqIEBleGFtcGxlIGR0LnNldCh7IHllYXI6IDIwMDUsIG9yZGluYWw6IDIzNCB9KVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHNldCh2YWx1ZXMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG5cbiAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplT2JqZWN0KHZhbHVlcywgbm9ybWFsaXplVW5pdCksXG4gICAgICBzZXR0aW5nV2Vla1N0dWZmID1cbiAgICAgICAgIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQud2Vla1llYXIpIHx8XG4gICAgICAgICFpc1VuZGVmaW5lZChub3JtYWxpemVkLndlZWtOdW1iZXIpIHx8XG4gICAgICAgICFpc1VuZGVmaW5lZChub3JtYWxpemVkLndlZWtkYXkpLFxuICAgICAgY29udGFpbnNPcmRpbmFsID0gIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQub3JkaW5hbCksXG4gICAgICBjb250YWluc0dyZWdvclllYXIgPSAhaXNVbmRlZmluZWQobm9ybWFsaXplZC55ZWFyKSxcbiAgICAgIGNvbnRhaW5zR3JlZ29yTUQgPSAhaXNVbmRlZmluZWQobm9ybWFsaXplZC5tb250aCkgfHwgIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQuZGF5KSxcbiAgICAgIGNvbnRhaW5zR3JlZ29yID0gY29udGFpbnNHcmVnb3JZZWFyIHx8IGNvbnRhaW5zR3JlZ29yTUQsXG4gICAgICBkZWZpbml0ZVdlZWtEZWYgPSBub3JtYWxpemVkLndlZWtZZWFyIHx8IG5vcm1hbGl6ZWQud2Vla051bWJlcjtcblxuICAgIGlmICgoY29udGFpbnNHcmVnb3IgfHwgY29udGFpbnNPcmRpbmFsKSAmJiBkZWZpbml0ZVdlZWtEZWYpIHtcbiAgICAgIHRocm93IG5ldyBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvcihcbiAgICAgICAgXCJDYW4ndCBtaXggd2Vla1llYXIvd2Vla051bWJlciB1bml0cyB3aXRoIHllYXIvbW9udGgvZGF5IG9yIG9yZGluYWxzXCJcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRhaW5zR3JlZ29yTUQgJiYgY29udGFpbnNPcmRpbmFsKSB7XG4gICAgICB0aHJvdyBuZXcgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IoXCJDYW4ndCBtaXggb3JkaW5hbCBkYXRlcyB3aXRoIG1vbnRoL2RheVwiKTtcbiAgICB9XG5cbiAgICBsZXQgbWl4ZWQ7XG4gICAgaWYgKHNldHRpbmdXZWVrU3R1ZmYpIHtcbiAgICAgIG1peGVkID0gd2Vla1RvR3JlZ29yaWFuKHsgLi4uZ3JlZ29yaWFuVG9XZWVrKHRoaXMuYyksIC4uLm5vcm1hbGl6ZWQgfSk7XG4gICAgfSBlbHNlIGlmICghaXNVbmRlZmluZWQobm9ybWFsaXplZC5vcmRpbmFsKSkge1xuICAgICAgbWl4ZWQgPSBvcmRpbmFsVG9HcmVnb3JpYW4oeyAuLi5ncmVnb3JpYW5Ub09yZGluYWwodGhpcy5jKSwgLi4ubm9ybWFsaXplZCB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWl4ZWQgPSB7IC4uLnRoaXMudG9PYmplY3QoKSwgLi4ubm9ybWFsaXplZCB9O1xuXG4gICAgICAvLyBpZiB3ZSBkaWRuJ3Qgc2V0IHRoZSBkYXkgYnV0IHdlIGVuZGVkIHVwIG9uIGFuIG92ZXJmbG93IGRhdGUsXG4gICAgICAvLyB1c2UgdGhlIGxhc3QgZGF5IG9mIHRoZSByaWdodCBtb250aFxuICAgICAgaWYgKGlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQuZGF5KSkge1xuICAgICAgICBtaXhlZC5kYXkgPSBNYXRoLm1pbihkYXlzSW5Nb250aChtaXhlZC55ZWFyLCBtaXhlZC5tb250aCksIG1peGVkLmRheSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgW3RzLCBvXSA9IG9ialRvVFMobWl4ZWQsIHRoaXMubywgdGhpcy56b25lKTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyB0cywgbyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBwZXJpb2Qgb2YgdGltZSB0byB0aGlzIERhdGVUaW1lIGFuZCByZXR1cm4gdGhlIHJlc3VsdGluZyBEYXRlVGltZVxuICAgKlxuICAgKiBBZGRpbmcgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG9yIG1pbGxpc2Vjb25kcyBpbmNyZWFzZXMgdGhlIHRpbWVzdGFtcCBieSB0aGUgcmlnaHQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcy4gQWRkaW5nIGRheXMsIG1vbnRocywgb3IgeWVhcnMgc2hpZnRzIHRoZSBjYWxlbmRhciwgYWNjb3VudGluZyBmb3IgRFNUcyBhbmQgbGVhcCB5ZWFycyBhbG9uZyB0aGUgd2F5LiBUaHVzLCBgZHQucGx1cyh7IGhvdXJzOiAyNCB9KWAgbWF5IHJlc3VsdCBpbiBhIGRpZmZlcmVudCB0aW1lIHRoYW4gYGR0LnBsdXMoeyBkYXlzOiAxIH0pYCBpZiB0aGVyZSdzIGEgRFNUIHNoaWZ0IGluIGJldHdlZW4uXG4gICAqIEBwYXJhbSB7RHVyYXRpb258T2JqZWN0fG51bWJlcn0gZHVyYXRpb24gLSBUaGUgYW1vdW50IHRvIGFkZC4gRWl0aGVyIGEgTHV4b24gRHVyYXRpb24sIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgdGhlIG9iamVjdCBhcmd1bWVudCB0byBEdXJhdGlvbi5mcm9tT2JqZWN0KClcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cygxMjMpIC8vfj4gaW4gMTIzIG1pbGxpc2Vjb25kc1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKHsgbWludXRlczogMTUgfSkgLy9+PiBpbiAxNSBtaW51dGVzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBkYXlzOiAxIH0pIC8vfj4gdGhpcyB0aW1lIHRvbW9ycm93XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBkYXlzOiAtMSB9KSAvL34+IHRoaXMgdGltZSB5ZXN0ZXJkYXlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IGhvdXJzOiAzLCBtaW51dGVzOiAxMyB9KSAvL34+IGluIDMgaHIsIDEzIG1pblxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMywgbWludXRlczogMTMgfSkpIC8vfj4gaW4gMyBociwgMTMgbWluXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgcGx1cyhkdXJhdGlvbikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tRHVyYXRpb25MaWtlKGR1cmF0aW9uKTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgYWRqdXN0VGltZSh0aGlzLCBkdXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJ0cmFjdCBhIHBlcmlvZCBvZiB0aW1lIHRvIHRoaXMgRGF0ZVRpbWUgYW5kIHJldHVybiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lXG4gICAqIFNlZSB7QGxpbmsgRGF0ZVRpbWUjcGx1c31cbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSBhbW91bnQgdG8gc3VidHJhY3QuIEVpdGhlciBhIEx1eG9uIER1cmF0aW9uLCBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIHRoZSBvYmplY3QgYXJndW1lbnQgdG8gRHVyYXRpb24uZnJvbU9iamVjdCgpXG4gICBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIG1pbnVzKGR1cmF0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IGR1ciA9IER1cmF0aW9uLmZyb21EdXJhdGlvbkxpa2UoZHVyYXRpb24pLm5lZ2F0ZSgpO1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCBhZGp1c3RUaW1lKHRoaXMsIGR1cikpO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhpcyBEYXRlVGltZSB0byB0aGUgYmVnaW5uaW5nIG9mIGEgdW5pdCBvZiB0aW1lLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIFRoZSB1bml0IHRvIGdvIHRvIHRoZSBiZWdpbm5pbmcgb2YuIENhbiBiZSAneWVhcicsICdxdWFydGVyJywgJ21vbnRoJywgJ3dlZWsnLCAnZGF5JywgJ2hvdXInLCAnbWludXRlJywgJ3NlY29uZCcsIG9yICdtaWxsaXNlY29uZCcuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMpLnN0YXJ0T2YoJ21vbnRoJykudG9JU09EYXRlKCk7IC8vPT4gJzIwMTQtMDMtMDEnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMpLnN0YXJ0T2YoJ3llYXInKS50b0lTT0RhdGUoKTsgLy89PiAnMjAxNC0wMS0wMSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMykuc3RhcnRPZignd2VlaycpLnRvSVNPRGF0ZSgpOyAvLz0+ICcyMDE0LTAzLTAzJywgd2Vla3MgYWx3YXlzIHN0YXJ0IG9uIE1vbmRheXNcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMywgNSwgMzApLnN0YXJ0T2YoJ2RheScpLnRvSVNPVGltZSgpOyAvLz0+ICcwMDowMC4wMDAtMDU6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMsIDUsIDMwKS5zdGFydE9mKCdob3VyJykudG9JU09UaW1lKCk7IC8vPT4gJzA1OjAwOjAwLjAwMC0wNTowMCdcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGFydE9mKHVuaXQpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgbyA9IHt9LFxuICAgICAgbm9ybWFsaXplZFVuaXQgPSBEdXJhdGlvbi5ub3JtYWxpemVVbml0KHVuaXQpO1xuICAgIHN3aXRjaCAobm9ybWFsaXplZFVuaXQpIHtcbiAgICAgIGNhc2UgXCJ5ZWFyc1wiOlxuICAgICAgICBvLm1vbnRoID0gMTtcbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgXCJxdWFydGVyc1wiOlxuICAgICAgY2FzZSBcIm1vbnRoc1wiOlxuICAgICAgICBvLmRheSA9IDE7XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlIFwid2Vla3NcIjpcbiAgICAgIGNhc2UgXCJkYXlzXCI6XG4gICAgICAgIG8uaG91ciA9IDA7XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlIFwiaG91cnNcIjpcbiAgICAgICAgby5taW51dGUgPSAwO1xuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSBcIm1pbnV0ZXNcIjpcbiAgICAgICAgby5zZWNvbmQgPSAwO1xuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSBcInNlY29uZHNcIjpcbiAgICAgICAgby5taWxsaXNlY29uZCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1pbGxpc2Vjb25kc1wiOlxuICAgICAgICBicmVhaztcbiAgICAgIC8vIG5vIGRlZmF1bHQsIGludmFsaWQgdW5pdHMgdGhyb3cgaW4gbm9ybWFsaXplVW5pdCgpXG4gICAgfVxuXG4gICAgaWYgKG5vcm1hbGl6ZWRVbml0ID09PSBcIndlZWtzXCIpIHtcbiAgICAgIG8ud2Vla2RheSA9IDE7XG4gICAgfVxuXG4gICAgaWYgKG5vcm1hbGl6ZWRVbml0ID09PSBcInF1YXJ0ZXJzXCIpIHtcbiAgICAgIGNvbnN0IHEgPSBNYXRoLmNlaWwodGhpcy5tb250aCAvIDMpO1xuICAgICAgby5tb250aCA9IChxIC0gMSkgKiAzICsgMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zZXQobyk7XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGlzIERhdGVUaW1lIHRvIHRoZSBlbmQgKG1lYW5pbmcgdGhlIGxhc3QgbWlsbGlzZWNvbmQpIG9mIGEgdW5pdCBvZiB0aW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1bml0IC0gVGhlIHVuaXQgdG8gZ28gdG8gdGhlIGVuZCBvZi4gQ2FuIGJlICd5ZWFyJywgJ3F1YXJ0ZXInLCAnbW9udGgnLCAnd2VlaycsICdkYXknLCAnaG91cicsICdtaW51dGUnLCAnc2Vjb25kJywgb3IgJ21pbGxpc2Vjb25kJy5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMykuZW5kT2YoJ21vbnRoJykudG9JU08oKTsgLy89PiAnMjAxNC0wMy0zMVQyMzo1OTo1OS45OTktMDU6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMpLmVuZE9mKCd5ZWFyJykudG9JU08oKTsgLy89PiAnMjAxNC0xMi0zMVQyMzo1OTo1OS45OTktMDU6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMpLmVuZE9mKCd3ZWVrJykudG9JU08oKTsgLy8gPT4gJzIwMTQtMDMtMDlUMjM6NTk6NTkuOTk5LTA1OjAwJywgd2Vla3Mgc3RhcnQgb24gTW9uZGF5c1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzLCA1LCAzMCkuZW5kT2YoJ2RheScpLnRvSVNPKCk7IC8vPT4gJzIwMTQtMDMtMDNUMjM6NTk6NTkuOTk5LTA1OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzLCA1LCAzMCkuZW5kT2YoJ2hvdXInKS50b0lTTygpOyAvLz0+ICcyMDE0LTAzLTAzVDA1OjU5OjU5Ljk5OS0wNTowMCdcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBlbmRPZih1bml0KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZFxuICAgICAgPyB0aGlzLnBsdXMoeyBbdW5pdF06IDEgfSlcbiAgICAgICAgICAuc3RhcnRPZih1bml0KVxuICAgICAgICAgIC5taW51cygxKVxuICAgICAgOiB0aGlzO1xuICB9XG5cbiAgLy8gT1VUUFVUXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBmb3JtYXR0ZWQgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgZm9ybWF0IHN0cmluZy5cbiAgICogKipZb3UgbWF5IG5vdCB3YW50IHRoaXMuKiogU2VlIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9yIGEgbW9yZSBmbGV4aWJsZSBmb3JtYXR0aW5nIHRvb2wuIEZvciBhIHRhYmxlIG9mIHRva2VucyBhbmQgdGhlaXIgaW50ZXJwcmV0YXRpb25zLCBzZWUgW2hlcmVdKGh0dHBzOi8vbW9tZW50LmdpdGh1Yi5pby9sdXhvbi8jL2Zvcm1hdHRpbmc/aWQ9dGFibGUtb2YtdG9rZW5zKS5cbiAgICogRGVmYXVsdHMgdG8gZW4tVVMgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZCwgcmVnYXJkbGVzcyBvZiB0aGUgc3lzdGVtJ3MgbG9jYWxlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm10IC0gdGhlIGZvcm1hdCBzdHJpbmdcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRzIHRvIG92ZXJyaWRlIHRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgb24gdGhpcyBEYXRlVGltZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0Zvcm1hdCgneXl5eSBMTEwgZGQnKSAvLz0+ICcyMDE3IEFwciAyMidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkuc2V0TG9jYWxlKCdmcicpLnRvRm9ybWF0KCd5eXl5IExMTCBkZCcpIC8vPT4gJzIwMTcgYXZyLiAyMidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Gb3JtYXQoJ3l5eXkgTExMIGRkJywgeyBsb2NhbGU6IFwiZnJcIiB9KSAvLz0+ICcyMDE3IGF2ci4gMjInXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvRm9ybWF0KFwiSEggJ2hvdXJzIGFuZCcgbW0gJ21pbnV0ZXMnXCIpIC8vPT4gJzIwIGhvdXJzIGFuZCA1NSBtaW51dGVzJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0Zvcm1hdChmbXQsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWRcbiAgICAgID8gRm9ybWF0dGVyLmNyZWF0ZSh0aGlzLmxvYy5yZWRlZmF1bHRUb0VOKG9wdHMpKS5mb3JtYXREYXRlVGltZUZyb21TdHJpbmcodGhpcywgZm10KVxuICAgICAgOiBJTlZBTElEO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsb2NhbGl6ZWQgc3RyaW5nIHJlcHJlc2VudGluZyB0aGlzIGRhdGUuIEFjY2VwdHMgdGhlIHNhbWUgb3B0aW9ucyBhcyB0aGUgSW50bC5EYXRlVGltZUZvcm1hdCBjb25zdHJ1Y3RvciBhbmQgYW55IHByZXNldHMgZGVmaW5lZCBieSBMdXhvbiwgc3VjaCBhcyBgRGF0ZVRpbWUuREFURV9GVUxMYCBvciBgRGF0ZVRpbWUuVElNRV9TSU1QTEVgLlxuICAgKiBUaGUgZXhhY3QgYmVoYXZpb3Igb2YgdGhpcyBtZXRob2QgaXMgYnJvd3Nlci1zcGVjaWZpYywgYnV0IGluIGdlbmVyYWwgaXQgd2lsbCByZXR1cm4gYW4gYXBwcm9wcmlhdGUgcmVwcmVzZW50YXRpb25cbiAgICogb2YgdGhlIERhdGVUaW1lIGluIHRoZSBhc3NpZ25lZCBsb2NhbGUuXG4gICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGVUaW1lRm9ybWF0XG4gICAqIEBwYXJhbSBmb3JtYXRPcHRzIHtPYmplY3R9IC0gSW50bC5EYXRlVGltZUZvcm1hdCBjb25zdHJ1Y3RvciBvcHRpb25zIGFuZCBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRzIHRvIG92ZXJyaWRlIHRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgb24gdGhpcyBEYXRlVGltZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVN0cmluZygpOyAvLz0+IDQvMjAvMjAxN1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5zZXRMb2NhbGUoJ2VuLWdiJykudG9Mb2NhbGVTdHJpbmcoKTsgLy89PiAnMjAvMDQvMjAxNydcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVTdHJpbmcoRGF0ZVRpbWUuREFURV9GVUxMKTsgLy89PiAnQXByaWwgMjAsIDIwMTcnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKERhdGVUaW1lLkRBVEVfRlVMTCwgeyBsb2NhbGU6ICdmcicgfSk7IC8vPT4gJzI4IGFvw7t0IDIwMjInXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKERhdGVUaW1lLlRJTUVfU0lNUExFKTsgLy89PiAnMTE6MzIgQU0nXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKERhdGVUaW1lLkRBVEVUSU1FX1NIT1JUKTsgLy89PiAnNC8yMC8yMDE3LCAxMTozMiBBTSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVTdHJpbmcoeyB3ZWVrZGF5OiAnbG9uZycsIG1vbnRoOiAnbG9uZycsIGRheTogJzItZGlnaXQnIH0pOyAvLz0+ICdUaHVyc2RheSwgQXByaWwgMjAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKHsgd2Vla2RheTogJ3Nob3J0JywgbW9udGg6ICdzaG9ydCcsIGRheTogJzItZGlnaXQnLCBob3VyOiAnMi1kaWdpdCcsIG1pbnV0ZTogJzItZGlnaXQnIH0pOyAvLz0+ICdUaHUsIEFwciAyMCwgMTE6MjcgQU0nXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKHsgaG91cjogJzItZGlnaXQnLCBtaW51dGU6ICcyLWRpZ2l0JywgaG91ckN5Y2xlOiAnaDIzJyB9KTsgLy89PiAnMTE6MzInXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvTG9jYWxlU3RyaW5nKGZvcm1hdE9wdHMgPSBGb3JtYXRzLkRBVEVfU0hPUlQsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWRcbiAgICAgID8gRm9ybWF0dGVyLmNyZWF0ZSh0aGlzLmxvYy5jbG9uZShvcHRzKSwgZm9ybWF0T3B0cykuZm9ybWF0RGF0ZVRpbWUodGhpcylcbiAgICAgIDogSU5WQUxJRDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGZvcm1hdCBcInBhcnRzXCIsIG1lYW5pbmcgaW5kaXZpZHVhbCB0b2tlbnMgYWxvbmcgd2l0aCBtZXRhZGF0YS4gVGhpcyBpcyBhbGxvd3MgY2FsbGVycyB0byBwb3N0LXByb2Nlc3MgaW5kaXZpZHVhbCBzZWN0aW9ucyBvZiB0aGUgZm9ybWF0dGVkIG91dHB1dC5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZVRpbWVGb3JtYXQvZm9ybWF0VG9QYXJ0c1xuICAgKiBAcGFyYW0gb3B0cyB7T2JqZWN0fSAtIEludGwuRGF0ZVRpbWVGb3JtYXQgY29uc3RydWN0b3Igb3B0aW9ucywgc2FtZSBhcyBgdG9Mb2NhbGVTdHJpbmdgLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVBhcnRzKCk7IC8vPT4gW1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy89PiAgIHsgdHlwZTogJ2RheScsIHZhbHVlOiAnMjUnIH0sXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLz0+ICAgeyB0eXBlOiAnbGl0ZXJhbCcsIHZhbHVlOiAnLycgfSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vPT4gICB7IHR5cGU6ICdtb250aCcsIHZhbHVlOiAnMDUnIH0sXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLz0+ICAgeyB0eXBlOiAnbGl0ZXJhbCcsIHZhbHVlOiAnLycgfSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vPT4gICB7IHR5cGU6ICd5ZWFyJywgdmFsdWU6ICcxOTgyJyB9XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLz0+IF1cbiAgICovXG4gIHRvTG9jYWxlUGFydHMob3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZFxuICAgICAgPyBGb3JtYXR0ZXIuY3JlYXRlKHRoaXMubG9jLmNsb25lKG9wdHMpLCBvcHRzKS5mb3JtYXREYXRlVGltZVBhcnRzKHRoaXMpXG4gICAgICA6IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnN1cHByZXNzTWlsbGlzZWNvbmRzPWZhbHNlXSAtIGV4Y2x1ZGUgbWlsbGlzZWNvbmRzIGZyb20gdGhlIGZvcm1hdCBpZiB0aGV5J3JlIDBcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zdXBwcmVzc1NlY29uZHM9ZmFsc2VdIC0gZXhjbHVkZSBzZWNvbmRzIGZyb20gdGhlIGZvcm1hdCBpZiB0aGV5J3JlIDBcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlT2Zmc2V0PXRydWVdIC0gaW5jbHVkZSB0aGUgb2Zmc2V0LCBzdWNoIGFzICdaJyBvciAnLTA0OjAwJ1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmV4dGVuZGVkWm9uZT1mYWxzZV0gLSBhZGQgdGhlIHRpbWUgem9uZSBmb3JtYXQgZXh0ZW5zaW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5mb3JtYXQ9J2V4dGVuZGVkJ10gLSBjaG9vc2UgYmV0d2VlbiB0aGUgYmFzaWMgYW5kIGV4dGVuZGVkIGZvcm1hdFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMTk4MywgNSwgMjUpLnRvSVNPKCkgLy89PiAnMTk4Mi0wNS0yNVQwMDowMDowMC4wMDBaJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0lTTygpIC8vPT4gJzIwMTctMDQtMjJUMjA6NDc6MDUuMzM1LTA0OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0lTTyh7IGluY2x1ZGVPZmZzZXQ6IGZhbHNlIH0pIC8vPT4gJzIwMTctMDQtMjJUMjA6NDc6MDUuMzM1J1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0lTTyh7IGZvcm1hdDogJ2Jhc2ljJyB9KSAvLz0+ICcyMDE3MDQyMlQyMDQ3MDUuMzM1LTA0MDAnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSVNPKHtcbiAgICBmb3JtYXQgPSBcImV4dGVuZGVkXCIsXG4gICAgc3VwcHJlc3NTZWNvbmRzID0gZmFsc2UsXG4gICAgc3VwcHJlc3NNaWxsaXNlY29uZHMgPSBmYWxzZSxcbiAgICBpbmNsdWRlT2Zmc2V0ID0gdHJ1ZSxcbiAgICBleHRlbmRlZFpvbmUgPSBmYWxzZSxcbiAgfSA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGV4dCA9IGZvcm1hdCA9PT0gXCJleHRlbmRlZFwiO1xuXG4gICAgbGV0IGMgPSB0b0lTT0RhdGUodGhpcywgZXh0KTtcbiAgICBjICs9IFwiVFwiO1xuICAgIGMgKz0gdG9JU09UaW1lKHRoaXMsIGV4dCwgc3VwcHJlc3NTZWNvbmRzLCBzdXBwcmVzc01pbGxpc2Vjb25kcywgaW5jbHVkZU9mZnNldCwgZXh0ZW5kZWRab25lKTtcbiAgICByZXR1cm4gYztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSdzIGRhdGUgY29tcG9uZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuZm9ybWF0PSdleHRlbmRlZCddIC0gY2hvb3NlIGJldHdlZW4gdGhlIGJhc2ljIGFuZCBleHRlbmRlZCBmb3JtYXRcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDE5ODIsIDUsIDI1KS50b0lTT0RhdGUoKSAvLz0+ICcxOTgyLTA1LTI1J1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMTk4MiwgNSwgMjUpLnRvSVNPRGF0ZSh7IGZvcm1hdDogJ2Jhc2ljJyB9KSAvLz0+ICcxOTgyMDUyNSdcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9JU09EYXRlKHsgZm9ybWF0ID0gXCJleHRlbmRlZFwiIH0gPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdG9JU09EYXRlKHRoaXMsIGZvcm1hdCA9PT0gXCJleHRlbmRlZFwiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSdzIHdlZWsgZGF0ZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMTk4MiwgNSwgMjUpLnRvSVNPV2Vla0RhdGUoKSAvLz0+ICcxOTgyLVcyMS0yJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0lTT1dlZWtEYXRlKCkge1xuICAgIHJldHVybiB0b1RlY2hGb3JtYXQodGhpcywgXCJra2trLSdXJ1dXLWNcIik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUncyB0aW1lIGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zdXBwcmVzc01pbGxpc2Vjb25kcz1mYWxzZV0gLSBleGNsdWRlIG1pbGxpc2Vjb25kcyBmcm9tIHRoZSBmb3JtYXQgaWYgdGhleSdyZSAwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc3VwcHJlc3NTZWNvbmRzPWZhbHNlXSAtIGV4Y2x1ZGUgc2Vjb25kcyBmcm9tIHRoZSBmb3JtYXQgaWYgdGhleSdyZSAwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZU9mZnNldD10cnVlXSAtIGluY2x1ZGUgdGhlIG9mZnNldCwgc3VjaCBhcyAnWicgb3IgJy0wNDowMCdcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5leHRlbmRlZFpvbmU9dHJ1ZV0gLSBhZGQgdGhlIHRpbWUgem9uZSBmb3JtYXQgZXh0ZW5zaW9uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZVByZWZpeD1mYWxzZV0gLSBpbmNsdWRlIHRoZSBgVGAgcHJlZml4XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5mb3JtYXQ9J2V4dGVuZGVkJ10gLSBjaG9vc2UgYmV0d2VlbiB0aGUgYmFzaWMgYW5kIGV4dGVuZGVkIGZvcm1hdFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoKS5zZXQoeyBob3VyOiA3LCBtaW51dGU6IDM0IH0pLnRvSVNPVGltZSgpIC8vPT4gJzA3OjM0OjE5LjM2MVonXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygpLnNldCh7IGhvdXI6IDcsIG1pbnV0ZTogMzQsIHNlY29uZHM6IDAsIG1pbGxpc2Vjb25kczogMCB9KS50b0lTT1RpbWUoeyBzdXBwcmVzc1NlY29uZHM6IHRydWUgfSkgLy89PiAnMDc6MzRaJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoKS5zZXQoeyBob3VyOiA3LCBtaW51dGU6IDM0IH0pLnRvSVNPVGltZSh7IGZvcm1hdDogJ2Jhc2ljJyB9KSAvLz0+ICcwNzM0MTkuMzYxWidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKCkuc2V0KHsgaG91cjogNywgbWludXRlOiAzNCB9KS50b0lTT1RpbWUoeyBpbmNsdWRlUHJlZml4OiB0cnVlIH0pIC8vPT4gJ1QwNzozNDoxOS4zNjFaJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0lTT1RpbWUoe1xuICAgIHN1cHByZXNzTWlsbGlzZWNvbmRzID0gZmFsc2UsXG4gICAgc3VwcHJlc3NTZWNvbmRzID0gZmFsc2UsXG4gICAgaW5jbHVkZU9mZnNldCA9IHRydWUsXG4gICAgaW5jbHVkZVByZWZpeCA9IGZhbHNlLFxuICAgIGV4dGVuZGVkWm9uZSA9IGZhbHNlLFxuICAgIGZvcm1hdCA9IFwiZXh0ZW5kZWRcIixcbiAgfSA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGxldCBjID0gaW5jbHVkZVByZWZpeCA/IFwiVFwiIDogXCJcIjtcbiAgICByZXR1cm4gKFxuICAgICAgYyArXG4gICAgICB0b0lTT1RpbWUoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIGZvcm1hdCA9PT0gXCJleHRlbmRlZFwiLFxuICAgICAgICBzdXBwcmVzc1NlY29uZHMsXG4gICAgICAgIHN1cHByZXNzTWlsbGlzZWNvbmRzLFxuICAgICAgICBpbmNsdWRlT2Zmc2V0LFxuICAgICAgICBleHRlbmRlZFpvbmVcbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gUkZDIDI4MjItY29tcGF0aWJsZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNCwgNywgMTMpLnRvUkZDMjgyMigpIC8vPT4gJ1N1biwgMTMgSnVsIDIwMTQgMDA6MDA6MDAgKzAwMDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDcsIDEzKS50b1JGQzI4MjIoKSAvLz0+ICdTdW4sIDEzIEp1bCAyMDE0IDAwOjAwOjAwIC0wNDAwJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b1JGQzI4MjIoKSB7XG4gICAgcmV0dXJuIHRvVGVjaEZvcm1hdCh0aGlzLCBcIkVFRSwgZGQgTExMIHl5eXkgSEg6bW06c3MgWlpaXCIsIGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBIVFRQIGhlYWRlcnMuIFRoZSBvdXRwdXQgaXMgYWx3YXlzIGV4cHJlc3NlZCBpbiBHTVQuXG4gICAqIFNwZWNpZmljYWxseSwgdGhlIHN0cmluZyBjb25mb3JtcyB0byBSRkMgMTEyMy5cbiAgICogQHNlZSBodHRwczovL3d3dy53My5vcmcvUHJvdG9jb2xzL3JmYzI2MTYvcmZjMjYxNi1zZWMzLmh0bWwjc2VjMy4zLjFcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTQsIDcsIDEzKS50b0hUVFAoKSAvLz0+ICdTdW4sIDEzIEp1bCAyMDE0IDAwOjAwOjAwIEdNVCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTQsIDcsIDEzLCAxOSkudG9IVFRQKCkgLy89PiAnU3VuLCAxMyBKdWwgMjAxNCAxOTowMDowMCBHTVQnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSFRUUCgpIHtcbiAgICByZXR1cm4gdG9UZWNoRm9ybWF0KHRoaXMudG9VVEMoKSwgXCJFRUUsIGRkIExMTCB5eXl5IEhIOm1tOnNzICdHTVQnXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBhcHByb3ByaWF0ZSBmb3IgdXNlIGluIFNRTCBEYXRlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE0LCA3LCAxMykudG9TUUxEYXRlKCkgLy89PiAnMjAxNC0wNy0xMydcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9TUUxEYXRlKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRvSVNPRGF0ZSh0aGlzLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBTUUwgVGltZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlWm9uZT1mYWxzZV0gLSBpbmNsdWRlIHRoZSB6b25lLCBzdWNoIGFzICdBbWVyaWNhL05ld19Zb3JrJy4gT3ZlcnJpZGVzIGluY2x1ZGVPZmZzZXQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZU9mZnNldD10cnVlXSAtIGluY2x1ZGUgdGhlIG9mZnNldCwgc3VjaCBhcyAnWicgb3IgJy0wNDowMCdcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlT2Zmc2V0U3BhY2U9dHJ1ZV0gLSBpbmNsdWRlIHRoZSBzcGFjZSBiZXR3ZWVuIHRoZSB0aW1lIGFuZCB0aGUgb2Zmc2V0LCBzdWNoIGFzICcwNToxNToxNi4zNDUgLTA0OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoKS50b1NRTCgpIC8vPT4gJzA1OjE1OjE2LjM0NSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9TUUwoKSAvLz0+ICcwNToxNToxNi4zNDUgLTA0OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b1NRTCh7IGluY2x1ZGVPZmZzZXQ6IGZhbHNlIH0pIC8vPT4gJzA1OjE1OjE2LjM0NSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9TUUwoeyBpbmNsdWRlWm9uZTogZmFsc2UgfSkgLy89PiAnMDU6MTU6MTYuMzQ1IEFtZXJpY2EvTmV3X1lvcmsnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvU1FMVGltZSh7IGluY2x1ZGVPZmZzZXQgPSB0cnVlLCBpbmNsdWRlWm9uZSA9IGZhbHNlLCBpbmNsdWRlT2Zmc2V0U3BhY2UgPSB0cnVlIH0gPSB7fSkge1xuICAgIGxldCBmbXQgPSBcIkhIOm1tOnNzLlNTU1wiO1xuXG4gICAgaWYgKGluY2x1ZGVab25lIHx8IGluY2x1ZGVPZmZzZXQpIHtcbiAgICAgIGlmIChpbmNsdWRlT2Zmc2V0U3BhY2UpIHtcbiAgICAgICAgZm10ICs9IFwiIFwiO1xuICAgICAgfVxuICAgICAgaWYgKGluY2x1ZGVab25lKSB7XG4gICAgICAgIGZtdCArPSBcInpcIjtcbiAgICAgIH0gZWxzZSBpZiAoaW5jbHVkZU9mZnNldCkge1xuICAgICAgICBmbXQgKz0gXCJaWlwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0b1RlY2hGb3JtYXQodGhpcywgZm10LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBTUUwgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZVpvbmU9ZmFsc2VdIC0gaW5jbHVkZSB0aGUgem9uZSwgc3VjaCBhcyAnQW1lcmljYS9OZXdfWW9yaycuIE92ZXJyaWRlcyBpbmNsdWRlT2Zmc2V0LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVPZmZzZXQ9dHJ1ZV0gLSBpbmNsdWRlIHRoZSBvZmZzZXQsIHN1Y2ggYXMgJ1onIG9yICctMDQ6MDAnXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZU9mZnNldFNwYWNlPXRydWVdIC0gaW5jbHVkZSB0aGUgc3BhY2UgYmV0d2VlbiB0aGUgdGltZSBhbmQgdGhlIG9mZnNldCwgc3VjaCBhcyAnMDU6MTU6MTYuMzQ1IC0wNDowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTQsIDcsIDEzKS50b1NRTCgpIC8vPT4gJzIwMTQtMDctMTMgMDA6MDA6MDAuMDAwIFonXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDcsIDEzKS50b1NRTCgpIC8vPT4gJzIwMTQtMDctMTMgMDA6MDA6MDAuMDAwIC0wNDowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgNywgMTMpLnRvU1FMKHsgaW5jbHVkZU9mZnNldDogZmFsc2UgfSkgLy89PiAnMjAxNC0wNy0xMyAwMDowMDowMC4wMDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDcsIDEzKS50b1NRTCh7IGluY2x1ZGVab25lOiB0cnVlIH0pIC8vPT4gJzIwMTQtMDctMTMgMDA6MDA6MDAuMDAwIEFtZXJpY2EvTmV3X1lvcmsnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvU1FMKG9wdHMgPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gYCR7dGhpcy50b1NRTERhdGUoKX0gJHt0aGlzLnRvU1FMVGltZShvcHRzKX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBhcHByb3ByaWF0ZSBmb3IgZGVidWdnaW5nXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnRvSVNPKCkgOiBJTlZBTElEO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVwb2NoIG1pbGxpc2Vjb25kcyBvZiB0aGlzIERhdGVUaW1lLiBBbGlhcyBvZiB7QGxpbmsgRGF0ZVRpbWUjdG9NaWxsaXN9XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHZhbHVlT2YoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9NaWxsaXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlcG9jaCBtaWxsaXNlY29uZHMgb2YgdGhpcyBEYXRlVGltZS5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgdG9NaWxsaXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudHMgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZXBvY2ggc2Vjb25kcyBvZiB0aGlzIERhdGVUaW1lLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICB0b1NlY29uZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudHMgLyAxMDAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVwb2NoIHNlY29uZHMgKGFzIGEgd2hvbGUgbnVtYmVyKSBvZiB0aGlzIERhdGVUaW1lLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICB0b1VuaXhJbnRlZ2VyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBNYXRoLmZsb29yKHRoaXMudHMgLyAxMDAwKSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBKU09OLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9JU08oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgQlNPTiBzZXJpYWxpemFibGUgZXF1aXZhbGVudCB0byB0aGlzIERhdGVUaW1lLlxuICAgKiBAcmV0dXJuIHtEYXRlfVxuICAgKi9cbiAgdG9CU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvSlNEYXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIEphdmFTY3JpcHQgb2JqZWN0IHdpdGggdGhpcyBEYXRlVGltZSdzIHllYXIsIG1vbnRoLCBkYXksIGFuZCBzbyBvbi5cbiAgICogQHBhcmFtIG9wdHMgLSBvcHRpb25zIGZvciBnZW5lcmF0aW5nIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlQ29uZmlnPWZhbHNlXSAtIGluY2x1ZGUgY29uZmlndXJhdGlvbiBhdHRyaWJ1dGVzIGluIHRoZSBvdXRwdXRcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9PYmplY3QoKSAvLz0+IHsgeWVhcjogMjAxNywgbW9udGg6IDQsIGRheTogMjIsIGhvdXI6IDIwLCBtaW51dGU6IDQ5LCBzZWNvbmQ6IDQyLCBtaWxsaXNlY29uZDogMjY4IH1cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgdG9PYmplY3Qob3B0cyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB7fTtcblxuICAgIGNvbnN0IGJhc2UgPSB7IC4uLnRoaXMuYyB9O1xuXG4gICAgaWYgKG9wdHMuaW5jbHVkZUNvbmZpZykge1xuICAgICAgYmFzZS5vdXRwdXRDYWxlbmRhciA9IHRoaXMub3V0cHV0Q2FsZW5kYXI7XG4gICAgICBiYXNlLm51bWJlcmluZ1N5c3RlbSA9IHRoaXMubG9jLm51bWJlcmluZ1N5c3RlbTtcbiAgICAgIGJhc2UubG9jYWxlID0gdGhpcy5sb2MubG9jYWxlO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgSmF2YVNjcmlwdCBEYXRlIGVxdWl2YWxlbnQgdG8gdGhpcyBEYXRlVGltZS5cbiAgICogQHJldHVybiB7RGF0ZX1cbiAgICovXG4gIHRvSlNEYXRlKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLmlzVmFsaWQgPyB0aGlzLnRzIDogTmFOKTtcbiAgfVxuXG4gIC8vIENPTVBBUkVcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdHdvIERhdGVUaW1lcyBhcyBhIER1cmF0aW9uLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBvdGhlckRhdGVUaW1lIC0gdGhlIERhdGVUaW1lIHRvIGNvbXBhcmUgdGhpcyBvbmUgdG9cbiAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IFt1bml0PVsnbWlsbGlzZWNvbmRzJ11dIC0gdGhlIHVuaXQgb3IgYXJyYXkgb2YgdW5pdHMgKHN1Y2ggYXMgJ2hvdXJzJyBvciAnZGF5cycpIHRvIGluY2x1ZGUgaW4gdGhlIGR1cmF0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdGhhdCBhZmZlY3QgdGhlIGNyZWF0aW9uIG9mIHRoZSBEdXJhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29udmVyc2lvbkFjY3VyYWN5PSdjYXN1YWwnXSAtIHRoZSBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGkxID0gRGF0ZVRpbWUuZnJvbUlTTygnMTk4Mi0wNS0yNVQwOTo0NScpLFxuICAgKiAgICAgaTIgPSBEYXRlVGltZS5mcm9tSVNPKCcxOTgzLTEwLTE0VDEwOjMwJyk7XG4gICAqIGkyLmRpZmYoaTEpLnRvT2JqZWN0KCkgLy89PiB7IG1pbGxpc2Vjb25kczogNDM4MDc1MDAwMDAgfVxuICAgKiBpMi5kaWZmKGkxLCAnaG91cnMnKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMTIxNjguNzUgfVxuICAgKiBpMi5kaWZmKGkxLCBbJ21vbnRocycsICdkYXlzJ10pLnRvT2JqZWN0KCkgLy89PiB7IG1vbnRoczogMTYsIGRheXM6IDE5LjAzMTI1IH1cbiAgICogaTIuZGlmZihpMSwgWydtb250aHMnLCAnZGF5cycsICdob3VycyddKS50b09iamVjdCgpIC8vPT4geyBtb250aHM6IDE2LCBkYXlzOiAxOSwgaG91cnM6IDAuNzUgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIGRpZmYob3RoZXJEYXRlVGltZSwgdW5pdCA9IFwibWlsbGlzZWNvbmRzXCIsIG9wdHMgPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkIHx8ICFvdGhlckRhdGVUaW1lLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5pbnZhbGlkKFwiY3JlYXRlZCBieSBkaWZmaW5nIGFuIGludmFsaWQgRGF0ZVRpbWVcIik7XG4gICAgfVxuXG4gICAgY29uc3QgZHVyT3B0cyA9IHsgbG9jYWxlOiB0aGlzLmxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtOiB0aGlzLm51bWJlcmluZ1N5c3RlbSwgLi4ub3B0cyB9O1xuXG4gICAgY29uc3QgdW5pdHMgPSBtYXliZUFycmF5KHVuaXQpLm1hcChEdXJhdGlvbi5ub3JtYWxpemVVbml0KSxcbiAgICAgIG90aGVySXNMYXRlciA9IG90aGVyRGF0ZVRpbWUudmFsdWVPZigpID4gdGhpcy52YWx1ZU9mKCksXG4gICAgICBlYXJsaWVyID0gb3RoZXJJc0xhdGVyID8gdGhpcyA6IG90aGVyRGF0ZVRpbWUsXG4gICAgICBsYXRlciA9IG90aGVySXNMYXRlciA/IG90aGVyRGF0ZVRpbWUgOiB0aGlzLFxuICAgICAgZGlmZmVkID0gZGlmZihlYXJsaWVyLCBsYXRlciwgdW5pdHMsIGR1ck9wdHMpO1xuXG4gICAgcmV0dXJuIG90aGVySXNMYXRlciA/IGRpZmZlZC5uZWdhdGUoKSA6IGRpZmZlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGlzIERhdGVUaW1lIGFuZCByaWdodCBub3cuXG4gICAqIFNlZSB7QGxpbmsgRGF0ZVRpbWUjZGlmZn1cbiAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IFt1bml0PVsnbWlsbGlzZWNvbmRzJ11dIC0gdGhlIHVuaXQgb3IgdW5pdHMgdW5pdHMgKHN1Y2ggYXMgJ2hvdXJzJyBvciAnZGF5cycpIHRvIGluY2x1ZGUgaW4gdGhlIGR1cmF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0aGF0IGFmZmVjdCB0aGUgY3JlYXRpb24gb2YgdGhlIER1cmF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5jb252ZXJzaW9uQWNjdXJhY3k9J2Nhc3VhbCddIC0gdGhlIGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIGRpZmZOb3codW5pdCA9IFwibWlsbGlzZWNvbmRzXCIsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmRpZmYoRGF0ZVRpbWUubm93KCksIHVuaXQsIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBJbnRlcnZhbCBzcGFubmluZyBiZXR3ZWVuIHRoaXMgRGF0ZVRpbWUgYW5kIGFub3RoZXIgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtEYXRlVGltZX0gb3RoZXJEYXRlVGltZSAtIHRoZSBvdGhlciBlbmQgcG9pbnQgb2YgdGhlIEludGVydmFsXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgdW50aWwob3RoZXJEYXRlVGltZSkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHRoaXMsIG90aGVyRGF0ZVRpbWUpIDogdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIERhdGVUaW1lIGlzIGluIHRoZSBzYW1lIHVuaXQgb2YgdGltZSBhcyBhbm90aGVyIERhdGVUaW1lLlxuICAgKiBIaWdoZXItb3JkZXIgdW5pdHMgbXVzdCBhbHNvIGJlIGlkZW50aWNhbCBmb3IgdGhpcyBmdW5jdGlvbiB0byByZXR1cm4gYHRydWVgLlxuICAgKiBOb3RlIHRoYXQgdGltZSB6b25lcyBhcmUgKippZ25vcmVkKiogaW4gdGhpcyBjb21wYXJpc29uLCB3aGljaCBjb21wYXJlcyB0aGUgKipsb2NhbCoqIGNhbGVuZGFyIHRpbWUuIFVzZSB7QGxpbmsgRGF0ZVRpbWUjc2V0Wm9uZX0gdG8gY29udmVydCBvbmUgb2YgdGhlIGRhdGVzIGlmIG5lZWRlZC5cbiAgICogQHBhcmFtIHtEYXRlVGltZX0gb3RoZXJEYXRlVGltZSAtIHRoZSBvdGhlciBEYXRlVGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIHRoZSB1bml0IG9mIHRpbWUgdG8gY2hlY2sgc2FtZW5lc3Mgb25cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkuaGFzU2FtZShvdGhlckRULCAnZGF5Jyk7IC8vfj4gdHJ1ZSBpZiBvdGhlckRUIGlzIGluIHRoZSBzYW1lIGN1cnJlbnQgY2FsZW5kYXIgZGF5XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNTYW1lKG90aGVyRGF0ZVRpbWUsIHVuaXQpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgY29uc3QgaW5wdXRNcyA9IG90aGVyRGF0ZVRpbWUudmFsdWVPZigpO1xuICAgIGNvbnN0IGFkanVzdGVkVG9ab25lID0gdGhpcy5zZXRab25lKG90aGVyRGF0ZVRpbWUuem9uZSwgeyBrZWVwTG9jYWxUaW1lOiB0cnVlIH0pO1xuICAgIHJldHVybiBhZGp1c3RlZFRvWm9uZS5zdGFydE9mKHVuaXQpIDw9IGlucHV0TXMgJiYgaW5wdXRNcyA8PSBhZGp1c3RlZFRvWm9uZS5lbmRPZih1bml0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFcXVhbGl0eSBjaGVja1xuICAgKiBUd28gRGF0ZVRpbWVzIGFyZSBlcXVhbCBpZiBhbmQgb25seSBpZiB0aGV5IHJlcHJlc2VudCB0aGUgc2FtZSBtaWxsaXNlY29uZCwgaGF2ZSB0aGUgc2FtZSB6b25lIGFuZCBsb2NhdGlvbiwgYW5kIGFyZSBib3RoIHZhbGlkLlxuICAgKiBUbyBjb21wYXJlIGp1c3QgdGhlIG1pbGxpc2Vjb25kIHZhbHVlcywgdXNlIGArZHQxID09PSArZHQyYC5cbiAgICogQHBhcmFtIHtEYXRlVGltZX0gb3RoZXIgLSB0aGUgb3RoZXIgRGF0ZVRpbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmlzVmFsaWQgJiZcbiAgICAgIG90aGVyLmlzVmFsaWQgJiZcbiAgICAgIHRoaXMudmFsdWVPZigpID09PSBvdGhlci52YWx1ZU9mKCkgJiZcbiAgICAgIHRoaXMuem9uZS5lcXVhbHMob3RoZXIuem9uZSkgJiZcbiAgICAgIHRoaXMubG9jLmVxdWFscyhvdGhlci5sb2MpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdGhpcyB0aW1lIHJlbGF0aXZlIHRvIG5vdywgc3VjaCBhcyBcImluIHR3byBkYXlzXCIuIENhbiBvbmx5IGludGVybmF0aW9uYWxpemUgaWYgeW91clxuICAgKiBwbGF0Zm9ybSBzdXBwb3J0cyBJbnRsLlJlbGF0aXZlVGltZUZvcm1hdC4gUm91bmRzIGRvd24gYnkgZGVmYXVsdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIHRoYXQgYWZmZWN0IHRoZSBvdXRwdXRcbiAgICogQHBhcmFtIHtEYXRlVGltZX0gW29wdGlvbnMuYmFzZT1EYXRlVGltZS5ub3coKV0gLSB0aGUgRGF0ZVRpbWUgdG8gdXNlIGFzIHRoZSBiYXNpcyB0byB3aGljaCB0aGlzIHRpbWUgaXMgY29tcGFyZWQuIERlZmF1bHRzIHRvIG5vdy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnN0eWxlPVwibG9uZ1wiXSAtIHRoZSBzdHlsZSBvZiB1bml0cywgbXVzdCBiZSBcImxvbmdcIiwgXCJzaG9ydFwiLCBvciBcIm5hcnJvd1wiXG4gICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBvcHRpb25zLnVuaXQgLSB1c2UgYSBzcGVjaWZpYyB1bml0IG9yIGFycmF5IG9mIHVuaXRzOyBpZiBvbWl0dGVkLCBvciBhbiBhcnJheSwgdGhlIG1ldGhvZCB3aWxsIHBpY2sgdGhlIGJlc3QgdW5pdC4gVXNlIGFuIGFycmF5IG9yIG9uZSBvZiBcInllYXJzXCIsIFwicXVhcnRlcnNcIiwgXCJtb250aHNcIiwgXCJ3ZWVrc1wiLCBcImRheXNcIiwgXCJob3Vyc1wiLCBcIm1pbnV0ZXNcIiwgb3IgXCJzZWNvbmRzXCJcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yb3VuZD10cnVlXSAtIHdoZXRoZXIgdG8gcm91bmQgdGhlIG51bWJlcnMgaW4gdGhlIG91dHB1dC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnBhZGRpbmc9MF0gLSBwYWRkaW5nIGluIG1pbGxpc2Vjb25kcy4gVGhpcyBhbGxvd3MgeW91IHRvIHJvdW5kIHVwIHRoZSByZXN1bHQgaWYgaXQgZml0cyBpbnNpZGUgdGhlIHRocmVzaG9sZC4gRG9uJ3QgdXNlIGluIGNvbWJpbmF0aW9uIHdpdGgge3JvdW5kOiBmYWxzZX0gYmVjYXVzZSB0aGUgZGVjaW1hbCBvdXRwdXQgd2lsbCBpbmNsdWRlIHRoZSBwYWRkaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5sb2NhbGUgLSBvdmVycmlkZSB0aGUgbG9jYWxlIG9mIHRoaXMgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubnVtYmVyaW5nU3lzdGVtIC0gb3ZlcnJpZGUgdGhlIG51bWJlcmluZ1N5c3RlbSBvZiB0aGlzIERhdGVUaW1lLiBUaGUgSW50bCBzeXN0ZW0gbWF5IGNob29zZSBub3QgdG8gaG9ub3IgdGhpc1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKHsgZGF5czogMSB9KS50b1JlbGF0aXZlKCkgLy89PiBcImluIDEgZGF5XCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkuc2V0TG9jYWxlKFwiZXNcIikudG9SZWxhdGl2ZSh7IGRheXM6IDEgfSkgLy89PiBcImRlbnRybyBkZSAxIGTDrWFcIlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKHsgZGF5czogMSB9KS50b1JlbGF0aXZlKHsgbG9jYWxlOiBcImZyXCIgfSkgLy89PiBcImRhbnMgMjMgaGV1cmVzXCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkubWludXMoeyBkYXlzOiAyIH0pLnRvUmVsYXRpdmUoKSAvLz0+IFwiMiBkYXlzIGFnb1wiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLm1pbnVzKHsgZGF5czogMiB9KS50b1JlbGF0aXZlKHsgdW5pdDogXCJob3Vyc1wiIH0pIC8vPT4gXCI0OCBob3VycyBhZ29cIlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5taW51cyh7IGhvdXJzOiAzNiB9KS50b1JlbGF0aXZlKHsgcm91bmQ6IGZhbHNlIH0pIC8vPT4gXCIxLjUgZGF5cyBhZ29cIlxuICAgKi9cbiAgdG9SZWxhdGl2ZShvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgYmFzZSA9IG9wdGlvbnMuYmFzZSB8fCBEYXRlVGltZS5mcm9tT2JqZWN0KHt9LCB7IHpvbmU6IHRoaXMuem9uZSB9KSxcbiAgICAgIHBhZGRpbmcgPSBvcHRpb25zLnBhZGRpbmcgPyAodGhpcyA8IGJhc2UgPyAtb3B0aW9ucy5wYWRkaW5nIDogb3B0aW9ucy5wYWRkaW5nKSA6IDA7XG4gICAgbGV0IHVuaXRzID0gW1wieWVhcnNcIiwgXCJtb250aHNcIiwgXCJkYXlzXCIsIFwiaG91cnNcIiwgXCJtaW51dGVzXCIsIFwic2Vjb25kc1wiXTtcbiAgICBsZXQgdW5pdCA9IG9wdGlvbnMudW5pdDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLnVuaXQpKSB7XG4gICAgICB1bml0cyA9IG9wdGlvbnMudW5pdDtcbiAgICAgIHVuaXQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBkaWZmUmVsYXRpdmUoYmFzZSwgdGhpcy5wbHVzKHBhZGRpbmcpLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgbnVtZXJpYzogXCJhbHdheXNcIixcbiAgICAgIHVuaXRzLFxuICAgICAgdW5pdCxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZGF0ZSByZWxhdGl2ZSB0byB0b2RheSwgc3VjaCBhcyBcInllc3RlcmRheVwiIG9yIFwibmV4dCBtb250aFwiLlxuICAgKiBPbmx5IGludGVybmF0aW9uYWxpemVzIG9uIHBsYXRmb3JtcyB0aGF0IHN1cHBvcnRzIEludGwuUmVsYXRpdmVUaW1lRm9ybWF0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgdGhhdCBhZmZlY3QgdGhlIG91dHB1dFxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBbb3B0aW9ucy5iYXNlPURhdGVUaW1lLm5vdygpXSAtIHRoZSBEYXRlVGltZSB0byB1c2UgYXMgdGhlIGJhc2lzIHRvIHdoaWNoIHRoaXMgdGltZSBpcyBjb21wYXJlZC4gRGVmYXVsdHMgdG8gbm93LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5sb2NhbGUgLSBvdmVycmlkZSB0aGUgbG9jYWxlIG9mIHRoaXMgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudW5pdCAtIHVzZSBhIHNwZWNpZmljIHVuaXQ7IGlmIG9taXR0ZWQsIHRoZSBtZXRob2Qgd2lsbCBwaWNrIHRoZSB1bml0LiBVc2Ugb25lIG9mIFwieWVhcnNcIiwgXCJxdWFydGVyc1wiLCBcIm1vbnRoc1wiLCBcIndlZWtzXCIsIG9yIFwiZGF5c1wiXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm51bWJlcmluZ1N5c3RlbSAtIG92ZXJyaWRlIHRoZSBudW1iZXJpbmdTeXN0ZW0gb2YgdGhpcyBEYXRlVGltZS4gVGhlIEludGwgc3lzdGVtIG1heSBjaG9vc2Ugbm90IHRvIGhvbm9yIHRoaXNcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IGRheXM6IDEgfSkudG9SZWxhdGl2ZUNhbGVuZGFyKCkgLy89PiBcInRvbW9ycm93XCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkuc2V0TG9jYWxlKFwiZXNcIikucGx1cyh7IGRheXM6IDEgfSkudG9SZWxhdGl2ZSgpIC8vPT4gXCJcIm1hw7FhbmFcIlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKHsgZGF5czogMSB9KS50b1JlbGF0aXZlQ2FsZW5kYXIoeyBsb2NhbGU6IFwiZnJcIiB9KSAvLz0+IFwiZGVtYWluXCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkubWludXMoeyBkYXlzOiAyIH0pLnRvUmVsYXRpdmVDYWxlbmRhcigpIC8vPT4gXCIyIGRheXMgYWdvXCJcbiAgICovXG4gIHRvUmVsYXRpdmVDYWxlbmRhcihvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIG51bGw7XG5cbiAgICByZXR1cm4gZGlmZlJlbGF0aXZlKG9wdGlvbnMuYmFzZSB8fCBEYXRlVGltZS5mcm9tT2JqZWN0KHt9LCB7IHpvbmU6IHRoaXMuem9uZSB9KSwgdGhpcywge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIG51bWVyaWM6IFwiYXV0b1wiLFxuICAgICAgdW5pdHM6IFtcInllYXJzXCIsIFwibW9udGhzXCIsIFwiZGF5c1wiXSxcbiAgICAgIGNhbGVuZGFyeTogdHJ1ZSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG1pbiBvZiBzZXZlcmFsIGRhdGUgdGltZXNcbiAgICogQHBhcmFtIHsuLi5EYXRlVGltZX0gZGF0ZVRpbWVzIC0gdGhlIERhdGVUaW1lcyBmcm9tIHdoaWNoIHRvIGNob29zZSB0aGUgbWluaW11bVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX0gdGhlIG1pbiBEYXRlVGltZSwgb3IgdW5kZWZpbmVkIGlmIGNhbGxlZCB3aXRoIG5vIGFyZ3VtZW50XG4gICAqL1xuICBzdGF0aWMgbWluKC4uLmRhdGVUaW1lcykge1xuICAgIGlmICghZGF0ZVRpbWVzLmV2ZXJ5KERhdGVUaW1lLmlzRGF0ZVRpbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJtaW4gcmVxdWlyZXMgYWxsIGFyZ3VtZW50cyBiZSBEYXRlVGltZXNcIik7XG4gICAgfVxuICAgIHJldHVybiBiZXN0QnkoZGF0ZVRpbWVzLCAoaSkgPT4gaS52YWx1ZU9mKCksIE1hdGgubWluKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG1heCBvZiBzZXZlcmFsIGRhdGUgdGltZXNcbiAgICogQHBhcmFtIHsuLi5EYXRlVGltZX0gZGF0ZVRpbWVzIC0gdGhlIERhdGVUaW1lcyBmcm9tIHdoaWNoIHRvIGNob29zZSB0aGUgbWF4aW11bVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX0gdGhlIG1heCBEYXRlVGltZSwgb3IgdW5kZWZpbmVkIGlmIGNhbGxlZCB3aXRoIG5vIGFyZ3VtZW50XG4gICAqL1xuICBzdGF0aWMgbWF4KC4uLmRhdGVUaW1lcykge1xuICAgIGlmICghZGF0ZVRpbWVzLmV2ZXJ5KERhdGVUaW1lLmlzRGF0ZVRpbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJtYXggcmVxdWlyZXMgYWxsIGFyZ3VtZW50cyBiZSBEYXRlVGltZXNcIik7XG4gICAgfVxuICAgIHJldHVybiBiZXN0QnkoZGF0ZVRpbWVzLCAoaSkgPT4gaS52YWx1ZU9mKCksIE1hdGgubWF4KTtcbiAgfVxuXG4gIC8vIE1JU0NcblxuICAvKipcbiAgICogRXhwbGFpbiBob3cgYSBzdHJpbmcgd291bGQgYmUgcGFyc2VkIGJ5IGZyb21Gb3JtYXQoKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZtdCAtIHRoZSBmb3JtYXQgdGhlIHN0cmluZyBpcyBleHBlY3RlZCB0byBiZSBpbiAoc2VlIGRlc2NyaXB0aW9uKVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgdGFrZW4gYnkgZnJvbUZvcm1hdCgpXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBmcm9tRm9ybWF0RXhwbGFpbih0ZXh0LCBmbXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgbG9jYWxlID0gbnVsbCwgbnVtYmVyaW5nU3lzdGVtID0gbnVsbCB9ID0gb3B0aW9ucyxcbiAgICAgIGxvY2FsZVRvVXNlID0gTG9jYWxlLmZyb21PcHRzKHtcbiAgICAgICAgbG9jYWxlLFxuICAgICAgICBudW1iZXJpbmdTeXN0ZW0sXG4gICAgICAgIGRlZmF1bHRUb0VOOiB0cnVlLFxuICAgICAgfSk7XG4gICAgcmV0dXJuIGV4cGxhaW5Gcm9tVG9rZW5zKGxvY2FsZVRvVXNlLCB0ZXh0LCBmbXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBmcm9tRm9ybWF0RXhwbGFpbiBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgZnJvbVN0cmluZ0V4cGxhaW4odGV4dCwgZm10LCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gRGF0ZVRpbWUuZnJvbUZvcm1hdEV4cGxhaW4odGV4dCwgZm10LCBvcHRpb25zKTtcbiAgfVxuXG4gIC8vIEZPUk1BVCBQUkVTRVRTXG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgMTAvMTQvMTk4M1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFX1NIT1JUKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVfU0hPUlQ7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnT2N0IDE0LCAxOTgzJ1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFX01FRCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFX01FRDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdGcmksIE9jdCAxNCwgMTk4MydcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURV9NRURfV0lUSF9XRUVLREFZKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVfTUVEX1dJVEhfV0VFS0RBWTtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdPY3RvYmVyIDE0LCAxOTgzJ1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFX0ZVTEwoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURV9GVUxMO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ1R1ZXNkYXksIE9jdG9iZXIgMTQsIDE5ODMnXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVfSFVHRSgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFX0hVR0U7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMDk6MzAgQU0nLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgVElNRV9TSU1QTEUoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuVElNRV9TSU1QTEU7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMDk6MzA6MjMgQU0nLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgVElNRV9XSVRIX1NFQ09ORFMoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuVElNRV9XSVRIX1NFQ09ORFM7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMDk6MzA6MjMgQU0gRURUJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFRJTUVfV0lUSF9TSE9SVF9PRkZTRVQoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuVElNRV9XSVRIX1NIT1JUX09GRlNFVDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMDoyMyBBTSBFYXN0ZXJuIERheWxpZ2h0IFRpbWUnLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgVElNRV9XSVRIX0xPTkdfT0ZGU0VUKCkge1xuICAgIHJldHVybiBGb3JtYXRzLlRJTUVfV0lUSF9MT05HX09GRlNFVDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMCcsIGFsd2F5cyAyNC1ob3VyLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FXzI0X1NJTVBMRSgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FXzI0X1NJTVBMRTtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMDoyMycsIGFsd2F5cyAyNC1ob3VyLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FXzI0X1dJVEhfU0VDT05EUygpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FXzI0X1dJVEhfU0VDT05EUztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMDoyMyBFRFQnLCBhbHdheXMgMjQtaG91ci5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgVElNRV8yNF9XSVRIX1NIT1JUX09GRlNFVCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FXzI0X1dJVEhfU0hPUlRfT0ZGU0VUO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwOjIzIEVhc3Rlcm4gRGF5bGlnaHQgVGltZScsIGFsd2F5cyAyNC1ob3VyLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FXzI0X1dJVEhfTE9OR19PRkZTRVQoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuVElNRV8yNF9XSVRIX0xPTkdfT0ZGU0VUO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzEwLzE0LzE5ODMsIDk6MzAgQU0nLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURVRJTUVfU0hPUlQoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfU0hPUlQ7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMTAvMTQvMTk4MywgOTozMDozMyBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9TSE9SVF9XSVRIX1NFQ09ORFMoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfU0hPUlRfV0lUSF9TRUNPTkRTO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ09jdCAxNCwgMTk4MywgOTozMCBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9NRUQoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfTUVEO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ09jdCAxNCwgMTk4MywgOTozMDozMyBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9NRURfV0lUSF9TRUNPTkRTKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVUSU1FX01FRF9XSVRIX1NFQ09ORFM7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnRnJpLCAxNCBPY3QgMTk4MywgOTozMCBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9NRURfV0lUSF9XRUVLREFZKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVUSU1FX01FRF9XSVRIX1dFRUtEQVk7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnT2N0b2JlciAxNCwgMTk4MywgOTozMCBBTSBFRFQnLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURVRJTUVfRlVMTCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9GVUxMO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ09jdG9iZXIgMTQsIDE5ODMsIDk6MzA6MzMgQU0gRURUJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX0ZVTExfV0lUSF9TRUNPTkRTKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVUSU1FX0ZVTExfV0lUSF9TRUNPTkRTO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ0ZyaWRheSwgT2N0b2JlciAxNCwgMTk4MywgOTozMCBBTSBFYXN0ZXJuIERheWxpZ2h0IFRpbWUnLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURVRJTUVfSFVHRSgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9IVUdFO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ0ZyaWRheSwgT2N0b2JlciAxNCwgMTk4MywgOTozMDozMyBBTSBFYXN0ZXJuIERheWxpZ2h0IFRpbWUnLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURVRJTUVfSFVHRV9XSVRIX1NFQ09ORFMoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfSFVHRV9XSVRIX1NFQ09ORFM7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJpZW5kbHlEYXRlVGltZShkYXRlVGltZWlzaCkge1xuICBpZiAoRGF0ZVRpbWUuaXNEYXRlVGltZShkYXRlVGltZWlzaCkpIHtcbiAgICByZXR1cm4gZGF0ZVRpbWVpc2g7XG4gIH0gZWxzZSBpZiAoZGF0ZVRpbWVpc2ggJiYgZGF0ZVRpbWVpc2gudmFsdWVPZiAmJiBpc051bWJlcihkYXRlVGltZWlzaC52YWx1ZU9mKCkpKSB7XG4gICAgcmV0dXJuIERhdGVUaW1lLmZyb21KU0RhdGUoZGF0ZVRpbWVpc2gpO1xuICB9IGVsc2UgaWYgKGRhdGVUaW1laXNoICYmIHR5cGVvZiBkYXRlVGltZWlzaCA9PT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBEYXRlVGltZS5mcm9tT2JqZWN0KGRhdGVUaW1laXNoKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXG4gICAgICBgVW5rbm93biBkYXRldGltZSBhcmd1bWVudDogJHtkYXRlVGltZWlzaH0sIG9mIHR5cGUgJHt0eXBlb2YgZGF0ZVRpbWVpc2h9YFxuICAgICk7XG4gIH1cbn1cbiIsICIvLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gUXVlcnkgU2V0dGluZ3MgLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmV4cG9ydCBpbnRlcmZhY2UgUXVlcnlTZXR0aW5ncyB7XG4gICAgLyoqIFdoYXQgdG8gcmVuZGVyICdudWxsJyBhcyBpbiB0YWJsZXMuIERlZmF1bHRzIHRvICctJy4gKi9cbiAgICByZW5kZXJOdWxsQXM6IHN0cmluZztcbiAgICAvKiogSWYgZW5hYmxlZCwgdGFza3MgaW4gRGF0YXZpZXcgdmlld3Mgd2lsbCBhdXRvbWF0aWNhbGx5IGhhdmUgdGhlaXIgY29tcGxldGlvbiBkYXRlIGFwcGVuZGVkIHdoZW4gdGhleSBhcmUgY2hlY2tlZC4gKi9cbiAgICB0YXNrQ29tcGxldGlvblRyYWNraW5nOiBib29sZWFuO1xuICAgIC8qKiBJZiBlbmFibGVkLCBhdXRvbWF0aWMgY29tcGxldGlvbnMgd2lsbCB1c2UgZW1vamkgc2hvcnRoYW5kIOKchSBZWVlZLU1NLUREIGluc3RlYWQgb2YgW2NvbXBsZXRpb246OiBkYXRlXS4gKi9cbiAgICB0YXNrQ29tcGxldGlvblVzZUVtb2ppU2hvcnRoYW5kOiBib29sZWFuO1xuICAgIC8qKiBUaGUgbmFtZSBvZiB0aGUgaW5saW5lIGZpZWxkIHRvIGJlIGFkZGVkIGFzIGEgdGFzaydzIGNvbXBsZXRpb24gd2hlbiBjaGVja2VkLiBPbmx5IHVzZWQgaWYgY29tcGxldGlvblRyYWNraW5nIGlzIGVuYWJsZWQgYW5kIGVtb2ppU2hvcnRoYW5kIGlzIG5vdC4gKi9cbiAgICB0YXNrQ29tcGxldGlvblRleHQ6IHN0cmluZztcbiAgICAvKiogRGF0ZSBmb3JtYXQgb2YgdGhlIHRhc2sncyBjb21wbGV0aW9uIHRpbWVzdGFtcC4gT25seSB1c2VkIGlmIGNvbXBsZXRpb25UcmFja2luZyBpcyBlbmFibGVkIGFuZCBlbW9qaVNob3J0aGFuZCBpcyBub3QuICovXG4gICAgdGFza0NvbXBsZXRpb25EYXRlRm9ybWF0OiBzdHJpbmc7XG4gICAgLyoqIFdoZXRoZXIgb3Igbm90IHN1YnRhc2tzIHNob3VsZCBiZSByZWN1cnNpdmVseSBjb21wbGV0ZWQgaW4gYWRkaXRpb24gdG8gdGhlaXIgcGFyZW50IHRhc2suICovXG4gICAgcmVjdXJzaXZlU3ViVGFza0NvbXBsZXRpb246IGJvb2xlYW47XG4gICAgLyoqIElmIHRydWUsIHJlbmRlciBhIG1vZGFsIHdoaWNoIHNob3dzIG5vIHJlc3VsdHMgd2VyZSByZXR1cm5lZC4gKi9cbiAgICB3YXJuT25FbXB0eVJlc3VsdDogYm9vbGVhbjtcbiAgICAvKiogV2hldGhlciBvciBub3QgYXV0b21hdGljIHZpZXcgcmVmcmVzaGluZyBpcyBlbmFibGVkLiAqL1xuICAgIHJlZnJlc2hFbmFibGVkOiBib29sZWFuO1xuICAgIC8qKiBUaGUgaW50ZXJ2YWwgdGhhdCB2aWV3cyBhcmUgcmVmcmVzaGVkLCBieSBkZWZhdWx0LiAqL1xuICAgIHJlZnJlc2hJbnRlcnZhbDogbnVtYmVyO1xuICAgIC8qKiBUaGUgZGVmYXVsdCBmb3JtYXQgdGhhdCBkYXRlcyBhcmUgcmVuZGVyZWQgaW4gKHVzaW5nIGx1eG9uJ3MgbW9tZW50LWxpa2UgZm9ybWF0dGluZykuICovXG4gICAgZGVmYXVsdERhdGVGb3JtYXQ6IHN0cmluZztcbiAgICAvKiogVGhlIGRlZmF1bHQgZm9ybWF0IHRoYXQgZGF0ZS10aW1lcyBhcmUgcmVuZGVyZWQgaW4gKHVzaW5nIGx1eG9ucyBtb21lbnQtbGlrZSBmb3JtYXR0aW5nKS4gKi9cbiAgICBkZWZhdWx0RGF0ZVRpbWVGb3JtYXQ6IHN0cmluZztcbiAgICAvKiogTWF4aW11bSBkZXB0aCB0aGF0IG9iamVjdHMgd2lsbCBiZSBleHBhbmRlZCB3aGVuIGJlaW5nIHJlbmRlcmVkIHJlY3Vyc2l2ZWx5LiAqL1xuICAgIG1heFJlY3Vyc2l2ZVJlbmRlckRlcHRoOiBudW1iZXI7XG4gICAgLyoqIFRoZSBuYW1lIG9mIHRoZSBkZWZhdWx0IElEIGZpZWxkICgnRmlsZScpLiAqL1xuICAgIHRhYmxlSWRDb2x1bW5OYW1lOiBzdHJpbmc7XG4gICAgLyoqIFRoZSBuYW1lIG9mIGRlZmF1bHQgSUQgZmllbGRzIG9uIGdyb3VwZWQgZGF0YSAoJ0dyb3VwJykuICovXG4gICAgdGFibGVHcm91cENvbHVtbk5hbWU6IHN0cmluZztcbiAgICAvKiogSW5jbHVkZSB0aGUgcmVzdWx0IGNvdW50IGFzIHBhcnQgb2YgdGhlIG91dHB1dC4gKi9cbiAgICBzaG93UmVzdWx0Q291bnQ6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX1FVRVJZX1NFVFRJTkdTOiBRdWVyeVNldHRpbmdzID0ge1xuICAgIHJlbmRlck51bGxBczogXCJcXFxcLVwiLFxuICAgIHRhc2tDb21wbGV0aW9uVHJhY2tpbmc6IGZhbHNlLFxuICAgIHRhc2tDb21wbGV0aW9uVXNlRW1vamlTaG9ydGhhbmQ6IGZhbHNlLFxuICAgIHRhc2tDb21wbGV0aW9uVGV4dDogXCJjb21wbGV0aW9uXCIsXG4gICAgdGFza0NvbXBsZXRpb25EYXRlRm9ybWF0OiBcInl5eXktTU0tZGRcIixcbiAgICByZWN1cnNpdmVTdWJUYXNrQ29tcGxldGlvbjogZmFsc2UsXG4gICAgd2Fybk9uRW1wdHlSZXN1bHQ6IHRydWUsXG4gICAgcmVmcmVzaEVuYWJsZWQ6IHRydWUsXG4gICAgcmVmcmVzaEludGVydmFsOiAyNTAwLFxuICAgIGRlZmF1bHREYXRlRm9ybWF0OiBcIk1NTU0gZGQsIHl5eXlcIixcbiAgICBkZWZhdWx0RGF0ZVRpbWVGb3JtYXQ6IFwiaDptbSBhIC0gTU1NTSBkZCwgeXl5eVwiLFxuICAgIG1heFJlY3Vyc2l2ZVJlbmRlckRlcHRoOiA0LFxuXG4gICAgdGFibGVJZENvbHVtbk5hbWU6IFwiRmlsZVwiLFxuICAgIHRhYmxlR3JvdXBDb2x1bW5OYW1lOiBcIkdyb3VwXCIsXG4gICAgc2hvd1Jlc3VsdENvdW50OiB0cnVlLFxufTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBFeHBvcnQgU2V0dGluZ3MgLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5leHBvcnQgaW50ZXJmYWNlIEV4cG9ydFNldHRpbmdzIHtcbiAgICAvKiogV2hldGhlciBvciBub3QgSFRNTCBzaG91bGQgYmUgdXNlZCBmb3IgZm9ybWF0dGluZyBpbiBleHBvcnRzLiAqL1xuICAgIGFsbG93SHRtbDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfRVhQT1JUX1NFVFRJTkdTOiBFeHBvcnRTZXR0aW5ncyA9IHtcbiAgICBhbGxvd0h0bWw6IHRydWUsXG59O1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBHZW5lcmFsIERhdGF2aWV3IFNldHRpbmdzIC8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0YXZpZXdTZXR0aW5ncyBleHRlbmRzIFF1ZXJ5U2V0dGluZ3MsIEV4cG9ydFNldHRpbmdzIHtcbiAgICAvKiogVGhlIHByZWZpeCBmb3IgaW5saW5lIHF1ZXJpZXMgYnkgZGVmYXVsdC4gKi9cbiAgICBpbmxpbmVRdWVyeVByZWZpeDogc3RyaW5nO1xuICAgIC8qKiBUaGUgcHJlZml4IGZvciBpbmxpbmUgSlMgcXVlcmllcyBieSBkZWZhdWx0LiAqL1xuICAgIGlubGluZUpzUXVlcnlQcmVmaXg6IHN0cmluZztcbiAgICAvKiogSWYgdHJ1ZSwgaW5saW5lIHF1ZXJpZXMgYXJlIGFsc28gZXZhbHVhdGVkIGluIGZ1bGwgY29kZWJsb2Nrcy4gKi9cbiAgICBpbmxpbmVRdWVyaWVzSW5Db2RlYmxvY2tzOiBib29sZWFuO1xuICAgIC8qKiBFbmFibGUgb3IgZGlzYWJsZSBleGVjdXRpbmcgRGF0YXZpZXdKUyBxdWVyaWVzLiAqL1xuICAgIGVuYWJsZURhdGF2aWV3SnM6IGJvb2xlYW47XG4gICAgLyoqIEVuYWJsZSBvciBkaXNhYmxlIHJlZ3VsYXIgaW5saW5lIHF1ZXJpZXMuICovXG4gICAgZW5hYmxlSW5saW5lRGF0YXZpZXc6IGJvb2xlYW47XG4gICAgLyoqIEVuYWJsZSBvciBkaXNhYmxlIGV4ZWN1dGluZyBpbmxpbmUgRGF0YXZpZXdKUyBxdWVyaWVzLiAqL1xuICAgIGVuYWJsZUlubGluZURhdGF2aWV3SnM6IGJvb2xlYW47XG4gICAgLyoqIEVuYWJsZSBvciBkaXNhYmxlIHJlbmRlcmluZyBpbmxpbmUgZmllbGRzIHByZXR0aWx5IGluIFJlYWRpbmcgVmlldy4gKi9cbiAgICBwcmV0dHlSZW5kZXJJbmxpbmVGaWVsZHM6IGJvb2xlYW47XG4gICAgLyoqIEVuYWJsZSBvciBkaXNhYmxlIHJlbmRlcmluZyBpbmxpbmUgZmllbGRzIHByZXR0aWx5IGluIExpdmUgUHJldmlldy4gKi9cbiAgICBwcmV0dHlSZW5kZXJJbmxpbmVGaWVsZHNJbkxpdmVQcmV2aWV3OiBib29sZWFuO1xuICAgIC8qKiBUaGUga2V5d29yZCBmb3IgRGF0YXZpZXdKUyBibG9ja3MuICovXG4gICAgZGF0YXZpZXdKc0tleXdvcmQ6IHN0cmluZztcbn1cblxuLyoqIERlZmF1bHQgc2V0dGluZ3MgZm9yIGRhdGF2aWV3IG9uIGluc3RhbGwuICovXG5leHBvcnQgY29uc3QgREVGQVVMVF9TRVRUSU5HUzogRGF0YXZpZXdTZXR0aW5ncyA9IHtcbiAgICAuLi5ERUZBVUxUX1FVRVJZX1NFVFRJTkdTLFxuICAgIC4uLkRFRkFVTFRfRVhQT1JUX1NFVFRJTkdTLFxuICAgIC4uLntcbiAgICAgICAgaW5saW5lUXVlcnlQcmVmaXg6IFwiPVwiLFxuICAgICAgICBpbmxpbmVKc1F1ZXJ5UHJlZml4OiBcIiQ9XCIsXG4gICAgICAgIGlubGluZVF1ZXJpZXNJbkNvZGVibG9ja3M6IHRydWUsXG4gICAgICAgIGVuYWJsZUlubGluZURhdGF2aWV3OiB0cnVlLFxuICAgICAgICBlbmFibGVEYXRhdmlld0pzOiBmYWxzZSxcbiAgICAgICAgZW5hYmxlSW5saW5lRGF0YXZpZXdKczogZmFsc2UsXG4gICAgICAgIHByZXR0eVJlbmRlcklubGluZUZpZWxkczogdHJ1ZSxcbiAgICAgICAgcHJldHR5UmVuZGVySW5saW5lRmllbGRzSW5MaXZlUHJldmlldzogdHJ1ZSxcbiAgICAgICAgZGF0YXZpZXdKc0tleXdvcmQ6IFwiZGF0YXZpZXdqc1wiLFxuICAgIH0sXG59O1xuIiwgIi8qKiBGdW5jdGlvbmFsIHJldHVybiB0eXBlIGZvciBlcnJvciBoYW5kbGluZy4gKi9cbmV4cG9ydCBjbGFzcyBTdWNjZXNzPFQsIEU+IHtcbiAgICBwdWJsaWMgc3VjY2Vzc2Z1bDogdHJ1ZTtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihwdWJsaWMgdmFsdWU6IFQpIHtcbiAgICAgICAgdGhpcy5zdWNjZXNzZnVsID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgbWFwPFU+KGY6IChhOiBUKSA9PiBVKTogUmVzdWx0PFUsIEU+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdWNjZXNzKGYodGhpcy52YWx1ZSkpO1xuICAgIH1cblxuICAgIHB1YmxpYyBmbGF0TWFwPFU+KGY6IChhOiBUKSA9PiBSZXN1bHQ8VSwgRT4pOiBSZXN1bHQ8VSwgRT4ge1xuICAgICAgICByZXR1cm4gZih0aGlzLnZhbHVlKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgbWFwRXJyPFU+KGY6IChlOiBFKSA9PiBVKTogUmVzdWx0PFQsIFU+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMgYXMgYW55IGFzIFJlc3VsdDxULCBVPjtcbiAgICB9XG5cbiAgICBwdWJsaWMgYmltYXA8VDIsIEUyPihzdWNjOiAoYTogVCkgPT4gVDIsIF9mYWlsOiAoYjogRSkgPT4gRTIpOiBSZXN1bHQ8VDIsIEUyPiB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcChzdWNjKSBhcyBhbnk7XG4gICAgfVxuXG4gICAgcHVibGljIG9yRWxzZShfdmFsdWU6IFQpOiBUIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuXG4gICAgcHVibGljIGNhc3Q8VT4oKTogUmVzdWx0PFUsIEU+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMgYXMgYW55O1xuICAgIH1cblxuICAgIHB1YmxpYyBvckVsc2VUaHJvdyhfbWVzc2FnZT86IChlOiBFKSA9PiBzdHJpbmcpOiBUIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxufVxuXG4vKiogRnVuY3Rpb25hbCByZXR1cm4gdHlwZSBmb3IgZXJyb3IgaGFuZGxpbmcuICovXG5leHBvcnQgY2xhc3MgRmFpbHVyZTxULCBFPiB7XG4gICAgcHVibGljIHN1Y2Nlc3NmdWw6IGZhbHNlO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKHB1YmxpYyBlcnJvcjogRSkge1xuICAgICAgICB0aGlzLnN1Y2Nlc3NmdWwgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgbWFwPFU+KF9mOiAoYTogVCkgPT4gVSk6IFJlc3VsdDxVLCBFPiB7XG4gICAgICAgIHJldHVybiB0aGlzIGFzIGFueSBhcyBGYWlsdXJlPFUsIEU+O1xuICAgIH1cblxuICAgIHB1YmxpYyBmbGF0TWFwPFU+KF9mOiAoYTogVCkgPT4gUmVzdWx0PFUsIEU+KTogUmVzdWx0PFUsIEU+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMgYXMgYW55IGFzIEZhaWx1cmU8VSwgRT47XG4gICAgfVxuXG4gICAgcHVibGljIG1hcEVycjxVPihmOiAoZTogRSkgPT4gVSk6IFJlc3VsdDxULCBVPiB7XG4gICAgICAgIHJldHVybiBuZXcgRmFpbHVyZShmKHRoaXMuZXJyb3IpKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYmltYXA8VDIsIEUyPihfc3VjYzogKGE6IFQpID0+IFQyLCBmYWlsOiAoYjogRSkgPT4gRTIpOiBSZXN1bHQ8VDIsIEUyPiB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcEVycihmYWlsKSBhcyBhbnk7XG4gICAgfVxuXG4gICAgcHVibGljIG9yRWxzZSh2YWx1ZTogVCk6IFQge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgcHVibGljIGNhc3Q8VT4oKTogUmVzdWx0PFUsIEU+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMgYXMgYW55O1xuICAgIH1cblxuICAgIHB1YmxpYyBvckVsc2VUaHJvdyhtZXNzYWdlPzogKGU6IEUpID0+IHN0cmluZyk6IFQge1xuICAgICAgICBpZiAobWVzc2FnZSkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UodGhpcy5lcnJvcikpO1xuICAgICAgICBlbHNlIHRocm93IG5ldyBFcnJvcihcIlwiICsgdGhpcy5lcnJvcik7XG4gICAgfVxufVxuXG5leHBvcnQgdHlwZSBSZXN1bHQ8VCwgRT4gPSBTdWNjZXNzPFQsIEU+IHwgRmFpbHVyZTxULCBFPjtcblxuLyoqIE1vbmFkaWMgJ1Jlc3VsdCcgdHlwZSB3aGljaCBlbmNhcHN1bGF0ZXMgd2hldGhlciBhIHByb2NlZHVyZSBzdWNjZWVkZWQgb3IgZmFpbGVkLCBhcyB3ZWxsIGFzIGl0J3MgcmV0dXJuIHZhbHVlLiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBSZXN1bHQge1xuICAgIC8qKiBDb25zdHJ1Y3QgYSBuZXcgc3VjY2VzcyByZXN1bHQgd3JhcHBpbmcgdGhlIGdpdmVuIHZhbHVlLiAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiBzdWNjZXNzPFQsIEU+KHZhbHVlOiBUKTogUmVzdWx0PFQsIEU+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdWNjZXNzKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKiogQ29uc3RydWN0IGEgbmV3IGZhaWx1cmUgdmFsdWUgd3JhcHBpbmcgdGhlIGdpdmVuIGVycm9yLiAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiBmYWlsdXJlPFQsIEU+KGVycm9yOiBFKTogUmVzdWx0PFQsIEU+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBGYWlsdXJlKGVycm9yKTtcbiAgICB9XG5cbiAgICAvKiogSm9pbiB0d28gcmVzdWx0cyB3aXRoIGEgYmktZnVuY3Rpb24gYW5kIHJldHVybiBhIG5ldyByZXN1bHQuICovXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGZsYXRNYXAyPFQxLCBUMiwgTywgRT4oXG4gICAgICAgIGZpcnN0OiBSZXN1bHQ8VDEsIEU+LFxuICAgICAgICBzZWNvbmQ6IFJlc3VsdDxUMiwgRT4sXG4gICAgICAgIGY6IChhOiBUMSwgYjogVDIpID0+IFJlc3VsdDxPLCBFPlxuICAgICk6IFJlc3VsdDxPLCBFPiB7XG4gICAgICAgIGlmIChmaXJzdC5zdWNjZXNzZnVsKSB7XG4gICAgICAgICAgICBpZiAoc2Vjb25kLnN1Y2Nlc3NmdWwpIHJldHVybiBmKGZpcnN0LnZhbHVlLCBzZWNvbmQudmFsdWUpO1xuICAgICAgICAgICAgZWxzZSByZXR1cm4gZmFpbHVyZShzZWNvbmQuZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhaWx1cmUoZmlyc3QuZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEpvaW4gdHdvIHJlc3VsdHMgd2l0aCBhIGJpLWZ1bmN0aW9uIGFuZCByZXR1cm4gYSBuZXcgcmVzdWx0LiAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiBtYXAyPFQxLCBUMiwgTywgRT4oXG4gICAgICAgIGZpcnN0OiBSZXN1bHQ8VDEsIEU+LFxuICAgICAgICBzZWNvbmQ6IFJlc3VsdDxUMiwgRT4sXG4gICAgICAgIGY6IChhOiBUMSwgYjogVDIpID0+IE9cbiAgICApOiBSZXN1bHQ8TywgRT4ge1xuICAgICAgICByZXR1cm4gZmxhdE1hcDIoZmlyc3QsIHNlY29uZCwgKGEsIGIpID0+IHN1Y2Nlc3MoZihhLCBiKSkpO1xuICAgIH1cbn1cbiIsICIhZnVuY3Rpb24obix0KXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz10KCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXSx0KTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzLlBhcnNpbW1vbj10KCk6bi5QYXJzaW1tb249dCgpfShcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZj9zZWxmOnRoaXMsZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24obil7dmFyIHQ9e307ZnVuY3Rpb24gcihlKXtpZih0W2VdKXJldHVybiB0W2VdLmV4cG9ydHM7dmFyIHU9dFtlXT17aTplLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIG5bZV0uY2FsbCh1LmV4cG9ydHMsdSx1LmV4cG9ydHMsciksdS5sPSEwLHUuZXhwb3J0c31yZXR1cm4gci5tPW4sci5jPXQsci5kPWZ1bmN0aW9uKG4sdCxlKXtyLm8obix0KXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sdCx7Y29uZmlndXJhYmxlOiExLGVudW1lcmFibGU6ITAsZ2V0OmV9KX0sci5yPWZ1bmN0aW9uKG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfSxyLm49ZnVuY3Rpb24obil7dmFyIHQ9biYmbi5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIG4uZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gbn07cmV0dXJuIHIuZCh0LFwiYVwiLHQpLHR9LHIubz1mdW5jdGlvbihuLHQpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobix0KX0sci5wPVwiXCIscihyLnM9MCl9KFtmdW5jdGlvbihuLHQscil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gZShuKXtpZighKHRoaXMgaW5zdGFuY2VvZiBlKSlyZXR1cm4gbmV3IGUobik7dGhpcy5fPW59dmFyIHU9ZS5wcm90b3R5cGU7ZnVuY3Rpb24gbyhuLHQpe2Zvcih2YXIgcj0wO3I8bjtyKyspdChyKX1mdW5jdGlvbiBpKG4sdCxyKXtyZXR1cm4gZnVuY3Rpb24obix0KXtvKHQubGVuZ3RoLGZ1bmN0aW9uKHIpe24odFtyXSxyLHQpfSl9KGZ1bmN0aW9uKHIsZSx1KXt0PW4odCxyLGUsdSl9LHIpLHR9ZnVuY3Rpb24gYShuLHQpe3JldHVybiBpKGZ1bmN0aW9uKHQscixlLHUpe3JldHVybiB0LmNvbmNhdChbbihyLGUsdSldKX0sW10sdCl9ZnVuY3Rpb24gZihuLHQpe3ZhciByPXt2OjAsYnVmOnR9O3JldHVybiBvKG4sZnVuY3Rpb24oKXt2YXIgbjtyPXt2OnIudjw8MXwobj1yLmJ1ZixuWzBdPj43KSxidWY6ZnVuY3Rpb24obil7dmFyIHQ9aShmdW5jdGlvbihuLHQscixlKXtyZXR1cm4gbi5jb25jYXQocj09PWUubGVuZ3RoLTE/QnVmZmVyLmZyb20oW3QsMF0pLnJlYWRVSW50MTZCRSgwKTplLnJlYWRVSW50MTZCRShyKSl9LFtdLG4pO3JldHVybiBCdWZmZXIuZnJvbShhKGZ1bmN0aW9uKG4pe3JldHVybihuPDwxJjY1NTM1KT4+OH0sdCkpfShyLmJ1Zil9fSkscn1mdW5jdGlvbiBjKCl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIEJ1ZmZlcn1mdW5jdGlvbiBzKCl7aWYoIWMoKSl0aHJvdyBuZXcgRXJyb3IoXCJCdWZmZXIgZ2xvYmFsIGRvZXMgbm90IGV4aXN0OyBwbGVhc2UgdXNlIHdlYnBhY2sgaWYgeW91IG5lZWQgdG8gcGFyc2UgQnVmZmVycyBpbiB0aGUgYnJvd3Nlci5cIil9ZnVuY3Rpb24gbChuKXtzKCk7dmFyIHQ9aShmdW5jdGlvbihuLHQpe3JldHVybiBuK3R9LDAsbik7aWYodCU4IT0wKXRocm93IG5ldyBFcnJvcihcIlRoZSBiaXRzIFtcIituLmpvaW4oXCIsIFwiKStcIl0gYWRkIHVwIHRvIFwiK3QrXCIgd2hpY2ggaXMgbm90IGFuIGV2ZW4gbnVtYmVyIG9mIGJ5dGVzOyB0aGUgdG90YWwgc2hvdWxkIGJlIGRpdmlzaWJsZSBieSA4XCIpO3ZhciByLHU9dC84LG89KHI9ZnVuY3Rpb24obil7cmV0dXJuIG4+NDh9LGkoZnVuY3Rpb24obix0KXtyZXR1cm4gbnx8KHIodCk/dDpuKX0sbnVsbCxuKSk7aWYobyl0aHJvdyBuZXcgRXJyb3IobytcIiBiaXQgcmFuZ2UgcmVxdWVzdGVkIGV4Y2VlZHMgNDggYml0ICg2IGJ5dGUpIE51bWJlciBtYXguXCIpO3JldHVybiBuZXcgZShmdW5jdGlvbih0LHIpe3ZhciBlPXUrcjtyZXR1cm4gZT50Lmxlbmd0aD94KHIsdS50b1N0cmluZygpK1wiIGJ5dGVzXCIpOmIoZSxpKGZ1bmN0aW9uKG4sdCl7dmFyIHI9Zih0LG4uYnVmKTtyZXR1cm57Y29sbDpuLmNvbGwuY29uY2F0KHIudiksYnVmOnIuYnVmfX0se2NvbGw6W10sYnVmOnQuc2xpY2UocixlKX0sbikuY29sbCl9KX1mdW5jdGlvbiBoKG4sdCl7cmV0dXJuIG5ldyBlKGZ1bmN0aW9uKHIsZSl7cmV0dXJuIHMoKSxlK3Q+ci5sZW5ndGg/eChlLHQrXCIgYnl0ZXMgZm9yIFwiK24pOmIoZSt0LHIuc2xpY2UoZSxlK3QpKX0pfWZ1bmN0aW9uIHAobix0KXtpZihcIm51bWJlclwiIT10eXBlb2Yocj10KXx8TWF0aC5mbG9vcihyKSE9PXJ8fHQ8MHx8dD42KXRocm93IG5ldyBFcnJvcihuK1wiIHJlcXVpcmVzIGludGVnZXIgbGVuZ3RoIGluIHJhbmdlIFswLCA2XS5cIik7dmFyIHJ9ZnVuY3Rpb24gZChuKXtyZXR1cm4gcChcInVpbnRCRVwiLG4pLGgoXCJ1aW50QkUoXCIrbitcIilcIixuKS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQucmVhZFVJbnRCRSgwLG4pfSl9ZnVuY3Rpb24gdihuKXtyZXR1cm4gcChcInVpbnRMRVwiLG4pLGgoXCJ1aW50TEUoXCIrbitcIilcIixuKS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQucmVhZFVJbnRMRSgwLG4pfSl9ZnVuY3Rpb24gZyhuKXtyZXR1cm4gcChcImludEJFXCIsbiksaChcImludEJFKFwiK24rXCIpXCIsbikubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnJlYWRJbnRCRSgwLG4pfSl9ZnVuY3Rpb24gbShuKXtyZXR1cm4gcChcImludExFXCIsbiksaChcImludExFKFwiK24rXCIpXCIsbikubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnJlYWRJbnRMRSgwLG4pfSl9ZnVuY3Rpb24geShuKXtyZXR1cm4gbiBpbnN0YW5jZW9mIGV9ZnVuY3Rpb24gRShuKXtyZXR1cm5cIltvYmplY3QgQXJyYXldXCI9PT17fS50b1N0cmluZy5jYWxsKG4pfWZ1bmN0aW9uIHcobil7cmV0dXJuIGMoKSYmQnVmZmVyLmlzQnVmZmVyKG4pfWZ1bmN0aW9uIGIobix0KXtyZXR1cm57c3RhdHVzOiEwLGluZGV4Om4sdmFsdWU6dCxmdXJ0aGVzdDotMSxleHBlY3RlZDpbXX19ZnVuY3Rpb24geChuLHQpe3JldHVybiBFKHQpfHwodD1bdF0pLHtzdGF0dXM6ITEsaW5kZXg6LTEsdmFsdWU6bnVsbCxmdXJ0aGVzdDpuLGV4cGVjdGVkOnR9fWZ1bmN0aW9uIEIobix0KXtpZighdClyZXR1cm4gbjtpZihuLmZ1cnRoZXN0PnQuZnVydGhlc3QpcmV0dXJuIG47dmFyIHI9bi5mdXJ0aGVzdD09PXQuZnVydGhlc3Q/ZnVuY3Rpb24obix0KXtpZihmdW5jdGlvbigpe2lmKHZvaWQgMCE9PWUuX3N1cHBvcnRzU2V0KXJldHVybiBlLl9zdXBwb3J0c1NldDt2YXIgbj1cInVuZGVmaW5lZFwiIT10eXBlb2YgU2V0O3JldHVybiBlLl9zdXBwb3J0c1NldD1uLG59KCkmJkFycmF5LmZyb20pe2Zvcih2YXIgcj1uZXcgU2V0KG4pLHU9MDt1PHQubGVuZ3RoO3UrKylyLmFkZCh0W3VdKTt2YXIgbz1BcnJheS5mcm9tKHIpO3JldHVybiBvLnNvcnQoKSxvfWZvcih2YXIgaT17fSxhPTA7YTxuLmxlbmd0aDthKyspaVtuW2FdXT0hMDtmb3IodmFyIGY9MDtmPHQubGVuZ3RoO2YrKylpW3RbZl1dPSEwO3ZhciBjPVtdO2Zvcih2YXIgcyBpbiBpKSh7fSkuaGFzT3duUHJvcGVydHkuY2FsbChpLHMpJiZjLnB1c2gocyk7cmV0dXJuIGMuc29ydCgpLGN9KG4uZXhwZWN0ZWQsdC5leHBlY3RlZCk6dC5leHBlY3RlZDtyZXR1cm57c3RhdHVzOm4uc3RhdHVzLGluZGV4Om4uaW5kZXgsdmFsdWU6bi52YWx1ZSxmdXJ0aGVzdDp0LmZ1cnRoZXN0LGV4cGVjdGVkOnJ9fXZhciBqPXt9O2Z1bmN0aW9uIFMobix0KXtpZih3KG4pKXJldHVybntvZmZzZXQ6dCxsaW5lOi0xLGNvbHVtbjotMX07biBpbiBqfHwoaltuXT17fSk7Zm9yKHZhciByPWpbbl0sZT0wLHU9MCxvPTAsaT10O2k+PTA7KXtpZihpIGluIHIpe2U9cltpXS5saW5lLDA9PT1vJiYobz1yW2ldLmxpbmVTdGFydCk7YnJlYWt9KFwiXFxuXCI9PT1uLmNoYXJBdChpKXx8XCJcXHJcIj09PW4uY2hhckF0KGkpJiZcIlxcblwiIT09bi5jaGFyQXQoaSsxKSkmJih1KyssMD09PW8mJihvPWkrMSkpLGktLX12YXIgYT1lK3UsZj10LW87cmV0dXJuIHJbdF09e2xpbmU6YSxsaW5lU3RhcnQ6b30se29mZnNldDp0LGxpbmU6YSsxLGNvbHVtbjpmKzF9fWZ1bmN0aW9uIF8obil7aWYoIXkobikpdGhyb3cgbmV3IEVycm9yKFwibm90IGEgcGFyc2VyOiBcIituKX1mdW5jdGlvbiBMKG4sdCl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIG4/bi5jaGFyQXQodCk6blt0XX1mdW5jdGlvbiBPKG4pe2lmKFwibnVtYmVyXCIhPXR5cGVvZiBuKXRocm93IG5ldyBFcnJvcihcIm5vdCBhIG51bWJlcjogXCIrbil9ZnVuY3Rpb24gayhuKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBuKXRocm93IG5ldyBFcnJvcihcIm5vdCBhIGZ1bmN0aW9uOiBcIituKX1mdW5jdGlvbiBQKG4pe2lmKFwic3RyaW5nXCIhPXR5cGVvZiBuKXRocm93IG5ldyBFcnJvcihcIm5vdCBhIHN0cmluZzogXCIrbil9dmFyIHE9MixBPTMsST04LEY9NSpJLE09NCpJLHo9XCIgIFwiO2Z1bmN0aW9uIFIobix0KXtyZXR1cm4gbmV3IEFycmF5KHQrMSkuam9pbihuKX1mdW5jdGlvbiBVKG4sdCxyKXt2YXIgZT10LW4ubGVuZ3RoO3JldHVybiBlPD0wP246UihyLGUpK259ZnVuY3Rpb24gVyhuLHQscixlKXtyZXR1cm57ZnJvbTpuLXQ+MD9uLXQ6MCx0bzpuK3I+ZT9lOm4rcn19ZnVuY3Rpb24gRChuLHQpe3ZhciByLGUsdSxvLGYsYz10LmluZGV4LHM9Yy5vZmZzZXQsbD0xO2lmKHM9PT1uLmxlbmd0aClyZXR1cm5cIkdvdCB0aGUgZW5kIG9mIHRoZSBpbnB1dFwiO2lmKHcobikpe3ZhciBoPXMtcyVJLHA9cy1oLGQ9VyhoLEYsTStJLG4ubGVuZ3RoKSx2PWEoZnVuY3Rpb24obil7cmV0dXJuIGEoZnVuY3Rpb24obil7cmV0dXJuIFUobi50b1N0cmluZygxNiksMixcIjBcIil9LG4pfSxmdW5jdGlvbihuLHQpe3ZhciByPW4ubGVuZ3RoLGU9W10sdT0wO2lmKHI8PXQpcmV0dXJuW24uc2xpY2UoKV07Zm9yKHZhciBvPTA7bzxyO28rKyllW3VdfHxlLnB1c2goW10pLGVbdV0ucHVzaChuW29dKSwobysxKSV0PT0wJiZ1Kys7cmV0dXJuIGV9KG4uc2xpY2UoZC5mcm9tLGQudG8pLnRvSlNPTigpLmRhdGEsSSkpO289ZnVuY3Rpb24obil7cmV0dXJuIDA9PT1uLmZyb20mJjE9PT1uLnRvP3tmcm9tOm4uZnJvbSx0bzpuLnRvfTp7ZnJvbTpuLmZyb20vSSx0bzpNYXRoLmZsb29yKG4udG8vSSl9fShkKSxlPWgvSSxyPTMqcCxwPj00JiYocis9MSksbD0yLHU9YShmdW5jdGlvbihuKXtyZXR1cm4gbi5sZW5ndGg8PTQ/bi5qb2luKFwiIFwiKTpuLnNsaWNlKDAsNCkuam9pbihcIiBcIikrXCIgIFwiK24uc2xpY2UoNCkuam9pbihcIiBcIil9LHYpLChmPSg4KihvLnRvPjA/by50by0xOm8udG8pKS50b1N0cmluZygxNikubGVuZ3RoKTwyJiYoZj0yKX1lbHNle3ZhciBnPW4uc3BsaXQoL1xcclxcbnxbXFxuXFxyXFx1MjAyOFxcdTIwMjldLyk7cj1jLmNvbHVtbi0xLGU9Yy5saW5lLTEsbz1XKGUscSxBLGcubGVuZ3RoKSx1PWcuc2xpY2Uoby5mcm9tLG8udG8pLGY9by50by50b1N0cmluZygpLmxlbmd0aH12YXIgbT1lLW8uZnJvbTtyZXR1cm4gdyhuKSYmKGY9KDgqKG8udG8+MD9vLnRvLTE6by50bykpLnRvU3RyaW5nKDE2KS5sZW5ndGgpPDImJihmPTIpLGkoZnVuY3Rpb24odCxlLHUpe3ZhciBpLGE9dT09PW0sYz1hP1wiPiBcIjp6O3JldHVybiBpPXcobik/VSgoOCooby5mcm9tK3UpKS50b1N0cmluZygxNiksZixcIjBcIik6VSgoby5mcm9tK3UrMSkudG9TdHJpbmcoKSxmLFwiIFwiKSxbXS5jb25jYXQodCxbYytpK1wiIHwgXCIrZV0sYT9beitSKFwiIFwiLGYpK1wiIHwgXCIrVShcIlwiLHIsXCIgXCIpK1IoXCJeXCIsbCldOltdKX0sW10sdSkuam9pbihcIlxcblwiKX1mdW5jdGlvbiBOKG4sdCl7cmV0dXJuW1wiXFxuXCIsXCItLSBQQVJTSU5HIEZBSUxFRCBcIitSKFwiLVwiLDUwKSxcIlxcblxcblwiLEQobix0KSxcIlxcblxcblwiLChyPXQuZXhwZWN0ZWQsMT09PXIubGVuZ3RoP1wiRXhwZWN0ZWQ6XFxuXFxuXCIrclswXTpcIkV4cGVjdGVkIG9uZSBvZiB0aGUgZm9sbG93aW5nOiBcXG5cXG5cIityLmpvaW4oXCIsIFwiKSksXCJcXG5cIl0uam9pbihcIlwiKTt2YXIgcn1mdW5jdGlvbiBHKG4pe3JldHVybiB2b2lkIDAhPT1uLmZsYWdzP24uZmxhZ3M6W24uZ2xvYmFsP1wiZ1wiOlwiXCIsbi5pZ25vcmVDYXNlP1wiaVwiOlwiXCIsbi5tdWx0aWxpbmU/XCJtXCI6XCJcIixuLnVuaWNvZGU/XCJ1XCI6XCJcIixuLnN0aWNreT9cInlcIjpcIlwiXS5qb2luKFwiXCIpfWZ1bmN0aW9uIEMoKXtmb3IodmFyIG49W10uc2xpY2UuY2FsbChhcmd1bWVudHMpLHQ9bi5sZW5ndGgscj0wO3I8dDtyKz0xKV8obltyXSk7cmV0dXJuIGUoZnVuY3Rpb24ocixlKXtmb3IodmFyIHUsbz1uZXcgQXJyYXkodCksaT0wO2k8dDtpKz0xKXtpZighKHU9QihuW2ldLl8ocixlKSx1KSkuc3RhdHVzKXJldHVybiB1O29baV09dS52YWx1ZSxlPXUuaW5kZXh9cmV0dXJuIEIoYihlLG8pLHUpfSl9ZnVuY3Rpb24gSigpe3ZhciBuPVtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtpZigwPT09bi5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic2VxTWFwIG5lZWRzIGF0IGxlYXN0IG9uZSBhcmd1bWVudFwiKTt2YXIgdD1uLnBvcCgpO3JldHVybiBrKHQpLEMuYXBwbHkobnVsbCxuKS5tYXAoZnVuY3Rpb24obil7cmV0dXJuIHQuYXBwbHkobnVsbCxuKX0pfWZ1bmN0aW9uIFQoKXt2YXIgbj1bXS5zbGljZS5jYWxsKGFyZ3VtZW50cyksdD1uLmxlbmd0aDtpZigwPT09dClyZXR1cm4gWShcInplcm8gYWx0ZXJuYXRlc1wiKTtmb3IodmFyIHI9MDtyPHQ7cis9MSlfKG5bcl0pO3JldHVybiBlKGZ1bmN0aW9uKHQscil7Zm9yKHZhciBlLHU9MDt1PG4ubGVuZ3RoO3UrPTEpaWYoKGU9QihuW3VdLl8odCxyKSxlKSkuc3RhdHVzKXJldHVybiBlO3JldHVybiBlfSl9ZnVuY3Rpb24gVihuLHQpe3JldHVybiBIKG4sdCkub3IoWChbXSkpfWZ1bmN0aW9uIEgobix0KXtyZXR1cm4gXyhuKSxfKHQpLEoobix0LnRoZW4obikubWFueSgpLGZ1bmN0aW9uKG4sdCl7cmV0dXJuW25dLmNvbmNhdCh0KX0pfWZ1bmN0aW9uIEsobil7UChuKTt2YXIgdD1cIidcIituK1wiJ1wiO3JldHVybiBlKGZ1bmN0aW9uKHIsZSl7dmFyIHU9ZStuLmxlbmd0aCxvPXIuc2xpY2UoZSx1KTtyZXR1cm4gbz09PW4/Yih1LG8pOngoZSx0KX0pfWZ1bmN0aW9uIFEobix0KXshZnVuY3Rpb24obil7aWYoIShuIGluc3RhbmNlb2YgUmVnRXhwKSl0aHJvdyBuZXcgRXJyb3IoXCJub3QgYSByZWdleHA6IFwiK24pO2Zvcih2YXIgdD1HKG4pLHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIGU9dC5jaGFyQXQocik7aWYoXCJpXCIhPT1lJiZcIm1cIiE9PWUmJlwidVwiIT09ZSYmXCJzXCIhPT1lKXRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgcmVnZXhwIGZsYWcgXCInK2UrJ1wiOiAnK24pfX0obiksYXJndW1lbnRzLmxlbmd0aD49Mj9PKHQpOnQ9MDt2YXIgcj1mdW5jdGlvbihuKXtyZXR1cm4gUmVnRXhwKFwiXig/OlwiK24uc291cmNlK1wiKVwiLEcobikpfShuKSx1PVwiXCIrbjtyZXR1cm4gZShmdW5jdGlvbihuLGUpe3ZhciBvPXIuZXhlYyhuLnNsaWNlKGUpKTtpZihvKXtpZigwPD10JiZ0PD1vLmxlbmd0aCl7dmFyIGk9b1swXSxhPW9bdF07cmV0dXJuIGIoZStpLmxlbmd0aCxhKX1yZXR1cm4geChlLFwidmFsaWQgbWF0Y2ggZ3JvdXAgKDAgdG8gXCIrby5sZW5ndGgrXCIpIGluIFwiK3UpfXJldHVybiB4KGUsdSl9KX1mdW5jdGlvbiBYKG4pe3JldHVybiBlKGZ1bmN0aW9uKHQscil7cmV0dXJuIGIocixuKX0pfWZ1bmN0aW9uIFkobil7cmV0dXJuIGUoZnVuY3Rpb24odCxyKXtyZXR1cm4geChyLG4pfSl9ZnVuY3Rpb24gWihuKXtpZih5KG4pKXJldHVybiBlKGZ1bmN0aW9uKHQscil7dmFyIGU9bi5fKHQscik7cmV0dXJuIGUuaW5kZXg9cixlLnZhbHVlPVwiXCIsZX0pO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBuKXJldHVybiBaKEsobikpO2lmKG4gaW5zdGFuY2VvZiBSZWdFeHApcmV0dXJuIFooUShuKSk7dGhyb3cgbmV3IEVycm9yKFwibm90IGEgc3RyaW5nLCByZWdleHAsIG9yIHBhcnNlcjogXCIrbil9ZnVuY3Rpb24gJChuKXtyZXR1cm4gXyhuKSxlKGZ1bmN0aW9uKHQscil7dmFyIGU9bi5fKHQsciksdT10LnNsaWNlKHIsZS5pbmRleCk7cmV0dXJuIGUuc3RhdHVzP3gociwnbm90IFwiJyt1KydcIicpOmIocixudWxsKX0pfWZ1bmN0aW9uIG5uKG4pe3JldHVybiBrKG4pLGUoZnVuY3Rpb24odCxyKXt2YXIgZT1MKHQscik7cmV0dXJuIHI8dC5sZW5ndGgmJm4oZSk/YihyKzEsZSk6eChyLFwiYSBjaGFyYWN0ZXIvYnl0ZSBtYXRjaGluZyBcIituKX0pfWZ1bmN0aW9uIHRuKG4sdCl7YXJndW1lbnRzLmxlbmd0aDwyJiYodD1uLG49dm9pZCAwKTt2YXIgcj1lKGZ1bmN0aW9uKG4sZSl7cmV0dXJuIHIuXz10KCkuXyxyLl8obixlKX0pO3JldHVybiBuP3IuZGVzYyhuKTpyfWZ1bmN0aW9uIHJuKCl7cmV0dXJuIFkoXCJmYW50YXN5LWxhbmQvZW1wdHlcIil9dS5wYXJzZT1mdW5jdGlvbihuKXtpZihcInN0cmluZ1wiIT10eXBlb2YgbiYmIXcobikpdGhyb3cgbmV3IEVycm9yKFwiLnBhcnNlIG11c3QgYmUgY2FsbGVkIHdpdGggYSBzdHJpbmcgb3IgQnVmZmVyIGFzIGl0cyBhcmd1bWVudFwiKTt2YXIgdCxyPXRoaXMuc2tpcChhbikuXyhuLDApO3JldHVybiB0PXIuc3RhdHVzP3tzdGF0dXM6ITAsdmFsdWU6ci52YWx1ZX06e3N0YXR1czohMSxpbmRleDpTKG4sci5mdXJ0aGVzdCksZXhwZWN0ZWQ6ci5leHBlY3RlZH0sZGVsZXRlIGpbbl0sdH0sdS50cnlQYXJzZT1mdW5jdGlvbihuKXt2YXIgdD10aGlzLnBhcnNlKG4pO2lmKHQuc3RhdHVzKXJldHVybiB0LnZhbHVlO3ZhciByPU4obix0KSxlPW5ldyBFcnJvcihyKTt0aHJvdyBlLnR5cGU9XCJQYXJzaW1tb25FcnJvclwiLGUucmVzdWx0PXQsZX0sdS5hc3NlcnQ9ZnVuY3Rpb24obix0KXtyZXR1cm4gdGhpcy5jaGFpbihmdW5jdGlvbihyKXtyZXR1cm4gbihyKT9YKHIpOlkodCl9KX0sdS5vcj1mdW5jdGlvbihuKXtyZXR1cm4gVCh0aGlzLG4pfSx1LnRyaW09ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMud3JhcChuLG4pfSx1LndyYXA9ZnVuY3Rpb24obix0KXtyZXR1cm4gSihuLHRoaXMsdCxmdW5jdGlvbihuLHQpe3JldHVybiB0fSl9LHUudGhydT1mdW5jdGlvbihuKXtyZXR1cm4gbih0aGlzKX0sdS50aGVuPWZ1bmN0aW9uKG4pe3JldHVybiBfKG4pLEModGhpcyxuKS5tYXAoZnVuY3Rpb24obil7cmV0dXJuIG5bMV19KX0sdS5tYW55PWZ1bmN0aW9uKCl7dmFyIG49dGhpcztyZXR1cm4gZShmdW5jdGlvbih0LHIpe2Zvcih2YXIgZT1bXSx1PXZvaWQgMDs7KXtpZighKHU9QihuLl8odCxyKSx1KSkuc3RhdHVzKXJldHVybiBCKGIocixlKSx1KTtpZihyPT09dS5pbmRleCl0aHJvdyBuZXcgRXJyb3IoXCJpbmZpbml0ZSBsb29wIGRldGVjdGVkIGluIC5tYW55KCkgcGFyc2VyIC0tLSBjYWxsaW5nIC5tYW55KCkgb24gYSBwYXJzZXIgd2hpY2ggY2FuIGFjY2VwdCB6ZXJvIGNoYXJhY3RlcnMgaXMgdXN1YWxseSB0aGUgY2F1c2VcIik7cj11LmluZGV4LGUucHVzaCh1LnZhbHVlKX19KX0sdS50aWVXaXRoPWZ1bmN0aW9uKG4pe3JldHVybiBQKG4pLHRoaXMubWFwKGZ1bmN0aW9uKHQpe2lmKGZ1bmN0aW9uKG4pe2lmKCFFKG4pKXRocm93IG5ldyBFcnJvcihcIm5vdCBhbiBhcnJheTogXCIrbil9KHQpLHQubGVuZ3RoKXtQKHRbMF0pO2Zvcih2YXIgcj10WzBdLGU9MTtlPHQubGVuZ3RoO2UrKylQKHRbZV0pLHIrPW4rdFtlXTtyZXR1cm4gcn1yZXR1cm5cIlwifSl9LHUudGllPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGllV2l0aChcIlwiKX0sdS50aW1lcz1mdW5jdGlvbihuLHQpe3ZhciByPXRoaXM7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg8MiYmKHQ9biksTyhuKSxPKHQpLGUoZnVuY3Rpb24oZSx1KXtmb3IodmFyIG89W10saT12b2lkIDAsYT12b2lkIDAsZj0wO2Y8bjtmKz0xKXtpZihhPUIoaT1yLl8oZSx1KSxhKSwhaS5zdGF0dXMpcmV0dXJuIGE7dT1pLmluZGV4LG8ucHVzaChpLnZhbHVlKX1mb3IoO2Y8dCYmKGE9QihpPXIuXyhlLHUpLGEpLGkuc3RhdHVzKTtmKz0xKXU9aS5pbmRleCxvLnB1c2goaS52YWx1ZSk7cmV0dXJuIEIoYih1LG8pLGEpfSl9LHUucmVzdWx0PWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLm1hcChmdW5jdGlvbigpe3JldHVybiBufSl9LHUuYXRNb3N0PWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLnRpbWVzKDAsbil9LHUuYXRMZWFzdD1mdW5jdGlvbihuKXtyZXR1cm4gSih0aGlzLnRpbWVzKG4pLHRoaXMubWFueSgpLGZ1bmN0aW9uKG4sdCl7cmV0dXJuIG4uY29uY2F0KHQpfSl9LHUubWFwPWZ1bmN0aW9uKG4pe2sobik7dmFyIHQ9dGhpcztyZXR1cm4gZShmdW5jdGlvbihyLGUpe3ZhciB1PXQuXyhyLGUpO3JldHVybiB1LnN0YXR1cz9CKGIodS5pbmRleCxuKHUudmFsdWUpKSx1KTp1fSl9LHUuY29udHJhbWFwPWZ1bmN0aW9uKG4pe2sobik7dmFyIHQ9dGhpcztyZXR1cm4gZShmdW5jdGlvbihyLGUpe3ZhciB1PXQucGFyc2UobihyLnNsaWNlKGUpKSk7cmV0dXJuIHUuc3RhdHVzP2IoZStyLmxlbmd0aCx1LnZhbHVlKTp1fSl9LHUucHJvbWFwPWZ1bmN0aW9uKG4sdCl7cmV0dXJuIGsobiksayh0KSx0aGlzLmNvbnRyYW1hcChuKS5tYXAodCl9LHUuc2tpcD1mdW5jdGlvbihuKXtyZXR1cm4gQyh0aGlzLG4pLm1hcChmdW5jdGlvbihuKXtyZXR1cm4gblswXX0pfSx1Lm1hcms9ZnVuY3Rpb24oKXtyZXR1cm4gSihlbix0aGlzLGVuLGZ1bmN0aW9uKG4sdCxyKXtyZXR1cm57c3RhcnQ6bix2YWx1ZTp0LGVuZDpyfX0pfSx1Lm5vZGU9ZnVuY3Rpb24obil7cmV0dXJuIEooZW4sdGhpcyxlbixmdW5jdGlvbih0LHIsZSl7cmV0dXJue25hbWU6bix2YWx1ZTpyLHN0YXJ0OnQsZW5kOmV9fSl9LHUuc2VwQnk9ZnVuY3Rpb24obil7cmV0dXJuIFYodGhpcyxuKX0sdS5zZXBCeTE9ZnVuY3Rpb24obil7cmV0dXJuIEgodGhpcyxuKX0sdS5sb29rYWhlYWQ9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuc2tpcChaKG4pKX0sdS5ub3RGb2xsb3dlZEJ5PWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLnNraXAoJChuKSl9LHUuZGVzYz1mdW5jdGlvbihuKXtFKG4pfHwobj1bbl0pO3ZhciB0PXRoaXM7cmV0dXJuIGUoZnVuY3Rpb24ocixlKXt2YXIgdT10Ll8ocixlKTtyZXR1cm4gdS5zdGF0dXN8fCh1LmV4cGVjdGVkPW4pLHV9KX0sdS5mYWxsYmFjaz1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5vcihYKG4pKX0sdS5hcD1mdW5jdGlvbihuKXtyZXR1cm4gSihuLHRoaXMsZnVuY3Rpb24obix0KXtyZXR1cm4gbih0KX0pfSx1LmNoYWluPWZ1bmN0aW9uKG4pe3ZhciB0PXRoaXM7cmV0dXJuIGUoZnVuY3Rpb24ocixlKXt2YXIgdT10Ll8ocixlKTtyZXR1cm4gdS5zdGF0dXM/QihuKHUudmFsdWUpLl8ocix1LmluZGV4KSx1KTp1fSl9LHUuY29uY2F0PXUub3IsdS5lbXB0eT1ybix1Lm9mPVgsdVtcImZhbnRhc3ktbGFuZC9hcFwiXT11LmFwLHVbXCJmYW50YXN5LWxhbmQvY2hhaW5cIl09dS5jaGFpbix1W1wiZmFudGFzeS1sYW5kL2NvbmNhdFwiXT11LmNvbmNhdCx1W1wiZmFudGFzeS1sYW5kL2VtcHR5XCJdPXUuZW1wdHksdVtcImZhbnRhc3ktbGFuZC9vZlwiXT11Lm9mLHVbXCJmYW50YXN5LWxhbmQvbWFwXCJdPXUubWFwO3ZhciBlbj1lKGZ1bmN0aW9uKG4sdCl7cmV0dXJuIGIodCxTKG4sdCkpfSksdW49ZShmdW5jdGlvbihuLHQpe3JldHVybiB0Pj1uLmxlbmd0aD94KHQsXCJhbnkgY2hhcmFjdGVyL2J5dGVcIik6Yih0KzEsTChuLHQpKX0pLG9uPWUoZnVuY3Rpb24obix0KXtyZXR1cm4gYihuLmxlbmd0aCxuLnNsaWNlKHQpKX0pLGFuPWUoZnVuY3Rpb24obix0KXtyZXR1cm4gdDxuLmxlbmd0aD94KHQsXCJFT0ZcIik6Yih0LG51bGwpfSksZm49USgvWzAtOV0vKS5kZXNjKFwiYSBkaWdpdFwiKSxjbj1RKC9bMC05XSovKS5kZXNjKFwib3B0aW9uYWwgZGlnaXRzXCIpLHNuPVEoL1thLXpdL2kpLmRlc2MoXCJhIGxldHRlclwiKSxsbj1RKC9bYS16XSovaSkuZGVzYyhcIm9wdGlvbmFsIGxldHRlcnNcIiksaG49USgvXFxzKi8pLmRlc2MoXCJvcHRpb25hbCB3aGl0ZXNwYWNlXCIpLHBuPVEoL1xccysvKS5kZXNjKFwid2hpdGVzcGFjZVwiKSxkbj1LKFwiXFxyXCIpLHZuPUsoXCJcXG5cIiksZ249SyhcIlxcclxcblwiKSxtbj1UKGduLHZuLGRuKS5kZXNjKFwibmV3bGluZVwiKSx5bj1UKG1uLGFuKTtlLmFsbD1vbixlLmFsdD1ULGUuYW55PXVuLGUuY3I9ZG4sZS5jcmVhdGVMYW5ndWFnZT1mdW5jdGlvbihuKXt2YXIgdD17fTtmb3IodmFyIHIgaW4gbikoe30pLmhhc093blByb3BlcnR5LmNhbGwobixyKSYmZnVuY3Rpb24ocil7dFtyXT10bihmdW5jdGlvbigpe3JldHVybiBuW3JdKHQpfSl9KHIpO3JldHVybiB0fSxlLmNybGY9Z24sZS5jdXN0b209ZnVuY3Rpb24obil7cmV0dXJuIGUobihiLHgpKX0sZS5kaWdpdD1mbixlLmRpZ2l0cz1jbixlLmVtcHR5PXJuLGUuZW5kPXluLGUuZW9mPWFuLGUuZmFpbD1ZLGUuZm9ybWF0RXJyb3I9TixlLmluZGV4PWVuLGUuaXNQYXJzZXI9eSxlLmxhenk9dG4sZS5sZXR0ZXI9c24sZS5sZXR0ZXJzPWxuLGUubGY9dm4sZS5sb29rYWhlYWQ9WixlLm1ha2VGYWlsdXJlPXgsZS5tYWtlU3VjY2Vzcz1iLGUubmV3bGluZT1tbixlLm5vbmVPZj1mdW5jdGlvbihuKXtyZXR1cm4gbm4oZnVuY3Rpb24odCl7cmV0dXJuIG4uaW5kZXhPZih0KTwwfSkuZGVzYyhcIm5vbmUgb2YgJ1wiK24rXCInXCIpfSxlLm5vdEZvbGxvd2VkQnk9JCxlLm9mPVgsZS5vbmVPZj1mdW5jdGlvbihuKXtmb3IodmFyIHQ9bi5zcGxpdChcIlwiKSxyPTA7cjx0Lmxlbmd0aDtyKyspdFtyXT1cIidcIit0W3JdK1wiJ1wiO3JldHVybiBubihmdW5jdGlvbih0KXtyZXR1cm4gbi5pbmRleE9mKHQpPj0wfSkuZGVzYyh0KX0sZS5vcHRXaGl0ZXNwYWNlPWhuLGUuUGFyc2VyPWUsZS5yYW5nZT1mdW5jdGlvbihuLHQpe3JldHVybiBubihmdW5jdGlvbihyKXtyZXR1cm4gbjw9ciYmcjw9dH0pLmRlc2MobitcIi1cIit0KX0sZS5yZWdleD1RLGUucmVnZXhwPVEsZS5zZXBCeT1WLGUuc2VwQnkxPUgsZS5zZXE9QyxlLnNlcU1hcD1KLGUuc2VxT2JqPWZ1bmN0aW9uKCl7Zm9yKHZhciBuLHQ9e30scj0wLHU9KG49YXJndW1lbnRzLEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG4pKSxvPXUubGVuZ3RoLGk9MDtpPG87aSs9MSl7dmFyIGE9dVtpXTtpZigheShhKSl7aWYoRShhKSYmMj09PWEubGVuZ3RoJiZcInN0cmluZ1wiPT10eXBlb2YgYVswXSYmeShhWzFdKSl7dmFyIGY9YVswXTtpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxmKSl0aHJvdyBuZXcgRXJyb3IoXCJzZXFPYmo6IGR1cGxpY2F0ZSBrZXkgXCIrZik7dFtmXT0hMCxyKys7Y29udGludWV9dGhyb3cgbmV3IEVycm9yKFwic2VxT2JqIGFyZ3VtZW50cyBtdXN0IGJlIHBhcnNlcnMgb3IgW3N0cmluZywgcGFyc2VyXSBhcnJheSBwYWlycy5cIil9fWlmKDA9PT1yKXRocm93IG5ldyBFcnJvcihcInNlcU9iaiBleHBlY3RzIGF0IGxlYXN0IG9uZSBuYW1lZCBwYXJzZXIsIGZvdW5kIHplcm9cIik7cmV0dXJuIGUoZnVuY3Rpb24obix0KXtmb3IodmFyIHIsZT17fSxpPTA7aTxvO2krPTEpe3ZhciBhLGY7aWYoRSh1W2ldKT8oYT11W2ldWzBdLGY9dVtpXVsxXSk6KGE9bnVsbCxmPXVbaV0pLCEocj1CKGYuXyhuLHQpLHIpKS5zdGF0dXMpcmV0dXJuIHI7YSYmKGVbYV09ci52YWx1ZSksdD1yLmluZGV4fXJldHVybiBCKGIodCxlKSxyKX0pfSxlLnN0cmluZz1LLGUuc3VjY2VlZD1YLGUudGFrZVdoaWxlPWZ1bmN0aW9uKG4pe3JldHVybiBrKG4pLGUoZnVuY3Rpb24odCxyKXtmb3IodmFyIGU9cjtlPHQubGVuZ3RoJiZuKEwodCxlKSk7KWUrKztyZXR1cm4gYihlLHQuc2xpY2UocixlKSl9KX0sZS50ZXN0PW5uLGUud2hpdGVzcGFjZT1wbixlW1wiZmFudGFzeS1sYW5kL2VtcHR5XCJdPXJuLGVbXCJmYW50YXN5LWxhbmQvb2ZcIl09WCxlLkJpbmFyeT17Yml0U2VxOmwsYml0U2VxT2JqOmZ1bmN0aW9uKG4pe3MoKTt2YXIgdD17fSxyPTAsZT1hKGZ1bmN0aW9uKG4pe2lmKEUobikpe3ZhciBlPW47aWYoMiE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIltcIitlLmpvaW4oXCIsIFwiKStcIl0gc2hvdWxkIGJlIGxlbmd0aCAyLCBnb3QgbGVuZ3RoIFwiK2UubGVuZ3RoKTtpZihQKGVbMF0pLE8oZVsxXSksT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsZVswXSkpdGhyb3cgbmV3IEVycm9yKFwiZHVwbGljYXRlIGtleSBpbiBiaXRTZXFPYmo6IFwiK2VbMF0pO3JldHVybiB0W2VbMF1dPSEwLHIrKyxlfXJldHVybiBPKG4pLFtudWxsLG5dfSxuKTtpZihyPDEpdGhyb3cgbmV3IEVycm9yKFwiYml0U2VxT2JqIGV4cGVjdHMgYXQgbGVhc3Qgb25lIG5hbWVkIHBhaXIsIGdvdCBbXCIrbi5qb2luKFwiLCBcIikrXCJdXCIpO3ZhciB1PWEoZnVuY3Rpb24obil7cmV0dXJuIG5bMF19LGUpO3JldHVybiBsKGEoZnVuY3Rpb24obil7cmV0dXJuIG5bMV19LGUpKS5tYXAoZnVuY3Rpb24obil7cmV0dXJuIGkoZnVuY3Rpb24obix0KXtyZXR1cm4gbnVsbCE9PXRbMF0mJihuW3RbMF1dPXRbMV0pLG59LHt9LGEoZnVuY3Rpb24odCxyKXtyZXR1cm5bdCxuW3JdXX0sdSkpfSl9LGJ5dGU6ZnVuY3Rpb24obil7aWYocygpLE8obiksbj4yNTUpdGhyb3cgbmV3IEVycm9yKFwiVmFsdWUgc3BlY2lmaWVkIHRvIGJ5dGUgY29uc3RydWN0b3IgKFwiK24rXCI9MHhcIituLnRvU3RyaW5nKDE2KStcIikgaXMgbGFyZ2VyIGluIHZhbHVlIHRoYW4gYSBzaW5nbGUgYnl0ZS5cIik7dmFyIHQ9KG4+MTU/XCIweFwiOlwiMHgwXCIpK24udG9TdHJpbmcoMTYpO3JldHVybiBlKGZ1bmN0aW9uKHIsZSl7dmFyIHU9TChyLGUpO3JldHVybiB1PT09bj9iKGUrMSx1KTp4KGUsdCl9KX0sYnVmZmVyOmZ1bmN0aW9uKG4pe3JldHVybiBoKFwiYnVmZmVyXCIsbikubWFwKGZ1bmN0aW9uKG4pe3JldHVybiBCdWZmZXIuZnJvbShuKX0pfSxlbmNvZGVkU3RyaW5nOmZ1bmN0aW9uKG4sdCl7cmV0dXJuIGgoXCJzdHJpbmdcIix0KS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQudG9TdHJpbmcobil9KX0sdWludEJFOmQsdWludDhCRTpkKDEpLHVpbnQxNkJFOmQoMiksdWludDMyQkU6ZCg0KSx1aW50TEU6dix1aW50OExFOnYoMSksdWludDE2TEU6digyKSx1aW50MzJMRTp2KDQpLGludEJFOmcsaW50OEJFOmcoMSksaW50MTZCRTpnKDIpLGludDMyQkU6Zyg0KSxpbnRMRTptLGludDhMRTptKDEpLGludDE2TEU6bSgyKSxpbnQzMkxFOm0oNCksZmxvYXRCRTpoKFwiZmxvYXRCRVwiLDQpLm1hcChmdW5jdGlvbihuKXtyZXR1cm4gbi5yZWFkRmxvYXRCRSgwKX0pLGZsb2F0TEU6aChcImZsb2F0TEVcIiw0KS5tYXAoZnVuY3Rpb24obil7cmV0dXJuIG4ucmVhZEZsb2F0TEUoMCl9KSxkb3VibGVCRTpoKFwiZG91YmxlQkVcIiw4KS5tYXAoZnVuY3Rpb24obil7cmV0dXJuIG4ucmVhZERvdWJsZUJFKDApfSksZG91YmxlTEU6aChcImRvdWJsZUxFXCIsOCkubWFwKGZ1bmN0aW9uKG4pe3JldHVybiBuLnJlYWREb3VibGVMRSgwKX0pfSxuLmV4cG9ydHM9ZX1dKX0pOyIsICJleHBvcnQgZGVmYXVsdCAoKSA9PiB7XG5cdC8vIGh0dHBzOi8vbXRocy5iZS9lbW9qaVxuXHRyZXR1cm4gL1sjKjAtOV1cXHVGRTBGP1xcdTIwRTN8W1xceEE5XFx4QUVcXHUyMDNDXFx1MjA0OVxcdTIxMjJcXHUyMTM5XFx1MjE5NC1cXHUyMTk5XFx1MjFBOVxcdTIxQUFcXHUyMzFBXFx1MjMxQlxcdTIzMjhcXHUyM0NGXFx1MjNFRC1cXHUyM0VGXFx1MjNGMVxcdTIzRjJcXHUyM0Y4LVxcdTIzRkFcXHUyNEMyXFx1MjVBQVxcdTI1QUJcXHUyNUI2XFx1MjVDMFxcdTI1RkJcXHUyNUZDXFx1MjVGRVxcdTI2MDAtXFx1MjYwNFxcdTI2MEVcXHUyNjExXFx1MjYxNFxcdTI2MTVcXHUyNjE4XFx1MjYyMFxcdTI2MjJcXHUyNjIzXFx1MjYyNlxcdTI2MkFcXHUyNjJFXFx1MjYyRlxcdTI2MzgtXFx1MjYzQVxcdTI2NDBcXHUyNjQyXFx1MjY0OC1cXHUyNjUzXFx1MjY1RlxcdTI2NjBcXHUyNjYzXFx1MjY2NVxcdTI2NjZcXHUyNjY4XFx1MjY3QlxcdTI2N0VcXHUyNjdGXFx1MjY5MlxcdTI2OTQtXFx1MjY5N1xcdTI2OTlcXHUyNjlCXFx1MjY5Q1xcdTI2QTBcXHUyNkE3XFx1MjZBQVxcdTI2QjBcXHUyNkIxXFx1MjZCRFxcdTI2QkVcXHUyNkM0XFx1MjZDOFxcdTI2Q0ZcXHUyNkQxXFx1MjZEM1xcdTI2RTlcXHUyNkYwLVxcdTI2RjVcXHUyNkY3XFx1MjZGOFxcdTI2RkFcXHUyNzAyXFx1MjcwOFxcdTI3MDlcXHUyNzBGXFx1MjcxMlxcdTI3MTRcXHUyNzE2XFx1MjcxRFxcdTI3MjFcXHUyNzMzXFx1MjczNFxcdTI3NDRcXHUyNzQ3XFx1Mjc1N1xcdTI3NjNcXHUyN0ExXFx1MjkzNFxcdTI5MzVcXHUyQjA1LVxcdTJCMDdcXHUyQjFCXFx1MkIxQ1xcdTJCNTVcXHUzMDMwXFx1MzAzRFxcdTMyOTdcXHUzMjk5XVxcdUZFMEY/fFtcXHUyNjFEXFx1MjcwQ1xcdTI3MERdKD86XFx1RkUwRnxcXHVEODNDW1xcdURGRkItXFx1REZGRl0pP3xbXFx1MjcwQVxcdTI3MEJdKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKT98W1xcdTIzRTktXFx1MjNFQ1xcdTIzRjBcXHUyM0YzXFx1MjVGRFxcdTI2OTNcXHUyNkExXFx1MjZBQlxcdTI2QzVcXHUyNkNFXFx1MjZENFxcdTI2RUFcXHUyNkZEXFx1MjcwNVxcdTI3MjhcXHUyNzRDXFx1Mjc0RVxcdTI3NTMtXFx1Mjc1NVxcdTI3OTUtXFx1Mjc5N1xcdTI3QjBcXHUyN0JGXFx1MkI1MF18XFx1MjZGOSg/OlxcdUZFMEZ8XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKT8oPzpcXHUyMDBEW1xcdTI2NDBcXHUyNjQyXVxcdUZFMEY/KT98XFx1Mjc2NFxcdUZFMEY/KD86XFx1MjAwRCg/OlxcdUQ4M0RcXHVERDI1fFxcdUQ4M0VcXHVERTc5KSk/fFxcdUQ4M0MoPzpbXFx1REMwNFxcdURENzBcXHVERDcxXFx1REQ3RVxcdUREN0ZcXHVERTAyXFx1REUzN1xcdURGMjFcXHVERjI0LVxcdURGMkNcXHVERjM2XFx1REY3RFxcdURGOTZcXHVERjk3XFx1REY5OS1cXHVERjlCXFx1REY5RVxcdURGOUZcXHVERkNEXFx1REZDRVxcdURGRDQtXFx1REZERlxcdURGRjVcXHVERkY3XVxcdUZFMEY/fFtcXHVERjg1XFx1REZDMlxcdURGQzddKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKT98W1xcdURGQzNcXHVERkM0XFx1REZDQV0oPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pPyg/OlxcdTIwMERbXFx1MjY0MFxcdTI2NDJdXFx1RkUwRj8pP3xbXFx1REZDQlxcdURGQ0NdKD86XFx1RkUwRnxcXHVEODNDW1xcdURGRkItXFx1REZGRl0pPyg/OlxcdTIwMERbXFx1MjY0MFxcdTI2NDJdXFx1RkUwRj8pP3xbXFx1RENDRlxcdUREOEVcXHVERDkxLVxcdUREOUFcXHVERTAxXFx1REUxQVxcdURFMkZcXHVERTMyLVxcdURFMzZcXHVERTM4LVxcdURFM0FcXHVERTUwXFx1REU1MVxcdURGMDAtXFx1REYyMFxcdURGMkQtXFx1REYzNVxcdURGMzctXFx1REY3Q1xcdURGN0UtXFx1REY4NFxcdURGODYtXFx1REY5M1xcdURGQTAtXFx1REZDMVxcdURGQzVcXHVERkM2XFx1REZDOFxcdURGQzlcXHVERkNGLVxcdURGRDNcXHVERkUwLVxcdURGRjBcXHVERkY4LVxcdURGRkZdfFxcdURERTZcXHVEODNDW1xcdURERTgtXFx1RERFQ1xcdURERUVcXHVEREYxXFx1RERGMlxcdURERjRcXHVEREY2LVxcdURERkFcXHVEREZDXFx1RERGRFxcdURERkZdfFxcdURERTdcXHVEODNDW1xcdURERTZcXHVEREU3XFx1RERFOS1cXHVEREVGXFx1RERGMS1cXHVEREY0XFx1RERGNi1cXHVEREY5XFx1RERGQlxcdURERkNcXHVEREZFXFx1RERGRl18XFx1RERFOFxcdUQ4M0NbXFx1RERFNlxcdURERThcXHVEREU5XFx1RERFQi1cXHVEREVFXFx1RERGMC1cXHVEREY1XFx1RERGN1xcdURERkEtXFx1RERGRl18XFx1RERFOVxcdUQ4M0NbXFx1RERFQVxcdURERUNcXHVEREVGXFx1RERGMFxcdURERjJcXHVEREY0XFx1RERGRl18XFx1RERFQVxcdUQ4M0NbXFx1RERFNlxcdURERThcXHVEREVBXFx1RERFQ1xcdURERURcXHVEREY3LVxcdURERkFdfFxcdURERUJcXHVEODNDW1xcdURERUUtXFx1RERGMFxcdURERjJcXHVEREY0XFx1RERGN118XFx1RERFQ1xcdUQ4M0NbXFx1RERFNlxcdURERTdcXHVEREU5LVxcdURERUVcXHVEREYxLVxcdURERjNcXHVEREY1LVxcdURERkFcXHVEREZDXFx1RERGRV18XFx1RERFRFxcdUQ4M0NbXFx1RERGMFxcdURERjJcXHVEREYzXFx1RERGN1xcdURERjlcXHVEREZBXXxcXHVEREVFXFx1RDgzQ1tcXHVEREU4LVxcdURERUFcXHVEREYxLVxcdURERjRcXHVEREY2LVxcdURERjldfFxcdURERUZcXHVEODNDW1xcdURERUFcXHVEREYyXFx1RERGNFxcdURERjVdfFxcdURERjBcXHVEODNDW1xcdURERUFcXHVEREVDLVxcdURERUVcXHVEREYyXFx1RERGM1xcdURERjVcXHVEREY3XFx1RERGQ1xcdURERkVcXHVEREZGXXxcXHVEREYxXFx1RDgzQ1tcXHVEREU2LVxcdURERThcXHVEREVFXFx1RERGMFxcdURERjctXFx1RERGQlxcdURERkVdfFxcdURERjJcXHVEODNDW1xcdURERTZcXHVEREU4LVxcdURERURcXHVEREYwLVxcdURERkZdfFxcdURERjNcXHVEODNDW1xcdURERTZcXHVEREU4XFx1RERFQS1cXHVEREVDXFx1RERFRVxcdURERjFcXHVEREY0XFx1RERGNVxcdURERjdcXHVEREZBXFx1RERGRl18XFx1RERGNFxcdUQ4M0NcXHVEREYyfFxcdURERjVcXHVEODNDW1xcdURERTZcXHVEREVBLVxcdURERURcXHVEREYwLVxcdURERjNcXHVEREY3LVxcdURERjlcXHVEREZDXFx1RERGRV18XFx1RERGNlxcdUQ4M0NcXHVEREU2fFxcdURERjdcXHVEODNDW1xcdURERUFcXHVEREY0XFx1RERGOFxcdURERkFcXHVEREZDXXxcXHVEREY4XFx1RDgzQ1tcXHVEREU2LVxcdURERUFcXHVEREVDLVxcdURERjRcXHVEREY3LVxcdURERjlcXHVEREZCXFx1RERGRC1cXHVEREZGXXxcXHVEREY5XFx1RDgzQ1tcXHVEREU2XFx1RERFOFxcdURERTlcXHVEREVCLVxcdURERURcXHVEREVGLVxcdURERjRcXHVEREY3XFx1RERGOVxcdURERkJcXHVEREZDXFx1RERGRl18XFx1RERGQVxcdUQ4M0NbXFx1RERFNlxcdURERUNcXHVEREYyXFx1RERGM1xcdURERjhcXHVEREZFXFx1RERGRl18XFx1RERGQlxcdUQ4M0NbXFx1RERFNlxcdURERThcXHVEREVBXFx1RERFQ1xcdURERUVcXHVEREYzXFx1RERGQV18XFx1RERGQ1xcdUQ4M0NbXFx1RERFQlxcdURERjhdfFxcdURERkRcXHVEODNDXFx1RERGMHxcXHVEREZFXFx1RDgzQ1tcXHVEREVBXFx1RERGOV18XFx1RERGRlxcdUQ4M0NbXFx1RERFNlxcdURERjJcXHVEREZDXXxcXHVERkYzXFx1RkUwRj8oPzpcXHUyMDBEKD86XFx1MjZBN1xcdUZFMEY/fFxcdUQ4M0NcXHVERjA4KSk/fFxcdURGRjQoPzpcXHUyMDBEXFx1MjYyMFxcdUZFMEY/fFxcdURCNDBcXHVEQzY3XFx1REI0MFxcdURDNjJcXHVEQjQwKD86XFx1REM2NVxcdURCNDBcXHVEQzZFXFx1REI0MFxcdURDNjd8XFx1REM3M1xcdURCNDBcXHVEQzYzXFx1REI0MFxcdURDNzR8XFx1REM3N1xcdURCNDBcXHVEQzZDXFx1REI0MFxcdURDNzMpXFx1REI0MFxcdURDN0YpPyl8XFx1RDgzRCg/OltcXHVEQzA4XFx1REMyNl0oPzpcXHUyMDBEXFx1MkIxQik/fFtcXHVEQzNGXFx1RENGRFxcdURENDlcXHVERDRBXFx1REQ2RlxcdURENzBcXHVERDczXFx1REQ3Ni1cXHVERDc5XFx1REQ4N1xcdUREOEEtXFx1REQ4RFxcdUREQTVcXHVEREE4XFx1RERCMVxcdUREQjJcXHVEREJDXFx1RERDMi1cXHVEREM0XFx1REREMS1cXHVEREQzXFx1REREQy1cXHVERERFXFx1RERFMVxcdURERTNcXHVEREU4XFx1RERFRlxcdURERjNcXHVEREZBXFx1REVDQlxcdURFQ0QtXFx1REVDRlxcdURFRTAtXFx1REVFNVxcdURFRTlcXHVERUYwXFx1REVGM11cXHVGRTBGP3xbXFx1REM0MlxcdURDNDNcXHVEQzQ2LVxcdURDNTBcXHVEQzY2XFx1REM2N1xcdURDNkItXFx1REM2RFxcdURDNzJcXHVEQzc0LVxcdURDNzZcXHVEQzc4XFx1REM3Q1xcdURDODNcXHVEQzg1XFx1REM4RlxcdURDOTFcXHVEQ0FBXFx1REQ3QVxcdUREOTVcXHVERDk2XFx1REU0Q1xcdURFNEZcXHVERUMwXFx1REVDQ10oPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pP3xbXFx1REM2RVxcdURDNzBcXHVEQzcxXFx1REM3M1xcdURDNzdcXHVEQzgxXFx1REM4MlxcdURDODZcXHVEQzg3XFx1REU0NS1cXHVERTQ3XFx1REU0QlxcdURFNERcXHVERTRFXFx1REVBM1xcdURFQjQtXFx1REVCNl0oPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pPyg/OlxcdTIwMERbXFx1MjY0MFxcdTI2NDJdXFx1RkUwRj8pP3xbXFx1REQ3NFxcdUREOTBdKD86XFx1RkUwRnxcXHVEODNDW1xcdURGRkItXFx1REZGRl0pP3xbXFx1REMwMC1cXHVEQzA3XFx1REMwOS1cXHVEQzE0XFx1REMxNi1cXHVEQzI1XFx1REMyNy1cXHVEQzNBXFx1REMzQy1cXHVEQzNFXFx1REM0MFxcdURDNDRcXHVEQzQ1XFx1REM1MS1cXHVEQzY1XFx1REM2QVxcdURDNzktXFx1REM3QlxcdURDN0QtXFx1REM4MFxcdURDODRcXHVEQzg4LVxcdURDOEVcXHVEQzkwXFx1REM5Mi1cXHVEQ0E5XFx1RENBQi1cXHVEQ0ZDXFx1RENGRi1cXHVERDNEXFx1REQ0Qi1cXHVERDRFXFx1REQ1MC1cXHVERDY3XFx1RERBNFxcdURERkItXFx1REUyRFxcdURFMkYtXFx1REUzNFxcdURFMzctXFx1REU0NFxcdURFNDgtXFx1REU0QVxcdURFODAtXFx1REVBMlxcdURFQTQtXFx1REVCM1xcdURFQjctXFx1REVCRlxcdURFQzEtXFx1REVDNVxcdURFRDAtXFx1REVEMlxcdURFRDUtXFx1REVEN1xcdURFREMtXFx1REVERlxcdURFRUJcXHVERUVDXFx1REVGNC1cXHVERUZDXFx1REZFMC1cXHVERkVCXFx1REZGMF18XFx1REMxNSg/OlxcdTIwMERcXHVEODNFXFx1RERCQSk/fFxcdURDM0IoPzpcXHUyMDBEXFx1Mjc0NFxcdUZFMEY/KT98XFx1REM0MVxcdUZFMEY/KD86XFx1MjAwRFxcdUQ4M0RcXHVEREU4XFx1RkUwRj8pP3xcXHVEQzY4KD86XFx1MjAwRCg/OltcXHUyNjk1XFx1MjY5NlxcdTI3MDhdXFx1RkUwRj98XFx1Mjc2NFxcdUZFMEY/XFx1MjAwRFxcdUQ4M0QoPzpcXHVEQzhCXFx1MjAwRFxcdUQ4M0QpP1xcdURDNjh8XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRCg/OltcXHVEQzY4XFx1REM2OV1cXHUyMDBEXFx1RDgzRCg/OlxcdURDNjYoPzpcXHUyMDBEXFx1RDgzRFxcdURDNjYpP3xcXHVEQzY3KD86XFx1MjAwRFxcdUQ4M0RbXFx1REM2NlxcdURDNjddKT8pfFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdURDNjYoPzpcXHUyMDBEXFx1RDgzRFxcdURDNjYpP3xcXHVEQzY3KD86XFx1MjAwRFxcdUQ4M0RbXFx1REM2NlxcdURDNjddKT8pfFxcdUQ4M0VbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdKXxcXHVEODNDKD86XFx1REZGQig/OlxcdTIwMEQoPzpbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XVxcdUZFMEY/fFxcdTI3NjRcXHVGRTBGP1xcdTIwMERcXHVEODNEKD86XFx1REM4QlxcdTIwMERcXHVEODNEKT9cXHVEQzY4XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFKD86W1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXXxcXHVERDFEXFx1MjAwRFxcdUQ4M0RcXHVEQzY4XFx1RDgzQ1tcXHVERkZDLVxcdURGRkZdKSkpP3xcXHVERkZDKD86XFx1MjAwRCg/OltcXHUyNjk1XFx1MjY5NlxcdTI3MDhdXFx1RkUwRj98XFx1Mjc2NFxcdUZFMEY/XFx1MjAwRFxcdUQ4M0QoPzpcXHVEQzhCXFx1MjAwRFxcdUQ4M0QpP1xcdURDNjhcXHVEODNDW1xcdURGRkItXFx1REZGRl18XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0UoPzpbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdfFxcdUREMURcXHUyMDBEXFx1RDgzRFxcdURDNjhcXHVEODNDW1xcdURGRkJcXHVERkZELVxcdURGRkZdKSkpP3xcXHVERkZEKD86XFx1MjAwRCg/OltcXHUyNjk1XFx1MjY5NlxcdTI3MDhdXFx1RkUwRj98XFx1Mjc2NFxcdUZFMEY/XFx1MjAwRFxcdUQ4M0QoPzpcXHVEQzhCXFx1MjAwRFxcdUQ4M0QpP1xcdURDNjhcXHVEODNDW1xcdURGRkItXFx1REZGRl18XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0UoPzpbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdfFxcdUREMURcXHUyMDBEXFx1RDgzRFxcdURDNjhcXHVEODNDW1xcdURGRkJcXHVERkZDXFx1REZGRVxcdURGRkZdKSkpP3xcXHVERkZFKD86XFx1MjAwRCg/OltcXHUyNjk1XFx1MjY5NlxcdTI3MDhdXFx1RkUwRj98XFx1Mjc2NFxcdUZFMEY/XFx1MjAwRFxcdUQ4M0QoPzpcXHVEQzhCXFx1MjAwRFxcdUQ4M0QpP1xcdURDNjhcXHVEODNDW1xcdURGRkItXFx1REZGRl18XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0UoPzpbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdfFxcdUREMURcXHUyMDBEXFx1RDgzRFxcdURDNjhcXHVEODNDW1xcdURGRkItXFx1REZGRFxcdURGRkZdKSkpP3xcXHVERkZGKD86XFx1MjAwRCg/OltcXHUyNjk1XFx1MjY5NlxcdTI3MDhdXFx1RkUwRj98XFx1Mjc2NFxcdUZFMEY/XFx1MjAwRFxcdUQ4M0QoPzpcXHVEQzhCXFx1MjAwRFxcdUQ4M0QpP1xcdURDNjhcXHVEODNDW1xcdURGRkItXFx1REZGRl18XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0UoPzpbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdfFxcdUREMURcXHUyMDBEXFx1RDgzRFxcdURDNjhcXHVEODNDW1xcdURGRkItXFx1REZGRV0pKSk/KSk/fFxcdURDNjkoPzpcXHUyMDBEKD86W1xcdTI2OTVcXHUyNjk2XFx1MjcwOF1cXHVGRTBGP3xcXHUyNzY0XFx1RkUwRj9cXHUyMDBEXFx1RDgzRCg/OlxcdURDOEJcXHUyMDBEXFx1RDgzRCk/W1xcdURDNjhcXHVEQzY5XXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEKD86W1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1REM2Nig/OlxcdTIwMERcXHVEODNEXFx1REM2Nik/fFxcdURDNjcoPzpcXHUyMDBEXFx1RDgzRFtcXHVEQzY2XFx1REM2N10pP3xcXHVEQzY5XFx1MjAwRFxcdUQ4M0QoPzpcXHVEQzY2KD86XFx1MjAwRFxcdUQ4M0RcXHVEQzY2KT98XFx1REM2Nyg/OlxcdTIwMERcXHVEODNEW1xcdURDNjZcXHVEQzY3XSk/KSl8XFx1RDgzRVtcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF0pfFxcdUQ4M0MoPzpcXHVERkZCKD86XFx1MjAwRCg/OltcXHUyNjk1XFx1MjY5NlxcdTI3MDhdXFx1RkUwRj98XFx1Mjc2NFxcdUZFMEY/XFx1MjAwRFxcdUQ4M0QoPzpbXFx1REM2OFxcdURDNjldfFxcdURDOEJcXHUyMDBEXFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pXFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFKD86W1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXXxcXHVERDFEXFx1MjAwRFxcdUQ4M0RbXFx1REM2OFxcdURDNjldXFx1RDgzQ1tcXHVERkZDLVxcdURGRkZdKSkpP3xcXHVERkZDKD86XFx1MjAwRCg/OltcXHUyNjk1XFx1MjY5NlxcdTI3MDhdXFx1RkUwRj98XFx1Mjc2NFxcdUZFMEY/XFx1MjAwRFxcdUQ4M0QoPzpbXFx1REM2OFxcdURDNjldfFxcdURDOEJcXHUyMDBEXFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pXFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFKD86W1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXXxcXHVERDFEXFx1MjAwRFxcdUQ4M0RbXFx1REM2OFxcdURDNjldXFx1RDgzQ1tcXHVERkZCXFx1REZGRC1cXHVERkZGXSkpKT98XFx1REZGRCg/OlxcdTIwMEQoPzpbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XVxcdUZFMEY/fFxcdTI3NjRcXHVGRTBGP1xcdTIwMERcXHVEODNEKD86W1xcdURDNjhcXHVEQzY5XXxcXHVEQzhCXFx1MjAwRFxcdUQ4M0RbXFx1REM2OFxcdURDNjldKVxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRSg/OltcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF18XFx1REQxRFxcdTIwMERcXHVEODNEW1xcdURDNjhcXHVEQzY5XVxcdUQ4M0NbXFx1REZGQlxcdURGRkNcXHVERkZFXFx1REZGRl0pKSk/fFxcdURGRkUoPzpcXHUyMDBEKD86W1xcdTI2OTVcXHUyNjk2XFx1MjcwOF1cXHVGRTBGP3xcXHUyNzY0XFx1RkUwRj9cXHUyMDBEXFx1RDgzRCg/OltcXHVEQzY4XFx1REM2OV18XFx1REM4QlxcdTIwMERcXHVEODNEW1xcdURDNjhcXHVEQzY5XSlcXHVEODNDW1xcdURGRkItXFx1REZGRl18XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0UoPzpbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdfFxcdUREMURcXHUyMDBEXFx1RDgzRFtcXHVEQzY4XFx1REM2OV1cXHVEODNDW1xcdURGRkItXFx1REZGRFxcdURGRkZdKSkpP3xcXHVERkZGKD86XFx1MjAwRCg/OltcXHUyNjk1XFx1MjY5NlxcdTI3MDhdXFx1RkUwRj98XFx1Mjc2NFxcdUZFMEY/XFx1MjAwRFxcdUQ4M0QoPzpbXFx1REM2OFxcdURDNjldfFxcdURDOEJcXHUyMDBEXFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pXFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFKD86W1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXXxcXHVERDFEXFx1MjAwRFxcdUQ4M0RbXFx1REM2OFxcdURDNjldXFx1RDgzQ1tcXHVERkZCLVxcdURGRkVdKSkpPykpP3xcXHVEQzZGKD86XFx1MjAwRFtcXHUyNjQwXFx1MjY0Ml1cXHVGRTBGPyk/fFxcdURENzUoPzpcXHVGRTBGfFxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSk/KD86XFx1MjAwRFtcXHUyNjQwXFx1MjY0Ml1cXHVGRTBGPyk/fFxcdURFMkUoPzpcXHUyMDBEXFx1RDgzRFxcdURDQTgpP3xcXHVERTM1KD86XFx1MjAwRFxcdUQ4M0RcXHVEQ0FCKT98XFx1REUzNig/OlxcdTIwMERcXHVEODNDXFx1REYyQlxcdUZFMEY/KT8pfFxcdUQ4M0UoPzpbXFx1REQwQ1xcdUREMEZcXHVERDE4LVxcdUREMUZcXHVERDMwLVxcdUREMzRcXHVERDM2XFx1REQ3N1xcdUREQjVcXHVEREI2XFx1RERCQlxcdURERDJcXHVEREQzXFx1RERENVxcdURFQzMtXFx1REVDNVxcdURFRjBcXHVERUYyLVxcdURFRjhdKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKT98W1xcdUREMjZcXHVERDM1XFx1REQzNy1cXHVERDM5XFx1REQzRFxcdUREM0VcXHVEREI4XFx1RERCOVxcdUREQ0QtXFx1RERDRlxcdURERDRcXHVEREQ2LVxcdURERERdKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKT8oPzpcXHUyMDBEW1xcdTI2NDBcXHUyNjQyXVxcdUZFMEY/KT98W1xcdUREREVcXHVERERGXSg/OlxcdTIwMERbXFx1MjY0MFxcdTI2NDJdXFx1RkUwRj8pP3xbXFx1REQwRFxcdUREMEVcXHVERDEwLVxcdUREMTdcXHVERDIwLVxcdUREMjVcXHVERDI3LVxcdUREMkZcXHVERDNBXFx1REQzRi1cXHVERDQ1XFx1REQ0Ny1cXHVERDc2XFx1REQ3OC1cXHVEREI0XFx1RERCN1xcdUREQkFcXHVEREJDLVxcdUREQ0NcXHVEREQwXFx1RERFMC1cXHVEREZGXFx1REU3MC1cXHVERTdDXFx1REU4MC1cXHVERTg4XFx1REU5MC1cXHVERUJEXFx1REVCRi1cXHVERUMyXFx1REVDRS1cXHVERURCXFx1REVFMC1cXHVERUU4XXxcXHVERDNDKD86XFx1MjAwRFtcXHUyNjQwXFx1MjY0Ml1cXHVGRTBGP3xcXHVEODNDW1xcdURGRkItXFx1REZGRl0pP3xcXHVEREQxKD86XFx1MjAwRCg/OltcXHUyNjk1XFx1MjY5NlxcdTI3MDhdXFx1RkUwRj98XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjg0XFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFKD86W1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXXxcXHVERDFEXFx1MjAwRFxcdUQ4M0VcXHVEREQxKSl8XFx1RDgzQyg/OlxcdURGRkIoPzpcXHUyMDBEKD86W1xcdTI2OTVcXHUyNjk2XFx1MjcwOF1cXHVGRTBGP3xcXHUyNzY0XFx1RkUwRj9cXHUyMDBEKD86XFx1RDgzRFxcdURDOEJcXHUyMDBEKT9cXHVEODNFXFx1REREMVxcdUQ4M0NbXFx1REZGQy1cXHVERkZGXXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGODRcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0UoPzpbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdfFxcdUREMURcXHUyMDBEXFx1RDgzRVxcdURERDFcXHVEODNDW1xcdURGRkItXFx1REZGRl0pKSk/fFxcdURGRkMoPzpcXHUyMDBEKD86W1xcdTI2OTVcXHUyNjk2XFx1MjcwOF1cXHVGRTBGP3xcXHUyNzY0XFx1RkUwRj9cXHUyMDBEKD86XFx1RDgzRFxcdURDOEJcXHUyMDBEKT9cXHVEODNFXFx1REREMVxcdUQ4M0NbXFx1REZGQlxcdURGRkQtXFx1REZGRl18XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjg0XFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFKD86W1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXXxcXHVERDFEXFx1MjAwRFxcdUQ4M0VcXHVEREQxXFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKSkpP3xcXHVERkZEKD86XFx1MjAwRCg/OltcXHUyNjk1XFx1MjY5NlxcdTI3MDhdXFx1RkUwRj98XFx1Mjc2NFxcdUZFMEY/XFx1MjAwRCg/OlxcdUQ4M0RcXHVEQzhCXFx1MjAwRCk/XFx1RDgzRVxcdURERDFcXHVEODNDW1xcdURGRkJcXHVERkZDXFx1REZGRVxcdURGRkZdfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY4NFxcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRSg/OltcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF18XFx1REQxRFxcdTIwMERcXHVEODNFXFx1REREMVxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSkpKT98XFx1REZGRSg/OlxcdTIwMEQoPzpbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XVxcdUZFMEY/fFxcdTI3NjRcXHVGRTBGP1xcdTIwMEQoPzpcXHVEODNEXFx1REM4QlxcdTIwMEQpP1xcdUQ4M0VcXHVEREQxXFx1RDgzQ1tcXHVERkZCLVxcdURGRkRcXHVERkZGXXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGODRcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0UoPzpbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdfFxcdUREMURcXHUyMDBEXFx1RDgzRVxcdURERDFcXHVEODNDW1xcdURGRkItXFx1REZGRl0pKSk/fFxcdURGRkYoPzpcXHUyMDBEKD86W1xcdTI2OTVcXHUyNjk2XFx1MjcwOF1cXHVGRTBGP3xcXHUyNzY0XFx1RkUwRj9cXHUyMDBEKD86XFx1RDgzRFxcdURDOEJcXHUyMDBEKT9cXHVEODNFXFx1REREMVxcdUQ4M0NbXFx1REZGQi1cXHVERkZFXXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGODRcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0UoPzpbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdfFxcdUREMURcXHUyMDBEXFx1RDgzRVxcdURERDFcXHVEODNDW1xcdURGRkItXFx1REZGRl0pKSk/KSk/fFxcdURFRjEoPzpcXHVEODNDKD86XFx1REZGQig/OlxcdTIwMERcXHVEODNFXFx1REVGMlxcdUQ4M0NbXFx1REZGQy1cXHVERkZGXSk/fFxcdURGRkMoPzpcXHUyMDBEXFx1RDgzRVxcdURFRjJcXHVEODNDW1xcdURGRkJcXHVERkZELVxcdURGRkZdKT98XFx1REZGRCg/OlxcdTIwMERcXHVEODNFXFx1REVGMlxcdUQ4M0NbXFx1REZGQlxcdURGRkNcXHVERkZFXFx1REZGRl0pP3xcXHVERkZFKD86XFx1MjAwRFxcdUQ4M0VcXHVERUYyXFx1RDgzQ1tcXHVERkZCLVxcdURGRkRcXHVERkZGXSk/fFxcdURGRkYoPzpcXHUyMDBEXFx1RDgzRVxcdURFRjJcXHVEODNDW1xcdURGRkItXFx1REZGRV0pPykpPykvZztcbn07XG4iLCAiaW1wb3J0IHsgRGF0ZVRpbWUsIER1cmF0aW9uIH0gZnJvbSBcImx1eG9uXCI7XG5pbXBvcnQgeyBSZXN1bHQgfSBmcm9tIFwiYXBpL3Jlc3VsdFwiO1xuaW1wb3J0ICogYXMgUCBmcm9tIFwicGFyc2ltbW9uXCI7XG5pbXBvcnQgZW1vamlSZWdleCBmcm9tIFwiZW1vamktcmVnZXhcIjtcbmltcG9ydCB7IFF1ZXJ5U2V0dGluZ3MgfSBmcm9tIFwic2V0dGluZ3NcIjtcblxuLyoqIE5vcm1hbGl6ZSBhIGR1cmF0aW9uIHRvIGFsbCBvZiB0aGUgcHJvcGVyIHVuaXRzLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZUR1cmF0aW9uKGR1cjogRHVyYXRpb24pIHtcbiAgICBpZiAoZHVyID09PSB1bmRlZmluZWQgfHwgZHVyID09PSBudWxsKSByZXR1cm4gZHVyO1xuXG4gICAgcmV0dXJuIGR1ci5zaGlmdFRvQWxsKCkubm9ybWFsaXplKCk7XG59XG5cbi8qKiBTdHJpcCB0aGUgdGltZSBjb21wb25lbnRzIG9mIGEgZGF0ZSB0aW1lIG9iamVjdC4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpcFRpbWUoZHQ6IERhdGVUaW1lKTogRGF0ZVRpbWUge1xuICAgIGlmIChkdCA9PT0gbnVsbCB8fCBkdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZHQ7XG5cbiAgICByZXR1cm4gRGF0ZVRpbWUuZnJvbU9iamVjdCh7XG4gICAgICAgIHllYXI6IGR0LnllYXIsXG4gICAgICAgIG1vbnRoOiBkdC5tb250aCxcbiAgICAgICAgZGF5OiBkdC5kYXksXG4gICAgfSk7XG59XG5cbi8qKiBUcnkgdG8gZXh0cmFjdCBhIFlZWVlNTUREIGRhdGUgZnJvbSBhIHN0cmluZy4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0RGF0ZShzdHI6IHN0cmluZyk6IERhdGVUaW1lIHwgdW5kZWZpbmVkIHtcbiAgICBsZXQgZGF0ZU1hdGNoID0gLyhcXGR7NH0pLShcXGR7Mn0pLShcXGR7Mn0pLy5leGVjKHN0cik7XG4gICAgaWYgKCFkYXRlTWF0Y2gpIGRhdGVNYXRjaCA9IC8oXFxkezR9KShcXGR7Mn0pKFxcZHsyfSkvLmV4ZWMoc3RyKTtcbiAgICBpZiAoZGF0ZU1hdGNoKSB7XG4gICAgICAgIGxldCB5ZWFyID0gTnVtYmVyLnBhcnNlSW50KGRhdGVNYXRjaFsxXSk7XG4gICAgICAgIGxldCBtb250aCA9IE51bWJlci5wYXJzZUludChkYXRlTWF0Y2hbMl0pO1xuICAgICAgICBsZXQgZGF5ID0gTnVtYmVyLnBhcnNlSW50KGRhdGVNYXRjaFszXSk7XG4gICAgICAgIHJldHVybiBEYXRlVGltZS5mcm9tT2JqZWN0KHsgeWVhciwgbW9udGgsIGRheSB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKiogR2V0IHRoZSBmb2xkZXIgY29udGFpbmluZyB0aGUgZ2l2ZW4gcGF0aCAoaS5lLiwgbGlrZSBjb21wdXRpbmcgJ3BhdGgvLi4nKS4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXJlbnRGb2xkZXIocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gcGF0aC5zcGxpdChcIi9cIikuc2xpY2UoMCwgLTEpLmpvaW4oXCIvXCIpO1xufVxuXG4vKiogR2V0IHRoZSBmaWxlIG5hbWUgZm9yIHRoZSBmaWxlIHJlZmVyZW5jZWQgaW4gdGhlIGdpdmVuIHBhdGgsIGJ5IHN0cmlwcGluZyB0aGUgcGFyZW50IGZvbGRlcnMuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmlsZU5hbWUocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gcGF0aC5pbmNsdWRlcyhcIi9cIikgPyBwYXRoLnN1YnN0cmluZyhwYXRoLmxhc3RJbmRleE9mKFwiL1wiKSArIDEpIDogcGF0aDtcbn1cblxuLyoqIEdldCB0aGUgXCJ0aXRsZVwiIGZvciBhIGZpbGUsIGJ5IHN0cmlwcGluZyBvdGhlciBwYXJ0cyBvZiB0aGUgcGF0aCBhcyB3ZWxsIGFzIHRoZSBleHRlbnNpb24uICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmlsZVRpdGxlKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgaWYgKHBhdGguaW5jbHVkZXMoXCIvXCIpKSBwYXRoID0gcGF0aC5zdWJzdHJpbmcocGF0aC5sYXN0SW5kZXhPZihcIi9cIikgKyAxKTtcbiAgICBpZiAocGF0aC5lbmRzV2l0aChcIi5tZFwiKSkgcGF0aCA9IHBhdGguc3Vic3RyaW5nKDAsIHBhdGgubGVuZ3RoIC0gMyk7XG4gICAgcmV0dXJuIHBhdGg7XG59XG5cbi8qKiBHZXQgdGhlIGV4dGVuc2lvbiBvZiBhIGZpbGUgZnJvbSB0aGUgZmlsZSBwYXRoLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEV4dGVuc2lvbihwYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmICghcGF0aC5pbmNsdWRlcyhcIi5cIikpIHJldHVybiBcIlwiO1xuICAgIHJldHVybiBwYXRoLnN1YnN0cmluZyhwYXRoLmxhc3RJbmRleE9mKFwiLlwiKSArIDEpO1xufVxuXG4vKiogUGFyc2UgYWxsIHN1YnRhZ3Mgb3V0IG9mIHRoZSBnaXZlbiB0YWcuIEkuZS4sICNoZWxsby9pL2FtIHdvdWxkIHlpZWxkIFsjaGVsbG8vaS9hbSwgI2hlbGxvL2ksICNoZWxsb10uICovXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFN1YnRhZ3ModGFnOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgbGV0IHJlc3VsdCA9IFt0YWddO1xuICAgIHdoaWxlICh0YWcuaW5jbHVkZXMoXCIvXCIpKSB7XG4gICAgICAgIHRhZyA9IHRhZy5zdWJzdHJpbmcoMCwgdGFnLmxhc3RJbmRleE9mKFwiL1wiKSk7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRhZyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqIFRyeSBjYWxsaW5nIHRoZSBnaXZlbiBmdW5jdGlvbjsgb24gZmFpbHVyZSwgcmV0dXJuIHRoZSBlcnJvciBtZXNzYWdlLiAgKi9cbmV4cG9ydCBmdW5jdGlvbiB0cnlPclByb3BvZ2F0ZTxUPihmdW5jOiAoKSA9PiBSZXN1bHQ8VCwgc3RyaW5nPik6IFJlc3VsdDxULCBzdHJpbmc+IHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZnVuYygpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBSZXN1bHQuZmFpbHVyZShcIlwiICsgZXJyb3IgKyBcIlxcblxcblwiICsgZXJyb3Iuc3RhY2spO1xuICAgIH1cbn1cblxuLyoqIFRyeSBhc3luY2hyb25vdXNseSBjYWxsaW5nIHRoZSBnaXZlbiBmdW5jdGlvbjsgb24gZmFpbHVyZSwgcmV0dXJuIHRoZSBlcnJvciBtZXNzYWdlLiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFzeW5jVHJ5T3JQcm9wb2dhdGU8VD4oZnVuYzogKCkgPT4gUHJvbWlzZTxSZXN1bHQ8VCwgc3RyaW5nPj4pOiBQcm9taXNlPFJlc3VsdDxULCBzdHJpbmc+PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGZ1bmMoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gUmVzdWx0LmZhaWx1cmUoXCJcIiArIGVycm9yICsgXCJcXG5cXG5cIiArIGVycm9yLnN0YWNrKTtcbiAgICB9XG59XG5cbi8qKlxuICogRXNjYXBlIHJlZ2V4IGNoYXJhY3RlcnMgaW4gYSBzdHJpbmcuXG4gKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9HdWlkZS9SZWd1bGFyX0V4cHJlc3Npb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlUmVnZXgoc3RyOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCBcIlxcXFwkJlwiKTtcbn1cblxuLyoqIEEgcGFyc2ltbW9uIHBhcnNlciB3aGljaCBjYW5vbmljYWxpemVzIHZhcmlhYmxlIG5hbWVzIHdoaWxlIHByb3Blcmx5IHJlc3BlY3RpbmcgZW1vamkuICovXG5jb25zdCBWQVJfTkFNRV9DQU5PTklDQUxJWkVSOiBQLlBhcnNlcjxzdHJpbmc+ID0gUC5hbHQoXG4gICAgUC5yZWdleChuZXcgUmVnRXhwKGVtb2ppUmVnZXgoKSwgXCJcIikpLFxuICAgIFAucmVnZXgoL1swLTlcXHB7TGV0dGVyfV8tXSsvdSkubWFwKHN0ciA9PiBzdHIudG9Mb2NhbGVMb3dlckNhc2UoKSksXG4gICAgUC53aGl0ZXNwYWNlLm1hcChfID0+IFwiLVwiKSxcbiAgICBQLmFueS5tYXAoXyA9PiBcIlwiKVxuKVxuICAgIC5tYW55KClcbiAgICAubWFwKHJlc3VsdCA9PiByZXN1bHQuam9pbihcIlwiKSk7XG5cbi8qKiBDb252ZXJ0IGFuIGFyYml0cmFyeSB2YXJpYWJsZSBuYW1lIGludG8gc29tZXRoaW5nIEpTL3F1ZXJ5IGZyaWVuZGx5LiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbm9uaWNhbGl6ZVZhck5hbWUobmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gVkFSX05BTUVfQ0FOT05JQ0FMSVpFUi50cnlQYXJzZShuYW1lKTtcbn1cblxuY29uc3QgSEVBREVSX0NBTk9OSUNBTElaRVI6IFAuUGFyc2VyPHN0cmluZz4gPSBQLmFsdChcbiAgICBQLnJlZ2V4KG5ldyBSZWdFeHAoZW1vamlSZWdleCgpLCBcIlwiKSksXG4gICAgUC5yZWdleCgvWzAtOVxccHtMZXR0ZXJ9Xy1dKy91KSxcbiAgICBQLndoaXRlc3BhY2UubWFwKF8gPT4gXCIgXCIpLFxuICAgIFAuYW55Lm1hcChfID0+IFwiIFwiKVxuKVxuICAgIC5tYW55KClcbiAgICAubWFwKHJlc3VsdCA9PiB7XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIlwiKS5zcGxpdCgvXFxzKy8pLmpvaW4oXCIgXCIpLnRyaW0oKTtcbiAgICB9KTtcblxuLyoqXG4gKiBOb3JtYWxpemVzIHRoZSB0ZXh0IGluIGEgaGVhZGVyIHRvIGJlIHNvbWV0aGluZyB0aGF0IGlzIGFjdHVhbGx5IGxpbmthYmxlIHRvLiBUaGlzIG1pbWljc1xuICogaG93IE9ic2lkaWFuIGRvZXMgaXQncyBub3JtYWxpemF0aW9uLCBjb2xsYXBzaW5nIHJlcGVhdGVkIHNwYWNlcyBhbmQgc3RyaXBwaW5nIG91dCBjb250cm9sIGNoYXJhY3RlcnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVIZWFkZXJGb3JMaW5rKGhlYWRlcjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gSEVBREVSX0NBTk9OSUNBTElaRVIudHJ5UGFyc2UoaGVhZGVyKTtcbn1cblxuLyoqIFJlbmRlciBhIERhdGVUaW1lIGluIGEgbWluaW1hbCBmb3JtYXQgdG8gc2F2ZSBzcGFjZS4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJNaW5pbWFsRGF0ZSh0aW1lOiBEYXRlVGltZSwgc2V0dGluZ3M6IFF1ZXJ5U2V0dGluZ3MsIGxvY2FsZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyByZWxldmFudCB0aW1lIHNwZWNpZmllZCwgZmFsbCBiYWNrIHRvIGp1c3QgcmVuZGVyaW5nIHRoZSBkYXRlLlxuICAgIGlmICh0aW1lLnNlY29uZCA9PSAwICYmIHRpbWUubWludXRlID09IDAgJiYgdGltZS5ob3VyID09IDApIHtcbiAgICAgICAgcmV0dXJuIHRpbWUudG9Mb2NhbCgpLnRvRm9ybWF0KHNldHRpbmdzLmRlZmF1bHREYXRlRm9ybWF0LCB7IGxvY2FsZSB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGltZS50b0xvY2FsKCkudG9Gb3JtYXQoc2V0dGluZ3MuZGVmYXVsdERhdGVUaW1lRm9ybWF0LCB7IGxvY2FsZSB9KTtcbn1cblxuLyoqIFJlbmRlciBhIGR1cmF0aW9uIGluIGEgbWluaW1hbCBmb3JtYXQgdG8gc2F2ZSBzcGFjZS4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJNaW5pbWFsRHVyYXRpb24oZHVyOiBEdXJhdGlvbik6IHN0cmluZyB7XG4gICAgZHVyID0gbm9ybWFsaXplRHVyYXRpb24oZHVyKTtcblxuICAgIC8vIHRvSHVtYW4gb3V0cHV0cyB6ZXJvIHF1YW50aXRpZXMgZS5nLiBcIjAgc2Vjb25kc1wiXG4gICAgZHVyID0gRHVyYXRpb24uZnJvbU9iamVjdChcbiAgICAgICAgT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGR1ci50b09iamVjdCgpKS5maWx0ZXIoKFssIHF1YW50aXR5XSkgPT4gcXVhbnRpdHkgIT0gMCkpXG4gICAgKTtcblxuICAgIHJldHVybiBkdXIudG9IdW1hbigpO1xufVxuXG4vKiogRGV0ZXJtaW5lIGlmIHR3byBzZXRzIGFyZSBlcXVhbCBpbiBjb250ZW50cy4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRzRXF1YWw8VD4oZmlyc3Q6IFNldDxUPiwgc2Vjb25kOiBTZXQ8VD4pOiBib29sZWFuIHtcbiAgICBpZiAoZmlyc3Quc2l6ZSAhPSBzZWNvbmQuc2l6ZSkgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGVsZW0gb2YgZmlyc3QpIGlmICghc2Vjb25kLmhhcyhlbGVtKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgcmV0dXJuIHRydWU7XG59XG4iLCAiaW1wb3J0IHsgRGF0ZVRpbWUsIER1cmF0aW9uIH0gZnJvbSBcImx1eG9uXCI7XG5pbXBvcnQgeyBERUZBVUxUX1FVRVJZX1NFVFRJTkdTLCBRdWVyeVNldHRpbmdzIH0gZnJvbSBcInNldHRpbmdzXCI7XG5pbXBvcnQgeyBnZXRGaWxlVGl0bGUsIG5vcm1hbGl6ZUhlYWRlckZvckxpbmssIHJlbmRlck1pbmltYWxEdXJhdGlvbiB9IGZyb20gXCJ1dGlsL25vcm1hbGl6ZVwiO1xuXG4vKiogU2hvcnRoYW5kIGZvciBhIG1hcHBpbmcgZnJvbSBrZXlzIHRvIHZhbHVlcy4gKi9cbmV4cG9ydCB0eXBlIERhdGFPYmplY3QgPSB7IFtrZXk6IHN0cmluZ106IExpdGVyYWwgfTtcbi8qKiBUaGUgbGl0ZXJhbCB0eXBlcyBzdXBwb3J0ZWQgYnkgdGhlIHF1ZXJ5IGVuZ2luZS4gKi9cbmV4cG9ydCB0eXBlIExpdGVyYWxUeXBlID1cbiAgICB8IFwiYm9vbGVhblwiXG4gICAgfCBcIm51bWJlclwiXG4gICAgfCBcInN0cmluZ1wiXG4gICAgfCBcImRhdGVcIlxuICAgIHwgXCJkdXJhdGlvblwiXG4gICAgfCBcImxpbmtcIlxuICAgIHwgXCJhcnJheVwiXG4gICAgfCBcIm9iamVjdFwiXG4gICAgfCBcImZ1bmN0aW9uXCJcbiAgICB8IFwibnVsbFwiXG4gICAgfCBcImh0bWxcIlxuICAgIHwgXCJ3aWRnZXRcIjtcbi8qKiBUaGUgcmF3IHZhbHVlcyB0aGF0IGEgbGl0ZXJhbCBjYW4gdGFrZSBvbi4gKi9cbmV4cG9ydCB0eXBlIExpdGVyYWwgPVxuICAgIHwgYm9vbGVhblxuICAgIHwgbnVtYmVyXG4gICAgfCBzdHJpbmdcbiAgICB8IERhdGVUaW1lXG4gICAgfCBEdXJhdGlvblxuICAgIHwgTGlua1xuICAgIHwgQXJyYXk8TGl0ZXJhbD5cbiAgICB8IERhdGFPYmplY3RcbiAgICB8IEZ1bmN0aW9uXG4gICAgfCBudWxsXG4gICAgfCBIVE1MRWxlbWVudFxuICAgIHwgV2lkZ2V0O1xuXG4vKiogQSBncm91cGluZyBvbiBhIHR5cGUgd2hpY2ggc3VwcG9ydHMgcmVjdXJzaXZlbHktbmVzdGVkIGdyb3Vwcy4gKi9cbmV4cG9ydCB0eXBlIEdyb3VwRWxlbWVudDxUPiA9IHsga2V5OiBMaXRlcmFsOyByb3dzOiBHcm91cGluZzxUPiB9O1xuZXhwb3J0IHR5cGUgR3JvdXBpbmc8VD4gPSBUW10gfCBHcm91cEVsZW1lbnQ8VD5bXTtcblxuLyoqIE1hcHMgdGhlIHN0cmluZyB0eXBlIHRvIGl0J3MgZXh0ZXJuYWwsIEFQSS1mYWNpbmcgcmVwcmVzZW50YXRpb24uICovXG5leHBvcnQgdHlwZSBMaXRlcmFsUmVwcjxUIGV4dGVuZHMgTGl0ZXJhbFR5cGU+ID0gVCBleHRlbmRzIFwiYm9vbGVhblwiXG4gICAgPyBib29sZWFuXG4gICAgOiBUIGV4dGVuZHMgXCJudW1iZXJcIlxuICAgID8gbnVtYmVyXG4gICAgOiBUIGV4dGVuZHMgXCJzdHJpbmdcIlxuICAgID8gc3RyaW5nXG4gICAgOiBUIGV4dGVuZHMgXCJkdXJhdGlvblwiXG4gICAgPyBEdXJhdGlvblxuICAgIDogVCBleHRlbmRzIFwiZGF0ZVwiXG4gICAgPyBEYXRlVGltZVxuICAgIDogVCBleHRlbmRzIFwibnVsbFwiXG4gICAgPyBudWxsXG4gICAgOiBUIGV4dGVuZHMgXCJsaW5rXCJcbiAgICA/IExpbmtcbiAgICA6IFQgZXh0ZW5kcyBcImFycmF5XCJcbiAgICA/IEFycmF5PExpdGVyYWw+XG4gICAgOiBUIGV4dGVuZHMgXCJvYmplY3RcIlxuICAgID8gUmVjb3JkPHN0cmluZywgTGl0ZXJhbD5cbiAgICA6IFQgZXh0ZW5kcyBcImZ1bmN0aW9uXCJcbiAgICA/IEZ1bmN0aW9uXG4gICAgOiBUIGV4dGVuZHMgXCJodG1sXCJcbiAgICA/IEhUTUxFbGVtZW50XG4gICAgOiBUIGV4dGVuZHMgXCJ3aWRnZXRcIlxuICAgID8gV2lkZ2V0XG4gICAgOiBhbnk7XG5cbi8qKiBBIHdyYXBwZWQgbGl0ZXJhbCB2YWx1ZSB3aGljaCBjYW4gYmUgc3dpdGNoZWQgb24uICovXG5leHBvcnQgdHlwZSBXcmFwcGVkTGl0ZXJhbCA9XG4gICAgfCBMaXRlcmFsV3JhcHBlcjxcInN0cmluZ1wiPlxuICAgIHwgTGl0ZXJhbFdyYXBwZXI8XCJudW1iZXJcIj5cbiAgICB8IExpdGVyYWxXcmFwcGVyPFwiYm9vbGVhblwiPlxuICAgIHwgTGl0ZXJhbFdyYXBwZXI8XCJkYXRlXCI+XG4gICAgfCBMaXRlcmFsV3JhcHBlcjxcImR1cmF0aW9uXCI+XG4gICAgfCBMaXRlcmFsV3JhcHBlcjxcImxpbmtcIj5cbiAgICB8IExpdGVyYWxXcmFwcGVyPFwiYXJyYXlcIj5cbiAgICB8IExpdGVyYWxXcmFwcGVyPFwib2JqZWN0XCI+XG4gICAgfCBMaXRlcmFsV3JhcHBlcjxcImh0bWxcIj5cbiAgICB8IExpdGVyYWxXcmFwcGVyPFwid2lkZ2V0XCI+XG4gICAgfCBMaXRlcmFsV3JhcHBlcjxcImZ1bmN0aW9uXCI+XG4gICAgfCBMaXRlcmFsV3JhcHBlcjxcIm51bGxcIj47XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGl0ZXJhbFdyYXBwZXI8VCBleHRlbmRzIExpdGVyYWxUeXBlPiB7XG4gICAgdHlwZTogVDtcbiAgICB2YWx1ZTogTGl0ZXJhbFJlcHI8VD47XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgVmFsdWVzIHtcbiAgICAvKiogQ29udmVydCBhbiBhcmJpdHJhcnkgdmFsdWUgaW50byBhIHJlYXNvbmFibGUsIE1hcmtkb3duLWZyaWVuZGx5IHN0cmluZyBpZiBwb3NzaWJsZS4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gdG9TdHJpbmcoXG4gICAgICAgIGZpZWxkOiBhbnksXG4gICAgICAgIHNldHRpbmc6IFF1ZXJ5U2V0dGluZ3MgPSBERUZBVUxUX1FVRVJZX1NFVFRJTkdTLFxuICAgICAgICByZWN1cnNpdmU6IGJvb2xlYW4gPSBmYWxzZVxuICAgICk6IHN0cmluZyB7XG4gICAgICAgIGxldCB3cmFwcGVkID0gd3JhcFZhbHVlKGZpZWxkKTtcbiAgICAgICAgaWYgKCF3cmFwcGVkKSByZXR1cm4gc2V0dGluZy5yZW5kZXJOdWxsQXM7XG5cbiAgICAgICAgc3dpdGNoICh3cmFwcGVkLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJudWxsXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldHRpbmcucmVuZGVyTnVsbEFzO1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkLnZhbHVlO1xuICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcIiArIHdyYXBwZWQudmFsdWU7XG4gICAgICAgICAgICBjYXNlIFwiaHRtbFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkLnZhbHVlLm91dGVySFRNTDtcbiAgICAgICAgICAgIGNhc2UgXCJ3aWRnZXRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZC52YWx1ZS5tYXJrZG93bigpO1xuICAgICAgICAgICAgY2FzZSBcImxpbmtcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZC52YWx1ZS5tYXJrZG93bigpO1xuICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiPGZ1bmN0aW9uPlwiO1xuICAgICAgICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgaWYgKHJlY3Vyc2l2ZSkgcmVzdWx0ICs9IFwiW1wiO1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB3cmFwcGVkLnZhbHVlLm1hcChmID0+IHRvU3RyaW5nKGYsIHNldHRpbmcsIHRydWUpKS5qb2luKFwiLCBcIik7XG4gICAgICAgICAgICAgICAgaWYgKHJlY3Vyc2l2ZSkgcmVzdWx0ICs9IFwiXVwiO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgXCJ7IFwiICtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMod3JhcHBlZC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZSA9PiBlWzBdICsgXCI6IFwiICsgdG9TdHJpbmcoZVsxXSwgc2V0dGluZywgdHJ1ZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuam9pbihcIiwgXCIpICtcbiAgICAgICAgICAgICAgICAgICAgXCIgfVwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNhc2UgXCJkYXRlXCI6XG4gICAgICAgICAgICAgICAgaWYgKHdyYXBwZWQudmFsdWUuc2Vjb25kID09IDAgJiYgd3JhcHBlZC52YWx1ZS5ob3VyID09IDAgJiYgd3JhcHBlZC52YWx1ZS5taW51dGUgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZC52YWx1ZS50b0Zvcm1hdChzZXR0aW5nLmRlZmF1bHREYXRlRm9ybWF0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZC52YWx1ZS50b0Zvcm1hdChzZXR0aW5nLmRlZmF1bHREYXRlVGltZUZvcm1hdCk7XG4gICAgICAgICAgICBjYXNlIFwiZHVyYXRpb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyTWluaW1hbER1cmF0aW9uKHdyYXBwZWQudmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIFdyYXAgYSBsaXRlcmFsIHZhbHVlIHNvIHlvdSBjYW4gc3dpdGNoIG9uIGl0IGVhc2lseS4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gd3JhcFZhbHVlKHZhbDogTGl0ZXJhbCk6IFdyYXBwZWRMaXRlcmFsIHwgdW5kZWZpbmVkIHtcbiAgICAgICAgaWYgKGlzTnVsbCh2YWwpKSByZXR1cm4geyB0eXBlOiBcIm51bGxcIiwgdmFsdWU6IHZhbCB9O1xuICAgICAgICBlbHNlIGlmIChpc051bWJlcih2YWwpKSByZXR1cm4geyB0eXBlOiBcIm51bWJlclwiLCB2YWx1ZTogdmFsIH07XG4gICAgICAgIGVsc2UgaWYgKGlzU3RyaW5nKHZhbCkpIHJldHVybiB7IHR5cGU6IFwic3RyaW5nXCIsIHZhbHVlOiB2YWwgfTtcbiAgICAgICAgZWxzZSBpZiAoaXNCb29sZWFuKHZhbCkpIHJldHVybiB7IHR5cGU6IFwiYm9vbGVhblwiLCB2YWx1ZTogdmFsIH07XG4gICAgICAgIGVsc2UgaWYgKGlzRHVyYXRpb24odmFsKSkgcmV0dXJuIHsgdHlwZTogXCJkdXJhdGlvblwiLCB2YWx1ZTogdmFsIH07XG4gICAgICAgIGVsc2UgaWYgKGlzRGF0ZSh2YWwpKSByZXR1cm4geyB0eXBlOiBcImRhdGVcIiwgdmFsdWU6IHZhbCB9O1xuICAgICAgICBlbHNlIGlmIChpc1dpZGdldCh2YWwpKSByZXR1cm4geyB0eXBlOiBcIndpZGdldFwiLCB2YWx1ZTogdmFsIH07XG4gICAgICAgIGVsc2UgaWYgKGlzQXJyYXkodmFsKSkgcmV0dXJuIHsgdHlwZTogXCJhcnJheVwiLCB2YWx1ZTogdmFsIH07XG4gICAgICAgIGVsc2UgaWYgKGlzTGluayh2YWwpKSByZXR1cm4geyB0eXBlOiBcImxpbmtcIiwgdmFsdWU6IHZhbCB9O1xuICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKHZhbCkpIHJldHVybiB7IHR5cGU6IFwiZnVuY3Rpb25cIiwgdmFsdWU6IHZhbCB9O1xuICAgICAgICBlbHNlIGlmIChpc0h0bWwodmFsKSkgcmV0dXJuIHsgdHlwZTogXCJodG1sXCIsIHZhbHVlOiB2YWwgfTtcbiAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QodmFsKSkgcmV0dXJuIHsgdHlwZTogXCJvYmplY3RcIiwgdmFsdWU6IHZhbCB9O1xuICAgICAgICBlbHNlIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqIFJlY3Vyc2l2ZWx5IG1hcCBjb21wbGV4IG9iamVjdHMgYXQgdGhlIGxlYXZlcy4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gbWFwTGVhdmVzKHZhbDogTGl0ZXJhbCwgZnVuYzogKHQ6IExpdGVyYWwpID0+IExpdGVyYWwpOiBMaXRlcmFsIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQ6IERhdGFPYmplY3QgPSB7fTtcbiAgICAgICAgICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh2YWwpKSByZXN1bHRba2V5XSA9IG1hcExlYXZlcyh2YWx1ZSwgZnVuYyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsKSkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdDogTGl0ZXJhbFtdID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWwpIHJlc3VsdC5wdXNoKG1hcExlYXZlcyh2YWx1ZSwgZnVuYykpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jKHZhbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQ29tcGFyZSB0d28gYXJiaXRyYXJ5IEphdmFTY3JpcHQgdmFsdWVzLiBQcm9kdWNlcyBhIHRvdGFsIG9yZGVyaW5nIG92ZXIgQU5ZIHBvc3NpYmxlIGRhdGF2aWV3IHZhbHVlLiAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiBjb21wYXJlVmFsdWUodmFsMTogTGl0ZXJhbCwgdmFsMjogTGl0ZXJhbCwgbGlua05vcm1hbGl6ZXI/OiAobGluazogc3RyaW5nKSA9PiBzdHJpbmcpOiBudW1iZXIge1xuICAgICAgICAvLyBIYW5kbGUgdW5kZWZpbmVkL251bGxzIGZpcnN0LlxuICAgICAgICBpZiAodmFsMSA9PT0gdW5kZWZpbmVkKSB2YWwxID0gbnVsbDtcbiAgICAgICAgaWYgKHZhbDIgPT09IHVuZGVmaW5lZCkgdmFsMiA9IG51bGw7XG4gICAgICAgIGlmICh2YWwxID09PSBudWxsICYmIHZhbDIgPT09IG51bGwpIHJldHVybiAwO1xuICAgICAgICBlbHNlIGlmICh2YWwxID09PSBudWxsKSByZXR1cm4gLTE7XG4gICAgICAgIGVsc2UgaWYgKHZhbDIgPT09IG51bGwpIHJldHVybiAxO1xuXG4gICAgICAgIC8vIEEgbm9uLW51bGwgdmFsdWUgbm93IHdoaWNoIHdlIGNhbiB3cmFwICYgY29tcGFyZSBvbi5cbiAgICAgICAgbGV0IHdyYXAxID0gd3JhcFZhbHVlKHZhbDEpO1xuICAgICAgICBsZXQgd3JhcDIgPSB3cmFwVmFsdWUodmFsMik7XG5cbiAgICAgICAgaWYgKHdyYXAxID09PSB1bmRlZmluZWQgJiYgd3JhcDIgPT09IHVuZGVmaW5lZCkgcmV0dXJuIDA7XG4gICAgICAgIGVsc2UgaWYgKHdyYXAxID09PSB1bmRlZmluZWQpIHJldHVybiAtMTtcbiAgICAgICAgZWxzZSBpZiAod3JhcDIgPT09IHVuZGVmaW5lZCkgcmV0dXJuIDE7XG5cbiAgICAgICAgLy8gU2hvcnQtY2lyY3VpdCBvbiBkaWZmZXJlbnQgdHlwZXMgb3Igb24gcmVmZXJlbmNlIGVxdWFsaXR5LlxuICAgICAgICBpZiAod3JhcDEudHlwZSAhPSB3cmFwMi50eXBlKSByZXR1cm4gd3JhcDEudHlwZS5sb2NhbGVDb21wYXJlKHdyYXAyLnR5cGUpO1xuICAgICAgICBpZiAod3JhcDEudmFsdWUgPT09IHdyYXAyLnZhbHVlKSByZXR1cm4gMDtcblxuICAgICAgICBzd2l0Y2ggKHdyYXAxLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcDEudmFsdWUubG9jYWxlQ29tcGFyZSh3cmFwMi52YWx1ZSBhcyBzdHJpbmcpO1xuICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgICAgIGlmICh3cmFwMS52YWx1ZSA8ICh3cmFwMi52YWx1ZSBhcyBudW1iZXIpKSByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAod3JhcDEudmFsdWUgPT0gKHdyYXAyLnZhbHVlIGFzIG51bWJlcikpIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgY2FzZSBcIm51bGxcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICAgICAgaWYgKHdyYXAxLnZhbHVlID09IHdyYXAyLnZhbHVlKSByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICBlbHNlIHJldHVybiB3cmFwMS52YWx1ZSA/IDEgOiAtMTtcbiAgICAgICAgICAgIGNhc2UgXCJsaW5rXCI6XG4gICAgICAgICAgICAgICAgbGV0IGxpbmsxID0gd3JhcDEudmFsdWU7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmsyID0gd3JhcDIudmFsdWUgYXMgTGluaztcbiAgICAgICAgICAgICAgICBsZXQgbm9ybWFsaXplID0gbGlua05vcm1hbGl6ZXIgPz8gKCh4OiBzdHJpbmcpID0+IHgpO1xuXG4gICAgICAgICAgICAgICAgLy8gV2UgY2FuJ3QgY29tcGFyZSBieSBmaWxlIG5hbWUgb3IgZGlzcGxheSwgc2luY2UgdGhhdCB3b3VsZCBicmVhayBsaW5rIGVxdWFsaXR5LiBDb21wYXJlIGJ5IHBhdGguXG4gICAgICAgICAgICAgICAgbGV0IHBhdGhDb21wYXJlID0gbm9ybWFsaXplKGxpbmsxLnBhdGgpLmxvY2FsZUNvbXBhcmUobm9ybWFsaXplKGxpbmsyLnBhdGgpKTtcbiAgICAgICAgICAgICAgICBpZiAocGF0aENvbXBhcmUgIT0gMCkgcmV0dXJuIHBhdGhDb21wYXJlO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhlbiBjb21wYXJlIGJ5IHR5cGUuXG4gICAgICAgICAgICAgICAgbGV0IHR5cGVDb21wYXJlID0gbGluazEudHlwZS5sb2NhbGVDb21wYXJlKGxpbmsyLnR5cGUpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlQ29tcGFyZSAhPSAwKSByZXR1cm4gdHlwZUNvbXBhcmU7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGVuIGNvbXBhcmUgYnkgc3VicGF0aCBleGlzdGVuY2UuXG4gICAgICAgICAgICAgICAgaWYgKGxpbmsxLnN1YnBhdGggJiYgIWxpbmsyLnN1YnBhdGgpIHJldHVybiAxO1xuICAgICAgICAgICAgICAgIGlmICghbGluazEuc3VicGF0aCAmJiBsaW5rMi5zdWJwYXRoKSByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgaWYgKCFsaW5rMS5zdWJwYXRoICYmICFsaW5rMi5zdWJwYXRoKSByZXR1cm4gMDtcblxuICAgICAgICAgICAgICAgIC8vIFNpbmNlIGJvdGggaGF2ZSBhIHN1YnBhdGgsIGNvbXBhcmUgYnkgc3VicGF0aC5cbiAgICAgICAgICAgICAgICByZXR1cm4gKGxpbmsxLnN1YnBhdGggPz8gXCJcIikubG9jYWxlQ29tcGFyZShsaW5rMi5zdWJwYXRoID8/IFwiXCIpO1xuICAgICAgICAgICAgY2FzZSBcImRhdGVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcDEudmFsdWUgPCAod3JhcDIudmFsdWUgYXMgRGF0ZVRpbWUpXG4gICAgICAgICAgICAgICAgICAgID8gLTFcbiAgICAgICAgICAgICAgICAgICAgOiB3cmFwMS52YWx1ZS5lcXVhbHMod3JhcDIudmFsdWUgYXMgRGF0ZVRpbWUpXG4gICAgICAgICAgICAgICAgICAgID8gMFxuICAgICAgICAgICAgICAgICAgICA6IDE7XG4gICAgICAgICAgICBjYXNlIFwiZHVyYXRpb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcDEudmFsdWUgPCAod3JhcDIudmFsdWUgYXMgRHVyYXRpb24pXG4gICAgICAgICAgICAgICAgICAgID8gLTFcbiAgICAgICAgICAgICAgICAgICAgOiB3cmFwMS52YWx1ZS5lcXVhbHMod3JhcDIudmFsdWUgYXMgRHVyYXRpb24pXG4gICAgICAgICAgICAgICAgICAgID8gMFxuICAgICAgICAgICAgICAgICAgICA6IDE7XG4gICAgICAgICAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgICAgICAgICBsZXQgZjEgPSB3cmFwMS52YWx1ZTtcbiAgICAgICAgICAgICAgICBsZXQgZjIgPSB3cmFwMi52YWx1ZSBhcyBhbnlbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgTWF0aC5taW4oZjEubGVuZ3RoLCBmMi5sZW5ndGgpOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb21wID0gY29tcGFyZVZhbHVlKGYxW2luZGV4XSwgZjJbaW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXAgIT0gMCkgcmV0dXJuIGNvbXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmMS5sZW5ndGggLSBmMi5sZW5ndGg7XG4gICAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICAgICAgbGV0IG8xID0gd3JhcDEudmFsdWU7XG4gICAgICAgICAgICAgICAgbGV0IG8yID0gd3JhcDIudmFsdWUgYXMgUmVjb3JkPHN0cmluZywgYW55PjtcbiAgICAgICAgICAgICAgICBsZXQgazEgPSBBcnJheS5mcm9tKE9iamVjdC5rZXlzKG8xKSk7XG4gICAgICAgICAgICAgICAgbGV0IGsyID0gQXJyYXkuZnJvbShPYmplY3Qua2V5cyhvMikpO1xuICAgICAgICAgICAgICAgIGsxLnNvcnQoKTtcbiAgICAgICAgICAgICAgICBrMi5zb3J0KCk7XG5cbiAgICAgICAgICAgICAgICBsZXQga2V5Q29tcGFyZSA9IGNvbXBhcmVWYWx1ZShrMSwgazIpO1xuICAgICAgICAgICAgICAgIGlmIChrZXlDb21wYXJlICE9IDApIHJldHVybiBrZXlDb21wYXJlO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQga2V5IG9mIGsxKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb21wID0gY29tcGFyZVZhbHVlKG8xW2tleV0sIG8yW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcCAhPSAwKSByZXR1cm4gY29tcDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIGNhc2UgXCJ3aWRnZXRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJodG1sXCI6XG4gICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBGaW5kIHRoZSBjb3JyZXNwb25kaW5nIERhdGF2ZWl3IHR5cGUgZm9yIGFuIGFyYml0cmFyeSB2YWx1ZS4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gdHlwZU9mKHZhbDogYW55KTogTGl0ZXJhbFR5cGUgfCB1bmRlZmluZWQge1xuICAgICAgICByZXR1cm4gd3JhcFZhbHVlKHZhbCk/LnR5cGU7XG4gICAgfVxuXG4gICAgLyoqIERldGVybWluZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgXCJ0cnV0aHlcIiAoaS5lLiwgaXMgbm9uLW51bGwgYW5kIGhhcyBkYXRhIGluIGl0KS4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gaXNUcnV0aHkoZmllbGQ6IExpdGVyYWwpOiBib29sZWFuIHtcbiAgICAgICAgbGV0IHdyYXBwZWQgPSB3cmFwVmFsdWUoZmllbGQpO1xuICAgICAgICBpZiAoIXdyYXBwZWQpIHJldHVybiBmYWxzZTtcblxuICAgICAgICBzd2l0Y2ggKHdyYXBwZWQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkLnZhbHVlICE9IDA7XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWQudmFsdWUubGVuZ3RoID4gMDtcbiAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWQudmFsdWU7XG4gICAgICAgICAgICBjYXNlIFwibGlua1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiAhIXdyYXBwZWQudmFsdWUucGF0aDtcbiAgICAgICAgICAgIGNhc2UgXCJkYXRlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWQudmFsdWUudG9NaWxsaXMoKSAhPSAwO1xuICAgICAgICAgICAgY2FzZSBcImR1cmF0aW9uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWQudmFsdWUuYXMoXCJzZWNvbmRzXCIpICE9IDA7XG4gICAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHdyYXBwZWQudmFsdWUpLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZC52YWx1ZS5sZW5ndGggPiAwO1xuICAgICAgICAgICAgY2FzZSBcIm51bGxcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYXNlIFwiaHRtbFwiOlxuICAgICAgICAgICAgY2FzZSBcIndpZGdldFwiOlxuICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogRGVlcCBjb3B5IGEgZmllbGQuICovXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGRlZXBDb3B5PFQgZXh0ZW5kcyBMaXRlcmFsPihmaWVsZDogVCk6IFQge1xuICAgICAgICBpZiAoZmllbGQgPT09IG51bGwgfHwgZmllbGQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZpZWxkO1xuXG4gICAgICAgIGlmIChWYWx1ZXMuaXNBcnJheShmaWVsZCkpIHtcbiAgICAgICAgICAgIHJldHVybiAoW10gYXMgTGl0ZXJhbFtdKS5jb25jYXQoZmllbGQubWFwKHYgPT4gZGVlcENvcHkodikpKSBhcyBUO1xuICAgICAgICB9IGVsc2UgaWYgKFZhbHVlcy5pc09iamVjdChmaWVsZCkpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQ6IFJlY29yZDxzdHJpbmcsIExpdGVyYWw+ID0ge307XG4gICAgICAgICAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZmllbGQpKSByZXN1bHRba2V5XSA9IGRlZXBDb3B5KHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgYXMgVDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmaWVsZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZyh2YWw6IGFueSk6IHZhbCBpcyBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbCA9PSBcInN0cmluZ1wiO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBpc051bWJlcih2YWw6IGFueSk6IHZhbCBpcyBudW1iZXIge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbCA9PSBcIm51bWJlclwiO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBpc0RhdGUodmFsOiBhbnkpOiB2YWwgaXMgRGF0ZVRpbWUge1xuICAgICAgICByZXR1cm4gdmFsIGluc3RhbmNlb2YgRGF0ZVRpbWU7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGlzRHVyYXRpb24odmFsOiBhbnkpOiB2YWwgaXMgRHVyYXRpb24ge1xuICAgICAgICByZXR1cm4gdmFsIGluc3RhbmNlb2YgRHVyYXRpb247XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGlzTnVsbCh2YWw6IGFueSk6IHZhbCBpcyBudWxsIHwgdW5kZWZpbmVkIHtcbiAgICAgICAgcmV0dXJuIHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gaXNBcnJheSh2YWw6IGFueSk6IHZhbCBpcyBhbnlbXSB7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbCk7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGlzQm9vbGVhbih2YWw6IGFueSk6IHZhbCBpcyBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09IFwiYm9vbGVhblwiO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBpc0xpbmsodmFsOiBhbnkpOiB2YWwgaXMgTGluayB7XG4gICAgICAgIHJldHVybiB2YWwgaW5zdGFuY2VvZiBMaW5rO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBpc1dpZGdldCh2YWw6IGFueSk6IHZhbCBpcyBXaWRnZXQge1xuICAgICAgICByZXR1cm4gdmFsIGluc3RhbmNlb2YgV2lkZ2V0O1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBpc0h0bWwodmFsOiBhbnkpOiB2YWwgaXMgSFRNTEVsZW1lbnQge1xuICAgICAgICBpZiAodHlwZW9mIEhUTUxFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQ2hlY2tzIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhbiBvYmplY3QgKGFuZCBub3QgYW55IG90aGVyIGRhdGF2aWV3LXJlY29nbml6ZWQgb2JqZWN0LWxpa2UgdHlwZSkuICovXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KHZhbDogYW55KTogdmFsIGlzIFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdHlwZW9mIHZhbCA9PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICAhaXNIdG1sKHZhbCkgJiZcbiAgICAgICAgICAgICFpc1dpZGdldCh2YWwpICYmXG4gICAgICAgICAgICAhaXNBcnJheSh2YWwpICYmXG4gICAgICAgICAgICAhaXNEdXJhdGlvbih2YWwpICYmXG4gICAgICAgICAgICAhaXNEYXRlKHZhbCkgJiZcbiAgICAgICAgICAgICFpc0xpbmsodmFsKSAmJlxuICAgICAgICAgICAgdmFsICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICFpc051bGwodmFsKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbDogYW55KTogdmFsIGlzIEZ1bmN0aW9uIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWwgPT0gXCJmdW5jdGlvblwiO1xuICAgIH1cbn1cblxuLy8vLy8vLy8vLy8vLy8vXG4vLyBHcm91cGluZ3MgLy9cbi8vLy8vLy8vLy8vLy8vL1xuXG5leHBvcnQgbmFtZXNwYWNlIEdyb3VwaW5ncyB7XG4gICAgLyoqIERldGVybWluZXMgaWYgdGhlIGdpdmVuIGdyb3VwIGVudHJ5IGlzIGEgc3RhbmRhbG9uZSB2YWx1ZSwgb3IgYSBncm91cGluZyBvZiBzdWItZW50cmllcy4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gaXNFbGVtZW50R3JvdXA8VD4oZW50cnk6IFQgfCBHcm91cEVsZW1lbnQ8VD4pOiBlbnRyeSBpcyBHcm91cEVsZW1lbnQ8VD4ge1xuICAgICAgICByZXR1cm4gVmFsdWVzLmlzT2JqZWN0KGVudHJ5KSAmJiBPYmplY3Qua2V5cyhlbnRyeSkubGVuZ3RoID09IDIgJiYgXCJrZXlcIiBpbiBlbnRyeSAmJiBcInJvd3NcIiBpbiBlbnRyeTtcbiAgICB9XG5cbiAgICAvKiogRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gYXJyYXkgaXMgYSBncm91cGluZyBhcnJheS4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gaXNHcm91cGluZzxUPihlbnRyeTogR3JvdXBpbmc8VD4pOiBlbnRyeSBpcyBHcm91cEVsZW1lbnQ8VD5bXSB7XG4gICAgICAgIGZvciAobGV0IGVsZW1lbnQgb2YgZW50cnkpIGlmICghaXNFbGVtZW50R3JvdXAoZWxlbWVudCkpIHJldHVybiBmYWxzZTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKiogQ291bnQgdGhlIHRvdGFsIG51bWJlciBvZiBlbGVtZW50cyBpbiBhIHJlY3Vyc2l2ZSBncm91cGluZy4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gY291bnQ8VD4oZWxlbWVudHM6IEdyb3VwaW5nPFQ+KTogbnVtYmVyIHtcbiAgICAgICAgaWYgKGlzR3JvdXBpbmcoZWxlbWVudHMpKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IHN1Ymdyb3VwIG9mIGVsZW1lbnRzKSByZXN1bHQgKz0gY291bnQoc3ViZ3JvdXAucm93cyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8vLy8vLy8vL1xuLy8gTElOSyAvL1xuLy8vLy8vLy8vL1xuXG4vKiogVGhlIE9ic2lkaWFuICdsaW5rJywgdXNlZCBmb3IgdW5pcXVlbHkgZGVzY3JpYmluZyBhIGZpbGUsIGhlYWRlciwgb3IgYmxvY2suICovXG5leHBvcnQgY2xhc3MgTGluayB7XG4gICAgLyoqIFRoZSBmaWxlIHBhdGggdGhpcyBsaW5rIHBvaW50cyB0by4gKi9cbiAgICBwdWJsaWMgcGF0aDogc3RyaW5nO1xuICAgIC8qKiBUaGUgZGlzcGxheSBuYW1lIGFzc29jaWF0ZWQgd2l0aCB0aGUgbGluay4gKi9cbiAgICBwdWJsaWMgZGlzcGxheT86IHN0cmluZztcbiAgICAvKiogVGhlIGJsb2NrIElEIG9yIGhlYWRlciB0aGlzIGxpbmsgcG9pbnRzIHRvIHdpdGhpbiBhIGZpbGUsIGlmIHJlbGV2YW50LiAqL1xuICAgIHB1YmxpYyBzdWJwYXRoPzogc3RyaW5nO1xuICAgIC8qKiBJcyB0aGlzIGxpbmsgYW4gZW1iZWRkZWQgbGluayAoISk/ICovXG4gICAgcHVibGljIGVtYmVkOiBib29sZWFuO1xuICAgIC8qKiBUaGUgdHlwZSBvZiB0aGlzIGxpbmssIHdoaWNoIGRldGVybWluZXMgd2hhdCAnc3VicGF0aCcgcmVmZXJzIHRvLCBpZiBhbnl0aGluZy4gKi9cbiAgICBwdWJsaWMgdHlwZTogXCJmaWxlXCIgfCBcImhlYWRlclwiIHwgXCJibG9ja1wiO1xuXG4gICAgLyoqIENyZWF0ZSBhIGxpbmsgdG8gYSBzcGVjaWZpYyBmaWxlLiAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZmlsZShwYXRoOiBzdHJpbmcsIGVtYmVkOiBib29sZWFuID0gZmFsc2UsIGRpc3BsYXk/OiBzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5rKHtcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBlbWJlZCxcbiAgICAgICAgICAgIGRpc3BsYXksXG4gICAgICAgICAgICBzdWJwYXRoOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBpbmZlcihsaW5rcGF0aDogc3RyaW5nLCBlbWJlZDogYm9vbGVhbiA9IGZhbHNlLCBkaXNwbGF5Pzogc3RyaW5nKSB7XG4gICAgICAgIGlmIChsaW5rcGF0aC5pbmNsdWRlcyhcIiNeXCIpKSB7XG4gICAgICAgICAgICBsZXQgc3BsaXQgPSBsaW5rcGF0aC5zcGxpdChcIiNeXCIpO1xuICAgICAgICAgICAgcmV0dXJuIExpbmsuYmxvY2soc3BsaXRbMF0sIHNwbGl0WzFdLCBlbWJlZCwgZGlzcGxheSk7XG4gICAgICAgIH0gZWxzZSBpZiAobGlua3BhdGguaW5jbHVkZXMoXCIjXCIpKSB7XG4gICAgICAgICAgICBsZXQgc3BsaXQgPSBsaW5rcGF0aC5zcGxpdChcIiNcIik7XG4gICAgICAgICAgICByZXR1cm4gTGluay5oZWFkZXIoc3BsaXRbMF0sIHNwbGl0WzFdLCBlbWJlZCwgZGlzcGxheSk7XG4gICAgICAgIH0gZWxzZSByZXR1cm4gTGluay5maWxlKGxpbmtwYXRoLCBlbWJlZCwgZGlzcGxheSk7XG4gICAgfVxuXG4gICAgLyoqIENyZWF0ZSBhIGxpbmsgdG8gYSBzcGVjaWZpYyBmaWxlIGFuZCBoZWFkZXIgaW4gdGhhdCBmaWxlLiAqL1xuICAgIHB1YmxpYyBzdGF0aWMgaGVhZGVyKHBhdGg6IHN0cmluZywgaGVhZGVyOiBzdHJpbmcsIGVtYmVkPzogYm9vbGVhbiwgZGlzcGxheT86IHN0cmluZykge1xuICAgICAgICAvLyBIZWFkZXJzIG5lZWQgdG8gYmUgbm9ybWFsaXplZCB0byBhbHBoYS1udW1lcmljICYgd2l0aCBleHRyYSBzcGFjaW5nIHJlbW92ZWQuXG4gICAgICAgIHJldHVybiBuZXcgTGluayh7XG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgZW1iZWQsXG4gICAgICAgICAgICBkaXNwbGF5LFxuICAgICAgICAgICAgc3VicGF0aDogbm9ybWFsaXplSGVhZGVyRm9yTGluayhoZWFkZXIpLFxuICAgICAgICAgICAgdHlwZTogXCJoZWFkZXJcIixcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqIENyZWF0ZSBhIGxpbmsgdG8gYSBzcGVjaWZpYyBmaWxlIGFuZCBibG9jayBpbiB0aGF0IGZpbGUuICovXG4gICAgcHVibGljIHN0YXRpYyBibG9jayhwYXRoOiBzdHJpbmcsIGJsb2NrSWQ6IHN0cmluZywgZW1iZWQ/OiBib29sZWFuLCBkaXNwbGF5Pzogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGluayh7XG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgZW1iZWQsXG4gICAgICAgICAgICBkaXNwbGF5LFxuICAgICAgICAgICAgc3VicGF0aDogYmxvY2tJZCxcbiAgICAgICAgICAgIHR5cGU6IFwiYmxvY2tcIixcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBmcm9tT2JqZWN0KG9iamVjdDogUmVjb3JkPHN0cmluZywgYW55Pikge1xuICAgICAgICByZXR1cm4gbmV3IExpbmsob2JqZWN0KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNvbnN0cnVjdG9yKGZpZWxkczogUGFydGlhbDxMaW5rPikge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGZpZWxkcyk7XG4gICAgfVxuXG4gICAgLyoqIENoZWNrcyBmb3IgbGluayBlcXVhbGl0eSAoaS5lLiwgdGhhdCB0aGUgbGlua3MgYXJlIHBvaW50aW5nIHRvIHRoZSBzYW1lIGV4YWN0IGxvY2F0aW9uKS4gKi9cbiAgICBwdWJsaWMgZXF1YWxzKG90aGVyOiBMaW5rKTogYm9vbGVhbiB7XG4gICAgICAgIGlmIChvdGhlciA9PSB1bmRlZmluZWQgfHwgb3RoZXIgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnBhdGggPT0gb3RoZXIucGF0aCAmJiB0aGlzLnR5cGUgPT0gb3RoZXIudHlwZSAmJiB0aGlzLnN1YnBhdGggPT0gb3RoZXIuc3VicGF0aDtcbiAgICB9XG5cbiAgICAvKiogQ29udmVydCB0aGlzIGxpbmsgdG8gaXQncyBtYXJrZG93biByZXByZXNlbnRhdGlvbi4gKi9cbiAgICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFya2Rvd24oKTtcbiAgICB9XG5cbiAgICAvKiogQ29udmVydCB0aGlzIGxpbmsgdG8gYSByYXcgb2JqZWN0IHdoaWNoIGlzIHNlcmlhbGl6YXRpb24tZnJpZW5kbHkuICovXG4gICAgcHVibGljIHRvT2JqZWN0KCk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICAgICAgICByZXR1cm4geyBwYXRoOiB0aGlzLnBhdGgsIHR5cGU6IHRoaXMudHlwZSwgc3VicGF0aDogdGhpcy5zdWJwYXRoLCBkaXNwbGF5OiB0aGlzLmRpc3BsYXksIGVtYmVkOiB0aGlzLmVtYmVkIH07XG4gICAgfVxuXG4gICAgLyoqIFVwZGF0ZSB0aGlzIGxpbmsgd2l0aCBhIG5ldyBwYXRoLiAqL1xuICAgIC8vQHRzLWlnbm9yZTsgZXJyb3IgYXBwZWFyZWQgYWZ0ZXIgdXBkYXRpbmcgT2JzaWRpYW4gdG8gMC4xNS40OyBpdCBhbHNvIHVwZGF0ZWQgb3RoZXIgcGFja2FnZXMgYnV0IGRpZG4ndCBzYXkgd2hpY2hcbiAgICBwdWJsaWMgd2l0aFBhdGgocGF0aDogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGluayhPYmplY3QuYXNzaWduKHt9LCB0aGlzLCB7IHBhdGggfSkpO1xuICAgIH1cblxuICAgIC8qKiBSZXR1cm4gYSBuZXcgbGluayB3aGljaCBwb2ludHMgdG8gdGhlIHNhbWUgbG9jYXRpb24gYnV0IHdpdGggYSBuZXcgZGlzcGxheSB2YWx1ZS4gKi9cbiAgICBwdWJsaWMgd2l0aERpc3BsYXkoZGlzcGxheT86IHN0cmluZykge1xuICAgICAgICByZXR1cm4gbmV3IExpbmsoT2JqZWN0LmFzc2lnbih7fSwgdGhpcywgeyBkaXNwbGF5IH0pKTtcbiAgICB9XG5cbiAgICAvKiogQ29udmVydCBhIGZpbGUgbGluayBpbnRvIGEgbGluayB0byBhIHNwZWNpZmljIGhlYWRlci4gKi9cbiAgICBwdWJsaWMgd2l0aEhlYWRlcihoZWFkZXI6IHN0cmluZykge1xuICAgICAgICByZXR1cm4gTGluay5oZWFkZXIodGhpcy5wYXRoLCBoZWFkZXIsIHRoaXMuZW1iZWQsIHRoaXMuZGlzcGxheSk7XG4gICAgfVxuXG4gICAgLyoqIENvbnZlcnQgYW55IGxpbmsgaW50byBhIGxpbmsgdG8gaXRzIGZpbGUuICovXG4gICAgcHVibGljIHRvRmlsZSgpIHtcbiAgICAgICAgcmV0dXJuIExpbmsuZmlsZSh0aGlzLnBhdGgsIHRoaXMuZW1iZWQsIHRoaXMuZGlzcGxheSk7XG4gICAgfVxuXG4gICAgLyoqIENvbnZlcnQgdGhpcyBsaW5rIGludG8gYW4gZW1iZWRkZWQgbGluay4gKi9cbiAgICBwdWJsaWMgdG9FbWJlZCgpOiBMaW5rIHtcbiAgICAgICAgaWYgKHRoaXMuZW1iZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGxpbmsgPSBuZXcgTGluayh0aGlzKTtcbiAgICAgICAgICAgIGxpbmsuZW1iZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGxpbms7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQ29udmVydCB0aGlzIGxpbmsgaW50byBhIG5vbi1lbWJlZGRlZCBsaW5rLiAqL1xuICAgIHB1YmxpYyBmcm9tRW1iZWQoKTogTGluayB7XG4gICAgICAgIGlmICghdGhpcy5lbWJlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgbGluayA9IG5ldyBMaW5rKHRoaXMpO1xuICAgICAgICAgICAgbGluay5lbWJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIGxpbms7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQ29udmVydCB0aGlzIGxpbmsgdG8gbWFya2Rvd24gc28gaXQgY2FuIGJlIHJlbmRlcmVkLiAqL1xuICAgIHB1YmxpYyBtYXJrZG93bigpOiBzdHJpbmcge1xuICAgICAgICBsZXQgcmVzdWx0ID0gKHRoaXMuZW1iZWQgPyBcIiFcIiA6IFwiXCIpICsgXCJbW1wiICsgdGhpcy5vYnNpZGlhbkxpbmsoKTtcblxuICAgICAgICBpZiAodGhpcy5kaXNwbGF5KSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCJ8XCIgKyB0aGlzLmRpc3BsYXk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCJ8XCIgKyBnZXRGaWxlVGl0bGUodGhpcy5wYXRoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT0gXCJoZWFkZXJcIiB8fCB0aGlzLnR5cGUgPT0gXCJibG9ja1wiKSByZXN1bHQgKz0gXCIgPiBcIiArIHRoaXMuc3VicGF0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCArPSBcIl1dXCI7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqIENvbnZlcnQgdGhlIGlubmVyIHBhcnQgb2YgdGhlIGxpbmsgdG8gc29tZXRoaW5nIHRoYXQgT2JzaWRpYW4gY2FuIG9wZW4gLyB1bmRlcnN0YW5kLiAqL1xuICAgIHB1YmxpYyBvYnNpZGlhbkxpbmsoKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgZXNjYXBlZCA9IHRoaXMucGF0aC5yZXBsYWNlQWxsKFwifFwiLCBcIlxcXFx8XCIpO1xuICAgICAgICBpZiAodGhpcy50eXBlID09IFwiaGVhZGVyXCIpIHJldHVybiBlc2NhcGVkICsgXCIjXCIgKyB0aGlzLnN1YnBhdGg/LnJlcGxhY2VBbGwoXCJ8XCIsIFwiXFxcXHxcIik7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT0gXCJibG9ja1wiKSByZXR1cm4gZXNjYXBlZCArIFwiI15cIiArIHRoaXMuc3VicGF0aD8ucmVwbGFjZUFsbChcInxcIiwgXCJcXFxcfFwiKTtcbiAgICAgICAgZWxzZSByZXR1cm4gZXNjYXBlZDtcbiAgICB9XG5cbiAgICAvKiogVGhlIHN0cmlwcGVkIG5hbWUgb2YgdGhlIGZpbGUgdGhpcyBsaW5rIHBvaW50cyB0by4gKi9cbiAgICBwdWJsaWMgZmlsZU5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIGdldEZpbGVUaXRsZSh0aGlzLnBhdGgpLnJlcGxhY2UoXCIubWRcIiwgXCJcIik7XG4gICAgfVxufVxuXG4vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0lER0VUIEJBU0UgLy9cbi8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQSB0cml2aWFsIGJhc2UgY2xhc3Mgd2hpY2gganVzdCBkZWZpbmVzIHRoZSAnJHdpZGdldCcgaWRlbnRpZmllciB0eXBlLiBTdWJ0eXBlcyBvZlxuICogd2lkZ2V0IGFyZSByZXNwb25zaWJsZSBmb3IgYWRkaW5nIHdoYXRldmVyIG1ldGFkYXRhIGlzIHJlbGV2YW50LiBJZiB5b3Ugd2FudCB5b3VyIHdpZGdldFxuICogdG8gaGF2ZSByZW5kZXJpbmcgZnVuY3Rpb25hbGl0eSAod2hpY2ggeW91IHByb2JhYmx5IGRvKSwgeW91IHNob3VsZCBleHRlbmQgYFJlbmRlcldpZGdldGAuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBXaWRnZXQge1xuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihwdWJsaWMgJHdpZGdldDogc3RyaW5nKSB7fVxuXG4gICAgLyoqXG4gICAgICogQXR0ZW1wdCB0byByZW5kZXIgdGhpcyB3aWRnZXQgaW4gbWFya2Rvd24sIGlmIHBvc3NpYmxlOyBpZiBtYXJrZG93biBpcyBub3QgcG9zc2libGUsXG4gICAgICogdGhlbiB0aGlzIHdpbGwgYXR0ZW1wdCB0byByZW5kZXIgYXMgSFRNTC4gTm90ZSB0aGF0IG1hbnkgd2lkZ2V0cyBoYXZlIGludGVyYWN0aXZlXG4gICAgICogY29tcG9uZW50cyBvciBkaWZmaWN1bHQgZnVuY3Rpb25hbCBjb21wb25lbnRzIGFuZCB0aGUgYG1hcmtkb3duYCBmdW5jdGlvbiBjYW4gc2ltcGx5XG4gICAgICogcmV0dXJuIGEgcGxhY2Vob2xkZXIgaW4gdGhpcyBjYXNlIChzdWNoIGFzIGA8ZnVuY3Rpb24+YCBvciBgPHRhc2stbGlzdD5gKS5cbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgbWFya2Rvd24oKTogc3RyaW5nO1xufVxuXG4vKiogQSB0cml2aWFsIHdpZGdldCB3aGljaCByZW5kZXJzIGEgKGtleSwgdmFsdWUpIHBhaXIsIGFuZCBhbGxvd3MgYWNjZXNzaW5nIHRoZSBrZXkgYW5kIHZhbHVlLiAqL1xuZXhwb3J0IGNsYXNzIExpc3RQYWlyV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0IHtcbiAgICBwdWJsaWMgY29uc3RydWN0b3IocHVibGljIGtleTogTGl0ZXJhbCwgcHVibGljIHZhbHVlOiBMaXRlcmFsKSB7XG4gICAgICAgIHN1cGVyKFwiZGF0YXZpZXc6bGlzdC1wYWlyXCIpO1xuICAgIH1cblxuICAgIHB1YmxpYyBvdmVycmlkZSBtYXJrZG93bigpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gYCR7VmFsdWVzLnRvU3RyaW5nKHRoaXMua2V5KX06ICR7VmFsdWVzLnRvU3RyaW5nKHRoaXMudmFsdWUpfWA7XG4gICAgfVxufVxuXG4vKiogQSBzaW1wbGUgd2lkZ2V0IHdoaWNoIHJlbmRlcnMgYW4gZXh0ZXJuYWwgbGluay4gKi9cbmV4cG9ydCBjbGFzcyBFeHRlcm5hbExpbmtXaWRnZXQgZXh0ZW5kcyBXaWRnZXQge1xuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihwdWJsaWMgdXJsOiBzdHJpbmcsIHB1YmxpYyBkaXNwbGF5Pzogc3RyaW5nKSB7XG4gICAgICAgIHN1cGVyKFwiZGF0YXZpZXc6ZXh0ZXJuYWwtbGlua1wiKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb3ZlcnJpZGUgbWFya2Rvd24oKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIGBbJHt0aGlzLmRpc3BsYXkgPz8gdGhpcy51cmx9XSgke3RoaXMudXJsfSlgO1xuICAgIH1cbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBXaWRnZXRzIHtcbiAgICAvKiogQ3JlYXRlIGEgbGlzdCBwYWlyIHdpZGdldCBtYXRjaGluZyB0aGUgZ2l2ZW4ga2V5IGFuZCB2YWx1ZS4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gbGlzdFBhaXIoa2V5OiBMaXRlcmFsLCB2YWx1ZTogTGl0ZXJhbCk6IExpc3RQYWlyV2lkZ2V0IHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaXN0UGFpcldpZGdldChrZXksIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKiogQ3JlYXRlIGFuIGV4dGVybmFsIGxpbmsgd2lkZ2V0IHdoaWNoIHJlbmRlcnMgYW4gZXh0ZXJuYWwgT2JzaWRpYW4gbGluay4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gZXh0ZXJuYWxMaW5rKHVybDogc3RyaW5nLCBkaXNwbGF5Pzogc3RyaW5nKTogRXh0ZXJuYWxMaW5rV2lkZ2V0IHtcbiAgICAgICAgcmV0dXJuIG5ldyBFeHRlcm5hbExpbmtXaWRnZXQodXJsLCBkaXNwbGF5KTtcbiAgICB9XG5cbiAgICAvKiogQ2hlY2tzIGlmIHRoZSBnaXZlbiB3aWRnZXQgaXMgYSBsaXN0IHBhaXIgd2lkZ2V0LiAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiBpc0xpc3RQYWlyKHdpZGdldDogV2lkZ2V0KTogd2lkZ2V0IGlzIExpc3RQYWlyV2lkZ2V0IHtcbiAgICAgICAgcmV0dXJuIHdpZGdldC4kd2lkZ2V0ID09PSBcImRhdGF2aWV3Omxpc3QtcGFpclwiO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBpc0V4dGVybmFsTGluayh3aWRnZXQ6IFdpZGdldCk6IHdpZGdldCBpcyBFeHRlcm5hbExpbmtXaWRnZXQge1xuICAgICAgICByZXR1cm4gd2lkZ2V0LiR3aWRnZXQgPT09IFwiZGF0YXZpZXc6ZXh0ZXJuYWwtbGlua1wiO1xuICAgIH1cblxuICAgIC8qKiBEZXRlcm1pbmVzIGlmIHRoZSBnaXZlbiB3aWRnZXQgaXMgYW55IGtpbmQgb2YgYnVpbHQtaW4gd2lkZ2V0IHdpdGggc3BlY2lhbCByZW5kZXJpbmcgaGFuZGxpbmcuICovXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGlzQnVpbHRpbih3aWRnZXQ6IFdpZGdldCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gaXNMaXN0UGFpcih3aWRnZXQpIHx8IGlzRXh0ZXJuYWxMaW5rKHdpZGdldCk7XG4gICAgfVxufVxuIiwgIi8qKiBEZWZpbmVzIHRoZSBBU1QgZm9yIGEgZmllbGQgd2hpY2ggY2FuIGJlIGV2YWx1YXRlZC4gKi9cbmltcG9ydCB7IExpdGVyYWwgfSBmcm9tIFwiZGF0YS1tb2RlbC92YWx1ZVwiO1xuXG4vKiogQ29tcGFyaXNvbiBvcGVyYXRvcnMgd2hpY2ggeWllbGQgdHJ1ZS9mYWxzZS4gKi9cbmV4cG9ydCB0eXBlIENvbXBhcmVPcCA9IFwiPlwiIHwgXCI+PVwiIHwgXCI8PVwiIHwgXCI8XCIgfCBcIj1cIiB8IFwiIT1cIjtcbi8qKiBBcml0aG1ldGljIG9wZXJhdG9ycyB3aGljaCB5aWVsZCBudW1iZXJzIGFuZCBvdGhlciB2YWx1ZXMuICovXG5leHBvcnQgdHlwZSBBcml0aG1ldGljT3AgPSBcIitcIiB8IFwiLVwiIHwgXCIqXCIgfCBcIi9cIiB8IFwiJVwiIHwgXCImXCIgfCBcInxcIjtcbi8qKiBBbGwgdmFsaWQgYmluYXJ5IG9wZXJhdG9ycy4gKi9cbmV4cG9ydCB0eXBlIEJpbmFyeU9wID0gQ29tcGFyZU9wIHwgQXJpdGhtZXRpY09wO1xuLyoqIEEgKHBvdGVudGlhbGx5IGNvbXB1dGVkKSBmaWVsZCB0byBzZWxlY3Qgb3IgY29tcGFyZSBhZ2FpbnN0LiAqL1xuZXhwb3J0IHR5cGUgRmllbGQgPVxuICAgIHwgQmluYXJ5T3BGaWVsZFxuICAgIHwgVmFyaWFibGVGaWVsZFxuICAgIHwgTGl0ZXJhbEZpZWxkXG4gICAgfCBGdW5jdGlvbkZpZWxkXG4gICAgfCBJbmRleEZpZWxkXG4gICAgfCBOZWdhdGVkRmllbGRcbiAgICB8IExhbWJkYUZpZWxkXG4gICAgfCBPYmplY3RGaWVsZFxuICAgIHwgTGlzdEZpZWxkO1xuXG4vKiogTGl0ZXJhbCByZXByZXNlbnRhdGlvbiBvZiBzb21lIGZpZWxkIHR5cGUuICovXG5leHBvcnQgaW50ZXJmYWNlIExpdGVyYWxGaWVsZCB7XG4gICAgdHlwZTogXCJsaXRlcmFsXCI7XG4gICAgdmFsdWU6IExpdGVyYWw7XG59XG5cbi8qKiBBIHZhcmlhYmxlIGZpZWxkIGZvciBhIHZhcmlhYmxlIHdpdGggYSBnaXZlbiBuYW1lLiAqL1xuZXhwb3J0IGludGVyZmFjZSBWYXJpYWJsZUZpZWxkIHtcbiAgICB0eXBlOiBcInZhcmlhYmxlXCI7XG4gICAgbmFtZTogc3RyaW5nO1xufVxuXG4vKiogQSBsaXN0LCB3aGljaCBpcyBhbiBvcmRlcmVkIGNvbGxlY3Rpb24gb2YgZmllbGRzLiAqL1xuZXhwb3J0IGludGVyZmFjZSBMaXN0RmllbGQge1xuICAgIHR5cGU6IFwibGlzdFwiO1xuICAgIHZhbHVlczogRmllbGRbXTtcbn1cblxuLyoqIEFuIG9iamVjdCwgd2hpY2ggaXMgYSBtYXBwaW5nIG9mIG5hbWUgdG8gZmllbGQuICovXG5leHBvcnQgaW50ZXJmYWNlIE9iamVjdEZpZWxkIHtcbiAgICB0eXBlOiBcIm9iamVjdFwiO1xuICAgIHZhbHVlczogUmVjb3JkPHN0cmluZywgRmllbGQ+O1xufVxuXG4vKiogQSBiaW5hcnkgb3BlcmF0b3IgZmllbGQgd2hpY2ggY29tYmluZXMgdHdvIHN1Ym5vZGVzIHNvbWVob3cuICovXG5leHBvcnQgaW50ZXJmYWNlIEJpbmFyeU9wRmllbGQge1xuICAgIHR5cGU6IFwiYmluYXJ5b3BcIjtcbiAgICBsZWZ0OiBGaWVsZDtcbiAgICByaWdodDogRmllbGQ7XG4gICAgb3A6IEJpbmFyeU9wO1xufVxuXG4vKiogQSBmdW5jdGlvbiBmaWVsZCB3aGljaCBjYWxscyBhIGZ1bmN0aW9uIG9uIDAgb3IgbW9yZSBhcmd1bWVudHMuICovXG5leHBvcnQgaW50ZXJmYWNlIEZ1bmN0aW9uRmllbGQge1xuICAgIHR5cGU6IFwiZnVuY3Rpb25cIjtcbiAgICAvKiogRWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiBiZWluZyBjYWxsZWQsIG9yIGEgRnVuY3Rpb24gb2JqZWN0LiAqL1xuICAgIGZ1bmM6IEZpZWxkO1xuICAgIC8qKiBUaGUgYXJndW1lbnRzIGJlaW5nIHBhc3NlZCB0byB0aGUgZnVuY3Rpb24uICovXG4gICAgYXJndW1lbnRzOiBGaWVsZFtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExhbWJkYUZpZWxkIHtcbiAgICB0eXBlOiBcImxhbWJkYVwiO1xuICAgIC8qKiBBbiBvcmRlcmVkIGxpc3Qgb2YgbmFtZWQgYXJndW1lbnRzLiAqL1xuICAgIGFyZ3VtZW50czogc3RyaW5nW107XG4gICAgLyoqIFRoZSBmaWVsZCB3aGljaCBzaG91bGQgYmUgZXZhbHVhdGVkIHdpdGggdGhlIGFyZ3VtZW50cyBpbiBjb250ZXh0LiAqL1xuICAgIHZhbHVlOiBGaWVsZDtcbn1cblxuLyoqIEEgZmllbGQgd2hpY2ggaW5kZXhlcyBhIHZhcmlhYmxlIGludG8gYW5vdGhlciB2YXJpYWJsZS4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW5kZXhGaWVsZCB7XG4gICAgdHlwZTogXCJpbmRleFwiO1xuICAgIC8qKiBUaGUgZmllbGQgdG8gaW5kZXggaW50by4gKi9cbiAgICBvYmplY3Q6IEZpZWxkO1xuICAgIC8qKiBUaGUgaW5kZXguICovXG4gICAgaW5kZXg6IEZpZWxkO1xufVxuXG4vKiogQSBmaWVsZCB3aGljaCBuZWdhdGVzIHRoZSB2YWx1ZSBvZiB0aGUgb3JpZ2luYWwgZmllbGQuICovXG5leHBvcnQgaW50ZXJmYWNlIE5lZ2F0ZWRGaWVsZCB7XG4gICAgdHlwZTogXCJuZWdhdGVkXCI7XG4gICAgLyoqIFRoZSBjaGlsZCBmaWVsZCB0byBuZWdhdGVkLiAqL1xuICAgIGNoaWxkOiBGaWVsZDtcbn1cblxuLyoqIFV0aWxpdHkgbWV0aG9kcyBmb3IgY3JlYXRpbmcgJiBjb21wYXJpbmcgZmllbGRzLiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBGaWVsZHMge1xuICAgIGV4cG9ydCBmdW5jdGlvbiB2YXJpYWJsZShuYW1lOiBzdHJpbmcpOiBWYXJpYWJsZUZpZWxkIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJ2YXJpYWJsZVwiLCBuYW1lIH07XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGxpdGVyYWwodmFsdWU6IExpdGVyYWwpOiBMaXRlcmFsRmllbGQge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWUgfTtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gYmluYXJ5T3AobGVmdDogRmllbGQsIG9wOiBCaW5hcnlPcCwgcmlnaHQ6IEZpZWxkKTogRmllbGQge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImJpbmFyeW9wXCIsIGxlZnQsIG9wLCByaWdodCB9IGFzIEJpbmFyeU9wRmllbGQ7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGluZGV4KG9iajogRmllbGQsIGluZGV4OiBGaWVsZCk6IEluZGV4RmllbGQge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImluZGV4XCIsIG9iamVjdDogb2JqLCBpbmRleCB9O1xuICAgIH1cblxuICAgIC8qKiBDb252ZXJ0cyBhIHN0cmluZyBpbiBkb3Qtbm90YXRpb24tZm9ybWF0IGludG8gYSB2YXJpYWJsZSB3aGljaCBpbmRleGVzLiAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiBpbmRleFZhcmlhYmxlKG5hbWU6IHN0cmluZyk6IEZpZWxkIHtcbiAgICAgICAgbGV0IHBhcnRzID0gbmFtZS5zcGxpdChcIi5cIik7XG4gICAgICAgIGxldCByZXN1bHQ6IEZpZWxkID0gRmllbGRzLnZhcmlhYmxlKHBhcnRzWzBdKTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAxOyBpbmRleCA8IHBhcnRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgcmVzdWx0ID0gRmllbGRzLmluZGV4KHJlc3VsdCwgRmllbGRzLmxpdGVyYWwocGFydHNbaW5kZXhdKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBsYW1iZGEoYXJnczogc3RyaW5nW10sIHZhbHVlOiBGaWVsZCk6IExhbWJkYUZpZWxkIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJsYW1iZGFcIiwgYXJndW1lbnRzOiBhcmdzLCB2YWx1ZSB9O1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBmdW5jKGZ1bmM6IEZpZWxkLCBhcmdzOiBGaWVsZFtdKTogRnVuY3Rpb25GaWVsZCB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiZnVuY3Rpb25cIiwgZnVuYywgYXJndW1lbnRzOiBhcmdzIH07XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGxpc3QodmFsdWVzOiBGaWVsZFtdKTogTGlzdEZpZWxkIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJsaXN0XCIsIHZhbHVlcyB9O1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBvYmplY3QodmFsdWVzOiBSZWNvcmQ8c3RyaW5nLCBGaWVsZD4pOiBPYmplY3RGaWVsZCB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwib2JqZWN0XCIsIHZhbHVlcyB9O1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBuZWdhdGUoY2hpbGQ6IEZpZWxkKTogTmVnYXRlZEZpZWxkIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJuZWdhdGVkXCIsIGNoaWxkIH07XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGlzQ29tcGFyZU9wKG9wOiBCaW5hcnlPcCk6IG9wIGlzIENvbXBhcmVPcCB7XG4gICAgICAgIHJldHVybiBvcCA9PSBcIjw9XCIgfHwgb3AgPT0gXCI8XCIgfHwgb3AgPT0gXCI+XCIgfHwgb3AgPT0gXCI+PVwiIHx8IG9wID09IFwiIT1cIiB8fCBvcCA9PSBcIj1cIjtcbiAgICB9XG5cbiAgICBleHBvcnQgY29uc3QgTlVMTCA9IEZpZWxkcy5saXRlcmFsKG51bGwpO1xufVxuIiwgIi8qKiBBU1QgaW1wbGVtZW50YXRpb24gZm9yIHF1ZXJpZXMgb3ZlciBkYXRhIHNvdXJjZXMuICovXG5cbi8qKiBUaGUgc291cmNlIG9mIGZpbGVzIGZvciBhIHF1ZXJ5LiAqL1xuZXhwb3J0IHR5cGUgU291cmNlID0gVGFnU291cmNlIHwgQ3N2U291cmNlIHwgRm9sZGVyU291cmNlIHwgTGlua1NvdXJjZSB8IEVtcHR5U291cmNlIHwgTmVnYXRlZFNvdXJjZSB8IEJpbmFyeU9wU291cmNlO1xuLyoqIFZhbGlkIG9wZXJhdGlvbnMgZm9yIGNvbWJpbmluZyBzb3VyY2VzLiAqL1xuZXhwb3J0IHR5cGUgU291cmNlT3AgPSBcIiZcIiB8IFwifFwiO1xuXG4vKiogQSB0YWcgYXMgYSBzb3VyY2Ugb2YgZGF0YS4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGFnU291cmNlIHtcbiAgICB0eXBlOiBcInRhZ1wiO1xuICAgIC8qKiBUaGUgdGFnIHRvIHNvdXJjZSBmcm9tLiAqL1xuICAgIHRhZzogc3RyaW5nO1xufVxuXG4vKiogQSBjc3YgYXMgYSBzb3VyY2Ugb2YgZGF0YS4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ3N2U291cmNlIHtcbiAgICB0eXBlOiBcImNzdlwiO1xuICAgIC8qKiBUaGUgcGF0aCB0byB0aGUgQ1NWIGZpbGUuICovXG4gICAgcGF0aDogc3RyaW5nO1xufVxuXG4vKiogQSBmb2xkZXIgcHJlZml4IGFzIGEgc291cmNlIG9mIGRhdGEuICovXG5leHBvcnQgaW50ZXJmYWNlIEZvbGRlclNvdXJjZSB7XG4gICAgdHlwZTogXCJmb2xkZXJcIjtcbiAgICAvKiogVGhlIGZvbGRlciBwcmVmaXggdG8gc291cmNlIGZyb20uICovXG4gICAgZm9sZGVyOiBzdHJpbmc7XG59XG5cbi8qKiBFaXRoZXIgaW5jb21pbmcgb3Igb3V0Z29pbmcgbGlua3MgdG8gYSBnaXZlbiBmaWxlLiAqL1xuZXhwb3J0IGludGVyZmFjZSBMaW5rU291cmNlIHtcbiAgICB0eXBlOiBcImxpbmtcIjtcbiAgICAvKiogVGhlIGZpbGUgdG8gbG9vayBmb3IgbGlua3MgdG8vZnJvbS4gICovXG4gICAgZmlsZTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRoZSBkaXJlY3Rpb24gdG8gbG9vayAtIGlmIGluY29taW5nLCB0aGVuIGFsbCBmaWxlcyBsaW5raW5nIHRvIHRoZSB0YXJnZXQgZmlsZS4gSWYgb3V0Z29pbmcsIHRoZW4gYWxsIGZpbGVzXG4gICAgICogd2hpY2ggdGhlIGZpbGUgbGlua3MgdG8uXG4gICAgICovXG4gICAgZGlyZWN0aW9uOiBcImluY29taW5nXCIgfCBcIm91dGdvaW5nXCI7XG59XG5cbi8qKiBBIHNvdXJjZSB3aGljaCBpcyBldmVyeXRoaW5nIEVYQ0VQVCB0aGUgZmlsZXMgcmV0dXJuZWQgYnkgdGhlIGdpdmVuIHNvdXJjZS4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmVnYXRlZFNvdXJjZSB7XG4gICAgdHlwZTogXCJuZWdhdGVcIjtcbiAgICAvKiogVGhlIHNvdXJjZSB0byBuZWdhdGUuICovXG4gICAgY2hpbGQ6IFNvdXJjZTtcbn1cblxuLyoqIEEgc291cmNlIHdoaWNoIHlpZWxkcyBub3RoaW5nLiAqL1xuZXhwb3J0IGludGVyZmFjZSBFbXB0eVNvdXJjZSB7XG4gICAgdHlwZTogXCJlbXB0eVwiO1xufVxuXG4vKiogQSBzb3VyY2UgbWFkZSBieSBjb21iaW5pbmcgc3Vic291cmNlcyB3aXRoIGEgbG9naWNhbCBvcGVyYXRvcnMuICovXG5leHBvcnQgaW50ZXJmYWNlIEJpbmFyeU9wU291cmNlIHtcbiAgICB0eXBlOiBcImJpbmFyeW9wXCI7XG4gICAgb3A6IFNvdXJjZU9wO1xuICAgIGxlZnQ6IFNvdXJjZTtcbiAgICByaWdodDogU291cmNlO1xufVxuXG4vKiogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIGNyZWF0aW5nIGFuZCBtYW5pcHVsYXRpbmcgc291cmNlcy4gKi9cbmV4cG9ydCBuYW1lc3BhY2UgU291cmNlcyB7XG4gICAgLyoqIENyZWF0ZSBhIHNvdXJjZSB3aGljaCBzZWFyY2hlcyBmcm9tIGEgdGFnLiAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiB0YWcodGFnOiBzdHJpbmcpOiBUYWdTb3VyY2Uge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcInRhZ1wiLCB0YWcgfTtcbiAgICB9XG5cbiAgICAvKiogQ3JlYXRlIGEgc291cmNlIHdoaWNoIGZldGNoZXMgZnJvbSBhIENTViBmaWxlLiAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiBjc3YocGF0aDogc3RyaW5nKTogQ3N2U291cmNlIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJjc3ZcIiwgcGF0aCB9O1xuICAgIH1cblxuICAgIC8qKiBDcmVhdGUgYSBzb3VyY2Ugd2hpY2ggc2VhcmNoZXMgZm9yIGZpbGVzIHVuZGVyIGEgZm9sZGVyIHByZWZpeC4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gZm9sZGVyKHByZWZpeDogc3RyaW5nKTogRm9sZGVyU291cmNlIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJmb2xkZXJcIiwgZm9sZGVyOiBwcmVmaXggfTtcbiAgICB9XG5cbiAgICAvKiogQ3JlYXRlIGEgc291cmNlIHdoaWNoIHNlYXJjaGVzIGZvciBmaWxlcyB3aGljaCBsaW5rIHRvL2Zyb20gYSBnaXZlbiBmaWxlLiAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiBsaW5rKGZpbGU6IHN0cmluZywgaW5jb21pbmc6IGJvb2xlYW4pOiBMaW5rU291cmNlIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJsaW5rXCIsIGZpbGUsIGRpcmVjdGlvbjogaW5jb21pbmcgPyBcImluY29taW5nXCIgOiBcIm91dGdvaW5nXCIgfTtcbiAgICB9XG5cbiAgICAvKiogQ3JlYXRlIGEgc291cmNlIHdoaWNoIGpvaW5zIHR3byBzb3VyY2VzIGJ5IGEgbG9naWNhbCBvcGVyYXRvciAoYW5kL29yKS4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gYmluYXJ5T3AobGVmdDogU291cmNlLCBvcDogU291cmNlT3AsIHJpZ2h0OiBTb3VyY2UpOiBTb3VyY2Uge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImJpbmFyeW9wXCIsIGxlZnQsIG9wLCByaWdodCB9O1xuICAgIH1cblxuICAgIC8qKiBDcmVhdGUgYSBzb3VyY2Ugd2hpY2ggdGFrZXMgdGhlIGludGVyc2VjdGlvbiBvZiB0d28gc291cmNlcy4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gYW5kKGxlZnQ6IFNvdXJjZSwgcmlnaHQ6IFNvdXJjZSk6IFNvdXJjZSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiYmluYXJ5b3BcIiwgbGVmdCwgb3A6IFwiJlwiLCByaWdodCB9O1xuICAgIH1cblxuICAgIC8qKiBDcmVhdGUgYSBzb3VyY2Ugd2hpY2ggdGFrZXMgdGhlIHVuaW9uIG9mIHR3byBzb3VyY2VzLiAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiBvcihsZWZ0OiBTb3VyY2UsIHJpZ2h0OiBTb3VyY2UpOiBTb3VyY2Uge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImJpbmFyeW9wXCIsIGxlZnQsIG9wOiBcInxcIiwgcmlnaHQgfTtcbiAgICB9XG5cbiAgICAvKiogQ3JlYXRlIGEgc291cmNlIHdoaWNoIG5lZ2F0ZXMgdGhlIHVuZGVybHlpbmcgc291cmNlLiAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiBuZWdhdGUoY2hpbGQ6IFNvdXJjZSk6IE5lZ2F0ZWRTb3VyY2Uge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcIm5lZ2F0ZVwiLCBjaGlsZCB9O1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBlbXB0eSgpOiBFbXB0eVNvdXJjZSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiZW1wdHlcIiB9O1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBEYXRlVGltZSwgRHVyYXRpb24gfSBmcm9tIFwibHV4b25cIjtcbmltcG9ydCB7IExpdGVyYWwsIExpbmsgfSBmcm9tIFwiZGF0YS1tb2RlbC92YWx1ZVwiO1xuaW1wb3J0ICogYXMgUCBmcm9tIFwicGFyc2ltbW9uXCI7XG5pbXBvcnQgeyBCaW5hcnlPcCwgRmllbGQsIEZpZWxkcywgTGFtYmRhRmllbGQsIExpc3RGaWVsZCwgTGl0ZXJhbEZpZWxkLCBPYmplY3RGaWVsZCwgVmFyaWFibGVGaWVsZCB9IGZyb20gXCIuL2ZpZWxkXCI7XG5pbXBvcnQgeyBGb2xkZXJTb3VyY2UsIE5lZ2F0ZWRTb3VyY2UsIFNvdXJjZSwgU291cmNlT3AsIFNvdXJjZXMsIFRhZ1NvdXJjZSwgQ3N2U291cmNlIH0gZnJvbSBcImRhdGEtaW5kZXgvc291cmNlXCI7XG5pbXBvcnQgeyBub3JtYWxpemVEdXJhdGlvbiB9IGZyb20gXCJ1dGlsL25vcm1hbGl6ZVwiO1xuaW1wb3J0IHsgUmVzdWx0IH0gZnJvbSBcImFwaS9yZXN1bHRcIjtcbmltcG9ydCBlbW9qaVJlZ2V4IGZyb20gXCJlbW9qaS1yZWdleFwiO1xuXG4vKiogRW1vamkgcmVnZXggd2l0aG91dCBhbnkgYWRkaXRpb25hbCBmbGFncy4gKi9cbmNvbnN0IEVNT0pJX1JFR0VYID0gbmV3IFJlZ0V4cChlbW9qaVJlZ2V4KCksIFwiXCIpO1xuXG4vKiogUHJvdmlkZXMgYSBsb29rdXAgdGFibGUgZm9yIHVuaXQgZHVyYXRpb25zIG9mIHRoZSBnaXZlbiB0eXBlLiAqL1xuZXhwb3J0IGNvbnN0IERVUkFUSU9OX1RZUEVTID0ge1xuICAgIHllYXI6IER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMSB9KSxcbiAgICB5ZWFyczogRHVyYXRpb24uZnJvbU9iamVjdCh7IHllYXJzOiAxIH0pLFxuICAgIHlyOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgeWVhcnM6IDEgfSksXG4gICAgeXJzOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgeWVhcnM6IDEgfSksXG5cbiAgICBtb250aDogRHVyYXRpb24uZnJvbU9iamVjdCh7IG1vbnRoczogMSB9KSxcbiAgICBtb250aHM6IER1cmF0aW9uLmZyb21PYmplY3QoeyBtb250aHM6IDEgfSksXG4gICAgbW86IER1cmF0aW9uLmZyb21PYmplY3QoeyBtb250aHM6IDEgfSksXG4gICAgbW9zOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbW9udGhzOiAxIH0pLFxuXG4gICAgd2VlazogRHVyYXRpb24uZnJvbU9iamVjdCh7IHdlZWtzOiAxIH0pLFxuICAgIHdlZWtzOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgd2Vla3M6IDEgfSksXG4gICAgd2s6IER1cmF0aW9uLmZyb21PYmplY3QoeyB3ZWVrczogMSB9KSxcbiAgICB3a3M6IER1cmF0aW9uLmZyb21PYmplY3QoeyB3ZWVrczogMSB9KSxcbiAgICB3OiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgd2Vla3M6IDEgfSksXG5cbiAgICBkYXk6IER1cmF0aW9uLmZyb21PYmplY3QoeyBkYXlzOiAxIH0pLFxuICAgIGRheXM6IER1cmF0aW9uLmZyb21PYmplY3QoeyBkYXlzOiAxIH0pLFxuICAgIGQ6IER1cmF0aW9uLmZyb21PYmplY3QoeyBkYXlzOiAxIH0pLFxuXG4gICAgaG91cjogRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxIH0pLFxuICAgIGhvdXJzOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDEgfSksXG4gICAgaHI6IER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMSB9KSxcbiAgICBocnM6IER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMSB9KSxcbiAgICBoOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDEgfSksXG5cbiAgICBtaW51dGU6IER1cmF0aW9uLmZyb21PYmplY3QoeyBtaW51dGVzOiAxIH0pLFxuICAgIG1pbnV0ZXM6IER1cmF0aW9uLmZyb21PYmplY3QoeyBtaW51dGVzOiAxIH0pLFxuICAgIG1pbjogRHVyYXRpb24uZnJvbU9iamVjdCh7IG1pbnV0ZXM6IDEgfSksXG4gICAgbWluczogRHVyYXRpb24uZnJvbU9iamVjdCh7IG1pbnV0ZXM6IDEgfSksXG4gICAgbTogRHVyYXRpb24uZnJvbU9iamVjdCh7IG1pbnV0ZXM6IDEgfSksXG5cbiAgICBzZWNvbmQ6IER1cmF0aW9uLmZyb21PYmplY3QoeyBzZWNvbmRzOiAxIH0pLFxuICAgIHNlY29uZHM6IER1cmF0aW9uLmZyb21PYmplY3QoeyBzZWNvbmRzOiAxIH0pLFxuICAgIHNlYzogRHVyYXRpb24uZnJvbU9iamVjdCh7IHNlY29uZHM6IDEgfSksXG4gICAgc2VjczogRHVyYXRpb24uZnJvbU9iamVjdCh7IHNlY29uZHM6IDEgfSksXG4gICAgczogRHVyYXRpb24uZnJvbU9iamVjdCh7IHNlY29uZHM6IDEgfSksXG59O1xuXG4vKiogU2hvcnRoYW5kIGZvciBjb21tb24gZGF0ZXMgKHJlbGF0aXZlIHRvIHJpZ2h0IG5vdykuICovXG5leHBvcnQgY29uc3QgREFURV9TSE9SVEhBTkRTID0ge1xuICAgIG5vdzogKCkgPT4gRGF0ZVRpbWUubG9jYWwoKSxcbiAgICB0b2RheTogKCkgPT4gRGF0ZVRpbWUubG9jYWwoKS5zdGFydE9mKFwiZGF5XCIpLFxuICAgIHllc3RlcmRheTogKCkgPT5cbiAgICAgICAgRGF0ZVRpbWUubG9jYWwoKVxuICAgICAgICAgICAgLnN0YXJ0T2YoXCJkYXlcIilcbiAgICAgICAgICAgIC5taW51cyhEdXJhdGlvbi5mcm9tT2JqZWN0KHsgZGF5czogMSB9KSksXG4gICAgdG9tb3Jyb3c6ICgpID0+XG4gICAgICAgIERhdGVUaW1lLmxvY2FsKClcbiAgICAgICAgICAgIC5zdGFydE9mKFwiZGF5XCIpXG4gICAgICAgICAgICAucGx1cyhEdXJhdGlvbi5mcm9tT2JqZWN0KHsgZGF5czogMSB9KSksXG4gICAgc293OiAoKSA9PiBEYXRlVGltZS5sb2NhbCgpLnN0YXJ0T2YoXCJ3ZWVrXCIpLFxuICAgIFwic3RhcnQtb2Ytd2Vla1wiOiAoKSA9PiBEYXRlVGltZS5sb2NhbCgpLnN0YXJ0T2YoXCJ3ZWVrXCIpLFxuICAgIGVvdzogKCkgPT4gRGF0ZVRpbWUubG9jYWwoKS5lbmRPZihcIndlZWtcIiksXG4gICAgXCJlbmQtb2Ytd2Vla1wiOiAoKSA9PiBEYXRlVGltZS5sb2NhbCgpLmVuZE9mKFwid2Vla1wiKSxcbiAgICBzb3k6ICgpID0+IERhdGVUaW1lLmxvY2FsKCkuc3RhcnRPZihcInllYXJcIiksXG4gICAgXCJzdGFydC1vZi15ZWFyXCI6ICgpID0+IERhdGVUaW1lLmxvY2FsKCkuc3RhcnRPZihcInllYXJcIiksXG4gICAgZW95OiAoKSA9PiBEYXRlVGltZS5sb2NhbCgpLmVuZE9mKFwieWVhclwiKSxcbiAgICBcImVuZC1vZi15ZWFyXCI6ICgpID0+IERhdGVUaW1lLmxvY2FsKCkuZW5kT2YoXCJ5ZWFyXCIpLFxuICAgIHNvbTogKCkgPT4gRGF0ZVRpbWUubG9jYWwoKS5zdGFydE9mKFwibW9udGhcIiksXG4gICAgXCJzdGFydC1vZi1tb250aFwiOiAoKSA9PiBEYXRlVGltZS5sb2NhbCgpLnN0YXJ0T2YoXCJtb250aFwiKSxcbiAgICBlb206ICgpID0+IERhdGVUaW1lLmxvY2FsKCkuZW5kT2YoXCJtb250aFwiKSxcbiAgICBcImVuZC1vZi1tb250aFwiOiAoKSA9PiBEYXRlVGltZS5sb2NhbCgpLmVuZE9mKFwibW9udGhcIiksXG59O1xuXG4vKipcbiAqIEtleXdvcmRzIHdoaWNoIGNhbm5vdCBiZSB1c2VkIGFzIHZhcmlhYmxlcyBkaXJlY3RseS4gVXNlIGByb3cuPHRoaW5nPmAgaWYgaXQgaXMgYSB2YXJpYWJsZSB5b3UgaGF2ZSBkZWZpbmVkIGFuZCB3YW50XG4gKiB0byBhY2Nlc3MuXG4gKi9cbmV4cG9ydCBjb25zdCBLRVlXT1JEUyA9IFtcIkZST01cIiwgXCJXSEVSRVwiLCBcIkxJTUlUXCIsIFwiR1JPVVBcIiwgXCJGTEFUVEVOXCJdO1xuXG4vLy8vLy8vLy8vLy8vLy9cbi8vIFV0aWxpdGllcyAvL1xuLy8vLy8vLy8vLy8vLy8vXG5cbi8qKiBTcGxpdCBvbiB1bmVzY2FwZWQgcGlwZXMgaW4gYW4gaW5uZXIgbGluay4gKi9cbmZ1bmN0aW9uIHNwbGl0T25VbmVzY2FwZWRQaXBlKGxpbms6IHN0cmluZyk6IFtzdHJpbmcsIHN0cmluZyB8IHVuZGVmaW5lZF0ge1xuICAgIGxldCBwaXBlID0gLTE7XG4gICAgd2hpbGUgKChwaXBlID0gbGluay5pbmRleE9mKFwifFwiLCBwaXBlICsgMSkpID49IDApIHtcbiAgICAgICAgaWYgKHBpcGUgPiAwICYmIGxpbmtbcGlwZSAtIDFdID09IFwiXFxcXFwiKSBjb250aW51ZTtcbiAgICAgICAgcmV0dXJuIFtsaW5rLnN1YnN0cmluZygwLCBwaXBlKS5yZXBsYWNlKC9cXFxcXFx8L2csIFwifFwiKSwgbGluay5zdWJzdHJpbmcocGlwZSArIDEpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gW2xpbmsucmVwbGFjZSgvXFxcXFxcfC9nLCBcInxcIiksIHVuZGVmaW5lZF07XG59XG5cbi8qKiBBdHRlbXB0IHRvIHBhcnNlIHRoZSBpbnNpZGUgb2YgYSBsaW5rIHRvIHB1bGwgb3V0IGRpc3BsYXkgbmFtZSwgc3VicGF0aCwgZXRjLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSW5uZXJMaW5rKHJhd2xpbms6IHN0cmluZyk6IExpbmsge1xuICAgIGxldCBbbGluaywgZGlzcGxheV0gPSBzcGxpdE9uVW5lc2NhcGVkUGlwZShyYXdsaW5rKTtcbiAgICByZXR1cm4gTGluay5pbmZlcihsaW5rLCBmYWxzZSwgZGlzcGxheSk7XG59XG5cbi8qKiBDcmVhdGUgYSBsZWZ0LWFzc29jaWF0aXZlIGJpbmFyeSBwYXJzZXIgd2hpY2ggcGFyc2VzIHRoZSBnaXZlbiBzdWItZWxlbWVudCBhbmQgc2VwYXJhdG9yLiBIYW5kbGVzIHdoaXRlc3BhY2UuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQmluYXJ5UGFyc2VyPFQsIFU+KFxuICAgIGNoaWxkOiBQLlBhcnNlcjxUPixcbiAgICBzZXA6IFAuUGFyc2VyPFU+LFxuICAgIGNvbWJpbmU6IChhOiBULCBiOiBVLCBjOiBUKSA9PiBUXG4pOiBQLlBhcnNlcjxUPiB7XG4gICAgcmV0dXJuIFAuc2VxTWFwKGNoaWxkLCBQLnNlcShQLm9wdFdoaXRlc3BhY2UsIHNlcCwgUC5vcHRXaGl0ZXNwYWNlLCBjaGlsZCkubWFueSgpLCAoZmlyc3QsIHJlc3QpID0+IHtcbiAgICAgICAgaWYgKHJlc3QubGVuZ3RoID09IDApIHJldHVybiBmaXJzdDtcblxuICAgICAgICBsZXQgbm9kZSA9IGNvbWJpbmUoZmlyc3QsIHJlc3RbMF1bMV0sIHJlc3RbMF1bM10pO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDE7IGluZGV4IDwgcmVzdC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIG5vZGUgPSBjb21iaW5lKG5vZGUsIHJlc3RbaW5kZXhdWzFdLCByZXN0W2luZGV4XVszXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGFpbk9wdDxUPihiYXNlOiBQLlBhcnNlcjxUPiwgLi4uZnVuY3M6ICgocjogVCkgPT4gUC5QYXJzZXI8VD4pW10pOiBQLlBhcnNlcjxUPiB7XG4gICAgcmV0dXJuIFAuY3VzdG9tKChzdWNjZXNzLCBmYWlsdXJlKSA9PiB7XG4gICAgICAgIHJldHVybiAoaW5wdXQsIGkpID0+IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSAoYmFzZSBhcyBhbnkpLl8oaW5wdXQsIGkpO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQuc3RhdHVzKSByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgICAgICBmb3IgKGxldCBmdW5jIG9mIGZ1bmNzKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSAoZnVuYyhyZXN1bHQudmFsdWUgYXMgVCkgYXMgYW55KS5fKGlucHV0LCByZXN1bHQuaW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmICghbmV4dC5zdGF0dXMpIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXh0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgIH0pO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEV4cHJlc3Npb24gUGFyc2luZyAvL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmV4cG9ydCB0eXBlIFBvc3RmaXhGcmFnbWVudCA9XG4gICAgfCB7IHR5cGU6IFwiZG90XCI7IGZpZWxkOiBzdHJpbmcgfVxuICAgIHwgeyB0eXBlOiBcImluZGV4XCI7IGZpZWxkOiBGaWVsZCB9XG4gICAgfCB7IHR5cGU6IFwiZnVuY3Rpb25cIjsgZmllbGRzOiBGaWVsZFtdIH07XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXhwcmVzc2lvbkxhbmd1YWdlIHtcbiAgICBudW1iZXI6IG51bWJlcjtcbiAgICBzdHJpbmc6IHN0cmluZztcbiAgICBlc2NhcGVDaGFyYWN0ZXI6IHN0cmluZztcbiAgICBib29sOiBib29sZWFuO1xuICAgIHRhZzogc3RyaW5nO1xuICAgIGlkZW50aWZpZXI6IHN0cmluZztcbiAgICBsaW5rOiBMaW5rO1xuICAgIGVtYmVkTGluazogTGluaztcbiAgICByb290RGF0ZTogRGF0ZVRpbWU7XG4gICAgZGF0ZVNob3J0aGFuZDoga2V5b2YgdHlwZW9mIERBVEVfU0hPUlRIQU5EUztcbiAgICBkYXRlOiBEYXRlVGltZTtcbiAgICBkYXRlUGx1czogRGF0ZVRpbWU7XG4gICAgZHVyYXRpb25UeXBlOiBrZXlvZiB0eXBlb2YgRFVSQVRJT05fVFlQRVM7XG4gICAgZHVyYXRpb246IER1cmF0aW9uO1xuICAgIHJhd051bGw6IHN0cmluZztcblxuICAgIGJpbmFyeVBsdXNNaW51czogQmluYXJ5T3A7XG4gICAgYmluYXJ5TXVsRGl2OiBCaW5hcnlPcDtcbiAgICBiaW5hcnlDb21wYXJlT3A6IEJpbmFyeU9wO1xuICAgIGJpbmFyeUJvb2xlYW5PcDogQmluYXJ5T3A7XG5cbiAgICAvLyBTb3VyY2UtcmVsYXRlZCBwYXJzZXJzLlxuICAgIHRhZ1NvdXJjZTogVGFnU291cmNlO1xuICAgIGNzdlNvdXJjZTogQ3N2U291cmNlO1xuICAgIGZvbGRlclNvdXJjZTogRm9sZGVyU291cmNlO1xuICAgIHBhcmVuc1NvdXJjZTogU291cmNlO1xuICAgIGF0b21Tb3VyY2U6IFNvdXJjZTtcbiAgICBsaW5rSW5jb21pbmdTb3VyY2U6IFNvdXJjZTtcbiAgICBsaW5rT3V0Z29pbmdTb3VyY2U6IFNvdXJjZTtcbiAgICBuZWdhdGVTb3VyY2U6IE5lZ2F0ZWRTb3VyY2U7XG4gICAgYmluYXJ5T3BTb3VyY2U6IFNvdXJjZTtcbiAgICBzb3VyY2U6IFNvdXJjZTtcblxuICAgIC8vIEZpZWxkLXJlbGF0ZWQgcGFyc2Vycy5cbiAgICB2YXJpYWJsZUZpZWxkOiBWYXJpYWJsZUZpZWxkO1xuICAgIG51bWJlckZpZWxkOiBMaXRlcmFsRmllbGQ7XG4gICAgYm9vbEZpZWxkOiBMaXRlcmFsRmllbGQ7XG4gICAgc3RyaW5nRmllbGQ6IExpdGVyYWxGaWVsZDtcbiAgICBkYXRlRmllbGQ6IExpdGVyYWxGaWVsZDtcbiAgICBkdXJhdGlvbkZpZWxkOiBMaXRlcmFsRmllbGQ7XG4gICAgbGlua0ZpZWxkOiBMaXRlcmFsRmllbGQ7XG4gICAgbnVsbEZpZWxkOiBMaXRlcmFsRmllbGQ7XG5cbiAgICBsaXN0RmllbGQ6IExpc3RGaWVsZDtcbiAgICBvYmplY3RGaWVsZDogT2JqZWN0RmllbGQ7XG5cbiAgICBhdG9tSW5saW5lRmllbGQ6IExpdGVyYWw7XG4gICAgaW5saW5lRmllbGRMaXN0OiBMaXRlcmFsW107XG4gICAgaW5saW5lRmllbGQ6IExpdGVyYWw7XG5cbiAgICBuZWdhdGVkRmllbGQ6IEZpZWxkO1xuICAgIGF0b21GaWVsZDogRmllbGQ7XG4gICAgaW5kZXhGaWVsZDogRmllbGQ7XG4gICAgbGFtYmRhRmllbGQ6IExhbWJkYUZpZWxkO1xuXG4gICAgLy8gUG9zdGZpeCBwYXJzZXJzIGZvciBmdW5jdGlvbiBjYWxscyAmIHRoZSBsaWtlLlxuICAgIGRvdFBvc3RmaXg6IFBvc3RmaXhGcmFnbWVudDtcbiAgICBpbmRleFBvc3RmaXg6IFBvc3RmaXhGcmFnbWVudDtcbiAgICBmdW5jdGlvblBvc3RmaXg6IFBvc3RmaXhGcmFnbWVudDtcblxuICAgIC8vIEJpbmFyeSBvcCBwYXJzZXJzLlxuICAgIGJpbmFyeU11bERpdkZpZWxkOiBGaWVsZDtcbiAgICBiaW5hcnlQbHVzTWludXNGaWVsZDogRmllbGQ7XG4gICAgYmluYXJ5Q29tcGFyZUZpZWxkOiBGaWVsZDtcbiAgICBiaW5hcnlCb29sZWFuRmllbGQ6IEZpZWxkO1xuICAgIGJpbmFyeU9wRmllbGQ6IEZpZWxkO1xuICAgIHBhcmVuc0ZpZWxkOiBGaWVsZDtcbiAgICBmaWVsZDogRmllbGQ7XG59XG5cbmV4cG9ydCBjb25zdCBFWFBSRVNTSU9OID0gUC5jcmVhdGVMYW5ndWFnZTxFeHByZXNzaW9uTGFuZ3VhZ2U+KHtcbiAgICAvLyBBIGZsb2F0aW5nIHBvaW50IG51bWJlcjsgdGhlIGRlY2ltYWwgcG9pbnQgaXMgb3B0aW9uYWwuXG4gICAgbnVtYmVyOiBxID0+XG4gICAgICAgIFAucmVnZXhwKC8tP1swLTldKyhcXC5bMC05XSspPy8pXG4gICAgICAgICAgICAubWFwKHN0ciA9PiBOdW1iZXIucGFyc2VGbG9hdChzdHIpKVxuICAgICAgICAgICAgLmRlc2MoXCJudW1iZXJcIiksXG5cbiAgICAvLyBBIHF1b3RlLXN1cnJvdW5kZWQgc3RyaW5nIHdoaWNoIHN1cHBvcnRzIGVzY2FwZSBjaGFyYWN0ZXJzICgnXFwnKS5cbiAgICBzdHJpbmc6IHEgPT5cbiAgICAgICAgUC5zdHJpbmcoJ1wiJylcbiAgICAgICAgICAgIC50aGVuKFxuICAgICAgICAgICAgICAgIFAuYWx0KHEuZXNjYXBlQ2hhcmFjdGVyLCBQLm5vbmVPZignXCJcXFxcJykpXG4gICAgICAgICAgICAgICAgICAgIC5hdExlYXN0KDApXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoY2hhcnMgPT4gY2hhcnMuam9pbihcIlwiKSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5za2lwKFAuc3RyaW5nKCdcIicpKVxuICAgICAgICAgICAgLmRlc2MoXCJzdHJpbmdcIiksXG5cbiAgICBlc2NhcGVDaGFyYWN0ZXI6IF8gPT5cbiAgICAgICAgUC5zdHJpbmcoXCJcXFxcXCIpXG4gICAgICAgICAgICAudGhlbihQLmFueSlcbiAgICAgICAgICAgIC5tYXAoZXNjYXBlZCA9PiB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgYXJlIGVzY2FwaW5nIGEgYmFja3NsYXNoIG9yIGEgcXVvdGUsIHBhc3MgaW4gb24gaW4gZXNjYXBlZCBmb3JtXG4gICAgICAgICAgICAgICAgaWYgKGVzY2FwZWQgPT09ICdcIicpIHJldHVybiAnXCInO1xuICAgICAgICAgICAgICAgIGlmIChlc2NhcGVkID09PSBcIlxcXFxcIikgcmV0dXJuIFwiXFxcXFwiO1xuICAgICAgICAgICAgICAgIGVsc2UgcmV0dXJuIFwiXFxcXFwiICsgZXNjYXBlZDtcbiAgICAgICAgICAgIH0pLFxuXG4gICAgLy8gQSBib29sZWFuIHRydWUvZmFsc2UgdmFsdWUuXG4gICAgYm9vbDogXyA9PlxuICAgICAgICBQLnJlZ2V4cCgvdHJ1ZXxmYWxzZXxUcnVlfEZhbHNlLylcbiAgICAgICAgICAgIC5tYXAoc3RyID0+IHN0ci50b0xvd2VyQ2FzZSgpID09IFwidHJ1ZVwiKVxuICAgICAgICAgICAgLmRlc2MoXCJib29sZWFuICgndHJ1ZScgb3IgJ2ZhbHNlJylcIiksXG5cbiAgICAvLyBBIHRhZyBvZiB0aGUgZm9ybSAnI3N0dWZmL2hlbGxvLXRoZXJlJy5cbiAgICB0YWc6IF8gPT5cbiAgICAgICAgUC5zZXFNYXAoXG4gICAgICAgICAgICBQLnN0cmluZyhcIiNcIiksXG4gICAgICAgICAgICBQLmFsdChQLnJlZ2V4cCgvW15cXHUyMDAwLVxcdTIwNkZcXHUyRTAwLVxcdTJFN0YnIVwiIyQlJigpKissLjo7PD0+P0BeYHt8fX5cXFtcXF1cXFxcXFxzXS8pLmRlc2MoXCJ0ZXh0XCIpKS5tYW55KCksXG4gICAgICAgICAgICAoc3RhcnQsIHJlc3QpID0+IHN0YXJ0ICsgcmVzdC5qb2luKFwiXCIpXG4gICAgICAgICkuZGVzYyhcInRhZyAoJyNoZWxsby9zdHVmZicpXCIpLFxuXG4gICAgLy8gQSB2YXJpYWJsZSBpZGVudGlmaWVyLCB3aGljaCBpcyBhbHBoYW51bWVyaWMgYW5kIG11c3Qgc3RhcnQgd2l0aCBhIGxldHRlciBvci4uLiBlbW9qaS5cbiAgICBpZGVudGlmaWVyOiBfID0+XG4gICAgICAgIFAuc2VxTWFwKFxuICAgICAgICAgICAgUC5hbHQoUC5yZWdleHAoL1xccHtMZXR0ZXJ9L3UpLCBQLnJlZ2V4cChFTU9KSV9SRUdFWCkuZGVzYyhcInRleHRcIikpLFxuICAgICAgICAgICAgUC5hbHQoUC5yZWdleHAoL1swLTlcXHB7TGV0dGVyfV8tXS91KSwgUC5yZWdleHAoRU1PSklfUkVHRVgpLmRlc2MoXCJ0ZXh0XCIpKS5tYW55KCksXG4gICAgICAgICAgICAoZmlyc3QsIHJlc3QpID0+IGZpcnN0ICsgcmVzdC5qb2luKFwiXCIpXG4gICAgICAgICkuZGVzYyhcInZhcmlhYmxlIGlkZW50aWZpZXJcIiksXG5cbiAgICAvLyBBbiBPYnNpZGlhbiBsaW5rIG9mIHRoZSBmb3JtIFtbPGxpbms+XV0uXG4gICAgbGluazogXyA9PlxuICAgICAgICBQLnJlZ2V4cCgvXFxbXFxbKFteXFxbXFxdXSo/KVxcXVxcXS91LCAxKVxuICAgICAgICAgICAgLm1hcChsaW5rSW5uZXIgPT4gcGFyc2VJbm5lckxpbmsobGlua0lubmVyKSlcbiAgICAgICAgICAgIC5kZXNjKFwiZmlsZSBsaW5rXCIpLFxuXG4gICAgLy8gQW4gZW1iZWRkYWJsZSBsaW5rIHdoaWNoIGNhbiBzdGFydCB3aXRoICchJy4gVGhpcyBvdmVybGFwcyB3aXRoIHRoZSBub3JtYWwgbmVnYXRpb24gb3BlcmF0b3IsIHNvIGl0IGlzIG9ubHlcbiAgICAvLyBwcm92aWRlZCBmb3IgbWV0YWRhdGEgcGFyc2luZy5cbiAgICBlbWJlZExpbms6IHEgPT5cbiAgICAgICAgUC5zZXFNYXAoUC5zdHJpbmcoXCIhXCIpLmF0TW9zdCgxKSwgcS5saW5rLCAocCwgbCkgPT4ge1xuICAgICAgICAgICAgaWYgKHAubGVuZ3RoID4gMCkgbC5lbWJlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gbDtcbiAgICAgICAgfSkuZGVzYyhcImZpbGUgbGlua1wiKSxcblxuICAgIC8vIEJpbmFyeSBwbHVzIG9yIG1pbnVzIG9wZXJhdG9yLlxuICAgIGJpbmFyeVBsdXNNaW51czogXyA9PlxuICAgICAgICBQLnJlZ2V4cCgvXFwrfC0vKVxuICAgICAgICAgICAgLm1hcChzdHIgPT4gc3RyIGFzIEJpbmFyeU9wKVxuICAgICAgICAgICAgLmRlc2MoXCInKycgb3IgJy0nXCIpLFxuXG4gICAgLy8gQmluYXJ5IHRpbWVzIG9yIGRpdmlkZSBvcGVyYXRvci5cbiAgICBiaW5hcnlNdWxEaXY6IF8gPT5cbiAgICAgICAgUC5yZWdleHAoL1xcKnxcXC98JS8pXG4gICAgICAgICAgICAubWFwKHN0ciA9PiBzdHIgYXMgQmluYXJ5T3ApXG4gICAgICAgICAgICAuZGVzYyhcIicqJyBvciAnLycgb3IgJyUnXCIpLFxuXG4gICAgLy8gQmluYXJ5IGNvbXBhcmlzb24gb3BlcmF0b3IuXG4gICAgYmluYXJ5Q29tcGFyZU9wOiBfID0+XG4gICAgICAgIFAucmVnZXhwKC8+PXw8PXwhPXw+fDx8PS8pXG4gICAgICAgICAgICAubWFwKHN0ciA9PiBzdHIgYXMgQmluYXJ5T3ApXG4gICAgICAgICAgICAuZGVzYyhcIic+PScgb3IgJzw9JyBvciAnIT0nIG9yICc9JyBvciAnPicgb3IgJzwnXCIpLFxuXG4gICAgLy8gQmluYXJ5IGJvb2xlYW4gY29tYmluYXRpb24gb3BlcmF0b3IuXG4gICAgYmluYXJ5Qm9vbGVhbk9wOiBfID0+XG4gICAgICAgIFAucmVnZXhwKC9hbmR8b3J8JnxcXHwvaSlcbiAgICAgICAgICAgIC5tYXAoc3RyID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc3RyLnRvTG93ZXJDYXNlKCkgPT0gXCJhbmRcIikgcmV0dXJuIFwiJlwiO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0ci50b0xvd2VyQ2FzZSgpID09IFwib3JcIikgcmV0dXJuIFwifFwiO1xuICAgICAgICAgICAgICAgIGVsc2UgcmV0dXJuIHN0ciBhcyBCaW5hcnlPcDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZGVzYyhcIidhbmQnIG9yICdvcidcIiksXG5cbiAgICAvLyBBIGRhdGUgd2hpY2ggY2FuIGJlIFlZWVktTU1bLUREVEhIOm1tOnNzXS5cbiAgICByb290RGF0ZTogXyA9PlxuICAgICAgICBQLnNlcU1hcChQLnJlZ2V4cCgvXFxkezR9LyksIFAuc3RyaW5nKFwiLVwiKSwgUC5yZWdleHAoL1xcZHsyfS8pLCAoeWVhciwgXywgbW9udGgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBEYXRlVGltZS5mcm9tT2JqZWN0KHsgeWVhcjogTnVtYmVyLnBhcnNlSW50KHllYXIpLCBtb250aDogTnVtYmVyLnBhcnNlSW50KG1vbnRoKSB9KTtcbiAgICAgICAgfSkuZGVzYyhcImRhdGUgaW4gZm9ybWF0IFlZWVktTU1bLUREVEhILU1NLVNTLk1TXVwiKSxcbiAgICBkYXRlU2hvcnRoYW5kOiBfID0+XG4gICAgICAgIFAuYWx0KFxuICAgICAgICAgICAgLi4uT2JqZWN0LmtleXMoREFURV9TSE9SVEhBTkRTKVxuICAgICAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBiLmxlbmd0aCAtIGEubGVuZ3RoKVxuICAgICAgICAgICAgICAgIC5tYXAoUC5zdHJpbmcpXG4gICAgICAgICkgYXMgUC5QYXJzZXI8a2V5b2YgdHlwZW9mIERBVEVfU0hPUlRIQU5EUz4sXG4gICAgZGF0ZTogcSA9PlxuICAgICAgICBjaGFpbk9wdDxEYXRlVGltZT4oXG4gICAgICAgICAgICBxLnJvb3REYXRlLFxuICAgICAgICAgICAgKHltOiBEYXRlVGltZSkgPT5cbiAgICAgICAgICAgICAgICBQLnNlcU1hcChQLnN0cmluZyhcIi1cIiksIFAucmVnZXhwKC9cXGR7Mn0vKSwgKF8sIGRheSkgPT4geW0uc2V0KHsgZGF5OiBOdW1iZXIucGFyc2VJbnQoZGF5KSB9KSksXG4gICAgICAgICAgICAoeW1kOiBEYXRlVGltZSkgPT5cbiAgICAgICAgICAgICAgICBQLnNlcU1hcChQLnN0cmluZyhcIlRcIiksIFAucmVnZXhwKC9cXGR7Mn0vKSwgKF8sIGhvdXIpID0+IHltZC5zZXQoeyBob3VyOiBOdW1iZXIucGFyc2VJbnQoaG91cikgfSkpLFxuICAgICAgICAgICAgKHltZGg6IERhdGVUaW1lKSA9PlxuICAgICAgICAgICAgICAgIFAuc2VxTWFwKFAuc3RyaW5nKFwiOlwiKSwgUC5yZWdleHAoL1xcZHsyfS8pLCAoXywgbWludXRlKSA9PlxuICAgICAgICAgICAgICAgICAgICB5bWRoLnNldCh7IG1pbnV0ZTogTnVtYmVyLnBhcnNlSW50KG1pbnV0ZSkgfSlcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKHltZGhtOiBEYXRlVGltZSkgPT5cbiAgICAgICAgICAgICAgICBQLnNlcU1hcChQLnN0cmluZyhcIjpcIiksIFAucmVnZXhwKC9cXGR7Mn0vKSwgKF8sIHNlY29uZCkgPT5cbiAgICAgICAgICAgICAgICAgICAgeW1kaG0uc2V0KHsgc2Vjb25kOiBOdW1iZXIucGFyc2VJbnQoc2Vjb25kKSB9KVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAoeW1kaG1zOiBEYXRlVGltZSkgPT5cbiAgICAgICAgICAgICAgICBQLmFsdChcbiAgICAgICAgICAgICAgICAgICAgUC5zZXFNYXAoUC5zdHJpbmcoXCIuXCIpLCBQLnJlZ2V4cCgvXFxkezN9LyksIChfLCBtaWxsaXNlY29uZCkgPT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHltZGhtcy5zZXQoeyBtaWxsaXNlY29uZDogTnVtYmVyLnBhcnNlSW50KG1pbGxpc2Vjb25kKSB9KVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBQLnN1Y2NlZWQoeW1kaG1zKSAvLyBwYXNzXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIChkdDogRGF0ZVRpbWUpID0+XG4gICAgICAgICAgICAgICAgUC5hbHQoXG4gICAgICAgICAgICAgICAgICAgIFAuc2VxTWFwKFAuc3RyaW5nKFwiK1wiKS5vcihQLnN0cmluZyhcIi1cIikpLCBQLnJlZ2V4cCgvXFxkezEsMn0oOlxcZHsyfSk/LyksIChwbSwgaHIpID0+XG4gICAgICAgICAgICAgICAgICAgICAgICBkdC5zZXRab25lKFwiVVRDXCIgKyBwbSArIGhyLCB7IGtlZXBMb2NhbFRpbWU6IHRydWUgfSlcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgUC5zZXFNYXAoUC5zdHJpbmcoXCJaXCIpLCAoKSA9PiBkdC5zZXRab25lKFwidXRjXCIsIHsga2VlcExvY2FsVGltZTogdHJ1ZSB9KSksXG4gICAgICAgICAgICAgICAgICAgIFAuc2VxTWFwKFAuc3RyaW5nKFwiW1wiKSwgUC5yZWdleHAoL1swLTlBLVphLXorLVxcL10rL3UpLCBQLnN0cmluZyhcIl1cIiksIChfYSwgem9uZSwgX2IpID0+XG4gICAgICAgICAgICAgICAgICAgICAgICBkdC5zZXRab25lKHpvbmUsIHsga2VlcExvY2FsVGltZTogdHJ1ZSB9KVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICApXG4gICAgICAgICAgICAuYXNzZXJ0KChkdDogRGF0ZVRpbWUpID0+IGR0LmlzVmFsaWQsIFwidmFsaWQgZGF0ZVwiKVxuICAgICAgICAgICAgLmRlc2MoXCJkYXRlIGluIGZvcm1hdCBZWVlZLU1NWy1ERFRISC1NTS1TUy5NU11cIiksXG5cbiAgICAvLyBBIGRhdGUsIHBsdXMgdmFyaW91cyBzaG9ydGhhbmQgdGltZXMgb2YgZGF5IGl0IGNvdWxkIGJlLlxuICAgIGRhdGVQbHVzOiBxID0+XG4gICAgICAgIFAuYWx0PERhdGVUaW1lPihcbiAgICAgICAgICAgIHEuZGF0ZVNob3J0aGFuZC5tYXAoZCA9PiBEQVRFX1NIT1JUSEFORFNbZF0oKSksXG4gICAgICAgICAgICBxLmRhdGVcbiAgICAgICAgKS5kZXNjKFwiZGF0ZSBpbiBmb3JtYXQgWVlZWS1NTVstRERUSEgtTU0tU1MuTVNdIG9yIGluIHNob3J0aGFuZFwiKSxcblxuICAgIC8vIEEgZHVyYXRpb24gb2YgdGltZS5cbiAgICBkdXJhdGlvblR5cGU6IF8gPT5cbiAgICAgICAgUC5hbHQoXG4gICAgICAgICAgICAuLi5PYmplY3Qua2V5cyhEVVJBVElPTl9UWVBFUylcbiAgICAgICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYi5sZW5ndGggLSBhLmxlbmd0aClcbiAgICAgICAgICAgICAgICAubWFwKFAuc3RyaW5nKVxuICAgICAgICApIGFzIFAuUGFyc2VyPGtleW9mIHR5cGVvZiBEVVJBVElPTl9UWVBFUz4sXG4gICAgZHVyYXRpb246IHEgPT5cbiAgICAgICAgUC5zZXFNYXAocS5udW1iZXIsIFAub3B0V2hpdGVzcGFjZSwgcS5kdXJhdGlvblR5cGUsIChjb3VudCwgXywgdCkgPT4gRFVSQVRJT05fVFlQRVNbdF0ubWFwVW5pdHMoeCA9PiB4ICogY291bnQpKVxuICAgICAgICAgICAgLnNlcEJ5MShQLnN0cmluZyhcIixcIikudHJpbShQLm9wdFdoaXRlc3BhY2UpLm9yKFAub3B0V2hpdGVzcGFjZSkpXG4gICAgICAgICAgICAubWFwKGR1cmF0aW9ucyA9PiBkdXJhdGlvbnMucmVkdWNlKChwLCBjKSA9PiBwLnBsdXMoYykpKVxuICAgICAgICAgICAgLmRlc2MoXCJkdXJhdGlvbiBsaWtlIDRocjJtaW5cIiksXG5cbiAgICAvLyBBIHJhdyBudWxsIHZhbHVlLlxuICAgIHJhd051bGw6IF8gPT4gUC5zdHJpbmcoXCJudWxsXCIpLFxuXG4gICAgLy8gU291cmNlIHBhcnNpbmcuXG4gICAgdGFnU291cmNlOiBxID0+IHEudGFnLm1hcCh0YWcgPT4gU291cmNlcy50YWcodGFnKSksXG4gICAgY3N2U291cmNlOiBxID0+XG4gICAgICAgIFAuc2VxTWFwKFAuc3RyaW5nKFwiY3N2KFwiKS5za2lwKFAub3B0V2hpdGVzcGFjZSksIHEuc3RyaW5nLCBQLnN0cmluZyhcIilcIiksIChfMSwgcGF0aCwgXzIpID0+IFNvdXJjZXMuY3N2KHBhdGgpKSxcbiAgICBsaW5rSW5jb21pbmdTb3VyY2U6IHEgPT4gcS5saW5rLm1hcChsaW5rID0+IFNvdXJjZXMubGluayhsaW5rLnBhdGgsIHRydWUpKSxcbiAgICBsaW5rT3V0Z29pbmdTb3VyY2U6IHEgPT5cbiAgICAgICAgUC5zZXFNYXAoUC5zdHJpbmcoXCJvdXRnb2luZyhcIikuc2tpcChQLm9wdFdoaXRlc3BhY2UpLCBxLmxpbmssIFAuc3RyaW5nKFwiKVwiKSwgKF8xLCBsaW5rLCBfMikgPT5cbiAgICAgICAgICAgIFNvdXJjZXMubGluayhsaW5rLnBhdGgsIGZhbHNlKVxuICAgICAgICApLFxuICAgIGZvbGRlclNvdXJjZTogcSA9PiBxLnN0cmluZy5tYXAoc3RyID0+IFNvdXJjZXMuZm9sZGVyKHN0cikpLFxuICAgIHBhcmVuc1NvdXJjZTogcSA9PlxuICAgICAgICBQLnNlcU1hcChcbiAgICAgICAgICAgIFAuc3RyaW5nKFwiKFwiKSxcbiAgICAgICAgICAgIFAub3B0V2hpdGVzcGFjZSxcbiAgICAgICAgICAgIHEuc291cmNlLFxuICAgICAgICAgICAgUC5vcHRXaGl0ZXNwYWNlLFxuICAgICAgICAgICAgUC5zdHJpbmcoXCIpXCIpLFxuICAgICAgICAgICAgKF8xLCBfMiwgZmllbGQsIF8zLCBfNCkgPT4gZmllbGRcbiAgICAgICAgKSxcbiAgICBuZWdhdGVTb3VyY2U6IHEgPT5cbiAgICAgICAgUC5zZXFNYXAoUC5hbHQoUC5zdHJpbmcoXCItXCIpLCBQLnN0cmluZyhcIiFcIikpLCBxLmF0b21Tb3VyY2UsIChfLCBzb3VyY2UpID0+IFNvdXJjZXMubmVnYXRlKHNvdXJjZSkpLFxuICAgIGF0b21Tb3VyY2U6IHEgPT5cbiAgICAgICAgUC5hbHQ8U291cmNlPihcbiAgICAgICAgICAgIHEucGFyZW5zU291cmNlLFxuICAgICAgICAgICAgcS5uZWdhdGVTb3VyY2UsXG4gICAgICAgICAgICBxLmxpbmtPdXRnb2luZ1NvdXJjZSxcbiAgICAgICAgICAgIHEubGlua0luY29taW5nU291cmNlLFxuICAgICAgICAgICAgcS5mb2xkZXJTb3VyY2UsXG4gICAgICAgICAgICBxLnRhZ1NvdXJjZSxcbiAgICAgICAgICAgIHEuY3N2U291cmNlXG4gICAgICAgICksXG4gICAgYmluYXJ5T3BTb3VyY2U6IHEgPT5cbiAgICAgICAgY3JlYXRlQmluYXJ5UGFyc2VyKFxuICAgICAgICAgICAgcS5hdG9tU291cmNlLFxuICAgICAgICAgICAgcS5iaW5hcnlCb29sZWFuT3AubWFwKHMgPT4gcyBhcyBTb3VyY2VPcCksXG4gICAgICAgICAgICBTb3VyY2VzLmJpbmFyeU9wXG4gICAgICAgICksXG4gICAgc291cmNlOiBxID0+IHEuYmluYXJ5T3BTb3VyY2UsXG5cbiAgICAvLyBGaWVsZCBwYXJzaW5nLlxuICAgIHZhcmlhYmxlRmllbGQ6IHEgPT5cbiAgICAgICAgcS5pZGVudGlmaWVyXG4gICAgICAgICAgICAuY2hhaW4ociA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKEtFWVdPUkRTLmluY2x1ZGVzKHIudG9VcHBlckNhc2UoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFAuZmFpbChcIlZhcmlhYmxlIGZpZWxkcyBjYW5ub3QgYmUgYSBrZXl3b3JkIChcIiArIEtFWVdPUkRTLmpvaW4oXCIgb3IgXCIpICsgXCIpXCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQLnN1Y2NlZWQoRmllbGRzLnZhcmlhYmxlKHIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmRlc2MoXCJ2YXJpYWJsZVwiKSxcbiAgICBudW1iZXJGaWVsZDogcSA9PiBxLm51bWJlci5tYXAodmFsID0+IEZpZWxkcy5saXRlcmFsKHZhbCkpLmRlc2MoXCJudW1iZXJcIiksXG4gICAgc3RyaW5nRmllbGQ6IHEgPT4gcS5zdHJpbmcubWFwKHZhbCA9PiBGaWVsZHMubGl0ZXJhbCh2YWwpKS5kZXNjKFwic3RyaW5nXCIpLFxuICAgIGJvb2xGaWVsZDogcSA9PiBxLmJvb2wubWFwKHZhbCA9PiBGaWVsZHMubGl0ZXJhbCh2YWwpKS5kZXNjKFwiYm9vbGVhblwiKSxcbiAgICBkYXRlRmllbGQ6IHEgPT5cbiAgICAgICAgUC5zZXFNYXAoXG4gICAgICAgICAgICBQLnN0cmluZyhcImRhdGUoXCIpLFxuICAgICAgICAgICAgUC5vcHRXaGl0ZXNwYWNlLFxuICAgICAgICAgICAgcS5kYXRlUGx1cyxcbiAgICAgICAgICAgIFAub3B0V2hpdGVzcGFjZSxcbiAgICAgICAgICAgIFAuc3RyaW5nKFwiKVwiKSxcbiAgICAgICAgICAgIChwcmVmaXgsIF8xLCBkYXRlLCBfMiwgcG9zdGZpeCkgPT4gRmllbGRzLmxpdGVyYWwoZGF0ZSlcbiAgICAgICAgKS5kZXNjKFwiZGF0ZVwiKSxcbiAgICBkdXJhdGlvbkZpZWxkOiBxID0+XG4gICAgICAgIFAuc2VxTWFwKFxuICAgICAgICAgICAgUC5zdHJpbmcoXCJkdXIoXCIpLFxuICAgICAgICAgICAgUC5vcHRXaGl0ZXNwYWNlLFxuICAgICAgICAgICAgcS5kdXJhdGlvbixcbiAgICAgICAgICAgIFAub3B0V2hpdGVzcGFjZSxcbiAgICAgICAgICAgIFAuc3RyaW5nKFwiKVwiKSxcbiAgICAgICAgICAgIChwcmVmaXgsIF8xLCBkdXIsIF8yLCBwb3N0Zml4KSA9PiBGaWVsZHMubGl0ZXJhbChkdXIpXG4gICAgICAgICkuZGVzYyhcImR1cmF0aW9uXCIpLFxuICAgIG51bGxGaWVsZDogcSA9PiBxLnJhd051bGwubWFwKF8gPT4gRmllbGRzLk5VTEwpLFxuICAgIGxpbmtGaWVsZDogcSA9PiBxLmxpbmsubWFwKGYgPT4gRmllbGRzLmxpdGVyYWwoZikpLFxuICAgIGxpc3RGaWVsZDogcSA9PlxuICAgICAgICBxLmZpZWxkXG4gICAgICAgICAgICAuc2VwQnkoUC5zdHJpbmcoXCIsXCIpLnRyaW0oUC5vcHRXaGl0ZXNwYWNlKSlcbiAgICAgICAgICAgIC53cmFwKFAuc3RyaW5nKFwiW1wiKS5za2lwKFAub3B0V2hpdGVzcGFjZSksIFAub3B0V2hpdGVzcGFjZS50aGVuKFAuc3RyaW5nKFwiXVwiKSkpXG4gICAgICAgICAgICAubWFwKGwgPT4gRmllbGRzLmxpc3QobCkpXG4gICAgICAgICAgICAuZGVzYyhcImxpc3QgKCdbMSwgMiwgM10nKVwiKSxcbiAgICBvYmplY3RGaWVsZDogcSA9PlxuICAgICAgICBQLnNlcU1hcChxLmlkZW50aWZpZXIub3IocS5zdHJpbmcpLCBQLnN0cmluZyhcIjpcIikudHJpbShQLm9wdFdoaXRlc3BhY2UpLCBxLmZpZWxkLCAobmFtZSwgX3NlcCwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWUsIHZhbHVlIH07XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuc2VwQnkoUC5zdHJpbmcoXCIsXCIpLnRyaW0oUC5vcHRXaGl0ZXNwYWNlKSlcbiAgICAgICAgICAgIC53cmFwKFAuc3RyaW5nKFwie1wiKS5za2lwKFAub3B0V2hpdGVzcGFjZSksIFAub3B0V2hpdGVzcGFjZS50aGVuKFAuc3RyaW5nKFwifVwiKSkpXG4gICAgICAgICAgICAubWFwKHZhbHMgPT4ge1xuICAgICAgICAgICAgICAgIGxldCByZXM6IFJlY29yZDxzdHJpbmcsIEZpZWxkPiA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGVudHJ5IG9mIHZhbHMpIHJlc1tlbnRyeS5uYW1lXSA9IGVudHJ5LnZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBGaWVsZHMub2JqZWN0KHJlcyk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmRlc2MoXCJvYmplY3QgKCd7IGE6IDEsIGI6IDIgfScpXCIpLFxuXG4gICAgYXRvbUlubGluZUZpZWxkOiBxID0+XG4gICAgICAgIFAuYWx0KFxuICAgICAgICAgICAgcS5kYXRlLFxuICAgICAgICAgICAgcS5kdXJhdGlvbi5tYXAoZCA9PiBub3JtYWxpemVEdXJhdGlvbihkKSksXG4gICAgICAgICAgICBxLnN0cmluZyxcbiAgICAgICAgICAgIHEudGFnLFxuICAgICAgICAgICAgcS5lbWJlZExpbmssXG4gICAgICAgICAgICBxLmJvb2wsXG4gICAgICAgICAgICBxLm51bWJlcixcbiAgICAgICAgICAgIHEucmF3TnVsbFxuICAgICAgICApLFxuICAgIGlubGluZUZpZWxkTGlzdDogcSA9PiBxLmF0b21JbmxpbmVGaWVsZC5zZXBCeShQLnN0cmluZyhcIixcIikudHJpbShQLm9wdFdoaXRlc3BhY2UpLmxvb2thaGVhZChxLmF0b21JbmxpbmVGaWVsZCkpLFxuICAgIGlubGluZUZpZWxkOiBxID0+XG4gICAgICAgIFAuYWx0KFxuICAgICAgICAgICAgUC5zZXFNYXAocS5hdG9tSW5saW5lRmllbGQsIFAuc3RyaW5nKFwiLFwiKS50cmltKFAub3B0V2hpdGVzcGFjZSksIHEuaW5saW5lRmllbGRMaXN0LCAoZiwgX3MsIGwpID0+XG4gICAgICAgICAgICAgICAgW2ZdLmNvbmNhdChsKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHEuYXRvbUlubGluZUZpZWxkXG4gICAgICAgICksXG5cbiAgICBhdG9tRmllbGQ6IHEgPT5cbiAgICAgICAgUC5hbHQoXG4gICAgICAgICAgICAvLyBQbGFjZSBlbWJlZCBsaW5rcyBhYm92ZSBuZWdhdGVkIGZpZWxkcyBhcyB0aGV5IGFyZSB0aGUgc3BlY2lhbCBwYXJzZXIgY2FzZSAnIVtbdGhpbmddXScgYW5kIGFyZSBnZW5lcmFsbHkgdW5hbWJpZ2lvdXMuXG4gICAgICAgICAgICBxLmVtYmVkTGluay5tYXAobCA9PiBGaWVsZHMubGl0ZXJhbChsKSksXG4gICAgICAgICAgICBxLm5lZ2F0ZWRGaWVsZCxcbiAgICAgICAgICAgIHEubGlua0ZpZWxkLFxuICAgICAgICAgICAgcS5saXN0RmllbGQsXG4gICAgICAgICAgICBxLm9iamVjdEZpZWxkLFxuICAgICAgICAgICAgcS5sYW1iZGFGaWVsZCxcbiAgICAgICAgICAgIHEucGFyZW5zRmllbGQsXG4gICAgICAgICAgICBxLmJvb2xGaWVsZCxcbiAgICAgICAgICAgIHEubnVtYmVyRmllbGQsXG4gICAgICAgICAgICBxLnN0cmluZ0ZpZWxkLFxuICAgICAgICAgICAgcS5kYXRlRmllbGQsXG4gICAgICAgICAgICBxLmR1cmF0aW9uRmllbGQsXG4gICAgICAgICAgICBxLm51bGxGaWVsZCxcbiAgICAgICAgICAgIHEudmFyaWFibGVGaWVsZFxuICAgICAgICApLFxuICAgIGluZGV4RmllbGQ6IHEgPT5cbiAgICAgICAgUC5zZXFNYXAocS5hdG9tRmllbGQsIFAuYWx0KHEuZG90UG9zdGZpeCwgcS5pbmRleFBvc3RmaXgsIHEuZnVuY3Rpb25Qb3N0Zml4KS5tYW55KCksIChvYmosIHBvc3RmaXhlcykgPT4ge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG9iajtcbiAgICAgICAgICAgIGZvciAobGV0IHBvc3Qgb2YgcG9zdGZpeGVzKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChwb3N0LnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImRvdFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gRmllbGRzLmluZGV4KHJlc3VsdCwgRmllbGRzLmxpdGVyYWwocG9zdC5maWVsZCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpbmRleFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gRmllbGRzLmluZGV4KHJlc3VsdCwgcG9zdC5maWVsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBGaWVsZHMuZnVuYyhyZXN1bHQsIHBvc3QuZmllbGRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSksXG4gICAgbmVnYXRlZEZpZWxkOiBxID0+IFAuc2VxTWFwKFAuc3RyaW5nKFwiIVwiKSwgcS5pbmRleEZpZWxkLCAoXywgZmllbGQpID0+IEZpZWxkcy5uZWdhdGUoZmllbGQpKS5kZXNjKFwibmVnYXRlZCBmaWVsZFwiKSxcbiAgICBwYXJlbnNGaWVsZDogcSA9PlxuICAgICAgICBQLnNlcU1hcChcbiAgICAgICAgICAgIFAuc3RyaW5nKFwiKFwiKSxcbiAgICAgICAgICAgIFAub3B0V2hpdGVzcGFjZSxcbiAgICAgICAgICAgIHEuZmllbGQsXG4gICAgICAgICAgICBQLm9wdFdoaXRlc3BhY2UsXG4gICAgICAgICAgICBQLnN0cmluZyhcIilcIiksXG4gICAgICAgICAgICAoXzEsIF8yLCBmaWVsZCwgXzMsIF80KSA9PiBmaWVsZFxuICAgICAgICApLFxuICAgIGxhbWJkYUZpZWxkOiBxID0+XG4gICAgICAgIFAuc2VxTWFwKFxuICAgICAgICAgICAgcS5pZGVudGlmaWVyXG4gICAgICAgICAgICAgICAgLnNlcEJ5KFAuc3RyaW5nKFwiLFwiKS50cmltKFAub3B0V2hpdGVzcGFjZSkpXG4gICAgICAgICAgICAgICAgLndyYXAoUC5zdHJpbmcoXCIoXCIpLnRyaW0oUC5vcHRXaGl0ZXNwYWNlKSwgUC5zdHJpbmcoXCIpXCIpLnRyaW0oUC5vcHRXaGl0ZXNwYWNlKSksXG4gICAgICAgICAgICBQLnN0cmluZyhcIj0+XCIpLnRyaW0oUC5vcHRXaGl0ZXNwYWNlKSxcbiAgICAgICAgICAgIHEuZmllbGQsXG4gICAgICAgICAgICAoaWRlbnQsIF9pZ25vcmUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJsYW1iZGFcIiwgYXJndW1lbnRzOiBpZGVudCwgdmFsdWUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKSxcblxuICAgIGRvdFBvc3RmaXg6IHEgPT5cbiAgICAgICAgUC5zZXFNYXAoUC5zdHJpbmcoXCIuXCIpLCBxLmlkZW50aWZpZXIsIChfLCBmaWVsZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJkb3RcIiwgZmllbGQ6IGZpZWxkIH07XG4gICAgICAgIH0pLFxuICAgIGluZGV4UG9zdGZpeDogcSA9PlxuICAgICAgICBQLnNlcU1hcChQLnN0cmluZyhcIltcIiksIFAub3B0V2hpdGVzcGFjZSwgcS5maWVsZCwgUC5vcHRXaGl0ZXNwYWNlLCBQLnN0cmluZyhcIl1cIiksIChfLCBfMiwgZmllbGQsIF8zLCBfNCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJpbmRleFwiLCBmaWVsZCB9O1xuICAgICAgICB9KSxcbiAgICBmdW5jdGlvblBvc3RmaXg6IHEgPT5cbiAgICAgICAgUC5zZXFNYXAoXG4gICAgICAgICAgICBQLnN0cmluZyhcIihcIiksXG4gICAgICAgICAgICBQLm9wdFdoaXRlc3BhY2UsXG4gICAgICAgICAgICBxLmZpZWxkLnNlcEJ5KFAuc3RyaW5nKFwiLFwiKS50cmltKFAub3B0V2hpdGVzcGFjZSkpLFxuICAgICAgICAgICAgUC5vcHRXaGl0ZXNwYWNlLFxuICAgICAgICAgICAgUC5zdHJpbmcoXCIpXCIpLFxuICAgICAgICAgICAgKF8sIF8xLCBmaWVsZHMsIF8yLCBfMykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiZnVuY3Rpb25cIiwgZmllbGRzIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICksXG5cbiAgICAvLyBUaGUgcHJlY2VkZW5jZSBoaWVyYXJjaHkgb2Ygb3BlcmF0b3JzIC0gbXVsdGlwbHkvZGl2aWRlLCBhZGQvc3VidHJhY3QsIGNvbXBhcmUsIGFuZCB0aGVuIGJvb2xlYW4gb3BlcmF0aW9ucy5cbiAgICBiaW5hcnlNdWxEaXZGaWVsZDogcSA9PiBjcmVhdGVCaW5hcnlQYXJzZXIocS5pbmRleEZpZWxkLCBxLmJpbmFyeU11bERpdiwgRmllbGRzLmJpbmFyeU9wKSxcbiAgICBiaW5hcnlQbHVzTWludXNGaWVsZDogcSA9PiBjcmVhdGVCaW5hcnlQYXJzZXIocS5iaW5hcnlNdWxEaXZGaWVsZCwgcS5iaW5hcnlQbHVzTWludXMsIEZpZWxkcy5iaW5hcnlPcCksXG4gICAgYmluYXJ5Q29tcGFyZUZpZWxkOiBxID0+IGNyZWF0ZUJpbmFyeVBhcnNlcihxLmJpbmFyeVBsdXNNaW51c0ZpZWxkLCBxLmJpbmFyeUNvbXBhcmVPcCwgRmllbGRzLmJpbmFyeU9wKSxcbiAgICBiaW5hcnlCb29sZWFuRmllbGQ6IHEgPT4gY3JlYXRlQmluYXJ5UGFyc2VyKHEuYmluYXJ5Q29tcGFyZUZpZWxkLCBxLmJpbmFyeUJvb2xlYW5PcCwgRmllbGRzLmJpbmFyeU9wKSxcbiAgICBiaW5hcnlPcEZpZWxkOiBxID0+IHEuYmluYXJ5Qm9vbGVhbkZpZWxkLFxuXG4gICAgZmllbGQ6IHEgPT4gcS5iaW5hcnlPcEZpZWxkLFxufSk7XG5cbi8qKlxuICogQXR0ZW1wdCB0byBwYXJzZSBhIGZpZWxkIGZyb20gdGhlIGdpdmVuIHRleHQsIHJldHVybmluZyBhIHN0cmluZyBlcnJvciBpZiB0aGVcbiAqIHBhcnNlIGZhaWxlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRmllbGQodGV4dDogc3RyaW5nKTogUmVzdWx0PEZpZWxkLCBzdHJpbmc+IHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gUmVzdWx0LnN1Y2Nlc3MoRVhQUkVTU0lPTi5maWVsZC50cnlQYXJzZSh0ZXh0KSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIFJlc3VsdC5mYWlsdXJlKFwiXCIgKyBlcnJvcik7XG4gICAgfVxufVxuIiwgIi8qKiBQcm92aWRlcyBhbiBBU1QgZm9yIGNvbXBsZXggcXVlcmllcy4gKi9cbmltcG9ydCB7IFNvdXJjZSB9IGZyb20gXCJkYXRhLWluZGV4L3NvdXJjZVwiO1xuaW1wb3J0IHsgRmllbGQgfSBmcm9tIFwiZXhwcmVzc2lvbi9maWVsZFwiO1xuXG4vKiogVGhlIHN1cHBvcnRlZCBxdWVyeSB0eXBlcyAoY29ycmVzcG9uZGluZyB0byB2aWV3IHR5cGVzKS4gKi9cbmV4cG9ydCB0eXBlIFF1ZXJ5VHlwZSA9IFwibGlzdFwiIHwgXCJ0YWJsZVwiIHwgXCJ0YXNrXCIgfCBcImNhbGVuZGFyXCI7XG5cbi8qKiBBIHNpbmdsZS1saW5lIGNvbW1lbnQuICovXG5leHBvcnQgdHlwZSBDb21tZW50ID0gc3RyaW5nO1xuXG4vKiogRmllbGRzIHVzZWQgaW4gdGhlIHF1ZXJ5IHBvcnRpb24uICovXG5leHBvcnQgaW50ZXJmYWNlIE5hbWVkRmllbGQge1xuICAgIC8qKiBUaGUgZWZmZWN0aXZlIG5hbWUgb2YgdGhpcyBmaWVsZC4gKi9cbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgLyoqIFRoZSB2YWx1ZSBvZiB0aGlzIGZpZWxkLiAqL1xuICAgIGZpZWxkOiBGaWVsZDtcbn1cblxuLyoqIEEgcXVlcnkgc29ydCBieSBmaWVsZCwgZm9yIGRldGVybWluaW5nIHNvcnQgb3JkZXIuICovXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXJ5U29ydEJ5IHtcbiAgICAvKiogVGhlIGZpZWxkIHRvIHNvcnQgb24uICovXG4gICAgZmllbGQ6IEZpZWxkO1xuICAgIC8qKiBUaGUgZGlyZWN0aW9uIHRvIHNvcnQgaW4uICovXG4gICAgZGlyZWN0aW9uOiBcImFzY2VuZGluZ1wiIHwgXCJkZXNjZW5kaW5nXCI7XG59XG5cbi8qKiBVdGlsaXR5IGZ1bmN0aW9ucyBmb3IgcXVpY2tseSBjcmVhdGluZyBmaWVsZHMuICovXG5leHBvcnQgbmFtZXNwYWNlIFF1ZXJ5RmllbGRzIHtcbiAgICBleHBvcnQgZnVuY3Rpb24gbmFtZWQobmFtZTogc3RyaW5nLCBmaWVsZDogRmllbGQpOiBOYW1lZEZpZWxkIHtcbiAgICAgICAgcmV0dXJuIHsgbmFtZSwgZmllbGQgfSBhcyBOYW1lZEZpZWxkO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBzb3J0QnkoZmllbGQ6IEZpZWxkLCBkaXI6IFwiYXNjZW5kaW5nXCIgfCBcImRlc2NlbmRpbmdcIik6IFF1ZXJ5U29ydEJ5IHtcbiAgICAgICAgcmV0dXJuIHsgZmllbGQsIGRpcmVjdGlvbjogZGlyIH07XG4gICAgfVxufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBRdWVyeSBEZWZpbml0aW9uIC8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKiBBIHF1ZXJ5IHdoaWNoIHNob3VsZCByZW5kZXIgYSBsaXN0IG9mIGVsZW1lbnRzLiAqL1xuZXhwb3J0IGludGVyZmFjZSBMaXN0UXVlcnkge1xuICAgIHR5cGU6IFwibGlzdFwiO1xuICAgIC8qKiBXaGF0IHNob3VsZCBiZSByZW5kZXJlZCBpbiB0aGUgbGlzdC4gKi9cbiAgICBmb3JtYXQ/OiBGaWVsZDtcbiAgICAvKiogSWYgdHJ1ZSwgc2hvdyB0aGUgZGVmYXVsdCBESSBmaWVsZDsgb3RoZXJ3aXNlLCBkb24ndC4gKi9cbiAgICBzaG93SWQ6IGJvb2xlYW47XG59XG5cbi8qKiBBIHF1ZXJ5IHdoaWNoIHJlbmRlcnMgYSB0YWJsZSBvZiBlbGVtZW50cy4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGFibGVRdWVyeSB7XG4gICAgdHlwZTogXCJ0YWJsZVwiO1xuICAgIC8qKiBUaGUgZmllbGRzIChjb21wdXRlZCBvciBvdGhlcndpc2UpIHRvIHNlbGVjdC4gKi9cbiAgICBmaWVsZHM6IE5hbWVkRmllbGRbXTtcbiAgICAvKiogSWYgdHJ1ZSwgc2hvdyB0aGUgZGVmYXVsdCBJRCBmaWVsZDsgb3RoZXJ3aXNlLCBkb24ndC4gKi9cbiAgICBzaG93SWQ6IGJvb2xlYW47XG59XG5cbi8qKiBBIHF1ZXJ5IHdoaWNoIHJlbmRlcnMgYSBjb2xsZWN0aW9uIG9mIHRhc2tzLiAqL1xuZXhwb3J0IGludGVyZmFjZSBUYXNrUXVlcnkge1xuICAgIHR5cGU6IFwidGFza1wiO1xufVxuXG4vKiogQSBxdWVyeSB3aGljaCByZW5kZXJzIGEgY29sbGVjdGlvbiBvZiBub3RlcyBpbiBhIGNhbGVuZGFyIHZpZXcuICovXG5leHBvcnQgaW50ZXJmYWNlIENhbGVuZGFyUXVlcnkge1xuICAgIHR5cGU6IFwiY2FsZW5kYXJcIjtcbiAgICAvKiogVGhlIGRhdGUgZmllbGQgdGhhdCB3ZSdsbCBiZSBncm91cGluZyBub3RlcyBieSBmb3IgdGhlIGNhbGVuZGFyIHZpZXcgKi9cbiAgICBmaWVsZDogTmFtZWRGaWVsZDtcbn1cblxuZXhwb3J0IHR5cGUgUXVlcnlIZWFkZXIgPSBMaXN0UXVlcnkgfCBUYWJsZVF1ZXJ5IHwgVGFza1F1ZXJ5IHwgQ2FsZW5kYXJRdWVyeTtcblxuLyoqIEEgc3RlcCB3aGljaCBvbmx5IHJldGFpbnMgcm93cyB3aG9zZSAnY2xhdXNlJyBmaWVsZCBpcyB0cnV0aHkuICovXG5leHBvcnQgaW50ZXJmYWNlIFdoZXJlU3RlcCB7XG4gICAgdHlwZTogXCJ3aGVyZVwiO1xuICAgIGNsYXVzZTogRmllbGQ7XG59XG5cbi8qKiBBIHN0ZXAgd2hpY2ggc29ydHMgYWxsIGN1cnJlbnQgcm93cyBieSB0aGUgZ2l2ZW4gbGlzdCBvZiBzb3J0cy4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU29ydEJ5U3RlcCB7XG4gICAgdHlwZTogXCJzb3J0XCI7XG4gICAgZmllbGRzOiBRdWVyeVNvcnRCeVtdO1xufVxuXG4vKiogQSBzdGVwIHdoaWNoIHRydW5jYXRlcyB0aGUgbnVtYmVyIG9mIHJvd3MgdG8gdGhlIGdpdmVuIGFtb3VudC4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTGltaXRTdGVwIHtcbiAgICB0eXBlOiBcImxpbWl0XCI7XG4gICAgYW1vdW50OiBGaWVsZDtcbn1cblxuLyoqIEEgc3RlcCB3aGljaCBmbGF0dGVucyByb3dzIGludG8gbXVsdGlwbGUgY2hpbGQgcm93cy4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRmxhdHRlblN0ZXAge1xuICAgIHR5cGU6IFwiZmxhdHRlblwiO1xuICAgIGZpZWxkOiBOYW1lZEZpZWxkO1xufVxuXG4vKiogQSBzdGVwIHdoaWNoIGdyb3VwcyByb3dzIGludG8gZ3JvdXBzIGJ5IHRoZSBnaXZlbiBmaWVsZC4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgR3JvdXBTdGVwIHtcbiAgICB0eXBlOiBcImdyb3VwXCI7XG4gICAgZmllbGQ6IE5hbWVkRmllbGQ7XG59XG5cbi8qKiBBIHZpcnR1YWwgc3RlcCB3aGljaCBleHRyYWN0cyBhbiBhcnJheSBvZiB2YWx1ZXMgZnJvbSBlYWNoIHJvdy4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRXh0cmFjdFN0ZXAge1xuICAgIHR5cGU6IFwiZXh0cmFjdFwiO1xuICAgIGZpZWxkczogUmVjb3JkPHN0cmluZywgRmllbGQ+O1xufVxuXG5leHBvcnQgdHlwZSBRdWVyeU9wZXJhdGlvbiA9IFdoZXJlU3RlcCB8IFNvcnRCeVN0ZXAgfCBMaW1pdFN0ZXAgfCBGbGF0dGVuU3RlcCB8IEdyb3VwU3RlcCB8IEV4dHJhY3RTdGVwO1xuXG4vKipcbiAqIEEgcXVlcnkgb3ZlciB0aGUgT2JzaWRpYW4gZGF0YWJhc2UuIFF1ZXJpZXMgaGF2ZSBhIHNwZWNpZmljIGFuZCBkZXRlcm1pbmlzdGljIGV4ZWN1dGlvbiBvcmRlcjpcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBRdWVyeSB7XG4gICAgLyoqIFRoZSB2aWV3IHR5cGUgdG8gcmVuZGVyIHRoaXMgcXVlcnkgaW4uICovXG4gICAgaGVhZGVyOiBRdWVyeUhlYWRlcjtcbiAgICAvKiogVGhlIHNvdXJjZSB0aGF0IGZpbGUgY2FuZGlkYXRlcyB3aWxsIGNvbWUgZnJvbS4gKi9cbiAgICBzb3VyY2U6IFNvdXJjZTtcbiAgICAvKiogVGhlIG9wZXJhdGlvbnMgdG8gYXBwbHkgdG8gdGhlIGRhdGEgdG8gcHJvZHVjZSB0aGUgZmluYWwgcmVzdWx0IHRoYXQgd2lsbCBiZSByZW5kZXJlZC4gKi9cbiAgICBvcGVyYXRpb25zOiBRdWVyeU9wZXJhdGlvbltdO1xufVxuIiwgImltcG9ydCB7IEVYUFJFU1NJT04gfSBmcm9tIFwiZXhwcmVzc2lvbi9wYXJzZVwiO1xuaW1wb3J0ICogYXMgUCBmcm9tIFwicGFyc2ltbW9uXCI7XG5pbXBvcnQge1xuICAgIEZsYXR0ZW5TdGVwLFxuICAgIEdyb3VwU3RlcCxcbiAgICBMaW1pdFN0ZXAsXG4gICAgTmFtZWRGaWVsZCxcbiAgICBRdWVyeSxcbiAgICBRdWVyeUZpZWxkcyxcbiAgICBRdWVyeUhlYWRlcixcbiAgICBRdWVyeU9wZXJhdGlvbixcbiAgICBRdWVyeVNvcnRCeSxcbiAgICBRdWVyeVR5cGUsXG4gICAgU29ydEJ5U3RlcCxcbiAgICBXaGVyZVN0ZXAsXG4gICAgQ29tbWVudCxcbn0gZnJvbSBcIi4vcXVlcnlcIjtcbmltcG9ydCB7IFNvdXJjZSwgU291cmNlcyB9IGZyb20gXCJkYXRhLWluZGV4L3NvdXJjZVwiO1xuaW1wb3J0IHsgREVGQVVMVF9RVUVSWV9TRVRUSU5HUyB9IGZyb20gXCJzZXR0aW5nc1wiO1xuaW1wb3J0IHsgUmVzdWx0IH0gZnJvbSBcImFwaS9yZXN1bHRcIjtcblxuLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gUXVlcnkgUGFyc2luZyAvL1xuLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKiogVHlwaW5ncyBmb3IgdGhlIG91dHB1dHMgb2YgYWxsIG9mIHRoZSBwYXJzZXIgY29tYmluYXRvcnMuICovXG5pbnRlcmZhY2UgUXVlcnlMYW5ndWFnZVR5cGVzIHtcbiAgICBxdWVyeVR5cGU6IFF1ZXJ5VHlwZTtcbiAgICBjb21tZW50OiBDb21tZW50O1xuXG4gICAgZXhwbGljaXROYW1lZEZpZWxkOiBOYW1lZEZpZWxkO1xuICAgIG5hbWVkRmllbGQ6IE5hbWVkRmllbGQ7XG4gICAgc29ydEZpZWxkOiBRdWVyeVNvcnRCeTtcblxuICAgIC8vIEVudGlyZSBjbGF1c2VzIGluIHF1ZXJpZXMuXG4gICAgaGVhZGVyQ2xhdXNlOiBRdWVyeUhlYWRlcjtcbiAgICBmcm9tQ2xhdXNlOiBTb3VyY2U7XG4gICAgd2hlcmVDbGF1c2U6IFdoZXJlU3RlcDtcbiAgICBzb3J0QnlDbGF1c2U6IFNvcnRCeVN0ZXA7XG4gICAgbGltaXRDbGF1c2U6IExpbWl0U3RlcDtcbiAgICBmbGF0dGVuQ2xhdXNlOiBGbGF0dGVuU3RlcDtcbiAgICBncm91cEJ5Q2xhdXNlOiBHcm91cFN0ZXA7XG4gICAgY2xhdXNlOiBRdWVyeU9wZXJhdGlvbjtcbiAgICBxdWVyeTogUXVlcnk7XG59XG5cbi8qKiBSZXR1cm4gYSBuZXcgcGFyc2VyIHdoaWNoIGV4ZWN1dGVzIHRoZSB1bmRlcmx5aW5nIHBhcnNlciBhbmQgcmV0dXJucyBpdCdzIHJhdyBzdHJpbmcgcmVwcmVzZW50YXRpb24uICovXG5leHBvcnQgZnVuY3Rpb24gY2FwdHVyZVJhdzxUPihiYXNlOiBQLlBhcnNlcjxUPik6IFAuUGFyc2VyPFtULCBzdHJpbmddPiB7XG4gICAgcmV0dXJuIFAuY3VzdG9tKChzdWNjZXNzLCBmYWlsdXJlKSA9PiB7XG4gICAgICAgIHJldHVybiAoaW5wdXQsIGkpID0+IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSAoYmFzZSBhcyBhbnkpLl8oaW5wdXQsIGkpO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQuc3RhdHVzKSByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcmVzdWx0LCB7IHZhbHVlOiBbcmVzdWx0LnZhbHVlLCBpbnB1dC5zdWJzdHJpbmcoaSwgcmVzdWx0LmluZGV4KV0gfSk7XG4gICAgICAgIH07XG4gICAgfSk7XG59XG5cbi8qKiBTdHJpcCBuZXdsaW5lcyBhbmQgZXhjZXNzIHdoaXRlc3BhY2Ugb3V0IG9mIHRleHQuICovXG5mdW5jdGlvbiBzdHJpcE5ld2xpbmVzKHRleHQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRleHRcbiAgICAgICAgLnNwbGl0KC9bXFxyXFxuXSsvKVxuICAgICAgICAubWFwKHQgPT4gdC50cmltKCkpXG4gICAgICAgIC5qb2luKFwiXCIpO1xufVxuXG4vKiogR2l2ZW4gYHBhcnNlcmAsIHJldHVybiB0aGUgcGFyc2VyIHRoYXQgcmV0dXJucyBgaWZfZW9mKClgIGlmIEVPRiBpcyBmb3VuZCxcbiAqIG90aGVyd2lzZSBgcGFyc2VyYCBwcmVjZWRlZCBieSAobm9uLW9wdGlvbmFsKSB3aGl0ZXNwYWNlICovXG5mdW5jdGlvbiBwcmVjZWRlZEJ5V2hpdGVzcGFjZUlmTm90RW9mPFQ+KGlmX2VvZjogKF86IHVuZGVmaW5lZCkgPT4gVCwgcGFyc2VyOiBQLlBhcnNlcjxUPik6IFAuUGFyc2VyPFQ+IHtcbiAgICByZXR1cm4gUC5lb2YubWFwKGlmX2VvZikub3IoUC53aGl0ZXNwYWNlLnRoZW4ocGFyc2VyKSk7XG59XG5cbi8qKiBBIHBhcnNpbW1vbi1wb3dlcmVkIHBhcnNlci1jb21iaW5hdG9yIGltcGxlbWVudGF0aW9uIG9mIHRoZSBxdWVyeSBsYW5ndWFnZS4gKi9cbmV4cG9ydCBjb25zdCBRVUVSWV9MQU5HVUFHRSA9IFAuY3JlYXRlTGFuZ3VhZ2U8UXVlcnlMYW5ndWFnZVR5cGVzPih7XG4gICAgLy8gU2ltcGxlIGF0b20gcGFyc2luZywgbGlrZSB3b3JkcywgaWRlbnRpZmllcnMsIG51bWJlcnMuXG4gICAgcXVlcnlUeXBlOiBxID0+XG4gICAgICAgIFAuYWx0PHN0cmluZz4oUC5yZWdleHAoL1RBQkxFfExJU1R8VEFTS3xDQUxFTkRBUi9pKSlcbiAgICAgICAgICAgIC5tYXAoc3RyID0+IHN0ci50b0xvd2VyQ2FzZSgpIGFzIFF1ZXJ5VHlwZSlcbiAgICAgICAgICAgIC5kZXNjKFwicXVlcnkgdHlwZSAoJ1RBQkxFJywgJ0xJU1QnLCAnVEFTSycsIG9yICdDQUxFTkRBUicpXCIpLFxuICAgIGV4cGxpY2l0TmFtZWRGaWVsZDogcSA9PlxuICAgICAgICBQLnNlcU1hcChcbiAgICAgICAgICAgIEVYUFJFU1NJT04uZmllbGQuc2tpcChQLndoaXRlc3BhY2UpLFxuICAgICAgICAgICAgUC5yZWdleHAoL0FTL2kpLnNraXAoUC53aGl0ZXNwYWNlKSxcbiAgICAgICAgICAgIEVYUFJFU1NJT04uaWRlbnRpZmllci5vcihFWFBSRVNTSU9OLnN0cmluZyksXG4gICAgICAgICAgICAoZmllbGQsIF9hcywgaWRlbnQpID0+IFF1ZXJ5RmllbGRzLm5hbWVkKGlkZW50LCBmaWVsZClcbiAgICAgICAgKSxcbiAgICBjb21tZW50OiAoKSA9PlxuICAgICAgICBQLlBhcnNlcigoaW5wdXQsIGkpID0+IHtcbiAgICAgICAgICAgIC8vIFBhcnNlIGEgY29tbWVudCwgd2hpY2ggaXMgYSBsaW5lIHN0YXJ0aW5nIHdpdGggLy8uXG4gICAgICAgICAgICBsZXQgbGluZSA9IGlucHV0LnN1YnN0cmluZyhpKTtcbiAgICAgICAgICAgIGlmICghbGluZS5zdGFydHNXaXRoKFwiLy9cIikpIHJldHVybiBQLm1ha2VGYWlsdXJlKGksIFwiTm90IGEgY29tbWVudFwiKTtcbiAgICAgICAgICAgIC8vIFRoZSBjb21tZW50IGVuZHMgYXQgdGhlIGVuZCBvZiB0aGUgbGluZS5cbiAgICAgICAgICAgIGxpbmUgPSBsaW5lLnNwbGl0KFwiXFxuXCIpWzBdO1xuICAgICAgICAgICAgbGV0IGNvbW1lbnQgPSBsaW5lLnN1YnN0cmluZygyKS50cmltKCk7XG4gICAgICAgICAgICByZXR1cm4gUC5tYWtlU3VjY2VzcyhpICsgbGluZS5sZW5ndGgsIGNvbW1lbnQpO1xuICAgICAgICB9KSxcbiAgICBuYW1lZEZpZWxkOiBxID0+XG4gICAgICAgIFAuYWx0PE5hbWVkRmllbGQ+KFxuICAgICAgICAgICAgcS5leHBsaWNpdE5hbWVkRmllbGQsXG4gICAgICAgICAgICBjYXB0dXJlUmF3KEVYUFJFU1NJT04uZmllbGQpLm1hcCgoW3ZhbHVlLCB0ZXh0XSkgPT4gUXVlcnlGaWVsZHMubmFtZWQoc3RyaXBOZXdsaW5lcyh0ZXh0KSwgdmFsdWUpKVxuICAgICAgICApLFxuICAgIHNvcnRGaWVsZDogcSA9PlxuICAgICAgICBQLnNlcU1hcChcbiAgICAgICAgICAgIEVYUFJFU1NJT04uZmllbGQuc2tpcChQLm9wdFdoaXRlc3BhY2UpLFxuICAgICAgICAgICAgUC5yZWdleHAoL0FTQ0VORElOR3xERVNDRU5ESU5HfEFTQ3xERVNDL2kpLmF0TW9zdCgxKSxcbiAgICAgICAgICAgIChmaWVsZCwgZGlyKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGRpcmVjdGlvbiA9IGRpci5sZW5ndGggPT0gMCA/IFwiYXNjZW5kaW5nXCIgOiBkaXJbMF0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09IFwiZGVzY1wiKSBkaXJlY3Rpb24gPSBcImRlc2NlbmRpbmdcIjtcbiAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09IFwiYXNjXCIpIGRpcmVjdGlvbiA9IFwiYXNjZW5kaW5nXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246IGRpcmVjdGlvbiBhcyBcImFzY2VuZGluZ1wiIHwgXCJkZXNjZW5kaW5nXCIsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKSxcblxuICAgIGhlYWRlckNsYXVzZTogcSA9PlxuICAgICAgICBxLnF1ZXJ5VHlwZVxuICAgICAgICAgICAgLmNoYWluKHR5cGUgPT4ge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidGFibGVcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZWNlZGVkQnlXaGl0ZXNwYWNlSWZOb3RFb2YoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCkgPT4gKHsgdHlwZSwgZmllbGRzOiBbXSwgc2hvd0lkOiB0cnVlIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFAuc2VxTWFwKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQLnJlZ2V4cCgvV0lUSE9VVFxccytJRC9pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNraXAoUC5vcHRXaGl0ZXNwYWNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0TW9zdCgxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUC5zZXBCeShxLm5hbWVkRmllbGQsIFAuc3RyaW5nKFwiLFwiKS50cmltKFAub3B0V2hpdGVzcGFjZSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAod2l0aG91dElkLCBmaWVsZHMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGUsIGZpZWxkcywgc2hvd0lkOiB3aXRob3V0SWQubGVuZ3RoID09IDAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImxpc3RcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmVjZWRlZEJ5V2hpdGVzcGFjZUlmTm90RW9mKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgpID0+ICh7IHR5cGUsIGZvcm1hdDogdW5kZWZpbmVkLCBzaG93SWQ6IHRydWUgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUC5zZXFNYXAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFAucmVnZXhwKC9XSVRIT1VUXFxzK0lEL2kpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2tpcChQLm9wdFdoaXRlc3BhY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXRNb3N0KDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFWFBSRVNTSU9OLmZpZWxkLmF0TW9zdCgxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHdpdGhvdXRJZCwgZm9ybWF0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiBmb3JtYXQubGVuZ3RoID09IDEgPyBmb3JtYXRbMF0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvd0lkOiB3aXRob3V0SWQubGVuZ3RoID09IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRhc2tcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQLnN1Y2NlZWQoeyB0eXBlIH0pO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY2FsZW5kYXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQLndoaXRlc3BhY2UudGhlbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQLnNlcU1hcChxLm5hbWVkRmllbGQsIGZpZWxkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG93SWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBhcyBRdWVyeUhlYWRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQLmZhaWwoYFVucmVjb2duaXplZCBxdWVyeSB0eXBlICcke3R5cGV9J2ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZGVzYyhcIlRBQkxFIG9yIExJU1Qgb3IgVEFTSyBvciBDQUxFTkRBUlwiKSxcbiAgICBmcm9tQ2xhdXNlOiBxID0+IFAuc2VxTWFwKFAucmVnZXhwKC9GUk9NL2kpLCBQLndoaXRlc3BhY2UsIEVYUFJFU1NJT04uc291cmNlLCAoXzEsIF8yLCBzb3VyY2UpID0+IHNvdXJjZSksXG4gICAgd2hlcmVDbGF1c2U6IHEgPT5cbiAgICAgICAgUC5zZXFNYXAoUC5yZWdleHAoL1dIRVJFL2kpLCBQLndoaXRlc3BhY2UsIEVYUFJFU1NJT04uZmllbGQsICh3aGVyZSwgXywgZmllbGQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwid2hlcmVcIiwgY2xhdXNlOiBmaWVsZCB9IGFzIFdoZXJlU3RlcDtcbiAgICAgICAgfSkuZGVzYyhcIldIRVJFIDxleHByZXNzaW9uPlwiKSxcbiAgICBzb3J0QnlDbGF1c2U6IHEgPT5cbiAgICAgICAgUC5zZXFNYXAoXG4gICAgICAgICAgICBQLnJlZ2V4cCgvU09SVC9pKSxcbiAgICAgICAgICAgIFAud2hpdGVzcGFjZSxcbiAgICAgICAgICAgIHEuc29ydEZpZWxkLnNlcEJ5MShQLnN0cmluZyhcIixcIikudHJpbShQLm9wdFdoaXRlc3BhY2UpKSxcbiAgICAgICAgICAgIChzb3J0LCBfMSwgZmllbGRzKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJzb3J0XCIsIGZpZWxkcyB9IGFzIFNvcnRCeVN0ZXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICkuZGVzYyhcIlNPUlQgZmllbGQgW0FTQy9ERVNDXVwiKSxcbiAgICBsaW1pdENsYXVzZTogcSA9PlxuICAgICAgICBQLnNlcU1hcChQLnJlZ2V4cCgvTElNSVQvaSksIFAud2hpdGVzcGFjZSwgRVhQUkVTU0lPTi5maWVsZCwgKGxpbWl0LCBfMSwgZmllbGQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwibGltaXRcIiwgYW1vdW50OiBmaWVsZCB9IGFzIExpbWl0U3RlcDtcbiAgICAgICAgfSkuZGVzYyhcIkxJTUlUIDx2YWx1ZT5cIiksXG4gICAgZmxhdHRlbkNsYXVzZTogcSA9PlxuICAgICAgICBQLnNlcU1hcChQLnJlZ2V4cCgvRkxBVFRFTi9pKS5za2lwKFAud2hpdGVzcGFjZSksIHEubmFtZWRGaWVsZCwgKF8sIGZpZWxkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImZsYXR0ZW5cIiwgZmllbGQgfSBhcyBGbGF0dGVuU3RlcDtcbiAgICAgICAgfSkuZGVzYyhcIkZMQVRURU4gPHZhbHVlPiBbQVMgPG5hbWU+XVwiKSxcbiAgICBncm91cEJ5Q2xhdXNlOiBxID0+XG4gICAgICAgIFAuc2VxTWFwKFAucmVnZXhwKC9HUk9VUCBCWS9pKS5za2lwKFAud2hpdGVzcGFjZSksIHEubmFtZWRGaWVsZCwgKF8sIGZpZWxkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImdyb3VwXCIsIGZpZWxkIH0gYXMgR3JvdXBTdGVwO1xuICAgICAgICB9KS5kZXNjKFwiR1JPVVAgQlkgPHZhbHVlPiBbQVMgPG5hbWU+XVwiKSxcbiAgICAvLyBGdWxsIHF1ZXJ5IHBhcnNpbmcuXG4gICAgY2xhdXNlOiBxID0+IFAuYWx0KHEuZnJvbUNsYXVzZSwgcS53aGVyZUNsYXVzZSwgcS5zb3J0QnlDbGF1c2UsIHEubGltaXRDbGF1c2UsIHEuZ3JvdXBCeUNsYXVzZSwgcS5mbGF0dGVuQ2xhdXNlKSxcbiAgICBxdWVyeTogcSA9PlxuICAgICAgICBQLnNlcU1hcChcbiAgICAgICAgICAgIHEuaGVhZGVyQ2xhdXNlLnRyaW0ob3B0aW9uYWxXaGl0ZXNwYWNlT3JDb21tZW50KSxcbiAgICAgICAgICAgIHEuZnJvbUNsYXVzZS50cmltKG9wdGlvbmFsV2hpdGVzcGFjZU9yQ29tbWVudCkuYXRNb3N0KDEpLFxuICAgICAgICAgICAgcS5jbGF1c2UudHJpbShvcHRpb25hbFdoaXRlc3BhY2VPckNvbW1lbnQpLm1hbnkoKSxcbiAgICAgICAgICAgIChoZWFkZXIsIGZyb20sIGNsYXVzZXMpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXIsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogZnJvbS5sZW5ndGggPT0gMCA/IFNvdXJjZXMuZm9sZGVyKFwiXCIpIDogZnJvbVswXSxcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uczogY2xhdXNlcyxcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3M6IERFRkFVTFRfUVVFUllfU0VUVElOR1MsXG4gICAgICAgICAgICAgICAgfSBhcyBRdWVyeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKSxcbn0pO1xuXG4vKipcbiAqIEEgcGFyc2VyIGZvciBvcHRpb25hbCB3aGl0ZXNwYWNlIG9yIGNvbW1lbnRzLiBUaGlzIGlzIHVzZWQgdG8gZXhjbHVkZSB3aGl0ZXNwYWNlIGFuZCBjb21tZW50cyBmcm9tIG90aGVyIHBhcnNlcnMuXG4gKi9cbmNvbnN0IG9wdGlvbmFsV2hpdGVzcGFjZU9yQ29tbWVudDogUC5QYXJzZXI8c3RyaW5nPiA9IFAuYWx0KFAud2hpdGVzcGFjZSwgUVVFUllfTEFOR1VBR0UuY29tbWVudClcbiAgICAubWFueSgpIC8vIFVzZSBtYW55KCkgc2luY2UgdGhlcmUgbWF5IGJlIHplcm8gd2hpdGVzcGFjZXMgb3IgY29tbWVudHMuXG4gICAgLy8gVHJhbnNmb3JtIHRoZSBtYW55IHRvIGEgc2luZ2xlIHJlc3VsdC5cbiAgICAubWFwKGFyciA9PiBhcnIuam9pbihcIlwiKSk7XG5cbi8qKlxuICogQXR0ZW1wdCB0byBwYXJzZSBhIHF1ZXJ5IGZyb20gdGhlIGdpdmVuIHF1ZXJ5IHRleHQsIHJldHVybmluZyBhIHN0cmluZyBlcnJvclxuICogaWYgdGhlIHBhcnNlIGZhaWxlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUXVlcnkodGV4dDogc3RyaW5nKTogUmVzdWx0PFF1ZXJ5LCBzdHJpbmc+IHtcbiAgICB0cnkge1xuICAgICAgICBsZXQgcXVlcnkgPSBRVUVSWV9MQU5HVUFHRS5xdWVyeS50cnlQYXJzZSh0ZXh0KTtcbiAgICAgICAgcmV0dXJuIFJlc3VsdC5zdWNjZXNzKHF1ZXJ5KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gUmVzdWx0LmZhaWx1cmUoXCJcIiArIGVycm9yKTtcbiAgICB9XG59XG4iLCAiLy8gQmFzaWMgQVBJIHR5cGUuXG5leHBvcnQgdHlwZSB7IERhdGF2aWV3QXBpIH0gZnJvbSBcImFwaS9wbHVnaW4tYXBpXCI7XG5cbi8vIENvcmUgRGF0YXZpZXcgdHlwZXMuXG5leHBvcnQgdHlwZSB7IERhdGVUaW1lLCBEdXJhdGlvbiB9IGZyb20gXCJsdXhvblwiO1xuZXhwb3J0IHR5cGUge1xuICAgIExpbmssXG4gICAgRGF0YU9iamVjdCxcbiAgICBMaXRlcmFsVHlwZSxcbiAgICBMaXRlcmFsLFxuICAgIExpdGVyYWxSZXByLFxuICAgIFdyYXBwZWRMaXRlcmFsLFxuICAgIExpdGVyYWxXcmFwcGVyLFxuICAgIFdpZGdldCxcbn0gZnJvbSBcImRhdGEtbW9kZWwvdmFsdWVcIjtcblxuZXhwb3J0IHR5cGUgeyBSZXN1bHQsIFN1Y2Nlc3MsIEZhaWx1cmUgfSBmcm9tIFwiYXBpL3Jlc3VsdFwiO1xuZXhwb3J0IHR5cGUgeyBEYXRhQXJyYXkgfSBmcm9tIFwiYXBpL2RhdGEtYXJyYXlcIjtcblxuLy8gRGF0YXZpZXcgSW5kZXguXG5leHBvcnQgdHlwZSB7IExpc3RJdGVtLCBQYWdlTWV0YWRhdGEgfSBmcm9tIFwiZGF0YS1tb2RlbC9tYXJrZG93blwiO1xuZXhwb3J0IHR5cGUgeyBGdWxsSW5kZXgsIFByZWZpeEluZGV4LCBJbmRleE1hcCB9IGZyb20gXCJkYXRhLWluZGV4L2luZGV4XCI7XG5cbi8vIFNlcmlhbGl6ZWQgdHlwZXMgd2hpY2ggZGVzY3JpYmUgYWxsIG91dHB1dHMgb2Ygc2VyaWFsaXphdGlvbi5cbmV4cG9ydCB0eXBlIHsgU01hcmtkb3duUGFnZSwgU0xpc3RFbnRyeSwgU1Rhc2sgfSBmcm9tIFwiZGF0YS1tb2RlbC9zZXJpYWxpemVkL21hcmtkb3duXCI7XG5cbi8vIFVzZWZ1bCB1dGlsaXRpZXMgZm9yIGRpcmVjdGx5IHVzaW5nIGRhdGF2aWV3IHBhcnNlcnMuXG5leHBvcnQge1xuICAgIERVUkFUSU9OX1RZUEVTLFxuICAgIERBVEVfU0hPUlRIQU5EUyxcbiAgICBLRVlXT1JEUyxcbiAgICBFeHByZXNzaW9uTGFuZ3VhZ2UsXG4gICAgRVhQUkVTU0lPTixcbiAgICBwYXJzZUZpZWxkLFxufSBmcm9tIFwiZXhwcmVzc2lvbi9wYXJzZVwiO1xuZXhwb3J0IHsgUVVFUllfTEFOR1VBR0UgfSBmcm9tIFwicXVlcnkvcGFyc2VcIjtcbmV4cG9ydCB7IFF1ZXJ5IH0gZnJvbSBcInF1ZXJ5L3F1ZXJ5XCI7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBJbXBsZW1lbnRhdGlvbiAvL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuaW1wb3J0IHR5cGUgeyBEYXRhdmlld0FwaSB9IGZyb20gXCJhcGkvcGx1Z2luLWFwaVwiO1xuXG5pbXBvcnQgXCJvYnNpZGlhblwiO1xuaW1wb3J0IHR5cGUgeyBBcHAgfSBmcm9tIFwib2JzaWRpYW5cIjtcblxuLy8gVXRpbGl0eSBmdW5jdGlvbnMuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBEYXRhdmlldyBBUEkgZnJvbSB0aGUgYXBwIGlmIHByb3ZpZGVkOyBpZiBub3QsIGl0IGlzIGluZmVycmVkIGZyb20gdGhlIGdsb2JhbCBBUEkgb2JqZWN0IGluc3RhbGxlZFxuICogb24gdGhlIHdpbmRvdy5cbiAqL1xuZXhwb3J0IGNvbnN0IGdldEFQSSA9IChhcHA/OiBBcHApOiBEYXRhdmlld0FwaSB8IHVuZGVmaW5lZCA9PiB7XG4gICAgaWYgKGFwcCkgcmV0dXJuIGFwcC5wbHVnaW5zLnBsdWdpbnMuZGF0YXZpZXc/LmFwaTtcbiAgICBlbHNlIHJldHVybiB3aW5kb3cuRGF0YXZpZXdBUEk7XG59O1xuXG4vKiogRGV0ZXJtaW5lIGlmIERhdGF2aWV3IGlzIGVuYWJsZWQgaW4gdGhlIGdpdmVuIGFwcGxpY2F0aW9uLiAqL1xuZXhwb3J0IGNvbnN0IGlzUGx1Z2luRW5hYmxlZCA9IChhcHA6IEFwcCkgPT4gYXBwLnBsdWdpbnMuZW5hYmxlZFBsdWdpbnMuaGFzKFwiZGF0YXZpZXdcIik7XG4iLCAiLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoLCAyMDIxICovXG5cbi8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbnZhciBJQ0FMO1xuKGZ1bmN0aW9uKCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpIHtcbiAgICAvLyBDb21tb25KUywgd2hlcmUgZXhwb3J0cyBtYXkgYmUgZGlmZmVyZW50IGVhY2ggdGltZS5cbiAgICBJQ0FMID0gbW9kdWxlLmV4cG9ydHM7XG4gIH0gZWxzZSBpZiAodHlwZW9mIEhUTUxTY3JpcHRFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiAnbm9Nb2R1bGUnIGluIEhUTUxTY3JpcHRFbGVtZW50LnByb3RvdHlwZSkge1xuICAgIC8vIFVudGlsIHdlIHVzZSBFUzYgZXhwb3J0cywgdXNpbmcgPHNjcmlwdCB0eXBlPVwibW9kdWxlXCI+IHdlIGRlZmluZSBJQ0FMIG9uIHRoZSB3aW5kb3cgZ2xvYmFsLlxuICAgIHdpbmRvdy5JQ0FMID0gSUNBTCA9IHt9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBJQ0FMICE9PSAnb2JqZWN0Jykge1xuICAgIElDQUwgPSB7fTtcbiAgfVxufSkoKTtcbi8qIGpzaGludCBpZ25vcmU6ZW5kICovXG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICogUG9ydGlvbnMgQ29weXJpZ2h0IChDKSBQaGlsaXBwIEtld2lzY2gsIDIwMTEtMjAxNSAqL1xuXG4vKipcbiAqIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBiZWZvcmUgaUNhbGVuZGFyIGxpbmUgZm9sZGluZyBzaG91bGQgb2NjdXJcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAZGVmYXVsdCA3NVxuICovXG5JQ0FMLmZvbGRMZW5ndGggPSA3NTtcblxuXG4vKipcbiAqIFRoZSBjaGFyYWN0ZXIocykgdG8gYmUgdXNlZCBmb3IgYSBuZXdsaW5lLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBwcm92aWRlZCBieVxuICogcmZjNTU0NS5cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVmYXVsdCBcIlxcclxcblwiXG4gKi9cbklDQUwubmV3TGluZUNoYXIgPSAnXFxyXFxuJztcblxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbnMgdXNlZCBpbiB2YXJpb3VzIHBsYWNlcyB3aXRoaW4gaWNhbC5qc1xuICogQG5hbWVzcGFjZVxuICovXG5JQ0FMLmhlbHBlcnMgPSB7XG4gIC8qKlxuICAgKiBDb21waWxlcyBhIGxpc3Qgb2YgYWxsIHJlZmVyZW5jZWQgVFpJRHMgaW4gYWxsIHN1YmNvbXBvbmVudHMgYW5kXG4gICAqIHJlbW92ZXMgYW55IGV4dHJhIFZUSU1FWk9ORSBzdWJjb21wb25lbnRzLiBJbiBhZGRpdGlvbiwgaWYgYW55IFRaSURzXG4gICAqIGFyZSByZWZlcmVuY2VkIGJ5IGEgY29tcG9uZW50LCBidXQgYSBWVElNRVpPTkUgZG9lcyBub3QgZXhpc3QsXG4gICAqIGFuIGF0dGVtcHQgd2lsbCBiZSBtYWRlIHRvIGdlbmVyYXRlIGEgVlRJTUVaT05FIHVzaW5nIElDQUwuVGltZXpvbmVTZXJ2aWNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0lDQUwuQ29tcG9uZW50fSB2Y2FsICAgICBUaGUgdG9wLWxldmVsIFZDQUxFTkRBUiBjb21wb25lbnQuXG4gICAqIEByZXR1cm4ge0lDQUwuQ29tcG9uZW50fSAgICAgICAgIFRoZSBJQ0FMLkNvbXBvbmVudCB0aGF0IHdhcyBwYXNzZWQgaW4uXG4gICAqL1xuICB1cGRhdGVUaW1lem9uZXM6IGZ1bmN0aW9uKHZjYWwpIHtcbiAgICB2YXIgYWxsc3VicywgcHJvcGVydGllcywgdnRpbWV6b25lcywgcmVxVHppZCwgaSwgdHppZDtcblxuICAgIGlmICghdmNhbCB8fCB2Y2FsLm5hbWUgIT09IFwidmNhbGVuZGFyXCIpIHtcbiAgICAgIC8vbm90IGEgdG9wLWxldmVsIHZjYWxlbmRhciBjb21wb25lbnRcbiAgICAgIHJldHVybiB2Y2FsO1xuICAgIH1cblxuICAgIC8vU3RvcmUgdnRpbWV6b25lIHN1YmNvbXBvbmVudHMgaW4gYW4gb2JqZWN0IHJlZmVyZW5jZSBieSB0emlkLlxuICAgIC8vU3RvcmUgcHJvcGVydGllcyBmcm9tIGV2ZXJ5dGhpbmcgZWxzZSBpbiBhbm90aGVyIGFycmF5XG4gICAgYWxsc3VicyA9IHZjYWwuZ2V0QWxsU3ViY29tcG9uZW50cygpO1xuICAgIHByb3BlcnRpZXMgPSBbXTtcbiAgICB2dGltZXpvbmVzID0ge307XG4gICAgZm9yIChpID0gMDsgaSA8IGFsbHN1YnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhbGxzdWJzW2ldLm5hbWUgPT09IFwidnRpbWV6b25lXCIpIHtcbiAgICAgICAgdHppZCA9IGFsbHN1YnNbaV0uZ2V0Rmlyc3RQcm9wZXJ0eShcInR6aWRcIikuZ2V0Rmlyc3RWYWx1ZSgpO1xuICAgICAgICB2dGltZXpvbmVzW3R6aWRdID0gYWxsc3Vic1tpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmNvbmNhdChhbGxzdWJzW2ldLmdldEFsbFByb3BlcnRpZXMoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9jcmVhdGUgYW4gb2JqZWN0IHdpdGggb25lIGVudHJ5IGZvciBlYWNoIHJlcXVpcmVkIHR6XG4gICAgcmVxVHppZCA9IHt9O1xuICAgIGZvciAoaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoKHR6aWQgPSBwcm9wZXJ0aWVzW2ldLmdldFBhcmFtZXRlcihcInR6aWRcIikpKSB7XG4gICAgICAgIHJlcVR6aWRbdHppZF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vZGVsZXRlIGFueSB2dGltZXpvbmVzIHRoYXQgYXJlIG5vdCBvbiB0aGUgcmVxVHppZCBsaXN0LlxuICAgIGZvciAoaSBpbiB2dGltZXpvbmVzKSB7XG4gICAgICBpZiAodnRpbWV6b25lcy5oYXNPd25Qcm9wZXJ0eShpKSAmJiAhcmVxVHppZFtpXSkge1xuICAgICAgICB2Y2FsLnJlbW92ZVN1YmNvbXBvbmVudCh2dGltZXpvbmVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL2NyZWF0ZSBhbnkgbWlzc2luZywgYnV0IHJlZ2lzdGVyZWQgdGltZXpvbmVzXG4gICAgZm9yIChpIGluIHJlcVR6aWQpIHtcbiAgICAgIGlmIChcbiAgICAgICAgcmVxVHppZC5oYXNPd25Qcm9wZXJ0eShpKSAmJlxuICAgICAgICAhdnRpbWV6b25lc1tpXSAmJlxuICAgICAgICBJQ0FMLlRpbWV6b25lU2VydmljZS5oYXMoaSlcbiAgICAgICkge1xuICAgICAgICB2Y2FsLmFkZFN1YmNvbXBvbmVudChJQ0FMLlRpbWV6b25lU2VydmljZS5nZXQoaSkuY29tcG9uZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmNhbDtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiB0eXBlIGlzIG9mIHRoZSBudW1iZXIgdHlwZSBhbmQgYWxzbyBOYU4uXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXIgICAgIFRoZSBudW1iZXIgdG8gY2hlY2tcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgVHJ1ZSwgaWYgdGhlIG51bWJlciBpcyBzdHJpY3RseSBOYU5cbiAgICovXG4gIGlzU3RyaWN0bHlOYU46IGZ1bmN0aW9uKG51bWJlcikge1xuICAgIHJldHVybiB0eXBlb2YobnVtYmVyKSA9PT0gJ251bWJlcicgJiYgaXNOYU4obnVtYmVyKTtcbiAgfSxcblxuICAvKipcbiAgICogUGFyc2VzIGEgc3RyaW5nIHZhbHVlIHRoYXQgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gaW50ZWdlciwgd2hlbiB0aGUgdmFsaWQgaXNcbiAgICogbm90IGFuIGludGVnZXIgdGhyb3dzIGEgZGVjb3JhdGlvbiBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyAgICAgUmF3IHN0cmluZyBpbnB1dFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICBQYXJzZWQgaW50ZWdlclxuICAgKi9cbiAgc3RyaWN0UGFyc2VJbnQ6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHZhciByZXN1bHQgPSBwYXJzZUludChzdHJpbmcsIDEwKTtcblxuICAgIGlmIChJQ0FMLmhlbHBlcnMuaXNTdHJpY3RseU5hTihyZXN1bHQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdDb3VsZCBub3QgZXh0cmFjdCBpbnRlZ2VyIGZyb20gXCInICsgc3RyaW5nICsgJ1wiJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIG9yIHJldHVybnMgYSBjbGFzcyBpbnN0YW5jZSBvZiBhIGdpdmVuIHR5cGUgd2l0aCB0aGUgaW5pdGlhbGl6YXRpb25cbiAgICogZGF0YSBpZiB0aGUgZGF0YSBpcyBub3QgYWxyZWFkeSBhbiBpbnN0YW5jZSBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogdmFyIHRpbWUgPSBuZXcgSUNBTC5UaW1lKC4uLik7XG4gICAqIHZhciByZXN1bHQgPSBJQ0FMLmhlbHBlcnMuZm9ybWF0Q2xhc3NUeXBlKHRpbWUsIElDQUwuVGltZSk7XG4gICAqXG4gICAqIChyZXN1bHQgaW5zdGFuY2VvZiBJQ0FMLlRpbWUpXG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogcmVzdWx0ID0gSUNBTC5oZWxwZXJzLmZvcm1hdENsYXNzVHlwZSh7fSwgSUNBTC5UaW1lKTtcbiAgICogKHJlc3VsdCBpc250YW5jZW9mIElDQUwuVGltZSlcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAgICAgICBvYmplY3QgaW5pdGlhbGl6YXRpb24gZGF0YVxuICAgKiBAcGFyYW0ge09iamVjdH0gdHlwZSAgICAgICBvYmplY3QgdHlwZSAobGlrZSBJQ0FMLlRpbWUpXG4gICAqIEByZXR1cm4gez99ICAgICAgICAgICAgICAgIEFuIGluc3RhbmNlIG9mIHRoZSBmb3VuZCB0eXBlLlxuICAgKi9cbiAgZm9ybWF0Q2xhc3NUeXBlOiBmdW5jdGlvbiBmb3JtYXRDbGFzc1R5cGUoZGF0YSwgdHlwZSkge1xuICAgIGlmICh0eXBlb2YoZGF0YSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgdHlwZSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIHJldHVybiBuZXcgdHlwZShkYXRhKTtcbiAgfSxcblxuICAvKipcbiAgICogSWRlbnRpY2FsIHRvIGluZGV4T2YgYnV0IHdpbGwgb25seSBtYXRjaCB2YWx1ZXMgd2hlbiB0aGV5IGFyZSBub3QgcHJlY2VkZWRcbiAgICogYnkgYSBiYWNrc2xhc2ggY2hhcmFjdGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYnVmZmVyICAgICAgICAgU3RyaW5nIHRvIHNlYXJjaFxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2VhcmNoICAgICAgICAgVmFsdWUgdG8gbG9vayBmb3JcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBvcyAgICAgICAgICAgIFN0YXJ0IHBvc2l0aW9uXG4gICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgICBUaGUgcG9zaXRpb24sIG9yIC0xIGlmIG5vdCBmb3VuZFxuICAgKi9cbiAgdW5lc2NhcGVkSW5kZXhPZjogZnVuY3Rpb24oYnVmZmVyLCBzZWFyY2gsIHBvcykge1xuICAgIHdoaWxlICgocG9zID0gYnVmZmVyLmluZGV4T2Yoc2VhcmNoLCBwb3MpKSAhPT0gLTEpIHtcbiAgICAgIGlmIChwb3MgPiAwICYmIGJ1ZmZlcltwb3MgLSAxXSA9PT0gJ1xcXFwnKSB7XG4gICAgICAgIHBvcyArPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGaW5kIHRoZSBpbmRleCBmb3IgaW5zZXJ0aW9uIHVzaW5nIGJpbmFyeSBzZWFyY2guXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgICAgICAgICAgICBUaGUgbGlzdCB0byBzZWFyY2hcbiAgICogQHBhcmFtIHs/fSBzZWVrVmFsICAgICAgICAgICAgIFRoZSB2YWx1ZSB0byBpbnNlcnRcbiAgICogQHBhcmFtIHtmdW5jdGlvbig/LD8pfSBjbXBmdW5jIFRoZSBjb21wYXJpc29uIGZ1bmMsIHRoYXQgY2FuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBhcmUgdHdvIHNlZWtWYWxzXG4gICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgICBUaGUgaW5zZXJ0IHBvc2l0aW9uXG4gICAqL1xuICBiaW5zZWFyY2hJbnNlcnQ6IGZ1bmN0aW9uKGxpc3QsIHNlZWtWYWwsIGNtcGZ1bmMpIHtcbiAgICBpZiAoIWxpc3QubGVuZ3RoKVxuICAgICAgcmV0dXJuIDA7XG5cbiAgICB2YXIgbG93ID0gMCwgaGlnaCA9IGxpc3QubGVuZ3RoIC0gMSxcbiAgICAgICAgbWlkLCBjbXB2YWw7XG5cbiAgICB3aGlsZSAobG93IDw9IGhpZ2gpIHtcbiAgICAgIG1pZCA9IGxvdyArIE1hdGguZmxvb3IoKGhpZ2ggLSBsb3cpIC8gMik7XG4gICAgICBjbXB2YWwgPSBjbXBmdW5jKHNlZWtWYWwsIGxpc3RbbWlkXSk7XG5cbiAgICAgIGlmIChjbXB2YWwgPCAwKVxuICAgICAgICBoaWdoID0gbWlkIC0gMTtcbiAgICAgIGVsc2UgaWYgKGNtcHZhbCA+IDApXG4gICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICBlbHNlXG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChjbXB2YWwgPCAwKVxuICAgICAgcmV0dXJuIG1pZDsgLy8gaW5zZXJ0aW9uIGlzIGRpc3BsYWNpbmcsIHNvIHVzZSBtaWQgb3V0cmlnaHQuXG4gICAgZWxzZSBpZiAoY21wdmFsID4gMClcbiAgICAgIHJldHVybiBtaWQgKyAxO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBtaWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlbmllbmNlIGZ1bmN0aW9uIGZvciBkZWJ1ZyBvdXRwdXRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGR1bXBuOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmdW5jdGlvbigpIHtcbiAgICBpZiAoIUlDQUwuZGVidWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIChjb25zb2xlKSAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2xvZycgaW4gY29uc29sZSkge1xuICAgICAgSUNBTC5oZWxwZXJzLmR1bXBuID0gZnVuY3Rpb24gY29uc29sZUR1bXBuKGlucHV0KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGlucHV0KTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIElDQUwuaGVscGVycy5kdW1wbiA9IGZ1bmN0aW9uIGdlY2tvRHVtcG4oaW5wdXQpIHtcbiAgICAgICAgZHVtcChpbnB1dCArICdcXG4nKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgSUNBTC5oZWxwZXJzLmR1bXBuKGFyZ3VtZW50c1swXSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENsb25lIHRoZSBwYXNzZWQgb2JqZWN0IG9yIHByaW1pdGl2ZS4gQnkgZGVmYXVsdCBhIHNoYWxsb3cgY2xvbmUgd2lsbCBiZVxuICAgKiBleGVjdXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBhU3JjICAgICAgICAgICAgVGhlIHRoaW5nIHRvIGNsb25lXG4gICAqIEBwYXJhbSB7Qm9vbGVhbj19IGFEZWVwICAgIElmIHRydWUsIGEgZGVlcCBjbG9uZSB3aWxsIGJlIHBlcmZvcm1lZFxuICAgKiBAcmV0dXJuIHsqfSAgICAgICAgICAgICAgICBUaGUgY29weSBvZiB0aGUgdGhpbmdcbiAgICovXG4gIGNsb25lOiBmdW5jdGlvbihhU3JjLCBhRGVlcCkge1xuICAgIGlmICghYVNyYyB8fCB0eXBlb2YgYVNyYyAhPSBcIm9iamVjdFwiKSB7XG4gICAgICByZXR1cm4gYVNyYztcbiAgICB9IGVsc2UgaWYgKGFTcmMgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoYVNyYy5nZXRUaW1lKCkpO1xuICAgIH0gZWxzZSBpZiAoXCJjbG9uZVwiIGluIGFTcmMpIHtcbiAgICAgIHJldHVybiBhU3JjLmNsb25lKCk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFTcmMpKSB7XG4gICAgICB2YXIgYXJyID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFTcmMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyLnB1c2goYURlZXAgPyBJQ0FMLmhlbHBlcnMuY2xvbmUoYVNyY1tpXSwgdHJ1ZSkgOiBhU3JjW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gYVNyYykge1xuICAgICAgICAvLyB1c2VzIHByb3RvdHlwZSBtZXRob2QgdG8gYWxsb3cgdXNlIG9mIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYVNyYywgbmFtZSkpIHtcbiAgICAgICAgICBpZiAoYURlZXApIHtcbiAgICAgICAgICAgIG9ialtuYW1lXSA9IElDQUwuaGVscGVycy5jbG9uZShhU3JjW25hbWVdLCB0cnVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2JqW25hbWVdID0gYVNyY1tuYW1lXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBQZXJmb3JtcyBpQ2FsZW5kYXIgbGluZSBmb2xkaW5nLiBBIGxpbmUgZW5kaW5nIGNoYXJhY3RlciBpcyBpbnNlcnRlZCBhbmRcbiAgICogdGhlIG5leHQgbGluZSBiZWdpbnMgd2l0aCBhIHdoaXRlc3BhY2UuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIFNVTU1BUlk6VGhpcyBsaW5lIHdpbGwgYmUgZm9sZFxuICAgKiAgZWQgcmlnaHQgaW4gdGhlIG1pZGRsZSBvZiBhIHdvcmQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhTGluZSAgICAgIFRoZSBsaW5lIHRvIGZvbGRcbiAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICAgVGhlIGZvbGRlZCBsaW5lXG4gICAqL1xuICBmb2xkbGluZTogZnVuY3Rpb24gZm9sZGxpbmUoYUxpbmUpIHtcbiAgICB2YXIgcmVzdWx0ID0gXCJcIjtcbiAgICB2YXIgbGluZSA9IGFMaW5lIHx8IFwiXCIsIHBvcyA9IDAsIGxpbmVfbGVuZ3RoID0gMDtcbiAgICAvL3BvcyBjb3VudHMgcG9zaXRpb24gaW4gbGluZSBmb3IgdGhlIFVURi0xNiBwcmVzZW50YXRpb25cbiAgICAvL2xpbmVfbGVuZ3RoIGNvdW50cyB0aGUgYnl0ZXMgZm9yIHRoZSBVVEYtOCBwcmVzZW50YXRpb25cbiAgICB3aGlsZSAobGluZS5sZW5ndGgpIHtcbiAgICAgIHZhciBjcCA9IGxpbmUuY29kZVBvaW50QXQocG9zKTtcbiAgICAgIGlmIChjcCA8IDEyOCkgKytsaW5lX2xlbmd0aDtcbiAgICAgIGVsc2UgaWYgKGNwIDwgMjA0OCkgbGluZV9sZW5ndGggKz0gMjsvL25lZWRzIDIgVVRGLTggYnl0ZXNcbiAgICAgIGVsc2UgaWYgKGNwIDwgNjU1MzYpIGxpbmVfbGVuZ3RoICs9IDM7XG4gICAgICBlbHNlIGxpbmVfbGVuZ3RoICs9IDQ7IC8vY3AgaXMgbGVzcyB0aGFuIDExMTQxMTJcbiAgICAgIGlmIChsaW5lX2xlbmd0aCA8IElDQUwuZm9sZExlbmd0aCArIDEpXG4gICAgICAgIHBvcyArPSBjcCA+IDY1NTM1ID8gMiA6IDE7XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ICs9IElDQUwubmV3TGluZUNoYXIgKyBcIiBcIiArIGxpbmUuc3Vic3RyaW5nKDAsIHBvcyk7XG4gICAgICAgIGxpbmUgPSBsaW5lLnN1YnN0cmluZyhwb3MpO1xuICAgICAgICBwb3MgPSBsaW5lX2xlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuc3Vic3RyKElDQUwubmV3TGluZUNoYXIubGVuZ3RoICsgMSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFBhZHMgdGhlIGdpdmVuIHN0cmluZyBvciBudW1iZXIgd2l0aCB6ZXJvcyBzbyBpdCB3aWxsIGhhdmUgYXQgbGVhc3QgdHdvXG4gICAqIGNoYXJhY3RlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gZGF0YSAgICBUaGUgc3RyaW5nIG9yIG51bWJlciB0byBwYWRcbiAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICAgICAgIFRoZSBudW1iZXIgcGFkZGVkIGFzIGEgc3RyaW5nXG4gICAqL1xuICBwYWQyOiBmdW5jdGlvbiBwYWQoZGF0YSkge1xuICAgIGlmICh0eXBlb2YoZGF0YSkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBoYW5kbGUgZnJhY3Rpb25zLlxuICAgICAgaWYgKHR5cGVvZihkYXRhKSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgZGF0YSA9IHBhcnNlSW50KGRhdGEpO1xuICAgICAgfVxuICAgICAgZGF0YSA9IFN0cmluZyhkYXRhKTtcbiAgICB9XG5cbiAgICB2YXIgbGVuID0gZGF0YS5sZW5ndGg7XG5cbiAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gJzAwJztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuICcwJyArIGRhdGE7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRydW5jYXRlcyB0aGUgZ2l2ZW4gbnVtYmVyLCBjb3JyZWN0bHkgaGFuZGxpbmcgbmVnYXRpdmUgbnVtYmVycy5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG51bWJlciAgICAgVGhlIG51bWJlciB0byB0cnVuY2F0ZVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICBUaGUgdHJ1bmNhdGVkIG51bWJlclxuICAgKi9cbiAgdHJ1bmM6IGZ1bmN0aW9uIHRydW5jKG51bWJlcikge1xuICAgIHJldHVybiAobnVtYmVyIDwgMCA/IE1hdGguY2VpbChudW1iZXIpIDogTWF0aC5mbG9vcihudW1iZXIpKTtcbiAgfSxcblxuICAvKipcbiAgICogUG9vci1tYW4ncyBjcm9zcy1icm93c2VyIGluaGVyaXRhbmNlIGZvciBKYXZhU2NyaXB0LiBEb2Vzbid0IHN1cHBvcnQgYWxsXG4gICAqIHRoZSBmZWF0dXJlcywgYnV0IGVub3VnaCBmb3Igb3VyIHVzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBiYXNlICAgICBUaGUgYmFzZSBjbGFzcyBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2hpbGQgICAgVGhlIGNoaWxkIGNsYXNzIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZXh0cmEgICAgICBFeHRlbmRzIHRoZSBwcm90b3R5cGUgd2l0aCBleHRyYSBwcm9wZXJ0aWVzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIG1ldGhvZHNcbiAgICovXG4gIGluaGVyaXRzOiBmdW5jdGlvbihiYXNlLCBjaGlsZCwgZXh0cmEpIHtcbiAgICBmdW5jdGlvbiBGKCkge31cbiAgICBGLnByb3RvdHlwZSA9IGJhc2UucHJvdG90eXBlO1xuICAgIGNoaWxkLnByb3RvdHlwZSA9IG5ldyBGKCk7XG5cbiAgICBpZiAoZXh0cmEpIHtcbiAgICAgIElDQUwuaGVscGVycy5leHRlbmQoZXh0cmEsIGNoaWxkLnByb3RvdHlwZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBQb29yLW1hbidzIGNyb3NzLWJyb3dzZXIgb2JqZWN0IGV4dGVuc2lvbi4gRG9lc24ndCBzdXBwb3J0IGFsbCB0aGVcbiAgICogZmVhdHVyZXMsIGJ1dCBlbm91Z2ggZm9yIG91ciB1c2FnZS4gTm90ZSB0aGF0IHRoZSB0YXJnZXQncyBwcm9wZXJ0aWVzIGFyZVxuICAgKiBub3Qgb3ZlcndyaXR0ZW4gd2l0aCB0aGUgc291cmNlIHByb3BlcnRpZXMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBjaGlsZCA9IElDQUwuaGVscGVycy5leHRlbmQocGFyZW50LCB7XG4gICAqICAgXCJiYXJcIjogMTIzXG4gICAqIH0pO1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlICAgICBUaGUgb2JqZWN0IHRvIGV4dGVuZFxuICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0ICAgICBUaGUgb2JqZWN0IHRvIGV4dGVuZCB3aXRoXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgIFJldHVybnMgdGhlIHRhcmdldC5cbiAgICovXG4gIGV4dGVuZDogZnVuY3Rpb24oc291cmNlLCB0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICB2YXIgZGVzY3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KTtcbiAgICAgIGlmIChkZXNjciAmJiAhT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbn07XG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICogUG9ydGlvbnMgQ29weXJpZ2h0IChDKSBQaGlsaXBwIEtld2lzY2gsIDIwMTEtMjAxNSAqL1xuXG4vKiogQG5hbWVzcGFjZSBJQ0FMICovXG5cblxuLyoqXG4gKiBUaGlzIHN5bWJvbCBpcyBmdXJ0aGVyIGRlc2NyaWJlZCBsYXRlciBvblxuICogQGlnbm9yZVxuICovXG5JQ0FMLmRlc2lnbiA9IChmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBGUk9NX0lDQUxfTkVXTElORSA9IC9cXFxcXFxcXHxcXFxcO3xcXFxcLHxcXFxcW05uXS9nO1xuICB2YXIgVE9fSUNBTF9ORVdMSU5FID0gL1xcXFx8O3wsfFxcbi9nO1xuICB2YXIgRlJPTV9WQ0FSRF9ORVdMSU5FID0gL1xcXFxcXFxcfFxcXFwsfFxcXFxbTm5dL2c7XG4gIHZhciBUT19WQ0FSRF9ORVdMSU5FID0gL1xcXFx8LHxcXG4vZztcblxuICBmdW5jdGlvbiBjcmVhdGVUZXh0VHlwZShmcm9tTmV3bGluZSwgdG9OZXdsaW5lKSB7XG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIG1hdGNoZXM6IC8uKi8sXG5cbiAgICAgIGZyb21JQ0FMOiBmdW5jdGlvbihhVmFsdWUsIHN0cnVjdHVyZWRFc2NhcGUpIHtcbiAgICAgICAgcmV0dXJuIHJlcGxhY2VOZXdsaW5lKGFWYWx1ZSwgZnJvbU5ld2xpbmUsIHN0cnVjdHVyZWRFc2NhcGUpO1xuICAgICAgfSxcblxuICAgICAgdG9JQ0FMOiBmdW5jdGlvbihhVmFsdWUsIHN0cnVjdHVyZWRFc2NhcGUpIHtcbiAgICAgICAgdmFyIHJlZ0V4ID0gdG9OZXdsaW5lO1xuICAgICAgICBpZiAoc3RydWN0dXJlZEVzY2FwZSlcbiAgICAgICAgICByZWdFeCA9IG5ldyBSZWdFeHAocmVnRXguc291cmNlICsgJ3wnICsgc3RydWN0dXJlZEVzY2FwZSk7XG4gICAgICAgIHJldHVybiBhVmFsdWUucmVwbGFjZShyZWdFeCwgZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgc3dpdGNoIChzdHIpIHtcbiAgICAgICAgICBjYXNlIFwiXFxcXFwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiXFxcXFxcXFxcIjtcbiAgICAgICAgICBjYXNlIFwiO1wiOlxuICAgICAgICAgICAgcmV0dXJuIFwiXFxcXDtcIjtcbiAgICAgICAgICBjYXNlIFwiLFwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiXFxcXCxcIjtcbiAgICAgICAgICBjYXNlIFwiXFxuXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJcXFxcblwiO1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBkZWZhdWx0IHR5cGVzIHVzZWQgbXVsdGlwbGUgdGltZXNcbiAgdmFyIERFRkFVTFRfVFlQRV9URVhUID0geyBkZWZhdWx0VHlwZTogXCJ0ZXh0XCIgfTtcbiAgdmFyIERFRkFVTFRfVFlQRV9URVhUX01VTFRJID0geyBkZWZhdWx0VHlwZTogXCJ0ZXh0XCIsIG11bHRpVmFsdWU6IFwiLFwiIH07XG4gIHZhciBERUZBVUxUX1RZUEVfVEVYVF9TVFJVQ1RVUkVEID0geyBkZWZhdWx0VHlwZTogXCJ0ZXh0XCIsIHN0cnVjdHVyZWRWYWx1ZTogXCI7XCIgfTtcbiAgdmFyIERFRkFVTFRfVFlQRV9JTlRFR0VSID0geyBkZWZhdWx0VHlwZTogXCJpbnRlZ2VyXCIgfTtcbiAgdmFyIERFRkFVTFRfVFlQRV9EQVRFVElNRV9EQVRFID0geyBkZWZhdWx0VHlwZTogXCJkYXRlLXRpbWVcIiwgYWxsb3dlZFR5cGVzOiBbXCJkYXRlLXRpbWVcIiwgXCJkYXRlXCJdIH07XG4gIHZhciBERUZBVUxUX1RZUEVfREFURVRJTUUgPSB7IGRlZmF1bHRUeXBlOiBcImRhdGUtdGltZVwiIH07XG4gIHZhciBERUZBVUxUX1RZUEVfVVJJID0geyBkZWZhdWx0VHlwZTogXCJ1cmlcIiB9O1xuICB2YXIgREVGQVVMVF9UWVBFX1VUQ09GRlNFVCA9IHsgZGVmYXVsdFR5cGU6IFwidXRjLW9mZnNldFwiIH07XG4gIHZhciBERUZBVUxUX1RZUEVfUkVDVVIgPSB7IGRlZmF1bHRUeXBlOiBcInJlY3VyXCIgfTtcbiAgdmFyIERFRkFVTFRfVFlQRV9EQVRFX0FORE9SX1RJTUUgPSB7IGRlZmF1bHRUeXBlOiBcImRhdGUtYW5kLW9yLXRpbWVcIiwgYWxsb3dlZFR5cGVzOiBbXCJkYXRlLXRpbWVcIiwgXCJkYXRlXCIsIFwidGV4dFwiXSB9O1xuXG4gIGZ1bmN0aW9uIHJlcGxhY2VOZXdsaW5lUmVwbGFjZShzdHJpbmcpIHtcbiAgICBzd2l0Y2ggKHN0cmluZykge1xuICAgICAgY2FzZSBcIlxcXFxcXFxcXCI6XG4gICAgICAgIHJldHVybiBcIlxcXFxcIjtcbiAgICAgIGNhc2UgXCJcXFxcO1wiOlxuICAgICAgICByZXR1cm4gXCI7XCI7XG4gICAgICBjYXNlIFwiXFxcXCxcIjpcbiAgICAgICAgcmV0dXJuIFwiLFwiO1xuICAgICAgY2FzZSBcIlxcXFxuXCI6XG4gICAgICBjYXNlIFwiXFxcXE5cIjpcbiAgICAgICAgcmV0dXJuIFwiXFxuXCI7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXBsYWNlTmV3bGluZSh2YWx1ZSwgbmV3bGluZSwgc3RydWN0dXJlZEVzY2FwZSkge1xuICAgIC8vIGF2b2lkIHJlZ2V4IHdoZW4gcG9zc2libGUuXG4gICAgaWYgKHZhbHVlLmluZGV4T2YoJ1xcXFwnKSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHN0cnVjdHVyZWRFc2NhcGUpXG4gICAgICBuZXdsaW5lID0gbmV3IFJlZ0V4cChuZXdsaW5lLnNvdXJjZSArICd8XFxcXFxcXFwnICsgc3RydWN0dXJlZEVzY2FwZSk7XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UobmV3bGluZSwgcmVwbGFjZU5ld2xpbmVSZXBsYWNlKTtcbiAgfVxuXG4gIHZhciBjb21tb25Qcm9wZXJ0aWVzID0ge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBERUZBVUxUX1RZUEVfVEVYVF9NVUxUSSxcbiAgICBcInVybFwiOiBERUZBVUxUX1RZUEVfVVJJLFxuICAgIFwidmVyc2lvblwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBcInVpZFwiOiBERUZBVUxUX1RZUEVfVEVYVFxuICB9O1xuXG4gIHZhciBjb21tb25WYWx1ZXMgPSB7XG4gICAgXCJib29sZWFuXCI6IHtcbiAgICAgIHZhbHVlczogW1wiVFJVRVwiLCBcIkZBTFNFXCJdLFxuXG4gICAgICBmcm9tSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHN3aXRjaCAoYVZhbHVlKSB7XG4gICAgICAgICAgY2FzZSAnVFJVRSc6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICBjYXNlICdGQUxTRSc6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vVE9ETzogcGFyc2VyIHdhcm5pbmdcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgdG9JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgaWYgKGFWYWx1ZSkge1xuICAgICAgICAgIHJldHVybiAnVFJVRSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdGQUxTRSc7XG4gICAgICB9XG5cbiAgICB9LFxuICAgIGZsb2F0OiB7XG4gICAgICBtYXRjaGVzOiAvXlsrLV0/XFxkK1xcLlxcZCskLyxcblxuICAgICAgZnJvbUlDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICB2YXIgcGFyc2VkID0gcGFyc2VGbG9hdChhVmFsdWUpO1xuICAgICAgICBpZiAoSUNBTC5oZWxwZXJzLmlzU3RyaWN0bHlOYU4ocGFyc2VkKSkge1xuICAgICAgICAgIC8vIFRPRE86IHBhcnNlciB3YXJuaW5nXG4gICAgICAgICAgcmV0dXJuIDAuMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgfSxcblxuICAgICAgdG9JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhhVmFsdWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgaW50ZWdlcjoge1xuICAgICAgZnJvbUlDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoYVZhbHVlKTtcbiAgICAgICAgaWYgKElDQUwuaGVscGVycy5pc1N0cmljdGx5TmFOKHBhcnNlZCkpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgfSxcblxuICAgICAgdG9JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhhVmFsdWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgXCJ1dGMtb2Zmc2V0XCI6IHtcbiAgICAgIHRvSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIGlmIChhVmFsdWUubGVuZ3RoIDwgNykge1xuICAgICAgICAgIC8vIG5vIHNlY29uZHNcbiAgICAgICAgICAvLyAtMDUwMFxuICAgICAgICAgIHJldHVybiBhVmFsdWUuc3Vic3RyKDAsIDMpICtcbiAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cig0LCAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBzZWNvbmRzXG4gICAgICAgICAgLy8gLTA1MDAwMFxuICAgICAgICAgIHJldHVybiBhVmFsdWUuc3Vic3RyKDAsIDMpICtcbiAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cig0LCAyKSArXG4gICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoNywgMik7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGZyb21JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgaWYgKGFWYWx1ZS5sZW5ndGggPCA2KSB7XG4gICAgICAgICAgLy8gbm8gc2Vjb25kc1xuICAgICAgICAgIC8vIC0wNTowMFxuICAgICAgICAgIHJldHVybiBhVmFsdWUuc3Vic3RyKDAsIDMpICsgJzonICtcbiAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cigzLCAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBzZWNvbmRzXG4gICAgICAgICAgLy8gLTA1OjAwOjAwXG4gICAgICAgICAgcmV0dXJuIGFWYWx1ZS5zdWJzdHIoMCwgMykgKyAnOicgK1xuICAgICAgICAgICAgICAgICBhVmFsdWUuc3Vic3RyKDMsIDIpICsgJzonICtcbiAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cig1LCAyKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gSUNBTC5VdGNPZmZzZXQuZnJvbVN0cmluZyhhVmFsdWUpO1xuICAgICAgfSxcblxuICAgICAgdW5kZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhVmFsdWUudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIGljYWxQYXJhbXMgPSB7XG4gICAgLy8gQWx0aG91Z2ggdGhlIHN5bnRheCBpcyBEUVVPVEUgdXJpIERRVU9URSwgSSBkb24ndCB0aGluayB3ZSBzaG91bGRcbiAgICAvLyBlbmZvY2UgYW55dGhpbmcgYXNpZGUgZnJvbSBpdCBiZWluZyBhIHZhbGlkIGNvbnRlbnQgbGluZS5cbiAgICAvL1xuICAgIC8vIEF0IGxlYXN0IHNvbWUgcGFyYW1zIHJlcXVpcmUgLSBpZiBtdWx0aSB2YWx1ZXMgYXJlIHVzZWQgLSBEUVVPVEVzXG4gICAgLy8gZm9yIGVhY2ggb2YgaXRzIHZhbHVlcyAtIGUuZy4gZGVsZWdhdGVkLWZyb209XCJ1cmkxXCIsXCJ1cmkyXCJcbiAgICAvLyBUbyBpbmRpY2F0ZSB0aGlzLCBJIGludHJvZHVjZWQgdGhlIG5ldyBrL3YgcGFpclxuICAgIC8vIG11bHRpVmFsdWVTZXBhcmF0ZURRdW90ZTogdHJ1ZVxuICAgIC8vXG4gICAgLy8gXCJBTFRSRVBcIjogeyAuLi4gfSxcblxuICAgIC8vIENOIGp1c3Qgd2FudHMgYSBwYXJhbS12YWx1ZVxuICAgIC8vIFwiQ05cIjogeyAuLi4gfVxuXG4gICAgXCJjdXR5cGVcIjoge1xuICAgICAgdmFsdWVzOiBbXCJJTkRJVklEVUFMXCIsIFwiR1JPVVBcIiwgXCJSRVNPVVJDRVwiLCBcIlJPT01cIiwgXCJVTktOT1dOXCJdLFxuICAgICAgYWxsb3dYTmFtZTogdHJ1ZSxcbiAgICAgIGFsbG93SWFuYVRva2VuOiB0cnVlXG4gICAgfSxcblxuICAgIFwiZGVsZWdhdGVkLWZyb21cIjoge1xuICAgICAgdmFsdWVUeXBlOiBcImNhbC1hZGRyZXNzXCIsXG4gICAgICBtdWx0aVZhbHVlOiBcIixcIixcbiAgICAgIG11bHRpVmFsdWVTZXBhcmF0ZURRdW90ZTogdHJ1ZVxuICAgIH0sXG4gICAgXCJkZWxlZ2F0ZWQtdG9cIjoge1xuICAgICAgdmFsdWVUeXBlOiBcImNhbC1hZGRyZXNzXCIsXG4gICAgICBtdWx0aVZhbHVlOiBcIixcIixcbiAgICAgIG11bHRpVmFsdWVTZXBhcmF0ZURRdW90ZTogdHJ1ZVxuICAgIH0sXG4gICAgLy8gXCJESVJcIjogeyAuLi4gfSwgLy8gU2VlIEFMVFJFUFxuICAgIFwiZW5jb2RpbmdcIjoge1xuICAgICAgdmFsdWVzOiBbXCI4QklUXCIsIFwiQkFTRTY0XCJdXG4gICAgfSxcbiAgICAvLyBcIkZNVFRZUEVcIjogeyAuLi4gfSwgLy8gU2VlIEFMVFJFUFxuICAgIFwiZmJ0eXBlXCI6IHtcbiAgICAgIHZhbHVlczogW1wiRlJFRVwiLCBcIkJVU1lcIiwgXCJCVVNZLVVOQVZBSUxBQkxFXCIsIFwiQlVTWS1URU5UQVRJVkVcIl0sXG4gICAgICBhbGxvd1hOYW1lOiB0cnVlLFxuICAgICAgYWxsb3dJYW5hVG9rZW46IHRydWVcbiAgICB9LFxuICAgIC8vIFwiTEFOR1VBR0VcIjogeyAuLi4gfSwgLy8gU2VlIEFMVFJFUFxuICAgIFwibWVtYmVyXCI6IHtcbiAgICAgIHZhbHVlVHlwZTogXCJjYWwtYWRkcmVzc1wiLFxuICAgICAgbXVsdGlWYWx1ZTogXCIsXCIsXG4gICAgICBtdWx0aVZhbHVlU2VwYXJhdGVEUXVvdGU6IHRydWVcbiAgICB9LFxuICAgIFwicGFydHN0YXRcIjoge1xuICAgICAgLy8gVE9ETyBUaGVzZSB2YWx1ZXMgYXJlIGFjdHVhbGx5IGRpZmZlcmVudCBwZXItY29tcG9uZW50XG4gICAgICB2YWx1ZXM6IFtcIk5FRURTLUFDVElPTlwiLCBcIkFDQ0VQVEVEXCIsIFwiREVDTElORURcIiwgXCJURU5UQVRJVkVcIixcbiAgICAgICAgICAgICAgIFwiREVMRUdBVEVEXCIsIFwiQ09NUExFVEVEXCIsIFwiSU4tUFJPQ0VTU1wiXSxcbiAgICAgIGFsbG93WE5hbWU6IHRydWUsXG4gICAgICBhbGxvd0lhbmFUb2tlbjogdHJ1ZVxuICAgIH0sXG4gICAgXCJyYW5nZVwiOiB7XG4gICAgICB2YWx1ZXM6IFtcIlRISVNBTkRGVVRVUkVcIl1cbiAgICB9LFxuICAgIFwicmVsYXRlZFwiOiB7XG4gICAgICB2YWx1ZXM6IFtcIlNUQVJUXCIsIFwiRU5EXCJdXG4gICAgfSxcbiAgICBcInJlbHR5cGVcIjoge1xuICAgICAgdmFsdWVzOiBbXCJQQVJFTlRcIiwgXCJDSElMRFwiLCBcIlNJQkxJTkdcIl0sXG4gICAgICBhbGxvd1hOYW1lOiB0cnVlLFxuICAgICAgYWxsb3dJYW5hVG9rZW46IHRydWVcbiAgICB9LFxuICAgIFwicm9sZVwiOiB7XG4gICAgICB2YWx1ZXM6IFtcIlJFUS1QQVJUSUNJUEFOVFwiLCBcIkNIQUlSXCIsXG4gICAgICAgICAgICAgICBcIk9QVC1QQVJUSUNJUEFOVFwiLCBcIk5PTi1QQVJUSUNJUEFOVFwiXSxcbiAgICAgIGFsbG93WE5hbWU6IHRydWUsXG4gICAgICBhbGxvd0lhbmFUb2tlbjogdHJ1ZVxuICAgIH0sXG4gICAgXCJyc3ZwXCI6IHtcbiAgICAgIHZhbHVlczogW1wiVFJVRVwiLCBcIkZBTFNFXCJdXG4gICAgfSxcbiAgICBcInNlbnQtYnlcIjoge1xuICAgICAgdmFsdWVUeXBlOiBcImNhbC1hZGRyZXNzXCJcbiAgICB9LFxuICAgIFwidHppZFwiOiB7XG4gICAgICBtYXRjaGVzOiAvXlxcLy9cbiAgICB9LFxuICAgIFwidmFsdWVcIjoge1xuICAgICAgLy8gc2luY2UgdGhlIHZhbHVlIGhlcmUgaXMgYSAndHlwZScgbG93ZXJjYXNlIGlzIHVzZWQuXG4gICAgICB2YWx1ZXM6IFtcImJpbmFyeVwiLCBcImJvb2xlYW5cIiwgXCJjYWwtYWRkcmVzc1wiLCBcImRhdGVcIiwgXCJkYXRlLXRpbWVcIixcbiAgICAgICAgICAgICAgIFwiZHVyYXRpb25cIiwgXCJmbG9hdFwiLCBcImludGVnZXJcIiwgXCJwZXJpb2RcIiwgXCJyZWN1clwiLCBcInRleHRcIixcbiAgICAgICAgICAgICAgIFwidGltZVwiLCBcInVyaVwiLCBcInV0Yy1vZmZzZXRcIl0sXG4gICAgICBhbGxvd1hOYW1lOiB0cnVlLFxuICAgICAgYWxsb3dJYW5hVG9rZW46IHRydWVcbiAgICB9XG4gIH07XG5cbiAgLy8gV2hlbiBhZGRpbmcgYSB2YWx1ZSBoZXJlLCBiZSBzdXJlIHRvIGFkZCBpdCB0byB0aGUgcGFyYW1ldGVyIHR5cGVzIVxuICB2YXIgaWNhbFZhbHVlcyA9IElDQUwuaGVscGVycy5leHRlbmQoY29tbW9uVmFsdWVzLCB7XG4gICAgdGV4dDogY3JlYXRlVGV4dFR5cGUoRlJPTV9JQ0FMX05FV0xJTkUsIFRPX0lDQUxfTkVXTElORSksXG5cbiAgICB1cmk6IHtcbiAgICAgIC8vIFRPRE9cbiAgICAgIC8qIC4uLiAqL1xuICAgIH0sXG5cbiAgICBcImJpbmFyeVwiOiB7XG4gICAgICBkZWNvcmF0ZTogZnVuY3Rpb24oYVN0cmluZykge1xuICAgICAgICByZXR1cm4gSUNBTC5CaW5hcnkuZnJvbVN0cmluZyhhU3RyaW5nKTtcbiAgICAgIH0sXG5cbiAgICAgIHVuZGVjb3JhdGU6IGZ1bmN0aW9uKGFCaW5hcnkpIHtcbiAgICAgICAgcmV0dXJuIGFCaW5hcnkudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiY2FsLWFkZHJlc3NcIjoge1xuICAgICAgLy8gbmVlZHMgdG8gYmUgYW4gdXJpXG4gICAgfSxcbiAgICBcImRhdGVcIjoge1xuICAgICAgZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSwgYVByb3ApIHtcbiAgICAgICAgaWYgKGRlc2lnbi5zdHJpY3QpIHtcbiAgICAgICAgICByZXR1cm4gSUNBTC5UaW1lLmZyb21EYXRlU3RyaW5nKGFWYWx1ZSwgYVByb3ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBJQ0FMLlRpbWUuZnJvbVN0cmluZyhhVmFsdWUsIGFQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiB1bmRlY29yYXRlcyBhIHRpbWUgb2JqZWN0LlxuICAgICAgICovXG4gICAgICB1bmRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFWYWx1ZS50b1N0cmluZygpO1xuICAgICAgfSxcblxuICAgICAgZnJvbUlDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICAvLyBmcm9tOiAyMDEyMDkwMVxuICAgICAgICAvLyB0bzogMjAxMi0wOS0wMVxuICAgICAgICBpZiAoIWRlc2lnbi5zdHJpY3QgJiYgYVZhbHVlLmxlbmd0aCA+PSAxNSkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgcHJvYmFibHkgYSBkYXRlLXRpbWUsIGUuZy4gMjAxMjA5MDFUMTMwMDAwWlxuICAgICAgICAgIHJldHVybiBpY2FsVmFsdWVzW1wiZGF0ZS10aW1lXCJdLmZyb21JQ0FMKGFWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGFWYWx1ZS5zdWJzdHIoMCwgNCkgKyAnLScgK1xuICAgICAgICAgICAgICAgICBhVmFsdWUuc3Vic3RyKDQsIDIpICsgJy0nICtcbiAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cig2LCAyKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgdG9JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgLy8gZnJvbTogMjAxMi0wOS0wMVxuICAgICAgICAvLyB0bzogMjAxMjA5MDFcbiAgICAgICAgdmFyIGxlbiA9IGFWYWx1ZS5sZW5ndGg7XG5cbiAgICAgICAgaWYgKGxlbiA9PSAxMCkge1xuICAgICAgICAgIHJldHVybiBhVmFsdWUuc3Vic3RyKDAsIDQpICtcbiAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cig1LCAyKSArXG4gICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoOCwgMik7XG4gICAgICAgIH0gZWxzZSBpZiAobGVuID49IDE5KSB7XG4gICAgICAgICAgcmV0dXJuIGljYWxWYWx1ZXNbXCJkYXRlLXRpbWVcIl0udG9JQ0FMKGFWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9UT0RPOiBzZXJpYWxpemUgd2FybmluZz9cbiAgICAgICAgICByZXR1cm4gYVZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiZGF0ZS10aW1lXCI6IHtcbiAgICAgIGZyb21JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgLy8gZnJvbTogMjAxMjA5MDFUMTMwMDAwXG4gICAgICAgIC8vIHRvOiAyMDEyLTA5LTAxVDEzOjAwOjAwXG4gICAgICAgIGlmICghZGVzaWduLnN0cmljdCAmJiBhVmFsdWUubGVuZ3RoID09IDgpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGEgZGF0ZSwgZS5nLiAyMDEyMDkwMVxuICAgICAgICAgIHJldHVybiBpY2FsVmFsdWVzLmRhdGUuZnJvbUlDQUwoYVZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gYVZhbHVlLnN1YnN0cigwLCA0KSArICctJyArXG4gICAgICAgICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoNCwgMikgKyAnLScgK1xuICAgICAgICAgICAgICAgICAgICAgICBhVmFsdWUuc3Vic3RyKDYsIDIpICsgJ1QnICtcbiAgICAgICAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cig5LCAyKSArICc6JyArXG4gICAgICAgICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoMTEsIDIpICsgJzonICtcbiAgICAgICAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cigxMywgMik7XG5cbiAgICAgICAgICBpZiAoYVZhbHVlWzE1XSAmJiBhVmFsdWVbMTVdID09PSAnWicpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnWic7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgdG9JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgLy8gZnJvbTogMjAxMi0wOS0wMVQxMzowMDowMFxuICAgICAgICAvLyB0bzogMjAxMjA5MDFUMTMwMDAwXG4gICAgICAgIHZhciBsZW4gPSBhVmFsdWUubGVuZ3RoO1xuXG4gICAgICAgIGlmIChsZW4gPT0gMTAgJiYgIWRlc2lnbi5zdHJpY3QpIHtcbiAgICAgICAgICByZXR1cm4gaWNhbFZhbHVlcy5kYXRlLnRvSUNBTChhVmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGxlbiA+PSAxOSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBhVmFsdWUuc3Vic3RyKDAsIDQpICtcbiAgICAgICAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cig1LCAyKSArXG4gICAgICAgICAgICAgICAgICAgICAgIC8vIGdyYWIgdGhlIChERFRISCkgc2VnbWVudFxuICAgICAgICAgICAgICAgICAgICAgICBhVmFsdWUuc3Vic3RyKDgsIDUpICtcbiAgICAgICAgICAgICAgICAgICAgICAgLy8gTU1cbiAgICAgICAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cigxNCwgMikgK1xuICAgICAgICAgICAgICAgICAgICAgICAvLyBTU1xuICAgICAgICAgICAgICAgICAgICAgICBhVmFsdWUuc3Vic3RyKDE3LCAyKTtcblxuICAgICAgICAgIGlmIChhVmFsdWVbMTldICYmIGFWYWx1ZVsxOV0gPT09ICdaJykge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICdaJztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUT0RPOiBlcnJvclxuICAgICAgICAgIHJldHVybiBhVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUsIGFQcm9wKSB7XG4gICAgICAgIGlmIChkZXNpZ24uc3RyaWN0KSB7XG4gICAgICAgICAgcmV0dXJuIElDQUwuVGltZS5mcm9tRGF0ZVRpbWVTdHJpbmcoYVZhbHVlLCBhUHJvcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIElDQUwuVGltZS5mcm9tU3RyaW5nKGFWYWx1ZSwgYVByb3ApO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB1bmRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFWYWx1ZS50b1N0cmluZygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZHVyYXRpb246IHtcbiAgICAgIGRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIElDQUwuRHVyYXRpb24uZnJvbVN0cmluZyhhVmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHVuZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gYVZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBwZXJpb2Q6IHtcblxuICAgICAgZnJvbUlDQUw6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICB2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJy8nKTtcbiAgICAgICAgcGFydHNbMF0gPSBpY2FsVmFsdWVzWydkYXRlLXRpbWUnXS5mcm9tSUNBTChwYXJ0c1swXSk7XG5cbiAgICAgICAgaWYgKCFJQ0FMLkR1cmF0aW9uLmlzVmFsdWVTdHJpbmcocGFydHNbMV0pKSB7XG4gICAgICAgICAgcGFydHNbMV0gPSBpY2FsVmFsdWVzWydkYXRlLXRpbWUnXS5mcm9tSUNBTChwYXJ0c1sxXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFydHM7XG4gICAgICB9LFxuXG4gICAgICB0b0lDQUw6IGZ1bmN0aW9uKHBhcnRzKSB7XG4gICAgICAgIGlmICghZGVzaWduLnN0cmljdCAmJiBwYXJ0c1swXS5sZW5ndGggPT0gMTApIHtcbiAgICAgICAgICBwYXJ0c1swXSA9IGljYWxWYWx1ZXMuZGF0ZS50b0lDQUwocGFydHNbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcnRzWzBdID0gaWNhbFZhbHVlc1snZGF0ZS10aW1lJ10udG9JQ0FMKHBhcnRzWzBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghSUNBTC5EdXJhdGlvbi5pc1ZhbHVlU3RyaW5nKHBhcnRzWzFdKSkge1xuICAgICAgICAgIGlmICghZGVzaWduLnN0cmljdCAmJiBwYXJ0c1sxXS5sZW5ndGggPT0gMTApIHtcbiAgICAgICAgICAgIHBhcnRzWzFdID0gaWNhbFZhbHVlcy5kYXRlLnRvSUNBTChwYXJ0c1sxXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnRzWzFdID0gaWNhbFZhbHVlc1snZGF0ZS10aW1lJ10udG9JQ0FMKHBhcnRzWzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFydHMuam9pbihcIi9cIik7XG4gICAgICB9LFxuXG4gICAgICBkZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlLCBhUHJvcCkge1xuICAgICAgICByZXR1cm4gSUNBTC5QZXJpb2QuZnJvbUpTT04oYVZhbHVlLCBhUHJvcCwgIWRlc2lnbi5zdHJpY3QpO1xuICAgICAgfSxcblxuICAgICAgdW5kZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhVmFsdWUudG9KU09OKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICByZWN1cjoge1xuICAgICAgZnJvbUlDQUw6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICByZXR1cm4gSUNBTC5SZWN1ci5fc3RyaW5nVG9EYXRhKHN0cmluZywgdHJ1ZSk7XG4gICAgICB9LFxuXG4gICAgICB0b0lDQUw6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdmFyIHN0ciA9IFwiXCI7XG4gICAgICAgIGZvciAodmFyIGsgaW4gZGF0YSkge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGspKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHZhbCA9IGRhdGFba107XG4gICAgICAgICAgaWYgKGsgPT0gXCJ1bnRpbFwiKSB7XG4gICAgICAgICAgICBpZiAodmFsLmxlbmd0aCA+IDEwKSB7XG4gICAgICAgICAgICAgIHZhbCA9IGljYWxWYWx1ZXNbJ2RhdGUtdGltZSddLnRvSUNBTCh2YWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFsID0gaWNhbFZhbHVlcy5kYXRlLnRvSUNBTCh2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoayA9PSBcIndrc3RcIikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgIHZhbCA9IElDQUwuUmVjdXIubnVtZXJpY0RheVRvSWNhbERheSh2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgICAgICB2YWwgPSB2YWwuam9pbihcIixcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0ciArPSBrLnRvVXBwZXJDYXNlKCkgKyBcIj1cIiArIHZhbCArIFwiO1wiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHIuc3Vic3RyKDAsIHN0ci5sZW5ndGggLSAxKTtcbiAgICAgIH0sXG5cbiAgICAgIGRlY29yYXRlOiBmdW5jdGlvbiBkZWNvcmF0ZShhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIElDQUwuUmVjdXIuZnJvbURhdGEoYVZhbHVlKTtcbiAgICAgIH0sXG5cbiAgICAgIHVuZGVjb3JhdGU6IGZ1bmN0aW9uKGFSZWN1cikge1xuICAgICAgICByZXR1cm4gYVJlY3VyLnRvSlNPTigpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB0aW1lOiB7XG4gICAgICBmcm9tSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIC8vIGZyb206IE1NSEhTUyhaKT9cbiAgICAgICAgLy8gdG86IEhIOk1NOlNTKFopP1xuICAgICAgICBpZiAoYVZhbHVlLmxlbmd0aCA8IDYpIHtcbiAgICAgICAgICAvLyBUT0RPOiBwYXJzZXIgZXhjZXB0aW9uP1xuICAgICAgICAgIHJldHVybiBhVmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBISDo6TU06OlNTWj9cbiAgICAgICAgdmFyIHJlc3VsdCA9IGFWYWx1ZS5zdWJzdHIoMCwgMikgKyAnOicgK1xuICAgICAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cigyLCAyKSArICc6JyArXG4gICAgICAgICAgICAgICAgICAgICBhVmFsdWUuc3Vic3RyKDQsIDIpO1xuXG4gICAgICAgIGlmIChhVmFsdWVbNl0gPT09ICdaJykge1xuICAgICAgICAgIHJlc3VsdCArPSAnWic7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcblxuICAgICAgdG9JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgLy8gZnJvbTogSEg6TU06U1MoWik/XG4gICAgICAgIC8vIHRvOiBNTUhIU1MoWik/XG4gICAgICAgIGlmIChhVmFsdWUubGVuZ3RoIDwgOCkge1xuICAgICAgICAgIC8vVE9ETzogZXJyb3JcbiAgICAgICAgICByZXR1cm4gYVZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IGFWYWx1ZS5zdWJzdHIoMCwgMikgK1xuICAgICAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cigzLCAyKSArXG4gICAgICAgICAgICAgICAgICAgICBhVmFsdWUuc3Vic3RyKDYsIDIpO1xuXG4gICAgICAgIGlmIChhVmFsdWVbOF0gPT09ICdaJykge1xuICAgICAgICAgIHJlc3VsdCArPSAnWic7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGljYWxQcm9wZXJ0aWVzID0gSUNBTC5oZWxwZXJzLmV4dGVuZChjb21tb25Qcm9wZXJ0aWVzLCB7XG5cbiAgICBcImFjdGlvblwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBcImF0dGFjaFwiOiB7IGRlZmF1bHRUeXBlOiBcInVyaVwiIH0sXG4gICAgXCJhdHRlbmRlZVwiOiB7IGRlZmF1bHRUeXBlOiBcImNhbC1hZGRyZXNzXCIgfSxcbiAgICBcImNhbHNjYWxlXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIFwiY2xhc3NcIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgXCJjb21tZW50XCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIFwiY29tcGxldGVkXCI6IERFRkFVTFRfVFlQRV9EQVRFVElNRSxcbiAgICBcImNvbnRhY3RcIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgXCJjcmVhdGVkXCI6IERFRkFVTFRfVFlQRV9EQVRFVElNRSxcbiAgICBcImRlc2NyaXB0aW9uXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIFwiZHRlbmRcIjogREVGQVVMVF9UWVBFX0RBVEVUSU1FX0RBVEUsXG4gICAgXCJkdHN0YW1wXCI6IERFRkFVTFRfVFlQRV9EQVRFVElNRSxcbiAgICBcImR0c3RhcnRcIjogREVGQVVMVF9UWVBFX0RBVEVUSU1FX0RBVEUsXG4gICAgXCJkdWVcIjogREVGQVVMVF9UWVBFX0RBVEVUSU1FX0RBVEUsXG4gICAgXCJkdXJhdGlvblwiOiB7IGRlZmF1bHRUeXBlOiBcImR1cmF0aW9uXCIgfSxcbiAgICBcImV4ZGF0ZVwiOiB7XG4gICAgICBkZWZhdWx0VHlwZTogXCJkYXRlLXRpbWVcIixcbiAgICAgIGFsbG93ZWRUeXBlczogW1wiZGF0ZS10aW1lXCIsIFwiZGF0ZVwiXSxcbiAgICAgIG11bHRpVmFsdWU6ICcsJ1xuICAgIH0sXG4gICAgXCJleHJ1bGVcIjogREVGQVVMVF9UWVBFX1JFQ1VSLFxuICAgIFwiZnJlZWJ1c3lcIjogeyBkZWZhdWx0VHlwZTogXCJwZXJpb2RcIiwgbXVsdGlWYWx1ZTogXCIsXCIgfSxcbiAgICBcImdlb1wiOiB7IGRlZmF1bHRUeXBlOiBcImZsb2F0XCIsIHN0cnVjdHVyZWRWYWx1ZTogXCI7XCIgfSxcbiAgICBcImxhc3QtbW9kaWZpZWRcIjogREVGQVVMVF9UWVBFX0RBVEVUSU1FLFxuICAgIFwibG9jYXRpb25cIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgXCJtZXRob2RcIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgXCJvcmdhbml6ZXJcIjogeyBkZWZhdWx0VHlwZTogXCJjYWwtYWRkcmVzc1wiIH0sXG4gICAgXCJwZXJjZW50LWNvbXBsZXRlXCI6IERFRkFVTFRfVFlQRV9JTlRFR0VSLFxuICAgIFwicHJpb3JpdHlcIjogREVGQVVMVF9UWVBFX0lOVEVHRVIsXG4gICAgXCJwcm9kaWRcIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgXCJyZWxhdGVkLXRvXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIFwicmVwZWF0XCI6IERFRkFVTFRfVFlQRV9JTlRFR0VSLFxuICAgIFwicmRhdGVcIjoge1xuICAgICAgZGVmYXVsdFR5cGU6IFwiZGF0ZS10aW1lXCIsXG4gICAgICBhbGxvd2VkVHlwZXM6IFtcImRhdGUtdGltZVwiLCBcImRhdGVcIiwgXCJwZXJpb2RcIl0sXG4gICAgICBtdWx0aVZhbHVlOiAnLCcsXG4gICAgICBkZXRlY3RUeXBlOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgaWYgKHN0cmluZy5pbmRleE9mKCcvJykgIT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuICdwZXJpb2QnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoc3RyaW5nLmluZGV4T2YoJ1QnKSA9PT0gLTEpID8gJ2RhdGUnIDogJ2RhdGUtdGltZSc7XG4gICAgICB9XG4gICAgfSxcbiAgICBcInJlY3VycmVuY2UtaWRcIjogREVGQVVMVF9UWVBFX0RBVEVUSU1FX0RBVEUsXG4gICAgXCJyZXNvdXJjZXNcIjogREVGQVVMVF9UWVBFX1RFWFRfTVVMVEksXG4gICAgXCJyZXF1ZXN0LXN0YXR1c1wiOiBERUZBVUxUX1RZUEVfVEVYVF9TVFJVQ1RVUkVELFxuICAgIFwicnJ1bGVcIjogREVGQVVMVF9UWVBFX1JFQ1VSLFxuICAgIFwic2VxdWVuY2VcIjogREVGQVVMVF9UWVBFX0lOVEVHRVIsXG4gICAgXCJzdGF0dXNcIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgXCJzdW1tYXJ5XCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIFwidHJhbnNwXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIFwidHJpZ2dlclwiOiB7IGRlZmF1bHRUeXBlOiBcImR1cmF0aW9uXCIsIGFsbG93ZWRUeXBlczogW1wiZHVyYXRpb25cIiwgXCJkYXRlLXRpbWVcIl0gfSxcbiAgICBcInR6b2Zmc2V0ZnJvbVwiOiBERUZBVUxUX1RZUEVfVVRDT0ZGU0VULFxuICAgIFwidHpvZmZzZXR0b1wiOiBERUZBVUxUX1RZUEVfVVRDT0ZGU0VULFxuICAgIFwidHp1cmxcIjogREVGQVVMVF9UWVBFX1VSSSxcbiAgICBcInR6aWRcIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgXCJ0em5hbWVcIjogREVGQVVMVF9UWVBFX1RFWFRcbiAgfSk7XG5cbiAgLy8gV2hlbiBhZGRpbmcgYSB2YWx1ZSBoZXJlLCBiZSBzdXJlIHRvIGFkZCBpdCB0byB0aGUgcGFyYW1ldGVyIHR5cGVzIVxuICB2YXIgdmNhcmRWYWx1ZXMgPSBJQ0FMLmhlbHBlcnMuZXh0ZW5kKGNvbW1vblZhbHVlcywge1xuICAgIHRleHQ6IGNyZWF0ZVRleHRUeXBlKEZST01fVkNBUkRfTkVXTElORSwgVE9fVkNBUkRfTkVXTElORSksXG4gICAgdXJpOiBjcmVhdGVUZXh0VHlwZShGUk9NX1ZDQVJEX05FV0xJTkUsIFRPX1ZDQVJEX05FV0xJTkUpLFxuXG4gICAgZGF0ZToge1xuICAgICAgZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gSUNBTC5WQ2FyZFRpbWUuZnJvbURhdGVBbmRPclRpbWVTdHJpbmcoYVZhbHVlLCBcImRhdGVcIik7XG4gICAgICB9LFxuICAgICAgdW5kZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhVmFsdWUudG9TdHJpbmcoKTtcbiAgICAgIH0sXG4gICAgICBmcm9tSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIGlmIChhVmFsdWUubGVuZ3RoID09IDgpIHtcbiAgICAgICAgICByZXR1cm4gaWNhbFZhbHVlcy5kYXRlLmZyb21JQ0FMKGFWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYVZhbHVlWzBdID09ICctJyAmJiBhVmFsdWUubGVuZ3RoID09IDYpIHtcbiAgICAgICAgICByZXR1cm4gYVZhbHVlLnN1YnN0cigwLCA0KSArICctJyArIGFWYWx1ZS5zdWJzdHIoNCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGFWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRvSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIGlmIChhVmFsdWUubGVuZ3RoID09IDEwKSB7XG4gICAgICAgICAgcmV0dXJuIGljYWxWYWx1ZXMuZGF0ZS50b0lDQUwoYVZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChhVmFsdWVbMF0gPT0gJy0nICYmIGFWYWx1ZS5sZW5ndGggPT0gNykge1xuICAgICAgICAgIHJldHVybiBhVmFsdWUuc3Vic3RyKDAsIDQpICsgYVZhbHVlLnN1YnN0cig1KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYVZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHRpbWU6IHtcbiAgICAgIGRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIElDQUwuVkNhcmRUaW1lLmZyb21EYXRlQW5kT3JUaW1lU3RyaW5nKFwiVFwiICsgYVZhbHVlLCBcInRpbWVcIik7XG4gICAgICB9LFxuICAgICAgdW5kZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhVmFsdWUudG9TdHJpbmcoKTtcbiAgICAgIH0sXG4gICAgICBmcm9tSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHZhciBzcGxpdHpvbmUgPSB2Y2FyZFZhbHVlcy50aW1lLl9zcGxpdFpvbmUoYVZhbHVlLCB0cnVlKTtcbiAgICAgICAgdmFyIHpvbmUgPSBzcGxpdHpvbmVbMF0sIHZhbHVlID0gc3BsaXR6b25lWzFdO1xuXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJTUExJVDogXCIsc3BsaXR6b25lKTtcblxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09IDYpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cigwLCAyKSArICc6JyArXG4gICAgICAgICAgICAgICAgICB2YWx1ZS5zdWJzdHIoMiwgMikgKyAnOicgK1xuICAgICAgICAgICAgICAgICAgdmFsdWUuc3Vic3RyKDQsIDIpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlLmxlbmd0aCA9PSA0ICYmIHZhbHVlWzBdICE9ICctJykge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyKDAsIDIpICsgJzonICsgdmFsdWUuc3Vic3RyKDIsIDIpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlLmxlbmd0aCA9PSA1KSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHIoMCwgMykgKyAnOicgKyB2YWx1ZS5zdWJzdHIoMywgMik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoem9uZS5sZW5ndGggPT0gNSAmJiAoem9uZVswXSA9PSAnLScgfHwgem9uZVswXSA9PSAnKycpKSB7XG4gICAgICAgICAgem9uZSA9IHpvbmUuc3Vic3RyKDAsIDMpICsgJzonICsgem9uZS5zdWJzdHIoMyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWUgKyB6b25lO1xuICAgICAgfSxcblxuICAgICAgdG9JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgdmFyIHNwbGl0em9uZSA9IHZjYXJkVmFsdWVzLnRpbWUuX3NwbGl0Wm9uZShhVmFsdWUpO1xuICAgICAgICB2YXIgem9uZSA9IHNwbGl0em9uZVswXSwgdmFsdWUgPSBzcGxpdHpvbmVbMV07XG5cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PSA4KSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHIoMCwgMikgK1xuICAgICAgICAgICAgICAgICAgdmFsdWUuc3Vic3RyKDMsIDIpICtcbiAgICAgICAgICAgICAgICAgIHZhbHVlLnN1YnN0cig2LCAyKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZS5sZW5ndGggPT0gNSAmJiB2YWx1ZVswXSAhPSAnLScpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cigwLCAyKSArIHZhbHVlLnN1YnN0cigzLCAyKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZS5sZW5ndGggPT0gNikge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyKDAsIDMpICsgdmFsdWUuc3Vic3RyKDQsIDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHpvbmUubGVuZ3RoID09IDYgJiYgKHpvbmVbMF0gPT0gJy0nIHx8IHpvbmVbMF0gPT0gJysnKSkge1xuICAgICAgICAgIHpvbmUgPSB6b25lLnN1YnN0cigwLCAzKSArIHpvbmUuc3Vic3RyKDQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlICsgem9uZTtcbiAgICAgIH0sXG5cbiAgICAgIF9zcGxpdFpvbmU6IGZ1bmN0aW9uKGFWYWx1ZSwgaXNGcm9tSWNhbCkge1xuICAgICAgICB2YXIgbGFzdENoYXIgPSBhVmFsdWUubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIHNpZ25DaGFyID0gYVZhbHVlLmxlbmd0aCAtIChpc0Zyb21JY2FsID8gNSA6IDYpO1xuICAgICAgICB2YXIgc2lnbiA9IGFWYWx1ZVtzaWduQ2hhcl07XG4gICAgICAgIHZhciB6b25lLCB2YWx1ZTtcblxuICAgICAgICBpZiAoYVZhbHVlW2xhc3RDaGFyXSA9PSAnWicpIHtcbiAgICAgICAgICB6b25lID0gYVZhbHVlW2xhc3RDaGFyXTtcbiAgICAgICAgICB2YWx1ZSA9IGFWYWx1ZS5zdWJzdHIoMCwgbGFzdENoYXIpO1xuICAgICAgICB9IGVsc2UgaWYgKGFWYWx1ZS5sZW5ndGggPiA2ICYmIChzaWduID09ICctJyB8fCBzaWduID09ICcrJykpIHtcbiAgICAgICAgICB6b25lID0gYVZhbHVlLnN1YnN0cihzaWduQ2hhcik7XG4gICAgICAgICAgdmFsdWUgPSBhVmFsdWUuc3Vic3RyKDAsIHNpZ25DaGFyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB6b25lID0gXCJcIjtcbiAgICAgICAgICB2YWx1ZSA9IGFWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbem9uZSwgdmFsdWVdO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImRhdGUtdGltZVwiOiB7XG4gICAgICBkZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBJQ0FMLlZDYXJkVGltZS5mcm9tRGF0ZUFuZE9yVGltZVN0cmluZyhhVmFsdWUsIFwiZGF0ZS10aW1lXCIpO1xuICAgICAgfSxcblxuICAgICAgdW5kZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhVmFsdWUudG9TdHJpbmcoKTtcbiAgICAgIH0sXG5cbiAgICAgIGZyb21JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZjYXJkVmFsdWVzWydkYXRlLWFuZC1vci10aW1lJ10uZnJvbUlDQUwoYVZhbHVlKTtcbiAgICAgIH0sXG5cbiAgICAgIHRvSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2Y2FyZFZhbHVlc1snZGF0ZS1hbmQtb3ItdGltZSddLnRvSUNBTChhVmFsdWUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImRhdGUtYW5kLW9yLXRpbWVcIjoge1xuICAgICAgZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gSUNBTC5WQ2FyZFRpbWUuZnJvbURhdGVBbmRPclRpbWVTdHJpbmcoYVZhbHVlLCBcImRhdGUtYW5kLW9yLXRpbWVcIik7XG4gICAgICB9LFxuXG4gICAgICB1bmRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFWYWx1ZS50b1N0cmluZygpO1xuICAgICAgfSxcblxuICAgICAgZnJvbUlDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICB2YXIgcGFydHMgPSBhVmFsdWUuc3BsaXQoJ1QnKTtcbiAgICAgICAgcmV0dXJuIChwYXJ0c1swXSA/IHZjYXJkVmFsdWVzLmRhdGUuZnJvbUlDQUwocGFydHNbMF0pIDogJycpICtcbiAgICAgICAgICAgICAgIChwYXJ0c1sxXSA/ICdUJyArIHZjYXJkVmFsdWVzLnRpbWUuZnJvbUlDQUwocGFydHNbMV0pIDogJycpO1xuICAgICAgfSxcblxuICAgICAgdG9JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgdmFyIHBhcnRzID0gYVZhbHVlLnNwbGl0KCdUJyk7XG4gICAgICAgIHJldHVybiB2Y2FyZFZhbHVlcy5kYXRlLnRvSUNBTChwYXJ0c1swXSkgK1xuICAgICAgICAgICAgICAgKHBhcnRzWzFdID8gJ1QnICsgdmNhcmRWYWx1ZXMudGltZS50b0lDQUwocGFydHNbMV0pIDogJycpO1xuXG4gICAgICB9XG4gICAgfSxcbiAgICB0aW1lc3RhbXA6IGljYWxWYWx1ZXNbJ2RhdGUtdGltZSddLFxuICAgIFwibGFuZ3VhZ2UtdGFnXCI6IHtcbiAgICAgIG1hdGNoZXM6IC9eW2EtekEtWjAtOS1dKyQvIC8vIENvdWxkIGdvIHdpdGggYSBtb3JlIHN0cmljdCByZWdleCBoZXJlXG4gICAgfVxuICB9KTtcblxuICB2YXIgdmNhcmRQYXJhbXMgPSB7XG4gICAgXCJ0eXBlXCI6IHtcbiAgICAgIHZhbHVlVHlwZTogXCJ0ZXh0XCIsXG4gICAgICBtdWx0aVZhbHVlOiBcIixcIlxuICAgIH0sXG4gICAgXCJ2YWx1ZVwiOiB7XG4gICAgICAvLyBzaW5jZSB0aGUgdmFsdWUgaGVyZSBpcyBhICd0eXBlJyBsb3dlcmNhc2UgaXMgdXNlZC5cbiAgICAgIHZhbHVlczogW1widGV4dFwiLCBcInVyaVwiLCBcImRhdGVcIiwgXCJ0aW1lXCIsIFwiZGF0ZS10aW1lXCIsIFwiZGF0ZS1hbmQtb3ItdGltZVwiLFxuICAgICAgICAgICAgICAgXCJ0aW1lc3RhbXBcIiwgXCJib29sZWFuXCIsIFwiaW50ZWdlclwiLCBcImZsb2F0XCIsIFwidXRjLW9mZnNldFwiLFxuICAgICAgICAgICAgICAgXCJsYW5ndWFnZS10YWdcIl0sXG4gICAgICBhbGxvd1hOYW1lOiB0cnVlLFxuICAgICAgYWxsb3dJYW5hVG9rZW46IHRydWVcbiAgICB9XG4gIH07XG5cbiAgdmFyIHZjYXJkUHJvcGVydGllcyA9IElDQUwuaGVscGVycy5leHRlbmQoY29tbW9uUHJvcGVydGllcywge1xuICAgIFwiYWRyXCI6IHsgZGVmYXVsdFR5cGU6IFwidGV4dFwiLCBzdHJ1Y3R1cmVkVmFsdWU6IFwiO1wiLCBtdWx0aVZhbHVlOiBcIixcIiB9LFxuICAgIFwiYW5uaXZlcnNhcnlcIjogREVGQVVMVF9UWVBFX0RBVEVfQU5ET1JfVElNRSxcbiAgICBcImJkYXlcIjogREVGQVVMVF9UWVBFX0RBVEVfQU5ET1JfVElNRSxcbiAgICBcImNhbGFkcnVyaVwiOiBERUZBVUxUX1RZUEVfVVJJLFxuICAgIFwiY2FsdXJpXCI6IERFRkFVTFRfVFlQRV9VUkksXG4gICAgXCJjbGllbnRwaWRtYXBcIjogREVGQVVMVF9UWVBFX1RFWFRfU1RSVUNUVVJFRCxcbiAgICBcImVtYWlsXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIFwiZmJ1cmxcIjogREVGQVVMVF9UWVBFX1VSSSxcbiAgICBcImZuXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIFwiZ2VuZGVyXCI6IERFRkFVTFRfVFlQRV9URVhUX1NUUlVDVFVSRUQsXG4gICAgXCJnZW9cIjogREVGQVVMVF9UWVBFX1VSSSxcbiAgICBcImltcHBcIjogREVGQVVMVF9UWVBFX1VSSSxcbiAgICBcImtleVwiOiBERUZBVUxUX1RZUEVfVVJJLFxuICAgIFwia2luZFwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBcImxhbmdcIjogeyBkZWZhdWx0VHlwZTogXCJsYW5ndWFnZS10YWdcIiB9LFxuICAgIFwibG9nb1wiOiBERUZBVUxUX1RZUEVfVVJJLFxuICAgIFwibWVtYmVyXCI6IERFRkFVTFRfVFlQRV9VUkksXG4gICAgXCJuXCI6IHsgZGVmYXVsdFR5cGU6IFwidGV4dFwiLCBzdHJ1Y3R1cmVkVmFsdWU6IFwiO1wiLCBtdWx0aVZhbHVlOiBcIixcIiB9LFxuICAgIFwibmlja25hbWVcIjogREVGQVVMVF9UWVBFX1RFWFRfTVVMVEksXG4gICAgXCJub3RlXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIFwib3JnXCI6IHsgZGVmYXVsdFR5cGU6IFwidGV4dFwiLCBzdHJ1Y3R1cmVkVmFsdWU6IFwiO1wiIH0sXG4gICAgXCJwaG90b1wiOiBERUZBVUxUX1RZUEVfVVJJLFxuICAgIFwicmVsYXRlZFwiOiBERUZBVUxUX1RZUEVfVVJJLFxuICAgIFwicmV2XCI6IHsgZGVmYXVsdFR5cGU6IFwidGltZXN0YW1wXCIgfSxcbiAgICBcInJvbGVcIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgXCJzb3VuZFwiOiBERUZBVUxUX1RZUEVfVVJJLFxuICAgIFwic291cmNlXCI6IERFRkFVTFRfVFlQRV9VUkksXG4gICAgXCJ0ZWxcIjogeyBkZWZhdWx0VHlwZTogXCJ1cmlcIiwgYWxsb3dlZFR5cGVzOiBbXCJ1cmlcIiwgXCJ0ZXh0XCJdIH0sXG4gICAgXCJ0aXRsZVwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBcInR6XCI6IHsgZGVmYXVsdFR5cGU6IFwidGV4dFwiLCBhbGxvd2VkVHlwZXM6IFtcInRleHRcIiwgXCJ1dGMtb2Zmc2V0XCIsIFwidXJpXCJdIH0sXG4gICAgXCJ4bWxcIjogREVGQVVMVF9UWVBFX1RFWFRcbiAgfSk7XG5cbiAgdmFyIHZjYXJkM1ZhbHVlcyA9IElDQUwuaGVscGVycy5leHRlbmQoY29tbW9uVmFsdWVzLCB7XG4gICAgYmluYXJ5OiBpY2FsVmFsdWVzLmJpbmFyeSxcbiAgICBkYXRlOiB2Y2FyZFZhbHVlcy5kYXRlLFxuICAgIFwiZGF0ZS10aW1lXCI6IHZjYXJkVmFsdWVzW1wiZGF0ZS10aW1lXCJdLFxuICAgIFwicGhvbmUtbnVtYmVyXCI6IHtcbiAgICAgIC8vIFRPRE9cbiAgICAgIC8qIC4uLiAqL1xuICAgIH0sXG4gICAgdXJpOiBpY2FsVmFsdWVzLnVyaSxcbiAgICB0ZXh0OiBpY2FsVmFsdWVzLnRleHQsXG4gICAgdGltZTogaWNhbFZhbHVlcy50aW1lLFxuICAgIHZjYXJkOiBpY2FsVmFsdWVzLnRleHQsXG4gICAgXCJ1dGMtb2Zmc2V0XCI6IHtcbiAgICAgIHRvSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhVmFsdWUuc3Vic3RyKDAsIDcpO1xuICAgICAgfSxcblxuICAgICAgZnJvbUlDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gYVZhbHVlLnN1YnN0cigwLCA3KTtcbiAgICAgIH0sXG5cbiAgICAgIGRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIElDQUwuVXRjT2Zmc2V0LmZyb21TdHJpbmcoYVZhbHVlKTtcbiAgICAgIH0sXG5cbiAgICAgIHVuZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gYVZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICB2YXIgdmNhcmQzUGFyYW1zID0ge1xuICAgIFwidHlwZVwiOiB7XG4gICAgICB2YWx1ZVR5cGU6IFwidGV4dFwiLFxuICAgICAgbXVsdGlWYWx1ZTogXCIsXCJcbiAgICB9LFxuICAgIFwidmFsdWVcIjoge1xuICAgICAgLy8gc2luY2UgdGhlIHZhbHVlIGhlcmUgaXMgYSAndHlwZScgbG93ZXJjYXNlIGlzIHVzZWQuXG4gICAgICB2YWx1ZXM6IFtcInRleHRcIiwgXCJ1cmlcIiwgXCJkYXRlXCIsIFwiZGF0ZS10aW1lXCIsIFwicGhvbmUtbnVtYmVyXCIsIFwidGltZVwiLFxuICAgICAgICAgICAgICAgXCJib29sZWFuXCIsIFwiaW50ZWdlclwiLCBcImZsb2F0XCIsIFwidXRjLW9mZnNldFwiLCBcInZjYXJkXCIsIFwiYmluYXJ5XCJdLFxuICAgICAgYWxsb3dYTmFtZTogdHJ1ZSxcbiAgICAgIGFsbG93SWFuYVRva2VuOiB0cnVlXG4gICAgfVxuICB9O1xuXG4gIHZhciB2Y2FyZDNQcm9wZXJ0aWVzID0gSUNBTC5oZWxwZXJzLmV4dGVuZChjb21tb25Qcm9wZXJ0aWVzLCB7XG4gICAgZm46IERFRkFVTFRfVFlQRV9URVhULFxuICAgIG46IHsgZGVmYXVsdFR5cGU6IFwidGV4dFwiLCBzdHJ1Y3R1cmVkVmFsdWU6IFwiO1wiLCBtdWx0aVZhbHVlOiBcIixcIiB9LFxuICAgIG5pY2tuYW1lOiBERUZBVUxUX1RZUEVfVEVYVF9NVUxUSSxcbiAgICBwaG90bzogeyBkZWZhdWx0VHlwZTogXCJiaW5hcnlcIiwgYWxsb3dlZFR5cGVzOiBbXCJiaW5hcnlcIiwgXCJ1cmlcIl0gfSxcbiAgICBiZGF5OiB7XG4gICAgICBkZWZhdWx0VHlwZTogXCJkYXRlLXRpbWVcIixcbiAgICAgIGFsbG93ZWRUeXBlczogW1wiZGF0ZS10aW1lXCIsIFwiZGF0ZVwiXSxcbiAgICAgIGRldGVjdFR5cGU6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICByZXR1cm4gKHN0cmluZy5pbmRleE9mKCdUJykgPT09IC0xKSA/ICdkYXRlJyA6ICdkYXRlLXRpbWUnO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBhZHI6IHsgZGVmYXVsdFR5cGU6IFwidGV4dFwiLCBzdHJ1Y3R1cmVkVmFsdWU6IFwiO1wiLCBtdWx0aVZhbHVlOiBcIixcIiB9LFxuICAgIGxhYmVsOiBERUZBVUxUX1RZUEVfVEVYVCxcblxuICAgIHRlbDogeyBkZWZhdWx0VHlwZTogXCJwaG9uZS1udW1iZXJcIiB9LFxuICAgIGVtYWlsOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBtYWlsZXI6IERFRkFVTFRfVFlQRV9URVhULFxuXG4gICAgdHo6IHsgZGVmYXVsdFR5cGU6IFwidXRjLW9mZnNldFwiLCBhbGxvd2VkVHlwZXM6IFtcInV0Yy1vZmZzZXRcIiwgXCJ0ZXh0XCJdIH0sXG4gICAgZ2VvOiB7IGRlZmF1bHRUeXBlOiBcImZsb2F0XCIsIHN0cnVjdHVyZWRWYWx1ZTogXCI7XCIgfSxcblxuICAgIHRpdGxlOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICByb2xlOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBsb2dvOiB7IGRlZmF1bHRUeXBlOiBcImJpbmFyeVwiLCBhbGxvd2VkVHlwZXM6IFtcImJpbmFyeVwiLCBcInVyaVwiXSB9LFxuICAgIGFnZW50OiB7IGRlZmF1bHRUeXBlOiBcInZjYXJkXCIsIGFsbG93ZWRUeXBlczogW1widmNhcmRcIiwgXCJ0ZXh0XCIsIFwidXJpXCJdIH0sXG4gICAgb3JnOiBERUZBVUxUX1RZUEVfVEVYVF9TVFJVQ1RVUkVELFxuXG4gICAgbm90ZTogREVGQVVMVF9UWVBFX1RFWFRfTVVMVEksXG4gICAgcHJvZGlkOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICByZXY6IHtcbiAgICAgIGRlZmF1bHRUeXBlOiBcImRhdGUtdGltZVwiLFxuICAgICAgYWxsb3dlZFR5cGVzOiBbXCJkYXRlLXRpbWVcIiwgXCJkYXRlXCJdLFxuICAgICAgZGV0ZWN0VHlwZTogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiAoc3RyaW5nLmluZGV4T2YoJ1QnKSA9PT0gLTEpID8gJ2RhdGUnIDogJ2RhdGUtdGltZSc7XG4gICAgICB9XG4gICAgfSxcbiAgICBcInNvcnQtc3RyaW5nXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIHNvdW5kOiB7IGRlZmF1bHRUeXBlOiBcImJpbmFyeVwiLCBhbGxvd2VkVHlwZXM6IFtcImJpbmFyeVwiLCBcInVyaVwiXSB9LFxuXG4gICAgY2xhc3M6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIGtleTogeyBkZWZhdWx0VHlwZTogXCJiaW5hcnlcIiwgYWxsb3dlZFR5cGVzOiBbXCJiaW5hcnlcIiwgXCJ0ZXh0XCJdIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIGlDYWxlbmRhciBkZXNpZ24gc2V0XG4gICAqIEB0eXBlIHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9XG4gICAqL1xuICB2YXIgaWNhbFNldCA9IHtcbiAgICB2YWx1ZTogaWNhbFZhbHVlcyxcbiAgICBwYXJhbTogaWNhbFBhcmFtcyxcbiAgICBwcm9wZXJ0eTogaWNhbFByb3BlcnRpZXNcbiAgfTtcblxuICAvKipcbiAgICogdkNhcmQgNC4wIGRlc2lnbiBzZXRcbiAgICogQHR5cGUge0lDQUwuZGVzaWduLmRlc2lnblNldH1cbiAgICovXG4gIHZhciB2Y2FyZFNldCA9IHtcbiAgICB2YWx1ZTogdmNhcmRWYWx1ZXMsXG4gICAgcGFyYW06IHZjYXJkUGFyYW1zLFxuICAgIHByb3BlcnR5OiB2Y2FyZFByb3BlcnRpZXNcbiAgfTtcblxuICAvKipcbiAgICogdkNhcmQgMy4wIGRlc2lnbiBzZXRcbiAgICogQHR5cGUge0lDQUwuZGVzaWduLmRlc2lnblNldH1cbiAgICovXG4gIHZhciB2Y2FyZDNTZXQgPSB7XG4gICAgdmFsdWU6IHZjYXJkM1ZhbHVlcyxcbiAgICBwYXJhbTogdmNhcmQzUGFyYW1zLFxuICAgIHByb3BlcnR5OiB2Y2FyZDNQcm9wZXJ0aWVzXG4gIH07XG5cbiAgLyoqXG4gICAqIFRoZSBkZXNpZ24gZGF0YSwgdXNlZCBieSB0aGUgcGFyc2VyIHRvIGRldGVybWluZSB0eXBlcyBmb3IgcHJvcGVydGllcyBhbmRcbiAgICogb3RoZXIgbWV0YWRhdGEgbmVlZGVkIHRvIHByb2R1Y2UgY29ycmVjdCBqQ2FyZC9qQ2FsIGRhdGEuXG4gICAqXG4gICAqIEBhbGlhcyBJQ0FMLmRlc2lnblxuICAgKiBAbmFtZXNwYWNlXG4gICAqL1xuICB2YXIgZGVzaWduID0ge1xuICAgIC8qKlxuICAgICAqIEEgZGVzaWduU2V0IGRlc2NyaWJlcyB2YWx1ZSwgcGFyYW1ldGVyIGFuZCBwcm9wZXJ0eSBkYXRhLiBJdCBpcyB1c2VkIGJ5XG4gICAgICogdGhlciBwYXJzZXIgYW5kIHN0cmluZ2lmaWVyIGluIGNvbXBvbmVudHMgYW5kIHByb3BlcnRpZXMgdG8gZGV0ZXJtaW5lIHRoZXlcbiAgICAgKiBzaG91bGQgYmUgcmVwcmVzZW50ZWQuXG4gICAgICpcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBkZXNpZ25TZXRcbiAgICAgKiBAbWVtYmVyT2YgSUNBTC5kZXNpZ25cbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gdmFsdWUgICAgICAgRGVmaW5pdGlvbnMgZm9yIHZhbHVlIHR5cGVzLCBrZXlzIGFyZSB0eXBlIG5hbWVzXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IHBhcmFtICAgICAgIERlZmluaXRpb25zIGZvciBwYXJhbXMsIGtleXMgYXJlIHBhcmFtIG5hbWVzXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IHByb3BlcnR5ICAgIERlZmludGlvbnMgZm9yIHByb3BlcnRpZXMsIGtleXMgYXJlIHByb3BlcnR5IG5hbWVzXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBDYW4gYmUgc2V0IHRvIGZhbHNlIHRvIG1ha2UgdGhlIHBhcnNlciBtb3JlIGxlbmllbnQuXG4gICAgICovXG4gICAgc3RyaWN0OiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgc2V0IGZvciBuZXcgcHJvcGVydGllcyBhbmQgY29tcG9uZW50cyBpZiBub25lIGlzIHNwZWNpZmllZC5cbiAgICAgKiBAdHlwZSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fVxuICAgICAqL1xuICAgIGRlZmF1bHRTZXQ6IGljYWxTZXQsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCB0eXBlIGZvciB1bmtub3duIHByb3BlcnRpZXNcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIGRlZmF1bHRUeXBlOiAndW5rbm93bicsXG5cbiAgICAvKipcbiAgICAgKiBIb2xkcyB0aGUgZGVzaWduIHNldCBmb3Iga25vd24gdG9wLWxldmVsIGNvbXBvbmVudHNcbiAgICAgKlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9IHZjYXJkICAgICAgIHZDYXJkIFZDQVJEXG4gICAgICogQHByb3BlcnR5IHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9IHZldmVudCAgICAgIGlDYWxlbmRhciBWRVZFTlRcbiAgICAgKiBAcHJvcGVydHkge0lDQUwuZGVzaWduLmRlc2lnblNldH0gdnRvZG8gICAgICAgaUNhbGVuZGFyIFZUT0RPXG4gICAgICogQHByb3BlcnR5IHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9IHZqb3VybmFsICAgIGlDYWxlbmRhciBWSk9VUk5BTFxuICAgICAqIEBwcm9wZXJ0eSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fSB2YWxhcm0gICAgICBpQ2FsZW5kYXIgVkFMQVJNXG4gICAgICogQHByb3BlcnR5IHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9IHZ0aW1lem9uZSAgIGlDYWxlbmRhciBWVElNRVpPTkVcbiAgICAgKiBAcHJvcGVydHkge0lDQUwuZGVzaWduLmRlc2lnblNldH0gZGF5bGlnaHQgICAgaUNhbGVuZGFyIERBWUxJR0hUXG4gICAgICogQHByb3BlcnR5IHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9IHN0YW5kYXJkICAgIGlDYWxlbmRhciBTVEFOREFSRFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgcHJvcGVydHlOYW1lID0gJ2ZuJztcbiAgICAgKiB2YXIgY29tcG9uZW50RGVzaWduID0gSUNBTC5kZXNpZ24uY29tcG9uZW50cy52Y2FyZDtcbiAgICAgKiB2YXIgcHJvcGVydHlEZXRhaWxzID0gY29tcG9uZW50RGVzaWduLnByb3BlcnR5W3Byb3BlcnR5TmFtZV07XG4gICAgICogaWYgKHByb3BlcnR5RGV0YWlscy5kZWZhdWx0VHlwZSA9PSAndGV4dCcpIHtcbiAgICAgKiAgIC8vIFllcCwgc3VyZSBpcy4uLlxuICAgICAqIH1cbiAgICAgKi9cbiAgICBjb21wb25lbnRzOiB7XG4gICAgICB2Y2FyZDogdmNhcmRTZXQsXG4gICAgICB2Y2FyZDM6IHZjYXJkM1NldCxcbiAgICAgIHZldmVudDogaWNhbFNldCxcbiAgICAgIHZ0b2RvOiBpY2FsU2V0LFxuICAgICAgdmpvdXJuYWw6IGljYWxTZXQsXG4gICAgICB2YWxhcm06IGljYWxTZXQsXG4gICAgICB2dGltZXpvbmU6IGljYWxTZXQsXG4gICAgICBkYXlsaWdodDogaWNhbFNldCxcbiAgICAgIHN0YW5kYXJkOiBpY2FsU2V0XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogVGhlIGRlc2lnbiBzZXQgZm9yIGlDYWxlbmRhciAocmZjNTU0NS9yZmM3MjY1KSBjb21wb25lbnRzLlxuICAgICAqIEB0eXBlIHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9XG4gICAgICovXG4gICAgaWNhbGVuZGFyOiBpY2FsU2V0LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGRlc2lnbiBzZXQgZm9yIHZDYXJkIChyZmM2MzUwL3JmYzcwOTUpIGNvbXBvbmVudHMuXG4gICAgICogQHR5cGUge0lDQUwuZGVzaWduLmRlc2lnblNldH1cbiAgICAgKi9cbiAgICB2Y2FyZDogdmNhcmRTZXQsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVzaWduIHNldCBmb3IgdkNhcmQgKHJmYzI0MjUvcmZjMjQyNi9yZmM3MDk1KSBjb21wb25lbnRzLlxuICAgICAqIEB0eXBlIHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9XG4gICAgICovXG4gICAgdmNhcmQzOiB2Y2FyZDNTZXQsXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBkZXNpZ24gc2V0IGZvciB0aGUgZ2l2ZW4gY29tcG9uZW50IG5hbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29tcG9uZW50TmFtZSAgICAgICAgVGhlIG5hbWUgb2YgdGhlIGNvbXBvbmVudFxuICAgICAqIEByZXR1cm4ge0lDQUwuZGVzaWduLmRlc2lnblNldH0gICAgICBUaGUgZGVzaWduIHNldCBmb3IgdGhlIGNvbXBvbmVudFxuICAgICAqL1xuICAgIGdldERlc2lnblNldDogZnVuY3Rpb24oY29tcG9uZW50TmFtZSkge1xuICAgICAgdmFyIGlzSW5EZXNpZ24gPSBjb21wb25lbnROYW1lICYmIGNvbXBvbmVudE5hbWUgaW4gZGVzaWduLmNvbXBvbmVudHM7XG4gICAgICByZXR1cm4gaXNJbkRlc2lnbiA/IGRlc2lnbi5jb21wb25lbnRzW2NvbXBvbmVudE5hbWVdIDogZGVzaWduLmRlZmF1bHRTZXQ7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBkZXNpZ247XG59KCkpO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoLCAyMDExLTIwMTUgKi9cblxuXG4vKipcbiAqIENvbnRhaW5zIHZhcmlvdXMgZnVuY3Rpb25zIHRvIGNvbnZlcnQgakNhbCBhbmQgakNhcmQgZGF0YSBiYWNrIGludG9cbiAqIGlDYWxlbmRhciBhbmQgdkNhcmQuXG4gKiBAbmFtZXNwYWNlXG4gKi9cbklDQUwuc3RyaW5naWZ5ID0gKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIExJTkVfRU5ESU5HID0gJ1xcclxcbic7XG4gIHZhciBERUZBVUxUX1ZBTFVFX1RZUEUgPSAndW5rbm93bic7XG5cbiAgdmFyIGRlc2lnbiA9IElDQUwuZGVzaWduO1xuICB2YXIgaGVscGVycyA9IElDQUwuaGVscGVycztcblxuICAvKipcbiAgICogQ29udmVydCBhIGZ1bGwgakNhbC9qQ2FyZCBhcnJheSBpbnRvIGEgaUNhbGVuZGFyL3ZDYXJkIHN0cmluZy5cbiAgICpcbiAgICogQGZ1bmN0aW9uIElDQUwuc3RyaW5naWZ5XG4gICAqIEB2YXJpYXRpb24gZnVuY3Rpb25cbiAgICogQHBhcmFtIHtBcnJheX0gakNhbCAgICBUaGUgakNhbC9qQ2FyZCBkb2N1bWVudFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgIFRoZSBzdHJpbmdpZmllZCBpQ2FsZW5kYXIvdkNhcmQgZG9jdW1lbnRcbiAgICovXG4gIGZ1bmN0aW9uIHN0cmluZ2lmeShqQ2FsKSB7XG4gICAgaWYgKHR5cGVvZiBqQ2FsWzBdID09IFwic3RyaW5nXCIpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBzaW5nbGUgY29tcG9uZW50XG4gICAgICBqQ2FsID0gW2pDYWxdO1xuICAgIH1cblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gakNhbC5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgcmVzdWx0ICs9IHN0cmluZ2lmeS5jb21wb25lbnQoakNhbFtpXSkgKyBMSU5FX0VORElORztcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGFuIGpDYWwgY29tcG9uZW50IGFycmF5IGludG8gYSBJQ0FMIHN0cmluZy5cbiAgICogUmVjdXJzaXZlIHdpbGwgcmVzb2x2ZSBzdWItY29tcG9uZW50cy5cbiAgICpcbiAgICogRXhhY3QgY29tcG9uZW50L3Byb3BlcnR5IG9yZGVyIGlzIG5vdCBzYXZlZCBhbGxcbiAgICogcHJvcGVydGllcyB3aWxsIGNvbWUgYmVmb3JlIHN1YmNvbXBvbmVudHMuXG4gICAqXG4gICAqIEBmdW5jdGlvbiBJQ0FMLnN0cmluZ2lmeS5jb21wb25lbnRcbiAgICogQHBhcmFtIHtBcnJheX0gY29tcG9uZW50XG4gICAqICAgICAgICBqQ2FsL2pDYXJkIGZyYWdtZW50IG9mIGEgY29tcG9uZW50XG4gICAqIEBwYXJhbSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fSBkZXNpZ25TZXRcbiAgICogICAgICAgIFRoZSBkZXNpZ24gZGF0YSB0byB1c2UgZm9yIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgVGhlIGlDYWxlbmRhci92Q2FyZCBzdHJpbmdcbiAgICovXG4gIHN0cmluZ2lmeS5jb21wb25lbnQgPSBmdW5jdGlvbihjb21wb25lbnQsIGRlc2lnblNldCkge1xuICAgIHZhciBuYW1lID0gY29tcG9uZW50WzBdLnRvVXBwZXJDYXNlKCk7XG4gICAgdmFyIHJlc3VsdCA9ICdCRUdJTjonICsgbmFtZSArIExJTkVfRU5ESU5HO1xuXG4gICAgdmFyIHByb3BzID0gY29tcG9uZW50WzFdO1xuICAgIHZhciBwcm9wSWR4ID0gMDtcbiAgICB2YXIgcHJvcExlbiA9IHByb3BzLmxlbmd0aDtcblxuICAgIHZhciBkZXNpZ25TZXROYW1lID0gY29tcG9uZW50WzBdO1xuICAgIC8vIHJmYzYzNTAgcmVxdWlyZXMgdGhhdCBpbiB2Q2FyZCA0LjAgdGhlIGZpcnN0IGNvbXBvbmVudCBpcyB0aGUgVkVSU0lPTlxuICAgIC8vIGNvbXBvbmVudCB3aXRoIGFzIHZhbHVlIDQuMCwgbm90ZSB0aGF0IDMuMCBkb2VzIG5vdCBoYXZlIHRoaXMgcmVxdWlyZW1lbnQuXG4gICAgaWYgKGRlc2lnblNldE5hbWUgPT09ICd2Y2FyZCcgJiYgY29tcG9uZW50WzFdLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICEoY29tcG9uZW50WzFdWzBdWzBdID09PSBcInZlcnNpb25cIiAmJiBjb21wb25lbnRbMV1bMF1bM10gPT09IFwiNC4wXCIpKSB7XG4gICAgICBkZXNpZ25TZXROYW1lID0gXCJ2Y2FyZDNcIjtcbiAgICB9XG4gICAgZGVzaWduU2V0ID0gZGVzaWduU2V0IHx8IGRlc2lnbi5nZXREZXNpZ25TZXQoZGVzaWduU2V0TmFtZSk7XG5cbiAgICBmb3IgKDsgcHJvcElkeCA8IHByb3BMZW47IHByb3BJZHgrKykge1xuICAgICAgcmVzdWx0ICs9IHN0cmluZ2lmeS5wcm9wZXJ0eShwcm9wc1twcm9wSWR4XSwgZGVzaWduU2V0KSArIExJTkVfRU5ESU5HO1xuICAgIH1cblxuICAgIC8vIElnbm9yZSBzdWJjb21wb25lbnRzIGlmIG5vbmUgZXhpc3QsIGUuZy4gaW4gdkNhcmQuXG4gICAgdmFyIGNvbXBzID0gY29tcG9uZW50WzJdIHx8IFtdO1xuICAgIHZhciBjb21wSWR4ID0gMDtcbiAgICB2YXIgY29tcExlbiA9IGNvbXBzLmxlbmd0aDtcblxuICAgIGZvciAoOyBjb21wSWR4IDwgY29tcExlbjsgY29tcElkeCsrKSB7XG4gICAgICByZXN1bHQgKz0gc3RyaW5naWZ5LmNvbXBvbmVudChjb21wc1tjb21wSWR4XSwgZGVzaWduU2V0KSArIExJTkVfRU5ESU5HO1xuICAgIH1cblxuICAgIHJlc3VsdCArPSAnRU5EOicgKyBuYW1lO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgc2luZ2xlIGpDYWwvakNhcmQgcHJvcGVydHkgdG8gYSBpQ2FsZW5kYXIvdkNhcmQgc3RyaW5nLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gSUNBTC5zdHJpbmdpZnkucHJvcGVydHlcbiAgICogQHBhcmFtIHtBcnJheX0gcHJvcGVydHlcbiAgICogICAgICAgIGpDYWwvakNhcmQgcHJvcGVydHkgYXJyYXlcbiAgICogQHBhcmFtIHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9IGRlc2lnblNldFxuICAgKiAgICAgICAgVGhlIGRlc2lnbiBkYXRhIHRvIHVzZSBmb3IgdGhpcyBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG5vRm9sZFxuICAgKiAgICAgICAgSWYgdHJ1ZSwgdGhlIGxpbmUgaXMgbm90IGZvbGRlZFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgIFRoZSBpQ2FsZW5kYXIvdkNhcmQgc3RyaW5nXG4gICAqL1xuICBzdHJpbmdpZnkucHJvcGVydHkgPSBmdW5jdGlvbihwcm9wZXJ0eSwgZGVzaWduU2V0LCBub0ZvbGQpIHtcbiAgICB2YXIgbmFtZSA9IHByb3BlcnR5WzBdLnRvVXBwZXJDYXNlKCk7XG4gICAgdmFyIGpzTmFtZSA9IHByb3BlcnR5WzBdO1xuICAgIHZhciBwYXJhbXMgPSBwcm9wZXJ0eVsxXTtcblxuICAgIHZhciBsaW5lID0gbmFtZTtcblxuICAgIHZhciBwYXJhbU5hbWU7XG4gICAgZm9yIChwYXJhbU5hbWUgaW4gcGFyYW1zKSB7XG4gICAgICB2YXIgdmFsdWUgPSBwYXJhbXNbcGFyYW1OYW1lXTtcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChwYXJhbXMuaGFzT3duUHJvcGVydHkocGFyYW1OYW1lKSkge1xuICAgICAgICB2YXIgbXVsdGlWYWx1ZSA9IChwYXJhbU5hbWUgaW4gZGVzaWduU2V0LnBhcmFtKSAmJiBkZXNpZ25TZXQucGFyYW1bcGFyYW1OYW1lXS5tdWx0aVZhbHVlO1xuICAgICAgICBpZiAobXVsdGlWYWx1ZSAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIGlmIChkZXNpZ25TZXQucGFyYW1bcGFyYW1OYW1lXS5tdWx0aVZhbHVlU2VwYXJhdGVEUXVvdGUpIHtcbiAgICAgICAgICAgIG11bHRpVmFsdWUgPSAnXCInICsgbXVsdGlWYWx1ZSArICdcIic7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbHVlID0gdmFsdWUubWFwKHN0cmluZ2lmeS5fcmZjNjg2OFVuZXNjYXBlKTtcbiAgICAgICAgICB2YWx1ZSA9IHN0cmluZ2lmeS5tdWx0aVZhbHVlKHZhbHVlLCBtdWx0aVZhbHVlLCBcInVua25vd25cIiwgbnVsbCwgZGVzaWduU2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IHN0cmluZ2lmeS5fcmZjNjg2OFVuZXNjYXBlKHZhbHVlKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgbGluZSArPSAnOycgKyBwYXJhbU5hbWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgbGluZSArPSAnPScgKyBzdHJpbmdpZnkucHJvcGVydHlWYWx1ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByb3BlcnR5Lmxlbmd0aCA9PT0gMykge1xuICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIHZhbHVlcywgd2UgbXVzdCBhc3N1bWUgYSBibGFuayB2YWx1ZVxuICAgICAgcmV0dXJuIGxpbmUgKyAnOic7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlVHlwZSA9IHByb3BlcnR5WzJdO1xuXG4gICAgaWYgKCFkZXNpZ25TZXQpIHtcbiAgICAgIGRlc2lnblNldCA9IGRlc2lnbi5kZWZhdWx0U2V0O1xuICAgIH1cblxuICAgIHZhciBwcm9wRGV0YWlscztcbiAgICB2YXIgbXVsdGlWYWx1ZSA9IGZhbHNlO1xuICAgIHZhciBzdHJ1Y3R1cmVkVmFsdWUgPSBmYWxzZTtcbiAgICB2YXIgaXNEZWZhdWx0ID0gZmFsc2U7XG5cbiAgICBpZiAoanNOYW1lIGluIGRlc2lnblNldC5wcm9wZXJ0eSkge1xuICAgICAgcHJvcERldGFpbHMgPSBkZXNpZ25TZXQucHJvcGVydHlbanNOYW1lXTtcblxuICAgICAgaWYgKCdtdWx0aVZhbHVlJyBpbiBwcm9wRGV0YWlscykge1xuICAgICAgICBtdWx0aVZhbHVlID0gcHJvcERldGFpbHMubXVsdGlWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCgnc3RydWN0dXJlZFZhbHVlJyBpbiBwcm9wRGV0YWlscykgJiYgQXJyYXkuaXNBcnJheShwcm9wZXJ0eVszXSkpIHtcbiAgICAgICAgc3RydWN0dXJlZFZhbHVlID0gcHJvcERldGFpbHMuc3RydWN0dXJlZFZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoJ2RlZmF1bHRUeXBlJyBpbiBwcm9wRGV0YWlscykge1xuICAgICAgICBpZiAodmFsdWVUeXBlID09PSBwcm9wRGV0YWlscy5kZWZhdWx0VHlwZSkge1xuICAgICAgICAgIGlzRGVmYXVsdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh2YWx1ZVR5cGUgPT09IERFRkFVTFRfVkFMVUVfVFlQRSkge1xuICAgICAgICAgIGlzRGVmYXVsdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHZhbHVlVHlwZSA9PT0gREVGQVVMVF9WQUxVRV9UWVBFKSB7XG4gICAgICAgIGlzRGVmYXVsdCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcHVzaCB0aGUgVkFMVUUgcHJvcGVydHkgaWYgdHlwZSBpcyBub3QgdGhlIGRlZmF1bHRcbiAgICAvLyBmb3IgdGhlIGN1cnJlbnQgcHJvcGVydHkuXG4gICAgaWYgKCFpc0RlZmF1bHQpIHtcbiAgICAgIC8vIHZhbHVlIHdpbGwgbmV2ZXIgY29udGFpbiA7LzovLCBzbyB3ZSBkb24ndCBlc2NhcGUgaXQgaGVyZS5cbiAgICAgIGxpbmUgKz0gJztWQUxVRT0nICsgdmFsdWVUeXBlLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgbGluZSArPSAnOic7XG5cbiAgICBpZiAobXVsdGlWYWx1ZSAmJiBzdHJ1Y3R1cmVkVmFsdWUpIHtcbiAgICAgIGxpbmUgKz0gc3RyaW5naWZ5Lm11bHRpVmFsdWUoXG4gICAgICAgIHByb3BlcnR5WzNdLCBzdHJ1Y3R1cmVkVmFsdWUsIHZhbHVlVHlwZSwgbXVsdGlWYWx1ZSwgZGVzaWduU2V0LCBzdHJ1Y3R1cmVkVmFsdWVcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChtdWx0aVZhbHVlKSB7XG4gICAgICBsaW5lICs9IHN0cmluZ2lmeS5tdWx0aVZhbHVlKFxuICAgICAgICBwcm9wZXJ0eS5zbGljZSgzKSwgbXVsdGlWYWx1ZSwgdmFsdWVUeXBlLCBudWxsLCBkZXNpZ25TZXQsIGZhbHNlXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoc3RydWN0dXJlZFZhbHVlKSB7XG4gICAgICBsaW5lICs9IHN0cmluZ2lmeS5tdWx0aVZhbHVlKFxuICAgICAgICBwcm9wZXJ0eVszXSwgc3RydWN0dXJlZFZhbHVlLCB2YWx1ZVR5cGUsIG51bGwsIGRlc2lnblNldCwgc3RydWN0dXJlZFZhbHVlXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lICs9IHN0cmluZ2lmeS52YWx1ZShwcm9wZXJ0eVszXSwgdmFsdWVUeXBlLCBkZXNpZ25TZXQsIGZhbHNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9Gb2xkID8gbGluZSA6IElDQUwuaGVscGVycy5mb2xkbGluZShsaW5lKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlcyBlc2NhcGluZyBvZiBwcm9wZXJ0eSB2YWx1ZXMgdGhhdCBtYXkgY29udGFpbjpcbiAgICpcbiAgICogICAgQ09MT04gKDopLCBTRU1JQ09MT04gKDspLCBvciBDT01NQSAoLClcbiAgICpcbiAgICogSWYgYW55IG9mIHRoZSBhYm92ZSBhcmUgcHJlc2VudCB0aGUgcmVzdWx0IGlzIHdyYXBwZWRcbiAgICogaW4gZG91YmxlIHF1b3Rlcy5cbiAgICpcbiAgICogQGZ1bmN0aW9uIElDQUwuc3RyaW5naWZ5LnByb3BlcnR5VmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlICAgICAgUmF3IHByb3BlcnR5IHZhbHVlXG4gICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgIEdpdmVuIG9yIGVzY2FwZWQgdmFsdWUgd2hlbiBuZWVkZWRcbiAgICovXG4gIHN0cmluZ2lmeS5wcm9wZXJ0eVZhbHVlID0gZnVuY3Rpb24odmFsdWUpIHtcblxuICAgIGlmICgoaGVscGVycy51bmVzY2FwZWRJbmRleE9mKHZhbHVlLCAnLCcpID09PSAtMSkgJiZcbiAgICAgICAgKGhlbHBlcnMudW5lc2NhcGVkSW5kZXhPZih2YWx1ZSwgJzonKSA9PT0gLTEpICYmXG4gICAgICAgIChoZWxwZXJzLnVuZXNjYXBlZEluZGV4T2YodmFsdWUsICc7JykgPT09IC0xKSkge1xuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuICdcIicgKyB2YWx1ZSArICdcIic7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGFuIGFycmF5IG9mIGljYWwgdmFsdWVzIGludG8gYSBzaW5nbGVcbiAgICogc3RyaW5nIGJhc2VkIG9uIGEgdHlwZSBhbmQgYSBkZWxpbWl0ZXIgdmFsdWUgKGxpa2UgXCIsXCIpLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gSUNBTC5zdHJpbmdpZnkubXVsdGlWYWx1ZVxuICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgICAgICBMaXN0IG9mIHZhbHVlcyB0byBjb252ZXJ0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkZWxpbSAgICAgIFVzZWQgdG8gam9pbiB0aGUgdmFsdWVzIChcIixcIiwgXCI7XCIsIFwiOlwiKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAgICAgICBMb3dlY2FzZSBpY2FsIHZhbHVlIHR5cGVcbiAgICogICAgICAgIChsaWtlIGJvb2xlYW4sIGRhdGUtdGltZSwgZXRjLi4pXG4gICAqIEBwYXJhbSB7P1N0cmluZ30gaW5uZXJNdWx0aSBJZiBzZXQsIGVhY2ggdmFsdWUgd2lsbCBhZ2FpbiBiZSBwcm9jZXNzZWRcbiAgICogICAgICAgIFVzZWQgZm9yIHN0cnVjdHVyZWQgdmFsdWVzXG4gICAqIEBwYXJhbSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fSBkZXNpZ25TZXRcbiAgICogICAgICAgIFRoZSBkZXNpZ24gZGF0YSB0byB1c2UgZm9yIHRoaXMgcHJvcGVydHlcbiAgICpcbiAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICAgaUNhbGVuZGFyL3ZDYXJkIHN0cmluZyBmb3IgdmFsdWVcbiAgICovXG4gIHN0cmluZ2lmeS5tdWx0aVZhbHVlID0gZnVuY3Rpb24odmFsdWVzLCBkZWxpbSwgdHlwZSwgaW5uZXJNdWx0aSwgZGVzaWduU2V0LCBzdHJ1Y3R1cmVkVmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGxlbiA9IHZhbHVlcy5sZW5ndGg7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGlubmVyTXVsdGkgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZXNbaV0pKSB7XG4gICAgICAgIHJlc3VsdCArPSBzdHJpbmdpZnkubXVsdGlWYWx1ZSh2YWx1ZXNbaV0sIGlubmVyTXVsdGksIHR5cGUsIG51bGwsIGRlc2lnblNldCwgc3RydWN0dXJlZFZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCArPSBzdHJpbmdpZnkudmFsdWUodmFsdWVzW2ldLCB0eXBlLCBkZXNpZ25TZXQsIHN0cnVjdHVyZWRWYWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpICE9PSAobGVuIC0gMSkpIHtcbiAgICAgICAgcmVzdWx0ICs9IGRlbGltO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb2Nlc3NlcyBhIHNpbmdsZSBpY2FsIHZhbHVlIHJ1bnMgdGhlIGFzc29jaWF0ZWQgXCJ0b0lDQUxcIiBtZXRob2QgZnJvbSB0aGVcbiAgICogZGVzaWduIHZhbHVlIHR5cGUgaWYgYXZhaWxhYmxlIHRvIGNvbnZlcnQgdGhlIHZhbHVlLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gSUNBTC5zdHJpbmdpZnkudmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWx1ZSAgICAgICBBIGZvcm1hdHRlZCB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAgICAgICAgICAgICAgIExvd2VyY2FzZSBpQ2FsZW5kYXIvdkNhcmQgdmFsdWUgdHlwZVxuICAgKiAgKGxpa2UgYm9vbGVhbiwgZGF0ZS10aW1lLCBldGMuLilcbiAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICAgICAgICAgICBpQ2FsZW5kYXIvdkNhcmQgdmFsdWUgZm9yIHNpbmdsZSB2YWx1ZVxuICAgKi9cbiAgc3RyaW5naWZ5LnZhbHVlID0gZnVuY3Rpb24odmFsdWUsIHR5cGUsIGRlc2lnblNldCwgc3RydWN0dXJlZFZhbHVlKSB7XG4gICAgaWYgKHR5cGUgaW4gZGVzaWduU2V0LnZhbHVlICYmICd0b0lDQUwnIGluIGRlc2lnblNldC52YWx1ZVt0eXBlXSkge1xuICAgICAgcmV0dXJuIGRlc2lnblNldC52YWx1ZVt0eXBlXS50b0lDQUwodmFsdWUsIHN0cnVjdHVyZWRWYWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICAvKipcbiAgICogSW50ZXJuYWwgaGVscGVyIGZvciByZmM2ODY4LiBFeHBvc2luZyB0aGlzIG9uIElDQUwuc3RyaW5naWZ5IHNvIHRoYXRcbiAgICogaGFja2VycyBjYW4gZGlzYWJsZSB0aGUgcmZjNjg2OCBwYXJzaW5nIGlmIHRoZSByZWFsbHkgbmVlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHZhbCAgICAgICAgVGhlIHZhbHVlIHRvIHVuZXNjYXBlXG4gICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgIFRoZSBlc2NhcGVkIHZhbHVlXG4gICAqL1xuICBzdHJpbmdpZnkuX3JmYzY4NjhVbmVzY2FwZSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgIHJldHVybiB2YWwucmVwbGFjZSgvW1xcbl5cIl0vZywgZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIFJGQzY4NjhfUkVQTEFDRV9NQVBbeF07XG4gICAgfSk7XG4gIH07XG4gIHZhciBSRkM2ODY4X1JFUExBQ0VfTUFQID0geyAnXCInOiBcIl4nXCIsIFwiXFxuXCI6IFwiXm5cIiwgXCJeXCI6IFwiXl5cIiB9O1xuXG4gIHJldHVybiBzdHJpbmdpZnk7XG59KCkpO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoLCAyMDExLTIwMTUgKi9cblxuXG4vKipcbiAqIENvbnRhaW5zIHZhcmlvdXMgZnVuY3Rpb25zIHRvIHBhcnNlIGlDYWxlbmRhciBhbmQgdkNhcmQgZGF0YS5cbiAqIEBuYW1lc3BhY2VcbiAqL1xuSUNBTC5wYXJzZSA9IChmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBDSEFSID0gL1teIFxcdF0vO1xuICB2YXIgTVVMVElWQUxVRV9ERUxJTUlURVIgPSAnLCc7XG4gIHZhciBWQUxVRV9ERUxJTUlURVIgPSAnOic7XG4gIHZhciBQQVJBTV9ERUxJTUlURVIgPSAnOyc7XG4gIHZhciBQQVJBTV9OQU1FX0RFTElNSVRFUiA9ICc9JztcbiAgdmFyIERFRkFVTFRfVkFMVUVfVFlQRSA9ICd1bmtub3duJztcbiAgdmFyIERFRkFVTFRfUEFSQU1fVFlQRSA9ICd0ZXh0JztcblxuICB2YXIgZGVzaWduID0gSUNBTC5kZXNpZ247XG4gIHZhciBoZWxwZXJzID0gSUNBTC5oZWxwZXJzO1xuXG4gIC8qKlxuICAgKiBBbiBlcnJvciB0aGF0IG9jY3VycmVkIGR1cmluZyBwYXJzaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSAgICAgICAgVGhlIGVycm9yIG1lc3NhZ2VcbiAgICogQG1lbWJlcm9mIElDQUwucGFyc2VcbiAgICogQGV4dGVuZHMge0Vycm9yfVxuICAgKiBAY2xhc3NcbiAgICovXG4gIGZ1bmN0aW9uIFBhcnNlckVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMubmFtZSA9ICdQYXJzZXJFcnJvcic7XG5cbiAgICB0cnkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUuc3RhY2spIHtcbiAgICAgICAgdmFyIHNwbGl0ID0gZS5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICAgIHNwbGl0LnNoaWZ0KCk7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBzcGxpdC5qb2luKCdcXG4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBQYXJzZXJFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBpQ2FsZW5kYXIgb3IgdkNhcmQgZGF0YSBpbnRvIGEgcmF3IGpDYWwgb2JqZWN0LiBDb25zdWx0XG4gICAqIGRvY3VtZW50YXRpb24gb24gdGhlIHtAdHV0b3JpYWwgbGF5ZXJzfGxheWVycyBvZiBwYXJzaW5nfSBmb3IgbW9yZVxuICAgKiBkZXRhaWxzLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gSUNBTC5wYXJzZVxuICAgKiBAdmFyaWF0aW9uIGZ1bmN0aW9uXG4gICAqIEB0b2RvIEZpeCB0aGUgQVBJIHRvIGJlIG1vcmUgY2xlYXIgb24gdGhlIHJldHVybiB0eXBlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCAgICAgIFRoZSBzdHJpbmcgZGF0YSB0byBwYXJzZVxuICAgKiBAcmV0dXJuIHtPYmplY3R8T2JqZWN0W119ICBBIHNpbmdsZSBqQ2FsIG9iamVjdCwgb3IgYW4gYXJyYXkgdGhlcmVvZlxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VyKGlucHV0KSB7XG4gICAgdmFyIHN0YXRlID0ge307XG4gICAgdmFyIHJvb3QgPSBzdGF0ZS5jb21wb25lbnQgPSBbXTtcblxuICAgIHN0YXRlLnN0YWNrID0gW3Jvb3RdO1xuXG4gICAgcGFyc2VyLl9lYWNoTGluZShpbnB1dCwgZnVuY3Rpb24oZXJyLCBsaW5lKSB7XG4gICAgICBwYXJzZXIuX2hhbmRsZUNvbnRlbnRMaW5lKGxpbmUsIHN0YXRlKTtcbiAgICB9KTtcblxuXG4gICAgLy8gd2hlbiB0aGVyZSBhcmUgc3RpbGwgaXRlbXMgb24gdGhlIHN0YWNrXG4gICAgLy8gdGhyb3cgYSBmYXRhbCBlcnJvciwgYSBjb21wb25lbnQgd2FzIG5vdCBjbG9zZWRcbiAgICAvLyBjb3JyZWN0bHkgaW4gdGhhdCBjYXNlLlxuICAgIGlmIChzdGF0ZS5zdGFjay5sZW5ndGggPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VyRXJyb3IoXG4gICAgICAgICdpbnZhbGlkIGljYWwgYm9keS4gY29tcG9uZW50IGJlZ2FuIGJ1dCBkaWQgbm90IGVuZCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgc3RhdGUgPSBudWxsO1xuXG4gICAgcmV0dXJuIChyb290Lmxlbmd0aCA9PSAxID8gcm9vdFswXSA6IHJvb3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGFuIGlDYWxlbmRhciBwcm9wZXJ0eSB2YWx1ZSBpbnRvIHRoZSBqQ2FsIGZvciBhIHNpbmdsZSBwcm9wZXJ0eVxuICAgKlxuICAgKiBAZnVuY3Rpb24gSUNBTC5wYXJzZS5wcm9wZXJ0eVxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gICAqICAgVGhlIGlDYWxlbmRhciBwcm9wZXJ0eSBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXQ9fSBkZXNpZ25TZXRcbiAgICogICBUaGUgZGVzaWduIGRhdGEgdG8gdXNlIGZvciB0aGlzIHByb3BlcnR5XG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogICBUaGUgakNhbCBPYmplY3QgY29udGFpbmluZyB0aGUgcHJvcGVydHlcbiAgICovXG4gIHBhcnNlci5wcm9wZXJ0eSA9IGZ1bmN0aW9uKHN0ciwgZGVzaWduU2V0KSB7XG4gICAgdmFyIHN0YXRlID0ge1xuICAgICAgY29tcG9uZW50OiBbW10sIFtdXSxcbiAgICAgIGRlc2lnblNldDogZGVzaWduU2V0IHx8IGRlc2lnbi5kZWZhdWx0U2V0XG4gICAgfTtcbiAgICBwYXJzZXIuX2hhbmRsZUNvbnRlbnRMaW5lKHN0ciwgc3RhdGUpO1xuICAgIHJldHVybiBzdGF0ZS5jb21wb25lbnRbMV1bMF07XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlbmllbmNlIG1ldGhvZCB0byBwYXJzZSBhIGNvbXBvbmVudC4gWW91IGNhbiB1c2UgSUNBTC5wYXJzZSgpIGRpcmVjdGx5XG4gICAqIGluc3RlYWQuXG4gICAqXG4gICAqIEBmdW5jdGlvbiBJQ0FMLnBhcnNlLmNvbXBvbmVudFxuICAgKiBAc2VlIElDQUwucGFyc2UoZnVuY3Rpb24pXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgICAgVGhlIGlDYWxlbmRhciBjb21wb25lbnQgc3RyaW5nIHRvIHBhcnNlXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgVGhlIGpDYWwgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNvbXBvbmVudFxuICAgKi9cbiAgcGFyc2VyLmNvbXBvbmVudCA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBwYXJzZXIoc3RyKTtcbiAgfTtcblxuICAvLyBjbGFzc2VzICYgY29uc3RhbnRzXG4gIHBhcnNlci5QYXJzZXJFcnJvciA9IFBhcnNlckVycm9yO1xuXG4gIC8qKlxuICAgKiBUaGUgc3RhdGUgZm9yIHBhcnNpbmcgY29udGVudCBsaW5lcyBmcm9tIGFuIGlDYWxlbmRhci92Q2FyZCBzdHJpbmcuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBtZW1iZXJvZiBJQ0FMLnBhcnNlXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IHBhcnNlclN0YXRlXG4gICAqIEBwcm9wZXJ0eSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fSBkZXNpZ25TZXQgICAgVGhlIGRlc2lnbiBzZXQgdG8gdXNlIGZvciBwYXJzaW5nXG4gICAqIEBwcm9wZXJ0eSB7SUNBTC5Db21wb25lbnRbXX0gc3RhY2sgICAgICAgICAgICAgVGhlIHN0YWNrIG9mIGNvbXBvbmVudHMgYmVpbmcgcHJvY2Vzc2VkXG4gICAqIEBwcm9wZXJ0eSB7SUNBTC5Db21wb25lbnR9IGNvbXBvbmVudCAgICAgICAgICAgVGhlIGN1cnJlbnRseSBhY3RpdmUgY29tcG9uZW50XG4gICAqL1xuXG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYSBzaW5nbGUgbGluZSBvZiBpQ2FsZW5kYXIvdkNhcmQsIHVwZGF0aW5nIHRoZSBzdGF0ZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGZ1bmN0aW9uIElDQUwucGFyc2UuX2hhbmRsZUNvbnRlbnRMaW5lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBsaW5lICAgICAgICAgICAgICAgVGhlIGNvbnRlbnQgbGluZSB0byBwcm9jZXNzXG4gICAqIEBwYXJhbSB7SUNBTC5wYXJzZS5wYXJzZXJTdGF0ZX0gICAgVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGxpbmUgcGFyc2luZ1xuICAgKi9cbiAgcGFyc2VyLl9oYW5kbGVDb250ZW50TGluZSA9IGZ1bmN0aW9uKGxpbmUsIHN0YXRlKSB7XG4gICAgLy8gYnJlYWsgdXAgdGhlIHBhcnRzIG9mIHRoZSBsaW5lXG4gICAgdmFyIHZhbHVlUG9zID0gbGluZS5pbmRleE9mKFZBTFVFX0RFTElNSVRFUik7XG4gICAgdmFyIHBhcmFtUG9zID0gbGluZS5pbmRleE9mKFBBUkFNX0RFTElNSVRFUik7XG5cbiAgICB2YXIgbGFzdFBhcmFtSW5kZXg7XG4gICAgdmFyIGxhc3RWYWx1ZVBvcztcblxuICAgIC8vIG5hbWUgb2YgcHJvcGVydHkgb3IgYmVnaW4vZW5kXG4gICAgdmFyIG5hbWU7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIHBhcmFtcyBpcyBvbmx5IG92ZXJyaWRkZW4gaWYgcGFyYW1Qb3MgIT09IC0xLlxuICAgIC8vIHdlIGNhbid0IGRvIHBhcmFtcyA9IHBhcmFtcyB8fCB7fSBsYXRlciBvblxuICAgIC8vIGJlY2F1c2UgaXQgc2FjcmlmaWNlcyBvcHMuXG4gICAgdmFyIHBhcmFtcyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogRGlmZmVyZW50IHByb3BlcnR5IGNhc2VzXG4gICAgICpcbiAgICAgKlxuICAgICAqIDEuIFJSVUxFOkZSRVE9Zm9vXG4gICAgICogICAgLy8gRlJFUT0gaXMgbm90IGEgcGFyYW0gYnV0IHRoZSB2YWx1ZVxuICAgICAqXG4gICAgICogMi4gQVRURU5ERUU7Uk9MRT1SRVEtUEFSVElDSVBBTlQ7XG4gICAgICogICAgLy8gUk9MRT0gaXMgYSBwYXJhbSBiZWNhdXNlIDogaGFzIG5vdCBoYXBwZW5lZCB5ZXRcbiAgICAgKi9cbiAgICAgIC8vIHdoZW4gdGhlIHBhcmFtZXRlciBkZWxpbWl0ZXIgaXMgYWZ0ZXIgdGhlXG4gICAgICAvLyB2YWx1ZSBkZWxpbWl0ZXIgdGhlbiBpdCBpcyBub3QgYSBwYXJhbWV0ZXIuXG5cbiAgICBpZiAoKHBhcmFtUG9zICE9PSAtMSAmJiB2YWx1ZVBvcyAhPT0gLTEpKSB7XG4gICAgICAvLyB3aGVuIHRoZSBwYXJhbWV0ZXIgZGVsaW1pdGVyIGlzIGFmdGVyIHRoZVxuICAgICAgLy8gdmFsdWUgZGVsaW1pdGVyIHRoZW4gaXQgaXMgbm90IGEgcGFyYW1ldGVyLlxuICAgICAgaWYgKHBhcmFtUG9zID4gdmFsdWVQb3MpIHtcbiAgICAgICAgcGFyYW1Qb3MgPSAtMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcGFyc2VkUGFyYW1zO1xuICAgIGlmIChwYXJhbVBvcyAhPT0gLTEpIHtcbiAgICAgIG5hbWUgPSBsaW5lLnN1YnN0cmluZygwLCBwYXJhbVBvcykudG9Mb3dlckNhc2UoKTtcbiAgICAgIHBhcnNlZFBhcmFtcyA9IHBhcnNlci5fcGFyc2VQYXJhbWV0ZXJzKGxpbmUuc3Vic3RyaW5nKHBhcmFtUG9zKSwgMCwgc3RhdGUuZGVzaWduU2V0KTtcbiAgICAgIGlmIChwYXJzZWRQYXJhbXNbMl0gPT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlckVycm9yKFwiSW52YWxpZCBwYXJhbWV0ZXJzIGluICdcIiArIGxpbmUgKyBcIidcIik7XG4gICAgICB9XG4gICAgICBwYXJhbXMgPSBwYXJzZWRQYXJhbXNbMF07XG4gICAgICBsYXN0UGFyYW1JbmRleCA9IHBhcnNlZFBhcmFtc1sxXS5sZW5ndGggKyBwYXJzZWRQYXJhbXNbMl0gKyBwYXJhbVBvcztcbiAgICAgIGlmICgobGFzdFZhbHVlUG9zID1cbiAgICAgICAgbGluZS5zdWJzdHJpbmcobGFzdFBhcmFtSW5kZXgpLmluZGV4T2YoVkFMVUVfREVMSU1JVEVSKSkgIT09IC0xKSB7XG4gICAgICAgIHZhbHVlID0gbGluZS5zdWJzdHJpbmcobGFzdFBhcmFtSW5kZXggKyBsYXN0VmFsdWVQb3MgKyAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZXJFcnJvcihcIk1pc3NpbmcgcGFyYW1ldGVyIHZhbHVlIGluICdcIiArIGxpbmUgKyBcIidcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh2YWx1ZVBvcyAhPT0gLTEpIHtcbiAgICAgIC8vIHdpdGhvdXQgcGFybWV0ZXJzIChCRUdJTjpWQ0FFTkRBUiwgQ0xBU1M6UFVCTElDKVxuICAgICAgbmFtZSA9IGxpbmUuc3Vic3RyaW5nKDAsIHZhbHVlUG9zKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFsdWUgPSBsaW5lLnN1YnN0cmluZyh2YWx1ZVBvcyArIDEpO1xuXG4gICAgICBpZiAobmFtZSA9PT0gJ2JlZ2luJykge1xuICAgICAgICB2YXIgbmV3Q29tcG9uZW50ID0gW3ZhbHVlLnRvTG93ZXJDYXNlKCksIFtdLCBbXV07XG4gICAgICAgIGlmIChzdGF0ZS5zdGFjay5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBzdGF0ZS5jb21wb25lbnQucHVzaChuZXdDb21wb25lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLmNvbXBvbmVudFsyXS5wdXNoKG5ld0NvbXBvbmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuc3RhY2sucHVzaChzdGF0ZS5jb21wb25lbnQpO1xuICAgICAgICBzdGF0ZS5jb21wb25lbnQgPSBuZXdDb21wb25lbnQ7XG4gICAgICAgIGlmICghc3RhdGUuZGVzaWduU2V0KSB7XG4gICAgICAgICAgc3RhdGUuZGVzaWduU2V0ID0gZGVzaWduLmdldERlc2lnblNldChzdGF0ZS5jb21wb25lbnRbMF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2VuZCcpIHtcbiAgICAgICAgc3RhdGUuY29tcG9uZW50ID0gc3RhdGUuc3RhY2sucG9wKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIElmIGl0IGlzIG5vdCBiZWdpbi9lbmQsIHRoZW4gdGhpcyBpcyBhIHByb3BlcnR5IHdpdGggYW4gZW1wdHkgdmFsdWUsXG4gICAgICAvLyB3aGljaCBzaG91bGQgYmUgY29uc2lkZXJlZCB2YWxpZC5cbiAgICB9IGVsc2Uge1xuICAgICAgLyoqXG4gICAgICAgKiBJbnZhbGlkIGxpbmUuXG4gICAgICAgKiBUaGUgcmF0aW9uYWwgdG8gdGhyb3cgYW4gZXJyb3IgaXMgd2Ugd2lsbFxuICAgICAgICogbmV2ZXIgYmUgY2VydGFpbiB0aGF0IHRoZSByZXN0IG9mIHRoZSBmaWxlXG4gICAgICAgKiBpcyBzYW5lIGFuZCBpdCBpcyB1bmxpa2VseSB0aGF0IHdlIGNhbiBzZXJpYWxpemVcbiAgICAgICAqIHRoZSByZXN1bHQgY29ycmVjdGx5IGVpdGhlci5cbiAgICAgICAqL1xuICAgICAgdGhyb3cgbmV3IFBhcnNlckVycm9yKFxuICAgICAgICAnaW52YWxpZCBsaW5lIChubyB0b2tlbiBcIjtcIiBvciBcIjpcIikgXCInICsgbGluZSArICdcIidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlVHlwZTtcbiAgICB2YXIgbXVsdGlWYWx1ZSA9IGZhbHNlO1xuICAgIHZhciBzdHJ1Y3R1cmVkVmFsdWUgPSBmYWxzZTtcbiAgICB2YXIgcHJvcGVydHlEZXRhaWxzO1xuXG4gICAgaWYgKG5hbWUgaW4gc3RhdGUuZGVzaWduU2V0LnByb3BlcnR5KSB7XG4gICAgICBwcm9wZXJ0eURldGFpbHMgPSBzdGF0ZS5kZXNpZ25TZXQucHJvcGVydHlbbmFtZV07XG5cbiAgICAgIGlmICgnbXVsdGlWYWx1ZScgaW4gcHJvcGVydHlEZXRhaWxzKSB7XG4gICAgICAgIG11bHRpVmFsdWUgPSBwcm9wZXJ0eURldGFpbHMubXVsdGlWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCdzdHJ1Y3R1cmVkVmFsdWUnIGluIHByb3BlcnR5RGV0YWlscykge1xuICAgICAgICBzdHJ1Y3R1cmVkVmFsdWUgPSBwcm9wZXJ0eURldGFpbHMuc3RydWN0dXJlZFZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUgJiYgJ2RldGVjdFR5cGUnIGluIHByb3BlcnR5RGV0YWlscykge1xuICAgICAgICB2YWx1ZVR5cGUgPSBwcm9wZXJ0eURldGFpbHMuZGV0ZWN0VHlwZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYXR0ZW1wdCB0byBkZXRlcm1pbmUgdmFsdWVcbiAgICBpZiAoIXZhbHVlVHlwZSkge1xuICAgICAgaWYgKCEoJ3ZhbHVlJyBpbiBwYXJhbXMpKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0eURldGFpbHMpIHtcbiAgICAgICAgICB2YWx1ZVR5cGUgPSBwcm9wZXJ0eURldGFpbHMuZGVmYXVsdFR5cGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWVUeXBlID0gREVGQVVMVF9WQUxVRV9UWVBFO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBwb3NzaWJsZSB0byBhdm9pZCB0aGlzP1xuICAgICAgICB2YWx1ZVR5cGUgPSBwYXJhbXMudmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkZWxldGUgcGFyYW1zLnZhbHVlO1xuXG4gICAgLyoqXG4gICAgICogTm90ZSBvbiBgdmFyIHJlc3VsdGAganVnZ2xpbmc6XG4gICAgICpcbiAgICAgKiBJIG9ic2VydmVkIHRoYXQgYnVpbGRpbmcgdGhlIGFycmF5IGluIHBpZWNlcyBoYXMgYWR2ZXJzZVxuICAgICAqIGVmZmVjdHMgb24gcGVyZm9ybWFuY2UsIHNvIHdoZXJlIHBvc3NpYmxlIHdlIGlubGluZSB0aGUgY3JlYXRpb24uXG4gICAgICogSXQgaXMgYSBsaXR0bGUgdWdseSBidXQgcmVzdWx0ZWQgaW4gfjIwMDAgYWRkaXRpb25hbCBvcHMvc2VjLlxuICAgICAqL1xuXG4gICAgdmFyIHJlc3VsdDtcbiAgICBpZiAobXVsdGlWYWx1ZSAmJiBzdHJ1Y3R1cmVkVmFsdWUpIHtcbiAgICAgIHZhbHVlID0gcGFyc2VyLl9wYXJzZU11bHRpVmFsdWUodmFsdWUsIHN0cnVjdHVyZWRWYWx1ZSwgdmFsdWVUeXBlLCBbXSwgbXVsdGlWYWx1ZSwgc3RhdGUuZGVzaWduU2V0LCBzdHJ1Y3R1cmVkVmFsdWUpO1xuICAgICAgcmVzdWx0ID0gW25hbWUsIHBhcmFtcywgdmFsdWVUeXBlLCB2YWx1ZV07XG4gICAgfSBlbHNlIGlmIChtdWx0aVZhbHVlKSB7XG4gICAgICByZXN1bHQgPSBbbmFtZSwgcGFyYW1zLCB2YWx1ZVR5cGVdO1xuICAgICAgcGFyc2VyLl9wYXJzZU11bHRpVmFsdWUodmFsdWUsIG11bHRpVmFsdWUsIHZhbHVlVHlwZSwgcmVzdWx0LCBudWxsLCBzdGF0ZS5kZXNpZ25TZXQsIGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKHN0cnVjdHVyZWRWYWx1ZSkge1xuICAgICAgdmFsdWUgPSBwYXJzZXIuX3BhcnNlTXVsdGlWYWx1ZSh2YWx1ZSwgc3RydWN0dXJlZFZhbHVlLCB2YWx1ZVR5cGUsIFtdLCBudWxsLCBzdGF0ZS5kZXNpZ25TZXQsIHN0cnVjdHVyZWRWYWx1ZSk7XG4gICAgICByZXN1bHQgPSBbbmFtZSwgcGFyYW1zLCB2YWx1ZVR5cGUsIHZhbHVlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSBwYXJzZXIuX3BhcnNlVmFsdWUodmFsdWUsIHZhbHVlVHlwZSwgc3RhdGUuZGVzaWduU2V0LCBmYWxzZSk7XG4gICAgICByZXN1bHQgPSBbbmFtZSwgcGFyYW1zLCB2YWx1ZVR5cGUsIHZhbHVlXTtcbiAgICB9XG4gICAgLy8gcmZjNjM1MCByZXF1aXJlcyB0aGF0IGluIHZDYXJkIDQuMCB0aGUgZmlyc3QgY29tcG9uZW50IGlzIHRoZSBWRVJTSU9OXG4gICAgLy8gY29tcG9uZW50IHdpdGggYXMgdmFsdWUgNC4wLCBub3RlIHRoYXQgMy4wIGRvZXMgbm90IGhhdmUgdGhpcyByZXF1aXJlbWVudC5cbiAgICBpZiAoc3RhdGUuY29tcG9uZW50WzBdID09PSAndmNhcmQnICYmIHN0YXRlLmNvbXBvbmVudFsxXS5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAgICEobmFtZSA9PT0gJ3ZlcnNpb24nICYmIHZhbHVlID09PSAnNC4wJykpIHtcbiAgICAgIHN0YXRlLmRlc2lnblNldCA9IGRlc2lnbi5nZXREZXNpZ25TZXQoXCJ2Y2FyZDNcIik7XG4gICAgfVxuICAgIHN0YXRlLmNvbXBvbmVudFsxXS5wdXNoKHJlc3VsdCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhcnNlIGEgdmFsdWUgZnJvbSB0aGUgcmF3IHZhbHVlIGludG8gdGhlIGpDYXJkL2pDYWwgdmFsdWUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBmdW5jdGlvbiBJQ0FMLnBhcnNlLl9wYXJzZVZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSAgICAgICAgICBPcmlnaW5hbCB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAgICAgICAgICAgVHlwZSBvZiB2YWx1ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZGVzaWduU2V0ICAgICAgVGhlIGRlc2lnbiBkYXRhIHRvIHVzZSBmb3IgdGhpcyB2YWx1ZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IHZhcmllcyBvbiB0eXBlXG4gICAqL1xuICBwYXJzZXIuX3BhcnNlVmFsdWUgPSBmdW5jdGlvbih2YWx1ZSwgdHlwZSwgZGVzaWduU2V0LCBzdHJ1Y3R1cmVkVmFsdWUpIHtcbiAgICBpZiAodHlwZSBpbiBkZXNpZ25TZXQudmFsdWUgJiYgJ2Zyb21JQ0FMJyBpbiBkZXNpZ25TZXQudmFsdWVbdHlwZV0pIHtcbiAgICAgIHJldHVybiBkZXNpZ25TZXQudmFsdWVbdHlwZV0uZnJvbUlDQUwodmFsdWUsIHN0cnVjdHVyZWRWYWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICAvKipcbiAgICogUGFyc2UgcGFyYW1ldGVycyBmcm9tIGEgc3RyaW5nIHRvIG9iamVjdC5cbiAgICpcbiAgICogQGZ1bmN0aW9uIElDQUwucGFyc2UuX3BhcnNlUGFyYW1ldGVyc1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbGluZSAgICAgICAgICAgQSBzaW5nbGUgdW5mb2xkZWQgbGluZVxuICAgKiBAcGFyYW0ge051bWVyaWN9IHN0YXJ0ICAgICAgICAgUG9zaXRpb24gdG8gc3RhcnQgbG9va2luZyBmb3IgcHJvcGVydGllc1xuICAgKiBAcGFyYW0ge09iamVjdH0gZGVzaWduU2V0ICAgICAgVGhlIGRlc2lnbiBkYXRhIHRvIHVzZSBmb3IgdGhpcyBwcm9wZXJ0eVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGtleS92YWx1ZSBwYWlyc1xuICAgKi9cbiAgcGFyc2VyLl9wYXJzZVBhcmFtZXRlcnMgPSBmdW5jdGlvbihsaW5lLCBzdGFydCwgZGVzaWduU2V0KSB7XG4gICAgdmFyIGxhc3RQYXJhbSA9IHN0YXJ0O1xuICAgIHZhciBwb3MgPSAwO1xuICAgIHZhciBkZWxpbSA9IFBBUkFNX05BTUVfREVMSU1JVEVSO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIgbmFtZSwgbGNuYW1lO1xuICAgIHZhciB2YWx1ZSwgdmFsdWVQb3MgPSAtMTtcbiAgICB2YXIgdHlwZSwgbXVsdGlWYWx1ZSwgbXZkZWxpbTtcblxuICAgIC8vIGZpbmQgdGhlIG5leHQgJz0nIHNpZ25cbiAgICAvLyB1c2UgbGFzdFBhcmFtIGFuZCBwb3MgdG8gZmluZCBuYW1lXG4gICAgLy8gY2hlY2sgaWYgXCIgaXMgdXNlZCBpZiBzbyBnZXQgdmFsdWUgZnJvbSBcIi0+XCJcbiAgICAvLyB0aGVuIGluY3JlbWVudCBwb3MgdG8gZmluZCBuZXh0IDtcblxuICAgIHdoaWxlICgocG9zICE9PSBmYWxzZSkgJiZcbiAgICAgICAgICAgKHBvcyA9IGhlbHBlcnMudW5lc2NhcGVkSW5kZXhPZihsaW5lLCBkZWxpbSwgcG9zICsgMSkpICE9PSAtMSkge1xuXG4gICAgICBuYW1lID0gbGluZS5zdWJzdHIobGFzdFBhcmFtICsgMSwgcG9zIC0gbGFzdFBhcmFtIC0gMSk7XG4gICAgICBpZiAobmFtZS5sZW5ndGggPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VyRXJyb3IoXCJFbXB0eSBwYXJhbWV0ZXIgbmFtZSBpbiAnXCIgKyBsaW5lICsgXCInXCIpO1xuICAgICAgfVxuICAgICAgbGNuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgbXZkZWxpbSA9IGZhbHNlO1xuICAgICAgbXVsdGlWYWx1ZSA9IGZhbHNlO1xuXG4gICAgICBpZiAobGNuYW1lIGluIGRlc2lnblNldC5wYXJhbSAmJiBkZXNpZ25TZXQucGFyYW1bbGNuYW1lXS52YWx1ZVR5cGUpIHtcbiAgICAgICAgdHlwZSA9IGRlc2lnblNldC5wYXJhbVtsY25hbWVdLnZhbHVlVHlwZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGUgPSBERUZBVUxUX1BBUkFNX1RZUEU7XG4gICAgICB9XG5cbiAgICAgIGlmIChsY25hbWUgaW4gZGVzaWduU2V0LnBhcmFtKSB7XG4gICAgICAgIG11bHRpVmFsdWUgPSBkZXNpZ25TZXQucGFyYW1bbGNuYW1lXS5tdWx0aVZhbHVlO1xuICAgICAgICBpZiAoZGVzaWduU2V0LnBhcmFtW2xjbmFtZV0ubXVsdGlWYWx1ZVNlcGFyYXRlRFF1b3RlKSB7XG4gICAgICAgICAgbXZkZWxpbSA9IHBhcnNlci5fcmZjNjg2OEVzY2FwZSgnXCInICsgbXVsdGlWYWx1ZSArICdcIicpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXh0Q2hhciA9IGxpbmVbcG9zICsgMV07XG4gICAgICBpZiAobmV4dENoYXIgPT09ICdcIicpIHtcbiAgICAgICAgdmFsdWVQb3MgPSBwb3MgKyAyO1xuICAgICAgICBwb3MgPSBoZWxwZXJzLnVuZXNjYXBlZEluZGV4T2YobGluZSwgJ1wiJywgdmFsdWVQb3MpO1xuICAgICAgICBpZiAobXVsdGlWYWx1ZSAmJiBwb3MgIT0gLTEpIHtcbiAgICAgICAgICAgIHZhciBleHRlbmRlZFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIHdoaWxlIChleHRlbmRlZFZhbHVlKSB7XG4gICAgICAgICAgICAgIGlmIChsaW5lW3BvcyArIDFdID09IG11bHRpVmFsdWUgJiYgbGluZVtwb3MgKyAyXSA9PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgcG9zID0gaGVscGVycy51bmVzY2FwZWRJbmRleE9mKGxpbmUsICdcIicsIHBvcyArIDMpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4dGVuZGVkVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyA9PT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VyRXJyb3IoXG4gICAgICAgICAgICAnaW52YWxpZCBsaW5lIChubyBtYXRjaGluZyBkb3VibGUgcXVvdGUpIFwiJyArIGxpbmUgKyAnXCInXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IGxpbmUuc3Vic3RyKHZhbHVlUG9zLCBwb3MgLSB2YWx1ZVBvcyk7XG4gICAgICAgIGxhc3RQYXJhbSA9IGhlbHBlcnMudW5lc2NhcGVkSW5kZXhPZihsaW5lLCBQQVJBTV9ERUxJTUlURVIsIHBvcyk7XG4gICAgICAgIGlmIChsYXN0UGFyYW0gPT09IC0xKSB7XG4gICAgICAgICAgcG9zID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlUG9zID0gcG9zICsgMTtcblxuICAgICAgICAvLyBtb3ZlIHRvIG5leHQgXCI7XCJcbiAgICAgICAgdmFyIG5leHRQb3MgPSBoZWxwZXJzLnVuZXNjYXBlZEluZGV4T2YobGluZSwgUEFSQU1fREVMSU1JVEVSLCB2YWx1ZVBvcyk7XG4gICAgICAgIHZhciBwcm9wVmFsdWVQb3MgPSBoZWxwZXJzLnVuZXNjYXBlZEluZGV4T2YobGluZSwgVkFMVUVfREVMSU1JVEVSLCB2YWx1ZVBvcyk7XG4gICAgICAgIGlmIChwcm9wVmFsdWVQb3MgIT09IC0xICYmIG5leHRQb3MgPiBwcm9wVmFsdWVQb3MpIHtcbiAgICAgICAgICAvLyB0aGlzIGlzIGEgZGVsaW1pdGVyIGluIHRoZSBwcm9wZXJ0eSB2YWx1ZSwgbGV0J3Mgc3RvcCBoZXJlXG4gICAgICAgICAgbmV4dFBvcyA9IHByb3BWYWx1ZVBvcztcbiAgICAgICAgICBwb3MgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChuZXh0UG9zID09PSAtMSkge1xuICAgICAgICAgIC8vIG5vIFwiO1wiXG4gICAgICAgICAgaWYgKHByb3BWYWx1ZVBvcyA9PT0gLTEpIHtcbiAgICAgICAgICAgIG5leHRQb3MgPSBsaW5lLmxlbmd0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV4dFBvcyA9IHByb3BWYWx1ZVBvcztcbiAgICAgICAgICB9XG4gICAgICAgICAgcG9zID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGFzdFBhcmFtID0gbmV4dFBvcztcbiAgICAgICAgICBwb3MgPSBuZXh0UG9zO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgPSBsaW5lLnN1YnN0cih2YWx1ZVBvcywgbmV4dFBvcyAtIHZhbHVlUG9zKTtcbiAgICAgIH1cblxuICAgICAgdmFsdWUgPSBwYXJzZXIuX3JmYzY4NjhFc2NhcGUodmFsdWUpO1xuICAgICAgaWYgKG11bHRpVmFsdWUpIHtcbiAgICAgICAgdmFyIGRlbGltaXRlciA9IG12ZGVsaW0gfHwgbXVsdGlWYWx1ZTtcbiAgICAgICAgdmFsdWUgPSBwYXJzZXIuX3BhcnNlTXVsdGlWYWx1ZSh2YWx1ZSwgZGVsaW1pdGVyLCB0eXBlLCBbXSwgbnVsbCwgZGVzaWduU2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gcGFyc2VyLl9wYXJzZVZhbHVlKHZhbHVlLCB0eXBlLCBkZXNpZ25TZXQpO1xuICAgICAgfVxuXG4gICAgICBpZiAobXVsdGlWYWx1ZSAmJiAobGNuYW1lIGluIHJlc3VsdCkpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0W2xjbmFtZV0pKSB7XG4gICAgICAgICAgcmVzdWx0W2xjbmFtZV0ucHVzaCh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0W2xjbmFtZV0gPSBbXG4gICAgICAgICAgICByZXN1bHRbbGNuYW1lXSxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W2xjbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtyZXN1bHQsIHZhbHVlLCB2YWx1ZVBvc107XG4gIH07XG5cbiAgLyoqXG4gICAqIEludGVybmFsIGhlbHBlciBmb3IgcmZjNjg2OC4gRXhwb3NpbmcgdGhpcyBvbiBJQ0FMLnBhcnNlIHNvIHRoYXRcbiAgICogaGFja2VycyBjYW4gZGlzYWJsZSB0aGUgcmZjNjg2OCBwYXJzaW5nIGlmIHRoZSByZWFsbHkgbmVlZCB0by5cbiAgICpcbiAgICogQGZ1bmN0aW9uIElDQUwucGFyc2UuX3JmYzY4NjhFc2NhcGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHZhbCAgICAgICAgVGhlIHZhbHVlIHRvIGVzY2FwZVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICBUaGUgZXNjYXBlZCB2YWx1ZVxuICAgKi9cbiAgcGFyc2VyLl9yZmM2ODY4RXNjYXBlID0gZnVuY3Rpb24odmFsKSB7XG4gICAgcmV0dXJuIHZhbC5yZXBsYWNlKC9cXF5bJ25eXS9nLCBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gUkZDNjg2OF9SRVBMQUNFX01BUFt4XTtcbiAgICB9KTtcbiAgfTtcbiAgdmFyIFJGQzY4NjhfUkVQTEFDRV9NQVAgPSB7IFwiXidcIjogJ1wiJywgXCJeblwiOiBcIlxcblwiLCBcIl5eXCI6IFwiXlwiIH07XG5cbiAgLyoqXG4gICAqIFBhcnNlIGEgbXVsdGkgdmFsdWUgc3RyaW5nLiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgZWl0aGVyIGZvciBwYXJzaW5nXG4gICAqIGFjdHVhbCBtdWx0aS12YWx1ZSBwcm9wZXJ0eSdzIHZhbHVlcywgb3IgZm9yIGhhbmRsaW5nIHBhcmFtZXRlciB2YWx1ZXMuIEl0XG4gICAqIGNhbiBiZSB1c2VkIGZvciBib3RoIG11bHRpLXZhbHVlIHByb3BlcnRpZXMgYW5kIHN0cnVjdHVyZWQgdmFsdWUgcHJvcGVydGllcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGZ1bmN0aW9uIElDQUwucGFyc2UuX3BhcnNlTXVsdGlWYWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gYnVmZmVyICAgICBUaGUgYnVmZmVyIGNvbnRhaW5pbmcgdGhlIGZ1bGwgdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRlbGltICAgICAgVGhlIG11bHRpLXZhbHVlIGRlbGltaXRlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAgICAgICBUaGUgdmFsdWUgdHlwZSB0byBiZSBwYXJzZWRcbiAgICogQHBhcmFtIHtBcnJheS48Pz59IHJlc3VsdCAgICAgICAgVGhlIGFycmF5IHRvIGFwcGVuZCByZXN1bHRzIHRvLCB2YXJpZXMgb24gdmFsdWUgdHlwZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5uZXJNdWx0aSBUaGUgaW5uZXIgZGVsaW1pdGVyIHRvIHNwbGl0IGVhY2ggdmFsdWUgd2l0aFxuICAgKiBAcGFyYW0ge0lDQUwuZGVzaWduLmRlc2lnblNldH0gZGVzaWduU2V0ICAgVGhlIGRlc2lnbiBkYXRhIGZvciB0aGlzIHZhbHVlXG4gICAqIEByZXR1cm4gez98QXJyYXkuPD8+fSAgICAgICAgICAgIEVpdGhlciBhbiBhcnJheSBvZiByZXN1bHRzLCBvciB0aGUgZmlyc3QgcmVzdWx0XG4gICAqL1xuICBwYXJzZXIuX3BhcnNlTXVsdGlWYWx1ZSA9IGZ1bmN0aW9uKGJ1ZmZlciwgZGVsaW0sIHR5cGUsIHJlc3VsdCwgaW5uZXJNdWx0aSwgZGVzaWduU2V0LCBzdHJ1Y3R1cmVkVmFsdWUpIHtcbiAgICB2YXIgcG9zID0gMDtcbiAgICB2YXIgbGFzdFBvcyA9IDA7XG4gICAgdmFyIHZhbHVlO1xuICAgIGlmIChkZWxpbS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfVxuXG4gICAgLy8gc3BsaXQgZWFjaCBwaWVjZVxuICAgIHdoaWxlICgocG9zID0gaGVscGVycy51bmVzY2FwZWRJbmRleE9mKGJ1ZmZlciwgZGVsaW0sIGxhc3RQb3MpKSAhPT0gLTEpIHtcbiAgICAgIHZhbHVlID0gYnVmZmVyLnN1YnN0cihsYXN0UG9zLCBwb3MgLSBsYXN0UG9zKTtcbiAgICAgIGlmIChpbm5lck11bHRpKSB7XG4gICAgICAgIHZhbHVlID0gcGFyc2VyLl9wYXJzZU11bHRpVmFsdWUodmFsdWUsIGlubmVyTXVsdGksIHR5cGUsIFtdLCBudWxsLCBkZXNpZ25TZXQsIHN0cnVjdHVyZWRWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IHBhcnNlci5fcGFyc2VWYWx1ZSh2YWx1ZSwgdHlwZSwgZGVzaWduU2V0LCBzdHJ1Y3R1cmVkVmFsdWUpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgbGFzdFBvcyA9IHBvcyArIGRlbGltLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBvbiB0aGUgbGFzdCBwaWVjZSB0YWtlIHRoZSByZXN0IG9mIHN0cmluZ1xuICAgIHZhbHVlID0gYnVmZmVyLnN1YnN0cihsYXN0UG9zKTtcbiAgICBpZiAoaW5uZXJNdWx0aSkge1xuICAgICAgdmFsdWUgPSBwYXJzZXIuX3BhcnNlTXVsdGlWYWx1ZSh2YWx1ZSwgaW5uZXJNdWx0aSwgdHlwZSwgW10sIG51bGwsIGRlc2lnblNldCwgc3RydWN0dXJlZFZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSBwYXJzZXIuX3BhcnNlVmFsdWUodmFsdWUsIHR5cGUsIGRlc2lnblNldCwgc3RydWN0dXJlZFZhbHVlKTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2godmFsdWUpO1xuXG4gICAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPT0gMSA/IHJlc3VsdFswXSA6IHJlc3VsdDtcbiAgfTtcblxuICAvKipcbiAgICogUHJvY2VzcyBhIGNvbXBsZXRlIGJ1ZmZlciBvZiBpQ2FsZW5kYXIvdkNhcmQgZGF0YSBsaW5lIGJ5IGxpbmUsIGNvcnJlY3RseVxuICAgKiB1bmZvbGRpbmcgY29udGVudC4gRWFjaCBsaW5lIHdpbGwgYmUgcHJvY2Vzc2VkIHdpdGggdGhlIGdpdmVuIGNhbGxiYWNrXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBmdW5jdGlvbiBJQ0FMLnBhcnNlLl9lYWNoTGluZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gYnVmZmVyICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBidWZmZXIgdG8gcHJvY2Vzc1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKD9TdHJpbmcsIFN0cmluZyl9IGNhbGxiYWNrICAgIFRoZSBjYWxsYmFjayBmb3IgZWFjaCBsaW5lXG4gICAqL1xuICBwYXJzZXIuX2VhY2hMaW5lID0gZnVuY3Rpb24oYnVmZmVyLCBjYWxsYmFjaykge1xuICAgIHZhciBsZW4gPSBidWZmZXIubGVuZ3RoO1xuICAgIHZhciBsYXN0UG9zID0gYnVmZmVyLnNlYXJjaChDSEFSKTtcbiAgICB2YXIgcG9zID0gbGFzdFBvcztcbiAgICB2YXIgbGluZTtcbiAgICB2YXIgZmlyc3RDaGFyO1xuXG4gICAgdmFyIG5ld2xpbmVPZmZzZXQ7XG5cbiAgICBkbyB7XG4gICAgICBwb3MgPSBidWZmZXIuaW5kZXhPZignXFxuJywgbGFzdFBvcykgKyAxO1xuXG4gICAgICBpZiAocG9zID4gMSAmJiBidWZmZXJbcG9zIC0gMl0gPT09ICdcXHInKSB7XG4gICAgICAgIG5ld2xpbmVPZmZzZXQgPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3bGluZU9mZnNldCA9IDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChwb3MgPT09IDApIHtcbiAgICAgICAgcG9zID0gbGVuO1xuICAgICAgICBuZXdsaW5lT2Zmc2V0ID0gMDtcbiAgICAgIH1cblxuICAgICAgZmlyc3RDaGFyID0gYnVmZmVyW2xhc3RQb3NdO1xuXG4gICAgICBpZiAoZmlyc3RDaGFyID09PSAnICcgfHwgZmlyc3RDaGFyID09PSAnXFx0Jykge1xuICAgICAgICAvLyBhZGQgdG8gbGluZVxuICAgICAgICBsaW5lICs9IGJ1ZmZlci5zdWJzdHIoXG4gICAgICAgICAgbGFzdFBvcyArIDEsXG4gICAgICAgICAgcG9zIC0gbGFzdFBvcyAtIChuZXdsaW5lT2Zmc2V0ICsgMSlcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChsaW5lKVxuICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGxpbmUpO1xuICAgICAgICAvLyBwdXNoIGxpbmVcbiAgICAgICAgbGluZSA9IGJ1ZmZlci5zdWJzdHIoXG4gICAgICAgICAgbGFzdFBvcyxcbiAgICAgICAgICBwb3MgLSBsYXN0UG9zIC0gbmV3bGluZU9mZnNldFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBsYXN0UG9zID0gcG9zO1xuICAgIH0gd2hpbGUgKHBvcyAhPT0gbGVuKTtcblxuICAgIC8vIGV4dHJhIGVuZGluZyBsaW5lXG4gICAgbGluZSA9IGxpbmUudHJpbSgpO1xuXG4gICAgaWYgKGxpbmUubGVuZ3RoKVxuICAgICAgY2FsbGJhY2sobnVsbCwgbGluZSk7XG4gIH07XG5cbiAgcmV0dXJuIHBhcnNlcjtcblxufSgpKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAxMS0yMDE1ICovXG5cblxuLyoqXG4gKiBUaGlzIHN5bWJvbCBpcyBmdXJ0aGVyIGRlc2NyaWJlZCBsYXRlciBvblxuICogQGlnbm9yZVxuICovXG5JQ0FMLkNvbXBvbmVudCA9IChmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBQUk9QRVJUWV9JTkRFWCA9IDE7XG4gIHZhciBDT01QT05FTlRfSU5ERVggPSAyO1xuICB2YXIgTkFNRV9JTkRFWCA9IDA7XG5cbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogV3JhcHMgYSBqQ2FsIGNvbXBvbmVudCwgYWRkaW5nIGNvbnZlbmllbmNlIG1ldGhvZHMgdG8gYWRkLCByZW1vdmUgYW5kXG4gICAqIHVwZGF0ZSBzdWJjb21wb25lbnRzIGFuZCBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQGFsaWFzIElDQUwuQ29tcG9uZW50XG4gICAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBqQ2FsICAgICAgICAgUmF3IGpDYWwgY29tcG9uZW50IGRhdGEgT1IgbmFtZSBvZiBuZXdcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge0lDQUwuQ29tcG9uZW50fSBwYXJlbnQgICAgIFBhcmVudCBjb21wb25lbnQgdG8gYXNzb2NpYXRlXG4gICAqL1xuICBmdW5jdGlvbiBDb21wb25lbnQoakNhbCwgcGFyZW50KSB7XG4gICAgaWYgKHR5cGVvZihqQ2FsKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIGpDYWwgc3BlYyAobmFtZSwgcHJvcGVydGllcywgY29tcG9uZW50cylcbiAgICAgIGpDYWwgPSBbakNhbCwgW10sIFtdXTtcbiAgICB9XG5cbiAgICAvLyBtb3N0bHkgZm9yIGxlZ2FjeSByZWFzb25zLlxuICAgIHRoaXMuakNhbCA9IGpDYWw7XG5cbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudCB8fCBudWxsO1xuICB9XG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBIeWRyYXRlZCBwcm9wZXJ0aWVzIGFyZSBpbnNlcnRlZCBpbnRvIHRoZSBfcHJvcGVydGllcyBhcnJheSBhdCB0aGUgc2FtZVxuICAgICAqIHBvc2l0aW9uIGFzIGluIHRoZSBqQ2FsIGFycmF5LCBzbyBpdCBpcyBwb3NzaWJsZSB0aGF0IHRoZSBhcnJheSBjb250YWluc1xuICAgICAqIHVuZGVmaW5lZCB2YWx1ZXMgZm9yIHVuaHlkcmRhdGVkIHByb3BlcnRpZXMuIFRvIGF2b2lkIGl0ZXJhdGluZyB0aGVcbiAgICAgKiBhcnJheSB3aGVuIGNoZWNraW5nIGlmIGFsbCBwcm9wZXJ0aWVzIGhhdmUgYmVlbiBoeWRyYXRlZCwgd2Ugc2F2ZSB0aGVcbiAgICAgKiBjb3VudCBoZXJlLlxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9oeWRyYXRlZFByb3BlcnR5Q291bnQ6IDAsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2FtZSBjb3VudCBhcyBmb3IgX2h5ZHJhdGVkUHJvcGVydHlDb3VudCwgYnV0IGZvciBzdWJjb21wb25lbnRzXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2h5ZHJhdGVkQ29tcG9uZW50Q291bnQ6IDAsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGlzIGNvbXBvbmVudFxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgcmV0dXJuIHRoaXMuakNhbFtOQU1FX0lOREVYXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGRlc2lnbiBzZXQgZm9yIHRoaXMgY29tcG9uZW50LCBlLmcuIGljYWxlbmRhciB2cyB2Y2FyZFxuICAgICAqXG4gICAgICogQHR5cGUge0lDQUwuZGVzaWduLmRlc2lnblNldH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldCBfZGVzaWduU2V0KCkge1xuICAgICAgdmFyIHBhcmVudERlc2lnbiA9IHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50Ll9kZXNpZ25TZXQ7XG4gICAgICByZXR1cm4gcGFyZW50RGVzaWduIHx8IElDQUwuZGVzaWduLmdldERlc2lnblNldCh0aGlzLm5hbWUpO1xuICAgIH0sXG5cbiAgICBfaHlkcmF0ZUNvbXBvbmVudDogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIGlmICghdGhpcy5fY29tcG9uZW50cykge1xuICAgICAgICB0aGlzLl9jb21wb25lbnRzID0gW107XG4gICAgICAgIHRoaXMuX2h5ZHJhdGVkQ29tcG9uZW50Q291bnQgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fY29tcG9uZW50c1tpbmRleF0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudHNbaW5kZXhdO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29tcCA9IG5ldyBDb21wb25lbnQoXG4gICAgICAgIHRoaXMuakNhbFtDT01QT05FTlRfSU5ERVhdW2luZGV4XSxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcblxuICAgICAgdGhpcy5faHlkcmF0ZWRDb21wb25lbnRDb3VudCsrO1xuICAgICAgcmV0dXJuICh0aGlzLl9jb21wb25lbnRzW2luZGV4XSA9IGNvbXApO1xuICAgIH0sXG5cbiAgICBfaHlkcmF0ZVByb3BlcnR5OiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgaWYgKCF0aGlzLl9wcm9wZXJ0aWVzKSB7XG4gICAgICAgIHRoaXMuX3Byb3BlcnRpZXMgPSBbXTtcbiAgICAgICAgdGhpcy5faHlkcmF0ZWRQcm9wZXJ0eUNvdW50ID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3Byb3BlcnRpZXNbaW5kZXhdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9wZXJ0aWVzW2luZGV4XTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByb3AgPSBuZXcgSUNBTC5Qcm9wZXJ0eShcbiAgICAgICAgdGhpcy5qQ2FsW1BST1BFUlRZX0lOREVYXVtpbmRleF0sXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG5cbiAgICAgIHRoaXMuX2h5ZHJhdGVkUHJvcGVydHlDb3VudCsrO1xuICAgICAgcmV0dXJuICh0aGlzLl9wcm9wZXJ0aWVzW2luZGV4XSA9IHByb3ApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyBmaXJzdCBzdWIgY29tcG9uZW50LCBvcHRpb25hbGx5IGZpbHRlcmVkIGJ5IG5hbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZz19IG5hbWUgICAgICAgIE9wdGlvbmFsIG5hbWUgdG8gZmlsdGVyIGJ5XG4gICAgICogQHJldHVybiB7P0lDQUwuQ29tcG9uZW50fSAgICAgVGhlIGZvdW5kIHN1YmNvbXBvbmVudFxuICAgICAqL1xuICAgIGdldEZpcnN0U3ViY29tcG9uZW50OiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBjb21wcyA9IHRoaXMuakNhbFtDT01QT05FTlRfSU5ERVhdO1xuICAgICAgICB2YXIgbGVuID0gY29tcHMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAoY29tcHNbaV1bTkFNRV9JTkRFWF0gPT09IG5hbWUpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9oeWRyYXRlQ29tcG9uZW50KGkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmpDYWxbQ09NUE9ORU5UX0lOREVYXS5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5faHlkcmF0ZUNvbXBvbmVudCgwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBlbnN1cmUgd2UgcmV0dXJuIGEgdmFsdWUgKHN0cmljdCBtb2RlKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIGFsbCBzdWIgY29tcG9uZW50cywgb3B0aW9uYWxseSBmaWx0ZXJpbmcgYnkgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nPX0gbmFtZSAgICAgICAgICAgIE9wdGlvbmFsIG5hbWUgdG8gZmlsdGVyIGJ5XG4gICAgICogQHJldHVybiB7SUNBTC5Db21wb25lbnRbXX0gICAgICAgVGhlIGZvdW5kIHN1YiBjb21wb25lbnRzXG4gICAgICovXG4gICAgZ2V0QWxsU3ViY29tcG9uZW50czogZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGpDYWxMZW4gPSB0aGlzLmpDYWxbQ09NUE9ORU5UX0lOREVYXS5sZW5ndGg7XG4gICAgICB2YXIgaSA9IDA7XG5cbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHZhciBjb21wcyA9IHRoaXMuakNhbFtDT01QT05FTlRfSU5ERVhdO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgZm9yICg7IGkgPCBqQ2FsTGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAobmFtZSA9PT0gY29tcHNbaV1bTkFNRV9JTkRFWF0pIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgICAgICB0aGlzLl9oeWRyYXRlQ29tcG9uZW50KGkpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jb21wb25lbnRzIHx8XG4gICAgICAgICAgICAodGhpcy5faHlkcmF0ZWRDb21wb25lbnRDb3VudCAhPT0gakNhbExlbikpIHtcbiAgICAgICAgICBmb3IgKDsgaSA8IGpDYWxMZW47IGkrKykge1xuICAgICAgICAgICAgdGhpcy5faHlkcmF0ZUNvbXBvbmVudChpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50cyB8fCBbXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIHdoZW4gYSBuYW1lZCBwcm9wZXJ0eSBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAgICAgVGhlIHByb3BlcnR5IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgVHJ1ZSwgd2hlbiBwcm9wZXJ0eSBpcyBmb3VuZFxuICAgICAqL1xuICAgIGhhc1Byb3BlcnR5OiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgcHJvcHMgPSB0aGlzLmpDYWxbUFJPUEVSVFlfSU5ERVhdO1xuICAgICAgdmFyIGxlbiA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgdmFyIGkgPSAwO1xuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAvLyAwIGlzIHByb3BlcnR5IG5hbWVcbiAgICAgICAgaWYgKHByb3BzW2ldW05BTUVfSU5ERVhdID09PSBuYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgZmlyc3QgcHJvcGVydHksIG9wdGlvbmFsbHkgd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nPX0gbmFtZSAgICAgICAgTG93ZXJjYXNlIHByb3BlcnR5IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/SUNBTC5Qcm9wZXJ0eX0gICAgIFRoZSBmb3VuZCBwcm9wZXJ0eVxuICAgICAqL1xuICAgIGdldEZpcnN0UHJvcGVydHk6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5qQ2FsW1BST1BFUlRZX0lOREVYXTtcbiAgICAgICAgdmFyIGxlbiA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWYgKHByb3BzW2ldW05BTUVfSU5ERVhdID09PSBuYW1lKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5faHlkcmF0ZVByb3BlcnR5KGkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmpDYWxbUFJPUEVSVFlfSU5ERVhdLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9oeWRyYXRlUHJvcGVydHkoMCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZmlyc3QgcHJvcGVydHkncyB2YWx1ZSwgaWYgYXZhaWxhYmxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmc9fSBuYW1lICAgIExvd2VyY2FzZSBwcm9wZXJ0eSBuYW1lXG4gICAgICogQHJldHVybiB7P1N0cmluZ30gICAgICAgIFRoZSBmb3VuZCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgKi9cbiAgICBnZXRGaXJzdFByb3BlcnR5VmFsdWU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciBwcm9wID0gdGhpcy5nZXRGaXJzdFByb3BlcnR5KG5hbWUpO1xuICAgICAgaWYgKHByb3ApIHtcbiAgICAgICAgcmV0dXJuIHByb3AuZ2V0Rmlyc3RWYWx1ZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBwcm9wZXJ0aWVzIGluIHRoZSBjb21wb25lbnQsIG9wdGlvbmFsbHkgZmlsdGVyZWQgYnkgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nPX0gbmFtZSAgICAgICAgTG93ZXJjYXNlIHByb3BlcnR5IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlByb3BlcnR5W119ICAgIExpc3Qgb2YgcHJvcGVydGllc1xuICAgICAqL1xuICAgIGdldEFsbFByb3BlcnRpZXM6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciBqQ2FsTGVuID0gdGhpcy5qQ2FsW1BST1BFUlRZX0lOREVYXS5sZW5ndGg7XG4gICAgICB2YXIgaSA9IDA7XG5cbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMuakNhbFtQUk9QRVJUWV9JTkRFWF07XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICBmb3IgKDsgaSA8IGpDYWxMZW47IGkrKykge1xuICAgICAgICAgIGlmIChuYW1lID09PSBwcm9wc1tpXVtOQU1FX0lOREVYXSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgICAgIHRoaXMuX2h5ZHJhdGVQcm9wZXJ0eShpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdGhpcy5fcHJvcGVydGllcyB8fFxuICAgICAgICAgICAgKHRoaXMuX2h5ZHJhdGVkUHJvcGVydHlDb3VudCAhPT0gakNhbExlbikpIHtcbiAgICAgICAgICBmb3IgKDsgaSA8IGpDYWxMZW47IGkrKykge1xuICAgICAgICAgICAgdGhpcy5faHlkcmF0ZVByb3BlcnR5KGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9wZXJ0aWVzIHx8IFtdO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfcmVtb3ZlT2JqZWN0QnlJbmRleDogZnVuY3Rpb24oakNhbEluZGV4LCBjYWNoZSwgaW5kZXgpIHtcbiAgICAgIGNhY2hlID0gY2FjaGUgfHwgW107XG4gICAgICAvLyByZW1vdmUgY2FjaGVkIHZlcnNpb25cbiAgICAgIGlmIChjYWNoZVtpbmRleF0pIHtcbiAgICAgICAgdmFyIG9iaiA9IGNhY2hlW2luZGV4XTtcbiAgICAgICAgaWYgKFwicGFyZW50XCIgaW4gb2JqKSB7XG4gICAgICAgICAgICBvYmoucGFyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjYWNoZS5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgICAvLyByZW1vdmUgaXQgZnJvbSB0aGUgakNhbFxuICAgICAgdGhpcy5qQ2FsW2pDYWxJbmRleF0uc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9LFxuXG4gICAgX3JlbW92ZU9iamVjdDogZnVuY3Rpb24oakNhbEluZGV4LCBjYWNoZSwgbmFtZU9yT2JqZWN0KSB7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgb2JqZWN0cyA9IHRoaXMuakNhbFtqQ2FsSW5kZXhdO1xuICAgICAgdmFyIGxlbiA9IG9iamVjdHMubGVuZ3RoO1xuICAgICAgdmFyIGNhY2hlZCA9IHRoaXNbY2FjaGVdO1xuXG4gICAgICBpZiAodHlwZW9mKG5hbWVPck9iamVjdCkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAob2JqZWN0c1tpXVtOQU1FX0lOREVYXSA9PT0gbmFtZU9yT2JqZWN0KSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVPYmplY3RCeUluZGV4KGpDYWxJbmRleCwgY2FjaGVkLCBpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjYWNoZWQpIHtcbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmIChjYWNoZWRbaV0gJiYgY2FjaGVkW2ldID09PSBuYW1lT3JPYmplY3QpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZU9iamVjdEJ5SW5kZXgoakNhbEluZGV4LCBjYWNoZWQsIGkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgX3JlbW92ZUFsbE9iamVjdHM6IGZ1bmN0aW9uKGpDYWxJbmRleCwgY2FjaGUsIG5hbWUpIHtcbiAgICAgIHZhciBjYWNoZWQgPSB0aGlzW2NhY2hlXTtcblxuICAgICAgLy8gVW5mb3J0dW5hdGVseSB3ZSBoYXZlIHRvIHJ1biB0aHJvdWdoIGFsbCBjaGlsZHJlbiB0byByZXNldCB0aGVpclxuICAgICAgLy8gcGFyZW50IHByb3BlcnR5LlxuICAgICAgdmFyIG9iamVjdHMgPSB0aGlzLmpDYWxbakNhbEluZGV4XTtcbiAgICAgIHZhciBpID0gb2JqZWN0cy5sZW5ndGggLSAxO1xuXG4gICAgICAvLyBkZXNjZW5kaW5nIHNlYXJjaCByZXF1aXJlZCBiZWNhdXNlIHNwbGljZVxuICAgICAgLy8gaXMgdXNlZCBhbmQgd2lsbCBlZmZlY3QgdGhlIGluZGljZXMuXG4gICAgICBmb3IgKDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKCFuYW1lIHx8IG9iamVjdHNbaV1bTkFNRV9JTkRFWF0gPT09IG5hbWUpIHtcbiAgICAgICAgICB0aGlzLl9yZW1vdmVPYmplY3RCeUluZGV4KGpDYWxJbmRleCwgY2FjaGVkLCBpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgc2luZ2xlIHN1YiBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuQ29tcG9uZW50fSBjb21wb25lbnQgICAgICAgIFRoZSBjb21wb25lbnQgdG8gYWRkXG4gICAgICogQHJldHVybiB7SUNBTC5Db21wb25lbnR9ICAgICAgICAgICAgICAgICBUaGUgcGFzc2VkIGluIGNvbXBvbmVudFxuICAgICAqL1xuICAgIGFkZFN1YmNvbXBvbmVudDogZnVuY3Rpb24oY29tcG9uZW50KSB7XG4gICAgICBpZiAoIXRoaXMuX2NvbXBvbmVudHMpIHtcbiAgICAgICAgdGhpcy5fY29tcG9uZW50cyA9IFtdO1xuICAgICAgICB0aGlzLl9oeWRyYXRlZENvbXBvbmVudENvdW50ID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbXBvbmVudC5wYXJlbnQpIHtcbiAgICAgICAgY29tcG9uZW50LnBhcmVudC5yZW1vdmVTdWJjb21wb25lbnQoY29tcG9uZW50KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlkeCA9IHRoaXMuakNhbFtDT01QT05FTlRfSU5ERVhdLnB1c2goY29tcG9uZW50LmpDYWwpO1xuICAgICAgdGhpcy5fY29tcG9uZW50c1tpZHggLSAxXSA9IGNvbXBvbmVudDtcbiAgICAgIHRoaXMuX2h5ZHJhdGVkQ29tcG9uZW50Q291bnQrKztcbiAgICAgIGNvbXBvbmVudC5wYXJlbnQgPSB0aGlzO1xuICAgICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHNpbmdsZSBjb21wb25lbnQgYnkgbmFtZSBvciB0aGUgaW5zdGFuY2Ugb2YgYSBzcGVjaWZpY1xuICAgICAqIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SUNBTC5Db21wb25lbnR8U3RyaW5nfSBuYW1lT3JDb21wICAgIE5hbWUgb2YgY29tcG9uZW50LCBvciBjb21wb25lbnRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICAgICAgICAgICAgICAgICAgICBUcnVlIHdoZW4gY29tcCBpcyByZW1vdmVkXG4gICAgICovXG4gICAgcmVtb3ZlU3ViY29tcG9uZW50OiBmdW5jdGlvbihuYW1lT3JDb21wKSB7XG4gICAgICB2YXIgcmVtb3ZlZCA9IHRoaXMuX3JlbW92ZU9iamVjdChDT01QT05FTlRfSU5ERVgsICdfY29tcG9uZW50cycsIG5hbWVPckNvbXApO1xuICAgICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgICAgdGhpcy5faHlkcmF0ZWRDb21wb25lbnRDb3VudC0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlbW92ZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGNvbXBvbmVudHMgb3IgKGlmIGdpdmVuKSBhbGwgY29tcG9uZW50cyBieSBhIHBhcnRpY3VsYXJcbiAgICAgKiBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmc9fSBuYW1lICAgICAgICAgICAgTG93ZXJjYXNlIGNvbXBvbmVudCBuYW1lXG4gICAgICovXG4gICAgcmVtb3ZlQWxsU3ViY29tcG9uZW50czogZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIHJlbW92ZWQgPSB0aGlzLl9yZW1vdmVBbGxPYmplY3RzKENPTVBPTkVOVF9JTkRFWCwgJ19jb21wb25lbnRzJywgbmFtZSk7XG4gICAgICB0aGlzLl9oeWRyYXRlZENvbXBvbmVudENvdW50ID0gMDtcbiAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIHtAbGluayBJQ0FMLlByb3BlcnR5fSB0byB0aGUgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLlByb3BlcnR5fSBwcm9wZXJ0eSAgICAgIFRoZSBwcm9wZXJ0eSB0byBhZGRcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlByb3BlcnR5fSAgICAgICAgICAgICAgVGhlIHBhc3NlZCBpbiBwcm9wZXJ0eVxuICAgICAqL1xuICAgIGFkZFByb3BlcnR5OiBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgICAgaWYgKCEocHJvcGVydHkgaW5zdGFuY2VvZiBJQ0FMLlByb3BlcnR5KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtdXN0IGluc3RhbmNlIG9mIElDQUwuUHJvcGVydHknKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9wcm9wZXJ0aWVzKSB7XG4gICAgICAgIHRoaXMuX3Byb3BlcnRpZXMgPSBbXTtcbiAgICAgICAgdGhpcy5faHlkcmF0ZWRQcm9wZXJ0eUNvdW50ID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3BlcnR5LnBhcmVudCkge1xuICAgICAgICBwcm9wZXJ0eS5wYXJlbnQucmVtb3ZlUHJvcGVydHkocHJvcGVydHkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaWR4ID0gdGhpcy5qQ2FsW1BST1BFUlRZX0lOREVYXS5wdXNoKHByb3BlcnR5LmpDYWwpO1xuICAgICAgdGhpcy5fcHJvcGVydGllc1tpZHggLSAxXSA9IHByb3BlcnR5O1xuICAgICAgdGhpcy5faHlkcmF0ZWRQcm9wZXJ0eUNvdW50Kys7XG4gICAgICBwcm9wZXJ0eS5wYXJlbnQgPSB0aGlzO1xuICAgICAgcmV0dXJuIHByb3BlcnR5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIGFkZCBhIHByb3BlcnR5IHdpdGggYSB2YWx1ZSB0byB0aGUgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgICAgICAgICAgICAgbmFtZSAgICAgICAgIFByb3BlcnR5IG5hbWUgdG8gYWRkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfE9iamVjdH0gdmFsdWUgICAgICAgIFByb3BlcnR5IHZhbHVlXG4gICAgICogQHJldHVybiB7SUNBTC5Qcm9wZXJ0eX0gICAgICAgICAgICAgICAgICAgIFRoZSBjcmVhdGVkIHByb3BlcnR5XG4gICAgICovXG4gICAgYWRkUHJvcGVydHlXaXRoVmFsdWU6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICB2YXIgcHJvcCA9IG5ldyBJQ0FMLlByb3BlcnR5KG5hbWUpO1xuICAgICAgcHJvcC5zZXRWYWx1ZSh2YWx1ZSk7XG5cbiAgICAgIHRoaXMuYWRkUHJvcGVydHkocHJvcCk7XG5cbiAgICAgIHJldHVybiBwcm9wO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRoYXQgd2lsbCB1cGRhdGUgb3IgY3JlYXRlIGEgcHJvcGVydHkgb2YgdGhlIGdpdmVuIG5hbWVcbiAgICAgKiBhbmQgc2V0cyBpdHMgdmFsdWUuIElmIG11bHRpcGxlIHByb3BlcnRpZXMgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBleGlzdCxcbiAgICAgKiBvbmx5IHRoZSBmaXJzdCBpcyB1cGRhdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgICAgICAgICAgICAgbmFtZSAgICAgICAgIFByb3BlcnR5IG5hbWUgdG8gdXBkYXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfE9iamVjdH0gdmFsdWUgICAgICAgIFByb3BlcnR5IHZhbHVlXG4gICAgICogQHJldHVybiB7SUNBTC5Qcm9wZXJ0eX0gICAgICAgICAgICAgICAgICAgIFRoZSBjcmVhdGVkIHByb3BlcnR5XG4gICAgICovXG4gICAgdXBkYXRlUHJvcGVydHlXaXRoVmFsdWU6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICB2YXIgcHJvcCA9IHRoaXMuZ2V0Rmlyc3RQcm9wZXJ0eShuYW1lKTtcblxuICAgICAgaWYgKHByb3ApIHtcbiAgICAgICAgcHJvcC5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wID0gdGhpcy5hZGRQcm9wZXJ0eVdpdGhWYWx1ZShuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcm9wO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgc2luZ2xlIHByb3BlcnR5IGJ5IG5hbWUgb3IgdGhlIGluc3RhbmNlIG9mIHRoZSBzcGVjaWZpY1xuICAgICAqIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8SUNBTC5Qcm9wZXJ0eX0gbmFtZU9yUHJvcCAgICAgUHJvcGVydHkgbmFtZSBvciBpbnN0YW5jZSB0byByZW1vdmVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICAgICAgICAgICAgICAgICAgICBUcnVlLCB3aGVuIGRlbGV0ZWRcbiAgICAgKi9cbiAgICByZW1vdmVQcm9wZXJ0eTogZnVuY3Rpb24obmFtZU9yUHJvcCkge1xuICAgICAgdmFyIHJlbW92ZWQgPSB0aGlzLl9yZW1vdmVPYmplY3QoUFJPUEVSVFlfSU5ERVgsICdfcHJvcGVydGllcycsIG5hbWVPclByb3ApO1xuICAgICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgICAgdGhpcy5faHlkcmF0ZWRQcm9wZXJ0eUNvdW50LS07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgcHJvcGVydGllcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBjb21wb25lbnQsIG9wdGlvbmFsbHlcbiAgICAgKiBmaWx0ZXJlZCBieSBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmc9fSBuYW1lICAgICAgICBMb3dlcmNhc2UgcHJvcGVydHkgbmFtZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgICAgVHJ1ZSwgd2hlbiBkZWxldGVkXG4gICAgICovXG4gICAgcmVtb3ZlQWxsUHJvcGVydGllczogZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIHJlbW92ZWQgPSB0aGlzLl9yZW1vdmVBbGxPYmplY3RzKFBST1BFUlRZX0lOREVYLCAnX3Byb3BlcnRpZXMnLCBuYW1lKTtcbiAgICAgIHRoaXMuX2h5ZHJhdGVkUHJvcGVydHlDb3VudCA9IDA7XG4gICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgY29tcG9uZW50LiBUaGUgcmV0dXJuZWQgb2JqZWN0XG4gICAgICogaXMgYSBsaXZlIGpDYWwgb2JqZWN0IGFuZCBzaG91bGQgYmUgY2xvbmVkIGlmIG1vZGlmaWVkLlxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT046IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuakNhbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbXBvbmVudC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIElDQUwuc3RyaW5naWZ5LmNvbXBvbmVudChcbiAgICAgICAgdGhpcy5qQ2FsLCB0aGlzLl9kZXNpZ25TZXRcbiAgICAgICk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4ge0BsaW5rIElDQUwuQ29tcG9uZW50fSBieSBwYXJzaW5nIHRoZSBwYXNzZWQgaUNhbGVuZGFyIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciAgICAgICAgVGhlIGlDYWxlbmRhciBzdHJpbmcgdG8gcGFyc2VcbiAgICovXG4gIENvbXBvbmVudC5mcm9tU3RyaW5nID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBDb21wb25lbnQoSUNBTC5wYXJzZS5jb21wb25lbnQoc3RyKSk7XG4gIH07XG5cbiAgcmV0dXJuIENvbXBvbmVudDtcbn0oKSk7XG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICogUG9ydGlvbnMgQ29weXJpZ2h0IChDKSBQaGlsaXBwIEtld2lzY2gsIDIwMTEtMjAxNSAqL1xuXG5cbi8qKlxuICogVGhpcyBzeW1ib2wgaXMgZnVydGhlciBkZXNjcmliZWQgbGF0ZXIgb25cbiAqIEBpZ25vcmVcbiAqL1xuSUNBTC5Qcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBOQU1FX0lOREVYID0gMDtcbiAgdmFyIFBST1BfSU5ERVggPSAxO1xuICB2YXIgVFlQRV9JTkRFWCA9IDI7XG4gIHZhciBWQUxVRV9JTkRFWCA9IDM7XG5cbiAgdmFyIGRlc2lnbiA9IElDQUwuZGVzaWduO1xuXG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIFByb3ZpZGVzIGEgbGF5ZXIgb24gdG9wIG9mIHRoZSByYXcgakNhbCBvYmplY3QgZm9yIG1hbmlwdWxhdGluZyBhIHNpbmdsZVxuICAgKiBwcm9wZXJ0eSwgd2l0aCBpdHMgcGFyYW1ldGVycyBhbmQgdmFsdWUuXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBJdCBpcyBpbXBvcnRhbnQgdG8gbm90ZSB0aGF0IG11dGF0aW9ucyBkb25lIGluIHRoZSB3cmFwcGVyXG4gICAqIGRpcmVjdGx5IG11dGF0ZSB0aGUgakNhbCBvYmplY3QgdXNlZCB0byBpbml0aWFsaXplLlxuICAgKlxuICAgKiBDYW4gYWxzbyBiZSB1c2VkIHRvIGNyZWF0ZSBuZXcgcHJvcGVydGllcyBieSBwYXNzaW5nXG4gICAqIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSAoYXMgYSBTdHJpbmcpLlxuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQGFsaWFzIElDQUwuUHJvcGVydHlcbiAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IGpDYWwgICAgICAgICBSYXcgakNhbCByZXByZXNlbnRhdGlvbiBPUlxuICAgKiAgdGhlIG5ldyBuYW1lIG9mIHRoZSBwcm9wZXJ0eVxuICAgKlxuICAgKiBAcGFyYW0ge0lDQUwuQ29tcG9uZW50PX0gcGFyZW50ICAgIFBhcmVudCBjb21wb25lbnRcbiAgICovXG4gIGZ1bmN0aW9uIFByb3BlcnR5KGpDYWwsIHBhcmVudCkge1xuICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudCB8fCBudWxsO1xuXG4gICAgaWYgKHR5cGVvZihqQ2FsKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFdlIGFyZSBjcmVhdGluZyB0aGUgcHJvcGVydHkgYnkgbmFtZSBhbmQgbmVlZCB0byBkZXRlY3QgdGhlIHR5cGVcbiAgICAgIHRoaXMuakNhbCA9IFtqQ2FsLCB7fSwgZGVzaWduLmRlZmF1bHRUeXBlXTtcbiAgICAgIHRoaXMuakNhbFtUWVBFX0lOREVYXSA9IHRoaXMuZ2V0RGVmYXVsdFR5cGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5qQ2FsID0gakNhbDtcbiAgICB9XG4gICAgdGhpcy5fdXBkYXRlVHlwZSgpO1xuICB9XG5cbiAgUHJvcGVydHkucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIHR5cGUgZm9yIHRoaXMgcHJvcGVydHlcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldCB0eXBlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuakNhbFtUWVBFX0lOREVYXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhpcyBwcm9wZXJ0eSwgaW4gbG93ZXJjYXNlLlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5qQ2FsW05BTUVfSU5ERVhdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgcGFyZW50IGNvbXBvbmVudCBmb3IgdGhpcyBwcm9wZXJ0eS5cbiAgICAgKiBAdHlwZSB7SUNBTC5Db21wb25lbnR9XG4gICAgICovXG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQ7XG4gICAgfSxcblxuICAgIHNldCBwYXJlbnQocCkge1xuICAgICAgLy8gQmVmb3JlIHNldHRpbmcgdGhlIHBhcmVudCwgY2hlY2sgaWYgdGhlIGRlc2lnbiBzZXQgaGFzIGNoYW5nZWQuIElmIGl0XG4gICAgICAvLyBoYXMsIHdlIGxhdGVyIG5lZWQgdG8gdXBkYXRlIHRoZSB0eXBlIGlmIGl0IHdhcyB1bmtub3duIGJlZm9yZS5cbiAgICAgIHZhciBkZXNpZ25TZXRDaGFuZ2VkID0gIXRoaXMuX3BhcmVudCB8fCAocCAmJiBwLl9kZXNpZ25TZXQgIT0gdGhpcy5fcGFyZW50Ll9kZXNpZ25TZXQpO1xuXG4gICAgICB0aGlzLl9wYXJlbnQgPSBwO1xuXG4gICAgICBpZiAodGhpcy50eXBlID09IGRlc2lnbi5kZWZhdWx0VHlwZSAmJiBkZXNpZ25TZXRDaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMuakNhbFtUWVBFX0lOREVYXSA9IHRoaXMuZ2V0RGVmYXVsdFR5cGUoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlVHlwZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGRlc2lnbiBzZXQgZm9yIHRoaXMgcHJvcGVydHksIGUuZy4gaWNhbGVuZGFyIHZzIHZjYXJkXG4gICAgICpcbiAgICAgKiBAdHlwZSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0IF9kZXNpZ25TZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5fZGVzaWduU2V0IDogZGVzaWduLmRlZmF1bHRTZXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHR5cGUgbWV0YWRhdGEgZnJvbSB0aGUgY3VycmVudCBqQ2FsIHR5cGUgYW5kIGRlc2lnbiBzZXQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVUeXBlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkZXNpZ25TZXQgPSB0aGlzLl9kZXNpZ25TZXQ7XG5cbiAgICAgIGlmICh0aGlzLnR5cGUgaW4gZGVzaWduU2V0LnZhbHVlKSB7XG4gICAgICAgIHZhciBkZXNpZ25UeXBlID0gZGVzaWduU2V0LnZhbHVlW3RoaXMudHlwZV07XG5cbiAgICAgICAgaWYgKCdkZWNvcmF0ZScgaW4gZGVzaWduU2V0LnZhbHVlW3RoaXMudHlwZV0pIHtcbiAgICAgICAgICB0aGlzLmlzRGVjb3JhdGVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmlzRGVjb3JhdGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5uYW1lIGluIGRlc2lnblNldC5wcm9wZXJ0eSkge1xuICAgICAgICAgIHRoaXMuaXNNdWx0aVZhbHVlID0gKCdtdWx0aVZhbHVlJyBpbiBkZXNpZ25TZXQucHJvcGVydHlbdGhpcy5uYW1lXSk7XG4gICAgICAgICAgdGhpcy5pc1N0cnVjdHVyZWRWYWx1ZSA9ICgnc3RydWN0dXJlZFZhbHVlJyBpbiBkZXNpZ25TZXQucHJvcGVydHlbdGhpcy5uYW1lXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSHlkcmF0ZSBhIHNpbmdsZSB2YWx1ZS4gVGhlIGFjdCBvZiBoeWRyYXRpbmcgbWVhbnMgdHVybmluZyB0aGUgcmF3IGpDYWxcbiAgICAgKiB2YWx1ZSBpbnRvIGEgcG90ZW50aWFsbHkgd3JhcHBlZCBvYmplY3QsIGZvciBleGFtcGxlIHtAbGluayBJQ0FMLlRpbWV9LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggICAgICAgIFRoZSBpbmRleCBvZiB0aGUgdmFsdWUgdG8gaHlkcmF0ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgVGhlIGRlY29yYXRlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBfaHlkcmF0ZVZhbHVlOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgaWYgKHRoaXMuX3ZhbHVlcyAmJiB0aGlzLl92YWx1ZXNbaW5kZXhdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZXNbaW5kZXhdO1xuICAgICAgfVxuXG4gICAgICAvLyBmb3IgdGhlIGNhc2Ugd2hlcmUgdGhlcmUgaXMgbm8gdmFsdWUuXG4gICAgICBpZiAodGhpcy5qQ2FsLmxlbmd0aCA8PSAoVkFMVUVfSU5ERVggKyBpbmRleCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmlzRGVjb3JhdGVkKSB7XG4gICAgICAgIGlmICghdGhpcy5fdmFsdWVzKSB7XG4gICAgICAgICAgdGhpcy5fdmFsdWVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0aGlzLl92YWx1ZXNbaW5kZXhdID0gdGhpcy5fZGVjb3JhdGUoXG4gICAgICAgICAgdGhpcy5qQ2FsW1ZBTFVFX0lOREVYICsgaW5kZXhdXG4gICAgICAgICkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuakNhbFtWQUxVRV9JTkRFWCArIGluZGV4XTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVjb3JhdGUgYSBzaW5nbGUgdmFsdWUsIHJldHVybmluZyBpdHMgd3JhcHBlZCBvYmplY3QuIFRoaXMgaXMgdXNlZCBieVxuICAgICAqIHRoZSBoeWRyYXRlIGZ1bmN0aW9uIHRvIGFjdHVhbGx5IHdyYXAgdGhlIHZhbHVlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlICAgICAgICAgVGhlIHZhbHVlIHRvIGRlY29yYXRlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgIFRoZSBkZWNvcmF0ZWQgdmFsdWVcbiAgICAgKi9cbiAgICBfZGVjb3JhdGU6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGVzaWduU2V0LnZhbHVlW3RoaXMudHlwZV0uZGVjb3JhdGUodmFsdWUsIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbmRlY29yYXRlIGEgc2luZ2xlIHZhbHVlLCByZXR1cm5pbmcgaXRzIHJhdyBqQ2FsIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSAgICAgICAgIFRoZSB2YWx1ZSB0byB1bmRlY29yYXRlXG4gICAgICogQHJldHVybiB7P30gICAgICAgICAgICAgICAgICAgVGhlIHVuZGVjb3JhdGVkIHZhbHVlXG4gICAgICovXG4gICAgX3VuZGVjb3JhdGU6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGVzaWduU2V0LnZhbHVlW3RoaXMudHlwZV0udW5kZWNvcmF0ZSh2YWx1ZSwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlIGF0IHRoZSBnaXZlbiBpbmRleCB3aGlsZSBhbHNvIGh5ZHJhdGluZyBpdC4gVGhlIHBhc3NlZFxuICAgICAqIHZhbHVlIGNhbiBlaXRoZXIgYmUgYSBkZWNvcmF0ZWQgb3IgdW5kZWNvcmF0ZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWUgICAgICAgICAgICAgVGhlIHZhbHVlIHRvIHNldFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAgICAgICAgVGhlIGluZGV4IHRvIHNldCBpdCBhdFxuICAgICAqL1xuICAgIF9zZXREZWNvcmF0ZWRWYWx1ZTogZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgICBpZiAoIXRoaXMuX3ZhbHVlcykge1xuICAgICAgICB0aGlzLl92YWx1ZXMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZih2YWx1ZSkgPT09ICdvYmplY3QnICYmICdpY2FsdHlwZScgaW4gdmFsdWUpIHtcbiAgICAgICAgLy8gZGVjb3JhdGVkIHZhbHVlXG4gICAgICAgIHRoaXMuakNhbFtWQUxVRV9JTkRFWCArIGluZGV4XSA9IHRoaXMuX3VuZGVjb3JhdGUodmFsdWUpO1xuICAgICAgICB0aGlzLl92YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1bmRlY29yYXRlZCB2YWx1ZVxuICAgICAgICB0aGlzLmpDYWxbVkFMVUVfSU5ERVggKyBpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fdmFsdWVzW2luZGV4XSA9IHRoaXMuX2RlY29yYXRlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIHBhcmFtZXRlciBvbiB0aGUgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICAgICAgIG5hbWUgICBQYXJhbWV0ZXIgbmFtZSAobG93ZXJjYXNlKVxuICAgICAqIEByZXR1cm4ge0FycmF5fFN0cmluZ30gICAgICAgIFBhcmFtZXRlciB2YWx1ZVxuICAgICAqL1xuICAgIGdldFBhcmFtZXRlcjogZnVuY3Rpb24obmFtZSkge1xuICAgICAgaWYgKG5hbWUgaW4gdGhpcy5qQ2FsW1BST1BfSU5ERVhdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmpDYWxbUFJPUF9JTkRFWF1bbmFtZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGZpcnN0IHBhcmFtZXRlciBvbiB0aGUgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICAgICAgIG5hbWUgICBQYXJhbWV0ZXIgbmFtZSAobG93ZXJjYXNlKVxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgIFBhcmFtZXRlciB2YWx1ZVxuICAgICAqL1xuICAgIGdldEZpcnN0UGFyYW1ldGVyOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgcGFyYW1ldGVycyA9IHRoaXMuZ2V0UGFyYW1ldGVyKG5hbWUpO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbWV0ZXJzKSkge1xuICAgICAgICByZXR1cm4gcGFyYW1ldGVyc1swXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcmFtZXRlcnM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgYSBwYXJhbWV0ZXIgb24gdGhlIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgICAgIG5hbWUgICAgIFRoZSBwYXJhbWV0ZXIgbmFtZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSB2YWx1ZSAgICBUaGUgcGFyYW1ldGVyIHZhbHVlXG4gICAgICovXG4gICAgc2V0UGFyYW1ldGVyOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIGxjbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICBsY25hbWUgaW4gdGhpcy5fZGVzaWduU2V0LnBhcmFtICYmXG4gICAgICAgICAgJ211bHRpVmFsdWUnIGluIHRoaXMuX2Rlc2lnblNldC5wYXJhbVtsY25hbWVdKSB7XG4gICAgICAgICAgdmFsdWUgPSBbdmFsdWVdO1xuICAgICAgfVxuICAgICAgdGhpcy5qQ2FsW1BST1BfSU5ERVhdW25hbWVdID0gdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBwYXJhbWV0ZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lICAgICBUaGUgcGFyYW1ldGVyIG5hbWVcbiAgICAgKi9cbiAgICByZW1vdmVQYXJhbWV0ZXI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmpDYWxbUFJPUF9JTkRFWF1bbmFtZV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZGVmYXVsdCB0eXBlIGJhc2VkIG9uIHRoaXMgcHJvcGVydHkncyBuYW1lLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgVGhlIGRlZmF1bHQgdHlwZSBmb3IgdGhpcyBwcm9wZXJ0eVxuICAgICAqL1xuICAgIGdldERlZmF1bHRUeXBlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBuYW1lID0gdGhpcy5qQ2FsW05BTUVfSU5ERVhdO1xuICAgICAgdmFyIGRlc2lnblNldCA9IHRoaXMuX2Rlc2lnblNldDtcblxuICAgICAgaWYgKG5hbWUgaW4gZGVzaWduU2V0LnByb3BlcnR5KSB7XG4gICAgICAgIHZhciBkZXRhaWxzID0gZGVzaWduU2V0LnByb3BlcnR5W25hbWVdO1xuICAgICAgICBpZiAoJ2RlZmF1bHRUeXBlJyBpbiBkZXRhaWxzKSB7XG4gICAgICAgICAgcmV0dXJuIGRldGFpbHMuZGVmYXVsdFR5cGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXNpZ24uZGVmYXVsdFR5cGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdHlwZSBvZiBwcm9wZXJ0eSBhbmQgY2xlYXJzIG91dCBhbnkgZXhpc3RpbmcgdmFsdWVzIG9mIHRoZSBjdXJyZW50XG4gICAgICogdHlwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlICAgICBOZXcgaUNBTCB0eXBlIChzZWUgZGVzaWduLioudmFsdWVzKVxuICAgICAqL1xuICAgIHJlc2V0VHlwZTogZnVuY3Rpb24odHlwZSkge1xuICAgICAgdGhpcy5yZW1vdmVBbGxWYWx1ZXMoKTtcbiAgICAgIHRoaXMuakNhbFtUWVBFX0lOREVYXSA9IHR5cGU7XG4gICAgICB0aGlzLl91cGRhdGVUeXBlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBmaXJzdCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICBGaXJzdCBwcm9wZXJ0eSB2YWx1ZVxuICAgICAqL1xuICAgIGdldEZpcnN0VmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2h5ZHJhdGVWYWx1ZSgwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgdmFsdWVzIG9uIHRoZSBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIE5PVEU6IHRoaXMgY3JlYXRlcyBhbiBhcnJheSBkdXJpbmcgZWFjaCBjYWxsLlxuICAgICAqXG4gICAgICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgIExpc3Qgb2YgdmFsdWVzXG4gICAgICovXG4gICAgZ2V0VmFsdWVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsZW4gPSB0aGlzLmpDYWwubGVuZ3RoIC0gVkFMVUVfSU5ERVg7XG5cbiAgICAgIGlmIChsZW4gPCAxKSB7XG4gICAgICAgIC8vIGl0IGlzIHBvc3NpYmxlIGZvciBhIHByb3BlcnR5IHRvIGhhdmUgbm8gdmFsdWUuXG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHJlc3VsdFtpXSA9IHRoaXMuX2h5ZHJhdGVWYWx1ZShpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgdmFsdWVzIGZyb20gdGhpcyBwcm9wZXJ0eVxuICAgICAqL1xuICAgIHJlbW92ZUFsbFZhbHVlczogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5fdmFsdWVzKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlcy5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgICAgdGhpcy5qQ2FsLmxlbmd0aCA9IDM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlcyBvZiB0aGUgcHJvcGVydHkuICBXaWxsIG92ZXJ3cml0ZSB0aGUgZXhpc3RpbmcgdmFsdWVzLlxuICAgICAqIFRoaXMgY2FuIG9ubHkgYmUgdXNlZCBmb3IgbXVsdGktdmFsdWUgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyAgICBBbiBhcnJheSBvZiB2YWx1ZXNcbiAgICAgKi9cbiAgICBzZXRWYWx1ZXM6IGZ1bmN0aW9uKHZhbHVlcykge1xuICAgICAgaWYgKCF0aGlzLmlzTXVsdGlWYWx1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgdGhpcy5uYW1lICsgJzogZG9lcyBub3Qgbm90IHN1cHBvcnQgbXVsaXRWYWx1ZS5cXG4nICtcbiAgICAgICAgICAnb3ZlcnJpZGUgaXNNdWx0aVZhbHVlJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuID0gdmFsdWVzLmxlbmd0aDtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHRoaXMucmVtb3ZlQWxsVmFsdWVzKCk7XG5cbiAgICAgIGlmIChsZW4gPiAwICYmXG4gICAgICAgICAgdHlwZW9mKHZhbHVlc1swXSkgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgJ2ljYWx0eXBlJyBpbiB2YWx1ZXNbMF0pIHtcbiAgICAgICAgdGhpcy5yZXNldFR5cGUodmFsdWVzWzBdLmljYWx0eXBlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNEZWNvcmF0ZWQpIHtcbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHRoaXMuX3NldERlY29yYXRlZFZhbHVlKHZhbHVlc1tpXSwgaSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICB0aGlzLmpDYWxbVkFMVUVfSU5ERVggKyBpXSA9IHZhbHVlc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBwcm9wZXJ0eS4gSWYgdGhpcyBpcyBhIG11bHRpLXZhbHVlXG4gICAgICogcHJvcGVydHksIGFsbCBvdGhlciB2YWx1ZXMgd2lsbCBiZSByZW1vdmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSB2YWx1ZSAgICAgTmV3IHByb3BlcnR5IHZhbHVlLlxuICAgICAqL1xuICAgIHNldFZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdGhpcy5yZW1vdmVBbGxWYWx1ZXMoKTtcbiAgICAgIGlmICh0eXBlb2YodmFsdWUpID09PSAnb2JqZWN0JyAmJiAnaWNhbHR5cGUnIGluIHZhbHVlKSB7XG4gICAgICAgIHRoaXMucmVzZXRUeXBlKHZhbHVlLmljYWx0eXBlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNEZWNvcmF0ZWQpIHtcbiAgICAgICAgdGhpcy5fc2V0RGVjb3JhdGVkVmFsdWUodmFsdWUsIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5qQ2FsW1ZBTFVFX0lOREVYXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBjb21wb25lbnQuIFRoZSByZXR1cm5lZCBvYmplY3RcbiAgICAgKiBpcyBhIGxpdmUgakNhbCBvYmplY3QgYW5kIHNob3VsZCBiZSBjbG9uZWQgaWYgbW9kaWZpZWQuXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5qQ2FsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgY29tcG9uZW50LlxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICB0b0lDQUxTdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIElDQUwuc3RyaW5naWZ5LnByb3BlcnR5KFxuICAgICAgICB0aGlzLmpDYWwsIHRoaXMuX2Rlc2lnblNldCwgdHJ1ZVxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiB7QGxpbmsgSUNBTC5Qcm9wZXJ0eX0gYnkgcGFyc2luZyB0aGUgcGFzc2VkIGlDYWxlbmRhciBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgICAgICAgICAgICAgICAgICAgICAgICBUaGUgaUNhbGVuZGFyIHN0cmluZyB0byBwYXJzZVxuICAgKiBAcGFyYW0ge0lDQUwuZGVzaWduLmRlc2lnblNldD19IGRlc2lnblNldCAgVGhlIGRlc2lnbiBkYXRhIHRvIHVzZSBmb3IgdGhpcyBwcm9wZXJ0eVxuICAgKiBAcmV0dXJuIHtJQ0FMLlByb3BlcnR5fSAgICAgICAgICAgICAgICAgICAgVGhlIGNyZWF0ZWQgaUNhbGVuZGFyIHByb3BlcnR5XG4gICAqL1xuICBQcm9wZXJ0eS5mcm9tU3RyaW5nID0gZnVuY3Rpb24oc3RyLCBkZXNpZ25TZXQpIHtcbiAgICByZXR1cm4gbmV3IFByb3BlcnR5KElDQUwucGFyc2UucHJvcGVydHkoc3RyLCBkZXNpZ25TZXQpKTtcbiAgfTtcblxuICByZXR1cm4gUHJvcGVydHk7XG59KCkpO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoLCAyMDExLTIwMTUgKi9cblxuXG4vKipcbiAqIFRoaXMgc3ltYm9sIGlzIGZ1cnRoZXIgZGVzY3JpYmVkIGxhdGVyIG9uXG4gKiBAaWdub3JlXG4gKi9cbklDQUwuVXRjT2Zmc2V0ID0gKGZ1bmN0aW9uKCkge1xuXG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIFRoaXMgY2xhc3MgcmVwcmVzZW50cyB0aGUgXCJkdXJhdGlvblwiIHZhbHVlIHR5cGUsIHdpdGggdmFyaW91cyBjYWxjdWxhdGlvblxuICAgKiBhbmQgbWFuaXB1bGF0aW9uIG1ldGhvZHMuXG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAYWxpYXMgSUNBTC5VdGNPZmZzZXRcbiAgICogQHBhcmFtIHtPYmplY3R9IGFEYXRhICAgICAgICAgIEFuIG9iamVjdCB3aXRoIG1lbWJlcnMgb2YgdGhlIHV0YyBvZmZzZXRcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5ob3VycyAgIFRoZSBob3VycyBmb3IgdGhlIHV0YyBvZmZzZXRcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5taW51dGVzIFRoZSBtaW51dGVzIGluIHRoZSB1dGMgb2Zmc2V0XG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEuZmFjdG9yICBUaGUgZmFjdG9yIGZvciB0aGUgdXRjLW9mZnNldCwgZWl0aGVyIC0xIG9yIDFcbiAgICovXG4gIGZ1bmN0aW9uIFV0Y09mZnNldChhRGF0YSkge1xuICAgIHRoaXMuZnJvbURhdGEoYURhdGEpO1xuICB9XG5cbiAgVXRjT2Zmc2V0LnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIFRoZSBob3VycyBpbiB0aGUgdXRjLW9mZnNldFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgaG91cnM6IDAsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWludXRlcyBpbiB0aGUgdXRjLW9mZnNldFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgbWludXRlczogMCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzaWduIG9mIHRoZSB1dGMgb2Zmc2V0LCAxIGZvciBwb3NpdGl2ZSBvZmZzZXQsIC0xIGZvciBuZWdhdGl2ZVxuICAgICAqIG9mZnNldHMuXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBmYWN0b3I6IDEsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBuYW1lLCB0byBiZSB1c2VkIGluIHRoZSBqQ2FsIG9iamVjdC5cbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IFwidXRjLW9mZnNldFwiXG4gICAgICovXG4gICAgaWNhbHR5cGU6IFwidXRjLW9mZnNldFwiLFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSB1dGMgb2Zmc2V0IG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0lDQUwuVXRjT2Zmc2V0fSAgICAgVGhlIGNsb25lZCBvYmplY3RcbiAgICAgKi9cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gSUNBTC5VdGNPZmZzZXQuZnJvbVNlY29uZHModGhpcy50b1NlY29uZHMoKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdXAgdGhlIGN1cnJlbnQgaW5zdGFuY2UgdXNpbmcgbWVtYmVycyBmcm9tIHRoZSBwYXNzZWQgZGF0YSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYURhdGEgICAgICAgICAgQW4gb2JqZWN0IHdpdGggbWVtYmVycyBvZiB0aGUgdXRjIG9mZnNldFxuICAgICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEuaG91cnMgICBUaGUgaG91cnMgZm9yIHRoZSB1dGMgb2Zmc2V0XG4gICAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5taW51dGVzIFRoZSBtaW51dGVzIGluIHRoZSB1dGMgb2Zmc2V0XG4gICAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5mYWN0b3IgIFRoZSBmYWN0b3IgZm9yIHRoZSB1dGMtb2Zmc2V0LCBlaXRoZXIgLTEgb3IgMVxuICAgICAqL1xuICAgIGZyb21EYXRhOiBmdW5jdGlvbihhRGF0YSkge1xuICAgICAgaWYgKGFEYXRhKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBhRGF0YSkge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgaWYgKGFEYXRhLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIHRoaXNba2V5XSA9IGFEYXRhW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9ub3JtYWxpemUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB1cCB0aGUgY3VycmVudCBpbnN0YW5jZSBmcm9tIHRoZSBnaXZlbiBzZWNvbmRzIHZhbHVlLiBUaGUgc2Vjb25kc1xuICAgICAqIHZhbHVlIGlzIHRydW5jYXRlZCB0byB0aGUgbWludXRlLiBPZmZzZXRzIGFyZSB3cmFwcGVkIHdoZW4gdGhlIHdvcmxkXG4gICAgICogZW5kcywgdGhlIGhvdXIgYWZ0ZXIgVVRDKzE0OjAwIGlzIFVUQy0xMjowMC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhU2Vjb25kcyAgICAgICAgIFRoZSBzZWNvbmRzIHRvIGNvbnZlcnQgaW50byBhbiBvZmZzZXRcbiAgICAgKi9cbiAgICBmcm9tU2Vjb25kczogZnVuY3Rpb24oYVNlY29uZHMpIHtcbiAgICAgIHZhciBzZWNzID0gTWF0aC5hYnMoYVNlY29uZHMpO1xuXG4gICAgICB0aGlzLmZhY3RvciA9IGFTZWNvbmRzIDwgMCA/IC0xIDogMTtcbiAgICAgIHRoaXMuaG91cnMgPSBJQ0FMLmhlbHBlcnMudHJ1bmMoc2VjcyAvIDM2MDApO1xuXG4gICAgICBzZWNzIC09ICh0aGlzLmhvdXJzICogMzYwMCk7XG4gICAgICB0aGlzLm1pbnV0ZXMgPSBJQ0FMLmhlbHBlcnMudHJ1bmMoc2VjcyAvIDYwKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBjdXJyZW50IG9mZnNldCB0byBhIHZhbHVlIGluIHNlY29uZHNcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgICAgIFRoZSBvZmZzZXQgaW4gc2Vjb25kc1xuICAgICAqL1xuICAgIHRvU2Vjb25kczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5mYWN0b3IgKiAoNjAgKiB0aGlzLm1pbnV0ZXMgKyAzNjAwICogdGhpcy5ob3Vycyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbXBhcmUgdGhpcyB1dGMgb2Zmc2V0IHdpdGggYW5vdGhlciBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuVXRjT2Zmc2V0fSBvdGhlciAgICAgICAgVGhlIG90aGVyIG9mZnNldCB0byBjb21wYXJlIHdpdGhcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgICAgICAgICAgLTEsIDAgb3IgMSBmb3IgbGVzcy9lcXVhbC9ncmVhdGVyXG4gICAgICovXG4gICAgY29tcGFyZTogZnVuY3Rpb24gaWNhbHRpbWVfY29tcGFyZShvdGhlcikge1xuICAgICAgdmFyIGEgPSB0aGlzLnRvU2Vjb25kcygpO1xuICAgICAgdmFyIGIgPSBvdGhlci50b1NlY29uZHMoKTtcbiAgICAgIHJldHVybiAoYSA+IGIpIC0gKGIgPiBhKTtcbiAgICB9LFxuXG4gICAgX25vcm1hbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBSYW5nZTogOTcyMDAgc2Vjb25kcyAod2l0aCAxIGhvdXIgaW5iZXR3ZWVuKVxuICAgICAgdmFyIHNlY3MgPSB0aGlzLnRvU2Vjb25kcygpO1xuICAgICAgdmFyIGZhY3RvciA9IHRoaXMuZmFjdG9yO1xuICAgICAgd2hpbGUgKHNlY3MgPCAtNDMyMDApIHsgLy8gPSBVVEMtMTI6MDBcbiAgICAgICAgc2VjcyArPSA5NzIwMDtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChzZWNzID4gNTA0MDApIHsgLy8gPSBVVEMrMTQ6MDBcbiAgICAgICAgc2VjcyAtPSA5NzIwMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5mcm9tU2Vjb25kcyhzZWNzKTtcblxuICAgICAgLy8gQXZvaWQgY2hhbmdpbmcgdGhlIGZhY3RvciB3aGVuIG9uIHplcm8gc2Vjb25kc1xuICAgICAgaWYgKHNlY3MgPT0gMCkge1xuICAgICAgICB0aGlzLmZhY3RvciA9IGZhY3RvcjtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGlDYWxlbmRhciBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB1dGMtb2Zmc2V0LlxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICB0b0lDQUxTdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIElDQUwuZGVzaWduLmljYWxlbmRhci52YWx1ZVsndXRjLW9mZnNldCddLnRvSUNBTCh0aGlzLnRvU3RyaW5nKCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdXRjLW9mZnNldC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICh0aGlzLmZhY3RvciA9PSAxID8gXCIrXCIgOiBcIi1cIikgK1xuICAgICAgICAgICAgICBJQ0FMLmhlbHBlcnMucGFkMih0aGlzLmhvdXJzKSArICc6JyArXG4gICAgICAgICAgICAgIElDQUwuaGVscGVycy5wYWQyKHRoaXMubWludXRlcyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBJQ0FMLlV0Y09mZnNldH0gaW5zdGFuY2UgZnJvbSB0aGUgcGFzc2VkIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFTdHJpbmcgICAgVGhlIHN0cmluZyB0byBwYXJzZVxuICAgKiBAcmV0dXJuIHtJQ0FMLkR1cmF0aW9ufSAgICBUaGUgY3JlYXRlZCB1dGMtb2Zmc2V0IGluc3RhbmNlXG4gICAqL1xuICBVdGNPZmZzZXQuZnJvbVN0cmluZyA9IGZ1bmN0aW9uKGFTdHJpbmcpIHtcbiAgICAvLyAtMDU6MDBcbiAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgIC8vVE9ETzogc3VwcG9ydCBzZWNvbmRzIHBlciByZmM1NTQ1ID9cbiAgICBvcHRpb25zLmZhY3RvciA9IChhU3RyaW5nWzBdID09PSAnKycpID8gMSA6IC0xO1xuICAgIG9wdGlvbnMuaG91cnMgPSBJQ0FMLmhlbHBlcnMuc3RyaWN0UGFyc2VJbnQoYVN0cmluZy5zdWJzdHIoMSwgMikpO1xuICAgIG9wdGlvbnMubWludXRlcyA9IElDQUwuaGVscGVycy5zdHJpY3RQYXJzZUludChhU3RyaW5nLnN1YnN0cig0LCAyKSk7XG5cbiAgICByZXR1cm4gbmV3IElDQUwuVXRjT2Zmc2V0KG9wdGlvbnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBJQ0FMLlV0Y09mZnNldH0gaW5zdGFuY2UgZnJvbSB0aGUgcGFzc2VkIHNlY29uZHNcbiAgICogdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhU2Vjb25kcyAgICAgICBUaGUgbnVtYmVyIG9mIHNlY29uZHMgdG8gY29udmVydFxuICAgKi9cbiAgVXRjT2Zmc2V0LmZyb21TZWNvbmRzID0gZnVuY3Rpb24oYVNlY29uZHMpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBuZXcgVXRjT2Zmc2V0KCk7XG4gICAgaW5zdGFuY2UuZnJvbVNlY29uZHMoYVNlY29uZHMpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcblxuICByZXR1cm4gVXRjT2Zmc2V0O1xufSgpKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAxMS0yMDE1ICovXG5cblxuLyoqXG4gKiBUaGlzIHN5bWJvbCBpcyBmdXJ0aGVyIGRlc2NyaWJlZCBsYXRlciBvblxuICogQGlnbm9yZVxuICovXG5JQ0FMLkJpbmFyeSA9IChmdW5jdGlvbigpIHtcblxuICAvKipcbiAgICogQGNsYXNzZGVzY1xuICAgKiBSZXByZXNlbnRzIHRoZSBCSU5BUlkgdmFsdWUgdHlwZSwgd2hpY2ggY29udGFpbnMgZXh0cmEgbWV0aG9kcyBmb3JcbiAgICogZW5jb2RpbmcgYW5kIGRlY29kaW5nLlxuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQGFsaWFzIElDQUwuQmluYXJ5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhVmFsdWUgICAgIFRoZSBiaW5hcnkgZGF0YSBmb3IgdGhpcyB2YWx1ZVxuICAgKi9cbiAgZnVuY3Rpb24gQmluYXJ5KGFWYWx1ZSkge1xuICAgIHRoaXMudmFsdWUgPSBhVmFsdWU7XG4gIH1cblxuICBCaW5hcnkucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG5hbWUsIHRvIGJlIHVzZWQgaW4gdGhlIGpDYWwgb2JqZWN0LlxuICAgICAqIEBkZWZhdWx0IFwiYmluYXJ5XCJcbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKi9cbiAgICBpY2FsdHlwZTogXCJiaW5hcnlcIixcblxuICAgIC8qKlxuICAgICAqIEJhc2U2NCBkZWNvZGUgdGhlIGN1cnJlbnQgdmFsdWVcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICBUaGUgYmFzZTY0LWRlY29kZWQgdmFsdWVcbiAgICAgKi9cbiAgICBkZWNvZGVWYWx1ZTogZnVuY3Rpb24gZGVjb2RlVmFsdWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYjY0X2RlY29kZSh0aGlzLnZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRW5jb2RlcyB0aGUgcGFzc2VkIHBhcmFtZXRlciB3aXRoIGJhc2U2NCBhbmQgc2V0cyB0aGUgaW50ZXJuYWxcbiAgICAgKiB2YWx1ZSB0byB0aGUgcmVzdWx0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFWYWx1ZSAgICAgIFRoZSByYXcgYmluYXJ5IHZhbHVlIHRvIGVuY29kZVxuICAgICAqL1xuICAgIHNldEVuY29kZWRWYWx1ZTogZnVuY3Rpb24gc2V0RW5jb2RlZFZhbHVlKGFWYWx1ZSkge1xuICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuX2I2NF9lbmNvZGUoYVZhbHVlKTtcbiAgICB9LFxuXG4gICAgX2I2NF9lbmNvZGU6IGZ1bmN0aW9uIGJhc2U2NF9lbmNvZGUoZGF0YSkge1xuICAgICAgLy8gaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXRcbiAgICAgIC8vICsgICBvcmlnaW5hbCBieTogVHlsZXIgQWtpbnMgKGh0dHA6Ly9ydW1raW4uY29tKVxuICAgICAgLy8gKyAgIGltcHJvdmVkIGJ5OiBCYXlyb24gR3VldmFyYVxuICAgICAgLy8gKyAgIGltcHJvdmVkIGJ5OiBUaHVuZGVyLm1cbiAgICAgIC8vICsgICBpbXByb3ZlZCBieTogS2V2aW4gdmFuIFpvbm5ldmVsZCAoaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXQpXG4gICAgICAvLyArICAgYnVnZml4ZWQgYnk6IFBlbGxlbnRlc3F1ZSBNYWxlc3VhZGFcbiAgICAgIC8vICsgICBpbXByb3ZlZCBieTogS2V2aW4gdmFuIFpvbm5ldmVsZCAoaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXQpXG4gICAgICAvLyArICAgaW1wcm92ZWQgYnk6IFJhZmFcdTAxNDIgS3VrYXdza2kgKGh0dHA6Ly9rdWthd3NraS5wbClcbiAgICAgIC8vICogICAgIGV4YW1wbGUgMTogYmFzZTY0X2VuY29kZSgnS2V2aW4gdmFuIFpvbm5ldmVsZCcpO1xuICAgICAgLy8gKiAgICAgcmV0dXJucyAxOiAnUzJWMmFXNGdkbUZ1SUZwdmJtNWxkbVZzWkE9PSdcbiAgICAgIC8vIG1vemlsbGEgaGFzIHRoaXMgbmF0aXZlXG4gICAgICAvLyAtIGJ1dCBicmVha3MgaW4gMi4wLjAuMTIhXG4gICAgICAvL2lmICh0eXBlb2YgdGhpcy53aW5kb3dbJ2F0b2InXSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyAgICByZXR1cm4gYXRvYihkYXRhKTtcbiAgICAgIC8vfVxuICAgICAgdmFyIGI2NCA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpcIiArXG4gICAgICAgICAgICAgICAgXCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cIjtcbiAgICAgIHZhciBvMSwgbzIsIG8zLCBoMSwgaDIsIGgzLCBoNCwgYml0cywgaSA9IDAsXG4gICAgICAgIGFjID0gMCxcbiAgICAgICAgZW5jID0gXCJcIixcbiAgICAgICAgdG1wX2FyciA9IFtdO1xuXG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9XG5cbiAgICAgIGRvIHsgLy8gcGFjayB0aHJlZSBvY3RldHMgaW50byBmb3VyIGhleGV0c1xuICAgICAgICBvMSA9IGRhdGEuY2hhckNvZGVBdChpKyspO1xuICAgICAgICBvMiA9IGRhdGEuY2hhckNvZGVBdChpKyspO1xuICAgICAgICBvMyA9IGRhdGEuY2hhckNvZGVBdChpKyspO1xuXG4gICAgICAgIGJpdHMgPSBvMSA8PCAxNiB8IG8yIDw8IDggfCBvMztcblxuICAgICAgICBoMSA9IGJpdHMgPj4gMTggJiAweDNmO1xuICAgICAgICBoMiA9IGJpdHMgPj4gMTIgJiAweDNmO1xuICAgICAgICBoMyA9IGJpdHMgPj4gNiAmIDB4M2Y7XG4gICAgICAgIGg0ID0gYml0cyAmIDB4M2Y7XG5cbiAgICAgICAgLy8gdXNlIGhleGV0cyB0byBpbmRleCBpbnRvIGI2NCwgYW5kIGFwcGVuZCByZXN1bHQgdG8gZW5jb2RlZCBzdHJpbmdcbiAgICAgICAgdG1wX2FyclthYysrXSA9IGI2NC5jaGFyQXQoaDEpICsgYjY0LmNoYXJBdChoMikgKyBiNjQuY2hhckF0KGgzKSArIGI2NC5jaGFyQXQoaDQpO1xuICAgICAgfSB3aGlsZSAoaSA8IGRhdGEubGVuZ3RoKTtcblxuICAgICAgZW5jID0gdG1wX2Fyci5qb2luKCcnKTtcblxuICAgICAgdmFyIHIgPSBkYXRhLmxlbmd0aCAlIDM7XG5cbiAgICAgIHJldHVybiAociA/IGVuYy5zbGljZSgwLCByIC0gMykgOiBlbmMpICsgJz09PScuc2xpY2UociB8fCAzKTtcblxuICAgIH0sXG5cbiAgICBfYjY0X2RlY29kZTogZnVuY3Rpb24gYmFzZTY0X2RlY29kZShkYXRhKSB7XG4gICAgICAvLyBodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldFxuICAgICAgLy8gKyAgIG9yaWdpbmFsIGJ5OiBUeWxlciBBa2lucyAoaHR0cDovL3J1bWtpbi5jb20pXG4gICAgICAvLyArICAgaW1wcm92ZWQgYnk6IFRodW5kZXIubVxuICAgICAgLy8gKyAgICAgIGlucHV0IGJ5OiBBbWFuIEd1cHRhXG4gICAgICAvLyArICAgaW1wcm92ZWQgYnk6IEtldmluIHZhbiBab25uZXZlbGQgKGh0dHA6Ly9rZXZpbi52YW56b25uZXZlbGQubmV0KVxuICAgICAgLy8gKyAgIGJ1Z2ZpeGVkIGJ5OiBPbm5vIE1hcnNtYW5cbiAgICAgIC8vICsgICBidWdmaXhlZCBieTogUGVsbGVudGVzcXVlIE1hbGVzdWFkYVxuICAgICAgLy8gKyAgIGltcHJvdmVkIGJ5OiBLZXZpbiB2YW4gWm9ubmV2ZWxkIChodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldClcbiAgICAgIC8vICsgICAgICBpbnB1dCBieTogQnJldHQgWmFtaXIgKGh0dHA6Ly9icmV0dC16YW1pci5tZSlcbiAgICAgIC8vICsgICBidWdmaXhlZCBieTogS2V2aW4gdmFuIFpvbm5ldmVsZCAoaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXQpXG4gICAgICAvLyAqICAgICBleGFtcGxlIDE6IGJhc2U2NF9kZWNvZGUoJ1MyVjJhVzRnZG1GdUlGcHZibTVsZG1Wc1pBPT0nKTtcbiAgICAgIC8vICogICAgIHJldHVybnMgMTogJ0tldmluIHZhbiBab25uZXZlbGQnXG4gICAgICAvLyBtb3ppbGxhIGhhcyB0aGlzIG5hdGl2ZVxuICAgICAgLy8gLSBidXQgYnJlYWtzIGluIDIuMC4wLjEyIVxuICAgICAgLy9pZiAodHlwZW9mIHRoaXMud2luZG93WydidG9hJ10gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gICAgcmV0dXJuIGJ0b2EoZGF0YSk7XG4gICAgICAvL31cbiAgICAgIHZhciBiNjQgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXCIgK1xuICAgICAgICAgICAgICAgIFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCI7XG4gICAgICB2YXIgbzEsIG8yLCBvMywgaDEsIGgyLCBoMywgaDQsIGJpdHMsIGkgPSAwLFxuICAgICAgICBhYyA9IDAsXG4gICAgICAgIGRlYyA9IFwiXCIsXG4gICAgICAgIHRtcF9hcnIgPSBbXTtcblxuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuXG4gICAgICBkYXRhICs9ICcnO1xuXG4gICAgICBkbyB7IC8vIHVucGFjayBmb3VyIGhleGV0cyBpbnRvIHRocmVlIG9jdGV0cyB1c2luZyBpbmRleCBwb2ludHMgaW4gYjY0XG4gICAgICAgIGgxID0gYjY0LmluZGV4T2YoZGF0YS5jaGFyQXQoaSsrKSk7XG4gICAgICAgIGgyID0gYjY0LmluZGV4T2YoZGF0YS5jaGFyQXQoaSsrKSk7XG4gICAgICAgIGgzID0gYjY0LmluZGV4T2YoZGF0YS5jaGFyQXQoaSsrKSk7XG4gICAgICAgIGg0ID0gYjY0LmluZGV4T2YoZGF0YS5jaGFyQXQoaSsrKSk7XG5cbiAgICAgICAgYml0cyA9IGgxIDw8IDE4IHwgaDIgPDwgMTIgfCBoMyA8PCA2IHwgaDQ7XG5cbiAgICAgICAgbzEgPSBiaXRzID4+IDE2ICYgMHhmZjtcbiAgICAgICAgbzIgPSBiaXRzID4+IDggJiAweGZmO1xuICAgICAgICBvMyA9IGJpdHMgJiAweGZmO1xuXG4gICAgICAgIGlmIChoMyA9PSA2NCkge1xuICAgICAgICAgIHRtcF9hcnJbYWMrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG8xKTtcbiAgICAgICAgfSBlbHNlIGlmIChoNCA9PSA2NCkge1xuICAgICAgICAgIHRtcF9hcnJbYWMrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG8xLCBvMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG1wX2FyclthYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUobzEsIG8yLCBvMyk7XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKGkgPCBkYXRhLmxlbmd0aCk7XG5cbiAgICAgIGRlYyA9IHRtcF9hcnIuam9pbignJyk7XG5cbiAgICAgIHJldHVybiBkZWM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB2YWx1ZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBiaW5hcnkgdmFsdWUgZnJvbSB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYVN0cmluZyAgICAgICAgVGhlIGJpbmFyeSB2YWx1ZSBzdHJpbmdcbiAgICogQHJldHVybiB7SUNBTC5CaW5hcnl9ICAgICAgICAgIFRoZSBiaW5hcnkgdmFsdWUgaW5zdGFuY2VcbiAgICovXG4gIEJpbmFyeS5mcm9tU3RyaW5nID0gZnVuY3Rpb24oYVN0cmluZykge1xuICAgIHJldHVybiBuZXcgQmluYXJ5KGFTdHJpbmcpO1xuICB9O1xuXG4gIHJldHVybiBCaW5hcnk7XG59KCkpO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoLCAyMDExLTIwMTUgKi9cblxuXG5cbihmdW5jdGlvbigpIHtcbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogVGhpcyBjbGFzcyByZXByZXNlbnRzIHRoZSBcInBlcmlvZFwiIHZhbHVlIHR5cGUsIHdpdGggdmFyaW91cyBjYWxjdWxhdGlvblxuICAgKiBhbmQgbWFuaXB1bGF0aW9uIG1ldGhvZHMuXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBUaGUgcGFzc2VkIGRhdGEgb2JqZWN0IGNhbm5vdCBjb250YWluIGJvdGggYW5kIGVuZCBkYXRlIGFuZCBhIGR1cmF0aW9uLlxuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHtPYmplY3R9IGFEYXRhICAgICAgICAgICAgICAgICAgQW4gb2JqZWN0IHdpdGggbWVtYmVycyBvZiB0aGUgcGVyaW9kXG4gICAqIEBwYXJhbSB7SUNBTC5UaW1lPX0gYURhdGEuc3RhcnQgICAgICAgIFRoZSBzdGFydCBvZiB0aGUgcGVyaW9kXG4gICAqIEBwYXJhbSB7SUNBTC5UaW1lPX0gYURhdGEuZW5kICAgICAgICAgIFRoZSBlbmQgb2YgdGhlIHBlcmlvZFxuICAgKiBAcGFyYW0ge0lDQUwuRHVyYXRpb249fSBhRGF0YS5kdXJhdGlvbiBUaGUgZHVyYXRpb24gb2YgdGhlIHBlcmlvZFxuICAgKi9cbiAgSUNBTC5QZXJpb2QgPSBmdW5jdGlvbiBpY2FscGVyaW9kKGFEYXRhKSB7XG4gICAgdGhpcy53cmFwcGVkSlNPYmplY3QgPSB0aGlzO1xuXG4gICAgaWYgKGFEYXRhICYmICdzdGFydCcgaW4gYURhdGEpIHtcbiAgICAgIGlmIChhRGF0YS5zdGFydCAmJiAhKGFEYXRhLnN0YXJ0IGluc3RhbmNlb2YgSUNBTC5UaW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcuc3RhcnQgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBJQ0FMLlRpbWUnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhcnQgPSBhRGF0YS5zdGFydDtcbiAgICB9XG5cbiAgICBpZiAoYURhdGEgJiYgYURhdGEuZW5kICYmIGFEYXRhLmR1cmF0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBhY2NlcHQgYm90aCBlbmQgYW5kIGR1cmF0aW9uJyk7XG4gICAgfVxuXG4gICAgaWYgKGFEYXRhICYmICdlbmQnIGluIGFEYXRhKSB7XG4gICAgICBpZiAoYURhdGEuZW5kICYmICEoYURhdGEuZW5kIGluc3RhbmNlb2YgSUNBTC5UaW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcuZW5kIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgSUNBTC5UaW1lJyk7XG4gICAgICB9XG4gICAgICB0aGlzLmVuZCA9IGFEYXRhLmVuZDtcbiAgICB9XG5cbiAgICBpZiAoYURhdGEgJiYgJ2R1cmF0aW9uJyBpbiBhRGF0YSkge1xuICAgICAgaWYgKGFEYXRhLmR1cmF0aW9uICYmICEoYURhdGEuZHVyYXRpb24gaW5zdGFuY2VvZiBJQ0FMLkR1cmF0aW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcuZHVyYXRpb24gbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBJQ0FMLkR1cmF0aW9uJyk7XG4gICAgICB9XG4gICAgICB0aGlzLmR1cmF0aW9uID0gYURhdGEuZHVyYXRpb247XG4gICAgfVxuICB9O1xuXG4gIElDQUwuUGVyaW9kLnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdGFydCBvZiB0aGUgcGVyaW9kXG4gICAgICogQHR5cGUge0lDQUwuVGltZX1cbiAgICAgKi9cbiAgICBzdGFydDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlbmQgb2YgdGhlIHBlcmlvZFxuICAgICAqIEB0eXBlIHtJQ0FMLlRpbWV9XG4gICAgICovXG4gICAgZW5kOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGR1cmF0aW9uIG9mIHRoZSBwZXJpb2RcbiAgICAgKiBAdHlwZSB7SUNBTC5EdXJhdGlvbn1cbiAgICAgKi9cbiAgICBkdXJhdGlvbjogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBjbGFzcyBpZGVudGlmaWVyLlxuICAgICAqIEBjb25zdGFudFxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgXCJpY2FscGVyaW9kXCJcbiAgICAgKi9cbiAgICBpY2FsY2xhc3M6IFwiaWNhbHBlcmlvZFwiLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgbmFtZSwgdG8gYmUgdXNlZCBpbiB0aGUgakNhbCBvYmplY3QuXG4gICAgICogQGNvbnN0YW50XG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBcInBlcmlvZFwiXG4gICAgICovXG4gICAgaWNhbHR5cGU6IFwicGVyaW9kXCIsXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIGR1cmF0aW9uIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0lDQUwuUGVyaW9kfSAgICAgIFRoZSBjbG9uZWQgb2JqZWN0XG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIElDQUwuUGVyaW9kLmZyb21EYXRhKHtcbiAgICAgICAgc3RhcnQ6IHRoaXMuc3RhcnQgPyB0aGlzLnN0YXJ0LmNsb25lKCkgOiBudWxsLFxuICAgICAgICBlbmQ6IHRoaXMuZW5kID8gdGhpcy5lbmQuY2xvbmUoKSA6IG51bGwsXG4gICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uID8gdGhpcy5kdXJhdGlvbi5jbG9uZSgpIDogbnVsbFxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGR1cmF0aW9uIG9mIHRoZSBwZXJpb2QsIGVpdGhlciBkaXJlY3RseSBvciBieSBzdWJ0cmFjdGluZ1xuICAgICAqIHN0YXJ0IGZyb20gZW5kIGRhdGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLkR1cmF0aW9ufSAgICAgIFRoZSBjYWxjdWxhdGVkIGR1cmF0aW9uXG4gICAgICovXG4gICAgZ2V0RHVyYXRpb246IGZ1bmN0aW9uIGR1cmF0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuZHVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHVyYXRpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmQuc3VidHJhY3REYXRlKHRoaXMuc3RhcnQpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBlbmQgZGF0ZSBvZiB0aGUgcGVyaW9kLCBlaXRoZXIgZGlyZWN0bHkgb3IgYnkgYWRkaW5nXG4gICAgICogZHVyYXRpb24gdG8gc3RhcnQgZGF0ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0lDQUwuVGltZX0gICAgICAgICAgVGhlIGNhbGN1bGF0ZWQgZW5kIGRhdGVcbiAgICAgKi9cbiAgICBnZXRFbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuZW5kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnN0YXJ0LmNsb25lKCk7XG4gICAgICAgIGVuZC5hZGREdXJhdGlvbih0aGlzLmR1cmF0aW9uKTtcbiAgICAgICAgcmV0dXJuIGVuZDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHBlcmlvZC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhcnQgKyBcIi9cIiArICh0aGlzLmVuZCB8fCB0aGlzLmR1cmF0aW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGpDYWwgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBwZXJpb2QgdHlwZS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBbdGhpcy5zdGFydC50b1N0cmluZygpLCAodGhpcy5lbmQgfHwgdGhpcy5kdXJhdGlvbikudG9TdHJpbmcoKV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBpQ2FsZW5kYXIgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgcGVyaW9kLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICB0b0lDQUxTdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhcnQudG9JQ0FMU3RyaW5nKCkgKyBcIi9cIiArXG4gICAgICAgICAgICAgKHRoaXMuZW5kIHx8IHRoaXMuZHVyYXRpb24pLnRvSUNBTFN0cmluZygpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgSUNBTC5QZXJpb2R9IGluc3RhbmNlIGZyb20gdGhlIHBhc3NlZCBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgICAgICAgICAgICBUaGUgc3RyaW5nIHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7SUNBTC5Qcm9wZXJ0eX0gcHJvcCAgICBUaGUgcHJvcGVydHkgdGhpcyBwZXJpb2Qgd2lsbCBiZSBvblxuICAgKiBAcmV0dXJuIHtJQ0FMLlBlcmlvZH0gICAgICAgICAgVGhlIGNyZWF0ZWQgcGVyaW9kIGluc3RhbmNlXG4gICAqL1xuICBJQ0FMLlBlcmlvZC5mcm9tU3RyaW5nID0gZnVuY3Rpb24gZnJvbVN0cmluZyhzdHIsIHByb3ApIHtcbiAgICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoJy8nKTtcblxuICAgIGlmIChwYXJ0cy5sZW5ndGggIT09IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0ludmFsaWQgc3RyaW5nIHZhbHVlOiBcIicgKyBzdHIgKyAnXCIgbXVzdCBjb250YWluIGEgXCIvXCIgY2hhci4nXG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgc3RhcnQ6IElDQUwuVGltZS5mcm9tRGF0ZVRpbWVTdHJpbmcocGFydHNbMF0sIHByb3ApXG4gICAgfTtcblxuICAgIHZhciBlbmQgPSBwYXJ0c1sxXTtcblxuICAgIGlmIChJQ0FMLkR1cmF0aW9uLmlzVmFsdWVTdHJpbmcoZW5kKSkge1xuICAgICAgb3B0aW9ucy5kdXJhdGlvbiA9IElDQUwuRHVyYXRpb24uZnJvbVN0cmluZyhlbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zLmVuZCA9IElDQUwuVGltZS5mcm9tRGF0ZVRpbWVTdHJpbmcoZW5kLCBwcm9wKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IElDQUwuUGVyaW9kKG9wdGlvbnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBJQ0FMLlBlcmlvZH0gaW5zdGFuY2UgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBvYmplY3QuXG4gICAqIFRoZSBwYXNzZWQgZGF0YSBvYmplY3QgY2Fubm90IGNvbnRhaW4gYm90aCBhbmQgZW5kIGRhdGUgYW5kIGEgZHVyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhRGF0YSAgICAgICAgICAgICAgICAgIEFuIG9iamVjdCB3aXRoIG1lbWJlcnMgb2YgdGhlIHBlcmlvZFxuICAgKiBAcGFyYW0ge0lDQUwuVGltZT19IGFEYXRhLnN0YXJ0ICAgICAgICBUaGUgc3RhcnQgb2YgdGhlIHBlcmlvZFxuICAgKiBAcGFyYW0ge0lDQUwuVGltZT19IGFEYXRhLmVuZCAgICAgICAgICBUaGUgZW5kIG9mIHRoZSBwZXJpb2RcbiAgICogQHBhcmFtIHtJQ0FMLkR1cmF0aW9uPX0gYURhdGEuZHVyYXRpb24gVGhlIGR1cmF0aW9uIG9mIHRoZSBwZXJpb2RcbiAgICogQHJldHVybiB7SUNBTC5QZXJpb2R9ICAgICAgICAgICAgICAgICAgVGhlIHBlcmlvZCBpbnN0YW5jZVxuICAgKi9cbiAgSUNBTC5QZXJpb2QuZnJvbURhdGEgPSBmdW5jdGlvbiBmcm9tRGF0YShhRGF0YSkge1xuICAgIHJldHVybiBuZXcgSUNBTC5QZXJpb2QoYURhdGEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IHBlcmlvZCBpbnN0YW5jZSBmcm9tIHRoZSBnaXZlbiBqQ2FsIGRhdGEgYXJyYXkuIFRoZSBmaXJzdFxuICAgKiBtZW1iZXIgaXMgYWx3YXlzIHRoZSBzdGFydCBkYXRlIHN0cmluZywgdGhlIHNlY29uZCBtZW1iZXIgaXMgZWl0aGVyIGFcbiAgICogZHVyYXRpb24gb3IgZW5kIGRhdGUgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PFN0cmluZyxTdHJpbmc+fSBhRGF0YSAgICBUaGUgakNhbCBkYXRhIGFycmF5XG4gICAqIEBwYXJhbSB7SUNBTC5Qcm9wZXJ0eX0gYVByb3AgICAgICAgICAgIFRoZSBwcm9wZXJ0eSB0aGlzIGpDYWwgZGF0YSBpcyBvblxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFMZW5pZW50ICAgICAgICAgICAgICBJZiB0cnVlLCBkYXRhIHZhbHVlIGNhbiBiZSBib3RoIGRhdGUgYW5kIGRhdGUtdGltZVxuICAgKiBAcmV0dXJuIHtJQ0FMLlBlcmlvZH0gICAgICAgICAgICAgICAgICBUaGUgcGVyaW9kIGluc3RhbmNlXG4gICAqL1xuICBJQ0FMLlBlcmlvZC5mcm9tSlNPTiA9IGZ1bmN0aW9uKGFEYXRhLCBhUHJvcCwgYUxlbmllbnQpIHtcbiAgICBmdW5jdGlvbiBmcm9tRGF0ZU9yRGF0ZVRpbWVTdHJpbmcoYVZhbHVlLCBhUHJvcCkge1xuICAgICAgaWYgKGFMZW5pZW50KSB7XG4gICAgICAgIHJldHVybiBJQ0FMLlRpbWUuZnJvbVN0cmluZyhhVmFsdWUsIGFQcm9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBJQ0FMLlRpbWUuZnJvbURhdGVUaW1lU3RyaW5nKGFWYWx1ZSwgYVByb3ApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChJQ0FMLkR1cmF0aW9uLmlzVmFsdWVTdHJpbmcoYURhdGFbMV0pKSB7XG4gICAgICByZXR1cm4gSUNBTC5QZXJpb2QuZnJvbURhdGEoe1xuICAgICAgICBzdGFydDogZnJvbURhdGVPckRhdGVUaW1lU3RyaW5nKGFEYXRhWzBdLCBhUHJvcCksXG4gICAgICAgIGR1cmF0aW9uOiBJQ0FMLkR1cmF0aW9uLmZyb21TdHJpbmcoYURhdGFbMV0pXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIElDQUwuUGVyaW9kLmZyb21EYXRhKHtcbiAgICAgICAgc3RhcnQ6IGZyb21EYXRlT3JEYXRlVGltZVN0cmluZyhhRGF0YVswXSwgYVByb3ApLFxuICAgICAgICBlbmQ6IGZyb21EYXRlT3JEYXRlVGltZVN0cmluZyhhRGF0YVsxXSwgYVByb3ApXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59KSgpO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoLCAyMDExLTIwMTUgKi9cblxuXG5cbihmdW5jdGlvbigpIHtcbiAgdmFyIERVUkFUSU9OX0xFVFRFUlMgPSAvKFtQRFdITVRTXXsxLDF9KS87XG5cbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogVGhpcyBjbGFzcyByZXByZXNlbnRzIHRoZSBcImR1cmF0aW9uXCIgdmFsdWUgdHlwZSwgd2l0aCB2YXJpb3VzIGNhbGN1bGF0aW9uXG4gICAqIGFuZCBtYW5pcHVsYXRpb24gbWV0aG9kcy5cbiAgICpcbiAgICogQGNsYXNzXG4gICAqIEBhbGlhcyBJQ0FMLkR1cmF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhICAgICAgICAgICAgICAgQW4gb2JqZWN0IHdpdGggbWVtYmVycyBvZiB0aGUgZHVyYXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEud2Vla3MgICAgICAgICBEdXJhdGlvbiBpbiB3ZWVrc1xuICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5kYXlzICAgICAgICAgIER1cmF0aW9uIGluIGRheXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEuaG91cnMgICAgICAgICBEdXJhdGlvbiBpbiBob3Vyc1xuICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5taW51dGVzICAgICAgIER1cmF0aW9uIGluIG1pbnV0ZXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEuc2Vjb25kcyAgICAgICBEdXJhdGlvbiBpbiBzZWNvbmRzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGF0YS5pc05lZ2F0aXZlICAgSWYgdHJ1ZSwgdGhlIGR1cmF0aW9uIGlzIG5lZ2F0aXZlXG4gICAqL1xuICBJQ0FMLkR1cmF0aW9uID0gZnVuY3Rpb24gaWNhbGR1cmF0aW9uKGRhdGEpIHtcbiAgICB0aGlzLndyYXBwZWRKU09iamVjdCA9IHRoaXM7XG4gICAgdGhpcy5mcm9tRGF0YShkYXRhKTtcbiAgfTtcblxuICBJQ0FMLkR1cmF0aW9uLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBUaGUgd2Vla3MgaW4gdGhpcyBkdXJhdGlvblxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHdlZWtzOiAwLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGRheXMgaW4gdGhpcyBkdXJhdGlvblxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIGRheXM6IDAsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGF5cyBpbiB0aGlzIGR1cmF0aW9uXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgaG91cnM6IDAsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWludXRlcyBpbiB0aGlzIGR1cmF0aW9uXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgbWludXRlczogMCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzZWNvbmRzIGluIHRoaXMgZHVyYXRpb25cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICBzZWNvbmRzOiAwLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHNlY29uZHMgaW4gdGhpcyBkdXJhdGlvblxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgaXNOZWdhdGl2ZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2xhc3MgaWRlbnRpZmllci5cbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IFwiaWNhbGR1cmF0aW9uXCJcbiAgICAgKi9cbiAgICBpY2FsY2xhc3M6IFwiaWNhbGR1cmF0aW9uXCIsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBuYW1lLCB0byBiZSB1c2VkIGluIHRoZSBqQ2FsIG9iamVjdC5cbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IFwiZHVyYXRpb25cIlxuICAgICAqL1xuICAgIGljYWx0eXBlOiBcImR1cmF0aW9uXCIsXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIGR1cmF0aW9uIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0lDQUwuRHVyYXRpb259ICAgICAgVGhlIGNsb25lZCBvYmplY3RcbiAgICAgKi9cbiAgICBjbG9uZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICByZXR1cm4gSUNBTC5EdXJhdGlvbi5mcm9tRGF0YSh0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGR1cmF0aW9uIHZhbHVlIGV4cHJlc3NlZCBhcyBhIG51bWJlciBvZiBzZWNvbmRzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgICBUaGUgZHVyYXRpb24gdmFsdWUgaW4gc2Vjb25kc1xuICAgICAqL1xuICAgIHRvU2Vjb25kczogZnVuY3Rpb24gdG9TZWNvbmRzKCkge1xuICAgICAgdmFyIHNlY29uZHMgPSB0aGlzLnNlY29uZHMgKyA2MCAqIHRoaXMubWludXRlcyArIDM2MDAgKiB0aGlzLmhvdXJzICtcbiAgICAgICAgICAgICAgICAgICAgODY0MDAgKiB0aGlzLmRheXMgKyA3ICogODY0MDAgKiB0aGlzLndlZWtzO1xuICAgICAgcmV0dXJuICh0aGlzLmlzTmVnYXRpdmUgPyAtc2Vjb25kcyA6IHNlY29uZHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWFkcyB0aGUgcGFzc2VkIHNlY29uZHMgdmFsdWUgaW50byB0aGlzIGR1cmF0aW9uIG9iamVjdC4gQWZ0ZXJ3YXJkcyxcbiAgICAgKiBtZW1iZXJzIGxpa2Uge0BsaW5rIElDQUwuRHVyYXRpb24jZGF5cyBkYXlzfSBhbmQge0BsaW5rIElDQUwuRHVyYXRpb24jd2Vla3Mgd2Vla3N9IHdpbGwgYmUgc2V0IHVwXG4gICAgICogYWNjb3JkaW5nbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYVNlY29uZHMgICAgIFRoZSBkdXJhdGlvbiB2YWx1ZSBpbiBzZWNvbmRzXG4gICAgICogQHJldHVybiB7SUNBTC5EdXJhdGlvbn0gICAgICBSZXR1cm5zIHRoaXMgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBmcm9tU2Vjb25kczogZnVuY3Rpb24gZnJvbVNlY29uZHMoYVNlY29uZHMpIHtcbiAgICAgIHZhciBzZWNzID0gTWF0aC5hYnMoYVNlY29uZHMpO1xuXG4gICAgICB0aGlzLmlzTmVnYXRpdmUgPSAoYVNlY29uZHMgPCAwKTtcbiAgICAgIHRoaXMuZGF5cyA9IElDQUwuaGVscGVycy50cnVuYyhzZWNzIC8gODY0MDApO1xuXG4gICAgICAvLyBJZiB3ZSBoYXZlIGEgZmxhdCBudW1iZXIgb2Ygd2Vla3MsIHVzZSB0aGVtLlxuICAgICAgaWYgKHRoaXMuZGF5cyAlIDcgPT0gMCkge1xuICAgICAgICB0aGlzLndlZWtzID0gdGhpcy5kYXlzIC8gNztcbiAgICAgICAgdGhpcy5kYXlzID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMud2Vla3MgPSAwO1xuICAgICAgfVxuXG4gICAgICBzZWNzIC09ICh0aGlzLmRheXMgKyA3ICogdGhpcy53ZWVrcykgKiA4NjQwMDtcblxuICAgICAgdGhpcy5ob3VycyA9IElDQUwuaGVscGVycy50cnVuYyhzZWNzIC8gMzYwMCk7XG4gICAgICBzZWNzIC09IHRoaXMuaG91cnMgKiAzNjAwO1xuXG4gICAgICB0aGlzLm1pbnV0ZXMgPSBJQ0FMLmhlbHBlcnMudHJ1bmMoc2VjcyAvIDYwKTtcbiAgICAgIHNlY3MgLT0gdGhpcy5taW51dGVzICogNjA7XG5cbiAgICAgIHRoaXMuc2Vjb25kcyA9IHNlY3M7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB1cCB0aGUgY3VycmVudCBpbnN0YW5jZSB1c2luZyBtZW1iZXJzIGZyb20gdGhlIHBhc3NlZCBkYXRhIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhRGF0YSAgICAgICAgICAgICAgIEFuIG9iamVjdCB3aXRoIG1lbWJlcnMgb2YgdGhlIGR1cmF0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXRhLndlZWtzICAgICAgICAgRHVyYXRpb24gaW4gd2Vla3NcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYURhdGEuZGF5cyAgICAgICAgICBEdXJhdGlvbiBpbiBkYXlzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXRhLmhvdXJzICAgICAgICAgRHVyYXRpb24gaW4gaG91cnNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYURhdGEubWludXRlcyAgICAgICBEdXJhdGlvbiBpbiBtaW51dGVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXRhLnNlY29uZHMgICAgICAgRHVyYXRpb24gaW4gc2Vjb25kc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gYURhdGEuaXNOZWdhdGl2ZSAgIElmIHRydWUsIHRoZSBkdXJhdGlvbiBpcyBuZWdhdGl2ZVxuICAgICAqL1xuICAgIGZyb21EYXRhOiBmdW5jdGlvbiBmcm9tRGF0YShhRGF0YSkge1xuICAgICAgdmFyIHByb3BzVG9Db3B5ID0gW1wid2Vla3NcIiwgXCJkYXlzXCIsIFwiaG91cnNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICBcIm1pbnV0ZXNcIiwgXCJzZWNvbmRzXCIsIFwiaXNOZWdhdGl2ZVwiXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wc1RvQ29weSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFwcm9wc1RvQ29weS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb3AgPSBwcm9wc1RvQ29weVtrZXldO1xuICAgICAgICBpZiAoYURhdGEgJiYgcHJvcCBpbiBhRGF0YSkge1xuICAgICAgICAgIHRoaXNbcHJvcF0gPSBhRGF0YVtwcm9wXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzW3Byb3BdID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIGR1cmF0aW9uIGluc3RhbmNlIHRvIHRoZSBkZWZhdWx0IHZhbHVlcywgaS5lLiBQVDBTXG4gICAgICovXG4gICAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgdGhpcy5pc05lZ2F0aXZlID0gZmFsc2U7XG4gICAgICB0aGlzLndlZWtzID0gMDtcbiAgICAgIHRoaXMuZGF5cyA9IDA7XG4gICAgICB0aGlzLmhvdXJzID0gMDtcbiAgICAgIHRoaXMubWludXRlcyA9IDA7XG4gICAgICB0aGlzLnNlY29uZHMgPSAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb21wYXJlcyB0aGUgZHVyYXRpb24gaW5zdGFuY2Ugd2l0aCBhbm90aGVyIG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SUNBTC5EdXJhdGlvbn0gYU90aGVyICAgICAgICBUaGUgaW5zdGFuY2UgdG8gY29tcGFyZSB3aXRoXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgICAgICAgICAgIC0xLCAwIG9yIDEgZm9yIGxlc3MvZXF1YWwvZ3JlYXRlclxuICAgICAqL1xuICAgIGNvbXBhcmU6IGZ1bmN0aW9uIGNvbXBhcmUoYU90aGVyKSB7XG4gICAgICB2YXIgdGhpc1NlY29uZHMgPSB0aGlzLnRvU2Vjb25kcygpO1xuICAgICAgdmFyIG90aGVyU2Vjb25kcyA9IGFPdGhlci50b1NlY29uZHMoKTtcbiAgICAgIHJldHVybiAodGhpc1NlY29uZHMgPiBvdGhlclNlY29uZHMpIC0gKHRoaXNTZWNvbmRzIDwgb3RoZXJTZWNvbmRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplcyB0aGUgZHVyYXRpb24gaW5zdGFuY2UuIEZvciBleGFtcGxlLCBhIGR1cmF0aW9uIHdpdGggYSB2YWx1ZVxuICAgICAqIG9mIDYxIHNlY29uZHMgd2lsbCBiZSBub3JtYWxpemVkIHRvIDEgbWludXRlIGFuZCAxIHNlY29uZC5cbiAgICAgKi9cbiAgICBub3JtYWxpemU6IGZ1bmN0aW9uIG5vcm1hbGl6ZSgpIHtcbiAgICAgIHRoaXMuZnJvbVNlY29uZHModGhpcy50b1NlY29uZHMoKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBkdXJhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgaWYgKHRoaXMudG9TZWNvbmRzKCkgPT0gMCkge1xuICAgICAgICByZXR1cm4gXCJQVDBTXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc3RyID0gXCJcIjtcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSkgc3RyICs9IFwiLVwiO1xuICAgICAgICBzdHIgKz0gXCJQXCI7XG4gICAgICAgIGlmICh0aGlzLndlZWtzKSBzdHIgKz0gdGhpcy53ZWVrcyArIFwiV1wiO1xuICAgICAgICBpZiAodGhpcy5kYXlzKSBzdHIgKz0gdGhpcy5kYXlzICsgXCJEXCI7XG5cbiAgICAgICAgaWYgKHRoaXMuaG91cnMgfHwgdGhpcy5taW51dGVzIHx8IHRoaXMuc2Vjb25kcykge1xuICAgICAgICAgIHN0ciArPSBcIlRcIjtcbiAgICAgICAgICBpZiAodGhpcy5ob3Vycykgc3RyICs9IHRoaXMuaG91cnMgKyBcIkhcIjtcbiAgICAgICAgICBpZiAodGhpcy5taW51dGVzKSBzdHIgKz0gdGhpcy5taW51dGVzICsgXCJNXCI7XG4gICAgICAgICAgaWYgKHRoaXMuc2Vjb25kcykgc3RyICs9IHRoaXMuc2Vjb25kcyArIFwiU1wiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBpQ2FsZW5kYXIgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZHVyYXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvSUNBTFN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBJQ0FMLkR1cmF0aW9uIGluc3RhbmNlIGZyb20gdGhlIHBhc3NlZCBzZWNvbmRzIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gYVNlY29uZHMgICAgICAgVGhlIHNlY29uZHMgdG8gY3JlYXRlIHRoZSBpbnN0YW5jZSBmcm9tXG4gICAqIEByZXR1cm4ge0lDQUwuRHVyYXRpb259ICAgICAgICBUaGUgbmV3bHkgY3JlYXRlZCBkdXJhdGlvbiBpbnN0YW5jZVxuICAgKi9cbiAgSUNBTC5EdXJhdGlvbi5mcm9tU2Vjb25kcyA9IGZ1bmN0aW9uIGljYWxkdXJhdGlvbl9mcm9tX3NlY29uZHMoYVNlY29uZHMpIHtcbiAgICByZXR1cm4gKG5ldyBJQ0FMLkR1cmF0aW9uKCkpLmZyb21TZWNvbmRzKGFTZWNvbmRzKTtcbiAgfTtcblxuICAvKipcbiAgICogSW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9uIHRvIGhhbmRsZSBhIGNodW5rIG9mIGEgZHVyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBsZXR0ZXIgdHlwZSBvZiBkdXJhdGlvbiBjaHVua1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbnVtYmVyIG51bWVyaWMgdmFsdWUgb3IgLS8rXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWN0IHRhcmdldCB0byBhc3NpZ24gdmFsdWVzIHRvXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZUR1cmF0aW9uQ2h1bmsobGV0dGVyLCBudW1iZXIsIG9iamVjdCkge1xuICAgIHZhciB0eXBlO1xuICAgIHN3aXRjaCAobGV0dGVyKSB7XG4gICAgICBjYXNlICdQJzpcbiAgICAgICAgaWYgKG51bWJlciAmJiBudW1iZXIgPT09ICctJykge1xuICAgICAgICAgIG9iamVjdC5pc05lZ2F0aXZlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvYmplY3QuaXNOZWdhdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBlcmlvZFxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0QnOlxuICAgICAgICB0eXBlID0gJ2RheXMnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1cnOlxuICAgICAgICB0eXBlID0gJ3dlZWtzJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdIJzpcbiAgICAgICAgdHlwZSA9ICdob3Vycyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTSc6XG4gICAgICAgIHR5cGUgPSAnbWludXRlcyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnUyc6XG4gICAgICAgIHR5cGUgPSAnc2Vjb25kcyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gTm90IGEgdmFsaWQgY2h1bmtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUpIHtcbiAgICAgIGlmICghbnVtYmVyICYmIG51bWJlciAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ2ludmFsaWQgZHVyYXRpb24gdmFsdWU6IE1pc3NpbmcgbnVtYmVyIGJlZm9yZSBcIicgKyBsZXR0ZXIgKyAnXCInXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB2YXIgbnVtID0gcGFyc2VJbnQobnVtYmVyLCAxMCk7XG4gICAgICBpZiAoSUNBTC5oZWxwZXJzLmlzU3RyaWN0bHlOYU4obnVtKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ2ludmFsaWQgZHVyYXRpb24gdmFsdWU6IEludmFsaWQgbnVtYmVyIFwiJyArIG51bWJlciArICdcIiBiZWZvcmUgXCInICsgbGV0dGVyICsgJ1wiJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgb2JqZWN0W3R5cGVdID0gbnVtO1xuICAgIH1cblxuICAgIHJldHVybiAxO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gc3RyaW5nIGlzIGFuIGlDYWxlbmRhciBkdXJhdGlvbiB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlICAgICAgVGhlIHJhdyBpY2FsIHZhbHVlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgIFRydWUsIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBvZiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiBpY2FsIHR5cGVcbiAgICovXG4gIElDQUwuRHVyYXRpb24uaXNWYWx1ZVN0cmluZyA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHJldHVybiAoc3RyaW5nWzBdID09PSAnUCcgfHwgc3RyaW5nWzFdID09PSAnUCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBJQ0FMLkR1cmF0aW9ufSBpbnN0YW5jZSBmcm9tIHRoZSBwYXNzZWQgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYVN0ciAgICAgICBUaGUgc3RyaW5nIHRvIHBhcnNlXG4gICAqIEByZXR1cm4ge0lDQUwuRHVyYXRpb259ICAgIFRoZSBjcmVhdGVkIGR1cmF0aW9uIGluc3RhbmNlXG4gICAqL1xuICBJQ0FMLkR1cmF0aW9uLmZyb21TdHJpbmcgPSBmdW5jdGlvbiBpY2FsZHVyYXRpb25fZnJvbV9zdHJpbmcoYVN0cikge1xuICAgIHZhciBwb3MgPSAwO1xuICAgIHZhciBkaWN0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgY2h1bmtzID0gMDtcblxuICAgIHdoaWxlICgocG9zID0gYVN0ci5zZWFyY2goRFVSQVRJT05fTEVUVEVSUykpICE9PSAtMSkge1xuICAgICAgdmFyIHR5cGUgPSBhU3RyW3Bvc107XG4gICAgICB2YXIgbnVtZXJpYyA9IGFTdHIuc3Vic3RyKDAsIHBvcyk7XG4gICAgICBhU3RyID0gYVN0ci5zdWJzdHIocG9zICsgMSk7XG5cbiAgICAgIGNodW5rcyArPSBwYXJzZUR1cmF0aW9uQ2h1bmsodHlwZSwgbnVtZXJpYywgZGljdCk7XG4gICAgfVxuXG4gICAgaWYgKGNodW5rcyA8IDIpIHtcbiAgICAgIC8vIFRoZXJlIG11c3QgYmUgYXQgbGVhc3QgYSBjaHVuayB3aXRoIFwiUFwiIGFuZCBzb21lIHVuaXQgY2h1bmtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2ludmFsaWQgZHVyYXRpb24gdmFsdWU6IE5vdCBlbm91Z2ggZHVyYXRpb24gY29tcG9uZW50cyBpbiBcIicgKyBhU3RyICsgJ1wiJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IElDQUwuRHVyYXRpb24oZGljdCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgSUNBTC5EdXJhdGlvbiBpbnN0YW5jZSBmcm9tIHRoZSBnaXZlbiBkYXRhIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFEYXRhICAgICAgICAgICAgICAgQW4gb2JqZWN0IHdpdGggbWVtYmVycyBvZiB0aGUgZHVyYXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXRhLndlZWtzICAgICAgICAgRHVyYXRpb24gaW4gd2Vla3NcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXRhLmRheXMgICAgICAgICAgRHVyYXRpb24gaW4gZGF5c1xuICAgKiBAcGFyYW0ge051bWJlcn0gYURhdGEuaG91cnMgICAgICAgICBEdXJhdGlvbiBpbiBob3Vyc1xuICAgKiBAcGFyYW0ge051bWJlcn0gYURhdGEubWludXRlcyAgICAgICBEdXJhdGlvbiBpbiBtaW51dGVzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhRGF0YS5zZWNvbmRzICAgICAgIER1cmF0aW9uIGluIHNlY29uZHNcbiAgICogQHBhcmFtIHtCb29sZWFufSBhRGF0YS5pc05lZ2F0aXZlICAgSWYgdHJ1ZSwgdGhlIGR1cmF0aW9uIGlzIG5lZ2F0aXZlXG4gICAqIEByZXR1cm4ge0lDQUwuRHVyYXRpb259ICAgICAgICAgICAgIFRoZSBjcmVhdGVhZCBkdXJhdGlvbiBpbnN0YW5jZVxuICAgKi9cbiAgSUNBTC5EdXJhdGlvbi5mcm9tRGF0YSA9IGZ1bmN0aW9uIGljYWxkdXJhdGlvbl9mcm9tX2RhdGEoYURhdGEpIHtcbiAgICByZXR1cm4gbmV3IElDQUwuRHVyYXRpb24oYURhdGEpO1xuICB9O1xufSkoKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAxMS0yMDEyICovXG5cblxuXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBPUFRJT05TID0gW1widHppZFwiLCBcImxvY2F0aW9uXCIsIFwidHpuYW1lc1wiLFxuICAgICAgICAgICAgICAgICBcImxhdGl0dWRlXCIsIFwibG9uZ2l0dWRlXCJdO1xuXG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIFRpbWV6b25lIHJlcHJlc2VudGF0aW9uLCBjcmVhdGVkIGJ5IHBhc3NpbmcgaW4gYSB0emlkIGFuZCBjb21wb25lbnQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciB2Y2FsZW5kYXI7XG4gICAqIHZhciB0aW1lem9uZUNvbXAgPSB2Y2FsZW5kYXIuZ2V0Rmlyc3RTdWJjb21wb25lbnQoJ3Z0aW1lem9uZScpO1xuICAgKiB2YXIgdHppZCA9IHRpbWV6b25lQ29tcC5nZXRGaXJzdFByb3BlcnR5VmFsdWUoJ3R6aWQnKTtcbiAgICpcbiAgICogdmFyIHRpbWV6b25lID0gbmV3IElDQUwuVGltZXpvbmUoe1xuICAgKiAgIGNvbXBvbmVudDogdGltZXpvbmVDb21wLFxuICAgKiAgIHR6aWRcbiAgICogfSk7XG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAcGFyYW0ge0lDQUwuQ29tcG9uZW50fE9iamVjdH0gZGF0YSBvcHRpb25zIGZvciBjbGFzc1xuICAgKiBAcGFyYW0ge1N0cmluZ3xJQ0FMLkNvbXBvbmVudH0gZGF0YS5jb21wb25lbnRcbiAgICogICAgICAgIElmIGRhdGEgaXMgYSBzaW1wbGUgb2JqZWN0LCB0aGVuIHRoaXMgbWVtYmVyIGNhbiBiZSBzZXQgdG8gZWl0aGVyIGFcbiAgICogICAgICAgIHN0cmluZyBjb250YWluaW5nIHRoZSBjb21wb25lbnQgZGF0YSwgb3IgYW4gYWxyZWFkeSBwYXJzZWRcbiAgICogICAgICAgIElDQUwuQ29tcG9uZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLnR6aWQgICAgICBUaGUgdGltZXpvbmUgaWRlbnRpZmllclxuICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5sb2NhdGlvbiAgVGhlIHRpbWV6b25lIGxvY2F0aW9ud1xuICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS50em5hbWVzICAgQW4gYWx0ZXJuYXRpdmUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lem9uZVxuICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5sYXRpdHVkZSAgVGhlIGxhdGl0dWRlIG9mIHRoZSB0aW1lem9uZVxuICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5sb25naXR1ZGUgVGhlIGxvbmdpdHVkZSBvZiB0aGUgdGltZXpvbmVcbiAgICovXG4gIElDQUwuVGltZXpvbmUgPSBmdW5jdGlvbiBpY2FsdGltZXpvbmUoZGF0YSkge1xuICAgIHRoaXMud3JhcHBlZEpTT2JqZWN0ID0gdGhpcztcbiAgICB0aGlzLmZyb21EYXRhKGRhdGEpO1xuICB9O1xuXG4gIElDQUwuVGltZXpvbmUucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogVGltZXpvbmUgaWRlbnRpZmllclxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgdHppZDogXCJcIixcblxuICAgIC8qKlxuICAgICAqIFRpbWV6b25lIGxvY2F0aW9uXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBsb2NhdGlvbjogXCJcIixcblxuICAgIC8qKlxuICAgICAqIEFsdGVybmF0aXZlIHRpbWV6b25lIG5hbWUsIGZvciB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICB0em5hbWVzOiBcIlwiLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHByaW1hcnkgbGF0aXR1ZGUgZm9yIHRoZSB0aW1lem9uZS5cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIGxhdGl0dWRlOiAwLjAsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgcHJpbWFyeSBsb25naXR1ZGUgZm9yIHRoZSB0aW1lem9uZS5cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIGxvbmdpdHVkZTogMC4wLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHZ0aW1lem9uZSBjb21wb25lbnQgZm9yIHRoaXMgdGltZXpvbmUuXG4gICAgICogQHR5cGUge0lDQUwuQ29tcG9uZW50fVxuICAgICAqL1xuICAgIGNvbXBvbmVudDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSB5ZWFyIHRoaXMgdGltZXpvbmUgaGFzIGJlZW4gZXhwYW5kZWQgdG8uIEFsbCB0aW1lem9uZSB0cmFuc2l0aW9uXG4gICAgICogZGF0ZXMgdW50aWwgdGhpcyB5ZWFyIGFyZSBrbm93biBhbmQgY2FuIGJlIHVzZWQgZm9yIGNhbGN1bGF0aW9uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZXhwYW5kZWRVbnRpbFllYXI6IDAsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2xhc3MgaWRlbnRpZmllci5cbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IFwiaWNhbHRpbWV6b25lXCJcbiAgICAgKi9cbiAgICBpY2FsY2xhc3M6IFwiaWNhbHRpbWV6b25lXCIsXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIHRoZSBjdXJyZW50IGluc3RhbmNlIHVzaW5nIG1lbWJlcnMgZnJvbSB0aGUgcGFzc2VkIGRhdGEgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLkNvbXBvbmVudHxPYmplY3R9IGFEYXRhIG9wdGlvbnMgZm9yIGNsYXNzXG4gICAgICogQHBhcmFtIHtTdHJpbmd8SUNBTC5Db21wb25lbnR9IGFEYXRhLmNvbXBvbmVudFxuICAgICAqICAgICAgICBJZiBhRGF0YSBpcyBhIHNpbXBsZSBvYmplY3QsIHRoZW4gdGhpcyBtZW1iZXIgY2FuIGJlIHNldCB0byBlaXRoZXIgYVxuICAgICAqICAgICAgICBzdHJpbmcgY29udGFpbmluZyB0aGUgY29tcG9uZW50IGRhdGEsIG9yIGFuIGFscmVhZHkgcGFyc2VkXG4gICAgICogICAgICAgIElDQUwuQ29tcG9uZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFEYXRhLnR6aWQgICAgICBUaGUgdGltZXpvbmUgaWRlbnRpZmllclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhRGF0YS5sb2NhdGlvbiAgVGhlIHRpbWV6b25lIGxvY2F0aW9ud1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhRGF0YS50em5hbWVzICAgQW4gYWx0ZXJuYXRpdmUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWV6b25lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXRhLmxhdGl0dWRlICBUaGUgbGF0aXR1ZGUgb2YgdGhlIHRpbWV6b25lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXRhLmxvbmdpdHVkZSBUaGUgbG9uZ2l0dWRlIG9mIHRoZSB0aW1lem9uZVxuICAgICAqL1xuICAgIGZyb21EYXRhOiBmdW5jdGlvbiBmcm9tRGF0YShhRGF0YSkge1xuICAgICAgdGhpcy5leHBhbmRlZFVudGlsWWVhciA9IDA7XG4gICAgICB0aGlzLmNoYW5nZXMgPSBbXTtcblxuICAgICAgaWYgKGFEYXRhIGluc3RhbmNlb2YgSUNBTC5Db21wb25lbnQpIHtcbiAgICAgICAgLy8gRWl0aGVyIGEgY29tcG9uZW50IGlzIHBhc3NlZCBkaXJlY3RseVxuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGFEYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlIHRoZSBjb21wb25lbnQgbWF5IGJlIGluIHRoZSBkYXRhIG9iamVjdFxuICAgICAgICBpZiAoYURhdGEgJiYgXCJjb21wb25lbnRcIiBpbiBhRGF0YSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgYURhdGEuY29tcG9uZW50ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIElmIGEgc3RyaW5nIHdhcyBwYXNzZWQsIHBhcnNlIGl0IGFzIGEgY29tcG9uZW50XG4gICAgICAgICAgICB2YXIgakNhbCA9IElDQUwucGFyc2UoYURhdGEuY29tcG9uZW50KTtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50ID0gbmV3IElDQUwuQ29tcG9uZW50KGpDYWwpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYURhdGEuY29tcG9uZW50IGluc3RhbmNlb2YgSUNBTC5Db21wb25lbnQpIHtcbiAgICAgICAgICAgIC8vIElmIGl0IHdhcyBhIGNvbXBvbmVudCBhbHJlYWR5LCB0aGVuIGp1c3Qgc2V0IGl0XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGFEYXRhLmNvbXBvbmVudDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGp1c3QgbnVsbCBvdXQgdGhlIGNvbXBvbmVudFxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvcHkgcmVtYWluaW5nIHBhc3NlZCBwcm9wZXJ0aWVzXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBPUFRJT05TKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICBpZiAoT1BUSU9OUy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICB2YXIgcHJvcCA9IE9QVElPTlNba2V5XTtcbiAgICAgICAgICAgIGlmIChhRGF0YSAmJiBwcm9wIGluIGFEYXRhKSB7XG4gICAgICAgICAgICAgIHRoaXNbcHJvcF0gPSBhRGF0YVtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgd2UgaGF2ZSBhIGNvbXBvbmVudCBidXQgbm8gVFpJRCwgYXR0ZW1wdCB0byBnZXQgaXQgZnJvbSB0aGVcbiAgICAgIC8vIGNvbXBvbmVudCdzIHByb3BlcnRpZXMuXG4gICAgICBpZiAodGhpcy5jb21wb25lbnQgaW5zdGFuY2VvZiBJQ0FMLkNvbXBvbmVudCAmJiAhdGhpcy50emlkKSB7XG4gICAgICAgIHRoaXMudHppZCA9IHRoaXMuY29tcG9uZW50LmdldEZpcnN0UHJvcGVydHlWYWx1ZSgndHppZCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIHV0Y09mZnNldCB0aGUgZ2l2ZW4gdGltZSB3b3VsZCBvY2N1ciBpbiB0aGlzIHRpbWV6b25lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWV9IHR0ICAgICAgICBUaGUgdGltZSB0byBjaGVjayBmb3JcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHV0YyBvZmZzZXQgaW4gc2Vjb25kc1xuICAgICAqL1xuICAgIHV0Y09mZnNldDogZnVuY3Rpb24gdXRjT2Zmc2V0KHR0KSB7XG4gICAgICBpZiAodGhpcyA9PSBJQ0FMLlRpbWV6b25lLnV0Y1RpbWV6b25lIHx8IHRoaXMgPT0gSUNBTC5UaW1lem9uZS5sb2NhbFRpbWV6b25lKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9lbnN1cmVDb3ZlcmFnZSh0dC55ZWFyKTtcblxuICAgICAgaWYgKCF0aGlzLmNoYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHRfY2hhbmdlID0ge1xuICAgICAgICB5ZWFyOiB0dC55ZWFyLFxuICAgICAgICBtb250aDogdHQubW9udGgsXG4gICAgICAgIGRheTogdHQuZGF5LFxuICAgICAgICBob3VyOiB0dC5ob3VyLFxuICAgICAgICBtaW51dGU6IHR0Lm1pbnV0ZSxcbiAgICAgICAgc2Vjb25kOiB0dC5zZWNvbmRcbiAgICAgIH07XG5cbiAgICAgIHZhciBjaGFuZ2VfbnVtID0gdGhpcy5fZmluZE5lYXJieUNoYW5nZSh0dF9jaGFuZ2UpO1xuICAgICAgdmFyIGNoYW5nZV9udW1fdG9fdXNlID0gLTE7XG4gICAgICB2YXIgc3RlcCA9IDE7XG5cbiAgICAgIC8vIFRPRE86IHJlcGxhY2Ugd2l0aCBiaW4gc2VhcmNoP1xuICAgICAgZm9yICg7Oykge1xuICAgICAgICB2YXIgY2hhbmdlID0gSUNBTC5oZWxwZXJzLmNsb25lKHRoaXMuY2hhbmdlc1tjaGFuZ2VfbnVtXSwgdHJ1ZSk7XG4gICAgICAgIGlmIChjaGFuZ2UudXRjT2Zmc2V0IDwgY2hhbmdlLnByZXZVdGNPZmZzZXQpIHtcbiAgICAgICAgICBJQ0FMLlRpbWV6b25lLmFkanVzdF9jaGFuZ2UoY2hhbmdlLCAwLCAwLCAwLCBjaGFuZ2UudXRjT2Zmc2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBJQ0FMLlRpbWV6b25lLmFkanVzdF9jaGFuZ2UoY2hhbmdlLCAwLCAwLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlLnByZXZVdGNPZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNtcCA9IElDQUwuVGltZXpvbmUuX2NvbXBhcmVfY2hhbmdlX2ZuKHR0X2NoYW5nZSwgY2hhbmdlKTtcblxuICAgICAgICBpZiAoY21wID49IDApIHtcbiAgICAgICAgICBjaGFuZ2VfbnVtX3RvX3VzZSA9IGNoYW5nZV9udW07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RlcCA9IC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0ZXAgPT0gLTEgJiYgY2hhbmdlX251bV90b191c2UgIT0gLTEpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGNoYW5nZV9udW0gKz0gc3RlcDtcblxuICAgICAgICBpZiAoY2hhbmdlX251bSA8IDApIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGFuZ2VfbnVtID49IHRoaXMuY2hhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgem9uZV9jaGFuZ2UgPSB0aGlzLmNoYW5nZXNbY2hhbmdlX251bV90b191c2VdO1xuICAgICAgdmFyIHV0Y09mZnNldF9jaGFuZ2UgPSB6b25lX2NoYW5nZS51dGNPZmZzZXQgLSB6b25lX2NoYW5nZS5wcmV2VXRjT2Zmc2V0O1xuXG4gICAgICBpZiAodXRjT2Zmc2V0X2NoYW5nZSA8IDAgJiYgY2hhbmdlX251bV90b191c2UgPiAwKSB7XG4gICAgICAgIHZhciB0bXBfY2hhbmdlID0gSUNBTC5oZWxwZXJzLmNsb25lKHpvbmVfY2hhbmdlLCB0cnVlKTtcbiAgICAgICAgSUNBTC5UaW1lem9uZS5hZGp1c3RfY2hhbmdlKHRtcF9jaGFuZ2UsIDAsIDAsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wX2NoYW5nZS5wcmV2VXRjT2Zmc2V0KTtcblxuICAgICAgICBpZiAoSUNBTC5UaW1lem9uZS5fY29tcGFyZV9jaGFuZ2VfZm4odHRfY2hhbmdlLCB0bXBfY2hhbmdlKSA8IDApIHtcbiAgICAgICAgICB2YXIgcHJldl96b25lX2NoYW5nZSA9IHRoaXMuY2hhbmdlc1tjaGFuZ2VfbnVtX3RvX3VzZSAtIDFdO1xuXG4gICAgICAgICAgdmFyIHdhbnRfZGF5bGlnaHQgPSBmYWxzZTsgLy8gVE9ET1xuXG4gICAgICAgICAgaWYgKHpvbmVfY2hhbmdlLmlzX2RheWxpZ2h0ICE9IHdhbnRfZGF5bGlnaHQgJiZcbiAgICAgICAgICAgICAgcHJldl96b25lX2NoYW5nZS5pc19kYXlsaWdodCA9PSB3YW50X2RheWxpZ2h0KSB7XG4gICAgICAgICAgICB6b25lX2NoYW5nZSA9IHByZXZfem9uZV9jaGFuZ2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRPRE8gcmV0dXJuIGlzX2RheWxpZ2h0P1xuICAgICAgcmV0dXJuIHpvbmVfY2hhbmdlLnV0Y09mZnNldDtcbiAgICB9LFxuXG4gICAgX2ZpbmROZWFyYnlDaGFuZ2U6IGZ1bmN0aW9uIGljYWx0aW1lem9uZV9maW5kX25lYXJieV9jaGFuZ2UoY2hhbmdlKSB7XG4gICAgICAvLyBmaW5kIHRoZSBjbG9zZXN0IG1hdGNoXG4gICAgICB2YXIgaWR4ID0gSUNBTC5oZWxwZXJzLmJpbnNlYXJjaEluc2VydChcbiAgICAgICAgdGhpcy5jaGFuZ2VzLFxuICAgICAgICBjaGFuZ2UsXG4gICAgICAgIElDQUwuVGltZXpvbmUuX2NvbXBhcmVfY2hhbmdlX2ZuXG4gICAgICApO1xuXG4gICAgICBpZiAoaWR4ID49IHRoaXMuY2hhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlcy5sZW5ndGggLSAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaWR4O1xuICAgIH0sXG5cbiAgICBfZW5zdXJlQ292ZXJhZ2U6IGZ1bmN0aW9uKGFZZWFyKSB7XG4gICAgICBpZiAoSUNBTC5UaW1lem9uZS5fbWluaW11bUV4cGFuc2lvblllYXIgPT0gLTEpIHtcbiAgICAgICAgdmFyIHRvZGF5ID0gSUNBTC5UaW1lLm5vdygpO1xuICAgICAgICBJQ0FMLlRpbWV6b25lLl9taW5pbXVtRXhwYW5zaW9uWWVhciA9IHRvZGF5LnllYXI7XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGFuZ2VzRW5kWWVhciA9IGFZZWFyO1xuICAgICAgaWYgKGNoYW5nZXNFbmRZZWFyIDwgSUNBTC5UaW1lem9uZS5fbWluaW11bUV4cGFuc2lvblllYXIpIHtcbiAgICAgICAgY2hhbmdlc0VuZFllYXIgPSBJQ0FMLlRpbWV6b25lLl9taW5pbXVtRXhwYW5zaW9uWWVhcjtcbiAgICAgIH1cblxuICAgICAgY2hhbmdlc0VuZFllYXIgKz0gSUNBTC5UaW1lem9uZS5FWFRSQV9DT1ZFUkFHRTtcblxuICAgICAgaWYgKGNoYW5nZXNFbmRZZWFyID4gSUNBTC5UaW1lem9uZS5NQVhfWUVBUikge1xuICAgICAgICBjaGFuZ2VzRW5kWWVhciA9IElDQUwuVGltZXpvbmUuTUFYX1lFQVI7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5jaGFuZ2VzLmxlbmd0aCB8fCB0aGlzLmV4cGFuZGVkVW50aWxZZWFyIDwgYVllYXIpIHtcbiAgICAgICAgdmFyIHN1YmNvbXBzID0gdGhpcy5jb21wb25lbnQuZ2V0QWxsU3ViY29tcG9uZW50cygpO1xuICAgICAgICB2YXIgY29tcExlbiA9IHN1YmNvbXBzLmxlbmd0aDtcbiAgICAgICAgdmFyIGNvbXBJZHggPSAwO1xuXG4gICAgICAgIGZvciAoOyBjb21wSWR4IDwgY29tcExlbjsgY29tcElkeCsrKSB7XG4gICAgICAgICAgdGhpcy5fZXhwYW5kQ29tcG9uZW50KFxuICAgICAgICAgICAgc3ViY29tcHNbY29tcElkeF0sIGNoYW5nZXNFbmRZZWFyLCB0aGlzLmNoYW5nZXNcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jaGFuZ2VzLnNvcnQoSUNBTC5UaW1lem9uZS5fY29tcGFyZV9jaGFuZ2VfZm4pO1xuICAgICAgICB0aGlzLmV4cGFuZGVkVW50aWxZZWFyID0gY2hhbmdlc0VuZFllYXI7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9leHBhbmRDb21wb25lbnQ6IGZ1bmN0aW9uKGFDb21wb25lbnQsIGFZZWFyLCBjaGFuZ2VzKSB7XG4gICAgICBpZiAoIWFDb21wb25lbnQuaGFzUHJvcGVydHkoXCJkdHN0YXJ0XCIpIHx8XG4gICAgICAgICAgIWFDb21wb25lbnQuaGFzUHJvcGVydHkoXCJ0em9mZnNldHRvXCIpIHx8XG4gICAgICAgICAgIWFDb21wb25lbnQuaGFzUHJvcGVydHkoXCJ0em9mZnNldGZyb21cIikpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBkdHN0YXJ0ID0gYUNvbXBvbmVudC5nZXRGaXJzdFByb3BlcnR5KFwiZHRzdGFydFwiKS5nZXRGaXJzdFZhbHVlKCk7XG4gICAgICB2YXIgY2hhbmdlO1xuXG4gICAgICBmdW5jdGlvbiBjb252ZXJ0X3R6b2Zmc2V0KG9mZnNldCkge1xuICAgICAgICByZXR1cm4gb2Zmc2V0LmZhY3RvciAqIChvZmZzZXQuaG91cnMgKiAzNjAwICsgb2Zmc2V0Lm1pbnV0ZXMgKiA2MCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGluaXRfY2hhbmdlcygpIHtcbiAgICAgICAgdmFyIGNoYW5nZWJhc2UgPSB7fTtcbiAgICAgICAgY2hhbmdlYmFzZS5pc19kYXlsaWdodCA9IChhQ29tcG9uZW50Lm5hbWUgPT0gXCJkYXlsaWdodFwiKTtcbiAgICAgICAgY2hhbmdlYmFzZS51dGNPZmZzZXQgPSBjb252ZXJ0X3R6b2Zmc2V0KFxuICAgICAgICAgIGFDb21wb25lbnQuZ2V0Rmlyc3RQcm9wZXJ0eShcInR6b2Zmc2V0dG9cIikuZ2V0Rmlyc3RWYWx1ZSgpXG4gICAgICAgICk7XG5cbiAgICAgICAgY2hhbmdlYmFzZS5wcmV2VXRjT2Zmc2V0ID0gY29udmVydF90em9mZnNldChcbiAgICAgICAgICBhQ29tcG9uZW50LmdldEZpcnN0UHJvcGVydHkoXCJ0em9mZnNldGZyb21cIikuZ2V0Rmlyc3RWYWx1ZSgpXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIGNoYW5nZWJhc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICghYUNvbXBvbmVudC5oYXNQcm9wZXJ0eShcInJydWxlXCIpICYmICFhQ29tcG9uZW50Lmhhc1Byb3BlcnR5KFwicmRhdGVcIikpIHtcbiAgICAgICAgY2hhbmdlID0gaW5pdF9jaGFuZ2VzKCk7XG4gICAgICAgIGNoYW5nZS55ZWFyID0gZHRzdGFydC55ZWFyO1xuICAgICAgICBjaGFuZ2UubW9udGggPSBkdHN0YXJ0Lm1vbnRoO1xuICAgICAgICBjaGFuZ2UuZGF5ID0gZHRzdGFydC5kYXk7XG4gICAgICAgIGNoYW5nZS5ob3VyID0gZHRzdGFydC5ob3VyO1xuICAgICAgICBjaGFuZ2UubWludXRlID0gZHRzdGFydC5taW51dGU7XG4gICAgICAgIGNoYW5nZS5zZWNvbmQgPSBkdHN0YXJ0LnNlY29uZDtcblxuICAgICAgICBJQ0FMLlRpbWV6b25lLmFkanVzdF9jaGFuZ2UoY2hhbmdlLCAwLCAwLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC1jaGFuZ2UucHJldlV0Y09mZnNldCk7XG4gICAgICAgIGNoYW5nZXMucHVzaChjaGFuZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHByb3BzID0gYUNvbXBvbmVudC5nZXRBbGxQcm9wZXJ0aWVzKFwicmRhdGVcIik7XG4gICAgICAgIGZvciAodmFyIHJkYXRla2V5IGluIHByb3BzKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eShyZGF0ZWtleSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmRhdGUgPSBwcm9wc1tyZGF0ZWtleV07XG4gICAgICAgICAgdmFyIHRpbWUgPSByZGF0ZS5nZXRGaXJzdFZhbHVlKCk7XG4gICAgICAgICAgY2hhbmdlID0gaW5pdF9jaGFuZ2VzKCk7XG5cbiAgICAgICAgICBjaGFuZ2UueWVhciA9IHRpbWUueWVhcjtcbiAgICAgICAgICBjaGFuZ2UubW9udGggPSB0aW1lLm1vbnRoO1xuICAgICAgICAgIGNoYW5nZS5kYXkgPSB0aW1lLmRheTtcblxuICAgICAgICAgIGlmICh0aW1lLmlzRGF0ZSkge1xuICAgICAgICAgICAgY2hhbmdlLmhvdXIgPSBkdHN0YXJ0LmhvdXI7XG4gICAgICAgICAgICBjaGFuZ2UubWludXRlID0gZHRzdGFydC5taW51dGU7XG4gICAgICAgICAgICBjaGFuZ2Uuc2Vjb25kID0gZHRzdGFydC5zZWNvbmQ7XG5cbiAgICAgICAgICAgIGlmIChkdHN0YXJ0LnpvbmUgIT0gSUNBTC5UaW1lem9uZS51dGNUaW1lem9uZSkge1xuICAgICAgICAgICAgICBJQ0FMLlRpbWV6b25lLmFkanVzdF9jaGFuZ2UoY2hhbmdlLCAwLCAwLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC1jaGFuZ2UucHJldlV0Y09mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoYW5nZS5ob3VyID0gdGltZS5ob3VyO1xuICAgICAgICAgICAgY2hhbmdlLm1pbnV0ZSA9IHRpbWUubWludXRlO1xuICAgICAgICAgICAgY2hhbmdlLnNlY29uZCA9IHRpbWUuc2Vjb25kO1xuXG4gICAgICAgICAgICBpZiAodGltZS56b25lICE9IElDQUwuVGltZXpvbmUudXRjVGltZXpvbmUpIHtcbiAgICAgICAgICAgICAgSUNBTC5UaW1lem9uZS5hZGp1c3RfY2hhbmdlKGNoYW5nZSwgMCwgMCwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtY2hhbmdlLnByZXZVdGNPZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNoYW5nZXMucHVzaChjaGFuZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJydWxlID0gYUNvbXBvbmVudC5nZXRGaXJzdFByb3BlcnR5KFwicnJ1bGVcIik7XG5cbiAgICAgICAgaWYgKHJydWxlKSB7XG4gICAgICAgICAgcnJ1bGUgPSBycnVsZS5nZXRGaXJzdFZhbHVlKCk7XG4gICAgICAgICAgY2hhbmdlID0gaW5pdF9jaGFuZ2VzKCk7XG5cbiAgICAgICAgICBpZiAocnJ1bGUudW50aWwgJiYgcnJ1bGUudW50aWwuem9uZSA9PSBJQ0FMLlRpbWV6b25lLnV0Y1RpbWV6b25lKSB7XG4gICAgICAgICAgICBycnVsZS51bnRpbC5hZGp1c3QoMCwgMCwgMCwgY2hhbmdlLnByZXZVdGNPZmZzZXQpO1xuICAgICAgICAgICAgcnJ1bGUudW50aWwuem9uZSA9IElDQUwuVGltZXpvbmUubG9jYWxUaW1lem9uZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBycnVsZS5pdGVyYXRvcihkdHN0YXJ0KTtcblxuICAgICAgICAgIHZhciBvY2M7XG4gICAgICAgICAgd2hpbGUgKChvY2MgPSBpdGVyYXRvci5uZXh0KCkpKSB7XG4gICAgICAgICAgICBjaGFuZ2UgPSBpbml0X2NoYW5nZXMoKTtcbiAgICAgICAgICAgIGlmIChvY2MueWVhciA+IGFZZWFyIHx8ICFvY2MpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoYW5nZS55ZWFyID0gb2NjLnllYXI7XG4gICAgICAgICAgICBjaGFuZ2UubW9udGggPSBvY2MubW9udGg7XG4gICAgICAgICAgICBjaGFuZ2UuZGF5ID0gb2NjLmRheTtcbiAgICAgICAgICAgIGNoYW5nZS5ob3VyID0gb2NjLmhvdXI7XG4gICAgICAgICAgICBjaGFuZ2UubWludXRlID0gb2NjLm1pbnV0ZTtcbiAgICAgICAgICAgIGNoYW5nZS5zZWNvbmQgPSBvY2Muc2Vjb25kO1xuICAgICAgICAgICAgY2hhbmdlLmlzRGF0ZSA9IG9jYy5pc0RhdGU7XG5cbiAgICAgICAgICAgIElDQUwuVGltZXpvbmUuYWRqdXN0X2NoYW5nZShjaGFuZ2UsIDAsIDAsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC1jaGFuZ2UucHJldlV0Y09mZnNldCk7XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goY2hhbmdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoYW5nZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB0aW1lem9uZS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICh0aGlzLnR6bmFtZXMgPyB0aGlzLnR6bmFtZXMgOiB0aGlzLnR6aWQpO1xuICAgIH1cbiAgfTtcblxuICBJQ0FMLlRpbWV6b25lLl9jb21wYXJlX2NoYW5nZV9mbiA9IGZ1bmN0aW9uIGljYWx0aW1lem9uZV9jb21wYXJlX2NoYW5nZV9mbihhLCBiKSB7XG4gICAgaWYgKGEueWVhciA8IGIueWVhcikgcmV0dXJuIC0xO1xuICAgIGVsc2UgaWYgKGEueWVhciA+IGIueWVhcikgcmV0dXJuIDE7XG5cbiAgICBpZiAoYS5tb250aCA8IGIubW9udGgpIHJldHVybiAtMTtcbiAgICBlbHNlIGlmIChhLm1vbnRoID4gYi5tb250aCkgcmV0dXJuIDE7XG5cbiAgICBpZiAoYS5kYXkgPCBiLmRheSkgcmV0dXJuIC0xO1xuICAgIGVsc2UgaWYgKGEuZGF5ID4gYi5kYXkpIHJldHVybiAxO1xuXG4gICAgaWYgKGEuaG91ciA8IGIuaG91cikgcmV0dXJuIC0xO1xuICAgIGVsc2UgaWYgKGEuaG91ciA+IGIuaG91cikgcmV0dXJuIDE7XG5cbiAgICBpZiAoYS5taW51dGUgPCBiLm1pbnV0ZSkgcmV0dXJuIC0xO1xuICAgIGVsc2UgaWYgKGEubWludXRlID4gYi5taW51dGUpIHJldHVybiAxO1xuXG4gICAgaWYgKGEuc2Vjb25kIDwgYi5zZWNvbmQpIHJldHVybiAtMTtcbiAgICBlbHNlIGlmIChhLnNlY29uZCA+IGIuc2Vjb25kKSByZXR1cm4gMTtcblxuICAgIHJldHVybiAwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHRoZSBkYXRlL3RpbWUgZnJvbSBvbmUgem9uZSB0byB0aGUgbmV4dC5cbiAgICpcbiAgICogQHBhcmFtIHtJQ0FMLlRpbWV9IHR0ICAgICAgICAgICAgICAgICAgVGhlIHRpbWUgdG8gY29udmVydFxuICAgKiBAcGFyYW0ge0lDQUwuVGltZXpvbmV9IGZyb21fem9uZSAgICAgICBUaGUgc291cmNlIHpvbmUgdG8gY29udmVydCBmcm9tXG4gICAqIEBwYXJhbSB7SUNBTC5UaW1lem9uZX0gdG9fem9uZSAgICAgICAgIFRoZSB0YXJnZXQgem9uZSB0byBjb252ZXJ0IHRvXG4gICAqIEByZXR1cm4ge0lDQUwuVGltZX0gICAgICAgICAgICAgICAgICAgIFRoZSBjb252ZXJ0ZWQgZGF0ZS90aW1lIG9iamVjdFxuICAgKi9cbiAgSUNBTC5UaW1lem9uZS5jb252ZXJ0X3RpbWUgPSBmdW5jdGlvbiBpY2FsdGltZXpvbmVfY29udmVydF90aW1lKHR0LCBmcm9tX3pvbmUsIHRvX3pvbmUpIHtcbiAgICBpZiAodHQuaXNEYXRlIHx8XG4gICAgICAgIGZyb21fem9uZS50emlkID09IHRvX3pvbmUudHppZCB8fFxuICAgICAgICBmcm9tX3pvbmUgPT0gSUNBTC5UaW1lem9uZS5sb2NhbFRpbWV6b25lIHx8XG4gICAgICAgIHRvX3pvbmUgPT0gSUNBTC5UaW1lem9uZS5sb2NhbFRpbWV6b25lKSB7XG4gICAgICB0dC56b25lID0gdG9fem9uZTtcbiAgICAgIHJldHVybiB0dDtcbiAgICB9XG5cbiAgICB2YXIgdXRjT2Zmc2V0ID0gZnJvbV96b25lLnV0Y09mZnNldCh0dCk7XG4gICAgdHQuYWRqdXN0KDAsIDAsIDAsIC0gdXRjT2Zmc2V0KTtcblxuICAgIHV0Y09mZnNldCA9IHRvX3pvbmUudXRjT2Zmc2V0KHR0KTtcbiAgICB0dC5hZGp1c3QoMCwgMCwgMCwgdXRjT2Zmc2V0KTtcblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IElDQUwuVGltZXpvbmUgaW5zdGFuY2UgZnJvbSB0aGUgcGFzc2VkIGRhdGEgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge0lDQUwuQ29tcG9uZW50fE9iamVjdH0gYURhdGEgb3B0aW9ucyBmb3IgY2xhc3NcbiAgICogQHBhcmFtIHtTdHJpbmd8SUNBTC5Db21wb25lbnR9IGFEYXRhLmNvbXBvbmVudFxuICAgKiAgICAgICAgSWYgYURhdGEgaXMgYSBzaW1wbGUgb2JqZWN0LCB0aGVuIHRoaXMgbWVtYmVyIGNhbiBiZSBzZXQgdG8gZWl0aGVyIGFcbiAgICogICAgICAgIHN0cmluZyBjb250YWluaW5nIHRoZSBjb21wb25lbnQgZGF0YSwgb3IgYW4gYWxyZWFkeSBwYXJzZWRcbiAgICogICAgICAgIElDQUwuQ29tcG9uZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhRGF0YS50emlkICAgICAgVGhlIHRpbWV6b25lIGlkZW50aWZpZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFEYXRhLmxvY2F0aW9uICBUaGUgdGltZXpvbmUgbG9jYXRpb253XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhRGF0YS50em5hbWVzICAgQW4gYWx0ZXJuYXRpdmUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lem9uZVxuICAgKiBAcGFyYW0ge051bWJlcn0gYURhdGEubGF0aXR1ZGUgIFRoZSBsYXRpdHVkZSBvZiB0aGUgdGltZXpvbmVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXRhLmxvbmdpdHVkZSBUaGUgbG9uZ2l0dWRlIG9mIHRoZSB0aW1lem9uZVxuICAgKi9cbiAgSUNBTC5UaW1lem9uZS5mcm9tRGF0YSA9IGZ1bmN0aW9uIGljYWx0aW1lem9uZV9mcm9tRGF0YShhRGF0YSkge1xuICAgIHZhciB0dCA9IG5ldyBJQ0FMLlRpbWV6b25lKCk7XG4gICAgcmV0dXJuIHR0LmZyb21EYXRhKGFEYXRhKTtcbiAgfTtcblxuICAvKipcbiAgICogVGhlIGluc3RhbmNlIGRlc2NyaWJpbmcgdGhlIFVUQyB0aW1lem9uZVxuICAgKiBAdHlwZSB7SUNBTC5UaW1lem9uZX1cbiAgICogQGNvbnN0YW50XG4gICAqIEBpbnN0YW5jZVxuICAgKi9cbiAgSUNBTC5UaW1lem9uZS51dGNUaW1lem9uZSA9IElDQUwuVGltZXpvbmUuZnJvbURhdGEoe1xuICAgIHR6aWQ6IFwiVVRDXCJcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFRoZSBpbnN0YW5jZSBkZXNjcmliaW5nIHRoZSBsb2NhbCB0aW1lem9uZVxuICAgKiBAdHlwZSB7SUNBTC5UaW1lem9uZX1cbiAgICogQGNvbnN0YW50XG4gICAqIEBpbnN0YW5jZVxuICAgKi9cbiAgSUNBTC5UaW1lem9uZS5sb2NhbFRpbWV6b25lID0gSUNBTC5UaW1lem9uZS5mcm9tRGF0YSh7XG4gICAgdHppZDogXCJmbG9hdGluZ1wiXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBBZGp1c3QgYSB0aW1lem9uZSBjaGFuZ2Ugb2JqZWN0LlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gY2hhbmdlICAgICBUaGUgdGltZXpvbmUgY2hhbmdlIG9iamVjdFxuICAgKiBAcGFyYW0ge051bWJlcn0gZGF5cyAgICAgICBUaGUgZXh0cmEgYW1vdW50IG9mIGRheXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhvdXJzICAgICAgVGhlIGV4dHJhIGFtb3VudCBvZiBob3Vyc1xuICAgKiBAcGFyYW0ge051bWJlcn0gbWludXRlcyAgICBUaGUgZXh0cmEgYW1vdW50IG9mIG1pbnV0ZXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNlY29uZHMgICAgVGhlIGV4dHJhIGFtb3VudCBvZiBzZWNvbmRzXG4gICAqL1xuICBJQ0FMLlRpbWV6b25lLmFkanVzdF9jaGFuZ2UgPSBmdW5jdGlvbiBpY2FsdGltZXpvbmVfYWRqdXN0X2NoYW5nZShjaGFuZ2UsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzKSB7XG4gICAgcmV0dXJuIElDQUwuVGltZS5wcm90b3R5cGUuYWRqdXN0LmNhbGwoXG4gICAgICBjaGFuZ2UsXG4gICAgICBkYXlzLFxuICAgICAgaG91cnMsXG4gICAgICBtaW51dGVzLFxuICAgICAgc2Vjb25kcyxcbiAgICAgIGNoYW5nZVxuICAgICk7XG4gIH07XG5cbiAgSUNBTC5UaW1lem9uZS5fbWluaW11bUV4cGFuc2lvblllYXIgPSAtMTtcbiAgSUNBTC5UaW1lem9uZS5NQVhfWUVBUiA9IDIwMzU7IC8vIFRPRE8gdGhpcyBpcyBiZWNhdXNlIG9mIHRpbWVfdCwgd2hpY2ggd2UgZG9uJ3QgbmVlZC4gU3RpbGwgdXNlZnVsbD9cbiAgSUNBTC5UaW1lem9uZS5FWFRSQV9DT1ZFUkFHRSA9IDU7XG59KSgpO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoLCAyMDExLTIwMTUgKi9cblxuXG4vKipcbiAqIFRoaXMgc3ltYm9sIGlzIGZ1cnRoZXIgZGVzY3JpYmVkIGxhdGVyIG9uXG4gKiBAaWdub3JlXG4gKi9cbklDQUwuVGltZXpvbmVTZXJ2aWNlID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgem9uZXM7XG5cbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogU2luZ2xldG9uIGNsYXNzIHRvIGNvbnRhaW4gdGltZXpvbmVzLiAgUmlnaHQgbm93IGl0IGlzIGFsbCBtYW51YWwgcmVnaXN0cnkgaW5cbiAgICogdGhlIGZ1dHVyZSB3ZSBtYXkgdXNlIHRoaXMgY2xhc3MgdG8gZG93bmxvYWQgdGltZXpvbmUgaW5mb3JtYXRpb24gb3IgaGFuZGxlXG4gICAqIGxvYWRpbmcgcHJlLWV4cGFuZGVkIHRpbWV6b25lcy5cbiAgICpcbiAgICogQG5hbWVzcGFjZVxuICAgKiBAYWxpYXMgSUNBTC5UaW1lem9uZVNlcnZpY2VcbiAgICovXG4gIHZhciBUaW1lem9uZVNlcnZpY2UgPSB7XG4gICAgZ2V0IGNvdW50KCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHpvbmVzKS5sZW5ndGg7XG4gICAgfSxcblxuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHpvbmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHZhciB1dGMgPSBJQ0FMLlRpbWV6b25lLnV0Y1RpbWV6b25lO1xuXG4gICAgICB6b25lcy5aID0gdXRjO1xuICAgICAgem9uZXMuVVRDID0gdXRjO1xuICAgICAgem9uZXMuR01UID0gdXRjO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGltZXpvbmUgaWQgaGFzIGJlZW4gcmVnaXN0ZXJlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0emlkICAgICBUaW1lem9uZSBpZGVudGlmaWVyIChlLmcuIEFtZXJpY2EvTG9zX0FuZ2VsZXMpXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgIEZhbHNlLCB3aGVuIG5vdCBwcmVzZW50XG4gICAgICovXG4gICAgaGFzOiBmdW5jdGlvbih0emlkKSB7XG4gICAgICByZXR1cm4gISF6b25lc1t0emlkXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHRpbWV6b25lIGJ5IGl0cyB0emlkIGlmIHByZXNlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHppZCAgICAgVGltZXpvbmUgaWRlbnRpZmllciAoZS5nLiBBbWVyaWNhL0xvc19BbmdlbGVzKVxuICAgICAqIEByZXR1cm4gez9JQ0FMLlRpbWV6b25lfSBUaGUgdGltZXpvbmUsIG9yIG51bGwgaWYgbm90IGZvdW5kXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbih0emlkKSB7XG4gICAgICByZXR1cm4gem9uZXNbdHppZF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIHRpbWV6b25lIG9iamVjdCBvciBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZz19IG5hbWVcbiAgICAgKiAgICAgICAgVGhlIG5hbWUgb2YgdGhlIHRpbWV6b25lLiBEZWZhdWx0cyB0byB0aGUgY29tcG9uZW50J3MgVFpJRCBpZiBub3RcbiAgICAgKiAgICAgICAgcGFzc2VkLlxuICAgICAqIEBwYXJhbSB7SUNBTC5Db21wb25lbnR8SUNBTC5UaW1lem9uZX0gem9uZVxuICAgICAqICAgICAgICBUaGUgaW5pdGlhbGl6ZWQgem9uZSBvciB2dGltZXpvbmUuXG4gICAgICovXG4gICAgcmVnaXN0ZXI6IGZ1bmN0aW9uKG5hbWUsIHRpbWV6b25lKSB7XG4gICAgICBpZiAobmFtZSBpbnN0YW5jZW9mIElDQUwuQ29tcG9uZW50KSB7XG4gICAgICAgIGlmIChuYW1lLm5hbWUgPT09ICd2dGltZXpvbmUnKSB7XG4gICAgICAgICAgdGltZXpvbmUgPSBuZXcgSUNBTC5UaW1lem9uZShuYW1lKTtcbiAgICAgICAgICBuYW1lID0gdGltZXpvbmUudHppZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGltZXpvbmUgaW5zdGFuY2VvZiBJQ0FMLlRpbWV6b25lKSB7XG4gICAgICAgIHpvbmVzW25hbWVdID0gdGltZXpvbmU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0aW1lem9uZSBtdXN0IGJlIElDQUwuVGltZXpvbmUgb3IgSUNBTC5Db21wb25lbnQnKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHRpbWV6b25lIGJ5IGl0cyB0emlkIGZyb20gdGhlIGxpc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHppZCAgICAgVGltZXpvbmUgaWRlbnRpZmllciAoZS5nLiBBbWVyaWNhL0xvc19BbmdlbGVzKVxuICAgICAqIEByZXR1cm4gez9JQ0FMLlRpbWV6b25lfSBUaGUgcmVtb3ZlZCB0aW1lem9uZSwgb3IgbnVsbCBpZiBub3QgcmVnaXN0ZXJlZFxuICAgICAqL1xuICAgIHJlbW92ZTogZnVuY3Rpb24odHppZCkge1xuICAgICAgcmV0dXJuIChkZWxldGUgem9uZXNbdHppZF0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBpbml0aWFsaXplIGRlZmF1bHRzXG4gIFRpbWV6b25lU2VydmljZS5yZXNldCgpO1xuXG4gIHJldHVybiBUaW1lem9uZVNlcnZpY2U7XG59KCkpO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoLCAyMDExLTIwMTUgKi9cblxuXG5cbihmdW5jdGlvbigpIHtcblxuICAvKipcbiAgICogQGNsYXNzZGVzY1xuICAgKiBpQ2FsZW5kYXIgVGltZSByZXByZXNlbnRhdGlvbiAoc2ltaWxhciB0byBKUyBEYXRlIG9iamVjdCkuICBGdWxseVxuICAgKiBpbmRlcGVuZGVudCBvZiBzeXN0ZW0gKE9TKSB0aW1lem9uZSAvIHRpbWUuICBVbmxpa2UgSlMgRGF0ZSwgdGhlIG1vbnRoXG4gICAqIEphbnVhcnkgaXMgMSwgbm90IHplcm8uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciB0aW1lID0gbmV3IElDQUwuVGltZSh7XG4gICAqICAgeWVhcjogMjAxMixcbiAgICogICBtb250aDogMTAsXG4gICAqICAgZGF5OiAxMVxuICAgKiAgIG1pbnV0ZTogMCxcbiAgICogICBzZWNvbmQ6IDAsXG4gICAqICAgaXNEYXRlOiBmYWxzZVxuICAgKiB9KTtcbiAgICpcbiAgICpcbiAgICogQGFsaWFzIElDQUwuVGltZVxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgICAgICAgICAgIFRpbWUgaW5pdGlhbGl6YXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLnllYXIgICAgIFRoZSB5ZWFyIGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLm1vbnRoICAgIFRoZSBtb250aCBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS5kYXkgICAgICBUaGUgZGF5IGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLmhvdXIgICAgIFRoZSBob3VyIGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLm1pbnV0ZSAgIFRoZSBtaW51dGUgZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcj19IGRhdGEuc2Vjb25kICAgVGhlIHNlY29uZCBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbj19IGRhdGEuaXNEYXRlICBJZiB0cnVlLCB0aGUgaW5zdGFuY2UgcmVwcmVzZW50cyBhIGRhdGUgKGFzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wcG9zZWQgdG8gYSBkYXRlLXRpbWUpXG4gICAqIEBwYXJhbSB7SUNBTC5UaW1lem9uZX0gem9uZSB0aW1lem9uZSB0aGlzIHBvc2l0aW9uIG9jY3VycyBpblxuICAgKi9cbiAgSUNBTC5UaW1lID0gZnVuY3Rpb24gaWNhbHRpbWUoZGF0YSwgem9uZSkge1xuICAgIHRoaXMud3JhcHBlZEpTT2JqZWN0ID0gdGhpcztcbiAgICB2YXIgdGltZSA9IHRoaXMuX3RpbWUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgLyogdGltZSBkZWZhdWx0cyAqL1xuICAgIHRpbWUueWVhciA9IDA7XG4gICAgdGltZS5tb250aCA9IDE7XG4gICAgdGltZS5kYXkgPSAxO1xuICAgIHRpbWUuaG91ciA9IDA7XG4gICAgdGltZS5taW51dGUgPSAwO1xuICAgIHRpbWUuc2Vjb25kID0gMDtcbiAgICB0aW1lLmlzRGF0ZSA9IGZhbHNlO1xuXG4gICAgdGhpcy5mcm9tRGF0YShkYXRhLCB6b25lKTtcbiAgfTtcblxuICBJQ0FMLlRpbWUuX2Rvd0NhY2hlID0ge307XG4gIElDQUwuVGltZS5fd25DYWNoZSA9IHt9O1xuXG4gIElDQUwuVGltZS5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2xhc3MgaWRlbnRpZmllci5cbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IFwiaWNhbHRpbWVcIlxuICAgICAqL1xuICAgIGljYWxjbGFzczogXCJpY2FsdGltZVwiLFxuICAgIF9jYWNoZWRVbml4VGltZTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG5hbWUsIHRvIGJlIHVzZWQgaW4gdGhlIGpDYWwgb2JqZWN0LiBUaGlzIHZhbHVlIG1heSBjaGFuZ2UgYW5kXG4gICAgICogaXMgc3RyaWN0bHkgZGVmaW5lZCBieSB0aGUge0BsaW5rIElDQUwuVGltZSNpc0RhdGUgaXNEYXRlfSBtZW1iZXIuXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBcImRhdGUtdGltZVwiXG4gICAgICovXG4gICAgZ2V0IGljYWx0eXBlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNEYXRlID8gJ2RhdGUnIDogJ2RhdGUtdGltZSc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB0aW1lem9uZSBmb3IgdGhpcyB0aW1lLlxuICAgICAqIEB0eXBlIHtJQ0FMLlRpbWV6b25lfVxuICAgICAqL1xuICAgIHpvbmU6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCB1c2VzIHRvIGluZGljYXRlIHRoYXQgYSBjaGFuZ2UgaGFzIGJlZW4gbWFkZSBhbmQgdGhlIG5leHQgcmVhZFxuICAgICAqIG9wZXJhdGlvbiBtdXN0IGF0dGVtcHQgdG8gbm9ybWFsaXplIHRoZSB2YWx1ZSAoZm9yIGV4YW1wbGUgY2hhbmdpbmcgdGhlXG4gICAgICogZGF5IHRvIDMzKS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3BlbmRpbmdOb3JtYWxpemF0aW9uOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgdGltZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlRpbWV9ICAgICAgICAgICAgICBUaGUgY2xvbmVkIG9iamVjdFxuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgSUNBTC5UaW1lKHRoaXMuX3RpbWUsIHRoaXMuem9uZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSB0aW1lIGluc3RhbmNlIHRvIGVwb2NoIHRpbWVcbiAgICAgKi9cbiAgICByZXNldDogZnVuY3Rpb24gaWNhbHRpbWVfcmVzZXQoKSB7XG4gICAgICB0aGlzLmZyb21EYXRhKElDQUwuVGltZS5lcG9jaFRpbWUpO1xuICAgICAgdGhpcy56b25lID0gSUNBTC5UaW1lem9uZS51dGNUaW1lem9uZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIHRpbWUgaW5zdGFuY2UgdG8gdGhlIGdpdmVuIGRhdGUvdGltZSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geWVhciAgICAgICAgICAgICBUaGUgeWVhciB0byBzZXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbW9udGggICAgICAgICAgICBUaGUgbW9udGggdG8gc2V0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRheSAgICAgICAgICAgICAgVGhlIGRheSB0byBzZXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaG91ciAgICAgICAgICAgICBUaGUgaG91ciB0byBzZXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbWludXRlICAgICAgICAgICBUaGUgbWludXRlIHRvIHNldFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzZWNvbmQgICAgICAgICAgIFRoZSBzZWNvbmQgdG8gc2V0XG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWV6b25lfSB0aW1lem9uZSAgVGhlIHRpbWV6b25lIHRvIHNldFxuICAgICAqL1xuICAgIHJlc2V0VG86IGZ1bmN0aW9uIGljYWx0aW1lX3Jlc2V0VG8oeWVhciwgbW9udGgsIGRheSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCB0aW1lem9uZSkge1xuICAgICAgdGhpcy5mcm9tRGF0YSh7XG4gICAgICAgIHllYXI6IHllYXIsXG4gICAgICAgIG1vbnRoOiBtb250aCxcbiAgICAgICAgZGF5OiBkYXksXG4gICAgICAgIGhvdXI6IGhvdXIsXG4gICAgICAgIG1pbnV0ZTogbWludXRlLFxuICAgICAgICBzZWNvbmQ6IHNlY29uZCxcbiAgICAgICAgem9uZTogdGltZXpvbmVcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdXAgdGhlIGN1cnJlbnQgaW5zdGFuY2UgZnJvbSB0aGUgSmF2YXNjcmlwdCBkYXRlIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/RGF0ZX0gYURhdGUgICAgIFRoZSBKYXZhc2NyaXB0IERhdGUgdG8gcmVhZCwgb3IgbnVsbCB0byByZXNldFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdXNlVVRDICBJZiB0cnVlLCB0aGUgVVRDIHZhbHVlcyBvZiB0aGUgZGF0ZSB3aWxsIGJlIHVzZWRcbiAgICAgKi9cbiAgICBmcm9tSlNEYXRlOiBmdW5jdGlvbiBpY2FsdGltZV9mcm9tSlNEYXRlKGFEYXRlLCB1c2VVVEMpIHtcbiAgICAgIGlmICghYURhdGUpIHtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHVzZVVUQykge1xuICAgICAgICAgIHRoaXMuem9uZSA9IElDQUwuVGltZXpvbmUudXRjVGltZXpvbmU7XG4gICAgICAgICAgdGhpcy55ZWFyID0gYURhdGUuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICAgICAgICB0aGlzLm1vbnRoID0gYURhdGUuZ2V0VVRDTW9udGgoKSArIDE7XG4gICAgICAgICAgdGhpcy5kYXkgPSBhRGF0ZS5nZXRVVENEYXRlKCk7XG4gICAgICAgICAgdGhpcy5ob3VyID0gYURhdGUuZ2V0VVRDSG91cnMoKTtcbiAgICAgICAgICB0aGlzLm1pbnV0ZSA9IGFEYXRlLmdldFVUQ01pbnV0ZXMoKTtcbiAgICAgICAgICB0aGlzLnNlY29uZCA9IGFEYXRlLmdldFVUQ1NlY29uZHMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnpvbmUgPSBJQ0FMLlRpbWV6b25lLmxvY2FsVGltZXpvbmU7XG4gICAgICAgICAgdGhpcy55ZWFyID0gYURhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgICB0aGlzLm1vbnRoID0gYURhdGUuZ2V0TW9udGgoKSArIDE7XG4gICAgICAgICAgdGhpcy5kYXkgPSBhRGF0ZS5nZXREYXRlKCk7XG4gICAgICAgICAgdGhpcy5ob3VyID0gYURhdGUuZ2V0SG91cnMoKTtcbiAgICAgICAgICB0aGlzLm1pbnV0ZSA9IGFEYXRlLmdldE1pbnV0ZXMoKTtcbiAgICAgICAgICB0aGlzLnNlY29uZCA9IGFEYXRlLmdldFNlY29uZHMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fY2FjaGVkVW5peFRpbWUgPSBudWxsO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdXAgdGhlIGN1cnJlbnQgaW5zdGFuY2UgdXNpbmcgbWVtYmVycyBmcm9tIHRoZSBwYXNzZWQgZGF0YSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYURhdGEgICAgICAgICAgICBUaW1lIGluaXRpYWxpemF0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS55ZWFyICAgICAgVGhlIHllYXIgZm9yIHRoaXMgZGF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEubW9udGggICAgIFRoZSBtb250aCBmb3IgdGhpcyBkYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5kYXkgICAgICAgVGhlIGRheSBmb3IgdGhpcyBkYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5ob3VyICAgICAgVGhlIGhvdXIgZm9yIHRoaXMgZGF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEubWludXRlICAgIFRoZSBtaW51dGUgZm9yIHRoaXMgZGF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEuc2Vjb25kICAgIFRoZSBzZWNvbmQgZm9yIHRoaXMgZGF0ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbj19IGFEYXRhLmlzRGF0ZSAgIElmIHRydWUsIHRoZSBpbnN0YW5jZSByZXByZXNlbnRzIGEgZGF0ZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGFzIG9wcG9zZWQgdG8gYSBkYXRlLXRpbWUpXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWV6b25lPX0gYVpvbmUgICAgVGltZXpvbmUgdGhpcyBwb3NpdGlvbiBvY2N1cnMgaW5cbiAgICAgKi9cbiAgICBmcm9tRGF0YTogZnVuY3Rpb24gZnJvbURhdGEoYURhdGEsIGFab25lKSB7XG4gICAgICBpZiAoYURhdGEpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGFEYXRhKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFEYXRhLCBrZXkpKSB7XG4gICAgICAgICAgICAvLyBpY2FsIHR5cGUgY2Fubm90IGJlIHNldFxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2ljYWx0eXBlJykgY29udGludWU7XG4gICAgICAgICAgICB0aGlzW2tleV0gPSBhRGF0YVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYVpvbmUpIHtcbiAgICAgICAgdGhpcy56b25lID0gYVpvbmU7XG4gICAgICB9XG5cbiAgICAgIGlmIChhRGF0YSAmJiAhKFwiaXNEYXRlXCIgaW4gYURhdGEpKSB7XG4gICAgICAgIHRoaXMuaXNEYXRlID0gIShcImhvdXJcIiBpbiBhRGF0YSk7XG4gICAgICB9IGVsc2UgaWYgKGFEYXRhICYmIChcImlzRGF0ZVwiIGluIGFEYXRhKSkge1xuICAgICAgICB0aGlzLmlzRGF0ZSA9IGFEYXRhLmlzRGF0ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFEYXRhICYmIFwidGltZXpvbmVcIiBpbiBhRGF0YSkge1xuICAgICAgICB2YXIgem9uZSA9IElDQUwuVGltZXpvbmVTZXJ2aWNlLmdldChcbiAgICAgICAgICBhRGF0YS50aW1lem9uZVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuem9uZSA9IHpvbmUgfHwgSUNBTC5UaW1lem9uZS5sb2NhbFRpbWV6b25lO1xuICAgICAgfVxuXG4gICAgICBpZiAoYURhdGEgJiYgXCJ6b25lXCIgaW4gYURhdGEpIHtcbiAgICAgICAgdGhpcy56b25lID0gYURhdGEuem9uZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLnpvbmUpIHtcbiAgICAgICAgdGhpcy56b25lID0gSUNBTC5UaW1lem9uZS5sb2NhbFRpbWV6b25lO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jYWNoZWRVbml4VGltZSA9IG51bGw7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBkYXkgb2Ygd2Vlay5cbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZS53ZWVrRGF5PX0gYVdlZWtTdGFydFxuICAgICAqICAgICAgICBUaGUgd2VlayBzdGFydCB3ZWVrZGF5LCBkZWZhdWx0cyB0byBTVU5EQVlcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlRpbWUud2Vla0RheX1cbiAgICAgKi9cbiAgICBkYXlPZldlZWs6IGZ1bmN0aW9uIGljYWx0aW1lX2RheU9mV2VlayhhV2Vla1N0YXJ0KSB7XG4gICAgICB2YXIgZmlyc3REb3cgPSBhV2Vla1N0YXJ0IHx8IElDQUwuVGltZS5TVU5EQVk7XG4gICAgICB2YXIgZG93Q2FjaGVLZXkgPSAodGhpcy55ZWFyIDw8IDEyKSArICh0aGlzLm1vbnRoIDw8IDgpICsgKHRoaXMuZGF5IDw8IDMpICsgZmlyc3REb3c7XG4gICAgICBpZiAoZG93Q2FjaGVLZXkgaW4gSUNBTC5UaW1lLl9kb3dDYWNoZSkge1xuICAgICAgICByZXR1cm4gSUNBTC5UaW1lLl9kb3dDYWNoZVtkb3dDYWNoZUtleV07XG4gICAgICB9XG5cbiAgICAgIC8vIFVzaW5nIFplbGxlcidzIGFsZ29yaXRobVxuICAgICAgdmFyIHEgPSB0aGlzLmRheTtcbiAgICAgIHZhciBtID0gdGhpcy5tb250aCArICh0aGlzLm1vbnRoIDwgMyA/IDEyIDogMCk7XG4gICAgICB2YXIgWSA9IHRoaXMueWVhciAtICh0aGlzLm1vbnRoIDwgMyA/IDEgOiAwKTtcblxuICAgICAgdmFyIGggPSAocSArIFkgKyBJQ0FMLmhlbHBlcnMudHJ1bmMoKChtICsgMSkgKiAyNikgLyAxMCkgKyBJQ0FMLmhlbHBlcnMudHJ1bmMoWSAvIDQpKTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAodHJ1ZSAvKiBncmVnb3JpYW4gKi8pIHtcbiAgICAgICAgaCArPSBJQ0FMLmhlbHBlcnMudHJ1bmMoWSAvIDEwMCkgKiA2ICsgSUNBTC5oZWxwZXJzLnRydW5jKFkgLyA0MDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaCArPSA1O1xuICAgICAgfVxuXG4gICAgICAvLyBOb3JtYWxpemUgdG8gMSA9IHdrc3RcbiAgICAgIGggPSAoKGggKyA3IC0gZmlyc3REb3cpICUgNykgKyAxO1xuICAgICAgSUNBTC5UaW1lLl9kb3dDYWNoZVtkb3dDYWNoZUtleV0gPSBoO1xuICAgICAgcmV0dXJuIGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgZGF5IG9mIHllYXIuXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGRheU9mWWVhcjogZnVuY3Rpb24gZGF5T2ZZZWFyKCkge1xuICAgICAgdmFyIGlzX2xlYXAgPSAoSUNBTC5UaW1lLmlzTGVhcFllYXIodGhpcy55ZWFyKSA/IDEgOiAwKTtcbiAgICAgIHZhciBkaXlwbSA9IElDQUwuVGltZS5kYXlzSW5ZZWFyUGFzc2VkTW9udGg7XG4gICAgICByZXR1cm4gZGl5cG1baXNfbGVhcF1bdGhpcy5tb250aCAtIDFdICsgdGhpcy5kYXk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IGRhdGUvdGltZSwgcmV3b3VuZCB0byB0aGUgc3RhcnQgb2YgdGhlXG4gICAgICogd2Vlay4gVGhlIHJlc3VsdGluZyBJQ0FMLlRpbWUgaW5zdGFuY2UgaXMgb2YgaWNhbHR5cGUgZGF0ZSwgZXZlbiBpZiB0aGlzXG4gICAgICogaXMgYSBkYXRlLXRpbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZS53ZWVrRGF5PX0gYVdlZWtTdGFydFxuICAgICAqICAgICAgICBUaGUgd2VlayBzdGFydCB3ZWVrZGF5LCBkZWZhdWx0cyB0byBTVU5EQVlcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlRpbWV9ICAgICAgVGhlIHN0YXJ0IG9mIHRoZSB3ZWVrIChjbG9uZWQpXG4gICAgICovXG4gICAgc3RhcnRPZldlZWs6IGZ1bmN0aW9uIHN0YXJ0T2ZXZWVrKGFXZWVrU3RhcnQpIHtcbiAgICAgIHZhciBmaXJzdERvdyA9IGFXZWVrU3RhcnQgfHwgSUNBTC5UaW1lLlNVTkRBWTtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNsb25lKCk7XG4gICAgICByZXN1bHQuZGF5IC09ICgodGhpcy5kYXlPZldlZWsoKSArIDcgLSBmaXJzdERvdykgJSA3KTtcbiAgICAgIHJlc3VsdC5pc0RhdGUgPSB0cnVlO1xuICAgICAgcmVzdWx0LmhvdXIgPSAwO1xuICAgICAgcmVzdWx0Lm1pbnV0ZSA9IDA7XG4gICAgICByZXN1bHQuc2Vjb25kID0gMDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IGRhdGUvdGltZSwgc2hpZnRlZCB0byB0aGUgZW5kIG9mIHRoZSB3ZWVrLlxuICAgICAqIFRoZSByZXN1bHRpbmcgSUNBTC5UaW1lIGluc3RhbmNlIGlzIG9mIGljYWx0eXBlIGRhdGUsIGV2ZW4gaWYgdGhpcyBpcyBhXG4gICAgICogZGF0ZS10aW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWUud2Vla0RheT19IGFXZWVrU3RhcnRcbiAgICAgKiAgICAgICAgVGhlIHdlZWsgc3RhcnQgd2Vla2RheSwgZGVmYXVsdHMgdG8gU1VOREFZXG4gICAgICogQHJldHVybiB7SUNBTC5UaW1lfSAgICAgIFRoZSBlbmQgb2YgdGhlIHdlZWsgKGNsb25lZClcbiAgICAgKi9cbiAgICBlbmRPZldlZWs6IGZ1bmN0aW9uIGVuZE9mV2VlayhhV2Vla1N0YXJ0KSB7XG4gICAgICB2YXIgZmlyc3REb3cgPSBhV2Vla1N0YXJ0IHx8IElDQUwuVGltZS5TVU5EQVk7XG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgcmVzdWx0LmRheSArPSAoNyAtIHRoaXMuZGF5T2ZXZWVrKCkgKyBmaXJzdERvdyAtIElDQUwuVGltZS5TVU5EQVkpICUgNztcbiAgICAgIHJlc3VsdC5pc0RhdGUgPSB0cnVlO1xuICAgICAgcmVzdWx0LmhvdXIgPSAwO1xuICAgICAgcmVzdWx0Lm1pbnV0ZSA9IDA7XG4gICAgICByZXN1bHQuc2Vjb25kID0gMDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IGRhdGUvdGltZSwgcmV3b3VuZCB0byB0aGUgc3RhcnQgb2YgdGhlXG4gICAgICogbW9udGguIFRoZSByZXN1bHRpbmcgSUNBTC5UaW1lIGluc3RhbmNlIGlzIG9mIGljYWx0eXBlIGRhdGUsIGV2ZW4gaWZcbiAgICAgKiB0aGlzIGlzIGEgZGF0ZS10aW1lLlxuICAgICAqXG4gICAgICogQHJldHVybiB7SUNBTC5UaW1lfSAgICAgIFRoZSBzdGFydCBvZiB0aGUgbW9udGggKGNsb25lZClcbiAgICAgKi9cbiAgICBzdGFydE9mTW9udGg6IGZ1bmN0aW9uIHN0YXJ0T2ZNb250aCgpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNsb25lKCk7XG4gICAgICByZXN1bHQuZGF5ID0gMTtcbiAgICAgIHJlc3VsdC5pc0RhdGUgPSB0cnVlO1xuICAgICAgcmVzdWx0LmhvdXIgPSAwO1xuICAgICAgcmVzdWx0Lm1pbnV0ZSA9IDA7XG4gICAgICByZXN1bHQuc2Vjb25kID0gMDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IGRhdGUvdGltZSwgc2hpZnRlZCB0byB0aGUgZW5kIG9mIHRoZVxuICAgICAqIG1vbnRoLiAgVGhlIHJlc3VsdGluZyBJQ0FMLlRpbWUgaW5zdGFuY2UgaXMgb2YgaWNhbHR5cGUgZGF0ZSwgZXZlbiBpZlxuICAgICAqIHRoaXMgaXMgYSBkYXRlLXRpbWUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlRpbWV9ICAgICAgVGhlIGVuZCBvZiB0aGUgbW9udGggKGNsb25lZClcbiAgICAgKi9cbiAgICBlbmRPZk1vbnRoOiBmdW5jdGlvbiBlbmRPZk1vbnRoKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgIHJlc3VsdC5kYXkgPSBJQ0FMLlRpbWUuZGF5c0luTW9udGgocmVzdWx0Lm1vbnRoLCByZXN1bHQueWVhcik7XG4gICAgICByZXN1bHQuaXNEYXRlID0gdHJ1ZTtcbiAgICAgIHJlc3VsdC5ob3VyID0gMDtcbiAgICAgIHJlc3VsdC5taW51dGUgPSAwO1xuICAgICAgcmVzdWx0LnNlY29uZCA9IDA7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBkYXRlL3RpbWUsIHJld291bmQgdG8gdGhlIHN0YXJ0IG9mIHRoZVxuICAgICAqIHllYXIuIFRoZSByZXN1bHRpbmcgSUNBTC5UaW1lIGluc3RhbmNlIGlzIG9mIGljYWx0eXBlIGRhdGUsIGV2ZW4gaWZcbiAgICAgKiB0aGlzIGlzIGEgZGF0ZS10aW1lLlxuICAgICAqXG4gICAgICogQHJldHVybiB7SUNBTC5UaW1lfSAgICAgIFRoZSBzdGFydCBvZiB0aGUgeWVhciAoY2xvbmVkKVxuICAgICAqL1xuICAgIHN0YXJ0T2ZZZWFyOiBmdW5jdGlvbiBzdGFydE9mWWVhcigpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNsb25lKCk7XG4gICAgICByZXN1bHQuZGF5ID0gMTtcbiAgICAgIHJlc3VsdC5tb250aCA9IDE7XG4gICAgICByZXN1bHQuaXNEYXRlID0gdHJ1ZTtcbiAgICAgIHJlc3VsdC5ob3VyID0gMDtcbiAgICAgIHJlc3VsdC5taW51dGUgPSAwO1xuICAgICAgcmVzdWx0LnNlY29uZCA9IDA7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBkYXRlL3RpbWUsIHNoaWZ0ZWQgdG8gdGhlIGVuZCBvZiB0aGVcbiAgICAgKiB5ZWFyLiAgVGhlIHJlc3VsdGluZyBJQ0FMLlRpbWUgaW5zdGFuY2UgaXMgb2YgaWNhbHR5cGUgZGF0ZSwgZXZlbiBpZlxuICAgICAqIHRoaXMgaXMgYSBkYXRlLXRpbWUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlRpbWV9ICAgICAgVGhlIGVuZCBvZiB0aGUgeWVhciAoY2xvbmVkKVxuICAgICAqL1xuICAgIGVuZE9mWWVhcjogZnVuY3Rpb24gZW5kT2ZZZWFyKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgIHJlc3VsdC5kYXkgPSAzMTtcbiAgICAgIHJlc3VsdC5tb250aCA9IDEyO1xuICAgICAgcmVzdWx0LmlzRGF0ZSA9IHRydWU7XG4gICAgICByZXN1bHQuaG91ciA9IDA7XG4gICAgICByZXN1bHQubWludXRlID0gMDtcbiAgICAgIHJlc3VsdC5zZWNvbmQgPSAwO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmlyc3QgY2FsY3VsYXRlcyB0aGUgc3RhcnQgb2YgdGhlIHdlZWssIHRoZW4gcmV0dXJucyB0aGUgZGF5IG9mIHllYXIgZm9yXG4gICAgICogdGhpcyBkYXRlLiBJZiB0aGUgZGF5IGZhbGxzIGludG8gdGhlIHByZXZpb3VzIHllYXIsIHRoZSBkYXkgaXMgemVybyBvciBuZWdhdGl2ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SUNBTC5UaW1lLndlZWtEYXk9fSBhRmlyc3REYXlPZldlZWtcbiAgICAgKiAgICAgICAgVGhlIHdlZWsgc3RhcnQgd2Vla2RheSwgZGVmYXVsdHMgdG8gU1VOREFZXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAgICAgVGhlIGNhbGN1bGF0ZWQgZGF5IG9mIHllYXJcbiAgICAgKi9cbiAgICBzdGFydERveVdlZWs6IGZ1bmN0aW9uIHN0YXJ0RG95V2VlayhhRmlyc3REYXlPZldlZWspIHtcbiAgICAgIHZhciBmaXJzdERvdyA9IGFGaXJzdERheU9mV2VlayB8fCBJQ0FMLlRpbWUuU1VOREFZO1xuICAgICAgdmFyIGRlbHRhID0gdGhpcy5kYXlPZldlZWsoKSAtIGZpcnN0RG93O1xuICAgICAgaWYgKGRlbHRhIDwgMCkgZGVsdGEgKz0gNztcbiAgICAgIHJldHVybiB0aGlzLmRheU9mWWVhcigpIC0gZGVsdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZG9taW5pY2FsIGxldHRlciBmb3IgdGhlIGN1cnJlbnQgeWVhci4gTGV0dGVycyByYW5nZSBmcm9tIEEgLSBHXG4gICAgICogZm9yIGNvbW1vbiB5ZWFycywgYW5kIEFHIHRvIEdGIGZvciBsZWFwIHllYXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlyICAgICAgICAgICBUaGUgeWVhciB0byByZXRyaWV2ZSB0aGUgbGV0dGVyIGZvclxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgICAgVGhlIGRvbWluaWNhbCBsZXR0ZXIuXG4gICAgICovXG4gICAgZ2V0RG9taW5pY2FsTGV0dGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBJQ0FMLlRpbWUuZ2V0RG9taW5pY2FsTGV0dGVyKHRoaXMueWVhcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBudGhXZWVrRGF5IHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IG1vbnRoIChub3QgZGF5KS4gIFRoZVxuICAgICAqIHJldHVybmVkIHZhbHVlIGlzIGEgZGF5IHJlbGF0aXZlIHRoZSBtb250aCB0aGF0IHRoaXMgbW9udGggYmVsb25ncyB0byBzb1xuICAgICAqIDEgd291bGQgaW5kaWNhdGUgdGhlIGZpcnN0IG9mIHRoZSBtb250aCBhbmQgNDAgd291bGQgaW5kaWNhdGUgYSBkYXkgaW5cbiAgICAgKiB0aGUgZm9sbG93aW5nIG1vbnRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXlPZldlZWsgICBEYXkgb2YgdGhlIHdlZWsgc2VlIHRoZSBkYXkgbmFtZSBjb25zdGFudHNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYVBvcyAgICAgICAgIE50aCBvY2N1cnJlbmNlIG9mIGEgZ2l2ZW4gd2VlayBkYXkgdmFsdWVzXG4gICAgICogICAgICAgIG9mIDEgYW5kIDAgYm90aCBpbmRpY2F0ZSB0aGUgZmlyc3Qgd2Vla2RheSBvZiB0aGF0IHR5cGUuIGFQb3MgbWF5XG4gICAgICogICAgICAgIGJlIGVpdGhlciBwb3NpdGl2ZSBvciBuZWdhdGl2ZVxuICAgICAqXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBudW1lcmljIHZhbHVlIGluZGljYXRpbmcgYSBkYXkgcmVsYXRpdmVcbiAgICAgKiAgICAgICAgICAgICAgICAgICB0byB0aGUgY3VycmVudCBtb250aCBvZiB0aGlzIHRpbWUgb2JqZWN0XG4gICAgICovXG4gICAgbnRoV2Vla0RheTogZnVuY3Rpb24gaWNhbHRpbWVfbnRoV2Vla0RheShhRGF5T2ZXZWVrLCBhUG9zKSB7XG4gICAgICB2YXIgZGF5c0luTW9udGggPSBJQ0FMLlRpbWUuZGF5c0luTW9udGgodGhpcy5tb250aCwgdGhpcy55ZWFyKTtcbiAgICAgIHZhciB3ZWVrZGF5O1xuICAgICAgdmFyIHBvcyA9IGFQb3M7XG5cbiAgICAgIHZhciBzdGFydCA9IDA7XG5cbiAgICAgIHZhciBvdGhlckRheSA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAgIG90aGVyRGF5LmRheSA9IDE7XG5cbiAgICAgICAgLy8gYmVjYXVzZSAwIG1lYW5zIG5vIHBvc2l0aW9uIGhhcyBiZWVuIGdpdmVuXG4gICAgICAgIC8vIDEgYW5kIDAgaW5kaWNhdGUgdGhlIHNhbWUgZGF5LlxuICAgICAgICBpZiAocG9zICE9IDApIHtcbiAgICAgICAgICAvLyByZW1vdmUgdGhlIGV4dHJhIG51bWVyaWMgdmFsdWVcbiAgICAgICAgICBwb3MtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCBjdXJyZW50IHN0YXJ0IG9mZnNldCB0byBjdXJyZW50IGRheS5cbiAgICAgICAgc3RhcnQgPSBvdGhlckRheS5kYXk7XG5cbiAgICAgICAgLy8gZmluZCB0aGUgY3VycmVudCBkYXkgb2Ygd2Vla1xuICAgICAgICB2YXIgc3RhcnREb3cgPSBvdGhlckRheS5kYXlPZldlZWsoKTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBjdXJyZW50XG4gICAgICAgIC8vIGRheSBvZiB0aGUgd2VlayBhbmQgZGVzaXJlZCBkYXkgb2YgdGhlIHdlZWtcbiAgICAgICAgdmFyIG9mZnNldCA9IGFEYXlPZldlZWsgLSBzdGFydERvdztcblxuXG4gICAgICAgIC8vIGlmIHRoZSBvZmZzZXQgZ29lcyBpbnRvIHRoZSBwYXN0XG4gICAgICAgIC8vIHdlZWsgd2UgYWRkIDcgc28gaXQgZ29lcyBpbnRvIHRoZSBuZXh0XG4gICAgICAgIC8vIHdlZWsuIFdlIG9ubHkgd2FudCB0byBnbyBmb3J3YXJkIGluIHRpbWUgaGVyZS5cbiAgICAgICAgaWYgKG9mZnNldCA8IDApXG4gICAgICAgICAgLy8gdGhpcyBpcyByZWFsbHkgaW1wb3J0YW50IG90aGVyd2lzZSB3ZSB3b3VsZFxuICAgICAgICAgIC8vIGVuZCB1cCB3aXRoIGRhdGVzIGZyb20gaW4gdGhlIHBhc3QuXG4gICAgICAgICAgb2Zmc2V0ICs9IDc7XG5cbiAgICAgICAgLy8gYWRkIG9mZnNldCB0byBzdGFydCBzbyBzdGFydCBpcyB0aGUgc2FtZVxuICAgICAgICAvLyBkYXkgb2YgdGhlIHdlZWsgYXMgdGhlIGRlc2lyZWQgZGF5IG9mIHdlZWsuXG4gICAgICAgIHN0YXJ0ICs9IG9mZnNldDtcblxuICAgICAgICAvLyBiZWNhdXNlIHdlIGFyZSBnb2luZyB0byBhZGQgKGFuZCBtdWx0aXBseSlcbiAgICAgICAgLy8gdGhlIG51bWVyaWMgdmFsdWUgb2YgdGhlIGRheSB3ZSBzdWJ0cmFjdCBpdFxuICAgICAgICAvLyBmcm9tIHRoZSBzdGFydCBwb3NpdGlvbiBzbyBub3QgdG8gYWRkIGl0IHR3aWNlLlxuICAgICAgICBzdGFydCAtPSBhRGF5T2ZXZWVrO1xuXG4gICAgICAgIC8vIHNldCB3ZWVrIGRheVxuICAgICAgICB3ZWVrZGF5ID0gYURheU9mV2VlaztcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gdGhlbiB3ZSBzZXQgaXQgdG8gdGhlIGxhc3QgZGF5IGluIHRoZSBjdXJyZW50IG1vbnRoXG4gICAgICAgIG90aGVyRGF5LmRheSA9IGRheXNJbk1vbnRoO1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIGVuZHMgd2Vla2RheVxuICAgICAgICB2YXIgZW5kRG93ID0gb3RoZXJEYXkuZGF5T2ZXZWVrKCk7XG5cbiAgICAgICAgcG9zKys7XG5cbiAgICAgICAgd2Vla2RheSA9IChlbmREb3cgLSBhRGF5T2ZXZWVrKTtcblxuICAgICAgICBpZiAod2Vla2RheSA8IDApIHtcbiAgICAgICAgICB3ZWVrZGF5ICs9IDc7XG4gICAgICAgIH1cblxuICAgICAgICB3ZWVrZGF5ID0gZGF5c0luTW9udGggLSB3ZWVrZGF5O1xuICAgICAgfVxuXG4gICAgICB3ZWVrZGF5ICs9IHBvcyAqIDc7XG5cbiAgICAgIHJldHVybiBzdGFydCArIHdlZWtkYXk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBjdXJyZW50IHRpbWUgaXMgdGhlIG50aCB3ZWVrZGF5LCByZWxhdGl2ZSB0byB0aGUgY3VycmVudFxuICAgICAqIG1vbnRoLiAgV2lsbCBhbHdheXMgcmV0dXJuIGZhbHNlIHdoZW4gcnVsZSByZXNvbHZlcyBvdXRzaWRlIG9mIGN1cnJlbnRcbiAgICAgKiBtb250aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SUNBTC5UaW1lLndlZWtEYXl9IGFEYXlPZldlZWsgICAgICAgRGF5IG9mIHdlZWsgdG8gY2hlY2tcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYVBvcyAgICAgICAgICAgICAgICAgICAgICAgIFJlbGF0aXZlIHBvc2l0aW9uXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgICAgICAgICAgICAgICAgICBUcnVlLCBpZiBpdCBpcyB0aGUgbnRoIHdlZWtkYXlcbiAgICAgKi9cbiAgICBpc050aFdlZWtEYXk6IGZ1bmN0aW9uKGFEYXlPZldlZWssIGFQb3MpIHtcbiAgICAgIHZhciBkb3cgPSB0aGlzLmRheU9mV2VlaygpO1xuXG4gICAgICBpZiAoYVBvcyA9PT0gMCAmJiBkb3cgPT09IGFEYXlPZldlZWspIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGdldCBwb3NcbiAgICAgIHZhciBkYXkgPSB0aGlzLm50aFdlZWtEYXkoYURheU9mV2VlaywgYVBvcyk7XG5cbiAgICAgIGlmIChkYXkgPT09IHRoaXMuZGF5KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIElTTyA4NjAxIHdlZWsgbnVtYmVyLiBUaGUgZmlyc3Qgd2VlayBvZiBhIHllYXIgaXMgdGhlXG4gICAgICogd2VlayB0aGF0IGNvbnRhaW5zIHRoZSBmaXJzdCBUaHVyc2RheS4gVGhlIHllYXIgY2FuIGhhdmUgNTMgd2Vla3MsIGlmXG4gICAgICogSmFudWFyeSAxc3QgaXMgYSBGcmlkYXkuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoZXJlIGFyZSByZWdpb25zIHdoZXJlIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyIGlzIHRoZSBvbmUgdGhhdFxuICAgICAqIHN0YXJ0cyBvbiBKYW51YXJ5IDFzdCwgd2hpY2ggbWF5IG9mZnNldCB0aGUgd2VlayBudW1iZXIuIEFsc28sIGlmIGFcbiAgICAgKiBkaWZmZXJlbnQgd2VlayBzdGFydCBpcyBzcGVjaWZpZWQsIHRoaXMgd2lsbCBhbHNvIGFmZmVjdCB0aGUgd2Vla1xuICAgICAqIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBzZWUgSUNBTC5UaW1lLndlZWtPbmVTdGFydHNcbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZS53ZWVrRGF5fSBhV2Vla1N0YXJ0ICAgICAgICBUaGUgd2Vla2RheSB0aGUgd2VlayBzdGFydHMgd2l0aFxuICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBJU08gd2VlayBudW1iZXJcbiAgICAgKi9cbiAgICB3ZWVrTnVtYmVyOiBmdW5jdGlvbiB3ZWVrTnVtYmVyKGFXZWVrU3RhcnQpIHtcbiAgICAgIHZhciB3bkNhY2hlS2V5ID0gKHRoaXMueWVhciA8PCAxMikgKyAodGhpcy5tb250aCA8PCA4KSArICh0aGlzLmRheSA8PCAzKSArIGFXZWVrU3RhcnQ7XG4gICAgICBpZiAod25DYWNoZUtleSBpbiBJQ0FMLlRpbWUuX3duQ2FjaGUpIHtcbiAgICAgICAgcmV0dXJuIElDQUwuVGltZS5fd25DYWNoZVt3bkNhY2hlS2V5XTtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgZnVuY3Rpb24gY291cnRlc3R5IG9mIEp1bGlhbiBCdWNrbmFsbCwgcHVibGlzaGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICAgICAgLy8gaHR0cDovL3d3dy5ib3lldC5jb20vYXJ0aWNsZXMvcHVibGlzaGVkYXJ0aWNsZXMvY2FsY3VsYXRpbmd0aGVpc293ZWVrbnVtYi5odG1sXG4gICAgICAvLyBwbHVzIHNvbWUgZml4ZXMgdG8gYmUgYWJsZSB0byB1c2UgZGlmZmVyZW50IHdlZWsgc3RhcnRzLlxuICAgICAgdmFyIHdlZWsxO1xuXG4gICAgICB2YXIgZHQgPSB0aGlzLmNsb25lKCk7XG4gICAgICBkdC5pc0RhdGUgPSB0cnVlO1xuICAgICAgdmFyIGlzb3llYXIgPSB0aGlzLnllYXI7XG5cbiAgICAgIGlmIChkdC5tb250aCA9PSAxMiAmJiBkdC5kYXkgPiAyNSkge1xuICAgICAgICB3ZWVrMSA9IElDQUwuVGltZS53ZWVrT25lU3RhcnRzKGlzb3llYXIgKyAxLCBhV2Vla1N0YXJ0KTtcbiAgICAgICAgaWYgKGR0LmNvbXBhcmUod2VlazEpIDwgMCkge1xuICAgICAgICAgIHdlZWsxID0gSUNBTC5UaW1lLndlZWtPbmVTdGFydHMoaXNveWVhciwgYVdlZWtTdGFydCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXNveWVhcisrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3ZWVrMSA9IElDQUwuVGltZS53ZWVrT25lU3RhcnRzKGlzb3llYXIsIGFXZWVrU3RhcnQpO1xuICAgICAgICBpZiAoZHQuY29tcGFyZSh3ZWVrMSkgPCAwKSB7XG4gICAgICAgICAgd2VlazEgPSBJQ0FMLlRpbWUud2Vla09uZVN0YXJ0cygtLWlzb3llYXIsIGFXZWVrU3RhcnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBkYXlzQmV0d2VlbiA9IChkdC5zdWJ0cmFjdERhdGUod2VlazEpLnRvU2Vjb25kcygpIC8gODY0MDApO1xuICAgICAgdmFyIGFuc3dlciA9IElDQUwuaGVscGVycy50cnVuYyhkYXlzQmV0d2VlbiAvIDcpICsgMTtcbiAgICAgIElDQUwuVGltZS5fd25DYWNoZVt3bkNhY2hlS2V5XSA9IGFuc3dlcjtcbiAgICAgIHJldHVybiBhbnN3ZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIGR1cmF0aW9uIHRvIHRoZSBjdXJyZW50IHRpbWUuIFRoZSBpbnN0YW5jZSBpcyBtb2RpZmllZCBpblxuICAgICAqIHBsYWNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLkR1cmF0aW9ufSBhRHVyYXRpb24gICAgICAgICBUaGUgZHVyYXRpb24gdG8gYWRkXG4gICAgICovXG4gICAgYWRkRHVyYXRpb246IGZ1bmN0aW9uIGljYWx0aW1lX2FkZChhRHVyYXRpb24pIHtcbiAgICAgIHZhciBtdWx0ID0gKGFEdXJhdGlvbi5pc05lZ2F0aXZlID8gLTEgOiAxKTtcblxuICAgICAgLy8gYmVjYXVzZSBvZiB0aGUgZHVyYXRpb24gb3B0aW1pemF0aW9ucyBpdCBpcyBtdWNoXG4gICAgICAvLyBtb3JlIGVmZmljaWVudCB0byBncmFiIGFsbCB0aGUgdmFsdWVzIHVwIGZyb250XG4gICAgICAvLyB0aGVuIHNldCB0aGVtIGRpcmVjdGx5ICh3aGljaCB3aWxsIGF2b2lkIGEgbm9ybWFsaXphdGlvbiBjYWxsKS5cbiAgICAgIC8vIFNvIHdlIGRvbid0IGFjdHVhbGx5IG5vcm1hbGl6ZSB1bnRpbCB3ZSBuZWVkIGl0LlxuICAgICAgdmFyIHNlY29uZCA9IHRoaXMuc2Vjb25kO1xuICAgICAgdmFyIG1pbnV0ZSA9IHRoaXMubWludXRlO1xuICAgICAgdmFyIGhvdXIgPSB0aGlzLmhvdXI7XG4gICAgICB2YXIgZGF5ID0gdGhpcy5kYXk7XG5cbiAgICAgIHNlY29uZCArPSBtdWx0ICogYUR1cmF0aW9uLnNlY29uZHM7XG4gICAgICBtaW51dGUgKz0gbXVsdCAqIGFEdXJhdGlvbi5taW51dGVzO1xuICAgICAgaG91ciArPSBtdWx0ICogYUR1cmF0aW9uLmhvdXJzO1xuICAgICAgZGF5ICs9IG11bHQgKiBhRHVyYXRpb24uZGF5cztcbiAgICAgIGRheSArPSBtdWx0ICogNyAqIGFEdXJhdGlvbi53ZWVrcztcblxuICAgICAgdGhpcy5zZWNvbmQgPSBzZWNvbmQ7XG4gICAgICB0aGlzLm1pbnV0ZSA9IG1pbnV0ZTtcbiAgICAgIHRoaXMuaG91ciA9IGhvdXI7XG4gICAgICB0aGlzLmRheSA9IGRheTtcblxuICAgICAgdGhpcy5fY2FjaGVkVW5peFRpbWUgPSBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdCB0aGUgZGF0ZSBkZXRhaWxzIChfZXhjbHVkaW5nXyB0aW1lem9uZSkuICBVc2VmdWwgZm9yIGZpbmRpbmdcbiAgICAgKiB0aGUgcmVsYXRpdmUgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byB0aW1lIG9iamVjdHMgZXhjbHVkaW5nIHRoZWlyXG4gICAgICogdGltZXpvbmUgZGlmZmVyZW5jZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZX0gYURhdGUgICAgIFRoZSBkYXRlIHRvIHN1YnN0cmFjdFxuICAgICAqIEByZXR1cm4ge0lDQUwuRHVyYXRpb259ICAgICAgVGhlIGRpZmZlcmVuY2UgYXMgYSBkdXJhdGlvblxuICAgICAqL1xuICAgIHN1YnRyYWN0RGF0ZTogZnVuY3Rpb24gaWNhbHRpbWVfc3VidHJhY3QoYURhdGUpIHtcbiAgICAgIHZhciB1bml4VGltZSA9IHRoaXMudG9Vbml4VGltZSgpICsgdGhpcy51dGNPZmZzZXQoKTtcbiAgICAgIHZhciBvdGhlciA9IGFEYXRlLnRvVW5peFRpbWUoKSArIGFEYXRlLnV0Y09mZnNldCgpO1xuICAgICAgcmV0dXJuIElDQUwuRHVyYXRpb24uZnJvbVNlY29uZHModW5peFRpbWUgLSBvdGhlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0IHRoZSBkYXRlIGRldGFpbHMsIHRha2luZyB0aW1lem9uZXMgaW50byBhY2NvdW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWV9IGFEYXRlICBUaGUgZGF0ZSB0byBzdWJ0cmFjdFxuICAgICAqIEByZXR1cm4ge0lDQUwuRHVyYXRpb259ICBUaGUgZGlmZmVyZW5jZSBpbiBkdXJhdGlvblxuICAgICAqL1xuICAgIHN1YnRyYWN0RGF0ZVR6OiBmdW5jdGlvbiBpY2FsdGltZV9zdWJ0cmFjdF9hYnMoYURhdGUpIHtcbiAgICAgIHZhciB1bml4VGltZSA9IHRoaXMudG9Vbml4VGltZSgpO1xuICAgICAgdmFyIG90aGVyID0gYURhdGUudG9Vbml4VGltZSgpO1xuICAgICAgcmV0dXJuIElDQUwuRHVyYXRpb24uZnJvbVNlY29uZHModW5peFRpbWUgLSBvdGhlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbXBhcmVzIHRoZSBJQ0FMLlRpbWUgaW5zdGFuY2Ugd2l0aCBhbm90aGVyIG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SUNBTC5EdXJhdGlvbn0gYU90aGVyICAgICAgICBUaGUgaW5zdGFuY2UgdG8gY29tcGFyZSB3aXRoXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgICAgICAgICAgIC0xLCAwIG9yIDEgZm9yIGxlc3MvZXF1YWwvZ3JlYXRlclxuICAgICAqL1xuICAgIGNvbXBhcmU6IGZ1bmN0aW9uIGljYWx0aW1lX2NvbXBhcmUob3RoZXIpIHtcbiAgICAgIHZhciBhID0gdGhpcy50b1VuaXhUaW1lKCk7XG4gICAgICB2YXIgYiA9IG90aGVyLnRvVW5peFRpbWUoKTtcblxuICAgICAgaWYgKGEgPiBiKSByZXR1cm4gMTtcbiAgICAgIGlmIChiID4gYSkgcmV0dXJuIC0xO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbXBhcmVzIG9ubHkgdGhlIGRhdGUgcGFydCBvZiB0aGlzIGluc3RhbmNlIHdpdGggYW5vdGhlciBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuRHVyYXRpb259IG90aGVyICAgICAgICAgVGhlIGluc3RhbmNlIHRvIGNvbXBhcmUgd2l0aFxuICAgICAqIEBwYXJhbSB7SUNBTC5UaW1lem9uZX0gdHogICAgICAgICAgICBUaGUgdGltZXpvbmUgdG8gY29tcGFyZSBpblxuICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgICAgICAgICAtMSwgMCBvciAxIGZvciBsZXNzL2VxdWFsL2dyZWF0ZXJcbiAgICAgKi9cbiAgICBjb21wYXJlRGF0ZU9ubHlUejogZnVuY3Rpb24gaWNhbHRpbWVfY29tcGFyZURhdGVPbmx5VHoob3RoZXIsIHR6KSB7XG4gICAgICBmdW5jdGlvbiBjbXAoYXR0cikge1xuICAgICAgICByZXR1cm4gSUNBTC5UaW1lLl9jbXBfYXR0cihhLCBiLCBhdHRyKTtcbiAgICAgIH1cbiAgICAgIHZhciBhID0gdGhpcy5jb252ZXJ0VG9ab25lKHR6KTtcbiAgICAgIHZhciBiID0gb3RoZXIuY29udmVydFRvWm9uZSh0eik7XG4gICAgICB2YXIgcmMgPSAwO1xuXG4gICAgICBpZiAoKHJjID0gY21wKFwieWVhclwiKSkgIT0gMCkgcmV0dXJuIHJjO1xuICAgICAgaWYgKChyYyA9IGNtcChcIm1vbnRoXCIpKSAhPSAwKSByZXR1cm4gcmM7XG4gICAgICBpZiAoKHJjID0gY21wKFwiZGF5XCIpKSAhPSAwKSByZXR1cm4gcmM7XG5cbiAgICAgIHJldHVybiByYztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCB0aGUgaW5zdGFuY2UgaW50byBhbm90aGVyIHRpbWV6b25lLiBUaGUgcmV0dXJuZWQgSUNBTC5UaW1lXG4gICAgICogaW5zdGFuY2UgaXMgYWx3YXlzIGEgY29weS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SUNBTC5UaW1lem9uZX0gem9uZSAgICAgIFRoZSB6b25lIHRvIGNvbnZlcnQgdG9cbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlRpbWV9ICAgICAgICAgICAgICBUaGUgY29weSwgY29udmVydGVkIHRvIHRoZSB6b25lXG4gICAgICovXG4gICAgY29udmVydFRvWm9uZTogZnVuY3Rpb24gY29udmVydFRvWm9uZSh6b25lKSB7XG4gICAgICB2YXIgY29weSA9IHRoaXMuY2xvbmUoKTtcbiAgICAgIHZhciB6b25lX2VxdWFscyA9ICh0aGlzLnpvbmUudHppZCA9PSB6b25lLnR6aWQpO1xuXG4gICAgICBpZiAoIXRoaXMuaXNEYXRlICYmICF6b25lX2VxdWFscykge1xuICAgICAgICBJQ0FMLlRpbWV6b25lLmNvbnZlcnRfdGltZShjb3B5LCB0aGlzLnpvbmUsIHpvbmUpO1xuICAgICAgfVxuXG4gICAgICBjb3B5LnpvbmUgPSB6b25lO1xuICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIFVUQyBvZmZzZXQgb2YgdGhlIGN1cnJlbnQgZGF0ZS90aW1lIGluIHRoZSB0aW1lem9uZSBpdCBpc1xuICAgICAqIGluLlxuICAgICAqXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAgICAgVVRDIG9mZnNldCBpbiBzZWNvbmRzXG4gICAgICovXG4gICAgdXRjT2Zmc2V0OiBmdW5jdGlvbiB1dGNfb2Zmc2V0KCkge1xuICAgICAgaWYgKHRoaXMuem9uZSA9PSBJQ0FMLlRpbWV6b25lLmxvY2FsVGltZXpvbmUgfHxcbiAgICAgICAgICB0aGlzLnpvbmUgPT0gSUNBTC5UaW1lem9uZS51dGNUaW1lem9uZSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnpvbmUudXRjT2Zmc2V0KHRoaXMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIFJGQyA1NTQ1IGNvbXBsaWFudCBpY2FsIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBpY2FsIGRhdGUvZGF0ZS10aW1lXG4gICAgICovXG4gICAgdG9JQ0FMU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzdHJpbmcgPSB0aGlzLnRvU3RyaW5nKCk7XG5cbiAgICAgIGlmIChzdHJpbmcubGVuZ3RoID4gMTApIHtcbiAgICAgICAgcmV0dXJuIElDQUwuZGVzaWduLmljYWxlbmRhci52YWx1ZVsnZGF0ZS10aW1lJ10udG9JQ0FMKHN0cmluZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gSUNBTC5kZXNpZ24uaWNhbGVuZGFyLnZhbHVlLmRhdGUudG9JQ0FMKHN0cmluZyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBkYXRlL3RpbWUsIGluIGpDYWwgZm9ybVxuICAgICAqIChpbmNsdWRpbmcgOiBhbmQgLSBzZXBhcmF0b3JzKS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMueWVhciArICctJyArXG4gICAgICAgICAgICAgICAgICAgSUNBTC5oZWxwZXJzLnBhZDIodGhpcy5tb250aCkgKyAnLScgK1xuICAgICAgICAgICAgICAgICAgIElDQUwuaGVscGVycy5wYWQyKHRoaXMuZGF5KTtcblxuICAgICAgaWYgKCF0aGlzLmlzRGF0ZSkge1xuICAgICAgICAgIHJlc3VsdCArPSAnVCcgKyBJQ0FMLmhlbHBlcnMucGFkMih0aGlzLmhvdXIpICsgJzonICtcbiAgICAgICAgICAgICAgICAgICAgSUNBTC5oZWxwZXJzLnBhZDIodGhpcy5taW51dGUpICsgJzonICtcbiAgICAgICAgICAgICAgICAgICAgSUNBTC5oZWxwZXJzLnBhZDIodGhpcy5zZWNvbmQpO1xuXG4gICAgICAgIGlmICh0aGlzLnpvbmUgPT09IElDQUwuVGltZXpvbmUudXRjVGltZXpvbmUpIHtcbiAgICAgICAgICByZXN1bHQgKz0gJ1onO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBjdXJyZW50IGluc3RhbmNlIHRvIGEgSmF2YXNjcmlwdCBkYXRlXG4gICAgICogQHJldHVybiB7RGF0ZX1cbiAgICAgKi9cbiAgICB0b0pTRGF0ZTogZnVuY3Rpb24gdG9KU0RhdGUoKSB7XG4gICAgICBpZiAodGhpcy56b25lID09IElDQUwuVGltZXpvbmUubG9jYWxUaW1lem9uZSkge1xuICAgICAgICBpZiAodGhpcy5pc0RhdGUpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy55ZWFyLCB0aGlzLm1vbnRoIC0gMSwgdGhpcy5kYXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnllYXIsIHRoaXMubW9udGggLSAxLCB0aGlzLmRheSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ob3VyLCB0aGlzLm1pbnV0ZSwgdGhpcy5zZWNvbmQsIDApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy50b1VuaXhUaW1lKCkgKiAxMDAwKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX25vcm1hbGl6ZTogZnVuY3Rpb24gaWNhbHRpbWVfbm9ybWFsaXplKCkge1xuICAgICAgdmFyIGlzRGF0ZSA9IHRoaXMuX3RpbWUuaXNEYXRlO1xuICAgICAgaWYgKHRoaXMuX3RpbWUuaXNEYXRlKSB7XG4gICAgICAgIHRoaXMuX3RpbWUuaG91ciA9IDA7XG4gICAgICAgIHRoaXMuX3RpbWUubWludXRlID0gMDtcbiAgICAgICAgdGhpcy5fdGltZS5zZWNvbmQgPSAwO1xuICAgICAgfVxuICAgICAgdGhpcy5hZGp1c3QoMCwgMCwgMCwgMCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGp1c3QgdGhlIGRhdGUvdGltZSBieSB0aGUgZ2l2ZW4gb2Zmc2V0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYUV4dHJhRGF5cyAgICAgICBUaGUgZXh0cmEgYW1vdW50IG9mIGRheXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYUV4dHJhSG91cnMgICAgICBUaGUgZXh0cmEgYW1vdW50IG9mIGhvdXJzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFFeHRyYU1pbnV0ZXMgICAgVGhlIGV4dHJhIGFtb3VudCBvZiBtaW51dGVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFFeHRyYVNlY29uZHMgICAgVGhlIGV4dHJhIGFtb3VudCBvZiBzZWNvbmRzXG4gICAgICogQHBhcmFtIHtOdW1iZXI9fSBhVGltZSAgICAgICAgICAgVGhlIHRpbWUgdG8gYWRqdXN0LCBkZWZhdWx0cyB0byB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgaW5zdGFuY2UuXG4gICAgICovXG4gICAgYWRqdXN0OiBmdW5jdGlvbiBpY2FsdGltZV9hZGp1c3QoYUV4dHJhRGF5cywgYUV4dHJhSG91cnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYUV4dHJhTWludXRlcywgYUV4dHJhU2Vjb25kcywgYVRpbWUpIHtcblxuICAgICAgdmFyIG1pbnV0ZXNPdmVyZmxvdywgaG91cnNPdmVyZmxvdyxcbiAgICAgICAgICBkYXlzT3ZlcmZsb3cgPSAwLCB5ZWFyc092ZXJmbG93ID0gMDtcblxuICAgICAgdmFyIHNlY29uZCwgbWludXRlLCBob3VyLCBkYXk7XG4gICAgICB2YXIgZGF5c0luTW9udGg7XG5cbiAgICAgIHZhciB0aW1lID0gYVRpbWUgfHwgdGhpcy5fdGltZTtcblxuICAgICAgaWYgKCF0aW1lLmlzRGF0ZSkge1xuICAgICAgICBzZWNvbmQgPSB0aW1lLnNlY29uZCArIGFFeHRyYVNlY29uZHM7XG4gICAgICAgIHRpbWUuc2Vjb25kID0gc2Vjb25kICUgNjA7XG4gICAgICAgIG1pbnV0ZXNPdmVyZmxvdyA9IElDQUwuaGVscGVycy50cnVuYyhzZWNvbmQgLyA2MCk7XG4gICAgICAgIGlmICh0aW1lLnNlY29uZCA8IDApIHtcbiAgICAgICAgICB0aW1lLnNlY29uZCArPSA2MDtcbiAgICAgICAgICBtaW51dGVzT3ZlcmZsb3ctLTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1pbnV0ZSA9IHRpbWUubWludXRlICsgYUV4dHJhTWludXRlcyArIG1pbnV0ZXNPdmVyZmxvdztcbiAgICAgICAgdGltZS5taW51dGUgPSBtaW51dGUgJSA2MDtcbiAgICAgICAgaG91cnNPdmVyZmxvdyA9IElDQUwuaGVscGVycy50cnVuYyhtaW51dGUgLyA2MCk7XG4gICAgICAgIGlmICh0aW1lLm1pbnV0ZSA8IDApIHtcbiAgICAgICAgICB0aW1lLm1pbnV0ZSArPSA2MDtcbiAgICAgICAgICBob3Vyc092ZXJmbG93LS07XG4gICAgICAgIH1cblxuICAgICAgICBob3VyID0gdGltZS5ob3VyICsgYUV4dHJhSG91cnMgKyBob3Vyc092ZXJmbG93O1xuXG4gICAgICAgIHRpbWUuaG91ciA9IGhvdXIgJSAyNDtcbiAgICAgICAgZGF5c092ZXJmbG93ID0gSUNBTC5oZWxwZXJzLnRydW5jKGhvdXIgLyAyNCk7XG4gICAgICAgIGlmICh0aW1lLmhvdXIgPCAwKSB7XG4gICAgICAgICAgdGltZS5ob3VyICs9IDI0O1xuICAgICAgICAgIGRheXNPdmVyZmxvdy0tO1xuICAgICAgICB9XG4gICAgICB9XG5cblxuICAgICAgLy8gQWRqdXN0IG1vbnRoIGFuZCB5ZWFyIGZpcnN0LCBiZWNhdXNlIHdlIG5lZWQgdG8ga25vdyB3aGF0IG1vbnRoIHRoZSBkYXlcbiAgICAgIC8vIGlzIGluIGJlZm9yZSBhZGp1c3RpbmcgaXQuXG4gICAgICBpZiAodGltZS5tb250aCA+IDEyKSB7XG4gICAgICAgIHllYXJzT3ZlcmZsb3cgPSBJQ0FMLmhlbHBlcnMudHJ1bmMoKHRpbWUubW9udGggLSAxKSAvIDEyKTtcbiAgICAgIH0gZWxzZSBpZiAodGltZS5tb250aCA8IDEpIHtcbiAgICAgICAgeWVhcnNPdmVyZmxvdyA9IElDQUwuaGVscGVycy50cnVuYyh0aW1lLm1vbnRoIC8gMTIpIC0gMTtcbiAgICAgIH1cblxuICAgICAgdGltZS55ZWFyICs9IHllYXJzT3ZlcmZsb3c7XG4gICAgICB0aW1lLm1vbnRoIC09IDEyICogeWVhcnNPdmVyZmxvdztcblxuICAgICAgLy8gTm93IHRha2UgY2FyZSBvZiB0aGUgZGF5cyAoYW5kIGFkanVzdCBtb250aCBpZiBuZWVkZWQpXG4gICAgICBkYXkgPSB0aW1lLmRheSArIGFFeHRyYURheXMgKyBkYXlzT3ZlcmZsb3c7XG5cbiAgICAgIGlmIChkYXkgPiAwKSB7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBkYXlzSW5Nb250aCA9IElDQUwuVGltZS5kYXlzSW5Nb250aCh0aW1lLm1vbnRoLCB0aW1lLnllYXIpO1xuICAgICAgICAgIGlmIChkYXkgPD0gZGF5c0luTW9udGgpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRpbWUubW9udGgrKztcbiAgICAgICAgICBpZiAodGltZS5tb250aCA+IDEyKSB7XG4gICAgICAgICAgICB0aW1lLnllYXIrKztcbiAgICAgICAgICAgIHRpbWUubW9udGggPSAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRheSAtPSBkYXlzSW5Nb250aDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2hpbGUgKGRheSA8PSAwKSB7XG4gICAgICAgICAgaWYgKHRpbWUubW9udGggPT0gMSkge1xuICAgICAgICAgICAgdGltZS55ZWFyLS07XG4gICAgICAgICAgICB0aW1lLm1vbnRoID0gMTI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpbWUubW9udGgtLTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkYXkgKz0gSUNBTC5UaW1lLmRheXNJbk1vbnRoKHRpbWUubW9udGgsIHRpbWUueWVhcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGltZS5kYXkgPSBkYXk7XG5cbiAgICAgIHRoaXMuX2NhY2hlZFVuaXhUaW1lID0gbnVsbDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIHRoZSBjdXJyZW50IGluc3RhbmNlIGZyb20gdW5peCB0aW1lLCB0aGUgbnVtYmVyIG9mIHNlY29uZHMgc2luY2VcbiAgICAgKiBKYW51YXJ5IDFzdCwgMTk3MC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzZWNvbmRzICAgICAgVGhlIHNlY29uZHMgdG8gc2V0IHVwIHdpdGhcbiAgICAgKi9cbiAgICBmcm9tVW5peFRpbWU6IGZ1bmN0aW9uIGZyb21Vbml4VGltZShzZWNvbmRzKSB7XG4gICAgICB0aGlzLnpvbmUgPSBJQ0FMLlRpbWV6b25lLnV0Y1RpbWV6b25lO1xuICAgICAgdmFyIGVwb2NoID0gSUNBTC5UaW1lLmVwb2NoVGltZS5jbG9uZSgpO1xuICAgICAgZXBvY2guYWRqdXN0KDAsIDAsIDAsIHNlY29uZHMpO1xuXG4gICAgICB0aGlzLnllYXIgPSBlcG9jaC55ZWFyO1xuICAgICAgdGhpcy5tb250aCA9IGVwb2NoLm1vbnRoO1xuICAgICAgdGhpcy5kYXkgPSBlcG9jaC5kYXk7XG4gICAgICB0aGlzLmhvdXIgPSBlcG9jaC5ob3VyO1xuICAgICAgdGhpcy5taW51dGUgPSBlcG9jaC5taW51dGU7XG4gICAgICB0aGlzLnNlY29uZCA9IE1hdGguZmxvb3IoZXBvY2guc2Vjb25kKTtcblxuICAgICAgdGhpcy5fY2FjaGVkVW5peFRpbWUgPSBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgY3VycmVudCBpbnN0YW5jZSB0byBzZWNvbmRzIHNpbmNlIEphbnVhcnkgMXN0IDE5NzAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgU2Vjb25kcyBzaW5jZSAxOTcwXG4gICAgICovXG4gICAgdG9Vbml4VGltZTogZnVuY3Rpb24gdG9Vbml4VGltZSgpIHtcbiAgICAgIGlmICh0aGlzLl9jYWNoZWRVbml4VGltZSAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkVW5peFRpbWU7XG4gICAgICB9XG4gICAgICB2YXIgb2Zmc2V0ID0gdGhpcy51dGNPZmZzZXQoKTtcblxuICAgICAgLy8gd2UgdXNlIHRoZSBvZmZzZXQgdHJpY2sgdG8gZW5zdXJlXG4gICAgICAvLyB0aGF0IHdlIGFyZSBnZXR0aW5nIHRoZSBhY3R1YWwgVVRDIHRpbWVcbiAgICAgIHZhciBtcyA9IERhdGUuVVRDKFxuICAgICAgICB0aGlzLnllYXIsXG4gICAgICAgIHRoaXMubW9udGggLSAxLFxuICAgICAgICB0aGlzLmRheSxcbiAgICAgICAgdGhpcy5ob3VyLFxuICAgICAgICB0aGlzLm1pbnV0ZSxcbiAgICAgICAgdGhpcy5zZWNvbmQgLSBvZmZzZXRcbiAgICAgICk7XG5cbiAgICAgIC8vIHNlY29uZHNcbiAgICAgIHRoaXMuX2NhY2hlZFVuaXhUaW1lID0gbXMgLyAxMDAwO1xuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZFVuaXhUaW1lO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aW1lIHRvIGludG8gT2JqZWN0IHdoaWNoIGNhbiBiZSBzZXJpYWxpemVkIHRoZW4gcmUtY3JlYXRlZFxuICAgICAqIHVzaW5nIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gdG9KU09OIHdpbGwgYXV0b21hdGljYWxseSBiZSBjYWxsZWRcbiAgICAgKiB2YXIganNvbiA9IEpTT04uc3RyaW5naWZ5KG15dGltZSk7XG4gICAgICpcbiAgICAgKiB2YXIgZGVzZXJpYWxpemVkID0gSlNPTi5wYXJzZShqc29uKTtcbiAgICAgKlxuICAgICAqIHZhciB0aW1lID0gbmV3IElDQUwuVGltZShkZXNlcmlhbGl6ZWQpO1xuICAgICAqXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29weSA9IFtcbiAgICAgICAgJ3llYXInLFxuICAgICAgICAnbW9udGgnLFxuICAgICAgICAnZGF5JyxcbiAgICAgICAgJ2hvdXInLFxuICAgICAgICAnbWludXRlJyxcbiAgICAgICAgJ3NlY29uZCcsXG4gICAgICAgICdpc0RhdGUnXG4gICAgICBdO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGxlbiA9IGNvcHkubGVuZ3RoO1xuICAgICAgdmFyIHByb3A7XG5cbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcHJvcCA9IGNvcHlbaV07XG4gICAgICAgIHJlc3VsdFtwcm9wXSA9IHRoaXNbcHJvcF07XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnpvbmUpIHtcbiAgICAgICAgcmVzdWx0LnRpbWV6b25lID0gdGhpcy56b25lLnR6aWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gIH07XG5cbiAgKGZ1bmN0aW9uIHNldHVwTm9ybWFsaXplQXR0cmlidXRlcygpIHtcbiAgICAvLyBUaGlzIG5lZWRzIHRvIHJ1biBiZWZvcmUgYW55IGluc3RhbmNlcyBhcmUgY3JlYXRlZCFcbiAgICBmdW5jdGlvbiBkZWZpbmVBdHRyKGF0dHIpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJQ0FMLlRpbWUucHJvdG90eXBlLCBhdHRyLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0VGltZUF0dHIoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdOb3JtYWxpemF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9ub3JtYWxpemUoKTtcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdOb3JtYWxpemF0aW9uID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWVbYXR0cl07XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0VGltZUF0dHIodmFsKSB7XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgaXNEYXRlIHdpbGwgYmUgc2V0IGFuZCBpZiB3YXMgbm90IHNldCB0byBub3JtYWxpemUgZGF0ZS5cbiAgICAgICAgICAvLyBUaGlzIGF2b2lkcyBsb3NpbmcgZGF5cyB3aGVuIHNlY29uZHMsIG1pbnV0ZXMgYW5kIGhvdXJzIGFyZSB6ZXJvZWRcbiAgICAgICAgICAvLyB3aGF0IG5vcm1hbGl6ZSB3aWxsIGRvIHdoZW4gdGltZSBpcyBhIGRhdGUuXG4gICAgICAgICAgaWYgKGF0dHIgPT09IFwiaXNEYXRlXCIgJiYgdmFsICYmICF0aGlzLl90aW1lLmlzRGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5hZGp1c3QoMCwgMCwgMCwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2NhY2hlZFVuaXhUaW1lID0gbnVsbDtcbiAgICAgICAgICB0aGlzLl9wZW5kaW5nTm9ybWFsaXphdGlvbiA9IHRydWU7XG4gICAgICAgICAgdGhpcy5fdGltZVthdHRyXSA9IHZhbDtcblxuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoXCJkZWZpbmVQcm9wZXJ0eVwiIGluIE9iamVjdCkge1xuICAgICAgZGVmaW5lQXR0cihcInllYXJcIik7XG4gICAgICBkZWZpbmVBdHRyKFwibW9udGhcIik7XG4gICAgICBkZWZpbmVBdHRyKFwiZGF5XCIpO1xuICAgICAgZGVmaW5lQXR0cihcImhvdXJcIik7XG4gICAgICBkZWZpbmVBdHRyKFwibWludXRlXCIpO1xuICAgICAgZGVmaW5lQXR0cihcInNlY29uZFwiKTtcbiAgICAgIGRlZmluZUF0dHIoXCJpc0RhdGVcIik7XG4gICAgfVxuICB9KSgpO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkYXlzIGluIHRoZSBnaXZlbiBtb250aFxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gbW9udGggICAgICBUaGUgbW9udGggdG8gY2hlY2tcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHllYXIgICAgICAgVGhlIHllYXIgdG8gY2hlY2tcbiAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgVGhlIG51bWJlciBvZiBkYXlzIGluIHRoZSBtb250aFxuICAgKi9cbiAgSUNBTC5UaW1lLmRheXNJbk1vbnRoID0gZnVuY3Rpb24gaWNhbHRpbWVfZGF5c0luTW9udGgobW9udGgsIHllYXIpIHtcbiAgICB2YXIgX2RheXNJbk1vbnRoID0gWzAsIDMxLCAyOCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdO1xuICAgIHZhciBkYXlzID0gMzA7XG5cbiAgICBpZiAobW9udGggPCAxIHx8IG1vbnRoID4gMTIpIHJldHVybiBkYXlzO1xuXG4gICAgZGF5cyA9IF9kYXlzSW5Nb250aFttb250aF07XG5cbiAgICBpZiAobW9udGggPT0gMikge1xuICAgICAgZGF5cyArPSBJQ0FMLlRpbWUuaXNMZWFwWWVhcih5ZWFyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF5cztcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSB5ZWFyIGlzIGEgbGVhcCB5ZWFyXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5ZWFyICAgICAgIFRoZSB5ZWFyIHRvIGNoZWNrXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgIFRydWUsIGlmIHRoZSB5ZWFyIGlzIGEgbGVhcCB5ZWFyXG4gICAqL1xuICBJQ0FMLlRpbWUuaXNMZWFwWWVhciA9IGZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcikge1xuICAgIGlmICh5ZWFyIDw9IDE3NTIpIHtcbiAgICAgIHJldHVybiAoKHllYXIgJSA0KSA9PSAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgoKHllYXIgJSA0ID09IDApICYmICh5ZWFyICUgMTAwICE9IDApKSB8fCAoeWVhciAlIDQwMCA9PSAwKSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgSUNBTC5UaW1lIGZyb20gdGhlIGRheSBvZiB5ZWFyIGFuZCB5ZWFyLiBUaGUgZGF0ZSBpcyByZXR1cm5lZFxuICAgKiBpbiBmbG9hdGluZyB0aW1lem9uZS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXlPZlllYXIgICAgIFRoZSBkYXkgb2YgeWVhclxuICAgKiBAcGFyYW0ge051bWJlcn0gYVllYXIgICAgICAgICAgVGhlIHllYXIgdG8gY3JlYXRlIHRoZSBpbnN0YW5jZSBpblxuICAgKiBAcmV0dXJuIHtJQ0FMLlRpbWV9ICAgICAgICAgICAgVGhlIGNyZWF0ZWQgaW5zdGFuY2Ugd2l0aCB0aGUgY2FsY3VsYXRlZCBkYXRlXG4gICAqL1xuICBJQ0FMLlRpbWUuZnJvbURheU9mWWVhciA9IGZ1bmN0aW9uIGljYWx0aW1lX2Zyb21EYXlPZlllYXIoYURheU9mWWVhciwgYVllYXIpIHtcbiAgICB2YXIgeWVhciA9IGFZZWFyO1xuICAgIHZhciBkb3kgPSBhRGF5T2ZZZWFyO1xuICAgIHZhciB0dCA9IG5ldyBJQ0FMLlRpbWUoKTtcbiAgICB0dC5hdXRvX25vcm1hbGl6ZSA9IGZhbHNlO1xuICAgIHZhciBpc19sZWFwID0gKElDQUwuVGltZS5pc0xlYXBZZWFyKHllYXIpID8gMSA6IDApO1xuXG4gICAgaWYgKGRveSA8IDEpIHtcbiAgICAgIHllYXItLTtcbiAgICAgIGlzX2xlYXAgPSAoSUNBTC5UaW1lLmlzTGVhcFllYXIoeWVhcikgPyAxIDogMCk7XG4gICAgICBkb3kgKz0gSUNBTC5UaW1lLmRheXNJblllYXJQYXNzZWRNb250aFtpc19sZWFwXVsxMl07XG4gICAgICByZXR1cm4gSUNBTC5UaW1lLmZyb21EYXlPZlllYXIoZG95LCB5ZWFyKTtcbiAgICB9IGVsc2UgaWYgKGRveSA+IElDQUwuVGltZS5kYXlzSW5ZZWFyUGFzc2VkTW9udGhbaXNfbGVhcF1bMTJdKSB7XG4gICAgICBpc19sZWFwID0gKElDQUwuVGltZS5pc0xlYXBZZWFyKHllYXIpID8gMSA6IDApO1xuICAgICAgZG95IC09IElDQUwuVGltZS5kYXlzSW5ZZWFyUGFzc2VkTW9udGhbaXNfbGVhcF1bMTJdO1xuICAgICAgeWVhcisrO1xuICAgICAgcmV0dXJuIElDQUwuVGltZS5mcm9tRGF5T2ZZZWFyKGRveSwgeWVhcik7XG4gICAgfVxuXG4gICAgdHQueWVhciA9IHllYXI7XG4gICAgdHQuaXNEYXRlID0gdHJ1ZTtcblxuICAgIGZvciAodmFyIG1vbnRoID0gMTE7IG1vbnRoID49IDA7IG1vbnRoLS0pIHtcbiAgICAgIGlmIChkb3kgPiBJQ0FMLlRpbWUuZGF5c0luWWVhclBhc3NlZE1vbnRoW2lzX2xlYXBdW21vbnRoXSkge1xuICAgICAgICB0dC5tb250aCA9IG1vbnRoICsgMTtcbiAgICAgICAgdHQuZGF5ID0gZG95IC0gSUNBTC5UaW1lLmRheXNJblllYXJQYXNzZWRNb250aFtpc19sZWFwXVttb250aF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHR0LmF1dG9fbm9ybWFsaXplID0gdHJ1ZTtcbiAgICByZXR1cm4gdHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgSUNBTC5UaW1lIGluc3RhbmNlIGZyb20gYSBkYXRlIHN0cmluZywgZS5nIDIwMTUtMDEtMDIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkICAgICAgICAgICAgICAgIFVzZSB7QGxpbmsgSUNBTC5UaW1lLmZyb21EYXRlU3RyaW5nfSBpbnN0ZWFkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgICAgICAgIFRoZSBzdHJpbmcgdG8gY3JlYXRlIGZyb21cbiAgICogQHJldHVybiB7SUNBTC5UaW1lfSAgICAgICAgVGhlIGRhdGUvdGltZSBpbnN0YW5jZVxuICAgKi9cbiAgSUNBTC5UaW1lLmZyb21TdHJpbmd2MiA9IGZ1bmN0aW9uIGZyb21TdHJpbmcoc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBJQ0FMLlRpbWUoe1xuICAgICAgeWVhcjogcGFyc2VJbnQoc3RyLnN1YnN0cigwLCA0KSwgMTApLFxuICAgICAgbW9udGg6IHBhcnNlSW50KHN0ci5zdWJzdHIoNSwgMiksIDEwKSxcbiAgICAgIGRheTogcGFyc2VJbnQoc3RyLnN1YnN0cig4LCAyKSwgMTApLFxuICAgICAgaXNEYXRlOiB0cnVlXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgSUNBTC5UaW1lIGluc3RhbmNlIGZyb20gYSBkYXRlIHN0cmluZywgZS5nIDIwMTUtMDEtMDIuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhVmFsdWUgICAgIFRoZSBzdHJpbmcgdG8gY3JlYXRlIGZyb21cbiAgICogQHJldHVybiB7SUNBTC5UaW1lfSAgICAgICAgVGhlIGRhdGUvdGltZSBpbnN0YW5jZVxuICAgKi9cbiAgSUNBTC5UaW1lLmZyb21EYXRlU3RyaW5nID0gZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgLy8gRGF0ZXMgc2hvdWxkIGhhdmUgbm8gdGltZXpvbmUuXG4gICAgLy8gR29vZ2xlIGxpa2VzIHRvIHNvbWV0aW1lcyBzcGVjaWZ5IFogb24gZGF0ZXNcbiAgICAvLyB3ZSBzcGVjaWZpY2FsbHkgaWdub3JlIHRoYXQgdG8gYXZvaWQgaXNzdWVzLlxuXG4gICAgLy8gWVlZWS1NTS1ERFxuICAgIC8vIDIwMTItMTAtMTBcbiAgICByZXR1cm4gbmV3IElDQUwuVGltZSh7XG4gICAgICB5ZWFyOiBJQ0FMLmhlbHBlcnMuc3RyaWN0UGFyc2VJbnQoYVZhbHVlLnN1YnN0cigwLCA0KSksXG4gICAgICBtb250aDogSUNBTC5oZWxwZXJzLnN0cmljdFBhcnNlSW50KGFWYWx1ZS5zdWJzdHIoNSwgMikpLFxuICAgICAgZGF5OiBJQ0FMLmhlbHBlcnMuc3RyaWN0UGFyc2VJbnQoYVZhbHVlLnN1YnN0cig4LCAyKSksXG4gICAgICBpc0RhdGU6IHRydWVcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBJQ0FMLlRpbWUgaW5zdGFuY2UgZnJvbSBhIGRhdGUtdGltZSBzdHJpbmcsIGUuZ1xuICAgKiAyMDE1LTAxLTAyVDAzOjA0OjA1LiBJZiBhIHByb3BlcnR5IGlzIHNwZWNpZmllZCwgdGhlIHRpbWV6b25lIGlzIHNldCB1cFxuICAgKiBmcm9tIHRoZSBwcm9wZXJ0eSdzIFRaSUQgcGFyYW1ldGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYVZhbHVlICAgICAgICAgVGhlIHN0cmluZyB0byBjcmVhdGUgZnJvbVxuICAgKiBAcGFyYW0ge0lDQUwuUHJvcGVydHk9fSBwcm9wICAgVGhlIHByb3BlcnR5IHRoZSBkYXRlIGJlbG9uZ3MgdG9cbiAgICogQHJldHVybiB7SUNBTC5UaW1lfSAgICAgICAgICAgIFRoZSBkYXRlL3RpbWUgaW5zdGFuY2VcbiAgICovXG4gIElDQUwuVGltZS5mcm9tRGF0ZVRpbWVTdHJpbmcgPSBmdW5jdGlvbihhVmFsdWUsIHByb3ApIHtcbiAgICBpZiAoYVZhbHVlLmxlbmd0aCA8IDE5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdpbnZhbGlkIGRhdGUtdGltZSB2YWx1ZTogXCInICsgYVZhbHVlICsgJ1wiJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgem9uZTtcblxuICAgIGlmIChhVmFsdWVbMTldICYmIGFWYWx1ZVsxOV0gPT09ICdaJykge1xuICAgICAgem9uZSA9ICdaJztcbiAgICB9IGVsc2UgaWYgKHByb3ApIHtcbiAgICAgIHpvbmUgPSBwcm9wLmdldFBhcmFtZXRlcigndHppZCcpO1xuICAgIH1cblxuICAgIC8vIDIwMTItMTAtMTBUMTA6MTA6MTAoWik/XG4gICAgdmFyIHRpbWUgPSBuZXcgSUNBTC5UaW1lKHtcbiAgICAgIHllYXI6IElDQUwuaGVscGVycy5zdHJpY3RQYXJzZUludChhVmFsdWUuc3Vic3RyKDAsIDQpKSxcbiAgICAgIG1vbnRoOiBJQ0FMLmhlbHBlcnMuc3RyaWN0UGFyc2VJbnQoYVZhbHVlLnN1YnN0cig1LCAyKSksXG4gICAgICBkYXk6IElDQUwuaGVscGVycy5zdHJpY3RQYXJzZUludChhVmFsdWUuc3Vic3RyKDgsIDIpKSxcbiAgICAgIGhvdXI6IElDQUwuaGVscGVycy5zdHJpY3RQYXJzZUludChhVmFsdWUuc3Vic3RyKDExLCAyKSksXG4gICAgICBtaW51dGU6IElDQUwuaGVscGVycy5zdHJpY3RQYXJzZUludChhVmFsdWUuc3Vic3RyKDE0LCAyKSksXG4gICAgICBzZWNvbmQ6IElDQUwuaGVscGVycy5zdHJpY3RQYXJzZUludChhVmFsdWUuc3Vic3RyKDE3LCAyKSksXG4gICAgICB0aW1lem9uZTogem9uZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRpbWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgSUNBTC5UaW1lIGluc3RhbmNlIGZyb20gYSBkYXRlIG9yIGRhdGUtdGltZSBzdHJpbmcsXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhVmFsdWUgICAgICAgICBUaGUgc3RyaW5nIHRvIGNyZWF0ZSBmcm9tXG4gICAqIEBwYXJhbSB7SUNBTC5Qcm9wZXJ0eT19IHByb3AgICBUaGUgcHJvcGVydHkgdGhlIGRhdGUgYmVsb25ncyB0b1xuICAgKiBAcmV0dXJuIHtJQ0FMLlRpbWV9ICAgICAgICAgICAgVGhlIGRhdGUvdGltZSBpbnN0YW5jZVxuICAgKi9cbiAgSUNBTC5UaW1lLmZyb21TdHJpbmcgPSBmdW5jdGlvbiBmcm9tU3RyaW5nKGFWYWx1ZSwgYVByb3BlcnR5KSB7XG4gICAgaWYgKGFWYWx1ZS5sZW5ndGggPiAxMCkge1xuICAgICAgcmV0dXJuIElDQUwuVGltZS5mcm9tRGF0ZVRpbWVTdHJpbmcoYVZhbHVlLCBhUHJvcGVydHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gSUNBTC5UaW1lLmZyb21EYXRlU3RyaW5nKGFWYWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IElDQUwuVGltZSBpbnN0YW5jZSBmcm9tIHRoZSBnaXZlbiBKYXZhc2NyaXB0IERhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7P0RhdGV9IGFEYXRlICAgICBUaGUgSmF2YXNjcmlwdCBEYXRlIHRvIHJlYWQsIG9yIG51bGwgdG8gcmVzZXRcbiAgICogQHBhcmFtIHtCb29sZWFufSB1c2VVVEMgIElmIHRydWUsIHRoZSBVVEMgdmFsdWVzIG9mIHRoZSBkYXRlIHdpbGwgYmUgdXNlZFxuICAgKi9cbiAgSUNBTC5UaW1lLmZyb21KU0RhdGUgPSBmdW5jdGlvbiBmcm9tSlNEYXRlKGFEYXRlLCB1c2VVVEMpIHtcbiAgICB2YXIgdHQgPSBuZXcgSUNBTC5UaW1lKCk7XG4gICAgcmV0dXJuIHR0LmZyb21KU0RhdGUoYURhdGUsIHVzZVVUQyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgSUNBTC5UaW1lIGluc3RhbmNlIGZyb20gdGhlIHRoZSBwYXNzZWQgZGF0YSBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhRGF0YSAgICAgICAgICAgIFRpbWUgaW5pdGlhbGl6YXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS55ZWFyICAgICAgVGhlIHllYXIgZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLm1vbnRoICAgICBUaGUgbW9udGggZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLmRheSAgICAgICBUaGUgZGF5IGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5ob3VyICAgICAgVGhlIGhvdXIgZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLm1pbnV0ZSAgICBUaGUgbWludXRlIGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5zZWNvbmQgICAgVGhlIHNlY29uZCBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbj19IGFEYXRhLmlzRGF0ZSAgIElmIHRydWUsIHRoZSBpbnN0YW5jZSByZXByZXNlbnRzIGEgZGF0ZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChhcyBvcHBvc2VkIHRvIGEgZGF0ZS10aW1lKVxuICAgKiBAcGFyYW0ge0lDQUwuVGltZXpvbmU9fSBhWm9uZSAgICBUaW1lem9uZSB0aGlzIHBvc2l0aW9uIG9jY3VycyBpblxuICAgKi9cbiAgSUNBTC5UaW1lLmZyb21EYXRhID0gZnVuY3Rpb24gZnJvbURhdGEoYURhdGEsIGFab25lKSB7XG4gICAgdmFyIHQgPSBuZXcgSUNBTC5UaW1lKCk7XG4gICAgcmV0dXJuIHQuZnJvbURhdGEoYURhdGEsIGFab25lKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBJQ0FMLlRpbWUgaW5zdGFuY2UgZnJvbSB0aGUgY3VycmVudCBtb21lbnQuXG4gICAqIFRoZSBpbnN0YW5jZSBpcyBcdTIwMUNmbG9hdGluZ1x1MjAxRCAtIGhhcyBubyB0aW1lem9uZSByZWxhdGlvbi5cbiAgICogVG8gY3JlYXRlIGFuIGluc3RhbmNlIGNvbnNpZGVyaW5nIHRoZSB0aW1lIHpvbmUsIGNhbGxcbiAgICogSUNBTC5UaW1lLmZyb21KU0RhdGUobmV3IERhdGUoKSwgdHJ1ZSlcbiAgICogQHJldHVybiB7SUNBTC5UaW1lfVxuICAgKi9cbiAgSUNBTC5UaW1lLm5vdyA9IGZ1bmN0aW9uIGljYWx0aW1lX25vdygpIHtcbiAgICByZXR1cm4gSUNBTC5UaW1lLmZyb21KU0RhdGUobmV3IERhdGUoKSwgZmFsc2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkYXRlIG9uIHdoaWNoIElTTyB3ZWVrIG51bWJlciAxIHN0YXJ0cy5cbiAgICpcbiAgICogQHNlZSBJQ0FMLlRpbWUjd2Vla051bWJlclxuICAgKiBAcGFyYW0ge051bWJlcn0gYVllYXIgICAgICAgICAgICAgICAgICBUaGUgeWVhciB0byBzZWFyY2ggaW5cbiAgICogQHBhcmFtIHtJQ0FMLlRpbWUud2Vla0RheT19IGFXZWVrU3RhcnQgVGhlIHdlZWsgc3RhcnQgd2Vla2RheSwgdXNlZCBmb3IgY2FsY3VsYXRpb24uXG4gICAqIEByZXR1cm4ge0lDQUwuVGltZX0gICAgICAgICAgICAgICAgICAgIFRoZSBkYXRlIG9uIHdoaWNoIHdlZWsgbnVtYmVyIDEgc3RhcnRzXG4gICAqL1xuICBJQ0FMLlRpbWUud2Vla09uZVN0YXJ0cyA9IGZ1bmN0aW9uIHdlZWtPbmVTdGFydHMoYVllYXIsIGFXZWVrU3RhcnQpIHtcbiAgICB2YXIgdCA9IElDQUwuVGltZS5mcm9tRGF0YSh7XG4gICAgICB5ZWFyOiBhWWVhcixcbiAgICAgIG1vbnRoOiAxLFxuICAgICAgZGF5OiAxLFxuICAgICAgaXNEYXRlOiB0cnVlXG4gICAgfSk7XG5cbiAgICB2YXIgZG93ID0gdC5kYXlPZldlZWsoKTtcbiAgICB2YXIgd2tzdCA9IGFXZWVrU3RhcnQgfHwgSUNBTC5UaW1lLkRFRkFVTFRfV0VFS19TVEFSVDtcbiAgICBpZiAoZG93ID4gSUNBTC5UaW1lLlRIVVJTREFZKSB7XG4gICAgICB0LmRheSArPSA3O1xuICAgIH1cbiAgICBpZiAod2tzdCA+IElDQUwuVGltZS5USFVSU0RBWSkge1xuICAgICAgdC5kYXkgLT0gNztcbiAgICB9XG5cbiAgICB0LmRheSAtPSBkb3cgLSB3a3N0O1xuXG4gICAgcmV0dXJuIHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZG9taW5pY2FsIGxldHRlciBmb3IgdGhlIGdpdmVuIHllYXIuIExldHRlcnMgcmFuZ2UgZnJvbSBBIC0gRyBmb3JcbiAgICogY29tbW9uIHllYXJzLCBhbmQgQUcgdG8gR0YgZm9yIGxlYXAgeWVhcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5ciAgICAgICAgICAgVGhlIHllYXIgdG8gcmV0cmlldmUgdGhlIGxldHRlciBmb3JcbiAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICAgICBUaGUgZG9taW5pY2FsIGxldHRlci5cbiAgICovXG4gIElDQUwuVGltZS5nZXREb21pbmljYWxMZXR0ZXIgPSBmdW5jdGlvbih5cikge1xuICAgIHZhciBMVFJTID0gXCJHRkVEQ0JBXCI7XG4gICAgdmFyIGRvbSA9ICh5ciArICh5ciAvIDQgfCAwKSArICh5ciAvIDQwMCB8IDApIC0gKHlyIC8gMTAwIHwgMCkgLSAxKSAlIDc7XG4gICAgdmFyIGlzTGVhcCA9IElDQUwuVGltZS5pc0xlYXBZZWFyKHlyKTtcbiAgICBpZiAoaXNMZWFwKSB7XG4gICAgICByZXR1cm4gTFRSU1soZG9tICsgNikgJSA3XSArIExUUlNbZG9tXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIExUUlNbZG9tXTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEphbnVhcnkgMXN0LCAxOTcwIGFzIGFuIElDQUwuVGltZS5cbiAgICogQHR5cGUge0lDQUwuVGltZX1cbiAgICogQGNvbnN0YW50XG4gICAqIEBpbnN0YW5jZVxuICAgKi9cbiAgSUNBTC5UaW1lLmVwb2NoVGltZSA9IElDQUwuVGltZS5mcm9tRGF0YSh7XG4gICAgeWVhcjogMTk3MCxcbiAgICBtb250aDogMSxcbiAgICBkYXk6IDEsXG4gICAgaG91cjogMCxcbiAgICBtaW51dGU6IDAsXG4gICAgc2Vjb25kOiAwLFxuICAgIGlzRGF0ZTogZmFsc2UsXG4gICAgdGltZXpvbmU6IFwiWlwiXG4gIH0pO1xuXG4gIElDQUwuVGltZS5fY21wX2F0dHIgPSBmdW5jdGlvbiBfY21wX2F0dHIoYSwgYiwgYXR0cikge1xuICAgIGlmIChhW2F0dHJdID4gYlthdHRyXSkgcmV0dXJuIDE7XG4gICAgaWYgKGFbYXR0cl0gPCBiW2F0dHJdKSByZXR1cm4gLTE7XG4gICAgcmV0dXJuIDA7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoZSBkYXlzIHRoYXQgaGF2ZSBwYXNzZWQgaW4gdGhlIHllYXIgYWZ0ZXIgYSBnaXZlbiBtb250aC4gVGhlIGFycmF5IGhhc1xuICAgKiB0d28gbWVtYmVycywgb25lIGJlaW5nIGFuIGFycmF5IG9mIHBhc3NlZCBkYXlzIGZvciBub24tbGVhcCB5ZWFycywgdGhlXG4gICAqIG90aGVyIGFuYWxvZyBmb3IgbGVhcCB5ZWFycy5cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGlzTGVhcFllYXIgPSBJQ0FMLlRpbWUuaXNMZWFwWWVhcih5ZWFyKTtcbiAgICogdmFyIHBhc3NlZERheXMgPSBJQ0FMLlRpbWUuZGF5c0luWWVhclBhc3NlZE1vbnRoW2lzTGVhcFllYXJdW21vbnRoXTtcbiAgICogQHR5cGUge0FycmF5LjxBcnJheS48TnVtYmVyPj59XG4gICAqL1xuICBJQ0FMLlRpbWUuZGF5c0luWWVhclBhc3NlZE1vbnRoID0gW1xuICAgIFswLCAzMSwgNTksIDkwLCAxMjAsIDE1MSwgMTgxLCAyMTIsIDI0MywgMjczLCAzMDQsIDMzNCwgMzY1XSxcbiAgICBbMCwgMzEsIDYwLCA5MSwgMTIxLCAxNTIsIDE4MiwgMjEzLCAyNDQsIDI3NCwgMzA1LCAzMzUsIDM2Nl1cbiAgXTtcblxuICAvKipcbiAgICogVGhlIHdlZWtkYXksIDEgPSBTVU5EQVksIDcgPSBTQVRVUkRBWS4gQWNjZXNzIHZpYVxuICAgKiBJQ0FMLlRpbWUuTU9OREFZLCBJQ0FMLlRpbWUuVFVFU0RBWSwgLi4uXG4gICAqXG4gICAqIEB0eXBlZGVmIHtOdW1iZXJ9IHdlZWtEYXlcbiAgICogQG1lbWJlcm9mIElDQUwuVGltZVxuICAgKi9cblxuICBJQ0FMLlRpbWUuU1VOREFZID0gMTtcbiAgSUNBTC5UaW1lLk1PTkRBWSA9IDI7XG4gIElDQUwuVGltZS5UVUVTREFZID0gMztcbiAgSUNBTC5UaW1lLldFRE5FU0RBWSA9IDQ7XG4gIElDQUwuVGltZS5USFVSU0RBWSA9IDU7XG4gIElDQUwuVGltZS5GUklEQVkgPSA2O1xuICBJQ0FMLlRpbWUuU0FUVVJEQVkgPSA3O1xuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCB3ZWVrZGF5IGZvciB0aGUgV0tTVCBwYXJ0LlxuICAgKiBAY29uc3RhbnRcbiAgICogQGRlZmF1bHQgSUNBTC5UaW1lLk1PTkRBWVxuICAgKi9cbiAgSUNBTC5UaW1lLkRFRkFVTFRfV0VFS19TVEFSVCA9IElDQUwuVGltZS5NT05EQVk7XG59KSgpO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoLCAyMDE1ICovXG5cblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgLyoqXG4gICAqIERlc2NyaWJlcyBhIHZDYXJkIHRpbWUsIHdoaWNoIGhhcyBzbGlnaHQgZGlmZmVyZW5jZXMgdG8gdGhlIElDQUwuVGltZS5cbiAgICogUHJvcGVydGllcyBjYW4gYmUgbnVsbCBpZiBub3Qgc3BlY2lmaWVkLCBmb3IgZXhhbXBsZSBmb3IgZGF0ZXMgd2l0aFxuICAgKiByZWR1Y2VkIGFjY3VyYWN5IG9yIHRydW5jYXRpb24uXG4gICAqXG4gICAqIE5vdGUgdGhhdCBjdXJyZW50bHkgbm90IGFsbCBtZXRob2RzIGFyZSBjb3JyZWN0bHkgcmUtaW1wbGVtZW50ZWQgZm9yXG4gICAqIFZDYXJkVGltZS4gRm9yIGV4YW1wbGUsIGNvbXBhcmlzb24gd2lsbCBoYXZlIHVuZGVmaW5lZCByZXN1bHRzIHdoZW4gc29tZVxuICAgKiBtZW1iZXJzIGFyZSBudWxsLlxuICAgKlxuICAgKiBBbHNvLCBub3JtYWxpemF0aW9uIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgZm9yIHRoaXMgY2xhc3MhXG4gICAqXG4gICAqIEBhbGlhcyBJQ0FMLlZDYXJkVGltZVxuICAgKiBAY2xhc3NcbiAgICogQGV4dGVuZHMge0lDQUwuVGltZX1cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgZGF0YSBmb3IgdGhlIHRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLnllYXIgICAgICAgICAgICAgICAgICAgICBUaGUgeWVhciBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS5tb250aCAgICAgICAgICAgICAgICAgICAgVGhlIG1vbnRoIGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLmRheSAgICAgICAgICAgICAgICAgICAgICBUaGUgZGF5IGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLmhvdXIgICAgICAgICAgICAgICAgICAgICBUaGUgaG91ciBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS5taW51dGUgICAgICAgICAgICAgICAgICAgVGhlIG1pbnV0ZSBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS5zZWNvbmQgICAgICAgICAgICAgICAgICAgVGhlIHNlY29uZCBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7SUNBTC5UaW1lem9uZXxJQ0FMLlV0Y09mZnNldH0gem9uZSAgICAgVGhlIHRpbWV6b25lIHRvIHVzZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gaWNhbHR5cGUgICAgICAgICAgICAgICAgICAgICAgIFRoZSB0eXBlIGZvciB0aGlzIGRhdGUvdGltZSBvYmplY3RcbiAgICovXG4gIElDQUwuVkNhcmRUaW1lID0gZnVuY3Rpb24oZGF0YSwgem9uZSwgaWNhbHR5cGUpIHtcbiAgICB0aGlzLndyYXBwZWRKU09iamVjdCA9IHRoaXM7XG4gICAgdmFyIHRpbWUgPSB0aGlzLl90aW1lID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIHRpbWUueWVhciA9IG51bGw7XG4gICAgdGltZS5tb250aCA9IG51bGw7XG4gICAgdGltZS5kYXkgPSBudWxsO1xuICAgIHRpbWUuaG91ciA9IG51bGw7XG4gICAgdGltZS5taW51dGUgPSBudWxsO1xuICAgIHRpbWUuc2Vjb25kID0gbnVsbDtcblxuICAgIHRoaXMuaWNhbHR5cGUgPSBpY2FsdHlwZSB8fCBcImRhdGUtYW5kLW9yLXRpbWVcIjtcblxuICAgIHRoaXMuZnJvbURhdGEoZGF0YSwgem9uZSk7XG4gIH07XG4gIElDQUwuaGVscGVycy5pbmhlcml0cyhJQ0FMLlRpbWUsIElDQUwuVkNhcmRUaW1lLCAvKiogQGxlbmRzIElDQUwuVkNhcmRUaW1lICovIHtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjbGFzcyBpZGVudGlmaWVyLlxuICAgICAqIEBjb25zdGFudFxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgXCJ2Y2FyZHRpbWVcIlxuICAgICAqL1xuICAgIGljYWxjbGFzczogXCJ2Y2FyZHRpbWVcIixcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG5hbWUsIHRvIGJlIHVzZWQgaW4gdGhlIGpDYWwgb2JqZWN0LlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgXCJkYXRlLWFuZC1vci10aW1lXCJcbiAgICAgKi9cbiAgICBpY2FsdHlwZTogXCJkYXRlLWFuZC1vci10aW1lXCIsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGltZXpvbmUuIFRoaXMgY2FuIGVpdGhlciBiZSBmbG9hdGluZywgVVRDLCBvciBhbiBpbnN0YW5jZSBvZlxuICAgICAqIElDQUwuVXRjT2Zmc2V0LlxuICAgICAqIEB0eXBlIHtJQ0FMLlRpbWV6b25lfElDQUwuVXRjT0Zmc2V0fVxuICAgICAqL1xuICAgIHpvbmU6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIHZjYXJkIGRhdGUvdGltZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlZDYXJkVGltZX0gICAgIFRoZSBjbG9uZWQgb2JqZWN0XG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBJQ0FMLlZDYXJkVGltZSh0aGlzLl90aW1lLCB0aGlzLnpvbmUsIHRoaXMuaWNhbHR5cGUpO1xuICAgIH0sXG5cbiAgICBfbm9ybWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdGRvY1xuICAgICAqL1xuICAgIHV0Y09mZnNldDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy56b25lIGluc3RhbmNlb2YgSUNBTC5VdGNPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuem9uZS50b1NlY29uZHMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBJQ0FMLlRpbWUucHJvdG90eXBlLnV0Y09mZnNldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIFJGQyA2MzUwIGNvbXBsaWFudCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICB2Y2FyZCBkYXRlL3RpbWUgc3RyaW5nXG4gICAgICovXG4gICAgdG9JQ0FMU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBJQ0FMLmRlc2lnbi52Y2FyZC52YWx1ZVt0aGlzLmljYWx0eXBlXS50b0lDQUwodGhpcy50b1N0cmluZygpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGRhdGUvdGltZSwgaW4gakNhcmQgZm9ybVxuICAgICAqIChpbmNsdWRpbmcgOiBhbmQgLSBzZXBhcmF0b3JzKS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgdmFyIHAyID0gSUNBTC5oZWxwZXJzLnBhZDI7XG4gICAgICB2YXIgeSA9IHRoaXMueWVhciwgbSA9IHRoaXMubW9udGgsIGQgPSB0aGlzLmRheTtcbiAgICAgIHZhciBoID0gdGhpcy5ob3VyLCBtbSA9IHRoaXMubWludXRlLCBzID0gdGhpcy5zZWNvbmQ7XG5cbiAgICAgIHZhciBoYXNZZWFyID0geSAhPT0gbnVsbCwgaGFzTW9udGggPSBtICE9PSBudWxsLCBoYXNEYXkgPSBkICE9PSBudWxsO1xuICAgICAgdmFyIGhhc0hvdXIgPSBoICE9PSBudWxsLCBoYXNNaW51dGUgPSBtbSAhPT0gbnVsbCwgaGFzU2Vjb25kID0gcyAhPT0gbnVsbDtcblxuICAgICAgdmFyIGRhdGVwYXJ0ID0gKGhhc1llYXIgPyBwMih5KSArIChoYXNNb250aCB8fCBoYXNEYXkgPyAnLScgOiAnJykgOiAoaGFzTW9udGggfHwgaGFzRGF5ID8gJy0tJyA6ICcnKSkgK1xuICAgICAgICAgICAgICAgICAgICAgKGhhc01vbnRoID8gcDIobSkgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAgKGhhc0RheSA/ICctJyArIHAyKGQpIDogJycpO1xuICAgICAgdmFyIHRpbWVwYXJ0ID0gKGhhc0hvdXIgPyBwMihoKSA6ICctJykgKyAoaGFzSG91ciAmJiBoYXNNaW51dGUgPyAnOicgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAgKGhhc01pbnV0ZSA/IHAyKG1tKSA6ICcnKSArICghaGFzSG91ciAmJiAhaGFzTWludXRlID8gJy0nIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgIChoYXNNaW51dGUgJiYgaGFzU2Vjb25kID8gJzonIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgIChoYXNTZWNvbmQgPyBwMihzKSA6ICcnKTtcblxuICAgICAgdmFyIHpvbmU7XG4gICAgICBpZiAodGhpcy56b25lID09PSBJQ0FMLlRpbWV6b25lLnV0Y1RpbWV6b25lKSB7XG4gICAgICAgIHpvbmUgPSAnWic7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuem9uZSBpbnN0YW5jZW9mIElDQUwuVXRjT2Zmc2V0KSB7XG4gICAgICAgIHpvbmUgPSB0aGlzLnpvbmUudG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy56b25lID09PSBJQ0FMLlRpbWV6b25lLmxvY2FsVGltZXpvbmUpIHtcbiAgICAgICAgem9uZSA9ICcnO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnpvbmUgaW5zdGFuY2VvZiBJQ0FMLlRpbWV6b25lKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSBJQ0FMLlV0Y09mZnNldC5mcm9tU2Vjb25kcyh0aGlzLnpvbmUudXRjT2Zmc2V0KHRoaXMpKTtcbiAgICAgICAgem9uZSA9IG9mZnNldC50b1N0cmluZygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgem9uZSA9ICcnO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHRoaXMuaWNhbHR5cGUpIHtcbiAgICAgICAgY2FzZSBcInRpbWVcIjpcbiAgICAgICAgICByZXR1cm4gdGltZXBhcnQgKyB6b25lO1xuICAgICAgICBjYXNlIFwiZGF0ZS1hbmQtb3ItdGltZVwiOlxuICAgICAgICBjYXNlIFwiZGF0ZS10aW1lXCI6XG4gICAgICAgICAgcmV0dXJuIGRhdGVwYXJ0ICsgKHRpbWVwYXJ0ID09ICctLScgPyAnJyA6ICdUJyArIHRpbWVwYXJ0ICsgem9uZSk7XG4gICAgICAgIGNhc2UgXCJkYXRlXCI6XG4gICAgICAgICAgcmV0dXJuIGRhdGVwYXJ0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBJQ0FMLlZDYXJkVGltZSBpbnN0YW5jZSBmcm9tIGEgZGF0ZSBhbmQvb3IgdGltZSBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhVmFsdWUgICAgIFRoZSBzdHJpbmcgdG8gY3JlYXRlIGZyb21cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFJY2FsVHlwZSAgVGhlIHR5cGUgZm9yIHRoaXMgaW5zdGFuY2UsIGUuZy4gZGF0ZS1hbmQtb3ItdGltZVxuICAgKiBAcmV0dXJuIHtJQ0FMLlZDYXJkVGltZX0gICBUaGUgZGF0ZS90aW1lIGluc3RhbmNlXG4gICAqL1xuICBJQ0FMLlZDYXJkVGltZS5mcm9tRGF0ZUFuZE9yVGltZVN0cmluZyA9IGZ1bmN0aW9uKGFWYWx1ZSwgYUljYWxUeXBlKSB7XG4gICAgZnVuY3Rpb24gcGFydCh2LCBzLCBlKSB7XG4gICAgICByZXR1cm4gdiA/IElDQUwuaGVscGVycy5zdHJpY3RQYXJzZUludCh2LnN1YnN0cihzLCBlKSkgOiBudWxsO1xuICAgIH1cbiAgICB2YXIgcGFydHMgPSBhVmFsdWUuc3BsaXQoJ1QnKTtcbiAgICB2YXIgZHQgPSBwYXJ0c1swXSwgdG16ID0gcGFydHNbMV07XG4gICAgdmFyIHNwbGl0em9uZSA9IHRteiA/IElDQUwuZGVzaWduLnZjYXJkLnZhbHVlLnRpbWUuX3NwbGl0Wm9uZSh0bXopIDogW107XG4gICAgdmFyIHpvbmUgPSBzcGxpdHpvbmVbMF0sIHRtID0gc3BsaXR6b25lWzFdO1xuXG4gICAgdmFyIHN0b2kgPSBJQ0FMLmhlbHBlcnMuc3RyaWN0UGFyc2VJbnQ7XG4gICAgdmFyIGR0bGVuID0gZHQgPyBkdC5sZW5ndGggOiAwO1xuICAgIHZhciB0bWxlbiA9IHRtID8gdG0ubGVuZ3RoIDogMDtcblxuICAgIHZhciBoYXNEYXNoRGF0ZSA9IGR0ICYmIGR0WzBdID09ICctJyAmJiBkdFsxXSA9PSAnLSc7XG4gICAgdmFyIGhhc0Rhc2hUaW1lID0gdG0gJiYgdG1bMF0gPT0gJy0nO1xuXG4gICAgdmFyIG8gPSB7XG4gICAgICB5ZWFyOiBoYXNEYXNoRGF0ZSA/IG51bGwgOiBwYXJ0KGR0LCAwLCA0KSxcbiAgICAgIG1vbnRoOiBoYXNEYXNoRGF0ZSAmJiAoZHRsZW4gPT0gNCB8fCBkdGxlbiA9PSA3KSA/IHBhcnQoZHQsIDIsIDIpIDogZHRsZW4gPT0gNyA/IHBhcnQoZHQsIDUsIDIpIDogZHRsZW4gPT0gMTAgPyBwYXJ0KGR0LCA1LCAyKSA6IG51bGwsXG4gICAgICBkYXk6IGR0bGVuID09IDUgPyBwYXJ0KGR0LCAzLCAyKSA6IGR0bGVuID09IDcgJiYgaGFzRGFzaERhdGUgPyBwYXJ0KGR0LCA1LCAyKSA6IGR0bGVuID09IDEwID8gcGFydChkdCwgOCwgMikgOiBudWxsLFxuXG4gICAgICBob3VyOiBoYXNEYXNoVGltZSA/IG51bGwgOiBwYXJ0KHRtLCAwLCAyKSxcbiAgICAgIG1pbnV0ZTogaGFzRGFzaFRpbWUgJiYgdG1sZW4gPT0gMyA/IHBhcnQodG0sIDEsIDIpIDogdG1sZW4gPiA0ID8gaGFzRGFzaFRpbWUgPyBwYXJ0KHRtLCAxLCAyKSA6IHBhcnQodG0sIDMsIDIpIDogbnVsbCxcbiAgICAgIHNlY29uZDogdG1sZW4gPT0gNCA/IHBhcnQodG0sIDIsIDIpIDogdG1sZW4gPT0gNiA/IHBhcnQodG0sIDQsIDIpIDogdG1sZW4gPT0gOCA/IHBhcnQodG0sIDYsIDIpIDogbnVsbFxuICAgIH07XG5cbiAgICBpZiAoem9uZSA9PSAnWicpIHtcbiAgICAgIHpvbmUgPSBJQ0FMLlRpbWV6b25lLnV0Y1RpbWV6b25lO1xuICAgIH0gZWxzZSBpZiAoem9uZSAmJiB6b25lWzNdID09ICc6Jykge1xuICAgICAgem9uZSA9IElDQUwuVXRjT2Zmc2V0LmZyb21TdHJpbmcoem9uZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHpvbmUgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgSUNBTC5WQ2FyZFRpbWUobywgem9uZSwgYUljYWxUeXBlKTtcbiAgfTtcbn0pKCk7XG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICogUG9ydGlvbnMgQ29weXJpZ2h0IChDKSBQaGlsaXBwIEtld2lzY2gsIDIwMTEtMjAxNSAqL1xuXG5cblxuKGZ1bmN0aW9uKCkge1xuICB2YXIgRE9XX01BUCA9IHtcbiAgICBTVTogSUNBTC5UaW1lLlNVTkRBWSxcbiAgICBNTzogSUNBTC5UaW1lLk1PTkRBWSxcbiAgICBUVTogSUNBTC5UaW1lLlRVRVNEQVksXG4gICAgV0U6IElDQUwuVGltZS5XRURORVNEQVksXG4gICAgVEg6IElDQUwuVGltZS5USFVSU0RBWSxcbiAgICBGUjogSUNBTC5UaW1lLkZSSURBWSxcbiAgICBTQTogSUNBTC5UaW1lLlNBVFVSREFZXG4gIH07XG5cbiAgdmFyIFJFVkVSU0VfRE9XX01BUCA9IHt9O1xuICBmb3IgKHZhciBrZXkgaW4gRE9XX01BUCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKERPV19NQVAuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgUkVWRVJTRV9ET1dfTUFQW0RPV19NQVBba2V5XV0gPSBrZXk7XG4gICAgfVxuICB9XG5cbiAgdmFyIENPUFlfUEFSVFMgPSBbXCJCWVNFQ09ORFwiLCBcIkJZTUlOVVRFXCIsIFwiQllIT1VSXCIsIFwiQllEQVlcIixcbiAgICAgICAgICAgICAgICAgICAgXCJCWU1PTlRIREFZXCIsIFwiQllZRUFSREFZXCIsIFwiQllXRUVLTk9cIixcbiAgICAgICAgICAgICAgICAgICAgXCJCWU1PTlRIXCIsIFwiQllTRVRQT1NcIl07XG5cbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogVGhpcyBjbGFzcyByZXByZXNlbnRzIHRoZSBcInJlY3VyXCIgdmFsdWUgdHlwZSwgd2l0aCB2YXJpb3VzIGNhbGN1bGF0aW9uXG4gICAqIGFuZCBtYW5pcHVsYXRpb24gbWV0aG9kcy5cbiAgICpcbiAgICogQGNsYXNzXG4gICAqIEBhbGlhcyBJQ0FMLlJlY3VyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFuIG9iamVjdCB3aXRoIG1lbWJlcnMgb2YgdGhlIHJlY3VycmVuY2VcbiAgICogQHBhcmFtIHtJQ0FMLlJlY3VyLmZyZXF1ZW5jeVZhbHVlcz19IGRhdGEuZnJlcSAgICAgVGhlIGZyZXF1ZW5jeSB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcj19IGRhdGEuaW50ZXJ2YWwgICAgICAgICAgICAgICAgICAgICBUaGUgSU5URVJWQUwgdmFsdWVcbiAgICogQHBhcmFtIHtJQ0FMLlRpbWUud2Vla0RheT19IGRhdGEud2tzdCAgICAgICAgICAgICAgVGhlIHdlZWsgc3RhcnQgdmFsdWVcbiAgICogQHBhcmFtIHtJQ0FMLlRpbWU9fSBkYXRhLnVudGlsICAgICAgICAgICAgICAgICAgICAgVGhlIGVuZCBvZiB0aGUgcmVjdXJyZW5jZSBzZXRcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLmNvdW50ICAgICAgICAgICAgICAgICAgICAgICAgVGhlIG51bWJlciBvZiBvY2N1cnJlbmNlc1xuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gZGF0YS5ieXNlY29uZCAgICAgICAgICAgICBUaGUgc2Vjb25kcyBmb3IgdGhlIEJZU0VDT05EIHBhcnRcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGRhdGEuYnltaW51dGUgICAgICAgICAgICAgVGhlIG1pbnV0ZXMgZm9yIHRoZSBCWU1JTlVURSBwYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBkYXRhLmJ5aG91ciAgICAgICAgICAgICAgIFRoZSBob3VycyBmb3IgdGhlIEJZSE9VUiBwYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz49fSBkYXRhLmJ5ZGF5ICAgICAgICAgICAgICAgIFRoZSBCWURBWSB2YWx1ZXNcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGRhdGEuYnltb250aGRheSAgICAgICAgICAgVGhlIGRheXMgZm9yIHRoZSBCWU1PTlRIREFZIHBhcnRcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGRhdGEuYnl5ZWFyZGF5ICAgICAgICAgICAgVGhlIGRheXMgZm9yIHRoZSBCWVlFQVJEQVkgcGFydFxuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gZGF0YS5ieXdlZWtubyAgICAgICAgICAgICBUaGUgd2Vla3MgZm9yIHRoZSBCWVdFRUtOTyBwYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBkYXRhLmJ5bW9udGggICAgICAgICAgICAgIFRoZSBtb250aCBmb3IgdGhlIEJZTU9OVEggcGFydFxuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gZGF0YS5ieXNldHBvcyAgICAgICAgICAgICBUaGUgcG9zaXRpb25hbHMgZm9yIHRoZSBCWVNFVFBPUyBwYXJ0XG4gICAqL1xuICBJQ0FMLlJlY3VyID0gZnVuY3Rpb24gaWNhbHJlY3VyKGRhdGEpIHtcbiAgICB0aGlzLndyYXBwZWRKU09iamVjdCA9IHRoaXM7XG4gICAgdGhpcy5wYXJ0cyA9IHt9O1xuXG4gICAgaWYgKGRhdGEgJiYgdHlwZW9mKGRhdGEpID09PSAnb2JqZWN0Jykge1xuICAgICAgdGhpcy5mcm9tRGF0YShkYXRhKTtcbiAgICB9XG4gIH07XG5cbiAgSUNBTC5SZWN1ci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IGhvbGRpbmcgdGhlIEJZLXBhcnRzIG9mIHRoZSByZWN1cnJlbmNlIHJ1bGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHBhcnRzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGludGVydmFsIHZhbHVlIGZvciB0aGUgcmVjdXJyZW5jZSBydWxlLlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgaW50ZXJ2YWw6IDEsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgd2VlayBzdGFydCBkYXlcbiAgICAgKlxuICAgICAqIEB0eXBlIHtJQ0FMLlRpbWUud2Vla0RheX1cbiAgICAgKiBAZGVmYXVsdCBJQ0FMLlRpbWUuTU9OREFZXG4gICAgICovXG4gICAgd2tzdDogSUNBTC5UaW1lLk1PTkRBWSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlbmQgb2YgdGhlIHJlY3VycmVuY2VcbiAgICAgKiBAdHlwZSB7P0lDQUwuVGltZX1cbiAgICAgKi9cbiAgICB1bnRpbDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBvY2N1cnJlbmNlc1xuICAgICAqIEB0eXBlIHs/TnVtYmVyfVxuICAgICAqL1xuICAgIGNvdW50OiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGZyZXF1ZW5jeSB2YWx1ZS5cbiAgICAgKiBAdHlwZSB7SUNBTC5SZWN1ci5mcmVxdWVuY3lWYWx1ZXN9XG4gICAgICovXG4gICAgZnJlcTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBjbGFzcyBpZGVudGlmaWVyLlxuICAgICAqIEBjb25zdGFudFxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgXCJpY2FscmVjdXJcIlxuICAgICAqL1xuICAgIGljYWxjbGFzczogXCJpY2FscmVjdXJcIixcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG5hbWUsIHRvIGJlIHVzZWQgaW4gdGhlIGpDYWwgb2JqZWN0LlxuICAgICAqIEBjb25zdGFudFxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgXCJyZWN1clwiXG4gICAgICovXG4gICAgaWNhbHR5cGU6IFwicmVjdXJcIixcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBpdGVyYXRvciBmb3IgdGhpcyByZWN1cnJlbmNlIHJ1bGUuIFRoZSBwYXNzZWQgc3RhcnQgZGF0ZVxuICAgICAqIG11c3QgYmUgdGhlIHN0YXJ0IGRhdGUgb2YgdGhlIGV2ZW50LCBub3QgdGhlIHN0YXJ0IG9mIHRoZSByYW5nZSB0b1xuICAgICAqIHNlYXJjaCBpbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIHJlY3VyID0gY29tcC5nZXRGaXJzdFByb3BlcnR5VmFsdWUoJ3JydWxlJyk7XG4gICAgICogdmFyIGR0c3RhcnQgPSBjb21wLmdldEZpcnN0UHJvcGVydHlWYWx1ZSgnZHRzdGFydCcpO1xuICAgICAqIHZhciBpdGVyID0gcmVjdXIuaXRlcmF0b3IoZHRzdGFydCk7XG4gICAgICogZm9yICh2YXIgbmV4dCA9IGl0ZXIubmV4dCgpOyBuZXh0OyBuZXh0ID0gaXRlci5uZXh0KCkpIHtcbiAgICAgKiAgIGlmIChuZXh0LmNvbXBhcmUocmFuZ2VTdGFydCkgPCAwKSB7XG4gICAgICogICAgIGNvbnRpbnVlO1xuICAgICAqICAgfVxuICAgICAqICAgY29uc29sZS5sb2cobmV4dC50b1N0cmluZygpKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZX0gYVN0YXJ0ICAgICAgICBUaGUgaXRlbSdzIHN0YXJ0IGRhdGVcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlJlY3VySXRlcmF0b3J9ICAgICBUaGUgcmVjdXJyZW5jZSBpdGVyYXRvclxuICAgICAqL1xuICAgIGl0ZXJhdG9yOiBmdW5jdGlvbihhU3RhcnQpIHtcbiAgICAgIHJldHVybiBuZXcgSUNBTC5SZWN1ckl0ZXJhdG9yKHtcbiAgICAgICAgcnVsZTogdGhpcyxcbiAgICAgICAgZHRzdGFydDogYVN0YXJ0XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSByZWN1cnJlbmNlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0lDQUwuUmVjdXJ9ICAgICAgVGhlIGNsb25lZCBvYmplY3RcbiAgICAgKi9cbiAgICBjbG9uZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICByZXR1cm4gbmV3IElDQUwuUmVjdXIodGhpcy50b0pTT04oKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgY3VycmVudCBydWxlIGlzIGZpbml0ZSwgaS5lLiBoYXMgYSBjb3VudCBvciB1bnRpbCBwYXJ0LlxuICAgICAqXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgIFRydWUsIGlmIHRoZSBydWxlIGlzIGZpbml0ZVxuICAgICAqL1xuICAgIGlzRmluaXRlOiBmdW5jdGlvbiBpc2Zpbml0ZSgpIHtcbiAgICAgIHJldHVybiAhISh0aGlzLmNvdW50IHx8IHRoaXMudW50aWwpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGN1cnJlbnQgcnVsZSBoYXMgYSBjb3VudCBwYXJ0LCBhbmQgbm90IGxpbWl0ZWQgYnkgYW4gdW50aWxcbiAgICAgKiBwYXJ0LlxuICAgICAqXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgIFRydWUsIGlmIHRoZSBydWxlIGlzIGJ5IGNvdW50XG4gICAgICovXG4gICAgaXNCeUNvdW50OiBmdW5jdGlvbiBpc2J5Y291bnQoKSB7XG4gICAgICByZXR1cm4gISEodGhpcy5jb3VudCAmJiAhdGhpcy51bnRpbCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBjb21wb25lbnQgKHBhcnQpIHRvIHRoZSByZWN1cnJlbmNlIHJ1bGUuIFRoaXMgaXMgbm90IGEgY29tcG9uZW50XG4gICAgICogaW4gdGhlIHNlbnNlIG9mIHtAbGluayBJQ0FMLkNvbXBvbmVudH0sIGJ1dCBhIHBhcnQgb2YgdGhlIHJlY3VycmVuY2VcbiAgICAgKiBydWxlLCBpLmUuIEJZTU9OVEguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYVR5cGUgICAgICAgICAgICBUaGUgbmFtZSBvZiB0aGUgY29tcG9uZW50IHBhcnRcbiAgICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gYVZhbHVlICAgICBUaGUgY29tcG9uZW50IHZhbHVlXG4gICAgICovXG4gICAgYWRkQ29tcG9uZW50OiBmdW5jdGlvbiBhZGRQYXJ0KGFUeXBlLCBhVmFsdWUpIHtcbiAgICAgIHZhciB1Y25hbWUgPSBhVHlwZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgaWYgKHVjbmFtZSBpbiB0aGlzLnBhcnRzKSB7XG4gICAgICAgIHRoaXMucGFydHNbdWNuYW1lXS5wdXNoKGFWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhcnRzW3VjbmFtZV0gPSBbYVZhbHVlXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY29tcG9uZW50IHZhbHVlIGZvciB0aGUgZ2l2ZW4gYnktcGFydC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhVHlwZSAgICAgICAgVGhlIGNvbXBvbmVudCBwYXJ0IG5hbWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhVmFsdWVzICAgICAgIFRoZSBjb21wb25lbnQgdmFsdWVzXG4gICAgICovXG4gICAgc2V0Q29tcG9uZW50OiBmdW5jdGlvbiBzZXRDb21wb25lbnQoYVR5cGUsIGFWYWx1ZXMpIHtcbiAgICAgIHRoaXMucGFydHNbYVR5cGUudG9VcHBlckNhc2UoKV0gPSBhVmFsdWVzLnNsaWNlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgKGEgY29weSkgb2YgdGhlIHJlcXVlc3RlZCBjb21wb25lbnQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYVR5cGUgICAgICAgIFRoZSBjb21wb25lbnQgcGFydCBuYW1lXG4gICAgICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgICAgICBUaGUgY29tcG9uZW50IHBhcnQgdmFsdWVcbiAgICAgKi9cbiAgICBnZXRDb21wb25lbnQ6IGZ1bmN0aW9uIGdldENvbXBvbmVudChhVHlwZSkge1xuICAgICAgdmFyIHVjbmFtZSA9IGFUeXBlLnRvVXBwZXJDYXNlKCk7XG4gICAgICByZXR1cm4gKHVjbmFtZSBpbiB0aGlzLnBhcnRzID8gdGhpcy5wYXJ0c1t1Y25hbWVdLnNsaWNlKCkgOiBbXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgbmV4dCBvY2N1cnJlbmNlIGFmdGVyIHRoZSBnaXZlbiByZWN1cnJlbmNlIGlkLiBTZWUgdGhlXG4gICAgICogZ3VpZGUgb24ge0B0dXRvcmlhbCB0ZXJtaW5vbG9neX0gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIE5PVEU6IEN1cnJlbnRseSwgdGhpcyBtZXRob2QgaXRlcmF0ZXMgYWxsIG9jY3VycmVuY2VzIGZyb20gdGhlIHN0YXJ0XG4gICAgICogZGF0ZS4gSXQgc2hvdWxkIG5vdCBiZSBjYWxsZWQgaW4gYSBsb29wIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiBJZiB5b3VcbiAgICAgKiB3b3VsZCBsaWtlIHRvIGdldCBtb3JlIHRoYW4gb25lIG9jY3VycmVuY2UsIHlvdSBjYW4gaXRlcmF0ZSB0aGVcbiAgICAgKiBvY2N1cnJlbmNlcyBtYW51YWxseSwgc2VlIHRoZSBleGFtcGxlIG9uIHRoZVxuICAgICAqIHtAbGluayBJQ0FMLlJlY3VyI2l0ZXJhdG9yIGl0ZXJhdG9yfSBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZX0gYVN0YXJ0VGltZSAgICAgICAgVGhlIHN0YXJ0IG9mIHRoZSBldmVudCBzZXJpZXNcbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZX0gYVJlY3VycmVuY2VJZCAgICAgVGhlIGRhdGUgb2YgdGhlIGxhc3Qgb2NjdXJyZW5jZVxuICAgICAqIEByZXR1cm4ge0lDQUwuVGltZX0gICAgICAgICAgICAgICAgICBUaGUgbmV4dCBvY2N1cnJlbmNlIGFmdGVyXG4gICAgICovXG4gICAgZ2V0TmV4dE9jY3VycmVuY2U6IGZ1bmN0aW9uIGdldE5leHRPY2N1cnJlbmNlKGFTdGFydFRpbWUsIGFSZWN1cnJlbmNlSWQpIHtcbiAgICAgIHZhciBpdGVyID0gdGhpcy5pdGVyYXRvcihhU3RhcnRUaW1lKTtcbiAgICAgIHZhciBuZXh0LCBjZHQ7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgbmV4dCA9IGl0ZXIubmV4dCgpO1xuICAgICAgfSB3aGlsZSAobmV4dCAmJiBuZXh0LmNvbXBhcmUoYVJlY3VycmVuY2VJZCkgPD0gMCk7XG5cbiAgICAgIGlmIChuZXh0ICYmIGFSZWN1cnJlbmNlSWQuem9uZSkge1xuICAgICAgICBuZXh0LnpvbmUgPSBhUmVjdXJyZW5jZUlkLnpvbmU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIHRoZSBjdXJyZW50IGluc3RhbmNlIHVzaW5nIG1lbWJlcnMgZnJvbSB0aGUgcGFzc2VkIGRhdGEgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQW4gb2JqZWN0IHdpdGggbWVtYmVycyBvZiB0aGUgcmVjdXJyZW5jZVxuICAgICAqIEBwYXJhbSB7SUNBTC5SZWN1ci5mcmVxdWVuY3lWYWx1ZXM9fSBkYXRhLmZyZXEgICAgIFRoZSBmcmVxdWVuY3kgdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcj19IGRhdGEuaW50ZXJ2YWwgICAgICAgICAgICAgICAgICAgICBUaGUgSU5URVJWQUwgdmFsdWVcbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZS53ZWVrRGF5PX0gZGF0YS53a3N0ICAgICAgICAgICAgICBUaGUgd2VlayBzdGFydCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7SUNBTC5UaW1lPX0gZGF0YS51bnRpbCAgICAgICAgICAgICAgICAgICAgIFRoZSBlbmQgb2YgdGhlIHJlY3VycmVuY2Ugc2V0XG4gICAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLmNvdW50ICAgICAgICAgICAgICAgICAgICAgICAgVGhlIG51bWJlciBvZiBvY2N1cnJlbmNlc1xuICAgICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBkYXRhLmJ5c2Vjb25kICAgICAgICAgICAgIFRoZSBzZWNvbmRzIGZvciB0aGUgQllTRUNPTkQgcGFydFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBkYXRhLmJ5bWludXRlICAgICAgICAgICAgIFRoZSBtaW51dGVzIGZvciB0aGUgQllNSU5VVEUgcGFydFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBkYXRhLmJ5aG91ciAgICAgICAgICAgICAgIFRoZSBob3VycyBmb3IgdGhlIEJZSE9VUiBwYXJ0XG4gICAgICogQHBhcmFtIHtBcnJheS48U3RyaW5nPj19IGRhdGEuYnlkYXkgICAgICAgICAgICAgICAgVGhlIEJZREFZIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBkYXRhLmJ5bW9udGhkYXkgICAgICAgICAgIFRoZSBkYXlzIGZvciB0aGUgQllNT05USERBWSBwYXJ0XG4gICAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGRhdGEuYnl5ZWFyZGF5ICAgICAgICAgICAgVGhlIGRheXMgZm9yIHRoZSBCWVlFQVJEQVkgcGFydFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBkYXRhLmJ5d2Vla25vICAgICAgICAgICAgIFRoZSB3ZWVrcyBmb3IgdGhlIEJZV0VFS05PIHBhcnRcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gZGF0YS5ieW1vbnRoICAgICAgICAgICAgICBUaGUgbW9udGggZm9yIHRoZSBCWU1PTlRIIHBhcnRcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gZGF0YS5ieXNldHBvcyAgICAgICAgICAgICBUaGUgcG9zaXRpb25hbHMgZm9yIHRoZSBCWVNFVFBPUyBwYXJ0XG4gICAgICovXG4gICAgZnJvbURhdGE6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgIHZhciB1Y2tleSA9IGtleS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgIGlmICh1Y2tleSBpbiBwYXJ0RGVzaWduKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YVtrZXldKSkge1xuICAgICAgICAgICAgdGhpcy5wYXJ0c1t1Y2tleV0gPSBkYXRhW2tleV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGFydHNbdWNrZXldID0gW2RhdGFba2V5XV07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXNba2V5XSA9IGRhdGFba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pbnRlcnZhbCAmJiB0eXBlb2YgdGhpcy5pbnRlcnZhbCAhPSBcIm51bWJlclwiKSB7XG4gICAgICAgIG9wdGlvbkRlc2lnbi5JTlRFUlZBTCh0aGlzLmludGVydmFsLCB0aGlzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMud2tzdCAmJiB0eXBlb2YgdGhpcy53a3N0ICE9IFwibnVtYmVyXCIpIHtcbiAgICAgICAgdGhpcy53a3N0ID0gSUNBTC5SZWN1ci5pY2FsRGF5VG9OdW1lcmljRGF5KHRoaXMud2tzdCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnVudGlsICYmICEodGhpcy51bnRpbCBpbnN0YW5jZW9mIElDQUwuVGltZSkpIHtcbiAgICAgICAgdGhpcy51bnRpbCA9IElDQUwuVGltZS5mcm9tU3RyaW5nKHRoaXMudW50aWwpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgakNhbCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHJlY3VycmVuY2UgdHlwZS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgcmVzLmZyZXEgPSB0aGlzLmZyZXE7XG5cbiAgICAgIGlmICh0aGlzLmNvdW50KSB7XG4gICAgICAgIHJlcy5jb3VudCA9IHRoaXMuY291bnQ7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmludGVydmFsID4gMSkge1xuICAgICAgICByZXMuaW50ZXJ2YWwgPSB0aGlzLmludGVydmFsO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBrIGluIHRoaXMucGFydHMpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghdGhpcy5wYXJ0cy5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrcGFydHMgPSB0aGlzLnBhcnRzW2tdO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShrcGFydHMpICYmIGtwYXJ0cy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgIHJlc1trLnRvTG93ZXJDYXNlKCldID0ga3BhcnRzWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc1trLnRvTG93ZXJDYXNlKCldID0gSUNBTC5oZWxwZXJzLmNsb25lKHRoaXMucGFydHNba10pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnVudGlsKSB7XG4gICAgICAgIHJlcy51bnRpbCA9IHRoaXMudW50aWwudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGlmICgnd2tzdCcgaW4gdGhpcyAmJiB0aGlzLndrc3QgIT09IElDQUwuVGltZS5ERUZBVUxUX1dFRUtfU1RBUlQpIHtcbiAgICAgICAgcmVzLndrc3QgPSBJQ0FMLlJlY3VyLm51bWVyaWNEYXlUb0ljYWxEYXkodGhpcy53a3N0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyByZWN1cnJlbmNlIHJ1bGUuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiBpY2FscmVjdXJfdG9TdHJpbmcoKSB7XG4gICAgICAvLyBUT0RPIHJldGFpbiBvcmRlclxuICAgICAgdmFyIHN0ciA9IFwiRlJFUT1cIiArIHRoaXMuZnJlcTtcbiAgICAgIGlmICh0aGlzLmNvdW50KSB7XG4gICAgICAgIHN0ciArPSBcIjtDT1VOVD1cIiArIHRoaXMuY291bnQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pbnRlcnZhbCA+IDEpIHtcbiAgICAgICAgc3RyICs9IFwiO0lOVEVSVkFMPVwiICsgdGhpcy5pbnRlcnZhbDtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGsgaW4gdGhpcy5wYXJ0cykge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAodGhpcy5wYXJ0cy5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgIHN0ciArPSBcIjtcIiArIGsgKyBcIj1cIiArIHRoaXMucGFydHNba107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnVudGlsKSB7XG4gICAgICAgIHN0ciArPSAnO1VOVElMPScgKyB0aGlzLnVudGlsLnRvSUNBTFN0cmluZygpO1xuICAgICAgfVxuICAgICAgaWYgKCd3a3N0JyBpbiB0aGlzICYmIHRoaXMud2tzdCAhPT0gSUNBTC5UaW1lLkRFRkFVTFRfV0VFS19TVEFSVCkge1xuICAgICAgICBzdHIgKz0gJztXS1NUPScgKyBJQ0FMLlJlY3VyLm51bWVyaWNEYXlUb0ljYWxEYXkodGhpcy53a3N0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIHBhcnNlTnVtZXJpY1ZhbHVlKHR5cGUsIG1pbiwgbWF4LCB2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSB2YWx1ZTtcblxuICAgIGlmICh2YWx1ZVswXSA9PT0gJysnKSB7XG4gICAgICByZXN1bHQgPSB2YWx1ZS5zdWJzdHIoMSk7XG4gICAgfVxuXG4gICAgcmVzdWx0ID0gSUNBTC5oZWxwZXJzLnN0cmljdFBhcnNlSW50KHJlc3VsdCk7XG5cbiAgICBpZiAobWluICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgPCBtaW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgdHlwZSArICc6IGludmFsaWQgdmFsdWUgXCInICsgdmFsdWUgKyAnXCIgbXVzdCBiZSA+ICcgKyBtaW5cbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKG1heCAhPT0gdW5kZWZpbmVkICYmIHZhbHVlID4gbWF4KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIHR5cGUgKyAnOiBpbnZhbGlkIHZhbHVlIFwiJyArIHZhbHVlICsgJ1wiIG11c3QgYmUgPCAnICsgbWluXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBhbiBpY2FsIHJlcHJlc2VudGF0aW9uIG9mIGEgZGF5IChTVSwgTU8sIGV0Yy4uKVxuICAgKiBpbnRvIGEgbnVtZXJpYyB2YWx1ZSBvZiB0aGF0IGRheS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyAgICAgVGhlIGlDYWxlbmRhciBkYXkgbmFtZVxuICAgKiBAcGFyYW0ge0lDQUwuVGltZS53ZWVrRGF5PX0gYVdlZWtTdGFydFxuICAgKiAgICAgICAgVGhlIHdlZWsgc3RhcnQgd2Vla2RheSwgZGVmYXVsdHMgdG8gU1VOREFZXG4gICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgIE51bWVyaWMgdmFsdWUgb2YgZ2l2ZW4gZGF5XG4gICAqL1xuICBJQ0FMLlJlY3VyLmljYWxEYXlUb051bWVyaWNEYXkgPSBmdW5jdGlvbiB0b051bWVyaWNEYXkoc3RyaW5nLCBhV2Vla1N0YXJ0KSB7XG4gICAgLy9YWFg6IHRoaXMgaXMgaGVyZSBzbyB3ZSBjYW4gZGVhbFxuICAgIC8vICAgICB3aXRoIHBvc3NpYmx5IGludmFsaWQgc3RyaW5nIHZhbHVlcy5cbiAgICB2YXIgZmlyc3REb3cgPSBhV2Vla1N0YXJ0IHx8IElDQUwuVGltZS5TVU5EQVk7XG4gICAgcmV0dXJuICgoRE9XX01BUFtzdHJpbmddIC0gZmlyc3REb3cgKyA3KSAlIDcpICsgMTtcbiAgfTtcblxuICAvKipcbiAgICogQ29udmVydCBhIG51bWVyaWMgZGF5IHZhbHVlIGludG8gaXRzIGljYWwgcmVwcmVzZW50YXRpb24gKFNVLCBNTywgZXRjLi4pXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBudW0gICAgICAgIE51bWVyaWMgdmFsdWUgb2YgZ2l2ZW4gZGF5XG4gICAqIEBwYXJhbSB7SUNBTC5UaW1lLndlZWtEYXk9fSBhV2Vla1N0YXJ0XG4gICAqICAgICAgICBUaGUgd2VlayBzdGFydCB3ZWVrZGF5LCBkZWZhdWx0cyB0byBTVU5EQVlcbiAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICAgVGhlIElDQUwgZGF5IHZhbHVlLCBlLmcgU1UsTU8sLi4uXG4gICAqL1xuICBJQ0FMLlJlY3VyLm51bWVyaWNEYXlUb0ljYWxEYXkgPSBmdW5jdGlvbiB0b0ljYWxEYXkobnVtLCBhV2Vla1N0YXJ0KSB7XG4gICAgLy9YWFg6IHRoaXMgaXMgaGVyZSBzbyB3ZSBjYW4gZGVhbCB3aXRoIHBvc3NpYmx5IGludmFsaWQgbnVtYmVyIHZhbHVlcy5cbiAgICAvLyAgICAgQWxzbywgdGhpcyBhbGxvd3MgY29uc2lzdGVudCBtYXBwaW5nIGJldHdlZW4gZGF5IG51bWJlcnMgYW5kIGRheVxuICAgIC8vICAgICBuYW1lcyBmb3IgZXh0ZXJuYWwgdXNlcnMuXG4gICAgdmFyIGZpcnN0RG93ID0gYVdlZWtTdGFydCB8fCBJQ0FMLlRpbWUuU1VOREFZO1xuICAgIHZhciBkb3cgPSAobnVtICsgZmlyc3REb3cgLSBJQ0FMLlRpbWUuU1VOREFZKTtcbiAgICBpZiAoZG93ID4gNykge1xuICAgICAgZG93IC09IDc7XG4gICAgfVxuICAgIHJldHVybiBSRVZFUlNFX0RPV19NQVBbZG93XTtcbiAgfTtcblxuICB2YXIgVkFMSURfREFZX05BTUVTID0gL14oU1V8TU98VFV8V0V8VEh8RlJ8U0EpJC87XG4gIHZhciBWQUxJRF9CWURBWV9QQVJUID0gL14oWystXSk/KDVbMC0zXXxbMS00XVswLTldfFsxLTldKT8oU1V8TU98VFV8V0V8VEh8RlJ8U0EpJC87XG5cbiAgLyoqXG4gICAqIFBvc3NpYmxlIGZyZXF1ZW5jeSB2YWx1ZXMgZm9yIHRoZSBGUkVRIHBhcnRcbiAgICogKFlFQVJMWSwgTU9OVEhMWSwgV0VFS0xZLCBEQUlMWSwgSE9VUkxZLCBNSU5VVEVMWSwgU0VDT05ETFkpXG4gICAqXG4gICAqIEB0eXBlZGVmIHtTdHJpbmd9IGZyZXF1ZW5jeVZhbHVlc1xuICAgKiBAbWVtYmVyb2YgSUNBTC5SZWN1clxuICAgKi9cblxuICB2YXIgQUxMT1dFRF9GUkVRID0gWydTRUNPTkRMWScsICdNSU5VVEVMWScsICdIT1VSTFknLFxuICAgICAgICAgICAgICAgICAgICAgICdEQUlMWScsICdXRUVLTFknLCAnTU9OVEhMWScsICdZRUFSTFknXTtcblxuICB2YXIgb3B0aW9uRGVzaWduID0ge1xuICAgIEZSRVE6IGZ1bmN0aW9uKHZhbHVlLCBkaWN0LCBmbXRJY2FsKSB7XG4gICAgICAvLyB5ZXMgdGhpcyBpcyBhY3R1YWxseSBlcXVhbCBvciBmYXN0ZXIgdGhlbiByZWdleC5cbiAgICAgIC8vIHVwc2lkZSBoZXJlIGlzIHdlIGNhbiBlbnVtZXJhdGUgdGhlIHZhbGlkIHZhbHVlcy5cbiAgICAgIGlmIChBTExPV0VEX0ZSRVEuaW5kZXhPZih2YWx1ZSkgIT09IC0xKSB7XG4gICAgICAgIGRpY3QuZnJlcSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdpbnZhbGlkIGZyZXF1ZW5jeSBcIicgKyB2YWx1ZSArICdcIiBleHBlY3RlZDogXCInICtcbiAgICAgICAgICBBTExPV0VEX0ZSRVEuam9pbignLCAnKSArICdcIidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgQ09VTlQ6IGZ1bmN0aW9uKHZhbHVlLCBkaWN0LCBmbXRJY2FsKSB7XG4gICAgICBkaWN0LmNvdW50ID0gSUNBTC5oZWxwZXJzLnN0cmljdFBhcnNlSW50KHZhbHVlKTtcbiAgICB9LFxuXG4gICAgSU5URVJWQUw6IGZ1bmN0aW9uKHZhbHVlLCBkaWN0LCBmbXRJY2FsKSB7XG4gICAgICBkaWN0LmludGVydmFsID0gSUNBTC5oZWxwZXJzLnN0cmljdFBhcnNlSW50KHZhbHVlKTtcbiAgICAgIGlmIChkaWN0LmludGVydmFsIDwgMSkge1xuICAgICAgICAvLyAwIG9yIG5lZ2F0aXZlIHZhbHVlcyBhcmUgbm90IGFsbG93ZWQsIHNvbWUgZW5naW5lcyBzZWVtIHRvIGdlbmVyYXRlXG4gICAgICAgIC8vIGl0IHRob3VnaC4gQXNzdW1lIDEgaW5zdGVhZC5cbiAgICAgICAgZGljdC5pbnRlcnZhbCA9IDE7XG4gICAgICB9XG4gICAgfSxcblxuICAgIFVOVElMOiBmdW5jdGlvbih2YWx1ZSwgZGljdCwgZm10SWNhbCkge1xuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDEwKSB7XG4gICAgICAgIGRpY3QudW50aWwgPSBJQ0FMLmRlc2lnbi5pY2FsZW5kYXIudmFsdWVbJ2RhdGUtdGltZSddLmZyb21JQ0FMKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpY3QudW50aWwgPSBJQ0FMLmRlc2lnbi5pY2FsZW5kYXIudmFsdWUuZGF0ZS5mcm9tSUNBTCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoIWZtdEljYWwpIHtcbiAgICAgICAgZGljdC51bnRpbCA9IElDQUwuVGltZS5mcm9tU3RyaW5nKGRpY3QudW50aWwpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBXS1NUOiBmdW5jdGlvbih2YWx1ZSwgZGljdCwgZm10SWNhbCkge1xuICAgICAgaWYgKFZBTElEX0RBWV9OQU1FUy50ZXN0KHZhbHVlKSkge1xuICAgICAgICBkaWN0Lndrc3QgPSBJQ0FMLlJlY3VyLmljYWxEYXlUb051bWVyaWNEYXkodmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFdLU1QgdmFsdWUgXCInICsgdmFsdWUgKyAnXCInKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIHBhcnREZXNpZ24gPSB7XG4gICAgQllTRUNPTkQ6IHBhcnNlTnVtZXJpY1ZhbHVlLmJpbmQodGhpcywgJ0JZU0VDT05EJywgMCwgNjApLFxuICAgIEJZTUlOVVRFOiBwYXJzZU51bWVyaWNWYWx1ZS5iaW5kKHRoaXMsICdCWU1JTlVURScsIDAsIDU5KSxcbiAgICBCWUhPVVI6IHBhcnNlTnVtZXJpY1ZhbHVlLmJpbmQodGhpcywgJ0JZSE9VUicsIDAsIDIzKSxcbiAgICBCWURBWTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmIChWQUxJRF9CWURBWV9QQVJULnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBCWURBWSB2YWx1ZSBcIicgKyB2YWx1ZSArICdcIicpO1xuICAgICAgfVxuICAgIH0sXG4gICAgQllNT05USERBWTogcGFyc2VOdW1lcmljVmFsdWUuYmluZCh0aGlzLCAnQllNT05USERBWScsIC0zMSwgMzEpLFxuICAgIEJZWUVBUkRBWTogcGFyc2VOdW1lcmljVmFsdWUuYmluZCh0aGlzLCAnQllZRUFSREFZJywgLTM2NiwgMzY2KSxcbiAgICBCWVdFRUtOTzogcGFyc2VOdW1lcmljVmFsdWUuYmluZCh0aGlzLCAnQllXRUVLTk8nLCAtNTMsIDUzKSxcbiAgICBCWU1PTlRIOiBwYXJzZU51bWVyaWNWYWx1ZS5iaW5kKHRoaXMsICdCWU1PTlRIJywgMSwgMTIpLFxuICAgIEJZU0VUUE9TOiBwYXJzZU51bWVyaWNWYWx1ZS5iaW5kKHRoaXMsICdCWVNFVFBPUycsIC0zNjYsIDM2NilcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBJQ0FMLlJlY3VyfSBpbnN0YW5jZSBmcm9tIHRoZSBwYXNzZWQgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nICAgICAgICAgVGhlIHN0cmluZyB0byBwYXJzZVxuICAgKiBAcmV0dXJuIHtJQ0FMLlJlY3VyfSAgICAgICAgICAgVGhlIGNyZWF0ZWQgcmVjdXJyZW5jZSBpbnN0YW5jZVxuICAgKi9cbiAgSUNBTC5SZWN1ci5mcm9tU3RyaW5nID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIGRhdGEgPSBJQ0FMLlJlY3VyLl9zdHJpbmdUb0RhdGEoc3RyaW5nLCBmYWxzZSk7XG4gICAgcmV0dXJuIG5ldyBJQ0FMLlJlY3VyKGRhdGEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBJQ0FMLlJlY3VyfSBpbnN0YW5jZSB1c2luZyBtZW1iZXJzIGZyb20gdGhlIHBhc3NlZFxuICAgKiBkYXRhIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFEYXRhICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQW4gb2JqZWN0IHdpdGggbWVtYmVycyBvZiB0aGUgcmVjdXJyZW5jZVxuICAgKiBAcGFyYW0ge0lDQUwuUmVjdXIuZnJlcXVlbmN5VmFsdWVzPX0gYURhdGEuZnJlcSAgICBUaGUgZnJlcXVlbmN5IHZhbHVlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEuaW50ZXJ2YWwgICAgICAgICAgICAgICAgICAgIFRoZSBJTlRFUlZBTCB2YWx1ZVxuICAgKiBAcGFyYW0ge0lDQUwuVGltZS53ZWVrRGF5PX0gYURhdGEud2tzdCAgICAgICAgICAgICBUaGUgd2VlayBzdGFydCB2YWx1ZVxuICAgKiBAcGFyYW0ge0lDQUwuVGltZT19IGFEYXRhLnVudGlsICAgICAgICAgICAgICAgICAgICBUaGUgZW5kIG9mIHRoZSByZWN1cnJlbmNlIHNldFxuICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLmNvdW50ICAgICAgICAgICAgICAgICAgICAgICBUaGUgbnVtYmVyIG9mIG9jY3VycmVuY2VzXG4gICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBhRGF0YS5ieXNlY29uZCAgICAgICAgICAgIFRoZSBzZWNvbmRzIGZvciB0aGUgQllTRUNPTkQgcGFydFxuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gYURhdGEuYnltaW51dGUgICAgICAgICAgICBUaGUgbWludXRlcyBmb3IgdGhlIEJZTUlOVVRFIHBhcnRcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGFEYXRhLmJ5aG91ciAgICAgICAgICAgICAgVGhlIGhvdXJzIGZvciB0aGUgQllIT1VSIHBhcnRcbiAgICogQHBhcmFtIHtBcnJheS48U3RyaW5nPj19IGFEYXRhLmJ5ZGF5ICAgICAgICAgICAgICAgVGhlIEJZREFZIHZhbHVlc1xuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gYURhdGEuYnltb250aGRheSAgICAgICAgICBUaGUgZGF5cyBmb3IgdGhlIEJZTU9OVEhEQVkgcGFydFxuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gYURhdGEuYnl5ZWFyZGF5ICAgICAgICAgICBUaGUgZGF5cyBmb3IgdGhlIEJZWUVBUkRBWSBwYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBhRGF0YS5ieXdlZWtubyAgICAgICAgICAgIFRoZSB3ZWVrcyBmb3IgdGhlIEJZV0VFS05PIHBhcnRcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGFEYXRhLmJ5bW9udGggICAgICAgICAgICAgVGhlIG1vbnRoIGZvciB0aGUgQllNT05USCBwYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBhRGF0YS5ieXNldHBvcyAgICAgICAgICAgIFRoZSBwb3NpdGlvbmFscyBmb3IgdGhlIEJZU0VUUE9TIHBhcnRcbiAgICovXG4gIElDQUwuUmVjdXIuZnJvbURhdGEgPSBmdW5jdGlvbihhRGF0YSkge1xuICAgIHJldHVybiBuZXcgSUNBTC5SZWN1cihhRGF0YSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgcmVjdXJyZW5jZSBzdHJpbmcgdG8gYSBkYXRhIG9iamVjdCwgc3VpdGFibGUgZm9yIHRoZSBmcm9tRGF0YVxuICAgKiBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgICAgIFRoZSBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtCb29sZWFufSBmbXRJY2FsICAgSWYgdHJ1ZSwgdGhlIHN0cmluZyBpcyBjb25zaWRlcmVkIHRvIGJlIGFuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaUNhbGVuZGFyIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtJQ0FMLlJlY3VyfSAgICAgICBUaGUgcmVjdXJyZW5jZSBpbnN0YW5jZVxuICAgKi9cbiAgSUNBTC5SZWN1ci5fc3RyaW5nVG9EYXRhID0gZnVuY3Rpb24oc3RyaW5nLCBmbXRJY2FsKSB7XG4gICAgdmFyIGRpY3QgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgLy8gc3BsaXQgaXMgc2xvd2VyIGluIEZGIGJ1dCBmYXN0IGVub3VnaC5cbiAgICAvLyB2OCBob3dldmVyIHRoaXMgaXMgZmFzdGVyIHRoZW4gbWFudWFsIHNwbGl0P1xuICAgIHZhciB2YWx1ZXMgPSBzdHJpbmcuc3BsaXQoJzsnKTtcbiAgICB2YXIgbGVuID0gdmFsdWVzLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBwYXJ0cyA9IHZhbHVlc1tpXS5zcGxpdCgnPScpO1xuICAgICAgdmFyIHVjbmFtZSA9IHBhcnRzWzBdLnRvVXBwZXJDYXNlKCk7XG4gICAgICB2YXIgbGNuYW1lID0gcGFydHNbMF0udG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBuYW1lID0gKGZtdEljYWwgPyBsY25hbWUgOiB1Y25hbWUpO1xuICAgICAgdmFyIHZhbHVlID0gcGFydHNbMV07XG5cbiAgICAgIGlmICh1Y25hbWUgaW4gcGFydERlc2lnbikge1xuICAgICAgICB2YXIgcGFydEFyciA9IHZhbHVlLnNwbGl0KCcsJyk7XG4gICAgICAgIHZhciBwYXJ0QXJySWR4ID0gMDtcbiAgICAgICAgdmFyIHBhcnRBcnJMZW4gPSBwYXJ0QXJyLmxlbmd0aDtcblxuICAgICAgICBmb3IgKDsgcGFydEFycklkeCA8IHBhcnRBcnJMZW47IHBhcnRBcnJJZHgrKykge1xuICAgICAgICAgIHBhcnRBcnJbcGFydEFycklkeF0gPSBwYXJ0RGVzaWduW3VjbmFtZV0ocGFydEFycltwYXJ0QXJySWR4XSk7XG4gICAgICAgIH1cbiAgICAgICAgZGljdFtuYW1lXSA9IChwYXJ0QXJyLmxlbmd0aCA9PSAxID8gcGFydEFyclswXSA6IHBhcnRBcnIpO1xuICAgICAgfSBlbHNlIGlmICh1Y25hbWUgaW4gb3B0aW9uRGVzaWduKSB7XG4gICAgICAgIG9wdGlvbkRlc2lnblt1Y25hbWVdKHZhbHVlLCBkaWN0LCBmbXRJY2FsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIERvbid0IHN3YWxsb3cgdW5rbm93biB2YWx1ZXMuIEp1c3Qgc2V0IHRoZW0gYXMgdGhleSBhcmUuXG4gICAgICAgIGRpY3RbbGNuYW1lXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkaWN0O1xuICB9O1xufSkoKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAxMS0yMDE1ICovXG5cblxuLyoqXG4gKiBUaGlzIHN5bWJvbCBpcyBmdXJ0aGVyIGRlc2NyaWJlZCBsYXRlciBvblxuICogQGlnbm9yZVxuICovXG5JQ0FMLlJlY3VySXRlcmF0b3IgPSAoZnVuY3Rpb24oKSB7XG5cbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogQW4gaXRlcmF0b3IgZm9yIGEgc2luZ2xlIHJlY3VycmVuY2UgcnVsZS4gVGhpcyBjbGFzcyB1c3VhbGx5IGRvZXNuJ3QgaGF2ZVxuICAgKiB0byBiZSBpbnN0YW5jaWF0ZWQgZGlyZWN0bHksIHRoZSBjb252ZW5pZW5jZSBtZXRob2RcbiAgICoge0BsaW5rIElDQUwuUmVjdXIjaXRlcmF0b3J9IGNhbiBiZSB1c2VkLlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogVGhlIG9wdGlvbnMgb2JqZWN0IG1heSBjb250YWluIGFkZGl0aW9uYWwgbWVtYmVycyB3aGVuIHJlc3VtaW5nIGl0ZXJhdGlvbiBmcm9tIGEgcHJldmlvdXMgcnVuXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBUaGUgb3B0aW9ucyBvYmplY3QgbWF5IGNvbnRhaW4gYWRkaXRpb25hbCBtZW1iZXJzIHdoZW4gcmVzdW1pbmcgaXRlcmF0aW9uXG4gICAqIGZyb20gYSBwcmV2aW91cyBydW4uXG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAYWxpYXMgSUNBTC5SZWN1ckl0ZXJhdG9yXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zICAgICAgICAgICAgICAgIFRoZSBpdGVyYXRvciBvcHRpb25zXG4gICAqIEBwYXJhbSB7SUNBTC5SZWN1cn0gb3B0aW9ucy5ydWxlICAgICAgIFRoZSBydWxlIHRvIGl0ZXJhdGUuXG4gICAqIEBwYXJhbSB7SUNBTC5UaW1lfSBvcHRpb25zLmR0c3RhcnQgICAgIFRoZSBzdGFydCBkYXRlIG9mIHRoZSBldmVudC5cbiAgICogQHBhcmFtIHtCb29sZWFuPX0gb3B0aW9ucy5pbml0aWFsaXplZCAgV2hlbiB0cnVlLCBhc3N1bWUgdGhhdCBvcHRpb25zIGFyZVxuICAgKiAgICAgICAgZnJvbSBhIHByZXZpb3VzbHkgY29uc3RydWN0ZWQgaXRlcmF0b3IuIEluaXRpYWxpemF0aW9uIHdpbGwgbm90IGJlXG4gICAqICAgICAgICByZXBlYXRlZC5cbiAgICovXG4gIGZ1bmN0aW9uIGljYWxyZWN1cl9pdGVyYXRvcihvcHRpb25zKSB7XG4gICAgdGhpcy5mcm9tRGF0YShvcHRpb25zKTtcbiAgfVxuXG4gIGljYWxyZWN1cl9pdGVyYXRvci5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBUcnVlIHdoZW4gaXRlcmF0aW9uIGlzIGZpbmlzaGVkLlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIGNvbXBsZXRlZDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgcnVsZSB0aGF0IGlzIGJlaW5nIGl0ZXJhdGVkXG4gICAgICogQHR5cGUge0lDQUwuUmVjdXJ9XG4gICAgICovXG4gICAgcnVsZTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdGFydCBkYXRlIG9mIHRoZSBldmVudCBiZWluZyBpdGVyYXRlZC5cbiAgICAgKiBAdHlwZSB7SUNBTC5UaW1lfVxuICAgICAqL1xuICAgIGR0c3RhcnQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGFzdCBvY2N1cnJlbmNlIHRoYXQgd2FzIHJldHVybmVkIGZyb20gdGhlXG4gICAgICoge0BsaW5rIElDQUwuUmVjdXJJdGVyYXRvciNuZXh0fSBtZXRob2QuXG4gICAgICogQHR5cGUge0lDQUwuVGltZX1cbiAgICAgKi9cbiAgICBsYXN0OiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHNlcXVlbmNlIG51bWJlciBmcm9tIHRoZSBvY2N1cnJlbmNlXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBvY2N1cnJlbmNlX251bWJlcjogMCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbmRpY2VzIHVzZWQgZm9yIHRoZSB7QGxpbmsgSUNBTC5SZWN1ckl0ZXJhdG9yI2J5X2RhdGF9IG9iamVjdC5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYnlfaW5kaWNlczogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHRoZSBpdGVyYXRvciBoYXMgYWxyZWFkeSBiZWVuIGluaXRpYWxpemVkXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBpbml0aWFsaXplZDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5pdGlhbGl6ZCBieS1kYXRhLlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBieV9kYXRhOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGV4cGFuZGVkIHllYXJkYXlzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZGF5czogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbmRleCBpbiB0aGUge0BsaW5rIElDQUwuUmVjdXJJdGVyYXRvciNkYXlzfSBhcnJheS5cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZGF5c19pbmRleDogMCxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGhlIHJlY3VycmVuY2UgaXRlcmF0b3IgZnJvbSB0aGUgcGFzc2VkIGRhdGEgb2JqZWN0LiBUaGlzXG4gICAgICogbWV0aG9kIGlzIHVzdWFsbHkgbm90IGNhbGxlZCBkaXJlY3RseSwgeW91IGNhbiBpbml0aWFsaXplIHRoZSBpdGVyYXRvclxuICAgICAqIHRocm91Z2ggdGhlIGNvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgICAgICAgICAgICAgICAgVGhlIGl0ZXJhdG9yIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0lDQUwuUmVjdXJ9IG9wdGlvbnMucnVsZSAgICAgICBUaGUgcnVsZSB0byBpdGVyYXRlLlxuICAgICAqIEBwYXJhbSB7SUNBTC5UaW1lfSBvcHRpb25zLmR0c3RhcnQgICAgIFRoZSBzdGFydCBkYXRlIG9mIHRoZSBldmVudC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW49fSBvcHRpb25zLmluaXRpYWxpemVkICBXaGVuIHRydWUsIGFzc3VtZSB0aGF0IG9wdGlvbnMgYXJlXG4gICAgICogICAgICAgIGZyb20gYSBwcmV2aW91c2x5IGNvbnN0cnVjdGVkIGl0ZXJhdG9yLiBJbml0aWFsaXphdGlvbiB3aWxsIG5vdCBiZVxuICAgICAqICAgICAgICByZXBlYXRlZC5cbiAgICAgKi9cbiAgICBmcm9tRGF0YTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdGhpcy5ydWxlID0gSUNBTC5oZWxwZXJzLmZvcm1hdENsYXNzVHlwZShvcHRpb25zLnJ1bGUsIElDQUwuUmVjdXIpO1xuXG4gICAgICBpZiAoIXRoaXMucnVsZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2l0ZXJhdG9yIHJlcXVpcmVzIGEgKElDQUwuUmVjdXIpIHJ1bGUnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kdHN0YXJ0ID0gSUNBTC5oZWxwZXJzLmZvcm1hdENsYXNzVHlwZShvcHRpb25zLmR0c3RhcnQsIElDQUwuVGltZSk7XG5cbiAgICAgIGlmICghdGhpcy5kdHN0YXJ0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaXRlcmF0b3IgcmVxdWlyZXMgYSAoSUNBTC5UaW1lKSBkdHN0YXJ0Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmJ5X2RhdGEpIHtcbiAgICAgICAgdGhpcy5ieV9kYXRhID0gb3B0aW9ucy5ieV9kYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ieV9kYXRhID0gSUNBTC5oZWxwZXJzLmNsb25lKHRoaXMucnVsZS5wYXJ0cywgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLm9jY3VycmVuY2VfbnVtYmVyKVxuICAgICAgICB0aGlzLm9jY3VycmVuY2VfbnVtYmVyID0gb3B0aW9ucy5vY2N1cnJlbmNlX251bWJlcjtcblxuICAgICAgdGhpcy5kYXlzID0gb3B0aW9ucy5kYXlzIHx8IFtdO1xuICAgICAgaWYgKG9wdGlvbnMubGFzdCkge1xuICAgICAgICB0aGlzLmxhc3QgPSBJQ0FMLmhlbHBlcnMuZm9ybWF0Q2xhc3NUeXBlKG9wdGlvbnMubGFzdCwgSUNBTC5UaW1lKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ieV9pbmRpY2VzID0gb3B0aW9ucy5ieV9pbmRpY2VzO1xuXG4gICAgICBpZiAoIXRoaXMuYnlfaW5kaWNlcykge1xuICAgICAgICB0aGlzLmJ5X2luZGljZXMgPSB7XG4gICAgICAgICAgXCJCWVNFQ09ORFwiOiAwLFxuICAgICAgICAgIFwiQllNSU5VVEVcIjogMCxcbiAgICAgICAgICBcIkJZSE9VUlwiOiAwLFxuICAgICAgICAgIFwiQllEQVlcIjogMCxcbiAgICAgICAgICBcIkJZTU9OVEhcIjogMCxcbiAgICAgICAgICBcIkJZV0VFS05PXCI6IDAsXG4gICAgICAgICAgXCJCWU1PTlRIREFZXCI6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pbml0aWFsaXplZCA9IG9wdGlvbnMuaW5pdGlhbGl6ZWQgfHwgZmFsc2U7XG5cbiAgICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW50aWFsaXplIHRoZSBpdGVyYXRvclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24gaWNhbHJlY3VyX2l0ZXJhdG9yX2luaXQoKSB7XG4gICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIHRoaXMubGFzdCA9IHRoaXMuZHRzdGFydC5jbG9uZSgpO1xuICAgICAgdmFyIHBhcnRzID0gdGhpcy5ieV9kYXRhO1xuXG4gICAgICBpZiAoXCJCWURBWVwiIGluIHBhcnRzKSB7XG4gICAgICAgIC8vIGxpYmljYWwgZG9lcyB0aGlzIGVhcmxpZXIgd2hlbiB0aGUgcnVsZSBpcyBsb2FkZWQsIGJ1dCB3ZSBwb3N0cG9uZSB0b1xuICAgICAgICAvLyBub3cgc28gd2UgY2FuIHByZXNlcnZlIHRoZSBvcmlnaW5hbCBvcmRlci5cbiAgICAgICAgdGhpcy5zb3J0X2J5ZGF5X3J1bGVzKHBhcnRzLkJZREFZKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIEJZWUVBUkRBWSBhcHBhcmVzLCBubyBvdGhlciBkYXRlIHJ1bGUgcGFydCBtYXkgYXBwZWFyXG4gICAgICBpZiAoXCJCWVlFQVJEQVlcIiBpbiBwYXJ0cykge1xuICAgICAgICBpZiAoXCJCWU1PTlRIXCIgaW4gcGFydHMgfHwgXCJCWVdFRUtOT1wiIGluIHBhcnRzIHx8XG4gICAgICAgICAgICBcIkJZTU9OVEhEQVlcIiBpbiBwYXJ0cyB8fCBcIkJZREFZXCIgaW4gcGFydHMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIEJZWUVBUkRBWSBydWxlXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEJZV0VFS05PIGFuZCBCWU1PTlRIREFZIHJ1bGUgcGFydHMgbWF5IG5vdCBib3RoIGFwcGVhclxuICAgICAgaWYgKFwiQllXRUVLTk9cIiBpbiBwYXJ0cyAmJiBcIkJZTU9OVEhEQVlcIiBpbiBwYXJ0cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCWVdFRUtOTyBkb2VzIG5vdCBmaXQgdG8gQllNT05USERBWVwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gRm9yIE1PTlRITFkgcmVjdXJyZW5jZXMgKEZSRVE9TU9OVEhMWSkgbmVpdGhlciBCWVlFQVJEQVkgbm9yXG4gICAgICAvLyBCWVdFRUtOTyBtYXkgYXBwZWFyLlxuICAgICAgaWYgKHRoaXMucnVsZS5mcmVxID09IFwiTU9OVEhMWVwiICYmXG4gICAgICAgICAgKFwiQllZRUFSREFZXCIgaW4gcGFydHMgfHwgXCJCWVdFRUtOT1wiIGluIHBhcnRzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGb3IgTU9OVEhMWSByZWN1cnJlbmNlcyBuZWl0aGVyIEJZWUVBUkRBWSBub3IgQllXRUVLTk8gbWF5IGFwcGVhclwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gRm9yIFdFRUtMWSByZWN1cnJlbmNlcyAoRlJFUT1XRUVLTFkpIG5laXRoZXIgQllNT05USERBWSBub3JcbiAgICAgIC8vIEJZWUVBUkRBWSBtYXkgYXBwZWFyLlxuICAgICAgaWYgKHRoaXMucnVsZS5mcmVxID09IFwiV0VFS0xZXCIgJiZcbiAgICAgICAgICAoXCJCWVlFQVJEQVlcIiBpbiBwYXJ0cyB8fCBcIkJZTU9OVEhEQVlcIiBpbiBwYXJ0cykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRm9yIFdFRUtMWSByZWN1cnJlbmNlcyBuZWl0aGVyIEJZTU9OVEhEQVkgbm9yIEJZWUVBUkRBWSBtYXkgYXBwZWFyXCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBCWVlFQVJEQVkgbWF5IG9ubHkgYXBwZWFyIGluIFlFQVJMWSBydWxlc1xuICAgICAgaWYgKHRoaXMucnVsZS5mcmVxICE9IFwiWUVBUkxZXCIgJiYgXCJCWVlFQVJEQVlcIiBpbiBwYXJ0cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCWVlFQVJEQVkgbWF5IG9ubHkgYXBwZWFyIGluIFlFQVJMWSBydWxlc1wiKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sYXN0LnNlY29uZCA9IHRoaXMuc2V0dXBfZGVmYXVsdHMoXCJCWVNFQ09ORFwiLCBcIlNFQ09ORExZXCIsIHRoaXMuZHRzdGFydC5zZWNvbmQpO1xuICAgICAgdGhpcy5sYXN0Lm1pbnV0ZSA9IHRoaXMuc2V0dXBfZGVmYXVsdHMoXCJCWU1JTlVURVwiLCBcIk1JTlVURUxZXCIsIHRoaXMuZHRzdGFydC5taW51dGUpO1xuICAgICAgdGhpcy5sYXN0LmhvdXIgPSB0aGlzLnNldHVwX2RlZmF1bHRzKFwiQllIT1VSXCIsIFwiSE9VUkxZXCIsIHRoaXMuZHRzdGFydC5ob3VyKTtcbiAgICAgIHRoaXMubGFzdC5kYXkgPSB0aGlzLnNldHVwX2RlZmF1bHRzKFwiQllNT05USERBWVwiLCBcIkRBSUxZXCIsIHRoaXMuZHRzdGFydC5kYXkpO1xuICAgICAgdGhpcy5sYXN0Lm1vbnRoID0gdGhpcy5zZXR1cF9kZWZhdWx0cyhcIkJZTU9OVEhcIiwgXCJNT05USExZXCIsIHRoaXMuZHRzdGFydC5tb250aCk7XG5cbiAgICAgIGlmICh0aGlzLnJ1bGUuZnJlcSA9PSBcIldFRUtMWVwiKSB7XG4gICAgICAgIGlmIChcIkJZREFZXCIgaW4gcGFydHMpIHtcbiAgICAgICAgICB2YXIgYnlkYXlQYXJ0cyA9IHRoaXMucnVsZURheU9mV2VlayhwYXJ0cy5CWURBWVswXSwgdGhpcy5ydWxlLndrc3QpO1xuICAgICAgICAgIHZhciBwb3MgPSBieWRheVBhcnRzWzBdO1xuICAgICAgICAgIHZhciBkb3cgPSBieWRheVBhcnRzWzFdO1xuICAgICAgICAgIHZhciB3a2R5ID0gZG93IC0gdGhpcy5sYXN0LmRheU9mV2Vlayh0aGlzLnJ1bGUud2tzdCk7XG4gICAgICAgICAgaWYgKCh0aGlzLmxhc3QuZGF5T2ZXZWVrKHRoaXMucnVsZS53a3N0KSA8IGRvdyAmJiB3a2R5ID49IDApIHx8IHdrZHkgPCAwKSB7XG4gICAgICAgICAgICAvLyBJbml0aWFsIHRpbWUgaXMgYWZ0ZXIgZmlyc3QgZGF5IG9mIEJZREFZIGRhdGFcbiAgICAgICAgICAgIHRoaXMubGFzdC5kYXkgKz0gd2tkeTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGRheU5hbWUgPSBJQ0FMLlJlY3VyLm51bWVyaWNEYXlUb0ljYWxEYXkodGhpcy5kdHN0YXJ0LmRheU9mV2VlaygpKTtcbiAgICAgICAgICBwYXJ0cy5CWURBWSA9IFtkYXlOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5ydWxlLmZyZXEgPT0gXCJZRUFSTFlcIikge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgdGhpcy5leHBhbmRfeWVhcl9kYXlzKHRoaXMubGFzdC55ZWFyKTtcbiAgICAgICAgICBpZiAodGhpcy5kYXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmluY3JlbWVudF95ZWFyKHRoaXMucnVsZS5pbnRlcnZhbCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9uZXh0QnlZZWFyRGF5KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnJ1bGUuZnJlcSA9PSBcIk1PTlRITFlcIiAmJiB0aGlzLmhhc19ieV9kYXRhKFwiQllEQVlcIikpIHtcbiAgICAgICAgdmFyIHRlbXBMYXN0ID0gbnVsbDtcbiAgICAgICAgdmFyIGluaXRMYXN0ID0gdGhpcy5sYXN0LmNsb25lKCk7XG4gICAgICAgIHZhciBkYXlzSW5Nb250aCA9IElDQUwuVGltZS5kYXlzSW5Nb250aCh0aGlzLmxhc3QubW9udGgsIHRoaXMubGFzdC55ZWFyKTtcblxuICAgICAgICAvLyBDaGVjayBldmVyeSB3ZWVrZGF5IGluIEJZREFZIHdpdGggcmVsYXRpdmUgZG93IGFuZCBwb3MuXG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5ieV9kYXRhLkJZREFZKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKCF0aGlzLmJ5X2RhdGEuQllEQVkuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmxhc3QgPSBpbml0TGFzdC5jbG9uZSgpO1xuICAgICAgICAgIHZhciBieWRheVBhcnRzID0gdGhpcy5ydWxlRGF5T2ZXZWVrKHRoaXMuYnlfZGF0YS5CWURBWVtpXSk7XG4gICAgICAgICAgdmFyIHBvcyA9IGJ5ZGF5UGFydHNbMF07XG4gICAgICAgICAgdmFyIGRvdyA9IGJ5ZGF5UGFydHNbMV07XG4gICAgICAgICAgdmFyIGRheU9mTW9udGggPSB0aGlzLmxhc3QubnRoV2Vla0RheShkb3csIHBvcyk7XG5cbiAgICAgICAgICAvLyBJZiB8cG9zfCA+PSA2LCB0aGUgYnlkYXkgaXMgaW52YWxpZCBmb3IgYSBtb250aGx5IHJ1bGUuXG4gICAgICAgICAgaWYgKHBvcyA+PSA2IHx8IHBvcyA8PSAtNikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWFsZm9ybWVkIHZhbHVlcyBpbiBCWURBWSBwYXJ0XCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIGEgQnlkYXkgd2l0aCBwb3M9Ky8tNSBpcyBub3QgaW4gdGhlIGN1cnJlbnQgbW9udGggaXRcbiAgICAgICAgICAvLyBtdXN0IGJlIHNlYXJjaGVkIGluIHRoZSBuZXh0IG1vbnRocy5cbiAgICAgICAgICBpZiAoZGF5T2ZNb250aCA+IGRheXNJbk1vbnRoIHx8IGRheU9mTW9udGggPD0gMCkge1xuICAgICAgICAgICAgLy8gU2tpcCBpZiB3ZSBoYXZlIGFscmVhZHkgZm91bmQgYSBcImxhc3RcIiBpbiB0aGlzIG1vbnRoLlxuICAgICAgICAgICAgaWYgKHRlbXBMYXN0ICYmIHRlbXBMYXN0Lm1vbnRoID09IGluaXRMYXN0Lm1vbnRoKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGRheU9mTW9udGggPiBkYXlzSW5Nb250aCB8fCBkYXlPZk1vbnRoIDw9IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5pbmNyZW1lbnRfbW9udGgoKTtcbiAgICAgICAgICAgICAgZGF5c0luTW9udGggPSBJQ0FMLlRpbWUuZGF5c0luTW9udGgodGhpcy5sYXN0Lm1vbnRoLCB0aGlzLmxhc3QueWVhcik7XG4gICAgICAgICAgICAgIGRheU9mTW9udGggPSB0aGlzLmxhc3QubnRoV2Vla0RheShkb3csIHBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5sYXN0LmRheSA9IGRheU9mTW9udGg7XG4gICAgICAgICAgaWYgKCF0ZW1wTGFzdCB8fCB0aGlzLmxhc3QuY29tcGFyZSh0ZW1wTGFzdCkgPCAwKSB7XG4gICAgICAgICAgICB0ZW1wTGFzdCA9IHRoaXMubGFzdC5jbG9uZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3QgPSB0ZW1wTGFzdC5jbG9uZSgpO1xuXG4gICAgICAgIC8vWFhYOiBUaGlzIGZlZWxzIGxpa2UgYSBoYWNrLCBidXQgd2UgbmVlZCB0byBpbml0aWFsaXplXG4gICAgICAgIC8vICAgICB0aGUgQllNT05USERBWSBjYXNlIGNvcnJlY3RseSBhbmQgYnlEYXlBbmRNb250aERheSBoYW5kbGVzXG4gICAgICAgIC8vICAgICB0aGlzIGNhc2UuIEl0IGFjY2VwdHMgYSBzcGVjaWFsIGZsYWcgd2hpY2ggd2lsbCBhdm9pZCBpbmNyZW1lbnRpbmdcbiAgICAgICAgLy8gICAgIHRoZSBpbml0aWFsIHZhbHVlIHdpdGhvdXQgdGhlIGZsYWcgZGF5cyB0aGF0IG1hdGNoIHRoZSBzdGFydCB0aW1lXG4gICAgICAgIC8vICAgICB3b3VsZCBiZSBtaXNzZWQuXG4gICAgICAgIGlmICh0aGlzLmhhc19ieV9kYXRhKCdCWU1PTlRIREFZJykpIHtcbiAgICAgICAgICB0aGlzLl9ieURheUFuZE1vbnRoRGF5KHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubGFzdC5kYXkgPiBkYXlzSW5Nb250aCB8fCB0aGlzLmxhc3QuZGF5ID09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWxmb3JtZWQgdmFsdWVzIGluIEJZREFZIHBhcnRcIik7XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIGlmICh0aGlzLmhhc19ieV9kYXRhKFwiQllNT05USERBWVwiKSkge1xuICAgICAgICBpZiAodGhpcy5sYXN0LmRheSA8IDApIHtcbiAgICAgICAgICB2YXIgZGF5c0luTW9udGggPSBJQ0FMLlRpbWUuZGF5c0luTW9udGgodGhpcy5sYXN0Lm1vbnRoLCB0aGlzLmxhc3QueWVhcik7XG4gICAgICAgICAgdGhpcy5sYXN0LmRheSA9IGRheXNJbk1vbnRoICsgdGhpcy5sYXN0LmRheSArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgbmV4dCBvY2N1cnJlbmNlIGZyb20gdGhlIGl0ZXJhdG9yLlxuICAgICAqIEByZXR1cm4ge0lDQUwuVGltZX1cbiAgICAgKi9cbiAgICBuZXh0OiBmdW5jdGlvbiBpY2FscmVjdXJfaXRlcmF0b3JfbmV4dCgpIHtcbiAgICAgIHZhciBiZWZvcmUgPSAodGhpcy5sYXN0ID8gdGhpcy5sYXN0LmNsb25lKCkgOiBudWxsKTtcblxuICAgICAgaWYgKCh0aGlzLnJ1bGUuY291bnQgJiYgdGhpcy5vY2N1cnJlbmNlX251bWJlciA+PSB0aGlzLnJ1bGUuY291bnQpIHx8XG4gICAgICAgICAgKHRoaXMucnVsZS51bnRpbCAmJiB0aGlzLmxhc3QuY29tcGFyZSh0aGlzLnJ1bGUudW50aWwpID4gMCkpIHtcblxuICAgICAgICAvL1hYWDogcmlnaHQgbm93IHRoaXMgaXMganVzdCBhIGZsYWcgYW5kIGhhcyBubyBpbXBhY3RcbiAgICAgICAgLy8gICAgIHdlIGNhbiBzaW1wbGlmeSB0aGUgYWJvdmUgY2FzZSB0byBjaGVjayBmb3IgY29tcGxldGVkIGxhdGVyLlxuICAgICAgICB0aGlzLmNvbXBsZXRlZCA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9jY3VycmVuY2VfbnVtYmVyID09IDAgJiYgdGhpcy5sYXN0LmNvbXBhcmUodGhpcy5kdHN0YXJ0KSA+PSAwKSB7XG4gICAgICAgIC8vIEZpcnN0IG9mIGFsbCwgZ2l2ZSB0aGUgaW5zdGFuY2UgdGhhdCB3YXMgaW5pdGlhbGl6ZWRcbiAgICAgICAgdGhpcy5vY2N1cnJlbmNlX251bWJlcisrO1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0O1xuICAgICAgfVxuXG5cbiAgICAgIHZhciB2YWxpZDtcbiAgICAgIGRvIHtcbiAgICAgICAgdmFsaWQgPSAxO1xuXG4gICAgICAgIHN3aXRjaCAodGhpcy5ydWxlLmZyZXEpIHtcbiAgICAgICAgY2FzZSBcIlNFQ09ORExZXCI6XG4gICAgICAgICAgdGhpcy5uZXh0X3NlY29uZCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTUlOVVRFTFlcIjpcbiAgICAgICAgICB0aGlzLm5leHRfbWludXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJIT1VSTFlcIjpcbiAgICAgICAgICB0aGlzLm5leHRfaG91cigpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiREFJTFlcIjpcbiAgICAgICAgICB0aGlzLm5leHRfZGF5KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJXRUVLTFlcIjpcbiAgICAgICAgICB0aGlzLm5leHRfd2VlaygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTU9OVEhMWVwiOlxuICAgICAgICAgIHZhbGlkID0gdGhpcy5uZXh0X21vbnRoKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJZRUFSTFlcIjpcbiAgICAgICAgICB0aGlzLm5leHRfeWVhcigpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKCF0aGlzLmNoZWNrX2NvbnRyYWN0aW5nX3J1bGVzKCkgfHxcbiAgICAgICAgICAgICAgIHRoaXMubGFzdC5jb21wYXJlKHRoaXMuZHRzdGFydCkgPCAwIHx8XG4gICAgICAgICAgICAgICAhdmFsaWQpO1xuXG4gICAgICAvLyBUT0RPIGlzIHRoaXMgdmFsaWQ/XG4gICAgICBpZiAodGhpcy5sYXN0LmNvbXBhcmUoYmVmb3JlKSA9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNhbWUgb2NjdXJyZW5jZSBmb3VuZCB0d2ljZSwgcHJvdGVjdGluZyBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBcInlvdSBmcm9tIGRlYXRoIGJ5IHJlY3Vyc2lvblwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucnVsZS51bnRpbCAmJiB0aGlzLmxhc3QuY29tcGFyZSh0aGlzLnJ1bGUudW50aWwpID4gMCkge1xuICAgICAgICB0aGlzLmNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vY2N1cnJlbmNlX251bWJlcisrO1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBuZXh0X3NlY29uZDogZnVuY3Rpb24gbmV4dF9zZWNvbmQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5uZXh0X2dlbmVyaWMoXCJCWVNFQ09ORFwiLCBcIlNFQ09ORExZXCIsIFwic2Vjb25kXCIsIFwibWludXRlXCIpO1xuICAgIH0sXG5cbiAgICBpbmNyZW1lbnRfc2Vjb25kOiBmdW5jdGlvbiBpbmNyZW1lbnRfc2Vjb25kKGluYykge1xuICAgICAgcmV0dXJuIHRoaXMuaW5jcmVtZW50X2dlbmVyaWMoaW5jLCBcInNlY29uZFwiLCA2MCwgXCJtaW51dGVcIik7XG4gICAgfSxcblxuICAgIG5leHRfbWludXRlOiBmdW5jdGlvbiBuZXh0X21pbnV0ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLm5leHRfZ2VuZXJpYyhcIkJZTUlOVVRFXCIsIFwiTUlOVVRFTFlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1pbnV0ZVwiLCBcImhvdXJcIiwgXCJuZXh0X3NlY29uZFwiKTtcbiAgICB9LFxuXG4gICAgaW5jcmVtZW50X21pbnV0ZTogZnVuY3Rpb24gaW5jcmVtZW50X21pbnV0ZShpbmMpIHtcbiAgICAgIHJldHVybiB0aGlzLmluY3JlbWVudF9nZW5lcmljKGluYywgXCJtaW51dGVcIiwgNjAsIFwiaG91clwiKTtcbiAgICB9LFxuXG4gICAgbmV4dF9ob3VyOiBmdW5jdGlvbiBuZXh0X2hvdXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5uZXh0X2dlbmVyaWMoXCJCWUhPVVJcIiwgXCJIT1VSTFlcIiwgXCJob3VyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtb250aGRheVwiLCBcIm5leHRfbWludXRlXCIpO1xuICAgIH0sXG5cbiAgICBpbmNyZW1lbnRfaG91cjogZnVuY3Rpb24gaW5jcmVtZW50X2hvdXIoaW5jKSB7XG4gICAgICB0aGlzLmluY3JlbWVudF9nZW5lcmljKGluYywgXCJob3VyXCIsIDI0LCBcIm1vbnRoZGF5XCIpO1xuICAgIH0sXG5cbiAgICBuZXh0X2RheTogZnVuY3Rpb24gbmV4dF9kYXkoKSB7XG4gICAgICB2YXIgaGFzX2J5X2RheSA9IChcIkJZREFZXCIgaW4gdGhpcy5ieV9kYXRhKTtcbiAgICAgIHZhciB0aGlzX2ZyZXEgPSAodGhpcy5ydWxlLmZyZXEgPT0gXCJEQUlMWVwiKTtcblxuICAgICAgaWYgKHRoaXMubmV4dF9ob3VyKCkgPT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXNfZnJlcSkge1xuICAgICAgICB0aGlzLmluY3JlbWVudF9tb250aGRheSh0aGlzLnJ1bGUuaW50ZXJ2YWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pbmNyZW1lbnRfbW9udGhkYXkoMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG5cbiAgICBuZXh0X3dlZWs6IGZ1bmN0aW9uIG5leHRfd2VlaygpIHtcbiAgICAgIHZhciBlbmRfb2ZfZGF0YSA9IDA7XG5cbiAgICAgIGlmICh0aGlzLm5leHRfd2Vla2RheV9ieV93ZWVrKCkgPT0gMCkge1xuICAgICAgICByZXR1cm4gZW5kX29mX2RhdGE7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmhhc19ieV9kYXRhKFwiQllXRUVLTk9cIikpIHtcbiAgICAgICAgdmFyIGlkeCA9ICsrdGhpcy5ieV9pbmRpY2VzLkJZV0VFS05PO1xuXG4gICAgICAgIGlmICh0aGlzLmJ5X2luZGljZXMuQllXRUVLTk8gPT0gdGhpcy5ieV9kYXRhLkJZV0VFS05PLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuYnlfaW5kaWNlcy5CWVdFRUtOTyA9IDA7XG4gICAgICAgICAgZW5kX29mX2RhdGEgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSEFDSyBzaG91bGQgYmUgZmlyc3QgbW9udGggb2YgdGhlIHllYXJcbiAgICAgICAgdGhpcy5sYXN0Lm1vbnRoID0gMTtcbiAgICAgICAgdGhpcy5sYXN0LmRheSA9IDE7XG5cbiAgICAgICAgdmFyIHdlZWtfbm8gPSB0aGlzLmJ5X2RhdGEuQllXRUVLTk9bdGhpcy5ieV9pbmRpY2VzLkJZV0VFS05PXTtcblxuICAgICAgICB0aGlzLmxhc3QuZGF5ICs9IDcgKiB3ZWVrX25vO1xuXG4gICAgICAgIGlmIChlbmRfb2ZfZGF0YSkge1xuICAgICAgICAgIHRoaXMuaW5jcmVtZW50X3llYXIoMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEp1bXAgdG8gdGhlIG5leHQgd2Vla1xuICAgICAgICB0aGlzLmluY3JlbWVudF9tb250aGRheSg3ICogdGhpcy5ydWxlLmludGVydmFsKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVuZF9vZl9kYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemUgZWFjaCBieSBkYXkgcnVsZSBmb3IgYSBnaXZlbiB5ZWFyL21vbnRoLlxuICAgICAqIFRha2VzIGludG8gYWNjb3VudCBvcmRlcmluZyBhbmQgbmVnYXRpdmUgcnVsZXNcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHllYXIgICAgICAgICBDdXJyZW50IHllYXIuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1vbnRoICAgICAgICBDdXJyZW50IG1vbnRoLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9ICBydWxlcyAgICAgICAgQXJyYXkgb2YgcnVsZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gc29ydGVkIGFuZCBub3JtYWxpemVkIHJ1bGVzLlxuICAgICAqICAgICAgICAgICAgICAgICBOZWdhdGl2ZSBydWxlcyB3aWxsIGJlIGV4cGFuZGVkIHRvIHRoZWlyXG4gICAgICogICAgICAgICAgICAgICAgIGNvcnJlY3QgcG9zaXRpdmUgdmFsdWVzIGZvciBlYXNpZXIgcHJvY2Vzc2luZy5cbiAgICAgKi9cbiAgICBub3JtYWxpemVCeU1vbnRoRGF5UnVsZXM6IGZ1bmN0aW9uKHllYXIsIG1vbnRoLCBydWxlcykge1xuICAgICAgdmFyIGRheXNJbk1vbnRoID0gSUNBTC5UaW1lLmRheXNJbk1vbnRoKG1vbnRoLCB5ZWFyKTtcblxuICAgICAgLy8gWFhYOiBUaGlzIGlzIHByb2JhYmx5IGJhZCBmb3IgcGVyZm9ybWFuY2UgdG8gYWxsb2NhdGVcbiAgICAgIC8vICAgICAgYSBuZXcgYXJyYXkgZm9yIGVhY2ggbW9udGggd2Ugc2NhbiwgaWYgcG9zc2libGVcbiAgICAgIC8vICAgICAgd2Ugc2hvdWxkIHRyeSB0byBvcHRpbWl6ZSB0aGlzLi4uXG4gICAgICB2YXIgbmV3UnVsZXMgPSBbXTtcblxuICAgICAgdmFyIHJ1bGVJZHggPSAwO1xuICAgICAgdmFyIGxlbiA9IHJ1bGVzLmxlbmd0aDtcbiAgICAgIHZhciBydWxlO1xuXG4gICAgICBmb3IgKDsgcnVsZUlkeCA8IGxlbjsgcnVsZUlkeCsrKSB7XG4gICAgICAgIHJ1bGUgPSBydWxlc1tydWxlSWR4XTtcblxuICAgICAgICAvLyBpZiB0aGlzIHJ1bGUgZmFsbHMgb3V0c2lkZSBvZiBnaXZlblxuICAgICAgICAvLyBtb250aCBkaXNjYXJkIGl0LlxuICAgICAgICBpZiAoTWF0aC5hYnMocnVsZSkgPiBkYXlzSW5Nb250aCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbmVnYXRpdmUgY2FzZVxuICAgICAgICBpZiAocnVsZSA8IDApIHtcbiAgICAgICAgICAvLyB3ZSBhZGQgKG5vdCBzdWJ0cmFjdCBpdCBpcyBhIG5lZ2F0aXZlIG51bWJlcilcbiAgICAgICAgICAvLyBvbmUgZnJvbSB0aGUgcnVsZSBiZWNhdXNlIDEgPT09IGxhc3QgZGF5IG9mIG1vbnRoXG4gICAgICAgICAgcnVsZSA9IGRheXNJbk1vbnRoICsgKHJ1bGUgKyAxKTtcbiAgICAgICAgfSBlbHNlIGlmIChydWxlID09PSAwKSB7XG4gICAgICAgICAgLy8gc2tpcCB6ZXJvOiBpdCBpcyBpbnZhbGlkLlxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb25seSBhZGQgdW5pcXVlIGl0ZW1zLi4uXG4gICAgICAgIGlmIChuZXdSdWxlcy5pbmRleE9mKHJ1bGUpID09PSAtMSkge1xuICAgICAgICAgIG5ld1J1bGVzLnB1c2gocnVsZSk7XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICAvLyB1bmlxdWUgYW5kIHNvcnRcbiAgICAgIHJldHVybiBuZXdSdWxlcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEgLSBiOyB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTk9URVM6XG4gICAgICogV2UgYXJlIGdpdmVuIGEgbGlzdCBvZiBkYXRlcyBpbiB0aGUgbW9udGggKEJZTU9OVEhEQVkpICgyMywgZXRjLi4pXG4gICAgICogQWxzbyB3ZSBhcmUgZ2l2ZW4gYSBsaXN0IG9mIGRheXMgKEJZREFZKSAoTU8sIDJTVSwgZXRjLi4pIHdoZW5cbiAgICAgKiBib3RoIGNvbmRpdGlvbnMgbWF0Y2ggYSBnaXZlbiBkYXRlICh0aGlzLmxhc3QuZGF5KSBpdGVyYXRpb24gc3RvcHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbj19IGlzSW5pdCAgICAgV2hlbiBnaXZlbiB0cnVlIHdpbGwgbm90IGluY3JlbWVudCB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCBkYXkgKHRoaXMubGFzdCkuXG4gICAgICovXG4gICAgX2J5RGF5QW5kTW9udGhEYXk6IGZ1bmN0aW9uKGlzSW5pdCkge1xuICAgICAgdmFyIGJ5TW9udGhEYXk7IC8vIHNldHVwIGluIGluaXRNb250aFxuICAgICAgdmFyIGJ5RGF5ID0gdGhpcy5ieV9kYXRhLkJZREFZO1xuXG4gICAgICB2YXIgZGF0ZTtcbiAgICAgIHZhciBkYXRlSWR4ID0gMDtcbiAgICAgIHZhciBkYXRlTGVuOyAvLyBzZXR1cCBpbiBpbml0TW9udGhcbiAgICAgIHZhciBkYXlMZW4gPSBieURheS5sZW5ndGg7XG5cbiAgICAgIC8vIHdlIGFyZSBub3QgdmFsaWQgYnkgZGVmYXVsdFxuICAgICAgdmFyIGRhdGFJc1ZhbGlkID0gMDtcblxuICAgICAgdmFyIGRheXNJbk1vbnRoO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgLy8gd2UgbmVlZCBhIGNvcHkgb2YgdGhpcywgYmVjYXVzZSBhIERhdGVUaW1lIGdldHMgbm9ybWFsaXplZFxuICAgICAgLy8gYXV0b21hdGljYWxseSBpZiB0aGUgZGF5IGlzIG91dCBvZiByYW5nZS4gQXQgc29tZSBwb2ludHMgd2VcbiAgICAgIC8vIHNldCB0aGUgbGFzdCBkYXkgdG8gMCB0byBzdGFydCBjb3VudGluZy5cbiAgICAgIHZhciBsYXN0RGF5ID0gdGhpcy5sYXN0LmRheTtcblxuICAgICAgZnVuY3Rpb24gaW5pdE1vbnRoKCkge1xuICAgICAgICBkYXlzSW5Nb250aCA9IElDQUwuVGltZS5kYXlzSW5Nb250aChcbiAgICAgICAgICBzZWxmLmxhc3QubW9udGgsIHNlbGYubGFzdC55ZWFyXG4gICAgICAgICk7XG5cbiAgICAgICAgYnlNb250aERheSA9IHNlbGYubm9ybWFsaXplQnlNb250aERheVJ1bGVzKFxuICAgICAgICAgIHNlbGYubGFzdC55ZWFyLFxuICAgICAgICAgIHNlbGYubGFzdC5tb250aCxcbiAgICAgICAgICBzZWxmLmJ5X2RhdGEuQllNT05USERBWVxuICAgICAgICApO1xuXG4gICAgICAgIGRhdGVMZW4gPSBieU1vbnRoRGF5Lmxlbmd0aDtcblxuICAgICAgICAvLyBGb3IgdGhlIGNhc2Ugb2YgbW9yZSB0aGFuIG9uZSBvY2N1cnJlbmNlIGluIG9uZSBtb250aFxuICAgICAgICAvLyB3ZSBoYXZlIHRvIGJlIHN1cmUgdG8gc3RhcnQgc2VhcmNoaW5nIGFmdGVyIHRoZSBsYXN0XG4gICAgICAgIC8vIGZvdW5kIGRhdGUgb3IgYXQgdGhlIGxhc3QgQllNT05USERBWSwgdW5sZXNzIHdlIGFyZVxuICAgICAgICAvLyBpbml0aWFsaXppbmcgdGhlIGl0ZXJhdG9yIGJlY2F1c2UgaW4gdGhpcyBjYXNlIHdlIGhhdmVcbiAgICAgICAgLy8gdG8gY29uc2lkZXIgdGhlIGxhc3QgZm91bmQgZGF0ZSB0b28uXG4gICAgICAgIHdoaWxlIChieU1vbnRoRGF5W2RhdGVJZHhdIDw9IGxhc3REYXkgJiZcbiAgICAgICAgICAgICAgICEoaXNJbml0ICYmIGJ5TW9udGhEYXlbZGF0ZUlkeF0gPT0gbGFzdERheSkgJiZcbiAgICAgICAgICAgICAgIGRhdGVJZHggPCBkYXRlTGVuIC0gMSkge1xuICAgICAgICAgIGRhdGVJZHgrKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBuZXh0TW9udGgoKSB7XG4gICAgICAgIC8vIHNpbmNlIHRoZSBkYXkgaXMgaW5jcmVtZW50ZWQgYXQgdGhlIHN0YXJ0XG4gICAgICAgIC8vIG9mIHRoZSBsb29wIGJlbG93LCB3ZSBuZWVkIHRvIHN0YXJ0IGF0IDBcbiAgICAgICAgbGFzdERheSA9IDA7XG4gICAgICAgIHNlbGYuaW5jcmVtZW50X21vbnRoKCk7XG4gICAgICAgIGRhdGVJZHggPSAwO1xuICAgICAgICBpbml0TW9udGgoKTtcbiAgICAgIH1cblxuICAgICAgaW5pdE1vbnRoKCk7XG5cbiAgICAgIC8vIHNob3VsZCBjb21lIGFmdGVyIGluaXRNb250aFxuICAgICAgaWYgKGlzSW5pdCkge1xuICAgICAgICBsYXN0RGF5IC09IDE7XG4gICAgICB9XG5cbiAgICAgIC8vIFVzZSBhIGNvdW50ZXIgdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcCB3aXRoIG1hbGZvcm1lZCBydWxlcy5cbiAgICAgIC8vIFN0b3AgY2hlY2tpbmcgYWZ0ZXIgNCB5ZWFycyBzbyB3ZSBjb25zaWRlciBhbHNvIGEgbGVhcCB5ZWFyLlxuICAgICAgdmFyIG1vbnRoc0NvdW50ZXIgPSA0ODtcblxuICAgICAgd2hpbGUgKCFkYXRhSXNWYWxpZCAmJiBtb250aHNDb3VudGVyKSB7XG4gICAgICAgIG1vbnRoc0NvdW50ZXItLTtcbiAgICAgICAgLy8gaW5jcmVtZW50IHRoZSBjdXJyZW50IGRhdGUuIFRoaXMgaXMgcmVhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCBvdGhlcndpc2Ugd2UgbWF5IGZhbGwgaW50byB0aGUgaW5maW5pdGVcbiAgICAgICAgLy8gbG9vcCB0cmFwLiBUaGUgaW5pdGlhbCBkYXRlIHRha2VzIGNhcmUgb2YgdGhlIGNhc2VcbiAgICAgICAgLy8gd2hlcmUgdGhlIGN1cnJlbnQgZGF0ZSBpcyB0aGUgZGF0ZSB3ZSBhcmUgbG9va2luZ1xuICAgICAgICAvLyBmb3IuXG4gICAgICAgIGRhdGUgPSBsYXN0RGF5ICsgMTtcblxuICAgICAgICBpZiAoZGF0ZSA+IGRheXNJbk1vbnRoKSB7XG4gICAgICAgICAgbmV4dE1vbnRoKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaW5kIG5leHQgZGF0ZVxuICAgICAgICB2YXIgbmV4dCA9IGJ5TW9udGhEYXlbZGF0ZUlkeCsrXTtcblxuICAgICAgICAvLyB0aGlzIGxvZ2ljIGlzIGRlcGVuZGFudCBvbiB0aGUgQllNT05USERBWVNcbiAgICAgICAgLy8gYmVpbmcgaW4gb3JkZXIgKHdoaWNoIGlzIGRvbmUgYnkgI25vcm1hbGl6ZUJ5TW9udGhEYXlSdWxlcylcbiAgICAgICAgaWYgKG5leHQgPj0gZGF0ZSkge1xuICAgICAgICAgIC8vIGlmIHRoZSBuZXh0IG1vbnRoIGRheSBpcyBpbiB0aGUgZnV0dXJlIGp1bXAgdG8gaXQuXG4gICAgICAgICAgbGFzdERheSA9IG5leHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaW4gdGhpcyBjYXNlIHRoZSAnbmV4dCcgbW9udGhkYXkgaGFzIHBhc3RcbiAgICAgICAgICAvLyB3ZSBtdXN0IG1vdmUgdG8gdGhlIG1vbnRoLlxuICAgICAgICAgIG5leHRNb250aCgpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm93IHdlIGNhbiBsb29wIHRocm91Z2ggdGhlIGRheSBydWxlcyB0byBzZWVcbiAgICAgICAgLy8gaWYgb25lIG1hdGNoZXMgdGhlIGN1cnJlbnQgbW9udGggZGF0ZS5cbiAgICAgICAgZm9yICh2YXIgZGF5SWR4ID0gMDsgZGF5SWR4IDwgZGF5TGVuOyBkYXlJZHgrKykge1xuICAgICAgICAgIHZhciBwYXJ0cyA9IHRoaXMucnVsZURheU9mV2VlayhieURheVtkYXlJZHhdKTtcbiAgICAgICAgICB2YXIgcG9zID0gcGFydHNbMF07XG4gICAgICAgICAgdmFyIGRvdyA9IHBhcnRzWzFdO1xuXG4gICAgICAgICAgdGhpcy5sYXN0LmRheSA9IGxhc3REYXk7XG4gICAgICAgICAgaWYgKHRoaXMubGFzdC5pc050aFdlZWtEYXkoZG93LCBwb3MpKSB7XG4gICAgICAgICAgICAvLyB3aGVuIHdlIGZpbmQgdGhlIHZhbGlkIG9uZSB3ZSBjYW4gbWFya1xuICAgICAgICAgICAgLy8gdGhlIGNvbmRpdGlvbnMgYXMgbWV0IGFuZCBicmVhayB0aGUgbG9vcC5cbiAgICAgICAgICAgIC8vIChCZWNhdXNlIHdlIGhhdmUgdGhpcyBjb25kaXRpb24gYWJvdmVcbiAgICAgICAgICAgIC8vICBpdCB3aWxsIGFsc28gYnJlYWsgdGhlIHBhcmVudCBsb29wKS5cbiAgICAgICAgICAgIGRhdGFJc1ZhbGlkID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEl0IGlzIGNvbXBsZXRlbHkgcG9zc2libGUgdGhhdCB0aGUgY29tYmluYXRpb25cbiAgICAgICAgLy8gY2Fubm90IGJlIG1hdGNoZWQgaW4gdGhlIGN1cnJlbnQgbW9udGguXG4gICAgICAgIC8vIFdoZW4gd2UgcmVhY2ggdGhlIGVuZCBvZiBwb3NzaWJsZSBjb21iaW5hdGlvbnNcbiAgICAgICAgLy8gaW4gdGhlIGN1cnJlbnQgbW9udGggd2UgaXRlcmF0ZSB0byB0aGUgbmV4dCBvbmUuXG4gICAgICAgIC8vIHNpbmNlIGRhdGVJZHggaXMgaW5jcmVtZW50ZWQgcmlnaHQgYWZ0ZXIgZ2V0dGluZ1xuICAgICAgICAvLyBcIm5leHRcIiwgd2UgZG9uJ3QgbmVlZCBkYXRlTGVuIC0xIGhlcmUuXG4gICAgICAgIGlmICghZGF0YUlzVmFsaWQgJiYgZGF0ZUlkeCA9PT0gZGF0ZUxlbikge1xuICAgICAgICAgIG5leHRNb250aCgpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtb250aHNDb3VudGVyIDw9IDApIHtcbiAgICAgICAgLy8gQ2hlY2tlZCA0IHllYXJzIHdpdGhvdXQgZmluZGluZyBhIEJ5ZGF5IHRoYXQgbWF0Y2hlc1xuICAgICAgICAvLyBhIEJ5bW9udGhkYXkuIE1heWJlIHRoZSBydWxlIGlzIG5vdCBjb3JyZWN0LlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWxmb3JtZWQgdmFsdWVzIGluIEJZREFZIGNvbWJpbmVkIHdpdGggQllNT05USERBWSBwYXJ0c1wiKTtcbiAgICAgIH1cblxuXG4gICAgICByZXR1cm4gZGF0YUlzVmFsaWQ7XG4gICAgfSxcblxuICAgIG5leHRfbW9udGg6IGZ1bmN0aW9uIG5leHRfbW9udGgoKSB7XG4gICAgICB2YXIgdGhpc19mcmVxID0gKHRoaXMucnVsZS5mcmVxID09IFwiTU9OVEhMWVwiKTtcbiAgICAgIHZhciBkYXRhX3ZhbGlkID0gMTtcblxuICAgICAgaWYgKHRoaXMubmV4dF9ob3VyKCkgPT0gMCkge1xuICAgICAgICByZXR1cm4gZGF0YV92YWxpZDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaGFzX2J5X2RhdGEoXCJCWURBWVwiKSAmJiB0aGlzLmhhc19ieV9kYXRhKFwiQllNT05USERBWVwiKSkge1xuICAgICAgICBkYXRhX3ZhbGlkID0gdGhpcy5fYnlEYXlBbmRNb250aERheSgpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmhhc19ieV9kYXRhKFwiQllEQVlcIikpIHtcbiAgICAgICAgdmFyIGRheXNJbk1vbnRoID0gSUNBTC5UaW1lLmRheXNJbk1vbnRoKHRoaXMubGFzdC5tb250aCwgdGhpcy5sYXN0LnllYXIpO1xuICAgICAgICB2YXIgc2V0cG9zID0gMDtcbiAgICAgICAgdmFyIHNldHBvc190b3RhbCA9IDA7XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzX2J5X2RhdGEoXCJCWVNFVFBPU1wiKSkge1xuICAgICAgICAgIHZhciBsYXN0X2RheSA9IHRoaXMubGFzdC5kYXk7XG4gICAgICAgICAgZm9yICh2YXIgZGF5ID0gMTsgZGF5IDw9IGRheXNJbk1vbnRoOyBkYXkrKykge1xuICAgICAgICAgICAgdGhpcy5sYXN0LmRheSA9IGRheTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzX2RheV9pbl9ieWRheSh0aGlzLmxhc3QpKSB7XG4gICAgICAgICAgICAgIHNldHBvc190b3RhbCsrO1xuICAgICAgICAgICAgICBpZiAoZGF5IDw9IGxhc3RfZGF5KSB7XG4gICAgICAgICAgICAgICAgc2V0cG9zKys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5sYXN0LmRheSA9IGxhc3RfZGF5O1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YV92YWxpZCA9IDA7XG4gICAgICAgIGZvciAodmFyIGRheSA9IHRoaXMubGFzdC5kYXkgKyAxOyBkYXkgPD0gZGF5c0luTW9udGg7IGRheSsrKSB7XG4gICAgICAgICAgdGhpcy5sYXN0LmRheSA9IGRheTtcblxuICAgICAgICAgIGlmICh0aGlzLmlzX2RheV9pbl9ieWRheSh0aGlzLmxhc3QpKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzX2J5X2RhdGEoXCJCWVNFVFBPU1wiKSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tfc2V0X3Bvc2l0aW9uKCsrc2V0cG9zKSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tfc2V0X3Bvc2l0aW9uKHNldHBvcyAtIHNldHBvc190b3RhbCAtIDEpKSB7XG5cbiAgICAgICAgICAgICAgZGF0YV92YWxpZCA9IDE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXkgPiBkYXlzSW5Nb250aCkge1xuICAgICAgICAgIHRoaXMubGFzdC5kYXkgPSAxO1xuICAgICAgICAgIHRoaXMuaW5jcmVtZW50X21vbnRoKCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5pc19kYXlfaW5fYnlkYXkodGhpcy5sYXN0KSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmhhc19ieV9kYXRhKFwiQllTRVRQT1NcIikgfHwgdGhpcy5jaGVja19zZXRfcG9zaXRpb24oMSkpIHtcbiAgICAgICAgICAgICAgZGF0YV92YWxpZCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGFfdmFsaWQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLmhhc19ieV9kYXRhKFwiQllNT05USERBWVwiKSkge1xuICAgICAgICB0aGlzLmJ5X2luZGljZXMuQllNT05USERBWSsrO1xuXG4gICAgICAgIGlmICh0aGlzLmJ5X2luZGljZXMuQllNT05USERBWSA+PSB0aGlzLmJ5X2RhdGEuQllNT05USERBWS5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmJ5X2luZGljZXMuQllNT05USERBWSA9IDA7XG4gICAgICAgICAgdGhpcy5pbmNyZW1lbnRfbW9udGgoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkYXlzSW5Nb250aCA9IElDQUwuVGltZS5kYXlzSW5Nb250aCh0aGlzLmxhc3QubW9udGgsIHRoaXMubGFzdC55ZWFyKTtcbiAgICAgICAgdmFyIGRheSA9IHRoaXMuYnlfZGF0YS5CWU1PTlRIREFZW3RoaXMuYnlfaW5kaWNlcy5CWU1PTlRIREFZXTtcblxuICAgICAgICBpZiAoZGF5IDwgMCkge1xuICAgICAgICAgIGRheSA9IGRheXNJbk1vbnRoICsgZGF5ICsgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXkgPiBkYXlzSW5Nb250aCkge1xuICAgICAgICAgIHRoaXMubGFzdC5kYXkgPSAxO1xuICAgICAgICAgIGRhdGFfdmFsaWQgPSB0aGlzLmlzX2RheV9pbl9ieWRheSh0aGlzLmxhc3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubGFzdC5kYXkgPSBkYXk7XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pbmNyZW1lbnRfbW9udGgoKTtcbiAgICAgICAgdmFyIGRheXNJbk1vbnRoID0gSUNBTC5UaW1lLmRheXNJbk1vbnRoKHRoaXMubGFzdC5tb250aCwgdGhpcy5sYXN0LnllYXIpO1xuICAgICAgICBpZiAodGhpcy5ieV9kYXRhLkJZTU9OVEhEQVlbMF0gPiBkYXlzSW5Nb250aCkge1xuICAgICAgICAgIGRhdGFfdmFsaWQgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubGFzdC5kYXkgPSB0aGlzLmJ5X2RhdGEuQllNT05USERBWVswXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YV92YWxpZDtcbiAgICB9LFxuXG4gICAgbmV4dF93ZWVrZGF5X2J5X3dlZWs6IGZ1bmN0aW9uIG5leHRfd2Vla2RheV9ieV93ZWVrKCkge1xuICAgICAgdmFyIGVuZF9vZl9kYXRhID0gMDtcblxuICAgICAgaWYgKHRoaXMubmV4dF9ob3VyKCkgPT0gMCkge1xuICAgICAgICByZXR1cm4gZW5kX29mX2RhdGE7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5oYXNfYnlfZGF0YShcIkJZREFZXCIpKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgIHZhciB0dCA9IG5ldyBJQ0FMLlRpbWUoKTtcbiAgICAgICAgdGhpcy5ieV9pbmRpY2VzLkJZREFZKys7XG5cbiAgICAgICAgaWYgKHRoaXMuYnlfaW5kaWNlcy5CWURBWSA9PSBPYmplY3Qua2V5cyh0aGlzLmJ5X2RhdGEuQllEQVkpLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuYnlfaW5kaWNlcy5CWURBWSA9IDA7XG4gICAgICAgICAgZW5kX29mX2RhdGEgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvZGVkX2RheSA9IHRoaXMuYnlfZGF0YS5CWURBWVt0aGlzLmJ5X2luZGljZXMuQllEQVldO1xuICAgICAgICB2YXIgcGFydHMgPSB0aGlzLnJ1bGVEYXlPZldlZWsoY29kZWRfZGF5KTtcbiAgICAgICAgdmFyIGRvdyA9IHBhcnRzWzFdO1xuXG4gICAgICAgIGRvdyAtPSB0aGlzLnJ1bGUud2tzdDtcblxuICAgICAgICBpZiAoZG93IDwgMCkge1xuICAgICAgICAgIGRvdyArPSA3O1xuICAgICAgICB9XG5cbiAgICAgICAgdHQueWVhciA9IHRoaXMubGFzdC55ZWFyO1xuICAgICAgICB0dC5tb250aCA9IHRoaXMubGFzdC5tb250aDtcbiAgICAgICAgdHQuZGF5ID0gdGhpcy5sYXN0LmRheTtcblxuICAgICAgICB2YXIgc3RhcnRPZldlZWsgPSB0dC5zdGFydERveVdlZWsodGhpcy5ydWxlLndrc3QpO1xuXG4gICAgICAgIGlmIChkb3cgKyBzdGFydE9mV2VlayA8IDEpIHtcbiAgICAgICAgICAvLyBUaGUgc2VsZWN0ZWQgZGF0ZSBpcyBpbiB0aGUgcHJldmlvdXMgeWVhclxuICAgICAgICAgIGlmICghZW5kX29mX2RhdGEpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXh0ID0gSUNBTC5UaW1lLmZyb21EYXlPZlllYXIoc3RhcnRPZldlZWsgKyBkb3csXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdC55ZWFyKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG5vcm1hbGl6YXRpb24gaG9ycm9ycyBiZWxvdyBhcmUgZHVlIHRvXG4gICAgICAgICAqIHRoZSBmYWN0IHRoYXQgd2hlbiB0aGUgeWVhci9tb250aC9kYXkgY2hhbmdlc1xuICAgICAgICAgKiBpdCBjYW4gZWZmZWN0IHRoZSBvdGhlciBvcGVyYXRpb25zIHRoYXQgY29tZSBhZnRlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGFzdC55ZWFyID0gbmV4dC55ZWFyO1xuICAgICAgICB0aGlzLmxhc3QubW9udGggPSBuZXh0Lm1vbnRoO1xuICAgICAgICB0aGlzLmxhc3QuZGF5ID0gbmV4dC5kYXk7XG5cbiAgICAgICAgcmV0dXJuIGVuZF9vZl9kYXRhO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBuZXh0X3llYXI6IGZ1bmN0aW9uIG5leHRfeWVhcigpIHtcblxuICAgICAgaWYgKHRoaXMubmV4dF9ob3VyKCkgPT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKCsrdGhpcy5kYXlzX2luZGV4ID09IHRoaXMuZGF5cy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5kYXlzX2luZGV4ID0gMDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIHRoaXMuaW5jcmVtZW50X3llYXIodGhpcy5ydWxlLmludGVydmFsKTtcbiAgICAgICAgICB0aGlzLmV4cGFuZF95ZWFyX2RheXModGhpcy5sYXN0LnllYXIpO1xuICAgICAgICB9IHdoaWxlICh0aGlzLmRheXMubGVuZ3RoID09IDApO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9uZXh0QnlZZWFyRGF5KCk7XG5cbiAgICAgIHJldHVybiAxO1xuICAgIH0sXG5cbiAgICBfbmV4dEJ5WWVhckRheTogZnVuY3Rpb24gX25leHRCeVllYXJEYXkoKSB7XG4gICAgICAgIHZhciBkb3kgPSB0aGlzLmRheXNbdGhpcy5kYXlzX2luZGV4XTtcbiAgICAgICAgdmFyIHllYXIgPSB0aGlzLmxhc3QueWVhcjtcbiAgICAgICAgaWYgKGRveSA8IDEpIHtcbiAgICAgICAgICAgIC8vIFRpbWUuZnJvbURheU9mWWVhcihkb3ksIHllYXIpIGluZGV4ZXMgcmVsYXRpdmUgdG8gdGhlXG4gICAgICAgICAgICAvLyBzdGFydCBvZiB0aGUgZ2l2ZW4geWVhci4gVGhhdCBpcyBkaWZmZXJlbnQgZnJvbSB0aGVcbiAgICAgICAgICAgIC8vIHNlbWFudGljcyBvZiBCWVlFQVJEQVkgd2hlcmUgbmVnYXRpdmUgaW5kZXhlcyBhcmUgYW5cbiAgICAgICAgICAgIC8vIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgdGhlIGdpdmVuIHllYXIuXG4gICAgICAgICAgICBkb3kgKz0gMTtcbiAgICAgICAgICAgIHllYXIgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV4dCA9IElDQUwuVGltZS5mcm9tRGF5T2ZZZWFyKGRveSwgeWVhcik7XG4gICAgICAgIHRoaXMubGFzdC5kYXkgPSBuZXh0LmRheTtcbiAgICAgICAgdGhpcy5sYXN0Lm1vbnRoID0gbmV4dC5tb250aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGRvdyAoZWc6ICcxVFUnLCAnLTFNTycpXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWUud2Vla0RheT19IGFXZWVrU3RhcnQgVGhlIHdlZWsgc3RhcnQgd2Vla2RheVxuICAgICAqIEByZXR1cm4gW3BvcywgbnVtZXJpY0Rvd10gKGVnOiBbMSwgM10pIG51bWVyaWNEb3cgaXMgcmVsYXRpdmUgdG8gYVdlZWtTdGFydFxuICAgICAqL1xuICAgIHJ1bGVEYXlPZldlZWs6IGZ1bmN0aW9uIHJ1bGVEYXlPZldlZWsoZG93LCBhV2Vla1N0YXJ0KSB7XG4gICAgICB2YXIgbWF0Y2hlcyA9IGRvdy5tYXRjaCgvKFsrLV0/WzAtOV0pPyhNT3xUVXxXRXxUSHxGUnxTQXxTVSkvKTtcbiAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgIHZhciBwb3MgPSBwYXJzZUludChtYXRjaGVzWzFdIHx8IDAsIDEwKTtcbiAgICAgICAgZG93ID0gSUNBTC5SZWN1ci5pY2FsRGF5VG9OdW1lcmljRGF5KG1hdGNoZXNbMl0sIGFXZWVrU3RhcnQpO1xuICAgICAgICByZXR1cm4gW3BvcywgZG93XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbMCwgMF07XG4gICAgICB9XG4gICAgfSxcblxuICAgIG5leHRfZ2VuZXJpYzogZnVuY3Rpb24gbmV4dF9nZW5lcmljKGFSdWxlVHlwZSwgYUludGVydmFsLCBhRGF0ZUF0dHIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYUZvbGxvd2luZ0F0dHIsIGFQcmV2aW91c0luY3IpIHtcbiAgICAgIHZhciBoYXNfYnlfcnVsZSA9IChhUnVsZVR5cGUgaW4gdGhpcy5ieV9kYXRhKTtcbiAgICAgIHZhciB0aGlzX2ZyZXEgPSAodGhpcy5ydWxlLmZyZXEgPT0gYUludGVydmFsKTtcbiAgICAgIHZhciBlbmRfb2ZfZGF0YSA9IDA7XG5cbiAgICAgIGlmIChhUHJldmlvdXNJbmNyICYmIHRoaXNbYVByZXZpb3VzSW5jcl0oKSA9PSAwKSB7XG4gICAgICAgIHJldHVybiBlbmRfb2ZfZGF0YTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhc19ieV9ydWxlKSB7XG4gICAgICAgIHRoaXMuYnlfaW5kaWNlc1thUnVsZVR5cGVdKys7XG4gICAgICAgIHZhciBpZHggPSB0aGlzLmJ5X2luZGljZXNbYVJ1bGVUeXBlXTtcbiAgICAgICAgdmFyIGR0YSA9IHRoaXMuYnlfZGF0YVthUnVsZVR5cGVdO1xuXG4gICAgICAgIGlmICh0aGlzLmJ5X2luZGljZXNbYVJ1bGVUeXBlXSA9PSBkdGEubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5ieV9pbmRpY2VzW2FSdWxlVHlwZV0gPSAwO1xuICAgICAgICAgIGVuZF9vZl9kYXRhID0gMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RbYURhdGVBdHRyXSA9IGR0YVt0aGlzLmJ5X2luZGljZXNbYVJ1bGVUeXBlXV07XG4gICAgICB9IGVsc2UgaWYgKHRoaXNfZnJlcSkge1xuICAgICAgICB0aGlzW1wiaW5jcmVtZW50X1wiICsgYURhdGVBdHRyXSh0aGlzLnJ1bGUuaW50ZXJ2YWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGFzX2J5X3J1bGUgJiYgZW5kX29mX2RhdGEgJiYgdGhpc19mcmVxKSB7XG4gICAgICAgIHRoaXNbXCJpbmNyZW1lbnRfXCIgKyBhRm9sbG93aW5nQXR0cl0oMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbmRfb2ZfZGF0YTtcbiAgICB9LFxuXG4gICAgaW5jcmVtZW50X21vbnRoZGF5OiBmdW5jdGlvbiBpbmNyZW1lbnRfbW9udGhkYXkoaW5jKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluYzsgaSsrKSB7XG4gICAgICAgIHZhciBkYXlzSW5Nb250aCA9IElDQUwuVGltZS5kYXlzSW5Nb250aCh0aGlzLmxhc3QubW9udGgsIHRoaXMubGFzdC55ZWFyKTtcbiAgICAgICAgdGhpcy5sYXN0LmRheSsrO1xuXG4gICAgICAgIGlmICh0aGlzLmxhc3QuZGF5ID4gZGF5c0luTW9udGgpIHtcbiAgICAgICAgICB0aGlzLmxhc3QuZGF5IC09IGRheXNJbk1vbnRoO1xuICAgICAgICAgIHRoaXMuaW5jcmVtZW50X21vbnRoKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaW5jcmVtZW50X21vbnRoOiBmdW5jdGlvbiBpbmNyZW1lbnRfbW9udGgoKSB7XG4gICAgICB0aGlzLmxhc3QuZGF5ID0gMTtcbiAgICAgIGlmICh0aGlzLmhhc19ieV9kYXRhKFwiQllNT05USFwiKSkge1xuICAgICAgICB0aGlzLmJ5X2luZGljZXMuQllNT05USCsrO1xuXG4gICAgICAgIGlmICh0aGlzLmJ5X2luZGljZXMuQllNT05USCA9PSB0aGlzLmJ5X2RhdGEuQllNT05USC5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmJ5X2luZGljZXMuQllNT05USCA9IDA7XG4gICAgICAgICAgdGhpcy5pbmNyZW1lbnRfeWVhcigxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubGFzdC5tb250aCA9IHRoaXMuYnlfZGF0YS5CWU1PTlRIW3RoaXMuYnlfaW5kaWNlcy5CWU1PTlRIXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLnJ1bGUuZnJlcSA9PSBcIk1PTlRITFlcIikge1xuICAgICAgICAgIHRoaXMubGFzdC5tb250aCArPSB0aGlzLnJ1bGUuaW50ZXJ2YWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5sYXN0Lm1vbnRoKys7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxhc3QubW9udGgtLTtcbiAgICAgICAgdmFyIHllYXJzID0gSUNBTC5oZWxwZXJzLnRydW5jKHRoaXMubGFzdC5tb250aCAvIDEyKTtcbiAgICAgICAgdGhpcy5sYXN0Lm1vbnRoICU9IDEyO1xuICAgICAgICB0aGlzLmxhc3QubW9udGgrKztcblxuICAgICAgICBpZiAoeWVhcnMgIT0gMCkge1xuICAgICAgICAgIHRoaXMuaW5jcmVtZW50X3llYXIoeWVhcnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGluY3JlbWVudF95ZWFyOiBmdW5jdGlvbiBpbmNyZW1lbnRfeWVhcihpbmMpIHtcbiAgICAgIHRoaXMubGFzdC55ZWFyICs9IGluYztcbiAgICB9LFxuXG4gICAgaW5jcmVtZW50X2dlbmVyaWM6IGZ1bmN0aW9uIGluY3JlbWVudF9nZW5lcmljKGluYywgYURhdGVBdHRyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhRmFjdG9yLCBhTmV4dEluY3JlbWVudCkge1xuICAgICAgdGhpcy5sYXN0W2FEYXRlQXR0cl0gKz0gaW5jO1xuICAgICAgdmFyIG5leHR1bml0ID0gSUNBTC5oZWxwZXJzLnRydW5jKHRoaXMubGFzdFthRGF0ZUF0dHJdIC8gYUZhY3Rvcik7XG4gICAgICB0aGlzLmxhc3RbYURhdGVBdHRyXSAlPSBhRmFjdG9yO1xuICAgICAgaWYgKG5leHR1bml0ICE9IDApIHtcbiAgICAgICAgdGhpc1tcImluY3JlbWVudF9cIiArIGFOZXh0SW5jcmVtZW50XShuZXh0dW5pdCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGhhc19ieV9kYXRhOiBmdW5jdGlvbiBoYXNfYnlfZGF0YShhUnVsZVR5cGUpIHtcbiAgICAgIHJldHVybiAoYVJ1bGVUeXBlIGluIHRoaXMucnVsZS5wYXJ0cyk7XG4gICAgfSxcblxuICAgIGV4cGFuZF95ZWFyX2RheXM6IGZ1bmN0aW9uIGV4cGFuZF95ZWFyX2RheXMoYVllYXIpIHtcbiAgICAgIHZhciB0ID0gbmV3IElDQUwuVGltZSgpO1xuICAgICAgdGhpcy5kYXlzID0gW107XG5cbiAgICAgIC8vIFdlIG5lZWQgb3VyIG93biBjb3B5IHdpdGggYSBmZXcga2V5cyBzZXRcbiAgICAgIHZhciBwYXJ0cyA9IHt9O1xuICAgICAgdmFyIHJ1bGVzID0gW1wiQllEQVlcIiwgXCJCWVdFRUtOT1wiLCBcIkJZTU9OVEhEQVlcIiwgXCJCWU1PTlRIXCIsIFwiQllZRUFSREFZXCJdO1xuICAgICAgZm9yICh2YXIgcCBpbiBydWxlcykge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAocnVsZXMuaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgICAgICB2YXIgcGFydCA9IHJ1bGVzW3BdO1xuICAgICAgICAgIGlmIChwYXJ0IGluIHRoaXMucnVsZS5wYXJ0cykge1xuICAgICAgICAgICAgcGFydHNbcGFydF0gPSB0aGlzLnJ1bGUucGFydHNbcGFydF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChcIkJZTU9OVEhcIiBpbiBwYXJ0cyAmJiBcIkJZV0VFS05PXCIgaW4gcGFydHMpIHtcbiAgICAgICAgdmFyIHZhbGlkID0gMTtcbiAgICAgICAgdmFyIHZhbGlkV2Vla3MgPSB7fTtcbiAgICAgICAgdC55ZWFyID0gYVllYXI7XG4gICAgICAgIHQuaXNEYXRlID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKHZhciBtb250aElkeCA9IDA7IG1vbnRoSWR4IDwgdGhpcy5ieV9kYXRhLkJZTU9OVEgubGVuZ3RoOyBtb250aElkeCsrKSB7XG4gICAgICAgICAgdmFyIG1vbnRoID0gdGhpcy5ieV9kYXRhLkJZTU9OVEhbbW9udGhJZHhdO1xuICAgICAgICAgIHQubW9udGggPSBtb250aDtcbiAgICAgICAgICB0LmRheSA9IDE7XG4gICAgICAgICAgdmFyIGZpcnN0X3dlZWsgPSB0LndlZWtOdW1iZXIodGhpcy5ydWxlLndrc3QpO1xuICAgICAgICAgIHQuZGF5ID0gSUNBTC5UaW1lLmRheXNJbk1vbnRoKG1vbnRoLCBhWWVhcik7XG4gICAgICAgICAgdmFyIGxhc3Rfd2VlayA9IHQud2Vla051bWJlcih0aGlzLnJ1bGUud2tzdCk7XG4gICAgICAgICAgZm9yIChtb250aElkeCA9IGZpcnN0X3dlZWs7IG1vbnRoSWR4IDwgbGFzdF93ZWVrOyBtb250aElkeCsrKSB7XG4gICAgICAgICAgICB2YWxpZFdlZWtzW21vbnRoSWR4XSA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgd2Vla0lkeCA9IDA7IHdlZWtJZHggPCB0aGlzLmJ5X2RhdGEuQllXRUVLTk8ubGVuZ3RoICYmIHZhbGlkOyB3ZWVrSWR4KyspIHtcbiAgICAgICAgICB2YXIgd2Vla25vID0gdGhpcy5ieV9kYXRhLkJZV0VFS05PW3dlZWtJZHhdO1xuICAgICAgICAgIGlmICh3ZWVrbm8gPCA1Mikge1xuICAgICAgICAgICAgdmFsaWQgJj0gdmFsaWRXZWVrc1t3ZWVrSWR4XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsaWQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWxpZCkge1xuICAgICAgICAgIGRlbGV0ZSBwYXJ0cy5CWU1PTlRIO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBwYXJ0cy5CWVdFRUtOTztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcGFydENvdW50ID0gT2JqZWN0LmtleXMocGFydHMpLmxlbmd0aDtcblxuICAgICAgaWYgKHBhcnRDb3VudCA9PSAwKSB7XG4gICAgICAgIHZhciB0MSA9IHRoaXMuZHRzdGFydC5jbG9uZSgpO1xuICAgICAgICB0MS55ZWFyID0gdGhpcy5sYXN0LnllYXI7XG4gICAgICAgIHRoaXMuZGF5cy5wdXNoKHQxLmRheU9mWWVhcigpKTtcbiAgICAgIH0gZWxzZSBpZiAocGFydENvdW50ID09IDEgJiYgXCJCWU1PTlRIXCIgaW4gcGFydHMpIHtcbiAgICAgICAgZm9yICh2YXIgbW9udGhrZXkgaW4gdGhpcy5ieV9kYXRhLkJZTU9OVEgpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAoIXRoaXMuYnlfZGF0YS5CWU1PTlRILmhhc093blByb3BlcnR5KG1vbnRoa2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB0MiA9IHRoaXMuZHRzdGFydC5jbG9uZSgpO1xuICAgICAgICAgIHQyLnllYXIgPSBhWWVhcjtcbiAgICAgICAgICB0Mi5tb250aCA9IHRoaXMuYnlfZGF0YS5CWU1PTlRIW21vbnRoa2V5XTtcbiAgICAgICAgICB0Mi5pc0RhdGUgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuZGF5cy5wdXNoKHQyLmRheU9mWWVhcigpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJ0Q291bnQgPT0gMSAmJiBcIkJZTU9OVEhEQVlcIiBpbiBwYXJ0cykge1xuICAgICAgICBmb3IgKHZhciBtb250aGRheWtleSBpbiB0aGlzLmJ5X2RhdGEuQllNT05USERBWSkge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmICghdGhpcy5ieV9kYXRhLkJZTU9OVEhEQVkuaGFzT3duUHJvcGVydHkobW9udGhkYXlrZXkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHQzID0gdGhpcy5kdHN0YXJ0LmNsb25lKCk7XG4gICAgICAgICAgdmFyIGRheV8gPSB0aGlzLmJ5X2RhdGEuQllNT05USERBWVttb250aGRheWtleV07XG4gICAgICAgICAgaWYgKGRheV8gPCAwKSB7XG4gICAgICAgICAgICB2YXIgZGF5c0luTW9udGggPSBJQ0FMLlRpbWUuZGF5c0luTW9udGgodDMubW9udGgsIGFZZWFyKTtcbiAgICAgICAgICAgIGRheV8gPSBkYXlfICsgZGF5c0luTW9udGggKyAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0My5kYXkgPSBkYXlfO1xuICAgICAgICAgIHQzLnllYXIgPSBhWWVhcjtcbiAgICAgICAgICB0My5pc0RhdGUgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuZGF5cy5wdXNoKHQzLmRheU9mWWVhcigpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJ0Q291bnQgPT0gMiAmJlxuICAgICAgICAgICAgICAgICBcIkJZTU9OVEhEQVlcIiBpbiBwYXJ0cyAmJlxuICAgICAgICAgICAgICAgICBcIkJZTU9OVEhcIiBpbiBwYXJ0cykge1xuICAgICAgICBmb3IgKHZhciBtb250aGtleSBpbiB0aGlzLmJ5X2RhdGEuQllNT05USCkge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmICghdGhpcy5ieV9kYXRhLkJZTU9OVEguaGFzT3duUHJvcGVydHkobW9udGhrZXkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG1vbnRoXyA9IHRoaXMuYnlfZGF0YS5CWU1PTlRIW21vbnRoa2V5XTtcbiAgICAgICAgICB2YXIgZGF5c0luTW9udGggPSBJQ0FMLlRpbWUuZGF5c0luTW9udGgobW9udGhfLCBhWWVhcik7XG4gICAgICAgICAgZm9yICh2YXIgbW9udGhkYXlrZXkgaW4gdGhpcy5ieV9kYXRhLkJZTU9OVEhEQVkpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKCF0aGlzLmJ5X2RhdGEuQllNT05USERBWS5oYXNPd25Qcm9wZXJ0eShtb250aGRheWtleSkpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGF5XyA9IHRoaXMuYnlfZGF0YS5CWU1PTlRIREFZW21vbnRoZGF5a2V5XTtcbiAgICAgICAgICAgIGlmIChkYXlfIDwgMCkge1xuICAgICAgICAgICAgICBkYXlfID0gZGF5XyArIGRheXNJbk1vbnRoICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHQuZGF5ID0gZGF5XztcbiAgICAgICAgICAgIHQubW9udGggPSBtb250aF87XG4gICAgICAgICAgICB0LnllYXIgPSBhWWVhcjtcbiAgICAgICAgICAgIHQuaXNEYXRlID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGhpcy5kYXlzLnB1c2godC5kYXlPZlllYXIoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcnRDb3VudCA9PSAxICYmIFwiQllXRUVLTk9cIiBpbiBwYXJ0cykge1xuICAgICAgICAvLyBUT0RPIHVuaW1wbGVtZW50ZWQgaW4gbGliaWNhbFxuICAgICAgfSBlbHNlIGlmIChwYXJ0Q291bnQgPT0gMiAmJlxuICAgICAgICAgICAgICAgICBcIkJZV0VFS05PXCIgaW4gcGFydHMgJiZcbiAgICAgICAgICAgICAgICAgXCJCWU1PTlRIREFZXCIgaW4gcGFydHMpIHtcbiAgICAgICAgLy8gVE9ETyB1bmltcGxlbWVudGVkIGluIGxpYmljYWxcbiAgICAgIH0gZWxzZSBpZiAocGFydENvdW50ID09IDEgJiYgXCJCWURBWVwiIGluIHBhcnRzKSB7XG4gICAgICAgIHRoaXMuZGF5cyA9IHRoaXMuZGF5cy5jb25jYXQodGhpcy5leHBhbmRfYnlfZGF5KGFZZWFyKSk7XG4gICAgICB9IGVsc2UgaWYgKHBhcnRDb3VudCA9PSAyICYmIFwiQllEQVlcIiBpbiBwYXJ0cyAmJiBcIkJZTU9OVEhcIiBpbiBwYXJ0cykge1xuICAgICAgICBmb3IgKHZhciBtb250aGtleSBpbiB0aGlzLmJ5X2RhdGEuQllNT05USCkge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmICghdGhpcy5ieV9kYXRhLkJZTU9OVEguaGFzT3duUHJvcGVydHkobW9udGhrZXkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG1vbnRoID0gdGhpcy5ieV9kYXRhLkJZTU9OVEhbbW9udGhrZXldO1xuICAgICAgICAgIHZhciBkYXlzSW5Nb250aCA9IElDQUwuVGltZS5kYXlzSW5Nb250aChtb250aCwgYVllYXIpO1xuXG4gICAgICAgICAgdC55ZWFyID0gYVllYXI7XG4gICAgICAgICAgdC5tb250aCA9IHRoaXMuYnlfZGF0YS5CWU1PTlRIW21vbnRoa2V5XTtcbiAgICAgICAgICB0LmRheSA9IDE7XG4gICAgICAgICAgdC5pc0RhdGUgPSB0cnVlO1xuXG4gICAgICAgICAgdmFyIGZpcnN0X2RvdyA9IHQuZGF5T2ZXZWVrKCk7XG4gICAgICAgICAgdmFyIGRveV9vZmZzZXQgPSB0LmRheU9mWWVhcigpIC0gMTtcblxuICAgICAgICAgIHQuZGF5ID0gZGF5c0luTW9udGg7XG4gICAgICAgICAgdmFyIGxhc3RfZG93ID0gdC5kYXlPZldlZWsoKTtcblxuICAgICAgICAgIGlmICh0aGlzLmhhc19ieV9kYXRhKFwiQllTRVRQT1NcIikpIHtcbiAgICAgICAgICAgIHZhciBzZXRfcG9zX2NvdW50ZXIgPSAwO1xuICAgICAgICAgICAgdmFyIGJ5X21vbnRoX2RheSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgZGF5ID0gMTsgZGF5IDw9IGRheXNJbk1vbnRoOyBkYXkrKykge1xuICAgICAgICAgICAgICB0LmRheSA9IGRheTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuaXNfZGF5X2luX2J5ZGF5KHQpKSB7XG4gICAgICAgICAgICAgICAgYnlfbW9udGhfZGF5LnB1c2goZGF5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBzcEluZGV4ID0gMDsgc3BJbmRleCA8IGJ5X21vbnRoX2RheS5sZW5ndGg7IHNwSW5kZXgrKykge1xuICAgICAgICAgICAgICBpZiAodGhpcy5jaGVja19zZXRfcG9zaXRpb24oc3BJbmRleCArIDEpIHx8XG4gICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrX3NldF9wb3NpdGlvbihzcEluZGV4IC0gYnlfbW9udGhfZGF5Lmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRheXMucHVzaChkb3lfb2Zmc2V0ICsgYnlfbW9udGhfZGF5W3NwSW5kZXhdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBkYXljb2RlZGtleSBpbiB0aGlzLmJ5X2RhdGEuQllEQVkpIHtcbiAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgIGlmICghdGhpcy5ieV9kYXRhLkJZREFZLmhhc093blByb3BlcnR5KGRheWNvZGVka2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBjb2RlZF9kYXkgPSB0aGlzLmJ5X2RhdGEuQllEQVlbZGF5Y29kZWRrZXldO1xuICAgICAgICAgICAgICB2YXIgYnlkYXlQYXJ0cyA9IHRoaXMucnVsZURheU9mV2Vlayhjb2RlZF9kYXkpO1xuICAgICAgICAgICAgICB2YXIgcG9zID0gYnlkYXlQYXJ0c1swXTtcbiAgICAgICAgICAgICAgdmFyIGRvdyA9IGJ5ZGF5UGFydHNbMV07XG4gICAgICAgICAgICAgIHZhciBtb250aF9kYXk7XG5cbiAgICAgICAgICAgICAgdmFyIGZpcnN0X21hdGNoaW5nX2RheSA9ICgoZG93ICsgNyAtIGZpcnN0X2RvdykgJSA3KSArIDE7XG4gICAgICAgICAgICAgIHZhciBsYXN0X21hdGNoaW5nX2RheSA9IGRheXNJbk1vbnRoIC0gKChsYXN0X2RvdyArIDcgLSBkb3cpICUgNyk7XG5cbiAgICAgICAgICAgICAgaWYgKHBvcyA9PSAwKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZGF5ID0gZmlyc3RfbWF0Y2hpbmdfZGF5OyBkYXkgPD0gZGF5c0luTW9udGg7IGRheSArPSA3KSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmRheXMucHVzaChkb3lfb2Zmc2V0ICsgZGF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocG9zID4gMCkge1xuICAgICAgICAgICAgICAgIG1vbnRoX2RheSA9IGZpcnN0X21hdGNoaW5nX2RheSArIChwb3MgLSAxKSAqIDc7XG5cbiAgICAgICAgICAgICAgICBpZiAobW9udGhfZGF5IDw9IGRheXNJbk1vbnRoKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmRheXMucHVzaChkb3lfb2Zmc2V0ICsgbW9udGhfZGF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbW9udGhfZGF5ID0gbGFzdF9tYXRjaGluZ19kYXkgKyAocG9zICsgMSkgKiA3O1xuXG4gICAgICAgICAgICAgICAgaWYgKG1vbnRoX2RheSA+IDApIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuZGF5cy5wdXNoKGRveV9vZmZzZXQgKyBtb250aF9kYXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gZGF0ZXMgaW4gb3JkZXIgb2Ygb2NjdXJyZW5jZSAoMSwyLDMsLi4uKSBpbnN0ZWFkXG4gICAgICAgIC8vIG9mIGJ5IGdyb3VwcyBvZiB3ZWVrZGF5cyAoMSw4LDE1LC4uLiwyLDksMTYsLi4uKS5cbiAgICAgICAgdGhpcy5kYXlzLnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYSAtIGI7IH0pOyAvLyBDb21wYXJhdG9yIGZ1bmN0aW9uIGFsbG93cyB0byBzb3J0IG51bWJlcnMuXG4gICAgICB9IGVsc2UgaWYgKHBhcnRDb3VudCA9PSAyICYmIFwiQllEQVlcIiBpbiBwYXJ0cyAmJiBcIkJZTU9OVEhEQVlcIiBpbiBwYXJ0cykge1xuICAgICAgICB2YXIgZXhwYW5kZWREYXlzID0gdGhpcy5leHBhbmRfYnlfZGF5KGFZZWFyKTtcblxuICAgICAgICBmb3IgKHZhciBkYXlrZXkgaW4gZXhwYW5kZWREYXlzKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKCFleHBhbmRlZERheXMuaGFzT3duUHJvcGVydHkoZGF5a2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBkYXkgPSBleHBhbmRlZERheXNbZGF5a2V5XTtcbiAgICAgICAgICB2YXIgdHQgPSBJQ0FMLlRpbWUuZnJvbURheU9mWWVhcihkYXksIGFZZWFyKTtcbiAgICAgICAgICBpZiAodGhpcy5ieV9kYXRhLkJZTU9OVEhEQVkuaW5kZXhPZih0dC5kYXkpID49IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGF5cy5wdXNoKGRheSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcnRDb3VudCA9PSAzICYmXG4gICAgICAgICAgICAgICAgIFwiQllEQVlcIiBpbiBwYXJ0cyAmJlxuICAgICAgICAgICAgICAgICBcIkJZTU9OVEhEQVlcIiBpbiBwYXJ0cyAmJlxuICAgICAgICAgICAgICAgICBcIkJZTU9OVEhcIiBpbiBwYXJ0cykge1xuICAgICAgICB2YXIgZXhwYW5kZWREYXlzID0gdGhpcy5leHBhbmRfYnlfZGF5KGFZZWFyKTtcblxuICAgICAgICBmb3IgKHZhciBkYXlrZXkgaW4gZXhwYW5kZWREYXlzKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKCFleHBhbmRlZERheXMuaGFzT3duUHJvcGVydHkoZGF5a2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBkYXkgPSBleHBhbmRlZERheXNbZGF5a2V5XTtcbiAgICAgICAgICB2YXIgdHQgPSBJQ0FMLlRpbWUuZnJvbURheU9mWWVhcihkYXksIGFZZWFyKTtcblxuICAgICAgICAgIGlmICh0aGlzLmJ5X2RhdGEuQllNT05USC5pbmRleE9mKHR0Lm1vbnRoKSA+PSAwICYmXG4gICAgICAgICAgICAgIHRoaXMuYnlfZGF0YS5CWU1PTlRIREFZLmluZGV4T2YodHQuZGF5KSA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRheXMucHVzaChkYXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJ0Q291bnQgPT0gMiAmJiBcIkJZREFZXCIgaW4gcGFydHMgJiYgXCJCWVdFRUtOT1wiIGluIHBhcnRzKSB7XG4gICAgICAgIHZhciBleHBhbmRlZERheXMgPSB0aGlzLmV4cGFuZF9ieV9kYXkoYVllYXIpO1xuXG4gICAgICAgIGZvciAodmFyIGRheWtleSBpbiBleHBhbmRlZERheXMpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAoIWV4cGFuZGVkRGF5cy5oYXNPd25Qcm9wZXJ0eShkYXlrZXkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGRheSA9IGV4cGFuZGVkRGF5c1tkYXlrZXldO1xuICAgICAgICAgIHZhciB0dCA9IElDQUwuVGltZS5mcm9tRGF5T2ZZZWFyKGRheSwgYVllYXIpO1xuICAgICAgICAgIHZhciB3ZWVrbm8gPSB0dC53ZWVrTnVtYmVyKHRoaXMucnVsZS53a3N0KTtcblxuICAgICAgICAgIGlmICh0aGlzLmJ5X2RhdGEuQllXRUVLTk8uaW5kZXhPZih3ZWVrbm8pKSB7XG4gICAgICAgICAgICB0aGlzLmRheXMucHVzaChkYXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJ0Q291bnQgPT0gMyAmJlxuICAgICAgICAgICAgICAgICBcIkJZREFZXCIgaW4gcGFydHMgJiZcbiAgICAgICAgICAgICAgICAgXCJCWVdFRUtOT1wiIGluIHBhcnRzICYmXG4gICAgICAgICAgICAgICAgIFwiQllNT05USERBWVwiIGluIHBhcnRzKSB7XG4gICAgICAgIC8vIFRPRE8gdW5pbXBsZW10ZWQgaW4gbGliaWNhbFxuICAgICAgfSBlbHNlIGlmIChwYXJ0Q291bnQgPT0gMSAmJiBcIkJZWUVBUkRBWVwiIGluIHBhcnRzKSB7XG4gICAgICAgIHRoaXMuZGF5cyA9IHRoaXMuZGF5cy5jb25jYXQodGhpcy5ieV9kYXRhLkJZWUVBUkRBWSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRheXMgPSBbXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG5cbiAgICBleHBhbmRfYnlfZGF5OiBmdW5jdGlvbiBleHBhbmRfYnlfZGF5KGFZZWFyKSB7XG5cbiAgICAgIHZhciBkYXlzX2xpc3QgPSBbXTtcbiAgICAgIHZhciB0bXAgPSB0aGlzLmxhc3QuY2xvbmUoKTtcblxuICAgICAgdG1wLnllYXIgPSBhWWVhcjtcbiAgICAgIHRtcC5tb250aCA9IDE7XG4gICAgICB0bXAuZGF5ID0gMTtcbiAgICAgIHRtcC5pc0RhdGUgPSB0cnVlO1xuXG4gICAgICB2YXIgc3RhcnRfZG93ID0gdG1wLmRheU9mV2VlaygpO1xuXG4gICAgICB0bXAubW9udGggPSAxMjtcbiAgICAgIHRtcC5kYXkgPSAzMTtcbiAgICAgIHRtcC5pc0RhdGUgPSB0cnVlO1xuXG4gICAgICB2YXIgZW5kX2RvdyA9IHRtcC5kYXlPZldlZWsoKTtcbiAgICAgIHZhciBlbmRfeWVhcl9kYXkgPSB0bXAuZGF5T2ZZZWFyKCk7XG5cbiAgICAgIGZvciAodmFyIGRheWtleSBpbiB0aGlzLmJ5X2RhdGEuQllEQVkpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghdGhpcy5ieV9kYXRhLkJZREFZLmhhc093blByb3BlcnR5KGRheWtleSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF5ID0gdGhpcy5ieV9kYXRhLkJZREFZW2RheWtleV07XG4gICAgICAgIHZhciBwYXJ0cyA9IHRoaXMucnVsZURheU9mV2VlayhkYXkpO1xuICAgICAgICB2YXIgcG9zID0gcGFydHNbMF07XG4gICAgICAgIHZhciBkb3cgPSBwYXJ0c1sxXTtcblxuICAgICAgICBpZiAocG9zID09IDApIHtcbiAgICAgICAgICB2YXIgdG1wX3N0YXJ0X2RveSA9ICgoZG93ICsgNyAtIHN0YXJ0X2RvdykgJSA3KSArIDE7XG5cbiAgICAgICAgICBmb3IgKHZhciBkb3kgPSB0bXBfc3RhcnRfZG95OyBkb3kgPD0gZW5kX3llYXJfZGF5OyBkb3kgKz0gNykge1xuICAgICAgICAgICAgZGF5c19saXN0LnB1c2goZG95KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChwb3MgPiAwKSB7XG4gICAgICAgICAgdmFyIGZpcnN0O1xuICAgICAgICAgIGlmIChkb3cgPj0gc3RhcnRfZG93KSB7XG4gICAgICAgICAgICBmaXJzdCA9IGRvdyAtIHN0YXJ0X2RvdyArIDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZpcnN0ID0gZG93IC0gc3RhcnRfZG93ICsgODtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkYXlzX2xpc3QucHVzaChmaXJzdCArIChwb3MgLSAxKSAqIDcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBsYXN0O1xuICAgICAgICAgIHBvcyA9IC1wb3M7XG5cbiAgICAgICAgICBpZiAoZG93IDw9IGVuZF9kb3cpIHtcbiAgICAgICAgICAgIGxhc3QgPSBlbmRfeWVhcl9kYXkgLSBlbmRfZG93ICsgZG93O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsYXN0ID0gZW5kX3llYXJfZGF5IC0gZW5kX2RvdyArIGRvdyAtIDc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGF5c19saXN0LnB1c2gobGFzdCAtIChwb3MgLSAxKSAqIDcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF5c19saXN0O1xuICAgIH0sXG5cbiAgICBpc19kYXlfaW5fYnlkYXk6IGZ1bmN0aW9uIGlzX2RheV9pbl9ieWRheSh0dCkge1xuICAgICAgZm9yICh2YXIgZGF5a2V5IGluIHRoaXMuYnlfZGF0YS5CWURBWSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCF0aGlzLmJ5X2RhdGEuQllEQVkuaGFzT3duUHJvcGVydHkoZGF5a2V5KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXkgPSB0aGlzLmJ5X2RhdGEuQllEQVlbZGF5a2V5XTtcbiAgICAgICAgdmFyIHBhcnRzID0gdGhpcy5ydWxlRGF5T2ZXZWVrKGRheSk7XG4gICAgICAgIHZhciBwb3MgPSBwYXJ0c1swXTtcbiAgICAgICAgdmFyIGRvdyA9IHBhcnRzWzFdO1xuICAgICAgICB2YXIgdGhpc19kb3cgPSB0dC5kYXlPZldlZWsoKTtcblxuICAgICAgICBpZiAoKHBvcyA9PSAwICYmIGRvdyA9PSB0aGlzX2RvdykgfHxcbiAgICAgICAgICAgICh0dC5udGhXZWVrRGF5KGRvdywgcG9zKSA9PSB0dC5kYXkpKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBnaXZlbiB2YWx1ZSBpcyBpbiBCWVNFVFBPUy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1lcmljfSBhUG9zIHBvc2l0aW9uIHRvIGNoZWNrIGZvci5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBmYWxzZSB1bmxlc3MgQllTRVRQT1MgcnVsZXMgZXhpc3RcbiAgICAgKiAgICAgICAgICAgICAgICAgICBhbmQgdGhlIGdpdmVuIHZhbHVlIGlzIHByZXNlbnQgaW4gcnVsZXMuXG4gICAgICovXG4gICAgY2hlY2tfc2V0X3Bvc2l0aW9uOiBmdW5jdGlvbiBjaGVja19zZXRfcG9zaXRpb24oYVBvcykge1xuICAgICAgaWYgKHRoaXMuaGFzX2J5X2RhdGEoJ0JZU0VUUE9TJykpIHtcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMuYnlfZGF0YS5CWVNFVFBPUy5pbmRleE9mKGFQb3MpO1xuICAgICAgICAvLyBuZWdhdGl2ZSBudW1iZXJzIGFyZSBub3QgZmFsc2UteVxuICAgICAgICByZXR1cm4gaWR4ICE9PSAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgc29ydF9ieWRheV9ydWxlczogZnVuY3Rpb24gaWNhbHJlY3VyX3NvcnRfYnlkYXlfcnVsZXMoYVJ1bGVzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFSdWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGk7IGorKykge1xuICAgICAgICAgIHZhciBvbmUgPSB0aGlzLnJ1bGVEYXlPZldlZWsoYVJ1bGVzW2pdLCB0aGlzLnJ1bGUud2tzdClbMV07XG4gICAgICAgICAgdmFyIHR3byA9IHRoaXMucnVsZURheU9mV2VlayhhUnVsZXNbaV0sIHRoaXMucnVsZS53a3N0KVsxXTtcblxuICAgICAgICAgIGlmIChvbmUgPiB0d28pIHtcbiAgICAgICAgICAgIHZhciB0bXAgPSBhUnVsZXNbaV07XG4gICAgICAgICAgICBhUnVsZXNbaV0gPSBhUnVsZXNbal07XG4gICAgICAgICAgICBhUnVsZXNbal0gPSB0bXA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGNoZWNrX2NvbnRyYWN0X3Jlc3RyaWN0aW9uOiBmdW5jdGlvbiBjaGVja19jb250cmFjdF9yZXN0cmljdGlvbihhUnVsZVR5cGUsIHYpIHtcbiAgICAgIHZhciBpbmRleE1hcFZhbHVlID0gaWNhbHJlY3VyX2l0ZXJhdG9yLl9pbmRleE1hcFthUnVsZVR5cGVdO1xuICAgICAgdmFyIHJ1bGVNYXBWYWx1ZSA9IGljYWxyZWN1cl9pdGVyYXRvci5fZXhwYW5kTWFwW3RoaXMucnVsZS5mcmVxXVtpbmRleE1hcFZhbHVlXTtcbiAgICAgIHZhciBwYXNzID0gZmFsc2U7XG5cbiAgICAgIGlmIChhUnVsZVR5cGUgaW4gdGhpcy5ieV9kYXRhICYmXG4gICAgICAgICAgcnVsZU1hcFZhbHVlID09IGljYWxyZWN1cl9pdGVyYXRvci5DT05UUkFDVCkge1xuXG4gICAgICAgIHZhciBydWxlVHlwZSA9IHRoaXMuYnlfZGF0YVthUnVsZVR5cGVdO1xuXG4gICAgICAgIGZvciAodmFyIGJ5ZGF0YWtleSBpbiBydWxlVHlwZSkge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgaWYgKHJ1bGVUeXBlLmhhc093blByb3BlcnR5KGJ5ZGF0YWtleSkpIHtcbiAgICAgICAgICAgIGlmIChydWxlVHlwZVtieWRhdGFrZXldID09IHYpIHtcbiAgICAgICAgICAgICAgcGFzcyA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm90IGEgY29udHJhY3RpbmcgYnlydWxlIG9yIGhhcyBubyBkYXRhLCB0ZXN0IHBhc3Nlc1xuICAgICAgICBwYXNzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXNzO1xuICAgIH0sXG5cbiAgICBjaGVja19jb250cmFjdGluZ19ydWxlczogZnVuY3Rpb24gY2hlY2tfY29udHJhY3RpbmdfcnVsZXMoKSB7XG4gICAgICB2YXIgZG93ID0gdGhpcy5sYXN0LmRheU9mV2VlaygpO1xuICAgICAgdmFyIHdlZWtObyA9IHRoaXMubGFzdC53ZWVrTnVtYmVyKHRoaXMucnVsZS53a3N0KTtcbiAgICAgIHZhciBkb3kgPSB0aGlzLmxhc3QuZGF5T2ZZZWFyKCk7XG5cbiAgICAgIHJldHVybiAodGhpcy5jaGVja19jb250cmFjdF9yZXN0cmljdGlvbihcIkJZU0VDT05EXCIsIHRoaXMubGFzdC5zZWNvbmQpICYmXG4gICAgICAgICAgICAgIHRoaXMuY2hlY2tfY29udHJhY3RfcmVzdHJpY3Rpb24oXCJCWU1JTlVURVwiLCB0aGlzLmxhc3QubWludXRlKSAmJlxuICAgICAgICAgICAgICB0aGlzLmNoZWNrX2NvbnRyYWN0X3Jlc3RyaWN0aW9uKFwiQllIT1VSXCIsIHRoaXMubGFzdC5ob3VyKSAmJlxuICAgICAgICAgICAgICB0aGlzLmNoZWNrX2NvbnRyYWN0X3Jlc3RyaWN0aW9uKFwiQllEQVlcIiwgSUNBTC5SZWN1ci5udW1lcmljRGF5VG9JY2FsRGF5KGRvdykpICYmXG4gICAgICAgICAgICAgIHRoaXMuY2hlY2tfY29udHJhY3RfcmVzdHJpY3Rpb24oXCJCWVdFRUtOT1wiLCB3ZWVrTm8pICYmXG4gICAgICAgICAgICAgIHRoaXMuY2hlY2tfY29udHJhY3RfcmVzdHJpY3Rpb24oXCJCWU1PTlRIREFZXCIsIHRoaXMubGFzdC5kYXkpICYmXG4gICAgICAgICAgICAgIHRoaXMuY2hlY2tfY29udHJhY3RfcmVzdHJpY3Rpb24oXCJCWU1PTlRIXCIsIHRoaXMubGFzdC5tb250aCkgJiZcbiAgICAgICAgICAgICAgdGhpcy5jaGVja19jb250cmFjdF9yZXN0cmljdGlvbihcIkJZWUVBUkRBWVwiLCBkb3kpKTtcbiAgICB9LFxuXG4gICAgc2V0dXBfZGVmYXVsdHM6IGZ1bmN0aW9uIHNldHVwX2RlZmF1bHRzKGFSdWxlVHlwZSwgcmVxLCBkZWZ0aW1lKSB7XG4gICAgICB2YXIgaW5kZXhNYXBWYWx1ZSA9IGljYWxyZWN1cl9pdGVyYXRvci5faW5kZXhNYXBbYVJ1bGVUeXBlXTtcbiAgICAgIHZhciBydWxlTWFwVmFsdWUgPSBpY2FscmVjdXJfaXRlcmF0b3IuX2V4cGFuZE1hcFt0aGlzLnJ1bGUuZnJlcV1baW5kZXhNYXBWYWx1ZV07XG5cbiAgICAgIGlmIChydWxlTWFwVmFsdWUgIT0gaWNhbHJlY3VyX2l0ZXJhdG9yLkNPTlRSQUNUKSB7XG4gICAgICAgIGlmICghKGFSdWxlVHlwZSBpbiB0aGlzLmJ5X2RhdGEpKSB7XG4gICAgICAgICAgdGhpcy5ieV9kYXRhW2FSdWxlVHlwZV0gPSBbZGVmdGltZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucnVsZS5mcmVxICE9IHJlcSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmJ5X2RhdGFbYVJ1bGVUeXBlXVswXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRlZnRpbWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgaXRlcmF0b3IgaW50byBhIHNlcmlhbGl6ZS1hYmxlIG9iamVjdC4gIFdpbGwgcHJlc2VydmUgY3VycmVudFxuICAgICAqIGl0ZXJhdGlvbiBzZXF1ZW5jZSB0byBlbnN1cmUgdGhlIHNlYW1sZXNzIGNvbnRpbnVhdGlvbiBvZiB0aGUgcmVjdXJyZW5jZVxuICAgICAqIHJ1bGUuXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgICAgcmVzdWx0LmluaXRpYWxpemVkID0gdGhpcy5pbml0aWFsaXplZDtcbiAgICAgIHJlc3VsdC5ydWxlID0gdGhpcy5ydWxlLnRvSlNPTigpO1xuICAgICAgcmVzdWx0LmR0c3RhcnQgPSB0aGlzLmR0c3RhcnQudG9KU09OKCk7XG4gICAgICByZXN1bHQuYnlfZGF0YSA9IHRoaXMuYnlfZGF0YTtcbiAgICAgIHJlc3VsdC5kYXlzID0gdGhpcy5kYXlzO1xuICAgICAgcmVzdWx0Lmxhc3QgPSB0aGlzLmxhc3QudG9KU09OKCk7XG4gICAgICByZXN1bHQuYnlfaW5kaWNlcyA9IHRoaXMuYnlfaW5kaWNlcztcbiAgICAgIHJlc3VsdC5vY2N1cnJlbmNlX251bWJlciA9IHRoaXMub2NjdXJyZW5jZV9udW1iZXI7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9O1xuXG4gIGljYWxyZWN1cl9pdGVyYXRvci5faW5kZXhNYXAgPSB7XG4gICAgXCJCWVNFQ09ORFwiOiAwLFxuICAgIFwiQllNSU5VVEVcIjogMSxcbiAgICBcIkJZSE9VUlwiOiAyLFxuICAgIFwiQllEQVlcIjogMyxcbiAgICBcIkJZTU9OVEhEQVlcIjogNCxcbiAgICBcIkJZWUVBUkRBWVwiOiA1LFxuICAgIFwiQllXRUVLTk9cIjogNixcbiAgICBcIkJZTU9OVEhcIjogNyxcbiAgICBcIkJZU0VUUE9TXCI6IDhcbiAgfTtcblxuICBpY2FscmVjdXJfaXRlcmF0b3IuX2V4cGFuZE1hcCA9IHtcbiAgICBcIlNFQ09ORExZXCI6IFsxLCAxLCAxLCAxLCAxLCAxLCAxLCAxXSxcbiAgICBcIk1JTlVURUxZXCI6IFsyLCAxLCAxLCAxLCAxLCAxLCAxLCAxXSxcbiAgICBcIkhPVVJMWVwiOiBbMiwgMiwgMSwgMSwgMSwgMSwgMSwgMV0sXG4gICAgXCJEQUlMWVwiOiBbMiwgMiwgMiwgMSwgMSwgMSwgMSwgMV0sXG4gICAgXCJXRUVLTFlcIjogWzIsIDIsIDIsIDIsIDMsIDMsIDEsIDFdLFxuICAgIFwiTU9OVEhMWVwiOiBbMiwgMiwgMiwgMiwgMiwgMywgMywgMV0sXG4gICAgXCJZRUFSTFlcIjogWzIsIDIsIDIsIDIsIDIsIDIsIDIsIDJdXG4gIH07XG4gIGljYWxyZWN1cl9pdGVyYXRvci5VTktOT1dOID0gMDtcbiAgaWNhbHJlY3VyX2l0ZXJhdG9yLkNPTlRSQUNUID0gMTtcbiAgaWNhbHJlY3VyX2l0ZXJhdG9yLkVYUEFORCA9IDI7XG4gIGljYWxyZWN1cl9pdGVyYXRvci5JTExFR0FMID0gMztcblxuICByZXR1cm4gaWNhbHJlY3VyX2l0ZXJhdG9yO1xuXG59KCkpO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoLCAyMDExLTIwMTUgKi9cblxuXG4vKipcbiAqIFRoaXMgc3ltYm9sIGlzIGZ1cnRoZXIgZGVzY3JpYmVkIGxhdGVyIG9uXG4gKiBAaWdub3JlXG4gKi9cbklDQUwuUmVjdXJFeHBhbnNpb24gPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIGZvcm1hdFRpbWUoaXRlbSkge1xuICAgIHJldHVybiBJQ0FMLmhlbHBlcnMuZm9ybWF0Q2xhc3NUeXBlKGl0ZW0sIElDQUwuVGltZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wYXJlVGltZShhLCBiKSB7XG4gICAgcmV0dXJuIGEuY29tcGFyZShiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUmVjdXJyaW5nQ29tcG9uZW50KGNvbXApIHtcbiAgICByZXR1cm4gY29tcC5oYXNQcm9wZXJ0eSgncmRhdGUnKSB8fFxuICAgICAgICAgICBjb21wLmhhc1Byb3BlcnR5KCdycnVsZScpIHx8XG4gICAgICAgICAgIGNvbXAuaGFzUHJvcGVydHkoJ3JlY3VycmVuY2UtaWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIFByaW1hcnkgY2xhc3MgZm9yIGV4cGFuZGluZyByZWN1cnJpbmcgcnVsZXMuICBDYW4gdGFrZSBtdWx0aXBsZSBycnVsZXMsXG4gICAqIHJkYXRlcywgZXhkYXRlKHMpIGFuZCBpdGVyYXRlIChpbiBvcmRlcikgb3ZlciBlYWNoIG5leHQgb2NjdXJyZW5jZS5cbiAgICpcbiAgICogT25jZSBpbml0aWFsaXplZCB0aGlzIGNsYXNzIGNhbiBhbHNvIGJlIHNlcmlhbGl6ZWQgc2F2ZWQgYW5kIGNvbnRpbnVlXG4gICAqIGl0ZXJhdGlvbiBmcm9tIHRoZSBsYXN0IHBvaW50LlxuICAgKlxuICAgKiBOT1RFOiBpdCBpcyBpbnRlbmRlZCB0aGF0IHRoaXMgY2xhc3MgaXMgdG8gYmUgdXNlZFxuICAgKiAgICAgICB3aXRoIElDQUwuRXZlbnQgd2hpY2ggaGFuZGxlcyByZWN1cnJlbmNlIGV4Y2VwdGlvbnMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGFzc3VtaW5nIGV2ZW50IGlzIGEgcGFyc2VkIGljYWwgY29tcG9uZW50XG4gICAqIHZhciBldmVudDtcbiAgICpcbiAgICogdmFyIGV4cGFuZCA9IG5ldyBJQ0FMLlJlY3VyRXhwYW5zaW9uKHtcbiAgICogICBjb21wb25lbnQ6IGV2ZW50LFxuICAgKiAgIGR0c3RhcnQ6IGV2ZW50LmdldEZpcnN0UHJvcGVydHlWYWx1ZSgnZHRzdGFydCcpXG4gICAqIH0pO1xuICAgKlxuICAgKiAvLyByZW1lbWJlciB0aGVyZSBhcmUgaW5maW5pdGUgcnVsZXNcbiAgICogLy8gc28gaXQgaXMgYSBnb29kIGlkZWEgdG8gbGltaXQgdGhlIHNjb3BlXG4gICAqIC8vIG9mIHRoZSBpdGVyYXRpb25zIHRoZW4gcmVzdW1lIGxhdGVyIG9uLlxuICAgKlxuICAgKiAvLyBuZXh0IGlzIGFsd2F5cyBhbiBJQ0FMLlRpbWUgb3IgbnVsbFxuICAgKiB2YXIgbmV4dDtcbiAgICpcbiAgICogd2hpbGUgKHNvbWVDb25kaXRpb24gJiYgKG5leHQgPSBleHBhbmQubmV4dCgpKSkge1xuICAgKiAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIG5leHRcbiAgICogfVxuICAgKlxuICAgKiAvLyBzYXZlIGluc3RhbmNlIGZvciBsYXRlclxuICAgKiB2YXIganNvbiA9IEpTT04uc3RyaW5naWZ5KGV4cGFuZCk7XG4gICAqXG4gICAqIC8vLi4uXG4gICAqXG4gICAqIC8vIE5PVEU6IGlmIHRoZSBjb21wb25lbnQncyBwcm9wZXJ0aWVzIGhhdmVcbiAgICogLy8gICAgICAgY2hhbmdlZCB5b3Ugd2lsbCBuZWVkIHRvIHJlYnVpbGQgdGhlXG4gICAqIC8vICAgICAgIGNsYXNzIGFuZCBzdGFydCBvdmVyLiBUaGlzIG9ubHkgd29ya3NcbiAgICogLy8gICAgICAgd2hlbiB0aGUgY29tcG9uZW50J3MgcmVjdXJyZW5jZSBpbmZvIGlzIHRoZSBzYW1lLlxuICAgKiB2YXIgZXhwYW5kID0gbmV3IElDQUwuUmVjdXJFeHBhbnNpb24oSlNPTi5wYXJzZShqc29uKSk7XG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBUaGUgb3B0aW9ucyBvYmplY3QgY2FuIGJlIGZpbGxlZCB3aXRoIHRoZSBzcGVjaWZpZWQgaW5pdGlhbCB2YWx1ZXMuIEl0IGNhblxuICAgKiBhbHNvIGNvbnRhaW4gYWRkaXRpb25hbCBtZW1iZXJzLCBhcyBhIHJlc3VsdCBvZiBzZXJpYWxpemluZyBhIHByZXZpb3VzXG4gICAqIGV4cGFuc2lvbiBzdGF0ZSwgYXMgc2hvd24gaW4gdGhlIGV4YW1wbGUuXG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAYWxpYXMgSUNBTC5SZWN1ckV4cGFuc2lvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiAgICAgICAgUmVjdXJyZW5jZSBleHBhbnNpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0lDQUwuVGltZX0gb3B0aW9ucy5kdHN0YXJ0XG4gICAqICAgICAgICBTdGFydCB0aW1lIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge0lDQUwuQ29tcG9uZW50PX0gb3B0aW9ucy5jb21wb25lbnRcbiAgICogICAgICAgIENvbXBvbmVudCBmb3IgZXhwYW5zaW9uLCByZXF1aXJlZCBpZiBub3QgcmVzdW1pbmcuXG4gICAqL1xuICBmdW5jdGlvbiBSZWN1ckV4cGFuc2lvbihvcHRpb25zKSB7XG4gICAgdGhpcy5ydWxlRGF0ZXMgPSBbXTtcbiAgICB0aGlzLmV4RGF0ZXMgPSBbXTtcbiAgICB0aGlzLmZyb21EYXRhKG9wdGlvbnMpO1xuICB9XG5cbiAgUmVjdXJFeHBhbnNpb24ucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIFRydWUgd2hlbiBpdGVyYXRpb24gaXMgZnVsbHkgY29tcGxldGVkLlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIGNvbXBsZXRlOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEFycmF5IG9mIHJydWxlIGl0ZXJhdG9ycy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtJQ0FMLlJlY3VySXRlcmF0b3JbXX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHJ1bGVJdGVyYXRvcnM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBvZiByZGF0ZSBpbnN0YW5jZXMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7SUNBTC5UaW1lW119XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBydWxlRGF0ZXM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBvZiBleGRhdGUgaW5zdGFuY2VzLlxuICAgICAqXG4gICAgICogQHR5cGUge0lDQUwuVGltZVtdfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZXhEYXRlczogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgcG9zaXRpb24gaW4gcnVsZURhdGVzIGFycmF5LlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBydWxlRGF0ZUluYzogMCxcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgcG9zaXRpb24gaW4gZXhEYXRlcyBhcnJheVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBleERhdGVJbmM6IDAsXG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IG5lZ2F0aXZlIGRhdGUuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7SUNBTC5UaW1lfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZXhEYXRlOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBhZGRpdGlvbmFsIGRhdGUuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7SUNBTC5UaW1lfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcnVsZURhdGU6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBTdGFydCBkYXRlIG9mIHJlY3VycmluZyBydWxlcy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtJQ0FMLlRpbWV9XG4gICAgICovXG4gICAgZHRzdGFydDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIExhc3QgZXhwYW5kZWQgdGltZVxuICAgICAqXG4gICAgICogQHR5cGUge0lDQUwuVGltZX1cbiAgICAgKi9cbiAgICBsYXN0OiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgcmVjdXJyZW5jZSBleHBhbnNpb24gZnJvbSB0aGUgZGF0YSBvYmplY3QuIFRoZSBvcHRpb25zXG4gICAgICogb2JqZWN0IG1heSBhbHNvIGNvbnRhaW4gYWRkaXRpb25hbCBtZW1iZXJzLCBzZWUgdGhlXG4gICAgICoge0BsaW5rIElDQUwuUmVjdXJFeHBhbnNpb24gY29uc3RydWN0b3J9IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqICAgICAgICBSZWN1cnJlbmNlIGV4cGFuc2lvbiBvcHRpb25zXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWV9IG9wdGlvbnMuZHRzdGFydFxuICAgICAqICAgICAgICBTdGFydCB0aW1lIG9mIHRoZSBldmVudFxuICAgICAqIEBwYXJhbSB7SUNBTC5Db21wb25lbnQ9fSBvcHRpb25zLmNvbXBvbmVudFxuICAgICAqICAgICAgICBDb21wb25lbnQgZm9yIGV4cGFuc2lvbiwgcmVxdWlyZWQgaWYgbm90IHJlc3VtaW5nLlxuICAgICAqL1xuICAgIGZyb21EYXRhOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgc3RhcnQgPSBJQ0FMLmhlbHBlcnMuZm9ybWF0Q2xhc3NUeXBlKG9wdGlvbnMuZHRzdGFydCwgSUNBTC5UaW1lKTtcblxuICAgICAgaWYgKCFzdGFydCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJy5kdHN0YXJ0IChJQ0FMLlRpbWUpIG11c3QgYmUgZ2l2ZW4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZHRzdGFydCA9IHN0YXJ0O1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5jb21wb25lbnQpIHtcbiAgICAgICAgdGhpcy5faW5pdChvcHRpb25zLmNvbXBvbmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxhc3QgPSBmb3JtYXRUaW1lKG9wdGlvbnMubGFzdCkgfHwgc3RhcnQuY2xvbmUoKTtcblxuICAgICAgICBpZiAoIW9wdGlvbnMucnVsZUl0ZXJhdG9ycykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignLnJ1bGVJdGVyYXRvcnMgb3IgLmNvbXBvbmVudCBtdXN0IGJlIGdpdmVuJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJ1bGVJdGVyYXRvcnMgPSBvcHRpb25zLnJ1bGVJdGVyYXRvcnMubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gSUNBTC5oZWxwZXJzLmZvcm1hdENsYXNzVHlwZShpdGVtLCBJQ0FMLlJlY3VySXRlcmF0b3IpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnJ1bGVEYXRlSW5jID0gb3B0aW9ucy5ydWxlRGF0ZUluYztcbiAgICAgICAgdGhpcy5leERhdGVJbmMgPSBvcHRpb25zLmV4RGF0ZUluYztcblxuICAgICAgICBpZiAob3B0aW9ucy5ydWxlRGF0ZXMpIHtcbiAgICAgICAgICB0aGlzLnJ1bGVEYXRlcyA9IG9wdGlvbnMucnVsZURhdGVzLm1hcChmb3JtYXRUaW1lKTtcbiAgICAgICAgICB0aGlzLnJ1bGVEYXRlID0gdGhpcy5ydWxlRGF0ZXNbdGhpcy5ydWxlRGF0ZUluY107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5leERhdGVzKSB7XG4gICAgICAgICAgdGhpcy5leERhdGVzID0gb3B0aW9ucy5leERhdGVzLm1hcChmb3JtYXRUaW1lKTtcbiAgICAgICAgICB0aGlzLmV4RGF0ZSA9IHRoaXMuZXhEYXRlc1t0aGlzLmV4RGF0ZUluY107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mKG9wdGlvbnMuY29tcGxldGUpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUgPSBvcHRpb25zLmNvbXBsZXRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBuZXh0IG9jY3VycmVuY2UgaW4gdGhlIHNlcmllcy5cbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlRpbWV9XG4gICAgICovXG4gICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaXRlcjtcbiAgICAgIHZhciBydWxlT2ZEYXk7XG4gICAgICB2YXIgbmV4dDtcbiAgICAgIHZhciBjb21wYXJlO1xuXG4gICAgICB2YXIgbWF4VHJpZXMgPSA1MDA7XG4gICAgICB2YXIgY3VycmVudFRyeSA9IDA7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmIChjdXJyZW50VHJ5KysgPiBtYXhUcmllcykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdtYXggdHJpZXMgaGF2ZSBvY2N1cmVkLCBydWxlIG1heSBiZSBpbXBvc3NpYmxlIHRvIGZvcmZpbGwuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0ID0gdGhpcy5ydWxlRGF0ZTtcbiAgICAgICAgaXRlciA9IHRoaXMuX25leHRSZWN1cnJlbmNlSXRlcih0aGlzLmxhc3QpO1xuXG4gICAgICAgIC8vIG5vIG1vcmUgbWF0Y2hlc1xuICAgICAgICAvLyBiZWNhdXNlIHdlIGluY3JlbWVudCB0aGUgcnVsZSBkYXkgb3IgcnVsZVxuICAgICAgICAvLyBfYWZ0ZXJfIHdlIGNob29zZSBhIHZhbHVlIHRoaXMgc2hvdWxkIGJlXG4gICAgICAgIC8vIHRoZSBvbmx5IHNwb3Qgd2hlcmUgd2UgbmVlZCB0byB3b3JyeSBhYm91dCB0aGVcbiAgICAgICAgLy8gZW5kIG9mIGV2ZW50cy5cbiAgICAgICAgaWYgKCFuZXh0ICYmICFpdGVyKSB7XG4gICAgICAgICAgLy8gdGhlcmUgYXJlIG5vIG1vcmUgaXRlcmF0b3JzIG9yIHJkYXRlc1xuICAgICAgICAgIHRoaXMuY29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm8gbmV4dCBydWxlIGRheSBvciByZWN1cnJlbmNlIHJ1bGUgaXMgZmlyc3QuXG4gICAgICAgIGlmICghbmV4dCB8fCAoaXRlciAmJiBuZXh0LmNvbXBhcmUoaXRlci5sYXN0KSA+IDApKSB7XG4gICAgICAgICAgLy8gbXVzdCBiZSBjbG9uZWQsIHJlY3VyIHdpbGwgcmV1c2UgdGhlIHRpbWUgZWxlbWVudC5cbiAgICAgICAgICBuZXh0ID0gaXRlci5sYXN0LmNsb25lKCk7XG4gICAgICAgICAgLy8gbW92ZSB0byBuZXh0IHNvIHdlIGNhbiBjb250aW51ZVxuICAgICAgICAgIGl0ZXIubmV4dCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlIHJ1bGVEYXRlIGlzIHN0aWxsIG5leHQgaW5jcmVtZW50IGl0LlxuICAgICAgICBpZiAodGhpcy5ydWxlRGF0ZSA9PT0gbmV4dCkge1xuICAgICAgICAgIHRoaXMuX25leHRSdWxlRGF5KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxhc3QgPSBuZXh0O1xuXG4gICAgICAgIC8vIGNoZWNrIHRoZSBuZWdhdGl2ZSBydWxlc1xuICAgICAgICBpZiAodGhpcy5leERhdGUpIHtcbiAgICAgICAgICBjb21wYXJlID0gdGhpcy5leERhdGUuY29tcGFyZSh0aGlzLmxhc3QpO1xuXG4gICAgICAgICAgaWYgKGNvbXBhcmUgPCAwKSB7XG4gICAgICAgICAgICB0aGlzLl9uZXh0RXhEYXkoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBpZiB0aGUgY3VycmVudCBydWxlIGlzIGV4Y2x1ZGVkIHNraXAgaXQuXG4gICAgICAgICAgaWYgKGNvbXBhcmUgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX25leHRFeERheSgpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9YWFg6IFRoZSBzcGVjIHN0YXRlcyB0aGF0IGFmdGVyIHdlIHJlc29sdmUgdGhlIGZpbmFsXG4gICAgICAgIC8vICAgICBsaXN0IG9mIGRhdGVzIHdlIGV4ZWN1dGUgZXhkYXRlIHRoaXMgc2VlbXMgc29tZXdoYXQgY291bnRlclxuICAgICAgICAvLyAgICAgaW50dWl0aXZlIHRvIHdoYXQgSSBoYXZlIHNlZW4gbW9zdCBzZXJ2ZXJzIGRvIHNvIGZvciBub3dcbiAgICAgICAgLy8gICAgIEkgZXhjbHVkZSBiYXNlZCBvbiB0aGUgb3JpZ2luYWwgZGF0ZSBub3QgdGhlIG9uZSB0aGF0IG1heVxuICAgICAgICAvLyAgICAgaGF2ZSBiZWVuIG1vZGlmaWVkIGJ5IHRoZSBleGNlcHRpb24uXG4gICAgICAgIHJldHVybiB0aGlzLmxhc3Q7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIG9iamVjdCBpbnRvIGEgc2VyaWFsaXplLWFibGUgZm9ybWF0LiBUaGlzIGZvcm1hdCBjYW4gYmUgcGFzc2VkXG4gICAgICogYmFjayBpbnRvIHRoZSBleHBhbnNpb24gdG8gcmVzdW1lIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmN0aW9uIHRvSlNPTihpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtLnRvSlNPTigpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHJlc3VsdC5ydWxlSXRlcmF0b3JzID0gdGhpcy5ydWxlSXRlcmF0b3JzLm1hcCh0b0pTT04pO1xuXG4gICAgICBpZiAodGhpcy5ydWxlRGF0ZXMpIHtcbiAgICAgICAgcmVzdWx0LnJ1bGVEYXRlcyA9IHRoaXMucnVsZURhdGVzLm1hcCh0b0pTT04pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5leERhdGVzKSB7XG4gICAgICAgIHJlc3VsdC5leERhdGVzID0gdGhpcy5leERhdGVzLm1hcCh0b0pTT04pO1xuICAgICAgfVxuXG4gICAgICByZXN1bHQucnVsZURhdGVJbmMgPSB0aGlzLnJ1bGVEYXRlSW5jO1xuICAgICAgcmVzdWx0LmV4RGF0ZUluYyA9IHRoaXMuZXhEYXRlSW5jO1xuICAgICAgcmVzdWx0Lmxhc3QgPSB0aGlzLmxhc3QudG9KU09OKCk7XG4gICAgICByZXN1bHQuZHRzdGFydCA9IHRoaXMuZHRzdGFydC50b0pTT04oKTtcbiAgICAgIHJlc3VsdC5jb21wbGV0ZSA9IHRoaXMuY29tcGxldGU7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3QgYWxsIGRhdGVzIGZyb20gdGhlIHByb3BlcnRpZXMgaW4gdGhlIGdpdmVuIGNvbXBvbmVudC4gVGhlXG4gICAgICogcHJvcGVydGllcyB3aWxsIGJlIGZpbHRlcmVkIGJ5IHRoZSBwcm9wZXJ0eSBuYW1lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0lDQUwuQ29tcG9uZW50fSBjb21wb25lbnQgICAgICAgIFRoZSBjb21wb25lbnQgdG8gc2VhcmNoIGluXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5TmFtZSAgICAgICAgICAgICBUaGUgcHJvcGVydHkgbmFtZSB0byBzZWFyY2ggZm9yXG4gICAgICogQHJldHVybiB7SUNBTC5UaW1lW119ICAgICAgICAgICAgICAgICAgICBUaGUgZXh0cmFjdGVkIGRhdGVzLlxuICAgICAqL1xuICAgIF9leHRyYWN0RGF0ZXM6IGZ1bmN0aW9uKGNvbXBvbmVudCwgcHJvcGVydHlOYW1lKSB7XG4gICAgICBmdW5jdGlvbiBoYW5kbGVQcm9wKHByb3ApIHtcbiAgICAgICAgaWR4ID0gSUNBTC5oZWxwZXJzLmJpbnNlYXJjaEluc2VydChcbiAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgcHJvcCxcbiAgICAgICAgICBjb21wYXJlVGltZVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIG9yZGVyZWQgaW5zZXJ0XG4gICAgICAgIHJlc3VsdC5zcGxpY2UoaWR4LCAwLCBwcm9wKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgdmFyIHByb3BzID0gY29tcG9uZW50LmdldEFsbFByb3BlcnRpZXMocHJvcGVydHlOYW1lKTtcbiAgICAgIHZhciBsZW4gPSBwcm9wcy5sZW5ndGg7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgcHJvcDtcblxuICAgICAgdmFyIGlkeDtcblxuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBwcm9wc1tpXS5nZXRWYWx1ZXMoKS5mb3JFYWNoKGhhbmRsZVByb3ApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHRoZSByZWN1cnJlbmNlIGV4cGFuc2lvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtJQ0FMLkNvbXBvbmVudH0gY29tcG9uZW50ICAgIFRoZSBjb21wb25lbnQgdG8gaW5pdGlhbGl6ZSBmcm9tLlxuICAgICAqL1xuICAgIF9pbml0OiBmdW5jdGlvbihjb21wb25lbnQpIHtcbiAgICAgIHRoaXMucnVsZUl0ZXJhdG9ycyA9IFtdO1xuXG4gICAgICB0aGlzLmxhc3QgPSB0aGlzLmR0c3RhcnQuY2xvbmUoKTtcblxuICAgICAgLy8gdG8gcHJvdmlkZSBhcGkgY29uc2lzdGVuY3kgbm9uLXJlY3VycmluZ1xuICAgICAgLy8gZXZlbnRzIGNhbiBhbHNvIHVzZSB0aGUgaXRlcmF0b3IgdGhvdWdoIGl0IHdpbGxcbiAgICAgIC8vIG9ubHkgcmV0dXJuIGEgc2luZ2xlIHRpbWUuXG4gICAgICBpZiAoIWlzUmVjdXJyaW5nQ29tcG9uZW50KGNvbXBvbmVudCkpIHtcbiAgICAgICAgdGhpcy5ydWxlRGF0ZSA9IHRoaXMubGFzdC5jbG9uZSgpO1xuICAgICAgICB0aGlzLmNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29tcG9uZW50Lmhhc1Byb3BlcnR5KCdyZGF0ZScpKSB7XG4gICAgICAgIHRoaXMucnVsZURhdGVzID0gdGhpcy5fZXh0cmFjdERhdGVzKGNvbXBvbmVudCwgJ3JkYXRlJyk7XG5cbiAgICAgICAgLy8gc3BlY2lhbCBoYWNrIGZvciBjYXNlcyB3aGVyZSBmaXJzdCByZGF0ZSBpcyBwcmlvclxuICAgICAgICAvLyB0byB0aGUgc3RhcnQgZGF0ZS4gV2Ugb25seSBjaGVjayBmb3IgdGhlIGZpcnN0IHJkYXRlLlxuICAgICAgICAvLyBUaGlzIGlzIG1vc3RseSBmb3IgZ29vZ2xlJ3MgY3JhenkgcmVjdXJyaW5nIGRhdGUgbG9naWNcbiAgICAgICAgLy8gKGNvbnRhY3RzIGJpcnRoZGF5cykuXG4gICAgICAgIGlmICgodGhpcy5ydWxlRGF0ZXNbMF0pICYmXG4gICAgICAgICAgICAodGhpcy5ydWxlRGF0ZXNbMF0uY29tcGFyZSh0aGlzLmR0c3RhcnQpIDwgMCkpIHtcblxuICAgICAgICAgIHRoaXMucnVsZURhdGVJbmMgPSAwO1xuICAgICAgICAgIHRoaXMubGFzdCA9IHRoaXMucnVsZURhdGVzWzBdLmNsb25lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5ydWxlRGF0ZUluYyA9IElDQUwuaGVscGVycy5iaW5zZWFyY2hJbnNlcnQoXG4gICAgICAgICAgICB0aGlzLnJ1bGVEYXRlcyxcbiAgICAgICAgICAgIHRoaXMubGFzdCxcbiAgICAgICAgICAgIGNvbXBhcmVUaW1lXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucnVsZURhdGUgPSB0aGlzLnJ1bGVEYXRlc1t0aGlzLnJ1bGVEYXRlSW5jXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbXBvbmVudC5oYXNQcm9wZXJ0eSgncnJ1bGUnKSkge1xuICAgICAgICB2YXIgcnVsZXMgPSBjb21wb25lbnQuZ2V0QWxsUHJvcGVydGllcygncnJ1bGUnKTtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGVuID0gcnVsZXMubGVuZ3RoO1xuXG4gICAgICAgIHZhciBydWxlO1xuICAgICAgICB2YXIgaXRlcjtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgcnVsZSA9IHJ1bGVzW2ldLmdldEZpcnN0VmFsdWUoKTtcbiAgICAgICAgICBpdGVyID0gcnVsZS5pdGVyYXRvcih0aGlzLmR0c3RhcnQpO1xuICAgICAgICAgIHRoaXMucnVsZUl0ZXJhdG9ycy5wdXNoKGl0ZXIpO1xuXG4gICAgICAgICAgLy8gaW5jcmVtZW50IHRvIHRoZSBuZXh0IG9jY3VycmVuY2Ugc28gZnV0dXJlXG4gICAgICAgICAgLy8gY2FsbHMgdG8gbmV4dCByZXR1cm4gdGltZXMgYmV5b25kIHRoZSBpbml0aWFsIGl0ZXJhdGlvbi5cbiAgICAgICAgICAvLyBYWFg6IEkgZmluZCB0aGlzIHN1c3BpY2lvdXMgbWlnaHQgYmUgYSBidWc/XG4gICAgICAgICAgaXRlci5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNvbXBvbmVudC5oYXNQcm9wZXJ0eSgnZXhkYXRlJykpIHtcbiAgICAgICAgdGhpcy5leERhdGVzID0gdGhpcy5fZXh0cmFjdERhdGVzKGNvbXBvbmVudCwgJ2V4ZGF0ZScpO1xuICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgLmxhc3QgZGF5IHdlIGluY3JlbWVudCB0aGUgaW5kZXggdG8gYmV5b25kIGl0LlxuICAgICAgICB0aGlzLmV4RGF0ZUluYyA9IElDQUwuaGVscGVycy5iaW5zZWFyY2hJbnNlcnQoXG4gICAgICAgICAgdGhpcy5leERhdGVzLFxuICAgICAgICAgIHRoaXMubGFzdCxcbiAgICAgICAgICBjb21wYXJlVGltZVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuZXhEYXRlID0gdGhpcy5leERhdGVzW3RoaXMuZXhEYXRlSW5jXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWR2YW5jZSB0byB0aGUgbmV4dCBleGRhdGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9uZXh0RXhEYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5leERhdGUgPSB0aGlzLmV4RGF0ZXNbKyt0aGlzLmV4RGF0ZUluY107XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkdmFuY2UgdG8gdGhlIG5leHQgcnVsZSBkYXRlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbmV4dFJ1bGVEYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5ydWxlRGF0ZSA9IHRoaXMucnVsZURhdGVzWysrdGhpcy5ydWxlRGF0ZUluY107XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgYW5kIHJldHVybiB0aGUgcmVjdXJyZW5jZSBydWxlIHdpdGggdGhlIG1vc3QgcmVjZW50IGV2ZW50IGFuZFxuICAgICAqIHJldHVybiBpdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7P0lDQUwuUmVjdXJJdGVyYXRvcn0gICAgRm91bmQgaXRlcmF0b3IuXG4gICAgICovXG4gICAgX25leHRSZWN1cnJlbmNlSXRlcjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaXRlcnMgPSB0aGlzLnJ1bGVJdGVyYXRvcnM7XG5cbiAgICAgIGlmIChpdGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZW4gPSBpdGVycy5sZW5ndGg7XG4gICAgICB2YXIgaXRlcjtcbiAgICAgIHZhciBpdGVyVGltZTtcbiAgICAgIHZhciBpdGVySWR4ID0gMDtcbiAgICAgIHZhciBjaG9zZW5JdGVyO1xuXG4gICAgICAvLyBsb29wIHRocm91Z2ggZWFjaCBpdGVyYXRvclxuICAgICAgZm9yICg7IGl0ZXJJZHggPCBsZW47IGl0ZXJJZHgrKykge1xuICAgICAgICBpdGVyID0gaXRlcnNbaXRlcklkeF07XG4gICAgICAgIGl0ZXJUaW1lID0gaXRlci5sYXN0O1xuXG4gICAgICAgIC8vIGlmIGl0ZXJhdGlvbiBpcyBjb21wbGV0ZVxuICAgICAgICAvLyB0aGVuIHdlIG11c3QgZXhjbHVkZSBpdCBmcm9tXG4gICAgICAgIC8vIHRoZSBzZWFyY2ggYW5kIHJlbW92ZSBpdC5cbiAgICAgICAgaWYgKGl0ZXIuY29tcGxldGVkKSB7XG4gICAgICAgICAgbGVuLS07XG4gICAgICAgICAgaWYgKGl0ZXJJZHggIT09IDApIHtcbiAgICAgICAgICAgIGl0ZXJJZHgtLTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaXRlcnMuc3BsaWNlKGl0ZXJJZHgsIDEpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluZCB0aGUgbW9zdCByZWNlbnQgcG9zc2libGUgY2hvaWNlXG4gICAgICAgIGlmICghY2hvc2VuSXRlciB8fCBjaG9zZW5JdGVyLmxhc3QuY29tcGFyZShpdGVyVGltZSkgPiAwKSB7XG4gICAgICAgICAgLy8gdGhhdCBpdGVyYXRvciBpcyBzYXZlZFxuICAgICAgICAgIGNob3Nlbkl0ZXIgPSBpdGVyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHRoZSBjaG9zZW4gaXRlcmF0b3IgaXMgcmV0dXJuZWQgYnV0IG5vdCBtdXRhdGVkXG4gICAgICAvLyB0aGlzIGl0ZXJhdG9yIGNvbnRhaW5zIHRoZSBtb3N0IHJlY2VudCBldmVudC5cbiAgICAgIHJldHVybiBjaG9zZW5JdGVyO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gUmVjdXJFeHBhbnNpb247XG59KCkpO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoLCAyMDExLTIwMTUgKi9cblxuXG4vKipcbiAqIFRoaXMgc3ltYm9sIGlzIGZ1cnRoZXIgZGVzY3JpYmVkIGxhdGVyIG9uXG4gKiBAaWdub3JlXG4gKi9cbklDQUwuRXZlbnQgPSAoZnVuY3Rpb24oKSB7XG5cbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogSUNBTC5qcyBpcyBvcmdhbml6ZWQgaW50byBtdWx0aXBsZSBsYXllcnMuIFRoZSBib3R0b20gbGF5ZXIgaXMgYSByYXcgakNhbFxuICAgKiBvYmplY3QsIGZvbGxvd2VkIGJ5IHRoZSBjb21wb25lbnQvcHJvcGVydHkgbGF5ZXIuIFRoZSBoaWdoZXN0IGxldmVsIGlzIHRoZVxuICAgKiBldmVudCByZXByZXNlbnRhdGlvbiwgd2hpY2ggdGhpcyBjbGFzcyBpcyBwYXJ0IG9mLiBTZWUgdGhlXG4gICAqIHtAdHV0b3JpYWwgbGF5ZXJzfSBndWlkZSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQGFsaWFzIElDQUwuRXZlbnRcbiAgICogQHBhcmFtIHtJQ0FMLkNvbXBvbmVudD19IGNvbXBvbmVudCAgICAgICAgIFRoZSBJQ0FMLkNvbXBvbmVudCB0byBiYXNlIHRoaXMgZXZlbnQgb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgICAgICAgICAgICAgICAgICAgIE9wdGlvbnMgZm9yIHRoaXMgZXZlbnRcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLnN0cmljdEV4Y2VwdGlvbnNcbiAgICogICAgICAgICAgV2hlbiB0cnVlLCB3aWxsIHZlcmlmeSBleGNlcHRpb25zIGFyZSByZWxhdGVkIGJ5IHRoZWlyIFVVSURcbiAgICogQHBhcmFtIHtBcnJheTxJQ0FMLkNvbXBvbmVudHxJQ0FMLkV2ZW50Pn0gb3B0aW9ucy5leGNlcHRpb25zXG4gICAqICAgICAgICAgIEV4Y2VwdGlvbnMgdG8gdGhpcyBldmVudCwgZWl0aGVyIGFzIGNvbXBvbmVudHMgb3IgZXZlbnRzLiBJZiBub3RcbiAgICogICAgICAgICAgICBzcGVjaWZpZWQgZXhjZXB0aW9ucyB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgc2V0IGluIHJlbGF0aW9uIG9mXG4gICAqICAgICAgICAgICAgY29tcG9uZW50J3MgcGFyZW50XG4gICAqL1xuICBmdW5jdGlvbiBFdmVudChjb21wb25lbnQsIG9wdGlvbnMpIHtcbiAgICBpZiAoIShjb21wb25lbnQgaW5zdGFuY2VvZiBJQ0FMLkNvbXBvbmVudCkpIHtcbiAgICAgIG9wdGlvbnMgPSBjb21wb25lbnQ7XG4gICAgICBjb21wb25lbnQgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbXBvbmVudCA9IG5ldyBJQ0FMLkNvbXBvbmVudCgndmV2ZW50Jyk7XG4gICAgfVxuXG4gICAgdGhpcy5fcmFuZ2VFeGNlcHRpb25DYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5leGNlcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLnJhbmdlRXhjZXB0aW9ucyA9IFtdO1xuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zdHJpY3RFeGNlcHRpb25zKSB7XG4gICAgICB0aGlzLnN0cmljdEV4Y2VwdGlvbnMgPSBvcHRpb25zLnN0cmljdEV4Y2VwdGlvbnM7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5leGNlcHRpb25zKSB7XG4gICAgICBvcHRpb25zLmV4Y2VwdGlvbnMuZm9yRWFjaCh0aGlzLnJlbGF0ZUV4Y2VwdGlvbiwgdGhpcyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmNvbXBvbmVudC5wYXJlbnQgJiYgIXRoaXMuaXNSZWN1cnJlbmNlRXhjZXB0aW9uKCkpIHtcbiAgICAgIHRoaXMuY29tcG9uZW50LnBhcmVudC5nZXRBbGxTdWJjb21wb25lbnRzKCd2ZXZlbnQnKS5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5oYXNQcm9wZXJ0eSgncmVjdXJyZW5jZS1pZCcpKSB7XG4gICAgICAgICAgdGhpcy5yZWxhdGVFeGNlcHRpb24oZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG4gIH1cblxuICBFdmVudC5wcm90b3R5cGUgPSB7XG5cbiAgICBUSElTQU5ERlVUVVJFOiAnVEhJU0FOREZVVFVSRScsXG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIHJlbGF0ZWQgZXZlbnQgZXhjZXB0aW9ucy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtJQ0FMLkV2ZW50W119XG4gICAgICovXG4gICAgZXhjZXB0aW9uczogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgd2lsbCB2ZXJpZnkgZXhjZXB0aW9ucyBhcmUgcmVsYXRlZCBieSB0aGVpciBVVUlELlxuICAgICAqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3RyaWN0RXhjZXB0aW9uczogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBSZWxhdGVzIGEgZ2l2ZW4gZXZlbnQgZXhjZXB0aW9uIHRvIHRoaXMgb2JqZWN0LiAgSWYgdGhlIGdpdmVuIGNvbXBvbmVudFxuICAgICAqIGRvZXMgbm90IHNoYXJlIHRoZSBVSUQgb2YgdGhpcyBldmVudCBpdCBjYW5ub3QgYmUgcmVsYXRlZCBhbmQgd2lsbCB0aHJvd1xuICAgICAqIGFuIGV4Y2VwdGlvbi5cbiAgICAgKlxuICAgICAqIElmIHRoaXMgY29tcG9uZW50IGlzIGFuIGV4Y2VwdGlvbiBpdCBjYW5ub3QgaGF2ZSBvdGhlciBleGNlcHRpb25zXG4gICAgICogcmVsYXRlZCB0byBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SUNBTC5Db21wb25lbnR8SUNBTC5FdmVudH0gb2JqICAgICAgIENvbXBvbmVudCBvciBldmVudFxuICAgICAqL1xuICAgIHJlbGF0ZUV4Y2VwdGlvbjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICBpZiAodGhpcy5pc1JlY3VycmVuY2VFeGNlcHRpb24oKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCByZWxhdGUgZXhjZXB0aW9uIHRvIGV4Y2VwdGlvbnMnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIElDQUwuQ29tcG9uZW50KSB7XG4gICAgICAgIG9iaiA9IG5ldyBJQ0FMLkV2ZW50KG9iaik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnN0cmljdEV4Y2VwdGlvbnMgJiYgb2JqLnVpZCAhPT0gdGhpcy51aWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhdHRlbXB0ZWQgdG8gcmVsYXRlIHVucmVsYXRlZCBleGNlcHRpb24nKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlkID0gb2JqLnJlY3VycmVuY2VJZC50b1N0cmluZygpO1xuXG4gICAgICAvLyB3ZSBkb24ndCBzb3J0IG9yIG1hbmFnZSBleGNlcHRpb25zIGRpcmVjdGx5XG4gICAgICAvLyBoZXJlIHRoZSByZWN1cnJlbmNlIGV4cGFuZGVyIGhhbmRsZXMgdGhhdC5cbiAgICAgIHRoaXMuZXhjZXB0aW9uc1tpZF0gPSBvYmo7XG5cbiAgICAgIC8vIGluZGV4IFJBTkdFPVRISVNBTkRGVVRVUkUgZXhjZXB0aW9ucyBzbyB3ZSBjYW5cbiAgICAgIC8vIGxvb2sgdGhlbSB1cCBsYXRlciBpbiBnZXRPY2N1cnJlbmNlRGV0YWlscy5cbiAgICAgIGlmIChvYmoubW9kaWZpZXNGdXR1cmUoKSkge1xuICAgICAgICB2YXIgaXRlbSA9IFtcbiAgICAgICAgICBvYmoucmVjdXJyZW5jZUlkLnRvVW5peFRpbWUoKSwgaWRcbiAgICAgICAgXTtcblxuICAgICAgICAvLyB3ZSBrZWVwIHRoZW0gc29ydGVkIHNvIHdlIGNhbiBmaW5kIHRoZSBuZWFyZXN0XG4gICAgICAgIC8vIHZhbHVlIGxhdGVyIG9uLi4uXG4gICAgICAgIHZhciBpZHggPSBJQ0FMLmhlbHBlcnMuYmluc2VhcmNoSW5zZXJ0KFxuICAgICAgICAgIHRoaXMucmFuZ2VFeGNlcHRpb25zLFxuICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgY29tcGFyZVJhbmdlRXhjZXB0aW9uXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5yYW5nZUV4Y2VwdGlvbnMuc3BsaWNlKGlkeCwgMCwgaXRlbSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGlzIHJlY29yZCBpcyBhbiBleGNlcHRpb24gYW5kIGhhcyB0aGUgUkFOR0U9VEhJU0FOREZVVFVSRVxuICAgICAqIHZhbHVlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgIFRydWUsIHdoZW4gZXhjZXB0aW9uIGlzIHdpdGhpbiByYW5nZVxuICAgICAqL1xuICAgIG1vZGlmaWVzRnV0dXJlOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5jb21wb25lbnQuaGFzUHJvcGVydHkoJ3JlY3VycmVuY2UtaWQnKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciByYW5nZSA9IHRoaXMuY29tcG9uZW50LmdldEZpcnN0UHJvcGVydHkoJ3JlY3VycmVuY2UtaWQnKS5nZXRQYXJhbWV0ZXIoJ3JhbmdlJyk7XG4gICAgICByZXR1cm4gcmFuZ2UgPT09IHRoaXMuVEhJU0FOREZVVFVSRTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIHJhbmdlIGV4Y2VwdGlvbiBuZWFyZXN0IHRvIHRoZSBnaXZlbiBkYXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWV9IHRpbWUgdXN1YWxseSBhbiBvY2N1cnJlbmNlIHRpbWUgb2YgYW4gZXZlbnRcbiAgICAgKiBAcmV0dXJuIHs/SUNBTC5FdmVudH0gdGhlIHJlbGF0ZWQgZXZlbnQvZXhjZXB0aW9uIG9yIG51bGxcbiAgICAgKi9cbiAgICBmaW5kUmFuZ2VFeGNlcHRpb246IGZ1bmN0aW9uKHRpbWUpIHtcbiAgICAgIGlmICghdGhpcy5yYW5nZUV4Y2VwdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgdXRjID0gdGltZS50b1VuaXhUaW1lKCk7XG4gICAgICB2YXIgaWR4ID0gSUNBTC5oZWxwZXJzLmJpbnNlYXJjaEluc2VydChcbiAgICAgICAgdGhpcy5yYW5nZUV4Y2VwdGlvbnMsXG4gICAgICAgIFt1dGNdLFxuICAgICAgICBjb21wYXJlUmFuZ2VFeGNlcHRpb25cbiAgICAgICk7XG5cbiAgICAgIGlkeCAtPSAxO1xuXG4gICAgICAvLyBvY2N1cnMgYmVmb3JlXG4gICAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJhbmdlSXRlbSA9IHRoaXMucmFuZ2VFeGNlcHRpb25zW2lkeF07XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBzYW5pdHkgY2hlY2sgb25seSAqL1xuICAgICAgaWYgKHV0YyA8IHJhbmdlSXRlbVswXSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJhbmdlSXRlbVsxXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBvYmplY3QgaXMgcmV0dXJuZWQgYnkge0BsaW5rIElDQUwuRXZlbnQjZ2V0T2NjdXJyZW5jZURldGFpbHMgZ2V0T2NjdXJyZW5jZURldGFpbHN9XG4gICAgICpcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBvY2N1cnJlbmNlRGV0YWlsc1xuICAgICAqIEBtZW1iZXJvZiBJQ0FMLkV2ZW50XG4gICAgICogQHByb3BlcnR5IHtJQ0FMLlRpbWV9IHJlY3VycmVuY2VJZCAgICAgICBUaGUgcGFzc2VkIGluIHJlY3VycmVuY2UgaWRcbiAgICAgKiBAcHJvcGVydHkge0lDQUwuRXZlbnR9IGl0ZW0gICAgICAgICAgICAgIFRoZSBvY2N1cnJlbmNlXG4gICAgICogQHByb3BlcnR5IHtJQ0FMLlRpbWV9IHN0YXJ0RGF0ZSAgICAgICAgICBUaGUgc3RhcnQgb2YgdGhlIG9jY3VycmVuY2VcbiAgICAgKiBAcHJvcGVydHkge0lDQUwuVGltZX0gZW5kRGF0ZSAgICAgICAgICAgIFRoZSBlbmQgb2YgdGhlIG9jY3VycmVuY2VcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG9jY3VycmVuY2UgZGV0YWlscyBiYXNlZCBvbiBpdHMgc3RhcnQgdGltZS4gIElmIHRoZVxuICAgICAqIG9jY3VycmVuY2UgaGFzIGFuIGV4Y2VwdGlvbiB3aWxsIHJldHVybiB0aGUgZGV0YWlscyBmb3IgdGhhdCBleGNlcHRpb24uXG4gICAgICpcbiAgICAgKiBOT1RFOiB0aGlzIG1ldGhvZCBpcyBpbnRlbmQgdG8gYmUgdXNlZCBpbiBjb25qdW5jdGlvblxuICAgICAqICAgICAgIHdpdGggdGhlIHtAbGluayBJQ0FMLkV2ZW50I2l0ZXJhdG9yIGl0ZXJhdG9yfSBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZX0gb2NjdXJyZW5jZSB0aW1lIG9jY3VycmVuY2VcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLkV2ZW50Lm9jY3VycmVuY2VEZXRhaWxzfSBJbmZvcm1hdGlvbiBhYm91dCB0aGUgb2NjdXJyZW5jZVxuICAgICAqL1xuICAgIGdldE9jY3VycmVuY2VEZXRhaWxzOiBmdW5jdGlvbihvY2N1cnJlbmNlKSB7XG4gICAgICB2YXIgaWQgPSBvY2N1cnJlbmNlLnRvU3RyaW5nKCk7XG4gICAgICB2YXIgdXRjSWQgPSBvY2N1cnJlbmNlLmNvbnZlcnRUb1pvbmUoSUNBTC5UaW1lem9uZS51dGNUaW1lem9uZSkudG9TdHJpbmcoKTtcbiAgICAgIHZhciBpdGVtO1xuICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgLy9YWFg6IENsb25lP1xuICAgICAgICByZWN1cnJlbmNlSWQ6IG9jY3VycmVuY2VcbiAgICAgIH07XG5cbiAgICAgIGlmIChpZCBpbiB0aGlzLmV4Y2VwdGlvbnMpIHtcbiAgICAgICAgaXRlbSA9IHJlc3VsdC5pdGVtID0gdGhpcy5leGNlcHRpb25zW2lkXTtcbiAgICAgICAgcmVzdWx0LnN0YXJ0RGF0ZSA9IGl0ZW0uc3RhcnREYXRlO1xuICAgICAgICByZXN1bHQuZW5kRGF0ZSA9IGl0ZW0uZW5kRGF0ZTtcbiAgICAgICAgcmVzdWx0Lml0ZW0gPSBpdGVtO1xuICAgICAgfSBlbHNlIGlmICh1dGNJZCBpbiB0aGlzLmV4Y2VwdGlvbnMpIHtcbiAgICAgICAgaXRlbSA9IHRoaXMuZXhjZXB0aW9uc1t1dGNJZF07XG4gICAgICAgIHJlc3VsdC5zdGFydERhdGUgPSBpdGVtLnN0YXJ0RGF0ZTtcbiAgICAgICAgcmVzdWx0LmVuZERhdGUgPSBpdGVtLmVuZERhdGU7XG4gICAgICAgIHJlc3VsdC5pdGVtID0gaXRlbTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJhbmdlIGV4Y2VwdGlvbnMgKFJBTkdFPVRISVNBTkRGVVRVUkUpIGhhdmUgYVxuICAgICAgICAvLyBsb3dlciBwcmlvcml0eSB0aGVuIGRpcmVjdCBleGNlcHRpb25zIGJ1dFxuICAgICAgICAvLyBtdXN0IGJlIGFjY291bnRlZCBmb3IgZmlyc3QuIFRoZWlyIGl0ZW0gaXNcbiAgICAgICAgLy8gYWx3YXlzIHRoZSBmaXJzdCBleGNlcHRpb24gd2l0aCB0aGUgcmFuZ2UgcHJvcC5cbiAgICAgICAgdmFyIHJhbmdlRXhjZXB0aW9uSWQgPSB0aGlzLmZpbmRSYW5nZUV4Y2VwdGlvbihcbiAgICAgICAgICBvY2N1cnJlbmNlXG4gICAgICAgICk7XG4gICAgICAgIHZhciBlbmQ7XG5cbiAgICAgICAgaWYgKHJhbmdlRXhjZXB0aW9uSWQpIHtcbiAgICAgICAgICB2YXIgZXhjZXB0aW9uID0gdGhpcy5leGNlcHRpb25zW3JhbmdlRXhjZXB0aW9uSWRdO1xuXG4gICAgICAgICAgLy8gcmFuZ2UgZXhjZXB0aW9uIG11c3QgbW9kaWZ5IHN0YW5kYXJkIHRpbWVcbiAgICAgICAgICAvLyBieSB0aGUgZGlmZmVyZW5jZSAoaWYgYW55KSBpbiBzdGFydC9lbmQgdGltZXMuXG4gICAgICAgICAgcmVzdWx0Lml0ZW0gPSBleGNlcHRpb247XG5cbiAgICAgICAgICB2YXIgc3RhcnREaWZmID0gdGhpcy5fcmFuZ2VFeGNlcHRpb25DYWNoZVtyYW5nZUV4Y2VwdGlvbklkXTtcblxuICAgICAgICAgIGlmICghc3RhcnREaWZmKSB7XG4gICAgICAgICAgICB2YXIgb3JpZ2luYWwgPSBleGNlcHRpb24ucmVjdXJyZW5jZUlkLmNsb25lKCk7XG4gICAgICAgICAgICB2YXIgbmV3U3RhcnQgPSBleGNlcHRpb24uc3RhcnREYXRlLmNsb25lKCk7XG5cbiAgICAgICAgICAgIC8vIHpvbmVzIG11c3QgYmUgc2FtZSBvdGhlcndpc2Ugc3VidHJhY3QgbWF5IGJlIGluY29ycmVjdC5cbiAgICAgICAgICAgIG9yaWdpbmFsLnpvbmUgPSBuZXdTdGFydC56b25lO1xuICAgICAgICAgICAgc3RhcnREaWZmID0gbmV3U3RhcnQuc3VidHJhY3REYXRlKG9yaWdpbmFsKTtcblxuICAgICAgICAgICAgdGhpcy5fcmFuZ2VFeGNlcHRpb25DYWNoZVtyYW5nZUV4Y2VwdGlvbklkXSA9IHN0YXJ0RGlmZjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc3RhcnQgPSBvY2N1cnJlbmNlLmNsb25lKCk7XG4gICAgICAgICAgc3RhcnQuem9uZSA9IGV4Y2VwdGlvbi5zdGFydERhdGUuem9uZTtcbiAgICAgICAgICBzdGFydC5hZGREdXJhdGlvbihzdGFydERpZmYpO1xuXG4gICAgICAgICAgZW5kID0gc3RhcnQuY2xvbmUoKTtcbiAgICAgICAgICBlbmQuYWRkRHVyYXRpb24oZXhjZXB0aW9uLmR1cmF0aW9uKTtcblxuICAgICAgICAgIHJlc3VsdC5zdGFydERhdGUgPSBzdGFydDtcbiAgICAgICAgICByZXN1bHQuZW5kRGF0ZSA9IGVuZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBubyByYW5nZSBleGNlcHRpb24gc3RhbmRhcmQgZXhwYW5zaW9uXG4gICAgICAgICAgZW5kID0gb2NjdXJyZW5jZS5jbG9uZSgpO1xuICAgICAgICAgIGVuZC5hZGREdXJhdGlvbih0aGlzLmR1cmF0aW9uKTtcblxuICAgICAgICAgIHJlc3VsdC5lbmREYXRlID0gZW5kO1xuICAgICAgICAgIHJlc3VsdC5zdGFydERhdGUgPSBvY2N1cnJlbmNlO1xuICAgICAgICAgIHJlc3VsdC5pdGVtID0gdGhpcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgYSByZWN1ciBleHBhbnNpb24gaW5zdGFuY2UgZm9yIGEgc3BlY2lmaWMgcG9pbnQgaW4gdGltZSAoZGVmYXVsdHNcbiAgICAgKiB0byBzdGFydERhdGUpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWV9IHN0YXJ0VGltZSAgICAgU3RhcnRpbmcgcG9pbnQgZm9yIGV4cGFuc2lvblxuICAgICAqIEByZXR1cm4ge0lDQUwuUmVjdXJFeHBhbnNpb259ICAgIEV4cGFuc2lvbiBvYmplY3RcbiAgICAgKi9cbiAgICBpdGVyYXRvcjogZnVuY3Rpb24oc3RhcnRUaW1lKSB7XG4gICAgICByZXR1cm4gbmV3IElDQUwuUmVjdXJFeHBhbnNpb24oe1xuICAgICAgICBjb21wb25lbnQ6IHRoaXMuY29tcG9uZW50LFxuICAgICAgICBkdHN0YXJ0OiBzdGFydFRpbWUgfHwgdGhpcy5zdGFydERhdGVcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGV2ZW50IGlzIHJlY3VycmluZ1xuICAgICAqXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgIFRydWUsIGlmIGV2ZW50IGlzIHJlY3VycmluZ1xuICAgICAqL1xuICAgIGlzUmVjdXJyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjb21wID0gdGhpcy5jb21wb25lbnQ7XG4gICAgICByZXR1cm4gY29tcC5oYXNQcm9wZXJ0eSgncnJ1bGUnKSB8fCBjb21wLmhhc1Byb3BlcnR5KCdyZGF0ZScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGV2ZW50IGRlc2NyaWJlcyBhIHJlY3VycmVuY2UgZXhjZXB0aW9uLiBTZWVcbiAgICAgKiB7QHR1dG9yaWFsIHRlcm1pbm9sb2d5fSBmb3IgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgIFRydWUsIGlmIHRoZSBldmVudCBkZXNjcmliZXMgYSByZWN1cnJlbmNlIGV4Y2VwdGlvblxuICAgICAqL1xuICAgIGlzUmVjdXJyZW5jZUV4Y2VwdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21wb25lbnQuaGFzUHJvcGVydHkoJ3JlY3VycmVuY2UtaWQnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdHlwZXMgb2YgcmVjdXJyZW5jZXMgdGhpcyBldmVudCBtYXkgaGF2ZS5cbiAgICAgKlxuICAgICAqIFJldHVybmVkIGFzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcG9zc2libGUga2V5czpcbiAgICAgKlxuICAgICAqICAgIC0gWUVBUkxZXG4gICAgICogICAgLSBNT05USExZXG4gICAgICogICAgLSBXRUVLTFlcbiAgICAgKiAgICAtIERBSUxZXG4gICAgICogICAgLSBNSU5VVEVMWVxuICAgICAqICAgIC0gU0VDT05ETFlcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge09iamVjdC48SUNBTC5SZWN1ci5mcmVxdWVuY3lWYWx1ZXMsIEJvb2xlYW4+fVxuICAgICAqICAgICAgICAgIE9iamVjdCBvZiByZWN1cnJlbmNlIGZsYWdzXG4gICAgICovXG4gICAgZ2V0UmVjdXJyZW5jZVR5cGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBydWxlcyA9IHRoaXMuY29tcG9uZW50LmdldEFsbFByb3BlcnRpZXMoJ3JydWxlJyk7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgbGVuID0gcnVsZXMubGVuZ3RoO1xuICAgICAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcnVsZXNbaV0uZ2V0Rmlyc3RWYWx1ZSgpO1xuICAgICAgICByZXN1bHRbdmFsdWUuZnJlcV0gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdWlkIG9mIHRoaXMgZXZlbnRcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldCB1aWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmlyc3RQcm9wKCd1aWQnKTtcbiAgICB9LFxuXG4gICAgc2V0IHVpZCh2YWx1ZSkge1xuICAgICAgdGhpcy5fc2V0UHJvcCgndWlkJywgdmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RhcnQgZGF0ZVxuICAgICAqIEB0eXBlIHtJQ0FMLlRpbWV9XG4gICAgICovXG4gICAgZ2V0IHN0YXJ0RGF0ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9maXJzdFByb3AoJ2R0c3RhcnQnKTtcbiAgICB9LFxuXG4gICAgc2V0IHN0YXJ0RGF0ZSh2YWx1ZSkge1xuICAgICAgdGhpcy5fc2V0VGltZSgnZHRzdGFydCcsIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVuZCBkYXRlLiBUaGlzIGNhbiBiZSB0aGUgcmVzdWx0IGRpcmVjdGx5IGZyb20gdGhlIHByb3BlcnR5LCBvciB0aGVcbiAgICAgKiBlbmQgZGF0ZSBjYWxjdWxhdGVkIGZyb20gc3RhcnQgZGF0ZSBhbmQgZHVyYXRpb24uIFNldHRpbmcgdGhlIHByb3BlcnR5XG4gICAgICogd2lsbCByZW1vdmUgYW55IGR1cmF0aW9uIHByb3BlcnRpZXMuXG4gICAgICogQHR5cGUge0lDQUwuVGltZX1cbiAgICAgKi9cbiAgICBnZXQgZW5kRGF0ZSgpIHtcbiAgICAgIHZhciBlbmREYXRlID0gdGhpcy5fZmlyc3RQcm9wKCdkdGVuZCcpO1xuICAgICAgaWYgKCFlbmREYXRlKSB7XG4gICAgICAgICAgdmFyIGR1cmF0aW9uID0gdGhpcy5fZmlyc3RQcm9wKCdkdXJhdGlvbicpO1xuICAgICAgICAgIGVuZERhdGUgPSB0aGlzLnN0YXJ0RGF0ZS5jbG9uZSgpO1xuICAgICAgICAgIGlmIChkdXJhdGlvbikge1xuICAgICAgICAgICAgICBlbmREYXRlLmFkZER1cmF0aW9uKGR1cmF0aW9uKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVuZERhdGUuaXNEYXRlKSB7XG4gICAgICAgICAgICAgIGVuZERhdGUuZGF5ICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGVuZERhdGU7XG4gICAgfSxcblxuICAgIHNldCBlbmREYXRlKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5jb21wb25lbnQuaGFzUHJvcGVydHkoJ2R1cmF0aW9uJykpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnQucmVtb3ZlUHJvcGVydHkoJ2R1cmF0aW9uJyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zZXRUaW1lKCdkdGVuZCcsIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGR1cmF0aW9uLiBUaGlzIGNhbiBiZSB0aGUgcmVzdWx0IGRpcmVjdGx5IGZyb20gdGhlIHByb3BlcnR5LCBvciB0aGVcbiAgICAgKiBkdXJhdGlvbiBjYWxjdWxhdGVkIGZyb20gc3RhcnQgZGF0ZSBhbmQgZW5kIGRhdGUuIFNldHRpbmcgdGhlIHByb3BlcnR5XG4gICAgICogd2lsbCByZW1vdmUgYW55IGBkdGVuZGAgcHJvcGVydGllcy5cbiAgICAgKiBAdHlwZSB7SUNBTC5EdXJhdGlvbn1cbiAgICAgKi9cbiAgICBnZXQgZHVyYXRpb24oKSB7XG4gICAgICB2YXIgZHVyYXRpb24gPSB0aGlzLl9maXJzdFByb3AoJ2R1cmF0aW9uJyk7XG4gICAgICBpZiAoIWR1cmF0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuZERhdGUuc3VidHJhY3REYXRlVHoodGhpcy5zdGFydERhdGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGR1cmF0aW9uO1xuICAgIH0sXG5cbiAgICBzZXQgZHVyYXRpb24odmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLmNvbXBvbmVudC5oYXNQcm9wZXJ0eSgnZHRlbmQnKSkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudC5yZW1vdmVQcm9wZXJ0eSgnZHRlbmQnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2V0UHJvcCgnZHVyYXRpb24nLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBsb2NhdGlvbiBvZiB0aGUgZXZlbnQuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgbG9jYXRpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmlyc3RQcm9wKCdsb2NhdGlvbicpO1xuICAgIH0sXG5cbiAgICBzZXQgbG9jYXRpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZXRQcm9wKCdsb2NhdGlvbicsIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGF0dGVuZGVlcyBpbiB0aGUgZXZlbnRcbiAgICAgKiBAdHlwZSB7SUNBTC5Qcm9wZXJ0eVtdfVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIGdldCBhdHRlbmRlZXMoKSB7XG4gICAgICAvL1hYWDogVGhpcyBpcyB3YXkgbGFtZSB3ZSBzaG91bGQgaGF2ZSBhIGJldHRlclxuICAgICAgLy8gICAgIGRhdGEgc3RydWN0dXJlIGZvciB0aGlzIGxhdGVyLlxuICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50LmdldEFsbFByb3BlcnRpZXMoJ2F0dGVuZGVlJyk7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogVGhlIGV2ZW50IHN1bW1hcnlcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBzdW1tYXJ5KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpcnN0UHJvcCgnc3VtbWFyeScpO1xuICAgIH0sXG5cbiAgICBzZXQgc3VtbWFyeSh2YWx1ZSkge1xuICAgICAgdGhpcy5fc2V0UHJvcCgnc3VtbWFyeScsIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGV2ZW50IGRlc2NyaXB0aW9uLlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpcnN0UHJvcCgnZGVzY3JpcHRpb24nKTtcbiAgICB9LFxuXG4gICAgc2V0IGRlc2NyaXB0aW9uKHZhbHVlKSB7XG4gICAgICB0aGlzLl9zZXRQcm9wKCdkZXNjcmlwdGlvbicsIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGV2ZW50IGNvbG9yIGZyb20gW3JmYzc5ODZdKGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNzk4NilcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBjb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9maXJzdFByb3AoJ2NvbG9yJyk7XG4gICAgfSxcblxuICAgIHNldCBjb2xvcih2YWx1ZSkge1xuICAgICAgdGhpcy5fc2V0UHJvcCgnY29sb3InLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcmdhbml6ZXIgdmFsdWUgYXMgYW4gdXJpLiBJbiBtb3N0IGNhc2VzIHRoaXMgaXMgYSBtYWlsdG86IHVyaSwgYnV0XG4gICAgICogaXQgY2FuIGFsc28gYmUgc29tZXRoaW5nIGVsc2UsIGxpa2UgdXJuOnV1aWQ6Li4uXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgb3JnYW5pemVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpcnN0UHJvcCgnb3JnYW5pemVyJyk7XG4gICAgfSxcblxuICAgIHNldCBvcmdhbml6ZXIodmFsdWUpIHtcbiAgICAgIHRoaXMuX3NldFByb3AoJ29yZ2FuaXplcicsIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHNlcXVlbmNlIHZhbHVlIGZvciB0aGlzIGV2ZW50LiBVc2VkIGZvciBzY2hlZHVsaW5nXG4gICAgICogc2VlIHtAdHV0b3JpYWwgdGVybWlub2xvZ3l9LlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHNlcXVlbmNlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpcnN0UHJvcCgnc2VxdWVuY2UnKTtcbiAgICB9LFxuXG4gICAgc2V0IHNlcXVlbmNlKHZhbHVlKSB7XG4gICAgICB0aGlzLl9zZXRQcm9wKCdzZXF1ZW5jZScsIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHJlY3VycmVuY2UgaWQgZm9yIHRoaXMgZXZlbnQuIFNlZSB7QHR1dG9yaWFsIHRlcm1pbm9sb2d5fSBmb3IgZGV0YWlscy5cbiAgICAgKiBAdHlwZSB7SUNBTC5UaW1lfVxuICAgICAqL1xuICAgIGdldCByZWN1cnJlbmNlSWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmlyc3RQcm9wKCdyZWN1cnJlbmNlLWlkJyk7XG4gICAgfSxcblxuICAgIHNldCByZWN1cnJlbmNlSWQodmFsdWUpIHtcbiAgICAgIHRoaXMuX3NldFRpbWUoJ3JlY3VycmVuY2UtaWQnLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldC91cGRhdGUgYSB0aW1lIHByb3BlcnR5J3MgdmFsdWUuXG4gICAgICogVGhpcyB3aWxsIGFsc28gdXBkYXRlIHRoZSBUWklEIG9mIHRoZSBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIFRPRE86IHRoaXMgbWV0aG9kIGhhbmRsZXMgdGhlIGNhc2Ugd2hlcmUgd2UgYXJlIHN3aXRjaGluZ1xuICAgICAqIGZyb20gYSBrbm93biB0aW1lem9uZSB0byBhbiBpbXBsaWVkIHRpbWV6b25lIChvbmUgd2l0aG91dCBUWklEKS5cbiAgICAgKiBUaGlzIGRvZXMgX25vdF8gaGFuZGxlIHRoZSBjYXNlIG9mIG1vdmluZyBiZXR3ZWVuIGEga25vd25cbiAgICAgKiAgKGJ5IFRpbWV6b25lU2VydmljZSkgdGltZXpvbmUgdG8gYW4gdW5rbm93biB0aW1lem9uZS4uLlxuICAgICAqXG4gICAgICogV2Ugd2lsbCBub3QgYWRkL3JlbW92ZS91cGRhdGUgdGhlIFZUSU1FWk9ORSBzdWJjb21wb25lbnRzXG4gICAgICogIGxlYWRpbmcgdG8gaW52YWxpZCBJQ0FMIGRhdGEuLi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wTmFtZSAgICAgVGhlIHByb3BlcnR5IG5hbWVcbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZX0gdGltZSAgICAgIFRoZSB0aW1lIHRvIHNldFxuICAgICAqL1xuICAgIF9zZXRUaW1lOiBmdW5jdGlvbihwcm9wTmFtZSwgdGltZSkge1xuICAgICAgdmFyIHByb3AgPSB0aGlzLmNvbXBvbmVudC5nZXRGaXJzdFByb3BlcnR5KHByb3BOYW1lKTtcblxuICAgICAgaWYgKCFwcm9wKSB7XG4gICAgICAgIHByb3AgPSBuZXcgSUNBTC5Qcm9wZXJ0eShwcm9wTmFtZSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50LmFkZFByb3BlcnR5KHByb3ApO1xuICAgICAgfVxuXG4gICAgICAvLyB1dGMgYW5kIGxvY2FsIGRvbid0IGdldCBhIHR6aWRcbiAgICAgIGlmIChcbiAgICAgICAgdGltZS56b25lID09PSBJQ0FMLlRpbWV6b25lLmxvY2FsVGltZXpvbmUgfHxcbiAgICAgICAgdGltZS56b25lID09PSBJQ0FMLlRpbWV6b25lLnV0Y1RpbWV6b25lXG4gICAgICApIHtcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSB0emlkXG4gICAgICAgIHByb3AucmVtb3ZlUGFyYW1ldGVyKCd0emlkJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wLnNldFBhcmFtZXRlcigndHppZCcsIHRpbWUuem9uZS50emlkKTtcbiAgICAgIH1cblxuICAgICAgcHJvcC5zZXRWYWx1ZSh0aW1lKTtcbiAgICB9LFxuXG4gICAgX3NldFByb3A6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICB0aGlzLmNvbXBvbmVudC51cGRhdGVQcm9wZXJ0eVdpdGhWYWx1ZShuYW1lLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIF9maXJzdFByb3A6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudC5nZXRGaXJzdFByb3BlcnR5VmFsdWUobmFtZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBldmVudC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50LnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gIH07XG5cbiAgZnVuY3Rpb24gY29tcGFyZVJhbmdlRXhjZXB0aW9uKGEsIGIpIHtcbiAgICBpZiAoYVswXSA+IGJbMF0pIHJldHVybiAxO1xuICAgIGlmIChiWzBdID4gYVswXSkgcmV0dXJuIC0xO1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIEV2ZW50O1xufSgpKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAxMS0yMDE1ICovXG5cblxuLyoqXG4gKiBUaGlzIHN5bWJvbCBpcyBmdXJ0aGVyIGRlc2NyaWJlZCBsYXRlciBvblxuICogQGlnbm9yZVxuICovXG5JQ0FMLkNvbXBvbmVudFBhcnNlciA9IChmdW5jdGlvbigpIHtcbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogVGhlIENvbXBvbmVudFBhcnNlciBpcyB1c2VkIHRvIHByb2Nlc3MgYSBTdHJpbmcgb3IgakNhbCBPYmplY3QsXG4gICAqIGZpcmluZyBjYWxsYmFja3MgZm9yIHZhcmlvdXMgZm91bmQgY29tcG9uZW50cywgYXMgd2VsbCBhcyBjb21wbGV0aW9uLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgb3B0aW9ucyA9IHtcbiAgICogICAvLyB3aGVuIGZhbHNlIG5vIGV2ZW50cyB3aWxsIGJlIGVtaXR0ZWQgZm9yIHR5cGVcbiAgICogICBwYXJzZUV2ZW50OiB0cnVlLFxuICAgKiAgIHBhcnNlVGltZXpvbmU6IHRydWVcbiAgICogfTtcbiAgICpcbiAgICogdmFyIHBhcnNlciA9IG5ldyBJQ0FMLkNvbXBvbmVudFBhcnNlcihvcHRpb25zKTtcbiAgICpcbiAgICogcGFyc2VyLm9uZXZlbnQoZXZlbnRDb21wb25lbnQpIHtcbiAgICogICAvLy4uLlxuICAgKiB9XG4gICAqXG4gICAqIC8vIG9udGltZXpvbmUsIGV0Yy4uLlxuICAgKlxuICAgKiBwYXJzZXIub25jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuICAgKlxuICAgKiB9O1xuICAgKlxuICAgKiBwYXJzZXIucHJvY2VzcyhzdHJpbmdPckNvbXBvbmVudCk7XG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAYWxpYXMgSUNBTC5Db21wb25lbnRQYXJzZXJcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zICAgICAgICBDb21wb25lbnQgcGFyc2VyIG9wdGlvbnNcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLnBhcnNlRXZlbnQgICAgICAgIFdoZXRoZXIgZXZlbnRzIHNob3VsZCBiZSBwYXJzZWRcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLnBhcnNlVGltZXplb25lICAgIFdoZXRoZXIgdGltZXpvbmVzIHNob3VsZCBiZSBwYXJzZWRcbiAgICovXG4gIGZ1bmN0aW9uIENvbXBvbmVudFBhcnNlcihvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZihvcHRpb25zKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIga2V5O1xuICAgIGZvciAoa2V5IGluIG9wdGlvbnMpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHRoaXNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBDb21wb25lbnRQYXJzZXIucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCBwYXJzZSBldmVudHNcbiAgICAgKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHBhcnNlRXZlbnQ6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIHBhcnNlIHRpbWV6b25lc1xuICAgICAqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgcGFyc2VUaW1lem9uZTogdHJ1ZSxcblxuXG4gICAgLyogU0FYIGxpa2UgZXZlbnRzIGhlcmUgZm9yIHJlZmVyZW5jZSAqL1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiBwYXJzaW5nIGlzIGNvbXBsZXRlXG4gICAgICogQGNhbGxiYWNrXG4gICAgICovXG4gICAgb25jb21wbGV0ZTogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZnVuY3Rpb24oKSB7fSxcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIGlmIGFuIGVycm9yIG9jY3VycyBkdXJpbmcgcGFyc2luZy5cbiAgICAgKlxuICAgICAqIEBjYWxsYmFja1xuICAgICAqIEBwYXJhbSB7RXJyb3J9IGVyciBkZXRhaWxzIG9mIGVycm9yXG4gICAgICovXG4gICAgb25lcnJvcjogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZnVuY3Rpb24oZXJyKSB7fSxcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gYSB0b3AgbGV2ZWwgY29tcG9uZW50IChWVElNRVpPTkUpIGlzIGZvdW5kXG4gICAgICpcbiAgICAgKiBAY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZXpvbmV9IGNvbXBvbmVudCAgICAgVGltZXpvbmUgb2JqZWN0XG4gICAgICovXG4gICAgb250aW1lem9uZTogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZnVuY3Rpb24oY29tcG9uZW50KSB7fSxcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gYSB0b3AgbGV2ZWwgY29tcG9uZW50IChWRVZFTlQpIGlzIGZvdW5kLlxuICAgICAqXG4gICAgICogQGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHtJQ0FMLkV2ZW50fSBjb21wb25lbnQgICAgVG9wIGxldmVsIGNvbXBvbmVudFxuICAgICAqL1xuICAgIG9uZXZlbnQ6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uKGNvbXBvbmVudCkge30sXG5cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGEgc3RyaW5nIG9yIHBhcnNlIGljYWwgb2JqZWN0LiAgVGhpcyBmdW5jdGlvbiBpdHNlbGYgd2lsbCByZXR1cm5cbiAgICAgKiBub3RoaW5nIGJ1dCB3aWxsIHN0YXJ0IHRoZSBwYXJzaW5nIHByb2Nlc3MuXG4gICAgICpcbiAgICAgKiBFdmVudHMgbXVzdCBiZSByZWdpc3RlcmVkIHByaW9yIHRvIGNhbGxpbmcgdGhpcyBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuQ29tcG9uZW50fFN0cmluZ3xPYmplY3R9IGljYWwgICAgICBUaGUgY29tcG9uZW50IHRvIHByb2Nlc3MsXG4gICAgICogICAgICAgIGVpdGhlciBpbiBpdHMgZmluYWwgZm9ybSwgYXMgYSBqQ2FsIE9iamVjdCwgb3Igc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAgICovXG4gICAgcHJvY2VzczogZnVuY3Rpb24oaWNhbCkge1xuICAgICAgLy9UT0RPOiB0aGlzIGlzIHN5bmMgbm93IGluIHRoZSBmdXR1cmUgd2Ugd2lsbCBoYXZlIGEgaW5jcmVtZW50YWwgcGFyc2VyLlxuICAgICAgaWYgKHR5cGVvZihpY2FsKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWNhbCA9IElDQUwucGFyc2UoaWNhbCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghKGljYWwgaW5zdGFuY2VvZiBJQ0FMLkNvbXBvbmVudCkpIHtcbiAgICAgICAgaWNhbCA9IG5ldyBJQ0FMLkNvbXBvbmVudChpY2FsKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbXBvbmVudHMgPSBpY2FsLmdldEFsbFN1YmNvbXBvbmVudHMoKTtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBsZW4gPSBjb21wb25lbnRzLmxlbmd0aDtcbiAgICAgIHZhciBjb21wb25lbnQ7XG5cbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29tcG9uZW50ID0gY29tcG9uZW50c1tpXTtcblxuICAgICAgICBzd2l0Y2ggKGNvbXBvbmVudC5uYW1lKSB7XG4gICAgICAgICAgY2FzZSAndnRpbWV6b25lJzpcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcnNlVGltZXpvbmUpIHtcbiAgICAgICAgICAgICAgdmFyIHR6aWQgPSBjb21wb25lbnQuZ2V0Rmlyc3RQcm9wZXJ0eVZhbHVlKCd0emlkJyk7XG4gICAgICAgICAgICAgIGlmICh0emlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbnRpbWV6b25lKG5ldyBJQ0FMLlRpbWV6b25lKHtcbiAgICAgICAgICAgICAgICAgIHR6aWQ6IHR6aWQsXG4gICAgICAgICAgICAgICAgICBjb21wb25lbnQ6IGNvbXBvbmVudFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndmV2ZW50JzpcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcnNlRXZlbnQpIHtcbiAgICAgICAgICAgICAgdGhpcy5vbmV2ZW50KG5ldyBJQ0FMLkV2ZW50KGNvbXBvbmVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vWFhYOiBpZGVhbGx5IHdlIHNob3VsZCBkbyBhIFwibmV4dFRpY2tcIiBoZXJlXG4gICAgICAvLyAgICAgc28gaW4gYWxsIGNhc2VzIHRoaXMgaXMgYWN0dWFsbHkgYXN5bmMuXG4gICAgICB0aGlzLm9uY29tcGxldGUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIENvbXBvbmVudFBhcnNlcjtcbn0oKSk7XG4iLCAiaW1wb3J0IHsgQXBwLCBQbHVnaW4sIFBsdWdpbk1hbmlmZXN0LCBURmlsZSwgV29ya3NwYWNlTGVhZiB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IENhbGVuZGFyVmlld30gZnJvbSBcIi4vdmlld3MvQ2FsZW5kYXJWaWV3XCJcbmltcG9ydCB7IENhY2hlIH0gZnJvbSBcIi4vY2FjaGVcIlxuaW1wb3J0IHsgUGx1Z2luU2V0dGluZ3MgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IE15U2V0dGluZ1RhYiB9IGZyb20gJy4vc2V0dGluZyc7XG5pbXBvcnQgeyBERUZBVUxUX1NFVFRJTkdTLCBDQUNIRV9JRCwgTVNHX1BMR19OQU1FLCBWSUVXX1RZUEUgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgU3RhdHVzQ29ycmVjdG9yIGZyb20gJy4vdmlld3Mvc3RhdHVzQ29ycmVjdG9yJztcbmltcG9ydCB7IFRpY2tDaGVja2VyIH0gZnJvbSAnLi92aWV3cy9UaWNrQ2hla2VyJztcbmltcG9ydCBOb3RlTWFuYWdlciBmcm9tICcuL05vdGVNYW5hZ2VyJztcblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNeVBsdWdpbiBleHRlbmRzIFBsdWdpbiB7XG4gIHByaXZhdGUgbm90ZU1hbmFnZXI6IE5vdGVNYW5hZ2VyXG5cbiAgcHJpdmF0ZSBjYWNoZTogQ2FjaGVcblxuICBwcml2YXRlIHN0YXR1c0NvcnJlY3RvcjogU3RhdHVzQ29ycmVjdG9yXG5cbiAgcHJpdmF0ZSBzZXR0aW5nczogUGx1Z2luU2V0dGluZ3NcblxuICBwcml2YXRlIHRpY2tDaGVja2VyOiBUaWNrQ2hlY2tlciB8IHZvaWRcblxuICBwcml2YXRlIGNhbGVuZGFyOiBDYWxlbmRhclZpZXcgfCB2b2lkXG5cbiAgY29uc3RydWN0b3IoYXBwOiBBcHAsIG1hbmlmZXN0OiBQbHVnaW5NYW5pZmVzdCkge1xuICAgIHN1cGVyKGFwcCwgbWFuaWZlc3QpXG5cbiAgICBjb25zdCBub3RlTWFuYWdlciA9IG5ldyBOb3RlTWFuYWdlcihcbiAgICAgIHRoaXMuYXBwLnZhdWx0LFxuICAgICAgdGhpcy5hcHAubWV0YWRhdGFDYWNoZSxcbiAgICAgIHRoaXMuYXBwLmZpbGVNYW5hZ2VyLFxuICAgICAgdGhpcy5hcHAud29ya3NwYWNlXG4gICAgKVxuICAgIHRoaXMubm90ZU1hbmFnZXIgPSBub3RlTWFuYWdlclxuXG4gICAgLy8gXHUwNDQxXHUwNDNFXHUwNDM3XHUwNDM0XHUwNDMwXHUwNDMyXHUwNDMwXHUwNDQyXHUwNDRDIFx1MDQzRlx1MDQ0MFx1MDQzOCBvbmxvYWQgXHUwNDM4IFx1MDQ0Mlx1MDQzRVx1MDQzM1x1MDQzNFx1MDQzMCBcdTA0MzZcdTA0MzUgXHUwNDM3XHUwNDMwXHUwNDNGXHUwNDQzXHUwNDQxXHUwNDNBXHUwNDMwXHUwNDQyXHUwNDRDIGluaXRTdG9yYWdlXG4gICAgdGhpcy5jYWNoZSA9IG5ldyBDYWNoZSh0aGlzLm5vdGVNYW5hZ2VyLCB0aGlzLmFwcC52YXVsdClcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBvbmxvYWQoKSB7XG4gICAgYXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKVxuXG4gICAgdGhpcy5pbml0UmVnaXN0ZXIoKVxuXG5cbiAgICB0aGlzLnRpY2tDaGVja2VyID0gbmV3IFRpY2tDaGVja2VyKFxuICAgICAgQ0FDSEVfSUQuVElDS19DSEVDS0VSLFxuICAgICAgdGhpcy5zZXR0aW5ncy5zb3VyY2Uubm90ZVNvdXJjZXMsXG4gICAgICB0aGlzLmNhY2hlLFxuICAgICAgdGhpcy5ub3RlTWFuYWdlclxuICAgIClcblxuICAgIGlmICh0aGlzLnNldHRpbmdzLnN0YXR1c0NvcnJlY3Rvci5pc09uKSB7XG4gICAgICB0aGlzLnN0YXR1c0NvcnJlY3RvciA9IG5ldyBTdGF0dXNDb3JyZWN0b3IoXG4gICAgICAgIENBQ0hFX0lELlNUQVRVU19DT1JSRUNUT1IsXG4gICAgICAgIHRoaXMuc2V0dGluZ3Muc291cmNlLm5vdGVTb3VyY2VzLFxuICAgICAgICB0aGlzLmNhY2hlLFxuICAgICAgICB0aGlzLm5vdGVNYW5hZ2VyXG4gICAgICApXG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnN0YXR1c0NvcnJlY3Rvci5zdGFydE9uU3RhcnRVcClcbiAgICAgICAgdGhpcy5zdGF0dXNDb3JyZWN0b3IuY29ycmVjdEFsbE5vdGVzKClcblxuICAgICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgICAgaWQ6ICdmdWxsU3RhdHVzQ29ycmVjdCcsXG4gICAgICAgIG5hbWU6IE1TR19QTEdfTkFNRSArICdGdWxsIFN0YXR1c0NvcnJlY3RvcicsXG4gICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5zdGF0dXNDb3JyZWN0b3IuY29ycmVjdEFsbE5vdGVzKClcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5hcHAud29ya3NwYWNlLm9uTGF5b3V0UmVhZHkoKCkgPT4gdGhpcy5pbml0KCkpXG5cbiAgICB0aGlzLnJlZ2lzdGVyVmlldyhcbiAgICAgICAgVklFV19UWVBFLFxuICAgICAgICAobGVhZjogV29ya3NwYWNlTGVhZikgPT4ge1xuICAgICAgICAgIHRoaXMuY2FsZW5kYXIgPSBuZXcgQ2FsZW5kYXJWaWV3KFxuICAgICAgICAgICAgbGVhZixcbiAgICAgICAgICAgIENBQ0hFX0lELkNBTEVOREFSLFxuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5zb3VyY2Uubm90ZVNvdXJjZXMsXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzLmNhbGVuZGFyLFxuICAgICAgICAgICAgdGhpcy5jYWNoZSxcbiAgICAgICAgICAgIHRoaXMubm90ZU1hbmFnZXIsXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzLnNvdXJjZS5kZWZhdWx0Q3JlYXRlUGF0aFxuICAgICAgICAgIClcblxuICAgICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyXG4gICAgICAgIH1cbiAgICApXG5cbiAgICB0aGlzLmFkZFJpYmJvbkljb24oXCJpbmZvXCIsIE1TR19QTEdfTkFNRSArIFwiT3BlbiBDYWxlbmRhclwiLCAoKSA9PiB0aGlzLmFjdGl2YXRlVmlldygpKVxuXG4gICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgIGlkOiAncmVzZXQtY2FjaGUnLFxuICAgICAgbmFtZTogTVNHX1BMR19OQU1FICsgJ1Jlc2V0IENhY2hlJyxcbiAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuY2FjaGUucmVzZXQoKVxuICAgICAgfVxuICAgIH0pXG4gICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgIGlkOiAnbG9nLWNhY2hlJyxcbiAgICAgIG5hbWU6IE1TR19QTEdfTkFNRSArICdMb2cgQ2FjaGUnLFxuICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgdGhpcy5jYWNoZS5sb2coKVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIG9udW5sb2FkKCkge1xuICAgIC8vIFRPRE8gXHUwNDNBXHUwNDMwXHUwNDNBIFx1MDQzMVx1MDQ0M1x1MDQzNFx1MDQ0Mlx1MDQzRSBcdTA0MzRcdTA0NDBcdTA0NDNcdTA0MzNcdTA0MzhcdTA0NDUgXHUwNDNEXHUwNDM1IFx1MDQ0NVx1MDQzMlx1MDQzMFx1MDQ0Mlx1MDQzMFx1MDQzNVx1MDQ0MiBkZXN0b3lcblxuICAgIC8vIGlmICh0aGlzLnNldHRpbmdzPy5zdGF0dXNDb3JyZWN0b3IuaXNPbilcbiAgICAgIHRoaXMuc3RhdHVzQ29ycmVjdG9yPy5kZXN0cm95KClcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaW5pdCgpIHtcbiAgICBhd2FpdCB0aGlzLmNhY2hlLmluaXQoKVxuXG4gICAgdGhpcy50aWNrQ2hlY2tlcj8uaW5pdCgpXG4gICAgdGhpcy5zdGF0dXNDb3JyZWN0b3I/LmluaXQoKVxuICB9XG5cbiAgcHJpdmF0ZSBpbml0UmVnaXN0ZXIoKSB7XG4gICAgdGhpcy5yZWdpc3RlckV2ZW50KFxuICAgICAgdGhpcy5hcHAubWV0YWRhdGFDYWNoZS5vbihcImNoYW5nZWRcIiwgZmlsZSA9PiB7XG4gICAgICAgIHRoaXMuY2FjaGUuY2hhbmdlRmlsZShmaWxlKVxuICAgICAgfSlcbiAgICApXG5cbiAgICB0aGlzLnJlZ2lzdGVyRXZlbnQoXG4gICAgICB0aGlzLmFwcC52YXVsdC5vbihcbiAgICAgICAgXCJyZW5hbWVcIixcbiAgICAgICAgKGZpbGUsIG9sZFBhdGgpID0+IHtcbiAgICAgICAgICAvLyBcdTA0M0ZcdTA0NDBcdTA0M0VcdTA0MzJcdTA0MzVcdTA0NDBcdTA0M0FcdTA0MzAgXHUwNDNEXHUwNDMwIFx1MDQ0Mlx1MDQzRSwgXHUwNDQ3XHUwNDQyXHUwNDNFIFx1MDQ0RFx1MDQ0Mlx1MDQzRSBcdTA0NDRcdTA0MzBcdTA0MzlcdTA0M0IsIFx1MDQzMCBcdTA0M0RcdTA0MzUgXHUwNDNGXHUwNDMwXHUwNDNGXHUwNDNBXHUwNDMwXG4gICAgICAgICAgaWYgKCEoZmlsZSBhcyBURmlsZSkuYmFzZW5hbWUpXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICAgIHRoaXMuY2FjaGUucmVuYW1lRmlsZShmaWxlIGFzIFRGaWxlLCBvbGRQYXRoKVxuICAgICAgICB9XG4gICAgICApXG4gICAgKVxuXG4gICAgdGhpcy5yZWdpc3RlckV2ZW50KFxuICAgICAgdGhpcy5hcHAudmF1bHQub24oXG4gICAgICAgIFwiZGVsZXRlXCIsXG4gICAgICAgIGZpbGUgPT4gdGhpcy5jYWNoZS5kZWxldGVGaWxlKGZpbGUpXG4gICAgICApXG4gICAgKVxuXG4gICAgdGhpcy5yZWdpc3RlckV2ZW50KFxuICAgICAgdGhpcy5hcHAudmF1bHQub24oXG4gICAgICAgIFwiY3JlYXRlXCIsXG4gICAgICAgIGZpbGUgPT4ge1xuICAgICAgICAgIC8vIFx1MDQzRlx1MDQ0MFx1MDQzRVx1MDQzMlx1MDQzNVx1MDQ0MFx1MDQzQVx1MDQzMCBcdTA0M0RcdTA0MzAgXHUwNDQyXHUwNDNFLCBcdTA0NDdcdTA0NDJcdTA0M0UgXHUwNDREXHUwNDQyXHUwNDNFIFx1MDQ0NFx1MDQzMFx1MDQzOVx1MDQzQiwgXHUwNDMwIFx1MDQzRFx1MDQzNSBcdTA0M0ZcdTA0MzBcdTA0M0ZcdTA0M0FcdTA0MzBcbiAgICAgICAgICBpZiAoIShmaWxlIGFzIFRGaWxlKS5iYXNlbmFtZSlcbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgICAgdGhpcy5jYWNoZS5hZGRGaWxlKGZpbGUgYXMgVEZpbGUpXG4gICAgICAgIH1cbiAgICAgIClcbiAgICApXG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGFjdGl2YXRlVmlldygpIHtcbiAgICBjb25zdCBsZWF2ZXMgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0TGVhdmVzT2ZUeXBlKFZJRVdfVFlQRSlcbiAgICBpZiAobGVhdmVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc3QgbGVhZiA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRMZWFmKGZhbHNlKTtcbiAgICAgIGF3YWl0IGxlYWYuc2V0Vmlld1N0YXRlKHtcbiAgICAgICAgdHlwZTogVklFV19UWVBFLFxuICAgICAgICBhY3RpdmU6IHRydWUsXG4gICAgICB9KVxuICAgIH1cbiAgICBlbHNlIGlmIChsZWF2ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAobGVhdmVzWzBdLnZpZXcgYXMgQ2FsZW5kYXJWaWV3KS5vbk9wZW4oKVxuICAgICAgdGhpcy5hcHAud29ya3NwYWNlLnNldEFjdGl2ZUxlYWYobGVhdmVzWzBdKVxuICAgIH1cbiAgICBlbHNlIGZvciAobGV0IGxlYWYgb2YgbGVhdmVzKVxuICAgICAgbGVhZi5kZXRhY2goKVxuICB9XG5cblxuICAvLyBTZXR0aW5nc1xuXG4gIHB1YmxpYyBnZXRTZXR0aW5ncygpOiBQbHVnaW5TZXR0aW5ncyB7XG4gICAgLy8gTk9URTogZnVsbCBjb3B5XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoXG4gICAgICBKU09OLnN0cmluZ2lmeSh0aGlzLnNldHRpbmdzKVxuICAgIClcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBzYXZlU2V0dGluZ3Moc2V0dGluZ3M6IFBsdWdpblNldHRpbmdzKSB7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzXG4gICAgYXdhaXQgdGhpcy5zYXZlRGF0YSh0aGlzLnNldHRpbmdzKTtcbiAgfVxuXG5cblxuICBwcml2YXRlIGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcbiAgICB0aGlzLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9TRVRUSU5HUywgYXdhaXQgdGhpcy5sb2FkRGF0YSgpKVxuXG4gICAgdGhpcy5hZGRTZXR0aW5nVGFiKG5ldyBNeVNldHRpbmdUYWIodGhpcy5hcHAsIHRoaXMpKTtcbiAgfVxufVxuIiwgImltcG9ydCB7IEl0ZW1WaWV3LCBQbGF0Zm9ybSwgV29ya3NwYWNlTGVhZiwgTm90aWNlLCBNb2RhbCwgQXBwLCBTZXR0aW5nLCBNZW51LCBDb21wb25lbnQgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgTXlQbHVnaW4gZnJvbSBcIi4uL21haW5cIlxuaW1wb3J0IHsgTVNHX1BMR19OQU1FLCBURVhUX0RPTkUsIFZJRVdfVFlQRSB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBDYWxlbmRhckV2ZW50LCBDYWxlbmRhclNldHRpbmdzLCBJRXZlbnQsIElQYWdlLCBJU3Vic2NyaWJlciwgU3JjIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgQ2FsZW5kYXJFdmVudFRvSURhdGUsIGdldENvbG91ckZyb21QYXRoLCBJRGF0ZVRvQ2FsZW5kYXJFdmVudCwgbWlsbGlzZWNUb1N0cmluZywgdGVtcGxhdGVJRFRpY2ssIHRlbXBsYXRlTmFtZVRpY2ssIHRpbWVBZGQgfSBmcm9tICcuLi91dGlsJztcbmltcG9ydCB7IHJlbmRlckNhbGVuZGFyIH0gZnJvbSAnbGliL29ic2lkaWFuLWZ1bGwtY2FsZW5kYXIvY2FsZW5kYXInO1xuaW1wb3J0IHsgQ2FsZW5kYXIgfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvcmUnO1xuaW1wb3J0IHsgQ2FjaGUgfSBmcm9tICdzcmMvY2FjaGUnO1xuaW1wb3J0IE5vdGVNYW5hZ2VyIGZyb20gJ3NyYy9Ob3RlTWFuYWdlcic7XG5cbmV4cG9ydCBjbGFzcyBDYWxlbmRhclZpZXcgZXh0ZW5kcyBJdGVtVmlldyBpbXBsZW1lbnRzIElTdWJzY3JpYmVyIHtcbiAgLy8gcHJpdmF0ZSBwYXJyZW50UG9pbnRlcjogTXlQbHVnaW5cblxuICBwcml2YXRlIGNhY2hlOiBDYWNoZVxuXG4gIHByaXZhdGUgY2FsZW5kYXI6IENhbGVuZGFyIHwgbnVsbCA9IG51bGxcblxuICBwcml2YXRlIGlkRm9yQ2FjaGU6IG51bWJlclxuXG4gIHByaXZhdGUgZXZlbnRTcmM6IFNyY1tdXG5cbiAgcHJpdmF0ZSBzZWxlY3RlZFNyY1BhdGhzOiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQoKVxuXG4gIHByaXZhdGUgbm90ZU1hbmFnZXI6IE5vdGVNYW5hZ2VyXG5cbiAgcHJpdmF0ZSBjYWxlbmRhclNldHRpbmdzOiBDYWxlbmRhclNldHRpbmdzXG5cbiAgcHJpdmF0ZSBsb2NhbFN0b3JhZ2U6IElQYWdlW11cblxuICAvLyBwcml2YXRlIHNyY0NoZWNrYm94Q29udGFpbmVyOiBIVE1MRWxlbWVudCB8IG51bGwgPSBudWxsXG4gIHByaXZhdGUgcGxhY2VGb3JDcmVhdGluZ05vdGU6IHN0cmluZ1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGxlYWY6IFdvcmtzcGFjZUxlYWYsXG4gICAgaWRGb3JDYWNoZTogbnVtYmVyLFxuICAgIGV2ZW50U3JjOiBTcmNbXSxcbiAgICBjYWxlbmRhclNldHRpbmdzOiBDYWxlbmRhclNldHRpbmdzLFxuICAgIGNhY2hlOiBDYWNoZSxcbiAgICBub3RlTWFuYWdlcjogTm90ZU1hbmFnZXIsXG4gICAgcGxhY2VGb3JDcmVhdGluZ05vdGU6IHN0cmluZyxcbiAgKSB7XG4gICAgc3VwZXIobGVhZilcblxuICAgIHRoaXMuY2FjaGUgPSBjYWNoZVxuICAgIHRoaXMuaWRGb3JDYWNoZSA9IGlkRm9yQ2FjaGVcbiAgICB0aGlzLmV2ZW50U3JjID0gZXZlbnRTcmNcbiAgICB0aGlzLm5vdGVNYW5hZ2VyID0gbm90ZU1hbmFnZXJcbiAgICB0aGlzLmNhbGVuZGFyU2V0dGluZ3MgPSBjYWxlbmRhclNldHRpbmdzXG4gICAgdGhpcy5wbGFjZUZvckNyZWF0aW5nTm90ZSA9IHBsYWNlRm9yQ3JlYXRpbmdOb3RlXG5cbiAgICBmb3IgKGxldCBzcmMgb2YgZXZlbnRTcmMpIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWRTcmNQYXRocy5hZGQoc3JjLnBhdGgpXG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldFZpZXdUeXBlKCkge3JldHVybiBWSUVXX1RZUEV9XG5cbiAgcHVibGljIGdldERpc3BsYXlUZXh0KCkge3JldHVybiBcIkNhbGVuZGFyXCJ9XG5cbiAgcHVibGljIGFzeW5jIG9uT3BlbigpIHtcbiAgICBpZiAoUGxhdGZvcm0uaXNNb2JpbGUpXG4gICAgICB0aGlzLmNvbnRhaW5lckVsLnN0eWxlLmhlaWdodCA9IFwiOTV2aFwiXG5cbiAgICBjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzXG4gICAgY29uc3QgY29udGFpbmVyID0gY29udGFpbmVyRWwuY2hpbGRyZW5bMV1cbiAgICBjb250YWluZXIuZW1wdHkoKVxuICAgIGNvbnN0IGNhbGVuZGFyQ29udGFpbmVyID0gY29udGFpbmVyLmNyZWF0ZURpdigvKntjbHM6ICdjbGFzcyd9Ki8pXG4gICAgY29uc3QgY2hlY2tCb3hDb250YWluZXIgPSBjb250YWluZXIuY3JlYXRlRGl2KHtjbHM6ICdjYWxlbmRhci1zcmMtY2hlY2tib3hlcyd9KVxuXG4gICAgdGhpcy5yZW5kZXIoY2FsZW5kYXJDb250YWluZXIpXG4gICAgICAudGhlbihcbiAgICAgICAgKCkgPT4gdGhpcy5yZW5kZXJTcmNDaGVja2JveGVzKGNoZWNrQm94Q29udGFpbmVyKVxuICAgICAgKVxuICB9XG5cbiAgcHVibGljIG9uUmVzaXplKCkge1xuICAgIHRoaXMuY2FsZW5kYXI/LnJlbmRlcigpO1xuICB9XG5cbiAgcHVibGljIGFkZEZpbGUoZGF0YTogSVBhZ2UpOiB2b2lkIHtcbiAgICB0aGlzLmxvY2FsU3RvcmFnZS5wdXNoKGRhdGEpXG4gICAgaWYgKCF0aGlzLmlzUGF0aEluQWN0aXZlU3JjKGRhdGEuZmlsZS5wYXRoKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgZXZlbnRzID0gdGhpcy5wYWdlVG9FdmVudHMoZGF0YSlcblxuICAgIGZvciAobGV0IGV2ZW50IG9mIGV2ZW50cylcbiAgICAgIHRoaXMuY2FsZW5kYXI/LmFkZEV2ZW50KGV2ZW50KVxuICB9XG5cbiAgcHVibGljIGNoYW5nZUZpbGUobmV3UGFnZTogSVBhZ2UsIG9sZFBhZ2U6IElQYWdlKTogdm9pZCB7XG4gICAgdGhpcy5jYWxlbmRhcj8ucGF1c2VSZW5kZXJpbmcoKVxuICAgIHRoaXMuZGVsZXRlRmlsZShvbGRQYWdlKVxuICAgIHRoaXMuYWRkRmlsZShuZXdQYWdlKVxuICAgIHRoaXMuY2FsZW5kYXI/LnJlc3VtZVJlbmRlcmluZygpXG4gIH1cblxuICBwdWJsaWMgcmVuYW1lRmlsZShuZXdQYWdlOiBJUGFnZSwgb2xkUGFnZTogSVBhZ2UpOiB2b2lkIHtcbiAgICB0aGlzLmNoYW5nZUZpbGUobmV3UGFnZSwgb2xkUGFnZSlcbiAgfVxuXG4gIHB1YmxpYyBkZWxldGVGaWxlKHBhZ2U6IElQYWdlKTogdm9pZCB7XG4gICAgY29uc3QgZWwgPSB0aGlzLmxvY2FsU3RvcmFnZS5maW5kKFxuICAgICAgdmFsdWUgPT4gcGFnZS5maWxlLnBhdGggPT0gdmFsdWUuZmlsZS5wYXRoXG4gICAgKVxuICAgIGlmIChlbClcbiAgICAgIHRoaXMubG9jYWxTdG9yYWdlLnJlbW92ZShlbClcblxuICAgIGlmICghdGhpcy5jYWxlbmRhcilcbiAgICAgIHJldHVyblxuXG4gICAgaWYgKCF0aGlzLmlzUGF0aEluQWN0aXZlU3JjKHBhZ2UuZmlsZS5wYXRoKSlcbiAgICAgIHJldHVyblxuXG4gICAgdGhpcy5jYWxlbmRhci5nZXRFdmVudEJ5SWQocGFnZS5maWxlLnBhdGgpPy5yZW1vdmUoKVxuXG4gICAgZm9yIChsZXQgdGljayBvZiBwYWdlLnRpY2tzKSB7XG4gICAgICB0aGlzLmNhbGVuZGFyLmdldEV2ZW50QnlJZChcbiAgICAgICAgdGVtcGxhdGVJRFRpY2socGFnZS5maWxlLnBhdGgsIHRpY2submFtZSlcbiAgICAgICk/LnJlbW92ZSgpXG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlc2V0KCkge1xuICAgIHRoaXMub251bmxvYWQoKVxuICAgIHRoaXMub25PcGVuKClcbiAgfVxuXG4gIG9udW5sb2FkKCkge1xuICAgIGlmICghdGhpcy5jYWxlbmRhcilcbiAgICAgIHJldHVyblxuXG4gICAgdGhpcy5jYWxlbmRhci5kZXN0cm95KCk7XG4gICAgdGhpcy5jYWxlbmRhciA9IG51bGw7XG4gICAgdGhpcy5jYWNoZS51bnN1YnNjcmliZSh0aGlzLmlkRm9yQ2FjaGUpXG4gIH1cblxuICBwdWJsaWMgcGFnZVRvRXZlbnRzKHBhZ2U6IElQYWdlKTogSUV2ZW50W10ge1xuICAgIGNvbnN0IHJlc3VsdDogSUV2ZW50W10gPSBbXVxuXG4gICAgY29uc3QgY29sb3VycyA9IHRoaXMuY2FsZW5kYXJTZXR0aW5ncy5jb2xvdXJzXG5cbiAgICBjb25zdCBzdHJ1Y3R1cmVUZW1wbGF0ZSA9IHtcbiAgICAgIGlkOiBcIlwiLFxuICAgICAgdGl0bGU6IFwiXCIsXG4gICAgICBib3JkZXJDb2xvcjogY29sb3Vycy5kZWZhdWx0LFxuICAgICAgY29sb3I6IGdldENvbG91ckZyb21QYXRoKHBhZ2UuZmlsZS5wYXRoKSxcbiAgICAgIGVkaXRhYmxlOiB0cnVlLFxuICAgIH1cblxuICAgIGlmIChwYWdlLmZmX2RhdGUpIHtcbiAgICAgIGNvbnN0IHN0cnVjdHVyZTogSUV2ZW50ID0ge1xuICAgICAgICAuLi5zdHJ1Y3R1cmVUZW1wbGF0ZSxcbiAgICAgICAgaWQ6IHBhZ2UuZmlsZS5wYXRoLFxuICAgICAgICB0aXRsZTogcGFnZS5maWxlLm5hbWUsXG4gICAgICAgIC4uLklEYXRlVG9DYWxlbmRhckV2ZW50KHBhZ2UpXG4gICAgICB9XG4gICAgICBpZiAocGFnZS5mZl9mcmVxdWVuY3kpXG4gICAgICAgIHN0cnVjdHVyZS5ib3JkZXJDb2xvciA9IGNvbG91cnMuZnJlcXVlbmN5XG4gICAgICBpZiAocGFnZS5mZl9zdGF0dXMgPT0gVEVYVF9ET05FKVxuICAgICAgICBzdHJ1Y3R1cmUuYm9yZGVyQ29sb3IgPSBjb2xvdXJzLmRvbmVcblxuICAgICAgcmVzdWx0LnB1c2goc3RydWN0dXJlKVxuICAgIH1cbiAgICBmb3IgKGxldCB0aWNrIG9mIHBhZ2UudGlja3MpIHtcbiAgICAgIGNvbnN0IHN0cnVjdHVyZTogSUV2ZW50ID0ge1xuICAgICAgICAuLi5zdHJ1Y3R1cmVUZW1wbGF0ZSxcbiAgICAgICAgaWQ6IHRlbXBsYXRlSURUaWNrKHBhZ2UuZmlsZS5wYXRoLCB0aWNrLm5hbWUpLFxuICAgICAgICB0aXRsZTogdGVtcGxhdGVOYW1lVGljayhwYWdlLmZpbGUubmFtZSwgdGljay5uYW1lKSxcbiAgICAgICAgYm9yZGVyQ29sb3I6IGNvbG91cnMudGljayxcbiAgICAgICAgZXh0ZW5kZWRQcm9wczoge1xuICAgICAgICAgIHRpY2tOYW1lOiB0aWNrLm5hbWUsXG4gICAgICAgICAgbm90ZVBhdGg6IHBhZ2UuZmlsZS5wYXRoXG4gICAgICAgIH0sXG4gICAgICAgIC4uLklEYXRlVG9DYWxlbmRhckV2ZW50KHRpY2spXG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaChzdHJ1Y3R1cmUpXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cblxuICBwcml2YXRlIHJlbmRlclNyY0NoZWNrYm94ZXMoc3JjQ2hlY2tib3hDb250YWluZXI6IEhUTUxFbGVtZW50KSB7XG4gICAgc3JjQ2hlY2tib3hDb250YWluZXIuZW1wdHkoKVxuICAgIHNyY0NoZWNrYm94Q29udGFpbmVyLmFkZENsYXNzKFwiY2FsZW5kYXItc3JjLWNoZWNrYm94ZXNcIilcblxuICAgIGZvciAobGV0IHNyYyBvZiB0aGlzLmV2ZW50U3JjKSB7XG4gICAgICBjb25zdCBjaGVja2JveENvbnRhaW5lciA9IHNyY0NoZWNrYm94Q29udGFpbmVyIS5jcmVhdGVEaXYoe2NsczogJ3NyYy1jaGVja2JveC1pdGVtJ30pXG5cbiAgICAgIGNvbnN0IGNoZWNrYm94ID0gY2hlY2tib3hDb250YWluZXIuY3JlYXRlRWwoJ2lucHV0Jywge1xuICAgICAgICB0eXBlOiAnY2hlY2tib3gnLFxuICAgICAgICBhdHRyOiB7XG4gICAgICAgICAgaWQ6IGBzcmMtY2hlY2tib3gtJHtzcmMucGF0aH1gLFxuICAgICAgICAgIGNoZWNrZWQ6IHRoaXMuc2VsZWN0ZWRTcmNQYXRocy5oYXMoc3JjLnBhdGgpID8gJ2NoZWNrZWQnIDogbnVsbFxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICBjaGVja2JveC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgIGlmIChjaGVja2JveC5jaGVja2VkKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3RlZFNyY1BhdGhzLmFkZChzcmMucGF0aClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGVkU3JjUGF0aHMuZGVsZXRlKHNyYy5wYXRoKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVmcmVzaENhbGVuZGFyKClcbiAgICAgIH0pXG5cbiAgICAgIGNoZWNrYm94Q29udGFpbmVyLmNyZWF0ZUVsKCdsYWJlbCcsIHtcbiAgICAgICAgdGV4dDogc3JjLnBhdGgsXG4gICAgICAgIGF0dHI6IHtmb3I6IGBzcmMtY2hlY2tib3gtJHtzcmMucGF0aH1gfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGlzUGF0aEluQWN0aXZlU3JjKHBhZ2VQYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCBldmVudFNyYyA9IHRoaXMuZXZlbnRTcmMuZmlsdGVyKFxuICAgICAgZWwgPT4gdGhpcy5zZWxlY3RlZFNyY1BhdGhzLmhhcyhlbC5wYXRoKVxuICAgIClcbiAgICByZXR1cm4gZXZlbnRTcmMuc29tZShcbiAgICAgIHNyYyA9PiBzcmMuaW5jbHVkZXMocGFnZVBhdGgpXG4gICAgKVxuICB9XG5cbiAgcHJpdmF0ZSByZWZyZXNoQ2FsZW5kYXIoKSB7XG4gICAgaWYgKCF0aGlzLmNhbGVuZGFyKVxuICAgICAgcmV0dXJuXG5cbiAgICB0aGlzLmNhbGVuZGFyLnJlbW92ZUFsbEV2ZW50cygpXG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgZXZlbnRzOiBJRXZlbnRbXSA9IFsuLi50aGlzLmNhbGVuZGFyU2V0dGluZ3MucmVzdFRpbWVdXG4gICAgZm9yIChsZXQgcGFnZSBvZiB0aGlzLmxvY2FsU3RvcmFnZSkge1xuICAgICAgaWYgKCAhdGhpcy5pc1BhdGhJbkFjdGl2ZVNyYyhwYWdlLmZpbGUucGF0aCkgKVxuICAgICAgICBjb250aW51ZVxuXG4gICAgICBldmVudHMucHVzaCggLi4udGhpcy5wYWdlVG9FdmVudHMocGFnZSkgKVxuICAgIH1cblxuICAgIGZvciAobGV0IGV2ZW50IG9mIGV2ZW50cykge1xuICAgICAgdGhpcy5jYWxlbmRhci5hZGRFdmVudChldmVudClcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHJlbmRlcihjb250YWluZXI6IEVsZW1lbnQpICB7XG4gICAgY29uc3Qgc3Vic2NyaWJlZERhdGEgPSBhd2FpdCB0aGlzLmNhY2hlLnN1YnNjcmliZSh0aGlzLmlkRm9yQ2FjaGUsIHRoaXMuZXZlbnRTcmMsIHRoaXMpXG4gICAgdGhpcy5sb2NhbFN0b3JhZ2UgPSBzdWJzY3JpYmVkRGF0YVxuXG4gICAgY29uc3QgZXZlbnRzOiBJRXZlbnRbXSA9IFtdXG4gICAgZm9yIChjb25zdCBwYWdlIG9mIHN1YnNjcmliZWREYXRhKSB7XG4gICAgICBpZiAoIXRoaXMuaXNQYXRoSW5BY3RpdmVTcmMocGFnZS5maWxlLnBhdGgpKVxuICAgICAgICBjb250aW51ZVxuXG4gICAgICBldmVudHMucHVzaCggLi4udGhpcy5wYWdlVG9FdmVudHMocGFnZSkgKVxuICAgIH1cblxuICAgIHRoaXMuY2FsZW5kYXIgPSByZW5kZXJDYWxlbmRhcihcbiAgICAgIGNvbnRhaW5lciBhcyBIVE1MRWxlbWVudCxcbiAgICAgIHtcbiAgICAgICAgLy9AdHMtaWdub3JlIC8vIFRPRE8gcmVtb3ZlXG4gICAgICAgIGV2ZW50czogW1xuICAgICAgICAgIC4uLnRoaXMuY2FsZW5kYXJTZXR0aW5ncy5yZXN0VGltZSxcbiAgICAgICAgICAuLi5ldmVudHNcbiAgICAgICAgXVxuICAgICAgfSwvLyBhcyBFdmVudFNvdXJjZSxcbiAgICAgICAgdGhpcy5nZXRTZXR0aW5nc0NhbGVuZGFyKCksXG4gICAgKVxuICAgIHRoaXMuY2FsZW5kYXIuc2V0T3B0aW9uKCd3ZWVrTnVtYmVycycsIHRydWUpXG5cbiAgICAvLyBOT1RFIHRvIGZpeCBidWcgZmlyc3QgcmVuZGVyXG4gICAgd2luZG93LnNldFRpbWVvdXQoXG4gICAgICAoXzogYW55KSA9PiB7XG4gICAgICAgIGlmIChQbGF0Zm9ybS5pc01vYmlsZSlcbiAgICAgICAgICB0aGlzLmNhbGVuZGFyPy5jaGFuZ2VWaWV3KCd0aW1lR3JpZDNEYXlzJylcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRoaXMuY2FsZW5kYXI/LmNoYW5nZVZpZXcoJ3RpbWVHcmlkV2VlaycpXG4gICAgICB9LCAxXG4gICAgKVxuICAgIHRoaXMuY2FsZW5kYXIucmVuZGVyKClcbiAgfVxuXG4gIHByaXZhdGUgZ2V0U2V0dGluZ3NDYWxlbmRhcigpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICBmaXJzdERheTogMSxcbiAgICAgIHdlZWtOdW1iZXJzOiB0cnVlLFxuICAgICAgdGltZUZvcm1hdDI0aDogdHJ1ZSxcblxuICAgICAgLy8gVE9ETyByZW1vdmUgYW55XG4gICAgICBldmVudENsaWNrOiAoYXJnOiBhbnkpID0+IHtcbiAgICAgICAgY29uc3Qge2V2ZW50LCBqc0V2ZW50fSA9IGFyZ1xuICAgICAgICB0aGlzLm5vdGVNYW5hZ2VyLm9wZW5Ob3RlKGV2ZW50KVxuICAgICAgfSxcblxuICAgICAgLy8gVE9ETyByZW1vdmUgYW55XG4gICAgICBtb2RpZnlFdmVudDogYXN5bmMgKG5ld1BvczogYW55LCBvbGRQb3M6IGFueSkgPT4ge1xuICAgICAgICBjb25zdCBwcm9wcyA9IG5ld1Bvcy5leHRlbmRlZFByb3BzXG5cbiAgICAgICAgY29uc3QgZXZlbnQ6IENhbGVuZGFyRXZlbnQgPSB7XG4gICAgICAgICAgc3RhcnQ6IG5ld1Bvcy5zdGFydCxcbiAgICAgICAgICBlbmQ6IG5ld1Bvcy5lbmQsXG4gICAgICAgICAgYWxsRGF5OiBuZXdQb3MuYWxsRGF5XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvcHMubm90ZVBhdGgpIHtcbiAgICAgICAgICBjb25zdCBwYWdlID0gdGhpcy5jYWNoZS5nZXRQYWdlKHByb3BzLm5vdGVQYXRoKVxuXG4gICAgICAgICAgaWYgKCFwYWdlKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7TVNHX1BMR19OQU1FfTogY2FuJ3QgZmluZCBwYWdlIGJ5IEV2ZW50LiBldmVudElEOiAke3Byb3BzLm5vdGVQYXRofWApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB0aWNrID0gcGFnZS50aWNrcy5maW5kKFxuICAgICAgICAgICAgZWwgPT4gZWwubmFtZSA9PSBwcm9wcy50aWNrTmFtZVxuICAgICAgICAgIClcbiAgICAgICAgICBpZiAoIXRpY2spIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHtNU0dfUExHX05BTUV9OiBjYW4ndCBmaW5kIHRpY2sgYnkgcGFnZS4gUGFnZSAtIHRpY2tOYW1lOiAke3Byb3BzLm5vdGVQYXRofSAtICR7cHJvcHMudGlja05hbWV9YClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aWNrLmZmX2R1cmF0aW9uICYmIG9sZFBvcy5hbGxEYXkgJiYgIW5ld1Bvcy5hbGxEYXkpIHtcbiAgICAgICAgICAgIGV2ZW50LmVuZCA9IHRpbWVBZGQobmV3UG9zLnN0YXJ0LCB0aWNrLmZmX2R1cmF0aW9uKVxuICAgICAgICAgICAgbmV3UG9zLnNldEVuZChldmVudC5lbmQpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgbmV3UHJvcCA9IENhbGVuZGFyRXZlbnRUb0lEYXRlKGV2ZW50KVxuICAgICAgICAgIGlmIChuZXdQb3MuYWxsRGF5KSB7XG4gICAgICAgICAgICBuZXdQcm9wWydmZl9kdXJhdGlvbiddID0gbWlsbGlzZWNUb1N0cmluZyhcbiAgICAgICAgICAgICAgdGljay5mZl9kdXJhdGlvbj8uYXMoXCJtaWxsaXNlY29uZHNcIilcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLm5vdGVNYW5hZ2VyLmNoYW5nZVRpY2tGaWxlKHByb3BzLm5vdGVQYXRoLCBwcm9wcy50aWNrTmFtZSwgbmV3UHJvcClcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb25zdCBwYWdlID0gdGhpcy5jYWNoZS5nZXRQYWdlKG5ld1Bvcy5pZClcblxuICAgICAgICAgIGlmICghcGFnZSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGAke01TR19QTEdfTkFNRX06IGNhbid0IGZpbmQgcGFnZSBieSBFdmVudC4gZXZlbnRJRDogJHtuZXdQb3MuaWR9YClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwYWdlLmZmX2R1cmF0aW9uICYmIG9sZFBvcy5hbGxEYXkgJiYgIW5ld1Bvcy5hbGxEYXkpIHtcbiAgICAgICAgICAgIGV2ZW50LmVuZCA9IHRpbWVBZGQobmV3UG9zLnN0YXJ0LCBwYWdlLmZmX2R1cmF0aW9uKVxuICAgICAgICAgICAgbmV3UG9zLnNldEVuZChldmVudC5lbmQpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgbmV3UHJvcCA9IENhbGVuZGFyRXZlbnRUb0lEYXRlKGV2ZW50KVxuICAgICAgICAgIGlmIChuZXdQb3MuYWxsRGF5KSB7XG4gICAgICAgICAgICBuZXdQcm9wWydmZl9kdXJhdGlvbiddID0gbWlsbGlzZWNUb1N0cmluZyhcbiAgICAgICAgICAgICAgcGFnZS5mZl9kdXJhdGlvbj8uYXMoXCJtaWxsaXNlY29uZHNcIilcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLm5vdGVNYW5hZ2VyLmNoYW5nZVByb3BlcnR5RmlsZShuZXdQb3MuaWQsIG5ld1Byb3ApXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSxcbiAgICAgIHNlbGVjdDogKHN0YXJ0OiBEYXRlLCBlbmQ6IERhdGUsIGFsbERheTogYm9vbGVhbiwgX192aWV3TW9kZTogYW55KSA9PiB7XG4gICAgICAgIG5ldyBuYW1lTW9kYWwoXG4gICAgICAgICAgdGhpcy5hcHAsXG4gICAgICAgICAgYXN5bmMgKG5hbWVPZkZpbGU6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKCFuYW1lT2ZGaWxlKVxuICAgICAgICAgICAgICAgIHRocm93IDFcblxuICAgICAgICAgICAgICBjb25zdCBwYXRoT2ZGaWxlID0gdGhpcy5wbGFjZUZvckNyZWF0aW5nTm90ZSArIGAvJHtuYW1lT2ZGaWxlfS5tZGBcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy5ub3RlTWFuYWdlci5jcmVhdGVGaWxlKHBhdGhPZkZpbGUpXG5cbiAgICAgICAgICAgICAgc2V0VGltZW91dChcbiAgICAgICAgICAgICAgICAoKSA9PiB0aGlzLm5vdGVNYW5hZ2VyLmNoYW5nZVByb3BlcnR5RmlsZShcbiAgICAgICAgICAgICAgICAgIHBhdGhPZkZpbGUsXG4gICAgICAgICAgICAgICAgICBDYWxlbmRhckV2ZW50VG9JRGF0ZSh7c3RhcnQsIGVuZCwgYWxsRGF5fSlcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIDE1MDBcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKVxuICAgICAgICAgICAgICBuZXcgTm90aWNlKFwiSG0uLi4gZXJyb3IuLi5cIilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICkub3BlbigpXG4gICAgICB9LFxuICAgICAgb3BlbkNvbnRleHRNZW51Rm9yRXZlbnQ6IChlOiBJRXZlbnQsIG1vdXNlRXZlbnQ6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAgICAgdGhpcy5jb250ZXh0TWVudUZvckV2ZW50KGUsIG1vdXNlRXZlbnQpXG4gICAgICB9LFxuICAgICAgc2xvdER1cmF0aW9uOiB0aGlzLmNhbGVuZGFyU2V0dGluZ3Muc2xvdER1cmF0aW9uXG4gICAgfVxuXG4gICAgaWYgKFBsYXRmb3JtLmlzTW9iaWxlKSB7XG4gICAgICByZXN1bHQuZXZlbnRDbGljayA9IChhcmc6IGFueSkgPT4ge1xuICAgICAgICBjb25zdCB7ZXZlbnQsIGpzRXZlbnR9ID0gYXJnXG4gICAgICAgIHRoaXMuY29udGV4dE1lbnVGb3JFdmVudChldmVudCwganNFdmVudClcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5vcGVuQ29udGV4dE1lbnVGb3JFdmVudCA9IChfOklFdmVudCwgX186TW91c2VFdmVudCkgPT4ge31cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBwcml2YXRlIGNvbnRleHRNZW51Rm9yRXZlbnQoZXZlbnQ6IElFdmVudCwgbW91c2VFdmVudDogTW91c2VFdmVudCkge1xuICAgIGNvbnN0IG1lbnUgPSBuZXcgTWVudVxuXG4gICAgbWVudS5hZGRJdGVtKFxuICAgICAgKGl0ZW0pID0+IGl0ZW0uc2V0VGl0bGUoZXZlbnQuaWQpXG4gICAgICAgIC5vbkNsaWNrKGFzeW5jICgpID0+IHRoaXMubm90ZU1hbmFnZXIub3Blbk5vdGUoZXZlbnQpKVxuICAgIClcblxuICAgIG1lbnUuc2hvd0F0TW91c2VFdmVudChtb3VzZUV2ZW50KVxuICB9XG59XG5cbmNsYXNzIG5hbWVNb2RhbCBleHRlbmRzIE1vZGFsIHtcbiAgcHJpdmF0ZSByZXN1bHQ6IHN0cmluZ1xuICBwcml2YXRlIG9uU3VibWl0OiBGdW5jdGlvblxuXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBvblN1Ym1pdDogRnVuY3Rpb24pIHtcbiAgICBzdXBlcihhcHApO1xuICAgIHRoaXMub25TdWJtaXQgPSBvblN1Ym1pdDtcbiAgfVxuXG4gIG9uT3BlbigpIHtcbiAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpc1xuXG4gICAgY29udGVudEVsLmNyZWF0ZUVsKFwiaDFcIiwgeyB0ZXh0OiBcIk5hbWUgb2YgdGFza1wiIH0pXG5cbiAgICBuZXcgU2V0dGluZyhjb250ZW50RWwpXG4gICAgLnNldE5hbWUoXCJOYW1lXCIpXG4gICAgLmFkZFRleHQoXG4gICAgICB0ZXh0ID0+IHRleHQub25DaGFuZ2UodmFsdWUgPT4gdGhpcy5yZXN1bHQgPSB2YWx1ZSlcbiAgICApXG5cbiAgICBuZXcgU2V0dGluZyhjb250ZW50RWwpXG4gICAgLmFkZEJ1dHRvbihcbiAgICAgIChidG4pID0+IGJ0bi5zZXRCdXR0b25UZXh0KFwiU3VibWl0XCIpXG4gICAgICAgIC5zZXRDdGEoKVxuICAgICAgICAub25DbGljaygoKSA9PiB7XG4gICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgIHRoaXMub25TdWJtaXQodGhpcy5yZXN1bHQpO1xuICAgICAgICB9KSk7XG4gIH1cblxuICBvbkNsb3NlKCkge1xuICAgIHRoaXMuY29udGVudEVsLmVtcHR5KCk7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBEVVJBVElPTl9UWVBFUyB9IGZyb20gXCJvYnNpZGlhbi1kYXRhdmlld1wiXG5cbmV4cG9ydCBjbGFzcyBTcmMge1xuICBjb25zdHJ1Y3RvcihwYXRoOiBzdHJpbmcpIHtcbiAgICB0aGlzLl9wYXRoID0gcGF0aDtcbiAgICB0aGlzLl9leGNsdWRlcyA9IFtdO1xuICB9XG5cbiAgcHVibGljIGFkZEV4Y2x1ZGVzKGV4Y2x1ZGVzOiBzdHJpbmdbXSk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGlzT2sgPSBleGNsdWRlcy5ldmVyeShcbiAgICAgIGV4Y2x1ZGUgPT4ge1xuICAgICAgICBpZiAoIWV4Y2x1ZGUuc3RhcnRzV2l0aCh0aGlzLl9wYXRoKSlcbiAgICAgICAgICByZXR1cm4gZmFsc2VcblxuICAgICAgICBpZiAoZXhjbHVkZSAhPT0gdGhpcy5fcGF0aClcbiAgICAgICAgICByZXR1cm4gZmFsc2VcblxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIClcblxuICAgIGlmICghaXNPaylcbiAgICAgIHJldHVybiBmYWxzZVxuXG4gICAgdGhpcy5fZXhjbHVkZXMucHVzaCguLi5leGNsdWRlcylcbiAgICB0aGlzLl9leGNsdWRlcyA9IHRoaXMuX2V4Y2x1ZGVzLnVuaXF1ZSgpXG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgcHVibGljIGluY2x1ZGVzKHBhdGg6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGlmICggIXBhdGguc3RhcnRzV2l0aCh0aGlzLl9wYXRoKSApIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGlmICghdGhpcy5fZXhjbHVkZXMubGVuZ3RoKVxuICAgICAgcmV0dXJuIHRydWVcblxuICAgIHJldHVybiB0aGlzLl9leGNsdWRlcy5zb21lKFxuICAgICAgZXhjbHVkZSA9PiB7XG4gICAgICAgIHBhdGguc3RhcnRzV2l0aChleGNsdWRlKVxuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIHByaXZhdGUgX3BhdGg6IHN0cmluZztcblxuICBnZXQgcGF0aCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9wYXRoO1xuICB9XG5cbiAgcHJpdmF0ZSBfZXhjbHVkZXM6IHN0cmluZ1tdO1xuXG4gIGdldCBleGNsdWRlcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHN0cnVjdHVyZWRDbG9uZSh0aGlzLl9leGNsdWRlcyk7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgQ2FsZW5kYXJTZXR0aW5ncyA9IHtcbiAgICBzbG90RHVyYXRpb246IHN0cmluZyxcbiAgICBjb2xvdXJzOiB7XG4gICAgICBmcmVxdWVuY3k6IHN0cmluZyxcbiAgICAgIGRvbmUgICAgIDogc3RyaW5nLFxuICAgICAgdGljayAgICAgOiBzdHJpbmcsXG4gICAgICBkZWZhdWx0ICA6IHN0cmluZyxcbiAgICB9LFxuICAgIHJlc3RUaW1lOiB7XG4gICAgICAgIHN0YXJ0VGltZTogc3RyaW5nLFxuICAgICAgICBlbmRUaW1lOiBzdHJpbmcsXG4gICAgICAgIGNvbG9yOiBzdHJpbmcsXG5cbiAgICAgICAgLy8gVE9ETyByZW1vdmUgYW55XG4gICAgICAgIGRheXNPZldlZWs6YW55LFxuICAgICAgICBkaXNwbGF5OmFueVxuICAgIH1bXVxuICB9XG5cbmV4cG9ydCB0eXBlIFBsdWdpblNldHRpbmdzID0ge1xuICBzdGF0dXNDb3JyZWN0b3I6IHtcbiAgICBpc09uOiBib29sZWFuLFxuICAgIHN0YXJ0T25TdGFydFVwOiBib29sZWFuXG4gIH0sXG4gIGNhbGVuZGFyOiBDYWxlbmRhclNldHRpbmdzLFxuICBzb3VyY2U6IHtcbiAgICBub3RlU291cmNlczogU3JjW10sXG5cbiAgICAvLyBOT1RFIGRlZmF1bHQgcGF0aCB3aGVyZSBub3RlIHdpbGwgYmUgY3JlYXRlZFxuICAgIGRlZmF1bHRDcmVhdGVQYXRoOiBzdHJpbmdcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIElEYXRlIHtcbiAgLy8gVE9ETyBkYXRlIFx1MDQzQ1x1MDQzRVx1MDQzNlx1MDQzNVx1MDQ0MiBcdTA0MzggXHUwNDNEXHUwNDM1IFx1MDQzMVx1MDQ0Qlx1MDQ0Mlx1MDQ0QyAoXHUwNDQxXHUwNDNDLiBmaWxlTWFuYWdlci50cy9nZXRQYWdlKVxuICBmZl9kYXRlOiBEYXRlXG4gIGZmX3RpbWVTdGFydDogRFVSQVRJT05fVFlQRVNcbiAgZmZfZHVyYXRpb246IERVUkFUSU9OX1RZUEVTXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVRpY2sgZXh0ZW5kcyBJRGF0ZSB7XG4gIG5hbWU6IHN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElQYWdlIGV4dGVuZHMgSURhdGUge1xuICBmaWxlOiB7XG4gICAgcGF0aDogc3RyaW5nLFxuICAgIG5hbWU6IHN0cmluZ1xuICB9LFxuICB0aWNrczogSVRpY2tbXVxuICBmZl9mcmVxdWVuY3k/OiBzdHJpbmdcbiAgZmZfc3RhdHVzPzogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUV2ZW50IHtcbiAgc3RhcnQ6IERhdGVcbiAgZW5kPzogRGF0ZVxuICBpZDogc3RyaW5nXG4gIHRpdGxlOiBzdHJpbmdcbiAgYWxsRGF5OiBib29sZWFuXG4gIGNvbG9yPzogc3RyaW5nXG4gIGJvcmRlckNvbG9yOiBzdHJpbmdcbiAgZWRpdGFibGU6IGJvb2xlYW5cbiAgZXh0ZW5kZWRQcm9wcz86IHtcbiAgICB0aWNrTmFtZTogc3RyaW5nXG4gICAgbm90ZVBhdGg6IHN0cmluZ1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2FsZW5kYXJFdmVudCB7XG4gIHN0YXJ0OiBEYXRlXG4gIGFsbERheTogYm9vbGVhblxuICBlbmQ/OiBEYXRlXG59XG5cbi8vIElORk8gXHUwNDREXHUwNDQyXHUwNDNFIFx1MDQzOFx1MDQzRFx1MDQ0Mlx1MDQzNVx1MDQ0MFx1MDQ0NFx1MDQzNVx1MDQzOVx1MDQ0MSBcdTA0MzRcdTA0M0JcdTA0NEYgQ2FjaGVcbmV4cG9ydCBpbnRlcmZhY2UgSVN1YnNjcmliZXIge1xuICByZXNldCgpOiB2b2lkXG4gIGFkZEZpbGUoXzogSVBhZ2UpOiB2b2lkXG4gIGRlbGV0ZUZpbGUoXzogSVBhZ2UpOiB2b2lkXG4gIGNoYW5nZUZpbGUobmV3UGFnZTogSVBhZ2UsIG9sZFBhZ2U6IElQYWdlKTogdm9pZFxuICByZW5hbWVGaWxlKG5ld1BhZ2U6IElQYWdlLCBvbGRQYWdlOiBJUGFnZSk6IHZvaWRcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJVGFza3Mge1xuICBkb25lOiBudW1iZXIsXG4gIGFsbDogbnVtYmVyXG59XG4iLCAiaW1wb3J0IHsgUGx1Z2luU2V0dGluZ3MsIFNyYyB9IGZyb20gXCIuL3R5cGVzXCJcblxuZXhwb3J0IGNvbnN0IE1TR19QTEdfTkFNRSA9IFwiTXlDYWxlbmRhclwiXG5cbmNvbnN0IEVWRU5UX1NSQyA9IFwiZGF0YWJhc2VzXCJcbmNvbnN0IFBMQUNFX0ZPUl9DUkVBVElOR19OT1RFID0gXCJkYXRhYmFzZXNcIlxuXG5jb25zdCBkYXlzT2ZXZWVrID0gWyAnMScsJzInLCczJywnNCcsJzUnLCc2JywnMCcgXSAvLyB0aGVzZSByZWN1cnJlbnQgZXZlbnRzIG1vdmUgc2VwYXJhdGVseVxuY29uc3QgZGlzcGxheSA9ICdiYWNrZ3JvdW5kJ1xuZXhwb3J0IGNvbnN0IENPTE9VUl9SRVNUICA9ICcjMzA1QjYwJ1xuZXhwb3J0IGNvbnN0IENPTE9VUl9TTEVFUCA9ICcjY2MwMDAwJ1xuXG5leHBvcnQgY29uc3QgREVGQVVMVF9TRVRUSU5HUzogUGx1Z2luU2V0dGluZ3MgPSB7XG4gIHN0YXR1c0NvcnJlY3Rvcjoge1xuICAgIGlzT246IHRydWUsXG4gICAgc3RhcnRPblN0YXJ0VXA6IHRydWVcbiAgfSxcbiAgY2FsZW5kYXI6IHtcbiAgICBzbG90RHVyYXRpb246IFwiMDA6MzA6MDBcIixcbiAgICBjb2xvdXJzOiB7XG4gICAgICBmcmVxdWVuY3k6IFwiIzhBMTcxN1wiLFxuICAgICAgZG9uZSAgICAgOiBcIiMwMDhFMDRcIixcbiAgICAgIHRpY2sgICAgIDogXCIjNDU3RTdFXCIsXG4gICAgICBkZWZhdWx0ICA6IFwiIzVlM2ZhOFwiLFxuICAgIH0sXG4gICAgcmVzdFRpbWU6IFtcbiAgICAgIHtkYXlzT2ZXZWVrLGRpc3BsYXksXG4gICAgICAgICAgc3RhcnRUaW1lOiAnMDowMDowMCcsXG4gICAgICAgICAgZW5kVGltZTogJzg6MDA6MDAnLFxuICAgICAgICAgIGNvbG9yOiBDT0xPVVJfU0xFRVAsXG4gICAgICB9LFxuICAgICAge2RheXNPZldlZWssZGlzcGxheSxcbiAgICAgICAgICBzdGFydFRpbWU6ICcyNDowMDowMCcsXG4gICAgICAgICAgZW5kVGltZTogJzI0OjAwOjAwJyxcbiAgICAgICAgICBjb2xvcjogQ09MT1VSX1NMRUVQLFxuICAgICAgfSxcbiAgICAgIHtkYXlzT2ZXZWVrLGRpc3BsYXksXG4gICAgICAgICAgc3RhcnRUaW1lOiAnMDowMDowMCcsXG4gICAgICAgICAgZW5kVGltZTogJzg6MzA6MDAnLFxuICAgICAgICAgIGNvbG9yOiBDT0xPVVJfUkVTVCxcbiAgICAgIH0sXG4gICAgICB7ZGF5c09mV2VlayxkaXNwbGF5LFxuICAgICAgICAgIHN0YXJ0VGltZTogJzIzOjAwOjAwJyxcbiAgICAgICAgICBlbmRUaW1lOiAnMjQ6MDA6MDAnLFxuICAgICAgICAgIGNvbG9yOiBDT0xPVVJfUkVTVCxcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHNvdXJjZToge1xuICAgIG5vdGVTb3VyY2VzOiBbbmV3IFNyYyhFVkVOVF9TUkMpXSxcblxuICAgIC8vIE5PVEUgZGVmYXVsdCBwYXRoIHdoZXJlIG5vdGUgd2lsbCBiZSBjcmVhdGVkXG4gICAgZGVmYXVsdENyZWF0ZVBhdGg6IFBMQUNFX0ZPUl9DUkVBVElOR19OT1RFXG4gIH1cblxufVxuXG5leHBvcnQgZW51bSBDQUNIRV9JRCB7XG4gIENBTEVOREFSID0gMSxcbiAgU1RBVFVTX0NPUlJFQ1RPUixcbiAgVElDS19DSEVDS0VSXG59XG5cbmV4cG9ydCBjb25zdCBWSUVXX1RZUEUgPSBcIm15LW9ic2lkaWFuLWNhbGVuZGFyLXBsdWdpblwiXG5cblxuLy8gVE9ETyBcdTA0M0ZcdTA0MzVcdTA0NDBcdTA0MzVcdTA0MzRcdTA0MzVcdTA0M0JcdTA0MzBcdTA0NDJcdTA0NEMgXHUwNDMyIFRFWFQgPSB7RE9ORS4uLkJMT0NLRUR9XG5leHBvcnQgY29uc3QgVEVYVF9ET05FID0gXCJcdUQ4M0RcdURGRTJkb25lXCJcbmV4cG9ydCBjb25zdCBURVhUX0lOX1BST0dSRVNTID0gXCJcdUQ4M0RcdUREMzVpbiBwcm9ncmVzc1wiXG5leHBvcnQgY29uc3QgVEVYVF9TT09OID0gXCJcdUQ4M0RcdURGRTNzb29uXCJcbmV4cG9ydCBjb25zdCBURVhUX0NISUxEX0lOX1BST0dSRVNTID0gXCJcdUQ4M0RcdURGRTFcdUQ4M0RcdURGRTZjaGlsZCBpbiBwcm9ncmVzc1wiXG5leHBvcnQgY29uc3QgVEVYVF9CTE9DS0VEID0gXCJcdUQ4M0RcdURGRTFibG9ja2VkXCJcblxuZXhwb3J0IGNvbnN0IEZPUk1BVF9EQVkgPSAnZCdcbmV4cG9ydCBjb25zdCBGT1JNQVRfSE9VUiA9ICdoJ1xuZXhwb3J0IGNvbnN0IEZPUk1BVF9NSU5VVEUgPSAnbSdcblxuZXhwb3J0IGNvbnN0IEJBQ0tHUk9VTkRfQ09MT1VSID0ge1xuICAgIGh1ZToge1xuICAgICAgICBzaGlmdDogMCxcbiAgICAgICAgbWluOiAwLFxuICAgICAgICBtYXg6IDM2MFxuICAgIH0sXG4gICAgc2F0dXJhdGlvbjoge1xuICAgICAgICBzaGlmdDogMCxcbiAgICAgICAgbWluOiA3MCxcbiAgICAgICAgbWF4OiA5MFxuICAgIH0sXG4gICAgbGlnaHRuZXNzOiB7XG4gICAgICAgIHNoaWZ0OiAwLFxuICAgICAgICBtaW46IDMwLFxuICAgICAgICBtYXg6IDUwXG4gICAgfVxufVxuXG5cbmNvbnN0IE1pbGxpc2Vjc0luU2Vjb25kID0gMTAwMFxuY29uc3QgU2Vjc0luTWludXRlID0gNjBcbmNvbnN0IE1pbnV0ZXNJbkhvdXIgPSA2MFxuZXhwb3J0IGNvbnN0IEhvdXJzSW5EYXkgPSAyNFxuZXhwb3J0IGNvbnN0IE1pbGxpc2Vjc0luTWludXRlID0gTWlsbGlzZWNzSW5TZWNvbmQgKiBTZWNzSW5NaW51dGVcbmV4cG9ydCBjb25zdCBNaWxsaXNlY3NJbkhvdXIgPSBNaWxsaXNlY3NJbk1pbnV0ZSAqIE1pbnV0ZXNJbkhvdXJcbmV4cG9ydCBjb25zdCBNaWxsaXNlY3NJbkRheSA9IE1pbGxpc2Vjc0luSG91ciAqIEhvdXJzSW5EYXlcbiIsICJpbXBvcnQgeyBJUGFnZSwgSVRpY2ssIElEYXRlLCBDYWxlbmRhckV2ZW50LCBJVGFza3MsIElFdmVudCB9IGZyb20gXCIuL3R5cGVzXCI7XG5pbXBvcnQgeyBEYXRhdmlld0FwaSB9IGZyb20gXCJvYnNpZGlhbi1kYXRhdmlldy9saWIvYXBpL3BsdWdpbi1hcGlcIlxuaW1wb3J0IHsgZ2V0QVBJIH0gZnJvbSBcIm9ic2lkaWFuLWRhdGF2aWV3XCJcbmltcG9ydCB7IERVUkFUSU9OX1RZUEVTIH0gZnJvbSBcIm9ic2lkaWFuLWRhdGF2aWV3XCJcblxuaW1wb3J0IHtcbiAgVEVYVF9ET05FLFxuICBNaWxsaXNlY3NJbkhvdXIsXG4gIE1pbGxpc2Vjc0luRGF5LFxuICBNaWxsaXNlY3NJbk1pbnV0ZSxcbiAgRk9STUFUX0RBWSxcbiAgRk9STUFUX0hPVVIsXG4gIEZPUk1BVF9NSU5VVEUsXG4gIEJBQ0tHUk9VTkRfQ09MT1VSLFxufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuaW1wb3J0IE15UGx1Z2luIGZyb20gXCIuL21haW5cIjtcbmltcG9ydCB7IENhY2hlIH0gZnJvbSBcIi4vY2FjaGVcIjtcbmltcG9ydCBOb3RlTWFuYWdlciBmcm9tIFwiLi9Ob3RlTWFuYWdlclwiO1xuXG5jb25zdCBTTEVFUF9USU1FID0gMTAwMCAvLyBtc1xuXG5leHBvcnQgY29uc3QgZHYgPSBnZXRBUEkoKSBhcyBEYXRhdmlld0FwaVxuXG5mdW5jdGlvbiBwYXRoVG9GaWxlV2l0aG91dEZpbGVOYW1lKHBhdGg6IHN0cmluZykge1xuICBjb25zdCBwYXRoX3NlcGFyYXRvciA9IHBhdGgubGFzdEluZGV4T2YoXCIvXCIpO1xuICBpZiAocGF0aF9zZXBhcmF0b3IgIT09IC0xKVxuICAgIHJldHVybiBwYXRoLnNsaWNlKDAsIHBhdGhfc2VwYXJhdG9yKTtcbiAgcmV0dXJuIFwiXCI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBJRGF0ZVRvQ2FsZW5kYXJFdmVudChhcmdzOiBJRGF0ZSk6IENhbGVuZGFyRXZlbnQge1xuICBjb25zdCBzdHJ1Y3R1cmU6IENhbGVuZGFyRXZlbnQgPSB7XG4gICAgc3RhcnQ6IG5ldyBEYXRlKGFyZ3MuZmZfZGF0ZSksXG4gICAgYWxsRGF5OiBmYWxzZSxcbiAgfVxuXG4gIGlmIChhcmdzLmZmX2R1cmF0aW9uKSB7XG4gICAgc3RydWN0dXJlLnN0YXJ0LnNldEhvdXJzICAoYXJncy5mZl90aW1lU3RhcnQ/LnZhbHVlcz8uaG91cnMgICB8fCAwKVxuICAgIHN0cnVjdHVyZS5zdGFydC5zZXRNaW51dGVzKGFyZ3MuZmZfdGltZVN0YXJ0Py52YWx1ZXM/Lm1pbnV0ZXMgfHwgMClcblxuICAgIGxldCB0bXBUaW1lID0gbmV3IERhdGUoc3RydWN0dXJlLnN0YXJ0KVxuICAgIGlmIChhcmdzLmZmX2R1cmF0aW9uPy52YWx1ZXM/Lm1pbnV0ZXMgfHwgYXJncy5mZl9kdXJhdGlvbj8udmFsdWVzPy5ob3VycyB8fCBhcmdzLmZmX2R1cmF0aW9uPy52YWx1ZXM/LmRheXMpIHtcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gYXJncy5mZl9kdXJhdGlvbi52YWx1ZXNcblxuICAgICAgdG1wVGltZS5zZXRNaW51dGVzKFxuICAgICAgICB0bXBUaW1lLmdldE1pbnV0ZXMoKSArIChkdXJhdGlvbi5taW51dGVzIHx8IDApXG4gICAgICApXG4gICAgICB0bXBUaW1lLnNldEhvdXJzKFxuICAgICAgICB0bXBUaW1lLmdldEhvdXJzKCkgKyAoZHVyYXRpb24uaG91cnMgfHwgMClcbiAgICAgIClcbiAgICAgIHRtcFRpbWUuc2V0RGF0ZShcbiAgICAgICAgdG1wVGltZS5nZXREYXRlKCkgKyAoZHVyYXRpb24uZGF5cyB8fCAwKVxuICAgICAgKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHN0cnVjdHVyZS5hbGxEYXkgPSB0cnVlXG4gICAgfVxuXG4gICAgaWYgKCFhcmdzLmZmX3RpbWVTdGFydD8udmFsdWVzKVxuICAgICAgc3RydWN0dXJlLmFsbERheSA9IHRydWVcblxuICAgIHN0cnVjdHVyZS5lbmQgPSB0bXBUaW1lXG4gIH1cbiAgZWxzZSBpZiAoYXJncy5mZl9kdXJhdGlvbikge1xuICAgIHN0cnVjdHVyZS5hbGxEYXkgPSB0cnVlXG4gIH1cbiAgZWxzZSBzdHJ1Y3R1cmUuYWxsRGF5ID0gdHJ1ZVxuXG4gIHJldHVybiBzdHJ1Y3R1cmVcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIENhbGVuZGFyRXZlbnRUb0lEYXRlKGV2ZW50OiBDYWxlbmRhckV2ZW50KTogSURhdGUge1xuICBjb25zdCB7c3RhcnQsIGVuZCwgYWxsRGF5fSA9IGV2ZW50XG4gIC8vICEgXHUwNDM0XHUwNDNCXHUwNDRGIElTTyAoXHUwNDNFXHUwNDNEIFx1MDQzRlx1MDQzNVx1MDQ0MFx1MDQzNVx1MDQzMlx1MDQzRVx1MDQzNFx1MDQzOFx1MDQ0MiBcdTA0MzIgXHUwNDMzXHUwNDQwXHUwNDM4XHUwNDNEXHUwNDMyXHUwNDM4XHUwNDQ3IFx1MDQzQ1x1MDQzRVx1MDQzNSBcdTA0MzJcdTA0NDBcdTA0MzVcdTA0M0NcdTA0NEYpXG4gIC8vIFx1MDQ0RiBcdTA0NDJcdTA0NDNcdTA0NDIgXHUwNDMzXHUwNDNFXHUwNDMyXHUwNDNFXHUwNDQwXHUwNDRFLCBcdTA0NDdcdTA0NDJcdTA0M0UgXHUwNDRGIFx1MDQzMiBcdTA0MzNcdTA0NDBcdTA0MzhcdTA0M0RcdTA0MzJcdTA0MzhcdTA0NDdcdTA0MzVcbiAgc3RhcnQuc2V0TWludXRlcyhcbiAgICBzdGFydC5nZXRNaW51dGVzKCkgLSBzdGFydC5nZXRUaW1lem9uZU9mZnNldCgpXG4gIClcblxuICBjb25zdCByZXN1bHQ6IElEYXRlID0ge1xuICAgIGZmX2R1cmF0aW9uOiBcIlwiLFxuICAgIGZmX3RpbWVTdGFydDogXCJcIixcbiAgICBmZl9kYXRlOiBuZXcgRGF0ZShzdGFydClcbiAgfVxuXG4gIC8vICEgXHUwNDQyXHUwNDQzXHUwNDQyIFx1MDQ0M1x1MDQzMVx1MDQzOFx1MDQ0MFx1MDQzMFx1MDQ0RSBcdTA0MzNcdTA0NDBcdTA0MzhcdTA0M0RcdTA0MzJcdTA0MzhcdTA0NDcgXHUwNDM0XHUwNDNCXHUwNDRGIGdldCdcdTA0MzVcdTA0NDBcdTA0M0VcdTA0MzIgXHUwNDMyXHUwNDNEXHUwNDM4XHUwNDM3XHUwNDQzXG4gIHN0YXJ0LnNldE1pbnV0ZXMoXG4gICAgc3RhcnQuZ2V0TWludXRlcygpICsgc3RhcnQuZ2V0VGltZXpvbmVPZmZzZXQoKVxuICApXG5cbiAgbGV0IHNyY01pbGxpc2VjID0gZW5kXG4gIC8vIEB0cy1pZ25vcmVcbiAgPyBlbmQgLSBzdGFydFxuICA6IE1pbGxpc2Vjc0luSG91clxuXG4gIGlmIChhbGxEYXkpIHtcbiAgICByZXN1bHRbJ2ZmX3RpbWVTdGFydCddID0gXCJcIlxuICAgIGlmIChzcmNNaWxsaXNlYyA8PSBNaWxsaXNlY3NJbkRheSlcbiAgICAgIHNyY01pbGxpc2VjID0gMFxuICB9XG4gIGVsc2VcbiAgICByZXN1bHRbJ2ZmX3RpbWVTdGFydCddID0gc3RhcnQuZ2V0SG91cnMoKSArICdoJyArIHN0YXJ0LmdldE1pbnV0ZXMoKSArICdtJ1xuXG4gIHJlc3VsdFsnZmZfZHVyYXRpb24nXSA9IG1pbGxpc2VjVG9TdHJpbmcoc3JjTWlsbGlzZWMpXG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGlja3NGcm9tVGV4dCh0ZXh0OiBzdHJpbmcpOiBJVGlja1tdIHtcbiAgY29uc3QgcmVzdWx0ID0gW11cbiAgY29uc3QgcmVnRXhwVGlja3MgPSAvXFxbdDo6LitcXF0vZ21cbiAgY29uc3QgbWF0Y2hlcyA9IHRleHQubWF0Y2gocmVnRXhwVGlja3MpXG5cbiAgaWYgKG1hdGNoZXMpIGZvciAobGV0IG1hdGNoIG9mIG1hdGNoZXMpIHtcbiAgICBjb25zdCBhcmdzID0gbWF0Y2guc2xpY2UoMSwgLTEpLnNwbGl0KFwiOjpcIilbMV0uc3BsaXQoJywnKVxuICAgIGlmICghYXJncylcbiAgICAgIGNvbnRpbnVlXG5cbiAgICBjb25zdCBuYW1lID0gYXJnc1swXT8udHJpbSgpXG4gICAgY29uc3QgZmZfZGF0ZSA9IGR2LmRhdGUoYXJnc1sxXT8udHJpbSgpKVxuICAgIGNvbnN0IGZmX3RpbWVTdGFydCA9IGR2LmR1cmF0aW9uKGFyZ3NbMl0/LnRyaW0oKSlcblxuICAgIGNvbnN0IHRlbXBEdXJhdGlvbiA9IGFyZ3NbM10/LnRyaW0oKVxuICAgIGNvbnN0IGZmX2R1cmF0aW9uID0gdGVtcER1cmF0aW9uID09ICd4J1xuICAgID8gJ3gnXG4gICAgOiBkdi5kdXJhdGlvbihhcmdzWzNdPy50cmltKCkpXG5cbiAgICBpZiAobmFtZSA9PSAnJylcbiAgICAgIGNvbnRpbnVlXG5cbiAgICByZXN1bHQucHVzaChcbiAgICAgIHtuYW1lLCBmZl9kYXRlLCBmZl90aW1lU3RhcnQsIGZmX2R1cmF0aW9ufVxuICAgIClcblxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1pbGxpc2VjVG9TdHJpbmcobWlsbGlzZWM6bnVtYmVyKTogc3RyaW5nIHtcbiAgY29uc3QgZGF5cyA9IE1hdGguZmxvb3IoXG4gICAgICBtaWxsaXNlYyAvIChNaWxsaXNlY3NJbkRheSlcbiAgKVxuICBtaWxsaXNlYyAtPSBkYXlzICogTWlsbGlzZWNzSW5EYXlcblxuICBjb25zdCBob3VycyA9IE1hdGguZmxvb3IoXG4gICAgICBtaWxsaXNlYyAvIChNaWxsaXNlY3NJbkhvdXIpXG4gIClcbiAgbWlsbGlzZWMgLT0gaG91cnMgKiBNaWxsaXNlY3NJbkhvdXJcblxuICBjb25zdCBtaW51dGVzID0gTWF0aC5mbG9vcihcbiAgICAgIG1pbGxpc2VjIC8gKE1pbGxpc2Vjc0luTWludXRlKVxuICApXG4gIG1pbGxpc2VjIC09IG1pbnV0ZXMgKiBNaWxsaXNlY3NJbk1pbnV0ZVxuXG4gIGxldCByZXNTdHJpbmcgPSAnJ1xuICBpZiAoZGF5cylcbiAgICByZXNTdHJpbmcgKz0gZGF5cy50b1N0cmluZygpICsgRk9STUFUX0RBWVxuICBpZiAoaG91cnMpXG4gICAgcmVzU3RyaW5nICs9IGhvdXJzLnRvU3RyaW5nKCkgKyBGT1JNQVRfSE9VUlxuICBpZiAobWludXRlcylcbiAgICByZXNTdHJpbmcgKz0gbWludXRlcy50b1N0cmluZygpICsgRk9STUFUX01JTlVURVxuXG4gIHJldHVybiByZXNTdHJpbmdcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRXF1YWxPYmoob2JqZWN0MTphbnksIG9iamVjdDI6YW55KSB7XG4gIGNvbnN0IGtleXMxID0gT2JqZWN0LmtleXMob2JqZWN0MSk7XG4gIGNvbnN0IGtleXMyID0gT2JqZWN0LmtleXMob2JqZWN0Mik7XG5cbiAgaWYgKGtleXMxLmxlbmd0aCAhPT0ga2V5czIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5czEpIHtcbiAgICBjb25zdCB2YWwxID0gb2JqZWN0MVtrZXldO1xuICAgIGNvbnN0IHZhbDIgPSBvYmplY3QyW2tleV07XG4gICAgY29uc3QgYXJlT2JqZWN0cyA9IGlzT2JqZWN0KHZhbDEpICYmIGlzT2JqZWN0KHZhbDIpO1xuICAgIGlmIChcbiAgICAgIGFyZU9iamVjdHMgJiYgIWlzRXF1YWxPYmoodmFsMSwgdmFsMikgfHxcbiAgICAgICFhcmVPYmplY3RzICYmIHZhbDEgIT09IHZhbDJcbiAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3Qob2JqZWN0OiBhbnkpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnO1xufVxuXG4vLyBcdTA0M0FcdTA0MzBcdTA0M0FcdTA0MzhcdTA0M0MgXHUwNDMxXHUwNDQzXHUwNDM0XHUwNDM1XHUwNDQyIElEIFx1MDQzMiBcdTA0M0FcdTA0MzBcdTA0M0JcdTA0MzVcdTA0M0RcdTA0MzRcdTA0MzBcdTA0NDBcdTA0MzUgXHUwNDQyXHUwNDM4XHUwNDNBXG5leHBvcnQgZnVuY3Rpb24gdGVtcGxhdGVJRFRpY2socGF0aDogc3RyaW5nLCB0aWNrTmFtZTpzdHJpbmcpIHtcbiAgcmV0dXJuIHBhdGggKyB0aWNrTmFtZVxufVxuXG4vLyBcdTA0M0FcdTA0MzBcdTA0M0EgXHUwNDMxXHUwNDQzXHUwNDM0XHUwNDM1XHUwNDQyIFx1MDQzRVx1MDQ0Mlx1MDQzRVx1MDQzMVx1MDQ0MFx1MDQzMFx1MDQzNlx1MDQzMFx1MDQ0Mlx1MDQ0Q1x1MDQ0MVx1MDQ0RiBcdTA0MzIgXHUwNDNBXHUwNDMwXHUwNDNCXHUwNDM1XHUwNDNEXHUwNDM0XHUwNDMwXHUwNDQwXHUwNDM1IFx1MDQ0Mlx1MDQzOFx1MDQzQVxuZXhwb3J0IGZ1bmN0aW9uIHRlbXBsYXRlTmFtZVRpY2soZmlsZU5hbWU6IHN0cmluZywgdGlja05hbWU6c3RyaW5nKSB7XG4gIHJldHVybiBcIihcIitmaWxlTmFtZStcIilcIiArIHRpY2tOYW1lXG59XG5cbmZ1bmN0aW9uIGhhc2hTdHJpbmcoc3RyOiBzdHJpbmcpIHtcbiAgbGV0IGhhc2ggPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGhhc2ggPSAoaGFzaCA8PCA1KSAtIGhhc2ggKyBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICB9XG4gIHJldHVybiBoYXNoO1xufVxuXG4vLyBUT0RPIFx1MDQzRFx1MDQzNSBcdTA0NDBcdTA0MzBcdTA0MzFcdTA0M0VcdTA0NDJcdTA0MzBcdTA0MzVcdTA0NDIgXHUwNDNEXHUwNDMwIFx1MDQzRVx1MDQ0Mlx1MDQ0MFx1MDQzOFx1MDQ0Nlx1MDQzMFx1MDQ0Mlx1MDQzNVx1MDQzQlx1MDQ0Q1x1MDQzRFx1MDQ0Qlx1MDQ0NSBcdTA0NDdcdTA0MzhcdTA0NDFcdTA0M0JcdTA0MzBcdTA0NDVcbi8vIFx1MDQzOCBcdTA0M0ZcdTA0NDBcdTA0MzggbWluID4gbWF4XG5mdW5jdGlvbiB0b1JhbmdlKHNyYzogbnVtYmVyLCBtaW46IG51bWJlciwgbWF4OiBudW1iZXIpIHtcbiAgbWF4IC09IG1pblxuICBzcmMgJT0gbWF4KzFcblxuICByZXR1cm4gKHNyYyArIG1pbilcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENvbG91ckZyb21QYXRoKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IHN0ciA9IHBhdGhUb0ZpbGVXaXRob3V0RmlsZU5hbWUocGF0aClcblxuICAvLyBOT1RFIFx1MDQ0Mlx1MDQzOFx1MDQzRlx1MDQzMCBcdTA0M0FcdTA0MzBcdTA0MzZcdTA0MzRcdTA0NEJcdTA0MzkgXHUwNDNGXHUwNDM1XHUwNDQwXHUwNDMyXHUwNDRCXHUwNDM5LCBcdTA0MzJcdTA0NDJcdTA0M0VcdTA0NDBcdTA0M0VcdTA0MzkgXHUwNDM4XHUwNDNCXHUwNDM4IFx1MDQ0Mlx1MDQ0MFx1MDQzNVx1MDQ0Mlx1MDQzOFx1MDQzOSBcdTA0NDFcdTA0MzhcdTA0M0NcdTA0MzJcdTA0M0VcdTA0M0IgXHUwNDQxXHUwNDQyXHUwNDQwXHUwNDNFXHUwNDNBXHUwNDM4XG4gIGNvbnN0IHN0cjEgPSBoYXNoU3RyaW5nKFsuLi5zdHJdLmZpbHRlcigoXywgaW5kZXgpID0+IChpbmRleCArIDEpICUgMyAhPT0gMCkuam9pbihcIlwiKSlcbiAgY29uc3Qgc3RyMiA9IGhhc2hTdHJpbmcoWy4uLnN0cl0uZmlsdGVyKChfLCBpbmRleCkgPT4gKGluZGV4ICsgMikgJSAzICE9PSAwKS5qb2luKFwiXCIpKVxuICBjb25zdCBzdHIzID0gaGFzaFN0cmluZyhbLi4uc3RyXS5maWx0ZXIoKF8sIGluZGV4KSA9PiAoaW5kZXggKyAzKSAlIDMgIT09IDApLmpvaW4oXCJcIikpXG5cbiAgY29uc3QgaHVlID0gdG9SYW5nZShzdHIxICsgQkFDS0dST1VORF9DT0xPVVIuaHVlLnNoaWZ0LFxuICAgIEJBQ0tHUk9VTkRfQ09MT1VSLmh1ZS5taW4sXG4gICAgQkFDS0dST1VORF9DT0xPVVIuaHVlLm1heFxuICApXG4gIGNvbnN0IHNhdHVyYXRpb24gPSB0b1JhbmdlKHN0cjIgKyBCQUNLR1JPVU5EX0NPTE9VUi5zYXR1cmF0aW9uLnNoaWZ0LFxuICAgIEJBQ0tHUk9VTkRfQ09MT1VSLnNhdHVyYXRpb24ubWluLFxuICAgIEJBQ0tHUk9VTkRfQ09MT1VSLnNhdHVyYXRpb24ubWF4KVxuICBjb25zdCBsaWdodG5lc3MgID0gdG9SYW5nZShzdHIzICsgQkFDS0dST1VORF9DT0xPVVIubGlnaHRuZXNzLnNoaWZ0LFxuICAgIEJBQ0tHUk9VTkRfQ09MT1VSLmxpZ2h0bmVzcy5taW4sXG4gICAgQkFDS0dST1VORF9DT0xPVVIubGlnaHRuZXNzLm1heFxuICApXG4gIHJldHVybiBgaHNsKCR7aHVlfSwgJHtzYXR1cmF0aW9ufSUsICR7bGlnaHRuZXNzfSUpYFxufVxuXG5hc3luYyBmdW5jdGlvbiB3YWl0RHZJbml0KCkge1xuICB3aGlsZSAoIWR2LmluZGV4LmluaXRpYWxpemVkKVxuICAgIGF3YWl0IHNsZWVwKFNMRUVQX1RJTUUpXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXROb3Rlc1dpdGhvdXRQYXJlbnQoc3JjOiBzdHJpbmcpOiBQcm9taXNlPElQYWdlW10+IHtcbiAgYXdhaXQgd2FpdER2SW5pdCgpXG5cbiAgY29uc3QgY2hpbGQgPSBkdi5wYWdlcyhgXCIke3NyY31cImApLndoZXJlKFxuICAgIChwYWdlOiBhbnkpID0+ICFwYWdlLmZmX3BhcmVudFxuICApLmFycmF5KClcblxuICByZXR1cm4gY2hpbGQgYXMgSVBhZ2VbXVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UHJvZ3Jlc3MoY2FjaGU6IENhY2hlLCBub3RlTWFuYWdlcjogTm90ZU1hbmFnZXIsIHBhZ2U6IElQYWdlKTogUHJvbWlzZTxJVGFza3M+IHtcbiAgY29uc3QgcmVzdWx0ID0ge2RvbmU6MCwgYWxsOjB9XG5cbiAgYXdhaXQgd2FpdER2SW5pdCgpXG5cbiAgY29uc3QgcGFnZXMgPSBuZXcgU2V0KClcbiAgY29uc3Qgc3RhY2sgPSBbcGFnZS5maWxlLnBhdGhdXG4gIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgcGF0aCA9IHN0YWNrLnBvcCgpIGFzIHN0cmluZ1xuICAgIGNvbnN0IHBhZ2UgPSBjYWNoZS5nZXRQYWdlKHBhdGgpXG4gICAgY29uc3QgbWV0YSA9IGR2LnBhZ2UocGF0aClcblxuICAgIGlmICghcGFnZSB8fCAhbWV0YSlcbiAgICAgIGNvbnRpbnVlXG5cbiAgICBjb25zdCB0YXNrcyA9IG5vdGVNYW5hZ2VyLmdldFRhc2tDb3VudChwYWdlKVxuXG4gICAgcmVzdWx0LmFsbCAgKz0gIHRhc2tzLmFsbFxuICAgIHJlc3VsdC5kb25lICArPSAgdGFza3MuZG9uZVxuXG5cbiAgICBjb25zdCBpbmxpbmtzID0gbWV0YS5maWxlLmlubGlua3MuYXJyYXkoKVxuICAgIC8vIGlmIChpbmxpbmtzLmxlbmd0aCA9PSAwKSB7XG4gICAgaWYgKHBhZ2UuZmZfc3RhdHVzKSB7XG4gICAgICArK3Jlc3VsdC5hbGxcblxuICAgICAgaWYgKHBhZ2UuZmZfc3RhdHVzID09IFRFWFRfRE9ORSlcbiAgICAgICAgKytyZXN1bHQuZG9uZVxuICAgIH1cbiAgICAvLyB9XG5cbiAgICBmb3IgKGxldCBpbmxpbmsgb2YgaW5saW5rcyApIHtcbiAgICAgIGlmIChwYWdlcy5oYXMoaW5saW5rLnBhdGgpKVxuICAgICAgICBjb250aW51ZVxuXG4gICAgICBwYWdlcy5hZGQoaW5saW5rLnBhdGgpXG4gICAgICBzdGFjay5wdXNoKGlubGluay5wYXRoKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENoaWxkTm90ZVBhdGhzKHBhdGg6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgYXdhaXQgd2FpdER2SW5pdCgpXG5cbiAgY29uc3QgbWV0YSA9IGR2LnBhZ2UocGF0aClcbiAgY29uc3QgaW5saW5rcyA9IG1ldGE/LmZpbGUuaW5saW5rcy5hcnJheSgpXG5cbiAgY29uc3QgcmVzdWx0OiBzdHJpbmdbXSA9IFtdXG4gIGZvciAobGV0IGlubGluayBvZiBpbmxpbmtzKSB7XG4gICAgcmVzdWx0LnB1c2goIGlubGluay5wYXRoIClcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFBhcmVudE5vdGUocGFnZTogSVBhZ2UpOiBQcm9taXNlPChJUGFnZXx1bmRlZmluZWQpW10+IHtcbiAgYXdhaXQgd2FpdER2SW5pdCgpXG5cbiAgY29uc3QgbWV0YSA9IGR2LnBhZ2UocGFnZS5maWxlLnBhdGgpXG4gIGNvbnN0IG91dGxpbmtzID0gbWV0YT8uZmlsZS5vdXRsaW5rcy5hcnJheSgpXG5cbiAgY29uc3QgcmVzdWx0OiBJUGFnZVtdID0gW11cbiAgZm9yIChsZXQgb3V0bGluayBvZiBvdXRsaW5rcykge1xuICAgIHJlc3VsdC5wdXNoKCBkdi5wYWdlKG91dGxpbmsucGF0aCkgYXMgSVBhZ2UgKVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2FmZVBhcnNlSW50KHN0cjogc3RyaW5nKTogbnVtYmVyIHtcbiAgY29uc3QgbnVtID0gTnVtYmVyKHN0cik7XG4gIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKG51bSkgPyBudW0gOiBOYU47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aW1lQWRkKHN0YXJ0OiBEYXRlLCBkdXJhdGlvbjogRFVSQVRJT05fVFlQRVMpOiBEYXRlIHtcbiAgY29uc3QgZHVyID0gZHVyYXRpb24uYXMoXCJtaW51dGVzXCIpXG5cbiAgY29uc3QgcmVzdWx0ID0gbmV3IERhdGUoc3RhcnQpXG4gIHJlc3VsdC5zZXRNaW51dGVzKHJlc3VsdC5nZXRNaW51dGVzKCkgKyBkdXIpXG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4iLCAiaW1wb3J0IHsgRU1QVFlfQVJSIH0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XG5cbi8qKlxuICogQXNzaWduIHByb3BlcnRpZXMgZnJvbSBgcHJvcHNgIHRvIGBvYmpgXG4gKiBAdGVtcGxhdGUgTywgUCBUaGUgb2JqIGFuZCBwcm9wcyB0eXBlc1xuICogQHBhcmFtIHtPfSBvYmogVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG9cbiAqIEBwYXJhbSB7UH0gcHJvcHMgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbVxuICogQHJldHVybnMge08gJiBQfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKG9iaiwgcHJvcHMpIHtcblx0Ly8gQHRzLWlnbm9yZSBXZSBjaGFuZ2UgdGhlIHR5cGUgb2YgYG9iamAgdG8gYmUgYE8gJiBQYFxuXHRmb3IgKGxldCBpIGluIHByb3BzKSBvYmpbaV0gPSBwcm9wc1tpXTtcblx0cmV0dXJuIC8qKiBAdHlwZSB7TyAmIFB9ICovIChvYmopO1xufVxuXG4vKipcbiAqIFJlbW92ZSBhIGNoaWxkIG5vZGUgZnJvbSBpdHMgcGFyZW50IGlmIGF0dGFjaGVkLiBUaGlzIGlzIGEgd29ya2Fyb3VuZCBmb3JcbiAqIElFMTEgd2hpY2ggZG9lc24ndCBzdXBwb3J0IGBFbGVtZW50LnByb3RvdHlwZS5yZW1vdmUoKWAuIFVzaW5nIHRoaXMgZnVuY3Rpb25cbiAqIGlzIHNtYWxsZXIgdGhhbiBpbmNsdWRpbmcgYSBkZWRpY2F0ZWQgcG9seWZpbGwuXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIG5vZGUgdG8gcmVtb3ZlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVOb2RlKG5vZGUpIHtcblx0bGV0IHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG5cdGlmIChwYXJlbnROb2RlKSBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xufVxuXG5leHBvcnQgY29uc3Qgc2xpY2UgPSBFTVBUWV9BUlIuc2xpY2U7XG4iLCAiaW1wb3J0IHsgX2NhdGNoRXJyb3IgfSBmcm9tICcuL2RpZmYvY2F0Y2gtZXJyb3InO1xuXG4vKipcbiAqIFRoZSBgb3B0aW9uYCBvYmplY3QgY2FuIHBvdGVudGlhbGx5IGNvbnRhaW4gY2FsbGJhY2sgZnVuY3Rpb25zXG4gKiB0aGF0IGFyZSBjYWxsZWQgZHVyaW5nIHZhcmlvdXMgc3RhZ2VzIG9mIG91ciByZW5kZXJlci4gVGhpcyBpcyB0aGVcbiAqIGZvdW5kYXRpb24gb24gd2hpY2ggYWxsIG91ciBhZGRvbnMgbGlrZSBgcHJlYWN0L2RlYnVnYCwgYHByZWFjdC9jb21wYXRgLFxuICogYW5kIGBwcmVhY3QvaG9va3NgIGFyZSBiYXNlZCBvbi4gU2VlIHRoZSBgT3B0aW9uc2AgdHlwZSBpbiBgaW50ZXJuYWwuZC50c2BcbiAqIGZvciBhIGZ1bGwgbGlzdCBvZiBhdmFpbGFibGUgb3B0aW9uIGhvb2tzIChtb3N0IGVkaXRvcnMvSURFcyBhbGxvdyB5b3UgdG9cbiAqIGN0cmwrY2xpY2sgb3IgY21kK2NsaWNrIG9uIG1hYyB0aGUgdHlwZSBkZWZpbml0aW9uIGJlbG93KS5cbiAqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5PcHRpb25zfVxuICovXG5jb25zdCBvcHRpb25zID0ge1xuXHRfY2F0Y2hFcnJvclxufTtcblxuZXhwb3J0IGRlZmF1bHQgb3B0aW9ucztcbiIsICJpbXBvcnQgeyBzbGljZSB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgb3B0aW9ucyBmcm9tICcuL29wdGlvbnMnO1xuXG5sZXQgdm5vZGVJZCA9IDA7XG5cbi8qKlxuICogQ3JlYXRlIGFuIHZpcnR1YWwgbm9kZSAodXNlZCBmb3IgSlNYKVxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZVtcInR5cGVcIl19IHR5cGUgVGhlIG5vZGUgbmFtZSBvciBDb21wb25lbnRcbiAqIGNvbnN0cnVjdG9yIGZvciB0aGlzIHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtvYmplY3QgfCBudWxsIHwgdW5kZWZpbmVkfSBbcHJvcHNdIFRoZSBwcm9wZXJ0aWVzIG9mIHRoZSB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuJykuQ29tcG9uZW50Q2hpbGRyZW4+fSBbY2hpbGRyZW5dIFRoZSBjaGlsZHJlbiBvZiB0aGUgdmlydHVhbCBub2RlXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFbGVtZW50KHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xuXHRsZXQgbm9ybWFsaXplZFByb3BzID0ge30sXG5cdFx0a2V5LFxuXHRcdHJlZixcblx0XHRpO1xuXHRmb3IgKGkgaW4gcHJvcHMpIHtcblx0XHRpZiAoaSA9PSAna2V5Jykga2V5ID0gcHJvcHNbaV07XG5cdFx0ZWxzZSBpZiAoaSA9PSAncmVmJykgcmVmID0gcHJvcHNbaV07XG5cdFx0ZWxzZSBub3JtYWxpemVkUHJvcHNbaV0gPSBwcm9wc1tpXTtcblx0fVxuXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuXHRcdG5vcm1hbGl6ZWRQcm9wcy5jaGlsZHJlbiA9XG5cdFx0XHRhcmd1bWVudHMubGVuZ3RoID4gMyA/IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSA6IGNoaWxkcmVuO1xuXHR9XG5cblx0Ly8gSWYgYSBDb21wb25lbnQgVk5vZGUsIGNoZWNrIGZvciBhbmQgYXBwbHkgZGVmYXVsdFByb3BzXG5cdC8vIE5vdGU6IHR5cGUgbWF5IGJlIHVuZGVmaW5lZCBpbiBkZXZlbG9wbWVudCwgbXVzdCBuZXZlciBlcnJvciBoZXJlLlxuXHRpZiAodHlwZW9mIHR5cGUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlLmRlZmF1bHRQcm9wcyAhPSBudWxsKSB7XG5cdFx0Zm9yIChpIGluIHR5cGUuZGVmYXVsdFByb3BzKSB7XG5cdFx0XHRpZiAobm9ybWFsaXplZFByb3BzW2ldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0bm9ybWFsaXplZFByb3BzW2ldID0gdHlwZS5kZWZhdWx0UHJvcHNbaV07XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIG5vcm1hbGl6ZWRQcm9wcywga2V5LCByZWYsIG51bGwpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIFZOb2RlICh1c2VkIGludGVybmFsbHkgYnkgUHJlYWN0KVxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZVtcInR5cGVcIl19IHR5cGUgVGhlIG5vZGUgbmFtZSBvciBDb21wb25lbnRcbiAqIENvbnN0cnVjdG9yIGZvciB0aGlzIHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtvYmplY3QgfCBzdHJpbmcgfCBudW1iZXIgfCBudWxsfSBwcm9wcyBUaGUgcHJvcGVydGllcyBvZiB0aGlzIHZpcnR1YWwgbm9kZS5cbiAqIElmIHRoaXMgdmlydHVhbCBub2RlIHJlcHJlc2VudHMgYSB0ZXh0IG5vZGUsIHRoaXMgaXMgdGhlIHRleHQgb2YgdGhlIG5vZGUgKHN0cmluZyBvciBudW1iZXIpLlxuICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXIgfCBudWxsfSBrZXkgVGhlIGtleSBmb3IgdGhpcyB2aXJ0dWFsIG5vZGUsIHVzZWQgd2hlblxuICogZGlmZmluZyBpdCBhZ2FpbnN0IGl0cyBjaGlsZHJlblxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZVtcInJlZlwiXX0gcmVmIFRoZSByZWYgcHJvcGVydHkgdGhhdCB3aWxsXG4gKiByZWNlaXZlIGEgcmVmZXJlbmNlIHRvIGl0cyBjcmVhdGVkIGNoaWxkXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVWTm9kZSh0eXBlLCBwcm9wcywga2V5LCByZWYsIG9yaWdpbmFsKSB7XG5cdC8vIFY4IHNlZW1zIHRvIGJlIGJldHRlciBhdCBkZXRlY3RpbmcgdHlwZSBzaGFwZXMgaWYgdGhlIG9iamVjdCBpcyBhbGxvY2F0ZWQgZnJvbSB0aGUgc2FtZSBjYWxsIHNpdGVcblx0Ly8gRG8gbm90IGlubGluZSBpbnRvIGNyZWF0ZUVsZW1lbnQgYW5kIGNvZXJjZVRvVk5vZGUhXG5cdGNvbnN0IHZub2RlID0ge1xuXHRcdHR5cGUsXG5cdFx0cHJvcHMsXG5cdFx0a2V5LFxuXHRcdHJlZixcblx0XHRfY2hpbGRyZW46IG51bGwsXG5cdFx0X3BhcmVudDogbnVsbCxcblx0XHRfZGVwdGg6IDAsXG5cdFx0X2RvbTogbnVsbCxcblx0XHQvLyBfbmV4dERvbSBtdXN0IGJlIGluaXRpYWxpemVkIHRvIHVuZGVmaW5lZCBiL2MgaXQgd2lsbCBldmVudHVhbGx5XG5cdFx0Ly8gYmUgc2V0IHRvIGRvbS5uZXh0U2libGluZyB3aGljaCBjYW4gcmV0dXJuIGBudWxsYCBhbmQgaXQgaXMgaW1wb3J0YW50XG5cdFx0Ly8gdG8gYmUgYWJsZSB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIGFuIHVuaW5pdGlhbGl6ZWQgX25leHREb20gYW5kXG5cdFx0Ly8gYSBfbmV4dERvbSB0aGF0IGhhcyBiZWVuIHNldCB0byBgbnVsbGBcblx0XHRfbmV4dERvbTogdW5kZWZpbmVkLFxuXHRcdF9jb21wb25lbnQ6IG51bGwsXG5cdFx0X2h5ZHJhdGluZzogbnVsbCxcblx0XHRjb25zdHJ1Y3RvcjogdW5kZWZpbmVkLFxuXHRcdF9vcmlnaW5hbDogb3JpZ2luYWwgPT0gbnVsbCA/ICsrdm5vZGVJZCA6IG9yaWdpbmFsXG5cdH07XG5cblx0Ly8gT25seSBpbnZva2UgdGhlIHZub2RlIGhvb2sgaWYgdGhpcyB3YXMgKm5vdCogYSBkaXJlY3QgY29weTpcblx0aWYgKG9yaWdpbmFsID09IG51bGwgJiYgb3B0aW9ucy52bm9kZSAhPSBudWxsKSBvcHRpb25zLnZub2RlKHZub2RlKTtcblxuXHRyZXR1cm4gdm5vZGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSZWYoKSB7XG5cdHJldHVybiB7IGN1cnJlbnQ6IG51bGwgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEZyYWdtZW50KHByb3BzKSB7XG5cdHJldHVybiBwcm9wcy5jaGlsZHJlbjtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHRoZSBhcmd1bWVudCBpcyBhIHZhbGlkIFByZWFjdCBWTm9kZS5cbiAqIEBwYXJhbSB7Kn0gdm5vZGVcbiAqIEByZXR1cm5zIHt2bm9kZSBpcyBpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX1cbiAqL1xuZXhwb3J0IGNvbnN0IGlzVmFsaWRFbGVtZW50ID0gdm5vZGUgPT5cblx0dm5vZGUgIT0gbnVsbCAmJiB2bm9kZS5jb25zdHJ1Y3RvciA9PT0gdW5kZWZpbmVkO1xuIiwgImltcG9ydCB7IElTX05PTl9ESU1FTlNJT05BTCB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgb3B0aW9ucyBmcm9tICcuLi9vcHRpb25zJztcblxuLyoqXG4gKiBEaWZmIHRoZSBvbGQgYW5kIG5ldyBwcm9wZXJ0aWVzIG9mIGEgVk5vZGUgYW5kIGFwcGx5IGNoYW5nZXMgdG8gdGhlIERPTSBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBkb20gVGhlIERPTSBub2RlIHRvIGFwcGx5XG4gKiBjaGFuZ2VzIHRvXG4gKiBAcGFyYW0ge29iamVjdH0gbmV3UHJvcHMgVGhlIG5ldyBwcm9wc1xuICogQHBhcmFtIHtvYmplY3R9IG9sZFByb3BzIFRoZSBvbGQgcHJvcHNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdmcgV2hldGhlciBvciBub3QgdGhpcyBub2RlIGlzIGFuIFNWRyBub2RlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGh5ZHJhdGUgV2hldGhlciBvciBub3Qgd2UgYXJlIGluIGh5ZHJhdGlvbiBtb2RlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaWZmUHJvcHMoZG9tLCBuZXdQcm9wcywgb2xkUHJvcHMsIGlzU3ZnLCBoeWRyYXRlKSB7XG5cdGxldCBpO1xuXG5cdGZvciAoaSBpbiBvbGRQcm9wcykge1xuXHRcdGlmIChpICE9PSAnY2hpbGRyZW4nICYmIGkgIT09ICdrZXknICYmICEoaSBpbiBuZXdQcm9wcykpIHtcblx0XHRcdHNldFByb3BlcnR5KGRvbSwgaSwgbnVsbCwgb2xkUHJvcHNbaV0sIGlzU3ZnKTtcblx0XHR9XG5cdH1cblxuXHRmb3IgKGkgaW4gbmV3UHJvcHMpIHtcblx0XHRpZiAoXG5cdFx0XHQoIWh5ZHJhdGUgfHwgdHlwZW9mIG5ld1Byb3BzW2ldID09ICdmdW5jdGlvbicpICYmXG5cdFx0XHRpICE9PSAnY2hpbGRyZW4nICYmXG5cdFx0XHRpICE9PSAna2V5JyAmJlxuXHRcdFx0aSAhPT0gJ3ZhbHVlJyAmJlxuXHRcdFx0aSAhPT0gJ2NoZWNrZWQnICYmXG5cdFx0XHRvbGRQcm9wc1tpXSAhPT0gbmV3UHJvcHNbaV1cblx0XHQpIHtcblx0XHRcdHNldFByb3BlcnR5KGRvbSwgaSwgbmV3UHJvcHNbaV0sIG9sZFByb3BzW2ldLCBpc1N2Zyk7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHNldFN0eWxlKHN0eWxlLCBrZXksIHZhbHVlKSB7XG5cdGlmIChrZXlbMF0gPT09ICctJykge1xuXHRcdHN0eWxlLnNldFByb3BlcnR5KGtleSwgdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWUpO1xuXHR9IGVsc2UgaWYgKHZhbHVlID09IG51bGwpIHtcblx0XHRzdHlsZVtrZXldID0gJyc7XG5cdH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9ICdudW1iZXInIHx8IElTX05PTl9ESU1FTlNJT05BTC50ZXN0KGtleSkpIHtcblx0XHRzdHlsZVtrZXldID0gdmFsdWU7XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGVba2V5XSA9IHZhbHVlICsgJ3B4Jztcblx0fVxufVxuXG4vKipcbiAqIFNldCBhIHByb3BlcnR5IHZhbHVlIG9uIGEgRE9NIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IGRvbSBUaGUgRE9NIG5vZGUgdG8gbW9kaWZ5XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gc2V0XG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQgdGhlIHByb3BlcnR5IHRvXG4gKiBAcGFyYW0geyp9IG9sZFZhbHVlIFRoZSBvbGQgdmFsdWUgdGhlIHByb3BlcnR5IGhhZFxuICogQHBhcmFtIHtib29sZWFufSBpc1N2ZyBXaGV0aGVyIG9yIG5vdCB0aGlzIERPTSBub2RlIGlzIGFuIFNWRyBub2RlIG9yIG5vdFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0UHJvcGVydHkoZG9tLCBuYW1lLCB2YWx1ZSwgb2xkVmFsdWUsIGlzU3ZnKSB7XG5cdGxldCB1c2VDYXB0dXJlO1xuXG5cdG86IGlmIChuYW1lID09PSAnc3R5bGUnKSB7XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuXHRcdFx0ZG9tLnN0eWxlLmNzc1RleHQgPSB2YWx1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKHR5cGVvZiBvbGRWYWx1ZSA9PSAnc3RyaW5nJykge1xuXHRcdFx0XHRkb20uc3R5bGUuY3NzVGV4dCA9IG9sZFZhbHVlID0gJyc7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvbGRWYWx1ZSkge1xuXHRcdFx0XHRmb3IgKG5hbWUgaW4gb2xkVmFsdWUpIHtcblx0XHRcdFx0XHRpZiAoISh2YWx1ZSAmJiBuYW1lIGluIHZhbHVlKSkge1xuXHRcdFx0XHRcdFx0c2V0U3R5bGUoZG9tLnN0eWxlLCBuYW1lLCAnJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0XHRmb3IgKG5hbWUgaW4gdmFsdWUpIHtcblx0XHRcdFx0XHRpZiAoIW9sZFZhbHVlIHx8IHZhbHVlW25hbWVdICE9PSBvbGRWYWx1ZVtuYW1lXSkge1xuXHRcdFx0XHRcdFx0c2V0U3R5bGUoZG9tLnN0eWxlLCBuYW1lLCB2YWx1ZVtuYW1lXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdC8vIEJlbmNobWFyayBmb3IgY29tcGFyaXNvbjogaHR0cHM6Ly9lc2JlbmNoLmNvbS9iZW5jaC81NzRjOTU0YmRiOTY1YjlhMDA5NjVhYzZcblx0ZWxzZSBpZiAobmFtZVswXSA9PT0gJ28nICYmIG5hbWVbMV0gPT09ICduJykge1xuXHRcdHVzZUNhcHR1cmUgPSBuYW1lICE9PSAobmFtZSA9IG5hbWUucmVwbGFjZSgvQ2FwdHVyZSQvLCAnJykpO1xuXG5cdFx0Ly8gSW5mZXIgY29ycmVjdCBjYXNpbmcgZm9yIERPTSBidWlsdC1pbiBldmVudHM6XG5cdFx0aWYgKG5hbWUudG9Mb3dlckNhc2UoKSBpbiBkb20pIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMik7XG5cdFx0ZWxzZSBuYW1lID0gbmFtZS5zbGljZSgyKTtcblxuXHRcdGlmICghZG9tLl9saXN0ZW5lcnMpIGRvbS5fbGlzdGVuZXJzID0ge307XG5cdFx0ZG9tLl9saXN0ZW5lcnNbbmFtZSArIHVzZUNhcHR1cmVdID0gdmFsdWU7XG5cblx0XHRpZiAodmFsdWUpIHtcblx0XHRcdGlmICghb2xkVmFsdWUpIHtcblx0XHRcdFx0Y29uc3QgaGFuZGxlciA9IHVzZUNhcHR1cmUgPyBldmVudFByb3h5Q2FwdHVyZSA6IGV2ZW50UHJveHk7XG5cdFx0XHRcdGRvbS5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIsIHVzZUNhcHR1cmUpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCBoYW5kbGVyID0gdXNlQ2FwdHVyZSA/IGV2ZW50UHJveHlDYXB0dXJlIDogZXZlbnRQcm94eTtcblx0XHRcdGRvbS5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIsIHVzZUNhcHR1cmUpO1xuXHRcdH1cblx0fSBlbHNlIGlmIChuYW1lICE9PSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnKSB7XG5cdFx0aWYgKGlzU3ZnKSB7XG5cdFx0XHQvLyBOb3JtYWxpemUgaW5jb3JyZWN0IHByb3AgdXNhZ2UgZm9yIFNWRzpcblx0XHRcdC8vIC0geGxpbms6aHJlZiAvIHhsaW5rSHJlZiAtLT4gaHJlZiAoeGxpbms6aHJlZiB3YXMgcmVtb3ZlZCBmcm9tIFNWRyBhbmQgaXNuJ3QgbmVlZGVkKVxuXHRcdFx0Ly8gLSBjbGFzc05hbWUgLS0+IGNsYXNzXG5cdFx0XHRuYW1lID0gbmFtZS5yZXBsYWNlKC94bGluayhIfDpoKS8sICdoJykucmVwbGFjZSgvc05hbWUkLywgJ3MnKTtcblx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0bmFtZSAhPT0gJ3dpZHRoJyAmJlxuXHRcdFx0bmFtZSAhPT0gJ2hlaWdodCcgJiZcblx0XHRcdG5hbWUgIT09ICdocmVmJyAmJlxuXHRcdFx0bmFtZSAhPT0gJ2xpc3QnICYmXG5cdFx0XHRuYW1lICE9PSAnZm9ybScgJiZcblx0XHRcdC8vIERlZmF1bHQgdmFsdWUgaW4gYnJvd3NlcnMgaXMgYC0xYCBhbmQgYW4gZW1wdHkgc3RyaW5nIGlzXG5cdFx0XHQvLyBjYXN0IHRvIGAwYCBpbnN0ZWFkXG5cdFx0XHRuYW1lICE9PSAndGFiSW5kZXgnICYmXG5cdFx0XHRuYW1lICE9PSAnZG93bmxvYWQnICYmXG5cdFx0XHRuYW1lIGluIGRvbVxuXHRcdCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZG9tW25hbWVdID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG5cdFx0XHRcdC8vIGxhYmVsbGVkIGJyZWFrIGlzIDFiIHNtYWxsZXIgaGVyZSB0aGFuIGEgcmV0dXJuIHN0YXRlbWVudCAoc29ycnkpXG5cdFx0XHRcdGJyZWFrIG87XG5cdFx0XHR9IGNhdGNoIChlKSB7fVxuXHRcdH1cblxuXHRcdC8vIEFSSUEtYXR0cmlidXRlcyBoYXZlIGEgZGlmZmVyZW50IG5vdGlvbiBvZiBib29sZWFuIHZhbHVlcy5cblx0XHQvLyBUaGUgdmFsdWUgYGZhbHNlYCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgYXR0cmlidXRlIG5vdFxuXHRcdC8vIGV4aXN0aW5nIG9uIHRoZSBET00sIHNvIHdlIGNhbid0IHJlbW92ZSBpdC4gRm9yIG5vbi1ib29sZWFuXG5cdFx0Ly8gQVJJQS1hdHRyaWJ1dGVzIHdlIGNvdWxkIHRyZWF0IGZhbHNlIGFzIGEgcmVtb3ZhbCwgYnV0IHRoZVxuXHRcdC8vIGFtb3VudCBvZiBleGNlcHRpb25zIHdvdWxkIGNvc3QgdXMgdG9vIG1hbnkgYnl0ZXMuIE9uIHRvcCBvZlxuXHRcdC8vIHRoYXQgb3RoZXIgVkRPTSBmcmFtZXdvcmtzIGFsc28gYWx3YXlzIHN0cmluZ2lmeSBgZmFsc2VgLlxuXG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Ly8gbmV2ZXIgc2VyaWFsaXplIGZ1bmN0aW9ucyBhcyBhdHRyaWJ1dGUgdmFsdWVzXG5cdFx0fSBlbHNlIGlmICh2YWx1ZSAhPSBudWxsICYmICh2YWx1ZSAhPT0gZmFsc2UgfHwgbmFtZS5pbmRleE9mKCctJykgIT0gLTEpKSB7XG5cdFx0XHRkb20uc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZG9tLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcblx0XHR9XG5cdH1cbn1cblxuZXhwb3J0IGxldCBpbkV2ZW50ID0gZmFsc2U7XG5cbi8qKlxuICogUHJveHkgYW4gZXZlbnQgdG8gaG9va2VkIGV2ZW50IGhhbmRsZXJzXG4gKiBAcGFyYW0ge0V2ZW50fSBlIFRoZSBldmVudCBvYmplY3QgZnJvbSB0aGUgYnJvd3NlclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXZlbnRQcm94eShlKSB7XG5cdGluRXZlbnQgPSB0cnVlO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzLl9saXN0ZW5lcnNbZS50eXBlICsgZmFsc2VdKFxuXHRcdFx0b3B0aW9ucy5ldmVudCA/IG9wdGlvbnMuZXZlbnQoZSkgOiBlXG5cdFx0KTtcblx0fSBmaW5hbGx5IHtcblx0XHRpbkV2ZW50ID0gZmFsc2U7XG5cdH1cbn1cblxuZnVuY3Rpb24gZXZlbnRQcm94eUNhcHR1cmUoZSkge1xuXHRpbkV2ZW50ID0gdHJ1ZTtcblx0dHJ5IHtcblx0XHRyZXR1cm4gdGhpcy5fbGlzdGVuZXJzW2UudHlwZSArIHRydWVdKG9wdGlvbnMuZXZlbnQgPyBvcHRpb25zLmV2ZW50KGUpIDogZSk7XG5cdH0gZmluYWxseSB7XG5cdFx0aW5FdmVudCA9IGZhbHNlO1xuXHR9XG59XG4iLCAiaW1wb3J0IHsgYXNzaWduIH0gZnJvbSAnLi91dGlsJztcbmltcG9ydCB7IGRpZmYsIGNvbW1pdFJvb3QgfSBmcm9tICcuL2RpZmYvaW5kZXgnO1xuaW1wb3J0IG9wdGlvbnMgZnJvbSAnLi9vcHRpb25zJztcbmltcG9ydCB7IEZyYWdtZW50IH0gZnJvbSAnLi9jcmVhdGUtZWxlbWVudCc7XG5pbXBvcnQgeyBpbkV2ZW50IH0gZnJvbSAnLi9kaWZmL3Byb3BzJztcblxuLyoqXG4gKiBCYXNlIENvbXBvbmVudCBjbGFzcy4gUHJvdmlkZXMgYHNldFN0YXRlKClgIGFuZCBgZm9yY2VVcGRhdGUoKWAsIHdoaWNoXG4gKiB0cmlnZ2VyIHJlbmRlcmluZ1xuICogQHBhcmFtIHtvYmplY3R9IHByb3BzIFRoZSBpbml0aWFsIGNvbXBvbmVudCBwcm9wc1xuICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHQgVGhlIGluaXRpYWwgY29udGV4dCBmcm9tIHBhcmVudCBjb21wb25lbnRzJ1xuICogZ2V0Q2hpbGRDb250ZXh0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBDb21wb25lbnQocHJvcHMsIGNvbnRleHQpIHtcblx0dGhpcy5wcm9wcyA9IHByb3BzO1xuXHR0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xufVxuXG4vKipcbiAqIFVwZGF0ZSBjb21wb25lbnQgc3RhdGUgYW5kIHNjaGVkdWxlIGEgcmUtcmVuZGVyLlxuICogQHRoaXMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH1cbiAqIEBwYXJhbSB7b2JqZWN0IHwgKChzOiBvYmplY3QsIHA6IG9iamVjdCkgPT4gb2JqZWN0KX0gdXBkYXRlIEEgaGFzaCBvZiBzdGF0ZVxuICogcHJvcGVydGllcyB0byB1cGRhdGUgd2l0aCBuZXcgdmFsdWVzIG9yIGEgZnVuY3Rpb24gdGhhdCBnaXZlbiB0aGUgY3VycmVudFxuICogc3RhdGUgYW5kIHByb3BzIHJldHVybnMgYSBuZXcgcGFydGlhbCBzdGF0ZVxuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBbY2FsbGJhY2tdIEEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uY2UgY29tcG9uZW50IHN0YXRlIGlzXG4gKiB1cGRhdGVkXG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbih1cGRhdGUsIGNhbGxiYWNrKSB7XG5cdC8vIG9ubHkgY2xvbmUgc3RhdGUgd2hlbiBjb3B5aW5nIHRvIG5leHRTdGF0ZSB0aGUgZmlyc3QgdGltZS5cblx0bGV0IHM7XG5cdGlmICh0aGlzLl9uZXh0U3RhdGUgIT0gbnVsbCAmJiB0aGlzLl9uZXh0U3RhdGUgIT09IHRoaXMuc3RhdGUpIHtcblx0XHRzID0gdGhpcy5fbmV4dFN0YXRlO1xuXHR9IGVsc2Uge1xuXHRcdHMgPSB0aGlzLl9uZXh0U3RhdGUgPSBhc3NpZ24oe30sIHRoaXMuc3RhdGUpO1xuXHR9XG5cblx0aWYgKHR5cGVvZiB1cGRhdGUgPT0gJ2Z1bmN0aW9uJykge1xuXHRcdC8vIFNvbWUgbGlicmFyaWVzIGxpa2UgYGltbWVyYCBtYXJrIHRoZSBjdXJyZW50IHN0YXRlIGFzIHJlYWRvbmx5LFxuXHRcdC8vIHByZXZlbnRpbmcgdXMgZnJvbSBtdXRhdGluZyBpdCwgc28gd2UgbmVlZCB0byBjbG9uZSBpdC4gU2VlICMyNzE2XG5cdFx0dXBkYXRlID0gdXBkYXRlKGFzc2lnbih7fSwgcyksIHRoaXMucHJvcHMpO1xuXHR9XG5cblx0aWYgKHVwZGF0ZSkge1xuXHRcdGFzc2lnbihzLCB1cGRhdGUpO1xuXHR9XG5cblx0Ly8gU2tpcCB1cGRhdGUgaWYgdXBkYXRlciBmdW5jdGlvbiByZXR1cm5lZCBudWxsXG5cdGlmICh1cGRhdGUgPT0gbnVsbCkgcmV0dXJuO1xuXG5cdGlmICh0aGlzLl92bm9kZSkge1xuXHRcdGlmIChjYWxsYmFjaykge1xuXHRcdFx0dGhpcy5fc3RhdGVDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG5cdFx0fVxuXHRcdGVucXVldWVSZW5kZXIodGhpcyk7XG5cdH1cbn07XG5cbi8qKlxuICogSW1tZWRpYXRlbHkgcGVyZm9ybSBhIHN5bmNocm9ub3VzIHJlLXJlbmRlciBvZiB0aGUgY29tcG9uZW50XG4gKiBAdGhpcyB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fVxuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBbY2FsbGJhY2tdIEEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpc1xuICogcmUtcmVuZGVyZWRcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdGlmICh0aGlzLl92bm9kZSkge1xuXHRcdC8vIFNldCByZW5kZXIgbW9kZSBzbyB0aGF0IHdlIGNhbiBkaWZmZXJlbnRpYXRlIHdoZXJlIHRoZSByZW5kZXIgcmVxdWVzdFxuXHRcdC8vIGlzIGNvbWluZyBmcm9tLiBXZSBuZWVkIHRoaXMgYmVjYXVzZSBmb3JjZVVwZGF0ZSBzaG91bGQgbmV2ZXIgY2FsbFxuXHRcdC8vIHNob3VsZENvbXBvbmVudFVwZGF0ZVxuXHRcdHRoaXMuX2ZvcmNlID0gdHJ1ZTtcblx0XHRpZiAoY2FsbGJhY2spIHRoaXMuX3JlbmRlckNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcblx0XHRlbnF1ZXVlUmVuZGVyKHRoaXMpO1xuXHR9XG59O1xuXG4vKipcbiAqIEFjY2VwdHMgYHByb3BzYCBhbmQgYHN0YXRlYCwgYW5kIHJldHVybnMgYSBuZXcgVmlydHVhbCBET00gdHJlZSB0byBidWlsZC5cbiAqIFZpcnR1YWwgRE9NIGlzIGdlbmVyYWxseSBjb25zdHJ1Y3RlZCB2aWEgW0pTWF0oaHR0cDovL2phc29uZm9ybWF0LmNvbS93dGYtaXMtanN4KS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcyBQcm9wcyAoZWc6IEpTWCBhdHRyaWJ1dGVzKSByZWNlaXZlZCBmcm9tIHBhcmVudFxuICogZWxlbWVudC9jb21wb25lbnRcbiAqIEBwYXJhbSB7b2JqZWN0fSBzdGF0ZSBUaGUgY29tcG9uZW50J3MgY3VycmVudCBzdGF0ZVxuICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHQgQ29udGV4dCBvYmplY3QsIGFzIHJldHVybmVkIGJ5IHRoZSBuZWFyZXN0XG4gKiBhbmNlc3RvcidzIGBnZXRDaGlsZENvbnRleHQoKWBcbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vaW5kZXgnKS5Db21wb25lbnRDaGlsZHJlbiB8IHZvaWR9XG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyID0gRnJhZ21lbnQ7XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGVcbiAqIEBwYXJhbSB7bnVtYmVyIHwgbnVsbH0gW2NoaWxkSW5kZXhdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREb21TaWJsaW5nKHZub2RlLCBjaGlsZEluZGV4KSB7XG5cdGlmIChjaGlsZEluZGV4ID09IG51bGwpIHtcblx0XHQvLyBVc2UgY2hpbGRJbmRleD09bnVsbCBhcyBhIHNpZ25hbCB0byByZXN1bWUgdGhlIHNlYXJjaCBmcm9tIHRoZSB2bm9kZSdzIHNpYmxpbmdcblx0XHRyZXR1cm4gdm5vZGUuX3BhcmVudFxuXHRcdFx0PyBnZXREb21TaWJsaW5nKHZub2RlLl9wYXJlbnQsIHZub2RlLl9wYXJlbnQuX2NoaWxkcmVuLmluZGV4T2Yodm5vZGUpICsgMSlcblx0XHRcdDogbnVsbDtcblx0fVxuXG5cdGxldCBzaWJsaW5nO1xuXHRmb3IgKDsgY2hpbGRJbmRleCA8IHZub2RlLl9jaGlsZHJlbi5sZW5ndGg7IGNoaWxkSW5kZXgrKykge1xuXHRcdHNpYmxpbmcgPSB2bm9kZS5fY2hpbGRyZW5bY2hpbGRJbmRleF07XG5cblx0XHRpZiAoc2libGluZyAhPSBudWxsICYmIHNpYmxpbmcuX2RvbSAhPSBudWxsKSB7XG5cdFx0XHQvLyBTaW5jZSB1cGRhdGVQYXJlbnREb21Qb2ludGVycyBrZWVwcyBfZG9tIHBvaW50ZXIgY29ycmVjdCxcblx0XHRcdC8vIHdlIGNhbiByZWx5IG9uIF9kb20gdG8gdGVsbCB1cyBpZiB0aGlzIHN1YnRyZWUgY29udGFpbnMgYVxuXHRcdFx0Ly8gcmVuZGVyZWQgRE9NIG5vZGUsIGFuZCB3aGF0IHRoZSBmaXJzdCByZW5kZXJlZCBET00gbm9kZSBpc1xuXHRcdFx0cmV0dXJuIHNpYmxpbmcuX2RvbTtcblx0XHR9XG5cdH1cblxuXHQvLyBJZiB3ZSBnZXQgaGVyZSwgd2UgaGF2ZSBub3QgZm91bmQgYSBET00gbm9kZSBpbiB0aGlzIHZub2RlJ3MgY2hpbGRyZW4uXG5cdC8vIFdlIG11c3QgcmVzdW1lIGZyb20gdGhpcyB2bm9kZSdzIHNpYmxpbmcgKGluIGl0J3MgcGFyZW50IF9jaGlsZHJlbiBhcnJheSlcblx0Ly8gT25seSBjbGltYiB1cCBhbmQgc2VhcmNoIHRoZSBwYXJlbnQgaWYgd2UgYXJlbid0IHNlYXJjaGluZyB0aHJvdWdoIGEgRE9NXG5cdC8vIFZOb2RlIChtZWFuaW5nIHdlIHJlYWNoZWQgdGhlIERPTSBwYXJlbnQgb2YgdGhlIG9yaWdpbmFsIHZub2RlIHRoYXQgYmVnYW5cblx0Ly8gdGhlIHNlYXJjaClcblx0cmV0dXJuIHR5cGVvZiB2bm9kZS50eXBlID09ICdmdW5jdGlvbicgPyBnZXREb21TaWJsaW5nKHZub2RlKSA6IG51bGw7XG59XG5cbi8qKlxuICogVHJpZ2dlciBpbi1wbGFjZSByZS1yZW5kZXJpbmcgb2YgYSBjb21wb25lbnQuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gY29tcG9uZW50IFRoZSBjb21wb25lbnQgdG8gcmVyZW5kZXJcbiAqL1xuZnVuY3Rpb24gcmVuZGVyQ29tcG9uZW50KGNvbXBvbmVudCkge1xuXHRsZXQgdm5vZGUgPSBjb21wb25lbnQuX3Zub2RlLFxuXHRcdG9sZERvbSA9IHZub2RlLl9kb20sXG5cdFx0cGFyZW50RG9tID0gY29tcG9uZW50Ll9wYXJlbnREb207XG5cblx0aWYgKHBhcmVudERvbSkge1xuXHRcdGxldCBjb21taXRRdWV1ZSA9IFtdO1xuXHRcdGNvbnN0IG9sZFZOb2RlID0gYXNzaWduKHt9LCB2bm9kZSk7XG5cdFx0b2xkVk5vZGUuX29yaWdpbmFsID0gdm5vZGUuX29yaWdpbmFsICsgMTtcblxuXHRcdGRpZmYoXG5cdFx0XHRwYXJlbnREb20sXG5cdFx0XHR2bm9kZSxcblx0XHRcdG9sZFZOb2RlLFxuXHRcdFx0Y29tcG9uZW50Ll9nbG9iYWxDb250ZXh0LFxuXHRcdFx0cGFyZW50RG9tLm93bmVyU1ZHRWxlbWVudCAhPT0gdW5kZWZpbmVkLFxuXHRcdFx0dm5vZGUuX2h5ZHJhdGluZyAhPSBudWxsID8gW29sZERvbV0gOiBudWxsLFxuXHRcdFx0Y29tbWl0UXVldWUsXG5cdFx0XHRvbGREb20gPT0gbnVsbCA/IGdldERvbVNpYmxpbmcodm5vZGUpIDogb2xkRG9tLFxuXHRcdFx0dm5vZGUuX2h5ZHJhdGluZ1xuXHRcdCk7XG5cdFx0Y29tbWl0Um9vdChjb21taXRRdWV1ZSwgdm5vZGUpO1xuXG5cdFx0aWYgKHZub2RlLl9kb20gIT0gb2xkRG9tKSB7XG5cdFx0XHR1cGRhdGVQYXJlbnREb21Qb2ludGVycyh2bm9kZSk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGVcbiAqL1xuZnVuY3Rpb24gdXBkYXRlUGFyZW50RG9tUG9pbnRlcnModm5vZGUpIHtcblx0aWYgKCh2bm9kZSA9IHZub2RlLl9wYXJlbnQpICE9IG51bGwgJiYgdm5vZGUuX2NvbXBvbmVudCAhPSBudWxsKSB7XG5cdFx0dm5vZGUuX2RvbSA9IHZub2RlLl9jb21wb25lbnQuYmFzZSA9IG51bGw7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB2bm9kZS5fY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdGxldCBjaGlsZCA9IHZub2RlLl9jaGlsZHJlbltpXTtcblx0XHRcdGlmIChjaGlsZCAhPSBudWxsICYmIGNoaWxkLl9kb20gIT0gbnVsbCkge1xuXHRcdFx0XHR2bm9kZS5fZG9tID0gdm5vZGUuX2NvbXBvbmVudC5iYXNlID0gY2hpbGQuX2RvbTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVwZGF0ZVBhcmVudERvbVBvaW50ZXJzKHZub2RlKTtcblx0fVxufVxuXG4vKipcbiAqIFRoZSByZW5kZXIgcXVldWVcbiAqIEB0eXBlIHtBcnJheTxpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnQ+fVxuICovXG5sZXQgcmVyZW5kZXJRdWV1ZSA9IFtdO1xuXG4vKlxuICogVGhlIHZhbHVlIG9mIGBDb21wb25lbnQuZGVib3VuY2VgIG11c3QgYXN5bmNocm9ub3VzbHkgaW52b2tlIHRoZSBwYXNzZWQgaW4gY2FsbGJhY2suIEl0IGlzXG4gKiBpbXBvcnRhbnQgdGhhdCBjb250cmlidXRvcnMgdG8gUHJlYWN0IGNhbiBjb25zaXN0ZW50bHkgcmVhc29uIGFib3V0IHdoYXQgY2FsbHMgdG8gYHNldFN0YXRlYCwgZXRjLlxuICogZG8sIGFuZCB3aGVuIHRoZWlyIGVmZmVjdHMgd2lsbCBiZSBhcHBsaWVkLiBTZWUgdGhlIGxpbmtzIGJlbG93IGZvciBzb21lIGZ1cnRoZXIgcmVhZGluZyBvbiBkZXNpZ25pbmdcbiAqIGFzeW5jaHJvbm91cyBBUElzLlxuICogKiBbRGVzaWduaW5nIEFQSXMgZm9yIEFzeW5jaHJvbnldKGh0dHBzOi8vYmxvZy5penMubWUvMjAxMy8wOC9kZXNpZ25pbmctYXBpcy1mb3ItYXN5bmNocm9ueSlcbiAqICogW0NhbGxiYWNrcyBzeW5jaHJvbm91cyBhbmQgYXN5bmNocm9ub3VzXShodHRwczovL2Jsb2cub21ldGVyLmNvbS8yMDExLzA3LzI0L2NhbGxiYWNrcy1zeW5jaHJvbm91cy1hbmQtYXN5bmNocm9ub3VzLylcbiAqL1xuXG5sZXQgcHJldkRlYm91bmNlO1xuXG5jb25zdCBtaWNyb1RpY2sgPVxuXHR0eXBlb2YgUHJvbWlzZSA9PSAnZnVuY3Rpb24nXG5cdFx0PyBQcm9taXNlLnByb3RvdHlwZS50aGVuLmJpbmQoUHJvbWlzZS5yZXNvbHZlKCkpXG5cdFx0OiBzZXRUaW1lb3V0O1xuZnVuY3Rpb24gZGVmZXIoY2IpIHtcblx0aWYgKGluRXZlbnQpIHtcblx0XHRzZXRUaW1lb3V0KGNiKTtcblx0fSBlbHNlIHtcblx0XHRtaWNyb1RpY2soY2IpO1xuXHR9XG59XG5cbi8qKlxuICogRW5xdWV1ZSBhIHJlcmVuZGVyIG9mIGEgY29tcG9uZW50XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gYyBUaGUgY29tcG9uZW50IHRvIHJlcmVuZGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnF1ZXVlUmVuZGVyKGMpIHtcblx0aWYgKFxuXHRcdCghYy5fZGlydHkgJiZcblx0XHRcdChjLl9kaXJ0eSA9IHRydWUpICYmXG5cdFx0XHRyZXJlbmRlclF1ZXVlLnB1c2goYykgJiZcblx0XHRcdCFwcm9jZXNzLl9yZXJlbmRlckNvdW50KyspIHx8XG5cdFx0cHJldkRlYm91bmNlICE9PSBvcHRpb25zLmRlYm91bmNlUmVuZGVyaW5nXG5cdCkge1xuXHRcdHByZXZEZWJvdW5jZSA9IG9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmc7XG5cdFx0KHByZXZEZWJvdW5jZSB8fCBkZWZlcikocHJvY2Vzcyk7XG5cdH1cbn1cblxuLyoqIEZsdXNoIHRoZSByZW5kZXIgcXVldWUgYnkgcmVyZW5kZXJpbmcgYWxsIHF1ZXVlZCBjb21wb25lbnRzICovXG5mdW5jdGlvbiBwcm9jZXNzKCkge1xuXHRsZXQgYztcblx0cmVyZW5kZXJRdWV1ZS5zb3J0KChhLCBiKSA9PiBhLl92bm9kZS5fZGVwdGggLSBiLl92bm9kZS5fZGVwdGgpO1xuXHQvLyBEb24ndCB1cGRhdGUgYHJlbmRlckNvdW50YCB5ZXQuIEtlZXAgaXRzIHZhbHVlIG5vbi16ZXJvIHRvIHByZXZlbnQgdW5uZWNlc3Nhcnlcblx0Ly8gcHJvY2VzcygpIGNhbGxzIGZyb20gZ2V0dGluZyBzY2hlZHVsZWQgd2hpbGUgYHF1ZXVlYCBpcyBzdGlsbCBiZWluZyBjb25zdW1lZC5cblx0d2hpbGUgKChjID0gcmVyZW5kZXJRdWV1ZS5zaGlmdCgpKSkge1xuXHRcdGlmIChjLl9kaXJ0eSkge1xuXHRcdFx0bGV0IHJlbmRlclF1ZXVlTGVuZ3RoID0gcmVyZW5kZXJRdWV1ZS5sZW5ndGg7XG5cdFx0XHRyZW5kZXJDb21wb25lbnQoYyk7XG5cdFx0XHRpZiAocmVyZW5kZXJRdWV1ZS5sZW5ndGggPiByZW5kZXJRdWV1ZUxlbmd0aCkge1xuXHRcdFx0XHQvLyBXaGVuIGkuZS4gcmVyZW5kZXJpbmcgYSBwcm92aWRlciBhZGRpdGlvbmFsIG5ldyBpdGVtcyBjYW4gYmUgaW5qZWN0ZWQsIHdlIHdhbnQgdG9cblx0XHRcdFx0Ly8ga2VlcCB0aGUgb3JkZXIgZnJvbSB0b3AgdG8gYm90dG9tIHdpdGggdGhvc2UgbmV3IGl0ZW1zIHNvIHdlIGNhbiBoYW5kbGUgdGhlbSBpbiBhXG5cdFx0XHRcdC8vIHNpbmdsZSBwYXNzXG5cdFx0XHRcdHJlcmVuZGVyUXVldWUuc29ydCgoYSwgYikgPT4gYS5fdm5vZGUuX2RlcHRoIC0gYi5fdm5vZGUuX2RlcHRoKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cHJvY2Vzcy5fcmVyZW5kZXJDb3VudCA9IDA7XG59XG5cbnByb2Nlc3MuX3JlcmVuZGVyQ291bnQgPSAwO1xuIiwgImltcG9ydCB7IGVucXVldWVSZW5kZXIgfSBmcm9tICcuL2NvbXBvbmVudCc7XG5cbmV4cG9ydCBsZXQgaSA9IDA7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb250ZXh0KGRlZmF1bHRWYWx1ZSwgY29udGV4dElkKSB7XG5cdGNvbnRleHRJZCA9ICdfX2NDJyArIGkrKztcblxuXHRjb25zdCBjb250ZXh0ID0ge1xuXHRcdF9pZDogY29udGV4dElkLFxuXHRcdF9kZWZhdWx0VmFsdWU6IGRlZmF1bHRWYWx1ZSxcblx0XHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkZ1bmN0aW9uQ29tcG9uZW50fSAqL1xuXHRcdENvbnN1bWVyKHByb3BzLCBjb250ZXh0VmFsdWUpIHtcblx0XHRcdC8vIHJldHVybiBwcm9wcy5jaGlsZHJlbihcblx0XHRcdC8vIFx0Y29udGV4dFtjb250ZXh0SWRdID8gY29udGV4dFtjb250ZXh0SWRdLnByb3BzLnZhbHVlIDogZGVmYXVsdFZhbHVlXG5cdFx0XHQvLyApO1xuXHRcdFx0cmV0dXJuIHByb3BzLmNoaWxkcmVuKGNvbnRleHRWYWx1ZSk7XG5cdFx0fSxcblx0XHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkZ1bmN0aW9uQ29tcG9uZW50fSAqL1xuXHRcdFByb3ZpZGVyKHByb3BzKSB7XG5cdFx0XHRpZiAoIXRoaXMuZ2V0Q2hpbGRDb250ZXh0KSB7XG5cdFx0XHRcdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50W119ICovXG5cdFx0XHRcdGxldCBzdWJzID0gW107XG5cdFx0XHRcdGxldCBjdHggPSB7fTtcblx0XHRcdFx0Y3R4W2NvbnRleHRJZF0gPSB0aGlzO1xuXG5cdFx0XHRcdHRoaXMuZ2V0Q2hpbGRDb250ZXh0ID0gKCkgPT4gY3R4O1xuXG5cdFx0XHRcdHRoaXMuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZnVuY3Rpb24oX3Byb3BzKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMucHJvcHMudmFsdWUgIT09IF9wcm9wcy52YWx1ZSkge1xuXHRcdFx0XHRcdFx0Ly8gSSB0aGluayB0aGUgZm9yY2VkIHZhbHVlIHByb3BhZ2F0aW9uIGhlcmUgd2FzIG9ubHkgbmVlZGVkIHdoZW4gYG9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmdgIHdhcyBiZWluZyBieXBhc3NlZDpcblx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmVhY3Rqcy9wcmVhY3QvY29tbWl0LzRkMzM5ZmI4MDNiZWEwOWU5ZjE5OGFiZjM4Y2ExYmY4ZWE0Yjc3NzEjZGlmZi01NDY4MmNlMzgwOTM1YTcxN2U0MWI4YmZjNTQ3MzdmNlIzNThcblx0XHRcdFx0XHRcdC8vIEluIHRob3NlIGNhc2VzIHRob3VnaCwgZXZlbiB3aXRoIHRoZSB2YWx1ZSBjb3JyZWN0ZWQsIHdlJ3JlIGRvdWJsZS1yZW5kZXJpbmcgYWxsIG5vZGVzLlxuXHRcdFx0XHRcdFx0Ly8gSXQgbWlnaHQgYmUgYmV0dGVyIHRvIGp1c3QgdGVsbCBmb2xrcyBub3QgdG8gdXNlIGZvcmNlLXN5bmMgbW9kZS5cblx0XHRcdFx0XHRcdC8vIEN1cnJlbnRseSwgdXNpbmcgYHVzZUNvbnRleHQoKWAgaW4gYSBjbGFzcyBjb21wb25lbnQgd2lsbCBvdmVyd3JpdGUgaXRzIGB0aGlzLmNvbnRleHRgIHZhbHVlLlxuXHRcdFx0XHRcdFx0Ly8gc3Vicy5zb21lKGMgPT4ge1xuXHRcdFx0XHRcdFx0Ly8gXHRjLmNvbnRleHQgPSBfcHJvcHMudmFsdWU7XG5cdFx0XHRcdFx0XHQvLyBcdGVucXVldWVSZW5kZXIoYyk7XG5cdFx0XHRcdFx0XHQvLyB9KTtcblxuXHRcdFx0XHRcdFx0Ly8gc3Vicy5zb21lKGMgPT4ge1xuXHRcdFx0XHRcdFx0Ly8gXHRjLmNvbnRleHRbY29udGV4dElkXSA9IF9wcm9wcy52YWx1ZTtcblx0XHRcdFx0XHRcdC8vIFx0ZW5xdWV1ZVJlbmRlcihjKTtcblx0XHRcdFx0XHRcdC8vIH0pO1xuXHRcdFx0XHRcdFx0c3Vicy5zb21lKGMgPT4ge1xuXHRcdFx0XHRcdFx0XHRjLl9mb3JjZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdGVucXVldWVSZW5kZXIoYyk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0dGhpcy5zdWIgPSBjID0+IHtcblx0XHRcdFx0XHRzdWJzLnB1c2goYyk7XG5cdFx0XHRcdFx0bGV0IG9sZCA9IGMuY29tcG9uZW50V2lsbFVubW91bnQ7XG5cdFx0XHRcdFx0Yy5jb21wb25lbnRXaWxsVW5tb3VudCA9ICgpID0+IHtcblx0XHRcdFx0XHRcdHN1YnMuc3BsaWNlKHN1YnMuaW5kZXhPZihjKSwgMSk7XG5cdFx0XHRcdFx0XHRpZiAob2xkKSBvbGQuY2FsbChjKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcHJvcHMuY2hpbGRyZW47XG5cdFx0fVxuXHR9O1xuXG5cdC8vIERldnRvb2xzIG5lZWRzIGFjY2VzcyB0byB0aGUgY29udGV4dCBvYmplY3Qgd2hlbiBpdFxuXHQvLyBlbmNvdW50ZXJzIGEgUHJvdmlkZXIuIFRoaXMgaXMgbmVjZXNzYXJ5IHRvIHN1cHBvcnRcblx0Ly8gc2V0dGluZyBgZGlzcGxheU5hbWVgIG9uIHRoZSBjb250ZXh0IG9iamVjdCBpbnN0ZWFkXG5cdC8vIG9mIG9uIHRoZSBjb21wb25lbnQgaXRzZWxmLiBTZWU6XG5cdC8vIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9jb250ZXh0Lmh0bWwjY29udGV4dGRpc3BsYXluYW1lXG5cblx0cmV0dXJuIChjb250ZXh0LlByb3ZpZGVyLl9jb250ZXh0UmVmID0gY29udGV4dC5Db25zdW1lci5jb250ZXh0VHlwZSA9IGNvbnRleHQpO1xufVxuIiwgImV4cG9ydCBjb25zdCBFTVBUWV9PQkogPSB7fTtcbmV4cG9ydCBjb25zdCBFTVBUWV9BUlIgPSBbXTtcbmV4cG9ydCBjb25zdCBJU19OT05fRElNRU5TSU9OQUwgPSAvYWNpdHxleCg/OnN8Z3xufHB8JCl8cnBofGdyaWR8b3dzfG1uY3xudHd8aW5lW2NoXXx6b298Xm9yZHxpdGVyYS9pO1xuIiwgImltcG9ydCB7IGRpZmYsIHVubW91bnQsIGFwcGx5UmVmIH0gZnJvbSAnLi9pbmRleCc7XG5pbXBvcnQgeyBjcmVhdGVWTm9kZSwgRnJhZ21lbnQgfSBmcm9tICcuLi9jcmVhdGUtZWxlbWVudCc7XG5pbXBvcnQgeyBFTVBUWV9PQkosIEVNUFRZX0FSUiB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBnZXREb21TaWJsaW5nIH0gZnJvbSAnLi4vY29tcG9uZW50JztcblxuLyoqXG4gKiBEaWZmIHRoZSBjaGlsZHJlbiBvZiBhIHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gcGFyZW50RG9tIFRoZSBET00gZWxlbWVudCB3aG9zZVxuICogY2hpbGRyZW4gYXJlIGJlaW5nIGRpZmZlZFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuQ29tcG9uZW50Q2hpbGRyZW5bXX0gcmVuZGVyUmVzdWx0XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gbmV3UGFyZW50Vk5vZGUgVGhlIG5ldyB2aXJ0dWFsXG4gKiBub2RlIHdob3NlIGNoaWxkcmVuIHNob3VsZCBiZSBkaWZmJ2VkIGFnYWluc3Qgb2xkUGFyZW50Vk5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBvbGRQYXJlbnRWTm9kZSBUaGUgb2xkIHZpcnR1YWxcbiAqIG5vZGUgd2hvc2UgY2hpbGRyZW4gc2hvdWxkIGJlIGRpZmYnZWQgYWdhaW5zdCBuZXdQYXJlbnRWTm9kZVxuICogQHBhcmFtIHtvYmplY3R9IGdsb2JhbENvbnRleHQgVGhlIGN1cnJlbnQgY29udGV4dCBvYmplY3QgLSBtb2RpZmllZCBieSBnZXRDaGlsZENvbnRleHRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdmcgV2hldGhlciBvciBub3QgdGhpcyBET00gbm9kZSBpcyBhbiBTVkcgbm9kZVxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudD59IGV4Y2Vzc0RvbUNoaWxkcmVuXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5Db21wb25lbnQ+fSBjb21taXRRdWV1ZSBMaXN0IG9mIGNvbXBvbmVudHNcbiAqIHdoaWNoIGhhdmUgY2FsbGJhY2tzIHRvIGludm9rZSBpbiBjb21taXRSb290XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBvbGREb20gVGhlIGN1cnJlbnQgYXR0YWNoZWQgRE9NXG4gKiBlbGVtZW50IGFueSBuZXcgZG9tIGVsZW1lbnRzIHNob3VsZCBiZSBwbGFjZWQgYXJvdW5kLiBMaWtlbHkgYG51bGxgIG9uIGZpcnN0XG4gKiByZW5kZXIgKGV4Y2VwdCB3aGVuIGh5ZHJhdGluZykuIENhbiBiZSBhIHNpYmxpbmcgRE9NIGVsZW1lbnQgd2hlbiBkaWZmaW5nXG4gKiBGcmFnbWVudHMgdGhhdCBoYXZlIHNpYmxpbmdzLiBJbiBtb3N0IGNhc2VzLCBpdCBzdGFydHMgb3V0IGFzIGBvbGRDaGlsZHJlblswXS5fZG9tYC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNIeWRyYXRpbmcgV2hldGhlciBvciBub3Qgd2UgYXJlIGluIGh5ZHJhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlmZkNoaWxkcmVuKFxuXHRwYXJlbnREb20sXG5cdHJlbmRlclJlc3VsdCxcblx0bmV3UGFyZW50Vk5vZGUsXG5cdG9sZFBhcmVudFZOb2RlLFxuXHRnbG9iYWxDb250ZXh0LFxuXHRpc1N2Zyxcblx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdGNvbW1pdFF1ZXVlLFxuXHRvbGREb20sXG5cdGlzSHlkcmF0aW5nXG4pIHtcblx0bGV0IGksIGosIG9sZFZOb2RlLCBjaGlsZFZOb2RlLCBuZXdEb20sIGZpcnN0Q2hpbGREb20sIHJlZnM7XG5cblx0Ly8gVGhpcyBpcyBhIGNvbXByZXNzaW9uIG9mIG9sZFBhcmVudFZOb2RlIT1udWxsICYmIG9sZFBhcmVudFZOb2RlICE9IEVNUFRZX09CSiAmJiBvbGRQYXJlbnRWTm9kZS5fY2hpbGRyZW4gfHwgRU1QVFlfQVJSXG5cdC8vIGFzIEVNUFRZX09CSi5fY2hpbGRyZW4gc2hvdWxkIGJlIGB1bmRlZmluZWRgLlxuXHRsZXQgb2xkQ2hpbGRyZW4gPSAob2xkUGFyZW50Vk5vZGUgJiYgb2xkUGFyZW50Vk5vZGUuX2NoaWxkcmVuKSB8fCBFTVBUWV9BUlI7XG5cblx0bGV0IG9sZENoaWxkcmVuTGVuZ3RoID0gb2xkQ2hpbGRyZW4ubGVuZ3RoO1xuXG5cdG5ld1BhcmVudFZOb2RlLl9jaGlsZHJlbiA9IFtdO1xuXHRmb3IgKGkgPSAwOyBpIDwgcmVuZGVyUmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0Y2hpbGRWTm9kZSA9IHJlbmRlclJlc3VsdFtpXTtcblxuXHRcdGlmIChjaGlsZFZOb2RlID09IG51bGwgfHwgdHlwZW9mIGNoaWxkVk5vZGUgPT0gJ2Jvb2xlYW4nKSB7XG5cdFx0XHRjaGlsZFZOb2RlID0gbmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuW2ldID0gbnVsbDtcblx0XHR9XG5cdFx0Ly8gSWYgdGhpcyBuZXdWTm9kZSBpcyBiZWluZyByZXVzZWQgKGUuZy4gPGRpdj57cmV1c2V9e3JldXNlfTwvZGl2PikgaW4gdGhlIHNhbWUgZGlmZixcblx0XHQvLyBvciB3ZSBhcmUgcmVuZGVyaW5nIGEgY29tcG9uZW50IChlLmcuIHNldFN0YXRlKSBjb3B5IHRoZSBvbGRWTm9kZXMgc28gaXQgY2FuIGhhdmVcblx0XHQvLyBpdCdzIG93biBET00gJiBldGMuIHBvaW50ZXJzXG5cdFx0ZWxzZSBpZiAoXG5cdFx0XHR0eXBlb2YgY2hpbGRWTm9kZSA9PSAnc3RyaW5nJyB8fFxuXHRcdFx0dHlwZW9mIGNoaWxkVk5vZGUgPT0gJ251bWJlcicgfHxcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB2YWxpZC10eXBlb2Zcblx0XHRcdHR5cGVvZiBjaGlsZFZOb2RlID09ICdiaWdpbnQnXG5cdFx0KSB7XG5cdFx0XHRjaGlsZFZOb2RlID0gbmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuW2ldID0gY3JlYXRlVk5vZGUoXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdGNoaWxkVk5vZGUsXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdGNoaWxkVk5vZGVcblx0XHRcdCk7XG5cdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNoaWxkVk5vZGUpKSB7XG5cdFx0XHRjaGlsZFZOb2RlID0gbmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuW2ldID0gY3JlYXRlVk5vZGUoXG5cdFx0XHRcdEZyYWdtZW50LFxuXHRcdFx0XHR7IGNoaWxkcmVuOiBjaGlsZFZOb2RlIH0sXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdG51bGxcblx0XHRcdCk7XG5cdFx0fSBlbHNlIGlmIChjaGlsZFZOb2RlLl9kZXB0aCA+IDApIHtcblx0XHRcdC8vIFZOb2RlIGlzIGFscmVhZHkgaW4gdXNlLCBjbG9uZSBpdC4gVGhpcyBjYW4gaGFwcGVuIGluIHRoZSBmb2xsb3dpbmdcblx0XHRcdC8vIHNjZW5hcmlvOlxuXHRcdFx0Ly8gICBjb25zdCByZXVzZSA9IDxkaXYgLz5cblx0XHRcdC8vICAgPGRpdj57cmV1c2V9PHNwYW4gLz57cmV1c2V9PC9kaXY+XG5cdFx0XHRjaGlsZFZOb2RlID0gbmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuW2ldID0gY3JlYXRlVk5vZGUoXG5cdFx0XHRcdGNoaWxkVk5vZGUudHlwZSxcblx0XHRcdFx0Y2hpbGRWTm9kZS5wcm9wcyxcblx0XHRcdFx0Y2hpbGRWTm9kZS5rZXksXG5cdFx0XHRcdGNoaWxkVk5vZGUucmVmID8gY2hpbGRWTm9kZS5yZWYgOiBudWxsLFxuXHRcdFx0XHRjaGlsZFZOb2RlLl9vcmlnaW5hbFxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2hpbGRWTm9kZSA9IG5ld1BhcmVudFZOb2RlLl9jaGlsZHJlbltpXSA9IGNoaWxkVk5vZGU7XG5cdFx0fVxuXG5cdFx0Ly8gVGVyc2VyIHJlbW92ZXMgdGhlIGBjb250aW51ZWAgaGVyZSBhbmQgd3JhcHMgdGhlIGxvb3AgYm9keVxuXHRcdC8vIGluIGEgYGlmIChjaGlsZFZOb2RlKSB7IC4uLiB9IGNvbmRpdGlvblxuXHRcdGlmIChjaGlsZFZOb2RlID09IG51bGwpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGNoaWxkVk5vZGUuX3BhcmVudCA9IG5ld1BhcmVudFZOb2RlO1xuXHRcdGNoaWxkVk5vZGUuX2RlcHRoID0gbmV3UGFyZW50Vk5vZGUuX2RlcHRoICsgMTtcblxuXHRcdC8vIENoZWNrIGlmIHdlIGZpbmQgYSBjb3JyZXNwb25kaW5nIGVsZW1lbnQgaW4gb2xkQ2hpbGRyZW4uXG5cdFx0Ly8gSWYgZm91bmQsIGRlbGV0ZSB0aGUgYXJyYXkgaXRlbSBieSBzZXR0aW5nIHRvIGB1bmRlZmluZWRgLlxuXHRcdC8vIFdlIHVzZSBgdW5kZWZpbmVkYCwgYXMgYG51bGxgIGlzIHJlc2VydmVkIGZvciBlbXB0eSBwbGFjZWhvbGRlcnNcblx0XHQvLyAoaG9sZXMpLlxuXHRcdG9sZFZOb2RlID0gb2xkQ2hpbGRyZW5baV07XG5cblx0XHRpZiAoXG5cdFx0XHRvbGRWTm9kZSA9PT0gbnVsbCB8fFxuXHRcdFx0KG9sZFZOb2RlICYmXG5cdFx0XHRcdGNoaWxkVk5vZGUua2V5ID09IG9sZFZOb2RlLmtleSAmJlxuXHRcdFx0XHRjaGlsZFZOb2RlLnR5cGUgPT09IG9sZFZOb2RlLnR5cGUpXG5cdFx0KSB7XG5cdFx0XHRvbGRDaGlsZHJlbltpXSA9IHVuZGVmaW5lZDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gRWl0aGVyIG9sZFZOb2RlID09PSB1bmRlZmluZWQgb3Igb2xkQ2hpbGRyZW5MZW5ndGggPiAwLFxuXHRcdFx0Ly8gc28gYWZ0ZXIgdGhpcyBsb29wIG9sZFZOb2RlID09IG51bGwgb3Igb2xkVk5vZGUgaXMgYSB2YWxpZCB2YWx1ZS5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBvbGRDaGlsZHJlbkxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdG9sZFZOb2RlID0gb2xkQ2hpbGRyZW5bal07XG5cdFx0XHRcdC8vIElmIGNoaWxkVk5vZGUgaXMgdW5rZXllZCwgd2Ugb25seSBtYXRjaCBzaW1pbGFybHkgdW5rZXllZCBub2Rlcywgb3RoZXJ3aXNlIHdlIG1hdGNoIGJ5IGtleS5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIG1hdGNoIGJ5IHR5cGUgKGluIGVpdGhlciBjYXNlKS5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdG9sZFZOb2RlICYmXG5cdFx0XHRcdFx0Y2hpbGRWTm9kZS5rZXkgPT0gb2xkVk5vZGUua2V5ICYmXG5cdFx0XHRcdFx0Y2hpbGRWTm9kZS50eXBlID09PSBvbGRWTm9kZS50eXBlXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdG9sZENoaWxkcmVuW2pdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG9sZFZOb2RlID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRvbGRWTm9kZSA9IG9sZFZOb2RlIHx8IEVNUFRZX09CSjtcblxuXHRcdC8vIE1vcnBoIHRoZSBvbGQgZWxlbWVudCBpbnRvIHRoZSBuZXcgb25lLCBidXQgZG9uJ3QgYXBwZW5kIGl0IHRvIHRoZSBkb20geWV0XG5cdFx0ZGlmZihcblx0XHRcdHBhcmVudERvbSxcblx0XHRcdGNoaWxkVk5vZGUsXG5cdFx0XHRvbGRWTm9kZSxcblx0XHRcdGdsb2JhbENvbnRleHQsXG5cdFx0XHRpc1N2Zyxcblx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuLFxuXHRcdFx0Y29tbWl0UXVldWUsXG5cdFx0XHRvbGREb20sXG5cdFx0XHRpc0h5ZHJhdGluZ1xuXHRcdCk7XG5cblx0XHRuZXdEb20gPSBjaGlsZFZOb2RlLl9kb207XG5cblx0XHRpZiAoKGogPSBjaGlsZFZOb2RlLnJlZikgJiYgb2xkVk5vZGUucmVmICE9IGopIHtcblx0XHRcdGlmICghcmVmcykgcmVmcyA9IFtdO1xuXHRcdFx0aWYgKG9sZFZOb2RlLnJlZikgcmVmcy5wdXNoKG9sZFZOb2RlLnJlZiwgbnVsbCwgY2hpbGRWTm9kZSk7XG5cdFx0XHRyZWZzLnB1c2goaiwgY2hpbGRWTm9kZS5fY29tcG9uZW50IHx8IG5ld0RvbSwgY2hpbGRWTm9kZSk7XG5cdFx0fVxuXG5cdFx0aWYgKG5ld0RvbSAhPSBudWxsKSB7XG5cdFx0XHRpZiAoZmlyc3RDaGlsZERvbSA9PSBudWxsKSB7XG5cdFx0XHRcdGZpcnN0Q2hpbGREb20gPSBuZXdEb207XG5cdFx0XHR9XG5cblx0XHRcdGlmIChcblx0XHRcdFx0dHlwZW9mIGNoaWxkVk5vZGUudHlwZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0XHRcdGNoaWxkVk5vZGUuX2NoaWxkcmVuID09PSBvbGRWTm9kZS5fY2hpbGRyZW5cblx0XHRcdCkge1xuXHRcdFx0XHRjaGlsZFZOb2RlLl9uZXh0RG9tID0gb2xkRG9tID0gcmVvcmRlckNoaWxkcmVuKFxuXHRcdFx0XHRcdGNoaWxkVk5vZGUsXG5cdFx0XHRcdFx0b2xkRG9tLFxuXHRcdFx0XHRcdHBhcmVudERvbVxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2xkRG9tID0gcGxhY2VDaGlsZChcblx0XHRcdFx0XHRwYXJlbnREb20sXG5cdFx0XHRcdFx0Y2hpbGRWTm9kZSxcblx0XHRcdFx0XHRvbGRWTm9kZSxcblx0XHRcdFx0XHRvbGRDaGlsZHJlbixcblx0XHRcdFx0XHRuZXdEb20sXG5cdFx0XHRcdFx0b2xkRG9tXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0eXBlb2YgbmV3UGFyZW50Vk5vZGUudHlwZSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdC8vIEJlY2F1c2UgdGhlIG5ld1BhcmVudFZOb2RlIGlzIEZyYWdtZW50LWxpa2UsIHdlIG5lZWQgdG8gc2V0IGl0J3Ncblx0XHRcdFx0Ly8gX25leHREb20gcHJvcGVydHkgdG8gdGhlIG5leHRTaWJsaW5nIG9mIGl0cyBsYXN0IGNoaWxkIERPTSBub2RlLlxuXHRcdFx0XHQvL1xuXHRcdFx0XHQvLyBgb2xkRG9tYCBjb250YWlucyB0aGUgY29ycmVjdCB2YWx1ZSBoZXJlIGJlY2F1c2UgaWYgdGhlIGxhc3QgY2hpbGRcblx0XHRcdFx0Ly8gaXMgYSBGcmFnbWVudC1saWtlLCB0aGVuIG9sZERvbSBoYXMgYWxyZWFkeSBiZWVuIHNldCB0byB0aGF0IGNoaWxkJ3MgX25leHREb20uXG5cdFx0XHRcdC8vIElmIHRoZSBsYXN0IGNoaWxkIGlzIGEgRE9NIFZOb2RlLCB0aGVuIG9sZERvbSB3aWxsIGJlIHNldCB0byB0aGF0IERPTVxuXHRcdFx0XHQvLyBub2RlJ3MgbmV4dFNpYmxpbmcuXG5cdFx0XHRcdG5ld1BhcmVudFZOb2RlLl9uZXh0RG9tID0gb2xkRG9tO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRvbGREb20gJiZcblx0XHRcdG9sZFZOb2RlLl9kb20gPT0gb2xkRG9tICYmXG5cdFx0XHRvbGREb20ucGFyZW50Tm9kZSAhPSBwYXJlbnREb21cblx0XHQpIHtcblx0XHRcdC8vIFRoZSBhYm92ZSBjb25kaXRpb24gaXMgdG8gaGFuZGxlIG51bGwgcGxhY2Vob2xkZXJzLiBTZWUgdGVzdCBpbiBwbGFjZWhvbGRlci50ZXN0LmpzOlxuXHRcdFx0Ly8gYGVmZmljaWVudGx5IHJlcGxhY2UgbnVsbCBwbGFjZWhvbGRlcnMgaW4gcGFyZW50IHJlcmVuZGVyc2Bcblx0XHRcdG9sZERvbSA9IGdldERvbVNpYmxpbmcob2xkVk5vZGUpO1xuXHRcdH1cblx0fVxuXG5cdG5ld1BhcmVudFZOb2RlLl9kb20gPSBmaXJzdENoaWxkRG9tO1xuXG5cdC8vIFJlbW92ZSByZW1haW5pbmcgb2xkQ2hpbGRyZW4gaWYgdGhlcmUgYXJlIGFueS5cblx0Zm9yIChpID0gb2xkQ2hpbGRyZW5MZW5ndGg7IGktLTsgKSB7XG5cdFx0aWYgKG9sZENoaWxkcmVuW2ldICE9IG51bGwpIHtcblx0XHRcdGlmIChcblx0XHRcdFx0dHlwZW9mIG5ld1BhcmVudFZOb2RlLnR5cGUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdFx0XHRvbGRDaGlsZHJlbltpXS5fZG9tICE9IG51bGwgJiZcblx0XHRcdFx0b2xkQ2hpbGRyZW5baV0uX2RvbSA9PSBuZXdQYXJlbnRWTm9kZS5fbmV4dERvbVxuXHRcdFx0KSB7XG5cdFx0XHRcdC8vIElmIHRoZSBuZXdQYXJlbnRWTm9kZS5fX25leHREb20gcG9pbnRzIHRvIGEgZG9tIG5vZGUgdGhhdCBpcyBhYm91dCB0b1xuXHRcdFx0XHQvLyBiZSB1bm1vdW50ZWQsIHRoZW4gZ2V0IHRoZSBuZXh0IHNpYmxpbmcgb2YgdGhhdCB2bm9kZSBhbmQgc2V0XG5cdFx0XHRcdC8vIF9uZXh0RG9tIHRvIGl0XG5cdFx0XHRcdG5ld1BhcmVudFZOb2RlLl9uZXh0RG9tID0gZ2V0TGFzdERvbShvbGRQYXJlbnRWTm9kZSkubmV4dFNpYmxpbmc7XG5cdFx0XHR9XG5cblx0XHRcdHVubW91bnQob2xkQ2hpbGRyZW5baV0sIG9sZENoaWxkcmVuW2ldKTtcblx0XHR9XG5cdH1cblxuXHQvLyBTZXQgcmVmcyBvbmx5IGFmdGVyIHVubW91bnRcblx0aWYgKHJlZnMpIHtcblx0XHRmb3IgKGkgPSAwOyBpIDwgcmVmcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0YXBwbHlSZWYocmVmc1tpXSwgcmVmc1srK2ldLCByZWZzWysraV0pO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiByZW9yZGVyQ2hpbGRyZW4oY2hpbGRWTm9kZSwgb2xkRG9tLCBwYXJlbnREb20pIHtcblx0Ly8gTm90ZTogVk5vZGVzIGluIG5lc3RlZCBzdXNwZW5kZWQgdHJlZXMgbWF5IGJlIG1pc3NpbmcgX2NoaWxkcmVuLlxuXHRsZXQgYyA9IGNoaWxkVk5vZGUuX2NoaWxkcmVuO1xuXHRsZXQgdG1wID0gMDtcblx0Zm9yICg7IGMgJiYgdG1wIDwgYy5sZW5ndGg7IHRtcCsrKSB7XG5cdFx0bGV0IHZub2RlID0gY1t0bXBdO1xuXHRcdGlmICh2bm9kZSkge1xuXHRcdFx0Ly8gV2UgdHlwaWNhbGx5IGVudGVyIHRoaXMgY29kZSBwYXRoIG9uIHNDVSBiYWlsb3V0LCB3aGVyZSB3ZSBjb3B5XG5cdFx0XHQvLyBvbGRWTm9kZS5fY2hpbGRyZW4gdG8gbmV3Vk5vZGUuX2NoaWxkcmVuLiBJZiB0aGF0IGlzIHRoZSBjYXNlLCB3ZSBuZWVkXG5cdFx0XHQvLyB0byB1cGRhdGUgdGhlIG9sZCBjaGlsZHJlbidzIF9wYXJlbnQgcG9pbnRlciB0byBwb2ludCB0byB0aGUgbmV3Vk5vZGVcblx0XHRcdC8vIChjaGlsZFZOb2RlIGhlcmUpLlxuXHRcdFx0dm5vZGUuX3BhcmVudCA9IGNoaWxkVk5vZGU7XG5cblx0XHRcdGlmICh0eXBlb2Ygdm5vZGUudHlwZSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdG9sZERvbSA9IHJlb3JkZXJDaGlsZHJlbih2bm9kZSwgb2xkRG9tLCBwYXJlbnREb20pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2xkRG9tID0gcGxhY2VDaGlsZChwYXJlbnREb20sIHZub2RlLCB2bm9kZSwgYywgdm5vZGUuX2RvbSwgb2xkRG9tKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gb2xkRG9tO1xufVxuXG4vKipcbiAqIEZsYXR0ZW4gYW5kIGxvb3AgdGhyb3VnaCB0aGUgY2hpbGRyZW4gb2YgYSB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbmRleCcpLkNvbXBvbmVudENoaWxkcmVufSBjaGlsZHJlbiBUaGUgdW5mbGF0dGVuZWRcbiAqIGNoaWxkcmVuIG9mIGEgdmlydHVhbCBub2RlXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlW119XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0NoaWxkQXJyYXkoY2hpbGRyZW4sIG91dCkge1xuXHRvdXQgPSBvdXQgfHwgW107XG5cdGlmIChjaGlsZHJlbiA9PSBudWxsIHx8IHR5cGVvZiBjaGlsZHJlbiA9PSAnYm9vbGVhbicpIHtcblx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuXHRcdGNoaWxkcmVuLnNvbWUoY2hpbGQgPT4ge1xuXHRcdFx0dG9DaGlsZEFycmF5KGNoaWxkLCBvdXQpO1xuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdG91dC5wdXNoKGNoaWxkcmVuKTtcblx0fVxuXHRyZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiBwbGFjZUNoaWxkKFxuXHRwYXJlbnREb20sXG5cdGNoaWxkVk5vZGUsXG5cdG9sZFZOb2RlLFxuXHRvbGRDaGlsZHJlbixcblx0bmV3RG9tLFxuXHRvbGREb21cbikge1xuXHRsZXQgbmV4dERvbTtcblx0aWYgKGNoaWxkVk5vZGUuX25leHREb20gIT09IHVuZGVmaW5lZCkge1xuXHRcdC8vIE9ubHkgRnJhZ21lbnRzIG9yIGNvbXBvbmVudHMgdGhhdCByZXR1cm4gRnJhZ21lbnQgbGlrZSBWTm9kZXMgd2lsbFxuXHRcdC8vIGhhdmUgYSBub24tdW5kZWZpbmVkIF9uZXh0RG9tLiBDb250aW51ZSB0aGUgZGlmZiBmcm9tIHRoZSBzaWJsaW5nXG5cdFx0Ly8gb2YgbGFzdCBET00gY2hpbGQgb2YgdGhpcyBjaGlsZCBWTm9kZVxuXHRcdG5leHREb20gPSBjaGlsZFZOb2RlLl9uZXh0RG9tO1xuXG5cdFx0Ly8gRWFnZXJseSBjbGVhbnVwIF9uZXh0RG9tLiBXZSBkb24ndCBuZWVkIHRvIHBlcnNpc3QgdGhlIHZhbHVlIGJlY2F1c2Vcblx0XHQvLyBpdCBpcyBvbmx5IHVzZWQgYnkgYGRpZmZDaGlsZHJlbmAgdG8gZGV0ZXJtaW5lIHdoZXJlIHRvIHJlc3VtZSB0aGUgZGlmZiBhZnRlclxuXHRcdC8vIGRpZmZpbmcgQ29tcG9uZW50cyBhbmQgRnJhZ21lbnRzLiBPbmNlIHdlIHN0b3JlIGl0IHRoZSBuZXh0RE9NIGxvY2FsIHZhciwgd2Vcblx0XHQvLyBjYW4gY2xlYW4gdXAgdGhlIHByb3BlcnR5XG5cdFx0Y2hpbGRWTm9kZS5fbmV4dERvbSA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmIChcblx0XHRvbGRWTm9kZSA9PSBudWxsIHx8XG5cdFx0bmV3RG9tICE9IG9sZERvbSB8fFxuXHRcdG5ld0RvbS5wYXJlbnROb2RlID09IG51bGxcblx0KSB7XG5cdFx0b3V0ZXI6IGlmIChvbGREb20gPT0gbnVsbCB8fCBvbGREb20ucGFyZW50Tm9kZSAhPT0gcGFyZW50RG9tKSB7XG5cdFx0XHRwYXJlbnREb20uYXBwZW5kQ2hpbGQobmV3RG9tKTtcblx0XHRcdG5leHREb20gPSBudWxsO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBgajxvbGRDaGlsZHJlbkxlbmd0aDsgais9MmAgaXMgYW4gYWx0ZXJuYXRpdmUgdG8gYGorKzxvbGRDaGlsZHJlbkxlbmd0aC8yYFxuXHRcdFx0Zm9yIChcblx0XHRcdFx0bGV0IHNpYkRvbSA9IG9sZERvbSwgaiA9IDA7XG5cdFx0XHRcdChzaWJEb20gPSBzaWJEb20ubmV4dFNpYmxpbmcpICYmIGogPCBvbGRDaGlsZHJlbi5sZW5ndGg7XG5cdFx0XHRcdGogKz0gMVxuXHRcdFx0KSB7XG5cdFx0XHRcdGlmIChzaWJEb20gPT0gbmV3RG9tKSB7XG5cdFx0XHRcdFx0YnJlYWsgb3V0ZXI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHBhcmVudERvbS5pbnNlcnRCZWZvcmUobmV3RG9tLCBvbGREb20pO1xuXHRcdFx0bmV4dERvbSA9IG9sZERvbTtcblx0XHR9XG5cdH1cblxuXHQvLyBJZiB3ZSBoYXZlIHByZS1jYWxjdWxhdGVkIHRoZSBuZXh0RE9NIG5vZGUsIHVzZSBpdC4gRWxzZSBjYWxjdWxhdGUgaXQgbm93XG5cdC8vIFN0cmljdGx5IGNoZWNrIGZvciBgdW5kZWZpbmVkYCBoZXJlIGN1eiBgbnVsbGAgaXMgYSB2YWxpZCB2YWx1ZSBvZiBgbmV4dERvbWAuXG5cdC8vIFNlZSBtb3JlIGRldGFpbCBpbiBjcmVhdGUtZWxlbWVudC5qczpjcmVhdGVWTm9kZVxuXHRpZiAobmV4dERvbSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0b2xkRG9tID0gbmV4dERvbTtcblx0fSBlbHNlIHtcblx0XHRvbGREb20gPSBuZXdEb20ubmV4dFNpYmxpbmc7XG5cdH1cblxuXHRyZXR1cm4gb2xkRG9tO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICovXG5mdW5jdGlvbiBnZXRMYXN0RG9tKHZub2RlKSB7XG5cdGlmICh2bm9kZS50eXBlID09IG51bGwgfHwgdHlwZW9mIHZub2RlLnR5cGUgPT09ICdzdHJpbmcnKSB7XG5cdFx0cmV0dXJuIHZub2RlLl9kb207XG5cdH1cblxuXHRpZiAodm5vZGUuX2NoaWxkcmVuKSB7XG5cdFx0Zm9yIChsZXQgaSA9IHZub2RlLl9jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0bGV0IGNoaWxkID0gdm5vZGUuX2NoaWxkcmVuW2ldO1xuXHRcdFx0aWYgKGNoaWxkKSB7XG5cdFx0XHRcdGxldCBsYXN0RG9tID0gZ2V0TGFzdERvbShjaGlsZCk7XG5cdFx0XHRcdGlmIChsYXN0RG9tKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGxhc3REb207XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbnVsbDtcbn1cbiIsICJpbXBvcnQgeyBFTVBUWV9PQkogfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBnZXREb21TaWJsaW5nIH0gZnJvbSAnLi4vY29tcG9uZW50JztcbmltcG9ydCB7IEZyYWdtZW50IH0gZnJvbSAnLi4vY3JlYXRlLWVsZW1lbnQnO1xuaW1wb3J0IHsgZGlmZkNoaWxkcmVuIH0gZnJvbSAnLi9jaGlsZHJlbic7XG5pbXBvcnQgeyBkaWZmUHJvcHMsIHNldFByb3BlcnR5IH0gZnJvbSAnLi9wcm9wcyc7XG5pbXBvcnQgeyBhc3NpZ24sIHJlbW92ZU5vZGUsIHNsaWNlIH0gZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgb3B0aW9ucyBmcm9tICcuLi9vcHRpb25zJztcblxuLyoqXG4gKiBEaWZmIHR3byB2aXJ0dWFsIG5vZGVzIGFuZCBhcHBseSBwcm9wZXIgY2hhbmdlcyB0byB0aGUgRE9NXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBwYXJlbnREb20gVGhlIHBhcmVudCBvZiB0aGUgRE9NIGVsZW1lbnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBuZXdWTm9kZSBUaGUgbmV3IHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IG9sZFZOb2RlIFRoZSBvbGQgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gZ2xvYmFsQ29udGV4dCBUaGUgY3VycmVudCBjb250ZXh0IG9iamVjdC4gTW9kaWZpZWQgYnkgZ2V0Q2hpbGRDb250ZXh0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3ZnIFdoZXRoZXIgb3Igbm90IHRoaXMgZWxlbWVudCBpcyBhbiBTVkcgbm9kZVxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudD59IGV4Y2Vzc0RvbUNoaWxkcmVuXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5Db21wb25lbnQ+fSBjb21taXRRdWV1ZSBMaXN0IG9mIGNvbXBvbmVudHNcbiAqIHdoaWNoIGhhdmUgY2FsbGJhY2tzIHRvIGludm9rZSBpbiBjb21taXRSb290XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBvbGREb20gVGhlIGN1cnJlbnQgYXR0YWNoZWQgRE9NXG4gKiBlbGVtZW50IGFueSBuZXcgZG9tIGVsZW1lbnRzIHNob3VsZCBiZSBwbGFjZWQgYXJvdW5kLiBMaWtlbHkgYG51bGxgIG9uIGZpcnN0XG4gKiByZW5kZXIgKGV4Y2VwdCB3aGVuIGh5ZHJhdGluZykuIENhbiBiZSBhIHNpYmxpbmcgRE9NIGVsZW1lbnQgd2hlbiBkaWZmaW5nXG4gKiBGcmFnbWVudHMgdGhhdCBoYXZlIHNpYmxpbmdzLiBJbiBtb3N0IGNhc2VzLCBpdCBzdGFydHMgb3V0IGFzIGBvbGRDaGlsZHJlblswXS5fZG9tYC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzSHlkcmF0aW5nXSBXaGV0aGVyIG9yIG5vdCB3ZSBhcmUgaW4gaHlkcmF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaWZmKFxuXHRwYXJlbnREb20sXG5cdG5ld1ZOb2RlLFxuXHRvbGRWTm9kZSxcblx0Z2xvYmFsQ29udGV4dCxcblx0aXNTdmcsXG5cdGV4Y2Vzc0RvbUNoaWxkcmVuLFxuXHRjb21taXRRdWV1ZSxcblx0b2xkRG9tLFxuXHRpc0h5ZHJhdGluZ1xuKSB7XG5cdGxldCB0bXAsXG5cdFx0bmV3VHlwZSA9IG5ld1ZOb2RlLnR5cGU7XG5cblx0Ly8gV2hlbiBwYXNzaW5nIHRocm91Z2ggY3JlYXRlRWxlbWVudCBpdCBhc3NpZ25zIHRoZSBvYmplY3Rcblx0Ly8gY29uc3RydWN0b3IgYXMgdW5kZWZpbmVkLiBUaGlzIHRvIHByZXZlbnQgSlNPTi1pbmplY3Rpb24uXG5cdGlmIChuZXdWTm9kZS5jb25zdHJ1Y3RvciAhPT0gdW5kZWZpbmVkKSByZXR1cm4gbnVsbDtcblxuXHQvLyBJZiB0aGUgcHJldmlvdXMgZGlmZiBiYWlsZWQgb3V0LCByZXN1bWUgY3JlYXRpbmcvaHlkcmF0aW5nLlxuXHRpZiAob2xkVk5vZGUuX2h5ZHJhdGluZyAhPSBudWxsKSB7XG5cdFx0aXNIeWRyYXRpbmcgPSBvbGRWTm9kZS5faHlkcmF0aW5nO1xuXHRcdG9sZERvbSA9IG5ld1ZOb2RlLl9kb20gPSBvbGRWTm9kZS5fZG9tO1xuXHRcdC8vIGlmIHdlIHJlc3VtZSwgd2Ugd2FudCB0aGUgdHJlZSB0byBiZSBcInVubG9ja2VkXCJcblx0XHRuZXdWTm9kZS5faHlkcmF0aW5nID0gbnVsbDtcblx0XHRleGNlc3NEb21DaGlsZHJlbiA9IFtvbGREb21dO1xuXHR9XG5cblx0aWYgKCh0bXAgPSBvcHRpb25zLl9kaWZmKSkgdG1wKG5ld1ZOb2RlKTtcblxuXHR0cnkge1xuXHRcdG91dGVyOiBpZiAodHlwZW9mIG5ld1R5cGUgPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0bGV0IGMsIGlzTmV3LCBvbGRQcm9wcywgb2xkU3RhdGUsIHNuYXBzaG90LCBjbGVhclByb2Nlc3NpbmdFeGNlcHRpb247XG5cdFx0XHRsZXQgbmV3UHJvcHMgPSBuZXdWTm9kZS5wcm9wcztcblxuXHRcdFx0Ly8gTmVjZXNzYXJ5IGZvciBjcmVhdGVDb250ZXh0IGFwaS4gU2V0dGluZyB0aGlzIHByb3BlcnR5IHdpbGwgcGFzc1xuXHRcdFx0Ly8gdGhlIGNvbnRleHQgdmFsdWUgYXMgYHRoaXMuY29udGV4dGAganVzdCBmb3IgdGhpcyBjb21wb25lbnQuXG5cdFx0XHR0bXAgPSBuZXdUeXBlLmNvbnRleHRUeXBlO1xuXHRcdFx0bGV0IHByb3ZpZGVyID0gdG1wICYmIGdsb2JhbENvbnRleHRbdG1wLl9pZF07XG5cdFx0XHRsZXQgY29tcG9uZW50Q29udGV4dCA9IHRtcFxuXHRcdFx0XHQ/IHByb3ZpZGVyXG5cdFx0XHRcdFx0PyBwcm92aWRlci5wcm9wcy52YWx1ZVxuXHRcdFx0XHRcdDogdG1wLl9kZWZhdWx0VmFsdWVcblx0XHRcdFx0OiBnbG9iYWxDb250ZXh0O1xuXG5cdFx0XHQvLyBHZXQgY29tcG9uZW50IGFuZCBzZXQgaXQgdG8gYGNgXG5cdFx0XHRpZiAob2xkVk5vZGUuX2NvbXBvbmVudCkge1xuXHRcdFx0XHRjID0gbmV3Vk5vZGUuX2NvbXBvbmVudCA9IG9sZFZOb2RlLl9jb21wb25lbnQ7XG5cdFx0XHRcdGNsZWFyUHJvY2Vzc2luZ0V4Y2VwdGlvbiA9IGMuX3Byb2Nlc3NpbmdFeGNlcHRpb24gPSBjLl9wZW5kaW5nRXJyb3I7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBJbnN0YW50aWF0ZSB0aGUgbmV3IGNvbXBvbmVudFxuXHRcdFx0XHRpZiAoJ3Byb3RvdHlwZScgaW4gbmV3VHlwZSAmJiBuZXdUeXBlLnByb3RvdHlwZS5yZW5kZXIpIHtcblx0XHRcdFx0XHQvLyBAdHMtaWdub3JlIFRoZSBjaGVjayBhYm92ZSB2ZXJpZmllcyB0aGF0IG5ld1R5cGUgaXMgc3VwcG9zZSB0byBiZSBjb25zdHJ1Y3RlZFxuXHRcdFx0XHRcdG5ld1ZOb2RlLl9jb21wb25lbnQgPSBjID0gbmV3IG5ld1R5cGUobmV3UHJvcHMsIGNvbXBvbmVudENvbnRleHQpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5ldy1jYXBcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBAdHMtaWdub3JlIFRydXN0IG1lLCBDb21wb25lbnQgaW1wbGVtZW50cyB0aGUgaW50ZXJmYWNlIHdlIHdhbnRcblx0XHRcdFx0XHRuZXdWTm9kZS5fY29tcG9uZW50ID0gYyA9IG5ldyBDb21wb25lbnQobmV3UHJvcHMsIGNvbXBvbmVudENvbnRleHQpO1xuXHRcdFx0XHRcdGMuY29uc3RydWN0b3IgPSBuZXdUeXBlO1xuXHRcdFx0XHRcdGMucmVuZGVyID0gZG9SZW5kZXI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHByb3ZpZGVyKSBwcm92aWRlci5zdWIoYyk7XG5cblx0XHRcdFx0Yy5wcm9wcyA9IG5ld1Byb3BzO1xuXHRcdFx0XHRpZiAoIWMuc3RhdGUpIGMuc3RhdGUgPSB7fTtcblx0XHRcdFx0Yy5jb250ZXh0ID0gY29tcG9uZW50Q29udGV4dDtcblx0XHRcdFx0Yy5fZ2xvYmFsQ29udGV4dCA9IGdsb2JhbENvbnRleHQ7XG5cdFx0XHRcdGlzTmV3ID0gYy5fZGlydHkgPSB0cnVlO1xuXHRcdFx0XHRjLl9yZW5kZXJDYWxsYmFja3MgPSBbXTtcblx0XHRcdFx0Yy5fc3RhdGVDYWxsYmFja3MgPSBbXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSW52b2tlIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc1xuXHRcdFx0aWYgKGMuX25leHRTdGF0ZSA9PSBudWxsKSB7XG5cdFx0XHRcdGMuX25leHRTdGF0ZSA9IGMuc3RhdGU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChuZXdUeXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAhPSBudWxsKSB7XG5cdFx0XHRcdGlmIChjLl9uZXh0U3RhdGUgPT0gYy5zdGF0ZSkge1xuXHRcdFx0XHRcdGMuX25leHRTdGF0ZSA9IGFzc2lnbih7fSwgYy5fbmV4dFN0YXRlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGFzc2lnbihcblx0XHRcdFx0XHRjLl9uZXh0U3RhdGUsXG5cdFx0XHRcdFx0bmV3VHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV3UHJvcHMsIGMuX25leHRTdGF0ZSlcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0b2xkUHJvcHMgPSBjLnByb3BzO1xuXHRcdFx0b2xkU3RhdGUgPSBjLnN0YXRlO1xuXHRcdFx0Yy5fdm5vZGUgPSBuZXdWTm9kZTtcblxuXHRcdFx0Ly8gSW52b2tlIHByZS1yZW5kZXIgbGlmZWN5Y2xlIG1ldGhvZHNcblx0XHRcdGlmIChpc05ldykge1xuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0bmV3VHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT0gbnVsbCAmJlxuXHRcdFx0XHRcdGMuY29tcG9uZW50V2lsbE1vdW50ICE9IG51bGxcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0Yy5jb21wb25lbnRXaWxsTW91bnQoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjLmNvbXBvbmVudERpZE1vdW50ICE9IG51bGwpIHtcblx0XHRcdFx0XHRjLl9yZW5kZXJDYWxsYmFja3MucHVzaChjLmNvbXBvbmVudERpZE1vdW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdG5ld1R5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09IG51bGwgJiZcblx0XHRcdFx0XHRuZXdQcm9wcyAhPT0gb2xkUHJvcHMgJiZcblx0XHRcdFx0XHRjLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgIT0gbnVsbFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRjLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMsIGNvbXBvbmVudENvbnRleHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdCghYy5fZm9yY2UgJiZcblx0XHRcdFx0XHRcdGMuc2hvdWxkQ29tcG9uZW50VXBkYXRlICE9IG51bGwgJiZcblx0XHRcdFx0XHRcdGMuc2hvdWxkQ29tcG9uZW50VXBkYXRlKFxuXHRcdFx0XHRcdFx0XHRuZXdQcm9wcyxcblx0XHRcdFx0XHRcdFx0Yy5fbmV4dFN0YXRlLFxuXHRcdFx0XHRcdFx0XHRjb21wb25lbnRDb250ZXh0XG5cdFx0XHRcdFx0XHQpID09PSBmYWxzZSkgfHxcblx0XHRcdFx0XHRuZXdWTm9kZS5fb3JpZ2luYWwgPT09IG9sZFZOb2RlLl9vcmlnaW5hbFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHQvLyBNb3JlIGluZm8gYWJvdXQgdGhpcyBoZXJlOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9Kb3ZpRGVDcm9vY2svYmVjNWYyY2U5MzU0NGQyZTYwNzBlZjhlMDAzNmU0ZThcblx0XHRcdFx0XHRpZiAobmV3Vk5vZGUuX29yaWdpbmFsICE9PSBvbGRWTm9kZS5fb3JpZ2luYWwpIHtcblx0XHRcdFx0XHRcdC8vIFdoZW4gd2UgYXJlIGRlYWxpbmcgd2l0aCBhIGJhaWwgYmVjYXVzZSBvZiBzQ1Ugd2UgaGF2ZSB0byB1cGRhdGVcblx0XHRcdFx0XHRcdC8vIHRoZSBwcm9wcywgc3RhdGUgYW5kIGRpcnR5LXN0YXRlLlxuXHRcdFx0XHRcdFx0Ly8gd2hlbiB3ZSBhcmUgZGVhbGluZyB3aXRoIHN0cmljdC1lcXVhbGl0eSB3ZSBkb24ndCBhcyB0aGUgY2hpbGQgY291bGQgc3RpbGxcblx0XHRcdFx0XHRcdC8vIGJlIGRpcnRpZWQgc2VlICMzODgzXG5cdFx0XHRcdFx0XHRjLnByb3BzID0gbmV3UHJvcHM7XG5cdFx0XHRcdFx0XHRjLnN0YXRlID0gYy5fbmV4dFN0YXRlO1xuXHRcdFx0XHRcdFx0Yy5fZGlydHkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bmV3Vk5vZGUuX2RvbSA9IG9sZFZOb2RlLl9kb207XG5cdFx0XHRcdFx0bmV3Vk5vZGUuX2NoaWxkcmVuID0gb2xkVk5vZGUuX2NoaWxkcmVuO1xuXHRcdFx0XHRcdG5ld1ZOb2RlLl9jaGlsZHJlbi5mb3JFYWNoKHZub2RlID0+IHtcblx0XHRcdFx0XHRcdGlmICh2bm9kZSkgdm5vZGUuX3BhcmVudCA9IG5ld1ZOb2RlO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjLl9zdGF0ZUNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0Yy5fcmVuZGVyQ2FsbGJhY2tzLnB1c2goYy5fc3RhdGVDYWxsYmFja3NbaV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjLl9zdGF0ZUNhbGxiYWNrcyA9IFtdO1xuXG5cdFx0XHRcdFx0aWYgKGMuX3JlbmRlckNhbGxiYWNrcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdGNvbW1pdFF1ZXVlLnB1c2goYyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWsgb3V0ZXI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoYy5jb21wb25lbnRXaWxsVXBkYXRlICE9IG51bGwpIHtcblx0XHRcdFx0XHRjLmNvbXBvbmVudFdpbGxVcGRhdGUobmV3UHJvcHMsIGMuX25leHRTdGF0ZSwgY29tcG9uZW50Q29udGV4dCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoYy5jb21wb25lbnREaWRVcGRhdGUgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGMuX3JlbmRlckNhbGxiYWNrcy5wdXNoKCgpID0+IHtcblx0XHRcdFx0XHRcdGMuY29tcG9uZW50RGlkVXBkYXRlKG9sZFByb3BzLCBvbGRTdGF0ZSwgc25hcHNob3QpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGMuY29udGV4dCA9IGNvbXBvbmVudENvbnRleHQ7XG5cdFx0XHRjLnByb3BzID0gbmV3UHJvcHM7XG5cdFx0XHRjLl9wYXJlbnREb20gPSBwYXJlbnREb207XG5cblx0XHRcdGxldCByZW5kZXJIb29rID0gb3B0aW9ucy5fcmVuZGVyLFxuXHRcdFx0XHRjb3VudCA9IDA7XG5cdFx0XHRpZiAoJ3Byb3RvdHlwZScgaW4gbmV3VHlwZSAmJiBuZXdUeXBlLnByb3RvdHlwZS5yZW5kZXIpIHtcblx0XHRcdFx0Yy5zdGF0ZSA9IGMuX25leHRTdGF0ZTtcblx0XHRcdFx0Yy5fZGlydHkgPSBmYWxzZTtcblxuXHRcdFx0XHRpZiAocmVuZGVySG9vaykgcmVuZGVySG9vayhuZXdWTm9kZSk7XG5cblx0XHRcdFx0dG1wID0gYy5yZW5kZXIoYy5wcm9wcywgYy5zdGF0ZSwgYy5jb250ZXh0KTtcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGMuX3N0YXRlQ2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0Yy5fcmVuZGVyQ2FsbGJhY2tzLnB1c2goYy5fc3RhdGVDYWxsYmFja3NbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGMuX3N0YXRlQ2FsbGJhY2tzID0gW107XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0Yy5fZGlydHkgPSBmYWxzZTtcblx0XHRcdFx0XHRpZiAocmVuZGVySG9vaykgcmVuZGVySG9vayhuZXdWTm9kZSk7XG5cblx0XHRcdFx0XHR0bXAgPSBjLnJlbmRlcihjLnByb3BzLCBjLnN0YXRlLCBjLmNvbnRleHQpO1xuXG5cdFx0XHRcdFx0Ly8gSGFuZGxlIHNldFN0YXRlIGNhbGxlZCBpbiByZW5kZXIsIHNlZSAjMjU1M1xuXHRcdFx0XHRcdGMuc3RhdGUgPSBjLl9uZXh0U3RhdGU7XG5cdFx0XHRcdH0gd2hpbGUgKGMuX2RpcnR5ICYmICsrY291bnQgPCAyNSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhhbmRsZSBzZXRTdGF0ZSBjYWxsZWQgaW4gcmVuZGVyLCBzZWUgIzI1NTNcblx0XHRcdGMuc3RhdGUgPSBjLl9uZXh0U3RhdGU7XG5cblx0XHRcdGlmIChjLmdldENoaWxkQ29udGV4dCAhPSBudWxsKSB7XG5cdFx0XHRcdGdsb2JhbENvbnRleHQgPSBhc3NpZ24oYXNzaWduKHt9LCBnbG9iYWxDb250ZXh0KSwgYy5nZXRDaGlsZENvbnRleHQoKSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghaXNOZXcgJiYgYy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSAhPSBudWxsKSB7XG5cdFx0XHRcdHNuYXBzaG90ID0gYy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZShvbGRQcm9wcywgb2xkU3RhdGUpO1xuXHRcdFx0fVxuXG5cdFx0XHRsZXQgaXNUb3BMZXZlbEZyYWdtZW50ID1cblx0XHRcdFx0dG1wICE9IG51bGwgJiYgdG1wLnR5cGUgPT09IEZyYWdtZW50ICYmIHRtcC5rZXkgPT0gbnVsbDtcblx0XHRcdGxldCByZW5kZXJSZXN1bHQgPSBpc1RvcExldmVsRnJhZ21lbnQgPyB0bXAucHJvcHMuY2hpbGRyZW4gOiB0bXA7XG5cblx0XHRcdGRpZmZDaGlsZHJlbihcblx0XHRcdFx0cGFyZW50RG9tLFxuXHRcdFx0XHRBcnJheS5pc0FycmF5KHJlbmRlclJlc3VsdCkgPyByZW5kZXJSZXN1bHQgOiBbcmVuZGVyUmVzdWx0XSxcblx0XHRcdFx0bmV3Vk5vZGUsXG5cdFx0XHRcdG9sZFZOb2RlLFxuXHRcdFx0XHRnbG9iYWxDb250ZXh0LFxuXHRcdFx0XHRpc1N2Zyxcblx0XHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdFx0XHRcdGNvbW1pdFF1ZXVlLFxuXHRcdFx0XHRvbGREb20sXG5cdFx0XHRcdGlzSHlkcmF0aW5nXG5cdFx0XHQpO1xuXG5cdFx0XHRjLmJhc2UgPSBuZXdWTm9kZS5fZG9tO1xuXG5cdFx0XHQvLyBXZSBzdWNjZXNzZnVsbHkgcmVuZGVyZWQgdGhpcyBWTm9kZSwgdW5zZXQgYW55IHN0b3JlZCBoeWRyYXRpb24vYmFpbG91dCBzdGF0ZTpcblx0XHRcdG5ld1ZOb2RlLl9oeWRyYXRpbmcgPSBudWxsO1xuXG5cdFx0XHRpZiAoYy5fcmVuZGVyQ2FsbGJhY2tzLmxlbmd0aCkge1xuXHRcdFx0XHRjb21taXRRdWV1ZS5wdXNoKGMpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoY2xlYXJQcm9jZXNzaW5nRXhjZXB0aW9uKSB7XG5cdFx0XHRcdGMuX3BlbmRpbmdFcnJvciA9IGMuX3Byb2Nlc3NpbmdFeGNlcHRpb24gPSBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRjLl9mb3JjZSA9IGZhbHNlO1xuXHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRleGNlc3NEb21DaGlsZHJlbiA9PSBudWxsICYmXG5cdFx0XHRuZXdWTm9kZS5fb3JpZ2luYWwgPT09IG9sZFZOb2RlLl9vcmlnaW5hbFxuXHRcdCkge1xuXHRcdFx0bmV3Vk5vZGUuX2NoaWxkcmVuID0gb2xkVk5vZGUuX2NoaWxkcmVuO1xuXHRcdFx0bmV3Vk5vZGUuX2RvbSA9IG9sZFZOb2RlLl9kb207XG5cdFx0fSBlbHNlIHtcblx0XHRcdG5ld1ZOb2RlLl9kb20gPSBkaWZmRWxlbWVudE5vZGVzKFxuXHRcdFx0XHRvbGRWTm9kZS5fZG9tLFxuXHRcdFx0XHRuZXdWTm9kZSxcblx0XHRcdFx0b2xkVk5vZGUsXG5cdFx0XHRcdGdsb2JhbENvbnRleHQsXG5cdFx0XHRcdGlzU3ZnLFxuXHRcdFx0XHRleGNlc3NEb21DaGlsZHJlbixcblx0XHRcdFx0Y29tbWl0UXVldWUsXG5cdFx0XHRcdGlzSHlkcmF0aW5nXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGlmICgodG1wID0gb3B0aW9ucy5kaWZmZWQpKSB0bXAobmV3Vk5vZGUpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0bmV3Vk5vZGUuX29yaWdpbmFsID0gbnVsbDtcblx0XHQvLyBpZiBoeWRyYXRpbmcgb3IgY3JlYXRpbmcgaW5pdGlhbCB0cmVlLCBiYWlsb3V0IHByZXNlcnZlcyBET006XG5cdFx0aWYgKGlzSHlkcmF0aW5nIHx8IGV4Y2Vzc0RvbUNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRcdG5ld1ZOb2RlLl9kb20gPSBvbGREb207XG5cdFx0XHRuZXdWTm9kZS5faHlkcmF0aW5nID0gISFpc0h5ZHJhdGluZztcblx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuW2V4Y2Vzc0RvbUNoaWxkcmVuLmluZGV4T2Yob2xkRG9tKV0gPSBudWxsO1xuXHRcdFx0Ly8gXiBjb3VsZCBwb3NzaWJseSBiZSBzaW1wbGlmaWVkIHRvOlxuXHRcdFx0Ly8gZXhjZXNzRG9tQ2hpbGRyZW4ubGVuZ3RoID0gMDtcblx0XHR9XG5cdFx0b3B0aW9ucy5fY2F0Y2hFcnJvcihlLCBuZXdWTm9kZSwgb2xkVk5vZGUpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4uL2ludGVybmFsJykuQ29tcG9uZW50Pn0gY29tbWl0UXVldWUgTGlzdCBvZiBjb21wb25lbnRzXG4gKiB3aGljaCBoYXZlIGNhbGxiYWNrcyB0byBpbnZva2UgaW4gY29tbWl0Um9vdFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IHJvb3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbW1pdFJvb3QoY29tbWl0UXVldWUsIHJvb3QpIHtcblx0aWYgKG9wdGlvbnMuX2NvbW1pdCkgb3B0aW9ucy5fY29tbWl0KHJvb3QsIGNvbW1pdFF1ZXVlKTtcblxuXHRjb21taXRRdWV1ZS5zb21lKGMgPT4ge1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBAdHMtaWdub3JlIFJldXNlIHRoZSBjb21taXRRdWV1ZSB2YXJpYWJsZSBoZXJlIHNvIHRoZSB0eXBlIGNoYW5nZXNcblx0XHRcdGNvbW1pdFF1ZXVlID0gYy5fcmVuZGVyQ2FsbGJhY2tzO1xuXHRcdFx0Yy5fcmVuZGVyQ2FsbGJhY2tzID0gW107XG5cdFx0XHRjb21taXRRdWV1ZS5zb21lKGNiID0+IHtcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZSBTZWUgYWJvdmUgdHMtaWdub3JlIG9uIGNvbW1pdFF1ZXVlXG5cdFx0XHRcdGNiLmNhbGwoYyk7XG5cdFx0XHR9KTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRvcHRpb25zLl9jYXRjaEVycm9yKGUsIGMuX3Zub2RlKTtcblx0XHR9XG5cdH0pO1xufVxuXG4vKipcbiAqIERpZmYgdHdvIHZpcnR1YWwgbm9kZXMgcmVwcmVzZW50aW5nIERPTSBlbGVtZW50XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBkb20gVGhlIERPTSBlbGVtZW50IHJlcHJlc2VudGluZ1xuICogdGhlIHZpcnR1YWwgbm9kZXMgYmVpbmcgZGlmZmVkXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gbmV3Vk5vZGUgVGhlIG5ldyB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBvbGRWTm9kZSBUaGUgb2xkIHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IGdsb2JhbENvbnRleHQgVGhlIGN1cnJlbnQgY29udGV4dCBvYmplY3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdmcgV2hldGhlciBvciBub3QgdGhpcyBET00gbm9kZSBpcyBhbiBTVkcgbm9kZVxuICogQHBhcmFtIHsqfSBleGNlc3NEb21DaGlsZHJlblxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4uL2ludGVybmFsJykuQ29tcG9uZW50Pn0gY29tbWl0UXVldWUgTGlzdCBvZiBjb21wb25lbnRzXG4gKiB3aGljaCBoYXZlIGNhbGxiYWNrcyB0byBpbnZva2UgaW4gY29tbWl0Um9vdFxuICogQHBhcmFtIHtib29sZWFufSBpc0h5ZHJhdGluZyBXaGV0aGVyIG9yIG5vdCB3ZSBhcmUgaW4gaHlkcmF0aW9uXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9XG4gKi9cbmZ1bmN0aW9uIGRpZmZFbGVtZW50Tm9kZXMoXG5cdGRvbSxcblx0bmV3Vk5vZGUsXG5cdG9sZFZOb2RlLFxuXHRnbG9iYWxDb250ZXh0LFxuXHRpc1N2Zyxcblx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdGNvbW1pdFF1ZXVlLFxuXHRpc0h5ZHJhdGluZ1xuKSB7XG5cdGxldCBvbGRQcm9wcyA9IG9sZFZOb2RlLnByb3BzO1xuXHRsZXQgbmV3UHJvcHMgPSBuZXdWTm9kZS5wcm9wcztcblx0bGV0IG5vZGVUeXBlID0gbmV3Vk5vZGUudHlwZTtcblx0bGV0IGkgPSAwO1xuXG5cdC8vIFRyYWNrcyBlbnRlcmluZyBhbmQgZXhpdGluZyBTVkcgbmFtZXNwYWNlIHdoZW4gZGVzY2VuZGluZyB0aHJvdWdoIHRoZSB0cmVlLlxuXHRpZiAobm9kZVR5cGUgPT09ICdzdmcnKSBpc1N2ZyA9IHRydWU7XG5cblx0aWYgKGV4Y2Vzc0RvbUNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRmb3IgKDsgaSA8IGV4Y2Vzc0RvbUNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBjaGlsZCA9IGV4Y2Vzc0RvbUNoaWxkcmVuW2ldO1xuXG5cdFx0XHQvLyBpZiBuZXdWTm9kZSBtYXRjaGVzIGFuIGVsZW1lbnQgaW4gZXhjZXNzRG9tQ2hpbGRyZW4gb3IgdGhlIGBkb21gXG5cdFx0XHQvLyBhcmd1bWVudCBtYXRjaGVzIGFuIGVsZW1lbnQgaW4gZXhjZXNzRG9tQ2hpbGRyZW4sIHJlbW92ZSBpdCBmcm9tXG5cdFx0XHQvLyBleGNlc3NEb21DaGlsZHJlbiBzbyBpdCBpc24ndCBsYXRlciByZW1vdmVkIGluIGRpZmZDaGlsZHJlblxuXHRcdFx0aWYgKFxuXHRcdFx0XHRjaGlsZCAmJlxuXHRcdFx0XHQnc2V0QXR0cmlidXRlJyBpbiBjaGlsZCA9PT0gISFub2RlVHlwZSAmJlxuXHRcdFx0XHQobm9kZVR5cGUgPyBjaGlsZC5sb2NhbE5hbWUgPT09IG5vZGVUeXBlIDogY2hpbGQubm9kZVR5cGUgPT09IDMpXG5cdFx0XHQpIHtcblx0XHRcdFx0ZG9tID0gY2hpbGQ7XG5cdFx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuW2ldID0gbnVsbDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKGRvbSA9PSBudWxsKSB7XG5cdFx0aWYgKG5vZGVUeXBlID09PSBudWxsKSB7XG5cdFx0XHQvLyBAdHMtaWdub3JlIGNyZWF0ZVRleHROb2RlIHJldHVybnMgVGV4dCwgd2UgZXhwZWN0IFByZWFjdEVsZW1lbnRcblx0XHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShuZXdQcm9wcyk7XG5cdFx0fVxuXG5cdFx0aWYgKGlzU3ZnKSB7XG5cdFx0XHRkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXG5cdFx0XHRcdCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG5cdFx0XHRcdC8vIEB0cy1pZ25vcmUgV2Uga25vdyBgbmV3Vk5vZGUudHlwZWAgaXMgYSBzdHJpbmdcblx0XHRcdFx0bm9kZVR5cGVcblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXG5cdFx0XHRcdC8vIEB0cy1pZ25vcmUgV2Uga25vdyBgbmV3Vk5vZGUudHlwZWAgaXMgYSBzdHJpbmdcblx0XHRcdFx0bm9kZVR5cGUsXG5cdFx0XHRcdG5ld1Byb3BzLmlzICYmIG5ld1Byb3BzXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdC8vIHdlIGNyZWF0ZWQgYSBuZXcgcGFyZW50LCBzbyBub25lIG9mIHRoZSBwcmV2aW91c2x5IGF0dGFjaGVkIGNoaWxkcmVuIGNhbiBiZSByZXVzZWQ6XG5cdFx0ZXhjZXNzRG9tQ2hpbGRyZW4gPSBudWxsO1xuXHRcdC8vIHdlIGFyZSBjcmVhdGluZyBhIG5ldyBub2RlLCBzbyB3ZSBjYW4gYXNzdW1lIHRoaXMgaXMgYSBuZXcgc3VidHJlZSAoaW4gY2FzZSB3ZSBhcmUgaHlkcmF0aW5nKSwgdGhpcyBkZW9wdHMgdGhlIGh5ZHJhdGVcblx0XHRpc0h5ZHJhdGluZyA9IGZhbHNlO1xuXHR9XG5cblx0aWYgKG5vZGVUeXBlID09PSBudWxsKSB7XG5cdFx0Ly8gRHVyaW5nIGh5ZHJhdGlvbiwgd2Ugc3RpbGwgaGF2ZSB0byBzcGxpdCBtZXJnZWQgdGV4dCBmcm9tIFNTUidkIEhUTUwuXG5cdFx0aWYgKG9sZFByb3BzICE9PSBuZXdQcm9wcyAmJiAoIWlzSHlkcmF0aW5nIHx8IGRvbS5kYXRhICE9PSBuZXdQcm9wcykpIHtcblx0XHRcdGRvbS5kYXRhID0gbmV3UHJvcHM7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdC8vIElmIGV4Y2Vzc0RvbUNoaWxkcmVuIHdhcyBub3QgbnVsbCwgcmVwb3B1bGF0ZSBpdCB3aXRoIHRoZSBjdXJyZW50IGVsZW1lbnQncyBjaGlsZHJlbjpcblx0XHRleGNlc3NEb21DaGlsZHJlbiA9IGV4Y2Vzc0RvbUNoaWxkcmVuICYmIHNsaWNlLmNhbGwoZG9tLmNoaWxkTm9kZXMpO1xuXG5cdFx0b2xkUHJvcHMgPSBvbGRWTm9kZS5wcm9wcyB8fCBFTVBUWV9PQko7XG5cblx0XHRsZXQgb2xkSHRtbCA9IG9sZFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MO1xuXHRcdGxldCBuZXdIdG1sID0gbmV3UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw7XG5cblx0XHQvLyBEdXJpbmcgaHlkcmF0aW9uLCBwcm9wcyBhcmUgbm90IGRpZmZlZCBhdCBhbGwgKGluY2x1ZGluZyBkYW5nZXJvdXNseVNldElubmVySFRNTClcblx0XHQvLyBAVE9ETyB3ZSBzaG91bGQgd2FybiBpbiBkZWJ1ZyBtb2RlIHdoZW4gcHJvcHMgZG9uJ3QgbWF0Y2ggaGVyZS5cblx0XHRpZiAoIWlzSHlkcmF0aW5nKSB7XG5cdFx0XHQvLyBCdXQsIGlmIHdlIGFyZSBpbiBhIHNpdHVhdGlvbiB3aGVyZSB3ZSBhcmUgdXNpbmcgZXhpc3RpbmcgRE9NIChlLmcuIHJlcGxhY2VOb2RlKVxuXHRcdFx0Ly8gd2Ugc2hvdWxkIHJlYWQgdGhlIGV4aXN0aW5nIERPTSBhdHRyaWJ1dGVzIHRvIGRpZmYgdGhlbVxuXHRcdFx0aWYgKGV4Y2Vzc0RvbUNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRcdFx0b2xkUHJvcHMgPSB7fTtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGRvbS5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0b2xkUHJvcHNbZG9tLmF0dHJpYnV0ZXNbaV0ubmFtZV0gPSBkb20uYXR0cmlidXRlc1tpXS52YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAobmV3SHRtbCB8fCBvbGRIdG1sKSB7XG5cdFx0XHRcdC8vIEF2b2lkIHJlLWFwcGx5aW5nIHRoZSBzYW1lICdfX2h0bWwnIGlmIGl0IGRpZCBub3QgY2hhbmdlZCBiZXR3ZWVuIHJlLXJlbmRlclxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0IW5ld0h0bWwgfHxcblx0XHRcdFx0XHQoKCFvbGRIdG1sIHx8IG5ld0h0bWwuX19odG1sICE9IG9sZEh0bWwuX19odG1sKSAmJlxuXHRcdFx0XHRcdFx0bmV3SHRtbC5fX2h0bWwgIT09IGRvbS5pbm5lckhUTUwpXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGRvbS5pbm5lckhUTUwgPSAobmV3SHRtbCAmJiBuZXdIdG1sLl9faHRtbCkgfHwgJyc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRkaWZmUHJvcHMoZG9tLCBuZXdQcm9wcywgb2xkUHJvcHMsIGlzU3ZnLCBpc0h5ZHJhdGluZyk7XG5cblx0XHQvLyBJZiB0aGUgbmV3IHZub2RlIGRpZG4ndCBoYXZlIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLCBkaWZmIGl0cyBjaGlsZHJlblxuXHRcdGlmIChuZXdIdG1sKSB7XG5cdFx0XHRuZXdWTm9kZS5fY2hpbGRyZW4gPSBbXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aSA9IG5ld1ZOb2RlLnByb3BzLmNoaWxkcmVuO1xuXHRcdFx0ZGlmZkNoaWxkcmVuKFxuXHRcdFx0XHRkb20sXG5cdFx0XHRcdEFycmF5LmlzQXJyYXkoaSkgPyBpIDogW2ldLFxuXHRcdFx0XHRuZXdWTm9kZSxcblx0XHRcdFx0b2xkVk5vZGUsXG5cdFx0XHRcdGdsb2JhbENvbnRleHQsXG5cdFx0XHRcdGlzU3ZnICYmIG5vZGVUeXBlICE9PSAnZm9yZWlnbk9iamVjdCcsXG5cdFx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuLFxuXHRcdFx0XHRjb21taXRRdWV1ZSxcblx0XHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW5cblx0XHRcdFx0XHQ/IGV4Y2Vzc0RvbUNoaWxkcmVuWzBdXG5cdFx0XHRcdFx0OiBvbGRWTm9kZS5fY2hpbGRyZW4gJiYgZ2V0RG9tU2libGluZyhvbGRWTm9kZSwgMCksXG5cdFx0XHRcdGlzSHlkcmF0aW5nXG5cdFx0XHQpO1xuXG5cdFx0XHQvLyBSZW1vdmUgY2hpbGRyZW4gdGhhdCBhcmUgbm90IHBhcnQgb2YgYW55IHZub2RlLlxuXHRcdFx0aWYgKGV4Y2Vzc0RvbUNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRcdFx0Zm9yIChpID0gZXhjZXNzRG9tQ2hpbGRyZW4ubGVuZ3RoOyBpLS07ICkge1xuXHRcdFx0XHRcdGlmIChleGNlc3NEb21DaGlsZHJlbltpXSAhPSBudWxsKSByZW1vdmVOb2RlKGV4Y2Vzc0RvbUNoaWxkcmVuW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIChhcyBhYm92ZSwgZG9uJ3QgZGlmZiBwcm9wcyBkdXJpbmcgaHlkcmF0aW9uKVxuXHRcdGlmICghaXNIeWRyYXRpbmcpIHtcblx0XHRcdGlmIChcblx0XHRcdFx0J3ZhbHVlJyBpbiBuZXdQcm9wcyAmJlxuXHRcdFx0XHQoaSA9IG5ld1Byb3BzLnZhbHVlKSAhPT0gdW5kZWZpbmVkICYmXG5cdFx0XHRcdC8vICMyNzU2IEZvciB0aGUgPHByb2dyZXNzPi1lbGVtZW50IHRoZSBpbml0aWFsIHZhbHVlIGlzIDAsXG5cdFx0XHRcdC8vIGRlc3BpdGUgdGhlIGF0dHJpYnV0ZSBub3QgYmVpbmcgcHJlc2VudC4gV2hlbiB0aGUgYXR0cmlidXRlXG5cdFx0XHRcdC8vIGlzIG1pc3NpbmcgdGhlIHByb2dyZXNzIGJhciBpcyB0cmVhdGVkIGFzIGluZGV0ZXJtaW5hdGUuXG5cdFx0XHRcdC8vIFRvIGZpeCB0aGF0IHdlJ2xsIGFsd2F5cyB1cGRhdGUgaXQgd2hlbiBpdCBpcyAwIGZvciBwcm9ncmVzcyBlbGVtZW50c1xuXHRcdFx0XHQoaSAhPT0gZG9tLnZhbHVlIHx8XG5cdFx0XHRcdFx0KG5vZGVUeXBlID09PSAncHJvZ3Jlc3MnICYmICFpKSB8fFxuXHRcdFx0XHRcdC8vIFRoaXMgaXMgb25seSBmb3IgSUUgMTEgdG8gZml4IDxzZWxlY3Q+IHZhbHVlIG5vdCBiZWluZyB1cGRhdGVkLlxuXHRcdFx0XHRcdC8vIFRvIGF2b2lkIGEgc3RhbGUgc2VsZWN0IHZhbHVlIHdlIG5lZWQgdG8gc2V0IHRoZSBvcHRpb24udmFsdWVcblx0XHRcdFx0XHQvLyBhZ2Fpbiwgd2hpY2ggdHJpZ2dlcnMgSUUxMSB0byByZS1ldmFsdWF0ZSB0aGUgc2VsZWN0IHZhbHVlXG5cdFx0XHRcdFx0KG5vZGVUeXBlID09PSAnb3B0aW9uJyAmJiBpICE9PSBvbGRQcm9wcy52YWx1ZSkpXG5cdFx0XHQpIHtcblx0XHRcdFx0c2V0UHJvcGVydHkoZG9tLCAndmFsdWUnLCBpLCBvbGRQcm9wcy52YWx1ZSwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKFxuXHRcdFx0XHQnY2hlY2tlZCcgaW4gbmV3UHJvcHMgJiZcblx0XHRcdFx0KGkgPSBuZXdQcm9wcy5jaGVja2VkKSAhPT0gdW5kZWZpbmVkICYmXG5cdFx0XHRcdGkgIT09IGRvbS5jaGVja2VkXG5cdFx0XHQpIHtcblx0XHRcdFx0c2V0UHJvcGVydHkoZG9tLCAnY2hlY2tlZCcsIGksIG9sZFByb3BzLmNoZWNrZWQsIGZhbHNlKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZG9tO1xufVxuXG4vKipcbiAqIEludm9rZSBvciB1cGRhdGUgYSByZWYsIGRlcGVuZGluZyBvbiB3aGV0aGVyIGl0IGlzIGEgZnVuY3Rpb24gb3Igb2JqZWN0IHJlZi5cbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSByZWZcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IHZub2RlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVJlZihyZWYsIHZhbHVlLCB2bm9kZSkge1xuXHR0cnkge1xuXHRcdGlmICh0eXBlb2YgcmVmID09ICdmdW5jdGlvbicpIHJlZih2YWx1ZSk7XG5cdFx0ZWxzZSByZWYuY3VycmVudCA9IHZhbHVlO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0b3B0aW9ucy5fY2F0Y2hFcnJvcihlLCB2bm9kZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBVbm1vdW50IGEgdmlydHVhbCBub2RlIGZyb20gdGhlIHRyZWUgYW5kIGFwcGx5IERPTSBjaGFuZ2VzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGUgVGhlIHZpcnR1YWwgbm9kZSB0byB1bm1vdW50XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gcGFyZW50Vk5vZGUgVGhlIHBhcmVudCBvZiB0aGUgVk5vZGUgdGhhdFxuICogaW5pdGlhdGVkIHRoZSB1bm1vdW50XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtza2lwUmVtb3ZlXSBGbGFnIHRoYXQgaW5kaWNhdGVzIHRoYXQgYSBwYXJlbnQgbm9kZSBvZiB0aGVcbiAqIGN1cnJlbnQgZWxlbWVudCBpcyBhbHJlYWR5IGRldGFjaGVkIGZyb20gdGhlIERPTS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVubW91bnQodm5vZGUsIHBhcmVudFZOb2RlLCBza2lwUmVtb3ZlKSB7XG5cdGxldCByO1xuXHRpZiAob3B0aW9ucy51bm1vdW50KSBvcHRpb25zLnVubW91bnQodm5vZGUpO1xuXG5cdGlmICgociA9IHZub2RlLnJlZikpIHtcblx0XHRpZiAoIXIuY3VycmVudCB8fCByLmN1cnJlbnQgPT09IHZub2RlLl9kb20pIHtcblx0XHRcdGFwcGx5UmVmKHIsIG51bGwsIHBhcmVudFZOb2RlKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoKHIgPSB2bm9kZS5fY29tcG9uZW50KSAhPSBudWxsKSB7XG5cdFx0aWYgKHIuY29tcG9uZW50V2lsbFVubW91bnQpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHIuY29tcG9uZW50V2lsbFVubW91bnQoKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0b3B0aW9ucy5fY2F0Y2hFcnJvcihlLCBwYXJlbnRWTm9kZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ci5iYXNlID0gci5fcGFyZW50RG9tID0gbnVsbDtcblx0XHR2bm9kZS5fY29tcG9uZW50ID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0aWYgKChyID0gdm5vZGUuX2NoaWxkcmVuKSkge1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgci5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHJbaV0pIHtcblx0XHRcdFx0dW5tb3VudChcblx0XHRcdFx0XHRyW2ldLFxuXHRcdFx0XHRcdHBhcmVudFZOb2RlLFxuXHRcdFx0XHRcdHNraXBSZW1vdmUgfHwgdHlwZW9mIHZub2RlLnR5cGUgIT09ICdmdW5jdGlvbidcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoIXNraXBSZW1vdmUgJiYgdm5vZGUuX2RvbSAhPSBudWxsKSB7XG5cdFx0cmVtb3ZlTm9kZSh2bm9kZS5fZG9tKTtcblx0fVxuXG5cdC8vIE11c3QgYmUgc2V0IHRvIGB1bmRlZmluZWRgIHRvIHByb3Blcmx5IGNsZWFuIHVwIGBfbmV4dERvbWBcblx0Ly8gZm9yIHdoaWNoIGBudWxsYCBpcyBhIHZhbGlkIHZhbHVlLiBTZWUgY29tbWVudCBpbiBgY3JlYXRlLWVsZW1lbnQuanNgXG5cdHZub2RlLl9wYXJlbnQgPSB2bm9kZS5fZG9tID0gdm5vZGUuX25leHREb20gPSB1bmRlZmluZWQ7XG59XG5cbi8qKiBUaGUgYC5yZW5kZXIoKWAgbWV0aG9kIGZvciBhIFBGQyBiYWNraW5nIGluc3RhbmNlLiAqL1xuZnVuY3Rpb24gZG9SZW5kZXIocHJvcHMsIHN0YXRlLCBjb250ZXh0KSB7XG5cdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKHByb3BzLCBjb250ZXh0KTtcbn1cbiIsICJpbXBvcnQgeyBFTVBUWV9PQkogfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBjb21taXRSb290LCBkaWZmIH0gZnJvbSAnLi9kaWZmL2luZGV4JztcbmltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIEZyYWdtZW50IH0gZnJvbSAnLi9jcmVhdGUtZWxlbWVudCc7XG5pbXBvcnQgb3B0aW9ucyBmcm9tICcuL29wdGlvbnMnO1xuaW1wb3J0IHsgc2xpY2UgfSBmcm9tICcuL3V0aWwnO1xuXG4vKipcbiAqIFJlbmRlciBhIFByZWFjdCB2aXJ0dWFsIG5vZGUgaW50byBhIERPTSBlbGVtZW50XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudENoaWxkfSB2bm9kZSBUaGUgdmlydHVhbCBub2RlIHRvIHJlbmRlclxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBwYXJlbnREb20gVGhlIERPTSBlbGVtZW50IHRvXG4gKiByZW5kZXIgaW50b1xuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50IHwgb2JqZWN0fSBbcmVwbGFjZU5vZGVdIE9wdGlvbmFsOiBBdHRlbXB0IHRvIHJlLXVzZSBhblxuICogZXhpc3RpbmcgRE9NIHRyZWUgcm9vdGVkIGF0IGByZXBsYWNlTm9kZWBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcih2bm9kZSwgcGFyZW50RG9tLCByZXBsYWNlTm9kZSkge1xuXHRpZiAob3B0aW9ucy5fcm9vdCkgb3B0aW9ucy5fcm9vdCh2bm9kZSwgcGFyZW50RG9tKTtcblxuXHQvLyBXZSBhYnVzZSB0aGUgYHJlcGxhY2VOb2RlYCBwYXJhbWV0ZXIgaW4gYGh5ZHJhdGUoKWAgdG8gc2lnbmFsIGlmIHdlIGFyZSBpblxuXHQvLyBoeWRyYXRpb24gbW9kZSBvciBub3QgYnkgcGFzc2luZyB0aGUgYGh5ZHJhdGVgIGZ1bmN0aW9uIGluc3RlYWQgb2YgYSBET01cblx0Ly8gZWxlbWVudC4uXG5cdGxldCBpc0h5ZHJhdGluZyA9IHR5cGVvZiByZXBsYWNlTm9kZSA9PT0gJ2Z1bmN0aW9uJztcblxuXHQvLyBUbyBiZSBhYmxlIHRvIHN1cHBvcnQgY2FsbGluZyBgcmVuZGVyKClgIG11bHRpcGxlIHRpbWVzIG9uIHRoZSBzYW1lXG5cdC8vIERPTSBub2RlLCB3ZSBuZWVkIHRvIG9idGFpbiBhIHJlZmVyZW5jZSB0byB0aGUgcHJldmlvdXMgdHJlZS4gV2UgZG9cblx0Ly8gdGhpcyBieSBhc3NpZ25pbmcgYSBuZXcgYF9jaGlsZHJlbmAgcHJvcGVydHkgdG8gRE9NIG5vZGVzIHdoaWNoIHBvaW50c1xuXHQvLyB0byB0aGUgbGFzdCByZW5kZXJlZCB0cmVlLiBCeSBkZWZhdWx0IHRoaXMgcHJvcGVydHkgaXMgbm90IHByZXNlbnQsIHdoaWNoXG5cdC8vIG1lYW5zIHRoYXQgd2UgYXJlIG1vdW50aW5nIGEgbmV3IHRyZWUgZm9yIHRoZSBmaXJzdCB0aW1lLlxuXHRsZXQgb2xkVk5vZGUgPSBpc0h5ZHJhdGluZ1xuXHRcdD8gbnVsbFxuXHRcdDogKHJlcGxhY2VOb2RlICYmIHJlcGxhY2VOb2RlLl9jaGlsZHJlbikgfHwgcGFyZW50RG9tLl9jaGlsZHJlbjtcblxuXHR2bm9kZSA9IChcblx0XHQoIWlzSHlkcmF0aW5nICYmIHJlcGxhY2VOb2RlKSB8fFxuXHRcdHBhcmVudERvbVxuXHQpLl9jaGlsZHJlbiA9IGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIFt2bm9kZV0pO1xuXG5cdC8vIExpc3Qgb2YgZWZmZWN0cyB0aGF0IG5lZWQgdG8gYmUgY2FsbGVkIGFmdGVyIGRpZmZpbmcuXG5cdGxldCBjb21taXRRdWV1ZSA9IFtdO1xuXHRkaWZmKFxuXHRcdHBhcmVudERvbSxcblx0XHQvLyBEZXRlcm1pbmUgdGhlIG5ldyB2bm9kZSB0cmVlIGFuZCBzdG9yZSBpdCBvbiB0aGUgRE9NIGVsZW1lbnQgb25cblx0XHQvLyBvdXIgY3VzdG9tIGBfY2hpbGRyZW5gIHByb3BlcnR5LlxuXHRcdHZub2RlLFxuXHRcdG9sZFZOb2RlIHx8IEVNUFRZX09CSixcblx0XHRFTVBUWV9PQkosXG5cdFx0cGFyZW50RG9tLm93bmVyU1ZHRWxlbWVudCAhPT0gdW5kZWZpbmVkLFxuXHRcdCFpc0h5ZHJhdGluZyAmJiByZXBsYWNlTm9kZVxuXHRcdFx0PyBbcmVwbGFjZU5vZGVdXG5cdFx0XHQ6IG9sZFZOb2RlXG5cdFx0XHQ/IG51bGxcblx0XHRcdDogcGFyZW50RG9tLmZpcnN0Q2hpbGRcblx0XHRcdD8gc2xpY2UuY2FsbChwYXJlbnREb20uY2hpbGROb2Rlcylcblx0XHRcdDogbnVsbCxcblx0XHRjb21taXRRdWV1ZSxcblx0XHQhaXNIeWRyYXRpbmcgJiYgcmVwbGFjZU5vZGVcblx0XHRcdD8gcmVwbGFjZU5vZGVcblx0XHRcdDogb2xkVk5vZGVcblx0XHRcdD8gb2xkVk5vZGUuX2RvbVxuXHRcdFx0OiBwYXJlbnREb20uZmlyc3RDaGlsZCxcblx0XHRpc0h5ZHJhdGluZ1xuXHQpO1xuXG5cdC8vIEZsdXNoIGFsbCBxdWV1ZWQgZWZmZWN0c1xuXHRjb21taXRSb290KGNvbW1pdFF1ZXVlLCB2bm9kZSk7XG59XG5cbi8qKlxuICogVXBkYXRlIGFuIGV4aXN0aW5nIERPTSBlbGVtZW50IHdpdGggZGF0YSBmcm9tIGEgUHJlYWN0IHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnRDaGlsZH0gdm5vZGUgVGhlIHZpcnR1YWwgbm9kZSB0byByZW5kZXJcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gcGFyZW50RG9tIFRoZSBET00gZWxlbWVudCB0b1xuICogdXBkYXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoeWRyYXRlKHZub2RlLCBwYXJlbnREb20pIHtcblx0cmVuZGVyKHZub2RlLCBwYXJlbnREb20sIGh5ZHJhdGUpO1xufVxuIiwgImltcG9ydCB7IGFzc2lnbiwgc2xpY2UgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsgY3JlYXRlVk5vZGUgfSBmcm9tICcuL2NyZWF0ZS1lbGVtZW50JztcblxuLyoqXG4gKiBDbG9uZXMgdGhlIGdpdmVuIFZOb2RlLCBvcHRpb25hbGx5IGFkZGluZyBhdHRyaWJ1dGVzL3Byb3BzIGFuZCByZXBsYWNpbmcgaXRzIGNoaWxkcmVuLlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGUgVGhlIHZpcnR1YWwgRE9NIGVsZW1lbnQgdG8gY2xvbmVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcyBBdHRyaWJ1dGVzL3Byb3BzIHRvIGFkZCB3aGVuIGNsb25pbmdcbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50Q2hpbGRyZW4+fSByZXN0IEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyB3aWxsIGJlIHVzZWQgYXMgcmVwbGFjZW1lbnQgY2hpbGRyZW4uXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZUVsZW1lbnQodm5vZGUsIHByb3BzLCBjaGlsZHJlbikge1xuXHRsZXQgbm9ybWFsaXplZFByb3BzID0gYXNzaWduKHt9LCB2bm9kZS5wcm9wcyksXG5cdFx0a2V5LFxuXHRcdHJlZixcblx0XHRpO1xuXHRmb3IgKGkgaW4gcHJvcHMpIHtcblx0XHRpZiAoaSA9PSAna2V5Jykga2V5ID0gcHJvcHNbaV07XG5cdFx0ZWxzZSBpZiAoaSA9PSAncmVmJykgcmVmID0gcHJvcHNbaV07XG5cdFx0ZWxzZSBub3JtYWxpemVkUHJvcHNbaV0gPSBwcm9wc1tpXTtcblx0fVxuXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuXHRcdG5vcm1hbGl6ZWRQcm9wcy5jaGlsZHJlbiA9XG5cdFx0XHRhcmd1bWVudHMubGVuZ3RoID4gMyA/IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSA6IGNoaWxkcmVuO1xuXHR9XG5cblx0cmV0dXJuIGNyZWF0ZVZOb2RlKFxuXHRcdHZub2RlLnR5cGUsXG5cdFx0bm9ybWFsaXplZFByb3BzLFxuXHRcdGtleSB8fCB2bm9kZS5rZXksXG5cdFx0cmVmIHx8IHZub2RlLnJlZixcblx0XHRudWxsXG5cdCk7XG59XG4iLCAiLyoqXG4gKiBGaW5kIHRoZSBjbG9zZXN0IGVycm9yIGJvdW5kYXJ5IHRvIGEgdGhyb3duIGVycm9yIGFuZCBjYWxsIGl0XG4gKiBAcGFyYW0ge29iamVjdH0gZXJyb3IgVGhlIHRocm93biB2YWx1ZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IHZub2RlIFRoZSB2bm9kZSB0aGF0IHRocmV3XG4gKiB0aGUgZXJyb3IgdGhhdCB3YXMgY2F1Z2h0IChleGNlcHQgZm9yIHVubW91bnRpbmcgd2hlbiB0aGlzIHBhcmFtZXRlclxuICogaXMgdGhlIGhpZ2hlc3QgcGFyZW50IHRoYXQgd2FzIGJlaW5nIHVubW91bnRlZClcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBbb2xkVk5vZGVdXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5FcnJvckluZm99IFtlcnJvckluZm9dXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfY2F0Y2hFcnJvcihlcnJvciwgdm5vZGUsIG9sZFZOb2RlLCBlcnJvckluZm8pIHtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4uL2ludGVybmFsJykuQ29tcG9uZW50fSAqL1xuXHRsZXQgY29tcG9uZW50LCBjdG9yLCBoYW5kbGVkO1xuXG5cdGZvciAoOyAodm5vZGUgPSB2bm9kZS5fcGFyZW50KTsgKSB7XG5cdFx0aWYgKChjb21wb25lbnQgPSB2bm9kZS5fY29tcG9uZW50KSAmJiAhY29tcG9uZW50Ll9wcm9jZXNzaW5nRXhjZXB0aW9uKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjdG9yID0gY29tcG9uZW50LmNvbnN0cnVjdG9yO1xuXG5cdFx0XHRcdGlmIChjdG9yICYmIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yICE9IG51bGwpIHtcblx0XHRcdFx0XHRjb21wb25lbnQuc2V0U3RhdGUoY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3IpKTtcblx0XHRcdFx0XHRoYW5kbGVkID0gY29tcG9uZW50Ll9kaXJ0eTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjb21wb25lbnQuY29tcG9uZW50RGlkQ2F0Y2ggIT0gbnVsbCkge1xuXHRcdFx0XHRcdGNvbXBvbmVudC5jb21wb25lbnREaWRDYXRjaChlcnJvciwgZXJyb3JJbmZvIHx8IHt9KTtcblx0XHRcdFx0XHRoYW5kbGVkID0gY29tcG9uZW50Ll9kaXJ0eTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRoaXMgaXMgYW4gZXJyb3IgYm91bmRhcnkuIE1hcmsgaXQgYXMgaGF2aW5nIGJhaWxlZCBvdXQsIGFuZCB3aGV0aGVyIGl0IHdhcyBtaWQtaHlkcmF0aW9uLlxuXHRcdFx0XHRpZiAoaGFuZGxlZCkge1xuXHRcdFx0XHRcdHJldHVybiAoY29tcG9uZW50Ll9wZW5kaW5nRXJyb3IgPSBjb21wb25lbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdGVycm9yID0gZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHR0aHJvdyBlcnJvcjtcbn1cbiIsICJpbXBvcnQgeyBvcHRpb25zIH0gZnJvbSAncHJlYWN0JztcblxuLyoqIEB0eXBlIHtudW1iZXJ9ICovXG5sZXQgY3VycmVudEluZGV4O1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gKi9cbmxldCBjdXJyZW50Q29tcG9uZW50O1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gKi9cbmxldCBwcmV2aW91c0NvbXBvbmVudDtcblxuLyoqIEB0eXBlIHtudW1iZXJ9ICovXG5sZXQgY3VycmVudEhvb2sgPSAwO1xuXG4vKiogQHR5cGUge0FycmF5PGltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59ICovXG5sZXQgYWZ0ZXJQYWludEVmZmVjdHMgPSBbXTtcblxubGV0IEVNUFRZID0gW107XG5cbmxldCBvbGRCZWZvcmVEaWZmID0gb3B0aW9ucy5fZGlmZjtcbmxldCBvbGRCZWZvcmVSZW5kZXIgPSBvcHRpb25zLl9yZW5kZXI7XG5sZXQgb2xkQWZ0ZXJEaWZmID0gb3B0aW9ucy5kaWZmZWQ7XG5sZXQgb2xkQ29tbWl0ID0gb3B0aW9ucy5fY29tbWl0O1xubGV0IG9sZEJlZm9yZVVubW91bnQgPSBvcHRpb25zLnVubW91bnQ7XG5cbmNvbnN0IFJBRl9USU1FT1VUID0gMTAwO1xubGV0IHByZXZSYWY7XG5cbm9wdGlvbnMuX2RpZmYgPSB2bm9kZSA9PiB7XG5cdGN1cnJlbnRDb21wb25lbnQgPSBudWxsO1xuXHRpZiAob2xkQmVmb3JlRGlmZikgb2xkQmVmb3JlRGlmZih2bm9kZSk7XG59O1xuXG5vcHRpb25zLl9yZW5kZXIgPSB2bm9kZSA9PiB7XG5cdGlmIChvbGRCZWZvcmVSZW5kZXIpIG9sZEJlZm9yZVJlbmRlcih2bm9kZSk7XG5cblx0Y3VycmVudENvbXBvbmVudCA9IHZub2RlLl9jb21wb25lbnQ7XG5cdGN1cnJlbnRJbmRleCA9IDA7XG5cblx0Y29uc3QgaG9va3MgPSBjdXJyZW50Q29tcG9uZW50Ll9faG9va3M7XG5cdGlmIChob29rcykge1xuXHRcdGlmIChwcmV2aW91c0NvbXBvbmVudCA9PT0gY3VycmVudENvbXBvbmVudCkge1xuXHRcdFx0aG9va3MuX3BlbmRpbmdFZmZlY3RzID0gW107XG5cdFx0XHRjdXJyZW50Q29tcG9uZW50Ll9yZW5kZXJDYWxsYmFja3MgPSBbXTtcblx0XHRcdGhvb2tzLl9saXN0LmZvckVhY2goaG9va0l0ZW0gPT4ge1xuXHRcdFx0XHRpZiAoaG9va0l0ZW0uX25leHRWYWx1ZSkge1xuXHRcdFx0XHRcdGhvb2tJdGVtLl92YWx1ZSA9IGhvb2tJdGVtLl9uZXh0VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aG9va0l0ZW0uX3BlbmRpbmdWYWx1ZSA9IEVNUFRZO1xuXHRcdFx0XHRob29rSXRlbS5fbmV4dFZhbHVlID0gaG9va0l0ZW0uX3BlbmRpbmdBcmdzID0gdW5kZWZpbmVkO1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGhvb2tzLl9wZW5kaW5nRWZmZWN0cy5mb3JFYWNoKGludm9rZUNsZWFudXApO1xuXHRcdFx0aG9va3MuX3BlbmRpbmdFZmZlY3RzLmZvckVhY2goaW52b2tlRWZmZWN0KTtcblx0XHRcdGhvb2tzLl9wZW5kaW5nRWZmZWN0cyA9IFtdO1xuXHRcdH1cblx0fVxuXHRwcmV2aW91c0NvbXBvbmVudCA9IGN1cnJlbnRDb21wb25lbnQ7XG59O1xuXG5vcHRpb25zLmRpZmZlZCA9IHZub2RlID0+IHtcblx0aWYgKG9sZEFmdGVyRGlmZikgb2xkQWZ0ZXJEaWZmKHZub2RlKTtcblxuXHRjb25zdCBjID0gdm5vZGUuX2NvbXBvbmVudDtcblx0aWYgKGMgJiYgYy5fX2hvb2tzKSB7XG5cdFx0aWYgKGMuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMubGVuZ3RoKSBhZnRlclBhaW50KGFmdGVyUGFpbnRFZmZlY3RzLnB1c2goYykpO1xuXHRcdGMuX19ob29rcy5fbGlzdC5mb3JFYWNoKGhvb2tJdGVtID0+IHtcblx0XHRcdGlmIChob29rSXRlbS5fcGVuZGluZ0FyZ3MpIHtcblx0XHRcdFx0aG9va0l0ZW0uX2FyZ3MgPSBob29rSXRlbS5fcGVuZGluZ0FyZ3M7XG5cdFx0XHR9XG5cdFx0XHRpZiAoaG9va0l0ZW0uX3BlbmRpbmdWYWx1ZSAhPT0gRU1QVFkpIHtcblx0XHRcdFx0aG9va0l0ZW0uX3ZhbHVlID0gaG9va0l0ZW0uX3BlbmRpbmdWYWx1ZTtcblx0XHRcdH1cblx0XHRcdGhvb2tJdGVtLl9wZW5kaW5nQXJncyA9IHVuZGVmaW5lZDtcblx0XHRcdGhvb2tJdGVtLl9wZW5kaW5nVmFsdWUgPSBFTVBUWTtcblx0XHR9KTtcblx0fVxuXHRwcmV2aW91c0NvbXBvbmVudCA9IGN1cnJlbnRDb21wb25lbnQgPSBudWxsO1xufTtcblxub3B0aW9ucy5fY29tbWl0ID0gKHZub2RlLCBjb21taXRRdWV1ZSkgPT4ge1xuXHRjb21taXRRdWV1ZS5zb21lKGNvbXBvbmVudCA9PiB7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbXBvbmVudC5fcmVuZGVyQ2FsbGJhY2tzLmZvckVhY2goaW52b2tlQ2xlYW51cCk7XG5cdFx0XHRjb21wb25lbnQuX3JlbmRlckNhbGxiYWNrcyA9IGNvbXBvbmVudC5fcmVuZGVyQ2FsbGJhY2tzLmZpbHRlcihjYiA9PlxuXHRcdFx0XHRjYi5fdmFsdWUgPyBpbnZva2VFZmZlY3QoY2IpIDogdHJ1ZVxuXHRcdFx0KTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRjb21taXRRdWV1ZS5zb21lKGMgPT4ge1xuXHRcdFx0XHRpZiAoYy5fcmVuZGVyQ2FsbGJhY2tzKSBjLl9yZW5kZXJDYWxsYmFja3MgPSBbXTtcblx0XHRcdH0pO1xuXHRcdFx0Y29tbWl0UXVldWUgPSBbXTtcblx0XHRcdG9wdGlvbnMuX2NhdGNoRXJyb3IoZSwgY29tcG9uZW50Ll92bm9kZSk7XG5cdFx0fVxuXHR9KTtcblxuXHRpZiAob2xkQ29tbWl0KSBvbGRDb21taXQodm5vZGUsIGNvbW1pdFF1ZXVlKTtcbn07XG5cbm9wdGlvbnMudW5tb3VudCA9IHZub2RlID0+IHtcblx0aWYgKG9sZEJlZm9yZVVubW91bnQpIG9sZEJlZm9yZVVubW91bnQodm5vZGUpO1xuXG5cdGNvbnN0IGMgPSB2bm9kZS5fY29tcG9uZW50O1xuXHRpZiAoYyAmJiBjLl9faG9va3MpIHtcblx0XHRsZXQgaGFzRXJyb3JlZDtcblx0XHRjLl9faG9va3MuX2xpc3QuZm9yRWFjaChzID0+IHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGludm9rZUNsZWFudXAocyk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdGhhc0Vycm9yZWQgPSBlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGMuX19ob29rcyA9IHVuZGVmaW5lZDtcblx0XHRpZiAoaGFzRXJyb3JlZCkgb3B0aW9ucy5fY2F0Y2hFcnJvcihoYXNFcnJvcmVkLCBjLl92bm9kZSk7XG5cdH1cbn07XG5cbi8qKlxuICogR2V0IGEgaG9vaydzIHN0YXRlIGZyb20gdGhlIGN1cnJlbnRDb21wb25lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGhvb2sgdG8gZ2V0XG4gKiBAcGFyYW0ge251bWJlcn0gdHlwZSBUaGUgaW5kZXggb2YgdGhlIGhvb2sgdG8gZ2V0XG4gKiBAcmV0dXJucyB7YW55fVxuICovXG5mdW5jdGlvbiBnZXRIb29rU3RhdGUoaW5kZXgsIHR5cGUpIHtcblx0aWYgKG9wdGlvbnMuX2hvb2spIHtcblx0XHRvcHRpb25zLl9ob29rKGN1cnJlbnRDb21wb25lbnQsIGluZGV4LCBjdXJyZW50SG9vayB8fCB0eXBlKTtcblx0fVxuXHRjdXJyZW50SG9vayA9IDA7XG5cblx0Ly8gTGFyZ2VseSBpbnNwaXJlZCBieTpcblx0Ly8gKiBodHRwczovL2dpdGh1Yi5jb20vbWljaGFlbC1rbGVpbi9mdW5jeS5qcy9ibG9iL2Y2YmU3MzQ2OGU2ZWM0NmIwZmY1YWEzY2M0YzliYWY3MmEyOTAyNWEvc3JjL2hvb2tzL2NvcmVfaG9va3MubWpzXG5cdC8vICogaHR0cHM6Ly9naXRodWIuY29tL21pY2hhZWwta2xlaW4vZnVuY3kuanMvYmxvYi82NTBiZWFhNThjNDNjMzNhNzQ4MjBhM2M5OGIzYzcwNzljZjJlMzMzL3NyYy9yZW5kZXJlci5tanNcblx0Ly8gT3RoZXIgaW1wbGVtZW50YXRpb25zIHRvIGxvb2sgYXQ6XG5cdC8vICogaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL21ub3gwNXFwOFxuXHRjb25zdCBob29rcyA9XG5cdFx0Y3VycmVudENvbXBvbmVudC5fX2hvb2tzIHx8XG5cdFx0KGN1cnJlbnRDb21wb25lbnQuX19ob29rcyA9IHtcblx0XHRcdF9saXN0OiBbXSxcblx0XHRcdF9wZW5kaW5nRWZmZWN0czogW11cblx0XHR9KTtcblxuXHRpZiAoaW5kZXggPj0gaG9va3MuX2xpc3QubGVuZ3RoKSB7XG5cdFx0aG9va3MuX2xpc3QucHVzaCh7IF9wZW5kaW5nVmFsdWU6IEVNUFRZIH0pO1xuXHR9XG5cdHJldHVybiBob29rcy5fbGlzdFtpbmRleF07XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW5kZXgnKS5TdGF0ZVVwZGF0ZXI8YW55Pn0gW2luaXRpYWxTdGF0ZV1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YXRlKGluaXRpYWxTdGF0ZSkge1xuXHRjdXJyZW50SG9vayA9IDE7XG5cdHJldHVybiB1c2VSZWR1Y2VyKGludm9rZU9yUmV0dXJuLCBpbml0aWFsU3RhdGUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2luZGV4JykuUmVkdWNlcjxhbnksIGFueT59IHJlZHVjZXJcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2luZGV4JykuU3RhdGVVcGRhdGVyPGFueT59IGluaXRpYWxTdGF0ZVxuICogQHBhcmFtIHsoaW5pdGlhbFN0YXRlOiBhbnkpID0+IHZvaWR9IFtpbml0XVxuICogQHJldHVybnMge1sgYW55LCAoc3RhdGU6IGFueSkgPT4gdm9pZCBdfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsU3RhdGUsIGluaXQpIHtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5SZWR1Y2VySG9va1N0YXRlfSAqL1xuXHRjb25zdCBob29rU3RhdGUgPSBnZXRIb29rU3RhdGUoY3VycmVudEluZGV4KyssIDIpO1xuXHRob29rU3RhdGUuX3JlZHVjZXIgPSByZWR1Y2VyO1xuXHRpZiAoIWhvb2tTdGF0ZS5fY29tcG9uZW50KSB7XG5cdFx0aG9va1N0YXRlLl92YWx1ZSA9IFtcblx0XHRcdCFpbml0ID8gaW52b2tlT3JSZXR1cm4odW5kZWZpbmVkLCBpbml0aWFsU3RhdGUpIDogaW5pdChpbml0aWFsU3RhdGUpLFxuXG5cdFx0XHRhY3Rpb24gPT4ge1xuXHRcdFx0XHRjb25zdCBjdXJyZW50VmFsdWUgPSBob29rU3RhdGUuX25leHRWYWx1ZVxuXHRcdFx0XHRcdD8gaG9va1N0YXRlLl9uZXh0VmFsdWVbMF1cblx0XHRcdFx0XHQ6IGhvb2tTdGF0ZS5fdmFsdWVbMF07XG5cdFx0XHRcdGNvbnN0IG5leHRWYWx1ZSA9IGhvb2tTdGF0ZS5fcmVkdWNlcihjdXJyZW50VmFsdWUsIGFjdGlvbik7XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSAhPT0gbmV4dFZhbHVlKSB7XG5cdFx0XHRcdFx0aG9va1N0YXRlLl9uZXh0VmFsdWUgPSBbbmV4dFZhbHVlLCBob29rU3RhdGUuX3ZhbHVlWzFdXTtcblx0XHRcdFx0XHRob29rU3RhdGUuX2NvbXBvbmVudC5zZXRTdGF0ZSh7fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRdO1xuXG5cdFx0aG9va1N0YXRlLl9jb21wb25lbnQgPSBjdXJyZW50Q29tcG9uZW50O1xuXG5cdFx0aWYgKCFjdXJyZW50Q29tcG9uZW50Ll9oYXNTY3VGcm9tSG9va3MpIHtcblx0XHRcdGN1cnJlbnRDb21wb25lbnQuX2hhc1NjdUZyb21Ib29rcyA9IHRydWU7XG5cdFx0XHRjb25zdCBwcmV2U2N1ID0gY3VycmVudENvbXBvbmVudC5zaG91bGRDb21wb25lbnRVcGRhdGU7XG5cblx0XHRcdC8vIFRoaXMgU0NVIGhhcyB0aGUgcHVycG9zZSBvZiBiYWlsaW5nIG91dCBhZnRlciByZXBlYXRlZCB1cGRhdGVzXG5cdFx0XHQvLyB0byBzdGF0ZWZ1bCBob29rcy5cblx0XHRcdC8vIHdlIHN0b3JlIHRoZSBuZXh0IHZhbHVlIGluIF9uZXh0VmFsdWVbMF0gYW5kIGtlZXAgZG9pbmcgdGhhdCBmb3IgYWxsXG5cdFx0XHQvLyBzdGF0ZSBzZXR0ZXJzLCBpZiB3ZSBoYXZlIG5leHQgc3RhdGVzIGFuZFxuXHRcdFx0Ly8gYWxsIG5leHQgc3RhdGVzIHdpdGhpbiBhIGNvbXBvbmVudCBlbmQgdXAgYmVpbmcgZXF1YWwgdG8gdGhlaXIgb3JpZ2luYWwgc3RhdGVcblx0XHRcdC8vIHdlIGFyZSBzYWZlIHRvIGJhaWwgb3V0IGZvciB0aGlzIHNwZWNpZmljIGNvbXBvbmVudC5cblx0XHRcdGN1cnJlbnRDb21wb25lbnQuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZnVuY3Rpb24ocCwgcywgYykge1xuXHRcdFx0XHRpZiAoIWhvb2tTdGF0ZS5fY29tcG9uZW50Ll9faG9va3MpIHJldHVybiB0cnVlO1xuXG5cdFx0XHRcdGNvbnN0IHN0YXRlSG9va3MgPSBob29rU3RhdGUuX2NvbXBvbmVudC5fX2hvb2tzLl9saXN0LmZpbHRlcihcblx0XHRcdFx0XHR4ID0+IHguX2NvbXBvbmVudFxuXHRcdFx0XHQpO1xuXHRcdFx0XHRjb25zdCBhbGxIb29rc0VtcHR5ID0gc3RhdGVIb29rcy5ldmVyeSh4ID0+ICF4Ll9uZXh0VmFsdWUpO1xuXHRcdFx0XHQvLyBXaGVuIHdlIGhhdmUgbm8gdXBkYXRlZCBob29rcyBpbiB0aGUgY29tcG9uZW50IHdlIGludm9rZSB0aGUgcHJldmlvdXMgU0NVIG9yXG5cdFx0XHRcdC8vIHRyYXZlcnNlIHRoZSBWRE9NIHRyZWUgZnVydGhlci5cblx0XHRcdFx0aWYgKGFsbEhvb2tzRW1wdHkpIHtcblx0XHRcdFx0XHRyZXR1cm4gcHJldlNjdSA/IHByZXZTY3UuY2FsbCh0aGlzLCBwLCBzLCBjKSA6IHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBXZSBjaGVjayB3aGV0aGVyIHdlIGhhdmUgY29tcG9uZW50cyB3aXRoIGEgbmV4dFZhbHVlIHNldCB0aGF0XG5cdFx0XHRcdC8vIGhhdmUgdmFsdWVzIHRoYXQgYXJlbid0IGVxdWFsIHRvIG9uZSBhbm90aGVyIHRoaXMgcHVzaGVzXG5cdFx0XHRcdC8vIHVzIHRvIHVwZGF0ZSBmdXJ0aGVyIGRvd24gdGhlIHRyZWVcblx0XHRcdFx0bGV0IHNob3VsZFVwZGF0ZSA9IGZhbHNlO1xuXHRcdFx0XHRzdGF0ZUhvb2tzLmZvckVhY2goaG9va0l0ZW0gPT4ge1xuXHRcdFx0XHRcdGlmIChob29rSXRlbS5fbmV4dFZhbHVlKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBjdXJyZW50VmFsdWUgPSBob29rSXRlbS5fdmFsdWVbMF07XG5cdFx0XHRcdFx0XHRob29rSXRlbS5fdmFsdWUgPSBob29rSXRlbS5fbmV4dFZhbHVlO1xuXHRcdFx0XHRcdFx0aG9va0l0ZW0uX25leHRWYWx1ZSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgIT09IGhvb2tJdGVtLl92YWx1ZVswXSkgc2hvdWxkVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHJldHVybiBzaG91bGRVcGRhdGUgfHwgaG9va1N0YXRlLl9jb21wb25lbnQucHJvcHMgIT09IHBcblx0XHRcdFx0XHQ/IHByZXZTY3Vcblx0XHRcdFx0XHRcdD8gcHJldlNjdS5jYWxsKHRoaXMsIHAsIHMsIGMpXG5cdFx0XHRcdFx0XHQ6IHRydWVcblx0XHRcdFx0XHQ6IGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gaG9va1N0YXRlLl9uZXh0VmFsdWUgfHwgaG9va1N0YXRlLl92YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdH0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUVmZmVjdChjYWxsYmFjaywgYXJncykge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdEhvb2tTdGF0ZX0gKi9cblx0Y29uc3Qgc3RhdGUgPSBnZXRIb29rU3RhdGUoY3VycmVudEluZGV4KyssIDMpO1xuXHRpZiAoIW9wdGlvbnMuX3NraXBFZmZlY3RzICYmIGFyZ3NDaGFuZ2VkKHN0YXRlLl9hcmdzLCBhcmdzKSkge1xuXHRcdHN0YXRlLl92YWx1ZSA9IGNhbGxiYWNrO1xuXHRcdHN0YXRlLl9wZW5kaW5nQXJncyA9IGFyZ3M7XG5cblx0XHRjdXJyZW50Q29tcG9uZW50Ll9faG9va3MuX3BlbmRpbmdFZmZlY3RzLnB1c2goc3RhdGUpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5FZmZlY3R9IGNhbGxiYWNrXG4gKiBAcGFyYW0ge2FueVtdfSBhcmdzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VMYXlvdXRFZmZlY3QoY2FsbGJhY2ssIGFyZ3MpIHtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5FZmZlY3RIb29rU3RhdGV9ICovXG5cdGNvbnN0IHN0YXRlID0gZ2V0SG9va1N0YXRlKGN1cnJlbnRJbmRleCsrLCA0KTtcblx0aWYgKCFvcHRpb25zLl9za2lwRWZmZWN0cyAmJiBhcmdzQ2hhbmdlZChzdGF0ZS5fYXJncywgYXJncykpIHtcblx0XHRzdGF0ZS5fdmFsdWUgPSBjYWxsYmFjaztcblx0XHRzdGF0ZS5fcGVuZGluZ0FyZ3MgPSBhcmdzO1xuXG5cdFx0Y3VycmVudENvbXBvbmVudC5fcmVuZGVyQ2FsbGJhY2tzLnB1c2goc3RhdGUpO1xuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VSZWYoaW5pdGlhbFZhbHVlKSB7XG5cdGN1cnJlbnRIb29rID0gNTtcblx0cmV0dXJuIHVzZU1lbW8oKCkgPT4gKHsgY3VycmVudDogaW5pdGlhbFZhbHVlIH0pLCBbXSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IHJlZlxuICogQHBhcmFtIHsoKSA9PiBvYmplY3R9IGNyZWF0ZUhhbmRsZVxuICogQHBhcmFtIHthbnlbXX0gYXJnc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZUhhbmRsZSwgYXJncykge1xuXHRjdXJyZW50SG9vayA9IDY7XG5cdHVzZUxheW91dEVmZmVjdChcblx0XHQoKSA9PiB7XG5cdFx0XHRpZiAodHlwZW9mIHJlZiA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHJlZihjcmVhdGVIYW5kbGUoKSk7XG5cdFx0XHRcdHJldHVybiAoKSA9PiByZWYobnVsbCk7XG5cdFx0XHR9IGVsc2UgaWYgKHJlZikge1xuXHRcdFx0XHRyZWYuY3VycmVudCA9IGNyZWF0ZUhhbmRsZSgpO1xuXHRcdFx0XHRyZXR1cm4gKCkgPT4gKHJlZi5jdXJyZW50ID0gbnVsbCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRhcmdzID09IG51bGwgPyBhcmdzIDogYXJncy5jb25jYXQocmVmKVxuXHQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7KCkgPT4gYW55fSBmYWN0b3J5XG4gKiBAcGFyYW0ge2FueVtdfSBhcmdzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNZW1vKGZhY3RvcnksIGFyZ3MpIHtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5NZW1vSG9va1N0YXRlfSAqL1xuXHRjb25zdCBzdGF0ZSA9IGdldEhvb2tTdGF0ZShjdXJyZW50SW5kZXgrKywgNyk7XG5cdGlmIChhcmdzQ2hhbmdlZChzdGF0ZS5fYXJncywgYXJncykpIHtcblx0XHRzdGF0ZS5fcGVuZGluZ1ZhbHVlID0gZmFjdG9yeSgpO1xuXHRcdHN0YXRlLl9wZW5kaW5nQXJncyA9IGFyZ3M7XG5cdFx0c3RhdGUuX2ZhY3RvcnkgPSBmYWN0b3J5O1xuXHRcdHJldHVybiBzdGF0ZS5fcGVuZGluZ1ZhbHVlO1xuXHR9XG5cblx0cmV0dXJuIHN0YXRlLl92YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IGNhbGxiYWNrXG4gKiBAcGFyYW0ge2FueVtdfSBhcmdzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VDYWxsYmFjayhjYWxsYmFjaywgYXJncykge1xuXHRjdXJyZW50SG9vayA9IDg7XG5cdHJldHVybiB1c2VNZW1vKCgpID0+IGNhbGxiYWNrLCBhcmdzKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlByZWFjdENvbnRleHR9IGNvbnRleHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNvbnRleHQoY29udGV4dCkge1xuXHRjb25zdCBwcm92aWRlciA9IGN1cnJlbnRDb21wb25lbnQuY29udGV4dFtjb250ZXh0Ll9pZF07XG5cdC8vIFdlIGNvdWxkIHNraXAgdGhpcyBjYWxsIGhlcmUsIGJ1dCB0aGFuIHdlJ2Qgbm90IGNhbGxcblx0Ly8gYG9wdGlvbnMuX2hvb2tgLiBXZSBuZWVkIHRvIGRvIHRoYXQgaW4gb3JkZXIgdG8gbWFrZVxuXHQvLyB0aGUgZGV2dG9vbHMgYXdhcmUgb2YgdGhpcyBob29rLlxuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbnRleHRIb29rU3RhdGV9ICovXG5cdGNvbnN0IHN0YXRlID0gZ2V0SG9va1N0YXRlKGN1cnJlbnRJbmRleCsrLCA5KTtcblx0Ly8gVGhlIGRldnRvb2xzIG5lZWRzIGFjY2VzcyB0byB0aGUgY29udGV4dCBvYmplY3QgdG9cblx0Ly8gYmUgYWJsZSB0byBwdWxsIG9mIHRoZSBkZWZhdWx0IHZhbHVlIHdoZW4gbm8gcHJvdmlkZXJcblx0Ly8gaXMgcHJlc2VudCBpbiB0aGUgdHJlZS5cblx0c3RhdGUuX2NvbnRleHQgPSBjb250ZXh0O1xuXHRpZiAoIXByb3ZpZGVyKSByZXR1cm4gY29udGV4dC5fZGVmYXVsdFZhbHVlO1xuXHQvLyBUaGlzIGlzIHByb2JhYmx5IG5vdCBzYWZlIHRvIGNvbnZlcnQgdG8gXCIhXCJcblx0aWYgKHN0YXRlLl92YWx1ZSA9PSBudWxsKSB7XG5cdFx0c3RhdGUuX3ZhbHVlID0gdHJ1ZTtcblx0XHRwcm92aWRlci5zdWIoY3VycmVudENvbXBvbmVudCk7XG5cdH1cblx0cmV0dXJuIHByb3ZpZGVyLnByb3BzLnZhbHVlO1xufVxuXG4vKipcbiAqIERpc3BsYXkgYSBjdXN0b20gbGFiZWwgZm9yIGEgY3VzdG9tIGhvb2sgZm9yIHRoZSBkZXZ0b29scyBwYW5lbFxuICogQHR5cGUgezxUPih2YWx1ZTogVCwgY2I/OiAodmFsdWU6IFQpID0+IHN0cmluZyB8IG51bWJlcikgPT4gdm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZURlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlcikge1xuXHRpZiAob3B0aW9ucy51c2VEZWJ1Z1ZhbHVlKSB7XG5cdFx0b3B0aW9ucy51c2VEZWJ1Z1ZhbHVlKGZvcm1hdHRlciA/IGZvcm1hdHRlcih2YWx1ZSkgOiB2YWx1ZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0geyhlcnJvcjogYW55LCBlcnJvckluZm86IGltcG9ydCgncHJlYWN0JykuRXJyb3JJbmZvKSA9PiB2b2lkfSBjYlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRXJyb3JCb3VuZGFyeShjYikge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVycm9yQm91bmRhcnlIb29rU3RhdGV9ICovXG5cdGNvbnN0IHN0YXRlID0gZ2V0SG9va1N0YXRlKGN1cnJlbnRJbmRleCsrLCAxMCk7XG5cdGNvbnN0IGVyclN0YXRlID0gdXNlU3RhdGUoKTtcblx0c3RhdGUuX3ZhbHVlID0gY2I7XG5cdGlmICghY3VycmVudENvbXBvbmVudC5jb21wb25lbnREaWRDYXRjaCkge1xuXHRcdGN1cnJlbnRDb21wb25lbnQuY29tcG9uZW50RGlkQ2F0Y2ggPSAoZXJyLCBlcnJvckluZm8pID0+IHtcblx0XHRcdGlmIChzdGF0ZS5fdmFsdWUpIHN0YXRlLl92YWx1ZShlcnIsIGVycm9ySW5mbyk7XG5cdFx0XHRlcnJTdGF0ZVsxXShlcnIpO1xuXHRcdH07XG5cdH1cblx0cmV0dXJuIFtcblx0XHRlcnJTdGF0ZVswXSxcblx0XHQoKSA9PiB7XG5cdFx0XHRlcnJTdGF0ZVsxXSh1bmRlZmluZWQpO1xuXHRcdH1cblx0XTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUlkKCkge1xuXHRjb25zdCBzdGF0ZSA9IGdldEhvb2tTdGF0ZShjdXJyZW50SW5kZXgrKywgMTEpO1xuXHRpZiAoIXN0YXRlLl92YWx1ZSkge1xuXHRcdC8vIEdyYWIgZWl0aGVyIHRoZSByb290IG5vZGUgb3IgdGhlIG5lYXJlc3QgYXN5bmMgYm91bmRhcnkgbm9kZS5cblx0XHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbC5kJykuVk5vZGV9ICovXG5cdFx0bGV0IHJvb3QgPSBjdXJyZW50Q29tcG9uZW50Ll92bm9kZTtcblx0XHR3aGlsZSAocm9vdCAhPT0gbnVsbCAmJiAhcm9vdC5fbWFzayAmJiByb290Ll9wYXJlbnQgIT09IG51bGwpIHtcblx0XHRcdHJvb3QgPSByb290Ll9wYXJlbnQ7XG5cdFx0fVxuXG5cdFx0bGV0IG1hc2sgPSByb290Ll9tYXNrIHx8IChyb290Ll9tYXNrID0gWzAsIDBdKTtcblx0XHRzdGF0ZS5fdmFsdWUgPSAnUCcgKyBtYXNrWzBdICsgJy0nICsgbWFza1sxXSsrO1xuXHR9XG5cblx0cmV0dXJuIHN0YXRlLl92YWx1ZTtcbn1cbi8qKlxuICogQWZ0ZXIgcGFpbnQgZWZmZWN0cyBjb25zdW1lci5cbiAqL1xuZnVuY3Rpb24gZmx1c2hBZnRlclBhaW50RWZmZWN0cygpIHtcblx0bGV0IGNvbXBvbmVudDtcblx0d2hpbGUgKChjb21wb25lbnQgPSBhZnRlclBhaW50RWZmZWN0cy5zaGlmdCgpKSkge1xuXHRcdGlmICghY29tcG9uZW50Ll9wYXJlbnREb20gfHwgIWNvbXBvbmVudC5fX2hvb2tzKSBjb250aW51ZTtcblx0XHR0cnkge1xuXHRcdFx0Y29tcG9uZW50Ll9faG9va3MuX3BlbmRpbmdFZmZlY3RzLmZvckVhY2goaW52b2tlQ2xlYW51cCk7XG5cdFx0XHRjb21wb25lbnQuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMuZm9yRWFjaChpbnZva2VFZmZlY3QpO1xuXHRcdFx0Y29tcG9uZW50Ll9faG9va3MuX3BlbmRpbmdFZmZlY3RzID0gW107XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0Y29tcG9uZW50Ll9faG9va3MuX3BlbmRpbmdFZmZlY3RzID0gW107XG5cdFx0XHRvcHRpb25zLl9jYXRjaEVycm9yKGUsIGNvbXBvbmVudC5fdm5vZGUpO1xuXHRcdH1cblx0fVxufVxuXG5sZXQgSEFTX1JBRiA9IHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT0gJ2Z1bmN0aW9uJztcblxuLyoqXG4gKiBTY2hlZHVsZSBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgYWZ0ZXIgdGhlIGJyb3dzZXIgaGFzIGEgY2hhbmNlIHRvIHBhaW50IGEgbmV3IGZyYW1lLlxuICogRG8gdGhpcyBieSBjb21iaW5pbmcgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIChyQUYpICsgc2V0VGltZW91dCB0byBpbnZva2UgYSBjYWxsYmFjayBhZnRlclxuICogdGhlIG5leHQgYnJvd3NlciBmcmFtZS5cbiAqXG4gKiBBbHNvLCBzY2hlZHVsZSBhIHRpbWVvdXQgaW4gcGFyYWxsZWwgdG8gdGhlIHRoZSByQUYgdG8gZW5zdXJlIHRoZSBjYWxsYmFjayBpcyBpbnZva2VkXG4gKiBldmVuIGlmIFJBRiBkb2Vzbid0IGZpcmUgKGZvciBleGFtcGxlIGlmIHRoZSBicm93c2VyIHRhYiBpcyBub3QgdmlzaWJsZSlcbiAqXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IGNhbGxiYWNrXG4gKi9cbmZ1bmN0aW9uIGFmdGVyTmV4dEZyYW1lKGNhbGxiYWNrKSB7XG5cdGNvbnN0IGRvbmUgPSAoKSA9PiB7XG5cdFx0Y2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXHRcdGlmIChIQVNfUkFGKSBjYW5jZWxBbmltYXRpb25GcmFtZShyYWYpO1xuXHRcdHNldFRpbWVvdXQoY2FsbGJhY2spO1xuXHR9O1xuXHRjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dChkb25lLCBSQUZfVElNRU9VVCk7XG5cblx0bGV0IHJhZjtcblx0aWYgKEhBU19SQUYpIHtcblx0XHRyYWYgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZG9uZSk7XG5cdH1cbn1cblxuLy8gTm90ZTogaWYgc29tZW9uZSB1c2VkIG9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmcgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUsXG4vLyB0aGVuIGVmZmVjdHMgd2lsbCBBTFdBWVMgcnVuIG9uIHRoZSBORVhUIGZyYW1lIGluc3RlYWQgb2YgdGhlIGN1cnJlbnQgb25lLCBpbmN1cnJpbmcgYSB+MTZtcyBkZWxheS5cbi8vIFBlcmhhcHMgdGhpcyBpcyBub3Qgc3VjaCBhIGJpZyBkZWFsLlxuLyoqXG4gKiBTY2hlZHVsZSBhZnRlclBhaW50RWZmZWN0cyBmbHVzaCBhZnRlciB0aGUgYnJvd3NlciBwYWludHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZXdRdWV1ZUxlbmd0aFxuICovXG5mdW5jdGlvbiBhZnRlclBhaW50KG5ld1F1ZXVlTGVuZ3RoKSB7XG5cdGlmIChuZXdRdWV1ZUxlbmd0aCA9PT0gMSB8fCBwcmV2UmFmICE9PSBvcHRpb25zLnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuXHRcdHByZXZSYWYgPSBvcHRpb25zLnJlcXVlc3RBbmltYXRpb25GcmFtZTtcblx0XHQocHJldlJhZiB8fCBhZnRlck5leHRGcmFtZSkoZmx1c2hBZnRlclBhaW50RWZmZWN0cyk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdEhvb2tTdGF0ZX0gaG9va1xuICovXG5mdW5jdGlvbiBpbnZva2VDbGVhbnVwKGhvb2spIHtcblx0Ly8gQSBob29rIGNsZWFudXAgY2FuIGludHJvZHVjZSBhIGNhbGwgdG8gcmVuZGVyIHdoaWNoIGNyZWF0ZXMgYSBuZXcgcm9vdCwgdGhpcyB3aWxsIGNhbGwgb3B0aW9ucy52bm9kZVxuXHQvLyBhbmQgbW92ZSB0aGUgY3VycmVudENvbXBvbmVudCBhd2F5LlxuXHRjb25zdCBjb21wID0gY3VycmVudENvbXBvbmVudDtcblx0bGV0IGNsZWFudXAgPSBob29rLl9jbGVhbnVwO1xuXHRpZiAodHlwZW9mIGNsZWFudXAgPT0gJ2Z1bmN0aW9uJykge1xuXHRcdGhvb2suX2NsZWFudXAgPSB1bmRlZmluZWQ7XG5cdFx0Y2xlYW51cCgpO1xuXHR9XG5cblx0Y3VycmVudENvbXBvbmVudCA9IGNvbXA7XG59XG5cbi8qKlxuICogSW52b2tlIGEgSG9vaydzIGVmZmVjdFxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5FZmZlY3RIb29rU3RhdGV9IGhvb2tcbiAqL1xuZnVuY3Rpb24gaW52b2tlRWZmZWN0KGhvb2spIHtcblx0Ly8gQSBob29rIGNhbGwgY2FuIGludHJvZHVjZSBhIGNhbGwgdG8gcmVuZGVyIHdoaWNoIGNyZWF0ZXMgYSBuZXcgcm9vdCwgdGhpcyB3aWxsIGNhbGwgb3B0aW9ucy52bm9kZVxuXHQvLyBhbmQgbW92ZSB0aGUgY3VycmVudENvbXBvbmVudCBhd2F5LlxuXHRjb25zdCBjb21wID0gY3VycmVudENvbXBvbmVudDtcblx0aG9vay5fY2xlYW51cCA9IGhvb2suX3ZhbHVlKCk7XG5cdGN1cnJlbnRDb21wb25lbnQgPSBjb21wO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55W119IG9sZEFyZ3NcbiAqIEBwYXJhbSB7YW55W119IG5ld0FyZ3NcbiAqL1xuZnVuY3Rpb24gYXJnc0NoYW5nZWQob2xkQXJncywgbmV3QXJncykge1xuXHRyZXR1cm4gKFxuXHRcdCFvbGRBcmdzIHx8XG5cdFx0b2xkQXJncy5sZW5ndGggIT09IG5ld0FyZ3MubGVuZ3RoIHx8XG5cdFx0bmV3QXJncy5zb21lKChhcmcsIGluZGV4KSA9PiBhcmcgIT09IG9sZEFyZ3NbaW5kZXhdKVxuXHQpO1xufVxuXG5mdW5jdGlvbiBpbnZva2VPclJldHVybihhcmcsIGYpIHtcblx0cmV0dXJuIHR5cGVvZiBmID09ICdmdW5jdGlvbicgPyBmKGFyZykgOiBmO1xufVxuIiwgIi8qKlxuICogQXNzaWduIHByb3BlcnRpZXMgZnJvbSBgcHJvcHNgIHRvIGBvYmpgXG4gKiBAdGVtcGxhdGUgTywgUCBUaGUgb2JqIGFuZCBwcm9wcyB0eXBlc1xuICogQHBhcmFtIHtPfSBvYmogVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG9cbiAqIEBwYXJhbSB7UH0gcHJvcHMgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbVxuICogQHJldHVybnMge08gJiBQfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKG9iaiwgcHJvcHMpIHtcblx0Zm9yIChsZXQgaSBpbiBwcm9wcykgb2JqW2ldID0gcHJvcHNbaV07XG5cdHJldHVybiAvKiogQHR5cGUge08gJiBQfSAqLyAob2JqKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gb2JqZWN0cyBoYXZlIGEgZGlmZmVyZW50IHNoYXBlXG4gKiBAcGFyYW0ge29iamVjdH0gYVxuICogQHBhcmFtIHtvYmplY3R9IGJcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2hhbGxvd0RpZmZlcnMoYSwgYikge1xuXHRmb3IgKGxldCBpIGluIGEpIGlmIChpICE9PSAnX19zb3VyY2UnICYmICEoaSBpbiBiKSkgcmV0dXJuIHRydWU7XG5cdGZvciAobGV0IGkgaW4gYikgaWYgKGkgIT09ICdfX3NvdXJjZScgJiYgYVtpXSAhPT0gYltpXSkgcmV0dXJuIHRydWU7XG5cdHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZU5vZGUobm9kZSkge1xuXHRsZXQgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcblx0aWYgKHBhcmVudE5vZGUpIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHZhbHVlcyBhcmUgdGhlIHNhbWUgdmFsdWVcbiAqIEBwYXJhbSB7Kn0geFxuICogQHBhcmFtIHsqfSB5XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzKHgsIHkpIHtcblx0cmV0dXJuICh4ID09PSB5ICYmICh4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSkpIHx8ICh4ICE9PSB4ICYmIHkgIT09IHkpO1xufVxuIiwgImltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgeyBzaGFsbG93RGlmZmVycyB9IGZyb20gJy4vdXRpbCc7XG5cbi8qKlxuICogQ29tcG9uZW50IGNsYXNzIHdpdGggYSBwcmVkZWZpbmVkIGBzaG91bGRDb21wb25lbnRVcGRhdGVgIGltcGxlbWVudGF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBQdXJlQ29tcG9uZW50KHApIHtcblx0dGhpcy5wcm9wcyA9IHA7XG59XG5QdXJlQ29tcG9uZW50LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnQoKTtcbi8vIFNvbWUgdGhpcmQtcGFydHkgbGlicmFyaWVzIGNoZWNrIGlmIHRoaXMgcHJvcGVydHkgaXMgcHJlc2VudFxuUHVyZUNvbXBvbmVudC5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuUHVyZUNvbXBvbmVudC5wcm90b3R5cGUuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZnVuY3Rpb24ocHJvcHMsIHN0YXRlKSB7XG5cdHJldHVybiBzaGFsbG93RGlmZmVycyh0aGlzLnByb3BzLCBwcm9wcykgfHwgc2hhbGxvd0RpZmZlcnModGhpcy5zdGF0ZSwgc3RhdGUpO1xufTtcbiIsICJpbXBvcnQgeyBjcmVhdGVFbGVtZW50IH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCB7IHNoYWxsb3dEaWZmZXJzIH0gZnJvbSAnLi91dGlsJztcblxuLyoqXG4gKiBNZW1vaXplIGEgY29tcG9uZW50LCBzbyB0aGF0IGl0IG9ubHkgdXBkYXRlcyB3aGVuIHRoZSBwcm9wcyBhY3R1YWxseSBoYXZlXG4gKiBjaGFuZ2VkLiBUaGlzIHdhcyBwcmV2aW91c2x5IGtub3duIGFzIGBSZWFjdC5wdXJlYC5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuRnVuY3Rpb25Db21wb25lbnR9IGMgZnVuY3Rpb25hbCBjb21wb25lbnRcbiAqIEBwYXJhbSB7KHByZXY6IG9iamVjdCwgbmV4dDogb2JqZWN0KSA9PiBib29sZWFufSBbY29tcGFyZXJdIEN1c3RvbSBlcXVhbGl0eSBmdW5jdGlvblxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkZ1bmN0aW9uQ29tcG9uZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVtbyhjLCBjb21wYXJlcikge1xuXHRmdW5jdGlvbiBzaG91bGRVcGRhdGUobmV4dFByb3BzKSB7XG5cdFx0bGV0IHJlZiA9IHRoaXMucHJvcHMucmVmO1xuXHRcdGxldCB1cGRhdGVSZWYgPSByZWYgPT0gbmV4dFByb3BzLnJlZjtcblx0XHRpZiAoIXVwZGF0ZVJlZiAmJiByZWYpIHtcblx0XHRcdHJlZi5jYWxsID8gcmVmKG51bGwpIDogKHJlZi5jdXJyZW50ID0gbnVsbCk7XG5cdFx0fVxuXG5cdFx0aWYgKCFjb21wYXJlcikge1xuXHRcdFx0cmV0dXJuIHNoYWxsb3dEaWZmZXJzKHRoaXMucHJvcHMsIG5leHRQcm9wcyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICFjb21wYXJlcih0aGlzLnByb3BzLCBuZXh0UHJvcHMpIHx8ICF1cGRhdGVSZWY7XG5cdH1cblxuXHRmdW5jdGlvbiBNZW1vZWQocHJvcHMpIHtcblx0XHR0aGlzLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IHNob3VsZFVwZGF0ZTtcblx0XHRyZXR1cm4gY3JlYXRlRWxlbWVudChjLCBwcm9wcyk7XG5cdH1cblx0TWVtb2VkLmRpc3BsYXlOYW1lID0gJ01lbW8oJyArIChjLmRpc3BsYXlOYW1lIHx8IGMubmFtZSkgKyAnKSc7XG5cdE1lbW9lZC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHRydWU7XG5cdE1lbW9lZC5fZm9yd2FyZGVkID0gdHJ1ZTtcblx0cmV0dXJuIE1lbW9lZDtcbn1cbiIsICJpbXBvcnQgeyBvcHRpb25zIH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCB7IGFzc2lnbiB9IGZyb20gJy4vdXRpbCc7XG5cbmxldCBvbGREaWZmSG9vayA9IG9wdGlvbnMuX2RpZmY7XG5vcHRpb25zLl9kaWZmID0gdm5vZGUgPT4ge1xuXHRpZiAodm5vZGUudHlwZSAmJiB2bm9kZS50eXBlLl9mb3J3YXJkZWQgJiYgdm5vZGUucmVmKSB7XG5cdFx0dm5vZGUucHJvcHMucmVmID0gdm5vZGUucmVmO1xuXHRcdHZub2RlLnJlZiA9IG51bGw7XG5cdH1cblx0aWYgKG9sZERpZmZIb29rKSBvbGREaWZmSG9vayh2bm9kZSk7XG59O1xuXG5leHBvcnQgY29uc3QgUkVBQ1RfRk9SV0FSRF9TWU1CT0wgPVxuXHQodHlwZW9mIFN5bWJvbCAhPSAndW5kZWZpbmVkJyAmJlxuXHRcdFN5bWJvbC5mb3IgJiZcblx0XHRTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpKSB8fFxuXHQweGY0NztcblxuLyoqXG4gKiBQYXNzIHJlZiBkb3duIHRvIGEgY2hpbGQuIFRoaXMgaXMgbWFpbmx5IHVzZWQgaW4gbGlicmFyaWVzIHdpdGggSE9DcyB0aGF0XG4gKiB3cmFwIGNvbXBvbmVudHMuIFVzaW5nIGBmb3J3YXJkUmVmYCB0aGVyZSBpcyBhbiBlYXN5IHdheSB0byBnZXQgYSByZWZlcmVuY2VcbiAqIG9mIHRoZSB3cmFwcGVkIGNvbXBvbmVudCBpbnN0ZWFkIG9mIG9uZSBvZiB0aGUgd3JhcHBlciBpdHNlbGYuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbmRleCcpLkZvcndhcmRGbn0gZm5cbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5GdW5jdGlvbkNvbXBvbmVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcndhcmRSZWYoZm4pIHtcblx0ZnVuY3Rpb24gRm9yd2FyZGVkKHByb3BzKSB7XG5cdFx0bGV0IGNsb25lID0gYXNzaWduKHt9LCBwcm9wcyk7XG5cdFx0ZGVsZXRlIGNsb25lLnJlZjtcblx0XHRyZXR1cm4gZm4oY2xvbmUsIHByb3BzLnJlZiB8fCBudWxsKTtcblx0fVxuXG5cdC8vIG1vYngtcmVhY3QgY2hlY2tzIGZvciB0aGlzIGJlaW5nIHByZXNlbnRcblx0Rm9yd2FyZGVkLiQkdHlwZW9mID0gUkVBQ1RfRk9SV0FSRF9TWU1CT0w7XG5cdC8vIG1vYngtcmVhY3QgaGVhdmlseSByZWxpZXMgb24gaW1wbGVtZW50YXRpb24gZGV0YWlscy5cblx0Ly8gSXQgZXhwZWN0cyBhbiBvYmplY3QgaGVyZSB3aXRoIGEgYHJlbmRlcmAgcHJvcGVydHksXG5cdC8vIGFuZCBwcm90b3R5cGUucmVuZGVyIHdpbGwgZmFpbC4gV2l0aG91dCB0aGlzXG5cdC8vIG1vYngtcmVhY3QgdGhyb3dzLlxuXHRGb3J3YXJkZWQucmVuZGVyID0gRm9yd2FyZGVkO1xuXG5cdEZvcndhcmRlZC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IEZvcndhcmRlZC5fZm9yd2FyZGVkID0gdHJ1ZTtcblx0Rm9yd2FyZGVkLmRpc3BsYXlOYW1lID0gJ0ZvcndhcmRSZWYoJyArIChmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lKSArICcpJztcblx0cmV0dXJuIEZvcndhcmRlZDtcbn1cbiIsICJpbXBvcnQgeyB0b0NoaWxkQXJyYXkgfSBmcm9tICdwcmVhY3QnO1xuXG5jb25zdCBtYXBGbiA9IChjaGlsZHJlbiwgZm4pID0+IHtcblx0aWYgKGNoaWxkcmVuID09IG51bGwpIHJldHVybiBudWxsO1xuXHRyZXR1cm4gdG9DaGlsZEFycmF5KHRvQ2hpbGRBcnJheShjaGlsZHJlbikubWFwKGZuKSk7XG59O1xuXG4vLyBUaGlzIEFQSSBpcyBjb21wbGV0ZWx5IHVubmVjZXNzYXJ5IGZvciBQcmVhY3QsIHNvIGl0J3MgYmFzaWNhbGx5IHBhc3N0aHJvdWdoLlxuZXhwb3J0IGNvbnN0IENoaWxkcmVuID0ge1xuXHRtYXA6IG1hcEZuLFxuXHRmb3JFYWNoOiBtYXBGbixcblx0Y291bnQoY2hpbGRyZW4pIHtcblx0XHRyZXR1cm4gY2hpbGRyZW4gPyB0b0NoaWxkQXJyYXkoY2hpbGRyZW4pLmxlbmd0aCA6IDA7XG5cdH0sXG5cdG9ubHkoY2hpbGRyZW4pIHtcblx0XHRjb25zdCBub3JtYWxpemVkID0gdG9DaGlsZEFycmF5KGNoaWxkcmVuKTtcblx0XHRpZiAobm9ybWFsaXplZC5sZW5ndGggIT09IDEpIHRocm93ICdDaGlsZHJlbi5vbmx5Jztcblx0XHRyZXR1cm4gbm9ybWFsaXplZFswXTtcblx0fSxcblx0dG9BcnJheTogdG9DaGlsZEFycmF5XG59O1xuIiwgImltcG9ydCB7IENvbXBvbmVudCwgY3JlYXRlRWxlbWVudCwgb3B0aW9ucywgRnJhZ21lbnQgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgYXNzaWduIH0gZnJvbSAnLi91dGlsJztcblxuY29uc3Qgb2xkQ2F0Y2hFcnJvciA9IG9wdGlvbnMuX2NhdGNoRXJyb3I7XG5vcHRpb25zLl9jYXRjaEVycm9yID0gZnVuY3Rpb24oZXJyb3IsIG5ld1ZOb2RlLCBvbGRWTm9kZSwgZXJyb3JJbmZvKSB7XG5cdGlmIChlcnJvci50aGVuKSB7XG5cdFx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9ICovXG5cdFx0bGV0IGNvbXBvbmVudDtcblx0XHRsZXQgdm5vZGUgPSBuZXdWTm9kZTtcblxuXHRcdGZvciAoOyAodm5vZGUgPSB2bm9kZS5fcGFyZW50KTsgKSB7XG5cdFx0XHRpZiAoKGNvbXBvbmVudCA9IHZub2RlLl9jb21wb25lbnQpICYmIGNvbXBvbmVudC5fY2hpbGREaWRTdXNwZW5kKSB7XG5cdFx0XHRcdGlmIChuZXdWTm9kZS5fZG9tID09IG51bGwpIHtcblx0XHRcdFx0XHRuZXdWTm9kZS5fZG9tID0gb2xkVk5vZGUuX2RvbTtcblx0XHRcdFx0XHRuZXdWTm9kZS5fY2hpbGRyZW4gPSBvbGRWTm9kZS5fY2hpbGRyZW47XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gRG9uJ3QgY2FsbCBvbGRDYXRjaEVycm9yIGlmIHdlIGZvdW5kIGEgU3VzcGVuc2Vcblx0XHRcdFx0cmV0dXJuIGNvbXBvbmVudC5fY2hpbGREaWRTdXNwZW5kKGVycm9yLCBuZXdWTm9kZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdG9sZENhdGNoRXJyb3IoZXJyb3IsIG5ld1ZOb2RlLCBvbGRWTm9kZSwgZXJyb3JJbmZvKTtcbn07XG5cbmNvbnN0IG9sZFVubW91bnQgPSBvcHRpb25zLnVubW91bnQ7XG5vcHRpb25zLnVubW91bnQgPSBmdW5jdGlvbih2bm9kZSkge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gKi9cblx0Y29uc3QgY29tcG9uZW50ID0gdm5vZGUuX2NvbXBvbmVudDtcblx0aWYgKGNvbXBvbmVudCAmJiBjb21wb25lbnQuX29uUmVzb2x2ZSkge1xuXHRcdGNvbXBvbmVudC5fb25SZXNvbHZlKCk7XG5cdH1cblxuXHQvLyBpZiB0aGUgY29tcG9uZW50IGlzIHN0aWxsIGh5ZHJhdGluZ1xuXHQvLyBtb3N0IGxpa2VseSBpdCBpcyBiZWNhdXNlIHRoZSBjb21wb25lbnQgaXMgc3VzcGVuZGVkXG5cdC8vIHdlIHNldCB0aGUgdm5vZGUudHlwZSBhcyBgbnVsbGAgc28gdGhhdCBpdCBpcyBub3QgYSB0eXBlb2YgZnVuY3Rpb25cblx0Ly8gc28gdGhlIHVubW91bnQgd2lsbCByZW1vdmUgdGhlIHZub2RlLl9kb21cblx0aWYgKGNvbXBvbmVudCAmJiB2bm9kZS5faHlkcmF0aW5nID09PSB0cnVlKSB7XG5cdFx0dm5vZGUudHlwZSA9IG51bGw7XG5cdH1cblxuXHRpZiAob2xkVW5tb3VudCkgb2xkVW5tb3VudCh2bm9kZSk7XG59O1xuXG5mdW5jdGlvbiBkZXRhY2hlZENsb25lKHZub2RlLCBkZXRhY2hlZFBhcmVudCwgcGFyZW50RG9tKSB7XG5cdGlmICh2bm9kZSkge1xuXHRcdGlmICh2bm9kZS5fY29tcG9uZW50ICYmIHZub2RlLl9jb21wb25lbnQuX19ob29rcykge1xuXHRcdFx0dm5vZGUuX2NvbXBvbmVudC5fX2hvb2tzLl9saXN0LmZvckVhY2goZWZmZWN0ID0+IHtcblx0XHRcdFx0aWYgKHR5cGVvZiBlZmZlY3QuX2NsZWFudXAgPT0gJ2Z1bmN0aW9uJykgZWZmZWN0Ll9jbGVhbnVwKCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0dm5vZGUuX2NvbXBvbmVudC5fX2hvb2tzID0gbnVsbDtcblx0XHR9XG5cblx0XHR2bm9kZSA9IGFzc2lnbih7fSwgdm5vZGUpO1xuXHRcdGlmICh2bm9kZS5fY29tcG9uZW50ICE9IG51bGwpIHtcblx0XHRcdGlmICh2bm9kZS5fY29tcG9uZW50Ll9wYXJlbnREb20gPT09IHBhcmVudERvbSkge1xuXHRcdFx0XHR2bm9kZS5fY29tcG9uZW50Ll9wYXJlbnREb20gPSBkZXRhY2hlZFBhcmVudDtcblx0XHRcdH1cblx0XHRcdHZub2RlLl9jb21wb25lbnQgPSBudWxsO1xuXHRcdH1cblxuXHRcdHZub2RlLl9jaGlsZHJlbiA9XG5cdFx0XHR2bm9kZS5fY2hpbGRyZW4gJiZcblx0XHRcdHZub2RlLl9jaGlsZHJlbi5tYXAoY2hpbGQgPT5cblx0XHRcdFx0ZGV0YWNoZWRDbG9uZShjaGlsZCwgZGV0YWNoZWRQYXJlbnQsIHBhcmVudERvbSlcblx0XHRcdCk7XG5cdH1cblxuXHRyZXR1cm4gdm5vZGU7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZU9yaWdpbmFsKHZub2RlLCBkZXRhY2hlZFBhcmVudCwgb3JpZ2luYWxQYXJlbnQpIHtcblx0aWYgKHZub2RlKSB7XG5cdFx0dm5vZGUuX29yaWdpbmFsID0gbnVsbDtcblx0XHR2bm9kZS5fY2hpbGRyZW4gPVxuXHRcdFx0dm5vZGUuX2NoaWxkcmVuICYmXG5cdFx0XHR2bm9kZS5fY2hpbGRyZW4ubWFwKGNoaWxkID0+XG5cdFx0XHRcdHJlbW92ZU9yaWdpbmFsKGNoaWxkLCBkZXRhY2hlZFBhcmVudCwgb3JpZ2luYWxQYXJlbnQpXG5cdFx0XHQpO1xuXG5cdFx0aWYgKHZub2RlLl9jb21wb25lbnQpIHtcblx0XHRcdGlmICh2bm9kZS5fY29tcG9uZW50Ll9wYXJlbnREb20gPT09IGRldGFjaGVkUGFyZW50KSB7XG5cdFx0XHRcdGlmICh2bm9kZS5fZG9tKSB7XG5cdFx0XHRcdFx0b3JpZ2luYWxQYXJlbnQuaW5zZXJ0QmVmb3JlKHZub2RlLl9kb20sIHZub2RlLl9uZXh0RG9tKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2bm9kZS5fY29tcG9uZW50Ll9mb3JjZSA9IHRydWU7XG5cdFx0XHRcdHZub2RlLl9jb21wb25lbnQuX3BhcmVudERvbSA9IG9yaWdpbmFsUGFyZW50O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB2bm9kZTtcbn1cblxuLy8gaGF2aW5nIGN1c3RvbSBpbmhlcml0YW5jZSBpbnN0ZWFkIG9mIGEgY2xhc3MgaGVyZSBzYXZlcyBhIGxvdCBvZiBieXRlc1xuZXhwb3J0IGZ1bmN0aW9uIFN1c3BlbnNlKCkge1xuXHQvLyB3ZSBkbyBub3QgY2FsbCBzdXBlciBoZXJlIHRvIGdvbGYgc29tZSBieXRlcy4uLlxuXHR0aGlzLl9wZW5kaW5nU3VzcGVuc2lvbkNvdW50ID0gMDtcblx0dGhpcy5fc3VzcGVuZGVycyA9IG51bGw7XG5cdHRoaXMuX2RldGFjaE9uTmV4dFJlbmRlciA9IG51bGw7XG59XG5cbi8vIFRoaW5ncyB3ZSBkbyBoZXJlIHRvIHNhdmUgc29tZSBieXRlcyBidXQgYXJlIG5vdCBwcm9wZXIgSlMgaW5oZXJpdGFuY2U6XG4vLyAtIGNhbGwgYG5ldyBDb21wb25lbnQoKWAgYXMgdGhlIHByb3RvdHlwZVxuLy8gLSBkbyBub3Qgc2V0IGBTdXNwZW5zZS5wcm90b3R5cGUuY29uc3RydWN0b3JgIHRvIGBTdXNwZW5zZWBcblN1c3BlbnNlLnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnQoKTtcblxuLyoqXG4gKiBAdGhpcyB7aW1wb3J0KCcuL2ludGVybmFsJykuU3VzcGVuc2VDb21wb25lbnR9XG4gKiBAcGFyYW0ge1Byb21pc2V9IHByb21pc2UgVGhlIHRocm93biBwcm9taXNlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlPGFueSwgYW55Pn0gc3VzcGVuZGluZ1ZOb2RlIFRoZSBzdXNwZW5kaW5nIGNvbXBvbmVudFxuICovXG5TdXNwZW5zZS5wcm90b3R5cGUuX2NoaWxkRGlkU3VzcGVuZCA9IGZ1bmN0aW9uKHByb21pc2UsIHN1c3BlbmRpbmdWTm9kZSkge1xuXHRjb25zdCBzdXNwZW5kaW5nQ29tcG9uZW50ID0gc3VzcGVuZGluZ1ZOb2RlLl9jb21wb25lbnQ7XG5cblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5TdXNwZW5zZUNvbXBvbmVudH0gKi9cblx0Y29uc3QgYyA9IHRoaXM7XG5cblx0aWYgKGMuX3N1c3BlbmRlcnMgPT0gbnVsbCkge1xuXHRcdGMuX3N1c3BlbmRlcnMgPSBbXTtcblx0fVxuXHRjLl9zdXNwZW5kZXJzLnB1c2goc3VzcGVuZGluZ0NvbXBvbmVudCk7XG5cblx0Y29uc3QgcmVzb2x2ZSA9IHN1c3BlbmRlZChjLl92bm9kZSk7XG5cblx0bGV0IHJlc29sdmVkID0gZmFsc2U7XG5cdGNvbnN0IG9uUmVzb2x2ZWQgPSAoKSA9PiB7XG5cdFx0aWYgKHJlc29sdmVkKSByZXR1cm47XG5cblx0XHRyZXNvbHZlZCA9IHRydWU7XG5cdFx0c3VzcGVuZGluZ0NvbXBvbmVudC5fb25SZXNvbHZlID0gbnVsbDtcblxuXHRcdGlmIChyZXNvbHZlKSB7XG5cdFx0XHRyZXNvbHZlKG9uU3VzcGVuc2lvbkNvbXBsZXRlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0b25TdXNwZW5zaW9uQ29tcGxldGUoKTtcblx0XHR9XG5cdH07XG5cblx0c3VzcGVuZGluZ0NvbXBvbmVudC5fb25SZXNvbHZlID0gb25SZXNvbHZlZDtcblxuXHRjb25zdCBvblN1c3BlbnNpb25Db21wbGV0ZSA9ICgpID0+IHtcblx0XHRpZiAoIS0tYy5fcGVuZGluZ1N1c3BlbnNpb25Db3VudCkge1xuXHRcdFx0Ly8gSWYgdGhlIHN1c3BlbnNpb24gd2FzIGR1cmluZyBoeWRyYXRpb24gd2UgZG9uJ3QgbmVlZCB0byByZXN0b3JlIHRoZVxuXHRcdFx0Ly8gc3VzcGVuZGVkIGNoaWxkcmVuIGludG8gdGhlIF9jaGlsZHJlbiBhcnJheVxuXHRcdFx0aWYgKGMuc3RhdGUuX3N1c3BlbmRlZCkge1xuXHRcdFx0XHRjb25zdCBzdXNwZW5kZWRWTm9kZSA9IGMuc3RhdGUuX3N1c3BlbmRlZDtcblx0XHRcdFx0Yy5fdm5vZGUuX2NoaWxkcmVuWzBdID0gcmVtb3ZlT3JpZ2luYWwoXG5cdFx0XHRcdFx0c3VzcGVuZGVkVk5vZGUsXG5cdFx0XHRcdFx0c3VzcGVuZGVkVk5vZGUuX2NvbXBvbmVudC5fcGFyZW50RG9tLFxuXHRcdFx0XHRcdHN1c3BlbmRlZFZOb2RlLl9jb21wb25lbnQuX29yaWdpbmFsUGFyZW50RG9tXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdGMuc2V0U3RhdGUoeyBfc3VzcGVuZGVkOiAoYy5fZGV0YWNoT25OZXh0UmVuZGVyID0gbnVsbCkgfSk7XG5cblx0XHRcdGxldCBzdXNwZW5kZWQ7XG5cdFx0XHR3aGlsZSAoKHN1c3BlbmRlZCA9IGMuX3N1c3BlbmRlcnMucG9wKCkpKSB7XG5cdFx0XHRcdHN1c3BlbmRlZC5mb3JjZVVwZGF0ZSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogV2UgZG8gbm90IHNldCBgc3VzcGVuZGVkOiB0cnVlYCBkdXJpbmcgaHlkcmF0aW9uIGJlY2F1c2Ugd2Ugd2FudCB0aGUgYWN0dWFsIG1hcmt1cFxuXHQgKiB0byByZW1haW4gb24gc2NyZWVuIGFuZCBoeWRyYXRlIGl0IHdoZW4gdGhlIHN1c3BlbnNlIGFjdHVhbGx5IGdldHMgcmVzb2x2ZWQuXG5cdCAqIFdoaWxlIGluIG5vbi1oeWRyYXRpb24gY2FzZXMgdGhlIHVzdWFsIGZhbGxiYWNrIC0+IGNvbXBvbmVudCBmbG93IHdvdWxkIG9jY291ci5cblx0ICovXG5cdGNvbnN0IHdhc0h5ZHJhdGluZyA9IHN1c3BlbmRpbmdWTm9kZS5faHlkcmF0aW5nID09PSB0cnVlO1xuXHRpZiAoIWMuX3BlbmRpbmdTdXNwZW5zaW9uQ291bnQrKyAmJiAhd2FzSHlkcmF0aW5nKSB7XG5cdFx0Yy5zZXRTdGF0ZSh7IF9zdXNwZW5kZWQ6IChjLl9kZXRhY2hPbk5leHRSZW5kZXIgPSBjLl92bm9kZS5fY2hpbGRyZW5bMF0pIH0pO1xuXHR9XG5cdHByb21pc2UudGhlbihvblJlc29sdmVkLCBvblJlc29sdmVkKTtcbn07XG5cblN1c3BlbnNlLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLl9zdXNwZW5kZXJzID0gW107XG59O1xuXG4vKipcbiAqIEB0aGlzIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5TdXNwZW5zZUNvbXBvbmVudH1cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuU3VzcGVuc2VDb21wb25lbnRbXCJwcm9wc1wiXX0gcHJvcHNcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuU3VzcGVuc2VTdGF0ZX0gc3RhdGVcbiAqL1xuU3VzcGVuc2UucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHByb3BzLCBzdGF0ZSkge1xuXHRpZiAodGhpcy5fZGV0YWNoT25OZXh0UmVuZGVyKSB7XG5cdFx0Ly8gV2hlbiB0aGUgU3VzcGVuc2UncyBfdm5vZGUgd2FzIGNyZWF0ZWQgYnkgYSBjYWxsIHRvIGNyZWF0ZVZOb2RlXG5cdFx0Ly8gKGkuZS4gZHVlIHRvIGEgc2V0U3RhdGUgZnVydGhlciB1cCBpbiB0aGUgdHJlZSlcblx0XHQvLyBpdCdzIF9jaGlsZHJlbiBwcm9wIGlzIG51bGwsIGluIHRoaXMgY2FzZSB3ZSBcImZvcmdldFwiIGFib3V0IHRoZSBwYXJrZWQgdm5vZGVzIHRvIGRldGFjaFxuXHRcdGlmICh0aGlzLl92bm9kZS5fY2hpbGRyZW4pIHtcblx0XHRcdGNvbnN0IGRldGFjaGVkUGFyZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0XHRjb25zdCBkZXRhY2hlZENvbXBvbmVudCA9IHRoaXMuX3Zub2RlLl9jaGlsZHJlblswXS5fY29tcG9uZW50O1xuXHRcdFx0dGhpcy5fdm5vZGUuX2NoaWxkcmVuWzBdID0gZGV0YWNoZWRDbG9uZShcblx0XHRcdFx0dGhpcy5fZGV0YWNoT25OZXh0UmVuZGVyLFxuXHRcdFx0XHRkZXRhY2hlZFBhcmVudCxcblx0XHRcdFx0KGRldGFjaGVkQ29tcG9uZW50Ll9vcmlnaW5hbFBhcmVudERvbSA9IGRldGFjaGVkQ29tcG9uZW50Ll9wYXJlbnREb20pXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2RldGFjaE9uTmV4dFJlbmRlciA9IG51bGw7XG5cdH1cblxuXHQvLyBXcmFwIGZhbGxiYWNrIHRyZWUgaW4gYSBWTm9kZSB0aGF0IHByZXZlbnRzIGl0c2VsZiBmcm9tIGJlaW5nIG1hcmtlZCBhcyBhYm9ydGluZyBtaWQtaHlkcmF0aW9uOlxuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSAqL1xuXHRjb25zdCBmYWxsYmFjayA9XG5cdFx0c3RhdGUuX3N1c3BlbmRlZCAmJiBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBwcm9wcy5mYWxsYmFjayk7XG5cdGlmIChmYWxsYmFjaykgZmFsbGJhY2suX2h5ZHJhdGluZyA9IG51bGw7XG5cblx0cmV0dXJuIFtcblx0XHRjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBzdGF0ZS5fc3VzcGVuZGVkID8gbnVsbCA6IHByb3BzLmNoaWxkcmVuKSxcblx0XHRmYWxsYmFja1xuXHRdO1xufTtcblxuLyoqXG4gKiBDaGVja3MgYW5kIGNhbGxzIHRoZSBwYXJlbnQgY29tcG9uZW50J3MgX3N1c3BlbmRlZCBtZXRob2QsIHBhc3NpbmcgaW4gdGhlXG4gKiBzdXNwZW5kZWQgdm5vZGUuIFRoaXMgaXMgYSB3YXkgZm9yIGEgcGFyZW50IChlLmcuIFN1c3BlbnNlTGlzdCkgdG8gZ2V0IG5vdGlmaWVkXG4gKiB0aGF0IG9uZSBvZiBpdHMgY2hpbGRyZW4vZGVzY2VuZGFudHMgc3VzcGVuZGVkLlxuICpcbiAqIFRoZSBwYXJlbnQgTUFZIHJldHVybiBhIGNhbGxiYWNrLiBUaGUgY2FsbGJhY2sgd2lsbCBnZXQgY2FsbGVkIHdoZW4gdGhlXG4gKiBzdXNwZW5zaW9uIHJlc29sdmVzLCBub3RpZnlpbmcgdGhlIHBhcmVudCBvZiB0aGUgZmFjdC5cbiAqIE1vcmVvdmVyLCB0aGUgY2FsbGJhY2sgZ2V0cyBmdW5jdGlvbiBgdW5zdXNwZW5kYCBhcyBhIHBhcmFtZXRlci4gVGhlIHJlc29sdmVkXG4gKiBjaGlsZCBkZXNjZW5kYW50IHdpbGwgbm90IGFjdHVhbGx5IGdldCB1bnN1c3BlbmRlZCB1bnRpbCBgdW5zdXNwZW5kYCBnZXRzIGNhbGxlZC5cbiAqIFRoaXMgaXMgYSB3YXkgZm9yIHRoZSBwYXJlbnQgdG8gZGVsYXkgdW5zdXNwZW5kaW5nLlxuICpcbiAqIElmIHRoZSBwYXJlbnQgZG9lcyBub3QgcmV0dXJuIGEgY2FsbGJhY2sgdGhlbiB0aGUgcmVzb2x2ZWQgdm5vZGVcbiAqIGdldHMgdW5zdXNwZW5kZWQgaW1tZWRpYXRlbHkgd2hlbiBpdCByZXNvbHZlcy5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICogQHJldHVybnMgeygodW5zdXNwZW5kOiAoKSA9PiB2b2lkKSA9PiB2b2lkKT99XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdXNwZW5kZWQodm5vZGUpIHtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9ICovXG5cdGxldCBjb21wb25lbnQgPSB2bm9kZS5fcGFyZW50Ll9jb21wb25lbnQ7XG5cdHJldHVybiBjb21wb25lbnQgJiYgY29tcG9uZW50Ll9zdXNwZW5kZWQgJiYgY29tcG9uZW50Ll9zdXNwZW5kZWQodm5vZGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGF6eShsb2FkZXIpIHtcblx0bGV0IHByb207XG5cdGxldCBjb21wb25lbnQ7XG5cdGxldCBlcnJvcjtcblxuXHRmdW5jdGlvbiBMYXp5KHByb3BzKSB7XG5cdFx0aWYgKCFwcm9tKSB7XG5cdFx0XHRwcm9tID0gbG9hZGVyKCk7XG5cdFx0XHRwcm9tLnRoZW4oXG5cdFx0XHRcdGV4cG9ydHMgPT4ge1xuXHRcdFx0XHRcdGNvbXBvbmVudCA9IGV4cG9ydHMuZGVmYXVsdCB8fCBleHBvcnRzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRlID0+IHtcblx0XHRcdFx0XHRlcnJvciA9IGU7XG5cdFx0XHRcdH1cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0aWYgKGVycm9yKSB7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cblx0XHRpZiAoIWNvbXBvbmVudCkge1xuXHRcdFx0dGhyb3cgcHJvbTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY3JlYXRlRWxlbWVudChjb21wb25lbnQsIHByb3BzKTtcblx0fVxuXG5cdExhenkuZGlzcGxheU5hbWUgPSAnTGF6eSc7XG5cdExhenkuX2ZvcndhcmRlZCA9IHRydWU7XG5cdHJldHVybiBMYXp5O1xufVxuIiwgImltcG9ydCB7IENvbXBvbmVudCwgdG9DaGlsZEFycmF5IH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCB7IHN1c3BlbmRlZCB9IGZyb20gJy4vc3VzcGVuc2UuanMnO1xuXG4vLyBJbmRleGVzIHRvIGxpbmtlZCBsaXN0IG5vZGVzIChub2RlcyBhcmUgc3RvcmVkIGFzIGFycmF5cyB0byBzYXZlIGJ5dGVzKS5cbmNvbnN0IFNVU1BFTkRFRF9DT1VOVCA9IDA7XG5jb25zdCBSRVNPTFZFRF9DT1VOVCA9IDE7XG5jb25zdCBORVhUX05PREUgPSAyO1xuXG4vLyBIYXZpbmcgY3VzdG9tIGluaGVyaXRhbmNlIGluc3RlYWQgb2YgYSBjbGFzcyBoZXJlIHNhdmVzIGEgbG90IG9mIGJ5dGVzLlxuZXhwb3J0IGZ1bmN0aW9uIFN1c3BlbnNlTGlzdCgpIHtcblx0dGhpcy5fbmV4dCA9IG51bGw7XG5cdHRoaXMuX21hcCA9IG51bGw7XG59XG5cbi8vIE1hcmsgb25lIG9mIGNoaWxkJ3MgZWFybGllciBzdXNwZW5zaW9ucyBhcyByZXNvbHZlZC5cbi8vIFNvbWUgcGVuZGluZyBjYWxsYmFja3MgbWF5IGJlY29tZSBjYWxsYWJsZSBkdWUgdG8gdGhpc1xuLy8gKGUuZy4gdGhlIGxhc3Qgc3VzcGVuZGVkIGRlc2NlbmRhbnQgZ2V0cyByZXNvbHZlZCB3aGVuXG4vLyByZXZlYWxPcmRlciA9PT0gJ3RvZ2V0aGVyJykuIFByb2Nlc3MgdGhvc2UgY2FsbGJhY2tzIGFzIHdlbGwuXG5jb25zdCByZXNvbHZlID0gKGxpc3QsIGNoaWxkLCBub2RlKSA9PiB7XG5cdGlmICgrK25vZGVbUkVTT0xWRURfQ09VTlRdID09PSBub2RlW1NVU1BFTkRFRF9DT1VOVF0pIHtcblx0XHQvLyBUaGUgbnVtYmVyIGEgY2hpbGQgKG9yIGFueSBvZiBpdHMgZGVzY2VuZGFudHMpIGhhcyBiZWVuIHN1c3BlbmRlZFxuXHRcdC8vIG1hdGNoZXMgdGhlIG51bWJlciBvZiB0aW1lcyBpdCdzIGJlZW4gcmVzb2x2ZWQuIFRoZXJlZm9yZSB3ZVxuXHRcdC8vIG1hcmsgdGhlIGNoaWxkIGFzIGNvbXBsZXRlbHkgcmVzb2x2ZWQgYnkgZGVsZXRpbmcgaXQgZnJvbSAuX21hcC5cblx0XHQvLyBUaGlzIGlzIHVzZWQgdG8gZmlndXJlIG91dCB3aGVuICphbGwqIGNoaWxkcmVuIGhhdmUgYmVlbiBjb21wbGV0ZWx5XG5cdFx0Ly8gcmVzb2x2ZWQgd2hlbiByZXZlYWxPcmRlciBpcyAndG9nZXRoZXInLlxuXHRcdGxpc3QuX21hcC5kZWxldGUoY2hpbGQpO1xuXHR9XG5cblx0Ly8gSWYgcmV2ZWFsT3JkZXIgaXMgZmFsc3kgdGhlbiB3ZSBjYW4gZG8gYW4gZWFybHkgZXhpdCwgYXMgdGhlXG5cdC8vIGNhbGxiYWNrcyB3b24ndCBnZXQgcXVldWVkIGluIHRoZSBub2RlIGFueXdheS5cblx0Ly8gSWYgcmV2ZWFsT3JkZXIgaXMgJ3RvZ2V0aGVyJyB0aGVuIGFsc28gZG8gYW4gZWFybHkgZXhpdFxuXHQvLyBpZiBhbGwgc3VzcGVuZGVkIGRlc2NlbmRhbnRzIGhhdmUgbm90IHlldCBiZWVuIHJlc29sdmVkLlxuXHRpZiAoXG5cdFx0IWxpc3QucHJvcHMucmV2ZWFsT3JkZXIgfHxcblx0XHQobGlzdC5wcm9wcy5yZXZlYWxPcmRlclswXSA9PT0gJ3QnICYmIGxpc3QuX21hcC5zaXplKVxuXHQpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBXYWxrIHRoZSBjdXJyZW50bHkgc3VzcGVuZGVkIGNoaWxkcmVuIGluIG9yZGVyLCBjYWxsaW5nIHRoZWlyXG5cdC8vIHN0b3JlZCBjYWxsYmFja3Mgb24gdGhlIHdheS4gU3RvcCBpZiB3ZSBlbmNvdW50ZXIgYSBjaGlsZCB0aGF0XG5cdC8vIGhhcyBub3QgYmVlbiBjb21wbGV0ZWx5IHJlc29sdmVkIHlldC5cblx0bm9kZSA9IGxpc3QuX25leHQ7XG5cdHdoaWxlIChub2RlKSB7XG5cdFx0d2hpbGUgKG5vZGUubGVuZ3RoID4gMykge1xuXHRcdFx0bm9kZS5wb3AoKSgpO1xuXHRcdH1cblx0XHRpZiAobm9kZVtSRVNPTFZFRF9DT1VOVF0gPCBub2RlW1NVU1BFTkRFRF9DT1VOVF0pIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHRsaXN0Ll9uZXh0ID0gbm9kZSA9IG5vZGVbTkVYVF9OT0RFXTtcblx0fVxufTtcblxuLy8gVGhpbmdzIHdlIGRvIGhlcmUgdG8gc2F2ZSBzb21lIGJ5dGVzIGJ1dCBhcmUgbm90IHByb3BlciBKUyBpbmhlcml0YW5jZTpcbi8vIC0gY2FsbCBgbmV3IENvbXBvbmVudCgpYCBhcyB0aGUgcHJvdG90eXBlXG4vLyAtIGRvIG5vdCBzZXQgYFN1c3BlbnNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvcmAgdG8gYFN1c3BlbnNlYFxuU3VzcGVuc2VMaXN0LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnQoKTtcblxuU3VzcGVuc2VMaXN0LnByb3RvdHlwZS5fc3VzcGVuZGVkID0gZnVuY3Rpb24oY2hpbGQpIHtcblx0Y29uc3QgbGlzdCA9IHRoaXM7XG5cdGNvbnN0IGRlbGVnYXRlZCA9IHN1c3BlbmRlZChsaXN0Ll92bm9kZSk7XG5cblx0bGV0IG5vZGUgPSBsaXN0Ll9tYXAuZ2V0KGNoaWxkKTtcblx0bm9kZVtTVVNQRU5ERURfQ09VTlRdKys7XG5cblx0cmV0dXJuIHVuc3VzcGVuZCA9PiB7XG5cdFx0Y29uc3Qgd3JhcHBlZFVuc3VzcGVuZCA9ICgpID0+IHtcblx0XHRcdGlmICghbGlzdC5wcm9wcy5yZXZlYWxPcmRlcikge1xuXHRcdFx0XHQvLyBTcGVjaWFsIGNhc2UgdGhlIHVuZGVmaW5lZCAoZmFsc3kpIHJldmVhbE9yZGVyLCBhcyB0aGVyZVxuXHRcdFx0XHQvLyBpcyBubyBuZWVkIHRvIGNvb3JkaW5hdGUgYSBzcGVjaWZpYyBvcmRlciBvciB1bnN1c3BlbmRzLlxuXHRcdFx0XHR1bnN1c3BlbmQoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5vZGUucHVzaCh1bnN1c3BlbmQpO1xuXHRcdFx0XHRyZXNvbHZlKGxpc3QsIGNoaWxkLCBub2RlKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdGlmIChkZWxlZ2F0ZWQpIHtcblx0XHRcdGRlbGVnYXRlZCh3cmFwcGVkVW5zdXNwZW5kKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0d3JhcHBlZFVuc3VzcGVuZCgpO1xuXHRcdH1cblx0fTtcbn07XG5cblN1c3BlbnNlTGlzdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24ocHJvcHMpIHtcblx0dGhpcy5fbmV4dCA9IG51bGw7XG5cdHRoaXMuX21hcCA9IG5ldyBNYXAoKTtcblxuXHRjb25zdCBjaGlsZHJlbiA9IHRvQ2hpbGRBcnJheShwcm9wcy5jaGlsZHJlbik7XG5cdGlmIChwcm9wcy5yZXZlYWxPcmRlciAmJiBwcm9wcy5yZXZlYWxPcmRlclswXSA9PT0gJ2InKSB7XG5cdFx0Ly8gSWYgb3JkZXIgPT09ICdiYWNrd2FyZHMnIChvciwgd2VsbCwgYW55dGhpbmcgc3RhcnRpbmcgd2l0aCBhICdiJylcblx0XHQvLyB0aGVuIGZsaXAgdGhlIGNoaWxkIGxpc3QgYXJvdW5kIHNvIHRoYXQgdGhlIGxhc3QgY2hpbGQgd2lsbCBiZVxuXHRcdC8vIHRoZSBmaXJzdCBpbiB0aGUgbGlua2VkIGxpc3QuXG5cdFx0Y2hpbGRyZW4ucmV2ZXJzZSgpO1xuXHR9XG5cdC8vIEJ1aWxkIHRoZSBsaW5rZWQgbGlzdC4gSXRlcmF0ZSB0aHJvdWdoIHRoZSBjaGlsZHJlbiBpbiByZXZlcnNlIG9yZGVyXG5cdC8vIHNvIHRoYXQgYF9uZXh0YCBwb2ludHMgdG8gdGhlIGZpcnN0IGxpbmtlZCBsaXN0IG5vZGUgdG8gYmUgcmVzb2x2ZWQuXG5cdGZvciAobGV0IGkgPSBjaGlsZHJlbi5sZW5ndGg7IGktLTsgKSB7XG5cdFx0Ly8gQ3JlYXRlIGEgbmV3IGxpbmtlZCBsaXN0IG5vZGUgYXMgYW4gYXJyYXkgb2YgZm9ybTpcblx0XHQvLyBcdFtzdXNwZW5kZWRfY291bnQsIHJlc29sdmVkX2NvdW50LCBuZXh0X25vZGVdXG5cdFx0Ly8gd2hlcmUgc3VzcGVuZGVkX2NvdW50IGFuZCByZXNvbHZlZF9jb3VudCBhcmUgbnVtZXJpYyBjb3VudGVycyBmb3Jcblx0XHQvLyBrZWVwaW5nIHRyYWNrIGhvdyBtYW55IHRpbWVzIGEgbm9kZSBoYXMgYmVlbiBzdXNwZW5kZWQgYW5kIHJlc29sdmVkLlxuXHRcdC8vXG5cdFx0Ly8gTm90ZSB0aGF0IHN1c3BlbmRlZF9jb3VudCBzdGFydHMgZnJvbSAxIGluc3RlYWQgb2YgMCwgc28gd2UgY2FuIGJsb2NrXG5cdFx0Ly8gcHJvY2Vzc2luZyBjYWxsYmFja3MgdW50aWwgY29tcG9uZW50RGlkTW91bnQgaGFzIGJlZW4gY2FsbGVkLiBJbiBhIHNlbnNlXG5cdFx0Ly8gbm9kZSBpcyBzdXNwZW5kZWQgYXQgbGVhc3QgdW50aWwgY29tcG9uZW50RGlkTW91bnQgZ2V0cyBjYWxsZWQhXG5cdFx0Ly9cblx0XHQvLyBQZW5kaW5nIGNhbGxiYWNrcyBhcmUgYWRkZWQgdG8gdGhlIGVuZCBvZiB0aGUgbm9kZTpcblx0XHQvLyBcdFtzdXNwZW5kZWRfY291bnQsIHJlc29sdmVkX2NvdW50LCBuZXh0X25vZGUsIGNhbGxiYWNrXzAsIGNhbGxiYWNrXzEsIC4uLl1cblx0XHR0aGlzLl9tYXAuc2V0KGNoaWxkcmVuW2ldLCAodGhpcy5fbmV4dCA9IFsxLCAwLCB0aGlzLl9uZXh0XSkpO1xuXHR9XG5cdHJldHVybiBwcm9wcy5jaGlsZHJlbjtcbn07XG5cblN1c3BlbnNlTGlzdC5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gU3VzcGVuc2VMaXN0LnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uKCkge1xuXHQvLyBJdGVyYXRlIHRocm91Z2ggYWxsIGNoaWxkcmVuIGFmdGVyIG1vdW50aW5nIGZvciB0d28gcmVhc29uczpcblx0Ly8gMS4gQXMgZWFjaCBub2RlW1NVU1BFTkRFRF9DT1VOVF0gc3RhcnRzIGZyb20gMSwgdGhpcyBpdGVyYXRpb24gaW5jcmVhc2VzXG5cdC8vICAgIGVhY2ggbm9kZVtSRUxFQVNFRF9DT1VOVF0gYnkgMSwgdGhlcmVmb3JlIGJhbGFuY2luZyB0aGUgY291bnRlcnMuXG5cdC8vICAgIFRoZSBub2RlcyBjYW4gbm93IGJlIGNvbXBsZXRlbHkgY29uc3VtZWQgZnJvbSB0aGUgbGlua2VkIGxpc3QuXG5cdC8vIDIuIEhhbmRsZSBub2RlcyB0aGF0IG1pZ2h0IGhhdmUgZ290dGVuIHJlc29sdmVkIGJldHdlZW4gcmVuZGVyIGFuZFxuXHQvLyAgICBjb21wb25lbnREaWRNb3VudC5cblx0dGhpcy5fbWFwLmZvckVhY2goKG5vZGUsIGNoaWxkKSA9PiB7XG5cdFx0cmVzb2x2ZSh0aGlzLCBjaGlsZCwgbm9kZSk7XG5cdH0pO1xufTtcbiIsICJpbXBvcnQgeyBjcmVhdGVFbGVtZW50LCByZW5kZXIgfSBmcm9tICdwcmVhY3QnO1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi9zcmMvaW5kZXgnKS5SZW5kZXJhYmxlUHJvcHM8eyBjb250ZXh0OiBhbnkgfT59IHByb3BzXG4gKi9cbmZ1bmN0aW9uIENvbnRleHRQcm92aWRlcihwcm9wcykge1xuXHR0aGlzLmdldENoaWxkQ29udGV4dCA9ICgpID0+IHByb3BzLmNvbnRleHQ7XG5cdHJldHVybiBwcm9wcy5jaGlsZHJlbjtcbn1cblxuLyoqXG4gKiBQb3J0YWwgY29tcG9uZW50XG4gKiBAdGhpcyB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fVxuICogQHBhcmFtIHtvYmplY3QgfCBudWxsIHwgdW5kZWZpbmVkfSBwcm9wc1xuICpcbiAqIFRPRE86IHVzZSBjcmVhdGVSb290KCkgaW5zdGVhZCBvZiBmYWtlIHJvb3RcbiAqL1xuZnVuY3Rpb24gUG9ydGFsKHByb3BzKSB7XG5cdGNvbnN0IF90aGlzID0gdGhpcztcblx0bGV0IGNvbnRhaW5lciA9IHByb3BzLl9jb250YWluZXI7XG5cblx0X3RoaXMuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbigpIHtcblx0XHRyZW5kZXIobnVsbCwgX3RoaXMuX3RlbXApO1xuXHRcdF90aGlzLl90ZW1wID0gbnVsbDtcblx0XHRfdGhpcy5fY29udGFpbmVyID0gbnVsbDtcblx0fTtcblxuXHQvLyBXaGVuIHdlIGNoYW5nZSBjb250YWluZXIgd2Ugc2hvdWxkIGNsZWFyIG91ciBvbGQgY29udGFpbmVyIGFuZFxuXHQvLyBpbmRpY2F0ZSBhIG5ldyBtb3VudC5cblx0aWYgKF90aGlzLl9jb250YWluZXIgJiYgX3RoaXMuX2NvbnRhaW5lciAhPT0gY29udGFpbmVyKSB7XG5cdFx0X3RoaXMuY29tcG9uZW50V2lsbFVubW91bnQoKTtcblx0fVxuXG5cdC8vIFdoZW4gcHJvcHMudm5vZGUgaXMgdW5kZWZpbmVkL2ZhbHNlL251bGwgd2UgYXJlIGRlYWxpbmcgd2l0aCBzb21lIGtpbmQgb2Zcblx0Ly8gY29uZGl0aW9uYWwgdm5vZGUuIFRoaXMgc2hvdWxkIG5vdCB0cmlnZ2VyIGEgcmVuZGVyLlxuXHRpZiAocHJvcHMuX3Zub2RlKSB7XG5cdFx0aWYgKCFfdGhpcy5fdGVtcCkge1xuXHRcdFx0X3RoaXMuX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcblxuXHRcdFx0Ly8gQ3JlYXRlIGEgZmFrZSBET00gcGFyZW50IG5vZGUgdGhhdCBtYW5hZ2VzIGEgc3Vic2V0IG9mIGBjb250YWluZXJgJ3MgY2hpbGRyZW46XG5cdFx0XHRfdGhpcy5fdGVtcCA9IHtcblx0XHRcdFx0bm9kZVR5cGU6IDEsXG5cdFx0XHRcdHBhcmVudE5vZGU6IGNvbnRhaW5lcixcblx0XHRcdFx0Y2hpbGROb2RlczogW10sXG5cdFx0XHRcdGFwcGVuZENoaWxkKGNoaWxkKSB7XG5cdFx0XHRcdFx0dGhpcy5jaGlsZE5vZGVzLnB1c2goY2hpbGQpO1xuXHRcdFx0XHRcdF90aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRpbnNlcnRCZWZvcmUoY2hpbGQsIGJlZm9yZSkge1xuXHRcdFx0XHRcdHRoaXMuY2hpbGROb2Rlcy5wdXNoKGNoaWxkKTtcblx0XHRcdFx0XHRfdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKGNoaWxkKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0cmVtb3ZlQ2hpbGQoY2hpbGQpIHtcblx0XHRcdFx0XHR0aGlzLmNoaWxkTm9kZXMuc3BsaWNlKHRoaXMuY2hpbGROb2Rlcy5pbmRleE9mKGNoaWxkKSA+Pj4gMSwgMSk7XG5cdFx0XHRcdFx0X3RoaXMuX2NvbnRhaW5lci5yZW1vdmVDaGlsZChjaGlsZCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gUmVuZGVyIG91ciB3cmFwcGluZyBlbGVtZW50IGludG8gdGVtcC5cblx0XHRyZW5kZXIoXG5cdFx0XHRjcmVhdGVFbGVtZW50KENvbnRleHRQcm92aWRlciwgeyBjb250ZXh0OiBfdGhpcy5jb250ZXh0IH0sIHByb3BzLl92bm9kZSksXG5cdFx0XHRfdGhpcy5fdGVtcFxuXHRcdCk7XG5cdH1cblx0Ly8gV2hlbiB3ZSBjb21lIGZyb20gYSBjb25kaXRpb25hbCByZW5kZXIsIG9uIGEgbW91bnRlZFxuXHQvLyBwb3J0YWwgd2Ugc2hvdWxkIGNsZWFyIHRoZSBET00uXG5cdGVsc2UgaWYgKF90aGlzLl90ZW1wKSB7XG5cdFx0X3RoaXMuY29tcG9uZW50V2lsbFVubW91bnQoKTtcblx0fVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIGBQb3J0YWxgIHRvIGNvbnRpbnVlIHJlbmRlcmluZyB0aGUgdm5vZGUgdHJlZSBhdCBhIGRpZmZlcmVudCBET00gbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGUgVGhlIHZub2RlIHRvIHJlbmRlclxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBjb250YWluZXIgVGhlIERPTSBub2RlIHRvIGNvbnRpbnVlIHJlbmRlcmluZyBpbiB0by5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVBvcnRhbCh2bm9kZSwgY29udGFpbmVyKSB7XG5cdGNvbnN0IGVsID0gY3JlYXRlRWxlbWVudChQb3J0YWwsIHsgX3Zub2RlOiB2bm9kZSwgX2NvbnRhaW5lcjogY29udGFpbmVyIH0pO1xuXHRlbC5jb250YWluZXJJbmZvID0gY29udGFpbmVyO1xuXHRyZXR1cm4gZWw7XG59XG4iLCAiaW1wb3J0IHtcblx0cmVuZGVyIGFzIHByZWFjdFJlbmRlcixcblx0aHlkcmF0ZSBhcyBwcmVhY3RIeWRyYXRlLFxuXHRvcHRpb25zLFxuXHR0b0NoaWxkQXJyYXksXG5cdENvbXBvbmVudFxufSBmcm9tICdwcmVhY3QnO1xuXG5leHBvcnQgY29uc3QgUkVBQ1RfRUxFTUVOVF9UWVBFID1cblx0KHR5cGVvZiBTeW1ib2wgIT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLmZvciAmJiBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykpIHx8XG5cdDB4ZWFjNztcblxuY29uc3QgQ0FNRUxfUFJPUFMgPSAvXig/OmFjY2VudHxhbGlnbm1lbnR8YXJhYmljfGJhc2VsaW5lfGNhcHxjbGlwKD8hUGF0aFUpfGNvbG9yfGRvbWluYW50fGZpbGx8Zmxvb2R8Zm9udHxnbHlwaCg/IVIpfGhvcml6fGltYWdlfGxldHRlcnxsaWdodGluZ3xtYXJrZXIoPyFIfFd8VSl8b3ZlcmxpbmV8cGFpbnR8cG9pbnRlcnxzaGFwZXxzdG9wfHN0cmlrZXRocm91Z2h8c3Ryb2tlfHRleHQoPyFMKXx0cmFuc2Zvcm18dW5kZXJsaW5lfHVuaWNvZGV8dW5pdHN8dnx2ZWN0b3J8dmVydHx3b3JkfHdyaXRpbmd8eCg/IUMpKVtBLVpdLztcblxuY29uc3QgSVNfRE9NID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcblxuLy8gSW5wdXQgdHlwZXMgZm9yIHdoaWNoIG9uY2hhbmdlIHNob3VsZCBub3QgYmUgY29udmVydGVkIHRvIG9uaW5wdXQuXG4vLyB0eXBlPVwiZmlsZXxjaGVja2JveHxyYWRpb1wiLCBwbHVzIFwicmFuZ2VcIiBpbiBJRTExLlxuLy8gKElFMTEgZG9lc24ndCBzdXBwb3J0IFN5bWJvbCwgd2hpY2ggd2UgdXNlIGhlcmUgdG8gdHVybiBgcmFkYCBpbnRvIGByYWAgd2hpY2ggbWF0Y2hlcyBcInJhbmdlXCIpXG5jb25zdCBvbkNoYW5nZUlucHV0VHlwZSA9IHR5cGUgPT5cblx0KHR5cGVvZiBTeW1ib2wgIT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIFN5bWJvbCgpID09ICdzeW1ib2wnXG5cdFx0PyAvZmlsfGNoZXxyYWQvaVxuXHRcdDogL2ZpbHxjaGV8cmEvaVxuXHQpLnRlc3QodHlwZSk7XG5cbi8vIFNvbWUgbGlicmFyaWVzIGxpa2UgYHJlYWN0LXZpcnR1YWxpemVkYCBleHBsaWNpdGx5IGNoZWNrIGZvciB0aGlzLlxuQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG5cbi8vIGBVTlNBRkVfKmAgbGlmZWN5Y2xlIGhvb2tzXG4vLyBQcmVhY3Qgb25seSBldmVyIGludm9rZXMgdGhlIHVucHJlZml4ZWQgbWV0aG9kcy5cbi8vIEhlcmUgd2UgcHJvdmlkZSBhIGJhc2UgXCJmYWxsYmFja1wiIGltcGxlbWVudGF0aW9uIHRoYXQgY2FsbHMgYW55IGRlZmluZWQgVU5TQUZFXyBwcmVmaXhlZCBtZXRob2QuXG4vLyAtIElmIGEgY29tcG9uZW50IGRlZmluZXMgaXRzIG93biBgY29tcG9uZW50RGlkTW91bnQoKWAgKGluY2x1ZGluZyB2aWEgZGVmaW5lUHJvcGVydHkpLCB1c2UgdGhhdC5cbi8vIC0gSWYgYSBjb21wb25lbnQgZGVmaW5lcyBgVU5TQUZFX2NvbXBvbmVudERpZE1vdW50KClgLCBgY29tcG9uZW50RGlkTW91bnRgIGlzIHRoZSBhbGlhcyBnZXR0ZXIvc2V0dGVyLlxuLy8gLSBJZiBhbnl0aGluZyBhc3NpZ25zIHRvIGFuIGBVTlNBRkVfKmAgcHJvcGVydHksIHRoZSBhc3NpZ25tZW50IGlzIGZvcndhcmRlZCB0byB0aGUgdW5wcmVmaXhlZCBwcm9wZXJ0eS5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJlYWN0anMvcHJlYWN0L2lzc3Vlcy8xOTQxXG5bXG5cdCdjb21wb25lbnRXaWxsTW91bnQnLFxuXHQnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcycsXG5cdCdjb21wb25lbnRXaWxsVXBkYXRlJ1xuXS5mb3JFYWNoKGtleSA9PiB7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBrZXksIHtcblx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0Z2V0KCkge1xuXHRcdFx0cmV0dXJuIHRoaXNbJ1VOU0FGRV8nICsga2V5XTtcblx0XHR9LFxuXHRcdHNldCh2KSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdHZhbHVlOiB2XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0pO1xufSk7XG5cbi8qKlxuICogUHJveHkgcmVuZGVyKCkgc2luY2UgUmVhY3QgcmV0dXJucyBhIENvbXBvbmVudCByZWZlcmVuY2UuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZSBWTm9kZSB0cmVlIHRvIHJlbmRlclxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBwYXJlbnQgRE9NIG5vZGUgdG8gcmVuZGVyIHZub2RlIHRyZWUgaW50b1xuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBbY2FsbGJhY2tdIE9wdGlvbmFsIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgcmVuZGVyaW5nXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50IHwgbnVsbH0gVGhlIHJvb3QgY29tcG9uZW50IHJlZmVyZW5jZSBvciBudWxsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXIodm5vZGUsIHBhcmVudCwgY2FsbGJhY2spIHtcblx0Ly8gUmVhY3QgZGVzdHJveXMgYW55IGV4aXN0aW5nIERPTSBub2Rlcywgc2VlICMxNzI3XG5cdC8vIC4uLmJ1dCBvbmx5IG9uIHRoZSBmaXJzdCByZW5kZXIsIHNlZSAjMTgyOFxuXHRpZiAocGFyZW50Ll9jaGlsZHJlbiA9PSBudWxsKSB7XG5cdFx0cGFyZW50LnRleHRDb250ZW50ID0gJyc7XG5cdH1cblxuXHRwcmVhY3RSZW5kZXIodm5vZGUsIHBhcmVudCk7XG5cdGlmICh0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2soKTtcblxuXHRyZXR1cm4gdm5vZGUgPyB2bm9kZS5fY29tcG9uZW50IDogbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGh5ZHJhdGUodm5vZGUsIHBhcmVudCwgY2FsbGJhY2spIHtcblx0cHJlYWN0SHlkcmF0ZSh2bm9kZSwgcGFyZW50KTtcblx0aWYgKHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nKSBjYWxsYmFjaygpO1xuXG5cdHJldHVybiB2bm9kZSA/IHZub2RlLl9jb21wb25lbnQgOiBudWxsO1xufVxuXG5sZXQgb2xkRXZlbnRIb29rID0gb3B0aW9ucy5ldmVudDtcbm9wdGlvbnMuZXZlbnQgPSBlID0+IHtcblx0aWYgKG9sZEV2ZW50SG9vaykgZSA9IG9sZEV2ZW50SG9vayhlKTtcblx0ZS5wZXJzaXN0ID0gZW1wdHk7XG5cdGUuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBpc1Byb3BhZ2F0aW9uU3RvcHBlZDtcblx0ZS5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBpc0RlZmF1bHRQcmV2ZW50ZWQ7XG5cdHJldHVybiAoZS5uYXRpdmVFdmVudCA9IGUpO1xufTtcblxuZnVuY3Rpb24gZW1wdHkoKSB7fVxuXG5mdW5jdGlvbiBpc1Byb3BhZ2F0aW9uU3RvcHBlZCgpIHtcblx0cmV0dXJuIHRoaXMuY2FuY2VsQnViYmxlO1xufVxuXG5mdW5jdGlvbiBpc0RlZmF1bHRQcmV2ZW50ZWQoKSB7XG5cdHJldHVybiB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQ7XG59XG5cbmxldCBjbGFzc05hbWVEZXNjcmlwdG9yID0ge1xuXHRjb25maWd1cmFibGU6IHRydWUsXG5cdGdldCgpIHtcblx0XHRyZXR1cm4gdGhpcy5jbGFzcztcblx0fVxufTtcblxubGV0IG9sZFZOb2RlSG9vayA9IG9wdGlvbnMudm5vZGU7XG5vcHRpb25zLnZub2RlID0gdm5vZGUgPT4ge1xuXHRsZXQgdHlwZSA9IHZub2RlLnR5cGU7XG5cdGxldCBwcm9wcyA9IHZub2RlLnByb3BzO1xuXHRsZXQgbm9ybWFsaXplZFByb3BzID0gcHJvcHM7XG5cblx0Ly8gb25seSBub3JtYWxpemUgcHJvcHMgb24gRWxlbWVudCBub2Rlc1xuXHRpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG5cdFx0Y29uc3Qgbm9uQ3VzdG9tRWxlbWVudCA9IHR5cGUuaW5kZXhPZignLScpID09PSAtMTtcblx0XHRub3JtYWxpemVkUHJvcHMgPSB7fTtcblxuXHRcdGZvciAobGV0IGkgaW4gcHJvcHMpIHtcblx0XHRcdGxldCB2YWx1ZSA9IHByb3BzW2ldO1xuXG5cdFx0XHRpZiAoSVNfRE9NICYmIGkgPT09ICdjaGlsZHJlbicgJiYgdHlwZSA9PT0gJ25vc2NyaXB0Jykge1xuXHRcdFx0XHQvLyBFbXVsYXRlIFJlYWN0J3MgYmVoYXZpb3Igb2Ygbm90IHJlbmRlcmluZyB0aGUgY29udGVudHMgb2Ygbm9zY3JpcHQgdGFncyBvbiB0aGUgY2xpZW50LlxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH0gZWxzZSBpZiAoaSA9PT0gJ3ZhbHVlJyAmJiAnZGVmYXVsdFZhbHVlJyBpbiBwcm9wcyAmJiB2YWx1ZSA9PSBudWxsKSB7XG5cdFx0XHRcdC8vIFNraXAgYXBwbHlpbmcgdmFsdWUgaWYgaXQgaXMgbnVsbC91bmRlZmluZWQgYW5kIHdlIGFscmVhZHkgc2V0XG5cdFx0XHRcdC8vIGEgZGVmYXVsdCB2YWx1ZVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRcdGkgPT09ICdkZWZhdWx0VmFsdWUnICYmXG5cdFx0XHRcdCd2YWx1ZScgaW4gcHJvcHMgJiZcblx0XHRcdFx0cHJvcHMudmFsdWUgPT0gbnVsbFxuXHRcdFx0KSB7XG5cdFx0XHRcdC8vIGBkZWZhdWx0VmFsdWVgIGlzIHRyZWF0ZWQgYXMgYSBmYWxsYmFjayBgdmFsdWVgIHdoZW4gYSB2YWx1ZSBwcm9wIGlzIHByZXNlbnQgYnV0IG51bGwvdW5kZWZpbmVkLlxuXHRcdFx0XHQvLyBgZGVmYXVsdFZhbHVlYCBmb3IgRWxlbWVudHMgd2l0aCBubyB2YWx1ZSBwcm9wIGlzIHRoZSBzYW1lIGFzIHRoZSBET00gZGVmYXVsdFZhbHVlIHByb3BlcnR5LlxuXHRcdFx0XHRpID0gJ3ZhbHVlJztcblx0XHRcdH0gZWxzZSBpZiAoaSA9PT0gJ2Rvd25sb2FkJyAmJiB2YWx1ZSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHQvLyBDYWxsaW5nIGBzZXRBdHRyaWJ1dGVgIHdpdGggYSB0cnV0aHkgdmFsdWUgd2lsbCBsZWFkIHRvIGl0IGJlaW5nXG5cdFx0XHRcdC8vIHBhc3NlZCBhcyBhIHN0cmluZ2lmaWVkIHZhbHVlLCBlLmcuIGBkb3dubG9hZD1cInRydWVcImAuIFJlYWN0XG5cdFx0XHRcdC8vIGNvbnZlcnRzIGl0IHRvIGFuIGVtcHR5IHN0cmluZyBpbnN0ZWFkLCBvdGhlcndpc2UgdGhlIGF0dHJpYnV0ZVxuXHRcdFx0XHQvLyB2YWx1ZSB3aWxsIGJlIHVzZWQgYXMgdGhlIGZpbGUgbmFtZSBhbmQgdGhlIGZpbGUgd2lsbCBiZSBjYWxsZWRcblx0XHRcdFx0Ly8gXCJ0cnVlXCIgdXBvbiBkb3dubG9hZGluZyBpdC5cblx0XHRcdFx0dmFsdWUgPSAnJztcblx0XHRcdH0gZWxzZSBpZiAoL29uZG91YmxlY2xpY2svaS50ZXN0KGkpKSB7XG5cdFx0XHRcdGkgPSAnb25kYmxjbGljayc7XG5cdFx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0XHQvXm9uY2hhbmdlKHRleHRhcmVhfGlucHV0KS9pLnRlc3QoaSArIHR5cGUpICYmXG5cdFx0XHRcdCFvbkNoYW5nZUlucHV0VHlwZShwcm9wcy50eXBlKVxuXHRcdFx0KSB7XG5cdFx0XHRcdGkgPSAnb25pbnB1dCc7XG5cdFx0XHR9IGVsc2UgaWYgKC9eb25mb2N1cyQvaS50ZXN0KGkpKSB7XG5cdFx0XHRcdGkgPSAnb25mb2N1c2luJztcblx0XHRcdH0gZWxzZSBpZiAoL15vbmJsdXIkL2kudGVzdChpKSkge1xuXHRcdFx0XHRpID0gJ29uZm9jdXNvdXQnO1xuXHRcdFx0fSBlbHNlIGlmICgvXm9uKEFuaXxUcmF8VG91fEJlZm9yZUlucHxDb21wbykvLnRlc3QoaSkpIHtcblx0XHRcdFx0aSA9IGkudG9Mb3dlckNhc2UoKTtcblx0XHRcdH0gZWxzZSBpZiAobm9uQ3VzdG9tRWxlbWVudCAmJiBDQU1FTF9QUk9QUy50ZXN0KGkpKSB7XG5cdFx0XHRcdGkgPSBpLnJlcGxhY2UoL1tBLVowLTldL2csICctJCYnKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuXHRcdFx0XHR2YWx1ZSA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHN1cHBvcnQgZm9yIG9uSW5wdXQgYW5kIG9uQ2hhbmdlLCBzZWUgIzM1NjFcblx0XHRcdC8vIGlmIHdlIGhhdmUgYW4gb25pbnB1dCBwcm9wIGFscmVhZHkgY2hhbmdlIGl0IHRvIG9uaW5wdXRDYXB0dXJlXG5cdFx0XHRpZiAoL15vbmlucHV0JC9pLnRlc3QoaSkpIHtcblx0XHRcdFx0aSA9IGkudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0aWYgKG5vcm1hbGl6ZWRQcm9wc1tpXSkge1xuXHRcdFx0XHRcdGkgPSAnb25pbnB1dENhcHR1cmUnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdG5vcm1hbGl6ZWRQcm9wc1tpXSA9IHZhbHVlO1xuXHRcdH1cblxuXHRcdC8vIEFkZCBzdXBwb3J0IGZvciBhcnJheSBzZWxlY3QgdmFsdWVzOiA8c2VsZWN0IG11bHRpcGxlIHZhbHVlPXtbXX0gLz5cblx0XHRpZiAoXG5cdFx0XHR0eXBlID09ICdzZWxlY3QnICYmXG5cdFx0XHRub3JtYWxpemVkUHJvcHMubXVsdGlwbGUgJiZcblx0XHRcdEFycmF5LmlzQXJyYXkobm9ybWFsaXplZFByb3BzLnZhbHVlKVxuXHRcdCkge1xuXHRcdFx0Ly8gZm9yRWFjaCgpIGFsd2F5cyByZXR1cm5zIHVuZGVmaW5lZCwgd2hpY2ggd2UgYWJ1c2UgaGVyZSB0byB1bnNldCB0aGUgdmFsdWUgcHJvcC5cblx0XHRcdG5vcm1hbGl6ZWRQcm9wcy52YWx1ZSA9IHRvQ2hpbGRBcnJheShwcm9wcy5jaGlsZHJlbikuZm9yRWFjaChjaGlsZCA9PiB7XG5cdFx0XHRcdGNoaWxkLnByb3BzLnNlbGVjdGVkID1cblx0XHRcdFx0XHRub3JtYWxpemVkUHJvcHMudmFsdWUuaW5kZXhPZihjaGlsZC5wcm9wcy52YWx1ZSkgIT0gLTE7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvLyBBZGRpbmcgc3VwcG9ydCBmb3IgZGVmYXVsdFZhbHVlIGluIHNlbGVjdCB0YWdcblx0XHRpZiAodHlwZSA9PSAnc2VsZWN0JyAmJiBub3JtYWxpemVkUHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcblx0XHRcdG5vcm1hbGl6ZWRQcm9wcy52YWx1ZSA9IHRvQ2hpbGRBcnJheShwcm9wcy5jaGlsZHJlbikuZm9yRWFjaChjaGlsZCA9PiB7XG5cdFx0XHRcdGlmIChub3JtYWxpemVkUHJvcHMubXVsdGlwbGUpIHtcblx0XHRcdFx0XHRjaGlsZC5wcm9wcy5zZWxlY3RlZCA9XG5cdFx0XHRcdFx0XHRub3JtYWxpemVkUHJvcHMuZGVmYXVsdFZhbHVlLmluZGV4T2YoY2hpbGQucHJvcHMudmFsdWUpICE9IC0xO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNoaWxkLnByb3BzLnNlbGVjdGVkID1cblx0XHRcdFx0XHRcdG5vcm1hbGl6ZWRQcm9wcy5kZWZhdWx0VmFsdWUgPT0gY2hpbGQucHJvcHMudmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHZub2RlLnByb3BzID0gbm9ybWFsaXplZFByb3BzO1xuXG5cdFx0aWYgKHByb3BzLmNsYXNzICE9IHByb3BzLmNsYXNzTmFtZSkge1xuXHRcdFx0Y2xhc3NOYW1lRGVzY3JpcHRvci5lbnVtZXJhYmxlID0gJ2NsYXNzTmFtZScgaW4gcHJvcHM7XG5cdFx0XHRpZiAocHJvcHMuY2xhc3NOYW1lICE9IG51bGwpIG5vcm1hbGl6ZWRQcm9wcy5jbGFzcyA9IHByb3BzLmNsYXNzTmFtZTtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShub3JtYWxpemVkUHJvcHMsICdjbGFzc05hbWUnLCBjbGFzc05hbWVEZXNjcmlwdG9yKTtcblx0XHR9XG5cdH1cblxuXHR2bm9kZS4kJHR5cGVvZiA9IFJFQUNUX0VMRU1FTlRfVFlQRTtcblxuXHRpZiAob2xkVk5vZGVIb29rKSBvbGRWTm9kZUhvb2sodm5vZGUpO1xufTtcblxuLy8gT25seSBuZWVkZWQgZm9yIHJlYWN0LXJlbGF5XG5sZXQgY3VycmVudENvbXBvbmVudDtcbmNvbnN0IG9sZEJlZm9yZVJlbmRlciA9IG9wdGlvbnMuX3JlbmRlcjtcbm9wdGlvbnMuX3JlbmRlciA9IGZ1bmN0aW9uKHZub2RlKSB7XG5cdGlmIChvbGRCZWZvcmVSZW5kZXIpIHtcblx0XHRvbGRCZWZvcmVSZW5kZXIodm5vZGUpO1xuXHR9XG5cdGN1cnJlbnRDb21wb25lbnQgPSB2bm9kZS5fY29tcG9uZW50O1xufTtcblxuLy8gVGhpcyBpcyBhIHZlcnkgdmVyeSBwcml2YXRlIGludGVybmFsIGZ1bmN0aW9uIGZvciBSZWFjdCBpdFxuLy8gaXMgdXNlZCB0byBzb3J0LW9mIGRvIHJ1bnRpbWUgZGVwZW5kZW5jeSBpbmplY3Rpb24uIFNvIGZhclxuLy8gb25seSBgcmVhY3QtcmVsYXlgIG1ha2VzIHVzZSBvZiBpdC4gSXQgdXNlcyBpdCB0byByZWFkIHRoZVxuLy8gY29udGV4dCB2YWx1ZS5cbmV4cG9ydCBjb25zdCBfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCA9IHtcblx0UmVhY3RDdXJyZW50RGlzcGF0Y2hlcjoge1xuXHRcdGN1cnJlbnQ6IHtcblx0XHRcdHJlYWRDb250ZXh0KGNvbnRleHQpIHtcblx0XHRcdFx0cmV0dXJuIGN1cnJlbnRDb21wb25lbnQuX2dsb2JhbENvbnRleHRbY29udGV4dC5faWRdLnByb3BzLnZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcbiIsICJpbXBvcnQge1xuXHRjcmVhdGVFbGVtZW50LFxuXHRyZW5kZXIgYXMgcHJlYWN0UmVuZGVyLFxuXHRjbG9uZUVsZW1lbnQgYXMgcHJlYWN0Q2xvbmVFbGVtZW50LFxuXHRjcmVhdGVSZWYsXG5cdENvbXBvbmVudCxcblx0Y3JlYXRlQ29udGV4dCxcblx0RnJhZ21lbnRcbn0gZnJvbSAncHJlYWN0JztcbmltcG9ydCB7XG5cdHVzZVN0YXRlLFxuXHR1c2VJZCxcblx0dXNlUmVkdWNlcixcblx0dXNlRWZmZWN0LFxuXHR1c2VMYXlvdXRFZmZlY3QsXG5cdHVzZVJlZixcblx0dXNlSW1wZXJhdGl2ZUhhbmRsZSxcblx0dXNlTWVtbyxcblx0dXNlQ2FsbGJhY2ssXG5cdHVzZUNvbnRleHQsXG5cdHVzZURlYnVnVmFsdWVcbn0gZnJvbSAncHJlYWN0L2hvb2tzJztcbmltcG9ydCB7IFB1cmVDb21wb25lbnQgfSBmcm9tICcuL1B1cmVDb21wb25lbnQnO1xuaW1wb3J0IHsgbWVtbyB9IGZyb20gJy4vbWVtbyc7XG5pbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAnLi9mb3J3YXJkUmVmJztcbmltcG9ydCB7IENoaWxkcmVuIH0gZnJvbSAnLi9DaGlsZHJlbic7XG5pbXBvcnQgeyBTdXNwZW5zZSwgbGF6eSB9IGZyb20gJy4vc3VzcGVuc2UnO1xuaW1wb3J0IHsgU3VzcGVuc2VMaXN0IH0gZnJvbSAnLi9zdXNwZW5zZS1saXN0JztcbmltcG9ydCB7IGNyZWF0ZVBvcnRhbCB9IGZyb20gJy4vcG9ydGFscyc7XG5pbXBvcnQgeyBpcyB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQge1xuXHRoeWRyYXRlLFxuXHRyZW5kZXIsXG5cdFJFQUNUX0VMRU1FTlRfVFlQRSxcblx0X19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRURcbn0gZnJvbSAnLi9yZW5kZXInO1xuXG5jb25zdCB2ZXJzaW9uID0gJzE3LjAuMic7IC8vIHRyaWNrIGxpYnJhcmllcyB0byB0aGluayB3ZSBhcmUgcmVhY3RcblxuLyoqXG4gKiBMZWdhY3kgdmVyc2lvbiBvZiBjcmVhdGVFbGVtZW50LlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZVtcInR5cGVcIl19IHR5cGUgVGhlIG5vZGUgbmFtZSBvciBDb21wb25lbnQgY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRmFjdG9yeSh0eXBlKSB7XG5cdHJldHVybiBjcmVhdGVFbGVtZW50LmJpbmQobnVsbCwgdHlwZSk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHBhc3NlZCBlbGVtZW50IGlzIGEgdmFsaWQgKHApcmVhY3Qgbm9kZS5cbiAqIEBwYXJhbSB7Kn0gZWxlbWVudCBUaGUgZWxlbWVudCB0byBjaGVja1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KGVsZW1lbnQpIHtcblx0cmV0dXJuICEhZWxlbWVudCAmJiBlbGVtZW50LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5cbi8qKlxuICogV3JhcCBgY2xvbmVFbGVtZW50YCB0byBhYm9ydCBpZiB0aGUgcGFzc2VkIGVsZW1lbnQgaXMgbm90IGEgdmFsaWQgZWxlbWVudCBhbmQgYXBwbHlcbiAqIGFsbCB2bm9kZSBub3JtYWxpemF0aW9ucy5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9IGVsZW1lbnQgVGhlIHZub2RlIHRvIGNsb25lXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgUHJvcHMgdG8gYWRkIHdoZW4gY2xvbmluZ1xuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnRDaGlsZHJlbj59IHJlc3QgT3B0aW9uYWwgY29tcG9uZW50IGNoaWxkcmVuXG4gKi9cbmZ1bmN0aW9uIGNsb25lRWxlbWVudChlbGVtZW50KSB7XG5cdGlmICghaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkpIHJldHVybiBlbGVtZW50O1xuXHRyZXR1cm4gcHJlYWN0Q2xvbmVFbGVtZW50LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICogUmVtb3ZlIGEgY29tcG9uZW50IHRyZWUgZnJvbSB0aGUgRE9NLCBpbmNsdWRpbmcgc3RhdGUgYW5kIGV2ZW50IGhhbmRsZXJzLlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBjb250YWluZXJcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiB1bm1vdW50Q29tcG9uZW50QXROb2RlKGNvbnRhaW5lcikge1xuXHRpZiAoY29udGFpbmVyLl9jaGlsZHJlbikge1xuXHRcdHByZWFjdFJlbmRlcihudWxsLCBjb250YWluZXIpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG1hdGNoaW5nIERPTSBub2RlIGZvciBhIGNvbXBvbmVudFxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9IGNvbXBvbmVudFxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnQgfCBudWxsfVxuICovXG5mdW5jdGlvbiBmaW5kRE9NTm9kZShjb21wb25lbnQpIHtcblx0cmV0dXJuIChcblx0XHQoY29tcG9uZW50ICYmXG5cdFx0XHQoY29tcG9uZW50LmJhc2UgfHwgKGNvbXBvbmVudC5ub2RlVHlwZSA9PT0gMSAmJiBjb21wb25lbnQpKSkgfHxcblx0XHRudWxsXG5cdCk7XG59XG5cbi8qKlxuICogRGVwcmVjYXRlZCB3YXkgdG8gY29udHJvbCBiYXRjaGVkIHJlbmRlcmluZyBpbnNpZGUgdGhlIHJlY29uY2lsZXIsIGJ1dCB3ZVxuICogYWxyZWFkeSBzY2hlZHVsZSBpbiBiYXRjaGVzIGluc2lkZSBvdXIgcmVuZGVyaW5nIGNvZGVcbiAqIEB0ZW1wbGF0ZSBBcmdcbiAqIEBwYXJhbSB7KGFyZzogQXJnKSA9PiB2b2lkfSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHRyaWdnZXJzIHRoZSB1cGRhdGVkXG4gKiBAcGFyYW0ge0FyZ30gW2FyZ10gT3B0aW9uYWwgYXJndW1lbnQgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIHRoZSBjYWxsYmFja1xuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FtZWxjYXNlXG5jb25zdCB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyA9IChjYWxsYmFjaywgYXJnKSA9PiBjYWxsYmFjayhhcmcpO1xuXG4vKipcbiAqIEluIFJlYWN0LCBgZmx1c2hTeW5jYCBmbHVzaGVzIHRoZSBlbnRpcmUgdHJlZSBhbmQgZm9yY2VzIGEgcmVyZW5kZXIuIEl0J3NcbiAqIGltcGxtZW50ZWQgaGVyZSBhcyBhIG5vLW9wLlxuICogQHRlbXBsYXRlIEFyZ1xuICogQHRlbXBsYXRlIFJlc3VsdFxuICogQHBhcmFtIHsoYXJnOiBBcmcpID0+IFJlc3VsdH0gY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBydW5zIGJlZm9yZSB0aGUgZmx1c2hcbiAqIEBwYXJhbSB7QXJnfSBbYXJnXSBPcHRpb25hbCBhcmd1bWVudCB0aGF0IGNhbiBiZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrXG4gKiBAcmV0dXJuc1xuICovXG5jb25zdCBmbHVzaFN5bmMgPSAoY2FsbGJhY2ssIGFyZykgPT4gY2FsbGJhY2soYXJnKTtcblxuLyoqXG4gKiBTdHJpY3QgTW9kZSBpcyBub3QgaW1wbGVtZW50ZWQgaW4gUHJlYWN0LCBzbyB3ZSBwcm92aWRlIGEgc3RhbmQtaW4gZm9yIGl0XG4gKiB0aGF0IGp1c3QgcmVuZGVycyBpdHMgY2hpbGRyZW4gd2l0aG91dCBpbXBvc2luZyBhbnkgcmVzdHJpY3Rpb25zLlxuICovXG5jb25zdCBTdHJpY3RNb2RlID0gRnJhZ21lbnQ7XG5cbmV4cG9ydCBmdW5jdGlvbiBzdGFydFRyYW5zaXRpb24oY2IpIHtcblx0Y2IoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZURlZmVycmVkVmFsdWUodmFsKSB7XG5cdHJldHVybiB2YWw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VUcmFuc2l0aW9uKCkge1xuXHRyZXR1cm4gW2ZhbHNlLCBzdGFydFRyYW5zaXRpb25dO1xufVxuXG4vLyBUT0RPOiBpbiB0aGVvcnkgdGhpcyBzaG91bGQgYmUgZG9uZSBhZnRlciBhIFZOb2RlIGlzIGRpZmZlZCBhcyB3ZSB3YW50IHRvIGluc2VydFxuLy8gc3R5bGVzLy4uLiBiZWZvcmUgaXQgYXR0YWNoZXNcbmV4cG9ydCBjb25zdCB1c2VJbnNlcnRpb25FZmZlY3QgPSB1c2VMYXlvdXRFZmZlY3Q7XG5cbi8qKlxuICogVGhpcyBpcyB0YWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL21haW4vcGFja2FnZXMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvc3JjL3VzZVN5bmNFeHRlcm5hbFN0b3JlU2hpbUNsaWVudC5qcyNMODRcbiAqIG9uIGEgaGlnaCBsZXZlbCB0aGlzIGN1dHMgb3V0IHRoZSB3YXJuaW5ncywgLi4uIGFuZCBhdHRlbXB0cyBhIHNtYWxsZXIgaW1wbGVtZW50YXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QpIHtcblx0Y29uc3QgdmFsdWUgPSBnZXRTbmFwc2hvdCgpO1xuXG5cdGNvbnN0IFt7IF9pbnN0YW5jZSB9LCBmb3JjZVVwZGF0ZV0gPSB1c2VTdGF0ZSh7XG5cdFx0X2luc3RhbmNlOiB7IF92YWx1ZTogdmFsdWUsIF9nZXRTbmFwc2hvdDogZ2V0U25hcHNob3QgfVxuXHR9KTtcblxuXHR1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuXHRcdF9pbnN0YW5jZS5fdmFsdWUgPSB2YWx1ZTtcblx0XHRfaW5zdGFuY2UuX2dldFNuYXBzaG90ID0gZ2V0U25hcHNob3Q7XG5cblx0XHRpZiAoIWlzKF9pbnN0YW5jZS5fdmFsdWUsIGdldFNuYXBzaG90KCkpKSB7XG5cdFx0XHRmb3JjZVVwZGF0ZSh7IF9pbnN0YW5jZSB9KTtcblx0XHR9XG5cdH0sIFtzdWJzY3JpYmUsIHZhbHVlLCBnZXRTbmFwc2hvdF0pO1xuXG5cdHVzZUVmZmVjdCgoKSA9PiB7XG5cdFx0aWYgKCFpcyhfaW5zdGFuY2UuX3ZhbHVlLCBfaW5zdGFuY2UuX2dldFNuYXBzaG90KCkpKSB7XG5cdFx0XHRmb3JjZVVwZGF0ZSh7IF9pbnN0YW5jZSB9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gc3Vic2NyaWJlKCgpID0+IHtcblx0XHRcdGlmICghaXMoX2luc3RhbmNlLl92YWx1ZSwgX2luc3RhbmNlLl9nZXRTbmFwc2hvdCgpKSkge1xuXHRcdFx0XHRmb3JjZVVwZGF0ZSh7IF9pbnN0YW5jZSB9KTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSwgW3N1YnNjcmliZV0pO1xuXG5cdHJldHVybiB2YWx1ZTtcbn1cblxuZXhwb3J0ICogZnJvbSAncHJlYWN0L2hvb2tzJztcbmV4cG9ydCB7XG5cdHZlcnNpb24sXG5cdENoaWxkcmVuLFxuXHRyZW5kZXIsXG5cdGh5ZHJhdGUsXG5cdHVubW91bnRDb21wb25lbnRBdE5vZGUsXG5cdGNyZWF0ZVBvcnRhbCxcblx0Y3JlYXRlRWxlbWVudCxcblx0Y3JlYXRlQ29udGV4dCxcblx0Y3JlYXRlRmFjdG9yeSxcblx0Y2xvbmVFbGVtZW50LFxuXHRjcmVhdGVSZWYsXG5cdEZyYWdtZW50LFxuXHRpc1ZhbGlkRWxlbWVudCxcblx0ZmluZERPTU5vZGUsXG5cdENvbXBvbmVudCxcblx0UHVyZUNvbXBvbmVudCxcblx0bWVtbyxcblx0Zm9yd2FyZFJlZixcblx0Zmx1c2hTeW5jLFxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FtZWxjYXNlXG5cdHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzLFxuXHRTdHJpY3RNb2RlLFxuXHRTdXNwZW5zZSxcblx0U3VzcGVuc2VMaXN0LFxuXHRsYXp5LFxuXHRfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRFxufTtcblxuLy8gUmVhY3QgY29waWVzIHRoZSBuYW1lZCBleHBvcnRzIHRvIHRoZSBkZWZhdWx0IG9uZS5cbmV4cG9ydCBkZWZhdWx0IHtcblx0dXNlU3RhdGUsXG5cdHVzZUlkLFxuXHR1c2VSZWR1Y2VyLFxuXHR1c2VFZmZlY3QsXG5cdHVzZUxheW91dEVmZmVjdCxcblx0dXNlSW5zZXJ0aW9uRWZmZWN0LFxuXHR1c2VUcmFuc2l0aW9uLFxuXHR1c2VEZWZlcnJlZFZhbHVlLFxuXHR1c2VTeW5jRXh0ZXJuYWxTdG9yZSxcblx0c3RhcnRUcmFuc2l0aW9uLFxuXHR1c2VSZWYsXG5cdHVzZUltcGVyYXRpdmVIYW5kbGUsXG5cdHVzZU1lbW8sXG5cdHVzZUNhbGxiYWNrLFxuXHR1c2VDb250ZXh0LFxuXHR1c2VEZWJ1Z1ZhbHVlLFxuXHR2ZXJzaW9uLFxuXHRDaGlsZHJlbixcblx0cmVuZGVyLFxuXHRoeWRyYXRlLFxuXHR1bm1vdW50Q29tcG9uZW50QXROb2RlLFxuXHRjcmVhdGVQb3J0YWwsXG5cdGNyZWF0ZUVsZW1lbnQsXG5cdGNyZWF0ZUNvbnRleHQsXG5cdGNyZWF0ZUZhY3RvcnksXG5cdGNsb25lRWxlbWVudCxcblx0Y3JlYXRlUmVmLFxuXHRGcmFnbWVudCxcblx0aXNWYWxpZEVsZW1lbnQsXG5cdGZpbmRET01Ob2RlLFxuXHRDb21wb25lbnQsXG5cdFB1cmVDb21wb25lbnQsXG5cdG1lbW8sXG5cdGZvcndhcmRSZWYsXG5cdGZsdXNoU3luYyxcblx0dW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMsXG5cdFN0cmljdE1vZGUsXG5cdFN1c3BlbnNlLFxuXHRTdXNwZW5zZUxpc3QsXG5cdGxhenksXG5cdF9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEXG59O1xuIiwgImltcG9ydCAqIGFzIHByZWFjdCBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBjcmVhdGVFbGVtZW50LCBpc1ZhbGlkRWxlbWVudCwgRnJhZ21lbnQgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgY3JlYXRlUG9ydGFsIH0gZnJvbSAncHJlYWN0L2NvbXBhdCc7XG5cbmNvbnN0IHN0eWxlVGV4dHMgPSBbXTtcbmNvbnN0IHN0eWxlRWxzID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gaW5qZWN0U3R5bGVzKHN0eWxlVGV4dCkge1xuICAgIHN0eWxlVGV4dHMucHVzaChzdHlsZVRleHQpO1xuICAgIHN0eWxlRWxzLmZvckVhY2goKHN0eWxlRWwpID0+IHtcbiAgICAgICAgYXBwZW5kU3R5bGVzVG8oc3R5bGVFbCwgc3R5bGVUZXh0KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUVsSGFzU3R5bGVzKGVsKSB7XG4gICAgaWYgKGVsLmlzQ29ubmVjdGVkICYmIC8vIHNvbWV0aW1lcyB0cnVlIGlmIFNTUiBzeXN0ZW0gc2ltdWxhdGVzIERPTVxuICAgICAgICBlbC5nZXRSb290Tm9kZSAvLyBzb21ldGltZXMgdW5kZWZpbmVkIGlmIFNTUiBzeXN0ZW0gc2ltdWxhdGVzIERPTVxuICAgICkge1xuICAgICAgICByZWdpc3RlclN0eWxlc1Jvb3QoZWwuZ2V0Um9vdE5vZGUoKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVnaXN0ZXJTdHlsZXNSb290KHJvb3ROb2RlKSB7XG4gICAgbGV0IHN0eWxlRWwgPSBzdHlsZUVscy5nZXQocm9vdE5vZGUpO1xuICAgIGlmICghc3R5bGVFbCB8fCAhc3R5bGVFbC5pc0Nvbm5lY3RlZCkge1xuICAgICAgICBzdHlsZUVsID0gcm9vdE5vZGUucXVlcnlTZWxlY3Rvcignc3R5bGVbZGF0YS1mdWxsY2FsZW5kYXJdJyk7XG4gICAgICAgIGlmICghc3R5bGVFbCkge1xuICAgICAgICAgICAgc3R5bGVFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgICAgICBzdHlsZUVsLnNldEF0dHJpYnV0ZSgnZGF0YS1mdWxsY2FsZW5kYXInLCAnJyk7XG4gICAgICAgICAgICBjb25zdCBub25jZSA9IGdldE5vbmNlVmFsdWUoKTtcbiAgICAgICAgICAgIGlmIChub25jZSkge1xuICAgICAgICAgICAgICAgIHN0eWxlRWwubm9uY2UgPSBub25jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhcmVudEVsID0gcm9vdE5vZGUgPT09IGRvY3VtZW50ID8gZG9jdW1lbnQuaGVhZCA6IHJvb3ROb2RlO1xuICAgICAgICAgICAgY29uc3QgaW5zZXJ0QmVmb3JlID0gcm9vdE5vZGUgPT09IGRvY3VtZW50XG4gICAgICAgICAgICAgICAgPyBwYXJlbnRFbC5xdWVyeVNlbGVjdG9yKCdzY3JpcHQsbGlua1tyZWw9c3R5bGVzaGVldF0sbGlua1thcz1zdHlsZV0sc3R5bGUnKVxuICAgICAgICAgICAgICAgIDogcGFyZW50RWwuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHBhcmVudEVsLmluc2VydEJlZm9yZShzdHlsZUVsLCBpbnNlcnRCZWZvcmUpO1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlRWxzLnNldChyb290Tm9kZSwgc3R5bGVFbCk7XG4gICAgICAgIGh5ZHJhdGVTdHlsZXNSb290KHN0eWxlRWwpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGh5ZHJhdGVTdHlsZXNSb290KHN0eWxlRWwpIHtcbiAgICBmb3IgKGNvbnN0IHN0eWxlVGV4dCBvZiBzdHlsZVRleHRzKSB7XG4gICAgICAgIGFwcGVuZFN0eWxlc1RvKHN0eWxlRWwsIHN0eWxlVGV4dCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwZW5kU3R5bGVzVG8oc3R5bGVFbCwgc3R5bGVUZXh0KSB7XG4gICAgY29uc3QgeyBzaGVldCB9ID0gc3R5bGVFbDtcbiAgICBjb25zdCBydWxlQ250ID0gc2hlZXQuY3NzUnVsZXMubGVuZ3RoO1xuICAgIHN0eWxlVGV4dC5zcGxpdCgnfScpLmZvckVhY2goKHN0eWxlU3RyLCBpKSA9PiB7XG4gICAgICAgIHN0eWxlU3RyID0gc3R5bGVTdHIudHJpbSgpO1xuICAgICAgICBpZiAoc3R5bGVTdHIpIHtcbiAgICAgICAgICAgIHNoZWV0Lmluc2VydFJ1bGUoc3R5bGVTdHIgKyAnfScsIHJ1bGVDbnQgKyBpKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLy8gbm9uY2Vcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmxldCBxdWVyaWVkTm9uY2VWYWx1ZTtcbmZ1bmN0aW9uIGdldE5vbmNlVmFsdWUoKSB7XG4gICAgaWYgKHF1ZXJpZWROb25jZVZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcXVlcmllZE5vbmNlVmFsdWUgPSBxdWVyeU5vbmNlVmFsdWUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHF1ZXJpZWROb25jZVZhbHVlO1xufVxuLypcblRPRE86IGRpc2NvdXJhZ2UgbWV0YSB0YWcgYW5kIGluc3RlYWQgcHV0IG5vbmNlIGF0dHJpYnV0ZSBvbiBwbGFjZWhvbGRlciA8c3R5bGU+IHRhZ1xuKi9cbmZ1bmN0aW9uIHF1ZXJ5Tm9uY2VWYWx1ZSgpIHtcbiAgICBjb25zdCBtZXRhV2l0aE5vbmNlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPVwiY3NwLW5vbmNlXCJdJyk7XG4gICAgaWYgKG1ldGFXaXRoTm9uY2UgJiYgbWV0YVdpdGhOb25jZS5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnQnKSkge1xuICAgICAgICByZXR1cm4gbWV0YVdpdGhOb25jZS5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnKTtcbiAgICB9XG4gICAgY29uc3QgZWxXaXRoTm9uY2UgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzY3JpcHRbbm9uY2VdJyk7XG4gICAgaWYgKGVsV2l0aE5vbmNlKSB7XG4gICAgICAgIHJldHVybiBlbFdpdGhOb25jZS5ub25jZSB8fCAnJztcbiAgICB9XG4gICAgcmV0dXJuICcnO1xufVxuLy8gbWFpblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZWdpc3RlclN0eWxlc1Jvb3QoZG9jdW1lbnQpO1xufVxuXG52YXIgY3NzXzI0OHogPSBcIjpyb290ey0tZmMtc21hbGwtZm9udC1zaXplOi44NWVtOy0tZmMtcGFnZS1iZy1jb2xvcjojZmZmOy0tZmMtbmV1dHJhbC1iZy1jb2xvcjpoc2xhKDAsMCUsODIlLC4zKTstLWZjLW5ldXRyYWwtdGV4dC1jb2xvcjpncmV5Oy0tZmMtYm9yZGVyLWNvbG9yOiNkZGQ7LS1mYy1idXR0b24tdGV4dC1jb2xvcjojZmZmOy0tZmMtYnV0dG9uLWJnLWNvbG9yOiMyYzNlNTA7LS1mYy1idXR0b24tYm9yZGVyLWNvbG9yOiMyYzNlNTA7LS1mYy1idXR0b24taG92ZXItYmctY29sb3I6IzFlMmIzNzstLWZjLWJ1dHRvbi1ob3Zlci1ib3JkZXItY29sb3I6IzFhMjUyZjstLWZjLWJ1dHRvbi1hY3RpdmUtYmctY29sb3I6IzFhMjUyZjstLWZjLWJ1dHRvbi1hY3RpdmUtYm9yZGVyLWNvbG9yOiMxNTFlMjc7LS1mYy1ldmVudC1iZy1jb2xvcjojMzc4OGQ4Oy0tZmMtZXZlbnQtYm9yZGVyLWNvbG9yOiMzNzg4ZDg7LS1mYy1ldmVudC10ZXh0LWNvbG9yOiNmZmY7LS1mYy1ldmVudC1zZWxlY3RlZC1vdmVybGF5LWNvbG9yOnJnYmEoMCwwLDAsLjI1KTstLWZjLW1vcmUtbGluay1iZy1jb2xvcjojZDBkMGQwOy0tZmMtbW9yZS1saW5rLXRleHQtY29sb3I6aW5oZXJpdDstLWZjLWV2ZW50LXJlc2l6ZXItdGhpY2tuZXNzOjhweDstLWZjLWV2ZW50LXJlc2l6ZXItZG90LXRvdGFsLXdpZHRoOjhweDstLWZjLWV2ZW50LXJlc2l6ZXItZG90LWJvcmRlci13aWR0aDoxcHg7LS1mYy1ub24tYnVzaW5lc3MtY29sb3I6aHNsYSgwLDAlLDg0JSwuMyk7LS1mYy1iZy1ldmVudC1jb2xvcjojOGZkZjgyOy0tZmMtYmctZXZlbnQtb3BhY2l0eTowLjM7LS1mYy1oaWdobGlnaHQtY29sb3I6cmdiYSgxODgsMjMyLDI0MSwuMyk7LS1mYy10b2RheS1iZy1jb2xvcjpyZ2JhKDI1NSwyMjAsNDAsLjE1KTstLWZjLW5vdy1pbmRpY2F0b3ItY29sb3I6cmVkfS5mYy1ub3QtYWxsb3dlZCwuZmMtbm90LWFsbG93ZWQgLmZjLWV2ZW50e2N1cnNvcjpub3QtYWxsb3dlZH0uZmN7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjtmb250LXNpemU6MWVtfS5mYywuZmMgKiwuZmMgOmFmdGVyLC5mYyA6YmVmb3Jle2JveC1zaXppbmc6Ym9yZGVyLWJveH0uZmMgdGFibGV7Ym9yZGVyLWNvbGxhcHNlOmNvbGxhcHNlO2JvcmRlci1zcGFjaW5nOjA7Zm9udC1zaXplOjFlbX0uZmMgdGh7dGV4dC1hbGlnbjpjZW50ZXJ9LmZjIHRkLC5mYyB0aHtwYWRkaW5nOjA7dmVydGljYWwtYWxpZ246dG9wfS5mYyBhW2RhdGEtbmF2bGlua117Y3Vyc29yOnBvaW50ZXJ9LmZjIGFbZGF0YS1uYXZsaW5rXTpob3Zlcnt0ZXh0LWRlY29yYXRpb246dW5kZXJsaW5lfS5mYy1kaXJlY3Rpb24tbHRye2RpcmVjdGlvbjpsdHI7dGV4dC1hbGlnbjpsZWZ0fS5mYy1kaXJlY3Rpb24tcnRse2RpcmVjdGlvbjpydGw7dGV4dC1hbGlnbjpyaWdodH0uZmMtdGhlbWUtc3RhbmRhcmQgdGQsLmZjLXRoZW1lLXN0YW5kYXJkIHRoe2JvcmRlcjoxcHggc29saWQgdmFyKC0tZmMtYm9yZGVyLWNvbG9yKX0uZmMtbGlxdWlkLWhhY2sgdGQsLmZjLWxpcXVpZC1oYWNrIHRoe3Bvc2l0aW9uOnJlbGF0aXZlfUBmb250LWZhY2V7Zm9udC1mYW1pbHk6ZmNpY29ucztmb250LXN0eWxlOm5vcm1hbDtmb250LXdlaWdodDo0MDA7c3JjOnVybChcXFwiZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtdHRmO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LEFBRUFBQUFMQUlBQUF3QXdUMU12TWc4U0JmQUFBQUM4QUFBQVlHTnRZWEFYVnRLTkFBQUJIQUFBQUZSbllYTndBQUFBRUFBQUFYQUFBQUFJWjJ4NVpnWXlkeElBQUFGNEFBQUZOR2hsWVdRVUo3Y0lBQUFHckFBQUFEWm9hR1ZoQjIwRHpBQUFCdVFBQUFBa2FHMTBlQ0lBQmhRQUFBY0lBQUFBTEd4dlkyRUQ0QVU2QUFBSE5BQUFBQmh0WVhod0FBOEFqQUFBQjB3QUFBQWdibUZ0WlhzcjY5MEFBQWRzQUFBQmhuQnZjM1FBQXdBQUFBQUk5QUFBQUNBQUF3UEFBWkFBQlFBQUFwa0N6QUFBQUk4Q21RTE1BQUFCNndBekFRa0FBQUFBQUFBQUFBQUFBQUFBQUFBQkVBQUFBQUFBQUFBQUFBQUFBQUFBQUFCQUFBRHBCZ1BBLzhBQVFBUEFBRUFBQUFBQkFBQUFBQUFBQUFBQUFBQWdBQUFBQUFBREFBQUFBd0FBQUJ3QUFRQURBQUFBSEFBREFBRUFBQUFjQUFRQU9BQUFBQW9BQ0FBQ0FBSUFBUUFnNlFiLy9mLy9BQUFBQUFBZzZRRC8vZi8vQUFILzR4Y0VBQU1BQVFBQUFBQUFBQUFBQUFBQUFRQUIvLzhBRHdBQkFBQUFBQUFBQUFBQUFnQUFOemtCQUFBQUFBRUFBQUFBQUFBQUFBQUNBQUEzT1FFQUFBQUFBUUFBQUFBQUFBQUFBQUlBQURjNUFRQUFBQUFCQVdJQWpRS2VBc2tBRXdBQUpTYzNOalFuSmlJSEFRWVVGd0VXTWpjMk5DY0NudUxpRFEwTUpBei9BQTBOQVFBTUpBd05EY25pNGd3akRRd00vd0FOSXd6L0FBME5EQ01OQUFBQUFRRmlBSTBDbmdMSkFCTUFBQ1VCTmpRbkFTWWlCd1lVSHdFSEJoUVhGakkzQVo0QkFBME4vd0FNSkF3TkRlTGlEUTBNSkF5TkFRQU1JdzBCQUF3TURTTU00dUlOSXd3TkRRQUFBQUlBNGdDM0F4NENuZ0FUQUNjQUFDVW5OelkwSnlZaUR3RUdGQjhCRmpJM05qUW5JU2MzTmpRbkppSVBBUVlVSHdFV01qYzJOQ2NCODdlM0RRME1JdzNWRFEzVkRTTU1EUTBCSzdlM0RRME1KQXpWRFEzVkRDUU1EUTN6dUxjTUpBd05EZFVOSXd6V0RBd05Jd3k0dHd3a0RBME4xUTBqRE5ZTURBMGpEQUFBQWdEaUFMY0RIZ0tlQUJNQUp3QUFKVGMyTkM4QkppSUhCaFFmQVFjR0ZCY1dNamNoTnpZMEx3RW1JZ2NHRkI4QkJ3WVVGeFl5TndKSjFRME4xUTBqREEwTnQ3Y05EUXdqRGY3VjFRME4xUXdrREEwTnQ3Y05EUXdrRExmV0RDTU4xUTBORENRTXQ3Z01JdzBNRE5ZTUl3M1ZEUTBNSkF5M3VBd2pEUXdNQUFBREFGVUFBQU9yQTFVQU13Qm9BSGNBQUJNaUJnY09BUWNPQVFjT0FSVVJGQllYSGdFWEhnRVhIZ0V6SVRJMk56NEJOejRCTno0Qk5SRTBKaWN1QVNjdUFTY3VBU01GSVRJV0Z4NEJGeDRCRng0QkZSRVVCZ2NPQVFjT0FRY09BU01oSWlZbkxnRW5MZ0VuTGdFMUVUUTJOejRCTno0Qk56NEJNeE1oTWpZMU5DWWpJU0lHRlJRV005VU5HQXdMRlFrSkRnVUZCUVVGQlE0SkNSVUxEQmdOQWxZTkdBd0xGUWtKRGdVRkJRVUZCUTRKQ1JVTERCZ04vYW9DVmdRSUJBUUhBd01GQVFJQkFRSUJCUU1EQndRRUNBVDlxZ1FJQkFRSEF3TUZBUUlCQVFJQkJRTURCd1FFQ0FTQUFWWVJHUmtSL3FvUkdSa1JBMVVGQkFVT0NRa1ZEQXNaRGYyckRSa0xEQlVKQ0E0RkJRVUZCUVVPQ1FnVkRBc1pEUUpWRFJrTERCVUpDUTRGQkFWVkFnRUNCUU1DQndRRUNBWDlxd1FKQXdRSEF3TUZBUUlDQWdJQkJRTURCd1FEQ1FRQ1ZRVUlCQVFIQWdNRkFnRUMvb0FaRWhFWkdSRVNHUUFBQUFBREFGVUFBQU9yQTFVQU13Qm9BSWtBQUJNaUJnY09BUWNPQVFjT0FSVVJGQllYSGdFWEhnRVhIZ0V6SVRJMk56NEJOejRCTno0Qk5SRTBKaWN1QVNjdUFTY3VBU01GSVRJV0Z4NEJGeDRCRng0QkZSRVVCZ2NPQVFjT0FRY09BU01oSWlZbkxnRW5MZ0VuTGdFMUVUUTJOejRCTno0Qk56NEJNeE16RlJRV016STJQUUV6TWpZMU5DWXJBVFUwSmlNaUJoMEJJeUlHRlJRV005VU5HQXdMRlFrSkRnVUZCUVVGQlE0SkNSVUxEQmdOQWxZTkdBd0xGUWtKRGdVRkJRVUZCUTRKQ1JVTERCZ04vYW9DVmdRSUJBUUhBd01GQVFJQkFRSUJCUU1EQndRRUNBVDlxZ1FJQkFRSEF3TUZBUUlCQVFJQkJRTURCd1FFQ0FTQWdCa1NFaG1BRVJrWkVZQVpFaElaZ0JFWkdSRURWUVVFQlE0SkNSVU1DeGtOL2FzTkdRc01GUWtJRGdVRkJRVUZCUTRKQ0JVTUN4a05BbFVOR1FzTUZRa0pEZ1VFQlZVQ0FRSUZBd0lIQkFRSUJmMnJCQWtEQkFjREF3VUJBZ0lDQWdFRkF3TUhCQU1KQkFKVkJRZ0VCQWNDQXdVQ0FRTCtnSUFTR1JrU2dCa1NFUm1BRWhrWkVvQVpFUklaQUFBQkFPSUFqUU1lQXNrQUlBQUFFeGNIQmhRWEZqSS9BUmNXTWpjMk5DOEJOelkwSnlZaUR3RW5KaUlIQmhRWDR1TGlEUTBNSkF6aTRnd2tEQTBONHVJTkRRd2tET0xpRENRTURRMENqZUxpRFNNTURRM2g0UTBORENNTjR1SU1JdzBNRE9MaURBd05Jd3dBQUFBQkFBQUFBUUFBYTVuMHkxOFBQUFVBQ3dRQUFBQUFBTml2T1ZzQUFBQUEySzg1V3dBQUFBQURxd05WQUFBQUNBQUNBQUFBQUFBQUFBRUFBQVBBLzhBQUFBUUFBQUFBQUFPckFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBTEJBQUFBQUFBQUFBQUFBQUFBZ0FBQUFRQUFXSUVBQUZpQkFBQTRnUUFBT0lFQUFCVkJBQUFWUVFBQU9JQUFBQUFBQW9BRkFBZUFFUUFhZ0NxQU9vQm5nSmtBcG9BQVFBQUFBc0FpZ0FEQUFBQUFBQUNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQTRBcmdBQkFBQUFBQUFCQUFjQUFBQUJBQUFBQUFBQ0FBY0FZQUFCQUFBQUFBQURBQWNBTmdBQkFBQUFBQUFFQUFjQWRRQUJBQUFBQUFBRkFBc0FGUUFCQUFBQUFBQUdBQWNBU3dBQkFBQUFBQUFLQUJvQWlnQURBQUVFQ1FBQkFBNEFCd0FEQUFFRUNRQUNBQTRBWndBREFBRUVDUUFEQUE0QVBRQURBQUVFQ1FBRUFBNEFmQUFEQUFFRUNRQUZBQllBSUFBREFBRUVDUUFHQUE0QVVnQURBQUVFQ1FBS0FEUUFwR1pqYVdOdmJuTUFaZ0JqQUdrQVl3QnZBRzRBYzFabGNuTnBiMjRnTVM0d0FGWUFaUUJ5QUhNQWFRQnZBRzRBSUFBeEFDNEFNR1pqYVdOdmJuTUFaZ0JqQUdrQVl3QnZBRzRBYzJaamFXTnZibk1BWmdCakFHa0FZd0J2QUc0QWMxSmxaM1ZzWVhJQVVnQmxBR2NBZFFCc0FHRUFjbVpqYVdOdmJuTUFaZ0JqQUdrQVl3QnZBRzRBYzBadmJuUWdaMlZ1WlhKaGRHVmtJR0o1SUVsamIwMXZiMjR1QUVZQWJ3QnVBSFFBSUFCbkFHVUFiZ0JsQUhJQVlRQjBBR1VBWkFBZ0FHSUFlUUFnQUVrQVl3QnZBRTBBYndCdkFHNEFMZ0FBQUFNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQT1cXFwiKSBmb3JtYXQoXFxcInRydWV0eXBlXFxcIil9LmZjLWljb257c3BlYWs6bm9uZTstd2Via2l0LWZvbnQtc21vb3RoaW5nOmFudGlhbGlhc2VkOy1tb3otb3N4LWZvbnQtc21vb3RoaW5nOmdyYXlzY2FsZTtkaXNwbGF5OmlubGluZS1ibG9jaztmb250LWZhbWlseTpmY2ljb25zIWltcG9ydGFudDtmb250LXN0eWxlOm5vcm1hbDtmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0OjQwMDtoZWlnaHQ6MWVtO2xpbmUtaGVpZ2h0OjE7dGV4dC1hbGlnbjpjZW50ZXI7dGV4dC10cmFuc2Zvcm06bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZTt3aWR0aDoxZW19LmZjLWljb24tY2hldnJvbi1sZWZ0OmJlZm9yZXtjb250ZW50OlxcXCJcXFxcZTkwMFxcXCJ9LmZjLWljb24tY2hldnJvbi1yaWdodDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXGU5MDFcXFwifS5mYy1pY29uLWNoZXZyb25zLWxlZnQ6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxlOTAyXFxcIn0uZmMtaWNvbi1jaGV2cm9ucy1yaWdodDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXGU5MDNcXFwifS5mYy1pY29uLW1pbnVzLXNxdWFyZTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXGU5MDRcXFwifS5mYy1pY29uLXBsdXMtc3F1YXJlOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcZTkwNVxcXCJ9LmZjLWljb24teDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXGU5MDZcXFwifS5mYyAuZmMtYnV0dG9ue2JvcmRlci1yYWRpdXM6MDtmb250LWZhbWlseTppbmhlcml0O2ZvbnQtc2l6ZTppbmhlcml0O2xpbmUtaGVpZ2h0OmluaGVyaXQ7bWFyZ2luOjA7b3ZlcmZsb3c6dmlzaWJsZTt0ZXh0LXRyYW5zZm9ybTpub25lfS5mYyAuZmMtYnV0dG9uOmZvY3Vze291dGxpbmU6MXB4IGRvdHRlZDtvdXRsaW5lOjVweCBhdXRvIC13ZWJraXQtZm9jdXMtcmluZy1jb2xvcn0uZmMgLmZjLWJ1dHRvbnstd2Via2l0LWFwcGVhcmFuY2U6YnV0dG9ufS5mYyAuZmMtYnV0dG9uOm5vdCg6ZGlzYWJsZWQpe2N1cnNvcjpwb2ludGVyfS5mYyAuZmMtYnV0dG9ue2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnQ7Ym9yZGVyOjFweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItcmFkaXVzOi4yNWVtO2Rpc3BsYXk6aW5saW5lLWJsb2NrO2ZvbnQtc2l6ZToxZW07Zm9udC13ZWlnaHQ6NDAwO2xpbmUtaGVpZ2h0OjEuNTtwYWRkaW5nOi40ZW0gLjY1ZW07dGV4dC1hbGlnbjpjZW50ZXI7LW1vei11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmU7dmVydGljYWwtYWxpZ246bWlkZGxlfS5mYyAuZmMtYnV0dG9uOmhvdmVye3RleHQtZGVjb3JhdGlvbjpub25lfS5mYyAuZmMtYnV0dG9uOmZvY3Vze2JveC1zaGFkb3c6MCAwIDAgLjJyZW0gcmdiYSg0NCw2Miw4MCwuMjUpO291dGxpbmU6MH0uZmMgLmZjLWJ1dHRvbjpkaXNhYmxlZHtvcGFjaXR5Oi42NX0uZmMgLmZjLWJ1dHRvbi1wcmltYXJ5e2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmMtYnV0dG9uLWJnLWNvbG9yKTtib3JkZXItY29sb3I6dmFyKC0tZmMtYnV0dG9uLWJvcmRlci1jb2xvcik7Y29sb3I6dmFyKC0tZmMtYnV0dG9uLXRleHQtY29sb3IpfS5mYyAuZmMtYnV0dG9uLXByaW1hcnk6aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1mYy1idXR0b24taG92ZXItYmctY29sb3IpO2JvcmRlci1jb2xvcjp2YXIoLS1mYy1idXR0b24taG92ZXItYm9yZGVyLWNvbG9yKTtjb2xvcjp2YXIoLS1mYy1idXR0b24tdGV4dC1jb2xvcil9LmZjIC5mYy1idXR0b24tcHJpbWFyeTpkaXNhYmxlZHtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWZjLWJ1dHRvbi1iZy1jb2xvcik7Ym9yZGVyLWNvbG9yOnZhcigtLWZjLWJ1dHRvbi1ib3JkZXItY29sb3IpO2NvbG9yOnZhcigtLWZjLWJ1dHRvbi10ZXh0LWNvbG9yKX0uZmMgLmZjLWJ1dHRvbi1wcmltYXJ5OmZvY3Vze2JveC1zaGFkb3c6MCAwIDAgLjJyZW0gcmdiYSg3Niw5MSwxMDYsLjUpfS5mYyAuZmMtYnV0dG9uLXByaW1hcnk6bm90KDpkaXNhYmxlZCkuZmMtYnV0dG9uLWFjdGl2ZSwuZmMgLmZjLWJ1dHRvbi1wcmltYXJ5Om5vdCg6ZGlzYWJsZWQpOmFjdGl2ZXtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWZjLWJ1dHRvbi1hY3RpdmUtYmctY29sb3IpO2JvcmRlci1jb2xvcjp2YXIoLS1mYy1idXR0b24tYWN0aXZlLWJvcmRlci1jb2xvcik7Y29sb3I6dmFyKC0tZmMtYnV0dG9uLXRleHQtY29sb3IpfS5mYyAuZmMtYnV0dG9uLXByaW1hcnk6bm90KDpkaXNhYmxlZCkuZmMtYnV0dG9uLWFjdGl2ZTpmb2N1cywuZmMgLmZjLWJ1dHRvbi1wcmltYXJ5Om5vdCg6ZGlzYWJsZWQpOmFjdGl2ZTpmb2N1c3tib3gtc2hhZG93OjAgMCAwIC4ycmVtIHJnYmEoNzYsOTEsMTA2LC41KX0uZmMgLmZjLWJ1dHRvbiAuZmMtaWNvbntmb250LXNpemU6MS41ZW07dmVydGljYWwtYWxpZ246bWlkZGxlfS5mYyAuZmMtYnV0dG9uLWdyb3Vwe2Rpc3BsYXk6aW5saW5lLWZsZXg7cG9zaXRpb246cmVsYXRpdmU7dmVydGljYWwtYWxpZ246bWlkZGxlfS5mYyAuZmMtYnV0dG9uLWdyb3VwPi5mYy1idXR0b257ZmxleDoxIDEgYXV0bztwb3NpdGlvbjpyZWxhdGl2ZX0uZmMgLmZjLWJ1dHRvbi1ncm91cD4uZmMtYnV0dG9uLmZjLWJ1dHRvbi1hY3RpdmUsLmZjIC5mYy1idXR0b24tZ3JvdXA+LmZjLWJ1dHRvbjphY3RpdmUsLmZjIC5mYy1idXR0b24tZ3JvdXA+LmZjLWJ1dHRvbjpmb2N1cywuZmMgLmZjLWJ1dHRvbi1ncm91cD4uZmMtYnV0dG9uOmhvdmVye3otaW5kZXg6MX0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtYnV0dG9uLWdyb3VwPi5mYy1idXR0b246bm90KDpmaXJzdC1jaGlsZCl7Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czowO2JvcmRlci10b3AtbGVmdC1yYWRpdXM6MDttYXJnaW4tbGVmdDotMXB4fS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1idXR0b24tZ3JvdXA+LmZjLWJ1dHRvbjpub3QoOmxhc3QtY2hpbGQpe2JvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOjA7Ym9yZGVyLXRvcC1yaWdodC1yYWRpdXM6MH0uZmMtZGlyZWN0aW9uLXJ0bCAuZmMtYnV0dG9uLWdyb3VwPi5mYy1idXR0b246bm90KDpmaXJzdC1jaGlsZCl7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6MDtib3JkZXItdG9wLXJpZ2h0LXJhZGl1czowO21hcmdpbi1yaWdodDotMXB4fS5mYy1kaXJlY3Rpb24tcnRsIC5mYy1idXR0b24tZ3JvdXA+LmZjLWJ1dHRvbjpub3QoOmxhc3QtY2hpbGQpe2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6MDtib3JkZXItdG9wLWxlZnQtcmFkaXVzOjB9LmZjIC5mYy10b29sYmFye2FsaWduLWl0ZW1zOmNlbnRlcjtkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW59LmZjIC5mYy10b29sYmFyLmZjLWhlYWRlci10b29sYmFye21hcmdpbi1ib3R0b206MS41ZW19LmZjIC5mYy10b29sYmFyLmZjLWZvb3Rlci10b29sYmFye21hcmdpbi10b3A6MS41ZW19LmZjIC5mYy10b29sYmFyLXRpdGxle2ZvbnQtc2l6ZToxLjc1ZW07bWFyZ2luOjB9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLXRvb2xiYXI+Kj46bm90KDpmaXJzdC1jaGlsZCl7bWFyZ2luLWxlZnQ6Ljc1ZW19LmZjLWRpcmVjdGlvbi1ydGwgLmZjLXRvb2xiYXI+Kj46bm90KDpmaXJzdC1jaGlsZCl7bWFyZ2luLXJpZ2h0Oi43NWVtfS5mYy1kaXJlY3Rpb24tcnRsIC5mYy10b29sYmFyLWx0cntmbGV4LWRpcmVjdGlvbjpyb3ctcmV2ZXJzZX0uZmMgLmZjLXNjcm9sbGVyey13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOnRvdWNoO3Bvc2l0aW9uOnJlbGF0aXZlfS5mYyAuZmMtc2Nyb2xsZXItbGlxdWlke2hlaWdodDoxMDAlfS5mYyAuZmMtc2Nyb2xsZXItbGlxdWlkLWFic29sdXRle2JvdHRvbTowO2xlZnQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO3RvcDowfS5mYyAuZmMtc2Nyb2xsZXItaGFybmVzc3tkaXJlY3Rpb246bHRyO292ZXJmbG93OmhpZGRlbjtwb3NpdGlvbjpyZWxhdGl2ZX0uZmMgLmZjLXNjcm9sbGVyLWhhcm5lc3MtbGlxdWlke2hlaWdodDoxMDAlfS5mYy1kaXJlY3Rpb24tcnRsIC5mYy1zY3JvbGxlci1oYXJuZXNzPi5mYy1zY3JvbGxlcntkaXJlY3Rpb246cnRsfS5mYy10aGVtZS1zdGFuZGFyZCAuZmMtc2Nyb2xsZ3JpZHtib3JkZXI6MXB4IHNvbGlkIHZhcigtLWZjLWJvcmRlci1jb2xvcil9LmZjIC5mYy1zY3JvbGxncmlkLC5mYyAuZmMtc2Nyb2xsZ3JpZCB0YWJsZXt0YWJsZS1sYXlvdXQ6Zml4ZWQ7d2lkdGg6MTAwJX0uZmMgLmZjLXNjcm9sbGdyaWQgdGFibGV7Ym9yZGVyLWxlZnQtc3R5bGU6aGlkZGVuO2JvcmRlci1yaWdodC1zdHlsZTpoaWRkZW47Ym9yZGVyLXRvcC1zdHlsZTpoaWRkZW59LmZjIC5mYy1zY3JvbGxncmlke2JvcmRlci1ib3R0b20td2lkdGg6MDtib3JkZXItY29sbGFwc2U6c2VwYXJhdGU7Ym9yZGVyLXJpZ2h0LXdpZHRoOjB9LmZjIC5mYy1zY3JvbGxncmlkLWxpcXVpZHtoZWlnaHQ6MTAwJX0uZmMgLmZjLXNjcm9sbGdyaWQtc2VjdGlvbiwuZmMgLmZjLXNjcm9sbGdyaWQtc2VjdGlvbiB0YWJsZSwuZmMgLmZjLXNjcm9sbGdyaWQtc2VjdGlvbj50ZHtoZWlnaHQ6MXB4fS5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLWxpcXVpZD50ZHtoZWlnaHQ6MTAwJX0uZmMgLmZjLXNjcm9sbGdyaWQtc2VjdGlvbj4qe2JvcmRlci1sZWZ0LXdpZHRoOjA7Ym9yZGVyLXRvcC13aWR0aDowfS5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLWZvb3Rlcj4qLC5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLWhlYWRlcj4qe2JvcmRlci1ib3R0b20td2lkdGg6MH0uZmMgLmZjLXNjcm9sbGdyaWQtc2VjdGlvbi1ib2R5IHRhYmxlLC5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLWZvb3RlciB0YWJsZXtib3JkZXItYm90dG9tLXN0eWxlOmhpZGRlbn0uZmMgLmZjLXNjcm9sbGdyaWQtc2VjdGlvbi1zdGlja3k+KntiYWNrZ3JvdW5kOnZhcigtLWZjLXBhZ2UtYmctY29sb3IpO3Bvc2l0aW9uOnN0aWNreTt6LWluZGV4OjN9LmZjIC5mYy1zY3JvbGxncmlkLXNlY3Rpb24taGVhZGVyLmZjLXNjcm9sbGdyaWQtc2VjdGlvbi1zdGlja3k+Knt0b3A6MH0uZmMgLmZjLXNjcm9sbGdyaWQtc2VjdGlvbi1mb290ZXIuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLXN0aWNreT4qe2JvdHRvbTowfS5mYyAuZmMtc2Nyb2xsZ3JpZC1zdGlja3ktc2hpbXtoZWlnaHQ6MXB4O21hcmdpbi1ib3R0b206LTFweH0uZmMtc3RpY2t5e3Bvc2l0aW9uOnN0aWNreX0uZmMgLmZjLXZpZXctaGFybmVzc3tmbGV4LWdyb3c6MTtwb3NpdGlvbjpyZWxhdGl2ZX0uZmMgLmZjLXZpZXctaGFybmVzcy1hY3RpdmU+LmZjLXZpZXd7Ym90dG9tOjA7bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7dG9wOjB9LmZjIC5mYy1jb2wtaGVhZGVyLWNlbGwtY3VzaGlvbntkaXNwbGF5OmlubGluZS1ibG9jaztwYWRkaW5nOjJweCA0cHh9LmZjIC5mYy1iZy1ldmVudCwuZmMgLmZjLWhpZ2hsaWdodCwuZmMgLmZjLW5vbi1idXNpbmVzc3tib3R0b206MDtsZWZ0OjA7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MDt0b3A6MH0uZmMgLmZjLW5vbi1idXNpbmVzc3tiYWNrZ3JvdW5kOnZhcigtLWZjLW5vbi1idXNpbmVzcy1jb2xvcil9LmZjIC5mYy1iZy1ldmVudHtiYWNrZ3JvdW5kOnZhcigtLWZjLWJnLWV2ZW50LWNvbG9yKTtvcGFjaXR5OnZhcigtLWZjLWJnLWV2ZW50LW9wYWNpdHkpfS5mYyAuZmMtYmctZXZlbnQgLmZjLWV2ZW50LXRpdGxle2ZvbnQtc2l6ZTp2YXIoLS1mYy1zbWFsbC1mb250LXNpemUpO2ZvbnQtc3R5bGU6aXRhbGljO21hcmdpbjouNWVtfS5mYyAuZmMtaGlnaGxpZ2h0e2JhY2tncm91bmQ6dmFyKC0tZmMtaGlnaGxpZ2h0LWNvbG9yKX0uZmMgLmZjLWNlbGwtc2hhZGVkLC5mYyAuZmMtZGF5LWRpc2FibGVke2JhY2tncm91bmQ6dmFyKC0tZmMtbmV1dHJhbC1iZy1jb2xvcil9YS5mYy1ldmVudCxhLmZjLWV2ZW50OmhvdmVye3RleHQtZGVjb3JhdGlvbjpub25lfS5mYy1ldmVudC5mYy1ldmVudC1kcmFnZ2FibGUsLmZjLWV2ZW50W2hyZWZde2N1cnNvcjpwb2ludGVyfS5mYy1ldmVudCAuZmMtZXZlbnQtbWFpbntwb3NpdGlvbjpyZWxhdGl2ZTt6LWluZGV4OjJ9LmZjLWV2ZW50LWRyYWdnaW5nOm5vdCguZmMtZXZlbnQtc2VsZWN0ZWQpe29wYWNpdHk6Ljc1fS5mYy1ldmVudC1kcmFnZ2luZy5mYy1ldmVudC1zZWxlY3RlZHtib3gtc2hhZG93OjAgMnB4IDdweCByZ2JhKDAsMCwwLC4zKX0uZmMtZXZlbnQgLmZjLWV2ZW50LXJlc2l6ZXJ7ZGlzcGxheTpub25lO3Bvc2l0aW9uOmFic29sdXRlO3otaW5kZXg6NH0uZmMtZXZlbnQtc2VsZWN0ZWQgLmZjLWV2ZW50LXJlc2l6ZXIsLmZjLWV2ZW50OmhvdmVyIC5mYy1ldmVudC1yZXNpemVye2Rpc3BsYXk6YmxvY2t9LmZjLWV2ZW50LXNlbGVjdGVkIC5mYy1ldmVudC1yZXNpemVye2JhY2tncm91bmQ6dmFyKC0tZmMtcGFnZS1iZy1jb2xvcik7Ym9yZGVyLWNvbG9yOmluaGVyaXQ7Ym9yZGVyLXJhZGl1czpjYWxjKHZhcigtLWZjLWV2ZW50LXJlc2l6ZXItZG90LXRvdGFsLXdpZHRoKS8yKTtib3JkZXItc3R5bGU6c29saWQ7Ym9yZGVyLXdpZHRoOnZhcigtLWZjLWV2ZW50LXJlc2l6ZXItZG90LWJvcmRlci13aWR0aCk7aGVpZ2h0OnZhcigtLWZjLWV2ZW50LXJlc2l6ZXItZG90LXRvdGFsLXdpZHRoKTt3aWR0aDp2YXIoLS1mYy1ldmVudC1yZXNpemVyLWRvdC10b3RhbC13aWR0aCl9LmZjLWV2ZW50LXNlbGVjdGVkIC5mYy1ldmVudC1yZXNpemVyOmJlZm9yZXtib3R0b206LTIwcHg7Y29udGVudDpcXFwiXFxcIjtsZWZ0Oi0yMHB4O3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0Oi0yMHB4O3RvcDotMjBweH0uZmMtZXZlbnQtc2VsZWN0ZWQsLmZjLWV2ZW50OmZvY3Vze2JveC1zaGFkb3c6MCAycHggNXB4IHJnYmEoMCwwLDAsLjIpfS5mYy1ldmVudC1zZWxlY3RlZDpiZWZvcmUsLmZjLWV2ZW50OmZvY3VzOmJlZm9yZXtib3R0b206MDtjb250ZW50OlxcXCJcXFwiO2xlZnQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO3RvcDowO3otaW5kZXg6M30uZmMtZXZlbnQtc2VsZWN0ZWQ6YWZ0ZXIsLmZjLWV2ZW50OmZvY3VzOmFmdGVye2JhY2tncm91bmQ6dmFyKC0tZmMtZXZlbnQtc2VsZWN0ZWQtb3ZlcmxheS1jb2xvcik7Ym90dG9tOi0xcHg7Y29udGVudDpcXFwiXFxcIjtsZWZ0Oi0xcHg7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6LTFweDt0b3A6LTFweDt6LWluZGV4OjF9LmZjLWgtZXZlbnR7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1mYy1ldmVudC1iZy1jb2xvcik7Ym9yZGVyOjFweCBzb2xpZCB2YXIoLS1mYy1ldmVudC1ib3JkZXItY29sb3IpO2Rpc3BsYXk6YmxvY2t9LmZjLWgtZXZlbnQgLmZjLWV2ZW50LW1haW57Y29sb3I6dmFyKC0tZmMtZXZlbnQtdGV4dC1jb2xvcil9LmZjLWgtZXZlbnQgLmZjLWV2ZW50LW1haW4tZnJhbWV7ZGlzcGxheTpmbGV4fS5mYy1oLWV2ZW50IC5mYy1ldmVudC10aW1le21heC13aWR0aDoxMDAlO292ZXJmbG93OmhpZGRlbn0uZmMtaC1ldmVudCAuZmMtZXZlbnQtdGl0bGUtY29udGFpbmVye2ZsZXgtZ3JvdzoxO2ZsZXgtc2hyaW5rOjE7bWluLXdpZHRoOjB9LmZjLWgtZXZlbnQgLmZjLWV2ZW50LXRpdGxle2Rpc3BsYXk6aW5saW5lLWJsb2NrO2xlZnQ6MDttYXgtd2lkdGg6MTAwJTtvdmVyZmxvdzpoaWRkZW47cmlnaHQ6MDt2ZXJ0aWNhbC1hbGlnbjp0b3B9LmZjLWgtZXZlbnQuZmMtZXZlbnQtc2VsZWN0ZWQ6YmVmb3Jle2JvdHRvbTotMTBweDt0b3A6LTEwcHh9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLWRheWdyaWQtYmxvY2stZXZlbnQ6bm90KC5mYy1ldmVudC1zdGFydCksLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWRheWdyaWQtYmxvY2stZXZlbnQ6bm90KC5mYy1ldmVudC1lbmQpe2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6MDtib3JkZXItbGVmdC13aWR0aDowO2JvcmRlci10b3AtbGVmdC1yYWRpdXM6MH0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtZGF5Z3JpZC1ibG9jay1ldmVudDpub3QoLmZjLWV2ZW50LWVuZCksLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWRheWdyaWQtYmxvY2stZXZlbnQ6bm90KC5mYy1ldmVudC1zdGFydCl7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6MDtib3JkZXItcmlnaHQtd2lkdGg6MDtib3JkZXItdG9wLXJpZ2h0LXJhZGl1czowfS5mYy1oLWV2ZW50Om5vdCguZmMtZXZlbnQtc2VsZWN0ZWQpIC5mYy1ldmVudC1yZXNpemVye2JvdHRvbTowO3RvcDowO3dpZHRoOnZhcigtLWZjLWV2ZW50LXJlc2l6ZXItdGhpY2tuZXNzKX0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtaC1ldmVudDpub3QoLmZjLWV2ZW50LXNlbGVjdGVkKSAuZmMtZXZlbnQtcmVzaXplci1zdGFydCwuZmMtZGlyZWN0aW9uLXJ0bCAuZmMtaC1ldmVudDpub3QoLmZjLWV2ZW50LXNlbGVjdGVkKSAuZmMtZXZlbnQtcmVzaXplci1lbmR7Y3Vyc29yOnctcmVzaXplO2xlZnQ6Y2FsYyh2YXIoLS1mYy1ldmVudC1yZXNpemVyLXRoaWNrbmVzcykqLS41KX0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtaC1ldmVudDpub3QoLmZjLWV2ZW50LXNlbGVjdGVkKSAuZmMtZXZlbnQtcmVzaXplci1lbmQsLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWgtZXZlbnQ6bm90KC5mYy1ldmVudC1zZWxlY3RlZCkgLmZjLWV2ZW50LXJlc2l6ZXItc3RhcnR7Y3Vyc29yOmUtcmVzaXplO3JpZ2h0OmNhbGModmFyKC0tZmMtZXZlbnQtcmVzaXplci10aGlja25lc3MpKi0uNSl9LmZjLWgtZXZlbnQuZmMtZXZlbnQtc2VsZWN0ZWQgLmZjLWV2ZW50LXJlc2l6ZXJ7bWFyZ2luLXRvcDpjYWxjKHZhcigtLWZjLWV2ZW50LXJlc2l6ZXItZG90LXRvdGFsLXdpZHRoKSotLjUpO3RvcDo1MCV9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLWgtZXZlbnQuZmMtZXZlbnQtc2VsZWN0ZWQgLmZjLWV2ZW50LXJlc2l6ZXItc3RhcnQsLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWgtZXZlbnQuZmMtZXZlbnQtc2VsZWN0ZWQgLmZjLWV2ZW50LXJlc2l6ZXItZW5ke2xlZnQ6Y2FsYyh2YXIoLS1mYy1ldmVudC1yZXNpemVyLWRvdC10b3RhbC13aWR0aCkqLS41KX0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtaC1ldmVudC5mYy1ldmVudC1zZWxlY3RlZCAuZmMtZXZlbnQtcmVzaXplci1lbmQsLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWgtZXZlbnQuZmMtZXZlbnQtc2VsZWN0ZWQgLmZjLWV2ZW50LXJlc2l6ZXItc3RhcnR7cmlnaHQ6Y2FsYyh2YXIoLS1mYy1ldmVudC1yZXNpemVyLWRvdC10b3RhbC13aWR0aCkqLS41KX0uZmMgLmZjLXBvcG92ZXJ7Ym94LXNoYWRvdzowIDJweCA2cHggcmdiYSgwLDAsMCwuMTUpO3Bvc2l0aW9uOmFic29sdXRlO3otaW5kZXg6OTk5OX0uZmMgLmZjLXBvcG92ZXItaGVhZGVye2FsaWduLWl0ZW1zOmNlbnRlcjtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246cm93O2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVuO3BhZGRpbmc6M3B4IDRweH0uZmMgLmZjLXBvcG92ZXItdGl0bGV7bWFyZ2luOjAgMnB4fS5mYyAuZmMtcG9wb3Zlci1jbG9zZXtjdXJzb3I6cG9pbnRlcjtmb250LXNpemU6MS4xZW07b3BhY2l0eTouNjV9LmZjLXRoZW1lLXN0YW5kYXJkIC5mYy1wb3BvdmVye2JhY2tncm91bmQ6dmFyKC0tZmMtcGFnZS1iZy1jb2xvcik7Ym9yZGVyOjFweCBzb2xpZCB2YXIoLS1mYy1ib3JkZXItY29sb3IpfS5mYy10aGVtZS1zdGFuZGFyZCAuZmMtcG9wb3Zlci1oZWFkZXJ7YmFja2dyb3VuZDp2YXIoLS1mYy1uZXV0cmFsLWJnLWNvbG9yKX1cIjtcbmluamVjdFN0eWxlcyhjc3NfMjQ4eik7XG5cbmNsYXNzIERlbGF5ZWRSdW5uZXIge1xuICAgIGNvbnN0cnVjdG9yKGRyYWluZWRPcHRpb24pIHtcbiAgICAgICAgdGhpcy5kcmFpbmVkT3B0aW9uID0gZHJhaW5lZE9wdGlvbjtcbiAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0RpcnR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGF1c2VEZXB0aHMgPSB7fTtcbiAgICAgICAgdGhpcy50aW1lb3V0SWQgPSAwO1xuICAgIH1cbiAgICByZXF1ZXN0KGRlbGF5KSB7XG4gICAgICAgIHRoaXMuaXNEaXJ0eSA9IHRydWU7XG4gICAgICAgIGlmICghdGhpcy5pc1BhdXNlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICAgICAgICAgICAgaWYgKGRlbGF5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyeURyYWluKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVvdXRJZCA9IHNldFRpbWVvdXQoLy8gTk9UIE9QVElNQUwhIFRPRE86IGxvb2sgYXQgZGVib3VuY2VcbiAgICAgICAgICAgICAgICB0aGlzLnRyeURyYWluLmJpbmQodGhpcyksIGRlbGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXVzZShzY29wZSA9ICcnKSB7XG4gICAgICAgIGxldCB7IHBhdXNlRGVwdGhzIH0gPSB0aGlzO1xuICAgICAgICBwYXVzZURlcHRoc1tzY29wZV0gPSAocGF1c2VEZXB0aHNbc2NvcGVdIHx8IDApICsgMTtcbiAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgICB9XG4gICAgcmVzdW1lKHNjb3BlID0gJycsIGZvcmNlKSB7XG4gICAgICAgIGxldCB7IHBhdXNlRGVwdGhzIH0gPSB0aGlzO1xuICAgICAgICBpZiAoc2NvcGUgaW4gcGF1c2VEZXB0aHMpIHtcbiAgICAgICAgICAgIGlmIChmb3JjZSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXVzZURlcHRoc1tzY29wZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXVzZURlcHRoc1tzY29wZV0gLT0gMTtcbiAgICAgICAgICAgICAgICBsZXQgZGVwdGggPSBwYXVzZURlcHRoc1tzY29wZV07XG4gICAgICAgICAgICAgICAgaWYgKGRlcHRoIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhdXNlRGVwdGhzW3Njb3BlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRyeURyYWluKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNQYXVzZWQoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnBhdXNlRGVwdGhzKS5sZW5ndGg7XG4gICAgfVxuICAgIHRyeURyYWluKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNSdW5uaW5nICYmICF0aGlzLmlzUGF1c2VkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuaXNSdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLmlzRGlydHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzRGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWluZWQoKTsgLy8gbWlnaHQgc2V0IGlzRGlydHkgdG8gdHJ1ZSBhZ2FpblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgICAgICAgdGhpcy5pc0RpcnR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGF1c2VEZXB0aHMgPSB7fTtcbiAgICB9XG4gICAgY2xlYXJUaW1lb3V0KCkge1xuICAgICAgICBpZiAodGhpcy50aW1lb3V0SWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZCk7XG4gICAgICAgICAgICB0aGlzLnRpbWVvdXRJZCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZHJhaW5lZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhaW5lZE9wdGlvbikge1xuICAgICAgICAgICAgdGhpcy5kcmFpbmVkT3B0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUVsZW1lbnQoZWwpIHtcbiAgICBpZiAoZWwucGFyZW50Tm9kZSkge1xuICAgICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICB9XG59XG4vLyBRdWVyeWluZ1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gZWxlbWVudENsb3Nlc3QoZWwsIHNlbGVjdG9yKSB7XG4gICAgaWYgKGVsLmNsb3Nlc3QpIHtcbiAgICAgICAgcmV0dXJuIGVsLmNsb3Nlc3Qoc2VsZWN0b3IpO1xuICAgICAgICAvLyByZWFsbHkgYmFkIGZhbGxiYWNrIGZvciBJRVxuICAgICAgICAvLyBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L2Nsb3Nlc3RcbiAgICB9XG4gICAgaWYgKCFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMoZWwpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBkbyB7XG4gICAgICAgIGlmIChlbGVtZW50TWF0Y2hlcyhlbCwgc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH1cbiAgICAgICAgZWwgPSAoZWwucGFyZW50RWxlbWVudCB8fCBlbC5wYXJlbnROb2RlKTtcbiAgICB9IHdoaWxlIChlbCAhPT0gbnVsbCAmJiBlbC5ub2RlVHlwZSA9PT0gMSk7XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBlbGVtZW50TWF0Y2hlcyhlbCwgc2VsZWN0b3IpIHtcbiAgICBsZXQgbWV0aG9kID0gZWwubWF0Y2hlcyB8fCBlbC5tYXRjaGVzU2VsZWN0b3IgfHwgZWwubXNNYXRjaGVzU2VsZWN0b3I7XG4gICAgcmV0dXJuIG1ldGhvZC5jYWxsKGVsLCBzZWxlY3Rvcik7XG59XG4vLyBhY2NlcHRzIG11bHRpcGxlIHN1YmplY3QgZWxzXG4vLyByZXR1cm5zIGEgcmVhbCBhcnJheS4gZ29vZCBmb3IgbWV0aG9kcyBsaWtlIGZvckVhY2hcbi8vIFRPRE86IGFjY2VwdCB0aGUgZG9jdW1lbnRcbmZ1bmN0aW9uIGZpbmRFbGVtZW50cyhjb250YWluZXIsIHNlbGVjdG9yKSB7XG4gICAgbGV0IGNvbnRhaW5lcnMgPSBjb250YWluZXIgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCA/IFtjb250YWluZXJdIDogY29udGFpbmVyO1xuICAgIGxldCBhbGxNYXRjaGVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250YWluZXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGxldCBtYXRjaGVzID0gY29udGFpbmVyc1tpXS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtYXRjaGVzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICBhbGxNYXRjaGVzLnB1c2gobWF0Y2hlc1tqXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFsbE1hdGNoZXM7XG59XG4vLyBhY2NlcHRzIG11bHRpcGxlIHN1YmplY3QgZWxzXG4vLyBvbmx5IHF1ZXJpZXMgZGlyZWN0IGNoaWxkIGVsZW1lbnRzIC8vIFRPRE86IHJlbmFtZSB0byBmaW5kRGlyZWN0Q2hpbGRyZW4hXG5mdW5jdGlvbiBmaW5kRGlyZWN0Q2hpbGRyZW4ocGFyZW50LCBzZWxlY3Rvcikge1xuICAgIGxldCBwYXJlbnRzID0gcGFyZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgPyBbcGFyZW50XSA6IHBhcmVudDtcbiAgICBsZXQgYWxsTWF0Y2hlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBsZXQgY2hpbGROb2RlcyA9IHBhcmVudHNbaV0uY2hpbGRyZW47IC8vIG9ubHkgZXZlciBlbGVtZW50c1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNoaWxkTm9kZXMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgIGxldCBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzW2pdO1xuICAgICAgICAgICAgaWYgKCFzZWxlY3RvciB8fCBlbGVtZW50TWF0Y2hlcyhjaGlsZE5vZGUsIHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICAgIGFsbE1hdGNoZXMucHVzaChjaGlsZE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhbGxNYXRjaGVzO1xufVxuLy8gU3R5bGVcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmNvbnN0IFBJWEVMX1BST1BfUkUgPSAvKHRvcHxsZWZ0fHJpZ2h0fGJvdHRvbXx3aWR0aHxoZWlnaHQpJC9pO1xuZnVuY3Rpb24gYXBwbHlTdHlsZShlbCwgcHJvcHMpIHtcbiAgICBmb3IgKGxldCBwcm9wTmFtZSBpbiBwcm9wcykge1xuICAgICAgICBhcHBseVN0eWxlUHJvcChlbCwgcHJvcE5hbWUsIHByb3BzW3Byb3BOYW1lXSk7XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwbHlTdHlsZVByb3AoZWwsIG5hbWUsIHZhbCkge1xuICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICBlbC5zdHlsZVtuYW1lXSA9ICcnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiBQSVhFTF9QUk9QX1JFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgZWwuc3R5bGVbbmFtZV0gPSBgJHt2YWx9cHhgO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZWwuc3R5bGVbbmFtZV0gPSB2YWw7XG4gICAgfVxufVxuLy8gRXZlbnQgSGFuZGxpbmdcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGlmIGludGVyY2VwdGluZyBidWJibGVkIGV2ZW50cyBhdCB0aGUgZG9jdW1lbnQvd2luZG93L2JvZHkgbGV2ZWwsXG4vLyBhbmQgd2FudCB0byBzZWUgb3JpZ2luYXRpbmcgZWxlbWVudCAodGhlICd0YXJnZXQnKSwgdXNlIHRoaXMgdXRpbCBpbnN0ZWFkXG4vLyBvZiBgZXYudGFyZ2V0YCBiZWNhdXNlIGl0IGdvZXMgd2l0aGluIHdlYi1jb21wb25lbnQgYm91bmRhcmllcy5cbmZ1bmN0aW9uIGdldEV2ZW50VGFyZ2V0VmlhUm9vdChldikge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IGV2LmNvbXBvc2VkUGF0aCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoZXYpWzBdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBldi50YXJnZXQ7XG59XG4vLyBVbmlxdWUgSUQgZm9yIERPTSBhdHRyaWJ1dGVcbmxldCBndWlkJDEgPSAwO1xuZnVuY3Rpb24gZ2V0VW5pcXVlRG9tSWQoKSB7XG4gICAgZ3VpZCQxICs9IDE7XG4gICAgcmV0dXJuICdmYy1kb20tJyArIGd1aWQkMTtcbn1cblxuLy8gU3RvcHMgYSBtb3VzZS90b3VjaCBldmVudCBmcm9tIGRvaW5nIGl0J3MgbmF0aXZlIGJyb3dzZXIgYWN0aW9uXG5mdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldikge1xuICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG59XG4vLyBFdmVudCBEZWxlZ2F0aW9uXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBidWlsZERlbGVnYXRpb25IYW5kbGVyKHNlbGVjdG9yLCBoYW5kbGVyKSB7XG4gICAgcmV0dXJuIChldikgPT4ge1xuICAgICAgICBsZXQgbWF0Y2hlZENoaWxkID0gZWxlbWVudENsb3Nlc3QoZXYudGFyZ2V0LCBzZWxlY3Rvcik7XG4gICAgICAgIGlmIChtYXRjaGVkQ2hpbGQpIHtcbiAgICAgICAgICAgIGhhbmRsZXIuY2FsbChtYXRjaGVkQ2hpbGQsIGV2LCBtYXRjaGVkQ2hpbGQpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGxpc3RlbkJ5U2VsZWN0b3IoY29udGFpbmVyLCBldmVudFR5cGUsIHNlbGVjdG9yLCBoYW5kbGVyKSB7XG4gICAgbGV0IGF0dGFjaGVkSGFuZGxlciA9IGJ1aWxkRGVsZWdhdGlvbkhhbmRsZXIoc2VsZWN0b3IsIGhhbmRsZXIpO1xuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgYXR0YWNoZWRIYW5kbGVyKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGF0dGFjaGVkSGFuZGxlcik7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGxpc3RlblRvSG92ZXJCeVNlbGVjdG9yKGNvbnRhaW5lciwgc2VsZWN0b3IsIG9uTW91c2VFbnRlciwgb25Nb3VzZUxlYXZlKSB7XG4gICAgbGV0IGN1cnJlbnRNYXRjaGVkQ2hpbGQ7XG4gICAgcmV0dXJuIGxpc3RlbkJ5U2VsZWN0b3IoY29udGFpbmVyLCAnbW91c2VvdmVyJywgc2VsZWN0b3IsIChtb3VzZU92ZXJFdiwgbWF0Y2hlZENoaWxkKSA9PiB7XG4gICAgICAgIGlmIChtYXRjaGVkQ2hpbGQgIT09IGN1cnJlbnRNYXRjaGVkQ2hpbGQpIHtcbiAgICAgICAgICAgIGN1cnJlbnRNYXRjaGVkQ2hpbGQgPSBtYXRjaGVkQ2hpbGQ7XG4gICAgICAgICAgICBvbk1vdXNlRW50ZXIobW91c2VPdmVyRXYsIG1hdGNoZWRDaGlsZCk7XG4gICAgICAgICAgICBsZXQgcmVhbE9uTW91c2VMZWF2ZSA9IChtb3VzZUxlYXZlRXYpID0+IHtcbiAgICAgICAgICAgICAgICBjdXJyZW50TWF0Y2hlZENoaWxkID0gbnVsbDtcbiAgICAgICAgICAgICAgICBvbk1vdXNlTGVhdmUobW91c2VMZWF2ZUV2LCBtYXRjaGVkQ2hpbGQpO1xuICAgICAgICAgICAgICAgIG1hdGNoZWRDaGlsZC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgcmVhbE9uTW91c2VMZWF2ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gbGlzdGVuIHRvIHRoZSBuZXh0IG1vdXNlbGVhdmUsIGFuZCB0aGVuIHVuYXR0YWNoXG4gICAgICAgICAgICBtYXRjaGVkQ2hpbGQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHJlYWxPbk1vdXNlTGVhdmUpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vLyBBbmltYXRpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmNvbnN0IHRyYW5zaXRpb25FdmVudE5hbWVzID0gW1xuICAgICd3ZWJraXRUcmFuc2l0aW9uRW5kJyxcbiAgICAnb3RyYW5zaXRpb25lbmQnLFxuICAgICdvVHJhbnNpdGlvbkVuZCcsXG4gICAgJ21zVHJhbnNpdGlvbkVuZCcsXG4gICAgJ3RyYW5zaXRpb25lbmQnLFxuXTtcbi8vIHRyaWdnZXJlZCBvbmx5IHdoZW4gdGhlIG5leHQgc2luZ2xlIHN1YnNlcXVlbnQgdHJhbnNpdGlvbiBmaW5pc2hlc1xuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25Eb25lKGVsLCBjYWxsYmFjaykge1xuICAgIGxldCByZWFsQ2FsbGJhY2sgPSAoZXYpID0+IHtcbiAgICAgICAgY2FsbGJhY2soZXYpO1xuICAgICAgICB0cmFuc2l0aW9uRXZlbnROYW1lcy5mb3JFYWNoKChldmVudE5hbWUpID0+IHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCByZWFsQ2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHRyYW5zaXRpb25FdmVudE5hbWVzLmZvckVhY2goKGV2ZW50TmFtZSkgPT4ge1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgcmVhbENhbGxiYWNrKTsgLy8gY3Jvc3MtYnJvd3NlciB3YXkgdG8gZGV0ZXJtaW5lIHdoZW4gdGhlIHRyYW5zaXRpb24gZmluaXNoZXNcbiAgICB9KTtcbn1cbi8vIEFSSUEgd29ya2Fyb3VuZHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGNyZWF0ZUFyaWFDbGlja0F0dHJzKGhhbmRsZXIpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IG9uQ2xpY2s6IGhhbmRsZXIgfSwgY3JlYXRlQXJpYUtleWJvYXJkQXR0cnMoaGFuZGxlcikpO1xufVxuZnVuY3Rpb24gY3JlYXRlQXJpYUtleWJvYXJkQXR0cnMoaGFuZGxlcikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHRhYkluZGV4OiAwLFxuICAgICAgICBvbktleURvd24oZXYpIHtcbiAgICAgICAgICAgIGlmIChldi5rZXkgPT09ICdFbnRlcicgfHwgZXYua2V5ID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyKGV2KTtcbiAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpOyAvLyBpZiBzcGFjZSwgZG9uJ3Qgc2Nyb2xsIGRvd24gcGFnZVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG59XG5cbmxldCBndWlkTnVtYmVyID0gMDtcbmZ1bmN0aW9uIGd1aWQoKSB7XG4gICAgZ3VpZE51bWJlciArPSAxO1xuICAgIHJldHVybiBTdHJpbmcoZ3VpZE51bWJlcik7XG59XG4vKiBGdWxsQ2FsZW5kYXItc3BlY2lmaWMgRE9NIFV0aWxpdGllc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vLyBNYWtlIHRoZSBtb3VzZSBjdXJzb3IgZXhwcmVzcyB0aGF0IGFuIGV2ZW50IGlzIG5vdCBhbGxvd2VkIGluIHRoZSBjdXJyZW50IGFyZWFcbmZ1bmN0aW9uIGRpc2FibGVDdXJzb3IoKSB7XG4gICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKCdmYy1ub3QtYWxsb3dlZCcpO1xufVxuLy8gUmV0dXJucyB0aGUgbW91c2UgY3Vyc29yIHRvIGl0cyBvcmlnaW5hbCBsb29rXG5mdW5jdGlvbiBlbmFibGVDdXJzb3IoKSB7XG4gICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKCdmYy1ub3QtYWxsb3dlZCcpO1xufVxuLyogU2VsZWN0aW9uXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmZ1bmN0aW9uIHByZXZlbnRTZWxlY3Rpb24oZWwpIHtcbiAgICBlbC5zdHlsZS51c2VyU2VsZWN0ID0gJ25vbmUnO1xuICAgIGVsLnN0eWxlLndlYmtpdFVzZXJTZWxlY3QgPSAnbm9uZSc7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0c3RhcnQnLCBwcmV2ZW50RGVmYXVsdCk7XG59XG5mdW5jdGlvbiBhbGxvd1NlbGVjdGlvbihlbCkge1xuICAgIGVsLnN0eWxlLnVzZXJTZWxlY3QgPSAnJztcbiAgICBlbC5zdHlsZS53ZWJraXRVc2VyU2VsZWN0ID0gJyc7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2VsZWN0c3RhcnQnLCBwcmV2ZW50RGVmYXVsdCk7XG59XG4vKiBDb250ZXh0IE1lbnVcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZnVuY3Rpb24gcHJldmVudENvbnRleHRNZW51KGVsKSB7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBwcmV2ZW50RGVmYXVsdCk7XG59XG5mdW5jdGlvbiBhbGxvd0NvbnRleHRNZW51KGVsKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBwcmV2ZW50RGVmYXVsdCk7XG59XG5mdW5jdGlvbiBwYXJzZUZpZWxkU3BlY3MoaW5wdXQpIHtcbiAgICBsZXQgc3BlY3MgPSBbXTtcbiAgICBsZXQgdG9rZW5zID0gW107XG4gICAgbGV0IGk7XG4gICAgbGV0IHRva2VuO1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRva2VucyA9IGlucHV0LnNwbGl0KC9cXHMqLFxccyovKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRva2VucyA9IFtpbnB1dF07XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIHRva2VucyA9IGlucHV0O1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc3BlY3MucHVzaCh0b2tlbi5jaGFyQXQoMCkgPT09ICctJyA/XG4gICAgICAgICAgICAgICAgeyBmaWVsZDogdG9rZW4uc3Vic3RyaW5nKDEpLCBvcmRlcjogLTEgfSA6XG4gICAgICAgICAgICAgICAgeyBmaWVsZDogdG9rZW4sIG9yZGVyOiAxIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc3BlY3MucHVzaCh7IGZ1bmM6IHRva2VuIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzcGVjcztcbn1cbmZ1bmN0aW9uIGNvbXBhcmVCeUZpZWxkU3BlY3Mob2JqMCwgb2JqMSwgZmllbGRTcGVjcykge1xuICAgIGxldCBpO1xuICAgIGxldCBjbXA7XG4gICAgZm9yIChpID0gMDsgaSA8IGZpZWxkU3BlY3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY21wID0gY29tcGFyZUJ5RmllbGRTcGVjKG9iajAsIG9iajEsIGZpZWxkU3BlY3NbaV0pO1xuICAgICAgICBpZiAoY21wKSB7XG4gICAgICAgICAgICByZXR1cm4gY21wO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuZnVuY3Rpb24gY29tcGFyZUJ5RmllbGRTcGVjKG9iajAsIG9iajEsIGZpZWxkU3BlYykge1xuICAgIGlmIChmaWVsZFNwZWMuZnVuYykge1xuICAgICAgICByZXR1cm4gZmllbGRTcGVjLmZ1bmMob2JqMCwgb2JqMSk7XG4gICAgfVxuICAgIHJldHVybiBmbGV4aWJsZUNvbXBhcmUob2JqMFtmaWVsZFNwZWMuZmllbGRdLCBvYmoxW2ZpZWxkU3BlYy5maWVsZF0pXG4gICAgICAgICogKGZpZWxkU3BlYy5vcmRlciB8fCAxKTtcbn1cbmZ1bmN0aW9uIGZsZXhpYmxlQ29tcGFyZShhLCBiKSB7XG4gICAgaWYgKCFhICYmICFiKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAoYiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgaWYgKGEgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgYiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhhKS5sb2NhbGVDb21wYXJlKFN0cmluZyhiKSk7XG4gICAgfVxuICAgIHJldHVybiBhIC0gYjtcbn1cbi8qIFN0cmluZyBVdGlsaXRpZXNcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZnVuY3Rpb24gcGFkU3RhcnQodmFsLCBsZW4pIHtcbiAgICBsZXQgcyA9IFN0cmluZyh2YWwpO1xuICAgIHJldHVybiAnMDAwJy5zdWJzdHIoMCwgbGVuIC0gcy5sZW5ndGgpICsgcztcbn1cbmZ1bmN0aW9uIGZvcm1hdFdpdGhPcmRpbmFscyhmb3JtYXR0ZXIsIGFyZ3MsIGZhbGxiYWNrVGV4dCkge1xuICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXR0ZXIoLi4uYXJncyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnc3RyaW5nJykgeyAvLyBub24tYmxhbmsgc3RyaW5nXG4gICAgICAgIHJldHVybiBhcmdzLnJlZHVjZSgoc3RyLCBhcmcsIGluZGV4KSA9PiAoc3RyLnJlcGxhY2UoJyQnICsgaW5kZXgsIGFyZyB8fCAnJykpLCBmb3JtYXR0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsbGJhY2tUZXh0O1xufVxuLyogTnVtYmVyIFV0aWxpdGllc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5mdW5jdGlvbiBjb21wYXJlTnVtYmVycyhhLCBiKSB7XG4gICAgcmV0dXJuIGEgLSBiO1xufVxuZnVuY3Rpb24gaXNJbnQobikge1xuICAgIHJldHVybiBuICUgMSA9PT0gMDtcbn1cbi8qIEZDLXNwZWNpZmljIERPTSBkaW1lbnNpb24gc3R1ZmZcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZnVuY3Rpb24gY29tcHV0ZVNtYWxsZXN0Q2VsbFdpZHRoKGNlbGxFbCkge1xuICAgIGxldCBhbGxXaWR0aEVsID0gY2VsbEVsLnF1ZXJ5U2VsZWN0b3IoJy5mYy1zY3JvbGxncmlkLXNocmluay1mcmFtZScpO1xuICAgIGxldCBjb250ZW50V2lkdGhFbCA9IGNlbGxFbC5xdWVyeVNlbGVjdG9yKCcuZmMtc2Nyb2xsZ3JpZC1zaHJpbmstY3VzaGlvbicpO1xuICAgIGlmICghYWxsV2lkdGhFbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25lZWRzIGZjLXNjcm9sbGdyaWQtc2hyaW5rLWZyYW1lIGNsYXNzTmFtZScpOyAvLyBUT0RPOiB1c2UgY29uc3RcbiAgICB9XG4gICAgaWYgKCFjb250ZW50V2lkdGhFbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25lZWRzIGZjLXNjcm9sbGdyaWQtc2hyaW5rLWN1c2hpb24gY2xhc3NOYW1lJyk7XG4gICAgfVxuICAgIHJldHVybiBjZWxsRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggLSBhbGxXaWR0aEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICsgLy8gdGhlIGNlbGwgcGFkZGluZytib3JkZXJcbiAgICAgICAgY29udGVudFdpZHRoRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG59XG5cbmNvbnN0IElOVEVSTkFMX1VOSVRTID0gWyd5ZWFycycsICdtb250aHMnLCAnZGF5cycsICdtaWxsaXNlY29uZHMnXTtcbmNvbnN0IFBBUlNFX1JFID0gL14oLT8pKD86KFxcZCspXFwuKT8oXFxkKyk6KFxcZFxcZCkoPzo6KFxcZFxcZCkoPzpcXC4oXFxkXFxkXFxkKSk/KT8vO1xuLy8gUGFyc2luZyBhbmQgQ3JlYXRpb25cbmZ1bmN0aW9uIGNyZWF0ZUR1cmF0aW9uKGlucHV0LCB1bml0KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlU3RyaW5nKGlucHV0KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiYgaW5wdXQpIHsgLy8gbm9uLW51bGwgb2JqZWN0XG4gICAgICAgIHJldHVybiBwYXJzZU9iamVjdChpbnB1dCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBwYXJzZU9iamVjdCh7IFt1bml0IHx8ICdtaWxsaXNlY29uZHMnXTogaW5wdXQgfSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcGFyc2VTdHJpbmcocykge1xuICAgIGxldCBtID0gUEFSU0VfUkUuZXhlYyhzKTtcbiAgICBpZiAobSkge1xuICAgICAgICBsZXQgc2lnbiA9IG1bMV0gPyAtMSA6IDE7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5ZWFyczogMCxcbiAgICAgICAgICAgIG1vbnRoczogMCxcbiAgICAgICAgICAgIGRheXM6IHNpZ24gKiAobVsyXSA/IHBhcnNlSW50KG1bMl0sIDEwKSA6IDApLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiBzaWduICogKChtWzNdID8gcGFyc2VJbnQobVszXSwgMTApIDogMCkgKiA2MCAqIDYwICogMTAwMCArIC8vIGhvdXJzXG4gICAgICAgICAgICAgICAgKG1bNF0gPyBwYXJzZUludChtWzRdLCAxMCkgOiAwKSAqIDYwICogMTAwMCArIC8vIG1pbnV0ZXNcbiAgICAgICAgICAgICAgICAobVs1XSA/IHBhcnNlSW50KG1bNV0sIDEwKSA6IDApICogMTAwMCArIC8vIHNlY29uZHNcbiAgICAgICAgICAgICAgICAobVs2XSA/IHBhcnNlSW50KG1bNl0sIDEwKSA6IDApIC8vIG1zXG4gICAgICAgICAgICApLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHBhcnNlT2JqZWN0KG9iaikge1xuICAgIGxldCBkdXJhdGlvbiA9IHtcbiAgICAgICAgeWVhcnM6IG9iai55ZWFycyB8fCBvYmoueWVhciB8fCAwLFxuICAgICAgICBtb250aHM6IG9iai5tb250aHMgfHwgb2JqLm1vbnRoIHx8IDAsXG4gICAgICAgIGRheXM6IG9iai5kYXlzIHx8IG9iai5kYXkgfHwgMCxcbiAgICAgICAgbWlsbGlzZWNvbmRzOiAob2JqLmhvdXJzIHx8IG9iai5ob3VyIHx8IDApICogNjAgKiA2MCAqIDEwMDAgKyAvLyBob3Vyc1xuICAgICAgICAgICAgKG9iai5taW51dGVzIHx8IG9iai5taW51dGUgfHwgMCkgKiA2MCAqIDEwMDAgKyAvLyBtaW51dGVzXG4gICAgICAgICAgICAob2JqLnNlY29uZHMgfHwgb2JqLnNlY29uZCB8fCAwKSAqIDEwMDAgKyAvLyBzZWNvbmRzXG4gICAgICAgICAgICAob2JqLm1pbGxpc2Vjb25kcyB8fCBvYmoubWlsbGlzZWNvbmQgfHwgb2JqLm1zIHx8IDApLCAvLyBtc1xuICAgIH07XG4gICAgbGV0IHdlZWtzID0gb2JqLndlZWtzIHx8IG9iai53ZWVrO1xuICAgIGlmICh3ZWVrcykge1xuICAgICAgICBkdXJhdGlvbi5kYXlzICs9IHdlZWtzICogNztcbiAgICAgICAgZHVyYXRpb24uc3BlY2lmaWVkV2Vla3MgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZHVyYXRpb247XG59XG4vLyBFcXVhbGl0eVxuZnVuY3Rpb24gZHVyYXRpb25zRXF1YWwoZDAsIGQxKSB7XG4gICAgcmV0dXJuIGQwLnllYXJzID09PSBkMS55ZWFycyAmJlxuICAgICAgICBkMC5tb250aHMgPT09IGQxLm1vbnRocyAmJlxuICAgICAgICBkMC5kYXlzID09PSBkMS5kYXlzICYmXG4gICAgICAgIGQwLm1pbGxpc2Vjb25kcyA9PT0gZDEubWlsbGlzZWNvbmRzO1xufVxuZnVuY3Rpb24gYXNDbGVhbkRheXMoZHVyKSB7XG4gICAgaWYgKCFkdXIueWVhcnMgJiYgIWR1ci5tb250aHMgJiYgIWR1ci5taWxsaXNlY29uZHMpIHtcbiAgICAgICAgcmV0dXJuIGR1ci5kYXlzO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbi8vIFNpbXBsZSBNYXRoXG5mdW5jdGlvbiBhZGREdXJhdGlvbnMoZDAsIGQxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcnM6IGQwLnllYXJzICsgZDEueWVhcnMsXG4gICAgICAgIG1vbnRoczogZDAubW9udGhzICsgZDEubW9udGhzLFxuICAgICAgICBkYXlzOiBkMC5kYXlzICsgZDEuZGF5cyxcbiAgICAgICAgbWlsbGlzZWNvbmRzOiBkMC5taWxsaXNlY29uZHMgKyBkMS5taWxsaXNlY29uZHMsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHN1YnRyYWN0RHVyYXRpb25zKGQxLCBkMCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHllYXJzOiBkMS55ZWFycyAtIGQwLnllYXJzLFxuICAgICAgICBtb250aHM6IGQxLm1vbnRocyAtIGQwLm1vbnRocyxcbiAgICAgICAgZGF5czogZDEuZGF5cyAtIGQwLmRheXMsXG4gICAgICAgIG1pbGxpc2Vjb25kczogZDEubWlsbGlzZWNvbmRzIC0gZDAubWlsbGlzZWNvbmRzLFxuICAgIH07XG59XG5mdW5jdGlvbiBtdWx0aXBseUR1cmF0aW9uKGQsIG4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB5ZWFyczogZC55ZWFycyAqIG4sXG4gICAgICAgIG1vbnRoczogZC5tb250aHMgKiBuLFxuICAgICAgICBkYXlzOiBkLmRheXMgKiBuLFxuICAgICAgICBtaWxsaXNlY29uZHM6IGQubWlsbGlzZWNvbmRzICogbixcbiAgICB9O1xufVxuLy8gQ29udmVyc2lvbnNcbi8vIFwiUm91Z2hcIiBiZWNhdXNlIHRoZXkgYXJlIGJhc2VkIG9uIGF2ZXJhZ2UtY2FzZSBHcmVnb3JpYW4gbW9udGhzL3llYXJzXG5mdW5jdGlvbiBhc1JvdWdoWWVhcnMoZHVyKSB7XG4gICAgcmV0dXJuIGFzUm91Z2hEYXlzKGR1cikgLyAzNjU7XG59XG5mdW5jdGlvbiBhc1JvdWdoTW9udGhzKGR1cikge1xuICAgIHJldHVybiBhc1JvdWdoRGF5cyhkdXIpIC8gMzA7XG59XG5mdW5jdGlvbiBhc1JvdWdoRGF5cyhkdXIpIHtcbiAgICByZXR1cm4gYXNSb3VnaE1zKGR1cikgLyA4NjRlNTtcbn1cbmZ1bmN0aW9uIGFzUm91Z2hNaW51dGVzKGR1cikge1xuICAgIHJldHVybiBhc1JvdWdoTXMoZHVyKSAvICgxMDAwICogNjApO1xufVxuZnVuY3Rpb24gYXNSb3VnaFNlY29uZHMoZHVyKSB7XG4gICAgcmV0dXJuIGFzUm91Z2hNcyhkdXIpIC8gMTAwMDtcbn1cbmZ1bmN0aW9uIGFzUm91Z2hNcyhkdXIpIHtcbiAgICByZXR1cm4gZHVyLnllYXJzICogKDM2NSAqIDg2NGU1KSArXG4gICAgICAgIGR1ci5tb250aHMgKiAoMzAgKiA4NjRlNSkgK1xuICAgICAgICBkdXIuZGF5cyAqIDg2NGU1ICtcbiAgICAgICAgZHVyLm1pbGxpc2Vjb25kcztcbn1cbi8vIEFkdmFuY2VkIE1hdGhcbmZ1bmN0aW9uIHdob2xlRGl2aWRlRHVyYXRpb25zKG51bWVyYXRvciwgZGVub21pbmF0b3IpIHtcbiAgICBsZXQgcmVzID0gbnVsbDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IElOVEVSTkFMX1VOSVRTLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGxldCB1bml0ID0gSU5URVJOQUxfVU5JVFNbaV07XG4gICAgICAgIGlmIChkZW5vbWluYXRvclt1bml0XSkge1xuICAgICAgICAgICAgbGV0IGxvY2FsUmVzID0gbnVtZXJhdG9yW3VuaXRdIC8gZGVub21pbmF0b3JbdW5pdF07XG4gICAgICAgICAgICBpZiAoIWlzSW50KGxvY2FsUmVzKSB8fCAocmVzICE9PSBudWxsICYmIHJlcyAhPT0gbG9jYWxSZXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMgPSBsb2NhbFJlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChudW1lcmF0b3JbdW5pdF0pIHtcbiAgICAgICAgICAgIC8vIG5lZWRzIHRvIGRpdmlkZSBieSBzb21ldGhpbmcgYnV0IGNhbid0IVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvcihkdXIpIHtcbiAgICBsZXQgbXMgPSBkdXIubWlsbGlzZWNvbmRzO1xuICAgIGlmIChtcykge1xuICAgICAgICBpZiAobXMgJSAxMDAwICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnbWlsbGlzZWNvbmQnLCB2YWx1ZTogbXMgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXMgJSAoMTAwMCAqIDYwKSAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ3NlY29uZCcsIHZhbHVlOiBtcyAvIDEwMDAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXMgJSAoMTAwMCAqIDYwICogNjApICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnbWludXRlJywgdmFsdWU6IG1zIC8gKDEwMDAgKiA2MCkgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXMpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdob3VyJywgdmFsdWU6IG1zIC8gKDEwMDAgKiA2MCAqIDYwKSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChkdXIuZGF5cykge1xuICAgICAgICBpZiAoZHVyLnNwZWNpZmllZFdlZWtzICYmIGR1ci5kYXlzICUgNyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ3dlZWsnLCB2YWx1ZTogZHVyLmRheXMgLyA3IH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdW5pdDogJ2RheScsIHZhbHVlOiBkdXIuZGF5cyB9O1xuICAgIH1cbiAgICBpZiAoZHVyLm1vbnRocykge1xuICAgICAgICByZXR1cm4geyB1bml0OiAnbW9udGgnLCB2YWx1ZTogZHVyLm1vbnRocyB9O1xuICAgIH1cbiAgICBpZiAoZHVyLnllYXJzKSB7XG4gICAgICAgIHJldHVybiB7IHVuaXQ6ICd5ZWFyJywgdmFsdWU6IGR1ci55ZWFycyB9O1xuICAgIH1cbiAgICByZXR1cm4geyB1bml0OiAnbWlsbGlzZWNvbmQnLCB2YWx1ZTogMCB9O1xufVxuXG4vLyBUT0RPOiBuZXcgdXRpbCBhcnJheWlmeT9cbmZ1bmN0aW9uIHJlbW92ZUV4YWN0KGFycmF5LCBleGFjdFZhbCkge1xuICAgIGxldCByZW1vdmVDbnQgPSAwO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFycmF5Lmxlbmd0aCkge1xuICAgICAgICBpZiAoYXJyYXlbaV0gPT09IGV4YWN0VmFsKSB7XG4gICAgICAgICAgICBhcnJheS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICByZW1vdmVDbnQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVtb3ZlQ250O1xufVxuZnVuY3Rpb24gaXNBcnJheXNFcXVhbChhMCwgYTEsIGVxdWFsaXR5RnVuYykge1xuICAgIGlmIChhMCA9PT0gYTEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxldCBsZW4gPSBhMC5sZW5ndGg7XG4gICAgbGV0IGk7XG4gICAgaWYgKGxlbiAhPT0gYTEubGVuZ3RoKSB7IC8vIG5vdCBhcnJheT8gb3Igbm90IHNhbWUgbGVuZ3RoP1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBpZiAoIShlcXVhbGl0eUZ1bmMgPyBlcXVhbGl0eUZ1bmMoYTBbaV0sIGExW2ldKSA6IGEwW2ldID09PSBhMVtpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuY29uc3QgREFZX0lEUyA9IFsnc3VuJywgJ21vbicsICd0dWUnLCAnd2VkJywgJ3RodScsICdmcmknLCAnc2F0J107XG4vLyBBZGRpbmdcbmZ1bmN0aW9uIGFkZFdlZWtzKG0sIG4pIHtcbiAgICBsZXQgYSA9IGRhdGVUb1V0Y0FycmF5KG0pO1xuICAgIGFbMl0gKz0gbiAqIDc7XG4gICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKGEpO1xufVxuZnVuY3Rpb24gYWRkRGF5cyhtLCBuKSB7XG4gICAgbGV0IGEgPSBkYXRlVG9VdGNBcnJheShtKTtcbiAgICBhWzJdICs9IG47XG4gICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKGEpO1xufVxuZnVuY3Rpb24gYWRkTXMobSwgbikge1xuICAgIGxldCBhID0gZGF0ZVRvVXRjQXJyYXkobSk7XG4gICAgYVs2XSArPSBuO1xuICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShhKTtcbn1cbi8vIERpZmZpbmcgKGFsbCByZXR1cm4gZmxvYXRzKVxuLy8gVE9ETzogd2h5IG5vdCB1c2UgcmFuZ2VzP1xuZnVuY3Rpb24gZGlmZldlZWtzKG0wLCBtMSkge1xuICAgIHJldHVybiBkaWZmRGF5cyhtMCwgbTEpIC8gNztcbn1cbmZ1bmN0aW9uIGRpZmZEYXlzKG0wLCBtMSkge1xuICAgIHJldHVybiAobTEudmFsdWVPZigpIC0gbTAudmFsdWVPZigpKSAvICgxMDAwICogNjAgKiA2MCAqIDI0KTtcbn1cbmZ1bmN0aW9uIGRpZmZIb3VycyhtMCwgbTEpIHtcbiAgICByZXR1cm4gKG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSkgLyAoMTAwMCAqIDYwICogNjApO1xufVxuZnVuY3Rpb24gZGlmZk1pbnV0ZXMobTAsIG0xKSB7XG4gICAgcmV0dXJuIChtMS52YWx1ZU9mKCkgLSBtMC52YWx1ZU9mKCkpIC8gKDEwMDAgKiA2MCk7XG59XG5mdW5jdGlvbiBkaWZmU2Vjb25kcyhtMCwgbTEpIHtcbiAgICByZXR1cm4gKG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSkgLyAxMDAwO1xufVxuZnVuY3Rpb24gZGlmZkRheUFuZFRpbWUobTAsIG0xKSB7XG4gICAgbGV0IG0wZGF5ID0gc3RhcnRPZkRheShtMCk7XG4gICAgbGV0IG0xZGF5ID0gc3RhcnRPZkRheShtMSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcnM6IDAsXG4gICAgICAgIG1vbnRoczogMCxcbiAgICAgICAgZGF5czogTWF0aC5yb3VuZChkaWZmRGF5cyhtMGRheSwgbTFkYXkpKSxcbiAgICAgICAgbWlsbGlzZWNvbmRzOiAobTEudmFsdWVPZigpIC0gbTFkYXkudmFsdWVPZigpKSAtIChtMC52YWx1ZU9mKCkgLSBtMGRheS52YWx1ZU9mKCkpLFxuICAgIH07XG59XG4vLyBEaWZmaW5nIFdob2xlIFVuaXRzXG5mdW5jdGlvbiBkaWZmV2hvbGVXZWVrcyhtMCwgbTEpIHtcbiAgICBsZXQgZCA9IGRpZmZXaG9sZURheXMobTAsIG0xKTtcbiAgICBpZiAoZCAhPT0gbnVsbCAmJiBkICUgNyA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZCAvIDc7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZGlmZldob2xlRGF5cyhtMCwgbTEpIHtcbiAgICBpZiAodGltZUFzTXMobTApID09PSB0aW1lQXNNcyhtMSkpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoZGlmZkRheXMobTAsIG0xKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLy8gU3RhcnQtT2ZcbmZ1bmN0aW9uIHN0YXJ0T2ZEYXkobSkge1xuICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShbXG4gICAgICAgIG0uZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgbS5nZXRVVENNb250aCgpLFxuICAgICAgICBtLmdldFVUQ0RhdGUoKSxcbiAgICBdKTtcbn1cbmZ1bmN0aW9uIHN0YXJ0T2ZIb3VyKG0pIHtcbiAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoW1xuICAgICAgICBtLmdldFVUQ0Z1bGxZZWFyKCksXG4gICAgICAgIG0uZ2V0VVRDTW9udGgoKSxcbiAgICAgICAgbS5nZXRVVENEYXRlKCksXG4gICAgICAgIG0uZ2V0VVRDSG91cnMoKSxcbiAgICBdKTtcbn1cbmZ1bmN0aW9uIHN0YXJ0T2ZNaW51dGUobSkge1xuICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShbXG4gICAgICAgIG0uZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgbS5nZXRVVENNb250aCgpLFxuICAgICAgICBtLmdldFVUQ0RhdGUoKSxcbiAgICAgICAgbS5nZXRVVENIb3VycygpLFxuICAgICAgICBtLmdldFVUQ01pbnV0ZXMoKSxcbiAgICBdKTtcbn1cbmZ1bmN0aW9uIHN0YXJ0T2ZTZWNvbmQobSkge1xuICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShbXG4gICAgICAgIG0uZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgbS5nZXRVVENNb250aCgpLFxuICAgICAgICBtLmdldFVUQ0RhdGUoKSxcbiAgICAgICAgbS5nZXRVVENIb3VycygpLFxuICAgICAgICBtLmdldFVUQ01pbnV0ZXMoKSxcbiAgICAgICAgbS5nZXRVVENTZWNvbmRzKCksXG4gICAgXSk7XG59XG4vLyBXZWVrIENvbXB1dGF0aW9uXG5mdW5jdGlvbiB3ZWVrT2ZZZWFyKG1hcmtlciwgZG93LCBkb3kpIHtcbiAgICBsZXQgeSA9IG1hcmtlci5nZXRVVENGdWxsWWVhcigpO1xuICAgIGxldCB3ID0gd2Vla09mR2l2ZW5ZZWFyKG1hcmtlciwgeSwgZG93LCBkb3kpO1xuICAgIGlmICh3IDwgMSkge1xuICAgICAgICByZXR1cm4gd2Vla09mR2l2ZW5ZZWFyKG1hcmtlciwgeSAtIDEsIGRvdywgZG95KTtcbiAgICB9XG4gICAgbGV0IG5leHRXID0gd2Vla09mR2l2ZW5ZZWFyKG1hcmtlciwgeSArIDEsIGRvdywgZG95KTtcbiAgICBpZiAobmV4dFcgPj0gMSkge1xuICAgICAgICByZXR1cm4gTWF0aC5taW4odywgbmV4dFcpO1xuICAgIH1cbiAgICByZXR1cm4gdztcbn1cbmZ1bmN0aW9uIHdlZWtPZkdpdmVuWWVhcihtYXJrZXIsIHllYXIsIGRvdywgZG95KSB7XG4gICAgbGV0IGZpcnN0V2Vla1N0YXJ0ID0gYXJyYXlUb1V0Y0RhdGUoW3llYXIsIDAsIDEgKyBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpXSk7XG4gICAgbGV0IGRheVN0YXJ0ID0gc3RhcnRPZkRheShtYXJrZXIpO1xuICAgIGxldCBkYXlzID0gTWF0aC5yb3VuZChkaWZmRGF5cyhmaXJzdFdlZWtTdGFydCwgZGF5U3RhcnQpKTtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihkYXlzIC8gNykgKyAxOyAvLyB6ZXJvLWluZGV4ZWRcbn1cbi8vIHN0YXJ0LW9mLWZpcnN0LXdlZWsgLSBzdGFydC1vZi15ZWFyXG5mdW5jdGlvbiBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpIHtcbiAgICAvLyBmaXJzdC13ZWVrIGRheSAtLSB3aGljaCBqYW51YXJ5IGlzIGFsd2F5cyBpbiB0aGUgZmlyc3Qgd2VlayAoNCBmb3IgaXNvLCAxIGZvciBvdGhlcilcbiAgICBsZXQgZndkID0gNyArIGRvdyAtIGRveTtcbiAgICAvLyBmaXJzdC13ZWVrIGRheSBsb2NhbCB3ZWVrZGF5IC0tIHdoaWNoIGxvY2FsIHdlZWtkYXkgaXMgZndkXG4gICAgbGV0IGZ3ZGx3ID0gKDcgKyBhcnJheVRvVXRjRGF0ZShbeWVhciwgMCwgZndkXSkuZ2V0VVRDRGF5KCkgLSBkb3cpICUgNztcbiAgICByZXR1cm4gLWZ3ZGx3ICsgZndkIC0gMTtcbn1cbi8vIEFycmF5IENvbnZlcnNpb25cbmZ1bmN0aW9uIGRhdGVUb0xvY2FsQXJyYXkoZGF0ZSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGRhdGUuZ2V0RnVsbFllYXIoKSxcbiAgICAgICAgZGF0ZS5nZXRNb250aCgpLFxuICAgICAgICBkYXRlLmdldERhdGUoKSxcbiAgICAgICAgZGF0ZS5nZXRIb3VycygpLFxuICAgICAgICBkYXRlLmdldE1pbnV0ZXMoKSxcbiAgICAgICAgZGF0ZS5nZXRTZWNvbmRzKCksXG4gICAgICAgIGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCksXG4gICAgXTtcbn1cbmZ1bmN0aW9uIGFycmF5VG9Mb2NhbERhdGUoYSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShhWzBdLCBhWzFdIHx8IDAsIGFbMl0gPT0gbnVsbCA/IDEgOiBhWzJdLCAvLyBkYXkgb2YgbW9udGhcbiAgICBhWzNdIHx8IDAsIGFbNF0gfHwgMCwgYVs1XSB8fCAwKTtcbn1cbmZ1bmN0aW9uIGRhdGVUb1V0Y0FycmF5KGRhdGUpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBkYXRlLmdldFVUQ0Z1bGxZZWFyKCksXG4gICAgICAgIGRhdGUuZ2V0VVRDTW9udGgoKSxcbiAgICAgICAgZGF0ZS5nZXRVVENEYXRlKCksXG4gICAgICAgIGRhdGUuZ2V0VVRDSG91cnMoKSxcbiAgICAgICAgZGF0ZS5nZXRVVENNaW51dGVzKCksXG4gICAgICAgIGRhdGUuZ2V0VVRDU2Vjb25kcygpLFxuICAgICAgICBkYXRlLmdldFVUQ01pbGxpc2Vjb25kcygpLFxuICAgIF07XG59XG5mdW5jdGlvbiBhcnJheVRvVXRjRGF0ZShhKSB7XG4gICAgLy8gYWNjb3JkaW5nIHRvIHdlYiBzdGFuZGFyZHMgKGFuZCBTYWZhcmkpLCBhIG1vbnRoIGluZGV4IGlzIHJlcXVpcmVkLlxuICAgIC8vIG1hc3NhZ2UgaWYgb25seSBnaXZlbiBhIHllYXIuXG4gICAgaWYgKGEubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGEgPSBhLmNvbmNhdChbMF0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoLi4uYSkpO1xufVxuLy8gT3RoZXIgVXRpbHNcbmZ1bmN0aW9uIGlzVmFsaWREYXRlKG0pIHtcbiAgICByZXR1cm4gIWlzTmFOKG0udmFsdWVPZigpKTtcbn1cbmZ1bmN0aW9uIHRpbWVBc01zKG0pIHtcbiAgICByZXR1cm4gbS5nZXRVVENIb3VycygpICogMTAwMCAqIDYwICogNjAgK1xuICAgICAgICBtLmdldFVUQ01pbnV0ZXMoKSAqIDEwMDAgKiA2MCArXG4gICAgICAgIG0uZ2V0VVRDU2Vjb25kcygpICogMTAwMCArXG4gICAgICAgIG0uZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG59XG5cbi8vIHRpbWVab25lT2Zmc2V0IGlzIGluIG1pbnV0ZXNcbmZ1bmN0aW9uIGJ1aWxkSXNvU3RyaW5nKG1hcmtlciwgdGltZVpvbmVPZmZzZXQsIHN0cmlwWmVyb1RpbWUgPSBmYWxzZSkge1xuICAgIGxldCBzID0gbWFya2VyLnRvSVNPU3RyaW5nKCk7XG4gICAgcyA9IHMucmVwbGFjZSgnLjAwMCcsICcnKTtcbiAgICBpZiAoc3RyaXBaZXJvVGltZSkge1xuICAgICAgICBzID0gcy5yZXBsYWNlKCdUMDA6MDA6MDBaJywgJycpO1xuICAgIH1cbiAgICBpZiAocy5sZW5ndGggPiAxMCkgeyAvLyB0aW1lIHBhcnQgd2Fzbid0IHN0cmlwcGVkLCBjYW4gYWRkIHRpbWV6b25lIGluZm9cbiAgICAgICAgaWYgKHRpbWVab25lT2Zmc2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoJ1onLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGltZVpvbmVPZmZzZXQgIT09IDApIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoJ1onLCBmb3JtYXRUaW1lWm9uZU9mZnNldCh0aW1lWm9uZU9mZnNldCwgdHJ1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG90aGVyd2lzZSwgaXRzIFVUQy0wIGFuZCB3ZSB3YW50IHRvIGtlZXAgdGhlIFpcbiAgICB9XG4gICAgcmV0dXJuIHM7XG59XG4vLyBmb3JtYXRzIHRoZSBkYXRlLCBidXQgd2l0aCBubyB0aW1lIHBhcnRcbi8vIFRPRE86IHNvbWVob3cgbWVyZ2Ugd2l0aCBidWlsZElzb1N0cmluZyBhbmQgc3RyaXBaZXJvVGltZVxuLy8gVE9ETzogcmVuYW1lLiBvbWl0IFwic3RyaW5nXCJcbmZ1bmN0aW9uIGZvcm1hdERheVN0cmluZyhtYXJrZXIpIHtcbiAgICByZXR1cm4gbWFya2VyLnRvSVNPU3RyaW5nKCkucmVwbGFjZSgvVC4qJC8sICcnKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdElzb01vbnRoU3RyKG1hcmtlcikge1xuICAgIHJldHVybiBtYXJrZXIudG9JU09TdHJpbmcoKS5tYXRjaCgvXlxcZHs0fS1cXGR7Mn0vKVswXTtcbn1cbi8vIFRPRE86IHVzZSBEYXRlOjp0b0lTT1N0cmluZyBhbmQgdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIFQ/XG5mdW5jdGlvbiBmb3JtYXRJc29UaW1lU3RyaW5nKG1hcmtlcikge1xuICAgIHJldHVybiBwYWRTdGFydChtYXJrZXIuZ2V0VVRDSG91cnMoKSwgMikgKyAnOicgK1xuICAgICAgICBwYWRTdGFydChtYXJrZXIuZ2V0VVRDTWludXRlcygpLCAyKSArICc6JyArXG4gICAgICAgIHBhZFN0YXJ0KG1hcmtlci5nZXRVVENTZWNvbmRzKCksIDIpO1xufVxuZnVuY3Rpb24gZm9ybWF0VGltZVpvbmVPZmZzZXQobWludXRlcywgZG9Jc28gPSBmYWxzZSkge1xuICAgIGxldCBzaWduID0gbWludXRlcyA8IDAgPyAnLScgOiAnKyc7XG4gICAgbGV0IGFicyA9IE1hdGguYWJzKG1pbnV0ZXMpO1xuICAgIGxldCBob3VycyA9IE1hdGguZmxvb3IoYWJzIC8gNjApO1xuICAgIGxldCBtaW5zID0gTWF0aC5yb3VuZChhYnMgJSA2MCk7XG4gICAgaWYgKGRvSXNvKSB7XG4gICAgICAgIHJldHVybiBgJHtzaWduICsgcGFkU3RhcnQoaG91cnMsIDIpfToke3BhZFN0YXJ0KG1pbnMsIDIpfWA7XG4gICAgfVxuICAgIHJldHVybiBgR01UJHtzaWdufSR7aG91cnN9JHttaW5zID8gYDoke3BhZFN0YXJ0KG1pbnMsIDIpfWAgOiAnJ31gO1xufVxuXG5mdW5jdGlvbiBtZW1vaXplKHdvcmtlckZ1bmMsIHJlc0VxdWFsaXR5LCB0ZWFyZG93bkZ1bmMpIHtcbiAgICBsZXQgY3VycmVudEFyZ3M7XG4gICAgbGV0IGN1cnJlbnRSZXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5uZXdBcmdzKSB7XG4gICAgICAgIGlmICghY3VycmVudEFyZ3MpIHtcbiAgICAgICAgICAgIGN1cnJlbnRSZXMgPSB3b3JrZXJGdW5jLmFwcGx5KHRoaXMsIG5ld0FyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpc0FycmF5c0VxdWFsKGN1cnJlbnRBcmdzLCBuZXdBcmdzKSkge1xuICAgICAgICAgICAgaWYgKHRlYXJkb3duRnVuYykge1xuICAgICAgICAgICAgICAgIHRlYXJkb3duRnVuYyhjdXJyZW50UmVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZXMgPSB3b3JrZXJGdW5jLmFwcGx5KHRoaXMsIG5ld0FyZ3MpO1xuICAgICAgICAgICAgaWYgKCFyZXNFcXVhbGl0eSB8fCAhcmVzRXF1YWxpdHkocmVzLCBjdXJyZW50UmVzKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRSZXMgPSByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEFyZ3MgPSBuZXdBcmdzO1xuICAgICAgICByZXR1cm4gY3VycmVudFJlcztcbiAgICB9O1xufVxuZnVuY3Rpb24gbWVtb2l6ZU9iakFyZyh3b3JrZXJGdW5jLCByZXNFcXVhbGl0eSwgdGVhcmRvd25GdW5jKSB7XG4gICAgbGV0IGN1cnJlbnRBcmc7XG4gICAgbGV0IGN1cnJlbnRSZXM7XG4gICAgcmV0dXJuIChuZXdBcmcpID0+IHtcbiAgICAgICAgaWYgKCFjdXJyZW50QXJnKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVzID0gd29ya2VyRnVuYy5jYWxsKHRoaXMsIG5ld0FyZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWlzUHJvcHNFcXVhbChjdXJyZW50QXJnLCBuZXdBcmcpKSB7XG4gICAgICAgICAgICBpZiAodGVhcmRvd25GdW5jKSB7XG4gICAgICAgICAgICAgICAgdGVhcmRvd25GdW5jKGN1cnJlbnRSZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlcyA9IHdvcmtlckZ1bmMuY2FsbCh0aGlzLCBuZXdBcmcpO1xuICAgICAgICAgICAgaWYgKCFyZXNFcXVhbGl0eSB8fCAhcmVzRXF1YWxpdHkocmVzLCBjdXJyZW50UmVzKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRSZXMgPSByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEFyZyA9IG5ld0FyZztcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRSZXM7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1lbW9pemVBcnJheWxpa2UoLy8gdXNlZCBhdCBhbGw/XG53b3JrZXJGdW5jLCByZXNFcXVhbGl0eSwgdGVhcmRvd25GdW5jKSB7XG4gICAgbGV0IGN1cnJlbnRBcmdTZXRzID0gW107XG4gICAgbGV0IGN1cnJlbnRSZXN1bHRzID0gW107XG4gICAgcmV0dXJuIChuZXdBcmdTZXRzKSA9PiB7XG4gICAgICAgIGxldCBjdXJyZW50TGVuID0gY3VycmVudEFyZ1NldHMubGVuZ3RoO1xuICAgICAgICBsZXQgbmV3TGVuID0gbmV3QXJnU2V0cy5sZW5ndGg7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yICg7IGkgPCBjdXJyZW50TGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmICghbmV3QXJnU2V0c1tpXSkgeyAvLyBvbmUgb2YgdGhlIG9sZCBzZXRzIG5vIGxvbmdlciBleGlzdHNcbiAgICAgICAgICAgICAgICBpZiAodGVhcmRvd25GdW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlYXJkb3duRnVuYyhjdXJyZW50UmVzdWx0c1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzQXJyYXlzRXF1YWwoY3VycmVudEFyZ1NldHNbaV0sIG5ld0FyZ1NldHNbaV0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRlYXJkb3duRnVuYykge1xuICAgICAgICAgICAgICAgICAgICB0ZWFyZG93bkZ1bmMoY3VycmVudFJlc3VsdHNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcmVzID0gd29ya2VyRnVuYy5hcHBseSh0aGlzLCBuZXdBcmdTZXRzW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc0VxdWFsaXR5IHx8ICFyZXNFcXVhbGl0eShyZXMsIGN1cnJlbnRSZXN1bHRzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVzdWx0c1tpXSA9IHJlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IGkgPCBuZXdMZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgY3VycmVudFJlc3VsdHNbaV0gPSB3b3JrZXJGdW5jLmFwcGx5KHRoaXMsIG5ld0FyZ1NldHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRBcmdTZXRzID0gbmV3QXJnU2V0cztcbiAgICAgICAgY3VycmVudFJlc3VsdHMuc3BsaWNlKG5ld0xlbik7IC8vIHJlbW92ZSBleGNlc3NcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRSZXN1bHRzO1xuICAgIH07XG59XG5mdW5jdGlvbiBtZW1vaXplSGFzaGxpa2Uod29ya2VyRnVuYywgcmVzRXF1YWxpdHksIHRlYXJkb3duRnVuYykge1xuICAgIGxldCBjdXJyZW50QXJnSGFzaCA9IHt9O1xuICAgIGxldCBjdXJyZW50UmVzSGFzaCA9IHt9O1xuICAgIHJldHVybiAobmV3QXJnSGFzaCkgPT4ge1xuICAgICAgICBsZXQgbmV3UmVzSGFzaCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBrZXkgaW4gbmV3QXJnSGFzaCkge1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50UmVzSGFzaFtrZXldKSB7XG4gICAgICAgICAgICAgICAgbmV3UmVzSGFzaFtrZXldID0gd29ya2VyRnVuYy5hcHBseSh0aGlzLCBuZXdBcmdIYXNoW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzQXJyYXlzRXF1YWwoY3VycmVudEFyZ0hhc2hba2V5XSwgbmV3QXJnSGFzaFtrZXldKSkge1xuICAgICAgICAgICAgICAgIGlmICh0ZWFyZG93bkZ1bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVhcmRvd25GdW5jKGN1cnJlbnRSZXNIYXNoW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcmVzID0gd29ya2VyRnVuYy5hcHBseSh0aGlzLCBuZXdBcmdIYXNoW2tleV0pO1xuICAgICAgICAgICAgICAgIG5ld1Jlc0hhc2hba2V5XSA9IChyZXNFcXVhbGl0eSAmJiByZXNFcXVhbGl0eShyZXMsIGN1cnJlbnRSZXNIYXNoW2tleV0pKVxuICAgICAgICAgICAgICAgICAgICA/IGN1cnJlbnRSZXNIYXNoW2tleV1cbiAgICAgICAgICAgICAgICAgICAgOiByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdSZXNIYXNoW2tleV0gPSBjdXJyZW50UmVzSGFzaFtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRBcmdIYXNoID0gbmV3QXJnSGFzaDtcbiAgICAgICAgY3VycmVudFJlc0hhc2ggPSBuZXdSZXNIYXNoO1xuICAgICAgICByZXR1cm4gbmV3UmVzSGFzaDtcbiAgICB9O1xufVxuXG5jb25zdCBFWFRFTkRFRF9TRVRUSU5HU19BTkRfU0VWRVJJVElFUyA9IHtcbiAgICB3ZWVrOiAzLFxuICAgIHNlcGFyYXRvcjogMCxcbiAgICBvbWl0WmVyb01pbnV0ZTogMCxcbiAgICBtZXJpZGllbTogMCxcbiAgICBvbWl0Q29tbWFzOiAwLFxufTtcbmNvbnN0IFNUQU5EQVJEX0RBVEVfUFJPUF9TRVZFUklUSUVTID0ge1xuICAgIHRpbWVab25lTmFtZTogNyxcbiAgICBlcmE6IDYsXG4gICAgeWVhcjogNSxcbiAgICBtb250aDogNCxcbiAgICBkYXk6IDIsXG4gICAgd2Vla2RheTogMixcbiAgICBob3VyOiAxLFxuICAgIG1pbnV0ZTogMSxcbiAgICBzZWNvbmQ6IDEsXG59O1xuY29uc3QgTUVSSURJRU1fUkUgPSAvXFxzKihbYXBdKVxcLj9tXFwuPy9pOyAvLyBlYXRzIHVwIGxlYWRpbmcgc3BhY2VzIHRvb1xuY29uc3QgQ09NTUFfUkUgPSAvLC9nOyAvLyB3ZSBuZWVkIHJlIGZvciBnbG9iYWxuZXNzXG5jb25zdCBNVUxUSV9TUEFDRV9SRSA9IC9cXHMrL2c7XG5jb25zdCBMVFJfUkUgPSAvXFx1MjAwZS9nOyAvLyBjb250cm9sIGNoYXJhY3RlclxuY29uc3QgVVRDX1JFID0gL1VUQ3xHTVQvO1xuY2xhc3MgTmF0aXZlRm9ybWF0dGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihmb3JtYXRTZXR0aW5ncykge1xuICAgICAgICBsZXQgc3RhbmRhcmREYXRlUHJvcHMgPSB7fTtcbiAgICAgICAgbGV0IGV4dGVuZGVkU2V0dGluZ3MgPSB7fTtcbiAgICAgICAgbGV0IHNldmVyaXR5ID0gMDtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBmb3JtYXRTZXR0aW5ncykge1xuICAgICAgICAgICAgaWYgKG5hbWUgaW4gRVhURU5ERURfU0VUVElOR1NfQU5EX1NFVkVSSVRJRVMpIHtcbiAgICAgICAgICAgICAgICBleHRlbmRlZFNldHRpbmdzW25hbWVdID0gZm9ybWF0U2V0dGluZ3NbbmFtZV07XG4gICAgICAgICAgICAgICAgc2V2ZXJpdHkgPSBNYXRoLm1heChFWFRFTkRFRF9TRVRUSU5HU19BTkRfU0VWRVJJVElFU1tuYW1lXSwgc2V2ZXJpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhbmRhcmREYXRlUHJvcHNbbmFtZV0gPSBmb3JtYXRTZXR0aW5nc1tuYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSBpbiBTVEFOREFSRF9EQVRFX1BST1BfU0VWRVJJVElFUykgeyAvLyBUT0RPOiB3aGF0IGFib3V0IGhvdXIxMj8gbm8gc2V2ZXJpdHlcbiAgICAgICAgICAgICAgICAgICAgc2V2ZXJpdHkgPSBNYXRoLm1heChTVEFOREFSRF9EQVRFX1BST1BfU0VWRVJJVElFU1tuYW1lXSwgc2V2ZXJpdHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YW5kYXJkRGF0ZVByb3BzID0gc3RhbmRhcmREYXRlUHJvcHM7XG4gICAgICAgIHRoaXMuZXh0ZW5kZWRTZXR0aW5ncyA9IGV4dGVuZGVkU2V0dGluZ3M7XG4gICAgICAgIHRoaXMuc2V2ZXJpdHkgPSBzZXZlcml0eTtcbiAgICAgICAgdGhpcy5idWlsZEZvcm1hdHRpbmdGdW5jID0gbWVtb2l6ZShidWlsZEZvcm1hdHRpbmdGdW5jKTtcbiAgICB9XG4gICAgZm9ybWF0KGRhdGUsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRGb3JtYXR0aW5nRnVuYyh0aGlzLnN0YW5kYXJkRGF0ZVByb3BzLCB0aGlzLmV4dGVuZGVkU2V0dGluZ3MsIGNvbnRleHQpKGRhdGUpO1xuICAgIH1cbiAgICBmb3JtYXRSYW5nZShzdGFydCwgZW5kLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSB7XG4gICAgICAgIGxldCB7IHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgZGlmZlNldmVyaXR5ID0gY29tcHV0ZU1hcmtlckRpZmZTZXZlcml0eShzdGFydC5tYXJrZXIsIGVuZC5tYXJrZXIsIGNvbnRleHQuY2FsZW5kYXJTeXN0ZW0pO1xuICAgICAgICBpZiAoIWRpZmZTZXZlcml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KHN0YXJ0LCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYmlnZ2VzdFVuaXRGb3JQYXJ0aWFsID0gZGlmZlNldmVyaXR5O1xuICAgICAgICBpZiAoYmlnZ2VzdFVuaXRGb3JQYXJ0aWFsID4gMSAmJiAvLyB0aGUgdHdvIGRhdGVzIGFyZSBkaWZmZXJlbnQgaW4gYSB3YXkgdGhhdCdzIGxhcmdlciBzY2FsZSB0aGFuIHRpbWVcbiAgICAgICAgICAgIChzdGFuZGFyZERhdGVQcm9wcy55ZWFyID09PSAnbnVtZXJpYycgfHwgc3RhbmRhcmREYXRlUHJvcHMueWVhciA9PT0gJzItZGlnaXQnKSAmJlxuICAgICAgICAgICAgKHN0YW5kYXJkRGF0ZVByb3BzLm1vbnRoID09PSAnbnVtZXJpYycgfHwgc3RhbmRhcmREYXRlUHJvcHMubW9udGggPT09ICcyLWRpZ2l0JykgJiZcbiAgICAgICAgICAgIChzdGFuZGFyZERhdGVQcm9wcy5kYXkgPT09ICdudW1lcmljJyB8fCBzdGFuZGFyZERhdGVQcm9wcy5kYXkgPT09ICcyLWRpZ2l0JykpIHtcbiAgICAgICAgICAgIGJpZ2dlc3RVbml0Rm9yUGFydGlhbCA9IDE7IC8vIG1ha2UgaXQgbG9vayBsaWtlIHRoZSBkYXRlcyBhcmUgb25seSBkaWZmZXJlbnQgaW4gdGVybXMgb2YgdGltZVxuICAgICAgICB9XG4gICAgICAgIGxldCBmdWxsMCA9IHRoaXMuZm9ybWF0KHN0YXJ0LCBjb250ZXh0KTtcbiAgICAgICAgbGV0IGZ1bGwxID0gdGhpcy5mb3JtYXQoZW5kLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKGZ1bGwwID09PSBmdWxsMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bGwwO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJ0aWFsRGF0ZVByb3BzID0gY29tcHV0ZVBhcnRpYWxGb3JtYXR0aW5nT3B0aW9ucyhzdGFuZGFyZERhdGVQcm9wcywgYmlnZ2VzdFVuaXRGb3JQYXJ0aWFsKTtcbiAgICAgICAgbGV0IHBhcnRpYWxGb3JtYXR0aW5nRnVuYyA9IGJ1aWxkRm9ybWF0dGluZ0Z1bmMocGFydGlhbERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCk7XG4gICAgICAgIGxldCBwYXJ0aWFsMCA9IHBhcnRpYWxGb3JtYXR0aW5nRnVuYyhzdGFydCk7XG4gICAgICAgIGxldCBwYXJ0aWFsMSA9IHBhcnRpYWxGb3JtYXR0aW5nRnVuYyhlbmQpO1xuICAgICAgICBsZXQgaW5zZXJ0aW9uID0gZmluZENvbW1vbkluc2VydGlvbihmdWxsMCwgcGFydGlhbDAsIGZ1bGwxLCBwYXJ0aWFsMSk7XG4gICAgICAgIGxldCBzZXBhcmF0b3IgPSBleHRlbmRlZFNldHRpbmdzLnNlcGFyYXRvciB8fCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yIHx8IGNvbnRleHQuZGVmYXVsdFNlcGFyYXRvciB8fCAnJztcbiAgICAgICAgaWYgKGluc2VydGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGluc2VydGlvbi5iZWZvcmUgKyBwYXJ0aWFsMCArIHNlcGFyYXRvciArIHBhcnRpYWwxICsgaW5zZXJ0aW9uLmFmdGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdWxsMCArIHNlcGFyYXRvciArIGZ1bGwxO1xuICAgIH1cbiAgICBnZXRMYXJnZXN0VW5pdCgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnNldmVyaXR5KSB7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgcmV0dXJuICd5ZWFyJztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ21vbnRoJztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3dlZWsnO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiAnZGF5JztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICd0aW1lJzsgLy8gcmVhbGx5P1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYnVpbGRGb3JtYXR0aW5nRnVuYyhzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCkge1xuICAgIGxldCBzdGFuZGFyZERhdGVQcm9wQ250ID0gT2JqZWN0LmtleXMoc3RhbmRhcmREYXRlUHJvcHMpLmxlbmd0aDtcbiAgICBpZiAoc3RhbmRhcmREYXRlUHJvcENudCA9PT0gMSAmJiBzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZU5hbWUgPT09ICdzaG9ydCcpIHtcbiAgICAgICAgcmV0dXJuIChkYXRlKSA9PiAoZm9ybWF0VGltZVpvbmVPZmZzZXQoZGF0ZS50aW1lWm9uZU9mZnNldCkpO1xuICAgIH1cbiAgICBpZiAoc3RhbmRhcmREYXRlUHJvcENudCA9PT0gMCAmJiBleHRlbmRlZFNldHRpbmdzLndlZWspIHtcbiAgICAgICAgcmV0dXJuIChkYXRlKSA9PiAoZm9ybWF0V2Vla051bWJlcihjb250ZXh0LmNvbXB1dGVXZWVrTnVtYmVyKGRhdGUubWFya2VyKSwgY29udGV4dC53ZWVrVGV4dCwgY29udGV4dC53ZWVrVGV4dExvbmcsIGNvbnRleHQubG9jYWxlLCBleHRlbmRlZFNldHRpbmdzLndlZWspKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1aWxkTmF0aXZlRm9ybWF0dGluZ0Z1bmMoc3RhbmRhcmREYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MsIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gYnVpbGROYXRpdmVGb3JtYXR0aW5nRnVuYyhzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCkge1xuICAgIHN0YW5kYXJkRGF0ZVByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhbmRhcmREYXRlUHJvcHMpOyAvLyBjb3B5XG4gICAgZXh0ZW5kZWRTZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIGV4dGVuZGVkU2V0dGluZ3MpOyAvLyBjb3B5XG4gICAgc2FuaXRpemVTZXR0aW5ncyhzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncyk7XG4gICAgc3RhbmRhcmREYXRlUHJvcHMudGltZVpvbmUgPSAnVVRDJzsgLy8gd2UgbGV2ZXJhZ2UgdGhlIG9ubHkgZ3VhcmFudGVlZCB0aW1lWm9uZSBmb3Igb3VyIFVUQyBtYXJrZXJzXG4gICAgbGV0IG5vcm1hbEZvcm1hdCA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGNvbnRleHQubG9jYWxlLmNvZGVzLCBzdGFuZGFyZERhdGVQcm9wcyk7XG4gICAgbGV0IHplcm9Gb3JtYXQ7IC8vIG5lZWRlZD9cbiAgICBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5vbWl0WmVyb01pbnV0ZSkge1xuICAgICAgICBsZXQgemVyb1Byb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhbmRhcmREYXRlUHJvcHMpO1xuICAgICAgICBkZWxldGUgemVyb1Byb3BzLm1pbnV0ZTsgLy8gc2Vjb25kcyBhbmQgbXMgd2VyZSBhbHJlYWR5IGNvbnNpZGVyZWQgaW4gc2FuaXRpemVTZXR0aW5nc1xuICAgICAgICB6ZXJvRm9ybWF0ID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoY29udGV4dC5sb2NhbGUuY29kZXMsIHplcm9Qcm9wcyk7XG4gICAgfVxuICAgIHJldHVybiAoZGF0ZSkgPT4ge1xuICAgICAgICBsZXQgeyBtYXJrZXIgfSA9IGRhdGU7XG4gICAgICAgIGxldCBmb3JtYXQ7XG4gICAgICAgIGlmICh6ZXJvRm9ybWF0ICYmICFtYXJrZXIuZ2V0VVRDTWludXRlcygpKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSB6ZXJvRm9ybWF0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9ybWF0ID0gbm9ybWFsRm9ybWF0O1xuICAgICAgICB9XG4gICAgICAgIGxldCBzID0gZm9ybWF0LmZvcm1hdChtYXJrZXIpO1xuICAgICAgICByZXR1cm4gcG9zdFByb2Nlc3MocywgZGF0ZSwgc3RhbmRhcmREYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MsIGNvbnRleHQpO1xuICAgIH07XG59XG5mdW5jdGlvbiBzYW5pdGl6ZVNldHRpbmdzKHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzKSB7XG4gICAgLy8gZGVhbCB3aXRoIGEgYnJvd3NlciBpbmNvbnNpc3RlbmN5IHdoZXJlIGZvcm1hdHRpbmcgdGhlIHRpbWV6b25lXG4gICAgLy8gcmVxdWlyZXMgdGhhdCB0aGUgaG91ci9taW51dGUgYmUgcHJlc2VudC5cbiAgICBpZiAoc3RhbmRhcmREYXRlUHJvcHMudGltZVpvbmVOYW1lKSB7XG4gICAgICAgIGlmICghc3RhbmRhcmREYXRlUHJvcHMuaG91cikge1xuICAgICAgICAgICAgc3RhbmRhcmREYXRlUHJvcHMuaG91ciA9ICcyLWRpZ2l0JztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0YW5kYXJkRGF0ZVByb3BzLm1pbnV0ZSkge1xuICAgICAgICAgICAgc3RhbmRhcmREYXRlUHJvcHMubWludXRlID0gJzItZGlnaXQnO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIG9ubHkgc3VwcG9ydCBzaG9ydCB0aW1lem9uZSBuYW1lc1xuICAgIGlmIChzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZU5hbWUgPT09ICdsb25nJykge1xuICAgICAgICBzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZU5hbWUgPSAnc2hvcnQnO1xuICAgIH1cbiAgICAvLyBpZiByZXF1ZXN0aW5nIHRvIGRpc3BsYXkgc2Vjb25kcywgTVVTVCBkaXNwbGF5IG1pbnV0ZXNcbiAgICBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5vbWl0WmVyb01pbnV0ZSAmJiAoc3RhbmRhcmREYXRlUHJvcHMuc2Vjb25kIHx8IHN0YW5kYXJkRGF0ZVByb3BzLm1pbGxpc2Vjb25kKSkge1xuICAgICAgICBkZWxldGUgZXh0ZW5kZWRTZXR0aW5ncy5vbWl0WmVyb01pbnV0ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBwb3N0UHJvY2VzcyhzLCBkYXRlLCBzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCkge1xuICAgIHMgPSBzLnJlcGxhY2UoTFRSX1JFLCAnJyk7IC8vIHJlbW92ZSBsZWZ0LXRvLXJpZ2h0IGNvbnRyb2wgY2hhcnMuIGRvIGZpcnN0LiBnb29kIGZvciBvdGhlciByZWdleGVzXG4gICAgaWYgKHN0YW5kYXJkRGF0ZVByb3BzLnRpbWVab25lTmFtZSA9PT0gJ3Nob3J0Jykge1xuICAgICAgICBzID0gaW5qZWN0VHpvU3RyKHMsIChjb250ZXh0LnRpbWVab25lID09PSAnVVRDJyB8fCBkYXRlLnRpbWVab25lT2Zmc2V0ID09IG51bGwpID9cbiAgICAgICAgICAgICdVVEMnIDogLy8gaW1wb3J0YW50IHRvIG5vcm1hbGl6ZSBmb3IgSUUsIHdoaWNoIGRvZXMgXCJHTVRcIlxuICAgICAgICAgICAgZm9ybWF0VGltZVpvbmVPZmZzZXQoZGF0ZS50aW1lWm9uZU9mZnNldCkpO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5vbWl0Q29tbWFzKSB7XG4gICAgICAgIHMgPSBzLnJlcGxhY2UoQ09NTUFfUkUsICcnKS50cmltKCk7XG4gICAgfVxuICAgIGlmIChleHRlbmRlZFNldHRpbmdzLm9taXRaZXJvTWludXRlKSB7XG4gICAgICAgIHMgPSBzLnJlcGxhY2UoJzowMCcsICcnKTsgLy8gemVyb0Zvcm1hdCBkb2Vzbid0IGFsd2F5cyBhY2hpZXZlIHRoaXNcbiAgICB9XG4gICAgLy8gXiBkbyBhbnl0aGluZyB0aGF0IG1pZ2h0IGNyZWF0ZSBhZGphY2VudCBzcGFjZXMgYmVmb3JlIHRoaXMgcG9pbnQsXG4gICAgLy8gYmVjYXVzZSBNRVJJRElFTV9SRSBsaWtlcyB0byBlYXQgdXAgbG9hZGluZyBzcGFjZXNcbiAgICBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5tZXJpZGllbSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcyA9IHMucmVwbGFjZShNRVJJRElFTV9SRSwgJycpLnRyaW0oKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5tZXJpZGllbSA9PT0gJ25hcnJvdycpIHsgLy8gYS9wXG4gICAgICAgIHMgPSBzLnJlcGxhY2UoTUVSSURJRU1fUkUsIChtMCwgbTEpID0+IG0xLnRvTG9jYWxlTG93ZXJDYXNlKCkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHRlbmRlZFNldHRpbmdzLm1lcmlkaWVtID09PSAnc2hvcnQnKSB7IC8vIGFtL3BtXG4gICAgICAgIHMgPSBzLnJlcGxhY2UoTUVSSURJRU1fUkUsIChtMCwgbTEpID0+IGAke20xLnRvTG9jYWxlTG93ZXJDYXNlKCl9bWApO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHRlbmRlZFNldHRpbmdzLm1lcmlkaWVtID09PSAnbG93ZXJjYXNlJykgeyAvLyBvdGhlciBtZXJpZGllbSB0cmFuc2Zvcm1lcnMgYWxyZWFkeSBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlXG4gICAgICAgIHMgPSBzLnJlcGxhY2UoTUVSSURJRU1fUkUsIChtMCkgPT4gbTAudG9Mb2NhbGVMb3dlckNhc2UoKSk7XG4gICAgfVxuICAgIHMgPSBzLnJlcGxhY2UoTVVMVElfU1BBQ0VfUkUsICcgJyk7XG4gICAgcyA9IHMudHJpbSgpO1xuICAgIHJldHVybiBzO1xufVxuZnVuY3Rpb24gaW5qZWN0VHpvU3RyKHMsIHR6b1N0cikge1xuICAgIGxldCByZXBsYWNlZCA9IGZhbHNlO1xuICAgIHMgPSBzLnJlcGxhY2UoVVRDX1JFLCAoKSA9PiB7XG4gICAgICAgIHJlcGxhY2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHR6b1N0cjtcbiAgICB9KTtcbiAgICAvLyBJRTExIGRvZXNuJ3QgaW5jbHVkZSBVVEMvR01UIGluIHRoZSBvcmlnaW5hbCBzdHJpbmcsIHNvIGFwcGVuZCB0byBlbmRcbiAgICBpZiAoIXJlcGxhY2VkKSB7XG4gICAgICAgIHMgKz0gYCAke3R6b1N0cn1gO1xuICAgIH1cbiAgICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIGZvcm1hdFdlZWtOdW1iZXIobnVtLCB3ZWVrVGV4dCwgd2Vla1RleHRMb25nLCBsb2NhbGUsIGRpc3BsYXkpIHtcbiAgICBsZXQgcGFydHMgPSBbXTtcbiAgICBpZiAoZGlzcGxheSA9PT0gJ2xvbmcnKSB7XG4gICAgICAgIHBhcnRzLnB1c2god2Vla1RleHRMb25nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGlzcGxheSA9PT0gJ3Nob3J0JyB8fCBkaXNwbGF5ID09PSAnbmFycm93Jykge1xuICAgICAgICBwYXJ0cy5wdXNoKHdlZWtUZXh0KTtcbiAgICB9XG4gICAgaWYgKGRpc3BsYXkgPT09ICdsb25nJyB8fCBkaXNwbGF5ID09PSAnc2hvcnQnKSB7XG4gICAgICAgIHBhcnRzLnB1c2goJyAnKTtcbiAgICB9XG4gICAgcGFydHMucHVzaChsb2NhbGUuc2ltcGxlTnVtYmVyRm9ybWF0LmZvcm1hdChudW0pKTtcbiAgICBpZiAobG9jYWxlLm9wdGlvbnMuZGlyZWN0aW9uID09PSAncnRsJykgeyAvLyBUT0RPOiB1c2UgY29udHJvbCBjaGFyYWN0ZXJzIGluc3RlYWQ/XG4gICAgICAgIHBhcnRzLnJldmVyc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oJycpO1xufVxuLy8gUmFuZ2UgRm9ybWF0dGluZyBVdGlsc1xuLy8gMCA9IGV4YWN0bHkgdGhlIHNhbWVcbi8vIDEgPSBkaWZmZXJlbnQgYnkgdGltZVxuLy8gYW5kIGJpZ2dlclxuZnVuY3Rpb24gY29tcHV0ZU1hcmtlckRpZmZTZXZlcml0eShkMCwgZDEsIGNhKSB7XG4gICAgaWYgKGNhLmdldE1hcmtlclllYXIoZDApICE9PSBjYS5nZXRNYXJrZXJZZWFyKGQxKSkge1xuICAgICAgICByZXR1cm4gNTtcbiAgICB9XG4gICAgaWYgKGNhLmdldE1hcmtlck1vbnRoKGQwKSAhPT0gY2EuZ2V0TWFya2VyTW9udGgoZDEpKSB7XG4gICAgICAgIHJldHVybiA0O1xuICAgIH1cbiAgICBpZiAoY2EuZ2V0TWFya2VyRGF5KGQwKSAhPT0gY2EuZ2V0TWFya2VyRGF5KGQxKSkge1xuICAgICAgICByZXR1cm4gMjtcbiAgICB9XG4gICAgaWYgKHRpbWVBc01zKGQwKSAhPT0gdGltZUFzTXMoZDEpKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVQYXJ0aWFsRm9ybWF0dGluZ09wdGlvbnMob3B0aW9ucywgYmlnZ2VzdFVuaXQpIHtcbiAgICBsZXQgcGFydGlhbE9wdGlvbnMgPSB7fTtcbiAgICBmb3IgKGxldCBuYW1lIGluIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCEobmFtZSBpbiBTVEFOREFSRF9EQVRFX1BST1BfU0VWRVJJVElFUykgfHwgLy8gbm90IGEgZGF0ZSBwYXJ0IHByb3AgKGxpa2UgdGltZVpvbmUpXG4gICAgICAgICAgICBTVEFOREFSRF9EQVRFX1BST1BfU0VWRVJJVElFU1tuYW1lXSA8PSBiaWdnZXN0VW5pdCkge1xuICAgICAgICAgICAgcGFydGlhbE9wdGlvbnNbbmFtZV0gPSBvcHRpb25zW25hbWVdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJ0aWFsT3B0aW9ucztcbn1cbmZ1bmN0aW9uIGZpbmRDb21tb25JbnNlcnRpb24oZnVsbDAsIHBhcnRpYWwwLCBmdWxsMSwgcGFydGlhbDEpIHtcbiAgICBsZXQgaTAgPSAwO1xuICAgIHdoaWxlIChpMCA8IGZ1bGwwLmxlbmd0aCkge1xuICAgICAgICBsZXQgZm91bmQwID0gZnVsbDAuaW5kZXhPZihwYXJ0aWFsMCwgaTApO1xuICAgICAgICBpZiAoZm91bmQwID09PSAtMSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJlZm9yZTAgPSBmdWxsMC5zdWJzdHIoMCwgZm91bmQwKTtcbiAgICAgICAgaTAgPSBmb3VuZDAgKyBwYXJ0aWFsMC5sZW5ndGg7XG4gICAgICAgIGxldCBhZnRlcjAgPSBmdWxsMC5zdWJzdHIoaTApO1xuICAgICAgICBsZXQgaTEgPSAwO1xuICAgICAgICB3aGlsZSAoaTEgPCBmdWxsMS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBmb3VuZDEgPSBmdWxsMS5pbmRleE9mKHBhcnRpYWwxLCBpMSk7XG4gICAgICAgICAgICBpZiAoZm91bmQxID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGJlZm9yZTEgPSBmdWxsMS5zdWJzdHIoMCwgZm91bmQxKTtcbiAgICAgICAgICAgIGkxID0gZm91bmQxICsgcGFydGlhbDEubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGFmdGVyMSA9IGZ1bGwxLnN1YnN0cihpMSk7XG4gICAgICAgICAgICBpZiAoYmVmb3JlMCA9PT0gYmVmb3JlMSAmJiBhZnRlcjAgPT09IGFmdGVyMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZTogYmVmb3JlMCxcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXI6IGFmdGVyMCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBleHBhbmRab25lZE1hcmtlcihkYXRlSW5mbywgY2FsZW5kYXJTeXN0ZW0pIHtcbiAgICBsZXQgYSA9IGNhbGVuZGFyU3lzdGVtLm1hcmtlclRvQXJyYXkoZGF0ZUluZm8ubWFya2VyKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBtYXJrZXI6IGRhdGVJbmZvLm1hcmtlcixcbiAgICAgICAgdGltZVpvbmVPZmZzZXQ6IGRhdGVJbmZvLnRpbWVab25lT2Zmc2V0LFxuICAgICAgICBhcnJheTogYSxcbiAgICAgICAgeWVhcjogYVswXSxcbiAgICAgICAgbW9udGg6IGFbMV0sXG4gICAgICAgIGRheTogYVsyXSxcbiAgICAgICAgaG91cjogYVszXSxcbiAgICAgICAgbWludXRlOiBhWzRdLFxuICAgICAgICBzZWNvbmQ6IGFbNV0sXG4gICAgICAgIG1pbGxpc2Vjb25kOiBhWzZdLFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVZlcmJvc2VGb3JtYXR0aW5nQXJnKHN0YXJ0LCBlbmQsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpIHtcbiAgICBsZXQgc3RhcnRJbmZvID0gZXhwYW5kWm9uZWRNYXJrZXIoc3RhcnQsIGNvbnRleHQuY2FsZW5kYXJTeXN0ZW0pO1xuICAgIGxldCBlbmRJbmZvID0gZW5kID8gZXhwYW5kWm9uZWRNYXJrZXIoZW5kLCBjb250ZXh0LmNhbGVuZGFyU3lzdGVtKSA6IG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGF0ZTogc3RhcnRJbmZvLFxuICAgICAgICBzdGFydDogc3RhcnRJbmZvLFxuICAgICAgICBlbmQ6IGVuZEluZm8sXG4gICAgICAgIHRpbWVab25lOiBjb250ZXh0LnRpbWVab25lLFxuICAgICAgICBsb2NhbGVDb2RlczogY29udGV4dC5sb2NhbGUuY29kZXMsXG4gICAgICAgIGRlZmF1bHRTZXBhcmF0b3I6IGJldHRlckRlZmF1bHRTZXBhcmF0b3IgfHwgY29udGV4dC5kZWZhdWx0U2VwYXJhdG9yLFxuICAgIH07XG59XG5cbi8qXG5UT0RPOiBmaXggdGhlIHRlcm1pbm9sb2d5IG9mIFwiZm9ybWF0dGVyXCIgdnMgXCJmb3JtYXR0aW5nIGZ1bmNcIlxuKi9cbi8qXG5BdCB0aGUgdGltZSBvZiBpbnN0YW50aWF0aW9uLCB0aGlzIG9iamVjdCBkb2VzIG5vdCBrbm93IHdoaWNoIGNtZC1mb3JtYXR0aW5nIHN5c3RlbSBpdCB3aWxsIHVzZS5cbkl0IHJlY2VpdmVzIHRoaXMgYXQgdGhlIHRpbWUgb2YgZm9ybWF0dGluZywgYXMgYSBzZXR0aW5nLlxuKi9cbmNsYXNzIENtZEZvcm1hdHRlciB7XG4gICAgY29uc3RydWN0b3IoY21kU3RyKSB7XG4gICAgICAgIHRoaXMuY21kU3RyID0gY21kU3RyO1xuICAgIH1cbiAgICBmb3JtYXQoZGF0ZSwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gY29udGV4dC5jbWRGb3JtYXR0ZXIodGhpcy5jbWRTdHIsIGNyZWF0ZVZlcmJvc2VGb3JtYXR0aW5nQXJnKGRhdGUsIG51bGwsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpKTtcbiAgICB9XG4gICAgZm9ybWF0UmFuZ2Uoc3RhcnQsIGVuZCwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gY29udGV4dC5jbWRGb3JtYXR0ZXIodGhpcy5jbWRTdHIsIGNyZWF0ZVZlcmJvc2VGb3JtYXR0aW5nQXJnKHN0YXJ0LCBlbmQsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpKTtcbiAgICB9XG59XG5cbmNsYXNzIEZ1bmNGb3JtYXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGZ1bmMpIHtcbiAgICAgICAgdGhpcy5mdW5jID0gZnVuYztcbiAgICB9XG4gICAgZm9ybWF0KGRhdGUsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnVuYyhjcmVhdGVWZXJib3NlRm9ybWF0dGluZ0FyZyhkYXRlLCBudWxsLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSk7XG4gICAgfVxuICAgIGZvcm1hdFJhbmdlKHN0YXJ0LCBlbmQsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnVuYyhjcmVhdGVWZXJib3NlRm9ybWF0dGluZ0FyZyhzdGFydCwgZW5kLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVGb3JtYXR0ZXIoaW5wdXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiBpbnB1dCkgeyAvLyBub24tbnVsbCBvYmplY3RcbiAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVGb3JtYXR0ZXIoaW5wdXQpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gbmV3IENtZEZvcm1hdHRlcihpbnB1dCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jRm9ybWF0dGVyKGlucHV0KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbi8vIGJhc2Ugb3B0aW9uc1xuLy8gLS0tLS0tLS0tLS0tXG5jb25zdCBCQVNFX09QVElPTl9SRUZJTkVSUyA9IHtcbiAgICBuYXZMaW5rRGF5Q2xpY2s6IGlkZW50aXR5LFxuICAgIG5hdkxpbmtXZWVrQ2xpY2s6IGlkZW50aXR5LFxuICAgIGR1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBib290c3RyYXBGb250QXdlc29tZTogaWRlbnRpdHksXG4gICAgYnV0dG9uSWNvbnM6IGlkZW50aXR5LFxuICAgIGN1c3RvbUJ1dHRvbnM6IGlkZW50aXR5LFxuICAgIGRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBkZWZhdWx0VGltZWRFdmVudER1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBuZXh0RGF5VGhyZXNob2xkOiBjcmVhdGVEdXJhdGlvbixcbiAgICBzY3JvbGxUaW1lOiBjcmVhdGVEdXJhdGlvbixcbiAgICBzY3JvbGxUaW1lUmVzZXQ6IEJvb2xlYW4sXG4gICAgc2xvdE1pblRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxuICAgIHNsb3RNYXhUaW1lOiBjcmVhdGVEdXJhdGlvbixcbiAgICBkYXlQb3BvdmVyRm9ybWF0OiBjcmVhdGVGb3JtYXR0ZXIsXG4gICAgc2xvdER1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBzbmFwRHVyYXRpb246IGNyZWF0ZUR1cmF0aW9uLFxuICAgIGhlYWRlclRvb2xiYXI6IGlkZW50aXR5LFxuICAgIGZvb3RlclRvb2xiYXI6IGlkZW50aXR5LFxuICAgIGRlZmF1bHRSYW5nZVNlcGFyYXRvcjogU3RyaW5nLFxuICAgIHRpdGxlUmFuZ2VTZXBhcmF0b3I6IFN0cmluZyxcbiAgICBmb3JjZUV2ZW50RHVyYXRpb246IEJvb2xlYW4sXG4gICAgZGF5SGVhZGVyczogQm9vbGVhbixcbiAgICBkYXlIZWFkZXJGb3JtYXQ6IGNyZWF0ZUZvcm1hdHRlcixcbiAgICBkYXlIZWFkZXJDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBkYXlIZWFkZXJDb250ZW50OiBpZGVudGl0eSxcbiAgICBkYXlIZWFkZXJEaWRNb3VudDogaWRlbnRpdHksXG4gICAgZGF5SGVhZGVyV2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIGRheUNlbGxDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBkYXlDZWxsQ29udGVudDogaWRlbnRpdHksXG4gICAgZGF5Q2VsbERpZE1vdW50OiBpZGVudGl0eSxcbiAgICBkYXlDZWxsV2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIGluaXRpYWxWaWV3OiBTdHJpbmcsXG4gICAgYXNwZWN0UmF0aW86IE51bWJlcixcbiAgICB3ZWVrZW5kczogQm9vbGVhbixcbiAgICB3ZWVrTnVtYmVyQ2FsY3VsYXRpb246IGlkZW50aXR5LFxuICAgIHdlZWtOdW1iZXJzOiBCb29sZWFuLFxuICAgIHdlZWtOdW1iZXJDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICB3ZWVrTnVtYmVyQ29udGVudDogaWRlbnRpdHksXG4gICAgd2Vla051bWJlckRpZE1vdW50OiBpZGVudGl0eSxcbiAgICB3ZWVrTnVtYmVyV2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIGVkaXRhYmxlOiBCb29sZWFuLFxuICAgIHZpZXdDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICB2aWV3RGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIHZpZXdXaWxsVW5tb3VudDogaWRlbnRpdHksXG4gICAgbm93SW5kaWNhdG9yOiBCb29sZWFuLFxuICAgIG5vd0luZGljYXRvckNsYXNzTmFtZXM6IGlkZW50aXR5LFxuICAgIG5vd0luZGljYXRvckNvbnRlbnQ6IGlkZW50aXR5LFxuICAgIG5vd0luZGljYXRvckRpZE1vdW50OiBpZGVudGl0eSxcbiAgICBub3dJbmRpY2F0b3JXaWxsVW5tb3VudDogaWRlbnRpdHksXG4gICAgc2hvd05vbkN1cnJlbnREYXRlczogQm9vbGVhbixcbiAgICBsYXp5RmV0Y2hpbmc6IEJvb2xlYW4sXG4gICAgc3RhcnRQYXJhbTogU3RyaW5nLFxuICAgIGVuZFBhcmFtOiBTdHJpbmcsXG4gICAgdGltZVpvbmVQYXJhbTogU3RyaW5nLFxuICAgIHRpbWVab25lOiBTdHJpbmcsXG4gICAgbG9jYWxlczogaWRlbnRpdHksXG4gICAgbG9jYWxlOiBpZGVudGl0eSxcbiAgICB0aGVtZVN5c3RlbTogU3RyaW5nLFxuICAgIGRyYWdSZXZlcnREdXJhdGlvbjogTnVtYmVyLFxuICAgIGRyYWdTY3JvbGw6IEJvb2xlYW4sXG4gICAgYWxsRGF5TWFpbnRhaW5EdXJhdGlvbjogQm9vbGVhbixcbiAgICB1bnNlbGVjdEF1dG86IEJvb2xlYW4sXG4gICAgZHJvcEFjY2VwdDogaWRlbnRpdHksXG4gICAgZXZlbnRPcmRlcjogcGFyc2VGaWVsZFNwZWNzLFxuICAgIGV2ZW50T3JkZXJTdHJpY3Q6IEJvb2xlYW4sXG4gICAgaGFuZGxlV2luZG93UmVzaXplOiBCb29sZWFuLFxuICAgIHdpbmRvd1Jlc2l6ZURlbGF5OiBOdW1iZXIsXG4gICAgbG9uZ1ByZXNzRGVsYXk6IE51bWJlcixcbiAgICBldmVudERyYWdNaW5EaXN0YW5jZTogTnVtYmVyLFxuICAgIGV4cGFuZFJvd3M6IEJvb2xlYW4sXG4gICAgaGVpZ2h0OiBpZGVudGl0eSxcbiAgICBjb250ZW50SGVpZ2h0OiBpZGVudGl0eSxcbiAgICBkaXJlY3Rpb246IFN0cmluZyxcbiAgICB3ZWVrTnVtYmVyRm9ybWF0OiBjcmVhdGVGb3JtYXR0ZXIsXG4gICAgZXZlbnRSZXNpemFibGVGcm9tU3RhcnQ6IEJvb2xlYW4sXG4gICAgZGlzcGxheUV2ZW50VGltZTogQm9vbGVhbixcbiAgICBkaXNwbGF5RXZlbnRFbmQ6IEJvb2xlYW4sXG4gICAgd2Vla1RleHQ6IFN0cmluZyxcbiAgICB3ZWVrVGV4dExvbmc6IFN0cmluZyxcbiAgICBwcm9ncmVzc2l2ZUV2ZW50UmVuZGVyaW5nOiBCb29sZWFuLFxuICAgIGJ1c2luZXNzSG91cnM6IGlkZW50aXR5LFxuICAgIGluaXRpYWxEYXRlOiBpZGVudGl0eSxcbiAgICBub3c6IGlkZW50aXR5LFxuICAgIGV2ZW50RGF0YVRyYW5zZm9ybTogaWRlbnRpdHksXG4gICAgc3RpY2t5SGVhZGVyRGF0ZXM6IGlkZW50aXR5LFxuICAgIHN0aWNreUZvb3RlclNjcm9sbGJhcjogaWRlbnRpdHksXG4gICAgdmlld0hlaWdodDogaWRlbnRpdHksXG4gICAgZGVmYXVsdEFsbERheTogQm9vbGVhbixcbiAgICBldmVudFNvdXJjZUZhaWx1cmU6IGlkZW50aXR5LFxuICAgIGV2ZW50U291cmNlU3VjY2VzczogaWRlbnRpdHksXG4gICAgZXZlbnREaXNwbGF5OiBTdHJpbmcsXG4gICAgZXZlbnRTdGFydEVkaXRhYmxlOiBCb29sZWFuLFxuICAgIGV2ZW50RHVyYXRpb25FZGl0YWJsZTogQm9vbGVhbixcbiAgICBldmVudE92ZXJsYXA6IGlkZW50aXR5LFxuICAgIGV2ZW50Q29uc3RyYWludDogaWRlbnRpdHksXG4gICAgZXZlbnRBbGxvdzogaWRlbnRpdHksXG4gICAgZXZlbnRCYWNrZ3JvdW5kQ29sb3I6IFN0cmluZyxcbiAgICBldmVudEJvcmRlckNvbG9yOiBTdHJpbmcsXG4gICAgZXZlbnRUZXh0Q29sb3I6IFN0cmluZyxcbiAgICBldmVudENvbG9yOiBTdHJpbmcsXG4gICAgZXZlbnRDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBldmVudENvbnRlbnQ6IGlkZW50aXR5LFxuICAgIGV2ZW50RGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIGV2ZW50V2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIHNlbGVjdENvbnN0cmFpbnQ6IGlkZW50aXR5LFxuICAgIHNlbGVjdE92ZXJsYXA6IGlkZW50aXR5LFxuICAgIHNlbGVjdEFsbG93OiBpZGVudGl0eSxcbiAgICBkcm9wcGFibGU6IEJvb2xlYW4sXG4gICAgdW5zZWxlY3RDYW5jZWw6IFN0cmluZyxcbiAgICBzbG90TGFiZWxGb3JtYXQ6IGlkZW50aXR5LFxuICAgIHNsb3RMYW5lQ2xhc3NOYW1lczogaWRlbnRpdHksXG4gICAgc2xvdExhbmVDb250ZW50OiBpZGVudGl0eSxcbiAgICBzbG90TGFuZURpZE1vdW50OiBpZGVudGl0eSxcbiAgICBzbG90TGFuZVdpbGxVbm1vdW50OiBpZGVudGl0eSxcbiAgICBzbG90TGFiZWxDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBzbG90TGFiZWxDb250ZW50OiBpZGVudGl0eSxcbiAgICBzbG90TGFiZWxEaWRNb3VudDogaWRlbnRpdHksXG4gICAgc2xvdExhYmVsV2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIGRheU1heEV2ZW50czogaWRlbnRpdHksXG4gICAgZGF5TWF4RXZlbnRSb3dzOiBpZGVudGl0eSxcbiAgICBkYXlNaW5XaWR0aDogTnVtYmVyLFxuICAgIHNsb3RMYWJlbEludGVydmFsOiBjcmVhdGVEdXJhdGlvbixcbiAgICBhbGxEYXlUZXh0OiBTdHJpbmcsXG4gICAgYWxsRGF5Q2xhc3NOYW1lczogaWRlbnRpdHksXG4gICAgYWxsRGF5Q29udGVudDogaWRlbnRpdHksXG4gICAgYWxsRGF5RGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIGFsbERheVdpbGxVbm1vdW50OiBpZGVudGl0eSxcbiAgICBzbG90TWluV2lkdGg6IE51bWJlcixcbiAgICBuYXZMaW5rczogQm9vbGVhbixcbiAgICBldmVudFRpbWVGb3JtYXQ6IGNyZWF0ZUZvcm1hdHRlcixcbiAgICByZXJlbmRlckRlbGF5OiBOdW1iZXIsXG4gICAgbW9yZUxpbmtUZXh0OiBpZGVudGl0eSxcbiAgICBtb3JlTGlua0hpbnQ6IGlkZW50aXR5LFxuICAgIHNlbGVjdE1pbkRpc3RhbmNlOiBOdW1iZXIsXG4gICAgc2VsZWN0YWJsZTogQm9vbGVhbixcbiAgICBzZWxlY3RMb25nUHJlc3NEZWxheTogTnVtYmVyLFxuICAgIGV2ZW50TG9uZ1ByZXNzRGVsYXk6IE51bWJlcixcbiAgICBzZWxlY3RNaXJyb3I6IEJvb2xlYW4sXG4gICAgZXZlbnRNYXhTdGFjazogTnVtYmVyLFxuICAgIGV2ZW50TWluSGVpZ2h0OiBOdW1iZXIsXG4gICAgZXZlbnRNaW5XaWR0aDogTnVtYmVyLFxuICAgIGV2ZW50U2hvcnRIZWlnaHQ6IE51bWJlcixcbiAgICBzbG90RXZlbnRPdmVybGFwOiBCb29sZWFuLFxuICAgIHBsdWdpbnM6IGlkZW50aXR5LFxuICAgIGZpcnN0RGF5OiBOdW1iZXIsXG4gICAgZGF5Q291bnQ6IE51bWJlcixcbiAgICBkYXRlQWxpZ25tZW50OiBTdHJpbmcsXG4gICAgZGF0ZUluY3JlbWVudDogY3JlYXRlRHVyYXRpb24sXG4gICAgaGlkZGVuRGF5czogaWRlbnRpdHksXG4gICAgZml4ZWRXZWVrQ291bnQ6IEJvb2xlYW4sXG4gICAgdmFsaWRSYW5nZTogaWRlbnRpdHksXG4gICAgdmlzaWJsZVJhbmdlOiBpZGVudGl0eSxcbiAgICB0aXRsZUZvcm1hdDogaWRlbnRpdHksXG4gICAgZXZlbnRJbnRlcmFjdGl2ZTogQm9vbGVhbixcbiAgICAvLyBvbmx5IHVzZWQgYnkgbGlzdC12aWV3LCBidXQgbGFuZ3VhZ2VzIGRlZmluZSB0aGUgdmFsdWUsIHNvIHdlIG5lZWQgaXQgaW4gYmFzZSBvcHRpb25zXG4gICAgbm9FdmVudHNUZXh0OiBTdHJpbmcsXG4gICAgdmlld0hpbnQ6IGlkZW50aXR5LFxuICAgIG5hdkxpbmtIaW50OiBpZGVudGl0eSxcbiAgICBjbG9zZUhpbnQ6IFN0cmluZyxcbiAgICB0aW1lSGludDogU3RyaW5nLFxuICAgIGV2ZW50SGludDogU3RyaW5nLFxuICAgIG1vcmVMaW5rQ2xpY2s6IGlkZW50aXR5LFxuICAgIG1vcmVMaW5rQ2xhc3NOYW1lczogaWRlbnRpdHksXG4gICAgbW9yZUxpbmtDb250ZW50OiBpZGVudGl0eSxcbiAgICBtb3JlTGlua0RpZE1vdW50OiBpZGVudGl0eSxcbiAgICBtb3JlTGlua1dpbGxVbm1vdW50OiBpZGVudGl0eSxcbiAgICBtb250aFN0YXJ0Rm9ybWF0OiBjcmVhdGVGb3JtYXR0ZXIsXG4gICAgLy8gZm9yIGNvbm5lY3RvcnNcbiAgICAvLyAoY2FuJ3QgYmUgcGFydCBvZiBwbHVnaW4gc3lzdGVtIGIvYyBtdXN0IGJlIHByb3ZpZGVkIGF0IHJ1bnRpbWUpXG4gICAgaGFuZGxlQ3VzdG9tUmVuZGVyaW5nOiBpZGVudGl0eSxcbiAgICBjdXN0b21SZW5kZXJpbmdNZXRhTWFwOiBpZGVudGl0eSxcbiAgICBjdXN0b21SZW5kZXJpbmdSZXBsYWNlczogQm9vbGVhbixcbn07XG4vLyBkbyBOT1QgZ2l2ZSBhIHR5cGUgaGVyZS4gbmVlZCBgdHlwZW9mIEJBU0VfT1BUSU9OX0RFRkFVTFRTYCB0byBnaXZlIHJlYWwgcmVzdWx0cy5cbi8vIHJhdyB2YWx1ZXMuXG5jb25zdCBCQVNFX09QVElPTl9ERUZBVUxUUyA9IHtcbiAgICBldmVudERpc3BsYXk6ICdhdXRvJyxcbiAgICBkZWZhdWx0UmFuZ2VTZXBhcmF0b3I6ICcgLSAnLFxuICAgIHRpdGxlUmFuZ2VTZXBhcmF0b3I6ICcgXFx1MjAxMyAnLFxuICAgIGRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb246ICcwMTowMDowMCcsXG4gICAgZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb246IHsgZGF5OiAxIH0sXG4gICAgZm9yY2VFdmVudER1cmF0aW9uOiBmYWxzZSxcbiAgICBuZXh0RGF5VGhyZXNob2xkOiAnMDA6MDA6MDAnLFxuICAgIGRheUhlYWRlcnM6IHRydWUsXG4gICAgaW5pdGlhbFZpZXc6ICcnLFxuICAgIGFzcGVjdFJhdGlvOiAxLjM1LFxuICAgIGhlYWRlclRvb2xiYXI6IHtcbiAgICAgICAgc3RhcnQ6ICd0aXRsZScsXG4gICAgICAgIGNlbnRlcjogJycsXG4gICAgICAgIGVuZDogJ3RvZGF5IHByZXYsbmV4dCcsXG4gICAgfSxcbiAgICB3ZWVrZW5kczogdHJ1ZSxcbiAgICB3ZWVrTnVtYmVyczogZmFsc2UsXG4gICAgd2Vla051bWJlckNhbGN1bGF0aW9uOiAnbG9jYWwnLFxuICAgIGVkaXRhYmxlOiBmYWxzZSxcbiAgICBub3dJbmRpY2F0b3I6IGZhbHNlLFxuICAgIHNjcm9sbFRpbWU6ICcwNjowMDowMCcsXG4gICAgc2Nyb2xsVGltZVJlc2V0OiB0cnVlLFxuICAgIHNsb3RNaW5UaW1lOiAnMDA6MDA6MDAnLFxuICAgIHNsb3RNYXhUaW1lOiAnMjQ6MDA6MDAnLFxuICAgIHNob3dOb25DdXJyZW50RGF0ZXM6IHRydWUsXG4gICAgbGF6eUZldGNoaW5nOiB0cnVlLFxuICAgIHN0YXJ0UGFyYW06ICdzdGFydCcsXG4gICAgZW5kUGFyYW06ICdlbmQnLFxuICAgIHRpbWVab25lUGFyYW06ICd0aW1lWm9uZScsXG4gICAgdGltZVpvbmU6ICdsb2NhbCcsXG4gICAgbG9jYWxlczogW10sXG4gICAgbG9jYWxlOiAnJyxcbiAgICB0aGVtZVN5c3RlbTogJ3N0YW5kYXJkJyxcbiAgICBkcmFnUmV2ZXJ0RHVyYXRpb246IDUwMCxcbiAgICBkcmFnU2Nyb2xsOiB0cnVlLFxuICAgIGFsbERheU1haW50YWluRHVyYXRpb246IGZhbHNlLFxuICAgIHVuc2VsZWN0QXV0bzogdHJ1ZSxcbiAgICBkcm9wQWNjZXB0OiAnKicsXG4gICAgZXZlbnRPcmRlcjogJ3N0YXJ0LC1kdXJhdGlvbixhbGxEYXksdGl0bGUnLFxuICAgIGRheVBvcG92ZXJGb3JtYXQ6IHsgbW9udGg6ICdsb25nJywgZGF5OiAnbnVtZXJpYycsIHllYXI6ICdudW1lcmljJyB9LFxuICAgIGhhbmRsZVdpbmRvd1Jlc2l6ZTogdHJ1ZSxcbiAgICB3aW5kb3dSZXNpemVEZWxheTogMTAwLFxuICAgIGxvbmdQcmVzc0RlbGF5OiAxMDAwLFxuICAgIGV2ZW50RHJhZ01pbkRpc3RhbmNlOiA1LFxuICAgIGV4cGFuZFJvd3M6IGZhbHNlLFxuICAgIG5hdkxpbmtzOiBmYWxzZSxcbiAgICBzZWxlY3RhYmxlOiBmYWxzZSxcbiAgICBldmVudE1pbkhlaWdodDogMTUsXG4gICAgZXZlbnRNaW5XaWR0aDogMzAsXG4gICAgZXZlbnRTaG9ydEhlaWdodDogMzAsXG4gICAgbW9udGhTdGFydEZvcm1hdDogeyBtb250aDogJ2xvbmcnLCBkYXk6ICdudW1lcmljJyB9LFxufTtcbi8vIGNhbGVuZGFyIGxpc3RlbmVyc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG5jb25zdCBDQUxFTkRBUl9MSVNURU5FUl9SRUZJTkVSUyA9IHtcbiAgICBkYXRlc1NldDogaWRlbnRpdHksXG4gICAgZXZlbnRzU2V0OiBpZGVudGl0eSxcbiAgICBldmVudEFkZDogaWRlbnRpdHksXG4gICAgZXZlbnRDaGFuZ2U6IGlkZW50aXR5LFxuICAgIGV2ZW50UmVtb3ZlOiBpZGVudGl0eSxcbiAgICB3aW5kb3dSZXNpemU6IGlkZW50aXR5LFxuICAgIGV2ZW50Q2xpY2s6IGlkZW50aXR5LFxuICAgIGV2ZW50TW91c2VFbnRlcjogaWRlbnRpdHksXG4gICAgZXZlbnRNb3VzZUxlYXZlOiBpZGVudGl0eSxcbiAgICBzZWxlY3Q6IGlkZW50aXR5LFxuICAgIHVuc2VsZWN0OiBpZGVudGl0eSxcbiAgICBsb2FkaW5nOiBpZGVudGl0eSxcbiAgICAvLyBpbnRlcm5hbFxuICAgIF91bm1vdW50OiBpZGVudGl0eSxcbiAgICBfYmVmb3JlcHJpbnQ6IGlkZW50aXR5LFxuICAgIF9hZnRlcnByaW50OiBpZGVudGl0eSxcbiAgICBfbm9FdmVudERyb3A6IGlkZW50aXR5LFxuICAgIF9ub0V2ZW50UmVzaXplOiBpZGVudGl0eSxcbiAgICBfcmVzaXplOiBpZGVudGl0eSxcbiAgICBfc2Nyb2xsUmVxdWVzdDogaWRlbnRpdHksXG59O1xuLy8gY2FsZW5kYXItc3BlY2lmaWMgb3B0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuY29uc3QgQ0FMRU5EQVJfT1BUSU9OX1JFRklORVJTID0ge1xuICAgIGJ1dHRvblRleHQ6IGlkZW50aXR5LFxuICAgIGJ1dHRvbkhpbnRzOiBpZGVudGl0eSxcbiAgICB2aWV3czogaWRlbnRpdHksXG4gICAgcGx1Z2luczogaWRlbnRpdHksXG4gICAgaW5pdGlhbEV2ZW50czogaWRlbnRpdHksXG4gICAgZXZlbnRzOiBpZGVudGl0eSxcbiAgICBldmVudFNvdXJjZXM6IGlkZW50aXR5LFxufTtcbmNvbnN0IENPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTID0ge1xuICAgIGhlYWRlclRvb2xiYXI6IGlzTWF5YmVPYmplY3RzRXF1YWwsXG4gICAgZm9vdGVyVG9vbGJhcjogaXNNYXliZU9iamVjdHNFcXVhbCxcbiAgICBidXR0b25UZXh0OiBpc01heWJlT2JqZWN0c0VxdWFsLFxuICAgIGJ1dHRvbkhpbnRzOiBpc01heWJlT2JqZWN0c0VxdWFsLFxuICAgIGJ1dHRvbkljb25zOiBpc01heWJlT2JqZWN0c0VxdWFsLFxuICAgIGRhdGVJbmNyZW1lbnQ6IGlzTWF5YmVPYmplY3RzRXF1YWwsXG4gICAgcGx1Z2luczogaXNNYXliZUFycmF5c0VxdWFsLFxuICAgIGV2ZW50czogaXNNYXliZUFycmF5c0VxdWFsLFxuICAgIGV2ZW50U291cmNlczogaXNNYXliZUFycmF5c0VxdWFsLFxuICAgIFsncmVzb3VyY2VzJ106IGlzTWF5YmVBcnJheXNFcXVhbCxcbn07XG5mdW5jdGlvbiBpc01heWJlT2JqZWN0c0VxdWFsKGEsIGIpIHtcbiAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnICYmIHR5cGVvZiBiID09PSAnb2JqZWN0JyAmJiBhICYmIGIpIHsgLy8gYm90aCBub24tbnVsbCBvYmplY3RzXG4gICAgICAgIHJldHVybiBpc1Byb3BzRXF1YWwoYSwgYik7XG4gICAgfVxuICAgIHJldHVybiBhID09PSBiO1xufVxuZnVuY3Rpb24gaXNNYXliZUFycmF5c0VxdWFsKGEsIGIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSAmJiBBcnJheS5pc0FycmF5KGIpKSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5c0VxdWFsKGEsIGIpO1xuICAgIH1cbiAgICByZXR1cm4gYSA9PT0gYjtcbn1cbi8vIHZpZXctc3BlY2lmaWMgb3B0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5jb25zdCBWSUVXX09QVElPTl9SRUZJTkVSUyA9IHtcbiAgICB0eXBlOiBTdHJpbmcsXG4gICAgY29tcG9uZW50OiBpZGVudGl0eSxcbiAgICBidXR0b25UZXh0OiBTdHJpbmcsXG4gICAgYnV0dG9uVGV4dEtleTogU3RyaW5nLFxuICAgIGRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3M6IGlkZW50aXR5LFxuICAgIHVzZXNNaW5NYXhUaW1lOiBCb29sZWFuLFxuICAgIGNsYXNzTmFtZXM6IGlkZW50aXR5LFxuICAgIGNvbnRlbnQ6IGlkZW50aXR5LFxuICAgIGRpZE1vdW50OiBpZGVudGl0eSxcbiAgICB3aWxsVW5tb3VudDogaWRlbnRpdHksXG59O1xuLy8gdXRpbCBmdW5jc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gbWVyZ2VSYXdPcHRpb25zKG9wdGlvblNldHMpIHtcbiAgICByZXR1cm4gbWVyZ2VQcm9wcyhvcHRpb25TZXRzLCBDT01QTEVYX09QVElPTl9DT01QQVJBVE9SUyk7XG59XG5mdW5jdGlvbiByZWZpbmVQcm9wcyhpbnB1dCwgcmVmaW5lcnMpIHtcbiAgICBsZXQgcmVmaW5lZCA9IHt9O1xuICAgIGxldCBleHRyYSA9IHt9O1xuICAgIGZvciAobGV0IHByb3BOYW1lIGluIHJlZmluZXJzKSB7XG4gICAgICAgIGlmIChwcm9wTmFtZSBpbiBpbnB1dCkge1xuICAgICAgICAgICAgcmVmaW5lZFtwcm9wTmFtZV0gPSByZWZpbmVyc1twcm9wTmFtZV0oaW5wdXRbcHJvcE5hbWVdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBwcm9wTmFtZSBpbiBpbnB1dCkge1xuICAgICAgICBpZiAoIShwcm9wTmFtZSBpbiByZWZpbmVycykpIHtcbiAgICAgICAgICAgIGV4dHJhW3Byb3BOYW1lXSA9IGlucHV0W3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyByZWZpbmVkLCBleHRyYSB9O1xufVxuZnVuY3Rpb24gaWRlbnRpdHkocmF3KSB7XG4gICAgcmV0dXJuIHJhdztcbn1cblxuY29uc3QgeyBoYXNPd25Qcm9wZXJ0eSB9ID0gT2JqZWN0LnByb3RvdHlwZTtcbi8vIE1lcmdlcyBhbiBhcnJheSBvZiBvYmplY3RzIGludG8gYSBzaW5nbGUgb2JqZWN0LlxuLy8gVGhlIHNlY29uZCBhcmd1bWVudCBhbGxvd3MgZm9yIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIHdobydzIG9iamVjdCB2YWx1ZXMgd2lsbCBiZSBtZXJnZWQgdG9nZXRoZXIuXG5mdW5jdGlvbiBtZXJnZVByb3BzKHByb3BPYmpzLCBjb21wbGV4UHJvcHNNYXApIHtcbiAgICBsZXQgZGVzdCA9IHt9O1xuICAgIGlmIChjb21wbGV4UHJvcHNNYXApIHtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBjb21wbGV4UHJvcHNNYXApIHtcbiAgICAgICAgICAgIGlmIChjb21wbGV4UHJvcHNNYXBbbmFtZV0gPT09IGlzTWF5YmVPYmplY3RzRXF1YWwpIHsgLy8gaW1wbGllcyB0aGF0IGl0J3Mgb2JqZWN0LW1lcmdlYWJsZVxuICAgICAgICAgICAgICAgIGxldCBjb21wbGV4T2JqcyA9IFtdO1xuICAgICAgICAgICAgICAgIC8vIGNvbGxlY3QgdGhlIHRyYWlsaW5nIG9iamVjdCB2YWx1ZXMsIHN0b3BwaW5nIHdoZW4gYSBub24tb2JqZWN0IGlzIGRpc2NvdmVyZWRcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gcHJvcE9ianMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbCA9IHByb3BPYmpzW2ldW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdmFsKSB7IC8vIG5vbi1udWxsIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxleE9ianMudW5zaGlmdCh2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0W25hbWVdID0gdmFsOyAvLyBpZiB0aGVyZSB3ZXJlIG5vIG9iamVjdHMsIHRoaXMgdmFsdWUgd2lsbCBiZSB1c2VkXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgdHJhaWxpbmcgdmFsdWVzIHdlcmUgb2JqZWN0cywgdXNlIHRoZSBtZXJnZWQgdmFsdWVcbiAgICAgICAgICAgICAgICBpZiAoY29tcGxleE9ianMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc3RbbmFtZV0gPSBtZXJnZVByb3BzKGNvbXBsZXhPYmpzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gY29weSB2YWx1ZXMgaW50byB0aGUgZGVzdGluYXRpb24sIGdvaW5nIGZyb20gbGFzdCB0byBmaXJzdFxuICAgIGZvciAobGV0IGkgPSBwcm9wT2Jqcy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICBsZXQgcHJvcHMgPSBwcm9wT2Jqc1tpXTtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBwcm9wcykge1xuICAgICAgICAgICAgaWYgKCEobmFtZSBpbiBkZXN0KSkgeyAvLyBpZiBhbHJlYWR5IGFzc2lnbmVkIGJ5IHByZXZpb3VzIHByb3BzIG9yIGNvbXBsZXggcHJvcHMsIGRvbid0IHJlYXNzaWduXG4gICAgICAgICAgICAgICAgZGVzdFtuYW1lXSA9IHByb3BzW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xufVxuZnVuY3Rpb24gZmlsdGVySGFzaChoYXNoLCBmdW5jKSB7XG4gICAgbGV0IGZpbHRlcmVkID0ge307XG4gICAgZm9yIChsZXQga2V5IGluIGhhc2gpIHtcbiAgICAgICAgaWYgKGZ1bmMoaGFzaFtrZXldLCBrZXkpKSB7XG4gICAgICAgICAgICBmaWx0ZXJlZFtrZXldID0gaGFzaFtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmaWx0ZXJlZDtcbn1cbmZ1bmN0aW9uIG1hcEhhc2goaGFzaCwgZnVuYykge1xuICAgIGxldCBuZXdIYXNoID0ge307XG4gICAgZm9yIChsZXQga2V5IGluIGhhc2gpIHtcbiAgICAgICAgbmV3SGFzaFtrZXldID0gZnVuYyhoYXNoW2tleV0sIGtleSk7XG4gICAgfVxuICAgIHJldHVybiBuZXdIYXNoO1xufVxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYSkge1xuICAgIGxldCBoYXNoID0ge307XG4gICAgZm9yIChsZXQgaXRlbSBvZiBhKSB7XG4gICAgICAgIGhhc2hbaXRlbV0gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gaGFzaDtcbn1cbi8vIFRPRE86IHJlYXNzZXNzIGJyb3dzZXIgc3VwcG9ydFxuLy8gaHR0cHM6Ly9jYW5pdXNlLmNvbS8/c2VhcmNoPW9iamVjdC52YWx1ZXNcbmZ1bmN0aW9uIGhhc2hWYWx1ZXNUb0FycmF5KG9iaikge1xuICAgIGxldCBhID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG9iaikge1xuICAgICAgICBhLnB1c2gob2JqW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbn1cbmZ1bmN0aW9uIGlzUHJvcHNFcXVhbChvYmowLCBvYmoxKSB7XG4gICAgaWYgKG9iajAgPT09IG9iajEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZvciAobGV0IGtleSBpbiBvYmowKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iajAsIGtleSkpIHtcbiAgICAgICAgICAgIGlmICghKGtleSBpbiBvYmoxKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBrZXkgaW4gb2JqMSkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmoxLCBrZXkpKSB7XG4gICAgICAgICAgICBpZiAob2JqMFtrZXldICE9PSBvYmoxW2tleV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5jb25zdCBIQU5ETEVSX1JFID0gL15vbltBLVpdLztcbmZ1bmN0aW9uIGlzTm9uSGFuZGxlclByb3BzRXF1YWwob2JqMCwgb2JqMSkge1xuICAgIGNvbnN0IGtleXMgPSBnZXRVbmVxdWFsUHJvcHMob2JqMCwgb2JqMSk7XG4gICAgZm9yIChsZXQga2V5IG9mIGtleXMpIHtcbiAgICAgICAgaWYgKCFIQU5ETEVSX1JFLnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0VW5lcXVhbFByb3BzKG9iajAsIG9iajEpIHtcbiAgICBsZXQga2V5cyA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvYmowKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iajAsIGtleSkpIHtcbiAgICAgICAgICAgIGlmICghKGtleSBpbiBvYmoxKSkge1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGtleSBpbiBvYmoxKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iajEsIGtleSkpIHtcbiAgICAgICAgICAgIGlmIChvYmowW2tleV0gIT09IG9iajFba2V5XSkge1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xufVxuZnVuY3Rpb24gY29tcGFyZU9ianMob2xkUHJvcHMsIG5ld1Byb3BzLCBlcXVhbGl0eUZ1bmNzID0ge30pIHtcbiAgICBpZiAob2xkUHJvcHMgPT09IG5ld1Byb3BzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmb3IgKGxldCBrZXkgaW4gbmV3UHJvcHMpIHtcbiAgICAgICAgaWYgKGtleSBpbiBvbGRQcm9wcyAmJiBpc09ialZhbHNFcXVhbChvbGRQcm9wc1trZXldLCBuZXdQcm9wc1trZXldLCBlcXVhbGl0eUZ1bmNzW2tleV0pKSA7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGNoZWNrIGZvciBwcm9wcyB0aGF0IHdlcmUgb21pdHRlZCBpbiB0aGUgbmV3XG4gICAgZm9yIChsZXQga2V5IGluIG9sZFByb3BzKSB7XG4gICAgICAgIGlmICghKGtleSBpbiBuZXdQcm9wcykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qXG5hc3N1bWVkIFwidHJ1ZVwiIGVxdWFsaXR5IGZvciBoYW5kbGVyIG5hbWVzIGxpa2UgXCJvblJlY2VpdmVTb21ldGhpbmdcIlxuKi9cbmZ1bmN0aW9uIGlzT2JqVmFsc0VxdWFsKHZhbDAsIHZhbDEsIGNvbXBhcmF0b3IpIHtcbiAgICBpZiAodmFsMCA9PT0gdmFsMSB8fCBjb21wYXJhdG9yID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoY29tcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gY29tcGFyYXRvcih2YWwwLCB2YWwxKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY29sbGVjdEZyb21IYXNoKGhhc2gsIHN0YXJ0SW5kZXggPSAwLCBlbmRJbmRleCwgc3RlcCA9IDEpIHtcbiAgICBsZXQgcmVzID0gW107XG4gICAgaWYgKGVuZEluZGV4ID09IG51bGwpIHtcbiAgICAgICAgZW5kSW5kZXggPSBPYmplY3Qua2V5cyhoYXNoKS5sZW5ndGg7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXg7IGkgKz0gc3RlcCkge1xuICAgICAgICBsZXQgdmFsID0gaGFzaFtpXTtcbiAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7IC8vIHdpbGwgZGlzcmVnYXJkIHVuZGVmaW5lZCBmb3Igc3BhcnNlIGFycmF5c1xuICAgICAgICAgICAgcmVzLnB1c2godmFsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5sZXQgY2FsZW5kYXJTeXN0ZW1DbGFzc01hcCA9IHt9O1xuZnVuY3Rpb24gcmVnaXN0ZXJDYWxlbmRhclN5c3RlbShuYW1lLCB0aGVDbGFzcykge1xuICAgIGNhbGVuZGFyU3lzdGVtQ2xhc3NNYXBbbmFtZV0gPSB0aGVDbGFzcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNhbGVuZGFyU3lzdGVtKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IGNhbGVuZGFyU3lzdGVtQ2xhc3NNYXBbbmFtZV0oKTtcbn1cbmNsYXNzIEdyZWdvcmlhbkNhbGVuZGFyU3lzdGVtIHtcbiAgICBnZXRNYXJrZXJZZWFyKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICB9XG4gICAgZ2V0TWFya2VyTW9udGgoZCkge1xuICAgICAgICByZXR1cm4gZC5nZXRVVENNb250aCgpO1xuICAgIH1cbiAgICBnZXRNYXJrZXJEYXkoZCkge1xuICAgICAgICByZXR1cm4gZC5nZXRVVENEYXRlKCk7XG4gICAgfVxuICAgIGFycmF5VG9NYXJrZXIoYXJyKSB7XG4gICAgICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShhcnIpO1xuICAgIH1cbiAgICBtYXJrZXJUb0FycmF5KG1hcmtlcikge1xuICAgICAgICByZXR1cm4gZGF0ZVRvVXRjQXJyYXkobWFya2VyKTtcbiAgICB9XG59XG5yZWdpc3RlckNhbGVuZGFyU3lzdGVtKCdncmVnb3J5JywgR3JlZ29yaWFuQ2FsZW5kYXJTeXN0ZW0pO1xuXG5jb25zdCBJU09fUkUgPSAvXlxccyooXFxkezR9KSgtPyhcXGR7Mn0pKC0/KFxcZHsyfSkoW1QgXShcXGR7Mn0pOj8oXFxkezJ9KSg6PyhcXGR7Mn0pKFxcLihcXGQrKSk/KT8oWnwoKFstK10pKFxcZHsyfSkoOj8oXFxkezJ9KSk/KSk/KT8pPyk/JC87XG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgICBsZXQgbSA9IElTT19SRS5leGVjKHN0cik7XG4gICAgaWYgKG0pIHtcbiAgICAgICAgbGV0IG1hcmtlciA9IG5ldyBEYXRlKERhdGUuVVRDKE51bWJlcihtWzFdKSwgbVszXSA/IE51bWJlcihtWzNdKSAtIDEgOiAwLCBOdW1iZXIobVs1XSB8fCAxKSwgTnVtYmVyKG1bN10gfHwgMCksIE51bWJlcihtWzhdIHx8IDApLCBOdW1iZXIobVsxMF0gfHwgMCksIG1bMTJdID8gTnVtYmVyKGAwLiR7bVsxMl19YCkgKiAxMDAwIDogMCkpO1xuICAgICAgICBpZiAoaXNWYWxpZERhdGUobWFya2VyKSkge1xuICAgICAgICAgICAgbGV0IHRpbWVab25lT2Zmc2V0ID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChtWzEzXSkge1xuICAgICAgICAgICAgICAgIHRpbWVab25lT2Zmc2V0ID0gKG1bMTVdID09PSAnLScgPyAtMSA6IDEpICogKE51bWJlcihtWzE2XSB8fCAwKSAqIDYwICtcbiAgICAgICAgICAgICAgICAgICAgTnVtYmVyKG1bMThdIHx8IDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWFya2VyLFxuICAgICAgICAgICAgICAgIGlzVGltZVVuc3BlY2lmaWVkOiAhbVs2XSxcbiAgICAgICAgICAgICAgICB0aW1lWm9uZU9mZnNldCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmNsYXNzIERhdGVFbnYge1xuICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgICAgIGxldCB0aW1lWm9uZSA9IHRoaXMudGltZVpvbmUgPSBzZXR0aW5ncy50aW1lWm9uZTtcbiAgICAgICAgbGV0IGlzTmFtZWRUaW1lWm9uZSA9IHRpbWVab25lICE9PSAnbG9jYWwnICYmIHRpbWVab25lICE9PSAnVVRDJztcbiAgICAgICAgaWYgKHNldHRpbmdzLm5hbWVkVGltZVpvbmVJbXBsICYmIGlzTmFtZWRUaW1lWm9uZSkge1xuICAgICAgICAgICAgdGhpcy5uYW1lZFRpbWVab25lSW1wbCA9IG5ldyBzZXR0aW5ncy5uYW1lZFRpbWVab25lSW1wbCh0aW1lWm9uZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYW5Db21wdXRlT2Zmc2V0ID0gQm9vbGVhbighaXNOYW1lZFRpbWVab25lIHx8IHRoaXMubmFtZWRUaW1lWm9uZUltcGwpO1xuICAgICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtID0gY3JlYXRlQ2FsZW5kYXJTeXN0ZW0oc2V0dGluZ3MuY2FsZW5kYXJTeXN0ZW0pO1xuICAgICAgICB0aGlzLmxvY2FsZSA9IHNldHRpbmdzLmxvY2FsZTtcbiAgICAgICAgdGhpcy53ZWVrRG93ID0gc2V0dGluZ3MubG9jYWxlLndlZWsuZG93O1xuICAgICAgICB0aGlzLndlZWtEb3kgPSBzZXR0aW5ncy5sb2NhbGUud2Vlay5kb3k7XG4gICAgICAgIGlmIChzZXR0aW5ncy53ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPT09ICdJU08nKSB7XG4gICAgICAgICAgICB0aGlzLndlZWtEb3cgPSAxO1xuICAgICAgICAgICAgdGhpcy53ZWVrRG95ID0gNDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLmZpcnN0RGF5ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy53ZWVrRG93ID0gc2V0dGluZ3MuZmlyc3REYXk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy53ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMud2Vla051bWJlckZ1bmMgPSBzZXR0aW5ncy53ZWVrTnVtYmVyQ2FsY3VsYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53ZWVrVGV4dCA9IHNldHRpbmdzLndlZWtUZXh0ICE9IG51bGwgPyBzZXR0aW5ncy53ZWVrVGV4dCA6IHNldHRpbmdzLmxvY2FsZS5vcHRpb25zLndlZWtUZXh0O1xuICAgICAgICB0aGlzLndlZWtUZXh0TG9uZyA9IChzZXR0aW5ncy53ZWVrVGV4dExvbmcgIT0gbnVsbCA/IHNldHRpbmdzLndlZWtUZXh0TG9uZyA6IHNldHRpbmdzLmxvY2FsZS5vcHRpb25zLndlZWtUZXh0TG9uZykgfHwgdGhpcy53ZWVrVGV4dDtcbiAgICAgICAgdGhpcy5jbWRGb3JtYXR0ZXIgPSBzZXR0aW5ncy5jbWRGb3JtYXR0ZXI7XG4gICAgICAgIHRoaXMuZGVmYXVsdFNlcGFyYXRvciA9IHNldHRpbmdzLmRlZmF1bHRTZXBhcmF0b3I7XG4gICAgfVxuICAgIC8vIENyZWF0aW5nIC8gUGFyc2luZ1xuICAgIGNyZWF0ZU1hcmtlcihpbnB1dCkge1xuICAgICAgICBsZXQgbWV0YSA9IHRoaXMuY3JlYXRlTWFya2VyTWV0YShpbnB1dCk7XG4gICAgICAgIGlmIChtZXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWV0YS5tYXJrZXI7XG4gICAgfVxuICAgIGNyZWF0ZU5vd01hcmtlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuQ29tcHV0ZU9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGltZXN0YW1wVG9NYXJrZXIobmV3IERhdGUoKS52YWx1ZU9mKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHdlIGNhbid0IGNvbXB1dGUgdGhlIGN1cnJlbnQgZGF0ZSB2YWwgZm9yIGEgdGltZXpvbmUsXG4gICAgICAgIC8vIGJldHRlciB0byBnaXZlIHRoZSBjdXJyZW50IGxvY2FsIGRhdGUgdmFscyB0aGFuIFVUQ1xuICAgICAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoZGF0ZVRvTG9jYWxBcnJheShuZXcgRGF0ZSgpKSk7XG4gICAgfVxuICAgIGNyZWF0ZU1hcmtlck1ldGEoaW5wdXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbWFya2VyID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIG1hcmtlciA9IHRoaXMudGltZXN0YW1wVG9NYXJrZXIoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgICAgICBpZiAoIWlzTmFOKGlucHV0KSkge1xuICAgICAgICAgICAgICAgIG1hcmtlciA9IHRoaXMudGltZXN0YW1wVG9NYXJrZXIoaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICBtYXJrZXIgPSBhcnJheVRvVXRjRGF0ZShpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmtlciA9PT0gbnVsbCB8fCAhaXNWYWxpZERhdGUobWFya2VyKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbWFya2VyLCBpc1RpbWVVbnNwZWNpZmllZDogZmFsc2UsIGZvcmNlZFR6bzogbnVsbCB9O1xuICAgIH1cbiAgICBwYXJzZShzKSB7XG4gICAgICAgIGxldCBwYXJ0cyA9IHBhcnNlKHMpO1xuICAgICAgICBpZiAocGFydHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IG1hcmtlciB9ID0gcGFydHM7XG4gICAgICAgIGxldCBmb3JjZWRUem8gPSBudWxsO1xuICAgICAgICBpZiAocGFydHMudGltZVpvbmVPZmZzZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbkNvbXB1dGVPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXIgPSB0aGlzLnRpbWVzdGFtcFRvTWFya2VyKG1hcmtlci52YWx1ZU9mKCkgLSBwYXJ0cy50aW1lWm9uZU9mZnNldCAqIDYwICogMTAwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3JjZWRUem8gPSBwYXJ0cy50aW1lWm9uZU9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtYXJrZXIsIGlzVGltZVVuc3BlY2lmaWVkOiBwYXJ0cy5pc1RpbWVVbnNwZWNpZmllZCwgZm9yY2VkVHpvIH07XG4gICAgfVxuICAgIC8vIEFjY2Vzc29yc1xuICAgIGdldFllYXIobWFya2VyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobWFya2VyKTtcbiAgICB9XG4gICAgZ2V0TW9udGgobWFya2VyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG1hcmtlcik7XG4gICAgfVxuICAgIGdldERheShtYXJrZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyRGF5KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIEFkZGluZyAvIFN1YnRyYWN0aW5nXG4gICAgYWRkKG1hcmtlciwgZHVyKSB7XG4gICAgICAgIGxldCBhID0gdGhpcy5jYWxlbmRhclN5c3RlbS5tYXJrZXJUb0FycmF5KG1hcmtlcik7XG4gICAgICAgIGFbMF0gKz0gZHVyLnllYXJzO1xuICAgICAgICBhWzFdICs9IGR1ci5tb250aHM7XG4gICAgICAgIGFbMl0gKz0gZHVyLmRheXM7XG4gICAgICAgIGFbNl0gKz0gZHVyLm1pbGxpc2Vjb25kcztcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihhKTtcbiAgICB9XG4gICAgc3VidHJhY3QobWFya2VyLCBkdXIpIHtcbiAgICAgICAgbGV0IGEgPSB0aGlzLmNhbGVuZGFyU3lzdGVtLm1hcmtlclRvQXJyYXkobWFya2VyKTtcbiAgICAgICAgYVswXSAtPSBkdXIueWVhcnM7XG4gICAgICAgIGFbMV0gLT0gZHVyLm1vbnRocztcbiAgICAgICAgYVsyXSAtPSBkdXIuZGF5cztcbiAgICAgICAgYVs2XSAtPSBkdXIubWlsbGlzZWNvbmRzO1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5hcnJheVRvTWFya2VyKGEpO1xuICAgIH1cbiAgICBhZGRZZWFycyhtYXJrZXIsIG4pIHtcbiAgICAgICAgbGV0IGEgPSB0aGlzLmNhbGVuZGFyU3lzdGVtLm1hcmtlclRvQXJyYXkobWFya2VyKTtcbiAgICAgICAgYVswXSArPSBuO1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5hcnJheVRvTWFya2VyKGEpO1xuICAgIH1cbiAgICBhZGRNb250aHMobWFya2VyLCBuKSB7XG4gICAgICAgIGxldCBhID0gdGhpcy5jYWxlbmRhclN5c3RlbS5tYXJrZXJUb0FycmF5KG1hcmtlcik7XG4gICAgICAgIGFbMV0gKz0gbjtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihhKTtcbiAgICB9XG4gICAgLy8gRGlmZmluZyBXaG9sZSBVbml0c1xuICAgIGRpZmZXaG9sZVllYXJzKG0wLCBtMSkge1xuICAgICAgICBsZXQgeyBjYWxlbmRhclN5c3RlbSB9ID0gdGhpcztcbiAgICAgICAgaWYgKHRpbWVBc01zKG0wKSA9PT0gdGltZUFzTXMobTEpICYmXG4gICAgICAgICAgICBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJEYXkobTApID09PSBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJEYXkobTEpICYmXG4gICAgICAgICAgICBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtMCkgPT09IGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG0xKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobTEpIC0gY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGRpZmZXaG9sZU1vbnRocyhtMCwgbTEpIHtcbiAgICAgICAgbGV0IHsgY2FsZW5kYXJTeXN0ZW0gfSA9IHRoaXM7XG4gICAgICAgIGlmICh0aW1lQXNNcyhtMCkgPT09IHRpbWVBc01zKG0xKSAmJlxuICAgICAgICAgICAgY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyRGF5KG0wKSA9PT0gY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyRGF5KG0xKSkge1xuICAgICAgICAgICAgcmV0dXJuIChjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtMSkgLSBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtMCkpICtcbiAgICAgICAgICAgICAgICAoY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtMSkgLSBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG0wKSkgKiAxMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gUmFuZ2UgLyBEdXJhdGlvblxuICAgIGdyZWF0ZXN0V2hvbGVVbml0KG0wLCBtMSkge1xuICAgICAgICBsZXQgbiA9IHRoaXMuZGlmZldob2xlWWVhcnMobTAsIG0xKTtcbiAgICAgICAgaWYgKG4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICd5ZWFyJywgdmFsdWU6IG4gfTtcbiAgICAgICAgfVxuICAgICAgICBuID0gdGhpcy5kaWZmV2hvbGVNb250aHMobTAsIG0xKTtcbiAgICAgICAgaWYgKG4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdtb250aCcsIHZhbHVlOiBuIH07XG4gICAgICAgIH1cbiAgICAgICAgbiA9IGRpZmZXaG9sZVdlZWtzKG0wLCBtMSk7XG4gICAgICAgIGlmIChuICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnd2VlaycsIHZhbHVlOiBuIH07XG4gICAgICAgIH1cbiAgICAgICAgbiA9IGRpZmZXaG9sZURheXMobTAsIG0xKTtcbiAgICAgICAgaWYgKG4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdkYXknLCB2YWx1ZTogbiB9O1xuICAgICAgICB9XG4gICAgICAgIG4gPSBkaWZmSG91cnMobTAsIG0xKTtcbiAgICAgICAgaWYgKGlzSW50KG4pKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnaG91cicsIHZhbHVlOiBuIH07XG4gICAgICAgIH1cbiAgICAgICAgbiA9IGRpZmZNaW51dGVzKG0wLCBtMSk7XG4gICAgICAgIGlmIChpc0ludChuKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ21pbnV0ZScsIHZhbHVlOiBuIH07XG4gICAgICAgIH1cbiAgICAgICAgbiA9IGRpZmZTZWNvbmRzKG0wLCBtMSk7XG4gICAgICAgIGlmIChpc0ludChuKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ3NlY29uZCcsIHZhbHVlOiBuIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdW5pdDogJ21pbGxpc2Vjb25kJywgdmFsdWU6IG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSB9O1xuICAgIH1cbiAgICBjb3VudER1cmF0aW9uc0JldHdlZW4obTAsIG0xLCBkKSB7XG4gICAgICAgIC8vIFRPRE86IGNhbiB1c2UgZ3JlYXRlc3RXaG9sZVVuaXRcbiAgICAgICAgbGV0IGRpZmY7XG4gICAgICAgIGlmIChkLnllYXJzKSB7XG4gICAgICAgICAgICBkaWZmID0gdGhpcy5kaWZmV2hvbGVZZWFycyhtMCwgbTEpO1xuICAgICAgICAgICAgaWYgKGRpZmYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlmZiAvIGFzUm91Z2hZZWFycyhkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZC5tb250aHMpIHtcbiAgICAgICAgICAgIGRpZmYgPSB0aGlzLmRpZmZXaG9sZU1vbnRocyhtMCwgbTEpO1xuICAgICAgICAgICAgaWYgKGRpZmYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlmZiAvIGFzUm91Z2hNb250aHMoZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGQuZGF5cykge1xuICAgICAgICAgICAgZGlmZiA9IGRpZmZXaG9sZURheXMobTAsIG0xKTtcbiAgICAgICAgICAgIGlmIChkaWZmICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpZmYgLyBhc1JvdWdoRGF5cyhkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSkgLyBhc1JvdWdoTXMoZCk7XG4gICAgfVxuICAgIC8vIFN0YXJ0LU9mXG4gICAgLy8gdGhlc2UgRE9OJ1QgcmV0dXJuIHpvbmVkLWRhdGVzLiBvbmx5IFVUQyBzdGFydC1vZiBkYXRlc1xuICAgIHN0YXJ0T2YobSwgdW5pdCkge1xuICAgICAgICBpZiAodW5pdCA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydE9mWWVhcihtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5pdCA9PT0gJ21vbnRoJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRPZk1vbnRoKG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0ID09PSAnd2VlaycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0T2ZXZWVrKG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0ID09PSAnZGF5Jykge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0T2ZEYXkobSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuaXQgPT09ICdob3VyJykge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0T2ZIb3VyKG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0ID09PSAnbWludXRlJykge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0T2ZNaW51dGUobSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuaXQgPT09ICdzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnRPZlNlY29uZChtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc3RhcnRPZlllYXIobSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5hcnJheVRvTWFya2VyKFtcbiAgICAgICAgICAgIHRoaXMuY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtKSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIHN0YXJ0T2ZNb250aChtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoW1xuICAgICAgICAgICAgdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG0pLFxuICAgICAgICAgICAgdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtKSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIHN0YXJ0T2ZXZWVrKG0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihbXG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobSksXG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG0pLFxuICAgICAgICAgICAgbS5nZXRVVENEYXRlKCkgLSAoKG0uZ2V0VVRDRGF5KCkgLSB0aGlzLndlZWtEb3cgKyA3KSAlIDcpLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLy8gV2VlayBOdW1iZXJcbiAgICBjb21wdXRlV2Vla051bWJlcihtYXJrZXIpIHtcbiAgICAgICAgaWYgKHRoaXMud2Vla051bWJlckZ1bmMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndlZWtOdW1iZXJGdW5jKHRoaXMudG9EYXRlKG1hcmtlcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKG1hcmtlciwgdGhpcy53ZWVrRG93LCB0aGlzLndlZWtEb3kpO1xuICAgIH1cbiAgICAvLyBUT0RPOiBjaG9rZSBvbiB0aW1lWm9uZU5hbWU6IGxvbmdcbiAgICBmb3JtYXQobWFya2VyLCBmb3JtYXR0ZXIsIGRhdGVPcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXQoe1xuICAgICAgICAgICAgbWFya2VyLFxuICAgICAgICAgICAgdGltZVpvbmVPZmZzZXQ6IGRhdGVPcHRpb25zLmZvcmNlZFR6byAhPSBudWxsID9cbiAgICAgICAgICAgICAgICBkYXRlT3B0aW9ucy5mb3JjZWRUem8gOlxuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0Rm9yTWFya2VyKG1hcmtlciksXG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgICBmb3JtYXRSYW5nZShzdGFydCwgZW5kLCBmb3JtYXR0ZXIsIGRhdGVPcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKGRhdGVPcHRpb25zLmlzRW5kRXhjbHVzaXZlKSB7XG4gICAgICAgICAgICBlbmQgPSBhZGRNcyhlbmQsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdFJhbmdlKHtcbiAgICAgICAgICAgIG1hcmtlcjogc3RhcnQsXG4gICAgICAgICAgICB0aW1lWm9uZU9mZnNldDogZGF0ZU9wdGlvbnMuZm9yY2VkU3RhcnRUem8gIT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgZGF0ZU9wdGlvbnMuZm9yY2VkU3RhcnRUem8gOlxuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0Rm9yTWFya2VyKHN0YXJ0KSxcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbWFya2VyOiBlbmQsXG4gICAgICAgICAgICB0aW1lWm9uZU9mZnNldDogZGF0ZU9wdGlvbnMuZm9yY2VkRW5kVHpvICE9IG51bGwgP1xuICAgICAgICAgICAgICAgIGRhdGVPcHRpb25zLmZvcmNlZEVuZFR6byA6XG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRGb3JNYXJrZXIoZW5kKSxcbiAgICAgICAgfSwgdGhpcywgZGF0ZU9wdGlvbnMuZGVmYXVsdFNlcGFyYXRvcik7XG4gICAgfVxuICAgIC8qXG4gICAgRFVNQjogdGhlIG9taXRUaW1lIGFyZyBpcyBkdW1iLiBpZiB3ZSBvbWl0IHRoZSB0aW1lLCB3ZSB3YW50IHRvIG9taXQgdGhlIHRpbWV6b25lIG9mZnNldC4gYW5kIGlmIHdlIGRvIHRoYXQsXG4gICAgbWlnaHQgYXMgd2VsbCB1c2UgYnVpbGRJc29TdHJpbmcgb3Igc29tZSBvdGhlciB1dGlsIGRpcmVjdGx5XG4gICAgKi9cbiAgICBmb3JtYXRJc28obWFya2VyLCBleHRyYU9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgdGltZVpvbmVPZmZzZXQgPSBudWxsO1xuICAgICAgICBpZiAoIWV4dHJhT3B0aW9ucy5vbWl0VGltZVpvbmVPZmZzZXQpIHtcbiAgICAgICAgICAgIGlmIChleHRyYU9wdGlvbnMuZm9yY2VkVHpvICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aW1lWm9uZU9mZnNldCA9IGV4dHJhT3B0aW9ucy5mb3JjZWRUem87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aW1lWm9uZU9mZnNldCA9IHRoaXMub2Zmc2V0Rm9yTWFya2VyKG1hcmtlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1aWxkSXNvU3RyaW5nKG1hcmtlciwgdGltZVpvbmVPZmZzZXQsIGV4dHJhT3B0aW9ucy5vbWl0VGltZSk7XG4gICAgfVxuICAgIC8vIFRpbWVab25lXG4gICAgdGltZXN0YW1wVG9NYXJrZXIobXMpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZVpvbmUgPT09ICdsb2NhbCcpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShkYXRlVG9Mb2NhbEFycmF5KG5ldyBEYXRlKG1zKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRpbWVab25lID09PSAnVVRDJyB8fCAhdGhpcy5uYW1lZFRpbWVab25lSW1wbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG1zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUodGhpcy5uYW1lZFRpbWVab25lSW1wbC50aW1lc3RhbXBUb0FycmF5KG1zKSk7XG4gICAgfVxuICAgIG9mZnNldEZvck1hcmtlcihtKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVab25lID09PSAnbG9jYWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gLWFycmF5VG9Mb2NhbERhdGUoZGF0ZVRvVXRjQXJyYXkobSkpLmdldFRpbWV6b25lT2Zmc2V0KCk7IC8vIGNvbnZlcnQgXCJpbnZlcnNlXCIgb2Zmc2V0IHRvIFwibm9ybWFsXCIgb2Zmc2V0XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudGltZVpvbmUgPT09ICdVVEMnKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5uYW1lZFRpbWVab25lSW1wbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmFtZWRUaW1lWm9uZUltcGwub2Zmc2V0Rm9yQXJyYXkoZGF0ZVRvVXRjQXJyYXkobSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBDb252ZXJzaW9uXG4gICAgdG9EYXRlKG0sIGZvcmNlZFR6bykge1xuICAgICAgICBpZiAodGhpcy50aW1lWm9uZSA9PT0gJ2xvY2FsJykge1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5VG9Mb2NhbERhdGUoZGF0ZVRvVXRjQXJyYXkobSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRpbWVab25lID09PSAnVVRDJykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG0udmFsdWVPZigpKTsgLy8gbWFrZSBzdXJlIGl0J3MgYSBjb3B5XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm5hbWVkVGltZVpvbmVJbXBsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUobS52YWx1ZU9mKCkgLSAoZm9yY2VkVHpvIHx8IDApKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IERhdGUobS52YWx1ZU9mKCkgLVxuICAgICAgICAgICAgdGhpcy5uYW1lZFRpbWVab25lSW1wbC5vZmZzZXRGb3JBcnJheShkYXRlVG9VdGNBcnJheShtKSkgKiAxMDAwICogNjApO1xuICAgIH1cbn1cblxuY2xhc3MgVGhlbWUge1xuICAgIGNvbnN0cnVjdG9yKGNhbGVuZGFyT3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5pY29uT3ZlcnJpZGVPcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SWNvbk92ZXJyaWRlKGNhbGVuZGFyT3B0aW9uc1t0aGlzLmljb25PdmVycmlkZU9wdGlvbl0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldEljb25PdmVycmlkZShpY29uT3ZlcnJpZGVIYXNoKSB7XG4gICAgICAgIGxldCBpY29uQ2xhc3Nlc0NvcHk7XG4gICAgICAgIGxldCBidXR0b25OYW1lO1xuICAgICAgICBpZiAodHlwZW9mIGljb25PdmVycmlkZUhhc2ggPT09ICdvYmplY3QnICYmIGljb25PdmVycmlkZUhhc2gpIHsgLy8gbm9uLW51bGwgb2JqZWN0XG4gICAgICAgICAgICBpY29uQ2xhc3Nlc0NvcHkgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmljb25DbGFzc2VzKTtcbiAgICAgICAgICAgIGZvciAoYnV0dG9uTmFtZSBpbiBpY29uT3ZlcnJpZGVIYXNoKSB7XG4gICAgICAgICAgICAgICAgaWNvbkNsYXNzZXNDb3B5W2J1dHRvbk5hbWVdID0gdGhpcy5hcHBseUljb25PdmVycmlkZVByZWZpeChpY29uT3ZlcnJpZGVIYXNoW2J1dHRvbk5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaWNvbkNsYXNzZXMgPSBpY29uQ2xhc3Nlc0NvcHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaWNvbk92ZXJyaWRlSGFzaCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuaWNvbkNsYXNzZXMgPSB7fTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhcHBseUljb25PdmVycmlkZVByZWZpeChjbGFzc05hbWUpIHtcbiAgICAgICAgbGV0IHByZWZpeCA9IHRoaXMuaWNvbk92ZXJyaWRlUHJlZml4O1xuICAgICAgICBpZiAocHJlZml4ICYmIGNsYXNzTmFtZS5pbmRleE9mKHByZWZpeCkgIT09IDApIHsgLy8gaWYgbm90IGFscmVhZHkgcHJlc2VudFxuICAgICAgICAgICAgY2xhc3NOYW1lID0gcHJlZml4ICsgY2xhc3NOYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbGFzc05hbWU7XG4gICAgfVxuICAgIGdldENsYXNzKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGFzc2VzW2tleV0gfHwgJyc7XG4gICAgfVxuICAgIGdldEljb25DbGFzcyhidXR0b25OYW1lLCBpc1J0bCkge1xuICAgICAgICBsZXQgY2xhc3NOYW1lO1xuICAgICAgICBpZiAoaXNSdGwgJiYgdGhpcy5ydGxJY29uQ2xhc3Nlcykge1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gdGhpcy5ydGxJY29uQ2xhc3Nlc1tidXR0b25OYW1lXSB8fCB0aGlzLmljb25DbGFzc2VzW2J1dHRvbk5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gdGhpcy5pY29uQ2xhc3Nlc1tidXR0b25OYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5iYXNlSWNvbkNsYXNzfSAke2NsYXNzTmFtZX1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgZ2V0Q3VzdG9tQnV0dG9uSWNvbkNsYXNzKGN1c3RvbUJ1dHRvblByb3BzKSB7XG4gICAgICAgIGxldCBjbGFzc05hbWU7XG4gICAgICAgIGlmICh0aGlzLmljb25PdmVycmlkZUN1c3RvbUJ1dHRvbk9wdGlvbikge1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gY3VzdG9tQnV0dG9uUHJvcHNbdGhpcy5pY29uT3ZlcnJpZGVDdXN0b21CdXR0b25PcHRpb25dO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLmJhc2VJY29uQ2xhc3N9ICR7dGhpcy5hcHBseUljb25PdmVycmlkZVByZWZpeChjbGFzc05hbWUpfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbn1cblRoZW1lLnByb3RvdHlwZS5jbGFzc2VzID0ge307XG5UaGVtZS5wcm90b3R5cGUuaWNvbkNsYXNzZXMgPSB7fTtcblRoZW1lLnByb3RvdHlwZS5iYXNlSWNvbkNsYXNzID0gJyc7XG5UaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlUHJlZml4ID0gJyc7XG5cbi8qXG5OT1RFOiB0aGlzIGNhbiBiZSBhIHB1YmxpYyBBUEksIGVzcGVjaWFsbHkgY3JlYXRlRWxlbWVudCBmb3IgaG9va3MuXG5TZWUgZXhhbXBsZXMvdHlwZXNjcmlwdC1zY2hlZHVsZXIvc3JjL2luZGV4LnRzXG4qL1xuZnVuY3Rpb24gZmx1c2hTeW5jKHJ1bkJlZm9yZUZsdXNoKSB7XG4gICAgcnVuQmVmb3JlRmx1c2goKTtcbiAgICBsZXQgb2xkRGVib3VuY2VSZW5kZXJpbmcgPSBwcmVhY3Qub3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZzsgLy8gb3JpZ1xuICAgIGxldCBjYWxsYmFja1EgPSBbXTtcbiAgICBmdW5jdGlvbiBleGVjQ2FsbGJhY2tTeW5jKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrUS5wdXNoKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgcHJlYWN0Lm9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmcgPSBleGVjQ2FsbGJhY2tTeW5jO1xuICAgIHByZWFjdC5yZW5kZXIocHJlYWN0LmNyZWF0ZUVsZW1lbnQoRmFrZUNvbXBvbmVudCwge30pLCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSk7XG4gICAgd2hpbGUgKGNhbGxiYWNrUS5sZW5ndGgpIHtcbiAgICAgICAgY2FsbGJhY2tRLnNoaWZ0KCkoKTtcbiAgICB9XG4gICAgcHJlYWN0Lm9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmcgPSBvbGREZWJvdW5jZVJlbmRlcmluZztcbn1cbmNsYXNzIEZha2VDb21wb25lbnQgZXh0ZW5kcyBwcmVhY3QuQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7IHJldHVybiBwcmVhY3QuY3JlYXRlRWxlbWVudCgnZGl2Jywge30pOyB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7IHRoaXMuc2V0U3RhdGUoe30pOyB9XG59XG4vLyBUT0RPOiB1c2UgcHJlYWN0L2NvbXBhdCBpbnN0ZWFkP1xuZnVuY3Rpb24gY3JlYXRlQ29udGV4dChkZWZhdWx0VmFsdWUpIHtcbiAgICBsZXQgQ29udGV4dFR5cGUgPSBwcmVhY3QuY3JlYXRlQ29udGV4dChkZWZhdWx0VmFsdWUpO1xuICAgIGxldCBvcmlnUHJvdmlkZXIgPSBDb250ZXh0VHlwZS5Qcm92aWRlcjtcbiAgICBDb250ZXh0VHlwZS5Qcm92aWRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbGV0IGlzTmV3ID0gIXRoaXMuZ2V0Q2hpbGRDb250ZXh0O1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBvcmlnUHJvdmlkZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItcmVzdC1wYXJhbXNcbiAgICAgICAgaWYgKGlzTmV3KSB7XG4gICAgICAgICAgICBsZXQgc3VicyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5zaG91bGRDb21wb25lbnRVcGRhdGUgPSAoX3Byb3BzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMudmFsdWUgIT09IF9wcm9wcy52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzdWJzLmZvckVhY2goKGMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuY29udGV4dCA9IF9wcm9wcy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuc3ViID0gKGMpID0+IHtcbiAgICAgICAgICAgICAgICBzdWJzLnB1c2goYyk7XG4gICAgICAgICAgICAgICAgbGV0IG9sZCA9IGMuY29tcG9uZW50V2lsbFVubW91bnQ7XG4gICAgICAgICAgICAgICAgYy5jb21wb25lbnRXaWxsVW5tb3VudCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc3Vicy5zcGxpY2Uoc3Vicy5pbmRleE9mKGMpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgb2xkICYmIG9sZC5jYWxsKGMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICB9O1xuICAgIHJldHVybiBDb250ZXh0VHlwZTtcbn1cblxuY2xhc3MgU2Nyb2xsUmVzcG9uZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihleGVjRnVuYywgZW1pdHRlciwgc2Nyb2xsVGltZSwgc2Nyb2xsVGltZVJlc2V0KSB7XG4gICAgICAgIHRoaXMuZXhlY0Z1bmMgPSBleGVjRnVuYztcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gZW1pdHRlcjtcbiAgICAgICAgdGhpcy5zY3JvbGxUaW1lID0gc2Nyb2xsVGltZTtcbiAgICAgICAgdGhpcy5zY3JvbGxUaW1lUmVzZXQgPSBzY3JvbGxUaW1lUmVzZXQ7XG4gICAgICAgIHRoaXMuaGFuZGxlU2Nyb2xsUmVxdWVzdCA9IChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnF1ZXVlZFJlcXVlc3QgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnF1ZXVlZFJlcXVlc3QgfHwge30sIHJlcXVlc3QpO1xuICAgICAgICAgICAgdGhpcy5kcmFpbigpO1xuICAgICAgICB9O1xuICAgICAgICBlbWl0dGVyLm9uKCdfc2Nyb2xsUmVxdWVzdCcsIHRoaXMuaGFuZGxlU2Nyb2xsUmVxdWVzdCk7XG4gICAgICAgIHRoaXMuZmlyZUluaXRpYWxTY3JvbGwoKTtcbiAgICB9XG4gICAgZGV0YWNoKCkge1xuICAgICAgICB0aGlzLmVtaXR0ZXIub2ZmKCdfc2Nyb2xsUmVxdWVzdCcsIHRoaXMuaGFuZGxlU2Nyb2xsUmVxdWVzdCk7XG4gICAgfVxuICAgIHVwZGF0ZShpc0RhdGVzTmV3KSB7XG4gICAgICAgIGlmIChpc0RhdGVzTmV3ICYmIHRoaXMuc2Nyb2xsVGltZVJlc2V0KSB7XG4gICAgICAgICAgICB0aGlzLmZpcmVJbml0aWFsU2Nyb2xsKCk7IC8vIHdpbGwgZHJhaW5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZHJhaW4oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaXJlSW5pdGlhbFNjcm9sbCgpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGxSZXF1ZXN0KHtcbiAgICAgICAgICAgIHRpbWU6IHRoaXMuc2Nyb2xsVGltZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRyYWluKCkge1xuICAgICAgICBpZiAodGhpcy5xdWV1ZWRSZXF1ZXN0ICYmIHRoaXMuZXhlY0Z1bmModGhpcy5xdWV1ZWRSZXF1ZXN0KSkge1xuICAgICAgICAgICAgdGhpcy5xdWV1ZWRSZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgVmlld0NvbnRleHRUeXBlID0gY3JlYXRlQ29udGV4dCh7fSk7IC8vIGZvciBDb21wb25lbnRzXG5mdW5jdGlvbiBidWlsZFZpZXdDb250ZXh0KHZpZXdTcGVjLCB2aWV3QXBpLCB2aWV3T3B0aW9ucywgZGF0ZVByb2ZpbGVHZW5lcmF0b3IsIGRhdGVFbnYsIHRoZW1lLCBwbHVnaW5Ib29rcywgZGlzcGF0Y2gsIGdldEN1cnJlbnREYXRhLCBlbWl0dGVyLCBjYWxlbmRhckFwaSwgcmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCwgdW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGF0ZUVudixcbiAgICAgICAgb3B0aW9uczogdmlld09wdGlvbnMsXG4gICAgICAgIHBsdWdpbkhvb2tzLFxuICAgICAgICBlbWl0dGVyLFxuICAgICAgICBkaXNwYXRjaCxcbiAgICAgICAgZ2V0Q3VycmVudERhdGEsXG4gICAgICAgIGNhbGVuZGFyQXBpLFxuICAgICAgICB2aWV3U3BlYyxcbiAgICAgICAgdmlld0FwaSxcbiAgICAgICAgZGF0ZVByb2ZpbGVHZW5lcmF0b3IsXG4gICAgICAgIHRoZW1lLFxuICAgICAgICBpc1J0bDogdmlld09wdGlvbnMuZGlyZWN0aW9uID09PSAncnRsJyxcbiAgICAgICAgYWRkUmVzaXplSGFuZGxlcihoYW5kbGVyKSB7XG4gICAgICAgICAgICBlbWl0dGVyLm9uKCdfcmVzaXplJywgaGFuZGxlcik7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZVJlc2l6ZUhhbmRsZXIoaGFuZGxlcikge1xuICAgICAgICAgICAgZW1pdHRlci5vZmYoJ19yZXNpemUnLCBoYW5kbGVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlU2Nyb2xsUmVzcG9uZGVyKGV4ZWNGdW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNjcm9sbFJlc3BvbmRlcihleGVjRnVuYywgZW1pdHRlciwgY3JlYXRlRHVyYXRpb24odmlld09wdGlvbnMuc2Nyb2xsVGltZSksIHZpZXdPcHRpb25zLnNjcm9sbFRpbWVSZXNldCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQsXG4gICAgICAgIHVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCxcbiAgICB9O1xufVxuXG4vKiBlc2xpbnQgbWF4LWNsYXNzZXMtcGVyLWZpbGU6IG9mZiAqL1xuY2xhc3MgUHVyZUNvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlKSB7XG4gICAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgY29uc29sZS5sb2coZ2V0VW5lcXVhbFByb3BzKG5leHRQcm9wcywgdGhpcy5wcm9wcyksIGdldFVuZXF1YWxQcm9wcyhuZXh0U3RhdGUsIHRoaXMuc3RhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIWNvbXBhcmVPYmpzKHRoaXMucHJvcHMsIG5leHRQcm9wcywgdGhpcy5wcm9wRXF1YWxpdHkpIHx8XG4gICAgICAgICAgICAhY29tcGFyZU9ianModGhpcy5zdGF0ZSwgbmV4dFN0YXRlLCB0aGlzLnN0YXRlRXF1YWxpdHkpO1xuICAgIH1cbiAgICAvLyBIQUNLIGZvciBmcmVha2luJyBSZWFjdCBTdHJpY3RNb2RlXG4gICAgc2FmZVNldFN0YXRlKG5ld1N0YXRlKSB7XG4gICAgICAgIGlmICghY29tcGFyZU9ianModGhpcy5zdGF0ZSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnN0YXRlKSwgbmV3U3RhdGUpLCB0aGlzLnN0YXRlRXF1YWxpdHkpKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKG5ld1N0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblB1cmVDb21wb25lbnQuYWRkUHJvcHNFcXVhbGl0eSA9IGFkZFByb3BzRXF1YWxpdHk7XG5QdXJlQ29tcG9uZW50LmFkZFN0YXRlRXF1YWxpdHkgPSBhZGRTdGF0ZUVxdWFsaXR5O1xuUHVyZUNvbXBvbmVudC5jb250ZXh0VHlwZSA9IFZpZXdDb250ZXh0VHlwZTtcblB1cmVDb21wb25lbnQucHJvdG90eXBlLnByb3BFcXVhbGl0eSA9IHt9O1xuUHVyZUNvbXBvbmVudC5wcm90b3R5cGUuc3RhdGVFcXVhbGl0eSA9IHt9O1xuY2xhc3MgQmFzZUNvbXBvbmVudCBleHRlbmRzIFB1cmVDb21wb25lbnQge1xufVxuQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZSA9IFZpZXdDb250ZXh0VHlwZTtcbmZ1bmN0aW9uIGFkZFByb3BzRXF1YWxpdHkocHJvcEVxdWFsaXR5KSB7XG4gICAgbGV0IGhhc2ggPSBPYmplY3QuY3JlYXRlKHRoaXMucHJvdG90eXBlLnByb3BFcXVhbGl0eSk7XG4gICAgT2JqZWN0LmFzc2lnbihoYXNoLCBwcm9wRXF1YWxpdHkpO1xuICAgIHRoaXMucHJvdG90eXBlLnByb3BFcXVhbGl0eSA9IGhhc2g7XG59XG5mdW5jdGlvbiBhZGRTdGF0ZUVxdWFsaXR5KHN0YXRlRXF1YWxpdHkpIHtcbiAgICBsZXQgaGFzaCA9IE9iamVjdC5jcmVhdGUodGhpcy5wcm90b3R5cGUuc3RhdGVFcXVhbGl0eSk7XG4gICAgT2JqZWN0LmFzc2lnbihoYXNoLCBzdGF0ZUVxdWFsaXR5KTtcbiAgICB0aGlzLnByb3RvdHlwZS5zdGF0ZUVxdWFsaXR5ID0gaGFzaDtcbn1cbi8vIHVzZSBvdGhlciBvbmVcbmZ1bmN0aW9uIHNldFJlZihyZWYsIGN1cnJlbnQpIHtcbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZWYoY3VycmVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlZikge1xuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzAyOVxuICAgICAgICByZWYuY3VycmVudCA9IGN1cnJlbnQ7XG4gICAgfVxufVxuXG5jbGFzcyBDb250ZW50SW5qZWN0b3IgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5pZCA9IGd1aWQoKTtcbiAgICAgICAgdGhpcy5xdWV1ZWREb21Ob2RlcyA9IFtdO1xuICAgICAgICB0aGlzLmN1cnJlbnREb21Ob2RlcyA9IFtdO1xuICAgICAgICB0aGlzLmhhbmRsZUVsID0gKGVsKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG9wdGlvbnMgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgICAgIGNvbnN0IHsgZ2VuZXJhdG9yTmFtZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5jdXN0b21SZW5kZXJpbmdSZXBsYWNlcyB8fCAhaGFzQ3VzdG9tUmVuZGVyaW5nSGFuZGxlcihnZW5lcmF0b3JOYW1lLCBvcHRpb25zKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRWxSZWYoZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZUVsUmVmID0gKGVsKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5lbFJlZikge1xuICAgICAgICAgICAgICAgIHNldFJlZih0aGlzLnByb3BzLmVsUmVmLCBlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSBjb250ZXh0O1xuICAgICAgICBjb25zdCB7IGN1c3RvbUdlbmVyYXRvciwgZGVmYXVsdEdlbmVyYXRvciwgcmVuZGVyUHJvcHMgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCBhdHRycyA9IGJ1aWxkRWxBdHRycyhwcm9wcywgW10sIHRoaXMuaGFuZGxlRWwpO1xuICAgICAgICBsZXQgdXNlRGVmYXVsdCA9IGZhbHNlO1xuICAgICAgICBsZXQgaW5uZXJDb250ZW50O1xuICAgICAgICBsZXQgcXVldWVkRG9tTm9kZXMgPSBbXTtcbiAgICAgICAgbGV0IGN1cnJlbnRHZW5lcmF0b3JNZXRhO1xuICAgICAgICBpZiAoY3VzdG9tR2VuZXJhdG9yICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1c3RvbUdlbmVyYXRvclJlcyA9IHR5cGVvZiBjdXN0b21HZW5lcmF0b3IgPT09ICdmdW5jdGlvbicgP1xuICAgICAgICAgICAgICAgIGN1c3RvbUdlbmVyYXRvcihyZW5kZXJQcm9wcywgY3JlYXRlRWxlbWVudCkgOlxuICAgICAgICAgICAgICAgIGN1c3RvbUdlbmVyYXRvcjtcbiAgICAgICAgICAgIGlmIChjdXN0b21HZW5lcmF0b3JSZXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB1c2VEZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzT2JqZWN0ID0gY3VzdG9tR2VuZXJhdG9yUmVzICYmIHR5cGVvZiBjdXN0b21HZW5lcmF0b3JSZXMgPT09ICdvYmplY3QnOyAvLyBub24tbnVsbFxuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdCAmJiAoJ2h0bWwnIGluIGN1c3RvbUdlbmVyYXRvclJlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cnMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPSB7IF9faHRtbDogY3VzdG9tR2VuZXJhdG9yUmVzLmh0bWwgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QgJiYgKCdkb21Ob2RlcycgaW4gY3VzdG9tR2VuZXJhdG9yUmVzKSkge1xuICAgICAgICAgICAgICAgICAgICBxdWV1ZWREb21Ob2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGN1c3RvbUdlbmVyYXRvclJlcy5kb21Ob2Rlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0XG4gICAgICAgICAgICAgICAgICAgID8gaXNWYWxpZEVsZW1lbnQoY3VzdG9tR2VuZXJhdG9yUmVzKSAvLyB2ZG9tIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgOiB0eXBlb2YgY3VzdG9tR2VuZXJhdG9yUmVzICE9PSAnZnVuY3Rpb24nIC8vIHByaW1pdGl2ZSB2YWx1ZSAobGlrZSBzdHJpbmcgb3IgbnVtYmVyKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAvLyB1c2UgaW4gdmRvbVxuICAgICAgICAgICAgICAgICAgICBpbm5lckNvbnRlbnQgPSBjdXN0b21HZW5lcmF0b3JSZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBhbiBleG90aWMgb2JqZWN0IGZvciBoYW5kbGVDdXN0b21SZW5kZXJpbmdcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEdlbmVyYXRvck1ldGEgPSBjdXN0b21HZW5lcmF0b3JSZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXNlRGVmYXVsdCA9ICFoYXNDdXN0b21SZW5kZXJpbmdIYW5kbGVyKHByb3BzLmdlbmVyYXRvck5hbWUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VEZWZhdWx0ICYmIGRlZmF1bHRHZW5lcmF0b3IpIHtcbiAgICAgICAgICAgIGlubmVyQ29udGVudCA9IGRlZmF1bHRHZW5lcmF0b3IocmVuZGVyUHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucXVldWVkRG9tTm9kZXMgPSBxdWV1ZWREb21Ob2RlcztcbiAgICAgICAgdGhpcy5jdXJyZW50R2VuZXJhdG9yTWV0YSA9IGN1cnJlbnRHZW5lcmF0b3JNZXRhO1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChwcm9wcy5lbFRhZywgYXR0cnMsIGlubmVyQ29udGVudCk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLmFwcGx5UXVldWV1ZERvbU5vZGVzKCk7XG4gICAgICAgIHRoaXMudHJpZ2dlckN1c3RvbVJlbmRlcmluZyh0cnVlKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICB0aGlzLmFwcGx5UXVldWV1ZERvbU5vZGVzKCk7XG4gICAgICAgIHRoaXMudHJpZ2dlckN1c3RvbVJlbmRlcmluZyh0cnVlKTtcbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlckN1c3RvbVJlbmRlcmluZyhmYWxzZSk7IC8vIFRPRE86IGRpZmZlcmVudCBBUEkgZm9yIHJlbW92YWw/XG4gICAgfVxuICAgIHRyaWdnZXJDdXN0b21SZW5kZXJpbmcoaXNBY3RpdmUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGhhbmRsZUN1c3RvbVJlbmRlcmluZywgY3VzdG9tUmVuZGVyaW5nTWV0YU1hcCB9ID0gY29udGV4dC5vcHRpb25zO1xuICAgICAgICBpZiAoaGFuZGxlQ3VzdG9tUmVuZGVyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBnZW5lcmF0b3JNZXRhID0gKF9hID0gdGhpcy5jdXJyZW50R2VuZXJhdG9yTWV0YSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY3VzdG9tUmVuZGVyaW5nTWV0YU1hcCA9PT0gbnVsbCB8fCBjdXN0b21SZW5kZXJpbmdNZXRhTWFwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXN0b21SZW5kZXJpbmdNZXRhTWFwW3Byb3BzLmdlbmVyYXRvck5hbWVdO1xuICAgICAgICAgICAgaWYgKGdlbmVyYXRvck1ldGEpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVDdXN0b21SZW5kZXJpbmcoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgaWQ6IHRoaXMuaWQsIGlzQWN0aXZlLCBjb250YWluZXJFbDogdGhpcy5iYXNlLCByZXBvcnROZXdDb250YWluZXJFbDogdGhpcy51cGRhdGVFbFJlZiwgLy8gZnJvbnQtZW5kIGZyYW1ld29yayB0ZWxscyB1cyBhYm91dCBuZXcgY29udGFpbmVyIGVsc1xuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0b3JNZXRhIH0sIHByb3BzKSwgeyBlbENsYXNzZXM6IChwcm9wcy5lbENsYXNzZXMgfHwgW10pLmZpbHRlcihpc1RydXRoeSkgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFwcGx5UXVldWV1ZERvbU5vZGVzKCkge1xuICAgICAgICBjb25zdCB7IHF1ZXVlZERvbU5vZGVzLCBjdXJyZW50RG9tTm9kZXMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGVsID0gdGhpcy5iYXNlO1xuICAgICAgICBpZiAoIWlzQXJyYXlzRXF1YWwocXVldWVkRG9tTm9kZXMsIGN1cnJlbnREb21Ob2RlcykpIHtcbiAgICAgICAgICAgIGN1cnJlbnREb21Ob2Rlcy5mb3JFYWNoKHJlbW92ZUVsZW1lbnQpO1xuICAgICAgICAgICAgZm9yIChsZXQgbmV3Tm9kZSBvZiBxdWV1ZWREb21Ob2Rlcykge1xuICAgICAgICAgICAgICAgIGVsLmFwcGVuZENoaWxkKG5ld05vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jdXJyZW50RG9tTm9kZXMgPSBxdWV1ZWREb21Ob2RlcztcbiAgICAgICAgfVxuICAgIH1cbn1cbkNvbnRlbnRJbmplY3Rvci5hZGRQcm9wc0VxdWFsaXR5KHtcbiAgICBlbENsYXNzZXM6IGlzQXJyYXlzRXF1YWwsXG4gICAgZWxTdHlsZTogaXNQcm9wc0VxdWFsLFxuICAgIGVsQXR0cnM6IGlzTm9uSGFuZGxlclByb3BzRXF1YWwsXG4gICAgcmVuZGVyUHJvcHM6IGlzUHJvcHNFcXVhbCxcbn0pO1xuLy8gVXRpbFxuLypcbkRvZXMgVUktZnJhbWV3b3JrIHByb3ZpZGUgY3VzdG9tIHdheSBvZiByZW5kZXJpbmcgdGhhdCBkb2VzIG5vdCB1c2UgUHJlYWN0IFZET01cbkFORCBkb2VzIHRoZSBjYWxlbmRhcidzIG9wdGlvbnMgZGVmaW5lIGN1c3RvbSByZW5kZXJpbmc/XG5BS0EuIFNob3VsZCB3ZSBOT1QgcmVuZGVyIHRoZSBkZWZhdWx0IGNvbnRlbnQ/XG4qL1xuZnVuY3Rpb24gaGFzQ3VzdG9tUmVuZGVyaW5nSGFuZGxlcihnZW5lcmF0b3JOYW1lLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBCb29sZWFuKG9wdGlvbnMuaGFuZGxlQ3VzdG9tUmVuZGVyaW5nICYmXG4gICAgICAgIGdlbmVyYXRvck5hbWUgJiZcbiAgICAgICAgKChfYSA9IG9wdGlvbnMuY3VzdG9tUmVuZGVyaW5nTWV0YU1hcCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2dlbmVyYXRvck5hbWVdKSk7XG59XG5mdW5jdGlvbiBidWlsZEVsQXR0cnMocHJvcHMsIGV4dHJhQ2xhc3NOYW1lcywgZWxSZWYpIHtcbiAgICBjb25zdCBhdHRycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMuZWxBdHRycyksIHsgcmVmOiBlbFJlZiB9KTtcbiAgICBpZiAocHJvcHMuZWxDbGFzc2VzIHx8IGV4dHJhQ2xhc3NOYW1lcykge1xuICAgICAgICBhdHRycy5jbGFzc05hbWUgPSAocHJvcHMuZWxDbGFzc2VzIHx8IFtdKVxuICAgICAgICAgICAgLmNvbmNhdChleHRyYUNsYXNzTmFtZXMgfHwgW10pXG4gICAgICAgICAgICAuY29uY2F0KGF0dHJzLmNsYXNzTmFtZSB8fCBbXSlcbiAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgICAgIC5qb2luKCcgJyk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5lbFN0eWxlKSB7XG4gICAgICAgIGF0dHJzLnN0eWxlID0gcHJvcHMuZWxTdHlsZTtcbiAgICB9XG4gICAgcmV0dXJuIGF0dHJzO1xufVxuZnVuY3Rpb24gaXNUcnV0aHkodmFsKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odmFsKTtcbn1cblxuY29uc3QgUmVuZGVySWQgPSBjcmVhdGVDb250ZXh0KDApO1xuXG5jbGFzcyBDb250ZW50Q29udGFpbmVyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5Jbm5lckNvbnRlbnQgPSBJbm5lckNvbnRlbnRJbmplY3Rvci5iaW5kKHVuZGVmaW5lZCwgdGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlRWwgPSAoZWwpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLmVsUmVmKSB7XG4gICAgICAgICAgICAgICAgc2V0UmVmKHRoaXMucHJvcHMuZWxSZWYsIGVsKTtcbiAgICAgICAgICAgICAgICBpZiAoZWwgJiYgdGhpcy5kaWRNb3VudE1pc2ZpcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnREaWRNb3VudCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBnZW5lcmF0ZWRDbGFzc05hbWVzID0gZ2VuZXJhdGVDbGFzc05hbWVzKHByb3BzLmNsYXNzTmFtZUdlbmVyYXRvciwgcHJvcHMucmVuZGVyUHJvcHMpO1xuICAgICAgICBpZiAocHJvcHMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGVsQXR0cnMgPSBidWlsZEVsQXR0cnMocHJvcHMsIGdlbmVyYXRlZENsYXNzTmFtZXMsIHRoaXMuaGFuZGxlRWwpO1xuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbih0aGlzLklubmVyQ29udGVudCwgcHJvcHMucmVuZGVyUHJvcHMsIGVsQXR0cnMpO1xuICAgICAgICAgICAgaWYgKHByb3BzLmVsVGFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQocHJvcHMuZWxUYWcsIGVsQXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KChDb250ZW50SW5qZWN0b3IpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByb3BzKSwgeyBlbFJlZjogdGhpcy5oYW5kbGVFbCwgZWxUYWc6IHByb3BzLmVsVGFnIHx8ICdkaXYnLCBlbENsYXNzZXM6IChwcm9wcy5lbENsYXNzZXMgfHwgW10pLmNvbmNhdChnZW5lcmF0ZWRDbGFzc05hbWVzKSwgcmVuZGVySWQ6IHRoaXMuY29udGV4dCB9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICh0aGlzLmVsKSB7XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLnByb3BzKS5kaWRNb3VudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcy5yZW5kZXJQcm9wcyksIHsgZWw6IHRoaXMuZWwgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kaWRNb3VudE1pc2ZpcmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLnByb3BzKS53aWxsVW5tb3VudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcy5yZW5kZXJQcm9wcyksIHsgZWw6IHRoaXMuZWwgfSkpO1xuICAgIH1cbn1cbkNvbnRlbnRDb250YWluZXIuY29udGV4dFR5cGUgPSBSZW5kZXJJZDtcbmZ1bmN0aW9uIElubmVyQ29udGVudEluamVjdG9yKGNvbnRhaW5lckNvbXBvbmVudCwgcHJvcHMpIHtcbiAgICBjb25zdCBwYXJlbnRQcm9wcyA9IGNvbnRhaW5lckNvbXBvbmVudC5wcm9wcztcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgoQ29udGVudEluamVjdG9yKSwgT2JqZWN0LmFzc2lnbih7IHJlbmRlclByb3BzOiBwYXJlbnRQcm9wcy5yZW5kZXJQcm9wcywgZ2VuZXJhdG9yTmFtZTogcGFyZW50UHJvcHMuZ2VuZXJhdG9yTmFtZSwgY3VzdG9tR2VuZXJhdG9yOiBwYXJlbnRQcm9wcy5jdXN0b21HZW5lcmF0b3IsIGRlZmF1bHRHZW5lcmF0b3I6IHBhcmVudFByb3BzLmRlZmF1bHRHZW5lcmF0b3IsIHJlbmRlcklkOiBjb250YWluZXJDb21wb25lbnQuY29udGV4dCB9LCBwcm9wcykpO1xufVxuLy8gVXRpbHNcbmZ1bmN0aW9uIGdlbmVyYXRlQ2xhc3NOYW1lcyhjbGFzc05hbWVHZW5lcmF0b3IsIHJlbmRlclByb3BzKSB7XG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IHR5cGVvZiBjbGFzc05hbWVHZW5lcmF0b3IgPT09ICdmdW5jdGlvbicgP1xuICAgICAgICBjbGFzc05hbWVHZW5lcmF0b3IocmVuZGVyUHJvcHMpIDpcbiAgICAgICAgY2xhc3NOYW1lR2VuZXJhdG9yIHx8IFtdO1xuICAgIHJldHVybiB0eXBlb2YgY2xhc3NOYW1lcyA9PT0gJ3N0cmluZycgPyBbY2xhc3NOYW1lc10gOiBjbGFzc05hbWVzO1xufVxuXG5jbGFzcyBWaWV3Q29udGFpbmVyIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgb3B0aW9ucyB9ID0gY29udGV4dDtcbiAgICAgICAgbGV0IHJlbmRlclByb3BzID0geyB2aWV3OiBjb250ZXh0LnZpZXdBcGkgfTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KENvbnRlbnRDb250YWluZXIsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCB7IGVsVGFnOiBwcm9wcy5lbFRhZyB8fCAnZGl2JywgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgLi4uYnVpbGRWaWV3Q2xhc3NOYW1lcyhwcm9wcy52aWV3U3BlYyksXG4gICAgICAgICAgICAgICAgLi4uKHByb3BzLmVsQ2xhc3NlcyB8fCBbXSksXG4gICAgICAgICAgICBdLCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy52aWV3Q2xhc3NOYW1lcywgZ2VuZXJhdG9yTmFtZTogdW5kZWZpbmVkLCBkaWRNb3VudDogb3B0aW9ucy52aWV3RGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLnZpZXdXaWxsVW5tb3VudCB9KSwgKCkgPT4gcHJvcHMuY2hpbGRyZW4pKTtcbiAgICB9XG59XG5mdW5jdGlvbiBidWlsZFZpZXdDbGFzc05hbWVzKHZpZXdTcGVjKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgYGZjLSR7dmlld1NwZWMudHlwZX0tdmlld2AsXG4gICAgICAgICdmYy12aWV3JyxcbiAgICBdO1xufVxuXG5mdW5jdGlvbiBwYXJzZVJhbmdlKGlucHV0LCBkYXRlRW52KSB7XG4gICAgbGV0IHN0YXJ0ID0gbnVsbDtcbiAgICBsZXQgZW5kID0gbnVsbDtcbiAgICBpZiAoaW5wdXQuc3RhcnQpIHtcbiAgICAgICAgc3RhcnQgPSBkYXRlRW52LmNyZWF0ZU1hcmtlcihpbnB1dC5zdGFydCk7XG4gICAgfVxuICAgIGlmIChpbnB1dC5lbmQpIHtcbiAgICAgICAgZW5kID0gZGF0ZUVudi5jcmVhdGVNYXJrZXIoaW5wdXQuZW5kKTtcbiAgICB9XG4gICAgaWYgKCFzdGFydCAmJiAhZW5kKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoc3RhcnQgJiYgZW5kICYmIGVuZCA8IHN0YXJ0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4geyBzdGFydCwgZW5kIH07XG59XG4vLyBTSURFLUVGRkVDVDogd2lsbCBtdXRhdGUgcmFuZ2VzLlxuLy8gV2lsbCByZXR1cm4gYSBuZXcgYXJyYXkgcmVzdWx0LlxuZnVuY3Rpb24gaW52ZXJ0UmFuZ2VzKHJhbmdlcywgY29uc3RyYWludFJhbmdlKSB7XG4gICAgbGV0IGludmVydGVkUmFuZ2VzID0gW107XG4gICAgbGV0IHsgc3RhcnQgfSA9IGNvbnN0cmFpbnRSYW5nZTsgLy8gdGhlIGVuZCBvZiB0aGUgcHJldmlvdXMgcmFuZ2UuIHRoZSBzdGFydCBvZiB0aGUgbmV3IHJhbmdlXG4gICAgbGV0IGk7XG4gICAgbGV0IGRhdGVSYW5nZTtcbiAgICAvLyByYW5nZXMgbmVlZCB0byBiZSBpbiBvcmRlci4gcmVxdWlyZWQgZm9yIG91ciBkYXRlLXdhbGtpbmcgYWxnb3JpdGhtXG4gICAgcmFuZ2VzLnNvcnQoY29tcGFyZVJhbmdlcyk7XG4gICAgZm9yIChpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBkYXRlUmFuZ2UgPSByYW5nZXNbaV07XG4gICAgICAgIC8vIGFkZCB0aGUgc3BhbiBvZiB0aW1lIGJlZm9yZSB0aGUgZXZlbnQgKGlmIHRoZXJlIGlzIGFueSlcbiAgICAgICAgaWYgKGRhdGVSYW5nZS5zdGFydCA+IHN0YXJ0KSB7IC8vIGNvbXBhcmUgbWlsbGlzZWNvbmQgdGltZSAoc2tpcCBhbnkgYW1iaWcgbG9naWMpXG4gICAgICAgICAgICBpbnZlcnRlZFJhbmdlcy5wdXNoKHsgc3RhcnQsIGVuZDogZGF0ZVJhbmdlLnN0YXJ0IH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRlUmFuZ2UuZW5kID4gc3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gZGF0ZVJhbmdlLmVuZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBhZGQgdGhlIHNwYW4gb2YgdGltZSBhZnRlciB0aGUgbGFzdCBldmVudCAoaWYgdGhlcmUgaXMgYW55KVxuICAgIGlmIChzdGFydCA8IGNvbnN0cmFpbnRSYW5nZS5lbmQpIHsgLy8gY29tcGFyZSBtaWxsaXNlY29uZCB0aW1lIChza2lwIGFueSBhbWJpZyBsb2dpYylcbiAgICAgICAgaW52ZXJ0ZWRSYW5nZXMucHVzaCh7IHN0YXJ0LCBlbmQ6IGNvbnN0cmFpbnRSYW5nZS5lbmQgfSk7XG4gICAgfVxuICAgIHJldHVybiBpbnZlcnRlZFJhbmdlcztcbn1cbmZ1bmN0aW9uIGNvbXBhcmVSYW5nZXMocmFuZ2UwLCByYW5nZTEpIHtcbiAgICByZXR1cm4gcmFuZ2UwLnN0YXJ0LnZhbHVlT2YoKSAtIHJhbmdlMS5zdGFydC52YWx1ZU9mKCk7IC8vIGVhcmxpZXIgcmFuZ2VzIGdvIGZpcnN0XG59XG5mdW5jdGlvbiBpbnRlcnNlY3RSYW5nZXMocmFuZ2UwLCByYW5nZTEpIHtcbiAgICBsZXQgeyBzdGFydCwgZW5kIH0gPSByYW5nZTA7XG4gICAgbGV0IG5ld1JhbmdlID0gbnVsbDtcbiAgICBpZiAocmFuZ2UxLnN0YXJ0ICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhcnQgPSByYW5nZTEuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFydCA9IG5ldyBEYXRlKE1hdGgubWF4KHN0YXJ0LnZhbHVlT2YoKSwgcmFuZ2UxLnN0YXJ0LnZhbHVlT2YoKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChyYW5nZTEuZW5kICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZW5kID0gcmFuZ2UxLmVuZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVuZCA9IG5ldyBEYXRlKE1hdGgubWluKGVuZC52YWx1ZU9mKCksIHJhbmdlMS5lbmQudmFsdWVPZigpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YXJ0ID09PSBudWxsIHx8IGVuZCA9PT0gbnVsbCB8fCBzdGFydCA8IGVuZCkge1xuICAgICAgICBuZXdSYW5nZSA9IHsgc3RhcnQsIGVuZCB9O1xuICAgIH1cbiAgICByZXR1cm4gbmV3UmFuZ2U7XG59XG5mdW5jdGlvbiByYW5nZXNFcXVhbChyYW5nZTAsIHJhbmdlMSkge1xuICAgIHJldHVybiAocmFuZ2UwLnN0YXJ0ID09PSBudWxsID8gbnVsbCA6IHJhbmdlMC5zdGFydC52YWx1ZU9mKCkpID09PSAocmFuZ2UxLnN0YXJ0ID09PSBudWxsID8gbnVsbCA6IHJhbmdlMS5zdGFydC52YWx1ZU9mKCkpICYmXG4gICAgICAgIChyYW5nZTAuZW5kID09PSBudWxsID8gbnVsbCA6IHJhbmdlMC5lbmQudmFsdWVPZigpKSA9PT0gKHJhbmdlMS5lbmQgPT09IG51bGwgPyBudWxsIDogcmFuZ2UxLmVuZC52YWx1ZU9mKCkpO1xufVxuZnVuY3Rpb24gcmFuZ2VzSW50ZXJzZWN0KHJhbmdlMCwgcmFuZ2UxKSB7XG4gICAgcmV0dXJuIChyYW5nZTAuZW5kID09PSBudWxsIHx8IHJhbmdlMS5zdGFydCA9PT0gbnVsbCB8fCByYW5nZTAuZW5kID4gcmFuZ2UxLnN0YXJ0KSAmJlxuICAgICAgICAocmFuZ2UwLnN0YXJ0ID09PSBudWxsIHx8IHJhbmdlMS5lbmQgPT09IG51bGwgfHwgcmFuZ2UwLnN0YXJ0IDwgcmFuZ2UxLmVuZCk7XG59XG5mdW5jdGlvbiByYW5nZUNvbnRhaW5zUmFuZ2Uob3V0ZXJSYW5nZSwgaW5uZXJSYW5nZSkge1xuICAgIHJldHVybiAob3V0ZXJSYW5nZS5zdGFydCA9PT0gbnVsbCB8fCAoaW5uZXJSYW5nZS5zdGFydCAhPT0gbnVsbCAmJiBpbm5lclJhbmdlLnN0YXJ0ID49IG91dGVyUmFuZ2Uuc3RhcnQpKSAmJlxuICAgICAgICAob3V0ZXJSYW5nZS5lbmQgPT09IG51bGwgfHwgKGlubmVyUmFuZ2UuZW5kICE9PSBudWxsICYmIGlubmVyUmFuZ2UuZW5kIDw9IG91dGVyUmFuZ2UuZW5kKSk7XG59XG5mdW5jdGlvbiByYW5nZUNvbnRhaW5zTWFya2VyKHJhbmdlLCBkYXRlKSB7XG4gICAgcmV0dXJuIChyYW5nZS5zdGFydCA9PT0gbnVsbCB8fCBkYXRlID49IHJhbmdlLnN0YXJ0KSAmJlxuICAgICAgICAocmFuZ2UuZW5kID09PSBudWxsIHx8IGRhdGUgPCByYW5nZS5lbmQpO1xufVxuLy8gSWYgdGhlIGdpdmVuIGRhdGUgaXMgbm90IHdpdGhpbiB0aGUgZ2l2ZW4gcmFuZ2UsIG1vdmUgaXQgaW5zaWRlLlxuLy8gKElmIGl0J3MgcGFzdCB0aGUgZW5kLCBtYWtlIGl0IG9uZSBtaWxsaXNlY29uZCBiZWZvcmUgdGhlIGVuZCkuXG5mdW5jdGlvbiBjb25zdHJhaW5NYXJrZXJUb1JhbmdlKGRhdGUsIHJhbmdlKSB7XG4gICAgaWYgKHJhbmdlLnN0YXJ0ICE9IG51bGwgJiYgZGF0ZSA8IHJhbmdlLnN0YXJ0KSB7XG4gICAgICAgIHJldHVybiByYW5nZS5zdGFydDtcbiAgICB9XG4gICAgaWYgKHJhbmdlLmVuZCAhPSBudWxsICYmIGRhdGUgPj0gcmFuZ2UuZW5kKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShyYW5nZS5lbmQudmFsdWVPZigpIC0gMSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRlO1xufVxuXG4vKiBEYXRlIHN0dWZmIHRoYXQgZG9lc24ndCBiZWxvbmcgaW4gZGF0ZWxpYiBjb3JlXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8vIGdpdmVuIGEgdGltZWQgcmFuZ2UsIGNvbXB1dGVzIGFuIGFsbC1kYXkgcmFuZ2UgdGhhdCBoYXMgdGhlIHNhbWUgZXhhY3QgZHVyYXRpb24sXG4vLyBidXQgd2hvc2Ugc3RhcnQgdGltZSBpcyBhbGlnbmVkIHdpdGggdGhlIHN0YXJ0IG9mIHRoZSBkYXkuXG5mdW5jdGlvbiBjb21wdXRlQWxpZ25lZERheVJhbmdlKHRpbWVkUmFuZ2UpIHtcbiAgICBsZXQgZGF5Q250ID0gTWF0aC5mbG9vcihkaWZmRGF5cyh0aW1lZFJhbmdlLnN0YXJ0LCB0aW1lZFJhbmdlLmVuZCkpIHx8IDE7XG4gICAgbGV0IHN0YXJ0ID0gc3RhcnRPZkRheSh0aW1lZFJhbmdlLnN0YXJ0KTtcbiAgICBsZXQgZW5kID0gYWRkRGF5cyhzdGFydCwgZGF5Q250KTtcbiAgICByZXR1cm4geyBzdGFydCwgZW5kIH07XG59XG4vLyBnaXZlbiBhIHRpbWVkIHJhbmdlLCBjb21wdXRlcyBhbiBhbGwtZGF5IHJhbmdlIGJhc2VkIG9uIGhvdyBmb3IgdGhlIGVuZCBkYXRlIGJsZWVkcyBpbnRvIHRoZSBuZXh0IGRheVxuLy8gVE9ETzogZ2l2ZSBuZXh0RGF5VGhyZXNob2xkIGEgZGVmYXVsdCBhcmdcbmZ1bmN0aW9uIGNvbXB1dGVWaXNpYmxlRGF5UmFuZ2UodGltZWRSYW5nZSwgbmV4dERheVRocmVzaG9sZCA9IGNyZWF0ZUR1cmF0aW9uKDApKSB7XG4gICAgbGV0IHN0YXJ0RGF5ID0gbnVsbDtcbiAgICBsZXQgZW5kRGF5ID0gbnVsbDtcbiAgICBpZiAodGltZWRSYW5nZS5lbmQpIHtcbiAgICAgICAgZW5kRGF5ID0gc3RhcnRPZkRheSh0aW1lZFJhbmdlLmVuZCk7XG4gICAgICAgIGxldCBlbmRUaW1lTVMgPSB0aW1lZFJhbmdlLmVuZC52YWx1ZU9mKCkgLSBlbmREYXkudmFsdWVPZigpOyAvLyAjIG9mIG1pbGxpc2Vjb25kcyBpbnRvIGBlbmREYXlgXG4gICAgICAgIC8vIElmIHRoZSBlbmQgdGltZSBpcyBhY3R1YWxseSBpbmNsdXNpdmVseSBwYXJ0IG9mIHRoZSBuZXh0IGRheSBhbmQgaXMgZXF1YWwgdG8gb3JcbiAgICAgICAgLy8gYmV5b25kIHRoZSBuZXh0IGRheSB0aHJlc2hvbGQsIGFkanVzdCB0aGUgZW5kIHRvIGJlIHRoZSBleGNsdXNpdmUgZW5kIG9mIGBlbmREYXlgLlxuICAgICAgICAvLyBPdGhlcndpc2UsIGxlYXZpbmcgaXQgYXMgaW5jbHVzaXZlIHdpbGwgY2F1c2UgaXQgdG8gZXhjbHVkZSBgZW5kRGF5YC5cbiAgICAgICAgaWYgKGVuZFRpbWVNUyAmJiBlbmRUaW1lTVMgPj0gYXNSb3VnaE1zKG5leHREYXlUaHJlc2hvbGQpKSB7XG4gICAgICAgICAgICBlbmREYXkgPSBhZGREYXlzKGVuZERheSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRpbWVkUmFuZ2Uuc3RhcnQpIHtcbiAgICAgICAgc3RhcnREYXkgPSBzdGFydE9mRGF5KHRpbWVkUmFuZ2Uuc3RhcnQpOyAvLyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBkYXkgdGhlIHJhbmdlIHN0YXJ0c1xuICAgICAgICAvLyBJZiBlbmQgaXMgd2l0aGluIGBzdGFydERheWAgYnV0IG5vdCBwYXN0IG5leHREYXlUaHJlc2hvbGQsIGFzc2lnbiB0aGUgZGVmYXVsdCBkdXJhdGlvbiBvZiBvbmUgZGF5LlxuICAgICAgICBpZiAoZW5kRGF5ICYmIGVuZERheSA8PSBzdGFydERheSkge1xuICAgICAgICAgICAgZW5kRGF5ID0gYWRkRGF5cyhzdGFydERheSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0RGF5LCBlbmQ6IGVuZERheSB9O1xufVxuLy8gc3BhbnMgZnJvbSBvbmUgZGF5IGludG8gYW5vdGhlcj9cbmZ1bmN0aW9uIGlzTXVsdGlEYXlSYW5nZShyYW5nZSkge1xuICAgIGxldCB2aXNpYmxlUmFuZ2UgPSBjb21wdXRlVmlzaWJsZURheVJhbmdlKHJhbmdlKTtcbiAgICByZXR1cm4gZGlmZkRheXModmlzaWJsZVJhbmdlLnN0YXJ0LCB2aXNpYmxlUmFuZ2UuZW5kKSA+IDE7XG59XG5mdW5jdGlvbiBkaWZmRGF0ZXMoZGF0ZTAsIGRhdGUxLCBkYXRlRW52LCBsYXJnZVVuaXQpIHtcbiAgICBpZiAobGFyZ2VVbml0ID09PSAneWVhcicpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKGRhdGVFbnYuZGlmZldob2xlWWVhcnMoZGF0ZTAsIGRhdGUxKSwgJ3llYXInKTtcbiAgICB9XG4gICAgaWYgKGxhcmdlVW5pdCA9PT0gJ21vbnRoJykge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oZGF0ZUVudi5kaWZmV2hvbGVNb250aHMoZGF0ZTAsIGRhdGUxKSwgJ21vbnRoJyk7XG4gICAgfVxuICAgIHJldHVybiBkaWZmRGF5QW5kVGltZShkYXRlMCwgZGF0ZTEpOyAvLyByZXR1cm5zIGEgZHVyYXRpb25cbn1cblxuZnVuY3Rpb24gcmVkdWNlQ3VycmVudERhdGUoY3VycmVudERhdGUsIGFjdGlvbikge1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnQ0hBTkdFX0RBVEUnOlxuICAgICAgICAgICAgcmV0dXJuIGFjdGlvbi5kYXRlTWFya2VyO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnREYXRlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEluaXRpYWxEYXRlKG9wdGlvbnMsIGRhdGVFbnYpIHtcbiAgICBsZXQgaW5pdGlhbERhdGVJbnB1dCA9IG9wdGlvbnMuaW5pdGlhbERhdGU7XG4gICAgLy8gY29tcHV0ZSB0aGUgaW5pdGlhbCBhbWJpZy10aW1lem9uZSBkYXRlXG4gICAgaWYgKGluaXRpYWxEYXRlSW5wdXQgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZGF0ZUVudi5jcmVhdGVNYXJrZXIoaW5pdGlhbERhdGVJbnB1dCk7XG4gICAgfVxuICAgIHJldHVybiBnZXROb3cob3B0aW9ucy5ub3csIGRhdGVFbnYpOyAvLyBnZXROb3cgYWxyZWFkeSByZXR1cm5zIHVuem9uZWRcbn1cbmZ1bmN0aW9uIGdldE5vdyhub3dJbnB1dCwgZGF0ZUVudikge1xuICAgIGlmICh0eXBlb2Ygbm93SW5wdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgbm93SW5wdXQgPSBub3dJbnB1dCgpO1xuICAgIH1cbiAgICBpZiAobm93SW5wdXQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZGF0ZUVudi5jcmVhdGVOb3dNYXJrZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGVFbnYuY3JlYXRlTWFya2VyKG5vd0lucHV0KTtcbn1cblxuY2xhc3MgRGF0ZVByb2ZpbGVHZW5lcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgICAgdGhpcy5ub3dEYXRlID0gZ2V0Tm93KHByb3BzLm5vd0lucHV0LCBwcm9wcy5kYXRlRW52KTtcbiAgICAgICAgdGhpcy5pbml0SGlkZGVuRGF5cygpO1xuICAgIH1cbiAgICAvKiBEYXRlIFJhbmdlIENvbXB1dGF0aW9uXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgICAvLyBCdWlsZHMgYSBzdHJ1Y3R1cmUgd2l0aCBpbmZvIGFib3V0IHdoYXQgdGhlIGRhdGVzL3JhbmdlcyB3aWxsIGJlIGZvciB0aGUgXCJwcmV2XCIgdmlldy5cbiAgICBidWlsZFByZXYoY3VycmVudERhdGVQcm9maWxlLCBjdXJyZW50RGF0ZSwgZm9yY2VUb1ZhbGlkKSB7XG4gICAgICAgIGxldCB7IGRhdGVFbnYgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCBwcmV2RGF0ZSA9IGRhdGVFbnYuc3VidHJhY3QoZGF0ZUVudi5zdGFydE9mKGN1cnJlbnREYXRlLCBjdXJyZW50RGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdCksIC8vIGltcG9ydGFudCBmb3Igc3RhcnQtb2YtbW9udGhcbiAgICAgICAgY3VycmVudERhdGVQcm9maWxlLmRhdGVJbmNyZW1lbnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5idWlsZChwcmV2RGF0ZSwgLTEsIGZvcmNlVG9WYWxpZCk7XG4gICAgfVxuICAgIC8vIEJ1aWxkcyBhIHN0cnVjdHVyZSB3aXRoIGluZm8gYWJvdXQgd2hhdCB0aGUgZGF0ZXMvcmFuZ2VzIHdpbGwgYmUgZm9yIHRoZSBcIm5leHRcIiB2aWV3LlxuICAgIGJ1aWxkTmV4dChjdXJyZW50RGF0ZVByb2ZpbGUsIGN1cnJlbnREYXRlLCBmb3JjZVRvVmFsaWQpIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IG5leHREYXRlID0gZGF0ZUVudi5hZGQoZGF0ZUVudi5zdGFydE9mKGN1cnJlbnREYXRlLCBjdXJyZW50RGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdCksIC8vIGltcG9ydGFudCBmb3Igc3RhcnQtb2YtbW9udGhcbiAgICAgICAgY3VycmVudERhdGVQcm9maWxlLmRhdGVJbmNyZW1lbnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5idWlsZChuZXh0RGF0ZSwgMSwgZm9yY2VUb1ZhbGlkKTtcbiAgICB9XG4gICAgLy8gQnVpbGRzIGEgc3RydWN0dXJlIGhvbGRpbmcgZGF0ZXMvcmFuZ2VzIGZvciByZW5kZXJpbmcgYXJvdW5kIHRoZSBnaXZlbiBkYXRlLlxuICAgIC8vIE9wdGlvbmFsIGRpcmVjdGlvbiBwYXJhbSBpbmRpY2F0ZXMgd2hldGhlciB0aGUgZGF0ZSBpcyBiZWluZyBpbmNyZW1lbnRlZC9kZWNyZW1lbnRlZFxuICAgIC8vIGZyb20gaXRzIHByZXZpb3VzIHZhbHVlLiBkZWNyZW1lbnRlZCA9IC0xLCBpbmNyZW1lbnRlZCA9IDEgKGRlZmF1bHQpLlxuICAgIGJ1aWxkKGN1cnJlbnREYXRlLCBkaXJlY3Rpb24sIGZvcmNlVG9WYWxpZCA9IHRydWUpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB2YWxpZFJhbmdlO1xuICAgICAgICBsZXQgY3VycmVudEluZm87XG4gICAgICAgIGxldCBpc1JhbmdlQWxsRGF5O1xuICAgICAgICBsZXQgcmVuZGVyUmFuZ2U7XG4gICAgICAgIGxldCBhY3RpdmVSYW5nZTtcbiAgICAgICAgbGV0IGlzVmFsaWQ7XG4gICAgICAgIHZhbGlkUmFuZ2UgPSB0aGlzLmJ1aWxkVmFsaWRSYW5nZSgpO1xuICAgICAgICB2YWxpZFJhbmdlID0gdGhpcy50cmltSGlkZGVuRGF5cyh2YWxpZFJhbmdlKTtcbiAgICAgICAgaWYgKGZvcmNlVG9WYWxpZCkge1xuICAgICAgICAgICAgY3VycmVudERhdGUgPSBjb25zdHJhaW5NYXJrZXJUb1JhbmdlKGN1cnJlbnREYXRlLCB2YWxpZFJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50SW5mbyA9IHRoaXMuYnVpbGRDdXJyZW50UmFuZ2VJbmZvKGN1cnJlbnREYXRlLCBkaXJlY3Rpb24pO1xuICAgICAgICBpc1JhbmdlQWxsRGF5ID0gL14oeWVhcnxtb250aHx3ZWVrfGRheSkkLy50ZXN0KGN1cnJlbnRJbmZvLnVuaXQpO1xuICAgICAgICByZW5kZXJSYW5nZSA9IHRoaXMuYnVpbGRSZW5kZXJSYW5nZSh0aGlzLnRyaW1IaWRkZW5EYXlzKGN1cnJlbnRJbmZvLnJhbmdlKSwgY3VycmVudEluZm8udW5pdCwgaXNSYW5nZUFsbERheSk7XG4gICAgICAgIHJlbmRlclJhbmdlID0gdGhpcy50cmltSGlkZGVuRGF5cyhyZW5kZXJSYW5nZSk7XG4gICAgICAgIGFjdGl2ZVJhbmdlID0gcmVuZGVyUmFuZ2U7XG4gICAgICAgIGlmICghcHJvcHMuc2hvd05vbkN1cnJlbnREYXRlcykge1xuICAgICAgICAgICAgYWN0aXZlUmFuZ2UgPSBpbnRlcnNlY3RSYW5nZXMoYWN0aXZlUmFuZ2UsIGN1cnJlbnRJbmZvLnJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBhY3RpdmVSYW5nZSA9IHRoaXMuYWRqdXN0QWN0aXZlUmFuZ2UoYWN0aXZlUmFuZ2UpO1xuICAgICAgICBhY3RpdmVSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhhY3RpdmVSYW5nZSwgdmFsaWRSYW5nZSk7IC8vIG1pZ2h0IHJldHVybiBudWxsXG4gICAgICAgIC8vIGl0J3MgaW52YWxpZCBpZiB0aGUgb3JpZ2luYWxseSByZXF1ZXN0ZWQgZGF0ZSBpcyBub3QgY29udGFpbmVkLFxuICAgICAgICAvLyBvciBpZiB0aGUgcmFuZ2UgaXMgY29tcGxldGVseSBvdXRzaWRlIG9mIHRoZSB2YWxpZCByYW5nZS5cbiAgICAgICAgaXNWYWxpZCA9IHJhbmdlc0ludGVyc2VjdChjdXJyZW50SW5mby5yYW5nZSwgdmFsaWRSYW5nZSk7XG4gICAgICAgIC8vIEhBQ0s6IGNvbnN0cmFpbiB0byByZW5kZXItcmFuZ2Ugc28gYGN1cnJlbnREYXRlYCBpcyBtb3JlIHVzZWZ1bCB0byB2aWV3IHJlbmRlcmluZ1xuICAgICAgICBpZiAoIXJhbmdlQ29udGFpbnNNYXJrZXIocmVuZGVyUmFuZ2UsIGN1cnJlbnREYXRlKSkge1xuICAgICAgICAgICAgY3VycmVudERhdGUgPSByZW5kZXJSYW5nZS5zdGFydDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3VycmVudERhdGUsXG4gICAgICAgICAgICAvLyBjb25zdHJhaW50IGZvciB3aGVyZSBwcmV2L25leHQgb3BlcmF0aW9ucyBjYW4gZ28gYW5kIHdoZXJlIGV2ZW50cyBjYW4gYmUgZHJhZ2dlZC9yZXNpemVkIHRvLlxuICAgICAgICAgICAgLy8gYW4gb2JqZWN0IHdpdGggb3B0aW9uYWwgc3RhcnQgYW5kIGVuZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgdmFsaWRSYW5nZSxcbiAgICAgICAgICAgIC8vIHJhbmdlIHRoZSB2aWV3IGlzIGZvcm1hbGx5IHJlc3BvbnNpYmxlIGZvci5cbiAgICAgICAgICAgIC8vIGZvciBleGFtcGxlLCBhIG1vbnRoIHZpZXcgbWlnaHQgaGF2ZSAxc3QtMzFzdCwgZXhjbHVkaW5nIHBhZGRlZCBkYXRlc1xuICAgICAgICAgICAgY3VycmVudFJhbmdlOiBjdXJyZW50SW5mby5yYW5nZSxcbiAgICAgICAgICAgIC8vIG5hbWUgb2YgbGFyZ2VzdCB1bml0IGJlaW5nIGRpc3BsYXllZCwgbGlrZSBcIm1vbnRoXCIgb3IgXCJ3ZWVrXCJcbiAgICAgICAgICAgIGN1cnJlbnRSYW5nZVVuaXQ6IGN1cnJlbnRJbmZvLnVuaXQsXG4gICAgICAgICAgICBpc1JhbmdlQWxsRGF5LFxuICAgICAgICAgICAgLy8gZGF0ZXMgdGhhdCBkaXNwbGF5IGV2ZW50cyBhbmQgYWNjZXB0IGRyYWctbi1kcm9wXG4gICAgICAgICAgICAvLyB3aWxsIGJlIGBudWxsYCBpZiBubyBkYXRlcyBhY2NlcHQgZXZlbnRzXG4gICAgICAgICAgICBhY3RpdmVSYW5nZSxcbiAgICAgICAgICAgIC8vIGRhdGUgcmFuZ2Ugd2l0aCBhIHJlbmRlcmVkIHNrZWxldG9uXG4gICAgICAgICAgICAvLyBpbmNsdWRlcyBub3QtYWN0aXZlIGRheXMgdGhhdCBuZWVkIHNvbWUgc29ydCBvZiBET01cbiAgICAgICAgICAgIHJlbmRlclJhbmdlLFxuICAgICAgICAgICAgLy8gRHVyYXRpb24gb2JqZWN0IHRoYXQgZGVub3RlcyB0aGUgZmlyc3QgdmlzaWJsZSB0aW1lIG9mIGFueSBnaXZlbiBkYXlcbiAgICAgICAgICAgIHNsb3RNaW5UaW1lOiBwcm9wcy5zbG90TWluVGltZSxcbiAgICAgICAgICAgIC8vIER1cmF0aW9uIG9iamVjdCB0aGF0IGRlbm90ZXMgdGhlIGV4Y2x1c2l2ZSB2aXNpYmxlIGVuZCB0aW1lIG9mIGFueSBnaXZlbiBkYXlcbiAgICAgICAgICAgIHNsb3RNYXhUaW1lOiBwcm9wcy5zbG90TWF4VGltZSxcbiAgICAgICAgICAgIGlzVmFsaWQsXG4gICAgICAgICAgICAvLyBob3cgZmFyIHRoZSBjdXJyZW50IGRhdGUgd2lsbCBtb3ZlIGZvciBhIHByZXYvbmV4dCBvcGVyYXRpb25cbiAgICAgICAgICAgIGRhdGVJbmNyZW1lbnQ6IHRoaXMuYnVpbGREYXRlSW5jcmVtZW50KGN1cnJlbnRJbmZvLmR1cmF0aW9uKSxcbiAgICAgICAgICAgIC8vIHBhc3MgYSBmYWxsYmFjayAobWlnaHQgYmUgbnVsbCkgXlxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBCdWlsZHMgYW4gb2JqZWN0IHdpdGggb3B0aW9uYWwgc3RhcnQvZW5kIHByb3BlcnRpZXMuXG4gICAgLy8gSW5kaWNhdGVzIHRoZSBtaW5pbXVtL21heGltdW0gZGF0ZXMgdG8gZGlzcGxheS5cbiAgICAvLyBub3QgcmVzcG9uc2libGUgZm9yIHRyaW1taW5nIGhpZGRlbiBkYXlzLlxuICAgIGJ1aWxkVmFsaWRSYW5nZSgpIHtcbiAgICAgICAgbGV0IGlucHV0ID0gdGhpcy5wcm9wcy52YWxpZFJhbmdlSW5wdXQ7XG4gICAgICAgIGxldCBzaW1wbGVJbnB1dCA9IHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBpbnB1dC5jYWxsKHRoaXMucHJvcHMuY2FsZW5kYXJBcGksIHRoaXMubm93RGF0ZSlcbiAgICAgICAgICAgIDogaW5wdXQ7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZmluZVJhbmdlKHNpbXBsZUlucHV0KSB8fFxuICAgICAgICAgICAgeyBzdGFydDogbnVsbCwgZW5kOiBudWxsIH07IC8vIGNvbXBsZXRlbHkgb3Blbi1lbmRlZFxuICAgIH1cbiAgICAvLyBCdWlsZHMgYSBzdHJ1Y3R1cmUgd2l0aCBpbmZvIGFib3V0IHRoZSBcImN1cnJlbnRcIiByYW5nZSwgdGhlIHJhbmdlIHRoYXQgaXNcbiAgICAvLyBoaWdobGlnaHRlZCBhcyBiZWluZyB0aGUgY3VycmVudCBtb250aCBmb3IgZXhhbXBsZS5cbiAgICAvLyBTZWUgYnVpbGQoKSBmb3IgYSBkZXNjcmlwdGlvbiBvZiBgZGlyZWN0aW9uYC5cbiAgICAvLyBHdWFyYW50ZWVkIHRvIGhhdmUgYHJhbmdlYCBhbmQgYHVuaXRgIHByb3BlcnRpZXMuIGBkdXJhdGlvbmAgaXMgb3B0aW9uYWwuXG4gICAgYnVpbGRDdXJyZW50UmFuZ2VJbmZvKGRhdGUsIGRpcmVjdGlvbikge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGR1cmF0aW9uID0gbnVsbDtcbiAgICAgICAgbGV0IHVuaXQgPSBudWxsO1xuICAgICAgICBsZXQgcmFuZ2UgPSBudWxsO1xuICAgICAgICBsZXQgZGF5Q291bnQ7XG4gICAgICAgIGlmIChwcm9wcy5kdXJhdGlvbikge1xuICAgICAgICAgICAgZHVyYXRpb24gPSBwcm9wcy5kdXJhdGlvbjtcbiAgICAgICAgICAgIHVuaXQgPSBwcm9wcy5kdXJhdGlvblVuaXQ7XG4gICAgICAgICAgICByYW5nZSA9IHRoaXMuYnVpbGRSYW5nZUZyb21EdXJhdGlvbihkYXRlLCBkaXJlY3Rpb24sIGR1cmF0aW9uLCB1bml0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoZGF5Q291bnQgPSB0aGlzLnByb3BzLmRheUNvdW50KSkge1xuICAgICAgICAgICAgdW5pdCA9ICdkYXknO1xuICAgICAgICAgICAgcmFuZ2UgPSB0aGlzLmJ1aWxkUmFuZ2VGcm9tRGF5Q291bnQoZGF0ZSwgZGlyZWN0aW9uLCBkYXlDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHJhbmdlID0gdGhpcy5idWlsZEN1c3RvbVZpc2libGVSYW5nZShkYXRlKSkpIHtcbiAgICAgICAgICAgIHVuaXQgPSBwcm9wcy5kYXRlRW52LmdyZWF0ZXN0V2hvbGVVbml0KHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQpLnVuaXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHRoaXMuZ2V0RmFsbGJhY2tEdXJhdGlvbigpO1xuICAgICAgICAgICAgdW5pdCA9IGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvcihkdXJhdGlvbikudW5pdDtcbiAgICAgICAgICAgIHJhbmdlID0gdGhpcy5idWlsZFJhbmdlRnJvbUR1cmF0aW9uKGRhdGUsIGRpcmVjdGlvbiwgZHVyYXRpb24sIHVuaXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGR1cmF0aW9uLCB1bml0LCByYW5nZSB9O1xuICAgIH1cbiAgICBnZXRGYWxsYmFja0R1cmF0aW9uKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oeyBkYXk6IDEgfSk7XG4gICAgfVxuICAgIC8vIFJldHVybnMgYSBuZXcgYWN0aXZlUmFuZ2UgdG8gaGF2ZSB0aW1lIHZhbHVlcyAodW4tYW1iaWd1YXRlKVxuICAgIC8vIHNsb3RNaW5UaW1lIG9yIHNsb3RNYXhUaW1lIGNhdXNlcyB0aGUgcmFuZ2UgdG8gZXhwYW5kLlxuICAgIGFkanVzdEFjdGl2ZVJhbmdlKHJhbmdlKSB7XG4gICAgICAgIGxldCB7IGRhdGVFbnYsIHVzZXNNaW5NYXhUaW1lLCBzbG90TWluVGltZSwgc2xvdE1heFRpbWUgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCB7IHN0YXJ0LCBlbmQgfSA9IHJhbmdlO1xuICAgICAgICBpZiAodXNlc01pbk1heFRpbWUpIHtcbiAgICAgICAgICAgIC8vIGV4cGFuZCBhY3RpdmUgcmFuZ2UgaWYgc2xvdE1pblRpbWUgaXMgbmVnYXRpdmUgKHdoeSBub3Qgd2hlbiBwb3NpdGl2ZT8pXG4gICAgICAgICAgICBpZiAoYXNSb3VnaERheXMoc2xvdE1pblRpbWUpIDwgMCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnRPZkRheShzdGFydCk7IC8vIG5lY2Vzc2FyeT9cbiAgICAgICAgICAgICAgICBzdGFydCA9IGRhdGVFbnYuYWRkKHN0YXJ0LCBzbG90TWluVGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBleHBhbmQgYWN0aXZlIHJhbmdlIGlmIHNsb3RNYXhUaW1lIGlzIGJleW9uZCBvbmUgZGF5ICh3aHkgbm90IHdoZW4gbmVnYXRpdmU/KVxuICAgICAgICAgICAgaWYgKGFzUm91Z2hEYXlzKHNsb3RNYXhUaW1lKSA+IDEpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBzdGFydE9mRGF5KGVuZCk7IC8vIG5lY2Vzc2FyeT9cbiAgICAgICAgICAgICAgICBlbmQgPSBhZGREYXlzKGVuZCwgLTEpO1xuICAgICAgICAgICAgICAgIGVuZCA9IGRhdGVFbnYuYWRkKGVuZCwgc2xvdE1heFRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXJ0LCBlbmQgfTtcbiAgICB9XG4gICAgLy8gQnVpbGRzIHRoZSBcImN1cnJlbnRcIiByYW5nZSB3aGVuIGl0IGlzIHNwZWNpZmllZCBhcyBhbiBleHBsaWNpdCBkdXJhdGlvbi5cbiAgICAvLyBgdW5pdGAgaXMgdGhlIGFscmVhZHktY29tcHV0ZWQgZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yIHVuaXQgb2YgZHVyYXRpb24uXG4gICAgYnVpbGRSYW5nZUZyb21EdXJhdGlvbihkYXRlLCBkaXJlY3Rpb24sIGR1cmF0aW9uLCB1bml0KSB7XG4gICAgICAgIGxldCB7IGRhdGVFbnYsIGRhdGVBbGlnbm1lbnQgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCBzdGFydDtcbiAgICAgICAgbGV0IGVuZDtcbiAgICAgICAgbGV0IHJlcztcbiAgICAgICAgLy8gY29tcHV0ZSB3aGF0IHRoZSBhbGlnbm1lbnQgc2hvdWxkIGJlXG4gICAgICAgIGlmICghZGF0ZUFsaWdubWVudCkge1xuICAgICAgICAgICAgbGV0IHsgZGF0ZUluY3JlbWVudCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGlmIChkYXRlSW5jcmVtZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gdXNlIHRoZSBzbWFsbGVyIG9mIHRoZSB0d28gdW5pdHNcbiAgICAgICAgICAgICAgICBpZiAoYXNSb3VnaE1zKGRhdGVJbmNyZW1lbnQpIDwgYXNSb3VnaE1zKGR1cmF0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRlQWxpZ25tZW50ID0gZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yKGRhdGVJbmNyZW1lbnQpLnVuaXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkYXRlQWxpZ25tZW50ID0gdW5pdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRlQWxpZ25tZW50ID0gdW5pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgdmlldyBkaXNwbGF5cyBhIHNpbmdsZSBkYXkgb3Igc21hbGxlclxuICAgICAgICBpZiAoYXNSb3VnaERheXMoZHVyYXRpb24pIDw9IDEpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSGlkZGVuRGF5KHN0YXJ0KSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5za2lwSGlkZGVuRGF5cyhzdGFydCwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHN0YXJ0T2ZEYXkoc3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNvbXB1dGVSZXMoKSB7XG4gICAgICAgICAgICBzdGFydCA9IGRhdGVFbnYuc3RhcnRPZihkYXRlLCBkYXRlQWxpZ25tZW50KTtcbiAgICAgICAgICAgIGVuZCA9IGRhdGVFbnYuYWRkKHN0YXJ0LCBkdXJhdGlvbik7XG4gICAgICAgICAgICByZXMgPSB7IHN0YXJ0LCBlbmQgfTtcbiAgICAgICAgfVxuICAgICAgICBjb21wdXRlUmVzKCk7XG4gICAgICAgIC8vIGlmIHJhbmdlIGlzIGNvbXBsZXRlbHkgZW52ZWxvcGVkIGJ5IGhpZGRlbiBkYXlzLCBnbyBwYXN0IHRoZSBoaWRkZW4gZGF5c1xuICAgICAgICBpZiAoIXRoaXMudHJpbUhpZGRlbkRheXMocmVzKSkge1xuICAgICAgICAgICAgZGF0ZSA9IHRoaXMuc2tpcEhpZGRlbkRheXMoZGF0ZSwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIGNvbXB1dGVSZXMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICAvLyBCdWlsZHMgdGhlIFwiY3VycmVudFwiIHJhbmdlIHdoZW4gYSBkYXlDb3VudCBpcyBzcGVjaWZpZWQuXG4gICAgYnVpbGRSYW5nZUZyb21EYXlDb3VudChkYXRlLCBkaXJlY3Rpb24sIGRheUNvdW50KSB7XG4gICAgICAgIGxldCB7IGRhdGVFbnYsIGRhdGVBbGlnbm1lbnQgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCBydW5uaW5nQ291bnQgPSAwO1xuICAgICAgICBsZXQgc3RhcnQgPSBkYXRlO1xuICAgICAgICBsZXQgZW5kO1xuICAgICAgICBpZiAoZGF0ZUFsaWdubWVudCkge1xuICAgICAgICAgICAgc3RhcnQgPSBkYXRlRW52LnN0YXJ0T2Yoc3RhcnQsIGRhdGVBbGlnbm1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0ID0gc3RhcnRPZkRheShzdGFydCk7XG4gICAgICAgIHN0YXJ0ID0gdGhpcy5za2lwSGlkZGVuRGF5cyhzdGFydCwgZGlyZWN0aW9uKTtcbiAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGVuZCA9IGFkZERheXMoZW5kLCAxKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0hpZGRlbkRheShlbmQpKSB7XG4gICAgICAgICAgICAgICAgcnVubmluZ0NvdW50ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKHJ1bm5pbmdDb3VudCA8IGRheUNvdW50KTtcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQsIGVuZCB9O1xuICAgIH1cbiAgICAvLyBCdWlsZHMgYSBub3JtYWxpemVkIHJhbmdlIG9iamVjdCBmb3IgdGhlIFwidmlzaWJsZVwiIHJhbmdlLFxuICAgIC8vIHdoaWNoIGlzIGEgd2F5IHRvIGRlZmluZSB0aGUgY3VycmVudFJhbmdlIGFuZCBhY3RpdmVSYW5nZSBhdCB0aGUgc2FtZSB0aW1lLlxuICAgIGJ1aWxkQ3VzdG9tVmlzaWJsZVJhbmdlKGRhdGUpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBpbnB1dCA9IHByb3BzLnZpc2libGVSYW5nZUlucHV0O1xuICAgICAgICBsZXQgc2ltcGxlSW5wdXQgPSB0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gaW5wdXQuY2FsbChwcm9wcy5jYWxlbmRhckFwaSwgcHJvcHMuZGF0ZUVudi50b0RhdGUoZGF0ZSkpXG4gICAgICAgICAgICA6IGlucHV0O1xuICAgICAgICBsZXQgcmFuZ2UgPSB0aGlzLnJlZmluZVJhbmdlKHNpbXBsZUlucHV0KTtcbiAgICAgICAgaWYgKHJhbmdlICYmIChyYW5nZS5zdGFydCA9PSBudWxsIHx8IHJhbmdlLmVuZCA9PSBudWxsKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH1cbiAgICAvLyBDb21wdXRlcyB0aGUgcmFuZ2UgdGhhdCB3aWxsIHJlcHJlc2VudCB0aGUgZWxlbWVudC9jZWxscyBmb3IgKnJlbmRlcmluZyosXG4gICAgLy8gYnV0IHdoaWNoIG1heSBoYXZlIHZvaWRlZCBkYXlzL3RpbWVzLlxuICAgIC8vIG5vdCByZXNwb25zaWJsZSBmb3IgdHJpbW1pbmcgaGlkZGVuIGRheXMuXG4gICAgYnVpbGRSZW5kZXJSYW5nZShjdXJyZW50UmFuZ2UsIGN1cnJlbnRSYW5nZVVuaXQsIGlzUmFuZ2VBbGxEYXkpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRSYW5nZTtcbiAgICB9XG4gICAgLy8gQ29tcHV0ZSB0aGUgZHVyYXRpb24gdmFsdWUgdGhhdCBzaG91bGQgYmUgYWRkZWQvc3Vic3RyYWN0ZWQgdG8gdGhlIGN1cnJlbnQgZGF0ZVxuICAgIC8vIHdoZW4gYSBwcmV2L25leHQgb3BlcmF0aW9uIGhhcHBlbnMuXG4gICAgYnVpbGREYXRlSW5jcmVtZW50KGZhbGxiYWNrKSB7XG4gICAgICAgIGxldCB7IGRhdGVJbmNyZW1lbnQgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCBjdXN0b21BbGlnbm1lbnQ7XG4gICAgICAgIGlmIChkYXRlSW5jcmVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0ZUluY3JlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGN1c3RvbUFsaWdubWVudCA9IHRoaXMucHJvcHMuZGF0ZUFsaWdubWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbigxLCBjdXN0b21BbGlnbm1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7IGRheXM6IDEgfSk7XG4gICAgfVxuICAgIHJlZmluZVJhbmdlKHJhbmdlSW5wdXQpIHtcbiAgICAgICAgaWYgKHJhbmdlSW5wdXQpIHtcbiAgICAgICAgICAgIGxldCByYW5nZSA9IHBhcnNlUmFuZ2UocmFuZ2VJbnB1dCwgdGhpcy5wcm9wcy5kYXRlRW52KTtcbiAgICAgICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgICAgIHJhbmdlID0gY29tcHV0ZVZpc2libGVEYXlSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qIEhpZGRlbiBEYXlzXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgICAvLyBJbml0aWFsaXplcyBpbnRlcm5hbCB2YXJpYWJsZXMgcmVsYXRlZCB0byBjYWxjdWxhdGluZyBoaWRkZW4gZGF5cy1vZi13ZWVrXG4gICAgaW5pdEhpZGRlbkRheXMoKSB7XG4gICAgICAgIGxldCBoaWRkZW5EYXlzID0gdGhpcy5wcm9wcy5oaWRkZW5EYXlzIHx8IFtdOyAvLyBhcnJheSBvZiBkYXktb2Ytd2VlayBpbmRpY2VzIHRoYXQgYXJlIGhpZGRlblxuICAgICAgICBsZXQgaXNIaWRkZW5EYXlIYXNoID0gW107IC8vIGlzIHRoZSBkYXktb2Ytd2VlayBoaWRkZW4/IChoYXNoIHdpdGggZGF5LW9mLXdlZWstaW5kZXggLT4gYm9vbClcbiAgICAgICAgbGV0IGRheUNudCA9IDA7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy53ZWVrZW5kcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGhpZGRlbkRheXMucHVzaCgwLCA2KTsgLy8gMD1zdW5kYXksIDY9c2F0dXJkYXlcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAoIShpc0hpZGRlbkRheUhhc2hbaV0gPSBoaWRkZW5EYXlzLmluZGV4T2YoaSkgIT09IC0xKSkge1xuICAgICAgICAgICAgICAgIGRheUNudCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZGF5Q250KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaGlkZGVuRGF5cycpOyAvLyBhbGwgZGF5cyB3ZXJlIGhpZGRlbj8gYmFkLlxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNIaWRkZW5EYXlIYXNoID0gaXNIaWRkZW5EYXlIYXNoO1xuICAgIH1cbiAgICAvLyBSZW1vdmUgZGF5cyBmcm9tIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiB0aGUgcmFuZ2UgdGhhdCBhcmUgY29tcHV0ZWQgYXMgaGlkZGVuLlxuICAgIC8vIElmIHRoZSB3aG9sZSByYW5nZSBpcyB0cmltbWVkIG9mZiwgcmV0dXJucyBudWxsXG4gICAgdHJpbUhpZGRlbkRheXMocmFuZ2UpIHtcbiAgICAgICAgbGV0IHsgc3RhcnQsIGVuZCB9ID0gcmFuZ2U7XG4gICAgICAgIGlmIChzdGFydCkge1xuICAgICAgICAgICAgc3RhcnQgPSB0aGlzLnNraXBIaWRkZW5EYXlzKHN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kKSB7XG4gICAgICAgICAgICBlbmQgPSB0aGlzLnNraXBIaWRkZW5EYXlzKGVuZCwgLTEsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCA9PSBudWxsIHx8IGVuZCA9PSBudWxsIHx8IHN0YXJ0IDwgZW5kKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdGFydCwgZW5kIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIElzIHRoZSBjdXJyZW50IGRheSBoaWRkZW4/XG4gICAgLy8gYGRheWAgaXMgYSBkYXktb2Ytd2VlayBpbmRleCAoMC02KSwgb3IgYSBEYXRlICh1c2VkIGZvciBVVEMpXG4gICAgaXNIaWRkZW5EYXkoZGF5KSB7XG4gICAgICAgIGlmIChkYXkgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICBkYXkgPSBkYXkuZ2V0VVRDRGF5KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaXNIaWRkZW5EYXlIYXNoW2RheV07XG4gICAgfVxuICAgIC8vIEluY3JlbWVudGluZyB0aGUgY3VycmVudCBkYXkgdW50aWwgaXQgaXMgbm8gbG9uZ2VyIGEgaGlkZGVuIGRheSwgcmV0dXJuaW5nIGEgY29weS5cbiAgICAvLyBET0VTIE5PVCBDT05TSURFUiB2YWxpZFJhbmdlIVxuICAgIC8vIElmIHRoZSBpbml0aWFsIHZhbHVlIG9mIGBkYXRlYCBpcyBub3QgYSBoaWRkZW4gZGF5LCBkb24ndCBkbyBhbnl0aGluZy5cbiAgICAvLyBQYXNzIGBpc0V4Y2x1c2l2ZWAgYXMgYHRydWVgIGlmIHlvdSBhcmUgZGVhbGluZyB3aXRoIGFuIGVuZCBkYXRlLlxuICAgIC8vIGBpbmNgIGRlZmF1bHRzIHRvIGAxYCAoaW5jcmVtZW50IG9uZSBkYXkgZm9yd2FyZCBlYWNoIHRpbWUpXG4gICAgc2tpcEhpZGRlbkRheXMoZGF0ZSwgaW5jID0gMSwgaXNFeGNsdXNpdmUgPSBmYWxzZSkge1xuICAgICAgICB3aGlsZSAodGhpcy5pc0hpZGRlbkRheUhhc2hbKGRhdGUuZ2V0VVRDRGF5KCkgKyAoaXNFeGNsdXNpdmUgPyBpbmMgOiAwKSArIDcpICUgN10pIHtcbiAgICAgICAgICAgIGRhdGUgPSBhZGREYXlzKGRhdGUsIGluYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFdmVudEluc3RhbmNlKGRlZklkLCByYW5nZSwgZm9yY2VkU3RhcnRUem8sIGZvcmNlZEVuZFR6bykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGluc3RhbmNlSWQ6IGd1aWQoKSxcbiAgICAgICAgZGVmSWQsXG4gICAgICAgIHJhbmdlLFxuICAgICAgICBmb3JjZWRTdGFydFR6bzogZm9yY2VkU3RhcnRUem8gPT0gbnVsbCA/IG51bGwgOiBmb3JjZWRTdGFydFR6byxcbiAgICAgICAgZm9yY2VkRW5kVHpvOiBmb3JjZWRFbmRUem8gPT0gbnVsbCA/IG51bGwgOiBmb3JjZWRFbmRUem8sXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VSZWN1cnJpbmcocmVmaW5lZCwgZGVmYXVsdEFsbERheSwgZGF0ZUVudiwgcmVjdXJyaW5nVHlwZXMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY3VycmluZ1R5cGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGxldCBwYXJzZWQgPSByZWN1cnJpbmdUeXBlc1tpXS5wYXJzZShyZWZpbmVkLCBkYXRlRW52KTtcbiAgICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICAgICAgbGV0IHsgYWxsRGF5IH0gPSByZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGFsbERheSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYWxsRGF5ID0gZGVmYXVsdEFsbERheTtcbiAgICAgICAgICAgICAgICBpZiAoYWxsRGF5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsRGF5ID0gcGFyc2VkLmFsbERheUd1ZXNzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWxsRGF5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbERheSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhbGxEYXksXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IHBhcnNlZC5kdXJhdGlvbixcbiAgICAgICAgICAgICAgICB0eXBlRGF0YTogcGFyc2VkLnR5cGVEYXRhLFxuICAgICAgICAgICAgICAgIHR5cGVJZDogaSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBleHBhbmRSZWN1cnJpbmcoZXZlbnRTdG9yZSwgZnJhbWluZ1JhbmdlLCBjb250ZXh0KSB7XG4gICAgbGV0IHsgZGF0ZUVudiwgcGx1Z2luSG9va3MsIG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgbGV0IHsgZGVmcywgaW5zdGFuY2VzIH0gPSBldmVudFN0b3JlO1xuICAgIC8vIHJlbW92ZSBleGlzdGluZyByZWN1cnJpbmcgaW5zdGFuY2VzXG4gICAgLy8gVE9ETzogYmFkLiBhbHdheXMgZXhwYW5kIGV2ZW50cyBhcyBhIHNlY29uZCBzdGVwXG4gICAgaW5zdGFuY2VzID0gZmlsdGVySGFzaChpbnN0YW5jZXMsIChpbnN0YW5jZSkgPT4gIWRlZnNbaW5zdGFuY2UuZGVmSWRdLnJlY3VycmluZ0RlZik7XG4gICAgZm9yIChsZXQgZGVmSWQgaW4gZGVmcykge1xuICAgICAgICBsZXQgZGVmID0gZGVmc1tkZWZJZF07XG4gICAgICAgIGlmIChkZWYucmVjdXJyaW5nRGVmKSB7XG4gICAgICAgICAgICBsZXQgeyBkdXJhdGlvbiB9ID0gZGVmLnJlY3VycmluZ0RlZjtcbiAgICAgICAgICAgIGlmICghZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IGRlZi5hbGxEYXkgP1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uIDpcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kZWZhdWx0VGltZWRFdmVudER1cmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHN0YXJ0cyA9IGV4cGFuZFJlY3VycmluZ1JhbmdlcyhkZWYsIGR1cmF0aW9uLCBmcmFtaW5nUmFuZ2UsIGRhdGVFbnYsIHBsdWdpbkhvb2tzLnJlY3VycmluZ1R5cGVzKTtcbiAgICAgICAgICAgIGZvciAobGV0IHN0YXJ0IG9mIHN0YXJ0cykge1xuICAgICAgICAgICAgICAgIGxldCBpbnN0YW5jZSA9IGNyZWF0ZUV2ZW50SW5zdGFuY2UoZGVmSWQsIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogZGF0ZUVudi5hZGQoc3RhcnQsIGR1cmF0aW9uKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZXNbaW5zdGFuY2UuaW5zdGFuY2VJZF0gPSBpbnN0YW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBkZWZzLCBpbnN0YW5jZXMgfTtcbn1cbi8qXG5FdmVudCBNVVNUIGhhdmUgYSByZWN1cnJpbmdEZWZcbiovXG5mdW5jdGlvbiBleHBhbmRSZWN1cnJpbmdSYW5nZXMoZXZlbnREZWYsIGR1cmF0aW9uLCBmcmFtaW5nUmFuZ2UsIGRhdGVFbnYsIHJlY3VycmluZ1R5cGVzKSB7XG4gICAgbGV0IHR5cGVEZWYgPSByZWN1cnJpbmdUeXBlc1tldmVudERlZi5yZWN1cnJpbmdEZWYudHlwZUlkXTtcbiAgICBsZXQgbWFya2VycyA9IHR5cGVEZWYuZXhwYW5kKGV2ZW50RGVmLnJlY3VycmluZ0RlZi50eXBlRGF0YSwge1xuICAgICAgICBzdGFydDogZGF0ZUVudi5zdWJ0cmFjdChmcmFtaW5nUmFuZ2Uuc3RhcnQsIGR1cmF0aW9uKSxcbiAgICAgICAgZW5kOiBmcmFtaW5nUmFuZ2UuZW5kLFxuICAgIH0sIGRhdGVFbnYpO1xuICAgIC8vIHRoZSByZWN1cnJlbmNlIHBsdWdpbnMgZG9uJ3QgZ3VhcmFudGVlIHRoYXQgYWxsLWRheSBldmVudHMgYXJlIHN0YXJ0LW9mLWRheSwgc28gd2UgaGF2ZSB0b1xuICAgIGlmIChldmVudERlZi5hbGxEYXkpIHtcbiAgICAgICAgbWFya2VycyA9IG1hcmtlcnMubWFwKHN0YXJ0T2ZEYXkpO1xuICAgIH1cbiAgICByZXR1cm4gbWFya2Vycztcbn1cblxuY29uc3QgRVZFTlRfTk9OX0RBVEVfUkVGSU5FUlMgPSB7XG4gICAgaWQ6IFN0cmluZyxcbiAgICBncm91cElkOiBTdHJpbmcsXG4gICAgdGl0bGU6IFN0cmluZyxcbiAgICB1cmw6IFN0cmluZyxcbiAgICBpbnRlcmFjdGl2ZTogQm9vbGVhbixcbn07XG5jb25zdCBFVkVOVF9EQVRFX1JFRklORVJTID0ge1xuICAgIHN0YXJ0OiBpZGVudGl0eSxcbiAgICBlbmQ6IGlkZW50aXR5LFxuICAgIGRhdGU6IGlkZW50aXR5LFxuICAgIGFsbERheTogQm9vbGVhbixcbn07XG5jb25zdCBFVkVOVF9SRUZJTkVSUyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBFVkVOVF9OT05fREFURV9SRUZJTkVSUyksIEVWRU5UX0RBVEVfUkVGSU5FUlMpLCB7IGV4dGVuZGVkUHJvcHM6IGlkZW50aXR5IH0pO1xuZnVuY3Rpb24gcGFyc2VFdmVudChyYXcsIGV2ZW50U291cmNlLCBjb250ZXh0LCBhbGxvd09wZW5SYW5nZSwgcmVmaW5lcnMgPSBidWlsZEV2ZW50UmVmaW5lcnMoY29udGV4dCksIGRlZklkTWFwLCBpbnN0YW5jZUlkTWFwKSB7XG4gICAgbGV0IHsgcmVmaW5lZCwgZXh0cmEgfSA9IHJlZmluZUV2ZW50RGVmKHJhdywgY29udGV4dCwgcmVmaW5lcnMpO1xuICAgIGxldCBkZWZhdWx0QWxsRGF5ID0gY29tcHV0ZUlzRGVmYXVsdEFsbERheShldmVudFNvdXJjZSwgY29udGV4dCk7XG4gICAgbGV0IHJlY3VycmluZ1JlcyA9IHBhcnNlUmVjdXJyaW5nKHJlZmluZWQsIGRlZmF1bHRBbGxEYXksIGNvbnRleHQuZGF0ZUVudiwgY29udGV4dC5wbHVnaW5Ib29rcy5yZWN1cnJpbmdUeXBlcyk7XG4gICAgaWYgKHJlY3VycmluZ1Jlcykge1xuICAgICAgICBsZXQgZGVmID0gcGFyc2VFdmVudERlZihyZWZpbmVkLCBleHRyYSwgZXZlbnRTb3VyY2UgPyBldmVudFNvdXJjZS5zb3VyY2VJZCA6ICcnLCByZWN1cnJpbmdSZXMuYWxsRGF5LCBCb29sZWFuKHJlY3VycmluZ1Jlcy5kdXJhdGlvbiksIGNvbnRleHQsIGRlZklkTWFwKTtcbiAgICAgICAgZGVmLnJlY3VycmluZ0RlZiA9IHtcbiAgICAgICAgICAgIHR5cGVJZDogcmVjdXJyaW5nUmVzLnR5cGVJZCxcbiAgICAgICAgICAgIHR5cGVEYXRhOiByZWN1cnJpbmdSZXMudHlwZURhdGEsXG4gICAgICAgICAgICBkdXJhdGlvbjogcmVjdXJyaW5nUmVzLmR1cmF0aW9uLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4geyBkZWYsIGluc3RhbmNlOiBudWxsIH07XG4gICAgfVxuICAgIGxldCBzaW5nbGVSZXMgPSBwYXJzZVNpbmdsZShyZWZpbmVkLCBkZWZhdWx0QWxsRGF5LCBjb250ZXh0LCBhbGxvd09wZW5SYW5nZSk7XG4gICAgaWYgKHNpbmdsZVJlcykge1xuICAgICAgICBsZXQgZGVmID0gcGFyc2VFdmVudERlZihyZWZpbmVkLCBleHRyYSwgZXZlbnRTb3VyY2UgPyBldmVudFNvdXJjZS5zb3VyY2VJZCA6ICcnLCBzaW5nbGVSZXMuYWxsRGF5LCBzaW5nbGVSZXMuaGFzRW5kLCBjb250ZXh0LCBkZWZJZE1hcCk7XG4gICAgICAgIGxldCBpbnN0YW5jZSA9IGNyZWF0ZUV2ZW50SW5zdGFuY2UoZGVmLmRlZklkLCBzaW5nbGVSZXMucmFuZ2UsIHNpbmdsZVJlcy5mb3JjZWRTdGFydFR6bywgc2luZ2xlUmVzLmZvcmNlZEVuZFR6byk7XG4gICAgICAgIGlmIChpbnN0YW5jZUlkTWFwICYmIGRlZi5wdWJsaWNJZCAmJiBpbnN0YW5jZUlkTWFwW2RlZi5wdWJsaWNJZF0pIHtcbiAgICAgICAgICAgIGluc3RhbmNlLmluc3RhbmNlSWQgPSBpbnN0YW5jZUlkTWFwW2RlZi5wdWJsaWNJZF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZGVmLCBpbnN0YW5jZSB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHJlZmluZUV2ZW50RGVmKHJhdywgY29udGV4dCwgcmVmaW5lcnMgPSBidWlsZEV2ZW50UmVmaW5lcnMoY29udGV4dCkpIHtcbiAgICByZXR1cm4gcmVmaW5lUHJvcHMocmF3LCByZWZpbmVycyk7XG59XG5mdW5jdGlvbiBidWlsZEV2ZW50UmVmaW5lcnMoY29udGV4dCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgRVZFTlRfVUlfUkVGSU5FUlMpLCBFVkVOVF9SRUZJTkVSUyksIGNvbnRleHQucGx1Z2luSG9va3MuZXZlbnRSZWZpbmVycyk7XG59XG4vKlxuV2lsbCBOT1QgcG9wdWxhdGUgZXh0ZW5kZWRQcm9wcyB3aXRoIHRoZSBsZWZ0b3ZlciBwcm9wZXJ0aWVzLlxuV2lsbCBOT1QgcG9wdWxhdGUgZGF0ZS1yZWxhdGVkIHByb3BzLlxuKi9cbmZ1bmN0aW9uIHBhcnNlRXZlbnREZWYocmVmaW5lZCwgZXh0cmEsIHNvdXJjZUlkLCBhbGxEYXksIGhhc0VuZCwgY29udGV4dCwgZGVmSWRNYXApIHtcbiAgICBsZXQgZGVmID0ge1xuICAgICAgICB0aXRsZTogcmVmaW5lZC50aXRsZSB8fCAnJyxcbiAgICAgICAgZ3JvdXBJZDogcmVmaW5lZC5ncm91cElkIHx8ICcnLFxuICAgICAgICBwdWJsaWNJZDogcmVmaW5lZC5pZCB8fCAnJyxcbiAgICAgICAgdXJsOiByZWZpbmVkLnVybCB8fCAnJyxcbiAgICAgICAgcmVjdXJyaW5nRGVmOiBudWxsLFxuICAgICAgICBkZWZJZDogKChkZWZJZE1hcCAmJiByZWZpbmVkLmlkKSA/IGRlZklkTWFwW3JlZmluZWQuaWRdIDogJycpIHx8IGd1aWQoKSxcbiAgICAgICAgc291cmNlSWQsXG4gICAgICAgIGFsbERheSxcbiAgICAgICAgaGFzRW5kLFxuICAgICAgICBpbnRlcmFjdGl2ZTogcmVmaW5lZC5pbnRlcmFjdGl2ZSxcbiAgICAgICAgdWk6IGNyZWF0ZUV2ZW50VWkocmVmaW5lZCwgY29udGV4dCksXG4gICAgICAgIGV4dGVuZGVkUHJvcHM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKHJlZmluZWQuZXh0ZW5kZWRQcm9wcyB8fCB7fSkpLCBleHRyYSksXG4gICAgfTtcbiAgICBmb3IgKGxldCBtZW1iZXJBZGRlciBvZiBjb250ZXh0LnBsdWdpbkhvb2tzLmV2ZW50RGVmTWVtYmVyQWRkZXJzKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oZGVmLCBtZW1iZXJBZGRlcihyZWZpbmVkKSk7XG4gICAgfVxuICAgIC8vIGhlbHAgb3V0IEV2ZW50SW1wbCBmcm9tIGhhdmluZyB1c2VyIG1vZGlmeSBwcm9wc1xuICAgIE9iamVjdC5mcmVlemUoZGVmLnVpLmNsYXNzTmFtZXMpO1xuICAgIE9iamVjdC5mcmVlemUoZGVmLmV4dGVuZGVkUHJvcHMpO1xuICAgIHJldHVybiBkZWY7XG59XG5mdW5jdGlvbiBwYXJzZVNpbmdsZShyZWZpbmVkLCBkZWZhdWx0QWxsRGF5LCBjb250ZXh0LCBhbGxvd09wZW5SYW5nZSkge1xuICAgIGxldCB7IGFsbERheSB9ID0gcmVmaW5lZDtcbiAgICBsZXQgc3RhcnRNZXRhO1xuICAgIGxldCBzdGFydE1hcmtlciA9IG51bGw7XG4gICAgbGV0IGhhc0VuZCA9IGZhbHNlO1xuICAgIGxldCBlbmRNZXRhO1xuICAgIGxldCBlbmRNYXJrZXIgPSBudWxsO1xuICAgIGxldCBzdGFydElucHV0ID0gcmVmaW5lZC5zdGFydCAhPSBudWxsID8gcmVmaW5lZC5zdGFydCA6IHJlZmluZWQuZGF0ZTtcbiAgICBzdGFydE1ldGEgPSBjb250ZXh0LmRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShzdGFydElucHV0KTtcbiAgICBpZiAoc3RhcnRNZXRhKSB7XG4gICAgICAgIHN0YXJ0TWFya2VyID0gc3RhcnRNZXRhLm1hcmtlcjtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWFsbG93T3BlblJhbmdlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAocmVmaW5lZC5lbmQgIT0gbnVsbCkge1xuICAgICAgICBlbmRNZXRhID0gY29udGV4dC5kYXRlRW52LmNyZWF0ZU1hcmtlck1ldGEocmVmaW5lZC5lbmQpO1xuICAgIH1cbiAgICBpZiAoYWxsRGF5ID09IG51bGwpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRBbGxEYXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgYWxsRGF5ID0gZGVmYXVsdEFsbERheTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZhbGwgYmFjayB0byB0aGUgZGF0ZSBwcm9wcyBMQVNUXG4gICAgICAgICAgICBhbGxEYXkgPSAoIXN0YXJ0TWV0YSB8fCBzdGFydE1ldGEuaXNUaW1lVW5zcGVjaWZpZWQpICYmXG4gICAgICAgICAgICAgICAgKCFlbmRNZXRhIHx8IGVuZE1ldGEuaXNUaW1lVW5zcGVjaWZpZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChhbGxEYXkgJiYgc3RhcnRNYXJrZXIpIHtcbiAgICAgICAgc3RhcnRNYXJrZXIgPSBzdGFydE9mRGF5KHN0YXJ0TWFya2VyKTtcbiAgICB9XG4gICAgaWYgKGVuZE1ldGEpIHtcbiAgICAgICAgZW5kTWFya2VyID0gZW5kTWV0YS5tYXJrZXI7XG4gICAgICAgIGlmIChhbGxEYXkpIHtcbiAgICAgICAgICAgIGVuZE1hcmtlciA9IHN0YXJ0T2ZEYXkoZW5kTWFya2VyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRNYXJrZXIgJiYgZW5kTWFya2VyIDw9IHN0YXJ0TWFya2VyKSB7XG4gICAgICAgICAgICBlbmRNYXJrZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChlbmRNYXJrZXIpIHtcbiAgICAgICAgaGFzRW5kID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWFsbG93T3BlblJhbmdlKSB7XG4gICAgICAgIGhhc0VuZCA9IGNvbnRleHQub3B0aW9ucy5mb3JjZUV2ZW50RHVyYXRpb24gfHwgZmFsc2U7XG4gICAgICAgIGVuZE1hcmtlciA9IGNvbnRleHQuZGF0ZUVudi5hZGQoc3RhcnRNYXJrZXIsIGFsbERheSA/XG4gICAgICAgICAgICBjb250ZXh0Lm9wdGlvbnMuZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb24gOlxuICAgICAgICAgICAgY29udGV4dC5vcHRpb25zLmRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBhbGxEYXksXG4gICAgICAgIGhhc0VuZCxcbiAgICAgICAgcmFuZ2U6IHsgc3RhcnQ6IHN0YXJ0TWFya2VyLCBlbmQ6IGVuZE1hcmtlciB9LFxuICAgICAgICBmb3JjZWRTdGFydFR6bzogc3RhcnRNZXRhID8gc3RhcnRNZXRhLmZvcmNlZFR6byA6IG51bGwsXG4gICAgICAgIGZvcmNlZEVuZFR6bzogZW5kTWV0YSA/IGVuZE1ldGEuZm9yY2VkVHpvIDogbnVsbCxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcHV0ZUlzRGVmYXVsdEFsbERheShldmVudFNvdXJjZSwgY29udGV4dCkge1xuICAgIGxldCByZXMgPSBudWxsO1xuICAgIGlmIChldmVudFNvdXJjZSkge1xuICAgICAgICByZXMgPSBldmVudFNvdXJjZS5kZWZhdWx0QWxsRGF5O1xuICAgIH1cbiAgICBpZiAocmVzID09IG51bGwpIHtcbiAgICAgICAgcmVzID0gY29udGV4dC5vcHRpb25zLmRlZmF1bHRBbGxEYXk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRXZlbnRzKHJhd0V2ZW50cywgZXZlbnRTb3VyY2UsIGNvbnRleHQsIGFsbG93T3BlblJhbmdlLCBkZWZJZE1hcCwgaW5zdGFuY2VJZE1hcCkge1xuICAgIGxldCBldmVudFN0b3JlID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7XG4gICAgbGV0IGV2ZW50UmVmaW5lcnMgPSBidWlsZEV2ZW50UmVmaW5lcnMoY29udGV4dCk7XG4gICAgZm9yIChsZXQgcmF3RXZlbnQgb2YgcmF3RXZlbnRzKSB7XG4gICAgICAgIGxldCB0dXBsZSA9IHBhcnNlRXZlbnQocmF3RXZlbnQsIGV2ZW50U291cmNlLCBjb250ZXh0LCBhbGxvd09wZW5SYW5nZSwgZXZlbnRSZWZpbmVycywgZGVmSWRNYXAsIGluc3RhbmNlSWRNYXApO1xuICAgICAgICBpZiAodHVwbGUpIHtcbiAgICAgICAgICAgIGV2ZW50VHVwbGVUb1N0b3JlKHR1cGxlLCBldmVudFN0b3JlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXZlbnRTdG9yZTtcbn1cbmZ1bmN0aW9uIGV2ZW50VHVwbGVUb1N0b3JlKHR1cGxlLCBldmVudFN0b3JlID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCkpIHtcbiAgICBldmVudFN0b3JlLmRlZnNbdHVwbGUuZGVmLmRlZklkXSA9IHR1cGxlLmRlZjtcbiAgICBpZiAodHVwbGUuaW5zdGFuY2UpIHtcbiAgICAgICAgZXZlbnRTdG9yZS5pbnN0YW5jZXNbdHVwbGUuaW5zdGFuY2UuaW5zdGFuY2VJZF0gPSB0dXBsZS5pbnN0YW5jZTtcbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50U3RvcmU7XG59XG4vLyByZXRyaWV2ZXMgZXZlbnRzIHRoYXQgaGF2ZSB0aGUgc2FtZSBncm91cElkIGFzIHRoZSBpbnN0YW5jZSBzcGVjaWZpZWQgYnkgYGluc3RhbmNlSWRgXG4vLyBvciB0aGV5IGFyZSB0aGUgc2FtZSBhcyB0aGUgaW5zdGFuY2UuXG4vLyB3aHkgbWlnaHQgaW5zdGFuY2VJZCBub3QgYmUgaW4gdGhlIHN0b3JlPyBhbiBldmVudCBmcm9tIGFub3RoZXIgY2FsZW5kYXI/XG5mdW5jdGlvbiBnZXRSZWxldmFudEV2ZW50cyhldmVudFN0b3JlLCBpbnN0YW5jZUlkKSB7XG4gICAgbGV0IGluc3RhbmNlID0gZXZlbnRTdG9yZS5pbnN0YW5jZXNbaW5zdGFuY2VJZF07XG4gICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgIGxldCBkZWYgPSBldmVudFN0b3JlLmRlZnNbaW5zdGFuY2UuZGVmSWRdO1xuICAgICAgICAvLyBnZXQgZXZlbnRzL2luc3RhbmNlcyB3aXRoIHNhbWUgZ3JvdXBcbiAgICAgICAgbGV0IG5ld1N0b3JlID0gZmlsdGVyRXZlbnRTdG9yZURlZnMoZXZlbnRTdG9yZSwgKGxvb2tEZWYpID0+IGlzRXZlbnREZWZzR3JvdXBlZChkZWYsIGxvb2tEZWYpKTtcbiAgICAgICAgLy8gYWRkIHRoZSBvcmlnaW5hbFxuICAgICAgICAvLyBUT0RPOiB3aXNoIHdlIGNvdWxkIHVzZSBldmVudFR1cGxlVG9TdG9yZSBvciBzb21ldGhpbmcgbGlrZSBpdFxuICAgICAgICBuZXdTdG9yZS5kZWZzW2RlZi5kZWZJZF0gPSBkZWY7XG4gICAgICAgIG5ld1N0b3JlLmluc3RhbmNlc1tpbnN0YW5jZS5pbnN0YW5jZUlkXSA9IGluc3RhbmNlO1xuICAgICAgICByZXR1cm4gbmV3U3RvcmU7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTtcbn1cbmZ1bmN0aW9uIGlzRXZlbnREZWZzR3JvdXBlZChkZWYwLCBkZWYxKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4oZGVmMC5ncm91cElkICYmIGRlZjAuZ3JvdXBJZCA9PT0gZGVmMS5ncm91cElkKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpIHtcbiAgICByZXR1cm4geyBkZWZzOiB7fSwgaW5zdGFuY2VzOiB7fSB9O1xufVxuZnVuY3Rpb24gbWVyZ2VFdmVudFN0b3JlcyhzdG9yZTAsIHN0b3JlMSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlZnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RvcmUwLmRlZnMpLCBzdG9yZTEuZGVmcyksXG4gICAgICAgIGluc3RhbmNlczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdG9yZTAuaW5zdGFuY2VzKSwgc3RvcmUxLmluc3RhbmNlcyksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZpbHRlckV2ZW50U3RvcmVEZWZzKGV2ZW50U3RvcmUsIGZpbHRlckZ1bmMpIHtcbiAgICBsZXQgZGVmcyA9IGZpbHRlckhhc2goZXZlbnRTdG9yZS5kZWZzLCBmaWx0ZXJGdW5jKTtcbiAgICBsZXQgaW5zdGFuY2VzID0gZmlsdGVySGFzaChldmVudFN0b3JlLmluc3RhbmNlcywgKGluc3RhbmNlKSA9PiAoZGVmc1tpbnN0YW5jZS5kZWZJZF0gLy8gc3RpbGwgZXhpc3RzP1xuICAgICkpO1xuICAgIHJldHVybiB7IGRlZnMsIGluc3RhbmNlcyB9O1xufVxuZnVuY3Rpb24gZXhjbHVkZVN1YkV2ZW50U3RvcmUobWFzdGVyLCBzdWIpIHtcbiAgICBsZXQgeyBkZWZzLCBpbnN0YW5jZXMgfSA9IG1hc3RlcjtcbiAgICBsZXQgZmlsdGVyZWREZWZzID0ge307XG4gICAgbGV0IGZpbHRlcmVkSW5zdGFuY2VzID0ge307XG4gICAgZm9yIChsZXQgZGVmSWQgaW4gZGVmcykge1xuICAgICAgICBpZiAoIXN1Yi5kZWZzW2RlZklkXSkgeyAvLyBub3QgZXhwbGljaXRseSBleGNsdWRlZFxuICAgICAgICAgICAgZmlsdGVyZWREZWZzW2RlZklkXSA9IGRlZnNbZGVmSWRdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGluc3RhbmNlSWQgaW4gaW5zdGFuY2VzKSB7XG4gICAgICAgIGlmICghc3ViLmluc3RhbmNlc1tpbnN0YW5jZUlkXSAmJiAvLyBub3QgZXhwbGljaXRseSBleGNsdWRlZFxuICAgICAgICAgICAgZmlsdGVyZWREZWZzW2luc3RhbmNlc1tpbnN0YW5jZUlkXS5kZWZJZF0gLy8gZGVmIHdhc24ndCBmaWx0ZXJlZCBhd2F5XG4gICAgICAgICkge1xuICAgICAgICAgICAgZmlsdGVyZWRJbnN0YW5jZXNbaW5zdGFuY2VJZF0gPSBpbnN0YW5jZXNbaW5zdGFuY2VJZF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVmczogZmlsdGVyZWREZWZzLFxuICAgICAgICBpbnN0YW5jZXM6IGZpbHRlcmVkSW5zdGFuY2VzLFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbnN0cmFpbnQoaW5wdXQsIGNvbnRleHQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRXZlbnRzKGlucHV0LCBudWxsLCBjb250ZXh0LCB0cnVlKTsgLy8gYWxsb3dPcGVuUmFuZ2U9dHJ1ZVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiBpbnB1dCkgeyAvLyBub24tbnVsbCBvYmplY3RcbiAgICAgICAgcmV0dXJuIHBhcnNlRXZlbnRzKFtpbnB1dF0sIG51bGwsIGNvbnRleHQsIHRydWUpOyAvLyBhbGxvd09wZW5SYW5nZT10cnVlXG4gICAgfVxuICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcoaW5wdXQpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcGFyc2VDbGFzc05hbWVzKHJhdykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJhdykpIHtcbiAgICAgICAgcmV0dXJuIHJhdztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiByYXcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiByYXcuc3BsaXQoL1xccysvKTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufVxuXG4vLyBUT0RPOiBiZXR0ZXIgY2FsbGVkIFwiRXZlbnRTZXR0aW5nc1wiIG9yIFwiRXZlbnRDb25maWdcIlxuLy8gVE9ETzogbW92ZSB0aGlzIGZpbGUgaW50byBzdHJ1Y3RzXG4vLyBUT0RPOiBzZXBhcmF0ZSBjb25zdHJhaW50L292ZXJsYXAvYWxsb3csIGJlY2F1c2Ugc2VsZWN0aW9uIHVzZXMgb25seSB0aGF0LCBub3Qgb3RoZXIgcHJvcHNcbmNvbnN0IEVWRU5UX1VJX1JFRklORVJTID0ge1xuICAgIGRpc3BsYXk6IFN0cmluZyxcbiAgICBlZGl0YWJsZTogQm9vbGVhbixcbiAgICBzdGFydEVkaXRhYmxlOiBCb29sZWFuLFxuICAgIGR1cmF0aW9uRWRpdGFibGU6IEJvb2xlYW4sXG4gICAgY29uc3RyYWludDogaWRlbnRpdHksXG4gICAgb3ZlcmxhcDogaWRlbnRpdHksXG4gICAgYWxsb3c6IGlkZW50aXR5LFxuICAgIGNsYXNzTmFtZTogcGFyc2VDbGFzc05hbWVzLFxuICAgIGNsYXNzTmFtZXM6IHBhcnNlQ2xhc3NOYW1lcyxcbiAgICBjb2xvcjogU3RyaW5nLFxuICAgIGJhY2tncm91bmRDb2xvcjogU3RyaW5nLFxuICAgIGJvcmRlckNvbG9yOiBTdHJpbmcsXG4gICAgdGV4dENvbG9yOiBTdHJpbmcsXG59O1xuY29uc3QgRU1QVFlfRVZFTlRfVUkgPSB7XG4gICAgZGlzcGxheTogbnVsbCxcbiAgICBzdGFydEVkaXRhYmxlOiBudWxsLFxuICAgIGR1cmF0aW9uRWRpdGFibGU6IG51bGwsXG4gICAgY29uc3RyYWludHM6IFtdLFxuICAgIG92ZXJsYXA6IG51bGwsXG4gICAgYWxsb3dzOiBbXSxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICcnLFxuICAgIGJvcmRlckNvbG9yOiAnJyxcbiAgICB0ZXh0Q29sb3I6ICcnLFxuICAgIGNsYXNzTmFtZXM6IFtdLFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50VWkocmVmaW5lZCwgY29udGV4dCkge1xuICAgIGxldCBjb25zdHJhaW50ID0gbm9ybWFsaXplQ29uc3RyYWludChyZWZpbmVkLmNvbnN0cmFpbnQsIGNvbnRleHQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRpc3BsYXk6IHJlZmluZWQuZGlzcGxheSB8fCBudWxsLFxuICAgICAgICBzdGFydEVkaXRhYmxlOiByZWZpbmVkLnN0YXJ0RWRpdGFibGUgIT0gbnVsbCA/IHJlZmluZWQuc3RhcnRFZGl0YWJsZSA6IHJlZmluZWQuZWRpdGFibGUsXG4gICAgICAgIGR1cmF0aW9uRWRpdGFibGU6IHJlZmluZWQuZHVyYXRpb25FZGl0YWJsZSAhPSBudWxsID8gcmVmaW5lZC5kdXJhdGlvbkVkaXRhYmxlIDogcmVmaW5lZC5lZGl0YWJsZSxcbiAgICAgICAgY29uc3RyYWludHM6IGNvbnN0cmFpbnQgIT0gbnVsbCA/IFtjb25zdHJhaW50XSA6IFtdLFxuICAgICAgICBvdmVybGFwOiByZWZpbmVkLm92ZXJsYXAgIT0gbnVsbCA/IHJlZmluZWQub3ZlcmxhcCA6IG51bGwsXG4gICAgICAgIGFsbG93czogcmVmaW5lZC5hbGxvdyAhPSBudWxsID8gW3JlZmluZWQuYWxsb3ddIDogW10sXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogcmVmaW5lZC5iYWNrZ3JvdW5kQ29sb3IgfHwgcmVmaW5lZC5jb2xvciB8fCAnJyxcbiAgICAgICAgYm9yZGVyQ29sb3I6IHJlZmluZWQuYm9yZGVyQ29sb3IgfHwgcmVmaW5lZC5jb2xvciB8fCAnJyxcbiAgICAgICAgdGV4dENvbG9yOiByZWZpbmVkLnRleHRDb2xvciB8fCAnJyxcbiAgICAgICAgY2xhc3NOYW1lczogKHJlZmluZWQuY2xhc3NOYW1lIHx8IFtdKS5jb25jYXQocmVmaW5lZC5jbGFzc05hbWVzIHx8IFtdKSwgLy8gam9pbiBzaW5ndWxhciBhbmQgcGx1cmFsXG4gICAgfTtcbn1cbi8vIFRPRE86IHByZXZlbnQgYWdhaW5zdCBwcm9ibGVtcyB3aXRoIDwyIGFyZ3MhXG5mdW5jdGlvbiBjb21iaW5lRXZlbnRVaXModWlzKSB7XG4gICAgcmV0dXJuIHVpcy5yZWR1Y2UoY29tYmluZVR3b0V2ZW50VWlzLCBFTVBUWV9FVkVOVF9VSSk7XG59XG5mdW5jdGlvbiBjb21iaW5lVHdvRXZlbnRVaXMoaXRlbTAsIGl0ZW0xKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGlzcGxheTogaXRlbTEuZGlzcGxheSAhPSBudWxsID8gaXRlbTEuZGlzcGxheSA6IGl0ZW0wLmRpc3BsYXksXG4gICAgICAgIHN0YXJ0RWRpdGFibGU6IGl0ZW0xLnN0YXJ0RWRpdGFibGUgIT0gbnVsbCA/IGl0ZW0xLnN0YXJ0RWRpdGFibGUgOiBpdGVtMC5zdGFydEVkaXRhYmxlLFxuICAgICAgICBkdXJhdGlvbkVkaXRhYmxlOiBpdGVtMS5kdXJhdGlvbkVkaXRhYmxlICE9IG51bGwgPyBpdGVtMS5kdXJhdGlvbkVkaXRhYmxlIDogaXRlbTAuZHVyYXRpb25FZGl0YWJsZSxcbiAgICAgICAgY29uc3RyYWludHM6IGl0ZW0wLmNvbnN0cmFpbnRzLmNvbmNhdChpdGVtMS5jb25zdHJhaW50cyksXG4gICAgICAgIG92ZXJsYXA6IHR5cGVvZiBpdGVtMS5vdmVybGFwID09PSAnYm9vbGVhbicgPyBpdGVtMS5vdmVybGFwIDogaXRlbTAub3ZlcmxhcCxcbiAgICAgICAgYWxsb3dzOiBpdGVtMC5hbGxvd3MuY29uY2F0KGl0ZW0xLmFsbG93cyksXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogaXRlbTEuYmFja2dyb3VuZENvbG9yIHx8IGl0ZW0wLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgYm9yZGVyQ29sb3I6IGl0ZW0xLmJvcmRlckNvbG9yIHx8IGl0ZW0wLmJvcmRlckNvbG9yLFxuICAgICAgICB0ZXh0Q29sb3I6IGl0ZW0xLnRleHRDb2xvciB8fCBpdGVtMC50ZXh0Q29sb3IsXG4gICAgICAgIGNsYXNzTmFtZXM6IGl0ZW0wLmNsYXNzTmFtZXMuY29uY2F0KGl0ZW0xLmNsYXNzTmFtZXMpLFxuICAgIH07XG59XG5cbmNvbnN0IEVWRU5UX1NPVVJDRV9SRUZJTkVSUyA9IHtcbiAgICBpZDogU3RyaW5nLFxuICAgIGRlZmF1bHRBbGxEYXk6IEJvb2xlYW4sXG4gICAgdXJsOiBTdHJpbmcsXG4gICAgZm9ybWF0OiBTdHJpbmcsXG4gICAgZXZlbnRzOiBpZGVudGl0eSxcbiAgICBldmVudERhdGFUcmFuc2Zvcm06IGlkZW50aXR5LFxuICAgIC8vIGZvciBhbnkgbmV0d29yay1yZWxhdGVkIHNvdXJjZXNcbiAgICBzdWNjZXNzOiBpZGVudGl0eSxcbiAgICBmYWlsdXJlOiBpZGVudGl0eSxcbn07XG5mdW5jdGlvbiBwYXJzZUV2ZW50U291cmNlKHJhdywgY29udGV4dCwgcmVmaW5lcnMgPSBidWlsZEV2ZW50U291cmNlUmVmaW5lcnMoY29udGV4dCkpIHtcbiAgICBsZXQgcmF3T2JqO1xuICAgIGlmICh0eXBlb2YgcmF3ID09PSAnc3RyaW5nJykge1xuICAgICAgICByYXdPYmogPSB7IHVybDogcmF3IH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiByYXcgPT09ICdmdW5jdGlvbicgfHwgQXJyYXkuaXNBcnJheShyYXcpKSB7XG4gICAgICAgIHJhd09iaiA9IHsgZXZlbnRzOiByYXcgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHJhdyA9PT0gJ29iamVjdCcgJiYgcmF3KSB7IC8vIG5vdCBudWxsXG4gICAgICAgIHJhd09iaiA9IHJhdztcbiAgICB9XG4gICAgaWYgKHJhd09iaikge1xuICAgICAgICBsZXQgeyByZWZpbmVkLCBleHRyYSB9ID0gcmVmaW5lUHJvcHMocmF3T2JqLCByZWZpbmVycyk7XG4gICAgICAgIGxldCBtZXRhUmVzID0gYnVpbGRFdmVudFNvdXJjZU1ldGEocmVmaW5lZCwgY29udGV4dCk7XG4gICAgICAgIGlmIChtZXRhUmVzKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIF9yYXc6IHJhdyxcbiAgICAgICAgICAgICAgICBpc0ZldGNoaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBsYXRlc3RGZXRjaElkOiAnJyxcbiAgICAgICAgICAgICAgICBmZXRjaFJhbmdlOiBudWxsLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRBbGxEYXk6IHJlZmluZWQuZGVmYXVsdEFsbERheSxcbiAgICAgICAgICAgICAgICBldmVudERhdGFUcmFuc2Zvcm06IHJlZmluZWQuZXZlbnREYXRhVHJhbnNmb3JtLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHJlZmluZWQuc3VjY2VzcyxcbiAgICAgICAgICAgICAgICBmYWlsdXJlOiByZWZpbmVkLmZhaWx1cmUsXG4gICAgICAgICAgICAgICAgcHVibGljSWQ6IHJlZmluZWQuaWQgfHwgJycsXG4gICAgICAgICAgICAgICAgc291cmNlSWQ6IGd1aWQoKSxcbiAgICAgICAgICAgICAgICBzb3VyY2VEZWZJZDogbWV0YVJlcy5zb3VyY2VEZWZJZCxcbiAgICAgICAgICAgICAgICBtZXRhOiBtZXRhUmVzLm1ldGEsXG4gICAgICAgICAgICAgICAgdWk6IGNyZWF0ZUV2ZW50VWkocmVmaW5lZCwgY29udGV4dCksXG4gICAgICAgICAgICAgICAgZXh0ZW5kZWRQcm9wczogZXh0cmEsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gYnVpbGRFdmVudFNvdXJjZVJlZmluZXJzKGNvbnRleHQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIEVWRU5UX1VJX1JFRklORVJTKSwgRVZFTlRfU09VUkNFX1JFRklORVJTKSwgY29udGV4dC5wbHVnaW5Ib29rcy5ldmVudFNvdXJjZVJlZmluZXJzKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRXZlbnRTb3VyY2VNZXRhKHJhdywgY29udGV4dCkge1xuICAgIGxldCBkZWZzID0gY29udGV4dC5wbHVnaW5Ib29rcy5ldmVudFNvdXJjZURlZnM7XG4gICAgZm9yIChsZXQgaSA9IGRlZnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHsgLy8gbGF0ZXItYWRkZWQgcGx1Z2lucyB0YWtlIHByZWNlZGVuY2VcbiAgICAgICAgbGV0IGRlZiA9IGRlZnNbaV07XG4gICAgICAgIGxldCBtZXRhID0gZGVmLnBhcnNlTWV0YShyYXcpO1xuICAgICAgICBpZiAobWV0YSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgc291cmNlRGVmSWQ6IGksIG1ldGEgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcmVkdWNlRXZlbnRTdG9yZShldmVudFN0b3JlLCBhY3Rpb24sIGV2ZW50U291cmNlcywgZGF0ZVByb2ZpbGUsIGNvbnRleHQpIHtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ1JFQ0VJVkVfRVZFTlRTJzogLy8gcmF3XG4gICAgICAgICAgICByZXR1cm4gcmVjZWl2ZVJhd0V2ZW50cyhldmVudFN0b3JlLCBldmVudFNvdXJjZXNbYWN0aW9uLnNvdXJjZUlkXSwgYWN0aW9uLmZldGNoSWQsIGFjdGlvbi5mZXRjaFJhbmdlLCBhY3Rpb24ucmF3RXZlbnRzLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSAnUkVTRVRfUkFXX0VWRU5UUyc6XG4gICAgICAgICAgICByZXR1cm4gcmVzZXRSYXdFdmVudHMoZXZlbnRTdG9yZSwgZXZlbnRTb3VyY2VzW2FjdGlvbi5zb3VyY2VJZF0sIGFjdGlvbi5yYXdFdmVudHMsIGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSAnQUREX0VWRU5UUyc6IC8vIGFscmVhZHkgcGFyc2VkLCBidXQgbm90IGV4cGFuZGVkXG4gICAgICAgICAgICByZXR1cm4gYWRkRXZlbnQoZXZlbnRTdG9yZSwgYWN0aW9uLmV2ZW50U3RvcmUsIC8vIG5ldyBvbmVzXG4gICAgICAgICAgICBkYXRlUHJvZmlsZSA/IGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlIDogbnVsbCwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgJ1JFU0VUX0VWRU5UUyc6XG4gICAgICAgICAgICByZXR1cm4gYWN0aW9uLmV2ZW50U3RvcmU7XG4gICAgICAgIGNhc2UgJ01FUkdFX0VWRU5UUyc6IC8vIGFscmVhZHkgcGFyc2VkIGFuZCBleHBhbmRlZFxuICAgICAgICAgICAgcmV0dXJuIG1lcmdlRXZlbnRTdG9yZXMoZXZlbnRTdG9yZSwgYWN0aW9uLmV2ZW50U3RvcmUpO1xuICAgICAgICBjYXNlICdQUkVWJzogLy8gVE9ETzogaG93IGRvIHdlIHRyYWNrIGFsbCBhY3Rpb25zIHRoYXQgYWZmZWN0IGRhdGVQcm9maWxlIDooXG4gICAgICAgIGNhc2UgJ05FWFQnOlxuICAgICAgICBjYXNlICdDSEFOR0VfREFURSc6XG4gICAgICAgIGNhc2UgJ0NIQU5HRV9WSUVXX1RZUEUnOlxuICAgICAgICAgICAgaWYgKGRhdGVQcm9maWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cGFuZFJlY3VycmluZyhldmVudFN0b3JlLCBkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRTdG9yZTtcbiAgICAgICAgY2FzZSAnUkVNT1ZFX0VWRU5UUyc6XG4gICAgICAgICAgICByZXR1cm4gZXhjbHVkZVN1YkV2ZW50U3RvcmUoZXZlbnRTdG9yZSwgYWN0aW9uLmV2ZW50U3RvcmUpO1xuICAgICAgICBjYXNlICdSRU1PVkVfRVZFTlRfU09VUkNFJzpcbiAgICAgICAgICAgIHJldHVybiBleGNsdWRlRXZlbnRzQnlTb3VyY2VJZChldmVudFN0b3JlLCBhY3Rpb24uc291cmNlSWQpO1xuICAgICAgICBjYXNlICdSRU1PVkVfQUxMX0VWRU5UX1NPVVJDRVMnOlxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlckV2ZW50U3RvcmVEZWZzKGV2ZW50U3RvcmUsIChldmVudERlZikgPT4gKCFldmVudERlZi5zb3VyY2VJZCAvLyBvbmx5IGtlZXAgZXZlbnRzIHdpdGggbm8gc291cmNlIGlkXG4gICAgICAgICAgICApKTtcbiAgICAgICAgY2FzZSAnUkVNT1ZFX0FMTF9FVkVOVFMnOlxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50U3RvcmU7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVjZWl2ZVJhd0V2ZW50cyhldmVudFN0b3JlLCBldmVudFNvdXJjZSwgZmV0Y2hJZCwgZmV0Y2hSYW5nZSwgcmF3RXZlbnRzLCBjb250ZXh0KSB7XG4gICAgaWYgKGV2ZW50U291cmNlICYmIC8vIG5vdCBhbHJlYWR5IHJlbW92ZWRcbiAgICAgICAgZmV0Y2hJZCA9PT0gZXZlbnRTb3VyY2UubGF0ZXN0RmV0Y2hJZCAvLyBUT0RPOiB3aXNoIHRoaXMgbG9naWMgd2FzIGFsd2F5cyBpbiBldmVudC1zb3VyY2VzXG4gICAgKSB7XG4gICAgICAgIGxldCBzdWJzZXQgPSBwYXJzZUV2ZW50cyh0cmFuc2Zvcm1SYXdFdmVudHMocmF3RXZlbnRzLCBldmVudFNvdXJjZSwgY29udGV4dCksIGV2ZW50U291cmNlLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKGZldGNoUmFuZ2UpIHtcbiAgICAgICAgICAgIHN1YnNldCA9IGV4cGFuZFJlY3VycmluZyhzdWJzZXQsIGZldGNoUmFuZ2UsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXJnZUV2ZW50U3RvcmVzKGV4Y2x1ZGVFdmVudHNCeVNvdXJjZUlkKGV2ZW50U3RvcmUsIGV2ZW50U291cmNlLnNvdXJjZUlkKSwgc3Vic2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50U3RvcmU7XG59XG5mdW5jdGlvbiByZXNldFJhd0V2ZW50cyhleGlzdGluZ0V2ZW50U3RvcmUsIGV2ZW50U291cmNlLCByYXdFdmVudHMsIGFjdGl2ZVJhbmdlLCBjb250ZXh0KSB7XG4gICAgY29uc3QgeyBkZWZJZE1hcCwgaW5zdGFuY2VJZE1hcCB9ID0gYnVpbGRQdWJsaWNJZE1hcHMoZXhpc3RpbmdFdmVudFN0b3JlKTtcbiAgICBsZXQgbmV3RXZlbnRTdG9yZSA9IHBhcnNlRXZlbnRzKHRyYW5zZm9ybVJhd0V2ZW50cyhyYXdFdmVudHMsIGV2ZW50U291cmNlLCBjb250ZXh0KSwgZXZlbnRTb3VyY2UsIGNvbnRleHQsIGZhbHNlLCBkZWZJZE1hcCwgaW5zdGFuY2VJZE1hcCk7XG4gICAgcmV0dXJuIGV4cGFuZFJlY3VycmluZyhuZXdFdmVudFN0b3JlLCBhY3RpdmVSYW5nZSwgY29udGV4dCk7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1SYXdFdmVudHMocmF3RXZlbnRzLCBldmVudFNvdXJjZSwgY29udGV4dCkge1xuICAgIGxldCBjYWxFYWNoVHJhbnNmb3JtID0gY29udGV4dC5vcHRpb25zLmV2ZW50RGF0YVRyYW5zZm9ybTtcbiAgICBsZXQgc291cmNlRWFjaFRyYW5zZm9ybSA9IGV2ZW50U291cmNlID8gZXZlbnRTb3VyY2UuZXZlbnREYXRhVHJhbnNmb3JtIDogbnVsbDtcbiAgICBpZiAoc291cmNlRWFjaFRyYW5zZm9ybSkge1xuICAgICAgICByYXdFdmVudHMgPSB0cmFuc2Zvcm1FYWNoUmF3RXZlbnQocmF3RXZlbnRzLCBzb3VyY2VFYWNoVHJhbnNmb3JtKTtcbiAgICB9XG4gICAgaWYgKGNhbEVhY2hUcmFuc2Zvcm0pIHtcbiAgICAgICAgcmF3RXZlbnRzID0gdHJhbnNmb3JtRWFjaFJhd0V2ZW50KHJhd0V2ZW50cywgY2FsRWFjaFRyYW5zZm9ybSk7XG4gICAgfVxuICAgIHJldHVybiByYXdFdmVudHM7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1FYWNoUmF3RXZlbnQocmF3RXZlbnRzLCBmdW5jKSB7XG4gICAgbGV0IHJlZmluZWRFdmVudHM7XG4gICAgaWYgKCFmdW5jKSB7XG4gICAgICAgIHJlZmluZWRFdmVudHMgPSByYXdFdmVudHM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZWZpbmVkRXZlbnRzID0gW107XG4gICAgICAgIGZvciAobGV0IHJhd0V2ZW50IG9mIHJhd0V2ZW50cykge1xuICAgICAgICAgICAgbGV0IHJlZmluZWRFdmVudCA9IGZ1bmMocmF3RXZlbnQpO1xuICAgICAgICAgICAgaWYgKHJlZmluZWRFdmVudCkge1xuICAgICAgICAgICAgICAgIHJlZmluZWRFdmVudHMucHVzaChyZWZpbmVkRXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVmaW5lZEV2ZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZWZpbmVkRXZlbnRzLnB1c2gocmF3RXZlbnQpO1xuICAgICAgICAgICAgfSAvLyBpZiBhIGRpZmZlcmVudCBmYWxzeSB2YWx1ZSwgZG8gbm90aGluZ1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZWZpbmVkRXZlbnRzO1xufVxuZnVuY3Rpb24gYWRkRXZlbnQoZXZlbnRTdG9yZSwgc3Vic2V0LCBleHBhbmRSYW5nZSwgY29udGV4dCkge1xuICAgIGlmIChleHBhbmRSYW5nZSkge1xuICAgICAgICBzdWJzZXQgPSBleHBhbmRSZWN1cnJpbmcoc3Vic2V0LCBleHBhbmRSYW5nZSwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBtZXJnZUV2ZW50U3RvcmVzKGV2ZW50U3RvcmUsIHN1YnNldCk7XG59XG5mdW5jdGlvbiByZXpvbmVFdmVudFN0b3JlRGF0ZXMoZXZlbnRTdG9yZSwgb2xkRGF0ZUVudiwgbmV3RGF0ZUVudikge1xuICAgIGxldCB7IGRlZnMgfSA9IGV2ZW50U3RvcmU7XG4gICAgbGV0IGluc3RhbmNlcyA9IG1hcEhhc2goZXZlbnRTdG9yZS5pbnN0YW5jZXMsIChpbnN0YW5jZSkgPT4ge1xuICAgICAgICBsZXQgZGVmID0gZGVmc1tpbnN0YW5jZS5kZWZJZF07XG4gICAgICAgIGlmIChkZWYuYWxsRGF5KSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7IC8vIGlzbid0IGRlcGVuZGVudCBvbiB0aW1lem9uZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGluc3RhbmNlKSwgeyByYW5nZToge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBuZXdEYXRlRW52LmNyZWF0ZU1hcmtlcihvbGREYXRlRW52LnRvRGF0ZShpbnN0YW5jZS5yYW5nZS5zdGFydCwgaW5zdGFuY2UuZm9yY2VkU3RhcnRUem8pKSxcbiAgICAgICAgICAgICAgICBlbmQ6IG5ld0RhdGVFbnYuY3JlYXRlTWFya2VyKG9sZERhdGVFbnYudG9EYXRlKGluc3RhbmNlLnJhbmdlLmVuZCwgaW5zdGFuY2UuZm9yY2VkRW5kVHpvKSksXG4gICAgICAgICAgICB9LCBmb3JjZWRTdGFydFR6bzogbmV3RGF0ZUVudi5jYW5Db21wdXRlT2Zmc2V0ID8gbnVsbCA6IGluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLCBmb3JjZWRFbmRUem86IG5ld0RhdGVFbnYuY2FuQ29tcHV0ZU9mZnNldCA/IG51bGwgOiBpbnN0YW5jZS5mb3JjZWRFbmRUem8gfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgZGVmcywgaW5zdGFuY2VzIH07XG59XG5mdW5jdGlvbiBleGNsdWRlRXZlbnRzQnlTb3VyY2VJZChldmVudFN0b3JlLCBzb3VyY2VJZCkge1xuICAgIHJldHVybiBmaWx0ZXJFdmVudFN0b3JlRGVmcyhldmVudFN0b3JlLCAoZXZlbnREZWYpID0+IGV2ZW50RGVmLnNvdXJjZUlkICE9PSBzb3VyY2VJZCk7XG59XG4vLyBRVUVTVElPTjogd2h5IG5vdCBqdXN0IHJldHVybiBpbnN0YW5jZXM/IGRvIGEgZ2VuZXJhbCBvYmplY3QtcHJvcGVydHktZXhjbHVzaW9uIHV0aWxcbmZ1bmN0aW9uIGV4Y2x1ZGVJbnN0YW5jZXMoZXZlbnRTdG9yZSwgcmVtb3ZhbHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWZzOiBldmVudFN0b3JlLmRlZnMsXG4gICAgICAgIGluc3RhbmNlczogZmlsdGVySGFzaChldmVudFN0b3JlLmluc3RhbmNlcywgKGluc3RhbmNlKSA9PiAhcmVtb3ZhbHNbaW5zdGFuY2UuaW5zdGFuY2VJZF0pLFxuICAgIH07XG59XG5mdW5jdGlvbiBidWlsZFB1YmxpY0lkTWFwcyhldmVudFN0b3JlKSB7XG4gICAgY29uc3QgeyBkZWZzLCBpbnN0YW5jZXMgfSA9IGV2ZW50U3RvcmU7XG4gICAgY29uc3QgZGVmSWRNYXAgPSB7fTtcbiAgICBjb25zdCBpbnN0YW5jZUlkTWFwID0ge307XG4gICAgZm9yIChsZXQgZGVmSWQgaW4gZGVmcykge1xuICAgICAgICBjb25zdCBkZWYgPSBkZWZzW2RlZklkXTtcbiAgICAgICAgY29uc3QgeyBwdWJsaWNJZCB9ID0gZGVmO1xuICAgICAgICBpZiAocHVibGljSWQpIHtcbiAgICAgICAgICAgIGRlZklkTWFwW3B1YmxpY0lkXSA9IGRlZklkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGluc3RhbmNlSWQgaW4gaW5zdGFuY2VzKSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gaW5zdGFuY2VzW2luc3RhbmNlSWRdO1xuICAgICAgICBjb25zdCBkZWYgPSBkZWZzW2luc3RhbmNlLmRlZklkXTtcbiAgICAgICAgY29uc3QgeyBwdWJsaWNJZCB9ID0gZGVmO1xuICAgICAgICBpZiAocHVibGljSWQpIHtcbiAgICAgICAgICAgIGluc3RhbmNlSWRNYXBbcHVibGljSWRdID0gaW5zdGFuY2VJZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBkZWZJZE1hcCwgaW5zdGFuY2VJZE1hcCB9O1xufVxuXG5jbGFzcyBFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IHt9O1xuICAgICAgICB0aGlzLnRoaXNDb250ZXh0ID0gbnVsbDtcbiAgICB9XG4gICAgc2V0VGhpc0NvbnRleHQodGhpc0NvbnRleHQpIHtcbiAgICAgICAgdGhpcy50aGlzQ29udGV4dCA9IHRoaXNDb250ZXh0O1xuICAgIH1cbiAgICBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgb24odHlwZSwgaGFuZGxlcikge1xuICAgICAgICBhZGRUb0hhc2godGhpcy5oYW5kbGVycywgdHlwZSwgaGFuZGxlcik7XG4gICAgfVxuICAgIG9mZih0eXBlLCBoYW5kbGVyKSB7XG4gICAgICAgIHJlbW92ZUZyb21IYXNoKHRoaXMuaGFuZGxlcnMsIHR5cGUsIGhhbmRsZXIpO1xuICAgIH1cbiAgICB0cmlnZ2VyKHR5cGUsIC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IGF0dGFjaGVkSGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzW3R5cGVdIHx8IFtdO1xuICAgICAgICBsZXQgb3B0aW9uSGFuZGxlciA9IHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnNbdHlwZV07XG4gICAgICAgIGxldCBoYW5kbGVycyA9IFtdLmNvbmNhdChvcHRpb25IYW5kbGVyIHx8IFtdLCBhdHRhY2hlZEhhbmRsZXJzKTtcbiAgICAgICAgZm9yIChsZXQgaGFuZGxlciBvZiBoYW5kbGVycykge1xuICAgICAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLnRoaXNDb250ZXh0LCBhcmdzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYXNIYW5kbGVycyh0eXBlKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKCh0aGlzLmhhbmRsZXJzW3R5cGVdICYmIHRoaXMuaGFuZGxlcnNbdHlwZV0ubGVuZ3RoKSB8fFxuICAgICAgICAgICAgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnNbdHlwZV0pKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRUb0hhc2goaGFzaCwgdHlwZSwgaGFuZGxlcikge1xuICAgIChoYXNoW3R5cGVdIHx8IChoYXNoW3R5cGVdID0gW10pKVxuICAgICAgICAucHVzaChoYW5kbGVyKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUZyb21IYXNoKGhhc2gsIHR5cGUsIGhhbmRsZXIpIHtcbiAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICBpZiAoaGFzaFt0eXBlXSkge1xuICAgICAgICAgICAgaGFzaFt0eXBlXSA9IGhhc2hbdHlwZV0uZmlsdGVyKChmdW5jKSA9PiBmdW5jICE9PSBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZGVsZXRlIGhhc2hbdHlwZV07IC8vIHJlbW92ZSBhbGwgaGFuZGxlciBmdW5jcyBmb3IgdGhpcyB0eXBlXG4gICAgfVxufVxuXG5jb25zdCBERUZfREVGQVVMVFMgPSB7XG4gICAgc3RhcnRUaW1lOiAnMDk6MDAnLFxuICAgIGVuZFRpbWU6ICcxNzowMCcsXG4gICAgZGF5c09mV2VlazogWzEsIDIsIDMsIDQsIDVdLFxuICAgIGRpc3BsYXk6ICdpbnZlcnNlLWJhY2tncm91bmQnLFxuICAgIGNsYXNzTmFtZXM6ICdmYy1ub24tYnVzaW5lc3MnLFxuICAgIGdyb3VwSWQ6ICdfYnVzaW5lc3NIb3VycycsIC8vIHNvIG11bHRpcGxlIGRlZnMgZ2V0IGdyb3VwZWRcbn07XG4vKlxuVE9ETzogcGFzcyBhcm91bmQgYXMgRXZlbnREZWZIYXNoISEhXG4qL1xuZnVuY3Rpb24gcGFyc2VCdXNpbmVzc0hvdXJzKGlucHV0LCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHBhcnNlRXZlbnRzKHJlZmluZUlucHV0cyhpbnB1dCksIG51bGwsIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gcmVmaW5lSW5wdXRzKGlucHV0KSB7XG4gICAgbGV0IHJhd0RlZnM7XG4gICAgaWYgKGlucHV0ID09PSB0cnVlKSB7XG4gICAgICAgIHJhd0RlZnMgPSBbe31dOyAvLyB3aWxsIGdldCBERUZfREVGQVVMVFMgdmVyYmF0aW1cbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgLy8gaWYgc3BlY2lmeWluZyBhbiBhcnJheSwgZXZlcnkgc3ViLWRlZmluaXRpb24gTkVFRFMgYSBkYXktb2Ytd2Vla1xuICAgICAgICByYXdEZWZzID0gaW5wdXQuZmlsdGVyKChyYXdEZWYpID0+IHJhd0RlZi5kYXlzT2ZXZWVrKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiBpbnB1dCkgeyAvLyBub24tbnVsbCBvYmplY3RcbiAgICAgICAgcmF3RGVmcyA9IFtpbnB1dF07XG4gICAgfVxuICAgIGVsc2UgeyAvLyBpcyBwcm9iYWJseSBmYWxzZVxuICAgICAgICByYXdEZWZzID0gW107XG4gICAgfVxuICAgIHJhd0RlZnMgPSByYXdEZWZzLm1hcCgocmF3RGVmKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBERUZfREVGQVVMVFMpLCByYXdEZWYpKSk7XG4gICAgcmV0dXJuIHJhd0RlZnM7XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXJEYXRlU2VsZWN0KHNlbGVjdGlvbiwgcGV2LCBjb250ZXh0KSB7XG4gICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ3NlbGVjdCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYnVpbGREYXRlU3BhbkFwaVdpdGhDb250ZXh0KHNlbGVjdGlvbiwgY29udGV4dCkpLCB7IGpzRXZlbnQ6IHBldiA/IHBldi5vcmlnRXZlbnQgOiBudWxsLCB2aWV3OiBjb250ZXh0LnZpZXdBcGkgfHwgY29udGV4dC5jYWxlbmRhckFwaS52aWV3IH0pKTtcbn1cbmZ1bmN0aW9uIHRyaWdnZXJEYXRlVW5zZWxlY3QocGV2LCBjb250ZXh0KSB7XG4gICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ3Vuc2VsZWN0Jywge1xuICAgICAgICBqc0V2ZW50OiBwZXYgPyBwZXYub3JpZ0V2ZW50IDogbnVsbCxcbiAgICAgICAgdmlldzogY29udGV4dC52aWV3QXBpIHx8IGNvbnRleHQuY2FsZW5kYXJBcGkudmlldyxcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRGF0ZVNwYW5BcGlXaXRoQ29udGV4dChkYXRlU3BhbiwgY29udGV4dCkge1xuICAgIGxldCBwcm9wcyA9IHt9O1xuICAgIGZvciAobGV0IHRyYW5zZm9ybSBvZiBjb250ZXh0LnBsdWdpbkhvb2tzLmRhdGVTcGFuVHJhbnNmb3Jtcykge1xuICAgICAgICBPYmplY3QuYXNzaWduKHByb3BzLCB0cmFuc2Zvcm0oZGF0ZVNwYW4sIGNvbnRleHQpKTtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbihwcm9wcywgYnVpbGREYXRlU3BhbkFwaShkYXRlU3BhbiwgY29udGV4dC5kYXRlRW52KSk7XG4gICAgcmV0dXJuIHByb3BzO1xufVxuLy8gR2l2ZW4gYW4gZXZlbnQncyBhbGxEYXkgc3RhdHVzIGFuZCBzdGFydCBkYXRlLCByZXR1cm4gd2hhdCBpdHMgZmFsbGJhY2sgZW5kIGRhdGUgc2hvdWxkIGJlLlxuLy8gVE9ETzogcmVuYW1lIHRvIGNvbXB1dGVEZWZhdWx0RXZlbnRFbmRcbmZ1bmN0aW9uIGdldERlZmF1bHRFdmVudEVuZChhbGxEYXksIG1hcmtlciwgY29udGV4dCkge1xuICAgIGxldCB7IGRhdGVFbnYsIG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgbGV0IGVuZCA9IG1hcmtlcjtcbiAgICBpZiAoYWxsRGF5KSB7XG4gICAgICAgIGVuZCA9IHN0YXJ0T2ZEYXkoZW5kKTtcbiAgICAgICAgZW5kID0gZGF0ZUVudi5hZGQoZW5kLCBvcHRpb25zLmRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVuZCA9IGRhdGVFbnYuYWRkKGVuZCwgb3B0aW9ucy5kZWZhdWx0VGltZWRFdmVudER1cmF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIGVuZDtcbn1cblxuLy8gYXBwbGllcyB0aGUgbXV0YXRpb24gdG8gQUxMIGRlZnMvaW5zdGFuY2VzIHdpdGhpbiB0aGUgZXZlbnQgc3RvcmVcbmZ1bmN0aW9uIGFwcGx5TXV0YXRpb25Ub0V2ZW50U3RvcmUoZXZlbnRTdG9yZSwgZXZlbnRDb25maWdCYXNlLCBtdXRhdGlvbiwgY29udGV4dCkge1xuICAgIGxldCBldmVudENvbmZpZ3MgPSBjb21waWxlRXZlbnRVaXMoZXZlbnRTdG9yZS5kZWZzLCBldmVudENvbmZpZ0Jhc2UpO1xuICAgIGxldCBkZXN0ID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7XG4gICAgZm9yIChsZXQgZGVmSWQgaW4gZXZlbnRTdG9yZS5kZWZzKSB7XG4gICAgICAgIGxldCBkZWYgPSBldmVudFN0b3JlLmRlZnNbZGVmSWRdO1xuICAgICAgICBkZXN0LmRlZnNbZGVmSWRdID0gYXBwbHlNdXRhdGlvblRvRXZlbnREZWYoZGVmLCBldmVudENvbmZpZ3NbZGVmSWRdLCBtdXRhdGlvbiwgY29udGV4dCk7XG4gICAgfVxuICAgIGZvciAobGV0IGluc3RhbmNlSWQgaW4gZXZlbnRTdG9yZS5pbnN0YW5jZXMpIHtcbiAgICAgICAgbGV0IGluc3RhbmNlID0gZXZlbnRTdG9yZS5pbnN0YW5jZXNbaW5zdGFuY2VJZF07XG4gICAgICAgIGxldCBkZWYgPSBkZXN0LmRlZnNbaW5zdGFuY2UuZGVmSWRdOyAvLyBpbXBvcnRhbnQgdG8gZ3JhYiB0aGUgbmV3bHkgbW9kaWZpZWQgZGVmXG4gICAgICAgIGRlc3QuaW5zdGFuY2VzW2luc3RhbmNlSWRdID0gYXBwbHlNdXRhdGlvblRvRXZlbnRJbnN0YW5jZShpbnN0YW5jZSwgZGVmLCBldmVudENvbmZpZ3NbaW5zdGFuY2UuZGVmSWRdLCBtdXRhdGlvbiwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xufVxuZnVuY3Rpb24gYXBwbHlNdXRhdGlvblRvRXZlbnREZWYoZXZlbnREZWYsIGV2ZW50Q29uZmlnLCBtdXRhdGlvbiwgY29udGV4dCkge1xuICAgIGxldCBzdGFuZGFyZFByb3BzID0gbXV0YXRpb24uc3RhbmRhcmRQcm9wcyB8fCB7fTtcbiAgICAvLyBpZiBoYXNFbmQgaGFzIG5vdCBiZWVuIHNwZWNpZmllZCwgZ3Vlc3MgYSBnb29kIHZhbHVlIGJhc2VkIG9uIGRlbHRhcy5cbiAgICAvLyBpZiBkdXJhdGlvbiB3aWxsIGNoYW5nZSwgdGhlcmUncyBubyB3YXkgdGhlIGRlZmF1bHQgZHVyYXRpb24gd2lsbCBwZXJzaXN0LFxuICAgIC8vIGFuZCB0aHVzLCB3ZSBuZWVkIHRvIG1hcmsgdGhlIGV2ZW50IGFzIGhhdmluZyBhIHJlYWwgZW5kXG4gICAgaWYgKHN0YW5kYXJkUHJvcHMuaGFzRW5kID09IG51bGwgJiZcbiAgICAgICAgZXZlbnRDb25maWcuZHVyYXRpb25FZGl0YWJsZSAmJlxuICAgICAgICAobXV0YXRpb24uc3RhcnREZWx0YSB8fCBtdXRhdGlvbi5lbmREZWx0YSkpIHtcbiAgICAgICAgc3RhbmRhcmRQcm9wcy5oYXNFbmQgPSB0cnVlOyAvLyBUT0RPOiBpcyB0aGlzIG11dGF0aW9uIG9rYXk/XG4gICAgfVxuICAgIGxldCBjb3B5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV2ZW50RGVmKSwgc3RhbmRhcmRQcm9wcyksIHsgdWk6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXZlbnREZWYudWkpLCBzdGFuZGFyZFByb3BzLnVpKSB9KTtcbiAgICBpZiAobXV0YXRpb24uZXh0ZW5kZWRQcm9wcykge1xuICAgICAgICBjb3B5LmV4dGVuZGVkUHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvcHkuZXh0ZW5kZWRQcm9wcyksIG11dGF0aW9uLmV4dGVuZGVkUHJvcHMpO1xuICAgIH1cbiAgICBmb3IgKGxldCBhcHBsaWVyIG9mIGNvbnRleHQucGx1Z2luSG9va3MuZXZlbnREZWZNdXRhdGlvbkFwcGxpZXJzKSB7XG4gICAgICAgIGFwcGxpZXIoY29weSwgbXV0YXRpb24sIGNvbnRleHQpO1xuICAgIH1cbiAgICBpZiAoIWNvcHkuaGFzRW5kICYmIGNvbnRleHQub3B0aW9ucy5mb3JjZUV2ZW50RHVyYXRpb24pIHtcbiAgICAgICAgY29weS5oYXNFbmQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gY29weTtcbn1cbmZ1bmN0aW9uIGFwcGx5TXV0YXRpb25Ub0V2ZW50SW5zdGFuY2UoZXZlbnRJbnN0YW5jZSwgZXZlbnREZWYsIC8vIG11c3QgZmlyc3QgYmUgbW9kaWZpZWQgYnkgYXBwbHlNdXRhdGlvblRvRXZlbnREZWZcbmV2ZW50Q29uZmlnLCBtdXRhdGlvbiwgY29udGV4dCkge1xuICAgIGxldCB7IGRhdGVFbnYgfSA9IGNvbnRleHQ7XG4gICAgbGV0IGZvcmNlQWxsRGF5ID0gbXV0YXRpb24uc3RhbmRhcmRQcm9wcyAmJiBtdXRhdGlvbi5zdGFuZGFyZFByb3BzLmFsbERheSA9PT0gdHJ1ZTtcbiAgICBsZXQgY2xlYXJFbmQgPSBtdXRhdGlvbi5zdGFuZGFyZFByb3BzICYmIG11dGF0aW9uLnN0YW5kYXJkUHJvcHMuaGFzRW5kID09PSBmYWxzZTtcbiAgICBsZXQgY29weSA9IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50SW5zdGFuY2UpO1xuICAgIGlmIChmb3JjZUFsbERheSkge1xuICAgICAgICBjb3B5LnJhbmdlID0gY29tcHV0ZUFsaWduZWREYXlSYW5nZShjb3B5LnJhbmdlKTtcbiAgICB9XG4gICAgaWYgKG11dGF0aW9uLmRhdGVzRGVsdGEgJiYgZXZlbnRDb25maWcuc3RhcnRFZGl0YWJsZSkge1xuICAgICAgICBjb3B5LnJhbmdlID0ge1xuICAgICAgICAgICAgc3RhcnQ6IGRhdGVFbnYuYWRkKGNvcHkucmFuZ2Uuc3RhcnQsIG11dGF0aW9uLmRhdGVzRGVsdGEpLFxuICAgICAgICAgICAgZW5kOiBkYXRlRW52LmFkZChjb3B5LnJhbmdlLmVuZCwgbXV0YXRpb24uZGF0ZXNEZWx0YSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChtdXRhdGlvbi5zdGFydERlbHRhICYmIGV2ZW50Q29uZmlnLmR1cmF0aW9uRWRpdGFibGUpIHtcbiAgICAgICAgY29weS5yYW5nZSA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiBkYXRlRW52LmFkZChjb3B5LnJhbmdlLnN0YXJ0LCBtdXRhdGlvbi5zdGFydERlbHRhKSxcbiAgICAgICAgICAgIGVuZDogY29weS5yYW5nZS5lbmQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChtdXRhdGlvbi5lbmREZWx0YSAmJiBldmVudENvbmZpZy5kdXJhdGlvbkVkaXRhYmxlKSB7XG4gICAgICAgIGNvcHkucmFuZ2UgPSB7XG4gICAgICAgICAgICBzdGFydDogY29weS5yYW5nZS5zdGFydCxcbiAgICAgICAgICAgIGVuZDogZGF0ZUVudi5hZGQoY29weS5yYW5nZS5lbmQsIG11dGF0aW9uLmVuZERlbHRhKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGNsZWFyRW5kKSB7XG4gICAgICAgIGNvcHkucmFuZ2UgPSB7XG4gICAgICAgICAgICBzdGFydDogY29weS5yYW5nZS5zdGFydCxcbiAgICAgICAgICAgIGVuZDogZ2V0RGVmYXVsdEV2ZW50RW5kKGV2ZW50RGVmLmFsbERheSwgY29weS5yYW5nZS5zdGFydCwgY29udGV4dCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIGluIGNhc2UgZXZlbnQgd2FzIGFsbC1kYXkgYnV0IHRoZSBzdXBwbGllZCBkZWx0YXMgd2VyZSBub3RcbiAgICAvLyBiZXR0ZXIgdXRpbCBmb3IgdGhpcz9cbiAgICBpZiAoZXZlbnREZWYuYWxsRGF5KSB7XG4gICAgICAgIGNvcHkucmFuZ2UgPSB7XG4gICAgICAgICAgICBzdGFydDogc3RhcnRPZkRheShjb3B5LnJhbmdlLnN0YXJ0KSxcbiAgICAgICAgICAgIGVuZDogc3RhcnRPZkRheShjb3B5LnJhbmdlLmVuZCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIGhhbmRsZSBpbnZhbGlkIGR1cmF0aW9uc1xuICAgIGlmIChjb3B5LnJhbmdlLmVuZCA8IGNvcHkucmFuZ2Uuc3RhcnQpIHtcbiAgICAgICAgY29weS5yYW5nZS5lbmQgPSBnZXREZWZhdWx0RXZlbnRFbmQoZXZlbnREZWYuYWxsRGF5LCBjb3B5LnJhbmdlLnN0YXJ0LCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvcHk7XG59XG5cbmNsYXNzIEV2ZW50U291cmNlSW1wbCB7XG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgaW50ZXJuYWxFdmVudFNvdXJjZSkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmludGVybmFsRXZlbnRTb3VyY2UgPSBpbnRlcm5hbEV2ZW50U291cmNlO1xuICAgIH1cbiAgICByZW1vdmUoKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnUkVNT1ZFX0VWRU5UX1NPVVJDRScsXG4gICAgICAgICAgICBzb3VyY2VJZDogdGhpcy5pbnRlcm5hbEV2ZW50U291cmNlLnNvdXJjZUlkLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVmZXRjaCgpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdGRVRDSF9FVkVOVF9TT1VSQ0VTJyxcbiAgICAgICAgICAgIHNvdXJjZUlkczogW3RoaXMuaW50ZXJuYWxFdmVudFNvdXJjZS5zb3VyY2VJZF0sXG4gICAgICAgICAgICBpc1JlZmV0Y2g6IHRydWUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsRXZlbnRTb3VyY2UucHVibGljSWQ7XG4gICAgfVxuICAgIGdldCB1cmwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsRXZlbnRTb3VyY2UubWV0YS51cmw7XG4gICAgfVxuICAgIGdldCBmb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsRXZlbnRTb3VyY2UubWV0YS5mb3JtYXQ7IC8vIFRPRE86IGJhZC4gbm90IGd1YXJhbnRlZWRcbiAgICB9XG59XG5cbmNsYXNzIEV2ZW50SW1wbCB7XG4gICAgLy8gaW5zdGFuY2Ugd2lsbCBiZSBudWxsIGlmIGV4cHJlc3NpbmcgYSByZWN1cnJpbmcgZXZlbnQgdGhhdCBoYXMgbm8gY3VycmVudCBpbnN0YW5jZXMsXG4gICAgLy8gT1IgaWYgdHJ5aW5nIHRvIHZhbGlkYXRlIGFuIGluY29taW5nIGV4dGVybmFsIGV2ZW50IHRoYXQgaGFzIG5vIGRhdGVzIGFzc2lnbmVkXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgZGVmLCBpbnN0YW5jZSkge1xuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5fZGVmID0gZGVmO1xuICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IGluc3RhbmNlIHx8IG51bGw7XG4gICAgfVxuICAgIC8qXG4gICAgVE9ETzogbWFrZSBldmVudCBzdHJ1Y3QgbW9yZSByZXNwb25zaWJsZSBmb3IgdGhpc1xuICAgICovXG4gICAgc2V0UHJvcChuYW1lLCB2YWwpIHtcbiAgICAgICAgaWYgKG5hbWUgaW4gRVZFTlRfREFURV9SRUZJTkVSUykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3Qgc2V0IGRhdGUtcmVsYXRlZCBwcm9wIFxcJ25hbWVcXCcuIFVzZSBvbmUgb2YgdGhlIGRhdGUtcmVsYXRlZCBtZXRob2RzIGluc3RlYWQuJyk7XG4gICAgICAgICAgICAvLyBUT0RPOiBtYWtlIHByb3BlciBhbGlhc2luZyBzeXN0ZW0/XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gJ2lkJykge1xuICAgICAgICAgICAgdmFsID0gRVZFTlRfTk9OX0RBVEVfUkVGSU5FUlNbbmFtZV0odmFsKTtcbiAgICAgICAgICAgIHRoaXMubXV0YXRlKHtcbiAgICAgICAgICAgICAgICBzdGFuZGFyZFByb3BzOiB7IHB1YmxpY0lkOiB2YWwgfSwgLy8gaGFyZGNvZGVkIGludGVybmFsIG5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWUgaW4gRVZFTlRfTk9OX0RBVEVfUkVGSU5FUlMpIHtcbiAgICAgICAgICAgIHZhbCA9IEVWRU5UX05PTl9EQVRFX1JFRklORVJTW25hbWVdKHZhbCk7XG4gICAgICAgICAgICB0aGlzLm11dGF0ZSh7XG4gICAgICAgICAgICAgICAgc3RhbmRhcmRQcm9wczogeyBbbmFtZV06IHZhbCB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmFtZSBpbiBFVkVOVF9VSV9SRUZJTkVSUykge1xuICAgICAgICAgICAgbGV0IHVpID0gRVZFTlRfVUlfUkVGSU5FUlNbbmFtZV0odmFsKTtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnY29sb3InKSB7XG4gICAgICAgICAgICAgICAgdWkgPSB7IGJhY2tncm91bmRDb2xvcjogdmFsLCBib3JkZXJDb2xvcjogdmFsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnZWRpdGFibGUnKSB7XG4gICAgICAgICAgICAgICAgdWkgPSB7IHN0YXJ0RWRpdGFibGU6IHZhbCwgZHVyYXRpb25FZGl0YWJsZTogdmFsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1aSA9IHsgW25hbWVdOiB2YWwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubXV0YXRlKHtcbiAgICAgICAgICAgICAgICBzdGFuZGFyZFByb3BzOiB7IHVpIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgQ291bGQgbm90IHNldCBwcm9wICcke25hbWV9Jy4gVXNlIHNldEV4dGVuZGVkUHJvcCBpbnN0ZWFkLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldEV4dGVuZGVkUHJvcChuYW1lLCB2YWwpIHtcbiAgICAgICAgdGhpcy5tdXRhdGUoe1xuICAgICAgICAgICAgZXh0ZW5kZWRQcm9wczogeyBbbmFtZV06IHZhbCB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2V0U3RhcnQoc3RhcnRJbnB1dCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCB7IGRhdGVFbnYgfSA9IHRoaXMuX2NvbnRleHQ7XG4gICAgICAgIGxldCBzdGFydCA9IGRhdGVFbnYuY3JlYXRlTWFya2VyKHN0YXJ0SW5wdXQpO1xuICAgICAgICBpZiAoc3RhcnQgJiYgdGhpcy5faW5zdGFuY2UpIHsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXG4gICAgICAgICAgICBsZXQgaW5zdGFuY2VSYW5nZSA9IHRoaXMuX2luc3RhbmNlLnJhbmdlO1xuICAgICAgICAgICAgbGV0IHN0YXJ0RGVsdGEgPSBkaWZmRGF0ZXMoaW5zdGFuY2VSYW5nZS5zdGFydCwgc3RhcnQsIGRhdGVFbnYsIG9wdGlvbnMuZ3JhbnVsYXJpdHkpOyAvLyB3aGF0IGlmIHBhcnNlZCBiYWQhP1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMubWFpbnRhaW5EdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgZGF0ZXNEZWx0YTogc3RhcnREZWx0YSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhcnREZWx0YSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRFbmQoZW5kSW5wdXQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgeyBkYXRlRW52IH0gPSB0aGlzLl9jb250ZXh0O1xuICAgICAgICBsZXQgZW5kO1xuICAgICAgICBpZiAoZW5kSW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgZW5kID0gZGF0ZUVudi5jcmVhdGVNYXJrZXIoZW5kSW5wdXQpO1xuICAgICAgICAgICAgaWYgKCFlbmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIFRPRE86IHdhcm5pbmcgaWYgcGFyc2VkIGJhZFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgICAgICAgaWYgKGVuZCkge1xuICAgICAgICAgICAgICAgIGxldCBlbmREZWx0YSA9IGRpZmZEYXRlcyh0aGlzLl9pbnN0YW5jZS5yYW5nZS5lbmQsIGVuZCwgZGF0ZUVudiwgb3B0aW9ucy5ncmFudWxhcml0eSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tdXRhdGUoeyBlbmREZWx0YSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhbmRhcmRQcm9wczogeyBoYXNFbmQ6IGZhbHNlIH0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0RGF0ZXMoc3RhcnRJbnB1dCwgZW5kSW5wdXQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgeyBkYXRlRW52IH0gPSB0aGlzLl9jb250ZXh0O1xuICAgICAgICBsZXQgc3RhbmRhcmRQcm9wcyA9IHsgYWxsRGF5OiBvcHRpb25zLmFsbERheSB9O1xuICAgICAgICBsZXQgc3RhcnQgPSBkYXRlRW52LmNyZWF0ZU1hcmtlcihzdGFydElucHV0KTtcbiAgICAgICAgbGV0IGVuZDtcbiAgICAgICAgaWYgKCFzdGFydCkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kSW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgZW5kID0gZGF0ZUVudi5jcmVhdGVNYXJrZXIoZW5kSW5wdXQpO1xuICAgICAgICAgICAgaWYgKCFlbmQpIHsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgICAgICAgbGV0IGluc3RhbmNlUmFuZ2UgPSB0aGlzLl9pbnN0YW5jZS5yYW5nZTtcbiAgICAgICAgICAgIC8vIHdoZW4gY29tcHV0aW5nIHRoZSBkaWZmIGZvciBhbiBldmVudCBiZWluZyBjb252ZXJ0ZWQgdG8gYWxsLWRheSxcbiAgICAgICAgICAgIC8vIGNvbXB1dGUgZGlmZiBvZmYgb2YgdGhlIGFsbC1kYXkgdmFsdWVzIHRoZSB3YXkgZXZlbnQtbXV0YXRpb24gZG9lcy5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFsbERheSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlUmFuZ2UgPSBjb21wdXRlQWxpZ25lZERheVJhbmdlKGluc3RhbmNlUmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHN0YXJ0RGVsdGEgPSBkaWZmRGF0ZXMoaW5zdGFuY2VSYW5nZS5zdGFydCwgc3RhcnQsIGRhdGVFbnYsIG9wdGlvbnMuZ3JhbnVsYXJpdHkpO1xuICAgICAgICAgICAgaWYgKGVuZCkge1xuICAgICAgICAgICAgICAgIGxldCBlbmREZWx0YSA9IGRpZmZEYXRlcyhpbnN0YW5jZVJhbmdlLmVuZCwgZW5kLCBkYXRlRW52LCBvcHRpb25zLmdyYW51bGFyaXR5KTtcbiAgICAgICAgICAgICAgICBpZiAoZHVyYXRpb25zRXF1YWwoc3RhcnREZWx0YSwgZW5kRGVsdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgZGF0ZXNEZWx0YTogc3RhcnREZWx0YSwgc3RhbmRhcmRQcm9wcyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhcnREZWx0YSwgZW5kRGVsdGEsIHN0YW5kYXJkUHJvcHMgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7IC8vIG1lYW5zIFwiY2xlYXIgdGhlIGVuZFwiXG4gICAgICAgICAgICAgICAgc3RhbmRhcmRQcm9wcy5oYXNFbmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLm11dGF0ZSh7IGRhdGVzRGVsdGE6IHN0YXJ0RGVsdGEsIHN0YW5kYXJkUHJvcHMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW92ZVN0YXJ0KGRlbHRhSW5wdXQpIHtcbiAgICAgICAgbGV0IGRlbHRhID0gY3JlYXRlRHVyYXRpb24oZGVsdGFJbnB1dCk7XG4gICAgICAgIGlmIChkZWx0YSkgeyAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcbiAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhcnREZWx0YTogZGVsdGEgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW92ZUVuZChkZWx0YUlucHV0KSB7XG4gICAgICAgIGxldCBkZWx0YSA9IGNyZWF0ZUR1cmF0aW9uKGRlbHRhSW5wdXQpO1xuICAgICAgICBpZiAoZGVsdGEpIHsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXG4gICAgICAgICAgICB0aGlzLm11dGF0ZSh7IGVuZERlbHRhOiBkZWx0YSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtb3ZlRGF0ZXMoZGVsdGFJbnB1dCkge1xuICAgICAgICBsZXQgZGVsdGEgPSBjcmVhdGVEdXJhdGlvbihkZWx0YUlucHV0KTtcbiAgICAgICAgaWYgKGRlbHRhKSB7IC8vIFRPRE86IHdhcm5pbmcgaWYgcGFyc2VkIGJhZFxuICAgICAgICAgICAgdGhpcy5tdXRhdGUoeyBkYXRlc0RlbHRhOiBkZWx0YSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRBbGxEYXkoYWxsRGF5LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgbGV0IHN0YW5kYXJkUHJvcHMgPSB7IGFsbERheSB9O1xuICAgICAgICBsZXQgeyBtYWludGFpbkR1cmF0aW9uIH0gPSBvcHRpb25zO1xuICAgICAgICBpZiAobWFpbnRhaW5EdXJhdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICBtYWludGFpbkR1cmF0aW9uID0gdGhpcy5fY29udGV4dC5vcHRpb25zLmFsbERheU1haW50YWluRHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2RlZi5hbGxEYXkgIT09IGFsbERheSkge1xuICAgICAgICAgICAgc3RhbmRhcmRQcm9wcy5oYXNFbmQgPSBtYWludGFpbkR1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubXV0YXRlKHsgc3RhbmRhcmRQcm9wcyB9KTtcbiAgICB9XG4gICAgZm9ybWF0UmFuZ2UoZm9ybWF0SW5wdXQpIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5fY29udGV4dDtcbiAgICAgICAgbGV0IGluc3RhbmNlID0gdGhpcy5faW5zdGFuY2U7XG4gICAgICAgIGxldCBmb3JtYXR0ZXIgPSBjcmVhdGVGb3JtYXR0ZXIoZm9ybWF0SW5wdXQpO1xuICAgICAgICBpZiAodGhpcy5fZGVmLmhhc0VuZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0UmFuZ2UoaW5zdGFuY2UucmFuZ2Uuc3RhcnQsIGluc3RhbmNlLnJhbmdlLmVuZCwgZm9ybWF0dGVyLCB7XG4gICAgICAgICAgICAgICAgZm9yY2VkU3RhcnRUem86IGluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLFxuICAgICAgICAgICAgICAgIGZvcmNlZEVuZFR6bzogaW5zdGFuY2UuZm9yY2VkRW5kVHpvLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0KGluc3RhbmNlLnJhbmdlLnN0YXJ0LCBmb3JtYXR0ZXIsIHtcbiAgICAgICAgICAgIGZvcmNlZFR6bzogaW5zdGFuY2UuZm9yY2VkU3RhcnRUem8sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtdXRhdGUobXV0YXRpb24pIHtcbiAgICAgICAgbGV0IGluc3RhbmNlID0gdGhpcy5faW5zdGFuY2U7XG4gICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgbGV0IGRlZiA9IHRoaXMuX2RlZjtcbiAgICAgICAgICAgIGxldCBjb250ZXh0ID0gdGhpcy5fY29udGV4dDtcbiAgICAgICAgICAgIGxldCB7IGV2ZW50U3RvcmUgfSA9IGNvbnRleHQuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgICAgIGxldCByZWxldmFudEV2ZW50cyA9IGdldFJlbGV2YW50RXZlbnRzKGV2ZW50U3RvcmUsIGluc3RhbmNlLmluc3RhbmNlSWQpO1xuICAgICAgICAgICAgbGV0IGV2ZW50Q29uZmlnQmFzZSA9IHtcbiAgICAgICAgICAgICAgICAnJzoge1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnJyxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRFZGl0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb25FZGl0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBvdmVybGFwOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd3M6IFtdLFxuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcnLFxuICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogJycsXG4gICAgICAgICAgICAgICAgICAgIHRleHRDb2xvcjogJycsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZXM6IFtdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVsZXZhbnRFdmVudHMgPSBhcHBseU11dGF0aW9uVG9FdmVudFN0b3JlKHJlbGV2YW50RXZlbnRzLCBldmVudENvbmZpZ0Jhc2UsIG11dGF0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGxldCBvbGRFdmVudCA9IG5ldyBFdmVudEltcGwoY29udGV4dCwgZGVmLCBpbnN0YW5jZSk7IC8vIHNuYXBzaG90XG4gICAgICAgICAgICB0aGlzLl9kZWYgPSByZWxldmFudEV2ZW50cy5kZWZzW2RlZi5kZWZJZF07XG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IHJlbGV2YW50RXZlbnRzLmluc3RhbmNlc1tpbnN0YW5jZS5pbnN0YW5jZUlkXTtcbiAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdNRVJHRV9FVkVOVFMnLFxuICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IHJlbGV2YW50RXZlbnRzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRDaGFuZ2UnLCB7XG4gICAgICAgICAgICAgICAgb2xkRXZlbnQsXG4gICAgICAgICAgICAgICAgZXZlbnQ6IHRoaXMsXG4gICAgICAgICAgICAgICAgcmVsYXRlZEV2ZW50czogYnVpbGRFdmVudEFwaXMocmVsZXZhbnRFdmVudHMsIGNvbnRleHQsIGluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICByZXZlcnQoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1JFU0VUX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlLCAvLyB0aGUgT1JJR0lOQUwgc3RvcmVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZSgpIHtcbiAgICAgICAgbGV0IGNvbnRleHQgPSB0aGlzLl9jb250ZXh0O1xuICAgICAgICBsZXQgYXNTdG9yZSA9IGV2ZW50QXBpVG9TdG9yZSh0aGlzKTtcbiAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnUkVNT1ZFX0VWRU5UUycsXG4gICAgICAgICAgICBldmVudFN0b3JlOiBhc1N0b3JlLFxuICAgICAgICB9KTtcbiAgICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50UmVtb3ZlJywge1xuICAgICAgICAgICAgZXZlbnQ6IHRoaXMsXG4gICAgICAgICAgICByZWxhdGVkRXZlbnRzOiBbXSxcbiAgICAgICAgICAgIHJldmVydCgpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ01FUkdFX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IGFzU3RvcmUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IHNvdXJjZSgpIHtcbiAgICAgICAgbGV0IHsgc291cmNlSWQgfSA9IHRoaXMuX2RlZjtcbiAgICAgICAgaWYgKHNvdXJjZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50U291cmNlSW1wbCh0aGlzLl9jb250ZXh0LCB0aGlzLl9jb250ZXh0LmdldEN1cnJlbnREYXRhKCkuZXZlbnRTb3VyY2VzW3NvdXJjZUlkXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldCBzdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RhbmNlID9cbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZGF0ZUVudi50b0RhdGUodGhpcy5faW5zdGFuY2UucmFuZ2Uuc3RhcnQpIDpcbiAgICAgICAgICAgIG51bGw7XG4gICAgfVxuICAgIGdldCBlbmQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5faW5zdGFuY2UgJiYgdGhpcy5fZGVmLmhhc0VuZCkgP1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5kYXRlRW52LnRvRGF0ZSh0aGlzLl9pbnN0YW5jZS5yYW5nZS5lbmQpIDpcbiAgICAgICAgICAgIG51bGw7XG4gICAgfVxuICAgIGdldCBzdGFydFN0cigpIHtcbiAgICAgICAgbGV0IGluc3RhbmNlID0gdGhpcy5faW5zdGFuY2U7XG4gICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuZGF0ZUVudi5mb3JtYXRJc28oaW5zdGFuY2UucmFuZ2Uuc3RhcnQsIHtcbiAgICAgICAgICAgICAgICBvbWl0VGltZTogdGhpcy5fZGVmLmFsbERheSxcbiAgICAgICAgICAgICAgICBmb3JjZWRUem86IGluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBnZXQgZW5kU3RyKCkge1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIHRoaXMuX2RlZi5oYXNFbmQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmRhdGVFbnYuZm9ybWF0SXNvKGluc3RhbmNlLnJhbmdlLmVuZCwge1xuICAgICAgICAgICAgICAgIG9taXRUaW1lOiB0aGlzLl9kZWYuYWxsRGF5LFxuICAgICAgICAgICAgICAgIGZvcmNlZFR6bzogaW5zdGFuY2UuZm9yY2VkRW5kVHpvLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICAvLyBjb21wdXRhYmxlIHByb3BzIHRoYXQgYWxsIGFjY2VzcyB0aGUgZGVmXG4gICAgLy8gVE9ETzogZmluZCBhIFR5cGVTY3JpcHQtY29tcGF0aWJsZSB3YXkgdG8gZG8gdGhpcyBhdCBzY2FsZVxuICAgIGdldCBpZCgpIHsgcmV0dXJuIHRoaXMuX2RlZi5wdWJsaWNJZDsgfVxuICAgIGdldCBncm91cElkKCkgeyByZXR1cm4gdGhpcy5fZGVmLmdyb3VwSWQ7IH1cbiAgICBnZXQgYWxsRGF5KCkgeyByZXR1cm4gdGhpcy5fZGVmLmFsbERheTsgfVxuICAgIGdldCB0aXRsZSgpIHsgcmV0dXJuIHRoaXMuX2RlZi50aXRsZTsgfVxuICAgIGdldCB1cmwoKSB7IHJldHVybiB0aGlzLl9kZWYudXJsOyB9XG4gICAgZ2V0IGRpc3BsYXkoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuZGlzcGxheSB8fCAnYXV0byc7IH0gLy8gYmFkLiBqdXN0IG5vcm1hbGl6ZSB0aGUgdHlwZSBlYXJsaWVyXG4gICAgZ2V0IHN0YXJ0RWRpdGFibGUoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuc3RhcnRFZGl0YWJsZTsgfVxuICAgIGdldCBkdXJhdGlvbkVkaXRhYmxlKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmR1cmF0aW9uRWRpdGFibGU7IH1cbiAgICBnZXQgY29uc3RyYWludCgpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5jb25zdHJhaW50c1swXSB8fCBudWxsOyB9XG4gICAgZ2V0IG92ZXJsYXAoKSB7IHJldHVybiB0aGlzLl9kZWYudWkub3ZlcmxhcDsgfVxuICAgIGdldCBhbGxvdygpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5hbGxvd3NbMF0gfHwgbnVsbDsgfVxuICAgIGdldCBiYWNrZ3JvdW5kQ29sb3IoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuYmFja2dyb3VuZENvbG9yOyB9XG4gICAgZ2V0IGJvcmRlckNvbG9yKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmJvcmRlckNvbG9yOyB9XG4gICAgZ2V0IHRleHRDb2xvcigpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS50ZXh0Q29sb3I7IH1cbiAgICAvLyBOT1RFOiB1c2VyIGNhbid0IG1vZGlmeSB0aGVzZSBiZWNhdXNlIE9iamVjdC5mcmVlemUgd2FzIGNhbGxlZCBpbiBldmVudC1kZWYgcGFyc2luZ1xuICAgIGdldCBjbGFzc05hbWVzKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmNsYXNzTmFtZXM7IH1cbiAgICBnZXQgZXh0ZW5kZWRQcm9wcygpIHsgcmV0dXJuIHRoaXMuX2RlZi5leHRlbmRlZFByb3BzOyB9XG4gICAgdG9QbGFpbk9iamVjdChzZXR0aW5ncyA9IHt9KSB7XG4gICAgICAgIGxldCBkZWYgPSB0aGlzLl9kZWY7XG4gICAgICAgIGxldCB7IHVpIH0gPSBkZWY7XG4gICAgICAgIGxldCB7IHN0YXJ0U3RyLCBlbmRTdHIgfSA9IHRoaXM7XG4gICAgICAgIGxldCByZXMgPSB7XG4gICAgICAgICAgICBhbGxEYXk6IGRlZi5hbGxEYXksXG4gICAgICAgIH07XG4gICAgICAgIGlmIChkZWYudGl0bGUpIHtcbiAgICAgICAgICAgIHJlcy50aXRsZSA9IGRlZi50aXRsZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRTdHIpIHtcbiAgICAgICAgICAgIHJlcy5zdGFydCA9IHN0YXJ0U3RyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmRTdHIpIHtcbiAgICAgICAgICAgIHJlcy5lbmQgPSBlbmRTdHI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi5wdWJsaWNJZCkge1xuICAgICAgICAgICAgcmVzLmlkID0gZGVmLnB1YmxpY0lkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYuZ3JvdXBJZCkge1xuICAgICAgICAgICAgcmVzLmdyb3VwSWQgPSBkZWYuZ3JvdXBJZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmLnVybCkge1xuICAgICAgICAgICAgcmVzLnVybCA9IGRlZi51cmw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVpLmRpc3BsYXkgJiYgdWkuZGlzcGxheSAhPT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICByZXMuZGlzcGxheSA9IHVpLmRpc3BsYXk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogd2hhdCBhYm91dCByZWN1cnJpbmctZXZlbnQgcHJvcGVydGllcz8/P1xuICAgICAgICAvLyBUT0RPOiBpbmNsdWRlIHN0YXJ0RWRpdGFibGUvZHVyYXRpb25FZGl0YWJsZS9jb25zdHJhaW50L292ZXJsYXAvYWxsb3dcbiAgICAgICAgaWYgKHNldHRpbmdzLmNvbGxhcHNlQ29sb3IgJiYgdWkuYmFja2dyb3VuZENvbG9yICYmIHVpLmJhY2tncm91bmRDb2xvciA9PT0gdWkuYm9yZGVyQ29sb3IpIHtcbiAgICAgICAgICAgIHJlcy5jb2xvciA9IHVpLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh1aS5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgICAgICAgICByZXMuYmFja2dyb3VuZENvbG9yID0gdWkuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVpLmJvcmRlckNvbG9yKSB7XG4gICAgICAgICAgICAgICAgcmVzLmJvcmRlckNvbG9yID0gdWkuYm9yZGVyQ29sb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVpLnRleHRDb2xvcikge1xuICAgICAgICAgICAgcmVzLnRleHRDb2xvciA9IHVpLnRleHRDb2xvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodWkuY2xhc3NOYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlcy5jbGFzc05hbWVzID0gdWkuY2xhc3NOYW1lcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoT2JqZWN0LmtleXMoZGVmLmV4dGVuZGVkUHJvcHMpLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmNvbGxhcHNlRXh0ZW5kZWRQcm9wcykge1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVzLCBkZWYuZXh0ZW5kZWRQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXMuZXh0ZW5kZWRQcm9wcyA9IGRlZi5leHRlbmRlZFByb3BzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9QbGFpbk9iamVjdCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGV2ZW50QXBpVG9TdG9yZShldmVudEFwaSkge1xuICAgIGxldCBkZWYgPSBldmVudEFwaS5fZGVmO1xuICAgIGxldCBpbnN0YW5jZSA9IGV2ZW50QXBpLl9pbnN0YW5jZTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWZzOiB7IFtkZWYuZGVmSWRdOiBkZWYgfSxcbiAgICAgICAgaW5zdGFuY2VzOiBpbnN0YW5jZVxuICAgICAgICAgICAgPyB7IFtpbnN0YW5jZS5pbnN0YW5jZUlkXTogaW5zdGFuY2UgfVxuICAgICAgICAgICAgOiB7fSxcbiAgICB9O1xufVxuZnVuY3Rpb24gYnVpbGRFdmVudEFwaXMoZXZlbnRTdG9yZSwgY29udGV4dCwgZXhjbHVkZUluc3RhbmNlKSB7XG4gICAgbGV0IHsgZGVmcywgaW5zdGFuY2VzIH0gPSBldmVudFN0b3JlO1xuICAgIGxldCBldmVudEFwaXMgPSBbXTtcbiAgICBsZXQgZXhjbHVkZUluc3RhbmNlSWQgPSBleGNsdWRlSW5zdGFuY2UgPyBleGNsdWRlSW5zdGFuY2UuaW5zdGFuY2VJZCA6ICcnO1xuICAgIGZvciAobGV0IGlkIGluIGluc3RhbmNlcykge1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSBpbnN0YW5jZXNbaWRdO1xuICAgICAgICBsZXQgZGVmID0gZGVmc1tpbnN0YW5jZS5kZWZJZF07XG4gICAgICAgIGlmIChpbnN0YW5jZS5pbnN0YW5jZUlkICE9PSBleGNsdWRlSW5zdGFuY2VJZCkge1xuICAgICAgICAgICAgZXZlbnRBcGlzLnB1c2gobmV3IEV2ZW50SW1wbChjb250ZXh0LCBkZWYsIGluc3RhbmNlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50QXBpcztcbn1cblxuLypcblNwZWNpZnlpbmcgbmV4dERheVRocmVzaG9sZCBzaWduYWxzIHRoYXQgYWxsLWRheSByYW5nZXMgc2hvdWxkIGJlIHNsaWNlZC5cbiovXG5mdW5jdGlvbiBzbGljZUV2ZW50U3RvcmUoZXZlbnRTdG9yZSwgZXZlbnRVaUJhc2VzLCBmcmFtaW5nUmFuZ2UsIG5leHREYXlUaHJlc2hvbGQpIHtcbiAgICBsZXQgaW52ZXJzZUJnQnlHcm91cElkID0ge307XG4gICAgbGV0IGludmVyc2VCZ0J5RGVmSWQgPSB7fTtcbiAgICBsZXQgZGVmQnlHcm91cElkID0ge307XG4gICAgbGV0IGJnUmFuZ2VzID0gW107XG4gICAgbGV0IGZnUmFuZ2VzID0gW107XG4gICAgbGV0IGV2ZW50VWlzID0gY29tcGlsZUV2ZW50VWlzKGV2ZW50U3RvcmUuZGVmcywgZXZlbnRVaUJhc2VzKTtcbiAgICBmb3IgKGxldCBkZWZJZCBpbiBldmVudFN0b3JlLmRlZnMpIHtcbiAgICAgICAgbGV0IGRlZiA9IGV2ZW50U3RvcmUuZGVmc1tkZWZJZF07XG4gICAgICAgIGxldCB1aSA9IGV2ZW50VWlzW2RlZi5kZWZJZF07XG4gICAgICAgIGlmICh1aS5kaXNwbGF5ID09PSAnaW52ZXJzZS1iYWNrZ3JvdW5kJykge1xuICAgICAgICAgICAgaWYgKGRlZi5ncm91cElkKSB7XG4gICAgICAgICAgICAgICAgaW52ZXJzZUJnQnlHcm91cElkW2RlZi5ncm91cElkXSA9IFtdO1xuICAgICAgICAgICAgICAgIGlmICghZGVmQnlHcm91cElkW2RlZi5ncm91cElkXSkge1xuICAgICAgICAgICAgICAgICAgICBkZWZCeUdyb3VwSWRbZGVmLmdyb3VwSWRdID0gZGVmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGludmVyc2VCZ0J5RGVmSWRbZGVmSWRdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaW5zdGFuY2VJZCBpbiBldmVudFN0b3JlLmluc3RhbmNlcykge1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSBldmVudFN0b3JlLmluc3RhbmNlc1tpbnN0YW5jZUlkXTtcbiAgICAgICAgbGV0IGRlZiA9IGV2ZW50U3RvcmUuZGVmc1tpbnN0YW5jZS5kZWZJZF07XG4gICAgICAgIGxldCB1aSA9IGV2ZW50VWlzW2RlZi5kZWZJZF07XG4gICAgICAgIGxldCBvcmlnUmFuZ2UgPSBpbnN0YW5jZS5yYW5nZTtcbiAgICAgICAgbGV0IG5vcm1hbFJhbmdlID0gKCFkZWYuYWxsRGF5ICYmIG5leHREYXlUaHJlc2hvbGQpID9cbiAgICAgICAgICAgIGNvbXB1dGVWaXNpYmxlRGF5UmFuZ2Uob3JpZ1JhbmdlLCBuZXh0RGF5VGhyZXNob2xkKSA6XG4gICAgICAgICAgICBvcmlnUmFuZ2U7XG4gICAgICAgIGxldCBzbGljZWRSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhub3JtYWxSYW5nZSwgZnJhbWluZ1JhbmdlKTtcbiAgICAgICAgaWYgKHNsaWNlZFJhbmdlKSB7XG4gICAgICAgICAgICBpZiAodWkuZGlzcGxheSA9PT0gJ2ludmVyc2UtYmFja2dyb3VuZCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVmLmdyb3VwSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW52ZXJzZUJnQnlHcm91cElkW2RlZi5ncm91cElkXS5wdXNoKHNsaWNlZFJhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGludmVyc2VCZ0J5RGVmSWRbaW5zdGFuY2UuZGVmSWRdLnB1c2goc2xpY2VkUmFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHVpLmRpc3BsYXkgIT09ICdub25lJykge1xuICAgICAgICAgICAgICAgICh1aS5kaXNwbGF5ID09PSAnYmFja2dyb3VuZCcgPyBiZ1JhbmdlcyA6IGZnUmFuZ2VzKS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgZGVmLFxuICAgICAgICAgICAgICAgICAgICB1aSxcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBzbGljZWRSYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgaXNTdGFydDogbm9ybWFsUmFuZ2Uuc3RhcnQgJiYgbm9ybWFsUmFuZ2Uuc3RhcnQudmFsdWVPZigpID09PSBzbGljZWRSYW5nZS5zdGFydC52YWx1ZU9mKCksXG4gICAgICAgICAgICAgICAgICAgIGlzRW5kOiBub3JtYWxSYW5nZS5lbmQgJiYgbm9ybWFsUmFuZ2UuZW5kLnZhbHVlT2YoKSA9PT0gc2xpY2VkUmFuZ2UuZW5kLnZhbHVlT2YoKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBncm91cElkIGluIGludmVyc2VCZ0J5R3JvdXBJZCkgeyAvLyBCWSBHUk9VUFxuICAgICAgICBsZXQgcmFuZ2VzID0gaW52ZXJzZUJnQnlHcm91cElkW2dyb3VwSWRdO1xuICAgICAgICBsZXQgaW52ZXJ0ZWRSYW5nZXMgPSBpbnZlcnRSYW5nZXMocmFuZ2VzLCBmcmFtaW5nUmFuZ2UpO1xuICAgICAgICBmb3IgKGxldCBpbnZlcnRlZFJhbmdlIG9mIGludmVydGVkUmFuZ2VzKSB7XG4gICAgICAgICAgICBsZXQgZGVmID0gZGVmQnlHcm91cElkW2dyb3VwSWRdO1xuICAgICAgICAgICAgbGV0IHVpID0gZXZlbnRVaXNbZGVmLmRlZklkXTtcbiAgICAgICAgICAgIGJnUmFuZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgIGRlZixcbiAgICAgICAgICAgICAgICB1aSxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTogbnVsbCxcbiAgICAgICAgICAgICAgICByYW5nZTogaW52ZXJ0ZWRSYW5nZSxcbiAgICAgICAgICAgICAgICBpc1N0YXJ0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc0VuZDogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBkZWZJZCBpbiBpbnZlcnNlQmdCeURlZklkKSB7XG4gICAgICAgIGxldCByYW5nZXMgPSBpbnZlcnNlQmdCeURlZklkW2RlZklkXTtcbiAgICAgICAgbGV0IGludmVydGVkUmFuZ2VzID0gaW52ZXJ0UmFuZ2VzKHJhbmdlcywgZnJhbWluZ1JhbmdlKTtcbiAgICAgICAgZm9yIChsZXQgaW52ZXJ0ZWRSYW5nZSBvZiBpbnZlcnRlZFJhbmdlcykge1xuICAgICAgICAgICAgYmdSYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgZGVmOiBldmVudFN0b3JlLmRlZnNbZGVmSWRdLFxuICAgICAgICAgICAgICAgIHVpOiBldmVudFVpc1tkZWZJZF0sXG4gICAgICAgICAgICAgICAgaW5zdGFuY2U6IG51bGwsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IGludmVydGVkUmFuZ2UsXG4gICAgICAgICAgICAgICAgaXNTdGFydDogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNFbmQ6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgYmc6IGJnUmFuZ2VzLCBmZzogZmdSYW5nZXMgfTtcbn1cbmZ1bmN0aW9uIGhhc0JnUmVuZGVyaW5nKGRlZikge1xuICAgIHJldHVybiBkZWYudWkuZGlzcGxheSA9PT0gJ2JhY2tncm91bmQnIHx8IGRlZi51aS5kaXNwbGF5ID09PSAnaW52ZXJzZS1iYWNrZ3JvdW5kJztcbn1cbmZ1bmN0aW9uIHNldEVsU2VnKGVsLCBzZWcpIHtcbiAgICBlbC5mY1NlZyA9IHNlZztcbn1cbmZ1bmN0aW9uIGdldEVsU2VnKGVsKSB7XG4gICAgcmV0dXJuIGVsLmZjU2VnIHx8XG4gICAgICAgIGVsLnBhcmVudE5vZGUuZmNTZWcgfHwgLy8gZm9yIHRoZSBoYXJuZXNzXG4gICAgICAgIG51bGw7XG59XG4vLyBldmVudCB1aSBjb21wdXRhdGlvblxuZnVuY3Rpb24gY29tcGlsZUV2ZW50VWlzKGV2ZW50RGVmcywgZXZlbnRVaUJhc2VzKSB7XG4gICAgcmV0dXJuIG1hcEhhc2goZXZlbnREZWZzLCAoZXZlbnREZWYpID0+IGNvbXBpbGVFdmVudFVpKGV2ZW50RGVmLCBldmVudFVpQmFzZXMpKTtcbn1cbmZ1bmN0aW9uIGNvbXBpbGVFdmVudFVpKGV2ZW50RGVmLCBldmVudFVpQmFzZXMpIHtcbiAgICBsZXQgdWlzID0gW107XG4gICAgaWYgKGV2ZW50VWlCYXNlc1snJ10pIHtcbiAgICAgICAgdWlzLnB1c2goZXZlbnRVaUJhc2VzWycnXSk7XG4gICAgfVxuICAgIGlmIChldmVudFVpQmFzZXNbZXZlbnREZWYuZGVmSWRdKSB7XG4gICAgICAgIHVpcy5wdXNoKGV2ZW50VWlCYXNlc1tldmVudERlZi5kZWZJZF0pO1xuICAgIH1cbiAgICB1aXMucHVzaChldmVudERlZi51aSk7XG4gICAgcmV0dXJuIGNvbWJpbmVFdmVudFVpcyh1aXMpO1xufVxuZnVuY3Rpb24gc29ydEV2ZW50U2VncyhzZWdzLCBldmVudE9yZGVyU3BlY3MpIHtcbiAgICBsZXQgb2JqcyA9IHNlZ3MubWFwKGJ1aWxkU2VnQ29tcGFyZU9iaik7XG4gICAgb2Jqcy5zb3J0KChvYmowLCBvYmoxKSA9PiBjb21wYXJlQnlGaWVsZFNwZWNzKG9iajAsIG9iajEsIGV2ZW50T3JkZXJTcGVjcykpO1xuICAgIHJldHVybiBvYmpzLm1hcCgoYykgPT4gYy5fc2VnKTtcbn1cbi8vIHJldHVybnMgYSBvYmplY3Qgd2l0aCBhbGwgcHJpbWl0aXZlIHByb3BzIHRoYXQgY2FuIGJlIGNvbXBhcmVkXG5mdW5jdGlvbiBidWlsZFNlZ0NvbXBhcmVPYmooc2VnKSB7XG4gICAgbGV0IHsgZXZlbnRSYW5nZSB9ID0gc2VnO1xuICAgIGxldCBldmVudERlZiA9IGV2ZW50UmFuZ2UuZGVmO1xuICAgIGxldCByYW5nZSA9IGV2ZW50UmFuZ2UuaW5zdGFuY2UgPyBldmVudFJhbmdlLmluc3RhbmNlLnJhbmdlIDogZXZlbnRSYW5nZS5yYW5nZTtcbiAgICBsZXQgc3RhcnQgPSByYW5nZS5zdGFydCA/IHJhbmdlLnN0YXJ0LnZhbHVlT2YoKSA6IDA7IC8vIFRPRE86IGJldHRlciBzdXBwb3J0IGZvciBvcGVuLXJhbmdlIGV2ZW50c1xuICAgIGxldCBlbmQgPSByYW5nZS5lbmQgPyByYW5nZS5lbmQudmFsdWVPZigpIDogMDsgLy8gXCJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV2ZW50RGVmLmV4dGVuZGVkUHJvcHMpLCBldmVudERlZiksIHsgaWQ6IGV2ZW50RGVmLnB1YmxpY0lkLCBzdGFydCxcbiAgICAgICAgZW5kLCBkdXJhdGlvbjogZW5kIC0gc3RhcnQsIGFsbERheTogTnVtYmVyKGV2ZW50RGVmLmFsbERheSksIF9zZWc6IHNlZyB9KTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVTZWdEcmFnZ2FibGUoc2VnLCBjb250ZXh0KSB7XG4gICAgbGV0IHsgcGx1Z2luSG9va3MgfSA9IGNvbnRleHQ7XG4gICAgbGV0IHRyYW5zZm9ybWVycyA9IHBsdWdpbkhvb2tzLmlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzO1xuICAgIGxldCB7IGRlZiwgdWkgfSA9IHNlZy5ldmVudFJhbmdlO1xuICAgIGxldCB2YWwgPSB1aS5zdGFydEVkaXRhYmxlO1xuICAgIGZvciAobGV0IHRyYW5zZm9ybWVyIG9mIHRyYW5zZm9ybWVycykge1xuICAgICAgICB2YWwgPSB0cmFuc2Zvcm1lcih2YWwsIGRlZiwgdWksIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xufVxuZnVuY3Rpb24gY29tcHV0ZVNlZ1N0YXJ0UmVzaXphYmxlKHNlZywgY29udGV4dCkge1xuICAgIHJldHVybiBzZWcuaXNTdGFydCAmJiBzZWcuZXZlbnRSYW5nZS51aS5kdXJhdGlvbkVkaXRhYmxlICYmIGNvbnRleHQub3B0aW9ucy5ldmVudFJlc2l6YWJsZUZyb21TdGFydDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVTZWdFbmRSZXNpemFibGUoc2VnLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHNlZy5pc0VuZCAmJiBzZWcuZXZlbnRSYW5nZS51aS5kdXJhdGlvbkVkaXRhYmxlO1xufVxuZnVuY3Rpb24gYnVpbGRTZWdUaW1lVGV4dChzZWcsIHRpbWVGb3JtYXQsIGNvbnRleHQsIGRlZmF1bHREaXNwbGF5RXZlbnRUaW1lLCAvLyBkZWZhdWx0cyB0byB0cnVlXG5kZWZhdWx0RGlzcGxheUV2ZW50RW5kLCAvLyBkZWZhdWx0cyB0byB0cnVlXG5zdGFydE92ZXJyaWRlLCBlbmRPdmVycmlkZSkge1xuICAgIGxldCB7IGRhdGVFbnYsIG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgbGV0IHsgZGlzcGxheUV2ZW50VGltZSwgZGlzcGxheUV2ZW50RW5kIH0gPSBvcHRpb25zO1xuICAgIGxldCBldmVudERlZiA9IHNlZy5ldmVudFJhbmdlLmRlZjtcbiAgICBsZXQgZXZlbnRJbnN0YW5jZSA9IHNlZy5ldmVudFJhbmdlLmluc3RhbmNlO1xuICAgIGlmIChkaXNwbGF5RXZlbnRUaW1lID09IG51bGwpIHtcbiAgICAgICAgZGlzcGxheUV2ZW50VGltZSA9IGRlZmF1bHREaXNwbGF5RXZlbnRUaW1lICE9PSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRpc3BsYXlFdmVudEVuZCA9PSBudWxsKSB7XG4gICAgICAgIGRpc3BsYXlFdmVudEVuZCA9IGRlZmF1bHREaXNwbGF5RXZlbnRFbmQgIT09IGZhbHNlO1xuICAgIH1cbiAgICBsZXQgd2hvbGVFdmVudFN0YXJ0ID0gZXZlbnRJbnN0YW5jZS5yYW5nZS5zdGFydDtcbiAgICBsZXQgd2hvbGVFdmVudEVuZCA9IGV2ZW50SW5zdGFuY2UucmFuZ2UuZW5kO1xuICAgIGxldCBzZWdTdGFydCA9IHN0YXJ0T3ZlcnJpZGUgfHwgc2VnLnN0YXJ0IHx8IHNlZy5ldmVudFJhbmdlLnJhbmdlLnN0YXJ0O1xuICAgIGxldCBzZWdFbmQgPSBlbmRPdmVycmlkZSB8fCBzZWcuZW5kIHx8IHNlZy5ldmVudFJhbmdlLnJhbmdlLmVuZDtcbiAgICBsZXQgaXNTdGFydERheSA9IHN0YXJ0T2ZEYXkod2hvbGVFdmVudFN0YXJ0KS52YWx1ZU9mKCkgPT09IHN0YXJ0T2ZEYXkoc2VnU3RhcnQpLnZhbHVlT2YoKTtcbiAgICBsZXQgaXNFbmREYXkgPSBzdGFydE9mRGF5KGFkZE1zKHdob2xlRXZlbnRFbmQsIC0xKSkudmFsdWVPZigpID09PSBzdGFydE9mRGF5KGFkZE1zKHNlZ0VuZCwgLTEpKS52YWx1ZU9mKCk7XG4gICAgaWYgKGRpc3BsYXlFdmVudFRpbWUgJiYgIWV2ZW50RGVmLmFsbERheSAmJiAoaXNTdGFydERheSB8fCBpc0VuZERheSkpIHtcbiAgICAgICAgc2VnU3RhcnQgPSBpc1N0YXJ0RGF5ID8gd2hvbGVFdmVudFN0YXJ0IDogc2VnU3RhcnQ7XG4gICAgICAgIHNlZ0VuZCA9IGlzRW5kRGF5ID8gd2hvbGVFdmVudEVuZCA6IHNlZ0VuZDtcbiAgICAgICAgaWYgKGRpc3BsYXlFdmVudEVuZCAmJiBldmVudERlZi5oYXNFbmQpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdFJhbmdlKHNlZ1N0YXJ0LCBzZWdFbmQsIHRpbWVGb3JtYXQsIHtcbiAgICAgICAgICAgICAgICBmb3JjZWRTdGFydFR6bzogc3RhcnRPdmVycmlkZSA/IG51bGwgOiBldmVudEluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLFxuICAgICAgICAgICAgICAgIGZvcmNlZEVuZFR6bzogZW5kT3ZlcnJpZGUgPyBudWxsIDogZXZlbnRJbnN0YW5jZS5mb3JjZWRFbmRUem8sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXQoc2VnU3RhcnQsIHRpbWVGb3JtYXQsIHtcbiAgICAgICAgICAgIGZvcmNlZFR6bzogc3RhcnRPdmVycmlkZSA/IG51bGwgOiBldmVudEluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLCAvLyBub29vb28sIHNhbWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAnJztcbn1cbmZ1bmN0aW9uIGdldFNlZ01ldGEoc2VnLCB0b2RheVJhbmdlLCBub3dEYXRlKSB7XG4gICAgbGV0IHNlZ1JhbmdlID0gc2VnLmV2ZW50UmFuZ2UucmFuZ2U7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaXNQYXN0OiBzZWdSYW5nZS5lbmQgPD0gKG5vd0RhdGUgfHwgdG9kYXlSYW5nZS5zdGFydCksXG4gICAgICAgIGlzRnV0dXJlOiBzZWdSYW5nZS5zdGFydCA+PSAobm93RGF0ZSB8fCB0b2RheVJhbmdlLmVuZCksXG4gICAgICAgIGlzVG9kYXk6IHRvZGF5UmFuZ2UgJiYgcmFuZ2VDb250YWluc01hcmtlcih0b2RheVJhbmdlLCBzZWdSYW5nZS5zdGFydCksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldEV2ZW50Q2xhc3NOYW1lcyhwcm9wcykge1xuICAgIGxldCBjbGFzc05hbWVzID0gWydmYy1ldmVudCddO1xuICAgIGlmIChwcm9wcy5pc01pcnJvcikge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LW1pcnJvcicpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNEcmFnZ2FibGUpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1kcmFnZ2FibGUnKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmlzU3RhcnRSZXNpemFibGUgfHwgcHJvcHMuaXNFbmRSZXNpemFibGUpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1yZXNpemFibGUnKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmlzRHJhZ2dpbmcpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1kcmFnZ2luZycpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNSZXNpemluZykge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LXJlc2l6aW5nJyk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pc1NlbGVjdGVkKSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtc2VsZWN0ZWQnKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmlzU3RhcnQpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1zdGFydCcpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNFbmQpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1lbmQnKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmlzUGFzdCkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LXBhc3QnKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmlzVG9kYXkpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC10b2RheScpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNGdXR1cmUpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1mdXR1cmUnKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzTmFtZXM7XG59XG5mdW5jdGlvbiBidWlsZEV2ZW50UmFuZ2VLZXkoZXZlbnRSYW5nZSkge1xuICAgIHJldHVybiBldmVudFJhbmdlLmluc3RhbmNlXG4gICAgICAgID8gZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkXG4gICAgICAgIDogYCR7ZXZlbnRSYW5nZS5kZWYuZGVmSWR9OiR7ZXZlbnRSYW5nZS5yYW5nZS5zdGFydC50b0lTT1N0cmluZygpfWA7XG4gICAgLy8gaW52ZXJzZS1iYWNrZ3JvdW5kIGV2ZW50cyBkb24ndCBoYXZlIHNwZWNpZmljIGluc3RhbmNlcy4gVE9ETzogYmV0dGVyIHNvbHV0aW9uXG59XG5mdW5jdGlvbiBnZXRTZWdBbmNob3JBdHRycyhzZWcsIGNvbnRleHQpIHtcbiAgICBsZXQgeyBkZWYsIGluc3RhbmNlIH0gPSBzZWcuZXZlbnRSYW5nZTtcbiAgICBsZXQgeyB1cmwgfSA9IGRlZjtcbiAgICBpZiAodXJsKSB7XG4gICAgICAgIHJldHVybiB7IGhyZWY6IHVybCB9O1xuICAgIH1cbiAgICBsZXQgeyBlbWl0dGVyLCBvcHRpb25zIH0gPSBjb250ZXh0O1xuICAgIGxldCB7IGV2ZW50SW50ZXJhY3RpdmUgfSA9IG9wdGlvbnM7XG4gICAgaWYgKGV2ZW50SW50ZXJhY3RpdmUgPT0gbnVsbCkge1xuICAgICAgICBldmVudEludGVyYWN0aXZlID0gZGVmLmludGVyYWN0aXZlO1xuICAgICAgICBpZiAoZXZlbnRJbnRlcmFjdGl2ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBldmVudEludGVyYWN0aXZlID0gQm9vbGVhbihlbWl0dGVyLmhhc0hhbmRsZXJzKCdldmVudENsaWNrJykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIG1vY2sgd2hhdCBoYXBwZW5zIGluIEV2ZW50Q2xpY2tpbmdcbiAgICBpZiAoZXZlbnRJbnRlcmFjdGl2ZSkge1xuICAgICAgICAvLyBvbmx5IGF0dGFjaCBrZXlib2FyZC1yZWxhdGVkIGhhbmRsZXJzIGJlY2F1c2UgY2xpY2sgaGFuZGxlciBpcyBhbHJlYWR5IGRvbmUgaW4gRXZlbnRDbGlja2luZ1xuICAgICAgICByZXR1cm4gY3JlYXRlQXJpYUtleWJvYXJkQXR0cnMoKGV2KSA9PiB7XG4gICAgICAgICAgICBlbWl0dGVyLnRyaWdnZXIoJ2V2ZW50Q2xpY2snLCB7XG4gICAgICAgICAgICAgICAgZWw6IGV2LnRhcmdldCxcbiAgICAgICAgICAgICAgICBldmVudDogbmV3IEV2ZW50SW1wbChjb250ZXh0LCBkZWYsIGluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICBqc0V2ZW50OiBldixcbiAgICAgICAgICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7fTtcbn1cblxuY29uc3QgU1RBTkRBUkRfUFJPUFMgPSB7XG4gICAgc3RhcnQ6IGlkZW50aXR5LFxuICAgIGVuZDogaWRlbnRpdHksXG4gICAgYWxsRGF5OiBCb29sZWFuLFxufTtcbmZ1bmN0aW9uIHBhcnNlRGF0ZVNwYW4ocmF3LCBkYXRlRW52LCBkZWZhdWx0RHVyYXRpb24pIHtcbiAgICBsZXQgc3BhbiA9IHBhcnNlT3BlbkRhdGVTcGFuKHJhdywgZGF0ZUVudik7XG4gICAgbGV0IHsgcmFuZ2UgfSA9IHNwYW47XG4gICAgaWYgKCFyYW5nZS5zdGFydCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFyYW5nZS5lbmQpIHtcbiAgICAgICAgaWYgKGRlZmF1bHREdXJhdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByYW5nZS5lbmQgPSBkYXRlRW52LmFkZChyYW5nZS5zdGFydCwgZGVmYXVsdER1cmF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHNwYW47XG59XG4vKlxuVE9ETzogc29tZWhvdyBjb21iaW5lIHdpdGggcGFyc2VSYW5nZT9cbldpbGwgcmV0dXJuIG51bGwgaWYgdGhlIHN0YXJ0L2VuZCBwcm9wcyB3ZXJlIHByZXNlbnQgYnV0IHBhcnNlZCBpbnZhbGlkbHkuXG4qL1xuZnVuY3Rpb24gcGFyc2VPcGVuRGF0ZVNwYW4ocmF3LCBkYXRlRW52KSB7XG4gICAgbGV0IHsgcmVmaW5lZDogc3RhbmRhcmRQcm9wcywgZXh0cmEgfSA9IHJlZmluZVByb3BzKHJhdywgU1RBTkRBUkRfUFJPUFMpO1xuICAgIGxldCBzdGFydE1ldGEgPSBzdGFuZGFyZFByb3BzLnN0YXJ0ID8gZGF0ZUVudi5jcmVhdGVNYXJrZXJNZXRhKHN0YW5kYXJkUHJvcHMuc3RhcnQpIDogbnVsbDtcbiAgICBsZXQgZW5kTWV0YSA9IHN0YW5kYXJkUHJvcHMuZW5kID8gZGF0ZUVudi5jcmVhdGVNYXJrZXJNZXRhKHN0YW5kYXJkUHJvcHMuZW5kKSA6IG51bGw7XG4gICAgbGV0IHsgYWxsRGF5IH0gPSBzdGFuZGFyZFByb3BzO1xuICAgIGlmIChhbGxEYXkgPT0gbnVsbCkge1xuICAgICAgICBhbGxEYXkgPSAoc3RhcnRNZXRhICYmIHN0YXJ0TWV0YS5pc1RpbWVVbnNwZWNpZmllZCkgJiZcbiAgICAgICAgICAgICghZW5kTWV0YSB8fCBlbmRNZXRhLmlzVGltZVVuc3BlY2lmaWVkKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyByYW5nZToge1xuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0TWV0YSA/IHN0YXJ0TWV0YS5tYXJrZXIgOiBudWxsLFxuICAgICAgICAgICAgZW5kOiBlbmRNZXRhID8gZW5kTWV0YS5tYXJrZXIgOiBudWxsLFxuICAgICAgICB9LCBhbGxEYXkgfSwgZXh0cmEpO1xufVxuZnVuY3Rpb24gaXNEYXRlU3BhbnNFcXVhbChzcGFuMCwgc3BhbjEpIHtcbiAgICByZXR1cm4gcmFuZ2VzRXF1YWwoc3BhbjAucmFuZ2UsIHNwYW4xLnJhbmdlKSAmJlxuICAgICAgICBzcGFuMC5hbGxEYXkgPT09IHNwYW4xLmFsbERheSAmJlxuICAgICAgICBpc1NwYW5Qcm9wc0VxdWFsKHNwYW4wLCBzcGFuMSk7XG59XG4vLyB0aGUgTk9OLURBVEUtUkVMQVRFRCBwcm9wc1xuZnVuY3Rpb24gaXNTcGFuUHJvcHNFcXVhbChzcGFuMCwgc3BhbjEpIHtcbiAgICBmb3IgKGxldCBwcm9wTmFtZSBpbiBzcGFuMSkge1xuICAgICAgICBpZiAocHJvcE5hbWUgIT09ICdyYW5nZScgJiYgcHJvcE5hbWUgIT09ICdhbGxEYXknKSB7XG4gICAgICAgICAgICBpZiAoc3BhbjBbcHJvcE5hbWVdICE9PSBzcGFuMVtwcm9wTmFtZV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYXJlIHRoZXJlIGFueSBwcm9wcyB0aGF0IHNwYW4wIGhhcyB0aGF0IHNwYW4xIERPRVNOJ1QgaGF2ZT9cbiAgICAvLyBib3RoIGhhdmUgcmFuZ2UvYWxsRGF5LCBzbyBubyBuZWVkIHRvIHNwZWNpYWwtY2FzZS5cbiAgICBmb3IgKGxldCBwcm9wTmFtZSBpbiBzcGFuMCkge1xuICAgICAgICBpZiAoIShwcm9wTmFtZSBpbiBzcGFuMSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRGF0ZVNwYW5BcGkoc3BhbiwgZGF0ZUVudikge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJ1aWxkUmFuZ2VBcGkoc3Bhbi5yYW5nZSwgZGF0ZUVudiwgc3Bhbi5hbGxEYXkpKSwgeyBhbGxEYXk6IHNwYW4uYWxsRGF5IH0pO1xufVxuZnVuY3Rpb24gYnVpbGRSYW5nZUFwaVdpdGhUaW1lWm9uZShyYW5nZSwgZGF0ZUVudiwgb21pdFRpbWUpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBidWlsZFJhbmdlQXBpKHJhbmdlLCBkYXRlRW52LCBvbWl0VGltZSkpLCB7IHRpbWVab25lOiBkYXRlRW52LnRpbWVab25lIH0pO1xufVxuZnVuY3Rpb24gYnVpbGRSYW5nZUFwaShyYW5nZSwgZGF0ZUVudiwgb21pdFRpbWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogZGF0ZUVudi50b0RhdGUocmFuZ2Uuc3RhcnQpLFxuICAgICAgICBlbmQ6IGRhdGVFbnYudG9EYXRlKHJhbmdlLmVuZCksXG4gICAgICAgIHN0YXJ0U3RyOiBkYXRlRW52LmZvcm1hdElzbyhyYW5nZS5zdGFydCwgeyBvbWl0VGltZSB9KSxcbiAgICAgICAgZW5kU3RyOiBkYXRlRW52LmZvcm1hdElzbyhyYW5nZS5lbmQsIHsgb21pdFRpbWUgfSksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZhYnJpY2F0ZUV2ZW50UmFuZ2UoZGF0ZVNwYW4sIGV2ZW50VWlCYXNlcywgY29udGV4dCkge1xuICAgIGxldCByZXMgPSByZWZpbmVFdmVudERlZih7IGVkaXRhYmxlOiBmYWxzZSB9LCBjb250ZXh0KTtcbiAgICBsZXQgZGVmID0gcGFyc2VFdmVudERlZihyZXMucmVmaW5lZCwgcmVzLmV4dHJhLCAnJywgLy8gc291cmNlSWRcbiAgICBkYXRlU3Bhbi5hbGxEYXksIHRydWUsIC8vIGhhc0VuZFxuICAgIGNvbnRleHQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlZixcbiAgICAgICAgdWk6IGNvbXBpbGVFdmVudFVpKGRlZiwgZXZlbnRVaUJhc2VzKSxcbiAgICAgICAgaW5zdGFuY2U6IGNyZWF0ZUV2ZW50SW5zdGFuY2UoZGVmLmRlZklkLCBkYXRlU3Bhbi5yYW5nZSksXG4gICAgICAgIHJhbmdlOiBkYXRlU3Bhbi5yYW5nZSxcbiAgICAgICAgaXNTdGFydDogdHJ1ZSxcbiAgICAgICAgaXNFbmQ6IHRydWUsXG4gICAgfTtcbn1cblxuLypcbmdpdmVuIGEgZnVuY3Rpb24gdGhhdCByZXNvbHZlcyBhIHJlc3VsdCBhc3luY2hyb25vdXNseS5cbnRoZSBmdW5jdGlvbiBjYW4gZWl0aGVyIGNhbGwgcGFzc2VkLWluIHN1Y2Nlc3MgYW5kIGZhaWx1cmUgY2FsbGJhY2tzLFxub3IgaXQgY2FuIHJldHVybiBhIHByb21pc2UuXG5pZiB5b3UgbmVlZCB0byBwYXNzIGFkZGl0aW9uYWwgcGFyYW1zIHRvIGZ1bmMsIGJpbmQgdGhlbSBmaXJzdC5cbiovXG5mdW5jdGlvbiB1bnByb21pc2lmeShmdW5jLCBub3JtYWxpemVkU3VjY2Vzc0NhbGxiYWNrLCBub3JtYWxpemVkRmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgLy8gZ3VhcmQgYWdhaW5zdCBzdWNjZXNzL2ZhaWx1cmUgY2FsbGJhY2tzIGJlaW5nIGNhbGxlZCBtb3JlIHRoYW4gb25jZVxuICAgIC8vIGFuZCBndWFyZCBhZ2FpbnN0IGEgcHJvbWlzZSBBTkQgY2FsbGJhY2sgYmVpbmcgdXNlZCB0b2dldGhlci5cbiAgICBsZXQgaXNSZXNvbHZlZCA9IGZhbHNlO1xuICAgIGxldCB3cmFwcGVkU3VjY2VzcyA9IGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgaWYgKCFpc1Jlc29sdmVkKSB7XG4gICAgICAgICAgICBpc1Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRTdWNjZXNzQ2FsbGJhY2socmVzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgbGV0IHdyYXBwZWRGYWlsdXJlID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGlmICghaXNSZXNvbHZlZCkge1xuICAgICAgICAgICAgaXNSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICBub3JtYWxpemVkRmFpbHVyZUNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgbGV0IHJlcyA9IGZ1bmMod3JhcHBlZFN1Y2Nlc3MsIHdyYXBwZWRGYWlsdXJlKTtcbiAgICBpZiAocmVzICYmIHR5cGVvZiByZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXMudGhlbih3cmFwcGVkU3VjY2Vzcywgd3JhcHBlZEZhaWx1cmUpO1xuICAgIH1cbn1cblxuY2xhc3MgSnNvblJlcXVlc3RFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCByZXNwb25zZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlcXVlc3RKc29uKG1ldGhvZCwgdXJsLCBwYXJhbXMpIHtcbiAgICBtZXRob2QgPSBtZXRob2QudG9VcHBlckNhc2UoKTtcbiAgICBjb25zdCBmZXRjaE9wdGlvbnMgPSB7XG4gICAgICAgIG1ldGhvZCxcbiAgICB9O1xuICAgIGlmIChtZXRob2QgPT09ICdHRVQnKSB7XG4gICAgICAgIHVybCArPSAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICtcbiAgICAgICAgICAgIG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZldGNoT3B0aW9ucy5ib2R5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbXMpO1xuICAgICAgICBmZXRjaE9wdGlvbnMuaGVhZGVycyA9IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZldGNoKHVybCwgZmV0Y2hPcHRpb25zKS50aGVuKChmZXRjaFJlcykgPT4ge1xuICAgICAgICBpZiAoZmV0Y2hSZXMub2spIHtcbiAgICAgICAgICAgIHJldHVybiBmZXRjaFJlcy5qc29uKCkudGhlbigocGFyc2VkUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3BhcnNlZFJlc3BvbnNlLCBmZXRjaFJlc107XG4gICAgICAgICAgICB9LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEpzb25SZXF1ZXN0RXJyb3IoJ0ZhaWx1cmUgcGFyc2luZyBKU09OJywgZmV0Y2hSZXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSnNvblJlcXVlc3RFcnJvcignUmVxdWVzdCBmYWlsZWQnLCBmZXRjaFJlcyk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxubGV0IGNhblZHcm93V2l0aGluQ2VsbDtcbmZ1bmN0aW9uIGdldENhblZHcm93V2l0aGluQ2VsbCgpIHtcbiAgICBpZiAoY2FuVkdyb3dXaXRoaW5DZWxsID09IG51bGwpIHtcbiAgICAgICAgY2FuVkdyb3dXaXRoaW5DZWxsID0gY29tcHV0ZUNhblZHcm93V2l0aGluQ2VsbCgpO1xuICAgIH1cbiAgICByZXR1cm4gY2FuVkdyb3dXaXRoaW5DZWxsO1xufVxuZnVuY3Rpb24gY29tcHV0ZUNhblZHcm93V2l0aGluQ2VsbCgpIHtcbiAgICAvLyBmb3IgU1NSLCBiZWNhdXNlIHRoaXMgZnVuY3Rpb24gaXMgY2FsbCBpbW1lZGlhdGVseSBhdCB0b3AtbGV2ZWxcbiAgICAvLyBUT0RPOiBqdXN0IG1ha2UgdGhpcyBsb2dpYyBleGVjdXRlIHRvcC1sZXZlbCwgaW1tZWRpYXRlbHksIGluc3RlYWQgb2YgZG9pbmcgbGF6aWx5XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxldCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGVsLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBlbC5zdHlsZS50b3AgPSAnMHB4JztcbiAgICBlbC5zdHlsZS5sZWZ0ID0gJzBweCc7XG4gICAgZWwuaW5uZXJIVE1MID0gJzx0YWJsZT48dHI+PHRkPjxkaXY+PC9kaXY+PC90ZD48L3RyPjwvdGFibGU+JztcbiAgICBlbC5xdWVyeVNlbGVjdG9yKCd0YWJsZScpLnN0eWxlLmhlaWdodCA9ICcxMDBweCc7XG4gICAgZWwucXVlcnlTZWxlY3RvcignZGl2Jykuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWwpO1xuICAgIGxldCBkaXYgPSBlbC5xdWVyeVNlbGVjdG9yKCdkaXYnKTtcbiAgICBsZXQgcG9zc2libGUgPSBkaXYub2Zmc2V0SGVpZ2h0ID4gMDtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsKTtcbiAgICByZXR1cm4gcG9zc2libGU7XG59XG5cbmNsYXNzIENhbGVuZGFyUm9vdCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgZm9yUHJpbnQ6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUJlZm9yZVByaW50ID0gKCkgPT4ge1xuICAgICAgICAgICAgZmx1c2hTeW5jKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgZm9yUHJpbnQ6IHRydWUgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVBZnRlclByaW50ID0gKCkgPT4ge1xuICAgICAgICAgICAgZmx1c2hTeW5jKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgZm9yUHJpbnQ6IGZhbHNlIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IHByb3BzO1xuICAgICAgICBsZXQgeyBmb3JQcmludCB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgbGV0IGlzSGVpZ2h0QXV0byA9IGZvclByaW50IHx8IG9wdGlvbnMuaGVpZ2h0ID09PSAnYXV0bycgfHwgb3B0aW9ucy5jb250ZW50SGVpZ2h0ID09PSAnYXV0byc7XG4gICAgICAgIGxldCBoZWlnaHQgPSAoIWlzSGVpZ2h0QXV0byAmJiBvcHRpb25zLmhlaWdodCAhPSBudWxsKSA/IG9wdGlvbnMuaGVpZ2h0IDogJyc7XG4gICAgICAgIGxldCBjbGFzc05hbWVzID0gW1xuICAgICAgICAgICAgJ2ZjJyxcbiAgICAgICAgICAgIGZvclByaW50ID8gJ2ZjLW1lZGlhLXByaW50JyA6ICdmYy1tZWRpYS1zY3JlZW4nLFxuICAgICAgICAgICAgYGZjLWRpcmVjdGlvbi0ke29wdGlvbnMuZGlyZWN0aW9ufWAsXG4gICAgICAgICAgICBwcm9wcy50aGVtZS5nZXRDbGFzcygncm9vdCcpLFxuICAgICAgICBdO1xuICAgICAgICBpZiAoIWdldENhblZHcm93V2l0aGluQ2VsbCgpKSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWxpcXVpZC1oYWNrJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3BzLmNoaWxkcmVuKGNsYXNzTmFtZXMsIGhlaWdodCwgaXNIZWlnaHRBdXRvLCBmb3JQcmludCk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBsZXQgeyBlbWl0dGVyIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBlbWl0dGVyLm9uKCdfYmVmb3JlcHJpbnQnLCB0aGlzLmhhbmRsZUJlZm9yZVByaW50KTtcbiAgICAgICAgZW1pdHRlci5vbignX2FmdGVycHJpbnQnLCB0aGlzLmhhbmRsZUFmdGVyUHJpbnQpO1xuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgbGV0IHsgZW1pdHRlciB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgZW1pdHRlci5vZmYoJ19iZWZvcmVwcmludCcsIHRoaXMuaGFuZGxlQmVmb3JlUHJpbnQpO1xuICAgICAgICBlbWl0dGVyLm9mZignX2FmdGVycHJpbnQnLCB0aGlzLmhhbmRsZUFmdGVyUHJpbnQpO1xuICAgIH1cbn1cblxuY2xhc3MgSW50ZXJhY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gc2V0dGluZ3MuY29tcG9uZW50O1xuICAgICAgICB0aGlzLmlzSGl0Q29tYm9BbGxvd2VkID0gc2V0dGluZ3MuaXNIaXRDb21ib0FsbG93ZWQgfHwgbnVsbDtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZUludGVyYWN0aW9uU2V0dGluZ3MoY29tcG9uZW50LCBpbnB1dCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbXBvbmVudCxcbiAgICAgICAgZWw6IGlucHV0LmVsLFxuICAgICAgICB1c2VFdmVudENlbnRlcjogaW5wdXQudXNlRXZlbnRDZW50ZXIgIT0gbnVsbCA/IGlucHV0LnVzZUV2ZW50Q2VudGVyIDogdHJ1ZSxcbiAgICAgICAgaXNIaXRDb21ib0FsbG93ZWQ6IGlucHV0LmlzSGl0Q29tYm9BbGxvd2VkIHx8IG51bGwsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGludGVyYWN0aW9uU2V0dGluZ3NUb1N0b3JlKHNldHRpbmdzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgW3NldHRpbmdzLmNvbXBvbmVudC51aWRdOiBzZXR0aW5ncyxcbiAgICB9O1xufVxuLy8gZ2xvYmFsIHN0YXRlXG5jb25zdCBpbnRlcmFjdGlvblNldHRpbmdzU3RvcmUgPSB7fTtcblxuY2xhc3MgQ2FsZW5kYXJJbXBsIHtcbiAgICBnZXRDdXJyZW50RGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudERhdGFNYW5hZ2VyLmdldEN1cnJlbnREYXRhKCk7XG4gICAgfVxuICAgIGRpc3BhdGNoKGFjdGlvbikge1xuICAgICAgICB0aGlzLmN1cnJlbnREYXRhTWFuYWdlci5kaXNwYXRjaChhY3Rpb24pO1xuICAgIH1cbiAgICBnZXQgdmlldygpIHsgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudERhdGEoKS52aWV3QXBpOyB9XG4gICAgYmF0Y2hSZW5kZXJpbmcoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gICAgdXBkYXRlU2l6ZSgpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdfcmVzaXplJywgdHJ1ZSk7XG4gICAgfVxuICAgIC8vIE9wdGlvbnNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHNldE9wdGlvbihuYW1lLCB2YWwpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnU0VUX09QVElPTicsXG4gICAgICAgICAgICBvcHRpb25OYW1lOiBuYW1lLFxuICAgICAgICAgICAgcmF3T3B0aW9uVmFsdWU6IHZhbCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldE9wdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnREYXRhTWFuYWdlci5jdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXRbbmFtZV07XG4gICAgfVxuICAgIGdldEF2YWlsYWJsZUxvY2FsZUNvZGVzKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5nZXRDdXJyZW50RGF0YSgpLmF2YWlsYWJsZVJhd0xvY2FsZXMpO1xuICAgIH1cbiAgICAvLyBUcmlnZ2VyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBvbihoYW5kbGVyTmFtZSwgaGFuZGxlcikge1xuICAgICAgICBsZXQgeyBjdXJyZW50RGF0YU1hbmFnZXIgfSA9IHRoaXM7XG4gICAgICAgIGlmIChjdXJyZW50RGF0YU1hbmFnZXIuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZXJzW2hhbmRsZXJOYW1lXSkge1xuICAgICAgICAgICAgY3VycmVudERhdGFNYW5hZ2VyLmVtaXR0ZXIub24oaGFuZGxlck5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBVbmtub3duIGxpc3RlbmVyIG5hbWUgJyR7aGFuZGxlck5hbWV9J2ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9mZihoYW5kbGVyTmFtZSwgaGFuZGxlcikge1xuICAgICAgICB0aGlzLmN1cnJlbnREYXRhTWFuYWdlci5lbWl0dGVyLm9mZihoYW5kbGVyTmFtZSwgaGFuZGxlcik7XG4gICAgfVxuICAgIC8vIG5vdCBtZWFudCBmb3IgcHVibGljIHVzZVxuICAgIHRyaWdnZXIoaGFuZGxlck5hbWUsIC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50RGF0YU1hbmFnZXIuZW1pdHRlci50cmlnZ2VyKGhhbmRsZXJOYW1lLCAuLi5hcmdzKTtcbiAgICB9XG4gICAgLy8gVmlld1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgY2hhbmdlVmlldyh2aWV3VHlwZSwgZGF0ZU9yUmFuZ2UpIHtcbiAgICAgICAgdGhpcy5iYXRjaFJlbmRlcmluZygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgICAgICBpZiAoZGF0ZU9yUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0ZU9yUmFuZ2Uuc3RhcnQgJiYgZGF0ZU9yUmFuZ2UuZW5kKSB7IC8vIGEgcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX1ZJRVdfVFlQRScsXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1NFVF9PUFRJT04nLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uTmFtZTogJ3Zpc2libGVSYW5nZScsXG4gICAgICAgICAgICAgICAgICAgICAgICByYXdPcHRpb25WYWx1ZTogZGF0ZU9yUmFuZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfVklFV19UWVBFJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZU1hcmtlcjogZGF0ZUVudi5jcmVhdGVNYXJrZXIoZGF0ZU9yUmFuZ2UpLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0NIQU5HRV9WSUVXX1RZUEUnLFxuICAgICAgICAgICAgICAgICAgICB2aWV3VHlwZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEZvcmNlcyBuYXZpZ2F0aW9uIHRvIGEgdmlldyBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gICAgLy8gYHZpZXdUeXBlYCBjYW4gYmUgYSBzcGVjaWZpYyB2aWV3IG5hbWUgb3IgYSBnZW5lcmljIG9uZSBsaWtlIFwid2Vla1wiIG9yIFwiZGF5XCIuXG4gICAgLy8gbmVlZHMgdG8gY2hhbmdlXG4gICAgem9vbVRvKGRhdGVNYXJrZXIsIHZpZXdUeXBlKSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgbGV0IHNwZWM7XG4gICAgICAgIHZpZXdUeXBlID0gdmlld1R5cGUgfHwgJ2RheSc7IC8vIGRheSBpcyBkZWZhdWx0IHpvb21cbiAgICAgICAgc3BlYyA9IHN0YXRlLnZpZXdTcGVjc1t2aWV3VHlwZV0gfHwgdGhpcy5nZXRVbml0Vmlld1NwZWModmlld1R5cGUpO1xuICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgIGlmIChzcGVjKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX1ZJRVdfVFlQRScsXG4gICAgICAgICAgICAgICAgdmlld1R5cGU6IHNwZWMudHlwZSxcbiAgICAgICAgICAgICAgICBkYXRlTWFya2VyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX0RBVEUnLFxuICAgICAgICAgICAgICAgIGRhdGVNYXJrZXIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBHaXZlbiBhIGR1cmF0aW9uIHNpbmd1bGFyIHVuaXQsIGxpa2UgXCJ3ZWVrXCIgb3IgXCJkYXlcIiwgZmluZHMgYSBtYXRjaGluZyB2aWV3IHNwZWMuXG4gICAgLy8gUHJlZmVyZW5jZSBpcyBnaXZlbiB0byB2aWV3cyB0aGF0IGhhdmUgY29ycmVzcG9uZGluZyBidXR0b25zLlxuICAgIGdldFVuaXRWaWV3U3BlYyh1bml0KSB7XG4gICAgICAgIGxldCB7IHZpZXdTcGVjcywgdG9vbGJhckNvbmZpZyB9ID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICBsZXQgdmlld1R5cGVzID0gW10uY29uY2F0KHRvb2xiYXJDb25maWcuaGVhZGVyID8gdG9vbGJhckNvbmZpZy5oZWFkZXIudmlld3NXaXRoQnV0dG9ucyA6IFtdLCB0b29sYmFyQ29uZmlnLmZvb3RlciA/IHRvb2xiYXJDb25maWcuZm9vdGVyLnZpZXdzV2l0aEJ1dHRvbnMgOiBbXSk7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBsZXQgc3BlYztcbiAgICAgICAgZm9yIChsZXQgdmlld1R5cGUgaW4gdmlld1NwZWNzKSB7XG4gICAgICAgICAgICB2aWV3VHlwZXMucHVzaCh2aWV3VHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHZpZXdUeXBlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgc3BlYyA9IHZpZXdTcGVjc1t2aWV3VHlwZXNbaV1dO1xuICAgICAgICAgICAgaWYgKHNwZWMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3BlYy5zaW5nbGVVbml0ID09PSB1bml0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzcGVjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gQ3VycmVudCBEYXRlXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBwcmV2KCkge1xuICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnUFJFVicgfSk7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIHRoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdORVhUJyB9KTtcbiAgICB9XG4gICAgcHJldlllYXIoKSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgdGhpcy51bnNlbGVjdCgpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfREFURScsXG4gICAgICAgICAgICBkYXRlTWFya2VyOiBzdGF0ZS5kYXRlRW52LmFkZFllYXJzKHN0YXRlLmN1cnJlbnREYXRlLCAtMSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZXh0WWVhcigpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ0NIQU5HRV9EQVRFJyxcbiAgICAgICAgICAgIGRhdGVNYXJrZXI6IHN0YXRlLmRhdGVFbnYuYWRkWWVhcnMoc3RhdGUuY3VycmVudERhdGUsIDEpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdG9kYXkoKSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgdGhpcy51bnNlbGVjdCgpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfREFURScsXG4gICAgICAgICAgICBkYXRlTWFya2VyOiBnZXROb3coc3RhdGUuY2FsZW5kYXJPcHRpb25zLm5vdywgc3RhdGUuZGF0ZUVudiksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnb3RvRGF0ZSh6b25lZERhdGVJbnB1dCkge1xuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIHRoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX0RBVEUnLFxuICAgICAgICAgICAgZGF0ZU1hcmtlcjogc3RhdGUuZGF0ZUVudi5jcmVhdGVNYXJrZXIoem9uZWREYXRlSW5wdXQpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW5jcmVtZW50RGF0ZShkZWx0YUlucHV0KSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgbGV0IGRlbHRhID0gY3JlYXRlRHVyYXRpb24oZGVsdGFJbnB1dCk7XG4gICAgICAgIGlmIChkZWx0YSkgeyAvLyBlbHNlLCB3YXJuIGFib3V0IGludmFsaWQgaW5wdXQ/XG4gICAgICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX0RBVEUnLFxuICAgICAgICAgICAgICAgIGRhdGVNYXJrZXI6IHN0YXRlLmRhdGVFbnYuYWRkKHN0YXRlLmN1cnJlbnREYXRlLCBkZWx0YSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXREYXRlKCkge1xuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIHJldHVybiBzdGF0ZS5kYXRlRW52LnRvRGF0ZShzdGF0ZS5jdXJyZW50RGF0ZSk7XG4gICAgfVxuICAgIC8vIERhdGUgRm9ybWF0dGluZyBVdGlsc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZm9ybWF0RGF0ZShkLCBmb3JtYXR0ZXIpIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXQoZGF0ZUVudi5jcmVhdGVNYXJrZXIoZCksIGNyZWF0ZUZvcm1hdHRlcihmb3JtYXR0ZXIpKTtcbiAgICB9XG4gICAgLy8gYHNldHRpbmdzYCBpcyBmb3IgZm9ybWF0dGVyIEFORCBpc0VuZEV4Y2x1c2l2ZVxuICAgIGZvcm1hdFJhbmdlKGQwLCBkMSwgc2V0dGluZ3MpIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXRSYW5nZShkYXRlRW52LmNyZWF0ZU1hcmtlcihkMCksIGRhdGVFbnYuY3JlYXRlTWFya2VyKGQxKSwgY3JlYXRlRm9ybWF0dGVyKHNldHRpbmdzKSwgc2V0dGluZ3MpO1xuICAgIH1cbiAgICBmb3JtYXRJc28oZCwgb21pdFRpbWUpIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXRJc28oZGF0ZUVudi5jcmVhdGVNYXJrZXIoZCksIHsgb21pdFRpbWUgfSk7XG4gICAgfVxuICAgIC8vIERhdGUgU2VsZWN0aW9uIC8gRXZlbnQgU2VsZWN0aW9uIC8gRGF5Q2xpY2tcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHNlbGVjdChkYXRlT3JPYmosIGVuZERhdGUpIHtcbiAgICAgICAgbGV0IHNlbGVjdGlvbklucHV0O1xuICAgICAgICBpZiAoZW5kRGF0ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoZGF0ZU9yT2JqLnN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25JbnB1dCA9IGRhdGVPck9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbklucHV0ID0ge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogZGF0ZU9yT2JqLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbklucHV0ID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBkYXRlT3JPYmosXG4gICAgICAgICAgICAgICAgZW5kOiBlbmREYXRlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSBwYXJzZURhdGVTcGFuKHNlbGVjdGlvbklucHV0LCBzdGF0ZS5kYXRlRW52LCBjcmVhdGVEdXJhdGlvbih7IGRheXM6IDEgfSkpO1xuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7IC8vIHRocm93IHBhcnNlIGVycm9yIG90aGVyd2lzZT9cbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnU0VMRUNUX0RBVEVTJywgc2VsZWN0aW9uIH0pO1xuICAgICAgICAgICAgdHJpZ2dlckRhdGVTZWxlY3Qoc2VsZWN0aW9uLCBudWxsLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5zZWxlY3QocGV2KSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgaWYgKHN0YXRlLmRhdGVTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRUxFQ1RfREFURVMnIH0pO1xuICAgICAgICAgICAgdHJpZ2dlckRhdGVVbnNlbGVjdChwZXYsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBQdWJsaWMgRXZlbnRzIEFQSVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgYWRkRXZlbnQoZXZlbnRJbnB1dCwgc291cmNlSW5wdXQpIHtcbiAgICAgICAgaWYgKGV2ZW50SW5wdXQgaW5zdGFuY2VvZiBFdmVudEltcGwpIHtcbiAgICAgICAgICAgIGxldCBkZWYgPSBldmVudElucHV0Ll9kZWY7XG4gICAgICAgICAgICBsZXQgaW5zdGFuY2UgPSBldmVudElucHV0Ll9pbnN0YW5jZTtcbiAgICAgICAgICAgIGxldCBjdXJyZW50RGF0YSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgICAgIC8vIG5vdCBhbHJlYWR5IHByZXNlbnQ/IGRvbid0IHdhbnQgdG8gYWRkIGFuIG9sZCBzbmFwc2hvdFxuICAgICAgICAgICAgaWYgKCFjdXJyZW50RGF0YS5ldmVudFN0b3JlLmRlZnNbZGVmLmRlZklkXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQUREX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IGV2ZW50VHVwbGVUb1N0b3JlKHsgZGVmLCBpbnN0YW5jZSB9KSwgLy8gVE9ETzogYmV0dGVyIHV0aWwgZm9yIHR3byBhcmdzP1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50QWRkKGV2ZW50SW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50SW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICBsZXQgZXZlbnRTb3VyY2U7XG4gICAgICAgIGlmIChzb3VyY2VJbnB1dCBpbnN0YW5jZW9mIEV2ZW50U291cmNlSW1wbCkge1xuICAgICAgICAgICAgZXZlbnRTb3VyY2UgPSBzb3VyY2VJbnB1dC5pbnRlcm5hbEV2ZW50U291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzb3VyY2VJbnB1dCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlSW5wdXQpIHsgLy8gdHJ1ZS4gcGFydCBvZiB0aGUgZmlyc3QgZXZlbnQgc291cmNlXG4gICAgICAgICAgICAgICAgW2V2ZW50U291cmNlXSA9IGhhc2hWYWx1ZXNUb0FycmF5KHN0YXRlLmV2ZW50U291cmNlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc291cmNlSW5wdXQgIT0gbnVsbCkgeyAvLyBhbiBJRC4gYWNjZXB0cyBhIG51bWJlciB0b29cbiAgICAgICAgICAgIGxldCBzb3VyY2VBcGkgPSB0aGlzLmdldEV2ZW50U291cmNlQnlJZChzb3VyY2VJbnB1dCk7IC8vIFRPRE86IHVzZSBhbiBpbnRlcm5hbCBmdW5jdGlvblxuICAgICAgICAgICAgaWYgKCFzb3VyY2VBcGkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYENvdWxkIG5vdCBmaW5kIGFuIGV2ZW50IHNvdXJjZSB3aXRoIElEIFwiJHtzb3VyY2VJbnB1dH1cImApOyAvLyBUT0RPOiB0ZXN0XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldmVudFNvdXJjZSA9IHNvdXJjZUFwaS5pbnRlcm5hbEV2ZW50U291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0dXBsZSA9IHBhcnNlRXZlbnQoZXZlbnRJbnB1dCwgZXZlbnRTb3VyY2UsIHN0YXRlLCBmYWxzZSk7XG4gICAgICAgIGlmICh0dXBsZSkge1xuICAgICAgICAgICAgbGV0IG5ld0V2ZW50QXBpID0gbmV3IEV2ZW50SW1wbChzdGF0ZSwgdHVwbGUuZGVmLCB0dXBsZS5kZWYucmVjdXJyaW5nRGVmID8gbnVsbCA6IHR1cGxlLmluc3RhbmNlKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdBRERfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICBldmVudFN0b3JlOiBldmVudFR1cGxlVG9TdG9yZSh0dXBsZSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50QWRkKG5ld0V2ZW50QXBpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXdFdmVudEFwaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdHJpZ2dlckV2ZW50QWRkKGV2ZW50QXBpKSB7XG4gICAgICAgIGxldCB7IGVtaXR0ZXIgfSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgZW1pdHRlci50cmlnZ2VyKCdldmVudEFkZCcsIHtcbiAgICAgICAgICAgIGV2ZW50OiBldmVudEFwaSxcbiAgICAgICAgICAgIHJlbGF0ZWRFdmVudHM6IFtdLFxuICAgICAgICAgICAgcmV2ZXJ0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdSRU1PVkVfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogZXZlbnRBcGlUb1N0b3JlKGV2ZW50QXBpKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBUT0RPOiBvcHRpbWl6ZVxuICAgIGdldEV2ZW50QnlJZChpZCkge1xuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIGxldCB7IGRlZnMsIGluc3RhbmNlcyB9ID0gc3RhdGUuZXZlbnRTdG9yZTtcbiAgICAgICAgaWQgPSBTdHJpbmcoaWQpO1xuICAgICAgICBmb3IgKGxldCBkZWZJZCBpbiBkZWZzKSB7XG4gICAgICAgICAgICBsZXQgZGVmID0gZGVmc1tkZWZJZF07XG4gICAgICAgICAgICBpZiAoZGVmLnB1YmxpY0lkID09PSBpZCkge1xuICAgICAgICAgICAgICAgIGlmIChkZWYucmVjdXJyaW5nRGVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRJbXBsKHN0YXRlLCBkZWYsIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpbnN0YW5jZUlkIGluIGluc3RhbmNlcykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5zdGFuY2UgPSBpbnN0YW5jZXNbaW5zdGFuY2VJZF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5kZWZJZCA9PT0gZGVmLmRlZklkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50SW1wbChzdGF0ZSwgZGVmLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldEV2ZW50cygpIHtcbiAgICAgICAgbGV0IGN1cnJlbnREYXRhID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICByZXR1cm4gYnVpbGRFdmVudEFwaXMoY3VycmVudERhdGEuZXZlbnRTdG9yZSwgY3VycmVudERhdGEpO1xuICAgIH1cbiAgICByZW1vdmVBbGxFdmVudHMoKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnUkVNT1ZFX0FMTF9FVkVOVFMnIH0pO1xuICAgIH1cbiAgICAvLyBQdWJsaWMgRXZlbnQgU291cmNlcyBBUElcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGdldEV2ZW50U291cmNlcygpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICBsZXQgc291cmNlSGFzaCA9IHN0YXRlLmV2ZW50U291cmNlcztcbiAgICAgICAgbGV0IHNvdXJjZUFwaXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW50ZXJuYWxJZCBpbiBzb3VyY2VIYXNoKSB7XG4gICAgICAgICAgICBzb3VyY2VBcGlzLnB1c2gobmV3IEV2ZW50U291cmNlSW1wbChzdGF0ZSwgc291cmNlSGFzaFtpbnRlcm5hbElkXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzb3VyY2VBcGlzO1xuICAgIH1cbiAgICBnZXRFdmVudFNvdXJjZUJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICBsZXQgc291cmNlSGFzaCA9IHN0YXRlLmV2ZW50U291cmNlcztcbiAgICAgICAgaWQgPSBTdHJpbmcoaWQpO1xuICAgICAgICBmb3IgKGxldCBzb3VyY2VJZCBpbiBzb3VyY2VIYXNoKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlSGFzaFtzb3VyY2VJZF0ucHVibGljSWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudFNvdXJjZUltcGwoc3RhdGUsIHNvdXJjZUhhc2hbc291cmNlSWRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYWRkRXZlbnRTb3VyY2Uoc291cmNlSW5wdXQpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICBpZiAoc291cmNlSW5wdXQgaW5zdGFuY2VvZiBFdmVudFNvdXJjZUltcGwpIHtcbiAgICAgICAgICAgIC8vIG5vdCBhbHJlYWR5IHByZXNlbnQ/IGRvbid0IHdhbnQgdG8gYWRkIGFuIG9sZCBzbmFwc2hvdFxuICAgICAgICAgICAgaWYgKCFzdGF0ZS5ldmVudFNvdXJjZXNbc291cmNlSW5wdXQuaW50ZXJuYWxFdmVudFNvdXJjZS5zb3VyY2VJZF0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0FERF9FVkVOVF9TT1VSQ0VTJyxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlczogW3NvdXJjZUlucHV0LmludGVybmFsRXZlbnRTb3VyY2VdLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZUlucHV0O1xuICAgICAgICB9XG4gICAgICAgIGxldCBldmVudFNvdXJjZSA9IHBhcnNlRXZlbnRTb3VyY2Uoc291cmNlSW5wdXQsIHN0YXRlKTtcbiAgICAgICAgaWYgKGV2ZW50U291cmNlKSB7IC8vIFRPRE86IGVycm9yIG90aGVyd2lzZT9cbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnQUREX0VWRU5UX1NPVVJDRVMnLCBzb3VyY2VzOiBbZXZlbnRTb3VyY2VdIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudFNvdXJjZUltcGwoc3RhdGUsIGV2ZW50U291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmVtb3ZlQWxsRXZlbnRTb3VyY2VzKCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHsgdHlwZTogJ1JFTU9WRV9BTExfRVZFTlRfU09VUkNFUycgfSk7XG4gICAgfVxuICAgIHJlZmV0Y2hFdmVudHMoKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnRkVUQ0hfRVZFTlRfU09VUkNFUycsIGlzUmVmZXRjaDogdHJ1ZSB9KTtcbiAgICB9XG4gICAgLy8gU2Nyb2xsXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBzY3JvbGxUb1RpbWUodGltZUlucHV0KSB7XG4gICAgICAgIGxldCB0aW1lID0gY3JlYXRlRHVyYXRpb24odGltZUlucHV0KTtcbiAgICAgICAgaWYgKHRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignX3Njcm9sbFJlcXVlc3QnLCB7IHRpbWUgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHBvaW50SW5zaWRlUmVjdChwb2ludCwgcmVjdCkge1xuICAgIHJldHVybiBwb2ludC5sZWZ0ID49IHJlY3QubGVmdCAmJlxuICAgICAgICBwb2ludC5sZWZ0IDwgcmVjdC5yaWdodCAmJlxuICAgICAgICBwb2ludC50b3AgPj0gcmVjdC50b3AgJiZcbiAgICAgICAgcG9pbnQudG9wIDwgcmVjdC5ib3R0b207XG59XG4vLyBSZXR1cm5zIGEgbmV3IHJlY3RhbmdsZSB0aGF0IGlzIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhlIHR3byByZWN0YW5nbGVzLiBJZiB0aGV5IGRvbid0IGludGVyc2VjdCwgcmV0dXJucyBmYWxzZVxuZnVuY3Rpb24gaW50ZXJzZWN0UmVjdHMocmVjdDEsIHJlY3QyKSB7XG4gICAgbGV0IHJlcyA9IHtcbiAgICAgICAgbGVmdDogTWF0aC5tYXgocmVjdDEubGVmdCwgcmVjdDIubGVmdCksXG4gICAgICAgIHJpZ2h0OiBNYXRoLm1pbihyZWN0MS5yaWdodCwgcmVjdDIucmlnaHQpLFxuICAgICAgICB0b3A6IE1hdGgubWF4KHJlY3QxLnRvcCwgcmVjdDIudG9wKSxcbiAgICAgICAgYm90dG9tOiBNYXRoLm1pbihyZWN0MS5ib3R0b20sIHJlY3QyLmJvdHRvbSksXG4gICAgfTtcbiAgICBpZiAocmVzLmxlZnQgPCByZXMucmlnaHQgJiYgcmVzLnRvcCA8IHJlcy5ib3R0b20pIHtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gdHJhbnNsYXRlUmVjdChyZWN0LCBkZWx0YVgsIGRlbHRhWSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IHJlY3QubGVmdCArIGRlbHRhWCxcbiAgICAgICAgcmlnaHQ6IHJlY3QucmlnaHQgKyBkZWx0YVgsXG4gICAgICAgIHRvcDogcmVjdC50b3AgKyBkZWx0YVksXG4gICAgICAgIGJvdHRvbTogcmVjdC5ib3R0b20gKyBkZWx0YVksXG4gICAgfTtcbn1cbi8vIFJldHVybnMgYSBuZXcgcG9pbnQgdGhhdCB3aWxsIGhhdmUgYmVlbiBtb3ZlZCB0byByZXNpZGUgd2l0aGluIHRoZSBnaXZlbiByZWN0YW5nbGVcbmZ1bmN0aW9uIGNvbnN0cmFpblBvaW50KHBvaW50LCByZWN0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogTWF0aC5taW4oTWF0aC5tYXgocG9pbnQubGVmdCwgcmVjdC5sZWZ0KSwgcmVjdC5yaWdodCksXG4gICAgICAgIHRvcDogTWF0aC5taW4oTWF0aC5tYXgocG9pbnQudG9wLCByZWN0LnRvcCksIHJlY3QuYm90dG9tKSxcbiAgICB9O1xufVxuLy8gUmV0dXJucyBhIHBvaW50IHRoYXQgaXMgdGhlIGNlbnRlciBvZiB0aGUgZ2l2ZW4gcmVjdGFuZ2xlXG5mdW5jdGlvbiBnZXRSZWN0Q2VudGVyKHJlY3QpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyLFxuICAgICAgICB0b3A6IChyZWN0LnRvcCArIHJlY3QuYm90dG9tKSAvIDIsXG4gICAgfTtcbn1cbi8vIFN1YnRyYWN0cyBwb2ludDIncyBjb29yZGluYXRlcyBmcm9tIHBvaW50MSdzIGNvb3JkaW5hdGVzLCByZXR1cm5pbmcgYSBkZWx0YVxuZnVuY3Rpb24gZGlmZlBvaW50cyhwb2ludDEsIHBvaW50Mikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IHBvaW50MS5sZWZ0IC0gcG9pbnQyLmxlZnQsXG4gICAgICAgIHRvcDogcG9pbnQxLnRvcCAtIHBvaW50Mi50b3AsXG4gICAgfTtcbn1cblxuY29uc3QgRU1QVFlfRVZFTlRfU1RPUkUgPSBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTsgLy8gZm9yIHB1cmVjb21wb25lbnRzLiBUT0RPOiBrZWVwIGVsc2V3aGVyZVxuY2xhc3MgU3BsaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmdldEtleXNGb3JFdmVudERlZnMgPSBtZW1vaXplKHRoaXMuX2dldEtleXNGb3JFdmVudERlZnMpO1xuICAgICAgICB0aGlzLnNwbGl0RGF0ZVNlbGVjdGlvbiA9IG1lbW9pemUodGhpcy5fc3BsaXREYXRlU3Bhbik7XG4gICAgICAgIHRoaXMuc3BsaXRFdmVudFN0b3JlID0gbWVtb2l6ZSh0aGlzLl9zcGxpdEV2ZW50U3RvcmUpO1xuICAgICAgICB0aGlzLnNwbGl0SW5kaXZpZHVhbFVpID0gbWVtb2l6ZSh0aGlzLl9zcGxpdEluZGl2aWR1YWxVaSk7XG4gICAgICAgIHRoaXMuc3BsaXRFdmVudERyYWcgPSBtZW1vaXplKHRoaXMuX3NwbGl0SW50ZXJhY3Rpb24pO1xuICAgICAgICB0aGlzLnNwbGl0RXZlbnRSZXNpemUgPSBtZW1vaXplKHRoaXMuX3NwbGl0SW50ZXJhY3Rpb24pO1xuICAgICAgICB0aGlzLmV2ZW50VWlCdWlsZGVycyA9IHt9OyAvLyBUT0RPOiB0eXBlc2NyaXB0IHByb3RlY3Rpb25cbiAgICB9XG4gICAgc3BsaXRQcm9wcyhwcm9wcykge1xuICAgICAgICBsZXQga2V5SW5mb3MgPSB0aGlzLmdldEtleUluZm8ocHJvcHMpO1xuICAgICAgICBsZXQgZGVmS2V5cyA9IHRoaXMuZ2V0S2V5c0ZvckV2ZW50RGVmcyhwcm9wcy5ldmVudFN0b3JlKTtcbiAgICAgICAgbGV0IGRhdGVTZWxlY3Rpb25zID0gdGhpcy5zcGxpdERhdGVTZWxlY3Rpb24ocHJvcHMuZGF0ZVNlbGVjdGlvbik7XG4gICAgICAgIGxldCBpbmRpdmlkdWFsVWkgPSB0aGlzLnNwbGl0SW5kaXZpZHVhbFVpKHByb3BzLmV2ZW50VWlCYXNlcywgZGVmS2V5cyk7IC8vIHRoZSBpbmRpdmlkdWFsICpiYXNlcypcbiAgICAgICAgbGV0IGV2ZW50U3RvcmVzID0gdGhpcy5zcGxpdEV2ZW50U3RvcmUocHJvcHMuZXZlbnRTdG9yZSwgZGVmS2V5cyk7XG4gICAgICAgIGxldCBldmVudERyYWdzID0gdGhpcy5zcGxpdEV2ZW50RHJhZyhwcm9wcy5ldmVudERyYWcpO1xuICAgICAgICBsZXQgZXZlbnRSZXNpemVzID0gdGhpcy5zcGxpdEV2ZW50UmVzaXplKHByb3BzLmV2ZW50UmVzaXplKTtcbiAgICAgICAgbGV0IHNwbGl0UHJvcHMgPSB7fTtcbiAgICAgICAgdGhpcy5ldmVudFVpQnVpbGRlcnMgPSBtYXBIYXNoKGtleUluZm9zLCAoaW5mbywga2V5KSA9PiB0aGlzLmV2ZW50VWlCdWlsZGVyc1trZXldIHx8IG1lbW9pemUoYnVpbGRFdmVudFVpRm9yS2V5KSk7XG4gICAgICAgIGZvciAobGV0IGtleSBpbiBrZXlJbmZvcykge1xuICAgICAgICAgICAgbGV0IGtleUluZm8gPSBrZXlJbmZvc1trZXldO1xuICAgICAgICAgICAgbGV0IGV2ZW50U3RvcmUgPSBldmVudFN0b3Jlc1trZXldIHx8IEVNUFRZX0VWRU5UX1NUT1JFO1xuICAgICAgICAgICAgbGV0IGJ1aWxkRXZlbnRVaSA9IHRoaXMuZXZlbnRVaUJ1aWxkZXJzW2tleV07XG4gICAgICAgICAgICBzcGxpdFByb3BzW2tleV0gPSB7XG4gICAgICAgICAgICAgICAgYnVzaW5lc3NIb3Vyczoga2V5SW5mby5idXNpbmVzc0hvdXJzIHx8IHByb3BzLmJ1c2luZXNzSG91cnMsXG4gICAgICAgICAgICAgICAgZGF0ZVNlbGVjdGlvbjogZGF0ZVNlbGVjdGlvbnNba2V5XSB8fCBudWxsLFxuICAgICAgICAgICAgICAgIGV2ZW50U3RvcmUsXG4gICAgICAgICAgICAgICAgZXZlbnRVaUJhc2VzOiBidWlsZEV2ZW50VWkocHJvcHMuZXZlbnRVaUJhc2VzWycnXSwga2V5SW5mby51aSwgaW5kaXZpZHVhbFVpW2tleV0pLFxuICAgICAgICAgICAgICAgIGV2ZW50U2VsZWN0aW9uOiBldmVudFN0b3JlLmluc3RhbmNlc1twcm9wcy5ldmVudFNlbGVjdGlvbl0gPyBwcm9wcy5ldmVudFNlbGVjdGlvbiA6ICcnLFxuICAgICAgICAgICAgICAgIGV2ZW50RHJhZzogZXZlbnREcmFnc1trZXldIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgZXZlbnRSZXNpemU6IGV2ZW50UmVzaXplc1trZXldIHx8IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGxpdFByb3BzO1xuICAgIH1cbiAgICBfc3BsaXREYXRlU3BhbihkYXRlU3Bhbikge1xuICAgICAgICBsZXQgZGF0ZVNwYW5zID0ge307XG4gICAgICAgIGlmIChkYXRlU3Bhbikge1xuICAgICAgICAgICAgbGV0IGtleXMgPSB0aGlzLmdldEtleXNGb3JEYXRlU3BhbihkYXRlU3Bhbik7XG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgb2Yga2V5cykge1xuICAgICAgICAgICAgICAgIGRhdGVTcGFuc1trZXldID0gZGF0ZVNwYW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGVTcGFucztcbiAgICB9XG4gICAgX2dldEtleXNGb3JFdmVudERlZnMoZXZlbnRTdG9yZSkge1xuICAgICAgICByZXR1cm4gbWFwSGFzaChldmVudFN0b3JlLmRlZnMsIChldmVudERlZikgPT4gdGhpcy5nZXRLZXlzRm9yRXZlbnREZWYoZXZlbnREZWYpKTtcbiAgICB9XG4gICAgX3NwbGl0RXZlbnRTdG9yZShldmVudFN0b3JlLCBkZWZLZXlzKSB7XG4gICAgICAgIGxldCB7IGRlZnMsIGluc3RhbmNlcyB9ID0gZXZlbnRTdG9yZTtcbiAgICAgICAgbGV0IHNwbGl0U3RvcmVzID0ge307XG4gICAgICAgIGZvciAobGV0IGRlZklkIGluIGRlZnMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBvZiBkZWZLZXlzW2RlZklkXSkge1xuICAgICAgICAgICAgICAgIGlmICghc3BsaXRTdG9yZXNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBzcGxpdFN0b3Jlc1trZXldID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNwbGl0U3RvcmVzW2tleV0uZGVmc1tkZWZJZF0gPSBkZWZzW2RlZklkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpbnN0YW5jZUlkIGluIGluc3RhbmNlcykge1xuICAgICAgICAgICAgbGV0IGluc3RhbmNlID0gaW5zdGFuY2VzW2luc3RhbmNlSWRdO1xuICAgICAgICAgICAgZm9yIChsZXQga2V5IG9mIGRlZktleXNbaW5zdGFuY2UuZGVmSWRdKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNwbGl0U3RvcmVzW2tleV0pIHsgLy8gbXVzdCBoYXZlIGFscmVhZHkgYmVlbiBjcmVhdGVkXG4gICAgICAgICAgICAgICAgICAgIHNwbGl0U3RvcmVzW2tleV0uaW5zdGFuY2VzW2luc3RhbmNlSWRdID0gaW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGxpdFN0b3JlcztcbiAgICB9XG4gICAgX3NwbGl0SW5kaXZpZHVhbFVpKGV2ZW50VWlCYXNlcywgZGVmS2V5cykge1xuICAgICAgICBsZXQgc3BsaXRIYXNoZXMgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgZGVmSWQgaW4gZXZlbnRVaUJhc2VzKSB7XG4gICAgICAgICAgICBpZiAoZGVmSWQpIHsgLy8gbm90IHRoZSAnJyBrZXlcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrZXkgb2YgZGVmS2V5c1tkZWZJZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzcGxpdEhhc2hlc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGxpdEhhc2hlc1trZXldID0ge307XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3BsaXRIYXNoZXNba2V5XVtkZWZJZF0gPSBldmVudFVpQmFzZXNbZGVmSWRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BsaXRIYXNoZXM7XG4gICAgfVxuICAgIF9zcGxpdEludGVyYWN0aW9uKGludGVyYWN0aW9uKSB7XG4gICAgICAgIGxldCBzcGxpdFN0YXRlcyA9IHt9O1xuICAgICAgICBpZiAoaW50ZXJhY3Rpb24pIHtcbiAgICAgICAgICAgIGxldCBhZmZlY3RlZFN0b3JlcyA9IHRoaXMuX3NwbGl0RXZlbnRTdG9yZShpbnRlcmFjdGlvbi5hZmZlY3RlZEV2ZW50cywgdGhpcy5fZ2V0S2V5c0ZvckV2ZW50RGVmcyhpbnRlcmFjdGlvbi5hZmZlY3RlZEV2ZW50cykpO1xuICAgICAgICAgICAgLy8gY2FuJ3QgcmVseSBvbiBkZWZLZXlzIGJlY2F1c2UgZXZlbnQgZGF0YSBpcyBtdXRhdGVkXG4gICAgICAgICAgICBsZXQgbXV0YXRlZEtleXNCeURlZklkID0gdGhpcy5fZ2V0S2V5c0ZvckV2ZW50RGVmcyhpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzKTtcbiAgICAgICAgICAgIGxldCBtdXRhdGVkU3RvcmVzID0gdGhpcy5fc3BsaXRFdmVudFN0b3JlKGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMsIG11dGF0ZWRLZXlzQnlEZWZJZCk7XG4gICAgICAgICAgICBsZXQgcG9wdWxhdGUgPSAoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFzcGxpdFN0YXRlc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwbGl0U3RhdGVzW2tleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZmZlY3RlZEV2ZW50czogYWZmZWN0ZWRTdG9yZXNba2V5XSB8fCBFTVBUWV9FVkVOVF9TVE9SRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0ZWRFdmVudHM6IG11dGF0ZWRTdG9yZXNba2V5XSB8fCBFTVBUWV9FVkVOVF9TVE9SRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRXZlbnQ6IGludGVyYWN0aW9uLmlzRXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBhZmZlY3RlZFN0b3Jlcykge1xuICAgICAgICAgICAgICAgIHBvcHVsYXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gbXV0YXRlZFN0b3Jlcykge1xuICAgICAgICAgICAgICAgIHBvcHVsYXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwbGl0U3RhdGVzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkRXZlbnRVaUZvcktleShhbGxVaSwgZXZlbnRVaUZvcktleSwgaW5kaXZpZHVhbFVpKSB7XG4gICAgbGV0IGJhc2VQYXJ0cyA9IFtdO1xuICAgIGlmIChhbGxVaSkge1xuICAgICAgICBiYXNlUGFydHMucHVzaChhbGxVaSk7XG4gICAgfVxuICAgIGlmIChldmVudFVpRm9yS2V5KSB7XG4gICAgICAgIGJhc2VQYXJ0cy5wdXNoKGV2ZW50VWlGb3JLZXkpO1xuICAgIH1cbiAgICBsZXQgc3R1ZmYgPSB7XG4gICAgICAgICcnOiBjb21iaW5lRXZlbnRVaXMoYmFzZVBhcnRzKSxcbiAgICB9O1xuICAgIGlmIChpbmRpdmlkdWFsVWkpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihzdHVmZiwgaW5kaXZpZHVhbFVpKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0dWZmO1xufVxuXG5mdW5jdGlvbiBnZXREYXRlTWV0YShkYXRlLCB0b2RheVJhbmdlLCBub3dEYXRlLCBkYXRlUHJvZmlsZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGRvdzogZGF0ZS5nZXRVVENEYXkoKSxcbiAgICAgICAgaXNEaXNhYmxlZDogQm9vbGVhbihkYXRlUHJvZmlsZSAmJiAhcmFuZ2VDb250YWluc01hcmtlcihkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgZGF0ZSkpLFxuICAgICAgICBpc090aGVyOiBCb29sZWFuKGRhdGVQcm9maWxlICYmICFyYW5nZUNvbnRhaW5zTWFya2VyKGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZSwgZGF0ZSkpLFxuICAgICAgICBpc1RvZGF5OiBCb29sZWFuKHRvZGF5UmFuZ2UgJiYgcmFuZ2VDb250YWluc01hcmtlcih0b2RheVJhbmdlLCBkYXRlKSksXG4gICAgICAgIGlzUGFzdDogQm9vbGVhbihub3dEYXRlID8gKGRhdGUgPCBub3dEYXRlKSA6IHRvZGF5UmFuZ2UgPyAoZGF0ZSA8IHRvZGF5UmFuZ2Uuc3RhcnQpIDogZmFsc2UpLFxuICAgICAgICBpc0Z1dHVyZTogQm9vbGVhbihub3dEYXRlID8gKGRhdGUgPiBub3dEYXRlKSA6IHRvZGF5UmFuZ2UgPyAoZGF0ZSA+PSB0b2RheVJhbmdlLmVuZCkgOiBmYWxzZSksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldERheUNsYXNzTmFtZXMobWV0YSwgdGhlbWUpIHtcbiAgICBsZXQgY2xhc3NOYW1lcyA9IFtcbiAgICAgICAgJ2ZjLWRheScsXG4gICAgICAgIGBmYy1kYXktJHtEQVlfSURTW21ldGEuZG93XX1gLFxuICAgIF07XG4gICAgaWYgKG1ldGEuaXNEaXNhYmxlZCkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWRheS1kaXNhYmxlZCcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKG1ldGEuaXNUb2RheSkge1xuICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1kYXktdG9kYXknKTtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCh0aGVtZS5nZXRDbGFzcygndG9kYXknKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuaXNQYXN0KSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWRheS1wYXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuaXNGdXR1cmUpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZGF5LWZ1dHVyZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhLmlzT3RoZXIpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZGF5LW90aGVyJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzTmFtZXM7XG59XG5mdW5jdGlvbiBnZXRTbG90Q2xhc3NOYW1lcyhtZXRhLCB0aGVtZSkge1xuICAgIGxldCBjbGFzc05hbWVzID0gW1xuICAgICAgICAnZmMtc2xvdCcsXG4gICAgICAgIGBmYy1zbG90LSR7REFZX0lEU1ttZXRhLmRvd119YCxcbiAgICBdO1xuICAgIGlmIChtZXRhLmlzRGlzYWJsZWQpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1zbG90LWRpc2FibGVkJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAobWV0YS5pc1RvZGF5KSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNsb3QtdG9kYXknKTtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCh0aGVtZS5nZXRDbGFzcygndG9kYXknKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuaXNQYXN0KSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNsb3QtcGFzdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhLmlzRnV0dXJlKSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNsb3QtZnV0dXJlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzTmFtZXM7XG59XG5cbmNvbnN0IERBWV9GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoeyB5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnbG9uZycsIGRheTogJ251bWVyaWMnIH0pO1xuY29uc3QgV0VFS19GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoeyB3ZWVrOiAnbG9uZycgfSk7XG5mdW5jdGlvbiBidWlsZE5hdkxpbmtBdHRycyhjb250ZXh0LCBkYXRlTWFya2VyLCB2aWV3VHlwZSA9ICdkYXknLCBpc1RhYmJhYmxlID0gdHJ1ZSkge1xuICAgIGNvbnN0IHsgZGF0ZUVudiwgb3B0aW9ucywgY2FsZW5kYXJBcGkgfSA9IGNvbnRleHQ7XG4gICAgbGV0IGRhdGVTdHIgPSBkYXRlRW52LmZvcm1hdChkYXRlTWFya2VyLCB2aWV3VHlwZSA9PT0gJ3dlZWsnID8gV0VFS19GT1JNQVQgOiBEQVlfRk9STUFUKTtcbiAgICBpZiAob3B0aW9ucy5uYXZMaW5rcykge1xuICAgICAgICBsZXQgem9uZWREYXRlID0gZGF0ZUVudi50b0RhdGUoZGF0ZU1hcmtlcik7XG4gICAgICAgIGNvbnN0IGhhbmRsZUludGVyYWN0aW9uID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBsZXQgY3VzdG9tQWN0aW9uID0gdmlld1R5cGUgPT09ICdkYXknID8gb3B0aW9ucy5uYXZMaW5rRGF5Q2xpY2sgOlxuICAgICAgICAgICAgICAgIHZpZXdUeXBlID09PSAnd2VlaycgPyBvcHRpb25zLm5hdkxpbmtXZWVrQ2xpY2sgOiBudWxsO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXN0b21BY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjdXN0b21BY3Rpb24uY2FsbChjYWxlbmRhckFwaSwgZGF0ZUVudi50b0RhdGUoZGF0ZU1hcmtlciksIGV2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3VzdG9tQWN0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB2aWV3VHlwZSA9IGN1c3RvbUFjdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsZW5kYXJBcGkuem9vbVRvKGRhdGVNYXJrZXIsIHZpZXdUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyB0aXRsZTogZm9ybWF0V2l0aE9yZGluYWxzKG9wdGlvbnMubmF2TGlua0hpbnQsIFtkYXRlU3RyLCB6b25lZERhdGVdLCBkYXRlU3RyKSwgJ2RhdGEtbmF2bGluayc6ICcnIH0sIChpc1RhYmJhYmxlXG4gICAgICAgICAgICA/IGNyZWF0ZUFyaWFDbGlja0F0dHJzKGhhbmRsZUludGVyYWN0aW9uKVxuICAgICAgICAgICAgOiB7IG9uQ2xpY2s6IGhhbmRsZUludGVyYWN0aW9uIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgJ2FyaWEtbGFiZWwnOiBkYXRlU3RyIH07XG59XG5cbmxldCBfaXNSdGxTY3JvbGxiYXJPbkxlZnQgPSBudWxsO1xuZnVuY3Rpb24gZ2V0SXNSdGxTY3JvbGxiYXJPbkxlZnQoKSB7XG4gICAgaWYgKF9pc1J0bFNjcm9sbGJhck9uTGVmdCA9PT0gbnVsbCkge1xuICAgICAgICBfaXNSdGxTY3JvbGxiYXJPbkxlZnQgPSBjb21wdXRlSXNSdGxTY3JvbGxiYXJPbkxlZnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9pc1J0bFNjcm9sbGJhck9uTGVmdDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVJc1J0bFNjcm9sbGJhck9uTGVmdCgpIHtcbiAgICBsZXQgb3V0ZXJFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGFwcGx5U3R5bGUob3V0ZXJFbCwge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgdG9wOiAtMTAwMCxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgYm9yZGVyOiAwLFxuICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICBvdmVyZmxvdzogJ3Njcm9sbCcsXG4gICAgICAgIGRpcmVjdGlvbjogJ3J0bCcsXG4gICAgfSk7XG4gICAgb3V0ZXJFbC5pbm5lckhUTUwgPSAnPGRpdj48L2Rpdj4nO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQob3V0ZXJFbCk7XG4gICAgbGV0IGlubmVyRWwgPSBvdXRlckVsLmZpcnN0Q2hpbGQ7XG4gICAgbGV0IHJlcyA9IGlubmVyRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCA+IG91dGVyRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcbiAgICByZW1vdmVFbGVtZW50KG91dGVyRWwpO1xuICAgIHJldHVybiByZXM7XG59XG5cbmxldCBfc2Nyb2xsYmFyV2lkdGhzO1xuZnVuY3Rpb24gZ2V0U2Nyb2xsYmFyV2lkdGhzKCkge1xuICAgIGlmICghX3Njcm9sbGJhcldpZHRocykge1xuICAgICAgICBfc2Nyb2xsYmFyV2lkdGhzID0gY29tcHV0ZVNjcm9sbGJhcldpZHRocygpO1xuICAgIH1cbiAgICByZXR1cm4gX3Njcm9sbGJhcldpZHRocztcbn1cbmZ1bmN0aW9uIGNvbXB1dGVTY3JvbGxiYXJXaWR0aHMoKSB7XG4gICAgbGV0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWwuc3R5bGUub3ZlcmZsb3cgPSAnc2Nyb2xsJztcbiAgICBlbC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgZWwuc3R5bGUudG9wID0gJy05OTk5cHgnO1xuICAgIGVsLnN0eWxlLmxlZnQgPSAnLTk5OTlweCc7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbCk7XG4gICAgbGV0IHJlcyA9IGNvbXB1dGVTY3JvbGxiYXJXaWR0aHNGb3JFbChlbCk7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlbCk7XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIFdBUk5JTkc6IHdpbGwgaW5jbHVkZSBib3JkZXJcbmZ1bmN0aW9uIGNvbXB1dGVTY3JvbGxiYXJXaWR0aHNGb3JFbChlbCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGVsLm9mZnNldEhlaWdodCAtIGVsLmNsaWVudEhlaWdodCxcbiAgICAgICAgeTogZWwub2Zmc2V0V2lkdGggLSBlbC5jbGllbnRXaWR0aCxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBjb21wdXRlRWRnZXMoZWwsIGdldFBhZGRpbmcgPSBmYWxzZSkge1xuICAgIGxldCBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgIGxldCBib3JkZXJMZWZ0ID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5ib3JkZXJMZWZ0V2lkdGgsIDEwKSB8fCAwO1xuICAgIGxldCBib3JkZXJSaWdodCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuYm9yZGVyUmlnaHRXaWR0aCwgMTApIHx8IDA7XG4gICAgbGV0IGJvcmRlclRvcCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuYm9yZGVyVG9wV2lkdGgsIDEwKSB8fCAwO1xuICAgIGxldCBib3JkZXJCb3R0b20gPSBwYXJzZUludChjb21wdXRlZFN0eWxlLmJvcmRlckJvdHRvbVdpZHRoLCAxMCkgfHwgMDtcbiAgICBsZXQgYmFkU2Nyb2xsYmFyV2lkdGhzID0gY29tcHV0ZVNjcm9sbGJhcldpZHRoc0ZvckVsKGVsKTsgLy8gaW5jbHVkZXMgYm9yZGVyIVxuICAgIGxldCBzY3JvbGxiYXJMZWZ0UmlnaHQgPSBiYWRTY3JvbGxiYXJXaWR0aHMueSAtIGJvcmRlckxlZnQgLSBib3JkZXJSaWdodDtcbiAgICBsZXQgc2Nyb2xsYmFyQm90dG9tID0gYmFkU2Nyb2xsYmFyV2lkdGhzLnggLSBib3JkZXJUb3AgLSBib3JkZXJCb3R0b207XG4gICAgbGV0IHJlcyA9IHtcbiAgICAgICAgYm9yZGVyTGVmdCxcbiAgICAgICAgYm9yZGVyUmlnaHQsXG4gICAgICAgIGJvcmRlclRvcCxcbiAgICAgICAgYm9yZGVyQm90dG9tLFxuICAgICAgICBzY3JvbGxiYXJCb3R0b20sXG4gICAgICAgIHNjcm9sbGJhckxlZnQ6IDAsXG4gICAgICAgIHNjcm9sbGJhclJpZ2h0OiAwLFxuICAgIH07XG4gICAgaWYgKGdldElzUnRsU2Nyb2xsYmFyT25MZWZ0KCkgJiYgY29tcHV0ZWRTdHlsZS5kaXJlY3Rpb24gPT09ICdydGwnKSB7IC8vIGlzIHRoZSBzY3JvbGxiYXIgb24gdGhlIGxlZnQgc2lkZT9cbiAgICAgICAgcmVzLnNjcm9sbGJhckxlZnQgPSBzY3JvbGxiYXJMZWZ0UmlnaHQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXMuc2Nyb2xsYmFyUmlnaHQgPSBzY3JvbGxiYXJMZWZ0UmlnaHQ7XG4gICAgfVxuICAgIGlmIChnZXRQYWRkaW5nKSB7XG4gICAgICAgIHJlcy5wYWRkaW5nTGVmdCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUucGFkZGluZ0xlZnQsIDEwKSB8fCAwO1xuICAgICAgICByZXMucGFkZGluZ1JpZ2h0ID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nUmlnaHQsIDEwKSB8fCAwO1xuICAgICAgICByZXMucGFkZGluZ1RvcCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUucGFkZGluZ1RvcCwgMTApIHx8IDA7XG4gICAgICAgIHJlcy5wYWRkaW5nQm90dG9tID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nQm90dG9tLCAxMCkgfHwgMDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGNvbXB1dGVJbm5lclJlY3QoZWwsIGdvV2l0aGluUGFkZGluZyA9IGZhbHNlLCBkb0Zyb21XaW5kb3dWaWV3cG9ydCkge1xuICAgIGxldCBvdXRlclJlY3QgPSBkb0Zyb21XaW5kb3dWaWV3cG9ydCA/IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogY29tcHV0ZVJlY3QoZWwpO1xuICAgIGxldCBlZGdlcyA9IGNvbXB1dGVFZGdlcyhlbCwgZ29XaXRoaW5QYWRkaW5nKTtcbiAgICBsZXQgcmVzID0ge1xuICAgICAgICBsZWZ0OiBvdXRlclJlY3QubGVmdCArIGVkZ2VzLmJvcmRlckxlZnQgKyBlZGdlcy5zY3JvbGxiYXJMZWZ0LFxuICAgICAgICByaWdodDogb3V0ZXJSZWN0LnJpZ2h0IC0gZWRnZXMuYm9yZGVyUmlnaHQgLSBlZGdlcy5zY3JvbGxiYXJSaWdodCxcbiAgICAgICAgdG9wOiBvdXRlclJlY3QudG9wICsgZWRnZXMuYm9yZGVyVG9wLFxuICAgICAgICBib3R0b206IG91dGVyUmVjdC5ib3R0b20gLSBlZGdlcy5ib3JkZXJCb3R0b20gLSBlZGdlcy5zY3JvbGxiYXJCb3R0b20sXG4gICAgfTtcbiAgICBpZiAoZ29XaXRoaW5QYWRkaW5nKSB7XG4gICAgICAgIHJlcy5sZWZ0ICs9IGVkZ2VzLnBhZGRpbmdMZWZ0O1xuICAgICAgICByZXMucmlnaHQgLT0gZWRnZXMucGFkZGluZ1JpZ2h0O1xuICAgICAgICByZXMudG9wICs9IGVkZ2VzLnBhZGRpbmdUb3A7XG4gICAgICAgIHJlcy5ib3R0b20gLT0gZWRnZXMucGFkZGluZ0JvdHRvbTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGNvbXB1dGVSZWN0KGVsKSB7XG4gICAgbGV0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiByZWN0LmxlZnQgKyB3aW5kb3cuc2Nyb2xsWCxcbiAgICAgICAgdG9wOiByZWN0LnRvcCArIHdpbmRvdy5zY3JvbGxZLFxuICAgICAgICByaWdodDogcmVjdC5yaWdodCArIHdpbmRvdy5zY3JvbGxYLFxuICAgICAgICBib3R0b206IHJlY3QuYm90dG9tICsgd2luZG93LnNjcm9sbFksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVDbGlwcGVkQ2xpZW50UmVjdChlbCkge1xuICAgIGxldCBjbGlwcGluZ1BhcmVudHMgPSBnZXRDbGlwcGluZ1BhcmVudHMoZWwpO1xuICAgIGxldCByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgZm9yIChsZXQgY2xpcHBpbmdQYXJlbnQgb2YgY2xpcHBpbmdQYXJlbnRzKSB7XG4gICAgICAgIGxldCBpbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3RSZWN0cyhyZWN0LCBjbGlwcGluZ1BhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG4gICAgICAgIGlmIChpbnRlcnNlY3Rpb24pIHtcbiAgICAgICAgICAgIHJlY3QgPSBpbnRlcnNlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVjdDtcbn1cbi8vIGRvZXMgbm90IHJldHVybiB3aW5kb3dcbmZ1bmN0aW9uIGdldENsaXBwaW5nUGFyZW50cyhlbCkge1xuICAgIGxldCBwYXJlbnRzID0gW107XG4gICAgd2hpbGUgKGVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHsgLy8gd2lsbCBzdG9wIHdoZW4gZ2V0cyB0byBkb2N1bWVudCBvciBudWxsXG4gICAgICAgIGxldCBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgICAgICBpZiAoY29tcHV0ZWRTdHlsZS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgvKGF1dG98c2Nyb2xsKS8pLnRlc3QoY29tcHV0ZWRTdHlsZS5vdmVyZmxvdyArIGNvbXB1dGVkU3R5bGUub3ZlcmZsb3dZICsgY29tcHV0ZWRTdHlsZS5vdmVyZmxvd1gpKSB7XG4gICAgICAgICAgICBwYXJlbnRzLnB1c2goZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsID0gZWwucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudHM7XG59XG5cbi8qXG5SZWNvcmRzIG9mZnNldCBpbmZvcm1hdGlvbiBmb3IgYSBzZXQgb2YgZWxlbWVudHMsIHJlbGF0aXZlIHRvIGFuIG9yaWdpbiBlbGVtZW50LlxuQ2FuIHJlY29yZCB0aGUgbGVmdC9yaWdodCBPUiB0aGUgdG9wL2JvdHRvbSBPUiBib3RoLlxuUHJvdmlkZXMgbWV0aG9kcyBmb3IgcXVlcnlpbmcgdGhlIGNhY2hlIGJ5IHBvc2l0aW9uLlxuKi9cbmNsYXNzIFBvc2l0aW9uQ2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKG9yaWdpbkVsLCBlbHMsIGlzSG9yaXpvbnRhbCwgaXNWZXJ0aWNhbCkge1xuICAgICAgICB0aGlzLmVscyA9IGVscztcbiAgICAgICAgbGV0IG9yaWdpbkNsaWVudFJlY3QgPSB0aGlzLm9yaWdpbkNsaWVudFJlY3QgPSBvcmlnaW5FbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgLy8gcmVsYXRpdmUgdG8gdmlld3BvcnQgdG9wLWxlZnRcbiAgICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgdGhpcy5idWlsZEVsSG9yaXpvbnRhbHMob3JpZ2luQ2xpZW50UmVjdC5sZWZ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNWZXJ0aWNhbCkge1xuICAgICAgICAgICAgdGhpcy5idWlsZEVsVmVydGljYWxzKG9yaWdpbkNsaWVudFJlY3QudG9wKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBQb3B1bGF0ZXMgdGhlIGxlZnQvcmlnaHQgaW50ZXJuYWwgY29vcmRpbmF0ZSBhcnJheXNcbiAgICBidWlsZEVsSG9yaXpvbnRhbHMob3JpZ2luQ2xpZW50TGVmdCkge1xuICAgICAgICBsZXQgbGVmdHMgPSBbXTtcbiAgICAgICAgbGV0IHJpZ2h0cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBlbCBvZiB0aGlzLmVscykge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGxlZnRzLnB1c2gocmVjdC5sZWZ0IC0gb3JpZ2luQ2xpZW50TGVmdCk7XG4gICAgICAgICAgICByaWdodHMucHVzaChyZWN0LnJpZ2h0IC0gb3JpZ2luQ2xpZW50TGVmdCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZWZ0cyA9IGxlZnRzO1xuICAgICAgICB0aGlzLnJpZ2h0cyA9IHJpZ2h0cztcbiAgICB9XG4gICAgLy8gUG9wdWxhdGVzIHRoZSB0b3AvYm90dG9tIGludGVybmFsIGNvb3JkaW5hdGUgYXJyYXlzXG4gICAgYnVpbGRFbFZlcnRpY2FscyhvcmlnaW5DbGllbnRUb3ApIHtcbiAgICAgICAgbGV0IHRvcHMgPSBbXTtcbiAgICAgICAgbGV0IGJvdHRvbXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZWwgb2YgdGhpcy5lbHMpIHtcbiAgICAgICAgICAgIGxldCByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB0b3BzLnB1c2gocmVjdC50b3AgLSBvcmlnaW5DbGllbnRUb3ApO1xuICAgICAgICAgICAgYm90dG9tcy5wdXNoKHJlY3QuYm90dG9tIC0gb3JpZ2luQ2xpZW50VG9wKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvcHMgPSB0b3BzO1xuICAgICAgICB0aGlzLmJvdHRvbXMgPSBib3R0b21zO1xuICAgIH1cbiAgICAvLyBHaXZlbiBhIGxlZnQgb2Zmc2V0IChmcm9tIGRvY3VtZW50IGxlZnQpLCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZWwgdGhhdCBpdCBob3Jpem9udGFsbHkgaW50ZXJzZWN0cy5cbiAgICAvLyBJZiBubyBpbnRlcnNlY3Rpb24gaXMgbWFkZSwgcmV0dXJucyB1bmRlZmluZWQuXG4gICAgbGVmdFRvSW5kZXgobGVmdFBvc2l0aW9uKSB7XG4gICAgICAgIGxldCB7IGxlZnRzLCByaWdodHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBsZW4gPSBsZWZ0cy5sZW5ndGg7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChsZWZ0UG9zaXRpb24gPj0gbGVmdHNbaV0gJiYgbGVmdFBvc2l0aW9uIDwgcmlnaHRzW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDsgLy8gVE9ETzogYmV0dGVyXG4gICAgfVxuICAgIC8vIEdpdmVuIGEgdG9wIG9mZnNldCAoZnJvbSBkb2N1bWVudCB0b3ApLCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZWwgdGhhdCBpdCB2ZXJ0aWNhbGx5IGludGVyc2VjdHMuXG4gICAgLy8gSWYgbm8gaW50ZXJzZWN0aW9uIGlzIG1hZGUsIHJldHVybnMgdW5kZWZpbmVkLlxuICAgIHRvcFRvSW5kZXgodG9wUG9zaXRpb24pIHtcbiAgICAgICAgbGV0IHsgdG9wcywgYm90dG9tcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGxlbiA9IHRvcHMubGVuZ3RoO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAodG9wUG9zaXRpb24gPj0gdG9wc1tpXSAmJiB0b3BQb3NpdGlvbiA8IGJvdHRvbXNbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkOyAvLyBUT0RPOiBiZXR0ZXJcbiAgICB9XG4gICAgLy8gR2V0cyB0aGUgd2lkdGggb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4XG4gICAgZ2V0V2lkdGgobGVmdEluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJpZ2h0c1tsZWZ0SW5kZXhdIC0gdGhpcy5sZWZ0c1tsZWZ0SW5kZXhdO1xuICAgIH1cbiAgICAvLyBHZXRzIHRoZSBoZWlnaHQgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4XG4gICAgZ2V0SGVpZ2h0KHRvcEluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvdHRvbXNbdG9wSW5kZXhdIC0gdGhpcy50b3BzW3RvcEluZGV4XTtcbiAgICB9XG4gICAgc2ltaWxhclRvKG90aGVyQ2FjaGUpIHtcbiAgICAgICAgcmV0dXJuIHNpbWlsYXJOdW1BcnJheXModGhpcy50b3BzIHx8IFtdLCBvdGhlckNhY2hlLnRvcHMgfHwgW10pICYmXG4gICAgICAgICAgICBzaW1pbGFyTnVtQXJyYXlzKHRoaXMuYm90dG9tcyB8fCBbXSwgb3RoZXJDYWNoZS5ib3R0b21zIHx8IFtdKSAmJlxuICAgICAgICAgICAgc2ltaWxhck51bUFycmF5cyh0aGlzLmxlZnRzIHx8IFtdLCBvdGhlckNhY2hlLmxlZnRzIHx8IFtdKSAmJlxuICAgICAgICAgICAgc2ltaWxhck51bUFycmF5cyh0aGlzLnJpZ2h0cyB8fCBbXSwgb3RoZXJDYWNoZS5yaWdodHMgfHwgW10pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNpbWlsYXJOdW1BcnJheXMoYSwgYikge1xuICAgIGNvbnN0IGxlbiA9IGEubGVuZ3RoO1xuICAgIGlmIChsZW4gIT09IGIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoTWF0aC5yb3VuZChhW2ldKSAhPT0gTWF0aC5yb3VuZChiW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vKiBlc2xpbnQgbWF4LWNsYXNzZXMtcGVyLWZpbGU6IFwib2ZmXCIgKi9cbi8qXG5BbiBvYmplY3QgZm9yIGdldHRpbmcvc2V0dGluZyBzY3JvbGwtcmVsYXRlZCBpbmZvcm1hdGlvbiBmb3IgYW4gZWxlbWVudC5cbkludGVybmFsbHksIHRoaXMgaXMgZG9uZSB2ZXJ5IGRpZmZlcmVudGx5IGZvciB3aW5kb3cgdmVyc3VzIERPTSBlbGVtZW50LFxuc28gdGhpcyBvYmplY3Qgc2VydmVzIGFzIGEgY29tbW9uIGludGVyZmFjZS5cbiovXG5jbGFzcyBTY3JvbGxDb250cm9sbGVyIHtcbiAgICBnZXRNYXhTY3JvbGxUb3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNjcm9sbEhlaWdodCgpIC0gdGhpcy5nZXRDbGllbnRIZWlnaHQoKTtcbiAgICB9XG4gICAgZ2V0TWF4U2Nyb2xsTGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2Nyb2xsV2lkdGgoKSAtIHRoaXMuZ2V0Q2xpZW50V2lkdGgoKTtcbiAgICB9XG4gICAgY2FuU2Nyb2xsVmVydGljYWxseSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWF4U2Nyb2xsVG9wKCkgPiAwO1xuICAgIH1cbiAgICBjYW5TY3JvbGxIb3Jpem9udGFsbHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1heFNjcm9sbExlZnQoKSA+IDA7XG4gICAgfVxuICAgIGNhblNjcm9sbFVwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTY3JvbGxUb3AoKSA+IDA7XG4gICAgfVxuICAgIGNhblNjcm9sbERvd24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNjcm9sbFRvcCgpIDwgdGhpcy5nZXRNYXhTY3JvbGxUb3AoKTtcbiAgICB9XG4gICAgY2FuU2Nyb2xsTGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2Nyb2xsTGVmdCgpID4gMDtcbiAgICB9XG4gICAgY2FuU2Nyb2xsUmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNjcm9sbExlZnQoKSA8IHRoaXMuZ2V0TWF4U2Nyb2xsTGVmdCgpO1xuICAgIH1cbn1cbmNsYXNzIEVsZW1lbnRTY3JvbGxDb250cm9sbGVyIGV4dGVuZHMgU2Nyb2xsQ29udHJvbGxlciB7XG4gICAgY29uc3RydWN0b3IoZWwpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgIH1cbiAgICBnZXRTY3JvbGxUb3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnNjcm9sbFRvcDtcbiAgICB9XG4gICAgZ2V0U2Nyb2xsTGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuc2Nyb2xsTGVmdDtcbiAgICB9XG4gICAgc2V0U2Nyb2xsVG9wKHRvcCkge1xuICAgICAgICB0aGlzLmVsLnNjcm9sbFRvcCA9IHRvcDtcbiAgICB9XG4gICAgc2V0U2Nyb2xsTGVmdChsZWZ0KSB7XG4gICAgICAgIHRoaXMuZWwuc2Nyb2xsTGVmdCA9IGxlZnQ7XG4gICAgfVxuICAgIGdldFNjcm9sbFdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zY3JvbGxXaWR0aDtcbiAgICB9XG4gICAgZ2V0U2Nyb2xsSGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zY3JvbGxIZWlnaHQ7XG4gICAgfVxuICAgIGdldENsaWVudEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuY2xpZW50SGVpZ2h0O1xuICAgIH1cbiAgICBnZXRDbGllbnRXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuY2xpZW50V2lkdGg7XG4gICAgfVxufVxuY2xhc3MgV2luZG93U2Nyb2xsQ29udHJvbGxlciBleHRlbmRzIFNjcm9sbENvbnRyb2xsZXIge1xuICAgIGdldFNjcm9sbFRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5zY3JvbGxZO1xuICAgIH1cbiAgICBnZXRTY3JvbGxMZWZ0KCkge1xuICAgICAgICByZXR1cm4gd2luZG93LnNjcm9sbFg7XG4gICAgfVxuICAgIHNldFNjcm9sbFRvcChuKSB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGwod2luZG93LnNjcm9sbFgsIG4pO1xuICAgIH1cbiAgICBzZXRTY3JvbGxMZWZ0KG4pIHtcbiAgICAgICAgd2luZG93LnNjcm9sbChuLCB3aW5kb3cuc2Nyb2xsWSk7XG4gICAgfVxuICAgIGdldFNjcm9sbFdpZHRoKCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFdpZHRoO1xuICAgIH1cbiAgICBnZXRTY3JvbGxIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0O1xuICAgIH1cbiAgICBnZXRDbGllbnRIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgIH1cbiAgICBnZXRDbGllbnRXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICB9XG59XG5cbi8qXG5hbiBJTlRFUkFDVEFCTEUgZGF0ZSBjb21wb25lbnRcblxuUFVSUE9TRVM6XG4tIGhvb2sgdXAgdG8gZmcsIGZpbGwsIGFuZCBtaXJyb3IgcmVuZGVyZXJzXG4tIGludGVyZmFjZSBmb3IgZHJhZ2dpbmcgYW5kIGhpdHNcbiovXG5jbGFzcyBEYXRlQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudWlkID0gZ3VpZCgpO1xuICAgIH1cbiAgICAvLyBIaXQgU3lzdGVtXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBwcmVwYXJlSGl0cygpIHtcbiAgICB9XG4gICAgcXVlcnlIaXQocG9zaXRpb25MZWZ0LCBwb3NpdGlvblRvcCwgZWxXaWR0aCwgZWxIZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7IC8vIHRoaXMgc2hvdWxkIGJlIGFic3RyYWN0XG4gICAgfVxuICAgIC8vIFBvaW50ZXIgSW50ZXJhY3Rpb24gVXRpbHNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGlzVmFsaWRTZWdEb3duRWwoZWwpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLnByb3BzLmV2ZW50RHJhZyAmJiAvLyBIQUNLXG4gICAgICAgICAgICAhdGhpcy5wcm9wcy5ldmVudFJlc2l6ZSAmJiAvLyBIQUNLXG4gICAgICAgICAgICAhZWxlbWVudENsb3Nlc3QoZWwsICcuZmMtZXZlbnQtbWlycm9yJyk7XG4gICAgfVxuICAgIGlzVmFsaWREYXRlRG93bkVsKGVsKSB7XG4gICAgICAgIHJldHVybiAhZWxlbWVudENsb3Nlc3QoZWwsICcuZmMtZXZlbnQ6bm90KC5mYy1iZy1ldmVudCknKSAmJlxuICAgICAgICAgICAgIWVsZW1lbnRDbG9zZXN0KGVsLCAnLmZjLW1vcmUtbGluaycpICYmIC8vIGEgXCJtb3JlLi5cIiBsaW5rXG4gICAgICAgICAgICAhZWxlbWVudENsb3Nlc3QoZWwsICdhW2RhdGEtbmF2bGlua10nKSAmJiAvLyBhIGNsaWNrYWJsZSBuYXYgbGlua1xuICAgICAgICAgICAgIWVsZW1lbnRDbG9zZXN0KGVsLCAnLmZjLXBvcG92ZXInKTsgLy8gaGFja1xuICAgIH1cbn1cblxuY2xhc3MgTmFtZWRUaW1lWm9uZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKHRpbWVab25lTmFtZSkge1xuICAgICAgICB0aGlzLnRpbWVab25lTmFtZSA9IHRpbWVab25lTmFtZTtcbiAgICB9XG59XG5cbmNsYXNzIFNlZ0hpZXJhcmNoeSB7XG4gICAgY29uc3RydWN0b3IoZ2V0RW50cnlUaGlja25lc3MgPSAoZW50cnkpID0+IHtcbiAgICAgICAgLy8gaWYgbm8gdGhpY2tuZXNzIGtub3duLCBhc3N1bWUgMSAoaWYgMCwgc28gc21hbGwgaXQgYWx3YXlzIGZpdHMpXG4gICAgICAgIHJldHVybiBlbnRyeS50aGlja25lc3MgfHwgMTtcbiAgICB9KSB7XG4gICAgICAgIHRoaXMuZ2V0RW50cnlUaGlja25lc3MgPSBnZXRFbnRyeVRoaWNrbmVzcztcbiAgICAgICAgLy8gc2V0dGluZ3NcbiAgICAgICAgdGhpcy5zdHJpY3RPcmRlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFsbG93UmVzbGljaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWF4Q29vcmQgPSAtMTsgLy8gLTEgbWVhbnMgbm8gbWF4XG4gICAgICAgIHRoaXMubWF4U3RhY2tDbnQgPSAtMTsgLy8gLTEgbWVhbnMgbm8gbWF4XG4gICAgICAgIHRoaXMubGV2ZWxDb29yZHMgPSBbXTsgLy8gb3JkZXJlZFxuICAgICAgICB0aGlzLmVudHJpZXNCeUxldmVsID0gW107IC8vIHBhcmFsbGVsIHdpdGggbGV2ZWxDb29yZHNcbiAgICAgICAgdGhpcy5zdGFja0NudHMgPSB7fTsgLy8gVE9ETzogdXNlIGJldHRlciB0ZWNobmlxdWUhP1xuICAgIH1cbiAgICBhZGRTZWdzKGlucHV0cykge1xuICAgICAgICBsZXQgaGlkZGVuRW50cmllcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpbnB1dCBvZiBpbnB1dHMpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0RW50cnkoaW5wdXQsIGhpZGRlbkVudHJpZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoaWRkZW5FbnRyaWVzO1xuICAgIH1cbiAgICBpbnNlcnRFbnRyeShlbnRyeSwgaGlkZGVuRW50cmllcykge1xuICAgICAgICBsZXQgaW5zZXJ0aW9uID0gdGhpcy5maW5kSW5zZXJ0aW9uKGVudHJ5KTtcbiAgICAgICAgaWYgKHRoaXMuaXNJbnNlcnRpb25WYWxpZChpbnNlcnRpb24sIGVudHJ5KSkge1xuICAgICAgICAgICAgdGhpcy5pbnNlcnRFbnRyeUF0KGVudHJ5LCBpbnNlcnRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVJbnZhbGlkSW5zZXJ0aW9uKGluc2VydGlvbiwgZW50cnksIGhpZGRlbkVudHJpZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzSW5zZXJ0aW9uVmFsaWQoaW5zZXJ0aW9uLCBlbnRyeSkge1xuICAgICAgICByZXR1cm4gKHRoaXMubWF4Q29vcmQgPT09IC0xIHx8IGluc2VydGlvbi5sZXZlbENvb3JkICsgdGhpcy5nZXRFbnRyeVRoaWNrbmVzcyhlbnRyeSkgPD0gdGhpcy5tYXhDb29yZCkgJiZcbiAgICAgICAgICAgICh0aGlzLm1heFN0YWNrQ250ID09PSAtMSB8fCBpbnNlcnRpb24uc3RhY2tDbnQgPCB0aGlzLm1heFN0YWNrQ250KTtcbiAgICB9XG4gICAgaGFuZGxlSW52YWxpZEluc2VydGlvbihpbnNlcnRpb24sIGVudHJ5LCBoaWRkZW5FbnRyaWVzKSB7XG4gICAgICAgIGlmICh0aGlzLmFsbG93UmVzbGljaW5nICYmIGluc2VydGlvbi50b3VjaGluZ0VudHJ5KSB7XG4gICAgICAgICAgICBjb25zdCBoaWRkZW5FbnRyeSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZW50cnkpLCB7IHNwYW46IGludGVyc2VjdFNwYW5zKGVudHJ5LnNwYW4sIGluc2VydGlvbi50b3VjaGluZ0VudHJ5LnNwYW4pIH0pO1xuICAgICAgICAgICAgaGlkZGVuRW50cmllcy5wdXNoKGhpZGRlbkVudHJ5KTtcbiAgICAgICAgICAgIHRoaXMuc3BsaXRFbnRyeShlbnRyeSwgaW5zZXJ0aW9uLnRvdWNoaW5nRW50cnksIGhpZGRlbkVudHJpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGlkZGVuRW50cmllcy5wdXNoKGVudHJ5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKlxuICAgIERvZXMgTk9UIGFkZCB3aGF0IGhpdCB0aGUgYGJhcnJpZXJgIGludG8gaGlkZGVuRW50cmllcy4gU2hvdWxkIGFscmVhZHkgYmUgZG9uZS5cbiAgICAqL1xuICAgIHNwbGl0RW50cnkoZW50cnksIGJhcnJpZXIsIGhpZGRlbkVudHJpZXMpIHtcbiAgICAgICAgbGV0IGVudHJ5U3BhbiA9IGVudHJ5LnNwYW47XG4gICAgICAgIGxldCBiYXJyaWVyU3BhbiA9IGJhcnJpZXIuc3BhbjtcbiAgICAgICAgaWYgKGVudHJ5U3Bhbi5zdGFydCA8IGJhcnJpZXJTcGFuLnN0YXJ0KSB7XG4gICAgICAgICAgICB0aGlzLmluc2VydEVudHJ5KHtcbiAgICAgICAgICAgICAgICBpbmRleDogZW50cnkuaW5kZXgsXG4gICAgICAgICAgICAgICAgdGhpY2tuZXNzOiBlbnRyeS50aGlja25lc3MsXG4gICAgICAgICAgICAgICAgc3BhbjogeyBzdGFydDogZW50cnlTcGFuLnN0YXJ0LCBlbmQ6IGJhcnJpZXJTcGFuLnN0YXJ0IH0sXG4gICAgICAgICAgICB9LCBoaWRkZW5FbnRyaWVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW50cnlTcGFuLmVuZCA+IGJhcnJpZXJTcGFuLmVuZCkge1xuICAgICAgICAgICAgdGhpcy5pbnNlcnRFbnRyeSh7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGVudHJ5LmluZGV4LFxuICAgICAgICAgICAgICAgIHRoaWNrbmVzczogZW50cnkudGhpY2tuZXNzLFxuICAgICAgICAgICAgICAgIHNwYW46IHsgc3RhcnQ6IGJhcnJpZXJTcGFuLmVuZCwgZW5kOiBlbnRyeVNwYW4uZW5kIH0sXG4gICAgICAgICAgICB9LCBoaWRkZW5FbnRyaWVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbnNlcnRFbnRyeUF0KGVudHJ5LCBpbnNlcnRpb24pIHtcbiAgICAgICAgbGV0IHsgZW50cmllc0J5TGV2ZWwsIGxldmVsQ29vcmRzIH0gPSB0aGlzO1xuICAgICAgICBpZiAoaW5zZXJ0aW9uLmxhdGVyYWwgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgYSBuZXcgbGV2ZWxcbiAgICAgICAgICAgIGluc2VydEF0KGxldmVsQ29vcmRzLCBpbnNlcnRpb24ubGV2ZWwsIGluc2VydGlvbi5sZXZlbENvb3JkKTtcbiAgICAgICAgICAgIGluc2VydEF0KGVudHJpZXNCeUxldmVsLCBpbnNlcnRpb24ubGV2ZWwsIFtlbnRyeV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaW5zZXJ0IGludG8gZXhpc3RpbmcgbGV2ZWxcbiAgICAgICAgICAgIGluc2VydEF0KGVudHJpZXNCeUxldmVsW2luc2VydGlvbi5sZXZlbF0sIGluc2VydGlvbi5sYXRlcmFsLCBlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFja0NudHNbYnVpbGRFbnRyeUtleShlbnRyeSldID0gaW5zZXJ0aW9uLnN0YWNrQ250O1xuICAgIH1cbiAgICAvKlxuICAgIGRvZXMgbm90IGNhcmUgYWJvdXQgbGltaXRzXG4gICAgKi9cbiAgICBmaW5kSW5zZXJ0aW9uKG5ld0VudHJ5KSB7XG4gICAgICAgIGxldCB7IGxldmVsQ29vcmRzLCBlbnRyaWVzQnlMZXZlbCwgc3RyaWN0T3JkZXIsIHN0YWNrQ250cyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGxldmVsQ250ID0gbGV2ZWxDb29yZHMubGVuZ3RoO1xuICAgICAgICBsZXQgY2FuZGlkYXRlQ29vcmQgPSAwO1xuICAgICAgICBsZXQgdG91Y2hpbmdMZXZlbCA9IC0xO1xuICAgICAgICBsZXQgdG91Y2hpbmdMYXRlcmFsID0gLTE7XG4gICAgICAgIGxldCB0b3VjaGluZ0VudHJ5ID0gbnVsbDtcbiAgICAgICAgbGV0IHN0YWNrQ250ID0gMDtcbiAgICAgICAgZm9yIChsZXQgdHJhY2tpbmdMZXZlbCA9IDA7IHRyYWNraW5nTGV2ZWwgPCBsZXZlbENudDsgdHJhY2tpbmdMZXZlbCArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCB0cmFja2luZ0Nvb3JkID0gbGV2ZWxDb29yZHNbdHJhY2tpbmdMZXZlbF07XG4gICAgICAgICAgICAvLyBpZiB0aGUgY3VycmVudCBsZXZlbCBpcyBwYXN0IHRoZSBwbGFjZWQgZW50cnksIHdlIGhhdmUgZm91bmQgYSBnb29kIGVtcHR5IHNwYWNlIGFuZCBjYW4gc3RvcC5cbiAgICAgICAgICAgIC8vIGlmIHN0cmljdE9yZGVyLCBrZWVwIGZpbmRpbmcgbW9yZSBsYXRlcmFsIGludGVyc2VjdGlvbnMuXG4gICAgICAgICAgICBpZiAoIXN0cmljdE9yZGVyICYmIHRyYWNraW5nQ29vcmQgPj0gY2FuZGlkYXRlQ29vcmQgKyB0aGlzLmdldEVudHJ5VGhpY2tuZXNzKG5ld0VudHJ5KSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRyYWNraW5nRW50cmllcyA9IGVudHJpZXNCeUxldmVsW3RyYWNraW5nTGV2ZWxdO1xuICAgICAgICAgICAgbGV0IHRyYWNraW5nRW50cnk7XG4gICAgICAgICAgICBsZXQgc2VhcmNoUmVzID0gYmluYXJ5U2VhcmNoKHRyYWNraW5nRW50cmllcywgbmV3RW50cnkuc3Bhbi5zdGFydCwgZ2V0RW50cnlTcGFuRW5kKTsgLy8gZmluZCBmaXJzdCBlbnRyeSBhZnRlciBuZXdFbnRyeSdzIGVuZFxuICAgICAgICAgICAgbGV0IGxhdGVyYWxJbmRleCA9IHNlYXJjaFJlc1swXSArIHNlYXJjaFJlc1sxXTsgLy8gaWYgZXhhY3QgbWF0Y2ggKHdoaWNoIGRvZXNuJ3QgY29sbGlkZSksIGdvIHRvIG5leHQgb25lXG4gICAgICAgICAgICB3aGlsZSAoIC8vIGxvb3AgdGhyb3VnaCBlbnRyaWVzIHRoYXQgaG9yaXpvbnRhbGx5IGludGVyc2VjdFxuICAgICAgICAgICAgKHRyYWNraW5nRW50cnkgPSB0cmFja2luZ0VudHJpZXNbbGF0ZXJhbEluZGV4XSkgJiYgLy8gYnV0IG5vdCBwYXN0IHRoZSB3aG9sZSBlbnRyeSBsaXN0XG4gICAgICAgICAgICAgICAgdHJhY2tpbmdFbnRyeS5zcGFuLnN0YXJ0IDwgbmV3RW50cnkuc3Bhbi5lbmQgLy8gYW5kIG5vdCBlbnRpcmVseSBwYXN0IG5ld0VudHJ5XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBsZXQgdHJhY2tpbmdFbnRyeUJvdHRvbSA9IHRyYWNraW5nQ29vcmQgKyB0aGlzLmdldEVudHJ5VGhpY2tuZXNzKHRyYWNraW5nRW50cnkpO1xuICAgICAgICAgICAgICAgIC8vIGludGVyc2VjdHMgaW50byB0aGUgdG9wIG9mIHRoZSBjYW5kaWRhdGU/XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNraW5nRW50cnlCb3R0b20gPiBjYW5kaWRhdGVDb29yZCkge1xuICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGVDb29yZCA9IHRyYWNraW5nRW50cnlCb3R0b207XG4gICAgICAgICAgICAgICAgICAgIHRvdWNoaW5nRW50cnkgPSB0cmFja2luZ0VudHJ5O1xuICAgICAgICAgICAgICAgICAgICB0b3VjaGluZ0xldmVsID0gdHJhY2tpbmdMZXZlbDtcbiAgICAgICAgICAgICAgICAgICAgdG91Y2hpbmdMYXRlcmFsID0gbGF0ZXJhbEluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBidXR0cyB1cCBhZ2FpbnN0IHRvcCBvZiBjYW5kaWRhdGU/ICh3aWxsIGhhcHBlbiBpZiBqdXN0IGludGVyc2VjdGVkIGFzIHdlbGwpXG4gICAgICAgICAgICAgICAgaWYgKHRyYWNraW5nRW50cnlCb3R0b20gPT09IGNhbmRpZGF0ZUNvb3JkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFjY3VtdWxhdGUgdGhlIGhpZ2hlc3QgcG9zc2libGUgc3RhY2tDbnQgb2YgdGhlIHRyYWNraW5nRW50cmllcyB0aGF0IGJ1dHQgdXBcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tDbnQgPSBNYXRoLm1heChzdGFja0NudCwgc3RhY2tDbnRzW2J1aWxkRW50cnlLZXkodHJhY2tpbmdFbnRyeSldICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhdGVyYWxJbmRleCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSBkZXN0aW5hdGlvbiBsZXZlbCB3aWxsIGJlIGFmdGVyIHRvdWNoaW5nRW50cnkncyBsZXZlbC4gZmluZCBpdFxuICAgICAgICBsZXQgZGVzdExldmVsID0gMDtcbiAgICAgICAgaWYgKHRvdWNoaW5nRW50cnkpIHtcbiAgICAgICAgICAgIGRlc3RMZXZlbCA9IHRvdWNoaW5nTGV2ZWwgKyAxO1xuICAgICAgICAgICAgd2hpbGUgKGRlc3RMZXZlbCA8IGxldmVsQ250ICYmIGxldmVsQ29vcmRzW2Rlc3RMZXZlbF0gPCBjYW5kaWRhdGVDb29yZCkge1xuICAgICAgICAgICAgICAgIGRlc3RMZXZlbCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGFkZGluZyB0byBhbiBleGlzdGluZyBsZXZlbCwgZmluZCB3aGVyZSB0byBpbnNlcnRcbiAgICAgICAgbGV0IGRlc3RMYXRlcmFsID0gLTE7XG4gICAgICAgIGlmIChkZXN0TGV2ZWwgPCBsZXZlbENudCAmJiBsZXZlbENvb3Jkc1tkZXN0TGV2ZWxdID09PSBjYW5kaWRhdGVDb29yZCkge1xuICAgICAgICAgICAgZGVzdExhdGVyYWwgPSBiaW5hcnlTZWFyY2goZW50cmllc0J5TGV2ZWxbZGVzdExldmVsXSwgbmV3RW50cnkuc3Bhbi5lbmQsIGdldEVudHJ5U3BhbkVuZClbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvdWNoaW5nTGV2ZWwsXG4gICAgICAgICAgICB0b3VjaGluZ0xhdGVyYWwsXG4gICAgICAgICAgICB0b3VjaGluZ0VudHJ5LFxuICAgICAgICAgICAgc3RhY2tDbnQsXG4gICAgICAgICAgICBsZXZlbENvb3JkOiBjYW5kaWRhdGVDb29yZCxcbiAgICAgICAgICAgIGxldmVsOiBkZXN0TGV2ZWwsXG4gICAgICAgICAgICBsYXRlcmFsOiBkZXN0TGF0ZXJhbCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gc29ydGVkIGJ5IGxldmVsQ29vcmQgKGxvd2VzdCB0byBoaWdoZXN0KVxuICAgIHRvUmVjdHMoKSB7XG4gICAgICAgIGxldCB7IGVudHJpZXNCeUxldmVsLCBsZXZlbENvb3JkcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGxldmVsQ250ID0gZW50cmllc0J5TGV2ZWwubGVuZ3RoO1xuICAgICAgICBsZXQgcmVjdHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgbGV2ZWwgPSAwOyBsZXZlbCA8IGxldmVsQ250OyBsZXZlbCArPSAxKSB7XG4gICAgICAgICAgICBsZXQgZW50cmllcyA9IGVudHJpZXNCeUxldmVsW2xldmVsXTtcbiAgICAgICAgICAgIGxldCBsZXZlbENvb3JkID0gbGV2ZWxDb29yZHNbbGV2ZWxdO1xuICAgICAgICAgICAgZm9yIChsZXQgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICAgICAgICAgIHJlY3RzLnB1c2goT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBlbnRyeSksIHsgdGhpY2tuZXNzOiB0aGlzLmdldEVudHJ5VGhpY2tuZXNzKGVudHJ5KSwgbGV2ZWxDb29yZCB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlY3RzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEVudHJ5U3BhbkVuZChlbnRyeSkge1xuICAgIHJldHVybiBlbnRyeS5zcGFuLmVuZDtcbn1cbmZ1bmN0aW9uIGJ1aWxkRW50cnlLZXkoZW50cnkpIHtcbiAgICByZXR1cm4gZW50cnkuaW5kZXggKyAnOicgKyBlbnRyeS5zcGFuLnN0YXJ0O1xufVxuLy8gcmV0dXJucyBncm91cHMgd2l0aCBlbnRyaWVzIHNvcnRlZCBieSBpbnB1dCBvcmRlclxuZnVuY3Rpb24gZ3JvdXBJbnRlcnNlY3RpbmdFbnRyaWVzKGVudHJpZXMpIHtcbiAgICBsZXQgbWVyZ2VzID0gW107XG4gICAgZm9yIChsZXQgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICBsZXQgZmlsdGVyZWRNZXJnZXMgPSBbXTtcbiAgICAgICAgbGV0IGh1bmdyeU1lcmdlID0ge1xuICAgICAgICAgICAgc3BhbjogZW50cnkuc3BhbixcbiAgICAgICAgICAgIGVudHJpZXM6IFtlbnRyeV0sXG4gICAgICAgIH07XG4gICAgICAgIGZvciAobGV0IG1lcmdlIG9mIG1lcmdlcykge1xuICAgICAgICAgICAgaWYgKGludGVyc2VjdFNwYW5zKG1lcmdlLnNwYW4sIGh1bmdyeU1lcmdlLnNwYW4pKSB7XG4gICAgICAgICAgICAgICAgaHVuZ3J5TWVyZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIGVudHJpZXM6IG1lcmdlLmVudHJpZXMuY29uY2F0KGh1bmdyeU1lcmdlLmVudHJpZXMpLFxuICAgICAgICAgICAgICAgICAgICBzcGFuOiBqb2luU3BhbnMobWVyZ2Uuc3BhbiwgaHVuZ3J5TWVyZ2Uuc3BhbiksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpbHRlcmVkTWVyZ2VzLnB1c2gobWVyZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbHRlcmVkTWVyZ2VzLnB1c2goaHVuZ3J5TWVyZ2UpO1xuICAgICAgICBtZXJnZXMgPSBmaWx0ZXJlZE1lcmdlcztcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlcztcbn1cbmZ1bmN0aW9uIGpvaW5TcGFucyhzcGFuMCwgc3BhbjEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogTWF0aC5taW4oc3BhbjAuc3RhcnQsIHNwYW4xLnN0YXJ0KSxcbiAgICAgICAgZW5kOiBNYXRoLm1heChzcGFuMC5lbmQsIHNwYW4xLmVuZCksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGludGVyc2VjdFNwYW5zKHNwYW4wLCBzcGFuMSkge1xuICAgIGxldCBzdGFydCA9IE1hdGgubWF4KHNwYW4wLnN0YXJ0LCBzcGFuMS5zdGFydCk7XG4gICAgbGV0IGVuZCA9IE1hdGgubWluKHNwYW4wLmVuZCwgc3BhbjEuZW5kKTtcbiAgICBpZiAoc3RhcnQgPCBlbmQpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQsIGVuZCB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8vIGdlbmVyYWwgdXRpbFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBpbnNlcnRBdChhcnIsIGluZGV4LCBpdGVtKSB7XG4gICAgYXJyLnNwbGljZShpbmRleCwgMCwgaXRlbSk7XG59XG5mdW5jdGlvbiBiaW5hcnlTZWFyY2goYSwgc2VhcmNoVmFsLCBnZXRJdGVtVmFsKSB7XG4gICAgbGV0IHN0YXJ0SW5kZXggPSAwO1xuICAgIGxldCBlbmRJbmRleCA9IGEubGVuZ3RoOyAvLyBleGNsdXNpdmVcbiAgICBpZiAoIWVuZEluZGV4IHx8IHNlYXJjaFZhbCA8IGdldEl0ZW1WYWwoYVtzdGFydEluZGV4XSkpIHsgLy8gbm8gaXRlbXMgT1IgYmVmb3JlIGZpcnN0IGl0ZW1cbiAgICAgICAgcmV0dXJuIFswLCAwXTtcbiAgICB9XG4gICAgaWYgKHNlYXJjaFZhbCA+IGdldEl0ZW1WYWwoYVtlbmRJbmRleCAtIDFdKSkgeyAvLyBhZnRlciBsYXN0IGl0ZW1cbiAgICAgICAgcmV0dXJuIFtlbmRJbmRleCwgMF07XG4gICAgfVxuICAgIHdoaWxlIChzdGFydEluZGV4IDwgZW5kSW5kZXgpIHtcbiAgICAgICAgbGV0IG1pZGRsZUluZGV4ID0gTWF0aC5mbG9vcihzdGFydEluZGV4ICsgKGVuZEluZGV4IC0gc3RhcnRJbmRleCkgLyAyKTtcbiAgICAgICAgbGV0IG1pZGRsZVZhbCA9IGdldEl0ZW1WYWwoYVttaWRkbGVJbmRleF0pO1xuICAgICAgICBpZiAoc2VhcmNoVmFsIDwgbWlkZGxlVmFsKSB7XG4gICAgICAgICAgICBlbmRJbmRleCA9IG1pZGRsZUluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNlYXJjaFZhbCA+IG1pZGRsZVZhbCkge1xuICAgICAgICAgICAgc3RhcnRJbmRleCA9IG1pZGRsZUluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gZXF1YWwhXG4gICAgICAgICAgICByZXR1cm4gW21pZGRsZUluZGV4LCAxXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW3N0YXJ0SW5kZXgsIDBdO1xufVxuXG4vKlxuQW4gYWJzdHJhY3Rpb24gZm9yIGEgZHJhZ2dpbmcgaW50ZXJhY3Rpb24gb3JpZ2luYXRpbmcgb24gYW4gZXZlbnQuXG5Eb2VzIGhpZ2hlci1sZXZlbCB0aGluZ3MgdGhhbiBQb2ludGVyRHJhZ2dlciwgc3VjaCBhcyBwb3NzaWJseTpcbi0gYSBcIm1pcnJvclwiIHRoYXQgbW92ZXMgd2l0aCB0aGUgcG9pbnRlclxuLSBhIG1pbmltdW0gbnVtYmVyIG9mIHBpeGVscyBvciBvdGhlciBjcml0ZXJpYSBmb3IgYSB0cnVlIGRyYWcgdG8gYmVnaW5cblxuc3ViY2xhc3NlcyBtdXN0IGVtaXQ6XG4tIHBvaW50ZXJkb3duXG4tIGRyYWdzdGFydFxuLSBkcmFnbW92ZVxuLSBwb2ludGVydXBcbi0gZHJhZ2VuZFxuKi9cbmNsYXNzIEVsZW1lbnREcmFnZ2luZyB7XG4gICAgY29uc3RydWN0b3IoZWwsIHNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgfVxuICAgIHNldE1pcnJvcklzVmlzaWJsZShib29sKSB7XG4gICAgICAgIC8vIG9wdGlvbmFsIGlmIHN1YmNsYXNzIGRvZXNuJ3Qgd2FudCB0byBzdXBwb3J0IGEgbWlycm9yXG4gICAgfVxuICAgIHNldE1pcnJvck5lZWRzUmV2ZXJ0KGJvb2wpIHtcbiAgICAgICAgLy8gb3B0aW9uYWwgaWYgc3ViY2xhc3MgZG9lc24ndCB3YW50IHRvIHN1cHBvcnQgYSBtaXJyb3JcbiAgICB9XG4gICAgc2V0QXV0b1Njcm9sbEVuYWJsZWQoYm9vbCkge1xuICAgICAgICAvLyBvcHRpb25hbFxuICAgIH1cbn1cblxuLy8gVE9ETzogZ2V0IHJpZCBvZiB0aGlzIGluIGZhdm9yIG9mIG9wdGlvbnMgc3lzdGVtLFxuLy8gdGhvIGl0J3MgcmVhbGx5IGVhc3kgdG8gYWNjZXNzIHRoaXMgZ2xvYmFsbHkgcmF0aGVyIHRoYW4gcGFzcyB0aHJ1IG9wdGlvbnMuXG5jb25zdCBjb25maWcgPSB7fTtcblxuLypcbkluZm9ybWF0aW9uIGFib3V0IHdoYXQgd2lsbCBoYXBwZW4gd2hlbiBhbiBleHRlcm5hbCBlbGVtZW50IGlzIGRyYWdnZWQtYW5kLWRyb3BwZWRcbm9udG8gYSBjYWxlbmRhci4gQ29udGFpbnMgaW5mb3JtYXRpb24gZm9yIGNyZWF0aW5nIGFuIGV2ZW50LlxuKi9cbmNvbnN0IERSQUdfTUVUQV9SRUZJTkVSUyA9IHtcbiAgICBzdGFydFRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxuICAgIGR1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBjcmVhdGU6IEJvb2xlYW4sXG4gICAgc291cmNlSWQ6IFN0cmluZyxcbn07XG5mdW5jdGlvbiBwYXJzZURyYWdNZXRhKHJhdykge1xuICAgIGxldCB7IHJlZmluZWQsIGV4dHJhIH0gPSByZWZpbmVQcm9wcyhyYXcsIERSQUdfTUVUQV9SRUZJTkVSUyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnRUaW1lOiByZWZpbmVkLnN0YXJ0VGltZSB8fCBudWxsLFxuICAgICAgICBkdXJhdGlvbjogcmVmaW5lZC5kdXJhdGlvbiB8fCBudWxsLFxuICAgICAgICBjcmVhdGU6IHJlZmluZWQuY3JlYXRlICE9IG51bGwgPyByZWZpbmVkLmNyZWF0ZSA6IHRydWUsXG4gICAgICAgIHNvdXJjZUlkOiByZWZpbmVkLnNvdXJjZUlkLFxuICAgICAgICBsZWZ0b3ZlclByb3BzOiBleHRyYSxcbiAgICB9O1xufVxuXG4vLyBDb21wdXRlcyBhIGRlZmF1bHQgY29sdW1uIGhlYWRlciBmb3JtYXR0aW5nIHN0cmluZyBpZiBgY29sRm9ybWF0YCBpcyBub3QgZXhwbGljaXRseSBkZWZpbmVkXG5mdW5jdGlvbiBjb21wdXRlRmFsbGJhY2tIZWFkZXJGb3JtYXQoZGF0ZXNSZXBEaXN0aW5jdERheXMsIGRheUNudCkge1xuICAgIC8vIGlmIG1vcmUgdGhhbiBvbmUgd2VlayByb3csIG9yIGlmIHRoZXJlIGFyZSBhIGxvdCBvZiBjb2x1bW5zIHdpdGggbm90IG11Y2ggc3BhY2UsXG4gICAgLy8gcHV0IGp1c3QgdGhlIGRheSBudW1iZXJzIHdpbGwgYmUgaW4gZWFjaCBjZWxsXG4gICAgaWYgKCFkYXRlc1JlcERpc3RpbmN0RGF5cyB8fCBkYXlDbnQgPiAxMCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRm9ybWF0dGVyKHsgd2Vla2RheTogJ3Nob3J0JyB9KTsgLy8gXCJTYXRcIlxuICAgIH1cbiAgICBpZiAoZGF5Q250ID4gMSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRm9ybWF0dGVyKHsgd2Vla2RheTogJ3Nob3J0JywgbW9udGg6ICdudW1lcmljJywgZGF5OiAnbnVtZXJpYycsIG9taXRDb21tYXM6IHRydWUgfSk7IC8vIFwiU2F0IDExLzEyXCJcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUZvcm1hdHRlcih7IHdlZWtkYXk6ICdsb25nJyB9KTsgLy8gXCJTYXR1cmRheVwiXG59XG5cbmNvbnN0IENMQVNTX05BTUUgPSAnZmMtY29sLWhlYWRlci1jZWxsJzsgLy8gZG8gdGhlIGN1c2hpb24gdG9vPyBub1xuZnVuY3Rpb24gcmVuZGVySW5uZXIkMShyZW5kZXJQcm9wcykge1xuICAgIHJldHVybiByZW5kZXJQcm9wcy50ZXh0O1xufVxuXG4vLyBCQUQgbmFtZSBmb3IgdGhpcyBjbGFzcyBub3cuIHVzZWQgaW4gdGhlIEhlYWRlclxuY2xhc3MgVGFibGVEYXRlQ2VsbCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiwgb3B0aW9ucywgdGhlbWUsIHZpZXdBcGkgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IGRhdGUsIGRhdGVQcm9maWxlIH0gPSBwcm9wcztcbiAgICAgICAgbGV0IGRheU1ldGEgPSBnZXREYXRlTWV0YShkYXRlLCBwcm9wcy50b2RheVJhbmdlLCBudWxsLCBkYXRlUHJvZmlsZSk7XG4gICAgICAgIGxldCBjbGFzc05hbWVzID0gW0NMQVNTX05BTUVdLmNvbmNhdChnZXREYXlDbGFzc05hbWVzKGRheU1ldGEsIHRoZW1lKSk7XG4gICAgICAgIGxldCB0ZXh0ID0gZGF0ZUVudi5mb3JtYXQoZGF0ZSwgcHJvcHMuZGF5SGVhZGVyRm9ybWF0KTtcbiAgICAgICAgLy8gaWYgY29sQ250IGlzIDEsIHdlIGFyZSBhbHJlYWR5IGluIGEgZGF5LXZpZXcgYW5kIGRvbid0IG5lZWQgYSBuYXZsaW5rXG4gICAgICAgIGxldCBuYXZMaW5rQXR0cnMgPSAoIWRheU1ldGEuaXNEaXNhYmxlZCAmJiBwcm9wcy5jb2xDbnQgPiAxKVxuICAgICAgICAgICAgPyBidWlsZE5hdkxpbmtBdHRycyh0aGlzLmNvbnRleHQsIGRhdGUpXG4gICAgICAgICAgICA6IHt9O1xuICAgICAgICBsZXQgcmVuZGVyUHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IGRhdGU6IGRhdGVFbnYudG9EYXRlKGRhdGUpLCB2aWV3OiB2aWV3QXBpIH0sIHByb3BzLmV4dHJhUmVuZGVyUHJvcHMpLCB7IHRleHQgfSksIGRheU1ldGEpO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoQ29udGVudENvbnRhaW5lciwgeyBlbFRhZzogXCJ0aFwiLCBlbENsYXNzZXM6IGNsYXNzTmFtZXMsIGVsQXR0cnM6IE9iamVjdC5hc3NpZ24oeyByb2xlOiAnY29sdW1uaGVhZGVyJywgY29sU3BhbjogcHJvcHMuY29sU3BhbiwgJ2RhdGEtZGF0ZSc6ICFkYXlNZXRhLmlzRGlzYWJsZWQgPyBmb3JtYXREYXlTdHJpbmcoZGF0ZSkgOiB1bmRlZmluZWQgfSwgcHJvcHMuZXh0cmFEYXRhQXR0cnMpLCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGdlbmVyYXRvck5hbWU6IFwiZGF5SGVhZGVyQ29udGVudFwiLCBjdXN0b21HZW5lcmF0b3I6IG9wdGlvbnMuZGF5SGVhZGVyQ29udGVudCwgZGVmYXVsdEdlbmVyYXRvcjogcmVuZGVySW5uZXIkMSwgY2xhc3NOYW1lR2VuZXJhdG9yOiBvcHRpb25zLmRheUhlYWRlckNsYXNzTmFtZXMsIGRpZE1vdW50OiBvcHRpb25zLmRheUhlYWRlckRpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy5kYXlIZWFkZXJXaWxsVW5tb3VudCB9LCAoSW5uZXJDb250YWluZXIpID0+IChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXNjcm9sbGdyaWQtc3luYy1pbm5lclwiIH0sICFkYXlNZXRhLmlzRGlzYWJsZWQgJiYgKGNyZWF0ZUVsZW1lbnQoSW5uZXJDb250YWluZXIsIHsgZWxUYWc6IFwiYVwiLCBlbEF0dHJzOiBuYXZMaW5rQXR0cnMsIGVsQ2xhc3NlczogW1xuICAgICAgICAgICAgICAgICdmYy1jb2wtaGVhZGVyLWNlbGwtY3VzaGlvbicsXG4gICAgICAgICAgICAgICAgcHJvcHMuaXNTdGlja3kgJiYgJ2ZjLXN0aWNreScsXG4gICAgICAgICAgICBdIH0pKSkpKSk7XG4gICAgfVxufVxuXG5jb25zdCBXRUVLREFZX0ZPUk1BVCA9IGNyZWF0ZUZvcm1hdHRlcih7IHdlZWtkYXk6ICdsb25nJyB9KTtcbmNsYXNzIFRhYmxlRG93Q2VsbCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IGRhdGVFbnYsIHRoZW1lLCB2aWV3QXBpLCBvcHRpb25zIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBkYXRlID0gYWRkRGF5cyhuZXcgRGF0ZSgyNTkyMDAwMDApLCBwcm9wcy5kb3cpOyAvLyBzdGFydCB3aXRoIFN1biwgMDQgSmFuIDE5NzAgMDA6MDA6MDAgR01UXG4gICAgICAgIGxldCBkYXRlTWV0YSA9IHtcbiAgICAgICAgICAgIGRvdzogcHJvcHMuZG93LFxuICAgICAgICAgICAgaXNEaXNhYmxlZDogZmFsc2UsXG4gICAgICAgICAgICBpc0Z1dHVyZTogZmFsc2UsXG4gICAgICAgICAgICBpc1Bhc3Q6IGZhbHNlLFxuICAgICAgICAgICAgaXNUb2RheTogZmFsc2UsXG4gICAgICAgICAgICBpc090aGVyOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHRleHQgPSBkYXRlRW52LmZvcm1hdChkYXRlLCBwcm9wcy5kYXlIZWFkZXJGb3JtYXQpO1xuICAgICAgICBsZXQgcmVuZGVyUHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgLy8gVE9ETzogbWFrZSB0aGlzIHB1YmxpYz9cbiAgICAgICAgICAgIGRhdGUgfSwgZGF0ZU1ldGEpLCB7IHZpZXc6IHZpZXdBcGkgfSksIHByb3BzLmV4dHJhUmVuZGVyUHJvcHMpLCB7IHRleHQgfSk7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChDb250ZW50Q29udGFpbmVyLCB7IGVsVGFnOiBcInRoXCIsIGVsQ2xhc3NlczogW1xuICAgICAgICAgICAgICAgIENMQVNTX05BTUUsXG4gICAgICAgICAgICAgICAgLi4uZ2V0RGF5Q2xhc3NOYW1lcyhkYXRlTWV0YSwgdGhlbWUpLFxuICAgICAgICAgICAgICAgIC4uLihwcm9wcy5leHRyYUNsYXNzTmFtZXMgfHwgW10pLFxuICAgICAgICAgICAgXSwgZWxBdHRyczogT2JqZWN0LmFzc2lnbih7IHJvbGU6ICdjb2x1bW5oZWFkZXInLCBjb2xTcGFuOiBwcm9wcy5jb2xTcGFuIH0sIHByb3BzLmV4dHJhRGF0YUF0dHJzKSwgcmVuZGVyUHJvcHM6IHJlbmRlclByb3BzLCBnZW5lcmF0b3JOYW1lOiBcImRheUhlYWRlckNvbnRlbnRcIiwgY3VzdG9tR2VuZXJhdG9yOiBvcHRpb25zLmRheUhlYWRlckNvbnRlbnQsIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlcklubmVyJDEsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy5kYXlIZWFkZXJDbGFzc05hbWVzLCBkaWRNb3VudDogb3B0aW9ucy5kYXlIZWFkZXJEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMuZGF5SGVhZGVyV2lsbFVubW91bnQgfSwgKElubmVyQ29udGVudCkgPT4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtc2Nyb2xsZ3JpZC1zeW5jLWlubmVyXCIgfSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoSW5uZXJDb250ZW50LCB7IGVsVGFnOiBcImFcIiwgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgICAgICdmYy1jb2wtaGVhZGVyLWNlbGwtY3VzaGlvbicsXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLmlzU3RpY2t5ICYmICdmYy1zdGlja3knLFxuICAgICAgICAgICAgICAgIF0sIGVsQXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2FyaWEtbGFiZWwnOiBkYXRlRW52LmZvcm1hdChkYXRlLCBXRUVLREFZX0ZPUk1BVCksXG4gICAgICAgICAgICAgICAgfSB9KSkpKSk7XG4gICAgfVxufVxuXG5jbGFzcyBOb3dUaW1lciBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMsIGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIocHJvcHMsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLmluaXRpYWxOb3dEYXRlID0gZ2V0Tm93KGNvbnRleHQub3B0aW9ucy5ub3csIGNvbnRleHQuZGF0ZUVudik7XG4gICAgICAgIHRoaXMuaW5pdGlhbE5vd1F1ZXJpZWRNcyA9IG5ldyBEYXRlKCkudmFsdWVPZigpO1xuICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5jb21wdXRlVGltaW5nKCkuY3VycmVudFN0YXRlO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBzdGF0ZSB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHByb3BzLmNoaWxkcmVuKHN0YXRlLm5vd0RhdGUsIHN0YXRlLnRvZGF5UmFuZ2UpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5zZXRUaW1lb3V0KCk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgICAgaWYgKHByZXZQcm9wcy51bml0ICE9PSB0aGlzLnByb3BzLnVuaXQpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJUaW1lb3V0KCk7XG4gICAgICAgICAgICB0aGlzLnNldFRpbWVvdXQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgICB9XG4gICAgY29tcHV0ZVRpbWluZygpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCB1bnJvdW5kZWROb3cgPSBhZGRNcyh0aGlzLmluaXRpYWxOb3dEYXRlLCBuZXcgRGF0ZSgpLnZhbHVlT2YoKSAtIHRoaXMuaW5pdGlhbE5vd1F1ZXJpZWRNcyk7XG4gICAgICAgIGxldCBjdXJyZW50VW5pdFN0YXJ0ID0gY29udGV4dC5kYXRlRW52LnN0YXJ0T2YodW5yb3VuZGVkTm93LCBwcm9wcy51bml0KTtcbiAgICAgICAgbGV0IG5leHRVbml0U3RhcnQgPSBjb250ZXh0LmRhdGVFbnYuYWRkKGN1cnJlbnRVbml0U3RhcnQsIGNyZWF0ZUR1cmF0aW9uKDEsIHByb3BzLnVuaXQpKTtcbiAgICAgICAgbGV0IHdhaXRNcyA9IG5leHRVbml0U3RhcnQudmFsdWVPZigpIC0gdW5yb3VuZGVkTm93LnZhbHVlT2YoKTtcbiAgICAgICAgLy8gdGhlcmUgaXMgYSBtYXggc2V0VGltZW91dCBtcyB2YWx1ZSAoaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM0Njg2NTAvOTYzNDIpXG4gICAgICAgIC8vIGVuc3VyZSBubyBsb25nZXIgdGhhbiBhIGRheVxuICAgICAgICB3YWl0TXMgPSBNYXRoLm1pbigxMDAwICogNjAgKiA2MCAqIDI0LCB3YWl0TXMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3VycmVudFN0YXRlOiB7IG5vd0RhdGU6IGN1cnJlbnRVbml0U3RhcnQsIHRvZGF5UmFuZ2U6IGJ1aWxkRGF5UmFuZ2UoY3VycmVudFVuaXRTdGFydCkgfSxcbiAgICAgICAgICAgIG5leHRTdGF0ZTogeyBub3dEYXRlOiBuZXh0VW5pdFN0YXJ0LCB0b2RheVJhbmdlOiBidWlsZERheVJhbmdlKG5leHRVbml0U3RhcnQpIH0sXG4gICAgICAgICAgICB3YWl0TXMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHNldFRpbWVvdXQoKSB7XG4gICAgICAgIGxldCB7IG5leHRTdGF0ZSwgd2FpdE1zIH0gPSB0aGlzLmNvbXB1dGVUaW1pbmcoKTtcbiAgICAgICAgdGhpcy50aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUobmV4dFN0YXRlLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRUaW1lb3V0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgd2FpdE1zKTtcbiAgICB9XG4gICAgY2xlYXJUaW1lb3V0KCkge1xuICAgICAgICBpZiAodGhpcy50aW1lb3V0SWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5Ob3dUaW1lci5jb250ZXh0VHlwZSA9IFZpZXdDb250ZXh0VHlwZTtcbmZ1bmN0aW9uIGJ1aWxkRGF5UmFuZ2UoZGF0ZSkge1xuICAgIGxldCBzdGFydCA9IHN0YXJ0T2ZEYXkoZGF0ZSk7XG4gICAgbGV0IGVuZCA9IGFkZERheXMoc3RhcnQsIDEpO1xuICAgIHJldHVybiB7IHN0YXJ0LCBlbmQgfTtcbn1cblxuY2xhc3MgRGF5SGVhZGVyIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuY3JlYXRlRGF5SGVhZGVyRm9ybWF0dGVyID0gbWVtb2l6ZShjcmVhdGVEYXlIZWFkZXJGb3JtYXR0ZXIpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IGRhdGVzLCBkYXRlUHJvZmlsZSwgZGF0ZXNSZXBEaXN0aW5jdERheXMsIHJlbmRlckludHJvIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBsZXQgZGF5SGVhZGVyRm9ybWF0ID0gdGhpcy5jcmVhdGVEYXlIZWFkZXJGb3JtYXR0ZXIoY29udGV4dC5vcHRpb25zLmRheUhlYWRlckZvcm1hdCwgZGF0ZXNSZXBEaXN0aW5jdERheXMsIGRhdGVzLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChOb3dUaW1lciwgeyB1bml0OiBcImRheVwiIH0sIChub3dEYXRlLCB0b2RheVJhbmdlKSA9PiAoY3JlYXRlRWxlbWVudChcInRyXCIsIHsgcm9sZTogXCJyb3dcIiB9LFxuICAgICAgICAgICAgcmVuZGVySW50cm8gJiYgcmVuZGVySW50cm8oJ2RheScpLFxuICAgICAgICAgICAgZGF0ZXMubWFwKChkYXRlKSA9PiAoZGF0ZXNSZXBEaXN0aW5jdERheXMgPyAoY3JlYXRlRWxlbWVudChUYWJsZURhdGVDZWxsLCB7IGtleTogZGF0ZS50b0lTT1N0cmluZygpLCBkYXRlOiBkYXRlLCBkYXRlUHJvZmlsZTogZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2U6IHRvZGF5UmFuZ2UsIGNvbENudDogZGF0ZXMubGVuZ3RoLCBkYXlIZWFkZXJGb3JtYXQ6IGRheUhlYWRlckZvcm1hdCB9KSkgOiAoY3JlYXRlRWxlbWVudChUYWJsZURvd0NlbGwsIHsga2V5OiBkYXRlLmdldFVUQ0RheSgpLCBkb3c6IGRhdGUuZ2V0VVRDRGF5KCksIGRheUhlYWRlckZvcm1hdDogZGF5SGVhZGVyRm9ybWF0IH0pKSkpKSkpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVEYXlIZWFkZXJGb3JtYXR0ZXIoZXhwbGljaXRGb3JtYXQsIGRhdGVzUmVwRGlzdGluY3REYXlzLCBkYXRlQ250KSB7XG4gICAgcmV0dXJuIGV4cGxpY2l0Rm9ybWF0IHx8IGNvbXB1dGVGYWxsYmFja0hlYWRlckZvcm1hdChkYXRlc1JlcERpc3RpbmN0RGF5cywgZGF0ZUNudCk7XG59XG5cbmNsYXNzIERheVNlcmllc01vZGVsIHtcbiAgICBjb25zdHJ1Y3RvcihyYW5nZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IpIHtcbiAgICAgICAgbGV0IGRhdGUgPSByYW5nZS5zdGFydDtcbiAgICAgICAgbGV0IHsgZW5kIH0gPSByYW5nZTtcbiAgICAgICAgbGV0IGluZGljZXMgPSBbXTtcbiAgICAgICAgbGV0IGRhdGVzID0gW107XG4gICAgICAgIGxldCBkYXlJbmRleCA9IC0xO1xuICAgICAgICB3aGlsZSAoZGF0ZSA8IGVuZCkgeyAvLyBsb29wIGVhY2ggZGF5IGZyb20gc3RhcnQgdG8gZW5kXG4gICAgICAgICAgICBpZiAoZGF0ZVByb2ZpbGVHZW5lcmF0b3IuaXNIaWRkZW5EYXkoZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2goZGF5SW5kZXggKyAwLjUpOyAvLyBtYXJrIHRoYXQgaXQncyBiZXR3ZWVuIGluZGljZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRheUluZGV4ICs9IDE7XG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGRheUluZGV4KTtcbiAgICAgICAgICAgICAgICBkYXRlcy5wdXNoKGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0ZSA9IGFkZERheXMoZGF0ZSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRlcyA9IGRhdGVzO1xuICAgICAgICB0aGlzLmluZGljZXMgPSBpbmRpY2VzO1xuICAgICAgICB0aGlzLmNudCA9IGRhdGVzLmxlbmd0aDtcbiAgICB9XG4gICAgc2xpY2VSYW5nZShyYW5nZSkge1xuICAgICAgICBsZXQgZmlyc3RJbmRleCA9IHRoaXMuZ2V0RGF0ZURheUluZGV4KHJhbmdlLnN0YXJ0KTsgLy8gaW5jbHVzaXZlIGZpcnN0IGluZGV4XG4gICAgICAgIGxldCBsYXN0SW5kZXggPSB0aGlzLmdldERhdGVEYXlJbmRleChhZGREYXlzKHJhbmdlLmVuZCwgLTEpKTsgLy8gaW5jbHVzaXZlIGxhc3QgaW5kZXhcbiAgICAgICAgbGV0IGNsaXBwZWRGaXJzdEluZGV4ID0gTWF0aC5tYXgoMCwgZmlyc3RJbmRleCk7XG4gICAgICAgIGxldCBjbGlwcGVkTGFzdEluZGV4ID0gTWF0aC5taW4odGhpcy5jbnQgLSAxLCBsYXN0SW5kZXgpO1xuICAgICAgICAvLyBkZWFsIHdpdGggaW4tYmV0d2VlbiBpbmRpY2VzXG4gICAgICAgIGNsaXBwZWRGaXJzdEluZGV4ID0gTWF0aC5jZWlsKGNsaXBwZWRGaXJzdEluZGV4KTsgLy8gaW4tYmV0d2VlbiBzdGFydHMgcm91bmQgdG8gbmV4dCBjZWxsXG4gICAgICAgIGNsaXBwZWRMYXN0SW5kZXggPSBNYXRoLmZsb29yKGNsaXBwZWRMYXN0SW5kZXgpOyAvLyBpbi1iZXR3ZWVuIGVuZHMgcm91bmQgdG8gcHJldiBjZWxsXG4gICAgICAgIGlmIChjbGlwcGVkRmlyc3RJbmRleCA8PSBjbGlwcGVkTGFzdEluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZpcnN0SW5kZXg6IGNsaXBwZWRGaXJzdEluZGV4LFxuICAgICAgICAgICAgICAgIGxhc3RJbmRleDogY2xpcHBlZExhc3RJbmRleCxcbiAgICAgICAgICAgICAgICBpc1N0YXJ0OiBmaXJzdEluZGV4ID09PSBjbGlwcGVkRmlyc3RJbmRleCxcbiAgICAgICAgICAgICAgICBpc0VuZDogbGFzdEluZGV4ID09PSBjbGlwcGVkTGFzdEluZGV4LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gR2l2ZW4gYSBkYXRlLCByZXR1cm5zIGl0cyBjaHJvbm9sb2NpYWwgY2VsbC1pbmRleCBmcm9tIHRoZSBmaXJzdCBjZWxsIG9mIHRoZSBncmlkLlxuICAgIC8vIElmIHRoZSBkYXRlIGxpZXMgYmV0d2VlbiBjZWxscyAoYmVjYXVzZSBvZiBoaWRkZW5EYXlzKSwgcmV0dXJucyBhIGZsb2F0aW5nLXBvaW50IHZhbHVlIGJldHdlZW4gb2Zmc2V0cy5cbiAgICAvLyBJZiBiZWZvcmUgdGhlIGZpcnN0IG9mZnNldCwgcmV0dXJucyBhIG5lZ2F0aXZlIG51bWJlci5cbiAgICAvLyBJZiBhZnRlciB0aGUgbGFzdCBvZmZzZXQsIHJldHVybnMgYW4gb2Zmc2V0IHBhc3QgdGhlIGxhc3QgY2VsbCBvZmZzZXQuXG4gICAgLy8gT25seSB3b3JrcyBmb3IgKnN0YXJ0KiBkYXRlcyBvZiBjZWxscy4gV2lsbCBub3Qgd29yayBmb3IgZXhjbHVzaXZlIGVuZCBkYXRlcyBmb3IgY2VsbHMuXG4gICAgZ2V0RGF0ZURheUluZGV4KGRhdGUpIHtcbiAgICAgICAgbGV0IHsgaW5kaWNlcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGRheU9mZnNldCA9IE1hdGguZmxvb3IoZGlmZkRheXModGhpcy5kYXRlc1swXSwgZGF0ZSkpO1xuICAgICAgICBpZiAoZGF5T2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIGluZGljZXNbMF0gLSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXlPZmZzZXQgPj0gaW5kaWNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmRpY2VzW2luZGljZXMubGVuZ3RoIC0gMV0gKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRpY2VzW2RheU9mZnNldF07XG4gICAgfVxufVxuXG5jbGFzcyBEYXlUYWJsZU1vZGVsIHtcbiAgICBjb25zdHJ1Y3RvcihkYXlTZXJpZXMsIGJyZWFrT25XZWVrcykge1xuICAgICAgICBsZXQgeyBkYXRlcyB9ID0gZGF5U2VyaWVzO1xuICAgICAgICBsZXQgZGF5c1BlclJvdztcbiAgICAgICAgbGV0IGZpcnN0RGF5O1xuICAgICAgICBsZXQgcm93Q250O1xuICAgICAgICBpZiAoYnJlYWtPbldlZWtzKSB7XG4gICAgICAgICAgICAvLyBjb3VudCBjb2x1bW5zIHVudGlsIHRoZSBkYXktb2Ytd2VlayByZXBlYXRzXG4gICAgICAgICAgICBmaXJzdERheSA9IGRhdGVzWzBdLmdldFVUQ0RheSgpO1xuICAgICAgICAgICAgZm9yIChkYXlzUGVyUm93ID0gMTsgZGF5c1BlclJvdyA8IGRhdGVzLmxlbmd0aDsgZGF5c1BlclJvdyArPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGVzW2RheXNQZXJSb3ddLmdldFVUQ0RheSgpID09PSBmaXJzdERheSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3dDbnQgPSBNYXRoLmNlaWwoZGF0ZXMubGVuZ3RoIC8gZGF5c1BlclJvdyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByb3dDbnQgPSAxO1xuICAgICAgICAgICAgZGF5c1BlclJvdyA9IGRhdGVzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJvd0NudCA9IHJvd0NudDtcbiAgICAgICAgdGhpcy5jb2xDbnQgPSBkYXlzUGVyUm93O1xuICAgICAgICB0aGlzLmRheVNlcmllcyA9IGRheVNlcmllcztcbiAgICAgICAgdGhpcy5jZWxscyA9IHRoaXMuYnVpbGRDZWxscygpO1xuICAgICAgICB0aGlzLmhlYWRlckRhdGVzID0gdGhpcy5idWlsZEhlYWRlckRhdGVzKCk7XG4gICAgfVxuICAgIGJ1aWxkQ2VsbHMoKSB7XG4gICAgICAgIGxldCByb3dzID0gW107XG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHRoaXMucm93Q250OyByb3cgKz0gMSkge1xuICAgICAgICAgICAgbGV0IGNlbGxzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCB0aGlzLmNvbENudDsgY29sICs9IDEpIHtcbiAgICAgICAgICAgICAgICBjZWxscy5wdXNoKHRoaXMuYnVpbGRDZWxsKHJvdywgY29sKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3dzLnB1c2goY2VsbHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3dzO1xuICAgIH1cbiAgICBidWlsZENlbGwocm93LCBjb2wpIHtcbiAgICAgICAgbGV0IGRhdGUgPSB0aGlzLmRheVNlcmllcy5kYXRlc1tyb3cgKiB0aGlzLmNvbENudCArIGNvbF07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrZXk6IGRhdGUudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIGRhdGUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGJ1aWxkSGVhZGVyRGF0ZXMoKSB7XG4gICAgICAgIGxldCBkYXRlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCB0aGlzLmNvbENudDsgY29sICs9IDEpIHtcbiAgICAgICAgICAgIGRhdGVzLnB1c2godGhpcy5jZWxsc1swXVtjb2xdLmRhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlcztcbiAgICB9XG4gICAgc2xpY2VSYW5nZShyYW5nZSkge1xuICAgICAgICBsZXQgeyBjb2xDbnQgfSA9IHRoaXM7XG4gICAgICAgIGxldCBzZXJpZXNTZWcgPSB0aGlzLmRheVNlcmllcy5zbGljZVJhbmdlKHJhbmdlKTtcbiAgICAgICAgbGV0IHNlZ3MgPSBbXTtcbiAgICAgICAgaWYgKHNlcmllc1NlZykge1xuICAgICAgICAgICAgbGV0IHsgZmlyc3RJbmRleCwgbGFzdEluZGV4IH0gPSBzZXJpZXNTZWc7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSBmaXJzdEluZGV4O1xuICAgICAgICAgICAgd2hpbGUgKGluZGV4IDw9IGxhc3RJbmRleCkge1xuICAgICAgICAgICAgICAgIGxldCByb3cgPSBNYXRoLmZsb29yKGluZGV4IC8gY29sQ250KTtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dEluZGV4ID0gTWF0aC5taW4oKHJvdyArIDEpICogY29sQ250LCBsYXN0SW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICBzZWdzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICByb3csXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0Q29sOiBpbmRleCAlIGNvbENudCxcbiAgICAgICAgICAgICAgICAgICAgbGFzdENvbDogKG5leHRJbmRleCAtIDEpICUgY29sQ250LFxuICAgICAgICAgICAgICAgICAgICBpc1N0YXJ0OiBzZXJpZXNTZWcuaXNTdGFydCAmJiBpbmRleCA9PT0gZmlyc3RJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgaXNFbmQ6IHNlcmllc1NlZy5pc0VuZCAmJiAobmV4dEluZGV4IC0gMSkgPT09IGxhc3RJbmRleCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpbmRleCA9IG5leHRJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VncztcbiAgICB9XG59XG5cbmNsYXNzIFNsaWNlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc2xpY2VCdXNpbmVzc0hvdXJzID0gbWVtb2l6ZSh0aGlzLl9zbGljZUJ1c2luZXNzSG91cnMpO1xuICAgICAgICB0aGlzLnNsaWNlRGF0ZVNlbGVjdGlvbiA9IG1lbW9pemUodGhpcy5fc2xpY2VEYXRlU3Bhbik7XG4gICAgICAgIHRoaXMuc2xpY2VFdmVudFN0b3JlID0gbWVtb2l6ZSh0aGlzLl9zbGljZUV2ZW50U3RvcmUpO1xuICAgICAgICB0aGlzLnNsaWNlRXZlbnREcmFnID0gbWVtb2l6ZSh0aGlzLl9zbGljZUludGVyYWN0aW9uKTtcbiAgICAgICAgdGhpcy5zbGljZUV2ZW50UmVzaXplID0gbWVtb2l6ZSh0aGlzLl9zbGljZUludGVyYWN0aW9uKTtcbiAgICAgICAgdGhpcy5mb3JjZURheUlmTGlzdEl0ZW0gPSBmYWxzZTsgLy8gaGFja1xuICAgIH1cbiAgICBzbGljZVByb3BzKHByb3BzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgY29udGV4dCwgLi4uZXh0cmFBcmdzKSB7XG4gICAgICAgIGxldCB7IGV2ZW50VWlCYXNlcyB9ID0gcHJvcHM7XG4gICAgICAgIGxldCBldmVudFNlZ3MgPSB0aGlzLnNsaWNlRXZlbnRTdG9yZShwcm9wcy5ldmVudFN0b3JlLCBldmVudFVpQmFzZXMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCAuLi5leHRyYUFyZ3MpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0ZVNlbGVjdGlvblNlZ3M6IHRoaXMuc2xpY2VEYXRlU2VsZWN0aW9uKHByb3BzLmRhdGVTZWxlY3Rpb24sIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCBldmVudFVpQmFzZXMsIGNvbnRleHQsIC4uLmV4dHJhQXJncyksXG4gICAgICAgICAgICBidXNpbmVzc0hvdXJTZWdzOiB0aGlzLnNsaWNlQnVzaW5lc3NIb3Vycyhwcm9wcy5idXNpbmVzc0hvdXJzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgY29udGV4dCwgLi4uZXh0cmFBcmdzKSxcbiAgICAgICAgICAgIGZnRXZlbnRTZWdzOiBldmVudFNlZ3MuZmcsXG4gICAgICAgICAgICBiZ0V2ZW50U2VnczogZXZlbnRTZWdzLmJnLFxuICAgICAgICAgICAgZXZlbnREcmFnOiB0aGlzLnNsaWNlRXZlbnREcmFnKHByb3BzLmV2ZW50RHJhZywgZXZlbnRVaUJhc2VzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgLi4uZXh0cmFBcmdzKSxcbiAgICAgICAgICAgIGV2ZW50UmVzaXplOiB0aGlzLnNsaWNlRXZlbnRSZXNpemUocHJvcHMuZXZlbnRSZXNpemUsIGV2ZW50VWlCYXNlcywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIC4uLmV4dHJhQXJncyksXG4gICAgICAgICAgICBldmVudFNlbGVjdGlvbjogcHJvcHMuZXZlbnRTZWxlY3Rpb24sXG4gICAgICAgIH07IC8vIFRPRE86IGdpdmUgaW50ZXJhY3Rpb25TZWdzP1xuICAgIH1cbiAgICBzbGljZU5vd0RhdGUoLy8gZG9lcyBub3QgbWVtb2l6ZVxuICAgIGRhdGUsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCBjb250ZXh0LCAuLi5leHRyYUFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NsaWNlRGF0ZVNwYW4oeyByYW5nZTogeyBzdGFydDogZGF0ZSwgZW5kOiBhZGRNcyhkYXRlLCAxKSB9LCBhbGxEYXk6IGZhbHNlIH0sIC8vIGFkZCAxIG1zLCBwcm90ZWN0IGFnYWluc3QgbnVsbCByYW5nZVxuICAgICAgICBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwge30sIGNvbnRleHQsIC4uLmV4dHJhQXJncyk7XG4gICAgfVxuICAgIF9zbGljZUJ1c2luZXNzSG91cnMoYnVzaW5lc3NIb3VycywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIGNvbnRleHQsIC4uLmV4dHJhQXJncykge1xuICAgICAgICBpZiAoIWJ1c2luZXNzSG91cnMpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc2xpY2VFdmVudFN0b3JlKGV4cGFuZFJlY3VycmluZyhidXNpbmVzc0hvdXJzLCBjb21wdXRlQWN0aXZlUmFuZ2UoZGF0ZVByb2ZpbGUsIEJvb2xlYW4obmV4dERheVRocmVzaG9sZCkpLCBjb250ZXh0KSwge30sIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCAuLi5leHRyYUFyZ3MpLmJnO1xuICAgIH1cbiAgICBfc2xpY2VFdmVudFN0b3JlKGV2ZW50U3RvcmUsIGV2ZW50VWlCYXNlcywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIC4uLmV4dHJhQXJncykge1xuICAgICAgICBpZiAoZXZlbnRTdG9yZSkge1xuICAgICAgICAgICAgbGV0IHJhbmdlUmVzID0gc2xpY2VFdmVudFN0b3JlKGV2ZW50U3RvcmUsIGV2ZW50VWlCYXNlcywgY29tcHV0ZUFjdGl2ZVJhbmdlKGRhdGVQcm9maWxlLCBCb29sZWFuKG5leHREYXlUaHJlc2hvbGQpKSwgbmV4dERheVRocmVzaG9sZCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJnOiB0aGlzLnNsaWNlRXZlbnRSYW5nZXMocmFuZ2VSZXMuYmcsIGV4dHJhQXJncyksXG4gICAgICAgICAgICAgICAgZmc6IHRoaXMuc2xpY2VFdmVudFJhbmdlcyhyYW5nZVJlcy5mZywgZXh0cmFBcmdzKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgYmc6IFtdLCBmZzogW10gfTtcbiAgICB9XG4gICAgX3NsaWNlSW50ZXJhY3Rpb24oaW50ZXJhY3Rpb24sIGV2ZW50VWlCYXNlcywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIC4uLmV4dHJhQXJncykge1xuICAgICAgICBpZiAoIWludGVyYWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmFuZ2VSZXMgPSBzbGljZUV2ZW50U3RvcmUoaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cywgZXZlbnRVaUJhc2VzLCBjb21wdXRlQWN0aXZlUmFuZ2UoZGF0ZVByb2ZpbGUsIEJvb2xlYW4obmV4dERheVRocmVzaG9sZCkpLCBuZXh0RGF5VGhyZXNob2xkKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNlZ3M6IHRoaXMuc2xpY2VFdmVudFJhbmdlcyhyYW5nZVJlcy5mZywgZXh0cmFBcmdzKSxcbiAgICAgICAgICAgIGFmZmVjdGVkSW5zdGFuY2VzOiBpbnRlcmFjdGlvbi5hZmZlY3RlZEV2ZW50cy5pbnN0YW5jZXMsXG4gICAgICAgICAgICBpc0V2ZW50OiBpbnRlcmFjdGlvbi5pc0V2ZW50LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfc2xpY2VEYXRlU3BhbihkYXRlU3BhbiwgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIGV2ZW50VWlCYXNlcywgY29udGV4dCwgLi4uZXh0cmFBcmdzKSB7XG4gICAgICAgIGlmICghZGF0ZVNwYW4pIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYWN0aXZlUmFuZ2UgPSBjb21wdXRlQWN0aXZlUmFuZ2UoZGF0ZVByb2ZpbGUsIEJvb2xlYW4obmV4dERheVRocmVzaG9sZCkpO1xuICAgICAgICBsZXQgYWN0aXZlRGF0ZVNwYW5SYW5nZSA9IGludGVyc2VjdFJhbmdlcyhkYXRlU3Bhbi5yYW5nZSwgYWN0aXZlUmFuZ2UpO1xuICAgICAgICBpZiAoYWN0aXZlRGF0ZVNwYW5SYW5nZSkge1xuICAgICAgICAgICAgZGF0ZVNwYW4gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRhdGVTcGFuKSwgeyByYW5nZTogYWN0aXZlRGF0ZVNwYW5SYW5nZSB9KTtcbiAgICAgICAgICAgIGxldCBldmVudFJhbmdlID0gZmFicmljYXRlRXZlbnRSYW5nZShkYXRlU3BhbiwgZXZlbnRVaUJhc2VzLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGxldCBzZWdzID0gdGhpcy5zbGljZVJhbmdlKGRhdGVTcGFuLnJhbmdlLCAuLi5leHRyYUFyZ3MpO1xuICAgICAgICAgICAgZm9yIChsZXQgc2VnIG9mIHNlZ3MpIHtcbiAgICAgICAgICAgICAgICBzZWcuZXZlbnRSYW5nZSA9IGV2ZW50UmFuZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2VncztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIC8qXG4gICAgXCJjb21wbGV0ZVwiIHNlZyBtZWFucyBpdCBoYXMgY29tcG9uZW50IGFuZCBldmVudFJhbmdlXG4gICAgKi9cbiAgICBzbGljZUV2ZW50UmFuZ2VzKGV2ZW50UmFuZ2VzLCBleHRyYUFyZ3MpIHtcbiAgICAgICAgbGV0IHNlZ3MgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZXZlbnRSYW5nZSBvZiBldmVudFJhbmdlcykge1xuICAgICAgICAgICAgc2Vncy5wdXNoKC4uLnRoaXMuc2xpY2VFdmVudFJhbmdlKGV2ZW50UmFuZ2UsIGV4dHJhQXJncykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWdzO1xuICAgIH1cbiAgICAvKlxuICAgIFwiY29tcGxldGVcIiBzZWcgbWVhbnMgaXQgaGFzIGNvbXBvbmVudCBhbmQgZXZlbnRSYW5nZVxuICAgICovXG4gICAgc2xpY2VFdmVudFJhbmdlKGV2ZW50UmFuZ2UsIGV4dHJhQXJncykge1xuICAgICAgICBsZXQgZGF0ZVJhbmdlID0gZXZlbnRSYW5nZS5yYW5nZTtcbiAgICAgICAgLy8gaGFjayB0byBtYWtlIG11bHRpLWRheSBldmVudHMgdGhhdCBhcmUgYmVpbmcgZm9yY2UtZGlzcGxheWVkIGFzIGxpc3QtaXRlbXMgdG8gdGFrZSB1cCBvbmx5IG9uZSBkYXlcbiAgICAgICAgaWYgKHRoaXMuZm9yY2VEYXlJZkxpc3RJdGVtICYmIGV2ZW50UmFuZ2UudWkuZGlzcGxheSA9PT0gJ2xpc3QtaXRlbScpIHtcbiAgICAgICAgICAgIGRhdGVSYW5nZSA9IHtcbiAgICAgICAgICAgICAgICBzdGFydDogZGF0ZVJhbmdlLnN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZDogYWRkRGF5cyhkYXRlUmFuZ2Uuc3RhcnQsIDEpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2VncyA9IHRoaXMuc2xpY2VSYW5nZShkYXRlUmFuZ2UsIC4uLmV4dHJhQXJncyk7XG4gICAgICAgIGZvciAobGV0IHNlZyBvZiBzZWdzKSB7XG4gICAgICAgICAgICBzZWcuZXZlbnRSYW5nZSA9IGV2ZW50UmFuZ2U7XG4gICAgICAgICAgICBzZWcuaXNTdGFydCA9IGV2ZW50UmFuZ2UuaXNTdGFydCAmJiBzZWcuaXNTdGFydDtcbiAgICAgICAgICAgIHNlZy5pc0VuZCA9IGV2ZW50UmFuZ2UuaXNFbmQgJiYgc2VnLmlzRW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWdzO1xuICAgIH1cbn1cbi8qXG5mb3IgaW5jb3Jwb3JhdGluZyBzbG90TWluVGltZS9zbG90TWF4VGltZSBpZiBhcHByb3ByaWF0ZVxuVE9ETzogc2hvdWxkIGJlIHBhcnQgb2YgRGF0ZVByb2ZpbGUhXG5UaW1lbGluZURhdGVQcm9maWxlIGFscmVhZHkgZG9lcyB0aGlzIGJ0d1xuKi9cbmZ1bmN0aW9uIGNvbXB1dGVBY3RpdmVSYW5nZShkYXRlUHJvZmlsZSwgaXNDb21wb25lbnRBbGxEYXkpIHtcbiAgICBsZXQgcmFuZ2UgPSBkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZTtcbiAgICBpZiAoaXNDb21wb25lbnRBbGxEYXkpIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogYWRkTXMocmFuZ2Uuc3RhcnQsIGRhdGVQcm9maWxlLnNsb3RNaW5UaW1lLm1pbGxpc2Vjb25kcyksXG4gICAgICAgIGVuZDogYWRkTXMocmFuZ2UuZW5kLCBkYXRlUHJvZmlsZS5zbG90TWF4VGltZS5taWxsaXNlY29uZHMgLSA4NjRlNSksIC8vIDg2NGU1ID0gbXMgaW4gYSBkYXlcbiAgICB9O1xufVxuXG4vLyBoaWdoLWxldmVsIHNlZ21lbnRpbmctYXdhcmUgdGVzdGVyIGZ1bmN0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBpc0ludGVyYWN0aW9uVmFsaWQoaW50ZXJhY3Rpb24sIGRhdGVQcm9maWxlLCBjb250ZXh0KSB7XG4gICAgbGV0IHsgaW5zdGFuY2VzIH0gPSBpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzO1xuICAgIGZvciAobGV0IGluc3RhbmNlSWQgaW4gaW5zdGFuY2VzKSB7XG4gICAgICAgIGlmICghcmFuZ2VDb250YWluc1JhbmdlKGRhdGVQcm9maWxlLnZhbGlkUmFuZ2UsIGluc3RhbmNlc1tpbnN0YW5jZUlkXS5yYW5nZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaXNOZXdQcm9wc1ZhbGlkKHsgZXZlbnREcmFnOiBpbnRlcmFjdGlvbiB9LCBjb250ZXh0KTsgLy8gSEFDSzogdGhlIGV2ZW50RHJhZyBwcm9wcyBpcyB1c2VkIGZvciBBTEwgaW50ZXJhY3Rpb25zXG59XG5mdW5jdGlvbiBpc0RhdGVTZWxlY3Rpb25WYWxpZChkYXRlU2VsZWN0aW9uLCBkYXRlUHJvZmlsZSwgY29udGV4dCkge1xuICAgIGlmICghcmFuZ2VDb250YWluc1JhbmdlKGRhdGVQcm9maWxlLnZhbGlkUmFuZ2UsIGRhdGVTZWxlY3Rpb24ucmFuZ2UpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzTmV3UHJvcHNWYWxpZCh7IGRhdGVTZWxlY3Rpb24gfSwgY29udGV4dCk7XG59XG5mdW5jdGlvbiBpc05ld1Byb3BzVmFsaWQobmV3UHJvcHMsIGNvbnRleHQpIHtcbiAgICBsZXQgY2FsZW5kYXJTdGF0ZSA9IGNvbnRleHQuZ2V0Q3VycmVudERhdGEoKTtcbiAgICBsZXQgcHJvcHMgPSBPYmplY3QuYXNzaWduKHsgYnVzaW5lc3NIb3VyczogY2FsZW5kYXJTdGF0ZS5idXNpbmVzc0hvdXJzLCBkYXRlU2VsZWN0aW9uOiAnJywgZXZlbnRTdG9yZTogY2FsZW5kYXJTdGF0ZS5ldmVudFN0b3JlLCBldmVudFVpQmFzZXM6IGNhbGVuZGFyU3RhdGUuZXZlbnRVaUJhc2VzLCBldmVudFNlbGVjdGlvbjogJycsIGV2ZW50RHJhZzogbnVsbCwgZXZlbnRSZXNpemU6IG51bGwgfSwgbmV3UHJvcHMpO1xuICAgIHJldHVybiAoY29udGV4dC5wbHVnaW5Ib29rcy5pc1Byb3BzVmFsaWQgfHwgaXNQcm9wc1ZhbGlkKShwcm9wcywgY29udGV4dCk7XG59XG5mdW5jdGlvbiBpc1Byb3BzVmFsaWQoc3RhdGUsIGNvbnRleHQsIGRhdGVTcGFuTWV0YSA9IHt9LCBmaWx0ZXJDb25maWcpIHtcbiAgICBpZiAoc3RhdGUuZXZlbnREcmFnICYmICFpc0ludGVyYWN0aW9uUHJvcHNWYWxpZChzdGF0ZSwgY29udGV4dCwgZGF0ZVNwYW5NZXRhLCBmaWx0ZXJDb25maWcpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLmRhdGVTZWxlY3Rpb24gJiYgIWlzRGF0ZVNlbGVjdGlvblByb3BzVmFsaWQoc3RhdGUsIGNvbnRleHQsIGRhdGVTcGFuTWV0YSwgZmlsdGVyQ29uZmlnKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLy8gTW92aW5nIEV2ZW50IFZhbGlkYXRpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gaXNJbnRlcmFjdGlvblByb3BzVmFsaWQoc3RhdGUsIGNvbnRleHQsIGRhdGVTcGFuTWV0YSwgZmlsdGVyQ29uZmlnKSB7XG4gICAgbGV0IGN1cnJlbnRTdGF0ZSA9IGNvbnRleHQuZ2V0Q3VycmVudERhdGEoKTtcbiAgICBsZXQgaW50ZXJhY3Rpb24gPSBzdGF0ZS5ldmVudERyYWc7IC8vIEhBQ0s6IHRoZSBldmVudERyYWcgcHJvcHMgaXMgdXNlZCBmb3IgQUxMIGludGVyYWN0aW9uc1xuICAgIGxldCBzdWJqZWN0RXZlbnRTdG9yZSA9IGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHM7XG4gICAgbGV0IHN1YmplY3REZWZzID0gc3ViamVjdEV2ZW50U3RvcmUuZGVmcztcbiAgICBsZXQgc3ViamVjdEluc3RhbmNlcyA9IHN1YmplY3RFdmVudFN0b3JlLmluc3RhbmNlcztcbiAgICBsZXQgc3ViamVjdENvbmZpZ3MgPSBjb21waWxlRXZlbnRVaXMoc3ViamVjdERlZnMsIGludGVyYWN0aW9uLmlzRXZlbnQgP1xuICAgICAgICBzdGF0ZS5ldmVudFVpQmFzZXMgOlxuICAgICAgICB7ICcnOiBjdXJyZW50U3RhdGUuc2VsZWN0aW9uQ29uZmlnIH0pO1xuICAgIGlmIChmaWx0ZXJDb25maWcpIHtcbiAgICAgICAgc3ViamVjdENvbmZpZ3MgPSBtYXBIYXNoKHN1YmplY3RDb25maWdzLCBmaWx0ZXJDb25maWcpO1xuICAgIH1cbiAgICAvLyBleGNsdWRlIHRoZSBzdWJqZWN0IGV2ZW50cy4gVE9ETzogZXhjbHVkZSBkZWZzIHRvbz9cbiAgICBsZXQgb3RoZXJFdmVudFN0b3JlID0gZXhjbHVkZUluc3RhbmNlcyhzdGF0ZS5ldmVudFN0b3JlLCBpbnRlcmFjdGlvbi5hZmZlY3RlZEV2ZW50cy5pbnN0YW5jZXMpO1xuICAgIGxldCBvdGhlckRlZnMgPSBvdGhlckV2ZW50U3RvcmUuZGVmcztcbiAgICBsZXQgb3RoZXJJbnN0YW5jZXMgPSBvdGhlckV2ZW50U3RvcmUuaW5zdGFuY2VzO1xuICAgIGxldCBvdGhlckNvbmZpZ3MgPSBjb21waWxlRXZlbnRVaXMob3RoZXJEZWZzLCBzdGF0ZS5ldmVudFVpQmFzZXMpO1xuICAgIGZvciAobGV0IHN1YmplY3RJbnN0YW5jZUlkIGluIHN1YmplY3RJbnN0YW5jZXMpIHtcbiAgICAgICAgbGV0IHN1YmplY3RJbnN0YW5jZSA9IHN1YmplY3RJbnN0YW5jZXNbc3ViamVjdEluc3RhbmNlSWRdO1xuICAgICAgICBsZXQgc3ViamVjdFJhbmdlID0gc3ViamVjdEluc3RhbmNlLnJhbmdlO1xuICAgICAgICBsZXQgc3ViamVjdENvbmZpZyA9IHN1YmplY3RDb25maWdzW3N1YmplY3RJbnN0YW5jZS5kZWZJZF07XG4gICAgICAgIGxldCBzdWJqZWN0RGVmID0gc3ViamVjdERlZnNbc3ViamVjdEluc3RhbmNlLmRlZklkXTtcbiAgICAgICAgLy8gY29uc3RyYWludFxuICAgICAgICBpZiAoIWFsbENvbnN0cmFpbnRzUGFzcyhzdWJqZWN0Q29uZmlnLmNvbnN0cmFpbnRzLCBzdWJqZWN0UmFuZ2UsIG90aGVyRXZlbnRTdG9yZSwgc3RhdGUuYnVzaW5lc3NIb3VycywgY29udGV4dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvdmVybGFwXG4gICAgICAgIGxldCB7IGV2ZW50T3ZlcmxhcCB9ID0gY29udGV4dC5vcHRpb25zO1xuICAgICAgICBsZXQgZXZlbnRPdmVybGFwRnVuYyA9IHR5cGVvZiBldmVudE92ZXJsYXAgPT09ICdmdW5jdGlvbicgPyBldmVudE92ZXJsYXAgOiBudWxsO1xuICAgICAgICBmb3IgKGxldCBvdGhlckluc3RhbmNlSWQgaW4gb3RoZXJJbnN0YW5jZXMpIHtcbiAgICAgICAgICAgIGxldCBvdGhlckluc3RhbmNlID0gb3RoZXJJbnN0YW5jZXNbb3RoZXJJbnN0YW5jZUlkXTtcbiAgICAgICAgICAgIC8vIGludGVyc2VjdCEgZXZhbHVhdGVcbiAgICAgICAgICAgIGlmIChyYW5nZXNJbnRlcnNlY3Qoc3ViamVjdFJhbmdlLCBvdGhlckluc3RhbmNlLnJhbmdlKSkge1xuICAgICAgICAgICAgICAgIGxldCBvdGhlck92ZXJsYXAgPSBvdGhlckNvbmZpZ3Nbb3RoZXJJbnN0YW5jZS5kZWZJZF0ub3ZlcmxhcDtcbiAgICAgICAgICAgICAgICAvLyBjb25zaWRlciB0aGUgb3RoZXIgZXZlbnQncyBvdmVybGFwLiBvbmx5IGRvIHRoaXMgaWYgdGhlIHN1YmplY3QgZXZlbnQgaXMgYSBcInJlYWxcIiBldmVudFxuICAgICAgICAgICAgICAgIGlmIChvdGhlck92ZXJsYXAgPT09IGZhbHNlICYmIGludGVyYWN0aW9uLmlzRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3ViamVjdENvbmZpZy5vdmVybGFwID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChldmVudE92ZXJsYXBGdW5jICYmICFldmVudE92ZXJsYXBGdW5jKG5ldyBFdmVudEltcGwoY29udGV4dCwgb3RoZXJEZWZzW290aGVySW5zdGFuY2UuZGVmSWRdLCBvdGhlckluc3RhbmNlKSwgLy8gc3RpbGwgZXZlbnRcbiAgICAgICAgICAgICAgICBuZXcgRXZlbnRJbXBsKGNvbnRleHQsIHN1YmplY3REZWYsIHN1YmplY3RJbnN0YW5jZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWxsb3cgKGEgZnVuY3Rpb24pXG4gICAgICAgIGxldCBjYWxlbmRhckV2ZW50U3RvcmUgPSBjdXJyZW50U3RhdGUuZXZlbnRTdG9yZTsgLy8gbmVlZCBnbG9iYWwtdG8tY2FsZW5kYXIsIG5vdCBsb2NhbCB0byBjb21wb25lbnQgKHNwbGl0dGFibGUpc3RhdGVcbiAgICAgICAgZm9yIChsZXQgc3ViamVjdEFsbG93IG9mIHN1YmplY3RDb25maWcuYWxsb3dzKSB7XG4gICAgICAgICAgICBsZXQgc3ViamVjdERhdGVTcGFuID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkYXRlU3Bhbk1ldGEpLCB7IHJhbmdlOiBzdWJqZWN0SW5zdGFuY2UucmFuZ2UsIGFsbERheTogc3ViamVjdERlZi5hbGxEYXkgfSk7XG4gICAgICAgICAgICBsZXQgb3JpZ0RlZiA9IGNhbGVuZGFyRXZlbnRTdG9yZS5kZWZzW3N1YmplY3REZWYuZGVmSWRdO1xuICAgICAgICAgICAgbGV0IG9yaWdJbnN0YW5jZSA9IGNhbGVuZGFyRXZlbnRTdG9yZS5pbnN0YW5jZXNbc3ViamVjdEluc3RhbmNlSWRdO1xuICAgICAgICAgICAgbGV0IGV2ZW50QXBpO1xuICAgICAgICAgICAgaWYgKG9yaWdEZWYpIHsgLy8gd2FzIHByZXZpb3VzbHkgaW4gdGhlIGNhbGVuZGFyXG4gICAgICAgICAgICAgICAgZXZlbnRBcGkgPSBuZXcgRXZlbnRJbXBsKGNvbnRleHQsIG9yaWdEZWYsIG9yaWdJbnN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHsgLy8gd2FzIGFuIGV4dGVybmFsIGV2ZW50XG4gICAgICAgICAgICAgICAgZXZlbnRBcGkgPSBuZXcgRXZlbnRJbXBsKGNvbnRleHQsIHN1YmplY3REZWYpOyAvLyBubyBpbnN0YW5jZSwgYmVjYXVzZSBoYWQgbm8gZGF0ZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3ViamVjdEFsbG93KGJ1aWxkRGF0ZVNwYW5BcGlXaXRoQ29udGV4dChzdWJqZWN0RGF0ZVNwYW4sIGNvbnRleHQpLCBldmVudEFwaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyBEYXRlIFNlbGVjdGlvbiBWYWxpZGF0aW9uXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGlzRGF0ZVNlbGVjdGlvblByb3BzVmFsaWQoc3RhdGUsIGNvbnRleHQsIGRhdGVTcGFuTWV0YSwgZmlsdGVyQ29uZmlnKSB7XG4gICAgbGV0IHJlbGV2YW50RXZlbnRTdG9yZSA9IHN0YXRlLmV2ZW50U3RvcmU7XG4gICAgbGV0IHJlbGV2YW50RGVmcyA9IHJlbGV2YW50RXZlbnRTdG9yZS5kZWZzO1xuICAgIGxldCByZWxldmFudEluc3RhbmNlcyA9IHJlbGV2YW50RXZlbnRTdG9yZS5pbnN0YW5jZXM7XG4gICAgbGV0IHNlbGVjdGlvbiA9IHN0YXRlLmRhdGVTZWxlY3Rpb247XG4gICAgbGV0IHNlbGVjdGlvblJhbmdlID0gc2VsZWN0aW9uLnJhbmdlO1xuICAgIGxldCB7IHNlbGVjdGlvbkNvbmZpZyB9ID0gY29udGV4dC5nZXRDdXJyZW50RGF0YSgpO1xuICAgIGlmIChmaWx0ZXJDb25maWcpIHtcbiAgICAgICAgc2VsZWN0aW9uQ29uZmlnID0gZmlsdGVyQ29uZmlnKHNlbGVjdGlvbkNvbmZpZyk7XG4gICAgfVxuICAgIC8vIGNvbnN0cmFpbnRcbiAgICBpZiAoIWFsbENvbnN0cmFpbnRzUGFzcyhzZWxlY3Rpb25Db25maWcuY29uc3RyYWludHMsIHNlbGVjdGlvblJhbmdlLCByZWxldmFudEV2ZW50U3RvcmUsIHN0YXRlLmJ1c2luZXNzSG91cnMsIGNvbnRleHQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gb3ZlcmxhcFxuICAgIGxldCB7IHNlbGVjdE92ZXJsYXAgfSA9IGNvbnRleHQub3B0aW9ucztcbiAgICBsZXQgc2VsZWN0T3ZlcmxhcEZ1bmMgPSB0eXBlb2Ygc2VsZWN0T3ZlcmxhcCA9PT0gJ2Z1bmN0aW9uJyA/IHNlbGVjdE92ZXJsYXAgOiBudWxsO1xuICAgIGZvciAobGV0IHJlbGV2YW50SW5zdGFuY2VJZCBpbiByZWxldmFudEluc3RhbmNlcykge1xuICAgICAgICBsZXQgcmVsZXZhbnRJbnN0YW5jZSA9IHJlbGV2YW50SW5zdGFuY2VzW3JlbGV2YW50SW5zdGFuY2VJZF07XG4gICAgICAgIC8vIGludGVyc2VjdCEgZXZhbHVhdGVcbiAgICAgICAgaWYgKHJhbmdlc0ludGVyc2VjdChzZWxlY3Rpb25SYW5nZSwgcmVsZXZhbnRJbnN0YW5jZS5yYW5nZSkpIHtcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb25Db25maWcub3ZlcmxhcCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZWN0T3ZlcmxhcEZ1bmMgJiYgIXNlbGVjdE92ZXJsYXBGdW5jKG5ldyBFdmVudEltcGwoY29udGV4dCwgcmVsZXZhbnREZWZzW3JlbGV2YW50SW5zdGFuY2UuZGVmSWRdLCByZWxldmFudEluc3RhbmNlKSwgbnVsbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYWxsb3cgKGEgZnVuY3Rpb24pXG4gICAgZm9yIChsZXQgc2VsZWN0aW9uQWxsb3cgb2Ygc2VsZWN0aW9uQ29uZmlnLmFsbG93cykge1xuICAgICAgICBsZXQgZnVsbERhdGVTcGFuID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkYXRlU3Bhbk1ldGEpLCBzZWxlY3Rpb24pO1xuICAgICAgICBpZiAoIXNlbGVjdGlvbkFsbG93KGJ1aWxkRGF0ZVNwYW5BcGlXaXRoQ29udGV4dChmdWxsRGF0ZVNwYW4sIGNvbnRleHQpLCBudWxsKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLy8gQ29uc3RyYWludCBVdGlsc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBhbGxDb25zdHJhaW50c1Bhc3MoY29uc3RyYWludHMsIHN1YmplY3RSYW5nZSwgb3RoZXJFdmVudFN0b3JlLCBidXNpbmVzc0hvdXJzVW5leHBhbmRlZCwgY29udGV4dCkge1xuICAgIGZvciAobGV0IGNvbnN0cmFpbnQgb2YgY29uc3RyYWludHMpIHtcbiAgICAgICAgaWYgKCFhbnlSYW5nZXNDb250YWluUmFuZ2UoY29uc3RyYWludFRvUmFuZ2VzKGNvbnN0cmFpbnQsIHN1YmplY3RSYW5nZSwgb3RoZXJFdmVudFN0b3JlLCBidXNpbmVzc0hvdXJzVW5leHBhbmRlZCwgY29udGV4dCksIHN1YmplY3RSYW5nZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNvbnN0cmFpbnRUb1Jhbmdlcyhjb25zdHJhaW50LCBzdWJqZWN0UmFuZ2UsIC8vIGZvciBleHBhbmRpbmcgYSByZWN1cnJpbmcgY29uc3RyYWludCwgb3IgZXhwYW5kaW5nIGJ1c2luZXNzIGhvdXJzXG5vdGhlckV2ZW50U3RvcmUsIC8vIGZvciBpZiBjb25zdHJhaW50IGlzIGFuIGV2ZW4gZ3JvdXAgSURcbmJ1c2luZXNzSG91cnNVbmV4cGFuZGVkLCAvLyBmb3IgaWYgY29uc3RyYWludCBpcyAnYnVzaW5lc3NIb3VycydcbmNvbnRleHQpIHtcbiAgICBpZiAoY29uc3RyYWludCA9PT0gJ2J1c2luZXNzSG91cnMnKSB7XG4gICAgICAgIHJldHVybiBldmVudFN0b3JlVG9SYW5nZXMoZXhwYW5kUmVjdXJyaW5nKGJ1c2luZXNzSG91cnNVbmV4cGFuZGVkLCBzdWJqZWN0UmFuZ2UsIGNvbnRleHQpKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb25zdHJhaW50ID09PSAnc3RyaW5nJykgeyAvLyBhbiBncm91cCBJRFxuICAgICAgICByZXR1cm4gZXZlbnRTdG9yZVRvUmFuZ2VzKGZpbHRlckV2ZW50U3RvcmVEZWZzKG90aGVyRXZlbnRTdG9yZSwgKGV2ZW50RGVmKSA9PiBldmVudERlZi5ncm91cElkID09PSBjb25zdHJhaW50KSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY29uc3RyYWludCA9PT0gJ29iamVjdCcgJiYgY29uc3RyYWludCkgeyAvLyBub24tbnVsbCBvYmplY3RcbiAgICAgICAgcmV0dXJuIGV2ZW50U3RvcmVUb1JhbmdlcyhleHBhbmRSZWN1cnJpbmcoY29uc3RyYWludCwgc3ViamVjdFJhbmdlLCBjb250ZXh0KSk7XG4gICAgfVxuICAgIHJldHVybiBbXTsgLy8gaWYgaXQncyBmYWxzZVxufVxuLy8gVE9ETzogbW92ZSB0byBldmVudC1zdG9yZSBmaWxlP1xuZnVuY3Rpb24gZXZlbnRTdG9yZVRvUmFuZ2VzKGV2ZW50U3RvcmUpIHtcbiAgICBsZXQgeyBpbnN0YW5jZXMgfSA9IGV2ZW50U3RvcmU7XG4gICAgbGV0IHJhbmdlcyA9IFtdO1xuICAgIGZvciAobGV0IGluc3RhbmNlSWQgaW4gaW5zdGFuY2VzKSB7XG4gICAgICAgIHJhbmdlcy5wdXNoKGluc3RhbmNlc1tpbnN0YW5jZUlkXS5yYW5nZSk7XG4gICAgfVxuICAgIHJldHVybiByYW5nZXM7XG59XG4vLyBUT0RPOiBtb3ZlIHRvIGdlb20gZmlsZT9cbmZ1bmN0aW9uIGFueVJhbmdlc0NvbnRhaW5SYW5nZShvdXRlclJhbmdlcywgaW5uZXJSYW5nZSkge1xuICAgIGZvciAobGV0IG91dGVyUmFuZ2Ugb2Ygb3V0ZXJSYW5nZXMpIHtcbiAgICAgICAgaWYgKHJhbmdlQ29udGFpbnNSYW5nZShvdXRlclJhbmdlLCBpbm5lclJhbmdlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5jb25zdCBWSVNJQkxFX0hJRERFTl9SRSA9IC9eKHZpc2libGV8aGlkZGVuKSQvO1xuY2xhc3MgU2Nyb2xsZXIgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVFbCA9IChlbCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICAgICAgc2V0UmVmKHRoaXMucHJvcHMuZWxSZWYsIGVsKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgbGlxdWlkLCBsaXF1aWRJc0Fic29sdXRlIH0gPSBwcm9wcztcbiAgICAgICAgbGV0IGlzQWJzb2x1dGUgPSBsaXF1aWQgJiYgbGlxdWlkSXNBYnNvbHV0ZTtcbiAgICAgICAgbGV0IGNsYXNzTmFtZSA9IFsnZmMtc2Nyb2xsZXInXTtcbiAgICAgICAgaWYgKGxpcXVpZCkge1xuICAgICAgICAgICAgaWYgKGxpcXVpZElzQWJzb2x1dGUpIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWUucHVzaCgnZmMtc2Nyb2xsZXItbGlxdWlkLWFic29sdXRlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWUucHVzaCgnZmMtc2Nyb2xsZXItbGlxdWlkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiB0aGlzLmhhbmRsZUVsLCBjbGFzc05hbWU6IGNsYXNzTmFtZS5qb2luKCcgJyksIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3dYOiBwcm9wcy5vdmVyZmxvd1gsXG4gICAgICAgICAgICAgICAgb3ZlcmZsb3dZOiBwcm9wcy5vdmVyZmxvd1ksXG4gICAgICAgICAgICAgICAgbGVmdDogKGlzQWJzb2x1dGUgJiYgLShwcm9wcy5vdmVyY29tZUxlZnQgfHwgMCkpIHx8ICcnLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiAoaXNBYnNvbHV0ZSAmJiAtKHByb3BzLm92ZXJjb21lUmlnaHQgfHwgMCkpIHx8ICcnLFxuICAgICAgICAgICAgICAgIGJvdHRvbTogKGlzQWJzb2x1dGUgJiYgLShwcm9wcy5vdmVyY29tZUJvdHRvbSB8fCAwKSkgfHwgJycsXG4gICAgICAgICAgICAgICAgbWFyZ2luTGVmdDogKCFpc0Fic29sdXRlICYmIC0ocHJvcHMub3ZlcmNvbWVMZWZ0IHx8IDApKSB8fCAnJyxcbiAgICAgICAgICAgICAgICBtYXJnaW5SaWdodDogKCFpc0Fic29sdXRlICYmIC0ocHJvcHMub3ZlcmNvbWVSaWdodCB8fCAwKSkgfHwgJycsXG4gICAgICAgICAgICAgICAgbWFyZ2luQm90dG9tOiAoIWlzQWJzb2x1dGUgJiYgLShwcm9wcy5vdmVyY29tZUJvdHRvbSB8fCAwKSkgfHwgJycsXG4gICAgICAgICAgICAgICAgbWF4SGVpZ2h0OiBwcm9wcy5tYXhIZWlnaHQgfHwgJycsXG4gICAgICAgICAgICB9IH0sIHByb3BzLmNoaWxkcmVuKSk7XG4gICAgfVxuICAgIG5lZWRzWFNjcm9sbGluZygpIHtcbiAgICAgICAgaWYgKFZJU0lCTEVfSElEREVOX1JFLnRlc3QodGhpcy5wcm9wcy5vdmVyZmxvd1gpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGVzdGluZyBzY3JvbGxXaWR0aD5jbGllbnRXaWR0aCBpcyB1bnJlbGlhYmxlIGNyb3NzLWJyb3dzZXIgd2hlbiBwaXhlbCBoZWlnaHRzIGFyZW4ndCBpbnRlZ2Vycy5cbiAgICAgICAgLy8gbXVjaCBtb3JlIHJlbGlhYmxlIHRvIHNlZSBpZiBjaGlsZHJlbiBhcmUgdGFsbGVyIHRoYW4gdGhlIHNjcm9sbGVyLCBldmVuIHRobyBkb2Vzbid0IGFjY291bnQgZm9yXG4gICAgICAgIC8vIGlubmVyLWNoaWxkIG1hcmdpbnMgYW5kIGFic29sdXRlIHBvc2l0aW9uaW5nXG4gICAgICAgIGxldCB7IGVsIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcmVhbENsaWVudFdpZHRoID0gdGhpcy5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCAtIHRoaXMuZ2V0WVNjcm9sbGJhcldpZHRoKCk7XG4gICAgICAgIGxldCB7IGNoaWxkcmVuIH0gPSBlbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgbGV0IGNoaWxkRWwgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChjaGlsZEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoID4gcmVhbENsaWVudFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBuZWVkc1lTY3JvbGxpbmcoKSB7XG4gICAgICAgIGlmIChWSVNJQkxFX0hJRERFTl9SRS50ZXN0KHRoaXMucHJvcHMub3ZlcmZsb3dZKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRlc3Rpbmcgc2Nyb2xsSGVpZ2h0PmNsaWVudEhlaWdodCBpcyB1bnJlbGlhYmxlIGNyb3NzLWJyb3dzZXIgd2hlbiBwaXhlbCBoZWlnaHRzIGFyZW4ndCBpbnRlZ2Vycy5cbiAgICAgICAgLy8gbXVjaCBtb3JlIHJlbGlhYmxlIHRvIHNlZSBpZiBjaGlsZHJlbiBhcmUgdGFsbGVyIHRoYW4gdGhlIHNjcm9sbGVyLCBldmVuIHRobyBkb2Vzbid0IGFjY291bnQgZm9yXG4gICAgICAgIC8vIGlubmVyLWNoaWxkIG1hcmdpbnMgYW5kIGFic29sdXRlIHBvc2l0aW9uaW5nXG4gICAgICAgIGxldCB7IGVsIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcmVhbENsaWVudEhlaWdodCA9IHRoaXMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0IC0gdGhpcy5nZXRYU2Nyb2xsYmFyV2lkdGgoKTtcbiAgICAgICAgbGV0IHsgY2hpbGRyZW4gfSA9IGVsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGRFbCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKGNoaWxkRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0ID4gcmVhbENsaWVudEhlaWdodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0WFNjcm9sbGJhcldpZHRoKCkge1xuICAgICAgICBpZiAoVklTSUJMRV9ISURERU5fUkUudGVzdCh0aGlzLnByb3BzLm92ZXJmbG93WCkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVsLm9mZnNldEhlaWdodCAtIHRoaXMuZWwuY2xpZW50SGVpZ2h0OyAvLyBvbmx5IHdvcmtzIGJlY2F1c2Ugd2UgZ3VhcmFudGVlIG5vIGJvcmRlcnMuIFRPRE86IGFkZCB0byBDU1Mgd2l0aCBpbXBvcnRhbnQ/XG4gICAgfVxuICAgIGdldFlTY3JvbGxiYXJXaWR0aCgpIHtcbiAgICAgICAgaWYgKFZJU0lCTEVfSElEREVOX1JFLnRlc3QodGhpcy5wcm9wcy5vdmVyZmxvd1kpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lbC5vZmZzZXRXaWR0aCAtIHRoaXMuZWwuY2xpZW50V2lkdGg7IC8vIG9ubHkgd29ya3MgYmVjYXVzZSB3ZSBndWFyYW50ZWUgbm8gYm9yZGVycy4gVE9ETzogYWRkIHRvIENTUyB3aXRoIGltcG9ydGFudD9cbiAgICB9XG59XG5cbi8qXG5UT0RPOiBzb21laG93IGluZmVyIE90aGVyQXJncyBmcm9tIG1hc3RlckNhbGxiYWNrP1xuVE9ETzogaW5mZXIgUmVmVHlwZSBmcm9tIG1hc3RlckNhbGxiYWNrIGlmIHByb3ZpZGVkXG4qL1xuY2xhc3MgUmVmTWFwIHtcbiAgICBjb25zdHJ1Y3RvcihtYXN0ZXJDYWxsYmFjaykge1xuICAgICAgICB0aGlzLm1hc3RlckNhbGxiYWNrID0gbWFzdGVyQ2FsbGJhY2s7XG4gICAgICAgIHRoaXMuY3VycmVudE1hcCA9IHt9O1xuICAgICAgICB0aGlzLmRlcHRocyA9IHt9O1xuICAgICAgICB0aGlzLmNhbGxiYWNrTWFwID0ge307XG4gICAgICAgIHRoaXMuaGFuZGxlVmFsdWUgPSAodmFsLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGxldCB7IGRlcHRocywgY3VycmVudE1hcCB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCByZW1vdmVkID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgYWRkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh2YWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBmb3IgYnVnLi4uIEFDVFVBTExZOiBjYW4gcHJvYmFibHkgZG8gYXdheSB3aXRoIHRoaXMgbm93IHRoYXQgY2FsbGVycyBkb24ndCBzaGFyZSBudW1lcmljIGluZGljZXMgYW55bW9yZVxuICAgICAgICAgICAgICAgIHJlbW92ZWQgPSAoa2V5IGluIGN1cnJlbnRNYXApO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRNYXBba2V5XSA9IHZhbDtcbiAgICAgICAgICAgICAgICBkZXB0aHNba2V5XSA9IChkZXB0aHNba2V5XSB8fCAwKSArIDE7XG4gICAgICAgICAgICAgICAgYWRkZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVwdGhzW2tleV0gLT0gMTtcbiAgICAgICAgICAgICAgICBpZiAoIWRlcHRoc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjdXJyZW50TWFwW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNhbGxiYWNrTWFwW2tleV07XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm1hc3RlckNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXN0ZXJDYWxsYmFjayhudWxsLCBTdHJpbmcoa2V5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhZGRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hc3RlckNhbGxiYWNrKHZhbCwgU3RyaW5nKGtleSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgY3JlYXRlUmVmKGtleSkge1xuICAgICAgICBsZXQgcmVmQ2FsbGJhY2sgPSB0aGlzLmNhbGxiYWNrTWFwW2tleV07XG4gICAgICAgIGlmICghcmVmQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJlZkNhbGxiYWNrID0gdGhpcy5jYWxsYmFja01hcFtrZXldID0gKHZhbCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlVmFsdWUodmFsLCBTdHJpbmcoa2V5KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWZDYWxsYmFjaztcbiAgICB9XG4gICAgLy8gVE9ETzogY2hlY2sgY2FsbGVycyB0aGF0IGRvbid0IGNhcmUgYWJvdXQgb3JkZXIuIHNob3VsZCB1c2UgZ2V0QWxsIGluc3RlYWRcbiAgICAvLyBOT1RFOiB0aGlzIG1ldGhvZCBoYXMgYmVjb21lIGxlc3MgdmFsdWFibGUgbm93IHRoYXQgd2UgYXJlIGVuY291cmFnZWQgdG8gbWFwIG9yZGVyIGJ5IHNvbWUgb3RoZXIgaW5kZXhcbiAgICAvLyBUT0RPOiBwcm92aWRlIE9ORSBhcnJheS1leHBvcnQgZnVuY3Rpb24sIGJ1aWxkQXJyYXksIHdoaWNoIGZhaWxzIG9uIG5vbi1udW1lcmljIGluZGV4ZXMuIGNhbGxlciBjYW4gbWFuaXB1bGF0ZSBhbmQgXCJjb2xsZWN0XCJcbiAgICBjb2xsZWN0KHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBzdGVwKSB7XG4gICAgICAgIHJldHVybiBjb2xsZWN0RnJvbUhhc2godGhpcy5jdXJyZW50TWFwLCBzdGFydEluZGV4LCBlbmRJbmRleCwgc3RlcCk7XG4gICAgfVxuICAgIGdldEFsbCgpIHtcbiAgICAgICAgcmV0dXJuIGhhc2hWYWx1ZXNUb0FycmF5KHRoaXMuY3VycmVudE1hcCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjb21wdXRlU2hyaW5rV2lkdGgoY2h1bmtFbHMpIHtcbiAgICBsZXQgc2hyaW5rQ2VsbHMgPSBmaW5kRWxlbWVudHMoY2h1bmtFbHMsICcuZmMtc2Nyb2xsZ3JpZC1zaHJpbmsnKTtcbiAgICBsZXQgbGFyZ2VzdFdpZHRoID0gMDtcbiAgICBmb3IgKGxldCBzaHJpbmtDZWxsIG9mIHNocmlua0NlbGxzKSB7XG4gICAgICAgIGxhcmdlc3RXaWR0aCA9IE1hdGgubWF4KGxhcmdlc3RXaWR0aCwgY29tcHV0ZVNtYWxsZXN0Q2VsbFdpZHRoKHNocmlua0NlbGwpKTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGguY2VpbChsYXJnZXN0V2lkdGgpOyAvLyA8dGFibGU+IGVsZW1lbnRzIHdvcmsgYmVzdCB3aXRoIGludGVnZXJzLiByb3VuZCB1cCB0byBlbnN1cmUgY29udGVudHMgZml0c1xufVxuZnVuY3Rpb24gZ2V0U2VjdGlvbkhhc0xpcXVpZEhlaWdodChwcm9wcywgc2VjdGlvbkNvbmZpZykge1xuICAgIHJldHVybiBwcm9wcy5saXF1aWQgJiYgc2VjdGlvbkNvbmZpZy5saXF1aWQ7IC8vIGRvZXMgdGhlIHNlY3Rpb24gZG8gbGlxdWlkLWhlaWdodD8gKG5lZWQgdG8gaGF2ZSB3aG9sZSBzY3JvbGxncmlkIGxpcXVpZC1oZWlnaHQgYXMgd2VsbClcbn1cbmZ1bmN0aW9uIGdldEFsbG93WVNjcm9sbGluZyhwcm9wcywgc2VjdGlvbkNvbmZpZykge1xuICAgIHJldHVybiBzZWN0aW9uQ29uZmlnLm1heEhlaWdodCAhPSBudWxsIHx8IC8vIGlmIGl0cyBwb3NzaWJsZSBmb3IgdGhlIGhlaWdodCB0byBtYXggb3V0LCB3ZSBtaWdodCBuZWVkIHNjcm9sbGJhcnNcbiAgICAgICAgZ2V0U2VjdGlvbkhhc0xpcXVpZEhlaWdodChwcm9wcywgc2VjdGlvbkNvbmZpZyk7IC8vIGlmIHRoZSBzZWN0aW9uIGlzIGxpcXVpZCBoZWlnaHQsIGl0IG1pZ2h0IGNvbmRlbnNlIGVub3VnaCB0byByZXF1aXJlIHNjcm9sbGJhcnNcbn1cbi8vIFRPRE86IE9OTFkgdXNlIGBhcmdgLiBmb3JjZSBvdXQgaW50ZXJuYWwgZnVuY3Rpb24gdG8gdXNlIHNhbWUgQVBJXG5mdW5jdGlvbiByZW5kZXJDaHVua0NvbnRlbnQoc2VjdGlvbkNvbmZpZywgY2h1bmtDb25maWcsIGFyZywgaXNIZWFkZXIpIHtcbiAgICBsZXQgeyBleHBhbmRSb3dzIH0gPSBhcmc7XG4gICAgbGV0IGNvbnRlbnQgPSB0eXBlb2YgY2h1bmtDb25maWcuY29udGVudCA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgIGNodW5rQ29uZmlnLmNvbnRlbnQoYXJnKSA6XG4gICAgICAgIGNyZWF0ZUVsZW1lbnQoJ3RhYmxlJywge1xuICAgICAgICAgICAgcm9sZTogJ3ByZXNlbnRhdGlvbicsXG4gICAgICAgICAgICBjbGFzc05hbWU6IFtcbiAgICAgICAgICAgICAgICBjaHVua0NvbmZpZy50YWJsZUNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICBzZWN0aW9uQ29uZmlnLnN5bmNSb3dIZWlnaHRzID8gJ2ZjLXNjcm9sbGdyaWQtc3luYy10YWJsZScgOiAnJyxcbiAgICAgICAgICAgIF0uam9pbignICcpLFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBtaW5XaWR0aDogYXJnLnRhYmxlTWluV2lkdGgsXG4gICAgICAgICAgICAgICAgd2lkdGg6IGFyZy5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGV4cGFuZFJvd3MgPyBhcmcuY2xpZW50SGVpZ2h0IDogJycsIC8vIGNzcyBgaGVpZ2h0YCBvbiBhIDx0YWJsZT4gc2VydmVzIGFzIGEgbWluLWhlaWdodFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSwgYXJnLnRhYmxlQ29sR3JvdXBOb2RlLCBjcmVhdGVFbGVtZW50KGlzSGVhZGVyID8gJ3RoZWFkJyA6ICd0Ym9keScsIHtcbiAgICAgICAgICAgIHJvbGU6ICdwcmVzZW50YXRpb24nLFxuICAgICAgICB9LCB0eXBlb2YgY2h1bmtDb25maWcucm93Q29udGVudCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBjaHVua0NvbmZpZy5yb3dDb250ZW50KGFyZylcbiAgICAgICAgICAgIDogY2h1bmtDb25maWcucm93Q29udGVudCkpO1xuICAgIHJldHVybiBjb250ZW50O1xufVxuZnVuY3Rpb24gaXNDb2xQcm9wc0VxdWFsKGNvbHMwLCBjb2xzMSkge1xuICAgIHJldHVybiBpc0FycmF5c0VxdWFsKGNvbHMwLCBjb2xzMSwgaXNQcm9wc0VxdWFsKTtcbn1cbmZ1bmN0aW9uIHJlbmRlck1pY3JvQ29sR3JvdXAoY29scywgc2hyaW5rV2lkdGgpIHtcbiAgICBsZXQgY29sTm9kZXMgPSBbXTtcbiAgICAvKlxuICAgIGZvciBDb2xQcm9wcyB3aXRoIHNwYW5zLCBpdCB3b3VsZCBoYXZlIGJlZW4gZ3JlYXQgdG8gbWFrZSBhIHNpbmdsZSA8Y29sIHNwYW49XCJcIj5cbiAgICBIT1dFVkVSLCBDaHJvbWUgd2FzIGdldHRpbmcgbWVzc2luZyB1cCBkaXN0cmlidXRpbmcgdGhlIHdpZHRoIHRvIDx0ZD4vPHRoPiBlbGVtZW50cyB3aXRoIGNvbHNwYW5zLlxuICAgIFNPTFVUSU9OOiBtYWtpbmcgaW5kaXZpZHVhbCA8Y29sPiBlbGVtZW50cyBtYWtlcyBDaHJvbWUgYmVoYXZlLlxuICAgICovXG4gICAgZm9yIChsZXQgY29sUHJvcHMgb2YgY29scykge1xuICAgICAgICBsZXQgc3BhbiA9IGNvbFByb3BzLnNwYW4gfHwgMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGFuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbE5vZGVzLnB1c2goY3JlYXRlRWxlbWVudChcImNvbFwiLCB7IHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjb2xQcm9wcy53aWR0aCA9PT0gJ3NocmluaycgPyBzYW5pdGl6ZVNocmlua1dpZHRoKHNocmlua1dpZHRoKSA6IChjb2xQcm9wcy53aWR0aCB8fCAnJyksXG4gICAgICAgICAgICAgICAgICAgIG1pbldpZHRoOiBjb2xQcm9wcy5taW5XaWR0aCB8fCAnJyxcbiAgICAgICAgICAgICAgICB9IH0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgnY29sZ3JvdXAnLCB7fSwgLi4uY29sTm9kZXMpO1xufVxuZnVuY3Rpb24gc2FuaXRpemVTaHJpbmtXaWR0aChzaHJpbmtXaWR0aCkge1xuICAgIC8qIHdoeSA0PyBpZiB3ZSBkbyAwLCBpdCB3aWxsIGtpbGwgYW55IGJvcmRlciwgd2hpY2ggYXJlIG5lZWRlZCBmb3IgY29tcHV0ZVNtYWxsZXN0Q2VsbFdpZHRoXG4gICAgNCBhY2NvdW50cyBmb3IgMiAyLXBpeGVsIGJvcmRlcnMuIFRPRE86IGJldHRlciBzb2x1dGlvbj8gKi9cbiAgICByZXR1cm4gc2hyaW5rV2lkdGggPT0gbnVsbCA/IDQgOiBzaHJpbmtXaWR0aDtcbn1cbmZ1bmN0aW9uIGhhc1Nocmlua1dpZHRoKGNvbHMpIHtcbiAgICBmb3IgKGxldCBjb2wgb2YgY29scykge1xuICAgICAgICBpZiAoY29sLndpZHRoID09PSAnc2hyaW5rJykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0U2Nyb2xsR3JpZENsYXNzTmFtZXMobGlxdWlkLCBjb250ZXh0KSB7XG4gICAgbGV0IGNsYXNzTmFtZXMgPSBbXG4gICAgICAgICdmYy1zY3JvbGxncmlkJyxcbiAgICAgICAgY29udGV4dC50aGVtZS5nZXRDbGFzcygndGFibGUnKSxcbiAgICBdO1xuICAgIGlmIChsaXF1aWQpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1zY3JvbGxncmlkLWxpcXVpZCcpO1xuICAgIH1cbiAgICByZXR1cm4gY2xhc3NOYW1lcztcbn1cbmZ1bmN0aW9uIGdldFNlY3Rpb25DbGFzc05hbWVzKHNlY3Rpb25Db25maWcsIHdob2xlVGFibGVWR3Jvdykge1xuICAgIGxldCBjbGFzc05hbWVzID0gW1xuICAgICAgICAnZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uJyxcbiAgICAgICAgYGZjLXNjcm9sbGdyaWQtc2VjdGlvbi0ke3NlY3Rpb25Db25maWcudHlwZX1gLFxuICAgICAgICBzZWN0aW9uQ29uZmlnLmNsYXNzTmFtZSwgLy8gdXNlZD9cbiAgICBdO1xuICAgIGlmICh3aG9sZVRhYmxlVkdyb3cgJiYgc2VjdGlvbkNvbmZpZy5saXF1aWQgJiYgc2VjdGlvbkNvbmZpZy5tYXhIZWlnaHQgPT0gbnVsbCkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNjcm9sbGdyaWQtc2VjdGlvbi1saXF1aWQnKTtcbiAgICB9XG4gICAgaWYgKHNlY3Rpb25Db25maWcuaXNTdGlja3kpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1zY3JvbGxncmlkLXNlY3Rpb24tc3RpY2t5Jyk7XG4gICAgfVxuICAgIHJldHVybiBjbGFzc05hbWVzO1xufVxuZnVuY3Rpb24gcmVuZGVyU2Nyb2xsU2hpbShhcmcpIHtcbiAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtc2Nyb2xsZ3JpZC1zdGlja3ktc2hpbVwiLCBzdHlsZToge1xuICAgICAgICAgICAgd2lkdGg6IGFyZy5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgIG1pbldpZHRoOiBhcmcudGFibGVNaW5XaWR0aCxcbiAgICAgICAgfSB9KSk7XG59XG5mdW5jdGlvbiBnZXRTdGlja3lIZWFkZXJEYXRlcyhvcHRpb25zKSB7XG4gICAgbGV0IHsgc3RpY2t5SGVhZGVyRGF0ZXMgfSA9IG9wdGlvbnM7XG4gICAgaWYgKHN0aWNreUhlYWRlckRhdGVzID09IG51bGwgfHwgc3RpY2t5SGVhZGVyRGF0ZXMgPT09ICdhdXRvJykge1xuICAgICAgICBzdGlja3lIZWFkZXJEYXRlcyA9IG9wdGlvbnMuaGVpZ2h0ID09PSAnYXV0bycgfHwgb3B0aW9ucy52aWV3SGVpZ2h0ID09PSAnYXV0byc7XG4gICAgfVxuICAgIHJldHVybiBzdGlja3lIZWFkZXJEYXRlcztcbn1cbmZ1bmN0aW9uIGdldFN0aWNreUZvb3RlclNjcm9sbGJhcihvcHRpb25zKSB7XG4gICAgbGV0IHsgc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyIH0gPSBvcHRpb25zO1xuICAgIGlmIChzdGlja3lGb290ZXJTY3JvbGxiYXIgPT0gbnVsbCB8fCBzdGlja3lGb290ZXJTY3JvbGxiYXIgPT09ICdhdXRvJykge1xuICAgICAgICBzdGlja3lGb290ZXJTY3JvbGxiYXIgPSBvcHRpb25zLmhlaWdodCA9PT0gJ2F1dG8nIHx8IG9wdGlvbnMudmlld0hlaWdodCA9PT0gJ2F1dG8nO1xuICAgIH1cbiAgICByZXR1cm4gc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyO1xufVxuXG5jbGFzcyBTaW1wbGVTY3JvbGxHcmlkIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMucHJvY2Vzc0NvbHMgPSBtZW1vaXplKChhKSA9PiBhLCBpc0NvbFByb3BzRXF1YWwpOyAvLyBzbyB3ZSBnZXQgc2FtZSBgY29sc2AgcHJvcHMgZXZlcnkgdGltZVxuICAgICAgICAvLyB5dWNreSB0byBtZW1vaXplIFZOb2RlcywgYnV0IG11Y2ggbW9yZSBlZmZpY2llbnQgZm9yIGNvbnN1bWVyc1xuICAgICAgICB0aGlzLnJlbmRlck1pY3JvQ29sR3JvdXAgPSBtZW1vaXplKHJlbmRlck1pY3JvQ29sR3JvdXApO1xuICAgICAgICB0aGlzLnNjcm9sbGVyUmVmcyA9IG5ldyBSZWZNYXAoKTtcbiAgICAgICAgdGhpcy5zY3JvbGxlckVsUmVmcyA9IG5ldyBSZWZNYXAodGhpcy5faGFuZGxlU2Nyb2xsZXJFbC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHNocmlua1dpZHRoOiBudWxsLFxuICAgICAgICAgICAgZm9yY2VZU2Nyb2xsYmFyczogZmFsc2UsXG4gICAgICAgICAgICBzY3JvbGxlckNsaWVudFdpZHRoczoge30sXG4gICAgICAgICAgICBzY3JvbGxlckNsaWVudEhlaWdodHM6IHt9LFxuICAgICAgICB9O1xuICAgICAgICAvLyBUT0RPOiBjYW4gZG8gYSByZWFsbHkgc2ltcGxlIHByaW50LXZpZXcuIGRvbnQgbmVlZCB0byBqb2luIHJvd3NcbiAgICAgICAgdGhpcy5oYW5kbGVTaXppbmcgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNhZmVTZXRTdGF0ZShPYmplY3QuYXNzaWduKHsgc2hyaW5rV2lkdGg6IHRoaXMuY29tcHV0ZVNocmlua1dpZHRoKCkgfSwgdGhpcy5jb21wdXRlU2Nyb2xsZXJEaW1zKCkpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgc3RhdGUsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCBzZWN0aW9uQ29uZmlncyA9IHByb3BzLnNlY3Rpb25zIHx8IFtdO1xuICAgICAgICBsZXQgY29scyA9IHRoaXMucHJvY2Vzc0NvbHMocHJvcHMuY29scyk7XG4gICAgICAgIGxldCBtaWNyb0NvbEdyb3VwTm9kZSA9IHRoaXMucmVuZGVyTWljcm9Db2xHcm91cChjb2xzLCBzdGF0ZS5zaHJpbmtXaWR0aCk7XG4gICAgICAgIGxldCBjbGFzc05hbWVzID0gZ2V0U2Nyb2xsR3JpZENsYXNzTmFtZXMocHJvcHMubGlxdWlkLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHByb3BzLmNvbGxhcHNpYmxlV2lkdGgpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtc2Nyb2xsZ3JpZC1jb2xsYXBzaWJsZScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IG1ha2UgRFJZXG4gICAgICAgIGxldCBjb25maWdDbnQgPSBzZWN0aW9uQ29uZmlncy5sZW5ndGg7XG4gICAgICAgIGxldCBjb25maWdJID0gMDtcbiAgICAgICAgbGV0IGN1cnJlbnRDb25maWc7XG4gICAgICAgIGxldCBoZWFkU2VjdGlvbk5vZGVzID0gW107XG4gICAgICAgIGxldCBib2R5U2VjdGlvbk5vZGVzID0gW107XG4gICAgICAgIGxldCBmb290U2VjdGlvbk5vZGVzID0gW107XG4gICAgICAgIHdoaWxlIChjb25maWdJIDwgY29uZmlnQ250ICYmIChjdXJyZW50Q29uZmlnID0gc2VjdGlvbkNvbmZpZ3NbY29uZmlnSV0pLnR5cGUgPT09ICdoZWFkZXInKSB7XG4gICAgICAgICAgICBoZWFkU2VjdGlvbk5vZGVzLnB1c2godGhpcy5yZW5kZXJTZWN0aW9uKGN1cnJlbnRDb25maWcsIG1pY3JvQ29sR3JvdXBOb2RlLCB0cnVlKSk7XG4gICAgICAgICAgICBjb25maWdJICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGNvbmZpZ0kgPCBjb25maWdDbnQgJiYgKGN1cnJlbnRDb25maWcgPSBzZWN0aW9uQ29uZmlnc1tjb25maWdJXSkudHlwZSA9PT0gJ2JvZHknKSB7XG4gICAgICAgICAgICBib2R5U2VjdGlvbk5vZGVzLnB1c2godGhpcy5yZW5kZXJTZWN0aW9uKGN1cnJlbnRDb25maWcsIG1pY3JvQ29sR3JvdXBOb2RlLCBmYWxzZSkpO1xuICAgICAgICAgICAgY29uZmlnSSArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChjb25maWdJIDwgY29uZmlnQ250ICYmIChjdXJyZW50Q29uZmlnID0gc2VjdGlvbkNvbmZpZ3NbY29uZmlnSV0pLnR5cGUgPT09ICdmb290ZXInKSB7XG4gICAgICAgICAgICBmb290U2VjdGlvbk5vZGVzLnB1c2godGhpcy5yZW5kZXJTZWN0aW9uKGN1cnJlbnRDb25maWcsIG1pY3JvQ29sR3JvdXBOb2RlLCB0cnVlKSk7XG4gICAgICAgICAgICBjb25maWdJICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmlyZWZveCBidWc6IHdoZW4gc2V0dGluZyBoZWlnaHQgb24gdGFibGUgYW5kIHRoZXJlIGlzIGEgdGhlYWQgb3IgdGZvb3QsXG4gICAgICAgIC8vIHRoZSBuZWNlc3NhcnkgaGVpZ2h0OjEwMCUgb24gdGhlIGxpcXVpZC1oZWlnaHQgYm9keSBzZWN0aW9uIGZvcmNlcyB0aGUgKndob2xlKiB0YWJsZSB0byBiZSB0YWxsZXIuIChidWcgIzU1MjQpXG4gICAgICAgIC8vIHVzZSBnZXRDYW5WR3Jvd1dpdGhpbkNlbGwgYXMgYSB3YXkgdG8gZGV0ZWN0IHRhYmxlLXN0dXBpZCBmaXJlZm94LlxuICAgICAgICAvLyBpZiBzbywgdXNlIGEgc2ltcGxlciBkb20gc3RydWN0dXJlLCBqYW0gZXZlcnl0aGluZyBpbnRvIGEgbG9uZSB0Ym9keS5cbiAgICAgICAgbGV0IGlzQnVnZ3kgPSAhZ2V0Q2FuVkdyb3dXaXRoaW5DZWxsKCk7XG4gICAgICAgIGNvbnN0IHJvbGVBdHRycyA9IHsgcm9sZTogJ3Jvd2dyb3VwJyB9O1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgndGFibGUnLCB7XG4gICAgICAgICAgICByb2xlOiAnZ3JpZCcsXG4gICAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZXMuam9pbignICcpLFxuICAgICAgICAgICAgc3R5bGU6IHsgaGVpZ2h0OiBwcm9wcy5oZWlnaHQgfSxcbiAgICAgICAgfSwgQm9vbGVhbighaXNCdWdneSAmJiBoZWFkU2VjdGlvbk5vZGVzLmxlbmd0aCkgJiYgY3JlYXRlRWxlbWVudCgndGhlYWQnLCByb2xlQXR0cnMsIC4uLmhlYWRTZWN0aW9uTm9kZXMpLCBCb29sZWFuKCFpc0J1Z2d5ICYmIGJvZHlTZWN0aW9uTm9kZXMubGVuZ3RoKSAmJiBjcmVhdGVFbGVtZW50KCd0Ym9keScsIHJvbGVBdHRycywgLi4uYm9keVNlY3Rpb25Ob2RlcyksIEJvb2xlYW4oIWlzQnVnZ3kgJiYgZm9vdFNlY3Rpb25Ob2Rlcy5sZW5ndGgpICYmIGNyZWF0ZUVsZW1lbnQoJ3Rmb290Jywgcm9sZUF0dHJzLCAuLi5mb290U2VjdGlvbk5vZGVzKSwgaXNCdWdneSAmJiBjcmVhdGVFbGVtZW50KCd0Ym9keScsIHJvbGVBdHRycywgLi4uaGVhZFNlY3Rpb25Ob2RlcywgLi4uYm9keVNlY3Rpb25Ob2RlcywgLi4uZm9vdFNlY3Rpb25Ob2RlcykpO1xuICAgIH1cbiAgICByZW5kZXJTZWN0aW9uKHNlY3Rpb25Db25maWcsIG1pY3JvQ29sR3JvdXBOb2RlLCBpc0hlYWRlcikge1xuICAgICAgICBpZiAoJ291dGVyQ29udGVudCcgaW4gc2VjdGlvbkNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEZyYWdtZW50LCB7IGtleTogc2VjdGlvbkNvbmZpZy5rZXkgfSwgc2VjdGlvbkNvbmZpZy5vdXRlckNvbnRlbnQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IGtleTogc2VjdGlvbkNvbmZpZy5rZXksIHJvbGU6IFwicHJlc2VudGF0aW9uXCIsIGNsYXNzTmFtZTogZ2V0U2VjdGlvbkNsYXNzTmFtZXMoc2VjdGlvbkNvbmZpZywgdGhpcy5wcm9wcy5saXF1aWQpLmpvaW4oJyAnKSB9LCB0aGlzLnJlbmRlckNodW5rVGQoc2VjdGlvbkNvbmZpZywgbWljcm9Db2xHcm91cE5vZGUsIHNlY3Rpb25Db25maWcuY2h1bmssIGlzSGVhZGVyKSkpO1xuICAgIH1cbiAgICByZW5kZXJDaHVua1RkKHNlY3Rpb25Db25maWcsIG1pY3JvQ29sR3JvdXBOb2RlLCBjaHVua0NvbmZpZywgaXNIZWFkZXIpIHtcbiAgICAgICAgaWYgKCdvdXRlckNvbnRlbnQnIGluIGNodW5rQ29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm4gY2h1bmtDb25maWcub3V0ZXJDb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBmb3JjZVlTY3JvbGxiYXJzLCBzY3JvbGxlckNsaWVudFdpZHRocywgc2Nyb2xsZXJDbGllbnRIZWlnaHRzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBsZXQgbmVlZHNZU2Nyb2xsaW5nID0gZ2V0QWxsb3dZU2Nyb2xsaW5nKHByb3BzLCBzZWN0aW9uQ29uZmlnKTsgLy8gVE9ETzogZG8gbGF6aWx5LiBkbyBpbiBzZWN0aW9uIGNvbmZpZz9cbiAgICAgICAgbGV0IGlzTGlxdWlkID0gZ2V0U2VjdGlvbkhhc0xpcXVpZEhlaWdodChwcm9wcywgc2VjdGlvbkNvbmZpZyk7XG4gICAgICAgIC8vIGZvciBgIXByb3BzLmxpcXVpZGAgLSBpcyBXSE9MRSBzY3JvbGxncmlkIG5hdHVyYWwgaGVpZ2h0P1xuICAgICAgICAvLyBUT0RPOiBkbyBzYW1lIHRoaW5nIGluIGFkdmFuY2VkIHNjcm9sbGdyaWQ/IHByb2xseSBub3QgYi9jIGFsd2F5cyBoYXMgaG9yaXpvbnRhbCBzY3JvbGxiYXJzXG4gICAgICAgIGxldCBvdmVyZmxvd1kgPSAhcHJvcHMubGlxdWlkID8gJ3Zpc2libGUnIDpcbiAgICAgICAgICAgIGZvcmNlWVNjcm9sbGJhcnMgPyAnc2Nyb2xsJyA6XG4gICAgICAgICAgICAgICAgIW5lZWRzWVNjcm9sbGluZyA/ICdoaWRkZW4nIDpcbiAgICAgICAgICAgICAgICAgICAgJ2F1dG8nO1xuICAgICAgICBsZXQgc2VjdGlvbktleSA9IHNlY3Rpb25Db25maWcua2V5O1xuICAgICAgICBsZXQgY29udGVudCA9IHJlbmRlckNodW5rQ29udGVudChzZWN0aW9uQ29uZmlnLCBjaHVua0NvbmZpZywge1xuICAgICAgICAgICAgdGFibGVDb2xHcm91cE5vZGU6IG1pY3JvQ29sR3JvdXBOb2RlLFxuICAgICAgICAgICAgdGFibGVNaW5XaWR0aDogJycsXG4gICAgICAgICAgICBjbGllbnRXaWR0aDogKCFwcm9wcy5jb2xsYXBzaWJsZVdpZHRoICYmIHNjcm9sbGVyQ2xpZW50V2lkdGhzW3NlY3Rpb25LZXldICE9PSB1bmRlZmluZWQpID8gc2Nyb2xsZXJDbGllbnRXaWR0aHNbc2VjdGlvbktleV0gOiBudWxsLFxuICAgICAgICAgICAgY2xpZW50SGVpZ2h0OiBzY3JvbGxlckNsaWVudEhlaWdodHNbc2VjdGlvbktleV0gIT09IHVuZGVmaW5lZCA/IHNjcm9sbGVyQ2xpZW50SGVpZ2h0c1tzZWN0aW9uS2V5XSA6IG51bGwsXG4gICAgICAgICAgICBleHBhbmRSb3dzOiBzZWN0aW9uQ29uZmlnLmV4cGFuZFJvd3MsXG4gICAgICAgICAgICBzeW5jUm93SGVpZ2h0czogZmFsc2UsXG4gICAgICAgICAgICByb3dTeW5jSGVpZ2h0czogW10sXG4gICAgICAgICAgICByZXBvcnRSb3dIZWlnaHRDaGFuZ2U6ICgpID0+IHsgfSxcbiAgICAgICAgfSwgaXNIZWFkZXIpO1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChpc0hlYWRlciA/ICd0aCcgOiAndGQnLCB7XG4gICAgICAgICAgICByZWY6IGNodW5rQ29uZmlnLmVsUmVmLFxuICAgICAgICAgICAgcm9sZTogJ3ByZXNlbnRhdGlvbicsXG4gICAgICAgIH0sIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGBmYy1zY3JvbGxlci1oYXJuZXNzJHtpc0xpcXVpZCA/ICcgZmMtc2Nyb2xsZXItaGFybmVzcy1saXF1aWQnIDogJyd9YCB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChTY3JvbGxlciwgeyByZWY6IHRoaXMuc2Nyb2xsZXJSZWZzLmNyZWF0ZVJlZihzZWN0aW9uS2V5KSwgZWxSZWY6IHRoaXMuc2Nyb2xsZXJFbFJlZnMuY3JlYXRlUmVmKHNlY3Rpb25LZXkpLCBvdmVyZmxvd1k6IG92ZXJmbG93WSwgb3ZlcmZsb3dYOiAhcHJvcHMubGlxdWlkID8gJ3Zpc2libGUnIDogJ2hpZGRlbicgLyogbmF0dXJhbCBoZWlnaHQ/ICovLCBtYXhIZWlnaHQ6IHNlY3Rpb25Db25maWcubWF4SGVpZ2h0LCBsaXF1aWQ6IGlzTGlxdWlkLCBsaXF1aWRJc0Fic29sdXRlIC8vIGJlY2F1c2UgaXRzIHdpdGhpbiBhIGhhcm5lc3NcbiAgICAgICAgICAgICAgICA6IHRydWUgfSwgY29udGVudCkpKTtcbiAgICB9XG4gICAgX2hhbmRsZVNjcm9sbGVyRWwoc2Nyb2xsZXJFbCwga2V5KSB7XG4gICAgICAgIGxldCBzZWN0aW9uID0gZ2V0U2VjdGlvbkJ5S2V5KHRoaXMucHJvcHMuc2VjdGlvbnMsIGtleSk7XG4gICAgICAgIGlmIChzZWN0aW9uKSB7XG4gICAgICAgICAgICBzZXRSZWYoc2VjdGlvbi5jaHVuay5zY3JvbGxlckVsUmVmLCBzY3JvbGxlckVsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVTaXppbmcoKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmFkZFJlc2l6ZUhhbmRsZXIodGhpcy5oYW5kbGVTaXppbmcpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgIC8vIFRPRE86IG5lZWQgYmV0dGVyIHNvbHV0aW9uIHdoZW4gc3RhdGUgY29udGFpbnMgbm9uLXNpemluZyB0aGluZ3NcbiAgICAgICAgdGhpcy5oYW5kbGVTaXppbmcoKTtcbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5yZW1vdmVSZXNpemVIYW5kbGVyKHRoaXMuaGFuZGxlU2l6aW5nKTtcbiAgICB9XG4gICAgY29tcHV0ZVNocmlua1dpZHRoKCkge1xuICAgICAgICByZXR1cm4gaGFzU2hyaW5rV2lkdGgodGhpcy5wcm9wcy5jb2xzKVxuICAgICAgICAgICAgPyBjb21wdXRlU2hyaW5rV2lkdGgodGhpcy5zY3JvbGxlckVsUmVmcy5nZXRBbGwoKSlcbiAgICAgICAgICAgIDogMDtcbiAgICB9XG4gICAgY29tcHV0ZVNjcm9sbGVyRGltcygpIHtcbiAgICAgICAgbGV0IHNjcm9sbGJhcldpZHRoID0gZ2V0U2Nyb2xsYmFyV2lkdGhzKCk7XG4gICAgICAgIGxldCB7IHNjcm9sbGVyUmVmcywgc2Nyb2xsZXJFbFJlZnMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBmb3JjZVlTY3JvbGxiYXJzID0gZmFsc2U7XG4gICAgICAgIGxldCBzY3JvbGxlckNsaWVudFdpZHRocyA9IHt9O1xuICAgICAgICBsZXQgc2Nyb2xsZXJDbGllbnRIZWlnaHRzID0ge307XG4gICAgICAgIGZvciAobGV0IHNlY3Rpb25LZXkgaW4gc2Nyb2xsZXJSZWZzLmN1cnJlbnRNYXApIHtcbiAgICAgICAgICAgIGxldCBzY3JvbGxlciA9IHNjcm9sbGVyUmVmcy5jdXJyZW50TWFwW3NlY3Rpb25LZXldO1xuICAgICAgICAgICAgaWYgKHNjcm9sbGVyICYmIHNjcm9sbGVyLm5lZWRzWVNjcm9sbGluZygpKSB7XG4gICAgICAgICAgICAgICAgZm9yY2VZU2Nyb2xsYmFycyA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgc2VjdGlvbiBvZiB0aGlzLnByb3BzLnNlY3Rpb25zKSB7XG4gICAgICAgICAgICBsZXQgc2VjdGlvbktleSA9IHNlY3Rpb24ua2V5O1xuICAgICAgICAgICAgbGV0IHNjcm9sbGVyRWwgPSBzY3JvbGxlckVsUmVmcy5jdXJyZW50TWFwW3NlY3Rpb25LZXldO1xuICAgICAgICAgICAgaWYgKHNjcm9sbGVyRWwpIHtcbiAgICAgICAgICAgICAgICBsZXQgaGFybmVzc0VsID0gc2Nyb2xsZXJFbC5wYXJlbnROb2RlOyAvLyBUT0RPOiB3ZWlyZCB3YXkgdG8gZ2V0IHRoaXMuIG5lZWQgaGFybmVzcyBiL2MgZG9lc24ndCBpbmNsdWRlIHRhYmxlIGJvcmRlcnNcbiAgICAgICAgICAgICAgICBzY3JvbGxlckNsaWVudFdpZHRoc1tzZWN0aW9uS2V5XSA9IE1hdGguZmxvb3IoaGFybmVzc0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC0gKGZvcmNlWVNjcm9sbGJhcnNcbiAgICAgICAgICAgICAgICAgICAgPyBzY3JvbGxiYXJXaWR0aC55IC8vIHVzZSBnbG9iYWwgYmVjYXVzZSBzY3JvbGxlciBtaWdodCBub3QgaGF2ZSBzY3JvbGxiYXJzIHlldCBidXQgd2lsbCBuZWVkIHRoZW0gaW4gZnV0dXJlXG4gICAgICAgICAgICAgICAgICAgIDogMCkpO1xuICAgICAgICAgICAgICAgIHNjcm9sbGVyQ2xpZW50SGVpZ2h0c1tzZWN0aW9uS2V5XSA9IE1hdGguZmxvb3IoaGFybmVzc0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZm9yY2VZU2Nyb2xsYmFycywgc2Nyb2xsZXJDbGllbnRXaWR0aHMsIHNjcm9sbGVyQ2xpZW50SGVpZ2h0cyB9O1xuICAgIH1cbn1cblNpbXBsZVNjcm9sbEdyaWQuYWRkU3RhdGVFcXVhbGl0eSh7XG4gICAgc2Nyb2xsZXJDbGllbnRXaWR0aHM6IGlzUHJvcHNFcXVhbCxcbiAgICBzY3JvbGxlckNsaWVudEhlaWdodHM6IGlzUHJvcHNFcXVhbCxcbn0pO1xuZnVuY3Rpb24gZ2V0U2VjdGlvbkJ5S2V5KHNlY3Rpb25zLCBrZXkpIHtcbiAgICBmb3IgKGxldCBzZWN0aW9uIG9mIHNlY3Rpb25zKSB7XG4gICAgICAgIGlmIChzZWN0aW9uLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gc2VjdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuY2xhc3MgRXZlbnRDb250YWluZXIgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVFbCA9IChlbCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICAgICAgc2V0RWxTZWcoZWwsIHRoaXMucHJvcHMuc2VnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgICAgIGNvbnN0IHsgc2VnIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgeyBldmVudFJhbmdlIH0gPSBzZWc7XG4gICAgICAgIGNvbnN0IHsgdWkgfSA9IGV2ZW50UmFuZ2U7XG4gICAgICAgIGNvbnN0IHJlbmRlclByb3BzID0ge1xuICAgICAgICAgICAgZXZlbnQ6IG5ldyBFdmVudEltcGwoY29udGV4dCwgZXZlbnRSYW5nZS5kZWYsIGV2ZW50UmFuZ2UuaW5zdGFuY2UpLFxuICAgICAgICAgICAgdmlldzogY29udGV4dC52aWV3QXBpLFxuICAgICAgICAgICAgdGltZVRleHQ6IHByb3BzLnRpbWVUZXh0LFxuICAgICAgICAgICAgdGV4dENvbG9yOiB1aS50ZXh0Q29sb3IsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHVpLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiB1aS5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgIGlzRHJhZ2dhYmxlOiAhcHJvcHMuZGlzYWJsZURyYWdnaW5nICYmIGNvbXB1dGVTZWdEcmFnZ2FibGUoc2VnLCBjb250ZXh0KSxcbiAgICAgICAgICAgIGlzU3RhcnRSZXNpemFibGU6ICFwcm9wcy5kaXNhYmxlUmVzaXppbmcgJiYgY29tcHV0ZVNlZ1N0YXJ0UmVzaXphYmxlKHNlZywgY29udGV4dCksXG4gICAgICAgICAgICBpc0VuZFJlc2l6YWJsZTogIXByb3BzLmRpc2FibGVSZXNpemluZyAmJiBjb21wdXRlU2VnRW5kUmVzaXphYmxlKHNlZyksXG4gICAgICAgICAgICBpc01pcnJvcjogQm9vbGVhbihwcm9wcy5pc0RyYWdnaW5nIHx8IHByb3BzLmlzUmVzaXppbmcgfHwgcHJvcHMuaXNEYXRlU2VsZWN0aW5nKSxcbiAgICAgICAgICAgIGlzU3RhcnQ6IEJvb2xlYW4oc2VnLmlzU3RhcnQpLFxuICAgICAgICAgICAgaXNFbmQ6IEJvb2xlYW4oc2VnLmlzRW5kKSxcbiAgICAgICAgICAgIGlzUGFzdDogQm9vbGVhbihwcm9wcy5pc1Bhc3QpLFxuICAgICAgICAgICAgaXNGdXR1cmU6IEJvb2xlYW4ocHJvcHMuaXNGdXR1cmUpLFxuICAgICAgICAgICAgaXNUb2RheTogQm9vbGVhbihwcm9wcy5pc1RvZGF5KSxcbiAgICAgICAgICAgIGlzU2VsZWN0ZWQ6IEJvb2xlYW4ocHJvcHMuaXNTZWxlY3RlZCksXG4gICAgICAgICAgICBpc0RyYWdnaW5nOiBCb29sZWFuKHByb3BzLmlzRHJhZ2dpbmcpLFxuICAgICAgICAgICAgaXNSZXNpemluZzogQm9vbGVhbihwcm9wcy5pc1Jlc2l6aW5nKSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KENvbnRlbnRDb250YWluZXIsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzIC8qIGNvbnRhaW5zIGNoaWxkcmVuICovLCB7IGVsUmVmOiB0aGlzLmhhbmRsZUVsLCBlbENsYXNzZXM6IFtcbiAgICAgICAgICAgICAgICAuLi5nZXRFdmVudENsYXNzTmFtZXMocmVuZGVyUHJvcHMpLFxuICAgICAgICAgICAgICAgIC4uLnNlZy5ldmVudFJhbmdlLnVpLmNsYXNzTmFtZXMsXG4gICAgICAgICAgICAgICAgLi4uKHByb3BzLmVsQ2xhc3NlcyB8fCBbXSksXG4gICAgICAgICAgICBdLCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGdlbmVyYXRvck5hbWU6IFwiZXZlbnRDb250ZW50XCIsIGN1c3RvbUdlbmVyYXRvcjogb3B0aW9ucy5ldmVudENvbnRlbnQsIGRlZmF1bHRHZW5lcmF0b3I6IHByb3BzLmRlZmF1bHRHZW5lcmF0b3IsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy5ldmVudENsYXNzTmFtZXMsIGRpZE1vdW50OiBvcHRpb25zLmV2ZW50RGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLmV2ZW50V2lsbFVubW91bnQgfSkpKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgICBpZiAodGhpcy5lbCAmJiB0aGlzLnByb3BzLnNlZyAhPT0gcHJldlByb3BzLnNlZykge1xuICAgICAgICAgICAgc2V0RWxTZWcodGhpcy5lbCwgdGhpcy5wcm9wcy5zZWcpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBzaG91bGQgbm90IGJlIGEgcHVyZWNvbXBvbmVudFxuY2xhc3MgU3RhbmRhcmRFdmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgICAgIGxldCB7IHNlZyB9ID0gcHJvcHM7XG4gICAgICAgIGxldCB7IHVpIH0gPSBzZWcuZXZlbnRSYW5nZTtcbiAgICAgICAgbGV0IHRpbWVGb3JtYXQgPSBvcHRpb25zLmV2ZW50VGltZUZvcm1hdCB8fCBwcm9wcy5kZWZhdWx0VGltZUZvcm1hdDtcbiAgICAgICAgbGV0IHRpbWVUZXh0ID0gYnVpbGRTZWdUaW1lVGV4dChzZWcsIHRpbWVGb3JtYXQsIGNvbnRleHQsIHByb3BzLmRlZmF1bHREaXNwbGF5RXZlbnRUaW1lLCBwcm9wcy5kZWZhdWx0RGlzcGxheUV2ZW50RW5kKTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEV2ZW50Q29udGFpbmVyLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcyAvKiBpbmNsdWRlcyBlbFJlZiAqLywgeyBlbFRhZzogXCJhXCIsIGVsU3R5bGU6IHtcbiAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogdWkuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB1aS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICB9LCBlbEF0dHJzOiBnZXRTZWdBbmNob3JBdHRycyhzZWcsIGNvbnRleHQpLCBkZWZhdWx0R2VuZXJhdG9yOiByZW5kZXJJbm5lckNvbnRlbnQkMSwgdGltZVRleHQ6IHRpbWVUZXh0IH0pLCAoSW5uZXJDb250ZW50LCBldmVudENvbnRlbnRBcmcpID0+IChjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChJbm5lckNvbnRlbnQsIHsgZWxUYWc6IFwiZGl2XCIsIGVsQ2xhc3NlczogWydmYy1ldmVudC1tYWluJ10sIGVsU3R5bGU6IHsgY29sb3I6IGV2ZW50Q29udGVudEFyZy50ZXh0Q29sb3IgfSB9KSxcbiAgICAgICAgICAgIEJvb2xlYW4oZXZlbnRDb250ZW50QXJnLmlzU3RhcnRSZXNpemFibGUpICYmIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXJlc2l6ZXIgZmMtZXZlbnQtcmVzaXplci1zdGFydFwiIH0pKSxcbiAgICAgICAgICAgIEJvb2xlYW4oZXZlbnRDb250ZW50QXJnLmlzRW5kUmVzaXphYmxlKSAmJiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1ldmVudC1yZXNpemVyIGZjLWV2ZW50LXJlc2l6ZXItZW5kXCIgfSkpKSkpKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZW5kZXJJbm5lckNvbnRlbnQkMShpbm5lclByb3BzKSB7XG4gICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LW1haW4tZnJhbWVcIiB9LFxuICAgICAgICBpbm5lclByb3BzLnRpbWVUZXh0ICYmIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXRpbWVcIiB9LCBpbm5lclByb3BzLnRpbWVUZXh0KSksXG4gICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZXZlbnQtdGl0bGUtY29udGFpbmVyXCIgfSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZXZlbnQtdGl0bGUgZmMtc3RpY2t5XCIgfSwgaW5uZXJQcm9wcy5ldmVudC50aXRsZSB8fCBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBcIlxcdTAwQTBcIikpKSkpO1xufVxuXG5jb25zdCBOb3dJbmRpY2F0b3JDb250YWluZXIgPSAocHJvcHMpID0+IChjcmVhdGVFbGVtZW50KFZpZXdDb250ZXh0VHlwZS5Db25zdW1lciwgbnVsbCwgKGNvbnRleHQpID0+IHtcbiAgICBsZXQgeyBvcHRpb25zIH0gPSBjb250ZXh0O1xuICAgIGxldCByZW5kZXJQcm9wcyA9IHtcbiAgICAgICAgaXNBeGlzOiBwcm9wcy5pc0F4aXMsXG4gICAgICAgIGRhdGU6IGNvbnRleHQuZGF0ZUVudi50b0RhdGUocHJvcHMuZGF0ZSksXG4gICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICB9O1xuICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChDb250ZW50Q29udGFpbmVyLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcyAvKiBpbmNsdWRlcyBjaGlsZHJlbiAqLywgeyBlbFRhZzogcHJvcHMuZWxUYWcgfHwgJ2RpdicsIHJlbmRlclByb3BzOiByZW5kZXJQcm9wcywgZ2VuZXJhdG9yTmFtZTogXCJub3dJbmRpY2F0b3JDb250ZW50XCIsIGN1c3RvbUdlbmVyYXRvcjogb3B0aW9ucy5ub3dJbmRpY2F0b3JDb250ZW50LCBjbGFzc05hbWVHZW5lcmF0b3I6IG9wdGlvbnMubm93SW5kaWNhdG9yQ2xhc3NOYW1lcywgZGlkTW91bnQ6IG9wdGlvbnMubm93SW5kaWNhdG9yRGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLm5vd0luZGljYXRvcldpbGxVbm1vdW50IH0pKSk7XG59KSk7XG5cbmNvbnN0IERBWV9OVU1fRk9STUFUID0gY3JlYXRlRm9ybWF0dGVyKHsgZGF5OiAnbnVtZXJpYycgfSk7XG5jbGFzcyBEYXlDZWxsQ29udGFpbmVyIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMucmVmaW5lUmVuZGVyUHJvcHMgPSBtZW1vaXplT2JqQXJnKHJlZmluZVJlbmRlclByb3BzKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgb3B0aW9ucyB9ID0gY29udGV4dDtcbiAgICAgICAgbGV0IHJlbmRlclByb3BzID0gdGhpcy5yZWZpbmVSZW5kZXJQcm9wcyh7XG4gICAgICAgICAgICBkYXRlOiBwcm9wcy5kYXRlLFxuICAgICAgICAgICAgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLFxuICAgICAgICAgICAgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSxcbiAgICAgICAgICAgIGlzTW9udGhTdGFydDogcHJvcHMuaXNNb250aFN0YXJ0IHx8IGZhbHNlLFxuICAgICAgICAgICAgc2hvd0RheU51bWJlcjogcHJvcHMuc2hvd0RheU51bWJlcixcbiAgICAgICAgICAgIGV4dHJhUmVuZGVyUHJvcHM6IHByb3BzLmV4dHJhUmVuZGVyUHJvcHMsXG4gICAgICAgICAgICB2aWV3QXBpOiBjb250ZXh0LnZpZXdBcGksXG4gICAgICAgICAgICBkYXRlRW52OiBjb250ZXh0LmRhdGVFbnYsXG4gICAgICAgICAgICBtb250aFN0YXJ0Rm9ybWF0OiBvcHRpb25zLm1vbnRoU3RhcnRGb3JtYXQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoQ29udGVudENvbnRhaW5lciwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMgLyogaW5jbHVkZXMgY2hpbGRyZW4gKi8sIHsgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgLi4uZ2V0RGF5Q2xhc3NOYW1lcyhyZW5kZXJQcm9wcywgY29udGV4dC50aGVtZSksXG4gICAgICAgICAgICAgICAgLi4uKHByb3BzLmVsQ2xhc3NlcyB8fCBbXSksXG4gICAgICAgICAgICBdLCBlbEF0dHJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByb3BzLmVsQXR0cnMpLCAocmVuZGVyUHJvcHMuaXNEaXNhYmxlZCA/IHt9IDogeyAnZGF0YS1kYXRlJzogZm9ybWF0RGF5U3RyaW5nKHByb3BzLmRhdGUpIH0pKSwgcmVuZGVyUHJvcHM6IHJlbmRlclByb3BzLCBnZW5lcmF0b3JOYW1lOiBcImRheUNlbGxDb250ZW50XCIsIGN1c3RvbUdlbmVyYXRvcjogb3B0aW9ucy5kYXlDZWxsQ29udGVudCwgZGVmYXVsdEdlbmVyYXRvcjogcHJvcHMuZGVmYXVsdEdlbmVyYXRvciwgY2xhc3NOYW1lR2VuZXJhdG9yOiBcbiAgICAgICAgICAgIC8vIGRvbid0IHVzZSBjdXN0b20gY2xhc3NOYW1lcyBpZiBkaXNhYmxlZFxuICAgICAgICAgICAgcmVuZGVyUHJvcHMuaXNEaXNhYmxlZCA/IHVuZGVmaW5lZCA6IG9wdGlvbnMuZGF5Q2VsbENsYXNzTmFtZXMsIGRpZE1vdW50OiBvcHRpb25zLmRheUNlbGxEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMuZGF5Q2VsbFdpbGxVbm1vdW50IH0pKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFzQ3VzdG9tRGF5Q2VsbENvbnRlbnQob3B0aW9ucykge1xuICAgIHJldHVybiBCb29sZWFuKG9wdGlvbnMuZGF5Q2VsbENvbnRlbnQgfHwgaGFzQ3VzdG9tUmVuZGVyaW5nSGFuZGxlcignZGF5Q2VsbENvbnRlbnQnLCBvcHRpb25zKSk7XG59XG5mdW5jdGlvbiByZWZpbmVSZW5kZXJQcm9wcyhyYXcpIHtcbiAgICBsZXQgeyBkYXRlLCBkYXRlRW52LCBkYXRlUHJvZmlsZSwgaXNNb250aFN0YXJ0IH0gPSByYXc7XG4gICAgbGV0IGRheU1ldGEgPSBnZXREYXRlTWV0YShkYXRlLCByYXcudG9kYXlSYW5nZSwgbnVsbCwgZGF0ZVByb2ZpbGUpO1xuICAgIGxldCBkYXlOdW1iZXJUZXh0ID0gcmF3LnNob3dEYXlOdW1iZXIgPyAoZGF0ZUVudi5mb3JtYXQoZGF0ZSwgaXNNb250aFN0YXJ0ID8gcmF3Lm1vbnRoU3RhcnRGb3JtYXQgOiBEQVlfTlVNX0ZPUk1BVCkpIDogJyc7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgZGF0ZTogZGF0ZUVudi50b0RhdGUoZGF0ZSksIHZpZXc6IHJhdy52aWV3QXBpIH0sIGRheU1ldGEpLCB7IGlzTW9udGhTdGFydCxcbiAgICAgICAgZGF5TnVtYmVyVGV4dCB9KSwgcmF3LmV4dHJhUmVuZGVyUHJvcHMpO1xufVxuXG5jbGFzcyBCZ0V2ZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgc2VnIH0gPSBwcm9wcztcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEV2ZW50Q29udGFpbmVyLCB7IGVsVGFnOiBcImRpdlwiLCBlbENsYXNzZXM6IFsnZmMtYmctZXZlbnQnXSwgZWxTdHlsZTogeyBiYWNrZ3JvdW5kQ29sb3I6IHNlZy5ldmVudFJhbmdlLnVpLmJhY2tncm91bmRDb2xvciB9LCBkZWZhdWx0R2VuZXJhdG9yOiByZW5kZXJJbm5lckNvbnRlbnQsIHNlZzogc2VnLCB0aW1lVGV4dDogXCJcIiwgaXNEcmFnZ2luZzogZmFsc2UsIGlzUmVzaXppbmc6IGZhbHNlLCBpc0RhdGVTZWxlY3Rpbmc6IGZhbHNlLCBpc1NlbGVjdGVkOiBmYWxzZSwgaXNQYXN0OiBwcm9wcy5pc1Bhc3QsIGlzRnV0dXJlOiBwcm9wcy5pc0Z1dHVyZSwgaXNUb2RheTogcHJvcHMuaXNUb2RheSwgZGlzYWJsZURyYWdnaW5nOiB0cnVlLCBkaXNhYmxlUmVzaXppbmc6IHRydWUgfSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbmRlcklubmVyQ29udGVudChwcm9wcykge1xuICAgIGxldCB7IHRpdGxlIH0gPSBwcm9wcy5ldmVudDtcbiAgICByZXR1cm4gdGl0bGUgJiYgKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZXZlbnQtdGl0bGVcIiB9LCBwcm9wcy5ldmVudC50aXRsZSkpO1xufVxuZnVuY3Rpb24gcmVuZGVyRmlsbChmaWxsVHlwZSkge1xuICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogYGZjLSR7ZmlsbFR5cGV9YCB9KSk7XG59XG5cbmNvbnN0IFdlZWtOdW1iZXJDb250YWluZXIgPSAocHJvcHMpID0+IChjcmVhdGVFbGVtZW50KFZpZXdDb250ZXh0VHlwZS5Db25zdW1lciwgbnVsbCwgKGNvbnRleHQpID0+IHtcbiAgICBsZXQgeyBkYXRlRW52LCBvcHRpb25zIH0gPSBjb250ZXh0O1xuICAgIGxldCB7IGRhdGUgfSA9IHByb3BzO1xuICAgIGxldCBmb3JtYXQgPSBvcHRpb25zLndlZWtOdW1iZXJGb3JtYXQgfHwgcHJvcHMuZGVmYXVsdEZvcm1hdDtcbiAgICBsZXQgbnVtID0gZGF0ZUVudi5jb21wdXRlV2Vla051bWJlcihkYXRlKTsgLy8gVE9ETzogc29tZWhvdyB1c2UgZm9yIGZvcm1hdHRpbmcgYXMgd2VsbD9cbiAgICBsZXQgdGV4dCA9IGRhdGVFbnYuZm9ybWF0KGRhdGUsIGZvcm1hdCk7XG4gICAgbGV0IHJlbmRlclByb3BzID0geyBudW0sIHRleHQsIGRhdGUgfTtcbiAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoQ29udGVudENvbnRhaW5lciAvLyB3aHkgaXNuJ3QgV2Vla051bWJlckNvbnRlbnRBcmcgYmVpbmcgYXV0by1kZXRlY3RlZD9cbiAgICAsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzIC8qIGluY2x1ZGVzIGNoaWxkcmVuICovLCB7IHJlbmRlclByb3BzOiByZW5kZXJQcm9wcywgZ2VuZXJhdG9yTmFtZTogXCJ3ZWVrTnVtYmVyQ29udGVudFwiLCBjdXN0b21HZW5lcmF0b3I6IG9wdGlvbnMud2Vla051bWJlckNvbnRlbnQsIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlcklubmVyLCBjbGFzc05hbWVHZW5lcmF0b3I6IG9wdGlvbnMud2Vla051bWJlckNsYXNzTmFtZXMsIGRpZE1vdW50OiBvcHRpb25zLndlZWtOdW1iZXJEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMud2Vla051bWJlcldpbGxVbm1vdW50IH0pKSk7XG59KSk7XG5mdW5jdGlvbiByZW5kZXJJbm5lcihpbm5lclByb3BzKSB7XG4gICAgcmV0dXJuIGlubmVyUHJvcHMudGV4dDtcbn1cblxuY29uc3QgUEFERElOR19GUk9NX1ZJRVdQT1JUID0gMTA7XG5jbGFzcyBQb3BvdmVyIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICB0aXRsZUlkOiBnZXRVbmlxdWVEb21JZCgpLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVJvb3RFbCA9IChlbCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yb290RWwgPSBlbDtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLmVsUmVmKSB7XG4gICAgICAgICAgICAgICAgc2V0UmVmKHRoaXMucHJvcHMuZWxSZWYsIGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gVHJpZ2dlcmVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzICphbnl3aGVyZSogaW4gdGhlIGRvY3VtZW50LCBmb3IgdGhlIGF1dG9IaWRlIGZlYXR1cmVcbiAgICAgICAgdGhpcy5oYW5kbGVEb2N1bWVudE1vdXNlRG93biA9IChldikgPT4ge1xuICAgICAgICAgICAgLy8gb25seSBoaWRlIHRoZSBwb3BvdmVyIGlmIHRoZSBjbGljayBoYXBwZW5lZCBvdXRzaWRlIHRoZSBwb3BvdmVyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXRFdmVudFRhcmdldFZpYVJvb3QoZXYpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJvb3RFbC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVDbG9zZUNsaWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlRG9jdW1lbnRLZXlEb3duID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXYua2V5ID09PSAnRXNjYXBlJykge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2xvc2VDbGljaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUNsb3NlQ2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBvbkNsb3NlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgaWYgKG9uQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICBvbkNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgdGhlbWUsIG9wdGlvbnMgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHsgcHJvcHMsIHN0YXRlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgY2xhc3NOYW1lcyA9IFtcbiAgICAgICAgICAgICdmYy1wb3BvdmVyJyxcbiAgICAgICAgICAgIHRoZW1lLmdldENsYXNzKCdwb3BvdmVyJyksXG4gICAgICAgIF0uY29uY2F0KHByb3BzLmV4dHJhQ2xhc3NOYW1lcyB8fCBbXSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVQb3J0YWwoY3JlYXRlRWxlbWVudChcImRpdlwiLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcy5leHRyYUF0dHJzLCB7IGlkOiBwcm9wcy5pZCwgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmpvaW4oJyAnKSwgXCJhcmlhLWxhYmVsbGVkYnlcIjogc3RhdGUudGl0bGVJZCwgcmVmOiB0aGlzLmhhbmRsZVJvb3RFbCB9KSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6ICdmYy1wb3BvdmVyLWhlYWRlciAnICsgdGhlbWUuZ2V0Q2xhc3MoJ3BvcG92ZXJIZWFkZXInKSB9LFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcImZjLXBvcG92ZXItdGl0bGVcIiwgaWQ6IHN0YXRlLnRpdGxlSWQgfSwgcHJvcHMudGl0bGUpLFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiAnZmMtcG9wb3Zlci1jbG9zZSAnICsgdGhlbWUuZ2V0SWNvbkNsYXNzKCdjbG9zZScpLCB0aXRsZTogb3B0aW9ucy5jbG9zZUhpbnQsIG9uQ2xpY2s6IHRoaXMuaGFuZGxlQ2xvc2VDbGljayB9KSksXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiAnZmMtcG9wb3Zlci1ib2R5ICcgKyB0aGVtZS5nZXRDbGFzcygncG9wb3ZlckNvbnRlbnQnKSB9LCBwcm9wcy5jaGlsZHJlbikpLCBwcm9wcy5wYXJlbnRFbCk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZURvY3VtZW50TW91c2VEb3duKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlRG9jdW1lbnRLZXlEb3duKTtcbiAgICAgICAgdGhpcy51cGRhdGVTaXplKCk7XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZURvY3VtZW50TW91c2VEb3duKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlRG9jdW1lbnRLZXlEb3duKTtcbiAgICB9XG4gICAgdXBkYXRlU2l6ZSgpIHtcbiAgICAgICAgbGV0IHsgaXNSdGwgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHsgYWxpZ25tZW50RWwsIGFsaWduR3JpZFRvcCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IHsgcm9vdEVsIH0gPSB0aGlzO1xuICAgICAgICBsZXQgYWxpZ25tZW50UmVjdCA9IGNvbXB1dGVDbGlwcGVkQ2xpZW50UmVjdChhbGlnbm1lbnRFbCk7XG4gICAgICAgIGlmIChhbGlnbm1lbnRSZWN0KSB7XG4gICAgICAgICAgICBsZXQgcG9wb3ZlckRpbXMgPSByb290RWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAvLyBwb3NpdGlvbiByZWxhdGl2ZSB0byB2aWV3cG9ydFxuICAgICAgICAgICAgbGV0IHBvcG92ZXJUb3AgPSBhbGlnbkdyaWRUb3BcbiAgICAgICAgICAgICAgICA/IGVsZW1lbnRDbG9zZXN0KGFsaWdubWVudEVsLCAnLmZjLXNjcm9sbGdyaWQnKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3BcbiAgICAgICAgICAgICAgICA6IGFsaWdubWVudFJlY3QudG9wO1xuICAgICAgICAgICAgbGV0IHBvcG92ZXJMZWZ0ID0gaXNSdGwgPyBhbGlnbm1lbnRSZWN0LnJpZ2h0IC0gcG9wb3ZlckRpbXMud2lkdGggOiBhbGlnbm1lbnRSZWN0LmxlZnQ7XG4gICAgICAgICAgICAvLyBjb25zdHJhaW5cbiAgICAgICAgICAgIHBvcG92ZXJUb3AgPSBNYXRoLm1heChwb3BvdmVyVG9wLCBQQURESU5HX0ZST01fVklFV1BPUlQpO1xuICAgICAgICAgICAgcG9wb3ZlckxlZnQgPSBNYXRoLm1pbihwb3BvdmVyTGVmdCwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIC0gUEFERElOR19GUk9NX1ZJRVdQT1JUIC0gcG9wb3ZlckRpbXMud2lkdGgpO1xuICAgICAgICAgICAgcG9wb3ZlckxlZnQgPSBNYXRoLm1heChwb3BvdmVyTGVmdCwgUEFERElOR19GUk9NX1ZJRVdQT1JUKTtcbiAgICAgICAgICAgIGxldCBvcmlnaW4gPSByb290RWwub2Zmc2V0UGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgYXBwbHlTdHlsZShyb290RWwsIHtcbiAgICAgICAgICAgICAgICB0b3A6IHBvcG92ZXJUb3AgLSBvcmlnaW4udG9wLFxuICAgICAgICAgICAgICAgIGxlZnQ6IHBvcG92ZXJMZWZ0IC0gb3JpZ2luLmxlZnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgTW9yZVBvcG92ZXIgZXh0ZW5kcyBEYXRlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVSb290RWwgPSAocm9vdEVsKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJvb3RFbCA9IHJvb3RFbDtcbiAgICAgICAgICAgIGlmIChyb290RWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCh0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgIGVsOiByb290RWwsXG4gICAgICAgICAgICAgICAgICAgIHVzZUV2ZW50Q2VudGVyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC51bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgb3B0aW9ucywgZGF0ZUVudiB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgc3RhcnREYXRlLCB0b2RheVJhbmdlLCBkYXRlUHJvZmlsZSB9ID0gcHJvcHM7XG4gICAgICAgIGxldCB0aXRsZSA9IGRhdGVFbnYuZm9ybWF0KHN0YXJ0RGF0ZSwgb3B0aW9ucy5kYXlQb3BvdmVyRm9ybWF0KTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KERheUNlbGxDb250YWluZXIsIHsgZWxSZWY6IHRoaXMuaGFuZGxlUm9vdEVsLCBkYXRlOiBzdGFydERhdGUsIGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogdG9kYXlSYW5nZSB9LCAoSW5uZXJDb250ZW50LCByZW5kZXJQcm9wcywgZWxBdHRycykgPT4gKGNyZWF0ZUVsZW1lbnQoUG9wb3ZlciwgeyBlbFJlZjogZWxBdHRycy5yZWYsIGlkOiBwcm9wcy5pZCwgdGl0bGU6IHRpdGxlLCBleHRyYUNsYXNzTmFtZXM6IFsnZmMtbW9yZS1wb3BvdmVyJ10uY29uY2F0KGVsQXR0cnMuY2xhc3NOYW1lIHx8IFtdKSwgZXh0cmFBdHRyczogZWxBdHRycyAvKiBUT0RPOiBtYWtlIHRoZXNlIHRpbWUtYmFzZWQgd2hlbiBub3Qgd2hvbGUtZGF5PyAqLywgcGFyZW50RWw6IHByb3BzLnBhcmVudEVsLCBhbGlnbm1lbnRFbDogcHJvcHMuYWxpZ25tZW50RWwsIGFsaWduR3JpZFRvcDogcHJvcHMuYWxpZ25HcmlkVG9wLCBvbkNsb3NlOiBwcm9wcy5vbkNsb3NlIH0sXG4gICAgICAgICAgICBoYXNDdXN0b21EYXlDZWxsQ29udGVudChvcHRpb25zKSAmJiAoY3JlYXRlRWxlbWVudChJbm5lckNvbnRlbnQsIHsgZWxUYWc6IFwiZGl2XCIsIGVsQ2xhc3NlczogWydmYy1tb3JlLXBvcG92ZXItbWlzYyddIH0pKSxcbiAgICAgICAgICAgIHByb3BzLmNoaWxkcmVuKSkpKTtcbiAgICB9XG4gICAgcXVlcnlIaXQocG9zaXRpb25MZWZ0LCBwb3NpdGlvblRvcCwgZWxXaWR0aCwgZWxIZWlnaHQpIHtcbiAgICAgICAgbGV0IHsgcm9vdEVsLCBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgaWYgKHBvc2l0aW9uTGVmdCA+PSAwICYmIHBvc2l0aW9uTGVmdCA8IGVsV2lkdGggJiZcbiAgICAgICAgICAgIHBvc2l0aW9uVG9wID49IDAgJiYgcG9zaXRpb25Ub3AgPCBlbEhlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsXG4gICAgICAgICAgICAgICAgZGF0ZVNwYW46IE9iamVjdC5hc3NpZ24oeyBhbGxEYXk6ICFwcm9wcy5mb3JjZVRpbWVkLCByYW5nZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHByb3BzLnN0YXJ0RGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogcHJvcHMuZW5kRGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgfSB9LCBwcm9wcy5leHRyYURhdGVTcGFuKSxcbiAgICAgICAgICAgICAgICBkYXlFbDogcm9vdEVsLFxuICAgICAgICAgICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgICAgICByaWdodDogZWxXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tOiBlbEhlaWdodCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGxheWVyOiAxLCAvLyBpbXBvcnRhbnQgd2hlbiBjb21wYXJpbmcgd2l0aCBoaXRzIGZyb20gb3RoZXIgY29tcG9uZW50c1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbmNsYXNzIE1vcmVMaW5rQ29udGFpbmVyIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBpc1BvcG92ZXJPcGVuOiBmYWxzZSxcbiAgICAgICAgICAgIHBvcG92ZXJJZDogZ2V0VW5pcXVlRG9tSWQoKSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVMaW5rRWwgPSAobGlua0VsKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxpbmtFbCA9IGxpbmtFbDtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLmVsUmVmKSB7XG4gICAgICAgICAgICAgICAgc2V0UmVmKHRoaXMucHJvcHMuZWxSZWYsIGxpbmtFbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlQ2xpY2sgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IHsgbW9yZUxpbmtDbGljayB9ID0gY29udGV4dC5vcHRpb25zO1xuICAgICAgICAgICAgbGV0IGRhdGUgPSBjb21wdXRlUmFuZ2UocHJvcHMpLnN0YXJ0O1xuICAgICAgICAgICAgZnVuY3Rpb24gYnVpbGRQdWJsaWNTZWcoc2VnKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgZGVmLCBpbnN0YW5jZSwgcmFuZ2UgfSA9IHNlZy5ldmVudFJhbmdlO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBuZXcgRXZlbnRJbXBsKGNvbnRleHQsIGRlZiwgaW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogY29udGV4dC5kYXRlRW52LnRvRGF0ZShyYW5nZS5zdGFydCksXG4gICAgICAgICAgICAgICAgICAgIGVuZDogY29udGV4dC5kYXRlRW52LnRvRGF0ZShyYW5nZS5lbmQpLFxuICAgICAgICAgICAgICAgICAgICBpc1N0YXJ0OiBzZWcuaXNTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgaXNFbmQ6IHNlZy5pc0VuZCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtb3JlTGlua0NsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgbW9yZUxpbmtDbGljayA9IG1vcmVMaW5rQ2xpY2soe1xuICAgICAgICAgICAgICAgICAgICBkYXRlLFxuICAgICAgICAgICAgICAgICAgICBhbGxEYXk6IEJvb2xlYW4ocHJvcHMuYWxsRGF5RGF0ZSksXG4gICAgICAgICAgICAgICAgICAgIGFsbFNlZ3M6IHByb3BzLmFsbFNlZ3MubWFwKGJ1aWxkUHVibGljU2VnKSxcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuU2VnczogcHJvcHMuaGlkZGVuU2Vncy5tYXAoYnVpbGRQdWJsaWNTZWcpLFxuICAgICAgICAgICAgICAgICAgICBqc0V2ZW50OiBldixcbiAgICAgICAgICAgICAgICAgICAgdmlldzogY29udGV4dC52aWV3QXBpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFtb3JlTGlua0NsaWNrIHx8IG1vcmVMaW5rQ2xpY2sgPT09ICdwb3BvdmVyJykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBpc1BvcG92ZXJPcGVuOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1vcmVMaW5rQ2xpY2sgPT09ICdzdHJpbmcnKSB7IC8vIGEgdmlldyBuYW1lXG4gICAgICAgICAgICAgICAgY29udGV4dC5jYWxlbmRhckFwaS56b29tVG8oZGF0ZSwgbW9yZUxpbmtDbGljayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUG9wb3ZlckNsb3NlID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGlzUG9wb3Zlck9wZW46IGZhbHNlIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBzdGF0ZSB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFZpZXdDb250ZXh0VHlwZS5Db25zdW1lciwgbnVsbCwgKGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgIGxldCB7IHZpZXdBcGksIG9wdGlvbnMsIGNhbGVuZGFyQXBpIH0gPSBjb250ZXh0O1xuICAgICAgICAgICAgbGV0IHsgbW9yZUxpbmtUZXh0IH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgbGV0IHsgbW9yZUNudCB9ID0gcHJvcHM7XG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSBjb21wdXRlUmFuZ2UocHJvcHMpO1xuICAgICAgICAgICAgbGV0IHRleHQgPSB0eXBlb2YgbW9yZUxpbmtUZXh0ID09PSAnZnVuY3Rpb24nIC8vIFRPRE86IGV2ZW50dWFsbHkgdXNlIGZvcm1hdFdpdGhPcmRpbmFsc1xuICAgICAgICAgICAgICAgID8gbW9yZUxpbmtUZXh0LmNhbGwoY2FsZW5kYXJBcGksIG1vcmVDbnQpXG4gICAgICAgICAgICAgICAgOiBgKyR7bW9yZUNudH0gJHttb3JlTGlua1RleHR9YDtcbiAgICAgICAgICAgIGxldCBoaW50ID0gZm9ybWF0V2l0aE9yZGluYWxzKG9wdGlvbnMubW9yZUxpbmtIaW50LCBbbW9yZUNudF0sIHRleHQpO1xuICAgICAgICAgICAgbGV0IHJlbmRlclByb3BzID0ge1xuICAgICAgICAgICAgICAgIG51bTogbW9yZUNudCxcbiAgICAgICAgICAgICAgICBzaG9ydFRleHQ6IGArJHttb3JlQ250fWAsXG4gICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICB2aWV3OiB2aWV3QXBpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCxcbiAgICAgICAgICAgICAgICBCb29sZWFuKHByb3BzLm1vcmVDbnQpICYmIChjcmVhdGVFbGVtZW50KENvbnRlbnRDb250YWluZXIsIHsgZWxUYWc6IHByb3BzLmVsVGFnIHx8ICdhJywgZWxSZWY6IHRoaXMuaGFuZGxlTGlua0VsLCBlbENsYXNzZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLihwcm9wcy5lbENsYXNzZXMgfHwgW10pLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLW1vcmUtbGluaycsXG4gICAgICAgICAgICAgICAgICAgIF0sIGVsU3R5bGU6IHByb3BzLmVsU3R5bGUsIGVsQXR0cnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcm9wcy5lbEF0dHJzKSwgY3JlYXRlQXJpYUNsaWNrQXR0cnModGhpcy5oYW5kbGVDbGljaykpLCB7IHRpdGxlOiBoaW50LCAnYXJpYS1leHBhbmRlZCc6IHN0YXRlLmlzUG9wb3Zlck9wZW4sICdhcmlhLWNvbnRyb2xzJzogc3RhdGUuaXNQb3BvdmVyT3BlbiA/IHN0YXRlLnBvcG92ZXJJZCA6ICcnIH0pLCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGdlbmVyYXRvck5hbWU6IFwibW9yZUxpbmtDb250ZW50XCIsIGN1c3RvbUdlbmVyYXRvcjogb3B0aW9ucy5tb3JlTGlua0NvbnRlbnQsIGRlZmF1bHRHZW5lcmF0b3I6IHByb3BzLmRlZmF1bHRHZW5lcmF0b3IgfHwgcmVuZGVyTW9yZUxpbmtJbm5lciwgY2xhc3NOYW1lR2VuZXJhdG9yOiBvcHRpb25zLm1vcmVMaW5rQ2xhc3NOYW1lcywgZGlkTW91bnQ6IG9wdGlvbnMubW9yZUxpbmtEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMubW9yZUxpbmtXaWxsVW5tb3VudCB9LCBwcm9wcy5jaGlsZHJlbikpLFxuICAgICAgICAgICAgICAgIHN0YXRlLmlzUG9wb3Zlck9wZW4gJiYgKGNyZWF0ZUVsZW1lbnQoTW9yZVBvcG92ZXIsIHsgaWQ6IHN0YXRlLnBvcG92ZXJJZCwgc3RhcnREYXRlOiByYW5nZS5zdGFydCwgZW5kRGF0ZTogcmFuZ2UuZW5kLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsIGV4dHJhRGF0ZVNwYW46IHByb3BzLmV4dHJhRGF0ZVNwYW4sIHBhcmVudEVsOiB0aGlzLnBhcmVudEVsLCBhbGlnbm1lbnRFbDogcHJvcHMuYWxpZ25tZW50RWxSZWYgP1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMuYWxpZ25tZW50RWxSZWYuY3VycmVudCA6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmtFbCwgYWxpZ25HcmlkVG9wOiBwcm9wcy5hbGlnbkdyaWRUb3AsIGZvcmNlVGltZWQ6IHByb3BzLmZvcmNlVGltZWQsIG9uQ2xvc2U6IHRoaXMuaGFuZGxlUG9wb3ZlckNsb3NlIH0sIHByb3BzLnBvcG92ZXJDb250ZW50KCkpKSkpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVBhcmVudEVsKCk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVQYXJlbnRFbCgpO1xuICAgIH1cbiAgICB1cGRhdGVQYXJlbnRFbCgpIHtcbiAgICAgICAgaWYgKHRoaXMubGlua0VsKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudEVsID0gZWxlbWVudENsb3Nlc3QodGhpcy5saW5rRWwsICcuZmMtdmlldy1oYXJuZXNzJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiByZW5kZXJNb3JlTGlua0lubmVyKHByb3BzKSB7XG4gICAgcmV0dXJuIHByb3BzLnRleHQ7XG59XG5mdW5jdGlvbiBjb21wdXRlUmFuZ2UocHJvcHMpIHtcbiAgICBpZiAocHJvcHMuYWxsRGF5RGF0ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhcnQ6IHByb3BzLmFsbERheURhdGUsXG4gICAgICAgICAgICBlbmQ6IGFkZERheXMocHJvcHMuYWxsRGF5RGF0ZSwgMSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGxldCB7IGhpZGRlblNlZ3MgfSA9IHByb3BzO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiBjb21wdXRlRWFybGllc3RTZWdTdGFydChoaWRkZW5TZWdzKSxcbiAgICAgICAgZW5kOiBjb21wdXRlTGF0ZXN0U2VnRW5kKGhpZGRlblNlZ3MpLFxuICAgIH07XG59XG5mdW5jdGlvbiBjb21wdXRlRWFybGllc3RTZWdTdGFydChzZWdzKSB7XG4gICAgcmV0dXJuIHNlZ3MucmVkdWNlKHBpY2tFYXJsaWVzdFN0YXJ0KS5ldmVudFJhbmdlLnJhbmdlLnN0YXJ0O1xufVxuZnVuY3Rpb24gcGlja0VhcmxpZXN0U3RhcnQoc2VnMCwgc2VnMSkge1xuICAgIHJldHVybiBzZWcwLmV2ZW50UmFuZ2UucmFuZ2Uuc3RhcnQgPCBzZWcxLmV2ZW50UmFuZ2UucmFuZ2Uuc3RhcnQgPyBzZWcwIDogc2VnMTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVMYXRlc3RTZWdFbmQoc2Vncykge1xuICAgIHJldHVybiBzZWdzLnJlZHVjZShwaWNrTGF0ZXN0RW5kKS5ldmVudFJhbmdlLnJhbmdlLmVuZDtcbn1cbmZ1bmN0aW9uIHBpY2tMYXRlc3RFbmQoc2VnMCwgc2VnMSkge1xuICAgIHJldHVybiBzZWcwLmV2ZW50UmFuZ2UucmFuZ2UuZW5kID4gc2VnMS5ldmVudFJhbmdlLnJhbmdlLmVuZCA/IHNlZzAgOiBzZWcxO1xufVxuXG5jbGFzcyBTdG9yZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSBbXTtcbiAgICB9XG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gdmFsdWU7XG4gICAgICAgIGZvciAobGV0IGhhbmRsZXIgb2YgdGhpcy5oYW5kbGVycykge1xuICAgICAgICAgICAgaGFuZGxlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3Vic2NyaWJlKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaGFuZGxlcih0aGlzLmN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qXG5TdWJzY3JpYmVycyB3aWxsIGdldCBhIExJU1Qgb2YgQ3VzdG9tUmVuZGVyaW5nc1xuKi9cbmNsYXNzIEN1c3RvbVJlbmRlcmluZ1N0b3JlIGV4dGVuZHMgU3RvcmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm1hcCA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgLy8gZm9yIGNvbnNpc3RlbnQgb3JkZXJcbiAgICBoYW5kbGUoY3VzdG9tUmVuZGVyaW5nKSB7XG4gICAgICAgIGNvbnN0IHsgbWFwIH0gPSB0aGlzO1xuICAgICAgICBsZXQgdXBkYXRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoY3VzdG9tUmVuZGVyaW5nLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICBtYXAuc2V0KGN1c3RvbVJlbmRlcmluZy5pZCwgY3VzdG9tUmVuZGVyaW5nKTtcbiAgICAgICAgICAgIHVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1hcC5oYXMoY3VzdG9tUmVuZGVyaW5nLmlkKSkge1xuICAgICAgICAgICAgbWFwLmRlbGV0ZShjdXN0b21SZW5kZXJpbmcuaWQpO1xuICAgICAgICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KG1hcCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCB7IGVsZW1lbnRDbG9zZXN0IGFzICQsIG1lbW9pemVPYmpBcmcgYXMgQSwgQmFzZUNvbXBvbmVudCBhcyBCLCBDb250ZW50Q29udGFpbmVyIGFzIEMsIERlbGF5ZWRSdW5uZXIgYXMgRCwgaXNQcm9wc0VxdWFsIGFzIEUsIEVtaXR0ZXIgYXMgRiwgZ2V0SW5pdGlhbERhdGUgYXMgRywgcmFuZ2VDb250YWluc01hcmtlciBhcyBILCBjcmVhdGVFbXB0eUV2ZW50U3RvcmUgYXMgSSwgcmVkdWNlQ3VycmVudERhdGUgYXMgSiwgcmVkdWNlRXZlbnRTdG9yZSBhcyBLLCByZXpvbmVFdmVudFN0b3JlRGF0ZXMgYXMgTCwgbWVyZ2VSYXdPcHRpb25zIGFzIE0sIEJBU0VfT1BUSU9OX1JFRklORVJTIGFzIE4sIENBTEVOREFSX0xJU1RFTkVSX1JFRklORVJTIGFzIE8sIENBTEVOREFSX09QVElPTl9SRUZJTkVSUyBhcyBQLCBDT01QTEVYX09QVElPTl9DT01QQVJBVE9SUyBhcyBRLCBWSUVXX09QVElPTl9SRUZJTkVSUyBhcyBSLCBEYXRlRW52IGFzIFMsIFRoZW1lIGFzIFQsIERhdGVQcm9maWxlR2VuZXJhdG9yIGFzIFUsIFZpZXdDb250ZXh0VHlwZSBhcyBWLCBjcmVhdGVFdmVudFVpIGFzIFcsIHBhcnNlQnVzaW5lc3NIb3VycyBhcyBYLCBzZXRSZWYgYXMgWSwgSW50ZXJhY3Rpb24gYXMgWiwgZ2V0RWxTZWcgYXMgXywgbWFwSGFzaCBhcyBhLCBnZXRTbG90Q2xhc3NOYW1lcyBhcyBhJCwgRXZlbnRJbXBsIGFzIGEwLCBsaXN0ZW5CeVNlbGVjdG9yIGFzIGExLCBsaXN0ZW5Ub0hvdmVyQnlTZWxlY3RvciBhcyBhMiwgUHVyZUNvbXBvbmVudCBhcyBhMywgYnVpbGRWaWV3Q29udGV4dCBhcyBhNCwgZ2V0VW5pcXVlRG9tSWQgYXMgYTUsIHBhcnNlSW50ZXJhY3Rpb25TZXR0aW5ncyBhcyBhNiwgaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlIGFzIGE3LCBnZXROb3cgYXMgYTgsIENhbGVuZGFySW1wbCBhcyBhOSwgZGlmZkRhdGVzIGFzIGFBLCByZW1vdmVFeGFjdCBhcyBhQiwgbWVtb2l6ZUFycmF5bGlrZSBhcyBhQywgbWVtb2l6ZUhhc2hsaWtlIGFzIGFELCBpbnRlcnNlY3RSZWN0cyBhcyBhRSwgcG9pbnRJbnNpZGVSZWN0IGFzIGFGLCBjb25zdHJhaW5Qb2ludCBhcyBhRywgZ2V0UmVjdENlbnRlciBhcyBhSCwgZGlmZlBvaW50cyBhcyBhSSwgdHJhbnNsYXRlUmVjdCBhcyBhSiwgY29tcGFyZU9ianMgYXMgYUssIGNvbGxlY3RGcm9tSGFzaCBhcyBhTCwgZmluZEVsZW1lbnRzIGFzIGFNLCBmaW5kRGlyZWN0Q2hpbGRyZW4gYXMgYU4sIHJlbW92ZUVsZW1lbnQgYXMgYU8sIGFwcGx5U3R5bGUgYXMgYVAsIGVsZW1lbnRNYXRjaGVzIGFzIGFRLCBnZXRFdmVudFRhcmdldFZpYVJvb3QgYXMgYVIsIHBhcnNlQ2xhc3NOYW1lcyBhcyBhUywgZ2V0Q2FuVkdyb3dXaXRoaW5DZWxsIGFzIGFULCBtZXJnZUV2ZW50U3RvcmVzIGFzIGFVLCBnZXRSZWxldmFudEV2ZW50cyBhcyBhViwgZXZlbnRUdXBsZVRvU3RvcmUgYXMgYVcsIGNvbWJpbmVFdmVudFVpcyBhcyBhWCwgU3BsaXR0ZXIgYXMgYVksIGdldERheUNsYXNzTmFtZXMgYXMgYVosIGdldERhdGVNZXRhIGFzIGFfLCBmbHVzaFN5bmMgYXMgYWEsIENhbGVuZGFyUm9vdCBhcyBhYiwgUmVuZGVySWQgYXMgYWMsIGVuc3VyZUVsSGFzU3R5bGVzIGFzIGFkLCBhcHBseVN0eWxlUHJvcCBhcyBhZSwgc2xpY2VFdmVudFN0b3JlIGFzIGFmLCBKc29uUmVxdWVzdEVycm9yIGFzIGFnLCBjcmVhdGVDb250ZXh0IGFzIGFoLCByZWZpbmVQcm9wcyBhcyBhaSwgY3JlYXRlRXZlbnRJbnN0YW5jZSBhcyBhaiwgcGFyc2VFdmVudERlZiBhcyBhaywgcmVmaW5lRXZlbnREZWYgYXMgYWwsIHBhZFN0YXJ0IGFzIGFtLCBpc0ludCBhcyBhbiwgcGFyc2VGaWVsZFNwZWNzIGFzIGFvLCBjb21wYXJlQnlGaWVsZFNwZWNzIGFzIGFwLCBmbGV4aWJsZUNvbXBhcmUgYXMgYXEsIHByZXZlbnRTZWxlY3Rpb24gYXMgYXIsIGFsbG93U2VsZWN0aW9uIGFzIGFzLCBwcmV2ZW50Q29udGV4dE1lbnUgYXMgYXQsIGFsbG93Q29udGV4dE1lbnUgYXMgYXUsIGNvbXBhcmVOdW1iZXJzIGFzIGF2LCBlbmFibGVDdXJzb3IgYXMgYXcsIGRpc2FibGVDdXJzb3IgYXMgYXgsIGNvbXB1dGVWaXNpYmxlRGF5UmFuZ2UgYXMgYXksIGlzTXVsdGlEYXlSYW5nZSBhcyBheiwgYnVpbGRWaWV3Q2xhc3NOYW1lcyBhcyBiLCBTaW1wbGVTY3JvbGxHcmlkIGFzIGIkLCBidWlsZE5hdkxpbmtBdHRycyBhcyBiMCwgcHJldmVudERlZmF1bHQgYXMgYjEsIHdoZW5UcmFuc2l0aW9uRG9uZSBhcyBiMiwgY29tcHV0ZUlubmVyUmVjdCBhcyBiMywgY29tcHV0ZUVkZ2VzIGFzIGI0LCBnZXRDbGlwcGluZ1BhcmVudHMgYXMgYjUsIGNvbXB1dGVSZWN0IGFzIGI2LCByYW5nZXNFcXVhbCBhcyBiNywgcmFuZ2VzSW50ZXJzZWN0IGFzIGI4LCByYW5nZUNvbnRhaW5zUmFuZ2UgYXMgYjksIFNlZ0hpZXJhcmNoeSBhcyBiQSwgYnVpbGRFbnRyeUtleSBhcyBiQiwgZ2V0RW50cnlTcGFuRW5kIGFzIGJDLCBiaW5hcnlTZWFyY2ggYXMgYkQsIGdyb3VwSW50ZXJzZWN0aW5nRW50cmllcyBhcyBiRSwgaW50ZXJzZWN0U3BhbnMgYXMgYkYsIGludGVyYWN0aW9uU2V0dGluZ3NUb1N0b3JlIGFzIGJHLCBFbGVtZW50RHJhZ2dpbmcgYXMgYkgsIGNvbmZpZyBhcyBiSSwgcGFyc2VEcmFnTWV0YSBhcyBiSiwgRGF5SGVhZGVyIGFzIGJLLCBjb21wdXRlRmFsbGJhY2tIZWFkZXJGb3JtYXQgYXMgYkwsIFRhYmxlRGF0ZUNlbGwgYXMgYk0sIFRhYmxlRG93Q2VsbCBhcyBiTiwgRGF5U2VyaWVzTW9kZWwgYXMgYk8sIGhhc0JnUmVuZGVyaW5nIGFzIGJQLCBidWlsZFNlZ1RpbWVUZXh0IGFzIGJRLCBzb3J0RXZlbnRTZWdzIGFzIGJSLCBnZXRTZWdNZXRhIGFzIGJTLCBidWlsZEV2ZW50UmFuZ2VLZXkgYXMgYlQsIGdldFNlZ0FuY2hvckF0dHJzIGFzIGJVLCBEYXlUYWJsZU1vZGVsIGFzIGJWLCBTbGljZXIgYXMgYlcsIGFwcGx5TXV0YXRpb25Ub0V2ZW50U3RvcmUgYXMgYlgsIGlzUHJvcHNWYWxpZCBhcyBiWSwgaXNJbnRlcmFjdGlvblZhbGlkIGFzIGJaLCBpc0RhdGVTZWxlY3Rpb25WYWxpZCBhcyBiXywgUG9zaXRpb25DYWNoZSBhcyBiYSwgU2Nyb2xsQ29udHJvbGxlciBhcyBiYiwgRWxlbWVudFNjcm9sbENvbnRyb2xsZXIgYXMgYmMsIFdpbmRvd1Njcm9sbENvbnRyb2xsZXIgYXMgYmQsIERhdGVDb21wb25lbnQgYXMgYmUsIGlzRGF0ZVNwYW5zRXF1YWwgYXMgYmYsIGFkZE1zIGFzIGJnLCBhZGRXZWVrcyBhcyBiaCwgZGlmZldlZWtzIGFzIGJpLCBkaWZmV2hvbGVXZWVrcyBhcyBiaiwgZGlmZkRheUFuZFRpbWUgYXMgYmssIGRpZmZEYXlzIGFzIGJsLCBpc1ZhbGlkRGF0ZSBhcyBibSwgYXNDbGVhbkRheXMgYXMgYm4sIG11bHRpcGx5RHVyYXRpb24gYXMgYm8sIGFkZER1cmF0aW9ucyBhcyBicCwgYXNSb3VnaE1pbnV0ZXMgYXMgYnEsIGFzUm91Z2hTZWNvbmRzIGFzIGJyLCBhc1JvdWdoTXMgYXMgYnMsIHdob2xlRGl2aWRlRHVyYXRpb25zIGFzIGJ0LCBmb3JtYXRJc29UaW1lU3RyaW5nIGFzIGJ1LCBmb3JtYXREYXlTdHJpbmcgYXMgYnYsIGJ1aWxkSXNvU3RyaW5nIGFzIGJ3LCBmb3JtYXRJc29Nb250aFN0ciBhcyBieCwgTmFtZWRUaW1lWm9uZUltcGwgYXMgYnksIHBhcnNlIGFzIGJ6LCBncmVhdGVzdER1cmF0aW9uRGVub21pbmF0b3IgYXMgYywgaGFzU2hyaW5rV2lkdGggYXMgYzAsIHJlbmRlck1pY3JvQ29sR3JvdXAgYXMgYzEsIGdldFNjcm9sbEdyaWRDbGFzc05hbWVzIGFzIGMyLCBnZXRTZWN0aW9uQ2xhc3NOYW1lcyBhcyBjMywgZ2V0U2VjdGlvbkhhc0xpcXVpZEhlaWdodCBhcyBjNCwgZ2V0QWxsb3dZU2Nyb2xsaW5nIGFzIGM1LCByZW5kZXJDaHVua0NvbnRlbnQgYXMgYzYsIGNvbXB1dGVTaHJpbmtXaWR0aCBhcyBjNywgc2FuaXRpemVTaHJpbmtXaWR0aCBhcyBjOCwgaXNDb2xQcm9wc0VxdWFsIGFzIGM5LCByZW5kZXJTY3JvbGxTaGltIGFzIGNhLCBnZXRTdGlja3lGb290ZXJTY3JvbGxiYXIgYXMgY2IsIGdldFN0aWNreUhlYWRlckRhdGVzIGFzIGNjLCBTY3JvbGxlciBhcyBjZCwgZ2V0U2Nyb2xsYmFyV2lkdGhzIGFzIGNlLCBSZWZNYXAgYXMgY2YsIGdldElzUnRsU2Nyb2xsYmFyT25MZWZ0IGFzIGNnLCBOb3dUaW1lciBhcyBjaCwgU2Nyb2xsUmVzcG9uZGVyIGFzIGNpLCBTdGFuZGFyZEV2ZW50IGFzIGNqLCBOb3dJbmRpY2F0b3JDb250YWluZXIgYXMgY2ssIERheUNlbGxDb250YWluZXIgYXMgY2wsIGhhc0N1c3RvbURheUNlbGxDb250ZW50IGFzIGNtLCBFdmVudENvbnRhaW5lciBhcyBjbiwgcmVuZGVyRmlsbCBhcyBjbywgQmdFdmVudCBhcyBjcCwgV2Vla051bWJlckNvbnRhaW5lciBhcyBjcSwgTW9yZUxpbmtDb250YWluZXIgYXMgY3IsIGNvbXB1dGVFYXJsaWVzdFNlZ1N0YXJ0IGFzIGNzLCBWaWV3Q29udGFpbmVyIGFzIGN0LCB0cmlnZ2VyRGF0ZVNlbGVjdCBhcyBjdSwgZ2V0RGVmYXVsdEV2ZW50RW5kIGFzIGN2LCBpbmplY3RTdHlsZXMgYXMgY3csIGJ1aWxkRWxBdHRycyBhcyBjeCwgQ3VzdG9tUmVuZGVyaW5nU3RvcmUgYXMgY3ksIGNyZWF0ZUR1cmF0aW9uIGFzIGQsIEJBU0VfT1BUSU9OX0RFRkFVTFRTIGFzIGUsIGFycmF5VG9IYXNoIGFzIGYsIGd1aWQgYXMgZywgZmlsdGVySGFzaCBhcyBoLCBpc0FycmF5c0VxdWFsIGFzIGksIGJ1aWxkRXZlbnRTb3VyY2VSZWZpbmVycyBhcyBqLCBmb3JtYXRXaXRoT3JkaW5hbHMgYXMgaywgYnVpbGRSYW5nZUFwaVdpdGhUaW1lWm9uZSBhcyBsLCBtZXJnZVByb3BzIGFzIG0sIGlkZW50aXR5IGFzIG4sIGludGVyc2VjdFJhbmdlcyBhcyBvLCBwYXJzZUV2ZW50U291cmNlIGFzIHAsIHN0YXJ0T2ZEYXkgYXMgcSwgcmVxdWVzdEpzb24gYXMgciwgc3VidHJhY3REdXJhdGlvbnMgYXMgcywgYWRkRGF5cyBhcyB0LCB1bnByb21pc2lmeSBhcyB1LCBoYXNoVmFsdWVzVG9BcnJheSBhcyB2LCBidWlsZEV2ZW50QXBpcyBhcyB3LCBjcmVhdGVGb3JtYXR0ZXIgYXMgeCwgZGlmZldob2xlRGF5cyBhcyB5LCBtZW1vaXplIGFzIHogfTtcbiIsICJpbXBvcnQgeyBtIGFzIG1lcmdlUHJvcHMsIGcgYXMgZ3VpZCwgaSBhcyBpc0FycmF5c0VxdWFsLCBUIGFzIFRoZW1lLCBhIGFzIG1hcEhhc2gsIEIgYXMgQmFzZUNvbXBvbmVudCwgViBhcyBWaWV3Q29udGV4dFR5cGUsIEMgYXMgQ29udGVudENvbnRhaW5lciwgYiBhcyBidWlsZFZpZXdDbGFzc05hbWVzLCBjIGFzIGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvciwgZCBhcyBjcmVhdGVEdXJhdGlvbiwgZSBhcyBCQVNFX09QVElPTl9ERUZBVUxUUywgZiBhcyBhcnJheVRvSGFzaCwgaCBhcyBmaWx0ZXJIYXNoLCBqIGFzIGJ1aWxkRXZlbnRTb3VyY2VSZWZpbmVycywgcCBhcyBwYXJzZUV2ZW50U291cmNlLCBrIGFzIGZvcm1hdFdpdGhPcmRpbmFscywgdSBhcyB1bnByb21pc2lmeSwgbCBhcyBidWlsZFJhbmdlQXBpV2l0aFRpbWVab25lLCBuIGFzIGlkZW50aXR5LCByIGFzIHJlcXVlc3RKc29uLCBzIGFzIHN1YnRyYWN0RHVyYXRpb25zLCBvIGFzIGludGVyc2VjdFJhbmdlcywgcSBhcyBzdGFydE9mRGF5LCB0IGFzIGFkZERheXMsIHYgYXMgaGFzaFZhbHVlc1RvQXJyYXksIHcgYXMgYnVpbGRFdmVudEFwaXMsIEQgYXMgRGVsYXllZFJ1bm5lciwgeCBhcyBjcmVhdGVGb3JtYXR0ZXIsIHkgYXMgZGlmZldob2xlRGF5cywgeiBhcyBtZW1vaXplLCBBIGFzIG1lbW9pemVPYmpBcmcsIEUgYXMgaXNQcm9wc0VxdWFsLCBGIGFzIEVtaXR0ZXIsIEcgYXMgZ2V0SW5pdGlhbERhdGUsIEggYXMgcmFuZ2VDb250YWluc01hcmtlciwgSSBhcyBjcmVhdGVFbXB0eUV2ZW50U3RvcmUsIEogYXMgcmVkdWNlQ3VycmVudERhdGUsIEsgYXMgcmVkdWNlRXZlbnRTdG9yZSwgTCBhcyByZXpvbmVFdmVudFN0b3JlRGF0ZXMsIE0gYXMgbWVyZ2VSYXdPcHRpb25zLCBOIGFzIEJBU0VfT1BUSU9OX1JFRklORVJTLCBPIGFzIENBTEVOREFSX0xJU1RFTkVSX1JFRklORVJTLCBQIGFzIENBTEVOREFSX09QVElPTl9SRUZJTkVSUywgUSBhcyBDT01QTEVYX09QVElPTl9DT01QQVJBVE9SUywgUiBhcyBWSUVXX09QVElPTl9SRUZJTkVSUywgUyBhcyBEYXRlRW52LCBVIGFzIERhdGVQcm9maWxlR2VuZXJhdG9yLCBXIGFzIGNyZWF0ZUV2ZW50VWksIFggYXMgcGFyc2VCdXNpbmVzc0hvdXJzLCBZIGFzIHNldFJlZiwgWiBhcyBJbnRlcmFjdGlvbiwgXyBhcyBnZXRFbFNlZywgJCBhcyBlbGVtZW50Q2xvc2VzdCwgYTAgYXMgRXZlbnRJbXBsLCBhMSBhcyBsaXN0ZW5CeVNlbGVjdG9yLCBhMiBhcyBsaXN0ZW5Ub0hvdmVyQnlTZWxlY3RvciwgYTMgYXMgUHVyZUNvbXBvbmVudCwgYTQgYXMgYnVpbGRWaWV3Q29udGV4dCwgYTUgYXMgZ2V0VW5pcXVlRG9tSWQsIGE2IGFzIHBhcnNlSW50ZXJhY3Rpb25TZXR0aW5ncywgYTcgYXMgaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlLCBhOCBhcyBnZXROb3csIGE5IGFzIENhbGVuZGFySW1wbCwgYWEgYXMgZmx1c2hTeW5jLCBhYiBhcyBDYWxlbmRhclJvb3QsIGFjIGFzIFJlbmRlcklkLCBhZCBhcyBlbnN1cmVFbEhhc1N0eWxlcywgYWUgYXMgYXBwbHlTdHlsZVByb3AsIGFmIGFzIHNsaWNlRXZlbnRTdG9yZSB9IGZyb20gJy4vaW50ZXJuYWwtY29tbW9uLmpzJztcbmV4cG9ydCB7IGFnIGFzIEpzb25SZXF1ZXN0RXJyb3IgfSBmcm9tICcuL2ludGVybmFsLWNvbW1vbi5qcyc7XG5pbXBvcnQgeyBjcmVhdGVFbGVtZW50LCBjcmVhdGVSZWYsIEZyYWdtZW50LCByZW5kZXIgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0ICdwcmVhY3QvY29tcGF0JztcblxuY29uc3QgZ2xvYmFsTG9jYWxlcyA9IFtdO1xuXG5jb25zdCBNSU5JTUFMX1JBV19FTl9MT0NBTEUgPSB7XG4gICAgY29kZTogJ2VuJyxcbiAgICB3ZWVrOiB7XG4gICAgICAgIGRvdzogMCxcbiAgICAgICAgZG95OiA0LCAvLyA0IGRheXMgbmVlZCB0byBiZSB3aXRoaW4gdGhlIHllYXIgdG8gYmUgY29uc2lkZXJlZCB0aGUgZmlyc3Qgd2Vla1xuICAgIH0sXG4gICAgZGlyZWN0aW9uOiAnbHRyJyxcbiAgICBidXR0b25UZXh0OiB7XG4gICAgICAgIHByZXY6ICdwcmV2JyxcbiAgICAgICAgbmV4dDogJ25leHQnLFxuICAgICAgICBwcmV2WWVhcjogJ3ByZXYgeWVhcicsXG4gICAgICAgIG5leHRZZWFyOiAnbmV4dCB5ZWFyJyxcbiAgICAgICAgeWVhcjogJ3llYXInLFxuICAgICAgICB0b2RheTogJ3RvZGF5JyxcbiAgICAgICAgbW9udGg6ICdtb250aCcsXG4gICAgICAgIHdlZWs6ICd3ZWVrJyxcbiAgICAgICAgZGF5OiAnZGF5JyxcbiAgICAgICAgbGlzdDogJ2xpc3QnLFxuICAgIH0sXG4gICAgd2Vla1RleHQ6ICdXJyxcbiAgICB3ZWVrVGV4dExvbmc6ICdXZWVrJyxcbiAgICBjbG9zZUhpbnQ6ICdDbG9zZScsXG4gICAgdGltZUhpbnQ6ICdUaW1lJyxcbiAgICBldmVudEhpbnQ6ICdFdmVudCcsXG4gICAgYWxsRGF5VGV4dDogJ2FsbC1kYXknLFxuICAgIG1vcmVMaW5rVGV4dDogJ21vcmUnLFxuICAgIG5vRXZlbnRzVGV4dDogJ05vIGV2ZW50cyB0byBkaXNwbGF5Jyxcbn07XG5jb25zdCBSQVdfRU5fTE9DQUxFID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBNSU5JTUFMX1JBV19FTl9MT0NBTEUpLCB7IFxuICAgIC8vIEluY2x1ZGVzIHRoaW5ncyB3ZSBkb24ndCB3YW50IG90aGVyIGxvY2FsZXMgdG8gaW5oZXJpdCxcbiAgICAvLyB0aGluZ3MgdGhhdCBkZXJpdmUgZnJvbSBvdGhlciB0cmFuc2xhdGFibGUgc3RyaW5ncy5cbiAgICBidXR0b25IaW50czoge1xuICAgICAgICBwcmV2OiAnUHJldmlvdXMgJDAnLFxuICAgICAgICBuZXh0OiAnTmV4dCAkMCcsXG4gICAgICAgIHRvZGF5KGJ1dHRvblRleHQsIHVuaXQpIHtcbiAgICAgICAgICAgIHJldHVybiAodW5pdCA9PT0gJ2RheScpXG4gICAgICAgICAgICAgICAgPyAnVG9kYXknXG4gICAgICAgICAgICAgICAgOiBgVGhpcyAke2J1dHRvblRleHR9YDtcbiAgICAgICAgfSxcbiAgICB9LCB2aWV3SGludDogJyQwIHZpZXcnLCBuYXZMaW5rSGludDogJ0dvIHRvICQwJywgbW9yZUxpbmtIaW50KGV2ZW50Q250KSB7XG4gICAgICAgIHJldHVybiBgU2hvdyAke2V2ZW50Q250fSBtb3JlIGV2ZW50JHtldmVudENudCA9PT0gMSA/ICcnIDogJ3MnfWA7XG4gICAgfSB9KTtcbmZ1bmN0aW9uIG9yZ2FuaXplUmF3TG9jYWxlcyhleHBsaWNpdFJhd0xvY2FsZXMpIHtcbiAgICBsZXQgZGVmYXVsdENvZGUgPSBleHBsaWNpdFJhd0xvY2FsZXMubGVuZ3RoID4gMCA/IGV4cGxpY2l0UmF3TG9jYWxlc1swXS5jb2RlIDogJ2VuJztcbiAgICBsZXQgYWxsUmF3TG9jYWxlcyA9IGdsb2JhbExvY2FsZXMuY29uY2F0KGV4cGxpY2l0UmF3TG9jYWxlcyk7XG4gICAgbGV0IHJhd0xvY2FsZU1hcCA9IHtcbiAgICAgICAgZW46IFJBV19FTl9MT0NBTEUsXG4gICAgfTtcbiAgICBmb3IgKGxldCByYXdMb2NhbGUgb2YgYWxsUmF3TG9jYWxlcykge1xuICAgICAgICByYXdMb2NhbGVNYXBbcmF3TG9jYWxlLmNvZGVdID0gcmF3TG9jYWxlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBtYXA6IHJhd0xvY2FsZU1hcCxcbiAgICAgICAgZGVmYXVsdENvZGUsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkTG9jYWxlKGlucHV0U2luZ3VsYXIsIGF2YWlsYWJsZSkge1xuICAgIGlmICh0eXBlb2YgaW5wdXRTaW5ndWxhciA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoaW5wdXRTaW5ndWxhcikpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlTG9jYWxlKGlucHV0U2luZ3VsYXIuY29kZSwgW2lucHV0U2luZ3VsYXIuY29kZV0sIGlucHV0U2luZ3VsYXIpO1xuICAgIH1cbiAgICByZXR1cm4gcXVlcnlMb2NhbGUoaW5wdXRTaW5ndWxhciwgYXZhaWxhYmxlKTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5TG9jYWxlKGNvZGVBcmcsIGF2YWlsYWJsZSkge1xuICAgIGxldCBjb2RlcyA9IFtdLmNvbmNhdChjb2RlQXJnIHx8IFtdKTsgLy8gd2lsbCBjb252ZXJ0IHRvIGFycmF5XG4gICAgbGV0IHJhdyA9IHF1ZXJ5UmF3TG9jYWxlKGNvZGVzLCBhdmFpbGFibGUpIHx8IFJBV19FTl9MT0NBTEU7XG4gICAgcmV0dXJuIHBhcnNlTG9jYWxlKGNvZGVBcmcsIGNvZGVzLCByYXcpO1xufVxuZnVuY3Rpb24gcXVlcnlSYXdMb2NhbGUoY29kZXMsIGF2YWlsYWJsZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29kZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgbGV0IHBhcnRzID0gY29kZXNbaV0udG9Mb2NhbGVMb3dlckNhc2UoKS5zcGxpdCgnLScpO1xuICAgICAgICBmb3IgKGxldCBqID0gcGFydHMubGVuZ3RoOyBqID4gMDsgaiAtPSAxKSB7XG4gICAgICAgICAgICBsZXQgc2ltcGxlSWQgPSBwYXJ0cy5zbGljZSgwLCBqKS5qb2luKCctJyk7XG4gICAgICAgICAgICBpZiAoYXZhaWxhYmxlW3NpbXBsZUlkXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhdmFpbGFibGVbc2ltcGxlSWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcGFyc2VMb2NhbGUoY29kZUFyZywgY29kZXMsIHJhdykge1xuICAgIGxldCBtZXJnZWQgPSBtZXJnZVByb3BzKFtNSU5JTUFMX1JBV19FTl9MT0NBTEUsIHJhd10sIFsnYnV0dG9uVGV4dCddKTtcbiAgICBkZWxldGUgbWVyZ2VkLmNvZGU7IC8vIGRvbid0IHdhbnQgdGhpcyBwYXJ0IG9mIHRoZSBvcHRpb25zXG4gICAgbGV0IHsgd2VlayB9ID0gbWVyZ2VkO1xuICAgIGRlbGV0ZSBtZXJnZWQud2VlaztcbiAgICByZXR1cm4ge1xuICAgICAgICBjb2RlQXJnLFxuICAgICAgICBjb2RlcyxcbiAgICAgICAgd2VlayxcbiAgICAgICAgc2ltcGxlTnVtYmVyRm9ybWF0OiBuZXcgSW50bC5OdW1iZXJGb3JtYXQoY29kZUFyZyksXG4gICAgICAgIG9wdGlvbnM6IG1lcmdlZCxcbiAgICB9O1xufVxuXG4vLyBUT0RPOiBlYXNpZXIgd2F5IHRvIGFkZCBuZXcgaG9va3M/IG5lZWQgdG8gdXBkYXRlIGEgbWlsbGlvbiB0aGluZ3NcbmZ1bmN0aW9uIGNyZWF0ZVBsdWdpbihpbnB1dCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBndWlkKCksXG4gICAgICAgIG5hbWU6IGlucHV0Lm5hbWUsXG4gICAgICAgIHByZW1pdW1SZWxlYXNlRGF0ZTogaW5wdXQucHJlbWl1bVJlbGVhc2VEYXRlID8gbmV3IERhdGUoaW5wdXQucHJlbWl1bVJlbGVhc2VEYXRlKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZGVwczogaW5wdXQuZGVwcyB8fCBbXSxcbiAgICAgICAgcmVkdWNlcnM6IGlucHV0LnJlZHVjZXJzIHx8IFtdLFxuICAgICAgICBpc0xvYWRpbmdGdW5jczogaW5wdXQuaXNMb2FkaW5nRnVuY3MgfHwgW10sXG4gICAgICAgIGNvbnRleHRJbml0OiBbXS5jb25jYXQoaW5wdXQuY29udGV4dEluaXQgfHwgW10pLFxuICAgICAgICBldmVudFJlZmluZXJzOiBpbnB1dC5ldmVudFJlZmluZXJzIHx8IHt9LFxuICAgICAgICBldmVudERlZk1lbWJlckFkZGVyczogaW5wdXQuZXZlbnREZWZNZW1iZXJBZGRlcnMgfHwgW10sXG4gICAgICAgIGV2ZW50U291cmNlUmVmaW5lcnM6IGlucHV0LmV2ZW50U291cmNlUmVmaW5lcnMgfHwge30sXG4gICAgICAgIGlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzOiBpbnB1dC5pc0RyYWdnYWJsZVRyYW5zZm9ybWVycyB8fCBbXSxcbiAgICAgICAgZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnM6IGlucHV0LmV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzIHx8IFtdLFxuICAgICAgICBldmVudERlZk11dGF0aW9uQXBwbGllcnM6IGlucHV0LmV2ZW50RGVmTXV0YXRpb25BcHBsaWVycyB8fCBbXSxcbiAgICAgICAgZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVyczogaW5wdXQuZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVycyB8fCBbXSxcbiAgICAgICAgZGF0ZVBvaW50VHJhbnNmb3JtczogaW5wdXQuZGF0ZVBvaW50VHJhbnNmb3JtcyB8fCBbXSxcbiAgICAgICAgZGF0ZVNwYW5UcmFuc2Zvcm1zOiBpbnB1dC5kYXRlU3BhblRyYW5zZm9ybXMgfHwgW10sXG4gICAgICAgIHZpZXdzOiBpbnB1dC52aWV3cyB8fCB7fSxcbiAgICAgICAgdmlld1Byb3BzVHJhbnNmb3JtZXJzOiBpbnB1dC52aWV3UHJvcHNUcmFuc2Zvcm1lcnMgfHwgW10sXG4gICAgICAgIGlzUHJvcHNWYWxpZDogaW5wdXQuaXNQcm9wc1ZhbGlkIHx8IG51bGwsXG4gICAgICAgIGV4dGVybmFsRGVmVHJhbnNmb3JtczogaW5wdXQuZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zIHx8IFtdLFxuICAgICAgICB2aWV3Q29udGFpbmVyQXBwZW5kczogaW5wdXQudmlld0NvbnRhaW5lckFwcGVuZHMgfHwgW10sXG4gICAgICAgIGV2ZW50RHJvcFRyYW5zZm9ybWVyczogaW5wdXQuZXZlbnREcm9wVHJhbnNmb3JtZXJzIHx8IFtdLFxuICAgICAgICBjb21wb25lbnRJbnRlcmFjdGlvbnM6IGlucHV0LmNvbXBvbmVudEludGVyYWN0aW9ucyB8fCBbXSxcbiAgICAgICAgY2FsZW5kYXJJbnRlcmFjdGlvbnM6IGlucHV0LmNhbGVuZGFySW50ZXJhY3Rpb25zIHx8IFtdLFxuICAgICAgICB0aGVtZUNsYXNzZXM6IGlucHV0LnRoZW1lQ2xhc3NlcyB8fCB7fSxcbiAgICAgICAgZXZlbnRTb3VyY2VEZWZzOiBpbnB1dC5ldmVudFNvdXJjZURlZnMgfHwgW10sXG4gICAgICAgIGNtZEZvcm1hdHRlcjogaW5wdXQuY21kRm9ybWF0dGVyLFxuICAgICAgICByZWN1cnJpbmdUeXBlczogaW5wdXQucmVjdXJyaW5nVHlwZXMgfHwgW10sXG4gICAgICAgIG5hbWVkVGltZVpvbmVkSW1wbDogaW5wdXQubmFtZWRUaW1lWm9uZWRJbXBsLFxuICAgICAgICBpbml0aWFsVmlldzogaW5wdXQuaW5pdGlhbFZpZXcgfHwgJycsXG4gICAgICAgIGVsZW1lbnREcmFnZ2luZ0ltcGw6IGlucHV0LmVsZW1lbnREcmFnZ2luZ0ltcGwsXG4gICAgICAgIG9wdGlvbkNoYW5nZUhhbmRsZXJzOiBpbnB1dC5vcHRpb25DaGFuZ2VIYW5kbGVycyB8fCB7fSxcbiAgICAgICAgc2Nyb2xsR3JpZEltcGw6IGlucHV0LnNjcm9sbEdyaWRJbXBsIHx8IG51bGwsXG4gICAgICAgIGxpc3RlbmVyUmVmaW5lcnM6IGlucHV0Lmxpc3RlbmVyUmVmaW5lcnMgfHwge30sXG4gICAgICAgIG9wdGlvblJlZmluZXJzOiBpbnB1dC5vcHRpb25SZWZpbmVycyB8fCB7fSxcbiAgICAgICAgcHJvcFNldEhhbmRsZXJzOiBpbnB1dC5wcm9wU2V0SGFuZGxlcnMgfHwge30sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkUGx1Z2luSG9va3MocGx1Z2luRGVmcywgZ2xvYmFsRGVmcykge1xuICAgIGxldCBjdXJyZW50UGx1Z2luSWRzID0ge307XG4gICAgbGV0IGhvb2tzID0ge1xuICAgICAgICBwcmVtaXVtUmVsZWFzZURhdGU6IHVuZGVmaW5lZCxcbiAgICAgICAgcmVkdWNlcnM6IFtdLFxuICAgICAgICBpc0xvYWRpbmdGdW5jczogW10sXG4gICAgICAgIGNvbnRleHRJbml0OiBbXSxcbiAgICAgICAgZXZlbnRSZWZpbmVyczoge30sXG4gICAgICAgIGV2ZW50RGVmTWVtYmVyQWRkZXJzOiBbXSxcbiAgICAgICAgZXZlbnRTb3VyY2VSZWZpbmVyczoge30sXG4gICAgICAgIGlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzOiBbXSxcbiAgICAgICAgZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnM6IFtdLFxuICAgICAgICBldmVudERlZk11dGF0aW9uQXBwbGllcnM6IFtdLFxuICAgICAgICBkYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzOiBbXSxcbiAgICAgICAgZGF0ZVBvaW50VHJhbnNmb3JtczogW10sXG4gICAgICAgIGRhdGVTcGFuVHJhbnNmb3JtczogW10sXG4gICAgICAgIHZpZXdzOiB7fSxcbiAgICAgICAgdmlld1Byb3BzVHJhbnNmb3JtZXJzOiBbXSxcbiAgICAgICAgaXNQcm9wc1ZhbGlkOiBudWxsLFxuICAgICAgICBleHRlcm5hbERlZlRyYW5zZm9ybXM6IFtdLFxuICAgICAgICB2aWV3Q29udGFpbmVyQXBwZW5kczogW10sXG4gICAgICAgIGV2ZW50RHJvcFRyYW5zZm9ybWVyczogW10sXG4gICAgICAgIGNvbXBvbmVudEludGVyYWN0aW9uczogW10sXG4gICAgICAgIGNhbGVuZGFySW50ZXJhY3Rpb25zOiBbXSxcbiAgICAgICAgdGhlbWVDbGFzc2VzOiB7fSxcbiAgICAgICAgZXZlbnRTb3VyY2VEZWZzOiBbXSxcbiAgICAgICAgY21kRm9ybWF0dGVyOiBudWxsLFxuICAgICAgICByZWN1cnJpbmdUeXBlczogW10sXG4gICAgICAgIG5hbWVkVGltZVpvbmVkSW1wbDogbnVsbCxcbiAgICAgICAgaW5pdGlhbFZpZXc6ICcnLFxuICAgICAgICBlbGVtZW50RHJhZ2dpbmdJbXBsOiBudWxsLFxuICAgICAgICBvcHRpb25DaGFuZ2VIYW5kbGVyczoge30sXG4gICAgICAgIHNjcm9sbEdyaWRJbXBsOiBudWxsLFxuICAgICAgICBsaXN0ZW5lclJlZmluZXJzOiB7fSxcbiAgICAgICAgb3B0aW9uUmVmaW5lcnM6IHt9LFxuICAgICAgICBwcm9wU2V0SGFuZGxlcnM6IHt9LFxuICAgIH07XG4gICAgZnVuY3Rpb24gYWRkRGVmcyhkZWZzKSB7XG4gICAgICAgIGZvciAobGV0IGRlZiBvZiBkZWZzKSB7XG4gICAgICAgICAgICBjb25zdCBwbHVnaW5OYW1lID0gZGVmLm5hbWU7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50SWQgPSBjdXJyZW50UGx1Z2luSWRzW3BsdWdpbk5hbWVdO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFBsdWdpbklkc1twbHVnaW5OYW1lXSA9IGRlZi5pZDtcbiAgICAgICAgICAgICAgICBhZGREZWZzKGRlZi5kZXBzKTtcbiAgICAgICAgICAgICAgICBob29rcyA9IGNvbWJpbmVIb29rcyhob29rcywgZGVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnRJZCAhPT0gZGVmLmlkKSB7XG4gICAgICAgICAgICAgICAgLy8gZGlmZmVyZW50IElEIHRoYW4gdGhlIG9uZSBhbHJlYWR5IGFkZGVkXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBEdXBsaWNhdGUgcGx1Z2luICcke3BsdWdpbk5hbWV9J2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwbHVnaW5EZWZzKSB7XG4gICAgICAgIGFkZERlZnMocGx1Z2luRGVmcyk7XG4gICAgfVxuICAgIGFkZERlZnMoZ2xvYmFsRGVmcyk7XG4gICAgcmV0dXJuIGhvb2tzO1xufVxuZnVuY3Rpb24gYnVpbGRCdWlsZFBsdWdpbkhvb2tzKCkge1xuICAgIGxldCBjdXJyZW50T3ZlcnJpZGVEZWZzID0gW107XG4gICAgbGV0IGN1cnJlbnRHbG9iYWxEZWZzID0gW107XG4gICAgbGV0IGN1cnJlbnRIb29rcztcbiAgICByZXR1cm4gKG92ZXJyaWRlRGVmcywgZ2xvYmFsRGVmcykgPT4ge1xuICAgICAgICBpZiAoIWN1cnJlbnRIb29rcyB8fCAhaXNBcnJheXNFcXVhbChvdmVycmlkZURlZnMsIGN1cnJlbnRPdmVycmlkZURlZnMpIHx8ICFpc0FycmF5c0VxdWFsKGdsb2JhbERlZnMsIGN1cnJlbnRHbG9iYWxEZWZzKSkge1xuICAgICAgICAgICAgY3VycmVudEhvb2tzID0gYnVpbGRQbHVnaW5Ib29rcyhvdmVycmlkZURlZnMsIGdsb2JhbERlZnMpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRPdmVycmlkZURlZnMgPSBvdmVycmlkZURlZnM7XG4gICAgICAgIGN1cnJlbnRHbG9iYWxEZWZzID0gZ2xvYmFsRGVmcztcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRIb29rcztcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tYmluZUhvb2tzKGhvb2tzMCwgaG9va3MxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJlbWl1bVJlbGVhc2VEYXRlOiBjb21wYXJlT3B0aW9uYWxEYXRlcyhob29rczAucHJlbWl1bVJlbGVhc2VEYXRlLCBob29rczEucHJlbWl1bVJlbGVhc2VEYXRlKSxcbiAgICAgICAgcmVkdWNlcnM6IGhvb2tzMC5yZWR1Y2Vycy5jb25jYXQoaG9va3MxLnJlZHVjZXJzKSxcbiAgICAgICAgaXNMb2FkaW5nRnVuY3M6IGhvb2tzMC5pc0xvYWRpbmdGdW5jcy5jb25jYXQoaG9va3MxLmlzTG9hZGluZ0Z1bmNzKSxcbiAgICAgICAgY29udGV4dEluaXQ6IGhvb2tzMC5jb250ZXh0SW5pdC5jb25jYXQoaG9va3MxLmNvbnRleHRJbml0KSxcbiAgICAgICAgZXZlbnRSZWZpbmVyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBob29rczAuZXZlbnRSZWZpbmVycyksIGhvb2tzMS5ldmVudFJlZmluZXJzKSxcbiAgICAgICAgZXZlbnREZWZNZW1iZXJBZGRlcnM6IGhvb2tzMC5ldmVudERlZk1lbWJlckFkZGVycy5jb25jYXQoaG9va3MxLmV2ZW50RGVmTWVtYmVyQWRkZXJzKSxcbiAgICAgICAgZXZlbnRTb3VyY2VSZWZpbmVyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBob29rczAuZXZlbnRTb3VyY2VSZWZpbmVycyksIGhvb2tzMS5ldmVudFNvdXJjZVJlZmluZXJzKSxcbiAgICAgICAgaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnM6IGhvb2tzMC5pc0RyYWdnYWJsZVRyYW5zZm9ybWVycy5jb25jYXQoaG9va3MxLmlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzKSxcbiAgICAgICAgZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnM6IGhvb2tzMC5ldmVudERyYWdNdXRhdGlvbk1hc3NhZ2Vycy5jb25jYXQoaG9va3MxLmV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzKSxcbiAgICAgICAgZXZlbnREZWZNdXRhdGlvbkFwcGxpZXJzOiBob29rczAuZXZlbnREZWZNdXRhdGlvbkFwcGxpZXJzLmNvbmNhdChob29rczEuZXZlbnREZWZNdXRhdGlvbkFwcGxpZXJzKSxcbiAgICAgICAgZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVyczogaG9va3MwLmRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnMuY29uY2F0KGhvb2tzMS5kYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzKSxcbiAgICAgICAgZGF0ZVBvaW50VHJhbnNmb3JtczogaG9va3MwLmRhdGVQb2ludFRyYW5zZm9ybXMuY29uY2F0KGhvb2tzMS5kYXRlUG9pbnRUcmFuc2Zvcm1zKSxcbiAgICAgICAgZGF0ZVNwYW5UcmFuc2Zvcm1zOiBob29rczAuZGF0ZVNwYW5UcmFuc2Zvcm1zLmNvbmNhdChob29rczEuZGF0ZVNwYW5UcmFuc2Zvcm1zKSxcbiAgICAgICAgdmlld3M6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaG9va3MwLnZpZXdzKSwgaG9va3MxLnZpZXdzKSxcbiAgICAgICAgdmlld1Byb3BzVHJhbnNmb3JtZXJzOiBob29rczAudmlld1Byb3BzVHJhbnNmb3JtZXJzLmNvbmNhdChob29rczEudmlld1Byb3BzVHJhbnNmb3JtZXJzKSxcbiAgICAgICAgaXNQcm9wc1ZhbGlkOiBob29rczEuaXNQcm9wc1ZhbGlkIHx8IGhvb2tzMC5pc1Byb3BzVmFsaWQsXG4gICAgICAgIGV4dGVybmFsRGVmVHJhbnNmb3JtczogaG9va3MwLmV4dGVybmFsRGVmVHJhbnNmb3Jtcy5jb25jYXQoaG9va3MxLmV4dGVybmFsRGVmVHJhbnNmb3JtcyksXG4gICAgICAgIHZpZXdDb250YWluZXJBcHBlbmRzOiBob29rczAudmlld0NvbnRhaW5lckFwcGVuZHMuY29uY2F0KGhvb2tzMS52aWV3Q29udGFpbmVyQXBwZW5kcyksXG4gICAgICAgIGV2ZW50RHJvcFRyYW5zZm9ybWVyczogaG9va3MwLmV2ZW50RHJvcFRyYW5zZm9ybWVycy5jb25jYXQoaG9va3MxLmV2ZW50RHJvcFRyYW5zZm9ybWVycyksXG4gICAgICAgIGNhbGVuZGFySW50ZXJhY3Rpb25zOiBob29rczAuY2FsZW5kYXJJbnRlcmFjdGlvbnMuY29uY2F0KGhvb2tzMS5jYWxlbmRhckludGVyYWN0aW9ucyksXG4gICAgICAgIGNvbXBvbmVudEludGVyYWN0aW9uczogaG9va3MwLmNvbXBvbmVudEludGVyYWN0aW9ucy5jb25jYXQoaG9va3MxLmNvbXBvbmVudEludGVyYWN0aW9ucyksXG4gICAgICAgIHRoZW1lQ2xhc3NlczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBob29rczAudGhlbWVDbGFzc2VzKSwgaG9va3MxLnRoZW1lQ2xhc3NlcyksXG4gICAgICAgIGV2ZW50U291cmNlRGVmczogaG9va3MwLmV2ZW50U291cmNlRGVmcy5jb25jYXQoaG9va3MxLmV2ZW50U291cmNlRGVmcyksXG4gICAgICAgIGNtZEZvcm1hdHRlcjogaG9va3MxLmNtZEZvcm1hdHRlciB8fCBob29rczAuY21kRm9ybWF0dGVyLFxuICAgICAgICByZWN1cnJpbmdUeXBlczogaG9va3MwLnJlY3VycmluZ1R5cGVzLmNvbmNhdChob29rczEucmVjdXJyaW5nVHlwZXMpLFxuICAgICAgICBuYW1lZFRpbWVab25lZEltcGw6IGhvb2tzMS5uYW1lZFRpbWVab25lZEltcGwgfHwgaG9va3MwLm5hbWVkVGltZVpvbmVkSW1wbCxcbiAgICAgICAgaW5pdGlhbFZpZXc6IGhvb2tzMC5pbml0aWFsVmlldyB8fCBob29rczEuaW5pdGlhbFZpZXcsXG4gICAgICAgIGVsZW1lbnREcmFnZ2luZ0ltcGw6IGhvb2tzMC5lbGVtZW50RHJhZ2dpbmdJbXBsIHx8IGhvb2tzMS5lbGVtZW50RHJhZ2dpbmdJbXBsLFxuICAgICAgICBvcHRpb25DaGFuZ2VIYW5kbGVyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBob29rczAub3B0aW9uQ2hhbmdlSGFuZGxlcnMpLCBob29rczEub3B0aW9uQ2hhbmdlSGFuZGxlcnMpLFxuICAgICAgICBzY3JvbGxHcmlkSW1wbDogaG9va3MxLnNjcm9sbEdyaWRJbXBsIHx8IGhvb2tzMC5zY3JvbGxHcmlkSW1wbCxcbiAgICAgICAgbGlzdGVuZXJSZWZpbmVyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBob29rczAubGlzdGVuZXJSZWZpbmVycyksIGhvb2tzMS5saXN0ZW5lclJlZmluZXJzKSxcbiAgICAgICAgb3B0aW9uUmVmaW5lcnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaG9va3MwLm9wdGlvblJlZmluZXJzKSwgaG9va3MxLm9wdGlvblJlZmluZXJzKSxcbiAgICAgICAgcHJvcFNldEhhbmRsZXJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGhvb2tzMC5wcm9wU2V0SGFuZGxlcnMpLCBob29rczEucHJvcFNldEhhbmRsZXJzKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcGFyZU9wdGlvbmFsRGF0ZXMoZGF0ZTAsIGRhdGUxKSB7XG4gICAgaWYgKGRhdGUwID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGRhdGUxO1xuICAgIH1cbiAgICBpZiAoZGF0ZTEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZGF0ZTA7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGF0ZShNYXRoLm1heChkYXRlMC52YWx1ZU9mKCksIGRhdGUxLnZhbHVlT2YoKSkpO1xufVxuXG5jbGFzcyBTdGFuZGFyZFRoZW1lIGV4dGVuZHMgVGhlbWUge1xufVxuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuY2xhc3NlcyA9IHtcbiAgICByb290OiAnZmMtdGhlbWUtc3RhbmRhcmQnLFxuICAgIHRhYmxlQ2VsbFNoYWRlZDogJ2ZjLWNlbGwtc2hhZGVkJyxcbiAgICBidXR0b25Hcm91cDogJ2ZjLWJ1dHRvbi1ncm91cCcsXG4gICAgYnV0dG9uOiAnZmMtYnV0dG9uIGZjLWJ1dHRvbi1wcmltYXJ5JyxcbiAgICBidXR0b25BY3RpdmU6ICdmYy1idXR0b24tYWN0aXZlJyxcbn07XG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5iYXNlSWNvbkNsYXNzID0gJ2ZjLWljb24nO1xuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuaWNvbkNsYXNzZXMgPSB7XG4gICAgY2xvc2U6ICdmYy1pY29uLXgnLFxuICAgIHByZXY6ICdmYy1pY29uLWNoZXZyb24tbGVmdCcsXG4gICAgbmV4dDogJ2ZjLWljb24tY2hldnJvbi1yaWdodCcsXG4gICAgcHJldlllYXI6ICdmYy1pY29uLWNoZXZyb25zLWxlZnQnLFxuICAgIG5leHRZZWFyOiAnZmMtaWNvbi1jaGV2cm9ucy1yaWdodCcsXG59O1xuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUucnRsSWNvbkNsYXNzZXMgPSB7XG4gICAgcHJldjogJ2ZjLWljb24tY2hldnJvbi1yaWdodCcsXG4gICAgbmV4dDogJ2ZjLWljb24tY2hldnJvbi1sZWZ0JyxcbiAgICBwcmV2WWVhcjogJ2ZjLWljb24tY2hldnJvbnMtcmlnaHQnLFxuICAgIG5leHRZZWFyOiAnZmMtaWNvbi1jaGV2cm9ucy1sZWZ0Jyxcbn07XG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVPcHRpb24gPSAnYnV0dG9uSWNvbnMnOyAvLyBUT0RPOiBtYWtlIFRTLWZyaWVuZGx5XG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVDdXN0b21CdXR0b25PcHRpb24gPSAnaWNvbic7XG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVQcmVmaXggPSAnZmMtaWNvbi0nO1xuXG5mdW5jdGlvbiBjb21waWxlVmlld0RlZnMoZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncykge1xuICAgIGxldCBoYXNoID0ge307XG4gICAgbGV0IHZpZXdUeXBlO1xuICAgIGZvciAodmlld1R5cGUgaW4gZGVmYXVsdENvbmZpZ3MpIHtcbiAgICAgICAgZW5zdXJlVmlld0RlZih2aWV3VHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncyk7XG4gICAgfVxuICAgIGZvciAodmlld1R5cGUgaW4gb3ZlcnJpZGVDb25maWdzKSB7XG4gICAgICAgIGVuc3VyZVZpZXdEZWYodmlld1R5cGUsIGhhc2gsIGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gaGFzaDtcbn1cbmZ1bmN0aW9uIGVuc3VyZVZpZXdEZWYodmlld1R5cGUsIGhhc2gsIGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpIHtcbiAgICBpZiAoaGFzaFt2aWV3VHlwZV0pIHtcbiAgICAgICAgcmV0dXJuIGhhc2hbdmlld1R5cGVdO1xuICAgIH1cbiAgICBsZXQgdmlld0RlZiA9IGJ1aWxkVmlld0RlZih2aWV3VHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncyk7XG4gICAgaWYgKHZpZXdEZWYpIHtcbiAgICAgICAgaGFzaFt2aWV3VHlwZV0gPSB2aWV3RGVmO1xuICAgIH1cbiAgICByZXR1cm4gdmlld0RlZjtcbn1cbmZ1bmN0aW9uIGJ1aWxkVmlld0RlZih2aWV3VHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncykge1xuICAgIGxldCBkZWZhdWx0Q29uZmlnID0gZGVmYXVsdENvbmZpZ3Nbdmlld1R5cGVdO1xuICAgIGxldCBvdmVycmlkZUNvbmZpZyA9IG92ZXJyaWRlQ29uZmlnc1t2aWV3VHlwZV07XG4gICAgbGV0IHF1ZXJ5UHJvcCA9IChuYW1lKSA9PiAoKGRlZmF1bHRDb25maWcgJiYgZGVmYXVsdENvbmZpZ1tuYW1lXSAhPT0gbnVsbCkgPyBkZWZhdWx0Q29uZmlnW25hbWVdIDpcbiAgICAgICAgKChvdmVycmlkZUNvbmZpZyAmJiBvdmVycmlkZUNvbmZpZ1tuYW1lXSAhPT0gbnVsbCkgPyBvdmVycmlkZUNvbmZpZ1tuYW1lXSA6IG51bGwpKTtcbiAgICBsZXQgdGhlQ29tcG9uZW50ID0gcXVlcnlQcm9wKCdjb21wb25lbnQnKTtcbiAgICBsZXQgc3VwZXJUeXBlID0gcXVlcnlQcm9wKCdzdXBlclR5cGUnKTtcbiAgICBsZXQgc3VwZXJEZWYgPSBudWxsO1xuICAgIGlmIChzdXBlclR5cGUpIHtcbiAgICAgICAgaWYgKHN1cGVyVHlwZSA9PT0gdmlld1R5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBoYXZlIGEgY3VzdG9tIHZpZXcgdHlwZSB0aGF0IHJlZmVyZW5jZXMgaXRzZWxmJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXJEZWYgPSBlbnN1cmVWaWV3RGVmKHN1cGVyVHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncyk7XG4gICAgfVxuICAgIGlmICghdGhlQ29tcG9uZW50ICYmIHN1cGVyRGVmKSB7XG4gICAgICAgIHRoZUNvbXBvbmVudCA9IHN1cGVyRGVmLmNvbXBvbmVudDtcbiAgICB9XG4gICAgaWYgKCF0aGVDb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7IC8vIGRvbid0IHRocm93IGEgd2FybmluZywgbWlnaHQgYmUgc2V0dGluZ3MgZm9yIGEgc2luZ2xlLXVuaXQgdmlld1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiB2aWV3VHlwZSxcbiAgICAgICAgY29tcG9uZW50OiB0aGVDb21wb25lbnQsXG4gICAgICAgIGRlZmF1bHRzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChzdXBlckRlZiA/IHN1cGVyRGVmLmRlZmF1bHRzIDoge30pKSwgKGRlZmF1bHRDb25maWcgPyBkZWZhdWx0Q29uZmlnLnJhd09wdGlvbnMgOiB7fSkpLFxuICAgICAgICBvdmVycmlkZXM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKHN1cGVyRGVmID8gc3VwZXJEZWYub3ZlcnJpZGVzIDoge30pKSwgKG92ZXJyaWRlQ29uZmlnID8gb3ZlcnJpZGVDb25maWcucmF3T3B0aW9ucyA6IHt9KSksXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VWaWV3Q29uZmlncyhpbnB1dHMpIHtcbiAgICByZXR1cm4gbWFwSGFzaChpbnB1dHMsIHBhcnNlVmlld0NvbmZpZyk7XG59XG5mdW5jdGlvbiBwYXJzZVZpZXdDb25maWcoaW5wdXQpIHtcbiAgICBsZXQgcmF3T3B0aW9ucyA9IHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgIHsgY29tcG9uZW50OiBpbnB1dCB9IDpcbiAgICAgICAgaW5wdXQ7XG4gICAgbGV0IHsgY29tcG9uZW50IH0gPSByYXdPcHRpb25zO1xuICAgIGlmIChyYXdPcHRpb25zLmNvbnRlbnQpIHtcbiAgICAgICAgLy8gVE9ETzogcmVtb3ZlIGNvbnRlbnQvY2xhc3NOYW1lcy9kaWRNb3VudC9ldGMgZnJvbSBvcHRpb25zP1xuICAgICAgICBjb21wb25lbnQgPSBjcmVhdGVWaWV3SG9va0NvbXBvbmVudChyYXdPcHRpb25zKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29tcG9uZW50ICYmICEoY29tcG9uZW50LnByb3RvdHlwZSBpbnN0YW5jZW9mIEJhc2VDb21wb25lbnQpKSB7XG4gICAgICAgIC8vIFdIWT86IHBlb3BsZSB3ZXJlIHVzaW5nIGBjb21wb25lbnRgIHByb3BlcnR5IGZvciBgY29udGVudGBcbiAgICAgICAgLy8gVE9ETzogY29udmVyZ2Ugb24gb25lIHNldHRpbmcgbmFtZVxuICAgICAgICBjb21wb25lbnQgPSBjcmVhdGVWaWV3SG9va0NvbXBvbmVudChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJhd09wdGlvbnMpLCB7IGNvbnRlbnQ6IGNvbXBvbmVudCB9KSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHN1cGVyVHlwZTogcmF3T3B0aW9ucy50eXBlLFxuICAgICAgICBjb21wb25lbnQ6IGNvbXBvbmVudCxcbiAgICAgICAgcmF3T3B0aW9ucywgLy8gaW5jbHVkZXMgdHlwZSBhbmQgY29tcG9uZW50IHRvbyA6KFxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVWaWV3SG9va0NvbXBvbmVudChvcHRpb25zKSB7XG4gICAgcmV0dXJuICh2aWV3UHJvcHMpID0+IChjcmVhdGVFbGVtZW50KFZpZXdDb250ZXh0VHlwZS5Db25zdW1lciwgbnVsbCwgKGNvbnRleHQpID0+IChjcmVhdGVFbGVtZW50KENvbnRlbnRDb250YWluZXIsIHsgZWxUYWc6IFwiZGl2XCIsIGVsQ2xhc3NlczogYnVpbGRWaWV3Q2xhc3NOYW1lcyhjb250ZXh0LnZpZXdTcGVjKSwgcmVuZGVyUHJvcHM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdmlld1Byb3BzKSwgeyBuZXh0RGF5VGhyZXNob2xkOiBjb250ZXh0Lm9wdGlvbnMubmV4dERheVRocmVzaG9sZCB9KSwgZ2VuZXJhdG9yTmFtZTogdW5kZWZpbmVkLCBjdXN0b21HZW5lcmF0b3I6IG9wdGlvbnMuY29udGVudCwgY2xhc3NOYW1lR2VuZXJhdG9yOiBvcHRpb25zLmNsYXNzTmFtZXMsIGRpZE1vdW50OiBvcHRpb25zLmRpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy53aWxsVW5tb3VudCB9KSkpKTtcbn1cblxuZnVuY3Rpb24gYnVpbGRWaWV3U3BlY3MoZGVmYXVsdElucHV0cywgb3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBsb2NhbGVEZWZhdWx0cykge1xuICAgIGxldCBkZWZhdWx0Q29uZmlncyA9IHBhcnNlVmlld0NvbmZpZ3MoZGVmYXVsdElucHV0cyk7XG4gICAgbGV0IG92ZXJyaWRlQ29uZmlncyA9IHBhcnNlVmlld0NvbmZpZ3Mob3B0aW9uT3ZlcnJpZGVzLnZpZXdzKTtcbiAgICBsZXQgdmlld0RlZnMgPSBjb21waWxlVmlld0RlZnMoZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncyk7XG4gICAgcmV0dXJuIG1hcEhhc2godmlld0RlZnMsICh2aWV3RGVmKSA9PiBidWlsZFZpZXdTcGVjKHZpZXdEZWYsIG92ZXJyaWRlQ29uZmlncywgb3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBsb2NhbGVEZWZhdWx0cykpO1xufVxuZnVuY3Rpb24gYnVpbGRWaWV3U3BlYyh2aWV3RGVmLCBvdmVycmlkZUNvbmZpZ3MsIG9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcywgbG9jYWxlRGVmYXVsdHMpIHtcbiAgICBsZXQgZHVyYXRpb25JbnB1dCA9IHZpZXdEZWYub3ZlcnJpZGVzLmR1cmF0aW9uIHx8XG4gICAgICAgIHZpZXdEZWYuZGVmYXVsdHMuZHVyYXRpb24gfHxcbiAgICAgICAgZHluYW1pY09wdGlvbk92ZXJyaWRlcy5kdXJhdGlvbiB8fFxuICAgICAgICBvcHRpb25PdmVycmlkZXMuZHVyYXRpb247XG4gICAgbGV0IGR1cmF0aW9uID0gbnVsbDtcbiAgICBsZXQgZHVyYXRpb25Vbml0ID0gJyc7XG4gICAgbGV0IHNpbmdsZVVuaXQgPSAnJztcbiAgICBsZXQgc2luZ2xlVW5pdE92ZXJyaWRlcyA9IHt9O1xuICAgIGlmIChkdXJhdGlvbklucHV0KSB7XG4gICAgICAgIGR1cmF0aW9uID0gY3JlYXRlRHVyYXRpb25DYWNoZWQoZHVyYXRpb25JbnB1dCk7XG4gICAgICAgIGlmIChkdXJhdGlvbikgeyAvLyB2YWxpZD9cbiAgICAgICAgICAgIGxldCBkZW5vbSA9IGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvcihkdXJhdGlvbik7XG4gICAgICAgICAgICBkdXJhdGlvblVuaXQgPSBkZW5vbS51bml0O1xuICAgICAgICAgICAgaWYgKGRlbm9tLnZhbHVlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgc2luZ2xlVW5pdCA9IGR1cmF0aW9uVW5pdDtcbiAgICAgICAgICAgICAgICBzaW5nbGVVbml0T3ZlcnJpZGVzID0gb3ZlcnJpZGVDb25maWdzW2R1cmF0aW9uVW5pdF0gPyBvdmVycmlkZUNvbmZpZ3NbZHVyYXRpb25Vbml0XS5yYXdPcHRpb25zIDoge307XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHF1ZXJ5QnV0dG9uVGV4dCA9IChvcHRpb25zU3Vic2V0KSA9PiB7XG4gICAgICAgIGxldCBidXR0b25UZXh0TWFwID0gb3B0aW9uc1N1YnNldC5idXR0b25UZXh0IHx8IHt9O1xuICAgICAgICBsZXQgYnV0dG9uVGV4dEtleSA9IHZpZXdEZWYuZGVmYXVsdHMuYnV0dG9uVGV4dEtleTtcbiAgICAgICAgaWYgKGJ1dHRvblRleHRLZXkgIT0gbnVsbCAmJiBidXR0b25UZXh0TWFwW2J1dHRvblRleHRLZXldICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBidXR0b25UZXh0TWFwW2J1dHRvblRleHRLZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidXR0b25UZXh0TWFwW3ZpZXdEZWYudHlwZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1dHRvblRleHRNYXBbdmlld0RlZi50eXBlXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnV0dG9uVGV4dE1hcFtzaW5nbGVVbml0XSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYnV0dG9uVGV4dE1hcFtzaW5nbGVVbml0XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIGxldCBxdWVyeUJ1dHRvblRpdGxlID0gKG9wdGlvbnNTdWJzZXQpID0+IHtcbiAgICAgICAgbGV0IGJ1dHRvbkhpbnRzID0gb3B0aW9uc1N1YnNldC5idXR0b25IaW50cyB8fCB7fTtcbiAgICAgICAgbGV0IGJ1dHRvbktleSA9IHZpZXdEZWYuZGVmYXVsdHMuYnV0dG9uVGV4dEtleTsgLy8gdXNlIHNhbWUga2V5IGFzIHRleHRcbiAgICAgICAgaWYgKGJ1dHRvbktleSAhPSBudWxsICYmIGJ1dHRvbkhpbnRzW2J1dHRvbktleV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1dHRvbkhpbnRzW2J1dHRvbktleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1dHRvbkhpbnRzW3ZpZXdEZWYudHlwZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1dHRvbkhpbnRzW3ZpZXdEZWYudHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1dHRvbkhpbnRzW3NpbmdsZVVuaXRdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBidXR0b25IaW50c1tzaW5nbGVVbml0XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHZpZXdEZWYudHlwZSxcbiAgICAgICAgY29tcG9uZW50OiB2aWV3RGVmLmNvbXBvbmVudCxcbiAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIGR1cmF0aW9uVW5pdCxcbiAgICAgICAgc2luZ2xlVW5pdCxcbiAgICAgICAgb3B0aW9uRGVmYXVsdHM6IHZpZXdEZWYuZGVmYXVsdHMsXG4gICAgICAgIG9wdGlvbk92ZXJyaWRlczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzaW5nbGVVbml0T3ZlcnJpZGVzKSwgdmlld0RlZi5vdmVycmlkZXMpLFxuICAgICAgICBidXR0b25UZXh0T3ZlcnJpZGU6IHF1ZXJ5QnV0dG9uVGV4dChkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKSB8fFxuICAgICAgICAgICAgcXVlcnlCdXR0b25UZXh0KG9wdGlvbk92ZXJyaWRlcykgfHwgLy8gY29uc3RydWN0b3Itc3BlY2lmaWVkIGJ1dHRvblRleHQgbG9va3VwIGhhc2ggdGFrZXMgcHJlY2VkZW5jZVxuICAgICAgICAgICAgdmlld0RlZi5vdmVycmlkZXMuYnV0dG9uVGV4dCxcbiAgICAgICAgYnV0dG9uVGV4dERlZmF1bHQ6IHF1ZXJ5QnV0dG9uVGV4dChsb2NhbGVEZWZhdWx0cykgfHxcbiAgICAgICAgICAgIHZpZXdEZWYuZGVmYXVsdHMuYnV0dG9uVGV4dCB8fFxuICAgICAgICAgICAgcXVlcnlCdXR0b25UZXh0KEJBU0VfT1BUSU9OX0RFRkFVTFRTKSB8fFxuICAgICAgICAgICAgdmlld0RlZi50eXBlLFxuICAgICAgICAvLyBub3QgRFJZXG4gICAgICAgIGJ1dHRvblRpdGxlT3ZlcnJpZGU6IHF1ZXJ5QnV0dG9uVGl0bGUoZHluYW1pY09wdGlvbk92ZXJyaWRlcykgfHxcbiAgICAgICAgICAgIHF1ZXJ5QnV0dG9uVGl0bGUob3B0aW9uT3ZlcnJpZGVzKSB8fFxuICAgICAgICAgICAgdmlld0RlZi5vdmVycmlkZXMuYnV0dG9uSGludCxcbiAgICAgICAgYnV0dG9uVGl0bGVEZWZhdWx0OiBxdWVyeUJ1dHRvblRpdGxlKGxvY2FsZURlZmF1bHRzKSB8fFxuICAgICAgICAgICAgdmlld0RlZi5kZWZhdWx0cy5idXR0b25IaW50IHx8XG4gICAgICAgICAgICBxdWVyeUJ1dHRvblRpdGxlKEJBU0VfT1BUSU9OX0RFRkFVTFRTKSxcbiAgICAgICAgLy8gd2lsbCBldmVudHVhbGx5IGZhbGwgYmFjayB0byBidXR0b25UZXh0XG4gICAgfTtcbn1cbi8vIGhhY2sgdG8gZ2V0IG1lbW9pemF0aW9uIHdvcmtpbmdcbmxldCBkdXJhdGlvbklucHV0TWFwID0ge307XG5mdW5jdGlvbiBjcmVhdGVEdXJhdGlvbkNhY2hlZChkdXJhdGlvbklucHV0KSB7XG4gICAgbGV0IGpzb24gPSBKU09OLnN0cmluZ2lmeShkdXJhdGlvbklucHV0KTtcbiAgICBsZXQgcmVzID0gZHVyYXRpb25JbnB1dE1hcFtqc29uXTtcbiAgICBpZiAocmVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzID0gY3JlYXRlRHVyYXRpb24oZHVyYXRpb25JbnB1dCk7XG4gICAgICAgIGR1cmF0aW9uSW5wdXRNYXBbanNvbl0gPSByZXM7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIHJlZHVjZVZpZXdUeXBlKHZpZXdUeXBlLCBhY3Rpb24pIHtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ0NIQU5HRV9WSUVXX1RZUEUnOlxuICAgICAgICAgICAgdmlld1R5cGUgPSBhY3Rpb24udmlld1R5cGU7XG4gICAgfVxuICAgIHJldHVybiB2aWV3VHlwZTtcbn1cblxuZnVuY3Rpb24gcmVkdWNlRHluYW1pY09wdGlvbk92ZXJyaWRlcyhkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBhY3Rpb24pIHtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ1NFVF9PUFRJT04nOlxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZHluYW1pY09wdGlvbk92ZXJyaWRlcyksIHsgW2FjdGlvbi5vcHRpb25OYW1lXTogYWN0aW9uLnJhd09wdGlvblZhbHVlIH0pO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGR5bmFtaWNPcHRpb25PdmVycmlkZXM7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWR1Y2VEYXRlUHJvZmlsZShjdXJyZW50RGF0ZVByb2ZpbGUsIGFjdGlvbiwgY3VycmVudERhdGUsIGRhdGVQcm9maWxlR2VuZXJhdG9yKSB7XG4gICAgbGV0IGRwO1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnQ0hBTkdFX1ZJRVdfVFlQRSc6XG4gICAgICAgICAgICByZXR1cm4gZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGQoYWN0aW9uLmRhdGVNYXJrZXIgfHwgY3VycmVudERhdGUpO1xuICAgICAgICBjYXNlICdDSEFOR0VfREFURSc6XG4gICAgICAgICAgICByZXR1cm4gZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGQoYWN0aW9uLmRhdGVNYXJrZXIpO1xuICAgICAgICBjYXNlICdQUkVWJzpcbiAgICAgICAgICAgIGRwID0gZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGRQcmV2KGN1cnJlbnREYXRlUHJvZmlsZSwgY3VycmVudERhdGUpO1xuICAgICAgICAgICAgaWYgKGRwLmlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZHA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnTkVYVCc6XG4gICAgICAgICAgICBkcCA9IGRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkTmV4dChjdXJyZW50RGF0ZVByb2ZpbGUsIGN1cnJlbnREYXRlKTtcbiAgICAgICAgICAgIGlmIChkcC5pc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50RGF0ZVByb2ZpbGU7XG59XG5cbmZ1bmN0aW9uIGluaXRFdmVudFNvdXJjZXMoY2FsZW5kYXJPcHRpb25zLCBkYXRlUHJvZmlsZSwgY29udGV4dCkge1xuICAgIGxldCBhY3RpdmVSYW5nZSA9IGRhdGVQcm9maWxlID8gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UgOiBudWxsO1xuICAgIHJldHVybiBhZGRTb3VyY2VzKHt9LCBwYXJzZUluaXRpYWxTb3VyY2VzKGNhbGVuZGFyT3B0aW9ucywgY29udGV4dCksIGFjdGl2ZVJhbmdlLCBjb250ZXh0KTtcbn1cbmZ1bmN0aW9uIHJlZHVjZUV2ZW50U291cmNlcyhldmVudFNvdXJjZXMsIGFjdGlvbiwgZGF0ZVByb2ZpbGUsIGNvbnRleHQpIHtcbiAgICBsZXQgYWN0aXZlUmFuZ2UgPSBkYXRlUHJvZmlsZSA/IGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlIDogbnVsbDsgLy8gbmVlZCB0aGlzIGNoZWNrP1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnQUREX0VWRU5UX1NPVVJDRVMnOiAvLyBhbHJlYWR5IHBhcnNlZFxuICAgICAgICAgICAgcmV0dXJuIGFkZFNvdXJjZXMoZXZlbnRTb3VyY2VzLCBhY3Rpb24uc291cmNlcywgYWN0aXZlUmFuZ2UsIGNvbnRleHQpO1xuICAgICAgICBjYXNlICdSRU1PVkVfRVZFTlRfU09VUkNFJzpcbiAgICAgICAgICAgIHJldHVybiByZW1vdmVTb3VyY2UoZXZlbnRTb3VyY2VzLCBhY3Rpb24uc291cmNlSWQpO1xuICAgICAgICBjYXNlICdQUkVWJzogLy8gVE9ETzogaG93IGRvIHdlIHRyYWNrIGFsbCBhY3Rpb25zIHRoYXQgYWZmZWN0IGRhdGVQcm9maWxlIDooXG4gICAgICAgIGNhc2UgJ05FWFQnOlxuICAgICAgICBjYXNlICdDSEFOR0VfREFURSc6XG4gICAgICAgIGNhc2UgJ0NIQU5HRV9WSUVXX1RZUEUnOlxuICAgICAgICAgICAgaWYgKGRhdGVQcm9maWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZldGNoRGlydHlTb3VyY2VzKGV2ZW50U291cmNlcywgYWN0aXZlUmFuZ2UsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50U291cmNlcztcbiAgICAgICAgY2FzZSAnRkVUQ0hfRVZFTlRfU09VUkNFUyc6XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2hTb3VyY2VzQnlJZHMoZXZlbnRTb3VyY2VzLCBhY3Rpb24uc291cmNlSWRzID8gLy8gd2h5IG5vIHR5cGU/XG4gICAgICAgICAgICAgICAgYXJyYXlUb0hhc2goYWN0aW9uLnNvdXJjZUlkcykgOlxuICAgICAgICAgICAgICAgIGV4Y2x1ZGVTdGF0aWNTb3VyY2VzKGV2ZW50U291cmNlcywgY29udGV4dCksIGFjdGl2ZVJhbmdlLCBhY3Rpb24uaXNSZWZldGNoIHx8IGZhbHNlLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSAnUkVDRUlWRV9FVkVOVFMnOlxuICAgICAgICBjYXNlICdSRUNFSVZFX0VWRU5UX0VSUk9SJzpcbiAgICAgICAgICAgIHJldHVybiByZWNlaXZlUmVzcG9uc2UoZXZlbnRTb3VyY2VzLCBhY3Rpb24uc291cmNlSWQsIGFjdGlvbi5mZXRjaElkLCBhY3Rpb24uZmV0Y2hSYW5nZSk7XG4gICAgICAgIGNhc2UgJ1JFTU9WRV9BTExfRVZFTlRfU09VUkNFUyc6XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRTb3VyY2VzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlZHVjZUV2ZW50U291cmNlc05ld1RpbWVab25lKGV2ZW50U291cmNlcywgZGF0ZVByb2ZpbGUsIGNvbnRleHQpIHtcbiAgICBsZXQgYWN0aXZlUmFuZ2UgPSBkYXRlUHJvZmlsZSA/IGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlIDogbnVsbDsgLy8gbmVlZCB0aGlzIGNoZWNrP1xuICAgIHJldHVybiBmZXRjaFNvdXJjZXNCeUlkcyhldmVudFNvdXJjZXMsIGV4Y2x1ZGVTdGF0aWNTb3VyY2VzKGV2ZW50U291cmNlcywgY29udGV4dCksIGFjdGl2ZVJhbmdlLCB0cnVlLCBjb250ZXh0KTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVFdmVudFNvdXJjZXNMb2FkaW5nKGV2ZW50U291cmNlcykge1xuICAgIGZvciAobGV0IHNvdXJjZUlkIGluIGV2ZW50U291cmNlcykge1xuICAgICAgICBpZiAoZXZlbnRTb3VyY2VzW3NvdXJjZUlkXS5pc0ZldGNoaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBhZGRTb3VyY2VzKGV2ZW50U291cmNlSGFzaCwgc291cmNlcywgZmV0Y2hSYW5nZSwgY29udGV4dCkge1xuICAgIGxldCBoYXNoID0ge307XG4gICAgZm9yIChsZXQgc291cmNlIG9mIHNvdXJjZXMpIHtcbiAgICAgICAgaGFzaFtzb3VyY2Uuc291cmNlSWRdID0gc291cmNlO1xuICAgIH1cbiAgICBpZiAoZmV0Y2hSYW5nZSkge1xuICAgICAgICBoYXNoID0gZmV0Y2hEaXJ0eVNvdXJjZXMoaGFzaCwgZmV0Y2hSYW5nZSwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV2ZW50U291cmNlSGFzaCksIGhhc2gpO1xufVxuZnVuY3Rpb24gcmVtb3ZlU291cmNlKGV2ZW50U291cmNlSGFzaCwgc291cmNlSWQpIHtcbiAgICByZXR1cm4gZmlsdGVySGFzaChldmVudFNvdXJjZUhhc2gsIChldmVudFNvdXJjZSkgPT4gZXZlbnRTb3VyY2Uuc291cmNlSWQgIT09IHNvdXJjZUlkKTtcbn1cbmZ1bmN0aW9uIGZldGNoRGlydHlTb3VyY2VzKHNvdXJjZUhhc2gsIGZldGNoUmFuZ2UsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gZmV0Y2hTb3VyY2VzQnlJZHMoc291cmNlSGFzaCwgZmlsdGVySGFzaChzb3VyY2VIYXNoLCAoZXZlbnRTb3VyY2UpID0+IGlzU291cmNlRGlydHkoZXZlbnRTb3VyY2UsIGZldGNoUmFuZ2UsIGNvbnRleHQpKSwgZmV0Y2hSYW5nZSwgZmFsc2UsIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gaXNTb3VyY2VEaXJ0eShldmVudFNvdXJjZSwgZmV0Y2hSYW5nZSwgY29udGV4dCkge1xuICAgIGlmICghZG9lc1NvdXJjZU5lZWRSYW5nZShldmVudFNvdXJjZSwgY29udGV4dCkpIHtcbiAgICAgICAgcmV0dXJuICFldmVudFNvdXJjZS5sYXRlc3RGZXRjaElkO1xuICAgIH1cbiAgICByZXR1cm4gIWNvbnRleHQub3B0aW9ucy5sYXp5RmV0Y2hpbmcgfHxcbiAgICAgICAgIWV2ZW50U291cmNlLmZldGNoUmFuZ2UgfHxcbiAgICAgICAgZXZlbnRTb3VyY2UuaXNGZXRjaGluZyB8fCAvLyBhbHdheXMgY2FuY2VsIG91dGRhdGVkIGluLXByb2dyZXNzIGZldGNoZXNcbiAgICAgICAgZmV0Y2hSYW5nZS5zdGFydCA8IGV2ZW50U291cmNlLmZldGNoUmFuZ2Uuc3RhcnQgfHxcbiAgICAgICAgZmV0Y2hSYW5nZS5lbmQgPiBldmVudFNvdXJjZS5mZXRjaFJhbmdlLmVuZDtcbn1cbmZ1bmN0aW9uIGZldGNoU291cmNlc0J5SWRzKHByZXZTb3VyY2VzLCBzb3VyY2VJZEhhc2gsIGZldGNoUmFuZ2UsIGlzUmVmZXRjaCwgY29udGV4dCkge1xuICAgIGxldCBuZXh0U291cmNlcyA9IHt9O1xuICAgIGZvciAobGV0IHNvdXJjZUlkIGluIHByZXZTb3VyY2VzKSB7XG4gICAgICAgIGxldCBzb3VyY2UgPSBwcmV2U291cmNlc1tzb3VyY2VJZF07XG4gICAgICAgIGlmIChzb3VyY2VJZEhhc2hbc291cmNlSWRdKSB7XG4gICAgICAgICAgICBuZXh0U291cmNlc1tzb3VyY2VJZF0gPSBmZXRjaFNvdXJjZShzb3VyY2UsIGZldGNoUmFuZ2UsIGlzUmVmZXRjaCwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXh0U291cmNlc1tzb3VyY2VJZF0gPSBzb3VyY2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5leHRTb3VyY2VzO1xufVxuZnVuY3Rpb24gZmV0Y2hTb3VyY2UoZXZlbnRTb3VyY2UsIGZldGNoUmFuZ2UsIGlzUmVmZXRjaCwgY29udGV4dCkge1xuICAgIGxldCB7IG9wdGlvbnMsIGNhbGVuZGFyQXBpIH0gPSBjb250ZXh0O1xuICAgIGxldCBzb3VyY2VEZWYgPSBjb250ZXh0LnBsdWdpbkhvb2tzLmV2ZW50U291cmNlRGVmc1tldmVudFNvdXJjZS5zb3VyY2VEZWZJZF07XG4gICAgbGV0IGZldGNoSWQgPSBndWlkKCk7XG4gICAgc291cmNlRGVmLmZldGNoKHtcbiAgICAgICAgZXZlbnRTb3VyY2UsXG4gICAgICAgIHJhbmdlOiBmZXRjaFJhbmdlLFxuICAgICAgICBpc1JlZmV0Y2gsXG4gICAgICAgIGNvbnRleHQsXG4gICAgfSwgKHJlcykgPT4ge1xuICAgICAgICBsZXQgeyByYXdFdmVudHMgfSA9IHJlcztcbiAgICAgICAgaWYgKG9wdGlvbnMuZXZlbnRTb3VyY2VTdWNjZXNzKSB7XG4gICAgICAgICAgICByYXdFdmVudHMgPSBvcHRpb25zLmV2ZW50U291cmNlU3VjY2Vzcy5jYWxsKGNhbGVuZGFyQXBpLCByYXdFdmVudHMsIHJlcy5yZXNwb25zZSkgfHwgcmF3RXZlbnRzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudFNvdXJjZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICByYXdFdmVudHMgPSBldmVudFNvdXJjZS5zdWNjZXNzLmNhbGwoY2FsZW5kYXJBcGksIHJhd0V2ZW50cywgcmVzLnJlc3BvbnNlKSB8fCByYXdFdmVudHM7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnUkVDRUlWRV9FVkVOVFMnLFxuICAgICAgICAgICAgc291cmNlSWQ6IGV2ZW50U291cmNlLnNvdXJjZUlkLFxuICAgICAgICAgICAgZmV0Y2hJZCxcbiAgICAgICAgICAgIGZldGNoUmFuZ2UsXG4gICAgICAgICAgICByYXdFdmVudHMsXG4gICAgICAgIH0pO1xuICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICBsZXQgZXJyb3JIYW5kbGVkID0gZmFsc2U7XG4gICAgICAgIGlmIChvcHRpb25zLmV2ZW50U291cmNlRmFpbHVyZSkge1xuICAgICAgICAgICAgb3B0aW9ucy5ldmVudFNvdXJjZUZhaWx1cmUuY2FsbChjYWxlbmRhckFwaSwgZXJyb3IpO1xuICAgICAgICAgICAgZXJyb3JIYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnRTb3VyY2UuZmFpbHVyZSkge1xuICAgICAgICAgICAgZXZlbnRTb3VyY2UuZmFpbHVyZShlcnJvcik7XG4gICAgICAgICAgICBlcnJvckhhbmRsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZXJyb3JIYW5kbGVkKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oZXJyb3IubWVzc2FnZSwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ1JFQ0VJVkVfRVZFTlRfRVJST1InLFxuICAgICAgICAgICAgc291cmNlSWQ6IGV2ZW50U291cmNlLnNvdXJjZUlkLFxuICAgICAgICAgICAgZmV0Y2hJZCxcbiAgICAgICAgICAgIGZldGNoUmFuZ2UsXG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRTb3VyY2UpLCB7IGlzRmV0Y2hpbmc6IHRydWUsIGxhdGVzdEZldGNoSWQ6IGZldGNoSWQgfSk7XG59XG5mdW5jdGlvbiByZWNlaXZlUmVzcG9uc2Uoc291cmNlSGFzaCwgc291cmNlSWQsIGZldGNoSWQsIGZldGNoUmFuZ2UpIHtcbiAgICBsZXQgZXZlbnRTb3VyY2UgPSBzb3VyY2VIYXNoW3NvdXJjZUlkXTtcbiAgICBpZiAoZXZlbnRTb3VyY2UgJiYgLy8gbm90IGFscmVhZHkgcmVtb3ZlZFxuICAgICAgICBmZXRjaElkID09PSBldmVudFNvdXJjZS5sYXRlc3RGZXRjaElkKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNvdXJjZUhhc2gpLCB7IFtzb3VyY2VJZF06IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRTb3VyY2UpLCB7IGlzRmV0Y2hpbmc6IGZhbHNlLCBmZXRjaFJhbmdlIH0pIH0pO1xuICAgIH1cbiAgICByZXR1cm4gc291cmNlSGFzaDtcbn1cbmZ1bmN0aW9uIGV4Y2x1ZGVTdGF0aWNTb3VyY2VzKGV2ZW50U291cmNlcywgY29udGV4dCkge1xuICAgIHJldHVybiBmaWx0ZXJIYXNoKGV2ZW50U291cmNlcywgKGV2ZW50U291cmNlKSA9PiBkb2VzU291cmNlTmVlZFJhbmdlKGV2ZW50U291cmNlLCBjb250ZXh0KSk7XG59XG5mdW5jdGlvbiBwYXJzZUluaXRpYWxTb3VyY2VzKHJhd09wdGlvbnMsIGNvbnRleHQpIHtcbiAgICBsZXQgcmVmaW5lcnMgPSBidWlsZEV2ZW50U291cmNlUmVmaW5lcnMoY29udGV4dCk7XG4gICAgbGV0IHJhd1NvdXJjZXMgPSBbXS5jb25jYXQocmF3T3B0aW9ucy5ldmVudFNvdXJjZXMgfHwgW10pO1xuICAgIGxldCBzb3VyY2VzID0gW107IC8vIHBhcnNlZFxuICAgIGlmIChyYXdPcHRpb25zLmluaXRpYWxFdmVudHMpIHtcbiAgICAgICAgcmF3U291cmNlcy51bnNoaWZ0KHJhd09wdGlvbnMuaW5pdGlhbEV2ZW50cyk7XG4gICAgfVxuICAgIGlmIChyYXdPcHRpb25zLmV2ZW50cykge1xuICAgICAgICByYXdTb3VyY2VzLnVuc2hpZnQocmF3T3B0aW9ucy5ldmVudHMpO1xuICAgIH1cbiAgICBmb3IgKGxldCByYXdTb3VyY2Ugb2YgcmF3U291cmNlcykge1xuICAgICAgICBsZXQgc291cmNlID0gcGFyc2VFdmVudFNvdXJjZShyYXdTb3VyY2UsIGNvbnRleHQsIHJlZmluZXJzKTtcbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgc291cmNlcy5wdXNoKHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZXM7XG59XG5mdW5jdGlvbiBkb2VzU291cmNlTmVlZFJhbmdlKGV2ZW50U291cmNlLCBjb250ZXh0KSB7XG4gICAgbGV0IGRlZnMgPSBjb250ZXh0LnBsdWdpbkhvb2tzLmV2ZW50U291cmNlRGVmcztcbiAgICByZXR1cm4gIWRlZnNbZXZlbnRTb3VyY2Uuc291cmNlRGVmSWRdLmlnbm9yZVJhbmdlO1xufVxuXG5mdW5jdGlvbiByZWR1Y2VEYXRlU2VsZWN0aW9uKGN1cnJlbnRTZWxlY3Rpb24sIGFjdGlvbikge1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnVU5TRUxFQ1RfREFURVMnOlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgJ1NFTEVDVF9EQVRFUyc6XG4gICAgICAgICAgICByZXR1cm4gYWN0aW9uLnNlbGVjdGlvbjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50U2VsZWN0aW9uO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVkdWNlU2VsZWN0ZWRFdmVudChjdXJyZW50SW5zdGFuY2VJZCwgYWN0aW9uKSB7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdVTlNFTEVDVF9FVkVOVCc6XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIGNhc2UgJ1NFTEVDVF9FVkVOVCc6XG4gICAgICAgICAgICByZXR1cm4gYWN0aW9uLmV2ZW50SW5zdGFuY2VJZDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50SW5zdGFuY2VJZDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlZHVjZUV2ZW50RHJhZyhjdXJyZW50RHJhZywgYWN0aW9uKSB7XG4gICAgbGV0IG5ld0RyYWc7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdVTlNFVF9FVkVOVF9EUkFHJzpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlICdTRVRfRVZFTlRfRFJBRyc6XG4gICAgICAgICAgICBuZXdEcmFnID0gYWN0aW9uLnN0YXRlO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhZmZlY3RlZEV2ZW50czogbmV3RHJhZy5hZmZlY3RlZEV2ZW50cyxcbiAgICAgICAgICAgICAgICBtdXRhdGVkRXZlbnRzOiBuZXdEcmFnLm11dGF0ZWRFdmVudHMsXG4gICAgICAgICAgICAgICAgaXNFdmVudDogbmV3RHJhZy5pc0V2ZW50LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50RHJhZztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlZHVjZUV2ZW50UmVzaXplKGN1cnJlbnRSZXNpemUsIGFjdGlvbikge1xuICAgIGxldCBuZXdSZXNpemU7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdVTlNFVF9FVkVOVF9SRVNJWkUnOlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgJ1NFVF9FVkVOVF9SRVNJWkUnOlxuICAgICAgICAgICAgbmV3UmVzaXplID0gYWN0aW9uLnN0YXRlO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhZmZlY3RlZEV2ZW50czogbmV3UmVzaXplLmFmZmVjdGVkRXZlbnRzLFxuICAgICAgICAgICAgICAgIG11dGF0ZWRFdmVudHM6IG5ld1Jlc2l6ZS5tdXRhdGVkRXZlbnRzLFxuICAgICAgICAgICAgICAgIGlzRXZlbnQ6IG5ld1Jlc2l6ZS5pc0V2ZW50LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50UmVzaXplO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VUb29sYmFycyhjYWxlbmRhck9wdGlvbnMsIGNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzLCB0aGVtZSwgdmlld1NwZWNzLCBjYWxlbmRhckFwaSkge1xuICAgIGxldCBoZWFkZXIgPSBjYWxlbmRhck9wdGlvbnMuaGVhZGVyVG9vbGJhciA/IHBhcnNlVG9vbGJhcihjYWxlbmRhck9wdGlvbnMuaGVhZGVyVG9vbGJhciwgY2FsZW5kYXJPcHRpb25zLCBjYWxlbmRhck9wdGlvbk92ZXJyaWRlcywgdGhlbWUsIHZpZXdTcGVjcywgY2FsZW5kYXJBcGkpIDogbnVsbDtcbiAgICBsZXQgZm9vdGVyID0gY2FsZW5kYXJPcHRpb25zLmZvb3RlclRvb2xiYXIgPyBwYXJzZVRvb2xiYXIoY2FsZW5kYXJPcHRpb25zLmZvb3RlclRvb2xiYXIsIGNhbGVuZGFyT3B0aW9ucywgY2FsZW5kYXJPcHRpb25PdmVycmlkZXMsIHRoZW1lLCB2aWV3U3BlY3MsIGNhbGVuZGFyQXBpKSA6IG51bGw7XG4gICAgcmV0dXJuIHsgaGVhZGVyLCBmb290ZXIgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlVG9vbGJhcihzZWN0aW9uU3RySGFzaCwgY2FsZW5kYXJPcHRpb25zLCBjYWxlbmRhck9wdGlvbk92ZXJyaWRlcywgdGhlbWUsIHZpZXdTcGVjcywgY2FsZW5kYXJBcGkpIHtcbiAgICBsZXQgc2VjdGlvbldpZGdldHMgPSB7fTtcbiAgICBsZXQgdmlld3NXaXRoQnV0dG9ucyA9IFtdO1xuICAgIGxldCBoYXNUaXRsZSA9IGZhbHNlO1xuICAgIGZvciAobGV0IHNlY3Rpb25OYW1lIGluIHNlY3Rpb25TdHJIYXNoKSB7XG4gICAgICAgIGxldCBzZWN0aW9uU3RyID0gc2VjdGlvblN0ckhhc2hbc2VjdGlvbk5hbWVdO1xuICAgICAgICBsZXQgc2VjdGlvblJlcyA9IHBhcnNlU2VjdGlvbihzZWN0aW9uU3RyLCBjYWxlbmRhck9wdGlvbnMsIGNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzLCB0aGVtZSwgdmlld1NwZWNzLCBjYWxlbmRhckFwaSk7XG4gICAgICAgIHNlY3Rpb25XaWRnZXRzW3NlY3Rpb25OYW1lXSA9IHNlY3Rpb25SZXMud2lkZ2V0cztcbiAgICAgICAgdmlld3NXaXRoQnV0dG9ucy5wdXNoKC4uLnNlY3Rpb25SZXMudmlld3NXaXRoQnV0dG9ucyk7XG4gICAgICAgIGhhc1RpdGxlID0gaGFzVGl0bGUgfHwgc2VjdGlvblJlcy5oYXNUaXRsZTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc2VjdGlvbldpZGdldHMsIHZpZXdzV2l0aEJ1dHRvbnMsIGhhc1RpdGxlIH07XG59XG4vKlxuQkFEOiBxdWVyeWluZyBpY29ucyBhbmQgdGV4dCBoZXJlLiBzaG91bGQgYmUgZG9uZSBhdCByZW5kZXIgdGltZVxuKi9cbmZ1bmN0aW9uIHBhcnNlU2VjdGlvbihzZWN0aW9uU3RyLCBjYWxlbmRhck9wdGlvbnMsIC8vIGRlZmF1bHRzK292ZXJyaWRlcywgdGhlbiByZWZpbmVkXG5jYWxlbmRhck9wdGlvbk92ZXJyaWRlcywgLy8gb3ZlcnJpZGVzIG9ubHkhLCB1bnJlZmluZWQgOihcbnRoZW1lLCB2aWV3U3BlY3MsIGNhbGVuZGFyQXBpKSB7XG4gICAgbGV0IGlzUnRsID0gY2FsZW5kYXJPcHRpb25zLmRpcmVjdGlvbiA9PT0gJ3J0bCc7XG4gICAgbGV0IGNhbGVuZGFyQ3VzdG9tQnV0dG9ucyA9IGNhbGVuZGFyT3B0aW9ucy5jdXN0b21CdXR0b25zIHx8IHt9O1xuICAgIGxldCBjYWxlbmRhckJ1dHRvblRleHRPdmVycmlkZXMgPSBjYWxlbmRhck9wdGlvbk92ZXJyaWRlcy5idXR0b25UZXh0IHx8IHt9O1xuICAgIGxldCBjYWxlbmRhckJ1dHRvblRleHQgPSBjYWxlbmRhck9wdGlvbnMuYnV0dG9uVGV4dCB8fCB7fTtcbiAgICBsZXQgY2FsZW5kYXJCdXR0b25IaW50T3ZlcnJpZGVzID0gY2FsZW5kYXJPcHRpb25PdmVycmlkZXMuYnV0dG9uSGludHMgfHwge307XG4gICAgbGV0IGNhbGVuZGFyQnV0dG9uSGludHMgPSBjYWxlbmRhck9wdGlvbnMuYnV0dG9uSGludHMgfHwge307XG4gICAgbGV0IHNlY3Rpb25TdWJzdHJzID0gc2VjdGlvblN0ciA/IHNlY3Rpb25TdHIuc3BsaXQoJyAnKSA6IFtdO1xuICAgIGxldCB2aWV3c1dpdGhCdXR0b25zID0gW107XG4gICAgbGV0IGhhc1RpdGxlID0gZmFsc2U7XG4gICAgbGV0IHdpZGdldHMgPSBzZWN0aW9uU3Vic3Rycy5tYXAoKGJ1dHRvbkdyb3VwU3RyKSA9PiAoYnV0dG9uR3JvdXBTdHIuc3BsaXQoJywnKS5tYXAoKGJ1dHRvbk5hbWUpID0+IHtcbiAgICAgICAgaWYgKGJ1dHRvbk5hbWUgPT09ICd0aXRsZScpIHtcbiAgICAgICAgICAgIGhhc1RpdGxlID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB7IGJ1dHRvbk5hbWUgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3VzdG9tQnV0dG9uUHJvcHM7XG4gICAgICAgIGxldCB2aWV3U3BlYztcbiAgICAgICAgbGV0IGJ1dHRvbkNsaWNrO1xuICAgICAgICBsZXQgYnV0dG9uSWNvbjsgLy8gb25seSBvbmUgb2YgdGhlc2Ugd2lsbCBiZSBzZXRcbiAgICAgICAgbGV0IGJ1dHRvblRleHQ7IC8vIFwiXG4gICAgICAgIGxldCBidXR0b25IaW50O1xuICAgICAgICAvLyBeIGZvciB0aGUgdGl0bGU9XCJcIiBhdHRyaWJ1dGUsIGZvciBhY2Nlc3NpYmlsaXR5XG4gICAgICAgIGlmICgoY3VzdG9tQnV0dG9uUHJvcHMgPSBjYWxlbmRhckN1c3RvbUJ1dHRvbnNbYnV0dG9uTmFtZV0pKSB7XG4gICAgICAgICAgICBidXR0b25DbGljayA9IChldikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjdXN0b21CdXR0b25Qcm9wcy5jbGljaykge1xuICAgICAgICAgICAgICAgICAgICBjdXN0b21CdXR0b25Qcm9wcy5jbGljay5jYWxsKGV2LnRhcmdldCwgZXYsIGV2LnRhcmdldCk7IC8vIFRPRE86IHVzZSBDYWxlbmRhciB0aGlzIGNvbnRleHQ/XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIChidXR0b25JY29uID0gdGhlbWUuZ2V0Q3VzdG9tQnV0dG9uSWNvbkNsYXNzKGN1c3RvbUJ1dHRvblByb3BzKSkgfHxcbiAgICAgICAgICAgICAgICAoYnV0dG9uSWNvbiA9IHRoZW1lLmdldEljb25DbGFzcyhidXR0b25OYW1lLCBpc1J0bCkpIHx8XG4gICAgICAgICAgICAgICAgKGJ1dHRvblRleHQgPSBjdXN0b21CdXR0b25Qcm9wcy50ZXh0KTtcbiAgICAgICAgICAgIGJ1dHRvbkhpbnQgPSBjdXN0b21CdXR0b25Qcm9wcy5oaW50IHx8IGN1c3RvbUJ1dHRvblByb3BzLnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHZpZXdTcGVjID0gdmlld1NwZWNzW2J1dHRvbk5hbWVdKSkge1xuICAgICAgICAgICAgdmlld3NXaXRoQnV0dG9ucy5wdXNoKGJ1dHRvbk5hbWUpO1xuICAgICAgICAgICAgYnV0dG9uQ2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2FsZW5kYXJBcGkuY2hhbmdlVmlldyhidXR0b25OYW1lKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAoYnV0dG9uVGV4dCA9IHZpZXdTcGVjLmJ1dHRvblRleHRPdmVycmlkZSkgfHxcbiAgICAgICAgICAgICAgICAoYnV0dG9uSWNvbiA9IHRoZW1lLmdldEljb25DbGFzcyhidXR0b25OYW1lLCBpc1J0bCkpIHx8XG4gICAgICAgICAgICAgICAgKGJ1dHRvblRleHQgPSB2aWV3U3BlYy5idXR0b25UZXh0RGVmYXVsdCk7XG4gICAgICAgICAgICBsZXQgdGV4dEZhbGxiYWNrID0gdmlld1NwZWMuYnV0dG9uVGV4dE92ZXJyaWRlIHx8XG4gICAgICAgICAgICAgICAgdmlld1NwZWMuYnV0dG9uVGV4dERlZmF1bHQ7XG4gICAgICAgICAgICBidXR0b25IaW50ID0gZm9ybWF0V2l0aE9yZGluYWxzKHZpZXdTcGVjLmJ1dHRvblRpdGxlT3ZlcnJpZGUgfHxcbiAgICAgICAgICAgICAgICB2aWV3U3BlYy5idXR0b25UaXRsZURlZmF1bHQgfHxcbiAgICAgICAgICAgICAgICBjYWxlbmRhck9wdGlvbnMudmlld0hpbnQsIFt0ZXh0RmFsbGJhY2ssIGJ1dHRvbk5hbWVdLCAvLyB2aWV3LW5hbWUgPSBidXR0b25OYW1lXG4gICAgICAgICAgICB0ZXh0RmFsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNhbGVuZGFyQXBpW2J1dHRvbk5hbWVdKSB7IC8vIGEgY2FsZW5kYXJBcGkgbWV0aG9kXG4gICAgICAgICAgICBidXR0b25DbGljayA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjYWxlbmRhckFwaVtidXR0b25OYW1lXSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIChidXR0b25UZXh0ID0gY2FsZW5kYXJCdXR0b25UZXh0T3ZlcnJpZGVzW2J1dHRvbk5hbWVdKSB8fFxuICAgICAgICAgICAgICAgIChidXR0b25JY29uID0gdGhlbWUuZ2V0SWNvbkNsYXNzKGJ1dHRvbk5hbWUsIGlzUnRsKSkgfHxcbiAgICAgICAgICAgICAgICAoYnV0dG9uVGV4dCA9IGNhbGVuZGFyQnV0dG9uVGV4dFtidXR0b25OYW1lXSk7IC8vIGV2ZXJ5dGhpbmcgZWxzZSBpcyBjb25zaWRlcmVkIGRlZmF1bHRcbiAgICAgICAgICAgIGlmIChidXR0b25OYW1lID09PSAncHJldlllYXInIHx8IGJ1dHRvbk5hbWUgPT09ICduZXh0WWVhcicpIHtcbiAgICAgICAgICAgICAgICBsZXQgcHJldk9yTmV4dCA9IGJ1dHRvbk5hbWUgPT09ICdwcmV2WWVhcicgPyAncHJldicgOiAnbmV4dCc7XG4gICAgICAgICAgICAgICAgYnV0dG9uSGludCA9IGZvcm1hdFdpdGhPcmRpbmFscyhjYWxlbmRhckJ1dHRvbkhpbnRPdmVycmlkZXNbcHJldk9yTmV4dF0gfHxcbiAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXJCdXR0b25IaW50c1twcmV2T3JOZXh0XSwgW1xuICAgICAgICAgICAgICAgICAgICBjYWxlbmRhckJ1dHRvblRleHQueWVhciB8fCAneWVhcicsXG4gICAgICAgICAgICAgICAgICAgICd5ZWFyJyxcbiAgICAgICAgICAgICAgICBdLCBjYWxlbmRhckJ1dHRvblRleHRbYnV0dG9uTmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnV0dG9uSGludCA9IChuYXZVbml0KSA9PiBmb3JtYXRXaXRoT3JkaW5hbHMoY2FsZW5kYXJCdXR0b25IaW50T3ZlcnJpZGVzW2J1dHRvbk5hbWVdIHx8XG4gICAgICAgICAgICAgICAgICAgIGNhbGVuZGFyQnV0dG9uSGludHNbYnV0dG9uTmFtZV0sIFtcbiAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXJCdXR0b25UZXh0W25hdlVuaXRdIHx8IG5hdlVuaXQsXG4gICAgICAgICAgICAgICAgICAgIG5hdlVuaXQsXG4gICAgICAgICAgICAgICAgXSwgY2FsZW5kYXJCdXR0b25UZXh0W2J1dHRvbk5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBidXR0b25OYW1lLCBidXR0b25DbGljaywgYnV0dG9uSWNvbiwgYnV0dG9uVGV4dCwgYnV0dG9uSGludCB9O1xuICAgIH0pKSk7XG4gICAgcmV0dXJuIHsgd2lkZ2V0cywgdmlld3NXaXRoQnV0dG9ucywgaGFzVGl0bGUgfTtcbn1cblxuLy8gYWx3YXlzIHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgdmlldy4gb3RoZXJ3aXNlLCBpdCdkIG5lZWQgdG8gY2hhbmdlIHZhbHVlIGV2ZXJ5IHRpbWUgZGF0ZSBjaGFuZ2VzXG5jbGFzcyBWaWV3SW1wbCB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgZ2V0Q3VycmVudERhdGEsIGRhdGVFbnYpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5nZXRDdXJyZW50RGF0YSA9IGdldEN1cnJlbnREYXRhO1xuICAgICAgICB0aGlzLmRhdGVFbnYgPSBkYXRlRW52O1xuICAgIH1cbiAgICBnZXQgY2FsZW5kYXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnREYXRhKCkuY2FsZW5kYXJBcGk7XG4gICAgfVxuICAgIGdldCB0aXRsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudERhdGEoKS52aWV3VGl0bGU7XG4gICAgfVxuICAgIGdldCBhY3RpdmVTdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZUVudi50b0RhdGUodGhpcy5nZXRDdXJyZW50RGF0YSgpLmRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLnN0YXJ0KTtcbiAgICB9XG4gICAgZ2V0IGFjdGl2ZUVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZUVudi50b0RhdGUodGhpcy5nZXRDdXJyZW50RGF0YSgpLmRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLmVuZCk7XG4gICAgfVxuICAgIGdldCBjdXJyZW50U3RhcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGVFbnYudG9EYXRlKHRoaXMuZ2V0Q3VycmVudERhdGEoKS5kYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2Uuc3RhcnQpO1xuICAgIH1cbiAgICBnZXQgY3VycmVudEVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZUVudi50b0RhdGUodGhpcy5nZXRDdXJyZW50RGF0YSgpLmRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5lbmQpO1xuICAgIH1cbiAgICBnZXRPcHRpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50RGF0YSgpLm9wdGlvbnNbbmFtZV07IC8vIGFyZSB0aGUgdmlldy1zcGVjaWZpYyBvcHRpb25zXG4gICAgfVxufVxuXG5sZXQgZXZlbnRTb3VyY2VEZWYkMiA9IHtcbiAgICBpZ25vcmVSYW5nZTogdHJ1ZSxcbiAgICBwYXJzZU1ldGEocmVmaW5lZCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZWZpbmVkLmV2ZW50cykpIHtcbiAgICAgICAgICAgIHJldHVybiByZWZpbmVkLmV2ZW50cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGZldGNoKGFyZywgc3VjY2Vzc0NhbGxiYWNrKSB7XG4gICAgICAgIHN1Y2Nlc3NDYWxsYmFjayh7XG4gICAgICAgICAgICByYXdFdmVudHM6IGFyZy5ldmVudFNvdXJjZS5tZXRhLFxuICAgICAgICB9KTtcbiAgICB9LFxufTtcbmNvbnN0IGFycmF5RXZlbnRTb3VyY2VQbHVnaW4gPSBjcmVhdGVQbHVnaW4oe1xuICAgIG5hbWU6ICdhcnJheS1ldmVudC1zb3VyY2UnLFxuICAgIGV2ZW50U291cmNlRGVmczogW2V2ZW50U291cmNlRGVmJDJdLFxufSk7XG5cbmxldCBldmVudFNvdXJjZURlZiQxID0ge1xuICAgIHBhcnNlTWV0YShyZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVmaW5lZC5ldmVudHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiByZWZpbmVkLmV2ZW50cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGZldGNoKGFyZywgc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHsgZGF0ZUVudiB9ID0gYXJnLmNvbnRleHQ7XG4gICAgICAgIGNvbnN0IGZ1bmMgPSBhcmcuZXZlbnRTb3VyY2UubWV0YTtcbiAgICAgICAgdW5wcm9taXNpZnkoZnVuYy5iaW5kKG51bGwsIGJ1aWxkUmFuZ2VBcGlXaXRoVGltZVpvbmUoYXJnLnJhbmdlLCBkYXRlRW52KSksIChyYXdFdmVudHMpID0+IHN1Y2Nlc3NDYWxsYmFjayh7IHJhd0V2ZW50cyB9KSwgZXJyb3JDYWxsYmFjayk7XG4gICAgfSxcbn07XG5jb25zdCBmdW5jRXZlbnRTb3VyY2VQbHVnaW4gPSBjcmVhdGVQbHVnaW4oe1xuICAgIG5hbWU6ICdmdW5jLWV2ZW50LXNvdXJjZScsXG4gICAgZXZlbnRTb3VyY2VEZWZzOiBbZXZlbnRTb3VyY2VEZWYkMV0sXG59KTtcblxuY29uc3QgSlNPTl9GRUVEX0VWRU5UX1NPVVJDRV9SRUZJTkVSUyA9IHtcbiAgICBtZXRob2Q6IFN0cmluZyxcbiAgICBleHRyYVBhcmFtczogaWRlbnRpdHksXG4gICAgc3RhcnRQYXJhbTogU3RyaW5nLFxuICAgIGVuZFBhcmFtOiBTdHJpbmcsXG4gICAgdGltZVpvbmVQYXJhbTogU3RyaW5nLFxufTtcblxubGV0IGV2ZW50U291cmNlRGVmID0ge1xuICAgIHBhcnNlTWV0YShyZWZpbmVkKSB7XG4gICAgICAgIGlmIChyZWZpbmVkLnVybCAmJiAocmVmaW5lZC5mb3JtYXQgPT09ICdqc29uJyB8fCAhcmVmaW5lZC5mb3JtYXQpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogcmVmaW5lZC51cmwsXG4gICAgICAgICAgICAgICAgZm9ybWF0OiAnanNvbicsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAocmVmaW5lZC5tZXRob2QgfHwgJ0dFVCcpLnRvVXBwZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgZXh0cmFQYXJhbXM6IHJlZmluZWQuZXh0cmFQYXJhbXMsXG4gICAgICAgICAgICAgICAgc3RhcnRQYXJhbTogcmVmaW5lZC5zdGFydFBhcmFtLFxuICAgICAgICAgICAgICAgIGVuZFBhcmFtOiByZWZpbmVkLmVuZFBhcmFtLFxuICAgICAgICAgICAgICAgIHRpbWVab25lUGFyYW06IHJlZmluZWQudGltZVpvbmVQYXJhbSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBmZXRjaChhcmcsIHN1Y2Nlc3NDYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xuICAgICAgICBjb25zdCB7IG1ldGEgfSA9IGFyZy5ldmVudFNvdXJjZTtcbiAgICAgICAgY29uc3QgcmVxdWVzdFBhcmFtcyA9IGJ1aWxkUmVxdWVzdFBhcmFtcyhtZXRhLCBhcmcucmFuZ2UsIGFyZy5jb250ZXh0KTtcbiAgICAgICAgcmVxdWVzdEpzb24obWV0YS5tZXRob2QsIG1ldGEudXJsLCByZXF1ZXN0UGFyYW1zKS50aGVuKChbcmF3RXZlbnRzLCByZXNwb25zZV0pID0+IHtcbiAgICAgICAgICAgIHN1Y2Nlc3NDYWxsYmFjayh7IHJhd0V2ZW50cywgcmVzcG9uc2UgfSk7XG4gICAgICAgIH0sIGVycm9yQ2FsbGJhY2spO1xuICAgIH0sXG59O1xuY29uc3QganNvbkZlZWRFdmVudFNvdXJjZVBsdWdpbiA9IGNyZWF0ZVBsdWdpbih7XG4gICAgbmFtZTogJ2pzb24tZXZlbnQtc291cmNlJyxcbiAgICBldmVudFNvdXJjZVJlZmluZXJzOiBKU09OX0ZFRURfRVZFTlRfU09VUkNFX1JFRklORVJTLFxuICAgIGV2ZW50U291cmNlRGVmczogW2V2ZW50U291cmNlRGVmXSxcbn0pO1xuZnVuY3Rpb24gYnVpbGRSZXF1ZXN0UGFyYW1zKG1ldGEsIHJhbmdlLCBjb250ZXh0KSB7XG4gICAgbGV0IHsgZGF0ZUVudiwgb3B0aW9ucyB9ID0gY29udGV4dDtcbiAgICBsZXQgc3RhcnRQYXJhbTtcbiAgICBsZXQgZW5kUGFyYW07XG4gICAgbGV0IHRpbWVab25lUGFyYW07XG4gICAgbGV0IGN1c3RvbVJlcXVlc3RQYXJhbXM7XG4gICAgbGV0IHBhcmFtcyA9IHt9O1xuICAgIHN0YXJ0UGFyYW0gPSBtZXRhLnN0YXJ0UGFyYW07XG4gICAgaWYgKHN0YXJ0UGFyYW0gPT0gbnVsbCkge1xuICAgICAgICBzdGFydFBhcmFtID0gb3B0aW9ucy5zdGFydFBhcmFtO1xuICAgIH1cbiAgICBlbmRQYXJhbSA9IG1ldGEuZW5kUGFyYW07XG4gICAgaWYgKGVuZFBhcmFtID09IG51bGwpIHtcbiAgICAgICAgZW5kUGFyYW0gPSBvcHRpb25zLmVuZFBhcmFtO1xuICAgIH1cbiAgICB0aW1lWm9uZVBhcmFtID0gbWV0YS50aW1lWm9uZVBhcmFtO1xuICAgIGlmICh0aW1lWm9uZVBhcmFtID09IG51bGwpIHtcbiAgICAgICAgdGltZVpvbmVQYXJhbSA9IG9wdGlvbnMudGltZVpvbmVQYXJhbTtcbiAgICB9XG4gICAgLy8gcmV0cmlldmUgYW55IG91dGJvdW5kIEdFVC9QT1NUIGRhdGEgZnJvbSB0aGUgb3B0aW9uc1xuICAgIGlmICh0eXBlb2YgbWV0YS5leHRyYVBhcmFtcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBzdXBwbGllZCBhcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGtleS92YWx1ZSBvYmplY3RcbiAgICAgICAgY3VzdG9tUmVxdWVzdFBhcmFtcyA9IG1ldGEuZXh0cmFQYXJhbXMoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIHByb2JhYmx5IHN1cHBsaWVkIGFzIGEgc3RyYWlnaHQga2V5L3ZhbHVlIG9iamVjdFxuICAgICAgICBjdXN0b21SZXF1ZXN0UGFyYW1zID0gbWV0YS5leHRyYVBhcmFtcyB8fCB7fTtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbihwYXJhbXMsIGN1c3RvbVJlcXVlc3RQYXJhbXMpO1xuICAgIHBhcmFtc1tzdGFydFBhcmFtXSA9IGRhdGVFbnYuZm9ybWF0SXNvKHJhbmdlLnN0YXJ0KTtcbiAgICBwYXJhbXNbZW5kUGFyYW1dID0gZGF0ZUVudi5mb3JtYXRJc28ocmFuZ2UuZW5kKTtcbiAgICBpZiAoZGF0ZUVudi50aW1lWm9uZSAhPT0gJ2xvY2FsJykge1xuICAgICAgICBwYXJhbXNbdGltZVpvbmVQYXJhbV0gPSBkYXRlRW52LnRpbWVab25lO1xuICAgIH1cbiAgICByZXR1cm4gcGFyYW1zO1xufVxuXG5jb25zdCBTSU1QTEVfUkVDVVJSSU5HX1JFRklORVJTID0ge1xuICAgIGRheXNPZldlZWs6IGlkZW50aXR5LFxuICAgIHN0YXJ0VGltZTogY3JlYXRlRHVyYXRpb24sXG4gICAgZW5kVGltZTogY3JlYXRlRHVyYXRpb24sXG4gICAgZHVyYXRpb246IGNyZWF0ZUR1cmF0aW9uLFxuICAgIHN0YXJ0UmVjdXI6IGlkZW50aXR5LFxuICAgIGVuZFJlY3VyOiBpZGVudGl0eSxcbn07XG5cbmxldCByZWN1cnJpbmcgPSB7XG4gICAgcGFyc2UocmVmaW5lZCwgZGF0ZUVudikge1xuICAgICAgICBpZiAocmVmaW5lZC5kYXlzT2ZXZWVrIHx8IHJlZmluZWQuc3RhcnRUaW1lIHx8IHJlZmluZWQuZW5kVGltZSB8fCByZWZpbmVkLnN0YXJ0UmVjdXIgfHwgcmVmaW5lZC5lbmRSZWN1cikge1xuICAgICAgICAgICAgbGV0IHJlY3VycmluZ0RhdGEgPSB7XG4gICAgICAgICAgICAgICAgZGF5c09mV2VlazogcmVmaW5lZC5kYXlzT2ZXZWVrIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lOiByZWZpbmVkLnN0YXJ0VGltZSB8fCBudWxsLFxuICAgICAgICAgICAgICAgIGVuZFRpbWU6IHJlZmluZWQuZW5kVGltZSB8fCBudWxsLFxuICAgICAgICAgICAgICAgIHN0YXJ0UmVjdXI6IHJlZmluZWQuc3RhcnRSZWN1ciA/IGRhdGVFbnYuY3JlYXRlTWFya2VyKHJlZmluZWQuc3RhcnRSZWN1cikgOiBudWxsLFxuICAgICAgICAgICAgICAgIGVuZFJlY3VyOiByZWZpbmVkLmVuZFJlY3VyID8gZGF0ZUVudi5jcmVhdGVNYXJrZXIocmVmaW5lZC5lbmRSZWN1cikgOiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBkdXJhdGlvbjtcbiAgICAgICAgICAgIGlmIChyZWZpbmVkLmR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb24gPSByZWZpbmVkLmR1cmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkdXJhdGlvbiAmJiByZWZpbmVkLnN0YXJ0VGltZSAmJiByZWZpbmVkLmVuZFRpbWUpIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IHN1YnRyYWN0RHVyYXRpb25zKHJlZmluZWQuZW5kVGltZSwgcmVmaW5lZC5zdGFydFRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhbGxEYXlHdWVzczogQm9vbGVhbighcmVmaW5lZC5zdGFydFRpbWUgJiYgIXJlZmluZWQuZW5kVGltZSksXG4gICAgICAgICAgICAgICAgZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgdHlwZURhdGE6IHJlY3VycmluZ0RhdGEsIC8vIGRvZXNuJ3QgbmVlZCBlbmRUaW1lIGFueW1vcmUgYnV0IG9oIHdlbGxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBleHBhbmQodHlwZURhdGEsIGZyYW1pbmdSYW5nZSwgZGF0ZUVudikge1xuICAgICAgICBsZXQgY2xpcHBlZEZyYW1pbmdSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhmcmFtaW5nUmFuZ2UsIHsgc3RhcnQ6IHR5cGVEYXRhLnN0YXJ0UmVjdXIsIGVuZDogdHlwZURhdGEuZW5kUmVjdXIgfSk7XG4gICAgICAgIGlmIChjbGlwcGVkRnJhbWluZ1JhbmdlKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwYW5kUmFuZ2VzKHR5cGVEYXRhLmRheXNPZldlZWssIHR5cGVEYXRhLnN0YXJ0VGltZSwgY2xpcHBlZEZyYW1pbmdSYW5nZSwgZGF0ZUVudik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG59O1xuY29uc3Qgc2ltcGxlUmVjdXJyaW5nRXZlbnRzUGx1Z2luID0gY3JlYXRlUGx1Z2luKHtcbiAgICBuYW1lOiAnc2ltcGxlLXJlY3VycmluZy1ldmVudCcsXG4gICAgcmVjdXJyaW5nVHlwZXM6IFtyZWN1cnJpbmddLFxuICAgIGV2ZW50UmVmaW5lcnM6IFNJTVBMRV9SRUNVUlJJTkdfUkVGSU5FUlMsXG59KTtcbmZ1bmN0aW9uIGV4cGFuZFJhbmdlcyhkYXlzT2ZXZWVrLCBzdGFydFRpbWUsIGZyYW1pbmdSYW5nZSwgZGF0ZUVudikge1xuICAgIGxldCBkb3dIYXNoID0gZGF5c09mV2VlayA/IGFycmF5VG9IYXNoKGRheXNPZldlZWspIDogbnVsbDtcbiAgICBsZXQgZGF5TWFya2VyID0gc3RhcnRPZkRheShmcmFtaW5nUmFuZ2Uuc3RhcnQpO1xuICAgIGxldCBlbmRNYXJrZXIgPSBmcmFtaW5nUmFuZ2UuZW5kO1xuICAgIGxldCBpbnN0YW5jZVN0YXJ0cyA9IFtdO1xuICAgIHdoaWxlIChkYXlNYXJrZXIgPCBlbmRNYXJrZXIpIHtcbiAgICAgICAgbGV0IGluc3RhbmNlU3RhcnQ7XG4gICAgICAgIC8vIGlmIGV2ZXJ5ZGF5LCBvciB0aGlzIHBhcnRpY3VsYXIgZGF5LW9mLXdlZWtcbiAgICAgICAgaWYgKCFkb3dIYXNoIHx8IGRvd0hhc2hbZGF5TWFya2VyLmdldFVUQ0RheSgpXSkge1xuICAgICAgICAgICAgaWYgKHN0YXJ0VGltZSkge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlU3RhcnQgPSBkYXRlRW52LmFkZChkYXlNYXJrZXIsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZVN0YXJ0ID0gZGF5TWFya2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5zdGFuY2VTdGFydHMucHVzaChpbnN0YW5jZVN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBkYXlNYXJrZXIgPSBhZGREYXlzKGRheU1hcmtlciwgMSk7XG4gICAgfVxuICAgIHJldHVybiBpbnN0YW5jZVN0YXJ0cztcbn1cblxuY29uc3QgY2hhbmdlSGFuZGxlclBsdWdpbiA9IGNyZWF0ZVBsdWdpbih7XG4gICAgbmFtZTogJ2NoYW5nZS1oYW5kbGVyJyxcbiAgICBvcHRpb25DaGFuZ2VIYW5kbGVyczoge1xuICAgICAgICBldmVudHMoZXZlbnRzLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBoYW5kbGVFdmVudFNvdXJjZXMoW2V2ZW50c10sIGNvbnRleHQpO1xuICAgICAgICB9LFxuICAgICAgICBldmVudFNvdXJjZXM6IGhhbmRsZUV2ZW50U291cmNlcyxcbiAgICB9LFxufSk7XG4vKlxuQlVHOiBpZiBgZXZlbnRgIHdhcyBzdXBwbGllZCwgYWxsIHByZXZpb3VzbHktZ2l2ZW4gYGV2ZW50U291cmNlc2Agd2lsbCBiZSB3aXBlZCBvdXRcbiovXG5mdW5jdGlvbiBoYW5kbGVFdmVudFNvdXJjZXMoaW5wdXRzLCBjb250ZXh0KSB7XG4gICAgbGV0IHVuZm91bmRTb3VyY2VzID0gaGFzaFZhbHVlc1RvQXJyYXkoY29udGV4dC5nZXRDdXJyZW50RGF0YSgpLmV2ZW50U291cmNlcyk7XG4gICAgaWYgKHVuZm91bmRTb3VyY2VzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICBpbnB1dHMubGVuZ3RoID09PSAxICYmXG4gICAgICAgIEFycmF5LmlzQXJyYXkodW5mb3VuZFNvdXJjZXNbMF0uX3JhdykgJiZcbiAgICAgICAgQXJyYXkuaXNBcnJheShpbnB1dHNbMF0pKSB7XG4gICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ1JFU0VUX1JBV19FVkVOVFMnLFxuICAgICAgICAgICAgc291cmNlSWQ6IHVuZm91bmRTb3VyY2VzWzBdLnNvdXJjZUlkLFxuICAgICAgICAgICAgcmF3RXZlbnRzOiBpbnB1dHNbMF0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBuZXdJbnB1dHMgPSBbXTtcbiAgICBmb3IgKGxldCBpbnB1dCBvZiBpbnB1dHMpIHtcbiAgICAgICAgbGV0IGlucHV0Rm91bmQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1bmZvdW5kU291cmNlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKHVuZm91bmRTb3VyY2VzW2ldLl9yYXcgPT09IGlucHV0KSB7XG4gICAgICAgICAgICAgICAgdW5mb3VuZFNvdXJjZXMuc3BsaWNlKGksIDEpOyAvLyBkZWxldGVcbiAgICAgICAgICAgICAgICBpbnB1dEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlucHV0Rm91bmQpIHtcbiAgICAgICAgICAgIG5ld0lucHV0cy5wdXNoKGlucHV0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCB1bmZvdW5kU291cmNlIG9mIHVuZm91bmRTb3VyY2VzKSB7XG4gICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ1JFTU9WRV9FVkVOVF9TT1VSQ0UnLFxuICAgICAgICAgICAgc291cmNlSWQ6IHVuZm91bmRTb3VyY2Uuc291cmNlSWQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKGxldCBuZXdJbnB1dCBvZiBuZXdJbnB1dHMpIHtcbiAgICAgICAgY29udGV4dC5jYWxlbmRhckFwaS5hZGRFdmVudFNvdXJjZShuZXdJbnB1dCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVEYXRlUHJvZmlsZShkYXRlUHJvZmlsZSwgY29udGV4dCkge1xuICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdkYXRlc1NldCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYnVpbGRSYW5nZUFwaVdpdGhUaW1lWm9uZShkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgY29udGV4dC5kYXRlRW52KSksIHsgdmlldzogY29udGV4dC52aWV3QXBpIH0pKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlRXZlbnRTdG9yZShldmVudFN0b3JlLCBjb250ZXh0KSB7XG4gICAgbGV0IHsgZW1pdHRlciB9ID0gY29udGV4dDtcbiAgICBpZiAoZW1pdHRlci5oYXNIYW5kbGVycygnZXZlbnRzU2V0JykpIHtcbiAgICAgICAgZW1pdHRlci50cmlnZ2VyKCdldmVudHNTZXQnLCBidWlsZEV2ZW50QXBpcyhldmVudFN0b3JlLCBjb250ZXh0KSk7XG4gICAgfVxufVxuXG4vKlxudGhpcyBhcnJheSBpcyBleHBvc2VkIG9uIHRoZSByb290IG5hbWVzcGFjZSBzbyB0aGF0IFVNRCBwbHVnaW5zIGNhbiBhZGQgdG8gaXQuXG5zZWUgdGhlIHJvbGx1cC1idW5kbGVzIHNjcmlwdC5cbiovXG5jb25zdCBnbG9iYWxQbHVnaW5zID0gW1xuICAgIGFycmF5RXZlbnRTb3VyY2VQbHVnaW4sXG4gICAgZnVuY0V2ZW50U291cmNlUGx1Z2luLFxuICAgIGpzb25GZWVkRXZlbnRTb3VyY2VQbHVnaW4sXG4gICAgc2ltcGxlUmVjdXJyaW5nRXZlbnRzUGx1Z2luLFxuICAgIGNoYW5nZUhhbmRsZXJQbHVnaW4sXG4gICAgY3JlYXRlUGx1Z2luKHtcbiAgICAgICAgbmFtZTogJ21pc2MnLFxuICAgICAgICBpc0xvYWRpbmdGdW5jczogW1xuICAgICAgICAgICAgKHN0YXRlKSA9PiBjb21wdXRlRXZlbnRTb3VyY2VzTG9hZGluZyhzdGF0ZS5ldmVudFNvdXJjZXMpLFxuICAgICAgICBdLFxuICAgICAgICBwcm9wU2V0SGFuZGxlcnM6IHtcbiAgICAgICAgICAgIGRhdGVQcm9maWxlOiBoYW5kbGVEYXRlUHJvZmlsZSxcbiAgICAgICAgICAgIGV2ZW50U3RvcmU6IGhhbmRsZUV2ZW50U3RvcmUsXG4gICAgICAgIH0sXG4gICAgfSksXG5dO1xuXG5jbGFzcyBUYXNrUnVubmVyIHtcbiAgICBjb25zdHJ1Y3RvcihydW5UYXNrT3B0aW9uLCBkcmFpbmVkT3B0aW9uKSB7XG4gICAgICAgIHRoaXMucnVuVGFza09wdGlvbiA9IHJ1blRhc2tPcHRpb247XG4gICAgICAgIHRoaXMuZHJhaW5lZE9wdGlvbiA9IGRyYWluZWRPcHRpb247XG4gICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5kZWxheWVkUnVubmVyID0gbmV3IERlbGF5ZWRSdW5uZXIodGhpcy5kcmFpbi5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgcmVxdWVzdCh0YXNrLCBkZWxheSkge1xuICAgICAgICB0aGlzLnF1ZXVlLnB1c2godGFzayk7XG4gICAgICAgIHRoaXMuZGVsYXllZFJ1bm5lci5yZXF1ZXN0KGRlbGF5KTtcbiAgICB9XG4gICAgcGF1c2Uoc2NvcGUpIHtcbiAgICAgICAgdGhpcy5kZWxheWVkUnVubmVyLnBhdXNlKHNjb3BlKTtcbiAgICB9XG4gICAgcmVzdW1lKHNjb3BlLCBmb3JjZSkge1xuICAgICAgICB0aGlzLmRlbGF5ZWRSdW5uZXIucmVzdW1lKHNjb3BlLCBmb3JjZSk7XG4gICAgfVxuICAgIGRyYWluKCkge1xuICAgICAgICBsZXQgeyBxdWV1ZSB9ID0gdGhpcztcbiAgICAgICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGNvbXBsZXRlZFRhc2tzID0gW107XG4gICAgICAgICAgICBsZXQgdGFzaztcbiAgICAgICAgICAgIHdoaWxlICgodGFzayA9IHF1ZXVlLnNoaWZ0KCkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5UYXNrKHRhc2spO1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlZFRhc2tzLnB1c2godGFzayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRyYWluZWQoY29tcGxldGVkVGFza3MpO1xuICAgICAgICB9IC8vIGtlZXAgZ29pbmcsIGluIGNhc2UgbmV3IHRhc2tzIHdlcmUgYWRkZWQgaW4gdGhlIGRyYWluZWQgaGFuZGxlclxuICAgIH1cbiAgICBydW5UYXNrKHRhc2spIHtcbiAgICAgICAgaWYgKHRoaXMucnVuVGFza09wdGlvbikge1xuICAgICAgICAgICAgdGhpcy5ydW5UYXNrT3B0aW9uKHRhc2spO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRyYWluZWQoY29tcGxldGVkVGFza3MpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhaW5lZE9wdGlvbikge1xuICAgICAgICAgICAgdGhpcy5kcmFpbmVkT3B0aW9uKGNvbXBsZXRlZFRhc2tzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gQ29tcHV0ZXMgd2hhdCB0aGUgdGl0bGUgYXQgdGhlIHRvcCBvZiB0aGUgY2FsZW5kYXJBcGkgc2hvdWxkIGJlIGZvciB0aGlzIHZpZXdcbmZ1bmN0aW9uIGJ1aWxkVGl0bGUoZGF0ZVByb2ZpbGUsIHZpZXdPcHRpb25zLCBkYXRlRW52KSB7XG4gICAgbGV0IHJhbmdlO1xuICAgIC8vIGZvciB2aWV3cyB0aGF0IHNwYW4gYSBsYXJnZSB1bml0IG9mIHRpbWUsIHNob3cgdGhlIHByb3BlciBpbnRlcnZhbCwgaWdub3Jpbmcgc3RyYXkgZGF5cyBiZWZvcmUgYW5kIGFmdGVyXG4gICAgaWYgKC9eKHllYXJ8bW9udGgpJC8udGVzdChkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2VVbml0KSkge1xuICAgICAgICByYW5nZSA9IGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZTtcbiAgICB9XG4gICAgZWxzZSB7IC8vIGZvciBkYXkgdW5pdHMgb3Igc21hbGxlciwgdXNlIHRoZSBhY3R1YWwgZGF5IHJhbmdlXG4gICAgICAgIHJhbmdlID0gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2U7XG4gICAgfVxuICAgIHJldHVybiBkYXRlRW52LmZvcm1hdFJhbmdlKHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQsIGNyZWF0ZUZvcm1hdHRlcih2aWV3T3B0aW9ucy50aXRsZUZvcm1hdCB8fCBidWlsZFRpdGxlRm9ybWF0KGRhdGVQcm9maWxlKSksIHtcbiAgICAgICAgaXNFbmRFeGNsdXNpdmU6IGRhdGVQcm9maWxlLmlzUmFuZ2VBbGxEYXksXG4gICAgICAgIGRlZmF1bHRTZXBhcmF0b3I6IHZpZXdPcHRpb25zLnRpdGxlUmFuZ2VTZXBhcmF0b3IsXG4gICAgfSk7XG59XG4vLyBHZW5lcmF0ZXMgdGhlIGZvcm1hdCBzdHJpbmcgdGhhdCBzaG91bGQgYmUgdXNlZCB0byBnZW5lcmF0ZSB0aGUgdGl0bGUgZm9yIHRoZSBjdXJyZW50IGRhdGUgcmFuZ2UuXG4vLyBBdHRlbXB0cyB0byBjb21wdXRlIHRoZSBtb3N0IGFwcHJvcHJpYXRlIGZvcm1hdCBpZiBub3QgZXhwbGljaXRseSBzcGVjaWZpZWQgd2l0aCBgdGl0bGVGb3JtYXRgLlxuZnVuY3Rpb24gYnVpbGRUaXRsZUZvcm1hdChkYXRlUHJvZmlsZSkge1xuICAgIGxldCB7IGN1cnJlbnRSYW5nZVVuaXQgfSA9IGRhdGVQcm9maWxlO1xuICAgIGlmIChjdXJyZW50UmFuZ2VVbml0ID09PSAneWVhcicpIHtcbiAgICAgICAgcmV0dXJuIHsgeWVhcjogJ251bWVyaWMnIH07XG4gICAgfVxuICAgIGlmIChjdXJyZW50UmFuZ2VVbml0ID09PSAnbW9udGgnKSB7XG4gICAgICAgIHJldHVybiB7IHllYXI6ICdudW1lcmljJywgbW9udGg6ICdsb25nJyB9OyAvLyBsaWtlIFwiU2VwdGVtYmVyIDIwMTRcIlxuICAgIH1cbiAgICBsZXQgZGF5cyA9IGRpZmZXaG9sZURheXMoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLnN0YXJ0LCBkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2UuZW5kKTtcbiAgICBpZiAoZGF5cyAhPT0gbnVsbCAmJiBkYXlzID4gMSkge1xuICAgICAgICAvLyBtdWx0aS1kYXkgcmFuZ2UuIHNob3J0ZXIsIGxpa2UgXCJTZXAgOSAtIDEwIDIwMTRcIlxuICAgICAgICByZXR1cm4geyB5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnc2hvcnQnLCBkYXk6ICdudW1lcmljJyB9O1xuICAgIH1cbiAgICAvLyBvbmUgZGF5LiBsb25nZXIsIGxpa2UgXCJTZXB0ZW1iZXIgOSAyMDE0XCJcbiAgICByZXR1cm4geyB5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnbG9uZycsIGRheTogJ251bWVyaWMnIH07XG59XG5cbi8vIGluIGZ1dHVyZSByZWZhY3RvciwgZG8gdGhlIHJlZHV4LXN0eWxlIGZ1bmN0aW9uKHN0YXRlPWluaXRpYWwpIGZvciBpbml0aWFsLXN0YXRlXG4vLyBhbHNvLCB3aGF0ZXZlciBpcyBoYXBwZW5pbmcgaW4gY29uc3RydWN0b3IsIGhhdmUgaXQgaGFwcGVuIGluIGFjdGlvbiBxdWV1ZSB0b29cbmNsYXNzIENhbGVuZGFyRGF0YU1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHRoaXMuY29tcHV0ZUN1cnJlbnRWaWV3RGF0YSA9IG1lbW9pemUodGhpcy5fY29tcHV0ZUN1cnJlbnRWaWV3RGF0YSk7XG4gICAgICAgIHRoaXMub3JnYW5pemVSYXdMb2NhbGVzID0gbWVtb2l6ZShvcmdhbml6ZVJhd0xvY2FsZXMpO1xuICAgICAgICB0aGlzLmJ1aWxkTG9jYWxlID0gbWVtb2l6ZShidWlsZExvY2FsZSk7XG4gICAgICAgIHRoaXMuYnVpbGRQbHVnaW5Ib29rcyA9IGJ1aWxkQnVpbGRQbHVnaW5Ib29rcygpO1xuICAgICAgICB0aGlzLmJ1aWxkRGF0ZUVudiA9IG1lbW9pemUoYnVpbGREYXRlRW52JDEpO1xuICAgICAgICB0aGlzLmJ1aWxkVGhlbWUgPSBtZW1vaXplKGJ1aWxkVGhlbWUpO1xuICAgICAgICB0aGlzLnBhcnNlVG9vbGJhcnMgPSBtZW1vaXplKHBhcnNlVG9vbGJhcnMpO1xuICAgICAgICB0aGlzLmJ1aWxkVmlld1NwZWNzID0gbWVtb2l6ZShidWlsZFZpZXdTcGVjcyk7XG4gICAgICAgIHRoaXMuYnVpbGREYXRlUHJvZmlsZUdlbmVyYXRvciA9IG1lbW9pemVPYmpBcmcoYnVpbGREYXRlUHJvZmlsZUdlbmVyYXRvcik7XG4gICAgICAgIHRoaXMuYnVpbGRWaWV3QXBpID0gbWVtb2l6ZShidWlsZFZpZXdBcGkpO1xuICAgICAgICB0aGlzLmJ1aWxkVmlld1VpUHJvcHMgPSBtZW1vaXplT2JqQXJnKGJ1aWxkVmlld1VpUHJvcHMpO1xuICAgICAgICB0aGlzLmJ1aWxkRXZlbnRVaUJ5U291cmNlID0gbWVtb2l6ZShidWlsZEV2ZW50VWlCeVNvdXJjZSwgaXNQcm9wc0VxdWFsKTtcbiAgICAgICAgdGhpcy5idWlsZEV2ZW50VWlCYXNlcyA9IG1lbW9pemUoYnVpbGRFdmVudFVpQmFzZXMpO1xuICAgICAgICB0aGlzLnBhcnNlQ29udGV4dEJ1c2luZXNzSG91cnMgPSBtZW1vaXplT2JqQXJnKHBhcnNlQ29udGV4dEJ1c2luZXNzSG91cnMpO1xuICAgICAgICB0aGlzLmJ1aWxkVGl0bGUgPSBtZW1vaXplKGJ1aWxkVGl0bGUpO1xuICAgICAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xuICAgICAgICB0aGlzLmFjdGlvblJ1bm5lciA9IG5ldyBUYXNrUnVubmVyKHRoaXMuX2hhbmRsZUFjdGlvbi5iaW5kKHRoaXMpLCB0aGlzLnVwZGF0ZURhdGEuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc0lucHV0ID0ge307XG4gICAgICAgIHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZWQgPSB7fTtcbiAgICAgICAgdGhpcy5jdXJyZW50Vmlld09wdGlvbnNJbnB1dCA9IHt9O1xuICAgICAgICB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc1JlZmluZWQgPSB7fTtcbiAgICAgICAgdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lcnMgPSB7fTtcbiAgICAgICAgdGhpcy5vcHRpb25zRm9yUmVmaW5pbmcgPSBbXTtcbiAgICAgICAgdGhpcy5vcHRpb25zRm9ySGFuZGxpbmcgPSBbXTtcbiAgICAgICAgdGhpcy5nZXRDdXJyZW50RGF0YSA9ICgpID0+IHRoaXMuZGF0YTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCA9IChhY3Rpb24pID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uUnVubmVyLnJlcXVlc3QoYWN0aW9uKTsgLy8gcHJvdGVjdHMgYWdhaW5zdCByZWN1cnNpdmUgY2FsbHMgdG8gX2hhbmRsZUFjdGlvblxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICAgIHRoaXMuYWN0aW9uUnVubmVyLnBhdXNlKCk7XG4gICAgICAgIGxldCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzID0ge307XG4gICAgICAgIGxldCBvcHRpb25zRGF0YSA9IHRoaXMuY29tcHV0ZU9wdGlvbnNEYXRhKHByb3BzLm9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcywgcHJvcHMuY2FsZW5kYXJBcGkpO1xuICAgICAgICBsZXQgY3VycmVudFZpZXdUeXBlID0gb3B0aW9uc0RhdGEuY2FsZW5kYXJPcHRpb25zLmluaXRpYWxWaWV3IHx8IG9wdGlvbnNEYXRhLnBsdWdpbkhvb2tzLmluaXRpYWxWaWV3O1xuICAgICAgICBsZXQgY3VycmVudFZpZXdEYXRhID0gdGhpcy5jb21wdXRlQ3VycmVudFZpZXdEYXRhKGN1cnJlbnRWaWV3VHlwZSwgb3B0aW9uc0RhdGEsIHByb3BzLm9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcyk7XG4gICAgICAgIC8vIHdpcmUgdGhpbmdzIHVwXG4gICAgICAgIC8vIFRPRE86IG5vdCBEUllcbiAgICAgICAgcHJvcHMuY2FsZW5kYXJBcGkuY3VycmVudERhdGFNYW5hZ2VyID0gdGhpcztcbiAgICAgICAgdGhpcy5lbWl0dGVyLnNldFRoaXNDb250ZXh0KHByb3BzLmNhbGVuZGFyQXBpKTtcbiAgICAgICAgdGhpcy5lbWl0dGVyLnNldE9wdGlvbnMoY3VycmVudFZpZXdEYXRhLm9wdGlvbnMpO1xuICAgICAgICBsZXQgY3VycmVudERhdGUgPSBnZXRJbml0aWFsRGF0ZShvcHRpb25zRGF0YS5jYWxlbmRhck9wdGlvbnMsIG9wdGlvbnNEYXRhLmRhdGVFbnYpO1xuICAgICAgICBsZXQgZGF0ZVByb2ZpbGUgPSBjdXJyZW50Vmlld0RhdGEuZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGQoY3VycmVudERhdGUpO1xuICAgICAgICBpZiAoIXJhbmdlQ29udGFpbnNNYXJrZXIoZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UsIGN1cnJlbnREYXRlKSkge1xuICAgICAgICAgICAgY3VycmVudERhdGUgPSBkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2Uuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNhbGVuZGFyQ29udGV4dCA9IHtcbiAgICAgICAgICAgIGRhdGVFbnY6IG9wdGlvbnNEYXRhLmRhdGVFbnYsXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zRGF0YS5jYWxlbmRhck9wdGlvbnMsXG4gICAgICAgICAgICBwbHVnaW5Ib29rczogb3B0aW9uc0RhdGEucGx1Z2luSG9va3MsXG4gICAgICAgICAgICBjYWxlbmRhckFwaTogcHJvcHMuY2FsZW5kYXJBcGksXG4gICAgICAgICAgICBkaXNwYXRjaDogdGhpcy5kaXNwYXRjaCxcbiAgICAgICAgICAgIGVtaXR0ZXI6IHRoaXMuZW1pdHRlcixcbiAgICAgICAgICAgIGdldEN1cnJlbnREYXRhOiB0aGlzLmdldEN1cnJlbnREYXRhLFxuICAgICAgICB9O1xuICAgICAgICAvLyBuZWVkcyB0byBiZSBhZnRlciBzZXRUaGlzQ29udGV4dFxuICAgICAgICBmb3IgKGxldCBjYWxsYmFjayBvZiBvcHRpb25zRGF0YS5wbHVnaW5Ib29rcy5jb250ZXh0SW5pdCkge1xuICAgICAgICAgICAgY2FsbGJhY2soY2FsZW5kYXJDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOT1QgRFJZXG4gICAgICAgIGxldCBldmVudFNvdXJjZXMgPSBpbml0RXZlbnRTb3VyY2VzKG9wdGlvbnNEYXRhLmNhbGVuZGFyT3B0aW9ucywgZGF0ZVByb2ZpbGUsIGNhbGVuZGFyQ29udGV4dCk7XG4gICAgICAgIGxldCBpbml0aWFsU3RhdGUgPSB7XG4gICAgICAgICAgICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICAgICAgY3VycmVudFZpZXdUeXBlLFxuICAgICAgICAgICAgY3VycmVudERhdGUsXG4gICAgICAgICAgICBkYXRlUHJvZmlsZSxcbiAgICAgICAgICAgIGJ1c2luZXNzSG91cnM6IHRoaXMucGFyc2VDb250ZXh0QnVzaW5lc3NIb3VycyhjYWxlbmRhckNvbnRleHQpLFxuICAgICAgICAgICAgZXZlbnRTb3VyY2VzLFxuICAgICAgICAgICAgZXZlbnRVaUJhc2VzOiB7fSxcbiAgICAgICAgICAgIGV2ZW50U3RvcmU6IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpLFxuICAgICAgICAgICAgcmVuZGVyYWJsZUV2ZW50U3RvcmU6IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpLFxuICAgICAgICAgICAgZGF0ZVNlbGVjdGlvbjogbnVsbCxcbiAgICAgICAgICAgIGV2ZW50U2VsZWN0aW9uOiAnJyxcbiAgICAgICAgICAgIGV2ZW50RHJhZzogbnVsbCxcbiAgICAgICAgICAgIGV2ZW50UmVzaXplOiBudWxsLFxuICAgICAgICAgICAgc2VsZWN0aW9uQ29uZmlnOiB0aGlzLmJ1aWxkVmlld1VpUHJvcHMoY2FsZW5kYXJDb250ZXh0KS5zZWxlY3Rpb25Db25maWcsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBjb250ZXh0QW5kU3RhdGUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNhbGVuZGFyQ29udGV4dCksIGluaXRpYWxTdGF0ZSk7XG4gICAgICAgIGZvciAobGV0IHJlZHVjZXIgb2Ygb3B0aW9uc0RhdGEucGx1Z2luSG9va3MucmVkdWNlcnMpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaW5pdGlhbFN0YXRlLCByZWR1Y2VyKG51bGwsIG51bGwsIGNvbnRleHRBbmRTdGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wdXRlSXNMb2FkaW5nKGluaXRpYWxTdGF0ZSwgY2FsZW5kYXJDb250ZXh0KSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2xvYWRpbmcnLCB0cnVlKTsgLy8gTk9UIERSWVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gICAgICAgIHRoaXMudXBkYXRlRGF0YSgpO1xuICAgICAgICB0aGlzLmFjdGlvblJ1bm5lci5yZXN1bWUoKTtcbiAgICB9XG4gICAgcmVzZXRPcHRpb25zKG9wdGlvbk92ZXJyaWRlcywgY2hhbmdlZE9wdGlvbk5hbWVzKSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBpZiAoY2hhbmdlZE9wdGlvbk5hbWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHByb3BzLm9wdGlvbk92ZXJyaWRlcyA9IG9wdGlvbk92ZXJyaWRlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByb3BzLm9wdGlvbk92ZXJyaWRlcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKHByb3BzLm9wdGlvbk92ZXJyaWRlcyB8fCB7fSkpLCBvcHRpb25PdmVycmlkZXMpO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zRm9yUmVmaW5pbmcucHVzaCguLi5jaGFuZ2VkT3B0aW9uTmFtZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VkT3B0aW9uTmFtZXMgPT09IHVuZGVmaW5lZCB8fCBjaGFuZ2VkT3B0aW9uTmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGlvblJ1bm5lci5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnTk9USElORycsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaGFuZGxlQWN0aW9uKGFjdGlvbikge1xuICAgICAgICBsZXQgeyBwcm9wcywgc3RhdGUsIGVtaXR0ZXIgfSA9IHRoaXM7XG4gICAgICAgIGxldCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzID0gcmVkdWNlRHluYW1pY09wdGlvbk92ZXJyaWRlcyhzdGF0ZS5keW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBhY3Rpb24pO1xuICAgICAgICBsZXQgb3B0aW9uc0RhdGEgPSB0aGlzLmNvbXB1dGVPcHRpb25zRGF0YShwcm9wcy5vcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsIHByb3BzLmNhbGVuZGFyQXBpKTtcbiAgICAgICAgbGV0IGN1cnJlbnRWaWV3VHlwZSA9IHJlZHVjZVZpZXdUeXBlKHN0YXRlLmN1cnJlbnRWaWV3VHlwZSwgYWN0aW9uKTtcbiAgICAgICAgbGV0IGN1cnJlbnRWaWV3RGF0YSA9IHRoaXMuY29tcHV0ZUN1cnJlbnRWaWV3RGF0YShjdXJyZW50Vmlld1R5cGUsIG9wdGlvbnNEYXRhLCBwcm9wcy5vcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMpO1xuICAgICAgICAvLyB3aXJlIHRoaW5ncyB1cFxuICAgICAgICAvLyBUT0RPOiBub3QgRFJZXG4gICAgICAgIHByb3BzLmNhbGVuZGFyQXBpLmN1cnJlbnREYXRhTWFuYWdlciA9IHRoaXM7XG4gICAgICAgIGVtaXR0ZXIuc2V0VGhpc0NvbnRleHQocHJvcHMuY2FsZW5kYXJBcGkpO1xuICAgICAgICBlbWl0dGVyLnNldE9wdGlvbnMoY3VycmVudFZpZXdEYXRhLm9wdGlvbnMpO1xuICAgICAgICBsZXQgY2FsZW5kYXJDb250ZXh0ID0ge1xuICAgICAgICAgICAgZGF0ZUVudjogb3B0aW9uc0RhdGEuZGF0ZUVudixcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNEYXRhLmNhbGVuZGFyT3B0aW9ucyxcbiAgICAgICAgICAgIHBsdWdpbkhvb2tzOiBvcHRpb25zRGF0YS5wbHVnaW5Ib29rcyxcbiAgICAgICAgICAgIGNhbGVuZGFyQXBpOiBwcm9wcy5jYWxlbmRhckFwaSxcbiAgICAgICAgICAgIGRpc3BhdGNoOiB0aGlzLmRpc3BhdGNoLFxuICAgICAgICAgICAgZW1pdHRlcixcbiAgICAgICAgICAgIGdldEN1cnJlbnREYXRhOiB0aGlzLmdldEN1cnJlbnREYXRhLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgeyBjdXJyZW50RGF0ZSwgZGF0ZVByb2ZpbGUgfSA9IHN0YXRlO1xuICAgICAgICBpZiAodGhpcy5kYXRhICYmIHRoaXMuZGF0YS5kYXRlUHJvZmlsZUdlbmVyYXRvciAhPT0gY3VycmVudFZpZXdEYXRhLmRhdGVQcm9maWxlR2VuZXJhdG9yKSB7IC8vIGhhY2tcbiAgICAgICAgICAgIGRhdGVQcm9maWxlID0gY3VycmVudFZpZXdEYXRhLmRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkKGN1cnJlbnREYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50RGF0ZSA9IHJlZHVjZUN1cnJlbnREYXRlKGN1cnJlbnREYXRlLCBhY3Rpb24pO1xuICAgICAgICBkYXRlUHJvZmlsZSA9IHJlZHVjZURhdGVQcm9maWxlKGRhdGVQcm9maWxlLCBhY3Rpb24sIGN1cnJlbnREYXRlLCBjdXJyZW50Vmlld0RhdGEuZGF0ZVByb2ZpbGVHZW5lcmF0b3IpO1xuICAgICAgICBpZiAoYWN0aW9uLnR5cGUgPT09ICdQUkVWJyB8fCAvLyBUT0RPOiBtb3ZlIHRoaXMgbG9naWMgaW50byBEYXRlUHJvZmlsZUdlbmVyYXRvclxuICAgICAgICAgICAgYWN0aW9uLnR5cGUgPT09ICdORVhUJyB8fCAvLyBcIlxuICAgICAgICAgICAgIXJhbmdlQ29udGFpbnNNYXJrZXIoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLCBjdXJyZW50RGF0ZSkpIHtcbiAgICAgICAgICAgIGN1cnJlbnREYXRlID0gZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGxldCBldmVudFNvdXJjZXMgPSByZWR1Y2VFdmVudFNvdXJjZXMoc3RhdGUuZXZlbnRTb3VyY2VzLCBhY3Rpb24sIGRhdGVQcm9maWxlLCBjYWxlbmRhckNvbnRleHQpO1xuICAgICAgICBsZXQgZXZlbnRTdG9yZSA9IHJlZHVjZUV2ZW50U3RvcmUoc3RhdGUuZXZlbnRTdG9yZSwgYWN0aW9uLCBldmVudFNvdXJjZXMsIGRhdGVQcm9maWxlLCBjYWxlbmRhckNvbnRleHQpO1xuICAgICAgICBsZXQgaXNFdmVudHNMb2FkaW5nID0gY29tcHV0ZUV2ZW50U291cmNlc0xvYWRpbmcoZXZlbnRTb3VyY2VzKTsgLy8gQkFELiBhbHNvIGNhbGxlZCBpbiB0aGlzIGZ1bmMgaW4gY29tcHV0ZUlzTG9hZGluZ1xuICAgICAgICBsZXQgcmVuZGVyYWJsZUV2ZW50U3RvcmUgPSAoaXNFdmVudHNMb2FkaW5nICYmICFjdXJyZW50Vmlld0RhdGEub3B0aW9ucy5wcm9ncmVzc2l2ZUV2ZW50UmVuZGVyaW5nKSA/XG4gICAgICAgICAgICAoc3RhdGUucmVuZGVyYWJsZUV2ZW50U3RvcmUgfHwgZXZlbnRTdG9yZSkgOiAvLyB0cnkgZnJvbSBwcmV2aW91cyBzdGF0ZVxuICAgICAgICAgICAgZXZlbnRTdG9yZTtcbiAgICAgICAgbGV0IHsgZXZlbnRVaVNpbmdsZUJhc2UsIHNlbGVjdGlvbkNvbmZpZyB9ID0gdGhpcy5idWlsZFZpZXdVaVByb3BzKGNhbGVuZGFyQ29udGV4dCk7IC8vIHdpbGwgbWVtb2l6ZSBvYmpcbiAgICAgICAgbGV0IGV2ZW50VWlCeVNvdXJjZSA9IHRoaXMuYnVpbGRFdmVudFVpQnlTb3VyY2UoZXZlbnRTb3VyY2VzKTtcbiAgICAgICAgbGV0IGV2ZW50VWlCYXNlcyA9IHRoaXMuYnVpbGRFdmVudFVpQmFzZXMocmVuZGVyYWJsZUV2ZW50U3RvcmUuZGVmcywgZXZlbnRVaVNpbmdsZUJhc2UsIGV2ZW50VWlCeVNvdXJjZSk7XG4gICAgICAgIGxldCBuZXdTdGF0ZSA9IHtcbiAgICAgICAgICAgIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsXG4gICAgICAgICAgICBjdXJyZW50Vmlld1R5cGUsXG4gICAgICAgICAgICBjdXJyZW50RGF0ZSxcbiAgICAgICAgICAgIGRhdGVQcm9maWxlLFxuICAgICAgICAgICAgZXZlbnRTb3VyY2VzLFxuICAgICAgICAgICAgZXZlbnRTdG9yZSxcbiAgICAgICAgICAgIHJlbmRlcmFibGVFdmVudFN0b3JlLFxuICAgICAgICAgICAgc2VsZWN0aW9uQ29uZmlnLFxuICAgICAgICAgICAgZXZlbnRVaUJhc2VzLFxuICAgICAgICAgICAgYnVzaW5lc3NIb3VyczogdGhpcy5wYXJzZUNvbnRleHRCdXNpbmVzc0hvdXJzKGNhbGVuZGFyQ29udGV4dCksXG4gICAgICAgICAgICBkYXRlU2VsZWN0aW9uOiByZWR1Y2VEYXRlU2VsZWN0aW9uKHN0YXRlLmRhdGVTZWxlY3Rpb24sIGFjdGlvbiksXG4gICAgICAgICAgICBldmVudFNlbGVjdGlvbjogcmVkdWNlU2VsZWN0ZWRFdmVudChzdGF0ZS5ldmVudFNlbGVjdGlvbiwgYWN0aW9uKSxcbiAgICAgICAgICAgIGV2ZW50RHJhZzogcmVkdWNlRXZlbnREcmFnKHN0YXRlLmV2ZW50RHJhZywgYWN0aW9uKSxcbiAgICAgICAgICAgIGV2ZW50UmVzaXplOiByZWR1Y2VFdmVudFJlc2l6ZShzdGF0ZS5ldmVudFJlc2l6ZSwgYWN0aW9uKSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGNvbnRleHRBbmRTdGF0ZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY2FsZW5kYXJDb250ZXh0KSwgbmV3U3RhdGUpO1xuICAgICAgICBmb3IgKGxldCByZWR1Y2VyIG9mIG9wdGlvbnNEYXRhLnBsdWdpbkhvb2tzLnJlZHVjZXJzKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG5ld1N0YXRlLCByZWR1Y2VyKHN0YXRlLCBhY3Rpb24sIGNvbnRleHRBbmRTdGF0ZSkpOyAvLyBnaXZlIHRoZSBPTEQgc3RhdGUsIGZvciBvbGQgdmFsdWVcbiAgICAgICAgfVxuICAgICAgICBsZXQgd2FzTG9hZGluZyA9IGNvbXB1dGVJc0xvYWRpbmcoc3RhdGUsIGNhbGVuZGFyQ29udGV4dCk7XG4gICAgICAgIGxldCBpc0xvYWRpbmcgPSBjb21wdXRlSXNMb2FkaW5nKG5ld1N0YXRlLCBjYWxlbmRhckNvbnRleHQpO1xuICAgICAgICAvLyBUT0RPOiB1c2UgcHJvcFNldEhhbmRsZXJzIGluIHBsdWdpbiBzeXN0ZW1cbiAgICAgICAgaWYgKCF3YXNMb2FkaW5nICYmIGlzTG9hZGluZykge1xuICAgICAgICAgICAgZW1pdHRlci50cmlnZ2VyKCdsb2FkaW5nJywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAod2FzTG9hZGluZyAmJiAhaXNMb2FkaW5nKSB7XG4gICAgICAgICAgICBlbWl0dGVyLnRyaWdnZXIoJ2xvYWRpbmcnLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICBpZiAocHJvcHMub25BY3Rpb24pIHtcbiAgICAgICAgICAgIHByb3BzLm9uQWN0aW9uKGFjdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlRGF0YSgpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIHN0YXRlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgb2xkRGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgbGV0IG9wdGlvbnNEYXRhID0gdGhpcy5jb21wdXRlT3B0aW9uc0RhdGEocHJvcHMub3B0aW9uT3ZlcnJpZGVzLCBzdGF0ZS5keW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBwcm9wcy5jYWxlbmRhckFwaSk7XG4gICAgICAgIGxldCBjdXJyZW50Vmlld0RhdGEgPSB0aGlzLmNvbXB1dGVDdXJyZW50Vmlld0RhdGEoc3RhdGUuY3VycmVudFZpZXdUeXBlLCBvcHRpb25zRGF0YSwgcHJvcHMub3B0aW9uT3ZlcnJpZGVzLCBzdGF0ZS5keW5hbWljT3B0aW9uT3ZlcnJpZGVzKTtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmRhdGEgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IHZpZXdUaXRsZTogdGhpcy5idWlsZFRpdGxlKHN0YXRlLmRhdGVQcm9maWxlLCBjdXJyZW50Vmlld0RhdGEub3B0aW9ucywgb3B0aW9uc0RhdGEuZGF0ZUVudiksIGNhbGVuZGFyQXBpOiBwcm9wcy5jYWxlbmRhckFwaSwgZGlzcGF0Y2g6IHRoaXMuZGlzcGF0Y2gsIGVtaXR0ZXI6IHRoaXMuZW1pdHRlciwgZ2V0Q3VycmVudERhdGE6IHRoaXMuZ2V0Q3VycmVudERhdGEgfSwgb3B0aW9uc0RhdGEpLCBjdXJyZW50Vmlld0RhdGEpLCBzdGF0ZSk7XG4gICAgICAgIGxldCBjaGFuZ2VIYW5kbGVycyA9IG9wdGlvbnNEYXRhLnBsdWdpbkhvb2tzLm9wdGlvbkNoYW5nZUhhbmRsZXJzO1xuICAgICAgICBsZXQgb2xkQ2FsZW5kYXJPcHRpb25zID0gb2xkRGF0YSAmJiBvbGREYXRhLmNhbGVuZGFyT3B0aW9ucztcbiAgICAgICAgbGV0IG5ld0NhbGVuZGFyT3B0aW9ucyA9IG9wdGlvbnNEYXRhLmNhbGVuZGFyT3B0aW9ucztcbiAgICAgICAgaWYgKG9sZENhbGVuZGFyT3B0aW9ucyAmJiBvbGRDYWxlbmRhck9wdGlvbnMgIT09IG5ld0NhbGVuZGFyT3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKG9sZENhbGVuZGFyT3B0aW9ucy50aW1lWm9uZSAhPT0gbmV3Q2FsZW5kYXJPcHRpb25zLnRpbWVab25lKSB7XG4gICAgICAgICAgICAgICAgLy8gaGFja1xuICAgICAgICAgICAgICAgIHN0YXRlLmV2ZW50U291cmNlcyA9IGRhdGEuZXZlbnRTb3VyY2VzID0gcmVkdWNlRXZlbnRTb3VyY2VzTmV3VGltZVpvbmUoZGF0YS5ldmVudFNvdXJjZXMsIHN0YXRlLmRhdGVQcm9maWxlLCBkYXRhKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5ldmVudFN0b3JlID0gZGF0YS5ldmVudFN0b3JlID0gcmV6b25lRXZlbnRTdG9yZURhdGVzKGRhdGEuZXZlbnRTdG9yZSwgb2xkRGF0YS5kYXRlRW52LCBkYXRhLmRhdGVFbnYpO1xuICAgICAgICAgICAgICAgIHN0YXRlLnJlbmRlcmFibGVFdmVudFN0b3JlID0gZGF0YS5yZW5kZXJhYmxlRXZlbnRTdG9yZSA9IHJlem9uZUV2ZW50U3RvcmVEYXRlcyhkYXRhLnJlbmRlcmFibGVFdmVudFN0b3JlLCBvbGREYXRhLmRhdGVFbnYsIGRhdGEuZGF0ZUVudik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBvcHRpb25OYW1lIGluIGNoYW5nZUhhbmRsZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uc0ZvckhhbmRsaW5nLmluZGV4T2Yob3B0aW9uTmFtZSkgIT09IC0xIHx8XG4gICAgICAgICAgICAgICAgICAgIG9sZENhbGVuZGFyT3B0aW9uc1tvcHRpb25OYW1lXSAhPT0gbmV3Q2FsZW5kYXJPcHRpb25zW29wdGlvbk5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUhhbmRsZXJzW29wdGlvbk5hbWVdKG5ld0NhbGVuZGFyT3B0aW9uc1tvcHRpb25OYW1lXSwgZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9uc0ZvckhhbmRsaW5nID0gW107XG4gICAgICAgIGlmIChwcm9wcy5vbkRhdGEpIHtcbiAgICAgICAgICAgIHByb3BzLm9uRGF0YShkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wdXRlT3B0aW9uc0RhdGEob3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBjYWxlbmRhckFwaSkge1xuICAgICAgICAvLyBUT0RPOiBibGFja2xpc3Qgb3B0aW9ucyB0aGF0IGFyZSBoYW5kbGVkIGJ5IG9wdGlvbkNoYW5nZUhhbmRsZXJzXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zRm9yUmVmaW5pbmcubGVuZ3RoICYmXG4gICAgICAgICAgICBvcHRpb25PdmVycmlkZXMgPT09IHRoaXMuc3RhYmxlT3B0aW9uT3ZlcnJpZGVzICYmXG4gICAgICAgICAgICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzID09PSB0aGlzLnN0YWJsZUR5bmFtaWNPcHRpb25PdmVycmlkZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YWJsZUNhbGVuZGFyT3B0aW9uc0RhdGE7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgcmVmaW5lZE9wdGlvbnMsIHBsdWdpbkhvb2tzLCBsb2NhbGVEZWZhdWx0cywgYXZhaWxhYmxlTG9jYWxlRGF0YSwgZXh0cmEsIH0gPSB0aGlzLnByb2Nlc3NSYXdDYWxlbmRhck9wdGlvbnMob3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKTtcbiAgICAgICAgd2FyblVua25vd25PcHRpb25zKGV4dHJhKTtcbiAgICAgICAgbGV0IGRhdGVFbnYgPSB0aGlzLmJ1aWxkRGF0ZUVudihyZWZpbmVkT3B0aW9ucy50aW1lWm9uZSwgcmVmaW5lZE9wdGlvbnMubG9jYWxlLCByZWZpbmVkT3B0aW9ucy53ZWVrTnVtYmVyQ2FsY3VsYXRpb24sIHJlZmluZWRPcHRpb25zLmZpcnN0RGF5LCByZWZpbmVkT3B0aW9ucy53ZWVrVGV4dCwgcGx1Z2luSG9va3MsIGF2YWlsYWJsZUxvY2FsZURhdGEsIHJlZmluZWRPcHRpb25zLmRlZmF1bHRSYW5nZVNlcGFyYXRvcik7XG4gICAgICAgIGxldCB2aWV3U3BlY3MgPSB0aGlzLmJ1aWxkVmlld1NwZWNzKHBsdWdpbkhvb2tzLnZpZXdzLCB0aGlzLnN0YWJsZU9wdGlvbk92ZXJyaWRlcywgdGhpcy5zdGFibGVEeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBsb2NhbGVEZWZhdWx0cyk7XG4gICAgICAgIGxldCB0aGVtZSA9IHRoaXMuYnVpbGRUaGVtZShyZWZpbmVkT3B0aW9ucywgcGx1Z2luSG9va3MpO1xuICAgICAgICBsZXQgdG9vbGJhckNvbmZpZyA9IHRoaXMucGFyc2VUb29sYmFycyhyZWZpbmVkT3B0aW9ucywgdGhpcy5zdGFibGVPcHRpb25PdmVycmlkZXMsIHRoZW1lLCB2aWV3U3BlY3MsIGNhbGVuZGFyQXBpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhYmxlQ2FsZW5kYXJPcHRpb25zRGF0YSA9IHtcbiAgICAgICAgICAgIGNhbGVuZGFyT3B0aW9uczogcmVmaW5lZE9wdGlvbnMsXG4gICAgICAgICAgICBwbHVnaW5Ib29rcyxcbiAgICAgICAgICAgIGRhdGVFbnYsXG4gICAgICAgICAgICB2aWV3U3BlY3MsXG4gICAgICAgICAgICB0aGVtZSxcbiAgICAgICAgICAgIHRvb2xiYXJDb25maWcsXG4gICAgICAgICAgICBsb2NhbGVEZWZhdWx0cyxcbiAgICAgICAgICAgIGF2YWlsYWJsZVJhd0xvY2FsZXM6IGF2YWlsYWJsZUxvY2FsZURhdGEubWFwLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBhbHdheXMgY2FsbGVkIGZyb20gYmVoaW5kIGEgbWVtb2l6ZXJcbiAgICBwcm9jZXNzUmF3Q2FsZW5kYXJPcHRpb25zKG9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcykge1xuICAgICAgICBsZXQgeyBsb2NhbGVzLCBsb2NhbGUgfSA9IG1lcmdlUmF3T3B0aW9ucyhbXG4gICAgICAgICAgICBCQVNFX09QVElPTl9ERUZBVUxUUyxcbiAgICAgICAgICAgIG9wdGlvbk92ZXJyaWRlcyxcbiAgICAgICAgICAgIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsXG4gICAgICAgIF0pO1xuICAgICAgICBsZXQgYXZhaWxhYmxlTG9jYWxlRGF0YSA9IHRoaXMub3JnYW5pemVSYXdMb2NhbGVzKGxvY2FsZXMpO1xuICAgICAgICBsZXQgYXZhaWxhYmxlUmF3TG9jYWxlcyA9IGF2YWlsYWJsZUxvY2FsZURhdGEubWFwO1xuICAgICAgICBsZXQgbG9jYWxlRGVmYXVsdHMgPSB0aGlzLmJ1aWxkTG9jYWxlKGxvY2FsZSB8fCBhdmFpbGFibGVMb2NhbGVEYXRhLmRlZmF1bHRDb2RlLCBhdmFpbGFibGVSYXdMb2NhbGVzKS5vcHRpb25zO1xuICAgICAgICBsZXQgcGx1Z2luSG9va3MgPSB0aGlzLmJ1aWxkUGx1Z2luSG9va3Mob3B0aW9uT3ZlcnJpZGVzLnBsdWdpbnMgfHwgW10sIGdsb2JhbFBsdWdpbnMpO1xuICAgICAgICBsZXQgcmVmaW5lcnMgPSB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgQkFTRV9PUFRJT05fUkVGSU5FUlMpLCBDQUxFTkRBUl9MSVNURU5FUl9SRUZJTkVSUyksIENBTEVOREFSX09QVElPTl9SRUZJTkVSUyksIHBsdWdpbkhvb2tzLmxpc3RlbmVyUmVmaW5lcnMpLCBwbHVnaW5Ib29rcy5vcHRpb25SZWZpbmVycyk7XG4gICAgICAgIGxldCBleHRyYSA9IHt9O1xuICAgICAgICBsZXQgcmF3ID0gbWVyZ2VSYXdPcHRpb25zKFtcbiAgICAgICAgICAgIEJBU0VfT1BUSU9OX0RFRkFVTFRTLFxuICAgICAgICAgICAgbG9jYWxlRGVmYXVsdHMsXG4gICAgICAgICAgICBvcHRpb25PdmVycmlkZXMsXG4gICAgICAgICAgICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICBdKTtcbiAgICAgICAgbGV0IHJlZmluZWQgPSB7fTtcbiAgICAgICAgbGV0IGN1cnJlbnRSYXcgPSB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dDtcbiAgICAgICAgbGV0IGN1cnJlbnRSZWZpbmVkID0gdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lZDtcbiAgICAgICAgbGV0IGFueUNoYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgb3B0aW9uTmFtZSBpbiByYXcpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNGb3JSZWZpbmluZy5pbmRleE9mKG9wdGlvbk5hbWUpID09PSAtMSAmJiAocmF3W29wdGlvbk5hbWVdID09PSBjdXJyZW50UmF3W29wdGlvbk5hbWVdIHx8IChDT01QTEVYX09QVElPTl9DT01QQVJBVE9SU1tvcHRpb25OYW1lXSAmJlxuICAgICAgICAgICAgICAgIChvcHRpb25OYW1lIGluIGN1cnJlbnRSYXcpICYmXG4gICAgICAgICAgICAgICAgQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlNbb3B0aW9uTmFtZV0oY3VycmVudFJhd1tvcHRpb25OYW1lXSwgcmF3W29wdGlvbk5hbWVdKSkpKSB7XG4gICAgICAgICAgICAgICAgcmVmaW5lZFtvcHRpb25OYW1lXSA9IGN1cnJlbnRSZWZpbmVkW29wdGlvbk5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVmaW5lcnNbb3B0aW9uTmFtZV0pIHtcbiAgICAgICAgICAgICAgICByZWZpbmVkW29wdGlvbk5hbWVdID0gcmVmaW5lcnNbb3B0aW9uTmFtZV0ocmF3W29wdGlvbk5hbWVdKTtcbiAgICAgICAgICAgICAgICBhbnlDaGFuZ2VzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4dHJhW29wdGlvbk5hbWVdID0gY3VycmVudFJhd1tvcHRpb25OYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYW55Q2hhbmdlcykge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXQgPSByYXc7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVkID0gcmVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuc3RhYmxlT3B0aW9uT3ZlcnJpZGVzID0gb3B0aW9uT3ZlcnJpZGVzO1xuICAgICAgICAgICAgdGhpcy5zdGFibGVEeW5hbWljT3B0aW9uT3ZlcnJpZGVzID0gZHluYW1pY09wdGlvbk92ZXJyaWRlcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnNGb3JIYW5kbGluZy5wdXNoKC4uLnRoaXMub3B0aW9uc0ZvclJlZmluaW5nKTtcbiAgICAgICAgdGhpcy5vcHRpb25zRm9yUmVmaW5pbmcgPSBbXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhd09wdGlvbnM6IHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc0lucHV0LFxuICAgICAgICAgICAgcmVmaW5lZE9wdGlvbnM6IHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZWQsXG4gICAgICAgICAgICBwbHVnaW5Ib29rcyxcbiAgICAgICAgICAgIGF2YWlsYWJsZUxvY2FsZURhdGEsXG4gICAgICAgICAgICBsb2NhbGVEZWZhdWx0cyxcbiAgICAgICAgICAgIGV4dHJhLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfY29tcHV0ZUN1cnJlbnRWaWV3RGF0YSh2aWV3VHlwZSwgb3B0aW9uc0RhdGEsIG9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcykge1xuICAgICAgICBsZXQgdmlld1NwZWMgPSBvcHRpb25zRGF0YS52aWV3U3BlY3Nbdmlld1R5cGVdO1xuICAgICAgICBpZiAoIXZpZXdTcGVjKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHZpZXdUeXBlIFwiJHt2aWV3VHlwZX1cIiBpcyBub3QgYXZhaWxhYmxlLiBQbGVhc2UgbWFrZSBzdXJlIHlvdSd2ZSBsb2FkZWQgYWxsIG5lY2Nlc3NhcnkgcGx1Z2luc2ApO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IHJlZmluZWRPcHRpb25zLCBleHRyYSB9ID0gdGhpcy5wcm9jZXNzUmF3Vmlld09wdGlvbnModmlld1NwZWMsIG9wdGlvbnNEYXRhLnBsdWdpbkhvb2tzLCBvcHRpb25zRGF0YS5sb2NhbGVEZWZhdWx0cywgb3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKTtcbiAgICAgICAgd2FyblVua25vd25PcHRpb25zKGV4dHJhKTtcbiAgICAgICAgbGV0IGRhdGVQcm9maWxlR2VuZXJhdG9yID0gdGhpcy5idWlsZERhdGVQcm9maWxlR2VuZXJhdG9yKHtcbiAgICAgICAgICAgIGRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3M6IHZpZXdTcGVjLm9wdGlvbkRlZmF1bHRzLmRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3MsXG4gICAgICAgICAgICBkdXJhdGlvbjogdmlld1NwZWMuZHVyYXRpb24sXG4gICAgICAgICAgICBkdXJhdGlvblVuaXQ6IHZpZXdTcGVjLmR1cmF0aW9uVW5pdCxcbiAgICAgICAgICAgIHVzZXNNaW5NYXhUaW1lOiB2aWV3U3BlYy5vcHRpb25EZWZhdWx0cy51c2VzTWluTWF4VGltZSxcbiAgICAgICAgICAgIGRhdGVFbnY6IG9wdGlvbnNEYXRhLmRhdGVFbnYsXG4gICAgICAgICAgICBjYWxlbmRhckFwaTogdGhpcy5wcm9wcy5jYWxlbmRhckFwaSxcbiAgICAgICAgICAgIHNsb3RNaW5UaW1lOiByZWZpbmVkT3B0aW9ucy5zbG90TWluVGltZSxcbiAgICAgICAgICAgIHNsb3RNYXhUaW1lOiByZWZpbmVkT3B0aW9ucy5zbG90TWF4VGltZSxcbiAgICAgICAgICAgIHNob3dOb25DdXJyZW50RGF0ZXM6IHJlZmluZWRPcHRpb25zLnNob3dOb25DdXJyZW50RGF0ZXMsXG4gICAgICAgICAgICBkYXlDb3VudDogcmVmaW5lZE9wdGlvbnMuZGF5Q291bnQsXG4gICAgICAgICAgICBkYXRlQWxpZ25tZW50OiByZWZpbmVkT3B0aW9ucy5kYXRlQWxpZ25tZW50LFxuICAgICAgICAgICAgZGF0ZUluY3JlbWVudDogcmVmaW5lZE9wdGlvbnMuZGF0ZUluY3JlbWVudCxcbiAgICAgICAgICAgIGhpZGRlbkRheXM6IHJlZmluZWRPcHRpb25zLmhpZGRlbkRheXMsXG4gICAgICAgICAgICB3ZWVrZW5kczogcmVmaW5lZE9wdGlvbnMud2Vla2VuZHMsXG4gICAgICAgICAgICBub3dJbnB1dDogcmVmaW5lZE9wdGlvbnMubm93LFxuICAgICAgICAgICAgdmFsaWRSYW5nZUlucHV0OiByZWZpbmVkT3B0aW9ucy52YWxpZFJhbmdlLFxuICAgICAgICAgICAgdmlzaWJsZVJhbmdlSW5wdXQ6IHJlZmluZWRPcHRpb25zLnZpc2libGVSYW5nZSxcbiAgICAgICAgICAgIGZpeGVkV2Vla0NvdW50OiByZWZpbmVkT3B0aW9ucy5maXhlZFdlZWtDb3VudCxcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCB2aWV3QXBpID0gdGhpcy5idWlsZFZpZXdBcGkodmlld1R5cGUsIHRoaXMuZ2V0Q3VycmVudERhdGEsIG9wdGlvbnNEYXRhLmRhdGVFbnYpO1xuICAgICAgICByZXR1cm4geyB2aWV3U3BlYywgb3B0aW9uczogcmVmaW5lZE9wdGlvbnMsIGRhdGVQcm9maWxlR2VuZXJhdG9yLCB2aWV3QXBpIH07XG4gICAgfVxuICAgIHByb2Nlc3NSYXdWaWV3T3B0aW9ucyh2aWV3U3BlYywgcGx1Z2luSG9va3MsIGxvY2FsZURlZmF1bHRzLCBvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMpIHtcbiAgICAgICAgbGV0IHJhdyA9IG1lcmdlUmF3T3B0aW9ucyhbXG4gICAgICAgICAgICBCQVNFX09QVElPTl9ERUZBVUxUUyxcbiAgICAgICAgICAgIHZpZXdTcGVjLm9wdGlvbkRlZmF1bHRzLFxuICAgICAgICAgICAgbG9jYWxlRGVmYXVsdHMsXG4gICAgICAgICAgICBvcHRpb25PdmVycmlkZXMsXG4gICAgICAgICAgICB2aWV3U3BlYy5vcHRpb25PdmVycmlkZXMsXG4gICAgICAgICAgICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICBdKTtcbiAgICAgICAgbGV0IHJlZmluZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIEJBU0VfT1BUSU9OX1JFRklORVJTKSwgQ0FMRU5EQVJfTElTVEVORVJfUkVGSU5FUlMpLCBDQUxFTkRBUl9PUFRJT05fUkVGSU5FUlMpLCBWSUVXX09QVElPTl9SRUZJTkVSUyksIHBsdWdpbkhvb2tzLmxpc3RlbmVyUmVmaW5lcnMpLCBwbHVnaW5Ib29rcy5vcHRpb25SZWZpbmVycyk7XG4gICAgICAgIGxldCByZWZpbmVkID0ge307XG4gICAgICAgIGxldCBjdXJyZW50UmF3ID0gdGhpcy5jdXJyZW50Vmlld09wdGlvbnNJbnB1dDtcbiAgICAgICAgbGV0IGN1cnJlbnRSZWZpbmVkID0gdGhpcy5jdXJyZW50Vmlld09wdGlvbnNSZWZpbmVkO1xuICAgICAgICBsZXQgYW55Q2hhbmdlcyA9IGZhbHNlO1xuICAgICAgICBsZXQgZXh0cmEgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgb3B0aW9uTmFtZSBpbiByYXcpIHtcbiAgICAgICAgICAgIGlmIChyYXdbb3B0aW9uTmFtZV0gPT09IGN1cnJlbnRSYXdbb3B0aW9uTmFtZV0gfHxcbiAgICAgICAgICAgICAgICAoQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlNbb3B0aW9uTmFtZV0gJiZcbiAgICAgICAgICAgICAgICAgICAgQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlNbb3B0aW9uTmFtZV0ocmF3W29wdGlvbk5hbWVdLCBjdXJyZW50UmF3W29wdGlvbk5hbWVdKSkpIHtcbiAgICAgICAgICAgICAgICByZWZpbmVkW29wdGlvbk5hbWVdID0gY3VycmVudFJlZmluZWRbb3B0aW9uTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocmF3W29wdGlvbk5hbWVdID09PSB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dFtvcHRpb25OYW1lXSB8fFxuICAgICAgICAgICAgICAgICAgICAoQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlNbb3B0aW9uTmFtZV0gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIENPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTW29wdGlvbk5hbWVdKHJhd1tvcHRpb25OYW1lXSwgdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXRbb3B0aW9uTmFtZV0pKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9uTmFtZSBpbiB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVkKSB7IC8vIG1pZ2h0IGJlIGFuIFwiZXh0cmFcIiBwcm9wXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZpbmVkW29wdGlvbk5hbWVdID0gdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lZFtvcHRpb25OYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWZpbmVyc1tvcHRpb25OYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICByZWZpbmVkW29wdGlvbk5hbWVdID0gcmVmaW5lcnNbb3B0aW9uTmFtZV0ocmF3W29wdGlvbk5hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhW29wdGlvbk5hbWVdID0gcmF3W29wdGlvbk5hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhbnlDaGFuZ2VzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYW55Q2hhbmdlcykge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Vmlld09wdGlvbnNJbnB1dCA9IHJhdztcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFZpZXdPcHRpb25zUmVmaW5lZCA9IHJlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhd09wdGlvbnM6IHRoaXMuY3VycmVudFZpZXdPcHRpb25zSW5wdXQsXG4gICAgICAgICAgICByZWZpbmVkT3B0aW9uczogdGhpcy5jdXJyZW50Vmlld09wdGlvbnNSZWZpbmVkLFxuICAgICAgICAgICAgZXh0cmEsXG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gYnVpbGREYXRlRW52JDEodGltZVpvbmUsIGV4cGxpY2l0TG9jYWxlLCB3ZWVrTnVtYmVyQ2FsY3VsYXRpb24sIGZpcnN0RGF5LCB3ZWVrVGV4dCwgcGx1Z2luSG9va3MsIGF2YWlsYWJsZUxvY2FsZURhdGEsIGRlZmF1bHRTZXBhcmF0b3IpIHtcbiAgICBsZXQgbG9jYWxlID0gYnVpbGRMb2NhbGUoZXhwbGljaXRMb2NhbGUgfHwgYXZhaWxhYmxlTG9jYWxlRGF0YS5kZWZhdWx0Q29kZSwgYXZhaWxhYmxlTG9jYWxlRGF0YS5tYXApO1xuICAgIHJldHVybiBuZXcgRGF0ZUVudih7XG4gICAgICAgIGNhbGVuZGFyU3lzdGVtOiAnZ3JlZ29yeScsXG4gICAgICAgIHRpbWVab25lLFxuICAgICAgICBuYW1lZFRpbWVab25lSW1wbDogcGx1Z2luSG9va3MubmFtZWRUaW1lWm9uZWRJbXBsLFxuICAgICAgICBsb2NhbGUsXG4gICAgICAgIHdlZWtOdW1iZXJDYWxjdWxhdGlvbixcbiAgICAgICAgZmlyc3REYXksXG4gICAgICAgIHdlZWtUZXh0LFxuICAgICAgICBjbWRGb3JtYXR0ZXI6IHBsdWdpbkhvb2tzLmNtZEZvcm1hdHRlcixcbiAgICAgICAgZGVmYXVsdFNlcGFyYXRvcixcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGJ1aWxkVGhlbWUob3B0aW9ucywgcGx1Z2luSG9va3MpIHtcbiAgICBsZXQgVGhlbWVDbGFzcyA9IHBsdWdpbkhvb2tzLnRoZW1lQ2xhc3Nlc1tvcHRpb25zLnRoZW1lU3lzdGVtXSB8fCBTdGFuZGFyZFRoZW1lO1xuICAgIHJldHVybiBuZXcgVGhlbWVDbGFzcyhvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRGF0ZVByb2ZpbGVHZW5lcmF0b3IocHJvcHMpIHtcbiAgICBsZXQgRGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyA9IHByb3BzLmRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3MgfHwgRGF0ZVByb2ZpbGVHZW5lcmF0b3I7XG4gICAgcmV0dXJuIG5ldyBEYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzKHByb3BzKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkVmlld0FwaSh0eXBlLCBnZXRDdXJyZW50RGF0YSwgZGF0ZUVudikge1xuICAgIHJldHVybiBuZXcgVmlld0ltcGwodHlwZSwgZ2V0Q3VycmVudERhdGEsIGRhdGVFbnYpO1xufVxuZnVuY3Rpb24gYnVpbGRFdmVudFVpQnlTb3VyY2UoZXZlbnRTb3VyY2VzKSB7XG4gICAgcmV0dXJuIG1hcEhhc2goZXZlbnRTb3VyY2VzLCAoZXZlbnRTb3VyY2UpID0+IGV2ZW50U291cmNlLnVpKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRXZlbnRVaUJhc2VzKGV2ZW50RGVmcywgZXZlbnRVaVNpbmdsZUJhc2UsIGV2ZW50VWlCeVNvdXJjZSkge1xuICAgIGxldCBldmVudFVpQmFzZXMgPSB7ICcnOiBldmVudFVpU2luZ2xlQmFzZSB9O1xuICAgIGZvciAobGV0IGRlZklkIGluIGV2ZW50RGVmcykge1xuICAgICAgICBsZXQgZGVmID0gZXZlbnREZWZzW2RlZklkXTtcbiAgICAgICAgaWYgKGRlZi5zb3VyY2VJZCAmJiBldmVudFVpQnlTb3VyY2VbZGVmLnNvdXJjZUlkXSkge1xuICAgICAgICAgICAgZXZlbnRVaUJhc2VzW2RlZklkXSA9IGV2ZW50VWlCeVNvdXJjZVtkZWYuc291cmNlSWRdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBldmVudFVpQmFzZXM7XG59XG5mdW5jdGlvbiBidWlsZFZpZXdVaVByb3BzKGNhbGVuZGFyQ29udGV4dCkge1xuICAgIGxldCB7IG9wdGlvbnMgfSA9IGNhbGVuZGFyQ29udGV4dDtcbiAgICByZXR1cm4ge1xuICAgICAgICBldmVudFVpU2luZ2xlQmFzZTogY3JlYXRlRXZlbnRVaSh7XG4gICAgICAgICAgICBkaXNwbGF5OiBvcHRpb25zLmV2ZW50RGlzcGxheSxcbiAgICAgICAgICAgIGVkaXRhYmxlOiBvcHRpb25zLmVkaXRhYmxlLFxuICAgICAgICAgICAgc3RhcnRFZGl0YWJsZTogb3B0aW9ucy5ldmVudFN0YXJ0RWRpdGFibGUsXG4gICAgICAgICAgICBkdXJhdGlvbkVkaXRhYmxlOiBvcHRpb25zLmV2ZW50RHVyYXRpb25FZGl0YWJsZSxcbiAgICAgICAgICAgIGNvbnN0cmFpbnQ6IG9wdGlvbnMuZXZlbnRDb25zdHJhaW50LFxuICAgICAgICAgICAgb3ZlcmxhcDogdHlwZW9mIG9wdGlvbnMuZXZlbnRPdmVybGFwID09PSAnYm9vbGVhbicgPyBvcHRpb25zLmV2ZW50T3ZlcmxhcCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGFsbG93OiBvcHRpb25zLmV2ZW50QWxsb3csXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuZXZlbnRCYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogb3B0aW9ucy5ldmVudEJvcmRlckNvbG9yLFxuICAgICAgICAgICAgdGV4dENvbG9yOiBvcHRpb25zLmV2ZW50VGV4dENvbG9yLFxuICAgICAgICAgICAgY29sb3I6IG9wdGlvbnMuZXZlbnRDb2xvcixcbiAgICAgICAgICAgIC8vIGNsYXNzTmFtZXM6IG9wdGlvbnMuZXZlbnRDbGFzc05hbWVzIC8vIHJlbmRlciBob29rIHdpbGwgaGFuZGxlIHRoaXNcbiAgICAgICAgfSwgY2FsZW5kYXJDb250ZXh0KSxcbiAgICAgICAgc2VsZWN0aW9uQ29uZmlnOiBjcmVhdGVFdmVudFVpKHtcbiAgICAgICAgICAgIGNvbnN0cmFpbnQ6IG9wdGlvbnMuc2VsZWN0Q29uc3RyYWludCxcbiAgICAgICAgICAgIG92ZXJsYXA6IHR5cGVvZiBvcHRpb25zLnNlbGVjdE92ZXJsYXAgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuc2VsZWN0T3ZlcmxhcCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGFsbG93OiBvcHRpb25zLnNlbGVjdEFsbG93LFxuICAgICAgICB9LCBjYWxlbmRhckNvbnRleHQpLFxuICAgIH07XG59XG5mdW5jdGlvbiBjb21wdXRlSXNMb2FkaW5nKHN0YXRlLCBjb250ZXh0KSB7XG4gICAgZm9yIChsZXQgaXNMb2FkaW5nRnVuYyBvZiBjb250ZXh0LnBsdWdpbkhvb2tzLmlzTG9hZGluZ0Z1bmNzKSB7XG4gICAgICAgIGlmIChpc0xvYWRpbmdGdW5jKHN0YXRlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gcGFyc2VDb250ZXh0QnVzaW5lc3NIb3VycyhjYWxlbmRhckNvbnRleHQpIHtcbiAgICByZXR1cm4gcGFyc2VCdXNpbmVzc0hvdXJzKGNhbGVuZGFyQ29udGV4dC5vcHRpb25zLmJ1c2luZXNzSG91cnMsIGNhbGVuZGFyQ29udGV4dCk7XG59XG5mdW5jdGlvbiB3YXJuVW5rbm93bk9wdGlvbnMob3B0aW9ucywgdmlld05hbWUpIHtcbiAgICBmb3IgKGxldCBvcHRpb25OYW1lIGluIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBVbmtub3duIG9wdGlvbiAnJHtvcHRpb25OYW1lfSdgICtcbiAgICAgICAgICAgICh2aWV3TmFtZSA/IGAgZm9yIHZpZXcgJyR7dmlld05hbWV9J2AgOiAnJykpO1xuICAgIH1cbn1cblxuY2xhc3MgVG9vbGJhclNlY3Rpb24gZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IHRoaXMucHJvcHMud2lkZ2V0R3JvdXBzLm1hcCgod2lkZ2V0R3JvdXApID0+IHRoaXMucmVuZGVyV2lkZ2V0R3JvdXAod2lkZ2V0R3JvdXApKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHsgY2xhc3NOYW1lOiAnZmMtdG9vbGJhci1jaHVuaycgfSwgLi4uY2hpbGRyZW4pO1xuICAgIH1cbiAgICByZW5kZXJXaWRnZXRHcm91cCh3aWRnZXRHcm91cCkge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgdGhlbWUgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gW107XG4gICAgICAgIGxldCBpc09ubHlCdXR0b25zID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgd2lkZ2V0IG9mIHdpZGdldEdyb3VwKSB7XG4gICAgICAgICAgICBsZXQgeyBidXR0b25OYW1lLCBidXR0b25DbGljaywgYnV0dG9uVGV4dCwgYnV0dG9uSWNvbiwgYnV0dG9uSGludCB9ID0gd2lkZ2V0O1xuICAgICAgICAgICAgaWYgKGJ1dHRvbk5hbWUgPT09ICd0aXRsZScpIHtcbiAgICAgICAgICAgICAgICBpc09ubHlCdXR0b25zID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChjcmVhdGVFbGVtZW50KFwiaDJcIiwgeyBjbGFzc05hbWU6IFwiZmMtdG9vbGJhci10aXRsZVwiLCBpZDogcHJvcHMudGl0bGVJZCB9LCBwcm9wcy50aXRsZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGlzUHJlc3NlZCA9IGJ1dHRvbk5hbWUgPT09IHByb3BzLmFjdGl2ZUJ1dHRvbjtcbiAgICAgICAgICAgICAgICBsZXQgaXNEaXNhYmxlZCA9ICghcHJvcHMuaXNUb2RheUVuYWJsZWQgJiYgYnV0dG9uTmFtZSA9PT0gJ3RvZGF5JykgfHxcbiAgICAgICAgICAgICAgICAgICAgKCFwcm9wcy5pc1ByZXZFbmFibGVkICYmIGJ1dHRvbk5hbWUgPT09ICdwcmV2JykgfHxcbiAgICAgICAgICAgICAgICAgICAgKCFwcm9wcy5pc05leHRFbmFibGVkICYmIGJ1dHRvbk5hbWUgPT09ICduZXh0Jyk7XG4gICAgICAgICAgICAgICAgbGV0IGJ1dHRvbkNsYXNzZXMgPSBbYGZjLSR7YnV0dG9uTmFtZX0tYnV0dG9uYCwgdGhlbWUuZ2V0Q2xhc3MoJ2J1dHRvbicpXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNQcmVzc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbkNsYXNzZXMucHVzaCh0aGVtZS5nZXRDbGFzcygnYnV0dG9uQWN0aXZlJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgeyB0eXBlOiBcImJ1dHRvblwiLCB0aXRsZTogdHlwZW9mIGJ1dHRvbkhpbnQgPT09ICdmdW5jdGlvbicgPyBidXR0b25IaW50KHByb3BzLm5hdlVuaXQpIDogYnV0dG9uSGludCwgZGlzYWJsZWQ6IGlzRGlzYWJsZWQsIFwiYXJpYS1wcmVzc2VkXCI6IGlzUHJlc3NlZCwgY2xhc3NOYW1lOiBidXR0b25DbGFzc2VzLmpvaW4oJyAnKSwgb25DbGljazogYnV0dG9uQ2xpY2sgfSwgYnV0dG9uVGV4dCB8fCAoYnV0dG9uSWNvbiA/IGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBidXR0b25JY29uLCByb2xlOiBcImltZ1wiIH0pIDogJycpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGxldCBncm91cENsYXNzTmFtZSA9IChpc09ubHlCdXR0b25zICYmIHRoZW1lLmdldENsYXNzKCdidXR0b25Hcm91cCcpKSB8fCAnJztcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCdkaXYnLCB7IGNsYXNzTmFtZTogZ3JvdXBDbGFzc05hbWUgfSwgLi4uY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZHJlblswXTtcbiAgICB9XG59XG5cbmNsYXNzIFRvb2xiYXIgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IG1vZGVsLCBleHRyYUNsYXNzTmFtZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IGZvcmNlTHRyID0gZmFsc2U7XG4gICAgICAgIGxldCBzdGFydENvbnRlbnQ7XG4gICAgICAgIGxldCBlbmRDb250ZW50O1xuICAgICAgICBsZXQgc2VjdGlvbldpZGdldHMgPSBtb2RlbC5zZWN0aW9uV2lkZ2V0cztcbiAgICAgICAgbGV0IGNlbnRlckNvbnRlbnQgPSBzZWN0aW9uV2lkZ2V0cy5jZW50ZXI7XG4gICAgICAgIGlmIChzZWN0aW9uV2lkZ2V0cy5sZWZ0KSB7XG4gICAgICAgICAgICBmb3JjZUx0ciA9IHRydWU7XG4gICAgICAgICAgICBzdGFydENvbnRlbnQgPSBzZWN0aW9uV2lkZ2V0cy5sZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnRDb250ZW50ID0gc2VjdGlvbldpZGdldHMuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlY3Rpb25XaWRnZXRzLnJpZ2h0KSB7XG4gICAgICAgICAgICBmb3JjZUx0ciA9IHRydWU7XG4gICAgICAgICAgICBlbmRDb250ZW50ID0gc2VjdGlvbldpZGdldHMucmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbmRDb250ZW50ID0gc2VjdGlvbldpZGdldHMuZW5kO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjbGFzc05hbWVzID0gW1xuICAgICAgICAgICAgZXh0cmFDbGFzc05hbWUgfHwgJycsXG4gICAgICAgICAgICAnZmMtdG9vbGJhcicsXG4gICAgICAgICAgICBmb3JjZUx0ciA/ICdmYy10b29sYmFyLWx0cicgOiAnJyxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmpvaW4oJyAnKSB9LFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJTZWN0aW9uKCdzdGFydCcsIHN0YXJ0Q29udGVudCB8fCBbXSksXG4gICAgICAgICAgICB0aGlzLnJlbmRlclNlY3Rpb24oJ2NlbnRlcicsIGNlbnRlckNvbnRlbnQgfHwgW10pLFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJTZWN0aW9uKCdlbmQnLCBlbmRDb250ZW50IHx8IFtdKSkpO1xuICAgIH1cbiAgICByZW5kZXJTZWN0aW9uKGtleSwgd2lkZ2V0R3JvdXBzKSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVG9vbGJhclNlY3Rpb24sIHsga2V5OiBrZXksIHdpZGdldEdyb3Vwczogd2lkZ2V0R3JvdXBzLCB0aXRsZTogcHJvcHMudGl0bGUsIG5hdlVuaXQ6IHByb3BzLm5hdlVuaXQsIGFjdGl2ZUJ1dHRvbjogcHJvcHMuYWN0aXZlQnV0dG9uLCBpc1RvZGF5RW5hYmxlZDogcHJvcHMuaXNUb2RheUVuYWJsZWQsIGlzUHJldkVuYWJsZWQ6IHByb3BzLmlzUHJldkVuYWJsZWQsIGlzTmV4dEVuYWJsZWQ6IHByb3BzLmlzTmV4dEVuYWJsZWQsIHRpdGxlSWQ6IHByb3BzLnRpdGxlSWQgfSkpO1xuICAgIH1cbn1cblxuY2xhc3MgVmlld0hhcm5lc3MgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGF2YWlsYWJsZVdpZHRoOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUVsID0gKGVsKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgICAgICBzZXRSZWYodGhpcy5wcm9wcy5lbFJlZiwgZWwpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVBdmFpbGFibGVXaWR0aCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVJlc2l6ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQXZhaWxhYmxlV2lkdGgoKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgc3RhdGUgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IGFzcGVjdFJhdGlvIH0gPSBwcm9wcztcbiAgICAgICAgbGV0IGNsYXNzTmFtZXMgPSBbXG4gICAgICAgICAgICAnZmMtdmlldy1oYXJuZXNzJyxcbiAgICAgICAgICAgIChhc3BlY3RSYXRpbyB8fCBwcm9wcy5saXF1aWQgfHwgcHJvcHMuaGVpZ2h0KVxuICAgICAgICAgICAgICAgID8gJ2ZjLXZpZXctaGFybmVzcy1hY3RpdmUnIC8vIGhhcm5lc3MgY29udHJvbHMgdGhlIGhlaWdodFxuICAgICAgICAgICAgICAgIDogJ2ZjLXZpZXctaGFybmVzcy1wYXNzaXZlJywgLy8gbGV0IHRoZSB2aWV3IGRvIHRoZSBoZWlnaHRcbiAgICAgICAgXTtcbiAgICAgICAgbGV0IGhlaWdodCA9ICcnO1xuICAgICAgICBsZXQgcGFkZGluZ0JvdHRvbSA9ICcnO1xuICAgICAgICBpZiAoYXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5hdmFpbGFibGVXaWR0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IHN0YXRlLmF2YWlsYWJsZVdpZHRoIC8gYXNwZWN0UmF0aW87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB3aGlsZSB3YWl0aW5nIHRvIGtub3cgYXZhaWxhYmxlV2lkdGgsIHdlIGNhbid0IHNldCBoZWlnaHQgdG8gKnplcm8qXG4gICAgICAgICAgICAgICAgLy8gYmVjYXVzZSB3aWxsIGNhdXNlIGxvdHMgb2YgdW5uZWNlc3Nhcnkgc2Nyb2xsYmFycyB3aXRoaW4gc2Nyb2xsZ3JpZC5cbiAgICAgICAgICAgICAgICAvLyBCRVRURVI6IGRvbid0IHN0YXJ0IHJlbmRlcmluZyBBTllUSElORyB5ZXQgdW50aWwgd2Uga25vdyBjb250YWluZXIgd2lkdGhcbiAgICAgICAgICAgICAgICAvLyBOT1RFOiB3aHkgbm90IGFsd2F5cyB1c2UgcGFkZGluZ0JvdHRvbT8gQ2F1c2VzIGhlaWdodCBvc2NpbGxhdGlvbiAoaXNzdWUgNTYwNilcbiAgICAgICAgICAgICAgICBwYWRkaW5nQm90dG9tID0gYCR7KDEgLyBhc3BlY3RSYXRpbykgKiAxMDB9JWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoZWlnaHQgPSBwcm9wcy5oZWlnaHQgfHwgJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgXCJhcmlhLWxhYmVsbGVkYnlcIjogcHJvcHMubGFiZWxlZEJ5SWQsIHJlZjogdGhpcy5oYW5kbGVFbCwgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmpvaW4oJyAnKSwgc3R5bGU6IHsgaGVpZ2h0LCBwYWRkaW5nQm90dG9tIH0gfSwgcHJvcHMuY2hpbGRyZW4pKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5hZGRSZXNpemVIYW5kbGVyKHRoaXMuaGFuZGxlUmVzaXplKTtcbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5yZW1vdmVSZXNpemVIYW5kbGVyKHRoaXMuaGFuZGxlUmVzaXplKTtcbiAgICB9XG4gICAgdXBkYXRlQXZhaWxhYmxlV2lkdGgoKSB7XG4gICAgICAgIGlmICh0aGlzLmVsICYmIC8vIG5lZWRlZC4gYnV0IHdoeT9cbiAgICAgICAgICAgIHRoaXMucHJvcHMuYXNwZWN0UmF0aW8gLy8gYXNwZWN0UmF0aW8gaXMgdGhlIG9ubHkgaGVpZ2h0IHNldHRpbmcgdGhhdCBuZWVkcyBhdmFpbGFibGVXaWR0aFxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBhdmFpbGFibGVXaWR0aDogdGhpcy5lbC5vZmZzZXRXaWR0aCB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLypcbkRldGVjdHMgd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gYW4gZXZlbnQgd2l0aGluIGEgRGF0ZUNvbXBvbmVudFxuKi9cbmNsYXNzIEV2ZW50Q2xpY2tpbmcgZXh0ZW5kcyBJbnRlcmFjdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICAgICAgc3VwZXIoc2V0dGluZ3MpO1xuICAgICAgICB0aGlzLmhhbmRsZVNlZ0NsaWNrID0gKGV2LCBzZWdFbCkgPT4ge1xuICAgICAgICAgICAgbGV0IHsgY29tcG9uZW50IH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IHsgY29udGV4dCB9ID0gY29tcG9uZW50O1xuICAgICAgICAgICAgbGV0IHNlZyA9IGdldEVsU2VnKHNlZ0VsKTtcbiAgICAgICAgICAgIGlmIChzZWcgJiYgLy8gbWlnaHQgYmUgdGhlIDxkaXY+IHN1cnJvdW5kaW5nIHRoZSBtb3JlIGxpbmtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuaXNWYWxpZFNlZ0Rvd25FbChldi50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgLy8gb3VyIHdheSB0byBzaW11bGF0ZSBhIGxpbmsgY2xpY2sgZm9yIGVsZW1lbnRzIHRoYXQgY2FuJ3QgYmUgPGE+IHRhZ3NcbiAgICAgICAgICAgICAgICAvLyBncmFiIGJlZm9yZSB0cmlnZ2VyIGZpcmVkIGluIGNhc2UgdHJpZ2dlciB0cmFzaGVzIERPTSB0aHJ1IHJlcmVuZGVyaW5nXG4gICAgICAgICAgICAgICAgbGV0IGhhc1VybENvbnRhaW5lciA9IGVsZW1lbnRDbG9zZXN0KGV2LnRhcmdldCwgJy5mYy1ldmVudC1mb3JjZWQtdXJsJyk7XG4gICAgICAgICAgICAgICAgbGV0IHVybCA9IGhhc1VybENvbnRhaW5lciA/IGhhc1VybENvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCdhW2hyZWZdJykuaHJlZiA6ICcnO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudENsaWNrJywge1xuICAgICAgICAgICAgICAgICAgICBlbDogc2VnRWwsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBuZXcgRXZlbnRJbXBsKGNvbXBvbmVudC5jb250ZXh0LCBzZWcuZXZlbnRSYW5nZS5kZWYsIHNlZy5ldmVudFJhbmdlLmluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICAgICAganNFdmVudDogZXYsXG4gICAgICAgICAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAodXJsICYmICFldi5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZXN0cm95ID0gbGlzdGVuQnlTZWxlY3RvcihzZXR0aW5ncy5lbCwgJ2NsaWNrJywgJy5mYy1ldmVudCcsIC8vIG9uIGJvdGggZmcgYW5kIGJnIGV2ZW50c1xuICAgICAgICB0aGlzLmhhbmRsZVNlZ0NsaWNrKTtcbiAgICB9XG59XG5cbi8qXG5UcmlnZ2VycyBldmVudHMgYW5kIGFkZHMvcmVtb3ZlcyBjb3JlIGNsYXNzTmFtZXMgd2hlbiB0aGUgdXNlcidzIHBvaW50ZXJcbmVudGVycy9sZWF2ZXMgZXZlbnQtZWxlbWVudHMgb2YgYSBjb21wb25lbnQuXG4qL1xuY2xhc3MgRXZlbnRIb3ZlcmluZyBleHRlbmRzIEludGVyYWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgICAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgICAgIC8vIGZvciBzaW11bGF0aW5nIGFuIGV2ZW50TW91c2VMZWF2ZSB3aGVuIHRoZSBldmVudCBlbCBpcyBkZXN0cm95ZWQgd2hpbGUgbW91c2UgaXMgb3ZlciBpdFxuICAgICAgICB0aGlzLmhhbmRsZUV2ZW50RWxSZW1vdmUgPSAoZWwpID0+IHtcbiAgICAgICAgICAgIGlmIChlbCA9PT0gdGhpcy5jdXJyZW50U2VnRWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVNlZ0xlYXZlKG51bGwsIHRoaXMuY3VycmVudFNlZ0VsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVTZWdFbnRlciA9IChldiwgc2VnRWwpID0+IHtcbiAgICAgICAgICAgIGlmIChnZXRFbFNlZyhzZWdFbCkpIHsgLy8gVE9ETzogYmV0dGVyIHdheSB0byBtYWtlIHN1cmUgbm90IGhvdmVyaW5nIG92ZXIgbW9yZSsgbGluayBvciBpdHMgd3JhcHBlclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNlZ0VsID0gc2VnRWw7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQoJ2V2ZW50TW91c2VFbnRlcicsIGV2LCBzZWdFbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlU2VnTGVhdmUgPSAoZXYsIHNlZ0VsKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50U2VnRWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTZWdFbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQoJ2V2ZW50TW91c2VMZWF2ZScsIGV2LCBzZWdFbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVtb3ZlSG92ZXJMaXN0ZW5lcnMgPSBsaXN0ZW5Ub0hvdmVyQnlTZWxlY3RvcihzZXR0aW5ncy5lbCwgJy5mYy1ldmVudCcsIC8vIG9uIGJvdGggZmcgYW5kIGJnIGV2ZW50c1xuICAgICAgICB0aGlzLmhhbmRsZVNlZ0VudGVyLCB0aGlzLmhhbmRsZVNlZ0xlYXZlKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVIb3Zlckxpc3RlbmVycygpO1xuICAgIH1cbiAgICB0cmlnZ2VyRXZlbnQocHVibGljRXZOYW1lLCBldiwgc2VnRWwpIHtcbiAgICAgICAgbGV0IHsgY29tcG9uZW50IH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBjb250ZXh0IH0gPSBjb21wb25lbnQ7XG4gICAgICAgIGxldCBzZWcgPSBnZXRFbFNlZyhzZWdFbCk7XG4gICAgICAgIGlmICghZXYgfHwgY29tcG9uZW50LmlzVmFsaWRTZWdEb3duRWwoZXYudGFyZ2V0KSkge1xuICAgICAgICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIocHVibGljRXZOYW1lLCB7XG4gICAgICAgICAgICAgICAgZWw6IHNlZ0VsLFxuICAgICAgICAgICAgICAgIGV2ZW50OiBuZXcgRXZlbnRJbXBsKGNvbnRleHQsIHNlZy5ldmVudFJhbmdlLmRlZiwgc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgIGpzRXZlbnQ6IGV2LFxuICAgICAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBDYWxlbmRhckNvbnRlbnQgZXh0ZW5kcyBQdXJlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5idWlsZFZpZXdDb250ZXh0ID0gbWVtb2l6ZShidWlsZFZpZXdDb250ZXh0KTtcbiAgICAgICAgdGhpcy5idWlsZFZpZXdQcm9wVHJhbnNmb3JtZXJzID0gbWVtb2l6ZShidWlsZFZpZXdQcm9wVHJhbnNmb3JtZXJzKTtcbiAgICAgICAgdGhpcy5idWlsZFRvb2xiYXJQcm9wcyA9IG1lbW9pemUoYnVpbGRUb29sYmFyUHJvcHMpO1xuICAgICAgICB0aGlzLmhlYWRlclJlZiA9IGNyZWF0ZVJlZigpO1xuICAgICAgICB0aGlzLmZvb3RlclJlZiA9IGNyZWF0ZVJlZigpO1xuICAgICAgICB0aGlzLmludGVyYWN0aW9uc1N0b3JlID0ge307XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgdmlld0xhYmVsSWQ6IGdldFVuaXF1ZURvbUlkKCksXG4gICAgICAgIH07XG4gICAgICAgIC8vIENvbXBvbmVudCBSZWdpc3RyYXRpb25cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgdGhpcy5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50ID0gKGNvbXBvbmVudCwgc2V0dGluZ3NJbnB1dCkgPT4ge1xuICAgICAgICAgICAgbGV0IHNldHRpbmdzID0gcGFyc2VJbnRlcmFjdGlvblNldHRpbmdzKGNvbXBvbmVudCwgc2V0dGluZ3NJbnB1dCk7XG4gICAgICAgICAgICBsZXQgREVGQVVMVF9JTlRFUkFDVElPTlMgPSBbXG4gICAgICAgICAgICAgICAgRXZlbnRDbGlja2luZyxcbiAgICAgICAgICAgICAgICBFdmVudEhvdmVyaW5nLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGxldCBpbnRlcmFjdGlvbkNsYXNzZXMgPSBERUZBVUxUX0lOVEVSQUNUSU9OUy5jb25jYXQodGhpcy5wcm9wcy5wbHVnaW5Ib29rcy5jb21wb25lbnRJbnRlcmFjdGlvbnMpO1xuICAgICAgICAgICAgbGV0IGludGVyYWN0aW9ucyA9IGludGVyYWN0aW9uQ2xhc3Nlcy5tYXAoKFRoZUludGVyYWN0aW9uQ2xhc3MpID0+IG5ldyBUaGVJbnRlcmFjdGlvbkNsYXNzKHNldHRpbmdzKSk7XG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uc1N0b3JlW2NvbXBvbmVudC51aWRdID0gaW50ZXJhY3Rpb25zO1xuICAgICAgICAgICAgaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlW2NvbXBvbmVudC51aWRdID0gc2V0dGluZ3M7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50ID0gKGNvbXBvbmVudCkgPT4ge1xuICAgICAgICAgICAgbGV0IGxpc3RlbmVycyA9IHRoaXMuaW50ZXJhY3Rpb25zU3RvcmVbY29tcG9uZW50LnVpZF07XG4gICAgICAgICAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuaW50ZXJhY3Rpb25zU3RvcmVbY29tcG9uZW50LnVpZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlW2NvbXBvbmVudC51aWRdO1xuICAgICAgICB9O1xuICAgICAgICAvLyBSZXNpemluZ1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICB0aGlzLnJlc2l6ZVJ1bm5lciA9IG5ldyBEZWxheWVkUnVubmVyKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMuZW1pdHRlci50cmlnZ2VyKCdfcmVzaXplJywgdHJ1ZSk7IC8vIHNob3VsZCB3aW5kb3cgcmVzaXplcyBiZSBjb25zaWRlcmVkIFwiZm9yY2VkXCIgP1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5lbWl0dGVyLnRyaWdnZXIoJ3dpbmRvd1Jlc2l6ZScsIHsgdmlldzogdGhpcy5wcm9wcy52aWV3QXBpIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5oYW5kbGVXaW5kb3dSZXNpemUgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5oYW5kbGVXaW5kb3dSZXNpemUgJiZcbiAgICAgICAgICAgICAgICBldi50YXJnZXQgPT09IHdpbmRvdyAvLyBhdm9pZCBqcXVpIGV2ZW50c1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNpemVSdW5uZXIucmVxdWVzdChvcHRpb25zLndpbmRvd1Jlc2l6ZURlbGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLypcbiAgICByZW5kZXJzIElOU0lERSBvZiBhbiBvdXRlciBkaXZcbiAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IHRvb2xiYXJDb25maWcsIG9wdGlvbnMgfSA9IHByb3BzO1xuICAgICAgICBsZXQgdG9vbGJhclByb3BzID0gdGhpcy5idWlsZFRvb2xiYXJQcm9wcyhwcm9wcy52aWV3U3BlYywgcHJvcHMuZGF0ZVByb2ZpbGUsIHByb3BzLmRhdGVQcm9maWxlR2VuZXJhdG9yLCBwcm9wcy5jdXJyZW50RGF0ZSwgZ2V0Tm93KHByb3BzLm9wdGlvbnMubm93LCBwcm9wcy5kYXRlRW52KSwgLy8gVE9ETzogdXNlIE5vd1RpbWVyPz8/P1xuICAgICAgICBwcm9wcy52aWV3VGl0bGUpO1xuICAgICAgICBsZXQgdmlld1ZHcm93ID0gZmFsc2U7XG4gICAgICAgIGxldCB2aWV3SGVpZ2h0ID0gJyc7XG4gICAgICAgIGxldCB2aWV3QXNwZWN0UmF0aW87XG4gICAgICAgIGlmIChwcm9wcy5pc0hlaWdodEF1dG8gfHwgcHJvcHMuZm9yUHJpbnQpIHtcbiAgICAgICAgICAgIHZpZXdIZWlnaHQgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLmhlaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICB2aWV3Vkdyb3cgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuY29udGVudEhlaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICB2aWV3SGVpZ2h0ID0gb3B0aW9ucy5jb250ZW50SGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmlld0FzcGVjdFJhdGlvID0gTWF0aC5tYXgob3B0aW9ucy5hc3BlY3RSYXRpbywgMC41KTsgLy8gcHJldmVudCBmcm9tIGdldHRpbmcgdG9vIHRhbGxcbiAgICAgICAgfVxuICAgICAgICBsZXQgdmlld0NvbnRleHQgPSB0aGlzLmJ1aWxkVmlld0NvbnRleHQocHJvcHMudmlld1NwZWMsIHByb3BzLnZpZXdBcGksIHByb3BzLm9wdGlvbnMsIHByb3BzLmRhdGVQcm9maWxlR2VuZXJhdG9yLCBwcm9wcy5kYXRlRW52LCBwcm9wcy50aGVtZSwgcHJvcHMucGx1Z2luSG9va3MsIHByb3BzLmRpc3BhdGNoLCBwcm9wcy5nZXRDdXJyZW50RGF0YSwgcHJvcHMuZW1pdHRlciwgcHJvcHMuY2FsZW5kYXJBcGksIHRoaXMucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCwgdGhpcy51bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQpO1xuICAgICAgICBsZXQgdmlld0xhYmVsSWQgPSAodG9vbGJhckNvbmZpZy5oZWFkZXIgJiYgdG9vbGJhckNvbmZpZy5oZWFkZXIuaGFzVGl0bGUpXG4gICAgICAgICAgICA/IHRoaXMuc3RhdGUudmlld0xhYmVsSWRcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVmlld0NvbnRleHRUeXBlLlByb3ZpZGVyLCB7IHZhbHVlOiB2aWV3Q29udGV4dCB9LFxuICAgICAgICAgICAgdG9vbGJhckNvbmZpZy5oZWFkZXIgJiYgKGNyZWF0ZUVsZW1lbnQoVG9vbGJhciwgT2JqZWN0LmFzc2lnbih7IHJlZjogdGhpcy5oZWFkZXJSZWYsIGV4dHJhQ2xhc3NOYW1lOiBcImZjLWhlYWRlci10b29sYmFyXCIsIG1vZGVsOiB0b29sYmFyQ29uZmlnLmhlYWRlciwgdGl0bGVJZDogdmlld0xhYmVsSWQgfSwgdG9vbGJhclByb3BzKSkpLFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChWaWV3SGFybmVzcywgeyBsaXF1aWQ6IHZpZXdWR3JvdywgaGVpZ2h0OiB2aWV3SGVpZ2h0LCBhc3BlY3RSYXRpbzogdmlld0FzcGVjdFJhdGlvLCBsYWJlbGVkQnlJZDogdmlld0xhYmVsSWQgfSxcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclZpZXcocHJvcHMpLFxuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRBcHBlbmRDb250ZW50KCkpLFxuICAgICAgICAgICAgdG9vbGJhckNvbmZpZy5mb290ZXIgJiYgKGNyZWF0ZUVsZW1lbnQoVG9vbGJhciwgT2JqZWN0LmFzc2lnbih7IHJlZjogdGhpcy5mb290ZXJSZWYsIGV4dHJhQ2xhc3NOYW1lOiBcImZjLWZvb3Rlci10b29sYmFyXCIsIG1vZGVsOiB0b29sYmFyQ29uZmlnLmZvb3RlciwgdGl0bGVJZDogXCJcIiB9LCB0b29sYmFyUHJvcHMpKSkpKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmNhbGVuZGFySW50ZXJhY3Rpb25zID0gcHJvcHMucGx1Z2luSG9va3MuY2FsZW5kYXJJbnRlcmFjdGlvbnNcbiAgICAgICAgICAgIC5tYXAoKENhbGVuZGFySW50ZXJhY3Rpb25DbGFzcykgPT4gbmV3IENhbGVuZGFySW50ZXJhY3Rpb25DbGFzcyhwcm9wcykpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5oYW5kbGVXaW5kb3dSZXNpemUpO1xuICAgICAgICBsZXQgeyBwcm9wU2V0SGFuZGxlcnMgfSA9IHByb3BzLnBsdWdpbkhvb2tzO1xuICAgICAgICBmb3IgKGxldCBwcm9wTmFtZSBpbiBwcm9wU2V0SGFuZGxlcnMpIHtcbiAgICAgICAgICAgIHByb3BTZXRIYW5kbGVyc1twcm9wTmFtZV0ocHJvcHNbcHJvcE5hbWVdLCBwcm9wcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgcHJvcFNldEhhbmRsZXJzIH0gPSBwcm9wcy5wbHVnaW5Ib29rcztcbiAgICAgICAgZm9yIChsZXQgcHJvcE5hbWUgaW4gcHJvcFNldEhhbmRsZXJzKSB7XG4gICAgICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdICE9PSBwcmV2UHJvcHNbcHJvcE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgcHJvcFNldEhhbmRsZXJzW3Byb3BOYW1lXShwcm9wc1twcm9wTmFtZV0sIHByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuaGFuZGxlV2luZG93UmVzaXplKTtcbiAgICAgICAgdGhpcy5yZXNpemVSdW5uZXIuY2xlYXIoKTtcbiAgICAgICAgZm9yIChsZXQgaW50ZXJhY3Rpb24gb2YgdGhpcy5jYWxlbmRhckludGVyYWN0aW9ucykge1xuICAgICAgICAgICAgaW50ZXJhY3Rpb24uZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvcHMuZW1pdHRlci50cmlnZ2VyKCdfdW5tb3VudCcpO1xuICAgIH1cbiAgICBidWlsZEFwcGVuZENvbnRlbnQoKSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBwcm9wcy5wbHVnaW5Ib29rcy52aWV3Q29udGFpbmVyQXBwZW5kcy5tYXAoKGJ1aWxkQXBwZW5kQ29udGVudCkgPT4gYnVpbGRBcHBlbmRDb250ZW50KHByb3BzKSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCB7fSwgLi4uY2hpbGRyZW4pO1xuICAgIH1cbiAgICByZW5kZXJWaWV3KHByb3BzKSB7XG4gICAgICAgIGxldCB7IHBsdWdpbkhvb2tzIH0gPSBwcm9wcztcbiAgICAgICAgbGV0IHsgdmlld1NwZWMgfSA9IHByb3BzO1xuICAgICAgICBsZXQgdmlld1Byb3BzID0ge1xuICAgICAgICAgICAgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLFxuICAgICAgICAgICAgYnVzaW5lc3NIb3VyczogcHJvcHMuYnVzaW5lc3NIb3VycyxcbiAgICAgICAgICAgIGV2ZW50U3RvcmU6IHByb3BzLnJlbmRlcmFibGVFdmVudFN0b3JlLFxuICAgICAgICAgICAgZXZlbnRVaUJhc2VzOiBwcm9wcy5ldmVudFVpQmFzZXMsXG4gICAgICAgICAgICBkYXRlU2VsZWN0aW9uOiBwcm9wcy5kYXRlU2VsZWN0aW9uLFxuICAgICAgICAgICAgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLFxuICAgICAgICAgICAgZXZlbnREcmFnOiBwcm9wcy5ldmVudERyYWcsXG4gICAgICAgICAgICBldmVudFJlc2l6ZTogcHJvcHMuZXZlbnRSZXNpemUsXG4gICAgICAgICAgICBpc0hlaWdodEF1dG86IHByb3BzLmlzSGVpZ2h0QXV0byxcbiAgICAgICAgICAgIGZvclByaW50OiBwcm9wcy5mb3JQcmludCxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVycyA9IHRoaXMuYnVpbGRWaWV3UHJvcFRyYW5zZm9ybWVycyhwbHVnaW5Ib29rcy52aWV3UHJvcHNUcmFuc2Zvcm1lcnMpO1xuICAgICAgICBmb3IgKGxldCB0cmFuc2Zvcm1lciBvZiB0cmFuc2Zvcm1lcnMpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odmlld1Byb3BzLCB0cmFuc2Zvcm1lci50cmFuc2Zvcm0odmlld1Byb3BzLCBwcm9wcykpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBWaWV3Q29tcG9uZW50ID0gdmlld1NwZWMuY29tcG9uZW50O1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVmlld0NvbXBvbmVudCwgT2JqZWN0LmFzc2lnbih7fSwgdmlld1Byb3BzKSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkVG9vbGJhclByb3BzKHZpZXdTcGVjLCBkYXRlUHJvZmlsZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IsIGN1cnJlbnREYXRlLCBub3csIHRpdGxlKSB7XG4gICAgLy8gZG9uJ3QgZm9yY2UgYW55IGRhdGUtcHJvZmlsZXMgdG8gdmFsaWQgZGF0ZSBwcm9maWxlcyAodGhlIGBmYWxzZWApIHNvIHRoYXQgd2UgY2FuIHRlbGwgaWYgaXQncyBpbnZhbGlkXG4gICAgbGV0IHRvZGF5SW5mbyA9IGRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkKG5vdywgdW5kZWZpbmVkLCBmYWxzZSk7IC8vIFRPRE86IG5lZWQgYHVuZGVmaW5lZGAgb3IgZWxzZSBJTkZJTklURSBMT09QIGZvciBzb21lIHJlYXNvblxuICAgIGxldCBwcmV2SW5mbyA9IGRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkUHJldihkYXRlUHJvZmlsZSwgY3VycmVudERhdGUsIGZhbHNlKTtcbiAgICBsZXQgbmV4dEluZm8gPSBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZE5leHQoZGF0ZVByb2ZpbGUsIGN1cnJlbnREYXRlLCBmYWxzZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGl0bGUsXG4gICAgICAgIGFjdGl2ZUJ1dHRvbjogdmlld1NwZWMudHlwZSxcbiAgICAgICAgbmF2VW5pdDogdmlld1NwZWMuc2luZ2xlVW5pdCxcbiAgICAgICAgaXNUb2RheUVuYWJsZWQ6IHRvZGF5SW5mby5pc1ZhbGlkICYmICFyYW5nZUNvbnRhaW5zTWFya2VyKGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZSwgbm93KSxcbiAgICAgICAgaXNQcmV2RW5hYmxlZDogcHJldkluZm8uaXNWYWxpZCxcbiAgICAgICAgaXNOZXh0RW5hYmxlZDogbmV4dEluZm8uaXNWYWxpZCxcbiAgICB9O1xufVxuLy8gUGx1Z2luXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gYnVpbGRWaWV3UHJvcFRyYW5zZm9ybWVycyh0aGVDbGFzc2VzKSB7XG4gICAgcmV0dXJuIHRoZUNsYXNzZXMubWFwKChUaGVDbGFzcykgPT4gbmV3IFRoZUNsYXNzKCkpO1xufVxuXG5jbGFzcyBDYWxlbmRhciBleHRlbmRzIENhbGVuZGFySW1wbCB7XG4gICAgY29uc3RydWN0b3IoZWwsIG9wdGlvbk92ZXJyaWRlcyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaXNSZW5kZXJpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1JlbmRlcmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY3VycmVudENsYXNzTmFtZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jdXN0b21Db250ZW50UmVuZGVySWQgPSAwO1xuICAgICAgICB0aGlzLmhhbmRsZUFjdGlvbiA9IChhY3Rpb24pID0+IHtcbiAgICAgICAgICAgIC8vIGFjdGlvbnMgd2Uga25vdyB3ZSB3YW50IHRvIHJlbmRlciBpbW1lZGlhdGVseVxuICAgICAgICAgICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ1NFVF9FVkVOVF9EUkFHJzpcbiAgICAgICAgICAgICAgICBjYXNlICdTRVRfRVZFTlRfUkVTSVpFJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJSdW5uZXIudHJ5RHJhaW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVEYXRhID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudERhdGEgPSBkYXRhO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJSdW5uZXIucmVxdWVzdChkYXRhLmNhbGVuZGFyT3B0aW9ucy5yZXJlbmRlckRlbGF5KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVSZW5kZXJSZXF1ZXN0ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNSZW5kZXJpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzUmVuZGVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGxldCB7IGN1cnJlbnREYXRhIH0gPSB0aGlzO1xuICAgICAgICAgICAgICAgIGZsdXNoU3luYygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcihjcmVhdGVFbGVtZW50KENhbGVuZGFyUm9vdCwgeyBvcHRpb25zOiBjdXJyZW50RGF0YS5jYWxlbmRhck9wdGlvbnMsIHRoZW1lOiBjdXJyZW50RGF0YS50aGVtZSwgZW1pdHRlcjogY3VycmVudERhdGEuZW1pdHRlciB9LCAoY2xhc3NOYW1lcywgaGVpZ2h0LCBpc0hlaWdodEF1dG8sIGZvclByaW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldENsYXNzTmFtZXMoY2xhc3NOYW1lcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEhlaWdodChoZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFJlbmRlcklkLlByb3ZpZGVyLCB7IHZhbHVlOiB0aGlzLmN1c3RvbUNvbnRlbnRSZW5kZXJJZCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoQ2FsZW5kYXJDb250ZW50LCBPYmplY3QuYXNzaWduKHsgaXNIZWlnaHRBdXRvOiBpc0hlaWdodEF1dG8sIGZvclByaW50OiBmb3JQcmludCB9LCBjdXJyZW50RGF0YSkpKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pLCB0aGlzLmVsKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaXNSZW5kZXJlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNSZW5kZXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJlbmRlcihudWxsLCB0aGlzLmVsKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldENsYXNzTmFtZXMoW10pO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0SGVpZ2h0KCcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZW5zdXJlRWxIYXNTdHlsZXMoZWwpO1xuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMucmVuZGVyUnVubmVyID0gbmV3IERlbGF5ZWRSdW5uZXIodGhpcy5oYW5kbGVSZW5kZXJSZXF1ZXN0KTtcbiAgICAgICAgbmV3IENhbGVuZGFyRGF0YU1hbmFnZXIoe1xuICAgICAgICAgICAgb3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICAgICAgY2FsZW5kYXJBcGk6IHRoaXMsXG4gICAgICAgICAgICBvbkFjdGlvbjogdGhpcy5oYW5kbGVBY3Rpb24sXG4gICAgICAgICAgICBvbkRhdGE6IHRoaXMuaGFuZGxlRGF0YSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHdhc1JlbmRlcmluZyA9IHRoaXMuaXNSZW5kZXJpbmc7XG4gICAgICAgIGlmICghd2FzUmVuZGVyaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmlzUmVuZGVyaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tQ29udGVudFJlbmRlcklkICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW5kZXJSdW5uZXIucmVxdWVzdCgpO1xuICAgICAgICBpZiAod2FzUmVuZGVyaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNpemUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5pc1JlbmRlcmluZykge1xuICAgICAgICAgICAgdGhpcy5pc1JlbmRlcmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJSdW5uZXIucmVxdWVzdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZVNpemUoKSB7XG4gICAgICAgIGZsdXNoU3luYygoKSA9PiB7XG4gICAgICAgICAgICBzdXBlci51cGRhdGVTaXplKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBiYXRjaFJlbmRlcmluZyhmdW5jKSB7XG4gICAgICAgIHRoaXMucmVuZGVyUnVubmVyLnBhdXNlKCdiYXRjaFJlbmRlcmluZycpO1xuICAgICAgICBmdW5jKCk7XG4gICAgICAgIHRoaXMucmVuZGVyUnVubmVyLnJlc3VtZSgnYmF0Y2hSZW5kZXJpbmcnKTtcbiAgICB9XG4gICAgcGF1c2VSZW5kZXJpbmcoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyUnVubmVyLnBhdXNlKCdwYXVzZVJlbmRlcmluZycpO1xuICAgIH1cbiAgICByZXN1bWVSZW5kZXJpbmcoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyUnVubmVyLnJlc3VtZSgncGF1c2VSZW5kZXJpbmcnLCB0cnVlKTtcbiAgICB9XG4gICAgcmVzZXRPcHRpb25zKG9wdGlvbk92ZXJyaWRlcywgY2hhbmdlZE9wdGlvbk5hbWVzKSB7XG4gICAgICAgIHRoaXMuY3VycmVudERhdGFNYW5hZ2VyLnJlc2V0T3B0aW9ucyhvcHRpb25PdmVycmlkZXMsIGNoYW5nZWRPcHRpb25OYW1lcyk7XG4gICAgfVxuICAgIHNldENsYXNzTmFtZXMoY2xhc3NOYW1lcykge1xuICAgICAgICBpZiAoIWlzQXJyYXlzRXF1YWwoY2xhc3NOYW1lcywgdGhpcy5jdXJyZW50Q2xhc3NOYW1lcykpIHtcbiAgICAgICAgICAgIGxldCB7IGNsYXNzTGlzdCB9ID0gdGhpcy5lbDtcbiAgICAgICAgICAgIGZvciAobGV0IGNsYXNzTmFtZSBvZiB0aGlzLmN1cnJlbnRDbGFzc05hbWVzKSB7XG4gICAgICAgICAgICAgICAgY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgY2xhc3NOYW1lIG9mIGNsYXNzTmFtZXMpIHtcbiAgICAgICAgICAgICAgICBjbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDbGFzc05hbWVzID0gY2xhc3NOYW1lcztcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRIZWlnaHQoaGVpZ2h0KSB7XG4gICAgICAgIGFwcGx5U3R5bGVQcm9wKHRoaXMuZWwsICdoZWlnaHQnLCBoZWlnaHQpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlSW5wdXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBkYXRlRW52ID0gYnVpbGREYXRlRW52KG9wdGlvbnMpO1xuICAgIGxldCBmb3JtYXR0ZXIgPSBjcmVhdGVGb3JtYXR0ZXIob3B0aW9ucyk7XG4gICAgbGV0IGRhdGVNZXRhID0gZGF0ZUVudi5jcmVhdGVNYXJrZXJNZXRhKGRhdGVJbnB1dCk7XG4gICAgaWYgKCFkYXRlTWV0YSkgeyAvLyBUT0RPOiB3YXJuaW5nP1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBkYXRlRW52LmZvcm1hdChkYXRlTWV0YS5tYXJrZXIsIGZvcm1hdHRlciwge1xuICAgICAgICBmb3JjZWRUem86IGRhdGVNZXRhLmZvcmNlZFR6byxcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFJhbmdlKHN0YXJ0SW5wdXQsIGVuZElucHV0LCBvcHRpb25zKSB7XG4gICAgbGV0IGRhdGVFbnYgPSBidWlsZERhdGVFbnYodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMgPyBvcHRpb25zIDoge30pOyAvLyBwYXNzIGluIGlmIG5vbi1udWxsIG9iamVjdFxuICAgIGxldCBmb3JtYXR0ZXIgPSBjcmVhdGVGb3JtYXR0ZXIob3B0aW9ucyk7XG4gICAgbGV0IHN0YXJ0TWV0YSA9IGRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShzdGFydElucHV0KTtcbiAgICBsZXQgZW5kTWV0YSA9IGRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShlbmRJbnB1dCk7XG4gICAgaWYgKCFzdGFydE1ldGEgfHwgIWVuZE1ldGEpIHsgLy8gVE9ETzogd2FybmluZz9cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXRSYW5nZShzdGFydE1ldGEubWFya2VyLCBlbmRNZXRhLm1hcmtlciwgZm9ybWF0dGVyLCB7XG4gICAgICAgIGZvcmNlZFN0YXJ0VHpvOiBzdGFydE1ldGEuZm9yY2VkVHpvLFxuICAgICAgICBmb3JjZWRFbmRUem86IGVuZE1ldGEuZm9yY2VkVHpvLFxuICAgICAgICBpc0VuZEV4Y2x1c2l2ZTogb3B0aW9ucy5pc0VuZEV4Y2x1c2l2ZSxcbiAgICAgICAgZGVmYXVsdFNlcGFyYXRvcjogQkFTRV9PUFRJT05fREVGQVVMVFMuZGVmYXVsdFJhbmdlU2VwYXJhdG9yLFxuICAgIH0pO1xufVxuLy8gVE9ETzogbW9yZSBEUlkgYW5kIG9wdGltaXplZFxuZnVuY3Rpb24gYnVpbGREYXRlRW52KHNldHRpbmdzKSB7XG4gICAgbGV0IGxvY2FsZSA9IGJ1aWxkTG9jYWxlKHNldHRpbmdzLmxvY2FsZSB8fCAnZW4nLCBvcmdhbml6ZVJhd0xvY2FsZXMoW10pLm1hcCk7IC8vIFRPRE86IGRvbid0IGhhcmRjb2RlICdlbicgZXZlcnl3aGVyZVxuICAgIHJldHVybiBuZXcgRGF0ZUVudihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyB0aW1lWm9uZTogQkFTRV9PUFRJT05fREVGQVVMVFMudGltZVpvbmUsIGNhbGVuZGFyU3lzdGVtOiAnZ3JlZ29yeScgfSwgc2V0dGluZ3MpLCB7IGxvY2FsZSB9KSk7XG59XG5cbi8vIEhFTFBFUlNcbi8qXG5pZiBuZXh0RGF5VGhyZXNob2xkIGlzIHNwZWNpZmllZCwgc2xpY2luZyBpcyBkb25lIGluIGFuIGFsbC1kYXkgZmFzaGlvbi5cbnlvdSBjYW4gZ2V0IG5leHREYXlUaHJlc2hvbGQgZnJvbSBjb250ZXh0Lm5leHREYXlUaHJlc2hvbGRcbiovXG5mdW5jdGlvbiBzbGljZUV2ZW50cyhwcm9wcywgYWxsRGF5KSB7XG4gICAgcmV0dXJuIHNsaWNlRXZlbnRTdG9yZShwcm9wcy5ldmVudFN0b3JlLCBwcm9wcy5ldmVudFVpQmFzZXMsIHByb3BzLmRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLCBhbGxEYXkgPyBwcm9wcy5uZXh0RGF5VGhyZXNob2xkIDogbnVsbCkuZmc7XG59XG5cbmNvbnN0IHZlcnNpb24gPSAnNi4xLjE1JztcblxuZXhwb3J0IHsgQ2FsZW5kYXIsIGNyZWF0ZVBsdWdpbiwgZm9ybWF0RGF0ZSwgZm9ybWF0UmFuZ2UsIGdsb2JhbExvY2FsZXMsIGdsb2JhbFBsdWdpbnMsIHNsaWNlRXZlbnRzLCB2ZXJzaW9uIH07XG4iLCAiaW1wb3J0IHsgRGF0ZUNvbXBvbmVudCwgZ2V0U3RpY2t5SGVhZGVyRGF0ZXMsIFZpZXdDb250YWluZXIsIFNpbXBsZVNjcm9sbEdyaWQsIGdldFN0aWNreUZvb3RlclNjcm9sbGJhciwgcmVuZGVyU2Nyb2xsU2hpbSwgY3JlYXRlRm9ybWF0dGVyLCBCYXNlQ29tcG9uZW50LCBTdGFuZGFyZEV2ZW50LCBidWlsZFNlZ1RpbWVUZXh0LCBFdmVudENvbnRhaW5lciwgZ2V0U2VnQW5jaG9yQXR0cnMsIG1lbW9pemUsIE1vcmVMaW5rQ29udGFpbmVyLCBnZXRTZWdNZXRhLCBnZXRVbmlxdWVEb21JZCwgc2V0UmVmLCBEYXlDZWxsQ29udGFpbmVyLCBXZWVrTnVtYmVyQ29udGFpbmVyLCBidWlsZE5hdkxpbmtBdHRycywgaGFzQ3VzdG9tRGF5Q2VsbENvbnRlbnQsIGFkZE1zLCBpbnRlcnNlY3RSYW5nZXMsIGFkZERheXMsIFNlZ0hpZXJhcmNoeSwgYnVpbGRFbnRyeUtleSwgaW50ZXJzZWN0U3BhbnMsIFJlZk1hcCwgc29ydEV2ZW50U2VncywgaXNQcm9wc0VxdWFsLCBidWlsZEV2ZW50UmFuZ2VLZXksIEJnRXZlbnQsIHJlbmRlckZpbGwsIFBvc2l0aW9uQ2FjaGUsIE5vd1RpbWVyLCBmb3JtYXRJc29Nb250aFN0ciwgZm9ybWF0RGF5U3RyaW5nLCBTbGljZXIsIERheUhlYWRlciwgRGF5U2VyaWVzTW9kZWwsIERheVRhYmxlTW9kZWwsIERhdGVQcm9maWxlR2VuZXJhdG9yLCBhZGRXZWVrcywgZGlmZldlZWtzLCBpbmplY3RTdHlsZXMgfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvcmUvaW50ZXJuYWwuanMnO1xuaW1wb3J0IHsgY3JlYXRlUmVmLCBjcmVhdGVFbGVtZW50LCBGcmFnbWVudCB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29yZS9wcmVhY3QuanMnO1xuXG4vKiBBbiBhYnN0cmFjdCBjbGFzcyBmb3IgdGhlIGRheWdyaWQgdmlld3MsIGFzIHdlbGwgYXMgbW9udGggdmlldy4gUmVuZGVycyBvbmUgb3IgbW9yZSByb3dzIG9mIGRheSBjZWxscy5cbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLy8gSXQgaXMgYSBtYW5hZ2VyIGZvciBhIFRhYmxlIHN1YmNvbXBvbmVudCwgd2hpY2ggZG9lcyBtb3N0IG9mIHRoZSBoZWF2eSBsaWZ0aW5nLlxuLy8gSXQgaXMgcmVzcG9uc2libGUgZm9yIG1hbmFnaW5nIHdpZHRoL2hlaWdodC5cbmNsYXNzIFRhYmxlVmlldyBleHRlbmRzIERhdGVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmhlYWRlckVsUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgfVxuICAgIHJlbmRlclNpbXBsZUxheW91dChoZWFkZXJSb3dDb250ZW50LCBib2R5Q29udGVudCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHNlY3Rpb25zID0gW107XG4gICAgICAgIGxldCBzdGlja3lIZWFkZXJEYXRlcyA9IGdldFN0aWNreUhlYWRlckRhdGVzKGNvbnRleHQub3B0aW9ucyk7XG4gICAgICAgIGlmIChoZWFkZXJSb3dDb250ZW50KSB7XG4gICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaGVhZGVyJyxcbiAgICAgICAgICAgICAgICBrZXk6ICdoZWFkZXInLFxuICAgICAgICAgICAgICAgIGlzU3RpY2t5OiBzdGlja3lIZWFkZXJEYXRlcyxcbiAgICAgICAgICAgICAgICBjaHVuazoge1xuICAgICAgICAgICAgICAgICAgICBlbFJlZjogdGhpcy5oZWFkZXJFbFJlZixcbiAgICAgICAgICAgICAgICAgICAgdGFibGVDbGFzc05hbWU6ICdmYy1jb2wtaGVhZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgcm93Q29udGVudDogaGVhZGVyUm93Q29udGVudCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnYm9keScsXG4gICAgICAgICAgICBrZXk6ICdib2R5JyxcbiAgICAgICAgICAgIGxpcXVpZDogdHJ1ZSxcbiAgICAgICAgICAgIGNodW5rOiB7IGNvbnRlbnQ6IGJvZHlDb250ZW50IH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVmlld0NvbnRhaW5lciwgeyBlbENsYXNzZXM6IFsnZmMtZGF5Z3JpZCddLCB2aWV3U3BlYzogY29udGV4dC52aWV3U3BlYyB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChTaW1wbGVTY3JvbGxHcmlkLCB7IGxpcXVpZDogIXByb3BzLmlzSGVpZ2h0QXV0byAmJiAhcHJvcHMuZm9yUHJpbnQsIGNvbGxhcHNpYmxlV2lkdGg6IHByb3BzLmZvclByaW50LCBjb2xzOiBbXSAvKiBUT0RPOiBtYWtlIG9wdGlvbmFsPyAqLywgc2VjdGlvbnM6IHNlY3Rpb25zIH0pKSk7XG4gICAgfVxuICAgIHJlbmRlckhTY3JvbGxMYXlvdXQoaGVhZGVyUm93Q29udGVudCwgYm9keUNvbnRlbnQsIGNvbENudCwgZGF5TWluV2lkdGgpIHtcbiAgICAgICAgbGV0IFNjcm9sbEdyaWQgPSB0aGlzLmNvbnRleHQucGx1Z2luSG9va3Muc2Nyb2xsR3JpZEltcGw7XG4gICAgICAgIGlmICghU2Nyb2xsR3JpZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBTY3JvbGxHcmlkIGltcGxlbWVudGF0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCBzdGlja3lIZWFkZXJEYXRlcyA9ICFwcm9wcy5mb3JQcmludCAmJiBnZXRTdGlja3lIZWFkZXJEYXRlcyhjb250ZXh0Lm9wdGlvbnMpO1xuICAgICAgICBsZXQgc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyID0gIXByb3BzLmZvclByaW50ICYmIGdldFN0aWNreUZvb3RlclNjcm9sbGJhcihjb250ZXh0Lm9wdGlvbnMpO1xuICAgICAgICBsZXQgc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgaWYgKGhlYWRlclJvd0NvbnRlbnQpIHtcbiAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdoZWFkZXInLFxuICAgICAgICAgICAgICAgIGtleTogJ2hlYWRlcicsXG4gICAgICAgICAgICAgICAgaXNTdGlja3k6IHN0aWNreUhlYWRlckRhdGVzLFxuICAgICAgICAgICAgICAgIGNodW5rczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ21haW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxSZWY6IHRoaXMuaGVhZGVyRWxSZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWJsZUNsYXNzTmFtZTogJ2ZjLWNvbC1oZWFkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm93Q29udGVudDogaGVhZGVyUm93Q29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdib2R5JyxcbiAgICAgICAgICAgIGtleTogJ2JvZHknLFxuICAgICAgICAgICAgbGlxdWlkOiB0cnVlLFxuICAgICAgICAgICAgY2h1bmtzOiBbe1xuICAgICAgICAgICAgICAgICAgICBrZXk6ICdtYWluJyxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogYm9keUNvbnRlbnQsXG4gICAgICAgICAgICAgICAgfV0sXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyKSB7XG4gICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZm9vdGVyJyxcbiAgICAgICAgICAgICAgICBrZXk6ICdmb290ZXInLFxuICAgICAgICAgICAgICAgIGlzU3RpY2t5OiB0cnVlLFxuICAgICAgICAgICAgICAgIGNodW5rczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ21haW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogcmVuZGVyU2Nyb2xsU2hpbSxcbiAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVmlld0NvbnRhaW5lciwgeyBlbENsYXNzZXM6IFsnZmMtZGF5Z3JpZCddLCB2aWV3U3BlYzogY29udGV4dC52aWV3U3BlYyB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChTY3JvbGxHcmlkLCB7IGxpcXVpZDogIXByb3BzLmlzSGVpZ2h0QXV0byAmJiAhcHJvcHMuZm9yUHJpbnQsIGZvclByaW50OiBwcm9wcy5mb3JQcmludCwgY29sbGFwc2libGVXaWR0aDogcHJvcHMuZm9yUHJpbnQsIGNvbEdyb3VwczogW3sgY29sczogW3sgc3BhbjogY29sQ250LCBtaW5XaWR0aDogZGF5TWluV2lkdGggfV0gfV0sIHNlY3Rpb25zOiBzZWN0aW9ucyB9KSkpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc3BsaXRTZWdzQnlSb3coc2Vncywgcm93Q250KSB7XG4gICAgbGV0IGJ5Um93ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dDbnQ7IGkgKz0gMSkge1xuICAgICAgICBieVJvd1tpXSA9IFtdO1xuICAgIH1cbiAgICBmb3IgKGxldCBzZWcgb2Ygc2Vncykge1xuICAgICAgICBieVJvd1tzZWcucm93XS5wdXNoKHNlZyk7XG4gICAgfVxuICAgIHJldHVybiBieVJvdztcbn1cbmZ1bmN0aW9uIHNwbGl0U2Vnc0J5Rmlyc3RDb2woc2VncywgY29sQ250KSB7XG4gICAgbGV0IGJ5Q29sID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xDbnQ7IGkgKz0gMSkge1xuICAgICAgICBieUNvbFtpXSA9IFtdO1xuICAgIH1cbiAgICBmb3IgKGxldCBzZWcgb2Ygc2Vncykge1xuICAgICAgICBieUNvbFtzZWcuZmlyc3RDb2xdLnB1c2goc2VnKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5Q29sO1xufVxuZnVuY3Rpb24gc3BsaXRJbnRlcmFjdGlvbkJ5Um93KHVpLCByb3dDbnQpIHtcbiAgICBsZXQgYnlSb3cgPSBbXTtcbiAgICBpZiAoIXVpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93Q250OyBpICs9IDEpIHtcbiAgICAgICAgICAgIGJ5Um93W2ldID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dDbnQ7IGkgKz0gMSkge1xuICAgICAgICAgICAgYnlSb3dbaV0gPSB7XG4gICAgICAgICAgICAgICAgYWZmZWN0ZWRJbnN0YW5jZXM6IHVpLmFmZmVjdGVkSW5zdGFuY2VzLFxuICAgICAgICAgICAgICAgIGlzRXZlbnQ6IHVpLmlzRXZlbnQsXG4gICAgICAgICAgICAgICAgc2VnczogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHNlZyBvZiB1aS5zZWdzKSB7XG4gICAgICAgICAgICBieVJvd1tzZWcucm93XS5zZWdzLnB1c2goc2VnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYnlSb3c7XG59XG5cbmNvbnN0IERFRkFVTFRfVEFCTEVfRVZFTlRfVElNRV9GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoe1xuICAgIGhvdXI6ICdudW1lcmljJyxcbiAgICBtaW51dGU6ICcyLWRpZ2l0JyxcbiAgICBvbWl0WmVyb01pbnV0ZTogdHJ1ZSxcbiAgICBtZXJpZGllbTogJ25hcnJvdycsXG59KTtcbmZ1bmN0aW9uIGhhc0xpc3RJdGVtRGlzcGxheShzZWcpIHtcbiAgICBsZXQgeyBkaXNwbGF5IH0gPSBzZWcuZXZlbnRSYW5nZS51aTtcbiAgICByZXR1cm4gZGlzcGxheSA9PT0gJ2xpc3QtaXRlbScgfHwgKGRpc3BsYXkgPT09ICdhdXRvJyAmJlxuICAgICAgICAhc2VnLmV2ZW50UmFuZ2UuZGVmLmFsbERheSAmJlxuICAgICAgICBzZWcuZmlyc3RDb2wgPT09IHNlZy5sYXN0Q29sICYmIC8vIGNhbid0IGJlIG11bHRpLWRheVxuICAgICAgICBzZWcuaXNTdGFydCAmJiAvLyBcIlxuICAgICAgICBzZWcuaXNFbmQgLy8gXCJcbiAgICApO1xufVxuXG5jbGFzcyBUYWJsZUJsb2NrRXZlbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoU3RhbmRhcmRFdmVudCwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMsIHsgZWxDbGFzc2VzOiBbJ2ZjLWRheWdyaWQtZXZlbnQnLCAnZmMtZGF5Z3JpZC1ibG9jay1ldmVudCcsICdmYy1oLWV2ZW50J10sIGRlZmF1bHRUaW1lRm9ybWF0OiBERUZBVUxUX1RBQkxFX0VWRU5UX1RJTUVfRk9STUFULCBkZWZhdWx0RGlzcGxheUV2ZW50RW5kOiBwcm9wcy5kZWZhdWx0RGlzcGxheUV2ZW50RW5kLCBkaXNhYmxlUmVzaXppbmc6ICFwcm9wcy5zZWcuZXZlbnRSYW5nZS5kZWYuYWxsRGF5IH0pKSk7XG4gICAgfVxufVxuXG5jbGFzcyBUYWJsZUxpc3RJdGVtRXZlbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSBjb250ZXh0O1xuICAgICAgICBsZXQgeyBzZWcgfSA9IHByb3BzO1xuICAgICAgICBsZXQgdGltZUZvcm1hdCA9IG9wdGlvbnMuZXZlbnRUaW1lRm9ybWF0IHx8IERFRkFVTFRfVEFCTEVfRVZFTlRfVElNRV9GT1JNQVQ7XG4gICAgICAgIGxldCB0aW1lVGV4dCA9IGJ1aWxkU2VnVGltZVRleHQoc2VnLCB0aW1lRm9ybWF0LCBjb250ZXh0LCB0cnVlLCBwcm9wcy5kZWZhdWx0RGlzcGxheUV2ZW50RW5kKTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEV2ZW50Q29udGFpbmVyLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcywgeyBlbFRhZzogXCJhXCIsIGVsQ2xhc3NlczogWydmYy1kYXlncmlkLWV2ZW50JywgJ2ZjLWRheWdyaWQtZG90LWV2ZW50J10sIGVsQXR0cnM6IGdldFNlZ0FuY2hvckF0dHJzKHByb3BzLnNlZywgY29udGV4dCksIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlcklubmVyQ29udGVudCwgdGltZVRleHQ6IHRpbWVUZXh0LCBpc1Jlc2l6aW5nOiBmYWxzZSwgaXNEYXRlU2VsZWN0aW5nOiBmYWxzZSB9KSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbmRlcklubmVyQ29udGVudChyZW5kZXJQcm9wcykge1xuICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCxcbiAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWV2ZW50LWRvdFwiLCBzdHlsZTogeyBib3JkZXJDb2xvcjogcmVuZGVyUHJvcHMuYm9yZGVyQ29sb3IgfHwgcmVuZGVyUHJvcHMuYmFja2dyb3VuZENvbG9yIH0gfSksXG4gICAgICAgIHJlbmRlclByb3BzLnRpbWVUZXh0ICYmIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXRpbWVcIiB9LCByZW5kZXJQcm9wcy50aW1lVGV4dCkpLFxuICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXRpdGxlXCIgfSwgcmVuZGVyUHJvcHMuZXZlbnQudGl0bGUgfHwgY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCwgXCJcXHUwMEEwXCIpKSkpO1xufVxuXG5jbGFzcyBUYWJsZUNlbGxNb3JlTGluayBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmNvbXBpbGVTZWdzID0gbWVtb2l6ZShjb21waWxlU2Vncyk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IGFsbFNlZ3MsIGludmlzaWJsZVNlZ3MgfSA9IHRoaXMuY29tcGlsZVNlZ3MocHJvcHMuc2luZ2xlUGxhY2VtZW50cyk7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChNb3JlTGlua0NvbnRhaW5lciwgeyBlbENsYXNzZXM6IFsnZmMtZGF5Z3JpZC1tb3JlLWxpbmsnXSwgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlLCBhbGxEYXlEYXRlOiBwcm9wcy5hbGxEYXlEYXRlLCBtb3JlQ250OiBwcm9wcy5tb3JlQ250LCBhbGxTZWdzOiBhbGxTZWdzLCBoaWRkZW5TZWdzOiBpbnZpc2libGVTZWdzLCBhbGlnbm1lbnRFbFJlZjogcHJvcHMuYWxpZ25tZW50RWxSZWYsIGFsaWduR3JpZFRvcDogcHJvcHMuYWxpZ25HcmlkVG9wLCBleHRyYURhdGVTcGFuOiBwcm9wcy5leHRyYURhdGVTcGFuLCBwb3BvdmVyQ29udGVudDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBpc0ZvcmNlZEludmlzaWJsZSA9IChwcm9wcy5ldmVudERyYWcgPyBwcm9wcy5ldmVudERyYWcuYWZmZWN0ZWRJbnN0YW5jZXMgOiBudWxsKSB8fFxuICAgICAgICAgICAgICAgICAgICAocHJvcHMuZXZlbnRSZXNpemUgPyBwcm9wcy5ldmVudFJlc2l6ZS5hZmZlY3RlZEluc3RhbmNlcyA6IG51bGwpIHx8XG4gICAgICAgICAgICAgICAgICAgIHt9O1xuICAgICAgICAgICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCwgYWxsU2Vncy5tYXAoKHNlZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5zdGFuY2VJZCA9IHNlZy5ldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWV2ZW50LWhhcm5lc3NcIiwga2V5OiBpbnN0YW5jZUlkLCBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IGlzRm9yY2VkSW52aXNpYmxlW2luc3RhbmNlSWRdID8gJ2hpZGRlbicgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gfSwgaGFzTGlzdEl0ZW1EaXNwbGF5KHNlZykgPyAoY3JlYXRlRWxlbWVudChUYWJsZUxpc3RJdGVtRXZlbnQsIE9iamVjdC5hc3NpZ24oeyBzZWc6IHNlZywgaXNEcmFnZ2luZzogZmFsc2UsIGlzU2VsZWN0ZWQ6IGluc3RhbmNlSWQgPT09IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBkZWZhdWx0RGlzcGxheUV2ZW50RW5kOiBmYWxzZSB9LCBnZXRTZWdNZXRhKHNlZywgcHJvcHMudG9kYXlSYW5nZSkpKSkgOiAoY3JlYXRlRWxlbWVudChUYWJsZUJsb2NrRXZlbnQsIE9iamVjdC5hc3NpZ24oeyBzZWc6IHNlZywgaXNEcmFnZ2luZzogZmFsc2UsIGlzUmVzaXppbmc6IGZhbHNlLCBpc0RhdGVTZWxlY3Rpbmc6IGZhbHNlLCBpc1NlbGVjdGVkOiBpbnN0YW5jZUlkID09PSBwcm9wcy5ldmVudFNlbGVjdGlvbiwgZGVmYXVsdERpc3BsYXlFdmVudEVuZDogZmFsc2UgfSwgZ2V0U2VnTWV0YShzZWcsIHByb3BzLnRvZGF5UmFuZ2UpKSkpKSk7XG4gICAgICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgIH0gfSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXBpbGVTZWdzKHNpbmdsZVBsYWNlbWVudHMpIHtcbiAgICBsZXQgYWxsU2VncyA9IFtdO1xuICAgIGxldCBpbnZpc2libGVTZWdzID0gW107XG4gICAgZm9yIChsZXQgcGxhY2VtZW50IG9mIHNpbmdsZVBsYWNlbWVudHMpIHtcbiAgICAgICAgYWxsU2Vncy5wdXNoKHBsYWNlbWVudC5zZWcpO1xuICAgICAgICBpZiAoIXBsYWNlbWVudC5pc1Zpc2libGUpIHtcbiAgICAgICAgICAgIGludmlzaWJsZVNlZ3MucHVzaChwbGFjZW1lbnQuc2VnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBhbGxTZWdzLCBpbnZpc2libGVTZWdzIH07XG59XG5cbmNvbnN0IERFRkFVTFRfV0VFS19OVU1fRk9STUFUID0gY3JlYXRlRm9ybWF0dGVyKHsgd2VlazogJ25hcnJvdycgfSk7XG5jbGFzcyBUYWJsZUNlbGwgZXh0ZW5kcyBEYXRlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5yb290RWxSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGRheU51bWJlcklkOiBnZXRVbmlxdWVEb21JZCgpLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVJvb3RFbCA9IChlbCkgPT4ge1xuICAgICAgICAgICAgc2V0UmVmKHRoaXMucm9vdEVsUmVmLCBlbCk7XG4gICAgICAgICAgICBzZXRSZWYodGhpcy5wcm9wcy5lbFJlZiwgZWwpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IGNvbnRleHQsIHByb3BzLCBzdGF0ZSwgcm9vdEVsUmVmIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBvcHRpb25zLCBkYXRlRW52IH0gPSBjb250ZXh0O1xuICAgICAgICBsZXQgeyBkYXRlLCBkYXRlUHJvZmlsZSB9ID0gcHJvcHM7XG4gICAgICAgIC8vIFRPRE86IG1lbW9pemUgdGhpcz9cbiAgICAgICAgY29uc3QgaXNNb250aFN0YXJ0ID0gcHJvcHMuc2hvd0RheU51bWJlciAmJlxuICAgICAgICAgICAgc2hvdWxkRGlzcGxheU1vbnRoU3RhcnQoZGF0ZSwgZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLCBkYXRlRW52KTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KERheUNlbGxDb250YWluZXIsIHsgZWxUYWc6IFwidGRcIiwgZWxSZWY6IHRoaXMuaGFuZGxlUm9vdEVsLCBlbENsYXNzZXM6IFtcbiAgICAgICAgICAgICAgICAnZmMtZGF5Z3JpZC1kYXknLFxuICAgICAgICAgICAgICAgIC4uLihwcm9wcy5leHRyYUNsYXNzTmFtZXMgfHwgW10pLFxuICAgICAgICAgICAgXSwgZWxBdHRyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByb3BzLmV4dHJhRGF0YUF0dHJzKSwgKHByb3BzLnNob3dEYXlOdW1iZXIgPyB7ICdhcmlhLWxhYmVsbGVkYnknOiBzdGF0ZS5kYXlOdW1iZXJJZCB9IDoge30pKSwgeyByb2xlOiAnZ3JpZGNlbGwnIH0pLCBkZWZhdWx0R2VuZXJhdG9yOiByZW5kZXJUb3BJbm5lciwgZGF0ZTogZGF0ZSwgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLCB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlLCBzaG93RGF5TnVtYmVyOiBwcm9wcy5zaG93RGF5TnVtYmVyLCBpc01vbnRoU3RhcnQ6IGlzTW9udGhTdGFydCwgZXh0cmFSZW5kZXJQcm9wczogcHJvcHMuZXh0cmFSZW5kZXJQcm9wcyB9LCAoSW5uZXJDb250ZW50LCByZW5kZXJQcm9wcykgPT4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IHByb3BzLmlubmVyRWxSZWYsIGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWRheS1mcmFtZSBmYy1zY3JvbGxncmlkLXN5bmMtaW5uZXJcIiwgc3R5bGU6IHsgbWluSGVpZ2h0OiBwcm9wcy5taW5IZWlnaHQgfSB9LFxuICAgICAgICAgICAgcHJvcHMuc2hvd1dlZWtOdW1iZXIgJiYgKGNyZWF0ZUVsZW1lbnQoV2Vla051bWJlckNvbnRhaW5lciwgeyBlbFRhZzogXCJhXCIsIGVsQ2xhc3NlczogWydmYy1kYXlncmlkLXdlZWstbnVtYmVyJ10sIGVsQXR0cnM6IGJ1aWxkTmF2TGlua0F0dHJzKGNvbnRleHQsIGRhdGUsICd3ZWVrJyksIGRhdGU6IGRhdGUsIGRlZmF1bHRGb3JtYXQ6IERFRkFVTFRfV0VFS19OVU1fRk9STUFUIH0pKSxcbiAgICAgICAgICAgICFyZW5kZXJQcm9wcy5pc0Rpc2FibGVkICYmXG4gICAgICAgICAgICAgICAgKHByb3BzLnNob3dEYXlOdW1iZXIgfHwgaGFzQ3VzdG9tRGF5Q2VsbENvbnRlbnQob3B0aW9ucykgfHwgcHJvcHMuZm9yY2VEYXlUb3ApID8gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZGF5Z3JpZC1kYXktdG9wXCIgfSxcbiAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KElubmVyQ29udGVudCwgeyBlbFRhZzogXCJhXCIsIGVsQ2xhc3NlczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLWRheWdyaWQtZGF5LW51bWJlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc01vbnRoU3RhcnQgJiYgJ2ZjLWRheWdyaWQtbW9udGgtc3RhcnQnLFxuICAgICAgICAgICAgICAgICAgICBdLCBlbEF0dHJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJ1aWxkTmF2TGlua0F0dHJzKGNvbnRleHQsIGRhdGUpKSwgeyBpZDogc3RhdGUuZGF5TnVtYmVySWQgfSkgfSkpKSA6IHByb3BzLnNob3dEYXlOdW1iZXIgPyAoXG4gICAgICAgICAgICAvLyBmb3IgY3JlYXRpbmcgY29ycmVjdCBhbW91bnQgb2Ygc3BhY2UgKHNlZSBpc3N1ZSAjNzE2MilcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZGF5Z3JpZC1kYXktdG9wXCIsIHN0eWxlOiB7IHZpc2liaWxpdHk6ICdoaWRkZW4nIH0gfSxcbiAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiYVwiLCB7IGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWRheS1udW1iZXJcIiB9LCBcIlxcdTAwQTBcIikpKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZGF5Z3JpZC1kYXktZXZlbnRzXCIsIHJlZjogcHJvcHMuZmdDb250ZW50RWxSZWYgfSxcbiAgICAgICAgICAgICAgICBwcm9wcy5mZ0NvbnRlbnQsXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWRheS1ib3R0b21cIiwgc3R5bGU6IHsgbWFyZ2luVG9wOiBwcm9wcy5tb3JlTWFyZ2luVG9wIH0gfSxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChUYWJsZUNlbGxNb3JlTGluaywgeyBhbGxEYXlEYXRlOiBkYXRlLCBzaW5nbGVQbGFjZW1lbnRzOiBwcm9wcy5zaW5nbGVQbGFjZW1lbnRzLCBtb3JlQ250OiBwcm9wcy5tb3JlQ250LCBhbGlnbm1lbnRFbFJlZjogcm9vdEVsUmVmLCBhbGlnbkdyaWRUb3A6ICFwcm9wcy5zaG93RGF5TnVtYmVyLCBleHRyYURhdGVTcGFuOiBwcm9wcy5leHRyYURhdGVTcGFuLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIGV2ZW50U2VsZWN0aW9uOiBwcm9wcy5ldmVudFNlbGVjdGlvbiwgZXZlbnREcmFnOiBwcm9wcy5ldmVudERyYWcsIGV2ZW50UmVzaXplOiBwcm9wcy5ldmVudFJlc2l6ZSwgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSB9KSkpLFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWRheS1iZ1wiIH0sIHByb3BzLmJnQ29udGVudCkpKSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbmRlclRvcElubmVyKHByb3BzKSB7XG4gICAgcmV0dXJuIHByb3BzLmRheU51bWJlclRleHQgfHwgY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCwgXCJcXHUwMEEwXCIpO1xufVxuZnVuY3Rpb24gc2hvdWxkRGlzcGxheU1vbnRoU3RhcnQoZGF0ZSwgY3VycmVudFJhbmdlLCBkYXRlRW52KSB7XG4gICAgY29uc3QgeyBzdGFydDogY3VycmVudFN0YXJ0LCBlbmQ6IGN1cnJlbnRFbmQgfSA9IGN1cnJlbnRSYW5nZTtcbiAgICBjb25zdCBjdXJyZW50RW5kSW5jbCA9IGFkZE1zKGN1cnJlbnRFbmQsIC0xKTtcbiAgICBjb25zdCBjdXJyZW50Rmlyc3RZZWFyID0gZGF0ZUVudi5nZXRZZWFyKGN1cnJlbnRTdGFydCk7XG4gICAgY29uc3QgY3VycmVudEZpcnN0TW9udGggPSBkYXRlRW52LmdldE1vbnRoKGN1cnJlbnRTdGFydCk7XG4gICAgY29uc3QgY3VycmVudExhc3RZZWFyID0gZGF0ZUVudi5nZXRZZWFyKGN1cnJlbnRFbmRJbmNsKTtcbiAgICBjb25zdCBjdXJyZW50TGFzdE1vbnRoID0gZGF0ZUVudi5nZXRNb250aChjdXJyZW50RW5kSW5jbCk7XG4gICAgLy8gc3BhbnMgbW9yZSB0aGFuIG9uZSBtb250aD9cbiAgICByZXR1cm4gIShjdXJyZW50Rmlyc3RZZWFyID09PSBjdXJyZW50TGFzdFllYXIgJiYgY3VycmVudEZpcnN0TW9udGggPT09IGN1cnJlbnRMYXN0TW9udGgpICYmXG4gICAgICAgIEJvb2xlYW4oXG4gICAgICAgIC8vIGZpcnN0IGRhdGUgaW4gY3VycmVudCB2aWV3P1xuICAgICAgICBkYXRlLnZhbHVlT2YoKSA9PT0gY3VycmVudFN0YXJ0LnZhbHVlT2YoKSB8fFxuICAgICAgICAgICAgLy8gYSBtb250aC1zdGFydCB0aGF0J3Mgd2l0aGluIHRoZSBjdXJyZW50IHJhbmdlP1xuICAgICAgICAgICAgKGRhdGVFbnYuZ2V0RGF5KGRhdGUpID09PSAxICYmIGRhdGUudmFsdWVPZigpIDwgY3VycmVudEVuZC52YWx1ZU9mKCkpKTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVTZWdLZXkoc2VnKSB7XG4gICAgcmV0dXJuIHNlZy5ldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWQgKyAnOicgKyBzZWcuZmlyc3RDb2w7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVNlZ1VpZChzZWcpIHtcbiAgICByZXR1cm4gZ2VuZXJhdGVTZWdLZXkoc2VnKSArICc6JyArIHNlZy5sYXN0Q29sO1xufVxuZnVuY3Rpb24gY29tcHV0ZUZnU2VnUGxhY2VtZW50KHNlZ3MsIC8vIGFzc3VtZWQgYWxyZWFkeSBzb3J0ZWRcbmRheU1heEV2ZW50cywgZGF5TWF4RXZlbnRSb3dzLCBzdHJpY3RPcmRlciwgc2VnSGVpZ2h0cywgbWF4Q29udGVudEhlaWdodCwgY2VsbHMpIHtcbiAgICBsZXQgaGllcmFyY2h5ID0gbmV3IERheUdyaWRTZWdIaWVyYXJjaHkoKHNlZ0VudHJ5KSA9PiB7XG4gICAgICAgIC8vIFRPRE86IG1vcmUgRFJZIHdpdGggZ2VuZXJhdGVTZWdVaWRcbiAgICAgICAgbGV0IHNlZ1VpZCA9IHNlZ3Nbc2VnRW50cnkuaW5kZXhdLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZCArXG4gICAgICAgICAgICAnOicgKyBzZWdFbnRyeS5zcGFuLnN0YXJ0ICtcbiAgICAgICAgICAgICc6JyArIChzZWdFbnRyeS5zcGFuLmVuZCAtIDEpO1xuICAgICAgICAvLyBpZiBubyB0aGlja25lc3Mga25vd24sIGFzc3VtZSAxIChpZiAwLCBzbyBzbWFsbCBpdCBhbHdheXMgZml0cylcbiAgICAgICAgcmV0dXJuIHNlZ0hlaWdodHNbc2VnVWlkXSB8fCAxO1xuICAgIH0pO1xuICAgIGhpZXJhcmNoeS5hbGxvd1Jlc2xpY2luZyA9IHRydWU7XG4gICAgaGllcmFyY2h5LnN0cmljdE9yZGVyID0gc3RyaWN0T3JkZXI7XG4gICAgaWYgKGRheU1heEV2ZW50cyA9PT0gdHJ1ZSB8fCBkYXlNYXhFdmVudFJvd3MgPT09IHRydWUpIHtcbiAgICAgICAgaGllcmFyY2h5Lm1heENvb3JkID0gbWF4Q29udGVudEhlaWdodDtcbiAgICAgICAgaGllcmFyY2h5LmhpZGRlbkNvbnN1bWVzID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRheU1heEV2ZW50cyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaGllcmFyY2h5Lm1heFN0YWNrQ250ID0gZGF5TWF4RXZlbnRzO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGF5TWF4RXZlbnRSb3dzID09PSAnbnVtYmVyJykge1xuICAgICAgICBoaWVyYXJjaHkubWF4U3RhY2tDbnQgPSBkYXlNYXhFdmVudFJvd3M7XG4gICAgICAgIGhpZXJhcmNoeS5oaWRkZW5Db25zdW1lcyA9IHRydWU7XG4gICAgfVxuICAgIC8vIGNyZWF0ZSBzZWdJbnB1dHMgb25seSBmb3Igc2VncyB3aXRoIGtub3duIGhlaWdodHNcbiAgICBsZXQgc2VnSW5wdXRzID0gW107XG4gICAgbGV0IHVua25vd25IZWlnaHRTZWdzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGxldCBzZWcgPSBzZWdzW2ldO1xuICAgICAgICBsZXQgc2VnVWlkID0gZ2VuZXJhdGVTZWdVaWQoc2VnKTtcbiAgICAgICAgbGV0IGV2ZW50SGVpZ2h0ID0gc2VnSGVpZ2h0c1tzZWdVaWRdO1xuICAgICAgICBpZiAoZXZlbnRIZWlnaHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2VnSW5wdXRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgIHNwYW46IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHNlZy5maXJzdENvbCxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBzZWcubGFzdENvbCArIDEsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdW5rbm93bkhlaWdodFNlZ3MucHVzaChzZWcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBoaWRkZW5FbnRyaWVzID0gaGllcmFyY2h5LmFkZFNlZ3Moc2VnSW5wdXRzKTtcbiAgICBsZXQgc2VnUmVjdHMgPSBoaWVyYXJjaHkudG9SZWN0cygpO1xuICAgIGxldCB7IHNpbmdsZUNvbFBsYWNlbWVudHMsIG11bHRpQ29sUGxhY2VtZW50cywgbGVmdG92ZXJNYXJnaW5zIH0gPSBwbGFjZVJlY3RzKHNlZ1JlY3RzLCBzZWdzLCBjZWxscyk7XG4gICAgbGV0IG1vcmVDbnRzID0gW107XG4gICAgbGV0IG1vcmVNYXJnaW5Ub3BzID0gW107XG4gICAgLy8gYWRkIHNlZ3Mgd2l0aCB1bmtub3duIGhlaWdodHNcbiAgICBmb3IgKGxldCBzZWcgb2YgdW5rbm93bkhlaWdodFNlZ3MpIHtcbiAgICAgICAgbXVsdGlDb2xQbGFjZW1lbnRzW3NlZy5maXJzdENvbF0ucHVzaCh7XG4gICAgICAgICAgICBzZWcsXG4gICAgICAgICAgICBpc1Zpc2libGU6IGZhbHNlLFxuICAgICAgICAgICAgaXNBYnNvbHV0ZTogdHJ1ZSxcbiAgICAgICAgICAgIGFic29sdXRlVG9wOiAwLFxuICAgICAgICAgICAgbWFyZ2luVG9wOiAwLFxuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChsZXQgY29sID0gc2VnLmZpcnN0Q29sOyBjb2wgPD0gc2VnLmxhc3RDb2w7IGNvbCArPSAxKSB7XG4gICAgICAgICAgICBzaW5nbGVDb2xQbGFjZW1lbnRzW2NvbF0ucHVzaCh7XG4gICAgICAgICAgICAgICAgc2VnOiByZXNsaWNlU2VnKHNlZywgY29sLCBjb2wgKyAxLCBjZWxscyksXG4gICAgICAgICAgICAgICAgaXNWaXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc0Fic29sdXRlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhYnNvbHV0ZVRvcDogMCxcbiAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6IDAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBhZGQgdGhlIGhpZGRlbiBlbnRyaWVzXG4gICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgY2VsbHMubGVuZ3RoOyBjb2wgKz0gMSkge1xuICAgICAgICBtb3JlQ250cy5wdXNoKDApO1xuICAgIH1cbiAgICBmb3IgKGxldCBoaWRkZW5FbnRyeSBvZiBoaWRkZW5FbnRyaWVzKSB7XG4gICAgICAgIGxldCBzZWcgPSBzZWdzW2hpZGRlbkVudHJ5LmluZGV4XTtcbiAgICAgICAgbGV0IGhpZGRlblNwYW4gPSBoaWRkZW5FbnRyeS5zcGFuO1xuICAgICAgICBtdWx0aUNvbFBsYWNlbWVudHNbaGlkZGVuU3Bhbi5zdGFydF0ucHVzaCh7XG4gICAgICAgICAgICBzZWc6IHJlc2xpY2VTZWcoc2VnLCBoaWRkZW5TcGFuLnN0YXJ0LCBoaWRkZW5TcGFuLmVuZCwgY2VsbHMpLFxuICAgICAgICAgICAgaXNWaXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGlzQWJzb2x1dGU6IHRydWUsXG4gICAgICAgICAgICBhYnNvbHV0ZVRvcDogMCxcbiAgICAgICAgICAgIG1hcmdpblRvcDogMCxcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAobGV0IGNvbCA9IGhpZGRlblNwYW4uc3RhcnQ7IGNvbCA8IGhpZGRlblNwYW4uZW5kOyBjb2wgKz0gMSkge1xuICAgICAgICAgICAgbW9yZUNudHNbY29sXSArPSAxO1xuICAgICAgICAgICAgc2luZ2xlQ29sUGxhY2VtZW50c1tjb2xdLnB1c2goe1xuICAgICAgICAgICAgICAgIHNlZzogcmVzbGljZVNlZyhzZWcsIGNvbCwgY29sICsgMSwgY2VsbHMpLFxuICAgICAgICAgICAgICAgIGlzVmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNBYnNvbHV0ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgYWJzb2x1dGVUb3A6IDAsXG4gICAgICAgICAgICAgICAgbWFyZ2luVG9wOiAwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZGVhbCB3aXRoIGxlZnRvdmVyIG1hcmdpbnNcbiAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjZWxscy5sZW5ndGg7IGNvbCArPSAxKSB7XG4gICAgICAgIG1vcmVNYXJnaW5Ub3BzLnB1c2gobGVmdG92ZXJNYXJnaW5zW2NvbF0pO1xuICAgIH1cbiAgICByZXR1cm4geyBzaW5nbGVDb2xQbGFjZW1lbnRzLCBtdWx0aUNvbFBsYWNlbWVudHMsIG1vcmVDbnRzLCBtb3JlTWFyZ2luVG9wcyB9O1xufVxuLy8gcmVjdHMgb3JkZXJlZCBieSB0b3AgY29vcmQsIHRoZW4gbGVmdFxuZnVuY3Rpb24gcGxhY2VSZWN0cyhhbGxSZWN0cywgc2VncywgY2VsbHMpIHtcbiAgICBsZXQgcmVjdHNCeUVhY2hDb2wgPSBncm91cFJlY3RzQnlFYWNoQ29sKGFsbFJlY3RzLCBjZWxscy5sZW5ndGgpO1xuICAgIGxldCBzaW5nbGVDb2xQbGFjZW1lbnRzID0gW107XG4gICAgbGV0IG11bHRpQ29sUGxhY2VtZW50cyA9IFtdO1xuICAgIGxldCBsZWZ0b3Zlck1hcmdpbnMgPSBbXTtcbiAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjZWxscy5sZW5ndGg7IGNvbCArPSAxKSB7XG4gICAgICAgIGxldCByZWN0cyA9IHJlY3RzQnlFYWNoQ29sW2NvbF07XG4gICAgICAgIC8vIGNvbXB1dGUgYWxsIHN0YXRpYyBzZWdzIGluIHNpbmdsZVBsYWNlbWVudHNcbiAgICAgICAgbGV0IHNpbmdsZVBsYWNlbWVudHMgPSBbXTtcbiAgICAgICAgbGV0IGN1cnJlbnRIZWlnaHQgPSAwO1xuICAgICAgICBsZXQgY3VycmVudE1hcmdpblRvcCA9IDA7XG4gICAgICAgIGZvciAobGV0IHJlY3Qgb2YgcmVjdHMpIHtcbiAgICAgICAgICAgIGxldCBzZWcgPSBzZWdzW3JlY3QuaW5kZXhdO1xuICAgICAgICAgICAgc2luZ2xlUGxhY2VtZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBzZWc6IHJlc2xpY2VTZWcoc2VnLCBjb2wsIGNvbCArIDEsIGNlbGxzKSxcbiAgICAgICAgICAgICAgICBpc1Zpc2libGU6IHRydWUsXG4gICAgICAgICAgICAgICAgaXNBYnNvbHV0ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgYWJzb2x1dGVUb3A6IHJlY3QubGV2ZWxDb29yZCxcbiAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6IHJlY3QubGV2ZWxDb29yZCAtIGN1cnJlbnRIZWlnaHQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGN1cnJlbnRIZWlnaHQgPSByZWN0LmxldmVsQ29vcmQgKyByZWN0LnRoaWNrbmVzcztcbiAgICAgICAgfVxuICAgICAgICAvLyBjb21wdXRlIG1peGVkIHN0YXRpYy9hYnNvbHV0ZSBzZWdzIGluIG11bHRpUGxhY2VtZW50c1xuICAgICAgICBsZXQgbXVsdGlQbGFjZW1lbnRzID0gW107XG4gICAgICAgIGN1cnJlbnRIZWlnaHQgPSAwO1xuICAgICAgICBjdXJyZW50TWFyZ2luVG9wID0gMDtcbiAgICAgICAgZm9yIChsZXQgcmVjdCBvZiByZWN0cykge1xuICAgICAgICAgICAgbGV0IHNlZyA9IHNlZ3NbcmVjdC5pbmRleF07XG4gICAgICAgICAgICBsZXQgaXNBYnNvbHV0ZSA9IHJlY3Quc3Bhbi5lbmQgLSByZWN0LnNwYW4uc3RhcnQgPiAxOyAvLyBtdWx0aS1jb2x1bW4/XG4gICAgICAgICAgICBsZXQgaXNGaXJzdENvbCA9IHJlY3Quc3Bhbi5zdGFydCA9PT0gY29sO1xuICAgICAgICAgICAgY3VycmVudE1hcmdpblRvcCArPSByZWN0LmxldmVsQ29vcmQgLSBjdXJyZW50SGVpZ2h0OyAvLyBhbW91bnQgb2Ygc3BhY2Ugc2luY2UgYm90dG9tIG9mIHByZXZpb3VzIHNlZ1xuICAgICAgICAgICAgY3VycmVudEhlaWdodCA9IHJlY3QubGV2ZWxDb29yZCArIHJlY3QudGhpY2tuZXNzOyAvLyBoZWlnaHQgd2lsbCBub3cgYmUgYm90dG9tIG9mIGN1cnJlbnQgc2VnXG4gICAgICAgICAgICBpZiAoaXNBYnNvbHV0ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRNYXJnaW5Ub3AgKz0gcmVjdC50aGlja25lc3M7XG4gICAgICAgICAgICAgICAgaWYgKGlzRmlyc3RDb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlQbGFjZW1lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VnOiByZXNsaWNlU2VnKHNlZywgcmVjdC5zcGFuLnN0YXJ0LCByZWN0LnNwYW4uZW5kLCBjZWxscyksXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1Zpc2libGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0Fic29sdXRlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWJzb2x1dGVUb3A6IHJlY3QubGV2ZWxDb29yZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpblRvcDogMCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNGaXJzdENvbCkge1xuICAgICAgICAgICAgICAgIG11bHRpUGxhY2VtZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgc2VnOiByZXNsaWNlU2VnKHNlZywgcmVjdC5zcGFuLnN0YXJ0LCByZWN0LnNwYW4uZW5kLCBjZWxscyksXG4gICAgICAgICAgICAgICAgICAgIGlzVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaXNBYnNvbHV0ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGFic29sdXRlVG9wOiByZWN0LmxldmVsQ29vcmQsXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpblRvcDogY3VycmVudE1hcmdpblRvcCwgLy8gY2xhaW0gdGhlIG1hcmdpblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRNYXJnaW5Ub3AgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNpbmdsZUNvbFBsYWNlbWVudHMucHVzaChzaW5nbGVQbGFjZW1lbnRzKTtcbiAgICAgICAgbXVsdGlDb2xQbGFjZW1lbnRzLnB1c2gobXVsdGlQbGFjZW1lbnRzKTtcbiAgICAgICAgbGVmdG92ZXJNYXJnaW5zLnB1c2goY3VycmVudE1hcmdpblRvcCk7XG4gICAgfVxuICAgIHJldHVybiB7IHNpbmdsZUNvbFBsYWNlbWVudHMsIG11bHRpQ29sUGxhY2VtZW50cywgbGVmdG92ZXJNYXJnaW5zIH07XG59XG5mdW5jdGlvbiBncm91cFJlY3RzQnlFYWNoQ29sKHJlY3RzLCBjb2xDbnQpIHtcbiAgICBsZXQgcmVjdHNCeUVhY2hDb2wgPSBbXTtcbiAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjb2xDbnQ7IGNvbCArPSAxKSB7XG4gICAgICAgIHJlY3RzQnlFYWNoQ29sLnB1c2goW10pO1xuICAgIH1cbiAgICBmb3IgKGxldCByZWN0IG9mIHJlY3RzKSB7XG4gICAgICAgIGZvciAobGV0IGNvbCA9IHJlY3Quc3Bhbi5zdGFydDsgY29sIDwgcmVjdC5zcGFuLmVuZDsgY29sICs9IDEpIHtcbiAgICAgICAgICAgIHJlY3RzQnlFYWNoQ29sW2NvbF0ucHVzaChyZWN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVjdHNCeUVhY2hDb2w7XG59XG5mdW5jdGlvbiByZXNsaWNlU2VnKHNlZywgc3BhblN0YXJ0LCBzcGFuRW5kLCBjZWxscykge1xuICAgIGlmIChzZWcuZmlyc3RDb2wgPT09IHNwYW5TdGFydCAmJiBzZWcubGFzdENvbCA9PT0gc3BhbkVuZCAtIDEpIHtcbiAgICAgICAgcmV0dXJuIHNlZztcbiAgICB9XG4gICAgbGV0IGV2ZW50UmFuZ2UgPSBzZWcuZXZlbnRSYW5nZTtcbiAgICBsZXQgb3JpZ1JhbmdlID0gZXZlbnRSYW5nZS5yYW5nZTtcbiAgICBsZXQgc2xpY2VkUmFuZ2UgPSBpbnRlcnNlY3RSYW5nZXMob3JpZ1JhbmdlLCB7XG4gICAgICAgIHN0YXJ0OiBjZWxsc1tzcGFuU3RhcnRdLmRhdGUsXG4gICAgICAgIGVuZDogYWRkRGF5cyhjZWxsc1tzcGFuRW5kIC0gMV0uZGF0ZSwgMSksXG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc2VnKSwgeyBmaXJzdENvbDogc3BhblN0YXJ0LCBsYXN0Q29sOiBzcGFuRW5kIC0gMSwgZXZlbnRSYW5nZToge1xuICAgICAgICAgICAgZGVmOiBldmVudFJhbmdlLmRlZixcbiAgICAgICAgICAgIHVpOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV2ZW50UmFuZ2UudWkpLCB7IGR1cmF0aW9uRWRpdGFibGU6IGZhbHNlIH0pLFxuICAgICAgICAgICAgaW5zdGFuY2U6IGV2ZW50UmFuZ2UuaW5zdGFuY2UsXG4gICAgICAgICAgICByYW5nZTogc2xpY2VkUmFuZ2UsXG4gICAgICAgIH0sIGlzU3RhcnQ6IHNlZy5pc1N0YXJ0ICYmIHNsaWNlZFJhbmdlLnN0YXJ0LnZhbHVlT2YoKSA9PT0gb3JpZ1JhbmdlLnN0YXJ0LnZhbHVlT2YoKSwgaXNFbmQ6IHNlZy5pc0VuZCAmJiBzbGljZWRSYW5nZS5lbmQudmFsdWVPZigpID09PSBvcmlnUmFuZ2UuZW5kLnZhbHVlT2YoKSB9KTtcbn1cbmNsYXNzIERheUdyaWRTZWdIaWVyYXJjaHkgZXh0ZW5kcyBTZWdIaWVyYXJjaHkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAvLyBjb25maWdcbiAgICAgICAgdGhpcy5oaWRkZW5Db25zdW1lcyA9IGZhbHNlO1xuICAgICAgICAvLyBhbGxvd3MgdXMgdG8ga2VlcCBoaWRkZW4gZW50cmllcyBpbiB0aGUgaGllcmFyY2h5IHNvIHRoZXkgdGFrZSB1cCBzcGFjZVxuICAgICAgICB0aGlzLmZvcmNlSGlkZGVuID0ge307XG4gICAgfVxuICAgIGFkZFNlZ3Moc2VnSW5wdXRzKSB7XG4gICAgICAgIGNvbnN0IGhpZGRlblNlZ3MgPSBzdXBlci5hZGRTZWdzKHNlZ0lucHV0cyk7XG4gICAgICAgIGNvbnN0IHsgZW50cmllc0J5TGV2ZWwgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGV4Y2x1ZGVIaWRkZW4gPSAoZW50cnkpID0+ICF0aGlzLmZvcmNlSGlkZGVuW2J1aWxkRW50cnlLZXkoZW50cnkpXTtcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBmb3JjZWQtaGlkZGVuIHNlZ3NcbiAgICAgICAgZm9yIChsZXQgbGV2ZWwgPSAwOyBsZXZlbCA8IGVudHJpZXNCeUxldmVsLmxlbmd0aDsgbGV2ZWwgKz0gMSkge1xuICAgICAgICAgICAgZW50cmllc0J5TGV2ZWxbbGV2ZWxdID0gZW50cmllc0J5TGV2ZWxbbGV2ZWxdLmZpbHRlcihleGNsdWRlSGlkZGVuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGlkZGVuU2VncztcbiAgICB9XG4gICAgaGFuZGxlSW52YWxpZEluc2VydGlvbihpbnNlcnRpb24sIGVudHJ5LCBoaWRkZW5FbnRyaWVzKSB7XG4gICAgICAgIGNvbnN0IHsgZW50cmllc0J5TGV2ZWwsIGZvcmNlSGlkZGVuIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHRvdWNoaW5nRW50cnksIHRvdWNoaW5nTGV2ZWwsIHRvdWNoaW5nTGF0ZXJhbCB9ID0gaW5zZXJ0aW9uO1xuICAgICAgICAvLyB0aGUgZW50cnkgdGhhdCB0aGUgbmV3IGluc2VydGlvbiBpcyB0b3VjaGluZyBtdXN0IGJlIGhpZGRlblxuICAgICAgICBpZiAodGhpcy5oaWRkZW5Db25zdW1lcyAmJiB0b3VjaGluZ0VudHJ5KSB7XG4gICAgICAgICAgICBjb25zdCB0b3VjaGluZ0VudHJ5SWQgPSBidWlsZEVudHJ5S2V5KHRvdWNoaW5nRW50cnkpO1xuICAgICAgICAgICAgaWYgKCFmb3JjZUhpZGRlblt0b3VjaGluZ0VudHJ5SWRdKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYWxsb3dSZXNsaWNpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3BsaXQgdXAgdGhlIHRvdWNoaW5nRW50cnksIHJlaW5zZXJ0IGl0XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhpZGRlbkVudHJ5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0b3VjaGluZ0VudHJ5KSwgeyBzcGFuOiBpbnRlcnNlY3RTcGFucyh0b3VjaGluZ0VudHJ5LnNwYW4sIGVudHJ5LnNwYW4pIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyByZWluc2VydCB0aGUgYXJlYSB0aGF0IHR1cm5lZCBpbnRvIGEgXCJtb3JlXCIgbGluayAoc28gbm8gb3RoZXIgZW50cmllcyB0cnkgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gb2NjdXB5IHRoZSBzcGFjZSkgYnV0IG1hcmsgaXQgZm9yY2VkLWhpZGRlblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBoaWRkZW5FbnRyeUlkID0gYnVpbGRFbnRyeUtleShoaWRkZW5FbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgIGZvcmNlSGlkZGVuW2hpZGRlbkVudHJ5SWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZW50cmllc0J5TGV2ZWxbdG91Y2hpbmdMZXZlbF1bdG91Y2hpbmdMYXRlcmFsXSA9IGhpZGRlbkVudHJ5O1xuICAgICAgICAgICAgICAgICAgICBoaWRkZW5FbnRyaWVzLnB1c2goaGlkZGVuRW50cnkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwbGl0RW50cnkodG91Y2hpbmdFbnRyeSwgZW50cnksIGhpZGRlbkVudHJpZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VIaWRkZW5bdG91Y2hpbmdFbnRyeUlkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGhpZGRlbkVudHJpZXMucHVzaCh0b3VjaGluZ0VudHJ5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2lsbCB0cnkgdG8gcmVzbGljZS4uLlxuICAgICAgICBzdXBlci5oYW5kbGVJbnZhbGlkSW5zZXJ0aW9uKGluc2VydGlvbiwgZW50cnksIGhpZGRlbkVudHJpZXMpO1xuICAgIH1cbn1cblxuY2xhc3MgVGFibGVSb3cgZXh0ZW5kcyBEYXRlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5jZWxsRWxSZWZzID0gbmV3IFJlZk1hcCgpOyAvLyB0aGUgPHRkPlxuICAgICAgICB0aGlzLmZyYW1lRWxSZWZzID0gbmV3IFJlZk1hcCgpOyAvLyB0aGUgZmMtZGF5Z3JpZC1kYXktZnJhbWVcbiAgICAgICAgdGhpcy5mZ0VsUmVmcyA9IG5ldyBSZWZNYXAoKTsgLy8gdGhlIGZjLWRheWdyaWQtZGF5LWV2ZW50c1xuICAgICAgICB0aGlzLnNlZ0hhcm5lc3NSZWZzID0gbmV3IFJlZk1hcCgpOyAvLyBpbmRleGVkIGJ5IFwiaW5zdGFuY2VJZDpmaXJzdENvbFwiXG4gICAgICAgIHRoaXMucm9vdEVsUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBmcmFtZVBvc2l0aW9uczogbnVsbCxcbiAgICAgICAgICAgIG1heENvbnRlbnRIZWlnaHQ6IG51bGwsXG4gICAgICAgICAgICBzZWdIZWlnaHRzOiB7fSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVSZXNpemUgPSAoaXNGb3JjZWQpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0ZvcmNlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU2l6aW5nKHRydWUpOyAvLyBpc0V4dGVybmFsPXRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgc3RhdGUsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgICAgIGxldCBjb2xDbnQgPSBwcm9wcy5jZWxscy5sZW5ndGg7XG4gICAgICAgIGxldCBidXNpbmVzc0hvdXJzQnlDb2wgPSBzcGxpdFNlZ3NCeUZpcnN0Q29sKHByb3BzLmJ1c2luZXNzSG91clNlZ3MsIGNvbENudCk7XG4gICAgICAgIGxldCBiZ0V2ZW50U2Vnc0J5Q29sID0gc3BsaXRTZWdzQnlGaXJzdENvbChwcm9wcy5iZ0V2ZW50U2VncywgY29sQ250KTtcbiAgICAgICAgbGV0IGhpZ2hsaWdodFNlZ3NCeUNvbCA9IHNwbGl0U2Vnc0J5Rmlyc3RDb2wodGhpcy5nZXRIaWdobGlnaHRTZWdzKCksIGNvbENudCk7XG4gICAgICAgIGxldCBtaXJyb3JTZWdzQnlDb2wgPSBzcGxpdFNlZ3NCeUZpcnN0Q29sKHRoaXMuZ2V0TWlycm9yU2VncygpLCBjb2xDbnQpO1xuICAgICAgICBsZXQgeyBzaW5nbGVDb2xQbGFjZW1lbnRzLCBtdWx0aUNvbFBsYWNlbWVudHMsIG1vcmVDbnRzLCBtb3JlTWFyZ2luVG9wcyB9ID0gY29tcHV0ZUZnU2VnUGxhY2VtZW50KHNvcnRFdmVudFNlZ3MocHJvcHMuZmdFdmVudFNlZ3MsIG9wdGlvbnMuZXZlbnRPcmRlciksIHByb3BzLmRheU1heEV2ZW50cywgcHJvcHMuZGF5TWF4RXZlbnRSb3dzLCBvcHRpb25zLmV2ZW50T3JkZXJTdHJpY3QsIHN0YXRlLnNlZ0hlaWdodHMsIHN0YXRlLm1heENvbnRlbnRIZWlnaHQsIHByb3BzLmNlbGxzKTtcbiAgICAgICAgbGV0IGlzRm9yY2VkSW52aXNpYmxlID0gLy8gVE9ETzogbWVzc3kgd2F5IHRvIGNvbXB1dGUgdGhpc1xuICAgICAgICAgKHByb3BzLmV2ZW50RHJhZyAmJiBwcm9wcy5ldmVudERyYWcuYWZmZWN0ZWRJbnN0YW5jZXMpIHx8XG4gICAgICAgICAgICAocHJvcHMuZXZlbnRSZXNpemUgJiYgcHJvcHMuZXZlbnRSZXNpemUuYWZmZWN0ZWRJbnN0YW5jZXMpIHx8XG4gICAgICAgICAgICB7fTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwidHJcIiwgeyByZWY6IHRoaXMucm9vdEVsUmVmLCByb2xlOiBcInJvd1wiIH0sXG4gICAgICAgICAgICBwcm9wcy5yZW5kZXJJbnRybyAmJiBwcm9wcy5yZW5kZXJJbnRybygpLFxuICAgICAgICAgICAgcHJvcHMuY2VsbHMubWFwKChjZWxsLCBjb2wpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgbm9ybWFsRmdOb2RlcyA9IHRoaXMucmVuZGVyRmdTZWdzKGNvbCwgcHJvcHMuZm9yUHJpbnQgPyBzaW5nbGVDb2xQbGFjZW1lbnRzW2NvbF0gOiBtdWx0aUNvbFBsYWNlbWVudHNbY29sXSwgcHJvcHMudG9kYXlSYW5nZSwgaXNGb3JjZWRJbnZpc2libGUpO1xuICAgICAgICAgICAgICAgIGxldCBtaXJyb3JGZ05vZGVzID0gdGhpcy5yZW5kZXJGZ1NlZ3MoY29sLCBidWlsZE1pcnJvclBsYWNlbWVudHMobWlycm9yU2Vnc0J5Q29sW2NvbF0sIG11bHRpQ29sUGxhY2VtZW50cyksIHByb3BzLnRvZGF5UmFuZ2UsIHt9LCBCb29sZWFuKHByb3BzLmV2ZW50RHJhZyksIEJvb2xlYW4ocHJvcHMuZXZlbnRSZXNpemUpLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFRhYmxlQ2VsbCwgeyBrZXk6IGNlbGwua2V5LCBlbFJlZjogdGhpcy5jZWxsRWxSZWZzLmNyZWF0ZVJlZihjZWxsLmtleSksIGlubmVyRWxSZWY6IHRoaXMuZnJhbWVFbFJlZnMuY3JlYXRlUmVmKGNlbGwua2V5KSAvKiBGRiA8dGQ+IHByb2JsZW0sIGJ1dCBva2F5IHRvIHVzZSBmb3IgbGVmdC9yaWdodC4gVE9ETzogcmVuYW1lIHByb3AgKi8sIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgZGF0ZTogY2VsbC5kYXRlLCBzaG93RGF5TnVtYmVyOiBwcm9wcy5zaG93RGF5TnVtYmVycywgc2hvd1dlZWtOdW1iZXI6IHByb3BzLnNob3dXZWVrTnVtYmVycyAmJiBjb2wgPT09IDAsIGZvcmNlRGF5VG9wOiBwcm9wcy5zaG93V2Vla051bWJlcnMgLyogZXZlbiBkaXNwbGF5aW5nIHdlZWtudW0gZm9yIHJvdywgbm90IG5lY2Vzc2FyaWx5IGRheSAqLywgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSwgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBldmVudERyYWc6IHByb3BzLmV2ZW50RHJhZywgZXZlbnRSZXNpemU6IHByb3BzLmV2ZW50UmVzaXplLCBleHRyYVJlbmRlclByb3BzOiBjZWxsLmV4dHJhUmVuZGVyUHJvcHMsIGV4dHJhRGF0YUF0dHJzOiBjZWxsLmV4dHJhRGF0YUF0dHJzLCBleHRyYUNsYXNzTmFtZXM6IGNlbGwuZXh0cmFDbGFzc05hbWVzLCBleHRyYURhdGVTcGFuOiBjZWxsLmV4dHJhRGF0ZVNwYW4sIG1vcmVDbnQ6IG1vcmVDbnRzW2NvbF0sIG1vcmVNYXJnaW5Ub3A6IG1vcmVNYXJnaW5Ub3BzW2NvbF0sIHNpbmdsZVBsYWNlbWVudHM6IHNpbmdsZUNvbFBsYWNlbWVudHNbY29sXSwgZmdDb250ZW50RWxSZWY6IHRoaXMuZmdFbFJlZnMuY3JlYXRlUmVmKGNlbGwua2V5KSwgZmdDb250ZW50OiAoIC8vIEZyYWdtZW50IHNjb3BlcyB0aGUga2V5c1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCwgbm9ybWFsRmdOb2RlcyksXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBtaXJyb3JGZ05vZGVzKSkpLCBiZ0NvbnRlbnQ6ICggLy8gRnJhZ21lbnQgc2NvcGVzIHRoZSBrZXlzXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckZpbGxTZWdzKGhpZ2hsaWdodFNlZ3NCeUNvbFtjb2xdLCAnaGlnaGxpZ2h0JyksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckZpbGxTZWdzKGJ1c2luZXNzSG91cnNCeUNvbFtjb2xdLCAnbm9uLWJ1c2luZXNzJyksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckZpbGxTZWdzKGJnRXZlbnRTZWdzQnlDb2xbY29sXSwgJ2JnLWV2ZW50JykpKSwgbWluSGVpZ2h0OiBwcm9wcy5jZWxsTWluSGVpZ2h0IH0pKTtcbiAgICAgICAgICAgIH0pKSk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVNpemluZyh0cnVlKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmFkZFJlc2l6ZUhhbmRsZXIodGhpcy5oYW5kbGVSZXNpemUpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUpIHtcbiAgICAgICAgbGV0IGN1cnJlbnRQcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHRoaXMudXBkYXRlU2l6aW5nKCFpc1Byb3BzRXF1YWwocHJldlByb3BzLCBjdXJyZW50UHJvcHMpKTtcbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5yZW1vdmVSZXNpemVIYW5kbGVyKHRoaXMuaGFuZGxlUmVzaXplKTtcbiAgICB9XG4gICAgZ2V0SGlnaGxpZ2h0U2VncygpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGlmIChwcm9wcy5ldmVudERyYWcgJiYgcHJvcHMuZXZlbnREcmFnLnNlZ3MubGVuZ3RoKSB7IC8vIG1lc3N5IGNoZWNrXG4gICAgICAgICAgICByZXR1cm4gcHJvcHMuZXZlbnREcmFnLnNlZ3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BzLmV2ZW50UmVzaXplICYmIHByb3BzLmV2ZW50UmVzaXplLnNlZ3MubGVuZ3RoKSB7IC8vIG1lc3N5IGNoZWNrXG4gICAgICAgICAgICByZXR1cm4gcHJvcHMuZXZlbnRSZXNpemUuc2VncztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvcHMuZGF0ZVNlbGVjdGlvblNlZ3M7XG4gICAgfVxuICAgIGdldE1pcnJvclNlZ3MoKSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBpZiAocHJvcHMuZXZlbnRSZXNpemUgJiYgcHJvcHMuZXZlbnRSZXNpemUuc2Vncy5sZW5ndGgpIHsgLy8gbWVzc3kgY2hlY2tcbiAgICAgICAgICAgIHJldHVybiBwcm9wcy5ldmVudFJlc2l6ZS5zZWdzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmVuZGVyRmdTZWdzKGNvbCwgc2VnUGxhY2VtZW50cywgdG9kYXlSYW5nZSwgaXNGb3JjZWRJbnZpc2libGUsIGlzRHJhZ2dpbmcsIGlzUmVzaXppbmcsIGlzRGF0ZVNlbGVjdGluZykge1xuICAgICAgICBsZXQgeyBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBldmVudFNlbGVjdGlvbiB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IHsgZnJhbWVQb3NpdGlvbnMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGxldCBkZWZhdWx0RGlzcGxheUV2ZW50RW5kID0gdGhpcy5wcm9wcy5jZWxscy5sZW5ndGggPT09IDE7IC8vIGNvbENudCA9PT0gMVxuICAgICAgICBsZXQgaXNNaXJyb3IgPSBpc0RyYWdnaW5nIHx8IGlzUmVzaXppbmcgfHwgaXNEYXRlU2VsZWN0aW5nO1xuICAgICAgICBsZXQgbm9kZXMgPSBbXTtcbiAgICAgICAgaWYgKGZyYW1lUG9zaXRpb25zKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBwbGFjZW1lbnQgb2Ygc2VnUGxhY2VtZW50cykge1xuICAgICAgICAgICAgICAgIGxldCB7IHNlZyB9ID0gcGxhY2VtZW50O1xuICAgICAgICAgICAgICAgIGxldCB7IGluc3RhbmNlSWQgfSA9IHNlZy5ldmVudFJhbmdlLmluc3RhbmNlO1xuICAgICAgICAgICAgICAgIGxldCBpc1Zpc2libGUgPSBwbGFjZW1lbnQuaXNWaXNpYmxlICYmICFpc0ZvcmNlZEludmlzaWJsZVtpbnN0YW5jZUlkXTtcbiAgICAgICAgICAgICAgICBsZXQgaXNBYnNvbHV0ZSA9IHBsYWNlbWVudC5pc0Fic29sdXRlO1xuICAgICAgICAgICAgICAgIGxldCBsZWZ0ID0gJyc7XG4gICAgICAgICAgICAgICAgbGV0IHJpZ2h0ID0gJyc7XG4gICAgICAgICAgICAgICAgaWYgKGlzQWJzb2x1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuaXNSdGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBmcmFtZVBvc2l0aW9ucy5sZWZ0c1tzZWcubGFzdENvbF0gLSBmcmFtZVBvc2l0aW9ucy5sZWZ0c1tzZWcuZmlyc3RDb2xdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IGZyYW1lUG9zaXRpb25zLnJpZ2h0c1tzZWcuZmlyc3RDb2xdIC0gZnJhbWVQb3NpdGlvbnMucmlnaHRzW3NlZy5sYXN0Q29sXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgIGtub3duIGJ1ZzogZXZlbnRzIHRoYXQgYXJlIGZvcmNlIHRvIGJlIGxpc3QtaXRlbSBidXQgc3BhbiBtdWx0aXBsZSBkYXlzIHN0aWxsIHRha2UgdXAgc3BhY2UgaW4gbGF0ZXIgY29sdW1uc1xuICAgICAgICAgICAgICAgIHRvZG86IGluIHByaW50IHZpZXcsIGZvciBtdWx0aS1kYXkgZXZlbnRzLCBkb24ndCBkaXNwbGF5IHRpdGxlIHdpdGhpbiBub24tc3RhcnQvZW5kIHNlZ3NcbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogJ2ZjLWRheWdyaWQtZXZlbnQtaGFybmVzcycgKyAoaXNBYnNvbHV0ZSA/ICcgZmMtZGF5Z3JpZC1ldmVudC1oYXJuZXNzLWFicycgOiAnJyksIGtleTogZ2VuZXJhdGVTZWdLZXkoc2VnKSwgcmVmOiBpc01pcnJvciA/IG51bGwgOiB0aGlzLnNlZ0hhcm5lc3NSZWZzLmNyZWF0ZVJlZihnZW5lcmF0ZVNlZ1VpZChzZWcpKSwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IGlzVmlzaWJsZSA/ICcnIDogJ2hpZGRlbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6IGlzQWJzb2x1dGUgPyAnJyA6IHBsYWNlbWVudC5tYXJnaW5Ub3AsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IGlzQWJzb2x1dGUgPyBwbGFjZW1lbnQuYWJzb2x1dGVUb3AgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCxcbiAgICAgICAgICAgICAgICAgICAgfSB9LCBoYXNMaXN0SXRlbURpc3BsYXkoc2VnKSA/IChjcmVhdGVFbGVtZW50KFRhYmxlTGlzdEl0ZW1FdmVudCwgT2JqZWN0LmFzc2lnbih7IHNlZzogc2VnLCBpc0RyYWdnaW5nOiBpc0RyYWdnaW5nLCBpc1NlbGVjdGVkOiBpbnN0YW5jZUlkID09PSBldmVudFNlbGVjdGlvbiwgZGVmYXVsdERpc3BsYXlFdmVudEVuZDogZGVmYXVsdERpc3BsYXlFdmVudEVuZCB9LCBnZXRTZWdNZXRhKHNlZywgdG9kYXlSYW5nZSkpKSkgOiAoY3JlYXRlRWxlbWVudChUYWJsZUJsb2NrRXZlbnQsIE9iamVjdC5hc3NpZ24oeyBzZWc6IHNlZywgaXNEcmFnZ2luZzogaXNEcmFnZ2luZywgaXNSZXNpemluZzogaXNSZXNpemluZywgaXNEYXRlU2VsZWN0aW5nOiBpc0RhdGVTZWxlY3RpbmcsIGlzU2VsZWN0ZWQ6IGluc3RhbmNlSWQgPT09IGV2ZW50U2VsZWN0aW9uLCBkZWZhdWx0RGlzcGxheUV2ZW50RW5kOiBkZWZhdWx0RGlzcGxheUV2ZW50RW5kIH0sIGdldFNlZ01ldGEoc2VnLCB0b2RheVJhbmdlKSkpKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG4gICAgcmVuZGVyRmlsbFNlZ3Moc2VncywgZmlsbFR5cGUpIHtcbiAgICAgICAgbGV0IHsgaXNSdGwgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHsgdG9kYXlSYW5nZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IHsgZnJhbWVQb3NpdGlvbnMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGxldCBub2RlcyA9IFtdO1xuICAgICAgICBpZiAoZnJhbWVQb3NpdGlvbnMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHNlZyBvZiBzZWdzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxlZnRSaWdodENzcyA9IGlzUnRsID8ge1xuICAgICAgICAgICAgICAgICAgICByaWdodDogMCxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogZnJhbWVQb3NpdGlvbnMubGVmdHNbc2VnLmxhc3RDb2xdIC0gZnJhbWVQb3NpdGlvbnMubGVmdHNbc2VnLmZpcnN0Q29sXSxcbiAgICAgICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgICAgICByaWdodDogZnJhbWVQb3NpdGlvbnMucmlnaHRzW3NlZy5maXJzdENvbF0gLSBmcmFtZVBvc2l0aW9ucy5yaWdodHNbc2VnLmxhc3RDb2xdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsga2V5OiBidWlsZEV2ZW50UmFuZ2VLZXkoc2VnLmV2ZW50UmFuZ2UpLCBjbGFzc05hbWU6IFwiZmMtZGF5Z3JpZC1iZy1oYXJuZXNzXCIsIHN0eWxlOiBsZWZ0UmlnaHRDc3MgfSwgZmlsbFR5cGUgPT09ICdiZy1ldmVudCcgP1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KEJnRXZlbnQsIE9iamVjdC5hc3NpZ24oeyBzZWc6IHNlZyB9LCBnZXRTZWdNZXRhKHNlZywgdG9kYXlSYW5nZSkpKSA6XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlckZpbGwoZmlsbFR5cGUpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIHt9LCAuLi5ub2Rlcyk7XG4gICAgfVxuICAgIHVwZGF0ZVNpemluZyhpc0V4dGVybmFsU2l6aW5nQ2hhbmdlKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBzdGF0ZSwgZnJhbWVFbFJlZnMgfSA9IHRoaXM7XG4gICAgICAgIGlmICghcHJvcHMuZm9yUHJpbnQgJiZcbiAgICAgICAgICAgIHByb3BzLmNsaWVudFdpZHRoICE9PSBudWxsIC8vIHBvc2l0aW9uaW5nIHJlYWR5P1xuICAgICAgICApIHtcbiAgICAgICAgICAgIGlmIChpc0V4dGVybmFsU2l6aW5nQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyYW1lRWxzID0gcHJvcHMuY2VsbHMubWFwKChjZWxsKSA9PiBmcmFtZUVsUmVmcy5jdXJyZW50TWFwW2NlbGwua2V5XSk7XG4gICAgICAgICAgICAgICAgaWYgKGZyYW1lRWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb3JpZ2luRWwgPSB0aGlzLnJvb3RFbFJlZi5jdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3UG9zaXRpb25DYWNoZSA9IG5ldyBQb3NpdGlvbkNhY2hlKG9yaWdpbkVsLCBmcmFtZUVscywgdHJ1ZSwgLy8gaXNIb3Jpem9udGFsXG4gICAgICAgICAgICAgICAgICAgIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5mcmFtZVBvc2l0aW9ucyB8fCAhc3RhdGUuZnJhbWVQb3NpdGlvbnMuc2ltaWxhclRvKG5ld1Bvc2l0aW9uQ2FjaGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZVBvc2l0aW9uczogbmV3IFBvc2l0aW9uQ2FjaGUob3JpZ2luRWwsIGZyYW1lRWxzLCB0cnVlLCAvLyBpc0hvcml6b250YWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9sZFNlZ0hlaWdodHMgPSB0aGlzLnN0YXRlLnNlZ0hlaWdodHM7XG4gICAgICAgICAgICBjb25zdCBuZXdTZWdIZWlnaHRzID0gdGhpcy5xdWVyeVNlZ0hlaWdodHMoKTtcbiAgICAgICAgICAgIGNvbnN0IGxpbWl0QnlDb250ZW50SGVpZ2h0ID0gcHJvcHMuZGF5TWF4RXZlbnRzID09PSB0cnVlIHx8IHByb3BzLmRheU1heEV2ZW50Um93cyA9PT0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc2FmZVNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAvLyBIQUNLIHRvIHByZXZlbnQgb3NjaWxsYXRpb25zIG9mIGV2ZW50cyBiZWluZyBzaG93bi9oaWRkZW4gZnJvbSBtYXgtZXZlbnQtcm93c1xuICAgICAgICAgICAgICAgIC8vIEVzc2VudGlhbGx5LCBvbmNlIHlvdSBjb21wdXRlIGFuIGVsZW1lbnQncyBoZWlnaHQsIG5ldmVyIG51bGwtb3V0LlxuICAgICAgICAgICAgICAgIC8vIFRPRE86IGFsd2F5cyBkaXNwbGF5IGFsbCBldmVudHMsIGFzIHZpc2liaWxpdHk6aGlkZGVuP1xuICAgICAgICAgICAgICAgIHNlZ0hlaWdodHM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb2xkU2VnSGVpZ2h0cyksIG5ld1NlZ0hlaWdodHMpLFxuICAgICAgICAgICAgICAgIG1heENvbnRlbnRIZWlnaHQ6IGxpbWl0QnlDb250ZW50SGVpZ2h0ID8gdGhpcy5jb21wdXRlTWF4Q29udGVudEhlaWdodCgpIDogbnVsbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXJ5U2VnSGVpZ2h0cygpIHtcbiAgICAgICAgbGV0IHNlZ0VsTWFwID0gdGhpcy5zZWdIYXJuZXNzUmVmcy5jdXJyZW50TWFwO1xuICAgICAgICBsZXQgc2VnSGVpZ2h0cyA9IHt9O1xuICAgICAgICAvLyBnZXQgdGhlIG1heCBoZWlnaHQgYW1vbmdzdCBpbnN0YW5jZSBzZWdzXG4gICAgICAgIGZvciAobGV0IHNlZ1VpZCBpbiBzZWdFbE1hcCkge1xuICAgICAgICAgICAgbGV0IGhlaWdodCA9IE1hdGgucm91bmQoc2VnRWxNYXBbc2VnVWlkXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQpO1xuICAgICAgICAgICAgc2VnSGVpZ2h0c1tzZWdVaWRdID0gTWF0aC5tYXgoc2VnSGVpZ2h0c1tzZWdVaWRdIHx8IDAsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlZ0hlaWdodHM7XG4gICAgfVxuICAgIGNvbXB1dGVNYXhDb250ZW50SGVpZ2h0KCkge1xuICAgICAgICBsZXQgZmlyc3RLZXkgPSB0aGlzLnByb3BzLmNlbGxzWzBdLmtleTtcbiAgICAgICAgbGV0IGNlbGxFbCA9IHRoaXMuY2VsbEVsUmVmcy5jdXJyZW50TWFwW2ZpcnN0S2V5XTtcbiAgICAgICAgbGV0IGZjQ29udGFpbmVyRWwgPSB0aGlzLmZnRWxSZWZzLmN1cnJlbnRNYXBbZmlyc3RLZXldO1xuICAgICAgICByZXR1cm4gY2VsbEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbSAtIGZjQ29udGFpbmVyRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xuICAgIH1cbiAgICBnZXRDZWxsRWxzKCkge1xuICAgICAgICBsZXQgZWxNYXAgPSB0aGlzLmNlbGxFbFJlZnMuY3VycmVudE1hcDtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY2VsbHMubWFwKChjZWxsKSA9PiBlbE1hcFtjZWxsLmtleV0pO1xuICAgIH1cbn1cblRhYmxlUm93LmFkZFN0YXRlRXF1YWxpdHkoe1xuICAgIHNlZ0hlaWdodHM6IGlzUHJvcHNFcXVhbCxcbn0pO1xuZnVuY3Rpb24gYnVpbGRNaXJyb3JQbGFjZW1lbnRzKG1pcnJvclNlZ3MsIGNvbFBsYWNlbWVudHMpIHtcbiAgICBpZiAoIW1pcnJvclNlZ3MubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgbGV0IHRvcHNCeUluc3RhbmNlSWQgPSBidWlsZEFic29sdXRlVG9wSGFzaChjb2xQbGFjZW1lbnRzKTsgLy8gVE9ETzogY2FjaGUgdGhpcyBhdCBmaXJzdCByZW5kZXI/XG4gICAgcmV0dXJuIG1pcnJvclNlZ3MubWFwKChzZWcpID0+ICh7XG4gICAgICAgIHNlZyxcbiAgICAgICAgaXNWaXNpYmxlOiB0cnVlLFxuICAgICAgICBpc0Fic29sdXRlOiB0cnVlLFxuICAgICAgICBhYnNvbHV0ZVRvcDogdG9wc0J5SW5zdGFuY2VJZFtzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkXSxcbiAgICAgICAgbWFyZ2luVG9wOiAwLFxuICAgIH0pKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkQWJzb2x1dGVUb3BIYXNoKGNvbFBsYWNlbWVudHMpIHtcbiAgICBsZXQgdG9wc0J5SW5zdGFuY2VJZCA9IHt9O1xuICAgIGZvciAobGV0IHBsYWNlbWVudHMgb2YgY29sUGxhY2VtZW50cykge1xuICAgICAgICBmb3IgKGxldCBwbGFjZW1lbnQgb2YgcGxhY2VtZW50cykge1xuICAgICAgICAgICAgdG9wc0J5SW5zdGFuY2VJZFtwbGFjZW1lbnQuc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZF0gPSBwbGFjZW1lbnQuYWJzb2x1dGVUb3A7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvcHNCeUluc3RhbmNlSWQ7XG59XG5cbmNsYXNzIFRhYmxlUm93cyBleHRlbmRzIERhdGVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnNwbGl0QnVzaW5lc3NIb3VyU2VncyA9IG1lbW9pemUoc3BsaXRTZWdzQnlSb3cpO1xuICAgICAgICB0aGlzLnNwbGl0QmdFdmVudFNlZ3MgPSBtZW1vaXplKHNwbGl0U2Vnc0J5Um93KTtcbiAgICAgICAgdGhpcy5zcGxpdEZnRXZlbnRTZWdzID0gbWVtb2l6ZShzcGxpdFNlZ3NCeVJvdyk7XG4gICAgICAgIHRoaXMuc3BsaXREYXRlU2VsZWN0aW9uU2VncyA9IG1lbW9pemUoc3BsaXRTZWdzQnlSb3cpO1xuICAgICAgICB0aGlzLnNwbGl0RXZlbnREcmFnID0gbWVtb2l6ZShzcGxpdEludGVyYWN0aW9uQnlSb3cpO1xuICAgICAgICB0aGlzLnNwbGl0RXZlbnRSZXNpemUgPSBtZW1vaXplKHNwbGl0SW50ZXJhY3Rpb25CeVJvdyk7XG4gICAgICAgIHRoaXMucm93UmVmcyA9IG5ldyBSZWZNYXAoKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHJvd0NudCA9IHByb3BzLmNlbGxzLmxlbmd0aDtcbiAgICAgICAgbGV0IGJ1c2luZXNzSG91clNlZ3NCeVJvdyA9IHRoaXMuc3BsaXRCdXNpbmVzc0hvdXJTZWdzKHByb3BzLmJ1c2luZXNzSG91clNlZ3MsIHJvd0NudCk7XG4gICAgICAgIGxldCBiZ0V2ZW50U2Vnc0J5Um93ID0gdGhpcy5zcGxpdEJnRXZlbnRTZWdzKHByb3BzLmJnRXZlbnRTZWdzLCByb3dDbnQpO1xuICAgICAgICBsZXQgZmdFdmVudFNlZ3NCeVJvdyA9IHRoaXMuc3BsaXRGZ0V2ZW50U2Vncyhwcm9wcy5mZ0V2ZW50U2Vncywgcm93Q250KTtcbiAgICAgICAgbGV0IGRhdGVTZWxlY3Rpb25TZWdzQnlSb3cgPSB0aGlzLnNwbGl0RGF0ZVNlbGVjdGlvblNlZ3MocHJvcHMuZGF0ZVNlbGVjdGlvblNlZ3MsIHJvd0NudCk7XG4gICAgICAgIGxldCBldmVudERyYWdCeVJvdyA9IHRoaXMuc3BsaXRFdmVudERyYWcocHJvcHMuZXZlbnREcmFnLCByb3dDbnQpO1xuICAgICAgICBsZXQgZXZlbnRSZXNpemVCeVJvdyA9IHRoaXMuc3BsaXRFdmVudFJlc2l6ZShwcm9wcy5ldmVudFJlc2l6ZSwgcm93Q250KTtcbiAgICAgICAgLy8gZm9yIERheUdyaWQgdmlldyB3aXRoIG1hbnkgcm93cywgZm9yY2UgYSBtaW4taGVpZ2h0IG9uIGNlbGxzIHNvIGRvZXNuJ3QgYXBwZWFyIHNxdWlzaGVkXG4gICAgICAgIC8vIGNob29zZSA3IGJlY2F1c2UgYSBtb250aCB2aWV3IHdpbGwgaGF2ZSBtYXggNiByb3dzXG4gICAgICAgIGxldCBjZWxsTWluSGVpZ2h0ID0gKHJvd0NudCA+PSA3ICYmIHByb3BzLmNsaWVudFdpZHRoKSA/XG4gICAgICAgICAgICBwcm9wcy5jbGllbnRXaWR0aCAvIGNvbnRleHQub3B0aW9ucy5hc3BlY3RSYXRpbyAvIDYgOlxuICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KE5vd1RpbWVyLCB7IHVuaXQ6IFwiZGF5XCIgfSwgKG5vd0RhdGUsIHRvZGF5UmFuZ2UpID0+IChjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBwcm9wcy5jZWxscy5tYXAoKGNlbGxzLCByb3cpID0+IChjcmVhdGVFbGVtZW50KFRhYmxlUm93LCB7IHJlZjogdGhpcy5yb3dSZWZzLmNyZWF0ZVJlZihyb3cpLCBrZXk6IGNlbGxzLmxlbmd0aFxuICAgICAgICAgICAgICAgID8gY2VsbHNbMF0uZGF0ZS50b0lTT1N0cmluZygpIC8qIGJlc3Q/IG9yIHB1dCBrZXkgb24gY2VsbD8gb3IgdXNlIGRpZmYgZm9ybWF0dGVyPyAqL1xuICAgICAgICAgICAgICAgIDogcm93IC8vIGluIGNhc2UgdGhlcmUgYXJlIG5vIGNlbGxzIChsaWtlIHdoZW4gcmVzb3VyY2UgdmlldyBpcyBsb2FkaW5nKVxuICAgICAgICAgICAgLCBzaG93RGF5TnVtYmVyczogcm93Q250ID4gMSwgc2hvd1dlZWtOdW1iZXJzOiBwcm9wcy5zaG93V2Vla051bWJlcnMsIHRvZGF5UmFuZ2U6IHRvZGF5UmFuZ2UsIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgY2VsbHM6IGNlbGxzLCByZW5kZXJJbnRybzogcHJvcHMucmVuZGVyUm93SW50cm8sIGJ1c2luZXNzSG91clNlZ3M6IGJ1c2luZXNzSG91clNlZ3NCeVJvd1tyb3ddLCBldmVudFNlbGVjdGlvbjogcHJvcHMuZXZlbnRTZWxlY3Rpb24sIGJnRXZlbnRTZWdzOiBiZ0V2ZW50U2Vnc0J5Um93W3Jvd10uZmlsdGVyKGlzU2VnQWxsRGF5KSAvKiBoYWNrICovLCBmZ0V2ZW50U2VnczogZmdFdmVudFNlZ3NCeVJvd1tyb3ddLCBkYXRlU2VsZWN0aW9uU2VnczogZGF0ZVNlbGVjdGlvblNlZ3NCeVJvd1tyb3ddLCBldmVudERyYWc6IGV2ZW50RHJhZ0J5Um93W3Jvd10sIGV2ZW50UmVzaXplOiBldmVudFJlc2l6ZUJ5Um93W3Jvd10sIGRheU1heEV2ZW50czogcHJvcHMuZGF5TWF4RXZlbnRzLCBkYXlNYXhFdmVudFJvd3M6IHByb3BzLmRheU1heEV2ZW50Um93cywgY2xpZW50V2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQ6IHByb3BzLmNsaWVudEhlaWdodCwgY2VsbE1pbkhlaWdodDogY2VsbE1pbkhlaWdodCwgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50IH0pKSkpKSkpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KCk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgLy8gZm9yIGlmIHN0YXJ0ZWQgd2l0aCB6ZXJvIGNlbGxzXG4gICAgICAgIHRoaXMucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCgpO1xuICAgIH1cbiAgICByZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMucm9vdEVsKSB7XG4gICAgICAgICAgICAvLyBIQUNLOiBuZWVkIGEgZGF5Z3JpZCB3cmFwcGVyIHBhcmVudCB0byBkbyBwb3NpdGlvbmluZ1xuICAgICAgICAgICAgLy8gTk9URTogYSBkYXlncmlkIHJlc291cmNlIHZpZXcgdy9vIHJlc291cmNlcyBjYW4gaGF2ZSB6ZXJvIGNlbGxzXG4gICAgICAgICAgICBjb25zdCBmaXJzdENlbGxFbCA9IHRoaXMucm93UmVmcy5jdXJyZW50TWFwWzBdLmdldENlbGxFbHMoKVswXTtcbiAgICAgICAgICAgIGNvbnN0IHJvb3RFbCA9IGZpcnN0Q2VsbEVsID8gZmlyc3RDZWxsRWwuY2xvc2VzdCgnLmZjLWRheWdyaWQtYm9keScpIDogbnVsbDtcbiAgICAgICAgICAgIGlmIChyb290RWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3RFbCA9IHJvb3RFbDtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCh0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgIGVsOiByb290RWwsXG4gICAgICAgICAgICAgICAgICAgIGlzSGl0Q29tYm9BbGxvd2VkOiB0aGlzLnByb3BzLmlzSGl0Q29tYm9BbGxvd2VkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICBpZiAodGhpcy5yb290RWwpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC51bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnJvb3RFbCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSGl0IFN5c3RlbVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBwcmVwYXJlSGl0cygpIHtcbiAgICAgICAgdGhpcy5yb3dQb3NpdGlvbnMgPSBuZXcgUG9zaXRpb25DYWNoZSh0aGlzLnJvb3RFbCwgdGhpcy5yb3dSZWZzLmNvbGxlY3QoKS5tYXAoKHJvd09iaikgPT4gcm93T2JqLmdldENlbGxFbHMoKVswXSksIC8vIGZpcnN0IGNlbGwgZWwgaW4gZWFjaCByb3cuIFRPRE86IG5vdCBvcHRpbWFsXG4gICAgICAgIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgdGhpcy5jb2xQb3NpdGlvbnMgPSBuZXcgUG9zaXRpb25DYWNoZSh0aGlzLnJvb3RFbCwgdGhpcy5yb3dSZWZzLmN1cnJlbnRNYXBbMF0uZ2V0Q2VsbEVscygpLCAvLyBjZWxsIGVscyBpbiBmaXJzdCByb3dcbiAgICAgICAgdHJ1ZSwgLy8gaG9yaXpvbnRhbFxuICAgICAgICBmYWxzZSk7XG4gICAgfVxuICAgIHF1ZXJ5SGl0KHBvc2l0aW9uTGVmdCwgcG9zaXRpb25Ub3ApIHtcbiAgICAgICAgbGV0IHsgY29sUG9zaXRpb25zLCByb3dQb3NpdGlvbnMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBjb2wgPSBjb2xQb3NpdGlvbnMubGVmdFRvSW5kZXgocG9zaXRpb25MZWZ0KTtcbiAgICAgICAgbGV0IHJvdyA9IHJvd1Bvc2l0aW9ucy50b3BUb0luZGV4KHBvc2l0aW9uVG9wKTtcbiAgICAgICAgaWYgKHJvdyAhPSBudWxsICYmIGNvbCAhPSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgY2VsbCA9IHRoaXMucHJvcHMuY2VsbHNbcm93XVtjb2xdO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRlUHJvZmlsZTogdGhpcy5wcm9wcy5kYXRlUHJvZmlsZSxcbiAgICAgICAgICAgICAgICBkYXRlU3BhbjogT2JqZWN0LmFzc2lnbih7IHJhbmdlOiB0aGlzLmdldENlbGxSYW5nZShyb3csIGNvbCksIGFsbERheTogdHJ1ZSB9LCBjZWxsLmV4dHJhRGF0ZVNwYW4pLFxuICAgICAgICAgICAgICAgIGRheUVsOiB0aGlzLmdldENlbGxFbChyb3csIGNvbCksXG4gICAgICAgICAgICAgICAgcmVjdDoge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBjb2xQb3NpdGlvbnMubGVmdHNbY29sXSxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGNvbFBvc2l0aW9ucy5yaWdodHNbY29sXSxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiByb3dQb3NpdGlvbnMudG9wc1tyb3ddLFxuICAgICAgICAgICAgICAgICAgICBib3R0b206IHJvd1Bvc2l0aW9ucy5ib3R0b21zW3Jvd10sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBsYXllcjogMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldENlbGxFbChyb3csIGNvbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3dSZWZzLmN1cnJlbnRNYXBbcm93XS5nZXRDZWxsRWxzKClbY29sXTsgLy8gVE9ETzogbm90IG9wdGltYWxcbiAgICB9XG4gICAgZ2V0Q2VsbFJhbmdlKHJvdywgY29sKSB7XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMucHJvcHMuY2VsbHNbcm93XVtjb2xdLmRhdGU7XG4gICAgICAgIGxldCBlbmQgPSBhZGREYXlzKHN0YXJ0LCAxKTtcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQsIGVuZCB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzU2VnQWxsRGF5KHNlZykge1xuICAgIHJldHVybiBzZWcuZXZlbnRSYW5nZS5kZWYuYWxsRGF5O1xufVxuXG5jbGFzcyBUYWJsZSBleHRlbmRzIERhdGVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmVsUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIHRoaXMubmVlZHNTY3JvbGxSZXNldCA9IGZhbHNlO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBkYXlNYXhFdmVudFJvd3MsIGRheU1heEV2ZW50cywgZXhwYW5kUm93cyB9ID0gcHJvcHM7XG4gICAgICAgIGxldCBsaW1pdFZpYUJhbGFuY2VkID0gZGF5TWF4RXZlbnRzID09PSB0cnVlIHx8IGRheU1heEV2ZW50Um93cyA9PT0gdHJ1ZTtcbiAgICAgICAgLy8gaWYgcm93cyBjYW4ndCBleHBhbmQgdG8gZmlsbCBmaXhlZCBoZWlnaHQsIGNhbid0IGRvIGJhbGFuY2VkLWhlaWdodCBldmVudCBsaW1pdFxuICAgICAgICAvLyBUT0RPOiBiZXN0IHBsYWNlIHRvIG5vcm1hbGl6ZSB0aGVzZSBvcHRpb25zP1xuICAgICAgICBpZiAobGltaXRWaWFCYWxhbmNlZCAmJiAhZXhwYW5kUm93cykge1xuICAgICAgICAgICAgbGltaXRWaWFCYWxhbmNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZGF5TWF4RXZlbnRSb3dzID0gbnVsbDtcbiAgICAgICAgICAgIGRheU1heEV2ZW50cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNsYXNzTmFtZXMgPSBbXG4gICAgICAgICAgICAnZmMtZGF5Z3JpZC1ib2R5JyxcbiAgICAgICAgICAgIGxpbWl0VmlhQmFsYW5jZWQgPyAnZmMtZGF5Z3JpZC1ib2R5LWJhbGFuY2VkJyA6ICdmYy1kYXlncmlkLWJvZHktdW5iYWxhbmNlZCcsXG4gICAgICAgICAgICBleHBhbmRSb3dzID8gJycgOiAnZmMtZGF5Z3JpZC1ib2R5LW5hdHVyYWwnLCAvLyB3aWxsIGhlaWdodCBvZiBvbmUgcm93IGRlcGVuZCBvbiB0aGUgb3RoZXJzP1xuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IHRoaXMuZWxSZWYsIGNsYXNzTmFtZTogY2xhc3NOYW1lcy5qb2luKCcgJyksIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgLy8gdGhlc2UgcHJvcHMgYXJlIGltcG9ydGFudCB0byBnaXZlIHRoaXMgd3JhcHBlciBjb3JyZWN0IGRpbWVuc2lvbnMgZm9yIGludGVyYWN0aW9uc1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGlmIHdlIHNldCBpdCBoZXJlLCBjYW4gd2UgYXZvaWQgZ2l2aW5nIHRvIGlubmVyIHRhYmxlcz9cbiAgICAgICAgICAgICAgICB3aWR0aDogcHJvcHMuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICAgICAgbWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsXG4gICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwidGFibGVcIiwgeyByb2xlOiBcInByZXNlbnRhdGlvblwiLCBjbGFzc05hbWU6IFwiZmMtc2Nyb2xsZ3JpZC1zeW5jLXRhYmxlXCIsIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgbWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogZXhwYW5kUm93cyA/IHByb3BzLmNsaWVudEhlaWdodCA6ICcnLFxuICAgICAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgICAgICBwcm9wcy5jb2xHcm91cE5vZGUsXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRib2R5XCIsIHsgcm9sZTogXCJwcmVzZW50YXRpb25cIiB9LFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFRhYmxlUm93cywgeyBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIGNlbGxzOiBwcm9wcy5jZWxscywgcmVuZGVyUm93SW50cm86IHByb3BzLnJlbmRlclJvd0ludHJvLCBzaG93V2Vla051bWJlcnM6IHByb3BzLnNob3dXZWVrTnVtYmVycywgY2xpZW50V2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQ6IHByb3BzLmNsaWVudEhlaWdodCwgYnVzaW5lc3NIb3VyU2VnczogcHJvcHMuYnVzaW5lc3NIb3VyU2VncywgYmdFdmVudFNlZ3M6IHByb3BzLmJnRXZlbnRTZWdzLCBmZ0V2ZW50U2VnczogcHJvcHMuZmdFdmVudFNlZ3MsIGRhdGVTZWxlY3Rpb25TZWdzOiBwcm9wcy5kYXRlU2VsZWN0aW9uU2VncywgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBldmVudERyYWc6IHByb3BzLmV2ZW50RHJhZywgZXZlbnRSZXNpemU6IHByb3BzLmV2ZW50UmVzaXplLCBkYXlNYXhFdmVudHM6IGRheU1heEV2ZW50cywgZGF5TWF4RXZlbnRSb3dzOiBkYXlNYXhFdmVudFJvd3MsIGZvclByaW50OiBwcm9wcy5mb3JQcmludCwgaXNIaXRDb21ib0FsbG93ZWQ6IHByb3BzLmlzSGl0Q29tYm9BbGxvd2VkIH0pKSkpKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdFNjcm9sbFJlc2V0KCk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgICAgaWYgKHByZXZQcm9wcy5kYXRlUHJvZmlsZSAhPT0gdGhpcy5wcm9wcy5kYXRlUHJvZmlsZSkge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0U2Nyb2xsUmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hTY3JvbGxSZXNldCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcXVlc3RTY3JvbGxSZXNldCgpIHtcbiAgICAgICAgdGhpcy5uZWVkc1Njcm9sbFJlc2V0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5mbHVzaFNjcm9sbFJlc2V0KCk7XG4gICAgfVxuICAgIGZsdXNoU2Nyb2xsUmVzZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLm5lZWRzU2Nyb2xsUmVzZXQgJiZcbiAgICAgICAgICAgIHRoaXMucHJvcHMuY2xpZW50V2lkdGggLy8gc2l6ZXMgY29tcHV0ZWQ/XG4gICAgICAgICkge1xuICAgICAgICAgICAgY29uc3Qgc3ViamVjdEVsID0gZ2V0U2Nyb2xsU3ViamVjdEVsKHRoaXMuZWxSZWYuY3VycmVudCwgdGhpcy5wcm9wcy5kYXRlUHJvZmlsZSk7XG4gICAgICAgICAgICBpZiAoc3ViamVjdEVsKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luRWwgPSBzdWJqZWN0RWwuY2xvc2VzdCgnLmZjLWRheWdyaWQtYm9keScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjcm9sbEVsID0gb3JpZ2luRWwuY2xvc2VzdCgnLmZjLXNjcm9sbGVyJyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2Nyb2xsVG9wID0gc3ViamVjdEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCAtXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbkVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcbiAgICAgICAgICAgICAgICBzY3JvbGxFbC5zY3JvbGxUb3AgPSBzY3JvbGxUb3AgPyAoc2Nyb2xsVG9wICsgMSkgOiAwOyAvLyBvdmVyY29tZSBib3JkZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubmVlZHNTY3JvbGxSZXNldCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0U2Nyb2xsU3ViamVjdEVsKGNvbnRhaW5lckVsLCBkYXRlUHJvZmlsZSkge1xuICAgIGxldCBlbDtcbiAgICBpZiAoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdC5tYXRjaCgveWVhcnxtb250aC8pKSB7XG4gICAgICAgIGVsID0gY29udGFpbmVyRWwucXVlcnlTZWxlY3RvcihgW2RhdGEtZGF0ZT1cIiR7Zm9ybWF0SXNvTW9udGhTdHIoZGF0ZVByb2ZpbGUuY3VycmVudERhdGUpfS0wMVwiXWApO1xuICAgICAgICAvLyBldmVuIGlmIHZpZXcgaXMgbW9udGgtYmFzZWQsIGZpcnN0LW9mLW1vbnRoIG1pZ2h0IGJlIGhpZGRlbi4uLlxuICAgIH1cbiAgICBpZiAoIWVsKSB7XG4gICAgICAgIGVsID0gY29udGFpbmVyRWwucXVlcnlTZWxlY3RvcihgW2RhdGEtZGF0ZT1cIiR7Zm9ybWF0RGF5U3RyaW5nKGRhdGVQcm9maWxlLmN1cnJlbnREYXRlKX1cIl1gKTtcbiAgICAgICAgLy8gY291bGQgc3RpbGwgYmUgaGlkZGVuIGlmIGFuIGludGVyaW9yLXZpZXcgaGlkZGVuIGRheVxuICAgIH1cbiAgICByZXR1cm4gZWw7XG59XG5cbmNsYXNzIERheVRhYmxlU2xpY2VyIGV4dGVuZHMgU2xpY2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5mb3JjZURheUlmTGlzdEl0ZW0gPSB0cnVlO1xuICAgIH1cbiAgICBzbGljZVJhbmdlKGRhdGVSYW5nZSwgZGF5VGFibGVNb2RlbCkge1xuICAgICAgICByZXR1cm4gZGF5VGFibGVNb2RlbC5zbGljZVJhbmdlKGRhdGVSYW5nZSk7XG4gICAgfVxufVxuXG5jbGFzcyBEYXlUYWJsZSBleHRlbmRzIERhdGVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnNsaWNlciA9IG5ldyBEYXlUYWJsZVNsaWNlcigpO1xuICAgICAgICB0aGlzLnRhYmxlUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChUYWJsZSwgT2JqZWN0LmFzc2lnbih7IHJlZjogdGhpcy50YWJsZVJlZiB9LCB0aGlzLnNsaWNlci5zbGljZVByb3BzKHByb3BzLCBwcm9wcy5kYXRlUHJvZmlsZSwgcHJvcHMubmV4dERheVRocmVzaG9sZCwgY29udGV4dCwgcHJvcHMuZGF5VGFibGVNb2RlbCksIHsgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCBjZWxsczogcHJvcHMuZGF5VGFibGVNb2RlbC5jZWxscywgY29sR3JvdXBOb2RlOiBwcm9wcy5jb2xHcm91cE5vZGUsIHRhYmxlTWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsIHJlbmRlclJvd0ludHJvOiBwcm9wcy5yZW5kZXJSb3dJbnRybywgZGF5TWF4RXZlbnRzOiBwcm9wcy5kYXlNYXhFdmVudHMsIGRheU1heEV2ZW50Um93czogcHJvcHMuZGF5TWF4RXZlbnRSb3dzLCBzaG93V2Vla051bWJlcnM6IHByb3BzLnNob3dXZWVrTnVtYmVycywgZXhwYW5kUm93czogcHJvcHMuZXhwYW5kUm93cywgaGVhZGVyQWxpZ25FbFJlZjogcHJvcHMuaGVhZGVyQWxpZ25FbFJlZiwgY2xpZW50V2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQ6IHByb3BzLmNsaWVudEhlaWdodCwgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50IH0pKSk7XG4gICAgfVxufVxuXG5jbGFzcyBEYXlUYWJsZVZpZXcgZXh0ZW5kcyBUYWJsZVZpZXcge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmJ1aWxkRGF5VGFibGVNb2RlbCA9IG1lbW9pemUoYnVpbGREYXlUYWJsZU1vZGVsKTtcbiAgICAgICAgdGhpcy5oZWFkZXJSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICAgICAgdGhpcy50YWJsZVJlZiA9IGNyZWF0ZVJlZigpO1xuICAgICAgICAvLyBjYW4ndCBvdmVycmlkZSBhbnkgbGlmZWN5Y2xlIG1ldGhvZHMgZnJvbSBwYXJlbnRcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBvcHRpb25zLCBkYXRlUHJvZmlsZUdlbmVyYXRvciB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGRheVRhYmxlTW9kZWwgPSB0aGlzLmJ1aWxkRGF5VGFibGVNb2RlbChwcm9wcy5kYXRlUHJvZmlsZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IpO1xuICAgICAgICBsZXQgaGVhZGVyQ29udGVudCA9IG9wdGlvbnMuZGF5SGVhZGVycyAmJiAoY3JlYXRlRWxlbWVudChEYXlIZWFkZXIsIHsgcmVmOiB0aGlzLmhlYWRlclJlZiwgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCBkYXRlczogZGF5VGFibGVNb2RlbC5oZWFkZXJEYXRlcywgZGF0ZXNSZXBEaXN0aW5jdERheXM6IGRheVRhYmxlTW9kZWwucm93Q250ID09PSAxIH0pKTtcbiAgICAgICAgbGV0IGJvZHlDb250ZW50ID0gKGNvbnRlbnRBcmcpID0+IChjcmVhdGVFbGVtZW50KERheVRhYmxlLCB7IHJlZjogdGhpcy50YWJsZVJlZiwgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCBkYXlUYWJsZU1vZGVsOiBkYXlUYWJsZU1vZGVsLCBidXNpbmVzc0hvdXJzOiBwcm9wcy5idXNpbmVzc0hvdXJzLCBkYXRlU2VsZWN0aW9uOiBwcm9wcy5kYXRlU2VsZWN0aW9uLCBldmVudFN0b3JlOiBwcm9wcy5ldmVudFN0b3JlLCBldmVudFVpQmFzZXM6IHByb3BzLmV2ZW50VWlCYXNlcywgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBldmVudERyYWc6IHByb3BzLmV2ZW50RHJhZywgZXZlbnRSZXNpemU6IHByb3BzLmV2ZW50UmVzaXplLCBuZXh0RGF5VGhyZXNob2xkOiBvcHRpb25zLm5leHREYXlUaHJlc2hvbGQsIGNvbEdyb3VwTm9kZTogY29udGVudEFyZy50YWJsZUNvbEdyb3VwTm9kZSwgdGFibGVNaW5XaWR0aDogY29udGVudEFyZy50YWJsZU1pbldpZHRoLCBkYXlNYXhFdmVudHM6IG9wdGlvbnMuZGF5TWF4RXZlbnRzLCBkYXlNYXhFdmVudFJvd3M6IG9wdGlvbnMuZGF5TWF4RXZlbnRSb3dzLCBzaG93V2Vla051bWJlcnM6IG9wdGlvbnMud2Vla051bWJlcnMsIGV4cGFuZFJvd3M6ICFwcm9wcy5pc0hlaWdodEF1dG8sIGhlYWRlckFsaWduRWxSZWY6IHRoaXMuaGVhZGVyRWxSZWYsIGNsaWVudFdpZHRoOiBjb250ZW50QXJnLmNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQ6IGNvbnRlbnRBcmcuY2xpZW50SGVpZ2h0LCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQgfSkpO1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5kYXlNaW5XaWR0aFxuICAgICAgICAgICAgPyB0aGlzLnJlbmRlckhTY3JvbGxMYXlvdXQoaGVhZGVyQ29udGVudCwgYm9keUNvbnRlbnQsIGRheVRhYmxlTW9kZWwuY29sQ250LCBvcHRpb25zLmRheU1pbldpZHRoKVxuICAgICAgICAgICAgOiB0aGlzLnJlbmRlclNpbXBsZUxheW91dChoZWFkZXJDb250ZW50LCBib2R5Q29udGVudCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYnVpbGREYXlUYWJsZU1vZGVsKGRhdGVQcm9maWxlLCBkYXRlUHJvZmlsZUdlbmVyYXRvcikge1xuICAgIGxldCBkYXlTZXJpZXMgPSBuZXcgRGF5U2VyaWVzTW9kZWwoZGF0ZVByb2ZpbGUucmVuZGVyUmFuZ2UsIGRhdGVQcm9maWxlR2VuZXJhdG9yKTtcbiAgICByZXR1cm4gbmV3IERheVRhYmxlTW9kZWwoZGF5U2VyaWVzLCAveWVhcnxtb250aHx3ZWVrLy50ZXN0KGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZVVuaXQpKTtcbn1cblxuY2xhc3MgVGFibGVEYXRlUHJvZmlsZUdlbmVyYXRvciBleHRlbmRzIERhdGVQcm9maWxlR2VuZXJhdG9yIHtcbiAgICAvLyBDb21wdXRlcyB0aGUgZGF0ZSByYW5nZSB0aGF0IHdpbGwgYmUgcmVuZGVyZWRcbiAgICBidWlsZFJlbmRlclJhbmdlKGN1cnJlbnRSYW5nZSwgY3VycmVudFJhbmdlVW5pdCwgaXNSYW5nZUFsbERheSkge1xuICAgICAgICBsZXQgcmVuZGVyUmFuZ2UgPSBzdXBlci5idWlsZFJlbmRlclJhbmdlKGN1cnJlbnRSYW5nZSwgY3VycmVudFJhbmdlVW5pdCwgaXNSYW5nZUFsbERheSk7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gYnVpbGREYXlUYWJsZVJlbmRlclJhbmdlKHtcbiAgICAgICAgICAgIGN1cnJlbnRSYW5nZTogcmVuZGVyUmFuZ2UsXG4gICAgICAgICAgICBzbmFwVG9XZWVrOiAvXih5ZWFyfG1vbnRoKSQvLnRlc3QoY3VycmVudFJhbmdlVW5pdCksXG4gICAgICAgICAgICBmaXhlZFdlZWtDb3VudDogcHJvcHMuZml4ZWRXZWVrQ291bnQsXG4gICAgICAgICAgICBkYXRlRW52OiBwcm9wcy5kYXRlRW52LFxuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBidWlsZERheVRhYmxlUmVuZGVyUmFuZ2UocHJvcHMpIHtcbiAgICBsZXQgeyBkYXRlRW52LCBjdXJyZW50UmFuZ2UgfSA9IHByb3BzO1xuICAgIGxldCB7IHN0YXJ0LCBlbmQgfSA9IGN1cnJlbnRSYW5nZTtcbiAgICBsZXQgZW5kT2ZXZWVrO1xuICAgIC8vIHllYXIgYW5kIG1vbnRoIHZpZXdzIHNob3VsZCBiZSBhbGlnbmVkIHdpdGggd2Vla3MuIHRoaXMgaXMgYWxyZWFkeSBkb25lIGZvciB3ZWVrXG4gICAgaWYgKHByb3BzLnNuYXBUb1dlZWspIHtcbiAgICAgICAgc3RhcnQgPSBkYXRlRW52LnN0YXJ0T2ZXZWVrKHN0YXJ0KTtcbiAgICAgICAgLy8gbWFrZSBlbmQtb2Ytd2VlayBpZiBub3QgYWxyZWFkeVxuICAgICAgICBlbmRPZldlZWsgPSBkYXRlRW52LnN0YXJ0T2ZXZWVrKGVuZCk7XG4gICAgICAgIGlmIChlbmRPZldlZWsudmFsdWVPZigpICE9PSBlbmQudmFsdWVPZigpKSB7XG4gICAgICAgICAgICBlbmQgPSBhZGRXZWVrcyhlbmRPZldlZWssIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGVuc3VyZSA2IHdlZWtzXG4gICAgaWYgKHByb3BzLmZpeGVkV2Vla0NvdW50KSB7XG4gICAgICAgIC8vIFRPRE86IGluc3RlYWQgb2YgdGhlc2UgZGF0ZS1tYXRoIGd5bW5hc3RpY3MgKGZvciBtdWx0aW1vbnRoIHZpZXcpLFxuICAgICAgICAvLyBjb21wdXRlIGRhdGVwcm9maWxlcyBvZiBhbGwgbW9udGhzLCB0aGVuIHVzZSBzdGFydCBvZiBmaXJzdCBhbmQgZW5kIG9mIGxhc3QuXG4gICAgICAgIGxldCBsYXN0TW9udGhSZW5kZXJTdGFydCA9IGRhdGVFbnYuc3RhcnRPZldlZWsoZGF0ZUVudi5zdGFydE9mTW9udGgoYWRkRGF5cyhjdXJyZW50UmFuZ2UuZW5kLCAtMSkpKTtcbiAgICAgICAgbGV0IHJvd0NudCA9IE1hdGguY2VpbCgvLyBjb3VsZCBiZSBwYXJ0aWFsIHdlZWtzIGR1ZSB0byBoaWRkZW5EYXlzXG4gICAgICAgIGRpZmZXZWVrcyhsYXN0TW9udGhSZW5kZXJTdGFydCwgZW5kKSk7XG4gICAgICAgIGVuZCA9IGFkZFdlZWtzKGVuZCwgNiAtIHJvd0NudCk7XG4gICAgfVxuICAgIHJldHVybiB7IHN0YXJ0LCBlbmQgfTtcbn1cblxudmFyIGNzc18yNDh6ID0gXCI6cm9vdHstLWZjLWRheWdyaWQtZXZlbnQtZG90LXdpZHRoOjhweH0uZmMtZGF5Z3JpZC1kYXktZXZlbnRzOmFmdGVyLC5mYy1kYXlncmlkLWRheS1ldmVudHM6YmVmb3JlLC5mYy1kYXlncmlkLWRheS1mcmFtZTphZnRlciwuZmMtZGF5Z3JpZC1kYXktZnJhbWU6YmVmb3JlLC5mYy1kYXlncmlkLWV2ZW50LWhhcm5lc3M6YWZ0ZXIsLmZjLWRheWdyaWQtZXZlbnQtaGFybmVzczpiZWZvcmV7Y2xlYXI6Ym90aDtjb250ZW50OlxcXCJcXFwiO2Rpc3BsYXk6dGFibGV9LmZjIC5mYy1kYXlncmlkLWJvZHl7cG9zaXRpb246cmVsYXRpdmU7ei1pbmRleDoxfS5mYyAuZmMtZGF5Z3JpZC1kYXkuZmMtZGF5LXRvZGF5e2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmMtdG9kYXktYmctY29sb3IpfS5mYyAuZmMtZGF5Z3JpZC1kYXktZnJhbWV7bWluLWhlaWdodDoxMDAlO3Bvc2l0aW9uOnJlbGF0aXZlfS5mYyAuZmMtZGF5Z3JpZC1kYXktdG9we2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpyb3ctcmV2ZXJzZX0uZmMgLmZjLWRheS1vdGhlciAuZmMtZGF5Z3JpZC1kYXktdG9we29wYWNpdHk6LjN9LmZjIC5mYy1kYXlncmlkLWRheS1udW1iZXJ7cGFkZGluZzo0cHg7cG9zaXRpb246cmVsYXRpdmU7ei1pbmRleDo0fS5mYyAuZmMtZGF5Z3JpZC1tb250aC1zdGFydHtmb250LXNpemU6MS4xZW07Zm9udC13ZWlnaHQ6NzAwfS5mYyAuZmMtZGF5Z3JpZC1kYXktZXZlbnRze21hcmdpbi10b3A6MXB4fS5mYyAuZmMtZGF5Z3JpZC1ib2R5LWJhbGFuY2VkIC5mYy1kYXlncmlkLWRheS1ldmVudHN7bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjB9LmZjIC5mYy1kYXlncmlkLWJvZHktdW5iYWxhbmNlZCAuZmMtZGF5Z3JpZC1kYXktZXZlbnRze21pbi1oZWlnaHQ6MmVtO3Bvc2l0aW9uOnJlbGF0aXZlfS5mYyAuZmMtZGF5Z3JpZC1ib2R5LW5hdHVyYWwgLmZjLWRheWdyaWQtZGF5LWV2ZW50c3ttYXJnaW4tYm90dG9tOjFlbX0uZmMgLmZjLWRheWdyaWQtZXZlbnQtaGFybmVzc3twb3NpdGlvbjpyZWxhdGl2ZX0uZmMgLmZjLWRheWdyaWQtZXZlbnQtaGFybmVzcy1hYnN7bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7dG9wOjB9LmZjIC5mYy1kYXlncmlkLWJnLWhhcm5lc3N7Ym90dG9tOjA7cG9zaXRpb246YWJzb2x1dGU7dG9wOjB9LmZjIC5mYy1kYXlncmlkLWRheS1iZyAuZmMtbm9uLWJ1c2luZXNze3otaW5kZXg6MX0uZmMgLmZjLWRheWdyaWQtZGF5LWJnIC5mYy1iZy1ldmVudHt6LWluZGV4OjJ9LmZjIC5mYy1kYXlncmlkLWRheS1iZyAuZmMtaGlnaGxpZ2h0e3otaW5kZXg6M30uZmMgLmZjLWRheWdyaWQtZXZlbnR7bWFyZ2luLXRvcDoxcHg7ei1pbmRleDo2fS5mYyAuZmMtZGF5Z3JpZC1ldmVudC5mYy1ldmVudC1taXJyb3J7ei1pbmRleDo3fS5mYyAuZmMtZGF5Z3JpZC1kYXktYm90dG9te2ZvbnQtc2l6ZTouODVlbTttYXJnaW46MCAycHh9LmZjIC5mYy1kYXlncmlkLWRheS1ib3R0b206YWZ0ZXIsLmZjIC5mYy1kYXlncmlkLWRheS1ib3R0b206YmVmb3Jle2NsZWFyOmJvdGg7Y29udGVudDpcXFwiXFxcIjtkaXNwbGF5OnRhYmxlfS5mYyAuZmMtZGF5Z3JpZC1tb3JlLWxpbmt7Ym9yZGVyLXJhZGl1czozcHg7Y3Vyc29yOnBvaW50ZXI7bGluZS1oZWlnaHQ6MTttYXJnaW4tdG9wOjFweDttYXgtd2lkdGg6MTAwJTtvdmVyZmxvdzpoaWRkZW47cGFkZGluZzoycHg7cG9zaXRpb246cmVsYXRpdmU7d2hpdGUtc3BhY2U6bm93cmFwO3otaW5kZXg6NH0uZmMgLmZjLWRheWdyaWQtbW9yZS1saW5rOmhvdmVye2JhY2tncm91bmQtY29sb3I6cmdiYSgwLDAsMCwuMSl9LmZjIC5mYy1kYXlncmlkLXdlZWstbnVtYmVye2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmMtbmV1dHJhbC1iZy1jb2xvcik7Y29sb3I6dmFyKC0tZmMtbmV1dHJhbC10ZXh0LWNvbG9yKTttaW4td2lkdGg6MS41ZW07cGFkZGluZzoycHg7cG9zaXRpb246YWJzb2x1dGU7dGV4dC1hbGlnbjpjZW50ZXI7dG9wOjA7ei1pbmRleDo1fS5mYyAuZmMtbW9yZS1wb3BvdmVyIC5mYy1wb3BvdmVyLWJvZHl7bWluLXdpZHRoOjIyMHB4O3BhZGRpbmc6MTBweH0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtZGF5Z3JpZC1ldmVudC5mYy1ldmVudC1zdGFydCwuZmMtZGlyZWN0aW9uLXJ0bCAuZmMtZGF5Z3JpZC1ldmVudC5mYy1ldmVudC1lbmR7bWFyZ2luLWxlZnQ6MnB4fS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1kYXlncmlkLWV2ZW50LmZjLWV2ZW50LWVuZCwuZmMtZGlyZWN0aW9uLXJ0bCAuZmMtZGF5Z3JpZC1ldmVudC5mYy1ldmVudC1zdGFydHttYXJnaW4tcmlnaHQ6MnB4fS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1kYXlncmlkLW1vcmUtbGlua3tmbG9hdDpsZWZ0fS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1kYXlncmlkLXdlZWstbnVtYmVye2JvcmRlci1yYWRpdXM6MCAwIDNweCAwO2xlZnQ6MH0uZmMtZGlyZWN0aW9uLXJ0bCAuZmMtZGF5Z3JpZC1tb3JlLWxpbmt7ZmxvYXQ6cmlnaHR9LmZjLWRpcmVjdGlvbi1ydGwgLmZjLWRheWdyaWQtd2Vlay1udW1iZXJ7Ym9yZGVyLXJhZGl1czowIDAgMCAzcHg7cmlnaHQ6MH0uZmMtbGlxdWlkLWhhY2sgLmZjLWRheWdyaWQtZGF5LWZyYW1le3Bvc2l0aW9uOnN0YXRpY30uZmMtZGF5Z3JpZC1ldmVudHtib3JkZXItcmFkaXVzOjNweDtmb250LXNpemU6dmFyKC0tZmMtc21hbGwtZm9udC1zaXplKTtwb3NpdGlvbjpyZWxhdGl2ZTt3aGl0ZS1zcGFjZTpub3dyYXB9LmZjLWRheWdyaWQtYmxvY2stZXZlbnQgLmZjLWV2ZW50LXRpbWV7Zm9udC13ZWlnaHQ6NzAwfS5mYy1kYXlncmlkLWJsb2NrLWV2ZW50IC5mYy1ldmVudC10aW1lLC5mYy1kYXlncmlkLWJsb2NrLWV2ZW50IC5mYy1ldmVudC10aXRsZXtwYWRkaW5nOjFweH0uZmMtZGF5Z3JpZC1kb3QtZXZlbnR7YWxpZ24taXRlbXM6Y2VudGVyO2Rpc3BsYXk6ZmxleDtwYWRkaW5nOjJweCAwfS5mYy1kYXlncmlkLWRvdC1ldmVudCAuZmMtZXZlbnQtdGl0bGV7ZmxleC1ncm93OjE7ZmxleC1zaHJpbms6MTtmb250LXdlaWdodDo3MDA7bWluLXdpZHRoOjA7b3ZlcmZsb3c6aGlkZGVufS5mYy1kYXlncmlkLWRvdC1ldmVudC5mYy1ldmVudC1taXJyb3IsLmZjLWRheWdyaWQtZG90LWV2ZW50OmhvdmVye2JhY2tncm91bmQ6cmdiYSgwLDAsMCwuMSl9LmZjLWRheWdyaWQtZG90LWV2ZW50LmZjLWV2ZW50LXNlbGVjdGVkOmJlZm9yZXtib3R0b206LTEwcHg7dG9wOi0xMHB4fS5mYy1kYXlncmlkLWV2ZW50LWRvdHtib3JkZXI6Y2FsYyh2YXIoLS1mYy1kYXlncmlkLWV2ZW50LWRvdC13aWR0aCkvMikgc29saWQgdmFyKC0tZmMtZXZlbnQtYm9yZGVyLWNvbG9yKTtib3JkZXItcmFkaXVzOmNhbGModmFyKC0tZmMtZGF5Z3JpZC1ldmVudC1kb3Qtd2lkdGgpLzIpO2JveC1zaXppbmc6Y29udGVudC1ib3g7aGVpZ2h0OjA7bWFyZ2luOjAgNHB4O3dpZHRoOjB9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLWRheWdyaWQtZXZlbnQgLmZjLWV2ZW50LXRpbWV7bWFyZ2luLXJpZ2h0OjNweH0uZmMtZGlyZWN0aW9uLXJ0bCAuZmMtZGF5Z3JpZC1ldmVudCAuZmMtZXZlbnQtdGltZXttYXJnaW4tbGVmdDozcHh9XCI7XG5pbmplY3RTdHlsZXMoY3NzXzI0OHopO1xuXG5leHBvcnQgeyBEYXlUYWJsZVZpZXcgYXMgRGF5R3JpZFZpZXcsIERheVRhYmxlLCBEYXlUYWJsZVNsaWNlciwgVGFibGUsIFRhYmxlRGF0ZVByb2ZpbGVHZW5lcmF0b3IsIFRhYmxlUm93cywgVGFibGVWaWV3LCBidWlsZERheVRhYmxlTW9kZWwsIGJ1aWxkRGF5VGFibGVSZW5kZXJSYW5nZSB9O1xuIiwgImltcG9ydCB7IGNyZWF0ZVBsdWdpbiB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29yZS9pbmRleC5qcyc7XG5pbXBvcnQgeyBEYXlHcmlkVmlldyBhcyBEYXlUYWJsZVZpZXcsIFRhYmxlRGF0ZVByb2ZpbGVHZW5lcmF0b3IgfSBmcm9tICcuL2ludGVybmFsLmpzJztcbmltcG9ydCAnQGZ1bGxjYWxlbmRhci9jb3JlL2ludGVybmFsLmpzJztcbmltcG9ydCAnQGZ1bGxjYWxlbmRhci9jb3JlL3ByZWFjdC5qcyc7XG5cbnZhciBpbmRleCA9IGNyZWF0ZVBsdWdpbih7XG4gICAgbmFtZTogJ0BmdWxsY2FsZW5kYXIvZGF5Z3JpZCcsXG4gICAgaW5pdGlhbFZpZXc6ICdkYXlHcmlkTW9udGgnLFxuICAgIHZpZXdzOiB7XG4gICAgICAgIGRheUdyaWQ6IHtcbiAgICAgICAgICAgIGNvbXBvbmVudDogRGF5VGFibGVWaWV3LFxuICAgICAgICAgICAgZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzczogVGFibGVEYXRlUHJvZmlsZUdlbmVyYXRvcixcbiAgICAgICAgfSxcbiAgICAgICAgZGF5R3JpZERheToge1xuICAgICAgICAgICAgdHlwZTogJ2RheUdyaWQnLFxuICAgICAgICAgICAgZHVyYXRpb246IHsgZGF5czogMSB9LFxuICAgICAgICB9LFxuICAgICAgICBkYXlHcmlkV2Vlazoge1xuICAgICAgICAgICAgdHlwZTogJ2RheUdyaWQnLFxuICAgICAgICAgICAgZHVyYXRpb246IHsgd2Vla3M6IDEgfSxcbiAgICAgICAgfSxcbiAgICAgICAgZGF5R3JpZE1vbnRoOiB7XG4gICAgICAgICAgICB0eXBlOiAnZGF5R3JpZCcsXG4gICAgICAgICAgICBkdXJhdGlvbjogeyBtb250aHM6IDEgfSxcbiAgICAgICAgICAgIGZpeGVkV2Vla0NvdW50OiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICBkYXlHcmlkWWVhcjoge1xuICAgICAgICAgICAgdHlwZTogJ2RheUdyaWQnLFxuICAgICAgICAgICAgZHVyYXRpb246IHsgeWVhcnM6IDEgfSxcbiAgICAgICAgfSxcbiAgICB9LFxufSk7XG5cbmV4cG9ydCB7IGluZGV4IGFzIGRlZmF1bHQgfTtcbiIsICJpbXBvcnQgeyBTcGxpdHRlciwgaGFzQmdSZW5kZXJpbmcsIGNyZWF0ZUZvcm1hdHRlciwgVmlld0NvbnRleHRUeXBlLCBDb250ZW50Q29udGFpbmVyLCBCYXNlQ29tcG9uZW50LCBEYXRlQ29tcG9uZW50LCBkaWZmRGF5cywgYnVpbGROYXZMaW5rQXR0cnMsIFdlZWtOdW1iZXJDb250YWluZXIsIGdldFN0aWNreUhlYWRlckRhdGVzLCBWaWV3Q29udGFpbmVyLCBTaW1wbGVTY3JvbGxHcmlkLCBnZXRTdGlja3lGb290ZXJTY3JvbGxiYXIsIE5vd1RpbWVyLCBOb3dJbmRpY2F0b3JDb250YWluZXIsIHJlbmRlclNjcm9sbFNoaW0sIHJhbmdlQ29udGFpbnNNYXJrZXIsIHN0YXJ0T2ZEYXksIGFzUm91Z2hNcywgY3JlYXRlRHVyYXRpb24sIFJlZk1hcCwgUG9zaXRpb25DYWNoZSwgTW9yZUxpbmtDb250YWluZXIsIFNlZ0hpZXJhcmNoeSwgZ3JvdXBJbnRlcnNlY3RpbmdFbnRyaWVzLCBiaW5hcnlTZWFyY2gsIGdldEVudHJ5U3BhbkVuZCwgYnVpbGRFbnRyeUtleSwgU3RhbmRhcmRFdmVudCwgbWVtb2l6ZSwgc29ydEV2ZW50U2VncywgRGF5Q2VsbENvbnRhaW5lciwgaGFzQ3VzdG9tRGF5Q2VsbENvbnRlbnQsIGdldFNlZ01ldGEsIGJ1aWxkSXNvU3RyaW5nLCBjb21wdXRlRWFybGllc3RTZWdTdGFydCwgYnVpbGRFdmVudFJhbmdlS2V5LCBCZ0V2ZW50LCByZW5kZXJGaWxsLCBhZGREdXJhdGlvbnMsIG11bHRpcGx5RHVyYXRpb24sIHdob2xlRGl2aWRlRHVyYXRpb25zLCBTbGljZXIsIGludGVyc2VjdFJhbmdlcywgZm9ybWF0SXNvVGltZVN0cmluZywgRGF5SGVhZGVyLCBEYXlTZXJpZXNNb2RlbCwgRGF5VGFibGVNb2RlbCwgaW5qZWN0U3R5bGVzIH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb3JlL2ludGVybmFsLmpzJztcbmltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIGNyZWF0ZVJlZiwgRnJhZ21lbnQgfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvcmUvcHJlYWN0LmpzJztcbmltcG9ydCB7IERheVRhYmxlIH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9kYXlncmlkL2ludGVybmFsLmpzJztcblxuY2xhc3MgQWxsRGF5U3BsaXR0ZXIgZXh0ZW5kcyBTcGxpdHRlciB7XG4gICAgZ2V0S2V5SW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFsbERheToge30sXG4gICAgICAgICAgICB0aW1lZDoge30sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldEtleXNGb3JEYXRlU3BhbihkYXRlU3Bhbikge1xuICAgICAgICBpZiAoZGF0ZVNwYW4uYWxsRGF5KSB7XG4gICAgICAgICAgICByZXR1cm4gWydhbGxEYXknXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWyd0aW1lZCddO1xuICAgIH1cbiAgICBnZXRLZXlzRm9yRXZlbnREZWYoZXZlbnREZWYpIHtcbiAgICAgICAgaWYgKCFldmVudERlZi5hbGxEYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBbJ3RpbWVkJ107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0JnUmVuZGVyaW5nKGV2ZW50RGVmKSkge1xuICAgICAgICAgICAgcmV0dXJuIFsndGltZWQnLCAnYWxsRGF5J107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFsnYWxsRGF5J107XG4gICAgfVxufVxuXG5jb25zdCBERUZBVUxUX1NMQVRfTEFCRUxfRk9STUFUID0gY3JlYXRlRm9ybWF0dGVyKHtcbiAgICBob3VyOiAnbnVtZXJpYycsXG4gICAgbWludXRlOiAnMi1kaWdpdCcsXG4gICAgb21pdFplcm9NaW51dGU6IHRydWUsXG4gICAgbWVyaWRpZW06ICdzaG9ydCcsXG59KTtcbmZ1bmN0aW9uIFRpbWVDb2xzQXhpc0NlbGwocHJvcHMpIHtcbiAgICBsZXQgY2xhc3NOYW1lcyA9IFtcbiAgICAgICAgJ2ZjLXRpbWVncmlkLXNsb3QnLFxuICAgICAgICAnZmMtdGltZWdyaWQtc2xvdC1sYWJlbCcsXG4gICAgICAgIHByb3BzLmlzTGFiZWxlZCA/ICdmYy1zY3JvbGxncmlkLXNocmluaycgOiAnZmMtdGltZWdyaWQtc2xvdC1taW5vcicsXG4gICAgXTtcbiAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVmlld0NvbnRleHRUeXBlLkNvbnN1bWVyLCBudWxsLCAoY29udGV4dCkgPT4ge1xuICAgICAgICBpZiAoIXByb3BzLmlzTGFiZWxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwidGRcIiwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMuam9pbignICcpLCBcImRhdGEtdGltZVwiOiBwcm9wcy5pc29UaW1lU3RyIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBkYXRlRW52LCBvcHRpb25zLCB2aWV3QXBpIH0gPSBjb250ZXh0O1xuICAgICAgICBsZXQgbGFiZWxGb3JtYXQgPSAvLyBUT0RPOiBmdWxseSBwcmUtcGFyc2VcbiAgICAgICAgIG9wdGlvbnMuc2xvdExhYmVsRm9ybWF0ID09IG51bGwgPyBERUZBVUxUX1NMQVRfTEFCRUxfRk9STUFUIDpcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkob3B0aW9ucy5zbG90TGFiZWxGb3JtYXQpID8gY3JlYXRlRm9ybWF0dGVyKG9wdGlvbnMuc2xvdExhYmVsRm9ybWF0WzBdKSA6XG4gICAgICAgICAgICAgICAgY3JlYXRlRm9ybWF0dGVyKG9wdGlvbnMuc2xvdExhYmVsRm9ybWF0KTtcbiAgICAgICAgbGV0IHJlbmRlclByb3BzID0ge1xuICAgICAgICAgICAgbGV2ZWw6IDAsXG4gICAgICAgICAgICB0aW1lOiBwcm9wcy50aW1lLFxuICAgICAgICAgICAgZGF0ZTogZGF0ZUVudi50b0RhdGUocHJvcHMuZGF0ZSksXG4gICAgICAgICAgICB2aWV3OiB2aWV3QXBpLFxuICAgICAgICAgICAgdGV4dDogZGF0ZUVudi5mb3JtYXQocHJvcHMuZGF0ZSwgbGFiZWxGb3JtYXQpLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoQ29udGVudENvbnRhaW5lciwgeyBlbFRhZzogXCJ0ZFwiLCBlbENsYXNzZXM6IGNsYXNzTmFtZXMsIGVsQXR0cnM6IHtcbiAgICAgICAgICAgICAgICAnZGF0YS10aW1lJzogcHJvcHMuaXNvVGltZVN0cixcbiAgICAgICAgICAgIH0sIHJlbmRlclByb3BzOiByZW5kZXJQcm9wcywgZ2VuZXJhdG9yTmFtZTogXCJzbG90TGFiZWxDb250ZW50XCIsIGN1c3RvbUdlbmVyYXRvcjogb3B0aW9ucy5zbG90TGFiZWxDb250ZW50LCBkZWZhdWx0R2VuZXJhdG9yOiByZW5kZXJJbm5lckNvbnRlbnQsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy5zbG90TGFiZWxDbGFzc05hbWVzLCBkaWRNb3VudDogb3B0aW9ucy5zbG90TGFiZWxEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMuc2xvdExhYmVsV2lsbFVubW91bnQgfSwgKElubmVyQ29udGVudCkgPT4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtc2xvdC1sYWJlbC1mcmFtZSBmYy1zY3JvbGxncmlkLXNocmluay1mcmFtZVwiIH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KElubmVyQ29udGVudCwgeyBlbFRhZzogXCJkaXZcIiwgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgICAgICdmYy10aW1lZ3JpZC1zbG90LWxhYmVsLWN1c2hpb24nLFxuICAgICAgICAgICAgICAgICAgICAnZmMtc2Nyb2xsZ3JpZC1zaHJpbmstY3VzaGlvbicsXG4gICAgICAgICAgICAgICAgXSB9KSkpKSk7XG4gICAgfSkpO1xufVxuZnVuY3Rpb24gcmVuZGVySW5uZXJDb250ZW50KHByb3BzKSB7XG4gICAgcmV0dXJuIHByb3BzLnRleHQ7XG59XG5cbmNsYXNzIFRpbWVCb2R5QXhpcyBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuc2xhdE1ldGFzLm1hcCgoc2xhdE1ldGEpID0+IChjcmVhdGVFbGVtZW50KFwidHJcIiwgeyBrZXk6IHNsYXRNZXRhLmtleSB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChUaW1lQ29sc0F4aXNDZWxsLCBPYmplY3QuYXNzaWduKHt9LCBzbGF0TWV0YSkpKSkpO1xuICAgIH1cbn1cblxuY29uc3QgREVGQVVMVF9XRUVLX05VTV9GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoeyB3ZWVrOiAnc2hvcnQnIH0pO1xuY29uc3QgQVVUT19BTExfREFZX01BWF9FVkVOVF9ST1dTID0gNTtcbmNsYXNzIFRpbWVDb2xzVmlldyBleHRlbmRzIERhdGVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmFsbERheVNwbGl0dGVyID0gbmV3IEFsbERheVNwbGl0dGVyKCk7IC8vIGZvciB1c2UgYnkgc3ViY2xhc3Nlc1xuICAgICAgICB0aGlzLmhlYWRlckVsUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIHRoaXMucm9vdEVsUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIHRoaXMuc2Nyb2xsZXJFbFJlZiA9IGNyZWF0ZVJlZigpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgc2xhdENvb3JkczogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGxUb3BSZXF1ZXN0ID0gKHNjcm9sbFRvcCkgPT4ge1xuICAgICAgICAgICAgbGV0IHNjcm9sbGVyRWwgPSB0aGlzLnNjcm9sbGVyRWxSZWYuY3VycmVudDtcbiAgICAgICAgICAgIGlmIChzY3JvbGxlckVsKSB7IC8vIFRPRE86IG5vdCBzdXJlIGhvdyB0aGlzIGNvdWxkIGV2ZXIgYmUgbnVsbC4gd2VpcmRuZXNzIHdpdGggdGhlIHJlZHVjZXJcbiAgICAgICAgICAgICAgICBzY3JvbGxlckVsLnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyogSGVhZGVyIFJlbmRlciBNZXRob2RzXG4gICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gICAgICAgIHRoaXMucmVuZGVySGVhZEF4aXMgPSAocm93S2V5LCBmcmFtZUhlaWdodCA9ICcnKSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgICAgICBsZXQgeyBkYXRlUHJvZmlsZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGxldCByYW5nZSA9IGRhdGVQcm9maWxlLnJlbmRlclJhbmdlO1xuICAgICAgICAgICAgbGV0IGRheUNudCA9IGRpZmZEYXlzKHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQpO1xuICAgICAgICAgICAgLy8gb25seSBkbyBpbiBkYXkgdmlld3MgKHRvIGF2b2lkIGRvaW5nIGluIHdlZWsgdmlld3MgdGhhdCBkb250IG5lZWQgaXQpXG4gICAgICAgICAgICBsZXQgbmF2TGlua0F0dHJzID0gKGRheUNudCA9PT0gMSlcbiAgICAgICAgICAgICAgICA/IGJ1aWxkTmF2TGlua0F0dHJzKHRoaXMuY29udGV4dCwgcmFuZ2Uuc3RhcnQsICd3ZWVrJylcbiAgICAgICAgICAgICAgICA6IHt9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMud2Vla051bWJlcnMgJiYgcm93S2V5ID09PSAnZGF5Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChXZWVrTnVtYmVyQ29udGFpbmVyLCB7IGVsVGFnOiBcInRoXCIsIGVsQ2xhc3NlczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLXRpbWVncmlkLWF4aXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLXNjcm9sbGdyaWQtc2hyaW5rJyxcbiAgICAgICAgICAgICAgICAgICAgXSwgZWxBdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2FyaWEtaGlkZGVuJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSwgZGF0ZTogcmFuZ2Uuc3RhcnQsIGRlZmF1bHRGb3JtYXQ6IERFRkFVTFRfV0VFS19OVU1fRk9STUFUIH0sIChJbm5lckNvbnRlbnQpID0+IChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmMtdGltZWdyaWQtYXhpcy1mcmFtZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmMtc2Nyb2xsZ3JpZC1zaHJpbmstZnJhbWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLXRpbWVncmlkLWF4aXMtZnJhbWUtbGlxdWlkJyxcbiAgICAgICAgICAgICAgICAgICAgXS5qb2luKCcgJyksIHN0eWxlOiB7IGhlaWdodDogZnJhbWVIZWlnaHQgfSB9LFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KElubmVyQ29udGVudCwgeyBlbFRhZzogXCJhXCIsIGVsQ2xhc3NlczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdmYy10aW1lZ3JpZC1heGlzLWN1c2hpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdmYy1zY3JvbGxncmlkLXNocmluay1jdXNoaW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZmMtc2Nyb2xsZ3JpZC1zeW5jLWlubmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sIGVsQXR0cnM6IG5hdkxpbmtBdHRycyB9KSkpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJ0aFwiLCB7IFwiYXJpYS1oaWRkZW5cIjogdHJ1ZSwgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWF4aXNcIiB9LFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtYXhpcy1mcmFtZVwiLCBzdHlsZTogeyBoZWlnaHQ6IGZyYW1lSGVpZ2h0IH0gfSkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyogVGFibGUgQ29tcG9uZW50IFJlbmRlciBNZXRob2RzXG4gICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gICAgICAgIC8vIG9ubHkgYSBvbmUtd2F5IGhlaWdodCBzeW5jLiB3ZSBkb24ndCBzZW5kIHRoZSBheGlzIGlubmVyLWNvbnRlbnQgaGVpZ2h0IHRvIHRoZSBEYXlHcmlkLFxuICAgICAgICAvLyBidXQgRGF5R3JpZCBzdGlsbCBuZWVkcyB0byBoYXZlIGNsYXNzTmFtZXMgb24gaW5uZXIgZWxlbWVudHMgaW4gb3JkZXIgdG8gbWVhc3VyZS5cbiAgICAgICAgdGhpcy5yZW5kZXJUYWJsZVJvd0F4aXMgPSAocm93SGVpZ2h0KSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBvcHRpb25zLCB2aWV3QXBpIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgICAgICBsZXQgcmVuZGVyUHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgdGV4dDogb3B0aW9ucy5hbGxEYXlUZXh0LFxuICAgICAgICAgICAgICAgIHZpZXc6IHZpZXdBcGksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIC8vIFRPRE86IG1ha2UgcmV1c2FibGUgaG9vay4gdXNlZCBpbiBsaXN0IHZpZXcgdG9vXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KENvbnRlbnRDb250YWluZXIsIHsgZWxUYWc6IFwidGRcIiwgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgICAgICdmYy10aW1lZ3JpZC1heGlzJyxcbiAgICAgICAgICAgICAgICAgICAgJ2ZjLXNjcm9sbGdyaWQtc2hyaW5rJyxcbiAgICAgICAgICAgICAgICBdLCBlbEF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICdhcmlhLWhpZGRlbic6IHRydWUsXG4gICAgICAgICAgICAgICAgfSwgcmVuZGVyUHJvcHM6IHJlbmRlclByb3BzLCBnZW5lcmF0b3JOYW1lOiBcImFsbERheUNvbnRlbnRcIiwgY3VzdG9tR2VuZXJhdG9yOiBvcHRpb25zLmFsbERheUNvbnRlbnQsIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlckFsbERheUlubmVyLCBjbGFzc05hbWVHZW5lcmF0b3I6IG9wdGlvbnMuYWxsRGF5Q2xhc3NOYW1lcywgZGlkTW91bnQ6IG9wdGlvbnMuYWxsRGF5RGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLmFsbERheVdpbGxVbm1vdW50IH0sIChJbm5lckNvbnRlbnQpID0+IChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBbXG4gICAgICAgICAgICAgICAgICAgICdmYy10aW1lZ3JpZC1heGlzLWZyYW1lJyxcbiAgICAgICAgICAgICAgICAgICAgJ2ZjLXNjcm9sbGdyaWQtc2hyaW5rLWZyYW1lJyxcbiAgICAgICAgICAgICAgICAgICAgcm93SGVpZ2h0ID09IG51bGwgPyAnIGZjLXRpbWVncmlkLWF4aXMtZnJhbWUtbGlxdWlkJyA6ICcnLFxuICAgICAgICAgICAgICAgIF0uam9pbignICcpLCBzdHlsZTogeyBoZWlnaHQ6IHJvd0hlaWdodCB9IH0sXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChJbm5lckNvbnRlbnQsIHsgZWxUYWc6IFwic3BhblwiLCBlbENsYXNzZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdmYy10aW1lZ3JpZC1heGlzLWN1c2hpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLXNjcm9sbGdyaWQtc2hyaW5rLWN1c2hpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLXNjcm9sbGdyaWQtc3luYy1pbm5lcicsXG4gICAgICAgICAgICAgICAgICAgIF0gfSkpKSkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVNsYXRDb29yZHMgPSAoc2xhdENvb3JkcykgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IHNsYXRDb29yZHMgfSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIHJlbmRlcmluZ1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICByZW5kZXJTaW1wbGVMYXlvdXQoaGVhZGVyUm93Q29udGVudCwgYWxsRGF5Q29udGVudCwgdGltZUNvbnRlbnQpIHtcbiAgICAgICAgbGV0IHsgY29udGV4dCwgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBzZWN0aW9ucyA9IFtdO1xuICAgICAgICBsZXQgc3RpY2t5SGVhZGVyRGF0ZXMgPSBnZXRTdGlja3lIZWFkZXJEYXRlcyhjb250ZXh0Lm9wdGlvbnMpO1xuICAgICAgICBpZiAoaGVhZGVyUm93Q29udGVudCkge1xuICAgICAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2hlYWRlcicsXG4gICAgICAgICAgICAgICAga2V5OiAnaGVhZGVyJyxcbiAgICAgICAgICAgICAgICBpc1N0aWNreTogc3RpY2t5SGVhZGVyRGF0ZXMsXG4gICAgICAgICAgICAgICAgY2h1bms6IHtcbiAgICAgICAgICAgICAgICAgICAgZWxSZWY6IHRoaXMuaGVhZGVyRWxSZWYsXG4gICAgICAgICAgICAgICAgICAgIHRhYmxlQ2xhc3NOYW1lOiAnZmMtY29sLWhlYWRlcicsXG4gICAgICAgICAgICAgICAgICAgIHJvd0NvbnRlbnQ6IGhlYWRlclJvd0NvbnRlbnQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbGxEYXlDb250ZW50KSB7XG4gICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYm9keScsXG4gICAgICAgICAgICAgICAga2V5OiAnYWxsLWRheScsXG4gICAgICAgICAgICAgICAgY2h1bms6IHsgY29udGVudDogYWxsRGF5Q29udGVudCB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYm9keScsXG4gICAgICAgICAgICAgICAga2V5OiAnYWxsLWRheS1kaXZpZGVyJyxcbiAgICAgICAgICAgICAgICBvdXRlckNvbnRlbnQ6ICggLy8gVE9ETzogcmVuYW1lIHRvIGNlbGxDb250ZW50IHNvIGRvbid0IG5lZWQgdG8gZGVmaW5lIDx0cj4/XG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRyXCIsIHsgcm9sZTogXCJwcmVzZW50YXRpb25cIiwgY2xhc3NOYW1lOiBcImZjLXNjcm9sbGdyaWQtc2VjdGlvblwiIH0sXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IGNsYXNzTmFtZTogJ2ZjLXRpbWVncmlkLWRpdmlkZXIgJyArIGNvbnRleHQudGhlbWUuZ2V0Q2xhc3MoJ3RhYmxlQ2VsbFNoYWRlZCcpIH0pKSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdib2R5JyxcbiAgICAgICAgICAgIGtleTogJ2JvZHknLFxuICAgICAgICAgICAgbGlxdWlkOiB0cnVlLFxuICAgICAgICAgICAgZXhwYW5kUm93czogQm9vbGVhbihjb250ZXh0Lm9wdGlvbnMuZXhwYW5kUm93cyksXG4gICAgICAgICAgICBjaHVuazoge1xuICAgICAgICAgICAgICAgIHNjcm9sbGVyRWxSZWY6IHRoaXMuc2Nyb2xsZXJFbFJlZixcbiAgICAgICAgICAgICAgICBjb250ZW50OiB0aW1lQ29udGVudCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVmlld0NvbnRhaW5lciwgeyBlbFJlZjogdGhpcy5yb290RWxSZWYsIGVsQ2xhc3NlczogWydmYy10aW1lZ3JpZCddLCB2aWV3U3BlYzogY29udGV4dC52aWV3U3BlYyB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChTaW1wbGVTY3JvbGxHcmlkLCB7IGxpcXVpZDogIXByb3BzLmlzSGVpZ2h0QXV0byAmJiAhcHJvcHMuZm9yUHJpbnQsIGNvbGxhcHNpYmxlV2lkdGg6IHByb3BzLmZvclByaW50LCBjb2xzOiBbeyB3aWR0aDogJ3NocmluaycgfV0sIHNlY3Rpb25zOiBzZWN0aW9ucyB9KSkpO1xuICAgIH1cbiAgICByZW5kZXJIU2Nyb2xsTGF5b3V0KGhlYWRlclJvd0NvbnRlbnQsIGFsbERheUNvbnRlbnQsIHRpbWVDb250ZW50LCBjb2xDbnQsIGRheU1pbldpZHRoLCBzbGF0TWV0YXMsIHNsYXRDb29yZHMpIHtcbiAgICAgICAgbGV0IFNjcm9sbEdyaWQgPSB0aGlzLmNvbnRleHQucGx1Z2luSG9va3Muc2Nyb2xsR3JpZEltcGw7XG4gICAgICAgIGlmICghU2Nyb2xsR3JpZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBTY3JvbGxHcmlkIGltcGxlbWVudGF0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgY29udGV4dCwgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBzdGlja3lIZWFkZXJEYXRlcyA9ICFwcm9wcy5mb3JQcmludCAmJiBnZXRTdGlja3lIZWFkZXJEYXRlcyhjb250ZXh0Lm9wdGlvbnMpO1xuICAgICAgICBsZXQgc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyID0gIXByb3BzLmZvclByaW50ICYmIGdldFN0aWNreUZvb3RlclNjcm9sbGJhcihjb250ZXh0Lm9wdGlvbnMpO1xuICAgICAgICBsZXQgc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgaWYgKGhlYWRlclJvd0NvbnRlbnQpIHtcbiAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdoZWFkZXInLFxuICAgICAgICAgICAgICAgIGtleTogJ2hlYWRlcicsXG4gICAgICAgICAgICAgICAgaXNTdGlja3k6IHN0aWNreUhlYWRlckRhdGVzLFxuICAgICAgICAgICAgICAgIHN5bmNSb3dIZWlnaHRzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNodW5rczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdheGlzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0NvbnRlbnQ6IChhcmcpID0+IChjcmVhdGVFbGVtZW50KFwidHJcIiwgeyByb2xlOiBcInByZXNlbnRhdGlvblwiIH0sIHRoaXMucmVuZGVySGVhZEF4aXMoJ2RheScsIGFyZy5yb3dTeW5jSGVpZ2h0c1swXSkpKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAnY29scycsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbFJlZjogdGhpcy5oZWFkZXJFbFJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlQ2xhc3NOYW1lOiAnZmMtY29sLWhlYWRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dDb250ZW50OiBoZWFkZXJSb3dDb250ZW50LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxsRGF5Q29udGVudCkge1xuICAgICAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2JvZHknLFxuICAgICAgICAgICAgICAgIGtleTogJ2FsbC1kYXknLFxuICAgICAgICAgICAgICAgIHN5bmNSb3dIZWlnaHRzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNodW5rczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdheGlzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0NvbnRlbnQ6IChjb250ZW50QXJnKSA9PiAoY3JlYXRlRWxlbWVudChcInRyXCIsIHsgcm9sZTogXCJwcmVzZW50YXRpb25cIiB9LCB0aGlzLnJlbmRlclRhYmxlUm93QXhpcyhjb250ZW50QXJnLnJvd1N5bmNIZWlnaHRzWzBdKSkpLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdjb2xzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGFsbERheUNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAga2V5OiAnYWxsLWRheS1kaXZpZGVyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYm9keScsXG4gICAgICAgICAgICAgICAgb3V0ZXJDb250ZW50OiAoIC8vIFRPRE86IHJlbmFtZSB0byBjZWxsQ29udGVudCBzbyBkb24ndCBuZWVkIHRvIGRlZmluZSA8dHI+P1xuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IHJvbGU6IFwicHJlc2VudGF0aW9uXCIsIGNsYXNzTmFtZTogXCJmYy1zY3JvbGxncmlkLXNlY3Rpb25cIiB9LFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwidGRcIiwgeyBjb2xTcGFuOiAyLCBjbGFzc05hbWU6ICdmYy10aW1lZ3JpZC1kaXZpZGVyICcgKyBjb250ZXh0LnRoZW1lLmdldENsYXNzKCd0YWJsZUNlbGxTaGFkZWQnKSB9KSkpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlzTm93SW5kaWNhdG9yID0gY29udGV4dC5vcHRpb25zLm5vd0luZGljYXRvcjtcbiAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnYm9keScsXG4gICAgICAgICAgICBrZXk6ICdib2R5JyxcbiAgICAgICAgICAgIGxpcXVpZDogdHJ1ZSxcbiAgICAgICAgICAgIGV4cGFuZFJvd3M6IEJvb2xlYW4oY29udGV4dC5vcHRpb25zLmV4cGFuZFJvd3MpLFxuICAgICAgICAgICAgY2h1bmtzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBrZXk6ICdheGlzJyxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogKGFyZykgPT4gKFxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBtYWtlIHRoaXMgbm93LWluZGljYXRvciBhcnJvdyBtb3JlIERSWSB3aXRoIFRpbWVDb2xzQ29udGVudFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWF4aXMtY2h1bmtcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRhYmxlXCIsIHsgXCJhcmlhLWhpZGRlblwiOiB0cnVlLCBzdHlsZTogeyBoZWlnaHQ6IGFyZy5leHBhbmRSb3dzID8gYXJnLmNsaWVudEhlaWdodCA6ICcnIH0gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcudGFibGVDb2xHcm91cE5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRib2R5XCIsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoVGltZUJvZHlBeGlzLCB7IHNsYXRNZXRhczogc2xhdE1ldGFzIH0pKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItY29udGFpbmVyXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KE5vd1RpbWVyLCB7IHVuaXQ6IGlzTm93SW5kaWNhdG9yID8gJ21pbnV0ZScgOiAnZGF5JyAvKiBoYWNreSAqLyB9LCAobm93RGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm93SW5kaWNhdG9yVG9wID0gaXNOb3dJbmRpY2F0b3IgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsYXRDb29yZHMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsYXRDb29yZHMuc2FmZUNvbXB1dGVUb3Aobm93RGF0ZSk7IC8vIG1pZ2h0IHJldHVybiB2b2lkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygbm93SW5kaWNhdG9yVG9wID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KE5vd0luZGljYXRvckNvbnRhaW5lciwgeyBlbENsYXNzZXM6IFsnZmMtdGltZWdyaWQtbm93LWluZGljYXRvci1hcnJvdyddLCBlbFN0eWxlOiB7IHRvcDogbm93SW5kaWNhdG9yVG9wIH0sIGlzQXhpczogdHJ1ZSwgZGF0ZTogbm93RGF0ZSB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpKSksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogJ2NvbHMnLFxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxlckVsUmVmOiB0aGlzLnNjcm9sbGVyRWxSZWYsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRpbWVDb250ZW50LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHN0aWNreUZvb3RlclNjcm9sbGJhcikge1xuICAgICAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAga2V5OiAnZm9vdGVyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnZm9vdGVyJyxcbiAgICAgICAgICAgICAgICBpc1N0aWNreTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjaHVua3M6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAnYXhpcycsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiByZW5kZXJTY3JvbGxTaGltLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdjb2xzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHJlbmRlclNjcm9sbFNoaW0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChWaWV3Q29udGFpbmVyLCB7IGVsUmVmOiB0aGlzLnJvb3RFbFJlZiwgZWxDbGFzc2VzOiBbJ2ZjLXRpbWVncmlkJ10sIHZpZXdTcGVjOiBjb250ZXh0LnZpZXdTcGVjIH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFNjcm9sbEdyaWQsIHsgbGlxdWlkOiAhcHJvcHMuaXNIZWlnaHRBdXRvICYmICFwcm9wcy5mb3JQcmludCwgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50LCBjb2xsYXBzaWJsZVdpZHRoOiBmYWxzZSwgY29sR3JvdXBzOiBbXG4gICAgICAgICAgICAgICAgICAgIHsgd2lkdGg6ICdzaHJpbmsnLCBjb2xzOiBbeyB3aWR0aDogJ3NocmluaycgfV0gfSxcbiAgICAgICAgICAgICAgICAgICAgeyBjb2xzOiBbeyBzcGFuOiBjb2xDbnQsIG1pbldpZHRoOiBkYXlNaW5XaWR0aCB9XSB9LFxuICAgICAgICAgICAgICAgIF0sIHNlY3Rpb25zOiBzZWN0aW9ucyB9KSkpO1xuICAgIH1cbiAgICAvKiBEaW1lbnNpb25zXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgICBnZXRBbGxEYXlNYXhFdmVudFByb3BzKCkge1xuICAgICAgICBsZXQgeyBkYXlNYXhFdmVudHMsIGRheU1heEV2ZW50Um93cyB9ID0gdGhpcy5jb250ZXh0Lm9wdGlvbnM7XG4gICAgICAgIGlmIChkYXlNYXhFdmVudHMgPT09IHRydWUgfHwgZGF5TWF4RXZlbnRSb3dzID09PSB0cnVlKSB7IC8vIGlzIGF1dG8/XG4gICAgICAgICAgICBkYXlNYXhFdmVudHMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBkYXlNYXhFdmVudFJvd3MgPSBBVVRPX0FMTF9EQVlfTUFYX0VWRU5UX1JPV1M7IC8vIG1ha2Ugc3VyZSBcImF1dG9cIiBnb2VzIHRvIGEgcmVhbCBudW1iZXJcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkYXlNYXhFdmVudHMsIGRheU1heEV2ZW50Um93cyB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbmRlckFsbERheUlubmVyKHJlbmRlclByb3BzKSB7XG4gICAgcmV0dXJuIHJlbmRlclByb3BzLnRleHQ7XG59XG5cbmNsYXNzIFRpbWVDb2xzU2xhdHNDb29yZHMge1xuICAgIGNvbnN0cnVjdG9yKHBvc2l0aW9ucywgZGF0ZVByb2ZpbGUsIHNsb3REdXJhdGlvbikge1xuICAgICAgICB0aGlzLnBvc2l0aW9ucyA9IHBvc2l0aW9ucztcbiAgICAgICAgdGhpcy5kYXRlUHJvZmlsZSA9IGRhdGVQcm9maWxlO1xuICAgICAgICB0aGlzLnNsb3REdXJhdGlvbiA9IHNsb3REdXJhdGlvbjtcbiAgICB9XG4gICAgc2FmZUNvbXB1dGVUb3AoZGF0ZSkge1xuICAgICAgICBsZXQgeyBkYXRlUHJvZmlsZSB9ID0gdGhpcztcbiAgICAgICAgaWYgKHJhbmdlQ29udGFpbnNNYXJrZXIoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLCBkYXRlKSkge1xuICAgICAgICAgICAgbGV0IHN0YXJ0T2ZEYXlEYXRlID0gc3RhcnRPZkRheShkYXRlKTtcbiAgICAgICAgICAgIGxldCB0aW1lTXMgPSBkYXRlLnZhbHVlT2YoKSAtIHN0YXJ0T2ZEYXlEYXRlLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIGlmICh0aW1lTXMgPj0gYXNSb3VnaE1zKGRhdGVQcm9maWxlLnNsb3RNaW5UaW1lKSAmJlxuICAgICAgICAgICAgICAgIHRpbWVNcyA8IGFzUm91Z2hNcyhkYXRlUHJvZmlsZS5zbG90TWF4VGltZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlVGltZVRvcChjcmVhdGVEdXJhdGlvbih0aW1lTXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gQ29tcHV0ZXMgdGhlIHRvcCBjb29yZGluYXRlLCByZWxhdGl2ZSB0byB0aGUgYm91bmRzIG9mIHRoZSBncmlkLCBvZiB0aGUgZ2l2ZW4gZGF0ZS5cbiAgICAvLyBBIGBzdGFydE9mRGF5RGF0ZWAgbXVzdCBiZSBnaXZlbiBmb3IgYXZvaWRpbmcgYW1iaWd1aXR5IG92ZXIgaG93IHRvIHRyZWF0IG1pZG5pZ2h0LlxuICAgIGNvbXB1dGVEYXRlVG9wKHdoZW4sIHN0YXJ0T2ZEYXlEYXRlKSB7XG4gICAgICAgIGlmICghc3RhcnRPZkRheURhdGUpIHtcbiAgICAgICAgICAgIHN0YXJ0T2ZEYXlEYXRlID0gc3RhcnRPZkRheSh3aGVuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlVGltZVRvcChjcmVhdGVEdXJhdGlvbih3aGVuLnZhbHVlT2YoKSAtIHN0YXJ0T2ZEYXlEYXRlLnZhbHVlT2YoKSkpO1xuICAgIH1cbiAgICAvLyBDb21wdXRlcyB0aGUgdG9wIGNvb3JkaW5hdGUsIHJlbGF0aXZlIHRvIHRoZSBib3VuZHMgb2YgdGhlIGdyaWQsIG9mIHRoZSBnaXZlbiB0aW1lIChhIER1cmF0aW9uKS5cbiAgICAvLyBUaGlzIGlzIGEgbWFrZXNoaWZ5IHdheSB0byBjb21wdXRlIHRoZSB0aW1lLXRvcC4gQXNzdW1lcyBhbGwgc2xhdE1ldGFzIGRhdGVzIGFyZSB1bmlmb3JtLlxuICAgIC8vIEV2ZW50dWFsbHkgYWxsb3cgY29tcHV0YXRpb24gd2l0aCBhcmJpcmFyeSBzbGF0IGRhdGVzLlxuICAgIGNvbXB1dGVUaW1lVG9wKGR1cmF0aW9uKSB7XG4gICAgICAgIGxldCB7IHBvc2l0aW9ucywgZGF0ZVByb2ZpbGUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBsZW4gPSBwb3NpdGlvbnMuZWxzLmxlbmd0aDtcbiAgICAgICAgLy8gZmxvYXRpbmctcG9pbnQgdmFsdWUgb2YgIyBvZiBzbG90cyBjb3ZlcmVkXG4gICAgICAgIGxldCBzbGF0Q292ZXJhZ2UgPSAoZHVyYXRpb24ubWlsbGlzZWNvbmRzIC0gYXNSb3VnaE1zKGRhdGVQcm9maWxlLnNsb3RNaW5UaW1lKSkgLyBhc1JvdWdoTXModGhpcy5zbG90RHVyYXRpb24pO1xuICAgICAgICBsZXQgc2xhdEluZGV4O1xuICAgICAgICBsZXQgc2xhdFJlbWFpbmRlcjtcbiAgICAgICAgLy8gY29tcHV0ZSBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBmb3IgaG93IG1hbnkgc2xhdHMgc2hvdWxkIGJlIHByb2dyZXNzZWQgdGhyb3VnaC5cbiAgICAgICAgLy8gZnJvbSAwIHRvIG51bWJlciBvZiBzbGF0cyAoaW5jbHVzaXZlKVxuICAgICAgICAvLyBjb25zdHJhaW5lZCBiZWNhdXNlIHNsb3RNaW5UaW1lL3Nsb3RNYXhUaW1lIG1pZ2h0IGJlIGN1c3RvbWl6ZWQuXG4gICAgICAgIHNsYXRDb3ZlcmFnZSA9IE1hdGgubWF4KDAsIHNsYXRDb3ZlcmFnZSk7XG4gICAgICAgIHNsYXRDb3ZlcmFnZSA9IE1hdGgubWluKGxlbiwgc2xhdENvdmVyYWdlKTtcbiAgICAgICAgLy8gYW4gaW50ZWdlciBpbmRleCBvZiB0aGUgZnVydGhlc3Qgd2hvbGUgc2xhdFxuICAgICAgICAvLyBmcm9tIDAgdG8gbnVtYmVyIHNsYXRzICgqZXhjbHVzaXZlKiwgc28gbGVuLTEpXG4gICAgICAgIHNsYXRJbmRleCA9IE1hdGguZmxvb3Ioc2xhdENvdmVyYWdlKTtcbiAgICAgICAgc2xhdEluZGV4ID0gTWF0aC5taW4oc2xhdEluZGV4LCBsZW4gLSAxKTtcbiAgICAgICAgLy8gaG93IG11Y2ggZnVydGhlciB0aHJvdWdoIHRoZSBzbGF0SW5kZXggc2xhdCAoZnJvbSAwLjAtMS4wKSBtdXN0IGJlIGNvdmVyZWQgaW4gYWRkaXRpb24uXG4gICAgICAgIC8vIGNvdWxkIGJlIDEuMCBpZiBzbGF0Q292ZXJhZ2UgaXMgY292ZXJpbmcgKmFsbCogdGhlIHNsb3RzXG4gICAgICAgIHNsYXRSZW1haW5kZXIgPSBzbGF0Q292ZXJhZ2UgLSBzbGF0SW5kZXg7XG4gICAgICAgIHJldHVybiBwb3NpdGlvbnMudG9wc1tzbGF0SW5kZXhdICtcbiAgICAgICAgICAgIHBvc2l0aW9ucy5nZXRIZWlnaHQoc2xhdEluZGV4KSAqIHNsYXRSZW1haW5kZXI7XG4gICAgfVxufVxuXG5jbGFzcyBUaW1lQ29sc1NsYXRzQm9keSBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgICAgIGxldCB7IHNsYXRFbFJlZnMgfSA9IHByb3BzO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJ0Ym9keVwiLCBudWxsLCBwcm9wcy5zbGF0TWV0YXMubWFwKChzbGF0TWV0YSwgaSkgPT4ge1xuICAgICAgICAgICAgbGV0IHJlbmRlclByb3BzID0ge1xuICAgICAgICAgICAgICAgIHRpbWU6IHNsYXRNZXRhLnRpbWUsXG4gICAgICAgICAgICAgICAgZGF0ZTogY29udGV4dC5kYXRlRW52LnRvRGF0ZShzbGF0TWV0YS5kYXRlKSxcbiAgICAgICAgICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwidHJcIiwgeyBrZXk6IHNsYXRNZXRhLmtleSwgcmVmOiBzbGF0RWxSZWZzLmNyZWF0ZVJlZihzbGF0TWV0YS5rZXkpIH0sXG4gICAgICAgICAgICAgICAgcHJvcHMuYXhpcyAmJiAoY3JlYXRlRWxlbWVudChUaW1lQ29sc0F4aXNDZWxsLCBPYmplY3QuYXNzaWduKHt9LCBzbGF0TWV0YSkpKSxcbiAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KENvbnRlbnRDb250YWluZXIsIHsgZWxUYWc6IFwidGRcIiwgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmMtdGltZWdyaWQtc2xvdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmMtdGltZWdyaWQtc2xvdC1sYW5lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICFzbGF0TWV0YS5pc0xhYmVsZWQgJiYgJ2ZjLXRpbWVncmlkLXNsb3QtbWlub3InLFxuICAgICAgICAgICAgICAgICAgICBdLCBlbEF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS10aW1lJzogc2xhdE1ldGEuaXNvVGltZVN0cixcbiAgICAgICAgICAgICAgICAgICAgfSwgcmVuZGVyUHJvcHM6IHJlbmRlclByb3BzLCBnZW5lcmF0b3JOYW1lOiBcInNsb3RMYW5lQ29udGVudFwiLCBjdXN0b21HZW5lcmF0b3I6IG9wdGlvbnMuc2xvdExhbmVDb250ZW50LCBjbGFzc05hbWVHZW5lcmF0b3I6IG9wdGlvbnMuc2xvdExhbmVDbGFzc05hbWVzLCBkaWRNb3VudDogb3B0aW9ucy5zbG90TGFuZURpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy5zbG90TGFuZVdpbGxVbm1vdW50IH0pKSk7XG4gICAgICAgIH0pKSk7XG4gICAgfVxufVxuXG4vKlxuZm9yIHRoZSBob3Jpem9udGFsIFwic2xhdHNcIiB0aGF0IHJ1biB3aWR0aC13aXNlLiBIYXMgYSB0aW1lIGF4aXMgb24gYSBzaWRlLiBEZXBlbmRzIG9uIFJUTC5cbiovXG5jbGFzcyBUaW1lQ29sc1NsYXRzIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMucm9vdEVsUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIHRoaXMuc2xhdEVsUmVmcyA9IG5ldyBSZWZNYXAoKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiB0aGlzLnJvb3RFbFJlZiwgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLXNsb3RzXCIgfSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJ0YWJsZVwiLCB7IFwiYXJpYS1oaWRkZW5cIjogdHJ1ZSwgY2xhc3NOYW1lOiBjb250ZXh0LnRoZW1lLmdldENsYXNzKCd0YWJsZScpLCBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICBtaW5XaWR0aDogcHJvcHMudGFibGVNaW5XaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHByb3BzLm1pbkhlaWdodCxcbiAgICAgICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICAgICAgcHJvcHMudGFibGVDb2xHcm91cE5vZGUgLyogcmVsaWVzIG9uIHRoZXJlIG9ubHkgYmVpbmcgYSBzaW5nbGUgPGNvbD4gZm9yIHRoZSBheGlzICovLFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoVGltZUNvbHNTbGF0c0JvZHksIHsgc2xhdEVsUmVmczogdGhpcy5zbGF0RWxSZWZzLCBheGlzOiBwcm9wcy5heGlzLCBzbGF0TWV0YXM6IHByb3BzLnNsYXRNZXRhcyB9KSkpKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU2l6aW5nKCk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVTaXppbmcoKTtcbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLm9uQ29vcmRzKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uQ29vcmRzKG51bGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZVNpemluZygpIHtcbiAgICAgICAgbGV0IHsgY29udGV4dCwgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGlmIChwcm9wcy5vbkNvb3JkcyAmJlxuICAgICAgICAgICAgcHJvcHMuY2xpZW50V2lkdGggIT09IG51bGwgLy8gbWVhbnMgc2l6aW5nIGhhcyBzdGFiaWxpemVkXG4gICAgICAgICkge1xuICAgICAgICAgICAgbGV0IHJvb3RFbCA9IHRoaXMucm9vdEVsUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICBpZiAocm9vdEVsLm9mZnNldEhlaWdodCkgeyAvLyBub3QgaGlkZGVuIGJ5IGNzc1xuICAgICAgICAgICAgICAgIHByb3BzLm9uQ29vcmRzKG5ldyBUaW1lQ29sc1NsYXRzQ29vcmRzKG5ldyBQb3NpdGlvbkNhY2hlKHRoaXMucm9vdEVsUmVmLmN1cnJlbnQsIGNvbGxlY3RTbGF0RWxzKHRoaXMuc2xhdEVsUmVmcy5jdXJyZW50TWFwLCBwcm9wcy5zbGF0TWV0YXMpLCBmYWxzZSwgdHJ1ZSksIHRoaXMucHJvcHMuZGF0ZVByb2ZpbGUsIGNvbnRleHQub3B0aW9ucy5zbG90RHVyYXRpb24pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbGxlY3RTbGF0RWxzKGVsTWFwLCBzbGF0TWV0YXMpIHtcbiAgICByZXR1cm4gc2xhdE1ldGFzLm1hcCgoc2xhdE1ldGEpID0+IGVsTWFwW3NsYXRNZXRhLmtleV0pO1xufVxuXG5mdW5jdGlvbiBzcGxpdFNlZ3NCeUNvbChzZWdzLCBjb2xDbnQpIHtcbiAgICBsZXQgc2Vnc0J5Q29sID0gW107XG4gICAgbGV0IGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGNvbENudDsgaSArPSAxKSB7XG4gICAgICAgIHNlZ3NCeUNvbC5wdXNoKFtdKTtcbiAgICB9XG4gICAgaWYgKHNlZ3MpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHNlZ3NCeUNvbFtzZWdzW2ldLmNvbF0ucHVzaChzZWdzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2Vnc0J5Q29sO1xufVxuZnVuY3Rpb24gc3BsaXRJbnRlcmFjdGlvbkJ5Q29sKHVpLCBjb2xDbnQpIHtcbiAgICBsZXQgYnlSb3cgPSBbXTtcbiAgICBpZiAoIXVpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sQ250OyBpICs9IDEpIHtcbiAgICAgICAgICAgIGJ5Um93W2ldID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xDbnQ7IGkgKz0gMSkge1xuICAgICAgICAgICAgYnlSb3dbaV0gPSB7XG4gICAgICAgICAgICAgICAgYWZmZWN0ZWRJbnN0YW5jZXM6IHVpLmFmZmVjdGVkSW5zdGFuY2VzLFxuICAgICAgICAgICAgICAgIGlzRXZlbnQ6IHVpLmlzRXZlbnQsXG4gICAgICAgICAgICAgICAgc2VnczogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHNlZyBvZiB1aS5zZWdzKSB7XG4gICAgICAgICAgICBieVJvd1tzZWcuY29sXS5zZWdzLnB1c2goc2VnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYnlSb3c7XG59XG5cbmNsYXNzIFRpbWVDb2xNb3JlTGluayBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChNb3JlTGlua0NvbnRhaW5lciwgeyBlbENsYXNzZXM6IFsnZmMtdGltZWdyaWQtbW9yZS1saW5rJ10sIGVsU3R5bGU6IHtcbiAgICAgICAgICAgICAgICB0b3A6IHByb3BzLnRvcCxcbiAgICAgICAgICAgICAgICBib3R0b206IHByb3BzLmJvdHRvbSxcbiAgICAgICAgICAgIH0sIGFsbERheURhdGU6IG51bGwsIG1vcmVDbnQ6IHByb3BzLmhpZGRlblNlZ3MubGVuZ3RoLCBhbGxTZWdzOiBwcm9wcy5oaWRkZW5TZWdzLCBoaWRkZW5TZWdzOiBwcm9wcy5oaWRkZW5TZWdzLCBleHRyYURhdGVTcGFuOiBwcm9wcy5leHRyYURhdGVTcGFuLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsIHBvcG92ZXJDb250ZW50OiAoKSA9PiByZW5kZXJQbGFpbkZnU2Vncyhwcm9wcy5oaWRkZW5TZWdzLCBwcm9wcyksIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlck1vcmVMaW5rSW5uZXIsIGZvcmNlVGltZWQ6IHRydWUgfSwgKElubmVyQ29udGVudCkgPT4gKGNyZWF0ZUVsZW1lbnQoSW5uZXJDb250ZW50LCB7IGVsVGFnOiBcImRpdlwiLCBlbENsYXNzZXM6IFsnZmMtdGltZWdyaWQtbW9yZS1saW5rLWlubmVyJywgJ2ZjLXN0aWNreSddIH0pKSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbmRlck1vcmVMaW5rSW5uZXIocHJvcHMpIHtcbiAgICByZXR1cm4gcHJvcHMuc2hvcnRUZXh0O1xufVxuXG4vLyBzZWdJbnB1dHMgYXNzdW1lZCBzb3J0ZWRcbmZ1bmN0aW9uIGJ1aWxkUG9zaXRpb25pbmcoc2VnSW5wdXRzLCBzdHJpY3RPcmRlciwgbWF4U3RhY2tDbnQpIHtcbiAgICBsZXQgaGllcmFyY2h5ID0gbmV3IFNlZ0hpZXJhcmNoeSgpO1xuICAgIGlmIChzdHJpY3RPcmRlciAhPSBudWxsKSB7XG4gICAgICAgIGhpZXJhcmNoeS5zdHJpY3RPcmRlciA9IHN0cmljdE9yZGVyO1xuICAgIH1cbiAgICBpZiAobWF4U3RhY2tDbnQgIT0gbnVsbCkge1xuICAgICAgICBoaWVyYXJjaHkubWF4U3RhY2tDbnQgPSBtYXhTdGFja0NudDtcbiAgICB9XG4gICAgbGV0IGhpZGRlbkVudHJpZXMgPSBoaWVyYXJjaHkuYWRkU2VncyhzZWdJbnB1dHMpO1xuICAgIGxldCBoaWRkZW5Hcm91cHMgPSBncm91cEludGVyc2VjdGluZ0VudHJpZXMoaGlkZGVuRW50cmllcyk7XG4gICAgbGV0IHdlYiA9IGJ1aWxkV2ViKGhpZXJhcmNoeSk7XG4gICAgd2ViID0gc3RyZXRjaFdlYih3ZWIsIDEpOyAvLyBhbGwgbGV2ZWxDb29yZHMvdGhpY2tuZXNzIHdpbGwgaGF2ZSAwLjAtMS4wXG4gICAgbGV0IHNlZ1JlY3RzID0gd2ViVG9SZWN0cyh3ZWIpO1xuICAgIHJldHVybiB7IHNlZ1JlY3RzLCBoaWRkZW5Hcm91cHMgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkV2ViKGhpZXJhcmNoeSkge1xuICAgIGNvbnN0IHsgZW50cmllc0J5TGV2ZWwgfSA9IGhpZXJhcmNoeTtcbiAgICBjb25zdCBidWlsZE5vZGUgPSBjYWNoZWFibGUoKGxldmVsLCBsYXRlcmFsKSA9PiBsZXZlbCArICc6JyArIGxhdGVyYWwsIChsZXZlbCwgbGF0ZXJhbCkgPT4ge1xuICAgICAgICBsZXQgc2libGluZ1JhbmdlID0gZmluZE5leHRMZXZlbFNlZ3MoaGllcmFyY2h5LCBsZXZlbCwgbGF0ZXJhbCk7XG4gICAgICAgIGxldCBuZXh0TGV2ZWxSZXMgPSBidWlsZE5vZGVzKHNpYmxpbmdSYW5nZSwgYnVpbGROb2RlKTtcbiAgICAgICAgbGV0IGVudHJ5ID0gZW50cmllc0J5TGV2ZWxbbGV2ZWxdW2xhdGVyYWxdO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBlbnRyeSksIHsgbmV4dExldmVsTm9kZXM6IG5leHRMZXZlbFJlc1swXSB9KSxcbiAgICAgICAgICAgIGVudHJ5LnRoaWNrbmVzcyArIG5leHRMZXZlbFJlc1sxXSwgLy8gdGhlIHByZXNzdXJlIGJ1aWxkc1xuICAgICAgICBdO1xuICAgIH0pO1xuICAgIHJldHVybiBidWlsZE5vZGVzKGVudHJpZXNCeUxldmVsLmxlbmd0aFxuICAgICAgICA/IHsgbGV2ZWw6IDAsIGxhdGVyYWxTdGFydDogMCwgbGF0ZXJhbEVuZDogZW50cmllc0J5TGV2ZWxbMF0ubGVuZ3RoIH1cbiAgICAgICAgOiBudWxsLCBidWlsZE5vZGUpWzBdO1xufVxuZnVuY3Rpb24gYnVpbGROb2RlcyhzaWJsaW5nUmFuZ2UsIGJ1aWxkTm9kZSkge1xuICAgIGlmICghc2libGluZ1JhbmdlKSB7XG4gICAgICAgIHJldHVybiBbW10sIDBdO1xuICAgIH1cbiAgICBsZXQgeyBsZXZlbCwgbGF0ZXJhbFN0YXJ0LCBsYXRlcmFsRW5kIH0gPSBzaWJsaW5nUmFuZ2U7XG4gICAgbGV0IGxhdGVyYWwgPSBsYXRlcmFsU3RhcnQ7XG4gICAgbGV0IHBhaXJzID0gW107XG4gICAgd2hpbGUgKGxhdGVyYWwgPCBsYXRlcmFsRW5kKSB7XG4gICAgICAgIHBhaXJzLnB1c2goYnVpbGROb2RlKGxldmVsLCBsYXRlcmFsKSk7XG4gICAgICAgIGxhdGVyYWwgKz0gMTtcbiAgICB9XG4gICAgcGFpcnMuc29ydChjbXBEZXNjUHJlc3N1cmVzKTtcbiAgICByZXR1cm4gW1xuICAgICAgICBwYWlycy5tYXAoZXh0cmFjdE5vZGUpLFxuICAgICAgICBwYWlyc1swXVsxXSwgLy8gZmlyc3QgaXRlbSdzIHByZXNzdXJlXG4gICAgXTtcbn1cbmZ1bmN0aW9uIGNtcERlc2NQcmVzc3VyZXMoYSwgYikge1xuICAgIHJldHVybiBiWzFdIC0gYVsxXTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3ROb2RlKGEpIHtcbiAgICByZXR1cm4gYVswXTtcbn1cbmZ1bmN0aW9uIGZpbmROZXh0TGV2ZWxTZWdzKGhpZXJhcmNoeSwgc3ViamVjdExldmVsLCBzdWJqZWN0TGF0ZXJhbCkge1xuICAgIGxldCB7IGxldmVsQ29vcmRzLCBlbnRyaWVzQnlMZXZlbCB9ID0gaGllcmFyY2h5O1xuICAgIGxldCBzdWJqZWN0RW50cnkgPSBlbnRyaWVzQnlMZXZlbFtzdWJqZWN0TGV2ZWxdW3N1YmplY3RMYXRlcmFsXTtcbiAgICBsZXQgYWZ0ZXJTdWJqZWN0ID0gbGV2ZWxDb29yZHNbc3ViamVjdExldmVsXSArIHN1YmplY3RFbnRyeS50aGlja25lc3M7XG4gICAgbGV0IGxldmVsQ250ID0gbGV2ZWxDb29yZHMubGVuZ3RoO1xuICAgIGxldCBsZXZlbCA9IHN1YmplY3RMZXZlbDtcbiAgICAvLyBza2lwIHBhc3QgbGV2ZWxzIHRoYXQgYXJlIHRvbyBoaWdoIHVwXG4gICAgZm9yICg7IGxldmVsIDwgbGV2ZWxDbnQgJiYgbGV2ZWxDb29yZHNbbGV2ZWxdIDwgYWZ0ZXJTdWJqZWN0OyBsZXZlbCArPSAxKVxuICAgICAgICA7IC8vIGRvIG5vdGhpbmdcbiAgICBmb3IgKDsgbGV2ZWwgPCBsZXZlbENudDsgbGV2ZWwgKz0gMSkge1xuICAgICAgICBsZXQgZW50cmllcyA9IGVudHJpZXNCeUxldmVsW2xldmVsXTtcbiAgICAgICAgbGV0IGVudHJ5O1xuICAgICAgICBsZXQgc2VhcmNoSW5kZXggPSBiaW5hcnlTZWFyY2goZW50cmllcywgc3ViamVjdEVudHJ5LnNwYW4uc3RhcnQsIGdldEVudHJ5U3BhbkVuZCk7XG4gICAgICAgIGxldCBsYXRlcmFsU3RhcnQgPSBzZWFyY2hJbmRleFswXSArIHNlYXJjaEluZGV4WzFdOyAvLyBpZiBleGFjdCBtYXRjaCAod2hpY2ggZG9lc24ndCBjb2xsaWRlKSwgZ28gdG8gbmV4dCBvbmVcbiAgICAgICAgbGV0IGxhdGVyYWxFbmQgPSBsYXRlcmFsU3RhcnQ7XG4gICAgICAgIHdoaWxlICggLy8gbG9vcCB0aHJvdWdoIGVudHJpZXMgdGhhdCBob3Jpem9udGFsbHkgaW50ZXJzZWN0XG4gICAgICAgIChlbnRyeSA9IGVudHJpZXNbbGF0ZXJhbEVuZF0pICYmIC8vIGJ1dCBub3QgcGFzdCB0aGUgd2hvbGUgc2VnIGxpc3RcbiAgICAgICAgICAgIGVudHJ5LnNwYW4uc3RhcnQgPCBzdWJqZWN0RW50cnkuc3Bhbi5lbmQpIHtcbiAgICAgICAgICAgIGxhdGVyYWxFbmQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGF0ZXJhbFN0YXJ0IDwgbGF0ZXJhbEVuZCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbGV2ZWwsIGxhdGVyYWxTdGFydCwgbGF0ZXJhbEVuZCB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gc3RyZXRjaFdlYih0b3BMZXZlbE5vZGVzLCB0b3RhbFRoaWNrbmVzcykge1xuICAgIGNvbnN0IHN0cmV0Y2hOb2RlID0gY2FjaGVhYmxlKChub2RlLCBzdGFydENvb3JkLCBwcmV2VGhpY2tuZXNzKSA9PiBidWlsZEVudHJ5S2V5KG5vZGUpLCAobm9kZSwgc3RhcnRDb29yZCwgcHJldlRoaWNrbmVzcykgPT4ge1xuICAgICAgICBsZXQgeyBuZXh0TGV2ZWxOb2RlcywgdGhpY2tuZXNzIH0gPSBub2RlO1xuICAgICAgICBsZXQgYWxsVGhpY2tuZXNzID0gdGhpY2tuZXNzICsgcHJldlRoaWNrbmVzcztcbiAgICAgICAgbGV0IHRoaWNrbmVzc0ZyYWN0aW9uID0gdGhpY2tuZXNzIC8gYWxsVGhpY2tuZXNzO1xuICAgICAgICBsZXQgZW5kQ29vcmQ7XG4gICAgICAgIGxldCBuZXdDaGlsZHJlbiA9IFtdO1xuICAgICAgICBpZiAoIW5leHRMZXZlbE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgZW5kQ29vcmQgPSB0b3RhbFRoaWNrbmVzcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNoaWxkTm9kZSBvZiBuZXh0TGV2ZWxOb2Rlcykge1xuICAgICAgICAgICAgICAgIGlmIChlbmRDb29yZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXMgPSBzdHJldGNoTm9kZShjaGlsZE5vZGUsIHN0YXJ0Q29vcmQsIGFsbFRoaWNrbmVzcyk7XG4gICAgICAgICAgICAgICAgICAgIGVuZENvb3JkID0gcmVzWzBdO1xuICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbi5wdXNoKHJlc1sxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzID0gc3RyZXRjaE5vZGUoY2hpbGROb2RlLCBlbmRDb29yZCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuLnB1c2gocmVzWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld1RoaWNrbmVzcyA9IChlbmRDb29yZCAtIHN0YXJ0Q29vcmQpICogdGhpY2tuZXNzRnJhY3Rpb247XG4gICAgICAgIHJldHVybiBbZW5kQ29vcmQgLSBuZXdUaGlja25lc3MsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbm9kZSksIHsgdGhpY2tuZXNzOiBuZXdUaGlja25lc3MsIG5leHRMZXZlbE5vZGVzOiBuZXdDaGlsZHJlbiB9KV07XG4gICAgfSk7XG4gICAgcmV0dXJuIHRvcExldmVsTm9kZXMubWFwKChub2RlKSA9PiBzdHJldGNoTm9kZShub2RlLCAwLCAwKVsxXSk7XG59XG4vLyBub3Qgc29ydGVkIGluIGFueSBwYXJ0aWN1bGFyIG9yZGVyXG5mdW5jdGlvbiB3ZWJUb1JlY3RzKHRvcExldmVsTm9kZXMpIHtcbiAgICBsZXQgcmVjdHMgPSBbXTtcbiAgICBjb25zdCBwcm9jZXNzTm9kZSA9IGNhY2hlYWJsZSgobm9kZSwgbGV2ZWxDb29yZCwgc3RhY2tEZXB0aCkgPT4gYnVpbGRFbnRyeUtleShub2RlKSwgKG5vZGUsIGxldmVsQ29vcmQsIHN0YWNrRGVwdGgpID0+IHtcbiAgICAgICAgbGV0IHJlY3QgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG5vZGUpLCB7IGxldmVsQ29vcmQsXG4gICAgICAgICAgICBzdGFja0RlcHRoLCBzdGFja0ZvcndhcmQ6IDAgfSk7XG4gICAgICAgIHJlY3RzLnB1c2gocmVjdCk7XG4gICAgICAgIHJldHVybiAocmVjdC5zdGFja0ZvcndhcmQgPSBwcm9jZXNzTm9kZXMobm9kZS5uZXh0TGV2ZWxOb2RlcywgbGV2ZWxDb29yZCArIG5vZGUudGhpY2tuZXNzLCBzdGFja0RlcHRoICsgMSkgKyAxKTtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBwcm9jZXNzTm9kZXMobm9kZXMsIGxldmVsQ29vcmQsIHN0YWNrRGVwdGgpIHtcbiAgICAgICAgbGV0IHN0YWNrRm9yd2FyZCA9IDA7XG4gICAgICAgIGZvciAobGV0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgICAgICAgIHN0YWNrRm9yd2FyZCA9IE1hdGgubWF4KHByb2Nlc3NOb2RlKG5vZGUsIGxldmVsQ29vcmQsIHN0YWNrRGVwdGgpLCBzdGFja0ZvcndhcmQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGFja0ZvcndhcmQ7XG4gICAgfVxuICAgIHByb2Nlc3NOb2Rlcyh0b3BMZXZlbE5vZGVzLCAwLCAwKTtcbiAgICByZXR1cm4gcmVjdHM7IC8vIFRPRE86IHNvcnQgcmVjdHMgYnkgbGV2ZWxDb29yZCB0byBiZSBjb25zaXN0ZW50IHdpdGggdG9SZWN0cz9cbn1cbi8vIFRPRE86IG1vdmUgdG8gZ2VuZXJhbCB1dGlsXG5mdW5jdGlvbiBjYWNoZWFibGUoa2V5RnVuYywgd29ya0Z1bmMpIHtcbiAgICBjb25zdCBjYWNoZSA9IHt9O1xuICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICBsZXQga2V5ID0ga2V5RnVuYyguLi5hcmdzKTtcbiAgICAgICAgcmV0dXJuIChrZXkgaW4gY2FjaGUpXG4gICAgICAgICAgICA/IGNhY2hlW2tleV1cbiAgICAgICAgICAgIDogKGNhY2hlW2tleV0gPSB3b3JrRnVuYyguLi5hcmdzKSk7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZVNlZ1ZDb29yZHMoc2VncywgY29sRGF0ZSwgc2xhdENvb3JkcyA9IG51bGwsIGV2ZW50TWluSGVpZ2h0ID0gMCkge1xuICAgIGxldCB2Y29vcmRzID0gW107XG4gICAgaWYgKHNsYXRDb29yZHMpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBsZXQgc2VnID0gc2Vnc1tpXTtcbiAgICAgICAgICAgIGxldCBzcGFuU3RhcnQgPSBzbGF0Q29vcmRzLmNvbXB1dGVEYXRlVG9wKHNlZy5zdGFydCwgY29sRGF0ZSk7XG4gICAgICAgICAgICBsZXQgc3BhbkVuZCA9IE1hdGgubWF4KHNwYW5TdGFydCArIChldmVudE1pbkhlaWdodCB8fCAwKSwgLy8gOihcbiAgICAgICAgICAgIHNsYXRDb29yZHMuY29tcHV0ZURhdGVUb3Aoc2VnLmVuZCwgY29sRGF0ZSkpO1xuICAgICAgICAgICAgdmNvb3Jkcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBzdGFydDogTWF0aC5yb3VuZChzcGFuU3RhcnQpLFxuICAgICAgICAgICAgICAgIGVuZDogTWF0aC5yb3VuZChzcGFuRW5kKSwgLy9cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2Y29vcmRzO1xufVxuZnVuY3Rpb24gY29tcHV0ZUZnU2VnUGxhY2VtZW50cyhzZWdzLCBzZWdWQ29vcmRzLCAvLyBtaWdodCBub3QgaGF2ZSBmb3IgZXZlcnkgc2VnXG5ldmVudE9yZGVyU3RyaWN0LCBldmVudE1heFN0YWNrKSB7XG4gICAgbGV0IHNlZ0lucHV0cyA9IFtdO1xuICAgIGxldCBkdW1iU2VncyA9IFtdOyAvLyBzZWdzIHdpdGhvdXQgY29vcmRzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGxldCB2Y29vcmRzID0gc2VnVkNvb3Jkc1tpXTtcbiAgICAgICAgaWYgKHZjb29yZHMpIHtcbiAgICAgICAgICAgIHNlZ0lucHV0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICB0aGlja25lc3M6IDEsXG4gICAgICAgICAgICAgICAgc3BhbjogdmNvb3JkcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZHVtYlNlZ3MucHVzaChzZWdzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgeyBzZWdSZWN0cywgaGlkZGVuR3JvdXBzIH0gPSBidWlsZFBvc2l0aW9uaW5nKHNlZ0lucHV0cywgZXZlbnRPcmRlclN0cmljdCwgZXZlbnRNYXhTdGFjayk7XG4gICAgbGV0IHNlZ1BsYWNlbWVudHMgPSBbXTtcbiAgICBmb3IgKGxldCBzZWdSZWN0IG9mIHNlZ1JlY3RzKSB7XG4gICAgICAgIHNlZ1BsYWNlbWVudHMucHVzaCh7XG4gICAgICAgICAgICBzZWc6IHNlZ3Nbc2VnUmVjdC5pbmRleF0sXG4gICAgICAgICAgICByZWN0OiBzZWdSZWN0LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZm9yIChsZXQgZHVtYlNlZyBvZiBkdW1iU2Vncykge1xuICAgICAgICBzZWdQbGFjZW1lbnRzLnB1c2goeyBzZWc6IGR1bWJTZWcsIHJlY3Q6IG51bGwgfSk7XG4gICAgfVxuICAgIHJldHVybiB7IHNlZ1BsYWNlbWVudHMsIGhpZGRlbkdyb3VwcyB9O1xufVxuXG5jb25zdCBERUZBVUxUX1RJTUVfRk9STUFUID0gY3JlYXRlRm9ybWF0dGVyKHtcbiAgICBob3VyOiAnbnVtZXJpYycsXG4gICAgbWludXRlOiAnMi1kaWdpdCcsXG4gICAgbWVyaWRpZW06IGZhbHNlLFxufSk7XG5jbGFzcyBUaW1lQ29sRXZlbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChTdGFuZGFyZEV2ZW50LCBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb3BzLCB7IGVsQ2xhc3NlczogW1xuICAgICAgICAgICAgICAgICdmYy10aW1lZ3JpZC1ldmVudCcsXG4gICAgICAgICAgICAgICAgJ2ZjLXYtZXZlbnQnLFxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuaXNTaG9ydCAmJiAnZmMtdGltZWdyaWQtZXZlbnQtc2hvcnQnLFxuICAgICAgICAgICAgXSwgZGVmYXVsdFRpbWVGb3JtYXQ6IERFRkFVTFRfVElNRV9GT1JNQVQgfSkpKTtcbiAgICB9XG59XG5cbmNsYXNzIFRpbWVDb2wgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5zb3J0RXZlbnRTZWdzID0gbWVtb2l6ZShzb3J0RXZlbnRTZWdzKTtcbiAgICB9XG4gICAgLy8gVE9ETzogbWVtb2l6ZSBldmVudC1wbGFjZW1lbnQ/XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgb3B0aW9ucyB9ID0gY29udGV4dDtcbiAgICAgICAgbGV0IGlzU2VsZWN0TWlycm9yID0gb3B0aW9ucy5zZWxlY3RNaXJyb3I7XG4gICAgICAgIGxldCBtaXJyb3JTZWdzID0gLy8geXVja1xuICAgICAgICAgKHByb3BzLmV2ZW50RHJhZyAmJiBwcm9wcy5ldmVudERyYWcuc2VncykgfHxcbiAgICAgICAgICAgIChwcm9wcy5ldmVudFJlc2l6ZSAmJiBwcm9wcy5ldmVudFJlc2l6ZS5zZWdzKSB8fFxuICAgICAgICAgICAgKGlzU2VsZWN0TWlycm9yICYmIHByb3BzLmRhdGVTZWxlY3Rpb25TZWdzKSB8fFxuICAgICAgICAgICAgW107XG4gICAgICAgIGxldCBpbnRlcmFjdGlvbkFmZmVjdGVkSW5zdGFuY2VzID0gLy8gVE9ETzogbWVzc3kgd2F5IHRvIGNvbXB1dGUgdGhpc1xuICAgICAgICAgKHByb3BzLmV2ZW50RHJhZyAmJiBwcm9wcy5ldmVudERyYWcuYWZmZWN0ZWRJbnN0YW5jZXMpIHx8XG4gICAgICAgICAgICAocHJvcHMuZXZlbnRSZXNpemUgJiYgcHJvcHMuZXZlbnRSZXNpemUuYWZmZWN0ZWRJbnN0YW5jZXMpIHx8XG4gICAgICAgICAgICB7fTtcbiAgICAgICAgbGV0IHNvcnRlZEZnU2VncyA9IHRoaXMuc29ydEV2ZW50U2Vncyhwcm9wcy5mZ0V2ZW50U2Vncywgb3B0aW9ucy5ldmVudE9yZGVyKTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KERheUNlbGxDb250YWluZXIsIHsgZWxUYWc6IFwidGRcIiwgZWxSZWY6IHByb3BzLmVsUmVmLCBlbENsYXNzZXM6IFtcbiAgICAgICAgICAgICAgICAnZmMtdGltZWdyaWQtY29sJyxcbiAgICAgICAgICAgICAgICAuLi4ocHJvcHMuZXh0cmFDbGFzc05hbWVzIHx8IFtdKSxcbiAgICAgICAgICAgIF0sIGVsQXR0cnM6IE9iamVjdC5hc3NpZ24oeyByb2xlOiAnZ3JpZGNlbGwnIH0sIHByb3BzLmV4dHJhRGF0YUF0dHJzKSwgZGF0ZTogcHJvcHMuZGF0ZSwgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlLCBleHRyYVJlbmRlclByb3BzOiBwcm9wcy5leHRyYVJlbmRlclByb3BzIH0sIChJbm5lckNvbnRlbnQpID0+IChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWNvbC1mcmFtZVwiIH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWNvbC1iZ1wiIH0sXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJGaWxsU2Vncyhwcm9wcy5idXNpbmVzc0hvdXJTZWdzLCAnbm9uLWJ1c2luZXNzJyksXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJGaWxsU2Vncyhwcm9wcy5iZ0V2ZW50U2VncywgJ2JnLWV2ZW50JyksXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJGaWxsU2Vncyhwcm9wcy5kYXRlU2VsZWN0aW9uU2VncywgJ2hpZ2hsaWdodCcpKSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtY29sLWV2ZW50c1wiIH0sIHRoaXMucmVuZGVyRmdTZWdzKHNvcnRlZEZnU2VncywgaW50ZXJhY3Rpb25BZmZlY3RlZEluc3RhbmNlcywgZmFsc2UsIGZhbHNlLCBmYWxzZSkpLFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1jb2wtZXZlbnRzXCIgfSwgdGhpcy5yZW5kZXJGZ1NlZ3MobWlycm9yU2Vncywge30sIEJvb2xlYW4ocHJvcHMuZXZlbnREcmFnKSwgQm9vbGVhbihwcm9wcy5ldmVudFJlc2l6ZSksIEJvb2xlYW4oaXNTZWxlY3RNaXJyb3IpLCAnbWlycm9yJykpLFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1ub3ctaW5kaWNhdG9yLWNvbnRhaW5lclwiIH0sIHRoaXMucmVuZGVyTm93SW5kaWNhdG9yKHByb3BzLm5vd0luZGljYXRvclNlZ3MpKSxcbiAgICAgICAgICAgIGhhc0N1c3RvbURheUNlbGxDb250ZW50KG9wdGlvbnMpICYmIChjcmVhdGVFbGVtZW50KElubmVyQ29udGVudCwgeyBlbFRhZzogXCJkaXZcIiwgZWxDbGFzc2VzOiBbJ2ZjLXRpbWVncmlkLWNvbC1taXNjJ10gfSkpKSkpKTtcbiAgICB9XG4gICAgcmVuZGVyRmdTZWdzKHNvcnRlZEZnU2Vncywgc2VnSXNJbnZpc2libGUsIGlzRHJhZ2dpbmcsIGlzUmVzaXppbmcsIGlzRGF0ZVNlbGVjdGluZywgZm9yY2VkS2V5KSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBpZiAocHJvcHMuZm9yUHJpbnQpIHtcbiAgICAgICAgICAgIHJldHVybiByZW5kZXJQbGFpbkZnU2Vncyhzb3J0ZWRGZ1NlZ3MsIHByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJQb3NpdGlvbmVkRmdTZWdzKHNvcnRlZEZnU2Vncywgc2VnSXNJbnZpc2libGUsIGlzRHJhZ2dpbmcsIGlzUmVzaXppbmcsIGlzRGF0ZVNlbGVjdGluZywgZm9yY2VkS2V5KTtcbiAgICB9XG4gICAgcmVuZGVyUG9zaXRpb25lZEZnU2VncyhzZWdzLCAvLyBpZiBub3QgbWlycm9yLCBuZWVkcyB0byBiZSBzb3J0ZWRcbiAgICBzZWdJc0ludmlzaWJsZSwgaXNEcmFnZ2luZywgaXNSZXNpemluZywgaXNEYXRlU2VsZWN0aW5nLCBmb3JjZWRLZXkpIHtcbiAgICAgICAgbGV0IHsgZXZlbnRNYXhTdGFjaywgZXZlbnRTaG9ydEhlaWdodCwgZXZlbnRPcmRlclN0cmljdCwgZXZlbnRNaW5IZWlnaHQgfSA9IHRoaXMuY29udGV4dC5vcHRpb25zO1xuICAgICAgICBsZXQgeyBkYXRlLCBzbGF0Q29vcmRzLCBldmVudFNlbGVjdGlvbiwgdG9kYXlSYW5nZSwgbm93RGF0ZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IGlzTWlycm9yID0gaXNEcmFnZ2luZyB8fCBpc1Jlc2l6aW5nIHx8IGlzRGF0ZVNlbGVjdGluZztcbiAgICAgICAgbGV0IHNlZ1ZDb29yZHMgPSBjb21wdXRlU2VnVkNvb3JkcyhzZWdzLCBkYXRlLCBzbGF0Q29vcmRzLCBldmVudE1pbkhlaWdodCk7XG4gICAgICAgIGxldCB7IHNlZ1BsYWNlbWVudHMsIGhpZGRlbkdyb3VwcyB9ID0gY29tcHV0ZUZnU2VnUGxhY2VtZW50cyhzZWdzLCBzZWdWQ29vcmRzLCBldmVudE9yZGVyU3RyaWN0LCBldmVudE1heFN0YWNrKTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJIaWRkZW5Hcm91cHMoaGlkZGVuR3JvdXBzLCBzZWdzKSxcbiAgICAgICAgICAgIHNlZ1BsYWNlbWVudHMubWFwKChzZWdQbGFjZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgeyBzZWcsIHJlY3QgfSA9IHNlZ1BsYWNlbWVudDtcbiAgICAgICAgICAgICAgICBsZXQgaW5zdGFuY2VJZCA9IHNlZy5ldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWQ7XG4gICAgICAgICAgICAgICAgbGV0IGlzVmlzaWJsZSA9IGlzTWlycm9yIHx8IEJvb2xlYW4oIXNlZ0lzSW52aXNpYmxlW2luc3RhbmNlSWRdICYmIHJlY3QpO1xuICAgICAgICAgICAgICAgIGxldCB2U3R5bGUgPSBjb21wdXRlU2VnVlN0eWxlKHJlY3QgJiYgcmVjdC5zcGFuKTtcbiAgICAgICAgICAgICAgICBsZXQgaFN0eWxlID0gKCFpc01pcnJvciAmJiByZWN0KSA/IHRoaXMuY29tcHV0ZVNlZ0hTdHlsZShyZWN0KSA6IHsgbGVmdDogMCwgcmlnaHQ6IDAgfTtcbiAgICAgICAgICAgICAgICBsZXQgaXNJbnNldCA9IEJvb2xlYW4ocmVjdCkgJiYgcmVjdC5zdGFja0ZvcndhcmQgPiAwO1xuICAgICAgICAgICAgICAgIGxldCBpc1Nob3J0ID0gQm9vbGVhbihyZWN0KSAmJiAocmVjdC5zcGFuLmVuZCAtIHJlY3Quc3Bhbi5zdGFydCkgPCBldmVudFNob3J0SGVpZ2h0OyAvLyBsb29rIGF0IG90aGVyIHBsYWNlcyBmb3IgdGhpcyBwcm9ibGVtXG4gICAgICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiAnZmMtdGltZWdyaWQtZXZlbnQtaGFybmVzcycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKGlzSW5zZXQgPyAnIGZjLXRpbWVncmlkLWV2ZW50LWhhcm5lc3MtaW5zZXQnIDogJycpLCBrZXk6IGZvcmNlZEtleSB8fCBpbnN0YW5jZUlkLCBzdHlsZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgdmlzaWJpbGl0eTogaXNWaXNpYmxlID8gJycgOiAnaGlkZGVuJyB9LCB2U3R5bGUpLCBoU3R5bGUpIH0sXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoVGltZUNvbEV2ZW50LCBPYmplY3QuYXNzaWduKHsgc2VnOiBzZWcsIGlzRHJhZ2dpbmc6IGlzRHJhZ2dpbmcsIGlzUmVzaXppbmc6IGlzUmVzaXppbmcsIGlzRGF0ZVNlbGVjdGluZzogaXNEYXRlU2VsZWN0aW5nLCBpc1NlbGVjdGVkOiBpbnN0YW5jZUlkID09PSBldmVudFNlbGVjdGlvbiwgaXNTaG9ydDogaXNTaG9ydCB9LCBnZXRTZWdNZXRhKHNlZywgdG9kYXlSYW5nZSwgbm93RGF0ZSkpKSkpO1xuICAgICAgICAgICAgfSkpKTtcbiAgICB9XG4gICAgLy8gd2lsbCBhbHJlYWR5IGhhdmUgZXZlbnRNaW5IZWlnaHQgYXBwbGllZCBiZWNhdXNlIHNlZ0lucHV0cyBhbHJlYWR5IGhhZCBpdFxuICAgIHJlbmRlckhpZGRlbkdyb3VwcyhoaWRkZW5Hcm91cHMsIHNlZ3MpIHtcbiAgICAgICAgbGV0IHsgZXh0cmFEYXRlU3BhbiwgZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2UsIG5vd0RhdGUsIGV2ZW50U2VsZWN0aW9uLCBldmVudERyYWcsIGV2ZW50UmVzaXplIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIGhpZGRlbkdyb3Vwcy5tYXAoKGhpZGRlbkdyb3VwKSA9PiB7XG4gICAgICAgICAgICBsZXQgcG9zaXRpb25Dc3MgPSBjb21wdXRlU2VnVlN0eWxlKGhpZGRlbkdyb3VwLnNwYW4pO1xuICAgICAgICAgICAgbGV0IGhpZGRlblNlZ3MgPSBjb21waWxlU2Vnc0Zyb21FbnRyaWVzKGhpZGRlbkdyb3VwLmVudHJpZXMsIHNlZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFRpbWVDb2xNb3JlTGluaywgeyBrZXk6IGJ1aWxkSXNvU3RyaW5nKGNvbXB1dGVFYXJsaWVzdFNlZ1N0YXJ0KGhpZGRlblNlZ3MpKSwgaGlkZGVuU2VnczogaGlkZGVuU2VncywgdG9wOiBwb3NpdGlvbkNzcy50b3AsIGJvdHRvbTogcG9zaXRpb25Dc3MuYm90dG9tLCBleHRyYURhdGVTcGFuOiBleHRyYURhdGVTcGFuLCBkYXRlUHJvZmlsZTogZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2U6IHRvZGF5UmFuZ2UsIG5vd0RhdGU6IG5vd0RhdGUsIGV2ZW50U2VsZWN0aW9uOiBldmVudFNlbGVjdGlvbiwgZXZlbnREcmFnOiBldmVudERyYWcsIGV2ZW50UmVzaXplOiBldmVudFJlc2l6ZSB9KSk7XG4gICAgICAgIH0pKSk7XG4gICAgfVxuICAgIHJlbmRlckZpbGxTZWdzKHNlZ3MsIGZpbGxUeXBlKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBsZXQgc2VnVkNvb3JkcyA9IGNvbXB1dGVTZWdWQ29vcmRzKHNlZ3MsIHByb3BzLmRhdGUsIHByb3BzLnNsYXRDb29yZHMsIGNvbnRleHQub3B0aW9ucy5ldmVudE1pbkhlaWdodCk7IC8vIGRvbid0IGFzc3VtZSBhbGwgcG9wdWxhdGVkXG4gICAgICAgIGxldCBjaGlsZHJlbiA9IHNlZ1ZDb29yZHMubWFwKCh2Y29vcmRzLCBpKSA9PiB7XG4gICAgICAgICAgICBsZXQgc2VnID0gc2Vnc1tpXTtcbiAgICAgICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGtleTogYnVpbGRFdmVudFJhbmdlS2V5KHNlZy5ldmVudFJhbmdlKSwgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWJnLWhhcm5lc3NcIiwgc3R5bGU6IGNvbXB1dGVTZWdWU3R5bGUodmNvb3JkcykgfSwgZmlsbFR5cGUgPT09ICdiZy1ldmVudCcgP1xuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoQmdFdmVudCwgT2JqZWN0LmFzc2lnbih7IHNlZzogc2VnIH0sIGdldFNlZ01ldGEoc2VnLCBwcm9wcy50b2RheVJhbmdlLCBwcm9wcy5ub3dEYXRlKSkpIDpcbiAgICAgICAgICAgICAgICByZW5kZXJGaWxsKGZpbGxUeXBlKSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuKTtcbiAgICB9XG4gICAgcmVuZGVyTm93SW5kaWNhdG9yKHNlZ3MpIHtcbiAgICAgICAgbGV0IHsgc2xhdENvb3JkcywgZGF0ZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgaWYgKCFzbGF0Q29vcmRzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2Vncy5tYXAoKHNlZywgaSkgPT4gKGNyZWF0ZUVsZW1lbnQoTm93SW5kaWNhdG9yQ29udGFpbmVyXG4gICAgICAgIC8vIGtleSBkb2Vzbid0IG1hdHRlci4gd2lsbCBvbmx5IGV2ZXIgYmUgb25lXG4gICAgICAgICwgeyBcbiAgICAgICAgICAgIC8vIGtleSBkb2Vzbid0IG1hdHRlci4gd2lsbCBvbmx5IGV2ZXIgYmUgb25lXG4gICAgICAgICAgICBrZXk6IGksIGVsQ2xhc3NlczogWydmYy10aW1lZ3JpZC1ub3ctaW5kaWNhdG9yLWxpbmUnXSwgZWxTdHlsZToge1xuICAgICAgICAgICAgICAgIHRvcDogc2xhdENvb3Jkcy5jb21wdXRlRGF0ZVRvcChzZWcuc3RhcnQsIGRhdGUpLFxuICAgICAgICAgICAgfSwgaXNBeGlzOiBmYWxzZSwgZGF0ZTogZGF0ZSB9KSkpO1xuICAgIH1cbiAgICBjb21wdXRlU2VnSFN0eWxlKHNlZ0hDb29yZHMpIHtcbiAgICAgICAgbGV0IHsgaXNSdGwsIG9wdGlvbnMgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHNob3VsZE92ZXJsYXAgPSBvcHRpb25zLnNsb3RFdmVudE92ZXJsYXA7XG4gICAgICAgIGxldCBuZWFyQ29vcmQgPSBzZWdIQ29vcmRzLmxldmVsQ29vcmQ7IC8vIHRoZSBsZWZ0IHNpZGUgaWYgTFRSLiB0aGUgcmlnaHQgc2lkZSBpZiBSVEwuIGZsb2F0aW5nLXBvaW50XG4gICAgICAgIGxldCBmYXJDb29yZCA9IHNlZ0hDb29yZHMubGV2ZWxDb29yZCArIHNlZ0hDb29yZHMudGhpY2tuZXNzOyAvLyB0aGUgcmlnaHQgc2lkZSBpZiBMVFIuIHRoZSBsZWZ0IHNpZGUgaWYgUlRMLiBmbG9hdGluZy1wb2ludFxuICAgICAgICBsZXQgbGVmdDsgLy8gYW1vdW50IG9mIHNwYWNlIGZyb20gbGVmdCBlZGdlLCBhIGZyYWN0aW9uIG9mIHRoZSB0b3RhbCB3aWR0aFxuICAgICAgICBsZXQgcmlnaHQ7IC8vIGFtb3VudCBvZiBzcGFjZSBmcm9tIHJpZ2h0IGVkZ2UsIGEgZnJhY3Rpb24gb2YgdGhlIHRvdGFsIHdpZHRoXG4gICAgICAgIGlmIChzaG91bGRPdmVybGFwKSB7XG4gICAgICAgICAgICAvLyBkb3VibGUgdGhlIHdpZHRoLCBidXQgZG9uJ3QgZ28gYmV5b25kIHRoZSBtYXhpbXVtIGZvcndhcmQgY29vcmRpbmF0ZSAoMS4wKVxuICAgICAgICAgICAgZmFyQ29vcmQgPSBNYXRoLm1pbigxLCBuZWFyQ29vcmQgKyAoZmFyQ29vcmQgLSBuZWFyQ29vcmQpICogMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUnRsKSB7XG4gICAgICAgICAgICBsZWZ0ID0gMSAtIGZhckNvb3JkO1xuICAgICAgICAgICAgcmlnaHQgPSBuZWFyQ29vcmQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZWZ0ID0gbmVhckNvb3JkO1xuICAgICAgICAgICAgcmlnaHQgPSAxIC0gZmFyQ29vcmQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByb3BzID0ge1xuICAgICAgICAgICAgekluZGV4OiBzZWdIQ29vcmRzLnN0YWNrRGVwdGggKyAxLFxuICAgICAgICAgICAgbGVmdDogbGVmdCAqIDEwMCArICclJyxcbiAgICAgICAgICAgIHJpZ2h0OiByaWdodCAqIDEwMCArICclJyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHNob3VsZE92ZXJsYXAgJiYgIXNlZ0hDb29yZHMuc3RhY2tGb3J3YXJkKSB7XG4gICAgICAgICAgICAvLyBhZGQgcGFkZGluZyB0byB0aGUgZWRnZSBzbyB0aGF0IGZvcndhcmQgc3RhY2tlZCBldmVudHMgZG9uJ3QgY292ZXIgdGhlIHJlc2l6ZXIncyBpY29uXG4gICAgICAgICAgICBwcm9wc1tpc1J0bCA/ICdtYXJnaW5MZWZ0JyA6ICdtYXJnaW5SaWdodCddID0gMTAgKiAyOyAvLyAxMCBpcyBhIGd1ZXNzdGltYXRlIG9mIHRoZSBpY29uJ3Mgd2lkdGhcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvcHM7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVuZGVyUGxhaW5GZ1NlZ3Moc29ydGVkRmdTZWdzLCB7IHRvZGF5UmFuZ2UsIG5vd0RhdGUsIGV2ZW50U2VsZWN0aW9uLCBldmVudERyYWcsIGV2ZW50UmVzaXplIH0pIHtcbiAgICBsZXQgaGlkZGVuSW5zdGFuY2VzID0gKGV2ZW50RHJhZyA/IGV2ZW50RHJhZy5hZmZlY3RlZEluc3RhbmNlcyA6IG51bGwpIHx8XG4gICAgICAgIChldmVudFJlc2l6ZSA/IGV2ZW50UmVzaXplLmFmZmVjdGVkSW5zdGFuY2VzIDogbnVsbCkgfHxcbiAgICAgICAge307XG4gICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBzb3J0ZWRGZ1NlZ3MubWFwKChzZWcpID0+IHtcbiAgICAgICAgbGV0IGluc3RhbmNlSWQgPSBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBrZXk6IGluc3RhbmNlSWQsIHN0eWxlOiB7IHZpc2liaWxpdHk6IGhpZGRlbkluc3RhbmNlc1tpbnN0YW5jZUlkXSA/ICdoaWRkZW4nIDogJycgfSB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChUaW1lQ29sRXZlbnQsIE9iamVjdC5hc3NpZ24oeyBzZWc6IHNlZywgaXNEcmFnZ2luZzogZmFsc2UsIGlzUmVzaXppbmc6IGZhbHNlLCBpc0RhdGVTZWxlY3Rpbmc6IGZhbHNlLCBpc1NlbGVjdGVkOiBpbnN0YW5jZUlkID09PSBldmVudFNlbGVjdGlvbiwgaXNTaG9ydDogZmFsc2UgfSwgZ2V0U2VnTWV0YShzZWcsIHRvZGF5UmFuZ2UsIG5vd0RhdGUpKSkpKTtcbiAgICB9KSkpO1xufVxuZnVuY3Rpb24gY29tcHV0ZVNlZ1ZTdHlsZShzZWdWQ29vcmRzKSB7XG4gICAgaWYgKCFzZWdWQ29vcmRzKSB7XG4gICAgICAgIHJldHVybiB7IHRvcDogJycsIGJvdHRvbTogJycgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiBzZWdWQ29vcmRzLnN0YXJ0LFxuICAgICAgICBib3R0b206IC1zZWdWQ29vcmRzLmVuZCxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcGlsZVNlZ3NGcm9tRW50cmllcyhzZWdFbnRyaWVzLCBhbGxTZWdzKSB7XG4gICAgcmV0dXJuIHNlZ0VudHJpZXMubWFwKChzZWdFbnRyeSkgPT4gYWxsU2Vnc1tzZWdFbnRyeS5pbmRleF0pO1xufVxuXG5jbGFzcyBUaW1lQ29sc0NvbnRlbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5zcGxpdEZnRXZlbnRTZWdzID0gbWVtb2l6ZShzcGxpdFNlZ3NCeUNvbCk7XG4gICAgICAgIHRoaXMuc3BsaXRCZ0V2ZW50U2VncyA9IG1lbW9pemUoc3BsaXRTZWdzQnlDb2wpO1xuICAgICAgICB0aGlzLnNwbGl0QnVzaW5lc3NIb3VyU2VncyA9IG1lbW9pemUoc3BsaXRTZWdzQnlDb2wpO1xuICAgICAgICB0aGlzLnNwbGl0Tm93SW5kaWNhdG9yU2VncyA9IG1lbW9pemUoc3BsaXRTZWdzQnlDb2wpO1xuICAgICAgICB0aGlzLnNwbGl0RGF0ZVNlbGVjdGlvblNlZ3MgPSBtZW1vaXplKHNwbGl0U2Vnc0J5Q29sKTtcbiAgICAgICAgdGhpcy5zcGxpdEV2ZW50RHJhZyA9IG1lbW9pemUoc3BsaXRJbnRlcmFjdGlvbkJ5Q29sKTtcbiAgICAgICAgdGhpcy5zcGxpdEV2ZW50UmVzaXplID0gbWVtb2l6ZShzcGxpdEludGVyYWN0aW9uQnlDb2wpO1xuICAgICAgICB0aGlzLnJvb3RFbFJlZiA9IGNyZWF0ZVJlZigpO1xuICAgICAgICB0aGlzLmNlbGxFbFJlZnMgPSBuZXcgUmVmTWFwKCk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCBub3dJbmRpY2F0b3JUb3AgPSBjb250ZXh0Lm9wdGlvbnMubm93SW5kaWNhdG9yICYmXG4gICAgICAgICAgICBwcm9wcy5zbGF0Q29vcmRzICYmXG4gICAgICAgICAgICBwcm9wcy5zbGF0Q29vcmRzLnNhZmVDb21wdXRlVG9wKHByb3BzLm5vd0RhdGUpOyAvLyBtaWdodCByZXR1cm4gdm9pZFxuICAgICAgICBsZXQgY29sQ250ID0gcHJvcHMuY2VsbHMubGVuZ3RoO1xuICAgICAgICBsZXQgZmdFdmVudFNlZ3NCeVJvdyA9IHRoaXMuc3BsaXRGZ0V2ZW50U2Vncyhwcm9wcy5mZ0V2ZW50U2VncywgY29sQ250KTtcbiAgICAgICAgbGV0IGJnRXZlbnRTZWdzQnlSb3cgPSB0aGlzLnNwbGl0QmdFdmVudFNlZ3MocHJvcHMuYmdFdmVudFNlZ3MsIGNvbENudCk7XG4gICAgICAgIGxldCBidXNpbmVzc0hvdXJTZWdzQnlSb3cgPSB0aGlzLnNwbGl0QnVzaW5lc3NIb3VyU2Vncyhwcm9wcy5idXNpbmVzc0hvdXJTZWdzLCBjb2xDbnQpO1xuICAgICAgICBsZXQgbm93SW5kaWNhdG9yU2Vnc0J5Um93ID0gdGhpcy5zcGxpdE5vd0luZGljYXRvclNlZ3MocHJvcHMubm93SW5kaWNhdG9yU2VncywgY29sQ250KTtcbiAgICAgICAgbGV0IGRhdGVTZWxlY3Rpb25TZWdzQnlSb3cgPSB0aGlzLnNwbGl0RGF0ZVNlbGVjdGlvblNlZ3MocHJvcHMuZGF0ZVNlbGVjdGlvblNlZ3MsIGNvbENudCk7XG4gICAgICAgIGxldCBldmVudERyYWdCeVJvdyA9IHRoaXMuc3BsaXRFdmVudERyYWcocHJvcHMuZXZlbnREcmFnLCBjb2xDbnQpO1xuICAgICAgICBsZXQgZXZlbnRSZXNpemVCeVJvdyA9IHRoaXMuc3BsaXRFdmVudFJlc2l6ZShwcm9wcy5ldmVudFJlc2l6ZSwgY29sQ250KTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWNvbHNcIiwgcmVmOiB0aGlzLnJvb3RFbFJlZiB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRhYmxlXCIsIHsgcm9sZTogXCJwcmVzZW50YXRpb25cIiwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgbWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICAgICAgcHJvcHMudGFibGVDb2xHcm91cE5vZGUsXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRib2R5XCIsIHsgcm9sZTogXCJwcmVzZW50YXRpb25cIiB9LFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwidHJcIiwgeyByb2xlOiBcInJvd1wiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5heGlzICYmIChjcmVhdGVFbGVtZW50KFwidGRcIiwgeyBcImFyaWEtaGlkZGVuXCI6IHRydWUsIGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1jb2wgZmMtdGltZWdyaWQtYXhpc1wiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1jb2wtZnJhbWVcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItY29udGFpbmVyXCIgfSwgdHlwZW9mIG5vd0luZGljYXRvclRvcCA9PT0gJ251bWJlcicgJiYgKGNyZWF0ZUVsZW1lbnQoTm93SW5kaWNhdG9yQ29udGFpbmVyLCB7IGVsQ2xhc3NlczogWydmYy10aW1lZ3JpZC1ub3ctaW5kaWNhdG9yLWFycm93J10sIGVsU3R5bGU6IHsgdG9wOiBub3dJbmRpY2F0b3JUb3AgfSwgaXNBeGlzOiB0cnVlLCBkYXRlOiBwcm9wcy5ub3dEYXRlIH0pKSkpKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5jZWxscy5tYXAoKGNlbGwsIGkpID0+IChjcmVhdGVFbGVtZW50KFRpbWVDb2wsIHsga2V5OiBjZWxsLmtleSwgZWxSZWY6IHRoaXMuY2VsbEVsUmVmcy5jcmVhdGVSZWYoY2VsbC5rZXkpLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIGRhdGU6IGNlbGwuZGF0ZSwgbm93RGF0ZTogcHJvcHMubm93RGF0ZSwgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSwgZXh0cmFSZW5kZXJQcm9wczogY2VsbC5leHRyYVJlbmRlclByb3BzLCBleHRyYURhdGFBdHRyczogY2VsbC5leHRyYURhdGFBdHRycywgZXh0cmFDbGFzc05hbWVzOiBjZWxsLmV4dHJhQ2xhc3NOYW1lcywgZXh0cmFEYXRlU3BhbjogY2VsbC5leHRyYURhdGVTcGFuLCBmZ0V2ZW50U2VnczogZmdFdmVudFNlZ3NCeVJvd1tpXSwgYmdFdmVudFNlZ3M6IGJnRXZlbnRTZWdzQnlSb3dbaV0sIGJ1c2luZXNzSG91clNlZ3M6IGJ1c2luZXNzSG91clNlZ3NCeVJvd1tpXSwgbm93SW5kaWNhdG9yU2Vnczogbm93SW5kaWNhdG9yU2Vnc0J5Um93W2ldLCBkYXRlU2VsZWN0aW9uU2VnczogZGF0ZVNlbGVjdGlvblNlZ3NCeVJvd1tpXSwgZXZlbnREcmFnOiBldmVudERyYWdCeVJvd1tpXSwgZXZlbnRSZXNpemU6IGV2ZW50UmVzaXplQnlSb3dbaV0sIHNsYXRDb29yZHM6IHByb3BzLnNsYXRDb29yZHMsIGV2ZW50U2VsZWN0aW9uOiBwcm9wcy5ldmVudFNlbGVjdGlvbiwgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50IH0pKSkpKSkpKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQ29vcmRzKCk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVDb29yZHMoKTtcbiAgICB9XG4gICAgdXBkYXRlQ29vcmRzKCkge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgaWYgKHByb3BzLm9uQ29sQ29vcmRzICYmXG4gICAgICAgICAgICBwcm9wcy5jbGllbnRXaWR0aCAhPT0gbnVsbCAvLyBtZWFucyBzaXppbmcgaGFzIHN0YWJpbGl6ZWRcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBwcm9wcy5vbkNvbENvb3JkcyhuZXcgUG9zaXRpb25DYWNoZSh0aGlzLnJvb3RFbFJlZi5jdXJyZW50LCBjb2xsZWN0Q2VsbEVscyh0aGlzLmNlbGxFbFJlZnMuY3VycmVudE1hcCwgcHJvcHMuY2VsbHMpLCB0cnVlLCAvLyBob3Jpem9udGFsXG4gICAgICAgICAgICBmYWxzZSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY29sbGVjdENlbGxFbHMoZWxNYXAsIGNlbGxzKSB7XG4gICAgcmV0dXJuIGNlbGxzLm1hcCgoY2VsbCkgPT4gZWxNYXBbY2VsbC5rZXldKTtcbn1cblxuLyogQSBjb21wb25lbnQgdGhhdCByZW5kZXJzIG9uZSBvciBtb3JlIGNvbHVtbnMgb2YgdmVydGljYWwgdGltZSBzbG90c1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5jbGFzcyBUaW1lQ29scyBleHRlbmRzIERhdGVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnByb2Nlc3NTbG90T3B0aW9ucyA9IG1lbW9pemUocHJvY2Vzc1Nsb3RPcHRpb25zKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHNsYXRDb29yZHM6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUm9vdEVsID0gKGVsKSA9PiB7XG4gICAgICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCh0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgICAgICBpc0hpdENvbWJvQWxsb3dlZDogdGhpcy5wcm9wcy5pc0hpdENvbWJvQWxsb3dlZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC51bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlU2Nyb2xsUmVxdWVzdCA9IChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBvblNjcm9sbFRvcFJlcXVlc3QgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBsZXQgeyBzbGF0Q29vcmRzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgaWYgKG9uU2Nyb2xsVG9wUmVxdWVzdCAmJiBzbGF0Q29vcmRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QudGltZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdG9wID0gc2xhdENvb3Jkcy5jb21wdXRlVGltZVRvcChyZXF1ZXN0LnRpbWUpO1xuICAgICAgICAgICAgICAgICAgICB0b3AgPSBNYXRoLmNlaWwodG9wKTsgLy8gem9vbSBjYW4gZ2l2ZSB3ZWlyZCBmbG9hdGluZy1wb2ludCB2YWx1ZXMuIHJhdGhlciBzY3JvbGwgYSBsaXR0bGUgYml0IGZ1cnRoZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wICs9IDE7IC8vIHRvIG92ZXJjb21lIHRvcCBib3JkZXIgdGhhdCBzbG90cyBiZXlvbmQgdGhlIGZpcnN0IGhhdmUuIGxvb2tzIGJldHRlclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9uU2Nyb2xsVG9wUmVxdWVzdCh0b3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVDb2xDb29yZHMgPSAoY29sQ29vcmRzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvbENvb3JkcyA9IGNvbENvb3JkcztcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVTbGF0Q29vcmRzID0gKHNsYXRDb29yZHMpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBzbGF0Q29vcmRzIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25TbGF0Q29vcmRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vblNsYXRDb29yZHMoc2xhdENvb3Jkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIHN0YXRlIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtYm9keVwiLCByZWY6IHRoaXMuaGFuZGxlUm9vdEVsLCBzdHlsZToge1xuICAgICAgICAgICAgICAgIC8vIHRoZXNlIHByb3BzIGFyZSBpbXBvcnRhbnQgdG8gZ2l2ZSB0aGlzIHdyYXBwZXIgY29ycmVjdCBkaW1lbnNpb25zIGZvciBpbnRlcmFjdGlvbnNcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBpZiB3ZSBzZXQgaXQgaGVyZSwgY2FuIHdlIGF2b2lkIGdpdmluZyB0byBpbm5lciB0YWJsZXM/XG4gICAgICAgICAgICAgICAgd2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICAgIG1pbldpZHRoOiBwcm9wcy50YWJsZU1pbldpZHRoLFxuICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChUaW1lQ29sc1NsYXRzLCB7IGF4aXM6IHByb3BzLmF4aXMsIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgc2xhdE1ldGFzOiBwcm9wcy5zbGF0TWV0YXMsIGNsaWVudFdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCwgbWluSGVpZ2h0OiBwcm9wcy5leHBhbmRSb3dzID8gcHJvcHMuY2xpZW50SGVpZ2h0IDogJycsIHRhYmxlTWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsIHRhYmxlQ29sR3JvdXBOb2RlOiBwcm9wcy5heGlzID8gcHJvcHMudGFibGVDb2xHcm91cE5vZGUgOiBudWxsIC8qIGF4aXMgZGVwZW5kcyBvbiB0aGUgY29sZ3JvdXAncyBzaHJpbmtpbmcgKi8sIG9uQ29vcmRzOiB0aGlzLmhhbmRsZVNsYXRDb29yZHMgfSksXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFRpbWVDb2xzQ29udGVudCwgeyBjZWxsczogcHJvcHMuY2VsbHMsIGF4aXM6IHByb3BzLmF4aXMsIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgYnVzaW5lc3NIb3VyU2VnczogcHJvcHMuYnVzaW5lc3NIb3VyU2VncywgYmdFdmVudFNlZ3M6IHByb3BzLmJnRXZlbnRTZWdzLCBmZ0V2ZW50U2VnczogcHJvcHMuZmdFdmVudFNlZ3MsIGRhdGVTZWxlY3Rpb25TZWdzOiBwcm9wcy5kYXRlU2VsZWN0aW9uU2VncywgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBldmVudERyYWc6IHByb3BzLmV2ZW50RHJhZywgZXZlbnRSZXNpemU6IHByb3BzLmV2ZW50UmVzaXplLCB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlLCBub3dEYXRlOiBwcm9wcy5ub3dEYXRlLCBub3dJbmRpY2F0b3JTZWdzOiBwcm9wcy5ub3dJbmRpY2F0b3JTZWdzLCBjbGllbnRXaWR0aDogcHJvcHMuY2xpZW50V2lkdGgsIHRhYmxlTWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsIHRhYmxlQ29sR3JvdXBOb2RlOiBwcm9wcy50YWJsZUNvbEdyb3VwTm9kZSwgc2xhdENvb3Jkczogc3RhdGUuc2xhdENvb3Jkcywgb25Db2xDb29yZHM6IHRoaXMuaGFuZGxlQ29sQ29vcmRzLCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQgfSkpKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsUmVzcG9uZGVyID0gdGhpcy5jb250ZXh0LmNyZWF0ZVNjcm9sbFJlc3BvbmRlcih0aGlzLmhhbmRsZVNjcm9sbFJlcXVlc3QpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsUmVzcG9uZGVyLnVwZGF0ZShwcmV2UHJvcHMuZGF0ZVByb2ZpbGUgIT09IHRoaXMucHJvcHMuZGF0ZVByb2ZpbGUpO1xuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxSZXNwb25kZXIuZGV0YWNoKCk7XG4gICAgfVxuICAgIHF1ZXJ5SGl0KHBvc2l0aW9uTGVmdCwgcG9zaXRpb25Ub3ApIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiwgb3B0aW9ucyB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgeyBjb2xDb29yZHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IGRhdGVQcm9maWxlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBsZXQgeyBzbGF0Q29vcmRzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBsZXQgeyBzbmFwRHVyYXRpb24sIHNuYXBzUGVyU2xvdCB9ID0gdGhpcy5wcm9jZXNzU2xvdE9wdGlvbnModGhpcy5wcm9wcy5zbG90RHVyYXRpb24sIG9wdGlvbnMuc25hcER1cmF0aW9uKTtcbiAgICAgICAgbGV0IGNvbEluZGV4ID0gY29sQ29vcmRzLmxlZnRUb0luZGV4KHBvc2l0aW9uTGVmdCk7XG4gICAgICAgIGxldCBzbGF0SW5kZXggPSBzbGF0Q29vcmRzLnBvc2l0aW9ucy50b3BUb0luZGV4KHBvc2l0aW9uVG9wKTtcbiAgICAgICAgaWYgKGNvbEluZGV4ICE9IG51bGwgJiYgc2xhdEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBjZWxsID0gdGhpcy5wcm9wcy5jZWxsc1tjb2xJbmRleF07XG4gICAgICAgICAgICBsZXQgc2xhdFRvcCA9IHNsYXRDb29yZHMucG9zaXRpb25zLnRvcHNbc2xhdEluZGV4XTtcbiAgICAgICAgICAgIGxldCBzbGF0SGVpZ2h0ID0gc2xhdENvb3Jkcy5wb3NpdGlvbnMuZ2V0SGVpZ2h0KHNsYXRJbmRleCk7XG4gICAgICAgICAgICBsZXQgcGFydGlhbCA9IChwb3NpdGlvblRvcCAtIHNsYXRUb3ApIC8gc2xhdEhlaWdodDsgLy8gZmxvYXRpbmcgcG9pbnQgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAgICAgICAgbGV0IGxvY2FsU25hcEluZGV4ID0gTWF0aC5mbG9vcihwYXJ0aWFsICogc25hcHNQZXJTbG90KTsgLy8gdGhlIHNuYXAgIyByZWxhdGl2ZSB0byBzdGFydCBvZiBzbGF0XG4gICAgICAgICAgICBsZXQgc25hcEluZGV4ID0gc2xhdEluZGV4ICogc25hcHNQZXJTbG90ICsgbG9jYWxTbmFwSW5kZXg7XG4gICAgICAgICAgICBsZXQgZGF5RGF0ZSA9IHRoaXMucHJvcHMuY2VsbHNbY29sSW5kZXhdLmRhdGU7XG4gICAgICAgICAgICBsZXQgdGltZSA9IGFkZER1cmF0aW9ucyhkYXRlUHJvZmlsZS5zbG90TWluVGltZSwgbXVsdGlwbHlEdXJhdGlvbihzbmFwRHVyYXRpb24sIHNuYXBJbmRleCkpO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gZGF0ZUVudi5hZGQoZGF5RGF0ZSwgdGltZSk7XG4gICAgICAgICAgICBsZXQgZW5kID0gZGF0ZUVudi5hZGQoc3RhcnQsIHNuYXBEdXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGVQcm9maWxlLFxuICAgICAgICAgICAgICAgIGRhdGVTcGFuOiBPYmplY3QuYXNzaWduKHsgcmFuZ2U6IHsgc3RhcnQsIGVuZCB9LCBhbGxEYXk6IGZhbHNlIH0sIGNlbGwuZXh0cmFEYXRlU3BhbiksXG4gICAgICAgICAgICAgICAgZGF5RWw6IGNvbENvb3Jkcy5lbHNbY29sSW5kZXhdLFxuICAgICAgICAgICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogY29sQ29vcmRzLmxlZnRzW2NvbEluZGV4XSxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGNvbENvb3Jkcy5yaWdodHNbY29sSW5kZXhdLFxuICAgICAgICAgICAgICAgICAgICB0b3A6IHNsYXRUb3AsXG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbTogc2xhdFRvcCArIHNsYXRIZWlnaHQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBsYXllcjogMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gcHJvY2Vzc1Nsb3RPcHRpb25zKHNsb3REdXJhdGlvbiwgc25hcER1cmF0aW9uT3ZlcnJpZGUpIHtcbiAgICBsZXQgc25hcER1cmF0aW9uID0gc25hcER1cmF0aW9uT3ZlcnJpZGUgfHwgc2xvdER1cmF0aW9uO1xuICAgIGxldCBzbmFwc1BlclNsb3QgPSB3aG9sZURpdmlkZUR1cmF0aW9ucyhzbG90RHVyYXRpb24sIHNuYXBEdXJhdGlvbik7XG4gICAgaWYgKHNuYXBzUGVyU2xvdCA9PT0gbnVsbCkge1xuICAgICAgICBzbmFwRHVyYXRpb24gPSBzbG90RHVyYXRpb247XG4gICAgICAgIHNuYXBzUGVyU2xvdCA9IDE7XG4gICAgICAgIC8vIFRPRE86IHNheSB3YXJuaW5nP1xuICAgIH1cbiAgICByZXR1cm4geyBzbmFwRHVyYXRpb24sIHNuYXBzUGVyU2xvdCB9O1xufVxuXG5jbGFzcyBEYXlUaW1lQ29sc1NsaWNlciBleHRlbmRzIFNsaWNlciB7XG4gICAgc2xpY2VSYW5nZShyYW5nZSwgZGF5UmFuZ2VzKSB7XG4gICAgICAgIGxldCBzZWdzID0gW107XG4gICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGRheVJhbmdlcy5sZW5ndGg7IGNvbCArPSAxKSB7XG4gICAgICAgICAgICBsZXQgc2VnUmFuZ2UgPSBpbnRlcnNlY3RSYW5nZXMocmFuZ2UsIGRheVJhbmdlc1tjb2xdKTtcbiAgICAgICAgICAgIGlmIChzZWdSYW5nZSkge1xuICAgICAgICAgICAgICAgIHNlZ3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzZWdSYW5nZS5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBzZWdSYW5nZS5lbmQsXG4gICAgICAgICAgICAgICAgICAgIGlzU3RhcnQ6IHNlZ1JhbmdlLnN0YXJ0LnZhbHVlT2YoKSA9PT0gcmFuZ2Uuc3RhcnQudmFsdWVPZigpLFxuICAgICAgICAgICAgICAgICAgICBpc0VuZDogc2VnUmFuZ2UuZW5kLnZhbHVlT2YoKSA9PT0gcmFuZ2UuZW5kLnZhbHVlT2YoKSxcbiAgICAgICAgICAgICAgICAgICAgY29sLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWdzO1xuICAgIH1cbn1cblxuY2xhc3MgRGF5VGltZUNvbHMgZXh0ZW5kcyBEYXRlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5idWlsZERheVJhbmdlcyA9IG1lbW9pemUoYnVpbGREYXlSYW5nZXMpO1xuICAgICAgICB0aGlzLnNsaWNlciA9IG5ldyBEYXlUaW1lQ29sc1NsaWNlcigpO1xuICAgICAgICB0aGlzLnRpbWVDb2xzUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IGRhdGVQcm9maWxlLCBkYXlUYWJsZU1vZGVsIH0gPSBwcm9wcztcbiAgICAgICAgbGV0IHsgbm93SW5kaWNhdG9yLCBuZXh0RGF5VGhyZXNob2xkIH0gPSBjb250ZXh0Lm9wdGlvbnM7XG4gICAgICAgIGxldCBkYXlSYW5nZXMgPSB0aGlzLmJ1aWxkRGF5UmFuZ2VzKGRheVRhYmxlTW9kZWwsIGRhdGVQcm9maWxlLCBjb250ZXh0LmRhdGVFbnYpO1xuICAgICAgICAvLyBnaXZlIGl0IHRoZSBmaXJzdCByb3cgb2YgY2VsbHNcbiAgICAgICAgLy8gVE9ETzogd291bGQgbW92ZSB0aGlzIGZ1cnRoZXIgZG93biBoaWVyYXJjaHksIGJ1dCBzbGljZU5vd0RhdGUgbmVlZHMgaXRcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KE5vd1RpbWVyLCB7IHVuaXQ6IG5vd0luZGljYXRvciA/ICdtaW51dGUnIDogJ2RheScgfSwgKG5vd0RhdGUsIHRvZGF5UmFuZ2UpID0+IChjcmVhdGVFbGVtZW50KFRpbWVDb2xzLCBPYmplY3QuYXNzaWduKHsgcmVmOiB0aGlzLnRpbWVDb2xzUmVmIH0sIHRoaXMuc2xpY2VyLnNsaWNlUHJvcHMocHJvcHMsIGRhdGVQcm9maWxlLCBudWxsLCBjb250ZXh0LCBkYXlSYW5nZXMpLCB7IGZvclByaW50OiBwcm9wcy5mb3JQcmludCwgYXhpczogcHJvcHMuYXhpcywgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLCBzbGF0TWV0YXM6IHByb3BzLnNsYXRNZXRhcywgc2xvdER1cmF0aW9uOiBwcm9wcy5zbG90RHVyYXRpb24sIGNlbGxzOiBkYXlUYWJsZU1vZGVsLmNlbGxzWzBdLCB0YWJsZUNvbEdyb3VwTm9kZTogcHJvcHMudGFibGVDb2xHcm91cE5vZGUsIHRhYmxlTWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsIGNsaWVudFdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0OiBwcm9wcy5jbGllbnRIZWlnaHQsIGV4cGFuZFJvd3M6IHByb3BzLmV4cGFuZFJvd3MsIG5vd0RhdGU6IG5vd0RhdGUsIG5vd0luZGljYXRvclNlZ3M6IG5vd0luZGljYXRvciAmJiB0aGlzLnNsaWNlci5zbGljZU5vd0RhdGUobm93RGF0ZSwgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIGNvbnRleHQsIGRheVJhbmdlcyksIHRvZGF5UmFuZ2U6IHRvZGF5UmFuZ2UsIG9uU2Nyb2xsVG9wUmVxdWVzdDogcHJvcHMub25TY3JvbGxUb3BSZXF1ZXN0LCBvblNsYXRDb29yZHM6IHByb3BzLm9uU2xhdENvb3JkcyB9KSkpKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gYnVpbGREYXlSYW5nZXMoZGF5VGFibGVNb2RlbCwgZGF0ZVByb2ZpbGUsIGRhdGVFbnYpIHtcbiAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgZm9yIChsZXQgZGF0ZSBvZiBkYXlUYWJsZU1vZGVsLmhlYWRlckRhdGVzKSB7XG4gICAgICAgIHJhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgIHN0YXJ0OiBkYXRlRW52LmFkZChkYXRlLCBkYXRlUHJvZmlsZS5zbG90TWluVGltZSksXG4gICAgICAgICAgICBlbmQ6IGRhdGVFbnYuYWRkKGRhdGUsIGRhdGVQcm9maWxlLnNsb3RNYXhUaW1lKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByYW5nZXM7XG59XG5cbi8vIHBvdGVudGlhbCBuaWNlIHZhbHVlcyBmb3IgdGhlIHNsb3QtZHVyYXRpb24gYW5kIGludGVydmFsLWR1cmF0aW9uXG4vLyBmcm9tIGxhcmdlc3QgdG8gc21hbGxlc3RcbmNvbnN0IFNUT0NLX1NVQl9EVVJBVElPTlMgPSBbXG4gICAgeyBob3VyczogMSB9LFxuICAgIHsgbWludXRlczogMzAgfSxcbiAgICB7IG1pbnV0ZXM6IDE1IH0sXG4gICAgeyBzZWNvbmRzOiAzMCB9LFxuICAgIHsgc2Vjb25kczogMTUgfSxcbl07XG5mdW5jdGlvbiBidWlsZFNsYXRNZXRhcyhzbG90TWluVGltZSwgc2xvdE1heFRpbWUsIGV4cGxpY2l0TGFiZWxJbnRlcnZhbCwgc2xvdER1cmF0aW9uLCBkYXRlRW52KSB7XG4gICAgbGV0IGRheVN0YXJ0ID0gbmV3IERhdGUoMCk7XG4gICAgbGV0IHNsYXRUaW1lID0gc2xvdE1pblRpbWU7XG4gICAgbGV0IHNsYXRJdGVyYXRvciA9IGNyZWF0ZUR1cmF0aW9uKDApO1xuICAgIGxldCBsYWJlbEludGVydmFsID0gZXhwbGljaXRMYWJlbEludGVydmFsIHx8IGNvbXB1dGVMYWJlbEludGVydmFsKHNsb3REdXJhdGlvbik7XG4gICAgbGV0IG1ldGFzID0gW107XG4gICAgd2hpbGUgKGFzUm91Z2hNcyhzbGF0VGltZSkgPCBhc1JvdWdoTXMoc2xvdE1heFRpbWUpKSB7XG4gICAgICAgIGxldCBkYXRlID0gZGF0ZUVudi5hZGQoZGF5U3RhcnQsIHNsYXRUaW1lKTtcbiAgICAgICAgbGV0IGlzTGFiZWxlZCA9IHdob2xlRGl2aWRlRHVyYXRpb25zKHNsYXRJdGVyYXRvciwgbGFiZWxJbnRlcnZhbCkgIT09IG51bGw7XG4gICAgICAgIG1ldGFzLnB1c2goe1xuICAgICAgICAgICAgZGF0ZSxcbiAgICAgICAgICAgIHRpbWU6IHNsYXRUaW1lLFxuICAgICAgICAgICAga2V5OiBkYXRlLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICBpc29UaW1lU3RyOiBmb3JtYXRJc29UaW1lU3RyaW5nKGRhdGUpLFxuICAgICAgICAgICAgaXNMYWJlbGVkLFxuICAgICAgICB9KTtcbiAgICAgICAgc2xhdFRpbWUgPSBhZGREdXJhdGlvbnMoc2xhdFRpbWUsIHNsb3REdXJhdGlvbik7XG4gICAgICAgIHNsYXRJdGVyYXRvciA9IGFkZER1cmF0aW9ucyhzbGF0SXRlcmF0b3IsIHNsb3REdXJhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBtZXRhcztcbn1cbi8vIENvbXB1dGVzIGFuIGF1dG9tYXRpYyB2YWx1ZSBmb3Igc2xvdExhYmVsSW50ZXJ2YWxcbmZ1bmN0aW9uIGNvbXB1dGVMYWJlbEludGVydmFsKHNsb3REdXJhdGlvbikge1xuICAgIGxldCBpO1xuICAgIGxldCBsYWJlbEludGVydmFsO1xuICAgIGxldCBzbG90c1BlckxhYmVsO1xuICAgIC8vIGZpbmQgdGhlIHNtYWxsZXN0IHN0b2NrIGxhYmVsIGludGVydmFsIHRoYXQgcmVzdWx0cyBpbiBtb3JlIHRoYW4gb25lIHNsb3RzLXBlci1sYWJlbFxuICAgIGZvciAoaSA9IFNUT0NLX1NVQl9EVVJBVElPTlMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgbGFiZWxJbnRlcnZhbCA9IGNyZWF0ZUR1cmF0aW9uKFNUT0NLX1NVQl9EVVJBVElPTlNbaV0pO1xuICAgICAgICBzbG90c1BlckxhYmVsID0gd2hvbGVEaXZpZGVEdXJhdGlvbnMobGFiZWxJbnRlcnZhbCwgc2xvdER1cmF0aW9uKTtcbiAgICAgICAgaWYgKHNsb3RzUGVyTGFiZWwgIT09IG51bGwgJiYgc2xvdHNQZXJMYWJlbCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBsYWJlbEludGVydmFsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzbG90RHVyYXRpb247IC8vIGZhbGwgYmFja1xufVxuXG5jbGFzcyBEYXlUaW1lQ29sc1ZpZXcgZXh0ZW5kcyBUaW1lQ29sc1ZpZXcge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmJ1aWxkVGltZUNvbHNNb2RlbCA9IG1lbW9pemUoYnVpbGRUaW1lQ29sc01vZGVsKTtcbiAgICAgICAgdGhpcy5idWlsZFNsYXRNZXRhcyA9IG1lbW9pemUoYnVpbGRTbGF0TWV0YXMpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IG9wdGlvbnMsIGRhdGVFbnYsIGRhdGVQcm9maWxlR2VuZXJhdG9yIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBkYXRlUHJvZmlsZSB9ID0gcHJvcHM7XG4gICAgICAgIGxldCBkYXlUYWJsZU1vZGVsID0gdGhpcy5idWlsZFRpbWVDb2xzTW9kZWwoZGF0ZVByb2ZpbGUsIGRhdGVQcm9maWxlR2VuZXJhdG9yKTtcbiAgICAgICAgbGV0IHNwbGl0UHJvcHMgPSB0aGlzLmFsbERheVNwbGl0dGVyLnNwbGl0UHJvcHMocHJvcHMpO1xuICAgICAgICBsZXQgc2xhdE1ldGFzID0gdGhpcy5idWlsZFNsYXRNZXRhcyhkYXRlUHJvZmlsZS5zbG90TWluVGltZSwgZGF0ZVByb2ZpbGUuc2xvdE1heFRpbWUsIG9wdGlvbnMuc2xvdExhYmVsSW50ZXJ2YWwsIG9wdGlvbnMuc2xvdER1cmF0aW9uLCBkYXRlRW52KTtcbiAgICAgICAgbGV0IHsgZGF5TWluV2lkdGggfSA9IG9wdGlvbnM7XG4gICAgICAgIGxldCBoYXNBdHRhY2hlZEF4aXMgPSAhZGF5TWluV2lkdGg7XG4gICAgICAgIGxldCBoYXNEZXRhY2hlZEF4aXMgPSBkYXlNaW5XaWR0aDtcbiAgICAgICAgbGV0IGhlYWRlckNvbnRlbnQgPSBvcHRpb25zLmRheUhlYWRlcnMgJiYgKGNyZWF0ZUVsZW1lbnQoRGF5SGVhZGVyLCB7IGRhdGVzOiBkYXlUYWJsZU1vZGVsLmhlYWRlckRhdGVzLCBkYXRlUHJvZmlsZTogZGF0ZVByb2ZpbGUsIGRhdGVzUmVwRGlzdGluY3REYXlzOiB0cnVlLCByZW5kZXJJbnRybzogaGFzQXR0YWNoZWRBeGlzID8gdGhpcy5yZW5kZXJIZWFkQXhpcyA6IG51bGwgfSkpO1xuICAgICAgICBsZXQgYWxsRGF5Q29udGVudCA9IChvcHRpb25zLmFsbERheVNsb3QgIT09IGZhbHNlKSAmJiAoKGNvbnRlbnRBcmcpID0+IChjcmVhdGVFbGVtZW50KERheVRhYmxlLCBPYmplY3QuYXNzaWduKHt9LCBzcGxpdFByb3BzLmFsbERheSwgeyBkYXRlUHJvZmlsZTogZGF0ZVByb2ZpbGUsIGRheVRhYmxlTW9kZWw6IGRheVRhYmxlTW9kZWwsIG5leHREYXlUaHJlc2hvbGQ6IG9wdGlvbnMubmV4dERheVRocmVzaG9sZCwgdGFibGVNaW5XaWR0aDogY29udGVudEFyZy50YWJsZU1pbldpZHRoLCBjb2xHcm91cE5vZGU6IGNvbnRlbnRBcmcudGFibGVDb2xHcm91cE5vZGUsIHJlbmRlclJvd0ludHJvOiBoYXNBdHRhY2hlZEF4aXMgPyB0aGlzLnJlbmRlclRhYmxlUm93QXhpcyA6IG51bGwsIHNob3dXZWVrTnVtYmVyczogZmFsc2UsIGV4cGFuZFJvd3M6IGZhbHNlLCBoZWFkZXJBbGlnbkVsUmVmOiB0aGlzLmhlYWRlckVsUmVmLCBjbGllbnRXaWR0aDogY29udGVudEFyZy5jbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0OiBjb250ZW50QXJnLmNsaWVudEhlaWdodCwgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50IH0sIHRoaXMuZ2V0QWxsRGF5TWF4RXZlbnRQcm9wcygpKSkpKTtcbiAgICAgICAgbGV0IHRpbWVHcmlkQ29udGVudCA9IChjb250ZW50QXJnKSA9PiAoY3JlYXRlRWxlbWVudChEYXlUaW1lQ29scywgT2JqZWN0LmFzc2lnbih7fSwgc3BsaXRQcm9wcy50aW1lZCwgeyBkYXlUYWJsZU1vZGVsOiBkYXlUYWJsZU1vZGVsLCBkYXRlUHJvZmlsZTogZGF0ZVByb2ZpbGUsIGF4aXM6IGhhc0F0dGFjaGVkQXhpcywgc2xvdER1cmF0aW9uOiBvcHRpb25zLnNsb3REdXJhdGlvbiwgc2xhdE1ldGFzOiBzbGF0TWV0YXMsIGZvclByaW50OiBwcm9wcy5mb3JQcmludCwgdGFibGVDb2xHcm91cE5vZGU6IGNvbnRlbnRBcmcudGFibGVDb2xHcm91cE5vZGUsIHRhYmxlTWluV2lkdGg6IGNvbnRlbnRBcmcudGFibGVNaW5XaWR0aCwgY2xpZW50V2lkdGg6IGNvbnRlbnRBcmcuY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodDogY29udGVudEFyZy5jbGllbnRIZWlnaHQsIG9uU2xhdENvb3JkczogdGhpcy5oYW5kbGVTbGF0Q29vcmRzLCBleHBhbmRSb3dzOiBjb250ZW50QXJnLmV4cGFuZFJvd3MsIG9uU2Nyb2xsVG9wUmVxdWVzdDogdGhpcy5oYW5kbGVTY3JvbGxUb3BSZXF1ZXN0IH0pKSk7XG4gICAgICAgIHJldHVybiBoYXNEZXRhY2hlZEF4aXNcbiAgICAgICAgICAgID8gdGhpcy5yZW5kZXJIU2Nyb2xsTGF5b3V0KGhlYWRlckNvbnRlbnQsIGFsbERheUNvbnRlbnQsIHRpbWVHcmlkQ29udGVudCwgZGF5VGFibGVNb2RlbC5jb2xDbnQsIGRheU1pbldpZHRoLCBzbGF0TWV0YXMsIHRoaXMuc3RhdGUuc2xhdENvb3JkcylcbiAgICAgICAgICAgIDogdGhpcy5yZW5kZXJTaW1wbGVMYXlvdXQoaGVhZGVyQ29udGVudCwgYWxsRGF5Q29udGVudCwgdGltZUdyaWRDb250ZW50KTtcbiAgICB9XG59XG5mdW5jdGlvbiBidWlsZFRpbWVDb2xzTW9kZWwoZGF0ZVByb2ZpbGUsIGRhdGVQcm9maWxlR2VuZXJhdG9yKSB7XG4gICAgbGV0IGRheVNlcmllcyA9IG5ldyBEYXlTZXJpZXNNb2RlbChkYXRlUHJvZmlsZS5yZW5kZXJSYW5nZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IpO1xuICAgIHJldHVybiBuZXcgRGF5VGFibGVNb2RlbChkYXlTZXJpZXMsIGZhbHNlKTtcbn1cblxudmFyIGNzc18yNDh6ID0gXCIuZmMtdi1ldmVudHtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWZjLWV2ZW50LWJnLWNvbG9yKTtib3JkZXI6MXB4IHNvbGlkIHZhcigtLWZjLWV2ZW50LWJvcmRlci1jb2xvcik7ZGlzcGxheTpibG9ja30uZmMtdi1ldmVudCAuZmMtZXZlbnQtbWFpbntjb2xvcjp2YXIoLS1mYy1ldmVudC10ZXh0LWNvbG9yKTtoZWlnaHQ6MTAwJX0uZmMtdi1ldmVudCAuZmMtZXZlbnQtbWFpbi1mcmFtZXtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1uO2hlaWdodDoxMDAlfS5mYy12LWV2ZW50IC5mYy1ldmVudC10aW1le2ZsZXgtZ3JvdzowO2ZsZXgtc2hyaW5rOjA7bWF4LWhlaWdodDoxMDAlO292ZXJmbG93OmhpZGRlbn0uZmMtdi1ldmVudCAuZmMtZXZlbnQtdGl0bGUtY29udGFpbmVye2ZsZXgtZ3JvdzoxO2ZsZXgtc2hyaW5rOjE7bWluLWhlaWdodDowfS5mYy12LWV2ZW50IC5mYy1ldmVudC10aXRsZXtib3R0b206MDttYXgtaGVpZ2h0OjEwMCU7b3ZlcmZsb3c6aGlkZGVuO3RvcDowfS5mYy12LWV2ZW50Om5vdCguZmMtZXZlbnQtc3RhcnQpe2JvcmRlci10b3AtbGVmdC1yYWRpdXM6MDtib3JkZXItdG9wLXJpZ2h0LXJhZGl1czowO2JvcmRlci10b3Atd2lkdGg6MH0uZmMtdi1ldmVudDpub3QoLmZjLWV2ZW50LWVuZCl7Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czowO2JvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOjA7Ym9yZGVyLWJvdHRvbS13aWR0aDowfS5mYy12LWV2ZW50LmZjLWV2ZW50LXNlbGVjdGVkOmJlZm9yZXtsZWZ0Oi0xMHB4O3JpZ2h0Oi0xMHB4fS5mYy12LWV2ZW50IC5mYy1ldmVudC1yZXNpemVyLXN0YXJ0e2N1cnNvcjpuLXJlc2l6ZX0uZmMtdi1ldmVudCAuZmMtZXZlbnQtcmVzaXplci1lbmR7Y3Vyc29yOnMtcmVzaXplfS5mYy12LWV2ZW50Om5vdCguZmMtZXZlbnQtc2VsZWN0ZWQpIC5mYy1ldmVudC1yZXNpemVye2hlaWdodDp2YXIoLS1mYy1ldmVudC1yZXNpemVyLXRoaWNrbmVzcyk7bGVmdDowO3JpZ2h0OjB9LmZjLXYtZXZlbnQ6bm90KC5mYy1ldmVudC1zZWxlY3RlZCkgLmZjLWV2ZW50LXJlc2l6ZXItc3RhcnR7dG9wOmNhbGModmFyKC0tZmMtZXZlbnQtcmVzaXplci10aGlja25lc3MpLy0yKX0uZmMtdi1ldmVudDpub3QoLmZjLWV2ZW50LXNlbGVjdGVkKSAuZmMtZXZlbnQtcmVzaXplci1lbmR7Ym90dG9tOmNhbGModmFyKC0tZmMtZXZlbnQtcmVzaXplci10aGlja25lc3MpLy0yKX0uZmMtdi1ldmVudC5mYy1ldmVudC1zZWxlY3RlZCAuZmMtZXZlbnQtcmVzaXplcntsZWZ0OjUwJTttYXJnaW4tbGVmdDpjYWxjKHZhcigtLWZjLWV2ZW50LXJlc2l6ZXItZG90LXRvdGFsLXdpZHRoKS8tMil9LmZjLXYtZXZlbnQuZmMtZXZlbnQtc2VsZWN0ZWQgLmZjLWV2ZW50LXJlc2l6ZXItc3RhcnR7dG9wOmNhbGModmFyKC0tZmMtZXZlbnQtcmVzaXplci1kb3QtdG90YWwtd2lkdGgpLy0yKX0uZmMtdi1ldmVudC5mYy1ldmVudC1zZWxlY3RlZCAuZmMtZXZlbnQtcmVzaXplci1lbmR7Ym90dG9tOmNhbGModmFyKC0tZmMtZXZlbnQtcmVzaXplci1kb3QtdG90YWwtd2lkdGgpLy0yKX0uZmMgLmZjLXRpbWVncmlkIC5mYy1kYXlncmlkLWJvZHl7ei1pbmRleDoyfS5mYyAuZmMtdGltZWdyaWQtZGl2aWRlcntwYWRkaW5nOjAgMCAycHh9LmZjIC5mYy10aW1lZ3JpZC1ib2R5e21pbi1oZWlnaHQ6MTAwJTtwb3NpdGlvbjpyZWxhdGl2ZTt6LWluZGV4OjF9LmZjIC5mYy10aW1lZ3JpZC1heGlzLWNodW5re3Bvc2l0aW9uOnJlbGF0aXZlfS5mYyAuZmMtdGltZWdyaWQtYXhpcy1jaHVuaz50YWJsZSwuZmMgLmZjLXRpbWVncmlkLXNsb3Rze3Bvc2l0aW9uOnJlbGF0aXZlO3otaW5kZXg6MX0uZmMgLmZjLXRpbWVncmlkLXNsb3R7Ym9yZGVyLWJvdHRvbTowO2hlaWdodDoxLjVlbX0uZmMgLmZjLXRpbWVncmlkLXNsb3Q6ZW1wdHk6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFwwMGEwXFxcIn0uZmMgLmZjLXRpbWVncmlkLXNsb3QtbWlub3J7Ym9yZGVyLXRvcC1zdHlsZTpkb3R0ZWR9LmZjIC5mYy10aW1lZ3JpZC1zbG90LWxhYmVsLWN1c2hpb257ZGlzcGxheTppbmxpbmUtYmxvY2s7d2hpdGUtc3BhY2U6bm93cmFwfS5mYyAuZmMtdGltZWdyaWQtc2xvdC1sYWJlbHt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9LmZjIC5mYy10aW1lZ3JpZC1heGlzLWN1c2hpb24sLmZjIC5mYy10aW1lZ3JpZC1zbG90LWxhYmVsLWN1c2hpb257cGFkZGluZzowIDRweH0uZmMgLmZjLXRpbWVncmlkLWF4aXMtZnJhbWUtbGlxdWlke2hlaWdodDoxMDAlfS5mYyAuZmMtdGltZWdyaWQtYXhpcy1mcmFtZXthbGlnbi1pdGVtczpjZW50ZXI7ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpmbGV4LWVuZDtvdmVyZmxvdzpoaWRkZW59LmZjIC5mYy10aW1lZ3JpZC1heGlzLWN1c2hpb257ZmxleC1zaHJpbms6MDttYXgtd2lkdGg6NjBweH0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtdGltZWdyaWQtc2xvdC1sYWJlbC1mcmFtZXt0ZXh0LWFsaWduOnJpZ2h0fS5mYy1kaXJlY3Rpb24tcnRsIC5mYy10aW1lZ3JpZC1zbG90LWxhYmVsLWZyYW1le3RleHQtYWxpZ246bGVmdH0uZmMtbGlxdWlkLWhhY2sgLmZjLXRpbWVncmlkLWF4aXMtZnJhbWUtbGlxdWlke2JvdHRvbTowO2hlaWdodDphdXRvO2xlZnQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO3RvcDowfS5mYyAuZmMtdGltZWdyaWQtY29sLmZjLWRheS10b2RheXtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWZjLXRvZGF5LWJnLWNvbG9yKX0uZmMgLmZjLXRpbWVncmlkLWNvbC1mcmFtZXttaW4taGVpZ2h0OjEwMCU7cG9zaXRpb246cmVsYXRpdmV9LmZjLW1lZGlhLXNjcmVlbi5mYy1saXF1aWQtaGFjayAuZmMtdGltZWdyaWQtY29sLWZyYW1le2JvdHRvbTowO2hlaWdodDphdXRvO2xlZnQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO3RvcDowfS5mYy1tZWRpYS1zY3JlZW4gLmZjLXRpbWVncmlkLWNvbHN7Ym90dG9tOjA7bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7dG9wOjB9LmZjLW1lZGlhLXNjcmVlbiAuZmMtdGltZWdyaWQtY29scz50YWJsZXtoZWlnaHQ6MTAwJX0uZmMtbWVkaWEtc2NyZWVuIC5mYy10aW1lZ3JpZC1jb2wtYmcsLmZjLW1lZGlhLXNjcmVlbiAuZmMtdGltZWdyaWQtY29sLWV2ZW50cywuZmMtbWVkaWEtc2NyZWVuIC5mYy10aW1lZ3JpZC1ub3ctaW5kaWNhdG9yLWNvbnRhaW5lcntsZWZ0OjA7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MDt0b3A6MH0uZmMgLmZjLXRpbWVncmlkLWNvbC1iZ3t6LWluZGV4OjJ9LmZjIC5mYy10aW1lZ3JpZC1jb2wtYmcgLmZjLW5vbi1idXNpbmVzc3t6LWluZGV4OjF9LmZjIC5mYy10aW1lZ3JpZC1jb2wtYmcgLmZjLWJnLWV2ZW50e3otaW5kZXg6Mn0uZmMgLmZjLXRpbWVncmlkLWNvbC1iZyAuZmMtaGlnaGxpZ2h0e3otaW5kZXg6M30uZmMgLmZjLXRpbWVncmlkLWJnLWhhcm5lc3N7bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjB9LmZjIC5mYy10aW1lZ3JpZC1jb2wtZXZlbnRze3otaW5kZXg6M30uZmMgLmZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItY29udGFpbmVye2JvdHRvbTowO292ZXJmbG93OmhpZGRlbn0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtdGltZWdyaWQtY29sLWV2ZW50c3ttYXJnaW46MCAyLjUlIDAgMnB4fS5mYy1kaXJlY3Rpb24tcnRsIC5mYy10aW1lZ3JpZC1jb2wtZXZlbnRze21hcmdpbjowIDJweCAwIDIuNSV9LmZjLXRpbWVncmlkLWV2ZW50LWhhcm5lc3N7cG9zaXRpb246YWJzb2x1dGV9LmZjLXRpbWVncmlkLWV2ZW50LWhhcm5lc3M+LmZjLXRpbWVncmlkLWV2ZW50e2JvdHRvbTowO2xlZnQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO3RvcDowfS5mYy10aW1lZ3JpZC1ldmVudC1oYXJuZXNzLWluc2V0IC5mYy10aW1lZ3JpZC1ldmVudCwuZmMtdGltZWdyaWQtZXZlbnQuZmMtZXZlbnQtbWlycm9yLC5mYy10aW1lZ3JpZC1tb3JlLWxpbmt7Ym94LXNoYWRvdzowIDAgMCAxcHggdmFyKC0tZmMtcGFnZS1iZy1jb2xvcil9LmZjLXRpbWVncmlkLWV2ZW50LC5mYy10aW1lZ3JpZC1tb3JlLWxpbmt7Ym9yZGVyLXJhZGl1czozcHg7Zm9udC1zaXplOnZhcigtLWZjLXNtYWxsLWZvbnQtc2l6ZSl9LmZjLXRpbWVncmlkLWV2ZW50e21hcmdpbi1ib3R0b206MXB4fS5mYy10aW1lZ3JpZC1ldmVudCAuZmMtZXZlbnQtbWFpbntwYWRkaW5nOjFweCAxcHggMH0uZmMtdGltZWdyaWQtZXZlbnQgLmZjLWV2ZW50LXRpbWV7Zm9udC1zaXplOnZhcigtLWZjLXNtYWxsLWZvbnQtc2l6ZSk7bWFyZ2luLWJvdHRvbToxcHg7d2hpdGUtc3BhY2U6bm93cmFwfS5mYy10aW1lZ3JpZC1ldmVudC1zaG9ydCAuZmMtZXZlbnQtbWFpbi1mcmFtZXtmbGV4LWRpcmVjdGlvbjpyb3c7b3ZlcmZsb3c6aGlkZGVufS5mYy10aW1lZ3JpZC1ldmVudC1zaG9ydCAuZmMtZXZlbnQtdGltZTphZnRlcntjb250ZW50OlxcXCJcXFxcMDBhMC1cXFxcMDBhMFxcXCJ9LmZjLXRpbWVncmlkLWV2ZW50LXNob3J0IC5mYy1ldmVudC10aXRsZXtmb250LXNpemU6dmFyKC0tZmMtc21hbGwtZm9udC1zaXplKX0uZmMtdGltZWdyaWQtbW9yZS1saW5re2JhY2tncm91bmQ6dmFyKC0tZmMtbW9yZS1saW5rLWJnLWNvbG9yKTtjb2xvcjp2YXIoLS1mYy1tb3JlLWxpbmstdGV4dC1jb2xvcik7Y3Vyc29yOnBvaW50ZXI7bWFyZ2luLWJvdHRvbToxcHg7cG9zaXRpb246YWJzb2x1dGU7ei1pbmRleDo5OTk5fS5mYy10aW1lZ3JpZC1tb3JlLWxpbmstaW5uZXJ7cGFkZGluZzozcHggMnB4O3RvcDowfS5mYy1kaXJlY3Rpb24tbHRyIC5mYy10aW1lZ3JpZC1tb3JlLWxpbmt7cmlnaHQ6MH0uZmMtZGlyZWN0aW9uLXJ0bCAuZmMtdGltZWdyaWQtbW9yZS1saW5re2xlZnQ6MH0uZmMgLmZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItYXJyb3csLmZjIC5mYy10aW1lZ3JpZC1ub3ctaW5kaWNhdG9yLWxpbmV7cG9pbnRlci1ldmVudHM6bm9uZX0uZmMgLmZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItbGluZXtib3JkZXItY29sb3I6dmFyKC0tZmMtbm93LWluZGljYXRvci1jb2xvcik7Ym9yZGVyLXN0eWxlOnNvbGlkO2JvcmRlci13aWR0aDoxcHggMCAwO2xlZnQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO3otaW5kZXg6NH0uZmMgLmZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItYXJyb3d7Ym9yZGVyLWNvbG9yOnZhcigtLWZjLW5vdy1pbmRpY2F0b3ItY29sb3IpO2JvcmRlci1zdHlsZTpzb2xpZDttYXJnaW4tdG9wOi01cHg7cG9zaXRpb246YWJzb2x1dGU7ei1pbmRleDo0fS5mYy1kaXJlY3Rpb24tbHRyIC5mYy10aW1lZ3JpZC1ub3ctaW5kaWNhdG9yLWFycm93e2JvcmRlci1ib3R0b20tY29sb3I6dHJhbnNwYXJlbnQ7Ym9yZGVyLXRvcC1jb2xvcjp0cmFuc3BhcmVudDtib3JkZXItd2lkdGg6NXB4IDAgNXB4IDZweDtsZWZ0OjB9LmZjLWRpcmVjdGlvbi1ydGwgLmZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItYXJyb3d7Ym9yZGVyLWJvdHRvbS1jb2xvcjp0cmFuc3BhcmVudDtib3JkZXItdG9wLWNvbG9yOnRyYW5zcGFyZW50O2JvcmRlci13aWR0aDo1cHggNnB4IDVweCAwO3JpZ2h0OjB9XCI7XG5pbmplY3RTdHlsZXMoY3NzXzI0OHopO1xuXG5leHBvcnQgeyBEYXlUaW1lQ29scywgRGF5VGltZUNvbHNTbGljZXIsIERheVRpbWVDb2xzVmlldywgVGltZUNvbHMsIFRpbWVDb2xzU2xhdHNDb29yZHMsIFRpbWVDb2xzVmlldywgYnVpbGREYXlSYW5nZXMsIGJ1aWxkU2xhdE1ldGFzLCBidWlsZFRpbWVDb2xzTW9kZWwgfTtcbiIsICJpbXBvcnQgeyBjcmVhdGVQbHVnaW4gfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvcmUvaW5kZXguanMnO1xuaW1wb3J0IHsgRGF5VGltZUNvbHNWaWV3IH0gZnJvbSAnLi9pbnRlcm5hbC5qcyc7XG5pbXBvcnQgJ0BmdWxsY2FsZW5kYXIvY29yZS9pbnRlcm5hbC5qcyc7XG5pbXBvcnQgJ0BmdWxsY2FsZW5kYXIvY29yZS9wcmVhY3QuanMnO1xuaW1wb3J0ICdAZnVsbGNhbGVuZGFyL2RheWdyaWQvaW50ZXJuYWwuanMnO1xuXG5jb25zdCBPUFRJT05fUkVGSU5FUlMgPSB7XG4gICAgYWxsRGF5U2xvdDogQm9vbGVhbixcbn07XG5cbnZhciBpbmRleCA9IGNyZWF0ZVBsdWdpbih7XG4gICAgbmFtZTogJ0BmdWxsY2FsZW5kYXIvdGltZWdyaWQnLFxuICAgIGluaXRpYWxWaWV3OiAndGltZUdyaWRXZWVrJyxcbiAgICBvcHRpb25SZWZpbmVyczogT1BUSU9OX1JFRklORVJTLFxuICAgIHZpZXdzOiB7XG4gICAgICAgIHRpbWVHcmlkOiB7XG4gICAgICAgICAgICBjb21wb25lbnQ6IERheVRpbWVDb2xzVmlldyxcbiAgICAgICAgICAgIHVzZXNNaW5NYXhUaW1lOiB0cnVlLFxuICAgICAgICAgICAgYWxsRGF5U2xvdDogdHJ1ZSxcbiAgICAgICAgICAgIHNsb3REdXJhdGlvbjogJzAwOjMwOjAwJyxcbiAgICAgICAgICAgIHNsb3RFdmVudE92ZXJsYXA6IHRydWUsIC8vIGEgYmFkIG5hbWUuIGNvbmZ1c2VkIHdpdGggb3ZlcmxhcC9jb25zdHJhaW50IHN5c3RlbVxuICAgICAgICB9LFxuICAgICAgICB0aW1lR3JpZERheToge1xuICAgICAgICAgICAgdHlwZTogJ3RpbWVHcmlkJyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB7IGRheXM6IDEgfSxcbiAgICAgICAgfSxcbiAgICAgICAgdGltZUdyaWRXZWVrOiB7XG4gICAgICAgICAgICB0eXBlOiAndGltZUdyaWQnLFxuICAgICAgICAgICAgZHVyYXRpb246IHsgd2Vla3M6IDEgfSxcbiAgICAgICAgfSxcbiAgICB9LFxufSk7XG5cbmV4cG9ydCB7IGluZGV4IGFzIGRlZmF1bHQgfTtcbiIsIG51bGwsIG51bGwsIG51bGwsIG51bGwsICIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19jcmVhdGVCaW5kaW5nID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcclxuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XHJcbiAgICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XHJcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59KTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgbykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwKSkgX19jcmVhdGVCaW5kaW5nKG8sIG0sIHApO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xyXG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgcmV0dXJuIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XHJcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcclxuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcclxuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XHJcbn0pIDogZnVuY3Rpb24obywgdikge1xyXG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XHJcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4oc3RhdGUsIHJlY2VpdmVyKSB7XHJcbiAgICBpZiAocmVjZWl2ZXIgPT09IG51bGwgfHwgKHR5cGVvZiByZWNlaXZlciAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcmVjZWl2ZXIgIT09IFwiZnVuY3Rpb25cIikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgdXNlICdpbicgb3BlcmF0b3Igb24gbm9uLW9iamVjdFwiKTtcclxuICAgIHJldHVybiB0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyID09PSBzdGF0ZSA6IHN0YXRlLmhhcyhyZWNlaXZlcik7XHJcbn1cclxuIiwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgImltcG9ydCB7IGNyZWF0ZVBsdWdpbiB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29yZS9pbmRleC5qcyc7XG5pbXBvcnQgKiBhcyBycnVsZUxpYiBmcm9tICdycnVsZSc7XG5pbXBvcnQgeyBwYXJzZU1hcmtlciwgaWRlbnRpdHksIGNyZWF0ZUR1cmF0aW9uIH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb3JlL2ludGVybmFsLmpzJztcblxuY29uc3QgcmVjdXJyaW5nVHlwZSA9IHtcbiAgICBwYXJzZShldmVudFByb3BzLCBkYXRlRW52KSB7XG4gICAgICAgIGlmIChldmVudFByb3BzLnJydWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBldmVudFJSdWxlRGF0YSA9IHBhcnNlRXZlbnRSUnVsZShldmVudFByb3BzLCBkYXRlRW52KTtcbiAgICAgICAgICAgIGlmIChldmVudFJSdWxlRGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVEYXRhOiB7IHJydWxlU2V0OiBldmVudFJSdWxlRGF0YS5ycnVsZVNldCwgaXNUaW1lWm9uZVNwZWNpZmllZDogZXZlbnRSUnVsZURhdGEuaXNUaW1lWm9uZVNwZWNpZmllZCB9LFxuICAgICAgICAgICAgICAgICAgICBhbGxEYXlHdWVzczogIWV2ZW50UlJ1bGVEYXRhLmlzVGltZVNwZWNpZmllZCxcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IGV2ZW50UHJvcHMuZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGV4cGFuZChldmVudFJSdWxlRGF0YSwgZnJhbWluZ1JhbmdlLCBkYXRlRW52KSB7XG4gICAgICAgIGxldCBkYXRlcztcbiAgICAgICAgaWYgKGV2ZW50UlJ1bGVEYXRhLmlzVGltZVpvbmVTcGVjaWZpZWQpIHtcbiAgICAgICAgICAgIGRhdGVzID0gZXZlbnRSUnVsZURhdGEucnJ1bGVTZXQuYmV0d2VlbihkYXRlRW52LnRvRGF0ZShmcmFtaW5nUmFuZ2Uuc3RhcnQpLCAvLyBycnVsZSBsaWIgd2lsbCB0cmVhdCBhcyBVVEMtem9uZWRcbiAgICAgICAgICAgIGRhdGVFbnYudG9EYXRlKGZyYW1pbmdSYW5nZS5lbmQpLCAvLyAoc2FtZSlcbiAgICAgICAgICAgIHRydWUpLm1hcCgoZGF0ZSkgPT4gZGF0ZUVudi5jcmVhdGVNYXJrZXIoZGF0ZSkpOyAvLyBjb252ZXJ0IFVUQy16b25lZC1kYXRlIHRvIGxvY2FsZSBkYXRlbWFya2VyXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB3aGVuIG5vIHRpbWV6b25lIGluIGdpdmVuIHN0YXJ0L2VuZCwgdGhlIHJydWxlIGxpYiB3aWxsIGFzc3VtZSBVVEMsXG4gICAgICAgICAgICAvLyB3aGljaCBpcyBzYW1lIGFzIG91ciBEYXRlTWFya2Vycy4gbm8gbmVlZCB0byBtYW5pcHVsYXRlXG4gICAgICAgICAgICBkYXRlcyA9IGV2ZW50UlJ1bGVEYXRhLnJydWxlU2V0LmJldHdlZW4oZnJhbWluZ1JhbmdlLnN0YXJ0LCBmcmFtaW5nUmFuZ2UuZW5kLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZXM7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBwYXJzZUV2ZW50UlJ1bGUoZXZlbnRQcm9wcywgZGF0ZUVudikge1xuICAgIGxldCBycnVsZVNldDtcbiAgICBsZXQgaXNUaW1lU3BlY2lmaWVkID0gZmFsc2U7XG4gICAgbGV0IGlzVGltZVpvbmVTcGVjaWZpZWQgPSBmYWxzZTtcbiAgICBpZiAodHlwZW9mIGV2ZW50UHJvcHMucnJ1bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGxldCByZXMgPSBwYXJzZVJSdWxlU3RyaW5nKGV2ZW50UHJvcHMucnJ1bGUpO1xuICAgICAgICBycnVsZVNldCA9IHJlcy5ycnVsZVNldDtcbiAgICAgICAgaXNUaW1lU3BlY2lmaWVkID0gcmVzLmlzVGltZVNwZWNpZmllZDtcbiAgICAgICAgaXNUaW1lWm9uZVNwZWNpZmllZCA9IHJlcy5pc1RpbWVab25lU3BlY2lmaWVkO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGV2ZW50UHJvcHMucnJ1bGUgPT09ICdvYmplY3QnICYmIGV2ZW50UHJvcHMucnJ1bGUpIHsgLy8gbm9uLW51bGwgb2JqZWN0XG4gICAgICAgIGxldCByZXMgPSBwYXJzZVJSdWxlT2JqZWN0KGV2ZW50UHJvcHMucnJ1bGUsIGRhdGVFbnYpO1xuICAgICAgICBycnVsZVNldCA9IG5ldyBycnVsZUxpYi5SUnVsZVNldCgpO1xuICAgICAgICBycnVsZVNldC5ycnVsZShyZXMucnJ1bGUpO1xuICAgICAgICBpc1RpbWVTcGVjaWZpZWQgPSByZXMuaXNUaW1lU3BlY2lmaWVkO1xuICAgICAgICBpc1RpbWVab25lU3BlY2lmaWVkID0gcmVzLmlzVGltZVpvbmVTcGVjaWZpZWQ7XG4gICAgfVxuICAgIC8vIGNvbnZlcnkgdG8gYXJyYXlzLiBUT0RPOiBnZW5lcmFsIHV0aWw/XG4gICAgbGV0IGV4ZGF0ZUlucHV0cyA9IFtdLmNvbmNhdChldmVudFByb3BzLmV4ZGF0ZSB8fCBbXSk7XG4gICAgbGV0IGV4cnVsZUlucHV0cyA9IFtdLmNvbmNhdChldmVudFByb3BzLmV4cnVsZSB8fCBbXSk7XG4gICAgZm9yIChsZXQgZXhkYXRlSW5wdXQgb2YgZXhkYXRlSW5wdXRzKSB7XG4gICAgICAgIGxldCByZXMgPSBwYXJzZU1hcmtlcihleGRhdGVJbnB1dCk7XG4gICAgICAgIGlzVGltZVNwZWNpZmllZCA9IGlzVGltZVNwZWNpZmllZCB8fCAhcmVzLmlzVGltZVVuc3BlY2lmaWVkO1xuICAgICAgICBpc1RpbWVab25lU3BlY2lmaWVkID0gaXNUaW1lWm9uZVNwZWNpZmllZCB8fCByZXMudGltZVpvbmVPZmZzZXQgIT09IG51bGw7XG4gICAgICAgIHJydWxlU2V0LmV4ZGF0ZShuZXcgRGF0ZShyZXMubWFya2VyLnZhbHVlT2YoKSAtIChyZXMudGltZVpvbmVPZmZzZXQgfHwgMCkgKiA2MCAqIDEwMDApKTtcbiAgICB9XG4gICAgLy8gVE9ETzogZXhydWxlIGlzIGRlcHJlY2F0ZWQuIHdoYXQgdG8gZG8/IChodHRwczovL2ljYWxlbmRhci5vcmcvaUNhbGVuZGFyLVJGQy01NTQ1L2EtMy1kZXByZWNhdGVkLWZlYXR1cmVzLmh0bWwpXG4gICAgZm9yIChsZXQgZXhydWxlSW5wdXQgb2YgZXhydWxlSW5wdXRzKSB7XG4gICAgICAgIGxldCByZXMgPSBwYXJzZVJSdWxlT2JqZWN0KGV4cnVsZUlucHV0LCBkYXRlRW52KTtcbiAgICAgICAgaXNUaW1lU3BlY2lmaWVkID0gaXNUaW1lU3BlY2lmaWVkIHx8IHJlcy5pc1RpbWVTcGVjaWZpZWQ7XG4gICAgICAgIGlzVGltZVpvbmVTcGVjaWZpZWQgPSBpc1RpbWVab25lU3BlY2lmaWVkIHx8IHJlcy5pc1RpbWVab25lU3BlY2lmaWVkO1xuICAgICAgICBycnVsZVNldC5leHJ1bGUocmVzLnJydWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgcnJ1bGVTZXQsIGlzVGltZVNwZWNpZmllZCwgaXNUaW1lWm9uZVNwZWNpZmllZCB9O1xufVxuZnVuY3Rpb24gcGFyc2VSUnVsZU9iamVjdChycnVsZUlucHV0LCBkYXRlRW52KSB7XG4gICAgbGV0IGlzVGltZVNwZWNpZmllZCA9IGZhbHNlO1xuICAgIGxldCBpc1RpbWVab25lU3BlY2lmaWVkID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gcHJvY2Vzc0RhdGVJbnB1dChkYXRlSW5wdXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRlSW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBsZXQgbWFya2VyRGF0YSA9IHBhcnNlTWFya2VyKGRhdGVJbnB1dCk7XG4gICAgICAgICAgICBpZiAobWFya2VyRGF0YSkge1xuICAgICAgICAgICAgICAgIGlzVGltZVNwZWNpZmllZCA9IGlzVGltZVNwZWNpZmllZCB8fCAhbWFya2VyRGF0YS5pc1RpbWVVbnNwZWNpZmllZDtcbiAgICAgICAgICAgICAgICBpc1RpbWVab25lU3BlY2lmaWVkID0gaXNUaW1lWm9uZVNwZWNpZmllZCB8fCBtYXJrZXJEYXRhLnRpbWVab25lT2Zmc2V0ICE9PSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShtYXJrZXJEYXRhLm1hcmtlci52YWx1ZU9mKCkgLSAobWFya2VyRGF0YS50aW1lWm9uZU9mZnNldCB8fCAwKSAqIDYwICogMTAwMCk7IC8vIE5PVCBEUllcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlSW5wdXQ7IC8vIFRPRE86IHdoYXQgYWJvdXQgbnVtYmVyIHRpbWVzdGFtcHM/XG4gICAgfVxuICAgIGxldCBycnVsZU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJydWxlSW5wdXQpLCB7IGR0c3RhcnQ6IHByb2Nlc3NEYXRlSW5wdXQocnJ1bGVJbnB1dC5kdHN0YXJ0KSwgdW50aWw6IHByb2Nlc3NEYXRlSW5wdXQocnJ1bGVJbnB1dC51bnRpbCksIGZyZXE6IGNvbnZlcnRDb25zdGFudChycnVsZUlucHV0LmZyZXEpLCB3a3N0OiBycnVsZUlucHV0Lndrc3QgPT0gbnVsbFxuICAgICAgICAgICAgPyAoZGF0ZUVudi53ZWVrRG93IC0gMSArIDcpICUgNyAvLyBjb252ZXJ0IFN1bmRheS1maXJzdCB0byBNb25kYXktZmlyc3RcbiAgICAgICAgICAgIDogY29udmVydENvbnN0YW50KHJydWxlSW5wdXQud2tzdCksIGJ5d2Vla2RheTogY29udmVydENvbnN0YW50cyhycnVsZUlucHV0LmJ5d2Vla2RheSkgfSk7XG4gICAgcmV0dXJuIHsgcnJ1bGU6IG5ldyBycnVsZUxpYi5SUnVsZShycnVsZU9wdGlvbnMpLCBpc1RpbWVTcGVjaWZpZWQsIGlzVGltZVpvbmVTcGVjaWZpZWQgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlUlJ1bGVTdHJpbmcoc3RyKSB7XG4gICAgbGV0IHJydWxlU2V0ID0gcnJ1bGVMaWIucnJ1bGVzdHIoc3RyLCB7IGZvcmNlc2V0OiB0cnVlIH0pO1xuICAgIGxldCBhbmFseXNpcyA9IGFuYWx5emVSUnVsZVN0cmluZyhzdHIpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgcnJ1bGVTZXQgfSwgYW5hbHlzaXMpO1xufVxuZnVuY3Rpb24gYW5hbHl6ZVJSdWxlU3RyaW5nKHN0cikge1xuICAgIGxldCBpc1RpbWVTcGVjaWZpZWQgPSBmYWxzZTtcbiAgICBsZXQgaXNUaW1lWm9uZVNwZWNpZmllZCA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIHByb2Nlc3NNYXRjaCh3aG9sZSwgaW50cm9QYXJ0LCBkYXRlUGFydCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gcGFyc2VNYXJrZXIoZGF0ZVBhcnQpO1xuICAgICAgICBpc1RpbWVTcGVjaWZpZWQgPSBpc1RpbWVTcGVjaWZpZWQgfHwgIXJlc3VsdC5pc1RpbWVVbnNwZWNpZmllZDtcbiAgICAgICAgaXNUaW1lWm9uZVNwZWNpZmllZCA9IGlzVGltZVpvbmVTcGVjaWZpZWQgfHwgcmVzdWx0LnRpbWVab25lT2Zmc2V0ICE9PSBudWxsO1xuICAgIH1cbiAgICBzdHIucmVwbGFjZSgvXFxiKERUU1RBUlQ6KShbXlxcbl0qKS8sIHByb2Nlc3NNYXRjaCk7XG4gICAgc3RyLnJlcGxhY2UoL1xcYihFWERBVEU6KShbXlxcbl0qKS8sIHByb2Nlc3NNYXRjaCk7XG4gICAgc3RyLnJlcGxhY2UoL1xcYihVTlRJTD0pKFteO1xcbl0qKS8sIHByb2Nlc3NNYXRjaCk7XG4gICAgcmV0dXJuIHsgaXNUaW1lU3BlY2lmaWVkLCBpc1RpbWVab25lU3BlY2lmaWVkIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0Q29uc3RhbnRzKGlucHV0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBpbnB1dC5tYXAoY29udmVydENvbnN0YW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnZlcnRDb25zdGFudChpbnB1dCk7XG59XG5mdW5jdGlvbiBjb252ZXJ0Q29uc3RhbnQoaW5wdXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gcnJ1bGVMaWIuUlJ1bGVbaW5wdXQudG9VcHBlckNhc2UoKV07XG4gICAgfVxuICAgIHJldHVybiBpbnB1dDtcbn1cblxuY29uc3QgUlJVTEVfRVZFTlRfUkVGSU5FUlMgPSB7XG4gICAgcnJ1bGU6IGlkZW50aXR5LFxuICAgIGV4cnVsZTogaWRlbnRpdHksXG4gICAgZXhkYXRlOiBpZGVudGl0eSxcbiAgICBkdXJhdGlvbjogY3JlYXRlRHVyYXRpb24sXG59O1xuXG52YXIgaW5kZXggPSBjcmVhdGVQbHVnaW4oe1xuICAgIG5hbWU6ICdAZnVsbGNhbGVuZGFyL3JydWxlJyxcbiAgICByZWN1cnJpbmdUeXBlczogW3JlY3VycmluZ1R5cGVdLFxuICAgIGV2ZW50UmVmaW5lcnM6IFJSVUxFX0VWRU5UX1JFRklORVJTLFxufSk7XG5cbmV4cG9ydCB7IGluZGV4IGFzIGRlZmF1bHQgfTtcbiIsICJpbXBvcnQgeyBCYXNlQ29tcG9uZW50LCBnZXRVbmlxdWVEb21JZCwgZ2V0RGF0ZU1ldGEsIGJ1aWxkTmF2TGlua0F0dHJzLCBDb250ZW50Q29udGFpbmVyLCBnZXREYXlDbGFzc05hbWVzLCBmb3JtYXREYXlTdHJpbmcsIGNyZWF0ZUZvcm1hdHRlciwgRXZlbnRDb250YWluZXIsIGdldFNlZ0FuY2hvckF0dHJzLCBpc011bHRpRGF5UmFuZ2UsIGJ1aWxkU2VnVGltZVRleHQsIERhdGVDb21wb25lbnQsIG1lbW9pemUsIFZpZXdDb250YWluZXIsIFNjcm9sbGVyLCBOb3dUaW1lciwgc29ydEV2ZW50U2VncywgZ2V0U2VnTWV0YSwgc2xpY2VFdmVudFN0b3JlLCBpbnRlcnNlY3RSYW5nZXMsIHN0YXJ0T2ZEYXksIGFkZERheXMsIGluamVjdFN0eWxlcyB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29yZS9pbnRlcm5hbC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVFbGVtZW50LCBGcmFnbWVudCB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29yZS9wcmVhY3QuanMnO1xuXG5jbGFzcyBMaXN0Vmlld0hlYWRlclJvdyBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgdGV4dElkOiBnZXRVbmlxdWVEb21JZCgpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHRoZW1lLCBkYXRlRW52LCBvcHRpb25zLCB2aWV3QXBpIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCB7IGNlbGxJZCwgZGF5RGF0ZSwgdG9kYXlSYW5nZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IHsgdGV4dElkIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBsZXQgZGF5TWV0YSA9IGdldERhdGVNZXRhKGRheURhdGUsIHRvZGF5UmFuZ2UpO1xuICAgICAgICAvLyB3aWxsIGV2ZXIgYmUgZmFsc3k/XG4gICAgICAgIGxldCB0ZXh0ID0gb3B0aW9ucy5saXN0RGF5Rm9ybWF0ID8gZGF0ZUVudi5mb3JtYXQoZGF5RGF0ZSwgb3B0aW9ucy5saXN0RGF5Rm9ybWF0KSA6ICcnO1xuICAgICAgICAvLyB3aWxsIGV2ZXIgYmUgZmFsc3k/IGFsc28sIEJBRCBOQU1FIFwiYWx0XCJcbiAgICAgICAgbGV0IHNpZGVUZXh0ID0gb3B0aW9ucy5saXN0RGF5U2lkZUZvcm1hdCA/IGRhdGVFbnYuZm9ybWF0KGRheURhdGUsIG9wdGlvbnMubGlzdERheVNpZGVGb3JtYXQpIDogJyc7XG4gICAgICAgIGxldCByZW5kZXJQcm9wcyA9IE9iamVjdC5hc3NpZ24oeyBkYXRlOiBkYXRlRW52LnRvRGF0ZShkYXlEYXRlKSwgdmlldzogdmlld0FwaSwgdGV4dElkLFxuICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgIHNpZGVUZXh0LCBuYXZMaW5rQXR0cnM6IGJ1aWxkTmF2TGlua0F0dHJzKHRoaXMuY29udGV4dCwgZGF5RGF0ZSksIHNpZGVOYXZMaW5rQXR0cnM6IGJ1aWxkTmF2TGlua0F0dHJzKHRoaXMuY29udGV4dCwgZGF5RGF0ZSwgJ2RheScsIGZhbHNlKSB9LCBkYXlNZXRhKTtcbiAgICAgICAgLy8gVE9ETzogbWFrZSBhIHJldXNhYmxlIEhPQyBmb3IgZGF5SGVhZGVyICh1c2VkIGluIGRheWdyaWQvdGltZWdyaWQgdG9vKVxuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoQ29udGVudENvbnRhaW5lciwgeyBlbFRhZzogXCJ0clwiLCBlbENsYXNzZXM6IFtcbiAgICAgICAgICAgICAgICAnZmMtbGlzdC1kYXknLFxuICAgICAgICAgICAgICAgIC4uLmdldERheUNsYXNzTmFtZXMoZGF5TWV0YSwgdGhlbWUpLFxuICAgICAgICAgICAgXSwgZWxBdHRyczoge1xuICAgICAgICAgICAgICAgICdkYXRhLWRhdGUnOiBmb3JtYXREYXlTdHJpbmcoZGF5RGF0ZSksXG4gICAgICAgICAgICB9LCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGdlbmVyYXRvck5hbWU6IFwiZGF5SGVhZGVyQ29udGVudFwiLCBjdXN0b21HZW5lcmF0b3I6IG9wdGlvbnMuZGF5SGVhZGVyQ29udGVudCwgZGVmYXVsdEdlbmVyYXRvcjogcmVuZGVySW5uZXJDb250ZW50LCBjbGFzc05hbWVHZW5lcmF0b3I6IG9wdGlvbnMuZGF5SGVhZGVyQ2xhc3NOYW1lcywgZGlkTW91bnQ6IG9wdGlvbnMuZGF5SGVhZGVyRGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLmRheUhlYWRlcldpbGxVbm1vdW50IH0sIChJbm5lckNvbnRlbnQpID0+ICggLy8gVE9ETzogZm9yY2UtaGlkZSB0b3AgYm9yZGVyIGJhc2VkIG9uIDpmaXJzdC1jaGlsZFxuICAgICAgICBjcmVhdGVFbGVtZW50KFwidGhcIiwgeyBzY29wZTogXCJjb2xncm91cFwiLCBjb2xTcGFuOiAzLCBpZDogY2VsbElkLCBcImFyaWEtbGFiZWxsZWRieVwiOiB0ZXh0SWQgfSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoSW5uZXJDb250ZW50LCB7IGVsVGFnOiBcImRpdlwiLCBlbENsYXNzZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2ZjLWxpc3QtZGF5LWN1c2hpb24nLFxuICAgICAgICAgICAgICAgICAgICB0aGVtZS5nZXRDbGFzcygndGFibGVDZWxsU2hhZGVkJyksXG4gICAgICAgICAgICAgICAgXSB9KSkpKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVuZGVySW5uZXJDb250ZW50KHByb3BzKSB7XG4gICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLFxuICAgICAgICBwcm9wcy50ZXh0ICYmIChjcmVhdGVFbGVtZW50KFwiYVwiLCBPYmplY3QuYXNzaWduKHsgaWQ6IHByb3BzLnRleHRJZCwgY2xhc3NOYW1lOiBcImZjLWxpc3QtZGF5LXRleHRcIiB9LCBwcm9wcy5uYXZMaW5rQXR0cnMpLCBwcm9wcy50ZXh0KSksXG4gICAgICAgIHByb3BzLnNpZGVUZXh0ICYmICggLyogbm90IGtleWJvYXJkIHRhYmJhYmxlICovY3JlYXRlRWxlbWVudChcImFcIiwgT2JqZWN0LmFzc2lnbih7IFwiYXJpYS1oaWRkZW5cIjogdHJ1ZSwgY2xhc3NOYW1lOiBcImZjLWxpc3QtZGF5LXNpZGUtdGV4dFwiIH0sIHByb3BzLnNpZGVOYXZMaW5rQXR0cnMpLCBwcm9wcy5zaWRlVGV4dCkpKSk7XG59XG5cbmNvbnN0IERFRkFVTFRfVElNRV9GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoe1xuICAgIGhvdXI6ICdudW1lcmljJyxcbiAgICBtaW51dGU6ICcyLWRpZ2l0JyxcbiAgICBtZXJpZGllbTogJ3Nob3J0Jyxcbn0pO1xuY2xhc3MgTGlzdFZpZXdFdmVudFJvdyBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgICAgIGxldCB7IHNlZywgdGltZUhlYWRlcklkLCBldmVudEhlYWRlcklkLCBkYXRlSGVhZGVySWQgfSA9IHByb3BzO1xuICAgICAgICBsZXQgdGltZUZvcm1hdCA9IG9wdGlvbnMuZXZlbnRUaW1lRm9ybWF0IHx8IERFRkFVTFRfVElNRV9GT1JNQVQ7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChFdmVudENvbnRhaW5lciwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMsIHsgZWxUYWc6IFwidHJcIiwgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgJ2ZjLWxpc3QtZXZlbnQnLFxuICAgICAgICAgICAgICAgIHNlZy5ldmVudFJhbmdlLmRlZi51cmwgJiYgJ2ZjLWV2ZW50LWZvcmNlZC11cmwnLFxuICAgICAgICAgICAgXSwgZGVmYXVsdEdlbmVyYXRvcjogKCkgPT4gcmVuZGVyRXZlbnRJbm5lckNvbnRlbnQoc2VnLCBjb250ZXh0KSAvKiB3ZWlyZCAqLywgc2VnOiBzZWcsIHRpbWVUZXh0OiBcIlwiLCBkaXNhYmxlRHJhZ2dpbmc6IHRydWUsIGRpc2FibGVSZXNpemluZzogdHJ1ZSB9KSwgKElubmVyQ29udGVudCwgZXZlbnRDb250ZW50QXJnKSA9PiAoY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCxcbiAgICAgICAgICAgIGJ1aWxkVGltZUNvbnRlbnQoc2VnLCB0aW1lRm9ybWF0LCBjb250ZXh0LCB0aW1lSGVhZGVySWQsIGRhdGVIZWFkZXJJZCksXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwidGRcIiwgeyBcImFyaWEtaGlkZGVuXCI6IHRydWUsIGNsYXNzTmFtZTogXCJmYy1saXN0LWV2ZW50LWdyYXBoaWNcIiB9LFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcImZjLWxpc3QtZXZlbnQtZG90XCIsIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogZXZlbnRDb250ZW50QXJnLmJvcmRlckNvbG9yIHx8IGV2ZW50Q29udGVudEFyZy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIH0gfSkpLFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChJbm5lckNvbnRlbnQsIHsgZWxUYWc6IFwidGRcIiwgZWxDbGFzc2VzOiBbJ2ZjLWxpc3QtZXZlbnQtdGl0bGUnXSwgZWxBdHRyczogeyBoZWFkZXJzOiBgJHtldmVudEhlYWRlcklkfSAke2RhdGVIZWFkZXJJZH1gIH0gfSkpKSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbmRlckV2ZW50SW5uZXJDb250ZW50KHNlZywgY29udGV4dCkge1xuICAgIGxldCBpbnRlcmFjdGl2ZUF0dHJzID0gZ2V0U2VnQW5jaG9yQXR0cnMoc2VnLCBjb250ZXh0KTtcbiAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJhXCIsIE9iamVjdC5hc3NpZ24oe30sIGludGVyYWN0aXZlQXR0cnMpLCBzZWcuZXZlbnRSYW5nZS5kZWYudGl0bGUpKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkVGltZUNvbnRlbnQoc2VnLCB0aW1lRm9ybWF0LCBjb250ZXh0LCB0aW1lSGVhZGVySWQsIGRhdGVIZWFkZXJJZCkge1xuICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgaWYgKG9wdGlvbnMuZGlzcGxheUV2ZW50VGltZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGV2ZW50RGVmID0gc2VnLmV2ZW50UmFuZ2UuZGVmO1xuICAgICAgICBsZXQgZXZlbnRJbnN0YW5jZSA9IHNlZy5ldmVudFJhbmdlLmluc3RhbmNlO1xuICAgICAgICBsZXQgZG9BbGxEYXkgPSBmYWxzZTtcbiAgICAgICAgbGV0IHRpbWVUZXh0O1xuICAgICAgICBpZiAoZXZlbnREZWYuYWxsRGF5KSB7XG4gICAgICAgICAgICBkb0FsbERheSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNNdWx0aURheVJhbmdlKHNlZy5ldmVudFJhbmdlLnJhbmdlKSkgeyAvLyBUT0RPOiB1c2UgKCFpc1N0YXJ0IHx8ICFpc0VuZCkgaW5zdGVhZD9cbiAgICAgICAgICAgIGlmIChzZWcuaXNTdGFydCkge1xuICAgICAgICAgICAgICAgIHRpbWVUZXh0ID0gYnVpbGRTZWdUaW1lVGV4dChzZWcsIHRpbWVGb3JtYXQsIGNvbnRleHQsIG51bGwsIG51bGwsIGV2ZW50SW5zdGFuY2UucmFuZ2Uuc3RhcnQsIHNlZy5lbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2VnLmlzRW5kKSB7XG4gICAgICAgICAgICAgICAgdGltZVRleHQgPSBidWlsZFNlZ1RpbWVUZXh0KHNlZywgdGltZUZvcm1hdCwgY29udGV4dCwgbnVsbCwgbnVsbCwgc2VnLnN0YXJ0LCBldmVudEluc3RhbmNlLnJhbmdlLmVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkb0FsbERheSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aW1lVGV4dCA9IGJ1aWxkU2VnVGltZVRleHQoc2VnLCB0aW1lRm9ybWF0LCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZG9BbGxEYXkpIHtcbiAgICAgICAgICAgIGxldCByZW5kZXJQcm9wcyA9IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBjb250ZXh0Lm9wdGlvbnMuYWxsRGF5VGV4dCxcbiAgICAgICAgICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KENvbnRlbnRDb250YWluZXIsIHsgZWxUYWc6IFwidGRcIiwgZWxDbGFzc2VzOiBbJ2ZjLWxpc3QtZXZlbnQtdGltZSddLCBlbEF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGAke3RpbWVIZWFkZXJJZH0gJHtkYXRlSGVhZGVySWR9YCxcbiAgICAgICAgICAgICAgICB9LCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGdlbmVyYXRvck5hbWU6IFwiYWxsRGF5Q29udGVudFwiLCBjdXN0b21HZW5lcmF0b3I6IG9wdGlvbnMuYWxsRGF5Q29udGVudCwgZGVmYXVsdEdlbmVyYXRvcjogcmVuZGVyQWxsRGF5SW5uZXIsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy5hbGxEYXlDbGFzc05hbWVzLCBkaWRNb3VudDogb3B0aW9ucy5hbGxEYXlEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMuYWxsRGF5V2lsbFVubW91bnQgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcInRkXCIsIHsgY2xhc3NOYW1lOiBcImZjLWxpc3QtZXZlbnQtdGltZVwiIH0sIHRpbWVUZXh0KSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcmVuZGVyQWxsRGF5SW5uZXIocmVuZGVyUHJvcHMpIHtcbiAgICByZXR1cm4gcmVuZGVyUHJvcHMudGV4dDtcbn1cblxuLypcblJlc3BvbnNpYmxlIGZvciB0aGUgc2Nyb2xsZXIsIGFuZCBmb3J3YXJkaW5nIGV2ZW50LXJlbGF0ZWQgYWN0aW9ucyBpbnRvIHRoZSBcImdyaWRcIi5cbiovXG5jbGFzcyBMaXN0VmlldyBleHRlbmRzIERhdGVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmNvbXB1dGVEYXRlVmFycyA9IG1lbW9pemUoY29tcHV0ZURhdGVWYXJzKTtcbiAgICAgICAgdGhpcy5ldmVudFN0b3JlVG9TZWdzID0gbWVtb2l6ZSh0aGlzLl9ldmVudFN0b3JlVG9TZWdzKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHRpbWVIZWFkZXJJZDogZ2V0VW5pcXVlRG9tSWQoKSxcbiAgICAgICAgICAgIGV2ZW50SGVhZGVySWQ6IGdldFVuaXF1ZURvbUlkKCksXG4gICAgICAgICAgICBkYXRlSGVhZGVySWRSb290OiBnZXRVbmlxdWVEb21JZCgpLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldFJvb3RFbCA9IChyb290RWwpID0+IHtcbiAgICAgICAgICAgIGlmIChyb290RWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCh0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgIGVsOiByb290RWwsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQudW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBkYXlEYXRlcywgZGF5UmFuZ2VzIH0gPSB0aGlzLmNvbXB1dGVEYXRlVmFycyhwcm9wcy5kYXRlUHJvZmlsZSk7XG4gICAgICAgIGxldCBldmVudFNlZ3MgPSB0aGlzLmV2ZW50U3RvcmVUb1NlZ3MocHJvcHMuZXZlbnRTdG9yZSwgcHJvcHMuZXZlbnRVaUJhc2VzLCBkYXlSYW5nZXMpO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVmlld0NvbnRhaW5lciwgeyBlbFJlZjogdGhpcy5zZXRSb290RWwsIGVsQ2xhc3NlczogW1xuICAgICAgICAgICAgICAgICdmYy1saXN0JyxcbiAgICAgICAgICAgICAgICBjb250ZXh0LnRoZW1lLmdldENsYXNzKCd0YWJsZScpLFxuICAgICAgICAgICAgICAgIGNvbnRleHQub3B0aW9ucy5zdGlja3lIZWFkZXJEYXRlcyAhPT0gZmFsc2UgP1xuICAgICAgICAgICAgICAgICAgICAnZmMtbGlzdC1zdGlja3knIDpcbiAgICAgICAgICAgICAgICAgICAgJycsXG4gICAgICAgICAgICBdLCB2aWV3U3BlYzogY29udGV4dC52aWV3U3BlYyB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChTY3JvbGxlciwgeyBsaXF1aWQ6ICFwcm9wcy5pc0hlaWdodEF1dG8sIG92ZXJmbG93WDogcHJvcHMuaXNIZWlnaHRBdXRvID8gJ3Zpc2libGUnIDogJ2hpZGRlbicsIG92ZXJmbG93WTogcHJvcHMuaXNIZWlnaHRBdXRvID8gJ3Zpc2libGUnIDogJ2F1dG8nIH0sIGV2ZW50U2Vncy5sZW5ndGggPiAwID9cbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclNlZ0xpc3QoZXZlbnRTZWdzLCBkYXlEYXRlcykgOlxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRW1wdHlNZXNzYWdlKCkpKSk7XG4gICAgfVxuICAgIHJlbmRlckVtcHR5TWVzc2FnZSgpIHtcbiAgICAgICAgbGV0IHsgb3B0aW9ucywgdmlld0FwaSB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgcmVuZGVyUHJvcHMgPSB7XG4gICAgICAgICAgICB0ZXh0OiBvcHRpb25zLm5vRXZlbnRzVGV4dCxcbiAgICAgICAgICAgIHZpZXc6IHZpZXdBcGksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChDb250ZW50Q29udGFpbmVyLCB7IGVsVGFnOiBcImRpdlwiLCBlbENsYXNzZXM6IFsnZmMtbGlzdC1lbXB0eSddLCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGdlbmVyYXRvck5hbWU6IFwibm9FdmVudHNDb250ZW50XCIsIGN1c3RvbUdlbmVyYXRvcjogb3B0aW9ucy5ub0V2ZW50c0NvbnRlbnQsIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlck5vRXZlbnRzSW5uZXIsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy5ub0V2ZW50c0NsYXNzTmFtZXMsIGRpZE1vdW50OiBvcHRpb25zLm5vRXZlbnRzRGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLm5vRXZlbnRzV2lsbFVubW91bnQgfSwgKElubmVyQ29udGVudCkgPT4gKGNyZWF0ZUVsZW1lbnQoSW5uZXJDb250ZW50LCB7IGVsVGFnOiBcImRpdlwiLCBlbENsYXNzZXM6IFsnZmMtbGlzdC1lbXB0eS1jdXNoaW9uJ10gfSkpKSk7XG4gICAgfVxuICAgIHJlbmRlclNlZ0xpc3QoYWxsU2VncywgZGF5RGF0ZXMpIHtcbiAgICAgICAgbGV0IHsgdGhlbWUsIG9wdGlvbnMgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHsgdGltZUhlYWRlcklkLCBldmVudEhlYWRlcklkLCBkYXRlSGVhZGVySWRSb290IH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBsZXQgc2Vnc0J5RGF5ID0gZ3JvdXBTZWdzQnlEYXkoYWxsU2Vncyk7IC8vIHNwYXJzZSBhcnJheVxuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoTm93VGltZXIsIHsgdW5pdDogXCJkYXlcIiB9LCAobm93RGF0ZSwgdG9kYXlSYW5nZSkgPT4ge1xuICAgICAgICAgICAgbGV0IGlubmVyTm9kZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGRheUluZGV4ID0gMDsgZGF5SW5kZXggPCBzZWdzQnlEYXkubGVuZ3RoOyBkYXlJbmRleCArPSAxKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRheVNlZ3MgPSBzZWdzQnlEYXlbZGF5SW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChkYXlTZWdzKSB7IC8vIHNwYXJzZSBhcnJheSwgc28gbWlnaHQgYmUgdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIGxldCBkYXlTdHIgPSBmb3JtYXREYXlTdHJpbmcoZGF5RGF0ZXNbZGF5SW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGVIZWFkZXJJZCA9IGRhdGVIZWFkZXJJZFJvb3QgKyAnLScgKyBkYXlTdHI7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFwcGVuZCBhIGRheSBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJOb2Rlcy5wdXNoKGNyZWF0ZUVsZW1lbnQoTGlzdFZpZXdIZWFkZXJSb3csIHsga2V5OiBkYXlTdHIsIGNlbGxJZDogZGF0ZUhlYWRlcklkLCBkYXlEYXRlOiBkYXlEYXRlc1tkYXlJbmRleF0sIHRvZGF5UmFuZ2U6IHRvZGF5UmFuZ2UgfSkpO1xuICAgICAgICAgICAgICAgICAgICBkYXlTZWdzID0gc29ydEV2ZW50U2VncyhkYXlTZWdzLCBvcHRpb25zLmV2ZW50T3JkZXIpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBzZWcgb2YgZGF5U2Vncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJOb2Rlcy5wdXNoKGNyZWF0ZUVsZW1lbnQoTGlzdFZpZXdFdmVudFJvdywgT2JqZWN0LmFzc2lnbih7IGtleTogZGF5U3RyICsgJzonICsgc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZCAvKiBhcmUgbXVsdGlwbGUgc2VncyBmb3IgYW4gaW5zdGFuY2VJZCAqLywgc2VnOiBzZWcsIGlzRHJhZ2dpbmc6IGZhbHNlLCBpc1Jlc2l6aW5nOiBmYWxzZSwgaXNEYXRlU2VsZWN0aW5nOiBmYWxzZSwgaXNTZWxlY3RlZDogZmFsc2UsIHRpbWVIZWFkZXJJZDogdGltZUhlYWRlcklkLCBldmVudEhlYWRlcklkOiBldmVudEhlYWRlcklkLCBkYXRlSGVhZGVySWQ6IGRhdGVIZWFkZXJJZCB9LCBnZXRTZWdNZXRhKHNlZywgdG9kYXlSYW5nZSwgbm93RGF0ZSkpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJ0YWJsZVwiLCB7IGNsYXNzTmFtZTogJ2ZjLWxpc3QtdGFibGUgJyArIHRoZW1lLmdldENsYXNzKCd0YWJsZScpIH0sXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRoZWFkXCIsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJ0clwiLCBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRoXCIsIHsgc2NvcGU6IFwiY29sXCIsIGlkOiB0aW1lSGVhZGVySWQgfSwgb3B0aW9ucy50aW1lSGludCksXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwidGhcIiwgeyBzY29wZTogXCJjb2xcIiwgXCJhcmlhLWhpZGRlblwiOiB0cnVlIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRoXCIsIHsgc2NvcGU6IFwiY29sXCIsIGlkOiBldmVudEhlYWRlcklkIH0sIG9wdGlvbnMuZXZlbnRIaW50KSkpLFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJ0Ym9keVwiLCBudWxsLCBpbm5lck5vZGVzKSkpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIF9ldmVudFN0b3JlVG9TZWdzKGV2ZW50U3RvcmUsIGV2ZW50VWlCYXNlcywgZGF5UmFuZ2VzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50UmFuZ2VzVG9TZWdzKHNsaWNlRXZlbnRTdG9yZShldmVudFN0b3JlLCBldmVudFVpQmFzZXMsIHRoaXMucHJvcHMuZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UsIHRoaXMuY29udGV4dC5vcHRpb25zLm5leHREYXlUaHJlc2hvbGQpLmZnLCBkYXlSYW5nZXMpO1xuICAgIH1cbiAgICBldmVudFJhbmdlc1RvU2VncyhldmVudFJhbmdlcywgZGF5UmFuZ2VzKSB7XG4gICAgICAgIGxldCBzZWdzID0gW107XG4gICAgICAgIGZvciAobGV0IGV2ZW50UmFuZ2Ugb2YgZXZlbnRSYW5nZXMpIHtcbiAgICAgICAgICAgIHNlZ3MucHVzaCguLi50aGlzLmV2ZW50UmFuZ2VUb1NlZ3MoZXZlbnRSYW5nZSwgZGF5UmFuZ2VzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlZ3M7XG4gICAgfVxuICAgIGV2ZW50UmFuZ2VUb1NlZ3MoZXZlbnRSYW5nZSwgZGF5UmFuZ2VzKSB7XG4gICAgICAgIGxldCB7IGRhdGVFbnYgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHsgbmV4dERheVRocmVzaG9sZCB9ID0gdGhpcy5jb250ZXh0Lm9wdGlvbnM7XG4gICAgICAgIGxldCByYW5nZSA9IGV2ZW50UmFuZ2UucmFuZ2U7XG4gICAgICAgIGxldCBhbGxEYXkgPSBldmVudFJhbmdlLmRlZi5hbGxEYXk7XG4gICAgICAgIGxldCBkYXlJbmRleDtcbiAgICAgICAgbGV0IHNlZ1JhbmdlO1xuICAgICAgICBsZXQgc2VnO1xuICAgICAgICBsZXQgc2VncyA9IFtdO1xuICAgICAgICBmb3IgKGRheUluZGV4ID0gMDsgZGF5SW5kZXggPCBkYXlSYW5nZXMubGVuZ3RoOyBkYXlJbmRleCArPSAxKSB7XG4gICAgICAgICAgICBzZWdSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhyYW5nZSwgZGF5UmFuZ2VzW2RheUluZGV4XSk7XG4gICAgICAgICAgICBpZiAoc2VnUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBzZWcgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudDogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRSYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHNlZ1JhbmdlLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IHNlZ1JhbmdlLmVuZCxcbiAgICAgICAgICAgICAgICAgICAgaXNTdGFydDogZXZlbnRSYW5nZS5pc1N0YXJ0ICYmIHNlZ1JhbmdlLnN0YXJ0LnZhbHVlT2YoKSA9PT0gcmFuZ2Uuc3RhcnQudmFsdWVPZigpLFxuICAgICAgICAgICAgICAgICAgICBpc0VuZDogZXZlbnRSYW5nZS5pc0VuZCAmJiBzZWdSYW5nZS5lbmQudmFsdWVPZigpID09PSByYW5nZS5lbmQudmFsdWVPZigpLFxuICAgICAgICAgICAgICAgICAgICBkYXlJbmRleCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHNlZ3MucHVzaChzZWcpO1xuICAgICAgICAgICAgICAgIC8vIGRldGVjdCB3aGVuIHJhbmdlIHdvbid0IGdvIGZ1bGx5IGludG8gdGhlIG5leHQgZGF5LFxuICAgICAgICAgICAgICAgIC8vIGFuZCBtdXRhdGUgdGhlIGxhdGVzdCBzZWcgdG8gdGhlIGJlIHRoZSBlbmQuXG4gICAgICAgICAgICAgICAgaWYgKCFzZWcuaXNFbmQgJiYgIWFsbERheSAmJlxuICAgICAgICAgICAgICAgICAgICBkYXlJbmRleCArIDEgPCBkYXlSYW5nZXMubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLmVuZCA8XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlRW52LmFkZChkYXlSYW5nZXNbZGF5SW5kZXggKyAxXS5zdGFydCwgbmV4dERheVRocmVzaG9sZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VnLmVuZCA9IHJhbmdlLmVuZDtcbiAgICAgICAgICAgICAgICAgICAgc2VnLmlzRW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWdzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbmRlck5vRXZlbnRzSW5uZXIocmVuZGVyUHJvcHMpIHtcbiAgICByZXR1cm4gcmVuZGVyUHJvcHMudGV4dDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVEYXRlVmFycyhkYXRlUHJvZmlsZSkge1xuICAgIGxldCBkYXlTdGFydCA9IHN0YXJ0T2ZEYXkoZGF0ZVByb2ZpbGUucmVuZGVyUmFuZ2Uuc3RhcnQpO1xuICAgIGxldCB2aWV3RW5kID0gZGF0ZVByb2ZpbGUucmVuZGVyUmFuZ2UuZW5kO1xuICAgIGxldCBkYXlEYXRlcyA9IFtdO1xuICAgIGxldCBkYXlSYW5nZXMgPSBbXTtcbiAgICB3aGlsZSAoZGF5U3RhcnQgPCB2aWV3RW5kKSB7XG4gICAgICAgIGRheURhdGVzLnB1c2goZGF5U3RhcnQpO1xuICAgICAgICBkYXlSYW5nZXMucHVzaCh7XG4gICAgICAgICAgICBzdGFydDogZGF5U3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGFkZERheXMoZGF5U3RhcnQsIDEpLFxuICAgICAgICB9KTtcbiAgICAgICAgZGF5U3RhcnQgPSBhZGREYXlzKGRheVN0YXJ0LCAxKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZGF5RGF0ZXMsIGRheVJhbmdlcyB9O1xufVxuLy8gUmV0dXJucyBhIHNwYXJzZSBhcnJheSBvZiBhcnJheXMsIHNlZ3MgZ3JvdXBlZCBieSB0aGVpciBkYXlJbmRleFxuZnVuY3Rpb24gZ3JvdXBTZWdzQnlEYXkoc2Vncykge1xuICAgIGxldCBzZWdzQnlEYXkgPSBbXTsgLy8gc3BhcnNlIGFycmF5XG4gICAgbGV0IGk7XG4gICAgbGV0IHNlZztcbiAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBzZWcgPSBzZWdzW2ldO1xuICAgICAgICAoc2Vnc0J5RGF5W3NlZy5kYXlJbmRleF0gfHwgKHNlZ3NCeURheVtzZWcuZGF5SW5kZXhdID0gW10pKVxuICAgICAgICAgICAgLnB1c2goc2VnKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlZ3NCeURheTtcbn1cblxudmFyIGNzc18yNDh6ID0gXCI6cm9vdHstLWZjLWxpc3QtZXZlbnQtZG90LXdpZHRoOjEwcHg7LS1mYy1saXN0LWV2ZW50LWhvdmVyLWJnLWNvbG9yOiNmNWY1ZjV9LmZjLXRoZW1lLXN0YW5kYXJkIC5mYy1saXN0e2JvcmRlcjoxcHggc29saWQgdmFyKC0tZmMtYm9yZGVyLWNvbG9yKX0uZmMgLmZjLWxpc3QtZW1wdHl7YWxpZ24taXRlbXM6Y2VudGVyO2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmMtbmV1dHJhbC1iZy1jb2xvcik7ZGlzcGxheTpmbGV4O2hlaWdodDoxMDAlO2p1c3RpZnktY29udGVudDpjZW50ZXJ9LmZjIC5mYy1saXN0LWVtcHR5LWN1c2hpb257bWFyZ2luOjVlbSAwfS5mYyAuZmMtbGlzdC10YWJsZXtib3JkZXItc3R5bGU6aGlkZGVuO3dpZHRoOjEwMCV9LmZjIC5mYy1saXN0LXRhYmxlIHRyPip7Ym9yZGVyLWxlZnQ6MDtib3JkZXItcmlnaHQ6MH0uZmMgLmZjLWxpc3Qtc3RpY2t5IC5mYy1saXN0LWRheT4qe2JhY2tncm91bmQ6dmFyKC0tZmMtcGFnZS1iZy1jb2xvcik7cG9zaXRpb246c3RpY2t5O3RvcDowfS5mYyAuZmMtbGlzdC10YWJsZSB0aGVhZHtsZWZ0Oi0xMDAwMHB4O3Bvc2l0aW9uOmFic29sdXRlfS5mYyAuZmMtbGlzdC10YWJsZSB0Ym9keT50cjpmaXJzdC1jaGlsZCB0aHtib3JkZXItdG9wOjB9LmZjIC5mYy1saXN0LXRhYmxlIHRoe3BhZGRpbmc6MH0uZmMgLmZjLWxpc3QtZGF5LWN1c2hpb24sLmZjIC5mYy1saXN0LXRhYmxlIHRke3BhZGRpbmc6OHB4IDE0cHh9LmZjIC5mYy1saXN0LWRheS1jdXNoaW9uOmFmdGVye2NsZWFyOmJvdGg7Y29udGVudDpcXFwiXFxcIjtkaXNwbGF5OnRhYmxlfS5mYy10aGVtZS1zdGFuZGFyZCAuZmMtbGlzdC1kYXktY3VzaGlvbntiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWZjLW5ldXRyYWwtYmctY29sb3IpfS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1saXN0LWRheS10ZXh0LC5mYy1kaXJlY3Rpb24tcnRsIC5mYy1saXN0LWRheS1zaWRlLXRleHR7ZmxvYXQ6bGVmdH0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtbGlzdC1kYXktc2lkZS10ZXh0LC5mYy1kaXJlY3Rpb24tcnRsIC5mYy1saXN0LWRheS10ZXh0e2Zsb2F0OnJpZ2h0fS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1saXN0LXRhYmxlIC5mYy1saXN0LWV2ZW50LWdyYXBoaWN7cGFkZGluZy1yaWdodDowfS5mYy1kaXJlY3Rpb24tcnRsIC5mYy1saXN0LXRhYmxlIC5mYy1saXN0LWV2ZW50LWdyYXBoaWN7cGFkZGluZy1sZWZ0OjB9LmZjIC5mYy1saXN0LWV2ZW50LmZjLWV2ZW50LWZvcmNlZC11cmx7Y3Vyc29yOnBvaW50ZXJ9LmZjIC5mYy1saXN0LWV2ZW50OmhvdmVyIHRke2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmMtbGlzdC1ldmVudC1ob3Zlci1iZy1jb2xvcil9LmZjIC5mYy1saXN0LWV2ZW50LWdyYXBoaWMsLmZjIC5mYy1saXN0LWV2ZW50LXRpbWV7d2hpdGUtc3BhY2U6bm93cmFwO3dpZHRoOjFweH0uZmMgLmZjLWxpc3QtZXZlbnQtZG90e2JvcmRlcjpjYWxjKHZhcigtLWZjLWxpc3QtZXZlbnQtZG90LXdpZHRoKS8yKSBzb2xpZCB2YXIoLS1mYy1ldmVudC1ib3JkZXItY29sb3IpO2JvcmRlci1yYWRpdXM6Y2FsYyh2YXIoLS1mYy1saXN0LWV2ZW50LWRvdC13aWR0aCkvMik7Ym94LXNpemluZzpjb250ZW50LWJveDtkaXNwbGF5OmlubGluZS1ibG9jaztoZWlnaHQ6MDt3aWR0aDowfS5mYyAuZmMtbGlzdC1ldmVudC10aXRsZSBhe2NvbG9yOmluaGVyaXQ7dGV4dC1kZWNvcmF0aW9uOm5vbmV9LmZjIC5mYy1saXN0LWV2ZW50LmZjLWV2ZW50LWZvcmNlZC11cmw6aG92ZXIgYXt0ZXh0LWRlY29yYXRpb246dW5kZXJsaW5lfVwiO1xuaW5qZWN0U3R5bGVzKGNzc18yNDh6KTtcblxuZXhwb3J0IHsgTGlzdFZpZXcgfTtcbiIsICJpbXBvcnQgeyBjcmVhdGVQbHVnaW4gfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvcmUvaW5kZXguanMnO1xuaW1wb3J0IHsgTGlzdFZpZXcgfSBmcm9tICcuL2ludGVybmFsLmpzJztcbmltcG9ydCB7IGlkZW50aXR5LCBjcmVhdGVGb3JtYXR0ZXIgfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvcmUvaW50ZXJuYWwuanMnO1xuaW1wb3J0ICdAZnVsbGNhbGVuZGFyL2NvcmUvcHJlYWN0LmpzJztcblxuY29uc3QgT1BUSU9OX1JFRklORVJTID0ge1xuICAgIGxpc3REYXlGb3JtYXQ6IGNyZWF0ZUZhbHNhYmxlRm9ybWF0dGVyLFxuICAgIGxpc3REYXlTaWRlRm9ybWF0OiBjcmVhdGVGYWxzYWJsZUZvcm1hdHRlcixcbiAgICBub0V2ZW50c0NsYXNzTmFtZXM6IGlkZW50aXR5LFxuICAgIG5vRXZlbnRzQ29udGVudDogaWRlbnRpdHksXG4gICAgbm9FdmVudHNEaWRNb3VudDogaWRlbnRpdHksXG4gICAgbm9FdmVudHNXaWxsVW5tb3VudDogaWRlbnRpdHksXG4gICAgLy8gbm9FdmVudHNUZXh0IGlzIGRlZmluZWQgaW4gYmFzZSBvcHRpb25zXG59O1xuZnVuY3Rpb24gY3JlYXRlRmFsc2FibGVGb3JtYXR0ZXIoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQgPT09IGZhbHNlID8gbnVsbCA6IGNyZWF0ZUZvcm1hdHRlcihpbnB1dCk7XG59XG5cbnZhciBpbmRleCA9IGNyZWF0ZVBsdWdpbih7XG4gICAgbmFtZTogJ0BmdWxsY2FsZW5kYXIvbGlzdCcsXG4gICAgb3B0aW9uUmVmaW5lcnM6IE9QVElPTl9SRUZJTkVSUyxcbiAgICB2aWV3czoge1xuICAgICAgICBsaXN0OiB7XG4gICAgICAgICAgICBjb21wb25lbnQ6IExpc3RWaWV3LFxuICAgICAgICAgICAgYnV0dG9uVGV4dEtleTogJ2xpc3QnLFxuICAgICAgICAgICAgbGlzdERheUZvcm1hdDogeyBtb250aDogJ2xvbmcnLCBkYXk6ICdudW1lcmljJywgeWVhcjogJ251bWVyaWMnIH0sIC8vIGxpa2UgXCJKYW51YXJ5IDEsIDIwMTZcIlxuICAgICAgICB9LFxuICAgICAgICBsaXN0RGF5OiB7XG4gICAgICAgICAgICB0eXBlOiAnbGlzdCcsXG4gICAgICAgICAgICBkdXJhdGlvbjogeyBkYXlzOiAxIH0sXG4gICAgICAgICAgICBsaXN0RGF5Rm9ybWF0OiB7IHdlZWtkYXk6ICdsb25nJyB9LCAvLyBkYXktb2Ytd2VlayBpcyBhbGwgd2UgbmVlZC4gZnVsbCBkYXRlIGlzIHByb2JhYmx5IGluIGhlYWRlclRvb2xiYXJcbiAgICAgICAgfSxcbiAgICAgICAgbGlzdFdlZWs6IHtcbiAgICAgICAgICAgIHR5cGU6ICdsaXN0JyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB7IHdlZWtzOiAxIH0sXG4gICAgICAgICAgICBsaXN0RGF5Rm9ybWF0OiB7IHdlZWtkYXk6ICdsb25nJyB9LFxuICAgICAgICAgICAgbGlzdERheVNpZGVGb3JtYXQ6IHsgbW9udGg6ICdsb25nJywgZGF5OiAnbnVtZXJpYycsIHllYXI6ICdudW1lcmljJyB9LFxuICAgICAgICB9LFxuICAgICAgICBsaXN0TW9udGg6IHtcbiAgICAgICAgICAgIHR5cGU6ICdsaXN0JyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB7IG1vbnRoOiAxIH0sXG4gICAgICAgICAgICBsaXN0RGF5U2lkZUZvcm1hdDogeyB3ZWVrZGF5OiAnbG9uZycgfSwgLy8gZGF5LW9mLXdlZWsgaXMgbmljZS10by1oYXZlXG4gICAgICAgIH0sXG4gICAgICAgIGxpc3RZZWFyOiB7XG4gICAgICAgICAgICB0eXBlOiAnbGlzdCcsXG4gICAgICAgICAgICBkdXJhdGlvbjogeyB5ZWFyOiAxIH0sXG4gICAgICAgICAgICBsaXN0RGF5U2lkZUZvcm1hdDogeyB3ZWVrZGF5OiAnbG9uZycgfSwgLy8gZGF5LW9mLXdlZWsgaXMgbmljZS10by1oYXZlXG4gICAgICAgIH0sXG4gICAgfSxcbn0pO1xuXG5leHBvcnQgeyBpbmRleCBhcyBkZWZhdWx0IH07XG4iLCAiaW1wb3J0IHsgY3JlYXRlUGx1Z2luIH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb3JlL2luZGV4LmpzJztcbmltcG9ydCB7IGNvbmZpZywgRW1pdHRlciwgZWxlbWVudENsb3Nlc3QsIGFwcGx5U3R5bGUsIHdoZW5UcmFuc2l0aW9uRG9uZSwgcmVtb3ZlRWxlbWVudCwgU2Nyb2xsQ29udHJvbGxlciwgRWxlbWVudFNjcm9sbENvbnRyb2xsZXIsIGNvbXB1dGVJbm5lclJlY3QsIFdpbmRvd1Njcm9sbENvbnRyb2xsZXIsIEVsZW1lbnREcmFnZ2luZywgcHJldmVudFNlbGVjdGlvbiwgcHJldmVudENvbnRleHRNZW51LCBhbGxvd1NlbGVjdGlvbiwgYWxsb3dDb250ZXh0TWVudSwgY29tcHV0ZVJlY3QsIGdldENsaXBwaW5nUGFyZW50cywgcG9pbnRJbnNpZGVSZWN0LCBjb25zdHJhaW5Qb2ludCwgaW50ZXJzZWN0UmVjdHMsIGdldFJlY3RDZW50ZXIsIGRpZmZQb2ludHMsIG1hcEhhc2gsIHJhbmdlQ29udGFpbnNSYW5nZSwgaXNEYXRlU3BhbnNFcXVhbCwgSW50ZXJhY3Rpb24sIGludGVyYWN0aW9uU2V0dGluZ3NUb1N0b3JlLCBpc0RhdGVTZWxlY3Rpb25WYWxpZCwgZW5hYmxlQ3Vyc29yLCBkaXNhYmxlQ3Vyc29yLCB0cmlnZ2VyRGF0ZVNlbGVjdCwgY29tcGFyZU51bWJlcnMsIGdldEVsU2VnLCBnZXRSZWxldmFudEV2ZW50cywgRXZlbnRJbXBsLCBjcmVhdGVFbXB0eUV2ZW50U3RvcmUsIGFwcGx5TXV0YXRpb25Ub0V2ZW50U3RvcmUsIGlzSW50ZXJhY3Rpb25WYWxpZCwgYnVpbGRFdmVudEFwaXMsIGludGVyYWN0aW9uU2V0dGluZ3NTdG9yZSwgc3RhcnRPZkRheSwgZGlmZkRhdGVzLCBjcmVhdGVEdXJhdGlvbiwgZ2V0RXZlbnRUYXJnZXRWaWFSb290LCBpZGVudGl0eSwgZXZlbnRUdXBsZVRvU3RvcmUsIHBhcnNlRHJhZ01ldGEsIGVsZW1lbnRNYXRjaGVzLCByZWZpbmVFdmVudERlZiwgcGFyc2VFdmVudERlZiwgZ2V0RGVmYXVsdEV2ZW50RW5kLCBjcmVhdGVFdmVudEluc3RhbmNlLCBCQVNFX09QVElPTl9ERUZBVUxUUyB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29yZS9pbnRlcm5hbC5qcyc7XG5cbmNvbmZpZy50b3VjaE1vdXNlSWdub3JlV2FpdCA9IDUwMDtcbmxldCBpZ25vcmVNb3VzZURlcHRoID0gMDtcbmxldCBsaXN0ZW5lckNudCA9IDA7XG5sZXQgaXNXaW5kb3dUb3VjaE1vdmVDYW5jZWxsZWQgPSBmYWxzZTtcbi8qXG5Vc2VzIGEgXCJwb2ludGVyXCIgYWJzdHJhY3Rpb24sIHdoaWNoIG1vbml0b3JzIFVJIGV2ZW50cyBmb3IgYm90aCBtb3VzZSBhbmQgdG91Y2guXG5UcmFja3Mgd2hlbiB0aGUgcG9pbnRlciBcImRyYWdzXCIgb24gYSBjZXJ0YWluIGVsZW1lbnQsIG1lYW5pbmcgZG93bittb3ZlK3VwLlxuXG5BbHNvLCB0cmFja3MgaWYgdGhlcmUgd2FzIHRvdWNoLXNjcm9sbGluZy5cbkFsc28sIGNhbiBwcmV2ZW50IHRvdWNoLXNjcm9sbGluZyBmcm9tIGhhcHBlbmluZy5cbkFsc28sIGNhbiBmaXJlIHBvaW50ZXJtb3ZlIGV2ZW50cyB3aGVuIHNjcm9sbGluZyBoYXBwZW5zIHVuZGVybmVhdGgsIGV2ZW4gd2hlbiBubyByZWFsIHBvaW50ZXIgbW92ZW1lbnQuXG5cbmVtaXRzOlxuLSBwb2ludGVyZG93blxuLSBwb2ludGVybW92ZVxuLSBwb2ludGVydXBcbiovXG5jbGFzcyBQb2ludGVyRHJhZ2dpbmcge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lckVsKSB7XG4gICAgICAgIHRoaXMuc3ViamVjdEVsID0gbnVsbDtcbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IGNhbiBiZSBkaXJlY3RseSBhc3NpZ25lZCBieSBjYWxsZXJcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9ICcnOyAvLyB3aWxsIGNhdXNlIHN1YmplY3RFbCBpbiBhbGwgZW1pdHRlZCBldmVudHMgdG8gYmUgdGhpcyBlbGVtZW50XG4gICAgICAgIHRoaXMuaGFuZGxlU2VsZWN0b3IgPSAnJztcbiAgICAgICAgdGhpcy5zaG91bGRJZ25vcmVNb3ZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2hvdWxkV2F0Y2hTY3JvbGwgPSB0cnVlOyAvLyBmb3Igc2ltdWxhdGluZyBwb2ludGVybW92ZSBvbiBzY3JvbGxcbiAgICAgICAgLy8gaW50ZXJuYWwgc3RhdGVzXG4gICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzVG91Y2hEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLndhc1RvdWNoU2Nyb2xsID0gZmFsc2U7XG4gICAgICAgIC8vIE1vdXNlXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgdGhpcy5oYW5kbGVNb3VzZURvd24gPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zaG91bGRJZ25vcmVNb3VzZSgpICYmXG4gICAgICAgICAgICAgICAgaXNQcmltYXJ5TW91c2VCdXR0b24oZXYpICYmXG4gICAgICAgICAgICAgICAgdGhpcy50cnlTdGFydChldikpIHtcbiAgICAgICAgICAgICAgICBsZXQgcGV2ID0gdGhpcy5jcmVhdGVFdmVudEZyb21Nb3VzZShldiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJkb3duJywgcGV2KTtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRTY3JvbGxXYXRjaChwZXYpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zaG91bGRJZ25vcmVNb3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuaGFuZGxlTW91c2VNb3ZlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuaGFuZGxlTW91c2VVcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlTW91c2VNb3ZlID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBsZXQgcGV2ID0gdGhpcy5jcmVhdGVFdmVudEZyb21Nb3VzZShldik7XG4gICAgICAgICAgICB0aGlzLnJlY29yZENvb3JkcyhwZXYpO1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJtb3ZlJywgcGV2KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVNb3VzZVVwID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLmhhbmRsZU1vdXNlTW92ZSk7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVydXAnLCB0aGlzLmNyZWF0ZUV2ZW50RnJvbU1vdXNlKGV2KSk7XG4gICAgICAgICAgICB0aGlzLmNsZWFudXAoKTsgLy8gY2FsbCBsYXN0IHNvIHRoYXQgcG9pbnRlcnVwIGhhcyBhY2Nlc3MgdG8gcHJvcHNcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVG91Y2hcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICB0aGlzLmhhbmRsZVRvdWNoU3RhcnQgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRyeVN0YXJ0KGV2KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNUb3VjaERyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBsZXQgcGV2ID0gdGhpcy5jcmVhdGVFdmVudEZyb21Ub3VjaChldiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJkb3duJywgcGV2KTtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRTY3JvbGxXYXRjaChwZXYpO1xuICAgICAgICAgICAgICAgIC8vIHVubGlrZSBtb3VzZSwgbmVlZCB0byBhdHRhY2ggdG8gdGFyZ2V0LCBub3QgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDU3NjAwMTRcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0RWwgPSBldi50YXJnZXQ7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNob3VsZElnbm9yZU1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5oYW5kbGVUb3VjaE1vdmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0YXJnZXRFbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuaGFuZGxlVG91Y2hFbmQpO1xuICAgICAgICAgICAgICAgIHRhcmdldEVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpcy5oYW5kbGVUb3VjaEVuZCk7IC8vIHRyZWF0IGl0IGFzIGEgdG91Y2ggZW5kXG4gICAgICAgICAgICAgICAgLy8gYXR0YWNoIGEgaGFuZGxlciB0byBnZXQgY2FsbGVkIHdoZW4gQU5ZIHNjcm9sbCBhY3Rpb24gaGFwcGVucyBvbiB0aGUgcGFnZS5cbiAgICAgICAgICAgICAgICAvLyB0aGlzIHdhcyBpbXBvc3NpYmxlIHRvIGRvIHdpdGggbm9ybWFsIG9uL29mZiBiZWNhdXNlICdzY3JvbGwnIGRvZXNuJ3QgYnViYmxlLlxuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzMyOTU0NTY1Lzk2MzQyXG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuaGFuZGxlVG91Y2hTY3JvbGwsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVRvdWNoTW92ZSA9IChldikgPT4ge1xuICAgICAgICAgICAgbGV0IHBldiA9IHRoaXMuY3JlYXRlRXZlbnRGcm9tVG91Y2goZXYpO1xuICAgICAgICAgICAgdGhpcy5yZWNvcmRDb29yZHMocGV2KTtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVybW92ZScsIHBldik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlVG91Y2hFbmQgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcpIHsgLy8gZG9uZSB0byBndWFyZCBhZ2FpbnN0IHRvdWNoZW5kIGZvbGxvd2VkIGJ5IHRvdWNoY2FuY2VsXG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldEVsID0gZXYudGFyZ2V0O1xuICAgICAgICAgICAgICAgIHRhcmdldEVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuaGFuZGxlVG91Y2hNb3ZlKTtcbiAgICAgICAgICAgICAgICB0YXJnZXRFbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuaGFuZGxlVG91Y2hFbmQpO1xuICAgICAgICAgICAgICAgIHRhcmdldEVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpcy5oYW5kbGVUb3VjaEVuZCk7XG4gICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuaGFuZGxlVG91Y2hTY3JvbGwsIHRydWUpOyAvLyB1c2VDYXB0dXJlZD10cnVlXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJ1cCcsIHRoaXMuY3JlYXRlRXZlbnRGcm9tVG91Y2goZXYpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFudXAoKTsgLy8gY2FsbCBsYXN0IHNvIHRoYXQgcG9pbnRlcnVwIGhhcyBhY2Nlc3MgdG8gcHJvcHNcbiAgICAgICAgICAgICAgICB0aGlzLmlzVG91Y2hEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHN0YXJ0SWdub3JpbmdNb3VzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVRvdWNoU2Nyb2xsID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy53YXNUb3VjaFNjcm9sbCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlU2Nyb2xsID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2hvdWxkSWdub3JlTW92ZSkge1xuICAgICAgICAgICAgICAgIGxldCBwYWdlWCA9ICh3aW5kb3cuc2Nyb2xsWCAtIHRoaXMucHJldlNjcm9sbFgpICsgdGhpcy5wcmV2UGFnZVg7XG4gICAgICAgICAgICAgICAgbGV0IHBhZ2VZID0gKHdpbmRvdy5zY3JvbGxZIC0gdGhpcy5wcmV2U2Nyb2xsWSkgKyB0aGlzLnByZXZQYWdlWTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcm1vdmUnLCB7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdFdmVudDogZXYsXG4gICAgICAgICAgICAgICAgICAgIGlzVG91Y2g6IHRoaXMuaXNUb3VjaERyYWdnaW5nLFxuICAgICAgICAgICAgICAgICAgICBzdWJqZWN0RWw6IHRoaXMuc3ViamVjdEVsLFxuICAgICAgICAgICAgICAgICAgICBwYWdlWCxcbiAgICAgICAgICAgICAgICAgICAgcGFnZVksXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhWDogcGFnZVggLSB0aGlzLm9yaWdQYWdlWCxcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFZOiBwYWdlWSAtIHRoaXMub3JpZ1BhZ2VZLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNvbnRhaW5lckVsID0gY29udGFpbmVyRWw7XG4gICAgICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XG4gICAgICAgIGNvbnRhaW5lckVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlTW91c2VEb3duKTtcbiAgICAgICAgY29udGFpbmVyRWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuaGFuZGxlVG91Y2hTdGFydCwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICBsaXN0ZW5lckNyZWF0ZWQoKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXJFbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZU1vdXNlRG93bik7XG4gICAgICAgIHRoaXMuY29udGFpbmVyRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuaGFuZGxlVG91Y2hTdGFydCwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICBsaXN0ZW5lckRlc3Ryb3llZCgpO1xuICAgIH1cbiAgICB0cnlTdGFydChldikge1xuICAgICAgICBsZXQgc3ViamVjdEVsID0gdGhpcy5xdWVyeVN1YmplY3RFbChldik7XG4gICAgICAgIGxldCBkb3duRWwgPSBldi50YXJnZXQ7XG4gICAgICAgIGlmIChzdWJqZWN0RWwgJiZcbiAgICAgICAgICAgICghdGhpcy5oYW5kbGVTZWxlY3RvciB8fCBlbGVtZW50Q2xvc2VzdChkb3duRWwsIHRoaXMuaGFuZGxlU2VsZWN0b3IpKSkge1xuICAgICAgICAgICAgdGhpcy5zdWJqZWN0RWwgPSBzdWJqZWN0RWw7XG4gICAgICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSB0cnVlOyAvLyBkbyB0aGlzIGZpcnN0IHNvIGNhbmNlbFRvdWNoU2Nyb2xsIHdpbGwgd29ya1xuICAgICAgICAgICAgdGhpcy53YXNUb3VjaFNjcm9sbCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjbGVhbnVwKCkge1xuICAgICAgICBpc1dpbmRvd1RvdWNoTW92ZUNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdWJqZWN0RWwgPSBudWxsO1xuICAgICAgICAvLyBrZWVwIHdhc1RvdWNoU2Nyb2xsIGFyb3VuZCBmb3IgbGF0ZXIgYWNjZXNzXG4gICAgICAgIHRoaXMuZGVzdHJveVNjcm9sbFdhdGNoKCk7XG4gICAgfVxuICAgIHF1ZXJ5U3ViamVjdEVsKGV2KSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudENsb3Nlc3QoZXYudGFyZ2V0LCB0aGlzLnNlbGVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXJFbDtcbiAgICB9XG4gICAgc2hvdWxkSWdub3JlTW91c2UoKSB7XG4gICAgICAgIHJldHVybiBpZ25vcmVNb3VzZURlcHRoIHx8IHRoaXMuaXNUb3VjaERyYWdnaW5nO1xuICAgIH1cbiAgICAvLyBjYW4gYmUgY2FsbGVkIGJ5IHVzZXIgb2YgdGhpcyBjbGFzcywgdG8gY2FuY2VsIHRvdWNoLWJhc2VkIHNjcm9sbGluZyBmb3IgdGhlIGN1cnJlbnQgZHJhZ1xuICAgIGNhbmNlbFRvdWNoU2Nyb2xsKCkge1xuICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICBpc1dpbmRvd1RvdWNoTW92ZUNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gU2Nyb2xsaW5nIHRoYXQgc2ltdWxhdGVzIHBvaW50ZXJtb3Zlc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBpbml0U2Nyb2xsV2F0Y2goZXYpIHtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkV2F0Y2hTY3JvbGwpIHtcbiAgICAgICAgICAgIHRoaXMucmVjb3JkQ29vcmRzKGV2KTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLmhhbmRsZVNjcm9sbCwgdHJ1ZSk7IC8vIHVzZUNhcHR1cmU9dHJ1ZVxuICAgICAgICB9XG4gICAgfVxuICAgIHJlY29yZENvb3Jkcyhldikge1xuICAgICAgICBpZiAodGhpcy5zaG91bGRXYXRjaFNjcm9sbCkge1xuICAgICAgICAgICAgdGhpcy5wcmV2UGFnZVggPSBldi5wYWdlWDtcbiAgICAgICAgICAgIHRoaXMucHJldlBhZ2VZID0gZXYucGFnZVk7XG4gICAgICAgICAgICB0aGlzLnByZXZTY3JvbGxYID0gd2luZG93LnNjcm9sbFg7XG4gICAgICAgICAgICB0aGlzLnByZXZTY3JvbGxZID0gd2luZG93LnNjcm9sbFk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveVNjcm9sbFdhdGNoKCkge1xuICAgICAgICBpZiAodGhpcy5zaG91bGRXYXRjaFNjcm9sbCkge1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuaGFuZGxlU2Nyb2xsLCB0cnVlKTsgLy8gdXNlQ2FwdHVyZWQ9dHJ1ZVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEV2ZW50IE5vcm1hbGl6YXRpb25cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgY3JlYXRlRXZlbnRGcm9tTW91c2UoZXYsIGlzRmlyc3QpIHtcbiAgICAgICAgbGV0IGRlbHRhWCA9IDA7XG4gICAgICAgIGxldCBkZWx0YVkgPSAwO1xuICAgICAgICAvLyBUT0RPOiByZXBlYXQgY29kZVxuICAgICAgICBpZiAoaXNGaXJzdCkge1xuICAgICAgICAgICAgdGhpcy5vcmlnUGFnZVggPSBldi5wYWdlWDtcbiAgICAgICAgICAgIHRoaXMub3JpZ1BhZ2VZID0gZXYucGFnZVk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWx0YVggPSBldi5wYWdlWCAtIHRoaXMub3JpZ1BhZ2VYO1xuICAgICAgICAgICAgZGVsdGFZID0gZXYucGFnZVkgLSB0aGlzLm9yaWdQYWdlWTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3JpZ0V2ZW50OiBldixcbiAgICAgICAgICAgIGlzVG91Y2g6IGZhbHNlLFxuICAgICAgICAgICAgc3ViamVjdEVsOiB0aGlzLnN1YmplY3RFbCxcbiAgICAgICAgICAgIHBhZ2VYOiBldi5wYWdlWCxcbiAgICAgICAgICAgIHBhZ2VZOiBldi5wYWdlWSxcbiAgICAgICAgICAgIGRlbHRhWCxcbiAgICAgICAgICAgIGRlbHRhWSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY3JlYXRlRXZlbnRGcm9tVG91Y2goZXYsIGlzRmlyc3QpIHtcbiAgICAgICAgbGV0IHRvdWNoZXMgPSBldi50b3VjaGVzO1xuICAgICAgICBsZXQgcGFnZVg7XG4gICAgICAgIGxldCBwYWdlWTtcbiAgICAgICAgbGV0IGRlbHRhWCA9IDA7XG4gICAgICAgIGxldCBkZWx0YVkgPSAwO1xuICAgICAgICAvLyBpZiB0b3VjaCBjb29yZHMgYXZhaWxhYmxlLCBwcmVmZXIsXG4gICAgICAgIC8vIGJlY2F1c2UgRkYgd291bGQgZ2l2ZSBiYWQgZXYucGFnZVggZXYucGFnZVlcbiAgICAgICAgaWYgKHRvdWNoZXMgJiYgdG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHBhZ2VYID0gdG91Y2hlc1swXS5wYWdlWDtcbiAgICAgICAgICAgIHBhZ2VZID0gdG91Y2hlc1swXS5wYWdlWTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhZ2VYID0gZXYucGFnZVg7XG4gICAgICAgICAgICBwYWdlWSA9IGV2LnBhZ2VZO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IHJlcGVhdCBjb2RlXG4gICAgICAgIGlmIChpc0ZpcnN0KSB7XG4gICAgICAgICAgICB0aGlzLm9yaWdQYWdlWCA9IHBhZ2VYO1xuICAgICAgICAgICAgdGhpcy5vcmlnUGFnZVkgPSBwYWdlWTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbHRhWCA9IHBhZ2VYIC0gdGhpcy5vcmlnUGFnZVg7XG4gICAgICAgICAgICBkZWx0YVkgPSBwYWdlWSAtIHRoaXMub3JpZ1BhZ2VZO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvcmlnRXZlbnQ6IGV2LFxuICAgICAgICAgICAgaXNUb3VjaDogdHJ1ZSxcbiAgICAgICAgICAgIHN1YmplY3RFbDogdGhpcy5zdWJqZWN0RWwsXG4gICAgICAgICAgICBwYWdlWCxcbiAgICAgICAgICAgIHBhZ2VZLFxuICAgICAgICAgICAgZGVsdGFYLFxuICAgICAgICAgICAgZGVsdGFZLFxuICAgICAgICB9O1xuICAgIH1cbn1cbi8vIFJldHVybnMgYSBib29sZWFuIHdoZXRoZXIgdGhpcyB3YXMgYSBsZWZ0IG1vdXNlIGNsaWNrIGFuZCBubyBjdHJsIGtleSAod2hpY2ggbWVhbnMgcmlnaHQgY2xpY2sgb24gTWFjKVxuZnVuY3Rpb24gaXNQcmltYXJ5TW91c2VCdXR0b24oZXYpIHtcbiAgICByZXR1cm4gZXYuYnV0dG9uID09PSAwICYmICFldi5jdHJsS2V5O1xufVxuLy8gSWdub3JpbmcgZmFrZSBtb3VzZSBldmVudHMgZ2VuZXJhdGVkIGJ5IHRvdWNoXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBzdGFydElnbm9yaW5nTW91c2UoKSB7XG4gICAgaWdub3JlTW91c2VEZXB0aCArPSAxO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZ25vcmVNb3VzZURlcHRoIC09IDE7XG4gICAgfSwgY29uZmlnLnRvdWNoTW91c2VJZ25vcmVXYWl0KTtcbn1cbi8vIFdlIHdhbnQgdG8gYXR0YWNoIHRvdWNobW92ZSBhcyBlYXJseSBhcyBwb3NzaWJsZSBmb3IgU2FmYXJpXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBsaXN0ZW5lckNyZWF0ZWQoKSB7XG4gICAgbGlzdGVuZXJDbnQgKz0gMTtcbiAgICBpZiAobGlzdGVuZXJDbnQgPT09IDEpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uV2luZG93VG91Y2hNb3ZlLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxpc3RlbmVyRGVzdHJveWVkKCkge1xuICAgIGxpc3RlbmVyQ250IC09IDE7XG4gICAgaWYgKCFsaXN0ZW5lckNudCkge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25XaW5kb3dUb3VjaE1vdmUsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gb25XaW5kb3dUb3VjaE1vdmUoZXYpIHtcbiAgICBpZiAoaXNXaW5kb3dUb3VjaE1vdmVDYW5jZWxsZWQpIHtcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG59XG5cbi8qXG5BbiBlZmZlY3QgaW4gd2hpY2ggYW4gZWxlbWVudCBmb2xsb3dzIHRoZSBtb3ZlbWVudCBvZiBhIHBvaW50ZXIgYWNyb3NzIHRoZSBzY3JlZW4uXG5UaGUgbW92aW5nIGVsZW1lbnQgaXMgYSBjbG9uZSBvZiBzb21lIG90aGVyIGVsZW1lbnQuXG5NdXN0IGNhbGwgc3RhcnQgKyBoYW5kbGVNb3ZlICsgc3RvcC5cbiovXG5jbGFzcyBFbGVtZW50TWlycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5pc1Zpc2libGUgPSBmYWxzZTsgLy8gbXVzdCBiZSBleHBsaWNpdGx5IGVuYWJsZWRcbiAgICAgICAgdGhpcy5zb3VyY2VFbCA9IG51bGw7XG4gICAgICAgIHRoaXMubWlycm9yRWwgPSBudWxsO1xuICAgICAgICB0aGlzLnNvdXJjZUVsUmVjdCA9IG51bGw7IC8vIHNjcmVlbiBjb29yZHMgcmVsYXRpdmUgdG8gdmlld3BvcnRcbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IGNhbiBiZSBzZXQgZGlyZWN0bHkgYnkgY2FsbGVyXG4gICAgICAgIHRoaXMucGFyZW50Tm9kZSA9IGRvY3VtZW50LmJvZHk7IC8vIEhJR0hMWSBTVUdHRVNURUQgdG8gc2V0IHRoaXMgdG8gc2lkZXN0ZXAgU2hhZG93RE9NIGlzc3Vlc1xuICAgICAgICB0aGlzLnpJbmRleCA9IDk5OTk7XG4gICAgICAgIHRoaXMucmV2ZXJ0RHVyYXRpb24gPSAwO1xuICAgIH1cbiAgICBzdGFydChzb3VyY2VFbCwgcGFnZVgsIHBhZ2VZKSB7XG4gICAgICAgIHRoaXMuc291cmNlRWwgPSBzb3VyY2VFbDtcbiAgICAgICAgdGhpcy5zb3VyY2VFbFJlY3QgPSB0aGlzLnNvdXJjZUVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0aGlzLm9yaWdTY3JlZW5YID0gcGFnZVggLSB3aW5kb3cuc2Nyb2xsWDtcbiAgICAgICAgdGhpcy5vcmlnU2NyZWVuWSA9IHBhZ2VZIC0gd2luZG93LnNjcm9sbFk7XG4gICAgICAgIHRoaXMuZGVsdGFYID0gMDtcbiAgICAgICAgdGhpcy5kZWx0YVkgPSAwO1xuICAgICAgICB0aGlzLnVwZGF0ZUVsUG9zaXRpb24oKTtcbiAgICB9XG4gICAgaGFuZGxlTW92ZShwYWdlWCwgcGFnZVkpIHtcbiAgICAgICAgdGhpcy5kZWx0YVggPSAocGFnZVggLSB3aW5kb3cuc2Nyb2xsWCkgLSB0aGlzLm9yaWdTY3JlZW5YO1xuICAgICAgICB0aGlzLmRlbHRhWSA9IChwYWdlWSAtIHdpbmRvdy5zY3JvbGxZKSAtIHRoaXMub3JpZ1NjcmVlblk7XG4gICAgICAgIHRoaXMudXBkYXRlRWxQb3NpdGlvbigpO1xuICAgIH1cbiAgICAvLyBjYW4gYmUgY2FsbGVkIGJlZm9yZSBzdGFydFxuICAgIHNldElzVmlzaWJsZShib29sKSB7XG4gICAgICAgIGlmIChib29sKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWlycm9yRWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5taXJyb3JFbC5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuaXNWaXNpYmxlID0gYm9vbDsgLy8gbmVlZHMgdG8gaGFwcGVuIGJlZm9yZSB1cGRhdGVFbFBvc2l0aW9uXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVFbFBvc2l0aW9uKCk7IC8vIGJlY2F1c2Ugd2FzIG5vdCB1cGRhdGluZyB0aGUgcG9zaXRpb24gd2hpbGUgaW52aXNpYmxlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pc1Zpc2libGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1pcnJvckVsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5taXJyb3JFbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pc1Zpc2libGUgPSBib29sO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGFsd2F5cyBhc3luY1xuICAgIHN0b3AobmVlZHNSZXZlcnRBbmltYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgICAgIGxldCBkb25lID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAobmVlZHNSZXZlcnRBbmltYXRpb24gJiZcbiAgICAgICAgICAgIHRoaXMubWlycm9yRWwgJiZcbiAgICAgICAgICAgIHRoaXMuaXNWaXNpYmxlICYmXG4gICAgICAgICAgICB0aGlzLnJldmVydER1cmF0aW9uICYmIC8vIGlmIDAsIHRyYW5zaXRpb24gd29uJ3Qgd29ya1xuICAgICAgICAgICAgKHRoaXMuZGVsdGFYIHx8IHRoaXMuZGVsdGFZKSAvLyBpZiBzYW1lIGNvb3JkcywgdHJhbnNpdGlvbiB3b24ndCB3b3JrXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5kb1JldmVydEFuaW1hdGlvbihkb25lLCB0aGlzLnJldmVydER1cmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZG9uZSwgMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZG9SZXZlcnRBbmltYXRpb24oY2FsbGJhY2ssIHJldmVydER1cmF0aW9uKSB7XG4gICAgICAgIGxldCBtaXJyb3JFbCA9IHRoaXMubWlycm9yRWw7XG4gICAgICAgIGxldCBmaW5hbFNvdXJjZUVsUmVjdCA9IHRoaXMuc291cmNlRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IC8vIGJlY2F1c2UgYXV0b3Njcm9sbGluZyBtaWdodCBoYXZlIGhhcHBlbmVkXG4gICAgICAgIG1pcnJvckVsLnN0eWxlLnRyYW5zaXRpb24gPVxuICAgICAgICAgICAgJ3RvcCAnICsgcmV2ZXJ0RHVyYXRpb24gKyAnbXMsJyArXG4gICAgICAgICAgICAgICAgJ2xlZnQgJyArIHJldmVydER1cmF0aW9uICsgJ21zJztcbiAgICAgICAgYXBwbHlTdHlsZShtaXJyb3JFbCwge1xuICAgICAgICAgICAgbGVmdDogZmluYWxTb3VyY2VFbFJlY3QubGVmdCxcbiAgICAgICAgICAgIHRvcDogZmluYWxTb3VyY2VFbFJlY3QudG9wLFxuICAgICAgICB9KTtcbiAgICAgICAgd2hlblRyYW5zaXRpb25Eb25lKG1pcnJvckVsLCAoKSA9PiB7XG4gICAgICAgICAgICBtaXJyb3JFbC5zdHlsZS50cmFuc2l0aW9uID0gJyc7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2xlYW51cCgpIHtcbiAgICAgICAgaWYgKHRoaXMubWlycm9yRWwpIHtcbiAgICAgICAgICAgIHJlbW92ZUVsZW1lbnQodGhpcy5taXJyb3JFbCk7XG4gICAgICAgICAgICB0aGlzLm1pcnJvckVsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNvdXJjZUVsID0gbnVsbDtcbiAgICB9XG4gICAgdXBkYXRlRWxQb3NpdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuc291cmNlRWwgJiYgdGhpcy5pc1Zpc2libGUpIHtcbiAgICAgICAgICAgIGFwcGx5U3R5bGUodGhpcy5nZXRNaXJyb3JFbCgpLCB7XG4gICAgICAgICAgICAgICAgbGVmdDogdGhpcy5zb3VyY2VFbFJlY3QubGVmdCArIHRoaXMuZGVsdGFYLFxuICAgICAgICAgICAgICAgIHRvcDogdGhpcy5zb3VyY2VFbFJlY3QudG9wICsgdGhpcy5kZWx0YVksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRNaXJyb3JFbCgpIHtcbiAgICAgICAgbGV0IHNvdXJjZUVsUmVjdCA9IHRoaXMuc291cmNlRWxSZWN0O1xuICAgICAgICBsZXQgbWlycm9yRWwgPSB0aGlzLm1pcnJvckVsO1xuICAgICAgICBpZiAoIW1pcnJvckVsKSB7XG4gICAgICAgICAgICBtaXJyb3JFbCA9IHRoaXMubWlycm9yRWwgPSB0aGlzLnNvdXJjZUVsLmNsb25lTm9kZSh0cnVlKTsgLy8gY2xvbmVDaGlsZHJlbj10cnVlXG4gICAgICAgICAgICAvLyB3ZSBkb24ndCB3YW50IGxvbmcgdGFwcyBvciBhbnkgbW91c2UgaW50ZXJhY3Rpb24gY2F1c2luZyBzZWxlY3Rpb24vbWVudXMuXG4gICAgICAgICAgICAvLyB3b3VsZCB1c2UgcHJldmVudFNlbGVjdGlvbigpLCBidXQgdGhhdCBwcmV2ZW50cyBzZWxlY3RzdGFydCwgY2F1c2luZyBwcm9ibGVtcy5cbiAgICAgICAgICAgIG1pcnJvckVsLnN0eWxlLnVzZXJTZWxlY3QgPSAnbm9uZSc7XG4gICAgICAgICAgICBtaXJyb3JFbC5zdHlsZS53ZWJraXRVc2VyU2VsZWN0ID0gJ25vbmUnO1xuICAgICAgICAgICAgbWlycm9yRWwuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgICAgICAgIG1pcnJvckVsLmNsYXNzTGlzdC5hZGQoJ2ZjLWV2ZW50LWRyYWdnaW5nJyk7XG4gICAgICAgICAgICBhcHBseVN0eWxlKG1pcnJvckVsLCB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICAgICAgICAgICAgekluZGV4OiB0aGlzLnpJbmRleCxcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiAnJyxcbiAgICAgICAgICAgICAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICAgICAgICAgICAgICB3aWR0aDogc291cmNlRWxSZWN0LnJpZ2h0IC0gc291cmNlRWxSZWN0LmxlZnQsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBzb3VyY2VFbFJlY3QuYm90dG9tIC0gc291cmNlRWxSZWN0LnRvcCxcbiAgICAgICAgICAgICAgICByaWdodDogJ2F1dG8nLFxuICAgICAgICAgICAgICAgIGJvdHRvbTogJ2F1dG8nLFxuICAgICAgICAgICAgICAgIG1hcmdpbjogMCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnROb2RlLmFwcGVuZENoaWxkKG1pcnJvckVsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWlycm9yRWw7XG4gICAgfVxufVxuXG4vKlxuSXMgYSBjYWNoZSBmb3IgYSBnaXZlbiBlbGVtZW50J3Mgc2Nyb2xsIGluZm9ybWF0aW9uIChhbGwgdGhlIGluZm8gdGhhdCBTY3JvbGxDb250cm9sbGVyIHN0b3JlcylcbmluIGFkZGl0aW9uIHRoZSBcImNsaWVudCByZWN0YW5nbGVcIiBvZiB0aGUgZWxlbWVudC4uIHRoZSBhcmVhIHdpdGhpbiB0aGUgc2Nyb2xsYmFycy5cblxuVGhlIGNhY2hlIGNhbiBiZSBpbiBvbmUgb2YgdHdvIG1vZGVzOlxuLSBkb2VzTGlzdGVuaW5nOmZhbHNlIC0gaWdub3JlcyB3aGVuIHRoZSBjb250YWluZXIgaXMgc2Nyb2xsZWQgYnkgc29tZW9uZSBlbHNlXG4tIGRvZXNMaXN0ZW5pbmc6dHJ1ZSAtIHdhdGNoIGZvciBzY3JvbGxpbmcgYW5kIHVwZGF0ZSB0aGUgY2FjaGVcbiovXG5jbGFzcyBTY3JvbGxHZW9tQ2FjaGUgZXh0ZW5kcyBTY3JvbGxDb250cm9sbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihzY3JvbGxDb250cm9sbGVyLCBkb2VzTGlzdGVuaW5nKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaGFuZGxlU2Nyb2xsID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxUb3AgPSB0aGlzLnNjcm9sbENvbnRyb2xsZXIuZ2V0U2Nyb2xsVG9wKCk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbExlZnQgPSB0aGlzLnNjcm9sbENvbnRyb2xsZXIuZ2V0U2Nyb2xsTGVmdCgpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGxDaGFuZ2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zY3JvbGxDb250cm9sbGVyID0gc2Nyb2xsQ29udHJvbGxlcjtcbiAgICAgICAgdGhpcy5kb2VzTGlzdGVuaW5nID0gZG9lc0xpc3RlbmluZztcbiAgICAgICAgdGhpcy5zY3JvbGxUb3AgPSB0aGlzLm9yaWdTY3JvbGxUb3AgPSBzY3JvbGxDb250cm9sbGVyLmdldFNjcm9sbFRvcCgpO1xuICAgICAgICB0aGlzLnNjcm9sbExlZnQgPSB0aGlzLm9yaWdTY3JvbGxMZWZ0ID0gc2Nyb2xsQ29udHJvbGxlci5nZXRTY3JvbGxMZWZ0KCk7XG4gICAgICAgIHRoaXMuc2Nyb2xsV2lkdGggPSBzY3JvbGxDb250cm9sbGVyLmdldFNjcm9sbFdpZHRoKCk7XG4gICAgICAgIHRoaXMuc2Nyb2xsSGVpZ2h0ID0gc2Nyb2xsQ29udHJvbGxlci5nZXRTY3JvbGxIZWlnaHQoKTtcbiAgICAgICAgdGhpcy5jbGllbnRXaWR0aCA9IHNjcm9sbENvbnRyb2xsZXIuZ2V0Q2xpZW50V2lkdGgoKTtcbiAgICAgICAgdGhpcy5jbGllbnRIZWlnaHQgPSBzY3JvbGxDb250cm9sbGVyLmdldENsaWVudEhlaWdodCgpO1xuICAgICAgICB0aGlzLmNsaWVudFJlY3QgPSB0aGlzLmNvbXB1dGVDbGllbnRSZWN0KCk7IC8vIGRvIGxhc3QgaW4gY2FzZSBpdCBuZWVkcyBjYWNoZWQgdmFsdWVzXG4gICAgICAgIGlmICh0aGlzLmRvZXNMaXN0ZW5pbmcpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0RXZlbnRUYXJnZXQoKS5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLmhhbmRsZVNjcm9sbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZG9lc0xpc3RlbmluZykge1xuICAgICAgICAgICAgdGhpcy5nZXRFdmVudFRhcmdldCgpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuaGFuZGxlU2Nyb2xsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRTY3JvbGxUb3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbFRvcDtcbiAgICB9XG4gICAgZ2V0U2Nyb2xsTGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsTGVmdDtcbiAgICB9XG4gICAgc2V0U2Nyb2xsVG9wKHRvcCkge1xuICAgICAgICB0aGlzLnNjcm9sbENvbnRyb2xsZXIuc2V0U2Nyb2xsVG9wKHRvcCk7XG4gICAgICAgIGlmICghdGhpcy5kb2VzTGlzdGVuaW5nKSB7XG4gICAgICAgICAgICAvLyB3ZSBhcmUgbm90IHJlbHlpbmcgb24gdGhlIGVsZW1lbnQgdG8gbm9ybWFsaXplIG91dC1vZi1ib3VuZHMgc2Nyb2xsIHZhbHVlc1xuICAgICAgICAgICAgLy8gc28gd2UgbmVlZCB0byBzYW5pdGl6ZSBvdXJzZWx2ZXNcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9wID0gTWF0aC5tYXgoTWF0aC5taW4odG9wLCB0aGlzLmdldE1heFNjcm9sbFRvcCgpKSwgMCk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVNjcm9sbENoYW5nZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldFNjcm9sbExlZnQodG9wKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsQ29udHJvbGxlci5zZXRTY3JvbGxMZWZ0KHRvcCk7XG4gICAgICAgIGlmICghdGhpcy5kb2VzTGlzdGVuaW5nKSB7XG4gICAgICAgICAgICAvLyB3ZSBhcmUgbm90IHJlbHlpbmcgb24gdGhlIGVsZW1lbnQgdG8gbm9ybWFsaXplIG91dC1vZi1ib3VuZHMgc2Nyb2xsIHZhbHVlc1xuICAgICAgICAgICAgLy8gc28gd2UgbmVlZCB0byBzYW5pdGl6ZSBvdXJzZWx2ZXNcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsTGVmdCA9IE1hdGgubWF4KE1hdGgubWluKHRvcCwgdGhpcy5nZXRNYXhTY3JvbGxMZWZ0KCkpLCAwKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU2Nyb2xsQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0Q2xpZW50V2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudFdpZHRoO1xuICAgIH1cbiAgICBnZXRDbGllbnRIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudEhlaWdodDtcbiAgICB9XG4gICAgZ2V0U2Nyb2xsV2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbFdpZHRoO1xuICAgIH1cbiAgICBnZXRTY3JvbGxIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbEhlaWdodDtcbiAgICB9XG4gICAgaGFuZGxlU2Nyb2xsQ2hhbmdlKCkge1xuICAgIH1cbn1cblxuY2xhc3MgRWxlbWVudFNjcm9sbEdlb21DYWNoZSBleHRlbmRzIFNjcm9sbEdlb21DYWNoZSB7XG4gICAgY29uc3RydWN0b3IoZWwsIGRvZXNMaXN0ZW5pbmcpIHtcbiAgICAgICAgc3VwZXIobmV3IEVsZW1lbnRTY3JvbGxDb250cm9sbGVyKGVsKSwgZG9lc0xpc3RlbmluZyk7XG4gICAgfVxuICAgIGdldEV2ZW50VGFyZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxDb250cm9sbGVyLmVsO1xuICAgIH1cbiAgICBjb21wdXRlQ2xpZW50UmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIGNvbXB1dGVJbm5lclJlY3QodGhpcy5zY3JvbGxDb250cm9sbGVyLmVsKTtcbiAgICB9XG59XG5cbmNsYXNzIFdpbmRvd1Njcm9sbEdlb21DYWNoZSBleHRlbmRzIFNjcm9sbEdlb21DYWNoZSB7XG4gICAgY29uc3RydWN0b3IoZG9lc0xpc3RlbmluZykge1xuICAgICAgICBzdXBlcihuZXcgV2luZG93U2Nyb2xsQ29udHJvbGxlcigpLCBkb2VzTGlzdGVuaW5nKTtcbiAgICB9XG4gICAgZ2V0RXZlbnRUYXJnZXQoKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgfVxuICAgIGNvbXB1dGVDbGllbnRSZWN0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogdGhpcy5zY3JvbGxMZWZ0LFxuICAgICAgICAgICAgcmlnaHQ6IHRoaXMuc2Nyb2xsTGVmdCArIHRoaXMuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICB0b3A6IHRoaXMuc2Nyb2xsVG9wLFxuICAgICAgICAgICAgYm90dG9tOiB0aGlzLnNjcm9sbFRvcCArIHRoaXMuY2xpZW50SGVpZ2h0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyB0aGUgd2luZG93IGlzIHRoZSBvbmx5IHNjcm9sbCBvYmplY3QgdGhhdCBjaGFuZ2VzIGl0J3MgcmVjdGFuZ2xlIHJlbGF0aXZlXG4gICAgLy8gdG8gdGhlIGRvY3VtZW50J3MgdG9wbGVmdCBhcyBpdCBzY3JvbGxzXG4gICAgaGFuZGxlU2Nyb2xsQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLmNsaWVudFJlY3QgPSB0aGlzLmNvbXB1dGVDbGllbnRSZWN0KCk7XG4gICAgfVxufVxuXG4vLyBJZiBhdmFpbGFibGUgd2UgYXJlIHVzaW5nIG5hdGl2ZSBcInBlcmZvcm1hbmNlXCIgQVBJIGluc3RlYWQgb2YgXCJEYXRlXCJcbi8vIFJlYWQgbW9yZSBhYm91dCBpdCBvbiBNRE46XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUGVyZm9ybWFuY2VcbmNvbnN0IGdldFRpbWUgPSB0eXBlb2YgcGVyZm9ybWFuY2UgPT09ICdmdW5jdGlvbicgPyBwZXJmb3JtYW5jZS5ub3cgOiBEYXRlLm5vdztcbi8qXG5Gb3IgYSBwb2ludGVyIGludGVyYWN0aW9uLCBhdXRvbWF0aWNhbGx5IHNjcm9sbHMgY2VydGFpbiBzY3JvbGwgY29udGFpbmVycyB3aGVuIHRoZSBwb2ludGVyXG5hcHByb2FjaGVzIHRoZSBlZGdlLlxuXG5UaGUgY2FsbGVyIG11c3QgY2FsbCBzdGFydCArIGhhbmRsZU1vdmUgKyBzdG9wLlxuKi9cbmNsYXNzIEF1dG9TY3JvbGxlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCBjYW4gYmUgc2V0IGJ5IGNhbGxlclxuICAgICAgICB0aGlzLmlzRW5hYmxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc2Nyb2xsUXVlcnkgPSBbd2luZG93LCAnLmZjLXNjcm9sbGVyJ107XG4gICAgICAgIHRoaXMuZWRnZVRocmVzaG9sZCA9IDUwOyAvLyBwaXhlbHNcbiAgICAgICAgdGhpcy5tYXhWZWxvY2l0eSA9IDMwMDsgLy8gcGl4ZWxzIHBlciBzZWNvbmRcbiAgICAgICAgLy8gaW50ZXJuYWwgc3RhdGVcbiAgICAgICAgdGhpcy5wb2ludGVyU2NyZWVuWCA9IG51bGw7XG4gICAgICAgIHRoaXMucG9pbnRlclNjcmVlblkgPSBudWxsO1xuICAgICAgICB0aGlzLmlzQW5pbWF0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2Nyb2xsQ2FjaGVzID0gbnVsbDtcbiAgICAgICAgLy8gcHJvdGVjdCBhZ2FpbnN0IHRoZSBpbml0aWFsIHBvaW50ZXJkb3duIGJlaW5nIHRvbyBjbG9zZSB0byBhbiBlZGdlIGFuZCBzdGFydGluZyB0aGUgc2Nyb2xsXG4gICAgICAgIHRoaXMuZXZlck1vdmVkVXAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ldmVyTW92ZWREb3duID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXZlck1vdmVkTGVmdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmV2ZXJNb3ZlZFJpZ2h0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYW5pbWF0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQW5pbWF0aW5nKSB7IC8vIHdhc24ndCBjYW5jZWxsZWQgYmV0d2VlbiBhbmltYXRpb24gY2FsbHNcbiAgICAgICAgICAgICAgICBsZXQgZWRnZSA9IHRoaXMuY29tcHV0ZUJlc3RFZGdlKHRoaXMucG9pbnRlclNjcmVlblggKyB3aW5kb3cuc2Nyb2xsWCwgdGhpcy5wb2ludGVyU2NyZWVuWSArIHdpbmRvdy5zY3JvbGxZKTtcbiAgICAgICAgICAgICAgICBpZiAoZWRnZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbm93ID0gZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVNpZGUoZWRnZSwgKG5vdyAtIHRoaXMubXNTaW5jZVJlcXVlc3QpIC8gMTAwMCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbihub3cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0FuaW1hdGluZyA9IGZhbHNlOyAvLyB3aWxsIHN0b3AgYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGFydChwYWdlWCwgcGFnZVksIHNjcm9sbFN0YXJ0RWwpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbENhY2hlcyA9IHRoaXMuYnVpbGRDYWNoZXMoc2Nyb2xsU3RhcnRFbCk7XG4gICAgICAgICAgICB0aGlzLnBvaW50ZXJTY3JlZW5YID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucG9pbnRlclNjcmVlblkgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5ldmVyTW92ZWRVcCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5ldmVyTW92ZWREb3duID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmV2ZXJNb3ZlZExlZnQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZXZlck1vdmVkUmlnaHQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTW92ZShwYWdlWCwgcGFnZVkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZU1vdmUocGFnZVgsIHBhZ2VZKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRW5hYmxlZCkge1xuICAgICAgICAgICAgbGV0IHBvaW50ZXJTY3JlZW5YID0gcGFnZVggLSB3aW5kb3cuc2Nyb2xsWDtcbiAgICAgICAgICAgIGxldCBwb2ludGVyU2NyZWVuWSA9IHBhZ2VZIC0gd2luZG93LnNjcm9sbFk7XG4gICAgICAgICAgICBsZXQgeURlbHRhID0gdGhpcy5wb2ludGVyU2NyZWVuWSA9PT0gbnVsbCA/IDAgOiBwb2ludGVyU2NyZWVuWSAtIHRoaXMucG9pbnRlclNjcmVlblk7XG4gICAgICAgICAgICBsZXQgeERlbHRhID0gdGhpcy5wb2ludGVyU2NyZWVuWCA9PT0gbnVsbCA/IDAgOiBwb2ludGVyU2NyZWVuWCAtIHRoaXMucG9pbnRlclNjcmVlblg7XG4gICAgICAgICAgICBpZiAoeURlbHRhIDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlck1vdmVkVXAgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoeURlbHRhID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlck1vdmVkRG93biA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeERlbHRhIDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlck1vdmVkTGVmdCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh4RGVsdGEgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVyTW92ZWRSaWdodCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBvaW50ZXJTY3JlZW5YID0gcG9pbnRlclNjcmVlblg7XG4gICAgICAgICAgICB0aGlzLnBvaW50ZXJTY3JlZW5ZID0gcG9pbnRlclNjcmVlblk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNBbmltYXRpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzQW5pbWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RBbmltYXRpb24oZ2V0VGltZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAodGhpcy5pc0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNBbmltYXRpbmcgPSBmYWxzZTsgLy8gd2lsbCBzdG9wIGFuaW1hdGlvblxuICAgICAgICAgICAgZm9yIChsZXQgc2Nyb2xsQ2FjaGUgb2YgdGhpcy5zY3JvbGxDYWNoZXMpIHtcbiAgICAgICAgICAgICAgICBzY3JvbGxDYWNoZS5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNjcm9sbENhY2hlcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVxdWVzdEFuaW1hdGlvbihub3cpIHtcbiAgICAgICAgdGhpcy5tc1NpbmNlUmVxdWVzdCA9IG5vdztcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0ZSk7XG4gICAgfVxuICAgIGhhbmRsZVNpZGUoZWRnZSwgc2Vjb25kcykge1xuICAgICAgICBsZXQgeyBzY3JvbGxDYWNoZSB9ID0gZWRnZTtcbiAgICAgICAgbGV0IHsgZWRnZVRocmVzaG9sZCB9ID0gdGhpcztcbiAgICAgICAgbGV0IGludkRpc3RhbmNlID0gZWRnZVRocmVzaG9sZCAtIGVkZ2UuZGlzdGFuY2U7XG4gICAgICAgIGxldCB2ZWxvY2l0eSA9IC8vIHRoZSBjbG9zZXIgdG8gdGhlIGVkZ2UsIHRoZSBmYXN0ZXIgd2Ugc2Nyb2xsXG4gICAgICAgICAoKGludkRpc3RhbmNlICogaW52RGlzdGFuY2UpIC8gKGVkZ2VUaHJlc2hvbGQgKiBlZGdlVGhyZXNob2xkKSkgKiAvLyBxdWFkcmF0aWNcbiAgICAgICAgICAgIHRoaXMubWF4VmVsb2NpdHkgKiBzZWNvbmRzO1xuICAgICAgICBsZXQgc2lnbiA9IDE7XG4gICAgICAgIHN3aXRjaCAoZWRnZS5uYW1lKSB7XG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICBzaWduID0gLTE7XG4gICAgICAgICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgc2Nyb2xsQ2FjaGUuc2V0U2Nyb2xsTGVmdChzY3JvbGxDYWNoZS5nZXRTY3JvbGxMZWZ0KCkgKyB2ZWxvY2l0eSAqIHNpZ24pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgICAgICBzaWduID0gLTE7XG4gICAgICAgICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgIHNjcm9sbENhY2hlLnNldFNjcm9sbFRvcChzY3JvbGxDYWNoZS5nZXRTY3JvbGxUb3AoKSArIHZlbG9jaXR5ICogc2lnbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gbGVmdC90b3AgYXJlIHJlbGF0aXZlIHRvIGRvY3VtZW50IHRvcGxlZnRcbiAgICBjb21wdXRlQmVzdEVkZ2UobGVmdCwgdG9wKSB7XG4gICAgICAgIGxldCB7IGVkZ2VUaHJlc2hvbGQgfSA9IHRoaXM7XG4gICAgICAgIGxldCBiZXN0U2lkZSA9IG51bGw7XG4gICAgICAgIGxldCBzY3JvbGxDYWNoZXMgPSB0aGlzLnNjcm9sbENhY2hlcyB8fCBbXTtcbiAgICAgICAgZm9yIChsZXQgc2Nyb2xsQ2FjaGUgb2Ygc2Nyb2xsQ2FjaGVzKSB7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IHNjcm9sbENhY2hlLmNsaWVudFJlY3Q7XG4gICAgICAgICAgICBsZXQgbGVmdERpc3QgPSBsZWZ0IC0gcmVjdC5sZWZ0O1xuICAgICAgICAgICAgbGV0IHJpZ2h0RGlzdCA9IHJlY3QucmlnaHQgLSBsZWZ0O1xuICAgICAgICAgICAgbGV0IHRvcERpc3QgPSB0b3AgLSByZWN0LnRvcDtcbiAgICAgICAgICAgIGxldCBib3R0b21EaXN0ID0gcmVjdC5ib3R0b20gLSB0b3A7XG4gICAgICAgICAgICAvLyBjb21wbGV0ZWx5IHdpdGhpbiB0aGUgcmVjdD9cbiAgICAgICAgICAgIGlmIChsZWZ0RGlzdCA+PSAwICYmIHJpZ2h0RGlzdCA+PSAwICYmIHRvcERpc3QgPj0gMCAmJiBib3R0b21EaXN0ID49IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodG9wRGlzdCA8PSBlZGdlVGhyZXNob2xkICYmIHRoaXMuZXZlck1vdmVkVXAgJiYgc2Nyb2xsQ2FjaGUuY2FuU2Nyb2xsVXAoKSAmJlxuICAgICAgICAgICAgICAgICAgICAoIWJlc3RTaWRlIHx8IGJlc3RTaWRlLmRpc3RhbmNlID4gdG9wRGlzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVzdFNpZGUgPSB7IHNjcm9sbENhY2hlLCBuYW1lOiAndG9wJywgZGlzdGFuY2U6IHRvcERpc3QgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJvdHRvbURpc3QgPD0gZWRnZVRocmVzaG9sZCAmJiB0aGlzLmV2ZXJNb3ZlZERvd24gJiYgc2Nyb2xsQ2FjaGUuY2FuU2Nyb2xsRG93bigpICYmXG4gICAgICAgICAgICAgICAgICAgICghYmVzdFNpZGUgfHwgYmVzdFNpZGUuZGlzdGFuY2UgPiBib3R0b21EaXN0KSkge1xuICAgICAgICAgICAgICAgICAgICBiZXN0U2lkZSA9IHsgc2Nyb2xsQ2FjaGUsIG5hbWU6ICdib3R0b20nLCBkaXN0YW5jZTogYm90dG9tRGlzdCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgIFRPRE86IGZpeCBicm9rZW4gUlRMIHNjcm9sbGluZy4gY2FuU2Nyb2xsTGVmdCBhbHdheXMgcmV0dXJuaW5nIGZhbHNlXG4gICAgICAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2Z1bGxjYWxlbmRhci9mdWxsY2FsZW5kYXIvaXNzdWVzLzQ4MzdcbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmIChsZWZ0RGlzdCA8PSBlZGdlVGhyZXNob2xkICYmIHRoaXMuZXZlck1vdmVkTGVmdCAmJiBzY3JvbGxDYWNoZS5jYW5TY3JvbGxMZWZ0KCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFiZXN0U2lkZSB8fCBiZXN0U2lkZS5kaXN0YW5jZSA+IGxlZnREaXN0KSkge1xuICAgICAgICAgICAgICAgICAgICBiZXN0U2lkZSA9IHsgc2Nyb2xsQ2FjaGUsIG5hbWU6ICdsZWZ0JywgZGlzdGFuY2U6IGxlZnREaXN0IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyaWdodERpc3QgPD0gZWRnZVRocmVzaG9sZCAmJiB0aGlzLmV2ZXJNb3ZlZFJpZ2h0ICYmIHNjcm9sbENhY2hlLmNhblNjcm9sbFJpZ2h0KCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFiZXN0U2lkZSB8fCBiZXN0U2lkZS5kaXN0YW5jZSA+IHJpZ2h0RGlzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVzdFNpZGUgPSB7IHNjcm9sbENhY2hlLCBuYW1lOiAncmlnaHQnLCBkaXN0YW5jZTogcmlnaHREaXN0IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiZXN0U2lkZTtcbiAgICB9XG4gICAgYnVpbGRDYWNoZXMoc2Nyb2xsU3RhcnRFbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWVyeVNjcm9sbEVscyhzY3JvbGxTdGFydEVsKS5tYXAoKGVsKSA9PiB7XG4gICAgICAgICAgICBpZiAoZWwgPT09IHdpbmRvdykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgV2luZG93U2Nyb2xsR2VvbUNhY2hlKGZhbHNlKTsgLy8gZmFsc2UgPSBkb24ndCBsaXN0ZW4gdG8gdXNlci1nZW5lcmF0ZWQgc2Nyb2xsc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50U2Nyb2xsR2VvbUNhY2hlKGVsLCBmYWxzZSk7IC8vIGZhbHNlID0gZG9uJ3QgbGlzdGVuIHRvIHVzZXItZ2VuZXJhdGVkIHNjcm9sbHNcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHF1ZXJ5U2Nyb2xsRWxzKHNjcm9sbFN0YXJ0RWwpIHtcbiAgICAgICAgbGV0IGVscyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBxdWVyeSBvZiB0aGlzLnNjcm9sbFF1ZXJ5KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGVscy5wdXNoKHF1ZXJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgVE9ETzogaW4gdGhlIGZ1dHVyZSwgYWx3YXlzIGhhdmUgYXV0by1zY3JvbGwgaGFwcGVuIG9uIGVsZW1lbnQgd2hlcmUgY3VycmVudCBIaXQgY2FtZSBmcm9tXG4gICAgICAgICAgICAgICAgVGlja2V0OiBodHRwczovL2dpdGh1Yi5jb20vZnVsbGNhbGVuZGFyL2Z1bGxjYWxlbmRhci9pc3N1ZXMvNDU5M1xuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZWxzLnB1c2goLi4uQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoc2Nyb2xsU3RhcnRFbC5nZXRSb290Tm9kZSgpLnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVscztcbiAgICB9XG59XG5cbi8qXG5Nb25pdG9ycyBkcmFnZ2luZyBvbiBhbiBlbGVtZW50LiBIYXMgYSBudW1iZXIgb2YgaGlnaC1sZXZlbCBmZWF0dXJlczpcbi0gbWluaW11bSBkaXN0YW5jZSByZXF1aXJlZCBiZWZvcmUgZHJhZ2dpbmdcbi0gbWluaW11bSB3YWl0IHRpbWUgKFwiZGVsYXlcIikgYmVmb3JlIGRyYWdnaW5nXG4tIGEgbWlycm9yIGVsZW1lbnQgdGhhdCBmb2xsb3dzIHRoZSBwb2ludGVyXG4qL1xuY2xhc3MgRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZyBleHRlbmRzIEVsZW1lbnREcmFnZ2luZyB7XG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyRWwsIHNlbGVjdG9yKSB7XG4gICAgICAgIHN1cGVyKGNvbnRhaW5lckVsKTtcbiAgICAgICAgdGhpcy5jb250YWluZXJFbCA9IGNvbnRhaW5lckVsO1xuICAgICAgICAvLyBvcHRpb25zIHRoYXQgY2FuIGJlIGRpcmVjdGx5IHNldCBieSBjYWxsZXJcbiAgICAgICAgLy8gdGhlIGNhbGxlciBjYW4gYWxzbyBzZXQgdGhlIFBvaW50ZXJEcmFnZ2luZydzIG9wdGlvbnMgYXMgd2VsbFxuICAgICAgICB0aGlzLmRlbGF5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5taW5EaXN0YW5jZSA9IDA7XG4gICAgICAgIHRoaXMudG91Y2hTY3JvbGxBbGxvd2VkID0gdHJ1ZTsgLy8gcHJldmVudHMgZHJhZyBmcm9tIHN0YXJ0aW5nIGFuZCBibG9ja3Mgc2Nyb2xsaW5nIGR1cmluZyBkcmFnXG4gICAgICAgIHRoaXMubWlycm9yTmVlZHNSZXZlcnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0ludGVyYWN0aW5nID0gZmFsc2U7IC8vIGlzIHRoZSB1c2VyIHZhbGlkbHkgbW92aW5nIHRoZSBwb2ludGVyPyBsYXN0cyB1bnRpbCBwb2ludGVydXBcbiAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7IC8vIGlzIGl0IElOVEVOVEZVTExZIGRyYWdnaW5nPyBsYXN0cyB1bnRpbCBhZnRlciByZXZlcnQgYW5pbWF0aW9uXG4gICAgICAgIHRoaXMuaXNEZWxheUVuZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNEaXN0YW5jZVN1cnBhc3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlbGF5VGltZW91dElkID0gbnVsbDtcbiAgICAgICAgdGhpcy5vblBvaW50ZXJEb3duID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNEcmFnZ2luZykgeyAvLyBzbyBuZXcgZHJhZyBkb2Vzbid0IGhhcHBlbiB3aGlsZSByZXZlcnQgYW5pbWF0aW9uIGlzIGdvaW5nXG4gICAgICAgICAgICAgICAgdGhpcy5pc0ludGVyYWN0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmlzRGVsYXlFbmRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNEaXN0YW5jZVN1cnBhc3NlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHByZXZlbnRTZWxlY3Rpb24oZG9jdW1lbnQuYm9keSk7XG4gICAgICAgICAgICAgICAgcHJldmVudENvbnRleHRNZW51KGRvY3VtZW50LmJvZHkpO1xuICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgbGlua3MgZnJvbSBiZWluZyB2aXNpdGVkIGlmIHRoZXJlJ3MgYW4gZXZlbnR1YWwgZHJhZy5cbiAgICAgICAgICAgICAgICAvLyBhbHNvIHByZXZlbnRzIHNlbGVjdGlvbiBpbiBvbGRlciBicm93c2VycyAobWF5YmU/KS5cbiAgICAgICAgICAgICAgICAvLyBub3QgbmVjZXNzYXJ5IGZvciB0b3VjaCwgYmVzaWRlcywgYnJvd3NlciB3b3VsZCBjb21wbGFpbiBhYm91dCBwYXNzaXZlbmVzcy5cbiAgICAgICAgICAgICAgICBpZiAoIWV2LmlzVG91Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgZXYub3JpZ0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVyZG93bicsIGV2KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0ludGVyYWN0aW5nICYmIC8vIG5vdCBkZXN0cm95ZWQgdmlhIHBvaW50ZXJkb3duIGhhbmRsZXJcbiAgICAgICAgICAgICAgICAgICAgIXRoaXMucG9pbnRlci5zaG91bGRJZ25vcmVNb3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFjdGlvbnMgcmVsYXRlZCB0byBpbml0aWF0aW5nIGRyYWdzdGFydCtkcmFnbW92ZStkcmFnZW5kLi4uXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWlycm9yLnNldElzVmlzaWJsZShmYWxzZSk7IC8vIHJlc2V0LiBjYWxsZXIgbXVzdCBzZXQtdmlzaWJsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1pcnJvci5zdGFydChldi5zdWJqZWN0RWwsIGV2LnBhZ2VYLCBldi5wYWdlWSk7IC8vIG11c3QgaGFwcGVuIG9uIGZpcnN0IHBvaW50ZXIgZG93blxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0RGVsYXkoZXYpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWluRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzdGFuY2VTdXJwYXNzZWQoZXYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uUG9pbnRlck1vdmUgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSW50ZXJhY3RpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcm1vdmUnLCBldik7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzRGlzdGFuY2VTdXJwYXNzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1pbkRpc3RhbmNlID0gdGhpcy5taW5EaXN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRpc3RhbmNlU3E7IC8vIGN1cnJlbnQgZGlzdGFuY2UgZnJvbSB0aGUgb3JpZ2luLCBzcXVhcmVkXG4gICAgICAgICAgICAgICAgICAgIGxldCB7IGRlbHRhWCwgZGVsdGFZIH0gPSBldjtcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2VTcSA9IGRlbHRhWCAqIGRlbHRhWCArIGRlbHRhWSAqIGRlbHRhWTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlU3EgPj0gbWluRGlzdGFuY2UgKiBtaW5EaXN0YW5jZSkgeyAvLyB1c2UgcHl0aGFnb3JlYW4gdGhlb3JlbVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXN0YW5jZVN1cnBhc3NlZChldik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZykge1xuICAgICAgICAgICAgICAgICAgICAvLyBhIHJlYWwgcG9pbnRlciBtb3ZlPyAobm90IG9uZSBzaW11bGF0ZWQgYnkgc2Nyb2xsaW5nKVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXYub3JpZ0V2ZW50LnR5cGUgIT09ICdzY3JvbGwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1pcnJvci5oYW5kbGVNb3ZlKGV2LnBhZ2VYLCBldi5wYWdlWSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF1dG9TY3JvbGxlci5oYW5kbGVNb3ZlKGV2LnBhZ2VYLCBldi5wYWdlWSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2RyYWdtb3ZlJywgZXYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vblBvaW50ZXJVcCA9IChldikgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNJbnRlcmFjdGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNJbnRlcmFjdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGFsbG93U2VsZWN0aW9uKGRvY3VtZW50LmJvZHkpO1xuICAgICAgICAgICAgICAgIGFsbG93Q29udGV4dE1lbnUoZG9jdW1lbnQuYm9keSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJ1cCcsIGV2KTsgLy8gY2FuIHBvdGVudGlhbGx5IHNldCBtaXJyb3JOZWVkc1JldmVydFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdXRvU2Nyb2xsZXIuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyeVN0b3BEcmFnKGV2KTsgLy8gd2hpY2ggd2lsbCBzdG9wIHRoZSBtaXJyb3JcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVsYXlUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZGVsYXlUaW1lb3V0SWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGF5VGltZW91dElkID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGxldCBwb2ludGVyID0gdGhpcy5wb2ludGVyID0gbmV3IFBvaW50ZXJEcmFnZ2luZyhjb250YWluZXJFbCk7XG4gICAgICAgIHBvaW50ZXIuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCB0aGlzLm9uUG9pbnRlckRvd24pO1xuICAgICAgICBwb2ludGVyLmVtaXR0ZXIub24oJ3BvaW50ZXJtb3ZlJywgdGhpcy5vblBvaW50ZXJNb3ZlKTtcbiAgICAgICAgcG9pbnRlci5lbWl0dGVyLm9uKCdwb2ludGVydXAnLCB0aGlzLm9uUG9pbnRlclVwKTtcbiAgICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICBwb2ludGVyLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5taXJyb3IgPSBuZXcgRWxlbWVudE1pcnJvcigpO1xuICAgICAgICB0aGlzLmF1dG9TY3JvbGxlciA9IG5ldyBBdXRvU2Nyb2xsZXIoKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5wb2ludGVyLmRlc3Ryb3koKTtcbiAgICAgICAgLy8gSEFDSzogc2ltdWxhdGUgYSBwb2ludGVyLXVwIHRvIGVuZCB0aGUgY3VycmVudCBkcmFnXG4gICAgICAgIC8vIFRPRE86IGZpcmUgJ2RyYWdlbmQnIGRpcmVjdGx5IGFuZCBzdG9wIGludGVyYWN0aW9uLiBkaXNjb3VyYWdlIHVzZSBvZiBwb2ludGVydXAgZXZlbnQgKGIvYyBtaWdodCBub3QgZmlyZSlcbiAgICAgICAgdGhpcy5vblBvaW50ZXJVcCh7fSk7XG4gICAgfVxuICAgIHN0YXJ0RGVsYXkoZXYpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmRlbGF5ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5kZWxheVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVsYXlUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRGVsYXlFbmQoZXYpO1xuICAgICAgICAgICAgfSwgdGhpcy5kZWxheSk7IC8vIG5vdCBhc3NpZ25hYmxlIHRvIG51bWJlciFcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRGVsYXlFbmQoZXYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZURlbGF5RW5kKGV2KSB7XG4gICAgICAgIHRoaXMuaXNEZWxheUVuZGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50cnlTdGFydERyYWcoZXYpO1xuICAgIH1cbiAgICBoYW5kbGVEaXN0YW5jZVN1cnBhc3NlZChldikge1xuICAgICAgICB0aGlzLmlzRGlzdGFuY2VTdXJwYXNzZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnRyeVN0YXJ0RHJhZyhldik7XG4gICAgfVxuICAgIHRyeVN0YXJ0RHJhZyhldikge1xuICAgICAgICBpZiAodGhpcy5pc0RlbGF5RW5kZWQgJiYgdGhpcy5pc0Rpc3RhbmNlU3VycGFzc2VkKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucG9pbnRlci53YXNUb3VjaFNjcm9sbCB8fCB0aGlzLnRvdWNoU2Nyb2xsQWxsb3dlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5taXJyb3JOZWVkc1JldmVydCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuYXV0b1Njcm9sbGVyLnN0YXJ0KGV2LnBhZ2VYLCBldi5wYWdlWSwgdGhpcy5jb250YWluZXJFbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2RyYWdzdGFydCcsIGV2KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50b3VjaFNjcm9sbEFsbG93ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9pbnRlci5jYW5jZWxUb3VjaFNjcm9sbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0cnlTdG9wRHJhZyhldikge1xuICAgICAgICAvLyAuc3RvcCgpIGlzIEFMV0FZUyBhc3luY2hyb25vdXMsIHdoaWNoIHdlIE5FRUQgYmVjYXVzZSB3ZSB3YW50IGFsbCBwb2ludGVydXAgZXZlbnRzXG4gICAgICAgIC8vIHRoYXQgY29tZSBmcm9tIHRoZSBkb2N1bWVudCB0byBmaXJlIGJlZm9yZWhhbmQuIG11Y2ggbW9yZSBjb252ZW5pZW50IHRoaXMgd2F5LlxuICAgICAgICB0aGlzLm1pcnJvci5zdG9wKHRoaXMubWlycm9yTmVlZHNSZXZlcnQsIHRoaXMuc3RvcERyYWcuYmluZCh0aGlzLCBldikpO1xuICAgIH1cbiAgICBzdG9wRHJhZyhldikge1xuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2RyYWdlbmQnLCBldik7XG4gICAgfVxuICAgIC8vIGZpbGwgaW4gdGhlIGltcGxlbWVudGF0aW9ucy4uLlxuICAgIHNldElnbm9yZU1vdmUoYm9vbCkge1xuICAgICAgICB0aGlzLnBvaW50ZXIuc2hvdWxkSWdub3JlTW92ZSA9IGJvb2w7XG4gICAgfVxuICAgIHNldE1pcnJvcklzVmlzaWJsZShib29sKSB7XG4gICAgICAgIHRoaXMubWlycm9yLnNldElzVmlzaWJsZShib29sKTtcbiAgICB9XG4gICAgc2V0TWlycm9yTmVlZHNSZXZlcnQoYm9vbCkge1xuICAgICAgICB0aGlzLm1pcnJvck5lZWRzUmV2ZXJ0ID0gYm9vbDtcbiAgICB9XG4gICAgc2V0QXV0b1Njcm9sbEVuYWJsZWQoYm9vbCkge1xuICAgICAgICB0aGlzLmF1dG9TY3JvbGxlci5pc0VuYWJsZWQgPSBib29sO1xuICAgIH1cbn1cblxuLypcbldoZW4gdGhpcyBjbGFzcyBpcyBpbnN0YW50aWF0ZWQsIGl0IHJlY29yZHMgdGhlIG9mZnNldCBvZiBhbiBlbGVtZW50IChyZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnQgdG9wbGVmdCksXG5hbmQgY29udGludWVzIHRvIG1vbml0b3Igc2Nyb2xsaW5nLCB1cGRhdGluZyB0aGUgY2FjaGVkIGNvb3JkaW5hdGVzIGlmIGl0IG5lZWRzIHRvLlxuRG9lcyBub3QgYWNjZXNzIHRoZSBET00gYWZ0ZXIgaW5zdGFudGlhdGlvbiwgc28gaGlnaGx5IHBlcmZvcm1hbnQuXG5cbkFsc28ga2VlcHMgdHJhY2sgb2YgYWxsIHNjcm9sbGluZy9vdmVyZmxvdzpoaWRkZW4gY29udGFpbmVycyB0aGF0IGFyZSBwYXJlbnRzIG9mIHRoZSBnaXZlbiBlbGVtZW50XG5hbmQgYW4gZGV0ZXJtaW5lIGlmIGEgZ2l2ZW4gcG9pbnQgaXMgaW5zaWRlIHRoZSBjb21iaW5lZCBjbGlwcGluZyByZWN0YW5nbGUuXG4qL1xuY2xhc3MgT2Zmc2V0VHJhY2tlciB7XG4gICAgY29uc3RydWN0b3IoZWwpIHtcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICB0aGlzLm9yaWdSZWN0ID0gY29tcHV0ZVJlY3QoZWwpO1xuICAgICAgICAvLyB3aWxsIHdvcmsgZmluZSBmb3IgZGl2cyB0aGF0IGhhdmUgb3ZlcmZsb3c6aGlkZGVuXG4gICAgICAgIHRoaXMuc2Nyb2xsQ2FjaGVzID0gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsKS5tYXAoKHNjcm9sbEVsKSA9PiBuZXcgRWxlbWVudFNjcm9sbEdlb21DYWNoZShzY3JvbGxFbCwgdHJ1ZSkpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBmb3IgKGxldCBzY3JvbGxDYWNoZSBvZiB0aGlzLnNjcm9sbENhY2hlcykge1xuICAgICAgICAgICAgc2Nyb2xsQ2FjaGUuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXB1dGVMZWZ0KCkge1xuICAgICAgICBsZXQgbGVmdCA9IHRoaXMub3JpZ1JlY3QubGVmdDtcbiAgICAgICAgZm9yIChsZXQgc2Nyb2xsQ2FjaGUgb2YgdGhpcy5zY3JvbGxDYWNoZXMpIHtcbiAgICAgICAgICAgIGxlZnQgKz0gc2Nyb2xsQ2FjaGUub3JpZ1Njcm9sbExlZnQgLSBzY3JvbGxDYWNoZS5nZXRTY3JvbGxMZWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgfVxuICAgIGNvbXB1dGVUb3AoKSB7XG4gICAgICAgIGxldCB0b3AgPSB0aGlzLm9yaWdSZWN0LnRvcDtcbiAgICAgICAgZm9yIChsZXQgc2Nyb2xsQ2FjaGUgb2YgdGhpcy5zY3JvbGxDYWNoZXMpIHtcbiAgICAgICAgICAgIHRvcCArPSBzY3JvbGxDYWNoZS5vcmlnU2Nyb2xsVG9wIC0gc2Nyb2xsQ2FjaGUuZ2V0U2Nyb2xsVG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvcDtcbiAgICB9XG4gICAgaXNXaXRoaW5DbGlwcGluZyhwYWdlWCwgcGFnZVkpIHtcbiAgICAgICAgbGV0IHBvaW50ID0geyBsZWZ0OiBwYWdlWCwgdG9wOiBwYWdlWSB9O1xuICAgICAgICBmb3IgKGxldCBzY3JvbGxDYWNoZSBvZiB0aGlzLnNjcm9sbENhY2hlcykge1xuICAgICAgICAgICAgaWYgKCFpc0lnbm9yZWRDbGlwcGluZyhzY3JvbGxDYWNoZS5nZXRFdmVudFRhcmdldCgpKSAmJlxuICAgICAgICAgICAgICAgICFwb2ludEluc2lkZVJlY3QocG9pbnQsIHNjcm9sbENhY2hlLmNsaWVudFJlY3QpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbi8vIGNlcnRhaW4gY2xpcHBpbmcgY29udGFpbmVycyBzaG91bGQgbmV2ZXIgY29uc3RyYWluIGludGVyYWN0aW9ucywgbGlrZSA8aHRtbD4gYW5kIDxib2R5PlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Z1bGxjYWxlbmRhci9mdWxsY2FsZW5kYXIvaXNzdWVzLzM2MTVcbmZ1bmN0aW9uIGlzSWdub3JlZENsaXBwaW5nKG5vZGUpIHtcbiAgICBsZXQgdGFnTmFtZSA9IG5vZGUudGFnTmFtZTtcbiAgICByZXR1cm4gdGFnTmFtZSA9PT0gJ0hUTUwnIHx8IHRhZ05hbWUgPT09ICdCT0RZJztcbn1cblxuLypcblRyYWNrcyBtb3ZlbWVudCBvdmVyIG11bHRpcGxlIGRyb3BwYWJsZSBhcmVhcyAoYWthIFwiaGl0c1wiKVxudGhhdCBleGlzdCBpbiBvbmUgb3IgbW9yZSBEYXRlQ29tcG9uZW50cy5cblJlbGllcyBvbiBhbiBleGlzdGluZyBkcmFnZ2FibGUuXG5cbmVtaXRzOlxuLSBwb2ludGVyZG93blxuLSBkcmFnc3RhcnRcbi0gaGl0Y2hhbmdlIC0gZmlyZXMgaW5pdGlhbGx5LCBldmVuIGlmIG5vdCBvdmVyIGEgaGl0XG4tIHBvaW50ZXJ1cFxuLSAoaGl0Y2hhbmdlIC0gYWdhaW4sIHRvIG51bGwsIGlmIGVuZGVkIG92ZXIgYSBoaXQpXG4tIGRyYWdlbmRcbiovXG5jbGFzcyBIaXREcmFnZ2luZyB7XG4gICAgY29uc3RydWN0b3IoZHJhZ2dpbmcsIGRyb3BwYWJsZVN0b3JlKSB7XG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCBjYW4gYmUgc2V0IGJ5IGNhbGxlclxuICAgICAgICB0aGlzLnVzZVN1YmplY3RDZW50ZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZXF1aXJlSW5pdGlhbCA9IHRydWU7IC8vIGlmIGRvZXNuJ3Qgc3RhcnQgb3V0IG9uIGEgaGl0LCB3b24ndCBlbWl0IGFueSBldmVudHNcbiAgICAgICAgdGhpcy5kaXNhYmxlUG9pbnRDaGVjayA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluaXRpYWxIaXQgPSBudWxsO1xuICAgICAgICB0aGlzLm1vdmluZ0hpdCA9IG51bGw7XG4gICAgICAgIHRoaXMuZmluYWxIaXQgPSBudWxsOyAvLyB3b24ndCBldmVyIGJlIHBvcHVsYXRlZCBpZiBzaG91bGRJZ25vcmVNb3ZlXG4gICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlckRvd24gPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGxldCB7IGRyYWdnaW5nIH0gPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsSGl0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubW92aW5nSGl0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZmluYWxIaXQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5wcmVwYXJlSGl0cygpO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzRmlyc3RDb29yZChldik7XG4gICAgICAgICAgICBpZiAodGhpcy5pbml0aWFsSGl0IHx8ICF0aGlzLnJlcXVpcmVJbml0aWFsKSB7XG4gICAgICAgICAgICAgICAgZHJhZ2dpbmcuc2V0SWdub3JlTW92ZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogZmlyZSB0aGlzIGJlZm9yZSBjb21wdXRpbmcgcHJvY2Vzc0ZpcnN0Q29vcmQsIHNvIGxpc3RlbmVycyBjYW4gY2FuY2VsLiB0aGlzIGdldHMgZmlyZWQgYnkgYWxtb3N0IGV2ZXJ5IGhhbmRsZXIgOihcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcmRvd24nLCBldik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkcmFnZ2luZy5zZXRJZ25vcmVNb3ZlKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZURyYWdTdGFydCA9IChldikgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2RyYWdzdGFydCcsIGV2KTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTW92ZShldiwgdHJ1ZSk7IC8vIGZvcmNlID0gZmlyZSBldmVuIGlmIGluaXRpYWxseSBudWxsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlRHJhZ01vdmUgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdkcmFnbW92ZScsIGV2KTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTW92ZShldik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlclVwID0gKGV2KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlbGVhc2VIaXRzKCk7XG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcnVwJywgZXYpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZURyYWdFbmQgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1vdmluZ0hpdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdoaXR1cGRhdGUnLCBudWxsLCB0cnVlLCBldik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZpbmFsSGl0ID0gdGhpcy5tb3ZpbmdIaXQ7XG4gICAgICAgICAgICB0aGlzLm1vdmluZ0hpdCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcignZHJhZ2VuZCcsIGV2KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kcm9wcGFibGVTdG9yZSA9IGRyb3BwYWJsZVN0b3JlO1xuICAgICAgICBkcmFnZ2luZy5lbWl0dGVyLm9uKCdwb2ludGVyZG93bicsIHRoaXMuaGFuZGxlUG9pbnRlckRvd24pO1xuICAgICAgICBkcmFnZ2luZy5lbWl0dGVyLm9uKCdkcmFnc3RhcnQnLCB0aGlzLmhhbmRsZURyYWdTdGFydCk7XG4gICAgICAgIGRyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdtb3ZlJywgdGhpcy5oYW5kbGVEcmFnTW92ZSk7XG4gICAgICAgIGRyYWdnaW5nLmVtaXR0ZXIub24oJ3BvaW50ZXJ1cCcsIHRoaXMuaGFuZGxlUG9pbnRlclVwKTtcbiAgICAgICAgZHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ2VuZCcsIHRoaXMuaGFuZGxlRHJhZ0VuZCk7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBkcmFnZ2luZztcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgLy8gc2V0cyBpbml0aWFsSGl0XG4gICAgLy8gc2V0cyBjb29yZEFkanVzdFxuICAgIHByb2Nlc3NGaXJzdENvb3JkKGV2KSB7XG4gICAgICAgIGxldCBvcmlnUG9pbnQgPSB7IGxlZnQ6IGV2LnBhZ2VYLCB0b3A6IGV2LnBhZ2VZIH07XG4gICAgICAgIGxldCBhZGp1c3RlZFBvaW50ID0gb3JpZ1BvaW50O1xuICAgICAgICBsZXQgc3ViamVjdEVsID0gZXYuc3ViamVjdEVsO1xuICAgICAgICBsZXQgc3ViamVjdFJlY3Q7XG4gICAgICAgIGlmIChzdWJqZWN0RWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkgeyAvLyBpLmUuIG5vdCBhIERvY3VtZW50L1NoYWRvd1Jvb3RcbiAgICAgICAgICAgIHN1YmplY3RSZWN0ID0gY29tcHV0ZVJlY3Qoc3ViamVjdEVsKTtcbiAgICAgICAgICAgIGFkanVzdGVkUG9pbnQgPSBjb25zdHJhaW5Qb2ludChhZGp1c3RlZFBvaW50LCBzdWJqZWN0UmVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGluaXRpYWxIaXQgPSB0aGlzLmluaXRpYWxIaXQgPSB0aGlzLnF1ZXJ5SGl0Rm9yT2Zmc2V0KGFkanVzdGVkUG9pbnQubGVmdCwgYWRqdXN0ZWRQb2ludC50b3ApO1xuICAgICAgICBpZiAoaW5pdGlhbEhpdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudXNlU3ViamVjdENlbnRlciAmJiBzdWJqZWN0UmVjdCkge1xuICAgICAgICAgICAgICAgIGxldCBzbGljZWRTdWJqZWN0UmVjdCA9IGludGVyc2VjdFJlY3RzKHN1YmplY3RSZWN0LCBpbml0aWFsSGl0LnJlY3QpO1xuICAgICAgICAgICAgICAgIGlmIChzbGljZWRTdWJqZWN0UmVjdCkge1xuICAgICAgICAgICAgICAgICAgICBhZGp1c3RlZFBvaW50ID0gZ2V0UmVjdENlbnRlcihzbGljZWRTdWJqZWN0UmVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb29yZEFkanVzdCA9IGRpZmZQb2ludHMoYWRqdXN0ZWRQb2ludCwgb3JpZ1BvaW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29vcmRBZGp1c3QgPSB7IGxlZnQ6IDAsIHRvcDogMCB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZU1vdmUoZXYsIGZvcmNlSGFuZGxlKSB7XG4gICAgICAgIGxldCBoaXQgPSB0aGlzLnF1ZXJ5SGl0Rm9yT2Zmc2V0KGV2LnBhZ2VYICsgdGhpcy5jb29yZEFkanVzdC5sZWZ0LCBldi5wYWdlWSArIHRoaXMuY29vcmRBZGp1c3QudG9wKTtcbiAgICAgICAgaWYgKGZvcmNlSGFuZGxlIHx8ICFpc0hpdHNFcXVhbCh0aGlzLm1vdmluZ0hpdCwgaGl0KSkge1xuICAgICAgICAgICAgdGhpcy5tb3ZpbmdIaXQgPSBoaXQ7XG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcignaGl0dXBkYXRlJywgaGl0LCBmYWxzZSwgZXYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByZXBhcmVIaXRzKCkge1xuICAgICAgICB0aGlzLm9mZnNldFRyYWNrZXJzID0gbWFwSGFzaCh0aGlzLmRyb3BwYWJsZVN0b3JlLCAoaW50ZXJhY3Rpb25TZXR0aW5ncykgPT4ge1xuICAgICAgICAgICAgaW50ZXJhY3Rpb25TZXR0aW5ncy5jb21wb25lbnQucHJlcGFyZUhpdHMoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgT2Zmc2V0VHJhY2tlcihpbnRlcmFjdGlvblNldHRpbmdzLmVsKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbGVhc2VIaXRzKCkge1xuICAgICAgICBsZXQgeyBvZmZzZXRUcmFja2VycyB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgaWQgaW4gb2Zmc2V0VHJhY2tlcnMpIHtcbiAgICAgICAgICAgIG9mZnNldFRyYWNrZXJzW2lkXS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vZmZzZXRUcmFja2VycyA9IHt9O1xuICAgIH1cbiAgICBxdWVyeUhpdEZvck9mZnNldChvZmZzZXRMZWZ0LCBvZmZzZXRUb3ApIHtcbiAgICAgICAgbGV0IHsgZHJvcHBhYmxlU3RvcmUsIG9mZnNldFRyYWNrZXJzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgYmVzdEhpdCA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGlkIGluIGRyb3BwYWJsZVN0b3JlKSB7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50ID0gZHJvcHBhYmxlU3RvcmVbaWRdLmNvbXBvbmVudDtcbiAgICAgICAgICAgIGxldCBvZmZzZXRUcmFja2VyID0gb2Zmc2V0VHJhY2tlcnNbaWRdO1xuICAgICAgICAgICAgaWYgKG9mZnNldFRyYWNrZXIgJiYgLy8gd2Fzbid0IGRlc3Ryb3llZCBtaWQtZHJhZ1xuICAgICAgICAgICAgICAgIG9mZnNldFRyYWNrZXIuaXNXaXRoaW5DbGlwcGluZyhvZmZzZXRMZWZ0LCBvZmZzZXRUb3ApKSB7XG4gICAgICAgICAgICAgICAgbGV0IG9yaWdpbkxlZnQgPSBvZmZzZXRUcmFja2VyLmNvbXB1dGVMZWZ0KCk7XG4gICAgICAgICAgICAgICAgbGV0IG9yaWdpblRvcCA9IG9mZnNldFRyYWNrZXIuY29tcHV0ZVRvcCgpO1xuICAgICAgICAgICAgICAgIGxldCBwb3NpdGlvbkxlZnQgPSBvZmZzZXRMZWZ0IC0gb3JpZ2luTGVmdDtcbiAgICAgICAgICAgICAgICBsZXQgcG9zaXRpb25Ub3AgPSBvZmZzZXRUb3AgLSBvcmlnaW5Ub3A7XG4gICAgICAgICAgICAgICAgbGV0IHsgb3JpZ1JlY3QgfSA9IG9mZnNldFRyYWNrZXI7XG4gICAgICAgICAgICAgICAgbGV0IHdpZHRoID0gb3JpZ1JlY3QucmlnaHQgLSBvcmlnUmVjdC5sZWZ0O1xuICAgICAgICAgICAgICAgIGxldCBoZWlnaHQgPSBvcmlnUmVjdC5ib3R0b20gLSBvcmlnUmVjdC50b3A7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIC8vIG11c3QgYmUgd2l0aGluIHRoZSBlbGVtZW50J3MgYm91bmRzXG4gICAgICAgICAgICAgICAgcG9zaXRpb25MZWZ0ID49IDAgJiYgcG9zaXRpb25MZWZ0IDwgd2lkdGggJiZcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25Ub3AgPj0gMCAmJiBwb3NpdGlvblRvcCA8IGhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaGl0ID0gY29tcG9uZW50LnF1ZXJ5SGl0KHBvc2l0aW9uTGVmdCwgcG9zaXRpb25Ub3AsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGl0ICYmIChcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBoaXQgaXMgd2l0aGluIGFjdGl2ZVJhbmdlLCBtZWFuaW5nIGl0J3Mgbm90IGEgZGVhZCBjZWxsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlQ29udGFpbnNSYW5nZShoaXQuZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UsIGhpdC5kYXRlU3Bhbi5yYW5nZSkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhlIGNvbXBvbmVudCB3ZSBhcmUgcXVlcnlpbmcgZm9yIHRoZSBoaXQgaXMgYWNjZXNzaWJseSBteSB0aGUgcG9pbnRlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudHMgb2JzY3VyZWQgY2FsZW5kYXJzIChleDogdW5kZXIgYSBtb2RhbCBkaWFsb2cpIGZyb20gYWNjZXB0aW5nIGhpdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Z1bGxjYWxlbmRhci9mdWxsY2FsZW5kYXIvaXNzdWVzLzUwMjZcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLmRpc2FibGVQb2ludENoZWNrIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0VHJhY2tlci5lbC5jb250YWlucyhvZmZzZXRUcmFja2VyLmVsLmdldFJvb3ROb2RlKCkuZWxlbWVudEZyb21Qb2ludChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQtYmFjayBvcmlnaW5zIHRvIGdldCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRvcC1sZWZ0IG9mIHdpbmRvdyB2aWV3cG9ydFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uTGVmdCArIG9yaWdpbkxlZnQgLSB3aW5kb3cuc2Nyb2xsWCwgcG9zaXRpb25Ub3AgKyBvcmlnaW5Ub3AgLSB3aW5kb3cuc2Nyb2xsWSkpKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCFiZXN0SGl0IHx8IGhpdC5sYXllciA+IGJlc3RIaXQubGF5ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaXQuY29tcG9uZW50SWQgPSBpZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdC5jb250ZXh0ID0gY29tcG9uZW50LmNvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBiZXR0ZXIgd2F5IHRvIHJlLW9yaWVudCByZWN0YW5nbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdC5yZWN0LmxlZnQgKz0gb3JpZ2luTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdC5yZWN0LnJpZ2h0ICs9IG9yaWdpbkxlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaXQucmVjdC50b3AgKz0gb3JpZ2luVG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGl0LnJlY3QuYm90dG9tICs9IG9yaWdpblRvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RIaXQgPSBoaXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJlc3RIaXQ7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNIaXRzRXF1YWwoaGl0MCwgaGl0MSkge1xuICAgIGlmICghaGl0MCAmJiAhaGl0MSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKEJvb2xlYW4oaGl0MCkgIT09IEJvb2xlYW4oaGl0MSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gaXNEYXRlU3BhbnNFcXVhbChoaXQwLmRhdGVTcGFuLCBoaXQxLmRhdGVTcGFuKTtcbn1cblxuZnVuY3Rpb24gYnVpbGREYXRlUG9pbnRBcGlXaXRoQ29udGV4dChkYXRlU3BhbiwgY29udGV4dCkge1xuICAgIGxldCBwcm9wcyA9IHt9O1xuICAgIGZvciAobGV0IHRyYW5zZm9ybSBvZiBjb250ZXh0LnBsdWdpbkhvb2tzLmRhdGVQb2ludFRyYW5zZm9ybXMpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihwcm9wcywgdHJhbnNmb3JtKGRhdGVTcGFuLCBjb250ZXh0KSk7XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24ocHJvcHMsIGJ1aWxkRGF0ZVBvaW50QXBpKGRhdGVTcGFuLCBjb250ZXh0LmRhdGVFbnYpKTtcbiAgICByZXR1cm4gcHJvcHM7XG59XG5mdW5jdGlvbiBidWlsZERhdGVQb2ludEFwaShzcGFuLCBkYXRlRW52KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGF0ZTogZGF0ZUVudi50b0RhdGUoc3Bhbi5yYW5nZS5zdGFydCksXG4gICAgICAgIGRhdGVTdHI6IGRhdGVFbnYuZm9ybWF0SXNvKHNwYW4ucmFuZ2Uuc3RhcnQsIHsgb21pdFRpbWU6IHNwYW4uYWxsRGF5IH0pLFxuICAgICAgICBhbGxEYXk6IHNwYW4uYWxsRGF5LFxuICAgIH07XG59XG5cbi8qXG5Nb25pdG9ycyB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiBhIHNwZWNpZmljIGRhdGUvdGltZSBvZiBhIGNvbXBvbmVudC5cbkEgcG9pbnRlcmRvd24rcG9pbnRlcnVwIG9uIHRoZSBzYW1lIFwiaGl0XCIgY29uc3RpdHV0ZXMgYSBjbGljay5cbiovXG5jbGFzcyBEYXRlQ2xpY2tpbmcgZXh0ZW5kcyBJbnRlcmFjdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICAgICAgc3VwZXIoc2V0dGluZ3MpO1xuICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJEb3duID0gKHBldikgPT4ge1xuICAgICAgICAgICAgbGV0IHsgZHJhZ2dpbmcgfSA9IHRoaXM7XG4gICAgICAgICAgICBsZXQgZG93bkVsID0gcGV2Lm9yaWdFdmVudC50YXJnZXQ7XG4gICAgICAgICAgICAvLyBkbyB0aGlzIGluIHBvaW50ZXJkb3duIChub3QgZHJhZ2VuZCkgYmVjYXVzZSBET00gbWlnaHQgYmUgbXV0YXRlZCBieSB0aGUgdGltZSBkcmFnZW5kIGlzIGZpcmVkXG4gICAgICAgICAgICBkcmFnZ2luZy5zZXRJZ25vcmVNb3ZlKCF0aGlzLmNvbXBvbmVudC5pc1ZhbGlkRGF0ZURvd25FbChkb3duRWwpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gd29uJ3QgZXZlbiBmaXJlIGlmIG1vdmluZyB3YXMgaWdub3JlZFxuICAgICAgICB0aGlzLmhhbmRsZURyYWdFbmQgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGxldCB7IGNvbXBvbmVudCB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCB7IHBvaW50ZXIgfSA9IHRoaXMuZHJhZ2dpbmc7XG4gICAgICAgICAgICBpZiAoIXBvaW50ZXIud2FzVG91Y2hTY3JvbGwpIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBpbml0aWFsSGl0LCBmaW5hbEhpdCB9ID0gdGhpcy5oaXREcmFnZ2luZztcbiAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbEhpdCAmJiBmaW5hbEhpdCAmJiBpc0hpdHNFcXVhbChpbml0aWFsSGl0LCBmaW5hbEhpdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgY29udGV4dCB9ID0gY29tcG9uZW50O1xuICAgICAgICAgICAgICAgICAgICBsZXQgYXJnID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBidWlsZERhdGVQb2ludEFwaVdpdGhDb250ZXh0KGluaXRpYWxIaXQuZGF0ZVNwYW4sIGNvbnRleHQpKSwgeyBkYXlFbDogaW5pdGlhbEhpdC5kYXlFbCwganNFdmVudDogZXYub3JpZ0V2ZW50LCB2aWV3OiBjb250ZXh0LnZpZXdBcGkgfHwgY29udGV4dC5jYWxlbmRhckFwaS52aWV3IH0pO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZGF0ZUNsaWNrJywgYXJnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIHdlIERPIHdhbnQgdG8gd2F0Y2ggcG9pbnRlciBtb3ZlcyBiZWNhdXNlIG90aGVyd2lzZSBmaW5hbEhpdCB3b24ndCBnZXQgcG9wdWxhdGVkXG4gICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBuZXcgRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZyhzZXR0aW5ncy5lbCk7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcuYXV0b1Njcm9sbGVyLmlzRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgaGl0RHJhZ2dpbmcgPSB0aGlzLmhpdERyYWdnaW5nID0gbmV3IEhpdERyYWdnaW5nKHRoaXMuZHJhZ2dpbmcsIGludGVyYWN0aW9uU2V0dGluZ3NUb1N0b3JlKHNldHRpbmdzKSk7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ3BvaW50ZXJkb3duJywgdGhpcy5oYW5kbGVQb2ludGVyRG93bik7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdlbmQnLCB0aGlzLmhhbmRsZURyYWdFbmQpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRyYWdnaW5nLmRlc3Ryb3koKTtcbiAgICB9XG59XG5cbi8qXG5UcmFja3Mgd2hlbiB0aGUgdXNlciBzZWxlY3RzIGEgcG9ydGlvbiBvZiB0aW1lIG9mIGEgY29tcG9uZW50LFxuY29uc3RpdHV0ZWQgYnkgYSBkcmFnIG92ZXIgZGF0ZSBjZWxscywgd2l0aCBhIHBvc3NpYmxlIGRlbGF5IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRyYWcuXG4qL1xuY2xhc3MgRGF0ZVNlbGVjdGluZyBleHRlbmRzIEludGVyYWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgICAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgICAgIHRoaXMuZHJhZ1NlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlckRvd24gPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGxldCB7IGNvbXBvbmVudCwgZHJhZ2dpbmcgfSA9IHRoaXM7XG4gICAgICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSBjb21wb25lbnQuY29udGV4dDtcbiAgICAgICAgICAgIGxldCBjYW5TZWxlY3QgPSBvcHRpb25zLnNlbGVjdGFibGUgJiZcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuaXNWYWxpZERhdGVEb3duRWwoZXYub3JpZ0V2ZW50LnRhcmdldCk7XG4gICAgICAgICAgICAvLyBkb24ndCBib3RoZXIgdG8gd2F0Y2ggZXhwZW5zaXZlIG1vdmVzIGlmIGNvbXBvbmVudCB3b24ndCBkbyBzZWxlY3Rpb25cbiAgICAgICAgICAgIGRyYWdnaW5nLnNldElnbm9yZU1vdmUoIWNhblNlbGVjdCk7XG4gICAgICAgICAgICAvLyBpZiB0b3VjaCwgcmVxdWlyZSB1c2VyIHRvIGhvbGQgZG93blxuICAgICAgICAgICAgZHJhZ2dpbmcuZGVsYXkgPSBldi5pc1RvdWNoID8gZ2V0Q29tcG9uZW50VG91Y2hEZWxheSQxKGNvbXBvbmVudCkgOiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZURyYWdTdGFydCA9IChldikgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQuY29udGV4dC5jYWxlbmRhckFwaS51bnNlbGVjdChldik7IC8vIHVuc2VsZWN0IHByZXZpb3VzIHNlbGVjdGlvbnNcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVIaXRVcGRhdGUgPSAoaGl0LCBpc0ZpbmFsKSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBjb250ZXh0IH0gPSB0aGlzLmNvbXBvbmVudDtcbiAgICAgICAgICAgIGxldCBkcmFnU2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBpc0ludmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChoaXQpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5pdGlhbEhpdCA9IHRoaXMuaGl0RHJhZ2dpbmcuaW5pdGlhbEhpdDtcbiAgICAgICAgICAgICAgICBsZXQgZGlzYWxsb3dlZCA9IGhpdC5jb21wb25lbnRJZCA9PT0gaW5pdGlhbEhpdC5jb21wb25lbnRJZFxuICAgICAgICAgICAgICAgICAgICAmJiB0aGlzLmlzSGl0Q29tYm9BbGxvd2VkXG4gICAgICAgICAgICAgICAgICAgICYmICF0aGlzLmlzSGl0Q29tYm9BbGxvd2VkKGluaXRpYWxIaXQsIGhpdCk7XG4gICAgICAgICAgICAgICAgaWYgKCFkaXNhbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdTZWxlY3Rpb24gPSBqb2luSGl0c0ludG9TZWxlY3Rpb24oaW5pdGlhbEhpdCwgaGl0LCBjb250ZXh0LnBsdWdpbkhvb2tzLmRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWRyYWdTZWxlY3Rpb24gfHwgIWlzRGF0ZVNlbGVjdGlvblZhbGlkKGRyYWdTZWxlY3Rpb24sIGhpdC5kYXRlUHJvZmlsZSwgY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNJbnZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ1NlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRyYWdTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1NFTEVDVF9EQVRFUycsIHNlbGVjdGlvbjogZHJhZ1NlbGVjdGlvbiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc0ZpbmFsKSB7IC8vIG9ubHkgdW5zZWxlY3QgaWYgbW92ZWQgYXdheSB3aGlsZSBkcmFnZ2luZ1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRUxFQ1RfREFURVMnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0ludmFsaWQpIHtcbiAgICAgICAgICAgICAgICBlbmFibGVDdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpc2FibGVDdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNGaW5hbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ1NlbGVjdGlvbiA9IGRyYWdTZWxlY3Rpb247IC8vIG9ubHkgY2xlYXIgaWYgbW92ZWQgYXdheSBmcm9tIGFsbCBoaXRzIHdoaWxlIGRyYWdnaW5nXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlclVwID0gKHBldikgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuZHJhZ1NlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIHNlbGVjdGlvbiBpcyBhbHJlYWR5IHJlbmRlcmVkLCBzbyBqdXN0IG5lZWQgdG8gcmVwb3J0IHNlbGVjdGlvblxuICAgICAgICAgICAgICAgIHRyaWdnZXJEYXRlU2VsZWN0KHRoaXMuZHJhZ1NlbGVjdGlvbiwgcGV2LCB0aGlzLmNvbXBvbmVudC5jb250ZXh0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsZXQgeyBjb21wb25lbnQgfSA9IHNldHRpbmdzO1xuICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSBjb21wb25lbnQuY29udGV4dDtcbiAgICAgICAgbGV0IGRyYWdnaW5nID0gdGhpcy5kcmFnZ2luZyA9IG5ldyBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nKHNldHRpbmdzLmVsKTtcbiAgICAgICAgZHJhZ2dpbmcudG91Y2hTY3JvbGxBbGxvd2VkID0gZmFsc2U7XG4gICAgICAgIGRyYWdnaW5nLm1pbkRpc3RhbmNlID0gb3B0aW9ucy5zZWxlY3RNaW5EaXN0YW5jZSB8fCAwO1xuICAgICAgICBkcmFnZ2luZy5hdXRvU2Nyb2xsZXIuaXNFbmFibGVkID0gb3B0aW9ucy5kcmFnU2Nyb2xsO1xuICAgICAgICBsZXQgaGl0RHJhZ2dpbmcgPSB0aGlzLmhpdERyYWdnaW5nID0gbmV3IEhpdERyYWdnaW5nKHRoaXMuZHJhZ2dpbmcsIGludGVyYWN0aW9uU2V0dGluZ3NUb1N0b3JlKHNldHRpbmdzKSk7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ3BvaW50ZXJkb3duJywgdGhpcy5oYW5kbGVQb2ludGVyRG93bik7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdzdGFydCcsIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0KTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignaGl0dXBkYXRlJywgdGhpcy5oYW5kbGVIaXRVcGRhdGUpO1xuICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdwb2ludGVydXAnLCB0aGlzLmhhbmRsZVBvaW50ZXJVcCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcuZGVzdHJveSgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldENvbXBvbmVudFRvdWNoRGVsYXkkMShjb21wb25lbnQpIHtcbiAgICBsZXQgeyBvcHRpb25zIH0gPSBjb21wb25lbnQuY29udGV4dDtcbiAgICBsZXQgZGVsYXkgPSBvcHRpb25zLnNlbGVjdExvbmdQcmVzc0RlbGF5O1xuICAgIGlmIChkZWxheSA9PSBudWxsKSB7XG4gICAgICAgIGRlbGF5ID0gb3B0aW9ucy5sb25nUHJlc3NEZWxheTtcbiAgICB9XG4gICAgcmV0dXJuIGRlbGF5O1xufVxuZnVuY3Rpb24gam9pbkhpdHNJbnRvU2VsZWN0aW9uKGhpdDAsIGhpdDEsIGRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnMpIHtcbiAgICBsZXQgZGF0ZVNwYW4wID0gaGl0MC5kYXRlU3BhbjtcbiAgICBsZXQgZGF0ZVNwYW4xID0gaGl0MS5kYXRlU3BhbjtcbiAgICBsZXQgbXMgPSBbXG4gICAgICAgIGRhdGVTcGFuMC5yYW5nZS5zdGFydCxcbiAgICAgICAgZGF0ZVNwYW4wLnJhbmdlLmVuZCxcbiAgICAgICAgZGF0ZVNwYW4xLnJhbmdlLnN0YXJ0LFxuICAgICAgICBkYXRlU3BhbjEucmFuZ2UuZW5kLFxuICAgIF07XG4gICAgbXMuc29ydChjb21wYXJlTnVtYmVycyk7XG4gICAgbGV0IHByb3BzID0ge307XG4gICAgZm9yIChsZXQgdHJhbnNmb3JtZXIgb2YgZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVycykge1xuICAgICAgICBsZXQgcmVzID0gdHJhbnNmb3JtZXIoaGl0MCwgaGl0MSk7XG4gICAgICAgIGlmIChyZXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHByb3BzLCByZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb3BzLnJhbmdlID0geyBzdGFydDogbXNbMF0sIGVuZDogbXNbM10gfTtcbiAgICBwcm9wcy5hbGxEYXkgPSBkYXRlU3BhbjAuYWxsRGF5O1xuICAgIHJldHVybiBwcm9wcztcbn1cblxuY2xhc3MgRXZlbnREcmFnZ2luZyBleHRlbmRzIEludGVyYWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgICAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgICAgIC8vIGludGVybmFsIHN0YXRlXG4gICAgICAgIHRoaXMuc3ViamVjdEVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdWJqZWN0U2VnID0gbnVsbDsgLy8gdGhlIHNlZyBiZWluZyBzZWxlY3RlZC9kcmFnZ2VkXG4gICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmV2ZW50UmFuZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLnJlbGV2YW50RXZlbnRzID0gbnVsbDsgLy8gdGhlIGV2ZW50cyBiZWluZyBkcmFnZ2VkXG4gICAgICAgIHRoaXMucmVjZWl2aW5nQ29udGV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMudmFsaWRNdXRhdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMubXV0YXRlZFJlbGV2YW50RXZlbnRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyRG93biA9IChldikgPT4ge1xuICAgICAgICAgICAgbGV0IG9yaWdUYXJnZXQgPSBldi5vcmlnRXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgbGV0IHsgY29tcG9uZW50LCBkcmFnZ2luZyB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCB7IG1pcnJvciB9ID0gZHJhZ2dpbmc7XG4gICAgICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSBjb21wb25lbnQuY29udGV4dDtcbiAgICAgICAgICAgIGxldCBpbml0aWFsQ29udGV4dCA9IGNvbXBvbmVudC5jb250ZXh0O1xuICAgICAgICAgICAgdGhpcy5zdWJqZWN0RWwgPSBldi5zdWJqZWN0RWw7XG4gICAgICAgICAgICBsZXQgc3ViamVjdFNlZyA9IHRoaXMuc3ViamVjdFNlZyA9IGdldEVsU2VnKGV2LnN1YmplY3RFbCk7XG4gICAgICAgICAgICBsZXQgZXZlbnRSYW5nZSA9IHRoaXMuZXZlbnRSYW5nZSA9IHN1YmplY3RTZWcuZXZlbnRSYW5nZTtcbiAgICAgICAgICAgIGxldCBldmVudEluc3RhbmNlSWQgPSBldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWQ7XG4gICAgICAgICAgICB0aGlzLnJlbGV2YW50RXZlbnRzID0gZ2V0UmVsZXZhbnRFdmVudHMoaW5pdGlhbENvbnRleHQuZ2V0Q3VycmVudERhdGEoKS5ldmVudFN0b3JlLCBldmVudEluc3RhbmNlSWQpO1xuICAgICAgICAgICAgZHJhZ2dpbmcubWluRGlzdGFuY2UgPSBldi5pc1RvdWNoID8gMCA6IG9wdGlvbnMuZXZlbnREcmFnTWluRGlzdGFuY2U7XG4gICAgICAgICAgICBkcmFnZ2luZy5kZWxheSA9XG4gICAgICAgICAgICAgICAgLy8gb25seSBkbyBhIHRvdWNoIGRlbGF5IGlmIHRvdWNoIGFuZCB0aGlzIGV2ZW50IGhhc24ndCBiZWVuIHNlbGVjdGVkIHlldFxuICAgICAgICAgICAgICAgIChldi5pc1RvdWNoICYmIGV2ZW50SW5zdGFuY2VJZCAhPT0gY29tcG9uZW50LnByb3BzLmV2ZW50U2VsZWN0aW9uKSA/XG4gICAgICAgICAgICAgICAgICAgIGdldENvbXBvbmVudFRvdWNoRGVsYXkoY29tcG9uZW50KSA6XG4gICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5maXhlZE1pcnJvclBhcmVudCkge1xuICAgICAgICAgICAgICAgIG1pcnJvci5wYXJlbnROb2RlID0gb3B0aW9ucy5maXhlZE1pcnJvclBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1pcnJvci5wYXJlbnROb2RlID0gZWxlbWVudENsb3Nlc3Qob3JpZ1RhcmdldCwgJy5mYycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWlycm9yLnJldmVydER1cmF0aW9uID0gb3B0aW9ucy5kcmFnUmV2ZXJ0RHVyYXRpb247XG4gICAgICAgICAgICBsZXQgaXNWYWxpZCA9IGNvbXBvbmVudC5pc1ZhbGlkU2VnRG93bkVsKG9yaWdUYXJnZXQpICYmXG4gICAgICAgICAgICAgICAgIWVsZW1lbnRDbG9zZXN0KG9yaWdUYXJnZXQsICcuZmMtZXZlbnQtcmVzaXplcicpOyAvLyBOT1Qgb24gYSByZXNpemVyXG4gICAgICAgICAgICBkcmFnZ2luZy5zZXRJZ25vcmVNb3ZlKCFpc1ZhbGlkKTtcbiAgICAgICAgICAgIC8vIGRpc2FibGUgZHJhZ2dpbmcgZm9yIGVsZW1lbnRzIHRoYXQgYXJlIHJlc2l6YWJsZSAoaWUsIHNlbGVjdGFibGUpXG4gICAgICAgICAgICAvLyBidXQgYXJlIG5vdCBkcmFnZ2FibGVcbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGlzVmFsaWQgJiZcbiAgICAgICAgICAgICAgICBldi5zdWJqZWN0RWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdmYy1ldmVudC1kcmFnZ2FibGUnKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVEcmFnU3RhcnQgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGxldCBpbml0aWFsQ29udGV4dCA9IHRoaXMuY29tcG9uZW50LmNvbnRleHQ7XG4gICAgICAgICAgICBsZXQgZXZlbnRSYW5nZSA9IHRoaXMuZXZlbnRSYW5nZTtcbiAgICAgICAgICAgIGxldCBldmVudEluc3RhbmNlSWQgPSBldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWQ7XG4gICAgICAgICAgICBpZiAoZXYuaXNUb3VjaCkge1xuICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gc2VsZWN0IGEgZGlmZmVyZW50IGV2ZW50P1xuICAgICAgICAgICAgICAgIGlmIChldmVudEluc3RhbmNlSWQgIT09IHRoaXMuY29tcG9uZW50LnByb3BzLmV2ZW50U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1NFTEVDVF9FVkVOVCcsIGV2ZW50SW5zdGFuY2VJZCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBub3cgdXNpbmcgbW91c2UsIGJ1dCB3YXMgcHJldmlvdXMgdG91Y2ggaW50ZXJhY3Rpb24sIGNsZWFyIHNlbGVjdGVkIGV2ZW50XG4gICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRUxFQ1RfRVZFTlQnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZykge1xuICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0LmNhbGVuZGFyQXBpLnVuc2VsZWN0KGV2KTsgLy8gdW5zZWxlY3QgKmRhdGUqIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnREcmFnU3RhcnQnLCB7XG4gICAgICAgICAgICAgICAgICAgIGVsOiB0aGlzLnN1YmplY3RFbCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IG5ldyBFdmVudEltcGwoaW5pdGlhbENvbnRleHQsIGV2ZW50UmFuZ2UuZGVmLCBldmVudFJhbmdlLmluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICAgICAganNFdmVudDogZXYub3JpZ0V2ZW50LFxuICAgICAgICAgICAgICAgICAgICB2aWV3OiBpbml0aWFsQ29udGV4dC52aWV3QXBpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUhpdFVwZGF0ZSA9IChoaXQsIGlzRmluYWwpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlbGV2YW50RXZlbnRzID0gdGhpcy5yZWxldmFudEV2ZW50cztcbiAgICAgICAgICAgIGxldCBpbml0aWFsSGl0ID0gdGhpcy5oaXREcmFnZ2luZy5pbml0aWFsSGl0O1xuICAgICAgICAgICAgbGV0IGluaXRpYWxDb250ZXh0ID0gdGhpcy5jb21wb25lbnQuY29udGV4dDtcbiAgICAgICAgICAgIC8vIHN0YXRlcyBiYXNlZCBvbiBuZXcgaGl0XG4gICAgICAgICAgICBsZXQgcmVjZWl2aW5nQ29udGV4dCA9IG51bGw7XG4gICAgICAgICAgICBsZXQgbXV0YXRpb24gPSBudWxsO1xuICAgICAgICAgICAgbGV0IG11dGF0ZWRSZWxldmFudEV2ZW50cyA9IG51bGw7XG4gICAgICAgICAgICBsZXQgaXNJbnZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgaW50ZXJhY3Rpb24gPSB7XG4gICAgICAgICAgICAgICAgYWZmZWN0ZWRFdmVudHM6IHJlbGV2YW50RXZlbnRzLFxuICAgICAgICAgICAgICAgIG11dGF0ZWRFdmVudHM6IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpLFxuICAgICAgICAgICAgICAgIGlzRXZlbnQ6IHRydWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGhpdCkge1xuICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQgPSBoaXQuY29udGV4dDtcbiAgICAgICAgICAgICAgICBsZXQgcmVjZWl2aW5nT3B0aW9ucyA9IHJlY2VpdmluZ0NvbnRleHQub3B0aW9ucztcbiAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbENvbnRleHQgPT09IHJlY2VpdmluZ0NvbnRleHQgfHxcbiAgICAgICAgICAgICAgICAgICAgKHJlY2VpdmluZ09wdGlvbnMuZWRpdGFibGUgJiYgcmVjZWl2aW5nT3B0aW9ucy5kcm9wcGFibGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG11dGF0aW9uID0gY29tcHV0ZUV2ZW50TXV0YXRpb24oaW5pdGlhbEhpdCwgaGl0LCB0aGlzLmV2ZW50UmFuZ2UuaW5zdGFuY2UucmFuZ2Uuc3RhcnQsIHJlY2VpdmluZ0NvbnRleHQuZ2V0Q3VycmVudERhdGEoKS5wbHVnaW5Ib29rcy5ldmVudERyYWdNdXRhdGlvbk1hc3NhZ2Vycyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtdXRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRlZFJlbGV2YW50RXZlbnRzID0gYXBwbHlNdXRhdGlvblRvRXZlbnRTdG9yZShyZWxldmFudEV2ZW50cywgcmVjZWl2aW5nQ29udGV4dC5nZXRDdXJyZW50RGF0YSgpLmV2ZW50VWlCYXNlcywgbXV0YXRpb24sIHJlY2VpdmluZ0NvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cyA9IG11dGF0ZWRSZWxldmFudEV2ZW50cztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNJbnRlcmFjdGlvblZhbGlkKGludGVyYWN0aW9uLCBoaXQuZGF0ZVByb2ZpbGUsIHJlY2VpdmluZ0NvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNJbnZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRlZFJlbGV2YW50RXZlbnRzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGlzcGxheURyYWcocmVjZWl2aW5nQ29udGV4dCwgaW50ZXJhY3Rpb24pO1xuICAgICAgICAgICAgaWYgKCFpc0ludmFsaWQpIHtcbiAgICAgICAgICAgICAgICBlbmFibGVDdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpc2FibGVDdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNGaW5hbCkge1xuICAgICAgICAgICAgICAgIGlmIChpbml0aWFsQ29udGV4dCA9PT0gcmVjZWl2aW5nQ29udGV4dCAmJiAvLyBUT0RPOiB3cml0ZSB0ZXN0IGZvciB0aGlzXG4gICAgICAgICAgICAgICAgICAgIGlzSGl0c0VxdWFsKGluaXRpYWxIaXQsIGhpdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbXV0YXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdnaW5nLnNldE1pcnJvck5lZWRzUmV2ZXJ0KCFtdXRhdGlvbik7XG4gICAgICAgICAgICAgICAgLy8gcmVuZGVyIHRoZSBtaXJyb3IgaWYgbm8gYWxyZWFkeS1yZW5kZXJlZCBtaXJyb3JcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiB3aXNoIHdlIGNvdWxkIHNvbWVob3cgd2FpdCBmb3IgZGlzcGF0Y2ggdG8gZ3VhcmFudGVlIHJlbmRlclxuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcuc2V0TWlycm9ySXNWaXNpYmxlKCFoaXQgfHwgIXRoaXMuc3ViamVjdEVsLmdldFJvb3ROb2RlKCkucXVlcnlTZWxlY3RvcignLmZjLWV2ZW50LW1pcnJvcicpKTtcbiAgICAgICAgICAgICAgICAvLyBhc3NpZ24gc3RhdGVzIGJhc2VkIG9uIG5ldyBoaXRcbiAgICAgICAgICAgICAgICB0aGlzLnJlY2VpdmluZ0NvbnRleHQgPSByZWNlaXZpbmdDb250ZXh0O1xuICAgICAgICAgICAgICAgIHRoaXMudmFsaWRNdXRhdGlvbiA9IG11dGF0aW9uO1xuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlZFJlbGV2YW50RXZlbnRzID0gbXV0YXRlZFJlbGV2YW50RXZlbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJVcCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhbnVwKCk7IC8vIGJlY2F1c2UgaGFuZGxlRHJhZ0VuZCB3b24ndCBmaXJlXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlRHJhZ0VuZCA9IChldikgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZykge1xuICAgICAgICAgICAgICAgIGxldCBpbml0aWFsQ29udGV4dCA9IHRoaXMuY29tcG9uZW50LmNvbnRleHQ7XG4gICAgICAgICAgICAgICAgbGV0IGluaXRpYWxWaWV3ID0gaW5pdGlhbENvbnRleHQudmlld0FwaTtcbiAgICAgICAgICAgICAgICBsZXQgeyByZWNlaXZpbmdDb250ZXh0LCB2YWxpZE11dGF0aW9uIH0gPSB0aGlzO1xuICAgICAgICAgICAgICAgIGxldCBldmVudERlZiA9IHRoaXMuZXZlbnRSYW5nZS5kZWY7XG4gICAgICAgICAgICAgICAgbGV0IGV2ZW50SW5zdGFuY2UgPSB0aGlzLmV2ZW50UmFuZ2UuaW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgbGV0IGV2ZW50QXBpID0gbmV3IEV2ZW50SW1wbChpbml0aWFsQ29udGV4dCwgZXZlbnREZWYsIGV2ZW50SW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIGxldCByZWxldmFudEV2ZW50cyA9IHRoaXMucmVsZXZhbnRFdmVudHM7XG4gICAgICAgICAgICAgICAgbGV0IG11dGF0ZWRSZWxldmFudEV2ZW50cyA9IHRoaXMubXV0YXRlZFJlbGV2YW50RXZlbnRzO1xuICAgICAgICAgICAgICAgIGxldCB7IGZpbmFsSGl0IH0gPSB0aGlzLmhpdERyYWdnaW5nO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJEcmFnKCk7IC8vIG11c3QgaGFwcGVuIGFmdGVyIHJldmVydCBhbmltYXRpb25cbiAgICAgICAgICAgICAgICBpbml0aWFsQ29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50RHJhZ1N0b3AnLCB7XG4gICAgICAgICAgICAgICAgICAgIGVsOiB0aGlzLnN1YmplY3RFbCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50QXBpLFxuICAgICAgICAgICAgICAgICAgICBqc0V2ZW50OiBldi5vcmlnRXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIHZpZXc6IGluaXRpYWxWaWV3LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh2YWxpZE11dGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRyb3BwZWQgd2l0aGluIHNhbWUgY2FsZW5kYXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY2VpdmluZ0NvbnRleHQgPT09IGluaXRpYWxDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdXBkYXRlZEV2ZW50QXBpID0gbmV3IEV2ZW50SW1wbChpbml0aWFsQ29udGV4dCwgbXV0YXRlZFJlbGV2YW50RXZlbnRzLmRlZnNbZXZlbnREZWYuZGVmSWRdLCBldmVudEluc3RhbmNlID8gbXV0YXRlZFJlbGV2YW50RXZlbnRzLmluc3RhbmNlc1tldmVudEluc3RhbmNlLmluc3RhbmNlSWRdIDogbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsQ29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ01FUkdFX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogbXV0YXRlZFJlbGV2YW50RXZlbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZXZlbnRDaGFuZ2VBcmcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkRXZlbnQ6IGV2ZW50QXBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiB1cGRhdGVkRXZlbnRBcGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRlZEV2ZW50czogYnVpbGRFdmVudEFwaXMobXV0YXRlZFJlbGV2YW50RXZlbnRzLCBpbml0aWFsQ29udGV4dCwgZXZlbnRJbnN0YW5jZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJ0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsQ29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTUVSR0VfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IHJlbGV2YW50RXZlbnRzLCAvLyB0aGUgcHJlLWNoYW5nZSBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRyYW5zZm9ybWVkID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB0cmFuc2Zvcm1lciBvZiBpbml0aWFsQ29udGV4dC5nZXRDdXJyZW50RGF0YSgpLnBsdWdpbkhvb2tzLmV2ZW50RHJvcFRyYW5zZm9ybWVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHJhbnNmb3JtZWQsIHRyYW5zZm9ybWVyKHZhbGlkTXV0YXRpb24sIGluaXRpYWxDb250ZXh0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsQ29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50RHJvcCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBldmVudENoYW5nZUFyZyksIHRyYW5zZm9ybWVkKSwgeyBlbDogZXYuc3ViamVjdEVsLCBkZWx0YTogdmFsaWRNdXRhdGlvbi5kYXRlc0RlbHRhLCBqc0V2ZW50OiBldi5vcmlnRXZlbnQsIHZpZXc6IGluaXRpYWxWaWV3IH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRDaGFuZ2UnLCBldmVudENoYW5nZUFyZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkcm9wcGVkIGluIGRpZmZlcmVudCBjYWxlbmRhclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlY2VpdmluZ0NvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBldmVudFJlbW92ZUFyZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDogZXZlbnRBcGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRlZEV2ZW50czogYnVpbGRFdmVudEFwaXMocmVsZXZhbnRFdmVudHMsIGluaXRpYWxDb250ZXh0LCBldmVudEluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdNRVJHRV9FVkVOVFMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogcmVsZXZhbnRFdmVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudExlYXZlJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBldmVudFJlbW92ZUFyZyksIHsgZHJhZ2dlZEVsOiBldi5zdWJqZWN0RWwsIHZpZXc6IGluaXRpYWxWaWV3IH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnUkVNT1ZFX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogcmVsZXZhbnRFdmVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRSZW1vdmUnLCBldmVudFJlbW92ZUFyZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYWRkZWRFdmVudERlZiA9IG11dGF0ZWRSZWxldmFudEV2ZW50cy5kZWZzW2V2ZW50RGVmLmRlZklkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhZGRlZEV2ZW50SW5zdGFuY2UgPSBtdXRhdGVkUmVsZXZhbnRFdmVudHMuaW5zdGFuY2VzW2V2ZW50SW5zdGFuY2UuaW5zdGFuY2VJZF07XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYWRkZWRFdmVudEFwaSA9IG5ldyBFdmVudEltcGwocmVjZWl2aW5nQ29udGV4dCwgYWRkZWRFdmVudERlZiwgYWRkZWRFdmVudEluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdNRVJHRV9FVkVOVFMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IG11dGF0ZWRSZWxldmFudEV2ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGV2ZW50QWRkQXJnID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBhZGRlZEV2ZW50QXBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0ZWRFdmVudHM6IGJ1aWxkRXZlbnRBcGlzKG11dGF0ZWRSZWxldmFudEV2ZW50cywgcmVjZWl2aW5nQ29udGV4dCwgYWRkZWRFdmVudEluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1JFTU9WRV9FVkVOVFMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogbXV0YXRlZFJlbGV2YW50RXZlbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudEFkZCcsIGV2ZW50QWRkQXJnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldi5pc1RvdWNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdTRUxFQ1RfRVZFTlQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudEluc3RhbmNlSWQ6IGV2ZW50SW5zdGFuY2UuaW5zdGFuY2VJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdkcm9wJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBidWlsZERhdGVQb2ludEFwaVdpdGhDb250ZXh0KGZpbmFsSGl0LmRhdGVTcGFuLCByZWNlaXZpbmdDb250ZXh0KSksIHsgZHJhZ2dlZEVsOiBldi5zdWJqZWN0RWwsIGpzRXZlbnQ6IGV2Lm9yaWdFdmVudCwgdmlldzogZmluYWxIaXQuY29udGV4dC52aWV3QXBpIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudFJlY2VpdmUnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV2ZW50QWRkQXJnKSwgeyBkcmFnZ2VkRWw6IGV2LnN1YmplY3RFbCwgdmlldzogZmluYWxIaXQuY29udGV4dC52aWV3QXBpIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdfbm9FdmVudERyb3AnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHsgY29tcG9uZW50IH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSBjb21wb25lbnQuY29udGV4dDtcbiAgICAgICAgbGV0IGRyYWdnaW5nID0gdGhpcy5kcmFnZ2luZyA9IG5ldyBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nKHNldHRpbmdzLmVsKTtcbiAgICAgICAgZHJhZ2dpbmcucG9pbnRlci5zZWxlY3RvciA9IEV2ZW50RHJhZ2dpbmcuU0VMRUNUT1I7XG4gICAgICAgIGRyYWdnaW5nLnRvdWNoU2Nyb2xsQWxsb3dlZCA9IGZhbHNlO1xuICAgICAgICBkcmFnZ2luZy5hdXRvU2Nyb2xsZXIuaXNFbmFibGVkID0gb3B0aW9ucy5kcmFnU2Nyb2xsO1xuICAgICAgICBsZXQgaGl0RHJhZ2dpbmcgPSB0aGlzLmhpdERyYWdnaW5nID0gbmV3IEhpdERyYWdnaW5nKHRoaXMuZHJhZ2dpbmcsIGludGVyYWN0aW9uU2V0dGluZ3NTdG9yZSk7XG4gICAgICAgIGhpdERyYWdnaW5nLnVzZVN1YmplY3RDZW50ZXIgPSBzZXR0aW5ncy51c2VFdmVudENlbnRlcjtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCB0aGlzLmhhbmRsZVBvaW50ZXJEb3duKTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ3N0YXJ0JywgdGhpcy5oYW5kbGVEcmFnU3RhcnQpO1xuICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdoaXR1cGRhdGUnLCB0aGlzLmhhbmRsZUhpdFVwZGF0ZSk7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ3BvaW50ZXJ1cCcsIHRoaXMuaGFuZGxlUG9pbnRlclVwKTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ2VuZCcsIHRoaXMuaGFuZGxlRHJhZ0VuZCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcuZGVzdHJveSgpO1xuICAgIH1cbiAgICAvLyByZW5kZXIgYSBkcmFnIHN0YXRlIG9uIHRoZSBuZXh0IHJlY2VpdmluZ0NhbGVuZGFyXG4gICAgZGlzcGxheURyYWcobmV4dENvbnRleHQsIHN0YXRlKSB7XG4gICAgICAgIGxldCBpbml0aWFsQ29udGV4dCA9IHRoaXMuY29tcG9uZW50LmNvbnRleHQ7XG4gICAgICAgIGxldCBwcmV2Q29udGV4dCA9IHRoaXMucmVjZWl2aW5nQ29udGV4dDtcbiAgICAgICAgLy8gZG9lcyB0aGUgcHJldmlvdXMgY2FsZW5kYXIgbmVlZCB0byBiZSBjbGVhcmVkP1xuICAgICAgICBpZiAocHJldkNvbnRleHQgJiYgcHJldkNvbnRleHQgIT09IG5leHRDb250ZXh0KSB7XG4gICAgICAgICAgICAvLyBkb2VzIHRoZSBpbml0aWFsIGNhbGVuZGFyIG5lZWQgdG8gYmUgY2xlYXJlZD9cbiAgICAgICAgICAgIC8vIGlmIHNvLCBkb24ndCBjbGVhciBhbGwgdGhlIHdheS4gd2Ugc3RpbGwgbmVlZCB0byB0byBoaWRlIHRoZSBhZmZlY3RlZEV2ZW50c1xuICAgICAgICAgICAgaWYgKHByZXZDb250ZXh0ID09PSBpbml0aWFsQ29udGV4dCkge1xuICAgICAgICAgICAgICAgIHByZXZDb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1NFVF9FVkVOVF9EUkFHJyxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmZmVjdGVkRXZlbnRzOiBzdGF0ZS5hZmZlY3RlZEV2ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0ZWRFdmVudHM6IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNFdmVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBjb21wbGV0ZWx5IGNsZWFyIHRoZSBvbGQgY2FsZW5kYXIgaWYgaXQgd2Fzbid0IHRoZSBpbml0aWFsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmV2Q29udGV4dC5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFVF9FVkVOVF9EUkFHJyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dENvbnRleHQpIHtcbiAgICAgICAgICAgIG5leHRDb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1NFVF9FVkVOVF9EUkFHJywgc3RhdGUgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xlYXJEcmFnKCkge1xuICAgICAgICBsZXQgaW5pdGlhbENhbGVuZGFyID0gdGhpcy5jb21wb25lbnQuY29udGV4dDtcbiAgICAgICAgbGV0IHsgcmVjZWl2aW5nQ29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgaWYgKHJlY2VpdmluZ0NvbnRleHQpIHtcbiAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRVRfRVZFTlRfRFJBRycgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlIGluaXRpYWwgY2FsZW5kYXIgbWlnaHQgaGF2ZSBhbiBkdW1teSBkcmFnIHN0YXRlIGZyb20gZGlzcGxheURyYWdcbiAgICAgICAgaWYgKGluaXRpYWxDYWxlbmRhciAhPT0gcmVjZWl2aW5nQ29udGV4dCkge1xuICAgICAgICAgICAgaW5pdGlhbENhbGVuZGFyLmRpc3BhdGNoKHsgdHlwZTogJ1VOU0VUX0VWRU5UX0RSQUcnIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsZWFudXAoKSB7XG4gICAgICAgIHRoaXMuc3ViamVjdFNlZyA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmV2ZW50UmFuZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLnJlbGV2YW50RXZlbnRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWNlaXZpbmdDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy52YWxpZE11dGF0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5tdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBudWxsO1xuICAgIH1cbn1cbi8vIFRPRE86IHRlc3QgdGhpcyBpbiBJRTExXG4vLyBRVUVTVElPTjogd2h5IGRvIHdlIG5lZWQgaXQgb24gdGhlIHJlc2l6YWJsZT8/P1xuRXZlbnREcmFnZ2luZy5TRUxFQ1RPUiA9ICcuZmMtZXZlbnQtZHJhZ2dhYmxlLCAuZmMtZXZlbnQtcmVzaXphYmxlJztcbmZ1bmN0aW9uIGNvbXB1dGVFdmVudE11dGF0aW9uKGhpdDAsIGhpdDEsIGV2ZW50SW5zdGFuY2VTdGFydCwgbWFzc2FnZXJzKSB7XG4gICAgbGV0IGRhdGVTcGFuMCA9IGhpdDAuZGF0ZVNwYW47XG4gICAgbGV0IGRhdGVTcGFuMSA9IGhpdDEuZGF0ZVNwYW47XG4gICAgbGV0IGRhdGUwID0gZGF0ZVNwYW4wLnJhbmdlLnN0YXJ0O1xuICAgIGxldCBkYXRlMSA9IGRhdGVTcGFuMS5yYW5nZS5zdGFydDtcbiAgICBsZXQgc3RhbmRhcmRQcm9wcyA9IHt9O1xuICAgIGlmIChkYXRlU3BhbjAuYWxsRGF5ICE9PSBkYXRlU3BhbjEuYWxsRGF5KSB7XG4gICAgICAgIHN0YW5kYXJkUHJvcHMuYWxsRGF5ID0gZGF0ZVNwYW4xLmFsbERheTtcbiAgICAgICAgc3RhbmRhcmRQcm9wcy5oYXNFbmQgPSBoaXQxLmNvbnRleHQub3B0aW9ucy5hbGxEYXlNYWludGFpbkR1cmF0aW9uO1xuICAgICAgICBpZiAoZGF0ZVNwYW4xLmFsbERheSkge1xuICAgICAgICAgICAgLy8gbWVhbnMgZGF0ZTEgaXMgYWxyZWFkeSBzdGFydC1vZi1kYXksXG4gICAgICAgICAgICAvLyBidXQgZGF0ZTAgbmVlZHMgdG8gYmUgY29udmVydGVkXG4gICAgICAgICAgICBkYXRlMCA9IHN0YXJ0T2ZEYXkoZXZlbnRJbnN0YW5jZVN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE1vdmluZyBmcm9tIGFsbERhdGUtPnRpbWVkXG4gICAgICAgICAgICAvLyBEb2Vzbid0IG1hdHRlciB3aGVyZSBvbiB0aGUgZXZlbnQgdGhlIGRyYWcgYmVnYW4sIG11dGF0ZSB0aGUgZXZlbnQncyBzdGFydC1kYXRlIHRvIGRhdGUxXG4gICAgICAgICAgICBkYXRlMCA9IGV2ZW50SW5zdGFuY2VTdGFydDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgZGVsdGEgPSBkaWZmRGF0ZXMoZGF0ZTAsIGRhdGUxLCBoaXQwLmNvbnRleHQuZGF0ZUVudiwgaGl0MC5jb21wb25lbnRJZCA9PT0gaGl0MS5jb21wb25lbnRJZCA/XG4gICAgICAgIGhpdDAubGFyZ2VVbml0IDpcbiAgICAgICAgbnVsbCk7XG4gICAgaWYgKGRlbHRhLm1pbGxpc2Vjb25kcykgeyAvLyBoYXMgaG91cnMvbWludXRlcy9zZWNvbmRzXG4gICAgICAgIHN0YW5kYXJkUHJvcHMuYWxsRGF5ID0gZmFsc2U7XG4gICAgfVxuICAgIGxldCBtdXRhdGlvbiA9IHtcbiAgICAgICAgZGF0ZXNEZWx0YTogZGVsdGEsXG4gICAgICAgIHN0YW5kYXJkUHJvcHMsXG4gICAgfTtcbiAgICBmb3IgKGxldCBtYXNzYWdlciBvZiBtYXNzYWdlcnMpIHtcbiAgICAgICAgbWFzc2FnZXIobXV0YXRpb24sIGhpdDAsIGhpdDEpO1xuICAgIH1cbiAgICByZXR1cm4gbXV0YXRpb247XG59XG5mdW5jdGlvbiBnZXRDb21wb25lbnRUb3VjaERlbGF5KGNvbXBvbmVudCkge1xuICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbXBvbmVudC5jb250ZXh0O1xuICAgIGxldCBkZWxheSA9IG9wdGlvbnMuZXZlbnRMb25nUHJlc3NEZWxheTtcbiAgICBpZiAoZGVsYXkgPT0gbnVsbCkge1xuICAgICAgICBkZWxheSA9IG9wdGlvbnMubG9uZ1ByZXNzRGVsYXk7XG4gICAgfVxuICAgIHJldHVybiBkZWxheTtcbn1cblxuY2xhc3MgRXZlbnRSZXNpemluZyBleHRlbmRzIEludGVyYWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgICAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgICAgIC8vIGludGVybmFsIHN0YXRlXG4gICAgICAgIHRoaXMuZHJhZ2dpbmdTZWdFbCA9IG51bGw7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmdTZWcgPSBudWxsOyAvLyBUT0RPOiByZW5hbWUgdG8gcmVzaXppbmdTZWc/IHN1YmplY3RTZWc/XG4gICAgICAgIHRoaXMuZXZlbnRSYW5nZSA9IG51bGw7XG4gICAgICAgIHRoaXMucmVsZXZhbnRFdmVudHMgPSBudWxsO1xuICAgICAgICB0aGlzLnZhbGlkTXV0YXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLm11dGF0ZWRSZWxldmFudEV2ZW50cyA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlckRvd24gPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGxldCB7IGNvbXBvbmVudCB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCBzZWdFbCA9IHRoaXMucXVlcnlTZWdFbChldik7XG4gICAgICAgICAgICBsZXQgc2VnID0gZ2V0RWxTZWcoc2VnRWwpO1xuICAgICAgICAgICAgbGV0IGV2ZW50UmFuZ2UgPSB0aGlzLmV2ZW50UmFuZ2UgPSBzZWcuZXZlbnRSYW5nZTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcubWluRGlzdGFuY2UgPSBjb21wb25lbnQuY29udGV4dC5vcHRpb25zLmV2ZW50RHJhZ01pbkRpc3RhbmNlO1xuICAgICAgICAgICAgLy8gaWYgdG91Y2gsIG5lZWQgdG8gYmUgd29ya2luZyB3aXRoIGEgc2VsZWN0ZWQgZXZlbnRcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcuc2V0SWdub3JlTW92ZSghdGhpcy5jb21wb25lbnQuaXNWYWxpZFNlZ0Rvd25FbChldi5vcmlnRXZlbnQudGFyZ2V0KSB8fFxuICAgICAgICAgICAgICAgIChldi5pc1RvdWNoICYmIHRoaXMuY29tcG9uZW50LnByb3BzLmV2ZW50U2VsZWN0aW9uICE9PSBldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWQpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVEcmFnU3RhcnQgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGxldCB7IGNvbnRleHQgfSA9IHRoaXMuY29tcG9uZW50O1xuICAgICAgICAgICAgbGV0IGV2ZW50UmFuZ2UgPSB0aGlzLmV2ZW50UmFuZ2U7XG4gICAgICAgICAgICB0aGlzLnJlbGV2YW50RXZlbnRzID0gZ2V0UmVsZXZhbnRFdmVudHMoY29udGV4dC5nZXRDdXJyZW50RGF0YSgpLmV2ZW50U3RvcmUsIHRoaXMuZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkKTtcbiAgICAgICAgICAgIGxldCBzZWdFbCA9IHRoaXMucXVlcnlTZWdFbChldik7XG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nU2VnRWwgPSBzZWdFbDtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdTZWcgPSBnZXRFbFNlZyhzZWdFbCk7XG4gICAgICAgICAgICBjb250ZXh0LmNhbGVuZGFyQXBpLnVuc2VsZWN0KCk7XG4gICAgICAgICAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRSZXNpemVTdGFydCcsIHtcbiAgICAgICAgICAgICAgICBlbDogc2VnRWwsXG4gICAgICAgICAgICAgICAgZXZlbnQ6IG5ldyBFdmVudEltcGwoY29udGV4dCwgZXZlbnRSYW5nZS5kZWYsIGV2ZW50UmFuZ2UuaW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgIGpzRXZlbnQ6IGV2Lm9yaWdFdmVudCxcbiAgICAgICAgICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVIaXRVcGRhdGUgPSAoaGl0LCBpc0ZpbmFsLCBldikgPT4ge1xuICAgICAgICAgICAgbGV0IHsgY29udGV4dCB9ID0gdGhpcy5jb21wb25lbnQ7XG4gICAgICAgICAgICBsZXQgcmVsZXZhbnRFdmVudHMgPSB0aGlzLnJlbGV2YW50RXZlbnRzO1xuICAgICAgICAgICAgbGV0IGluaXRpYWxIaXQgPSB0aGlzLmhpdERyYWdnaW5nLmluaXRpYWxIaXQ7XG4gICAgICAgICAgICBsZXQgZXZlbnRJbnN0YW5jZSA9IHRoaXMuZXZlbnRSYW5nZS5pbnN0YW5jZTtcbiAgICAgICAgICAgIGxldCBtdXRhdGlvbiA9IG51bGw7XG4gICAgICAgICAgICBsZXQgbXV0YXRlZFJlbGV2YW50RXZlbnRzID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBpc0ludmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBpbnRlcmFjdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBhZmZlY3RlZEV2ZW50czogcmVsZXZhbnRFdmVudHMsXG4gICAgICAgICAgICAgICAgbXV0YXRlZEV2ZW50czogY3JlYXRlRW1wdHlFdmVudFN0b3JlKCksXG4gICAgICAgICAgICAgICAgaXNFdmVudDogdHJ1ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoaGl0KSB7XG4gICAgICAgICAgICAgICAgbGV0IGRpc2FsbG93ZWQgPSBoaXQuY29tcG9uZW50SWQgPT09IGluaXRpYWxIaXQuY29tcG9uZW50SWRcbiAgICAgICAgICAgICAgICAgICAgJiYgdGhpcy5pc0hpdENvbWJvQWxsb3dlZFxuICAgICAgICAgICAgICAgICAgICAmJiAhdGhpcy5pc0hpdENvbWJvQWxsb3dlZChpbml0aWFsSGl0LCBoaXQpO1xuICAgICAgICAgICAgICAgIGlmICghZGlzYWxsb3dlZCkge1xuICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbiA9IGNvbXB1dGVNdXRhdGlvbihpbml0aWFsSGl0LCBoaXQsIGV2LnN1YmplY3RFbC5jbGFzc0xpc3QuY29udGFpbnMoJ2ZjLWV2ZW50LXJlc2l6ZXItc3RhcnQnKSwgZXZlbnRJbnN0YW5jZS5yYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG11dGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgbXV0YXRlZFJlbGV2YW50RXZlbnRzID0gYXBwbHlNdXRhdGlvblRvRXZlbnRTdG9yZShyZWxldmFudEV2ZW50cywgY29udGV4dC5nZXRDdXJyZW50RGF0YSgpLmV2ZW50VWlCYXNlcywgbXV0YXRpb24sIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMgPSBtdXRhdGVkUmVsZXZhbnRFdmVudHM7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0ludGVyYWN0aW9uVmFsaWQoaW50ZXJhY3Rpb24sIGhpdC5kYXRlUHJvZmlsZSwgY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNJbnZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbXV0YXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBtdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobXV0YXRlZFJlbGV2YW50RXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdTRVRfRVZFTlRfUkVTSVpFJyxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IGludGVyYWN0aW9uLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFVF9FVkVOVF9SRVNJWkUnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0ludmFsaWQpIHtcbiAgICAgICAgICAgICAgICBlbmFibGVDdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpc2FibGVDdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNGaW5hbCkge1xuICAgICAgICAgICAgICAgIGlmIChtdXRhdGlvbiAmJiBpc0hpdHNFcXVhbChpbml0aWFsSGl0LCBoaXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG11dGF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy52YWxpZE11dGF0aW9uID0gbXV0YXRpb247XG4gICAgICAgICAgICAgICAgdGhpcy5tdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBtdXRhdGVkUmVsZXZhbnRFdmVudHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlRHJhZ0VuZCA9IChldikgPT4ge1xuICAgICAgICAgICAgbGV0IHsgY29udGV4dCB9ID0gdGhpcy5jb21wb25lbnQ7XG4gICAgICAgICAgICBsZXQgZXZlbnREZWYgPSB0aGlzLmV2ZW50UmFuZ2UuZGVmO1xuICAgICAgICAgICAgbGV0IGV2ZW50SW5zdGFuY2UgPSB0aGlzLmV2ZW50UmFuZ2UuaW5zdGFuY2U7XG4gICAgICAgICAgICBsZXQgZXZlbnRBcGkgPSBuZXcgRXZlbnRJbXBsKGNvbnRleHQsIGV2ZW50RGVmLCBldmVudEluc3RhbmNlKTtcbiAgICAgICAgICAgIGxldCByZWxldmFudEV2ZW50cyA9IHRoaXMucmVsZXZhbnRFdmVudHM7XG4gICAgICAgICAgICBsZXQgbXV0YXRlZFJlbGV2YW50RXZlbnRzID0gdGhpcy5tdXRhdGVkUmVsZXZhbnRFdmVudHM7XG4gICAgICAgICAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRSZXNpemVTdG9wJywge1xuICAgICAgICAgICAgICAgIGVsOiB0aGlzLmRyYWdnaW5nU2VnRWwsXG4gICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50QXBpLFxuICAgICAgICAgICAgICAgIGpzRXZlbnQ6IGV2Lm9yaWdFdmVudCxcbiAgICAgICAgICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbGlkTXV0YXRpb24pIHtcbiAgICAgICAgICAgICAgICBsZXQgdXBkYXRlZEV2ZW50QXBpID0gbmV3IEV2ZW50SW1wbChjb250ZXh0LCBtdXRhdGVkUmVsZXZhbnRFdmVudHMuZGVmc1tldmVudERlZi5kZWZJZF0sIGV2ZW50SW5zdGFuY2UgPyBtdXRhdGVkUmVsZXZhbnRFdmVudHMuaW5zdGFuY2VzW2V2ZW50SW5zdGFuY2UuaW5zdGFuY2VJZF0gOiBudWxsKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ01FUkdFX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IG11dGF0ZWRSZWxldmFudEV2ZW50cyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsZXQgZXZlbnRDaGFuZ2VBcmcgPSB7XG4gICAgICAgICAgICAgICAgICAgIG9sZEV2ZW50OiBldmVudEFwaSxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IHVwZGF0ZWRFdmVudEFwaSxcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRlZEV2ZW50czogYnVpbGRFdmVudEFwaXMobXV0YXRlZFJlbGV2YW50RXZlbnRzLCBjb250ZXh0LCBldmVudEluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJ0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ01FUkdFX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogcmVsZXZhbnRFdmVudHMsIC8vIHRoZSBwcmUtY2hhbmdlIGV2ZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRSZXNpemUnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV2ZW50Q2hhbmdlQXJnKSwgeyBlbDogdGhpcy5kcmFnZ2luZ1NlZ0VsLCBzdGFydERlbHRhOiB0aGlzLnZhbGlkTXV0YXRpb24uc3RhcnREZWx0YSB8fCBjcmVhdGVEdXJhdGlvbigwKSwgZW5kRGVsdGE6IHRoaXMudmFsaWRNdXRhdGlvbi5lbmREZWx0YSB8fCBjcmVhdGVEdXJhdGlvbigwKSwganNFdmVudDogZXYub3JpZ0V2ZW50LCB2aWV3OiBjb250ZXh0LnZpZXdBcGkgfSkpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudENoYW5nZScsIGV2ZW50Q2hhbmdlQXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdfbm9FdmVudFJlc2l6ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmVzZXQgYWxsIGludGVybmFsIHN0YXRlXG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nU2VnID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucmVsZXZhbnRFdmVudHMgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy52YWxpZE11dGF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIC8vIG9rYXkgdG8ga2VlcCBldmVudEluc3RhbmNlIGFyb3VuZC4gdXNlZnVsIHRvIHNldCBpdCBpbiBoYW5kbGVQb2ludGVyRG93blxuICAgICAgICB9O1xuICAgICAgICBsZXQgeyBjb21wb25lbnQgfSA9IHNldHRpbmdzO1xuICAgICAgICBsZXQgZHJhZ2dpbmcgPSB0aGlzLmRyYWdnaW5nID0gbmV3IEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcoc2V0dGluZ3MuZWwpO1xuICAgICAgICBkcmFnZ2luZy5wb2ludGVyLnNlbGVjdG9yID0gJy5mYy1ldmVudC1yZXNpemVyJztcbiAgICAgICAgZHJhZ2dpbmcudG91Y2hTY3JvbGxBbGxvd2VkID0gZmFsc2U7XG4gICAgICAgIGRyYWdnaW5nLmF1dG9TY3JvbGxlci5pc0VuYWJsZWQgPSBjb21wb25lbnQuY29udGV4dC5vcHRpb25zLmRyYWdTY3JvbGw7XG4gICAgICAgIGxldCBoaXREcmFnZ2luZyA9IHRoaXMuaGl0RHJhZ2dpbmcgPSBuZXcgSGl0RHJhZ2dpbmcodGhpcy5kcmFnZ2luZywgaW50ZXJhY3Rpb25TZXR0aW5nc1RvU3RvcmUoc2V0dGluZ3MpKTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCB0aGlzLmhhbmRsZVBvaW50ZXJEb3duKTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ3N0YXJ0JywgdGhpcy5oYW5kbGVEcmFnU3RhcnQpO1xuICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdoaXR1cGRhdGUnLCB0aGlzLmhhbmRsZUhpdFVwZGF0ZSk7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdlbmQnLCB0aGlzLmhhbmRsZURyYWdFbmQpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRyYWdnaW5nLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgcXVlcnlTZWdFbChldikge1xuICAgICAgICByZXR1cm4gZWxlbWVudENsb3Nlc3QoZXYuc3ViamVjdEVsLCAnLmZjLWV2ZW50Jyk7XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcHV0ZU11dGF0aW9uKGhpdDAsIGhpdDEsIGlzRnJvbVN0YXJ0LCBpbnN0YW5jZVJhbmdlKSB7XG4gICAgbGV0IGRhdGVFbnYgPSBoaXQwLmNvbnRleHQuZGF0ZUVudjtcbiAgICBsZXQgZGF0ZTAgPSBoaXQwLmRhdGVTcGFuLnJhbmdlLnN0YXJ0O1xuICAgIGxldCBkYXRlMSA9IGhpdDEuZGF0ZVNwYW4ucmFuZ2Uuc3RhcnQ7XG4gICAgbGV0IGRlbHRhID0gZGlmZkRhdGVzKGRhdGUwLCBkYXRlMSwgZGF0ZUVudiwgaGl0MC5sYXJnZVVuaXQpO1xuICAgIGlmIChpc0Zyb21TdGFydCkge1xuICAgICAgICBpZiAoZGF0ZUVudi5hZGQoaW5zdGFuY2VSYW5nZS5zdGFydCwgZGVsdGEpIDwgaW5zdGFuY2VSYW5nZS5lbmQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0RGVsdGE6IGRlbHRhIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0ZUVudi5hZGQoaW5zdGFuY2VSYW5nZS5lbmQsIGRlbHRhKSA+IGluc3RhbmNlUmFuZ2Uuc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIHsgZW5kRGVsdGE6IGRlbHRhIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5jbGFzcyBVbnNlbGVjdEF1dG8ge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5pc1JlY2VudFBvaW50ZXJEYXRlU2VsZWN0ID0gZmFsc2U7IC8vIHdpc2ggd2UgY291bGQgdXNlIGEgc2VsZWN0b3IgdG8gZGV0ZWN0IGRhdGUgc2VsZWN0aW9uLCBidXQgdXNlcyBoaXQgc3lzdGVtXG4gICAgICAgIHRoaXMubWF0Y2hlc0NhbmNlbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1hdGNoZXNFdmVudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9uU2VsZWN0ID0gKHNlbGVjdEluZm8pID0+IHtcbiAgICAgICAgICAgIGlmIChzZWxlY3RJbmZvLmpzRXZlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzUmVjZW50UG9pbnRlckRhdGVTZWxlY3QgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uRG9jdW1lbnRQb2ludGVyRG93biA9IChwZXYpID0+IHtcbiAgICAgICAgICAgIGxldCB1bnNlbGVjdENhbmNlbCA9IHRoaXMuY29udGV4dC5vcHRpb25zLnVuc2VsZWN0Q2FuY2VsO1xuICAgICAgICAgICAgbGV0IGRvd25FbCA9IGdldEV2ZW50VGFyZ2V0VmlhUm9vdChwZXYub3JpZ0V2ZW50KTtcbiAgICAgICAgICAgIHRoaXMubWF0Y2hlc0NhbmNlbCA9ICEhZWxlbWVudENsb3Nlc3QoZG93bkVsLCB1bnNlbGVjdENhbmNlbCk7XG4gICAgICAgICAgICB0aGlzLm1hdGNoZXNFdmVudCA9ICEhZWxlbWVudENsb3Nlc3QoZG93bkVsLCBFdmVudERyYWdnaW5nLlNFTEVDVE9SKTsgLy8gaW50ZXJhY3Rpb24gc3RhcnRlZCBvbiBhbiBldmVudD9cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbkRvY3VtZW50UG9pbnRlclVwID0gKHBldikgPT4ge1xuICAgICAgICAgICAgbGV0IHsgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCB7IGRvY3VtZW50UG9pbnRlciB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCBjYWxlbmRhclN0YXRlID0gY29udGV4dC5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICAgICAgLy8gdG91Y2gtc2Nyb2xsaW5nIHNob3VsZCBuZXZlciB1bmZvY3VzIGFueSB0eXBlIG9mIHNlbGVjdGlvblxuICAgICAgICAgICAgaWYgKCFkb2N1bWVudFBvaW50ZXIud2FzVG91Y2hTY3JvbGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FsZW5kYXJTdGF0ZS5kYXRlU2VsZWN0aW9uICYmIC8vIGFuIGV4aXN0aW5nIGRhdGUgc2VsZWN0aW9uP1xuICAgICAgICAgICAgICAgICAgICAhdGhpcy5pc1JlY2VudFBvaW50ZXJEYXRlU2VsZWN0IC8vIGEgbmV3IHBvaW50ZXItaW5pdGlhdGVkIGRhdGUgc2VsZWN0aW9uIHNpbmNlIGxhc3Qgb25Eb2N1bWVudFBvaW50ZXJVcD9cbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHVuc2VsZWN0QXV0byA9IGNvbnRleHQub3B0aW9ucy51bnNlbGVjdEF1dG87XG4gICAgICAgICAgICAgICAgICAgIGlmICh1bnNlbGVjdEF1dG8gJiYgKCF1bnNlbGVjdEF1dG8gfHwgIXRoaXMubWF0Y2hlc0NhbmNlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuY2FsZW5kYXJBcGkudW5zZWxlY3QocGV2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2FsZW5kYXJTdGF0ZS5ldmVudFNlbGVjdGlvbiAmJiAvLyBhbiBleGlzdGluZyBldmVudCBzZWxlY3RlZD9cbiAgICAgICAgICAgICAgICAgICAgIXRoaXMubWF0Y2hlc0V2ZW50IC8vIGludGVyYWN0aW9uIERJRE4nVCBzdGFydCBvbiBhbiBldmVudFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1VOU0VMRUNUX0VWRU5UJyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmlzUmVjZW50UG9pbnRlckRhdGVTZWxlY3QgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGRvY3VtZW50UG9pbnRlciA9IHRoaXMuZG9jdW1lbnRQb2ludGVyID0gbmV3IFBvaW50ZXJEcmFnZ2luZyhkb2N1bWVudCk7XG4gICAgICAgIGRvY3VtZW50UG9pbnRlci5zaG91bGRJZ25vcmVNb3ZlID0gdHJ1ZTtcbiAgICAgICAgZG9jdW1lbnRQb2ludGVyLnNob3VsZFdhdGNoU2Nyb2xsID0gZmFsc2U7XG4gICAgICAgIGRvY3VtZW50UG9pbnRlci5lbWl0dGVyLm9uKCdwb2ludGVyZG93bicsIHRoaXMub25Eb2N1bWVudFBvaW50ZXJEb3duKTtcbiAgICAgICAgZG9jdW1lbnRQb2ludGVyLmVtaXR0ZXIub24oJ3BvaW50ZXJ1cCcsIHRoaXMub25Eb2N1bWVudFBvaW50ZXJVcCk7XG4gICAgICAgIC8qXG4gICAgICAgIFRPRE86IGJldHRlciB3YXkgdG8ga25vdyBhYm91dCB3aGV0aGVyIHRoZXJlIHdhcyBhIHNlbGVjdGlvbiB3aXRoIHRoZSBwb2ludGVyXG4gICAgICAgICovXG4gICAgICAgIGNvbnRleHQuZW1pdHRlci5vbignc2VsZWN0JywgdGhpcy5vblNlbGVjdCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5lbWl0dGVyLm9mZignc2VsZWN0JywgdGhpcy5vblNlbGVjdCk7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRQb2ludGVyLmRlc3Ryb3koKTtcbiAgICB9XG59XG5cbmNvbnN0IE9QVElPTl9SRUZJTkVSUyA9IHtcbiAgICBmaXhlZE1pcnJvclBhcmVudDogaWRlbnRpdHksXG59O1xuY29uc3QgTElTVEVORVJfUkVGSU5FUlMgPSB7XG4gICAgZGF0ZUNsaWNrOiBpZGVudGl0eSxcbiAgICBldmVudERyYWdTdGFydDogaWRlbnRpdHksXG4gICAgZXZlbnREcmFnU3RvcDogaWRlbnRpdHksXG4gICAgZXZlbnREcm9wOiBpZGVudGl0eSxcbiAgICBldmVudFJlc2l6ZVN0YXJ0OiBpZGVudGl0eSxcbiAgICBldmVudFJlc2l6ZVN0b3A6IGlkZW50aXR5LFxuICAgIGV2ZW50UmVzaXplOiBpZGVudGl0eSxcbiAgICBkcm9wOiBpZGVudGl0eSxcbiAgICBldmVudFJlY2VpdmU6IGlkZW50aXR5LFxuICAgIGV2ZW50TGVhdmU6IGlkZW50aXR5LFxufTtcblxuLypcbkdpdmVuIGFuIGFscmVhZHkgaW5zdGFudGlhdGVkIGRyYWdnYWJsZSBvYmplY3QgZm9yIG9uZS1vci1tb3JlIGVsZW1lbnRzLFxuSW50ZXJwcmV0cyBhbnkgZHJhZ2dpbmcgYXMgYW4gYXR0ZW1wdCB0byBkcmFnIGFuIGV2ZW50cyB0aGF0IGxpdmVzIG91dHNpZGVcbm9mIGEgY2FsZW5kYXIgb250byBhIGNhbGVuZGFyLlxuKi9cbmNsYXNzIEV4dGVybmFsRWxlbWVudERyYWdnaW5nIHtcbiAgICBjb25zdHJ1Y3RvcihkcmFnZ2luZywgc3VwcGxpZWREcmFnTWV0YSkge1xuICAgICAgICB0aGlzLnJlY2VpdmluZ0NvbnRleHQgPSBudWxsO1xuICAgICAgICB0aGlzLmRyb3BwYWJsZUV2ZW50ID0gbnVsbDsgLy8gd2lsbCBleGlzdCBmb3IgYWxsIGRyYWdzLCBldmVuIGlmIGNyZWF0ZTpmYWxzZVxuICAgICAgICB0aGlzLnN1cHBsaWVkRHJhZ01ldGEgPSBudWxsO1xuICAgICAgICB0aGlzLmRyYWdNZXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYW5kbGVEcmFnU3RhcnQgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ01ldGEgPSB0aGlzLmJ1aWxkRHJhZ01ldGEoZXYuc3ViamVjdEVsKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVIaXRVcGRhdGUgPSAoaGl0LCBpc0ZpbmFsLCBldikgPT4ge1xuICAgICAgICAgICAgbGV0IHsgZHJhZ2dpbmcgfSA9IHRoaXMuaGl0RHJhZ2dpbmc7XG4gICAgICAgICAgICBsZXQgcmVjZWl2aW5nQ29udGV4dCA9IG51bGw7XG4gICAgICAgICAgICBsZXQgZHJvcHBhYmxlRXZlbnQgPSBudWxsO1xuICAgICAgICAgICAgbGV0IGlzSW52YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGludGVyYWN0aW9uID0ge1xuICAgICAgICAgICAgICAgIGFmZmVjdGVkRXZlbnRzOiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSxcbiAgICAgICAgICAgICAgICBtdXRhdGVkRXZlbnRzOiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSxcbiAgICAgICAgICAgICAgICBpc0V2ZW50OiB0aGlzLmRyYWdNZXRhLmNyZWF0ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoaGl0KSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dCA9IGhpdC5jb250ZXh0O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhbkRyb3BFbE9uQ2FsZW5kYXIoZXYuc3ViamVjdEVsLCByZWNlaXZpbmdDb250ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICBkcm9wcGFibGVFdmVudCA9IGNvbXB1dGVFdmVudEZvckRhdGVTcGFuKGhpdC5kYXRlU3BhbiwgdGhpcy5kcmFnTWV0YSwgcmVjZWl2aW5nQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMgPSBldmVudFR1cGxlVG9TdG9yZShkcm9wcGFibGVFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlzSW52YWxpZCA9ICFpc0ludGVyYWN0aW9uVmFsaWQoaW50ZXJhY3Rpb24sIGhpdC5kYXRlUHJvZmlsZSwgcmVjZWl2aW5nQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0ludmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMgPSBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyb3BwYWJsZUV2ZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGlzcGxheURyYWcocmVjZWl2aW5nQ29udGV4dCwgaW50ZXJhY3Rpb24pO1xuICAgICAgICAgICAgLy8gc2hvdyBtaXJyb3IgaWYgbm8gYWxyZWFkeS1yZW5kZXJlZCBtaXJyb3IgZWxlbWVudCBPUiBpZiB3ZSBhcmUgc2h1dHRpbmcgZG93biB0aGUgbWlycm9yICg/KVxuICAgICAgICAgICAgLy8gVE9ETzogd2lzaCB3ZSBjb3VsZCBzb21laG93IHdhaXQgZm9yIGRpc3BhdGNoIHRvIGd1YXJhbnRlZSByZW5kZXJcbiAgICAgICAgICAgIGRyYWdnaW5nLnNldE1pcnJvcklzVmlzaWJsZShpc0ZpbmFsIHx8ICFkcm9wcGFibGVFdmVudCB8fCAhZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmZjLWV2ZW50LW1pcnJvcicpKTtcbiAgICAgICAgICAgIGlmICghaXNJbnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgZW5hYmxlQ3Vyc29yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaXNhYmxlQ3Vyc29yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzRmluYWwpIHtcbiAgICAgICAgICAgICAgICBkcmFnZ2luZy5zZXRNaXJyb3JOZWVkc1JldmVydCghZHJvcHBhYmxlRXZlbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVjZWl2aW5nQ29udGV4dCA9IHJlY2VpdmluZ0NvbnRleHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5kcm9wcGFibGVFdmVudCA9IGRyb3BwYWJsZUV2ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZURyYWdFbmQgPSAocGV2KSA9PiB7XG4gICAgICAgICAgICBsZXQgeyByZWNlaXZpbmdDb250ZXh0LCBkcm9wcGFibGVFdmVudCB9ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuY2xlYXJEcmFnKCk7XG4gICAgICAgICAgICBpZiAocmVjZWl2aW5nQ29udGV4dCAmJiBkcm9wcGFibGVFdmVudCkge1xuICAgICAgICAgICAgICAgIGxldCBmaW5hbEhpdCA9IHRoaXMuaGl0RHJhZ2dpbmcuZmluYWxIaXQ7XG4gICAgICAgICAgICAgICAgbGV0IGZpbmFsVmlldyA9IGZpbmFsSGl0LmNvbnRleHQudmlld0FwaTtcbiAgICAgICAgICAgICAgICBsZXQgZHJhZ01ldGEgPSB0aGlzLmRyYWdNZXRhO1xuICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdkcm9wJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBidWlsZERhdGVQb2ludEFwaVdpdGhDb250ZXh0KGZpbmFsSGl0LmRhdGVTcGFuLCByZWNlaXZpbmdDb250ZXh0KSksIHsgZHJhZ2dlZEVsOiBwZXYuc3ViamVjdEVsLCBqc0V2ZW50OiBwZXYub3JpZ0V2ZW50LCB2aWV3OiBmaW5hbFZpZXcgfSkpO1xuICAgICAgICAgICAgICAgIGlmIChkcmFnTWV0YS5jcmVhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFkZGluZ0V2ZW50cyA9IGV2ZW50VHVwbGVUb1N0b3JlKGRyb3BwYWJsZUV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTUVSR0VfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IGFkZGluZ0V2ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwZXYuaXNUb3VjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1NFTEVDVF9FVkVOVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRJbnN0YW5jZUlkOiBkcm9wcGFibGVFdmVudC5pbnN0YW5jZS5pbnN0YW5jZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gc2lnbmFsIHRoYXQgYW4gZXh0ZXJuYWwgZXZlbnQgbGFuZGVkXG4gICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudFJlY2VpdmUnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudDogbmV3IEV2ZW50SW1wbChyZWNlaXZpbmdDb250ZXh0LCBkcm9wcGFibGVFdmVudC5kZWYsIGRyb3BwYWJsZUV2ZW50Lmluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0ZWRFdmVudHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJ0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnUkVNT1ZFX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IGFkZGluZ0V2ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnZ2VkRWw6IHBldi5zdWJqZWN0RWwsXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3OiBmaW5hbFZpZXcsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVjZWl2aW5nQ29udGV4dCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmRyb3BwYWJsZUV2ZW50ID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGhpdERyYWdnaW5nID0gdGhpcy5oaXREcmFnZ2luZyA9IG5ldyBIaXREcmFnZ2luZyhkcmFnZ2luZywgaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlKTtcbiAgICAgICAgaGl0RHJhZ2dpbmcucmVxdWlyZUluaXRpYWwgPSBmYWxzZTsgLy8gd2lsbCBzdGFydCBvdXRzaWRlIG9mIGEgY29tcG9uZW50XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdzdGFydCcsIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0KTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignaGl0dXBkYXRlJywgdGhpcy5oYW5kbGVIaXRVcGRhdGUpO1xuICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdkcmFnZW5kJywgdGhpcy5oYW5kbGVEcmFnRW5kKTtcbiAgICAgICAgdGhpcy5zdXBwbGllZERyYWdNZXRhID0gc3VwcGxpZWREcmFnTWV0YTtcbiAgICB9XG4gICAgYnVpbGREcmFnTWV0YShzdWJqZWN0RWwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnN1cHBsaWVkRHJhZ01ldGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VEcmFnTWV0YSh0aGlzLnN1cHBsaWVkRHJhZ01ldGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5zdXBwbGllZERyYWdNZXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VEcmFnTWV0YSh0aGlzLnN1cHBsaWVkRHJhZ01ldGEoc3ViamVjdEVsKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldERyYWdNZXRhRnJvbUVsKHN1YmplY3RFbCk7XG4gICAgfVxuICAgIGRpc3BsYXlEcmFnKG5leHRDb250ZXh0LCBzdGF0ZSkge1xuICAgICAgICBsZXQgcHJldkNvbnRleHQgPSB0aGlzLnJlY2VpdmluZ0NvbnRleHQ7XG4gICAgICAgIGlmIChwcmV2Q29udGV4dCAmJiBwcmV2Q29udGV4dCAhPT0gbmV4dENvbnRleHQpIHtcbiAgICAgICAgICAgIHByZXZDb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1VOU0VUX0VWRU5UX0RSQUcnIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0Q29udGV4dCkge1xuICAgICAgICAgICAgbmV4dENvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnU0VUX0VWRU5UX0RSQUcnLCBzdGF0ZSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGVhckRyYWcoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlY2VpdmluZ0NvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMucmVjZWl2aW5nQ29udGV4dC5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFVF9FVkVOVF9EUkFHJyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYW5Ecm9wRWxPbkNhbGVuZGFyKGVsLCByZWNlaXZpbmdDb250ZXh0KSB7XG4gICAgICAgIGxldCBkcm9wQWNjZXB0ID0gcmVjZWl2aW5nQ29udGV4dC5vcHRpb25zLmRyb3BBY2NlcHQ7XG4gICAgICAgIGlmICh0eXBlb2YgZHJvcEFjY2VwdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIGRyb3BBY2NlcHQuY2FsbChyZWNlaXZpbmdDb250ZXh0LmNhbGVuZGFyQXBpLCBlbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkcm9wQWNjZXB0ID09PSAnc3RyaW5nJyAmJiBkcm9wQWNjZXB0KSB7XG4gICAgICAgICAgICByZXR1cm4gQm9vbGVhbihlbGVtZW50TWF0Y2hlcyhlbCwgZHJvcEFjY2VwdCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbi8vIFV0aWxzIGZvciBjb21wdXRpbmcgZXZlbnQgc3RvcmUgZnJvbSB0aGUgRHJhZ01ldGFcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGNvbXB1dGVFdmVudEZvckRhdGVTcGFuKGRhdGVTcGFuLCBkcmFnTWV0YSwgY29udGV4dCkge1xuICAgIGxldCBkZWZQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIGRyYWdNZXRhLmxlZnRvdmVyUHJvcHMpO1xuICAgIGZvciAobGV0IHRyYW5zZm9ybSBvZiBjb250ZXh0LnBsdWdpbkhvb2tzLmV4dGVybmFsRGVmVHJhbnNmb3Jtcykge1xuICAgICAgICBPYmplY3QuYXNzaWduKGRlZlByb3BzLCB0cmFuc2Zvcm0oZGF0ZVNwYW4sIGRyYWdNZXRhKSk7XG4gICAgfVxuICAgIGxldCB7IHJlZmluZWQsIGV4dHJhIH0gPSByZWZpbmVFdmVudERlZihkZWZQcm9wcywgY29udGV4dCk7XG4gICAgbGV0IGRlZiA9IHBhcnNlRXZlbnREZWYocmVmaW5lZCwgZXh0cmEsIGRyYWdNZXRhLnNvdXJjZUlkLCBkYXRlU3Bhbi5hbGxEYXksIGNvbnRleHQub3B0aW9ucy5mb3JjZUV2ZW50RHVyYXRpb24gfHwgQm9vbGVhbihkcmFnTWV0YS5kdXJhdGlvbiksIC8vIGhhc0VuZFxuICAgIGNvbnRleHQpO1xuICAgIGxldCBzdGFydCA9IGRhdGVTcGFuLnJhbmdlLnN0YXJ0O1xuICAgIC8vIG9ubHkgcmVseSBvbiB0aW1lIGluZm8gaWYgZHJvcCB6b25lIGlzIGFsbC1kYXksXG4gICAgLy8gb3RoZXJ3aXNlLCB3ZSBhbHJlYWR5IGtub3cgdGhlIHRpbWVcbiAgICBpZiAoZGF0ZVNwYW4uYWxsRGF5ICYmIGRyYWdNZXRhLnN0YXJ0VGltZSkge1xuICAgICAgICBzdGFydCA9IGNvbnRleHQuZGF0ZUVudi5hZGQoc3RhcnQsIGRyYWdNZXRhLnN0YXJ0VGltZSk7XG4gICAgfVxuICAgIGxldCBlbmQgPSBkcmFnTWV0YS5kdXJhdGlvbiA/XG4gICAgICAgIGNvbnRleHQuZGF0ZUVudi5hZGQoc3RhcnQsIGRyYWdNZXRhLmR1cmF0aW9uKSA6XG4gICAgICAgIGdldERlZmF1bHRFdmVudEVuZChkYXRlU3Bhbi5hbGxEYXksIHN0YXJ0LCBjb250ZXh0KTtcbiAgICBsZXQgaW5zdGFuY2UgPSBjcmVhdGVFdmVudEluc3RhbmNlKGRlZi5kZWZJZCwgeyBzdGFydCwgZW5kIH0pO1xuICAgIHJldHVybiB7IGRlZiwgaW5zdGFuY2UgfTtcbn1cbi8vIFV0aWxzIGZvciBleHRyYWN0aW5nIGRhdGEgZnJvbSBlbGVtZW50XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBnZXREcmFnTWV0YUZyb21FbChlbCkge1xuICAgIGxldCBzdHIgPSBnZXRFbWJlZGRlZEVsRGF0YShlbCwgJ2V2ZW50Jyk7XG4gICAgbGV0IG9iaiA9IHN0ciA/XG4gICAgICAgIEpTT04ucGFyc2Uoc3RyKSA6XG4gICAgICAgIHsgY3JlYXRlOiBmYWxzZSB9OyAvLyBpZiBubyBlbWJlZGRlZCBkYXRhLCBhc3N1bWUgbm8gZXZlbnQgY3JlYXRpb25cbiAgICByZXR1cm4gcGFyc2VEcmFnTWV0YShvYmopO1xufVxuY29uZmlnLmRhdGFBdHRyUHJlZml4ID0gJyc7XG5mdW5jdGlvbiBnZXRFbWJlZGRlZEVsRGF0YShlbCwgbmFtZSkge1xuICAgIGxldCBwcmVmaXggPSBjb25maWcuZGF0YUF0dHJQcmVmaXg7XG4gICAgbGV0IHByZWZpeGVkTmFtZSA9IChwcmVmaXggPyBwcmVmaXggKyAnLScgOiAnJykgKyBuYW1lO1xuICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtJyArIHByZWZpeGVkTmFtZSkgfHwgJyc7XG59XG5cbi8qXG5NYWtlcyBhbiBlbGVtZW50ICh0aGF0IGlzICpleHRlcm5hbCogdG8gYW55IGNhbGVuZGFyKSBkcmFnZ2FibGUuXG5DYW4gcGFzcyBpbiBkYXRhIHRoYXQgZGV0ZXJtaW5lcyBob3cgYW4gZXZlbnQgd2lsbCBiZSBjcmVhdGVkIHdoZW4gZHJvcHBlZCBvbnRvIGEgY2FsZW5kYXIuXG5MZXZlcmFnZXMgRnVsbENhbGVuZGFyJ3MgaW50ZXJuYWwgZHJhZy1uLWRyb3AgZnVuY3Rpb25hbGl0eSBXSVRIT1VUIGEgdGhpcmQtcGFydHkgZHJhZyBzeXN0ZW0uXG4qL1xuY2xhc3MgRXh0ZXJuYWxEcmFnZ2FibGUge1xuICAgIGNvbnN0cnVjdG9yKGVsLCBzZXR0aW5ncyA9IHt9KSB7XG4gICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlckRvd24gPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGxldCB7IGRyYWdnaW5nIH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IHsgbWluRGlzdGFuY2UsIGxvbmdQcmVzc0RlbGF5IH0gPSB0aGlzLnNldHRpbmdzO1xuICAgICAgICAgICAgZHJhZ2dpbmcubWluRGlzdGFuY2UgPVxuICAgICAgICAgICAgICAgIG1pbkRpc3RhbmNlICE9IG51bGwgP1xuICAgICAgICAgICAgICAgICAgICBtaW5EaXN0YW5jZSA6XG4gICAgICAgICAgICAgICAgICAgIChldi5pc1RvdWNoID8gMCA6IEJBU0VfT1BUSU9OX0RFRkFVTFRTLmV2ZW50RHJhZ01pbkRpc3RhbmNlKTtcbiAgICAgICAgICAgIGRyYWdnaW5nLmRlbGF5ID1cbiAgICAgICAgICAgICAgICBldi5pc1RvdWNoID8gLy8gVE9ETzogZXZlbnR1YWxseSByZWFkIGV2ZW50TG9uZ1ByZXNzRGVsYXkgaW5zdGVhZCB2dnZcbiAgICAgICAgICAgICAgICAgICAgKGxvbmdQcmVzc0RlbGF5ICE9IG51bGwgPyBsb25nUHJlc3NEZWxheSA6IEJBU0VfT1BUSU9OX0RFRkFVTFRTLmxvbmdQcmVzc0RlbGF5KSA6XG4gICAgICAgICAgICAgICAgICAgIDA7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0ID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXYuaXNUb3VjaCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcuZGVsYXkgJiZcbiAgICAgICAgICAgICAgICBldi5zdWJqZWN0RWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdmYy1ldmVudCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZy5taXJyb3IuZ2V0TWlycm9yRWwoKS5jbGFzc0xpc3QuYWRkKCdmYy1ldmVudC1zZWxlY3RlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgICAgIGxldCBkcmFnZ2luZyA9IHRoaXMuZHJhZ2dpbmcgPSBuZXcgRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZyhlbCk7XG4gICAgICAgIGRyYWdnaW5nLnRvdWNoU2Nyb2xsQWxsb3dlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoc2V0dGluZ3MuaXRlbVNlbGVjdG9yICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRyYWdnaW5nLnBvaW50ZXIuc2VsZWN0b3IgPSBzZXR0aW5ncy5pdGVtU2VsZWN0b3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldHRpbmdzLmFwcGVuZFRvICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRyYWdnaW5nLm1pcnJvci5wYXJlbnROb2RlID0gc2V0dGluZ3MuYXBwZW5kVG87IC8vIFRPRE86IHdyaXRlIHRlc3RzXG4gICAgICAgIH1cbiAgICAgICAgZHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCB0aGlzLmhhbmRsZVBvaW50ZXJEb3duKTtcbiAgICAgICAgZHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ3N0YXJ0JywgdGhpcy5oYW5kbGVEcmFnU3RhcnQpO1xuICAgICAgICBuZXcgRXh0ZXJuYWxFbGVtZW50RHJhZ2dpbmcoZHJhZ2dpbmcsIHNldHRpbmdzLmV2ZW50RGF0YSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcuZGVzdHJveSgpO1xuICAgIH1cbn1cblxuLypcbkRldGVjdHMgd2hlbiBhICpUSElSRC1QQVJUWSogZHJhZy1uLWRyb3Agc3lzdGVtIGludGVyYWN0cyB3aXRoIGVsZW1lbnRzLlxuVGhlIHRoaXJkLXBhcnR5IHN5c3RlbSBpcyByZXNwb25zaWJsZSBmb3IgZHJhd2luZyB0aGUgdmlzdWFscyBlZmZlY3RzIG9mIHRoZSBkcmFnLlxuVGhpcyBjbGFzcyBzaW1wbHkgbW9uaXRvcnMgZm9yIHBvaW50ZXIgbW92ZW1lbnRzIGFuZCBmaXJlcyBldmVudHMuXG5JdCBhbHNvIGhhcyB0aGUgYWJpbGl0eSB0byBoaWRlIHRoZSBtb3ZpbmcgZWxlbWVudCAodGhlIFwibWlycm9yXCIpIGR1cmluZyB0aGUgZHJhZy5cbiovXG5jbGFzcyBJbmZlcnJlZEVsZW1lbnREcmFnZ2luZyBleHRlbmRzIEVsZW1lbnREcmFnZ2luZyB7XG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyRWwpIHtcbiAgICAgICAgc3VwZXIoY29udGFpbmVyRWwpO1xuICAgICAgICB0aGlzLnNob3VsZElnbm9yZU1vdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5taXJyb3JTZWxlY3RvciA9ICcnO1xuICAgICAgICB0aGlzLmN1cnJlbnRNaXJyb3JFbCA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlckRvd24gPSAoZXYpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVyZG93bicsIGV2KTtcbiAgICAgICAgICAgIGlmICghdGhpcy5zaG91bGRJZ25vcmVNb3ZlKSB7XG4gICAgICAgICAgICAgICAgLy8gZmlyZSBkcmFnc3RhcnQgcmlnaHQgYXdheS4gZG9lcyBub3Qgc3VwcG9ydCBkZWxheSBvciBtaW4tZGlzdGFuY2VcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcignZHJhZ3N0YXJ0JywgZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJNb3ZlID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2hvdWxkSWdub3JlTW92ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdkcmFnbW92ZScsIGV2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyVXAgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVydXAnLCBldik7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2hvdWxkSWdub3JlTW92ZSkge1xuICAgICAgICAgICAgICAgIC8vIGZpcmUgZHJhZ2VuZCByaWdodCBhd2F5LiBkb2VzIG5vdCBzdXBwb3J0IGEgcmV2ZXJ0IGFuaW1hdGlvblxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdkcmFnZW5kJywgZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsZXQgcG9pbnRlciA9IHRoaXMucG9pbnRlciA9IG5ldyBQb2ludGVyRHJhZ2dpbmcoY29udGFpbmVyRWwpO1xuICAgICAgICBwb2ludGVyLmVtaXR0ZXIub24oJ3BvaW50ZXJkb3duJywgdGhpcy5oYW5kbGVQb2ludGVyRG93bik7XG4gICAgICAgIHBvaW50ZXIuZW1pdHRlci5vbigncG9pbnRlcm1vdmUnLCB0aGlzLmhhbmRsZVBvaW50ZXJNb3ZlKTtcbiAgICAgICAgcG9pbnRlci5lbWl0dGVyLm9uKCdwb2ludGVydXAnLCB0aGlzLmhhbmRsZVBvaW50ZXJVcCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMucG9pbnRlci5kZXN0cm95KCk7XG4gICAgfVxuICAgIHNldElnbm9yZU1vdmUoYm9vbCkge1xuICAgICAgICB0aGlzLnNob3VsZElnbm9yZU1vdmUgPSBib29sO1xuICAgIH1cbiAgICBzZXRNaXJyb3JJc1Zpc2libGUoYm9vbCkge1xuICAgICAgICBpZiAoYm9vbCkge1xuICAgICAgICAgICAgLy8gcmVzdG9yZSBhIHByZXZpb3VzbHkgaGlkZGVuIGVsZW1lbnQuXG4gICAgICAgICAgICAvLyB1c2UgdGhlIHJlZmVyZW5jZSBpbiBjYXNlIHRoZSBzZWxlY3RvciBjbGFzcyBoYXMgYWxyZWFkeSBiZWVuIHJlbW92ZWQuXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50TWlycm9yRWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRNaXJyb3JFbC5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50TWlycm9yRWwgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG1pcnJvckVsID0gdGhpcy5taXJyb3JTZWxlY3RvclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IHNvbWVob3cgcXVlcnkgRnVsbENhbGVuZGFycyBXSVRISU4gc2hhZG93LXJvb3RzXG4gICAgICAgICAgICAgICAgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRoaXMubWlycm9yU2VsZWN0b3IpXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgaWYgKG1pcnJvckVsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50TWlycm9yRWwgPSBtaXJyb3JFbDtcbiAgICAgICAgICAgICAgICBtaXJyb3JFbC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qXG5CcmlkZ2VzIHRoaXJkLXBhcnR5IGRyYWctbi1kcm9wIHN5c3RlbXMgd2l0aCBGdWxsQ2FsZW5kYXIuXG5NdXN0IGJlIGluc3RhbnRpYXRlZCBhbmQgZGVzdHJveWVkIGJ5IGNhbGxlci5cbiovXG5jbGFzcyBUaGlyZFBhcnR5RHJhZ2dhYmxlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXJPclNldHRpbmdzLCBzZXR0aW5ncykge1xuICAgICAgICBsZXQgY29udGFpbmVyRWwgPSBkb2N1bWVudDtcbiAgICAgICAgaWYgKFxuICAgICAgICAvLyB3aXNoIHdlIGNvdWxkIGp1c3QgdGVzdCBpbnN0YW5jZW9mIEV2ZW50VGFyZ2V0LCBidXQgZG9lc24ndCB3b3JrIGluIElFMTFcbiAgICAgICAgY29udGFpbmVyT3JTZXR0aW5ncyA9PT0gZG9jdW1lbnQgfHxcbiAgICAgICAgICAgIGNvbnRhaW5lck9yU2V0dGluZ3MgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgICAgICBjb250YWluZXJFbCA9IGNvbnRhaW5lck9yU2V0dGluZ3M7XG4gICAgICAgICAgICBzZXR0aW5ncyA9IHNldHRpbmdzIHx8IHt9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0dGluZ3MgPSAoY29udGFpbmVyT3JTZXR0aW5ncyB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRyYWdnaW5nID0gdGhpcy5kcmFnZ2luZyA9IG5ldyBJbmZlcnJlZEVsZW1lbnREcmFnZ2luZyhjb250YWluZXJFbCk7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MuaXRlbVNlbGVjdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZHJhZ2dpbmcucG9pbnRlci5zZWxlY3RvciA9IHNldHRpbmdzLml0ZW1TZWxlY3RvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250YWluZXJFbCA9PT0gZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIGRyYWdnaW5nLnBvaW50ZXIuc2VsZWN0b3IgPSAnW2RhdGEtZXZlbnRdJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLm1pcnJvclNlbGVjdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZHJhZ2dpbmcubWlycm9yU2VsZWN0b3IgPSBzZXR0aW5ncy5taXJyb3JTZWxlY3RvcjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZXh0ZXJuYWxEcmFnZ2luZyA9IG5ldyBFeHRlcm5hbEVsZW1lbnREcmFnZ2luZyhkcmFnZ2luZywgc2V0dGluZ3MuZXZlbnREYXRhKTtcbiAgICAgICAgLy8gVGhlIGhpdC1kZXRlY3Rpb24gc3lzdGVtIHJlcXVpcmVzIHRoYXQgdGhlIGRuZC1taXJyb3ItZWxlbWVudCBiZSBwb2ludGVyLWV2ZW50czpub25lLFxuICAgICAgICAvLyBidXQgdGhpcyBjYW4ndCBiZSBndWFyYW50ZWVkIGZvciB0aGlyZC1wYXJ0eSBkcmFnZ2FibGVzLCBzbyBkaXNhYmxlXG4gICAgICAgIGV4dGVybmFsRHJhZ2dpbmcuaGl0RHJhZ2dpbmcuZGlzYWJsZVBvaW50Q2hlY2sgPSB0cnVlO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRyYWdnaW5nLmRlc3Ryb3koKTtcbiAgICB9XG59XG5cbnZhciBpbmRleCA9IGNyZWF0ZVBsdWdpbih7XG4gICAgbmFtZTogJ0BmdWxsY2FsZW5kYXIvaW50ZXJhY3Rpb24nLFxuICAgIGNvbXBvbmVudEludGVyYWN0aW9uczogW0RhdGVDbGlja2luZywgRGF0ZVNlbGVjdGluZywgRXZlbnREcmFnZ2luZywgRXZlbnRSZXNpemluZ10sXG4gICAgY2FsZW5kYXJJbnRlcmFjdGlvbnM6IFtVbnNlbGVjdEF1dG9dLFxuICAgIGVsZW1lbnREcmFnZ2luZ0ltcGw6IEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcsXG4gICAgb3B0aW9uUmVmaW5lcnM6IE9QVElPTl9SRUZJTkVSUyxcbiAgICBsaXN0ZW5lclJlZmluZXJzOiBMSVNURU5FUl9SRUZJTkVSUyxcbn0pO1xuXG5leHBvcnQgeyBFeHRlcm5hbERyYWdnYWJsZSBhcyBEcmFnZ2FibGUsIFRoaXJkUGFydHlEcmFnZ2FibGUsIGluZGV4IGFzIGRlZmF1bHQgfTtcbiIsICJpbXBvcnQgeyBKc29uUmVxdWVzdEVycm9yLCBjcmVhdGVQbHVnaW4gfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvcmUvaW5kZXguanMnO1xuaW1wb3J0IHsgcmVxdWVzdEpzb24sIGFkZERheXMsIGlkZW50aXR5IH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb3JlL2ludGVybmFsLmpzJztcblxuLy8gVE9ETzogZXhwb3NlIHNvbWVob3dcbmNvbnN0IEFQSV9CQVNFID0gJ2h0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2NhbGVuZGFyL3YzL2NhbGVuZGFycyc7XG5jb25zdCBldmVudFNvdXJjZURlZiA9IHtcbiAgICBwYXJzZU1ldGEocmVmaW5lZCkge1xuICAgICAgICBsZXQgeyBnb29nbGVDYWxlbmRhcklkIH0gPSByZWZpbmVkO1xuICAgICAgICBpZiAoIWdvb2dsZUNhbGVuZGFySWQgJiYgcmVmaW5lZC51cmwpIHtcbiAgICAgICAgICAgIGdvb2dsZUNhbGVuZGFySWQgPSBwYXJzZUdvb2dsZUNhbGVuZGFySWQocmVmaW5lZC51cmwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnb29nbGVDYWxlbmRhcklkKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGdvb2dsZUNhbGVuZGFySWQsXG4gICAgICAgICAgICAgICAgZ29vZ2xlQ2FsZW5kYXJBcGlLZXk6IHJlZmluZWQuZ29vZ2xlQ2FsZW5kYXJBcGlLZXksXG4gICAgICAgICAgICAgICAgZ29vZ2xlQ2FsZW5kYXJBcGlCYXNlOiByZWZpbmVkLmdvb2dsZUNhbGVuZGFyQXBpQmFzZSxcbiAgICAgICAgICAgICAgICBleHRyYVBhcmFtczogcmVmaW5lZC5leHRyYVBhcmFtcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBmZXRjaChhcmcsIHN1Y2Nlc3NDYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xuICAgICAgICBsZXQgeyBkYXRlRW52LCBvcHRpb25zIH0gPSBhcmcuY29udGV4dDtcbiAgICAgICAgbGV0IG1ldGEgPSBhcmcuZXZlbnRTb3VyY2UubWV0YTtcbiAgICAgICAgbGV0IGFwaUtleSA9IG1ldGEuZ29vZ2xlQ2FsZW5kYXJBcGlLZXkgfHwgb3B0aW9ucy5nb29nbGVDYWxlbmRhckFwaUtleTtcbiAgICAgICAgaWYgKCFhcGlLZXkpIHtcbiAgICAgICAgICAgIGVycm9yQ2FsbGJhY2sobmV3IEVycm9yKCdTcGVjaWZ5IGEgZ29vZ2xlQ2FsZW5kYXJBcGlLZXkuIFNlZSBodHRwczovL2Z1bGxjYWxlbmRhci5pby9kb2NzL2dvb2dsZS1jYWxlbmRhcicpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCB1cmwgPSBidWlsZFVybChtZXRhKTtcbiAgICAgICAgICAgIC8vIFRPRE86IG1ha2UgRFJZIHdpdGgganNvbi1mZWVkLWV2ZW50LXNvdXJjZVxuICAgICAgICAgICAgbGV0IHsgZXh0cmFQYXJhbXMgfSA9IG1ldGE7XG4gICAgICAgICAgICBsZXQgZXh0cmFQYXJhbXNPYmogPSB0eXBlb2YgZXh0cmFQYXJhbXMgPT09ICdmdW5jdGlvbicgPyBleHRyYVBhcmFtcygpIDogZXh0cmFQYXJhbXM7XG4gICAgICAgICAgICBsZXQgcmVxdWVzdFBhcmFtcyA9IGJ1aWxkUmVxdWVzdFBhcmFtcyhhcmcucmFuZ2UsIGFwaUtleSwgZXh0cmFQYXJhbXNPYmosIGRhdGVFbnYpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RKc29uKCdHRVQnLCB1cmwsIHJlcXVlc3RQYXJhbXMpLnRoZW4oKFtib2R5LCByZXNwb25zZV0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYm9keS5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBlcnJvckNhbGxiYWNrKG5ldyBKc29uUmVxdWVzdEVycm9yKCdHb29nbGUgQ2FsZW5kYXIgQVBJOiAnICsgYm9keS5lcnJvci5tZXNzYWdlLCByZXNwb25zZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc0NhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhd0V2ZW50czogZ2NhbEl0ZW1zVG9SYXdFdmVudERlZnMoYm9keS5pdGVtcywgcmVxdWVzdFBhcmFtcy50aW1lWm9uZSksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZXJyb3JDYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmZ1bmN0aW9uIHBhcnNlR29vZ2xlQ2FsZW5kYXJJZCh1cmwpIHtcbiAgICBsZXQgbWF0Y2g7XG4gICAgLy8gZGV0ZWN0IGlmIHRoZSBJRCB3YXMgc3BlY2lmaWVkIGFzIGEgc2luZ2xlIHN0cmluZy5cbiAgICAvLyB3aWxsIG1hdGNoIGNhbGVuZGFycyBsaWtlIFwiYXNkZjEyMzRAY2FsZW5kYXIuZ29vZ2xlLmNvbVwiIGluIGFkZGl0aW9uIHRvIHBlcnNvbiBlbWFpbCBjYWxlbmRhcnMuXG4gICAgaWYgKC9eW14vXStAKFteLy5dK1xcLikqKGdvb2dsZXxnb29nbGVtYWlsfGdtYWlsKVxcLmNvbSQvLnRlc3QodXJsKSkge1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cbiAgICBpZiAoKG1hdGNoID0gL15odHRwczpcXC9cXC93d3cuZ29vZ2xlYXBpcy5jb21cXC9jYWxlbmRhclxcL3YzXFwvY2FsZW5kYXJzXFwvKFteL10qKS8uZXhlYyh1cmwpKSB8fFxuICAgICAgICAobWF0Y2ggPSAvXmh0dHBzPzpcXC9cXC93d3cuZ29vZ2xlLmNvbVxcL2NhbGVuZGFyXFwvZmVlZHNcXC8oW14vXSopLy5leGVjKHVybCkpKSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQobWF0Y2hbMV0pO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGJ1aWxkVXJsKG1ldGEpIHtcbiAgICBsZXQgYXBpQmFzZSA9IG1ldGEuZ29vZ2xlQ2FsZW5kYXJBcGlCYXNlO1xuICAgIGlmICghYXBpQmFzZSkge1xuICAgICAgICBhcGlCYXNlID0gQVBJX0JBU0U7XG4gICAgfVxuICAgIHJldHVybiBhcGlCYXNlICsgJy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KG1ldGEuZ29vZ2xlQ2FsZW5kYXJJZCkgKyAnL2V2ZW50cyc7XG59XG5mdW5jdGlvbiBidWlsZFJlcXVlc3RQYXJhbXMocmFuZ2UsIGFwaUtleSwgZXh0cmFQYXJhbXMsIGRhdGVFbnYpIHtcbiAgICBsZXQgcGFyYW1zO1xuICAgIGxldCBzdGFydFN0cjtcbiAgICBsZXQgZW5kU3RyO1xuICAgIGlmIChkYXRlRW52LmNhbkNvbXB1dGVPZmZzZXQpIHtcbiAgICAgICAgLy8gc3RyaW5ncyB3aWxsIG5hdHVyYWxseSBoYXZlIG9mZnNldHMsIHdoaWNoIEdDYWwgbmVlZHNcbiAgICAgICAgc3RhcnRTdHIgPSBkYXRlRW52LmZvcm1hdElzbyhyYW5nZS5zdGFydCk7XG4gICAgICAgIGVuZFN0ciA9IGRhdGVFbnYuZm9ybWF0SXNvKHJhbmdlLmVuZCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyB3aGVuIHRpbWV6b25lIGlzbid0IGtub3duLCB3ZSBkb24ndCBrbm93IHdoYXQgdGhlIFVUQyBvZmZzZXQgc2hvdWxkIGJlLCBzbyBhc2sgZm9yICsvLSAxIGRheVxuICAgICAgICAvLyBmcm9tIHRoZSBVVEMgZGF5LXN0YXJ0IHRvIGd1YXJhbnRlZSB3ZSdyZSBnZXR0aW5nIGFsbCB0aGUgZXZlbnRzXG4gICAgICAgIC8vIChzdGFydC9lbmQgd2lsbCBiZSBVVEMtY29lcmNlZCBkYXRlcywgc28gdG9JU09TdHJpbmcgaXMgb2theSlcbiAgICAgICAgc3RhcnRTdHIgPSBhZGREYXlzKHJhbmdlLnN0YXJ0LCAtMSkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgZW5kU3RyID0gYWRkRGF5cyhyYW5nZS5lbmQsIDEpLnRvSVNPU3RyaW5nKCk7XG4gICAgfVxuICAgIHBhcmFtcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKGV4dHJhUGFyYW1zIHx8IHt9KSksIHsga2V5OiBhcGlLZXksIHRpbWVNaW46IHN0YXJ0U3RyLCB0aW1lTWF4OiBlbmRTdHIsIHNpbmdsZUV2ZW50czogdHJ1ZSwgbWF4UmVzdWx0czogOTk5OSB9KTtcbiAgICBpZiAoZGF0ZUVudi50aW1lWm9uZSAhPT0gJ2xvY2FsJykge1xuICAgICAgICBwYXJhbXMudGltZVpvbmUgPSBkYXRlRW52LnRpbWVab25lO1xuICAgIH1cbiAgICByZXR1cm4gcGFyYW1zO1xufVxuZnVuY3Rpb24gZ2NhbEl0ZW1zVG9SYXdFdmVudERlZnMoaXRlbXMsIGdjYWxUaW1lem9uZSkge1xuICAgIHJldHVybiBpdGVtcy5tYXAoKGl0ZW0pID0+IGdjYWxJdGVtVG9SYXdFdmVudERlZihpdGVtLCBnY2FsVGltZXpvbmUpKTtcbn1cbmZ1bmN0aW9uIGdjYWxJdGVtVG9SYXdFdmVudERlZihpdGVtLCBnY2FsVGltZXpvbmUpIHtcbiAgICBsZXQgdXJsID0gaXRlbS5odG1sTGluayB8fCBudWxsO1xuICAgIC8vIG1ha2UgdGhlIFVSTHMgZm9yIGVhY2ggZXZlbnQgc2hvdyB0aW1lcyBpbiB0aGUgY29ycmVjdCB0aW1lem9uZVxuICAgIGlmICh1cmwgJiYgZ2NhbFRpbWV6b25lKSB7XG4gICAgICAgIHVybCA9IGluamVjdFFzQ29tcG9uZW50KHVybCwgJ2N0ej0nICsgZ2NhbFRpbWV6b25lKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IGl0ZW0uaWQsXG4gICAgICAgIHRpdGxlOiBpdGVtLnN1bW1hcnksXG4gICAgICAgIHN0YXJ0OiBpdGVtLnN0YXJ0LmRhdGVUaW1lIHx8IGl0ZW0uc3RhcnQuZGF0ZSxcbiAgICAgICAgZW5kOiBpdGVtLmVuZC5kYXRlVGltZSB8fCBpdGVtLmVuZC5kYXRlLFxuICAgICAgICB1cmwsXG4gICAgICAgIGxvY2F0aW9uOiBpdGVtLmxvY2F0aW9uLFxuICAgICAgICBkZXNjcmlwdGlvbjogaXRlbS5kZXNjcmlwdGlvbixcbiAgICAgICAgYXR0YWNobWVudHM6IGl0ZW0uYXR0YWNobWVudHMgfHwgW10sXG4gICAgICAgIGV4dGVuZGVkUHJvcHM6IChpdGVtLmV4dGVuZGVkUHJvcGVydGllcyB8fCB7fSkuc2hhcmVkIHx8IHt9LFxuICAgIH07XG59XG4vLyBJbmplY3RzIGEgc3RyaW5nIGxpa2UgXCJhcmc9dmFsdWVcIiBpbnRvIHRoZSBxdWVyeXN0cmluZyBvZiBhIFVSTFxuLy8gVE9ETzogbW92ZSB0byBhIGdlbmVyYWwgdXRpbCBmaWxlP1xuZnVuY3Rpb24gaW5qZWN0UXNDb21wb25lbnQodXJsLCBjb21wb25lbnQpIHtcbiAgICAvLyBpbmplY3QgaXQgYWZ0ZXIgdGhlIHF1ZXJ5c3RyaW5nIGJ1dCBiZWZvcmUgdGhlIGZyYWdtZW50XG4gICAgcmV0dXJuIHVybC5yZXBsYWNlKC8oXFw/Lio/KT8oI3wkKS8sICh3aG9sZSwgcXMsIGhhc2gpID0+IChxcyA/IHFzICsgJyYnIDogJz8nKSArIGNvbXBvbmVudCArIGhhc2gpO1xufVxuXG5jb25zdCBPUFRJT05fUkVGSU5FUlMgPSB7XG4gICAgZ29vZ2xlQ2FsZW5kYXJBcGlLZXk6IFN0cmluZyxcbn07XG5cbmNvbnN0IEVWRU5UX1NPVVJDRV9SRUZJTkVSUyA9IHtcbiAgICBnb29nbGVDYWxlbmRhckFwaUtleTogU3RyaW5nLFxuICAgIGdvb2dsZUNhbGVuZGFySWQ6IFN0cmluZyxcbiAgICBnb29nbGVDYWxlbmRhckFwaUJhc2U6IFN0cmluZyxcbiAgICBleHRyYVBhcmFtczogaWRlbnRpdHksXG59O1xuXG52YXIgaW5kZXggPSBjcmVhdGVQbHVnaW4oe1xuICAgIG5hbWU6ICdAZnVsbGNhbGVuZGFyL2dvb2dsZS1jYWxlbmRhcicsXG4gICAgZXZlbnRTb3VyY2VEZWZzOiBbZXZlbnRTb3VyY2VEZWZdLFxuICAgIG9wdGlvblJlZmluZXJzOiBPUFRJT05fUkVGSU5FUlMsXG4gICAgZXZlbnRTb3VyY2VSZWZpbmVyczogRVZFTlRfU09VUkNFX1JFRklORVJTLFxufSk7XG5cbmV4cG9ydCB7IGluZGV4IGFzIGRlZmF1bHQgfTtcbiIsICJpbXBvcnQgeyBjcmVhdGVQbHVnaW4gfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvcmUvaW5kZXguanMnO1xuaW1wb3J0IHsgYWRkRGF5cyB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29yZS9pbnRlcm5hbC5qcyc7XG5pbXBvcnQgKiBhcyBJQ0FMIGZyb20gJ2ljYWwuanMnO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuY2xhc3MgSWNhbEV4cGFuZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHRoaXMubWF4SXRlcmF0aW9ucyA9IG9wdHMubWF4SXRlcmF0aW9ucyAhPSBudWxsID8gb3B0cy5tYXhJdGVyYXRpb25zIDogMTAwMDtcbiAgICAgICAgdGhpcy5za2lwSW52YWxpZERhdGVzID0gb3B0cy5za2lwSW52YWxpZERhdGVzICE9IG51bGwgPyBvcHRzLnNraXBJbnZhbGlkRGF0ZXMgOiBmYWxzZTtcbiAgICAgICAgdGhpcy5qQ2FsRGF0YSA9IElDQUwucGFyc2Uob3B0cy5pY3MpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IG5ldyBJQ0FMLkNvbXBvbmVudCh0aGlzLmpDYWxEYXRhKTtcbiAgICAgICAgdGhpcy5ldmVudHMgPSB0aGlzLmNvbXBvbmVudC5nZXRBbGxTdWJjb21wb25lbnRzKCd2ZXZlbnQnKS5tYXAodmV2ZW50ID0+IG5ldyBJQ0FMLkV2ZW50KHZldmVudCkpO1xuICAgICAgICBpZiAodGhpcy5za2lwSW52YWxpZERhdGVzKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50cyA9IHRoaXMuZXZlbnRzLmZpbHRlcigoZXZ0KSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZXZ0LnN0YXJ0RGF0ZS50b0pTRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBldnQuZW5kRGF0ZS50b0pTRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAvLyBza2lwcGluZyBldmVudHMgd2l0aCBpbnZhbGlkIHRpbWVcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJldHdlZW4oYWZ0ZXIsIGJlZm9yZSkge1xuICAgICAgICBmdW5jdGlvbiBpc0V2ZW50V2l0aGluUmFuZ2Uoc3RhcnRUaW1lLCBlbmRUaW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gKCFhZnRlciB8fCBlbmRUaW1lID49IGFmdGVyLmdldFRpbWUoKSkgJiZcbiAgICAgICAgICAgICAgICAoIWJlZm9yZSB8fCBzdGFydFRpbWUgPD0gYmVmb3JlLmdldFRpbWUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0VGltZXMoZXZlbnRPck9jY3VycmVuY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IGV2ZW50T3JPY2N1cnJlbmNlLnN0YXJ0RGF0ZS50b0pTRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIGxldCBlbmRUaW1lID0gZXZlbnRPck9jY3VycmVuY2UuZW5kRGF0ZS50b0pTRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIC8vIElmIGl0IGlzIGFuIGFsbCBkYXkgZXZlbnQsIHRoZSBlbmQgZGF0ZSBpcyBzZXQgdG8gMDA6MDAgb2YgdGhlIG5leHQgZGF5XG4gICAgICAgICAgICAvLyBTbyB3ZSBuZWVkIHRvIG1ha2UgaXQgYmUgMjM6NTk6NTkgdG8gY29tcGFyZSBjb3JyZWN0bHkgd2l0aCB0aGUgZ2l2ZW4gcmFuZ2VcbiAgICAgICAgICAgIGlmIChldmVudE9yT2NjdXJyZW5jZS5lbmREYXRlLmlzRGF0ZSAmJiAoZW5kVGltZSA+IHN0YXJ0VGltZSkpIHtcbiAgICAgICAgICAgICAgICBlbmRUaW1lIC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBzdGFydFRpbWUsIGVuZFRpbWUgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleGNlcHRpb25zID0gW107XG4gICAgICAgIHRoaXMuZXZlbnRzLmZvckVhY2goKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuaXNSZWN1cnJlbmNlRXhjZXB0aW9uKCkpXG4gICAgICAgICAgICAgICAgZXhjZXB0aW9ucy5wdXNoKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJldCA9IHtcbiAgICAgICAgICAgIGV2ZW50czogW10sXG4gICAgICAgICAgICBvY2N1cnJlbmNlczogW10sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZXZlbnRzLmZpbHRlcihlID0+ICFlLmlzUmVjdXJyZW5jZUV4Y2VwdGlvbigpKS5mb3JFYWNoKChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXhkYXRlcyA9IFtdO1xuICAgICAgICAgICAgZXZlbnQuY29tcG9uZW50LmdldEFsbFByb3BlcnRpZXMoJ2V4ZGF0ZScpLmZvckVhY2goKGV4ZGF0ZVByb3ApID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBleGRhdGUgPSBleGRhdGVQcm9wLmdldEZpcnN0VmFsdWUoKTtcbiAgICAgICAgICAgICAgICBleGRhdGVzLnB1c2goZXhkYXRlLnRvSlNEYXRlKCkuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gUmVjdXJyaW5nIGV2ZW50IGlzIGhhbmRsZWQgZGlmZmVyZW50bHlcbiAgICAgICAgICAgIGlmIChldmVudC5pc1JlY3VycmluZygpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlcmF0b3IgPSBldmVudC5pdGVyYXRvcigpO1xuICAgICAgICAgICAgICAgIGxldCBuZXh0O1xuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9jY3VycmVuY2UgPSBldmVudC5nZXRPY2N1cnJlbmNlRGV0YWlscyhuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc3RhcnRUaW1lLCBlbmRUaW1lIH0gPSBnZXRUaW1lcyhvY2N1cnJlbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzT2NjdXJyZW5jZUV4Y2x1ZGVkID0gZXhkYXRlcy5pbmRleE9mKHN0YXJ0VGltZSkgIT09IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBjaGVjayB0aGF0IHdpdGhpbiBzYW1lIGRheT9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4Y2VwdGlvbiA9IGV4Y2VwdGlvbnMuZmluZChleCA9PiBleC51aWQgPT09IGV2ZW50LnVpZCAmJiBleC5yZWN1cnJlbmNlSWQudG9KU0RhdGUoKS5nZXRUaW1lKCkgPT09IG9jY3VycmVuY2Uuc3RhcnREYXRlLnRvSlNEYXRlKCkuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgcGFzc2VkIHRoZSBtYXggZGF0ZSwgc3RvcFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJlZm9yZSAmJiBzdGFydFRpbWUgPiBiZWZvcmUuZ2V0VGltZSgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB3ZSBhcmUgd2l0aGluIG91ciByYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRXZlbnRXaXRoaW5SYW5nZShzdGFydFRpbWUsIGVuZFRpbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQuZXZlbnRzLnB1c2goZXhjZXB0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzT2NjdXJyZW5jZUV4Y2x1ZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldC5vY2N1cnJlbmNlcy5wdXNoKG9jY3VycmVuY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKG5leHQgJiYgKCF0aGlzLm1heEl0ZXJhdGlvbnMgfHwgaSA8IHRoaXMubWF4SXRlcmF0aW9ucykpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vbi1yZWN1cnJpbmcgZXZlbnQ6XG4gICAgICAgICAgICBjb25zdCB7IHN0YXJ0VGltZSwgZW5kVGltZSB9ID0gZ2V0VGltZXMoZXZlbnQpO1xuICAgICAgICAgICAgaWYgKGlzRXZlbnRXaXRoaW5SYW5nZShzdGFydFRpbWUsIGVuZFRpbWUpKVxuICAgICAgICAgICAgICAgIHJldC5ldmVudHMucHVzaChldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBiZWZvcmUoYmVmb3JlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJldHdlZW4odW5kZWZpbmVkLCBiZWZvcmUpO1xuICAgIH1cbiAgICBhZnRlcihhZnRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5iZXR3ZWVuKGFmdGVyKTtcbiAgICB9XG4gICAgYWxsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZXR3ZWVuKCk7XG4gICAgfVxufVxuXG5jb25zdCBldmVudFNvdXJjZURlZiA9IHtcbiAgICBwYXJzZU1ldGEocmVmaW5lZCkge1xuICAgICAgICBpZiAocmVmaW5lZC51cmwgJiYgcmVmaW5lZC5mb3JtYXQgPT09ICdpY3MnKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogcmVmaW5lZC51cmwsXG4gICAgICAgICAgICAgICAgZm9ybWF0OiAnaWNzJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBmZXRjaChhcmcsIHN1Y2Nlc3NDYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xuICAgICAgICBsZXQgbWV0YSA9IGFyZy5ldmVudFNvdXJjZS5tZXRhO1xuICAgICAgICBsZXQgeyBpbnRlcm5hbFN0YXRlIH0gPSBtZXRhO1xuICAgICAgICAvKlxuICAgICAgICBOT1RFOiBpc1JlZmV0Y2ggaXMgYSBIQUNLLiB3ZSB3b3VsZCBkbyB0aGUgcmVjdXJyaW5nLWV4cGFuZGluZyBpbiBhIHNlcGFyYXRlIHBsdWdpbiBob29rLFxuICAgICAgICBidXQgd2UgY291bGRuJ3QgbGV2ZXJhZ2UgYnVpbHQtaW4gYWxsRGF5LWd1ZXNzaW5nLCBhbW9uZyBvdGhlciB0aGluZ3MuXG4gICAgICAgICovXG4gICAgICAgIGlmICghaW50ZXJuYWxTdGF0ZSB8fCBhcmcuaXNSZWZldGNoKSB7XG4gICAgICAgICAgICBpbnRlcm5hbFN0YXRlID0gbWV0YS5pbnRlcm5hbFN0YXRlID0ge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlOiBudWxsLFxuICAgICAgICAgICAgICAgIGlDYWxFeHBhbmRlclByb21pc2U6IGZldGNoKG1ldGEudXJsLCB7IG1ldGhvZDogJ0dFVCcgfSkudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKS50aGVuKChpY3NUZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFN0YXRlLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEljYWxFeHBhbmRlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNzOiBpY3NUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNraXBJbnZhbGlkRGF0ZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGludGVybmFsU3RhdGUuaUNhbEV4cGFuZGVyUHJvbWlzZS50aGVuKChpQ2FsRXhwYW5kZXIpID0+IHtcbiAgICAgICAgICAgIHN1Y2Nlc3NDYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgcmF3RXZlbnRzOiBleHBhbmRJQ2FsRXZlbnRzKGlDYWxFeHBhbmRlciwgYXJnLnJhbmdlKSxcbiAgICAgICAgICAgICAgICByZXNwb25zZTogaW50ZXJuYWxTdGF0ZS5yZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBlcnJvckNhbGxiYWNrKTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGV4cGFuZElDYWxFdmVudHMoaUNhbEV4cGFuZGVyLCByYW5nZSkge1xuICAgIC8vIGV4cGFuZCB0aGUgcmFuZ2UuIGJlY2F1c2Ugb3VyIGByYW5nZWAgaXMgdGltZVpvbmUtYWdub3N0aWMgVVRDXG4gICAgLy8gb3IgbWF5YmUgYmVjYXVzZSBpY2FsLmpzIGFsd2F5cyBwcm9kdWNlcyBkYXRlcyBpbiBsb2NhbCB0aW1lPyBpIGZvcmdldFxuICAgIGxldCByYW5nZVN0YXJ0ID0gYWRkRGF5cyhyYW5nZS5zdGFydCwgLTEpO1xuICAgIGxldCByYW5nZUVuZCA9IGFkZERheXMocmFuZ2UuZW5kLCAxKTtcbiAgICBsZXQgaUNhbFJlcyA9IGlDYWxFeHBhbmRlci5iZXR3ZWVuKHJhbmdlU3RhcnQsIHJhbmdlRW5kKTsgLy8gZW5kIGluY2x1c2l2ZS4gd2lsbCBnaXZlIGV4dHJhIHJlc3VsdHNcbiAgICBsZXQgZXhwYW5kZWQgPSBbXTtcbiAgICAvLyBUT0RPOiBpbnN0ZWFkIG9mIHVzaW5nIHN0YXJ0RGF0ZS9lbmREYXRlLnRvU3RyaW5nIHRvIGNvbW11bmljYXRlIGFsbERheSxcbiAgICAvLyB3ZSBjYW4gcXVlcnkgc3RhcnREYXRlL2VuZERhdGUuaXNEYXRlLiBNb3JlIGVmZmljaWVudCB0byBhdm9pZCBmb3JtYXR0aW5nL3JlcGFyc2luZy5cbiAgICAvLyBzaW5nbGUgZXZlbnRzXG4gICAgZm9yIChsZXQgaUNhbEV2ZW50IG9mIGlDYWxSZXMuZXZlbnRzKSB7XG4gICAgICAgIGV4cGFuZGVkLnB1c2goT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBidWlsZE5vbkRhdGVQcm9wcyhpQ2FsRXZlbnQpKSwgeyBzdGFydDogaUNhbEV2ZW50LnN0YXJ0RGF0ZS50b1N0cmluZygpLCBlbmQ6IChzcGVjaWZpZXNFbmQoaUNhbEV2ZW50KSAmJiBpQ2FsRXZlbnQuZW5kRGF0ZSlcbiAgICAgICAgICAgICAgICA/IGlDYWxFdmVudC5lbmREYXRlLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICA6IG51bGwgfSkpO1xuICAgIH1cbiAgICAvLyByZWN1cnJpbmcgZXZlbnQgaW5zdGFuY2VzXG4gICAgZm9yIChsZXQgaUNhbE9jY3VyZW5jZSBvZiBpQ2FsUmVzLm9jY3VycmVuY2VzKSB7XG4gICAgICAgIGxldCBpQ2FsRXZlbnQgPSBpQ2FsT2NjdXJlbmNlLml0ZW07XG4gICAgICAgIGV4cGFuZGVkLnB1c2goT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBidWlsZE5vbkRhdGVQcm9wcyhpQ2FsRXZlbnQpKSwgeyBzdGFydDogaUNhbE9jY3VyZW5jZS5zdGFydERhdGUudG9TdHJpbmcoKSwgZW5kOiAoc3BlY2lmaWVzRW5kKGlDYWxFdmVudCkgJiYgaUNhbE9jY3VyZW5jZS5lbmREYXRlKVxuICAgICAgICAgICAgICAgID8gaUNhbE9jY3VyZW5jZS5lbmREYXRlLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICA6IG51bGwgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gZXhwYW5kZWQ7XG59XG5mdW5jdGlvbiBidWlsZE5vbkRhdGVQcm9wcyhpQ2FsRXZlbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0aXRsZTogaUNhbEV2ZW50LnN1bW1hcnksXG4gICAgICAgIHVybDogZXh0cmFjdEV2ZW50VXJsKGlDYWxFdmVudCksXG4gICAgICAgIGV4dGVuZGVkUHJvcHM6IHtcbiAgICAgICAgICAgIGxvY2F0aW9uOiBpQ2FsRXZlbnQubG9jYXRpb24sXG4gICAgICAgICAgICBvcmdhbml6ZXI6IGlDYWxFdmVudC5vcmdhbml6ZXIsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogaUNhbEV2ZW50LmRlc2NyaXB0aW9uLFxuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBleHRyYWN0RXZlbnRVcmwoaUNhbEV2ZW50KSB7XG4gICAgbGV0IHVybFByb3AgPSBpQ2FsRXZlbnQuY29tcG9uZW50LmdldEZpcnN0UHJvcGVydHkoJ3VybCcpO1xuICAgIHJldHVybiB1cmxQcm9wID8gdXJsUHJvcC5nZXRGaXJzdFZhbHVlKCkgOiAnJztcbn1cbmZ1bmN0aW9uIHNwZWNpZmllc0VuZChpQ2FsRXZlbnQpIHtcbiAgICByZXR1cm4gQm9vbGVhbihpQ2FsRXZlbnQuY29tcG9uZW50LmdldEZpcnN0UHJvcGVydHkoJ2R0ZW5kJykpIHx8XG4gICAgICAgIEJvb2xlYW4oaUNhbEV2ZW50LmNvbXBvbmVudC5nZXRGaXJzdFByb3BlcnR5KCdkdXJhdGlvbicpKTtcbn1cblxudmFyIGluZGV4ID0gY3JlYXRlUGx1Z2luKHtcbiAgICBuYW1lOiAnQGZ1bGxjYWxlbmRhci9pY2FsZW5kYXInLFxuICAgIGV2ZW50U291cmNlRGVmczogW2V2ZW50U291cmNlRGVmXSxcbn0pO1xuXG5leHBvcnQgeyBpbmRleCBhcyBkZWZhdWx0IH07XG4iLCAiLyoqXG4gKiBIYW5kbGVzIHJlbmRlcmluZyB0aGUgY2FsZW5kYXIgZ2l2ZW4gYSBjb250YWluZXIgZWxlbWVudCwgZXZlbnRTb3VyY2VzLCBhbmQgaW50ZXJhY3Rpb24gY2FsbGJhY2tzLlxuICovXG5pbXBvcnQge1xuICAgIENhbGVuZGFyLFxuICAgIEV2ZW50QXBpLFxuICAgIEV2ZW50Q2xpY2tBcmcsXG4gICAgRXZlbnRIb3ZlcmluZ0FyZyxcbiAgICBFdmVudFNvdXJjZUlucHV0LFxufSBmcm9tIFwiQGZ1bGxjYWxlbmRhci9jb3JlXCI7XG5pbXBvcnQgZGF5R3JpZFBsdWdpbiBmcm9tIFwiQGZ1bGxjYWxlbmRhci9kYXlncmlkXCI7XG4vLyBpbXBvcnQgbXVsdGlNb250aFBsdWdpbiBmcm9tICdAZnVsbGNhbGVuZGFyL211bHRpbW9udGgnXG5pbXBvcnQgdGltZUdyaWRQbHVnaW4gZnJvbSBcIkBmdWxsY2FsZW5kYXIvdGltZWdyaWRcIjtcbmltcG9ydCBycnVsZVBsdWdpbiBmcm9tIFwiQGZ1bGxjYWxlbmRhci9ycnVsZVwiO1xuaW1wb3J0IGxpc3RQbHVnaW4gZnJvbSBcIkBmdWxsY2FsZW5kYXIvbGlzdFwiO1xuaW1wb3J0IGludGVyYWN0aW9uUGx1Z2luIGZyb20gXCJAZnVsbGNhbGVuZGFyL2ludGVyYWN0aW9uXCI7XG5pbXBvcnQgZ29vZ2xlQ2FsZW5kYXJQbHVnaW4gZnJvbSBcIkBmdWxsY2FsZW5kYXIvZ29vZ2xlLWNhbGVuZGFyXCI7XG5pbXBvcnQgaUNhbGVuZGFyUGx1Z2luIGZyb20gXCJAZnVsbGNhbGVuZGFyL2ljYWxlbmRhclwiO1xuXG4vLyBUaGVyZSBpcyBhbiBpc3N1ZSB3aXRoIEZ1bGxDYWxlbmRhciBSUnVsZSBzdXBwb3J0IGFyb3VuZCBEU1QgYm91bmRhcmllcyB3aGljaCBpcyBmaXhlZCBieSB0aGlzIG1vbmtleXBhdGNoOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Z1bGxjYWxlbmRhci9mdWxsY2FsZW5kYXIvaXNzdWVzLzUyNzMjaXNzdWVjb21tZW50LTEzNjA0NTkzNDJcbnJydWxlUGx1Z2luLnJlY3VycmluZ1R5cGVzWzBdLmV4cGFuZCA9IGZ1bmN0aW9uIChlcnJkLCBmciwgZGUpIHtcbiAgICBjb25zdCBob3VycyA9IGVycmQucnJ1bGVTZXQuX2R0c3RhcnQuZ2V0SG91cnMoKTtcbiAgICByZXR1cm4gZXJyZC5ycnVsZVNldFxuICAgICAgICAuYmV0d2VlbihkZS50b0RhdGUoZnIuc3RhcnQpLCBkZS50b0RhdGUoZnIuZW5kKSwgdHJ1ZSlcbiAgICAgICAgLm1hcCgoZDogRGF0ZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKFxuICAgICAgICAgICAgICAgIERhdGUuVVRDKFxuICAgICAgICAgICAgICAgICAgICBkLmdldEZ1bGxZZWFyKCksXG4gICAgICAgICAgICAgICAgICAgIGQuZ2V0TW9udGgoKSxcbiAgICAgICAgICAgICAgICAgICAgZC5nZXREYXRlKCksXG4gICAgICAgICAgICAgICAgICAgIGhvdXJzLFxuICAgICAgICAgICAgICAgICAgICBkLmdldE1pbnV0ZXMoKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xufTtcblxuaW50ZXJmYWNlIEV4dHJhUmVuZGVyUHJvcHMge1xuICAgIGV2ZW50Q2xpY2s/OiAoaW5mbzogRXZlbnRDbGlja0FyZykgPT4gdm9pZDtcbiAgICBzZWxlY3Q/OiAoXG4gICAgICAgIHN0YXJ0RGF0ZTogRGF0ZSxcbiAgICAgICAgZW5kRGF0ZTogRGF0ZSxcbiAgICAgICAgYWxsRGF5OiBib29sZWFuLFxuICAgICAgICB2aWV3VHlwZTogc3RyaW5nXG4gICAgKSA9PiBQcm9taXNlPHZvaWQ+O1xuICAgIG1vZGlmeUV2ZW50PzogKGV2ZW50OiBFdmVudEFwaSwgb2xkRXZlbnQ6IEV2ZW50QXBpKSA9PiBQcm9taXNlPGJvb2xlYW4+O1xuICAgIGV2ZW50TW91c2VFbnRlcj86IChpbmZvOiBFdmVudEhvdmVyaW5nQXJnKSA9PiB2b2lkO1xuICAgIGZpcnN0RGF5PzogbnVtYmVyO1xuICAgIGluaXRpYWxWaWV3PzogeyBkZXNrdG9wOiBzdHJpbmc7IG1vYmlsZTogc3RyaW5nIH07XG4gICAgdGltZUZvcm1hdDI0aD86IGJvb2xlYW47XG4gICAgb3BlbkNvbnRleHRNZW51Rm9yRXZlbnQ/OiAoXG4gICAgICAgIGV2ZW50OiBFdmVudEFwaSxcbiAgICAgICAgbW91c2VFdmVudDogTW91c2VFdmVudFxuICAgICkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgICB0b2dnbGVUYXNrPzogKGV2ZW50OiBFdmVudEFwaSwgaXNDb21wbGV0ZTogYm9vbGVhbikgPT4gUHJvbWlzZTxib29sZWFuPjtcbiAgICBmb3JjZU5hcnJvdz86IGJvb2xlYW47XG4gICAgc2xvdER1cmF0aW9uOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJDYWxlbmRhcihcbiAgICBjb250YWluZXJFbDogSFRNTEVsZW1lbnQsXG4gICAgZXZlbnRTb3VyY2VzOiBFdmVudFNvdXJjZUlucHV0W10sXG4gICAgc2V0dGluZ3M/OiBFeHRyYVJlbmRlclByb3BzXG4pOiBDYWxlbmRhciB7XG4gICAgY29uc3QgaXNNb2JpbGUgPSB3aW5kb3cuaW5uZXJXaWR0aCA8IDUwMDtcbiAgICBjb25zdCBpc05hcnJvdyA9IHNldHRpbmdzPy5mb3JjZU5hcnJvdyB8fCBpc01vYmlsZTtcbiAgICBjb25zdCB7XG4gICAgICAgIGV2ZW50Q2xpY2ssXG4gICAgICAgIHNlbGVjdCxcbiAgICAgICAgbW9kaWZ5RXZlbnQsXG4gICAgICAgIGV2ZW50TW91c2VFbnRlcixcbiAgICAgICAgb3BlbkNvbnRleHRNZW51Rm9yRXZlbnQsXG4gICAgICAgIHRvZ2dsZVRhc2ssXG4gICAgfSA9IHNldHRpbmdzIHx8IHt9O1xuICAgIGNvbnN0IG1vZGlmeUV2ZW50Q2FsbGJhY2sgPVxuICAgICAgICBtb2RpZnlFdmVudCAmJlxuICAgICAgICAoYXN5bmMgKHtcbiAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgb2xkRXZlbnQsXG4gICAgICAgICAgICByZXZlcnQsXG4gICAgICAgIH06IHtcbiAgICAgICAgICAgIGV2ZW50OiBFdmVudEFwaTtcbiAgICAgICAgICAgIG9sZEV2ZW50OiBFdmVudEFwaTtcbiAgICAgICAgICAgIHJldmVydDogKCkgPT4gdm9pZDtcbiAgICAgICAgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3VjY2VzcyA9IGF3YWl0IG1vZGlmeUV2ZW50KGV2ZW50LCBvbGRFdmVudCk7XG4gICAgICAgICAgICBpZiAoIXN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICByZXZlcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICBjb25zdCBjYWwgPSBuZXcgQ2FsZW5kYXIoY29udGFpbmVyRWwsIHtcbiAgICAgICAgcGx1Z2luczogW1xuICAgICAgICAgICAgLy8gVmlldyBwbHVnaW5zXG4gICAgICAgICAgICBkYXlHcmlkUGx1Z2luLFxuICAgICAgICAgICAgdGltZUdyaWRQbHVnaW4sXG4gICAgICAgICAgICBsaXN0UGx1Z2luLFxuICAgICAgICAgICAgLy8gbXVsdGlNb250aFBsdWdpbixcbiAgICAgICAgICAgIC8vIERyYWcgKyBkcm9wIGFuZCBlZGl0aW5nXG4gICAgICAgICAgICBpbnRlcmFjdGlvblBsdWdpbixcbiAgICAgICAgICAgIC8vIFJlbW90ZSBzb3VyY2VzXG4gICAgICAgICAgICBnb29nbGVDYWxlbmRhclBsdWdpbixcbiAgICAgICAgICAgIGlDYWxlbmRhclBsdWdpbixcbiAgICAgICAgICAgIHJydWxlUGx1Z2luLFxuICAgICAgICBdLFxuICAgICAgICBnb29nbGVDYWxlbmRhckFwaUtleTogXCJBSXphU3lESWlrbEZ3SlhhTFd1VF80eTZJOVpSVlZzUHVmNHhHcmtcIixcbiAgICAgICAgaW5pdGlhbFZpZXc6XG4gICAgICAgICAgICBzZXR0aW5ncz8uaW5pdGlhbFZpZXc/Lltpc05hcnJvdyA/IFwibW9iaWxlXCIgOiBcImRlc2t0b3BcIl0gfHxcbiAgICAgICAgICAgIChpc05hcnJvdyA/IFwidGltZUdyaWQzRGF5c1wiIDogXCJ0aW1lR3JpZFdlZWtcIiksXG4gICAgICAgIG5vd0luZGljYXRvcjogdHJ1ZSxcbiAgICAgICAgc2Nyb2xsVGltZVJlc2V0OiBmYWxzZSxcbiAgICAgICAgZGF5TWF4RXZlbnRzOiB0cnVlLFxuICAgICAgICBleHBhbmRSb3dzOnRydWUsXG4gICAgICAgIHNsb3REdXJhdGlvbjogc2V0dGluZ3M/LnNsb3REdXJhdGlvbiB8fCBcIjAwOjMwOjAwXCIsXG4gICAgICAgIC8vIG11bHRpTW9udGhNYXhDb2x1bW5zOiAxLFxuXG4gICAgICAgIGhlYWRlclRvb2xiYXI6ICFpc05hcnJvd1xuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICBsZWZ0OiBcInByZXYsbmV4dCB0b2RheVwiLFxuICAgICAgICAgICAgICAgICAgY2VudGVyOiBcInRpdGxlXCIsXG4gICAgICAgICAgICAgICAgICByaWdodDogXCJ0aW1lR3JpZDVEYXlzLHRpbWVHcmlkV2VlayxsaXN0V2VlayxkYXlHcmlkTW9udGgsZGF5R3JpZFllYXJcIixcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiAhaXNNb2JpbGVcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgcmlnaHQ6IFwidG9kYXkscHJldixuZXh0XCIsXG4gICAgICAgICAgICAgICAgICBsZWZ0OiBcImRheUdyaWRNb250aCx0aW1lR3JpZDNEYXlzLGxpc3RXZWVrLGRheUdyaWRZZWFyXCIsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgIGZvb3RlclRvb2xiYXI6IGlzTW9iaWxlXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgIHJpZ2h0OiBcInRvZGF5LHByZXYsbmV4dFwiLFxuICAgICAgICAgICAgICAgICAgbGVmdDogXCJ0aW1lR3JpZDNEYXlzLGRheUdyaWRNb250aCxkYXlHcmlkWWVhcix0aW1lR3JpZFdlZWssbGlzdFdlZWtcIixcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBmYWxzZSxcblxuICAgICAgICB2aWV3czoge1xuICAgICAgICAgICAgdGltZUdyaWQzRGF5czoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidGltZUdyaWRcIixcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogeyBkYXlzOiAzIH0sXG4gICAgICAgICAgICAgICAgYnV0dG9uVGV4dDogXCIzXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGltZUdyaWQ1RGF5czoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidGltZUdyaWRcIixcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogeyBkYXlzOiA1IH0sXG4gICAgICAgICAgICAgICAgYnV0dG9uVGV4dDogXCI1XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkYXlHcmlkTW9udGg6IHtcbiAgICAgICAgICAgICAgZGF5TWF4RXZlbnRzOiBmYWxzZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkYXlHcmlkWWVhcjoge1xuICAgICAgICAgICAgICBkYXlNYXhFdmVudHM6IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgZmlyc3REYXk6IHNldHRpbmdzPy5maXJzdERheSxcbiAgICAgICAgLi4uKHNldHRpbmdzPy50aW1lRm9ybWF0MjRoICYmIHtcbiAgICAgICAgICAgIGV2ZW50VGltZUZvcm1hdDoge1xuICAgICAgICAgICAgICAgIGhvdXI6IFwibnVtZXJpY1wiLFxuICAgICAgICAgICAgICAgIG1pbnV0ZTogXCIyLWRpZ2l0XCIsXG4gICAgICAgICAgICAgICAgaG91cjEyOiBmYWxzZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzbG90TGFiZWxGb3JtYXQ6IHtcbiAgICAgICAgICAgICAgICBob3VyOiBcIm51bWVyaWNcIixcbiAgICAgICAgICAgICAgICBtaW51dGU6IFwiMi1kaWdpdFwiLFxuICAgICAgICAgICAgICAgIGhvdXIxMjogZmFsc2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KSxcbiAgICAgICAgZXZlbnRTb3VyY2VzLFxuICAgICAgICBldmVudENsaWNrLFxuXG4gICAgICAgIHNlbGVjdGFibGU6IHNlbGVjdCAmJiB0cnVlLFxuICAgICAgICBzZWxlY3RNaXJyb3I6IHNlbGVjdCAmJiB0cnVlLFxuICAgICAgICBzZWxlY3Q6XG4gICAgICAgICAgICBzZWxlY3QgJiZcbiAgICAgICAgICAgIChhc3luYyAoaW5mbykgPT4ge1xuICAgICAgICAgICAgICAgIGF3YWl0IHNlbGVjdChpbmZvLnN0YXJ0LCBpbmZvLmVuZCwgaW5mby5hbGxEYXksIGluZm8udmlldy50eXBlKTtcbiAgICAgICAgICAgICAgICBpbmZvLnZpZXcuY2FsZW5kYXIudW5zZWxlY3QoKTtcbiAgICAgICAgICAgIH0pLFxuXG4gICAgICAgIGVkaXRhYmxlOiBtb2RpZnlFdmVudCAmJiB0cnVlLFxuICAgICAgICBldmVudERyb3A6IG1vZGlmeUV2ZW50Q2FsbGJhY2ssXG4gICAgICAgIGV2ZW50UmVzaXplOiBtb2RpZnlFdmVudENhbGxiYWNrLFxuXG4gICAgICAgIGV2ZW50TW91c2VFbnRlcixcblxuICAgICAgICBldmVudERpZE1vdW50OiAoeyBldmVudCwgZWwsIHRleHRDb2xvciB9KSA9PiB7XG4gICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgKGUpID0+IHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgb3BlbkNvbnRleHRNZW51Rm9yRXZlbnQgJiYgb3BlbkNvbnRleHRNZW51Rm9yRXZlbnQoZXZlbnQsIGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodG9nZ2xlVGFzaykge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5leHRlbmRlZFByb3BzLmlzVGFzaykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGVja2JveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tib3gudHlwZSA9IFwiY2hlY2tib3hcIjtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tib3guY2hlY2tlZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5leHRlbmRlZFByb3BzLnRhc2tDb21wbGV0ZWQgIT09IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjaGVja2JveC5vbmNsaWNrID0gYXN5bmMgKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmV0ID0gYXdhaXQgdG9nZ2xlVGFzayhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlLnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50KS5jaGVja2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZS50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudCkuY2hlY2tlZCA9ICEoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkuY2hlY2tlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2UgdGhlIGNoZWNrYm94IG1vcmUgdmlzaWJsZSBhZ2FpbnN0IGRpZmZlcmVudCBjb2xvciBldmVudHMuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0Q29sb3IgPT0gXCJibGFja1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja2JveC5hZGRDbGFzcyhcIm9mYy1jaGVja2JveC1ibGFja1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrYm94LmFkZENsYXNzKFwib2ZjLWNoZWNrYm94LXdoaXRlXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrYm94LmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLmFkZENsYXNzKFwib2ZjLXRhc2stY29tcGxldGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRGVwZW5kaW5nIG9uIHRoZSB2aWV3LCB3ZSBzaG91bGQgcHV0IHRoZSBjaGVja2JveCBpbiBhIGRpZmZlcmVudCBzcG90LlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250YWluZXIgPVxuICAgICAgICAgICAgICAgICAgICAgICAgZWwucXVlcnlTZWxlY3RvcihcIi5mYy1ldmVudC10aW1lXCIpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5xdWVyeVNlbGVjdG9yKFwiLmZjLWV2ZW50LXRpdGxlXCIpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5xdWVyeVNlbGVjdG9yKFwiLmZjLWxpc3QtZXZlbnQtdGl0bGVcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyPy5hZGRDbGFzcyhcIm9mYy1oYXMtY2hlY2tib3hcIik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcj8ucHJlcGVuZChjaGVja2JveCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGxvbmdQcmVzc0RlbGF5OiAyNTAsXG4gICAgfSk7XG4gICAgY2FsLnJlbmRlcigpO1xuICAgIHJldHVybiBjYWw7XG59XG4iLCAiaW1wb3J0IE15UGx1Z2luIGZyb20gXCIuL21haW5cIlxuaW1wb3J0IHsgTm90aWNlLCBUQWJzdHJhY3RGaWxlLCBURmlsZSwgVmF1bHQgfSBmcm9tIFwib2JzaWRpYW5cIlxuaW1wb3J0IHsgSVBhZ2UsIElTdWJzY3JpYmVyLCBTcmMgfSBmcm9tIFwiLi90eXBlc1wiXG5pbXBvcnQgeyBpc0VxdWFsT2JqIH0gZnJvbSBcIi4vdXRpbFwiXG5pbXBvcnQgRmlsZU1hbmFnZXIgZnJvbSBcIi4vTm90ZU1hbmFnZXJcIlxuaW1wb3J0IHsgTVNHX1BMR19OQU1FIH0gZnJvbSBcIi4vY29uc3RhbnRzXCJcbmltcG9ydCBOb3RlTWFuYWdlciBmcm9tIFwiLi9Ob3RlTWFuYWdlclwiXG5cbnR5cGUgSVBhdGhTdWJzY3JpYmVyID0ge1xuICBwYXRoczogU3JjW10sXG4gIHN1YnNjcmliZXI6IElTdWJzY3JpYmVyXG59XG5cbmV4cG9ydCBjbGFzcyBDYWNoZSB7XG4gIHByaXZhdGUgbm90ZU1hbmFnZXI6IE5vdGVNYW5hZ2VyXG5cbiAgcHJpdmF0ZSB2YXVsdDogVmF1bHRcblxuICBwcml2YXRlIHN0b3JhZ2UgPSBuZXcgTWFwPHN0cmluZywgSVBhZ2U+KClcbiAgcHJpdmF0ZSBzdWJzY3JpYmVycyA9IG5ldyBNYXA8TnVtYmVyLCBJUGF0aFN1YnNjcmliZXI+KClcblxuICBwcml2YXRlIGluaXRTeW5jOiBQcm9taXNlPHZvaWQ+ID0gbmV3IFByb21pc2UoXG4gICAgcmVzb2x2ZSA9PiB0aGlzLmluaXRTeW5jUmVzb2x2ZSA9IHJlc29sdmVcbiAgKVxuICBwcml2YXRlIGluaXRTeW5jUmVzb2x2ZTogKHZhbHVlOiB2b2lkIHwgUHJvbWlzZUxpa2U8dm9pZD4pID0+IHZvaWRcbiAgcHJpdmF0ZSBpc0luaXRlZCA9IGZhbHNlXG5cbiAgY29uc3RydWN0b3Iobm90ZU1hbmFnZXI6IE5vdGVNYW5hZ2VyLCB2YXVsdDogVmF1bHQpIHtcbiAgICB0aGlzLm5vdGVNYW5hZ2VyID0gbm90ZU1hbmFnZXJcbiAgICB0aGlzLnZhdWx0ID0gdmF1bHRcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBpbml0KCkge1xuICAgIC8vIE5PVEUgdSBjYW4gaW5pdCBvbmx5IG9uZSB0aW1lXG4gICAgaWYgKHRoaXMuaXNJbml0ZWQpXG4gICAgICByZXR1cm5cblxuICAgIGF3YWl0IHRoaXMuaW5pdFN0b3JhZ2UoKVxuXG4gICAgdGhpcy5pbml0U3luY1Jlc29sdmUoKVxuICAgIHRoaXMuaXNJbml0ZWQgPSB0cnVlXG4gIH1cblxuICBwdWJsaWMgZ2V0UGFnZShwYXRoOiBzdHJpbmcpOiBJUGFnZXx1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLnN0b3JhZ2UuZ2V0KHBhdGgpXG4gIH1cblxuICBwdWJsaWMgbG9nKCkge1xuICAgIGNvbnNvbGUubG9nKFwic3RvcmFnZVwiLCB0aGlzLnN0b3JhZ2UpXG4gICAgY29uc29sZS5sb2coXCJzdWJzY3JpYmVyc1wiLCB0aGlzLnN1YnNjcmliZXJzKVxuICB9XG5cbiAgcHVibGljIGFzeW5jIHN1YnNjcmliZShpZDogTnVtYmVyLCBwYXRoczogU3JjW10sIHN1YnNjcmliZXI6IElTdWJzY3JpYmVyKTogUHJvbWlzZTxJUGFnZVtdPiB7XG4gICAgdGhpcy5zdWJzY3JpYmVycy5zZXQoXG4gICAgICBpZCxcbiAgICAgIHtcbiAgICAgICAgcGF0aHMsXG4gICAgICAgIHN1YnNjcmliZXJcbiAgICAgIH1cbiAgICApXG5cbiAgICBpZiAoIXRoaXMuaXNJbml0ZWQpXG4gICAgICBhd2FpdCB0aGlzLmluaXRTeW5jXG5cbiAgICBjb25zdCByZXN1bHQ6IElQYWdlW10gPSBbXVxuICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiB0aGlzLnN0b3JhZ2UpIHtcbiAgICAgIGNvbnN0IGlzT2sgPSBwYXRocy5zb21lKFxuICAgICAgICBlbCA9PiBlbC5pbmNsdWRlcyhrZXkpXG4gICAgICApXG5cbiAgICAgIGlmIChpc09rKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIHB1YmxpYyB1bnN1YnNjcmliZShpZDogTnVtYmVyKSB7XG4gICAgdGhpcy5zdWJzY3JpYmVycy5kZWxldGUoaWQpXG4gIH1cblxuICBwdWJsaWMgYXN5bmMgcmVuYW1lRmlsZShmaWxlOiBURmlsZSwgb2xkUGF0aDogc3RyaW5nKSB7XG4gICAgaWYgKCF0aGlzLmlzSW5pdGVkKVxuICAgICAgcmV0dXJuXG5cbiAgICBjb25zdCBvbGRQYWdlID0gdGhpcy5zdG9yYWdlLmdldChvbGRQYXRoKSBhcyBJUGFnZVxuXG4gICAgLy8gTk9URSBcdTA0NDJcdTA0MzhcdTA0M0ZcdTA0MzAgXHUwNDREXHUwNDQyXHUwNDNFIFx1MDQ0MVx1MDQ0MVx1MDQ0Qlx1MDQzQlx1MDQzRVx1MDQ0N1x1MDQzRFx1MDQ0Qlx1MDQzNSBcdTA0M0VcdTA0MzFcdTA0NEFcdTA0MzVcdTA0M0FcdTA0NDJcdTA0NEJcbiAgICBjb25zdCBwYWdlID0gey4uLm9sZFBhZ2V9XG4gICAgcGFnZS5maWxlID0gey4uLm9sZFBhZ2UuZmlsZX1cbiAgICBwYWdlLmZpbGUucGF0aCA9IGZpbGUucGF0aFxuICAgIHBhZ2UuZmlsZS5uYW1lID0gZmlsZS5iYXNlbmFtZVxuXG4gICAgdGhpcy5zdG9yYWdlLmRlbGV0ZShvbGRQYXRoKVxuICAgIHRoaXMuc3RvcmFnZS5zZXQoZmlsZS5wYXRoLCBwYWdlKVxuXG4gICAgZm9yIChsZXQgW18sIHtwYXRocywgc3Vic2NyaWJlcn1dIG9mIHRoaXMuc3Vic2NyaWJlcnMpIHtcbiAgICAgIGNvbnN0IGlzT2sxID0gcGF0aHMuc29tZSggZWwgPT4gZWwuaW5jbHVkZXMoZmlsZS5wYXRoKSApXG4gICAgICBjb25zdCBpc09rMiA9IHBhdGhzLnNvbWUoIGVsID0+IGVsLmluY2x1ZGVzKG9sZFBhdGgpIClcblxuICAgICAgZm9yIChsZXQgcGF0aCBvZiBwYXRocykge1xuICAgICAgICBpZiAoaXNPazEgJiYgaXNPazIpXG4gICAgICAgICAgc3Vic2NyaWJlci5yZW5hbWVGaWxlKHBhZ2UsIG9sZFBhZ2UpXG4gICAgICAgIGVsc2UgaWYgKGlzT2syKVxuICAgICAgICAgIHN1YnNjcmliZXIuZGVsZXRlRmlsZShvbGRQYWdlKVxuICAgICAgICBlbHNlIGlmIChpc09rMSlcbiAgICAgICAgICBzdWJzY3JpYmVyLmFkZEZpbGUocGFnZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgYWRkRmlsZShmaWxlOiBURmlsZSkge1xuICAgIGlmICghdGhpcy5pc0luaXRlZClcbiAgICAgIHJldHVyblxuXG4gICAgY29uc3QgcGFnZSA9IGF3YWl0IHRoaXMubm90ZU1hbmFnZXIuZ2V0UGFnZShmaWxlKVxuICAgIHRoaXMuc3RvcmFnZS5zZXQoZmlsZS5wYXRoLCBwYWdlKVxuXG4gICAgZm9yIChsZXQgW18sIHtwYXRocywgc3Vic2NyaWJlcn1dIG9mIHRoaXMuc3Vic2NyaWJlcnMpIHtcbiAgICAgIGNvbnN0IGlzT2sgPSBwYXRocy5zb21lKCBlbCA9PiBlbC5pbmNsdWRlcyhmaWxlLnBhdGgpIClcblxuICAgICAgaWYgKGlzT2spXG4gICAgICAgIHN1YnNjcmliZXIuYWRkRmlsZShwYWdlKVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBjaGFuZ2VGaWxlKGZpbGU6IFRGaWxlKSB7XG4gICAgaWYgKCF0aGlzLmlzSW5pdGVkKVxuICAgICAgcmV0dXJuXG5cbiAgICBjb25zdCBwYWdlID0gYXdhaXQgdGhpcy5ub3RlTWFuYWdlci5nZXRQYWdlKGZpbGUpXG4gICAgY29uc3Qgb2xkUGFnZSA9IHRoaXMuc3RvcmFnZS5nZXQoZmlsZS5wYXRoKSBhcyBJUGFnZVxuICAgIGlmIChpc0VxdWFsT2JqKHBhZ2UsIG9sZFBhZ2UpKVxuICAgICAgcmV0dXJuXG5cbiAgICB0aGlzLnN0b3JhZ2Uuc2V0KGZpbGUucGF0aCwgcGFnZSlcbiAgICBmb3IgKGxldCBbXywge3BhdGhzLCBzdWJzY3JpYmVyfV0gb2YgdGhpcy5zdWJzY3JpYmVycykge1xuICAgICAgY29uc3QgaXNPayA9IHBhdGhzLnNvbWUoIGVsID0+IGVsLmluY2x1ZGVzKGZpbGUucGF0aCkgKVxuXG4gICAgICBpZiAoaXNPaylcbiAgICAgICAgc3Vic2NyaWJlci5jaGFuZ2VGaWxlKHBhZ2UsIG9sZFBhZ2UpXG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGRlbGV0ZUZpbGUoZmlsZTogVEFic3RyYWN0RmlsZSkge1xuICAgIGlmICghdGhpcy5pc0luaXRlZClcbiAgICAgIHJldHVyblxuXG4gICAgY29uc3QgcGFnZSA9IHRoaXMuc3RvcmFnZS5nZXQoZmlsZS5wYXRoKSBhcyBJUGFnZVxuXG4gICAgdGhpcy5zdG9yYWdlLmRlbGV0ZShmaWxlLnBhdGgpXG4gICAgZm9yIChsZXQgW18sIHtwYXRocywgc3Vic2NyaWJlcn1dIG9mIHRoaXMuc3Vic2NyaWJlcnMpIHtcbiAgICAgIGNvbnN0IGlzT2sgPSBwYXRocy5zb21lKCBlbCA9PiBlbC5pbmNsdWRlcyhmaWxlLnBhdGgpIClcblxuICAgICAgaWYgKGlzT2spXG4gICAgICAgIHN1YnNjcmliZXIuZGVsZXRlRmlsZShwYWdlKVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyByZXNldCgpIHtcbiAgICB0aGlzLmlzSW5pdGVkID0gZmFsc2VcblxuICAgIHRoaXMuc3RvcmFnZS5jbGVhcigpXG5cbiAgICBjb25zdCB0bXAgPSB0aGlzLnN1YnNjcmliZXJzXG4gICAgdGhpcy5zdWJzY3JpYmVycyA9IG5ldyBNYXAoKVxuICAgIGF3YWl0IHRoaXMuaW5pdCgpIC8vIFRPRE8gXHUwNDQ3XHUwNDQyXHUwNDNFIFx1MDQ0RFx1MDQ0Mlx1MDQzRSBcdTA0MzRcdTA0MzVcdTA0M0JcdTA0MzBcdTA0MzVcdTA0NDJcblxuICAgIGZvciAobGV0IFtfLCB7c3Vic2NyaWJlcn1dIG9mIHRtcClcbiAgICAgIHN1YnNjcmliZXIucmVzZXQoKVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBpbml0U3RvcmFnZSgpIHtcbiAgICBjb25zdCB0RmlsZXMgPSB0aGlzLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKVxuXG4gICAgY29uc3Qgbm90aWNlID0gbmV3IE5vdGljZShcbiAgICAgIGAke01TR19QTEdfTkFNRX06IHRoZXJlIGFyZSAke3RGaWxlcy5sZW5ndGh9IG5vdGVzYCxcbiAgICAgIDEwMDAgKiA2MCAvLyA2MCBzZWNvbmRzXG4gICAgKVxuXG4gICAgZm9yIChsZXQgaSBpbiB0RmlsZXMpIHtcbiAgICAgIGNvbnN0IHRGaWxlID0gdEZpbGVzW2ldXG5cbiAgICAgIG5vdGljZS5zZXRNZXNzYWdlKGAke01TR19QTEdfTkFNRX06ICgke2l9LyR7dEZpbGVzLmxlbmd0aH0pIGFkZGVkICR7dEZpbGUucGF0aH1gKVxuXG4gICAgICB0aGlzLnN0b3JhZ2Uuc2V0KFxuICAgICAgICB0RmlsZS5wYXRoLFxuICAgICAgICBhd2FpdCB0aGlzLm5vdGVNYW5hZ2VyLmdldFBhZ2UodEZpbGUpXG4gICAgICApXG4gICAgfVxuXG4gICAgbm90aWNlLmhpZGUoKVxuICAgIG5ldyBOb3RpY2UoYCR7TVNHX1BMR19OQU1FfTogY2FjaGUgaGFzIGJlZW4gaW5pdGVkYClcbiAgfVxufVxuIiwgImltcG9ydCB7IEFwcCwgTm90aWNlLCBQbHVnaW5TZXR0aW5nVGFiLCBTZXR0aW5nIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgTXlQbHVnaW4gZnJvbSBcIi4vbWFpblwiO1xuaW1wb3J0IHsgQ09MT1VSX1JFU1QsIENPTE9VUl9TTEVFUCwgREVGQVVMVF9TRVRUSU5HUywgTVNHX1BMR19OQU1FIH0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XG5cbmV4cG9ydCBjbGFzcyBNeVNldHRpbmdUYWIgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFiIHtcbiAgcGx1Z2luOiBNeVBsdWdpbjtcblxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcGx1Z2luOiBNeVBsdWdpbikge1xuICAgIHN1cGVyKGFwcCwgcGx1Z2luKTtcbiAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcbiAgfVxuXG4gIGRpc3BsYXkoKSB7XG4gICAgbGV0IHsgY29udGFpbmVyRWwgfSA9IHRoaXM7XG4gICAgY29udGFpbmVyRWwuZW1wdHkoKTtcblxuICAgIGNvbnN0IHNldHRpbmdzID0gdGhpcy5wbHVnaW4uZ2V0U2V0dGluZ3MoKVxuXG4gICAgLy8gVE9ETyBcdTA0M0ZcdTA0NDBcdTA0MzggXHUwNDQxXHUwNDNDXHUwNDM1XHUwNDNEXHUwNDM1IFx1MDQzMlx1MDQ0Qlx1MDQzQVx1MDQzQlx1MDQ0RVx1MDQ0N1x1MDQzMFx1MDQ0Mlx1MDQ0QyBcdTA0MzIgXHUwNDQyXHUwNDM1XHUwNDNBXHUwNDQzXHUwNDQ5XHUwNDM1XHUwNDM5IFx1MDQ0MVx1MDQzNVx1MDQ0MVx1MDQ0MVx1MDQzOFx1MDQzOCBcdTA0MzhcdTA0M0RcdTA0NDFcdTA0NDJcdTA0NDBcdTA0NDNcdTA0M0NcdTA0MzVcdTA0M0RcdTA0NDIsIFx1MDQzMCBcdTA0M0RcdTA0MzUgXHUwNDNGXHUwNDQwXHUwNDM4IFx1MDQzRlx1MDQzNVx1MDQ0MFx1MDQzNVx1MDQzN1x1MDQzMFx1MDQzM1x1MDQ0MFx1MDQ0M1x1MDQzN1x1MDQzQVx1MDQzNVxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKS5zZXRIZWFkaW5nKCkuc2V0TmFtZShcIkl0J3MgcmVjb21tZW5kZWQgdG8gcmVsb2FkIE9ic2lkaWFuQXBwIGFmdGVyIGNoYW5naW5nIHRoZSBzZXR0aW5nc1wiKVxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKS5hZGRCdXR0b24oXG4gICAgICBidG4gPT4ge1xuICAgICAgICBidG4uc2V0QnV0dG9uVGV4dChcIlNldCBEZWZhdWx0IFZhbHVlc1wiKVxuICAgICAgICAub25DbGljayhcbiAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoREVGQVVMVF9TRVRUSU5HUylcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoTVNHX1BMR19OQU1FICsgXCJUaGUgZGVmYXVsdCBzZXR0aW5ncyBoYXMgYmVlbiBhcHBsaWVkXCIpXG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICB9XG4gICAgKVxuXG4gICAgLy8gQ2FsZW5kYXJcbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbCkuc2V0SGVhZGluZygpXG5cbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbCkuc2V0TmFtZShcIkNhbGVuZGFyXCIpLnNldEhlYWRpbmcoKVxuXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpLnNldE5hbWUoXCJTbG90IGR1cmF0aW9uXCIpXG4gICAgLnNldERlc2MoYERlZmF1bHQ6ICR7REVGQVVMVF9TRVRUSU5HUy5jYWxlbmRhci5zbG90RHVyYXRpb259YClcbiAgICAuYWRkVGV4dChcbiAgICAgIGNvbXBvbmVudCA9PiB7XG4gICAgICAgIGNvbXBvbmVudC5zZXRQbGFjZWhvbGRlcihcImhoOm1tOnNzXCIpXG4gICAgICAgIC5zZXRWYWx1ZShzZXR0aW5ncy5jYWxlbmRhci5zbG90RHVyYXRpb24pXG4gICAgICAgIC5vbkNoYW5nZShcbiAgICAgICAgICB2YWx1ZSA9PiB7XG4gICAgICAgICAgICAvLyBDb21tZW50ZXQgY2F1c2UgSXQgY3JlYXRlIGEgbG90IG9mIE5vdGljZVxuICAgICAgICAgICAgLy8gY29uc3QgcmVnRXhwID0gL15cXGR7Mn06XFxkezJ9OlxcZHsyfSQvXG5cbiAgICAgICAgICAgIC8vIC8vIE5PVEUgXHUwNDNGXHUwNDQwXHUwNDNFXHUwNDMyXHUwNDM1XHUwNDQwXHUwNDRGXHUwNDM1XHUwNDNDIFx1MDQ0MVx1MDQzRVx1MDQzRVx1MDQ0Mlx1MDQzMlx1MDQzNVx1MDQ0Mlx1MDQ0MVx1MDQ0Mlx1MDQzMlx1MDQzOFx1MDQzNSBcdTA0NDRcdTA0M0VcdTA0NDBcdTA0M0NcdTA0MzBcdTA0NDJcdTA0NDNcbiAgICAgICAgICAgIC8vIGlmICghcmVnRXhwLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAvLyAgIHZhbHVlID0gREVGQVVMVF9TRVRUSU5HUy5jYWxlbmRhci5zbG90RHVyYXRpb25cbiAgICAgICAgICAgIC8vICAgbmV3IE5vdGljZShNU0dfUExHX05BTUUgKyBcImludmFsaWQgU2xvdER1cmF0aW9uIGZvcm1hdFwiKVxuICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICBzZXR0aW5ncy5jYWxlbmRhci5zbG90RHVyYXRpb24gPSB2YWx1ZVxuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKHNldHRpbmdzKVxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgfVxuICAgIClcblxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKS5zZXROYW1lKFwiQ29sb3Vyc1wiKS5zZXRIZWFkaW5nKClcbiAgICBmb3IgKGxldCBrZXkgb2YgT2JqZWN0LmtleXMoc2V0dGluZ3MuY2FsZW5kYXIuY29sb3VycykgYXMgKGtleW9mIHR5cGVvZiBzZXR0aW5ncy5jYWxlbmRhci5jb2xvdXJzKVtdICkge1xuICAgICAgdGhpcy5hZGRDb2xvdXJTZXR0aW5nKFxuICAgICAgICBjb250YWluZXJFbCwga2V5LFxuICAgICAgICBERUZBVUxUX1NFVFRJTkdTLmNhbGVuZGFyLmNvbG91cnNba2V5XSxcbiAgICAgICAgc2V0dGluZ3MuY2FsZW5kYXIuY29sb3Vyc1trZXldLFxuICAgICAgICAodmFsOnN0cmluZykgPT4ge1xuICAgICAgICAgIHNldHRpbmdzLmNhbGVuZGFyLmNvbG91cnNba2V5XSA9IHZhbFxuICAgICAgICAgIHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncyhzZXR0aW5ncylcbiAgICAgICAgfVxuICAgICAgKVxuICAgIH1cblxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKS5zZXROYW1lKFwiUmVzdFRpbWVcIikuc2V0SGVhZGluZygpXG4gICAgZm9yIChsZXQgaW5kZXggaW4gc2V0dGluZ3MuY2FsZW5kYXIucmVzdFRpbWUpIHtcblxuICAgICAgY29uc3QgZWwgPSBzZXR0aW5ncy5jYWxlbmRhci5yZXN0VGltZVtpbmRleF1cblxuICAgICAgbGV0IG5hbWUgPSBcIlwiXG4gICAgICBpZiAoZWwuY29sb3IgPT09IENPTE9VUl9SRVNUKSB7XG4gICAgICAgIG5hbWUgPSBcIlJlc3QgdGltZVwiXG4gICAgICB9XG4gICAgICBlbHNlIGlmIChlbC5jb2xvciA9PT0gQ09MT1VSX1NMRUVQKSB7XG4gICAgICAgIG5hbWUgPSBcIlNsZWVwIHRpbWVcIlxuICAgICAgfVxuICAgICAgZWxzZVxuICAgICAgICBjb250aW51ZVxuXG4gICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbCkuc2V0TmFtZShgU3RhcnQgb2YgJHtuYW1lfSAoJHtpbmRleH0pYCkuYWRkVGV4dChcbiAgICAgICAgdGV4dCA9PiB7XG4gICAgICAgICAgdGV4dC5zZXRWYWx1ZShlbC5zdGFydFRpbWUpLnNldFBsYWNlaG9sZGVyKFwiaGg6bW06c3NcIilcbiAgICAgICAgICAub25DaGFuZ2UoXG4gICAgICAgICAgICB2YWwgPT4ge1xuICAgICAgICAgICAgICBzZXR0aW5ncy5jYWxlbmRhci5yZXN0VGltZVtpbmRleF0uc3RhcnRUaW1lID0gdmFsXG4gICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncyhzZXR0aW5ncylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIClcbiAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKS5zZXROYW1lKGBFbmQgb2YgJHtuYW1lfSAoJHtpbmRleH0pYCkuYWRkVGV4dChcbiAgICAgICAgdGV4dCA9PiB7XG4gICAgICAgICAgdGV4dC5zZXRWYWx1ZShlbC5lbmRUaW1lKS5zZXRQbGFjZWhvbGRlcihcImhoOm1tOnNzXCIpXG4gICAgICAgICAgLm9uQ2hhbmdlKFxuICAgICAgICAgICAgdmFsID0+IHtcbiAgICAgICAgICAgICAgc2V0dGluZ3MuY2FsZW5kYXIucmVzdFRpbWVbaW5kZXhdLmVuZFRpbWUgPSB2YWxcbiAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKHNldHRpbmdzKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgKVxuXG4gICAgfVxuXG5cbiAgICAvLyBTdGF0dXMgQ29ycmVjdG9yXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpLnNldEhlYWRpbmcoKVxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKS5zZXROYW1lKFwiU3RhdHVzQ29ycmVjdG9yXCIpLnNldEhlYWRpbmcoKVxuICAgIC8vIC5zZXREZXNjKFwiVGhpcyBpcyBEZXNjcmlwdGlvblwiKVxuXG4gICAgY29uc3Qgc3RhdHVzQ29ycmVjdG9yID0gc2V0dGluZ3Muc3RhdHVzQ29ycmVjdG9yLmlzT25cbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgIC5zZXROYW1lKFwiRW5hYmxlIHRvb2xcIilcbiAgICAgIC5hZGRUb2dnbGUoXG4gICAgICAgIHRvZ2dsZSA9PlxuICAgICAgICAgIHRvZ2dsZVxuICAgICAgICAgICAgLnNldFZhbHVlKHN0YXR1c0NvcnJlY3RvcilcbiAgICAgICAgICAgIC5vbkNoYW5nZShcbiAgICAgICAgICAgICAgdmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLnN0YXR1c0NvcnJlY3Rvci5pc09uID0gdmFsdWVcbiAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3Moc2V0dGluZ3MpXG5cbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXkoKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICApXG4gICAgaWYgKHN0YXR1c0NvcnJlY3Rvcikge1xuICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgIC5zZXROYW1lKFwiU3RhcnQgb24gU3RhcnQgVXBcIilcbiAgICAgICAgLmFkZFRvZ2dsZShcbiAgICAgICAgICB0b2dnbGUgPT4gdG9nZ2xlLnNldFZhbHVlKHNldHRpbmdzLnN0YXR1c0NvcnJlY3Rvci5zdGFydE9uU3RhcnRVcClcbiAgICAgICAgICAgIC5vbkNoYW5nZShcbiAgICAgICAgICAgICAgdmFsID0+IHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5zdGF0dXNDb3JyZWN0b3Iuc3RhcnRPblN0YXJ0VXAgPSB2YWxcbiAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3Moc2V0dGluZ3MpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClcbiAgICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYWRkQ29sb3VyU2V0dGluZyhjb250YWluZXJFbDogSFRNTEVsZW1lbnQsIG5hbWU6IHN0cmluZywgZGVmYXVsdFZhbHVlOiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWU6IHN0cmluZywgY2FsbGJhY2s6IEZ1bmN0aW9uKSB7XG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpLnNldE5hbWUobmFtZSkuc2V0RGVzYyhgRGVmYXVsdDogJHtkZWZhdWx0VmFsdWV9YClcbiAgICAuYWRkVGV4dChcbiAgICAgIGNvbXBvbmVudCA9PiB7XG4gICAgICAgIGNvbXBvbmVudC5zZXRQbGFjZWhvbGRlcihcIiMwZjBmMGZcIilcbiAgICAgICAgLnNldFZhbHVlKGN1cnJlbnRWYWx1ZSkub25DaGFuZ2UodmFsID0+IGNhbGxiYWNrKHZhbCkpXG4gICAgICB9XG4gICAgKVxuICB9XG59XG4iLCAiaW1wb3J0IHsgTm90aWNlIH0gZnJvbSBcIm9ic2lkaWFuXCJcbmltcG9ydCB7IFRFWFRfQkxPQ0tFRCwgVEVYVF9ET05FLCBURVhUX1NPT04sIFRFWFRfSU5fUFJPR1JFU1MsIFRFWFRfQ0hJTERfSU5fUFJPR1JFU1MsIE1TR19QTEdfTkFNRSB9IGZyb20gXCIuLi9jb25zdGFudHNcIlxuaW1wb3J0IHsgSVBhZ2UsIElTdWJzY3JpYmVyLCBTcmMgfSBmcm9tIFwiLi4vdHlwZXNcIlxuaW1wb3J0IHsgZ2V0Tm90ZXNXaXRob3V0UGFyZW50LCBnZXRQYXJlbnROb3RlLCBnZXRDaGlsZE5vdGVQYXRocywgZ2V0UHJvZ3Jlc3MgfSBmcm9tIFwiLi4vdXRpbFwiXG5pbXBvcnQgeyBDYWNoZSB9IGZyb20gXCJzcmMvY2FjaGVcIlxuaW1wb3J0IE5vdGVNYW5hZ2VyIGZyb20gXCJzcmMvTm90ZU1hbmFnZXJcIlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGF0dXNDb3JyZWN0b3IgaW1wbGVtZW50cyBJU3Vic2NyaWJlciB7XG4gIHByaXZhdGUgY2FjaGU6IENhY2hlXG5cbiAgcHJpdmF0ZSBpZEZvckNhY2hlOiBudW1iZXJcblxuICBwcml2YXRlIGV2ZW50U3JjOiBTcmNbXVxuXG4gIHByaXZhdGUgbm90ZU1hbmFnZXI6IE5vdGVNYW5hZ2VyXG5cbiAgcHJpdmF0ZSBzdWJzY3JpYmVkID0gZmFsc2VcbiAgcHJpdmF0ZSB3aGlsZVN1YnNjcmliaW5nID0gbmV3IFByb21pc2UoXG4gICAgKHJlc29sdmUpID0+IHRoaXMucmVzb2x2ZVN1YnNjcmliaW5nID0gcmVzb2x2ZVxuICApXG4gIHByaXZhdGUgcmVzb2x2ZVN1YnNjcmliaW5nOiAodmFsdWU6IHZvaWQgfCBQcm9taXNlTGlrZTx2b2lkPikgPT4gdm9pZFxuXG4gIGNvbnN0cnVjdG9yKGlkRm9yQ2FjaGU6IG51bWJlciwgZXZlbnRTcmM6IFNyY1tdLCBjYWNoZTogQ2FjaGUsIG5vdGVNYW5hZ2VyOiBOb3RlTWFuYWdlcikge1xuICAgIHRoaXMuY2FjaGUgPSBjYWNoZVxuICAgIHRoaXMuaWRGb3JDYWNoZSA9IGlkRm9yQ2FjaGVcbiAgICB0aGlzLmV2ZW50U3JjID0gZXZlbnRTcmNcbiAgICB0aGlzLm5vdGVNYW5hZ2VyID0gbm90ZU1hbmFnZXJcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBpbml0KCkge1xuICAgIGF3YWl0IHRoaXMuY2FjaGUuc3Vic2NyaWJlKHRoaXMuaWRGb3JDYWNoZSwgdGhpcy5ldmVudFNyYywgdGhpcylcblxuICAgIHRoaXMuc3Vic2NyaWJlZCA9IHRydWVcbiAgICB0aGlzLnJlc29sdmVTdWJzY3JpYmluZygpXG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGNvcnJlY3ROb3RlKHBhZ2U6IElQYWdlKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgbGV0IHN0YXR1cyA9IHBhZ2UuZmZfc3RhdHVzXG4gICAgaWYgKCFzdGF0dXMpXG4gICAgICByZXR1cm4gZmFsc2VcblxuICAgIGNoZWNrUHJvZ3Jlc3M6IHtcbiAgICAgIGNvbnN0IHRhc2tzID0gYXdhaXQgZ2V0UHJvZ3Jlc3ModGhpcy5jYWNoZSwgdGhpcy5ub3RlTWFuYWdlciwgcGFnZSlcbiAgICAgIGlmIChzdGF0dXMgPT0gVEVYVF9ET05FICYmIHRhc2tzLmFsbCAhPSB0YXNrcy5kb25lKSB7XG4gICAgICAgIHN0YXR1cyA9IFRFWFRfSU5fUFJPR1JFU1NcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHN0YXR1cyA9PSBURVhUX1NPT04gJiYgdGFza3MuZG9uZSAhPSAwKSB7XG4gICAgICAgIHN0YXR1cyA9IFRFWFRfQkxPQ0tFRFxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc3RhdHVzICE9IFRFWFRfSU5fUFJPR1JFU1MgJiYgdGFza3MuZG9uZSA9PSAwICYmIHRhc2tzLmFsbCAhPSAwKSB7XG4gICAgICAgIHN0YXR1cyA9IFRFWFRfU09PTjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjaGVja0RhdGU6IHtcbiAgICAgIGNvbnN0IGNoZWNrcyA9IFtURVhUX1NPT04sIFRFWFRfQkxPQ0tFRCwgVEVYVF9DSElMRF9JTl9QUk9HUkVTU11cbiAgICAgIGlmIChwYWdlLmZmX2RhdGUgJiYgY2hlY2tzLmluZGV4T2Yoc3RhdHVzIGFzIHN0cmluZykgIT0gLTEpIHtcbiAgICAgICAgc3RhdHVzID0gVEVYVF9JTl9QUk9HUkVTU1xuICAgICAgfVxuICAgIH1cblxuICAgIGNoZWNrU3RhdHVzOiB7XG4gICAgICBjb25zdCBjaGlsZF8gPSBhd2FpdCBnZXRDaGlsZE5vdGVQYXRocyhwYWdlLmZpbGUucGF0aClcbiAgICAgIGNvbnN0IHN0YXR1c2VzOiBzdHJpbmdbXSA9IG5ldyBBcnJheVxuXG4gICAgICBmb3IgKGxldCBjaGlsZHJlbl8gb2YgY2hpbGRfKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gKHRoaXMuY2FjaGUuZ2V0UGFnZShjaGlsZHJlbl8pIGFzIElQYWdlKVxuXG4gICAgICAgIGlmICghY2hpbGRyZW4/LmZmX3N0YXR1cylcbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIHN0YXR1c2VzLnB1c2goY2hpbGRyZW4uZmZfc3RhdHVzKVxuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHN0YXR1cykge1xuICAgICAgICBjYXNlIFRFWFRfU09PTjoge1xuICAgICAgICAgIGlmIChzdGF0dXNlcy5pbmRleE9mKFRFWFRfSU5fUFJPR1JFU1MpICE9IC0xKVxuICAgICAgICAgICAgc3RhdHVzID0gVEVYVF9DSElMRF9JTl9QUk9HUkVTU1xuICAgICAgICAgIGVsc2UgaWYgKHN0YXR1c2VzLmluZGV4T2YoVEVYVF9DSElMRF9JTl9QUk9HUkVTUykgIT0gLTEpXG4gICAgICAgICAgICBzdGF0dXMgPSBURVhUX0NISUxEX0lOX1BST0dSRVNTXG4gICAgICAgICAgZWxzZSBpZiAoc3RhdHVzZXMuaW5kZXhPZihURVhUX0JMT0NLRUQpICE9IC0xKVxuICAgICAgICAgICAgc3RhdHVzID0gVEVYVF9CTE9DS0VEXG4gICAgICAgICAgZWxzZSBpZiAoc3RhdHVzZXMuaW5kZXhPZihURVhUX0RPTkUpICE9IC0xKVxuICAgICAgICAgICAgc3RhdHVzID0gVEVYVF9CTE9DS0VEXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFRFWFRfQkxPQ0tFRDoge1xuICAgICAgICAgIGlmIChzdGF0dXNlcy5pbmRleE9mKFRFWFRfSU5fUFJPR1JFU1MpICE9IC0xKVxuICAgICAgICAgICAgc3RhdHVzID0gVEVYVF9DSElMRF9JTl9QUk9HUkVTU1xuICAgICAgICAgIGVsc2UgaWYgKHN0YXR1c2VzLmluZGV4T2YoVEVYVF9DSElMRF9JTl9QUk9HUkVTUykgIT0gLTEpXG4gICAgICAgICAgICBzdGF0dXMgPSBURVhUX0NISUxEX0lOX1BST0dSRVNTXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFRFWFRfQ0hJTERfSU5fUFJPR1JFU1M6IHtcbiAgICAgICAgICBzdGF0dXMgPSBURVhUX0JMT0NLRURcbiAgICAgICAgICBpZiAoc3RhdHVzZXMuaW5kZXhPZihURVhUX0lOX1BST0dSRVNTKSAhPSAtMSlcbiAgICAgICAgICAgIHN0YXR1cyA9IFRFWFRfQ0hJTERfSU5fUFJPR1JFU1NcbiAgICAgICAgICBlbHNlIGlmIChzdGF0dXNlcy5pbmRleE9mKFRFWFRfQ0hJTERfSU5fUFJPR1JFU1MpICE9IC0xKVxuICAgICAgICAgICAgc3RhdHVzID0gVEVYVF9DSElMRF9JTl9QUk9HUkVTU1xuICAgICAgICAgIGVsc2UgaWYgKHN0YXR1c2VzLmluZGV4T2YoVEVYVF9ET05FKSAhPSAtMSlcbiAgICAgICAgICAgIHN0YXR1cyA9IFRFWFRfSU5fUFJPR1JFU1NcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgVEVYVF9ET05FOiB7XG4gICAgICAgICAgaWYgKHN0YXR1c2VzLmluZGV4T2YoVEVYVF9TT09OKSAhPSAtMSlcbiAgICAgICAgICAgIHN0YXR1cyA9IFRFWFRfQkxPQ0tFRFxuICAgICAgICAgIGVsc2UgaWYgKHN0YXR1c2VzLmluZGV4T2YoVEVYVF9CTE9DS0VEKSAhPSAtMSlcbiAgICAgICAgICAgIHN0YXR1cyA9IFRFWFRfQkxPQ0tFRFxuICAgICAgICAgIGVsc2UgaWYgKHN0YXR1c2VzLmluZGV4T2YoVEVYVF9JTl9QUk9HUkVTUykgIT0gLTEpXG4gICAgICAgICAgICBzdGF0dXMgPSBURVhUX0NISUxEX0lOX1BST0dSRVNTXG4gICAgICAgICAgZWxzZSBpZiAoc3RhdHVzZXMuaW5kZXhPZihURVhUX0NISUxEX0lOX1BST0dSRVNTKSAhPSAtMSlcbiAgICAgICAgICAgIHN0YXR1cyA9IFRFWFRfQ0hJTERfSU5fUFJPR1JFU1NcblxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgLy8gY2FzZSBURVhUX0JMT0NLRUQ6IGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdGF0dXMgPT0gcGFnZS5mZl9zdGF0dXMpXG4gICAgICByZXR1cm4gZmFsc2VcblxuICAgIHBhZ2UuZmZfc3RhdHVzID0gc3RhdHVzXG4gICAgYXdhaXQgdGhpcy5ub3RlTWFuYWdlci5jaGFuZ2VTdGF0dXNGaWxlKHBhZ2UuZmlsZS5wYXRoLCBzdGF0dXMpXG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGNvcnJlY3RBbGxOb3RlcygpIHtcbiAgICBjb25zdCBub3RpY2UgPSBuZXcgTm90aWNlKFxuICAgICAgTVNHX1BMR19OQU1FICsgXCI6IFN0YXJ0IGNoZWNraW5nIHN0YXR1cyBvZiBub3Rlc1wiLFxuICAgICAgMTAwMCAqIDYwIC8vIDYwIHNlY29uZHNcbiAgICApXG5cbiAgICBpZiAoIXRoaXMuc3Vic2NyaWJlZCkge1xuICAgICAgYXdhaXQgdGhpcy53aGlsZVN1YnNjcmliaW5nXG4gICAgfVxuXG4gICAgY29uc3QgcXVldWVQYXRoczogc3RyaW5nW10gPSBbXVxuICAgIGNvbnN0IHNldCA9IG5ldyBTZXQ8c3RyaW5nPigpXG5cbiAgICAvLyBsZXQgcGFyZW50cyA9IFtdXG4gICAgY29uc3QgY29tcHV0ZXMgPSBbXVxuXG4gICAgZm9yIChsZXQgZWwgb2YgdGhpcy5ldmVudFNyYykge1xuICAgICAgY29tcHV0ZXMucHVzaChcbiAgICAgICAgZ2V0Tm90ZXNXaXRob3V0UGFyZW50KGVsLnBhdGgpXG4gICAgICApXG4gICAgfVxuICAgIGxldCBwYXJlbnRzXyA9IGF3YWl0IFByb21pc2UuYWxsKGNvbXB1dGVzKVxuICAgIGxldCBwYXJlbnRzID0gW11cbiAgICBmb3IgKGxldCBlbCBvZiBwYXJlbnRzXykge1xuICAgICAgcGFyZW50cy5wdXNoKC4uLmVsKVxuICAgIH1cbiAgICBwYXJlbnRzID0gcGFyZW50cy51bmlxdWUoKVxuICAgICAgLmZpbHRlcihcbiAgICAgICAgZWwgPT4gdGhpcy5ldmVudFNyYy5zb21lKHNyYyA9PiBzcmMuaW5jbHVkZXMoZWwuZmlsZS5wYXRoKSlcbiAgICAgIClcblxuICAgIGZvciAobGV0IHBhcmVudCBvZiBwYXJlbnRzKSB7XG4gICAgICBxdWV1ZVBhdGhzLnB1c2gocGFyZW50LmZpbGUucGF0aClcbiAgICAgIHNldC5hZGQocGFyZW50LmZpbGUucGF0aClcbiAgICB9XG5cbiAgICBmb3IgKGxldCBsZWZ0UG9pbnRlciA9IDA7IGxlZnRQb2ludGVyIDwgcXVldWVQYXRocy5sZW5ndGg7ICsrbGVmdFBvaW50ZXIpIHtcbiAgICAgIGxldCBwYXRoID0gcXVldWVQYXRoc1tsZWZ0UG9pbnRlcl1cblxuICAgICAgY29uc3QgY2hpbGQgPSBhd2FpdCBnZXRDaGlsZE5vdGVQYXRocyhwYXRoKVxuICAgICAgZm9yIChsZXQgY2hpbGRyZW4gb2YgY2hpbGQpIHtcbiAgICAgICAgaWYgKHNldC5oYXMoY2hpbGRyZW4pKVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgc2V0LmFkZChjaGlsZHJlbilcbiAgICAgICAgcXVldWVQYXRocy5wdXNoKGNoaWxkcmVuKVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobGV0IHBvaW50ZXIgPSBxdWV1ZVBhdGhzLmxlbmd0aC0xOyBwb2ludGVyID4gMDsgLS1wb2ludGVyKSB7XG4gICAgICBsZXQgaSA9IHF1ZXVlUGF0aHMubGVuZ3RoIC0gcG9pbnRlciAtIDFcbiAgICAgIG5vdGljZS5zZXRNZXNzYWdlKGAke01TR19QTEdfTkFNRX0oc3RhdHVzKSAke2l9LyR7cXVldWVQYXRocy5sZW5ndGh9YClcblxuICAgICAgYXdhaXQgdGhpcy5jb3JyZWN0Tm90ZShcbiAgICAgICAgdGhpcy5jYWNoZS5nZXRQYWdlKFxuICAgICAgICAgIHF1ZXVlUGF0aHNbcG9pbnRlcl1cbiAgICAgICAgKSBhcyBJUGFnZVxuICAgICAgKVxuICAgIH1cblxuICAgIG5vdGljZS5zZXRNZXNzYWdlKE1TR19QTEdfTkFNRSArIFwiOiBTdGF0dXMgb2YgTm90ZXMgaGFzIGJlZW4gY2hlY2tlZFwiKVxuICAgIHNldFRpbWVvdXQoXG4gICAgICAoKSA9PiBub3RpY2UuaGlkZSgpLFxuICAgICAgMzAwMFxuICAgIClcblxuICAgIG5ldyBOb3RpY2UoYCR7TVNHX1BMR19OQU1FfTogTm90ZXMgaGFzIGJlZW4gY2hlY2tlZGApXG4gIH1cblxuICBwdWJsaWMgZGVzdHJveSgpIHtcbiAgICAvLyBUT0RPOiBcdTA0M0ZcdTA0NDBcdTA0MzggXHUwNDMyXHUwNDRCXHUwNDM3XHUwNDNFXHUwNDMyXHUwNDM1IFx1MDQzN1x1MDQzMFx1MDQzMlx1MDQzNVx1MDQ0MFx1MDQ0OFx1MDQzMFx1MDQ0Mlx1MDQ0QyBcdTA0MzdcdTA0MzBcdTA0M0ZcdTA0NDNcdTA0NDFcdTA0M0Egc3RhdHVzQ29ycmVjdG9yXG5cbiAgICB0aGlzLmNhY2hlLnVuc3Vic2NyaWJlKHRoaXMuaWRGb3JDYWNoZSlcbiAgfVxuXG4gIHB1YmxpYyByZW5hbWVGaWxlKG5ld1BhZ2U6IElQYWdlLCBvbGRQYWdlOiBJUGFnZSk6IHZvaWQge31cbiAgcHVibGljIGRlbGV0ZUZpbGUocGFnZTogSVBhZ2UpOiB2b2lkIHt9XG4gIHB1YmxpYyByZXNldCgpOiB2b2lkIHt9XG5cbiAgcHVibGljIGFzeW5jIGFkZEZpbGUocGFnZTogSVBhZ2UpIHtcbiAgICBhd2FpdCB0aGlzLmNoYW5nZUZpbGUocGFnZSwgcGFnZSlcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBjaGFuZ2VGaWxlKHBhZ2U6IElQYWdlLCBvbGRQYWdlOiBJUGFnZSkge1xuICAgIGNvbnN0IHF1ZXVlUGF0aHM6IHN0cmluZ1tdID0gW11cbiAgICBjb25zdCBzZXQgPSBuZXcgU2V0PHN0cmluZz4oKVxuXG4gICAgcXVldWVQYXRocy5wdXNoKHBhZ2UuZmlsZS5wYXRoKVxuICAgIHNldC5hZGQocGFnZS5maWxlLnBhdGgpXG5cbiAgICBmb3IgKGxldCBsZWZ0UG9pbnRlciA9IDA7IGxlZnRQb2ludGVyIDwgcXVldWVQYXRocy5sZW5ndGg7ICsrbGVmdFBvaW50ZXIpIHtcbiAgICAgIGNvbnN0IHBhdGggPSBxdWV1ZVBhdGhzW2xlZnRQb2ludGVyXVxuICAgICAgY29uc3QgcGFnZSA9IHRoaXMuY2FjaGUuZ2V0UGFnZShwYXRoKSBhcyBJUGFnZVxuICAgICAgY29uc3Qgb2xkU3RhdHVzID0gcGFnZS5mZl9zdGF0dXNcblxuICAgICAgY29uc3QgaXNDaGFuZ2VkID0gYXdhaXQgdGhpcy5jb3JyZWN0Tm90ZShwYWdlKVxuICAgICAgaWYgKCFpc0NoYW5nZWQgJiYgcGFnZS5mZl9zdGF0dXMgPT0gb2xkUGFnZS5mZl9zdGF0dXMpXG4gICAgICAgIGNvbnRpbnVlXG5cbiAgICAgIG5ldyBOb3RpY2UoXG4gICAgICAgIGAke3BhZ2UuZmlsZS5uYW1lfSAtIGNoYW5nZSBzdGF0dXM6ICR7b2xkU3RhdHVzfSA9PiAke3BhZ2UuZmZfc3RhdHVzfWBcbiAgICAgIClcblxuICAgICAgY29uc3QgY2hpbGQgPSBhd2FpdCBnZXRQYXJlbnROb3RlKHBhZ2UpXG4gICAgICBmb3IgKGxldCBjaGlsZHJlbiBvZiBjaGlsZCkge1xuICAgICAgICBpZiAoIWNoaWxkcmVuKVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY29uc3QgbmV3UGF0aCA9IGNoaWxkcmVuLmZpbGUucGF0aFxuICAgICAgICBpZiAoc2V0LmhhcyhuZXdQYXRoKSlcbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIHNldC5hZGQobmV3UGF0aClcbiAgICAgICAgcXVldWVQYXRocy5wdXNoKG5ld1BhdGgpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbn1cbiIsICJpbXBvcnQgeyBBcHAsIE5vdGljZSB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IE15UGx1Z2luIGZyb20gXCIuLi9tYWluXCI7XG5pbXBvcnQgeyBJUGFnZSwgSVN1YnNjcmliZXIsIFNyYyB9IGZyb20gXCIuLi90eXBlc1wiXG5pbXBvcnQgeyBNU0dfUExHX05BTUUgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBzYWZlUGFyc2VJbnQgfSBmcm9tIFwiLi4vdXRpbFwiO1xuaW1wb3J0IHsgQ2FjaGUgfSBmcm9tIFwic3JjL2NhY2hlXCI7XG5pbXBvcnQgTm90ZU1hbmFnZXIgZnJvbSBcInNyYy9Ob3RlTWFuYWdlclwiO1xuXG5leHBvcnQgY2xhc3MgVGlja0NoZWNrZXIgaW1wbGVtZW50cyBJU3Vic2NyaWJlciB7XG4gIHByaXZhdGUgcGFyZW50OiBNeVBsdWdpblxuXG4gIHByaXZhdGUgaWRGb3JDYWNoZTogbnVtYmVyXG5cbiAgcHJpdmF0ZSBjYWNoZTogQ2FjaGVcblxuICBwcml2YXRlIGV2ZW50U3JjOiBTcmNbXVxuXG4gIHByaXZhdGUgbm90ZU1hbmFnZXI6IE5vdGVNYW5hZ2VyXG5cblxuICBjb25zdHJ1Y3RvcihpZEZvckNhY2hlOiBudW1iZXIsIGV2ZW50U3JjOiBTcmNbXSwgY2FjaGU6IENhY2hlLCBub3RlTWFuYWdlcjogTm90ZU1hbmFnZXIpIHtcbiAgICB0aGlzLmNhY2hlID0gY2FjaGVcbiAgICB0aGlzLmlkRm9yQ2FjaGUgPSBpZEZvckNhY2hlXG4gICAgdGhpcy5ldmVudFNyYyA9IGV2ZW50U3JjXG4gICAgdGhpcy5ub3RlTWFuYWdlciA9IG5vdGVNYW5hZ2VyXG4gIH1cblxuICBwdWJsaWMgYXN5bmMgaW5pdCgpIHtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5jYWNoZS5zdWJzY3JpYmUodGhpcy5pZEZvckNhY2hlLCB0aGlzLmV2ZW50U3JjLCB0aGlzKVxuXG4gICAgY29uc3QgY2FsY3MgPSBkYXRhLm1hcChcbiAgICAgIGVsID0+IHRoaXMucHJvY2VzcyhlbClcbiAgICApXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoY2FsY3MpXG5cbiAgICB0aGlzLmNhY2hlLnVuc3Vic2NyaWJlKHRoaXMuaWRGb3JDYWNoZSlcbiAgfVxuXG5cbiAgcHJpdmF0ZSBhc3luYyBwcm9jZXNzKHBhZ2U6IElQYWdlKSB7XG4gICAgZm9yIChsZXQgdGljayBvZiBwYWdlLnRpY2tzKSB7XG4gICAgICBpZiAoIGlzTmFOKHNhZmVQYXJzZUludCh0aWNrLm5hbWUpKSApXG4gICAgICAgIGNvbnRpbnVlXG5cblxuICAgICAgbGV0IHRleHQgPSBhd2FpdCB0aGlzLm5vdGVNYW5hZ2VyLmdldFRleHQocGFnZS5maWxlLnBhdGgpXG4gICAgICBjb25zdCByZWdFeHAgPSBuZXcgUmVnRXhwKGBcXFxcW3Q6OlxcXFxzKiR7dGljay5uYW1lfSgsW15cXFxcXV0qfClcXFxcXWAsIFwiZ21cIilcblxuICAgICAgYXdhaXQgdGhpcy5ub3RlTWFuYWdlci5zZXRUZXh0KFxuICAgICAgICBwYWdlLmZpbGUucGF0aCxcbiAgICAgICAgdGV4dC5yZXBsYWNlKHJlZ0V4cCwgYFt0Ojoke3RpY2submFtZX1fJDFdYClcbiAgICAgIClcblxuICAgICAgbmV3IE5vdGljZShgJHtNU0dfUExHX05BTUV9OiBjaGFuZ2UgdGlja25hbWUgaW4gJHtwYWdlLmZpbGUubmFtZX06ICR7dGljay5uYW1lfWApXG4gICAgfVxuXG4gIH1cblxuICByZW5hbWVGaWxlKG5ld1BhZ2U6IElQYWdlLCBvbGRQYWdlOiBJUGFnZSk6IHZvaWQge31cbiAgZGVsZXRlRmlsZShwYWdlOiBJUGFnZSk6IHZvaWQge31cbiAgYWRkRmlsZShwYWdlOiBJUGFnZSk6IHZvaWQge31cbiAgY2hhbmdlRmlsZShuZXdQYWdlOiBJUGFnZSwgb2xkUGFnZTogSVBhZ2UpOiB2b2lkIHt9XG4gIHJlc2V0KCk6IHZvaWQge31cblxufVxuIiwgImltcG9ydCB7IEFwcCwgRmlsZU1hbmFnZXIsIE1ldGFkYXRhQ2FjaGUsIE5vdGljZSwgVEZpbGUsIFZhdWx0LCBXb3Jrc3BhY2UgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCBNeVBsdWdpbiBmcm9tIFwiLi9tYWluXCI7XG5pbXBvcnQgeyBJRXZlbnQsIElQYWdlLCBJVGFza3MsIElEYXRlIH0gZnJvbSBcIi4vdHlwZXNcIjtcbmltcG9ydCB7IENhbGVuZGFyRXZlbnRUb0lEYXRlLCBkdiwgZ2V0VGlja3NGcm9tVGV4dCB9IGZyb20gXCIuL3V0aWxcIjtcbmltcG9ydCB7IE1TR19QTEdfTkFNRSB9IGZyb20gXCIuL2NvbnN0YW50c1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb3RlTWFuYWdlciB7XG4gIHByaXZhdGUgdmF1bHQ6IFZhdWx0XG5cbiAgcHJpdmF0ZSBtZXRhZGF0YUNhY2hlOiBNZXRhZGF0YUNhY2hlXG5cbiAgcHJpdmF0ZSBmaWxlTWFuYWdlcjogRmlsZU1hbmFnZXJcblxuICBwcml2YXRlIHdvcmtzcGFjZTogV29ya3NwYWNlXG5cbiAgY29uc3RydWN0b3IoXG4gICAgdmF1bHQ6IFZhdWx0LFxuICAgIG1ldGFkYXRhQ2FjaGU6IE1ldGFkYXRhQ2FjaGUsXG4gICAgZmlsZU1hbmFnZXI6IEZpbGVNYW5hZ2VyLFxuICAgIHdvcmtzcGFjZTogV29ya3NwYWNlXG4gICkge1xuICAgIHRoaXMudmF1bHQgPSB2YXVsdFxuICAgIHRoaXMubWV0YWRhdGFDYWNoZSA9IG1ldGFkYXRhQ2FjaGVcbiAgICB0aGlzLmZpbGVNYW5hZ2VyID0gZmlsZU1hbmFnZXJcbiAgICB0aGlzLndvcmtzcGFjZSA9IHdvcmtzcGFjZVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGNyZWF0ZUZpbGUocGF0aDogc3RyaW5nKSB7XG4gICAgYXdhaXQgdGhpcy52YXVsdC5jcmVhdGUocGF0aCwgJycpXG4gICAgbmV3IE5vdGljZShNU0dfUExHX05BTUUgKyBcImNyZWF0ZWQgXCIgKyBwYXRoKVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGNoYW5nZVByb3BlcnR5RmlsZShwYXRoOiBzdHJpbmcsIGV2ZW50OiBJRGF0ZSkge1xuICAgIC8vIE5PVEUgXHUwNDREXHUwNDQyXHUwNDNFIFx1MDQzRVx1MDQ0Mlx1MDQzRlx1MDQ0MFx1MDQzMFx1MDQzMlx1MDQzOFx1MDQ0MiBcdTA0NDFcdTA0MzhcdTA0MzNcdTA0M0RcdTA0MzBcdTA0M0IgY2FjaGVcbiAgICBjb25zdCB0RmlsZSA9IHRoaXMubWV0YWRhdGFDYWNoZS5nZXRGaXJzdExpbmtwYXRoRGVzdChwYXRoLCAnJykgYXMgVEZpbGVcbiAgICBhd2FpdCB0aGlzLmZpbGVNYW5hZ2VyLnByb2Nlc3NGcm9udE1hdHRlcihcbiAgICAgIHRGaWxlLFxuICAgICAgcHJvcGVydHkgPT4ge1xuICAgICAgICBwcm9wZXJ0eVsnZmZfZGF0ZSddICAgICAgPSBldmVudFsnZmZfZGF0ZSddLnRvSVNPU3RyaW5nKCkuc2xpY2UoMCwtMTQpXG4gICAgICAgIHByb3BlcnR5WydmZl90aW1lU3RhcnQnXSA9IGV2ZW50WydmZl90aW1lU3RhcnQnXVxuICAgICAgICBwcm9wZXJ0eVsnZmZfZHVyYXRpb24nXSAgPSBldmVudFsnZmZfZHVyYXRpb24nXVxuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBjaGFuZ2VTdGF0dXNGaWxlKHBhdGg6IHN0cmluZywgc3RhdHVzOiBzdHJpbmcpIHtcbiAgICAvLyBOT1RFIFx1MDQ0RFx1MDQ0Mlx1MDQzRSBcdTA0M0VcdTA0NDJcdTA0M0ZcdTA0NDBcdTA0MzBcdTA0MzJcdTA0MzhcdTA0NDIgXHUwNDQxXHUwNDM4XHUwNDMzXHUwNDNEXHUwNDMwXHUwNDNCIGNhY2hlXG4gICAgY29uc3QgdEZpbGUgPSB0aGlzLm1ldGFkYXRhQ2FjaGUuZ2V0Rmlyc3RMaW5rcGF0aERlc3QocGF0aCwgJycpIGFzIFRGaWxlXG4gICAgYXdhaXQgdGhpcy5maWxlTWFuYWdlci5wcm9jZXNzRnJvbnRNYXR0ZXIoXG4gICAgICB0RmlsZSxcbiAgICAgIHByb3BlcnR5ID0+IHtcbiAgICAgICAgcHJvcGVydHlbJ2ZmX3N0YXR1cyddID0gc3RhdHVzXG4gICAgICB9XG4gICAgKVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGNoYW5nZVRpY2tGaWxlKHBhdGg6IHN0cmluZywgdGlja25hbWU6c3RyaW5nLCBldmVudDogSURhdGUpIHtcbiAgICAvLyBOT1RFIFx1MDQ0RFx1MDQ0Mlx1MDQzRSBcdTA0M0VcdTA0NDJcdTA0M0ZcdTA0NDBcdTA0MzBcdTA0MzJcdTA0MzhcdTA0NDIgXHUwNDQxXHUwNDM4XHUwNDMzXHUwNDNEXHUwNDMwXHUwNDNCIGNhY2hlXG4gICAgY29uc3QgdEZpbGUgPSB0aGlzLm1ldGFkYXRhQ2FjaGUuZ2V0Rmlyc3RMaW5rcGF0aERlc3QocGF0aCwgJycpIGFzIFRGaWxlXG5cbiAgICAvLyAhIFx1MDQzQ1x1MDQzMSwgXHUwNDNGXHUwNDNFXHUwNDNDXHUwNDM1XHUwNDNEXHUwNDRGXHUwNDQyXHUwNDRDIFx1MDQ0MSBcdTA0MzhcdTA0NDFcdTA0M0ZcdTA0M0VcdTA0M0JcdTA0NENcdTA0MzdcdTA0M0VcdTA0MzJcdTA0MzBcdTA0M0RcdTA0MzhcdTA0MzVcdTA0M0MgXHUwNDM0XHUwNDQwXHUwNDQzXHUwNDMzXHUwNDNFXHUwNDM5IFx1MDQzQlx1MDQzOFx1MDQzMVx1MDQ0QiAoXHUwNDQxXHUwNDNDLiBcdTA0M0ZcdTA0M0JcdTA0MzBcdTA0MzNcdTA0MzhcdTA0M0QgXHUwNDM0XHUwNDQwXHUwNDQzXHUwNDMzXHUwNDNFXHUwNDM5IFx1MDQ0MSBcdTA0MzJcdTA0MzhcdTA0MzRcdTA0M0VcdTA0NDFcdTA0MzAgWW91VHViZSlcbiAgICBjb25zdCB0ZXh0ID0gYXdhaXQgdGhpcy52YXVsdC5yZWFkKHRGaWxlKVxuICAgIGNvbnN0IHJlZ0V4cCA9IG5ldyBSZWdFeHAoYFxcXFxbdDo6XFxcXHMqJHt0aWNrbmFtZX0oLFteXFxcXF1dKnwpXFxcXF1gLCBcImdtXCIpXG5cbiAgICBjb25zdCBkYXRlID0gZXZlbnRbXCJmZl9kYXRlXCJdLnRvSVNPU3RyaW5nKCkuc2xpY2UoMCwtMTQpXG4gICAgY29uc3QgbmV3U3RyaW5nID0gYFt0Ojoke3RpY2tuYW1lfSwke2RhdGV9LCR7ZXZlbnRbXCJmZl90aW1lU3RhcnRcIl19LCR7ZXZlbnRbJ2ZmX2R1cmF0aW9uJ119XWBcblxuICAgIGF3YWl0IHRoaXMudmF1bHQubW9kaWZ5KFxuICAgICAgdEZpbGUsXG4gICAgICB0ZXh0LnJlcGxhY2UocmVnRXhwLCBuZXdTdHJpbmcpXG4gICAgKVxuICB9XG5cbiAgcHVibGljIG9wZW5Ob3RlKGV2ZW50OiBJRXZlbnQpIHtcbiAgICAvLyBOT1RFIFx1MDQ0MVx1MDQzRFx1MDQzMFx1MDQ0N1x1MDQzMFx1MDQzQlx1MDQzMCBcdTA0M0ZcdTA0NDBcdTA0M0VcdTA0MzJcdTA0MzVcdTA0NDBcdTA0NEZcdTA0MzVcdTA0NDIgXHUwNDQyXHUwNDM4XHUwNDNBIFx1MDQzQlx1MDQzOCBcdTA0NERcdTA0NDJcdTA0M0UsIFx1MDQzMCBcdTA0M0ZcdTA0M0VcdTA0NDJcdTA0M0VcdTA0M0MgXHUwNDNGXHUwNDM1XHUwNDQwXHUwNDM1XHUwNDQ1XHUwNDNFXHUwNDM0XHUwNDM4XHUwNDQyIFx1MDQzQSBpZFxuICAgIGNvbnN0IHRGaWxlID0gdGhpcy5tZXRhZGF0YUNhY2hlLmdldEZpcnN0TGlua3BhdGhEZXN0KFxuICAgICAgZXZlbnQ/LmV4dGVuZGVkUHJvcHM/Lm5vdGVQYXRoIHx8IGV2ZW50LmlkLCAnJ1xuICAgIClcblxuICAgIC8vIGZhbHNlID0gb3BlbiBpbiB0aGUgY3VycmVudCB0YWJcbiAgICBjb25zdCBsZWFmID0gdGhpcy53b3Jrc3BhY2UuZ2V0TGVhZih0cnVlKVxuICAgIHRGaWxlICYmIGxlYWYub3BlbkZpbGUodEZpbGUpXG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZ2V0UGFnZShmaWxlOiBURmlsZSk6IFByb21pc2U8SVBhZ2U+IHtcbiAgICBjb25zdCByZXN1bHQ6IElQYWdlID0ge1xuICAgICAgZmlsZToge1xuICAgICAgICBwYXRoOiBmaWxlLnBhdGgsXG4gICAgICAgIG5hbWU6IGZpbGUuYmFzZW5hbWVcbiAgICAgIH0sXG4gICAgICB0aWNrczogZ2V0VGlja3NGcm9tVGV4dChhd2FpdCB0aGlzLnZhdWx0LmNhY2hlZFJlYWQoZmlsZSkpLFxuICAgICAgZmZfZHVyYXRpb246IFwiXCIsXG4gICAgICBmZl90aW1lU3RhcnQ6IFwiXCIsXG5cbiAgICAgIC8vIFRPRE8gXHUwNDM4XHUwNDM3LVx1MDQzN1x1MDQzMCBcdTA0NDJcdTA0M0VcdTA0MzNcdTA0M0UsIFx1MDQ0N1x1MDQ0Mlx1MDQzRSBcdTA0M0RcdTA0MzUgXHUwNDMyXHUwNDQxXHUwNDM1IFx1MDQzN1x1MDQzMFx1MDQzQ1x1MDQzNVx1MDQ0Mlx1MDQzQVx1MDQzOCBcdTA0MzhcdTA0M0NcdTA0MzVcdTA0NEVcdTA0NDIgZmZfZGF0ZSwgXHUwNDNFXHUwNDNEIFx1MDQzNFx1MDQzRVx1MDQzQlx1MDQzNlx1MDQzNVx1MDQzRCBcdTA0MzJcdTA0M0VcdTA0MzdcdTA0MzJcdTA0NDBcdTA0MzBcdTA0NDlcdTA0MzBcdTA0NDJcdTA0NEMgbnVsbCwgXHUwNDNEXHUwNDNFIFx1MDQ0RFx1MDQ0Mlx1MDQzRSBiYWQgcHJhY3RpY2VcbiAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgZmZfZGF0ZTogbnVsbCxcbiAgICB9XG5cbiAgICBjb25zdCBwcm9wZXJ0eSA9IHRoaXMubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSk/LmZyb250bWF0dGVyXG4gICAgaWYgKCFwcm9wZXJ0eSkge1xuICAgICAgLy8gYmFkIHdheSwgY2F1c2UgaXQgbWF5IGhhdmVuJ3QgZXhwZWN0ZWQgZmllbGRzXG4gICAgICAvLyBUT0RPIHRocm93IEVycm9yKFwidW5yZWFjaGFibGVcIilcbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG5cbiAgICBjb25zdCBhZGRlZCA9IHtcbiAgICAgIGZmX2R1cmF0aW9uOiBkdi5kdXJhdGlvbihwcm9wZXJ0eS5mZl9kdXJhdGlvbiksXG4gICAgICBmZl90aW1lU3RhcnQ6IGR2LmR1cmF0aW9uKHByb3BlcnR5LmZmX3RpbWVTdGFydCksXG4gICAgICBmZl9kYXRlOiBkdi5kYXRlKHByb3BlcnR5LmZmX2RhdGUpLFxuICAgICAgZmZfc3RhdHVzOiBwcm9wZXJ0eS5mZl9zdGF0dXNcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4ucmVzdWx0LFxuICAgICAgLi4uYWRkZWRcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0VGFza0NvdW50KHBhZ2U6IElQYWdlKTogSVRhc2tzIHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICBkb25lOiAwLFxuICAgICAgYWxsOiAwXG4gICAgfVxuXG4gICAgY29uc3QgdEZpbGUgPSB0aGlzLnZhdWx0LmdldEZpbGVCeVBhdGgocGFnZS5maWxlLnBhdGgpXG5cbiAgICBpZiAoIXRGaWxlKVxuICAgICAgcmV0dXJuIHJlc3VsdFxuXG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKHRGaWxlKT8ubGlzdEl0ZW1zXG5cbiAgICBpZiAoaXRlbXMpIGZvciAobGV0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgIGlmIChpdGVtLnRhc2sgPT0gdW5kZWZpbmVkKVxuICAgICAgICBjb250aW51ZVxuXG4gICAgICBpZiAoaXRlbS50YXNrID09ICd4Jykge1xuICAgICAgICArK3Jlc3VsdC5kb25lXG4gICAgICB9XG4gICAgICArK3Jlc3VsdC5hbGxcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZ2V0VGV4dChwYXRoOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IHRGaWxlID0gdGhpcy5tZXRhZGF0YUNhY2hlLmdldEZpcnN0TGlua3BhdGhEZXN0KHBhdGgsICcnKSBhcyBURmlsZVxuICAgIGNvbnN0IHRleHQgPSBhd2FpdCB0aGlzLnZhdWx0LnJlYWQodEZpbGUpXG5cbiAgICByZXR1cm4gdGV4dFxuICB9XG5cbiAgcHVibGljIGFzeW5jIHNldFRleHQocGF0aDogc3RyaW5nLCB0ZXh0OiBzdHJpbmcpIHtcbiAgICBjb25zdCB0RmlsZSA9IHRoaXMubWV0YWRhdGFDYWNoZS5nZXRGaXJzdExpbmtwYXRoRGVzdChwYXRoLCAnJykgYXMgVEZpbGVcblxuICAgIGF3YWl0IHRoaXMudmF1bHQubW9kaWZ5KHRGaWxlLCB0ZXh0KVxuICB9XG5cbn1cbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBS0EsUUFBTSxhQUFOLGNBQXlCLE1BQU07SUFBQTtB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YztBQUFBLEVBQ2Qsd0JBQXdCO0FBQUEsRUFDeEIscUJBQXFCO0FBQUEsRUFDckIsc0JBQXNCO0FBQUEsRUFDdEIseUJBQXlCO0FBQUEsRUFDekIscUJBQXFCO0FBQUEsRUFDckIsY0FBYztBQUFBLEVBQ2QsWUFBWTtBQUFBLEVBQ1osVUFBVTtBQUFBLEVBQ1YsZUFBZTtBQUFBLEVBQ2YsVUFBVTtBQUFBLEVBQ1YsU0FBUztBQUFBLEVBQ1QsUUFBUTtBQUFBLEVBQ1IsYUFBYTtBQUFBLEVBQ2Isb0JBQW9CO0FBQUEsRUFDcEIsWUFBWTtBQUFBLEVBQ1osd0JBQXdCO0FBQUEsRUFDeEIsY0FBYztBQUFBLEVBQ2QsWUFBWTtBQUFBLEVBQ1osWUFBWTtBQUFBLEVBQ1osa0JBQWtCO0FBQUEsRUFDbEIsb0JBQW9CO0FBQUEsRUFDcEIsbUJBQW1CO0FBQUEsRUFDbkIsZ0JBQWdCO0FBQUEsRUFDaEIsc0JBQXNCO0FBQUEsRUFDdEIsWUFBWTtBQUFBLEVBQ1osUUFBUTtBQUFBLEVBQ1IsZUFBZTtBQUFBLEVBQ2YsV0FBVztBQUFBLEVBQ1gsa0JBQWtCO0FBQUEsRUFDbEIseUJBQXlCO0FBQUEsRUFDekIsa0JBQWtCO0FBQUEsRUFDbEIsaUJBQWlCO0FBQUEsRUFDakIsVUFBVTtBQUFBLEVBQ1YsY0FBYztBQUFBLEVBQ2QsMkJBQTJCO0FBQUEsRUFDM0IsZUFBZTtBQUFBLEVBQ2YsYUFBYTtBQUFBLEVBQ2IsS0FBSztBQUFBLEVBQ0wsb0JBQW9CO0FBQUEsRUFDcEIsbUJBQW1CO0FBQUEsRUFDbkIsdUJBQXVCO0FBQUEsRUFDdkIsWUFBWTtBQUFBLEVBQ1osZUFBZTtBQUFBLEVBQ2Ysb0JBQW9CO0FBQUEsRUFDcEIsb0JBQW9CO0FBQUEsRUFDcEIsY0FBYztBQUFBLEVBQ2Qsb0JBQW9CO0FBQUEsRUFDcEIsdUJBQXVCO0FBQUEsRUFDdkIsY0FBYztBQUFBLEVBQ2QsaUJBQWlCO0FBQUEsRUFDakIsWUFBWTtBQUFBLEVBQ1osc0JBQXNCO0FBQUEsRUFDdEIsa0JBQWtCO0FBQUEsRUFDbEIsZ0JBQWdCO0FBQUEsRUFDaEIsWUFBWTtBQUFBLEVBQ1osaUJBQWlCO0FBQUEsRUFDakIsY0FBYztBQUFBLEVBQ2QsZUFBZTtBQUFBLEVBQ2Ysa0JBQWtCO0FBQUEsRUFDbEIsa0JBQWtCO0FBQUEsRUFDbEIsZUFBZTtBQUFBLEVBQ2YsYUFBYTtBQUFBLEVBQ2IsV0FBVztBQUFBLEVBQ1gsZ0JBQWdCO0FBQUEsRUFDaEIsaUJBQWlCO0FBQUEsRUFDakIsb0JBQW9CO0FBQUEsRUFDcEIsaUJBQWlCO0FBQUEsRUFDakIsa0JBQWtCO0FBQUEsRUFDbEIscUJBQXFCO0FBQUEsRUFDckIscUJBQXFCO0FBQUEsRUFDckIsa0JBQWtCO0FBQUEsRUFDbEIsbUJBQW1CO0FBQUEsRUFDbkIsc0JBQXNCO0FBQUEsRUFDdEIsY0FBYztBQUFBLEVBQ2QsaUJBQWlCO0FBQUEsRUFDakIsYUFBYTtBQUFBLEVBQ2IsbUJBQW1CO0FBQUEsRUFDbkIsWUFBWTtBQUFBLEVBQ1osa0JBQWtCO0FBQUEsRUFDbEIsZUFBZTtBQUFBLEVBQ2YsZ0JBQWdCO0FBQUEsRUFDaEIsbUJBQW1CO0FBQUEsRUFDbkIsY0FBYztBQUFBLEVBQ2QsVUFBVTtBQUFBLEVBQ1YsaUJBQWlCO0FBQUEsRUFDakIsZUFBZTtBQUFBLEVBQ2YsY0FBYztBQUFBLEVBQ2QsY0FBYztBQUFBLEVBQ2QsbUJBQW1CO0FBQUEsRUFDbkIsWUFBWTtBQUFBLEVBQ1osc0JBQXNCO0FBQUEsRUFDdEIscUJBQXFCO0FBQUEsRUFDckIsY0FBYztBQUFBLEVBQ2QsZUFBZTtBQUFBLEVBQ2YsZ0JBQWdCO0FBQUEsRUFDaEIsZUFBZTtBQUFBLEVBQ2Ysa0JBQWtCO0FBQUEsRUFDbEIsa0JBQWtCO0FBQUEsRUFDbEIsU0FBUztBQUFBLEVBQ1QsVUFBVTtBQUFBLEVBQ1YsVUFBVTtBQUFBLEVBQ1YsZUFBZTtBQUFBLEVBQ2YsZUFBZTtBQUFBLEVBQ2YsWUFBWTtBQUFBLEVBQ1osZ0JBQWdCO0FBQUEsRUFDaEIsWUFBWTtBQUFBLEVBQ1osY0FBYztBQUFBLEVBQ2QsYUFBYTtBQUFBLEVBQ2Isa0JBQWtC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QUFFLEtBQXNCLE9BQU87QUFDeEMsV0FBSyxJQUFJLFVBQVUsY0FBYyxPQUFPLENBQUMsQ0FBQztBQUFBLElBQzVDO0FBQ0ssZUFBUyxRQUFRO0FBQ3BCLGFBQUssT0FBTztBQUFBLEVBQ2hCO0FBQUE7QUFBQSxFQUtPLGNBQThCO0FBRW5DLFdBQU8sS0FBSztBQUFBLE1BQ1YsS0FBSyxVQUFVLEtBQUssUUFBUTtBQUFBLElBQzlCO0FBQUEsRUFDRjtBQUFBLEVBRUEsTUFBYSxhQUFhLFVBQTBCO0FBQ2xELFNBQUssV0FBVztBQUNoQixVQUFNLEtBQUssU0FBUyxLQUFLLFFBQVE7QUFBQSxFQUNuQztBQUFBLEVBSUEsTUFBYyxlQUFlO0FBQzNCLFNBQUssV0FBVyxPQUFPLE9BQU8sQ0FBQyxHQUFHLGtCQUFrQixNQUFNLEtBQUssU0FBUyxDQUFDO0FBRXpFLFNBQUssY0FBYyxJQUFJLGFBQWEsS0FBSyxLQUFLLElBQUksQ0FBQztBQUFBLEVBQ3JEO0FBQ0Y7IiwKICAibmFtZXMiOiBbIm4iLCAicyIsICJsIiwgInNpbmdsZXRvbiIsICJpIiwgImUiLCAiZiIsICJEYXRlVGltZSIsICJwYWRTdGFydCIsICJ6IiwgIkVuZ2xpc2guZm9ybWF0UmVsYXRpdmVUaW1lIiwgIkVuZ2xpc2gubW9udGhzIiwgIkVuZ2xpc2gud2Vla2RheXMiLCAiRW5nbGlzaC5tZXJpZGllbXMiLCAiRW5nbGlzaC5lcmFzIiwgIm0iLCAib2Zmc2V0IiwgInIiLCAiZGVmYXVsdFpvbmUiLCAiaXNOdW1iZXIiLCAidCIsICJvIiwgImlzRGF0ZSIsICJhIiwgImsiLCAiaGFzT3duUHJvcGVydHkiLCAieCIsICJpc0xlYXBZZWFyIiwgImQiLCAicDIiLCAidSIsICJ2IiwgIkZvcm1hdHMuREFURV9TSE9SVCIsICJGb3JtYXRzLkRBVEVfTUVEIiwgIkZvcm1hdHMuREFURV9GVUxMIiwgIkZvcm1hdHMuREFURV9IVUdFIiwgIkZvcm1hdHMuVElNRV9TSU1QTEUiLCAiRm9ybWF0cy5USU1FX1dJVEhfU0VDT05EUyIsICJGb3JtYXRzLlRJTUVfV0lUSF9TSE9SVF9PRkZTRVQiLCAiRm9ybWF0cy5USU1FX1dJVEhfTE9OR19PRkZTRVQiLCAiRm9ybWF0cy5USU1FXzI0X1NJTVBMRSIsICJGb3JtYXRzLlRJTUVfMjRfV0lUSF9TRUNPTkRTIiwgIkZvcm1hdHMuVElNRV8yNF9XSVRIX1NIT1JUX09GRlNFVCIsICJGb3JtYXRzLlRJTUVfMjRfV0lUSF9MT05HX09GRlNFVCIsICJGb3JtYXRzLkRBVEVUSU1FX1NIT1JUIiwgIkZvcm1hdHMuREFURVRJTUVfTUVEIiwgIkZvcm1hdHMuREFURVRJTUVfRlVMTCIsICJGb3JtYXRzLkRBVEVUSU1FX0hVR0UiLCAiRm9ybWF0cy5EQVRFVElNRV9TSE9SVF9XSVRIX1NFQ09ORFMiLCAiRm9ybWF0cy5EQVRFVElNRV9NRURfV0lUSF9TRUNPTkRTIiwgIkZvcm1hdHMuREFURVRJTUVfRlVMTF9XSVRIX1NFQ09ORFMiLCAiRm9ybWF0cy5EQVRFVElNRV9IVUdFX1dJVEhfU0VDT05EUyIsICJjIiwgInAiLCAiZm9ybWF0T2Zmc2V0IiwgIkVuZ2xpc2gubWVyaWRpZW1Gb3JEYXRlVGltZSIsICJFbmdsaXNoLm1vbnRoRm9yRGF0ZVRpbWUiLCAiRW5nbGlzaC53ZWVrZGF5Rm9yRGF0ZVRpbWUiLCAiRW5nbGlzaC5lcmFGb3JEYXRlVGltZSIsICJwYXJzZSIsICJtYXRjaCIsICJFbmdsaXNoLm1vbnRoc1Nob3J0IiwgIkVuZ2xpc2gud2Vla2RheXNMb25nIiwgIkVuZ2xpc2gud2Vla2RheXNTaG9ydCIsICJJTlZBTElEIiwgIm9yZGVyZWRVbml0cyIsICJjbG9uZSIsICJjb25maWciLCAidjIiLCAiYiIsICJoIiwgIm8yIiwgImMyIiwgInEiLCAiRm9ybWF0cy5EQVRFX01FRF9XSVRIX1dFRUtEQVkiLCAiRm9ybWF0cy5EQVRFVElNRV9NRURfV0lUSF9XRUVLREFZIiwgIlJlc3VsdCIsICJtb2R1bGUiLCAidGhpcyIsICJnIiwgInkiLCAiRSIsICJ3IiwgIkIiLCAiaiIsICJTIiwgIl8iLCAiTCIsICJPIiwgIlAiLCAiQSIsICJJIiwgIkYiLCAiTSIsICJVIiwgIlciLCAiRCIsICJOIiwgIkciLCAiQyIsICJKIiwgIlQiLCAiViIsICJIIiwgIlgiLCAiSyIsICJRIiwgIloiLCAiJCIsICJubiIsICJ0biIsICJlbiIsICJQLmFsdCIsICJQLnJlZ2V4IiwgIlAud2hpdGVzcGFjZSIsICJQLmFueSIsICJWYWx1ZXMiLCAiaXNTdHJpbmciLCAiaXNBcnJheSIsICJpc09iamVjdCIsICJmMiIsICJpbmRleCIsICJrMiIsICJpc1RydXRoeSIsICJHcm91cGluZ3MiLCAiZGlzcGxheSIsICJzcGxpdCIsICJXaWRnZXRzIiwgIkZpZWxkcyIsICJmdW5jIiwgIlNvdXJjZXMiLCAidGFnIiwgImVtcHR5IiwgImNvbWJpbmUiLCAiUC5zZXFNYXAiLCAiUC5zZXEiLCAiUC5vcHRXaGl0ZXNwYWNlIiwgIlAuY3VzdG9tIiwgIlAuY3JlYXRlTGFuZ3VhZ2UiLCAiUC5yZWdleHAiLCAiUC5zdHJpbmciLCAiUC5ub25lT2YiLCAiUC5zdWNjZWVkIiwgIl8yIiwgIlAuZmFpbCIsICJfMyIsICJRdWVyeUZpZWxkcyIsICJQLmVvZiIsICJQLlBhcnNlciIsICJQLm1ha2VGYWlsdXJlIiwgIlAubWFrZVN1Y2Nlc3MiLCAiUC5zZXBCeSIsICJzb3J0IiwgImdldEFQSSIsICJtb2R1bGUiLCAiSUNBTCIsICJpIiwgIkYiLCAiayIsICJ4IiwgImUiLCAic3BsaXQiLCAiQ29tcG9uZW50IiwgImluZGV4IiwgInAiLCAiYSIsICJiIiwgImgyIiwgInIiLCAiYVByb3AiLCAiY2xvbmUiLCAicSIsICJtIiwgImgiLCAiZGF5c0JldHdlZW4iLCAiaXNEYXRlIiwgImlzTGVhcFllYXIiLCAidCIsICJwMiIsICJ5IiwgImQiLCAicyIsICJ2IiwgIm8iLCAiaXRlciIsICJrZXkiLCAic2VsZiIsICJ0MiIsICJ0MyIsICJqIiwgInByb3AiLCAiRXZlbnQiLCAicmFuZ2UiLCAiaW1wb3J0X29ic2lkaWFuIiwgImkiLCAiXyIsICJpbmRleCIsICJwYWdlIiwgInNsaWNlIiwgIm9wdGlvbnMiLCAidm5vZGVJZCIsICJpc1ZhbGlkRWxlbWVudCIsICJpbkV2ZW50IiwgInJlcmVuZGVyUXVldWUiLCAicHJldkRlYm91bmNlIiwgIm1pY3JvVGljayIsICJpIiwgIkVNUFRZX09CSiIsICJFTVBUWV9BUlIiLCAiSVNfTk9OX0RJTUVOU0lPTkFMIiwgImFzc2lnbiIsICJvYmoiLCAicHJvcHMiLCAicmVtb3ZlTm9kZSIsICJub2RlIiwgInBhcmVudE5vZGUiLCAicmVtb3ZlQ2hpbGQiLCAiY3JlYXRlRWxlbWVudCIsICJ0eXBlIiwgImNoaWxkcmVuIiwgImtleSIsICJyZWYiLCAibm9ybWFsaXplZFByb3BzIiwgImFyZ3VtZW50cyIsICJsZW5ndGgiLCAiY2FsbCIsICJkZWZhdWx0UHJvcHMiLCAiY3JlYXRlVk5vZGUiLCAib3JpZ2luYWwiLCAidm5vZGUiLCAiX19rIiwgIl9fIiwgIl9fYiIsICJfX2UiLCAiX19kIiwgIl9fYyIsICJfX2giLCAiY29uc3RydWN0b3IiLCAiX192IiwgImNyZWF0ZVJlZiIsICJjdXJyZW50IiwgIkZyYWdtZW50IiwgImRpZmZQcm9wcyIsICJkb20iLCAibmV3UHJvcHMiLCAib2xkUHJvcHMiLCAiaXNTdmciLCAiaHlkcmF0ZSIsICJzZXRQcm9wZXJ0eSIsICJzZXRTdHlsZSIsICJzdHlsZSIsICJ2YWx1ZSIsICJ0ZXN0IiwgIm5hbWUiLCAib2xkVmFsdWUiLCAidXNlQ2FwdHVyZSIsICJvIiwgImNzc1RleHQiLCAicmVwbGFjZSIsICJ0b0xvd2VyQ2FzZSIsICJsIiwgImFkZEV2ZW50TGlzdGVuZXIiLCAiZXZlbnRQcm94eUNhcHR1cmUiLCAiZXZlbnRQcm94eSIsICJyZW1vdmVFdmVudExpc3RlbmVyIiwgImUiLCAiaW5kZXhPZiIsICJyZW1vdmVBdHRyaWJ1dGUiLCAic2V0QXR0cmlidXRlIiwgInRoaXMiLCAiZXZlbnQiLCAiQ29tcG9uZW50IiwgImNvbnRleHQiLCAiZ2V0RG9tU2libGluZyIsICJjaGlsZEluZGV4IiwgInNpYmxpbmciLCAidXBkYXRlUGFyZW50RG9tUG9pbnRlcnMiLCAiY2hpbGQiLCAiYmFzZSIsICJkZWZlciIsICJjYiIsICJzZXRUaW1lb3V0IiwgImVucXVldWVSZW5kZXIiLCAiYyIsICJwdXNoIiwgInByb2Nlc3MiLCAiX19yIiwgImRlYm91bmNlUmVuZGVyaW5nIiwgInJlbmRlclF1ZXVlTGVuZ3RoIiwgImNvbXBvbmVudCIsICJjb21taXRRdWV1ZSIsICJvbGRWTm9kZSIsICJvbGREb20iLCAicGFyZW50RG9tIiwgInNvcnQiLCAiYSIsICJiIiwgInNoaWZ0IiwgIl9fUCIsICJkaWZmIiwgIm93bmVyU1ZHRWxlbWVudCIsICJjb21taXRSb290IiwgImRpZmZDaGlsZHJlbiIsICJyZW5kZXJSZXN1bHQiLCAibmV3UGFyZW50Vk5vZGUiLCAib2xkUGFyZW50Vk5vZGUiLCAiZ2xvYmFsQ29udGV4dCIsICJleGNlc3NEb21DaGlsZHJlbiIsICJpc0h5ZHJhdGluZyIsICJqIiwgImNoaWxkVk5vZGUiLCAibmV3RG9tIiwgImZpcnN0Q2hpbGREb20iLCAicmVmcyIsICJvbGRDaGlsZHJlbiIsICJvbGRDaGlsZHJlbkxlbmd0aCIsICJBcnJheSIsICJpc0FycmF5IiwgInJlb3JkZXJDaGlsZHJlbiIsICJwbGFjZUNoaWxkIiwgImdldExhc3REb20iLCAibmV4dFNpYmxpbmciLCAidW5tb3VudCIsICJhcHBseVJlZiIsICJ0bXAiLCAidG9DaGlsZEFycmF5IiwgIm91dCIsICJzb21lIiwgIm5leHREb20iLCAic2liRG9tIiwgIm91dGVyIiwgImFwcGVuZENoaWxkIiwgImluc2VydEJlZm9yZSIsICJsYXN0RG9tIiwgIm5ld1ZOb2RlIiwgImlzTmV3IiwgIm9sZFN0YXRlIiwgInNuYXBzaG90IiwgImNsZWFyUHJvY2Vzc2luZ0V4Y2VwdGlvbiIsICJwcm92aWRlciIsICJjb21wb25lbnRDb250ZXh0IiwgInJlbmRlckhvb2siLCAiY291bnQiLCAibmV3VHlwZSIsICJjb250ZXh0VHlwZSIsICJfX0UiLCAicHJvdG90eXBlIiwgInJlbmRlciIsICJkb1JlbmRlciIsICJzdWIiLCAic3RhdGUiLCAiX3NiIiwgIl9fcyIsICJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCAiY29tcG9uZW50V2lsbE1vdW50IiwgImNvbXBvbmVudERpZE1vdW50IiwgImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCAic2hvdWxkQ29tcG9uZW50VXBkYXRlIiwgImZvckVhY2giLCAiY29tcG9uZW50V2lsbFVwZGF0ZSIsICJjb21wb25lbnREaWRVcGRhdGUiLCAiZ2V0Q2hpbGRDb250ZXh0IiwgImdldFNuYXBzaG90QmVmb3JlVXBkYXRlIiwgImRpZmZFbGVtZW50Tm9kZXMiLCAiZGlmZmVkIiwgInJvb3QiLCAib2xkSHRtbCIsICJuZXdIdG1sIiwgIm5vZGVUeXBlIiwgImxvY2FsTmFtZSIsICJkb2N1bWVudCIsICJjcmVhdGVUZXh0Tm9kZSIsICJjcmVhdGVFbGVtZW50TlMiLCAiaXMiLCAiZGF0YSIsICJjaGlsZE5vZGVzIiwgImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwgImF0dHJpYnV0ZXMiLCAiX19odG1sIiwgImlubmVySFRNTCIsICJjaGVja2VkIiwgInBhcmVudFZOb2RlIiwgInNraXBSZW1vdmUiLCAiciIsICJjb21wb25lbnRXaWxsVW5tb3VudCIsICJyZXBsYWNlTm9kZSIsICJmaXJzdENoaWxkIiwgImNyZWF0ZUNvbnRleHQiLCAiZGVmYXVsdFZhbHVlIiwgImNvbnRleHRJZCIsICJjb250ZXh0IiwgIl9fYyIsICJpIiwgIl9fIiwgIkNvbnN1bWVyIiwgInByb3BzIiwgImNvbnRleHRWYWx1ZSIsICJjaGlsZHJlbiIsICJQcm92aWRlciIsICJzdWJzIiwgImN0eCIsICJ0aGlzIiwgImdldENoaWxkQ29udGV4dCIsICJzaG91bGRDb21wb25lbnRVcGRhdGUiLCAiX3Byb3BzIiwgInZhbHVlIiwgInNvbWUiLCAiYyIsICJfX2UiLCAiZW5xdWV1ZVJlbmRlciIsICJzdWIiLCAicHVzaCIsICJvbGQiLCAiY29tcG9uZW50V2lsbFVubW91bnQiLCAic3BsaWNlIiwgImluZGV4T2YiLCAiY2FsbCIsICJjb250ZXh0VHlwZSIsICJzbGljZSIsICJFTVBUWV9BUlIiLCAib3B0aW9ucyIsICJlcnJvciIsICJ2bm9kZSIsICJvbGRWTm9kZSIsICJlcnJvckluZm8iLCAiY29tcG9uZW50IiwgImN0b3IiLCAiaGFuZGxlZCIsICJjb25zdHJ1Y3RvciIsICJnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IiLCAic2V0U3RhdGUiLCAiX19kIiwgImNvbXBvbmVudERpZENhdGNoIiwgIl9fRSIsICJlIiwgInZub2RlSWQiLCAiaXNWYWxpZEVsZW1lbnQiLCAiaW5FdmVudCIsICJDb21wb25lbnQiLCAicHJvdG90eXBlIiwgInVwZGF0ZSIsICJjYWxsYmFjayIsICJzIiwgIl9fcyIsICJzdGF0ZSIsICJhc3NpZ24iLCAiX192IiwgIl9zYiIsICJmb3JjZVVwZGF0ZSIsICJfX2giLCAicmVuZGVyIiwgIkZyYWdtZW50IiwgInJlcmVuZGVyUXVldWUiLCAibWljcm9UaWNrIiwgIlByb21pc2UiLCAidGhlbiIsICJiaW5kIiwgInJlc29sdmUiLCAic2V0VGltZW91dCIsICJwcm9jZXNzIiwgIl9fciIsICJjdXJyZW50SW5kZXgiLCAiY3VycmVudENvbXBvbmVudCIsICJwcmV2aW91c0NvbXBvbmVudCIsICJwcmV2UmFmIiwgImFmdGVyUGFpbnRFZmZlY3RzIiwgIkVNUFRZIiwgIm9sZEJlZm9yZURpZmYiLCAib3B0aW9ucyIsICJvbGRCZWZvcmVSZW5kZXIiLCAib2xkQWZ0ZXJEaWZmIiwgImRpZmZlZCIsICJvbGRDb21taXQiLCAiX19jIiwgIm9sZEJlZm9yZVVubW91bnQiLCAidW5tb3VudCIsICJmbHVzaEFmdGVyUGFpbnRFZmZlY3RzIiwgImNvbXBvbmVudCIsICJhZnRlclBhaW50RWZmZWN0cyIsICJzaGlmdCIsICJfX0giLCAiZm9yRWFjaCIsICJpbnZva2VDbGVhbnVwIiwgImludm9rZUVmZmVjdCIsICJfX2giLCAiZSIsICJvcHRpb25zIiwgIl9fZSIsICJfX2IiLCAidm5vZGUiLCAiY3VycmVudENvbXBvbmVudCIsICJvbGRCZWZvcmVEaWZmIiwgIm9sZEJlZm9yZVJlbmRlciIsICJjdXJyZW50SW5kZXgiLCAiaG9va3MiLCAiX19jIiwgInByZXZpb3VzQ29tcG9uZW50IiwgIl9fIiwgImhvb2tJdGVtIiwgIl9fTiIsICJFTVBUWSIsICJfcGVuZGluZ0FyZ3MiLCAiZGlmZmVkIiwgIm9sZEFmdGVyRGlmZiIsICJjIiwgImxlbmd0aCIsICJwdXNoIiwgInByZXZSYWYiLCAicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwgImFmdGVyTmV4dEZyYW1lIiwgIl9fViIsICJjb21taXRRdWV1ZSIsICJzb21lIiwgImZpbHRlciIsICJjYiIsICJfX3YiLCAib2xkQ29tbWl0IiwgInVubW91bnQiLCAib2xkQmVmb3JlVW5tb3VudCIsICJoYXNFcnJvcmVkIiwgInMiLCAiSEFTX1JBRiIsICJjYWxsYmFjayIsICJyYWYiLCAiZG9uZSIsICJjbGVhclRpbWVvdXQiLCAidGltZW91dCIsICJjYW5jZWxBbmltYXRpb25GcmFtZSIsICJzZXRUaW1lb3V0IiwgImhvb2siLCAiY29tcCIsICJjbGVhbnVwIiwgImFzc2lnbiIsICJvYmoiLCAicHJvcHMiLCAiaSIsICJzaGFsbG93RGlmZmVycyIsICJhIiwgImIiLCAiUHVyZUNvbXBvbmVudCIsICJwIiwgInRoaXMiLCAicHJvcHMiLCAiUHVyZUNvbXBvbmVudCIsICJwcm90b3R5cGUiLCAiQ29tcG9uZW50IiwgImlzUHVyZVJlYWN0Q29tcG9uZW50IiwgInNob3VsZENvbXBvbmVudFVwZGF0ZSIsICJwcm9wcyIsICJzdGF0ZSIsICJzaGFsbG93RGlmZmVycyIsICJ0aGlzIiwgIm9sZERpZmZIb29rIiwgIm9wdGlvbnMiLCAiX19iIiwgInZub2RlIiwgInR5cGUiLCAiX19mIiwgInJlZiIsICJSRUFDVF9GT1JXQVJEX1NZTUJPTCIsICJTeW1ib2wiLCAiZm9yIiwgIm9sZENhdGNoRXJyb3IiLCAib3B0aW9ucyIsICJfX2UiLCAiZXJyb3IiLCAibmV3Vk5vZGUiLCAib2xkVk5vZGUiLCAiZXJyb3JJbmZvIiwgInRoZW4iLCAiY29tcG9uZW50IiwgInZub2RlIiwgIl9fYyIsICJfX2siLCAib2xkVW5tb3VudCIsICJ1bm1vdW50IiwgImRldGFjaGVkQ2xvbmUiLCAiZGV0YWNoZWRQYXJlbnQiLCAicGFyZW50RG9tIiwgImZvckVhY2giLCAiZWZmZWN0IiwgIl9fSCIsICJhc3NpZ24iLCAiX19QIiwgIm1hcCIsICJjaGlsZCIsICJyZW1vdmVPcmlnaW5hbCIsICJvcmlnaW5hbFBhcmVudCIsICJfX3YiLCAiaW5zZXJ0QmVmb3JlIiwgIl9fZCIsICJTdXNwZW5zZSIsICJ0aGlzIiwgIl9fdSIsICJfc3VzcGVuZGVycyIsICJzdXNwZW5kZWQiLCAiX18iLCAiX19hIiwgIlN1c3BlbnNlTGlzdCIsICJ0aGlzIiwgIl9uZXh0IiwgIl9tYXAiLCAib3B0aW9ucyIsICJ1bm1vdW50IiwgInZub2RlIiwgImNvbXBvbmVudCIsICJfX2MiLCAiX19SIiwgIl9faCIsICJ0eXBlIiwgIm9sZFVubW91bnQiLCAiU3VzcGVuc2UiLCAicHJvdG90eXBlIiwgIkNvbXBvbmVudCIsICJwcm9taXNlIiwgInN1c3BlbmRpbmdWTm9kZSIsICJzdXNwZW5kaW5nQ29tcG9uZW50IiwgImMiLCAiX3N1c3BlbmRlcnMiLCAicHVzaCIsICJyZXNvbHZlIiwgInN1c3BlbmRlZCIsICJfX3YiLCAicmVzb2x2ZWQiLCAib25SZXNvbHZlZCIsICJvblN1c3BlbnNpb25Db21wbGV0ZSIsICJfX3UiLCAic3RhdGUiLCAiX19hIiwgInN1c3BlbmRlZFZOb2RlIiwgIl9fayIsICJyZW1vdmVPcmlnaW5hbCIsICJzZXRTdGF0ZSIsICJfX2IiLCAicG9wIiwgImZvcmNlVXBkYXRlIiwgIndhc0h5ZHJhdGluZyIsICJ0aGVuIiwgImNvbXBvbmVudFdpbGxVbm1vdW50IiwgInJlbmRlciIsICJwcm9wcyIsICJkZXRhY2hlZFBhcmVudCIsICJkb2N1bWVudCIsICJjcmVhdGVFbGVtZW50IiwgImRldGFjaGVkQ29tcG9uZW50IiwgImRldGFjaGVkQ2xvbmUiLCAiX19PIiwgIl9fUCIsICJmYWxsYmFjayIsICJGcmFnbWVudCIsICJjaGlsZHJlbiIsICJsaXN0IiwgImNoaWxkIiwgIm5vZGUiLCAiZGVsZXRlIiwgInJldmVhbE9yZGVyIiwgInNpemUiLCAibGVuZ3RoIiwgIkNvbnRleHRQcm92aWRlciIsICJnZXRDaGlsZENvbnRleHQiLCAiY29udGV4dCIsICJQb3J0YWwiLCAiX3RoaXMiLCAiY29udGFpbmVyIiwgIl9jb250YWluZXIiLCAiX3RlbXAiLCAibm9kZVR5cGUiLCAicGFyZW50Tm9kZSIsICJjaGlsZE5vZGVzIiwgImFwcGVuZENoaWxkIiwgImluc2VydEJlZm9yZSIsICJiZWZvcmUiLCAicmVtb3ZlQ2hpbGQiLCAic3BsaWNlIiwgImluZGV4T2YiLCAiY3JlYXRlUG9ydGFsIiwgImVsIiwgImNvbnRhaW5lckluZm8iLCAiZGVsZWdhdGVkIiwgImdldCIsICJ1bnN1c3BlbmQiLCAid3JhcHBlZFVuc3VzcGVuZCIsICJNYXAiLCAidG9DaGlsZEFycmF5IiwgInJldmVyc2UiLCAiaSIsICJzZXQiLCAiY29tcG9uZW50RGlkVXBkYXRlIiwgImNvbXBvbmVudERpZE1vdW50IiwgImZvckVhY2giLCAiUkVBQ1RfRUxFTUVOVF9UWVBFIiwgIlN5bWJvbCIsICJmb3IiLCAiQ0FNRUxfUFJPUFMiLCAiSVNfRE9NIiwgIm9uQ2hhbmdlSW5wdXRUeXBlIiwgInRlc3QiLCAiQ29tcG9uZW50IiwgInByb3RvdHlwZSIsICJpc1JlYWN0Q29tcG9uZW50IiwgImZvckVhY2giLCAia2V5IiwgIk9iamVjdCIsICJkZWZpbmVQcm9wZXJ0eSIsICJjb25maWd1cmFibGUiLCAiZ2V0IiwgInRoaXMiLCAic2V0IiwgInYiLCAid3JpdGFibGUiLCAidmFsdWUiLCAib2xkRXZlbnRIb29rIiwgIm9wdGlvbnMiLCAiZXZlbnQiLCAiZW1wdHkiLCAiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCAiY2FuY2VsQnViYmxlIiwgImlzRGVmYXVsdFByZXZlbnRlZCIsICJkZWZhdWx0UHJldmVudGVkIiwgImUiLCAicGVyc2lzdCIsICJuYXRpdmVFdmVudCIsICJjdXJyZW50Q29tcG9uZW50IiwgImNsYXNzTmFtZURlc2NyaXB0b3IiLCAiY2xhc3MiLCAib2xkVk5vZGVIb29rIiwgInZub2RlIiwgInR5cGUiLCAicHJvcHMiLCAibm9ybWFsaXplZFByb3BzIiwgIm5vbkN1c3RvbUVsZW1lbnQiLCAiaW5kZXhPZiIsICJpIiwgIklTX0RPTSIsICJ0ZXN0IiwgIm9uQ2hhbmdlSW5wdXRUeXBlIiwgInRvTG93ZXJDYXNlIiwgIkNBTUVMX1BST1BTIiwgInJlcGxhY2UiLCAibXVsdGlwbGUiLCAiQXJyYXkiLCAiaXNBcnJheSIsICJ0b0NoaWxkQXJyYXkiLCAiY2hpbGRyZW4iLCAiY2hpbGQiLCAic2VsZWN0ZWQiLCAiZGVmYXVsdFZhbHVlIiwgImNsYXNzTmFtZSIsICJlbnVtZXJhYmxlIiwgIiQkdHlwZW9mIiwgIlJFQUNUX0VMRU1FTlRfVFlQRSIsICJvbGRCZWZvcmVSZW5kZXIiLCAiX19yIiwgIl9fYyIsICJpIiwgImoiLCAiaSIsICJhIiwgImIiLCAicyIsICJpbmRleCIsICJuIiwgIm0iLCAiZCIsICJuIiwgImkiLCAiaSIsICJtIiwgIm4iLCAiYSIsICJkIiwgInkiLCAidyIsICJzIiwgInMiLCAiZGlzcGxheSIsICJhIiwgImIiLCAiaSIsICJkIiwgIm0iLCAibiIsICJjIiwgImlzT2JqZWN0IiwgInJhbmdlIiwgInJlcyIsICJpIiwgImEiLCAiYiIsICJuIiwgImluZGV4IiwgImEiLCAicmFuZ2UiLCAiaW5kZXgiLCAiaSIsICJhIiwgImoiLCAiaSIsICJqIiwgInJhbmdlIiwgImRheXNPZldlZWsiLCAiaSIsICJkaXNwbGF5IiwgInJlbmRlcklubmVyQ29udGVudCIsICJjc3NfMjQ4eiIsICJyZW5kZXJJbm5lckNvbnRlbnQiLCAiREVGQVVMVF9XRUVLX05VTV9GT1JNQVQiLCAicmFuZ2UiLCAiaSIsICJyZW5kZXJNb3JlTGlua0lubmVyIiwgImEiLCAiYiIsICJjc3NfMjQ4eiIsICJpbmRleCIsICJXZWVrZGF5IiwgIm4iLCAicyIsICJpIiwgImkiLCAicGFkU3RhcnQiLCAiYSIsICJiIiwgInIiLCAieSIsICJtIiwgImQiLCAiaCIsICJpIiwgInMiLCAiaXNWYWxpZERhdGUiLCAiaSIsICJhIiwgImIiLCAicGFkU3RhcnQiLCAiSXRlclJlc3VsdCIsICJkIiwgImIiLCAicCIsICJfX2Fzc2lnbiIsICJ0IiwgInMiLCAiaSIsICJuIiwgImkiLCAibCIsICJDYWxsYmFja0l0ZXJSZXN1bHQiLCAiVG9UZXh0IiwgImEiLCAiYiIsICJuIiwgIm0iLCAicyIsICJpIiwgIm8iLCAiUGFyc2VyIiwgInYiLCAiUyIsICJuIiwgIkYiLCAibSIsICJGcmVxdWVuY3kiLCAiVGltZSIsICJEYXRlVGltZSIsICJpc1ZhbGlkRGF0ZSIsICJpIiwgInYiLCAicGFyc2VTdHJpbmciLCAieCIsICJuIiwgIkRhdGVXaXRoWm9uZSIsICJkZWZhdWx0S2V5cyIsICJpIiwgImoiLCAia2V5IiwgInZhbHVlIiwgIngiLCAiaSIsICJDYWNoZSIsICJpdGVtIiwgImkiLCAiaiIsICJuIiwgImkiLCAiayIsICJqIiwgImsiLCAiaSIsICJuIiwgInkiLCAiYSIsICJiIiwgImMiLCAiZCIsICJlIiwgImYiLCAiZyIsICJoIiwgImkiLCAiayIsICJsIiwgIm0iLCAiSXRlcmluZm8iLCAiXyIsICJpIiwgImoiLCAiaiIsICJrIiwgImkiLCAiaiIsICJrIiwgIlJSdWxlIiwgImlzVmFsaWREYXRlIiwgInBhcnNlU3RyaW5nIiwgInpvbmVkRGF0ZSIsICJpIiwgIkRFRkFVTFRfT1BUSU9OUyIsICJzIiwgInBhcnNlU3RyaW5nIiwgInZhbCIsICJpbml0aWFsaXplT3B0aW9ucyIsICJkZWZhdWx0S2V5cyIsICJpIiwgImkiLCAiUlJ1bGVTZXQiLCAiZSIsICJpbmRleCIsICJyZW5kZXJJbm5lckNvbnRlbnQiLCAiREVGQVVMVF9USU1FX0ZPUk1BVCIsICJyZW5kZXJBbGxEYXlJbm5lciIsICJyYW5nZSIsICJpIiwgImNzc18yNDh6IiwgIk9QVElPTl9SRUZJTkVSUyIsICJpbmRleCIsICJkcmFnZ2luZyIsICJjb21wb25lbnQiLCAib3B0aW9ucyIsICJjb250ZXh0IiwgImRvY3VtZW50UG9pbnRlciIsICJPUFRJT05fUkVGSU5FUlMiLCAiaW5kZXgiLCAiT1BUSU9OX1JFRklORVJTIiwgImV2ZW50U291cmNlRGVmIiwgImJ1aWxkUmVxdWVzdFBhcmFtcyIsICJyYW5nZSIsICJPUFRJT05fUkVGSU5FUlMiLCAiRVZFTlRfU09VUkNFX1JFRklORVJTIiwgImluZGV4IiwgImUiLCAiaSIsICJzdGFydFRpbWUiLCAiZW5kVGltZSIsICJldmVudFNvdXJjZURlZiIsICJyYW5nZSIsICJpbmRleCIsICJpbmRleCIsICJkIiwgImUiLCAiXyIsICJlIiwgImltcG9ydF9vYnNpZGlhbiIsICJDYWNoZSIsICJfIiwgImkiLCAiaW1wb3J0X29ic2lkaWFuIiwgImluZGV4IiwgImltcG9ydF9vYnNpZGlhbiIsICJpIiwgInBhZ2UiLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJDYWNoZSJdCn0K
