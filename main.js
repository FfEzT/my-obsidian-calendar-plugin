/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// node_modules/obsidian-dataview/lib/index.js
var require_lib = __commonJS({
  "node_modules/obsidian-dataview/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    require("obsidian");
    var LuxonError = class extends Error {
    };
    var InvalidDateTimeError = class extends LuxonError {
      constructor(reason) {
        super(`Invalid DateTime: ${reason.toMessage()}`);
      }
    };
    var InvalidIntervalError = class extends LuxonError {
      constructor(reason) {
        super(`Invalid Interval: ${reason.toMessage()}`);
      }
    };
    var InvalidDurationError = class extends LuxonError {
      constructor(reason) {
        super(`Invalid Duration: ${reason.toMessage()}`);
      }
    };
    var ConflictingSpecificationError = class extends LuxonError {
    };
    var InvalidUnitError = class extends LuxonError {
      constructor(unit) {
        super(`Invalid unit ${unit}`);
      }
    };
    var InvalidArgumentError = class extends LuxonError {
    };
    var ZoneIsAbstractError = class extends LuxonError {
      constructor() {
        super("Zone is an abstract class");
      }
    };
    var n2 = "numeric";
    var s3 = "short";
    var l3 = "long";
    var DATE_SHORT = {
      year: n2,
      month: n2,
      day: n2
    };
    var DATE_MED = {
      year: n2,
      month: s3,
      day: n2
    };
    var DATE_MED_WITH_WEEKDAY = {
      year: n2,
      month: s3,
      day: n2,
      weekday: s3
    };
    var DATE_FULL = {
      year: n2,
      month: l3,
      day: n2
    };
    var DATE_HUGE = {
      year: n2,
      month: l3,
      day: n2,
      weekday: l3
    };
    var TIME_SIMPLE = {
      hour: n2,
      minute: n2
    };
    var TIME_WITH_SECONDS = {
      hour: n2,
      minute: n2,
      second: n2
    };
    var TIME_WITH_SHORT_OFFSET = {
      hour: n2,
      minute: n2,
      second: n2,
      timeZoneName: s3
    };
    var TIME_WITH_LONG_OFFSET = {
      hour: n2,
      minute: n2,
      second: n2,
      timeZoneName: l3
    };
    var TIME_24_SIMPLE = {
      hour: n2,
      minute: n2,
      hourCycle: "h23"
    };
    var TIME_24_WITH_SECONDS = {
      hour: n2,
      minute: n2,
      second: n2,
      hourCycle: "h23"
    };
    var TIME_24_WITH_SHORT_OFFSET = {
      hour: n2,
      minute: n2,
      second: n2,
      hourCycle: "h23",
      timeZoneName: s3
    };
    var TIME_24_WITH_LONG_OFFSET = {
      hour: n2,
      minute: n2,
      second: n2,
      hourCycle: "h23",
      timeZoneName: l3
    };
    var DATETIME_SHORT = {
      year: n2,
      month: n2,
      day: n2,
      hour: n2,
      minute: n2
    };
    var DATETIME_SHORT_WITH_SECONDS = {
      year: n2,
      month: n2,
      day: n2,
      hour: n2,
      minute: n2,
      second: n2
    };
    var DATETIME_MED = {
      year: n2,
      month: s3,
      day: n2,
      hour: n2,
      minute: n2
    };
    var DATETIME_MED_WITH_SECONDS = {
      year: n2,
      month: s3,
      day: n2,
      hour: n2,
      minute: n2,
      second: n2
    };
    var DATETIME_MED_WITH_WEEKDAY = {
      year: n2,
      month: s3,
      day: n2,
      weekday: s3,
      hour: n2,
      minute: n2
    };
    var DATETIME_FULL = {
      year: n2,
      month: l3,
      day: n2,
      hour: n2,
      minute: n2,
      timeZoneName: s3
    };
    var DATETIME_FULL_WITH_SECONDS = {
      year: n2,
      month: l3,
      day: n2,
      hour: n2,
      minute: n2,
      second: n2,
      timeZoneName: s3
    };
    var DATETIME_HUGE = {
      year: n2,
      month: l3,
      day: n2,
      weekday: l3,
      hour: n2,
      minute: n2,
      timeZoneName: l3
    };
    var DATETIME_HUGE_WITH_SECONDS = {
      year: n2,
      month: l3,
      day: n2,
      weekday: l3,
      hour: n2,
      minute: n2,
      second: n2,
      timeZoneName: l3
    };
    var Zone = class {
      /**
       * The type of zone
       * @abstract
       * @type {string}
       */
      get type() {
        throw new ZoneIsAbstractError();
      }
      /**
       * The name of this zone.
       * @abstract
       * @type {string}
       */
      get name() {
        throw new ZoneIsAbstractError();
      }
      get ianaName() {
        return this.name;
      }
      /**
       * Returns whether the offset is known to be fixed for the whole year.
       * @abstract
       * @type {boolean}
       */
      get isUniversal() {
        throw new ZoneIsAbstractError();
      }
      /**
       * Returns the offset's common name (such as EST) at the specified timestamp
       * @abstract
       * @param {number} ts - Epoch milliseconds for which to get the name
       * @param {Object} opts - Options to affect the format
       * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
       * @param {string} opts.locale - What locale to return the offset name in.
       * @return {string}
       */
      offsetName(ts, opts) {
        throw new ZoneIsAbstractError();
      }
      /**
       * Returns the offset's value as a string
       * @abstract
       * @param {number} ts - Epoch milliseconds for which to get the offset
       * @param {string} format - What style of offset to return.
       *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
       * @return {string}
       */
      formatOffset(ts, format) {
        throw new ZoneIsAbstractError();
      }
      /**
       * Return the offset in minutes for this zone at the specified timestamp.
       * @abstract
       * @param {number} ts - Epoch milliseconds for which to compute the offset
       * @return {number}
       */
      offset(ts) {
        throw new ZoneIsAbstractError();
      }
      /**
       * Return whether this Zone is equal to another zone
       * @abstract
       * @param {Zone} otherZone - the zone to compare
       * @return {boolean}
       */
      equals(otherZone) {
        throw new ZoneIsAbstractError();
      }
      /**
       * Return whether this Zone is valid.
       * @abstract
       * @type {boolean}
       */
      get isValid() {
        throw new ZoneIsAbstractError();
      }
    };
    var singleton$1 = null;
    var SystemZone = class extends Zone {
      /**
       * Get a singleton instance of the local zone
       * @return {SystemZone}
       */
      static get instance() {
        if (singleton$1 === null) {
          singleton$1 = new SystemZone();
        }
        return singleton$1;
      }
      /** @override **/
      get type() {
        return "system";
      }
      /** @override **/
      get name() {
        return new Intl.DateTimeFormat().resolvedOptions().timeZone;
      }
      /** @override **/
      get isUniversal() {
        return false;
      }
      /** @override **/
      offsetName(ts, { format, locale }) {
        return parseZoneInfo(ts, format, locale);
      }
      /** @override **/
      formatOffset(ts, format) {
        return formatOffset(this.offset(ts), format);
      }
      /** @override **/
      offset(ts) {
        return -new Date(ts).getTimezoneOffset();
      }
      /** @override **/
      equals(otherZone) {
        return otherZone.type === "system";
      }
      /** @override **/
      get isValid() {
        return true;
      }
    };
    var dtfCache = {};
    function makeDTF(zone) {
      if (!dtfCache[zone]) {
        dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
          hour12: false,
          timeZone: zone,
          year: "numeric",
          month: "2-digit",
          day: "2-digit",
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit",
          era: "short"
        });
      }
      return dtfCache[zone];
    }
    var typeToPos = {
      year: 0,
      month: 1,
      day: 2,
      era: 3,
      hour: 4,
      minute: 5,
      second: 6
    };
    function hackyOffset(dtf, date) {
      const formatted = dtf.format(date).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted), [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
      return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
    }
    function partsOffset(dtf, date) {
      const formatted = dtf.formatToParts(date);
      const filled = [];
      for (let i3 = 0; i3 < formatted.length; i3++) {
        const { type, value } = formatted[i3];
        const pos = typeToPos[type];
        if (type === "era") {
          filled[pos] = value;
        } else if (!isUndefined(pos)) {
          filled[pos] = parseInt(value, 10);
        }
      }
      return filled;
    }
    var ianaZoneCache = {};
    var IANAZone = class extends Zone {
      /**
       * @param {string} name - Zone name
       * @return {IANAZone}
       */
      static create(name) {
        if (!ianaZoneCache[name]) {
          ianaZoneCache[name] = new IANAZone(name);
        }
        return ianaZoneCache[name];
      }
      /**
       * Reset local caches. Should only be necessary in testing scenarios.
       * @return {void}
       */
      static resetCache() {
        ianaZoneCache = {};
        dtfCache = {};
      }
      /**
       * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
       * @param {string} s - The string to check validity on
       * @example IANAZone.isValidSpecifier("America/New_York") //=> true
       * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
       * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.
       * @return {boolean}
       */
      static isValidSpecifier(s4) {
        return this.isValidZone(s4);
      }
      /**
       * Returns whether the provided string identifies a real zone
       * @param {string} zone - The string to check
       * @example IANAZone.isValidZone("America/New_York") //=> true
       * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
       * @example IANAZone.isValidZone("Sport~~blorp") //=> false
       * @return {boolean}
       */
      static isValidZone(zone) {
        if (!zone) {
          return false;
        }
        try {
          new Intl.DateTimeFormat("en-US", { timeZone: zone }).format();
          return true;
        } catch (e3) {
          return false;
        }
      }
      constructor(name) {
        super();
        this.zoneName = name;
        this.valid = IANAZone.isValidZone(name);
      }
      /** @override **/
      get type() {
        return "iana";
      }
      /** @override **/
      get name() {
        return this.zoneName;
      }
      /** @override **/
      get isUniversal() {
        return false;
      }
      /** @override **/
      offsetName(ts, { format, locale }) {
        return parseZoneInfo(ts, format, locale, this.name);
      }
      /** @override **/
      formatOffset(ts, format) {
        return formatOffset(this.offset(ts), format);
      }
      /** @override **/
      offset(ts) {
        const date = new Date(ts);
        if (isNaN(date))
          return NaN;
        const dtf = makeDTF(this.name);
        let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date);
        if (adOrBc === "BC") {
          year = -Math.abs(year) + 1;
        }
        const adjustedHour = hour === 24 ? 0 : hour;
        const asUTC = objToLocalTS({
          year,
          month,
          day,
          hour: adjustedHour,
          minute,
          second,
          millisecond: 0
        });
        let asTS = +date;
        const over = asTS % 1e3;
        asTS -= over >= 0 ? over : 1e3 + over;
        return (asUTC - asTS) / (60 * 1e3);
      }
      /** @override **/
      equals(otherZone) {
        return otherZone.type === "iana" && otherZone.name === this.name;
      }
      /** @override **/
      get isValid() {
        return this.valid;
      }
    };
    var intlLFCache = {};
    function getCachedLF(locString, opts = {}) {
      const key = JSON.stringify([locString, opts]);
      let dtf = intlLFCache[key];
      if (!dtf) {
        dtf = new Intl.ListFormat(locString, opts);
        intlLFCache[key] = dtf;
      }
      return dtf;
    }
    var intlDTCache = {};
    function getCachedDTF(locString, opts = {}) {
      const key = JSON.stringify([locString, opts]);
      let dtf = intlDTCache[key];
      if (!dtf) {
        dtf = new Intl.DateTimeFormat(locString, opts);
        intlDTCache[key] = dtf;
      }
      return dtf;
    }
    var intlNumCache = {};
    function getCachedINF(locString, opts = {}) {
      const key = JSON.stringify([locString, opts]);
      let inf = intlNumCache[key];
      if (!inf) {
        inf = new Intl.NumberFormat(locString, opts);
        intlNumCache[key] = inf;
      }
      return inf;
    }
    var intlRelCache = {};
    function getCachedRTF(locString, opts = {}) {
      const { base, ...cacheKeyOpts } = opts;
      const key = JSON.stringify([locString, cacheKeyOpts]);
      let inf = intlRelCache[key];
      if (!inf) {
        inf = new Intl.RelativeTimeFormat(locString, opts);
        intlRelCache[key] = inf;
      }
      return inf;
    }
    var sysLocaleCache = null;
    function systemLocale() {
      if (sysLocaleCache) {
        return sysLocaleCache;
      } else {
        sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
        return sysLocaleCache;
      }
    }
    function parseLocaleString(localeStr) {
      const xIndex = localeStr.indexOf("-x-");
      if (xIndex !== -1) {
        localeStr = localeStr.substring(0, xIndex);
      }
      const uIndex = localeStr.indexOf("-u-");
      if (uIndex === -1) {
        return [localeStr];
      } else {
        let options;
        let selectedStr;
        try {
          options = getCachedDTF(localeStr).resolvedOptions();
          selectedStr = localeStr;
        } catch (e3) {
          const smaller = localeStr.substring(0, uIndex);
          options = getCachedDTF(smaller).resolvedOptions();
          selectedStr = smaller;
        }
        const { numberingSystem, calendar } = options;
        return [selectedStr, numberingSystem, calendar];
      }
    }
    function intlConfigString(localeStr, numberingSystem, outputCalendar) {
      if (outputCalendar || numberingSystem) {
        if (!localeStr.includes("-u-")) {
          localeStr += "-u";
        }
        if (outputCalendar) {
          localeStr += `-ca-${outputCalendar}`;
        }
        if (numberingSystem) {
          localeStr += `-nu-${numberingSystem}`;
        }
        return localeStr;
      } else {
        return localeStr;
      }
    }
    function mapMonths(f3) {
      const ms = [];
      for (let i3 = 1; i3 <= 12; i3++) {
        const dt = DateTime2.utc(2009, i3, 1);
        ms.push(f3(dt));
      }
      return ms;
    }
    function mapWeekdays(f3) {
      const ms = [];
      for (let i3 = 1; i3 <= 7; i3++) {
        const dt = DateTime2.utc(2016, 11, 13 + i3);
        ms.push(f3(dt));
      }
      return ms;
    }
    function listStuff(loc, length, englishFn, intlFn) {
      const mode = loc.listingMode();
      if (mode === "error") {
        return null;
      } else if (mode === "en") {
        return englishFn(length);
      } else {
        return intlFn(length);
      }
    }
    function supportsFastNumbers(loc) {
      if (loc.numberingSystem && loc.numberingSystem !== "latn") {
        return false;
      } else {
        return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
      }
    }
    var PolyNumberFormatter = class {
      constructor(intl, forceSimple, opts) {
        this.padTo = opts.padTo || 0;
        this.floor = opts.floor || false;
        const { padTo, floor, ...otherOpts } = opts;
        if (!forceSimple || Object.keys(otherOpts).length > 0) {
          const intlOpts = { useGrouping: false, ...opts };
          if (opts.padTo > 0)
            intlOpts.minimumIntegerDigits = opts.padTo;
          this.inf = getCachedINF(intl, intlOpts);
        }
      }
      format(i3) {
        if (this.inf) {
          const fixed = this.floor ? Math.floor(i3) : i3;
          return this.inf.format(fixed);
        } else {
          const fixed = this.floor ? Math.floor(i3) : roundTo(i3, 3);
          return padStart3(fixed, this.padTo);
        }
      }
    };
    var PolyDateFormatter = class {
      constructor(dt, intl, opts) {
        this.opts = opts;
        this.originalZone = void 0;
        let z3 = void 0;
        if (this.opts.timeZone) {
          this.dt = dt;
        } else if (dt.zone.type === "fixed") {
          const gmtOffset = -1 * (dt.offset / 60);
          const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
          if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
            z3 = offsetZ;
            this.dt = dt;
          } else {
            z3 = "UTC";
            this.dt = dt.offset === 0 ? dt : dt.setZone("UTC").plus({ minutes: dt.offset });
            this.originalZone = dt.zone;
          }
        } else if (dt.zone.type === "system") {
          this.dt = dt;
        } else if (dt.zone.type === "iana") {
          this.dt = dt;
          z3 = dt.zone.name;
        } else {
          z3 = "UTC";
          this.dt = dt.setZone("UTC").plus({ minutes: dt.offset });
          this.originalZone = dt.zone;
        }
        const intlOpts = { ...this.opts };
        intlOpts.timeZone = intlOpts.timeZone || z3;
        this.dtf = getCachedDTF(intl, intlOpts);
      }
      format() {
        if (this.originalZone) {
          return this.formatToParts().map(({ value }) => value).join("");
        }
        return this.dtf.format(this.dt.toJSDate());
      }
      formatToParts() {
        const parts = this.dtf.formatToParts(this.dt.toJSDate());
        if (this.originalZone) {
          return parts.map((part) => {
            if (part.type === "timeZoneName") {
              const offsetName = this.originalZone.offsetName(this.dt.ts, {
                locale: this.dt.locale,
                format: this.opts.timeZoneName
              });
              return {
                ...part,
                value: offsetName
              };
            } else {
              return part;
            }
          });
        }
        return parts;
      }
      resolvedOptions() {
        return this.dtf.resolvedOptions();
      }
    };
    var PolyRelFormatter = class {
      constructor(intl, isEnglish, opts) {
        this.opts = { style: "long", ...opts };
        if (!isEnglish && hasRelative()) {
          this.rtf = getCachedRTF(intl, opts);
        }
      }
      format(count, unit) {
        if (this.rtf) {
          return this.rtf.format(count, unit);
        } else {
          return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
        }
      }
      formatToParts(count, unit) {
        if (this.rtf) {
          return this.rtf.formatToParts(count, unit);
        } else {
          return [];
        }
      }
    };
    var Locale = class {
      static fromOpts(opts) {
        return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);
      }
      static create(locale, numberingSystem, outputCalendar, defaultToEN = false) {
        const specifiedLocale = locale || Settings.defaultLocale;
        const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
        const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
        const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
        return new Locale(localeR, numberingSystemR, outputCalendarR, specifiedLocale);
      }
      static resetCache() {
        sysLocaleCache = null;
        intlDTCache = {};
        intlNumCache = {};
        intlRelCache = {};
      }
      static fromObject({ locale, numberingSystem, outputCalendar } = {}) {
        return Locale.create(locale, numberingSystem, outputCalendar);
      }
      constructor(locale, numbering, outputCalendar, specifiedLocale) {
        const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);
        this.locale = parsedLocale;
        this.numberingSystem = numbering || parsedNumberingSystem || null;
        this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
        this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
        this.weekdaysCache = { format: {}, standalone: {} };
        this.monthsCache = { format: {}, standalone: {} };
        this.meridiemCache = null;
        this.eraCache = {};
        this.specifiedLocale = specifiedLocale;
        this.fastNumbersCached = null;
      }
      get fastNumbers() {
        if (this.fastNumbersCached == null) {
          this.fastNumbersCached = supportsFastNumbers(this);
        }
        return this.fastNumbersCached;
      }
      listingMode() {
        const isActuallyEn = this.isEnglish();
        const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
        return isActuallyEn && hasNoWeirdness ? "en" : "intl";
      }
      clone(alts) {
        if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
          return this;
        } else {
          return Locale.create(
            alts.locale || this.specifiedLocale,
            alts.numberingSystem || this.numberingSystem,
            alts.outputCalendar || this.outputCalendar,
            alts.defaultToEN || false
          );
        }
      }
      redefaultToEN(alts = {}) {
        return this.clone({ ...alts, defaultToEN: true });
      }
      redefaultToSystem(alts = {}) {
        return this.clone({ ...alts, defaultToEN: false });
      }
      months(length, format = false) {
        return listStuff(this, length, months, () => {
          const intl = format ? { month: length, day: "numeric" } : { month: length }, formatStr = format ? "format" : "standalone";
          if (!this.monthsCache[formatStr][length]) {
            this.monthsCache[formatStr][length] = mapMonths((dt) => this.extract(dt, intl, "month"));
          }
          return this.monthsCache[formatStr][length];
        });
      }
      weekdays(length, format = false) {
        return listStuff(this, length, weekdays, () => {
          const intl = format ? { weekday: length, year: "numeric", month: "long", day: "numeric" } : { weekday: length }, formatStr = format ? "format" : "standalone";
          if (!this.weekdaysCache[formatStr][length]) {
            this.weekdaysCache[formatStr][length] = mapWeekdays(
              (dt) => this.extract(dt, intl, "weekday")
            );
          }
          return this.weekdaysCache[formatStr][length];
        });
      }
      meridiems() {
        return listStuff(
          this,
          void 0,
          () => meridiems,
          () => {
            if (!this.meridiemCache) {
              const intl = { hour: "numeric", hourCycle: "h12" };
              this.meridiemCache = [DateTime2.utc(2016, 11, 13, 9), DateTime2.utc(2016, 11, 13, 19)].map(
                (dt) => this.extract(dt, intl, "dayperiod")
              );
            }
            return this.meridiemCache;
          }
        );
      }
      eras(length) {
        return listStuff(this, length, eras, () => {
          const intl = { era: length };
          if (!this.eraCache[length]) {
            this.eraCache[length] = [DateTime2.utc(-40, 1, 1), DateTime2.utc(2017, 1, 1)].map(
              (dt) => this.extract(dt, intl, "era")
            );
          }
          return this.eraCache[length];
        });
      }
      extract(dt, intlOpts, field) {
        const df = this.dtFormatter(dt, intlOpts), results = df.formatToParts(), matching = results.find((m3) => m3.type.toLowerCase() === field);
        return matching ? matching.value : null;
      }
      numberFormatter(opts = {}) {
        return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
      }
      dtFormatter(dt, intlOpts = {}) {
        return new PolyDateFormatter(dt, this.intl, intlOpts);
      }
      relFormatter(opts = {}) {
        return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
      }
      listFormatter(opts = {}) {
        return getCachedLF(this.intl, opts);
      }
      isEnglish() {
        return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
      }
      equals(other) {
        return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
      }
    };
    var singleton = null;
    var FixedOffsetZone = class extends Zone {
      /**
       * Get a singleton instance of UTC
       * @return {FixedOffsetZone}
       */
      static get utcInstance() {
        if (singleton === null) {
          singleton = new FixedOffsetZone(0);
        }
        return singleton;
      }
      /**
       * Get an instance with a specified offset
       * @param {number} offset - The offset in minutes
       * @return {FixedOffsetZone}
       */
      static instance(offset2) {
        return offset2 === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset2);
      }
      /**
       * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
       * @param {string} s - The offset string to parse
       * @example FixedOffsetZone.parseSpecifier("UTC+6")
       * @example FixedOffsetZone.parseSpecifier("UTC+06")
       * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
       * @return {FixedOffsetZone}
       */
      static parseSpecifier(s4) {
        if (s4) {
          const r3 = s4.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
          if (r3) {
            return new FixedOffsetZone(signedOffset(r3[1], r3[2]));
          }
        }
        return null;
      }
      constructor(offset2) {
        super();
        this.fixed = offset2;
      }
      /** @override **/
      get type() {
        return "fixed";
      }
      /** @override **/
      get name() {
        return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`;
      }
      get ianaName() {
        if (this.fixed === 0) {
          return "Etc/UTC";
        } else {
          return `Etc/GMT${formatOffset(-this.fixed, "narrow")}`;
        }
      }
      /** @override **/
      offsetName() {
        return this.name;
      }
      /** @override **/
      formatOffset(ts, format) {
        return formatOffset(this.fixed, format);
      }
      /** @override **/
      get isUniversal() {
        return true;
      }
      /** @override **/
      offset() {
        return this.fixed;
      }
      /** @override **/
      equals(otherZone) {
        return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
      }
      /** @override **/
      get isValid() {
        return true;
      }
    };
    var InvalidZone = class extends Zone {
      constructor(zoneName) {
        super();
        this.zoneName = zoneName;
      }
      /** @override **/
      get type() {
        return "invalid";
      }
      /** @override **/
      get name() {
        return this.zoneName;
      }
      /** @override **/
      get isUniversal() {
        return false;
      }
      /** @override **/
      offsetName() {
        return null;
      }
      /** @override **/
      formatOffset() {
        return "";
      }
      /** @override **/
      offset() {
        return NaN;
      }
      /** @override **/
      equals() {
        return false;
      }
      /** @override **/
      get isValid() {
        return false;
      }
    };
    function normalizeZone(input, defaultZone2) {
      if (isUndefined(input) || input === null) {
        return defaultZone2;
      } else if (input instanceof Zone) {
        return input;
      } else if (isString(input)) {
        const lowered = input.toLowerCase();
        if (lowered === "default")
          return defaultZone2;
        else if (lowered === "local" || lowered === "system")
          return SystemZone.instance;
        else if (lowered === "utc" || lowered === "gmt")
          return FixedOffsetZone.utcInstance;
        else
          return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input);
      } else if (isNumber2(input)) {
        return FixedOffsetZone.instance(input);
      } else if (typeof input === "object" && "offset" in input && typeof input.offset === "function") {
        return input;
      } else {
        return new InvalidZone(input);
      }
    }
    var now = () => Date.now();
    var defaultZone = "system";
    var defaultLocale = null;
    var defaultNumberingSystem = null;
    var defaultOutputCalendar = null;
    var twoDigitCutoffYear = 60;
    var throwOnInvalid;
    var Settings = class {
      /**
       * Get the callback for returning the current timestamp.
       * @type {function}
       */
      static get now() {
        return now;
      }
      /**
       * Set the callback for returning the current timestamp.
       * The function should return a number, which will be interpreted as an Epoch millisecond count
       * @type {function}
       * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
       * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
       */
      static set now(n3) {
        now = n3;
      }
      /**
       * Set the default time zone to create DateTimes in. Does not affect existing instances.
       * Use the value "system" to reset this value to the system's time zone.
       * @type {string}
       */
      static set defaultZone(zone) {
        defaultZone = zone;
      }
      /**
       * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
       * The default value is the system's time zone (the one set on the machine that runs this code).
       * @type {Zone}
       */
      static get defaultZone() {
        return normalizeZone(defaultZone, SystemZone.instance);
      }
      /**
       * Get the default locale to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static get defaultLocale() {
        return defaultLocale;
      }
      /**
       * Set the default locale to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static set defaultLocale(locale) {
        defaultLocale = locale;
      }
      /**
       * Get the default numbering system to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static get defaultNumberingSystem() {
        return defaultNumberingSystem;
      }
      /**
       * Set the default numbering system to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static set defaultNumberingSystem(numberingSystem) {
        defaultNumberingSystem = numberingSystem;
      }
      /**
       * Get the default output calendar to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static get defaultOutputCalendar() {
        return defaultOutputCalendar;
      }
      /**
       * Set the default output calendar to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static set defaultOutputCalendar(outputCalendar) {
        defaultOutputCalendar = outputCalendar;
      }
      /**
       * Get the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
       * @type {number}
       */
      static get twoDigitCutoffYear() {
        return twoDigitCutoffYear;
      }
      /**
       * Set the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
       * @type {number}
       * @example Settings.twoDigitCutoffYear = 0 // cut-off year is 0, so all 'yy' are interpreted as current century
       * @example Settings.twoDigitCutoffYear = 50 // '49' -> 1949; '50' -> 2050
       * @example Settings.twoDigitCutoffYear = 1950 // interpreted as 50
       * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpreted as 50
       */
      static set twoDigitCutoffYear(cutoffYear) {
        twoDigitCutoffYear = cutoffYear % 100;
      }
      /**
       * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
       * @type {boolean}
       */
      static get throwOnInvalid() {
        return throwOnInvalid;
      }
      /**
       * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
       * @type {boolean}
       */
      static set throwOnInvalid(t3) {
        throwOnInvalid = t3;
      }
      /**
       * Reset Luxon's global caches. Should only be necessary in testing scenarios.
       * @return {void}
       */
      static resetCaches() {
        Locale.resetCache();
        IANAZone.resetCache();
      }
    };
    function isUndefined(o2) {
      return typeof o2 === "undefined";
    }
    function isNumber2(o2) {
      return typeof o2 === "number";
    }
    function isInteger(o2) {
      return typeof o2 === "number" && o2 % 1 === 0;
    }
    function isString(o2) {
      return typeof o2 === "string";
    }
    function isDate2(o2) {
      return Object.prototype.toString.call(o2) === "[object Date]";
    }
    function hasRelative() {
      try {
        return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
      } catch (e3) {
        return false;
      }
    }
    function maybeArray(thing) {
      return Array.isArray(thing) ? thing : [thing];
    }
    function bestBy(arr, by, compare) {
      if (arr.length === 0) {
        return void 0;
      }
      return arr.reduce((best, next) => {
        const pair = [by(next), next];
        if (!best) {
          return pair;
        } else if (compare(best[0], pair[0]) === best[0]) {
          return best;
        } else {
          return pair;
        }
      }, null)[1];
    }
    function pick(obj, keys) {
      return keys.reduce((a3, k3) => {
        a3[k3] = obj[k3];
        return a3;
      }, {});
    }
    function hasOwnProperty2(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    function integerBetween(thing, bottom, top) {
      return isInteger(thing) && thing >= bottom && thing <= top;
    }
    function floorMod(x4, n3) {
      return x4 - n3 * Math.floor(x4 / n3);
    }
    function padStart3(input, n3 = 2) {
      const isNeg = input < 0;
      let padded;
      if (isNeg) {
        padded = "-" + ("" + -input).padStart(n3, "0");
      } else {
        padded = ("" + input).padStart(n3, "0");
      }
      return padded;
    }
    function parseInteger(string) {
      if (isUndefined(string) || string === null || string === "") {
        return void 0;
      } else {
        return parseInt(string, 10);
      }
    }
    function parseFloating(string) {
      if (isUndefined(string) || string === null || string === "") {
        return void 0;
      } else {
        return parseFloat(string);
      }
    }
    function parseMillis(fraction) {
      if (isUndefined(fraction) || fraction === null || fraction === "") {
        return void 0;
      } else {
        const f3 = parseFloat("0." + fraction) * 1e3;
        return Math.floor(f3);
      }
    }
    function roundTo(number, digits, towardZero = false) {
      const factor = 10 ** digits, rounder = towardZero ? Math.trunc : Math.round;
      return rounder(number * factor) / factor;
    }
    function isLeapYear2(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    function daysInYear(year) {
      return isLeapYear2(year) ? 366 : 365;
    }
    function daysInMonth(year, month) {
      const modMonth = floorMod(month - 1, 12) + 1, modYear = year + (month - modMonth) / 12;
      if (modMonth === 2) {
        return isLeapYear2(modYear) ? 29 : 28;
      } else {
        return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
      }
    }
    function objToLocalTS(obj) {
      let d2 = Date.UTC(
        obj.year,
        obj.month - 1,
        obj.day,
        obj.hour,
        obj.minute,
        obj.second,
        obj.millisecond
      );
      if (obj.year < 100 && obj.year >= 0) {
        d2 = new Date(d2);
        d2.setUTCFullYear(obj.year, obj.month - 1, obj.day);
      }
      return +d2;
    }
    function weeksInWeekYear(weekYear) {
      const p1 = (weekYear + Math.floor(weekYear / 4) - Math.floor(weekYear / 100) + Math.floor(weekYear / 400)) % 7, last = weekYear - 1, p22 = (last + Math.floor(last / 4) - Math.floor(last / 100) + Math.floor(last / 400)) % 7;
      return p1 === 4 || p22 === 3 ? 53 : 52;
    }
    function untruncateYear(year) {
      if (year > 99) {
        return year;
      } else
        return year > Settings.twoDigitCutoffYear ? 1900 + year : 2e3 + year;
    }
    function parseZoneInfo(ts, offsetFormat, locale, timeZone = null) {
      const date = new Date(ts), intlOpts = {
        hourCycle: "h23",
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit"
      };
      if (timeZone) {
        intlOpts.timeZone = timeZone;
      }
      const modified = { timeZoneName: offsetFormat, ...intlOpts };
      const parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date).find((m3) => m3.type.toLowerCase() === "timezonename");
      return parsed ? parsed.value : null;
    }
    function signedOffset(offHourStr, offMinuteStr) {
      let offHour = parseInt(offHourStr, 10);
      if (Number.isNaN(offHour)) {
        offHour = 0;
      }
      const offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
      return offHour * 60 + offMinSigned;
    }
    function asNumber(value) {
      const numericValue = Number(value);
      if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue))
        throw new InvalidArgumentError(`Invalid unit value ${value}`);
      return numericValue;
    }
    function normalizeObject(obj, normalizer) {
      const normalized = {};
      for (const u3 in obj) {
        if (hasOwnProperty2(obj, u3)) {
          const v3 = obj[u3];
          if (v3 === void 0 || v3 === null)
            continue;
          normalized[normalizer(u3)] = asNumber(v3);
        }
      }
      return normalized;
    }
    function formatOffset(offset2, format) {
      const hours = Math.trunc(Math.abs(offset2 / 60)), minutes = Math.trunc(Math.abs(offset2 % 60)), sign = offset2 >= 0 ? "+" : "-";
      switch (format) {
        case "short":
          return `${sign}${padStart3(hours, 2)}:${padStart3(minutes, 2)}`;
        case "narrow":
          return `${sign}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
        case "techie":
          return `${sign}${padStart3(hours, 2)}${padStart3(minutes, 2)}`;
        default:
          throw new RangeError(`Value format ${format} is out of range for property format`);
      }
    }
    function timeObject(obj) {
      return pick(obj, ["hour", "minute", "second", "millisecond"]);
    }
    var monthsLong = [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ];
    var monthsShort = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    var monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
    function months(length) {
      switch (length) {
        case "narrow":
          return [...monthsNarrow];
        case "short":
          return [...monthsShort];
        case "long":
          return [...monthsLong];
        case "numeric":
          return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
        case "2-digit":
          return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
        default:
          return null;
      }
    }
    var weekdaysLong = [
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday",
      "Sunday"
    ];
    var weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
    var weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
    function weekdays(length) {
      switch (length) {
        case "narrow":
          return [...weekdaysNarrow];
        case "short":
          return [...weekdaysShort];
        case "long":
          return [...weekdaysLong];
        case "numeric":
          return ["1", "2", "3", "4", "5", "6", "7"];
        default:
          return null;
      }
    }
    var meridiems = ["AM", "PM"];
    var erasLong = ["Before Christ", "Anno Domini"];
    var erasShort = ["BC", "AD"];
    var erasNarrow = ["B", "A"];
    function eras(length) {
      switch (length) {
        case "narrow":
          return [...erasNarrow];
        case "short":
          return [...erasShort];
        case "long":
          return [...erasLong];
        default:
          return null;
      }
    }
    function meridiemForDateTime(dt) {
      return meridiems[dt.hour < 12 ? 0 : 1];
    }
    function weekdayForDateTime(dt, length) {
      return weekdays(length)[dt.weekday - 1];
    }
    function monthForDateTime(dt, length) {
      return months(length)[dt.month - 1];
    }
    function eraForDateTime(dt, length) {
      return eras(length)[dt.year < 0 ? 0 : 1];
    }
    function formatRelativeTime(unit, count, numeric = "always", narrow = false) {
      const units = {
        years: ["year", "yr."],
        quarters: ["quarter", "qtr."],
        months: ["month", "mo."],
        weeks: ["week", "wk."],
        days: ["day", "day", "days"],
        hours: ["hour", "hr."],
        minutes: ["minute", "min."],
        seconds: ["second", "sec."]
      };
      const lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;
      if (numeric === "auto" && lastable) {
        const isDay = unit === "days";
        switch (count) {
          case 1:
            return isDay ? "tomorrow" : `next ${units[unit][0]}`;
          case -1:
            return isDay ? "yesterday" : `last ${units[unit][0]}`;
          case 0:
            return isDay ? "today" : `this ${units[unit][0]}`;
        }
      }
      const isInPast = Object.is(count, -0) || count < 0, fmtValue = Math.abs(count), singular = fmtValue === 1, lilUnits = units[unit], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
      return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
    }
    function stringifyTokens(splits, tokenToString) {
      let s4 = "";
      for (const token of splits) {
        if (token.literal) {
          s4 += token.val;
        } else {
          s4 += tokenToString(token.val);
        }
      }
      return s4;
    }
    var macroTokenToFormatOpts = {
      D: DATE_SHORT,
      DD: DATE_MED,
      DDD: DATE_FULL,
      DDDD: DATE_HUGE,
      t: TIME_SIMPLE,
      tt: TIME_WITH_SECONDS,
      ttt: TIME_WITH_SHORT_OFFSET,
      tttt: TIME_WITH_LONG_OFFSET,
      T: TIME_24_SIMPLE,
      TT: TIME_24_WITH_SECONDS,
      TTT: TIME_24_WITH_SHORT_OFFSET,
      TTTT: TIME_24_WITH_LONG_OFFSET,
      f: DATETIME_SHORT,
      ff: DATETIME_MED,
      fff: DATETIME_FULL,
      ffff: DATETIME_HUGE,
      F: DATETIME_SHORT_WITH_SECONDS,
      FF: DATETIME_MED_WITH_SECONDS,
      FFF: DATETIME_FULL_WITH_SECONDS,
      FFFF: DATETIME_HUGE_WITH_SECONDS
    };
    var Formatter = class {
      static create(locale, opts = {}) {
        return new Formatter(locale, opts);
      }
      static parseFormat(fmt) {
        let current = null, currentFull = "", bracketed = false;
        const splits = [];
        for (let i3 = 0; i3 < fmt.length; i3++) {
          const c3 = fmt.charAt(i3);
          if (c3 === "'") {
            if (currentFull.length > 0) {
              splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
            }
            current = null;
            currentFull = "";
            bracketed = !bracketed;
          } else if (bracketed) {
            currentFull += c3;
          } else if (c3 === current) {
            currentFull += c3;
          } else {
            if (currentFull.length > 0) {
              splits.push({ literal: /^\s+$/.test(currentFull), val: currentFull });
            }
            currentFull = c3;
            current = c3;
          }
        }
        if (currentFull.length > 0) {
          splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
        }
        return splits;
      }
      static macroTokenToFormatOpts(token) {
        return macroTokenToFormatOpts[token];
      }
      constructor(locale, formatOpts) {
        this.opts = formatOpts;
        this.loc = locale;
        this.systemLoc = null;
      }
      formatWithSystemDefault(dt, opts) {
        if (this.systemLoc === null) {
          this.systemLoc = this.loc.redefaultToSystem();
        }
        const df = this.systemLoc.dtFormatter(dt, { ...this.opts, ...opts });
        return df.format();
      }
      dtFormatter(dt, opts = {}) {
        return this.loc.dtFormatter(dt, { ...this.opts, ...opts });
      }
      formatDateTime(dt, opts) {
        return this.dtFormatter(dt, opts).format();
      }
      formatDateTimeParts(dt, opts) {
        return this.dtFormatter(dt, opts).formatToParts();
      }
      formatInterval(interval, opts) {
        const df = this.dtFormatter(interval.start, opts);
        return df.dtf.formatRange(interval.start.toJSDate(), interval.end.toJSDate());
      }
      resolvedOptions(dt, opts) {
        return this.dtFormatter(dt, opts).resolvedOptions();
      }
      num(n3, p3 = 0) {
        if (this.opts.forceSimple) {
          return padStart3(n3, p3);
        }
        const opts = { ...this.opts };
        if (p3 > 0) {
          opts.padTo = p3;
        }
        return this.loc.numberFormatter(opts).format(n3);
      }
      formatDateTimeFromString(dt, fmt) {
        const knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", string = (opts, extract) => this.loc.extract(dt, opts, extract), formatOffset2 = (opts) => {
          if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
            return "Z";
          }
          return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
        }, meridiem = () => knownEnglish ? meridiemForDateTime(dt) : string({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), month = (length, standalone) => knownEnglish ? monthForDateTime(dt, length) : string(standalone ? { month: length } : { month: length, day: "numeric" }, "month"), weekday = (length, standalone) => knownEnglish ? weekdayForDateTime(dt, length) : string(
          standalone ? { weekday: length } : { weekday: length, month: "long", day: "numeric" },
          "weekday"
        ), maybeMacro = (token) => {
          const formatOpts = Formatter.macroTokenToFormatOpts(token);
          if (formatOpts) {
            return this.formatWithSystemDefault(dt, formatOpts);
          } else {
            return token;
          }
        }, era = (length) => knownEnglish ? eraForDateTime(dt, length) : string({ era: length }, "era"), tokenToString = (token) => {
          switch (token) {
            case "S":
              return this.num(dt.millisecond);
            case "u":
            case "SSS":
              return this.num(dt.millisecond, 3);
            case "s":
              return this.num(dt.second);
            case "ss":
              return this.num(dt.second, 2);
            case "uu":
              return this.num(Math.floor(dt.millisecond / 10), 2);
            case "uuu":
              return this.num(Math.floor(dt.millisecond / 100));
            case "m":
              return this.num(dt.minute);
            case "mm":
              return this.num(dt.minute, 2);
            case "h":
              return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
            case "hh":
              return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
            case "H":
              return this.num(dt.hour);
            case "HH":
              return this.num(dt.hour, 2);
            case "Z":
              return formatOffset2({ format: "narrow", allowZ: this.opts.allowZ });
            case "ZZ":
              return formatOffset2({ format: "short", allowZ: this.opts.allowZ });
            case "ZZZ":
              return formatOffset2({ format: "techie", allowZ: this.opts.allowZ });
            case "ZZZZ":
              return dt.zone.offsetName(dt.ts, { format: "short", locale: this.loc.locale });
            case "ZZZZZ":
              return dt.zone.offsetName(dt.ts, { format: "long", locale: this.loc.locale });
            case "z":
              return dt.zoneName;
            case "a":
              return meridiem();
            case "d":
              return useDateTimeFormatter ? string({ day: "numeric" }, "day") : this.num(dt.day);
            case "dd":
              return useDateTimeFormatter ? string({ day: "2-digit" }, "day") : this.num(dt.day, 2);
            case "c":
              return this.num(dt.weekday);
            case "ccc":
              return weekday("short", true);
            case "cccc":
              return weekday("long", true);
            case "ccccc":
              return weekday("narrow", true);
            case "E":
              return this.num(dt.weekday);
            case "EEE":
              return weekday("short", false);
            case "EEEE":
              return weekday("long", false);
            case "EEEEE":
              return weekday("narrow", false);
            case "L":
              return useDateTimeFormatter ? string({ month: "numeric", day: "numeric" }, "month") : this.num(dt.month);
            case "LL":
              return useDateTimeFormatter ? string({ month: "2-digit", day: "numeric" }, "month") : this.num(dt.month, 2);
            case "LLL":
              return month("short", true);
            case "LLLL":
              return month("long", true);
            case "LLLLL":
              return month("narrow", true);
            case "M":
              return useDateTimeFormatter ? string({ month: "numeric" }, "month") : this.num(dt.month);
            case "MM":
              return useDateTimeFormatter ? string({ month: "2-digit" }, "month") : this.num(dt.month, 2);
            case "MMM":
              return month("short", false);
            case "MMMM":
              return month("long", false);
            case "MMMMM":
              return month("narrow", false);
            case "y":
              return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year);
            case "yy":
              return useDateTimeFormatter ? string({ year: "2-digit" }, "year") : this.num(dt.year.toString().slice(-2), 2);
            case "yyyy":
              return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 4);
            case "yyyyyy":
              return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 6);
            case "G":
              return era("short");
            case "GG":
              return era("long");
            case "GGGGG":
              return era("narrow");
            case "kk":
              return this.num(dt.weekYear.toString().slice(-2), 2);
            case "kkkk":
              return this.num(dt.weekYear, 4);
            case "W":
              return this.num(dt.weekNumber);
            case "WW":
              return this.num(dt.weekNumber, 2);
            case "o":
              return this.num(dt.ordinal);
            case "ooo":
              return this.num(dt.ordinal, 3);
            case "q":
              return this.num(dt.quarter);
            case "qq":
              return this.num(dt.quarter, 2);
            case "X":
              return this.num(Math.floor(dt.ts / 1e3));
            case "x":
              return this.num(dt.ts);
            default:
              return maybeMacro(token);
          }
        };
        return stringifyTokens(Formatter.parseFormat(fmt), tokenToString);
      }
      formatDurationFromString(dur, fmt) {
        const tokenToField = (token) => {
          switch (token[0]) {
            case "S":
              return "millisecond";
            case "s":
              return "second";
            case "m":
              return "minute";
            case "h":
              return "hour";
            case "d":
              return "day";
            case "w":
              return "week";
            case "M":
              return "month";
            case "y":
              return "year";
            default:
              return null;
          }
        }, tokenToString = (lildur) => (token) => {
          const mapped = tokenToField(token);
          if (mapped) {
            return this.num(lildur.get(mapped), token.length);
          } else {
            return token;
          }
        }, tokens = Formatter.parseFormat(fmt), realTokens = tokens.reduce(
          (found, { literal, val }) => literal ? found : found.concat(val),
          []
        ), collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t3) => t3));
        return stringifyTokens(tokens, tokenToString(collapsed));
      }
    };
    var Invalid = class {
      constructor(reason, explanation) {
        this.reason = reason;
        this.explanation = explanation;
      }
      toMessage() {
        if (this.explanation) {
          return `${this.reason}: ${this.explanation}`;
        } else {
          return this.reason;
        }
      }
    };
    var ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
    function combineRegexes(...regexes) {
      const full = regexes.reduce((f3, r3) => f3 + r3.source, "");
      return RegExp(`^${full}$`);
    }
    function combineExtractors(...extractors) {
      return (m3) => extractors.reduce(
        ([mergedVals, mergedZone, cursor], ex) => {
          const [val, zone, next] = ex(m3, cursor);
          return [{ ...mergedVals, ...val }, zone || mergedZone, next];
        },
        [{}, null, 1]
      ).slice(0, 2);
    }
    function parse3(s4, ...patterns) {
      if (s4 == null) {
        return [null, null];
      }
      for (const [regex, extractor] of patterns) {
        const m3 = regex.exec(s4);
        if (m3) {
          return extractor(m3);
        }
      }
      return [null, null];
    }
    function simpleParse(...keys) {
      return (match2, cursor) => {
        const ret = {};
        let i3;
        for (i3 = 0; i3 < keys.length; i3++) {
          ret[keys[i3]] = parseInteger(match2[cursor + i3]);
        }
        return [ret, null, cursor + i3];
      };
    }
    var offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
    var isoExtendedZone = `(?:${offsetRegex.source}?(?:\\[(${ianaRegex.source})\\])?)?`;
    var isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
    var isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);
    var isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`);
    var isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
    var isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
    var isoOrdinalRegex = /(\d{4})-?(\d{3})/;
    var extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
    var extractISOOrdinalData = simpleParse("year", "ordinal");
    var sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/;
    var sqlTimeRegex = RegExp(
      `${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`
    );
    var sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);
    function int(match2, pos, fallback) {
      const m3 = match2[pos];
      return isUndefined(m3) ? fallback : parseInteger(m3);
    }
    function extractISOYmd(match2, cursor) {
      const item = {
        year: int(match2, cursor),
        month: int(match2, cursor + 1, 1),
        day: int(match2, cursor + 2, 1)
      };
      return [item, null, cursor + 3];
    }
    function extractISOTime(match2, cursor) {
      const item = {
        hours: int(match2, cursor, 0),
        minutes: int(match2, cursor + 1, 0),
        seconds: int(match2, cursor + 2, 0),
        milliseconds: parseMillis(match2[cursor + 3])
      };
      return [item, null, cursor + 4];
    }
    function extractISOOffset(match2, cursor) {
      const local = !match2[cursor] && !match2[cursor + 1], fullOffset = signedOffset(match2[cursor + 1], match2[cursor + 2]), zone = local ? null : FixedOffsetZone.instance(fullOffset);
      return [{}, zone, cursor + 3];
    }
    function extractIANAZone(match2, cursor) {
      const zone = match2[cursor] ? IANAZone.create(match2[cursor]) : null;
      return [{}, zone, cursor + 1];
    }
    var isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);
    var isoDuration = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
    function extractISODuration(match2) {
      const [s4, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] = match2;
      const hasNegativePrefix = s4[0] === "-";
      const negativeSeconds = secondStr && secondStr[0] === "-";
      const maybeNegate = (num, force = false) => num !== void 0 && (force || num && hasNegativePrefix) ? -num : num;
      return [
        {
          years: maybeNegate(parseFloating(yearStr)),
          months: maybeNegate(parseFloating(monthStr)),
          weeks: maybeNegate(parseFloating(weekStr)),
          days: maybeNegate(parseFloating(dayStr)),
          hours: maybeNegate(parseFloating(hourStr)),
          minutes: maybeNegate(parseFloating(minuteStr)),
          seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
          milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
        }
      ];
    }
    var obsOffsets = {
      GMT: 0,
      EDT: -4 * 60,
      EST: -5 * 60,
      CDT: -5 * 60,
      CST: -6 * 60,
      MDT: -6 * 60,
      MST: -7 * 60,
      PDT: -7 * 60,
      PST: -8 * 60
    };
    function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
      const result = {
        year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
        month: monthsShort.indexOf(monthStr) + 1,
        day: parseInteger(dayStr),
        hour: parseInteger(hourStr),
        minute: parseInteger(minuteStr)
      };
      if (secondStr)
        result.second = parseInteger(secondStr);
      if (weekdayStr) {
        result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
      }
      return result;
    }
    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
    function extractRFC2822(match2) {
      const [
        ,
        weekdayStr,
        dayStr,
        monthStr,
        yearStr,
        hourStr,
        minuteStr,
        secondStr,
        obsOffset,
        milOffset,
        offHourStr,
        offMinuteStr
      ] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      let offset2;
      if (obsOffset) {
        offset2 = obsOffsets[obsOffset];
      } else if (milOffset) {
        offset2 = 0;
      } else {
        offset2 = signedOffset(offHourStr, offMinuteStr);
      }
      return [result, new FixedOffsetZone(offset2)];
    }
    function preprocessRFC2822(s4) {
      return s4.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
    }
    var rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/;
    var rfc850 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/;
    var ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
    function extractRFC1123Or850(match2) {
      const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      return [result, FixedOffsetZone.utcInstance];
    }
    function extractASCII(match2) {
      const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      return [result, FixedOffsetZone.utcInstance];
    }
    var isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
    var isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
    var isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
    var isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
    var extractISOYmdTimeAndOffset = combineExtractors(
      extractISOYmd,
      extractISOTime,
      extractISOOffset,
      extractIANAZone
    );
    var extractISOWeekTimeAndOffset = combineExtractors(
      extractISOWeekData,
      extractISOTime,
      extractISOOffset,
      extractIANAZone
    );
    var extractISOOrdinalDateAndTime = combineExtractors(
      extractISOOrdinalData,
      extractISOTime,
      extractISOOffset,
      extractIANAZone
    );
    var extractISOTimeAndOffset = combineExtractors(
      extractISOTime,
      extractISOOffset,
      extractIANAZone
    );
    function parseISODate(s4) {
      return parse3(
        s4,
        [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
        [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset],
        [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime],
        [isoTimeCombinedRegex, extractISOTimeAndOffset]
      );
    }
    function parseRFC2822Date(s4) {
      return parse3(preprocessRFC2822(s4), [rfc2822, extractRFC2822]);
    }
    function parseHTTPDate(s4) {
      return parse3(
        s4,
        [rfc1123, extractRFC1123Or850],
        [rfc850, extractRFC1123Or850],
        [ascii, extractASCII]
      );
    }
    function parseISODuration(s4) {
      return parse3(s4, [isoDuration, extractISODuration]);
    }
    var extractISOTimeOnly = combineExtractors(extractISOTime);
    function parseISOTimeOnly(s4) {
      return parse3(s4, [isoTimeOnly, extractISOTimeOnly]);
    }
    var sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
    var sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
    var extractISOTimeOffsetAndIANAZone = combineExtractors(
      extractISOTime,
      extractISOOffset,
      extractIANAZone
    );
    function parseSQL(s4) {
      return parse3(
        s4,
        [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
        [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]
      );
    }
    var INVALID$2 = "Invalid Duration";
    var lowOrderMatrix = {
      weeks: {
        days: 7,
        hours: 7 * 24,
        minutes: 7 * 24 * 60,
        seconds: 7 * 24 * 60 * 60,
        milliseconds: 7 * 24 * 60 * 60 * 1e3
      },
      days: {
        hours: 24,
        minutes: 24 * 60,
        seconds: 24 * 60 * 60,
        milliseconds: 24 * 60 * 60 * 1e3
      },
      hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
      minutes: { seconds: 60, milliseconds: 60 * 1e3 },
      seconds: { milliseconds: 1e3 }
    };
    var casualMatrix = {
      years: {
        quarters: 4,
        months: 12,
        weeks: 52,
        days: 365,
        hours: 365 * 24,
        minutes: 365 * 24 * 60,
        seconds: 365 * 24 * 60 * 60,
        milliseconds: 365 * 24 * 60 * 60 * 1e3
      },
      quarters: {
        months: 3,
        weeks: 13,
        days: 91,
        hours: 91 * 24,
        minutes: 91 * 24 * 60,
        seconds: 91 * 24 * 60 * 60,
        milliseconds: 91 * 24 * 60 * 60 * 1e3
      },
      months: {
        weeks: 4,
        days: 30,
        hours: 30 * 24,
        minutes: 30 * 24 * 60,
        seconds: 30 * 24 * 60 * 60,
        milliseconds: 30 * 24 * 60 * 60 * 1e3
      },
      ...lowOrderMatrix
    };
    var daysInYearAccurate = 146097 / 400;
    var daysInMonthAccurate = 146097 / 4800;
    var accurateMatrix = {
      years: {
        quarters: 4,
        months: 12,
        weeks: daysInYearAccurate / 7,
        days: daysInYearAccurate,
        hours: daysInYearAccurate * 24,
        minutes: daysInYearAccurate * 24 * 60,
        seconds: daysInYearAccurate * 24 * 60 * 60,
        milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3
      },
      quarters: {
        months: 3,
        weeks: daysInYearAccurate / 28,
        days: daysInYearAccurate / 4,
        hours: daysInYearAccurate * 24 / 4,
        minutes: daysInYearAccurate * 24 * 60 / 4,
        seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
        milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3 / 4
      },
      months: {
        weeks: daysInMonthAccurate / 7,
        days: daysInMonthAccurate,
        hours: daysInMonthAccurate * 24,
        minutes: daysInMonthAccurate * 24 * 60,
        seconds: daysInMonthAccurate * 24 * 60 * 60,
        milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1e3
      },
      ...lowOrderMatrix
    };
    var orderedUnits$1 = [
      "years",
      "quarters",
      "months",
      "weeks",
      "days",
      "hours",
      "minutes",
      "seconds",
      "milliseconds"
    ];
    var reverseUnits = orderedUnits$1.slice(0).reverse();
    function clone$1(dur, alts, clear = false) {
      const conf = {
        values: clear ? alts.values : { ...dur.values, ...alts.values || {} },
        loc: dur.loc.clone(alts.loc),
        conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
        matrix: alts.matrix || dur.matrix
      };
      return new Duration(conf);
    }
    function durationToMillis(matrix, vals) {
      var _a;
      let sum = (_a = vals.milliseconds) != null ? _a : 0;
      for (const unit of reverseUnits.slice(1)) {
        if (vals[unit]) {
          sum += vals[unit] * matrix[unit]["milliseconds"];
        }
      }
      return sum;
    }
    function normalizeValues(matrix, vals) {
      const factor = durationToMillis(matrix, vals) < 0 ? -1 : 1;
      orderedUnits$1.reduceRight((previous, current) => {
        if (!isUndefined(vals[current])) {
          if (previous) {
            const previousVal = vals[previous] * factor;
            const conv = matrix[current][previous];
            const rollUp = Math.floor(previousVal / conv);
            vals[current] += rollUp * factor;
            vals[previous] -= rollUp * conv * factor;
          }
          return current;
        } else {
          return previous;
        }
      }, null);
      orderedUnits$1.reduce((previous, current) => {
        if (!isUndefined(vals[current])) {
          if (previous) {
            const fraction = vals[previous] % 1;
            vals[previous] -= fraction;
            vals[current] += fraction * matrix[previous][current];
          }
          return current;
        } else {
          return previous;
        }
      }, null);
    }
    function removeZeroes(vals) {
      const newVals = {};
      for (const [key, value] of Object.entries(vals)) {
        if (value !== 0) {
          newVals[key] = value;
        }
      }
      return newVals;
    }
    var Duration = class {
      /**
       * @private
       */
      constructor(config2) {
        const accurate = config2.conversionAccuracy === "longterm" || false;
        let matrix = accurate ? accurateMatrix : casualMatrix;
        if (config2.matrix) {
          matrix = config2.matrix;
        }
        this.values = config2.values;
        this.loc = config2.loc || Locale.create();
        this.conversionAccuracy = accurate ? "longterm" : "casual";
        this.invalid = config2.invalid || null;
        this.matrix = matrix;
        this.isLuxonDuration = true;
      }
      /**
       * Create Duration from a number of milliseconds.
       * @param {number} count of milliseconds
       * @param {Object} opts - options for parsing
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @return {Duration}
       */
      static fromMillis(count, opts) {
        return Duration.fromObject({ milliseconds: count }, opts);
      }
      /**
       * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
       * If this object is empty then a zero milliseconds duration is returned.
       * @param {Object} obj - the object to create the DateTime from
       * @param {number} obj.years
       * @param {number} obj.quarters
       * @param {number} obj.months
       * @param {number} obj.weeks
       * @param {number} obj.days
       * @param {number} obj.hours
       * @param {number} obj.minutes
       * @param {number} obj.seconds
       * @param {number} obj.milliseconds
       * @param {Object} [opts=[]] - options for creating this Duration
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
       * @param {string} [opts.matrix=Object] - the custom conversion system to use
       * @return {Duration}
       */
      static fromObject(obj, opts = {}) {
        if (obj == null || typeof obj !== "object") {
          throw new InvalidArgumentError(
            `Duration.fromObject: argument expected to be an object, got ${obj === null ? "null" : typeof obj}`
          );
        }
        return new Duration({
          values: normalizeObject(obj, Duration.normalizeUnit),
          loc: Locale.fromObject(opts),
          conversionAccuracy: opts.conversionAccuracy,
          matrix: opts.matrix
        });
      }
      /**
       * Create a Duration from DurationLike.
       *
       * @param {Object | number | Duration} durationLike
       * One of:
       * - object with keys like 'years' and 'hours'.
       * - number representing milliseconds
       * - Duration instance
       * @return {Duration}
       */
      static fromDurationLike(durationLike) {
        if (isNumber2(durationLike)) {
          return Duration.fromMillis(durationLike);
        } else if (Duration.isDuration(durationLike)) {
          return durationLike;
        } else if (typeof durationLike === "object") {
          return Duration.fromObject(durationLike);
        } else {
          throw new InvalidArgumentError(
            `Unknown duration argument ${durationLike} of type ${typeof durationLike}`
          );
        }
      }
      /**
       * Create a Duration from an ISO 8601 duration string.
       * @param {string} text - text to parse
       * @param {Object} opts - options for parsing
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
       * @param {string} [opts.matrix=Object] - the preset conversion system to use
       * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
       * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
       * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
       * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
       * @return {Duration}
       */
      static fromISO(text, opts) {
        const [parsed] = parseISODuration(text);
        if (parsed) {
          return Duration.fromObject(parsed, opts);
        } else {
          return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
        }
      }
      /**
       * Create a Duration from an ISO 8601 time string.
       * @param {string} text - text to parse
       * @param {Object} opts - options for parsing
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
       * @param {string} [opts.matrix=Object] - the conversion system to use
       * @see https://en.wikipedia.org/wiki/ISO_8601#Times
       * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
       * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @return {Duration}
       */
      static fromISOTime(text, opts) {
        const [parsed] = parseISOTimeOnly(text);
        if (parsed) {
          return Duration.fromObject(parsed, opts);
        } else {
          return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
        }
      }
      /**
       * Create an invalid Duration.
       * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
       * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
       * @return {Duration}
       */
      static invalid(reason, explanation = null) {
        if (!reason) {
          throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
        }
        const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
        if (Settings.throwOnInvalid) {
          throw new InvalidDurationError(invalid);
        } else {
          return new Duration({ invalid });
        }
      }
      /**
       * @private
       */
      static normalizeUnit(unit) {
        const normalized = {
          year: "years",
          years: "years",
          quarter: "quarters",
          quarters: "quarters",
          month: "months",
          months: "months",
          week: "weeks",
          weeks: "weeks",
          day: "days",
          days: "days",
          hour: "hours",
          hours: "hours",
          minute: "minutes",
          minutes: "minutes",
          second: "seconds",
          seconds: "seconds",
          millisecond: "milliseconds",
          milliseconds: "milliseconds"
        }[unit ? unit.toLowerCase() : unit];
        if (!normalized)
          throw new InvalidUnitError(unit);
        return normalized;
      }
      /**
       * Check if an object is a Duration. Works across context boundaries
       * @param {object} o
       * @return {boolean}
       */
      static isDuration(o2) {
        return o2 && o2.isLuxonDuration || false;
      }
      /**
       * Get  the locale of a Duration, such 'en-GB'
       * @type {string}
       */
      get locale() {
        return this.isValid ? this.loc.locale : null;
      }
      /**
       * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
       *
       * @type {string}
       */
      get numberingSystem() {
        return this.isValid ? this.loc.numberingSystem : null;
      }
      /**
       * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
       * * `S` for milliseconds
       * * `s` for seconds
       * * `m` for minutes
       * * `h` for hours
       * * `d` for days
       * * `w` for weeks
       * * `M` for months
       * * `y` for years
       * Notes:
       * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
       * * Tokens can be escaped by wrapping with single quotes.
       * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
       * @param {string} fmt - the format string
       * @param {Object} opts - options
       * @param {boolean} [opts.floor=true] - floor numerical values
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
       * @return {string}
       */
      toFormat(fmt, opts = {}) {
        const fmtOpts = {
          ...opts,
          floor: opts.round !== false && opts.floor !== false
        };
        return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID$2;
      }
      /**
       * Returns a string representation of a Duration with all units included.
       * To modify its behavior use the `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat
       * @param opts - On option object to override the formatting. Accepts the same keys as the options parameter of the native `Int.NumberFormat` constructor, as well as `listStyle`.
       * @example
       * ```js
       * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
       * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
       * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
       * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
       * ```
       */
      toHuman(opts = {}) {
        if (!this.isValid)
          return INVALID$2;
        const l4 = orderedUnits$1.map((unit) => {
          const val = this.values[unit];
          if (isUndefined(val)) {
            return null;
          }
          return this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...opts, unit: unit.slice(0, -1) }).format(val);
        }).filter((n3) => n3);
        return this.loc.listFormatter({ type: "conjunction", style: opts.listStyle || "narrow", ...opts }).format(l4);
      }
      /**
       * Returns a JavaScript object with this Duration's values.
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
       * @return {Object}
       */
      toObject() {
        if (!this.isValid)
          return {};
        return { ...this.values };
      }
      /**
       * Returns an ISO 8601-compliant string representation of this Duration.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
       * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
       * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
       * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
       * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
       * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
       * @return {string}
       */
      toISO() {
        if (!this.isValid)
          return null;
        let s4 = "P";
        if (this.years !== 0)
          s4 += this.years + "Y";
        if (this.months !== 0 || this.quarters !== 0)
          s4 += this.months + this.quarters * 3 + "M";
        if (this.weeks !== 0)
          s4 += this.weeks + "W";
        if (this.days !== 0)
          s4 += this.days + "D";
        if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
          s4 += "T";
        if (this.hours !== 0)
          s4 += this.hours + "H";
        if (this.minutes !== 0)
          s4 += this.minutes + "M";
        if (this.seconds !== 0 || this.milliseconds !== 0)
          s4 += roundTo(this.seconds + this.milliseconds / 1e3, 3) + "S";
        if (s4 === "P")
          s4 += "T0S";
        return s4;
      }
      /**
       * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
       * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Times
       * @param {Object} opts - options
       * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
       * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
       * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
       * @return {string}
       */
      toISOTime(opts = {}) {
        if (!this.isValid)
          return null;
        const millis = this.toMillis();
        if (millis < 0 || millis >= 864e5)
          return null;
        opts = {
          suppressMilliseconds: false,
          suppressSeconds: false,
          includePrefix: false,
          format: "extended",
          ...opts,
          includeOffset: false
        };
        const dateTime = DateTime2.fromMillis(millis, { zone: "UTC" });
        return dateTime.toISOTime(opts);
      }
      /**
       * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
       * @return {string}
       */
      toJSON() {
        return this.toISO();
      }
      /**
       * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
       * @return {string}
       */
      toString() {
        return this.toISO();
      }
      /**
       * Returns an milliseconds value of this Duration.
       * @return {number}
       */
      toMillis() {
        if (!this.isValid)
          return NaN;
        return durationToMillis(this.matrix, this.values);
      }
      /**
       * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
       * @return {number}
       */
      valueOf() {
        return this.toMillis();
      }
      /**
       * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
       * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       * @return {Duration}
       */
      plus(duration) {
        if (!this.isValid)
          return this;
        const dur = Duration.fromDurationLike(duration), result = {};
        for (const k3 of orderedUnits$1) {
          if (hasOwnProperty2(dur.values, k3) || hasOwnProperty2(this.values, k3)) {
            result[k3] = dur.get(k3) + this.get(k3);
          }
        }
        return clone$1(this, { values: result }, true);
      }
      /**
       * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
       * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       * @return {Duration}
       */
      minus(duration) {
        if (!this.isValid)
          return this;
        const dur = Duration.fromDurationLike(duration);
        return this.plus(dur.negate());
      }
      /**
       * Scale this Duration by the specified amount. Return a newly-constructed Duration.
       * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
       * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
       * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hours" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
       * @return {Duration}
       */
      mapUnits(fn) {
        if (!this.isValid)
          return this;
        const result = {};
        for (const k3 of Object.keys(this.values)) {
          result[k3] = asNumber(fn(this.values[k3], k3));
        }
        return clone$1(this, { values: result }, true);
      }
      /**
       * Get the value of unit.
       * @param {string} unit - a unit such as 'minute' or 'day'
       * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
       * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
       * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
       * @return {number}
       */
      get(unit) {
        return this[Duration.normalizeUnit(unit)];
      }
      /**
       * "Set" the values of specified units. Return a newly-constructed Duration.
       * @param {Object} values - a mapping of units to numbers
       * @example dur.set({ years: 2017 })
       * @example dur.set({ hours: 8, minutes: 30 })
       * @return {Duration}
       */
      set(values) {
        if (!this.isValid)
          return this;
        const mixed = { ...this.values, ...normalizeObject(values, Duration.normalizeUnit) };
        return clone$1(this, { values: mixed });
      }
      /**
       * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
       * @example dur.reconfigure({ locale: 'en-GB' })
       * @return {Duration}
       */
      reconfigure({ locale, numberingSystem, conversionAccuracy, matrix } = {}) {
        const loc = this.loc.clone({ locale, numberingSystem });
        const opts = { loc, matrix, conversionAccuracy };
        return clone$1(this, opts);
      }
      /**
       * Return the length of the duration in the specified unit.
       * @param {string} unit - a unit such as 'minutes' or 'days'
       * @example Duration.fromObject({years: 1}).as('days') //=> 365
       * @example Duration.fromObject({years: 1}).as('months') //=> 12
       * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
       * @return {number}
       */
      as(unit) {
        return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
      }
      /**
       * Reduce this Duration to its canonical representation in its current units.
       * Assuming the overall value of the Duration is positive, this means:
       * - excessive values for lower-order units are converted to higher-order units (if possible, see first and second example)
       * - negative lower-order units are converted to higher order units (there must be such a higher order unit, otherwise
       *   the overall value would be negative, see second example)
       * - fractional values for higher-order units are converted to lower-order units (if possible, see fourth example)
       *
       * If the overall value is negative, the result of this method is equivalent to `this.negate().normalize().negate()`.
       * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
       * @example Duration.fromObject({ days: 5000 }).normalize().toObject() //=> { days: 5000 }
       * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
       * @example Duration.fromObject({ years: 2.5, days: 0, hours: 0 }).normalize().toObject() //=> { years: 2, days: 182, hours: 12 }
       * @return {Duration}
       */
      normalize() {
        if (!this.isValid)
          return this;
        const vals = this.toObject();
        normalizeValues(this.matrix, vals);
        return clone$1(this, { values: vals }, true);
      }
      /**
       * Rescale units to its largest representation
       * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }
       * @return {Duration}
       */
      rescale() {
        if (!this.isValid)
          return this;
        const vals = removeZeroes(this.normalize().shiftToAll().toObject());
        return clone$1(this, { values: vals }, true);
      }
      /**
       * Convert this Duration into its representation in a different set of units.
       * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
       * @return {Duration}
       */
      shiftTo(...units) {
        if (!this.isValid)
          return this;
        if (units.length === 0) {
          return this;
        }
        units = units.map((u3) => Duration.normalizeUnit(u3));
        const built = {}, accumulated = {}, vals = this.toObject();
        let lastUnit;
        for (const k3 of orderedUnits$1) {
          if (units.indexOf(k3) >= 0) {
            lastUnit = k3;
            let own = 0;
            for (const ak in accumulated) {
              own += this.matrix[ak][k3] * accumulated[ak];
              accumulated[ak] = 0;
            }
            if (isNumber2(vals[k3])) {
              own += vals[k3];
            }
            const i3 = Math.trunc(own);
            built[k3] = i3;
            accumulated[k3] = (own * 1e3 - i3 * 1e3) / 1e3;
          } else if (isNumber2(vals[k3])) {
            accumulated[k3] = vals[k3];
          }
        }
        for (const key in accumulated) {
          if (accumulated[key] !== 0) {
            built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
          }
        }
        normalizeValues(this.matrix, built);
        return clone$1(this, { values: built }, true);
      }
      /**
       * Shift this Duration to all available units.
       * Same as shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds")
       * @return {Duration}
       */
      shiftToAll() {
        if (!this.isValid)
          return this;
        return this.shiftTo(
          "years",
          "months",
          "weeks",
          "days",
          "hours",
          "minutes",
          "seconds",
          "milliseconds"
        );
      }
      /**
       * Return the negative of this Duration.
       * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
       * @return {Duration}
       */
      negate() {
        if (!this.isValid)
          return this;
        const negated = {};
        for (const k3 of Object.keys(this.values)) {
          negated[k3] = this.values[k3] === 0 ? 0 : -this.values[k3];
        }
        return clone$1(this, { values: negated }, true);
      }
      /**
       * Get the years.
       * @type {number}
       */
      get years() {
        return this.isValid ? this.values.years || 0 : NaN;
      }
      /**
       * Get the quarters.
       * @type {number}
       */
      get quarters() {
        return this.isValid ? this.values.quarters || 0 : NaN;
      }
      /**
       * Get the months.
       * @type {number}
       */
      get months() {
        return this.isValid ? this.values.months || 0 : NaN;
      }
      /**
       * Get the weeks
       * @type {number}
       */
      get weeks() {
        return this.isValid ? this.values.weeks || 0 : NaN;
      }
      /**
       * Get the days.
       * @type {number}
       */
      get days() {
        return this.isValid ? this.values.days || 0 : NaN;
      }
      /**
       * Get the hours.
       * @type {number}
       */
      get hours() {
        return this.isValid ? this.values.hours || 0 : NaN;
      }
      /**
       * Get the minutes.
       * @type {number}
       */
      get minutes() {
        return this.isValid ? this.values.minutes || 0 : NaN;
      }
      /**
       * Get the seconds.
       * @return {number}
       */
      get seconds() {
        return this.isValid ? this.values.seconds || 0 : NaN;
      }
      /**
       * Get the milliseconds.
       * @return {number}
       */
      get milliseconds() {
        return this.isValid ? this.values.milliseconds || 0 : NaN;
      }
      /**
       * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
       * on invalid DateTimes or Intervals.
       * @return {boolean}
       */
      get isValid() {
        return this.invalid === null;
      }
      /**
       * Returns an error code if this Duration became invalid, or null if the Duration is valid
       * @return {string}
       */
      get invalidReason() {
        return this.invalid ? this.invalid.reason : null;
      }
      /**
       * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
       * @type {string}
       */
      get invalidExplanation() {
        return this.invalid ? this.invalid.explanation : null;
      }
      /**
       * Equality check
       * Two Durations are equal iff they have the same units and the same values for each unit.
       * @param {Duration} other
       * @return {boolean}
       */
      equals(other) {
        if (!this.isValid || !other.isValid) {
          return false;
        }
        if (!this.loc.equals(other.loc)) {
          return false;
        }
        function eq(v1, v22) {
          if (v1 === void 0 || v1 === 0)
            return v22 === void 0 || v22 === 0;
          return v1 === v22;
        }
        for (const u3 of orderedUnits$1) {
          if (!eq(this.values[u3], other.values[u3])) {
            return false;
          }
        }
        return true;
      }
    };
    var INVALID$1 = "Invalid Interval";
    function validateStartEnd(start, end) {
      if (!start || !start.isValid) {
        return Interval.invalid("missing or invalid start");
      } else if (!end || !end.isValid) {
        return Interval.invalid("missing or invalid end");
      } else if (end < start) {
        return Interval.invalid(
          "end before start",
          `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`
        );
      } else {
        return null;
      }
    }
    var Interval = class {
      /**
       * @private
       */
      constructor(config2) {
        this.s = config2.start;
        this.e = config2.end;
        this.invalid = config2.invalid || null;
        this.isLuxonInterval = true;
      }
      /**
       * Create an invalid Interval.
       * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
       * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
       * @return {Interval}
       */
      static invalid(reason, explanation = null) {
        if (!reason) {
          throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
        }
        const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
        if (Settings.throwOnInvalid) {
          throw new InvalidIntervalError(invalid);
        } else {
          return new Interval({ invalid });
        }
      }
      /**
       * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
       * @param {DateTime|Date|Object} start
       * @param {DateTime|Date|Object} end
       * @return {Interval}
       */
      static fromDateTimes(start, end) {
        const builtStart = friendlyDateTime(start), builtEnd = friendlyDateTime(end);
        const validateError = validateStartEnd(builtStart, builtEnd);
        if (validateError == null) {
          return new Interval({
            start: builtStart,
            end: builtEnd
          });
        } else {
          return validateError;
        }
      }
      /**
       * Create an Interval from a start DateTime and a Duration to extend to.
       * @param {DateTime|Date|Object} start
       * @param {Duration|Object|number} duration - the length of the Interval.
       * @return {Interval}
       */
      static after(start, duration) {
        const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(start);
        return Interval.fromDateTimes(dt, dt.plus(dur));
      }
      /**
       * Create an Interval from an end DateTime and a Duration to extend backwards to.
       * @param {DateTime|Date|Object} end
       * @param {Duration|Object|number} duration - the length of the Interval.
       * @return {Interval}
       */
      static before(end, duration) {
        const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(end);
        return Interval.fromDateTimes(dt.minus(dur), dt);
      }
      /**
       * Create an Interval from an ISO 8601 string.
       * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
       * @param {string} text - the ISO string to parse
       * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @return {Interval}
       */
      static fromISO(text, opts) {
        const [s4, e3] = (text || "").split("/", 2);
        if (s4 && e3) {
          let start, startIsValid;
          try {
            start = DateTime2.fromISO(s4, opts);
            startIsValid = start.isValid;
          } catch (e4) {
            startIsValid = false;
          }
          let end, endIsValid;
          try {
            end = DateTime2.fromISO(e3, opts);
            endIsValid = end.isValid;
          } catch (e4) {
            endIsValid = false;
          }
          if (startIsValid && endIsValid) {
            return Interval.fromDateTimes(start, end);
          }
          if (startIsValid) {
            const dur = Duration.fromISO(e3, opts);
            if (dur.isValid) {
              return Interval.after(start, dur);
            }
          } else if (endIsValid) {
            const dur = Duration.fromISO(s4, opts);
            if (dur.isValid) {
              return Interval.before(end, dur);
            }
          }
        }
        return Interval.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
      }
      /**
       * Check if an object is an Interval. Works across context boundaries
       * @param {object} o
       * @return {boolean}
       */
      static isInterval(o2) {
        return o2 && o2.isLuxonInterval || false;
      }
      /**
       * Returns the start of the Interval
       * @type {DateTime}
       */
      get start() {
        return this.isValid ? this.s : null;
      }
      /**
       * Returns the end of the Interval
       * @type {DateTime}
       */
      get end() {
        return this.isValid ? this.e : null;
      }
      /**
       * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
       * @type {boolean}
       */
      get isValid() {
        return this.invalidReason === null;
      }
      /**
       * Returns an error code if this Interval is invalid, or null if the Interval is valid
       * @type {string}
       */
      get invalidReason() {
        return this.invalid ? this.invalid.reason : null;
      }
      /**
       * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
       * @type {string}
       */
      get invalidExplanation() {
        return this.invalid ? this.invalid.explanation : null;
      }
      /**
       * Returns the length of the Interval in the specified unit.
       * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
       * @return {number}
       */
      length(unit = "milliseconds") {
        return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;
      }
      /**
       * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
       * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
       * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
       * @param {string} [unit='milliseconds'] - the unit of time to count.
       * @return {number}
       */
      count(unit = "milliseconds") {
        if (!this.isValid)
          return NaN;
        const start = this.start.startOf(unit), end = this.end.startOf(unit);
        return Math.floor(end.diff(start, unit).get(unit)) + (end.valueOf() !== this.end.valueOf());
      }
      /**
       * Returns whether this Interval's start and end are both in the same unit of time
       * @param {string} unit - the unit of time to check sameness on
       * @return {boolean}
       */
      hasSame(unit) {
        return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
      }
      /**
       * Return whether this Interval has the same start and end DateTimes.
       * @return {boolean}
       */
      isEmpty() {
        return this.s.valueOf() === this.e.valueOf();
      }
      /**
       * Return whether this Interval's start is after the specified DateTime.
       * @param {DateTime} dateTime
       * @return {boolean}
       */
      isAfter(dateTime) {
        if (!this.isValid)
          return false;
        return this.s > dateTime;
      }
      /**
       * Return whether this Interval's end is before the specified DateTime.
       * @param {DateTime} dateTime
       * @return {boolean}
       */
      isBefore(dateTime) {
        if (!this.isValid)
          return false;
        return this.e <= dateTime;
      }
      /**
       * Return whether this Interval contains the specified DateTime.
       * @param {DateTime} dateTime
       * @return {boolean}
       */
      contains(dateTime) {
        if (!this.isValid)
          return false;
        return this.s <= dateTime && this.e > dateTime;
      }
      /**
       * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
       * @param {Object} values - the values to set
       * @param {DateTime} values.start - the starting DateTime
       * @param {DateTime} values.end - the ending DateTime
       * @return {Interval}
       */
      set({ start, end } = {}) {
        if (!this.isValid)
          return this;
        return Interval.fromDateTimes(start || this.s, end || this.e);
      }
      /**
       * Split this Interval at each of the specified DateTimes
       * @param {...DateTime} dateTimes - the unit of time to count.
       * @return {Array}
       */
      splitAt(...dateTimes) {
        if (!this.isValid)
          return [];
        const sorted = dateTimes.map(friendlyDateTime).filter((d2) => this.contains(d2)).sort(), results = [];
        let { s: s4 } = this, i3 = 0;
        while (s4 < this.e) {
          const added = sorted[i3] || this.e, next = +added > +this.e ? this.e : added;
          results.push(Interval.fromDateTimes(s4, next));
          s4 = next;
          i3 += 1;
        }
        return results;
      }
      /**
       * Split this Interval into smaller Intervals, each of the specified length.
       * Left over time is grouped into a smaller interval
       * @param {Duration|Object|number} duration - The length of each resulting interval.
       * @return {Array}
       */
      splitBy(duration) {
        const dur = Duration.fromDurationLike(duration);
        if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
          return [];
        }
        let { s: s4 } = this, idx = 1, next;
        const results = [];
        while (s4 < this.e) {
          const added = this.start.plus(dur.mapUnits((x4) => x4 * idx));
          next = +added > +this.e ? this.e : added;
          results.push(Interval.fromDateTimes(s4, next));
          s4 = next;
          idx += 1;
        }
        return results;
      }
      /**
       * Split this Interval into the specified number of smaller intervals.
       * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
       * @return {Array}
       */
      divideEqually(numberOfParts) {
        if (!this.isValid)
          return [];
        return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
      }
      /**
       * Return whether this Interval overlaps with the specified Interval
       * @param {Interval} other
       * @return {boolean}
       */
      overlaps(other) {
        return this.e > other.s && this.s < other.e;
      }
      /**
       * Return whether this Interval's end is adjacent to the specified Interval's start.
       * @param {Interval} other
       * @return {boolean}
       */
      abutsStart(other) {
        if (!this.isValid)
          return false;
        return +this.e === +other.s;
      }
      /**
       * Return whether this Interval's start is adjacent to the specified Interval's end.
       * @param {Interval} other
       * @return {boolean}
       */
      abutsEnd(other) {
        if (!this.isValid)
          return false;
        return +other.e === +this.s;
      }
      /**
       * Return whether this Interval engulfs the start and end of the specified Interval.
       * @param {Interval} other
       * @return {boolean}
       */
      engulfs(other) {
        if (!this.isValid)
          return false;
        return this.s <= other.s && this.e >= other.e;
      }
      /**
       * Return whether this Interval has the same start and end as the specified Interval.
       * @param {Interval} other
       * @return {boolean}
       */
      equals(other) {
        if (!this.isValid || !other.isValid) {
          return false;
        }
        return this.s.equals(other.s) && this.e.equals(other.e);
      }
      /**
       * Return an Interval representing the intersection of this Interval and the specified Interval.
       * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
       * Returns null if the intersection is empty, meaning, the intervals don't intersect.
       * @param {Interval} other
       * @return {Interval}
       */
      intersection(other) {
        if (!this.isValid)
          return this;
        const s4 = this.s > other.s ? this.s : other.s, e3 = this.e < other.e ? this.e : other.e;
        if (s4 >= e3) {
          return null;
        } else {
          return Interval.fromDateTimes(s4, e3);
        }
      }
      /**
       * Return an Interval representing the union of this Interval and the specified Interval.
       * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
       * @param {Interval} other
       * @return {Interval}
       */
      union(other) {
        if (!this.isValid)
          return this;
        const s4 = this.s < other.s ? this.s : other.s, e3 = this.e > other.e ? this.e : other.e;
        return Interval.fromDateTimes(s4, e3);
      }
      /**
       * Merge an array of Intervals into a equivalent minimal set of Intervals.
       * Combines overlapping and adjacent Intervals.
       * @param {Array} intervals
       * @return {Array}
       */
      static merge(intervals) {
        const [found, final] = intervals.sort((a3, b3) => a3.s - b3.s).reduce(
          ([sofar, current], item) => {
            if (!current) {
              return [sofar, item];
            } else if (current.overlaps(item) || current.abutsStart(item)) {
              return [sofar, current.union(item)];
            } else {
              return [sofar.concat([current]), item];
            }
          },
          [[], null]
        );
        if (final) {
          found.push(final);
        }
        return found;
      }
      /**
       * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
       * @param {Array} intervals
       * @return {Array}
       */
      static xor(intervals) {
        let start = null, currentCount = 0;
        const results = [], ends = intervals.map((i3) => [
          { time: i3.s, type: "s" },
          { time: i3.e, type: "e" }
        ]), flattened = Array.prototype.concat(...ends), arr = flattened.sort((a3, b3) => a3.time - b3.time);
        for (const i3 of arr) {
          currentCount += i3.type === "s" ? 1 : -1;
          if (currentCount === 1) {
            start = i3.time;
          } else {
            if (start && +start !== +i3.time) {
              results.push(Interval.fromDateTimes(start, i3.time));
            }
            start = null;
          }
        }
        return Interval.merge(results);
      }
      /**
       * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
       * @param {...Interval} intervals
       * @return {Array}
       */
      difference(...intervals) {
        return Interval.xor([this].concat(intervals)).map((i3) => this.intersection(i3)).filter((i3) => i3 && !i3.isEmpty());
      }
      /**
       * Returns a string representation of this Interval appropriate for debugging.
       * @return {string}
       */
      toString() {
        if (!this.isValid)
          return INVALID$1;
        return `[${this.s.toISO()} \u2013 ${this.e.toISO()})`;
      }
      /**
       * Returns a localized string representing this Interval. Accepts the same options as the
       * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as
       * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method
       * is browser-specific, but in general it will return an appropriate representation of the
       * Interval in the assigned locale. Defaults to the system's locale if no locale has been
       * specified.
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or
       * Intl.DateTimeFormat constructor options.
       * @param {Object} opts - Options to override the configuration of the start DateTime.
       * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022  11/8/2022
       * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7  8, 2022
       * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 78 novembre 2022
       * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00  8:00 PM
       * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00  8:00 p
       * @return {string}
       */
      toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
        return this.isValid ? Formatter.create(this.s.loc.clone(opts), formatOpts).formatInterval(this) : INVALID$1;
      }
      /**
       * Returns an ISO 8601-compliant string representation of this Interval.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @param {Object} opts - The same options as {@link DateTime#toISO}
       * @return {string}
       */
      toISO(opts) {
        if (!this.isValid)
          return INVALID$1;
        return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
      }
      /**
       * Returns an ISO 8601-compliant string representation of date of this Interval.
       * The time components are ignored.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @return {string}
       */
      toISODate() {
        if (!this.isValid)
          return INVALID$1;
        return `${this.s.toISODate()}/${this.e.toISODate()}`;
      }
      /**
       * Returns an ISO 8601-compliant string representation of time of this Interval.
       * The date components are ignored.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @param {Object} opts - The same options as {@link DateTime#toISO}
       * @return {string}
       */
      toISOTime(opts) {
        if (!this.isValid)
          return INVALID$1;
        return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
      }
      /**
       * Returns a string representation of this Interval formatted according to the specified format
       * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible
       * formatting tool.
       * @param {string} dateFormat - The format string. This string formats the start and end time.
       * See {@link DateTime#toFormat} for details.
       * @param {Object} opts - Options.
       * @param {string} [opts.separator =  '  '] - A separator to place between the start and end
       * representations.
       * @return {string}
       */
      toFormat(dateFormat, { separator = " \u2013 " } = {}) {
        if (!this.isValid)
          return INVALID$1;
        return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
      }
      /**
       * Return a Duration representing the time spanned by this interval.
       * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
       * @param {Object} opts - options that affect the creation of the Duration
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
       * @return {Duration}
       */
      toDuration(unit, opts) {
        if (!this.isValid) {
          return Duration.invalid(this.invalidReason);
        }
        return this.e.diff(this.s, unit, opts);
      }
      /**
       * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
       * @param {function} mapFn
       * @return {Interval}
       * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
       * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
       */
      mapEndpoints(mapFn) {
        return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
      }
    };
    var Info = class {
      /**
       * Return whether the specified zone contains a DST.
       * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
       * @return {boolean}
       */
      static hasDST(zone = Settings.defaultZone) {
        const proto = DateTime2.now().setZone(zone).set({ month: 12 });
        return !zone.isUniversal && proto.offset !== proto.set({ month: 6 }).offset;
      }
      /**
       * Return whether the specified zone is a valid IANA specifier.
       * @param {string} zone - Zone to check
       * @return {boolean}
       */
      static isValidIANAZone(zone) {
        return IANAZone.isValidZone(zone);
      }
      /**
       * Converts the input into a {@link Zone} instance.
       *
       * * If `input` is already a Zone instance, it is returned unchanged.
       * * If `input` is a string containing a valid time zone name, a Zone instance
       *   with that name is returned.
       * * If `input` is a string that doesn't refer to a known time zone, a Zone
       *   instance with {@link Zone#isValid} == false is returned.
       * * If `input is a number, a Zone instance with the specified fixed offset
       *   in minutes is returned.
       * * If `input` is `null` or `undefined`, the default zone is returned.
       * @param {string|Zone|number} [input] - the value to be converted
       * @return {Zone}
       */
      static normalizeZone(input) {
        return normalizeZone(input, Settings.defaultZone);
      }
      /**
       * Return an array of standalone month names.
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @param {string} [opts.outputCalendar='gregory'] - the calendar
       * @example Info.months()[0] //=> 'January'
       * @example Info.months('short')[0] //=> 'Jan'
       * @example Info.months('numeric')[0] //=> '1'
       * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
       * @example Info.months('numeric', { locale: 'ar' })[0] //=> ''
       * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabi I'
       * @return {Array}
       */
      static months(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
        return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length);
      }
      /**
       * Return an array of format month names.
       * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
       * changes the string.
       * See {@link Info#months}
       * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @param {string} [opts.outputCalendar='gregory'] - the calendar
       * @return {Array}
       */
      static monthsFormat(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
        return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length, true);
      }
      /**
       * Return an array of standalone week names.
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @example Info.weekdays()[0] //=> 'Monday'
       * @example Info.weekdays('short')[0] //=> 'Mon'
       * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
       * @example Info.weekdays('short', { locale: 'ar' })[0] //=> ''
       * @return {Array}
       */
      static weekdays(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
        return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length);
      }
      /**
       * Return an array of format week names.
       * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
       * changes the string.
       * See {@link Info#weekdays}
       * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
       * @param {Object} opts - options
       * @param {string} [opts.locale=null] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @return {Array}
       */
      static weekdaysFormat(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
        return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length, true);
      }
      /**
       * Return an array of meridiems.
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @example Info.meridiems() //=> [ 'AM', 'PM' ]
       * @example Info.meridiems({ locale: 'my' }) //=> [ '', '' ]
       * @return {Array}
       */
      static meridiems({ locale = null } = {}) {
        return Locale.create(locale).meridiems();
      }
      /**
       * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
       * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @example Info.eras() //=> [ 'BC', 'AD' ]
       * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
       * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jsus-Christ', 'aprs Jsus-Christ' ]
       * @return {Array}
       */
      static eras(length = "short", { locale = null } = {}) {
        return Locale.create(locale, null, "gregory").eras(length);
      }
      /**
       * Return the set of available features in this environment.
       * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
       * Keys:
       * * `relative`: whether this environment supports relative time formatting
       * @example Info.features() //=> { relative: false }
       * @return {Object}
       */
      static features() {
        return { relative: hasRelative() };
      }
    };
    function dayDiff(earlier, later) {
      const utcDayStart = (dt) => dt.toUTC(0, { keepLocalTime: true }).startOf("day").valueOf(), ms = utcDayStart(later) - utcDayStart(earlier);
      return Math.floor(Duration.fromMillis(ms).as("days"));
    }
    function highOrderDiffs(cursor, later, units) {
      const differs = [
        ["years", (a3, b3) => b3.year - a3.year],
        ["quarters", (a3, b3) => b3.quarter - a3.quarter + (b3.year - a3.year) * 4],
        ["months", (a3, b3) => b3.month - a3.month + (b3.year - a3.year) * 12],
        [
          "weeks",
          (a3, b3) => {
            const days = dayDiff(a3, b3);
            return (days - days % 7) / 7;
          }
        ],
        ["days", dayDiff]
      ];
      const results = {};
      const earlier = cursor;
      let lowestOrder, highWater;
      for (const [unit, differ] of differs) {
        if (units.indexOf(unit) >= 0) {
          lowestOrder = unit;
          results[unit] = differ(cursor, later);
          highWater = earlier.plus(results);
          if (highWater > later) {
            results[unit]--;
            cursor = earlier.plus(results);
            if (cursor > later) {
              highWater = cursor;
              results[unit]--;
              cursor = earlier.plus(results);
            }
          } else {
            cursor = highWater;
          }
        }
      }
      return [cursor, results, highWater, lowestOrder];
    }
    function diff(earlier, later, units, opts) {
      let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);
      const remainingMillis = later - cursor;
      const lowerOrderUnits = units.filter(
        (u3) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u3) >= 0
      );
      if (lowerOrderUnits.length === 0) {
        if (highWater < later) {
          highWater = cursor.plus({ [lowestOrder]: 1 });
        }
        if (highWater !== cursor) {
          results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
        }
      }
      const duration = Duration.fromObject(results, opts);
      if (lowerOrderUnits.length > 0) {
        return Duration.fromMillis(remainingMillis, opts).shiftTo(...lowerOrderUnits).plus(duration);
      } else {
        return duration;
      }
    }
    var numberingSystems = {
      arab: "[\u0660-\u0669]",
      arabext: "[\u06F0-\u06F9]",
      bali: "[\u1B50-\u1B59]",
      beng: "[\u09E6-\u09EF]",
      deva: "[\u0966-\u096F]",
      fullwide: "[\uFF10-\uFF19]",
      gujr: "[\u0AE6-\u0AEF]",
      hanidec: "[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]",
      khmr: "[\u17E0-\u17E9]",
      knda: "[\u0CE6-\u0CEF]",
      laoo: "[\u0ED0-\u0ED9]",
      limb: "[\u1946-\u194F]",
      mlym: "[\u0D66-\u0D6F]",
      mong: "[\u1810-\u1819]",
      mymr: "[\u1040-\u1049]",
      orya: "[\u0B66-\u0B6F]",
      tamldec: "[\u0BE6-\u0BEF]",
      telu: "[\u0C66-\u0C6F]",
      thai: "[\u0E50-\u0E59]",
      tibt: "[\u0F20-\u0F29]",
      latn: "\\d"
    };
    var numberingSystemsUTF16 = {
      arab: [1632, 1641],
      arabext: [1776, 1785],
      bali: [6992, 7001],
      beng: [2534, 2543],
      deva: [2406, 2415],
      fullwide: [65296, 65303],
      gujr: [2790, 2799],
      khmr: [6112, 6121],
      knda: [3302, 3311],
      laoo: [3792, 3801],
      limb: [6470, 6479],
      mlym: [3430, 3439],
      mong: [6160, 6169],
      mymr: [4160, 4169],
      orya: [2918, 2927],
      tamldec: [3046, 3055],
      telu: [3174, 3183],
      thai: [3664, 3673],
      tibt: [3872, 3881]
    };
    var hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
    function parseDigits(str) {
      let value = parseInt(str, 10);
      if (isNaN(value)) {
        value = "";
        for (let i3 = 0; i3 < str.length; i3++) {
          const code = str.charCodeAt(i3);
          if (str[i3].search(numberingSystems.hanidec) !== -1) {
            value += hanidecChars.indexOf(str[i3]);
          } else {
            for (const key in numberingSystemsUTF16) {
              const [min, max] = numberingSystemsUTF16[key];
              if (code >= min && code <= max) {
                value += code - min;
              }
            }
          }
        }
        return parseInt(value, 10);
      } else {
        return value;
      }
    }
    function digitRegex({ numberingSystem }, append = "") {
      return new RegExp(`${numberingSystems[numberingSystem || "latn"]}${append}`);
    }
    var MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
    function intUnit(regex, post = (i3) => i3) {
      return { regex, deser: ([s4]) => post(parseDigits(s4)) };
    }
    var NBSP = String.fromCharCode(160);
    var spaceOrNBSP = `[ ${NBSP}]`;
    var spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
    function fixListRegex(s4) {
      return s4.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
    }
    function stripInsensitivities(s4) {
      return s4.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
    }
    function oneOf(strings, startIndex) {
      if (strings === null) {
        return null;
      } else {
        return {
          regex: RegExp(strings.map(fixListRegex).join("|")),
          deser: ([s4]) => strings.findIndex((i3) => stripInsensitivities(s4) === stripInsensitivities(i3)) + startIndex
        };
      }
    }
    function offset(regex, groups) {
      return { regex, deser: ([, h3, m3]) => signedOffset(h3, m3), groups };
    }
    function simple(regex) {
      return { regex, deser: ([s4]) => s4 };
    }
    function escapeToken(value) {
      return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
    }
    function unitForToken(token, loc) {
      const one = digitRegex(loc), two = digitRegex(loc, "{2}"), three = digitRegex(loc, "{3}"), four = digitRegex(loc, "{4}"), six = digitRegex(loc, "{6}"), oneOrTwo = digitRegex(loc, "{1,2}"), oneToThree = digitRegex(loc, "{1,3}"), oneToSix = digitRegex(loc, "{1,6}"), oneToNine = digitRegex(loc, "{1,9}"), twoToFour = digitRegex(loc, "{2,4}"), fourToSix = digitRegex(loc, "{4,6}"), literal = (t3) => ({ regex: RegExp(escapeToken(t3.val)), deser: ([s4]) => s4, literal: true }), unitate = (t3) => {
        if (token.literal) {
          return literal(t3);
        }
        switch (t3.val) {
          case "G":
            return oneOf(loc.eras("short"), 0);
          case "GG":
            return oneOf(loc.eras("long"), 0);
          case "y":
            return intUnit(oneToSix);
          case "yy":
            return intUnit(twoToFour, untruncateYear);
          case "yyyy":
            return intUnit(four);
          case "yyyyy":
            return intUnit(fourToSix);
          case "yyyyyy":
            return intUnit(six);
          case "M":
            return intUnit(oneOrTwo);
          case "MM":
            return intUnit(two);
          case "MMM":
            return oneOf(loc.months("short", true), 1);
          case "MMMM":
            return oneOf(loc.months("long", true), 1);
          case "L":
            return intUnit(oneOrTwo);
          case "LL":
            return intUnit(two);
          case "LLL":
            return oneOf(loc.months("short", false), 1);
          case "LLLL":
            return oneOf(loc.months("long", false), 1);
          case "d":
            return intUnit(oneOrTwo);
          case "dd":
            return intUnit(two);
          case "o":
            return intUnit(oneToThree);
          case "ooo":
            return intUnit(three);
          case "HH":
            return intUnit(two);
          case "H":
            return intUnit(oneOrTwo);
          case "hh":
            return intUnit(two);
          case "h":
            return intUnit(oneOrTwo);
          case "mm":
            return intUnit(two);
          case "m":
            return intUnit(oneOrTwo);
          case "q":
            return intUnit(oneOrTwo);
          case "qq":
            return intUnit(two);
          case "s":
            return intUnit(oneOrTwo);
          case "ss":
            return intUnit(two);
          case "S":
            return intUnit(oneToThree);
          case "SSS":
            return intUnit(three);
          case "u":
            return simple(oneToNine);
          case "uu":
            return simple(oneOrTwo);
          case "uuu":
            return intUnit(one);
          case "a":
            return oneOf(loc.meridiems(), 0);
          case "kkkk":
            return intUnit(four);
          case "kk":
            return intUnit(twoToFour, untruncateYear);
          case "W":
            return intUnit(oneOrTwo);
          case "WW":
            return intUnit(two);
          case "E":
          case "c":
            return intUnit(one);
          case "EEE":
            return oneOf(loc.weekdays("short", false), 1);
          case "EEEE":
            return oneOf(loc.weekdays("long", false), 1);
          case "ccc":
            return oneOf(loc.weekdays("short", true), 1);
          case "cccc":
            return oneOf(loc.weekdays("long", true), 1);
          case "Z":
          case "ZZ":
            return offset(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
          case "ZZZ":
            return offset(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
          case "z":
            return simple(/[a-z_+-/]{1,256}?/i);
          case " ":
            return simple(/[^\S\n\r]/);
          default:
            return literal(t3);
        }
      };
      const unit = unitate(token) || {
        invalidReason: MISSING_FTP
      };
      unit.token = token;
      return unit;
    }
    var partTypeStyleToTokenVal = {
      year: {
        "2-digit": "yy",
        numeric: "yyyyy"
      },
      month: {
        numeric: "M",
        "2-digit": "MM",
        short: "MMM",
        long: "MMMM"
      },
      day: {
        numeric: "d",
        "2-digit": "dd"
      },
      weekday: {
        short: "EEE",
        long: "EEEE"
      },
      dayperiod: "a",
      dayPeriod: "a",
      hour12: {
        numeric: "h",
        "2-digit": "hh"
      },
      hour24: {
        numeric: "H",
        "2-digit": "HH"
      },
      minute: {
        numeric: "m",
        "2-digit": "mm"
      },
      second: {
        numeric: "s",
        "2-digit": "ss"
      },
      timeZoneName: {
        long: "ZZZZZ",
        short: "ZZZ"
      }
    };
    function tokenForPart(part, formatOpts, resolvedOpts) {
      const { type, value } = part;
      if (type === "literal") {
        const isSpace = /^\s+$/.test(value);
        return {
          literal: !isSpace,
          val: isSpace ? " " : value
        };
      }
      const style = formatOpts[type];
      let actualType = type;
      if (type === "hour") {
        if (formatOpts.hour12 != null) {
          actualType = formatOpts.hour12 ? "hour12" : "hour24";
        } else if (formatOpts.hourCycle != null) {
          if (formatOpts.hourCycle === "h11" || formatOpts.hourCycle === "h12") {
            actualType = "hour12";
          } else {
            actualType = "hour24";
          }
        } else {
          actualType = resolvedOpts.hour12 ? "hour12" : "hour24";
        }
      }
      let val = partTypeStyleToTokenVal[actualType];
      if (typeof val === "object") {
        val = val[style];
      }
      if (val) {
        return {
          literal: false,
          val
        };
      }
      return void 0;
    }
    function buildRegex(units) {
      const re = units.map((u3) => u3.regex).reduce((f3, r3) => `${f3}(${r3.source})`, "");
      return [`^${re}$`, units];
    }
    function match(input, regex, handlers) {
      const matches = input.match(regex);
      if (matches) {
        const all = {};
        let matchIndex = 1;
        for (const i3 in handlers) {
          if (hasOwnProperty2(handlers, i3)) {
            const h3 = handlers[i3], groups = h3.groups ? h3.groups + 1 : 1;
            if (!h3.literal && h3.token) {
              all[h3.token.val[0]] = h3.deser(matches.slice(matchIndex, matchIndex + groups));
            }
            matchIndex += groups;
          }
        }
        return [matches, all];
      } else {
        return [matches, {}];
      }
    }
    function dateTimeFromMatches(matches) {
      const toField = (token) => {
        switch (token) {
          case "S":
            return "millisecond";
          case "s":
            return "second";
          case "m":
            return "minute";
          case "h":
          case "H":
            return "hour";
          case "d":
            return "day";
          case "o":
            return "ordinal";
          case "L":
          case "M":
            return "month";
          case "y":
            return "year";
          case "E":
          case "c":
            return "weekday";
          case "W":
            return "weekNumber";
          case "k":
            return "weekYear";
          case "q":
            return "quarter";
          default:
            return null;
        }
      };
      let zone = null;
      let specificOffset;
      if (!isUndefined(matches.z)) {
        zone = IANAZone.create(matches.z);
      }
      if (!isUndefined(matches.Z)) {
        if (!zone) {
          zone = new FixedOffsetZone(matches.Z);
        }
        specificOffset = matches.Z;
      }
      if (!isUndefined(matches.q)) {
        matches.M = (matches.q - 1) * 3 + 1;
      }
      if (!isUndefined(matches.h)) {
        if (matches.h < 12 && matches.a === 1) {
          matches.h += 12;
        } else if (matches.h === 12 && matches.a === 0) {
          matches.h = 0;
        }
      }
      if (matches.G === 0 && matches.y) {
        matches.y = -matches.y;
      }
      if (!isUndefined(matches.u)) {
        matches.S = parseMillis(matches.u);
      }
      const vals = Object.keys(matches).reduce((r3, k3) => {
        const f3 = toField(k3);
        if (f3) {
          r3[f3] = matches[k3];
        }
        return r3;
      }, {});
      return [vals, zone, specificOffset];
    }
    var dummyDateTimeCache = null;
    function getDummyDateTime() {
      if (!dummyDateTimeCache) {
        dummyDateTimeCache = DateTime2.fromMillis(1555555555555);
      }
      return dummyDateTimeCache;
    }
    function maybeExpandMacroToken(token, locale) {
      if (token.literal) {
        return token;
      }
      const formatOpts = Formatter.macroTokenToFormatOpts(token.val);
      const tokens = formatOptsToTokens(formatOpts, locale);
      if (tokens == null || tokens.includes(void 0)) {
        return token;
      }
      return tokens;
    }
    function expandMacroTokens(tokens, locale) {
      return Array.prototype.concat(...tokens.map((t3) => maybeExpandMacroToken(t3, locale)));
    }
    function explainFromTokens(locale, input, format) {
      const tokens = expandMacroTokens(Formatter.parseFormat(format), locale), units = tokens.map((t3) => unitForToken(t3, locale)), disqualifyingUnit = units.find((t3) => t3.invalidReason);
      if (disqualifyingUnit) {
        return { input, tokens, invalidReason: disqualifyingUnit.invalidReason };
      } else {
        const [regexString, handlers] = buildRegex(units), regex = RegExp(regexString, "i"), [rawMatches, matches] = match(input, regex, handlers), [result, zone, specificOffset] = matches ? dateTimeFromMatches(matches) : [null, null, void 0];
        if (hasOwnProperty2(matches, "a") && hasOwnProperty2(matches, "H")) {
          throw new ConflictingSpecificationError(
            "Can't include meridiem when specifying 24-hour format"
          );
        }
        return { input, tokens, regex, rawMatches, matches, result, zone, specificOffset };
      }
    }
    function parseFromTokens(locale, input, format) {
      const { result, zone, specificOffset, invalidReason } = explainFromTokens(locale, input, format);
      return [result, zone, specificOffset, invalidReason];
    }
    function formatOptsToTokens(formatOpts, locale) {
      if (!formatOpts) {
        return null;
      }
      const formatter = Formatter.create(locale, formatOpts);
      const df = formatter.dtFormatter(getDummyDateTime());
      const parts = df.formatToParts();
      const resolvedOpts = df.resolvedOptions();
      return parts.map((p3) => tokenForPart(p3, formatOpts, resolvedOpts));
    }
    var nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
    var leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
    function unitOutOfRange(unit, value) {
      return new Invalid(
        "unit out of range",
        `you specified ${value} (of type ${typeof value}) as a ${unit}, which is invalid`
      );
    }
    function dayOfWeek(year, month, day) {
      const d2 = new Date(Date.UTC(year, month - 1, day));
      if (year < 100 && year >= 0) {
        d2.setUTCFullYear(d2.getUTCFullYear() - 1900);
      }
      const js = d2.getUTCDay();
      return js === 0 ? 7 : js;
    }
    function computeOrdinal(year, month, day) {
      return day + (isLeapYear2(year) ? leapLadder : nonLeapLadder)[month - 1];
    }
    function uncomputeOrdinal(year, ordinal) {
      const table = isLeapYear2(year) ? leapLadder : nonLeapLadder, month0 = table.findIndex((i3) => i3 < ordinal), day = ordinal - table[month0];
      return { month: month0 + 1, day };
    }
    function gregorianToWeek(gregObj) {
      const { year, month, day } = gregObj, ordinal = computeOrdinal(year, month, day), weekday = dayOfWeek(year, month, day);
      let weekNumber = Math.floor((ordinal - weekday + 10) / 7), weekYear;
      if (weekNumber < 1) {
        weekYear = year - 1;
        weekNumber = weeksInWeekYear(weekYear);
      } else if (weekNumber > weeksInWeekYear(year)) {
        weekYear = year + 1;
        weekNumber = 1;
      } else {
        weekYear = year;
      }
      return { weekYear, weekNumber, weekday, ...timeObject(gregObj) };
    }
    function weekToGregorian(weekData) {
      const { weekYear, weekNumber, weekday } = weekData, weekdayOfJan4 = dayOfWeek(weekYear, 1, 4), yearInDays = daysInYear(weekYear);
      let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 3, year;
      if (ordinal < 1) {
        year = weekYear - 1;
        ordinal += daysInYear(year);
      } else if (ordinal > yearInDays) {
        year = weekYear + 1;
        ordinal -= daysInYear(weekYear);
      } else {
        year = weekYear;
      }
      const { month, day } = uncomputeOrdinal(year, ordinal);
      return { year, month, day, ...timeObject(weekData) };
    }
    function gregorianToOrdinal(gregData) {
      const { year, month, day } = gregData;
      const ordinal = computeOrdinal(year, month, day);
      return { year, ordinal, ...timeObject(gregData) };
    }
    function ordinalToGregorian(ordinalData) {
      const { year, ordinal } = ordinalData;
      const { month, day } = uncomputeOrdinal(year, ordinal);
      return { year, month, day, ...timeObject(ordinalData) };
    }
    function hasInvalidWeekData(obj) {
      const validYear = isInteger(obj.weekYear), validWeek = integerBetween(obj.weekNumber, 1, weeksInWeekYear(obj.weekYear)), validWeekday = integerBetween(obj.weekday, 1, 7);
      if (!validYear) {
        return unitOutOfRange("weekYear", obj.weekYear);
      } else if (!validWeek) {
        return unitOutOfRange("week", obj.week);
      } else if (!validWeekday) {
        return unitOutOfRange("weekday", obj.weekday);
      } else
        return false;
    }
    function hasInvalidOrdinalData(obj) {
      const validYear = isInteger(obj.year), validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
      if (!validYear) {
        return unitOutOfRange("year", obj.year);
      } else if (!validOrdinal) {
        return unitOutOfRange("ordinal", obj.ordinal);
      } else
        return false;
    }
    function hasInvalidGregorianData(obj) {
      const validYear = isInteger(obj.year), validMonth = integerBetween(obj.month, 1, 12), validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
      if (!validYear) {
        return unitOutOfRange("year", obj.year);
      } else if (!validMonth) {
        return unitOutOfRange("month", obj.month);
      } else if (!validDay) {
        return unitOutOfRange("day", obj.day);
      } else
        return false;
    }
    function hasInvalidTimeData(obj) {
      const { hour, minute, second, millisecond } = obj;
      const validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0, validMinute = integerBetween(minute, 0, 59), validSecond = integerBetween(second, 0, 59), validMillisecond = integerBetween(millisecond, 0, 999);
      if (!validHour) {
        return unitOutOfRange("hour", hour);
      } else if (!validMinute) {
        return unitOutOfRange("minute", minute);
      } else if (!validSecond) {
        return unitOutOfRange("second", second);
      } else if (!validMillisecond) {
        return unitOutOfRange("millisecond", millisecond);
      } else
        return false;
    }
    var INVALID = "Invalid DateTime";
    var MAX_DATE = 864e13;
    function unsupportedZone(zone) {
      return new Invalid("unsupported zone", `the zone "${zone.name}" is not supported`);
    }
    function possiblyCachedWeekData(dt) {
      if (dt.weekData === null) {
        dt.weekData = gregorianToWeek(dt.c);
      }
      return dt.weekData;
    }
    function clone2(inst, alts) {
      const current = {
        ts: inst.ts,
        zone: inst.zone,
        c: inst.c,
        o: inst.o,
        loc: inst.loc,
        invalid: inst.invalid
      };
      return new DateTime2({ ...current, ...alts, old: current });
    }
    function fixOffset(localTS, o2, tz) {
      let utcGuess = localTS - o2 * 60 * 1e3;
      const o22 = tz.offset(utcGuess);
      if (o2 === o22) {
        return [utcGuess, o2];
      }
      utcGuess -= (o22 - o2) * 60 * 1e3;
      const o3 = tz.offset(utcGuess);
      if (o22 === o3) {
        return [utcGuess, o22];
      }
      return [localTS - Math.min(o22, o3) * 60 * 1e3, Math.max(o22, o3)];
    }
    function tsToObj(ts, offset2) {
      ts += offset2 * 60 * 1e3;
      const d2 = new Date(ts);
      return {
        year: d2.getUTCFullYear(),
        month: d2.getUTCMonth() + 1,
        day: d2.getUTCDate(),
        hour: d2.getUTCHours(),
        minute: d2.getUTCMinutes(),
        second: d2.getUTCSeconds(),
        millisecond: d2.getUTCMilliseconds()
      };
    }
    function objToTS(obj, offset2, zone) {
      return fixOffset(objToLocalTS(obj), offset2, zone);
    }
    function adjustTime(inst, dur) {
      const oPre = inst.o, year = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c3 = {
        ...inst.c,
        year,
        month,
        day: Math.min(inst.c.day, daysInMonth(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
      }, millisToAdd = Duration.fromObject({
        years: dur.years - Math.trunc(dur.years),
        quarters: dur.quarters - Math.trunc(dur.quarters),
        months: dur.months - Math.trunc(dur.months),
        weeks: dur.weeks - Math.trunc(dur.weeks),
        days: dur.days - Math.trunc(dur.days),
        hours: dur.hours,
        minutes: dur.minutes,
        seconds: dur.seconds,
        milliseconds: dur.milliseconds
      }).as("milliseconds"), localTS = objToLocalTS(c3);
      let [ts, o2] = fixOffset(localTS, oPre, inst.zone);
      if (millisToAdd !== 0) {
        ts += millisToAdd;
        o2 = inst.zone.offset(ts);
      }
      return { ts, o: o2 };
    }
    function parseDataToDateTime(parsed, parsedZone, opts, format, text, specificOffset) {
      const { setZone, zone } = opts;
      if (parsed && Object.keys(parsed).length !== 0 || parsedZone) {
        const interpretationZone = parsedZone || zone, inst = DateTime2.fromObject(parsed, {
          ...opts,
          zone: interpretationZone,
          specificOffset
        });
        return setZone ? inst : inst.setZone(zone);
      } else {
        return DateTime2.invalid(
          new Invalid("unparsable", `the input "${text}" can't be parsed as ${format}`)
        );
      }
    }
    function toTechFormat(dt, format, allowZ = true) {
      return dt.isValid ? Formatter.create(Locale.create("en-US"), {
        allowZ,
        forceSimple: true
      }).formatDateTimeFromString(dt, format) : null;
    }
    function toISODate(o2, extended) {
      const longFormat = o2.c.year > 9999 || o2.c.year < 0;
      let c3 = "";
      if (longFormat && o2.c.year >= 0)
        c3 += "+";
      c3 += padStart3(o2.c.year, longFormat ? 6 : 4);
      if (extended) {
        c3 += "-";
        c3 += padStart3(o2.c.month);
        c3 += "-";
        c3 += padStart3(o2.c.day);
      } else {
        c3 += padStart3(o2.c.month);
        c3 += padStart3(o2.c.day);
      }
      return c3;
    }
    function toISOTime(o2, extended, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone) {
      let c3 = padStart3(o2.c.hour);
      if (extended) {
        c3 += ":";
        c3 += padStart3(o2.c.minute);
        if (o2.c.millisecond !== 0 || o2.c.second !== 0 || !suppressSeconds) {
          c3 += ":";
        }
      } else {
        c3 += padStart3(o2.c.minute);
      }
      if (o2.c.millisecond !== 0 || o2.c.second !== 0 || !suppressSeconds) {
        c3 += padStart3(o2.c.second);
        if (o2.c.millisecond !== 0 || !suppressMilliseconds) {
          c3 += ".";
          c3 += padStart3(o2.c.millisecond, 3);
        }
      }
      if (includeOffset) {
        if (o2.isOffsetFixed && o2.offset === 0 && !extendedZone) {
          c3 += "Z";
        } else if (o2.o < 0) {
          c3 += "-";
          c3 += padStart3(Math.trunc(-o2.o / 60));
          c3 += ":";
          c3 += padStart3(Math.trunc(-o2.o % 60));
        } else {
          c3 += "+";
          c3 += padStart3(Math.trunc(o2.o / 60));
          c3 += ":";
          c3 += padStart3(Math.trunc(o2.o % 60));
        }
      }
      if (extendedZone) {
        c3 += "[" + o2.zone.ianaName + "]";
      }
      return c3;
    }
    var defaultUnitValues = {
      month: 1,
      day: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    };
    var defaultWeekUnitValues = {
      weekNumber: 1,
      weekday: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    };
    var defaultOrdinalUnitValues = {
      ordinal: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    };
    var orderedUnits = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
    var orderedWeekUnits = [
      "weekYear",
      "weekNumber",
      "weekday",
      "hour",
      "minute",
      "second",
      "millisecond"
    ];
    var orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
    function normalizeUnit(unit) {
      const normalized = {
        year: "year",
        years: "year",
        month: "month",
        months: "month",
        day: "day",
        days: "day",
        hour: "hour",
        hours: "hour",
        minute: "minute",
        minutes: "minute",
        quarter: "quarter",
        quarters: "quarter",
        second: "second",
        seconds: "second",
        millisecond: "millisecond",
        milliseconds: "millisecond",
        weekday: "weekday",
        weekdays: "weekday",
        weeknumber: "weekNumber",
        weeksnumber: "weekNumber",
        weeknumbers: "weekNumber",
        weekyear: "weekYear",
        weekyears: "weekYear",
        ordinal: "ordinal"
      }[unit.toLowerCase()];
      if (!normalized)
        throw new InvalidUnitError(unit);
      return normalized;
    }
    function quickDT(obj, opts) {
      const zone = normalizeZone(opts.zone, Settings.defaultZone), loc = Locale.fromObject(opts), tsNow = Settings.now();
      let ts, o2;
      if (!isUndefined(obj.year)) {
        for (const u3 of orderedUnits) {
          if (isUndefined(obj[u3])) {
            obj[u3] = defaultUnitValues[u3];
          }
        }
        const invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
        if (invalid) {
          return DateTime2.invalid(invalid);
        }
        const offsetProvis = zone.offset(tsNow);
        [ts, o2] = objToTS(obj, offsetProvis, zone);
      } else {
        ts = tsNow;
      }
      return new DateTime2({ ts, zone, loc, o: o2 });
    }
    function diffRelative(start, end, opts) {
      const round = isUndefined(opts.round) ? true : opts.round, format = (c3, unit) => {
        c3 = roundTo(c3, round || opts.calendary ? 0 : 2, true);
        const formatter = end.loc.clone(opts).relFormatter(opts);
        return formatter.format(c3, unit);
      }, differ = (unit) => {
        if (opts.calendary) {
          if (!end.hasSame(start, unit)) {
            return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);
          } else
            return 0;
        } else {
          return end.diff(start, unit).get(unit);
        }
      };
      if (opts.unit) {
        return format(differ(opts.unit), opts.unit);
      }
      for (const unit of opts.units) {
        const count = differ(unit);
        if (Math.abs(count) >= 1) {
          return format(count, unit);
        }
      }
      return format(start > end ? -0 : 0, opts.units[opts.units.length - 1]);
    }
    function lastOpts(argList) {
      let opts = {}, args;
      if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
        opts = argList[argList.length - 1];
        args = Array.from(argList).slice(0, argList.length - 1);
      } else {
        args = Array.from(argList);
      }
      return [opts, args];
    }
    var DateTime2 = class {
      /**
       * @access private
       */
      constructor(config2) {
        const zone = config2.zone || Settings.defaultZone;
        let invalid = config2.invalid || (Number.isNaN(config2.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
        this.ts = isUndefined(config2.ts) ? Settings.now() : config2.ts;
        let c3 = null, o2 = null;
        if (!invalid) {
          const unchanged = config2.old && config2.old.ts === this.ts && config2.old.zone.equals(zone);
          if (unchanged) {
            [c3, o2] = [config2.old.c, config2.old.o];
          } else {
            const ot = zone.offset(this.ts);
            c3 = tsToObj(this.ts, ot);
            invalid = Number.isNaN(c3.year) ? new Invalid("invalid input") : null;
            c3 = invalid ? null : c3;
            o2 = invalid ? null : ot;
          }
        }
        this._zone = zone;
        this.loc = config2.loc || Locale.create();
        this.invalid = invalid;
        this.weekData = null;
        this.c = c3;
        this.o = o2;
        this.isLuxonDateTime = true;
      }
      // CONSTRUCT
      /**
       * Create a DateTime for the current instant, in the system's time zone.
       *
       * Use Settings to override these default values if needed.
       * @example DateTime.now().toISO() //~> now in the ISO format
       * @return {DateTime}
       */
      static now() {
        return new DateTime2({});
      }
      /**
       * Create a local DateTime
       * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
       * @param {number} [month=1] - The month, 1-indexed
       * @param {number} [day=1] - The day of the month, 1-indexed
       * @param {number} [hour=0] - The hour of the day, in 24-hour time
       * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
       * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
       * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
       * @example DateTime.local()                                  //~> now
       * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
       * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
       * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
       * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
       * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
       * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
       * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
       * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
       * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
       * @return {DateTime}
       */
      static local() {
        const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
        return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
      }
      /**
       * Create a DateTime in UTC
       * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
       * @param {number} [month=1] - The month, 1-indexed
       * @param {number} [day=1] - The day of the month
       * @param {number} [hour=0] - The hour of the day, in 24-hour time
       * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
       * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
       * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
       * @param {Object} options - configuration options for the DateTime
       * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
       * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
       * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
       * @example DateTime.utc()                                              //~> now
       * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
       * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
       * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
       * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
       * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
       * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
       * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
       * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
       * @return {DateTime}
       */
      static utc() {
        const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
        opts.zone = FixedOffsetZone.utcInstance;
        return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
      }
      /**
       * Create a DateTime from a JavaScript Date object. Uses the default zone.
       * @param {Date} date - a JavaScript Date object
       * @param {Object} options - configuration options for the DateTime
       * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
       * @return {DateTime}
       */
      static fromJSDate(date, options = {}) {
        const ts = isDate2(date) ? date.valueOf() : NaN;
        if (Number.isNaN(ts)) {
          return DateTime2.invalid("invalid input");
        }
        const zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
        if (!zoneToUse.isValid) {
          return DateTime2.invalid(unsupportedZone(zoneToUse));
        }
        return new DateTime2({
          ts,
          zone: zoneToUse,
          loc: Locale.fromObject(options)
        });
      }
      /**
       * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
       * @param {number} milliseconds - a number of milliseconds since 1970 UTC
       * @param {Object} options - configuration options for the DateTime
       * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
       * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
       * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @return {DateTime}
       */
      static fromMillis(milliseconds, options = {}) {
        if (!isNumber2(milliseconds)) {
          throw new InvalidArgumentError(
            `fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`
          );
        } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
          return DateTime2.invalid("Timestamp out of range");
        } else {
          return new DateTime2({
            ts: milliseconds,
            zone: normalizeZone(options.zone, Settings.defaultZone),
            loc: Locale.fromObject(options)
          });
        }
      }
      /**
       * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
       * @param {number} seconds - a number of seconds since 1970 UTC
       * @param {Object} options - configuration options for the DateTime
       * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
       * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
       * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @return {DateTime}
       */
      static fromSeconds(seconds, options = {}) {
        if (!isNumber2(seconds)) {
          throw new InvalidArgumentError("fromSeconds requires a numerical input");
        } else {
          return new DateTime2({
            ts: seconds * 1e3,
            zone: normalizeZone(options.zone, Settings.defaultZone),
            loc: Locale.fromObject(options)
          });
        }
      }
      /**
       * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
       * @param {Object} obj - the object to create the DateTime from
       * @param {number} obj.year - a year, such as 1987
       * @param {number} obj.month - a month, 1-12
       * @param {number} obj.day - a day of the month, 1-31, depending on the month
       * @param {number} obj.ordinal - day of the year, 1-365 or 366
       * @param {number} obj.weekYear - an ISO week year
       * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
       * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
       * @param {number} obj.hour - hour of the day, 0-23
       * @param {number} obj.minute - minute of the hour, 0-59
       * @param {number} obj.second - second of the minute, 0-59
       * @param {number} obj.millisecond - millisecond of the second, 0-999
       * @param {Object} opts - options for creating this DateTime
       * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
       * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
       * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
       * @return {DateTime}
       */
      static fromObject(obj, opts = {}) {
        obj = obj || {};
        const zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
        if (!zoneToUse.isValid) {
          return DateTime2.invalid(unsupportedZone(zoneToUse));
        }
        const tsNow = Settings.now(), offsetProvis = !isUndefined(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow), normalized = normalizeObject(obj, normalizeUnit), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber, loc = Locale.fromObject(opts);
        if ((containsGregor || containsOrdinal) && definiteWeekDef) {
          throw new ConflictingSpecificationError(
            "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
          );
        }
        if (containsGregorMD && containsOrdinal) {
          throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
        }
        const useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
        let units, defaultValues, objNow = tsToObj(tsNow, offsetProvis);
        if (useWeekData) {
          units = orderedWeekUnits;
          defaultValues = defaultWeekUnitValues;
          objNow = gregorianToWeek(objNow);
        } else if (containsOrdinal) {
          units = orderedOrdinalUnits;
          defaultValues = defaultOrdinalUnitValues;
          objNow = gregorianToOrdinal(objNow);
        } else {
          units = orderedUnits;
          defaultValues = defaultUnitValues;
        }
        let foundFirst = false;
        for (const u3 of units) {
          const v3 = normalized[u3];
          if (!isUndefined(v3)) {
            foundFirst = true;
          } else if (foundFirst) {
            normalized[u3] = defaultValues[u3];
          } else {
            normalized[u3] = objNow[u3];
          }
        }
        const higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized), invalid = higherOrderInvalid || hasInvalidTimeData(normalized);
        if (invalid) {
          return DateTime2.invalid(invalid);
        }
        const gregorian = useWeekData ? weekToGregorian(normalized) : containsOrdinal ? ordinalToGregorian(normalized) : normalized, [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse), inst = new DateTime2({
          ts: tsFinal,
          zone: zoneToUse,
          o: offsetFinal,
          loc
        });
        if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
          return DateTime2.invalid(
            "mismatched weekday",
            `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`
          );
        }
        return inst;
      }
      /**
       * Create a DateTime from an ISO 8601 string
       * @param {string} text - the ISO string
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
       * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
       * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
       * @example DateTime.fromISO('2016-05-25T09:08:34.123')
       * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
       * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
       * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
       * @example DateTime.fromISO('2016-W05-4')
       * @return {DateTime}
       */
      static fromISO(text, opts = {}) {
        const [vals, parsedZone] = parseISODate(text);
        return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text);
      }
      /**
       * Create a DateTime from an RFC 2822 string
       * @param {string} text - the RFC 2822 string
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
       * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
       * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
       * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
       * @return {DateTime}
       */
      static fromRFC2822(text, opts = {}) {
        const [vals, parsedZone] = parseRFC2822Date(text);
        return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text);
      }
      /**
       * Create a DateTime from an HTTP header date
       * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
       * @param {string} text - the HTTP header date
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
       * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
       * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
       * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
       * @return {DateTime}
       */
      static fromHTTP(text, opts = {}) {
        const [vals, parsedZone] = parseHTTPDate(text);
        return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
      }
      /**
       * Create a DateTime from an input string and format string.
       * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
       * @param {string} text - the string to parse
       * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
       * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
       * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @return {DateTime}
       */
      static fromFormat(text, fmt, opts = {}) {
        if (isUndefined(text) || isUndefined(fmt)) {
          throw new InvalidArgumentError("fromFormat requires an input string and a format");
        }
        const { locale = null, numberingSystem = null } = opts, localeToUse = Locale.fromOpts({
          locale,
          numberingSystem,
          defaultToEN: true
        }), [vals, parsedZone, specificOffset, invalid] = parseFromTokens(localeToUse, text, fmt);
        if (invalid) {
          return DateTime2.invalid(invalid);
        } else {
          return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text, specificOffset);
        }
      }
      /**
       * @deprecated use fromFormat instead
       */
      static fromString(text, fmt, opts = {}) {
        return DateTime2.fromFormat(text, fmt, opts);
      }
      /**
       * Create a DateTime from a SQL date, time, or datetime
       * Defaults to en-US if no locale has been specified, regardless of the system's locale
       * @param {string} text - the string to parse
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
       * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
       * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @example DateTime.fromSQL('2017-05-15')
       * @example DateTime.fromSQL('2017-05-15 09:12:34')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
       * @example DateTime.fromSQL('09:12:34.342')
       * @return {DateTime}
       */
      static fromSQL(text, opts = {}) {
        const [vals, parsedZone] = parseSQL(text);
        return parseDataToDateTime(vals, parsedZone, opts, "SQL", text);
      }
      /**
       * Create an invalid DateTime.
       * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent.
       * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
       * @return {DateTime}
       */
      static invalid(reason, explanation = null) {
        if (!reason) {
          throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
        }
        const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
        if (Settings.throwOnInvalid) {
          throw new InvalidDateTimeError(invalid);
        } else {
          return new DateTime2({ invalid });
        }
      }
      /**
       * Check if an object is an instance of DateTime. Works across context boundaries
       * @param {object} o
       * @return {boolean}
       */
      static isDateTime(o2) {
        return o2 && o2.isLuxonDateTime || false;
      }
      /**
       * Produce the format string for a set of options
       * @param formatOpts
       * @param localeOpts
       * @returns {string}
       */
      static parseFormatForOpts(formatOpts, localeOpts = {}) {
        const tokenList = formatOptsToTokens(formatOpts, Locale.fromObject(localeOpts));
        return !tokenList ? null : tokenList.map((t3) => t3 ? t3.val : null).join("");
      }
      /**
       * Produce the the fully expanded format token for the locale
       * Does NOT quote characters, so quoted tokens will not round trip correctly
       * @param fmt
       * @param localeOpts
       * @returns {string}
       */
      static expandFormat(fmt, localeOpts = {}) {
        const expanded = expandMacroTokens(Formatter.parseFormat(fmt), Locale.fromObject(localeOpts));
        return expanded.map((t3) => t3.val).join("");
      }
      // INFO
      /**
       * Get the value of unit.
       * @param {string} unit - a unit such as 'minute' or 'day'
       * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
       * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
       * @return {number}
       */
      get(unit) {
        return this[unit];
      }
      /**
       * Returns whether the DateTime is valid. Invalid DateTimes occur when:
       * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
       * * The DateTime was created by an operation on another invalid date
       * @type {boolean}
       */
      get isValid() {
        return this.invalid === null;
      }
      /**
       * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
       * @type {string}
       */
      get invalidReason() {
        return this.invalid ? this.invalid.reason : null;
      }
      /**
       * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
       * @type {string}
       */
      get invalidExplanation() {
        return this.invalid ? this.invalid.explanation : null;
      }
      /**
       * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
       *
       * @type {string}
       */
      get locale() {
        return this.isValid ? this.loc.locale : null;
      }
      /**
       * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
       *
       * @type {string}
       */
      get numberingSystem() {
        return this.isValid ? this.loc.numberingSystem : null;
      }
      /**
       * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
       *
       * @type {string}
       */
      get outputCalendar() {
        return this.isValid ? this.loc.outputCalendar : null;
      }
      /**
       * Get the time zone associated with this DateTime.
       * @type {Zone}
       */
      get zone() {
        return this._zone;
      }
      /**
       * Get the name of the time zone.
       * @type {string}
       */
      get zoneName() {
        return this.isValid ? this.zone.name : null;
      }
      /**
       * Get the year
       * @example DateTime.local(2017, 5, 25).year //=> 2017
       * @type {number}
       */
      get year() {
        return this.isValid ? this.c.year : NaN;
      }
      /**
       * Get the quarter
       * @example DateTime.local(2017, 5, 25).quarter //=> 2
       * @type {number}
       */
      get quarter() {
        return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
      }
      /**
       * Get the month (1-12).
       * @example DateTime.local(2017, 5, 25).month //=> 5
       * @type {number}
       */
      get month() {
        return this.isValid ? this.c.month : NaN;
      }
      /**
       * Get the day of the month (1-30ish).
       * @example DateTime.local(2017, 5, 25).day //=> 25
       * @type {number}
       */
      get day() {
        return this.isValid ? this.c.day : NaN;
      }
      /**
       * Get the hour of the day (0-23).
       * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
       * @type {number}
       */
      get hour() {
        return this.isValid ? this.c.hour : NaN;
      }
      /**
       * Get the minute of the hour (0-59).
       * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
       * @type {number}
       */
      get minute() {
        return this.isValid ? this.c.minute : NaN;
      }
      /**
       * Get the second of the minute (0-59).
       * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
       * @type {number}
       */
      get second() {
        return this.isValid ? this.c.second : NaN;
      }
      /**
       * Get the millisecond of the second (0-999).
       * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
       * @type {number}
       */
      get millisecond() {
        return this.isValid ? this.c.millisecond : NaN;
      }
      /**
       * Get the week year
       * @see https://en.wikipedia.org/wiki/ISO_week_date
       * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
       * @type {number}
       */
      get weekYear() {
        return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
      }
      /**
       * Get the week number of the week year (1-52ish).
       * @see https://en.wikipedia.org/wiki/ISO_week_date
       * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
       * @type {number}
       */
      get weekNumber() {
        return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
      }
      /**
       * Get the day of the week.
       * 1 is Monday and 7 is Sunday
       * @see https://en.wikipedia.org/wiki/ISO_week_date
       * @example DateTime.local(2014, 11, 31).weekday //=> 4
       * @type {number}
       */
      get weekday() {
        return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
      }
      /**
       * Get the ordinal (meaning the day of the year)
       * @example DateTime.local(2017, 5, 25).ordinal //=> 145
       * @type {number|DateTime}
       */
      get ordinal() {
        return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
      }
      /**
       * Get the human readable short month name, such as 'Oct'.
       * Defaults to the system's locale if no locale has been specified
       * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
       * @type {string}
       */
      get monthShort() {
        return this.isValid ? Info.months("short", { locObj: this.loc })[this.month - 1] : null;
      }
      /**
       * Get the human readable long month name, such as 'October'.
       * Defaults to the system's locale if no locale has been specified
       * @example DateTime.local(2017, 10, 30).monthLong //=> October
       * @type {string}
       */
      get monthLong() {
        return this.isValid ? Info.months("long", { locObj: this.loc })[this.month - 1] : null;
      }
      /**
       * Get the human readable short weekday, such as 'Mon'.
       * Defaults to the system's locale if no locale has been specified
       * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
       * @type {string}
       */
      get weekdayShort() {
        return this.isValid ? Info.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
      }
      /**
       * Get the human readable long weekday, such as 'Monday'.
       * Defaults to the system's locale if no locale has been specified
       * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
       * @type {string}
       */
      get weekdayLong() {
        return this.isValid ? Info.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
      }
      /**
       * Get the UTC offset of this DateTime in minutes
       * @example DateTime.now().offset //=> -240
       * @example DateTime.utc().offset //=> 0
       * @type {number}
       */
      get offset() {
        return this.isValid ? +this.o : NaN;
      }
      /**
       * Get the short human name for the zone's current offset, for example "EST" or "EDT".
       * Defaults to the system's locale if no locale has been specified
       * @type {string}
       */
      get offsetNameShort() {
        if (this.isValid) {
          return this.zone.offsetName(this.ts, {
            format: "short",
            locale: this.locale
          });
        } else {
          return null;
        }
      }
      /**
       * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
       * Defaults to the system's locale if no locale has been specified
       * @type {string}
       */
      get offsetNameLong() {
        if (this.isValid) {
          return this.zone.offsetName(this.ts, {
            format: "long",
            locale: this.locale
          });
        } else {
          return null;
        }
      }
      /**
       * Get whether this zone's offset ever changes, as in a DST.
       * @type {boolean}
       */
      get isOffsetFixed() {
        return this.isValid ? this.zone.isUniversal : null;
      }
      /**
       * Get whether the DateTime is in a DST.
       * @type {boolean}
       */
      get isInDST() {
        if (this.isOffsetFixed) {
          return false;
        } else {
          return this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
        }
      }
      /**
       * Get those DateTimes which have the same local time as this DateTime, but a different offset from UTC
       * in this DateTime's zone. During DST changes local time can be ambiguous, for example
       * `2023-10-29T02:30:00` in `Europe/Berlin` can have offset `+01:00` or `+02:00`.
       * This method will return both possible DateTimes if this DateTime's local time is ambiguous.
       * @returns {DateTime[]}
       */
      getPossibleOffsets() {
        if (!this.isValid || this.isOffsetFixed) {
          return [this];
        }
        const dayMs = 864e5;
        const minuteMs = 6e4;
        const localTS = objToLocalTS(this.c);
        const oEarlier = this.zone.offset(localTS - dayMs);
        const oLater = this.zone.offset(localTS + dayMs);
        const o1 = this.zone.offset(localTS - oEarlier * minuteMs);
        const o2 = this.zone.offset(localTS - oLater * minuteMs);
        if (o1 === o2) {
          return [this];
        }
        const ts1 = localTS - o1 * minuteMs;
        const ts2 = localTS - o2 * minuteMs;
        const c1 = tsToObj(ts1, o1);
        const c22 = tsToObj(ts2, o2);
        if (c1.hour === c22.hour && c1.minute === c22.minute && c1.second === c22.second && c1.millisecond === c22.millisecond) {
          return [clone2(this, { ts: ts1 }), clone2(this, { ts: ts2 })];
        }
        return [this];
      }
      /**
       * Returns true if this DateTime is in a leap year, false otherwise
       * @example DateTime.local(2016).isInLeapYear //=> true
       * @example DateTime.local(2013).isInLeapYear //=> false
       * @type {boolean}
       */
      get isInLeapYear() {
        return isLeapYear2(this.year);
      }
      /**
       * Returns the number of days in this DateTime's month
       * @example DateTime.local(2016, 2).daysInMonth //=> 29
       * @example DateTime.local(2016, 3).daysInMonth //=> 31
       * @type {number}
       */
      get daysInMonth() {
        return daysInMonth(this.year, this.month);
      }
      /**
       * Returns the number of days in this DateTime's year
       * @example DateTime.local(2016).daysInYear //=> 366
       * @example DateTime.local(2013).daysInYear //=> 365
       * @type {number}
       */
      get daysInYear() {
        return this.isValid ? daysInYear(this.year) : NaN;
      }
      /**
       * Returns the number of weeks in this DateTime's year
       * @see https://en.wikipedia.org/wiki/ISO_week_date
       * @example DateTime.local(2004).weeksInWeekYear //=> 53
       * @example DateTime.local(2013).weeksInWeekYear //=> 52
       * @type {number}
       */
      get weeksInWeekYear() {
        return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
      }
      /**
       * Returns the resolved Intl options for this DateTime.
       * This is useful in understanding the behavior of formatting methods
       * @param {Object} opts - the same options as toLocaleString
       * @return {Object}
       */
      resolvedLocaleOptions(opts = {}) {
        const { locale, numberingSystem, calendar } = Formatter.create(
          this.loc.clone(opts),
          opts
        ).resolvedOptions(this);
        return { locale, numberingSystem, outputCalendar: calendar };
      }
      // TRANSFORM
      /**
       * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
       *
       * Equivalent to {@link DateTime#setZone}('utc')
       * @param {number} [offset=0] - optionally, an offset from UTC in minutes
       * @param {Object} [opts={}] - options to pass to `setZone()`
       * @return {DateTime}
       */
      toUTC(offset2 = 0, opts = {}) {
        return this.setZone(FixedOffsetZone.instance(offset2), opts);
      }
      /**
       * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
       *
       * Equivalent to `setZone('local')`
       * @return {DateTime}
       */
      toLocal() {
        return this.setZone(Settings.defaultZone);
      }
      /**
       * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
       *
       * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
       * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
       * @param {Object} opts - options
       * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
       * @return {DateTime}
       */
      setZone(zone, { keepLocalTime = false, keepCalendarTime = false } = {}) {
        zone = normalizeZone(zone, Settings.defaultZone);
        if (zone.equals(this.zone)) {
          return this;
        } else if (!zone.isValid) {
          return DateTime2.invalid(unsupportedZone(zone));
        } else {
          let newTS = this.ts;
          if (keepLocalTime || keepCalendarTime) {
            const offsetGuess = zone.offset(this.ts);
            const asObj = this.toObject();
            [newTS] = objToTS(asObj, offsetGuess, zone);
          }
          return clone2(this, { ts: newTS, zone });
        }
      }
      /**
       * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
       * @param {Object} properties - the properties to set
       * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
       * @return {DateTime}
       */
      reconfigure({ locale, numberingSystem, outputCalendar } = {}) {
        const loc = this.loc.clone({ locale, numberingSystem, outputCalendar });
        return clone2(this, { loc });
      }
      /**
       * "Set" the locale. Returns a newly-constructed DateTime.
       * Just a convenient alias for reconfigure({ locale })
       * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
       * @return {DateTime}
       */
      setLocale(locale) {
        return this.reconfigure({ locale });
      }
      /**
       * "Set" the values of specified units. Returns a newly-constructed DateTime.
       * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
       * @param {Object} values - a mapping of units to numbers
       * @example dt.set({ year: 2017 })
       * @example dt.set({ hour: 8, minute: 30 })
       * @example dt.set({ weekday: 5 })
       * @example dt.set({ year: 2005, ordinal: 234 })
       * @return {DateTime}
       */
      set(values) {
        if (!this.isValid)
          return this;
        const normalized = normalizeObject(values, normalizeUnit), settingWeekStuff = !isUndefined(normalized.weekYear) || !isUndefined(normalized.weekNumber) || !isUndefined(normalized.weekday), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
        if ((containsGregor || containsOrdinal) && definiteWeekDef) {
          throw new ConflictingSpecificationError(
            "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
          );
        }
        if (containsGregorMD && containsOrdinal) {
          throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
        }
        let mixed;
        if (settingWeekStuff) {
          mixed = weekToGregorian({ ...gregorianToWeek(this.c), ...normalized });
        } else if (!isUndefined(normalized.ordinal)) {
          mixed = ordinalToGregorian({ ...gregorianToOrdinal(this.c), ...normalized });
        } else {
          mixed = { ...this.toObject(), ...normalized };
          if (isUndefined(normalized.day)) {
            mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
          }
        }
        const [ts, o2] = objToTS(mixed, this.o, this.zone);
        return clone2(this, { ts, o: o2 });
      }
      /**
       * Add a period of time to this DateTime and return the resulting DateTime
       *
       * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
       * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       * @example DateTime.now().plus(123) //~> in 123 milliseconds
       * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
       * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
       * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
       * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
       * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
       * @return {DateTime}
       */
      plus(duration) {
        if (!this.isValid)
          return this;
        const dur = Duration.fromDurationLike(duration);
        return clone2(this, adjustTime(this, dur));
      }
      /**
       * Subtract a period of time to this DateTime and return the resulting DateTime
       * See {@link DateTime#plus}
       * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       @return {DateTime}
       */
      minus(duration) {
        if (!this.isValid)
          return this;
        const dur = Duration.fromDurationLike(duration).negate();
        return clone2(this, adjustTime(this, dur));
      }
      /**
       * "Set" this DateTime to the beginning of a unit of time.
       * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
       * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
       * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
       * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
       * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
       * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
       * @return {DateTime}
       */
      startOf(unit) {
        if (!this.isValid)
          return this;
        const o2 = {}, normalizedUnit = Duration.normalizeUnit(unit);
        switch (normalizedUnit) {
          case "years":
            o2.month = 1;
          case "quarters":
          case "months":
            o2.day = 1;
          case "weeks":
          case "days":
            o2.hour = 0;
          case "hours":
            o2.minute = 0;
          case "minutes":
            o2.second = 0;
          case "seconds":
            o2.millisecond = 0;
            break;
        }
        if (normalizedUnit === "weeks") {
          o2.weekday = 1;
        }
        if (normalizedUnit === "quarters") {
          const q3 = Math.ceil(this.month / 3);
          o2.month = (q3 - 1) * 3 + 1;
        }
        return this.set(o2);
      }
      /**
       * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
       * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
       * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
       * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
       * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
       * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
       * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
       * @return {DateTime}
       */
      endOf(unit) {
        return this.isValid ? this.plus({ [unit]: 1 }).startOf(unit).minus(1) : this;
      }
      // OUTPUT
      /**
       * Returns a string representation of this DateTime formatted according to the specified format string.
       * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
       * Defaults to en-US if no locale has been specified, regardless of the system's locale.
       * @param {string} fmt - the format string
       * @param {Object} opts - opts to override the configuration options on this DateTime
       * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
       * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
       * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
       * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
       * @return {string}
       */
      toFormat(fmt, opts = {}) {
        return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID;
      }
      /**
       * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
       * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
       * of the DateTime in the assigned locale.
       * Defaults to the system's locale if no locale has been specified
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
       * @param {Object} opts - opts to override the configuration options on this DateTime
       * @example DateTime.now().toLocaleString(); //=> 4/20/2017
       * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
       * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
       * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 aot 2022'
       * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
       * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
       * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
       * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
       * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
       * @return {string}
       */
      toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
        return this.isValid ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID;
      }
      /**
       * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
       * Defaults to the system's locale if no locale has been specified
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
       * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
       * @example DateTime.now().toLocaleParts(); //=> [
       *                                   //=>   { type: 'day', value: '25' },
       *                                   //=>   { type: 'literal', value: '/' },
       *                                   //=>   { type: 'month', value: '05' },
       *                                   //=>   { type: 'literal', value: '/' },
       *                                   //=>   { type: 'year', value: '1982' }
       *                                   //=> ]
       */
      toLocaleParts(opts = {}) {
        return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime
       * @param {Object} opts - options
       * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
       * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @param {boolean} [opts.extendedZone=false] - add the time zone format extension
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
       * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
       * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
       * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
       * @return {string}
       */
      toISO({
        format = "extended",
        suppressSeconds = false,
        suppressMilliseconds = false,
        includeOffset = true,
        extendedZone = false
      } = {}) {
        if (!this.isValid) {
          return null;
        }
        const ext = format === "extended";
        let c3 = toISODate(this, ext);
        c3 += "T";
        c3 += toISOTime(this, ext, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
        return c3;
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime's date component
       * @param {Object} opts - options
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
       * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
       * @return {string}
       */
      toISODate({ format = "extended" } = {}) {
        if (!this.isValid) {
          return null;
        }
        return toISODate(this, format === "extended");
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime's week date
       * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
       * @return {string}
       */
      toISOWeekDate() {
        return toTechFormat(this, "kkkk-'W'WW-c");
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime's time component
       * @param {Object} opts - options
       * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
       * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
       * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
       * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
       * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
       * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
       * @return {string}
       */
      toISOTime({
        suppressMilliseconds = false,
        suppressSeconds = false,
        includeOffset = true,
        includePrefix = false,
        extendedZone = false,
        format = "extended"
      } = {}) {
        if (!this.isValid) {
          return null;
        }
        let c3 = includePrefix ? "T" : "";
        return c3 + toISOTime(
          this,
          format === "extended",
          suppressSeconds,
          suppressMilliseconds,
          includeOffset,
          extendedZone
        );
      }
      /**
       * Returns an RFC 2822-compatible string representation of this DateTime
       * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
       * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
       * @return {string}
       */
      toRFC2822() {
        return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
       * Specifically, the string conforms to RFC 1123.
       * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
       * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
       * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
       * @return {string}
       */
      toHTTP() {
        return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in SQL Date
       * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
       * @return {string}
       */
      toSQLDate() {
        if (!this.isValid) {
          return null;
        }
        return toISODate(this, true);
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in SQL Time
       * @param {Object} opts - options
       * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
       * @example DateTime.utc().toSQL() //=> '05:15:16.345'
       * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
       * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
       * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
       * @return {string}
       */
      toSQLTime({ includeOffset = true, includeZone = false, includeOffsetSpace = true } = {}) {
        let fmt = "HH:mm:ss.SSS";
        if (includeZone || includeOffset) {
          if (includeOffsetSpace) {
            fmt += " ";
          }
          if (includeZone) {
            fmt += "z";
          } else if (includeOffset) {
            fmt += "ZZ";
          }
        }
        return toTechFormat(this, fmt, true);
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in SQL DateTime
       * @param {Object} opts - options
       * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
       * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
       * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
       * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
       * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
       * @return {string}
       */
      toSQL(opts = {}) {
        if (!this.isValid) {
          return null;
        }
        return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
      }
      /**
       * Returns a string representation of this DateTime appropriate for debugging
       * @return {string}
       */
      toString() {
        return this.isValid ? this.toISO() : INVALID;
      }
      /**
       * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
       * @return {number}
       */
      valueOf() {
        return this.toMillis();
      }
      /**
       * Returns the epoch milliseconds of this DateTime.
       * @return {number}
       */
      toMillis() {
        return this.isValid ? this.ts : NaN;
      }
      /**
       * Returns the epoch seconds of this DateTime.
       * @return {number}
       */
      toSeconds() {
        return this.isValid ? this.ts / 1e3 : NaN;
      }
      /**
       * Returns the epoch seconds (as a whole number) of this DateTime.
       * @return {number}
       */
      toUnixInteger() {
        return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
      }
      /**
       * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
       * @return {string}
       */
      toJSON() {
        return this.toISO();
      }
      /**
       * Returns a BSON serializable equivalent to this DateTime.
       * @return {Date}
       */
      toBSON() {
        return this.toJSDate();
      }
      /**
       * Returns a JavaScript object with this DateTime's year, month, day, and so on.
       * @param opts - options for generating the object
       * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
       * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
       * @return {Object}
       */
      toObject(opts = {}) {
        if (!this.isValid)
          return {};
        const base = { ...this.c };
        if (opts.includeConfig) {
          base.outputCalendar = this.outputCalendar;
          base.numberingSystem = this.loc.numberingSystem;
          base.locale = this.loc.locale;
        }
        return base;
      }
      /**
       * Returns a JavaScript Date equivalent to this DateTime.
       * @return {Date}
       */
      toJSDate() {
        return new Date(this.isValid ? this.ts : NaN);
      }
      // COMPARE
      /**
       * Return the difference between two DateTimes as a Duration.
       * @param {DateTime} otherDateTime - the DateTime to compare this one to
       * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
       * @param {Object} opts - options that affect the creation of the Duration
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @example
       * var i1 = DateTime.fromISO('1982-05-25T09:45'),
       *     i2 = DateTime.fromISO('1983-10-14T10:30');
       * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
       * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
       * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
       * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
       * @return {Duration}
       */
      diff(otherDateTime, unit = "milliseconds", opts = {}) {
        if (!this.isValid || !otherDateTime.isValid) {
          return Duration.invalid("created by diffing an invalid DateTime");
        }
        const durOpts = { locale: this.locale, numberingSystem: this.numberingSystem, ...opts };
        const units = maybeArray(unit).map(Duration.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = diff(earlier, later, units, durOpts);
        return otherIsLater ? diffed.negate() : diffed;
      }
      /**
       * Return the difference between this DateTime and right now.
       * See {@link DateTime#diff}
       * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
       * @param {Object} opts - options that affect the creation of the Duration
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @return {Duration}
       */
      diffNow(unit = "milliseconds", opts = {}) {
        return this.diff(DateTime2.now(), unit, opts);
      }
      /**
       * Return an Interval spanning between this DateTime and another DateTime
       * @param {DateTime} otherDateTime - the other end point of the Interval
       * @return {Interval}
       */
      until(otherDateTime) {
        return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
      }
      /**
       * Return whether this DateTime is in the same unit of time as another DateTime.
       * Higher-order units must also be identical for this function to return `true`.
       * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
       * @param {DateTime} otherDateTime - the other DateTime
       * @param {string} unit - the unit of time to check sameness on
       * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
       * @return {boolean}
       */
      hasSame(otherDateTime, unit) {
        if (!this.isValid)
          return false;
        const inputMs = otherDateTime.valueOf();
        const adjustedToZone = this.setZone(otherDateTime.zone, { keepLocalTime: true });
        return adjustedToZone.startOf(unit) <= inputMs && inputMs <= adjustedToZone.endOf(unit);
      }
      /**
       * Equality check
       * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.
       * To compare just the millisecond values, use `+dt1 === +dt2`.
       * @param {DateTime} other - the other DateTime
       * @return {boolean}
       */
      equals(other) {
        return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
      }
      /**
       * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
       * platform supports Intl.RelativeTimeFormat. Rounds down by default.
       * @param {Object} options - options that affect the output
       * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
       * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
       * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
       * @param {boolean} [options.round=true] - whether to round the numbers in the output.
       * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
       * @param {string} options.locale - override the locale of this DateTime
       * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
       * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
       * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 da"
       * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
       * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
       * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
       * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
       */
      toRelative(options = {}) {
        if (!this.isValid)
          return null;
        const base = options.base || DateTime2.fromObject({}, { zone: this.zone }), padding = options.padding ? this < base ? -options.padding : options.padding : 0;
        let units = ["years", "months", "days", "hours", "minutes", "seconds"];
        let unit = options.unit;
        if (Array.isArray(options.unit)) {
          units = options.unit;
          unit = void 0;
        }
        return diffRelative(base, this.plus(padding), {
          ...options,
          numeric: "always",
          units,
          unit
        });
      }
      /**
       * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
       * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
       * @param {Object} options - options that affect the output
       * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
       * @param {string} options.locale - override the locale of this DateTime
       * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
       * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
       * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
       * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""maana"
       * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
       * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
       */
      toRelativeCalendar(options = {}) {
        if (!this.isValid)
          return null;
        return diffRelative(options.base || DateTime2.fromObject({}, { zone: this.zone }), this, {
          ...options,
          numeric: "auto",
          units: ["years", "months", "days"],
          calendary: true
        });
      }
      /**
       * Return the min of several date times
       * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
       * @return {DateTime} the min DateTime, or undefined if called with no argument
       */
      static min(...dateTimes) {
        if (!dateTimes.every(DateTime2.isDateTime)) {
          throw new InvalidArgumentError("min requires all arguments be DateTimes");
        }
        return bestBy(dateTimes, (i3) => i3.valueOf(), Math.min);
      }
      /**
       * Return the max of several date times
       * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
       * @return {DateTime} the max DateTime, or undefined if called with no argument
       */
      static max(...dateTimes) {
        if (!dateTimes.every(DateTime2.isDateTime)) {
          throw new InvalidArgumentError("max requires all arguments be DateTimes");
        }
        return bestBy(dateTimes, (i3) => i3.valueOf(), Math.max);
      }
      // MISC
      /**
       * Explain how a string would be parsed by fromFormat()
       * @param {string} text - the string to parse
       * @param {string} fmt - the format the string is expected to be in (see description)
       * @param {Object} options - options taken by fromFormat()
       * @return {Object}
       */
      static fromFormatExplain(text, fmt, options = {}) {
        const { locale = null, numberingSystem = null } = options, localeToUse = Locale.fromOpts({
          locale,
          numberingSystem,
          defaultToEN: true
        });
        return explainFromTokens(localeToUse, text, fmt);
      }
      /**
       * @deprecated use fromFormatExplain instead
       */
      static fromStringExplain(text, fmt, options = {}) {
        return DateTime2.fromFormatExplain(text, fmt, options);
      }
      // FORMAT PRESETS
      /**
       * {@link DateTime#toLocaleString} format like 10/14/1983
       * @type {Object}
       */
      static get DATE_SHORT() {
        return DATE_SHORT;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
       * @type {Object}
       */
      static get DATE_MED() {
        return DATE_MED;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
       * @type {Object}
       */
      static get DATE_MED_WITH_WEEKDAY() {
        return DATE_MED_WITH_WEEKDAY;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'October 14, 1983'
       * @type {Object}
       */
      static get DATE_FULL() {
        return DATE_FULL;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
       * @type {Object}
       */
      static get DATE_HUGE() {
        return DATE_HUGE;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get TIME_SIMPLE() {
        return TIME_SIMPLE;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get TIME_WITH_SECONDS() {
        return TIME_WITH_SECONDS;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get TIME_WITH_SHORT_OFFSET() {
        return TIME_WITH_SHORT_OFFSET;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get TIME_WITH_LONG_OFFSET() {
        return TIME_WITH_LONG_OFFSET;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
       * @type {Object}
       */
      static get TIME_24_SIMPLE() {
        return TIME_24_SIMPLE;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
       * @type {Object}
       */
      static get TIME_24_WITH_SECONDS() {
        return TIME_24_WITH_SECONDS;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
       * @type {Object}
       */
      static get TIME_24_WITH_SHORT_OFFSET() {
        return TIME_24_WITH_SHORT_OFFSET;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
       * @type {Object}
       */
      static get TIME_24_WITH_LONG_OFFSET() {
        return TIME_24_WITH_LONG_OFFSET;
      }
      /**
       * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_SHORT() {
        return DATETIME_SHORT;
      }
      /**
       * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_SHORT_WITH_SECONDS() {
        return DATETIME_SHORT_WITH_SECONDS;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_MED() {
        return DATETIME_MED;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_MED_WITH_SECONDS() {
        return DATETIME_MED_WITH_SECONDS;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_MED_WITH_WEEKDAY() {
        return DATETIME_MED_WITH_WEEKDAY;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_FULL() {
        return DATETIME_FULL;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_FULL_WITH_SECONDS() {
        return DATETIME_FULL_WITH_SECONDS;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_HUGE() {
        return DATETIME_HUGE;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_HUGE_WITH_SECONDS() {
        return DATETIME_HUGE_WITH_SECONDS;
      }
    };
    function friendlyDateTime(dateTimeish) {
      if (DateTime2.isDateTime(dateTimeish)) {
        return dateTimeish;
      } else if (dateTimeish && dateTimeish.valueOf && isNumber2(dateTimeish.valueOf())) {
        return DateTime2.fromJSDate(dateTimeish);
      } else if (dateTimeish && typeof dateTimeish === "object") {
        return DateTime2.fromObject(dateTimeish);
      } else {
        throw new InvalidArgumentError(
          `Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`
        );
      }
    }
    var DEFAULT_QUERY_SETTINGS = {
      renderNullAs: "\\-",
      taskCompletionTracking: false,
      taskCompletionUseEmojiShorthand: false,
      taskCompletionText: "completion",
      taskCompletionDateFormat: "yyyy-MM-dd",
      recursiveSubTaskCompletion: false,
      warnOnEmptyResult: true,
      refreshEnabled: true,
      refreshInterval: 2500,
      defaultDateFormat: "MMMM dd, yyyy",
      defaultDateTimeFormat: "h:mm a - MMMM dd, yyyy",
      maxRecursiveRenderDepth: 4,
      tableIdColumnName: "File",
      tableGroupColumnName: "Group",
      showResultCount: true
    };
    var DEFAULT_EXPORT_SETTINGS = {
      allowHtml: true
    };
    ({
      ...DEFAULT_QUERY_SETTINGS,
      ...DEFAULT_EXPORT_SETTINGS,
      ...{
        inlineQueryPrefix: "=",
        inlineJsQueryPrefix: "$=",
        inlineQueriesInCodeblocks: true,
        enableInlineDataview: true,
        enableDataviewJs: false,
        enableInlineDataviewJs: false,
        prettyRenderInlineFields: true,
        prettyRenderInlineFieldsInLivePreview: true,
        dataviewJsKeyword: "dataviewjs"
      }
    });
    var Success = class {
      constructor(value) {
        __publicField(this, "value");
        __publicField(this, "successful");
        this.value = value;
        this.successful = true;
      }
      map(f3) {
        return new Success(f3(this.value));
      }
      flatMap(f3) {
        return f3(this.value);
      }
      mapErr(f3) {
        return this;
      }
      bimap(succ, _fail) {
        return this.map(succ);
      }
      orElse(_value) {
        return this.value;
      }
      cast() {
        return this;
      }
      orElseThrow(_message) {
        return this.value;
      }
    };
    var Failure = class {
      constructor(error) {
        __publicField(this, "error");
        __publicField(this, "successful");
        this.error = error;
        this.successful = false;
      }
      map(_f) {
        return this;
      }
      flatMap(_f) {
        return this;
      }
      mapErr(f3) {
        return new Failure(f3(this.error));
      }
      bimap(_succ, fail) {
        return this.mapErr(fail);
      }
      orElse(value) {
        return value;
      }
      cast() {
        return this;
      }
      orElseThrow(message) {
        if (message)
          throw new Error(message(this.error));
        else
          throw new Error("" + this.error);
      }
    };
    var Result;
    (function(Result2) {
      function success(value) {
        return new Success(value);
      }
      Result2.success = success;
      function failure(error) {
        return new Failure(error);
      }
      Result2.failure = failure;
      function flatMap2(first, second, f3) {
        if (first.successful) {
          if (second.successful)
            return f3(first.value, second.value);
          else
            return failure(second.error);
        } else {
          return failure(first.error);
        }
      }
      Result2.flatMap2 = flatMap2;
      function map2(first, second, f3) {
        return flatMap2(first, second, (a3, b3) => success(f3(a3, b3)));
      }
      Result2.map2 = map2;
    })(Result || (Result = {}));
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    var parsimmon_umd_min = { exports: {} };
    parsimmon_umd_min.exports;
    (function(module3, exports2) {
      !function(n3, t3) {
        module3.exports = t3();
      }("undefined" != typeof self ? self : commonjsGlobal, function() {
        return function(n3) {
          var t3 = {};
          function r3(e3) {
            if (t3[e3])
              return t3[e3].exports;
            var u3 = t3[e3] = { i: e3, l: false, exports: {} };
            return n3[e3].call(u3.exports, u3, u3.exports, r3), u3.l = true, u3.exports;
          }
          return r3.m = n3, r3.c = t3, r3.d = function(n4, t4, e3) {
            r3.o(n4, t4) || Object.defineProperty(n4, t4, { configurable: false, enumerable: true, get: e3 });
          }, r3.r = function(n4) {
            Object.defineProperty(n4, "__esModule", { value: true });
          }, r3.n = function(n4) {
            var t4 = n4 && n4.__esModule ? function() {
              return n4.default;
            } : function() {
              return n4;
            };
            return r3.d(t4, "a", t4), t4;
          }, r3.o = function(n4, t4) {
            return Object.prototype.hasOwnProperty.call(n4, t4);
          }, r3.p = "", r3(r3.s = 0);
        }([function(n3, t3, r3) {
          function e3(n4) {
            if (!(this instanceof e3))
              return new e3(n4);
            this._ = n4;
          }
          var u3 = e3.prototype;
          function o2(n4, t4) {
            for (var r4 = 0; r4 < n4; r4++)
              t4(r4);
          }
          function i3(n4, t4, r4) {
            return function(n5, t5) {
              o2(t5.length, function(r5) {
                n5(t5[r5], r5, t5);
              });
            }(function(r5, e4, u4) {
              t4 = n4(t4, r5, e4, u4);
            }, r4), t4;
          }
          function a3(n4, t4) {
            return i3(function(t5, r4, e4, u4) {
              return t5.concat([n4(r4, e4, u4)]);
            }, [], t4);
          }
          function f3(n4, t4) {
            var r4 = { v: 0, buf: t4 };
            return o2(n4, function() {
              var n5;
              r4 = { v: r4.v << 1 | (n5 = r4.buf, n5[0] >> 7), buf: function(n6) {
                var t5 = i3(function(n7, t6, r5, e4) {
                  return n7.concat(r5 === e4.length - 1 ? Buffer.from([t6, 0]).readUInt16BE(0) : e4.readUInt16BE(r5));
                }, [], n6);
                return Buffer.from(a3(function(n7) {
                  return (n7 << 1 & 65535) >> 8;
                }, t5));
              }(r4.buf) };
            }), r4;
          }
          function c3() {
            return "undefined" != typeof Buffer;
          }
          function s4() {
            if (!c3())
              throw new Error("Buffer global does not exist; please use webpack if you need to parse Buffers in the browser.");
          }
          function l4(n4) {
            s4();
            var t4 = i3(function(n5, t5) {
              return n5 + t5;
            }, 0, n4);
            if (t4 % 8 != 0)
              throw new Error("The bits [" + n4.join(", ") + "] add up to " + t4 + " which is not an even number of bytes; the total should be divisible by 8");
            var r4, u4 = t4 / 8, o3 = (r4 = function(n5) {
              return n5 > 48;
            }, i3(function(n5, t5) {
              return n5 || (r4(t5) ? t5 : n5);
            }, null, n4));
            if (o3)
              throw new Error(o3 + " bit range requested exceeds 48 bit (6 byte) Number max.");
            return new e3(function(t5, r5) {
              var e4 = u4 + r5;
              return e4 > t5.length ? x4(r5, u4.toString() + " bytes") : b3(e4, i3(function(n5, t6) {
                var r6 = f3(t6, n5.buf);
                return { coll: n5.coll.concat(r6.v), buf: r6.buf };
              }, { coll: [], buf: t5.slice(r5, e4) }, n4).coll);
            });
          }
          function h3(n4, t4) {
            return new e3(function(r4, e4) {
              return s4(), e4 + t4 > r4.length ? x4(e4, t4 + " bytes for " + n4) : b3(e4 + t4, r4.slice(e4, e4 + t4));
            });
          }
          function p3(n4, t4) {
            if ("number" != typeof (r4 = t4) || Math.floor(r4) !== r4 || t4 < 0 || t4 > 6)
              throw new Error(n4 + " requires integer length in range [0, 6].");
            var r4;
          }
          function d2(n4) {
            return p3("uintBE", n4), h3("uintBE(" + n4 + ")", n4).map(function(t4) {
              return t4.readUIntBE(0, n4);
            });
          }
          function v3(n4) {
            return p3("uintLE", n4), h3("uintLE(" + n4 + ")", n4).map(function(t4) {
              return t4.readUIntLE(0, n4);
            });
          }
          function g4(n4) {
            return p3("intBE", n4), h3("intBE(" + n4 + ")", n4).map(function(t4) {
              return t4.readIntBE(0, n4);
            });
          }
          function m3(n4) {
            return p3("intLE", n4), h3("intLE(" + n4 + ")", n4).map(function(t4) {
              return t4.readIntLE(0, n4);
            });
          }
          function y3(n4) {
            return n4 instanceof e3;
          }
          function E2(n4) {
            return "[object Array]" === {}.toString.call(n4);
          }
          function w4(n4) {
            return c3() && Buffer.isBuffer(n4);
          }
          function b3(n4, t4) {
            return { status: true, index: n4, value: t4, furthest: -1, expected: [] };
          }
          function x4(n4, t4) {
            return E2(t4) || (t4 = [t4]), { status: false, index: -1, value: null, furthest: n4, expected: t4 };
          }
          function B3(n4, t4) {
            if (!t4)
              return n4;
            if (n4.furthest > t4.furthest)
              return n4;
            var r4 = n4.furthest === t4.furthest ? function(n5, t5) {
              if (function() {
                if (void 0 !== e3._supportsSet)
                  return e3._supportsSet;
                var n6 = "undefined" != typeof Set;
                return e3._supportsSet = n6, n6;
              }() && Array.from) {
                for (var r5 = new Set(n5), u4 = 0; u4 < t5.length; u4++)
                  r5.add(t5[u4]);
                var o3 = Array.from(r5);
                return o3.sort(), o3;
              }
              for (var i4 = {}, a4 = 0; a4 < n5.length; a4++)
                i4[n5[a4]] = true;
              for (var f4 = 0; f4 < t5.length; f4++)
                i4[t5[f4]] = true;
              var c4 = [];
              for (var s5 in i4)
                ({}).hasOwnProperty.call(i4, s5) && c4.push(s5);
              return c4.sort(), c4;
            }(n4.expected, t4.expected) : t4.expected;
            return { status: n4.status, index: n4.index, value: n4.value, furthest: t4.furthest, expected: r4 };
          }
          var j4 = {};
          function S2(n4, t4) {
            if (w4(n4))
              return { offset: t4, line: -1, column: -1 };
            n4 in j4 || (j4[n4] = {});
            for (var r4 = j4[n4], e4 = 0, u4 = 0, o3 = 0, i4 = t4; i4 >= 0; ) {
              if (i4 in r4) {
                e4 = r4[i4].line, 0 === o3 && (o3 = r4[i4].lineStart);
                break;
              }
              ("\n" === n4.charAt(i4) || "\r" === n4.charAt(i4) && "\n" !== n4.charAt(i4 + 1)) && (u4++, 0 === o3 && (o3 = i4 + 1)), i4--;
            }
            var a4 = e4 + u4, f4 = t4 - o3;
            return r4[t4] = { line: a4, lineStart: o3 }, { offset: t4, line: a4 + 1, column: f4 + 1 };
          }
          function _3(n4) {
            if (!y3(n4))
              throw new Error("not a parser: " + n4);
          }
          function L3(n4, t4) {
            return "string" == typeof n4 ? n4.charAt(t4) : n4[t4];
          }
          function O2(n4) {
            if ("number" != typeof n4)
              throw new Error("not a number: " + n4);
          }
          function k3(n4) {
            if ("function" != typeof n4)
              throw new Error("not a function: " + n4);
          }
          function P3(n4) {
            if ("string" != typeof n4)
              throw new Error("not a string: " + n4);
          }
          var q3 = 2, A3 = 3, I3 = 8, F4 = 5 * I3, M2 = 4 * I3, z3 = "  ";
          function R(n4, t4) {
            return new Array(t4 + 1).join(n4);
          }
          function U2(n4, t4, r4) {
            var e4 = t4 - n4.length;
            return e4 <= 0 ? n4 : R(r4, e4) + n4;
          }
          function W2(n4, t4, r4, e4) {
            return { from: n4 - t4 > 0 ? n4 - t4 : 0, to: n4 + r4 > e4 ? e4 : n4 + r4 };
          }
          function D3(n4, t4) {
            var r4, e4, u4, o3, f4, c4 = t4.index, s5 = c4.offset, l5 = 1;
            if (s5 === n4.length)
              return "Got the end of the input";
            if (w4(n4)) {
              var h4 = s5 - s5 % I3, p4 = s5 - h4, d3 = W2(h4, F4, M2 + I3, n4.length), v4 = a3(function(n5) {
                return a3(function(n6) {
                  return U2(n6.toString(16), 2, "0");
                }, n5);
              }, function(n5, t5) {
                var r5 = n5.length, e5 = [], u5 = 0;
                if (r5 <= t5)
                  return [n5.slice()];
                for (var o4 = 0; o4 < r5; o4++)
                  e5[u5] || e5.push([]), e5[u5].push(n5[o4]), (o4 + 1) % t5 == 0 && u5++;
                return e5;
              }(n4.slice(d3.from, d3.to).toJSON().data, I3));
              o3 = function(n5) {
                return 0 === n5.from && 1 === n5.to ? { from: n5.from, to: n5.to } : { from: n5.from / I3, to: Math.floor(n5.to / I3) };
              }(d3), e4 = h4 / I3, r4 = 3 * p4, p4 >= 4 && (r4 += 1), l5 = 2, u4 = a3(function(n5) {
                return n5.length <= 4 ? n5.join(" ") : n5.slice(0, 4).join(" ") + "  " + n5.slice(4).join(" ");
              }, v4), (f4 = (8 * (o3.to > 0 ? o3.to - 1 : o3.to)).toString(16).length) < 2 && (f4 = 2);
            } else {
              var g5 = n4.split(/\r\n|[\n\r\u2028\u2029]/);
              r4 = c4.column - 1, e4 = c4.line - 1, o3 = W2(e4, q3, A3, g5.length), u4 = g5.slice(o3.from, o3.to), f4 = o3.to.toString().length;
            }
            var m4 = e4 - o3.from;
            return w4(n4) && (f4 = (8 * (o3.to > 0 ? o3.to - 1 : o3.to)).toString(16).length) < 2 && (f4 = 2), i3(function(t5, e5, u5) {
              var i4, a4 = u5 === m4, c5 = a4 ? "> " : z3;
              return i4 = w4(n4) ? U2((8 * (o3.from + u5)).toString(16), f4, "0") : U2((o3.from + u5 + 1).toString(), f4, " "), [].concat(t5, [c5 + i4 + " | " + e5], a4 ? [z3 + R(" ", f4) + " | " + U2("", r4, " ") + R("^", l5)] : []);
            }, [], u4).join("\n");
          }
          function N3(n4, t4) {
            return ["\n", "-- PARSING FAILED " + R("-", 50), "\n\n", D3(n4, t4), "\n\n", (r4 = t4.expected, 1 === r4.length ? "Expected:\n\n" + r4[0] : "Expected one of the following: \n\n" + r4.join(", ")), "\n"].join("");
            var r4;
          }
          function G3(n4) {
            return void 0 !== n4.flags ? n4.flags : [n4.global ? "g" : "", n4.ignoreCase ? "i" : "", n4.multiline ? "m" : "", n4.unicode ? "u" : "", n4.sticky ? "y" : ""].join("");
          }
          function C3() {
            for (var n4 = [].slice.call(arguments), t4 = n4.length, r4 = 0; r4 < t4; r4 += 1)
              _3(n4[r4]);
            return e3(function(r5, e4) {
              for (var u4, o3 = new Array(t4), i4 = 0; i4 < t4; i4 += 1) {
                if (!(u4 = B3(n4[i4]._(r5, e4), u4)).status)
                  return u4;
                o3[i4] = u4.value, e4 = u4.index;
              }
              return B3(b3(e4, o3), u4);
            });
          }
          function J2() {
            var n4 = [].slice.call(arguments);
            if (0 === n4.length)
              throw new Error("seqMap needs at least one argument");
            var t4 = n4.pop();
            return k3(t4), C3.apply(null, n4).map(function(n5) {
              return t4.apply(null, n5);
            });
          }
          function T4() {
            var n4 = [].slice.call(arguments), t4 = n4.length;
            if (0 === t4)
              return Y("zero alternates");
            for (var r4 = 0; r4 < t4; r4 += 1)
              _3(n4[r4]);
            return e3(function(t5, r5) {
              for (var e4, u4 = 0; u4 < n4.length; u4 += 1)
                if ((e4 = B3(n4[u4]._(t5, r5), e4)).status)
                  return e4;
              return e4;
            });
          }
          function V3(n4, t4) {
            return H3(n4, t4).or(X2([]));
          }
          function H3(n4, t4) {
            return _3(n4), _3(t4), J2(n4, t4.then(n4).many(), function(n5, t5) {
              return [n5].concat(t5);
            });
          }
          function K2(n4) {
            P3(n4);
            var t4 = "'" + n4 + "'";
            return e3(function(r4, e4) {
              var u4 = e4 + n4.length, o3 = r4.slice(e4, u4);
              return o3 === n4 ? b3(u4, o3) : x4(e4, t4);
            });
          }
          function Q2(n4, t4) {
            !function(n5) {
              if (!(n5 instanceof RegExp))
                throw new Error("not a regexp: " + n5);
              for (var t5 = G3(n5), r5 = 0; r5 < t5.length; r5++) {
                var e4 = t5.charAt(r5);
                if ("i" !== e4 && "m" !== e4 && "u" !== e4 && "s" !== e4)
                  throw new Error('unsupported regexp flag "' + e4 + '": ' + n5);
              }
            }(n4), arguments.length >= 2 ? O2(t4) : t4 = 0;
            var r4 = function(n5) {
              return RegExp("^(?:" + n5.source + ")", G3(n5));
            }(n4), u4 = "" + n4;
            return e3(function(n5, e4) {
              var o3 = r4.exec(n5.slice(e4));
              if (o3) {
                if (0 <= t4 && t4 <= o3.length) {
                  var i4 = o3[0], a4 = o3[t4];
                  return b3(e4 + i4.length, a4);
                }
                return x4(e4, "valid match group (0 to " + o3.length + ") in " + u4);
              }
              return x4(e4, u4);
            });
          }
          function X2(n4) {
            return e3(function(t4, r4) {
              return b3(r4, n4);
            });
          }
          function Y(n4) {
            return e3(function(t4, r4) {
              return x4(r4, n4);
            });
          }
          function Z2(n4) {
            if (y3(n4))
              return e3(function(t4, r4) {
                var e4 = n4._(t4, r4);
                return e4.index = r4, e4.value = "", e4;
              });
            if ("string" == typeof n4)
              return Z2(K2(n4));
            if (n4 instanceof RegExp)
              return Z2(Q2(n4));
            throw new Error("not a string, regexp, or parser: " + n4);
          }
          function $3(n4) {
            return _3(n4), e3(function(t4, r4) {
              var e4 = n4._(t4, r4), u4 = t4.slice(r4, e4.index);
              return e4.status ? x4(r4, 'not "' + u4 + '"') : b3(r4, null);
            });
          }
          function nn2(n4) {
            return k3(n4), e3(function(t4, r4) {
              var e4 = L3(t4, r4);
              return r4 < t4.length && n4(e4) ? b3(r4 + 1, e4) : x4(r4, "a character/byte matching " + n4);
            });
          }
          function tn2(n4, t4) {
            arguments.length < 2 && (t4 = n4, n4 = void 0);
            var r4 = e3(function(n5, e4) {
              return r4._ = t4()._, r4._(n5, e4);
            });
            return n4 ? r4.desc(n4) : r4;
          }
          function rn() {
            return Y("fantasy-land/empty");
          }
          u3.parse = function(n4) {
            if ("string" != typeof n4 && !w4(n4))
              throw new Error(".parse must be called with a string or Buffer as its argument");
            var t4, r4 = this.skip(an)._(n4, 0);
            return t4 = r4.status ? { status: true, value: r4.value } : { status: false, index: S2(n4, r4.furthest), expected: r4.expected }, delete j4[n4], t4;
          }, u3.tryParse = function(n4) {
            var t4 = this.parse(n4);
            if (t4.status)
              return t4.value;
            var r4 = N3(n4, t4), e4 = new Error(r4);
            throw e4.type = "ParsimmonError", e4.result = t4, e4;
          }, u3.assert = function(n4, t4) {
            return this.chain(function(r4) {
              return n4(r4) ? X2(r4) : Y(t4);
            });
          }, u3.or = function(n4) {
            return T4(this, n4);
          }, u3.trim = function(n4) {
            return this.wrap(n4, n4);
          }, u3.wrap = function(n4, t4) {
            return J2(n4, this, t4, function(n5, t5) {
              return t5;
            });
          }, u3.thru = function(n4) {
            return n4(this);
          }, u3.then = function(n4) {
            return _3(n4), C3(this, n4).map(function(n5) {
              return n5[1];
            });
          }, u3.many = function() {
            var n4 = this;
            return e3(function(t4, r4) {
              for (var e4 = [], u4 = void 0; ; ) {
                if (!(u4 = B3(n4._(t4, r4), u4)).status)
                  return B3(b3(r4, e4), u4);
                if (r4 === u4.index)
                  throw new Error("infinite loop detected in .many() parser --- calling .many() on a parser which can accept zero characters is usually the cause");
                r4 = u4.index, e4.push(u4.value);
              }
            });
          }, u3.tieWith = function(n4) {
            return P3(n4), this.map(function(t4) {
              if (function(n5) {
                if (!E2(n5))
                  throw new Error("not an array: " + n5);
              }(t4), t4.length) {
                P3(t4[0]);
                for (var r4 = t4[0], e4 = 1; e4 < t4.length; e4++)
                  P3(t4[e4]), r4 += n4 + t4[e4];
                return r4;
              }
              return "";
            });
          }, u3.tie = function() {
            return this.tieWith("");
          }, u3.times = function(n4, t4) {
            var r4 = this;
            return arguments.length < 2 && (t4 = n4), O2(n4), O2(t4), e3(function(e4, u4) {
              for (var o3 = [], i4 = void 0, a4 = void 0, f4 = 0; f4 < n4; f4 += 1) {
                if (a4 = B3(i4 = r4._(e4, u4), a4), !i4.status)
                  return a4;
                u4 = i4.index, o3.push(i4.value);
              }
              for (; f4 < t4 && (a4 = B3(i4 = r4._(e4, u4), a4), i4.status); f4 += 1)
                u4 = i4.index, o3.push(i4.value);
              return B3(b3(u4, o3), a4);
            });
          }, u3.result = function(n4) {
            return this.map(function() {
              return n4;
            });
          }, u3.atMost = function(n4) {
            return this.times(0, n4);
          }, u3.atLeast = function(n4) {
            return J2(this.times(n4), this.many(), function(n5, t4) {
              return n5.concat(t4);
            });
          }, u3.map = function(n4) {
            k3(n4);
            var t4 = this;
            return e3(function(r4, e4) {
              var u4 = t4._(r4, e4);
              return u4.status ? B3(b3(u4.index, n4(u4.value)), u4) : u4;
            });
          }, u3.contramap = function(n4) {
            k3(n4);
            var t4 = this;
            return e3(function(r4, e4) {
              var u4 = t4.parse(n4(r4.slice(e4)));
              return u4.status ? b3(e4 + r4.length, u4.value) : u4;
            });
          }, u3.promap = function(n4, t4) {
            return k3(n4), k3(t4), this.contramap(n4).map(t4);
          }, u3.skip = function(n4) {
            return C3(this, n4).map(function(n5) {
              return n5[0];
            });
          }, u3.mark = function() {
            return J2(en2, this, en2, function(n4, t4, r4) {
              return { start: n4, value: t4, end: r4 };
            });
          }, u3.node = function(n4) {
            return J2(en2, this, en2, function(t4, r4, e4) {
              return { name: n4, value: r4, start: t4, end: e4 };
            });
          }, u3.sepBy = function(n4) {
            return V3(this, n4);
          }, u3.sepBy1 = function(n4) {
            return H3(this, n4);
          }, u3.lookahead = function(n4) {
            return this.skip(Z2(n4));
          }, u3.notFollowedBy = function(n4) {
            return this.skip($3(n4));
          }, u3.desc = function(n4) {
            E2(n4) || (n4 = [n4]);
            var t4 = this;
            return e3(function(r4, e4) {
              var u4 = t4._(r4, e4);
              return u4.status || (u4.expected = n4), u4;
            });
          }, u3.fallback = function(n4) {
            return this.or(X2(n4));
          }, u3.ap = function(n4) {
            return J2(n4, this, function(n5, t4) {
              return n5(t4);
            });
          }, u3.chain = function(n4) {
            var t4 = this;
            return e3(function(r4, e4) {
              var u4 = t4._(r4, e4);
              return u4.status ? B3(n4(u4.value)._(r4, u4.index), u4) : u4;
            });
          }, u3.concat = u3.or, u3.empty = rn, u3.of = X2, u3["fantasy-land/ap"] = u3.ap, u3["fantasy-land/chain"] = u3.chain, u3["fantasy-land/concat"] = u3.concat, u3["fantasy-land/empty"] = u3.empty, u3["fantasy-land/of"] = u3.of, u3["fantasy-land/map"] = u3.map;
          var en2 = e3(function(n4, t4) {
            return b3(t4, S2(n4, t4));
          }), un = e3(function(n4, t4) {
            return t4 >= n4.length ? x4(t4, "any character/byte") : b3(t4 + 1, L3(n4, t4));
          }), on = e3(function(n4, t4) {
            return b3(n4.length, n4.slice(t4));
          }), an = e3(function(n4, t4) {
            return t4 < n4.length ? x4(t4, "EOF") : b3(t4, null);
          }), fn = Q2(/[0-9]/).desc("a digit"), cn = Q2(/[0-9]*/).desc("optional digits"), sn = Q2(/[a-z]/i).desc("a letter"), ln = Q2(/[a-z]*/i).desc("optional letters"), hn = Q2(/\s*/).desc("optional whitespace"), pn = Q2(/\s+/).desc("whitespace"), dn = K2("\r"), vn = K2("\n"), gn = K2("\r\n"), mn = T4(gn, vn, dn).desc("newline"), yn = T4(mn, an);
          e3.all = on, e3.alt = T4, e3.any = un, e3.cr = dn, e3.createLanguage = function(n4) {
            var t4 = {};
            for (var r4 in n4)
              ({}).hasOwnProperty.call(n4, r4) && function(r5) {
                t4[r5] = tn2(function() {
                  return n4[r5](t4);
                });
              }(r4);
            return t4;
          }, e3.crlf = gn, e3.custom = function(n4) {
            return e3(n4(b3, x4));
          }, e3.digit = fn, e3.digits = cn, e3.empty = rn, e3.end = yn, e3.eof = an, e3.fail = Y, e3.formatError = N3, e3.index = en2, e3.isParser = y3, e3.lazy = tn2, e3.letter = sn, e3.letters = ln, e3.lf = vn, e3.lookahead = Z2, e3.makeFailure = x4, e3.makeSuccess = b3, e3.newline = mn, e3.noneOf = function(n4) {
            return nn2(function(t4) {
              return n4.indexOf(t4) < 0;
            }).desc("none of '" + n4 + "'");
          }, e3.notFollowedBy = $3, e3.of = X2, e3.oneOf = function(n4) {
            for (var t4 = n4.split(""), r4 = 0; r4 < t4.length; r4++)
              t4[r4] = "'" + t4[r4] + "'";
            return nn2(function(t5) {
              return n4.indexOf(t5) >= 0;
            }).desc(t4);
          }, e3.optWhitespace = hn, e3.Parser = e3, e3.range = function(n4, t4) {
            return nn2(function(r4) {
              return n4 <= r4 && r4 <= t4;
            }).desc(n4 + "-" + t4);
          }, e3.regex = Q2, e3.regexp = Q2, e3.sepBy = V3, e3.sepBy1 = H3, e3.seq = C3, e3.seqMap = J2, e3.seqObj = function() {
            for (var n4, t4 = {}, r4 = 0, u4 = (n4 = arguments, Array.prototype.slice.call(n4)), o3 = u4.length, i4 = 0; i4 < o3; i4 += 1) {
              var a4 = u4[i4];
              if (!y3(a4)) {
                if (E2(a4) && 2 === a4.length && "string" == typeof a4[0] && y3(a4[1])) {
                  var f4 = a4[0];
                  if (Object.prototype.hasOwnProperty.call(t4, f4))
                    throw new Error("seqObj: duplicate key " + f4);
                  t4[f4] = true, r4++;
                  continue;
                }
                throw new Error("seqObj arguments must be parsers or [string, parser] array pairs.");
              }
            }
            if (0 === r4)
              throw new Error("seqObj expects at least one named parser, found zero");
            return e3(function(n5, t5) {
              for (var r5, e4 = {}, i5 = 0; i5 < o3; i5 += 1) {
                var a5, f5;
                if (E2(u4[i5]) ? (a5 = u4[i5][0], f5 = u4[i5][1]) : (a5 = null, f5 = u4[i5]), !(r5 = B3(f5._(n5, t5), r5)).status)
                  return r5;
                a5 && (e4[a5] = r5.value), t5 = r5.index;
              }
              return B3(b3(t5, e4), r5);
            });
          }, e3.string = K2, e3.succeed = X2, e3.takeWhile = function(n4) {
            return k3(n4), e3(function(t4, r4) {
              for (var e4 = r4; e4 < t4.length && n4(L3(t4, e4)); )
                e4++;
              return b3(e4, t4.slice(r4, e4));
            });
          }, e3.test = nn2, e3.whitespace = pn, e3["fantasy-land/empty"] = rn, e3["fantasy-land/of"] = X2, e3.Binary = { bitSeq: l4, bitSeqObj: function(n4) {
            s4();
            var t4 = {}, r4 = 0, e4 = a3(function(n5) {
              if (E2(n5)) {
                var e5 = n5;
                if (2 !== e5.length)
                  throw new Error("[" + e5.join(", ") + "] should be length 2, got length " + e5.length);
                if (P3(e5[0]), O2(e5[1]), Object.prototype.hasOwnProperty.call(t4, e5[0]))
                  throw new Error("duplicate key in bitSeqObj: " + e5[0]);
                return t4[e5[0]] = true, r4++, e5;
              }
              return O2(n5), [null, n5];
            }, n4);
            if (r4 < 1)
              throw new Error("bitSeqObj expects at least one named pair, got [" + n4.join(", ") + "]");
            var u4 = a3(function(n5) {
              return n5[0];
            }, e4);
            return l4(a3(function(n5) {
              return n5[1];
            }, e4)).map(function(n5) {
              return i3(function(n6, t5) {
                return null !== t5[0] && (n6[t5[0]] = t5[1]), n6;
              }, {}, a3(function(t5, r5) {
                return [t5, n5[r5]];
              }, u4));
            });
          }, byte: function(n4) {
            if (s4(), O2(n4), n4 > 255)
              throw new Error("Value specified to byte constructor (" + n4 + "=0x" + n4.toString(16) + ") is larger in value than a single byte.");
            var t4 = (n4 > 15 ? "0x" : "0x0") + n4.toString(16);
            return e3(function(r4, e4) {
              var u4 = L3(r4, e4);
              return u4 === n4 ? b3(e4 + 1, u4) : x4(e4, t4);
            });
          }, buffer: function(n4) {
            return h3("buffer", n4).map(function(n5) {
              return Buffer.from(n5);
            });
          }, encodedString: function(n4, t4) {
            return h3("string", t4).map(function(t5) {
              return t5.toString(n4);
            });
          }, uintBE: d2, uint8BE: d2(1), uint16BE: d2(2), uint32BE: d2(4), uintLE: v3, uint8LE: v3(1), uint16LE: v3(2), uint32LE: v3(4), intBE: g4, int8BE: g4(1), int16BE: g4(2), int32BE: g4(4), intLE: m3, int8LE: m3(1), int16LE: m3(2), int32LE: m3(4), floatBE: h3("floatBE", 4).map(function(n4) {
            return n4.readFloatBE(0);
          }), floatLE: h3("floatLE", 4).map(function(n4) {
            return n4.readFloatLE(0);
          }), doubleBE: h3("doubleBE", 8).map(function(n4) {
            return n4.readDoubleBE(0);
          }), doubleLE: h3("doubleLE", 8).map(function(n4) {
            return n4.readDoubleLE(0);
          }) }, n3.exports = e3;
        }]);
      });
    })(parsimmon_umd_min, parsimmon_umd_min.exports);
    var parsimmon_umd_minExports = parsimmon_umd_min.exports;
    var emojiRegex = () => {
      return /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC3\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC08\uDC26](?:\u200D\u2B1B)?|[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
    };
    function normalizeDuration(dur) {
      if (dur === void 0 || dur === null)
        return dur;
      return dur.shiftToAll().normalize();
    }
    function getFileTitle(path) {
      if (path.includes("/"))
        path = path.substring(path.lastIndexOf("/") + 1);
      if (path.endsWith(".md"))
        path = path.substring(0, path.length - 3);
      return path;
    }
    parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regex(new RegExp(emojiRegex(), "")), parsimmon_umd_minExports.regex(/[0-9\p{Letter}_-]+/u).map((str) => str.toLocaleLowerCase()), parsimmon_umd_minExports.whitespace.map((_3) => "-"), parsimmon_umd_minExports.any.map((_3) => "")).many().map((result) => result.join(""));
    var HEADER_CANONICALIZER = parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regex(new RegExp(emojiRegex(), "")), parsimmon_umd_minExports.regex(/[0-9\p{Letter}_-]+/u), parsimmon_umd_minExports.whitespace.map((_3) => " "), parsimmon_umd_minExports.any.map((_3) => " ")).many().map((result) => {
      return result.join("").split(/\s+/).join(" ").trim();
    });
    function normalizeHeaderForLink(header) {
      return HEADER_CANONICALIZER.tryParse(header);
    }
    function renderMinimalDuration(dur) {
      dur = normalizeDuration(dur);
      dur = Duration.fromObject(Object.fromEntries(Object.entries(dur.toObject()).filter(([, quantity]) => quantity != 0)));
      return dur.toHuman();
    }
    var Values;
    (function(Values2) {
      function toString(field, setting = DEFAULT_QUERY_SETTINGS, recursive = false) {
        let wrapped = wrapValue(field);
        if (!wrapped)
          return setting.renderNullAs;
        switch (wrapped.type) {
          case "null":
            return setting.renderNullAs;
          case "string":
            return wrapped.value;
          case "number":
          case "boolean":
            return "" + wrapped.value;
          case "html":
            return wrapped.value.outerHTML;
          case "widget":
            return wrapped.value.markdown();
          case "link":
            return wrapped.value.markdown();
          case "function":
            return "<function>";
          case "array":
            let result = "";
            if (recursive)
              result += "[";
            result += wrapped.value.map((f3) => toString(f3, setting, true)).join(", ");
            if (recursive)
              result += "]";
            return result;
          case "object":
            return "{ " + Object.entries(wrapped.value).map((e3) => e3[0] + ": " + toString(e3[1], setting, true)).join(", ") + " }";
          case "date":
            if (wrapped.value.second == 0 && wrapped.value.hour == 0 && wrapped.value.minute == 0) {
              return wrapped.value.toFormat(setting.defaultDateFormat);
            }
            return wrapped.value.toFormat(setting.defaultDateTimeFormat);
          case "duration":
            return renderMinimalDuration(wrapped.value);
        }
      }
      Values2.toString = toString;
      function wrapValue(val) {
        if (isNull(val))
          return { type: "null", value: val };
        else if (isNumber3(val))
          return { type: "number", value: val };
        else if (isString2(val))
          return { type: "string", value: val };
        else if (isBoolean(val))
          return { type: "boolean", value: val };
        else if (isDuration(val))
          return { type: "duration", value: val };
        else if (isDate3(val))
          return { type: "date", value: val };
        else if (isWidget(val))
          return { type: "widget", value: val };
        else if (isArray2(val))
          return { type: "array", value: val };
        else if (isLink(val))
          return { type: "link", value: val };
        else if (isFunction(val))
          return { type: "function", value: val };
        else if (isHtml(val))
          return { type: "html", value: val };
        else if (isObject2(val))
          return { type: "object", value: val };
        else
          return void 0;
      }
      Values2.wrapValue = wrapValue;
      function mapLeaves(val, func) {
        if (isObject2(val)) {
          let result = {};
          for (let [key, value] of Object.entries(val))
            result[key] = mapLeaves(value, func);
          return result;
        } else if (isArray2(val)) {
          let result = [];
          for (let value of val)
            result.push(mapLeaves(value, func));
          return result;
        } else {
          return func(val);
        }
      }
      Values2.mapLeaves = mapLeaves;
      function compareValue(val1, val2, linkNormalizer) {
        var _a, _b;
        if (val1 === void 0)
          val1 = null;
        if (val2 === void 0)
          val2 = null;
        if (val1 === null && val2 === null)
          return 0;
        else if (val1 === null)
          return -1;
        else if (val2 === null)
          return 1;
        let wrap1 = wrapValue(val1);
        let wrap2 = wrapValue(val2);
        if (wrap1 === void 0 && wrap2 === void 0)
          return 0;
        else if (wrap1 === void 0)
          return -1;
        else if (wrap2 === void 0)
          return 1;
        if (wrap1.type != wrap2.type)
          return wrap1.type.localeCompare(wrap2.type);
        if (wrap1.value === wrap2.value)
          return 0;
        switch (wrap1.type) {
          case "string":
            return wrap1.value.localeCompare(wrap2.value);
          case "number":
            if (wrap1.value < wrap2.value)
              return -1;
            else if (wrap1.value == wrap2.value)
              return 0;
            return 1;
          case "null":
            return 0;
          case "boolean":
            if (wrap1.value == wrap2.value)
              return 0;
            else
              return wrap1.value ? 1 : -1;
          case "link":
            let link1 = wrap1.value;
            let link2 = wrap2.value;
            let normalize = linkNormalizer != null ? linkNormalizer : (x4) => x4;
            let pathCompare = normalize(link1.path).localeCompare(normalize(link2.path));
            if (pathCompare != 0)
              return pathCompare;
            let typeCompare = link1.type.localeCompare(link2.type);
            if (typeCompare != 0)
              return typeCompare;
            if (link1.subpath && !link2.subpath)
              return 1;
            if (!link1.subpath && link2.subpath)
              return -1;
            if (!link1.subpath && !link2.subpath)
              return 0;
            return ((_a = link1.subpath) != null ? _a : "").localeCompare((_b = link2.subpath) != null ? _b : "");
          case "date":
            return wrap1.value < wrap2.value ? -1 : wrap1.value.equals(wrap2.value) ? 0 : 1;
          case "duration":
            return wrap1.value < wrap2.value ? -1 : wrap1.value.equals(wrap2.value) ? 0 : 1;
          case "array":
            let f1 = wrap1.value;
            let f22 = wrap2.value;
            for (let index8 = 0; index8 < Math.min(f1.length, f22.length); index8++) {
              let comp = compareValue(f1[index8], f22[index8]);
              if (comp != 0)
                return comp;
            }
            return f1.length - f22.length;
          case "object":
            let o1 = wrap1.value;
            let o2 = wrap2.value;
            let k1 = Array.from(Object.keys(o1));
            let k22 = Array.from(Object.keys(o2));
            k1.sort();
            k22.sort();
            let keyCompare = compareValue(k1, k22);
            if (keyCompare != 0)
              return keyCompare;
            for (let key of k1) {
              let comp = compareValue(o1[key], o2[key]);
              if (comp != 0)
                return comp;
            }
            return 0;
          case "widget":
          case "html":
          case "function":
            return 0;
        }
      }
      Values2.compareValue = compareValue;
      function typeOf(val) {
        var _a;
        return (_a = wrapValue(val)) == null ? void 0 : _a.type;
      }
      Values2.typeOf = typeOf;
      function isTruthy2(field) {
        let wrapped = wrapValue(field);
        if (!wrapped)
          return false;
        switch (wrapped.type) {
          case "number":
            return wrapped.value != 0;
          case "string":
            return wrapped.value.length > 0;
          case "boolean":
            return wrapped.value;
          case "link":
            return !!wrapped.value.path;
          case "date":
            return wrapped.value.toMillis() != 0;
          case "duration":
            return wrapped.value.as("seconds") != 0;
          case "object":
            return Object.keys(wrapped.value).length > 0;
          case "array":
            return wrapped.value.length > 0;
          case "null":
            return false;
          case "html":
          case "widget":
          case "function":
            return true;
        }
      }
      Values2.isTruthy = isTruthy2;
      function deepCopy(field) {
        if (field === null || field === void 0)
          return field;
        if (Values2.isArray(field)) {
          return [].concat(field.map((v3) => deepCopy(v3)));
        } else if (Values2.isObject(field)) {
          let result = {};
          for (let [key, value] of Object.entries(field))
            result[key] = deepCopy(value);
          return result;
        } else {
          return field;
        }
      }
      Values2.deepCopy = deepCopy;
      function isString2(val) {
        return typeof val == "string";
      }
      Values2.isString = isString2;
      function isNumber3(val) {
        return typeof val == "number";
      }
      Values2.isNumber = isNumber3;
      function isDate3(val) {
        return val instanceof DateTime2;
      }
      Values2.isDate = isDate3;
      function isDuration(val) {
        return val instanceof Duration;
      }
      Values2.isDuration = isDuration;
      function isNull(val) {
        return val === null || val === void 0;
      }
      Values2.isNull = isNull;
      function isArray2(val) {
        return Array.isArray(val);
      }
      Values2.isArray = isArray2;
      function isBoolean(val) {
        return typeof val === "boolean";
      }
      Values2.isBoolean = isBoolean;
      function isLink(val) {
        return val instanceof Link;
      }
      Values2.isLink = isLink;
      function isWidget(val) {
        return val instanceof Widget;
      }
      Values2.isWidget = isWidget;
      function isHtml(val) {
        if (typeof HTMLElement !== "undefined") {
          return val instanceof HTMLElement;
        } else {
          return false;
        }
      }
      Values2.isHtml = isHtml;
      function isObject2(val) {
        return typeof val == "object" && !isHtml(val) && !isWidget(val) && !isArray2(val) && !isDuration(val) && !isDate3(val) && !isLink(val) && val !== void 0 && !isNull(val);
      }
      Values2.isObject = isObject2;
      function isFunction(val) {
        return typeof val == "function";
      }
      Values2.isFunction = isFunction;
    })(Values || (Values = {}));
    var Groupings;
    (function(Groupings2) {
      function isElementGroup(entry) {
        return Values.isObject(entry) && Object.keys(entry).length == 2 && "key" in entry && "rows" in entry;
      }
      Groupings2.isElementGroup = isElementGroup;
      function isGrouping(entry) {
        for (let element of entry)
          if (!isElementGroup(element))
            return false;
        return true;
      }
      Groupings2.isGrouping = isGrouping;
      function count(elements) {
        if (isGrouping(elements)) {
          let result = 0;
          for (let subgroup of elements)
            result += count(subgroup.rows);
          return result;
        } else {
          return elements.length;
        }
      }
      Groupings2.count = count;
    })(Groupings || (Groupings = {}));
    var Link = class {
      constructor(fields) {
        /** The file path this link points to. */
        __publicField(this, "path");
        /** The display name associated with the link. */
        __publicField(this, "display");
        /** The block ID or header this link points to within a file, if relevant. */
        __publicField(this, "subpath");
        /** Is this link an embedded link (!)? */
        __publicField(this, "embed");
        /** The type of this link, which determines what 'subpath' refers to, if anything. */
        __publicField(this, "type");
        Object.assign(this, fields);
      }
      /** Create a link to a specific file. */
      static file(path, embed = false, display2) {
        return new Link({
          path,
          embed,
          display: display2,
          subpath: void 0,
          type: "file"
        });
      }
      static infer(linkpath, embed = false, display2) {
        if (linkpath.includes("#^")) {
          let split2 = linkpath.split("#^");
          return Link.block(split2[0], split2[1], embed, display2);
        } else if (linkpath.includes("#")) {
          let split2 = linkpath.split("#");
          return Link.header(split2[0], split2[1], embed, display2);
        } else
          return Link.file(linkpath, embed, display2);
      }
      /** Create a link to a specific file and header in that file. */
      static header(path, header, embed, display2) {
        return new Link({
          path,
          embed,
          display: display2,
          subpath: normalizeHeaderForLink(header),
          type: "header"
        });
      }
      /** Create a link to a specific file and block in that file. */
      static block(path, blockId, embed, display2) {
        return new Link({
          path,
          embed,
          display: display2,
          subpath: blockId,
          type: "block"
        });
      }
      static fromObject(object) {
        return new Link(object);
      }
      /** Checks for link equality (i.e., that the links are pointing to the same exact location). */
      equals(other) {
        if (other == void 0 || other == null)
          return false;
        return this.path == other.path && this.type == other.type && this.subpath == other.subpath;
      }
      /** Convert this link to it's markdown representation. */
      toString() {
        return this.markdown();
      }
      /** Convert this link to a raw object which is serialization-friendly. */
      toObject() {
        return { path: this.path, type: this.type, subpath: this.subpath, display: this.display, embed: this.embed };
      }
      /** Update this link with a new path. */
      //@ts-ignore; error appeared after updating Obsidian to 0.15.4; it also updated other packages but didn't say which
      withPath(path) {
        return new Link(Object.assign({}, this, { path }));
      }
      /** Return a new link which points to the same location but with a new display value. */
      withDisplay(display2) {
        return new Link(Object.assign({}, this, { display: display2 }));
      }
      /** Convert a file link into a link to a specific header. */
      withHeader(header) {
        return Link.header(this.path, header, this.embed, this.display);
      }
      /** Convert any link into a link to its file. */
      toFile() {
        return Link.file(this.path, this.embed, this.display);
      }
      /** Convert this link into an embedded link. */
      toEmbed() {
        if (this.embed) {
          return this;
        } else {
          let link = new Link(this);
          link.embed = true;
          return link;
        }
      }
      /** Convert this link into a non-embedded link. */
      fromEmbed() {
        if (!this.embed) {
          return this;
        } else {
          let link = new Link(this);
          link.embed = false;
          return link;
        }
      }
      /** Convert this link to markdown so it can be rendered. */
      markdown() {
        let result = (this.embed ? "!" : "") + "[[" + this.obsidianLink();
        if (this.display) {
          result += "|" + this.display;
        } else {
          result += "|" + getFileTitle(this.path);
          if (this.type == "header" || this.type == "block")
            result += " > " + this.subpath;
        }
        result += "]]";
        return result;
      }
      /** Convert the inner part of the link to something that Obsidian can open / understand. */
      obsidianLink() {
        var _a, _b;
        const escaped = this.path.replaceAll("|", "\\|");
        if (this.type == "header")
          return escaped + "#" + ((_a = this.subpath) == null ? void 0 : _a.replaceAll("|", "\\|"));
        if (this.type == "block")
          return escaped + "#^" + ((_b = this.subpath) == null ? void 0 : _b.replaceAll("|", "\\|"));
        else
          return escaped;
      }
      /** The stripped name of the file this link points to. */
      fileName() {
        return getFileTitle(this.path).replace(".md", "");
      }
    };
    var Widget = class {
      constructor($widget) {
        __publicField(this, "$widget");
        this.$widget = $widget;
      }
    };
    var ListPairWidget = class extends Widget {
      constructor(key, value) {
        super("dataview:list-pair");
        __publicField(this, "key");
        __publicField(this, "value");
        this.key = key;
        this.value = value;
      }
      markdown() {
        return `${Values.toString(this.key)}: ${Values.toString(this.value)}`;
      }
    };
    var ExternalLinkWidget = class extends Widget {
      constructor(url, display2) {
        super("dataview:external-link");
        __publicField(this, "url");
        __publicField(this, "display");
        this.url = url;
        this.display = display2;
      }
      markdown() {
        var _a;
        return `[${(_a = this.display) != null ? _a : this.url}](${this.url})`;
      }
    };
    var Widgets;
    (function(Widgets2) {
      function listPair(key, value) {
        return new ListPairWidget(key, value);
      }
      Widgets2.listPair = listPair;
      function externalLink(url, display2) {
        return new ExternalLinkWidget(url, display2);
      }
      Widgets2.externalLink = externalLink;
      function isListPair(widget) {
        return widget.$widget === "dataview:list-pair";
      }
      Widgets2.isListPair = isListPair;
      function isExternalLink(widget) {
        return widget.$widget === "dataview:external-link";
      }
      Widgets2.isExternalLink = isExternalLink;
      function isBuiltin(widget) {
        return isListPair(widget) || isExternalLink(widget);
      }
      Widgets2.isBuiltin = isBuiltin;
    })(Widgets || (Widgets = {}));
    var Fields;
    (function(Fields2) {
      function variable(name) {
        return { type: "variable", name };
      }
      Fields2.variable = variable;
      function literal(value) {
        return { type: "literal", value };
      }
      Fields2.literal = literal;
      function binaryOp(left, op, right) {
        return { type: "binaryop", left, op, right };
      }
      Fields2.binaryOp = binaryOp;
      function index8(obj, index9) {
        return { type: "index", object: obj, index: index9 };
      }
      Fields2.index = index8;
      function indexVariable(name) {
        let parts = name.split(".");
        let result = Fields2.variable(parts[0]);
        for (let index9 = 1; index9 < parts.length; index9++) {
          result = Fields2.index(result, Fields2.literal(parts[index9]));
        }
        return result;
      }
      Fields2.indexVariable = indexVariable;
      function lambda(args, value) {
        return { type: "lambda", arguments: args, value };
      }
      Fields2.lambda = lambda;
      function func(func2, args) {
        return { type: "function", func: func2, arguments: args };
      }
      Fields2.func = func;
      function list(values) {
        return { type: "list", values };
      }
      Fields2.list = list;
      function object(values) {
        return { type: "object", values };
      }
      Fields2.object = object;
      function negate(child) {
        return { type: "negated", child };
      }
      Fields2.negate = negate;
      function isCompareOp(op) {
        return op == "<=" || op == "<" || op == ">" || op == ">=" || op == "!=" || op == "=";
      }
      Fields2.isCompareOp = isCompareOp;
      Fields2.NULL = Fields2.literal(null);
    })(Fields || (Fields = {}));
    var Sources;
    (function(Sources2) {
      function tag(tag2) {
        return { type: "tag", tag: tag2 };
      }
      Sources2.tag = tag;
      function csv(path) {
        return { type: "csv", path };
      }
      Sources2.csv = csv;
      function folder(prefix) {
        return { type: "folder", folder: prefix };
      }
      Sources2.folder = folder;
      function link(file, incoming) {
        return { type: "link", file, direction: incoming ? "incoming" : "outgoing" };
      }
      Sources2.link = link;
      function binaryOp(left, op, right) {
        return { type: "binaryop", left, op, right };
      }
      Sources2.binaryOp = binaryOp;
      function and(left, right) {
        return { type: "binaryop", left, op: "&", right };
      }
      Sources2.and = and;
      function or(left, right) {
        return { type: "binaryop", left, op: "|", right };
      }
      Sources2.or = or;
      function negate(child) {
        return { type: "negate", child };
      }
      Sources2.negate = negate;
      function empty2() {
        return { type: "empty" };
      }
      Sources2.empty = empty2;
    })(Sources || (Sources = {}));
    var EMOJI_REGEX = new RegExp(emojiRegex(), "");
    var DURATION_TYPES = {
      year: Duration.fromObject({ years: 1 }),
      years: Duration.fromObject({ years: 1 }),
      yr: Duration.fromObject({ years: 1 }),
      yrs: Duration.fromObject({ years: 1 }),
      month: Duration.fromObject({ months: 1 }),
      months: Duration.fromObject({ months: 1 }),
      mo: Duration.fromObject({ months: 1 }),
      mos: Duration.fromObject({ months: 1 }),
      week: Duration.fromObject({ weeks: 1 }),
      weeks: Duration.fromObject({ weeks: 1 }),
      wk: Duration.fromObject({ weeks: 1 }),
      wks: Duration.fromObject({ weeks: 1 }),
      w: Duration.fromObject({ weeks: 1 }),
      day: Duration.fromObject({ days: 1 }),
      days: Duration.fromObject({ days: 1 }),
      d: Duration.fromObject({ days: 1 }),
      hour: Duration.fromObject({ hours: 1 }),
      hours: Duration.fromObject({ hours: 1 }),
      hr: Duration.fromObject({ hours: 1 }),
      hrs: Duration.fromObject({ hours: 1 }),
      h: Duration.fromObject({ hours: 1 }),
      minute: Duration.fromObject({ minutes: 1 }),
      minutes: Duration.fromObject({ minutes: 1 }),
      min: Duration.fromObject({ minutes: 1 }),
      mins: Duration.fromObject({ minutes: 1 }),
      m: Duration.fromObject({ minutes: 1 }),
      second: Duration.fromObject({ seconds: 1 }),
      seconds: Duration.fromObject({ seconds: 1 }),
      sec: Duration.fromObject({ seconds: 1 }),
      secs: Duration.fromObject({ seconds: 1 }),
      s: Duration.fromObject({ seconds: 1 })
    };
    var DATE_SHORTHANDS = {
      now: () => DateTime2.local(),
      today: () => DateTime2.local().startOf("day"),
      yesterday: () => DateTime2.local().startOf("day").minus(Duration.fromObject({ days: 1 })),
      tomorrow: () => DateTime2.local().startOf("day").plus(Duration.fromObject({ days: 1 })),
      sow: () => DateTime2.local().startOf("week"),
      "start-of-week": () => DateTime2.local().startOf("week"),
      eow: () => DateTime2.local().endOf("week"),
      "end-of-week": () => DateTime2.local().endOf("week"),
      soy: () => DateTime2.local().startOf("year"),
      "start-of-year": () => DateTime2.local().startOf("year"),
      eoy: () => DateTime2.local().endOf("year"),
      "end-of-year": () => DateTime2.local().endOf("year"),
      som: () => DateTime2.local().startOf("month"),
      "start-of-month": () => DateTime2.local().startOf("month"),
      eom: () => DateTime2.local().endOf("month"),
      "end-of-month": () => DateTime2.local().endOf("month")
    };
    var KEYWORDS = ["FROM", "WHERE", "LIMIT", "GROUP", "FLATTEN"];
    function splitOnUnescapedPipe(link) {
      let pipe = -1;
      while ((pipe = link.indexOf("|", pipe + 1)) >= 0) {
        if (pipe > 0 && link[pipe - 1] == "\\")
          continue;
        return [link.substring(0, pipe).replace(/\\\|/g, "|"), link.substring(pipe + 1)];
      }
      return [link.replace(/\\\|/g, "|"), void 0];
    }
    function parseInnerLink(rawlink) {
      let [link, display2] = splitOnUnescapedPipe(rawlink);
      return Link.infer(link, false, display2);
    }
    function createBinaryParser(child, sep, combine2) {
      return parsimmon_umd_minExports.seqMap(child, parsimmon_umd_minExports.seq(parsimmon_umd_minExports.optWhitespace, sep, parsimmon_umd_minExports.optWhitespace, child).many(), (first, rest) => {
        if (rest.length == 0)
          return first;
        let node = combine2(first, rest[0][1], rest[0][3]);
        for (let index8 = 1; index8 < rest.length; index8++) {
          node = combine2(node, rest[index8][1], rest[index8][3]);
        }
        return node;
      });
    }
    function chainOpt(base, ...funcs) {
      return parsimmon_umd_minExports.custom((success, failure) => {
        return (input, i3) => {
          let result = base._(input, i3);
          if (!result.status)
            return result;
          for (let func of funcs) {
            let next = func(result.value)._(input, result.index);
            if (!next.status)
              return result;
            result = next;
          }
          return result;
        };
      });
    }
    var EXPRESSION = parsimmon_umd_minExports.createLanguage({
      // A floating point number; the decimal point is optional.
      number: (q3) => parsimmon_umd_minExports.regexp(/-?[0-9]+(\.[0-9]+)?/).map((str) => Number.parseFloat(str)).desc("number"),
      // A quote-surrounded string which supports escape characters ('\').
      string: (q3) => parsimmon_umd_minExports.string('"').then(parsimmon_umd_minExports.alt(q3.escapeCharacter, parsimmon_umd_minExports.noneOf('"\\')).atLeast(0).map((chars) => chars.join(""))).skip(parsimmon_umd_minExports.string('"')).desc("string"),
      escapeCharacter: (_3) => parsimmon_umd_minExports.string("\\").then(parsimmon_umd_minExports.any).map((escaped) => {
        if (escaped === '"')
          return '"';
        if (escaped === "\\")
          return "\\";
        else
          return "\\" + escaped;
      }),
      // A boolean true/false value.
      bool: (_3) => parsimmon_umd_minExports.regexp(/true|false|True|False/).map((str) => str.toLowerCase() == "true").desc("boolean ('true' or 'false')"),
      // A tag of the form '#stuff/hello-there'.
      tag: (_3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("#"), parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regexp(/[^\u2000-\u206F\u2E00-\u2E7F'!"#$%&()*+,.:;<=>?@^`{|}~\[\]\\\s]/).desc("text")).many(), (start, rest) => start + rest.join("")).desc("tag ('#hello/stuff')"),
      // A variable identifier, which is alphanumeric and must start with a letter or... emoji.
      identifier: (_3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regexp(/\p{Letter}/u), parsimmon_umd_minExports.regexp(EMOJI_REGEX).desc("text")), parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regexp(/[0-9\p{Letter}_-]/u), parsimmon_umd_minExports.regexp(EMOJI_REGEX).desc("text")).many(), (first, rest) => first + rest.join("")).desc("variable identifier"),
      // An Obsidian link of the form [[<link>]].
      link: (_3) => parsimmon_umd_minExports.regexp(/\[\[([^\[\]]*?)\]\]/u, 1).map((linkInner) => parseInnerLink(linkInner)).desc("file link"),
      // An embeddable link which can start with '!'. This overlaps with the normal negation operator, so it is only
      // provided for metadata parsing.
      embedLink: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("!").atMost(1), q3.link, (p3, l4) => {
        if (p3.length > 0)
          l4.embed = true;
        return l4;
      }).desc("file link"),
      // Binary plus or minus operator.
      binaryPlusMinus: (_3) => parsimmon_umd_minExports.regexp(/\+|-/).map((str) => str).desc("'+' or '-'"),
      // Binary times or divide operator.
      binaryMulDiv: (_3) => parsimmon_umd_minExports.regexp(/\*|\/|%/).map((str) => str).desc("'*' or '/' or '%'"),
      // Binary comparison operator.
      binaryCompareOp: (_3) => parsimmon_umd_minExports.regexp(/>=|<=|!=|>|<|=/).map((str) => str).desc("'>=' or '<=' or '!=' or '=' or '>' or '<'"),
      // Binary boolean combination operator.
      binaryBooleanOp: (_3) => parsimmon_umd_minExports.regexp(/and|or|&|\|/i).map((str) => {
        if (str.toLowerCase() == "and")
          return "&";
        else if (str.toLowerCase() == "or")
          return "|";
        else
          return str;
      }).desc("'and' or 'or'"),
      // A date which can be YYYY-MM[-DDTHH:mm:ss].
      rootDate: (_3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/\d{4}/), parsimmon_umd_minExports.string("-"), parsimmon_umd_minExports.regexp(/\d{2}/), (year, _4, month) => {
        return DateTime2.fromObject({ year: Number.parseInt(year), month: Number.parseInt(month) });
      }).desc("date in format YYYY-MM[-DDTHH-MM-SS.MS]"),
      dateShorthand: (_3) => parsimmon_umd_minExports.alt(...Object.keys(DATE_SHORTHANDS).sort((a3, b3) => b3.length - a3.length).map(parsimmon_umd_minExports.string)),
      date: (q3) => chainOpt(q3.rootDate, (ym) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("-"), parsimmon_umd_minExports.regexp(/\d{2}/), (_3, day) => ym.set({ day: Number.parseInt(day) })), (ymd) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("T"), parsimmon_umd_minExports.regexp(/\d{2}/), (_3, hour) => ymd.set({ hour: Number.parseInt(hour) })), (ymdh) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string(":"), parsimmon_umd_minExports.regexp(/\d{2}/), (_3, minute) => ymdh.set({ minute: Number.parseInt(minute) })), (ymdhm) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string(":"), parsimmon_umd_minExports.regexp(/\d{2}/), (_3, second) => ymdhm.set({ second: Number.parseInt(second) })), (ymdhms) => parsimmon_umd_minExports.alt(
        parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("."), parsimmon_umd_minExports.regexp(/\d{3}/), (_3, millisecond) => ymdhms.set({ millisecond: Number.parseInt(millisecond) })),
        parsimmon_umd_minExports.succeed(ymdhms)
        // pass
      ), (dt) => parsimmon_umd_minExports.alt(parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("+").or(parsimmon_umd_minExports.string("-")), parsimmon_umd_minExports.regexp(/\d{1,2}(:\d{2})?/), (pm, hr) => dt.setZone("UTC" + pm + hr, { keepLocalTime: true })), parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("Z"), () => dt.setZone("utc", { keepLocalTime: true })), parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("["), parsimmon_umd_minExports.regexp(/[0-9A-Za-z+-\/]+/u), parsimmon_umd_minExports.string("]"), (_a, zone, _b) => dt.setZone(zone, { keepLocalTime: true })))).assert((dt) => dt.isValid, "valid date").desc("date in format YYYY-MM[-DDTHH-MM-SS.MS]"),
      // A date, plus various shorthand times of day it could be.
      datePlus: (q3) => parsimmon_umd_minExports.alt(q3.dateShorthand.map((d2) => DATE_SHORTHANDS[d2]()), q3.date).desc("date in format YYYY-MM[-DDTHH-MM-SS.MS] or in shorthand"),
      // A duration of time.
      durationType: (_3) => parsimmon_umd_minExports.alt(...Object.keys(DURATION_TYPES).sort((a3, b3) => b3.length - a3.length).map(parsimmon_umd_minExports.string)),
      duration: (q3) => parsimmon_umd_minExports.seqMap(q3.number, parsimmon_umd_minExports.optWhitespace, q3.durationType, (count, _3, t3) => DURATION_TYPES[t3].mapUnits((x4) => x4 * count)).sepBy1(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace).or(parsimmon_umd_minExports.optWhitespace)).map((durations) => durations.reduce((p3, c3) => p3.plus(c3))).desc("duration like 4hr2min"),
      // A raw null value.
      rawNull: (_3) => parsimmon_umd_minExports.string("null"),
      // Source parsing.
      tagSource: (q3) => q3.tag.map((tag) => Sources.tag(tag)),
      csvSource: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("csv(").skip(parsimmon_umd_minExports.optWhitespace), q3.string, parsimmon_umd_minExports.string(")"), (_1, path, _22) => Sources.csv(path)),
      linkIncomingSource: (q3) => q3.link.map((link) => Sources.link(link.path, true)),
      linkOutgoingSource: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("outgoing(").skip(parsimmon_umd_minExports.optWhitespace), q3.link, parsimmon_umd_minExports.string(")"), (_1, link, _22) => Sources.link(link.path, false)),
      folderSource: (q3) => q3.string.map((str) => Sources.folder(str)),
      parensSource: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("("), parsimmon_umd_minExports.optWhitespace, q3.source, parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string(")"), (_1, _22, field, _3, _4) => field),
      negateSource: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.alt(parsimmon_umd_minExports.string("-"), parsimmon_umd_minExports.string("!")), q3.atomSource, (_3, source) => Sources.negate(source)),
      atomSource: (q3) => parsimmon_umd_minExports.alt(q3.parensSource, q3.negateSource, q3.linkOutgoingSource, q3.linkIncomingSource, q3.folderSource, q3.tagSource, q3.csvSource),
      binaryOpSource: (q3) => createBinaryParser(q3.atomSource, q3.binaryBooleanOp.map((s4) => s4), Sources.binaryOp),
      source: (q3) => q3.binaryOpSource,
      // Field parsing.
      variableField: (q3) => q3.identifier.chain((r3) => {
        if (KEYWORDS.includes(r3.toUpperCase())) {
          return parsimmon_umd_minExports.fail("Variable fields cannot be a keyword (" + KEYWORDS.join(" or ") + ")");
        } else {
          return parsimmon_umd_minExports.succeed(Fields.variable(r3));
        }
      }).desc("variable"),
      numberField: (q3) => q3.number.map((val) => Fields.literal(val)).desc("number"),
      stringField: (q3) => q3.string.map((val) => Fields.literal(val)).desc("string"),
      boolField: (q3) => q3.bool.map((val) => Fields.literal(val)).desc("boolean"),
      dateField: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("date("), parsimmon_umd_minExports.optWhitespace, q3.datePlus, parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string(")"), (prefix, _1, date, _22, postfix) => Fields.literal(date)).desc("date"),
      durationField: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("dur("), parsimmon_umd_minExports.optWhitespace, q3.duration, parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string(")"), (prefix, _1, dur, _22, postfix) => Fields.literal(dur)).desc("duration"),
      nullField: (q3) => q3.rawNull.map((_3) => Fields.NULL),
      linkField: (q3) => q3.link.map((f3) => Fields.literal(f3)),
      listField: (q3) => q3.field.sepBy(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)).wrap(parsimmon_umd_minExports.string("[").skip(parsimmon_umd_minExports.optWhitespace), parsimmon_umd_minExports.optWhitespace.then(parsimmon_umd_minExports.string("]"))).map((l4) => Fields.list(l4)).desc("list ('[1, 2, 3]')"),
      objectField: (q3) => parsimmon_umd_minExports.seqMap(q3.identifier.or(q3.string), parsimmon_umd_minExports.string(":").trim(parsimmon_umd_minExports.optWhitespace), q3.field, (name, _sep, value) => {
        return { name, value };
      }).sepBy(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)).wrap(parsimmon_umd_minExports.string("{").skip(parsimmon_umd_minExports.optWhitespace), parsimmon_umd_minExports.optWhitespace.then(parsimmon_umd_minExports.string("}"))).map((vals) => {
        let res = {};
        for (let entry of vals)
          res[entry.name] = entry.value;
        return Fields.object(res);
      }).desc("object ('{ a: 1, b: 2 }')"),
      atomInlineField: (q3) => parsimmon_umd_minExports.alt(q3.date, q3.duration.map((d2) => normalizeDuration(d2)), q3.string, q3.tag, q3.embedLink, q3.bool, q3.number, q3.rawNull),
      inlineFieldList: (q3) => q3.atomInlineField.sepBy(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace).lookahead(q3.atomInlineField)),
      inlineField: (q3) => parsimmon_umd_minExports.alt(parsimmon_umd_minExports.seqMap(q3.atomInlineField, parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace), q3.inlineFieldList, (f3, _s, l4) => [f3].concat(l4)), q3.atomInlineField),
      atomField: (q3) => parsimmon_umd_minExports.alt(
        // Place embed links above negated fields as they are the special parser case '![[thing]]' and are generally unambigious.
        q3.embedLink.map((l4) => Fields.literal(l4)),
        q3.negatedField,
        q3.linkField,
        q3.listField,
        q3.objectField,
        q3.lambdaField,
        q3.parensField,
        q3.boolField,
        q3.numberField,
        q3.stringField,
        q3.dateField,
        q3.durationField,
        q3.nullField,
        q3.variableField
      ),
      indexField: (q3) => parsimmon_umd_minExports.seqMap(q3.atomField, parsimmon_umd_minExports.alt(q3.dotPostfix, q3.indexPostfix, q3.functionPostfix).many(), (obj, postfixes) => {
        let result = obj;
        for (let post of postfixes) {
          switch (post.type) {
            case "dot":
              result = Fields.index(result, Fields.literal(post.field));
              break;
            case "index":
              result = Fields.index(result, post.field);
              break;
            case "function":
              result = Fields.func(result, post.fields);
              break;
          }
        }
        return result;
      }),
      negatedField: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("!"), q3.indexField, (_3, field) => Fields.negate(field)).desc("negated field"),
      parensField: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("("), parsimmon_umd_minExports.optWhitespace, q3.field, parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string(")"), (_1, _22, field, _3, _4) => field),
      lambdaField: (q3) => parsimmon_umd_minExports.seqMap(q3.identifier.sepBy(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)).wrap(parsimmon_umd_minExports.string("(").trim(parsimmon_umd_minExports.optWhitespace), parsimmon_umd_minExports.string(")").trim(parsimmon_umd_minExports.optWhitespace)), parsimmon_umd_minExports.string("=>").trim(parsimmon_umd_minExports.optWhitespace), q3.field, (ident, _ignore, value) => {
        return { type: "lambda", arguments: ident, value };
      }),
      dotPostfix: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("."), q3.identifier, (_3, field) => {
        return { type: "dot", field };
      }),
      indexPostfix: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("["), parsimmon_umd_minExports.optWhitespace, q3.field, parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string("]"), (_3, _22, field, _32, _4) => {
        return { type: "index", field };
      }),
      functionPostfix: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("("), parsimmon_umd_minExports.optWhitespace, q3.field.sepBy(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)), parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string(")"), (_3, _1, fields, _22, _32) => {
        return { type: "function", fields };
      }),
      // The precedence hierarchy of operators - multiply/divide, add/subtract, compare, and then boolean operations.
      binaryMulDivField: (q3) => createBinaryParser(q3.indexField, q3.binaryMulDiv, Fields.binaryOp),
      binaryPlusMinusField: (q3) => createBinaryParser(q3.binaryMulDivField, q3.binaryPlusMinus, Fields.binaryOp),
      binaryCompareField: (q3) => createBinaryParser(q3.binaryPlusMinusField, q3.binaryCompareOp, Fields.binaryOp),
      binaryBooleanField: (q3) => createBinaryParser(q3.binaryCompareField, q3.binaryBooleanOp, Fields.binaryOp),
      binaryOpField: (q3) => q3.binaryBooleanField,
      field: (q3) => q3.binaryOpField
    });
    function parseField(text) {
      try {
        return Result.success(EXPRESSION.field.tryParse(text));
      } catch (error) {
        return Result.failure("" + error);
      }
    }
    var QueryFields;
    (function(QueryFields2) {
      function named(name, field) {
        return { name, field };
      }
      QueryFields2.named = named;
      function sortBy(field, dir) {
        return { field, direction: dir };
      }
      QueryFields2.sortBy = sortBy;
    })(QueryFields || (QueryFields = {}));
    function captureRaw(base) {
      return parsimmon_umd_minExports.custom((success, failure) => {
        return (input, i3) => {
          let result = base._(input, i3);
          if (!result.status)
            return result;
          return Object.assign({}, result, { value: [result.value, input.substring(i3, result.index)] });
        };
      });
    }
    function stripNewlines(text) {
      return text.split(/[\r\n]+/).map((t3) => t3.trim()).join("");
    }
    function precededByWhitespaceIfNotEof(if_eof, parser) {
      return parsimmon_umd_minExports.eof.map(if_eof).or(parsimmon_umd_minExports.whitespace.then(parser));
    }
    var QUERY_LANGUAGE = parsimmon_umd_minExports.createLanguage({
      // Simple atom parsing, like words, identifiers, numbers.
      queryType: (q3) => parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regexp(/TABLE|LIST|TASK|CALENDAR/i)).map((str) => str.toLowerCase()).desc("query type ('TABLE', 'LIST', 'TASK', or 'CALENDAR')"),
      explicitNamedField: (q3) => parsimmon_umd_minExports.seqMap(EXPRESSION.field.skip(parsimmon_umd_minExports.whitespace), parsimmon_umd_minExports.regexp(/AS/i).skip(parsimmon_umd_minExports.whitespace), EXPRESSION.identifier.or(EXPRESSION.string), (field, _as, ident) => QueryFields.named(ident, field)),
      comment: () => parsimmon_umd_minExports.Parser((input, i3) => {
        let line = input.substring(i3);
        if (!line.startsWith("//"))
          return parsimmon_umd_minExports.makeFailure(i3, "Not a comment");
        line = line.split("\n")[0];
        let comment = line.substring(2).trim();
        return parsimmon_umd_minExports.makeSuccess(i3 + line.length, comment);
      }),
      namedField: (q3) => parsimmon_umd_minExports.alt(q3.explicitNamedField, captureRaw(EXPRESSION.field).map(([value, text]) => QueryFields.named(stripNewlines(text), value))),
      sortField: (q3) => parsimmon_umd_minExports.seqMap(EXPRESSION.field.skip(parsimmon_umd_minExports.optWhitespace), parsimmon_umd_minExports.regexp(/ASCENDING|DESCENDING|ASC|DESC/i).atMost(1), (field, dir) => {
        let direction = dir.length == 0 ? "ascending" : dir[0].toLowerCase();
        if (direction == "desc")
          direction = "descending";
        if (direction == "asc")
          direction = "ascending";
        return {
          field,
          direction
        };
      }),
      headerClause: (q3) => q3.queryType.chain((type) => {
        switch (type) {
          case "table": {
            return precededByWhitespaceIfNotEof(() => ({ type, fields: [], showId: true }), parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/WITHOUT\s+ID/i).skip(parsimmon_umd_minExports.optWhitespace).atMost(1), parsimmon_umd_minExports.sepBy(q3.namedField, parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)), (withoutId, fields) => {
              return { type, fields, showId: withoutId.length == 0 };
            }));
          }
          case "list":
            return precededByWhitespaceIfNotEof(() => ({ type, format: void 0, showId: true }), parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/WITHOUT\s+ID/i).skip(parsimmon_umd_minExports.optWhitespace).atMost(1), EXPRESSION.field.atMost(1), (withoutId, format) => {
              return {
                type,
                format: format.length == 1 ? format[0] : void 0,
                showId: withoutId.length == 0
              };
            }));
          case "task":
            return parsimmon_umd_minExports.succeed({ type });
          case "calendar":
            return parsimmon_umd_minExports.whitespace.then(parsimmon_umd_minExports.seqMap(q3.namedField, (field) => {
              return {
                type,
                showId: true,
                field
              };
            }));
          default:
            return parsimmon_umd_minExports.fail(`Unrecognized query type '${type}'`);
        }
      }).desc("TABLE or LIST or TASK or CALENDAR"),
      fromClause: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/FROM/i), parsimmon_umd_minExports.whitespace, EXPRESSION.source, (_1, _22, source) => source),
      whereClause: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/WHERE/i), parsimmon_umd_minExports.whitespace, EXPRESSION.field, (where, _3, field) => {
        return { type: "where", clause: field };
      }).desc("WHERE <expression>"),
      sortByClause: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/SORT/i), parsimmon_umd_minExports.whitespace, q3.sortField.sepBy1(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)), (sort2, _1, fields) => {
        return { type: "sort", fields };
      }).desc("SORT field [ASC/DESC]"),
      limitClause: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/LIMIT/i), parsimmon_umd_minExports.whitespace, EXPRESSION.field, (limit, _1, field) => {
        return { type: "limit", amount: field };
      }).desc("LIMIT <value>"),
      flattenClause: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/FLATTEN/i).skip(parsimmon_umd_minExports.whitespace), q3.namedField, (_3, field) => {
        return { type: "flatten", field };
      }).desc("FLATTEN <value> [AS <name>]"),
      groupByClause: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/GROUP BY/i).skip(parsimmon_umd_minExports.whitespace), q3.namedField, (_3, field) => {
        return { type: "group", field };
      }).desc("GROUP BY <value> [AS <name>]"),
      // Full query parsing.
      clause: (q3) => parsimmon_umd_minExports.alt(q3.fromClause, q3.whereClause, q3.sortByClause, q3.limitClause, q3.groupByClause, q3.flattenClause),
      query: (q3) => parsimmon_umd_minExports.seqMap(q3.headerClause.trim(optionalWhitespaceOrComment), q3.fromClause.trim(optionalWhitespaceOrComment).atMost(1), q3.clause.trim(optionalWhitespaceOrComment).many(), (header, from, clauses) => {
        return {
          header,
          source: from.length == 0 ? Sources.folder("") : from[0],
          operations: clauses,
          settings: DEFAULT_QUERY_SETTINGS
        };
      })
    });
    var optionalWhitespaceOrComment = parsimmon_umd_minExports.alt(parsimmon_umd_minExports.whitespace, QUERY_LANGUAGE.comment).many().map((arr) => arr.join(""));
    var getAPI2 = (app) => {
      var _a;
      if (app)
        return (_a = app.plugins.plugins.dataview) == null ? void 0 : _a.api;
      else
        return window.DataviewAPI;
    };
    var isPluginEnabled = (app) => app.plugins.enabledPlugins.has("dataview");
    exports.DATE_SHORTHANDS = DATE_SHORTHANDS;
    exports.DURATION_TYPES = DURATION_TYPES;
    exports.EXPRESSION = EXPRESSION;
    exports.KEYWORDS = KEYWORDS;
    exports.QUERY_LANGUAGE = QUERY_LANGUAGE;
    exports.getAPI = getAPI2;
    exports.isPluginEnabled = isPluginEnabled;
    exports.parseField = parseField;
  }
});

// node_modules/ical.js/build/ical.js
var require_ical = __commonJS({
  "node_modules/ical.js/build/ical.js"(exports, module2) {
    var ICAL2;
    (function() {
      if (typeof module2 === "object") {
        ICAL2 = module2.exports;
      } else if (typeof HTMLScriptElement !== "undefined" && "noModule" in HTMLScriptElement.prototype) {
        window.ICAL = ICAL2 = {};
      } else if (typeof ICAL2 !== "object") {
        ICAL2 = {};
      }
    })();
    ICAL2.foldLength = 75;
    ICAL2.newLineChar = "\r\n";
    ICAL2.helpers = {
      /**
       * Compiles a list of all referenced TZIDs in all subcomponents and
       * removes any extra VTIMEZONE subcomponents. In addition, if any TZIDs
       * are referenced by a component, but a VTIMEZONE does not exist,
       * an attempt will be made to generate a VTIMEZONE using ICAL.TimezoneService.
       *
       * @param {ICAL.Component} vcal     The top-level VCALENDAR component.
       * @return {ICAL.Component}         The ICAL.Component that was passed in.
       */
      updateTimezones: function(vcal) {
        var allsubs, properties, vtimezones, reqTzid, i3, tzid;
        if (!vcal || vcal.name !== "vcalendar") {
          return vcal;
        }
        allsubs = vcal.getAllSubcomponents();
        properties = [];
        vtimezones = {};
        for (i3 = 0; i3 < allsubs.length; i3++) {
          if (allsubs[i3].name === "vtimezone") {
            tzid = allsubs[i3].getFirstProperty("tzid").getFirstValue();
            vtimezones[tzid] = allsubs[i3];
          } else {
            properties = properties.concat(allsubs[i3].getAllProperties());
          }
        }
        reqTzid = {};
        for (i3 = 0; i3 < properties.length; i3++) {
          if (tzid = properties[i3].getParameter("tzid")) {
            reqTzid[tzid] = true;
          }
        }
        for (i3 in vtimezones) {
          if (vtimezones.hasOwnProperty(i3) && !reqTzid[i3]) {
            vcal.removeSubcomponent(vtimezones[i3]);
          }
        }
        for (i3 in reqTzid) {
          if (reqTzid.hasOwnProperty(i3) && !vtimezones[i3] && ICAL2.TimezoneService.has(i3)) {
            vcal.addSubcomponent(ICAL2.TimezoneService.get(i3).component);
          }
        }
        return vcal;
      },
      /**
       * Checks if the given type is of the number type and also NaN.
       *
       * @param {Number} number     The number to check
       * @return {Boolean}          True, if the number is strictly NaN
       */
      isStrictlyNaN: function(number) {
        return typeof number === "number" && isNaN(number);
      },
      /**
       * Parses a string value that is expected to be an integer, when the valid is
       * not an integer throws a decoration error.
       *
       * @param {String} string     Raw string input
       * @return {Number}           Parsed integer
       */
      strictParseInt: function(string) {
        var result = parseInt(string, 10);
        if (ICAL2.helpers.isStrictlyNaN(result)) {
          throw new Error(
            'Could not extract integer from "' + string + '"'
          );
        }
        return result;
      },
      /**
       * Creates or returns a class instance of a given type with the initialization
       * data if the data is not already an instance of the given type.
       *
       * @example
       * var time = new ICAL.Time(...);
       * var result = ICAL.helpers.formatClassType(time, ICAL.Time);
       *
       * (result instanceof ICAL.Time)
       * // => true
       *
       * result = ICAL.helpers.formatClassType({}, ICAL.Time);
       * (result isntanceof ICAL.Time)
       * // => true
       *
       *
       * @param {Object} data       object initialization data
       * @param {Object} type       object type (like ICAL.Time)
       * @return {?}                An instance of the found type.
       */
      formatClassType: function formatClassType(data, type) {
        if (typeof data === "undefined") {
          return void 0;
        }
        if (data instanceof type) {
          return data;
        }
        return new type(data);
      },
      /**
       * Identical to indexOf but will only match values when they are not preceded
       * by a backslash character.
       *
       * @param {String} buffer         String to search
       * @param {String} search         Value to look for
       * @param {Number} pos            Start position
       * @return {Number}               The position, or -1 if not found
       */
      unescapedIndexOf: function(buffer, search, pos) {
        while ((pos = buffer.indexOf(search, pos)) !== -1) {
          if (pos > 0 && buffer[pos - 1] === "\\") {
            pos += 1;
          } else {
            return pos;
          }
        }
        return -1;
      },
      /**
       * Find the index for insertion using binary search.
       *
       * @param {Array} list            The list to search
       * @param {?} seekVal             The value to insert
       * @param {function(?,?)} cmpfunc The comparison func, that can
       *                                  compare two seekVals
       * @return {Number}               The insert position
       */
      binsearchInsert: function(list, seekVal, cmpfunc) {
        if (!list.length)
          return 0;
        var low = 0, high = list.length - 1, mid, cmpval;
        while (low <= high) {
          mid = low + Math.floor((high - low) / 2);
          cmpval = cmpfunc(seekVal, list[mid]);
          if (cmpval < 0)
            high = mid - 1;
          else if (cmpval > 0)
            low = mid + 1;
          else
            break;
        }
        if (cmpval < 0)
          return mid;
        else if (cmpval > 0)
          return mid + 1;
        else
          return mid;
      },
      /**
       * Convenience function for debug output
       * @private
       */
      dumpn: (
        /* istanbul ignore next */
        function() {
          if (!ICAL2.debug) {
            return;
          }
          if (typeof console !== "undefined" && "log" in console) {
            ICAL2.helpers.dumpn = function consoleDumpn(input) {
              console.log(input);
            };
          } else {
            ICAL2.helpers.dumpn = function geckoDumpn(input) {
              dump(input + "\n");
            };
          }
          ICAL2.helpers.dumpn(arguments[0]);
        }
      ),
      /**
       * Clone the passed object or primitive. By default a shallow clone will be
       * executed.
       *
       * @param {*} aSrc            The thing to clone
       * @param {Boolean=} aDeep    If true, a deep clone will be performed
       * @return {*}                The copy of the thing
       */
      clone: function(aSrc, aDeep) {
        if (!aSrc || typeof aSrc != "object") {
          return aSrc;
        } else if (aSrc instanceof Date) {
          return new Date(aSrc.getTime());
        } else if ("clone" in aSrc) {
          return aSrc.clone();
        } else if (Array.isArray(aSrc)) {
          var arr = [];
          for (var i3 = 0; i3 < aSrc.length; i3++) {
            arr.push(aDeep ? ICAL2.helpers.clone(aSrc[i3], true) : aSrc[i3]);
          }
          return arr;
        } else {
          var obj = {};
          for (var name in aSrc) {
            if (Object.prototype.hasOwnProperty.call(aSrc, name)) {
              if (aDeep) {
                obj[name] = ICAL2.helpers.clone(aSrc[name], true);
              } else {
                obj[name] = aSrc[name];
              }
            }
          }
          return obj;
        }
      },
      /**
       * Performs iCalendar line folding. A line ending character is inserted and
       * the next line begins with a whitespace.
       *
       * @example
       * SUMMARY:This line will be fold
       *  ed right in the middle of a word.
       *
       * @param {String} aLine      The line to fold
       * @return {String}           The folded line
       */
      foldline: function foldline(aLine) {
        var result = "";
        var line = aLine || "", pos = 0, line_length = 0;
        while (line.length) {
          var cp = line.codePointAt(pos);
          if (cp < 128)
            ++line_length;
          else if (cp < 2048)
            line_length += 2;
          else if (cp < 65536)
            line_length += 3;
          else
            line_length += 4;
          if (line_length < ICAL2.foldLength + 1)
            pos += cp > 65535 ? 2 : 1;
          else {
            result += ICAL2.newLineChar + " " + line.substring(0, pos);
            line = line.substring(pos);
            pos = line_length = 0;
          }
        }
        return result.substr(ICAL2.newLineChar.length + 1);
      },
      /**
       * Pads the given string or number with zeros so it will have at least two
       * characters.
       *
       * @param {String|Number} data    The string or number to pad
       * @return {String}               The number padded as a string
       */
      pad2: function pad(data) {
        if (typeof data !== "string") {
          if (typeof data === "number") {
            data = parseInt(data);
          }
          data = String(data);
        }
        var len = data.length;
        switch (len) {
          case 0:
            return "00";
          case 1:
            return "0" + data;
          default:
            return data;
        }
      },
      /**
       * Truncates the given number, correctly handling negative numbers.
       *
       * @param {Number} number     The number to truncate
       * @return {Number}           The truncated number
       */
      trunc: function trunc(number) {
        return number < 0 ? Math.ceil(number) : Math.floor(number);
      },
      /**
       * Poor-man's cross-browser inheritance for JavaScript. Doesn't support all
       * the features, but enough for our usage.
       *
       * @param {Function} base     The base class constructor function.
       * @param {Function} child    The child class constructor function.
       * @param {Object} extra      Extends the prototype with extra properties
       *                              and methods
       */
      inherits: function(base, child, extra) {
        function F4() {
        }
        F4.prototype = base.prototype;
        child.prototype = new F4();
        if (extra) {
          ICAL2.helpers.extend(extra, child.prototype);
        }
      },
      /**
       * Poor-man's cross-browser object extension. Doesn't support all the
       * features, but enough for our usage. Note that the target's properties are
       * not overwritten with the source properties.
       *
       * @example
       * var child = ICAL.helpers.extend(parent, {
       *   "bar": 123
       * });
       *
       * @param {Object} source     The object to extend
       * @param {Object} target     The object to extend with
       * @return {Object}           Returns the target.
       */
      extend: function(source, target) {
        for (var key in source) {
          var descr = Object.getOwnPropertyDescriptor(source, key);
          if (descr && !Object.getOwnPropertyDescriptor(target, key)) {
            Object.defineProperty(target, key, descr);
          }
        }
        return target;
      }
    };
    ICAL2.design = function() {
      "use strict";
      var FROM_ICAL_NEWLINE = /\\\\|\\;|\\,|\\[Nn]/g;
      var TO_ICAL_NEWLINE = /\\|;|,|\n/g;
      var FROM_VCARD_NEWLINE = /\\\\|\\,|\\[Nn]/g;
      var TO_VCARD_NEWLINE = /\\|,|\n/g;
      function createTextType(fromNewline, toNewline) {
        var result = {
          matches: /.*/,
          fromICAL: function(aValue, structuredEscape) {
            return replaceNewline(aValue, fromNewline, structuredEscape);
          },
          toICAL: function(aValue, structuredEscape) {
            var regEx = toNewline;
            if (structuredEscape)
              regEx = new RegExp(regEx.source + "|" + structuredEscape);
            return aValue.replace(regEx, function(str) {
              switch (str) {
                case "\\":
                  return "\\\\";
                case ";":
                  return "\\;";
                case ",":
                  return "\\,";
                case "\n":
                  return "\\n";
                default:
                  return str;
              }
            });
          }
        };
        return result;
      }
      var DEFAULT_TYPE_TEXT = { defaultType: "text" };
      var DEFAULT_TYPE_TEXT_MULTI = { defaultType: "text", multiValue: "," };
      var DEFAULT_TYPE_TEXT_STRUCTURED = { defaultType: "text", structuredValue: ";" };
      var DEFAULT_TYPE_INTEGER = { defaultType: "integer" };
      var DEFAULT_TYPE_DATETIME_DATE = { defaultType: "date-time", allowedTypes: ["date-time", "date"] };
      var DEFAULT_TYPE_DATETIME = { defaultType: "date-time" };
      var DEFAULT_TYPE_URI = { defaultType: "uri" };
      var DEFAULT_TYPE_UTCOFFSET = { defaultType: "utc-offset" };
      var DEFAULT_TYPE_RECUR = { defaultType: "recur" };
      var DEFAULT_TYPE_DATE_ANDOR_TIME = { defaultType: "date-and-or-time", allowedTypes: ["date-time", "date", "text"] };
      function replaceNewlineReplace(string) {
        switch (string) {
          case "\\\\":
            return "\\";
          case "\\;":
            return ";";
          case "\\,":
            return ",";
          case "\\n":
          case "\\N":
            return "\n";
          default:
            return string;
        }
      }
      function replaceNewline(value, newline, structuredEscape) {
        if (value.indexOf("\\") === -1) {
          return value;
        }
        if (structuredEscape)
          newline = new RegExp(newline.source + "|\\\\" + structuredEscape);
        return value.replace(newline, replaceNewlineReplace);
      }
      var commonProperties = {
        "categories": DEFAULT_TYPE_TEXT_MULTI,
        "url": DEFAULT_TYPE_URI,
        "version": DEFAULT_TYPE_TEXT,
        "uid": DEFAULT_TYPE_TEXT
      };
      var commonValues = {
        "boolean": {
          values: ["TRUE", "FALSE"],
          fromICAL: function(aValue) {
            switch (aValue) {
              case "TRUE":
                return true;
              case "FALSE":
                return false;
              default:
                return false;
            }
          },
          toICAL: function(aValue) {
            if (aValue) {
              return "TRUE";
            }
            return "FALSE";
          }
        },
        float: {
          matches: /^[+-]?\d+\.\d+$/,
          fromICAL: function(aValue) {
            var parsed = parseFloat(aValue);
            if (ICAL2.helpers.isStrictlyNaN(parsed)) {
              return 0;
            }
            return parsed;
          },
          toICAL: function(aValue) {
            return String(aValue);
          }
        },
        integer: {
          fromICAL: function(aValue) {
            var parsed = parseInt(aValue);
            if (ICAL2.helpers.isStrictlyNaN(parsed)) {
              return 0;
            }
            return parsed;
          },
          toICAL: function(aValue) {
            return String(aValue);
          }
        },
        "utc-offset": {
          toICAL: function(aValue) {
            if (aValue.length < 7) {
              return aValue.substr(0, 3) + aValue.substr(4, 2);
            } else {
              return aValue.substr(0, 3) + aValue.substr(4, 2) + aValue.substr(7, 2);
            }
          },
          fromICAL: function(aValue) {
            if (aValue.length < 6) {
              return aValue.substr(0, 3) + ":" + aValue.substr(3, 2);
            } else {
              return aValue.substr(0, 3) + ":" + aValue.substr(3, 2) + ":" + aValue.substr(5, 2);
            }
          },
          decorate: function(aValue) {
            return ICAL2.UtcOffset.fromString(aValue);
          },
          undecorate: function(aValue) {
            return aValue.toString();
          }
        }
      };
      var icalParams = {
        // Although the syntax is DQUOTE uri DQUOTE, I don't think we should
        // enfoce anything aside from it being a valid content line.
        //
        // At least some params require - if multi values are used - DQUOTEs
        // for each of its values - e.g. delegated-from="uri1","uri2"
        // To indicate this, I introduced the new k/v pair
        // multiValueSeparateDQuote: true
        //
        // "ALTREP": { ... },
        // CN just wants a param-value
        // "CN": { ... }
        "cutype": {
          values: ["INDIVIDUAL", "GROUP", "RESOURCE", "ROOM", "UNKNOWN"],
          allowXName: true,
          allowIanaToken: true
        },
        "delegated-from": {
          valueType: "cal-address",
          multiValue: ",",
          multiValueSeparateDQuote: true
        },
        "delegated-to": {
          valueType: "cal-address",
          multiValue: ",",
          multiValueSeparateDQuote: true
        },
        // "DIR": { ... }, // See ALTREP
        "encoding": {
          values: ["8BIT", "BASE64"]
        },
        // "FMTTYPE": { ... }, // See ALTREP
        "fbtype": {
          values: ["FREE", "BUSY", "BUSY-UNAVAILABLE", "BUSY-TENTATIVE"],
          allowXName: true,
          allowIanaToken: true
        },
        // "LANGUAGE": { ... }, // See ALTREP
        "member": {
          valueType: "cal-address",
          multiValue: ",",
          multiValueSeparateDQuote: true
        },
        "partstat": {
          // TODO These values are actually different per-component
          values: [
            "NEEDS-ACTION",
            "ACCEPTED",
            "DECLINED",
            "TENTATIVE",
            "DELEGATED",
            "COMPLETED",
            "IN-PROCESS"
          ],
          allowXName: true,
          allowIanaToken: true
        },
        "range": {
          values: ["THISANDFUTURE"]
        },
        "related": {
          values: ["START", "END"]
        },
        "reltype": {
          values: ["PARENT", "CHILD", "SIBLING"],
          allowXName: true,
          allowIanaToken: true
        },
        "role": {
          values: [
            "REQ-PARTICIPANT",
            "CHAIR",
            "OPT-PARTICIPANT",
            "NON-PARTICIPANT"
          ],
          allowXName: true,
          allowIanaToken: true
        },
        "rsvp": {
          values: ["TRUE", "FALSE"]
        },
        "sent-by": {
          valueType: "cal-address"
        },
        "tzid": {
          matches: /^\//
        },
        "value": {
          // since the value here is a 'type' lowercase is used.
          values: [
            "binary",
            "boolean",
            "cal-address",
            "date",
            "date-time",
            "duration",
            "float",
            "integer",
            "period",
            "recur",
            "text",
            "time",
            "uri",
            "utc-offset"
          ],
          allowXName: true,
          allowIanaToken: true
        }
      };
      var icalValues = ICAL2.helpers.extend(commonValues, {
        text: createTextType(FROM_ICAL_NEWLINE, TO_ICAL_NEWLINE),
        uri: {
          // TODO
          /* ... */
        },
        "binary": {
          decorate: function(aString) {
            return ICAL2.Binary.fromString(aString);
          },
          undecorate: function(aBinary) {
            return aBinary.toString();
          }
        },
        "cal-address": {
          // needs to be an uri
        },
        "date": {
          decorate: function(aValue, aProp) {
            if (design.strict) {
              return ICAL2.Time.fromDateString(aValue, aProp);
            } else {
              return ICAL2.Time.fromString(aValue, aProp);
            }
          },
          /**
           * undecorates a time object.
           */
          undecorate: function(aValue) {
            return aValue.toString();
          },
          fromICAL: function(aValue) {
            if (!design.strict && aValue.length >= 15) {
              return icalValues["date-time"].fromICAL(aValue);
            } else {
              return aValue.substr(0, 4) + "-" + aValue.substr(4, 2) + "-" + aValue.substr(6, 2);
            }
          },
          toICAL: function(aValue) {
            var len = aValue.length;
            if (len == 10) {
              return aValue.substr(0, 4) + aValue.substr(5, 2) + aValue.substr(8, 2);
            } else if (len >= 19) {
              return icalValues["date-time"].toICAL(aValue);
            } else {
              return aValue;
            }
          }
        },
        "date-time": {
          fromICAL: function(aValue) {
            if (!design.strict && aValue.length == 8) {
              return icalValues.date.fromICAL(aValue);
            } else {
              var result = aValue.substr(0, 4) + "-" + aValue.substr(4, 2) + "-" + aValue.substr(6, 2) + "T" + aValue.substr(9, 2) + ":" + aValue.substr(11, 2) + ":" + aValue.substr(13, 2);
              if (aValue[15] && aValue[15] === "Z") {
                result += "Z";
              }
              return result;
            }
          },
          toICAL: function(aValue) {
            var len = aValue.length;
            if (len == 10 && !design.strict) {
              return icalValues.date.toICAL(aValue);
            } else if (len >= 19) {
              var result = aValue.substr(0, 4) + aValue.substr(5, 2) + // grab the (DDTHH) segment
              aValue.substr(8, 5) + // MM
              aValue.substr(14, 2) + // SS
              aValue.substr(17, 2);
              if (aValue[19] && aValue[19] === "Z") {
                result += "Z";
              }
              return result;
            } else {
              return aValue;
            }
          },
          decorate: function(aValue, aProp) {
            if (design.strict) {
              return ICAL2.Time.fromDateTimeString(aValue, aProp);
            } else {
              return ICAL2.Time.fromString(aValue, aProp);
            }
          },
          undecorate: function(aValue) {
            return aValue.toString();
          }
        },
        duration: {
          decorate: function(aValue) {
            return ICAL2.Duration.fromString(aValue);
          },
          undecorate: function(aValue) {
            return aValue.toString();
          }
        },
        period: {
          fromICAL: function(string) {
            var parts = string.split("/");
            parts[0] = icalValues["date-time"].fromICAL(parts[0]);
            if (!ICAL2.Duration.isValueString(parts[1])) {
              parts[1] = icalValues["date-time"].fromICAL(parts[1]);
            }
            return parts;
          },
          toICAL: function(parts) {
            if (!design.strict && parts[0].length == 10) {
              parts[0] = icalValues.date.toICAL(parts[0]);
            } else {
              parts[0] = icalValues["date-time"].toICAL(parts[0]);
            }
            if (!ICAL2.Duration.isValueString(parts[1])) {
              if (!design.strict && parts[1].length == 10) {
                parts[1] = icalValues.date.toICAL(parts[1]);
              } else {
                parts[1] = icalValues["date-time"].toICAL(parts[1]);
              }
            }
            return parts.join("/");
          },
          decorate: function(aValue, aProp) {
            return ICAL2.Period.fromJSON(aValue, aProp, !design.strict);
          },
          undecorate: function(aValue) {
            return aValue.toJSON();
          }
        },
        recur: {
          fromICAL: function(string) {
            return ICAL2.Recur._stringToData(string, true);
          },
          toICAL: function(data) {
            var str = "";
            for (var k3 in data) {
              if (!Object.prototype.hasOwnProperty.call(data, k3)) {
                continue;
              }
              var val = data[k3];
              if (k3 == "until") {
                if (val.length > 10) {
                  val = icalValues["date-time"].toICAL(val);
                } else {
                  val = icalValues.date.toICAL(val);
                }
              } else if (k3 == "wkst") {
                if (typeof val === "number") {
                  val = ICAL2.Recur.numericDayToIcalDay(val);
                }
              } else if (Array.isArray(val)) {
                val = val.join(",");
              }
              str += k3.toUpperCase() + "=" + val + ";";
            }
            return str.substr(0, str.length - 1);
          },
          decorate: function decorate(aValue) {
            return ICAL2.Recur.fromData(aValue);
          },
          undecorate: function(aRecur) {
            return aRecur.toJSON();
          }
        },
        time: {
          fromICAL: function(aValue) {
            if (aValue.length < 6) {
              return aValue;
            }
            var result = aValue.substr(0, 2) + ":" + aValue.substr(2, 2) + ":" + aValue.substr(4, 2);
            if (aValue[6] === "Z") {
              result += "Z";
            }
            return result;
          },
          toICAL: function(aValue) {
            if (aValue.length < 8) {
              return aValue;
            }
            var result = aValue.substr(0, 2) + aValue.substr(3, 2) + aValue.substr(6, 2);
            if (aValue[8] === "Z") {
              result += "Z";
            }
            return result;
          }
        }
      });
      var icalProperties = ICAL2.helpers.extend(commonProperties, {
        "action": DEFAULT_TYPE_TEXT,
        "attach": { defaultType: "uri" },
        "attendee": { defaultType: "cal-address" },
        "calscale": DEFAULT_TYPE_TEXT,
        "class": DEFAULT_TYPE_TEXT,
        "comment": DEFAULT_TYPE_TEXT,
        "completed": DEFAULT_TYPE_DATETIME,
        "contact": DEFAULT_TYPE_TEXT,
        "created": DEFAULT_TYPE_DATETIME,
        "description": DEFAULT_TYPE_TEXT,
        "dtend": DEFAULT_TYPE_DATETIME_DATE,
        "dtstamp": DEFAULT_TYPE_DATETIME,
        "dtstart": DEFAULT_TYPE_DATETIME_DATE,
        "due": DEFAULT_TYPE_DATETIME_DATE,
        "duration": { defaultType: "duration" },
        "exdate": {
          defaultType: "date-time",
          allowedTypes: ["date-time", "date"],
          multiValue: ","
        },
        "exrule": DEFAULT_TYPE_RECUR,
        "freebusy": { defaultType: "period", multiValue: "," },
        "geo": { defaultType: "float", structuredValue: ";" },
        "last-modified": DEFAULT_TYPE_DATETIME,
        "location": DEFAULT_TYPE_TEXT,
        "method": DEFAULT_TYPE_TEXT,
        "organizer": { defaultType: "cal-address" },
        "percent-complete": DEFAULT_TYPE_INTEGER,
        "priority": DEFAULT_TYPE_INTEGER,
        "prodid": DEFAULT_TYPE_TEXT,
        "related-to": DEFAULT_TYPE_TEXT,
        "repeat": DEFAULT_TYPE_INTEGER,
        "rdate": {
          defaultType: "date-time",
          allowedTypes: ["date-time", "date", "period"],
          multiValue: ",",
          detectType: function(string) {
            if (string.indexOf("/") !== -1) {
              return "period";
            }
            return string.indexOf("T") === -1 ? "date" : "date-time";
          }
        },
        "recurrence-id": DEFAULT_TYPE_DATETIME_DATE,
        "resources": DEFAULT_TYPE_TEXT_MULTI,
        "request-status": DEFAULT_TYPE_TEXT_STRUCTURED,
        "rrule": DEFAULT_TYPE_RECUR,
        "sequence": DEFAULT_TYPE_INTEGER,
        "status": DEFAULT_TYPE_TEXT,
        "summary": DEFAULT_TYPE_TEXT,
        "transp": DEFAULT_TYPE_TEXT,
        "trigger": { defaultType: "duration", allowedTypes: ["duration", "date-time"] },
        "tzoffsetfrom": DEFAULT_TYPE_UTCOFFSET,
        "tzoffsetto": DEFAULT_TYPE_UTCOFFSET,
        "tzurl": DEFAULT_TYPE_URI,
        "tzid": DEFAULT_TYPE_TEXT,
        "tzname": DEFAULT_TYPE_TEXT
      });
      var vcardValues = ICAL2.helpers.extend(commonValues, {
        text: createTextType(FROM_VCARD_NEWLINE, TO_VCARD_NEWLINE),
        uri: createTextType(FROM_VCARD_NEWLINE, TO_VCARD_NEWLINE),
        date: {
          decorate: function(aValue) {
            return ICAL2.VCardTime.fromDateAndOrTimeString(aValue, "date");
          },
          undecorate: function(aValue) {
            return aValue.toString();
          },
          fromICAL: function(aValue) {
            if (aValue.length == 8) {
              return icalValues.date.fromICAL(aValue);
            } else if (aValue[0] == "-" && aValue.length == 6) {
              return aValue.substr(0, 4) + "-" + aValue.substr(4);
            } else {
              return aValue;
            }
          },
          toICAL: function(aValue) {
            if (aValue.length == 10) {
              return icalValues.date.toICAL(aValue);
            } else if (aValue[0] == "-" && aValue.length == 7) {
              return aValue.substr(0, 4) + aValue.substr(5);
            } else {
              return aValue;
            }
          }
        },
        time: {
          decorate: function(aValue) {
            return ICAL2.VCardTime.fromDateAndOrTimeString("T" + aValue, "time");
          },
          undecorate: function(aValue) {
            return aValue.toString();
          },
          fromICAL: function(aValue) {
            var splitzone = vcardValues.time._splitZone(aValue, true);
            var zone = splitzone[0], value = splitzone[1];
            if (value.length == 6) {
              value = value.substr(0, 2) + ":" + value.substr(2, 2) + ":" + value.substr(4, 2);
            } else if (value.length == 4 && value[0] != "-") {
              value = value.substr(0, 2) + ":" + value.substr(2, 2);
            } else if (value.length == 5) {
              value = value.substr(0, 3) + ":" + value.substr(3, 2);
            }
            if (zone.length == 5 && (zone[0] == "-" || zone[0] == "+")) {
              zone = zone.substr(0, 3) + ":" + zone.substr(3);
            }
            return value + zone;
          },
          toICAL: function(aValue) {
            var splitzone = vcardValues.time._splitZone(aValue);
            var zone = splitzone[0], value = splitzone[1];
            if (value.length == 8) {
              value = value.substr(0, 2) + value.substr(3, 2) + value.substr(6, 2);
            } else if (value.length == 5 && value[0] != "-") {
              value = value.substr(0, 2) + value.substr(3, 2);
            } else if (value.length == 6) {
              value = value.substr(0, 3) + value.substr(4, 2);
            }
            if (zone.length == 6 && (zone[0] == "-" || zone[0] == "+")) {
              zone = zone.substr(0, 3) + zone.substr(4);
            }
            return value + zone;
          },
          _splitZone: function(aValue, isFromIcal) {
            var lastChar = aValue.length - 1;
            var signChar = aValue.length - (isFromIcal ? 5 : 6);
            var sign = aValue[signChar];
            var zone, value;
            if (aValue[lastChar] == "Z") {
              zone = aValue[lastChar];
              value = aValue.substr(0, lastChar);
            } else if (aValue.length > 6 && (sign == "-" || sign == "+")) {
              zone = aValue.substr(signChar);
              value = aValue.substr(0, signChar);
            } else {
              zone = "";
              value = aValue;
            }
            return [zone, value];
          }
        },
        "date-time": {
          decorate: function(aValue) {
            return ICAL2.VCardTime.fromDateAndOrTimeString(aValue, "date-time");
          },
          undecorate: function(aValue) {
            return aValue.toString();
          },
          fromICAL: function(aValue) {
            return vcardValues["date-and-or-time"].fromICAL(aValue);
          },
          toICAL: function(aValue) {
            return vcardValues["date-and-or-time"].toICAL(aValue);
          }
        },
        "date-and-or-time": {
          decorate: function(aValue) {
            return ICAL2.VCardTime.fromDateAndOrTimeString(aValue, "date-and-or-time");
          },
          undecorate: function(aValue) {
            return aValue.toString();
          },
          fromICAL: function(aValue) {
            var parts = aValue.split("T");
            return (parts[0] ? vcardValues.date.fromICAL(parts[0]) : "") + (parts[1] ? "T" + vcardValues.time.fromICAL(parts[1]) : "");
          },
          toICAL: function(aValue) {
            var parts = aValue.split("T");
            return vcardValues.date.toICAL(parts[0]) + (parts[1] ? "T" + vcardValues.time.toICAL(parts[1]) : "");
          }
        },
        timestamp: icalValues["date-time"],
        "language-tag": {
          matches: /^[a-zA-Z0-9-]+$/
          // Could go with a more strict regex here
        }
      });
      var vcardParams = {
        "type": {
          valueType: "text",
          multiValue: ","
        },
        "value": {
          // since the value here is a 'type' lowercase is used.
          values: [
            "text",
            "uri",
            "date",
            "time",
            "date-time",
            "date-and-or-time",
            "timestamp",
            "boolean",
            "integer",
            "float",
            "utc-offset",
            "language-tag"
          ],
          allowXName: true,
          allowIanaToken: true
        }
      };
      var vcardProperties = ICAL2.helpers.extend(commonProperties, {
        "adr": { defaultType: "text", structuredValue: ";", multiValue: "," },
        "anniversary": DEFAULT_TYPE_DATE_ANDOR_TIME,
        "bday": DEFAULT_TYPE_DATE_ANDOR_TIME,
        "caladruri": DEFAULT_TYPE_URI,
        "caluri": DEFAULT_TYPE_URI,
        "clientpidmap": DEFAULT_TYPE_TEXT_STRUCTURED,
        "email": DEFAULT_TYPE_TEXT,
        "fburl": DEFAULT_TYPE_URI,
        "fn": DEFAULT_TYPE_TEXT,
        "gender": DEFAULT_TYPE_TEXT_STRUCTURED,
        "geo": DEFAULT_TYPE_URI,
        "impp": DEFAULT_TYPE_URI,
        "key": DEFAULT_TYPE_URI,
        "kind": DEFAULT_TYPE_TEXT,
        "lang": { defaultType: "language-tag" },
        "logo": DEFAULT_TYPE_URI,
        "member": DEFAULT_TYPE_URI,
        "n": { defaultType: "text", structuredValue: ";", multiValue: "," },
        "nickname": DEFAULT_TYPE_TEXT_MULTI,
        "note": DEFAULT_TYPE_TEXT,
        "org": { defaultType: "text", structuredValue: ";" },
        "photo": DEFAULT_TYPE_URI,
        "related": DEFAULT_TYPE_URI,
        "rev": { defaultType: "timestamp" },
        "role": DEFAULT_TYPE_TEXT,
        "sound": DEFAULT_TYPE_URI,
        "source": DEFAULT_TYPE_URI,
        "tel": { defaultType: "uri", allowedTypes: ["uri", "text"] },
        "title": DEFAULT_TYPE_TEXT,
        "tz": { defaultType: "text", allowedTypes: ["text", "utc-offset", "uri"] },
        "xml": DEFAULT_TYPE_TEXT
      });
      var vcard3Values = ICAL2.helpers.extend(commonValues, {
        binary: icalValues.binary,
        date: vcardValues.date,
        "date-time": vcardValues["date-time"],
        "phone-number": {
          // TODO
          /* ... */
        },
        uri: icalValues.uri,
        text: icalValues.text,
        time: icalValues.time,
        vcard: icalValues.text,
        "utc-offset": {
          toICAL: function(aValue) {
            return aValue.substr(0, 7);
          },
          fromICAL: function(aValue) {
            return aValue.substr(0, 7);
          },
          decorate: function(aValue) {
            return ICAL2.UtcOffset.fromString(aValue);
          },
          undecorate: function(aValue) {
            return aValue.toString();
          }
        }
      });
      var vcard3Params = {
        "type": {
          valueType: "text",
          multiValue: ","
        },
        "value": {
          // since the value here is a 'type' lowercase is used.
          values: [
            "text",
            "uri",
            "date",
            "date-time",
            "phone-number",
            "time",
            "boolean",
            "integer",
            "float",
            "utc-offset",
            "vcard",
            "binary"
          ],
          allowXName: true,
          allowIanaToken: true
        }
      };
      var vcard3Properties = ICAL2.helpers.extend(commonProperties, {
        fn: DEFAULT_TYPE_TEXT,
        n: { defaultType: "text", structuredValue: ";", multiValue: "," },
        nickname: DEFAULT_TYPE_TEXT_MULTI,
        photo: { defaultType: "binary", allowedTypes: ["binary", "uri"] },
        bday: {
          defaultType: "date-time",
          allowedTypes: ["date-time", "date"],
          detectType: function(string) {
            return string.indexOf("T") === -1 ? "date" : "date-time";
          }
        },
        adr: { defaultType: "text", structuredValue: ";", multiValue: "," },
        label: DEFAULT_TYPE_TEXT,
        tel: { defaultType: "phone-number" },
        email: DEFAULT_TYPE_TEXT,
        mailer: DEFAULT_TYPE_TEXT,
        tz: { defaultType: "utc-offset", allowedTypes: ["utc-offset", "text"] },
        geo: { defaultType: "float", structuredValue: ";" },
        title: DEFAULT_TYPE_TEXT,
        role: DEFAULT_TYPE_TEXT,
        logo: { defaultType: "binary", allowedTypes: ["binary", "uri"] },
        agent: { defaultType: "vcard", allowedTypes: ["vcard", "text", "uri"] },
        org: DEFAULT_TYPE_TEXT_STRUCTURED,
        note: DEFAULT_TYPE_TEXT_MULTI,
        prodid: DEFAULT_TYPE_TEXT,
        rev: {
          defaultType: "date-time",
          allowedTypes: ["date-time", "date"],
          detectType: function(string) {
            return string.indexOf("T") === -1 ? "date" : "date-time";
          }
        },
        "sort-string": DEFAULT_TYPE_TEXT,
        sound: { defaultType: "binary", allowedTypes: ["binary", "uri"] },
        class: DEFAULT_TYPE_TEXT,
        key: { defaultType: "binary", allowedTypes: ["binary", "text"] }
      });
      var icalSet = {
        value: icalValues,
        param: icalParams,
        property: icalProperties
      };
      var vcardSet = {
        value: vcardValues,
        param: vcardParams,
        property: vcardProperties
      };
      var vcard3Set = {
        value: vcard3Values,
        param: vcard3Params,
        property: vcard3Properties
      };
      var design = {
        /**
         * A designSet describes value, parameter and property data. It is used by
         * ther parser and stringifier in components and properties to determine they
         * should be represented.
         *
         * @typedef {Object} designSet
         * @memberOf ICAL.design
         * @property {Object} value       Definitions for value types, keys are type names
         * @property {Object} param       Definitions for params, keys are param names
         * @property {Object} property    Defintions for properties, keys are property names
         */
        /**
         * Can be set to false to make the parser more lenient.
         */
        strict: true,
        /**
         * The default set for new properties and components if none is specified.
         * @type {ICAL.design.designSet}
         */
        defaultSet: icalSet,
        /**
         * The default type for unknown properties
         * @type {String}
         */
        defaultType: "unknown",
        /**
         * Holds the design set for known top-level components
         *
         * @type {Object}
         * @property {ICAL.design.designSet} vcard       vCard VCARD
         * @property {ICAL.design.designSet} vevent      iCalendar VEVENT
         * @property {ICAL.design.designSet} vtodo       iCalendar VTODO
         * @property {ICAL.design.designSet} vjournal    iCalendar VJOURNAL
         * @property {ICAL.design.designSet} valarm      iCalendar VALARM
         * @property {ICAL.design.designSet} vtimezone   iCalendar VTIMEZONE
         * @property {ICAL.design.designSet} daylight    iCalendar DAYLIGHT
         * @property {ICAL.design.designSet} standard    iCalendar STANDARD
         *
         * @example
         * var propertyName = 'fn';
         * var componentDesign = ICAL.design.components.vcard;
         * var propertyDetails = componentDesign.property[propertyName];
         * if (propertyDetails.defaultType == 'text') {
         *   // Yep, sure is...
         * }
         */
        components: {
          vcard: vcardSet,
          vcard3: vcard3Set,
          vevent: icalSet,
          vtodo: icalSet,
          vjournal: icalSet,
          valarm: icalSet,
          vtimezone: icalSet,
          daylight: icalSet,
          standard: icalSet
        },
        /**
         * The design set for iCalendar (rfc5545/rfc7265) components.
         * @type {ICAL.design.designSet}
         */
        icalendar: icalSet,
        /**
         * The design set for vCard (rfc6350/rfc7095) components.
         * @type {ICAL.design.designSet}
         */
        vcard: vcardSet,
        /**
         * The design set for vCard (rfc2425/rfc2426/rfc7095) components.
         * @type {ICAL.design.designSet}
         */
        vcard3: vcard3Set,
        /**
         * Gets the design set for the given component name.
         *
         * @param {String} componentName        The name of the component
         * @return {ICAL.design.designSet}      The design set for the component
         */
        getDesignSet: function(componentName) {
          var isInDesign = componentName && componentName in design.components;
          return isInDesign ? design.components[componentName] : design.defaultSet;
        }
      };
      return design;
    }();
    ICAL2.stringify = function() {
      "use strict";
      var LINE_ENDING = "\r\n";
      var DEFAULT_VALUE_TYPE = "unknown";
      var design = ICAL2.design;
      var helpers = ICAL2.helpers;
      function stringify(jCal) {
        if (typeof jCal[0] == "string") {
          jCal = [jCal];
        }
        var i3 = 0;
        var len = jCal.length;
        var result = "";
        for (; i3 < len; i3++) {
          result += stringify.component(jCal[i3]) + LINE_ENDING;
        }
        return result;
      }
      stringify.component = function(component, designSet) {
        var name = component[0].toUpperCase();
        var result = "BEGIN:" + name + LINE_ENDING;
        var props = component[1];
        var propIdx = 0;
        var propLen = props.length;
        var designSetName = component[0];
        if (designSetName === "vcard" && component[1].length > 0 && !(component[1][0][0] === "version" && component[1][0][3] === "4.0")) {
          designSetName = "vcard3";
        }
        designSet = designSet || design.getDesignSet(designSetName);
        for (; propIdx < propLen; propIdx++) {
          result += stringify.property(props[propIdx], designSet) + LINE_ENDING;
        }
        var comps = component[2] || [];
        var compIdx = 0;
        var compLen = comps.length;
        for (; compIdx < compLen; compIdx++) {
          result += stringify.component(comps[compIdx], designSet) + LINE_ENDING;
        }
        result += "END:" + name;
        return result;
      };
      stringify.property = function(property, designSet, noFold) {
        var name = property[0].toUpperCase();
        var jsName = property[0];
        var params = property[1];
        var line = name;
        var paramName;
        for (paramName in params) {
          var value = params[paramName];
          if (params.hasOwnProperty(paramName)) {
            var multiValue = paramName in designSet.param && designSet.param[paramName].multiValue;
            if (multiValue && Array.isArray(value)) {
              if (designSet.param[paramName].multiValueSeparateDQuote) {
                multiValue = '"' + multiValue + '"';
              }
              value = value.map(stringify._rfc6868Unescape);
              value = stringify.multiValue(value, multiValue, "unknown", null, designSet);
            } else {
              value = stringify._rfc6868Unescape(value);
            }
            line += ";" + paramName.toUpperCase();
            line += "=" + stringify.propertyValue(value);
          }
        }
        if (property.length === 3) {
          return line + ":";
        }
        var valueType = property[2];
        if (!designSet) {
          designSet = design.defaultSet;
        }
        var propDetails;
        var multiValue = false;
        var structuredValue = false;
        var isDefault = false;
        if (jsName in designSet.property) {
          propDetails = designSet.property[jsName];
          if ("multiValue" in propDetails) {
            multiValue = propDetails.multiValue;
          }
          if ("structuredValue" in propDetails && Array.isArray(property[3])) {
            structuredValue = propDetails.structuredValue;
          }
          if ("defaultType" in propDetails) {
            if (valueType === propDetails.defaultType) {
              isDefault = true;
            }
          } else {
            if (valueType === DEFAULT_VALUE_TYPE) {
              isDefault = true;
            }
          }
        } else {
          if (valueType === DEFAULT_VALUE_TYPE) {
            isDefault = true;
          }
        }
        if (!isDefault) {
          line += ";VALUE=" + valueType.toUpperCase();
        }
        line += ":";
        if (multiValue && structuredValue) {
          line += stringify.multiValue(
            property[3],
            structuredValue,
            valueType,
            multiValue,
            designSet,
            structuredValue
          );
        } else if (multiValue) {
          line += stringify.multiValue(
            property.slice(3),
            multiValue,
            valueType,
            null,
            designSet,
            false
          );
        } else if (structuredValue) {
          line += stringify.multiValue(
            property[3],
            structuredValue,
            valueType,
            null,
            designSet,
            structuredValue
          );
        } else {
          line += stringify.value(property[3], valueType, designSet, false);
        }
        return noFold ? line : ICAL2.helpers.foldline(line);
      };
      stringify.propertyValue = function(value) {
        if (helpers.unescapedIndexOf(value, ",") === -1 && helpers.unescapedIndexOf(value, ":") === -1 && helpers.unescapedIndexOf(value, ";") === -1) {
          return value;
        }
        return '"' + value + '"';
      };
      stringify.multiValue = function(values, delim, type, innerMulti, designSet, structuredValue) {
        var result = "";
        var len = values.length;
        var i3 = 0;
        for (; i3 < len; i3++) {
          if (innerMulti && Array.isArray(values[i3])) {
            result += stringify.multiValue(values[i3], innerMulti, type, null, designSet, structuredValue);
          } else {
            result += stringify.value(values[i3], type, designSet, structuredValue);
          }
          if (i3 !== len - 1) {
            result += delim;
          }
        }
        return result;
      };
      stringify.value = function(value, type, designSet, structuredValue) {
        if (type in designSet.value && "toICAL" in designSet.value[type]) {
          return designSet.value[type].toICAL(value, structuredValue);
        }
        return value;
      };
      stringify._rfc6868Unescape = function(val) {
        return val.replace(/[\n^"]/g, function(x4) {
          return RFC6868_REPLACE_MAP[x4];
        });
      };
      var RFC6868_REPLACE_MAP = { '"': "^'", "\n": "^n", "^": "^^" };
      return stringify;
    }();
    ICAL2.parse = function() {
      "use strict";
      var CHAR = /[^ \t]/;
      var MULTIVALUE_DELIMITER = ",";
      var VALUE_DELIMITER = ":";
      var PARAM_DELIMITER = ";";
      var PARAM_NAME_DELIMITER = "=";
      var DEFAULT_VALUE_TYPE = "unknown";
      var DEFAULT_PARAM_TYPE = "text";
      var design = ICAL2.design;
      var helpers = ICAL2.helpers;
      function ParserError(message) {
        this.message = message;
        this.name = "ParserError";
        try {
          throw new Error();
        } catch (e3) {
          if (e3.stack) {
            var split2 = e3.stack.split("\n");
            split2.shift();
            this.stack = split2.join("\n");
          }
        }
      }
      ParserError.prototype = Error.prototype;
      function parser(input) {
        var state = {};
        var root = state.component = [];
        state.stack = [root];
        parser._eachLine(input, function(err, line) {
          parser._handleContentLine(line, state);
        });
        if (state.stack.length > 1) {
          throw new ParserError(
            "invalid ical body. component began but did not end"
          );
        }
        state = null;
        return root.length == 1 ? root[0] : root;
      }
      parser.property = function(str, designSet) {
        var state = {
          component: [[], []],
          designSet: designSet || design.defaultSet
        };
        parser._handleContentLine(str, state);
        return state.component[1][0];
      };
      parser.component = function(str) {
        return parser(str);
      };
      parser.ParserError = ParserError;
      parser._handleContentLine = function(line, state) {
        var valuePos = line.indexOf(VALUE_DELIMITER);
        var paramPos = line.indexOf(PARAM_DELIMITER);
        var lastParamIndex;
        var lastValuePos;
        var name;
        var value;
        var params = {};
        if (paramPos !== -1 && valuePos !== -1) {
          if (paramPos > valuePos) {
            paramPos = -1;
          }
        }
        var parsedParams;
        if (paramPos !== -1) {
          name = line.substring(0, paramPos).toLowerCase();
          parsedParams = parser._parseParameters(line.substring(paramPos), 0, state.designSet);
          if (parsedParams[2] == -1) {
            throw new ParserError("Invalid parameters in '" + line + "'");
          }
          params = parsedParams[0];
          lastParamIndex = parsedParams[1].length + parsedParams[2] + paramPos;
          if ((lastValuePos = line.substring(lastParamIndex).indexOf(VALUE_DELIMITER)) !== -1) {
            value = line.substring(lastParamIndex + lastValuePos + 1);
          } else {
            throw new ParserError("Missing parameter value in '" + line + "'");
          }
        } else if (valuePos !== -1) {
          name = line.substring(0, valuePos).toLowerCase();
          value = line.substring(valuePos + 1);
          if (name === "begin") {
            var newComponent = [value.toLowerCase(), [], []];
            if (state.stack.length === 1) {
              state.component.push(newComponent);
            } else {
              state.component[2].push(newComponent);
            }
            state.stack.push(state.component);
            state.component = newComponent;
            if (!state.designSet) {
              state.designSet = design.getDesignSet(state.component[0]);
            }
            return;
          } else if (name === "end") {
            state.component = state.stack.pop();
            return;
          }
        } else {
          throw new ParserError(
            'invalid line (no token ";" or ":") "' + line + '"'
          );
        }
        var valueType;
        var multiValue = false;
        var structuredValue = false;
        var propertyDetails;
        if (name in state.designSet.property) {
          propertyDetails = state.designSet.property[name];
          if ("multiValue" in propertyDetails) {
            multiValue = propertyDetails.multiValue;
          }
          if ("structuredValue" in propertyDetails) {
            structuredValue = propertyDetails.structuredValue;
          }
          if (value && "detectType" in propertyDetails) {
            valueType = propertyDetails.detectType(value);
          }
        }
        if (!valueType) {
          if (!("value" in params)) {
            if (propertyDetails) {
              valueType = propertyDetails.defaultType;
            } else {
              valueType = DEFAULT_VALUE_TYPE;
            }
          } else {
            valueType = params.value.toLowerCase();
          }
        }
        delete params.value;
        var result;
        if (multiValue && structuredValue) {
          value = parser._parseMultiValue(value, structuredValue, valueType, [], multiValue, state.designSet, structuredValue);
          result = [name, params, valueType, value];
        } else if (multiValue) {
          result = [name, params, valueType];
          parser._parseMultiValue(value, multiValue, valueType, result, null, state.designSet, false);
        } else if (structuredValue) {
          value = parser._parseMultiValue(value, structuredValue, valueType, [], null, state.designSet, structuredValue);
          result = [name, params, valueType, value];
        } else {
          value = parser._parseValue(value, valueType, state.designSet, false);
          result = [name, params, valueType, value];
        }
        if (state.component[0] === "vcard" && state.component[1].length === 0 && !(name === "version" && value === "4.0")) {
          state.designSet = design.getDesignSet("vcard3");
        }
        state.component[1].push(result);
      };
      parser._parseValue = function(value, type, designSet, structuredValue) {
        if (type in designSet.value && "fromICAL" in designSet.value[type]) {
          return designSet.value[type].fromICAL(value, structuredValue);
        }
        return value;
      };
      parser._parseParameters = function(line, start, designSet) {
        var lastParam = start;
        var pos = 0;
        var delim = PARAM_NAME_DELIMITER;
        var result = {};
        var name, lcname;
        var value, valuePos = -1;
        var type, multiValue, mvdelim;
        while (pos !== false && (pos = helpers.unescapedIndexOf(line, delim, pos + 1)) !== -1) {
          name = line.substr(lastParam + 1, pos - lastParam - 1);
          if (name.length == 0) {
            throw new ParserError("Empty parameter name in '" + line + "'");
          }
          lcname = name.toLowerCase();
          mvdelim = false;
          multiValue = false;
          if (lcname in designSet.param && designSet.param[lcname].valueType) {
            type = designSet.param[lcname].valueType;
          } else {
            type = DEFAULT_PARAM_TYPE;
          }
          if (lcname in designSet.param) {
            multiValue = designSet.param[lcname].multiValue;
            if (designSet.param[lcname].multiValueSeparateDQuote) {
              mvdelim = parser._rfc6868Escape('"' + multiValue + '"');
            }
          }
          var nextChar = line[pos + 1];
          if (nextChar === '"') {
            valuePos = pos + 2;
            pos = helpers.unescapedIndexOf(line, '"', valuePos);
            if (multiValue && pos != -1) {
              var extendedValue = true;
              while (extendedValue) {
                if (line[pos + 1] == multiValue && line[pos + 2] == '"') {
                  pos = helpers.unescapedIndexOf(line, '"', pos + 3);
                } else {
                  extendedValue = false;
                }
              }
            }
            if (pos === -1) {
              throw new ParserError(
                'invalid line (no matching double quote) "' + line + '"'
              );
            }
            value = line.substr(valuePos, pos - valuePos);
            lastParam = helpers.unescapedIndexOf(line, PARAM_DELIMITER, pos);
            if (lastParam === -1) {
              pos = false;
            }
          } else {
            valuePos = pos + 1;
            var nextPos = helpers.unescapedIndexOf(line, PARAM_DELIMITER, valuePos);
            var propValuePos = helpers.unescapedIndexOf(line, VALUE_DELIMITER, valuePos);
            if (propValuePos !== -1 && nextPos > propValuePos) {
              nextPos = propValuePos;
              pos = false;
            } else if (nextPos === -1) {
              if (propValuePos === -1) {
                nextPos = line.length;
              } else {
                nextPos = propValuePos;
              }
              pos = false;
            } else {
              lastParam = nextPos;
              pos = nextPos;
            }
            value = line.substr(valuePos, nextPos - valuePos);
          }
          value = parser._rfc6868Escape(value);
          if (multiValue) {
            var delimiter = mvdelim || multiValue;
            value = parser._parseMultiValue(value, delimiter, type, [], null, designSet);
          } else {
            value = parser._parseValue(value, type, designSet);
          }
          if (multiValue && lcname in result) {
            if (Array.isArray(result[lcname])) {
              result[lcname].push(value);
            } else {
              result[lcname] = [
                result[lcname],
                value
              ];
            }
          } else {
            result[lcname] = value;
          }
        }
        return [result, value, valuePos];
      };
      parser._rfc6868Escape = function(val) {
        return val.replace(/\^['n^]/g, function(x4) {
          return RFC6868_REPLACE_MAP[x4];
        });
      };
      var RFC6868_REPLACE_MAP = { "^'": '"', "^n": "\n", "^^": "^" };
      parser._parseMultiValue = function(buffer, delim, type, result, innerMulti, designSet, structuredValue) {
        var pos = 0;
        var lastPos = 0;
        var value;
        if (delim.length === 0) {
          return buffer;
        }
        while ((pos = helpers.unescapedIndexOf(buffer, delim, lastPos)) !== -1) {
          value = buffer.substr(lastPos, pos - lastPos);
          if (innerMulti) {
            value = parser._parseMultiValue(value, innerMulti, type, [], null, designSet, structuredValue);
          } else {
            value = parser._parseValue(value, type, designSet, structuredValue);
          }
          result.push(value);
          lastPos = pos + delim.length;
        }
        value = buffer.substr(lastPos);
        if (innerMulti) {
          value = parser._parseMultiValue(value, innerMulti, type, [], null, designSet, structuredValue);
        } else {
          value = parser._parseValue(value, type, designSet, structuredValue);
        }
        result.push(value);
        return result.length == 1 ? result[0] : result;
      };
      parser._eachLine = function(buffer, callback) {
        var len = buffer.length;
        var lastPos = buffer.search(CHAR);
        var pos = lastPos;
        var line;
        var firstChar;
        var newlineOffset;
        do {
          pos = buffer.indexOf("\n", lastPos) + 1;
          if (pos > 1 && buffer[pos - 2] === "\r") {
            newlineOffset = 2;
          } else {
            newlineOffset = 1;
          }
          if (pos === 0) {
            pos = len;
            newlineOffset = 0;
          }
          firstChar = buffer[lastPos];
          if (firstChar === " " || firstChar === "	") {
            line += buffer.substr(
              lastPos + 1,
              pos - lastPos - (newlineOffset + 1)
            );
          } else {
            if (line)
              callback(null, line);
            line = buffer.substr(
              lastPos,
              pos - lastPos - newlineOffset
            );
          }
          lastPos = pos;
        } while (pos !== len);
        line = line.trim();
        if (line.length)
          callback(null, line);
      };
      return parser;
    }();
    ICAL2.Component = function() {
      "use strict";
      var PROPERTY_INDEX = 1;
      var COMPONENT_INDEX = 2;
      var NAME_INDEX = 0;
      function Component3(jCal, parent) {
        if (typeof jCal === "string") {
          jCal = [jCal, [], []];
        }
        this.jCal = jCal;
        this.parent = parent || null;
      }
      Component3.prototype = {
        /**
         * Hydrated properties are inserted into the _properties array at the same
         * position as in the jCal array, so it is possible that the array contains
         * undefined values for unhydrdated properties. To avoid iterating the
         * array when checking if all properties have been hydrated, we save the
         * count here.
         *
         * @type {Number}
         * @private
         */
        _hydratedPropertyCount: 0,
        /**
         * The same count as for _hydratedPropertyCount, but for subcomponents
         *
         * @type {Number}
         * @private
         */
        _hydratedComponentCount: 0,
        /**
         * The name of this component
         * @readonly
         */
        get name() {
          return this.jCal[NAME_INDEX];
        },
        /**
         * The design set for this component, e.g. icalendar vs vcard
         *
         * @type {ICAL.design.designSet}
         * @private
         */
        get _designSet() {
          var parentDesign = this.parent && this.parent._designSet;
          return parentDesign || ICAL2.design.getDesignSet(this.name);
        },
        _hydrateComponent: function(index8) {
          if (!this._components) {
            this._components = [];
            this._hydratedComponentCount = 0;
          }
          if (this._components[index8]) {
            return this._components[index8];
          }
          var comp = new Component3(
            this.jCal[COMPONENT_INDEX][index8],
            this
          );
          this._hydratedComponentCount++;
          return this._components[index8] = comp;
        },
        _hydrateProperty: function(index8) {
          if (!this._properties) {
            this._properties = [];
            this._hydratedPropertyCount = 0;
          }
          if (this._properties[index8]) {
            return this._properties[index8];
          }
          var prop = new ICAL2.Property(
            this.jCal[PROPERTY_INDEX][index8],
            this
          );
          this._hydratedPropertyCount++;
          return this._properties[index8] = prop;
        },
        /**
         * Finds first sub component, optionally filtered by name.
         *
         * @param {String=} name        Optional name to filter by
         * @return {?ICAL.Component}     The found subcomponent
         */
        getFirstSubcomponent: function(name) {
          if (name) {
            var i3 = 0;
            var comps = this.jCal[COMPONENT_INDEX];
            var len = comps.length;
            for (; i3 < len; i3++) {
              if (comps[i3][NAME_INDEX] === name) {
                var result = this._hydrateComponent(i3);
                return result;
              }
            }
          } else {
            if (this.jCal[COMPONENT_INDEX].length) {
              return this._hydrateComponent(0);
            }
          }
          return null;
        },
        /**
         * Finds all sub components, optionally filtering by name.
         *
         * @param {String=} name            Optional name to filter by
         * @return {ICAL.Component[]}       The found sub components
         */
        getAllSubcomponents: function(name) {
          var jCalLen = this.jCal[COMPONENT_INDEX].length;
          var i3 = 0;
          if (name) {
            var comps = this.jCal[COMPONENT_INDEX];
            var result = [];
            for (; i3 < jCalLen; i3++) {
              if (name === comps[i3][NAME_INDEX]) {
                result.push(
                  this._hydrateComponent(i3)
                );
              }
            }
            return result;
          } else {
            if (!this._components || this._hydratedComponentCount !== jCalLen) {
              for (; i3 < jCalLen; i3++) {
                this._hydrateComponent(i3);
              }
            }
            return this._components || [];
          }
        },
        /**
         * Returns true when a named property exists.
         *
         * @param {String} name     The property name
         * @return {Boolean}        True, when property is found
         */
        hasProperty: function(name) {
          var props = this.jCal[PROPERTY_INDEX];
          var len = props.length;
          var i3 = 0;
          for (; i3 < len; i3++) {
            if (props[i3][NAME_INDEX] === name) {
              return true;
            }
          }
          return false;
        },
        /**
         * Finds the first property, optionally with the given name.
         *
         * @param {String=} name        Lowercase property name
         * @return {?ICAL.Property}     The found property
         */
        getFirstProperty: function(name) {
          if (name) {
            var i3 = 0;
            var props = this.jCal[PROPERTY_INDEX];
            var len = props.length;
            for (; i3 < len; i3++) {
              if (props[i3][NAME_INDEX] === name) {
                var result = this._hydrateProperty(i3);
                return result;
              }
            }
          } else {
            if (this.jCal[PROPERTY_INDEX].length) {
              return this._hydrateProperty(0);
            }
          }
          return null;
        },
        /**
         * Returns first property's value, if available.
         *
         * @param {String=} name    Lowercase property name
         * @return {?String}        The found property value.
         */
        getFirstPropertyValue: function(name) {
          var prop = this.getFirstProperty(name);
          if (prop) {
            return prop.getFirstValue();
          }
          return null;
        },
        /**
         * Get all properties in the component, optionally filtered by name.
         *
         * @param {String=} name        Lowercase property name
         * @return {ICAL.Property[]}    List of properties
         */
        getAllProperties: function(name) {
          var jCalLen = this.jCal[PROPERTY_INDEX].length;
          var i3 = 0;
          if (name) {
            var props = this.jCal[PROPERTY_INDEX];
            var result = [];
            for (; i3 < jCalLen; i3++) {
              if (name === props[i3][NAME_INDEX]) {
                result.push(
                  this._hydrateProperty(i3)
                );
              }
            }
            return result;
          } else {
            if (!this._properties || this._hydratedPropertyCount !== jCalLen) {
              for (; i3 < jCalLen; i3++) {
                this._hydrateProperty(i3);
              }
            }
            return this._properties || [];
          }
        },
        _removeObjectByIndex: function(jCalIndex, cache, index8) {
          cache = cache || [];
          if (cache[index8]) {
            var obj = cache[index8];
            if ("parent" in obj) {
              obj.parent = null;
            }
          }
          cache.splice(index8, 1);
          this.jCal[jCalIndex].splice(index8, 1);
        },
        _removeObject: function(jCalIndex, cache, nameOrObject) {
          var i3 = 0;
          var objects = this.jCal[jCalIndex];
          var len = objects.length;
          var cached = this[cache];
          if (typeof nameOrObject === "string") {
            for (; i3 < len; i3++) {
              if (objects[i3][NAME_INDEX] === nameOrObject) {
                this._removeObjectByIndex(jCalIndex, cached, i3);
                return true;
              }
            }
          } else if (cached) {
            for (; i3 < len; i3++) {
              if (cached[i3] && cached[i3] === nameOrObject) {
                this._removeObjectByIndex(jCalIndex, cached, i3);
                return true;
              }
            }
          }
          return false;
        },
        _removeAllObjects: function(jCalIndex, cache, name) {
          var cached = this[cache];
          var objects = this.jCal[jCalIndex];
          var i3 = objects.length - 1;
          for (; i3 >= 0; i3--) {
            if (!name || objects[i3][NAME_INDEX] === name) {
              this._removeObjectByIndex(jCalIndex, cached, i3);
            }
          }
        },
        /**
         * Adds a single sub component.
         *
         * @param {ICAL.Component} component        The component to add
         * @return {ICAL.Component}                 The passed in component
         */
        addSubcomponent: function(component) {
          if (!this._components) {
            this._components = [];
            this._hydratedComponentCount = 0;
          }
          if (component.parent) {
            component.parent.removeSubcomponent(component);
          }
          var idx = this.jCal[COMPONENT_INDEX].push(component.jCal);
          this._components[idx - 1] = component;
          this._hydratedComponentCount++;
          component.parent = this;
          return component;
        },
        /**
         * Removes a single component by name or the instance of a specific
         * component.
         *
         * @param {ICAL.Component|String} nameOrComp    Name of component, or component
         * @return {Boolean}                            True when comp is removed
         */
        removeSubcomponent: function(nameOrComp) {
          var removed = this._removeObject(COMPONENT_INDEX, "_components", nameOrComp);
          if (removed) {
            this._hydratedComponentCount--;
          }
          return removed;
        },
        /**
         * Removes all components or (if given) all components by a particular
         * name.
         *
         * @param {String=} name            Lowercase component name
         */
        removeAllSubcomponents: function(name) {
          var removed = this._removeAllObjects(COMPONENT_INDEX, "_components", name);
          this._hydratedComponentCount = 0;
          return removed;
        },
        /**
         * Adds an {@link ICAL.Property} to the component.
         *
         * @param {ICAL.Property} property      The property to add
         * @return {ICAL.Property}              The passed in property
         */
        addProperty: function(property) {
          if (!(property instanceof ICAL2.Property)) {
            throw new TypeError("must instance of ICAL.Property");
          }
          if (!this._properties) {
            this._properties = [];
            this._hydratedPropertyCount = 0;
          }
          if (property.parent) {
            property.parent.removeProperty(property);
          }
          var idx = this.jCal[PROPERTY_INDEX].push(property.jCal);
          this._properties[idx - 1] = property;
          this._hydratedPropertyCount++;
          property.parent = this;
          return property;
        },
        /**
         * Helper method to add a property with a value to the component.
         *
         * @param {String}               name         Property name to add
         * @param {String|Number|Object} value        Property value
         * @return {ICAL.Property}                    The created property
         */
        addPropertyWithValue: function(name, value) {
          var prop = new ICAL2.Property(name);
          prop.setValue(value);
          this.addProperty(prop);
          return prop;
        },
        /**
         * Helper method that will update or create a property of the given name
         * and sets its value. If multiple properties with the given name exist,
         * only the first is updated.
         *
         * @param {String}               name         Property name to update
         * @param {String|Number|Object} value        Property value
         * @return {ICAL.Property}                    The created property
         */
        updatePropertyWithValue: function(name, value) {
          var prop = this.getFirstProperty(name);
          if (prop) {
            prop.setValue(value);
          } else {
            prop = this.addPropertyWithValue(name, value);
          }
          return prop;
        },
        /**
         * Removes a single property by name or the instance of the specific
         * property.
         *
         * @param {String|ICAL.Property} nameOrProp     Property name or instance to remove
         * @return {Boolean}                            True, when deleted
         */
        removeProperty: function(nameOrProp) {
          var removed = this._removeObject(PROPERTY_INDEX, "_properties", nameOrProp);
          if (removed) {
            this._hydratedPropertyCount--;
          }
          return removed;
        },
        /**
         * Removes all properties associated with this component, optionally
         * filtered by name.
         *
         * @param {String=} name        Lowercase property name
         * @return {Boolean}            True, when deleted
         */
        removeAllProperties: function(name) {
          var removed = this._removeAllObjects(PROPERTY_INDEX, "_properties", name);
          this._hydratedPropertyCount = 0;
          return removed;
        },
        /**
         * Returns the Object representation of this component. The returned object
         * is a live jCal object and should be cloned if modified.
         * @return {Object}
         */
        toJSON: function() {
          return this.jCal;
        },
        /**
         * The string representation of this component.
         * @return {String}
         */
        toString: function() {
          return ICAL2.stringify.component(
            this.jCal,
            this._designSet
          );
        }
      };
      Component3.fromString = function(str) {
        return new Component3(ICAL2.parse.component(str));
      };
      return Component3;
    }();
    ICAL2.Property = function() {
      "use strict";
      var NAME_INDEX = 0;
      var PROP_INDEX = 1;
      var TYPE_INDEX = 2;
      var VALUE_INDEX = 3;
      var design = ICAL2.design;
      function Property(jCal, parent) {
        this._parent = parent || null;
        if (typeof jCal === "string") {
          this.jCal = [jCal, {}, design.defaultType];
          this.jCal[TYPE_INDEX] = this.getDefaultType();
        } else {
          this.jCal = jCal;
        }
        this._updateType();
      }
      Property.prototype = {
        /**
         * The value type for this property
         * @readonly
         * @type {String}
         */
        get type() {
          return this.jCal[TYPE_INDEX];
        },
        /**
         * The name of this property, in lowercase.
         * @readonly
         * @type {String}
         */
        get name() {
          return this.jCal[NAME_INDEX];
        },
        /**
         * The parent component for this property.
         * @type {ICAL.Component}
         */
        get parent() {
          return this._parent;
        },
        set parent(p3) {
          var designSetChanged = !this._parent || p3 && p3._designSet != this._parent._designSet;
          this._parent = p3;
          if (this.type == design.defaultType && designSetChanged) {
            this.jCal[TYPE_INDEX] = this.getDefaultType();
            this._updateType();
          }
          return p3;
        },
        /**
         * The design set for this property, e.g. icalendar vs vcard
         *
         * @type {ICAL.design.designSet}
         * @private
         */
        get _designSet() {
          return this.parent ? this.parent._designSet : design.defaultSet;
        },
        /**
         * Updates the type metadata from the current jCal type and design set.
         *
         * @private
         */
        _updateType: function() {
          var designSet = this._designSet;
          if (this.type in designSet.value) {
            var designType = designSet.value[this.type];
            if ("decorate" in designSet.value[this.type]) {
              this.isDecorated = true;
            } else {
              this.isDecorated = false;
            }
            if (this.name in designSet.property) {
              this.isMultiValue = "multiValue" in designSet.property[this.name];
              this.isStructuredValue = "structuredValue" in designSet.property[this.name];
            }
          }
        },
        /**
         * Hydrate a single value. The act of hydrating means turning the raw jCal
         * value into a potentially wrapped object, for example {@link ICAL.Time}.
         *
         * @private
         * @param {Number} index        The index of the value to hydrate
         * @return {Object}             The decorated value.
         */
        _hydrateValue: function(index8) {
          if (this._values && this._values[index8]) {
            return this._values[index8];
          }
          if (this.jCal.length <= VALUE_INDEX + index8) {
            return null;
          }
          if (this.isDecorated) {
            if (!this._values) {
              this._values = [];
            }
            return this._values[index8] = this._decorate(
              this.jCal[VALUE_INDEX + index8]
            );
          } else {
            return this.jCal[VALUE_INDEX + index8];
          }
        },
        /**
         * Decorate a single value, returning its wrapped object. This is used by
         * the hydrate function to actually wrap the value.
         *
         * @private
         * @param {?} value         The value to decorate
         * @return {Object}         The decorated value
         */
        _decorate: function(value) {
          return this._designSet.value[this.type].decorate(value, this);
        },
        /**
         * Undecorate a single value, returning its raw jCal data.
         *
         * @private
         * @param {Object} value         The value to undecorate
         * @return {?}                   The undecorated value
         */
        _undecorate: function(value) {
          return this._designSet.value[this.type].undecorate(value, this);
        },
        /**
         * Sets the value at the given index while also hydrating it. The passed
         * value can either be a decorated or undecorated value.
         *
         * @private
         * @param {?} value             The value to set
         * @param {Number} index        The index to set it at
         */
        _setDecoratedValue: function(value, index8) {
          if (!this._values) {
            this._values = [];
          }
          if (typeof value === "object" && "icaltype" in value) {
            this.jCal[VALUE_INDEX + index8] = this._undecorate(value);
            this._values[index8] = value;
          } else {
            this.jCal[VALUE_INDEX + index8] = value;
            this._values[index8] = this._decorate(value);
          }
        },
        /**
         * Gets a parameter on the property.
         *
         * @param {String}        name   Parameter name (lowercase)
         * @return {Array|String}        Parameter value
         */
        getParameter: function(name) {
          if (name in this.jCal[PROP_INDEX]) {
            return this.jCal[PROP_INDEX][name];
          } else {
            return void 0;
          }
        },
        /**
         * Gets first parameter on the property.
         *
         * @param {String}        name   Parameter name (lowercase)
         * @return {String}        Parameter value
         */
        getFirstParameter: function(name) {
          var parameters = this.getParameter(name);
          if (Array.isArray(parameters)) {
            return parameters[0];
          }
          return parameters;
        },
        /**
         * Sets a parameter on the property.
         *
         * @param {String}       name     The parameter name
         * @param {Array|String} value    The parameter value
         */
        setParameter: function(name, value) {
          var lcname = name.toLowerCase();
          if (typeof value === "string" && lcname in this._designSet.param && "multiValue" in this._designSet.param[lcname]) {
            value = [value];
          }
          this.jCal[PROP_INDEX][name] = value;
        },
        /**
         * Removes a parameter
         *
         * @param {String} name     The parameter name
         */
        removeParameter: function(name) {
          delete this.jCal[PROP_INDEX][name];
        },
        /**
         * Get the default type based on this property's name.
         *
         * @return {String}     The default type for this property
         */
        getDefaultType: function() {
          var name = this.jCal[NAME_INDEX];
          var designSet = this._designSet;
          if (name in designSet.property) {
            var details = designSet.property[name];
            if ("defaultType" in details) {
              return details.defaultType;
            }
          }
          return design.defaultType;
        },
        /**
         * Sets type of property and clears out any existing values of the current
         * type.
         *
         * @param {String} type     New iCAL type (see design.*.values)
         */
        resetType: function(type) {
          this.removeAllValues();
          this.jCal[TYPE_INDEX] = type;
          this._updateType();
        },
        /**
         * Finds the first property value.
         *
         * @return {String}         First property value
         */
        getFirstValue: function() {
          return this._hydrateValue(0);
        },
        /**
         * Gets all values on the property.
         *
         * NOTE: this creates an array during each call.
         *
         * @return {Array}          List of values
         */
        getValues: function() {
          var len = this.jCal.length - VALUE_INDEX;
          if (len < 1) {
            return [];
          }
          var i3 = 0;
          var result = [];
          for (; i3 < len; i3++) {
            result[i3] = this._hydrateValue(i3);
          }
          return result;
        },
        /**
         * Removes all values from this property
         */
        removeAllValues: function() {
          if (this._values) {
            this._values.length = 0;
          }
          this.jCal.length = 3;
        },
        /**
         * Sets the values of the property.  Will overwrite the existing values.
         * This can only be used for multi-value properties.
         *
         * @param {Array} values    An array of values
         */
        setValues: function(values) {
          if (!this.isMultiValue) {
            throw new Error(
              this.name + ": does not not support mulitValue.\noverride isMultiValue"
            );
          }
          var len = values.length;
          var i3 = 0;
          this.removeAllValues();
          if (len > 0 && typeof values[0] === "object" && "icaltype" in values[0]) {
            this.resetType(values[0].icaltype);
          }
          if (this.isDecorated) {
            for (; i3 < len; i3++) {
              this._setDecoratedValue(values[i3], i3);
            }
          } else {
            for (; i3 < len; i3++) {
              this.jCal[VALUE_INDEX + i3] = values[i3];
            }
          }
        },
        /**
         * Sets the current value of the property. If this is a multi-value
         * property, all other values will be removed.
         *
         * @param {String|Object} value     New property value.
         */
        setValue: function(value) {
          this.removeAllValues();
          if (typeof value === "object" && "icaltype" in value) {
            this.resetType(value.icaltype);
          }
          if (this.isDecorated) {
            this._setDecoratedValue(value, 0);
          } else {
            this.jCal[VALUE_INDEX] = value;
          }
        },
        /**
         * Returns the Object representation of this component. The returned object
         * is a live jCal object and should be cloned if modified.
         * @return {Object}
         */
        toJSON: function() {
          return this.jCal;
        },
        /**
         * The string representation of this component.
         * @return {String}
         */
        toICALString: function() {
          return ICAL2.stringify.property(
            this.jCal,
            this._designSet,
            true
          );
        }
      };
      Property.fromString = function(str, designSet) {
        return new Property(ICAL2.parse.property(str, designSet));
      };
      return Property;
    }();
    ICAL2.UtcOffset = function() {
      function UtcOffset(aData) {
        this.fromData(aData);
      }
      UtcOffset.prototype = {
        /**
         * The hours in the utc-offset
         * @type {Number}
         */
        hours: 0,
        /**
         * The minutes in the utc-offset
         * @type {Number}
         */
        minutes: 0,
        /**
         * The sign of the utc offset, 1 for positive offset, -1 for negative
         * offsets.
         * @type {Number}
         */
        factor: 1,
        /**
         * The type name, to be used in the jCal object.
         * @constant
         * @type {String}
         * @default "utc-offset"
         */
        icaltype: "utc-offset",
        /**
         * Returns a clone of the utc offset object.
         *
         * @return {ICAL.UtcOffset}     The cloned object
         */
        clone: function() {
          return ICAL2.UtcOffset.fromSeconds(this.toSeconds());
        },
        /**
         * Sets up the current instance using members from the passed data object.
         *
         * @param {Object} aData          An object with members of the utc offset
         * @param {Number=} aData.hours   The hours for the utc offset
         * @param {Number=} aData.minutes The minutes in the utc offset
         * @param {Number=} aData.factor  The factor for the utc-offset, either -1 or 1
         */
        fromData: function(aData) {
          if (aData) {
            for (var key in aData) {
              if (aData.hasOwnProperty(key)) {
                this[key] = aData[key];
              }
            }
          }
          this._normalize();
        },
        /**
         * Sets up the current instance from the given seconds value. The seconds
         * value is truncated to the minute. Offsets are wrapped when the world
         * ends, the hour after UTC+14:00 is UTC-12:00.
         *
         * @param {Number} aSeconds         The seconds to convert into an offset
         */
        fromSeconds: function(aSeconds) {
          var secs = Math.abs(aSeconds);
          this.factor = aSeconds < 0 ? -1 : 1;
          this.hours = ICAL2.helpers.trunc(secs / 3600);
          secs -= this.hours * 3600;
          this.minutes = ICAL2.helpers.trunc(secs / 60);
          return this;
        },
        /**
         * Convert the current offset to a value in seconds
         *
         * @return {Number}                 The offset in seconds
         */
        toSeconds: function() {
          return this.factor * (60 * this.minutes + 3600 * this.hours);
        },
        /**
         * Compare this utc offset with another one.
         *
         * @param {ICAL.UtcOffset} other        The other offset to compare with
         * @return {Number}                     -1, 0 or 1 for less/equal/greater
         */
        compare: function icaltime_compare(other) {
          var a3 = this.toSeconds();
          var b3 = other.toSeconds();
          return (a3 > b3) - (b3 > a3);
        },
        _normalize: function() {
          var secs = this.toSeconds();
          var factor = this.factor;
          while (secs < -43200) {
            secs += 97200;
          }
          while (secs > 50400) {
            secs -= 97200;
          }
          this.fromSeconds(secs);
          if (secs == 0) {
            this.factor = factor;
          }
        },
        /**
         * The iCalendar string representation of this utc-offset.
         * @return {String}
         */
        toICALString: function() {
          return ICAL2.design.icalendar.value["utc-offset"].toICAL(this.toString());
        },
        /**
         * The string representation of this utc-offset.
         * @return {String}
         */
        toString: function toString() {
          return (this.factor == 1 ? "+" : "-") + ICAL2.helpers.pad2(this.hours) + ":" + ICAL2.helpers.pad2(this.minutes);
        }
      };
      UtcOffset.fromString = function(aString) {
        var options = {};
        options.factor = aString[0] === "+" ? 1 : -1;
        options.hours = ICAL2.helpers.strictParseInt(aString.substr(1, 2));
        options.minutes = ICAL2.helpers.strictParseInt(aString.substr(4, 2));
        return new ICAL2.UtcOffset(options);
      };
      UtcOffset.fromSeconds = function(aSeconds) {
        var instance = new UtcOffset();
        instance.fromSeconds(aSeconds);
        return instance;
      };
      return UtcOffset;
    }();
    ICAL2.Binary = function() {
      function Binary(aValue) {
        this.value = aValue;
      }
      Binary.prototype = {
        /**
         * The type name, to be used in the jCal object.
         * @default "binary"
         * @constant
         */
        icaltype: "binary",
        /**
         * Base64 decode the current value
         *
         * @return {String}         The base64-decoded value
         */
        decodeValue: function decodeValue() {
          return this._b64_decode(this.value);
        },
        /**
         * Encodes the passed parameter with base64 and sets the internal
         * value to the result.
         *
         * @param {String} aValue      The raw binary value to encode
         */
        setEncodedValue: function setEncodedValue(aValue) {
          this.value = this._b64_encode(aValue);
        },
        _b64_encode: function base64_encode(data) {
          var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
          var o1, o2, o3, h1, h22, h3, h4, bits, i3 = 0, ac = 0, enc = "", tmp_arr = [];
          if (!data) {
            return data;
          }
          do {
            o1 = data.charCodeAt(i3++);
            o2 = data.charCodeAt(i3++);
            o3 = data.charCodeAt(i3++);
            bits = o1 << 16 | o2 << 8 | o3;
            h1 = bits >> 18 & 63;
            h22 = bits >> 12 & 63;
            h3 = bits >> 6 & 63;
            h4 = bits & 63;
            tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h22) + b64.charAt(h3) + b64.charAt(h4);
          } while (i3 < data.length);
          enc = tmp_arr.join("");
          var r3 = data.length % 3;
          return (r3 ? enc.slice(0, r3 - 3) : enc) + "===".slice(r3 || 3);
        },
        _b64_decode: function base64_decode(data) {
          var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
          var o1, o2, o3, h1, h22, h3, h4, bits, i3 = 0, ac = 0, dec = "", tmp_arr = [];
          if (!data) {
            return data;
          }
          data += "";
          do {
            h1 = b64.indexOf(data.charAt(i3++));
            h22 = b64.indexOf(data.charAt(i3++));
            h3 = b64.indexOf(data.charAt(i3++));
            h4 = b64.indexOf(data.charAt(i3++));
            bits = h1 << 18 | h22 << 12 | h3 << 6 | h4;
            o1 = bits >> 16 & 255;
            o2 = bits >> 8 & 255;
            o3 = bits & 255;
            if (h3 == 64) {
              tmp_arr[ac++] = String.fromCharCode(o1);
            } else if (h4 == 64) {
              tmp_arr[ac++] = String.fromCharCode(o1, o2);
            } else {
              tmp_arr[ac++] = String.fromCharCode(o1, o2, o3);
            }
          } while (i3 < data.length);
          dec = tmp_arr.join("");
          return dec;
        },
        /**
         * The string representation of this value
         * @return {String}
         */
        toString: function() {
          return this.value;
        }
      };
      Binary.fromString = function(aString) {
        return new Binary(aString);
      };
      return Binary;
    }();
    (function() {
      ICAL2.Period = function icalperiod(aData) {
        this.wrappedJSObject = this;
        if (aData && "start" in aData) {
          if (aData.start && !(aData.start instanceof ICAL2.Time)) {
            throw new TypeError(".start must be an instance of ICAL.Time");
          }
          this.start = aData.start;
        }
        if (aData && aData.end && aData.duration) {
          throw new Error("cannot accept both end and duration");
        }
        if (aData && "end" in aData) {
          if (aData.end && !(aData.end instanceof ICAL2.Time)) {
            throw new TypeError(".end must be an instance of ICAL.Time");
          }
          this.end = aData.end;
        }
        if (aData && "duration" in aData) {
          if (aData.duration && !(aData.duration instanceof ICAL2.Duration)) {
            throw new TypeError(".duration must be an instance of ICAL.Duration");
          }
          this.duration = aData.duration;
        }
      };
      ICAL2.Period.prototype = {
        /**
         * The start of the period
         * @type {ICAL.Time}
         */
        start: null,
        /**
         * The end of the period
         * @type {ICAL.Time}
         */
        end: null,
        /**
         * The duration of the period
         * @type {ICAL.Duration}
         */
        duration: null,
        /**
         * The class identifier.
         * @constant
         * @type {String}
         * @default "icalperiod"
         */
        icalclass: "icalperiod",
        /**
         * The type name, to be used in the jCal object.
         * @constant
         * @type {String}
         * @default "period"
         */
        icaltype: "period",
        /**
         * Returns a clone of the duration object.
         *
         * @return {ICAL.Period}      The cloned object
         */
        clone: function() {
          return ICAL2.Period.fromData({
            start: this.start ? this.start.clone() : null,
            end: this.end ? this.end.clone() : null,
            duration: this.duration ? this.duration.clone() : null
          });
        },
        /**
         * Calculates the duration of the period, either directly or by subtracting
         * start from end date.
         *
         * @return {ICAL.Duration}      The calculated duration
         */
        getDuration: function duration() {
          if (this.duration) {
            return this.duration;
          } else {
            return this.end.subtractDate(this.start);
          }
        },
        /**
         * Calculates the end date of the period, either directly or by adding
         * duration to start date.
         *
         * @return {ICAL.Time}          The calculated end date
         */
        getEnd: function() {
          if (this.end) {
            return this.end;
          } else {
            var end = this.start.clone();
            end.addDuration(this.duration);
            return end;
          }
        },
        /**
         * The string representation of this period.
         * @return {String}
         */
        toString: function toString() {
          return this.start + "/" + (this.end || this.duration);
        },
        /**
         * The jCal representation of this period type.
         * @return {Object}
         */
        toJSON: function() {
          return [this.start.toString(), (this.end || this.duration).toString()];
        },
        /**
         * The iCalendar string representation of this period.
         * @return {String}
         */
        toICALString: function() {
          return this.start.toICALString() + "/" + (this.end || this.duration).toICALString();
        }
      };
      ICAL2.Period.fromString = function fromString(str, prop) {
        var parts = str.split("/");
        if (parts.length !== 2) {
          throw new Error(
            'Invalid string value: "' + str + '" must contain a "/" char.'
          );
        }
        var options = {
          start: ICAL2.Time.fromDateTimeString(parts[0], prop)
        };
        var end = parts[1];
        if (ICAL2.Duration.isValueString(end)) {
          options.duration = ICAL2.Duration.fromString(end);
        } else {
          options.end = ICAL2.Time.fromDateTimeString(end, prop);
        }
        return new ICAL2.Period(options);
      };
      ICAL2.Period.fromData = function fromData(aData) {
        return new ICAL2.Period(aData);
      };
      ICAL2.Period.fromJSON = function(aData, aProp, aLenient) {
        function fromDateOrDateTimeString(aValue, aProp2) {
          if (aLenient) {
            return ICAL2.Time.fromString(aValue, aProp2);
          } else {
            return ICAL2.Time.fromDateTimeString(aValue, aProp2);
          }
        }
        if (ICAL2.Duration.isValueString(aData[1])) {
          return ICAL2.Period.fromData({
            start: fromDateOrDateTimeString(aData[0], aProp),
            duration: ICAL2.Duration.fromString(aData[1])
          });
        } else {
          return ICAL2.Period.fromData({
            start: fromDateOrDateTimeString(aData[0], aProp),
            end: fromDateOrDateTimeString(aData[1], aProp)
          });
        }
      };
    })();
    (function() {
      var DURATION_LETTERS = /([PDWHMTS]{1,1})/;
      ICAL2.Duration = function icalduration(data) {
        this.wrappedJSObject = this;
        this.fromData(data);
      };
      ICAL2.Duration.prototype = {
        /**
         * The weeks in this duration
         * @type {Number}
         * @default 0
         */
        weeks: 0,
        /**
         * The days in this duration
         * @type {Number}
         * @default 0
         */
        days: 0,
        /**
         * The days in this duration
         * @type {Number}
         * @default 0
         */
        hours: 0,
        /**
         * The minutes in this duration
         * @type {Number}
         * @default 0
         */
        minutes: 0,
        /**
         * The seconds in this duration
         * @type {Number}
         * @default 0
         */
        seconds: 0,
        /**
         * The seconds in this duration
         * @type {Boolean}
         * @default false
         */
        isNegative: false,
        /**
         * The class identifier.
         * @constant
         * @type {String}
         * @default "icalduration"
         */
        icalclass: "icalduration",
        /**
         * The type name, to be used in the jCal object.
         * @constant
         * @type {String}
         * @default "duration"
         */
        icaltype: "duration",
        /**
         * Returns a clone of the duration object.
         *
         * @return {ICAL.Duration}      The cloned object
         */
        clone: function clone2() {
          return ICAL2.Duration.fromData(this);
        },
        /**
         * The duration value expressed as a number of seconds.
         *
         * @return {Number}             The duration value in seconds
         */
        toSeconds: function toSeconds() {
          var seconds = this.seconds + 60 * this.minutes + 3600 * this.hours + 86400 * this.days + 7 * 86400 * this.weeks;
          return this.isNegative ? -seconds : seconds;
        },
        /**
         * Reads the passed seconds value into this duration object. Afterwards,
         * members like {@link ICAL.Duration#days days} and {@link ICAL.Duration#weeks weeks} will be set up
         * accordingly.
         *
         * @param {Number} aSeconds     The duration value in seconds
         * @return {ICAL.Duration}      Returns this instance
         */
        fromSeconds: function fromSeconds(aSeconds) {
          var secs = Math.abs(aSeconds);
          this.isNegative = aSeconds < 0;
          this.days = ICAL2.helpers.trunc(secs / 86400);
          if (this.days % 7 == 0) {
            this.weeks = this.days / 7;
            this.days = 0;
          } else {
            this.weeks = 0;
          }
          secs -= (this.days + 7 * this.weeks) * 86400;
          this.hours = ICAL2.helpers.trunc(secs / 3600);
          secs -= this.hours * 3600;
          this.minutes = ICAL2.helpers.trunc(secs / 60);
          secs -= this.minutes * 60;
          this.seconds = secs;
          return this;
        },
        /**
         * Sets up the current instance using members from the passed data object.
         *
         * @param {Object} aData               An object with members of the duration
         * @param {Number} aData.weeks         Duration in weeks
         * @param {Number} aData.days          Duration in days
         * @param {Number} aData.hours         Duration in hours
         * @param {Number} aData.minutes       Duration in minutes
         * @param {Number} aData.seconds       Duration in seconds
         * @param {Boolean} aData.isNegative   If true, the duration is negative
         */
        fromData: function fromData(aData) {
          var propsToCopy = [
            "weeks",
            "days",
            "hours",
            "minutes",
            "seconds",
            "isNegative"
          ];
          for (var key in propsToCopy) {
            if (!propsToCopy.hasOwnProperty(key)) {
              continue;
            }
            var prop = propsToCopy[key];
            if (aData && prop in aData) {
              this[prop] = aData[prop];
            } else {
              this[prop] = 0;
            }
          }
        },
        /**
         * Resets the duration instance to the default values, i.e. PT0S
         */
        reset: function reset() {
          this.isNegative = false;
          this.weeks = 0;
          this.days = 0;
          this.hours = 0;
          this.minutes = 0;
          this.seconds = 0;
        },
        /**
         * Compares the duration instance with another one.
         *
         * @param {ICAL.Duration} aOther        The instance to compare with
         * @return {Number}                     -1, 0 or 1 for less/equal/greater
         */
        compare: function compare(aOther) {
          var thisSeconds = this.toSeconds();
          var otherSeconds = aOther.toSeconds();
          return (thisSeconds > otherSeconds) - (thisSeconds < otherSeconds);
        },
        /**
         * Normalizes the duration instance. For example, a duration with a value
         * of 61 seconds will be normalized to 1 minute and 1 second.
         */
        normalize: function normalize() {
          this.fromSeconds(this.toSeconds());
        },
        /**
         * The string representation of this duration.
         * @return {String}
         */
        toString: function toString() {
          if (this.toSeconds() == 0) {
            return "PT0S";
          } else {
            var str = "";
            if (this.isNegative)
              str += "-";
            str += "P";
            if (this.weeks)
              str += this.weeks + "W";
            if (this.days)
              str += this.days + "D";
            if (this.hours || this.minutes || this.seconds) {
              str += "T";
              if (this.hours)
                str += this.hours + "H";
              if (this.minutes)
                str += this.minutes + "M";
              if (this.seconds)
                str += this.seconds + "S";
            }
            return str;
          }
        },
        /**
         * The iCalendar string representation of this duration.
         * @return {String}
         */
        toICALString: function() {
          return this.toString();
        }
      };
      ICAL2.Duration.fromSeconds = function icalduration_from_seconds(aSeconds) {
        return new ICAL2.Duration().fromSeconds(aSeconds);
      };
      function parseDurationChunk(letter, number, object) {
        var type;
        switch (letter) {
          case "P":
            if (number && number === "-") {
              object.isNegative = true;
            } else {
              object.isNegative = false;
            }
            break;
          case "D":
            type = "days";
            break;
          case "W":
            type = "weeks";
            break;
          case "H":
            type = "hours";
            break;
          case "M":
            type = "minutes";
            break;
          case "S":
            type = "seconds";
            break;
          default:
            return 0;
        }
        if (type) {
          if (!number && number !== 0) {
            throw new Error(
              'invalid duration value: Missing number before "' + letter + '"'
            );
          }
          var num = parseInt(number, 10);
          if (ICAL2.helpers.isStrictlyNaN(num)) {
            throw new Error(
              'invalid duration value: Invalid number "' + number + '" before "' + letter + '"'
            );
          }
          object[type] = num;
        }
        return 1;
      }
      ICAL2.Duration.isValueString = function(string) {
        return string[0] === "P" || string[1] === "P";
      };
      ICAL2.Duration.fromString = function icalduration_from_string(aStr) {
        var pos = 0;
        var dict = /* @__PURE__ */ Object.create(null);
        var chunks = 0;
        while ((pos = aStr.search(DURATION_LETTERS)) !== -1) {
          var type = aStr[pos];
          var numeric = aStr.substr(0, pos);
          aStr = aStr.substr(pos + 1);
          chunks += parseDurationChunk(type, numeric, dict);
        }
        if (chunks < 2) {
          throw new Error(
            'invalid duration value: Not enough duration components in "' + aStr + '"'
          );
        }
        return new ICAL2.Duration(dict);
      };
      ICAL2.Duration.fromData = function icalduration_from_data(aData) {
        return new ICAL2.Duration(aData);
      };
    })();
    (function() {
      var OPTIONS = [
        "tzid",
        "location",
        "tznames",
        "latitude",
        "longitude"
      ];
      ICAL2.Timezone = function icaltimezone(data) {
        this.wrappedJSObject = this;
        this.fromData(data);
      };
      ICAL2.Timezone.prototype = {
        /**
         * Timezone identifier
         * @type {String}
         */
        tzid: "",
        /**
         * Timezone location
         * @type {String}
         */
        location: "",
        /**
         * Alternative timezone name, for the string representation
         * @type {String}
         */
        tznames: "",
        /**
         * The primary latitude for the timezone.
         * @type {Number}
         */
        latitude: 0,
        /**
         * The primary longitude for the timezone.
         * @type {Number}
         */
        longitude: 0,
        /**
         * The vtimezone component for this timezone.
         * @type {ICAL.Component}
         */
        component: null,
        /**
         * The year this timezone has been expanded to. All timezone transition
         * dates until this year are known and can be used for calculation
         *
         * @private
         * @type {Number}
         */
        expandedUntilYear: 0,
        /**
         * The class identifier.
         * @constant
         * @type {String}
         * @default "icaltimezone"
         */
        icalclass: "icaltimezone",
        /**
         * Sets up the current instance using members from the passed data object.
         *
         * @param {ICAL.Component|Object} aData options for class
         * @param {String|ICAL.Component} aData.component
         *        If aData is a simple object, then this member can be set to either a
         *        string containing the component data, or an already parsed
         *        ICAL.Component
         * @param {String} aData.tzid      The timezone identifier
         * @param {String} aData.location  The timezone locationw
         * @param {String} aData.tznames   An alternative string representation of the
         *                                  timezone
         * @param {Number} aData.latitude  The latitude of the timezone
         * @param {Number} aData.longitude The longitude of the timezone
         */
        fromData: function fromData(aData) {
          this.expandedUntilYear = 0;
          this.changes = [];
          if (aData instanceof ICAL2.Component) {
            this.component = aData;
          } else {
            if (aData && "component" in aData) {
              if (typeof aData.component == "string") {
                var jCal = ICAL2.parse(aData.component);
                this.component = new ICAL2.Component(jCal);
              } else if (aData.component instanceof ICAL2.Component) {
                this.component = aData.component;
              } else {
                this.component = null;
              }
            }
            for (var key in OPTIONS) {
              if (OPTIONS.hasOwnProperty(key)) {
                var prop = OPTIONS[key];
                if (aData && prop in aData) {
                  this[prop] = aData[prop];
                }
              }
            }
          }
          if (this.component instanceof ICAL2.Component && !this.tzid) {
            this.tzid = this.component.getFirstPropertyValue("tzid");
          }
          return this;
        },
        /**
         * Finds the utcOffset the given time would occur in this timezone.
         *
         * @param {ICAL.Time} tt        The time to check for
         * @return {Number} utc offset in seconds
         */
        utcOffset: function utcOffset(tt) {
          if (this == ICAL2.Timezone.utcTimezone || this == ICAL2.Timezone.localTimezone) {
            return 0;
          }
          this._ensureCoverage(tt.year);
          if (!this.changes.length) {
            return 0;
          }
          var tt_change = {
            year: tt.year,
            month: tt.month,
            day: tt.day,
            hour: tt.hour,
            minute: tt.minute,
            second: tt.second
          };
          var change_num = this._findNearbyChange(tt_change);
          var change_num_to_use = -1;
          var step = 1;
          for (; ; ) {
            var change = ICAL2.helpers.clone(this.changes[change_num], true);
            if (change.utcOffset < change.prevUtcOffset) {
              ICAL2.Timezone.adjust_change(change, 0, 0, 0, change.utcOffset);
            } else {
              ICAL2.Timezone.adjust_change(
                change,
                0,
                0,
                0,
                change.prevUtcOffset
              );
            }
            var cmp = ICAL2.Timezone._compare_change_fn(tt_change, change);
            if (cmp >= 0) {
              change_num_to_use = change_num;
            } else {
              step = -1;
            }
            if (step == -1 && change_num_to_use != -1) {
              break;
            }
            change_num += step;
            if (change_num < 0) {
              return 0;
            }
            if (change_num >= this.changes.length) {
              break;
            }
          }
          var zone_change = this.changes[change_num_to_use];
          var utcOffset_change = zone_change.utcOffset - zone_change.prevUtcOffset;
          if (utcOffset_change < 0 && change_num_to_use > 0) {
            var tmp_change = ICAL2.helpers.clone(zone_change, true);
            ICAL2.Timezone.adjust_change(
              tmp_change,
              0,
              0,
              0,
              tmp_change.prevUtcOffset
            );
            if (ICAL2.Timezone._compare_change_fn(tt_change, tmp_change) < 0) {
              var prev_zone_change = this.changes[change_num_to_use - 1];
              var want_daylight = false;
              if (zone_change.is_daylight != want_daylight && prev_zone_change.is_daylight == want_daylight) {
                zone_change = prev_zone_change;
              }
            }
          }
          return zone_change.utcOffset;
        },
        _findNearbyChange: function icaltimezone_find_nearby_change(change) {
          var idx = ICAL2.helpers.binsearchInsert(
            this.changes,
            change,
            ICAL2.Timezone._compare_change_fn
          );
          if (idx >= this.changes.length) {
            return this.changes.length - 1;
          }
          return idx;
        },
        _ensureCoverage: function(aYear) {
          if (ICAL2.Timezone._minimumExpansionYear == -1) {
            var today = ICAL2.Time.now();
            ICAL2.Timezone._minimumExpansionYear = today.year;
          }
          var changesEndYear = aYear;
          if (changesEndYear < ICAL2.Timezone._minimumExpansionYear) {
            changesEndYear = ICAL2.Timezone._minimumExpansionYear;
          }
          changesEndYear += ICAL2.Timezone.EXTRA_COVERAGE;
          if (changesEndYear > ICAL2.Timezone.MAX_YEAR) {
            changesEndYear = ICAL2.Timezone.MAX_YEAR;
          }
          if (!this.changes.length || this.expandedUntilYear < aYear) {
            var subcomps = this.component.getAllSubcomponents();
            var compLen = subcomps.length;
            var compIdx = 0;
            for (; compIdx < compLen; compIdx++) {
              this._expandComponent(
                subcomps[compIdx],
                changesEndYear,
                this.changes
              );
            }
            this.changes.sort(ICAL2.Timezone._compare_change_fn);
            this.expandedUntilYear = changesEndYear;
          }
        },
        _expandComponent: function(aComponent, aYear, changes) {
          if (!aComponent.hasProperty("dtstart") || !aComponent.hasProperty("tzoffsetto") || !aComponent.hasProperty("tzoffsetfrom")) {
            return null;
          }
          var dtstart = aComponent.getFirstProperty("dtstart").getFirstValue();
          var change;
          function convert_tzoffset(offset) {
            return offset.factor * (offset.hours * 3600 + offset.minutes * 60);
          }
          function init_changes() {
            var changebase = {};
            changebase.is_daylight = aComponent.name == "daylight";
            changebase.utcOffset = convert_tzoffset(
              aComponent.getFirstProperty("tzoffsetto").getFirstValue()
            );
            changebase.prevUtcOffset = convert_tzoffset(
              aComponent.getFirstProperty("tzoffsetfrom").getFirstValue()
            );
            return changebase;
          }
          if (!aComponent.hasProperty("rrule") && !aComponent.hasProperty("rdate")) {
            change = init_changes();
            change.year = dtstart.year;
            change.month = dtstart.month;
            change.day = dtstart.day;
            change.hour = dtstart.hour;
            change.minute = dtstart.minute;
            change.second = dtstart.second;
            ICAL2.Timezone.adjust_change(
              change,
              0,
              0,
              0,
              -change.prevUtcOffset
            );
            changes.push(change);
          } else {
            var props = aComponent.getAllProperties("rdate");
            for (var rdatekey in props) {
              if (!props.hasOwnProperty(rdatekey)) {
                continue;
              }
              var rdate = props[rdatekey];
              var time = rdate.getFirstValue();
              change = init_changes();
              change.year = time.year;
              change.month = time.month;
              change.day = time.day;
              if (time.isDate) {
                change.hour = dtstart.hour;
                change.minute = dtstart.minute;
                change.second = dtstart.second;
                if (dtstart.zone != ICAL2.Timezone.utcTimezone) {
                  ICAL2.Timezone.adjust_change(
                    change,
                    0,
                    0,
                    0,
                    -change.prevUtcOffset
                  );
                }
              } else {
                change.hour = time.hour;
                change.minute = time.minute;
                change.second = time.second;
                if (time.zone != ICAL2.Timezone.utcTimezone) {
                  ICAL2.Timezone.adjust_change(
                    change,
                    0,
                    0,
                    0,
                    -change.prevUtcOffset
                  );
                }
              }
              changes.push(change);
            }
            var rrule = aComponent.getFirstProperty("rrule");
            if (rrule) {
              rrule = rrule.getFirstValue();
              change = init_changes();
              if (rrule.until && rrule.until.zone == ICAL2.Timezone.utcTimezone) {
                rrule.until.adjust(0, 0, 0, change.prevUtcOffset);
                rrule.until.zone = ICAL2.Timezone.localTimezone;
              }
              var iterator = rrule.iterator(dtstart);
              var occ;
              while (occ = iterator.next()) {
                change = init_changes();
                if (occ.year > aYear || !occ) {
                  break;
                }
                change.year = occ.year;
                change.month = occ.month;
                change.day = occ.day;
                change.hour = occ.hour;
                change.minute = occ.minute;
                change.second = occ.second;
                change.isDate = occ.isDate;
                ICAL2.Timezone.adjust_change(
                  change,
                  0,
                  0,
                  0,
                  -change.prevUtcOffset
                );
                changes.push(change);
              }
            }
          }
          return changes;
        },
        /**
         * The string representation of this timezone.
         * @return {String}
         */
        toString: function toString() {
          return this.tznames ? this.tznames : this.tzid;
        }
      };
      ICAL2.Timezone._compare_change_fn = function icaltimezone_compare_change_fn(a3, b3) {
        if (a3.year < b3.year)
          return -1;
        else if (a3.year > b3.year)
          return 1;
        if (a3.month < b3.month)
          return -1;
        else if (a3.month > b3.month)
          return 1;
        if (a3.day < b3.day)
          return -1;
        else if (a3.day > b3.day)
          return 1;
        if (a3.hour < b3.hour)
          return -1;
        else if (a3.hour > b3.hour)
          return 1;
        if (a3.minute < b3.minute)
          return -1;
        else if (a3.minute > b3.minute)
          return 1;
        if (a3.second < b3.second)
          return -1;
        else if (a3.second > b3.second)
          return 1;
        return 0;
      };
      ICAL2.Timezone.convert_time = function icaltimezone_convert_time(tt, from_zone, to_zone) {
        if (tt.isDate || from_zone.tzid == to_zone.tzid || from_zone == ICAL2.Timezone.localTimezone || to_zone == ICAL2.Timezone.localTimezone) {
          tt.zone = to_zone;
          return tt;
        }
        var utcOffset = from_zone.utcOffset(tt);
        tt.adjust(0, 0, 0, -utcOffset);
        utcOffset = to_zone.utcOffset(tt);
        tt.adjust(0, 0, 0, utcOffset);
        return null;
      };
      ICAL2.Timezone.fromData = function icaltimezone_fromData(aData) {
        var tt = new ICAL2.Timezone();
        return tt.fromData(aData);
      };
      ICAL2.Timezone.utcTimezone = ICAL2.Timezone.fromData({
        tzid: "UTC"
      });
      ICAL2.Timezone.localTimezone = ICAL2.Timezone.fromData({
        tzid: "floating"
      });
      ICAL2.Timezone.adjust_change = function icaltimezone_adjust_change(change, days, hours, minutes, seconds) {
        return ICAL2.Time.prototype.adjust.call(
          change,
          days,
          hours,
          minutes,
          seconds,
          change
        );
      };
      ICAL2.Timezone._minimumExpansionYear = -1;
      ICAL2.Timezone.MAX_YEAR = 2035;
      ICAL2.Timezone.EXTRA_COVERAGE = 5;
    })();
    ICAL2.TimezoneService = function() {
      var zones;
      var TimezoneService = {
        get count() {
          return Object.keys(zones).length;
        },
        reset: function() {
          zones = /* @__PURE__ */ Object.create(null);
          var utc = ICAL2.Timezone.utcTimezone;
          zones.Z = utc;
          zones.UTC = utc;
          zones.GMT = utc;
        },
        /**
         * Checks if timezone id has been registered.
         *
         * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)
         * @return {Boolean}        False, when not present
         */
        has: function(tzid) {
          return !!zones[tzid];
        },
        /**
         * Returns a timezone by its tzid if present.
         *
         * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)
         * @return {?ICAL.Timezone} The timezone, or null if not found
         */
        get: function(tzid) {
          return zones[tzid];
        },
        /**
         * Registers a timezone object or component.
         *
         * @param {String=} name
         *        The name of the timezone. Defaults to the component's TZID if not
         *        passed.
         * @param {ICAL.Component|ICAL.Timezone} zone
         *        The initialized zone or vtimezone.
         */
        register: function(name, timezone) {
          if (name instanceof ICAL2.Component) {
            if (name.name === "vtimezone") {
              timezone = new ICAL2.Timezone(name);
              name = timezone.tzid;
            }
          }
          if (timezone instanceof ICAL2.Timezone) {
            zones[name] = timezone;
          } else {
            throw new TypeError("timezone must be ICAL.Timezone or ICAL.Component");
          }
        },
        /**
         * Removes a timezone by its tzid from the list.
         *
         * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)
         * @return {?ICAL.Timezone} The removed timezone, or null if not registered
         */
        remove: function(tzid) {
          return delete zones[tzid];
        }
      };
      TimezoneService.reset();
      return TimezoneService;
    }();
    (function() {
      ICAL2.Time = function icaltime(data, zone) {
        this.wrappedJSObject = this;
        var time = this._time = /* @__PURE__ */ Object.create(null);
        time.year = 0;
        time.month = 1;
        time.day = 1;
        time.hour = 0;
        time.minute = 0;
        time.second = 0;
        time.isDate = false;
        this.fromData(data, zone);
      };
      ICAL2.Time._dowCache = {};
      ICAL2.Time._wnCache = {};
      ICAL2.Time.prototype = {
        /**
         * The class identifier.
         * @constant
         * @type {String}
         * @default "icaltime"
         */
        icalclass: "icaltime",
        _cachedUnixTime: null,
        /**
         * The type name, to be used in the jCal object. This value may change and
         * is strictly defined by the {@link ICAL.Time#isDate isDate} member.
         * @readonly
         * @type {String}
         * @default "date-time"
         */
        get icaltype() {
          return this.isDate ? "date" : "date-time";
        },
        /**
         * The timezone for this time.
         * @type {ICAL.Timezone}
         */
        zone: null,
        /**
         * Internal uses to indicate that a change has been made and the next read
         * operation must attempt to normalize the value (for example changing the
         * day to 33).
         *
         * @type {Boolean}
         * @private
         */
        _pendingNormalization: false,
        /**
         * Returns a clone of the time object.
         *
         * @return {ICAL.Time}              The cloned object
         */
        clone: function() {
          return new ICAL2.Time(this._time, this.zone);
        },
        /**
         * Reset the time instance to epoch time
         */
        reset: function icaltime_reset() {
          this.fromData(ICAL2.Time.epochTime);
          this.zone = ICAL2.Timezone.utcTimezone;
        },
        /**
         * Reset the time instance to the given date/time values.
         *
         * @param {Number} year             The year to set
         * @param {Number} month            The month to set
         * @param {Number} day              The day to set
         * @param {Number} hour             The hour to set
         * @param {Number} minute           The minute to set
         * @param {Number} second           The second to set
         * @param {ICAL.Timezone} timezone  The timezone to set
         */
        resetTo: function icaltime_resetTo(year, month, day, hour, minute, second, timezone) {
          this.fromData({
            year,
            month,
            day,
            hour,
            minute,
            second,
            zone: timezone
          });
        },
        /**
         * Set up the current instance from the Javascript date value.
         *
         * @param {?Date} aDate     The Javascript Date to read, or null to reset
         * @param {Boolean} useUTC  If true, the UTC values of the date will be used
         */
        fromJSDate: function icaltime_fromJSDate(aDate, useUTC) {
          if (!aDate) {
            this.reset();
          } else {
            if (useUTC) {
              this.zone = ICAL2.Timezone.utcTimezone;
              this.year = aDate.getUTCFullYear();
              this.month = aDate.getUTCMonth() + 1;
              this.day = aDate.getUTCDate();
              this.hour = aDate.getUTCHours();
              this.minute = aDate.getUTCMinutes();
              this.second = aDate.getUTCSeconds();
            } else {
              this.zone = ICAL2.Timezone.localTimezone;
              this.year = aDate.getFullYear();
              this.month = aDate.getMonth() + 1;
              this.day = aDate.getDate();
              this.hour = aDate.getHours();
              this.minute = aDate.getMinutes();
              this.second = aDate.getSeconds();
            }
          }
          this._cachedUnixTime = null;
          return this;
        },
        /**
         * Sets up the current instance using members from the passed data object.
         *
         * @param {Object} aData            Time initialization
         * @param {Number=} aData.year      The year for this date
         * @param {Number=} aData.month     The month for this date
         * @param {Number=} aData.day       The day for this date
         * @param {Number=} aData.hour      The hour for this date
         * @param {Number=} aData.minute    The minute for this date
         * @param {Number=} aData.second    The second for this date
         * @param {Boolean=} aData.isDate   If true, the instance represents a date
         *                                    (as opposed to a date-time)
         * @param {ICAL.Timezone=} aZone    Timezone this position occurs in
         */
        fromData: function fromData(aData, aZone) {
          if (aData) {
            for (var key in aData) {
              if (Object.prototype.hasOwnProperty.call(aData, key)) {
                if (key === "icaltype")
                  continue;
                this[key] = aData[key];
              }
            }
          }
          if (aZone) {
            this.zone = aZone;
          }
          if (aData && !("isDate" in aData)) {
            this.isDate = !("hour" in aData);
          } else if (aData && "isDate" in aData) {
            this.isDate = aData.isDate;
          }
          if (aData && "timezone" in aData) {
            var zone = ICAL2.TimezoneService.get(
              aData.timezone
            );
            this.zone = zone || ICAL2.Timezone.localTimezone;
          }
          if (aData && "zone" in aData) {
            this.zone = aData.zone;
          }
          if (!this.zone) {
            this.zone = ICAL2.Timezone.localTimezone;
          }
          this._cachedUnixTime = null;
          return this;
        },
        /**
         * Calculate the day of week.
         * @param {ICAL.Time.weekDay=} aWeekStart
         *        The week start weekday, defaults to SUNDAY
         * @return {ICAL.Time.weekDay}
         */
        dayOfWeek: function icaltime_dayOfWeek(aWeekStart) {
          var firstDow = aWeekStart || ICAL2.Time.SUNDAY;
          var dowCacheKey = (this.year << 12) + (this.month << 8) + (this.day << 3) + firstDow;
          if (dowCacheKey in ICAL2.Time._dowCache) {
            return ICAL2.Time._dowCache[dowCacheKey];
          }
          var q3 = this.day;
          var m3 = this.month + (this.month < 3 ? 12 : 0);
          var Y = this.year - (this.month < 3 ? 1 : 0);
          var h3 = q3 + Y + ICAL2.helpers.trunc((m3 + 1) * 26 / 10) + ICAL2.helpers.trunc(Y / 4);
          if (true) {
            h3 += ICAL2.helpers.trunc(Y / 100) * 6 + ICAL2.helpers.trunc(Y / 400);
          } else {
            h3 += 5;
          }
          h3 = (h3 + 7 - firstDow) % 7 + 1;
          ICAL2.Time._dowCache[dowCacheKey] = h3;
          return h3;
        },
        /**
         * Calculate the day of year.
         * @return {Number}
         */
        dayOfYear: function dayOfYear() {
          var is_leap = ICAL2.Time.isLeapYear(this.year) ? 1 : 0;
          var diypm = ICAL2.Time.daysInYearPassedMonth;
          return diypm[is_leap][this.month - 1] + this.day;
        },
        /**
         * Returns a copy of the current date/time, rewound to the start of the
         * week. The resulting ICAL.Time instance is of icaltype date, even if this
         * is a date-time.
         *
         * @param {ICAL.Time.weekDay=} aWeekStart
         *        The week start weekday, defaults to SUNDAY
         * @return {ICAL.Time}      The start of the week (cloned)
         */
        startOfWeek: function startOfWeek(aWeekStart) {
          var firstDow = aWeekStart || ICAL2.Time.SUNDAY;
          var result = this.clone();
          result.day -= (this.dayOfWeek() + 7 - firstDow) % 7;
          result.isDate = true;
          result.hour = 0;
          result.minute = 0;
          result.second = 0;
          return result;
        },
        /**
         * Returns a copy of the current date/time, shifted to the end of the week.
         * The resulting ICAL.Time instance is of icaltype date, even if this is a
         * date-time.
         *
         * @param {ICAL.Time.weekDay=} aWeekStart
         *        The week start weekday, defaults to SUNDAY
         * @return {ICAL.Time}      The end of the week (cloned)
         */
        endOfWeek: function endOfWeek(aWeekStart) {
          var firstDow = aWeekStart || ICAL2.Time.SUNDAY;
          var result = this.clone();
          result.day += (7 - this.dayOfWeek() + firstDow - ICAL2.Time.SUNDAY) % 7;
          result.isDate = true;
          result.hour = 0;
          result.minute = 0;
          result.second = 0;
          return result;
        },
        /**
         * Returns a copy of the current date/time, rewound to the start of the
         * month. The resulting ICAL.Time instance is of icaltype date, even if
         * this is a date-time.
         *
         * @return {ICAL.Time}      The start of the month (cloned)
         */
        startOfMonth: function startOfMonth() {
          var result = this.clone();
          result.day = 1;
          result.isDate = true;
          result.hour = 0;
          result.minute = 0;
          result.second = 0;
          return result;
        },
        /**
         * Returns a copy of the current date/time, shifted to the end of the
         * month.  The resulting ICAL.Time instance is of icaltype date, even if
         * this is a date-time.
         *
         * @return {ICAL.Time}      The end of the month (cloned)
         */
        endOfMonth: function endOfMonth() {
          var result = this.clone();
          result.day = ICAL2.Time.daysInMonth(result.month, result.year);
          result.isDate = true;
          result.hour = 0;
          result.minute = 0;
          result.second = 0;
          return result;
        },
        /**
         * Returns a copy of the current date/time, rewound to the start of the
         * year. The resulting ICAL.Time instance is of icaltype date, even if
         * this is a date-time.
         *
         * @return {ICAL.Time}      The start of the year (cloned)
         */
        startOfYear: function startOfYear() {
          var result = this.clone();
          result.day = 1;
          result.month = 1;
          result.isDate = true;
          result.hour = 0;
          result.minute = 0;
          result.second = 0;
          return result;
        },
        /**
         * Returns a copy of the current date/time, shifted to the end of the
         * year.  The resulting ICAL.Time instance is of icaltype date, even if
         * this is a date-time.
         *
         * @return {ICAL.Time}      The end of the year (cloned)
         */
        endOfYear: function endOfYear() {
          var result = this.clone();
          result.day = 31;
          result.month = 12;
          result.isDate = true;
          result.hour = 0;
          result.minute = 0;
          result.second = 0;
          return result;
        },
        /**
         * First calculates the start of the week, then returns the day of year for
         * this date. If the day falls into the previous year, the day is zero or negative.
         *
         * @param {ICAL.Time.weekDay=} aFirstDayOfWeek
         *        The week start weekday, defaults to SUNDAY
         * @return {Number}     The calculated day of year
         */
        startDoyWeek: function startDoyWeek(aFirstDayOfWeek) {
          var firstDow = aFirstDayOfWeek || ICAL2.Time.SUNDAY;
          var delta = this.dayOfWeek() - firstDow;
          if (delta < 0)
            delta += 7;
          return this.dayOfYear() - delta;
        },
        /**
         * Get the dominical letter for the current year. Letters range from A - G
         * for common years, and AG to GF for leap years.
         *
         * @param {Number} yr           The year to retrieve the letter for
         * @return {String}             The dominical letter.
         */
        getDominicalLetter: function() {
          return ICAL2.Time.getDominicalLetter(this.year);
        },
        /**
         * Finds the nthWeekDay relative to the current month (not day).  The
         * returned value is a day relative the month that this month belongs to so
         * 1 would indicate the first of the month and 40 would indicate a day in
         * the following month.
         *
         * @param {Number} aDayOfWeek   Day of the week see the day name constants
         * @param {Number} aPos         Nth occurrence of a given week day values
         *        of 1 and 0 both indicate the first weekday of that type. aPos may
         *        be either positive or negative
         *
         * @return {Number} numeric value indicating a day relative
         *                   to the current month of this time object
         */
        nthWeekDay: function icaltime_nthWeekDay(aDayOfWeek, aPos) {
          var daysInMonth = ICAL2.Time.daysInMonth(this.month, this.year);
          var weekday;
          var pos = aPos;
          var start = 0;
          var otherDay = this.clone();
          if (pos >= 0) {
            otherDay.day = 1;
            if (pos != 0) {
              pos--;
            }
            start = otherDay.day;
            var startDow = otherDay.dayOfWeek();
            var offset = aDayOfWeek - startDow;
            if (offset < 0)
              offset += 7;
            start += offset;
            start -= aDayOfWeek;
            weekday = aDayOfWeek;
          } else {
            otherDay.day = daysInMonth;
            var endDow = otherDay.dayOfWeek();
            pos++;
            weekday = endDow - aDayOfWeek;
            if (weekday < 0) {
              weekday += 7;
            }
            weekday = daysInMonth - weekday;
          }
          weekday += pos * 7;
          return start + weekday;
        },
        /**
         * Checks if current time is the nth weekday, relative to the current
         * month.  Will always return false when rule resolves outside of current
         * month.
         *
         * @param {ICAL.Time.weekDay} aDayOfWeek       Day of week to check
         * @param {Number} aPos                        Relative position
         * @return {Boolean}                           True, if it is the nth weekday
         */
        isNthWeekDay: function(aDayOfWeek, aPos) {
          var dow = this.dayOfWeek();
          if (aPos === 0 && dow === aDayOfWeek) {
            return true;
          }
          var day = this.nthWeekDay(aDayOfWeek, aPos);
          if (day === this.day) {
            return true;
          }
          return false;
        },
        /**
         * Calculates the ISO 8601 week number. The first week of a year is the
         * week that contains the first Thursday. The year can have 53 weeks, if
         * January 1st is a Friday.
         *
         * Note there are regions where the first week of the year is the one that
         * starts on January 1st, which may offset the week number. Also, if a
         * different week start is specified, this will also affect the week
         * number.
         *
         * @see ICAL.Time.weekOneStarts
         * @param {ICAL.Time.weekDay} aWeekStart        The weekday the week starts with
         * @return {Number}                             The ISO week number
         */
        weekNumber: function weekNumber(aWeekStart) {
          var wnCacheKey = (this.year << 12) + (this.month << 8) + (this.day << 3) + aWeekStart;
          if (wnCacheKey in ICAL2.Time._wnCache) {
            return ICAL2.Time._wnCache[wnCacheKey];
          }
          var week1;
          var dt = this.clone();
          dt.isDate = true;
          var isoyear = this.year;
          if (dt.month == 12 && dt.day > 25) {
            week1 = ICAL2.Time.weekOneStarts(isoyear + 1, aWeekStart);
            if (dt.compare(week1) < 0) {
              week1 = ICAL2.Time.weekOneStarts(isoyear, aWeekStart);
            } else {
              isoyear++;
            }
          } else {
            week1 = ICAL2.Time.weekOneStarts(isoyear, aWeekStart);
            if (dt.compare(week1) < 0) {
              week1 = ICAL2.Time.weekOneStarts(--isoyear, aWeekStart);
            }
          }
          var daysBetween2 = dt.subtractDate(week1).toSeconds() / 86400;
          var answer = ICAL2.helpers.trunc(daysBetween2 / 7) + 1;
          ICAL2.Time._wnCache[wnCacheKey] = answer;
          return answer;
        },
        /**
         * Adds the duration to the current time. The instance is modified in
         * place.
         *
         * @param {ICAL.Duration} aDuration         The duration to add
         */
        addDuration: function icaltime_add(aDuration) {
          var mult = aDuration.isNegative ? -1 : 1;
          var second = this.second;
          var minute = this.minute;
          var hour = this.hour;
          var day = this.day;
          second += mult * aDuration.seconds;
          minute += mult * aDuration.minutes;
          hour += mult * aDuration.hours;
          day += mult * aDuration.days;
          day += mult * 7 * aDuration.weeks;
          this.second = second;
          this.minute = minute;
          this.hour = hour;
          this.day = day;
          this._cachedUnixTime = null;
        },
        /**
         * Subtract the date details (_excluding_ timezone).  Useful for finding
         * the relative difference between two time objects excluding their
         * timezone differences.
         *
         * @param {ICAL.Time} aDate     The date to substract
         * @return {ICAL.Duration}      The difference as a duration
         */
        subtractDate: function icaltime_subtract(aDate) {
          var unixTime = this.toUnixTime() + this.utcOffset();
          var other = aDate.toUnixTime() + aDate.utcOffset();
          return ICAL2.Duration.fromSeconds(unixTime - other);
        },
        /**
         * Subtract the date details, taking timezones into account.
         *
         * @param {ICAL.Time} aDate  The date to subtract
         * @return {ICAL.Duration}  The difference in duration
         */
        subtractDateTz: function icaltime_subtract_abs(aDate) {
          var unixTime = this.toUnixTime();
          var other = aDate.toUnixTime();
          return ICAL2.Duration.fromSeconds(unixTime - other);
        },
        /**
         * Compares the ICAL.Time instance with another one.
         *
         * @param {ICAL.Duration} aOther        The instance to compare with
         * @return {Number}                     -1, 0 or 1 for less/equal/greater
         */
        compare: function icaltime_compare(other) {
          var a3 = this.toUnixTime();
          var b3 = other.toUnixTime();
          if (a3 > b3)
            return 1;
          if (b3 > a3)
            return -1;
          return 0;
        },
        /**
         * Compares only the date part of this instance with another one.
         *
         * @param {ICAL.Duration} other         The instance to compare with
         * @param {ICAL.Timezone} tz            The timezone to compare in
         * @return {Number}                     -1, 0 or 1 for less/equal/greater
         */
        compareDateOnlyTz: function icaltime_compareDateOnlyTz(other, tz) {
          function cmp(attr) {
            return ICAL2.Time._cmp_attr(a3, b3, attr);
          }
          var a3 = this.convertToZone(tz);
          var b3 = other.convertToZone(tz);
          var rc = 0;
          if ((rc = cmp("year")) != 0)
            return rc;
          if ((rc = cmp("month")) != 0)
            return rc;
          if ((rc = cmp("day")) != 0)
            return rc;
          return rc;
        },
        /**
         * Convert the instance into another timezone. The returned ICAL.Time
         * instance is always a copy.
         *
         * @param {ICAL.Timezone} zone      The zone to convert to
         * @return {ICAL.Time}              The copy, converted to the zone
         */
        convertToZone: function convertToZone(zone) {
          var copy = this.clone();
          var zone_equals = this.zone.tzid == zone.tzid;
          if (!this.isDate && !zone_equals) {
            ICAL2.Timezone.convert_time(copy, this.zone, zone);
          }
          copy.zone = zone;
          return copy;
        },
        /**
         * Calculates the UTC offset of the current date/time in the timezone it is
         * in.
         *
         * @return {Number}     UTC offset in seconds
         */
        utcOffset: function utc_offset() {
          if (this.zone == ICAL2.Timezone.localTimezone || this.zone == ICAL2.Timezone.utcTimezone) {
            return 0;
          } else {
            return this.zone.utcOffset(this);
          }
        },
        /**
         * Returns an RFC 5545 compliant ical representation of this object.
         *
         * @return {String} ical date/date-time
         */
        toICALString: function() {
          var string = this.toString();
          if (string.length > 10) {
            return ICAL2.design.icalendar.value["date-time"].toICAL(string);
          } else {
            return ICAL2.design.icalendar.value.date.toICAL(string);
          }
        },
        /**
         * The string representation of this date/time, in jCal form
         * (including : and - separators).
         * @return {String}
         */
        toString: function toString() {
          var result = this.year + "-" + ICAL2.helpers.pad2(this.month) + "-" + ICAL2.helpers.pad2(this.day);
          if (!this.isDate) {
            result += "T" + ICAL2.helpers.pad2(this.hour) + ":" + ICAL2.helpers.pad2(this.minute) + ":" + ICAL2.helpers.pad2(this.second);
            if (this.zone === ICAL2.Timezone.utcTimezone) {
              result += "Z";
            }
          }
          return result;
        },
        /**
         * Converts the current instance to a Javascript date
         * @return {Date}
         */
        toJSDate: function toJSDate() {
          if (this.zone == ICAL2.Timezone.localTimezone) {
            if (this.isDate) {
              return new Date(this.year, this.month - 1, this.day);
            } else {
              return new Date(
                this.year,
                this.month - 1,
                this.day,
                this.hour,
                this.minute,
                this.second,
                0
              );
            }
          } else {
            return new Date(this.toUnixTime() * 1e3);
          }
        },
        _normalize: function icaltime_normalize() {
          var isDate2 = this._time.isDate;
          if (this._time.isDate) {
            this._time.hour = 0;
            this._time.minute = 0;
            this._time.second = 0;
          }
          this.adjust(0, 0, 0, 0);
          return this;
        },
        /**
         * Adjust the date/time by the given offset
         *
         * @param {Number} aExtraDays       The extra amount of days
         * @param {Number} aExtraHours      The extra amount of hours
         * @param {Number} aExtraMinutes    The extra amount of minutes
         * @param {Number} aExtraSeconds    The extra amount of seconds
         * @param {Number=} aTime           The time to adjust, defaults to the
         *                                    current instance.
         */
        adjust: function icaltime_adjust(aExtraDays, aExtraHours, aExtraMinutes, aExtraSeconds, aTime) {
          var minutesOverflow, hoursOverflow, daysOverflow = 0, yearsOverflow = 0;
          var second, minute, hour, day;
          var daysInMonth;
          var time = aTime || this._time;
          if (!time.isDate) {
            second = time.second + aExtraSeconds;
            time.second = second % 60;
            minutesOverflow = ICAL2.helpers.trunc(second / 60);
            if (time.second < 0) {
              time.second += 60;
              minutesOverflow--;
            }
            minute = time.minute + aExtraMinutes + minutesOverflow;
            time.minute = minute % 60;
            hoursOverflow = ICAL2.helpers.trunc(minute / 60);
            if (time.minute < 0) {
              time.minute += 60;
              hoursOverflow--;
            }
            hour = time.hour + aExtraHours + hoursOverflow;
            time.hour = hour % 24;
            daysOverflow = ICAL2.helpers.trunc(hour / 24);
            if (time.hour < 0) {
              time.hour += 24;
              daysOverflow--;
            }
          }
          if (time.month > 12) {
            yearsOverflow = ICAL2.helpers.trunc((time.month - 1) / 12);
          } else if (time.month < 1) {
            yearsOverflow = ICAL2.helpers.trunc(time.month / 12) - 1;
          }
          time.year += yearsOverflow;
          time.month -= 12 * yearsOverflow;
          day = time.day + aExtraDays + daysOverflow;
          if (day > 0) {
            for (; ; ) {
              daysInMonth = ICAL2.Time.daysInMonth(time.month, time.year);
              if (day <= daysInMonth) {
                break;
              }
              time.month++;
              if (time.month > 12) {
                time.year++;
                time.month = 1;
              }
              day -= daysInMonth;
            }
          } else {
            while (day <= 0) {
              if (time.month == 1) {
                time.year--;
                time.month = 12;
              } else {
                time.month--;
              }
              day += ICAL2.Time.daysInMonth(time.month, time.year);
            }
          }
          time.day = day;
          this._cachedUnixTime = null;
          return this;
        },
        /**
         * Sets up the current instance from unix time, the number of seconds since
         * January 1st, 1970.
         *
         * @param {Number} seconds      The seconds to set up with
         */
        fromUnixTime: function fromUnixTime(seconds) {
          this.zone = ICAL2.Timezone.utcTimezone;
          var epoch = ICAL2.Time.epochTime.clone();
          epoch.adjust(0, 0, 0, seconds);
          this.year = epoch.year;
          this.month = epoch.month;
          this.day = epoch.day;
          this.hour = epoch.hour;
          this.minute = epoch.minute;
          this.second = Math.floor(epoch.second);
          this._cachedUnixTime = null;
        },
        /**
         * Converts the current instance to seconds since January 1st 1970.
         *
         * @return {Number}         Seconds since 1970
         */
        toUnixTime: function toUnixTime() {
          if (this._cachedUnixTime !== null) {
            return this._cachedUnixTime;
          }
          var offset = this.utcOffset();
          var ms = Date.UTC(
            this.year,
            this.month - 1,
            this.day,
            this.hour,
            this.minute,
            this.second - offset
          );
          this._cachedUnixTime = ms / 1e3;
          return this._cachedUnixTime;
        },
        /**
         * Converts time to into Object which can be serialized then re-created
         * using the constructor.
         *
         * @example
         * // toJSON will automatically be called
         * var json = JSON.stringify(mytime);
         *
         * var deserialized = JSON.parse(json);
         *
         * var time = new ICAL.Time(deserialized);
         *
         * @return {Object}
         */
        toJSON: function() {
          var copy = [
            "year",
            "month",
            "day",
            "hour",
            "minute",
            "second",
            "isDate"
          ];
          var result = /* @__PURE__ */ Object.create(null);
          var i3 = 0;
          var len = copy.length;
          var prop;
          for (; i3 < len; i3++) {
            prop = copy[i3];
            result[prop] = this[prop];
          }
          if (this.zone) {
            result.timezone = this.zone.tzid;
          }
          return result;
        }
      };
      (function setupNormalizeAttributes() {
        function defineAttr(attr) {
          Object.defineProperty(ICAL2.Time.prototype, attr, {
            get: function getTimeAttr() {
              if (this._pendingNormalization) {
                this._normalize();
                this._pendingNormalization = false;
              }
              return this._time[attr];
            },
            set: function setTimeAttr(val) {
              if (attr === "isDate" && val && !this._time.isDate) {
                this.adjust(0, 0, 0, 0);
              }
              this._cachedUnixTime = null;
              this._pendingNormalization = true;
              this._time[attr] = val;
              return val;
            }
          });
        }
        if ("defineProperty" in Object) {
          defineAttr("year");
          defineAttr("month");
          defineAttr("day");
          defineAttr("hour");
          defineAttr("minute");
          defineAttr("second");
          defineAttr("isDate");
        }
      })();
      ICAL2.Time.daysInMonth = function icaltime_daysInMonth(month, year) {
        var _daysInMonth = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        var days = 30;
        if (month < 1 || month > 12)
          return days;
        days = _daysInMonth[month];
        if (month == 2) {
          days += ICAL2.Time.isLeapYear(year);
        }
        return days;
      };
      ICAL2.Time.isLeapYear = function isLeapYear2(year) {
        if (year <= 1752) {
          return year % 4 == 0;
        } else {
          return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
        }
      };
      ICAL2.Time.fromDayOfYear = function icaltime_fromDayOfYear(aDayOfYear, aYear) {
        var year = aYear;
        var doy = aDayOfYear;
        var tt = new ICAL2.Time();
        tt.auto_normalize = false;
        var is_leap = ICAL2.Time.isLeapYear(year) ? 1 : 0;
        if (doy < 1) {
          year--;
          is_leap = ICAL2.Time.isLeapYear(year) ? 1 : 0;
          doy += ICAL2.Time.daysInYearPassedMonth[is_leap][12];
          return ICAL2.Time.fromDayOfYear(doy, year);
        } else if (doy > ICAL2.Time.daysInYearPassedMonth[is_leap][12]) {
          is_leap = ICAL2.Time.isLeapYear(year) ? 1 : 0;
          doy -= ICAL2.Time.daysInYearPassedMonth[is_leap][12];
          year++;
          return ICAL2.Time.fromDayOfYear(doy, year);
        }
        tt.year = year;
        tt.isDate = true;
        for (var month = 11; month >= 0; month--) {
          if (doy > ICAL2.Time.daysInYearPassedMonth[is_leap][month]) {
            tt.month = month + 1;
            tt.day = doy - ICAL2.Time.daysInYearPassedMonth[is_leap][month];
            break;
          }
        }
        tt.auto_normalize = true;
        return tt;
      };
      ICAL2.Time.fromStringv2 = function fromString(str) {
        return new ICAL2.Time({
          year: parseInt(str.substr(0, 4), 10),
          month: parseInt(str.substr(5, 2), 10),
          day: parseInt(str.substr(8, 2), 10),
          isDate: true
        });
      };
      ICAL2.Time.fromDateString = function(aValue) {
        return new ICAL2.Time({
          year: ICAL2.helpers.strictParseInt(aValue.substr(0, 4)),
          month: ICAL2.helpers.strictParseInt(aValue.substr(5, 2)),
          day: ICAL2.helpers.strictParseInt(aValue.substr(8, 2)),
          isDate: true
        });
      };
      ICAL2.Time.fromDateTimeString = function(aValue, prop) {
        if (aValue.length < 19) {
          throw new Error(
            'invalid date-time value: "' + aValue + '"'
          );
        }
        var zone;
        if (aValue[19] && aValue[19] === "Z") {
          zone = "Z";
        } else if (prop) {
          zone = prop.getParameter("tzid");
        }
        var time = new ICAL2.Time({
          year: ICAL2.helpers.strictParseInt(aValue.substr(0, 4)),
          month: ICAL2.helpers.strictParseInt(aValue.substr(5, 2)),
          day: ICAL2.helpers.strictParseInt(aValue.substr(8, 2)),
          hour: ICAL2.helpers.strictParseInt(aValue.substr(11, 2)),
          minute: ICAL2.helpers.strictParseInt(aValue.substr(14, 2)),
          second: ICAL2.helpers.strictParseInt(aValue.substr(17, 2)),
          timezone: zone
        });
        return time;
      };
      ICAL2.Time.fromString = function fromString(aValue, aProperty) {
        if (aValue.length > 10) {
          return ICAL2.Time.fromDateTimeString(aValue, aProperty);
        } else {
          return ICAL2.Time.fromDateString(aValue);
        }
      };
      ICAL2.Time.fromJSDate = function fromJSDate(aDate, useUTC) {
        var tt = new ICAL2.Time();
        return tt.fromJSDate(aDate, useUTC);
      };
      ICAL2.Time.fromData = function fromData(aData, aZone) {
        var t3 = new ICAL2.Time();
        return t3.fromData(aData, aZone);
      };
      ICAL2.Time.now = function icaltime_now() {
        return ICAL2.Time.fromJSDate(new Date(), false);
      };
      ICAL2.Time.weekOneStarts = function weekOneStarts(aYear, aWeekStart) {
        var t3 = ICAL2.Time.fromData({
          year: aYear,
          month: 1,
          day: 1,
          isDate: true
        });
        var dow = t3.dayOfWeek();
        var wkst = aWeekStart || ICAL2.Time.DEFAULT_WEEK_START;
        if (dow > ICAL2.Time.THURSDAY) {
          t3.day += 7;
        }
        if (wkst > ICAL2.Time.THURSDAY) {
          t3.day -= 7;
        }
        t3.day -= dow - wkst;
        return t3;
      };
      ICAL2.Time.getDominicalLetter = function(yr) {
        var LTRS = "GFEDCBA";
        var dom = (yr + (yr / 4 | 0) + (yr / 400 | 0) - (yr / 100 | 0) - 1) % 7;
        var isLeap = ICAL2.Time.isLeapYear(yr);
        if (isLeap) {
          return LTRS[(dom + 6) % 7] + LTRS[dom];
        } else {
          return LTRS[dom];
        }
      };
      ICAL2.Time.epochTime = ICAL2.Time.fromData({
        year: 1970,
        month: 1,
        day: 1,
        hour: 0,
        minute: 0,
        second: 0,
        isDate: false,
        timezone: "Z"
      });
      ICAL2.Time._cmp_attr = function _cmp_attr(a3, b3, attr) {
        if (a3[attr] > b3[attr])
          return 1;
        if (a3[attr] < b3[attr])
          return -1;
        return 0;
      };
      ICAL2.Time.daysInYearPassedMonth = [
        [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365],
        [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366]
      ];
      ICAL2.Time.SUNDAY = 1;
      ICAL2.Time.MONDAY = 2;
      ICAL2.Time.TUESDAY = 3;
      ICAL2.Time.WEDNESDAY = 4;
      ICAL2.Time.THURSDAY = 5;
      ICAL2.Time.FRIDAY = 6;
      ICAL2.Time.SATURDAY = 7;
      ICAL2.Time.DEFAULT_WEEK_START = ICAL2.Time.MONDAY;
    })();
    (function() {
      ICAL2.VCardTime = function(data, zone, icaltype) {
        this.wrappedJSObject = this;
        var time = this._time = /* @__PURE__ */ Object.create(null);
        time.year = null;
        time.month = null;
        time.day = null;
        time.hour = null;
        time.minute = null;
        time.second = null;
        this.icaltype = icaltype || "date-and-or-time";
        this.fromData(data, zone);
      };
      ICAL2.helpers.inherits(
        ICAL2.Time,
        ICAL2.VCardTime,
        /** @lends ICAL.VCardTime */
        {
          /**
           * The class identifier.
           * @constant
           * @type {String}
           * @default "vcardtime"
           */
          icalclass: "vcardtime",
          /**
           * The type name, to be used in the jCal object.
           * @type {String}
           * @default "date-and-or-time"
           */
          icaltype: "date-and-or-time",
          /**
           * The timezone. This can either be floating, UTC, or an instance of
           * ICAL.UtcOffset.
           * @type {ICAL.Timezone|ICAL.UtcOFfset}
           */
          zone: null,
          /**
           * Returns a clone of the vcard date/time object.
           *
           * @return {ICAL.VCardTime}     The cloned object
           */
          clone: function() {
            return new ICAL2.VCardTime(this._time, this.zone, this.icaltype);
          },
          _normalize: function() {
            return this;
          },
          /**
           * @inheritdoc
           */
          utcOffset: function() {
            if (this.zone instanceof ICAL2.UtcOffset) {
              return this.zone.toSeconds();
            } else {
              return ICAL2.Time.prototype.utcOffset.apply(this, arguments);
            }
          },
          /**
           * Returns an RFC 6350 compliant representation of this object.
           *
           * @return {String}         vcard date/time string
           */
          toICALString: function() {
            return ICAL2.design.vcard.value[this.icaltype].toICAL(this.toString());
          },
          /**
           * The string representation of this date/time, in jCard form
           * (including : and - separators).
           * @return {String}
           */
          toString: function toString() {
            var p22 = ICAL2.helpers.pad2;
            var y3 = this.year, m3 = this.month, d2 = this.day;
            var h3 = this.hour, mm = this.minute, s3 = this.second;
            var hasYear = y3 !== null, hasMonth = m3 !== null, hasDay = d2 !== null;
            var hasHour = h3 !== null, hasMinute = mm !== null, hasSecond = s3 !== null;
            var datepart = (hasYear ? p22(y3) + (hasMonth || hasDay ? "-" : "") : hasMonth || hasDay ? "--" : "") + (hasMonth ? p22(m3) : "") + (hasDay ? "-" + p22(d2) : "");
            var timepart = (hasHour ? p22(h3) : "-") + (hasHour && hasMinute ? ":" : "") + (hasMinute ? p22(mm) : "") + (!hasHour && !hasMinute ? "-" : "") + (hasMinute && hasSecond ? ":" : "") + (hasSecond ? p22(s3) : "");
            var zone;
            if (this.zone === ICAL2.Timezone.utcTimezone) {
              zone = "Z";
            } else if (this.zone instanceof ICAL2.UtcOffset) {
              zone = this.zone.toString();
            } else if (this.zone === ICAL2.Timezone.localTimezone) {
              zone = "";
            } else if (this.zone instanceof ICAL2.Timezone) {
              var offset = ICAL2.UtcOffset.fromSeconds(this.zone.utcOffset(this));
              zone = offset.toString();
            } else {
              zone = "";
            }
            switch (this.icaltype) {
              case "time":
                return timepart + zone;
              case "date-and-or-time":
              case "date-time":
                return datepart + (timepart == "--" ? "" : "T" + timepart + zone);
              case "date":
                return datepart;
            }
            return null;
          }
        }
      );
      ICAL2.VCardTime.fromDateAndOrTimeString = function(aValue, aIcalType) {
        function part(v3, s3, e3) {
          return v3 ? ICAL2.helpers.strictParseInt(v3.substr(s3, e3)) : null;
        }
        var parts = aValue.split("T");
        var dt = parts[0], tmz = parts[1];
        var splitzone = tmz ? ICAL2.design.vcard.value.time._splitZone(tmz) : [];
        var zone = splitzone[0], tm = splitzone[1];
        var stoi = ICAL2.helpers.strictParseInt;
        var dtlen = dt ? dt.length : 0;
        var tmlen = tm ? tm.length : 0;
        var hasDashDate = dt && dt[0] == "-" && dt[1] == "-";
        var hasDashTime = tm && tm[0] == "-";
        var o2 = {
          year: hasDashDate ? null : part(dt, 0, 4),
          month: hasDashDate && (dtlen == 4 || dtlen == 7) ? part(dt, 2, 2) : dtlen == 7 ? part(dt, 5, 2) : dtlen == 10 ? part(dt, 5, 2) : null,
          day: dtlen == 5 ? part(dt, 3, 2) : dtlen == 7 && hasDashDate ? part(dt, 5, 2) : dtlen == 10 ? part(dt, 8, 2) : null,
          hour: hasDashTime ? null : part(tm, 0, 2),
          minute: hasDashTime && tmlen == 3 ? part(tm, 1, 2) : tmlen > 4 ? hasDashTime ? part(tm, 1, 2) : part(tm, 3, 2) : null,
          second: tmlen == 4 ? part(tm, 2, 2) : tmlen == 6 ? part(tm, 4, 2) : tmlen == 8 ? part(tm, 6, 2) : null
        };
        if (zone == "Z") {
          zone = ICAL2.Timezone.utcTimezone;
        } else if (zone && zone[3] == ":") {
          zone = ICAL2.UtcOffset.fromString(zone);
        } else {
          zone = null;
        }
        return new ICAL2.VCardTime(o2, zone, aIcalType);
      };
    })();
    (function() {
      var DOW_MAP = {
        SU: ICAL2.Time.SUNDAY,
        MO: ICAL2.Time.MONDAY,
        TU: ICAL2.Time.TUESDAY,
        WE: ICAL2.Time.WEDNESDAY,
        TH: ICAL2.Time.THURSDAY,
        FR: ICAL2.Time.FRIDAY,
        SA: ICAL2.Time.SATURDAY
      };
      var REVERSE_DOW_MAP = {};
      for (var key in DOW_MAP) {
        if (DOW_MAP.hasOwnProperty(key)) {
          REVERSE_DOW_MAP[DOW_MAP[key]] = key;
        }
      }
      var COPY_PARTS = [
        "BYSECOND",
        "BYMINUTE",
        "BYHOUR",
        "BYDAY",
        "BYMONTHDAY",
        "BYYEARDAY",
        "BYWEEKNO",
        "BYMONTH",
        "BYSETPOS"
      ];
      ICAL2.Recur = function icalrecur(data) {
        this.wrappedJSObject = this;
        this.parts = {};
        if (data && typeof data === "object") {
          this.fromData(data);
        }
      };
      ICAL2.Recur.prototype = {
        /**
         * An object holding the BY-parts of the recurrence rule
         * @type {Object}
         */
        parts: null,
        /**
         * The interval value for the recurrence rule.
         * @type {Number}
         */
        interval: 1,
        /**
         * The week start day
         *
         * @type {ICAL.Time.weekDay}
         * @default ICAL.Time.MONDAY
         */
        wkst: ICAL2.Time.MONDAY,
        /**
         * The end of the recurrence
         * @type {?ICAL.Time}
         */
        until: null,
        /**
         * The maximum number of occurrences
         * @type {?Number}
         */
        count: null,
        /**
         * The frequency value.
         * @type {ICAL.Recur.frequencyValues}
         */
        freq: null,
        /**
         * The class identifier.
         * @constant
         * @type {String}
         * @default "icalrecur"
         */
        icalclass: "icalrecur",
        /**
         * The type name, to be used in the jCal object.
         * @constant
         * @type {String}
         * @default "recur"
         */
        icaltype: "recur",
        /**
         * Create a new iterator for this recurrence rule. The passed start date
         * must be the start date of the event, not the start of the range to
         * search in.
         *
         * @example
         * var recur = comp.getFirstPropertyValue('rrule');
         * var dtstart = comp.getFirstPropertyValue('dtstart');
         * var iter = recur.iterator(dtstart);
         * for (var next = iter.next(); next; next = iter.next()) {
         *   if (next.compare(rangeStart) < 0) {
         *     continue;
         *   }
         *   console.log(next.toString());
         * }
         *
         * @param {ICAL.Time} aStart        The item's start date
         * @return {ICAL.RecurIterator}     The recurrence iterator
         */
        iterator: function(aStart) {
          return new ICAL2.RecurIterator({
            rule: this,
            dtstart: aStart
          });
        },
        /**
         * Returns a clone of the recurrence object.
         *
         * @return {ICAL.Recur}      The cloned object
         */
        clone: function clone2() {
          return new ICAL2.Recur(this.toJSON());
        },
        /**
         * Checks if the current rule is finite, i.e. has a count or until part.
         *
         * @return {Boolean}        True, if the rule is finite
         */
        isFinite: function isfinite() {
          return !!(this.count || this.until);
        },
        /**
         * Checks if the current rule has a count part, and not limited by an until
         * part.
         *
         * @return {Boolean}        True, if the rule is by count
         */
        isByCount: function isbycount() {
          return !!(this.count && !this.until);
        },
        /**
         * Adds a component (part) to the recurrence rule. This is not a component
         * in the sense of {@link ICAL.Component}, but a part of the recurrence
         * rule, i.e. BYMONTH.
         *
         * @param {String} aType            The name of the component part
         * @param {Array|String} aValue     The component value
         */
        addComponent: function addPart(aType, aValue) {
          var ucname = aType.toUpperCase();
          if (ucname in this.parts) {
            this.parts[ucname].push(aValue);
          } else {
            this.parts[ucname] = [aValue];
          }
        },
        /**
         * Sets the component value for the given by-part.
         *
         * @param {String} aType        The component part name
         * @param {Array} aValues       The component values
         */
        setComponent: function setComponent(aType, aValues) {
          this.parts[aType.toUpperCase()] = aValues.slice();
        },
        /**
         * Gets (a copy) of the requested component value.
         *
         * @param {String} aType        The component part name
         * @return {Array}              The component part value
         */
        getComponent: function getComponent(aType) {
          var ucname = aType.toUpperCase();
          return ucname in this.parts ? this.parts[ucname].slice() : [];
        },
        /**
         * Retrieves the next occurrence after the given recurrence id. See the
         * guide on {@tutorial terminology} for more details.
         *
         * NOTE: Currently, this method iterates all occurrences from the start
         * date. It should not be called in a loop for performance reasons. If you
         * would like to get more than one occurrence, you can iterate the
         * occurrences manually, see the example on the
         * {@link ICAL.Recur#iterator iterator} method.
         *
         * @param {ICAL.Time} aStartTime        The start of the event series
         * @param {ICAL.Time} aRecurrenceId     The date of the last occurrence
         * @return {ICAL.Time}                  The next occurrence after
         */
        getNextOccurrence: function getNextOccurrence(aStartTime, aRecurrenceId) {
          var iter2 = this.iterator(aStartTime);
          var next, cdt;
          do {
            next = iter2.next();
          } while (next && next.compare(aRecurrenceId) <= 0);
          if (next && aRecurrenceId.zone) {
            next.zone = aRecurrenceId.zone;
          }
          return next;
        },
        /**
         * Sets up the current instance using members from the passed data object.
         *
         * @param {Object} data                               An object with members of the recurrence
         * @param {ICAL.Recur.frequencyValues=} data.freq     The frequency value
         * @param {Number=} data.interval                     The INTERVAL value
         * @param {ICAL.Time.weekDay=} data.wkst              The week start value
         * @param {ICAL.Time=} data.until                     The end of the recurrence set
         * @param {Number=} data.count                        The number of occurrences
         * @param {Array.<Number>=} data.bysecond             The seconds for the BYSECOND part
         * @param {Array.<Number>=} data.byminute             The minutes for the BYMINUTE part
         * @param {Array.<Number>=} data.byhour               The hours for the BYHOUR part
         * @param {Array.<String>=} data.byday                The BYDAY values
         * @param {Array.<Number>=} data.bymonthday           The days for the BYMONTHDAY part
         * @param {Array.<Number>=} data.byyearday            The days for the BYYEARDAY part
         * @param {Array.<Number>=} data.byweekno             The weeks for the BYWEEKNO part
         * @param {Array.<Number>=} data.bymonth              The month for the BYMONTH part
         * @param {Array.<Number>=} data.bysetpos             The positionals for the BYSETPOS part
         */
        fromData: function(data) {
          for (var key2 in data) {
            var uckey = key2.toUpperCase();
            if (uckey in partDesign) {
              if (Array.isArray(data[key2])) {
                this.parts[uckey] = data[key2];
              } else {
                this.parts[uckey] = [data[key2]];
              }
            } else {
              this[key2] = data[key2];
            }
          }
          if (this.interval && typeof this.interval != "number") {
            optionDesign.INTERVAL(this.interval, this);
          }
          if (this.wkst && typeof this.wkst != "number") {
            this.wkst = ICAL2.Recur.icalDayToNumericDay(this.wkst);
          }
          if (this.until && !(this.until instanceof ICAL2.Time)) {
            this.until = ICAL2.Time.fromString(this.until);
          }
        },
        /**
         * The jCal representation of this recurrence type.
         * @return {Object}
         */
        toJSON: function() {
          var res = /* @__PURE__ */ Object.create(null);
          res.freq = this.freq;
          if (this.count) {
            res.count = this.count;
          }
          if (this.interval > 1) {
            res.interval = this.interval;
          }
          for (var k3 in this.parts) {
            if (!this.parts.hasOwnProperty(k3)) {
              continue;
            }
            var kparts = this.parts[k3];
            if (Array.isArray(kparts) && kparts.length == 1) {
              res[k3.toLowerCase()] = kparts[0];
            } else {
              res[k3.toLowerCase()] = ICAL2.helpers.clone(this.parts[k3]);
            }
          }
          if (this.until) {
            res.until = this.until.toString();
          }
          if ("wkst" in this && this.wkst !== ICAL2.Time.DEFAULT_WEEK_START) {
            res.wkst = ICAL2.Recur.numericDayToIcalDay(this.wkst);
          }
          return res;
        },
        /**
         * The string representation of this recurrence rule.
         * @return {String}
         */
        toString: function icalrecur_toString() {
          var str = "FREQ=" + this.freq;
          if (this.count) {
            str += ";COUNT=" + this.count;
          }
          if (this.interval > 1) {
            str += ";INTERVAL=" + this.interval;
          }
          for (var k3 in this.parts) {
            if (this.parts.hasOwnProperty(k3)) {
              str += ";" + k3 + "=" + this.parts[k3];
            }
          }
          if (this.until) {
            str += ";UNTIL=" + this.until.toICALString();
          }
          if ("wkst" in this && this.wkst !== ICAL2.Time.DEFAULT_WEEK_START) {
            str += ";WKST=" + ICAL2.Recur.numericDayToIcalDay(this.wkst);
          }
          return str;
        }
      };
      function parseNumericValue(type, min, max, value) {
        var result = value;
        if (value[0] === "+") {
          result = value.substr(1);
        }
        result = ICAL2.helpers.strictParseInt(result);
        if (min !== void 0 && value < min) {
          throw new Error(
            type + ': invalid value "' + value + '" must be > ' + min
          );
        }
        if (max !== void 0 && value > max) {
          throw new Error(
            type + ': invalid value "' + value + '" must be < ' + min
          );
        }
        return result;
      }
      ICAL2.Recur.icalDayToNumericDay = function toNumericDay(string, aWeekStart) {
        var firstDow = aWeekStart || ICAL2.Time.SUNDAY;
        return (DOW_MAP[string] - firstDow + 7) % 7 + 1;
      };
      ICAL2.Recur.numericDayToIcalDay = function toIcalDay(num, aWeekStart) {
        var firstDow = aWeekStart || ICAL2.Time.SUNDAY;
        var dow = num + firstDow - ICAL2.Time.SUNDAY;
        if (dow > 7) {
          dow -= 7;
        }
        return REVERSE_DOW_MAP[dow];
      };
      var VALID_DAY_NAMES = /^(SU|MO|TU|WE|TH|FR|SA)$/;
      var VALID_BYDAY_PART = /^([+-])?(5[0-3]|[1-4][0-9]|[1-9])?(SU|MO|TU|WE|TH|FR|SA)$/;
      var ALLOWED_FREQ = [
        "SECONDLY",
        "MINUTELY",
        "HOURLY",
        "DAILY",
        "WEEKLY",
        "MONTHLY",
        "YEARLY"
      ];
      var optionDesign = {
        FREQ: function(value, dict, fmtIcal) {
          if (ALLOWED_FREQ.indexOf(value) !== -1) {
            dict.freq = value;
          } else {
            throw new Error(
              'invalid frequency "' + value + '" expected: "' + ALLOWED_FREQ.join(", ") + '"'
            );
          }
        },
        COUNT: function(value, dict, fmtIcal) {
          dict.count = ICAL2.helpers.strictParseInt(value);
        },
        INTERVAL: function(value, dict, fmtIcal) {
          dict.interval = ICAL2.helpers.strictParseInt(value);
          if (dict.interval < 1) {
            dict.interval = 1;
          }
        },
        UNTIL: function(value, dict, fmtIcal) {
          if (value.length > 10) {
            dict.until = ICAL2.design.icalendar.value["date-time"].fromICAL(value);
          } else {
            dict.until = ICAL2.design.icalendar.value.date.fromICAL(value);
          }
          if (!fmtIcal) {
            dict.until = ICAL2.Time.fromString(dict.until);
          }
        },
        WKST: function(value, dict, fmtIcal) {
          if (VALID_DAY_NAMES.test(value)) {
            dict.wkst = ICAL2.Recur.icalDayToNumericDay(value);
          } else {
            throw new Error('invalid WKST value "' + value + '"');
          }
        }
      };
      var partDesign = {
        BYSECOND: parseNumericValue.bind(this, "BYSECOND", 0, 60),
        BYMINUTE: parseNumericValue.bind(this, "BYMINUTE", 0, 59),
        BYHOUR: parseNumericValue.bind(this, "BYHOUR", 0, 23),
        BYDAY: function(value) {
          if (VALID_BYDAY_PART.test(value)) {
            return value;
          } else {
            throw new Error('invalid BYDAY value "' + value + '"');
          }
        },
        BYMONTHDAY: parseNumericValue.bind(this, "BYMONTHDAY", -31, 31),
        BYYEARDAY: parseNumericValue.bind(this, "BYYEARDAY", -366, 366),
        BYWEEKNO: parseNumericValue.bind(this, "BYWEEKNO", -53, 53),
        BYMONTH: parseNumericValue.bind(this, "BYMONTH", 1, 12),
        BYSETPOS: parseNumericValue.bind(this, "BYSETPOS", -366, 366)
      };
      ICAL2.Recur.fromString = function(string) {
        var data = ICAL2.Recur._stringToData(string, false);
        return new ICAL2.Recur(data);
      };
      ICAL2.Recur.fromData = function(aData) {
        return new ICAL2.Recur(aData);
      };
      ICAL2.Recur._stringToData = function(string, fmtIcal) {
        var dict = /* @__PURE__ */ Object.create(null);
        var values = string.split(";");
        var len = values.length;
        for (var i3 = 0; i3 < len; i3++) {
          var parts = values[i3].split("=");
          var ucname = parts[0].toUpperCase();
          var lcname = parts[0].toLowerCase();
          var name = fmtIcal ? lcname : ucname;
          var value = parts[1];
          if (ucname in partDesign) {
            var partArr = value.split(",");
            var partArrIdx = 0;
            var partArrLen = partArr.length;
            for (; partArrIdx < partArrLen; partArrIdx++) {
              partArr[partArrIdx] = partDesign[ucname](partArr[partArrIdx]);
            }
            dict[name] = partArr.length == 1 ? partArr[0] : partArr;
          } else if (ucname in optionDesign) {
            optionDesign[ucname](value, dict, fmtIcal);
          } else {
            dict[lcname] = value;
          }
        }
        return dict;
      };
    })();
    ICAL2.RecurIterator = function() {
      function icalrecur_iterator(options) {
        this.fromData(options);
      }
      icalrecur_iterator.prototype = {
        /**
         * True when iteration is finished.
         * @type {Boolean}
         */
        completed: false,
        /**
         * The rule that is being iterated
         * @type {ICAL.Recur}
         */
        rule: null,
        /**
         * The start date of the event being iterated.
         * @type {ICAL.Time}
         */
        dtstart: null,
        /**
         * The last occurrence that was returned from the
         * {@link ICAL.RecurIterator#next} method.
         * @type {ICAL.Time}
         */
        last: null,
        /**
         * The sequence number from the occurrence
         * @type {Number}
         */
        occurrence_number: 0,
        /**
         * The indices used for the {@link ICAL.RecurIterator#by_data} object.
         * @type {Object}
         * @private
         */
        by_indices: null,
        /**
         * If true, the iterator has already been initialized
         * @type {Boolean}
         * @private
         */
        initialized: false,
        /**
         * The initializd by-data.
         * @type {Object}
         * @private
         */
        by_data: null,
        /**
         * The expanded yeardays
         * @type {Array}
         * @private
         */
        days: null,
        /**
         * The index in the {@link ICAL.RecurIterator#days} array.
         * @type {Number}
         * @private
         */
        days_index: 0,
        /**
         * Initialize the recurrence iterator from the passed data object. This
         * method is usually not called directly, you can initialize the iterator
         * through the constructor.
         *
         * @param {Object} options                The iterator options
         * @param {ICAL.Recur} options.rule       The rule to iterate.
         * @param {ICAL.Time} options.dtstart     The start date of the event.
         * @param {Boolean=} options.initialized  When true, assume that options are
         *        from a previously constructed iterator. Initialization will not be
         *        repeated.
         */
        fromData: function(options) {
          this.rule = ICAL2.helpers.formatClassType(options.rule, ICAL2.Recur);
          if (!this.rule) {
            throw new Error("iterator requires a (ICAL.Recur) rule");
          }
          this.dtstart = ICAL2.helpers.formatClassType(options.dtstart, ICAL2.Time);
          if (!this.dtstart) {
            throw new Error("iterator requires a (ICAL.Time) dtstart");
          }
          if (options.by_data) {
            this.by_data = options.by_data;
          } else {
            this.by_data = ICAL2.helpers.clone(this.rule.parts, true);
          }
          if (options.occurrence_number)
            this.occurrence_number = options.occurrence_number;
          this.days = options.days || [];
          if (options.last) {
            this.last = ICAL2.helpers.formatClassType(options.last, ICAL2.Time);
          }
          this.by_indices = options.by_indices;
          if (!this.by_indices) {
            this.by_indices = {
              "BYSECOND": 0,
              "BYMINUTE": 0,
              "BYHOUR": 0,
              "BYDAY": 0,
              "BYMONTH": 0,
              "BYWEEKNO": 0,
              "BYMONTHDAY": 0
            };
          }
          this.initialized = options.initialized || false;
          if (!this.initialized) {
            this.init();
          }
        },
        /**
         * Intialize the iterator
         * @private
         */
        init: function icalrecur_iterator_init() {
          this.initialized = true;
          this.last = this.dtstart.clone();
          var parts = this.by_data;
          if ("BYDAY" in parts) {
            this.sort_byday_rules(parts.BYDAY);
          }
          if ("BYYEARDAY" in parts) {
            if ("BYMONTH" in parts || "BYWEEKNO" in parts || "BYMONTHDAY" in parts || "BYDAY" in parts) {
              throw new Error("Invalid BYYEARDAY rule");
            }
          }
          if ("BYWEEKNO" in parts && "BYMONTHDAY" in parts) {
            throw new Error("BYWEEKNO does not fit to BYMONTHDAY");
          }
          if (this.rule.freq == "MONTHLY" && ("BYYEARDAY" in parts || "BYWEEKNO" in parts)) {
            throw new Error("For MONTHLY recurrences neither BYYEARDAY nor BYWEEKNO may appear");
          }
          if (this.rule.freq == "WEEKLY" && ("BYYEARDAY" in parts || "BYMONTHDAY" in parts)) {
            throw new Error("For WEEKLY recurrences neither BYMONTHDAY nor BYYEARDAY may appear");
          }
          if (this.rule.freq != "YEARLY" && "BYYEARDAY" in parts) {
            throw new Error("BYYEARDAY may only appear in YEARLY rules");
          }
          this.last.second = this.setup_defaults("BYSECOND", "SECONDLY", this.dtstart.second);
          this.last.minute = this.setup_defaults("BYMINUTE", "MINUTELY", this.dtstart.minute);
          this.last.hour = this.setup_defaults("BYHOUR", "HOURLY", this.dtstart.hour);
          this.last.day = this.setup_defaults("BYMONTHDAY", "DAILY", this.dtstart.day);
          this.last.month = this.setup_defaults("BYMONTH", "MONTHLY", this.dtstart.month);
          if (this.rule.freq == "WEEKLY") {
            if ("BYDAY" in parts) {
              var bydayParts = this.ruleDayOfWeek(parts.BYDAY[0], this.rule.wkst);
              var pos = bydayParts[0];
              var dow = bydayParts[1];
              var wkdy = dow - this.last.dayOfWeek(this.rule.wkst);
              if (this.last.dayOfWeek(this.rule.wkst) < dow && wkdy >= 0 || wkdy < 0) {
                this.last.day += wkdy;
              }
            } else {
              var dayName = ICAL2.Recur.numericDayToIcalDay(this.dtstart.dayOfWeek());
              parts.BYDAY = [dayName];
            }
          }
          if (this.rule.freq == "YEARLY") {
            for (; ; ) {
              this.expand_year_days(this.last.year);
              if (this.days.length > 0) {
                break;
              }
              this.increment_year(this.rule.interval);
            }
            this._nextByYearDay();
          }
          if (this.rule.freq == "MONTHLY" && this.has_by_data("BYDAY")) {
            var tempLast = null;
            var initLast = this.last.clone();
            var daysInMonth = ICAL2.Time.daysInMonth(this.last.month, this.last.year);
            for (var i3 in this.by_data.BYDAY) {
              if (!this.by_data.BYDAY.hasOwnProperty(i3)) {
                continue;
              }
              this.last = initLast.clone();
              var bydayParts = this.ruleDayOfWeek(this.by_data.BYDAY[i3]);
              var pos = bydayParts[0];
              var dow = bydayParts[1];
              var dayOfMonth = this.last.nthWeekDay(dow, pos);
              if (pos >= 6 || pos <= -6) {
                throw new Error("Malformed values in BYDAY part");
              }
              if (dayOfMonth > daysInMonth || dayOfMonth <= 0) {
                if (tempLast && tempLast.month == initLast.month) {
                  continue;
                }
                while (dayOfMonth > daysInMonth || dayOfMonth <= 0) {
                  this.increment_month();
                  daysInMonth = ICAL2.Time.daysInMonth(this.last.month, this.last.year);
                  dayOfMonth = this.last.nthWeekDay(dow, pos);
                }
              }
              this.last.day = dayOfMonth;
              if (!tempLast || this.last.compare(tempLast) < 0) {
                tempLast = this.last.clone();
              }
            }
            this.last = tempLast.clone();
            if (this.has_by_data("BYMONTHDAY")) {
              this._byDayAndMonthDay(true);
            }
            if (this.last.day > daysInMonth || this.last.day == 0) {
              throw new Error("Malformed values in BYDAY part");
            }
          } else if (this.has_by_data("BYMONTHDAY")) {
            if (this.last.day < 0) {
              var daysInMonth = ICAL2.Time.daysInMonth(this.last.month, this.last.year);
              this.last.day = daysInMonth + this.last.day + 1;
            }
          }
        },
        /**
         * Retrieve the next occurrence from the iterator.
         * @return {ICAL.Time}
         */
        next: function icalrecur_iterator_next() {
          var before = this.last ? this.last.clone() : null;
          if (this.rule.count && this.occurrence_number >= this.rule.count || this.rule.until && this.last.compare(this.rule.until) > 0) {
            this.completed = true;
            return null;
          }
          if (this.occurrence_number == 0 && this.last.compare(this.dtstart) >= 0) {
            this.occurrence_number++;
            return this.last;
          }
          var valid;
          do {
            valid = 1;
            switch (this.rule.freq) {
              case "SECONDLY":
                this.next_second();
                break;
              case "MINUTELY":
                this.next_minute();
                break;
              case "HOURLY":
                this.next_hour();
                break;
              case "DAILY":
                this.next_day();
                break;
              case "WEEKLY":
                this.next_week();
                break;
              case "MONTHLY":
                valid = this.next_month();
                break;
              case "YEARLY":
                this.next_year();
                break;
              default:
                return null;
            }
          } while (!this.check_contracting_rules() || this.last.compare(this.dtstart) < 0 || !valid);
          if (this.last.compare(before) == 0) {
            throw new Error("Same occurrence found twice, protecting you from death by recursion");
          }
          if (this.rule.until && this.last.compare(this.rule.until) > 0) {
            this.completed = true;
            return null;
          } else {
            this.occurrence_number++;
            return this.last;
          }
        },
        next_second: function next_second() {
          return this.next_generic("BYSECOND", "SECONDLY", "second", "minute");
        },
        increment_second: function increment_second(inc) {
          return this.increment_generic(inc, "second", 60, "minute");
        },
        next_minute: function next_minute() {
          return this.next_generic(
            "BYMINUTE",
            "MINUTELY",
            "minute",
            "hour",
            "next_second"
          );
        },
        increment_minute: function increment_minute(inc) {
          return this.increment_generic(inc, "minute", 60, "hour");
        },
        next_hour: function next_hour() {
          return this.next_generic(
            "BYHOUR",
            "HOURLY",
            "hour",
            "monthday",
            "next_minute"
          );
        },
        increment_hour: function increment_hour(inc) {
          this.increment_generic(inc, "hour", 24, "monthday");
        },
        next_day: function next_day() {
          var has_by_day = "BYDAY" in this.by_data;
          var this_freq = this.rule.freq == "DAILY";
          if (this.next_hour() == 0) {
            return 0;
          }
          if (this_freq) {
            this.increment_monthday(this.rule.interval);
          } else {
            this.increment_monthday(1);
          }
          return 0;
        },
        next_week: function next_week() {
          var end_of_data = 0;
          if (this.next_weekday_by_week() == 0) {
            return end_of_data;
          }
          if (this.has_by_data("BYWEEKNO")) {
            var idx = ++this.by_indices.BYWEEKNO;
            if (this.by_indices.BYWEEKNO == this.by_data.BYWEEKNO.length) {
              this.by_indices.BYWEEKNO = 0;
              end_of_data = 1;
            }
            this.last.month = 1;
            this.last.day = 1;
            var week_no = this.by_data.BYWEEKNO[this.by_indices.BYWEEKNO];
            this.last.day += 7 * week_no;
            if (end_of_data) {
              this.increment_year(1);
            }
          } else {
            this.increment_monthday(7 * this.rule.interval);
          }
          return end_of_data;
        },
        /**
         * Normalize each by day rule for a given year/month.
         * Takes into account ordering and negative rules
         *
         * @private
         * @param {Number} year         Current year.
         * @param {Number} month        Current month.
         * @param {Array}  rules        Array of rules.
         *
         * @return {Array} sorted and normalized rules.
         *                 Negative rules will be expanded to their
         *                 correct positive values for easier processing.
         */
        normalizeByMonthDayRules: function(year, month, rules) {
          var daysInMonth = ICAL2.Time.daysInMonth(month, year);
          var newRules = [];
          var ruleIdx = 0;
          var len = rules.length;
          var rule;
          for (; ruleIdx < len; ruleIdx++) {
            rule = rules[ruleIdx];
            if (Math.abs(rule) > daysInMonth) {
              continue;
            }
            if (rule < 0) {
              rule = daysInMonth + (rule + 1);
            } else if (rule === 0) {
              continue;
            }
            if (newRules.indexOf(rule) === -1) {
              newRules.push(rule);
            }
          }
          return newRules.sort(function(a3, b3) {
            return a3 - b3;
          });
        },
        /**
         * NOTES:
         * We are given a list of dates in the month (BYMONTHDAY) (23, etc..)
         * Also we are given a list of days (BYDAY) (MO, 2SU, etc..) when
         * both conditions match a given date (this.last.day) iteration stops.
         *
         * @private
         * @param {Boolean=} isInit     When given true will not increment the
         *                                current day (this.last).
         */
        _byDayAndMonthDay: function(isInit) {
          var byMonthDay;
          var byDay = this.by_data.BYDAY;
          var date;
          var dateIdx = 0;
          var dateLen;
          var dayLen = byDay.length;
          var dataIsValid = 0;
          var daysInMonth;
          var self2 = this;
          var lastDay = this.last.day;
          function initMonth() {
            daysInMonth = ICAL2.Time.daysInMonth(
              self2.last.month,
              self2.last.year
            );
            byMonthDay = self2.normalizeByMonthDayRules(
              self2.last.year,
              self2.last.month,
              self2.by_data.BYMONTHDAY
            );
            dateLen = byMonthDay.length;
            while (byMonthDay[dateIdx] <= lastDay && !(isInit && byMonthDay[dateIdx] == lastDay) && dateIdx < dateLen - 1) {
              dateIdx++;
            }
          }
          function nextMonth() {
            lastDay = 0;
            self2.increment_month();
            dateIdx = 0;
            initMonth();
          }
          initMonth();
          if (isInit) {
            lastDay -= 1;
          }
          var monthsCounter = 48;
          while (!dataIsValid && monthsCounter) {
            monthsCounter--;
            date = lastDay + 1;
            if (date > daysInMonth) {
              nextMonth();
              continue;
            }
            var next = byMonthDay[dateIdx++];
            if (next >= date) {
              lastDay = next;
            } else {
              nextMonth();
              continue;
            }
            for (var dayIdx = 0; dayIdx < dayLen; dayIdx++) {
              var parts = this.ruleDayOfWeek(byDay[dayIdx]);
              var pos = parts[0];
              var dow = parts[1];
              this.last.day = lastDay;
              if (this.last.isNthWeekDay(dow, pos)) {
                dataIsValid = 1;
                break;
              }
            }
            if (!dataIsValid && dateIdx === dateLen) {
              nextMonth();
              continue;
            }
          }
          if (monthsCounter <= 0) {
            throw new Error("Malformed values in BYDAY combined with BYMONTHDAY parts");
          }
          return dataIsValid;
        },
        next_month: function next_month() {
          var this_freq = this.rule.freq == "MONTHLY";
          var data_valid = 1;
          if (this.next_hour() == 0) {
            return data_valid;
          }
          if (this.has_by_data("BYDAY") && this.has_by_data("BYMONTHDAY")) {
            data_valid = this._byDayAndMonthDay();
          } else if (this.has_by_data("BYDAY")) {
            var daysInMonth = ICAL2.Time.daysInMonth(this.last.month, this.last.year);
            var setpos = 0;
            var setpos_total = 0;
            if (this.has_by_data("BYSETPOS")) {
              var last_day = this.last.day;
              for (var day = 1; day <= daysInMonth; day++) {
                this.last.day = day;
                if (this.is_day_in_byday(this.last)) {
                  setpos_total++;
                  if (day <= last_day) {
                    setpos++;
                  }
                }
              }
              this.last.day = last_day;
            }
            data_valid = 0;
            for (var day = this.last.day + 1; day <= daysInMonth; day++) {
              this.last.day = day;
              if (this.is_day_in_byday(this.last)) {
                if (!this.has_by_data("BYSETPOS") || this.check_set_position(++setpos) || this.check_set_position(setpos - setpos_total - 1)) {
                  data_valid = 1;
                  break;
                }
              }
            }
            if (day > daysInMonth) {
              this.last.day = 1;
              this.increment_month();
              if (this.is_day_in_byday(this.last)) {
                if (!this.has_by_data("BYSETPOS") || this.check_set_position(1)) {
                  data_valid = 1;
                }
              } else {
                data_valid = 0;
              }
            }
          } else if (this.has_by_data("BYMONTHDAY")) {
            this.by_indices.BYMONTHDAY++;
            if (this.by_indices.BYMONTHDAY >= this.by_data.BYMONTHDAY.length) {
              this.by_indices.BYMONTHDAY = 0;
              this.increment_month();
            }
            var daysInMonth = ICAL2.Time.daysInMonth(this.last.month, this.last.year);
            var day = this.by_data.BYMONTHDAY[this.by_indices.BYMONTHDAY];
            if (day < 0) {
              day = daysInMonth + day + 1;
            }
            if (day > daysInMonth) {
              this.last.day = 1;
              data_valid = this.is_day_in_byday(this.last);
            } else {
              this.last.day = day;
            }
          } else {
            this.increment_month();
            var daysInMonth = ICAL2.Time.daysInMonth(this.last.month, this.last.year);
            if (this.by_data.BYMONTHDAY[0] > daysInMonth) {
              data_valid = 0;
            } else {
              this.last.day = this.by_data.BYMONTHDAY[0];
            }
          }
          return data_valid;
        },
        next_weekday_by_week: function next_weekday_by_week() {
          var end_of_data = 0;
          if (this.next_hour() == 0) {
            return end_of_data;
          }
          if (!this.has_by_data("BYDAY")) {
            return 1;
          }
          for (; ; ) {
            var tt = new ICAL2.Time();
            this.by_indices.BYDAY++;
            if (this.by_indices.BYDAY == Object.keys(this.by_data.BYDAY).length) {
              this.by_indices.BYDAY = 0;
              end_of_data = 1;
            }
            var coded_day = this.by_data.BYDAY[this.by_indices.BYDAY];
            var parts = this.ruleDayOfWeek(coded_day);
            var dow = parts[1];
            dow -= this.rule.wkst;
            if (dow < 0) {
              dow += 7;
            }
            tt.year = this.last.year;
            tt.month = this.last.month;
            tt.day = this.last.day;
            var startOfWeek = tt.startDoyWeek(this.rule.wkst);
            if (dow + startOfWeek < 1) {
              if (!end_of_data) {
                continue;
              }
            }
            var next = ICAL2.Time.fromDayOfYear(
              startOfWeek + dow,
              this.last.year
            );
            this.last.year = next.year;
            this.last.month = next.month;
            this.last.day = next.day;
            return end_of_data;
          }
        },
        next_year: function next_year() {
          if (this.next_hour() == 0) {
            return 0;
          }
          if (++this.days_index == this.days.length) {
            this.days_index = 0;
            do {
              this.increment_year(this.rule.interval);
              this.expand_year_days(this.last.year);
            } while (this.days.length == 0);
          }
          this._nextByYearDay();
          return 1;
        },
        _nextByYearDay: function _nextByYearDay() {
          var doy = this.days[this.days_index];
          var year = this.last.year;
          if (doy < 1) {
            doy += 1;
            year += 1;
          }
          var next = ICAL2.Time.fromDayOfYear(doy, year);
          this.last.day = next.day;
          this.last.month = next.month;
        },
        /**
         * @param dow (eg: '1TU', '-1MO')
         * @param {ICAL.Time.weekDay=} aWeekStart The week start weekday
         * @return [pos, numericDow] (eg: [1, 3]) numericDow is relative to aWeekStart
         */
        ruleDayOfWeek: function ruleDayOfWeek(dow, aWeekStart) {
          var matches = dow.match(/([+-]?[0-9])?(MO|TU|WE|TH|FR|SA|SU)/);
          if (matches) {
            var pos = parseInt(matches[1] || 0, 10);
            dow = ICAL2.Recur.icalDayToNumericDay(matches[2], aWeekStart);
            return [pos, dow];
          } else {
            return [0, 0];
          }
        },
        next_generic: function next_generic(aRuleType, aInterval, aDateAttr, aFollowingAttr, aPreviousIncr) {
          var has_by_rule = aRuleType in this.by_data;
          var this_freq = this.rule.freq == aInterval;
          var end_of_data = 0;
          if (aPreviousIncr && this[aPreviousIncr]() == 0) {
            return end_of_data;
          }
          if (has_by_rule) {
            this.by_indices[aRuleType]++;
            var idx = this.by_indices[aRuleType];
            var dta = this.by_data[aRuleType];
            if (this.by_indices[aRuleType] == dta.length) {
              this.by_indices[aRuleType] = 0;
              end_of_data = 1;
            }
            this.last[aDateAttr] = dta[this.by_indices[aRuleType]];
          } else if (this_freq) {
            this["increment_" + aDateAttr](this.rule.interval);
          }
          if (has_by_rule && end_of_data && this_freq) {
            this["increment_" + aFollowingAttr](1);
          }
          return end_of_data;
        },
        increment_monthday: function increment_monthday(inc) {
          for (var i3 = 0; i3 < inc; i3++) {
            var daysInMonth = ICAL2.Time.daysInMonth(this.last.month, this.last.year);
            this.last.day++;
            if (this.last.day > daysInMonth) {
              this.last.day -= daysInMonth;
              this.increment_month();
            }
          }
        },
        increment_month: function increment_month() {
          this.last.day = 1;
          if (this.has_by_data("BYMONTH")) {
            this.by_indices.BYMONTH++;
            if (this.by_indices.BYMONTH == this.by_data.BYMONTH.length) {
              this.by_indices.BYMONTH = 0;
              this.increment_year(1);
            }
            this.last.month = this.by_data.BYMONTH[this.by_indices.BYMONTH];
          } else {
            if (this.rule.freq == "MONTHLY") {
              this.last.month += this.rule.interval;
            } else {
              this.last.month++;
            }
            this.last.month--;
            var years = ICAL2.helpers.trunc(this.last.month / 12);
            this.last.month %= 12;
            this.last.month++;
            if (years != 0) {
              this.increment_year(years);
            }
          }
        },
        increment_year: function increment_year(inc) {
          this.last.year += inc;
        },
        increment_generic: function increment_generic(inc, aDateAttr, aFactor, aNextIncrement) {
          this.last[aDateAttr] += inc;
          var nextunit = ICAL2.helpers.trunc(this.last[aDateAttr] / aFactor);
          this.last[aDateAttr] %= aFactor;
          if (nextunit != 0) {
            this["increment_" + aNextIncrement](nextunit);
          }
        },
        has_by_data: function has_by_data(aRuleType) {
          return aRuleType in this.rule.parts;
        },
        expand_year_days: function expand_year_days(aYear) {
          var t3 = new ICAL2.Time();
          this.days = [];
          var parts = {};
          var rules = ["BYDAY", "BYWEEKNO", "BYMONTHDAY", "BYMONTH", "BYYEARDAY"];
          for (var p3 in rules) {
            if (rules.hasOwnProperty(p3)) {
              var part = rules[p3];
              if (part in this.rule.parts) {
                parts[part] = this.rule.parts[part];
              }
            }
          }
          if ("BYMONTH" in parts && "BYWEEKNO" in parts) {
            var valid = 1;
            var validWeeks = {};
            t3.year = aYear;
            t3.isDate = true;
            for (var monthIdx = 0; monthIdx < this.by_data.BYMONTH.length; monthIdx++) {
              var month = this.by_data.BYMONTH[monthIdx];
              t3.month = month;
              t3.day = 1;
              var first_week = t3.weekNumber(this.rule.wkst);
              t3.day = ICAL2.Time.daysInMonth(month, aYear);
              var last_week = t3.weekNumber(this.rule.wkst);
              for (monthIdx = first_week; monthIdx < last_week; monthIdx++) {
                validWeeks[monthIdx] = 1;
              }
            }
            for (var weekIdx = 0; weekIdx < this.by_data.BYWEEKNO.length && valid; weekIdx++) {
              var weekno = this.by_data.BYWEEKNO[weekIdx];
              if (weekno < 52) {
                valid &= validWeeks[weekIdx];
              } else {
                valid = 0;
              }
            }
            if (valid) {
              delete parts.BYMONTH;
            } else {
              delete parts.BYWEEKNO;
            }
          }
          var partCount = Object.keys(parts).length;
          if (partCount == 0) {
            var t1 = this.dtstart.clone();
            t1.year = this.last.year;
            this.days.push(t1.dayOfYear());
          } else if (partCount == 1 && "BYMONTH" in parts) {
            for (var monthkey in this.by_data.BYMONTH) {
              if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {
                continue;
              }
              var t22 = this.dtstart.clone();
              t22.year = aYear;
              t22.month = this.by_data.BYMONTH[monthkey];
              t22.isDate = true;
              this.days.push(t22.dayOfYear());
            }
          } else if (partCount == 1 && "BYMONTHDAY" in parts) {
            for (var monthdaykey in this.by_data.BYMONTHDAY) {
              if (!this.by_data.BYMONTHDAY.hasOwnProperty(monthdaykey)) {
                continue;
              }
              var t32 = this.dtstart.clone();
              var day_ = this.by_data.BYMONTHDAY[monthdaykey];
              if (day_ < 0) {
                var daysInMonth = ICAL2.Time.daysInMonth(t32.month, aYear);
                day_ = day_ + daysInMonth + 1;
              }
              t32.day = day_;
              t32.year = aYear;
              t32.isDate = true;
              this.days.push(t32.dayOfYear());
            }
          } else if (partCount == 2 && "BYMONTHDAY" in parts && "BYMONTH" in parts) {
            for (var monthkey in this.by_data.BYMONTH) {
              if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {
                continue;
              }
              var month_ = this.by_data.BYMONTH[monthkey];
              var daysInMonth = ICAL2.Time.daysInMonth(month_, aYear);
              for (var monthdaykey in this.by_data.BYMONTHDAY) {
                if (!this.by_data.BYMONTHDAY.hasOwnProperty(monthdaykey)) {
                  continue;
                }
                var day_ = this.by_data.BYMONTHDAY[monthdaykey];
                if (day_ < 0) {
                  day_ = day_ + daysInMonth + 1;
                }
                t3.day = day_;
                t3.month = month_;
                t3.year = aYear;
                t3.isDate = true;
                this.days.push(t3.dayOfYear());
              }
            }
          } else if (partCount == 1 && "BYWEEKNO" in parts) {
          } else if (partCount == 2 && "BYWEEKNO" in parts && "BYMONTHDAY" in parts) {
          } else if (partCount == 1 && "BYDAY" in parts) {
            this.days = this.days.concat(this.expand_by_day(aYear));
          } else if (partCount == 2 && "BYDAY" in parts && "BYMONTH" in parts) {
            for (var monthkey in this.by_data.BYMONTH) {
              if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {
                continue;
              }
              var month = this.by_data.BYMONTH[monthkey];
              var daysInMonth = ICAL2.Time.daysInMonth(month, aYear);
              t3.year = aYear;
              t3.month = this.by_data.BYMONTH[monthkey];
              t3.day = 1;
              t3.isDate = true;
              var first_dow = t3.dayOfWeek();
              var doy_offset = t3.dayOfYear() - 1;
              t3.day = daysInMonth;
              var last_dow = t3.dayOfWeek();
              if (this.has_by_data("BYSETPOS")) {
                var set_pos_counter = 0;
                var by_month_day = [];
                for (var day = 1; day <= daysInMonth; day++) {
                  t3.day = day;
                  if (this.is_day_in_byday(t3)) {
                    by_month_day.push(day);
                  }
                }
                for (var spIndex = 0; spIndex < by_month_day.length; spIndex++) {
                  if (this.check_set_position(spIndex + 1) || this.check_set_position(spIndex - by_month_day.length)) {
                    this.days.push(doy_offset + by_month_day[spIndex]);
                  }
                }
              } else {
                for (var daycodedkey in this.by_data.BYDAY) {
                  if (!this.by_data.BYDAY.hasOwnProperty(daycodedkey)) {
                    continue;
                  }
                  var coded_day = this.by_data.BYDAY[daycodedkey];
                  var bydayParts = this.ruleDayOfWeek(coded_day);
                  var pos = bydayParts[0];
                  var dow = bydayParts[1];
                  var month_day;
                  var first_matching_day = (dow + 7 - first_dow) % 7 + 1;
                  var last_matching_day = daysInMonth - (last_dow + 7 - dow) % 7;
                  if (pos == 0) {
                    for (var day = first_matching_day; day <= daysInMonth; day += 7) {
                      this.days.push(doy_offset + day);
                    }
                  } else if (pos > 0) {
                    month_day = first_matching_day + (pos - 1) * 7;
                    if (month_day <= daysInMonth) {
                      this.days.push(doy_offset + month_day);
                    }
                  } else {
                    month_day = last_matching_day + (pos + 1) * 7;
                    if (month_day > 0) {
                      this.days.push(doy_offset + month_day);
                    }
                  }
                }
              }
            }
            this.days.sort(function(a3, b3) {
              return a3 - b3;
            });
          } else if (partCount == 2 && "BYDAY" in parts && "BYMONTHDAY" in parts) {
            var expandedDays = this.expand_by_day(aYear);
            for (var daykey in expandedDays) {
              if (!expandedDays.hasOwnProperty(daykey)) {
                continue;
              }
              var day = expandedDays[daykey];
              var tt = ICAL2.Time.fromDayOfYear(day, aYear);
              if (this.by_data.BYMONTHDAY.indexOf(tt.day) >= 0) {
                this.days.push(day);
              }
            }
          } else if (partCount == 3 && "BYDAY" in parts && "BYMONTHDAY" in parts && "BYMONTH" in parts) {
            var expandedDays = this.expand_by_day(aYear);
            for (var daykey in expandedDays) {
              if (!expandedDays.hasOwnProperty(daykey)) {
                continue;
              }
              var day = expandedDays[daykey];
              var tt = ICAL2.Time.fromDayOfYear(day, aYear);
              if (this.by_data.BYMONTH.indexOf(tt.month) >= 0 && this.by_data.BYMONTHDAY.indexOf(tt.day) >= 0) {
                this.days.push(day);
              }
            }
          } else if (partCount == 2 && "BYDAY" in parts && "BYWEEKNO" in parts) {
            var expandedDays = this.expand_by_day(aYear);
            for (var daykey in expandedDays) {
              if (!expandedDays.hasOwnProperty(daykey)) {
                continue;
              }
              var day = expandedDays[daykey];
              var tt = ICAL2.Time.fromDayOfYear(day, aYear);
              var weekno = tt.weekNumber(this.rule.wkst);
              if (this.by_data.BYWEEKNO.indexOf(weekno)) {
                this.days.push(day);
              }
            }
          } else if (partCount == 3 && "BYDAY" in parts && "BYWEEKNO" in parts && "BYMONTHDAY" in parts) {
          } else if (partCount == 1 && "BYYEARDAY" in parts) {
            this.days = this.days.concat(this.by_data.BYYEARDAY);
          } else {
            this.days = [];
          }
          return 0;
        },
        expand_by_day: function expand_by_day(aYear) {
          var days_list = [];
          var tmp = this.last.clone();
          tmp.year = aYear;
          tmp.month = 1;
          tmp.day = 1;
          tmp.isDate = true;
          var start_dow = tmp.dayOfWeek();
          tmp.month = 12;
          tmp.day = 31;
          tmp.isDate = true;
          var end_dow = tmp.dayOfWeek();
          var end_year_day = tmp.dayOfYear();
          for (var daykey in this.by_data.BYDAY) {
            if (!this.by_data.BYDAY.hasOwnProperty(daykey)) {
              continue;
            }
            var day = this.by_data.BYDAY[daykey];
            var parts = this.ruleDayOfWeek(day);
            var pos = parts[0];
            var dow = parts[1];
            if (pos == 0) {
              var tmp_start_doy = (dow + 7 - start_dow) % 7 + 1;
              for (var doy = tmp_start_doy; doy <= end_year_day; doy += 7) {
                days_list.push(doy);
              }
            } else if (pos > 0) {
              var first;
              if (dow >= start_dow) {
                first = dow - start_dow + 1;
              } else {
                first = dow - start_dow + 8;
              }
              days_list.push(first + (pos - 1) * 7);
            } else {
              var last;
              pos = -pos;
              if (dow <= end_dow) {
                last = end_year_day - end_dow + dow;
              } else {
                last = end_year_day - end_dow + dow - 7;
              }
              days_list.push(last - (pos - 1) * 7);
            }
          }
          return days_list;
        },
        is_day_in_byday: function is_day_in_byday(tt) {
          for (var daykey in this.by_data.BYDAY) {
            if (!this.by_data.BYDAY.hasOwnProperty(daykey)) {
              continue;
            }
            var day = this.by_data.BYDAY[daykey];
            var parts = this.ruleDayOfWeek(day);
            var pos = parts[0];
            var dow = parts[1];
            var this_dow = tt.dayOfWeek();
            if (pos == 0 && dow == this_dow || tt.nthWeekDay(dow, pos) == tt.day) {
              return 1;
            }
          }
          return 0;
        },
        /**
         * Checks if given value is in BYSETPOS.
         *
         * @private
         * @param {Numeric} aPos position to check for.
         * @return {Boolean} false unless BYSETPOS rules exist
         *                   and the given value is present in rules.
         */
        check_set_position: function check_set_position(aPos) {
          if (this.has_by_data("BYSETPOS")) {
            var idx = this.by_data.BYSETPOS.indexOf(aPos);
            return idx !== -1;
          }
          return false;
        },
        sort_byday_rules: function icalrecur_sort_byday_rules(aRules) {
          for (var i3 = 0; i3 < aRules.length; i3++) {
            for (var j4 = 0; j4 < i3; j4++) {
              var one = this.ruleDayOfWeek(aRules[j4], this.rule.wkst)[1];
              var two = this.ruleDayOfWeek(aRules[i3], this.rule.wkst)[1];
              if (one > two) {
                var tmp = aRules[i3];
                aRules[i3] = aRules[j4];
                aRules[j4] = tmp;
              }
            }
          }
        },
        check_contract_restriction: function check_contract_restriction(aRuleType, v3) {
          var indexMapValue = icalrecur_iterator._indexMap[aRuleType];
          var ruleMapValue = icalrecur_iterator._expandMap[this.rule.freq][indexMapValue];
          var pass = false;
          if (aRuleType in this.by_data && ruleMapValue == icalrecur_iterator.CONTRACT) {
            var ruleType = this.by_data[aRuleType];
            for (var bydatakey in ruleType) {
              if (ruleType.hasOwnProperty(bydatakey)) {
                if (ruleType[bydatakey] == v3) {
                  pass = true;
                  break;
                }
              }
            }
          } else {
            pass = true;
          }
          return pass;
        },
        check_contracting_rules: function check_contracting_rules() {
          var dow = this.last.dayOfWeek();
          var weekNo = this.last.weekNumber(this.rule.wkst);
          var doy = this.last.dayOfYear();
          return this.check_contract_restriction("BYSECOND", this.last.second) && this.check_contract_restriction("BYMINUTE", this.last.minute) && this.check_contract_restriction("BYHOUR", this.last.hour) && this.check_contract_restriction("BYDAY", ICAL2.Recur.numericDayToIcalDay(dow)) && this.check_contract_restriction("BYWEEKNO", weekNo) && this.check_contract_restriction("BYMONTHDAY", this.last.day) && this.check_contract_restriction("BYMONTH", this.last.month) && this.check_contract_restriction("BYYEARDAY", doy);
        },
        setup_defaults: function setup_defaults(aRuleType, req, deftime) {
          var indexMapValue = icalrecur_iterator._indexMap[aRuleType];
          var ruleMapValue = icalrecur_iterator._expandMap[this.rule.freq][indexMapValue];
          if (ruleMapValue != icalrecur_iterator.CONTRACT) {
            if (!(aRuleType in this.by_data)) {
              this.by_data[aRuleType] = [deftime];
            }
            if (this.rule.freq != req) {
              return this.by_data[aRuleType][0];
            }
          }
          return deftime;
        },
        /**
         * Convert iterator into a serialize-able object.  Will preserve current
         * iteration sequence to ensure the seamless continuation of the recurrence
         * rule.
         * @return {Object}
         */
        toJSON: function() {
          var result = /* @__PURE__ */ Object.create(null);
          result.initialized = this.initialized;
          result.rule = this.rule.toJSON();
          result.dtstart = this.dtstart.toJSON();
          result.by_data = this.by_data;
          result.days = this.days;
          result.last = this.last.toJSON();
          result.by_indices = this.by_indices;
          result.occurrence_number = this.occurrence_number;
          return result;
        }
      };
      icalrecur_iterator._indexMap = {
        "BYSECOND": 0,
        "BYMINUTE": 1,
        "BYHOUR": 2,
        "BYDAY": 3,
        "BYMONTHDAY": 4,
        "BYYEARDAY": 5,
        "BYWEEKNO": 6,
        "BYMONTH": 7,
        "BYSETPOS": 8
      };
      icalrecur_iterator._expandMap = {
        "SECONDLY": [1, 1, 1, 1, 1, 1, 1, 1],
        "MINUTELY": [2, 1, 1, 1, 1, 1, 1, 1],
        "HOURLY": [2, 2, 1, 1, 1, 1, 1, 1],
        "DAILY": [2, 2, 2, 1, 1, 1, 1, 1],
        "WEEKLY": [2, 2, 2, 2, 3, 3, 1, 1],
        "MONTHLY": [2, 2, 2, 2, 2, 3, 3, 1],
        "YEARLY": [2, 2, 2, 2, 2, 2, 2, 2]
      };
      icalrecur_iterator.UNKNOWN = 0;
      icalrecur_iterator.CONTRACT = 1;
      icalrecur_iterator.EXPAND = 2;
      icalrecur_iterator.ILLEGAL = 3;
      return icalrecur_iterator;
    }();
    ICAL2.RecurExpansion = function() {
      function formatTime(item) {
        return ICAL2.helpers.formatClassType(item, ICAL2.Time);
      }
      function compareTime(a3, b3) {
        return a3.compare(b3);
      }
      function isRecurringComponent(comp) {
        return comp.hasProperty("rdate") || comp.hasProperty("rrule") || comp.hasProperty("recurrence-id");
      }
      function RecurExpansion(options) {
        this.ruleDates = [];
        this.exDates = [];
        this.fromData(options);
      }
      RecurExpansion.prototype = {
        /**
         * True when iteration is fully completed.
         * @type {Boolean}
         */
        complete: false,
        /**
         * Array of rrule iterators.
         *
         * @type {ICAL.RecurIterator[]}
         * @private
         */
        ruleIterators: null,
        /**
         * Array of rdate instances.
         *
         * @type {ICAL.Time[]}
         * @private
         */
        ruleDates: null,
        /**
         * Array of exdate instances.
         *
         * @type {ICAL.Time[]}
         * @private
         */
        exDates: null,
        /**
         * Current position in ruleDates array.
         * @type {Number}
         * @private
         */
        ruleDateInc: 0,
        /**
         * Current position in exDates array
         * @type {Number}
         * @private
         */
        exDateInc: 0,
        /**
         * Current negative date.
         *
         * @type {ICAL.Time}
         * @private
         */
        exDate: null,
        /**
         * Current additional date.
         *
         * @type {ICAL.Time}
         * @private
         */
        ruleDate: null,
        /**
         * Start date of recurring rules.
         *
         * @type {ICAL.Time}
         */
        dtstart: null,
        /**
         * Last expanded time
         *
         * @type {ICAL.Time}
         */
        last: null,
        /**
         * Initialize the recurrence expansion from the data object. The options
         * object may also contain additional members, see the
         * {@link ICAL.RecurExpansion constructor} for more details.
         *
         * @param {Object} options
         *        Recurrence expansion options
         * @param {ICAL.Time} options.dtstart
         *        Start time of the event
         * @param {ICAL.Component=} options.component
         *        Component for expansion, required if not resuming.
         */
        fromData: function(options) {
          var start = ICAL2.helpers.formatClassType(options.dtstart, ICAL2.Time);
          if (!start) {
            throw new Error(".dtstart (ICAL.Time) must be given");
          } else {
            this.dtstart = start;
          }
          if (options.component) {
            this._init(options.component);
          } else {
            this.last = formatTime(options.last) || start.clone();
            if (!options.ruleIterators) {
              throw new Error(".ruleIterators or .component must be given");
            }
            this.ruleIterators = options.ruleIterators.map(function(item) {
              return ICAL2.helpers.formatClassType(item, ICAL2.RecurIterator);
            });
            this.ruleDateInc = options.ruleDateInc;
            this.exDateInc = options.exDateInc;
            if (options.ruleDates) {
              this.ruleDates = options.ruleDates.map(formatTime);
              this.ruleDate = this.ruleDates[this.ruleDateInc];
            }
            if (options.exDates) {
              this.exDates = options.exDates.map(formatTime);
              this.exDate = this.exDates[this.exDateInc];
            }
            if (typeof options.complete !== "undefined") {
              this.complete = options.complete;
            }
          }
        },
        /**
         * Retrieve the next occurrence in the series.
         * @return {ICAL.Time}
         */
        next: function() {
          var iter2;
          var ruleOfDay;
          var next;
          var compare;
          var maxTries = 500;
          var currentTry = 0;
          while (true) {
            if (currentTry++ > maxTries) {
              throw new Error(
                "max tries have occured, rule may be impossible to forfill."
              );
            }
            next = this.ruleDate;
            iter2 = this._nextRecurrenceIter(this.last);
            if (!next && !iter2) {
              this.complete = true;
              break;
            }
            if (!next || iter2 && next.compare(iter2.last) > 0) {
              next = iter2.last.clone();
              iter2.next();
            }
            if (this.ruleDate === next) {
              this._nextRuleDay();
            }
            this.last = next;
            if (this.exDate) {
              compare = this.exDate.compare(this.last);
              if (compare < 0) {
                this._nextExDay();
              }
              if (compare === 0) {
                this._nextExDay();
                continue;
              }
            }
            return this.last;
          }
        },
        /**
         * Converts object into a serialize-able format. This format can be passed
         * back into the expansion to resume iteration.
         * @return {Object}
         */
        toJSON: function() {
          function toJSON(item) {
            return item.toJSON();
          }
          var result = /* @__PURE__ */ Object.create(null);
          result.ruleIterators = this.ruleIterators.map(toJSON);
          if (this.ruleDates) {
            result.ruleDates = this.ruleDates.map(toJSON);
          }
          if (this.exDates) {
            result.exDates = this.exDates.map(toJSON);
          }
          result.ruleDateInc = this.ruleDateInc;
          result.exDateInc = this.exDateInc;
          result.last = this.last.toJSON();
          result.dtstart = this.dtstart.toJSON();
          result.complete = this.complete;
          return result;
        },
        /**
         * Extract all dates from the properties in the given component. The
         * properties will be filtered by the property name.
         *
         * @private
         * @param {ICAL.Component} component        The component to search in
         * @param {String} propertyName             The property name to search for
         * @return {ICAL.Time[]}                    The extracted dates.
         */
        _extractDates: function(component, propertyName) {
          function handleProp(prop2) {
            idx = ICAL2.helpers.binsearchInsert(
              result,
              prop2,
              compareTime
            );
            result.splice(idx, 0, prop2);
          }
          var result = [];
          var props = component.getAllProperties(propertyName);
          var len = props.length;
          var i3 = 0;
          var prop;
          var idx;
          for (; i3 < len; i3++) {
            props[i3].getValues().forEach(handleProp);
          }
          return result;
        },
        /**
         * Initialize the recurrence expansion.
         *
         * @private
         * @param {ICAL.Component} component    The component to initialize from.
         */
        _init: function(component) {
          this.ruleIterators = [];
          this.last = this.dtstart.clone();
          if (!isRecurringComponent(component)) {
            this.ruleDate = this.last.clone();
            this.complete = true;
            return;
          }
          if (component.hasProperty("rdate")) {
            this.ruleDates = this._extractDates(component, "rdate");
            if (this.ruleDates[0] && this.ruleDates[0].compare(this.dtstart) < 0) {
              this.ruleDateInc = 0;
              this.last = this.ruleDates[0].clone();
            } else {
              this.ruleDateInc = ICAL2.helpers.binsearchInsert(
                this.ruleDates,
                this.last,
                compareTime
              );
            }
            this.ruleDate = this.ruleDates[this.ruleDateInc];
          }
          if (component.hasProperty("rrule")) {
            var rules = component.getAllProperties("rrule");
            var i3 = 0;
            var len = rules.length;
            var rule;
            var iter2;
            for (; i3 < len; i3++) {
              rule = rules[i3].getFirstValue();
              iter2 = rule.iterator(this.dtstart);
              this.ruleIterators.push(iter2);
              iter2.next();
            }
          }
          if (component.hasProperty("exdate")) {
            this.exDates = this._extractDates(component, "exdate");
            this.exDateInc = ICAL2.helpers.binsearchInsert(
              this.exDates,
              this.last,
              compareTime
            );
            this.exDate = this.exDates[this.exDateInc];
          }
        },
        /**
         * Advance to the next exdate
         * @private
         */
        _nextExDay: function() {
          this.exDate = this.exDates[++this.exDateInc];
        },
        /**
         * Advance to the next rule date
         * @private
         */
        _nextRuleDay: function() {
          this.ruleDate = this.ruleDates[++this.ruleDateInc];
        },
        /**
         * Find and return the recurrence rule with the most recent event and
         * return it.
         *
         * @private
         * @return {?ICAL.RecurIterator}    Found iterator.
         */
        _nextRecurrenceIter: function() {
          var iters = this.ruleIterators;
          if (iters.length === 0) {
            return null;
          }
          var len = iters.length;
          var iter2;
          var iterTime;
          var iterIdx = 0;
          var chosenIter;
          for (; iterIdx < len; iterIdx++) {
            iter2 = iters[iterIdx];
            iterTime = iter2.last;
            if (iter2.completed) {
              len--;
              if (iterIdx !== 0) {
                iterIdx--;
              }
              iters.splice(iterIdx, 1);
              continue;
            }
            if (!chosenIter || chosenIter.last.compare(iterTime) > 0) {
              chosenIter = iter2;
            }
          }
          return chosenIter;
        }
      };
      return RecurExpansion;
    }();
    ICAL2.Event = function() {
      function Event2(component, options) {
        if (!(component instanceof ICAL2.Component)) {
          options = component;
          component = null;
        }
        if (component) {
          this.component = component;
        } else {
          this.component = new ICAL2.Component("vevent");
        }
        this._rangeExceptionCache = /* @__PURE__ */ Object.create(null);
        this.exceptions = /* @__PURE__ */ Object.create(null);
        this.rangeExceptions = [];
        if (options && options.strictExceptions) {
          this.strictExceptions = options.strictExceptions;
        }
        if (options && options.exceptions) {
          options.exceptions.forEach(this.relateException, this);
        } else if (this.component.parent && !this.isRecurrenceException()) {
          this.component.parent.getAllSubcomponents("vevent").forEach(function(event) {
            if (event.hasProperty("recurrence-id")) {
              this.relateException(event);
            }
          }, this);
        }
      }
      Event2.prototype = {
        THISANDFUTURE: "THISANDFUTURE",
        /**
         * List of related event exceptions.
         *
         * @type {ICAL.Event[]}
         */
        exceptions: null,
        /**
         * When true, will verify exceptions are related by their UUID.
         *
         * @type {Boolean}
         */
        strictExceptions: false,
        /**
         * Relates a given event exception to this object.  If the given component
         * does not share the UID of this event it cannot be related and will throw
         * an exception.
         *
         * If this component is an exception it cannot have other exceptions
         * related to it.
         *
         * @param {ICAL.Component|ICAL.Event} obj       Component or event
         */
        relateException: function(obj) {
          if (this.isRecurrenceException()) {
            throw new Error("cannot relate exception to exceptions");
          }
          if (obj instanceof ICAL2.Component) {
            obj = new ICAL2.Event(obj);
          }
          if (this.strictExceptions && obj.uid !== this.uid) {
            throw new Error("attempted to relate unrelated exception");
          }
          var id = obj.recurrenceId.toString();
          this.exceptions[id] = obj;
          if (obj.modifiesFuture()) {
            var item = [
              obj.recurrenceId.toUnixTime(),
              id
            ];
            var idx = ICAL2.helpers.binsearchInsert(
              this.rangeExceptions,
              item,
              compareRangeException
            );
            this.rangeExceptions.splice(idx, 0, item);
          }
        },
        /**
         * Checks if this record is an exception and has the RANGE=THISANDFUTURE
         * value.
         *
         * @return {Boolean}        True, when exception is within range
         */
        modifiesFuture: function() {
          if (!this.component.hasProperty("recurrence-id")) {
            return false;
          }
          var range2 = this.component.getFirstProperty("recurrence-id").getParameter("range");
          return range2 === this.THISANDFUTURE;
        },
        /**
         * Finds the range exception nearest to the given date.
         *
         * @param {ICAL.Time} time usually an occurrence time of an event
         * @return {?ICAL.Event} the related event/exception or null
         */
        findRangeException: function(time) {
          if (!this.rangeExceptions.length) {
            return null;
          }
          var utc = time.toUnixTime();
          var idx = ICAL2.helpers.binsearchInsert(
            this.rangeExceptions,
            [utc],
            compareRangeException
          );
          idx -= 1;
          if (idx < 0) {
            return null;
          }
          var rangeItem = this.rangeExceptions[idx];
          if (utc < rangeItem[0]) {
            return null;
          }
          return rangeItem[1];
        },
        /**
         * This object is returned by {@link ICAL.Event#getOccurrenceDetails getOccurrenceDetails}
         *
         * @typedef {Object} occurrenceDetails
         * @memberof ICAL.Event
         * @property {ICAL.Time} recurrenceId       The passed in recurrence id
         * @property {ICAL.Event} item              The occurrence
         * @property {ICAL.Time} startDate          The start of the occurrence
         * @property {ICAL.Time} endDate            The end of the occurrence
         */
        /**
         * Returns the occurrence details based on its start time.  If the
         * occurrence has an exception will return the details for that exception.
         *
         * NOTE: this method is intend to be used in conjunction
         *       with the {@link ICAL.Event#iterator iterator} method.
         *
         * @param {ICAL.Time} occurrence time occurrence
         * @return {ICAL.Event.occurrenceDetails} Information about the occurrence
         */
        getOccurrenceDetails: function(occurrence) {
          var id = occurrence.toString();
          var utcId = occurrence.convertToZone(ICAL2.Timezone.utcTimezone).toString();
          var item;
          var result = {
            //XXX: Clone?
            recurrenceId: occurrence
          };
          if (id in this.exceptions) {
            item = result.item = this.exceptions[id];
            result.startDate = item.startDate;
            result.endDate = item.endDate;
            result.item = item;
          } else if (utcId in this.exceptions) {
            item = this.exceptions[utcId];
            result.startDate = item.startDate;
            result.endDate = item.endDate;
            result.item = item;
          } else {
            var rangeExceptionId = this.findRangeException(
              occurrence
            );
            var end;
            if (rangeExceptionId) {
              var exception = this.exceptions[rangeExceptionId];
              result.item = exception;
              var startDiff = this._rangeExceptionCache[rangeExceptionId];
              if (!startDiff) {
                var original = exception.recurrenceId.clone();
                var newStart = exception.startDate.clone();
                original.zone = newStart.zone;
                startDiff = newStart.subtractDate(original);
                this._rangeExceptionCache[rangeExceptionId] = startDiff;
              }
              var start = occurrence.clone();
              start.zone = exception.startDate.zone;
              start.addDuration(startDiff);
              end = start.clone();
              end.addDuration(exception.duration);
              result.startDate = start;
              result.endDate = end;
            } else {
              end = occurrence.clone();
              end.addDuration(this.duration);
              result.endDate = end;
              result.startDate = occurrence;
              result.item = this;
            }
          }
          return result;
        },
        /**
         * Builds a recur expansion instance for a specific point in time (defaults
         * to startDate).
         *
         * @param {ICAL.Time} startTime     Starting point for expansion
         * @return {ICAL.RecurExpansion}    Expansion object
         */
        iterator: function(startTime) {
          return new ICAL2.RecurExpansion({
            component: this.component,
            dtstart: startTime || this.startDate
          });
        },
        /**
         * Checks if the event is recurring
         *
         * @return {Boolean}        True, if event is recurring
         */
        isRecurring: function() {
          var comp = this.component;
          return comp.hasProperty("rrule") || comp.hasProperty("rdate");
        },
        /**
         * Checks if the event describes a recurrence exception. See
         * {@tutorial terminology} for details.
         *
         * @return {Boolean}    True, if the event describes a recurrence exception
         */
        isRecurrenceException: function() {
          return this.component.hasProperty("recurrence-id");
        },
        /**
         * Returns the types of recurrences this event may have.
         *
         * Returned as an object with the following possible keys:
         *
         *    - YEARLY
         *    - MONTHLY
         *    - WEEKLY
         *    - DAILY
         *    - MINUTELY
         *    - SECONDLY
         *
         * @return {Object.<ICAL.Recur.frequencyValues, Boolean>}
         *          Object of recurrence flags
         */
        getRecurrenceTypes: function() {
          var rules = this.component.getAllProperties("rrule");
          var i3 = 0;
          var len = rules.length;
          var result = /* @__PURE__ */ Object.create(null);
          for (; i3 < len; i3++) {
            var value = rules[i3].getFirstValue();
            result[value.freq] = true;
          }
          return result;
        },
        /**
         * The uid of this event
         * @type {String}
         */
        get uid() {
          return this._firstProp("uid");
        },
        set uid(value) {
          this._setProp("uid", value);
        },
        /**
         * The start date
         * @type {ICAL.Time}
         */
        get startDate() {
          return this._firstProp("dtstart");
        },
        set startDate(value) {
          this._setTime("dtstart", value);
        },
        /**
         * The end date. This can be the result directly from the property, or the
         * end date calculated from start date and duration. Setting the property
         * will remove any duration properties.
         * @type {ICAL.Time}
         */
        get endDate() {
          var endDate = this._firstProp("dtend");
          if (!endDate) {
            var duration = this._firstProp("duration");
            endDate = this.startDate.clone();
            if (duration) {
              endDate.addDuration(duration);
            } else if (endDate.isDate) {
              endDate.day += 1;
            }
          }
          return endDate;
        },
        set endDate(value) {
          if (this.component.hasProperty("duration")) {
            this.component.removeProperty("duration");
          }
          this._setTime("dtend", value);
        },
        /**
         * The duration. This can be the result directly from the property, or the
         * duration calculated from start date and end date. Setting the property
         * will remove any `dtend` properties.
         * @type {ICAL.Duration}
         */
        get duration() {
          var duration = this._firstProp("duration");
          if (!duration) {
            return this.endDate.subtractDateTz(this.startDate);
          }
          return duration;
        },
        set duration(value) {
          if (this.component.hasProperty("dtend")) {
            this.component.removeProperty("dtend");
          }
          this._setProp("duration", value);
        },
        /**
         * The location of the event.
         * @type {String}
         */
        get location() {
          return this._firstProp("location");
        },
        set location(value) {
          return this._setProp("location", value);
        },
        /**
         * The attendees in the event
         * @type {ICAL.Property[]}
         * @readonly
         */
        get attendees() {
          return this.component.getAllProperties("attendee");
        },
        /**
         * The event summary
         * @type {String}
         */
        get summary() {
          return this._firstProp("summary");
        },
        set summary(value) {
          this._setProp("summary", value);
        },
        /**
         * The event description.
         * @type {String}
         */
        get description() {
          return this._firstProp("description");
        },
        set description(value) {
          this._setProp("description", value);
        },
        /**
         * The event color from [rfc7986](https://datatracker.ietf.org/doc/html/rfc7986)
         * @type {String}
         */
        get color() {
          return this._firstProp("color");
        },
        set color(value) {
          this._setProp("color", value);
        },
        /**
         * The organizer value as an uri. In most cases this is a mailto: uri, but
         * it can also be something else, like urn:uuid:...
         * @type {String}
         */
        get organizer() {
          return this._firstProp("organizer");
        },
        set organizer(value) {
          this._setProp("organizer", value);
        },
        /**
         * The sequence value for this event. Used for scheduling
         * see {@tutorial terminology}.
         * @type {Number}
         */
        get sequence() {
          return this._firstProp("sequence");
        },
        set sequence(value) {
          this._setProp("sequence", value);
        },
        /**
         * The recurrence id for this event. See {@tutorial terminology} for details.
         * @type {ICAL.Time}
         */
        get recurrenceId() {
          return this._firstProp("recurrence-id");
        },
        set recurrenceId(value) {
          this._setTime("recurrence-id", value);
        },
        /**
         * Set/update a time property's value.
         * This will also update the TZID of the property.
         *
         * TODO: this method handles the case where we are switching
         * from a known timezone to an implied timezone (one without TZID).
         * This does _not_ handle the case of moving between a known
         *  (by TimezoneService) timezone to an unknown timezone...
         *
         * We will not add/remove/update the VTIMEZONE subcomponents
         *  leading to invalid ICAL data...
         * @private
         * @param {String} propName     The property name
         * @param {ICAL.Time} time      The time to set
         */
        _setTime: function(propName, time) {
          var prop = this.component.getFirstProperty(propName);
          if (!prop) {
            prop = new ICAL2.Property(propName);
            this.component.addProperty(prop);
          }
          if (time.zone === ICAL2.Timezone.localTimezone || time.zone === ICAL2.Timezone.utcTimezone) {
            prop.removeParameter("tzid");
          } else {
            prop.setParameter("tzid", time.zone.tzid);
          }
          prop.setValue(time);
        },
        _setProp: function(name, value) {
          this.component.updatePropertyWithValue(name, value);
        },
        _firstProp: function(name) {
          return this.component.getFirstPropertyValue(name);
        },
        /**
         * The string representation of this event.
         * @return {String}
         */
        toString: function() {
          return this.component.toString();
        }
      };
      function compareRangeException(a3, b3) {
        if (a3[0] > b3[0])
          return 1;
        if (b3[0] > a3[0])
          return -1;
        return 0;
      }
      return Event2;
    }();
    ICAL2.ComponentParser = function() {
      function ComponentParser(options) {
        if (typeof options === "undefined") {
          options = {};
        }
        var key;
        for (key in options) {
          if (options.hasOwnProperty(key)) {
            this[key] = options[key];
          }
        }
      }
      ComponentParser.prototype = {
        /**
         * When true, parse events
         *
         * @type {Boolean}
         */
        parseEvent: true,
        /**
         * When true, parse timezones
         *
         * @type {Boolean}
         */
        parseTimezone: true,
        /* SAX like events here for reference */
        /**
         * Fired when parsing is complete
         * @callback
         */
        oncomplete: (
          /* istanbul ignore next */
          function() {
          }
        ),
        /**
         * Fired if an error occurs during parsing.
         *
         * @callback
         * @param {Error} err details of error
         */
        onerror: (
          /* istanbul ignore next */
          function(err) {
          }
        ),
        /**
         * Fired when a top level component (VTIMEZONE) is found
         *
         * @callback
         * @param {ICAL.Timezone} component     Timezone object
         */
        ontimezone: (
          /* istanbul ignore next */
          function(component) {
          }
        ),
        /**
         * Fired when a top level component (VEVENT) is found.
         *
         * @callback
         * @param {ICAL.Event} component    Top level component
         */
        onevent: (
          /* istanbul ignore next */
          function(component) {
          }
        ),
        /**
         * Process a string or parse ical object.  This function itself will return
         * nothing but will start the parsing process.
         *
         * Events must be registered prior to calling this method.
         *
         * @param {ICAL.Component|String|Object} ical      The component to process,
         *        either in its final form, as a jCal Object, or string representation
         */
        process: function(ical) {
          if (typeof ical === "string") {
            ical = ICAL2.parse(ical);
          }
          if (!(ical instanceof ICAL2.Component)) {
            ical = new ICAL2.Component(ical);
          }
          var components = ical.getAllSubcomponents();
          var i3 = 0;
          var len = components.length;
          var component;
          for (; i3 < len; i3++) {
            component = components[i3];
            switch (component.name) {
              case "vtimezone":
                if (this.parseTimezone) {
                  var tzid = component.getFirstPropertyValue("tzid");
                  if (tzid) {
                    this.ontimezone(new ICAL2.Timezone({
                      tzid,
                      component
                    }));
                  }
                }
                break;
              case "vevent":
                if (this.parseEvent) {
                  this.onevent(new ICAL2.Event(component));
                }
                break;
              default:
                continue;
            }
          }
          this.oncomplete();
        }
      };
      return ComponentParser;
    }();
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MyPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian6 = require("obsidian");

// src/views/CalendarView.ts
var import_obsidian = require("obsidian");

// src/types.ts
var Src = class {
  constructor(path) {
    this._path = path;
  }
  addExcludes(excludes) {
    return true;
  }
  get path() {
    return this._path;
  }
  get excludes() {
    return structuredClone(this._excludes);
  }
};

// src/constants.ts
var MSG_PLG_NAME = "MyCalendar";
var EVENT_SRC = "databases";
var PLACE_FOR_CREATING_NOTE = "databases";
var daysOfWeek = ["1", "2", "3", "4", "5", "6", "0"];
var display = "background";
var COLOUR_REST = "#305B60";
var COLOUR_SLEEP = "#cc0000";
var DEFAULT_SETTINGS = {
  statusCorrector: {
    isOn: true,
    startOnStartUp: true
  },
  calendar: {
    slotDuration: "00:30:00",
    colours: {
      frequency: "#8A1717",
      done: "#008E04",
      tick: "#457E7E",
      default: "#5e3fa8"
    },
    restTime: [
      {
        daysOfWeek,
        display,
        startTime: "0:00:00",
        endTime: "8:00:00",
        color: COLOUR_SLEEP
      },
      {
        daysOfWeek,
        display,
        startTime: "24:00:00",
        endTime: "24:00:00",
        color: COLOUR_SLEEP
      },
      {
        daysOfWeek,
        display,
        startTime: "0:00:00",
        endTime: "8:30:00",
        color: COLOUR_REST
      },
      {
        daysOfWeek,
        display,
        startTime: "23:00:00",
        endTime: "24:00:00",
        color: COLOUR_REST
      }
    ]
  },
  source: {
    noteSources: [new Src(EVENT_SRC)],
    // NOTE default path where note will be created
    defaultCreatePath: PLACE_FOR_CREATING_NOTE
  }
};
var VIEW_TYPE = "my-obsidian-calendar-plugin";
var TEXT_DONE = "\u{1F7E2}done";
var FORMAT_DAY = "d";
var FORMAT_HOUR = "h";
var FORMAT_MINUTE = "m";
var BACKGROUND_COLOUR = {
  hue: {
    shift: 0,
    min: 0,
    max: 360
  },
  saturation: {
    shift: 0,
    min: 70,
    max: 90
  },
  lightness: {
    shift: 0,
    min: 30,
    max: 50
  }
};
var MillisecsInSecond = 1e3;
var SecsInMinute = 60;
var MinutesInHour = 60;
var HoursInDay = 24;
var MillisecsInMinute = MillisecsInSecond * SecsInMinute;
var MillisecsInHour = MillisecsInMinute * MinutesInHour;
var MillisecsInDay = MillisecsInHour * HoursInDay;

// src/util.ts
var import_obsidian_dataview = __toESM(require_lib());
var dv = (0, import_obsidian_dataview.getAPI)();
function pathToFileWithoutFileName(path) {
  const path_separator = path.lastIndexOf("/");
  if (path_separator !== -1)
    return path.slice(0, path_separator);
  return "";
}
function IDateToCalendarEvent(args) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
  const structure = {
    start: new Date(args.ff_date),
    allDay: false
  };
  if (args.ff_duration) {
    structure.start.setHours(((_b = (_a = args.ff_timeStart) == null ? void 0 : _a.values) == null ? void 0 : _b.hours) || 0);
    structure.start.setMinutes(((_d = (_c = args.ff_timeStart) == null ? void 0 : _c.values) == null ? void 0 : _d.minutes) || 0);
    let tmpTime = new Date(structure.start);
    if (((_f = (_e = args.ff_duration) == null ? void 0 : _e.values) == null ? void 0 : _f.minutes) || ((_h = (_g = args.ff_duration) == null ? void 0 : _g.values) == null ? void 0 : _h.hours) || ((_j = (_i = args.ff_duration) == null ? void 0 : _i.values) == null ? void 0 : _j.days)) {
      const duration = args.ff_duration.values;
      tmpTime.setMinutes(
        tmpTime.getMinutes() + (duration.minutes || 0)
      );
      tmpTime.setHours(
        tmpTime.getHours() + (duration.hours || 0)
      );
      tmpTime.setDate(
        tmpTime.getDate() + (duration.days || 0)
      );
    } else {
      structure.allDay = true;
    }
    if (!((_k = args.ff_timeStart) == null ? void 0 : _k.values))
      structure.allDay = true;
    structure.end = tmpTime;
  } else if (args.ff_duration) {
    structure.allDay = true;
  } else
    structure.allDay = true;
  return structure;
}
function CalendarEventToIDate(event) {
  const { start, end, allDay } = event;
  start.setMinutes(
    start.getMinutes() - start.getTimezoneOffset()
  );
  const result = {
    ff_duration: "",
    ff_timeStart: "",
    ff_date: new Date(start)
  };
  start.setMinutes(
    start.getMinutes() + start.getTimezoneOffset()
  );
  let srcMillisec = end ? end - start : MillisecsInHour;
  if (allDay) {
    result["ff_timeStart"] = "";
    if (srcMillisec <= MillisecsInDay)
      srcMillisec = 0;
  } else
    result["ff_timeStart"] = start.getHours() + "h" + start.getMinutes() + "m";
  result["ff_duration"] = millisecToString(srcMillisec);
  return result;
}
function getTicksFromText(text) {
  var _a, _b, _c, _d, _e;
  const result = [];
  const regExpTicks = /\[t::.+\]/gm;
  const matches = text.match(regExpTicks);
  if (matches)
    for (let match of matches) {
      const args = match.slice(1, -1).split("::")[1].split(",");
      if (!args)
        continue;
      const name = (_a = args[0]) == null ? void 0 : _a.trim();
      const ff_date = dv.date((_b = args[1]) == null ? void 0 : _b.trim());
      const ff_timeStart = dv.duration((_c = args[2]) == null ? void 0 : _c.trim());
      const tempDuration = (_d = args[3]) == null ? void 0 : _d.trim();
      const ff_duration = tempDuration == "x" ? "x" : dv.duration((_e = args[3]) == null ? void 0 : _e.trim());
      if (name == "")
        continue;
      result.push(
        { name, ff_date, ff_timeStart, ff_duration }
      );
    }
  return result;
}
function millisecToString(millisec) {
  const days = Math.floor(
    millisec / MillisecsInDay
  );
  millisec -= days * MillisecsInDay;
  const hours = Math.floor(
    millisec / MillisecsInHour
  );
  millisec -= hours * MillisecsInHour;
  const minutes = Math.floor(
    millisec / MillisecsInMinute
  );
  millisec -= minutes * MillisecsInMinute;
  let resString = "";
  if (days)
    resString += days.toString() + FORMAT_DAY;
  if (hours)
    resString += hours.toString() + FORMAT_HOUR;
  if (minutes)
    resString += minutes.toString() + FORMAT_MINUTE;
  return resString;
}
function isEqualObj(object1, object2) {
  const keys1 = Object.keys(object1);
  const keys2 = Object.keys(object2);
  if (keys1.length !== keys2.length) {
    return false;
  }
  for (const key of keys1) {
    const val1 = object1[key];
    const val2 = object2[key];
    const areObjects = isObject(val1) && isObject(val2);
    if (areObjects && !isEqualObj(val1, val2) || !areObjects && val1 !== val2) {
      return false;
    }
  }
  return true;
}
function isObject(object) {
  return object != null && typeof object === "object";
}
function templateIDTick(path, tickName) {
  return path + tickName;
}
function templateNameTick(fileName, tickName) {
  return "(" + fileName + ")" + tickName;
}
function hashString(str) {
  let hash = 0;
  for (let i3 = 0; i3 < str.length; i3++) {
    hash = (hash << 5) - hash + str.charCodeAt(i3);
    hash |= 0;
  }
  return hash;
}
function toRange(src, min, max) {
  max -= min;
  src %= max + 1;
  return src + min;
}
function getColourFromPath(path) {
  const str = pathToFileWithoutFileName(path);
  const str1 = hashString([...str].filter((_3, index8) => (index8 + 1) % 3 !== 0).join(""));
  const str2 = hashString([...str].filter((_3, index8) => (index8 + 2) % 3 !== 0).join(""));
  const str3 = hashString([...str].filter((_3, index8) => (index8 + 3) % 3 !== 0).join(""));
  const hue = toRange(
    str1 + BACKGROUND_COLOUR.hue.shift,
    BACKGROUND_COLOUR.hue.min,
    BACKGROUND_COLOUR.hue.max
  );
  const saturation = toRange(
    str2 + BACKGROUND_COLOUR.saturation.shift,
    BACKGROUND_COLOUR.saturation.min,
    BACKGROUND_COLOUR.saturation.max
  );
  const lightness = toRange(
    str3 + BACKGROUND_COLOUR.lightness.shift,
    BACKGROUND_COLOUR.lightness.min,
    BACKGROUND_COLOUR.lightness.max
  );
  return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
}
function safeParseInt(str) {
  const num = Number(str);
  return Number.isInteger(num) ? num : NaN;
}
function timeAdd(start, duration) {
  const dur = duration.as("minutes");
  const result = new Date(start);
  result.setMinutes(result.getMinutes() + dur);
  return result;
}
function pageToEvents(page) {
  const result = [];
  const colours = this.calendarSettings.colours;
  const structureTemplate = {
    id: "",
    title: "",
    borderColor: colours.default,
    color: getColourFromPath(page.file.path),
    editable: true
  };
  if (page.ff_date) {
    const structure = {
      ...structureTemplate,
      id: page.file.path,
      title: page.file.name,
      ...IDateToCalendarEvent(page)
    };
    if (page.ff_frequency)
      structure.borderColor = colours.frequency;
    if (page.ff_status == TEXT_DONE)
      structure.borderColor = colours.done;
    result.push(structure);
  }
  for (let tick of page.ticks) {
    const structure = {
      ...structureTemplate,
      id: templateIDTick(page.file.path, tick.name),
      title: templateNameTick(page.file.name, tick.name),
      borderColor: colours.tick,
      extendedProps: {
        tickName: tick.name,
        notePath: page.file.path
      },
      ...IDateToCalendarEvent(tick)
    };
    result.push(structure);
  }
  return result;
}

// node_modules/@fullcalendar/core/node_modules/preact/dist/preact.module.js
var n;
var l;
var u;
var i;
var t;
var r;
var o;
var f;
var e;
var c = {};
var s = [];
var a = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
function h(n2, l3) {
  for (var u3 in l3)
    n2[u3] = l3[u3];
  return n2;
}
function v(n2) {
  var l3 = n2.parentNode;
  l3 && l3.removeChild(n2);
}
function y(l3, u3, i3) {
  var t3, r3, o2, f3 = {};
  for (o2 in u3)
    "key" == o2 ? t3 = u3[o2] : "ref" == o2 ? r3 = u3[o2] : f3[o2] = u3[o2];
  if (arguments.length > 2 && (f3.children = arguments.length > 3 ? n.call(arguments, 2) : i3), "function" == typeof l3 && null != l3.defaultProps)
    for (o2 in l3.defaultProps)
      void 0 === f3[o2] && (f3[o2] = l3.defaultProps[o2]);
  return p(l3, f3, t3, r3, null);
}
function p(n2, i3, t3, r3, o2) {
  var f3 = { type: n2, props: i3, key: t3, ref: r3, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: null == o2 ? ++u : o2 };
  return null == o2 && null != l.vnode && l.vnode(f3), f3;
}
function d() {
  return { current: null };
}
function _(n2) {
  return n2.children;
}
function k(n2, l3, u3, i3, t3) {
  var r3;
  for (r3 in u3)
    "children" === r3 || "key" === r3 || r3 in l3 || g(n2, r3, null, u3[r3], i3);
  for (r3 in l3)
    t3 && "function" != typeof l3[r3] || "children" === r3 || "key" === r3 || "value" === r3 || "checked" === r3 || u3[r3] === l3[r3] || g(n2, r3, l3[r3], u3[r3], i3);
}
function b(n2, l3, u3) {
  "-" === l3[0] ? n2.setProperty(l3, null == u3 ? "" : u3) : n2[l3] = null == u3 ? "" : "number" != typeof u3 || a.test(l3) ? u3 : u3 + "px";
}
function g(n2, l3, u3, i3, t3) {
  var r3;
  n:
    if ("style" === l3)
      if ("string" == typeof u3)
        n2.style.cssText = u3;
      else {
        if ("string" == typeof i3 && (n2.style.cssText = i3 = ""), i3)
          for (l3 in i3)
            u3 && l3 in u3 || b(n2.style, l3, "");
        if (u3)
          for (l3 in u3)
            i3 && u3[l3] === i3[l3] || b(n2.style, l3, u3[l3]);
      }
    else if ("o" === l3[0] && "n" === l3[1])
      r3 = l3 !== (l3 = l3.replace(/Capture$/, "")), l3 = l3.toLowerCase() in n2 ? l3.toLowerCase().slice(2) : l3.slice(2), n2.l || (n2.l = {}), n2.l[l3 + r3] = u3, u3 ? i3 || n2.addEventListener(l3, r3 ? w : m, r3) : n2.removeEventListener(l3, r3 ? w : m, r3);
    else if ("dangerouslySetInnerHTML" !== l3) {
      if (t3)
        l3 = l3.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
      else if ("width" !== l3 && "height" !== l3 && "href" !== l3 && "list" !== l3 && "form" !== l3 && "tabIndex" !== l3 && "download" !== l3 && l3 in n2)
        try {
          n2[l3] = null == u3 ? "" : u3;
          break n;
        } catch (n3) {
        }
      "function" == typeof u3 || (null == u3 || false === u3 && -1 == l3.indexOf("-") ? n2.removeAttribute(l3) : n2.setAttribute(l3, u3));
    }
}
function m(n2) {
  t = true;
  try {
    return this.l[n2.type + false](l.event ? l.event(n2) : n2);
  } finally {
    t = false;
  }
}
function w(n2) {
  t = true;
  try {
    return this.l[n2.type + true](l.event ? l.event(n2) : n2);
  } finally {
    t = false;
  }
}
function x(n2, l3) {
  this.props = n2, this.context = l3;
}
function A(n2, l3) {
  if (null == l3)
    return n2.__ ? A(n2.__, n2.__.__k.indexOf(n2) + 1) : null;
  for (var u3; l3 < n2.__k.length; l3++)
    if (null != (u3 = n2.__k[l3]) && null != u3.__e)
      return u3.__e;
  return "function" == typeof n2.type ? A(n2) : null;
}
function P(n2) {
  var l3, u3;
  if (null != (n2 = n2.__) && null != n2.__c) {
    for (n2.__e = n2.__c.base = null, l3 = 0; l3 < n2.__k.length; l3++)
      if (null != (u3 = n2.__k[l3]) && null != u3.__e) {
        n2.__e = n2.__c.base = u3.__e;
        break;
      }
    return P(n2);
  }
}
function C(n2) {
  t ? setTimeout(n2) : f(n2);
}
function T(n2) {
  (!n2.__d && (n2.__d = true) && r.push(n2) && !$.__r++ || o !== l.debounceRendering) && ((o = l.debounceRendering) || C)($);
}
function $() {
  var n2, l3, u3, i3, t3, o2, f3, e3;
  for (r.sort(function(n3, l4) {
    return n3.__v.__b - l4.__v.__b;
  }); n2 = r.shift(); )
    n2.__d && (l3 = r.length, i3 = void 0, t3 = void 0, f3 = (o2 = (u3 = n2).__v).__e, (e3 = u3.__P) && (i3 = [], (t3 = h({}, o2)).__v = o2.__v + 1, M(e3, o2, t3, u3.__n, void 0 !== e3.ownerSVGElement, null != o2.__h ? [f3] : null, i3, null == f3 ? A(o2) : f3, o2.__h), N(i3, o2), o2.__e != f3 && P(o2)), r.length > l3 && r.sort(function(n3, l4) {
      return n3.__v.__b - l4.__v.__b;
    }));
  $.__r = 0;
}
function H(n2, l3, u3, i3, t3, r3, o2, f3, e3, a3) {
  var h3, v3, y3, d2, k3, b3, g4, m3 = i3 && i3.__k || s, w4 = m3.length;
  for (u3.__k = [], h3 = 0; h3 < l3.length; h3++)
    if (null != (d2 = u3.__k[h3] = null == (d2 = l3[h3]) || "boolean" == typeof d2 ? null : "string" == typeof d2 || "number" == typeof d2 || "bigint" == typeof d2 ? p(null, d2, null, null, d2) : Array.isArray(d2) ? p(_, { children: d2 }, null, null, null) : d2.__b > 0 ? p(d2.type, d2.props, d2.key, d2.ref ? d2.ref : null, d2.__v) : d2)) {
      if (d2.__ = u3, d2.__b = u3.__b + 1, null === (y3 = m3[h3]) || y3 && d2.key == y3.key && d2.type === y3.type)
        m3[h3] = void 0;
      else
        for (v3 = 0; v3 < w4; v3++) {
          if ((y3 = m3[v3]) && d2.key == y3.key && d2.type === y3.type) {
            m3[v3] = void 0;
            break;
          }
          y3 = null;
        }
      M(n2, d2, y3 = y3 || c, t3, r3, o2, f3, e3, a3), k3 = d2.__e, (v3 = d2.ref) && y3.ref != v3 && (g4 || (g4 = []), y3.ref && g4.push(y3.ref, null, d2), g4.push(v3, d2.__c || k3, d2)), null != k3 ? (null == b3 && (b3 = k3), "function" == typeof d2.type && d2.__k === y3.__k ? d2.__d = e3 = I(d2, e3, n2) : e3 = z(n2, d2, y3, m3, k3, e3), "function" == typeof u3.type && (u3.__d = e3)) : e3 && y3.__e == e3 && e3.parentNode != n2 && (e3 = A(y3));
    }
  for (u3.__e = b3, h3 = w4; h3--; )
    null != m3[h3] && ("function" == typeof u3.type && null != m3[h3].__e && m3[h3].__e == u3.__d && (u3.__d = L(i3).nextSibling), q(m3[h3], m3[h3]));
  if (g4)
    for (h3 = 0; h3 < g4.length; h3++)
      S(g4[h3], g4[++h3], g4[++h3]);
}
function I(n2, l3, u3) {
  for (var i3, t3 = n2.__k, r3 = 0; t3 && r3 < t3.length; r3++)
    (i3 = t3[r3]) && (i3.__ = n2, l3 = "function" == typeof i3.type ? I(i3, l3, u3) : z(u3, i3, i3, t3, i3.__e, l3));
  return l3;
}
function j(n2, l3) {
  return l3 = l3 || [], null == n2 || "boolean" == typeof n2 || (Array.isArray(n2) ? n2.some(function(n3) {
    j(n3, l3);
  }) : l3.push(n2)), l3;
}
function z(n2, l3, u3, i3, t3, r3) {
  var o2, f3, e3;
  if (void 0 !== l3.__d)
    o2 = l3.__d, l3.__d = void 0;
  else if (null == u3 || t3 != r3 || null == t3.parentNode)
    n:
      if (null == r3 || r3.parentNode !== n2)
        n2.appendChild(t3), o2 = null;
      else {
        for (f3 = r3, e3 = 0; (f3 = f3.nextSibling) && e3 < i3.length; e3 += 1)
          if (f3 == t3)
            break n;
        n2.insertBefore(t3, r3), o2 = r3;
      }
  return void 0 !== o2 ? o2 : t3.nextSibling;
}
function L(n2) {
  var l3, u3, i3;
  if (null == n2.type || "string" == typeof n2.type)
    return n2.__e;
  if (n2.__k) {
    for (l3 = n2.__k.length - 1; l3 >= 0; l3--)
      if ((u3 = n2.__k[l3]) && (i3 = L(u3)))
        return i3;
  }
  return null;
}
function M(n2, u3, i3, t3, r3, o2, f3, e3, c3) {
  var s3, a3, v3, y3, p3, d2, k3, b3, g4, m3, w4, A3, P3, C3, T4, $3 = u3.type;
  if (void 0 !== u3.constructor)
    return null;
  null != i3.__h && (c3 = i3.__h, e3 = u3.__e = i3.__e, u3.__h = null, o2 = [e3]), (s3 = l.__b) && s3(u3);
  try {
    n:
      if ("function" == typeof $3) {
        if (b3 = u3.props, g4 = (s3 = $3.contextType) && t3[s3.__c], m3 = s3 ? g4 ? g4.props.value : s3.__ : t3, i3.__c ? k3 = (a3 = u3.__c = i3.__c).__ = a3.__E : ("prototype" in $3 && $3.prototype.render ? u3.__c = a3 = new $3(b3, m3) : (u3.__c = a3 = new x(b3, m3), a3.constructor = $3, a3.render = B), g4 && g4.sub(a3), a3.props = b3, a3.state || (a3.state = {}), a3.context = m3, a3.__n = t3, v3 = a3.__d = true, a3.__h = [], a3._sb = []), null == a3.__s && (a3.__s = a3.state), null != $3.getDerivedStateFromProps && (a3.__s == a3.state && (a3.__s = h({}, a3.__s)), h(a3.__s, $3.getDerivedStateFromProps(b3, a3.__s))), y3 = a3.props, p3 = a3.state, a3.__v = u3, v3)
          null == $3.getDerivedStateFromProps && null != a3.componentWillMount && a3.componentWillMount(), null != a3.componentDidMount && a3.__h.push(a3.componentDidMount);
        else {
          if (null == $3.getDerivedStateFromProps && b3 !== y3 && null != a3.componentWillReceiveProps && a3.componentWillReceiveProps(b3, m3), !a3.__e && null != a3.shouldComponentUpdate && false === a3.shouldComponentUpdate(b3, a3.__s, m3) || u3.__v === i3.__v) {
            for (u3.__v !== i3.__v && (a3.props = b3, a3.state = a3.__s, a3.__d = false), u3.__e = i3.__e, u3.__k = i3.__k, u3.__k.forEach(function(n3) {
              n3 && (n3.__ = u3);
            }), w4 = 0; w4 < a3._sb.length; w4++)
              a3.__h.push(a3._sb[w4]);
            a3._sb = [], a3.__h.length && f3.push(a3);
            break n;
          }
          null != a3.componentWillUpdate && a3.componentWillUpdate(b3, a3.__s, m3), null != a3.componentDidUpdate && a3.__h.push(function() {
            a3.componentDidUpdate(y3, p3, d2);
          });
        }
        if (a3.context = m3, a3.props = b3, a3.__P = n2, A3 = l.__r, P3 = 0, "prototype" in $3 && $3.prototype.render) {
          for (a3.state = a3.__s, a3.__d = false, A3 && A3(u3), s3 = a3.render(a3.props, a3.state, a3.context), C3 = 0; C3 < a3._sb.length; C3++)
            a3.__h.push(a3._sb[C3]);
          a3._sb = [];
        } else
          do {
            a3.__d = false, A3 && A3(u3), s3 = a3.render(a3.props, a3.state, a3.context), a3.state = a3.__s;
          } while (a3.__d && ++P3 < 25);
        a3.state = a3.__s, null != a3.getChildContext && (t3 = h(h({}, t3), a3.getChildContext())), v3 || null == a3.getSnapshotBeforeUpdate || (d2 = a3.getSnapshotBeforeUpdate(y3, p3)), T4 = null != s3 && s3.type === _ && null == s3.key ? s3.props.children : s3, H(n2, Array.isArray(T4) ? T4 : [T4], u3, i3, t3, r3, o2, f3, e3, c3), a3.base = u3.__e, u3.__h = null, a3.__h.length && f3.push(a3), k3 && (a3.__E = a3.__ = null), a3.__e = false;
      } else
        null == o2 && u3.__v === i3.__v ? (u3.__k = i3.__k, u3.__e = i3.__e) : u3.__e = O(i3.__e, u3, i3, t3, r3, o2, f3, c3);
    (s3 = l.diffed) && s3(u3);
  } catch (n3) {
    u3.__v = null, (c3 || null != o2) && (u3.__e = e3, u3.__h = !!c3, o2[o2.indexOf(e3)] = null), l.__e(n3, u3, i3);
  }
}
function N(n2, u3) {
  l.__c && l.__c(u3, n2), n2.some(function(u4) {
    try {
      n2 = u4.__h, u4.__h = [], n2.some(function(n3) {
        n3.call(u4);
      });
    } catch (n3) {
      l.__e(n3, u4.__v);
    }
  });
}
function O(l3, u3, i3, t3, r3, o2, f3, e3) {
  var s3, a3, h3, y3 = i3.props, p3 = u3.props, d2 = u3.type, _3 = 0;
  if ("svg" === d2 && (r3 = true), null != o2) {
    for (; _3 < o2.length; _3++)
      if ((s3 = o2[_3]) && "setAttribute" in s3 == !!d2 && (d2 ? s3.localName === d2 : 3 === s3.nodeType)) {
        l3 = s3, o2[_3] = null;
        break;
      }
  }
  if (null == l3) {
    if (null === d2)
      return document.createTextNode(p3);
    l3 = r3 ? document.createElementNS("http://www.w3.org/2000/svg", d2) : document.createElement(d2, p3.is && p3), o2 = null, e3 = false;
  }
  if (null === d2)
    y3 === p3 || e3 && l3.data === p3 || (l3.data = p3);
  else {
    if (o2 = o2 && n.call(l3.childNodes), a3 = (y3 = i3.props || c).dangerouslySetInnerHTML, h3 = p3.dangerouslySetInnerHTML, !e3) {
      if (null != o2)
        for (y3 = {}, _3 = 0; _3 < l3.attributes.length; _3++)
          y3[l3.attributes[_3].name] = l3.attributes[_3].value;
      (h3 || a3) && (h3 && (a3 && h3.__html == a3.__html || h3.__html === l3.innerHTML) || (l3.innerHTML = h3 && h3.__html || ""));
    }
    if (k(l3, p3, y3, r3, e3), h3)
      u3.__k = [];
    else if (_3 = u3.props.children, H(l3, Array.isArray(_3) ? _3 : [_3], u3, i3, t3, r3 && "foreignObject" !== d2, o2, f3, o2 ? o2[0] : i3.__k && A(i3, 0), e3), null != o2)
      for (_3 = o2.length; _3--; )
        null != o2[_3] && v(o2[_3]);
    e3 || ("value" in p3 && void 0 !== (_3 = p3.value) && (_3 !== l3.value || "progress" === d2 && !_3 || "option" === d2 && _3 !== y3.value) && g(l3, "value", _3, y3.value, false), "checked" in p3 && void 0 !== (_3 = p3.checked) && _3 !== l3.checked && g(l3, "checked", _3, y3.checked, false));
  }
  return l3;
}
function S(n2, u3, i3) {
  try {
    "function" == typeof n2 ? n2(u3) : n2.current = u3;
  } catch (n3) {
    l.__e(n3, i3);
  }
}
function q(n2, u3, i3) {
  var t3, r3;
  if (l.unmount && l.unmount(n2), (t3 = n2.ref) && (t3.current && t3.current !== n2.__e || S(t3, null, u3)), null != (t3 = n2.__c)) {
    if (t3.componentWillUnmount)
      try {
        t3.componentWillUnmount();
      } catch (n3) {
        l.__e(n3, u3);
      }
    t3.base = t3.__P = null, n2.__c = void 0;
  }
  if (t3 = n2.__k)
    for (r3 = 0; r3 < t3.length; r3++)
      t3[r3] && q(t3[r3], u3, i3 || "function" != typeof n2.type);
  i3 || null == n2.__e || v(n2.__e), n2.__ = n2.__e = n2.__d = void 0;
}
function B(n2, l3, u3) {
  return this.constructor(n2, u3);
}
function D(u3, i3, t3) {
  var r3, o2, f3;
  l.__ && l.__(u3, i3), o2 = (r3 = "function" == typeof t3) ? null : t3 && t3.__k || i3.__k, f3 = [], M(i3, u3 = (!r3 && t3 || i3).__k = y(_, null, [u3]), o2 || c, c, void 0 !== i3.ownerSVGElement, !r3 && t3 ? [t3] : o2 ? null : i3.firstChild ? n.call(i3.childNodes) : null, f3, !r3 && t3 ? t3 : o2 ? o2.__e : i3.firstChild, r3), N(f3, u3);
}
function G(n2, l3) {
  var u3 = { __c: l3 = "__cC" + e++, __: n2, Consumer: function(n3, l4) {
    return n3.children(l4);
  }, Provider: function(n3) {
    var u4, i3;
    return this.getChildContext || (u4 = [], (i3 = {})[l3] = this, this.getChildContext = function() {
      return i3;
    }, this.shouldComponentUpdate = function(n4) {
      this.props.value !== n4.value && u4.some(function(n5) {
        n5.__e = true, T(n5);
      });
    }, this.sub = function(n4) {
      u4.push(n4);
      var l4 = n4.componentWillUnmount;
      n4.componentWillUnmount = function() {
        u4.splice(u4.indexOf(n4), 1), l4 && l4.call(n4);
      };
    }), n3.children;
  } };
  return u3.Provider.__ = u3.Consumer.contextType = u3;
}
n = s.slice, l = { __e: function(n2, l3, u3, i3) {
  for (var t3, r3, o2; l3 = l3.__; )
    if ((t3 = l3.__c) && !t3.__)
      try {
        if ((r3 = t3.constructor) && null != r3.getDerivedStateFromError && (t3.setState(r3.getDerivedStateFromError(n2)), o2 = t3.__d), null != t3.componentDidCatch && (t3.componentDidCatch(n2, i3 || {}), o2 = t3.__d), o2)
          return t3.__E = t3;
      } catch (l4) {
        n2 = l4;
      }
  throw n2;
} }, u = 0, i = function(n2) {
  return null != n2 && void 0 === n2.constructor;
}, t = false, x.prototype.setState = function(n2, l3) {
  var u3;
  u3 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = h({}, this.state), "function" == typeof n2 && (n2 = n2(h({}, u3), this.props)), n2 && h(u3, n2), null != n2 && this.__v && (l3 && this._sb.push(l3), T(this));
}, x.prototype.forceUpdate = function(n2) {
  this.__v && (this.__e = true, n2 && this.__h.push(n2), T(this));
}, x.prototype.render = _, r = [], f = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, $.__r = 0, e = 0;

// node_modules/@fullcalendar/core/node_modules/preact/hooks/dist/hooks.module.js
var t2;
var r2;
var u2;
var i2;
var f2 = [];
var c2 = [];
var e2 = l.__b;
var a2 = l.__r;
var v2 = l.diffed;
var l2 = l.__c;
var m2 = l.unmount;
function b2() {
  for (var t3; t3 = f2.shift(); )
    if (t3.__P && t3.__H)
      try {
        t3.__H.__h.forEach(k2), t3.__H.__h.forEach(w2), t3.__H.__h = [];
      } catch (r3) {
        t3.__H.__h = [], l.__e(r3, t3.__v);
      }
}
l.__b = function(n2) {
  r2 = null, e2 && e2(n2);
}, l.__r = function(n2) {
  a2 && a2(n2), t2 = 0;
  var i3 = (r2 = n2.__c).__H;
  i3 && (u2 === r2 ? (i3.__h = [], r2.__h = [], i3.__.forEach(function(n3) {
    n3.__N && (n3.__ = n3.__N), n3.__V = c2, n3.__N = n3.i = void 0;
  })) : (i3.__h.forEach(k2), i3.__h.forEach(w2), i3.__h = [])), u2 = r2;
}, l.diffed = function(t3) {
  v2 && v2(t3);
  var o2 = t3.__c;
  o2 && o2.__H && (o2.__H.__h.length && (1 !== f2.push(o2) && i2 === l.requestAnimationFrame || ((i2 = l.requestAnimationFrame) || j2)(b2)), o2.__H.__.forEach(function(n2) {
    n2.i && (n2.__H = n2.i), n2.__V !== c2 && (n2.__ = n2.__V), n2.i = void 0, n2.__V = c2;
  })), u2 = r2 = null;
}, l.__c = function(t3, r3) {
  r3.some(function(t4) {
    try {
      t4.__h.forEach(k2), t4.__h = t4.__h.filter(function(n2) {
        return !n2.__ || w2(n2);
      });
    } catch (u3) {
      r3.some(function(n2) {
        n2.__h && (n2.__h = []);
      }), r3 = [], l.__e(u3, t4.__v);
    }
  }), l2 && l2(t3, r3);
}, l.unmount = function(t3) {
  m2 && m2(t3);
  var r3, u3 = t3.__c;
  u3 && u3.__H && (u3.__H.__.forEach(function(n2) {
    try {
      k2(n2);
    } catch (n3) {
      r3 = n3;
    }
  }), u3.__H = void 0, r3 && l.__e(r3, u3.__v));
};
var g2 = "function" == typeof requestAnimationFrame;
function j2(n2) {
  var t3, r3 = function() {
    clearTimeout(u3), g2 && cancelAnimationFrame(t3), setTimeout(n2);
  }, u3 = setTimeout(r3, 100);
  g2 && (t3 = requestAnimationFrame(r3));
}
function k2(n2) {
  var t3 = r2, u3 = n2.__c;
  "function" == typeof u3 && (n2.__c = void 0, u3()), r2 = t3;
}
function w2(n2) {
  var t3 = r2;
  n2.__c = n2.__(), r2 = t3;
}

// node_modules/@fullcalendar/core/node_modules/preact/compat/dist/compat.module.js
function g3(n2, t3) {
  for (var e3 in t3)
    n2[e3] = t3[e3];
  return n2;
}
function C2(n2, t3) {
  for (var e3 in n2)
    if ("__source" !== e3 && !(e3 in t3))
      return true;
  for (var r3 in t3)
    if ("__source" !== r3 && n2[r3] !== t3[r3])
      return true;
  return false;
}
function w3(n2) {
  this.props = n2;
}
(w3.prototype = new x()).isPureReactComponent = true, w3.prototype.shouldComponentUpdate = function(n2, t3) {
  return C2(this.props, n2) || C2(this.state, t3);
};
var x3 = l.__b;
l.__b = function(n2) {
  n2.type && n2.type.__f && n2.ref && (n2.props.ref = n2.ref, n2.ref = null), x3 && x3(n2);
};
var N2 = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.forward_ref") || 3911;
var T3 = l.__e;
l.__e = function(n2, t3, e3, r3) {
  if (n2.then) {
    for (var u3, o2 = t3; o2 = o2.__; )
      if ((u3 = o2.__c) && u3.__c)
        return null == t3.__e && (t3.__e = e3.__e, t3.__k = e3.__k), u3.__c(n2, t3);
  }
  T3(n2, t3, e3, r3);
};
var I2 = l.unmount;
function L2(n2, t3, e3) {
  return n2 && (n2.__c && n2.__c.__H && (n2.__c.__H.__.forEach(function(n3) {
    "function" == typeof n3.__c && n3.__c();
  }), n2.__c.__H = null), null != (n2 = g3({}, n2)).__c && (n2.__c.__P === e3 && (n2.__c.__P = t3), n2.__c = null), n2.__k = n2.__k && n2.__k.map(function(n3) {
    return L2(n3, t3, e3);
  })), n2;
}
function U(n2, t3, e3) {
  return n2 && (n2.__v = null, n2.__k = n2.__k && n2.__k.map(function(n3) {
    return U(n3, t3, e3);
  }), n2.__c && n2.__c.__P === t3 && (n2.__e && e3.insertBefore(n2.__e, n2.__d), n2.__c.__e = true, n2.__c.__P = e3)), n2;
}
function D2() {
  this.__u = 0, this.t = null, this.__b = null;
}
function F3(n2) {
  var t3 = n2.__.__c;
  return t3 && t3.__a && t3.__a(n2);
}
function V2() {
  this.u = null, this.o = null;
}
l.unmount = function(n2) {
  var t3 = n2.__c;
  t3 && t3.__R && t3.__R(), t3 && true === n2.__h && (n2.type = null), I2 && I2(n2);
}, (D2.prototype = new x()).__c = function(n2, t3) {
  var e3 = t3.__c, r3 = this;
  null == r3.t && (r3.t = []), r3.t.push(e3);
  var u3 = F3(r3.__v), o2 = false, i3 = function() {
    o2 || (o2 = true, e3.__R = null, u3 ? u3(l3) : l3());
  };
  e3.__R = i3;
  var l3 = function() {
    if (!--r3.__u) {
      if (r3.state.__a) {
        var n3 = r3.state.__a;
        r3.__v.__k[0] = U(n3, n3.__c.__P, n3.__c.__O);
      }
      var t4;
      for (r3.setState({ __a: r3.__b = null }); t4 = r3.t.pop(); )
        t4.forceUpdate();
    }
  }, c3 = true === t3.__h;
  r3.__u++ || c3 || r3.setState({ __a: r3.__b = r3.__v.__k[0] }), n2.then(i3, i3);
}, D2.prototype.componentWillUnmount = function() {
  this.t = [];
}, D2.prototype.render = function(n2, e3) {
  if (this.__b) {
    if (this.__v.__k) {
      var r3 = document.createElement("div"), o2 = this.__v.__k[0].__c;
      this.__v.__k[0] = L2(this.__b, r3, o2.__O = o2.__P);
    }
    this.__b = null;
  }
  var i3 = e3.__a && y(_, null, n2.fallback);
  return i3 && (i3.__h = null), [y(_, null, e3.__a ? null : n2.children), i3];
};
var W = function(n2, t3, e3) {
  if (++e3[1] === e3[0] && n2.o.delete(t3), n2.props.revealOrder && ("t" !== n2.props.revealOrder[0] || !n2.o.size))
    for (e3 = n2.u; e3; ) {
      for (; e3.length > 3; )
        e3.pop()();
      if (e3[1] < e3[0])
        break;
      n2.u = e3 = e3[2];
    }
};
function P2(n2) {
  return this.getChildContext = function() {
    return n2.context;
  }, n2.children;
}
function $2(n2) {
  var e3 = this, r3 = n2.i;
  e3.componentWillUnmount = function() {
    D(null, e3.l), e3.l = null, e3.i = null;
  }, e3.i && e3.i !== r3 && e3.componentWillUnmount(), n2.__v ? (e3.l || (e3.i = r3, e3.l = { nodeType: 1, parentNode: r3, childNodes: [], appendChild: function(n3) {
    this.childNodes.push(n3), e3.i.appendChild(n3);
  }, insertBefore: function(n3, t3) {
    this.childNodes.push(n3), e3.i.appendChild(n3);
  }, removeChild: function(n3) {
    this.childNodes.splice(this.childNodes.indexOf(n3) >>> 1, 1), e3.i.removeChild(n3);
  } }), D(y(P2, { context: e3.context }, n2.__v), e3.l)) : e3.l && e3.componentWillUnmount();
}
function j3(n2, e3) {
  var r3 = y($2, { __v: n2, i: e3 });
  return r3.containerInfo = e3, r3;
}
(V2.prototype = new x()).__a = function(n2) {
  var t3 = this, e3 = F3(t3.__v), r3 = t3.o.get(n2);
  return r3[0]++, function(u3) {
    var o2 = function() {
      t3.props.revealOrder ? (r3.push(u3), W(t3, n2, r3)) : u3();
    };
    e3 ? e3(o2) : o2();
  };
}, V2.prototype.render = function(n2) {
  this.u = null, this.o = /* @__PURE__ */ new Map();
  var t3 = j(n2.children);
  n2.revealOrder && "b" === n2.revealOrder[0] && t3.reverse();
  for (var e3 = t3.length; e3--; )
    this.o.set(t3[e3], this.u = [1, 0, this.u]);
  return n2.children;
}, V2.prototype.componentDidUpdate = V2.prototype.componentDidMount = function() {
  var n2 = this;
  this.o.forEach(function(t3, e3) {
    W(n2, e3, t3);
  });
};
var z2 = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103;
var B2 = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;
var H2 = "undefined" != typeof document;
var Z = function(n2) {
  return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/i : /fil|che|ra/i).test(n2);
};
x.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function(t3) {
  Object.defineProperty(x.prototype, t3, { configurable: true, get: function() {
    return this["UNSAFE_" + t3];
  }, set: function(n2) {
    Object.defineProperty(this, t3, { configurable: true, writable: true, value: n2 });
  } });
});
var G2 = l.event;
function J() {
}
function K() {
  return this.cancelBubble;
}
function Q() {
  return this.defaultPrevented;
}
l.event = function(n2) {
  return G2 && (n2 = G2(n2)), n2.persist = J, n2.isPropagationStopped = K, n2.isDefaultPrevented = Q, n2.nativeEvent = n2;
};
var X;
var nn = { configurable: true, get: function() {
  return this.class;
} };
var tn = l.vnode;
l.vnode = function(n2) {
  var t3 = n2.type, e3 = n2.props, u3 = e3;
  if ("string" == typeof t3) {
    var o2 = -1 === t3.indexOf("-");
    for (var i3 in u3 = {}, e3) {
      var l3 = e3[i3];
      H2 && "children" === i3 && "noscript" === t3 || "value" === i3 && "defaultValue" in e3 && null == l3 || ("defaultValue" === i3 && "value" in e3 && null == e3.value ? i3 = "value" : "download" === i3 && true === l3 ? l3 = "" : /ondoubleclick/i.test(i3) ? i3 = "ondblclick" : /^onchange(textarea|input)/i.test(i3 + t3) && !Z(e3.type) ? i3 = "oninput" : /^onfocus$/i.test(i3) ? i3 = "onfocusin" : /^onblur$/i.test(i3) ? i3 = "onfocusout" : /^on(Ani|Tra|Tou|BeforeInp|Compo)/.test(i3) ? i3 = i3.toLowerCase() : o2 && B2.test(i3) ? i3 = i3.replace(/[A-Z0-9]/g, "-$&").toLowerCase() : null === l3 && (l3 = void 0), /^oninput$/i.test(i3) && (i3 = i3.toLowerCase(), u3[i3] && (i3 = "oninputCapture")), u3[i3] = l3);
    }
    "select" == t3 && u3.multiple && Array.isArray(u3.value) && (u3.value = j(e3.children).forEach(function(n3) {
      n3.props.selected = -1 != u3.value.indexOf(n3.props.value);
    })), "select" == t3 && null != u3.defaultValue && (u3.value = j(e3.children).forEach(function(n3) {
      n3.props.selected = u3.multiple ? -1 != u3.defaultValue.indexOf(n3.props.value) : u3.defaultValue == n3.props.value;
    })), n2.props = u3, e3.class != e3.className && (nn.enumerable = "className" in e3, null != e3.className && (u3.class = e3.className), Object.defineProperty(u3, "className", nn));
  }
  n2.$$typeof = z2, tn && tn(n2);
};
var en = l.__r;
l.__r = function(n2) {
  en && en(n2), X = n2.__c;
};

// node_modules/@fullcalendar/core/internal-common.js
var styleTexts = [];
var styleEls = /* @__PURE__ */ new Map();
function injectStyles(styleText) {
  styleTexts.push(styleText);
  styleEls.forEach((styleEl) => {
    appendStylesTo(styleEl, styleText);
  });
}
function ensureElHasStyles(el) {
  if (el.isConnected && // sometimes true if SSR system simulates DOM
  el.getRootNode) {
    registerStylesRoot(el.getRootNode());
  }
}
function registerStylesRoot(rootNode) {
  let styleEl = styleEls.get(rootNode);
  if (!styleEl || !styleEl.isConnected) {
    styleEl = rootNode.querySelector("style[data-fullcalendar]");
    if (!styleEl) {
      styleEl = document.createElement("style");
      styleEl.setAttribute("data-fullcalendar", "");
      const nonce = getNonceValue();
      if (nonce) {
        styleEl.nonce = nonce;
      }
      const parentEl = rootNode === document ? document.head : rootNode;
      const insertBefore = rootNode === document ? parentEl.querySelector("script,link[rel=stylesheet],link[as=style],style") : parentEl.firstChild;
      parentEl.insertBefore(styleEl, insertBefore);
    }
    styleEls.set(rootNode, styleEl);
    hydrateStylesRoot(styleEl);
  }
}
function hydrateStylesRoot(styleEl) {
  for (const styleText of styleTexts) {
    appendStylesTo(styleEl, styleText);
  }
}
function appendStylesTo(styleEl, styleText) {
  const { sheet } = styleEl;
  const ruleCnt = sheet.cssRules.length;
  styleText.split("}").forEach((styleStr, i3) => {
    styleStr = styleStr.trim();
    if (styleStr) {
      sheet.insertRule(styleStr + "}", ruleCnt + i3);
    }
  });
}
var queriedNonceValue;
function getNonceValue() {
  if (queriedNonceValue === void 0) {
    queriedNonceValue = queryNonceValue();
  }
  return queriedNonceValue;
}
function queryNonceValue() {
  const metaWithNonce = document.querySelector('meta[name="csp-nonce"]');
  if (metaWithNonce && metaWithNonce.hasAttribute("content")) {
    return metaWithNonce.getAttribute("content");
  }
  const elWithNonce = document.querySelector("script[nonce]");
  if (elWithNonce) {
    return elWithNonce.nonce || "";
  }
  return "";
}
if (typeof document !== "undefined") {
  registerStylesRoot(document);
}
var css_248z = ':root{--fc-small-font-size:.85em;--fc-page-bg-color:#fff;--fc-neutral-bg-color:hsla(0,0%,82%,.3);--fc-neutral-text-color:grey;--fc-border-color:#ddd;--fc-button-text-color:#fff;--fc-button-bg-color:#2c3e50;--fc-button-border-color:#2c3e50;--fc-button-hover-bg-color:#1e2b37;--fc-button-hover-border-color:#1a252f;--fc-button-active-bg-color:#1a252f;--fc-button-active-border-color:#151e27;--fc-event-bg-color:#3788d8;--fc-event-border-color:#3788d8;--fc-event-text-color:#fff;--fc-event-selected-overlay-color:rgba(0,0,0,.25);--fc-more-link-bg-color:#d0d0d0;--fc-more-link-text-color:inherit;--fc-event-resizer-thickness:8px;--fc-event-resizer-dot-total-width:8px;--fc-event-resizer-dot-border-width:1px;--fc-non-business-color:hsla(0,0%,84%,.3);--fc-bg-event-color:#8fdf82;--fc-bg-event-opacity:0.3;--fc-highlight-color:rgba(188,232,241,.3);--fc-today-bg-color:rgba(255,220,40,.15);--fc-now-indicator-color:red}.fc-not-allowed,.fc-not-allowed .fc-event{cursor:not-allowed}.fc{display:flex;flex-direction:column;font-size:1em}.fc,.fc *,.fc :after,.fc :before{box-sizing:border-box}.fc table{border-collapse:collapse;border-spacing:0;font-size:1em}.fc th{text-align:center}.fc td,.fc th{padding:0;vertical-align:top}.fc a[data-navlink]{cursor:pointer}.fc a[data-navlink]:hover{text-decoration:underline}.fc-direction-ltr{direction:ltr;text-align:left}.fc-direction-rtl{direction:rtl;text-align:right}.fc-theme-standard td,.fc-theme-standard th{border:1px solid var(--fc-border-color)}.fc-liquid-hack td,.fc-liquid-hack th{position:relative}@font-face{font-family:fcicons;font-style:normal;font-weight:400;src:url("data:application/x-font-ttf;charset=utf-8;base64,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") format("truetype")}.fc-icon{speak:none;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;display:inline-block;font-family:fcicons!important;font-style:normal;font-variant:normal;font-weight:400;height:1em;line-height:1;text-align:center;text-transform:none;-moz-user-select:none;user-select:none;width:1em}.fc-icon-chevron-left:before{content:"\\e900"}.fc-icon-chevron-right:before{content:"\\e901"}.fc-icon-chevrons-left:before{content:"\\e902"}.fc-icon-chevrons-right:before{content:"\\e903"}.fc-icon-minus-square:before{content:"\\e904"}.fc-icon-plus-square:before{content:"\\e905"}.fc-icon-x:before{content:"\\e906"}.fc .fc-button{border-radius:0;font-family:inherit;font-size:inherit;line-height:inherit;margin:0;overflow:visible;text-transform:none}.fc .fc-button:focus{outline:1px dotted;outline:5px auto -webkit-focus-ring-color}.fc .fc-button{-webkit-appearance:button}.fc .fc-button:not(:disabled){cursor:pointer}.fc .fc-button{background-color:transparent;border:1px solid transparent;border-radius:.25em;display:inline-block;font-size:1em;font-weight:400;line-height:1.5;padding:.4em .65em;text-align:center;-moz-user-select:none;user-select:none;vertical-align:middle}.fc .fc-button:hover{text-decoration:none}.fc .fc-button:focus{box-shadow:0 0 0 .2rem rgba(44,62,80,.25);outline:0}.fc .fc-button:disabled{opacity:.65}.fc .fc-button-primary{background-color:var(--fc-button-bg-color);border-color:var(--fc-button-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:hover{background-color:var(--fc-button-hover-bg-color);border-color:var(--fc-button-hover-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:disabled{background-color:var(--fc-button-bg-color);border-color:var(--fc-button-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:focus{box-shadow:0 0 0 .2rem rgba(76,91,106,.5)}.fc .fc-button-primary:not(:disabled).fc-button-active,.fc .fc-button-primary:not(:disabled):active{background-color:var(--fc-button-active-bg-color);border-color:var(--fc-button-active-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:not(:disabled).fc-button-active:focus,.fc .fc-button-primary:not(:disabled):active:focus{box-shadow:0 0 0 .2rem rgba(76,91,106,.5)}.fc .fc-button .fc-icon{font-size:1.5em;vertical-align:middle}.fc .fc-button-group{display:inline-flex;position:relative;vertical-align:middle}.fc .fc-button-group>.fc-button{flex:1 1 auto;position:relative}.fc .fc-button-group>.fc-button.fc-button-active,.fc .fc-button-group>.fc-button:active,.fc .fc-button-group>.fc-button:focus,.fc .fc-button-group>.fc-button:hover{z-index:1}.fc-direction-ltr .fc-button-group>.fc-button:not(:first-child){border-bottom-left-radius:0;border-top-left-radius:0;margin-left:-1px}.fc-direction-ltr .fc-button-group>.fc-button:not(:last-child){border-bottom-right-radius:0;border-top-right-radius:0}.fc-direction-rtl .fc-button-group>.fc-button:not(:first-child){border-bottom-right-radius:0;border-top-right-radius:0;margin-right:-1px}.fc-direction-rtl .fc-button-group>.fc-button:not(:last-child){border-bottom-left-radius:0;border-top-left-radius:0}.fc .fc-toolbar{align-items:center;display:flex;justify-content:space-between}.fc .fc-toolbar.fc-header-toolbar{margin-bottom:1.5em}.fc .fc-toolbar.fc-footer-toolbar{margin-top:1.5em}.fc .fc-toolbar-title{font-size:1.75em;margin:0}.fc-direction-ltr .fc-toolbar>*>:not(:first-child){margin-left:.75em}.fc-direction-rtl .fc-toolbar>*>:not(:first-child){margin-right:.75em}.fc-direction-rtl .fc-toolbar-ltr{flex-direction:row-reverse}.fc .fc-scroller{-webkit-overflow-scrolling:touch;position:relative}.fc .fc-scroller-liquid{height:100%}.fc .fc-scroller-liquid-absolute{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-scroller-harness{direction:ltr;overflow:hidden;position:relative}.fc .fc-scroller-harness-liquid{height:100%}.fc-direction-rtl .fc-scroller-harness>.fc-scroller{direction:rtl}.fc-theme-standard .fc-scrollgrid{border:1px solid var(--fc-border-color)}.fc .fc-scrollgrid,.fc .fc-scrollgrid table{table-layout:fixed;width:100%}.fc .fc-scrollgrid table{border-left-style:hidden;border-right-style:hidden;border-top-style:hidden}.fc .fc-scrollgrid{border-bottom-width:0;border-collapse:separate;border-right-width:0}.fc .fc-scrollgrid-liquid{height:100%}.fc .fc-scrollgrid-section,.fc .fc-scrollgrid-section table,.fc .fc-scrollgrid-section>td{height:1px}.fc .fc-scrollgrid-section-liquid>td{height:100%}.fc .fc-scrollgrid-section>*{border-left-width:0;border-top-width:0}.fc .fc-scrollgrid-section-footer>*,.fc .fc-scrollgrid-section-header>*{border-bottom-width:0}.fc .fc-scrollgrid-section-body table,.fc .fc-scrollgrid-section-footer table{border-bottom-style:hidden}.fc .fc-scrollgrid-section-sticky>*{background:var(--fc-page-bg-color);position:sticky;z-index:3}.fc .fc-scrollgrid-section-header.fc-scrollgrid-section-sticky>*{top:0}.fc .fc-scrollgrid-section-footer.fc-scrollgrid-section-sticky>*{bottom:0}.fc .fc-scrollgrid-sticky-shim{height:1px;margin-bottom:-1px}.fc-sticky{position:sticky}.fc .fc-view-harness{flex-grow:1;position:relative}.fc .fc-view-harness-active>.fc-view{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-col-header-cell-cushion{display:inline-block;padding:2px 4px}.fc .fc-bg-event,.fc .fc-highlight,.fc .fc-non-business{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-non-business{background:var(--fc-non-business-color)}.fc .fc-bg-event{background:var(--fc-bg-event-color);opacity:var(--fc-bg-event-opacity)}.fc .fc-bg-event .fc-event-title{font-size:var(--fc-small-font-size);font-style:italic;margin:.5em}.fc .fc-highlight{background:var(--fc-highlight-color)}.fc .fc-cell-shaded,.fc .fc-day-disabled{background:var(--fc-neutral-bg-color)}a.fc-event,a.fc-event:hover{text-decoration:none}.fc-event.fc-event-draggable,.fc-event[href]{cursor:pointer}.fc-event .fc-event-main{position:relative;z-index:2}.fc-event-dragging:not(.fc-event-selected){opacity:.75}.fc-event-dragging.fc-event-selected{box-shadow:0 2px 7px rgba(0,0,0,.3)}.fc-event .fc-event-resizer{display:none;position:absolute;z-index:4}.fc-event-selected .fc-event-resizer,.fc-event:hover .fc-event-resizer{display:block}.fc-event-selected .fc-event-resizer{background:var(--fc-page-bg-color);border-color:inherit;border-radius:calc(var(--fc-event-resizer-dot-total-width)/2);border-style:solid;border-width:var(--fc-event-resizer-dot-border-width);height:var(--fc-event-resizer-dot-total-width);width:var(--fc-event-resizer-dot-total-width)}.fc-event-selected .fc-event-resizer:before{bottom:-20px;content:"";left:-20px;position:absolute;right:-20px;top:-20px}.fc-event-selected,.fc-event:focus{box-shadow:0 2px 5px rgba(0,0,0,.2)}.fc-event-selected:before,.fc-event:focus:before{bottom:0;content:"";left:0;position:absolute;right:0;top:0;z-index:3}.fc-event-selected:after,.fc-event:focus:after{background:var(--fc-event-selected-overlay-color);bottom:-1px;content:"";left:-1px;position:absolute;right:-1px;top:-1px;z-index:1}.fc-h-event{background-color:var(--fc-event-bg-color);border:1px solid var(--fc-event-border-color);display:block}.fc-h-event .fc-event-main{color:var(--fc-event-text-color)}.fc-h-event .fc-event-main-frame{display:flex}.fc-h-event .fc-event-time{max-width:100%;overflow:hidden}.fc-h-event .fc-event-title-container{flex-grow:1;flex-shrink:1;min-width:0}.fc-h-event .fc-event-title{display:inline-block;left:0;max-width:100%;overflow:hidden;right:0;vertical-align:top}.fc-h-event.fc-event-selected:before{bottom:-10px;top:-10px}.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-start),.fc-direction-rtl .fc-daygrid-block-event:not(.fc-event-end){border-bottom-left-radius:0;border-left-width:0;border-top-left-radius:0}.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-end),.fc-direction-rtl .fc-daygrid-block-event:not(.fc-event-start){border-bottom-right-radius:0;border-right-width:0;border-top-right-radius:0}.fc-h-event:not(.fc-event-selected) .fc-event-resizer{bottom:0;top:0;width:var(--fc-event-resizer-thickness)}.fc-direction-ltr .fc-h-event:not(.fc-event-selected) .fc-event-resizer-start,.fc-direction-rtl .fc-h-event:not(.fc-event-selected) .fc-event-resizer-end{cursor:w-resize;left:calc(var(--fc-event-resizer-thickness)*-.5)}.fc-direction-ltr .fc-h-event:not(.fc-event-selected) .fc-event-resizer-end,.fc-direction-rtl .fc-h-event:not(.fc-event-selected) .fc-event-resizer-start{cursor:e-resize;right:calc(var(--fc-event-resizer-thickness)*-.5)}.fc-h-event.fc-event-selected .fc-event-resizer{margin-top:calc(var(--fc-event-resizer-dot-total-width)*-.5);top:50%}.fc-direction-ltr .fc-h-event.fc-event-selected .fc-event-resizer-start,.fc-direction-rtl .fc-h-event.fc-event-selected .fc-event-resizer-end{left:calc(var(--fc-event-resizer-dot-total-width)*-.5)}.fc-direction-ltr .fc-h-event.fc-event-selected .fc-event-resizer-end,.fc-direction-rtl .fc-h-event.fc-event-selected .fc-event-resizer-start{right:calc(var(--fc-event-resizer-dot-total-width)*-.5)}.fc .fc-popover{box-shadow:0 2px 6px rgba(0,0,0,.15);position:absolute;z-index:9999}.fc .fc-popover-header{align-items:center;display:flex;flex-direction:row;justify-content:space-between;padding:3px 4px}.fc .fc-popover-title{margin:0 2px}.fc .fc-popover-close{cursor:pointer;font-size:1.1em;opacity:.65}.fc-theme-standard .fc-popover{background:var(--fc-page-bg-color);border:1px solid var(--fc-border-color)}.fc-theme-standard .fc-popover-header{background:var(--fc-neutral-bg-color)}';
injectStyles(css_248z);
var DelayedRunner = class {
  constructor(drainedOption) {
    this.drainedOption = drainedOption;
    this.isRunning = false;
    this.isDirty = false;
    this.pauseDepths = {};
    this.timeoutId = 0;
  }
  request(delay) {
    this.isDirty = true;
    if (!this.isPaused()) {
      this.clearTimeout();
      if (delay == null) {
        this.tryDrain();
      } else {
        this.timeoutId = setTimeout(
          // NOT OPTIMAL! TODO: look at debounce
          this.tryDrain.bind(this),
          delay
        );
      }
    }
  }
  pause(scope = "") {
    let { pauseDepths } = this;
    pauseDepths[scope] = (pauseDepths[scope] || 0) + 1;
    this.clearTimeout();
  }
  resume(scope = "", force) {
    let { pauseDepths } = this;
    if (scope in pauseDepths) {
      if (force) {
        delete pauseDepths[scope];
      } else {
        pauseDepths[scope] -= 1;
        let depth = pauseDepths[scope];
        if (depth <= 0) {
          delete pauseDepths[scope];
        }
      }
      this.tryDrain();
    }
  }
  isPaused() {
    return Object.keys(this.pauseDepths).length;
  }
  tryDrain() {
    if (!this.isRunning && !this.isPaused()) {
      this.isRunning = true;
      while (this.isDirty) {
        this.isDirty = false;
        this.drained();
      }
      this.isRunning = false;
    }
  }
  clear() {
    this.clearTimeout();
    this.isDirty = false;
    this.pauseDepths = {};
  }
  clearTimeout() {
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
      this.timeoutId = 0;
    }
  }
  drained() {
    if (this.drainedOption) {
      this.drainedOption();
    }
  }
};
function removeElement(el) {
  if (el.parentNode) {
    el.parentNode.removeChild(el);
  }
}
function elementClosest(el, selector) {
  if (el.closest) {
    return el.closest(selector);
  }
  if (!document.documentElement.contains(el)) {
    return null;
  }
  do {
    if (elementMatches(el, selector)) {
      return el;
    }
    el = el.parentElement || el.parentNode;
  } while (el !== null && el.nodeType === 1);
  return null;
}
function elementMatches(el, selector) {
  let method = el.matches || el.matchesSelector || el.msMatchesSelector;
  return method.call(el, selector);
}
function findElements(container, selector) {
  let containers = container instanceof HTMLElement ? [container] : container;
  let allMatches = [];
  for (let i3 = 0; i3 < containers.length; i3 += 1) {
    let matches = containers[i3].querySelectorAll(selector);
    for (let j4 = 0; j4 < matches.length; j4 += 1) {
      allMatches.push(matches[j4]);
    }
  }
  return allMatches;
}
var PIXEL_PROP_RE = /(top|left|right|bottom|width|height)$/i;
function applyStyle(el, props) {
  for (let propName in props) {
    applyStyleProp(el, propName, props[propName]);
  }
}
function applyStyleProp(el, name, val) {
  if (val == null) {
    el.style[name] = "";
  } else if (typeof val === "number" && PIXEL_PROP_RE.test(name)) {
    el.style[name] = `${val}px`;
  } else {
    el.style[name] = val;
  }
}
function getEventTargetViaRoot(ev) {
  var _a, _b;
  return (_b = (_a = ev.composedPath) === null || _a === void 0 ? void 0 : _a.call(ev)[0]) !== null && _b !== void 0 ? _b : ev.target;
}
var guid$1 = 0;
function getUniqueDomId() {
  guid$1 += 1;
  return "fc-dom-" + guid$1;
}
function preventDefault(ev) {
  ev.preventDefault();
}
function buildDelegationHandler(selector, handler) {
  return (ev) => {
    let matchedChild = elementClosest(ev.target, selector);
    if (matchedChild) {
      handler.call(matchedChild, ev, matchedChild);
    }
  };
}
function listenBySelector(container, eventType, selector, handler) {
  let attachedHandler = buildDelegationHandler(selector, handler);
  container.addEventListener(eventType, attachedHandler);
  return () => {
    container.removeEventListener(eventType, attachedHandler);
  };
}
function listenToHoverBySelector(container, selector, onMouseEnter, onMouseLeave) {
  let currentMatchedChild;
  return listenBySelector(container, "mouseover", selector, (mouseOverEv, matchedChild) => {
    if (matchedChild !== currentMatchedChild) {
      currentMatchedChild = matchedChild;
      onMouseEnter(mouseOverEv, matchedChild);
      let realOnMouseLeave = (mouseLeaveEv) => {
        currentMatchedChild = null;
        onMouseLeave(mouseLeaveEv, matchedChild);
        matchedChild.removeEventListener("mouseleave", realOnMouseLeave);
      };
      matchedChild.addEventListener("mouseleave", realOnMouseLeave);
    }
  });
}
var transitionEventNames = [
  "webkitTransitionEnd",
  "otransitionend",
  "oTransitionEnd",
  "msTransitionEnd",
  "transitionend"
];
function whenTransitionDone(el, callback) {
  let realCallback = (ev) => {
    callback(ev);
    transitionEventNames.forEach((eventName) => {
      el.removeEventListener(eventName, realCallback);
    });
  };
  transitionEventNames.forEach((eventName) => {
    el.addEventListener(eventName, realCallback);
  });
}
function createAriaClickAttrs(handler) {
  return Object.assign({ onClick: handler }, createAriaKeyboardAttrs(handler));
}
function createAriaKeyboardAttrs(handler) {
  return {
    tabIndex: 0,
    onKeyDown(ev) {
      if (ev.key === "Enter" || ev.key === " ") {
        handler(ev);
        ev.preventDefault();
      }
    }
  };
}
var guidNumber = 0;
function guid() {
  guidNumber += 1;
  return String(guidNumber);
}
function disableCursor() {
  document.body.classList.add("fc-not-allowed");
}
function enableCursor() {
  document.body.classList.remove("fc-not-allowed");
}
function preventSelection(el) {
  el.style.userSelect = "none";
  el.style.webkitUserSelect = "none";
  el.addEventListener("selectstart", preventDefault);
}
function allowSelection(el) {
  el.style.userSelect = "";
  el.style.webkitUserSelect = "";
  el.removeEventListener("selectstart", preventDefault);
}
function preventContextMenu(el) {
  el.addEventListener("contextmenu", preventDefault);
}
function allowContextMenu(el) {
  el.removeEventListener("contextmenu", preventDefault);
}
function parseFieldSpecs(input) {
  let specs = [];
  let tokens = [];
  let i3;
  let token;
  if (typeof input === "string") {
    tokens = input.split(/\s*,\s*/);
  } else if (typeof input === "function") {
    tokens = [input];
  } else if (Array.isArray(input)) {
    tokens = input;
  }
  for (i3 = 0; i3 < tokens.length; i3 += 1) {
    token = tokens[i3];
    if (typeof token === "string") {
      specs.push(token.charAt(0) === "-" ? { field: token.substring(1), order: -1 } : { field: token, order: 1 });
    } else if (typeof token === "function") {
      specs.push({ func: token });
    }
  }
  return specs;
}
function compareByFieldSpecs(obj0, obj1, fieldSpecs) {
  let i3;
  let cmp;
  for (i3 = 0; i3 < fieldSpecs.length; i3 += 1) {
    cmp = compareByFieldSpec(obj0, obj1, fieldSpecs[i3]);
    if (cmp) {
      return cmp;
    }
  }
  return 0;
}
function compareByFieldSpec(obj0, obj1, fieldSpec) {
  if (fieldSpec.func) {
    return fieldSpec.func(obj0, obj1);
  }
  return flexibleCompare(obj0[fieldSpec.field], obj1[fieldSpec.field]) * (fieldSpec.order || 1);
}
function flexibleCompare(a3, b3) {
  if (!a3 && !b3) {
    return 0;
  }
  if (b3 == null) {
    return -1;
  }
  if (a3 == null) {
    return 1;
  }
  if (typeof a3 === "string" || typeof b3 === "string") {
    return String(a3).localeCompare(String(b3));
  }
  return a3 - b3;
}
function padStart(val, len) {
  let s3 = String(val);
  return "000".substr(0, len - s3.length) + s3;
}
function formatWithOrdinals(formatter, args, fallbackText) {
  if (typeof formatter === "function") {
    return formatter(...args);
  }
  if (typeof formatter === "string") {
    return args.reduce((str, arg, index8) => str.replace("$" + index8, arg || ""), formatter);
  }
  return fallbackText;
}
function compareNumbers(a3, b3) {
  return a3 - b3;
}
function isInt(n2) {
  return n2 % 1 === 0;
}
function computeSmallestCellWidth(cellEl) {
  let allWidthEl = cellEl.querySelector(".fc-scrollgrid-shrink-frame");
  let contentWidthEl = cellEl.querySelector(".fc-scrollgrid-shrink-cushion");
  if (!allWidthEl) {
    throw new Error("needs fc-scrollgrid-shrink-frame className");
  }
  if (!contentWidthEl) {
    throw new Error("needs fc-scrollgrid-shrink-cushion className");
  }
  return cellEl.getBoundingClientRect().width - allWidthEl.getBoundingClientRect().width + // the cell padding+border
  contentWidthEl.getBoundingClientRect().width;
}
var INTERNAL_UNITS = ["years", "months", "days", "milliseconds"];
var PARSE_RE = /^(-?)(?:(\d+)\.)?(\d+):(\d\d)(?::(\d\d)(?:\.(\d\d\d))?)?/;
function createDuration(input, unit) {
  if (typeof input === "string") {
    return parseString(input);
  }
  if (typeof input === "object" && input) {
    return parseObject(input);
  }
  if (typeof input === "number") {
    return parseObject({ [unit || "milliseconds"]: input });
  }
  return null;
}
function parseString(s3) {
  let m3 = PARSE_RE.exec(s3);
  if (m3) {
    let sign = m3[1] ? -1 : 1;
    return {
      years: 0,
      months: 0,
      days: sign * (m3[2] ? parseInt(m3[2], 10) : 0),
      milliseconds: sign * ((m3[3] ? parseInt(m3[3], 10) : 0) * 60 * 60 * 1e3 + // hours
      (m3[4] ? parseInt(m3[4], 10) : 0) * 60 * 1e3 + // minutes
      (m3[5] ? parseInt(m3[5], 10) : 0) * 1e3 + // seconds
      (m3[6] ? parseInt(m3[6], 10) : 0))
    };
  }
  return null;
}
function parseObject(obj) {
  let duration = {
    years: obj.years || obj.year || 0,
    months: obj.months || obj.month || 0,
    days: obj.days || obj.day || 0,
    milliseconds: (obj.hours || obj.hour || 0) * 60 * 60 * 1e3 + // hours
    (obj.minutes || obj.minute || 0) * 60 * 1e3 + // minutes
    (obj.seconds || obj.second || 0) * 1e3 + // seconds
    (obj.milliseconds || obj.millisecond || obj.ms || 0)
    // ms
  };
  let weeks = obj.weeks || obj.week;
  if (weeks) {
    duration.days += weeks * 7;
    duration.specifiedWeeks = true;
  }
  return duration;
}
function durationsEqual(d0, d1) {
  return d0.years === d1.years && d0.months === d1.months && d0.days === d1.days && d0.milliseconds === d1.milliseconds;
}
function addDurations(d0, d1) {
  return {
    years: d0.years + d1.years,
    months: d0.months + d1.months,
    days: d0.days + d1.days,
    milliseconds: d0.milliseconds + d1.milliseconds
  };
}
function subtractDurations(d1, d0) {
  return {
    years: d1.years - d0.years,
    months: d1.months - d0.months,
    days: d1.days - d0.days,
    milliseconds: d1.milliseconds - d0.milliseconds
  };
}
function multiplyDuration(d2, n2) {
  return {
    years: d2.years * n2,
    months: d2.months * n2,
    days: d2.days * n2,
    milliseconds: d2.milliseconds * n2
  };
}
function asRoughYears(dur) {
  return asRoughDays(dur) / 365;
}
function asRoughMonths(dur) {
  return asRoughDays(dur) / 30;
}
function asRoughDays(dur) {
  return asRoughMs(dur) / 864e5;
}
function asRoughMs(dur) {
  return dur.years * (365 * 864e5) + dur.months * (30 * 864e5) + dur.days * 864e5 + dur.milliseconds;
}
function wholeDivideDurations(numerator, denominator) {
  let res = null;
  for (let i3 = 0; i3 < INTERNAL_UNITS.length; i3 += 1) {
    let unit = INTERNAL_UNITS[i3];
    if (denominator[unit]) {
      let localRes = numerator[unit] / denominator[unit];
      if (!isInt(localRes) || res !== null && res !== localRes) {
        return null;
      }
      res = localRes;
    } else if (numerator[unit]) {
      return null;
    }
  }
  return res;
}
function greatestDurationDenominator(dur) {
  let ms = dur.milliseconds;
  if (ms) {
    if (ms % 1e3 !== 0) {
      return { unit: "millisecond", value: ms };
    }
    if (ms % (1e3 * 60) !== 0) {
      return { unit: "second", value: ms / 1e3 };
    }
    if (ms % (1e3 * 60 * 60) !== 0) {
      return { unit: "minute", value: ms / (1e3 * 60) };
    }
    if (ms) {
      return { unit: "hour", value: ms / (1e3 * 60 * 60) };
    }
  }
  if (dur.days) {
    if (dur.specifiedWeeks && dur.days % 7 === 0) {
      return { unit: "week", value: dur.days / 7 };
    }
    return { unit: "day", value: dur.days };
  }
  if (dur.months) {
    return { unit: "month", value: dur.months };
  }
  if (dur.years) {
    return { unit: "year", value: dur.years };
  }
  return { unit: "millisecond", value: 0 };
}
function isArraysEqual(a0, a1, equalityFunc) {
  if (a0 === a1) {
    return true;
  }
  let len = a0.length;
  let i3;
  if (len !== a1.length) {
    return false;
  }
  for (i3 = 0; i3 < len; i3 += 1) {
    if (!(equalityFunc ? equalityFunc(a0[i3], a1[i3]) : a0[i3] === a1[i3])) {
      return false;
    }
  }
  return true;
}
var DAY_IDS = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];
function addWeeks(m3, n2) {
  let a3 = dateToUtcArray(m3);
  a3[2] += n2 * 7;
  return arrayToUtcDate(a3);
}
function addDays(m3, n2) {
  let a3 = dateToUtcArray(m3);
  a3[2] += n2;
  return arrayToUtcDate(a3);
}
function addMs(m3, n2) {
  let a3 = dateToUtcArray(m3);
  a3[6] += n2;
  return arrayToUtcDate(a3);
}
function diffWeeks(m0, m1) {
  return diffDays(m0, m1) / 7;
}
function diffDays(m0, m1) {
  return (m1.valueOf() - m0.valueOf()) / (1e3 * 60 * 60 * 24);
}
function diffHours(m0, m1) {
  return (m1.valueOf() - m0.valueOf()) / (1e3 * 60 * 60);
}
function diffMinutes(m0, m1) {
  return (m1.valueOf() - m0.valueOf()) / (1e3 * 60);
}
function diffSeconds(m0, m1) {
  return (m1.valueOf() - m0.valueOf()) / 1e3;
}
function diffDayAndTime(m0, m1) {
  let m0day = startOfDay(m0);
  let m1day = startOfDay(m1);
  return {
    years: 0,
    months: 0,
    days: Math.round(diffDays(m0day, m1day)),
    milliseconds: m1.valueOf() - m1day.valueOf() - (m0.valueOf() - m0day.valueOf())
  };
}
function diffWholeWeeks(m0, m1) {
  let d2 = diffWholeDays(m0, m1);
  if (d2 !== null && d2 % 7 === 0) {
    return d2 / 7;
  }
  return null;
}
function diffWholeDays(m0, m1) {
  if (timeAsMs(m0) === timeAsMs(m1)) {
    return Math.round(diffDays(m0, m1));
  }
  return null;
}
function startOfDay(m3) {
  return arrayToUtcDate([
    m3.getUTCFullYear(),
    m3.getUTCMonth(),
    m3.getUTCDate()
  ]);
}
function startOfHour(m3) {
  return arrayToUtcDate([
    m3.getUTCFullYear(),
    m3.getUTCMonth(),
    m3.getUTCDate(),
    m3.getUTCHours()
  ]);
}
function startOfMinute(m3) {
  return arrayToUtcDate([
    m3.getUTCFullYear(),
    m3.getUTCMonth(),
    m3.getUTCDate(),
    m3.getUTCHours(),
    m3.getUTCMinutes()
  ]);
}
function startOfSecond(m3) {
  return arrayToUtcDate([
    m3.getUTCFullYear(),
    m3.getUTCMonth(),
    m3.getUTCDate(),
    m3.getUTCHours(),
    m3.getUTCMinutes(),
    m3.getUTCSeconds()
  ]);
}
function weekOfYear(marker, dow, doy) {
  let y3 = marker.getUTCFullYear();
  let w4 = weekOfGivenYear(marker, y3, dow, doy);
  if (w4 < 1) {
    return weekOfGivenYear(marker, y3 - 1, dow, doy);
  }
  let nextW = weekOfGivenYear(marker, y3 + 1, dow, doy);
  if (nextW >= 1) {
    return Math.min(w4, nextW);
  }
  return w4;
}
function weekOfGivenYear(marker, year, dow, doy) {
  let firstWeekStart = arrayToUtcDate([year, 0, 1 + firstWeekOffset(year, dow, doy)]);
  let dayStart = startOfDay(marker);
  let days = Math.round(diffDays(firstWeekStart, dayStart));
  return Math.floor(days / 7) + 1;
}
function firstWeekOffset(year, dow, doy) {
  let fwd = 7 + dow - doy;
  let fwdlw = (7 + arrayToUtcDate([year, 0, fwd]).getUTCDay() - dow) % 7;
  return -fwdlw + fwd - 1;
}
function dateToLocalArray(date) {
  return [
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    date.getHours(),
    date.getMinutes(),
    date.getSeconds(),
    date.getMilliseconds()
  ];
}
function arrayToLocalDate(a3) {
  return new Date(
    a3[0],
    a3[1] || 0,
    a3[2] == null ? 1 : a3[2],
    // day of month
    a3[3] || 0,
    a3[4] || 0,
    a3[5] || 0
  );
}
function dateToUtcArray(date) {
  return [
    date.getUTCFullYear(),
    date.getUTCMonth(),
    date.getUTCDate(),
    date.getUTCHours(),
    date.getUTCMinutes(),
    date.getUTCSeconds(),
    date.getUTCMilliseconds()
  ];
}
function arrayToUtcDate(a3) {
  if (a3.length === 1) {
    a3 = a3.concat([0]);
  }
  return new Date(Date.UTC(...a3));
}
function isValidDate(m3) {
  return !isNaN(m3.valueOf());
}
function timeAsMs(m3) {
  return m3.getUTCHours() * 1e3 * 60 * 60 + m3.getUTCMinutes() * 1e3 * 60 + m3.getUTCSeconds() * 1e3 + m3.getUTCMilliseconds();
}
function buildIsoString(marker, timeZoneOffset, stripZeroTime = false) {
  let s3 = marker.toISOString();
  s3 = s3.replace(".000", "");
  if (stripZeroTime) {
    s3 = s3.replace("T00:00:00Z", "");
  }
  if (s3.length > 10) {
    if (timeZoneOffset == null) {
      s3 = s3.replace("Z", "");
    } else if (timeZoneOffset !== 0) {
      s3 = s3.replace("Z", formatTimeZoneOffset(timeZoneOffset, true));
    }
  }
  return s3;
}
function formatDayString(marker) {
  return marker.toISOString().replace(/T.*$/, "");
}
function formatIsoMonthStr(marker) {
  return marker.toISOString().match(/^\d{4}-\d{2}/)[0];
}
function formatIsoTimeString(marker) {
  return padStart(marker.getUTCHours(), 2) + ":" + padStart(marker.getUTCMinutes(), 2) + ":" + padStart(marker.getUTCSeconds(), 2);
}
function formatTimeZoneOffset(minutes, doIso = false) {
  let sign = minutes < 0 ? "-" : "+";
  let abs = Math.abs(minutes);
  let hours = Math.floor(abs / 60);
  let mins = Math.round(abs % 60);
  if (doIso) {
    return `${sign + padStart(hours, 2)}:${padStart(mins, 2)}`;
  }
  return `GMT${sign}${hours}${mins ? `:${padStart(mins, 2)}` : ""}`;
}
function memoize(workerFunc, resEquality, teardownFunc) {
  let currentArgs;
  let currentRes;
  return function(...newArgs) {
    if (!currentArgs) {
      currentRes = workerFunc.apply(this, newArgs);
    } else if (!isArraysEqual(currentArgs, newArgs)) {
      if (teardownFunc) {
        teardownFunc(currentRes);
      }
      let res = workerFunc.apply(this, newArgs);
      if (!resEquality || !resEquality(res, currentRes)) {
        currentRes = res;
      }
    }
    currentArgs = newArgs;
    return currentRes;
  };
}
function memoizeObjArg(workerFunc, resEquality, teardownFunc) {
  let currentArg;
  let currentRes;
  return (newArg) => {
    if (!currentArg) {
      currentRes = workerFunc.call(this, newArg);
    } else if (!isPropsEqual(currentArg, newArg)) {
      if (teardownFunc) {
        teardownFunc(currentRes);
      }
      let res = workerFunc.call(this, newArg);
      if (!resEquality || !resEquality(res, currentRes)) {
        currentRes = res;
      }
    }
    currentArg = newArg;
    return currentRes;
  };
}
var EXTENDED_SETTINGS_AND_SEVERITIES = {
  week: 3,
  separator: 0,
  omitZeroMinute: 0,
  meridiem: 0,
  omitCommas: 0
};
var STANDARD_DATE_PROP_SEVERITIES = {
  timeZoneName: 7,
  era: 6,
  year: 5,
  month: 4,
  day: 2,
  weekday: 2,
  hour: 1,
  minute: 1,
  second: 1
};
var MERIDIEM_RE = /\s*([ap])\.?m\.?/i;
var COMMA_RE = /,/g;
var MULTI_SPACE_RE = /\s+/g;
var LTR_RE = /\u200e/g;
var UTC_RE = /UTC|GMT/;
var NativeFormatter = class {
  constructor(formatSettings) {
    let standardDateProps = {};
    let extendedSettings = {};
    let severity = 0;
    for (let name in formatSettings) {
      if (name in EXTENDED_SETTINGS_AND_SEVERITIES) {
        extendedSettings[name] = formatSettings[name];
        severity = Math.max(EXTENDED_SETTINGS_AND_SEVERITIES[name], severity);
      } else {
        standardDateProps[name] = formatSettings[name];
        if (name in STANDARD_DATE_PROP_SEVERITIES) {
          severity = Math.max(STANDARD_DATE_PROP_SEVERITIES[name], severity);
        }
      }
    }
    this.standardDateProps = standardDateProps;
    this.extendedSettings = extendedSettings;
    this.severity = severity;
    this.buildFormattingFunc = memoize(buildFormattingFunc);
  }
  format(date, context) {
    return this.buildFormattingFunc(this.standardDateProps, this.extendedSettings, context)(date);
  }
  formatRange(start, end, context, betterDefaultSeparator) {
    let { standardDateProps, extendedSettings } = this;
    let diffSeverity = computeMarkerDiffSeverity(start.marker, end.marker, context.calendarSystem);
    if (!diffSeverity) {
      return this.format(start, context);
    }
    let biggestUnitForPartial = diffSeverity;
    if (biggestUnitForPartial > 1 && // the two dates are different in a way that's larger scale than time
    (standardDateProps.year === "numeric" || standardDateProps.year === "2-digit") && (standardDateProps.month === "numeric" || standardDateProps.month === "2-digit") && (standardDateProps.day === "numeric" || standardDateProps.day === "2-digit")) {
      biggestUnitForPartial = 1;
    }
    let full0 = this.format(start, context);
    let full1 = this.format(end, context);
    if (full0 === full1) {
      return full0;
    }
    let partialDateProps = computePartialFormattingOptions(standardDateProps, biggestUnitForPartial);
    let partialFormattingFunc = buildFormattingFunc(partialDateProps, extendedSettings, context);
    let partial0 = partialFormattingFunc(start);
    let partial1 = partialFormattingFunc(end);
    let insertion = findCommonInsertion(full0, partial0, full1, partial1);
    let separator = extendedSettings.separator || betterDefaultSeparator || context.defaultSeparator || "";
    if (insertion) {
      return insertion.before + partial0 + separator + partial1 + insertion.after;
    }
    return full0 + separator + full1;
  }
  getLargestUnit() {
    switch (this.severity) {
      case 7:
      case 6:
      case 5:
        return "year";
      case 4:
        return "month";
      case 3:
        return "week";
      case 2:
        return "day";
      default:
        return "time";
    }
  }
};
function buildFormattingFunc(standardDateProps, extendedSettings, context) {
  let standardDatePropCnt = Object.keys(standardDateProps).length;
  if (standardDatePropCnt === 1 && standardDateProps.timeZoneName === "short") {
    return (date) => formatTimeZoneOffset(date.timeZoneOffset);
  }
  if (standardDatePropCnt === 0 && extendedSettings.week) {
    return (date) => formatWeekNumber(context.computeWeekNumber(date.marker), context.weekText, context.weekTextLong, context.locale, extendedSettings.week);
  }
  return buildNativeFormattingFunc(standardDateProps, extendedSettings, context);
}
function buildNativeFormattingFunc(standardDateProps, extendedSettings, context) {
  standardDateProps = Object.assign({}, standardDateProps);
  extendedSettings = Object.assign({}, extendedSettings);
  sanitizeSettings(standardDateProps, extendedSettings);
  standardDateProps.timeZone = "UTC";
  let normalFormat = new Intl.DateTimeFormat(context.locale.codes, standardDateProps);
  let zeroFormat;
  if (extendedSettings.omitZeroMinute) {
    let zeroProps = Object.assign({}, standardDateProps);
    delete zeroProps.minute;
    zeroFormat = new Intl.DateTimeFormat(context.locale.codes, zeroProps);
  }
  return (date) => {
    let { marker } = date;
    let format;
    if (zeroFormat && !marker.getUTCMinutes()) {
      format = zeroFormat;
    } else {
      format = normalFormat;
    }
    let s3 = format.format(marker);
    return postProcess(s3, date, standardDateProps, extendedSettings, context);
  };
}
function sanitizeSettings(standardDateProps, extendedSettings) {
  if (standardDateProps.timeZoneName) {
    if (!standardDateProps.hour) {
      standardDateProps.hour = "2-digit";
    }
    if (!standardDateProps.minute) {
      standardDateProps.minute = "2-digit";
    }
  }
  if (standardDateProps.timeZoneName === "long") {
    standardDateProps.timeZoneName = "short";
  }
  if (extendedSettings.omitZeroMinute && (standardDateProps.second || standardDateProps.millisecond)) {
    delete extendedSettings.omitZeroMinute;
  }
}
function postProcess(s3, date, standardDateProps, extendedSettings, context) {
  s3 = s3.replace(LTR_RE, "");
  if (standardDateProps.timeZoneName === "short") {
    s3 = injectTzoStr(s3, context.timeZone === "UTC" || date.timeZoneOffset == null ? "UTC" : (
      // important to normalize for IE, which does "GMT"
      formatTimeZoneOffset(date.timeZoneOffset)
    ));
  }
  if (extendedSettings.omitCommas) {
    s3 = s3.replace(COMMA_RE, "").trim();
  }
  if (extendedSettings.omitZeroMinute) {
    s3 = s3.replace(":00", "");
  }
  if (extendedSettings.meridiem === false) {
    s3 = s3.replace(MERIDIEM_RE, "").trim();
  } else if (extendedSettings.meridiem === "narrow") {
    s3 = s3.replace(MERIDIEM_RE, (m0, m1) => m1.toLocaleLowerCase());
  } else if (extendedSettings.meridiem === "short") {
    s3 = s3.replace(MERIDIEM_RE, (m0, m1) => `${m1.toLocaleLowerCase()}m`);
  } else if (extendedSettings.meridiem === "lowercase") {
    s3 = s3.replace(MERIDIEM_RE, (m0) => m0.toLocaleLowerCase());
  }
  s3 = s3.replace(MULTI_SPACE_RE, " ");
  s3 = s3.trim();
  return s3;
}
function injectTzoStr(s3, tzoStr) {
  let replaced = false;
  s3 = s3.replace(UTC_RE, () => {
    replaced = true;
    return tzoStr;
  });
  if (!replaced) {
    s3 += ` ${tzoStr}`;
  }
  return s3;
}
function formatWeekNumber(num, weekText, weekTextLong, locale, display2) {
  let parts = [];
  if (display2 === "long") {
    parts.push(weekTextLong);
  } else if (display2 === "short" || display2 === "narrow") {
    parts.push(weekText);
  }
  if (display2 === "long" || display2 === "short") {
    parts.push(" ");
  }
  parts.push(locale.simpleNumberFormat.format(num));
  if (locale.options.direction === "rtl") {
    parts.reverse();
  }
  return parts.join("");
}
function computeMarkerDiffSeverity(d0, d1, ca) {
  if (ca.getMarkerYear(d0) !== ca.getMarkerYear(d1)) {
    return 5;
  }
  if (ca.getMarkerMonth(d0) !== ca.getMarkerMonth(d1)) {
    return 4;
  }
  if (ca.getMarkerDay(d0) !== ca.getMarkerDay(d1)) {
    return 2;
  }
  if (timeAsMs(d0) !== timeAsMs(d1)) {
    return 1;
  }
  return 0;
}
function computePartialFormattingOptions(options, biggestUnit) {
  let partialOptions = {};
  for (let name in options) {
    if (!(name in STANDARD_DATE_PROP_SEVERITIES) || // not a date part prop (like timeZone)
    STANDARD_DATE_PROP_SEVERITIES[name] <= biggestUnit) {
      partialOptions[name] = options[name];
    }
  }
  return partialOptions;
}
function findCommonInsertion(full0, partial0, full1, partial1) {
  let i0 = 0;
  while (i0 < full0.length) {
    let found0 = full0.indexOf(partial0, i0);
    if (found0 === -1) {
      break;
    }
    let before0 = full0.substr(0, found0);
    i0 = found0 + partial0.length;
    let after0 = full0.substr(i0);
    let i1 = 0;
    while (i1 < full1.length) {
      let found1 = full1.indexOf(partial1, i1);
      if (found1 === -1) {
        break;
      }
      let before1 = full1.substr(0, found1);
      i1 = found1 + partial1.length;
      let after1 = full1.substr(i1);
      if (before0 === before1 && after0 === after1) {
        return {
          before: before0,
          after: after0
        };
      }
    }
  }
  return null;
}
function expandZonedMarker(dateInfo, calendarSystem) {
  let a3 = calendarSystem.markerToArray(dateInfo.marker);
  return {
    marker: dateInfo.marker,
    timeZoneOffset: dateInfo.timeZoneOffset,
    array: a3,
    year: a3[0],
    month: a3[1],
    day: a3[2],
    hour: a3[3],
    minute: a3[4],
    second: a3[5],
    millisecond: a3[6]
  };
}
function createVerboseFormattingArg(start, end, context, betterDefaultSeparator) {
  let startInfo = expandZonedMarker(start, context.calendarSystem);
  let endInfo = end ? expandZonedMarker(end, context.calendarSystem) : null;
  return {
    date: startInfo,
    start: startInfo,
    end: endInfo,
    timeZone: context.timeZone,
    localeCodes: context.locale.codes,
    defaultSeparator: betterDefaultSeparator || context.defaultSeparator
  };
}
var CmdFormatter = class {
  constructor(cmdStr) {
    this.cmdStr = cmdStr;
  }
  format(date, context, betterDefaultSeparator) {
    return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(date, null, context, betterDefaultSeparator));
  }
  formatRange(start, end, context, betterDefaultSeparator) {
    return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(start, end, context, betterDefaultSeparator));
  }
};
var FuncFormatter = class {
  constructor(func) {
    this.func = func;
  }
  format(date, context, betterDefaultSeparator) {
    return this.func(createVerboseFormattingArg(date, null, context, betterDefaultSeparator));
  }
  formatRange(start, end, context, betterDefaultSeparator) {
    return this.func(createVerboseFormattingArg(start, end, context, betterDefaultSeparator));
  }
};
function createFormatter(input) {
  if (typeof input === "object" && input) {
    return new NativeFormatter(input);
  }
  if (typeof input === "string") {
    return new CmdFormatter(input);
  }
  if (typeof input === "function") {
    return new FuncFormatter(input);
  }
  return null;
}
var BASE_OPTION_REFINERS = {
  navLinkDayClick: identity,
  navLinkWeekClick: identity,
  duration: createDuration,
  bootstrapFontAwesome: identity,
  buttonIcons: identity,
  customButtons: identity,
  defaultAllDayEventDuration: createDuration,
  defaultTimedEventDuration: createDuration,
  nextDayThreshold: createDuration,
  scrollTime: createDuration,
  scrollTimeReset: Boolean,
  slotMinTime: createDuration,
  slotMaxTime: createDuration,
  dayPopoverFormat: createFormatter,
  slotDuration: createDuration,
  snapDuration: createDuration,
  headerToolbar: identity,
  footerToolbar: identity,
  defaultRangeSeparator: String,
  titleRangeSeparator: String,
  forceEventDuration: Boolean,
  dayHeaders: Boolean,
  dayHeaderFormat: createFormatter,
  dayHeaderClassNames: identity,
  dayHeaderContent: identity,
  dayHeaderDidMount: identity,
  dayHeaderWillUnmount: identity,
  dayCellClassNames: identity,
  dayCellContent: identity,
  dayCellDidMount: identity,
  dayCellWillUnmount: identity,
  initialView: String,
  aspectRatio: Number,
  weekends: Boolean,
  weekNumberCalculation: identity,
  weekNumbers: Boolean,
  weekNumberClassNames: identity,
  weekNumberContent: identity,
  weekNumberDidMount: identity,
  weekNumberWillUnmount: identity,
  editable: Boolean,
  viewClassNames: identity,
  viewDidMount: identity,
  viewWillUnmount: identity,
  nowIndicator: Boolean,
  nowIndicatorClassNames: identity,
  nowIndicatorContent: identity,
  nowIndicatorDidMount: identity,
  nowIndicatorWillUnmount: identity,
  showNonCurrentDates: Boolean,
  lazyFetching: Boolean,
  startParam: String,
  endParam: String,
  timeZoneParam: String,
  timeZone: String,
  locales: identity,
  locale: identity,
  themeSystem: String,
  dragRevertDuration: Number,
  dragScroll: Boolean,
  allDayMaintainDuration: Boolean,
  unselectAuto: Boolean,
  dropAccept: identity,
  eventOrder: parseFieldSpecs,
  eventOrderStrict: Boolean,
  handleWindowResize: Boolean,
  windowResizeDelay: Number,
  longPressDelay: Number,
  eventDragMinDistance: Number,
  expandRows: Boolean,
  height: identity,
  contentHeight: identity,
  direction: String,
  weekNumberFormat: createFormatter,
  eventResizableFromStart: Boolean,
  displayEventTime: Boolean,
  displayEventEnd: Boolean,
  weekText: String,
  weekTextLong: String,
  progressiveEventRendering: Boolean,
  businessHours: identity,
  initialDate: identity,
  now: identity,
  eventDataTransform: identity,
  stickyHeaderDates: identity,
  stickyFooterScrollbar: identity,
  viewHeight: identity,
  defaultAllDay: Boolean,
  eventSourceFailure: identity,
  eventSourceSuccess: identity,
  eventDisplay: String,
  eventStartEditable: Boolean,
  eventDurationEditable: Boolean,
  eventOverlap: identity,
  eventConstraint: identity,
  eventAllow: identity,
  eventBackgroundColor: String,
  eventBorderColor: String,
  eventTextColor: String,
  eventColor: String,
  eventClassNames: identity,
  eventContent: identity,
  eventDidMount: identity,
  eventWillUnmount: identity,
  selectConstraint: identity,
  selectOverlap: identity,
  selectAllow: identity,
  droppable: Boolean,
  unselectCancel: String,
  slotLabelFormat: identity,
  slotLaneClassNames: identity,
  slotLaneContent: identity,
  slotLaneDidMount: identity,
  slotLaneWillUnmount: identity,
  slotLabelClassNames: identity,
  slotLabelContent: identity,
  slotLabelDidMount: identity,
  slotLabelWillUnmount: identity,
  dayMaxEvents: identity,
  dayMaxEventRows: identity,
  dayMinWidth: Number,
  slotLabelInterval: createDuration,
  allDayText: String,
  allDayClassNames: identity,
  allDayContent: identity,
  allDayDidMount: identity,
  allDayWillUnmount: identity,
  slotMinWidth: Number,
  navLinks: Boolean,
  eventTimeFormat: createFormatter,
  rerenderDelay: Number,
  moreLinkText: identity,
  moreLinkHint: identity,
  selectMinDistance: Number,
  selectable: Boolean,
  selectLongPressDelay: Number,
  eventLongPressDelay: Number,
  selectMirror: Boolean,
  eventMaxStack: Number,
  eventMinHeight: Number,
  eventMinWidth: Number,
  eventShortHeight: Number,
  slotEventOverlap: Boolean,
  plugins: identity,
  firstDay: Number,
  dayCount: Number,
  dateAlignment: String,
  dateIncrement: createDuration,
  hiddenDays: identity,
  fixedWeekCount: Boolean,
  validRange: identity,
  visibleRange: identity,
  titleFormat: identity,
  eventInteractive: Boolean,
  // only used by list-view, but languages define the value, so we need it in base options
  noEventsText: String,
  viewHint: identity,
  navLinkHint: identity,
  closeHint: String,
  timeHint: String,
  eventHint: String,
  moreLinkClick: identity,
  moreLinkClassNames: identity,
  moreLinkContent: identity,
  moreLinkDidMount: identity,
  moreLinkWillUnmount: identity,
  monthStartFormat: createFormatter,
  // for connectors
  // (can't be part of plugin system b/c must be provided at runtime)
  handleCustomRendering: identity,
  customRenderingMetaMap: identity,
  customRenderingReplaces: Boolean
};
var BASE_OPTION_DEFAULTS = {
  eventDisplay: "auto",
  defaultRangeSeparator: " - ",
  titleRangeSeparator: " \u2013 ",
  defaultTimedEventDuration: "01:00:00",
  defaultAllDayEventDuration: { day: 1 },
  forceEventDuration: false,
  nextDayThreshold: "00:00:00",
  dayHeaders: true,
  initialView: "",
  aspectRatio: 1.35,
  headerToolbar: {
    start: "title",
    center: "",
    end: "today prev,next"
  },
  weekends: true,
  weekNumbers: false,
  weekNumberCalculation: "local",
  editable: false,
  nowIndicator: false,
  scrollTime: "06:00:00",
  scrollTimeReset: true,
  slotMinTime: "00:00:00",
  slotMaxTime: "24:00:00",
  showNonCurrentDates: true,
  lazyFetching: true,
  startParam: "start",
  endParam: "end",
  timeZoneParam: "timeZone",
  timeZone: "local",
  locales: [],
  locale: "",
  themeSystem: "standard",
  dragRevertDuration: 500,
  dragScroll: true,
  allDayMaintainDuration: false,
  unselectAuto: true,
  dropAccept: "*",
  eventOrder: "start,-duration,allDay,title",
  dayPopoverFormat: { month: "long", day: "numeric", year: "numeric" },
  handleWindowResize: true,
  windowResizeDelay: 100,
  longPressDelay: 1e3,
  eventDragMinDistance: 5,
  expandRows: false,
  navLinks: false,
  selectable: false,
  eventMinHeight: 15,
  eventMinWidth: 30,
  eventShortHeight: 30,
  monthStartFormat: { month: "long", day: "numeric" }
};
var CALENDAR_LISTENER_REFINERS = {
  datesSet: identity,
  eventsSet: identity,
  eventAdd: identity,
  eventChange: identity,
  eventRemove: identity,
  windowResize: identity,
  eventClick: identity,
  eventMouseEnter: identity,
  eventMouseLeave: identity,
  select: identity,
  unselect: identity,
  loading: identity,
  // internal
  _unmount: identity,
  _beforeprint: identity,
  _afterprint: identity,
  _noEventDrop: identity,
  _noEventResize: identity,
  _resize: identity,
  _scrollRequest: identity
};
var CALENDAR_OPTION_REFINERS = {
  buttonText: identity,
  buttonHints: identity,
  views: identity,
  plugins: identity,
  initialEvents: identity,
  events: identity,
  eventSources: identity
};
var COMPLEX_OPTION_COMPARATORS = {
  headerToolbar: isMaybeObjectsEqual,
  footerToolbar: isMaybeObjectsEqual,
  buttonText: isMaybeObjectsEqual,
  buttonHints: isMaybeObjectsEqual,
  buttonIcons: isMaybeObjectsEqual,
  dateIncrement: isMaybeObjectsEqual,
  plugins: isMaybeArraysEqual,
  events: isMaybeArraysEqual,
  eventSources: isMaybeArraysEqual,
  ["resources"]: isMaybeArraysEqual
};
function isMaybeObjectsEqual(a3, b3) {
  if (typeof a3 === "object" && typeof b3 === "object" && a3 && b3) {
    return isPropsEqual(a3, b3);
  }
  return a3 === b3;
}
function isMaybeArraysEqual(a3, b3) {
  if (Array.isArray(a3) && Array.isArray(b3)) {
    return isArraysEqual(a3, b3);
  }
  return a3 === b3;
}
var VIEW_OPTION_REFINERS = {
  type: String,
  component: identity,
  buttonText: String,
  buttonTextKey: String,
  dateProfileGeneratorClass: identity,
  usesMinMaxTime: Boolean,
  classNames: identity,
  content: identity,
  didMount: identity,
  willUnmount: identity
};
function mergeRawOptions(optionSets) {
  return mergeProps(optionSets, COMPLEX_OPTION_COMPARATORS);
}
function refineProps(input, refiners) {
  let refined = {};
  let extra = {};
  for (let propName in refiners) {
    if (propName in input) {
      refined[propName] = refiners[propName](input[propName]);
    }
  }
  for (let propName in input) {
    if (!(propName in refiners)) {
      extra[propName] = input[propName];
    }
  }
  return { refined, extra };
}
function identity(raw) {
  return raw;
}
var { hasOwnProperty } = Object.prototype;
function mergeProps(propObjs, complexPropsMap) {
  let dest = {};
  if (complexPropsMap) {
    for (let name in complexPropsMap) {
      if (complexPropsMap[name] === isMaybeObjectsEqual) {
        let complexObjs = [];
        for (let i3 = propObjs.length - 1; i3 >= 0; i3 -= 1) {
          let val = propObjs[i3][name];
          if (typeof val === "object" && val) {
            complexObjs.unshift(val);
          } else if (val !== void 0) {
            dest[name] = val;
            break;
          }
        }
        if (complexObjs.length) {
          dest[name] = mergeProps(complexObjs);
        }
      }
    }
  }
  for (let i3 = propObjs.length - 1; i3 >= 0; i3 -= 1) {
    let props = propObjs[i3];
    for (let name in props) {
      if (!(name in dest)) {
        dest[name] = props[name];
      }
    }
  }
  return dest;
}
function filterHash(hash, func) {
  let filtered = {};
  for (let key in hash) {
    if (func(hash[key], key)) {
      filtered[key] = hash[key];
    }
  }
  return filtered;
}
function mapHash(hash, func) {
  let newHash = {};
  for (let key in hash) {
    newHash[key] = func(hash[key], key);
  }
  return newHash;
}
function arrayToHash(a3) {
  let hash = {};
  for (let item of a3) {
    hash[item] = true;
  }
  return hash;
}
function hashValuesToArray(obj) {
  let a3 = [];
  for (let key in obj) {
    a3.push(obj[key]);
  }
  return a3;
}
function isPropsEqual(obj0, obj1) {
  if (obj0 === obj1) {
    return true;
  }
  for (let key in obj0) {
    if (hasOwnProperty.call(obj0, key)) {
      if (!(key in obj1)) {
        return false;
      }
    }
  }
  for (let key in obj1) {
    if (hasOwnProperty.call(obj1, key)) {
      if (obj0[key] !== obj1[key]) {
        return false;
      }
    }
  }
  return true;
}
var HANDLER_RE = /^on[A-Z]/;
function isNonHandlerPropsEqual(obj0, obj1) {
  const keys = getUnequalProps(obj0, obj1);
  for (let key of keys) {
    if (!HANDLER_RE.test(key)) {
      return false;
    }
  }
  return true;
}
function getUnequalProps(obj0, obj1) {
  let keys = [];
  for (let key in obj0) {
    if (hasOwnProperty.call(obj0, key)) {
      if (!(key in obj1)) {
        keys.push(key);
      }
    }
  }
  for (let key in obj1) {
    if (hasOwnProperty.call(obj1, key)) {
      if (obj0[key] !== obj1[key]) {
        keys.push(key);
      }
    }
  }
  return keys;
}
function compareObjs(oldProps, newProps, equalityFuncs = {}) {
  if (oldProps === newProps) {
    return true;
  }
  for (let key in newProps) {
    if (key in oldProps && isObjValsEqual(oldProps[key], newProps[key], equalityFuncs[key]))
      ;
    else {
      return false;
    }
  }
  for (let key in oldProps) {
    if (!(key in newProps)) {
      return false;
    }
  }
  return true;
}
function isObjValsEqual(val0, val1, comparator) {
  if (val0 === val1 || comparator === true) {
    return true;
  }
  if (comparator) {
    return comparator(val0, val1);
  }
  return false;
}
function collectFromHash(hash, startIndex = 0, endIndex, step = 1) {
  let res = [];
  if (endIndex == null) {
    endIndex = Object.keys(hash).length;
  }
  for (let i3 = startIndex; i3 < endIndex; i3 += step) {
    let val = hash[i3];
    if (val !== void 0) {
      res.push(val);
    }
  }
  return res;
}
var calendarSystemClassMap = {};
function registerCalendarSystem(name, theClass) {
  calendarSystemClassMap[name] = theClass;
}
function createCalendarSystem(name) {
  return new calendarSystemClassMap[name]();
}
var GregorianCalendarSystem = class {
  getMarkerYear(d2) {
    return d2.getUTCFullYear();
  }
  getMarkerMonth(d2) {
    return d2.getUTCMonth();
  }
  getMarkerDay(d2) {
    return d2.getUTCDate();
  }
  arrayToMarker(arr) {
    return arrayToUtcDate(arr);
  }
  markerToArray(marker) {
    return dateToUtcArray(marker);
  }
};
registerCalendarSystem("gregory", GregorianCalendarSystem);
var ISO_RE = /^\s*(\d{4})(-?(\d{2})(-?(\d{2})([T ](\d{2}):?(\d{2})(:?(\d{2})(\.(\d+))?)?(Z|(([-+])(\d{2})(:?(\d{2}))?))?)?)?)?$/;
function parse(str) {
  let m3 = ISO_RE.exec(str);
  if (m3) {
    let marker = new Date(Date.UTC(Number(m3[1]), m3[3] ? Number(m3[3]) - 1 : 0, Number(m3[5] || 1), Number(m3[7] || 0), Number(m3[8] || 0), Number(m3[10] || 0), m3[12] ? Number(`0.${m3[12]}`) * 1e3 : 0));
    if (isValidDate(marker)) {
      let timeZoneOffset = null;
      if (m3[13]) {
        timeZoneOffset = (m3[15] === "-" ? -1 : 1) * (Number(m3[16] || 0) * 60 + Number(m3[18] || 0));
      }
      return {
        marker,
        isTimeUnspecified: !m3[6],
        timeZoneOffset
      };
    }
  }
  return null;
}
var DateEnv = class {
  constructor(settings) {
    let timeZone = this.timeZone = settings.timeZone;
    let isNamedTimeZone = timeZone !== "local" && timeZone !== "UTC";
    if (settings.namedTimeZoneImpl && isNamedTimeZone) {
      this.namedTimeZoneImpl = new settings.namedTimeZoneImpl(timeZone);
    }
    this.canComputeOffset = Boolean(!isNamedTimeZone || this.namedTimeZoneImpl);
    this.calendarSystem = createCalendarSystem(settings.calendarSystem);
    this.locale = settings.locale;
    this.weekDow = settings.locale.week.dow;
    this.weekDoy = settings.locale.week.doy;
    if (settings.weekNumberCalculation === "ISO") {
      this.weekDow = 1;
      this.weekDoy = 4;
    }
    if (typeof settings.firstDay === "number") {
      this.weekDow = settings.firstDay;
    }
    if (typeof settings.weekNumberCalculation === "function") {
      this.weekNumberFunc = settings.weekNumberCalculation;
    }
    this.weekText = settings.weekText != null ? settings.weekText : settings.locale.options.weekText;
    this.weekTextLong = (settings.weekTextLong != null ? settings.weekTextLong : settings.locale.options.weekTextLong) || this.weekText;
    this.cmdFormatter = settings.cmdFormatter;
    this.defaultSeparator = settings.defaultSeparator;
  }
  // Creating / Parsing
  createMarker(input) {
    let meta = this.createMarkerMeta(input);
    if (meta === null) {
      return null;
    }
    return meta.marker;
  }
  createNowMarker() {
    if (this.canComputeOffset) {
      return this.timestampToMarker(new Date().valueOf());
    }
    return arrayToUtcDate(dateToLocalArray(new Date()));
  }
  createMarkerMeta(input) {
    if (typeof input === "string") {
      return this.parse(input);
    }
    let marker = null;
    if (typeof input === "number") {
      marker = this.timestampToMarker(input);
    } else if (input instanceof Date) {
      input = input.valueOf();
      if (!isNaN(input)) {
        marker = this.timestampToMarker(input);
      }
    } else if (Array.isArray(input)) {
      marker = arrayToUtcDate(input);
    }
    if (marker === null || !isValidDate(marker)) {
      return null;
    }
    return { marker, isTimeUnspecified: false, forcedTzo: null };
  }
  parse(s3) {
    let parts = parse(s3);
    if (parts === null) {
      return null;
    }
    let { marker } = parts;
    let forcedTzo = null;
    if (parts.timeZoneOffset !== null) {
      if (this.canComputeOffset) {
        marker = this.timestampToMarker(marker.valueOf() - parts.timeZoneOffset * 60 * 1e3);
      } else {
        forcedTzo = parts.timeZoneOffset;
      }
    }
    return { marker, isTimeUnspecified: parts.isTimeUnspecified, forcedTzo };
  }
  // Accessors
  getYear(marker) {
    return this.calendarSystem.getMarkerYear(marker);
  }
  getMonth(marker) {
    return this.calendarSystem.getMarkerMonth(marker);
  }
  getDay(marker) {
    return this.calendarSystem.getMarkerDay(marker);
  }
  // Adding / Subtracting
  add(marker, dur) {
    let a3 = this.calendarSystem.markerToArray(marker);
    a3[0] += dur.years;
    a3[1] += dur.months;
    a3[2] += dur.days;
    a3[6] += dur.milliseconds;
    return this.calendarSystem.arrayToMarker(a3);
  }
  subtract(marker, dur) {
    let a3 = this.calendarSystem.markerToArray(marker);
    a3[0] -= dur.years;
    a3[1] -= dur.months;
    a3[2] -= dur.days;
    a3[6] -= dur.milliseconds;
    return this.calendarSystem.arrayToMarker(a3);
  }
  addYears(marker, n2) {
    let a3 = this.calendarSystem.markerToArray(marker);
    a3[0] += n2;
    return this.calendarSystem.arrayToMarker(a3);
  }
  addMonths(marker, n2) {
    let a3 = this.calendarSystem.markerToArray(marker);
    a3[1] += n2;
    return this.calendarSystem.arrayToMarker(a3);
  }
  // Diffing Whole Units
  diffWholeYears(m0, m1) {
    let { calendarSystem } = this;
    if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1) && calendarSystem.getMarkerMonth(m0) === calendarSystem.getMarkerMonth(m1)) {
      return calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0);
    }
    return null;
  }
  diffWholeMonths(m0, m1) {
    let { calendarSystem } = this;
    if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1)) {
      return calendarSystem.getMarkerMonth(m1) - calendarSystem.getMarkerMonth(m0) + (calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0)) * 12;
    }
    return null;
  }
  // Range / Duration
  greatestWholeUnit(m0, m1) {
    let n2 = this.diffWholeYears(m0, m1);
    if (n2 !== null) {
      return { unit: "year", value: n2 };
    }
    n2 = this.diffWholeMonths(m0, m1);
    if (n2 !== null) {
      return { unit: "month", value: n2 };
    }
    n2 = diffWholeWeeks(m0, m1);
    if (n2 !== null) {
      return { unit: "week", value: n2 };
    }
    n2 = diffWholeDays(m0, m1);
    if (n2 !== null) {
      return { unit: "day", value: n2 };
    }
    n2 = diffHours(m0, m1);
    if (isInt(n2)) {
      return { unit: "hour", value: n2 };
    }
    n2 = diffMinutes(m0, m1);
    if (isInt(n2)) {
      return { unit: "minute", value: n2 };
    }
    n2 = diffSeconds(m0, m1);
    if (isInt(n2)) {
      return { unit: "second", value: n2 };
    }
    return { unit: "millisecond", value: m1.valueOf() - m0.valueOf() };
  }
  countDurationsBetween(m0, m1, d2) {
    let diff;
    if (d2.years) {
      diff = this.diffWholeYears(m0, m1);
      if (diff !== null) {
        return diff / asRoughYears(d2);
      }
    }
    if (d2.months) {
      diff = this.diffWholeMonths(m0, m1);
      if (diff !== null) {
        return diff / asRoughMonths(d2);
      }
    }
    if (d2.days) {
      diff = diffWholeDays(m0, m1);
      if (diff !== null) {
        return diff / asRoughDays(d2);
      }
    }
    return (m1.valueOf() - m0.valueOf()) / asRoughMs(d2);
  }
  // Start-Of
  // these DON'T return zoned-dates. only UTC start-of dates
  startOf(m3, unit) {
    if (unit === "year") {
      return this.startOfYear(m3);
    }
    if (unit === "month") {
      return this.startOfMonth(m3);
    }
    if (unit === "week") {
      return this.startOfWeek(m3);
    }
    if (unit === "day") {
      return startOfDay(m3);
    }
    if (unit === "hour") {
      return startOfHour(m3);
    }
    if (unit === "minute") {
      return startOfMinute(m3);
    }
    if (unit === "second") {
      return startOfSecond(m3);
    }
    return null;
  }
  startOfYear(m3) {
    return this.calendarSystem.arrayToMarker([
      this.calendarSystem.getMarkerYear(m3)
    ]);
  }
  startOfMonth(m3) {
    return this.calendarSystem.arrayToMarker([
      this.calendarSystem.getMarkerYear(m3),
      this.calendarSystem.getMarkerMonth(m3)
    ]);
  }
  startOfWeek(m3) {
    return this.calendarSystem.arrayToMarker([
      this.calendarSystem.getMarkerYear(m3),
      this.calendarSystem.getMarkerMonth(m3),
      m3.getUTCDate() - (m3.getUTCDay() - this.weekDow + 7) % 7
    ]);
  }
  // Week Number
  computeWeekNumber(marker) {
    if (this.weekNumberFunc) {
      return this.weekNumberFunc(this.toDate(marker));
    }
    return weekOfYear(marker, this.weekDow, this.weekDoy);
  }
  // TODO: choke on timeZoneName: long
  format(marker, formatter, dateOptions = {}) {
    return formatter.format({
      marker,
      timeZoneOffset: dateOptions.forcedTzo != null ? dateOptions.forcedTzo : this.offsetForMarker(marker)
    }, this);
  }
  formatRange(start, end, formatter, dateOptions = {}) {
    if (dateOptions.isEndExclusive) {
      end = addMs(end, -1);
    }
    return formatter.formatRange({
      marker: start,
      timeZoneOffset: dateOptions.forcedStartTzo != null ? dateOptions.forcedStartTzo : this.offsetForMarker(start)
    }, {
      marker: end,
      timeZoneOffset: dateOptions.forcedEndTzo != null ? dateOptions.forcedEndTzo : this.offsetForMarker(end)
    }, this, dateOptions.defaultSeparator);
  }
  /*
  DUMB: the omitTime arg is dumb. if we omit the time, we want to omit the timezone offset. and if we do that,
  might as well use buildIsoString or some other util directly
  */
  formatIso(marker, extraOptions = {}) {
    let timeZoneOffset = null;
    if (!extraOptions.omitTimeZoneOffset) {
      if (extraOptions.forcedTzo != null) {
        timeZoneOffset = extraOptions.forcedTzo;
      } else {
        timeZoneOffset = this.offsetForMarker(marker);
      }
    }
    return buildIsoString(marker, timeZoneOffset, extraOptions.omitTime);
  }
  // TimeZone
  timestampToMarker(ms) {
    if (this.timeZone === "local") {
      return arrayToUtcDate(dateToLocalArray(new Date(ms)));
    }
    if (this.timeZone === "UTC" || !this.namedTimeZoneImpl) {
      return new Date(ms);
    }
    return arrayToUtcDate(this.namedTimeZoneImpl.timestampToArray(ms));
  }
  offsetForMarker(m3) {
    if (this.timeZone === "local") {
      return -arrayToLocalDate(dateToUtcArray(m3)).getTimezoneOffset();
    }
    if (this.timeZone === "UTC") {
      return 0;
    }
    if (this.namedTimeZoneImpl) {
      return this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m3));
    }
    return null;
  }
  // Conversion
  toDate(m3, forcedTzo) {
    if (this.timeZone === "local") {
      return arrayToLocalDate(dateToUtcArray(m3));
    }
    if (this.timeZone === "UTC") {
      return new Date(m3.valueOf());
    }
    if (!this.namedTimeZoneImpl) {
      return new Date(m3.valueOf() - (forcedTzo || 0));
    }
    return new Date(m3.valueOf() - this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m3)) * 1e3 * 60);
  }
};
var Theme = class {
  constructor(calendarOptions) {
    if (this.iconOverrideOption) {
      this.setIconOverride(calendarOptions[this.iconOverrideOption]);
    }
  }
  setIconOverride(iconOverrideHash) {
    let iconClassesCopy;
    let buttonName;
    if (typeof iconOverrideHash === "object" && iconOverrideHash) {
      iconClassesCopy = Object.assign({}, this.iconClasses);
      for (buttonName in iconOverrideHash) {
        iconClassesCopy[buttonName] = this.applyIconOverridePrefix(iconOverrideHash[buttonName]);
      }
      this.iconClasses = iconClassesCopy;
    } else if (iconOverrideHash === false) {
      this.iconClasses = {};
    }
  }
  applyIconOverridePrefix(className) {
    let prefix = this.iconOverridePrefix;
    if (prefix && className.indexOf(prefix) !== 0) {
      className = prefix + className;
    }
    return className;
  }
  getClass(key) {
    return this.classes[key] || "";
  }
  getIconClass(buttonName, isRtl) {
    let className;
    if (isRtl && this.rtlIconClasses) {
      className = this.rtlIconClasses[buttonName] || this.iconClasses[buttonName];
    } else {
      className = this.iconClasses[buttonName];
    }
    if (className) {
      return `${this.baseIconClass} ${className}`;
    }
    return "";
  }
  getCustomButtonIconClass(customButtonProps) {
    let className;
    if (this.iconOverrideCustomButtonOption) {
      className = customButtonProps[this.iconOverrideCustomButtonOption];
      if (className) {
        return `${this.baseIconClass} ${this.applyIconOverridePrefix(className)}`;
      }
    }
    return "";
  }
};
Theme.prototype.classes = {};
Theme.prototype.iconClasses = {};
Theme.prototype.baseIconClass = "";
Theme.prototype.iconOverridePrefix = "";
function flushSync(runBeforeFlush) {
  runBeforeFlush();
  let oldDebounceRendering = l.debounceRendering;
  let callbackQ = [];
  function execCallbackSync(callback) {
    callbackQ.push(callback);
  }
  l.debounceRendering = execCallbackSync;
  D(y(FakeComponent, {}), document.createElement("div"));
  while (callbackQ.length) {
    callbackQ.shift()();
  }
  l.debounceRendering = oldDebounceRendering;
}
var FakeComponent = class extends x {
  render() {
    return y("div", {});
  }
  componentDidMount() {
    this.setState({});
  }
};
function createContext(defaultValue) {
  let ContextType = G(defaultValue);
  let origProvider = ContextType.Provider;
  ContextType.Provider = function() {
    let isNew = !this.getChildContext;
    let children = origProvider.apply(this, arguments);
    if (isNew) {
      let subs = [];
      this.shouldComponentUpdate = (_props) => {
        if (this.props.value !== _props.value) {
          subs.forEach((c3) => {
            c3.context = _props.value;
            c3.forceUpdate();
          });
        }
      };
      this.sub = (c3) => {
        subs.push(c3);
        let old = c3.componentWillUnmount;
        c3.componentWillUnmount = () => {
          subs.splice(subs.indexOf(c3), 1);
          old && old.call(c3);
        };
      };
    }
    return children;
  };
  return ContextType;
}
var ScrollResponder = class {
  constructor(execFunc, emitter, scrollTime, scrollTimeReset) {
    this.execFunc = execFunc;
    this.emitter = emitter;
    this.scrollTime = scrollTime;
    this.scrollTimeReset = scrollTimeReset;
    this.handleScrollRequest = (request) => {
      this.queuedRequest = Object.assign({}, this.queuedRequest || {}, request);
      this.drain();
    };
    emitter.on("_scrollRequest", this.handleScrollRequest);
    this.fireInitialScroll();
  }
  detach() {
    this.emitter.off("_scrollRequest", this.handleScrollRequest);
  }
  update(isDatesNew) {
    if (isDatesNew && this.scrollTimeReset) {
      this.fireInitialScroll();
    } else {
      this.drain();
    }
  }
  fireInitialScroll() {
    this.handleScrollRequest({
      time: this.scrollTime
    });
  }
  drain() {
    if (this.queuedRequest && this.execFunc(this.queuedRequest)) {
      this.queuedRequest = null;
    }
  }
};
var ViewContextType = createContext({});
function buildViewContext(viewSpec, viewApi, viewOptions, dateProfileGenerator, dateEnv, theme, pluginHooks, dispatch, getCurrentData, emitter, calendarApi, registerInteractiveComponent, unregisterInteractiveComponent) {
  return {
    dateEnv,
    options: viewOptions,
    pluginHooks,
    emitter,
    dispatch,
    getCurrentData,
    calendarApi,
    viewSpec,
    viewApi,
    dateProfileGenerator,
    theme,
    isRtl: viewOptions.direction === "rtl",
    addResizeHandler(handler) {
      emitter.on("_resize", handler);
    },
    removeResizeHandler(handler) {
      emitter.off("_resize", handler);
    },
    createScrollResponder(execFunc) {
      return new ScrollResponder(execFunc, emitter, createDuration(viewOptions.scrollTime), viewOptions.scrollTimeReset);
    },
    registerInteractiveComponent,
    unregisterInteractiveComponent
  };
}
var PureComponent = class extends x {
  shouldComponentUpdate(nextProps, nextState) {
    if (this.debug) {
      console.log(getUnequalProps(nextProps, this.props), getUnequalProps(nextState, this.state));
    }
    return !compareObjs(this.props, nextProps, this.propEquality) || !compareObjs(this.state, nextState, this.stateEquality);
  }
  // HACK for freakin' React StrictMode
  safeSetState(newState) {
    if (!compareObjs(this.state, Object.assign(Object.assign({}, this.state), newState), this.stateEquality)) {
      this.setState(newState);
    }
  }
};
PureComponent.addPropsEquality = addPropsEquality;
PureComponent.addStateEquality = addStateEquality;
PureComponent.contextType = ViewContextType;
PureComponent.prototype.propEquality = {};
PureComponent.prototype.stateEquality = {};
var BaseComponent = class extends PureComponent {
};
BaseComponent.contextType = ViewContextType;
function addPropsEquality(propEquality) {
  let hash = Object.create(this.prototype.propEquality);
  Object.assign(hash, propEquality);
  this.prototype.propEquality = hash;
}
function addStateEquality(stateEquality) {
  let hash = Object.create(this.prototype.stateEquality);
  Object.assign(hash, stateEquality);
  this.prototype.stateEquality = hash;
}
function setRef(ref, current) {
  if (typeof ref === "function") {
    ref(current);
  } else if (ref) {
    ref.current = current;
  }
}
var ContentInjector = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.id = guid();
    this.queuedDomNodes = [];
    this.currentDomNodes = [];
    this.handleEl = (el) => {
      const { options } = this.context;
      const { generatorName } = this.props;
      if (!options.customRenderingReplaces || !hasCustomRenderingHandler(generatorName, options)) {
        this.updateElRef(el);
      }
    };
    this.updateElRef = (el) => {
      if (this.props.elRef) {
        setRef(this.props.elRef, el);
      }
    };
  }
  render() {
    const { props, context } = this;
    const { options } = context;
    const { customGenerator, defaultGenerator, renderProps } = props;
    const attrs = buildElAttrs(props, [], this.handleEl);
    let useDefault = false;
    let innerContent;
    let queuedDomNodes = [];
    let currentGeneratorMeta;
    if (customGenerator != null) {
      const customGeneratorRes = typeof customGenerator === "function" ? customGenerator(renderProps, y) : customGenerator;
      if (customGeneratorRes === true) {
        useDefault = true;
      } else {
        const isObject2 = customGeneratorRes && typeof customGeneratorRes === "object";
        if (isObject2 && "html" in customGeneratorRes) {
          attrs.dangerouslySetInnerHTML = { __html: customGeneratorRes.html };
        } else if (isObject2 && "domNodes" in customGeneratorRes) {
          queuedDomNodes = Array.prototype.slice.call(customGeneratorRes.domNodes);
        } else if (isObject2 ? i(customGeneratorRes) : typeof customGeneratorRes !== "function") {
          innerContent = customGeneratorRes;
        } else {
          currentGeneratorMeta = customGeneratorRes;
        }
      }
    } else {
      useDefault = !hasCustomRenderingHandler(props.generatorName, options);
    }
    if (useDefault && defaultGenerator) {
      innerContent = defaultGenerator(renderProps);
    }
    this.queuedDomNodes = queuedDomNodes;
    this.currentGeneratorMeta = currentGeneratorMeta;
    return y(props.elTag, attrs, innerContent);
  }
  componentDidMount() {
    this.applyQueueudDomNodes();
    this.triggerCustomRendering(true);
  }
  componentDidUpdate() {
    this.applyQueueudDomNodes();
    this.triggerCustomRendering(true);
  }
  componentWillUnmount() {
    this.triggerCustomRendering(false);
  }
  triggerCustomRendering(isActive) {
    var _a;
    const { props, context } = this;
    const { handleCustomRendering, customRenderingMetaMap } = context.options;
    if (handleCustomRendering) {
      const generatorMeta = (_a = this.currentGeneratorMeta) !== null && _a !== void 0 ? _a : customRenderingMetaMap === null || customRenderingMetaMap === void 0 ? void 0 : customRenderingMetaMap[props.generatorName];
      if (generatorMeta) {
        handleCustomRendering(Object.assign(Object.assign({
          id: this.id,
          isActive,
          containerEl: this.base,
          reportNewContainerEl: this.updateElRef,
          // front-end framework tells us about new container els
          generatorMeta
        }, props), { elClasses: (props.elClasses || []).filter(isTruthy) }));
      }
    }
  }
  applyQueueudDomNodes() {
    const { queuedDomNodes, currentDomNodes } = this;
    const el = this.base;
    if (!isArraysEqual(queuedDomNodes, currentDomNodes)) {
      currentDomNodes.forEach(removeElement);
      for (let newNode of queuedDomNodes) {
        el.appendChild(newNode);
      }
      this.currentDomNodes = queuedDomNodes;
    }
  }
};
ContentInjector.addPropsEquality({
  elClasses: isArraysEqual,
  elStyle: isPropsEqual,
  elAttrs: isNonHandlerPropsEqual,
  renderProps: isPropsEqual
});
function hasCustomRenderingHandler(generatorName, options) {
  var _a;
  return Boolean(options.handleCustomRendering && generatorName && ((_a = options.customRenderingMetaMap) === null || _a === void 0 ? void 0 : _a[generatorName]));
}
function buildElAttrs(props, extraClassNames, elRef) {
  const attrs = Object.assign(Object.assign({}, props.elAttrs), { ref: elRef });
  if (props.elClasses || extraClassNames) {
    attrs.className = (props.elClasses || []).concat(extraClassNames || []).concat(attrs.className || []).filter(Boolean).join(" ");
  }
  if (props.elStyle) {
    attrs.style = props.elStyle;
  }
  return attrs;
}
function isTruthy(val) {
  return Boolean(val);
}
var RenderId = createContext(0);
var ContentContainer = class extends x {
  constructor() {
    super(...arguments);
    this.InnerContent = InnerContentInjector.bind(void 0, this);
    this.handleEl = (el) => {
      this.el = el;
      if (this.props.elRef) {
        setRef(this.props.elRef, el);
        if (el && this.didMountMisfire) {
          this.componentDidMount();
        }
      }
    };
  }
  render() {
    const { props } = this;
    const generatedClassNames = generateClassNames(props.classNameGenerator, props.renderProps);
    if (props.children) {
      const elAttrs = buildElAttrs(props, generatedClassNames, this.handleEl);
      const children = props.children(this.InnerContent, props.renderProps, elAttrs);
      if (props.elTag) {
        return y(props.elTag, elAttrs, children);
      } else {
        return children;
      }
    } else {
      return y(ContentInjector, Object.assign(Object.assign({}, props), { elRef: this.handleEl, elTag: props.elTag || "div", elClasses: (props.elClasses || []).concat(generatedClassNames), renderId: this.context }));
    }
  }
  componentDidMount() {
    var _a, _b;
    if (this.el) {
      (_b = (_a = this.props).didMount) === null || _b === void 0 ? void 0 : _b.call(_a, Object.assign(Object.assign({}, this.props.renderProps), { el: this.el }));
    } else {
      this.didMountMisfire = true;
    }
  }
  componentWillUnmount() {
    var _a, _b;
    (_b = (_a = this.props).willUnmount) === null || _b === void 0 ? void 0 : _b.call(_a, Object.assign(Object.assign({}, this.props.renderProps), { el: this.el }));
  }
};
ContentContainer.contextType = RenderId;
function InnerContentInjector(containerComponent, props) {
  const parentProps = containerComponent.props;
  return y(ContentInjector, Object.assign({ renderProps: parentProps.renderProps, generatorName: parentProps.generatorName, customGenerator: parentProps.customGenerator, defaultGenerator: parentProps.defaultGenerator, renderId: containerComponent.context }, props));
}
function generateClassNames(classNameGenerator, renderProps) {
  const classNames = typeof classNameGenerator === "function" ? classNameGenerator(renderProps) : classNameGenerator || [];
  return typeof classNames === "string" ? [classNames] : classNames;
}
var ViewContainer = class extends BaseComponent {
  render() {
    let { props, context } = this;
    let { options } = context;
    let renderProps = { view: context.viewApi };
    return y(ContentContainer, Object.assign({}, props, { elTag: props.elTag || "div", elClasses: [
      ...buildViewClassNames(props.viewSpec),
      ...props.elClasses || []
    ], renderProps, classNameGenerator: options.viewClassNames, generatorName: void 0, didMount: options.viewDidMount, willUnmount: options.viewWillUnmount }), () => props.children);
  }
};
function buildViewClassNames(viewSpec) {
  return [
    `fc-${viewSpec.type}-view`,
    "fc-view"
  ];
}
function parseRange(input, dateEnv) {
  let start = null;
  let end = null;
  if (input.start) {
    start = dateEnv.createMarker(input.start);
  }
  if (input.end) {
    end = dateEnv.createMarker(input.end);
  }
  if (!start && !end) {
    return null;
  }
  if (start && end && end < start) {
    return null;
  }
  return { start, end };
}
function invertRanges(ranges, constraintRange) {
  let invertedRanges = [];
  let { start } = constraintRange;
  let i3;
  let dateRange;
  ranges.sort(compareRanges);
  for (i3 = 0; i3 < ranges.length; i3 += 1) {
    dateRange = ranges[i3];
    if (dateRange.start > start) {
      invertedRanges.push({ start, end: dateRange.start });
    }
    if (dateRange.end > start) {
      start = dateRange.end;
    }
  }
  if (start < constraintRange.end) {
    invertedRanges.push({ start, end: constraintRange.end });
  }
  return invertedRanges;
}
function compareRanges(range0, range1) {
  return range0.start.valueOf() - range1.start.valueOf();
}
function intersectRanges(range0, range1) {
  let { start, end } = range0;
  let newRange = null;
  if (range1.start !== null) {
    if (start === null) {
      start = range1.start;
    } else {
      start = new Date(Math.max(start.valueOf(), range1.start.valueOf()));
    }
  }
  if (range1.end != null) {
    if (end === null) {
      end = range1.end;
    } else {
      end = new Date(Math.min(end.valueOf(), range1.end.valueOf()));
    }
  }
  if (start === null || end === null || start < end) {
    newRange = { start, end };
  }
  return newRange;
}
function rangesEqual(range0, range1) {
  return (range0.start === null ? null : range0.start.valueOf()) === (range1.start === null ? null : range1.start.valueOf()) && (range0.end === null ? null : range0.end.valueOf()) === (range1.end === null ? null : range1.end.valueOf());
}
function rangesIntersect(range0, range1) {
  return (range0.end === null || range1.start === null || range0.end > range1.start) && (range0.start === null || range1.end === null || range0.start < range1.end);
}
function rangeContainsRange(outerRange, innerRange) {
  return (outerRange.start === null || innerRange.start !== null && innerRange.start >= outerRange.start) && (outerRange.end === null || innerRange.end !== null && innerRange.end <= outerRange.end);
}
function rangeContainsMarker(range2, date) {
  return (range2.start === null || date >= range2.start) && (range2.end === null || date < range2.end);
}
function constrainMarkerToRange(date, range2) {
  if (range2.start != null && date < range2.start) {
    return range2.start;
  }
  if (range2.end != null && date >= range2.end) {
    return new Date(range2.end.valueOf() - 1);
  }
  return date;
}
function computeAlignedDayRange(timedRange) {
  let dayCnt = Math.floor(diffDays(timedRange.start, timedRange.end)) || 1;
  let start = startOfDay(timedRange.start);
  let end = addDays(start, dayCnt);
  return { start, end };
}
function computeVisibleDayRange(timedRange, nextDayThreshold = createDuration(0)) {
  let startDay = null;
  let endDay = null;
  if (timedRange.end) {
    endDay = startOfDay(timedRange.end);
    let endTimeMS = timedRange.end.valueOf() - endDay.valueOf();
    if (endTimeMS && endTimeMS >= asRoughMs(nextDayThreshold)) {
      endDay = addDays(endDay, 1);
    }
  }
  if (timedRange.start) {
    startDay = startOfDay(timedRange.start);
    if (endDay && endDay <= startDay) {
      endDay = addDays(startDay, 1);
    }
  }
  return { start: startDay, end: endDay };
}
function isMultiDayRange(range2) {
  let visibleRange = computeVisibleDayRange(range2);
  return diffDays(visibleRange.start, visibleRange.end) > 1;
}
function diffDates(date0, date1, dateEnv, largeUnit) {
  if (largeUnit === "year") {
    return createDuration(dateEnv.diffWholeYears(date0, date1), "year");
  }
  if (largeUnit === "month") {
    return createDuration(dateEnv.diffWholeMonths(date0, date1), "month");
  }
  return diffDayAndTime(date0, date1);
}
function reduceCurrentDate(currentDate, action) {
  switch (action.type) {
    case "CHANGE_DATE":
      return action.dateMarker;
    default:
      return currentDate;
  }
}
function getInitialDate(options, dateEnv) {
  let initialDateInput = options.initialDate;
  if (initialDateInput != null) {
    return dateEnv.createMarker(initialDateInput);
  }
  return getNow(options.now, dateEnv);
}
function getNow(nowInput, dateEnv) {
  if (typeof nowInput === "function") {
    nowInput = nowInput();
  }
  if (nowInput == null) {
    return dateEnv.createNowMarker();
  }
  return dateEnv.createMarker(nowInput);
}
var DateProfileGenerator = class {
  constructor(props) {
    this.props = props;
    this.nowDate = getNow(props.nowInput, props.dateEnv);
    this.initHiddenDays();
  }
  /* Date Range Computation
  ------------------------------------------------------------------------------------------------------------------*/
  // Builds a structure with info about what the dates/ranges will be for the "prev" view.
  buildPrev(currentDateProfile, currentDate, forceToValid) {
    let { dateEnv } = this.props;
    let prevDate = dateEnv.subtract(
      dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit),
      // important for start-of-month
      currentDateProfile.dateIncrement
    );
    return this.build(prevDate, -1, forceToValid);
  }
  // Builds a structure with info about what the dates/ranges will be for the "next" view.
  buildNext(currentDateProfile, currentDate, forceToValid) {
    let { dateEnv } = this.props;
    let nextDate = dateEnv.add(
      dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit),
      // important for start-of-month
      currentDateProfile.dateIncrement
    );
    return this.build(nextDate, 1, forceToValid);
  }
  // Builds a structure holding dates/ranges for rendering around the given date.
  // Optional direction param indicates whether the date is being incremented/decremented
  // from its previous value. decremented = -1, incremented = 1 (default).
  build(currentDate, direction, forceToValid = true) {
    let { props } = this;
    let validRange;
    let currentInfo;
    let isRangeAllDay;
    let renderRange;
    let activeRange;
    let isValid;
    validRange = this.buildValidRange();
    validRange = this.trimHiddenDays(validRange);
    if (forceToValid) {
      currentDate = constrainMarkerToRange(currentDate, validRange);
    }
    currentInfo = this.buildCurrentRangeInfo(currentDate, direction);
    isRangeAllDay = /^(year|month|week|day)$/.test(currentInfo.unit);
    renderRange = this.buildRenderRange(this.trimHiddenDays(currentInfo.range), currentInfo.unit, isRangeAllDay);
    renderRange = this.trimHiddenDays(renderRange);
    activeRange = renderRange;
    if (!props.showNonCurrentDates) {
      activeRange = intersectRanges(activeRange, currentInfo.range);
    }
    activeRange = this.adjustActiveRange(activeRange);
    activeRange = intersectRanges(activeRange, validRange);
    isValid = rangesIntersect(currentInfo.range, validRange);
    if (!rangeContainsMarker(renderRange, currentDate)) {
      currentDate = renderRange.start;
    }
    return {
      currentDate,
      // constraint for where prev/next operations can go and where events can be dragged/resized to.
      // an object with optional start and end properties.
      validRange,
      // range the view is formally responsible for.
      // for example, a month view might have 1st-31st, excluding padded dates
      currentRange: currentInfo.range,
      // name of largest unit being displayed, like "month" or "week"
      currentRangeUnit: currentInfo.unit,
      isRangeAllDay,
      // dates that display events and accept drag-n-drop
      // will be `null` if no dates accept events
      activeRange,
      // date range with a rendered skeleton
      // includes not-active days that need some sort of DOM
      renderRange,
      // Duration object that denotes the first visible time of any given day
      slotMinTime: props.slotMinTime,
      // Duration object that denotes the exclusive visible end time of any given day
      slotMaxTime: props.slotMaxTime,
      isValid,
      // how far the current date will move for a prev/next operation
      dateIncrement: this.buildDateIncrement(currentInfo.duration)
      // pass a fallback (might be null) ^
    };
  }
  // Builds an object with optional start/end properties.
  // Indicates the minimum/maximum dates to display.
  // not responsible for trimming hidden days.
  buildValidRange() {
    let input = this.props.validRangeInput;
    let simpleInput = typeof input === "function" ? input.call(this.props.calendarApi, this.nowDate) : input;
    return this.refineRange(simpleInput) || { start: null, end: null };
  }
  // Builds a structure with info about the "current" range, the range that is
  // highlighted as being the current month for example.
  // See build() for a description of `direction`.
  // Guaranteed to have `range` and `unit` properties. `duration` is optional.
  buildCurrentRangeInfo(date, direction) {
    let { props } = this;
    let duration = null;
    let unit = null;
    let range2 = null;
    let dayCount;
    if (props.duration) {
      duration = props.duration;
      unit = props.durationUnit;
      range2 = this.buildRangeFromDuration(date, direction, duration, unit);
    } else if (dayCount = this.props.dayCount) {
      unit = "day";
      range2 = this.buildRangeFromDayCount(date, direction, dayCount);
    } else if (range2 = this.buildCustomVisibleRange(date)) {
      unit = props.dateEnv.greatestWholeUnit(range2.start, range2.end).unit;
    } else {
      duration = this.getFallbackDuration();
      unit = greatestDurationDenominator(duration).unit;
      range2 = this.buildRangeFromDuration(date, direction, duration, unit);
    }
    return { duration, unit, range: range2 };
  }
  getFallbackDuration() {
    return createDuration({ day: 1 });
  }
  // Returns a new activeRange to have time values (un-ambiguate)
  // slotMinTime or slotMaxTime causes the range to expand.
  adjustActiveRange(range2) {
    let { dateEnv, usesMinMaxTime, slotMinTime, slotMaxTime } = this.props;
    let { start, end } = range2;
    if (usesMinMaxTime) {
      if (asRoughDays(slotMinTime) < 0) {
        start = startOfDay(start);
        start = dateEnv.add(start, slotMinTime);
      }
      if (asRoughDays(slotMaxTime) > 1) {
        end = startOfDay(end);
        end = addDays(end, -1);
        end = dateEnv.add(end, slotMaxTime);
      }
    }
    return { start, end };
  }
  // Builds the "current" range when it is specified as an explicit duration.
  // `unit` is the already-computed greatestDurationDenominator unit of duration.
  buildRangeFromDuration(date, direction, duration, unit) {
    let { dateEnv, dateAlignment } = this.props;
    let start;
    let end;
    let res;
    if (!dateAlignment) {
      let { dateIncrement } = this.props;
      if (dateIncrement) {
        if (asRoughMs(dateIncrement) < asRoughMs(duration)) {
          dateAlignment = greatestDurationDenominator(dateIncrement).unit;
        } else {
          dateAlignment = unit;
        }
      } else {
        dateAlignment = unit;
      }
    }
    if (asRoughDays(duration) <= 1) {
      if (this.isHiddenDay(start)) {
        start = this.skipHiddenDays(start, direction);
        start = startOfDay(start);
      }
    }
    function computeRes() {
      start = dateEnv.startOf(date, dateAlignment);
      end = dateEnv.add(start, duration);
      res = { start, end };
    }
    computeRes();
    if (!this.trimHiddenDays(res)) {
      date = this.skipHiddenDays(date, direction);
      computeRes();
    }
    return res;
  }
  // Builds the "current" range when a dayCount is specified.
  buildRangeFromDayCount(date, direction, dayCount) {
    let { dateEnv, dateAlignment } = this.props;
    let runningCount = 0;
    let start = date;
    let end;
    if (dateAlignment) {
      start = dateEnv.startOf(start, dateAlignment);
    }
    start = startOfDay(start);
    start = this.skipHiddenDays(start, direction);
    end = start;
    do {
      end = addDays(end, 1);
      if (!this.isHiddenDay(end)) {
        runningCount += 1;
      }
    } while (runningCount < dayCount);
    return { start, end };
  }
  // Builds a normalized range object for the "visible" range,
  // which is a way to define the currentRange and activeRange at the same time.
  buildCustomVisibleRange(date) {
    let { props } = this;
    let input = props.visibleRangeInput;
    let simpleInput = typeof input === "function" ? input.call(props.calendarApi, props.dateEnv.toDate(date)) : input;
    let range2 = this.refineRange(simpleInput);
    if (range2 && (range2.start == null || range2.end == null)) {
      return null;
    }
    return range2;
  }
  // Computes the range that will represent the element/cells for *rendering*,
  // but which may have voided days/times.
  // not responsible for trimming hidden days.
  buildRenderRange(currentRange, currentRangeUnit, isRangeAllDay) {
    return currentRange;
  }
  // Compute the duration value that should be added/substracted to the current date
  // when a prev/next operation happens.
  buildDateIncrement(fallback) {
    let { dateIncrement } = this.props;
    let customAlignment;
    if (dateIncrement) {
      return dateIncrement;
    }
    if (customAlignment = this.props.dateAlignment) {
      return createDuration(1, customAlignment);
    }
    if (fallback) {
      return fallback;
    }
    return createDuration({ days: 1 });
  }
  refineRange(rangeInput) {
    if (rangeInput) {
      let range2 = parseRange(rangeInput, this.props.dateEnv);
      if (range2) {
        range2 = computeVisibleDayRange(range2);
      }
      return range2;
    }
    return null;
  }
  /* Hidden Days
  ------------------------------------------------------------------------------------------------------------------*/
  // Initializes internal variables related to calculating hidden days-of-week
  initHiddenDays() {
    let hiddenDays = this.props.hiddenDays || [];
    let isHiddenDayHash = [];
    let dayCnt = 0;
    let i3;
    if (this.props.weekends === false) {
      hiddenDays.push(0, 6);
    }
    for (i3 = 0; i3 < 7; i3 += 1) {
      if (!(isHiddenDayHash[i3] = hiddenDays.indexOf(i3) !== -1)) {
        dayCnt += 1;
      }
    }
    if (!dayCnt) {
      throw new Error("invalid hiddenDays");
    }
    this.isHiddenDayHash = isHiddenDayHash;
  }
  // Remove days from the beginning and end of the range that are computed as hidden.
  // If the whole range is trimmed off, returns null
  trimHiddenDays(range2) {
    let { start, end } = range2;
    if (start) {
      start = this.skipHiddenDays(start);
    }
    if (end) {
      end = this.skipHiddenDays(end, -1, true);
    }
    if (start == null || end == null || start < end) {
      return { start, end };
    }
    return null;
  }
  // Is the current day hidden?
  // `day` is a day-of-week index (0-6), or a Date (used for UTC)
  isHiddenDay(day) {
    if (day instanceof Date) {
      day = day.getUTCDay();
    }
    return this.isHiddenDayHash[day];
  }
  // Incrementing the current day until it is no longer a hidden day, returning a copy.
  // DOES NOT CONSIDER validRange!
  // If the initial value of `date` is not a hidden day, don't do anything.
  // Pass `isExclusive` as `true` if you are dealing with an end date.
  // `inc` defaults to `1` (increment one day forward each time)
  skipHiddenDays(date, inc = 1, isExclusive = false) {
    while (this.isHiddenDayHash[(date.getUTCDay() + (isExclusive ? inc : 0) + 7) % 7]) {
      date = addDays(date, inc);
    }
    return date;
  }
};
function createEventInstance(defId, range2, forcedStartTzo, forcedEndTzo) {
  return {
    instanceId: guid(),
    defId,
    range: range2,
    forcedStartTzo: forcedStartTzo == null ? null : forcedStartTzo,
    forcedEndTzo: forcedEndTzo == null ? null : forcedEndTzo
  };
}
function parseRecurring(refined, defaultAllDay, dateEnv, recurringTypes) {
  for (let i3 = 0; i3 < recurringTypes.length; i3 += 1) {
    let parsed = recurringTypes[i3].parse(refined, dateEnv);
    if (parsed) {
      let { allDay } = refined;
      if (allDay == null) {
        allDay = defaultAllDay;
        if (allDay == null) {
          allDay = parsed.allDayGuess;
          if (allDay == null) {
            allDay = false;
          }
        }
      }
      return {
        allDay,
        duration: parsed.duration,
        typeData: parsed.typeData,
        typeId: i3
      };
    }
  }
  return null;
}
function expandRecurring(eventStore, framingRange, context) {
  let { dateEnv, pluginHooks, options } = context;
  let { defs, instances } = eventStore;
  instances = filterHash(instances, (instance) => !defs[instance.defId].recurringDef);
  for (let defId in defs) {
    let def = defs[defId];
    if (def.recurringDef) {
      let { duration } = def.recurringDef;
      if (!duration) {
        duration = def.allDay ? options.defaultAllDayEventDuration : options.defaultTimedEventDuration;
      }
      let starts = expandRecurringRanges(def, duration, framingRange, dateEnv, pluginHooks.recurringTypes);
      for (let start of starts) {
        let instance = createEventInstance(defId, {
          start,
          end: dateEnv.add(start, duration)
        });
        instances[instance.instanceId] = instance;
      }
    }
  }
  return { defs, instances };
}
function expandRecurringRanges(eventDef, duration, framingRange, dateEnv, recurringTypes) {
  let typeDef = recurringTypes[eventDef.recurringDef.typeId];
  let markers = typeDef.expand(eventDef.recurringDef.typeData, {
    start: dateEnv.subtract(framingRange.start, duration),
    end: framingRange.end
  }, dateEnv);
  if (eventDef.allDay) {
    markers = markers.map(startOfDay);
  }
  return markers;
}
var EVENT_NON_DATE_REFINERS = {
  id: String,
  groupId: String,
  title: String,
  url: String,
  interactive: Boolean
};
var EVENT_DATE_REFINERS = {
  start: identity,
  end: identity,
  date: identity,
  allDay: Boolean
};
var EVENT_REFINERS = Object.assign(Object.assign(Object.assign({}, EVENT_NON_DATE_REFINERS), EVENT_DATE_REFINERS), { extendedProps: identity });
function parseEvent(raw, eventSource, context, allowOpenRange, refiners = buildEventRefiners(context), defIdMap, instanceIdMap) {
  let { refined, extra } = refineEventDef(raw, context, refiners);
  let defaultAllDay = computeIsDefaultAllDay(eventSource, context);
  let recurringRes = parseRecurring(refined, defaultAllDay, context.dateEnv, context.pluginHooks.recurringTypes);
  if (recurringRes) {
    let def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : "", recurringRes.allDay, Boolean(recurringRes.duration), context, defIdMap);
    def.recurringDef = {
      typeId: recurringRes.typeId,
      typeData: recurringRes.typeData,
      duration: recurringRes.duration
    };
    return { def, instance: null };
  }
  let singleRes = parseSingle(refined, defaultAllDay, context, allowOpenRange);
  if (singleRes) {
    let def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : "", singleRes.allDay, singleRes.hasEnd, context, defIdMap);
    let instance = createEventInstance(def.defId, singleRes.range, singleRes.forcedStartTzo, singleRes.forcedEndTzo);
    if (instanceIdMap && def.publicId && instanceIdMap[def.publicId]) {
      instance.instanceId = instanceIdMap[def.publicId];
    }
    return { def, instance };
  }
  return null;
}
function refineEventDef(raw, context, refiners = buildEventRefiners(context)) {
  return refineProps(raw, refiners);
}
function buildEventRefiners(context) {
  return Object.assign(Object.assign(Object.assign({}, EVENT_UI_REFINERS), EVENT_REFINERS), context.pluginHooks.eventRefiners);
}
function parseEventDef(refined, extra, sourceId, allDay, hasEnd, context, defIdMap) {
  let def = {
    title: refined.title || "",
    groupId: refined.groupId || "",
    publicId: refined.id || "",
    url: refined.url || "",
    recurringDef: null,
    defId: (defIdMap && refined.id ? defIdMap[refined.id] : "") || guid(),
    sourceId,
    allDay,
    hasEnd,
    interactive: refined.interactive,
    ui: createEventUi(refined, context),
    extendedProps: Object.assign(Object.assign({}, refined.extendedProps || {}), extra)
  };
  for (let memberAdder of context.pluginHooks.eventDefMemberAdders) {
    Object.assign(def, memberAdder(refined));
  }
  Object.freeze(def.ui.classNames);
  Object.freeze(def.extendedProps);
  return def;
}
function parseSingle(refined, defaultAllDay, context, allowOpenRange) {
  let { allDay } = refined;
  let startMeta;
  let startMarker = null;
  let hasEnd = false;
  let endMeta;
  let endMarker = null;
  let startInput = refined.start != null ? refined.start : refined.date;
  startMeta = context.dateEnv.createMarkerMeta(startInput);
  if (startMeta) {
    startMarker = startMeta.marker;
  } else if (!allowOpenRange) {
    return null;
  }
  if (refined.end != null) {
    endMeta = context.dateEnv.createMarkerMeta(refined.end);
  }
  if (allDay == null) {
    if (defaultAllDay != null) {
      allDay = defaultAllDay;
    } else {
      allDay = (!startMeta || startMeta.isTimeUnspecified) && (!endMeta || endMeta.isTimeUnspecified);
    }
  }
  if (allDay && startMarker) {
    startMarker = startOfDay(startMarker);
  }
  if (endMeta) {
    endMarker = endMeta.marker;
    if (allDay) {
      endMarker = startOfDay(endMarker);
    }
    if (startMarker && endMarker <= startMarker) {
      endMarker = null;
    }
  }
  if (endMarker) {
    hasEnd = true;
  } else if (!allowOpenRange) {
    hasEnd = context.options.forceEventDuration || false;
    endMarker = context.dateEnv.add(startMarker, allDay ? context.options.defaultAllDayEventDuration : context.options.defaultTimedEventDuration);
  }
  return {
    allDay,
    hasEnd,
    range: { start: startMarker, end: endMarker },
    forcedStartTzo: startMeta ? startMeta.forcedTzo : null,
    forcedEndTzo: endMeta ? endMeta.forcedTzo : null
  };
}
function computeIsDefaultAllDay(eventSource, context) {
  let res = null;
  if (eventSource) {
    res = eventSource.defaultAllDay;
  }
  if (res == null) {
    res = context.options.defaultAllDay;
  }
  return res;
}
function parseEvents(rawEvents, eventSource, context, allowOpenRange, defIdMap, instanceIdMap) {
  let eventStore = createEmptyEventStore();
  let eventRefiners = buildEventRefiners(context);
  for (let rawEvent of rawEvents) {
    let tuple = parseEvent(rawEvent, eventSource, context, allowOpenRange, eventRefiners, defIdMap, instanceIdMap);
    if (tuple) {
      eventTupleToStore(tuple, eventStore);
    }
  }
  return eventStore;
}
function eventTupleToStore(tuple, eventStore = createEmptyEventStore()) {
  eventStore.defs[tuple.def.defId] = tuple.def;
  if (tuple.instance) {
    eventStore.instances[tuple.instance.instanceId] = tuple.instance;
  }
  return eventStore;
}
function getRelevantEvents(eventStore, instanceId) {
  let instance = eventStore.instances[instanceId];
  if (instance) {
    let def = eventStore.defs[instance.defId];
    let newStore = filterEventStoreDefs(eventStore, (lookDef) => isEventDefsGrouped(def, lookDef));
    newStore.defs[def.defId] = def;
    newStore.instances[instance.instanceId] = instance;
    return newStore;
  }
  return createEmptyEventStore();
}
function isEventDefsGrouped(def0, def1) {
  return Boolean(def0.groupId && def0.groupId === def1.groupId);
}
function createEmptyEventStore() {
  return { defs: {}, instances: {} };
}
function mergeEventStores(store0, store1) {
  return {
    defs: Object.assign(Object.assign({}, store0.defs), store1.defs),
    instances: Object.assign(Object.assign({}, store0.instances), store1.instances)
  };
}
function filterEventStoreDefs(eventStore, filterFunc) {
  let defs = filterHash(eventStore.defs, filterFunc);
  let instances = filterHash(eventStore.instances, (instance) => defs[instance.defId]);
  return { defs, instances };
}
function excludeSubEventStore(master, sub) {
  let { defs, instances } = master;
  let filteredDefs = {};
  let filteredInstances = {};
  for (let defId in defs) {
    if (!sub.defs[defId]) {
      filteredDefs[defId] = defs[defId];
    }
  }
  for (let instanceId in instances) {
    if (!sub.instances[instanceId] && // not explicitly excluded
    filteredDefs[instances[instanceId].defId]) {
      filteredInstances[instanceId] = instances[instanceId];
    }
  }
  return {
    defs: filteredDefs,
    instances: filteredInstances
  };
}
function normalizeConstraint(input, context) {
  if (Array.isArray(input)) {
    return parseEvents(input, null, context, true);
  }
  if (typeof input === "object" && input) {
    return parseEvents([input], null, context, true);
  }
  if (input != null) {
    return String(input);
  }
  return null;
}
function parseClassNames(raw) {
  if (Array.isArray(raw)) {
    return raw;
  }
  if (typeof raw === "string") {
    return raw.split(/\s+/);
  }
  return [];
}
var EVENT_UI_REFINERS = {
  display: String,
  editable: Boolean,
  startEditable: Boolean,
  durationEditable: Boolean,
  constraint: identity,
  overlap: identity,
  allow: identity,
  className: parseClassNames,
  classNames: parseClassNames,
  color: String,
  backgroundColor: String,
  borderColor: String,
  textColor: String
};
var EMPTY_EVENT_UI = {
  display: null,
  startEditable: null,
  durationEditable: null,
  constraints: [],
  overlap: null,
  allows: [],
  backgroundColor: "",
  borderColor: "",
  textColor: "",
  classNames: []
};
function createEventUi(refined, context) {
  let constraint = normalizeConstraint(refined.constraint, context);
  return {
    display: refined.display || null,
    startEditable: refined.startEditable != null ? refined.startEditable : refined.editable,
    durationEditable: refined.durationEditable != null ? refined.durationEditable : refined.editable,
    constraints: constraint != null ? [constraint] : [],
    overlap: refined.overlap != null ? refined.overlap : null,
    allows: refined.allow != null ? [refined.allow] : [],
    backgroundColor: refined.backgroundColor || refined.color || "",
    borderColor: refined.borderColor || refined.color || "",
    textColor: refined.textColor || "",
    classNames: (refined.className || []).concat(refined.classNames || [])
    // join singular and plural
  };
}
function combineEventUis(uis) {
  return uis.reduce(combineTwoEventUis, EMPTY_EVENT_UI);
}
function combineTwoEventUis(item0, item1) {
  return {
    display: item1.display != null ? item1.display : item0.display,
    startEditable: item1.startEditable != null ? item1.startEditable : item0.startEditable,
    durationEditable: item1.durationEditable != null ? item1.durationEditable : item0.durationEditable,
    constraints: item0.constraints.concat(item1.constraints),
    overlap: typeof item1.overlap === "boolean" ? item1.overlap : item0.overlap,
    allows: item0.allows.concat(item1.allows),
    backgroundColor: item1.backgroundColor || item0.backgroundColor,
    borderColor: item1.borderColor || item0.borderColor,
    textColor: item1.textColor || item0.textColor,
    classNames: item0.classNames.concat(item1.classNames)
  };
}
var EVENT_SOURCE_REFINERS = {
  id: String,
  defaultAllDay: Boolean,
  url: String,
  format: String,
  events: identity,
  eventDataTransform: identity,
  // for any network-related sources
  success: identity,
  failure: identity
};
function parseEventSource(raw, context, refiners = buildEventSourceRefiners(context)) {
  let rawObj;
  if (typeof raw === "string") {
    rawObj = { url: raw };
  } else if (typeof raw === "function" || Array.isArray(raw)) {
    rawObj = { events: raw };
  } else if (typeof raw === "object" && raw) {
    rawObj = raw;
  }
  if (rawObj) {
    let { refined, extra } = refineProps(rawObj, refiners);
    let metaRes = buildEventSourceMeta(refined, context);
    if (metaRes) {
      return {
        _raw: raw,
        isFetching: false,
        latestFetchId: "",
        fetchRange: null,
        defaultAllDay: refined.defaultAllDay,
        eventDataTransform: refined.eventDataTransform,
        success: refined.success,
        failure: refined.failure,
        publicId: refined.id || "",
        sourceId: guid(),
        sourceDefId: metaRes.sourceDefId,
        meta: metaRes.meta,
        ui: createEventUi(refined, context),
        extendedProps: extra
      };
    }
  }
  return null;
}
function buildEventSourceRefiners(context) {
  return Object.assign(Object.assign(Object.assign({}, EVENT_UI_REFINERS), EVENT_SOURCE_REFINERS), context.pluginHooks.eventSourceRefiners);
}
function buildEventSourceMeta(raw, context) {
  let defs = context.pluginHooks.eventSourceDefs;
  for (let i3 = defs.length - 1; i3 >= 0; i3 -= 1) {
    let def = defs[i3];
    let meta = def.parseMeta(raw);
    if (meta) {
      return { sourceDefId: i3, meta };
    }
  }
  return null;
}
function reduceEventStore(eventStore, action, eventSources, dateProfile, context) {
  switch (action.type) {
    case "RECEIVE_EVENTS":
      return receiveRawEvents(eventStore, eventSources[action.sourceId], action.fetchId, action.fetchRange, action.rawEvents, context);
    case "RESET_RAW_EVENTS":
      return resetRawEvents(eventStore, eventSources[action.sourceId], action.rawEvents, dateProfile.activeRange, context);
    case "ADD_EVENTS":
      return addEvent(
        eventStore,
        action.eventStore,
        // new ones
        dateProfile ? dateProfile.activeRange : null,
        context
      );
    case "RESET_EVENTS":
      return action.eventStore;
    case "MERGE_EVENTS":
      return mergeEventStores(eventStore, action.eventStore);
    case "PREV":
    case "NEXT":
    case "CHANGE_DATE":
    case "CHANGE_VIEW_TYPE":
      if (dateProfile) {
        return expandRecurring(eventStore, dateProfile.activeRange, context);
      }
      return eventStore;
    case "REMOVE_EVENTS":
      return excludeSubEventStore(eventStore, action.eventStore);
    case "REMOVE_EVENT_SOURCE":
      return excludeEventsBySourceId(eventStore, action.sourceId);
    case "REMOVE_ALL_EVENT_SOURCES":
      return filterEventStoreDefs(eventStore, (eventDef) => !eventDef.sourceId);
    case "REMOVE_ALL_EVENTS":
      return createEmptyEventStore();
    default:
      return eventStore;
  }
}
function receiveRawEvents(eventStore, eventSource, fetchId, fetchRange, rawEvents, context) {
  if (eventSource && // not already removed
  fetchId === eventSource.latestFetchId) {
    let subset = parseEvents(transformRawEvents(rawEvents, eventSource, context), eventSource, context);
    if (fetchRange) {
      subset = expandRecurring(subset, fetchRange, context);
    }
    return mergeEventStores(excludeEventsBySourceId(eventStore, eventSource.sourceId), subset);
  }
  return eventStore;
}
function resetRawEvents(existingEventStore, eventSource, rawEvents, activeRange, context) {
  const { defIdMap, instanceIdMap } = buildPublicIdMaps(existingEventStore);
  let newEventStore = parseEvents(transformRawEvents(rawEvents, eventSource, context), eventSource, context, false, defIdMap, instanceIdMap);
  return expandRecurring(newEventStore, activeRange, context);
}
function transformRawEvents(rawEvents, eventSource, context) {
  let calEachTransform = context.options.eventDataTransform;
  let sourceEachTransform = eventSource ? eventSource.eventDataTransform : null;
  if (sourceEachTransform) {
    rawEvents = transformEachRawEvent(rawEvents, sourceEachTransform);
  }
  if (calEachTransform) {
    rawEvents = transformEachRawEvent(rawEvents, calEachTransform);
  }
  return rawEvents;
}
function transformEachRawEvent(rawEvents, func) {
  let refinedEvents;
  if (!func) {
    refinedEvents = rawEvents;
  } else {
    refinedEvents = [];
    for (let rawEvent of rawEvents) {
      let refinedEvent = func(rawEvent);
      if (refinedEvent) {
        refinedEvents.push(refinedEvent);
      } else if (refinedEvent == null) {
        refinedEvents.push(rawEvent);
      }
    }
  }
  return refinedEvents;
}
function addEvent(eventStore, subset, expandRange, context) {
  if (expandRange) {
    subset = expandRecurring(subset, expandRange, context);
  }
  return mergeEventStores(eventStore, subset);
}
function rezoneEventStoreDates(eventStore, oldDateEnv, newDateEnv) {
  let { defs } = eventStore;
  let instances = mapHash(eventStore.instances, (instance) => {
    let def = defs[instance.defId];
    if (def.allDay) {
      return instance;
    }
    return Object.assign(Object.assign({}, instance), { range: {
      start: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.start, instance.forcedStartTzo)),
      end: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.end, instance.forcedEndTzo))
    }, forcedStartTzo: newDateEnv.canComputeOffset ? null : instance.forcedStartTzo, forcedEndTzo: newDateEnv.canComputeOffset ? null : instance.forcedEndTzo });
  });
  return { defs, instances };
}
function excludeEventsBySourceId(eventStore, sourceId) {
  return filterEventStoreDefs(eventStore, (eventDef) => eventDef.sourceId !== sourceId);
}
function excludeInstances(eventStore, removals) {
  return {
    defs: eventStore.defs,
    instances: filterHash(eventStore.instances, (instance) => !removals[instance.instanceId])
  };
}
function buildPublicIdMaps(eventStore) {
  const { defs, instances } = eventStore;
  const defIdMap = {};
  const instanceIdMap = {};
  for (let defId in defs) {
    const def = defs[defId];
    const { publicId } = def;
    if (publicId) {
      defIdMap[publicId] = defId;
    }
  }
  for (let instanceId in instances) {
    const instance = instances[instanceId];
    const def = defs[instance.defId];
    const { publicId } = def;
    if (publicId) {
      instanceIdMap[publicId] = instanceId;
    }
  }
  return { defIdMap, instanceIdMap };
}
var Emitter = class {
  constructor() {
    this.handlers = {};
    this.thisContext = null;
  }
  setThisContext(thisContext) {
    this.thisContext = thisContext;
  }
  setOptions(options) {
    this.options = options;
  }
  on(type, handler) {
    addToHash(this.handlers, type, handler);
  }
  off(type, handler) {
    removeFromHash(this.handlers, type, handler);
  }
  trigger(type, ...args) {
    let attachedHandlers = this.handlers[type] || [];
    let optionHandler = this.options && this.options[type];
    let handlers = [].concat(optionHandler || [], attachedHandlers);
    for (let handler of handlers) {
      handler.apply(this.thisContext, args);
    }
  }
  hasHandlers(type) {
    return Boolean(this.handlers[type] && this.handlers[type].length || this.options && this.options[type]);
  }
};
function addToHash(hash, type, handler) {
  (hash[type] || (hash[type] = [])).push(handler);
}
function removeFromHash(hash, type, handler) {
  if (handler) {
    if (hash[type]) {
      hash[type] = hash[type].filter((func) => func !== handler);
    }
  } else {
    delete hash[type];
  }
}
var DEF_DEFAULTS = {
  startTime: "09:00",
  endTime: "17:00",
  daysOfWeek: [1, 2, 3, 4, 5],
  display: "inverse-background",
  classNames: "fc-non-business",
  groupId: "_businessHours"
  // so multiple defs get grouped
};
function parseBusinessHours(input, context) {
  return parseEvents(refineInputs(input), null, context);
}
function refineInputs(input) {
  let rawDefs;
  if (input === true) {
    rawDefs = [{}];
  } else if (Array.isArray(input)) {
    rawDefs = input.filter((rawDef) => rawDef.daysOfWeek);
  } else if (typeof input === "object" && input) {
    rawDefs = [input];
  } else {
    rawDefs = [];
  }
  rawDefs = rawDefs.map((rawDef) => Object.assign(Object.assign({}, DEF_DEFAULTS), rawDef));
  return rawDefs;
}
function triggerDateSelect(selection, pev, context) {
  context.emitter.trigger("select", Object.assign(Object.assign({}, buildDateSpanApiWithContext(selection, context)), { jsEvent: pev ? pev.origEvent : null, view: context.viewApi || context.calendarApi.view }));
}
function triggerDateUnselect(pev, context) {
  context.emitter.trigger("unselect", {
    jsEvent: pev ? pev.origEvent : null,
    view: context.viewApi || context.calendarApi.view
  });
}
function buildDateSpanApiWithContext(dateSpan, context) {
  let props = {};
  for (let transform of context.pluginHooks.dateSpanTransforms) {
    Object.assign(props, transform(dateSpan, context));
  }
  Object.assign(props, buildDateSpanApi(dateSpan, context.dateEnv));
  return props;
}
function getDefaultEventEnd(allDay, marker, context) {
  let { dateEnv, options } = context;
  let end = marker;
  if (allDay) {
    end = startOfDay(end);
    end = dateEnv.add(end, options.defaultAllDayEventDuration);
  } else {
    end = dateEnv.add(end, options.defaultTimedEventDuration);
  }
  return end;
}
function applyMutationToEventStore(eventStore, eventConfigBase, mutation, context) {
  let eventConfigs = compileEventUis(eventStore.defs, eventConfigBase);
  let dest = createEmptyEventStore();
  for (let defId in eventStore.defs) {
    let def = eventStore.defs[defId];
    dest.defs[defId] = applyMutationToEventDef(def, eventConfigs[defId], mutation, context);
  }
  for (let instanceId in eventStore.instances) {
    let instance = eventStore.instances[instanceId];
    let def = dest.defs[instance.defId];
    dest.instances[instanceId] = applyMutationToEventInstance(instance, def, eventConfigs[instance.defId], mutation, context);
  }
  return dest;
}
function applyMutationToEventDef(eventDef, eventConfig, mutation, context) {
  let standardProps = mutation.standardProps || {};
  if (standardProps.hasEnd == null && eventConfig.durationEditable && (mutation.startDelta || mutation.endDelta)) {
    standardProps.hasEnd = true;
  }
  let copy = Object.assign(Object.assign(Object.assign({}, eventDef), standardProps), { ui: Object.assign(Object.assign({}, eventDef.ui), standardProps.ui) });
  if (mutation.extendedProps) {
    copy.extendedProps = Object.assign(Object.assign({}, copy.extendedProps), mutation.extendedProps);
  }
  for (let applier of context.pluginHooks.eventDefMutationAppliers) {
    applier(copy, mutation, context);
  }
  if (!copy.hasEnd && context.options.forceEventDuration) {
    copy.hasEnd = true;
  }
  return copy;
}
function applyMutationToEventInstance(eventInstance, eventDef, eventConfig, mutation, context) {
  let { dateEnv } = context;
  let forceAllDay = mutation.standardProps && mutation.standardProps.allDay === true;
  let clearEnd = mutation.standardProps && mutation.standardProps.hasEnd === false;
  let copy = Object.assign({}, eventInstance);
  if (forceAllDay) {
    copy.range = computeAlignedDayRange(copy.range);
  }
  if (mutation.datesDelta && eventConfig.startEditable) {
    copy.range = {
      start: dateEnv.add(copy.range.start, mutation.datesDelta),
      end: dateEnv.add(copy.range.end, mutation.datesDelta)
    };
  }
  if (mutation.startDelta && eventConfig.durationEditable) {
    copy.range = {
      start: dateEnv.add(copy.range.start, mutation.startDelta),
      end: copy.range.end
    };
  }
  if (mutation.endDelta && eventConfig.durationEditable) {
    copy.range = {
      start: copy.range.start,
      end: dateEnv.add(copy.range.end, mutation.endDelta)
    };
  }
  if (clearEnd) {
    copy.range = {
      start: copy.range.start,
      end: getDefaultEventEnd(eventDef.allDay, copy.range.start, context)
    };
  }
  if (eventDef.allDay) {
    copy.range = {
      start: startOfDay(copy.range.start),
      end: startOfDay(copy.range.end)
    };
  }
  if (copy.range.end < copy.range.start) {
    copy.range.end = getDefaultEventEnd(eventDef.allDay, copy.range.start, context);
  }
  return copy;
}
var EventSourceImpl = class {
  constructor(context, internalEventSource) {
    this.context = context;
    this.internalEventSource = internalEventSource;
  }
  remove() {
    this.context.dispatch({
      type: "REMOVE_EVENT_SOURCE",
      sourceId: this.internalEventSource.sourceId
    });
  }
  refetch() {
    this.context.dispatch({
      type: "FETCH_EVENT_SOURCES",
      sourceIds: [this.internalEventSource.sourceId],
      isRefetch: true
    });
  }
  get id() {
    return this.internalEventSource.publicId;
  }
  get url() {
    return this.internalEventSource.meta.url;
  }
  get format() {
    return this.internalEventSource.meta.format;
  }
};
var EventImpl = class {
  // instance will be null if expressing a recurring event that has no current instances,
  // OR if trying to validate an incoming external event that has no dates assigned
  constructor(context, def, instance) {
    this._context = context;
    this._def = def;
    this._instance = instance || null;
  }
  /*
  TODO: make event struct more responsible for this
  */
  setProp(name, val) {
    if (name in EVENT_DATE_REFINERS) {
      console.warn("Could not set date-related prop 'name'. Use one of the date-related methods instead.");
    } else if (name === "id") {
      val = EVENT_NON_DATE_REFINERS[name](val);
      this.mutate({
        standardProps: { publicId: val }
        // hardcoded internal name
      });
    } else if (name in EVENT_NON_DATE_REFINERS) {
      val = EVENT_NON_DATE_REFINERS[name](val);
      this.mutate({
        standardProps: { [name]: val }
      });
    } else if (name in EVENT_UI_REFINERS) {
      let ui = EVENT_UI_REFINERS[name](val);
      if (name === "color") {
        ui = { backgroundColor: val, borderColor: val };
      } else if (name === "editable") {
        ui = { startEditable: val, durationEditable: val };
      } else {
        ui = { [name]: val };
      }
      this.mutate({
        standardProps: { ui }
      });
    } else {
      console.warn(`Could not set prop '${name}'. Use setExtendedProp instead.`);
    }
  }
  setExtendedProp(name, val) {
    this.mutate({
      extendedProps: { [name]: val }
    });
  }
  setStart(startInput, options = {}) {
    let { dateEnv } = this._context;
    let start = dateEnv.createMarker(startInput);
    if (start && this._instance) {
      let instanceRange = this._instance.range;
      let startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity);
      if (options.maintainDuration) {
        this.mutate({ datesDelta: startDelta });
      } else {
        this.mutate({ startDelta });
      }
    }
  }
  setEnd(endInput, options = {}) {
    let { dateEnv } = this._context;
    let end;
    if (endInput != null) {
      end = dateEnv.createMarker(endInput);
      if (!end) {
        return;
      }
    }
    if (this._instance) {
      if (end) {
        let endDelta = diffDates(this._instance.range.end, end, dateEnv, options.granularity);
        this.mutate({ endDelta });
      } else {
        this.mutate({ standardProps: { hasEnd: false } });
      }
    }
  }
  setDates(startInput, endInput, options = {}) {
    let { dateEnv } = this._context;
    let standardProps = { allDay: options.allDay };
    let start = dateEnv.createMarker(startInput);
    let end;
    if (!start) {
      return;
    }
    if (endInput != null) {
      end = dateEnv.createMarker(endInput);
      if (!end) {
        return;
      }
    }
    if (this._instance) {
      let instanceRange = this._instance.range;
      if (options.allDay === true) {
        instanceRange = computeAlignedDayRange(instanceRange);
      }
      let startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity);
      if (end) {
        let endDelta = diffDates(instanceRange.end, end, dateEnv, options.granularity);
        if (durationsEqual(startDelta, endDelta)) {
          this.mutate({ datesDelta: startDelta, standardProps });
        } else {
          this.mutate({ startDelta, endDelta, standardProps });
        }
      } else {
        standardProps.hasEnd = false;
        this.mutate({ datesDelta: startDelta, standardProps });
      }
    }
  }
  moveStart(deltaInput) {
    let delta = createDuration(deltaInput);
    if (delta) {
      this.mutate({ startDelta: delta });
    }
  }
  moveEnd(deltaInput) {
    let delta = createDuration(deltaInput);
    if (delta) {
      this.mutate({ endDelta: delta });
    }
  }
  moveDates(deltaInput) {
    let delta = createDuration(deltaInput);
    if (delta) {
      this.mutate({ datesDelta: delta });
    }
  }
  setAllDay(allDay, options = {}) {
    let standardProps = { allDay };
    let { maintainDuration } = options;
    if (maintainDuration == null) {
      maintainDuration = this._context.options.allDayMaintainDuration;
    }
    if (this._def.allDay !== allDay) {
      standardProps.hasEnd = maintainDuration;
    }
    this.mutate({ standardProps });
  }
  formatRange(formatInput) {
    let { dateEnv } = this._context;
    let instance = this._instance;
    let formatter = createFormatter(formatInput);
    if (this._def.hasEnd) {
      return dateEnv.formatRange(instance.range.start, instance.range.end, formatter, {
        forcedStartTzo: instance.forcedStartTzo,
        forcedEndTzo: instance.forcedEndTzo
      });
    }
    return dateEnv.format(instance.range.start, formatter, {
      forcedTzo: instance.forcedStartTzo
    });
  }
  mutate(mutation) {
    let instance = this._instance;
    if (instance) {
      let def = this._def;
      let context = this._context;
      let { eventStore } = context.getCurrentData();
      let relevantEvents = getRelevantEvents(eventStore, instance.instanceId);
      let eventConfigBase = {
        "": {
          display: "",
          startEditable: true,
          durationEditable: true,
          constraints: [],
          overlap: null,
          allows: [],
          backgroundColor: "",
          borderColor: "",
          textColor: "",
          classNames: []
        }
      };
      relevantEvents = applyMutationToEventStore(relevantEvents, eventConfigBase, mutation, context);
      let oldEvent = new EventImpl(context, def, instance);
      this._def = relevantEvents.defs[def.defId];
      this._instance = relevantEvents.instances[instance.instanceId];
      context.dispatch({
        type: "MERGE_EVENTS",
        eventStore: relevantEvents
      });
      context.emitter.trigger("eventChange", {
        oldEvent,
        event: this,
        relatedEvents: buildEventApis(relevantEvents, context, instance),
        revert() {
          context.dispatch({
            type: "RESET_EVENTS",
            eventStore
            // the ORIGINAL store
          });
        }
      });
    }
  }
  remove() {
    let context = this._context;
    let asStore = eventApiToStore(this);
    context.dispatch({
      type: "REMOVE_EVENTS",
      eventStore: asStore
    });
    context.emitter.trigger("eventRemove", {
      event: this,
      relatedEvents: [],
      revert() {
        context.dispatch({
          type: "MERGE_EVENTS",
          eventStore: asStore
        });
      }
    });
  }
  get source() {
    let { sourceId } = this._def;
    if (sourceId) {
      return new EventSourceImpl(this._context, this._context.getCurrentData().eventSources[sourceId]);
    }
    return null;
  }
  get start() {
    return this._instance ? this._context.dateEnv.toDate(this._instance.range.start) : null;
  }
  get end() {
    return this._instance && this._def.hasEnd ? this._context.dateEnv.toDate(this._instance.range.end) : null;
  }
  get startStr() {
    let instance = this._instance;
    if (instance) {
      return this._context.dateEnv.formatIso(instance.range.start, {
        omitTime: this._def.allDay,
        forcedTzo: instance.forcedStartTzo
      });
    }
    return "";
  }
  get endStr() {
    let instance = this._instance;
    if (instance && this._def.hasEnd) {
      return this._context.dateEnv.formatIso(instance.range.end, {
        omitTime: this._def.allDay,
        forcedTzo: instance.forcedEndTzo
      });
    }
    return "";
  }
  // computable props that all access the def
  // TODO: find a TypeScript-compatible way to do this at scale
  get id() {
    return this._def.publicId;
  }
  get groupId() {
    return this._def.groupId;
  }
  get allDay() {
    return this._def.allDay;
  }
  get title() {
    return this._def.title;
  }
  get url() {
    return this._def.url;
  }
  get display() {
    return this._def.ui.display || "auto";
  }
  // bad. just normalize the type earlier
  get startEditable() {
    return this._def.ui.startEditable;
  }
  get durationEditable() {
    return this._def.ui.durationEditable;
  }
  get constraint() {
    return this._def.ui.constraints[0] || null;
  }
  get overlap() {
    return this._def.ui.overlap;
  }
  get allow() {
    return this._def.ui.allows[0] || null;
  }
  get backgroundColor() {
    return this._def.ui.backgroundColor;
  }
  get borderColor() {
    return this._def.ui.borderColor;
  }
  get textColor() {
    return this._def.ui.textColor;
  }
  // NOTE: user can't modify these because Object.freeze was called in event-def parsing
  get classNames() {
    return this._def.ui.classNames;
  }
  get extendedProps() {
    return this._def.extendedProps;
  }
  toPlainObject(settings = {}) {
    let def = this._def;
    let { ui } = def;
    let { startStr, endStr } = this;
    let res = {
      allDay: def.allDay
    };
    if (def.title) {
      res.title = def.title;
    }
    if (startStr) {
      res.start = startStr;
    }
    if (endStr) {
      res.end = endStr;
    }
    if (def.publicId) {
      res.id = def.publicId;
    }
    if (def.groupId) {
      res.groupId = def.groupId;
    }
    if (def.url) {
      res.url = def.url;
    }
    if (ui.display && ui.display !== "auto") {
      res.display = ui.display;
    }
    if (settings.collapseColor && ui.backgroundColor && ui.backgroundColor === ui.borderColor) {
      res.color = ui.backgroundColor;
    } else {
      if (ui.backgroundColor) {
        res.backgroundColor = ui.backgroundColor;
      }
      if (ui.borderColor) {
        res.borderColor = ui.borderColor;
      }
    }
    if (ui.textColor) {
      res.textColor = ui.textColor;
    }
    if (ui.classNames.length) {
      res.classNames = ui.classNames;
    }
    if (Object.keys(def.extendedProps).length) {
      if (settings.collapseExtendedProps) {
        Object.assign(res, def.extendedProps);
      } else {
        res.extendedProps = def.extendedProps;
      }
    }
    return res;
  }
  toJSON() {
    return this.toPlainObject();
  }
};
function eventApiToStore(eventApi) {
  let def = eventApi._def;
  let instance = eventApi._instance;
  return {
    defs: { [def.defId]: def },
    instances: instance ? { [instance.instanceId]: instance } : {}
  };
}
function buildEventApis(eventStore, context, excludeInstance) {
  let { defs, instances } = eventStore;
  let eventApis = [];
  let excludeInstanceId = excludeInstance ? excludeInstance.instanceId : "";
  for (let id in instances) {
    let instance = instances[id];
    let def = defs[instance.defId];
    if (instance.instanceId !== excludeInstanceId) {
      eventApis.push(new EventImpl(context, def, instance));
    }
  }
  return eventApis;
}
function sliceEventStore(eventStore, eventUiBases, framingRange, nextDayThreshold) {
  let inverseBgByGroupId = {};
  let inverseBgByDefId = {};
  let defByGroupId = {};
  let bgRanges = [];
  let fgRanges = [];
  let eventUis = compileEventUis(eventStore.defs, eventUiBases);
  for (let defId in eventStore.defs) {
    let def = eventStore.defs[defId];
    let ui = eventUis[def.defId];
    if (ui.display === "inverse-background") {
      if (def.groupId) {
        inverseBgByGroupId[def.groupId] = [];
        if (!defByGroupId[def.groupId]) {
          defByGroupId[def.groupId] = def;
        }
      } else {
        inverseBgByDefId[defId] = [];
      }
    }
  }
  for (let instanceId in eventStore.instances) {
    let instance = eventStore.instances[instanceId];
    let def = eventStore.defs[instance.defId];
    let ui = eventUis[def.defId];
    let origRange = instance.range;
    let normalRange = !def.allDay && nextDayThreshold ? computeVisibleDayRange(origRange, nextDayThreshold) : origRange;
    let slicedRange = intersectRanges(normalRange, framingRange);
    if (slicedRange) {
      if (ui.display === "inverse-background") {
        if (def.groupId) {
          inverseBgByGroupId[def.groupId].push(slicedRange);
        } else {
          inverseBgByDefId[instance.defId].push(slicedRange);
        }
      } else if (ui.display !== "none") {
        (ui.display === "background" ? bgRanges : fgRanges).push({
          def,
          ui,
          instance,
          range: slicedRange,
          isStart: normalRange.start && normalRange.start.valueOf() === slicedRange.start.valueOf(),
          isEnd: normalRange.end && normalRange.end.valueOf() === slicedRange.end.valueOf()
        });
      }
    }
  }
  for (let groupId in inverseBgByGroupId) {
    let ranges = inverseBgByGroupId[groupId];
    let invertedRanges = invertRanges(ranges, framingRange);
    for (let invertedRange of invertedRanges) {
      let def = defByGroupId[groupId];
      let ui = eventUis[def.defId];
      bgRanges.push({
        def,
        ui,
        instance: null,
        range: invertedRange,
        isStart: false,
        isEnd: false
      });
    }
  }
  for (let defId in inverseBgByDefId) {
    let ranges = inverseBgByDefId[defId];
    let invertedRanges = invertRanges(ranges, framingRange);
    for (let invertedRange of invertedRanges) {
      bgRanges.push({
        def: eventStore.defs[defId],
        ui: eventUis[defId],
        instance: null,
        range: invertedRange,
        isStart: false,
        isEnd: false
      });
    }
  }
  return { bg: bgRanges, fg: fgRanges };
}
function hasBgRendering(def) {
  return def.ui.display === "background" || def.ui.display === "inverse-background";
}
function setElSeg(el, seg) {
  el.fcSeg = seg;
}
function getElSeg(el) {
  return el.fcSeg || el.parentNode.fcSeg || // for the harness
  null;
}
function compileEventUis(eventDefs, eventUiBases) {
  return mapHash(eventDefs, (eventDef) => compileEventUi(eventDef, eventUiBases));
}
function compileEventUi(eventDef, eventUiBases) {
  let uis = [];
  if (eventUiBases[""]) {
    uis.push(eventUiBases[""]);
  }
  if (eventUiBases[eventDef.defId]) {
    uis.push(eventUiBases[eventDef.defId]);
  }
  uis.push(eventDef.ui);
  return combineEventUis(uis);
}
function sortEventSegs(segs, eventOrderSpecs) {
  let objs = segs.map(buildSegCompareObj);
  objs.sort((obj0, obj1) => compareByFieldSpecs(obj0, obj1, eventOrderSpecs));
  return objs.map((c3) => c3._seg);
}
function buildSegCompareObj(seg) {
  let { eventRange } = seg;
  let eventDef = eventRange.def;
  let range2 = eventRange.instance ? eventRange.instance.range : eventRange.range;
  let start = range2.start ? range2.start.valueOf() : 0;
  let end = range2.end ? range2.end.valueOf() : 0;
  return Object.assign(Object.assign(Object.assign({}, eventDef.extendedProps), eventDef), {
    id: eventDef.publicId,
    start,
    end,
    duration: end - start,
    allDay: Number(eventDef.allDay),
    _seg: seg
  });
}
function computeSegDraggable(seg, context) {
  let { pluginHooks } = context;
  let transformers = pluginHooks.isDraggableTransformers;
  let { def, ui } = seg.eventRange;
  let val = ui.startEditable;
  for (let transformer of transformers) {
    val = transformer(val, def, ui, context);
  }
  return val;
}
function computeSegStartResizable(seg, context) {
  return seg.isStart && seg.eventRange.ui.durationEditable && context.options.eventResizableFromStart;
}
function computeSegEndResizable(seg, context) {
  return seg.isEnd && seg.eventRange.ui.durationEditable;
}
function buildSegTimeText(seg, timeFormat, context, defaultDisplayEventTime, defaultDisplayEventEnd, startOverride, endOverride) {
  let { dateEnv, options } = context;
  let { displayEventTime, displayEventEnd } = options;
  let eventDef = seg.eventRange.def;
  let eventInstance = seg.eventRange.instance;
  if (displayEventTime == null) {
    displayEventTime = defaultDisplayEventTime !== false;
  }
  if (displayEventEnd == null) {
    displayEventEnd = defaultDisplayEventEnd !== false;
  }
  let wholeEventStart = eventInstance.range.start;
  let wholeEventEnd = eventInstance.range.end;
  let segStart = startOverride || seg.start || seg.eventRange.range.start;
  let segEnd = endOverride || seg.end || seg.eventRange.range.end;
  let isStartDay = startOfDay(wholeEventStart).valueOf() === startOfDay(segStart).valueOf();
  let isEndDay = startOfDay(addMs(wholeEventEnd, -1)).valueOf() === startOfDay(addMs(segEnd, -1)).valueOf();
  if (displayEventTime && !eventDef.allDay && (isStartDay || isEndDay)) {
    segStart = isStartDay ? wholeEventStart : segStart;
    segEnd = isEndDay ? wholeEventEnd : segEnd;
    if (displayEventEnd && eventDef.hasEnd) {
      return dateEnv.formatRange(segStart, segEnd, timeFormat, {
        forcedStartTzo: startOverride ? null : eventInstance.forcedStartTzo,
        forcedEndTzo: endOverride ? null : eventInstance.forcedEndTzo
      });
    }
    return dateEnv.format(segStart, timeFormat, {
      forcedTzo: startOverride ? null : eventInstance.forcedStartTzo
      // nooooo, same
    });
  }
  return "";
}
function getSegMeta(seg, todayRange, nowDate) {
  let segRange = seg.eventRange.range;
  return {
    isPast: segRange.end <= (nowDate || todayRange.start),
    isFuture: segRange.start >= (nowDate || todayRange.end),
    isToday: todayRange && rangeContainsMarker(todayRange, segRange.start)
  };
}
function getEventClassNames(props) {
  let classNames = ["fc-event"];
  if (props.isMirror) {
    classNames.push("fc-event-mirror");
  }
  if (props.isDraggable) {
    classNames.push("fc-event-draggable");
  }
  if (props.isStartResizable || props.isEndResizable) {
    classNames.push("fc-event-resizable");
  }
  if (props.isDragging) {
    classNames.push("fc-event-dragging");
  }
  if (props.isResizing) {
    classNames.push("fc-event-resizing");
  }
  if (props.isSelected) {
    classNames.push("fc-event-selected");
  }
  if (props.isStart) {
    classNames.push("fc-event-start");
  }
  if (props.isEnd) {
    classNames.push("fc-event-end");
  }
  if (props.isPast) {
    classNames.push("fc-event-past");
  }
  if (props.isToday) {
    classNames.push("fc-event-today");
  }
  if (props.isFuture) {
    classNames.push("fc-event-future");
  }
  return classNames;
}
function buildEventRangeKey(eventRange) {
  return eventRange.instance ? eventRange.instance.instanceId : `${eventRange.def.defId}:${eventRange.range.start.toISOString()}`;
}
function getSegAnchorAttrs(seg, context) {
  let { def, instance } = seg.eventRange;
  let { url } = def;
  if (url) {
    return { href: url };
  }
  let { emitter, options } = context;
  let { eventInteractive } = options;
  if (eventInteractive == null) {
    eventInteractive = def.interactive;
    if (eventInteractive == null) {
      eventInteractive = Boolean(emitter.hasHandlers("eventClick"));
    }
  }
  if (eventInteractive) {
    return createAriaKeyboardAttrs((ev) => {
      emitter.trigger("eventClick", {
        el: ev.target,
        event: new EventImpl(context, def, instance),
        jsEvent: ev,
        view: context.viewApi
      });
    });
  }
  return {};
}
var STANDARD_PROPS = {
  start: identity,
  end: identity,
  allDay: Boolean
};
function parseDateSpan(raw, dateEnv, defaultDuration) {
  let span = parseOpenDateSpan(raw, dateEnv);
  let { range: range2 } = span;
  if (!range2.start) {
    return null;
  }
  if (!range2.end) {
    if (defaultDuration == null) {
      return null;
    }
    range2.end = dateEnv.add(range2.start, defaultDuration);
  }
  return span;
}
function parseOpenDateSpan(raw, dateEnv) {
  let { refined: standardProps, extra } = refineProps(raw, STANDARD_PROPS);
  let startMeta = standardProps.start ? dateEnv.createMarkerMeta(standardProps.start) : null;
  let endMeta = standardProps.end ? dateEnv.createMarkerMeta(standardProps.end) : null;
  let { allDay } = standardProps;
  if (allDay == null) {
    allDay = startMeta && startMeta.isTimeUnspecified && (!endMeta || endMeta.isTimeUnspecified);
  }
  return Object.assign({ range: {
    start: startMeta ? startMeta.marker : null,
    end: endMeta ? endMeta.marker : null
  }, allDay }, extra);
}
function isDateSpansEqual(span0, span1) {
  return rangesEqual(span0.range, span1.range) && span0.allDay === span1.allDay && isSpanPropsEqual(span0, span1);
}
function isSpanPropsEqual(span0, span1) {
  for (let propName in span1) {
    if (propName !== "range" && propName !== "allDay") {
      if (span0[propName] !== span1[propName]) {
        return false;
      }
    }
  }
  for (let propName in span0) {
    if (!(propName in span1)) {
      return false;
    }
  }
  return true;
}
function buildDateSpanApi(span, dateEnv) {
  return Object.assign(Object.assign({}, buildRangeApi(span.range, dateEnv, span.allDay)), { allDay: span.allDay });
}
function buildRangeApiWithTimeZone(range2, dateEnv, omitTime) {
  return Object.assign(Object.assign({}, buildRangeApi(range2, dateEnv, omitTime)), { timeZone: dateEnv.timeZone });
}
function buildRangeApi(range2, dateEnv, omitTime) {
  return {
    start: dateEnv.toDate(range2.start),
    end: dateEnv.toDate(range2.end),
    startStr: dateEnv.formatIso(range2.start, { omitTime }),
    endStr: dateEnv.formatIso(range2.end, { omitTime })
  };
}
function fabricateEventRange(dateSpan, eventUiBases, context) {
  let res = refineEventDef({ editable: false }, context);
  let def = parseEventDef(
    res.refined,
    res.extra,
    "",
    // sourceId
    dateSpan.allDay,
    true,
    // hasEnd
    context
  );
  return {
    def,
    ui: compileEventUi(def, eventUiBases),
    instance: createEventInstance(def.defId, dateSpan.range),
    range: dateSpan.range,
    isStart: true,
    isEnd: true
  };
}
function unpromisify(func, normalizedSuccessCallback, normalizedFailureCallback) {
  let isResolved = false;
  let wrappedSuccess = function(res2) {
    if (!isResolved) {
      isResolved = true;
      normalizedSuccessCallback(res2);
    }
  };
  let wrappedFailure = function(error) {
    if (!isResolved) {
      isResolved = true;
      normalizedFailureCallback(error);
    }
  };
  let res = func(wrappedSuccess, wrappedFailure);
  if (res && typeof res.then === "function") {
    res.then(wrappedSuccess, wrappedFailure);
  }
}
var JsonRequestError = class extends Error {
  constructor(message, response) {
    super(message);
    this.response = response;
  }
};
function requestJson(method, url, params) {
  method = method.toUpperCase();
  const fetchOptions = {
    method
  };
  if (method === "GET") {
    url += (url.indexOf("?") === -1 ? "?" : "&") + new URLSearchParams(params);
  } else {
    fetchOptions.body = new URLSearchParams(params);
    fetchOptions.headers = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
  }
  return fetch(url, fetchOptions).then((fetchRes) => {
    if (fetchRes.ok) {
      return fetchRes.json().then((parsedResponse) => {
        return [parsedResponse, fetchRes];
      }, () => {
        throw new JsonRequestError("Failure parsing JSON", fetchRes);
      });
    } else {
      throw new JsonRequestError("Request failed", fetchRes);
    }
  });
}
var canVGrowWithinCell;
function getCanVGrowWithinCell() {
  if (canVGrowWithinCell == null) {
    canVGrowWithinCell = computeCanVGrowWithinCell();
  }
  return canVGrowWithinCell;
}
function computeCanVGrowWithinCell() {
  if (typeof document === "undefined") {
    return true;
  }
  let el = document.createElement("div");
  el.style.position = "absolute";
  el.style.top = "0px";
  el.style.left = "0px";
  el.innerHTML = "<table><tr><td><div></div></td></tr></table>";
  el.querySelector("table").style.height = "100px";
  el.querySelector("div").style.height = "100%";
  document.body.appendChild(el);
  let div = el.querySelector("div");
  let possible = div.offsetHeight > 0;
  document.body.removeChild(el);
  return possible;
}
var CalendarRoot = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.state = {
      forPrint: false
    };
    this.handleBeforePrint = () => {
      flushSync(() => {
        this.setState({ forPrint: true });
      });
    };
    this.handleAfterPrint = () => {
      flushSync(() => {
        this.setState({ forPrint: false });
      });
    };
  }
  render() {
    let { props } = this;
    let { options } = props;
    let { forPrint } = this.state;
    let isHeightAuto = forPrint || options.height === "auto" || options.contentHeight === "auto";
    let height = !isHeightAuto && options.height != null ? options.height : "";
    let classNames = [
      "fc",
      forPrint ? "fc-media-print" : "fc-media-screen",
      `fc-direction-${options.direction}`,
      props.theme.getClass("root")
    ];
    if (!getCanVGrowWithinCell()) {
      classNames.push("fc-liquid-hack");
    }
    return props.children(classNames, height, isHeightAuto, forPrint);
  }
  componentDidMount() {
    let { emitter } = this.props;
    emitter.on("_beforeprint", this.handleBeforePrint);
    emitter.on("_afterprint", this.handleAfterPrint);
  }
  componentWillUnmount() {
    let { emitter } = this.props;
    emitter.off("_beforeprint", this.handleBeforePrint);
    emitter.off("_afterprint", this.handleAfterPrint);
  }
};
var Interaction = class {
  constructor(settings) {
    this.component = settings.component;
    this.isHitComboAllowed = settings.isHitComboAllowed || null;
  }
  destroy() {
  }
};
function parseInteractionSettings(component, input) {
  return {
    component,
    el: input.el,
    useEventCenter: input.useEventCenter != null ? input.useEventCenter : true,
    isHitComboAllowed: input.isHitComboAllowed || null
  };
}
function interactionSettingsToStore(settings) {
  return {
    [settings.component.uid]: settings
  };
}
var interactionSettingsStore = {};
var CalendarImpl = class {
  getCurrentData() {
    return this.currentDataManager.getCurrentData();
  }
  dispatch(action) {
    this.currentDataManager.dispatch(action);
  }
  get view() {
    return this.getCurrentData().viewApi;
  }
  batchRendering(callback) {
    callback();
  }
  updateSize() {
    this.trigger("_resize", true);
  }
  // Options
  // -----------------------------------------------------------------------------------------------------------------
  setOption(name, val) {
    this.dispatch({
      type: "SET_OPTION",
      optionName: name,
      rawOptionValue: val
    });
  }
  getOption(name) {
    return this.currentDataManager.currentCalendarOptionsInput[name];
  }
  getAvailableLocaleCodes() {
    return Object.keys(this.getCurrentData().availableRawLocales);
  }
  // Trigger
  // -----------------------------------------------------------------------------------------------------------------
  on(handlerName, handler) {
    let { currentDataManager } = this;
    if (currentDataManager.currentCalendarOptionsRefiners[handlerName]) {
      currentDataManager.emitter.on(handlerName, handler);
    } else {
      console.warn(`Unknown listener name '${handlerName}'`);
    }
  }
  off(handlerName, handler) {
    this.currentDataManager.emitter.off(handlerName, handler);
  }
  // not meant for public use
  trigger(handlerName, ...args) {
    this.currentDataManager.emitter.trigger(handlerName, ...args);
  }
  // View
  // -----------------------------------------------------------------------------------------------------------------
  changeView(viewType, dateOrRange) {
    this.batchRendering(() => {
      this.unselect();
      if (dateOrRange) {
        if (dateOrRange.start && dateOrRange.end) {
          this.dispatch({
            type: "CHANGE_VIEW_TYPE",
            viewType
          });
          this.dispatch({
            type: "SET_OPTION",
            optionName: "visibleRange",
            rawOptionValue: dateOrRange
          });
        } else {
          let { dateEnv } = this.getCurrentData();
          this.dispatch({
            type: "CHANGE_VIEW_TYPE",
            viewType,
            dateMarker: dateEnv.createMarker(dateOrRange)
          });
        }
      } else {
        this.dispatch({
          type: "CHANGE_VIEW_TYPE",
          viewType
        });
      }
    });
  }
  // Forces navigation to a view for the given date.
  // `viewType` can be a specific view name or a generic one like "week" or "day".
  // needs to change
  zoomTo(dateMarker, viewType) {
    let state = this.getCurrentData();
    let spec;
    viewType = viewType || "day";
    spec = state.viewSpecs[viewType] || this.getUnitViewSpec(viewType);
    this.unselect();
    if (spec) {
      this.dispatch({
        type: "CHANGE_VIEW_TYPE",
        viewType: spec.type,
        dateMarker
      });
    } else {
      this.dispatch({
        type: "CHANGE_DATE",
        dateMarker
      });
    }
  }
  // Given a duration singular unit, like "week" or "day", finds a matching view spec.
  // Preference is given to views that have corresponding buttons.
  getUnitViewSpec(unit) {
    let { viewSpecs, toolbarConfig } = this.getCurrentData();
    let viewTypes = [].concat(toolbarConfig.header ? toolbarConfig.header.viewsWithButtons : [], toolbarConfig.footer ? toolbarConfig.footer.viewsWithButtons : []);
    let i3;
    let spec;
    for (let viewType in viewSpecs) {
      viewTypes.push(viewType);
    }
    for (i3 = 0; i3 < viewTypes.length; i3 += 1) {
      spec = viewSpecs[viewTypes[i3]];
      if (spec) {
        if (spec.singleUnit === unit) {
          return spec;
        }
      }
    }
    return null;
  }
  // Current Date
  // -----------------------------------------------------------------------------------------------------------------
  prev() {
    this.unselect();
    this.dispatch({ type: "PREV" });
  }
  next() {
    this.unselect();
    this.dispatch({ type: "NEXT" });
  }
  prevYear() {
    let state = this.getCurrentData();
    this.unselect();
    this.dispatch({
      type: "CHANGE_DATE",
      dateMarker: state.dateEnv.addYears(state.currentDate, -1)
    });
  }
  nextYear() {
    let state = this.getCurrentData();
    this.unselect();
    this.dispatch({
      type: "CHANGE_DATE",
      dateMarker: state.dateEnv.addYears(state.currentDate, 1)
    });
  }
  today() {
    let state = this.getCurrentData();
    this.unselect();
    this.dispatch({
      type: "CHANGE_DATE",
      dateMarker: getNow(state.calendarOptions.now, state.dateEnv)
    });
  }
  gotoDate(zonedDateInput) {
    let state = this.getCurrentData();
    this.unselect();
    this.dispatch({
      type: "CHANGE_DATE",
      dateMarker: state.dateEnv.createMarker(zonedDateInput)
    });
  }
  incrementDate(deltaInput) {
    let state = this.getCurrentData();
    let delta = createDuration(deltaInput);
    if (delta) {
      this.unselect();
      this.dispatch({
        type: "CHANGE_DATE",
        dateMarker: state.dateEnv.add(state.currentDate, delta)
      });
    }
  }
  getDate() {
    let state = this.getCurrentData();
    return state.dateEnv.toDate(state.currentDate);
  }
  // Date Formatting Utils
  // -----------------------------------------------------------------------------------------------------------------
  formatDate(d2, formatter) {
    let { dateEnv } = this.getCurrentData();
    return dateEnv.format(dateEnv.createMarker(d2), createFormatter(formatter));
  }
  // `settings` is for formatter AND isEndExclusive
  formatRange(d0, d1, settings) {
    let { dateEnv } = this.getCurrentData();
    return dateEnv.formatRange(dateEnv.createMarker(d0), dateEnv.createMarker(d1), createFormatter(settings), settings);
  }
  formatIso(d2, omitTime) {
    let { dateEnv } = this.getCurrentData();
    return dateEnv.formatIso(dateEnv.createMarker(d2), { omitTime });
  }
  // Date Selection / Event Selection / DayClick
  // -----------------------------------------------------------------------------------------------------------------
  select(dateOrObj, endDate) {
    let selectionInput;
    if (endDate == null) {
      if (dateOrObj.start != null) {
        selectionInput = dateOrObj;
      } else {
        selectionInput = {
          start: dateOrObj,
          end: null
        };
      }
    } else {
      selectionInput = {
        start: dateOrObj,
        end: endDate
      };
    }
    let state = this.getCurrentData();
    let selection = parseDateSpan(selectionInput, state.dateEnv, createDuration({ days: 1 }));
    if (selection) {
      this.dispatch({ type: "SELECT_DATES", selection });
      triggerDateSelect(selection, null, state);
    }
  }
  unselect(pev) {
    let state = this.getCurrentData();
    if (state.dateSelection) {
      this.dispatch({ type: "UNSELECT_DATES" });
      triggerDateUnselect(pev, state);
    }
  }
  // Public Events API
  // -----------------------------------------------------------------------------------------------------------------
  addEvent(eventInput, sourceInput) {
    if (eventInput instanceof EventImpl) {
      let def = eventInput._def;
      let instance = eventInput._instance;
      let currentData = this.getCurrentData();
      if (!currentData.eventStore.defs[def.defId]) {
        this.dispatch({
          type: "ADD_EVENTS",
          eventStore: eventTupleToStore({ def, instance })
          // TODO: better util for two args?
        });
        this.triggerEventAdd(eventInput);
      }
      return eventInput;
    }
    let state = this.getCurrentData();
    let eventSource;
    if (sourceInput instanceof EventSourceImpl) {
      eventSource = sourceInput.internalEventSource;
    } else if (typeof sourceInput === "boolean") {
      if (sourceInput) {
        [eventSource] = hashValuesToArray(state.eventSources);
      }
    } else if (sourceInput != null) {
      let sourceApi = this.getEventSourceById(sourceInput);
      if (!sourceApi) {
        console.warn(`Could not find an event source with ID "${sourceInput}"`);
        return null;
      }
      eventSource = sourceApi.internalEventSource;
    }
    let tuple = parseEvent(eventInput, eventSource, state, false);
    if (tuple) {
      let newEventApi = new EventImpl(state, tuple.def, tuple.def.recurringDef ? null : tuple.instance);
      this.dispatch({
        type: "ADD_EVENTS",
        eventStore: eventTupleToStore(tuple)
      });
      this.triggerEventAdd(newEventApi);
      return newEventApi;
    }
    return null;
  }
  triggerEventAdd(eventApi) {
    let { emitter } = this.getCurrentData();
    emitter.trigger("eventAdd", {
      event: eventApi,
      relatedEvents: [],
      revert: () => {
        this.dispatch({
          type: "REMOVE_EVENTS",
          eventStore: eventApiToStore(eventApi)
        });
      }
    });
  }
  // TODO: optimize
  getEventById(id) {
    let state = this.getCurrentData();
    let { defs, instances } = state.eventStore;
    id = String(id);
    for (let defId in defs) {
      let def = defs[defId];
      if (def.publicId === id) {
        if (def.recurringDef) {
          return new EventImpl(state, def, null);
        }
        for (let instanceId in instances) {
          let instance = instances[instanceId];
          if (instance.defId === def.defId) {
            return new EventImpl(state, def, instance);
          }
        }
      }
    }
    return null;
  }
  getEvents() {
    let currentData = this.getCurrentData();
    return buildEventApis(currentData.eventStore, currentData);
  }
  removeAllEvents() {
    this.dispatch({ type: "REMOVE_ALL_EVENTS" });
  }
  // Public Event Sources API
  // -----------------------------------------------------------------------------------------------------------------
  getEventSources() {
    let state = this.getCurrentData();
    let sourceHash = state.eventSources;
    let sourceApis = [];
    for (let internalId in sourceHash) {
      sourceApis.push(new EventSourceImpl(state, sourceHash[internalId]));
    }
    return sourceApis;
  }
  getEventSourceById(id) {
    let state = this.getCurrentData();
    let sourceHash = state.eventSources;
    id = String(id);
    for (let sourceId in sourceHash) {
      if (sourceHash[sourceId].publicId === id) {
        return new EventSourceImpl(state, sourceHash[sourceId]);
      }
    }
    return null;
  }
  addEventSource(sourceInput) {
    let state = this.getCurrentData();
    if (sourceInput instanceof EventSourceImpl) {
      if (!state.eventSources[sourceInput.internalEventSource.sourceId]) {
        this.dispatch({
          type: "ADD_EVENT_SOURCES",
          sources: [sourceInput.internalEventSource]
        });
      }
      return sourceInput;
    }
    let eventSource = parseEventSource(sourceInput, state);
    if (eventSource) {
      this.dispatch({ type: "ADD_EVENT_SOURCES", sources: [eventSource] });
      return new EventSourceImpl(state, eventSource);
    }
    return null;
  }
  removeAllEventSources() {
    this.dispatch({ type: "REMOVE_ALL_EVENT_SOURCES" });
  }
  refetchEvents() {
    this.dispatch({ type: "FETCH_EVENT_SOURCES", isRefetch: true });
  }
  // Scroll
  // -----------------------------------------------------------------------------------------------------------------
  scrollToTime(timeInput) {
    let time = createDuration(timeInput);
    if (time) {
      this.trigger("_scrollRequest", { time });
    }
  }
};
function pointInsideRect(point, rect) {
  return point.left >= rect.left && point.left < rect.right && point.top >= rect.top && point.top < rect.bottom;
}
function intersectRects(rect1, rect2) {
  let res = {
    left: Math.max(rect1.left, rect2.left),
    right: Math.min(rect1.right, rect2.right),
    top: Math.max(rect1.top, rect2.top),
    bottom: Math.min(rect1.bottom, rect2.bottom)
  };
  if (res.left < res.right && res.top < res.bottom) {
    return res;
  }
  return false;
}
function constrainPoint(point, rect) {
  return {
    left: Math.min(Math.max(point.left, rect.left), rect.right),
    top: Math.min(Math.max(point.top, rect.top), rect.bottom)
  };
}
function getRectCenter(rect) {
  return {
    left: (rect.left + rect.right) / 2,
    top: (rect.top + rect.bottom) / 2
  };
}
function diffPoints(point1, point2) {
  return {
    left: point1.left - point2.left,
    top: point1.top - point2.top
  };
}
var EMPTY_EVENT_STORE = createEmptyEventStore();
var Splitter = class {
  constructor() {
    this.getKeysForEventDefs = memoize(this._getKeysForEventDefs);
    this.splitDateSelection = memoize(this._splitDateSpan);
    this.splitEventStore = memoize(this._splitEventStore);
    this.splitIndividualUi = memoize(this._splitIndividualUi);
    this.splitEventDrag = memoize(this._splitInteraction);
    this.splitEventResize = memoize(this._splitInteraction);
    this.eventUiBuilders = {};
  }
  splitProps(props) {
    let keyInfos = this.getKeyInfo(props);
    let defKeys = this.getKeysForEventDefs(props.eventStore);
    let dateSelections = this.splitDateSelection(props.dateSelection);
    let individualUi = this.splitIndividualUi(props.eventUiBases, defKeys);
    let eventStores = this.splitEventStore(props.eventStore, defKeys);
    let eventDrags = this.splitEventDrag(props.eventDrag);
    let eventResizes = this.splitEventResize(props.eventResize);
    let splitProps = {};
    this.eventUiBuilders = mapHash(keyInfos, (info, key) => this.eventUiBuilders[key] || memoize(buildEventUiForKey));
    for (let key in keyInfos) {
      let keyInfo = keyInfos[key];
      let eventStore = eventStores[key] || EMPTY_EVENT_STORE;
      let buildEventUi = this.eventUiBuilders[key];
      splitProps[key] = {
        businessHours: keyInfo.businessHours || props.businessHours,
        dateSelection: dateSelections[key] || null,
        eventStore,
        eventUiBases: buildEventUi(props.eventUiBases[""], keyInfo.ui, individualUi[key]),
        eventSelection: eventStore.instances[props.eventSelection] ? props.eventSelection : "",
        eventDrag: eventDrags[key] || null,
        eventResize: eventResizes[key] || null
      };
    }
    return splitProps;
  }
  _splitDateSpan(dateSpan) {
    let dateSpans = {};
    if (dateSpan) {
      let keys = this.getKeysForDateSpan(dateSpan);
      for (let key of keys) {
        dateSpans[key] = dateSpan;
      }
    }
    return dateSpans;
  }
  _getKeysForEventDefs(eventStore) {
    return mapHash(eventStore.defs, (eventDef) => this.getKeysForEventDef(eventDef));
  }
  _splitEventStore(eventStore, defKeys) {
    let { defs, instances } = eventStore;
    let splitStores = {};
    for (let defId in defs) {
      for (let key of defKeys[defId]) {
        if (!splitStores[key]) {
          splitStores[key] = createEmptyEventStore();
        }
        splitStores[key].defs[defId] = defs[defId];
      }
    }
    for (let instanceId in instances) {
      let instance = instances[instanceId];
      for (let key of defKeys[instance.defId]) {
        if (splitStores[key]) {
          splitStores[key].instances[instanceId] = instance;
        }
      }
    }
    return splitStores;
  }
  _splitIndividualUi(eventUiBases, defKeys) {
    let splitHashes = {};
    for (let defId in eventUiBases) {
      if (defId) {
        for (let key of defKeys[defId]) {
          if (!splitHashes[key]) {
            splitHashes[key] = {};
          }
          splitHashes[key][defId] = eventUiBases[defId];
        }
      }
    }
    return splitHashes;
  }
  _splitInteraction(interaction) {
    let splitStates = {};
    if (interaction) {
      let affectedStores = this._splitEventStore(interaction.affectedEvents, this._getKeysForEventDefs(interaction.affectedEvents));
      let mutatedKeysByDefId = this._getKeysForEventDefs(interaction.mutatedEvents);
      let mutatedStores = this._splitEventStore(interaction.mutatedEvents, mutatedKeysByDefId);
      let populate = (key) => {
        if (!splitStates[key]) {
          splitStates[key] = {
            affectedEvents: affectedStores[key] || EMPTY_EVENT_STORE,
            mutatedEvents: mutatedStores[key] || EMPTY_EVENT_STORE,
            isEvent: interaction.isEvent
          };
        }
      };
      for (let key in affectedStores) {
        populate(key);
      }
      for (let key in mutatedStores) {
        populate(key);
      }
    }
    return splitStates;
  }
};
function buildEventUiForKey(allUi, eventUiForKey, individualUi) {
  let baseParts = [];
  if (allUi) {
    baseParts.push(allUi);
  }
  if (eventUiForKey) {
    baseParts.push(eventUiForKey);
  }
  let stuff = {
    "": combineEventUis(baseParts)
  };
  if (individualUi) {
    Object.assign(stuff, individualUi);
  }
  return stuff;
}
function getDateMeta(date, todayRange, nowDate, dateProfile) {
  return {
    dow: date.getUTCDay(),
    isDisabled: Boolean(dateProfile && !rangeContainsMarker(dateProfile.activeRange, date)),
    isOther: Boolean(dateProfile && !rangeContainsMarker(dateProfile.currentRange, date)),
    isToday: Boolean(todayRange && rangeContainsMarker(todayRange, date)),
    isPast: Boolean(nowDate ? date < nowDate : todayRange ? date < todayRange.start : false),
    isFuture: Boolean(nowDate ? date > nowDate : todayRange ? date >= todayRange.end : false)
  };
}
function getDayClassNames(meta, theme) {
  let classNames = [
    "fc-day",
    `fc-day-${DAY_IDS[meta.dow]}`
  ];
  if (meta.isDisabled) {
    classNames.push("fc-day-disabled");
  } else {
    if (meta.isToday) {
      classNames.push("fc-day-today");
      classNames.push(theme.getClass("today"));
    }
    if (meta.isPast) {
      classNames.push("fc-day-past");
    }
    if (meta.isFuture) {
      classNames.push("fc-day-future");
    }
    if (meta.isOther) {
      classNames.push("fc-day-other");
    }
  }
  return classNames;
}
var DAY_FORMAT = createFormatter({ year: "numeric", month: "long", day: "numeric" });
var WEEK_FORMAT = createFormatter({ week: "long" });
function buildNavLinkAttrs(context, dateMarker, viewType = "day", isTabbable = true) {
  const { dateEnv, options, calendarApi } = context;
  let dateStr = dateEnv.format(dateMarker, viewType === "week" ? WEEK_FORMAT : DAY_FORMAT);
  if (options.navLinks) {
    let zonedDate = dateEnv.toDate(dateMarker);
    const handleInteraction = (ev) => {
      let customAction = viewType === "day" ? options.navLinkDayClick : viewType === "week" ? options.navLinkWeekClick : null;
      if (typeof customAction === "function") {
        customAction.call(calendarApi, dateEnv.toDate(dateMarker), ev);
      } else {
        if (typeof customAction === "string") {
          viewType = customAction;
        }
        calendarApi.zoomTo(dateMarker, viewType);
      }
    };
    return Object.assign({ title: formatWithOrdinals(options.navLinkHint, [dateStr, zonedDate], dateStr), "data-navlink": "" }, isTabbable ? createAriaClickAttrs(handleInteraction) : { onClick: handleInteraction });
  }
  return { "aria-label": dateStr };
}
var _isRtlScrollbarOnLeft = null;
function getIsRtlScrollbarOnLeft() {
  if (_isRtlScrollbarOnLeft === null) {
    _isRtlScrollbarOnLeft = computeIsRtlScrollbarOnLeft();
  }
  return _isRtlScrollbarOnLeft;
}
function computeIsRtlScrollbarOnLeft() {
  let outerEl = document.createElement("div");
  applyStyle(outerEl, {
    position: "absolute",
    top: -1e3,
    left: 0,
    border: 0,
    padding: 0,
    overflow: "scroll",
    direction: "rtl"
  });
  outerEl.innerHTML = "<div></div>";
  document.body.appendChild(outerEl);
  let innerEl = outerEl.firstChild;
  let res = innerEl.getBoundingClientRect().left > outerEl.getBoundingClientRect().left;
  removeElement(outerEl);
  return res;
}
var _scrollbarWidths;
function getScrollbarWidths() {
  if (!_scrollbarWidths) {
    _scrollbarWidths = computeScrollbarWidths();
  }
  return _scrollbarWidths;
}
function computeScrollbarWidths() {
  let el = document.createElement("div");
  el.style.overflow = "scroll";
  el.style.position = "absolute";
  el.style.top = "-9999px";
  el.style.left = "-9999px";
  document.body.appendChild(el);
  let res = computeScrollbarWidthsForEl(el);
  document.body.removeChild(el);
  return res;
}
function computeScrollbarWidthsForEl(el) {
  return {
    x: el.offsetHeight - el.clientHeight,
    y: el.offsetWidth - el.clientWidth
  };
}
function computeEdges(el, getPadding = false) {
  let computedStyle = window.getComputedStyle(el);
  let borderLeft = parseInt(computedStyle.borderLeftWidth, 10) || 0;
  let borderRight = parseInt(computedStyle.borderRightWidth, 10) || 0;
  let borderTop = parseInt(computedStyle.borderTopWidth, 10) || 0;
  let borderBottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;
  let badScrollbarWidths = computeScrollbarWidthsForEl(el);
  let scrollbarLeftRight = badScrollbarWidths.y - borderLeft - borderRight;
  let scrollbarBottom = badScrollbarWidths.x - borderTop - borderBottom;
  let res = {
    borderLeft,
    borderRight,
    borderTop,
    borderBottom,
    scrollbarBottom,
    scrollbarLeft: 0,
    scrollbarRight: 0
  };
  if (getIsRtlScrollbarOnLeft() && computedStyle.direction === "rtl") {
    res.scrollbarLeft = scrollbarLeftRight;
  } else {
    res.scrollbarRight = scrollbarLeftRight;
  }
  if (getPadding) {
    res.paddingLeft = parseInt(computedStyle.paddingLeft, 10) || 0;
    res.paddingRight = parseInt(computedStyle.paddingRight, 10) || 0;
    res.paddingTop = parseInt(computedStyle.paddingTop, 10) || 0;
    res.paddingBottom = parseInt(computedStyle.paddingBottom, 10) || 0;
  }
  return res;
}
function computeInnerRect(el, goWithinPadding = false, doFromWindowViewport) {
  let outerRect = doFromWindowViewport ? el.getBoundingClientRect() : computeRect(el);
  let edges = computeEdges(el, goWithinPadding);
  let res = {
    left: outerRect.left + edges.borderLeft + edges.scrollbarLeft,
    right: outerRect.right - edges.borderRight - edges.scrollbarRight,
    top: outerRect.top + edges.borderTop,
    bottom: outerRect.bottom - edges.borderBottom - edges.scrollbarBottom
  };
  if (goWithinPadding) {
    res.left += edges.paddingLeft;
    res.right -= edges.paddingRight;
    res.top += edges.paddingTop;
    res.bottom -= edges.paddingBottom;
  }
  return res;
}
function computeRect(el) {
  let rect = el.getBoundingClientRect();
  return {
    left: rect.left + window.scrollX,
    top: rect.top + window.scrollY,
    right: rect.right + window.scrollX,
    bottom: rect.bottom + window.scrollY
  };
}
function computeClippedClientRect(el) {
  let clippingParents = getClippingParents(el);
  let rect = el.getBoundingClientRect();
  for (let clippingParent of clippingParents) {
    let intersection = intersectRects(rect, clippingParent.getBoundingClientRect());
    if (intersection) {
      rect = intersection;
    } else {
      return null;
    }
  }
  return rect;
}
function getClippingParents(el) {
  let parents = [];
  while (el instanceof HTMLElement) {
    let computedStyle = window.getComputedStyle(el);
    if (computedStyle.position === "fixed") {
      break;
    }
    if (/(auto|scroll)/.test(computedStyle.overflow + computedStyle.overflowY + computedStyle.overflowX)) {
      parents.push(el);
    }
    el = el.parentNode;
  }
  return parents;
}
var PositionCache = class {
  constructor(originEl, els, isHorizontal, isVertical) {
    this.els = els;
    let originClientRect = this.originClientRect = originEl.getBoundingClientRect();
    if (isHorizontal) {
      this.buildElHorizontals(originClientRect.left);
    }
    if (isVertical) {
      this.buildElVerticals(originClientRect.top);
    }
  }
  // Populates the left/right internal coordinate arrays
  buildElHorizontals(originClientLeft) {
    let lefts = [];
    let rights = [];
    for (let el of this.els) {
      let rect = el.getBoundingClientRect();
      lefts.push(rect.left - originClientLeft);
      rights.push(rect.right - originClientLeft);
    }
    this.lefts = lefts;
    this.rights = rights;
  }
  // Populates the top/bottom internal coordinate arrays
  buildElVerticals(originClientTop) {
    let tops = [];
    let bottoms = [];
    for (let el of this.els) {
      let rect = el.getBoundingClientRect();
      tops.push(rect.top - originClientTop);
      bottoms.push(rect.bottom - originClientTop);
    }
    this.tops = tops;
    this.bottoms = bottoms;
  }
  // Given a left offset (from document left), returns the index of the el that it horizontally intersects.
  // If no intersection is made, returns undefined.
  leftToIndex(leftPosition) {
    let { lefts, rights } = this;
    let len = lefts.length;
    let i3;
    for (i3 = 0; i3 < len; i3 += 1) {
      if (leftPosition >= lefts[i3] && leftPosition < rights[i3]) {
        return i3;
      }
    }
    return void 0;
  }
  // Given a top offset (from document top), returns the index of the el that it vertically intersects.
  // If no intersection is made, returns undefined.
  topToIndex(topPosition) {
    let { tops, bottoms } = this;
    let len = tops.length;
    let i3;
    for (i3 = 0; i3 < len; i3 += 1) {
      if (topPosition >= tops[i3] && topPosition < bottoms[i3]) {
        return i3;
      }
    }
    return void 0;
  }
  // Gets the width of the element at the given index
  getWidth(leftIndex) {
    return this.rights[leftIndex] - this.lefts[leftIndex];
  }
  // Gets the height of the element at the given index
  getHeight(topIndex) {
    return this.bottoms[topIndex] - this.tops[topIndex];
  }
  similarTo(otherCache) {
    return similarNumArrays(this.tops || [], otherCache.tops || []) && similarNumArrays(this.bottoms || [], otherCache.bottoms || []) && similarNumArrays(this.lefts || [], otherCache.lefts || []) && similarNumArrays(this.rights || [], otherCache.rights || []);
  }
};
function similarNumArrays(a3, b3) {
  const len = a3.length;
  if (len !== b3.length) {
    return false;
  }
  for (let i3 = 0; i3 < len; i3++) {
    if (Math.round(a3[i3]) !== Math.round(b3[i3])) {
      return false;
    }
  }
  return true;
}
var ScrollController = class {
  getMaxScrollTop() {
    return this.getScrollHeight() - this.getClientHeight();
  }
  getMaxScrollLeft() {
    return this.getScrollWidth() - this.getClientWidth();
  }
  canScrollVertically() {
    return this.getMaxScrollTop() > 0;
  }
  canScrollHorizontally() {
    return this.getMaxScrollLeft() > 0;
  }
  canScrollUp() {
    return this.getScrollTop() > 0;
  }
  canScrollDown() {
    return this.getScrollTop() < this.getMaxScrollTop();
  }
  canScrollLeft() {
    return this.getScrollLeft() > 0;
  }
  canScrollRight() {
    return this.getScrollLeft() < this.getMaxScrollLeft();
  }
};
var ElementScrollController = class extends ScrollController {
  constructor(el) {
    super();
    this.el = el;
  }
  getScrollTop() {
    return this.el.scrollTop;
  }
  getScrollLeft() {
    return this.el.scrollLeft;
  }
  setScrollTop(top) {
    this.el.scrollTop = top;
  }
  setScrollLeft(left) {
    this.el.scrollLeft = left;
  }
  getScrollWidth() {
    return this.el.scrollWidth;
  }
  getScrollHeight() {
    return this.el.scrollHeight;
  }
  getClientHeight() {
    return this.el.clientHeight;
  }
  getClientWidth() {
    return this.el.clientWidth;
  }
};
var WindowScrollController = class extends ScrollController {
  getScrollTop() {
    return window.scrollY;
  }
  getScrollLeft() {
    return window.scrollX;
  }
  setScrollTop(n2) {
    window.scroll(window.scrollX, n2);
  }
  setScrollLeft(n2) {
    window.scroll(n2, window.scrollY);
  }
  getScrollWidth() {
    return document.documentElement.scrollWidth;
  }
  getScrollHeight() {
    return document.documentElement.scrollHeight;
  }
  getClientHeight() {
    return document.documentElement.clientHeight;
  }
  getClientWidth() {
    return document.documentElement.clientWidth;
  }
};
var DateComponent = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.uid = guid();
  }
  // Hit System
  // -----------------------------------------------------------------------------------------------------------------
  prepareHits() {
  }
  queryHit(positionLeft, positionTop, elWidth, elHeight) {
    return null;
  }
  // Pointer Interaction Utils
  // -----------------------------------------------------------------------------------------------------------------
  isValidSegDownEl(el) {
    return !this.props.eventDrag && // HACK
    !this.props.eventResize && // HACK
    !elementClosest(el, ".fc-event-mirror");
  }
  isValidDateDownEl(el) {
    return !elementClosest(el, ".fc-event:not(.fc-bg-event)") && !elementClosest(el, ".fc-more-link") && // a "more.." link
    !elementClosest(el, "a[data-navlink]") && // a clickable nav link
    !elementClosest(el, ".fc-popover");
  }
};
var SegHierarchy = class {
  constructor(getEntryThickness = (entry) => {
    return entry.thickness || 1;
  }) {
    this.getEntryThickness = getEntryThickness;
    this.strictOrder = false;
    this.allowReslicing = false;
    this.maxCoord = -1;
    this.maxStackCnt = -1;
    this.levelCoords = [];
    this.entriesByLevel = [];
    this.stackCnts = {};
  }
  addSegs(inputs) {
    let hiddenEntries = [];
    for (let input of inputs) {
      this.insertEntry(input, hiddenEntries);
    }
    return hiddenEntries;
  }
  insertEntry(entry, hiddenEntries) {
    let insertion = this.findInsertion(entry);
    if (this.isInsertionValid(insertion, entry)) {
      this.insertEntryAt(entry, insertion);
    } else {
      this.handleInvalidInsertion(insertion, entry, hiddenEntries);
    }
  }
  isInsertionValid(insertion, entry) {
    return (this.maxCoord === -1 || insertion.levelCoord + this.getEntryThickness(entry) <= this.maxCoord) && (this.maxStackCnt === -1 || insertion.stackCnt < this.maxStackCnt);
  }
  handleInvalidInsertion(insertion, entry, hiddenEntries) {
    if (this.allowReslicing && insertion.touchingEntry) {
      const hiddenEntry = Object.assign(Object.assign({}, entry), { span: intersectSpans(entry.span, insertion.touchingEntry.span) });
      hiddenEntries.push(hiddenEntry);
      this.splitEntry(entry, insertion.touchingEntry, hiddenEntries);
    } else {
      hiddenEntries.push(entry);
    }
  }
  /*
  Does NOT add what hit the `barrier` into hiddenEntries. Should already be done.
  */
  splitEntry(entry, barrier, hiddenEntries) {
    let entrySpan = entry.span;
    let barrierSpan = barrier.span;
    if (entrySpan.start < barrierSpan.start) {
      this.insertEntry({
        index: entry.index,
        thickness: entry.thickness,
        span: { start: entrySpan.start, end: barrierSpan.start }
      }, hiddenEntries);
    }
    if (entrySpan.end > barrierSpan.end) {
      this.insertEntry({
        index: entry.index,
        thickness: entry.thickness,
        span: { start: barrierSpan.end, end: entrySpan.end }
      }, hiddenEntries);
    }
  }
  insertEntryAt(entry, insertion) {
    let { entriesByLevel, levelCoords } = this;
    if (insertion.lateral === -1) {
      insertAt(levelCoords, insertion.level, insertion.levelCoord);
      insertAt(entriesByLevel, insertion.level, [entry]);
    } else {
      insertAt(entriesByLevel[insertion.level], insertion.lateral, entry);
    }
    this.stackCnts[buildEntryKey(entry)] = insertion.stackCnt;
  }
  /*
  does not care about limits
  */
  findInsertion(newEntry) {
    let { levelCoords, entriesByLevel, strictOrder, stackCnts } = this;
    let levelCnt = levelCoords.length;
    let candidateCoord = 0;
    let touchingLevel = -1;
    let touchingLateral = -1;
    let touchingEntry = null;
    let stackCnt = 0;
    for (let trackingLevel = 0; trackingLevel < levelCnt; trackingLevel += 1) {
      const trackingCoord = levelCoords[trackingLevel];
      if (!strictOrder && trackingCoord >= candidateCoord + this.getEntryThickness(newEntry)) {
        break;
      }
      let trackingEntries = entriesByLevel[trackingLevel];
      let trackingEntry;
      let searchRes = binarySearch(trackingEntries, newEntry.span.start, getEntrySpanEnd);
      let lateralIndex = searchRes[0] + searchRes[1];
      while (
        // loop through entries that horizontally intersect
        (trackingEntry = trackingEntries[lateralIndex]) && // but not past the whole entry list
        trackingEntry.span.start < newEntry.span.end
      ) {
        let trackingEntryBottom = trackingCoord + this.getEntryThickness(trackingEntry);
        if (trackingEntryBottom > candidateCoord) {
          candidateCoord = trackingEntryBottom;
          touchingEntry = trackingEntry;
          touchingLevel = trackingLevel;
          touchingLateral = lateralIndex;
        }
        if (trackingEntryBottom === candidateCoord) {
          stackCnt = Math.max(stackCnt, stackCnts[buildEntryKey(trackingEntry)] + 1);
        }
        lateralIndex += 1;
      }
    }
    let destLevel = 0;
    if (touchingEntry) {
      destLevel = touchingLevel + 1;
      while (destLevel < levelCnt && levelCoords[destLevel] < candidateCoord) {
        destLevel += 1;
      }
    }
    let destLateral = -1;
    if (destLevel < levelCnt && levelCoords[destLevel] === candidateCoord) {
      destLateral = binarySearch(entriesByLevel[destLevel], newEntry.span.end, getEntrySpanEnd)[0];
    }
    return {
      touchingLevel,
      touchingLateral,
      touchingEntry,
      stackCnt,
      levelCoord: candidateCoord,
      level: destLevel,
      lateral: destLateral
    };
  }
  // sorted by levelCoord (lowest to highest)
  toRects() {
    let { entriesByLevel, levelCoords } = this;
    let levelCnt = entriesByLevel.length;
    let rects = [];
    for (let level = 0; level < levelCnt; level += 1) {
      let entries = entriesByLevel[level];
      let levelCoord = levelCoords[level];
      for (let entry of entries) {
        rects.push(Object.assign(Object.assign({}, entry), { thickness: this.getEntryThickness(entry), levelCoord }));
      }
    }
    return rects;
  }
};
function getEntrySpanEnd(entry) {
  return entry.span.end;
}
function buildEntryKey(entry) {
  return entry.index + ":" + entry.span.start;
}
function groupIntersectingEntries(entries) {
  let merges = [];
  for (let entry of entries) {
    let filteredMerges = [];
    let hungryMerge = {
      span: entry.span,
      entries: [entry]
    };
    for (let merge of merges) {
      if (intersectSpans(merge.span, hungryMerge.span)) {
        hungryMerge = {
          entries: merge.entries.concat(hungryMerge.entries),
          span: joinSpans(merge.span, hungryMerge.span)
        };
      } else {
        filteredMerges.push(merge);
      }
    }
    filteredMerges.push(hungryMerge);
    merges = filteredMerges;
  }
  return merges;
}
function joinSpans(span0, span1) {
  return {
    start: Math.min(span0.start, span1.start),
    end: Math.max(span0.end, span1.end)
  };
}
function intersectSpans(span0, span1) {
  let start = Math.max(span0.start, span1.start);
  let end = Math.min(span0.end, span1.end);
  if (start < end) {
    return { start, end };
  }
  return null;
}
function insertAt(arr, index8, item) {
  arr.splice(index8, 0, item);
}
function binarySearch(a3, searchVal, getItemVal) {
  let startIndex = 0;
  let endIndex = a3.length;
  if (!endIndex || searchVal < getItemVal(a3[startIndex])) {
    return [0, 0];
  }
  if (searchVal > getItemVal(a3[endIndex - 1])) {
    return [endIndex, 0];
  }
  while (startIndex < endIndex) {
    let middleIndex = Math.floor(startIndex + (endIndex - startIndex) / 2);
    let middleVal = getItemVal(a3[middleIndex]);
    if (searchVal < middleVal) {
      endIndex = middleIndex;
    } else if (searchVal > middleVal) {
      startIndex = middleIndex + 1;
    } else {
      return [middleIndex, 1];
    }
  }
  return [startIndex, 0];
}
var ElementDragging = class {
  constructor(el, selector) {
    this.emitter = new Emitter();
  }
  destroy() {
  }
  setMirrorIsVisible(bool) {
  }
  setMirrorNeedsRevert(bool) {
  }
  setAutoScrollEnabled(bool) {
  }
};
var config = {};
function computeFallbackHeaderFormat(datesRepDistinctDays, dayCnt) {
  if (!datesRepDistinctDays || dayCnt > 10) {
    return createFormatter({ weekday: "short" });
  }
  if (dayCnt > 1) {
    return createFormatter({ weekday: "short", month: "numeric", day: "numeric", omitCommas: true });
  }
  return createFormatter({ weekday: "long" });
}
var CLASS_NAME = "fc-col-header-cell";
function renderInner$1(renderProps) {
  return renderProps.text;
}
var TableDateCell = class extends BaseComponent {
  render() {
    let { dateEnv, options, theme, viewApi } = this.context;
    let { props } = this;
    let { date, dateProfile } = props;
    let dayMeta = getDateMeta(date, props.todayRange, null, dateProfile);
    let classNames = [CLASS_NAME].concat(getDayClassNames(dayMeta, theme));
    let text = dateEnv.format(date, props.dayHeaderFormat);
    let navLinkAttrs = !dayMeta.isDisabled && props.colCnt > 1 ? buildNavLinkAttrs(this.context, date) : {};
    let renderProps = Object.assign(Object.assign(Object.assign({ date: dateEnv.toDate(date), view: viewApi }, props.extraRenderProps), { text }), dayMeta);
    return y(ContentContainer, { elTag: "th", elClasses: classNames, elAttrs: Object.assign({ role: "columnheader", colSpan: props.colSpan, "data-date": !dayMeta.isDisabled ? formatDayString(date) : void 0 }, props.extraDataAttrs), renderProps, generatorName: "dayHeaderContent", customGenerator: options.dayHeaderContent, defaultGenerator: renderInner$1, classNameGenerator: options.dayHeaderClassNames, didMount: options.dayHeaderDidMount, willUnmount: options.dayHeaderWillUnmount }, (InnerContainer) => y("div", { className: "fc-scrollgrid-sync-inner" }, !dayMeta.isDisabled && y(InnerContainer, { elTag: "a", elAttrs: navLinkAttrs, elClasses: [
      "fc-col-header-cell-cushion",
      props.isSticky && "fc-sticky"
    ] })));
  }
};
var WEEKDAY_FORMAT = createFormatter({ weekday: "long" });
var TableDowCell = class extends BaseComponent {
  render() {
    let { props } = this;
    let { dateEnv, theme, viewApi, options } = this.context;
    let date = addDays(new Date(2592e5), props.dow);
    let dateMeta = {
      dow: props.dow,
      isDisabled: false,
      isFuture: false,
      isPast: false,
      isToday: false,
      isOther: false
    };
    let text = dateEnv.format(date, props.dayHeaderFormat);
    let renderProps = Object.assign(Object.assign(Object.assign(Object.assign({
      // TODO: make this public?
      date
    }, dateMeta), { view: viewApi }), props.extraRenderProps), { text });
    return y(ContentContainer, { elTag: "th", elClasses: [
      CLASS_NAME,
      ...getDayClassNames(dateMeta, theme),
      ...props.extraClassNames || []
    ], elAttrs: Object.assign({ role: "columnheader", colSpan: props.colSpan }, props.extraDataAttrs), renderProps, generatorName: "dayHeaderContent", customGenerator: options.dayHeaderContent, defaultGenerator: renderInner$1, classNameGenerator: options.dayHeaderClassNames, didMount: options.dayHeaderDidMount, willUnmount: options.dayHeaderWillUnmount }, (InnerContent) => y(
      "div",
      { className: "fc-scrollgrid-sync-inner" },
      y(InnerContent, { elTag: "a", elClasses: [
        "fc-col-header-cell-cushion",
        props.isSticky && "fc-sticky"
      ], elAttrs: {
        "aria-label": dateEnv.format(date, WEEKDAY_FORMAT)
      } })
    ));
  }
};
var NowTimer = class extends x {
  constructor(props, context) {
    super(props, context);
    this.initialNowDate = getNow(context.options.now, context.dateEnv);
    this.initialNowQueriedMs = new Date().valueOf();
    this.state = this.computeTiming().currentState;
  }
  render() {
    let { props, state } = this;
    return props.children(state.nowDate, state.todayRange);
  }
  componentDidMount() {
    this.setTimeout();
  }
  componentDidUpdate(prevProps) {
    if (prevProps.unit !== this.props.unit) {
      this.clearTimeout();
      this.setTimeout();
    }
  }
  componentWillUnmount() {
    this.clearTimeout();
  }
  computeTiming() {
    let { props, context } = this;
    let unroundedNow = addMs(this.initialNowDate, new Date().valueOf() - this.initialNowQueriedMs);
    let currentUnitStart = context.dateEnv.startOf(unroundedNow, props.unit);
    let nextUnitStart = context.dateEnv.add(currentUnitStart, createDuration(1, props.unit));
    let waitMs = nextUnitStart.valueOf() - unroundedNow.valueOf();
    waitMs = Math.min(1e3 * 60 * 60 * 24, waitMs);
    return {
      currentState: { nowDate: currentUnitStart, todayRange: buildDayRange(currentUnitStart) },
      nextState: { nowDate: nextUnitStart, todayRange: buildDayRange(nextUnitStart) },
      waitMs
    };
  }
  setTimeout() {
    let { nextState, waitMs } = this.computeTiming();
    this.timeoutId = setTimeout(() => {
      this.setState(nextState, () => {
        this.setTimeout();
      });
    }, waitMs);
  }
  clearTimeout() {
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
    }
  }
};
NowTimer.contextType = ViewContextType;
function buildDayRange(date) {
  let start = startOfDay(date);
  let end = addDays(start, 1);
  return { start, end };
}
var DayHeader = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.createDayHeaderFormatter = memoize(createDayHeaderFormatter);
  }
  render() {
    let { context } = this;
    let { dates, dateProfile, datesRepDistinctDays, renderIntro } = this.props;
    let dayHeaderFormat = this.createDayHeaderFormatter(context.options.dayHeaderFormat, datesRepDistinctDays, dates.length);
    return y(NowTimer, { unit: "day" }, (nowDate, todayRange) => y(
      "tr",
      { role: "row" },
      renderIntro && renderIntro("day"),
      dates.map((date) => datesRepDistinctDays ? y(TableDateCell, { key: date.toISOString(), date, dateProfile, todayRange, colCnt: dates.length, dayHeaderFormat }) : y(TableDowCell, { key: date.getUTCDay(), dow: date.getUTCDay(), dayHeaderFormat }))
    ));
  }
};
function createDayHeaderFormatter(explicitFormat, datesRepDistinctDays, dateCnt) {
  return explicitFormat || computeFallbackHeaderFormat(datesRepDistinctDays, dateCnt);
}
var DaySeriesModel = class {
  constructor(range2, dateProfileGenerator) {
    let date = range2.start;
    let { end } = range2;
    let indices = [];
    let dates = [];
    let dayIndex = -1;
    while (date < end) {
      if (dateProfileGenerator.isHiddenDay(date)) {
        indices.push(dayIndex + 0.5);
      } else {
        dayIndex += 1;
        indices.push(dayIndex);
        dates.push(date);
      }
      date = addDays(date, 1);
    }
    this.dates = dates;
    this.indices = indices;
    this.cnt = dates.length;
  }
  sliceRange(range2) {
    let firstIndex = this.getDateDayIndex(range2.start);
    let lastIndex = this.getDateDayIndex(addDays(range2.end, -1));
    let clippedFirstIndex = Math.max(0, firstIndex);
    let clippedLastIndex = Math.min(this.cnt - 1, lastIndex);
    clippedFirstIndex = Math.ceil(clippedFirstIndex);
    clippedLastIndex = Math.floor(clippedLastIndex);
    if (clippedFirstIndex <= clippedLastIndex) {
      return {
        firstIndex: clippedFirstIndex,
        lastIndex: clippedLastIndex,
        isStart: firstIndex === clippedFirstIndex,
        isEnd: lastIndex === clippedLastIndex
      };
    }
    return null;
  }
  // Given a date, returns its chronolocial cell-index from the first cell of the grid.
  // If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.
  // If before the first offset, returns a negative number.
  // If after the last offset, returns an offset past the last cell offset.
  // Only works for *start* dates of cells. Will not work for exclusive end dates for cells.
  getDateDayIndex(date) {
    let { indices } = this;
    let dayOffset = Math.floor(diffDays(this.dates[0], date));
    if (dayOffset < 0) {
      return indices[0] - 1;
    }
    if (dayOffset >= indices.length) {
      return indices[indices.length - 1] + 1;
    }
    return indices[dayOffset];
  }
};
var DayTableModel = class {
  constructor(daySeries, breakOnWeeks) {
    let { dates } = daySeries;
    let daysPerRow;
    let firstDay;
    let rowCnt;
    if (breakOnWeeks) {
      firstDay = dates[0].getUTCDay();
      for (daysPerRow = 1; daysPerRow < dates.length; daysPerRow += 1) {
        if (dates[daysPerRow].getUTCDay() === firstDay) {
          break;
        }
      }
      rowCnt = Math.ceil(dates.length / daysPerRow);
    } else {
      rowCnt = 1;
      daysPerRow = dates.length;
    }
    this.rowCnt = rowCnt;
    this.colCnt = daysPerRow;
    this.daySeries = daySeries;
    this.cells = this.buildCells();
    this.headerDates = this.buildHeaderDates();
  }
  buildCells() {
    let rows = [];
    for (let row = 0; row < this.rowCnt; row += 1) {
      let cells = [];
      for (let col = 0; col < this.colCnt; col += 1) {
        cells.push(this.buildCell(row, col));
      }
      rows.push(cells);
    }
    return rows;
  }
  buildCell(row, col) {
    let date = this.daySeries.dates[row * this.colCnt + col];
    return {
      key: date.toISOString(),
      date
    };
  }
  buildHeaderDates() {
    let dates = [];
    for (let col = 0; col < this.colCnt; col += 1) {
      dates.push(this.cells[0][col].date);
    }
    return dates;
  }
  sliceRange(range2) {
    let { colCnt } = this;
    let seriesSeg = this.daySeries.sliceRange(range2);
    let segs = [];
    if (seriesSeg) {
      let { firstIndex, lastIndex } = seriesSeg;
      let index8 = firstIndex;
      while (index8 <= lastIndex) {
        let row = Math.floor(index8 / colCnt);
        let nextIndex = Math.min((row + 1) * colCnt, lastIndex + 1);
        segs.push({
          row,
          firstCol: index8 % colCnt,
          lastCol: (nextIndex - 1) % colCnt,
          isStart: seriesSeg.isStart && index8 === firstIndex,
          isEnd: seriesSeg.isEnd && nextIndex - 1 === lastIndex
        });
        index8 = nextIndex;
      }
    }
    return segs;
  }
};
var Slicer = class {
  constructor() {
    this.sliceBusinessHours = memoize(this._sliceBusinessHours);
    this.sliceDateSelection = memoize(this._sliceDateSpan);
    this.sliceEventStore = memoize(this._sliceEventStore);
    this.sliceEventDrag = memoize(this._sliceInteraction);
    this.sliceEventResize = memoize(this._sliceInteraction);
    this.forceDayIfListItem = false;
  }
  sliceProps(props, dateProfile, nextDayThreshold, context, ...extraArgs) {
    let { eventUiBases } = props;
    let eventSegs = this.sliceEventStore(props.eventStore, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs);
    return {
      dateSelectionSegs: this.sliceDateSelection(props.dateSelection, dateProfile, nextDayThreshold, eventUiBases, context, ...extraArgs),
      businessHourSegs: this.sliceBusinessHours(props.businessHours, dateProfile, nextDayThreshold, context, ...extraArgs),
      fgEventSegs: eventSegs.fg,
      bgEventSegs: eventSegs.bg,
      eventDrag: this.sliceEventDrag(props.eventDrag, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs),
      eventResize: this.sliceEventResize(props.eventResize, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs),
      eventSelection: props.eventSelection
    };
  }
  sliceNowDate(date, dateProfile, nextDayThreshold, context, ...extraArgs) {
    return this._sliceDateSpan(
      { range: { start: date, end: addMs(date, 1) }, allDay: false },
      // add 1 ms, protect against null range
      dateProfile,
      nextDayThreshold,
      {},
      context,
      ...extraArgs
    );
  }
  _sliceBusinessHours(businessHours, dateProfile, nextDayThreshold, context, ...extraArgs) {
    if (!businessHours) {
      return [];
    }
    return this._sliceEventStore(expandRecurring(businessHours, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), context), {}, dateProfile, nextDayThreshold, ...extraArgs).bg;
  }
  _sliceEventStore(eventStore, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs) {
    if (eventStore) {
      let rangeRes = sliceEventStore(eventStore, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);
      return {
        bg: this.sliceEventRanges(rangeRes.bg, extraArgs),
        fg: this.sliceEventRanges(rangeRes.fg, extraArgs)
      };
    }
    return { bg: [], fg: [] };
  }
  _sliceInteraction(interaction, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs) {
    if (!interaction) {
      return null;
    }
    let rangeRes = sliceEventStore(interaction.mutatedEvents, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);
    return {
      segs: this.sliceEventRanges(rangeRes.fg, extraArgs),
      affectedInstances: interaction.affectedEvents.instances,
      isEvent: interaction.isEvent
    };
  }
  _sliceDateSpan(dateSpan, dateProfile, nextDayThreshold, eventUiBases, context, ...extraArgs) {
    if (!dateSpan) {
      return [];
    }
    let activeRange = computeActiveRange(dateProfile, Boolean(nextDayThreshold));
    let activeDateSpanRange = intersectRanges(dateSpan.range, activeRange);
    if (activeDateSpanRange) {
      dateSpan = Object.assign(Object.assign({}, dateSpan), { range: activeDateSpanRange });
      let eventRange = fabricateEventRange(dateSpan, eventUiBases, context);
      let segs = this.sliceRange(dateSpan.range, ...extraArgs);
      for (let seg of segs) {
        seg.eventRange = eventRange;
      }
      return segs;
    }
    return [];
  }
  /*
  "complete" seg means it has component and eventRange
  */
  sliceEventRanges(eventRanges, extraArgs) {
    let segs = [];
    for (let eventRange of eventRanges) {
      segs.push(...this.sliceEventRange(eventRange, extraArgs));
    }
    return segs;
  }
  /*
  "complete" seg means it has component and eventRange
  */
  sliceEventRange(eventRange, extraArgs) {
    let dateRange = eventRange.range;
    if (this.forceDayIfListItem && eventRange.ui.display === "list-item") {
      dateRange = {
        start: dateRange.start,
        end: addDays(dateRange.start, 1)
      };
    }
    let segs = this.sliceRange(dateRange, ...extraArgs);
    for (let seg of segs) {
      seg.eventRange = eventRange;
      seg.isStart = eventRange.isStart && seg.isStart;
      seg.isEnd = eventRange.isEnd && seg.isEnd;
    }
    return segs;
  }
};
function computeActiveRange(dateProfile, isComponentAllDay) {
  let range2 = dateProfile.activeRange;
  if (isComponentAllDay) {
    return range2;
  }
  return {
    start: addMs(range2.start, dateProfile.slotMinTime.milliseconds),
    end: addMs(range2.end, dateProfile.slotMaxTime.milliseconds - 864e5)
    // 864e5 = ms in a day
  };
}
function isInteractionValid(interaction, dateProfile, context) {
  let { instances } = interaction.mutatedEvents;
  for (let instanceId in instances) {
    if (!rangeContainsRange(dateProfile.validRange, instances[instanceId].range)) {
      return false;
    }
  }
  return isNewPropsValid({ eventDrag: interaction }, context);
}
function isDateSelectionValid(dateSelection, dateProfile, context) {
  if (!rangeContainsRange(dateProfile.validRange, dateSelection.range)) {
    return false;
  }
  return isNewPropsValid({ dateSelection }, context);
}
function isNewPropsValid(newProps, context) {
  let calendarState = context.getCurrentData();
  let props = Object.assign({ businessHours: calendarState.businessHours, dateSelection: "", eventStore: calendarState.eventStore, eventUiBases: calendarState.eventUiBases, eventSelection: "", eventDrag: null, eventResize: null }, newProps);
  return (context.pluginHooks.isPropsValid || isPropsValid)(props, context);
}
function isPropsValid(state, context, dateSpanMeta = {}, filterConfig) {
  if (state.eventDrag && !isInteractionPropsValid(state, context, dateSpanMeta, filterConfig)) {
    return false;
  }
  if (state.dateSelection && !isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig)) {
    return false;
  }
  return true;
}
function isInteractionPropsValid(state, context, dateSpanMeta, filterConfig) {
  let currentState = context.getCurrentData();
  let interaction = state.eventDrag;
  let subjectEventStore = interaction.mutatedEvents;
  let subjectDefs = subjectEventStore.defs;
  let subjectInstances = subjectEventStore.instances;
  let subjectConfigs = compileEventUis(subjectDefs, interaction.isEvent ? state.eventUiBases : { "": currentState.selectionConfig });
  if (filterConfig) {
    subjectConfigs = mapHash(subjectConfigs, filterConfig);
  }
  let otherEventStore = excludeInstances(state.eventStore, interaction.affectedEvents.instances);
  let otherDefs = otherEventStore.defs;
  let otherInstances = otherEventStore.instances;
  let otherConfigs = compileEventUis(otherDefs, state.eventUiBases);
  for (let subjectInstanceId in subjectInstances) {
    let subjectInstance = subjectInstances[subjectInstanceId];
    let subjectRange = subjectInstance.range;
    let subjectConfig = subjectConfigs[subjectInstance.defId];
    let subjectDef = subjectDefs[subjectInstance.defId];
    if (!allConstraintsPass(subjectConfig.constraints, subjectRange, otherEventStore, state.businessHours, context)) {
      return false;
    }
    let { eventOverlap } = context.options;
    let eventOverlapFunc = typeof eventOverlap === "function" ? eventOverlap : null;
    for (let otherInstanceId in otherInstances) {
      let otherInstance = otherInstances[otherInstanceId];
      if (rangesIntersect(subjectRange, otherInstance.range)) {
        let otherOverlap = otherConfigs[otherInstance.defId].overlap;
        if (otherOverlap === false && interaction.isEvent) {
          return false;
        }
        if (subjectConfig.overlap === false) {
          return false;
        }
        if (eventOverlapFunc && !eventOverlapFunc(
          new EventImpl(context, otherDefs[otherInstance.defId], otherInstance),
          // still event
          new EventImpl(context, subjectDef, subjectInstance)
        )) {
          return false;
        }
      }
    }
    let calendarEventStore = currentState.eventStore;
    for (let subjectAllow of subjectConfig.allows) {
      let subjectDateSpan = Object.assign(Object.assign({}, dateSpanMeta), { range: subjectInstance.range, allDay: subjectDef.allDay });
      let origDef = calendarEventStore.defs[subjectDef.defId];
      let origInstance = calendarEventStore.instances[subjectInstanceId];
      let eventApi;
      if (origDef) {
        eventApi = new EventImpl(context, origDef, origInstance);
      } else {
        eventApi = new EventImpl(context, subjectDef);
      }
      if (!subjectAllow(buildDateSpanApiWithContext(subjectDateSpan, context), eventApi)) {
        return false;
      }
    }
  }
  return true;
}
function isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig) {
  let relevantEventStore = state.eventStore;
  let relevantDefs = relevantEventStore.defs;
  let relevantInstances = relevantEventStore.instances;
  let selection = state.dateSelection;
  let selectionRange = selection.range;
  let { selectionConfig } = context.getCurrentData();
  if (filterConfig) {
    selectionConfig = filterConfig(selectionConfig);
  }
  if (!allConstraintsPass(selectionConfig.constraints, selectionRange, relevantEventStore, state.businessHours, context)) {
    return false;
  }
  let { selectOverlap } = context.options;
  let selectOverlapFunc = typeof selectOverlap === "function" ? selectOverlap : null;
  for (let relevantInstanceId in relevantInstances) {
    let relevantInstance = relevantInstances[relevantInstanceId];
    if (rangesIntersect(selectionRange, relevantInstance.range)) {
      if (selectionConfig.overlap === false) {
        return false;
      }
      if (selectOverlapFunc && !selectOverlapFunc(new EventImpl(context, relevantDefs[relevantInstance.defId], relevantInstance), null)) {
        return false;
      }
    }
  }
  for (let selectionAllow of selectionConfig.allows) {
    let fullDateSpan = Object.assign(Object.assign({}, dateSpanMeta), selection);
    if (!selectionAllow(buildDateSpanApiWithContext(fullDateSpan, context), null)) {
      return false;
    }
  }
  return true;
}
function allConstraintsPass(constraints, subjectRange, otherEventStore, businessHoursUnexpanded, context) {
  for (let constraint of constraints) {
    if (!anyRangesContainRange(constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, context), subjectRange)) {
      return false;
    }
  }
  return true;
}
function constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, context) {
  if (constraint === "businessHours") {
    return eventStoreToRanges(expandRecurring(businessHoursUnexpanded, subjectRange, context));
  }
  if (typeof constraint === "string") {
    return eventStoreToRanges(filterEventStoreDefs(otherEventStore, (eventDef) => eventDef.groupId === constraint));
  }
  if (typeof constraint === "object" && constraint) {
    return eventStoreToRanges(expandRecurring(constraint, subjectRange, context));
  }
  return [];
}
function eventStoreToRanges(eventStore) {
  let { instances } = eventStore;
  let ranges = [];
  for (let instanceId in instances) {
    ranges.push(instances[instanceId].range);
  }
  return ranges;
}
function anyRangesContainRange(outerRanges, innerRange) {
  for (let outerRange of outerRanges) {
    if (rangeContainsRange(outerRange, innerRange)) {
      return true;
    }
  }
  return false;
}
var VISIBLE_HIDDEN_RE = /^(visible|hidden)$/;
var Scroller = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.handleEl = (el) => {
      this.el = el;
      setRef(this.props.elRef, el);
    };
  }
  render() {
    let { props } = this;
    let { liquid, liquidIsAbsolute } = props;
    let isAbsolute = liquid && liquidIsAbsolute;
    let className = ["fc-scroller"];
    if (liquid) {
      if (liquidIsAbsolute) {
        className.push("fc-scroller-liquid-absolute");
      } else {
        className.push("fc-scroller-liquid");
      }
    }
    return y("div", { ref: this.handleEl, className: className.join(" "), style: {
      overflowX: props.overflowX,
      overflowY: props.overflowY,
      left: isAbsolute && -(props.overcomeLeft || 0) || "",
      right: isAbsolute && -(props.overcomeRight || 0) || "",
      bottom: isAbsolute && -(props.overcomeBottom || 0) || "",
      marginLeft: !isAbsolute && -(props.overcomeLeft || 0) || "",
      marginRight: !isAbsolute && -(props.overcomeRight || 0) || "",
      marginBottom: !isAbsolute && -(props.overcomeBottom || 0) || "",
      maxHeight: props.maxHeight || ""
    } }, props.children);
  }
  needsXScrolling() {
    if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {
      return false;
    }
    let { el } = this;
    let realClientWidth = this.el.getBoundingClientRect().width - this.getYScrollbarWidth();
    let { children } = el;
    for (let i3 = 0; i3 < children.length; i3 += 1) {
      let childEl = children[i3];
      if (childEl.getBoundingClientRect().width > realClientWidth) {
        return true;
      }
    }
    return false;
  }
  needsYScrolling() {
    if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {
      return false;
    }
    let { el } = this;
    let realClientHeight = this.el.getBoundingClientRect().height - this.getXScrollbarWidth();
    let { children } = el;
    for (let i3 = 0; i3 < children.length; i3 += 1) {
      let childEl = children[i3];
      if (childEl.getBoundingClientRect().height > realClientHeight) {
        return true;
      }
    }
    return false;
  }
  getXScrollbarWidth() {
    if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {
      return 0;
    }
    return this.el.offsetHeight - this.el.clientHeight;
  }
  getYScrollbarWidth() {
    if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {
      return 0;
    }
    return this.el.offsetWidth - this.el.clientWidth;
  }
};
var RefMap = class {
  constructor(masterCallback) {
    this.masterCallback = masterCallback;
    this.currentMap = {};
    this.depths = {};
    this.callbackMap = {};
    this.handleValue = (val, key) => {
      let { depths, currentMap } = this;
      let removed = false;
      let added = false;
      if (val !== null) {
        removed = key in currentMap;
        currentMap[key] = val;
        depths[key] = (depths[key] || 0) + 1;
        added = true;
      } else {
        depths[key] -= 1;
        if (!depths[key]) {
          delete currentMap[key];
          delete this.callbackMap[key];
          removed = true;
        }
      }
      if (this.masterCallback) {
        if (removed) {
          this.masterCallback(null, String(key));
        }
        if (added) {
          this.masterCallback(val, String(key));
        }
      }
    };
  }
  createRef(key) {
    let refCallback = this.callbackMap[key];
    if (!refCallback) {
      refCallback = this.callbackMap[key] = (val) => {
        this.handleValue(val, String(key));
      };
    }
    return refCallback;
  }
  // TODO: check callers that don't care about order. should use getAll instead
  // NOTE: this method has become less valuable now that we are encouraged to map order by some other index
  // TODO: provide ONE array-export function, buildArray, which fails on non-numeric indexes. caller can manipulate and "collect"
  collect(startIndex, endIndex, step) {
    return collectFromHash(this.currentMap, startIndex, endIndex, step);
  }
  getAll() {
    return hashValuesToArray(this.currentMap);
  }
};
function computeShrinkWidth(chunkEls) {
  let shrinkCells = findElements(chunkEls, ".fc-scrollgrid-shrink");
  let largestWidth = 0;
  for (let shrinkCell of shrinkCells) {
    largestWidth = Math.max(largestWidth, computeSmallestCellWidth(shrinkCell));
  }
  return Math.ceil(largestWidth);
}
function getSectionHasLiquidHeight(props, sectionConfig) {
  return props.liquid && sectionConfig.liquid;
}
function getAllowYScrolling(props, sectionConfig) {
  return sectionConfig.maxHeight != null || // if its possible for the height to max out, we might need scrollbars
  getSectionHasLiquidHeight(props, sectionConfig);
}
function renderChunkContent(sectionConfig, chunkConfig, arg, isHeader) {
  let { expandRows } = arg;
  let content = typeof chunkConfig.content === "function" ? chunkConfig.content(arg) : y("table", {
    role: "presentation",
    className: [
      chunkConfig.tableClassName,
      sectionConfig.syncRowHeights ? "fc-scrollgrid-sync-table" : ""
    ].join(" "),
    style: {
      minWidth: arg.tableMinWidth,
      width: arg.clientWidth,
      height: expandRows ? arg.clientHeight : ""
      // css `height` on a <table> serves as a min-height
    }
  }, arg.tableColGroupNode, y(isHeader ? "thead" : "tbody", {
    role: "presentation"
  }, typeof chunkConfig.rowContent === "function" ? chunkConfig.rowContent(arg) : chunkConfig.rowContent));
  return content;
}
function isColPropsEqual(cols0, cols1) {
  return isArraysEqual(cols0, cols1, isPropsEqual);
}
function renderMicroColGroup(cols, shrinkWidth) {
  let colNodes = [];
  for (let colProps of cols) {
    let span = colProps.span || 1;
    for (let i3 = 0; i3 < span; i3 += 1) {
      colNodes.push(y("col", { style: {
        width: colProps.width === "shrink" ? sanitizeShrinkWidth(shrinkWidth) : colProps.width || "",
        minWidth: colProps.minWidth || ""
      } }));
    }
  }
  return y("colgroup", {}, ...colNodes);
}
function sanitizeShrinkWidth(shrinkWidth) {
  return shrinkWidth == null ? 4 : shrinkWidth;
}
function hasShrinkWidth(cols) {
  for (let col of cols) {
    if (col.width === "shrink") {
      return true;
    }
  }
  return false;
}
function getScrollGridClassNames(liquid, context) {
  let classNames = [
    "fc-scrollgrid",
    context.theme.getClass("table")
  ];
  if (liquid) {
    classNames.push("fc-scrollgrid-liquid");
  }
  return classNames;
}
function getSectionClassNames(sectionConfig, wholeTableVGrow) {
  let classNames = [
    "fc-scrollgrid-section",
    `fc-scrollgrid-section-${sectionConfig.type}`,
    sectionConfig.className
    // used?
  ];
  if (wholeTableVGrow && sectionConfig.liquid && sectionConfig.maxHeight == null) {
    classNames.push("fc-scrollgrid-section-liquid");
  }
  if (sectionConfig.isSticky) {
    classNames.push("fc-scrollgrid-section-sticky");
  }
  return classNames;
}
function renderScrollShim(arg) {
  return y("div", { className: "fc-scrollgrid-sticky-shim", style: {
    width: arg.clientWidth,
    minWidth: arg.tableMinWidth
  } });
}
function getStickyHeaderDates(options) {
  let { stickyHeaderDates } = options;
  if (stickyHeaderDates == null || stickyHeaderDates === "auto") {
    stickyHeaderDates = options.height === "auto" || options.viewHeight === "auto";
  }
  return stickyHeaderDates;
}
function getStickyFooterScrollbar(options) {
  let { stickyFooterScrollbar } = options;
  if (stickyFooterScrollbar == null || stickyFooterScrollbar === "auto") {
    stickyFooterScrollbar = options.height === "auto" || options.viewHeight === "auto";
  }
  return stickyFooterScrollbar;
}
var SimpleScrollGrid = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.processCols = memoize((a3) => a3, isColPropsEqual);
    this.renderMicroColGroup = memoize(renderMicroColGroup);
    this.scrollerRefs = new RefMap();
    this.scrollerElRefs = new RefMap(this._handleScrollerEl.bind(this));
    this.state = {
      shrinkWidth: null,
      forceYScrollbars: false,
      scrollerClientWidths: {},
      scrollerClientHeights: {}
    };
    this.handleSizing = () => {
      this.safeSetState(Object.assign({ shrinkWidth: this.computeShrinkWidth() }, this.computeScrollerDims()));
    };
  }
  render() {
    let { props, state, context } = this;
    let sectionConfigs = props.sections || [];
    let cols = this.processCols(props.cols);
    let microColGroupNode = this.renderMicroColGroup(cols, state.shrinkWidth);
    let classNames = getScrollGridClassNames(props.liquid, context);
    if (props.collapsibleWidth) {
      classNames.push("fc-scrollgrid-collapsible");
    }
    let configCnt = sectionConfigs.length;
    let configI = 0;
    let currentConfig;
    let headSectionNodes = [];
    let bodySectionNodes = [];
    let footSectionNodes = [];
    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === "header") {
      headSectionNodes.push(this.renderSection(currentConfig, microColGroupNode, true));
      configI += 1;
    }
    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === "body") {
      bodySectionNodes.push(this.renderSection(currentConfig, microColGroupNode, false));
      configI += 1;
    }
    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === "footer") {
      footSectionNodes.push(this.renderSection(currentConfig, microColGroupNode, true));
      configI += 1;
    }
    let isBuggy = !getCanVGrowWithinCell();
    const roleAttrs = { role: "rowgroup" };
    return y("table", {
      role: "grid",
      className: classNames.join(" "),
      style: { height: props.height }
    }, Boolean(!isBuggy && headSectionNodes.length) && y("thead", roleAttrs, ...headSectionNodes), Boolean(!isBuggy && bodySectionNodes.length) && y("tbody", roleAttrs, ...bodySectionNodes), Boolean(!isBuggy && footSectionNodes.length) && y("tfoot", roleAttrs, ...footSectionNodes), isBuggy && y("tbody", roleAttrs, ...headSectionNodes, ...bodySectionNodes, ...footSectionNodes));
  }
  renderSection(sectionConfig, microColGroupNode, isHeader) {
    if ("outerContent" in sectionConfig) {
      return y(_, { key: sectionConfig.key }, sectionConfig.outerContent);
    }
    return y("tr", { key: sectionConfig.key, role: "presentation", className: getSectionClassNames(sectionConfig, this.props.liquid).join(" ") }, this.renderChunkTd(sectionConfig, microColGroupNode, sectionConfig.chunk, isHeader));
  }
  renderChunkTd(sectionConfig, microColGroupNode, chunkConfig, isHeader) {
    if ("outerContent" in chunkConfig) {
      return chunkConfig.outerContent;
    }
    let { props } = this;
    let { forceYScrollbars, scrollerClientWidths, scrollerClientHeights } = this.state;
    let needsYScrolling = getAllowYScrolling(props, sectionConfig);
    let isLiquid = getSectionHasLiquidHeight(props, sectionConfig);
    let overflowY = !props.liquid ? "visible" : forceYScrollbars ? "scroll" : !needsYScrolling ? "hidden" : "auto";
    let sectionKey = sectionConfig.key;
    let content = renderChunkContent(sectionConfig, chunkConfig, {
      tableColGroupNode: microColGroupNode,
      tableMinWidth: "",
      clientWidth: !props.collapsibleWidth && scrollerClientWidths[sectionKey] !== void 0 ? scrollerClientWidths[sectionKey] : null,
      clientHeight: scrollerClientHeights[sectionKey] !== void 0 ? scrollerClientHeights[sectionKey] : null,
      expandRows: sectionConfig.expandRows,
      syncRowHeights: false,
      rowSyncHeights: [],
      reportRowHeightChange: () => {
      }
    }, isHeader);
    return y(isHeader ? "th" : "td", {
      ref: chunkConfig.elRef,
      role: "presentation"
    }, y(
      "div",
      { className: `fc-scroller-harness${isLiquid ? " fc-scroller-harness-liquid" : ""}` },
      y(Scroller, { ref: this.scrollerRefs.createRef(sectionKey), elRef: this.scrollerElRefs.createRef(sectionKey), overflowY, overflowX: !props.liquid ? "visible" : "hidden", maxHeight: sectionConfig.maxHeight, liquid: isLiquid, liquidIsAbsolute: true }, content)
    ));
  }
  _handleScrollerEl(scrollerEl, key) {
    let section = getSectionByKey(this.props.sections, key);
    if (section) {
      setRef(section.chunk.scrollerElRef, scrollerEl);
    }
  }
  componentDidMount() {
    this.handleSizing();
    this.context.addResizeHandler(this.handleSizing);
  }
  componentDidUpdate() {
    this.handleSizing();
  }
  componentWillUnmount() {
    this.context.removeResizeHandler(this.handleSizing);
  }
  computeShrinkWidth() {
    return hasShrinkWidth(this.props.cols) ? computeShrinkWidth(this.scrollerElRefs.getAll()) : 0;
  }
  computeScrollerDims() {
    let scrollbarWidth = getScrollbarWidths();
    let { scrollerRefs, scrollerElRefs } = this;
    let forceYScrollbars = false;
    let scrollerClientWidths = {};
    let scrollerClientHeights = {};
    for (let sectionKey in scrollerRefs.currentMap) {
      let scroller = scrollerRefs.currentMap[sectionKey];
      if (scroller && scroller.needsYScrolling()) {
        forceYScrollbars = true;
        break;
      }
    }
    for (let section of this.props.sections) {
      let sectionKey = section.key;
      let scrollerEl = scrollerElRefs.currentMap[sectionKey];
      if (scrollerEl) {
        let harnessEl = scrollerEl.parentNode;
        scrollerClientWidths[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().width - (forceYScrollbars ? scrollbarWidth.y : 0));
        scrollerClientHeights[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().height);
      }
    }
    return { forceYScrollbars, scrollerClientWidths, scrollerClientHeights };
  }
};
SimpleScrollGrid.addStateEquality({
  scrollerClientWidths: isPropsEqual,
  scrollerClientHeights: isPropsEqual
});
function getSectionByKey(sections, key) {
  for (let section of sections) {
    if (section.key === key) {
      return section;
    }
  }
  return null;
}
var EventContainer = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.handleEl = (el) => {
      this.el = el;
      if (el) {
        setElSeg(el, this.props.seg);
      }
    };
  }
  render() {
    const { props, context } = this;
    const { options } = context;
    const { seg } = props;
    const { eventRange } = seg;
    const { ui } = eventRange;
    const renderProps = {
      event: new EventImpl(context, eventRange.def, eventRange.instance),
      view: context.viewApi,
      timeText: props.timeText,
      textColor: ui.textColor,
      backgroundColor: ui.backgroundColor,
      borderColor: ui.borderColor,
      isDraggable: !props.disableDragging && computeSegDraggable(seg, context),
      isStartResizable: !props.disableResizing && computeSegStartResizable(seg, context),
      isEndResizable: !props.disableResizing && computeSegEndResizable(seg),
      isMirror: Boolean(props.isDragging || props.isResizing || props.isDateSelecting),
      isStart: Boolean(seg.isStart),
      isEnd: Boolean(seg.isEnd),
      isPast: Boolean(props.isPast),
      isFuture: Boolean(props.isFuture),
      isToday: Boolean(props.isToday),
      isSelected: Boolean(props.isSelected),
      isDragging: Boolean(props.isDragging),
      isResizing: Boolean(props.isResizing)
    };
    return y(ContentContainer, Object.assign({}, props, { elRef: this.handleEl, elClasses: [
      ...getEventClassNames(renderProps),
      ...seg.eventRange.ui.classNames,
      ...props.elClasses || []
    ], renderProps, generatorName: "eventContent", customGenerator: options.eventContent, defaultGenerator: props.defaultGenerator, classNameGenerator: options.eventClassNames, didMount: options.eventDidMount, willUnmount: options.eventWillUnmount }));
  }
  componentDidUpdate(prevProps) {
    if (this.el && this.props.seg !== prevProps.seg) {
      setElSeg(this.el, this.props.seg);
    }
  }
};
var StandardEvent = class extends BaseComponent {
  render() {
    let { props, context } = this;
    let { options } = context;
    let { seg } = props;
    let { ui } = seg.eventRange;
    let timeFormat = options.eventTimeFormat || props.defaultTimeFormat;
    let timeText = buildSegTimeText(seg, timeFormat, context, props.defaultDisplayEventTime, props.defaultDisplayEventEnd);
    return y(EventContainer, Object.assign({}, props, { elTag: "a", elStyle: {
      borderColor: ui.borderColor,
      backgroundColor: ui.backgroundColor
    }, elAttrs: getSegAnchorAttrs(seg, context), defaultGenerator: renderInnerContent$1, timeText }), (InnerContent, eventContentArg) => y(
      _,
      null,
      y(InnerContent, { elTag: "div", elClasses: ["fc-event-main"], elStyle: { color: eventContentArg.textColor } }),
      Boolean(eventContentArg.isStartResizable) && y("div", { className: "fc-event-resizer fc-event-resizer-start" }),
      Boolean(eventContentArg.isEndResizable) && y("div", { className: "fc-event-resizer fc-event-resizer-end" })
    ));
  }
};
function renderInnerContent$1(innerProps) {
  return y(
    "div",
    { className: "fc-event-main-frame" },
    innerProps.timeText && y("div", { className: "fc-event-time" }, innerProps.timeText),
    y(
      "div",
      { className: "fc-event-title-container" },
      y("div", { className: "fc-event-title fc-sticky" }, innerProps.event.title || y(_, null, "\xA0"))
    )
  );
}
var NowIndicatorContainer = (props) => y(ViewContextType.Consumer, null, (context) => {
  let { options } = context;
  let renderProps = {
    isAxis: props.isAxis,
    date: context.dateEnv.toDate(props.date),
    view: context.viewApi
  };
  return y(ContentContainer, Object.assign({}, props, { elTag: props.elTag || "div", renderProps, generatorName: "nowIndicatorContent", customGenerator: options.nowIndicatorContent, classNameGenerator: options.nowIndicatorClassNames, didMount: options.nowIndicatorDidMount, willUnmount: options.nowIndicatorWillUnmount }));
});
var DAY_NUM_FORMAT = createFormatter({ day: "numeric" });
var DayCellContainer = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.refineRenderProps = memoizeObjArg(refineRenderProps);
  }
  render() {
    let { props, context } = this;
    let { options } = context;
    let renderProps = this.refineRenderProps({
      date: props.date,
      dateProfile: props.dateProfile,
      todayRange: props.todayRange,
      isMonthStart: props.isMonthStart || false,
      showDayNumber: props.showDayNumber,
      extraRenderProps: props.extraRenderProps,
      viewApi: context.viewApi,
      dateEnv: context.dateEnv,
      monthStartFormat: options.monthStartFormat
    });
    return y(ContentContainer, Object.assign({}, props, { elClasses: [
      ...getDayClassNames(renderProps, context.theme),
      ...props.elClasses || []
    ], elAttrs: Object.assign(Object.assign({}, props.elAttrs), renderProps.isDisabled ? {} : { "data-date": formatDayString(props.date) }), renderProps, generatorName: "dayCellContent", customGenerator: options.dayCellContent, defaultGenerator: props.defaultGenerator, classNameGenerator: (
      // don't use custom classNames if disabled
      renderProps.isDisabled ? void 0 : options.dayCellClassNames
    ), didMount: options.dayCellDidMount, willUnmount: options.dayCellWillUnmount }));
  }
};
function hasCustomDayCellContent(options) {
  return Boolean(options.dayCellContent || hasCustomRenderingHandler("dayCellContent", options));
}
function refineRenderProps(raw) {
  let { date, dateEnv, dateProfile, isMonthStart } = raw;
  let dayMeta = getDateMeta(date, raw.todayRange, null, dateProfile);
  let dayNumberText = raw.showDayNumber ? dateEnv.format(date, isMonthStart ? raw.monthStartFormat : DAY_NUM_FORMAT) : "";
  return Object.assign(Object.assign(Object.assign({ date: dateEnv.toDate(date), view: raw.viewApi }, dayMeta), {
    isMonthStart,
    dayNumberText
  }), raw.extraRenderProps);
}
var BgEvent = class extends BaseComponent {
  render() {
    let { props } = this;
    let { seg } = props;
    return y(EventContainer, { elTag: "div", elClasses: ["fc-bg-event"], elStyle: { backgroundColor: seg.eventRange.ui.backgroundColor }, defaultGenerator: renderInnerContent, seg, timeText: "", isDragging: false, isResizing: false, isDateSelecting: false, isSelected: false, isPast: props.isPast, isFuture: props.isFuture, isToday: props.isToday, disableDragging: true, disableResizing: true });
  }
};
function renderInnerContent(props) {
  let { title } = props.event;
  return title && y("div", { className: "fc-event-title" }, props.event.title);
}
function renderFill(fillType) {
  return y("div", { className: `fc-${fillType}` });
}
var WeekNumberContainer = (props) => y(ViewContextType.Consumer, null, (context) => {
  let { dateEnv, options } = context;
  let { date } = props;
  let format = options.weekNumberFormat || props.defaultFormat;
  let num = dateEnv.computeWeekNumber(date);
  let text = dateEnv.format(date, format);
  let renderProps = { num, text, date };
  return y(
    ContentContainer,
    Object.assign({}, props, { renderProps, generatorName: "weekNumberContent", customGenerator: options.weekNumberContent, defaultGenerator: renderInner, classNameGenerator: options.weekNumberClassNames, didMount: options.weekNumberDidMount, willUnmount: options.weekNumberWillUnmount })
  );
});
function renderInner(innerProps) {
  return innerProps.text;
}
var PADDING_FROM_VIEWPORT = 10;
var Popover = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.state = {
      titleId: getUniqueDomId()
    };
    this.handleRootEl = (el) => {
      this.rootEl = el;
      if (this.props.elRef) {
        setRef(this.props.elRef, el);
      }
    };
    this.handleDocumentMouseDown = (ev) => {
      const target = getEventTargetViaRoot(ev);
      if (!this.rootEl.contains(target)) {
        this.handleCloseClick();
      }
    };
    this.handleDocumentKeyDown = (ev) => {
      if (ev.key === "Escape") {
        this.handleCloseClick();
      }
    };
    this.handleCloseClick = () => {
      let { onClose } = this.props;
      if (onClose) {
        onClose();
      }
    };
  }
  render() {
    let { theme, options } = this.context;
    let { props, state } = this;
    let classNames = [
      "fc-popover",
      theme.getClass("popover")
    ].concat(props.extraClassNames || []);
    return j3(y(
      "div",
      Object.assign({}, props.extraAttrs, { id: props.id, className: classNames.join(" "), "aria-labelledby": state.titleId, ref: this.handleRootEl }),
      y(
        "div",
        { className: "fc-popover-header " + theme.getClass("popoverHeader") },
        y("span", { className: "fc-popover-title", id: state.titleId }, props.title),
        y("span", { className: "fc-popover-close " + theme.getIconClass("close"), title: options.closeHint, onClick: this.handleCloseClick })
      ),
      y("div", { className: "fc-popover-body " + theme.getClass("popoverContent") }, props.children)
    ), props.parentEl);
  }
  componentDidMount() {
    document.addEventListener("mousedown", this.handleDocumentMouseDown);
    document.addEventListener("keydown", this.handleDocumentKeyDown);
    this.updateSize();
  }
  componentWillUnmount() {
    document.removeEventListener("mousedown", this.handleDocumentMouseDown);
    document.removeEventListener("keydown", this.handleDocumentKeyDown);
  }
  updateSize() {
    let { isRtl } = this.context;
    let { alignmentEl, alignGridTop } = this.props;
    let { rootEl } = this;
    let alignmentRect = computeClippedClientRect(alignmentEl);
    if (alignmentRect) {
      let popoverDims = rootEl.getBoundingClientRect();
      let popoverTop = alignGridTop ? elementClosest(alignmentEl, ".fc-scrollgrid").getBoundingClientRect().top : alignmentRect.top;
      let popoverLeft = isRtl ? alignmentRect.right - popoverDims.width : alignmentRect.left;
      popoverTop = Math.max(popoverTop, PADDING_FROM_VIEWPORT);
      popoverLeft = Math.min(popoverLeft, document.documentElement.clientWidth - PADDING_FROM_VIEWPORT - popoverDims.width);
      popoverLeft = Math.max(popoverLeft, PADDING_FROM_VIEWPORT);
      let origin = rootEl.offsetParent.getBoundingClientRect();
      applyStyle(rootEl, {
        top: popoverTop - origin.top,
        left: popoverLeft - origin.left
      });
    }
  }
};
var MorePopover = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.handleRootEl = (rootEl) => {
      this.rootEl = rootEl;
      if (rootEl) {
        this.context.registerInteractiveComponent(this, {
          el: rootEl,
          useEventCenter: false
        });
      } else {
        this.context.unregisterInteractiveComponent(this);
      }
    };
  }
  render() {
    let { options, dateEnv } = this.context;
    let { props } = this;
    let { startDate, todayRange, dateProfile } = props;
    let title = dateEnv.format(startDate, options.dayPopoverFormat);
    return y(DayCellContainer, { elRef: this.handleRootEl, date: startDate, dateProfile, todayRange }, (InnerContent, renderProps, elAttrs) => y(
      Popover,
      { elRef: elAttrs.ref, id: props.id, title, extraClassNames: ["fc-more-popover"].concat(elAttrs.className || []), extraAttrs: elAttrs, parentEl: props.parentEl, alignmentEl: props.alignmentEl, alignGridTop: props.alignGridTop, onClose: props.onClose },
      hasCustomDayCellContent(options) && y(InnerContent, { elTag: "div", elClasses: ["fc-more-popover-misc"] }),
      props.children
    ));
  }
  queryHit(positionLeft, positionTop, elWidth, elHeight) {
    let { rootEl, props } = this;
    if (positionLeft >= 0 && positionLeft < elWidth && positionTop >= 0 && positionTop < elHeight) {
      return {
        dateProfile: props.dateProfile,
        dateSpan: Object.assign({ allDay: !props.forceTimed, range: {
          start: props.startDate,
          end: props.endDate
        } }, props.extraDateSpan),
        dayEl: rootEl,
        rect: {
          left: 0,
          top: 0,
          right: elWidth,
          bottom: elHeight
        },
        layer: 1
        // important when comparing with hits from other components
      };
    }
    return null;
  }
};
var MoreLinkContainer = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.state = {
      isPopoverOpen: false,
      popoverId: getUniqueDomId()
    };
    this.handleLinkEl = (linkEl) => {
      this.linkEl = linkEl;
      if (this.props.elRef) {
        setRef(this.props.elRef, linkEl);
      }
    };
    this.handleClick = (ev) => {
      let { props, context } = this;
      let { moreLinkClick } = context.options;
      let date = computeRange(props).start;
      function buildPublicSeg(seg) {
        let { def, instance, range: range2 } = seg.eventRange;
        return {
          event: new EventImpl(context, def, instance),
          start: context.dateEnv.toDate(range2.start),
          end: context.dateEnv.toDate(range2.end),
          isStart: seg.isStart,
          isEnd: seg.isEnd
        };
      }
      if (typeof moreLinkClick === "function") {
        moreLinkClick = moreLinkClick({
          date,
          allDay: Boolean(props.allDayDate),
          allSegs: props.allSegs.map(buildPublicSeg),
          hiddenSegs: props.hiddenSegs.map(buildPublicSeg),
          jsEvent: ev,
          view: context.viewApi
        });
      }
      if (!moreLinkClick || moreLinkClick === "popover") {
        this.setState({ isPopoverOpen: true });
      } else if (typeof moreLinkClick === "string") {
        context.calendarApi.zoomTo(date, moreLinkClick);
      }
    };
    this.handlePopoverClose = () => {
      this.setState({ isPopoverOpen: false });
    };
  }
  render() {
    let { props, state } = this;
    return y(ViewContextType.Consumer, null, (context) => {
      let { viewApi, options, calendarApi } = context;
      let { moreLinkText } = options;
      let { moreCnt } = props;
      let range2 = computeRange(props);
      let text = typeof moreLinkText === "function" ? moreLinkText.call(calendarApi, moreCnt) : `+${moreCnt} ${moreLinkText}`;
      let hint = formatWithOrdinals(options.moreLinkHint, [moreCnt], text);
      let renderProps = {
        num: moreCnt,
        shortText: `+${moreCnt}`,
        text,
        view: viewApi
      };
      return y(
        _,
        null,
        Boolean(props.moreCnt) && y(ContentContainer, { elTag: props.elTag || "a", elRef: this.handleLinkEl, elClasses: [
          ...props.elClasses || [],
          "fc-more-link"
        ], elStyle: props.elStyle, elAttrs: Object.assign(Object.assign(Object.assign({}, props.elAttrs), createAriaClickAttrs(this.handleClick)), { title: hint, "aria-expanded": state.isPopoverOpen, "aria-controls": state.isPopoverOpen ? state.popoverId : "" }), renderProps, generatorName: "moreLinkContent", customGenerator: options.moreLinkContent, defaultGenerator: props.defaultGenerator || renderMoreLinkInner, classNameGenerator: options.moreLinkClassNames, didMount: options.moreLinkDidMount, willUnmount: options.moreLinkWillUnmount }, props.children),
        state.isPopoverOpen && y(MorePopover, { id: state.popoverId, startDate: range2.start, endDate: range2.end, dateProfile: props.dateProfile, todayRange: props.todayRange, extraDateSpan: props.extraDateSpan, parentEl: this.parentEl, alignmentEl: props.alignmentElRef ? props.alignmentElRef.current : this.linkEl, alignGridTop: props.alignGridTop, forceTimed: props.forceTimed, onClose: this.handlePopoverClose }, props.popoverContent())
      );
    });
  }
  componentDidMount() {
    this.updateParentEl();
  }
  componentDidUpdate() {
    this.updateParentEl();
  }
  updateParentEl() {
    if (this.linkEl) {
      this.parentEl = elementClosest(this.linkEl, ".fc-view-harness");
    }
  }
};
function renderMoreLinkInner(props) {
  return props.text;
}
function computeRange(props) {
  if (props.allDayDate) {
    return {
      start: props.allDayDate,
      end: addDays(props.allDayDate, 1)
    };
  }
  let { hiddenSegs } = props;
  return {
    start: computeEarliestSegStart(hiddenSegs),
    end: computeLatestSegEnd(hiddenSegs)
  };
}
function computeEarliestSegStart(segs) {
  return segs.reduce(pickEarliestStart).eventRange.range.start;
}
function pickEarliestStart(seg0, seg1) {
  return seg0.eventRange.range.start < seg1.eventRange.range.start ? seg0 : seg1;
}
function computeLatestSegEnd(segs) {
  return segs.reduce(pickLatestEnd).eventRange.range.end;
}
function pickLatestEnd(seg0, seg1) {
  return seg0.eventRange.range.end > seg1.eventRange.range.end ? seg0 : seg1;
}

// node_modules/@fullcalendar/core/index.js
var globalLocales = [];
var MINIMAL_RAW_EN_LOCALE = {
  code: "en",
  week: {
    dow: 0,
    doy: 4
    // 4 days need to be within the year to be considered the first week
  },
  direction: "ltr",
  buttonText: {
    prev: "prev",
    next: "next",
    prevYear: "prev year",
    nextYear: "next year",
    year: "year",
    today: "today",
    month: "month",
    week: "week",
    day: "day",
    list: "list"
  },
  weekText: "W",
  weekTextLong: "Week",
  closeHint: "Close",
  timeHint: "Time",
  eventHint: "Event",
  allDayText: "all-day",
  moreLinkText: "more",
  noEventsText: "No events to display"
};
var RAW_EN_LOCALE = Object.assign(Object.assign({}, MINIMAL_RAW_EN_LOCALE), {
  // Includes things we don't want other locales to inherit,
  // things that derive from other translatable strings.
  buttonHints: {
    prev: "Previous $0",
    next: "Next $0",
    today(buttonText, unit) {
      return unit === "day" ? "Today" : `This ${buttonText}`;
    }
  },
  viewHint: "$0 view",
  navLinkHint: "Go to $0",
  moreLinkHint(eventCnt) {
    return `Show ${eventCnt} more event${eventCnt === 1 ? "" : "s"}`;
  }
});
function organizeRawLocales(explicitRawLocales) {
  let defaultCode = explicitRawLocales.length > 0 ? explicitRawLocales[0].code : "en";
  let allRawLocales = globalLocales.concat(explicitRawLocales);
  let rawLocaleMap = {
    en: RAW_EN_LOCALE
  };
  for (let rawLocale of allRawLocales) {
    rawLocaleMap[rawLocale.code] = rawLocale;
  }
  return {
    map: rawLocaleMap,
    defaultCode
  };
}
function buildLocale(inputSingular, available) {
  if (typeof inputSingular === "object" && !Array.isArray(inputSingular)) {
    return parseLocale(inputSingular.code, [inputSingular.code], inputSingular);
  }
  return queryLocale(inputSingular, available);
}
function queryLocale(codeArg, available) {
  let codes = [].concat(codeArg || []);
  let raw = queryRawLocale(codes, available) || RAW_EN_LOCALE;
  return parseLocale(codeArg, codes, raw);
}
function queryRawLocale(codes, available) {
  for (let i3 = 0; i3 < codes.length; i3 += 1) {
    let parts = codes[i3].toLocaleLowerCase().split("-");
    for (let j4 = parts.length; j4 > 0; j4 -= 1) {
      let simpleId = parts.slice(0, j4).join("-");
      if (available[simpleId]) {
        return available[simpleId];
      }
    }
  }
  return null;
}
function parseLocale(codeArg, codes, raw) {
  let merged = mergeProps([MINIMAL_RAW_EN_LOCALE, raw], ["buttonText"]);
  delete merged.code;
  let { week } = merged;
  delete merged.week;
  return {
    codeArg,
    codes,
    week,
    simpleNumberFormat: new Intl.NumberFormat(codeArg),
    options: merged
  };
}
function createPlugin(input) {
  return {
    id: guid(),
    name: input.name,
    premiumReleaseDate: input.premiumReleaseDate ? new Date(input.premiumReleaseDate) : void 0,
    deps: input.deps || [],
    reducers: input.reducers || [],
    isLoadingFuncs: input.isLoadingFuncs || [],
    contextInit: [].concat(input.contextInit || []),
    eventRefiners: input.eventRefiners || {},
    eventDefMemberAdders: input.eventDefMemberAdders || [],
    eventSourceRefiners: input.eventSourceRefiners || {},
    isDraggableTransformers: input.isDraggableTransformers || [],
    eventDragMutationMassagers: input.eventDragMutationMassagers || [],
    eventDefMutationAppliers: input.eventDefMutationAppliers || [],
    dateSelectionTransformers: input.dateSelectionTransformers || [],
    datePointTransforms: input.datePointTransforms || [],
    dateSpanTransforms: input.dateSpanTransforms || [],
    views: input.views || {},
    viewPropsTransformers: input.viewPropsTransformers || [],
    isPropsValid: input.isPropsValid || null,
    externalDefTransforms: input.externalDefTransforms || [],
    viewContainerAppends: input.viewContainerAppends || [],
    eventDropTransformers: input.eventDropTransformers || [],
    componentInteractions: input.componentInteractions || [],
    calendarInteractions: input.calendarInteractions || [],
    themeClasses: input.themeClasses || {},
    eventSourceDefs: input.eventSourceDefs || [],
    cmdFormatter: input.cmdFormatter,
    recurringTypes: input.recurringTypes || [],
    namedTimeZonedImpl: input.namedTimeZonedImpl,
    initialView: input.initialView || "",
    elementDraggingImpl: input.elementDraggingImpl,
    optionChangeHandlers: input.optionChangeHandlers || {},
    scrollGridImpl: input.scrollGridImpl || null,
    listenerRefiners: input.listenerRefiners || {},
    optionRefiners: input.optionRefiners || {},
    propSetHandlers: input.propSetHandlers || {}
  };
}
function buildPluginHooks(pluginDefs, globalDefs) {
  let currentPluginIds = {};
  let hooks = {
    premiumReleaseDate: void 0,
    reducers: [],
    isLoadingFuncs: [],
    contextInit: [],
    eventRefiners: {},
    eventDefMemberAdders: [],
    eventSourceRefiners: {},
    isDraggableTransformers: [],
    eventDragMutationMassagers: [],
    eventDefMutationAppliers: [],
    dateSelectionTransformers: [],
    datePointTransforms: [],
    dateSpanTransforms: [],
    views: {},
    viewPropsTransformers: [],
    isPropsValid: null,
    externalDefTransforms: [],
    viewContainerAppends: [],
    eventDropTransformers: [],
    componentInteractions: [],
    calendarInteractions: [],
    themeClasses: {},
    eventSourceDefs: [],
    cmdFormatter: null,
    recurringTypes: [],
    namedTimeZonedImpl: null,
    initialView: "",
    elementDraggingImpl: null,
    optionChangeHandlers: {},
    scrollGridImpl: null,
    listenerRefiners: {},
    optionRefiners: {},
    propSetHandlers: {}
  };
  function addDefs(defs) {
    for (let def of defs) {
      const pluginName = def.name;
      const currentId = currentPluginIds[pluginName];
      if (currentId === void 0) {
        currentPluginIds[pluginName] = def.id;
        addDefs(def.deps);
        hooks = combineHooks(hooks, def);
      } else if (currentId !== def.id) {
        console.warn(`Duplicate plugin '${pluginName}'`);
      }
    }
  }
  if (pluginDefs) {
    addDefs(pluginDefs);
  }
  addDefs(globalDefs);
  return hooks;
}
function buildBuildPluginHooks() {
  let currentOverrideDefs = [];
  let currentGlobalDefs = [];
  let currentHooks;
  return (overrideDefs, globalDefs) => {
    if (!currentHooks || !isArraysEqual(overrideDefs, currentOverrideDefs) || !isArraysEqual(globalDefs, currentGlobalDefs)) {
      currentHooks = buildPluginHooks(overrideDefs, globalDefs);
    }
    currentOverrideDefs = overrideDefs;
    currentGlobalDefs = globalDefs;
    return currentHooks;
  };
}
function combineHooks(hooks0, hooks1) {
  return {
    premiumReleaseDate: compareOptionalDates(hooks0.premiumReleaseDate, hooks1.premiumReleaseDate),
    reducers: hooks0.reducers.concat(hooks1.reducers),
    isLoadingFuncs: hooks0.isLoadingFuncs.concat(hooks1.isLoadingFuncs),
    contextInit: hooks0.contextInit.concat(hooks1.contextInit),
    eventRefiners: Object.assign(Object.assign({}, hooks0.eventRefiners), hooks1.eventRefiners),
    eventDefMemberAdders: hooks0.eventDefMemberAdders.concat(hooks1.eventDefMemberAdders),
    eventSourceRefiners: Object.assign(Object.assign({}, hooks0.eventSourceRefiners), hooks1.eventSourceRefiners),
    isDraggableTransformers: hooks0.isDraggableTransformers.concat(hooks1.isDraggableTransformers),
    eventDragMutationMassagers: hooks0.eventDragMutationMassagers.concat(hooks1.eventDragMutationMassagers),
    eventDefMutationAppliers: hooks0.eventDefMutationAppliers.concat(hooks1.eventDefMutationAppliers),
    dateSelectionTransformers: hooks0.dateSelectionTransformers.concat(hooks1.dateSelectionTransformers),
    datePointTransforms: hooks0.datePointTransforms.concat(hooks1.datePointTransforms),
    dateSpanTransforms: hooks0.dateSpanTransforms.concat(hooks1.dateSpanTransforms),
    views: Object.assign(Object.assign({}, hooks0.views), hooks1.views),
    viewPropsTransformers: hooks0.viewPropsTransformers.concat(hooks1.viewPropsTransformers),
    isPropsValid: hooks1.isPropsValid || hooks0.isPropsValid,
    externalDefTransforms: hooks0.externalDefTransforms.concat(hooks1.externalDefTransforms),
    viewContainerAppends: hooks0.viewContainerAppends.concat(hooks1.viewContainerAppends),
    eventDropTransformers: hooks0.eventDropTransformers.concat(hooks1.eventDropTransformers),
    calendarInteractions: hooks0.calendarInteractions.concat(hooks1.calendarInteractions),
    componentInteractions: hooks0.componentInteractions.concat(hooks1.componentInteractions),
    themeClasses: Object.assign(Object.assign({}, hooks0.themeClasses), hooks1.themeClasses),
    eventSourceDefs: hooks0.eventSourceDefs.concat(hooks1.eventSourceDefs),
    cmdFormatter: hooks1.cmdFormatter || hooks0.cmdFormatter,
    recurringTypes: hooks0.recurringTypes.concat(hooks1.recurringTypes),
    namedTimeZonedImpl: hooks1.namedTimeZonedImpl || hooks0.namedTimeZonedImpl,
    initialView: hooks0.initialView || hooks1.initialView,
    elementDraggingImpl: hooks0.elementDraggingImpl || hooks1.elementDraggingImpl,
    optionChangeHandlers: Object.assign(Object.assign({}, hooks0.optionChangeHandlers), hooks1.optionChangeHandlers),
    scrollGridImpl: hooks1.scrollGridImpl || hooks0.scrollGridImpl,
    listenerRefiners: Object.assign(Object.assign({}, hooks0.listenerRefiners), hooks1.listenerRefiners),
    optionRefiners: Object.assign(Object.assign({}, hooks0.optionRefiners), hooks1.optionRefiners),
    propSetHandlers: Object.assign(Object.assign({}, hooks0.propSetHandlers), hooks1.propSetHandlers)
  };
}
function compareOptionalDates(date0, date1) {
  if (date0 === void 0) {
    return date1;
  }
  if (date1 === void 0) {
    return date0;
  }
  return new Date(Math.max(date0.valueOf(), date1.valueOf()));
}
var StandardTheme = class extends Theme {
};
StandardTheme.prototype.classes = {
  root: "fc-theme-standard",
  tableCellShaded: "fc-cell-shaded",
  buttonGroup: "fc-button-group",
  button: "fc-button fc-button-primary",
  buttonActive: "fc-button-active"
};
StandardTheme.prototype.baseIconClass = "fc-icon";
StandardTheme.prototype.iconClasses = {
  close: "fc-icon-x",
  prev: "fc-icon-chevron-left",
  next: "fc-icon-chevron-right",
  prevYear: "fc-icon-chevrons-left",
  nextYear: "fc-icon-chevrons-right"
};
StandardTheme.prototype.rtlIconClasses = {
  prev: "fc-icon-chevron-right",
  next: "fc-icon-chevron-left",
  prevYear: "fc-icon-chevrons-right",
  nextYear: "fc-icon-chevrons-left"
};
StandardTheme.prototype.iconOverrideOption = "buttonIcons";
StandardTheme.prototype.iconOverrideCustomButtonOption = "icon";
StandardTheme.prototype.iconOverridePrefix = "fc-icon-";
function compileViewDefs(defaultConfigs, overrideConfigs) {
  let hash = {};
  let viewType;
  for (viewType in defaultConfigs) {
    ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);
  }
  for (viewType in overrideConfigs) {
    ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);
  }
  return hash;
}
function ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs) {
  if (hash[viewType]) {
    return hash[viewType];
  }
  let viewDef = buildViewDef(viewType, hash, defaultConfigs, overrideConfigs);
  if (viewDef) {
    hash[viewType] = viewDef;
  }
  return viewDef;
}
function buildViewDef(viewType, hash, defaultConfigs, overrideConfigs) {
  let defaultConfig = defaultConfigs[viewType];
  let overrideConfig = overrideConfigs[viewType];
  let queryProp = (name) => defaultConfig && defaultConfig[name] !== null ? defaultConfig[name] : overrideConfig && overrideConfig[name] !== null ? overrideConfig[name] : null;
  let theComponent = queryProp("component");
  let superType = queryProp("superType");
  let superDef = null;
  if (superType) {
    if (superType === viewType) {
      throw new Error("Can't have a custom view type that references itself");
    }
    superDef = ensureViewDef(superType, hash, defaultConfigs, overrideConfigs);
  }
  if (!theComponent && superDef) {
    theComponent = superDef.component;
  }
  if (!theComponent) {
    return null;
  }
  return {
    type: viewType,
    component: theComponent,
    defaults: Object.assign(Object.assign({}, superDef ? superDef.defaults : {}), defaultConfig ? defaultConfig.rawOptions : {}),
    overrides: Object.assign(Object.assign({}, superDef ? superDef.overrides : {}), overrideConfig ? overrideConfig.rawOptions : {})
  };
}
function parseViewConfigs(inputs) {
  return mapHash(inputs, parseViewConfig);
}
function parseViewConfig(input) {
  let rawOptions = typeof input === "function" ? { component: input } : input;
  let { component } = rawOptions;
  if (rawOptions.content) {
    component = createViewHookComponent(rawOptions);
  } else if (component && !(component.prototype instanceof BaseComponent)) {
    component = createViewHookComponent(Object.assign(Object.assign({}, rawOptions), { content: component }));
  }
  return {
    superType: rawOptions.type,
    component,
    rawOptions
    // includes type and component too :(
  };
}
function createViewHookComponent(options) {
  return (viewProps) => y(ViewContextType.Consumer, null, (context) => y(ContentContainer, { elTag: "div", elClasses: buildViewClassNames(context.viewSpec), renderProps: Object.assign(Object.assign({}, viewProps), { nextDayThreshold: context.options.nextDayThreshold }), generatorName: void 0, customGenerator: options.content, classNameGenerator: options.classNames, didMount: options.didMount, willUnmount: options.willUnmount }));
}
function buildViewSpecs(defaultInputs, optionOverrides, dynamicOptionOverrides, localeDefaults) {
  let defaultConfigs = parseViewConfigs(defaultInputs);
  let overrideConfigs = parseViewConfigs(optionOverrides.views);
  let viewDefs = compileViewDefs(defaultConfigs, overrideConfigs);
  return mapHash(viewDefs, (viewDef) => buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults));
}
function buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults) {
  let durationInput = viewDef.overrides.duration || viewDef.defaults.duration || dynamicOptionOverrides.duration || optionOverrides.duration;
  let duration = null;
  let durationUnit = "";
  let singleUnit = "";
  let singleUnitOverrides = {};
  if (durationInput) {
    duration = createDurationCached(durationInput);
    if (duration) {
      let denom = greatestDurationDenominator(duration);
      durationUnit = denom.unit;
      if (denom.value === 1) {
        singleUnit = durationUnit;
        singleUnitOverrides = overrideConfigs[durationUnit] ? overrideConfigs[durationUnit].rawOptions : {};
      }
    }
  }
  let queryButtonText = (optionsSubset) => {
    let buttonTextMap = optionsSubset.buttonText || {};
    let buttonTextKey = viewDef.defaults.buttonTextKey;
    if (buttonTextKey != null && buttonTextMap[buttonTextKey] != null) {
      return buttonTextMap[buttonTextKey];
    }
    if (buttonTextMap[viewDef.type] != null) {
      return buttonTextMap[viewDef.type];
    }
    if (buttonTextMap[singleUnit] != null) {
      return buttonTextMap[singleUnit];
    }
    return null;
  };
  let queryButtonTitle = (optionsSubset) => {
    let buttonHints = optionsSubset.buttonHints || {};
    let buttonKey = viewDef.defaults.buttonTextKey;
    if (buttonKey != null && buttonHints[buttonKey] != null) {
      return buttonHints[buttonKey];
    }
    if (buttonHints[viewDef.type] != null) {
      return buttonHints[viewDef.type];
    }
    if (buttonHints[singleUnit] != null) {
      return buttonHints[singleUnit];
    }
    return null;
  };
  return {
    type: viewDef.type,
    component: viewDef.component,
    duration,
    durationUnit,
    singleUnit,
    optionDefaults: viewDef.defaults,
    optionOverrides: Object.assign(Object.assign({}, singleUnitOverrides), viewDef.overrides),
    buttonTextOverride: queryButtonText(dynamicOptionOverrides) || queryButtonText(optionOverrides) || // constructor-specified buttonText lookup hash takes precedence
    viewDef.overrides.buttonText,
    buttonTextDefault: queryButtonText(localeDefaults) || viewDef.defaults.buttonText || queryButtonText(BASE_OPTION_DEFAULTS) || viewDef.type,
    // not DRY
    buttonTitleOverride: queryButtonTitle(dynamicOptionOverrides) || queryButtonTitle(optionOverrides) || viewDef.overrides.buttonHint,
    buttonTitleDefault: queryButtonTitle(localeDefaults) || viewDef.defaults.buttonHint || queryButtonTitle(BASE_OPTION_DEFAULTS)
    // will eventually fall back to buttonText
  };
}
var durationInputMap = {};
function createDurationCached(durationInput) {
  let json = JSON.stringify(durationInput);
  let res = durationInputMap[json];
  if (res === void 0) {
    res = createDuration(durationInput);
    durationInputMap[json] = res;
  }
  return res;
}
function reduceViewType(viewType, action) {
  switch (action.type) {
    case "CHANGE_VIEW_TYPE":
      viewType = action.viewType;
  }
  return viewType;
}
function reduceDynamicOptionOverrides(dynamicOptionOverrides, action) {
  switch (action.type) {
    case "SET_OPTION":
      return Object.assign(Object.assign({}, dynamicOptionOverrides), { [action.optionName]: action.rawOptionValue });
    default:
      return dynamicOptionOverrides;
  }
}
function reduceDateProfile(currentDateProfile, action, currentDate, dateProfileGenerator) {
  let dp;
  switch (action.type) {
    case "CHANGE_VIEW_TYPE":
      return dateProfileGenerator.build(action.dateMarker || currentDate);
    case "CHANGE_DATE":
      return dateProfileGenerator.build(action.dateMarker);
    case "PREV":
      dp = dateProfileGenerator.buildPrev(currentDateProfile, currentDate);
      if (dp.isValid) {
        return dp;
      }
      break;
    case "NEXT":
      dp = dateProfileGenerator.buildNext(currentDateProfile, currentDate);
      if (dp.isValid) {
        return dp;
      }
      break;
  }
  return currentDateProfile;
}
function initEventSources(calendarOptions, dateProfile, context) {
  let activeRange = dateProfile ? dateProfile.activeRange : null;
  return addSources({}, parseInitialSources(calendarOptions, context), activeRange, context);
}
function reduceEventSources(eventSources, action, dateProfile, context) {
  let activeRange = dateProfile ? dateProfile.activeRange : null;
  switch (action.type) {
    case "ADD_EVENT_SOURCES":
      return addSources(eventSources, action.sources, activeRange, context);
    case "REMOVE_EVENT_SOURCE":
      return removeSource(eventSources, action.sourceId);
    case "PREV":
    case "NEXT":
    case "CHANGE_DATE":
    case "CHANGE_VIEW_TYPE":
      if (dateProfile) {
        return fetchDirtySources(eventSources, activeRange, context);
      }
      return eventSources;
    case "FETCH_EVENT_SOURCES":
      return fetchSourcesByIds(eventSources, action.sourceIds ? (
        // why no type?
        arrayToHash(action.sourceIds)
      ) : excludeStaticSources(eventSources, context), activeRange, action.isRefetch || false, context);
    case "RECEIVE_EVENTS":
    case "RECEIVE_EVENT_ERROR":
      return receiveResponse(eventSources, action.sourceId, action.fetchId, action.fetchRange);
    case "REMOVE_ALL_EVENT_SOURCES":
      return {};
    default:
      return eventSources;
  }
}
function reduceEventSourcesNewTimeZone(eventSources, dateProfile, context) {
  let activeRange = dateProfile ? dateProfile.activeRange : null;
  return fetchSourcesByIds(eventSources, excludeStaticSources(eventSources, context), activeRange, true, context);
}
function computeEventSourcesLoading(eventSources) {
  for (let sourceId in eventSources) {
    if (eventSources[sourceId].isFetching) {
      return true;
    }
  }
  return false;
}
function addSources(eventSourceHash, sources, fetchRange, context) {
  let hash = {};
  for (let source of sources) {
    hash[source.sourceId] = source;
  }
  if (fetchRange) {
    hash = fetchDirtySources(hash, fetchRange, context);
  }
  return Object.assign(Object.assign({}, eventSourceHash), hash);
}
function removeSource(eventSourceHash, sourceId) {
  return filterHash(eventSourceHash, (eventSource) => eventSource.sourceId !== sourceId);
}
function fetchDirtySources(sourceHash, fetchRange, context) {
  return fetchSourcesByIds(sourceHash, filterHash(sourceHash, (eventSource) => isSourceDirty(eventSource, fetchRange, context)), fetchRange, false, context);
}
function isSourceDirty(eventSource, fetchRange, context) {
  if (!doesSourceNeedRange(eventSource, context)) {
    return !eventSource.latestFetchId;
  }
  return !context.options.lazyFetching || !eventSource.fetchRange || eventSource.isFetching || // always cancel outdated in-progress fetches
  fetchRange.start < eventSource.fetchRange.start || fetchRange.end > eventSource.fetchRange.end;
}
function fetchSourcesByIds(prevSources, sourceIdHash, fetchRange, isRefetch, context) {
  let nextSources = {};
  for (let sourceId in prevSources) {
    let source = prevSources[sourceId];
    if (sourceIdHash[sourceId]) {
      nextSources[sourceId] = fetchSource(source, fetchRange, isRefetch, context);
    } else {
      nextSources[sourceId] = source;
    }
  }
  return nextSources;
}
function fetchSource(eventSource, fetchRange, isRefetch, context) {
  let { options, calendarApi } = context;
  let sourceDef = context.pluginHooks.eventSourceDefs[eventSource.sourceDefId];
  let fetchId = guid();
  sourceDef.fetch({
    eventSource,
    range: fetchRange,
    isRefetch,
    context
  }, (res) => {
    let { rawEvents } = res;
    if (options.eventSourceSuccess) {
      rawEvents = options.eventSourceSuccess.call(calendarApi, rawEvents, res.response) || rawEvents;
    }
    if (eventSource.success) {
      rawEvents = eventSource.success.call(calendarApi, rawEvents, res.response) || rawEvents;
    }
    context.dispatch({
      type: "RECEIVE_EVENTS",
      sourceId: eventSource.sourceId,
      fetchId,
      fetchRange,
      rawEvents
    });
  }, (error) => {
    let errorHandled = false;
    if (options.eventSourceFailure) {
      options.eventSourceFailure.call(calendarApi, error);
      errorHandled = true;
    }
    if (eventSource.failure) {
      eventSource.failure(error);
      errorHandled = true;
    }
    if (!errorHandled) {
      console.warn(error.message, error);
    }
    context.dispatch({
      type: "RECEIVE_EVENT_ERROR",
      sourceId: eventSource.sourceId,
      fetchId,
      fetchRange,
      error
    });
  });
  return Object.assign(Object.assign({}, eventSource), { isFetching: true, latestFetchId: fetchId });
}
function receiveResponse(sourceHash, sourceId, fetchId, fetchRange) {
  let eventSource = sourceHash[sourceId];
  if (eventSource && // not already removed
  fetchId === eventSource.latestFetchId) {
    return Object.assign(Object.assign({}, sourceHash), { [sourceId]: Object.assign(Object.assign({}, eventSource), { isFetching: false, fetchRange }) });
  }
  return sourceHash;
}
function excludeStaticSources(eventSources, context) {
  return filterHash(eventSources, (eventSource) => doesSourceNeedRange(eventSource, context));
}
function parseInitialSources(rawOptions, context) {
  let refiners = buildEventSourceRefiners(context);
  let rawSources = [].concat(rawOptions.eventSources || []);
  let sources = [];
  if (rawOptions.initialEvents) {
    rawSources.unshift(rawOptions.initialEvents);
  }
  if (rawOptions.events) {
    rawSources.unshift(rawOptions.events);
  }
  for (let rawSource of rawSources) {
    let source = parseEventSource(rawSource, context, refiners);
    if (source) {
      sources.push(source);
    }
  }
  return sources;
}
function doesSourceNeedRange(eventSource, context) {
  let defs = context.pluginHooks.eventSourceDefs;
  return !defs[eventSource.sourceDefId].ignoreRange;
}
function reduceDateSelection(currentSelection, action) {
  switch (action.type) {
    case "UNSELECT_DATES":
      return null;
    case "SELECT_DATES":
      return action.selection;
    default:
      return currentSelection;
  }
}
function reduceSelectedEvent(currentInstanceId, action) {
  switch (action.type) {
    case "UNSELECT_EVENT":
      return "";
    case "SELECT_EVENT":
      return action.eventInstanceId;
    default:
      return currentInstanceId;
  }
}
function reduceEventDrag(currentDrag, action) {
  let newDrag;
  switch (action.type) {
    case "UNSET_EVENT_DRAG":
      return null;
    case "SET_EVENT_DRAG":
      newDrag = action.state;
      return {
        affectedEvents: newDrag.affectedEvents,
        mutatedEvents: newDrag.mutatedEvents,
        isEvent: newDrag.isEvent
      };
    default:
      return currentDrag;
  }
}
function reduceEventResize(currentResize, action) {
  let newResize;
  switch (action.type) {
    case "UNSET_EVENT_RESIZE":
      return null;
    case "SET_EVENT_RESIZE":
      newResize = action.state;
      return {
        affectedEvents: newResize.affectedEvents,
        mutatedEvents: newResize.mutatedEvents,
        isEvent: newResize.isEvent
      };
    default:
      return currentResize;
  }
}
function parseToolbars(calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {
  let header = calendarOptions.headerToolbar ? parseToolbar(calendarOptions.headerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) : null;
  let footer = calendarOptions.footerToolbar ? parseToolbar(calendarOptions.footerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) : null;
  return { header, footer };
}
function parseToolbar(sectionStrHash, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {
  let sectionWidgets = {};
  let viewsWithButtons = [];
  let hasTitle = false;
  for (let sectionName in sectionStrHash) {
    let sectionStr = sectionStrHash[sectionName];
    let sectionRes = parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi);
    sectionWidgets[sectionName] = sectionRes.widgets;
    viewsWithButtons.push(...sectionRes.viewsWithButtons);
    hasTitle = hasTitle || sectionRes.hasTitle;
  }
  return { sectionWidgets, viewsWithButtons, hasTitle };
}
function parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {
  let isRtl = calendarOptions.direction === "rtl";
  let calendarCustomButtons = calendarOptions.customButtons || {};
  let calendarButtonTextOverrides = calendarOptionOverrides.buttonText || {};
  let calendarButtonText = calendarOptions.buttonText || {};
  let calendarButtonHintOverrides = calendarOptionOverrides.buttonHints || {};
  let calendarButtonHints = calendarOptions.buttonHints || {};
  let sectionSubstrs = sectionStr ? sectionStr.split(" ") : [];
  let viewsWithButtons = [];
  let hasTitle = false;
  let widgets = sectionSubstrs.map((buttonGroupStr) => buttonGroupStr.split(",").map((buttonName) => {
    if (buttonName === "title") {
      hasTitle = true;
      return { buttonName };
    }
    let customButtonProps;
    let viewSpec;
    let buttonClick;
    let buttonIcon;
    let buttonText;
    let buttonHint;
    if (customButtonProps = calendarCustomButtons[buttonName]) {
      buttonClick = (ev) => {
        if (customButtonProps.click) {
          customButtonProps.click.call(ev.target, ev, ev.target);
        }
      };
      (buttonIcon = theme.getCustomButtonIconClass(customButtonProps)) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = customButtonProps.text);
      buttonHint = customButtonProps.hint || customButtonProps.text;
    } else if (viewSpec = viewSpecs[buttonName]) {
      viewsWithButtons.push(buttonName);
      buttonClick = () => {
        calendarApi.changeView(buttonName);
      };
      (buttonText = viewSpec.buttonTextOverride) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = viewSpec.buttonTextDefault);
      let textFallback = viewSpec.buttonTextOverride || viewSpec.buttonTextDefault;
      buttonHint = formatWithOrdinals(
        viewSpec.buttonTitleOverride || viewSpec.buttonTitleDefault || calendarOptions.viewHint,
        [textFallback, buttonName],
        // view-name = buttonName
        textFallback
      );
    } else if (calendarApi[buttonName]) {
      buttonClick = () => {
        calendarApi[buttonName]();
      };
      (buttonText = calendarButtonTextOverrides[buttonName]) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = calendarButtonText[buttonName]);
      if (buttonName === "prevYear" || buttonName === "nextYear") {
        let prevOrNext = buttonName === "prevYear" ? "prev" : "next";
        buttonHint = formatWithOrdinals(calendarButtonHintOverrides[prevOrNext] || calendarButtonHints[prevOrNext], [
          calendarButtonText.year || "year",
          "year"
        ], calendarButtonText[buttonName]);
      } else {
        buttonHint = (navUnit) => formatWithOrdinals(calendarButtonHintOverrides[buttonName] || calendarButtonHints[buttonName], [
          calendarButtonText[navUnit] || navUnit,
          navUnit
        ], calendarButtonText[buttonName]);
      }
    }
    return { buttonName, buttonClick, buttonIcon, buttonText, buttonHint };
  }));
  return { widgets, viewsWithButtons, hasTitle };
}
var ViewImpl = class {
  constructor(type, getCurrentData, dateEnv) {
    this.type = type;
    this.getCurrentData = getCurrentData;
    this.dateEnv = dateEnv;
  }
  get calendar() {
    return this.getCurrentData().calendarApi;
  }
  get title() {
    return this.getCurrentData().viewTitle;
  }
  get activeStart() {
    return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.start);
  }
  get activeEnd() {
    return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.end);
  }
  get currentStart() {
    return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.start);
  }
  get currentEnd() {
    return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.end);
  }
  getOption(name) {
    return this.getCurrentData().options[name];
  }
};
var eventSourceDef$2 = {
  ignoreRange: true,
  parseMeta(refined) {
    if (Array.isArray(refined.events)) {
      return refined.events;
    }
    return null;
  },
  fetch(arg, successCallback) {
    successCallback({
      rawEvents: arg.eventSource.meta
    });
  }
};
var arrayEventSourcePlugin = createPlugin({
  name: "array-event-source",
  eventSourceDefs: [eventSourceDef$2]
});
var eventSourceDef$1 = {
  parseMeta(refined) {
    if (typeof refined.events === "function") {
      return refined.events;
    }
    return null;
  },
  fetch(arg, successCallback, errorCallback) {
    const { dateEnv } = arg.context;
    const func = arg.eventSource.meta;
    unpromisify(func.bind(null, buildRangeApiWithTimeZone(arg.range, dateEnv)), (rawEvents) => successCallback({ rawEvents }), errorCallback);
  }
};
var funcEventSourcePlugin = createPlugin({
  name: "func-event-source",
  eventSourceDefs: [eventSourceDef$1]
});
var JSON_FEED_EVENT_SOURCE_REFINERS = {
  method: String,
  extraParams: identity,
  startParam: String,
  endParam: String,
  timeZoneParam: String
};
var eventSourceDef = {
  parseMeta(refined) {
    if (refined.url && (refined.format === "json" || !refined.format)) {
      return {
        url: refined.url,
        format: "json",
        method: (refined.method || "GET").toUpperCase(),
        extraParams: refined.extraParams,
        startParam: refined.startParam,
        endParam: refined.endParam,
        timeZoneParam: refined.timeZoneParam
      };
    }
    return null;
  },
  fetch(arg, successCallback, errorCallback) {
    const { meta } = arg.eventSource;
    const requestParams = buildRequestParams(meta, arg.range, arg.context);
    requestJson(meta.method, meta.url, requestParams).then(([rawEvents, response]) => {
      successCallback({ rawEvents, response });
    }, errorCallback);
  }
};
var jsonFeedEventSourcePlugin = createPlugin({
  name: "json-event-source",
  eventSourceRefiners: JSON_FEED_EVENT_SOURCE_REFINERS,
  eventSourceDefs: [eventSourceDef]
});
function buildRequestParams(meta, range2, context) {
  let { dateEnv, options } = context;
  let startParam;
  let endParam;
  let timeZoneParam;
  let customRequestParams;
  let params = {};
  startParam = meta.startParam;
  if (startParam == null) {
    startParam = options.startParam;
  }
  endParam = meta.endParam;
  if (endParam == null) {
    endParam = options.endParam;
  }
  timeZoneParam = meta.timeZoneParam;
  if (timeZoneParam == null) {
    timeZoneParam = options.timeZoneParam;
  }
  if (typeof meta.extraParams === "function") {
    customRequestParams = meta.extraParams();
  } else {
    customRequestParams = meta.extraParams || {};
  }
  Object.assign(params, customRequestParams);
  params[startParam] = dateEnv.formatIso(range2.start);
  params[endParam] = dateEnv.formatIso(range2.end);
  if (dateEnv.timeZone !== "local") {
    params[timeZoneParam] = dateEnv.timeZone;
  }
  return params;
}
var SIMPLE_RECURRING_REFINERS = {
  daysOfWeek: identity,
  startTime: createDuration,
  endTime: createDuration,
  duration: createDuration,
  startRecur: identity,
  endRecur: identity
};
var recurring = {
  parse(refined, dateEnv) {
    if (refined.daysOfWeek || refined.startTime || refined.endTime || refined.startRecur || refined.endRecur) {
      let recurringData = {
        daysOfWeek: refined.daysOfWeek || null,
        startTime: refined.startTime || null,
        endTime: refined.endTime || null,
        startRecur: refined.startRecur ? dateEnv.createMarker(refined.startRecur) : null,
        endRecur: refined.endRecur ? dateEnv.createMarker(refined.endRecur) : null
      };
      let duration;
      if (refined.duration) {
        duration = refined.duration;
      }
      if (!duration && refined.startTime && refined.endTime) {
        duration = subtractDurations(refined.endTime, refined.startTime);
      }
      return {
        allDayGuess: Boolean(!refined.startTime && !refined.endTime),
        duration,
        typeData: recurringData
        // doesn't need endTime anymore but oh well
      };
    }
    return null;
  },
  expand(typeData, framingRange, dateEnv) {
    let clippedFramingRange = intersectRanges(framingRange, { start: typeData.startRecur, end: typeData.endRecur });
    if (clippedFramingRange) {
      return expandRanges(typeData.daysOfWeek, typeData.startTime, clippedFramingRange, dateEnv);
    }
    return [];
  }
};
var simpleRecurringEventsPlugin = createPlugin({
  name: "simple-recurring-event",
  recurringTypes: [recurring],
  eventRefiners: SIMPLE_RECURRING_REFINERS
});
function expandRanges(daysOfWeek2, startTime, framingRange, dateEnv) {
  let dowHash = daysOfWeek2 ? arrayToHash(daysOfWeek2) : null;
  let dayMarker = startOfDay(framingRange.start);
  let endMarker = framingRange.end;
  let instanceStarts = [];
  while (dayMarker < endMarker) {
    let instanceStart;
    if (!dowHash || dowHash[dayMarker.getUTCDay()]) {
      if (startTime) {
        instanceStart = dateEnv.add(dayMarker, startTime);
      } else {
        instanceStart = dayMarker;
      }
      instanceStarts.push(instanceStart);
    }
    dayMarker = addDays(dayMarker, 1);
  }
  return instanceStarts;
}
var changeHandlerPlugin = createPlugin({
  name: "change-handler",
  optionChangeHandlers: {
    events(events, context) {
      handleEventSources([events], context);
    },
    eventSources: handleEventSources
  }
});
function handleEventSources(inputs, context) {
  let unfoundSources = hashValuesToArray(context.getCurrentData().eventSources);
  if (unfoundSources.length === 1 && inputs.length === 1 && Array.isArray(unfoundSources[0]._raw) && Array.isArray(inputs[0])) {
    context.dispatch({
      type: "RESET_RAW_EVENTS",
      sourceId: unfoundSources[0].sourceId,
      rawEvents: inputs[0]
    });
    return;
  }
  let newInputs = [];
  for (let input of inputs) {
    let inputFound = false;
    for (let i3 = 0; i3 < unfoundSources.length; i3 += 1) {
      if (unfoundSources[i3]._raw === input) {
        unfoundSources.splice(i3, 1);
        inputFound = true;
        break;
      }
    }
    if (!inputFound) {
      newInputs.push(input);
    }
  }
  for (let unfoundSource of unfoundSources) {
    context.dispatch({
      type: "REMOVE_EVENT_SOURCE",
      sourceId: unfoundSource.sourceId
    });
  }
  for (let newInput of newInputs) {
    context.calendarApi.addEventSource(newInput);
  }
}
function handleDateProfile(dateProfile, context) {
  context.emitter.trigger("datesSet", Object.assign(Object.assign({}, buildRangeApiWithTimeZone(dateProfile.activeRange, context.dateEnv)), { view: context.viewApi }));
}
function handleEventStore(eventStore, context) {
  let { emitter } = context;
  if (emitter.hasHandlers("eventsSet")) {
    emitter.trigger("eventsSet", buildEventApis(eventStore, context));
  }
}
var globalPlugins = [
  arrayEventSourcePlugin,
  funcEventSourcePlugin,
  jsonFeedEventSourcePlugin,
  simpleRecurringEventsPlugin,
  changeHandlerPlugin,
  createPlugin({
    name: "misc",
    isLoadingFuncs: [
      (state) => computeEventSourcesLoading(state.eventSources)
    ],
    propSetHandlers: {
      dateProfile: handleDateProfile,
      eventStore: handleEventStore
    }
  })
];
var TaskRunner = class {
  constructor(runTaskOption, drainedOption) {
    this.runTaskOption = runTaskOption;
    this.drainedOption = drainedOption;
    this.queue = [];
    this.delayedRunner = new DelayedRunner(this.drain.bind(this));
  }
  request(task, delay) {
    this.queue.push(task);
    this.delayedRunner.request(delay);
  }
  pause(scope) {
    this.delayedRunner.pause(scope);
  }
  resume(scope, force) {
    this.delayedRunner.resume(scope, force);
  }
  drain() {
    let { queue } = this;
    while (queue.length) {
      let completedTasks = [];
      let task;
      while (task = queue.shift()) {
        this.runTask(task);
        completedTasks.push(task);
      }
      this.drained(completedTasks);
    }
  }
  runTask(task) {
    if (this.runTaskOption) {
      this.runTaskOption(task);
    }
  }
  drained(completedTasks) {
    if (this.drainedOption) {
      this.drainedOption(completedTasks);
    }
  }
};
function buildTitle(dateProfile, viewOptions, dateEnv) {
  let range2;
  if (/^(year|month)$/.test(dateProfile.currentRangeUnit)) {
    range2 = dateProfile.currentRange;
  } else {
    range2 = dateProfile.activeRange;
  }
  return dateEnv.formatRange(range2.start, range2.end, createFormatter(viewOptions.titleFormat || buildTitleFormat(dateProfile)), {
    isEndExclusive: dateProfile.isRangeAllDay,
    defaultSeparator: viewOptions.titleRangeSeparator
  });
}
function buildTitleFormat(dateProfile) {
  let { currentRangeUnit } = dateProfile;
  if (currentRangeUnit === "year") {
    return { year: "numeric" };
  }
  if (currentRangeUnit === "month") {
    return { year: "numeric", month: "long" };
  }
  let days = diffWholeDays(dateProfile.currentRange.start, dateProfile.currentRange.end);
  if (days !== null && days > 1) {
    return { year: "numeric", month: "short", day: "numeric" };
  }
  return { year: "numeric", month: "long", day: "numeric" };
}
var CalendarDataManager = class {
  constructor(props) {
    this.computeCurrentViewData = memoize(this._computeCurrentViewData);
    this.organizeRawLocales = memoize(organizeRawLocales);
    this.buildLocale = memoize(buildLocale);
    this.buildPluginHooks = buildBuildPluginHooks();
    this.buildDateEnv = memoize(buildDateEnv$1);
    this.buildTheme = memoize(buildTheme);
    this.parseToolbars = memoize(parseToolbars);
    this.buildViewSpecs = memoize(buildViewSpecs);
    this.buildDateProfileGenerator = memoizeObjArg(buildDateProfileGenerator);
    this.buildViewApi = memoize(buildViewApi);
    this.buildViewUiProps = memoizeObjArg(buildViewUiProps);
    this.buildEventUiBySource = memoize(buildEventUiBySource, isPropsEqual);
    this.buildEventUiBases = memoize(buildEventUiBases);
    this.parseContextBusinessHours = memoizeObjArg(parseContextBusinessHours);
    this.buildTitle = memoize(buildTitle);
    this.emitter = new Emitter();
    this.actionRunner = new TaskRunner(this._handleAction.bind(this), this.updateData.bind(this));
    this.currentCalendarOptionsInput = {};
    this.currentCalendarOptionsRefined = {};
    this.currentViewOptionsInput = {};
    this.currentViewOptionsRefined = {};
    this.currentCalendarOptionsRefiners = {};
    this.optionsForRefining = [];
    this.optionsForHandling = [];
    this.getCurrentData = () => this.data;
    this.dispatch = (action) => {
      this.actionRunner.request(action);
    };
    this.props = props;
    this.actionRunner.pause();
    let dynamicOptionOverrides = {};
    let optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);
    let currentViewType = optionsData.calendarOptions.initialView || optionsData.pluginHooks.initialView;
    let currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides);
    props.calendarApi.currentDataManager = this;
    this.emitter.setThisContext(props.calendarApi);
    this.emitter.setOptions(currentViewData.options);
    let currentDate = getInitialDate(optionsData.calendarOptions, optionsData.dateEnv);
    let dateProfile = currentViewData.dateProfileGenerator.build(currentDate);
    if (!rangeContainsMarker(dateProfile.activeRange, currentDate)) {
      currentDate = dateProfile.currentRange.start;
    }
    let calendarContext = {
      dateEnv: optionsData.dateEnv,
      options: optionsData.calendarOptions,
      pluginHooks: optionsData.pluginHooks,
      calendarApi: props.calendarApi,
      dispatch: this.dispatch,
      emitter: this.emitter,
      getCurrentData: this.getCurrentData
    };
    for (let callback of optionsData.pluginHooks.contextInit) {
      callback(calendarContext);
    }
    let eventSources = initEventSources(optionsData.calendarOptions, dateProfile, calendarContext);
    let initialState = {
      dynamicOptionOverrides,
      currentViewType,
      currentDate,
      dateProfile,
      businessHours: this.parseContextBusinessHours(calendarContext),
      eventSources,
      eventUiBases: {},
      eventStore: createEmptyEventStore(),
      renderableEventStore: createEmptyEventStore(),
      dateSelection: null,
      eventSelection: "",
      eventDrag: null,
      eventResize: null,
      selectionConfig: this.buildViewUiProps(calendarContext).selectionConfig
    };
    let contextAndState = Object.assign(Object.assign({}, calendarContext), initialState);
    for (let reducer of optionsData.pluginHooks.reducers) {
      Object.assign(initialState, reducer(null, null, contextAndState));
    }
    if (computeIsLoading(initialState, calendarContext)) {
      this.emitter.trigger("loading", true);
    }
    this.state = initialState;
    this.updateData();
    this.actionRunner.resume();
  }
  resetOptions(optionOverrides, changedOptionNames) {
    let { props } = this;
    if (changedOptionNames === void 0) {
      props.optionOverrides = optionOverrides;
    } else {
      props.optionOverrides = Object.assign(Object.assign({}, props.optionOverrides || {}), optionOverrides);
      this.optionsForRefining.push(...changedOptionNames);
    }
    if (changedOptionNames === void 0 || changedOptionNames.length) {
      this.actionRunner.request({
        type: "NOTHING"
      });
    }
  }
  _handleAction(action) {
    let { props, state, emitter } = this;
    let dynamicOptionOverrides = reduceDynamicOptionOverrides(state.dynamicOptionOverrides, action);
    let optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);
    let currentViewType = reduceViewType(state.currentViewType, action);
    let currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides);
    props.calendarApi.currentDataManager = this;
    emitter.setThisContext(props.calendarApi);
    emitter.setOptions(currentViewData.options);
    let calendarContext = {
      dateEnv: optionsData.dateEnv,
      options: optionsData.calendarOptions,
      pluginHooks: optionsData.pluginHooks,
      calendarApi: props.calendarApi,
      dispatch: this.dispatch,
      emitter,
      getCurrentData: this.getCurrentData
    };
    let { currentDate, dateProfile } = state;
    if (this.data && this.data.dateProfileGenerator !== currentViewData.dateProfileGenerator) {
      dateProfile = currentViewData.dateProfileGenerator.build(currentDate);
    }
    currentDate = reduceCurrentDate(currentDate, action);
    dateProfile = reduceDateProfile(dateProfile, action, currentDate, currentViewData.dateProfileGenerator);
    if (action.type === "PREV" || // TODO: move this logic into DateProfileGenerator
    action.type === "NEXT" || // "
    !rangeContainsMarker(dateProfile.currentRange, currentDate)) {
      currentDate = dateProfile.currentRange.start;
    }
    let eventSources = reduceEventSources(state.eventSources, action, dateProfile, calendarContext);
    let eventStore = reduceEventStore(state.eventStore, action, eventSources, dateProfile, calendarContext);
    let isEventsLoading = computeEventSourcesLoading(eventSources);
    let renderableEventStore = isEventsLoading && !currentViewData.options.progressiveEventRendering ? state.renderableEventStore || eventStore : (
      // try from previous state
      eventStore
    );
    let { eventUiSingleBase, selectionConfig } = this.buildViewUiProps(calendarContext);
    let eventUiBySource = this.buildEventUiBySource(eventSources);
    let eventUiBases = this.buildEventUiBases(renderableEventStore.defs, eventUiSingleBase, eventUiBySource);
    let newState = {
      dynamicOptionOverrides,
      currentViewType,
      currentDate,
      dateProfile,
      eventSources,
      eventStore,
      renderableEventStore,
      selectionConfig,
      eventUiBases,
      businessHours: this.parseContextBusinessHours(calendarContext),
      dateSelection: reduceDateSelection(state.dateSelection, action),
      eventSelection: reduceSelectedEvent(state.eventSelection, action),
      eventDrag: reduceEventDrag(state.eventDrag, action),
      eventResize: reduceEventResize(state.eventResize, action)
    };
    let contextAndState = Object.assign(Object.assign({}, calendarContext), newState);
    for (let reducer of optionsData.pluginHooks.reducers) {
      Object.assign(newState, reducer(state, action, contextAndState));
    }
    let wasLoading = computeIsLoading(state, calendarContext);
    let isLoading = computeIsLoading(newState, calendarContext);
    if (!wasLoading && isLoading) {
      emitter.trigger("loading", true);
    } else if (wasLoading && !isLoading) {
      emitter.trigger("loading", false);
    }
    this.state = newState;
    if (props.onAction) {
      props.onAction(action);
    }
  }
  updateData() {
    let { props, state } = this;
    let oldData = this.data;
    let optionsData = this.computeOptionsData(props.optionOverrides, state.dynamicOptionOverrides, props.calendarApi);
    let currentViewData = this.computeCurrentViewData(state.currentViewType, optionsData, props.optionOverrides, state.dynamicOptionOverrides);
    let data = this.data = Object.assign(Object.assign(Object.assign({ viewTitle: this.buildTitle(state.dateProfile, currentViewData.options, optionsData.dateEnv), calendarApi: props.calendarApi, dispatch: this.dispatch, emitter: this.emitter, getCurrentData: this.getCurrentData }, optionsData), currentViewData), state);
    let changeHandlers = optionsData.pluginHooks.optionChangeHandlers;
    let oldCalendarOptions = oldData && oldData.calendarOptions;
    let newCalendarOptions = optionsData.calendarOptions;
    if (oldCalendarOptions && oldCalendarOptions !== newCalendarOptions) {
      if (oldCalendarOptions.timeZone !== newCalendarOptions.timeZone) {
        state.eventSources = data.eventSources = reduceEventSourcesNewTimeZone(data.eventSources, state.dateProfile, data);
        state.eventStore = data.eventStore = rezoneEventStoreDates(data.eventStore, oldData.dateEnv, data.dateEnv);
        state.renderableEventStore = data.renderableEventStore = rezoneEventStoreDates(data.renderableEventStore, oldData.dateEnv, data.dateEnv);
      }
      for (let optionName in changeHandlers) {
        if (this.optionsForHandling.indexOf(optionName) !== -1 || oldCalendarOptions[optionName] !== newCalendarOptions[optionName]) {
          changeHandlers[optionName](newCalendarOptions[optionName], data);
        }
      }
    }
    this.optionsForHandling = [];
    if (props.onData) {
      props.onData(data);
    }
  }
  computeOptionsData(optionOverrides, dynamicOptionOverrides, calendarApi) {
    if (!this.optionsForRefining.length && optionOverrides === this.stableOptionOverrides && dynamicOptionOverrides === this.stableDynamicOptionOverrides) {
      return this.stableCalendarOptionsData;
    }
    let { refinedOptions, pluginHooks, localeDefaults, availableLocaleData, extra } = this.processRawCalendarOptions(optionOverrides, dynamicOptionOverrides);
    warnUnknownOptions(extra);
    let dateEnv = this.buildDateEnv(refinedOptions.timeZone, refinedOptions.locale, refinedOptions.weekNumberCalculation, refinedOptions.firstDay, refinedOptions.weekText, pluginHooks, availableLocaleData, refinedOptions.defaultRangeSeparator);
    let viewSpecs = this.buildViewSpecs(pluginHooks.views, this.stableOptionOverrides, this.stableDynamicOptionOverrides, localeDefaults);
    let theme = this.buildTheme(refinedOptions, pluginHooks);
    let toolbarConfig = this.parseToolbars(refinedOptions, this.stableOptionOverrides, theme, viewSpecs, calendarApi);
    return this.stableCalendarOptionsData = {
      calendarOptions: refinedOptions,
      pluginHooks,
      dateEnv,
      viewSpecs,
      theme,
      toolbarConfig,
      localeDefaults,
      availableRawLocales: availableLocaleData.map
    };
  }
  // always called from behind a memoizer
  processRawCalendarOptions(optionOverrides, dynamicOptionOverrides) {
    let { locales, locale } = mergeRawOptions([
      BASE_OPTION_DEFAULTS,
      optionOverrides,
      dynamicOptionOverrides
    ]);
    let availableLocaleData = this.organizeRawLocales(locales);
    let availableRawLocales = availableLocaleData.map;
    let localeDefaults = this.buildLocale(locale || availableLocaleData.defaultCode, availableRawLocales).options;
    let pluginHooks = this.buildPluginHooks(optionOverrides.plugins || [], globalPlugins);
    let refiners = this.currentCalendarOptionsRefiners = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);
    let extra = {};
    let raw = mergeRawOptions([
      BASE_OPTION_DEFAULTS,
      localeDefaults,
      optionOverrides,
      dynamicOptionOverrides
    ]);
    let refined = {};
    let currentRaw = this.currentCalendarOptionsInput;
    let currentRefined = this.currentCalendarOptionsRefined;
    let anyChanges = false;
    for (let optionName in raw) {
      if (this.optionsForRefining.indexOf(optionName) === -1 && (raw[optionName] === currentRaw[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && optionName in currentRaw && COMPLEX_OPTION_COMPARATORS[optionName](currentRaw[optionName], raw[optionName]))) {
        refined[optionName] = currentRefined[optionName];
      } else if (refiners[optionName]) {
        refined[optionName] = refiners[optionName](raw[optionName]);
        anyChanges = true;
      } else {
        extra[optionName] = currentRaw[optionName];
      }
    }
    if (anyChanges) {
      this.currentCalendarOptionsInput = raw;
      this.currentCalendarOptionsRefined = refined;
      this.stableOptionOverrides = optionOverrides;
      this.stableDynamicOptionOverrides = dynamicOptionOverrides;
    }
    this.optionsForHandling.push(...this.optionsForRefining);
    this.optionsForRefining = [];
    return {
      rawOptions: this.currentCalendarOptionsInput,
      refinedOptions: this.currentCalendarOptionsRefined,
      pluginHooks,
      availableLocaleData,
      localeDefaults,
      extra
    };
  }
  _computeCurrentViewData(viewType, optionsData, optionOverrides, dynamicOptionOverrides) {
    let viewSpec = optionsData.viewSpecs[viewType];
    if (!viewSpec) {
      throw new Error(`viewType "${viewType}" is not available. Please make sure you've loaded all neccessary plugins`);
    }
    let { refinedOptions, extra } = this.processRawViewOptions(viewSpec, optionsData.pluginHooks, optionsData.localeDefaults, optionOverrides, dynamicOptionOverrides);
    warnUnknownOptions(extra);
    let dateProfileGenerator = this.buildDateProfileGenerator({
      dateProfileGeneratorClass: viewSpec.optionDefaults.dateProfileGeneratorClass,
      duration: viewSpec.duration,
      durationUnit: viewSpec.durationUnit,
      usesMinMaxTime: viewSpec.optionDefaults.usesMinMaxTime,
      dateEnv: optionsData.dateEnv,
      calendarApi: this.props.calendarApi,
      slotMinTime: refinedOptions.slotMinTime,
      slotMaxTime: refinedOptions.slotMaxTime,
      showNonCurrentDates: refinedOptions.showNonCurrentDates,
      dayCount: refinedOptions.dayCount,
      dateAlignment: refinedOptions.dateAlignment,
      dateIncrement: refinedOptions.dateIncrement,
      hiddenDays: refinedOptions.hiddenDays,
      weekends: refinedOptions.weekends,
      nowInput: refinedOptions.now,
      validRangeInput: refinedOptions.validRange,
      visibleRangeInput: refinedOptions.visibleRange,
      fixedWeekCount: refinedOptions.fixedWeekCount
    });
    let viewApi = this.buildViewApi(viewType, this.getCurrentData, optionsData.dateEnv);
    return { viewSpec, options: refinedOptions, dateProfileGenerator, viewApi };
  }
  processRawViewOptions(viewSpec, pluginHooks, localeDefaults, optionOverrides, dynamicOptionOverrides) {
    let raw = mergeRawOptions([
      BASE_OPTION_DEFAULTS,
      viewSpec.optionDefaults,
      localeDefaults,
      optionOverrides,
      viewSpec.optionOverrides,
      dynamicOptionOverrides
    ]);
    let refiners = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), VIEW_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);
    let refined = {};
    let currentRaw = this.currentViewOptionsInput;
    let currentRefined = this.currentViewOptionsRefined;
    let anyChanges = false;
    let extra = {};
    for (let optionName in raw) {
      if (raw[optionName] === currentRaw[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && COMPLEX_OPTION_COMPARATORS[optionName](raw[optionName], currentRaw[optionName])) {
        refined[optionName] = currentRefined[optionName];
      } else {
        if (raw[optionName] === this.currentCalendarOptionsInput[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && COMPLEX_OPTION_COMPARATORS[optionName](raw[optionName], this.currentCalendarOptionsInput[optionName])) {
          if (optionName in this.currentCalendarOptionsRefined) {
            refined[optionName] = this.currentCalendarOptionsRefined[optionName];
          }
        } else if (refiners[optionName]) {
          refined[optionName] = refiners[optionName](raw[optionName]);
        } else {
          extra[optionName] = raw[optionName];
        }
        anyChanges = true;
      }
    }
    if (anyChanges) {
      this.currentViewOptionsInput = raw;
      this.currentViewOptionsRefined = refined;
    }
    return {
      rawOptions: this.currentViewOptionsInput,
      refinedOptions: this.currentViewOptionsRefined,
      extra
    };
  }
};
function buildDateEnv$1(timeZone, explicitLocale, weekNumberCalculation, firstDay, weekText, pluginHooks, availableLocaleData, defaultSeparator) {
  let locale = buildLocale(explicitLocale || availableLocaleData.defaultCode, availableLocaleData.map);
  return new DateEnv({
    calendarSystem: "gregory",
    timeZone,
    namedTimeZoneImpl: pluginHooks.namedTimeZonedImpl,
    locale,
    weekNumberCalculation,
    firstDay,
    weekText,
    cmdFormatter: pluginHooks.cmdFormatter,
    defaultSeparator
  });
}
function buildTheme(options, pluginHooks) {
  let ThemeClass = pluginHooks.themeClasses[options.themeSystem] || StandardTheme;
  return new ThemeClass(options);
}
function buildDateProfileGenerator(props) {
  let DateProfileGeneratorClass = props.dateProfileGeneratorClass || DateProfileGenerator;
  return new DateProfileGeneratorClass(props);
}
function buildViewApi(type, getCurrentData, dateEnv) {
  return new ViewImpl(type, getCurrentData, dateEnv);
}
function buildEventUiBySource(eventSources) {
  return mapHash(eventSources, (eventSource) => eventSource.ui);
}
function buildEventUiBases(eventDefs, eventUiSingleBase, eventUiBySource) {
  let eventUiBases = { "": eventUiSingleBase };
  for (let defId in eventDefs) {
    let def = eventDefs[defId];
    if (def.sourceId && eventUiBySource[def.sourceId]) {
      eventUiBases[defId] = eventUiBySource[def.sourceId];
    }
  }
  return eventUiBases;
}
function buildViewUiProps(calendarContext) {
  let { options } = calendarContext;
  return {
    eventUiSingleBase: createEventUi({
      display: options.eventDisplay,
      editable: options.editable,
      startEditable: options.eventStartEditable,
      durationEditable: options.eventDurationEditable,
      constraint: options.eventConstraint,
      overlap: typeof options.eventOverlap === "boolean" ? options.eventOverlap : void 0,
      allow: options.eventAllow,
      backgroundColor: options.eventBackgroundColor,
      borderColor: options.eventBorderColor,
      textColor: options.eventTextColor,
      color: options.eventColor
      // classNames: options.eventClassNames // render hook will handle this
    }, calendarContext),
    selectionConfig: createEventUi({
      constraint: options.selectConstraint,
      overlap: typeof options.selectOverlap === "boolean" ? options.selectOverlap : void 0,
      allow: options.selectAllow
    }, calendarContext)
  };
}
function computeIsLoading(state, context) {
  for (let isLoadingFunc of context.pluginHooks.isLoadingFuncs) {
    if (isLoadingFunc(state)) {
      return true;
    }
  }
  return false;
}
function parseContextBusinessHours(calendarContext) {
  return parseBusinessHours(calendarContext.options.businessHours, calendarContext);
}
function warnUnknownOptions(options, viewName) {
  for (let optionName in options) {
    console.warn(`Unknown option '${optionName}'` + (viewName ? ` for view '${viewName}'` : ""));
  }
}
var ToolbarSection = class extends BaseComponent {
  render() {
    let children = this.props.widgetGroups.map((widgetGroup) => this.renderWidgetGroup(widgetGroup));
    return y("div", { className: "fc-toolbar-chunk" }, ...children);
  }
  renderWidgetGroup(widgetGroup) {
    let { props } = this;
    let { theme } = this.context;
    let children = [];
    let isOnlyButtons = true;
    for (let widget of widgetGroup) {
      let { buttonName, buttonClick, buttonText, buttonIcon, buttonHint } = widget;
      if (buttonName === "title") {
        isOnlyButtons = false;
        children.push(y("h2", { className: "fc-toolbar-title", id: props.titleId }, props.title));
      } else {
        let isPressed = buttonName === props.activeButton;
        let isDisabled = !props.isTodayEnabled && buttonName === "today" || !props.isPrevEnabled && buttonName === "prev" || !props.isNextEnabled && buttonName === "next";
        let buttonClasses = [`fc-${buttonName}-button`, theme.getClass("button")];
        if (isPressed) {
          buttonClasses.push(theme.getClass("buttonActive"));
        }
        children.push(y("button", { type: "button", title: typeof buttonHint === "function" ? buttonHint(props.navUnit) : buttonHint, disabled: isDisabled, "aria-pressed": isPressed, className: buttonClasses.join(" "), onClick: buttonClick }, buttonText || (buttonIcon ? y("span", { className: buttonIcon, role: "img" }) : "")));
      }
    }
    if (children.length > 1) {
      let groupClassName = isOnlyButtons && theme.getClass("buttonGroup") || "";
      return y("div", { className: groupClassName }, ...children);
    }
    return children[0];
  }
};
var Toolbar = class extends BaseComponent {
  render() {
    let { model, extraClassName } = this.props;
    let forceLtr = false;
    let startContent;
    let endContent;
    let sectionWidgets = model.sectionWidgets;
    let centerContent = sectionWidgets.center;
    if (sectionWidgets.left) {
      forceLtr = true;
      startContent = sectionWidgets.left;
    } else {
      startContent = sectionWidgets.start;
    }
    if (sectionWidgets.right) {
      forceLtr = true;
      endContent = sectionWidgets.right;
    } else {
      endContent = sectionWidgets.end;
    }
    let classNames = [
      extraClassName || "",
      "fc-toolbar",
      forceLtr ? "fc-toolbar-ltr" : ""
    ];
    return y(
      "div",
      { className: classNames.join(" ") },
      this.renderSection("start", startContent || []),
      this.renderSection("center", centerContent || []),
      this.renderSection("end", endContent || [])
    );
  }
  renderSection(key, widgetGroups) {
    let { props } = this;
    return y(ToolbarSection, { key, widgetGroups, title: props.title, navUnit: props.navUnit, activeButton: props.activeButton, isTodayEnabled: props.isTodayEnabled, isPrevEnabled: props.isPrevEnabled, isNextEnabled: props.isNextEnabled, titleId: props.titleId });
  }
};
var ViewHarness = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.state = {
      availableWidth: null
    };
    this.handleEl = (el) => {
      this.el = el;
      setRef(this.props.elRef, el);
      this.updateAvailableWidth();
    };
    this.handleResize = () => {
      this.updateAvailableWidth();
    };
  }
  render() {
    let { props, state } = this;
    let { aspectRatio } = props;
    let classNames = [
      "fc-view-harness",
      aspectRatio || props.liquid || props.height ? "fc-view-harness-active" : "fc-view-harness-passive"
      // let the view do the height
    ];
    let height = "";
    let paddingBottom = "";
    if (aspectRatio) {
      if (state.availableWidth !== null) {
        height = state.availableWidth / aspectRatio;
      } else {
        paddingBottom = `${1 / aspectRatio * 100}%`;
      }
    } else {
      height = props.height || "";
    }
    return y("div", { "aria-labelledby": props.labeledById, ref: this.handleEl, className: classNames.join(" "), style: { height, paddingBottom } }, props.children);
  }
  componentDidMount() {
    this.context.addResizeHandler(this.handleResize);
  }
  componentWillUnmount() {
    this.context.removeResizeHandler(this.handleResize);
  }
  updateAvailableWidth() {
    if (this.el && // needed. but why?
    this.props.aspectRatio) {
      this.setState({ availableWidth: this.el.offsetWidth });
    }
  }
};
var EventClicking = class extends Interaction {
  constructor(settings) {
    super(settings);
    this.handleSegClick = (ev, segEl) => {
      let { component } = this;
      let { context } = component;
      let seg = getElSeg(segEl);
      if (seg && // might be the <div> surrounding the more link
      component.isValidSegDownEl(ev.target)) {
        let hasUrlContainer = elementClosest(ev.target, ".fc-event-forced-url");
        let url = hasUrlContainer ? hasUrlContainer.querySelector("a[href]").href : "";
        context.emitter.trigger("eventClick", {
          el: segEl,
          event: new EventImpl(component.context, seg.eventRange.def, seg.eventRange.instance),
          jsEvent: ev,
          view: context.viewApi
        });
        if (url && !ev.defaultPrevented) {
          window.location.href = url;
        }
      }
    };
    this.destroy = listenBySelector(
      settings.el,
      "click",
      ".fc-event",
      // on both fg and bg events
      this.handleSegClick
    );
  }
};
var EventHovering = class extends Interaction {
  constructor(settings) {
    super(settings);
    this.handleEventElRemove = (el) => {
      if (el === this.currentSegEl) {
        this.handleSegLeave(null, this.currentSegEl);
      }
    };
    this.handleSegEnter = (ev, segEl) => {
      if (getElSeg(segEl)) {
        this.currentSegEl = segEl;
        this.triggerEvent("eventMouseEnter", ev, segEl);
      }
    };
    this.handleSegLeave = (ev, segEl) => {
      if (this.currentSegEl) {
        this.currentSegEl = null;
        this.triggerEvent("eventMouseLeave", ev, segEl);
      }
    };
    this.removeHoverListeners = listenToHoverBySelector(
      settings.el,
      ".fc-event",
      // on both fg and bg events
      this.handleSegEnter,
      this.handleSegLeave
    );
  }
  destroy() {
    this.removeHoverListeners();
  }
  triggerEvent(publicEvName, ev, segEl) {
    let { component } = this;
    let { context } = component;
    let seg = getElSeg(segEl);
    if (!ev || component.isValidSegDownEl(ev.target)) {
      context.emitter.trigger(publicEvName, {
        el: segEl,
        event: new EventImpl(context, seg.eventRange.def, seg.eventRange.instance),
        jsEvent: ev,
        view: context.viewApi
      });
    }
  }
};
var CalendarContent = class extends PureComponent {
  constructor() {
    super(...arguments);
    this.buildViewContext = memoize(buildViewContext);
    this.buildViewPropTransformers = memoize(buildViewPropTransformers);
    this.buildToolbarProps = memoize(buildToolbarProps);
    this.headerRef = d();
    this.footerRef = d();
    this.interactionsStore = {};
    this.state = {
      viewLabelId: getUniqueDomId()
    };
    this.registerInteractiveComponent = (component, settingsInput) => {
      let settings = parseInteractionSettings(component, settingsInput);
      let DEFAULT_INTERACTIONS = [
        EventClicking,
        EventHovering
      ];
      let interactionClasses = DEFAULT_INTERACTIONS.concat(this.props.pluginHooks.componentInteractions);
      let interactions = interactionClasses.map((TheInteractionClass) => new TheInteractionClass(settings));
      this.interactionsStore[component.uid] = interactions;
      interactionSettingsStore[component.uid] = settings;
    };
    this.unregisterInteractiveComponent = (component) => {
      let listeners = this.interactionsStore[component.uid];
      if (listeners) {
        for (let listener of listeners) {
          listener.destroy();
        }
        delete this.interactionsStore[component.uid];
      }
      delete interactionSettingsStore[component.uid];
    };
    this.resizeRunner = new DelayedRunner(() => {
      this.props.emitter.trigger("_resize", true);
      this.props.emitter.trigger("windowResize", { view: this.props.viewApi });
    });
    this.handleWindowResize = (ev) => {
      let { options } = this.props;
      if (options.handleWindowResize && ev.target === window) {
        this.resizeRunner.request(options.windowResizeDelay);
      }
    };
  }
  /*
  renders INSIDE of an outer div
  */
  render() {
    let { props } = this;
    let { toolbarConfig, options } = props;
    let toolbarProps = this.buildToolbarProps(
      props.viewSpec,
      props.dateProfile,
      props.dateProfileGenerator,
      props.currentDate,
      getNow(props.options.now, props.dateEnv),
      // TODO: use NowTimer????
      props.viewTitle
    );
    let viewVGrow = false;
    let viewHeight = "";
    let viewAspectRatio;
    if (props.isHeightAuto || props.forPrint) {
      viewHeight = "";
    } else if (options.height != null) {
      viewVGrow = true;
    } else if (options.contentHeight != null) {
      viewHeight = options.contentHeight;
    } else {
      viewAspectRatio = Math.max(options.aspectRatio, 0.5);
    }
    let viewContext = this.buildViewContext(props.viewSpec, props.viewApi, props.options, props.dateProfileGenerator, props.dateEnv, props.theme, props.pluginHooks, props.dispatch, props.getCurrentData, props.emitter, props.calendarApi, this.registerInteractiveComponent, this.unregisterInteractiveComponent);
    let viewLabelId = toolbarConfig.header && toolbarConfig.header.hasTitle ? this.state.viewLabelId : void 0;
    return y(
      ViewContextType.Provider,
      { value: viewContext },
      toolbarConfig.header && y(Toolbar, Object.assign({ ref: this.headerRef, extraClassName: "fc-header-toolbar", model: toolbarConfig.header, titleId: viewLabelId }, toolbarProps)),
      y(
        ViewHarness,
        { liquid: viewVGrow, height: viewHeight, aspectRatio: viewAspectRatio, labeledById: viewLabelId },
        this.renderView(props),
        this.buildAppendContent()
      ),
      toolbarConfig.footer && y(Toolbar, Object.assign({ ref: this.footerRef, extraClassName: "fc-footer-toolbar", model: toolbarConfig.footer, titleId: "" }, toolbarProps))
    );
  }
  componentDidMount() {
    let { props } = this;
    this.calendarInteractions = props.pluginHooks.calendarInteractions.map((CalendarInteractionClass) => new CalendarInteractionClass(props));
    window.addEventListener("resize", this.handleWindowResize);
    let { propSetHandlers } = props.pluginHooks;
    for (let propName in propSetHandlers) {
      propSetHandlers[propName](props[propName], props);
    }
  }
  componentDidUpdate(prevProps) {
    let { props } = this;
    let { propSetHandlers } = props.pluginHooks;
    for (let propName in propSetHandlers) {
      if (props[propName] !== prevProps[propName]) {
        propSetHandlers[propName](props[propName], props);
      }
    }
  }
  componentWillUnmount() {
    window.removeEventListener("resize", this.handleWindowResize);
    this.resizeRunner.clear();
    for (let interaction of this.calendarInteractions) {
      interaction.destroy();
    }
    this.props.emitter.trigger("_unmount");
  }
  buildAppendContent() {
    let { props } = this;
    let children = props.pluginHooks.viewContainerAppends.map((buildAppendContent) => buildAppendContent(props));
    return y(_, {}, ...children);
  }
  renderView(props) {
    let { pluginHooks } = props;
    let { viewSpec } = props;
    let viewProps = {
      dateProfile: props.dateProfile,
      businessHours: props.businessHours,
      eventStore: props.renderableEventStore,
      eventUiBases: props.eventUiBases,
      dateSelection: props.dateSelection,
      eventSelection: props.eventSelection,
      eventDrag: props.eventDrag,
      eventResize: props.eventResize,
      isHeightAuto: props.isHeightAuto,
      forPrint: props.forPrint
    };
    let transformers = this.buildViewPropTransformers(pluginHooks.viewPropsTransformers);
    for (let transformer of transformers) {
      Object.assign(viewProps, transformer.transform(viewProps, props));
    }
    let ViewComponent = viewSpec.component;
    return y(ViewComponent, Object.assign({}, viewProps));
  }
};
function buildToolbarProps(viewSpec, dateProfile, dateProfileGenerator, currentDate, now, title) {
  let todayInfo = dateProfileGenerator.build(now, void 0, false);
  let prevInfo = dateProfileGenerator.buildPrev(dateProfile, currentDate, false);
  let nextInfo = dateProfileGenerator.buildNext(dateProfile, currentDate, false);
  return {
    title,
    activeButton: viewSpec.type,
    navUnit: viewSpec.singleUnit,
    isTodayEnabled: todayInfo.isValid && !rangeContainsMarker(dateProfile.currentRange, now),
    isPrevEnabled: prevInfo.isValid,
    isNextEnabled: nextInfo.isValid
  };
}
function buildViewPropTransformers(theClasses) {
  return theClasses.map((TheClass) => new TheClass());
}
var Calendar = class extends CalendarImpl {
  constructor(el, optionOverrides = {}) {
    super();
    this.isRendering = false;
    this.isRendered = false;
    this.currentClassNames = [];
    this.customContentRenderId = 0;
    this.handleAction = (action) => {
      switch (action.type) {
        case "SET_EVENT_DRAG":
        case "SET_EVENT_RESIZE":
          this.renderRunner.tryDrain();
      }
    };
    this.handleData = (data) => {
      this.currentData = data;
      this.renderRunner.request(data.calendarOptions.rerenderDelay);
    };
    this.handleRenderRequest = () => {
      if (this.isRendering) {
        this.isRendered = true;
        let { currentData } = this;
        flushSync(() => {
          D(y(CalendarRoot, { options: currentData.calendarOptions, theme: currentData.theme, emitter: currentData.emitter }, (classNames, height, isHeightAuto, forPrint) => {
            this.setClassNames(classNames);
            this.setHeight(height);
            return y(
              RenderId.Provider,
              { value: this.customContentRenderId },
              y(CalendarContent, Object.assign({ isHeightAuto, forPrint }, currentData))
            );
          }), this.el);
        });
      } else if (this.isRendered) {
        this.isRendered = false;
        D(null, this.el);
        this.setClassNames([]);
        this.setHeight("");
      }
    };
    ensureElHasStyles(el);
    this.el = el;
    this.renderRunner = new DelayedRunner(this.handleRenderRequest);
    new CalendarDataManager({
      optionOverrides,
      calendarApi: this,
      onAction: this.handleAction,
      onData: this.handleData
    });
  }
  render() {
    let wasRendering = this.isRendering;
    if (!wasRendering) {
      this.isRendering = true;
    } else {
      this.customContentRenderId += 1;
    }
    this.renderRunner.request();
    if (wasRendering) {
      this.updateSize();
    }
  }
  destroy() {
    if (this.isRendering) {
      this.isRendering = false;
      this.renderRunner.request();
    }
  }
  updateSize() {
    flushSync(() => {
      super.updateSize();
    });
  }
  batchRendering(func) {
    this.renderRunner.pause("batchRendering");
    func();
    this.renderRunner.resume("batchRendering");
  }
  pauseRendering() {
    this.renderRunner.pause("pauseRendering");
  }
  resumeRendering() {
    this.renderRunner.resume("pauseRendering", true);
  }
  resetOptions(optionOverrides, changedOptionNames) {
    this.currentDataManager.resetOptions(optionOverrides, changedOptionNames);
  }
  setClassNames(classNames) {
    if (!isArraysEqual(classNames, this.currentClassNames)) {
      let { classList } = this.el;
      for (let className of this.currentClassNames) {
        classList.remove(className);
      }
      for (let className of classNames) {
        classList.add(className);
      }
      this.currentClassNames = classNames;
    }
  }
  setHeight(height) {
    applyStyleProp(this.el, "height", height);
  }
};

// node_modules/@fullcalendar/daygrid/internal.js
var TableView = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.headerElRef = d();
  }
  renderSimpleLayout(headerRowContent, bodyContent) {
    let { props, context } = this;
    let sections = [];
    let stickyHeaderDates = getStickyHeaderDates(context.options);
    if (headerRowContent) {
      sections.push({
        type: "header",
        key: "header",
        isSticky: stickyHeaderDates,
        chunk: {
          elRef: this.headerElRef,
          tableClassName: "fc-col-header",
          rowContent: headerRowContent
        }
      });
    }
    sections.push({
      type: "body",
      key: "body",
      liquid: true,
      chunk: { content: bodyContent }
    });
    return y(
      ViewContainer,
      { elClasses: ["fc-daygrid"], viewSpec: context.viewSpec },
      y(SimpleScrollGrid, { liquid: !props.isHeightAuto && !props.forPrint, collapsibleWidth: props.forPrint, cols: [], sections })
    );
  }
  renderHScrollLayout(headerRowContent, bodyContent, colCnt, dayMinWidth) {
    let ScrollGrid = this.context.pluginHooks.scrollGridImpl;
    if (!ScrollGrid) {
      throw new Error("No ScrollGrid implementation");
    }
    let { props, context } = this;
    let stickyHeaderDates = !props.forPrint && getStickyHeaderDates(context.options);
    let stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(context.options);
    let sections = [];
    if (headerRowContent) {
      sections.push({
        type: "header",
        key: "header",
        isSticky: stickyHeaderDates,
        chunks: [{
          key: "main",
          elRef: this.headerElRef,
          tableClassName: "fc-col-header",
          rowContent: headerRowContent
        }]
      });
    }
    sections.push({
      type: "body",
      key: "body",
      liquid: true,
      chunks: [{
        key: "main",
        content: bodyContent
      }]
    });
    if (stickyFooterScrollbar) {
      sections.push({
        type: "footer",
        key: "footer",
        isSticky: true,
        chunks: [{
          key: "main",
          content: renderScrollShim
        }]
      });
    }
    return y(
      ViewContainer,
      { elClasses: ["fc-daygrid"], viewSpec: context.viewSpec },
      y(ScrollGrid, { liquid: !props.isHeightAuto && !props.forPrint, forPrint: props.forPrint, collapsibleWidth: props.forPrint, colGroups: [{ cols: [{ span: colCnt, minWidth: dayMinWidth }] }], sections })
    );
  }
};
function splitSegsByRow(segs, rowCnt) {
  let byRow = [];
  for (let i3 = 0; i3 < rowCnt; i3 += 1) {
    byRow[i3] = [];
  }
  for (let seg of segs) {
    byRow[seg.row].push(seg);
  }
  return byRow;
}
function splitSegsByFirstCol(segs, colCnt) {
  let byCol = [];
  for (let i3 = 0; i3 < colCnt; i3 += 1) {
    byCol[i3] = [];
  }
  for (let seg of segs) {
    byCol[seg.firstCol].push(seg);
  }
  return byCol;
}
function splitInteractionByRow(ui, rowCnt) {
  let byRow = [];
  if (!ui) {
    for (let i3 = 0; i3 < rowCnt; i3 += 1) {
      byRow[i3] = null;
    }
  } else {
    for (let i3 = 0; i3 < rowCnt; i3 += 1) {
      byRow[i3] = {
        affectedInstances: ui.affectedInstances,
        isEvent: ui.isEvent,
        segs: []
      };
    }
    for (let seg of ui.segs) {
      byRow[seg.row].segs.push(seg);
    }
  }
  return byRow;
}
var DEFAULT_TABLE_EVENT_TIME_FORMAT = createFormatter({
  hour: "numeric",
  minute: "2-digit",
  omitZeroMinute: true,
  meridiem: "narrow"
});
function hasListItemDisplay(seg) {
  let { display: display2 } = seg.eventRange.ui;
  return display2 === "list-item" || display2 === "auto" && !seg.eventRange.def.allDay && seg.firstCol === seg.lastCol && // can't be multi-day
  seg.isStart && // "
  seg.isEnd;
}
var TableBlockEvent = class extends BaseComponent {
  render() {
    let { props } = this;
    return y(StandardEvent, Object.assign({}, props, { elClasses: ["fc-daygrid-event", "fc-daygrid-block-event", "fc-h-event"], defaultTimeFormat: DEFAULT_TABLE_EVENT_TIME_FORMAT, defaultDisplayEventEnd: props.defaultDisplayEventEnd, disableResizing: !props.seg.eventRange.def.allDay }));
  }
};
var TableListItemEvent = class extends BaseComponent {
  render() {
    let { props, context } = this;
    let { options } = context;
    let { seg } = props;
    let timeFormat = options.eventTimeFormat || DEFAULT_TABLE_EVENT_TIME_FORMAT;
    let timeText = buildSegTimeText(seg, timeFormat, context, true, props.defaultDisplayEventEnd);
    return y(EventContainer, Object.assign({}, props, { elTag: "a", elClasses: ["fc-daygrid-event", "fc-daygrid-dot-event"], elAttrs: getSegAnchorAttrs(props.seg, context), defaultGenerator: renderInnerContent2, timeText, isResizing: false, isDateSelecting: false }));
  }
};
function renderInnerContent2(renderProps) {
  return y(
    _,
    null,
    y("div", { className: "fc-daygrid-event-dot", style: { borderColor: renderProps.borderColor || renderProps.backgroundColor } }),
    renderProps.timeText && y("div", { className: "fc-event-time" }, renderProps.timeText),
    y("div", { className: "fc-event-title" }, renderProps.event.title || y(_, null, "\xA0"))
  );
}
var TableCellMoreLink = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.compileSegs = memoize(compileSegs);
  }
  render() {
    let { props } = this;
    let { allSegs, invisibleSegs } = this.compileSegs(props.singlePlacements);
    return y(MoreLinkContainer, { elClasses: ["fc-daygrid-more-link"], dateProfile: props.dateProfile, todayRange: props.todayRange, allDayDate: props.allDayDate, moreCnt: props.moreCnt, allSegs, hiddenSegs: invisibleSegs, alignmentElRef: props.alignmentElRef, alignGridTop: props.alignGridTop, extraDateSpan: props.extraDateSpan, popoverContent: () => {
      let isForcedInvisible = (props.eventDrag ? props.eventDrag.affectedInstances : null) || (props.eventResize ? props.eventResize.affectedInstances : null) || {};
      return y(_, null, allSegs.map((seg) => {
        let instanceId = seg.eventRange.instance.instanceId;
        return y("div", { className: "fc-daygrid-event-harness", key: instanceId, style: {
          visibility: isForcedInvisible[instanceId] ? "hidden" : ""
        } }, hasListItemDisplay(seg) ? y(TableListItemEvent, Object.assign({ seg, isDragging: false, isSelected: instanceId === props.eventSelection, defaultDisplayEventEnd: false }, getSegMeta(seg, props.todayRange))) : y(TableBlockEvent, Object.assign({ seg, isDragging: false, isResizing: false, isDateSelecting: false, isSelected: instanceId === props.eventSelection, defaultDisplayEventEnd: false }, getSegMeta(seg, props.todayRange))));
      }));
    } });
  }
};
function compileSegs(singlePlacements) {
  let allSegs = [];
  let invisibleSegs = [];
  for (let placement of singlePlacements) {
    allSegs.push(placement.seg);
    if (!placement.isVisible) {
      invisibleSegs.push(placement.seg);
    }
  }
  return { allSegs, invisibleSegs };
}
var DEFAULT_WEEK_NUM_FORMAT = createFormatter({ week: "narrow" });
var TableCell = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.rootElRef = d();
    this.state = {
      dayNumberId: getUniqueDomId()
    };
    this.handleRootEl = (el) => {
      setRef(this.rootElRef, el);
      setRef(this.props.elRef, el);
    };
  }
  render() {
    let { context, props, state, rootElRef } = this;
    let { options, dateEnv } = context;
    let { date, dateProfile } = props;
    const isMonthStart = props.showDayNumber && shouldDisplayMonthStart(date, dateProfile.currentRange, dateEnv);
    return y(DayCellContainer, { elTag: "td", elRef: this.handleRootEl, elClasses: [
      "fc-daygrid-day",
      ...props.extraClassNames || []
    ], elAttrs: Object.assign(Object.assign(Object.assign({}, props.extraDataAttrs), props.showDayNumber ? { "aria-labelledby": state.dayNumberId } : {}), { role: "gridcell" }), defaultGenerator: renderTopInner, date, dateProfile, todayRange: props.todayRange, showDayNumber: props.showDayNumber, isMonthStart, extraRenderProps: props.extraRenderProps }, (InnerContent, renderProps) => y(
      "div",
      { ref: props.innerElRef, className: "fc-daygrid-day-frame fc-scrollgrid-sync-inner", style: { minHeight: props.minHeight } },
      props.showWeekNumber && y(WeekNumberContainer, { elTag: "a", elClasses: ["fc-daygrid-week-number"], elAttrs: buildNavLinkAttrs(context, date, "week"), date, defaultFormat: DEFAULT_WEEK_NUM_FORMAT }),
      !renderProps.isDisabled && (props.showDayNumber || hasCustomDayCellContent(options) || props.forceDayTop) ? y(
        "div",
        { className: "fc-daygrid-day-top" },
        y(InnerContent, { elTag: "a", elClasses: [
          "fc-daygrid-day-number",
          isMonthStart && "fc-daygrid-month-start"
        ], elAttrs: Object.assign(Object.assign({}, buildNavLinkAttrs(context, date)), { id: state.dayNumberId }) })
      ) : props.showDayNumber ? (
        // for creating correct amount of space (see issue #7162)
        y(
          "div",
          { className: "fc-daygrid-day-top", style: { visibility: "hidden" } },
          y("a", { className: "fc-daygrid-day-number" }, "\xA0")
        )
      ) : void 0,
      y(
        "div",
        { className: "fc-daygrid-day-events", ref: props.fgContentElRef },
        props.fgContent,
        y(
          "div",
          { className: "fc-daygrid-day-bottom", style: { marginTop: props.moreMarginTop } },
          y(TableCellMoreLink, { allDayDate: date, singlePlacements: props.singlePlacements, moreCnt: props.moreCnt, alignmentElRef: rootElRef, alignGridTop: !props.showDayNumber, extraDateSpan: props.extraDateSpan, dateProfile: props.dateProfile, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, todayRange: props.todayRange })
        )
      ),
      y("div", { className: "fc-daygrid-day-bg" }, props.bgContent)
    ));
  }
};
function renderTopInner(props) {
  return props.dayNumberText || y(_, null, "\xA0");
}
function shouldDisplayMonthStart(date, currentRange, dateEnv) {
  const { start: currentStart, end: currentEnd } = currentRange;
  const currentEndIncl = addMs(currentEnd, -1);
  const currentFirstYear = dateEnv.getYear(currentStart);
  const currentFirstMonth = dateEnv.getMonth(currentStart);
  const currentLastYear = dateEnv.getYear(currentEndIncl);
  const currentLastMonth = dateEnv.getMonth(currentEndIncl);
  return !(currentFirstYear === currentLastYear && currentFirstMonth === currentLastMonth) && Boolean(
    // first date in current view?
    date.valueOf() === currentStart.valueOf() || // a month-start that's within the current range?
    dateEnv.getDay(date) === 1 && date.valueOf() < currentEnd.valueOf()
  );
}
function generateSegKey(seg) {
  return seg.eventRange.instance.instanceId + ":" + seg.firstCol;
}
function generateSegUid(seg) {
  return generateSegKey(seg) + ":" + seg.lastCol;
}
function computeFgSegPlacement(segs, dayMaxEvents, dayMaxEventRows, strictOrder, segHeights, maxContentHeight, cells) {
  let hierarchy = new DayGridSegHierarchy((segEntry) => {
    let segUid = segs[segEntry.index].eventRange.instance.instanceId + ":" + segEntry.span.start + ":" + (segEntry.span.end - 1);
    return segHeights[segUid] || 1;
  });
  hierarchy.allowReslicing = true;
  hierarchy.strictOrder = strictOrder;
  if (dayMaxEvents === true || dayMaxEventRows === true) {
    hierarchy.maxCoord = maxContentHeight;
    hierarchy.hiddenConsumes = true;
  } else if (typeof dayMaxEvents === "number") {
    hierarchy.maxStackCnt = dayMaxEvents;
  } else if (typeof dayMaxEventRows === "number") {
    hierarchy.maxStackCnt = dayMaxEventRows;
    hierarchy.hiddenConsumes = true;
  }
  let segInputs = [];
  let unknownHeightSegs = [];
  for (let i3 = 0; i3 < segs.length; i3 += 1) {
    let seg = segs[i3];
    let segUid = generateSegUid(seg);
    let eventHeight = segHeights[segUid];
    if (eventHeight != null) {
      segInputs.push({
        index: i3,
        span: {
          start: seg.firstCol,
          end: seg.lastCol + 1
        }
      });
    } else {
      unknownHeightSegs.push(seg);
    }
  }
  let hiddenEntries = hierarchy.addSegs(segInputs);
  let segRects = hierarchy.toRects();
  let { singleColPlacements, multiColPlacements, leftoverMargins } = placeRects(segRects, segs, cells);
  let moreCnts = [];
  let moreMarginTops = [];
  for (let seg of unknownHeightSegs) {
    multiColPlacements[seg.firstCol].push({
      seg,
      isVisible: false,
      isAbsolute: true,
      absoluteTop: 0,
      marginTop: 0
    });
    for (let col = seg.firstCol; col <= seg.lastCol; col += 1) {
      singleColPlacements[col].push({
        seg: resliceSeg(seg, col, col + 1, cells),
        isVisible: false,
        isAbsolute: false,
        absoluteTop: 0,
        marginTop: 0
      });
    }
  }
  for (let col = 0; col < cells.length; col += 1) {
    moreCnts.push(0);
  }
  for (let hiddenEntry of hiddenEntries) {
    let seg = segs[hiddenEntry.index];
    let hiddenSpan = hiddenEntry.span;
    multiColPlacements[hiddenSpan.start].push({
      seg: resliceSeg(seg, hiddenSpan.start, hiddenSpan.end, cells),
      isVisible: false,
      isAbsolute: true,
      absoluteTop: 0,
      marginTop: 0
    });
    for (let col = hiddenSpan.start; col < hiddenSpan.end; col += 1) {
      moreCnts[col] += 1;
      singleColPlacements[col].push({
        seg: resliceSeg(seg, col, col + 1, cells),
        isVisible: false,
        isAbsolute: false,
        absoluteTop: 0,
        marginTop: 0
      });
    }
  }
  for (let col = 0; col < cells.length; col += 1) {
    moreMarginTops.push(leftoverMargins[col]);
  }
  return { singleColPlacements, multiColPlacements, moreCnts, moreMarginTops };
}
function placeRects(allRects, segs, cells) {
  let rectsByEachCol = groupRectsByEachCol(allRects, cells.length);
  let singleColPlacements = [];
  let multiColPlacements = [];
  let leftoverMargins = [];
  for (let col = 0; col < cells.length; col += 1) {
    let rects = rectsByEachCol[col];
    let singlePlacements = [];
    let currentHeight = 0;
    let currentMarginTop = 0;
    for (let rect of rects) {
      let seg = segs[rect.index];
      singlePlacements.push({
        seg: resliceSeg(seg, col, col + 1, cells),
        isVisible: true,
        isAbsolute: false,
        absoluteTop: rect.levelCoord,
        marginTop: rect.levelCoord - currentHeight
      });
      currentHeight = rect.levelCoord + rect.thickness;
    }
    let multiPlacements = [];
    currentHeight = 0;
    currentMarginTop = 0;
    for (let rect of rects) {
      let seg = segs[rect.index];
      let isAbsolute = rect.span.end - rect.span.start > 1;
      let isFirstCol = rect.span.start === col;
      currentMarginTop += rect.levelCoord - currentHeight;
      currentHeight = rect.levelCoord + rect.thickness;
      if (isAbsolute) {
        currentMarginTop += rect.thickness;
        if (isFirstCol) {
          multiPlacements.push({
            seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),
            isVisible: true,
            isAbsolute: true,
            absoluteTop: rect.levelCoord,
            marginTop: 0
          });
        }
      } else if (isFirstCol) {
        multiPlacements.push({
          seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),
          isVisible: true,
          isAbsolute: false,
          absoluteTop: rect.levelCoord,
          marginTop: currentMarginTop
          // claim the margin
        });
        currentMarginTop = 0;
      }
    }
    singleColPlacements.push(singlePlacements);
    multiColPlacements.push(multiPlacements);
    leftoverMargins.push(currentMarginTop);
  }
  return { singleColPlacements, multiColPlacements, leftoverMargins };
}
function groupRectsByEachCol(rects, colCnt) {
  let rectsByEachCol = [];
  for (let col = 0; col < colCnt; col += 1) {
    rectsByEachCol.push([]);
  }
  for (let rect of rects) {
    for (let col = rect.span.start; col < rect.span.end; col += 1) {
      rectsByEachCol[col].push(rect);
    }
  }
  return rectsByEachCol;
}
function resliceSeg(seg, spanStart, spanEnd, cells) {
  if (seg.firstCol === spanStart && seg.lastCol === spanEnd - 1) {
    return seg;
  }
  let eventRange = seg.eventRange;
  let origRange = eventRange.range;
  let slicedRange = intersectRanges(origRange, {
    start: cells[spanStart].date,
    end: addDays(cells[spanEnd - 1].date, 1)
  });
  return Object.assign(Object.assign({}, seg), { firstCol: spanStart, lastCol: spanEnd - 1, eventRange: {
    def: eventRange.def,
    ui: Object.assign(Object.assign({}, eventRange.ui), { durationEditable: false }),
    instance: eventRange.instance,
    range: slicedRange
  }, isStart: seg.isStart && slicedRange.start.valueOf() === origRange.start.valueOf(), isEnd: seg.isEnd && slicedRange.end.valueOf() === origRange.end.valueOf() });
}
var DayGridSegHierarchy = class extends SegHierarchy {
  constructor() {
    super(...arguments);
    this.hiddenConsumes = false;
    this.forceHidden = {};
  }
  addSegs(segInputs) {
    const hiddenSegs = super.addSegs(segInputs);
    const { entriesByLevel } = this;
    const excludeHidden = (entry) => !this.forceHidden[buildEntryKey(entry)];
    for (let level = 0; level < entriesByLevel.length; level += 1) {
      entriesByLevel[level] = entriesByLevel[level].filter(excludeHidden);
    }
    return hiddenSegs;
  }
  handleInvalidInsertion(insertion, entry, hiddenEntries) {
    const { entriesByLevel, forceHidden } = this;
    const { touchingEntry, touchingLevel, touchingLateral } = insertion;
    if (this.hiddenConsumes && touchingEntry) {
      const touchingEntryId = buildEntryKey(touchingEntry);
      if (!forceHidden[touchingEntryId]) {
        if (this.allowReslicing) {
          const hiddenEntry = Object.assign(Object.assign({}, touchingEntry), { span: intersectSpans(touchingEntry.span, entry.span) });
          const hiddenEntryId = buildEntryKey(hiddenEntry);
          forceHidden[hiddenEntryId] = true;
          entriesByLevel[touchingLevel][touchingLateral] = hiddenEntry;
          hiddenEntries.push(hiddenEntry);
          this.splitEntry(touchingEntry, entry, hiddenEntries);
        } else {
          forceHidden[touchingEntryId] = true;
          hiddenEntries.push(touchingEntry);
        }
      }
    }
    super.handleInvalidInsertion(insertion, entry, hiddenEntries);
  }
};
var TableRow = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.cellElRefs = new RefMap();
    this.frameElRefs = new RefMap();
    this.fgElRefs = new RefMap();
    this.segHarnessRefs = new RefMap();
    this.rootElRef = d();
    this.state = {
      framePositions: null,
      maxContentHeight: null,
      segHeights: {}
    };
    this.handleResize = (isForced) => {
      if (isForced) {
        this.updateSizing(true);
      }
    };
  }
  render() {
    let { props, state, context } = this;
    let { options } = context;
    let colCnt = props.cells.length;
    let businessHoursByCol = splitSegsByFirstCol(props.businessHourSegs, colCnt);
    let bgEventSegsByCol = splitSegsByFirstCol(props.bgEventSegs, colCnt);
    let highlightSegsByCol = splitSegsByFirstCol(this.getHighlightSegs(), colCnt);
    let mirrorSegsByCol = splitSegsByFirstCol(this.getMirrorSegs(), colCnt);
    let { singleColPlacements, multiColPlacements, moreCnts, moreMarginTops } = computeFgSegPlacement(sortEventSegs(props.fgEventSegs, options.eventOrder), props.dayMaxEvents, props.dayMaxEventRows, options.eventOrderStrict, state.segHeights, state.maxContentHeight, props.cells);
    let isForcedInvisible = (
      // TODO: messy way to compute this
      props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {}
    );
    return y(
      "tr",
      { ref: this.rootElRef, role: "row" },
      props.renderIntro && props.renderIntro(),
      props.cells.map((cell, col) => {
        let normalFgNodes = this.renderFgSegs(col, props.forPrint ? singleColPlacements[col] : multiColPlacements[col], props.todayRange, isForcedInvisible);
        let mirrorFgNodes = this.renderFgSegs(col, buildMirrorPlacements(mirrorSegsByCol[col], multiColPlacements), props.todayRange, {}, Boolean(props.eventDrag), Boolean(props.eventResize), false);
        return y(TableCell, { key: cell.key, elRef: this.cellElRefs.createRef(cell.key), innerElRef: this.frameElRefs.createRef(cell.key), dateProfile: props.dateProfile, date: cell.date, showDayNumber: props.showDayNumbers, showWeekNumber: props.showWeekNumbers && col === 0, forceDayTop: props.showWeekNumbers, todayRange: props.todayRange, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, extraRenderProps: cell.extraRenderProps, extraDataAttrs: cell.extraDataAttrs, extraClassNames: cell.extraClassNames, extraDateSpan: cell.extraDateSpan, moreCnt: moreCnts[col], moreMarginTop: moreMarginTops[col], singlePlacements: singleColPlacements[col], fgContentElRef: this.fgElRefs.createRef(cell.key), fgContent: (
          // Fragment scopes the keys
          y(
            _,
            null,
            y(_, null, normalFgNodes),
            y(_, null, mirrorFgNodes)
          )
        ), bgContent: (
          // Fragment scopes the keys
          y(
            _,
            null,
            this.renderFillSegs(highlightSegsByCol[col], "highlight"),
            this.renderFillSegs(businessHoursByCol[col], "non-business"),
            this.renderFillSegs(bgEventSegsByCol[col], "bg-event")
          )
        ), minHeight: props.cellMinHeight });
      })
    );
  }
  componentDidMount() {
    this.updateSizing(true);
    this.context.addResizeHandler(this.handleResize);
  }
  componentDidUpdate(prevProps, prevState) {
    let currentProps = this.props;
    this.updateSizing(!isPropsEqual(prevProps, currentProps));
  }
  componentWillUnmount() {
    this.context.removeResizeHandler(this.handleResize);
  }
  getHighlightSegs() {
    let { props } = this;
    if (props.eventDrag && props.eventDrag.segs.length) {
      return props.eventDrag.segs;
    }
    if (props.eventResize && props.eventResize.segs.length) {
      return props.eventResize.segs;
    }
    return props.dateSelectionSegs;
  }
  getMirrorSegs() {
    let { props } = this;
    if (props.eventResize && props.eventResize.segs.length) {
      return props.eventResize.segs;
    }
    return [];
  }
  renderFgSegs(col, segPlacements, todayRange, isForcedInvisible, isDragging, isResizing, isDateSelecting) {
    let { context } = this;
    let { eventSelection } = this.props;
    let { framePositions } = this.state;
    let defaultDisplayEventEnd = this.props.cells.length === 1;
    let isMirror = isDragging || isResizing || isDateSelecting;
    let nodes = [];
    if (framePositions) {
      for (let placement of segPlacements) {
        let { seg } = placement;
        let { instanceId } = seg.eventRange.instance;
        let isVisible = placement.isVisible && !isForcedInvisible[instanceId];
        let isAbsolute = placement.isAbsolute;
        let left = "";
        let right = "";
        if (isAbsolute) {
          if (context.isRtl) {
            right = 0;
            left = framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol];
          } else {
            left = 0;
            right = framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol];
          }
        }
        nodes.push(y("div", { className: "fc-daygrid-event-harness" + (isAbsolute ? " fc-daygrid-event-harness-abs" : ""), key: generateSegKey(seg), ref: isMirror ? null : this.segHarnessRefs.createRef(generateSegUid(seg)), style: {
          visibility: isVisible ? "" : "hidden",
          marginTop: isAbsolute ? "" : placement.marginTop,
          top: isAbsolute ? placement.absoluteTop : "",
          left,
          right
        } }, hasListItemDisplay(seg) ? y(TableListItemEvent, Object.assign({ seg, isDragging, isSelected: instanceId === eventSelection, defaultDisplayEventEnd }, getSegMeta(seg, todayRange))) : y(TableBlockEvent, Object.assign({ seg, isDragging, isResizing, isDateSelecting, isSelected: instanceId === eventSelection, defaultDisplayEventEnd }, getSegMeta(seg, todayRange)))));
      }
    }
    return nodes;
  }
  renderFillSegs(segs, fillType) {
    let { isRtl } = this.context;
    let { todayRange } = this.props;
    let { framePositions } = this.state;
    let nodes = [];
    if (framePositions) {
      for (let seg of segs) {
        let leftRightCss = isRtl ? {
          right: 0,
          left: framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol]
        } : {
          left: 0,
          right: framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol]
        };
        nodes.push(y("div", { key: buildEventRangeKey(seg.eventRange), className: "fc-daygrid-bg-harness", style: leftRightCss }, fillType === "bg-event" ? y(BgEvent, Object.assign({ seg }, getSegMeta(seg, todayRange))) : renderFill(fillType)));
      }
    }
    return y(_, {}, ...nodes);
  }
  updateSizing(isExternalSizingChange) {
    let { props, state, frameElRefs } = this;
    if (!props.forPrint && props.clientWidth !== null) {
      if (isExternalSizingChange) {
        let frameEls = props.cells.map((cell) => frameElRefs.currentMap[cell.key]);
        if (frameEls.length) {
          let originEl = this.rootElRef.current;
          let newPositionCache = new PositionCache(
            originEl,
            frameEls,
            true,
            // isHorizontal
            false
          );
          if (!state.framePositions || !state.framePositions.similarTo(newPositionCache)) {
            this.setState({
              framePositions: new PositionCache(
                originEl,
                frameEls,
                true,
                // isHorizontal
                false
              )
            });
          }
        }
      }
      const oldSegHeights = this.state.segHeights;
      const newSegHeights = this.querySegHeights();
      const limitByContentHeight = props.dayMaxEvents === true || props.dayMaxEventRows === true;
      this.safeSetState({
        // HACK to prevent oscillations of events being shown/hidden from max-event-rows
        // Essentially, once you compute an element's height, never null-out.
        // TODO: always display all events, as visibility:hidden?
        segHeights: Object.assign(Object.assign({}, oldSegHeights), newSegHeights),
        maxContentHeight: limitByContentHeight ? this.computeMaxContentHeight() : null
      });
    }
  }
  querySegHeights() {
    let segElMap = this.segHarnessRefs.currentMap;
    let segHeights = {};
    for (let segUid in segElMap) {
      let height = Math.round(segElMap[segUid].getBoundingClientRect().height);
      segHeights[segUid] = Math.max(segHeights[segUid] || 0, height);
    }
    return segHeights;
  }
  computeMaxContentHeight() {
    let firstKey = this.props.cells[0].key;
    let cellEl = this.cellElRefs.currentMap[firstKey];
    let fcContainerEl = this.fgElRefs.currentMap[firstKey];
    return cellEl.getBoundingClientRect().bottom - fcContainerEl.getBoundingClientRect().top;
  }
  getCellEls() {
    let elMap = this.cellElRefs.currentMap;
    return this.props.cells.map((cell) => elMap[cell.key]);
  }
};
TableRow.addStateEquality({
  segHeights: isPropsEqual
});
function buildMirrorPlacements(mirrorSegs, colPlacements) {
  if (!mirrorSegs.length) {
    return [];
  }
  let topsByInstanceId = buildAbsoluteTopHash(colPlacements);
  return mirrorSegs.map((seg) => ({
    seg,
    isVisible: true,
    isAbsolute: true,
    absoluteTop: topsByInstanceId[seg.eventRange.instance.instanceId],
    marginTop: 0
  }));
}
function buildAbsoluteTopHash(colPlacements) {
  let topsByInstanceId = {};
  for (let placements of colPlacements) {
    for (let placement of placements) {
      topsByInstanceId[placement.seg.eventRange.instance.instanceId] = placement.absoluteTop;
    }
  }
  return topsByInstanceId;
}
var TableRows = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.splitBusinessHourSegs = memoize(splitSegsByRow);
    this.splitBgEventSegs = memoize(splitSegsByRow);
    this.splitFgEventSegs = memoize(splitSegsByRow);
    this.splitDateSelectionSegs = memoize(splitSegsByRow);
    this.splitEventDrag = memoize(splitInteractionByRow);
    this.splitEventResize = memoize(splitInteractionByRow);
    this.rowRefs = new RefMap();
  }
  render() {
    let { props, context } = this;
    let rowCnt = props.cells.length;
    let businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, rowCnt);
    let bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, rowCnt);
    let fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, rowCnt);
    let dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, rowCnt);
    let eventDragByRow = this.splitEventDrag(props.eventDrag, rowCnt);
    let eventResizeByRow = this.splitEventResize(props.eventResize, rowCnt);
    let cellMinHeight = rowCnt >= 7 && props.clientWidth ? props.clientWidth / context.options.aspectRatio / 6 : null;
    return y(NowTimer, { unit: "day" }, (nowDate, todayRange) => y(_, null, props.cells.map((cells, row) => y(TableRow, {
      ref: this.rowRefs.createRef(row),
      key: cells.length ? cells[0].date.toISOString() : row,
      showDayNumbers: rowCnt > 1,
      showWeekNumbers: props.showWeekNumbers,
      todayRange,
      dateProfile: props.dateProfile,
      cells,
      renderIntro: props.renderRowIntro,
      businessHourSegs: businessHourSegsByRow[row],
      eventSelection: props.eventSelection,
      bgEventSegs: bgEventSegsByRow[row].filter(isSegAllDay),
      fgEventSegs: fgEventSegsByRow[row],
      dateSelectionSegs: dateSelectionSegsByRow[row],
      eventDrag: eventDragByRow[row],
      eventResize: eventResizeByRow[row],
      dayMaxEvents: props.dayMaxEvents,
      dayMaxEventRows: props.dayMaxEventRows,
      clientWidth: props.clientWidth,
      clientHeight: props.clientHeight,
      cellMinHeight,
      forPrint: props.forPrint
    }))));
  }
  componentDidMount() {
    this.registerInteractiveComponent();
  }
  componentDidUpdate() {
    this.registerInteractiveComponent();
  }
  registerInteractiveComponent() {
    if (!this.rootEl) {
      const firstCellEl = this.rowRefs.currentMap[0].getCellEls()[0];
      const rootEl = firstCellEl ? firstCellEl.closest(".fc-daygrid-body") : null;
      if (rootEl) {
        this.rootEl = rootEl;
        this.context.registerInteractiveComponent(this, {
          el: rootEl,
          isHitComboAllowed: this.props.isHitComboAllowed
        });
      }
    }
  }
  componentWillUnmount() {
    if (this.rootEl) {
      this.context.unregisterInteractiveComponent(this);
      this.rootEl = null;
    }
  }
  // Hit System
  // ----------------------------------------------------------------------------------------------------
  prepareHits() {
    this.rowPositions = new PositionCache(
      this.rootEl,
      this.rowRefs.collect().map((rowObj) => rowObj.getCellEls()[0]),
      // first cell el in each row. TODO: not optimal
      false,
      true
    );
    this.colPositions = new PositionCache(
      this.rootEl,
      this.rowRefs.currentMap[0].getCellEls(),
      // cell els in first row
      true,
      // horizontal
      false
    );
  }
  queryHit(positionLeft, positionTop) {
    let { colPositions, rowPositions } = this;
    let col = colPositions.leftToIndex(positionLeft);
    let row = rowPositions.topToIndex(positionTop);
    if (row != null && col != null) {
      let cell = this.props.cells[row][col];
      return {
        dateProfile: this.props.dateProfile,
        dateSpan: Object.assign({ range: this.getCellRange(row, col), allDay: true }, cell.extraDateSpan),
        dayEl: this.getCellEl(row, col),
        rect: {
          left: colPositions.lefts[col],
          right: colPositions.rights[col],
          top: rowPositions.tops[row],
          bottom: rowPositions.bottoms[row]
        },
        layer: 0
      };
    }
    return null;
  }
  getCellEl(row, col) {
    return this.rowRefs.currentMap[row].getCellEls()[col];
  }
  getCellRange(row, col) {
    let start = this.props.cells[row][col].date;
    let end = addDays(start, 1);
    return { start, end };
  }
};
function isSegAllDay(seg) {
  return seg.eventRange.def.allDay;
}
var Table = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.elRef = d();
    this.needsScrollReset = false;
  }
  render() {
    let { props } = this;
    let { dayMaxEventRows, dayMaxEvents, expandRows } = props;
    let limitViaBalanced = dayMaxEvents === true || dayMaxEventRows === true;
    if (limitViaBalanced && !expandRows) {
      limitViaBalanced = false;
      dayMaxEventRows = null;
      dayMaxEvents = null;
    }
    let classNames = [
      "fc-daygrid-body",
      limitViaBalanced ? "fc-daygrid-body-balanced" : "fc-daygrid-body-unbalanced",
      expandRows ? "" : "fc-daygrid-body-natural"
      // will height of one row depend on the others?
    ];
    return y(
      "div",
      { ref: this.elRef, className: classNames.join(" "), style: {
        // these props are important to give this wrapper correct dimensions for interactions
        // TODO: if we set it here, can we avoid giving to inner tables?
        width: props.clientWidth,
        minWidth: props.tableMinWidth
      } },
      y(
        "table",
        { role: "presentation", className: "fc-scrollgrid-sync-table", style: {
          width: props.clientWidth,
          minWidth: props.tableMinWidth,
          height: expandRows ? props.clientHeight : ""
        } },
        props.colGroupNode,
        y(
          "tbody",
          { role: "presentation" },
          y(TableRows, { dateProfile: props.dateProfile, cells: props.cells, renderRowIntro: props.renderRowIntro, showWeekNumbers: props.showWeekNumbers, clientWidth: props.clientWidth, clientHeight: props.clientHeight, businessHourSegs: props.businessHourSegs, bgEventSegs: props.bgEventSegs, fgEventSegs: props.fgEventSegs, dateSelectionSegs: props.dateSelectionSegs, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, dayMaxEvents, dayMaxEventRows, forPrint: props.forPrint, isHitComboAllowed: props.isHitComboAllowed })
        )
      )
    );
  }
  componentDidMount() {
    this.requestScrollReset();
  }
  componentDidUpdate(prevProps) {
    if (prevProps.dateProfile !== this.props.dateProfile) {
      this.requestScrollReset();
    } else {
      this.flushScrollReset();
    }
  }
  requestScrollReset() {
    this.needsScrollReset = true;
    this.flushScrollReset();
  }
  flushScrollReset() {
    if (this.needsScrollReset && this.props.clientWidth) {
      const subjectEl = getScrollSubjectEl(this.elRef.current, this.props.dateProfile);
      if (subjectEl) {
        const originEl = subjectEl.closest(".fc-daygrid-body");
        const scrollEl = originEl.closest(".fc-scroller");
        const scrollTop = subjectEl.getBoundingClientRect().top - originEl.getBoundingClientRect().top;
        scrollEl.scrollTop = scrollTop ? scrollTop + 1 : 0;
      }
      this.needsScrollReset = false;
    }
  }
};
function getScrollSubjectEl(containerEl, dateProfile) {
  let el;
  if (dateProfile.currentRangeUnit.match(/year|month/)) {
    el = containerEl.querySelector(`[data-date="${formatIsoMonthStr(dateProfile.currentDate)}-01"]`);
  }
  if (!el) {
    el = containerEl.querySelector(`[data-date="${formatDayString(dateProfile.currentDate)}"]`);
  }
  return el;
}
var DayTableSlicer = class extends Slicer {
  constructor() {
    super(...arguments);
    this.forceDayIfListItem = true;
  }
  sliceRange(dateRange, dayTableModel) {
    return dayTableModel.sliceRange(dateRange);
  }
};
var DayTable = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.slicer = new DayTableSlicer();
    this.tableRef = d();
  }
  render() {
    let { props, context } = this;
    return y(Table, Object.assign({ ref: this.tableRef }, this.slicer.sliceProps(props, props.dateProfile, props.nextDayThreshold, context, props.dayTableModel), { dateProfile: props.dateProfile, cells: props.dayTableModel.cells, colGroupNode: props.colGroupNode, tableMinWidth: props.tableMinWidth, renderRowIntro: props.renderRowIntro, dayMaxEvents: props.dayMaxEvents, dayMaxEventRows: props.dayMaxEventRows, showWeekNumbers: props.showWeekNumbers, expandRows: props.expandRows, headerAlignElRef: props.headerAlignElRef, clientWidth: props.clientWidth, clientHeight: props.clientHeight, forPrint: props.forPrint }));
  }
};
var DayTableView = class extends TableView {
  constructor() {
    super(...arguments);
    this.buildDayTableModel = memoize(buildDayTableModel);
    this.headerRef = d();
    this.tableRef = d();
  }
  render() {
    let { options, dateProfileGenerator } = this.context;
    let { props } = this;
    let dayTableModel = this.buildDayTableModel(props.dateProfile, dateProfileGenerator);
    let headerContent = options.dayHeaders && y(DayHeader, { ref: this.headerRef, dateProfile: props.dateProfile, dates: dayTableModel.headerDates, datesRepDistinctDays: dayTableModel.rowCnt === 1 });
    let bodyContent = (contentArg) => y(DayTable, { ref: this.tableRef, dateProfile: props.dateProfile, dayTableModel, businessHours: props.businessHours, dateSelection: props.dateSelection, eventStore: props.eventStore, eventUiBases: props.eventUiBases, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, nextDayThreshold: options.nextDayThreshold, colGroupNode: contentArg.tableColGroupNode, tableMinWidth: contentArg.tableMinWidth, dayMaxEvents: options.dayMaxEvents, dayMaxEventRows: options.dayMaxEventRows, showWeekNumbers: options.weekNumbers, expandRows: !props.isHeightAuto, headerAlignElRef: this.headerElRef, clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, forPrint: props.forPrint });
    return options.dayMinWidth ? this.renderHScrollLayout(headerContent, bodyContent, dayTableModel.colCnt, options.dayMinWidth) : this.renderSimpleLayout(headerContent, bodyContent);
  }
};
function buildDayTableModel(dateProfile, dateProfileGenerator) {
  let daySeries = new DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);
  return new DayTableModel(daySeries, /year|month|week/.test(dateProfile.currentRangeUnit));
}
var TableDateProfileGenerator = class extends DateProfileGenerator {
  // Computes the date range that will be rendered
  buildRenderRange(currentRange, currentRangeUnit, isRangeAllDay) {
    let renderRange = super.buildRenderRange(currentRange, currentRangeUnit, isRangeAllDay);
    let { props } = this;
    return buildDayTableRenderRange({
      currentRange: renderRange,
      snapToWeek: /^(year|month)$/.test(currentRangeUnit),
      fixedWeekCount: props.fixedWeekCount,
      dateEnv: props.dateEnv
    });
  }
};
function buildDayTableRenderRange(props) {
  let { dateEnv, currentRange } = props;
  let { start, end } = currentRange;
  let endOfWeek;
  if (props.snapToWeek) {
    start = dateEnv.startOfWeek(start);
    endOfWeek = dateEnv.startOfWeek(end);
    if (endOfWeek.valueOf() !== end.valueOf()) {
      end = addWeeks(endOfWeek, 1);
    }
  }
  if (props.fixedWeekCount) {
    let lastMonthRenderStart = dateEnv.startOfWeek(dateEnv.startOfMonth(addDays(currentRange.end, -1)));
    let rowCnt = Math.ceil(
      // could be partial weeks due to hiddenDays
      diffWeeks(lastMonthRenderStart, end)
    );
    end = addWeeks(end, 6 - rowCnt);
  }
  return { start, end };
}
var css_248z2 = ':root{--fc-daygrid-event-dot-width:8px}.fc-daygrid-day-events:after,.fc-daygrid-day-events:before,.fc-daygrid-day-frame:after,.fc-daygrid-day-frame:before,.fc-daygrid-event-harness:after,.fc-daygrid-event-harness:before{clear:both;content:"";display:table}.fc .fc-daygrid-body{position:relative;z-index:1}.fc .fc-daygrid-day.fc-day-today{background-color:var(--fc-today-bg-color)}.fc .fc-daygrid-day-frame{min-height:100%;position:relative}.fc .fc-daygrid-day-top{display:flex;flex-direction:row-reverse}.fc .fc-day-other .fc-daygrid-day-top{opacity:.3}.fc .fc-daygrid-day-number{padding:4px;position:relative;z-index:4}.fc .fc-daygrid-month-start{font-size:1.1em;font-weight:700}.fc .fc-daygrid-day-events{margin-top:1px}.fc .fc-daygrid-body-balanced .fc-daygrid-day-events{left:0;position:absolute;right:0}.fc .fc-daygrid-body-unbalanced .fc-daygrid-day-events{min-height:2em;position:relative}.fc .fc-daygrid-body-natural .fc-daygrid-day-events{margin-bottom:1em}.fc .fc-daygrid-event-harness{position:relative}.fc .fc-daygrid-event-harness-abs{left:0;position:absolute;right:0;top:0}.fc .fc-daygrid-bg-harness{bottom:0;position:absolute;top:0}.fc .fc-daygrid-day-bg .fc-non-business{z-index:1}.fc .fc-daygrid-day-bg .fc-bg-event{z-index:2}.fc .fc-daygrid-day-bg .fc-highlight{z-index:3}.fc .fc-daygrid-event{margin-top:1px;z-index:6}.fc .fc-daygrid-event.fc-event-mirror{z-index:7}.fc .fc-daygrid-day-bottom{font-size:.85em;margin:0 2px}.fc .fc-daygrid-day-bottom:after,.fc .fc-daygrid-day-bottom:before{clear:both;content:"";display:table}.fc .fc-daygrid-more-link{border-radius:3px;cursor:pointer;line-height:1;margin-top:1px;max-width:100%;overflow:hidden;padding:2px;position:relative;white-space:nowrap;z-index:4}.fc .fc-daygrid-more-link:hover{background-color:rgba(0,0,0,.1)}.fc .fc-daygrid-week-number{background-color:var(--fc-neutral-bg-color);color:var(--fc-neutral-text-color);min-width:1.5em;padding:2px;position:absolute;text-align:center;top:0;z-index:5}.fc .fc-more-popover .fc-popover-body{min-width:220px;padding:10px}.fc-direction-ltr .fc-daygrid-event.fc-event-start,.fc-direction-rtl .fc-daygrid-event.fc-event-end{margin-left:2px}.fc-direction-ltr .fc-daygrid-event.fc-event-end,.fc-direction-rtl .fc-daygrid-event.fc-event-start{margin-right:2px}.fc-direction-ltr .fc-daygrid-more-link{float:left}.fc-direction-ltr .fc-daygrid-week-number{border-radius:0 0 3px 0;left:0}.fc-direction-rtl .fc-daygrid-more-link{float:right}.fc-direction-rtl .fc-daygrid-week-number{border-radius:0 0 0 3px;right:0}.fc-liquid-hack .fc-daygrid-day-frame{position:static}.fc-daygrid-event{border-radius:3px;font-size:var(--fc-small-font-size);position:relative;white-space:nowrap}.fc-daygrid-block-event .fc-event-time{font-weight:700}.fc-daygrid-block-event .fc-event-time,.fc-daygrid-block-event .fc-event-title{padding:1px}.fc-daygrid-dot-event{align-items:center;display:flex;padding:2px 0}.fc-daygrid-dot-event .fc-event-title{flex-grow:1;flex-shrink:1;font-weight:700;min-width:0;overflow:hidden}.fc-daygrid-dot-event.fc-event-mirror,.fc-daygrid-dot-event:hover{background:rgba(0,0,0,.1)}.fc-daygrid-dot-event.fc-event-selected:before{bottom:-10px;top:-10px}.fc-daygrid-event-dot{border:calc(var(--fc-daygrid-event-dot-width)/2) solid var(--fc-event-border-color);border-radius:calc(var(--fc-daygrid-event-dot-width)/2);box-sizing:content-box;height:0;margin:0 4px;width:0}.fc-direction-ltr .fc-daygrid-event .fc-event-time{margin-right:3px}.fc-direction-rtl .fc-daygrid-event .fc-event-time{margin-left:3px}';
injectStyles(css_248z2);

// node_modules/@fullcalendar/daygrid/index.js
var index = createPlugin({
  name: "@fullcalendar/daygrid",
  initialView: "dayGridMonth",
  views: {
    dayGrid: {
      component: DayTableView,
      dateProfileGeneratorClass: TableDateProfileGenerator
    },
    dayGridDay: {
      type: "dayGrid",
      duration: { days: 1 }
    },
    dayGridWeek: {
      type: "dayGrid",
      duration: { weeks: 1 }
    },
    dayGridMonth: {
      type: "dayGrid",
      duration: { months: 1 },
      fixedWeekCount: true
    },
    dayGridYear: {
      type: "dayGrid",
      duration: { years: 1 }
    }
  }
});

// node_modules/@fullcalendar/timegrid/internal.js
var AllDaySplitter = class extends Splitter {
  getKeyInfo() {
    return {
      allDay: {},
      timed: {}
    };
  }
  getKeysForDateSpan(dateSpan) {
    if (dateSpan.allDay) {
      return ["allDay"];
    }
    return ["timed"];
  }
  getKeysForEventDef(eventDef) {
    if (!eventDef.allDay) {
      return ["timed"];
    }
    if (hasBgRendering(eventDef)) {
      return ["timed", "allDay"];
    }
    return ["allDay"];
  }
};
var DEFAULT_SLAT_LABEL_FORMAT = createFormatter({
  hour: "numeric",
  minute: "2-digit",
  omitZeroMinute: true,
  meridiem: "short"
});
function TimeColsAxisCell(props) {
  let classNames = [
    "fc-timegrid-slot",
    "fc-timegrid-slot-label",
    props.isLabeled ? "fc-scrollgrid-shrink" : "fc-timegrid-slot-minor"
  ];
  return y(ViewContextType.Consumer, null, (context) => {
    if (!props.isLabeled) {
      return y("td", { className: classNames.join(" "), "data-time": props.isoTimeStr });
    }
    let { dateEnv, options, viewApi } = context;
    let labelFormat = (
      // TODO: fully pre-parse
      options.slotLabelFormat == null ? DEFAULT_SLAT_LABEL_FORMAT : Array.isArray(options.slotLabelFormat) ? createFormatter(options.slotLabelFormat[0]) : createFormatter(options.slotLabelFormat)
    );
    let renderProps = {
      level: 0,
      time: props.time,
      date: dateEnv.toDate(props.date),
      view: viewApi,
      text: dateEnv.format(props.date, labelFormat)
    };
    return y(ContentContainer, { elTag: "td", elClasses: classNames, elAttrs: {
      "data-time": props.isoTimeStr
    }, renderProps, generatorName: "slotLabelContent", customGenerator: options.slotLabelContent, defaultGenerator: renderInnerContent3, classNameGenerator: options.slotLabelClassNames, didMount: options.slotLabelDidMount, willUnmount: options.slotLabelWillUnmount }, (InnerContent) => y(
      "div",
      { className: "fc-timegrid-slot-label-frame fc-scrollgrid-shrink-frame" },
      y(InnerContent, { elTag: "div", elClasses: [
        "fc-timegrid-slot-label-cushion",
        "fc-scrollgrid-shrink-cushion"
      ] })
    ));
  });
}
function renderInnerContent3(props) {
  return props.text;
}
var TimeBodyAxis = class extends BaseComponent {
  render() {
    return this.props.slatMetas.map((slatMeta) => y(
      "tr",
      { key: slatMeta.key },
      y(TimeColsAxisCell, Object.assign({}, slatMeta))
    ));
  }
};
var DEFAULT_WEEK_NUM_FORMAT2 = createFormatter({ week: "short" });
var AUTO_ALL_DAY_MAX_EVENT_ROWS = 5;
var TimeColsView = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.allDaySplitter = new AllDaySplitter();
    this.headerElRef = d();
    this.rootElRef = d();
    this.scrollerElRef = d();
    this.state = {
      slatCoords: null
    };
    this.handleScrollTopRequest = (scrollTop) => {
      let scrollerEl = this.scrollerElRef.current;
      if (scrollerEl) {
        scrollerEl.scrollTop = scrollTop;
      }
    };
    this.renderHeadAxis = (rowKey, frameHeight = "") => {
      let { options } = this.context;
      let { dateProfile } = this.props;
      let range2 = dateProfile.renderRange;
      let dayCnt = diffDays(range2.start, range2.end);
      let navLinkAttrs = dayCnt === 1 ? buildNavLinkAttrs(this.context, range2.start, "week") : {};
      if (options.weekNumbers && rowKey === "day") {
        return y(WeekNumberContainer, { elTag: "th", elClasses: [
          "fc-timegrid-axis",
          "fc-scrollgrid-shrink"
        ], elAttrs: {
          "aria-hidden": true
        }, date: range2.start, defaultFormat: DEFAULT_WEEK_NUM_FORMAT2 }, (InnerContent) => y(
          "div",
          { className: [
            "fc-timegrid-axis-frame",
            "fc-scrollgrid-shrink-frame",
            "fc-timegrid-axis-frame-liquid"
          ].join(" "), style: { height: frameHeight } },
          y(InnerContent, { elTag: "a", elClasses: [
            "fc-timegrid-axis-cushion",
            "fc-scrollgrid-shrink-cushion",
            "fc-scrollgrid-sync-inner"
          ], elAttrs: navLinkAttrs })
        ));
      }
      return y(
        "th",
        { "aria-hidden": true, className: "fc-timegrid-axis" },
        y("div", { className: "fc-timegrid-axis-frame", style: { height: frameHeight } })
      );
    };
    this.renderTableRowAxis = (rowHeight) => {
      let { options, viewApi } = this.context;
      let renderProps = {
        text: options.allDayText,
        view: viewApi
      };
      return (
        // TODO: make reusable hook. used in list view too
        y(ContentContainer, { elTag: "td", elClasses: [
          "fc-timegrid-axis",
          "fc-scrollgrid-shrink"
        ], elAttrs: {
          "aria-hidden": true
        }, renderProps, generatorName: "allDayContent", customGenerator: options.allDayContent, defaultGenerator: renderAllDayInner, classNameGenerator: options.allDayClassNames, didMount: options.allDayDidMount, willUnmount: options.allDayWillUnmount }, (InnerContent) => y(
          "div",
          { className: [
            "fc-timegrid-axis-frame",
            "fc-scrollgrid-shrink-frame",
            rowHeight == null ? " fc-timegrid-axis-frame-liquid" : ""
          ].join(" "), style: { height: rowHeight } },
          y(InnerContent, { elTag: "span", elClasses: [
            "fc-timegrid-axis-cushion",
            "fc-scrollgrid-shrink-cushion",
            "fc-scrollgrid-sync-inner"
          ] })
        ))
      );
    };
    this.handleSlatCoords = (slatCoords) => {
      this.setState({ slatCoords });
    };
  }
  // rendering
  // ----------------------------------------------------------------------------------------------------
  renderSimpleLayout(headerRowContent, allDayContent, timeContent) {
    let { context, props } = this;
    let sections = [];
    let stickyHeaderDates = getStickyHeaderDates(context.options);
    if (headerRowContent) {
      sections.push({
        type: "header",
        key: "header",
        isSticky: stickyHeaderDates,
        chunk: {
          elRef: this.headerElRef,
          tableClassName: "fc-col-header",
          rowContent: headerRowContent
        }
      });
    }
    if (allDayContent) {
      sections.push({
        type: "body",
        key: "all-day",
        chunk: { content: allDayContent }
      });
      sections.push({
        type: "body",
        key: "all-day-divider",
        outerContent: (
          // TODO: rename to cellContent so don't need to define <tr>?
          y(
            "tr",
            { role: "presentation", className: "fc-scrollgrid-section" },
            y("td", { className: "fc-timegrid-divider " + context.theme.getClass("tableCellShaded") })
          )
        )
      });
    }
    sections.push({
      type: "body",
      key: "body",
      liquid: true,
      expandRows: Boolean(context.options.expandRows),
      chunk: {
        scrollerElRef: this.scrollerElRef,
        content: timeContent
      }
    });
    return y(
      ViewContainer,
      { elRef: this.rootElRef, elClasses: ["fc-timegrid"], viewSpec: context.viewSpec },
      y(SimpleScrollGrid, { liquid: !props.isHeightAuto && !props.forPrint, collapsibleWidth: props.forPrint, cols: [{ width: "shrink" }], sections })
    );
  }
  renderHScrollLayout(headerRowContent, allDayContent, timeContent, colCnt, dayMinWidth, slatMetas, slatCoords) {
    let ScrollGrid = this.context.pluginHooks.scrollGridImpl;
    if (!ScrollGrid) {
      throw new Error("No ScrollGrid implementation");
    }
    let { context, props } = this;
    let stickyHeaderDates = !props.forPrint && getStickyHeaderDates(context.options);
    let stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(context.options);
    let sections = [];
    if (headerRowContent) {
      sections.push({
        type: "header",
        key: "header",
        isSticky: stickyHeaderDates,
        syncRowHeights: true,
        chunks: [
          {
            key: "axis",
            rowContent: (arg) => y("tr", { role: "presentation" }, this.renderHeadAxis("day", arg.rowSyncHeights[0]))
          },
          {
            key: "cols",
            elRef: this.headerElRef,
            tableClassName: "fc-col-header",
            rowContent: headerRowContent
          }
        ]
      });
    }
    if (allDayContent) {
      sections.push({
        type: "body",
        key: "all-day",
        syncRowHeights: true,
        chunks: [
          {
            key: "axis",
            rowContent: (contentArg) => y("tr", { role: "presentation" }, this.renderTableRowAxis(contentArg.rowSyncHeights[0]))
          },
          {
            key: "cols",
            content: allDayContent
          }
        ]
      });
      sections.push({
        key: "all-day-divider",
        type: "body",
        outerContent: (
          // TODO: rename to cellContent so don't need to define <tr>?
          y(
            "tr",
            { role: "presentation", className: "fc-scrollgrid-section" },
            y("td", { colSpan: 2, className: "fc-timegrid-divider " + context.theme.getClass("tableCellShaded") })
          )
        )
      });
    }
    let isNowIndicator = context.options.nowIndicator;
    sections.push({
      type: "body",
      key: "body",
      liquid: true,
      expandRows: Boolean(context.options.expandRows),
      chunks: [
        {
          key: "axis",
          content: (arg) => (
            // TODO: make this now-indicator arrow more DRY with TimeColsContent
            y(
              "div",
              { className: "fc-timegrid-axis-chunk" },
              y(
                "table",
                { "aria-hidden": true, style: { height: arg.expandRows ? arg.clientHeight : "" } },
                arg.tableColGroupNode,
                y(
                  "tbody",
                  null,
                  y(TimeBodyAxis, { slatMetas })
                )
              ),
              y(
                "div",
                { className: "fc-timegrid-now-indicator-container" },
                y(NowTimer, {
                  unit: isNowIndicator ? "minute" : "day"
                  /* hacky */
                }, (nowDate) => {
                  let nowIndicatorTop = isNowIndicator && slatCoords && slatCoords.safeComputeTop(nowDate);
                  if (typeof nowIndicatorTop === "number") {
                    return y(NowIndicatorContainer, { elClasses: ["fc-timegrid-now-indicator-arrow"], elStyle: { top: nowIndicatorTop }, isAxis: true, date: nowDate });
                  }
                  return null;
                })
              )
            )
          )
        },
        {
          key: "cols",
          scrollerElRef: this.scrollerElRef,
          content: timeContent
        }
      ]
    });
    if (stickyFooterScrollbar) {
      sections.push({
        key: "footer",
        type: "footer",
        isSticky: true,
        chunks: [
          {
            key: "axis",
            content: renderScrollShim
          },
          {
            key: "cols",
            content: renderScrollShim
          }
        ]
      });
    }
    return y(
      ViewContainer,
      { elRef: this.rootElRef, elClasses: ["fc-timegrid"], viewSpec: context.viewSpec },
      y(ScrollGrid, { liquid: !props.isHeightAuto && !props.forPrint, forPrint: props.forPrint, collapsibleWidth: false, colGroups: [
        { width: "shrink", cols: [{ width: "shrink" }] },
        { cols: [{ span: colCnt, minWidth: dayMinWidth }] }
      ], sections })
    );
  }
  /* Dimensions
  ------------------------------------------------------------------------------------------------------------------*/
  getAllDayMaxEventProps() {
    let { dayMaxEvents, dayMaxEventRows } = this.context.options;
    if (dayMaxEvents === true || dayMaxEventRows === true) {
      dayMaxEvents = void 0;
      dayMaxEventRows = AUTO_ALL_DAY_MAX_EVENT_ROWS;
    }
    return { dayMaxEvents, dayMaxEventRows };
  }
};
function renderAllDayInner(renderProps) {
  return renderProps.text;
}
var TimeColsSlatsCoords = class {
  constructor(positions, dateProfile, slotDuration) {
    this.positions = positions;
    this.dateProfile = dateProfile;
    this.slotDuration = slotDuration;
  }
  safeComputeTop(date) {
    let { dateProfile } = this;
    if (rangeContainsMarker(dateProfile.currentRange, date)) {
      let startOfDayDate = startOfDay(date);
      let timeMs = date.valueOf() - startOfDayDate.valueOf();
      if (timeMs >= asRoughMs(dateProfile.slotMinTime) && timeMs < asRoughMs(dateProfile.slotMaxTime)) {
        return this.computeTimeTop(createDuration(timeMs));
      }
    }
    return null;
  }
  // Computes the top coordinate, relative to the bounds of the grid, of the given date.
  // A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.
  computeDateTop(when, startOfDayDate) {
    if (!startOfDayDate) {
      startOfDayDate = startOfDay(when);
    }
    return this.computeTimeTop(createDuration(when.valueOf() - startOfDayDate.valueOf()));
  }
  // Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).
  // This is a makeshify way to compute the time-top. Assumes all slatMetas dates are uniform.
  // Eventually allow computation with arbirary slat dates.
  computeTimeTop(duration) {
    let { positions, dateProfile } = this;
    let len = positions.els.length;
    let slatCoverage = (duration.milliseconds - asRoughMs(dateProfile.slotMinTime)) / asRoughMs(this.slotDuration);
    let slatIndex;
    let slatRemainder;
    slatCoverage = Math.max(0, slatCoverage);
    slatCoverage = Math.min(len, slatCoverage);
    slatIndex = Math.floor(slatCoverage);
    slatIndex = Math.min(slatIndex, len - 1);
    slatRemainder = slatCoverage - slatIndex;
    return positions.tops[slatIndex] + positions.getHeight(slatIndex) * slatRemainder;
  }
};
var TimeColsSlatsBody = class extends BaseComponent {
  render() {
    let { props, context } = this;
    let { options } = context;
    let { slatElRefs } = props;
    return y("tbody", null, props.slatMetas.map((slatMeta, i3) => {
      let renderProps = {
        time: slatMeta.time,
        date: context.dateEnv.toDate(slatMeta.date),
        view: context.viewApi
      };
      return y(
        "tr",
        { key: slatMeta.key, ref: slatElRefs.createRef(slatMeta.key) },
        props.axis && y(TimeColsAxisCell, Object.assign({}, slatMeta)),
        y(ContentContainer, { elTag: "td", elClasses: [
          "fc-timegrid-slot",
          "fc-timegrid-slot-lane",
          !slatMeta.isLabeled && "fc-timegrid-slot-minor"
        ], elAttrs: {
          "data-time": slatMeta.isoTimeStr
        }, renderProps, generatorName: "slotLaneContent", customGenerator: options.slotLaneContent, classNameGenerator: options.slotLaneClassNames, didMount: options.slotLaneDidMount, willUnmount: options.slotLaneWillUnmount })
      );
    }));
  }
};
var TimeColsSlats = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.rootElRef = d();
    this.slatElRefs = new RefMap();
  }
  render() {
    let { props, context } = this;
    return y(
      "div",
      { ref: this.rootElRef, className: "fc-timegrid-slots" },
      y(
        "table",
        { "aria-hidden": true, className: context.theme.getClass("table"), style: {
          minWidth: props.tableMinWidth,
          width: props.clientWidth,
          height: props.minHeight
        } },
        props.tableColGroupNode,
        y(TimeColsSlatsBody, { slatElRefs: this.slatElRefs, axis: props.axis, slatMetas: props.slatMetas })
      )
    );
  }
  componentDidMount() {
    this.updateSizing();
  }
  componentDidUpdate() {
    this.updateSizing();
  }
  componentWillUnmount() {
    if (this.props.onCoords) {
      this.props.onCoords(null);
    }
  }
  updateSizing() {
    let { context, props } = this;
    if (props.onCoords && props.clientWidth !== null) {
      let rootEl = this.rootElRef.current;
      if (rootEl.offsetHeight) {
        props.onCoords(new TimeColsSlatsCoords(new PositionCache(this.rootElRef.current, collectSlatEls(this.slatElRefs.currentMap, props.slatMetas), false, true), this.props.dateProfile, context.options.slotDuration));
      }
    }
  }
};
function collectSlatEls(elMap, slatMetas) {
  return slatMetas.map((slatMeta) => elMap[slatMeta.key]);
}
function splitSegsByCol(segs, colCnt) {
  let segsByCol = [];
  let i3;
  for (i3 = 0; i3 < colCnt; i3 += 1) {
    segsByCol.push([]);
  }
  if (segs) {
    for (i3 = 0; i3 < segs.length; i3 += 1) {
      segsByCol[segs[i3].col].push(segs[i3]);
    }
  }
  return segsByCol;
}
function splitInteractionByCol(ui, colCnt) {
  let byRow = [];
  if (!ui) {
    for (let i3 = 0; i3 < colCnt; i3 += 1) {
      byRow[i3] = null;
    }
  } else {
    for (let i3 = 0; i3 < colCnt; i3 += 1) {
      byRow[i3] = {
        affectedInstances: ui.affectedInstances,
        isEvent: ui.isEvent,
        segs: []
      };
    }
    for (let seg of ui.segs) {
      byRow[seg.col].segs.push(seg);
    }
  }
  return byRow;
}
var TimeColMoreLink = class extends BaseComponent {
  render() {
    let { props } = this;
    return y(MoreLinkContainer, { elClasses: ["fc-timegrid-more-link"], elStyle: {
      top: props.top,
      bottom: props.bottom
    }, allDayDate: null, moreCnt: props.hiddenSegs.length, allSegs: props.hiddenSegs, hiddenSegs: props.hiddenSegs, extraDateSpan: props.extraDateSpan, dateProfile: props.dateProfile, todayRange: props.todayRange, popoverContent: () => renderPlainFgSegs(props.hiddenSegs, props), defaultGenerator: renderMoreLinkInner2, forceTimed: true }, (InnerContent) => y(InnerContent, { elTag: "div", elClasses: ["fc-timegrid-more-link-inner", "fc-sticky"] }));
  }
};
function renderMoreLinkInner2(props) {
  return props.shortText;
}
function buildPositioning(segInputs, strictOrder, maxStackCnt) {
  let hierarchy = new SegHierarchy();
  if (strictOrder != null) {
    hierarchy.strictOrder = strictOrder;
  }
  if (maxStackCnt != null) {
    hierarchy.maxStackCnt = maxStackCnt;
  }
  let hiddenEntries = hierarchy.addSegs(segInputs);
  let hiddenGroups = groupIntersectingEntries(hiddenEntries);
  let web = buildWeb(hierarchy);
  web = stretchWeb(web, 1);
  let segRects = webToRects(web);
  return { segRects, hiddenGroups };
}
function buildWeb(hierarchy) {
  const { entriesByLevel } = hierarchy;
  const buildNode = cacheable((level, lateral) => level + ":" + lateral, (level, lateral) => {
    let siblingRange = findNextLevelSegs(hierarchy, level, lateral);
    let nextLevelRes = buildNodes(siblingRange, buildNode);
    let entry = entriesByLevel[level][lateral];
    return [
      Object.assign(Object.assign({}, entry), { nextLevelNodes: nextLevelRes[0] }),
      entry.thickness + nextLevelRes[1]
      // the pressure builds
    ];
  });
  return buildNodes(entriesByLevel.length ? { level: 0, lateralStart: 0, lateralEnd: entriesByLevel[0].length } : null, buildNode)[0];
}
function buildNodes(siblingRange, buildNode) {
  if (!siblingRange) {
    return [[], 0];
  }
  let { level, lateralStart, lateralEnd } = siblingRange;
  let lateral = lateralStart;
  let pairs = [];
  while (lateral < lateralEnd) {
    pairs.push(buildNode(level, lateral));
    lateral += 1;
  }
  pairs.sort(cmpDescPressures);
  return [
    pairs.map(extractNode),
    pairs[0][1]
    // first item's pressure
  ];
}
function cmpDescPressures(a3, b3) {
  return b3[1] - a3[1];
}
function extractNode(a3) {
  return a3[0];
}
function findNextLevelSegs(hierarchy, subjectLevel, subjectLateral) {
  let { levelCoords, entriesByLevel } = hierarchy;
  let subjectEntry = entriesByLevel[subjectLevel][subjectLateral];
  let afterSubject = levelCoords[subjectLevel] + subjectEntry.thickness;
  let levelCnt = levelCoords.length;
  let level = subjectLevel;
  for (; level < levelCnt && levelCoords[level] < afterSubject; level += 1)
    ;
  for (; level < levelCnt; level += 1) {
    let entries = entriesByLevel[level];
    let entry;
    let searchIndex = binarySearch(entries, subjectEntry.span.start, getEntrySpanEnd);
    let lateralStart = searchIndex[0] + searchIndex[1];
    let lateralEnd = lateralStart;
    while (
      // loop through entries that horizontally intersect
      (entry = entries[lateralEnd]) && // but not past the whole seg list
      entry.span.start < subjectEntry.span.end
    ) {
      lateralEnd += 1;
    }
    if (lateralStart < lateralEnd) {
      return { level, lateralStart, lateralEnd };
    }
  }
  return null;
}
function stretchWeb(topLevelNodes, totalThickness) {
  const stretchNode = cacheable((node, startCoord, prevThickness) => buildEntryKey(node), (node, startCoord, prevThickness) => {
    let { nextLevelNodes, thickness } = node;
    let allThickness = thickness + prevThickness;
    let thicknessFraction = thickness / allThickness;
    let endCoord;
    let newChildren = [];
    if (!nextLevelNodes.length) {
      endCoord = totalThickness;
    } else {
      for (let childNode of nextLevelNodes) {
        if (endCoord === void 0) {
          let res = stretchNode(childNode, startCoord, allThickness);
          endCoord = res[0];
          newChildren.push(res[1]);
        } else {
          let res = stretchNode(childNode, endCoord, 0);
          newChildren.push(res[1]);
        }
      }
    }
    let newThickness = (endCoord - startCoord) * thicknessFraction;
    return [endCoord - newThickness, Object.assign(Object.assign({}, node), { thickness: newThickness, nextLevelNodes: newChildren })];
  });
  return topLevelNodes.map((node) => stretchNode(node, 0, 0)[1]);
}
function webToRects(topLevelNodes) {
  let rects = [];
  const processNode = cacheable((node, levelCoord, stackDepth) => buildEntryKey(node), (node, levelCoord, stackDepth) => {
    let rect = Object.assign(Object.assign({}, node), {
      levelCoord,
      stackDepth,
      stackForward: 0
    });
    rects.push(rect);
    return rect.stackForward = processNodes(node.nextLevelNodes, levelCoord + node.thickness, stackDepth + 1) + 1;
  });
  function processNodes(nodes, levelCoord, stackDepth) {
    let stackForward = 0;
    for (let node of nodes) {
      stackForward = Math.max(processNode(node, levelCoord, stackDepth), stackForward);
    }
    return stackForward;
  }
  processNodes(topLevelNodes, 0, 0);
  return rects;
}
function cacheable(keyFunc, workFunc) {
  const cache = {};
  return (...args) => {
    let key = keyFunc(...args);
    return key in cache ? cache[key] : cache[key] = workFunc(...args);
  };
}
function computeSegVCoords(segs, colDate, slatCoords = null, eventMinHeight = 0) {
  let vcoords = [];
  if (slatCoords) {
    for (let i3 = 0; i3 < segs.length; i3 += 1) {
      let seg = segs[i3];
      let spanStart = slatCoords.computeDateTop(seg.start, colDate);
      let spanEnd = Math.max(
        spanStart + (eventMinHeight || 0),
        // :(
        slatCoords.computeDateTop(seg.end, colDate)
      );
      vcoords.push({
        start: Math.round(spanStart),
        end: Math.round(spanEnd)
        //
      });
    }
  }
  return vcoords;
}
function computeFgSegPlacements(segs, segVCoords, eventOrderStrict, eventMaxStack) {
  let segInputs = [];
  let dumbSegs = [];
  for (let i3 = 0; i3 < segs.length; i3 += 1) {
    let vcoords = segVCoords[i3];
    if (vcoords) {
      segInputs.push({
        index: i3,
        thickness: 1,
        span: vcoords
      });
    } else {
      dumbSegs.push(segs[i3]);
    }
  }
  let { segRects, hiddenGroups } = buildPositioning(segInputs, eventOrderStrict, eventMaxStack);
  let segPlacements = [];
  for (let segRect of segRects) {
    segPlacements.push({
      seg: segs[segRect.index],
      rect: segRect
    });
  }
  for (let dumbSeg of dumbSegs) {
    segPlacements.push({ seg: dumbSeg, rect: null });
  }
  return { segPlacements, hiddenGroups };
}
var DEFAULT_TIME_FORMAT = createFormatter({
  hour: "numeric",
  minute: "2-digit",
  meridiem: false
});
var TimeColEvent = class extends BaseComponent {
  render() {
    return y(StandardEvent, Object.assign({}, this.props, { elClasses: [
      "fc-timegrid-event",
      "fc-v-event",
      this.props.isShort && "fc-timegrid-event-short"
    ], defaultTimeFormat: DEFAULT_TIME_FORMAT }));
  }
};
var TimeCol = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.sortEventSegs = memoize(sortEventSegs);
  }
  // TODO: memoize event-placement?
  render() {
    let { props, context } = this;
    let { options } = context;
    let isSelectMirror = options.selectMirror;
    let mirrorSegs = (
      // yuck
      props.eventDrag && props.eventDrag.segs || props.eventResize && props.eventResize.segs || isSelectMirror && props.dateSelectionSegs || []
    );
    let interactionAffectedInstances = (
      // TODO: messy way to compute this
      props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {}
    );
    let sortedFgSegs = this.sortEventSegs(props.fgEventSegs, options.eventOrder);
    return y(DayCellContainer, { elTag: "td", elRef: props.elRef, elClasses: [
      "fc-timegrid-col",
      ...props.extraClassNames || []
    ], elAttrs: Object.assign({ role: "gridcell" }, props.extraDataAttrs), date: props.date, dateProfile: props.dateProfile, todayRange: props.todayRange, extraRenderProps: props.extraRenderProps }, (InnerContent) => y(
      "div",
      { className: "fc-timegrid-col-frame" },
      y(
        "div",
        { className: "fc-timegrid-col-bg" },
        this.renderFillSegs(props.businessHourSegs, "non-business"),
        this.renderFillSegs(props.bgEventSegs, "bg-event"),
        this.renderFillSegs(props.dateSelectionSegs, "highlight")
      ),
      y("div", { className: "fc-timegrid-col-events" }, this.renderFgSegs(sortedFgSegs, interactionAffectedInstances, false, false, false)),
      y("div", { className: "fc-timegrid-col-events" }, this.renderFgSegs(mirrorSegs, {}, Boolean(props.eventDrag), Boolean(props.eventResize), Boolean(isSelectMirror), "mirror")),
      y("div", { className: "fc-timegrid-now-indicator-container" }, this.renderNowIndicator(props.nowIndicatorSegs)),
      hasCustomDayCellContent(options) && y(InnerContent, { elTag: "div", elClasses: ["fc-timegrid-col-misc"] })
    ));
  }
  renderFgSegs(sortedFgSegs, segIsInvisible, isDragging, isResizing, isDateSelecting, forcedKey) {
    let { props } = this;
    if (props.forPrint) {
      return renderPlainFgSegs(sortedFgSegs, props);
    }
    return this.renderPositionedFgSegs(sortedFgSegs, segIsInvisible, isDragging, isResizing, isDateSelecting, forcedKey);
  }
  renderPositionedFgSegs(segs, segIsInvisible, isDragging, isResizing, isDateSelecting, forcedKey) {
    let { eventMaxStack, eventShortHeight, eventOrderStrict, eventMinHeight } = this.context.options;
    let { date, slatCoords, eventSelection, todayRange, nowDate } = this.props;
    let isMirror = isDragging || isResizing || isDateSelecting;
    let segVCoords = computeSegVCoords(segs, date, slatCoords, eventMinHeight);
    let { segPlacements, hiddenGroups } = computeFgSegPlacements(segs, segVCoords, eventOrderStrict, eventMaxStack);
    return y(
      _,
      null,
      this.renderHiddenGroups(hiddenGroups, segs),
      segPlacements.map((segPlacement) => {
        let { seg, rect } = segPlacement;
        let instanceId = seg.eventRange.instance.instanceId;
        let isVisible = isMirror || Boolean(!segIsInvisible[instanceId] && rect);
        let vStyle = computeSegVStyle(rect && rect.span);
        let hStyle = !isMirror && rect ? this.computeSegHStyle(rect) : { left: 0, right: 0 };
        let isInset = Boolean(rect) && rect.stackForward > 0;
        let isShort = Boolean(rect) && rect.span.end - rect.span.start < eventShortHeight;
        return y(
          "div",
          { className: "fc-timegrid-event-harness" + (isInset ? " fc-timegrid-event-harness-inset" : ""), key: forcedKey || instanceId, style: Object.assign(Object.assign({ visibility: isVisible ? "" : "hidden" }, vStyle), hStyle) },
          y(TimeColEvent, Object.assign({ seg, isDragging, isResizing, isDateSelecting, isSelected: instanceId === eventSelection, isShort }, getSegMeta(seg, todayRange, nowDate)))
        );
      })
    );
  }
  // will already have eventMinHeight applied because segInputs already had it
  renderHiddenGroups(hiddenGroups, segs) {
    let { extraDateSpan, dateProfile, todayRange, nowDate, eventSelection, eventDrag, eventResize } = this.props;
    return y(_, null, hiddenGroups.map((hiddenGroup) => {
      let positionCss = computeSegVStyle(hiddenGroup.span);
      let hiddenSegs = compileSegsFromEntries(hiddenGroup.entries, segs);
      return y(TimeColMoreLink, { key: buildIsoString(computeEarliestSegStart(hiddenSegs)), hiddenSegs, top: positionCss.top, bottom: positionCss.bottom, extraDateSpan, dateProfile, todayRange, nowDate, eventSelection, eventDrag, eventResize });
    }));
  }
  renderFillSegs(segs, fillType) {
    let { props, context } = this;
    let segVCoords = computeSegVCoords(segs, props.date, props.slatCoords, context.options.eventMinHeight);
    let children = segVCoords.map((vcoords, i3) => {
      let seg = segs[i3];
      return y("div", { key: buildEventRangeKey(seg.eventRange), className: "fc-timegrid-bg-harness", style: computeSegVStyle(vcoords) }, fillType === "bg-event" ? y(BgEvent, Object.assign({ seg }, getSegMeta(seg, props.todayRange, props.nowDate))) : renderFill(fillType));
    });
    return y(_, null, children);
  }
  renderNowIndicator(segs) {
    let { slatCoords, date } = this.props;
    if (!slatCoords) {
      return null;
    }
    return segs.map((seg, i3) => y(
      NowIndicatorContainer,
      {
        // key doesn't matter. will only ever be one
        key: i3,
        elClasses: ["fc-timegrid-now-indicator-line"],
        elStyle: {
          top: slatCoords.computeDateTop(seg.start, date)
        },
        isAxis: false,
        date
      }
    ));
  }
  computeSegHStyle(segHCoords) {
    let { isRtl, options } = this.context;
    let shouldOverlap = options.slotEventOverlap;
    let nearCoord = segHCoords.levelCoord;
    let farCoord = segHCoords.levelCoord + segHCoords.thickness;
    let left;
    let right;
    if (shouldOverlap) {
      farCoord = Math.min(1, nearCoord + (farCoord - nearCoord) * 2);
    }
    if (isRtl) {
      left = 1 - farCoord;
      right = nearCoord;
    } else {
      left = nearCoord;
      right = 1 - farCoord;
    }
    let props = {
      zIndex: segHCoords.stackDepth + 1,
      left: left * 100 + "%",
      right: right * 100 + "%"
    };
    if (shouldOverlap && !segHCoords.stackForward) {
      props[isRtl ? "marginLeft" : "marginRight"] = 10 * 2;
    }
    return props;
  }
};
function renderPlainFgSegs(sortedFgSegs, { todayRange, nowDate, eventSelection, eventDrag, eventResize }) {
  let hiddenInstances = (eventDrag ? eventDrag.affectedInstances : null) || (eventResize ? eventResize.affectedInstances : null) || {};
  return y(_, null, sortedFgSegs.map((seg) => {
    let instanceId = seg.eventRange.instance.instanceId;
    return y(
      "div",
      { key: instanceId, style: { visibility: hiddenInstances[instanceId] ? "hidden" : "" } },
      y(TimeColEvent, Object.assign({ seg, isDragging: false, isResizing: false, isDateSelecting: false, isSelected: instanceId === eventSelection, isShort: false }, getSegMeta(seg, todayRange, nowDate)))
    );
  }));
}
function computeSegVStyle(segVCoords) {
  if (!segVCoords) {
    return { top: "", bottom: "" };
  }
  return {
    top: segVCoords.start,
    bottom: -segVCoords.end
  };
}
function compileSegsFromEntries(segEntries, allSegs) {
  return segEntries.map((segEntry) => allSegs[segEntry.index]);
}
var TimeColsContent = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.splitFgEventSegs = memoize(splitSegsByCol);
    this.splitBgEventSegs = memoize(splitSegsByCol);
    this.splitBusinessHourSegs = memoize(splitSegsByCol);
    this.splitNowIndicatorSegs = memoize(splitSegsByCol);
    this.splitDateSelectionSegs = memoize(splitSegsByCol);
    this.splitEventDrag = memoize(splitInteractionByCol);
    this.splitEventResize = memoize(splitInteractionByCol);
    this.rootElRef = d();
    this.cellElRefs = new RefMap();
  }
  render() {
    let { props, context } = this;
    let nowIndicatorTop = context.options.nowIndicator && props.slatCoords && props.slatCoords.safeComputeTop(props.nowDate);
    let colCnt = props.cells.length;
    let fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, colCnt);
    let bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, colCnt);
    let businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, colCnt);
    let nowIndicatorSegsByRow = this.splitNowIndicatorSegs(props.nowIndicatorSegs, colCnt);
    let dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, colCnt);
    let eventDragByRow = this.splitEventDrag(props.eventDrag, colCnt);
    let eventResizeByRow = this.splitEventResize(props.eventResize, colCnt);
    return y(
      "div",
      { className: "fc-timegrid-cols", ref: this.rootElRef },
      y(
        "table",
        { role: "presentation", style: {
          minWidth: props.tableMinWidth,
          width: props.clientWidth
        } },
        props.tableColGroupNode,
        y(
          "tbody",
          { role: "presentation" },
          y(
            "tr",
            { role: "row" },
            props.axis && y(
              "td",
              { "aria-hidden": true, className: "fc-timegrid-col fc-timegrid-axis" },
              y(
                "div",
                { className: "fc-timegrid-col-frame" },
                y("div", { className: "fc-timegrid-now-indicator-container" }, typeof nowIndicatorTop === "number" && y(NowIndicatorContainer, { elClasses: ["fc-timegrid-now-indicator-arrow"], elStyle: { top: nowIndicatorTop }, isAxis: true, date: props.nowDate }))
              )
            ),
            props.cells.map((cell, i3) => y(TimeCol, { key: cell.key, elRef: this.cellElRefs.createRef(cell.key), dateProfile: props.dateProfile, date: cell.date, nowDate: props.nowDate, todayRange: props.todayRange, extraRenderProps: cell.extraRenderProps, extraDataAttrs: cell.extraDataAttrs, extraClassNames: cell.extraClassNames, extraDateSpan: cell.extraDateSpan, fgEventSegs: fgEventSegsByRow[i3], bgEventSegs: bgEventSegsByRow[i3], businessHourSegs: businessHourSegsByRow[i3], nowIndicatorSegs: nowIndicatorSegsByRow[i3], dateSelectionSegs: dateSelectionSegsByRow[i3], eventDrag: eventDragByRow[i3], eventResize: eventResizeByRow[i3], slatCoords: props.slatCoords, eventSelection: props.eventSelection, forPrint: props.forPrint }))
          )
        )
      )
    );
  }
  componentDidMount() {
    this.updateCoords();
  }
  componentDidUpdate() {
    this.updateCoords();
  }
  updateCoords() {
    let { props } = this;
    if (props.onColCoords && props.clientWidth !== null) {
      props.onColCoords(new PositionCache(
        this.rootElRef.current,
        collectCellEls(this.cellElRefs.currentMap, props.cells),
        true,
        // horizontal
        false
      ));
    }
  }
};
function collectCellEls(elMap, cells) {
  return cells.map((cell) => elMap[cell.key]);
}
var TimeCols = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.processSlotOptions = memoize(processSlotOptions);
    this.state = {
      slatCoords: null
    };
    this.handleRootEl = (el) => {
      if (el) {
        this.context.registerInteractiveComponent(this, {
          el,
          isHitComboAllowed: this.props.isHitComboAllowed
        });
      } else {
        this.context.unregisterInteractiveComponent(this);
      }
    };
    this.handleScrollRequest = (request) => {
      let { onScrollTopRequest } = this.props;
      let { slatCoords } = this.state;
      if (onScrollTopRequest && slatCoords) {
        if (request.time) {
          let top = slatCoords.computeTimeTop(request.time);
          top = Math.ceil(top);
          if (top) {
            top += 1;
          }
          onScrollTopRequest(top);
        }
        return true;
      }
      return false;
    };
    this.handleColCoords = (colCoords) => {
      this.colCoords = colCoords;
    };
    this.handleSlatCoords = (slatCoords) => {
      this.setState({ slatCoords });
      if (this.props.onSlatCoords) {
        this.props.onSlatCoords(slatCoords);
      }
    };
  }
  render() {
    let { props, state } = this;
    return y(
      "div",
      { className: "fc-timegrid-body", ref: this.handleRootEl, style: {
        // these props are important to give this wrapper correct dimensions for interactions
        // TODO: if we set it here, can we avoid giving to inner tables?
        width: props.clientWidth,
        minWidth: props.tableMinWidth
      } },
      y(TimeColsSlats, { axis: props.axis, dateProfile: props.dateProfile, slatMetas: props.slatMetas, clientWidth: props.clientWidth, minHeight: props.expandRows ? props.clientHeight : "", tableMinWidth: props.tableMinWidth, tableColGroupNode: props.axis ? props.tableColGroupNode : null, onCoords: this.handleSlatCoords }),
      y(TimeColsContent, { cells: props.cells, axis: props.axis, dateProfile: props.dateProfile, businessHourSegs: props.businessHourSegs, bgEventSegs: props.bgEventSegs, fgEventSegs: props.fgEventSegs, dateSelectionSegs: props.dateSelectionSegs, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, todayRange: props.todayRange, nowDate: props.nowDate, nowIndicatorSegs: props.nowIndicatorSegs, clientWidth: props.clientWidth, tableMinWidth: props.tableMinWidth, tableColGroupNode: props.tableColGroupNode, slatCoords: state.slatCoords, onColCoords: this.handleColCoords, forPrint: props.forPrint })
    );
  }
  componentDidMount() {
    this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest);
  }
  componentDidUpdate(prevProps) {
    this.scrollResponder.update(prevProps.dateProfile !== this.props.dateProfile);
  }
  componentWillUnmount() {
    this.scrollResponder.detach();
  }
  queryHit(positionLeft, positionTop) {
    let { dateEnv, options } = this.context;
    let { colCoords } = this;
    let { dateProfile } = this.props;
    let { slatCoords } = this.state;
    let { snapDuration, snapsPerSlot } = this.processSlotOptions(this.props.slotDuration, options.snapDuration);
    let colIndex = colCoords.leftToIndex(positionLeft);
    let slatIndex = slatCoords.positions.topToIndex(positionTop);
    if (colIndex != null && slatIndex != null) {
      let cell = this.props.cells[colIndex];
      let slatTop = slatCoords.positions.tops[slatIndex];
      let slatHeight = slatCoords.positions.getHeight(slatIndex);
      let partial = (positionTop - slatTop) / slatHeight;
      let localSnapIndex = Math.floor(partial * snapsPerSlot);
      let snapIndex = slatIndex * snapsPerSlot + localSnapIndex;
      let dayDate = this.props.cells[colIndex].date;
      let time = addDurations(dateProfile.slotMinTime, multiplyDuration(snapDuration, snapIndex));
      let start = dateEnv.add(dayDate, time);
      let end = dateEnv.add(start, snapDuration);
      return {
        dateProfile,
        dateSpan: Object.assign({ range: { start, end }, allDay: false }, cell.extraDateSpan),
        dayEl: colCoords.els[colIndex],
        rect: {
          left: colCoords.lefts[colIndex],
          right: colCoords.rights[colIndex],
          top: slatTop,
          bottom: slatTop + slatHeight
        },
        layer: 0
      };
    }
    return null;
  }
};
function processSlotOptions(slotDuration, snapDurationOverride) {
  let snapDuration = snapDurationOverride || slotDuration;
  let snapsPerSlot = wholeDivideDurations(slotDuration, snapDuration);
  if (snapsPerSlot === null) {
    snapDuration = slotDuration;
    snapsPerSlot = 1;
  }
  return { snapDuration, snapsPerSlot };
}
var DayTimeColsSlicer = class extends Slicer {
  sliceRange(range2, dayRanges) {
    let segs = [];
    for (let col = 0; col < dayRanges.length; col += 1) {
      let segRange = intersectRanges(range2, dayRanges[col]);
      if (segRange) {
        segs.push({
          start: segRange.start,
          end: segRange.end,
          isStart: segRange.start.valueOf() === range2.start.valueOf(),
          isEnd: segRange.end.valueOf() === range2.end.valueOf(),
          col
        });
      }
    }
    return segs;
  }
};
var DayTimeCols = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.buildDayRanges = memoize(buildDayRanges);
    this.slicer = new DayTimeColsSlicer();
    this.timeColsRef = d();
  }
  render() {
    let { props, context } = this;
    let { dateProfile, dayTableModel } = props;
    let { nowIndicator, nextDayThreshold } = context.options;
    let dayRanges = this.buildDayRanges(dayTableModel, dateProfile, context.dateEnv);
    return y(NowTimer, { unit: nowIndicator ? "minute" : "day" }, (nowDate, todayRange) => y(TimeCols, Object.assign({ ref: this.timeColsRef }, this.slicer.sliceProps(props, dateProfile, null, context, dayRanges), { forPrint: props.forPrint, axis: props.axis, dateProfile, slatMetas: props.slatMetas, slotDuration: props.slotDuration, cells: dayTableModel.cells[0], tableColGroupNode: props.tableColGroupNode, tableMinWidth: props.tableMinWidth, clientWidth: props.clientWidth, clientHeight: props.clientHeight, expandRows: props.expandRows, nowDate, nowIndicatorSegs: nowIndicator && this.slicer.sliceNowDate(nowDate, dateProfile, nextDayThreshold, context, dayRanges), todayRange, onScrollTopRequest: props.onScrollTopRequest, onSlatCoords: props.onSlatCoords })));
  }
};
function buildDayRanges(dayTableModel, dateProfile, dateEnv) {
  let ranges = [];
  for (let date of dayTableModel.headerDates) {
    ranges.push({
      start: dateEnv.add(date, dateProfile.slotMinTime),
      end: dateEnv.add(date, dateProfile.slotMaxTime)
    });
  }
  return ranges;
}
var STOCK_SUB_DURATIONS = [
  { hours: 1 },
  { minutes: 30 },
  { minutes: 15 },
  { seconds: 30 },
  { seconds: 15 }
];
function buildSlatMetas(slotMinTime, slotMaxTime, explicitLabelInterval, slotDuration, dateEnv) {
  let dayStart = new Date(0);
  let slatTime = slotMinTime;
  let slatIterator = createDuration(0);
  let labelInterval = explicitLabelInterval || computeLabelInterval(slotDuration);
  let metas = [];
  while (asRoughMs(slatTime) < asRoughMs(slotMaxTime)) {
    let date = dateEnv.add(dayStart, slatTime);
    let isLabeled = wholeDivideDurations(slatIterator, labelInterval) !== null;
    metas.push({
      date,
      time: slatTime,
      key: date.toISOString(),
      isoTimeStr: formatIsoTimeString(date),
      isLabeled
    });
    slatTime = addDurations(slatTime, slotDuration);
    slatIterator = addDurations(slatIterator, slotDuration);
  }
  return metas;
}
function computeLabelInterval(slotDuration) {
  let i3;
  let labelInterval;
  let slotsPerLabel;
  for (i3 = STOCK_SUB_DURATIONS.length - 1; i3 >= 0; i3 -= 1) {
    labelInterval = createDuration(STOCK_SUB_DURATIONS[i3]);
    slotsPerLabel = wholeDivideDurations(labelInterval, slotDuration);
    if (slotsPerLabel !== null && slotsPerLabel > 1) {
      return labelInterval;
    }
  }
  return slotDuration;
}
var DayTimeColsView = class extends TimeColsView {
  constructor() {
    super(...arguments);
    this.buildTimeColsModel = memoize(buildTimeColsModel);
    this.buildSlatMetas = memoize(buildSlatMetas);
  }
  render() {
    let { options, dateEnv, dateProfileGenerator } = this.context;
    let { props } = this;
    let { dateProfile } = props;
    let dayTableModel = this.buildTimeColsModel(dateProfile, dateProfileGenerator);
    let splitProps = this.allDaySplitter.splitProps(props);
    let slatMetas = this.buildSlatMetas(dateProfile.slotMinTime, dateProfile.slotMaxTime, options.slotLabelInterval, options.slotDuration, dateEnv);
    let { dayMinWidth } = options;
    let hasAttachedAxis = !dayMinWidth;
    let hasDetachedAxis = dayMinWidth;
    let headerContent = options.dayHeaders && y(DayHeader, { dates: dayTableModel.headerDates, dateProfile, datesRepDistinctDays: true, renderIntro: hasAttachedAxis ? this.renderHeadAxis : null });
    let allDayContent = options.allDaySlot !== false && ((contentArg) => y(DayTable, Object.assign({}, splitProps.allDay, { dateProfile, dayTableModel, nextDayThreshold: options.nextDayThreshold, tableMinWidth: contentArg.tableMinWidth, colGroupNode: contentArg.tableColGroupNode, renderRowIntro: hasAttachedAxis ? this.renderTableRowAxis : null, showWeekNumbers: false, expandRows: false, headerAlignElRef: this.headerElRef, clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, forPrint: props.forPrint }, this.getAllDayMaxEventProps())));
    let timeGridContent = (contentArg) => y(DayTimeCols, Object.assign({}, splitProps.timed, { dayTableModel, dateProfile, axis: hasAttachedAxis, slotDuration: options.slotDuration, slatMetas, forPrint: props.forPrint, tableColGroupNode: contentArg.tableColGroupNode, tableMinWidth: contentArg.tableMinWidth, clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, onSlatCoords: this.handleSlatCoords, expandRows: contentArg.expandRows, onScrollTopRequest: this.handleScrollTopRequest }));
    return hasDetachedAxis ? this.renderHScrollLayout(headerContent, allDayContent, timeGridContent, dayTableModel.colCnt, dayMinWidth, slatMetas, this.state.slatCoords) : this.renderSimpleLayout(headerContent, allDayContent, timeGridContent);
  }
};
function buildTimeColsModel(dateProfile, dateProfileGenerator) {
  let daySeries = new DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);
  return new DayTableModel(daySeries, false);
}
var css_248z3 = '.fc-v-event{background-color:var(--fc-event-bg-color);border:1px solid var(--fc-event-border-color);display:block}.fc-v-event .fc-event-main{color:var(--fc-event-text-color);height:100%}.fc-v-event .fc-event-main-frame{display:flex;flex-direction:column;height:100%}.fc-v-event .fc-event-time{flex-grow:0;flex-shrink:0;max-height:100%;overflow:hidden}.fc-v-event .fc-event-title-container{flex-grow:1;flex-shrink:1;min-height:0}.fc-v-event .fc-event-title{bottom:0;max-height:100%;overflow:hidden;top:0}.fc-v-event:not(.fc-event-start){border-top-left-radius:0;border-top-right-radius:0;border-top-width:0}.fc-v-event:not(.fc-event-end){border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom-width:0}.fc-v-event.fc-event-selected:before{left:-10px;right:-10px}.fc-v-event .fc-event-resizer-start{cursor:n-resize}.fc-v-event .fc-event-resizer-end{cursor:s-resize}.fc-v-event:not(.fc-event-selected) .fc-event-resizer{height:var(--fc-event-resizer-thickness);left:0;right:0}.fc-v-event:not(.fc-event-selected) .fc-event-resizer-start{top:calc(var(--fc-event-resizer-thickness)/-2)}.fc-v-event:not(.fc-event-selected) .fc-event-resizer-end{bottom:calc(var(--fc-event-resizer-thickness)/-2)}.fc-v-event.fc-event-selected .fc-event-resizer{left:50%;margin-left:calc(var(--fc-event-resizer-dot-total-width)/-2)}.fc-v-event.fc-event-selected .fc-event-resizer-start{top:calc(var(--fc-event-resizer-dot-total-width)/-2)}.fc-v-event.fc-event-selected .fc-event-resizer-end{bottom:calc(var(--fc-event-resizer-dot-total-width)/-2)}.fc .fc-timegrid .fc-daygrid-body{z-index:2}.fc .fc-timegrid-divider{padding:0 0 2px}.fc .fc-timegrid-body{min-height:100%;position:relative;z-index:1}.fc .fc-timegrid-axis-chunk{position:relative}.fc .fc-timegrid-axis-chunk>table,.fc .fc-timegrid-slots{position:relative;z-index:1}.fc .fc-timegrid-slot{border-bottom:0;height:1.5em}.fc .fc-timegrid-slot:empty:before{content:"\\00a0"}.fc .fc-timegrid-slot-minor{border-top-style:dotted}.fc .fc-timegrid-slot-label-cushion{display:inline-block;white-space:nowrap}.fc .fc-timegrid-slot-label{vertical-align:middle}.fc .fc-timegrid-axis-cushion,.fc .fc-timegrid-slot-label-cushion{padding:0 4px}.fc .fc-timegrid-axis-frame-liquid{height:100%}.fc .fc-timegrid-axis-frame{align-items:center;display:flex;justify-content:flex-end;overflow:hidden}.fc .fc-timegrid-axis-cushion{flex-shrink:0;max-width:60px}.fc-direction-ltr .fc-timegrid-slot-label-frame{text-align:right}.fc-direction-rtl .fc-timegrid-slot-label-frame{text-align:left}.fc-liquid-hack .fc-timegrid-axis-frame-liquid{bottom:0;height:auto;left:0;position:absolute;right:0;top:0}.fc .fc-timegrid-col.fc-day-today{background-color:var(--fc-today-bg-color)}.fc .fc-timegrid-col-frame{min-height:100%;position:relative}.fc-media-screen.fc-liquid-hack .fc-timegrid-col-frame{bottom:0;height:auto;left:0;position:absolute;right:0;top:0}.fc-media-screen .fc-timegrid-cols{bottom:0;left:0;position:absolute;right:0;top:0}.fc-media-screen .fc-timegrid-cols>table{height:100%}.fc-media-screen .fc-timegrid-col-bg,.fc-media-screen .fc-timegrid-col-events,.fc-media-screen .fc-timegrid-now-indicator-container{left:0;position:absolute;right:0;top:0}.fc .fc-timegrid-col-bg{z-index:2}.fc .fc-timegrid-col-bg .fc-non-business{z-index:1}.fc .fc-timegrid-col-bg .fc-bg-event{z-index:2}.fc .fc-timegrid-col-bg .fc-highlight{z-index:3}.fc .fc-timegrid-bg-harness{left:0;position:absolute;right:0}.fc .fc-timegrid-col-events{z-index:3}.fc .fc-timegrid-now-indicator-container{bottom:0;overflow:hidden}.fc-direction-ltr .fc-timegrid-col-events{margin:0 2.5% 0 2px}.fc-direction-rtl .fc-timegrid-col-events{margin:0 2px 0 2.5%}.fc-timegrid-event-harness{position:absolute}.fc-timegrid-event-harness>.fc-timegrid-event{bottom:0;left:0;position:absolute;right:0;top:0}.fc-timegrid-event-harness-inset .fc-timegrid-event,.fc-timegrid-event.fc-event-mirror,.fc-timegrid-more-link{box-shadow:0 0 0 1px var(--fc-page-bg-color)}.fc-timegrid-event,.fc-timegrid-more-link{border-radius:3px;font-size:var(--fc-small-font-size)}.fc-timegrid-event{margin-bottom:1px}.fc-timegrid-event .fc-event-main{padding:1px 1px 0}.fc-timegrid-event .fc-event-time{font-size:var(--fc-small-font-size);margin-bottom:1px;white-space:nowrap}.fc-timegrid-event-short .fc-event-main-frame{flex-direction:row;overflow:hidden}.fc-timegrid-event-short .fc-event-time:after{content:"\\00a0-\\00a0"}.fc-timegrid-event-short .fc-event-title{font-size:var(--fc-small-font-size)}.fc-timegrid-more-link{background:var(--fc-more-link-bg-color);color:var(--fc-more-link-text-color);cursor:pointer;margin-bottom:1px;position:absolute;z-index:9999}.fc-timegrid-more-link-inner{padding:3px 2px;top:0}.fc-direction-ltr .fc-timegrid-more-link{right:0}.fc-direction-rtl .fc-timegrid-more-link{left:0}.fc .fc-timegrid-now-indicator-arrow,.fc .fc-timegrid-now-indicator-line{pointer-events:none}.fc .fc-timegrid-now-indicator-line{border-color:var(--fc-now-indicator-color);border-style:solid;border-width:1px 0 0;left:0;position:absolute;right:0;z-index:4}.fc .fc-timegrid-now-indicator-arrow{border-color:var(--fc-now-indicator-color);border-style:solid;margin-top:-5px;position:absolute;z-index:4}.fc-direction-ltr .fc-timegrid-now-indicator-arrow{border-bottom-color:transparent;border-top-color:transparent;border-width:5px 0 5px 6px;left:0}.fc-direction-rtl .fc-timegrid-now-indicator-arrow{border-bottom-color:transparent;border-top-color:transparent;border-width:5px 6px 5px 0;right:0}';
injectStyles(css_248z3);

// node_modules/@fullcalendar/timegrid/index.js
var OPTION_REFINERS = {
  allDaySlot: Boolean
};
var index2 = createPlugin({
  name: "@fullcalendar/timegrid",
  initialView: "timeGridWeek",
  optionRefiners: OPTION_REFINERS,
  views: {
    timeGrid: {
      component: DayTimeColsView,
      usesMinMaxTime: true,
      allDaySlot: true,
      slotDuration: "00:30:00",
      slotEventOverlap: true
      // a bad name. confused with overlap/constraint system
    },
    timeGridDay: {
      type: "timeGrid",
      duration: { days: 1 }
    },
    timeGridWeek: {
      type: "timeGrid",
      duration: { weeks: 1 }
    }
  }
});

// node_modules/rrule/dist/esm/weekday.js
var ALL_WEEKDAYS = [
  "MO",
  "TU",
  "WE",
  "TH",
  "FR",
  "SA",
  "SU"
];
var Weekday = (
  /** @class */
  function() {
    function Weekday2(weekday, n2) {
      if (n2 === 0)
        throw new Error("Can't create weekday with n == 0");
      this.weekday = weekday;
      this.n = n2;
    }
    Weekday2.fromStr = function(str) {
      return new Weekday2(ALL_WEEKDAYS.indexOf(str));
    };
    Weekday2.prototype.nth = function(n2) {
      return this.n === n2 ? this : new Weekday2(this.weekday, n2);
    };
    Weekday2.prototype.equals = function(other) {
      return this.weekday === other.weekday && this.n === other.n;
    };
    Weekday2.prototype.toString = function() {
      var s3 = ALL_WEEKDAYS[this.weekday];
      if (this.n)
        s3 = (this.n > 0 ? "+" : "") + String(this.n) + s3;
      return s3;
    };
    Weekday2.prototype.getJsWeekday = function() {
      return this.weekday === 6 ? 0 : this.weekday + 1;
    };
    return Weekday2;
  }()
);

// node_modules/rrule/dist/esm/helpers.js
var isPresent = function(value) {
  return value !== null && value !== void 0;
};
var isNumber = function(value) {
  return typeof value === "number";
};
var isWeekdayStr = function(value) {
  return typeof value === "string" && ALL_WEEKDAYS.includes(value);
};
var isArray = Array.isArray;
var range = function(start, end) {
  if (end === void 0) {
    end = start;
  }
  if (arguments.length === 1) {
    end = start;
    start = 0;
  }
  var rang = [];
  for (var i3 = start; i3 < end; i3++)
    rang.push(i3);
  return rang;
};
var repeat = function(value, times) {
  var i3 = 0;
  var array = [];
  if (isArray(value)) {
    for (; i3 < times; i3++)
      array[i3] = [].concat(value);
  } else {
    for (; i3 < times; i3++)
      array[i3] = value;
  }
  return array;
};
var toArray = function(item) {
  if (isArray(item)) {
    return item;
  }
  return [item];
};
function padStart2(item, targetLength, padString) {
  if (padString === void 0) {
    padString = " ";
  }
  var str = String(item);
  targetLength = targetLength >> 0;
  if (str.length > targetLength) {
    return String(str);
  }
  targetLength = targetLength - str.length;
  if (targetLength > padString.length) {
    padString += repeat(padString, targetLength / padString.length);
  }
  return padString.slice(0, targetLength) + String(str);
}
var split = function(str, sep, num) {
  var splits = str.split(sep);
  return num ? splits.slice(0, num).concat([splits.slice(num).join(sep)]) : splits;
};
var pymod = function(a3, b3) {
  var r3 = a3 % b3;
  return r3 * b3 < 0 ? r3 + b3 : r3;
};
var divmod = function(a3, b3) {
  return { div: Math.floor(a3 / b3), mod: pymod(a3, b3) };
};
var empty = function(obj) {
  return !isPresent(obj) || obj.length === 0;
};
var notEmpty = function(obj) {
  return !empty(obj);
};
var includes = function(arr, val) {
  return notEmpty(arr) && arr.indexOf(val) !== -1;
};

// node_modules/rrule/dist/esm/dateutil.js
var datetime = function(y3, m3, d2, h3, i3, s3) {
  if (h3 === void 0) {
    h3 = 0;
  }
  if (i3 === void 0) {
    i3 = 0;
  }
  if (s3 === void 0) {
    s3 = 0;
  }
  return new Date(Date.UTC(y3, m3 - 1, d2, h3, i3, s3));
};
var MONTH_DAYS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var ONE_DAY = 1e3 * 60 * 60 * 24;
var MAXYEAR = 9999;
var ORDINAL_BASE = datetime(1970, 1, 1);
var PY_WEEKDAYS = [6, 0, 1, 2, 3, 4, 5];
var isLeapYear = function(year) {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
};
var isDate = function(value) {
  return value instanceof Date;
};
var isValidDate2 = function(value) {
  return isDate(value) && !isNaN(value.getTime());
};
var daysBetween = function(date1, date2) {
  var date1ms = date1.getTime();
  var date2ms = date2.getTime();
  var differencems = date1ms - date2ms;
  return Math.round(differencems / ONE_DAY);
};
var toOrdinal = function(date) {
  return daysBetween(date, ORDINAL_BASE);
};
var fromOrdinal = function(ordinal) {
  return new Date(ORDINAL_BASE.getTime() + ordinal * ONE_DAY);
};
var getMonthDays = function(date) {
  var month = date.getUTCMonth();
  return month === 1 && isLeapYear(date.getUTCFullYear()) ? 29 : MONTH_DAYS[month];
};
var getWeekday = function(date) {
  return PY_WEEKDAYS[date.getUTCDay()];
};
var monthRange = function(year, month) {
  var date = datetime(year, month + 1, 1);
  return [getWeekday(date), getMonthDays(date)];
};
var combine = function(date, time) {
  time = time || date;
  return new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds()));
};
var clone = function(date) {
  var dolly = new Date(date.getTime());
  return dolly;
};
var cloneDates = function(dates) {
  var clones = [];
  for (var i3 = 0; i3 < dates.length; i3++) {
    clones.push(clone(dates[i3]));
  }
  return clones;
};
var sort = function(dates) {
  dates.sort(function(a3, b3) {
    return a3.getTime() - b3.getTime();
  });
};
var timeToUntilString = function(time, utc) {
  if (utc === void 0) {
    utc = true;
  }
  var date = new Date(time);
  return [
    padStart2(date.getUTCFullYear().toString(), 4, "0"),
    padStart2(date.getUTCMonth() + 1, 2, "0"),
    padStart2(date.getUTCDate(), 2, "0"),
    "T",
    padStart2(date.getUTCHours(), 2, "0"),
    padStart2(date.getUTCMinutes(), 2, "0"),
    padStart2(date.getUTCSeconds(), 2, "0"),
    utc ? "Z" : ""
  ].join("");
};
var untilStringToDate = function(until) {
  var re = /^(\d{4})(\d{2})(\d{2})(T(\d{2})(\d{2})(\d{2})Z?)?$/;
  var bits = re.exec(until);
  if (!bits)
    throw new Error("Invalid UNTIL value: ".concat(until));
  return new Date(Date.UTC(parseInt(bits[1], 10), parseInt(bits[2], 10) - 1, parseInt(bits[3], 10), parseInt(bits[5], 10) || 0, parseInt(bits[6], 10) || 0, parseInt(bits[7], 10) || 0));
};
var dateTZtoISO8601 = function(date, timeZone) {
  var dateStr = date.toLocaleString("sv-SE", { timeZone });
  return dateStr.replace(" ", "T") + "Z";
};
var dateInTimeZone = function(date, timeZone) {
  var localTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
  var dateInLocalTZ = new Date(dateTZtoISO8601(date, localTimeZone));
  var dateInTargetTZ = new Date(dateTZtoISO8601(date, timeZone !== null && timeZone !== void 0 ? timeZone : "UTC"));
  var tzOffset = dateInTargetTZ.getTime() - dateInLocalTZ.getTime();
  return new Date(date.getTime() - tzOffset);
};

// node_modules/rrule/dist/esm/iterresult.js
var IterResult = (
  /** @class */
  function() {
    function IterResult2(method, args) {
      this.minDate = null;
      this.maxDate = null;
      this._result = [];
      this.total = 0;
      this.method = method;
      this.args = args;
      if (method === "between") {
        this.maxDate = args.inc ? args.before : new Date(args.before.getTime() - 1);
        this.minDate = args.inc ? args.after : new Date(args.after.getTime() + 1);
      } else if (method === "before") {
        this.maxDate = args.inc ? args.dt : new Date(args.dt.getTime() - 1);
      } else if (method === "after") {
        this.minDate = args.inc ? args.dt : new Date(args.dt.getTime() + 1);
      }
    }
    IterResult2.prototype.accept = function(date) {
      ++this.total;
      var tooEarly = this.minDate && date < this.minDate;
      var tooLate = this.maxDate && date > this.maxDate;
      if (this.method === "between") {
        if (tooEarly)
          return true;
        if (tooLate)
          return false;
      } else if (this.method === "before") {
        if (tooLate)
          return false;
      } else if (this.method === "after") {
        if (tooEarly)
          return true;
        this.add(date);
        return false;
      }
      return this.add(date);
    };
    IterResult2.prototype.add = function(date) {
      this._result.push(date);
      return true;
    };
    IterResult2.prototype.getValue = function() {
      var res = this._result;
      switch (this.method) {
        case "all":
        case "between":
          return res;
        case "before":
        case "after":
        default:
          return res.length ? res[res.length - 1] : null;
      }
    };
    IterResult2.prototype.clone = function() {
      return new IterResult2(this.method, this.args);
    };
    return IterResult2;
  }()
);
var iterresult_default = IterResult;

// node_modules/tslib/tslib.es6.js
var extendStatics = function(d2, b3) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b4) {
    d3.__proto__ = b4;
  } || function(d3, b4) {
    for (var p3 in b4)
      if (Object.prototype.hasOwnProperty.call(b4, p3))
        d3[p3] = b4[p3];
  };
  return extendStatics(d2, b3);
};
function __extends(d2, b3) {
  if (typeof b3 !== "function" && b3 !== null)
    throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
  extendStatics(d2, b3);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t3) {
    for (var s3, i3 = 1, n2 = arguments.length; i3 < n2; i3++) {
      s3 = arguments[i3];
      for (var p3 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p3))
          t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign.apply(this, arguments);
};
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i3 = 0, l3 = from.length, ar; i3 < l3; i3++) {
      if (ar || !(i3 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i3);
        ar[i3] = from[i3];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}

// node_modules/rrule/dist/esm/callbackiterresult.js
var CallbackIterResult = (
  /** @class */
  function(_super) {
    __extends(CallbackIterResult2, _super);
    function CallbackIterResult2(method, args, iterator) {
      var _this = _super.call(this, method, args) || this;
      _this.iterator = iterator;
      return _this;
    }
    CallbackIterResult2.prototype.add = function(date) {
      if (this.iterator(date, this._result.length)) {
        this._result.push(date);
        return true;
      }
      return false;
    };
    return CallbackIterResult2;
  }(iterresult_default)
);
var callbackiterresult_default = CallbackIterResult;

// node_modules/rrule/dist/esm/nlp/i18n.js
var ENGLISH = {
  dayNames: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ],
  monthNames: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ],
  tokens: {
    SKIP: /^[ \r\n\t]+|^\.$/,
    number: /^[1-9][0-9]*/,
    numberAsText: /^(one|two|three)/i,
    every: /^every/i,
    "day(s)": /^days?/i,
    "weekday(s)": /^weekdays?/i,
    "week(s)": /^weeks?/i,
    "hour(s)": /^hours?/i,
    "minute(s)": /^minutes?/i,
    "month(s)": /^months?/i,
    "year(s)": /^years?/i,
    on: /^(on|in)/i,
    at: /^(at)/i,
    the: /^the/i,
    first: /^first/i,
    second: /^second/i,
    third: /^third/i,
    nth: /^([1-9][0-9]*)(\.|th|nd|rd|st)/i,
    last: /^last/i,
    for: /^for/i,
    "time(s)": /^times?/i,
    until: /^(un)?til/i,
    monday: /^mo(n(day)?)?/i,
    tuesday: /^tu(e(s(day)?)?)?/i,
    wednesday: /^we(d(n(esday)?)?)?/i,
    thursday: /^th(u(r(sday)?)?)?/i,
    friday: /^fr(i(day)?)?/i,
    saturday: /^sa(t(urday)?)?/i,
    sunday: /^su(n(day)?)?/i,
    january: /^jan(uary)?/i,
    february: /^feb(ruary)?/i,
    march: /^mar(ch)?/i,
    april: /^apr(il)?/i,
    may: /^may/i,
    june: /^june?/i,
    july: /^july?/i,
    august: /^aug(ust)?/i,
    september: /^sep(t(ember)?)?/i,
    october: /^oct(ober)?/i,
    november: /^nov(ember)?/i,
    december: /^dec(ember)?/i,
    comma: /^(,\s*|(and|or)\s*)+/i
  }
};
var i18n_default = ENGLISH;

// node_modules/rrule/dist/esm/nlp/totext.js
var contains = function(arr, val) {
  return arr.indexOf(val) !== -1;
};
var defaultGetText = function(id) {
  return id.toString();
};
var defaultDateFormatter = function(year, month, day) {
  return "".concat(month, " ").concat(day, ", ").concat(year);
};
var ToText = (
  /** @class */
  function() {
    function ToText2(rrule, gettext, language, dateFormatter) {
      if (gettext === void 0) {
        gettext = defaultGetText;
      }
      if (language === void 0) {
        language = i18n_default;
      }
      if (dateFormatter === void 0) {
        dateFormatter = defaultDateFormatter;
      }
      this.text = [];
      this.language = language || i18n_default;
      this.gettext = gettext;
      this.dateFormatter = dateFormatter;
      this.rrule = rrule;
      this.options = rrule.options;
      this.origOptions = rrule.origOptions;
      if (this.origOptions.bymonthday) {
        var bymonthday = [].concat(this.options.bymonthday);
        var bynmonthday = [].concat(this.options.bynmonthday);
        bymonthday.sort(function(a3, b3) {
          return a3 - b3;
        });
        bynmonthday.sort(function(a3, b3) {
          return b3 - a3;
        });
        this.bymonthday = bymonthday.concat(bynmonthday);
        if (!this.bymonthday.length)
          this.bymonthday = null;
      }
      if (isPresent(this.origOptions.byweekday)) {
        var byweekday = !isArray(this.origOptions.byweekday) ? [this.origOptions.byweekday] : this.origOptions.byweekday;
        var days = String(byweekday);
        this.byweekday = {
          allWeeks: byweekday.filter(function(weekday) {
            return !weekday.n;
          }),
          someWeeks: byweekday.filter(function(weekday) {
            return Boolean(weekday.n);
          }),
          isWeekdays: days.indexOf("MO") !== -1 && days.indexOf("TU") !== -1 && days.indexOf("WE") !== -1 && days.indexOf("TH") !== -1 && days.indexOf("FR") !== -1 && days.indexOf("SA") === -1 && days.indexOf("SU") === -1,
          isEveryDay: days.indexOf("MO") !== -1 && days.indexOf("TU") !== -1 && days.indexOf("WE") !== -1 && days.indexOf("TH") !== -1 && days.indexOf("FR") !== -1 && days.indexOf("SA") !== -1 && days.indexOf("SU") !== -1
        };
        var sortWeekDays = function(a3, b3) {
          return a3.weekday - b3.weekday;
        };
        this.byweekday.allWeeks.sort(sortWeekDays);
        this.byweekday.someWeeks.sort(sortWeekDays);
        if (!this.byweekday.allWeeks.length)
          this.byweekday.allWeeks = null;
        if (!this.byweekday.someWeeks.length)
          this.byweekday.someWeeks = null;
      } else {
        this.byweekday = null;
      }
    }
    ToText2.isFullyConvertible = function(rrule) {
      var canConvert = true;
      if (!(rrule.options.freq in ToText2.IMPLEMENTED))
        return false;
      if (rrule.origOptions.until && rrule.origOptions.count)
        return false;
      for (var key in rrule.origOptions) {
        if (contains(["dtstart", "tzid", "wkst", "freq"], key))
          return true;
        if (!contains(ToText2.IMPLEMENTED[rrule.options.freq], key))
          return false;
      }
      return canConvert;
    };
    ToText2.prototype.isFullyConvertible = function() {
      return ToText2.isFullyConvertible(this.rrule);
    };
    ToText2.prototype.toString = function() {
      var gettext = this.gettext;
      if (!(this.options.freq in ToText2.IMPLEMENTED)) {
        return gettext("RRule error: Unable to fully convert this rrule to text");
      }
      this.text = [gettext("every")];
      this[RRule.FREQUENCIES[this.options.freq]]();
      if (this.options.until) {
        this.add(gettext("until"));
        var until = this.options.until;
        this.add(this.dateFormatter(until.getUTCFullYear(), this.language.monthNames[until.getUTCMonth()], until.getUTCDate()));
      } else if (this.options.count) {
        this.add(gettext("for")).add(this.options.count.toString()).add(this.plural(this.options.count) ? gettext("times") : gettext("time"));
      }
      if (!this.isFullyConvertible())
        this.add(gettext("(~ approximate)"));
      return this.text.join("");
    };
    ToText2.prototype.HOURLY = function() {
      var gettext = this.gettext;
      if (this.options.interval !== 1)
        this.add(this.options.interval.toString());
      this.add(this.plural(this.options.interval) ? gettext("hours") : gettext("hour"));
    };
    ToText2.prototype.MINUTELY = function() {
      var gettext = this.gettext;
      if (this.options.interval !== 1)
        this.add(this.options.interval.toString());
      this.add(this.plural(this.options.interval) ? gettext("minutes") : gettext("minute"));
    };
    ToText2.prototype.DAILY = function() {
      var gettext = this.gettext;
      if (this.options.interval !== 1)
        this.add(this.options.interval.toString());
      if (this.byweekday && this.byweekday.isWeekdays) {
        this.add(this.plural(this.options.interval) ? gettext("weekdays") : gettext("weekday"));
      } else {
        this.add(this.plural(this.options.interval) ? gettext("days") : gettext("day"));
      }
      if (this.origOptions.bymonth) {
        this.add(gettext("in"));
        this._bymonth();
      }
      if (this.bymonthday) {
        this._bymonthday();
      } else if (this.byweekday) {
        this._byweekday();
      } else if (this.origOptions.byhour) {
        this._byhour();
      }
    };
    ToText2.prototype.WEEKLY = function() {
      var gettext = this.gettext;
      if (this.options.interval !== 1) {
        this.add(this.options.interval.toString()).add(this.plural(this.options.interval) ? gettext("weeks") : gettext("week"));
      }
      if (this.byweekday && this.byweekday.isWeekdays) {
        if (this.options.interval === 1) {
          this.add(this.plural(this.options.interval) ? gettext("weekdays") : gettext("weekday"));
        } else {
          this.add(gettext("on")).add(gettext("weekdays"));
        }
      } else if (this.byweekday && this.byweekday.isEveryDay) {
        this.add(this.plural(this.options.interval) ? gettext("days") : gettext("day"));
      } else {
        if (this.options.interval === 1)
          this.add(gettext("week"));
        if (this.origOptions.bymonth) {
          this.add(gettext("in"));
          this._bymonth();
        }
        if (this.bymonthday) {
          this._bymonthday();
        } else if (this.byweekday) {
          this._byweekday();
        }
        if (this.origOptions.byhour) {
          this._byhour();
        }
      }
    };
    ToText2.prototype.MONTHLY = function() {
      var gettext = this.gettext;
      if (this.origOptions.bymonth) {
        if (this.options.interval !== 1) {
          this.add(this.options.interval.toString()).add(gettext("months"));
          if (this.plural(this.options.interval))
            this.add(gettext("in"));
        } else {
        }
        this._bymonth();
      } else {
        if (this.options.interval !== 1) {
          this.add(this.options.interval.toString());
        }
        this.add(this.plural(this.options.interval) ? gettext("months") : gettext("month"));
      }
      if (this.bymonthday) {
        this._bymonthday();
      } else if (this.byweekday && this.byweekday.isWeekdays) {
        this.add(gettext("on")).add(gettext("weekdays"));
      } else if (this.byweekday) {
        this._byweekday();
      }
    };
    ToText2.prototype.YEARLY = function() {
      var gettext = this.gettext;
      if (this.origOptions.bymonth) {
        if (this.options.interval !== 1) {
          this.add(this.options.interval.toString());
          this.add(gettext("years"));
        } else {
        }
        this._bymonth();
      } else {
        if (this.options.interval !== 1) {
          this.add(this.options.interval.toString());
        }
        this.add(this.plural(this.options.interval) ? gettext("years") : gettext("year"));
      }
      if (this.bymonthday) {
        this._bymonthday();
      } else if (this.byweekday) {
        this._byweekday();
      }
      if (this.options.byyearday) {
        this.add(gettext("on the")).add(this.list(this.options.byyearday, this.nth, gettext("and"))).add(gettext("day"));
      }
      if (this.options.byweekno) {
        this.add(gettext("in")).add(this.plural(this.options.byweekno.length) ? gettext("weeks") : gettext("week")).add(this.list(this.options.byweekno, void 0, gettext("and")));
      }
    };
    ToText2.prototype._bymonthday = function() {
      var gettext = this.gettext;
      if (this.byweekday && this.byweekday.allWeeks) {
        this.add(gettext("on")).add(this.list(this.byweekday.allWeeks, this.weekdaytext, gettext("or"))).add(gettext("the")).add(this.list(this.bymonthday, this.nth, gettext("or")));
      } else {
        this.add(gettext("on the")).add(this.list(this.bymonthday, this.nth, gettext("and")));
      }
    };
    ToText2.prototype._byweekday = function() {
      var gettext = this.gettext;
      if (this.byweekday.allWeeks && !this.byweekday.isWeekdays) {
        this.add(gettext("on")).add(this.list(this.byweekday.allWeeks, this.weekdaytext));
      }
      if (this.byweekday.someWeeks) {
        if (this.byweekday.allWeeks)
          this.add(gettext("and"));
        this.add(gettext("on the")).add(this.list(this.byweekday.someWeeks, this.weekdaytext, gettext("and")));
      }
    };
    ToText2.prototype._byhour = function() {
      var gettext = this.gettext;
      this.add(gettext("at")).add(this.list(this.origOptions.byhour, void 0, gettext("and")));
    };
    ToText2.prototype._bymonth = function() {
      this.add(this.list(this.options.bymonth, this.monthtext, this.gettext("and")));
    };
    ToText2.prototype.nth = function(n2) {
      n2 = parseInt(n2.toString(), 10);
      var nth;
      var gettext = this.gettext;
      if (n2 === -1)
        return gettext("last");
      var npos = Math.abs(n2);
      switch (npos) {
        case 1:
        case 21:
        case 31:
          nth = npos + gettext("st");
          break;
        case 2:
        case 22:
          nth = npos + gettext("nd");
          break;
        case 3:
        case 23:
          nth = npos + gettext("rd");
          break;
        default:
          nth = npos + gettext("th");
      }
      return n2 < 0 ? nth + " " + gettext("last") : nth;
    };
    ToText2.prototype.monthtext = function(m3) {
      return this.language.monthNames[m3 - 1];
    };
    ToText2.prototype.weekdaytext = function(wday) {
      var weekday = isNumber(wday) ? (wday + 1) % 7 : wday.getJsWeekday();
      return (wday.n ? this.nth(wday.n) + " " : "") + this.language.dayNames[weekday];
    };
    ToText2.prototype.plural = function(n2) {
      return n2 % 100 !== 1;
    };
    ToText2.prototype.add = function(s3) {
      this.text.push(" ");
      this.text.push(s3);
      return this;
    };
    ToText2.prototype.list = function(arr, callback, finalDelim, delim) {
      var _this = this;
      if (delim === void 0) {
        delim = ",";
      }
      if (!isArray(arr)) {
        arr = [arr];
      }
      var delimJoin = function(array, delimiter, finalDelimiter) {
        var list = "";
        for (var i3 = 0; i3 < array.length; i3++) {
          if (i3 !== 0) {
            if (i3 === array.length - 1) {
              list += " " + finalDelimiter + " ";
            } else {
              list += delimiter + " ";
            }
          }
          list += array[i3];
        }
        return list;
      };
      callback = callback || function(o2) {
        return o2.toString();
      };
      var realCallback = function(arg) {
        return callback && callback.call(_this, arg);
      };
      if (finalDelim) {
        return delimJoin(arr.map(realCallback), delim, finalDelim);
      } else {
        return arr.map(realCallback).join(delim + " ");
      }
    };
    return ToText2;
  }()
);
var totext_default = ToText;

// node_modules/rrule/dist/esm/nlp/parsetext.js
var Parser = (
  /** @class */
  function() {
    function Parser2(rules) {
      this.done = true;
      this.rules = rules;
    }
    Parser2.prototype.start = function(text) {
      this.text = text;
      this.done = false;
      return this.nextSymbol();
    };
    Parser2.prototype.isDone = function() {
      return this.done && this.symbol === null;
    };
    Parser2.prototype.nextSymbol = function() {
      var best;
      var bestSymbol;
      this.symbol = null;
      this.value = null;
      do {
        if (this.done)
          return false;
        var rule = void 0;
        best = null;
        for (var name_1 in this.rules) {
          rule = this.rules[name_1];
          var match = rule.exec(this.text);
          if (match) {
            if (best === null || match[0].length > best[0].length) {
              best = match;
              bestSymbol = name_1;
            }
          }
        }
        if (best != null) {
          this.text = this.text.substr(best[0].length);
          if (this.text === "")
            this.done = true;
        }
        if (best == null) {
          this.done = true;
          this.symbol = null;
          this.value = null;
          return;
        }
      } while (bestSymbol === "SKIP");
      this.symbol = bestSymbol;
      this.value = best;
      return true;
    };
    Parser2.prototype.accept = function(name) {
      if (this.symbol === name) {
        if (this.value) {
          var v3 = this.value;
          this.nextSymbol();
          return v3;
        }
        this.nextSymbol();
        return true;
      }
      return false;
    };
    Parser2.prototype.acceptNumber = function() {
      return this.accept("number");
    };
    Parser2.prototype.expect = function(name) {
      if (this.accept(name))
        return true;
      throw new Error("expected " + name + " but found " + this.symbol);
    };
    return Parser2;
  }()
);
function parseText(text, language) {
  if (language === void 0) {
    language = i18n_default;
  }
  var options = {};
  var ttr = new Parser(language.tokens);
  if (!ttr.start(text))
    return null;
  S2();
  return options;
  function S2() {
    ttr.expect("every");
    var n2 = ttr.acceptNumber();
    if (n2)
      options.interval = parseInt(n2[0], 10);
    if (ttr.isDone())
      throw new Error("Unexpected end");
    switch (ttr.symbol) {
      case "day(s)":
        options.freq = RRule.DAILY;
        if (ttr.nextSymbol()) {
          AT();
          F4();
        }
        break;
      case "weekday(s)":
        options.freq = RRule.WEEKLY;
        options.byweekday = [RRule.MO, RRule.TU, RRule.WE, RRule.TH, RRule.FR];
        ttr.nextSymbol();
        AT();
        F4();
        break;
      case "week(s)":
        options.freq = RRule.WEEKLY;
        if (ttr.nextSymbol()) {
          ON();
          AT();
          F4();
        }
        break;
      case "hour(s)":
        options.freq = RRule.HOURLY;
        if (ttr.nextSymbol()) {
          ON();
          F4();
        }
        break;
      case "minute(s)":
        options.freq = RRule.MINUTELY;
        if (ttr.nextSymbol()) {
          ON();
          F4();
        }
        break;
      case "month(s)":
        options.freq = RRule.MONTHLY;
        if (ttr.nextSymbol()) {
          ON();
          F4();
        }
        break;
      case "year(s)":
        options.freq = RRule.YEARLY;
        if (ttr.nextSymbol()) {
          ON();
          F4();
        }
        break;
      case "monday":
      case "tuesday":
      case "wednesday":
      case "thursday":
      case "friday":
      case "saturday":
      case "sunday":
        options.freq = RRule.WEEKLY;
        var key = ttr.symbol.substr(0, 2).toUpperCase();
        options.byweekday = [RRule[key]];
        if (!ttr.nextSymbol())
          return;
        while (ttr.accept("comma")) {
          if (ttr.isDone())
            throw new Error("Unexpected end");
          var wkd = decodeWKD();
          if (!wkd) {
            throw new Error("Unexpected symbol " + ttr.symbol + ", expected weekday");
          }
          options.byweekday.push(RRule[wkd]);
          ttr.nextSymbol();
        }
        AT();
        MDAYs();
        F4();
        break;
      case "january":
      case "february":
      case "march":
      case "april":
      case "may":
      case "june":
      case "july":
      case "august":
      case "september":
      case "october":
      case "november":
      case "december":
        options.freq = RRule.YEARLY;
        options.bymonth = [decodeM()];
        if (!ttr.nextSymbol())
          return;
        while (ttr.accept("comma")) {
          if (ttr.isDone())
            throw new Error("Unexpected end");
          var m3 = decodeM();
          if (!m3) {
            throw new Error("Unexpected symbol " + ttr.symbol + ", expected month");
          }
          options.bymonth.push(m3);
          ttr.nextSymbol();
        }
        ON();
        F4();
        break;
      default:
        throw new Error("Unknown symbol");
    }
  }
  function ON() {
    var on = ttr.accept("on");
    var the = ttr.accept("the");
    if (!(on || the))
      return;
    do {
      var nth = decodeNTH();
      var wkd = decodeWKD();
      var m3 = decodeM();
      if (nth) {
        if (wkd) {
          ttr.nextSymbol();
          if (!options.byweekday)
            options.byweekday = [];
          options.byweekday.push(RRule[wkd].nth(nth));
        } else {
          if (!options.bymonthday)
            options.bymonthday = [];
          options.bymonthday.push(nth);
          ttr.accept("day(s)");
        }
      } else if (wkd) {
        ttr.nextSymbol();
        if (!options.byweekday)
          options.byweekday = [];
        options.byweekday.push(RRule[wkd]);
      } else if (ttr.symbol === "weekday(s)") {
        ttr.nextSymbol();
        if (!options.byweekday) {
          options.byweekday = [RRule.MO, RRule.TU, RRule.WE, RRule.TH, RRule.FR];
        }
      } else if (ttr.symbol === "week(s)") {
        ttr.nextSymbol();
        var n2 = ttr.acceptNumber();
        if (!n2) {
          throw new Error("Unexpected symbol " + ttr.symbol + ", expected week number");
        }
        options.byweekno = [parseInt(n2[0], 10)];
        while (ttr.accept("comma")) {
          n2 = ttr.acceptNumber();
          if (!n2) {
            throw new Error("Unexpected symbol " + ttr.symbol + "; expected monthday");
          }
          options.byweekno.push(parseInt(n2[0], 10));
        }
      } else if (m3) {
        ttr.nextSymbol();
        if (!options.bymonth)
          options.bymonth = [];
        options.bymonth.push(m3);
      } else {
        return;
      }
    } while (ttr.accept("comma") || ttr.accept("the") || ttr.accept("on"));
  }
  function AT() {
    var at = ttr.accept("at");
    if (!at)
      return;
    do {
      var n2 = ttr.acceptNumber();
      if (!n2) {
        throw new Error("Unexpected symbol " + ttr.symbol + ", expected hour");
      }
      options.byhour = [parseInt(n2[0], 10)];
      while (ttr.accept("comma")) {
        n2 = ttr.acceptNumber();
        if (!n2) {
          throw new Error("Unexpected symbol " + ttr.symbol + "; expected hour");
        }
        options.byhour.push(parseInt(n2[0], 10));
      }
    } while (ttr.accept("comma") || ttr.accept("at"));
  }
  function decodeM() {
    switch (ttr.symbol) {
      case "january":
        return 1;
      case "february":
        return 2;
      case "march":
        return 3;
      case "april":
        return 4;
      case "may":
        return 5;
      case "june":
        return 6;
      case "july":
        return 7;
      case "august":
        return 8;
      case "september":
        return 9;
      case "october":
        return 10;
      case "november":
        return 11;
      case "december":
        return 12;
      default:
        return false;
    }
  }
  function decodeWKD() {
    switch (ttr.symbol) {
      case "monday":
      case "tuesday":
      case "wednesday":
      case "thursday":
      case "friday":
      case "saturday":
      case "sunday":
        return ttr.symbol.substr(0, 2).toUpperCase();
      default:
        return false;
    }
  }
  function decodeNTH() {
    switch (ttr.symbol) {
      case "last":
        ttr.nextSymbol();
        return -1;
      case "first":
        ttr.nextSymbol();
        return 1;
      case "second":
        ttr.nextSymbol();
        return ttr.accept("last") ? -2 : 2;
      case "third":
        ttr.nextSymbol();
        return ttr.accept("last") ? -3 : 3;
      case "nth":
        var v3 = parseInt(ttr.value[1], 10);
        if (v3 < -366 || v3 > 366)
          throw new Error("Nth out of range: " + v3);
        ttr.nextSymbol();
        return ttr.accept("last") ? -v3 : v3;
      default:
        return false;
    }
  }
  function MDAYs() {
    ttr.accept("on");
    ttr.accept("the");
    var nth = decodeNTH();
    if (!nth)
      return;
    options.bymonthday = [nth];
    ttr.nextSymbol();
    while (ttr.accept("comma")) {
      nth = decodeNTH();
      if (!nth) {
        throw new Error("Unexpected symbol " + ttr.symbol + "; expected monthday");
      }
      options.bymonthday.push(nth);
      ttr.nextSymbol();
    }
  }
  function F4() {
    if (ttr.symbol === "until") {
      var date = Date.parse(ttr.text);
      if (!date)
        throw new Error("Cannot parse until date:" + ttr.text);
      options.until = new Date(date);
    } else if (ttr.accept("for")) {
      options.count = parseInt(ttr.value[0], 10);
      ttr.expect("number");
    }
  }
}

// node_modules/rrule/dist/esm/types.js
var Frequency;
(function(Frequency2) {
  Frequency2[Frequency2["YEARLY"] = 0] = "YEARLY";
  Frequency2[Frequency2["MONTHLY"] = 1] = "MONTHLY";
  Frequency2[Frequency2["WEEKLY"] = 2] = "WEEKLY";
  Frequency2[Frequency2["DAILY"] = 3] = "DAILY";
  Frequency2[Frequency2["HOURLY"] = 4] = "HOURLY";
  Frequency2[Frequency2["MINUTELY"] = 5] = "MINUTELY";
  Frequency2[Frequency2["SECONDLY"] = 6] = "SECONDLY";
})(Frequency || (Frequency = {}));
function freqIsDailyOrGreater(freq) {
  return freq < Frequency.HOURLY;
}

// node_modules/rrule/dist/esm/nlp/index.js
var fromText = function(text, language) {
  if (language === void 0) {
    language = i18n_default;
  }
  return new RRule(parseText(text, language) || void 0);
};
var common = [
  "count",
  "until",
  "interval",
  "byweekday",
  "bymonthday",
  "bymonth"
];
totext_default.IMPLEMENTED = [];
totext_default.IMPLEMENTED[Frequency.HOURLY] = common;
totext_default.IMPLEMENTED[Frequency.MINUTELY] = common;
totext_default.IMPLEMENTED[Frequency.DAILY] = ["byhour"].concat(common);
totext_default.IMPLEMENTED[Frequency.WEEKLY] = common;
totext_default.IMPLEMENTED[Frequency.MONTHLY] = common;
totext_default.IMPLEMENTED[Frequency.YEARLY] = ["byweekno", "byyearday"].concat(common);
var toText = function(rrule, gettext, language, dateFormatter) {
  return new totext_default(rrule, gettext, language, dateFormatter).toString();
};
var isFullyConvertible = totext_default.isFullyConvertible;

// node_modules/rrule/dist/esm/datetime.js
var Time = (
  /** @class */
  function() {
    function Time2(hour, minute, second, millisecond) {
      this.hour = hour;
      this.minute = minute;
      this.second = second;
      this.millisecond = millisecond || 0;
    }
    Time2.prototype.getHours = function() {
      return this.hour;
    };
    Time2.prototype.getMinutes = function() {
      return this.minute;
    };
    Time2.prototype.getSeconds = function() {
      return this.second;
    };
    Time2.prototype.getMilliseconds = function() {
      return this.millisecond;
    };
    Time2.prototype.getTime = function() {
      return (this.hour * 60 * 60 + this.minute * 60 + this.second) * 1e3 + this.millisecond;
    };
    return Time2;
  }()
);
var DateTime = (
  /** @class */
  function(_super) {
    __extends(DateTime2, _super);
    function DateTime2(year, month, day, hour, minute, second, millisecond) {
      var _this = _super.call(this, hour, minute, second, millisecond) || this;
      _this.year = year;
      _this.month = month;
      _this.day = day;
      return _this;
    }
    DateTime2.fromDate = function(date) {
      return new this(date.getUTCFullYear(), date.getUTCMonth() + 1, date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.valueOf() % 1e3);
    };
    DateTime2.prototype.getWeekday = function() {
      return getWeekday(new Date(this.getTime()));
    };
    DateTime2.prototype.getTime = function() {
      return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond)).getTime();
    };
    DateTime2.prototype.getDay = function() {
      return this.day;
    };
    DateTime2.prototype.getMonth = function() {
      return this.month;
    };
    DateTime2.prototype.getYear = function() {
      return this.year;
    };
    DateTime2.prototype.addYears = function(years) {
      this.year += years;
    };
    DateTime2.prototype.addMonths = function(months) {
      this.month += months;
      if (this.month > 12) {
        var yearDiv = Math.floor(this.month / 12);
        var monthMod = pymod(this.month, 12);
        this.month = monthMod;
        this.year += yearDiv;
        if (this.month === 0) {
          this.month = 12;
          --this.year;
        }
      }
    };
    DateTime2.prototype.addWeekly = function(days, wkst) {
      if (wkst > this.getWeekday()) {
        this.day += -(this.getWeekday() + 1 + (6 - wkst)) + days * 7;
      } else {
        this.day += -(this.getWeekday() - wkst) + days * 7;
      }
      this.fixDay();
    };
    DateTime2.prototype.addDaily = function(days) {
      this.day += days;
      this.fixDay();
    };
    DateTime2.prototype.addHours = function(hours, filtered, byhour) {
      if (filtered) {
        this.hour += Math.floor((23 - this.hour) / hours) * hours;
      }
      for (; ; ) {
        this.hour += hours;
        var _a = divmod(this.hour, 24), dayDiv = _a.div, hourMod = _a.mod;
        if (dayDiv) {
          this.hour = hourMod;
          this.addDaily(dayDiv);
        }
        if (empty(byhour) || includes(byhour, this.hour))
          break;
      }
    };
    DateTime2.prototype.addMinutes = function(minutes, filtered, byhour, byminute) {
      if (filtered) {
        this.minute += Math.floor((1439 - (this.hour * 60 + this.minute)) / minutes) * minutes;
      }
      for (; ; ) {
        this.minute += minutes;
        var _a = divmod(this.minute, 60), hourDiv = _a.div, minuteMod = _a.mod;
        if (hourDiv) {
          this.minute = minuteMod;
          this.addHours(hourDiv, false, byhour);
        }
        if ((empty(byhour) || includes(byhour, this.hour)) && (empty(byminute) || includes(byminute, this.minute))) {
          break;
        }
      }
    };
    DateTime2.prototype.addSeconds = function(seconds, filtered, byhour, byminute, bysecond) {
      if (filtered) {
        this.second += Math.floor((86399 - (this.hour * 3600 + this.minute * 60 + this.second)) / seconds) * seconds;
      }
      for (; ; ) {
        this.second += seconds;
        var _a = divmod(this.second, 60), minuteDiv = _a.div, secondMod = _a.mod;
        if (minuteDiv) {
          this.second = secondMod;
          this.addMinutes(minuteDiv, false, byhour, byminute);
        }
        if ((empty(byhour) || includes(byhour, this.hour)) && (empty(byminute) || includes(byminute, this.minute)) && (empty(bysecond) || includes(bysecond, this.second))) {
          break;
        }
      }
    };
    DateTime2.prototype.fixDay = function() {
      if (this.day <= 28) {
        return;
      }
      var daysinmonth = monthRange(this.year, this.month - 1)[1];
      if (this.day <= daysinmonth) {
        return;
      }
      while (this.day > daysinmonth) {
        this.day -= daysinmonth;
        ++this.month;
        if (this.month === 13) {
          this.month = 1;
          ++this.year;
          if (this.year > MAXYEAR) {
            return;
          }
        }
        daysinmonth = monthRange(this.year, this.month - 1)[1];
      }
    };
    DateTime2.prototype.add = function(options, filtered) {
      var freq = options.freq, interval = options.interval, wkst = options.wkst, byhour = options.byhour, byminute = options.byminute, bysecond = options.bysecond;
      switch (freq) {
        case Frequency.YEARLY:
          return this.addYears(interval);
        case Frequency.MONTHLY:
          return this.addMonths(interval);
        case Frequency.WEEKLY:
          return this.addWeekly(interval, wkst);
        case Frequency.DAILY:
          return this.addDaily(interval);
        case Frequency.HOURLY:
          return this.addHours(interval, filtered, byhour);
        case Frequency.MINUTELY:
          return this.addMinutes(interval, filtered, byhour, byminute);
        case Frequency.SECONDLY:
          return this.addSeconds(interval, filtered, byhour, byminute, bysecond);
      }
    };
    return DateTime2;
  }(Time)
);

// node_modules/rrule/dist/esm/parseoptions.js
function initializeOptions(options) {
  var invalid = [];
  var keys = Object.keys(options);
  for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
    var key = keys_1[_i];
    if (!includes(defaultKeys, key))
      invalid.push(key);
    if (isDate(options[key]) && !isValidDate2(options[key])) {
      invalid.push(key);
    }
  }
  if (invalid.length) {
    throw new Error("Invalid options: " + invalid.join(", "));
  }
  return __assign({}, options);
}
function parseOptions(options) {
  var opts = __assign(__assign({}, DEFAULT_OPTIONS), initializeOptions(options));
  if (isPresent(opts.byeaster))
    opts.freq = RRule.YEARLY;
  if (!(isPresent(opts.freq) && RRule.FREQUENCIES[opts.freq])) {
    throw new Error("Invalid frequency: ".concat(opts.freq, " ").concat(options.freq));
  }
  if (!opts.dtstart)
    opts.dtstart = new Date(new Date().setMilliseconds(0));
  if (!isPresent(opts.wkst)) {
    opts.wkst = RRule.MO.weekday;
  } else if (isNumber(opts.wkst)) {
  } else {
    opts.wkst = opts.wkst.weekday;
  }
  if (isPresent(opts.bysetpos)) {
    if (isNumber(opts.bysetpos))
      opts.bysetpos = [opts.bysetpos];
    for (var i3 = 0; i3 < opts.bysetpos.length; i3++) {
      var v3 = opts.bysetpos[i3];
      if (v3 === 0 || !(v3 >= -366 && v3 <= 366)) {
        throw new Error("bysetpos must be between 1 and 366, or between -366 and -1");
      }
    }
  }
  if (!(Boolean(opts.byweekno) || notEmpty(opts.byweekno) || notEmpty(opts.byyearday) || Boolean(opts.bymonthday) || notEmpty(opts.bymonthday) || isPresent(opts.byweekday) || isPresent(opts.byeaster))) {
    switch (opts.freq) {
      case RRule.YEARLY:
        if (!opts.bymonth)
          opts.bymonth = opts.dtstart.getUTCMonth() + 1;
        opts.bymonthday = opts.dtstart.getUTCDate();
        break;
      case RRule.MONTHLY:
        opts.bymonthday = opts.dtstart.getUTCDate();
        break;
      case RRule.WEEKLY:
        opts.byweekday = [getWeekday(opts.dtstart)];
        break;
    }
  }
  if (isPresent(opts.bymonth) && !isArray(opts.bymonth)) {
    opts.bymonth = [opts.bymonth];
  }
  if (isPresent(opts.byyearday) && !isArray(opts.byyearday) && isNumber(opts.byyearday)) {
    opts.byyearday = [opts.byyearday];
  }
  if (!isPresent(opts.bymonthday)) {
    opts.bymonthday = [];
    opts.bynmonthday = [];
  } else if (isArray(opts.bymonthday)) {
    var bymonthday = [];
    var bynmonthday = [];
    for (var i3 = 0; i3 < opts.bymonthday.length; i3++) {
      var v3 = opts.bymonthday[i3];
      if (v3 > 0) {
        bymonthday.push(v3);
      } else if (v3 < 0) {
        bynmonthday.push(v3);
      }
    }
    opts.bymonthday = bymonthday;
    opts.bynmonthday = bynmonthday;
  } else if (opts.bymonthday < 0) {
    opts.bynmonthday = [opts.bymonthday];
    opts.bymonthday = [];
  } else {
    opts.bynmonthday = [];
    opts.bymonthday = [opts.bymonthday];
  }
  if (isPresent(opts.byweekno) && !isArray(opts.byweekno)) {
    opts.byweekno = [opts.byweekno];
  }
  if (!isPresent(opts.byweekday)) {
    opts.bynweekday = null;
  } else if (isNumber(opts.byweekday)) {
    opts.byweekday = [opts.byweekday];
    opts.bynweekday = null;
  } else if (isWeekdayStr(opts.byweekday)) {
    opts.byweekday = [Weekday.fromStr(opts.byweekday).weekday];
    opts.bynweekday = null;
  } else if (opts.byweekday instanceof Weekday) {
    if (!opts.byweekday.n || opts.freq > RRule.MONTHLY) {
      opts.byweekday = [opts.byweekday.weekday];
      opts.bynweekday = null;
    } else {
      opts.bynweekday = [[opts.byweekday.weekday, opts.byweekday.n]];
      opts.byweekday = null;
    }
  } else {
    var byweekday = [];
    var bynweekday = [];
    for (var i3 = 0; i3 < opts.byweekday.length; i3++) {
      var wday = opts.byweekday[i3];
      if (isNumber(wday)) {
        byweekday.push(wday);
        continue;
      } else if (isWeekdayStr(wday)) {
        byweekday.push(Weekday.fromStr(wday).weekday);
        continue;
      }
      if (!wday.n || opts.freq > RRule.MONTHLY) {
        byweekday.push(wday.weekday);
      } else {
        bynweekday.push([wday.weekday, wday.n]);
      }
    }
    opts.byweekday = notEmpty(byweekday) ? byweekday : null;
    opts.bynweekday = notEmpty(bynweekday) ? bynweekday : null;
  }
  if (!isPresent(opts.byhour)) {
    opts.byhour = opts.freq < RRule.HOURLY ? [opts.dtstart.getUTCHours()] : null;
  } else if (isNumber(opts.byhour)) {
    opts.byhour = [opts.byhour];
  }
  if (!isPresent(opts.byminute)) {
    opts.byminute = opts.freq < RRule.MINUTELY ? [opts.dtstart.getUTCMinutes()] : null;
  } else if (isNumber(opts.byminute)) {
    opts.byminute = [opts.byminute];
  }
  if (!isPresent(opts.bysecond)) {
    opts.bysecond = opts.freq < RRule.SECONDLY ? [opts.dtstart.getUTCSeconds()] : null;
  } else if (isNumber(opts.bysecond)) {
    opts.bysecond = [opts.bysecond];
  }
  return { parsedOptions: opts };
}
function buildTimeset(opts) {
  var millisecondModulo = opts.dtstart.getTime() % 1e3;
  if (!freqIsDailyOrGreater(opts.freq)) {
    return [];
  }
  var timeset = [];
  opts.byhour.forEach(function(hour) {
    opts.byminute.forEach(function(minute) {
      opts.bysecond.forEach(function(second) {
        timeset.push(new Time(hour, minute, second, millisecondModulo));
      });
    });
  });
  return timeset;
}

// node_modules/rrule/dist/esm/parsestring.js
function parseString2(rfcString) {
  var options = rfcString.split("\n").map(parseLine).filter(function(x4) {
    return x4 !== null;
  });
  return __assign(__assign({}, options[0]), options[1]);
}
function parseDtstart(line) {
  var options = {};
  var dtstartWithZone = /DTSTART(?:;TZID=([^:=]+?))?(?::|=)([^;\s]+)/i.exec(line);
  if (!dtstartWithZone) {
    return options;
  }
  var tzid = dtstartWithZone[1], dtstart = dtstartWithZone[2];
  if (tzid) {
    options.tzid = tzid;
  }
  options.dtstart = untilStringToDate(dtstart);
  return options;
}
function parseLine(rfcString) {
  rfcString = rfcString.replace(/^\s+|\s+$/, "");
  if (!rfcString.length)
    return null;
  var header = /^([A-Z]+?)[:;]/.exec(rfcString.toUpperCase());
  if (!header) {
    return parseRrule(rfcString);
  }
  var key = header[1];
  switch (key.toUpperCase()) {
    case "RRULE":
    case "EXRULE":
      return parseRrule(rfcString);
    case "DTSTART":
      return parseDtstart(rfcString);
    default:
      throw new Error("Unsupported RFC prop ".concat(key, " in ").concat(rfcString));
  }
}
function parseRrule(line) {
  var strippedLine = line.replace(/^RRULE:/i, "");
  var options = parseDtstart(strippedLine);
  var attrs = line.replace(/^(?:RRULE|EXRULE):/i, "").split(";");
  attrs.forEach(function(attr) {
    var _a = attr.split("="), key = _a[0], value = _a[1];
    switch (key.toUpperCase()) {
      case "FREQ":
        options.freq = Frequency[value.toUpperCase()];
        break;
      case "WKST":
        options.wkst = Days[value.toUpperCase()];
        break;
      case "COUNT":
      case "INTERVAL":
      case "BYSETPOS":
      case "BYMONTH":
      case "BYMONTHDAY":
      case "BYYEARDAY":
      case "BYWEEKNO":
      case "BYHOUR":
      case "BYMINUTE":
      case "BYSECOND":
        var num = parseNumber(value);
        var optionKey = key.toLowerCase();
        options[optionKey] = num;
        break;
      case "BYWEEKDAY":
      case "BYDAY":
        options.byweekday = parseWeekday(value);
        break;
      case "DTSTART":
      case "TZID":
        var dtstart = parseDtstart(line);
        options.tzid = dtstart.tzid;
        options.dtstart = dtstart.dtstart;
        break;
      case "UNTIL":
        options.until = untilStringToDate(value);
        break;
      case "BYEASTER":
        options.byeaster = Number(value);
        break;
      default:
        throw new Error("Unknown RRULE property '" + key + "'");
    }
  });
  return options;
}
function parseNumber(value) {
  if (value.indexOf(",") !== -1) {
    var values = value.split(",");
    return values.map(parseIndividualNumber);
  }
  return parseIndividualNumber(value);
}
function parseIndividualNumber(value) {
  if (/^[+-]?\d+$/.test(value)) {
    return Number(value);
  }
  return value;
}
function parseWeekday(value) {
  var days = value.split(",");
  return days.map(function(day) {
    if (day.length === 2) {
      return Days[day];
    }
    var parts = day.match(/^([+-]?\d{1,2})([A-Z]{2})$/);
    if (!parts || parts.length < 3) {
      throw new SyntaxError("Invalid weekday string: ".concat(day));
    }
    var n2 = Number(parts[1]);
    var wdaypart = parts[2];
    var wday = Days[wdaypart].weekday;
    return new Weekday(wday, n2);
  });
}

// node_modules/rrule/dist/esm/datewithzone.js
var DateWithZone = (
  /** @class */
  function() {
    function DateWithZone2(date, tzid) {
      if (isNaN(date.getTime())) {
        throw new RangeError("Invalid date passed to DateWithZone");
      }
      this.date = date;
      this.tzid = tzid;
    }
    Object.defineProperty(DateWithZone2.prototype, "isUTC", {
      get: function() {
        return !this.tzid || this.tzid.toUpperCase() === "UTC";
      },
      enumerable: false,
      configurable: true
    });
    DateWithZone2.prototype.toString = function() {
      var datestr = timeToUntilString(this.date.getTime(), this.isUTC);
      if (!this.isUTC) {
        return ";TZID=".concat(this.tzid, ":").concat(datestr);
      }
      return ":".concat(datestr);
    };
    DateWithZone2.prototype.getTime = function() {
      return this.date.getTime();
    };
    DateWithZone2.prototype.rezonedDate = function() {
      if (this.isUTC) {
        return this.date;
      }
      return dateInTimeZone(this.date, this.tzid);
    };
    return DateWithZone2;
  }()
);

// node_modules/rrule/dist/esm/optionstostring.js
function optionsToString(options) {
  var rrule = [];
  var dtstart = "";
  var keys = Object.keys(options);
  var defaultKeys2 = Object.keys(DEFAULT_OPTIONS);
  for (var i3 = 0; i3 < keys.length; i3++) {
    if (keys[i3] === "tzid")
      continue;
    if (!includes(defaultKeys2, keys[i3]))
      continue;
    var key = keys[i3].toUpperCase();
    var value = options[keys[i3]];
    var outValue = "";
    if (!isPresent(value) || isArray(value) && !value.length)
      continue;
    switch (key) {
      case "FREQ":
        outValue = RRule.FREQUENCIES[options.freq];
        break;
      case "WKST":
        if (isNumber(value)) {
          outValue = new Weekday(value).toString();
        } else {
          outValue = value.toString();
        }
        break;
      case "BYWEEKDAY":
        key = "BYDAY";
        outValue = toArray(value).map(function(wday) {
          if (wday instanceof Weekday) {
            return wday;
          }
          if (isArray(wday)) {
            return new Weekday(wday[0], wday[1]);
          }
          return new Weekday(wday);
        }).toString();
        break;
      case "DTSTART":
        dtstart = buildDtstart(value, options.tzid);
        break;
      case "UNTIL":
        outValue = timeToUntilString(value, !options.tzid);
        break;
      default:
        if (isArray(value)) {
          var strValues = [];
          for (var j4 = 0; j4 < value.length; j4++) {
            strValues[j4] = String(value[j4]);
          }
          outValue = strValues.toString();
        } else {
          outValue = String(value);
        }
    }
    if (outValue) {
      rrule.push([key, outValue]);
    }
  }
  var rules = rrule.map(function(_a) {
    var key2 = _a[0], value2 = _a[1];
    return "".concat(key2, "=").concat(value2.toString());
  }).join(";");
  var ruleString = "";
  if (rules !== "") {
    ruleString = "RRULE:".concat(rules);
  }
  return [dtstart, ruleString].filter(function(x4) {
    return !!x4;
  }).join("\n");
}
function buildDtstart(dtstart, tzid) {
  if (!dtstart) {
    return "";
  }
  return "DTSTART" + new DateWithZone(new Date(dtstart), tzid).toString();
}

// node_modules/rrule/dist/esm/cache.js
function argsMatch(left, right) {
  if (Array.isArray(left)) {
    if (!Array.isArray(right))
      return false;
    if (left.length !== right.length)
      return false;
    return left.every(function(date, i3) {
      return date.getTime() === right[i3].getTime();
    });
  }
  if (left instanceof Date) {
    return right instanceof Date && left.getTime() === right.getTime();
  }
  return left === right;
}
var Cache = (
  /** @class */
  function() {
    function Cache3() {
      this.all = false;
      this.before = [];
      this.after = [];
      this.between = [];
    }
    Cache3.prototype._cacheAdd = function(what, value, args) {
      if (value) {
        value = value instanceof Date ? clone(value) : cloneDates(value);
      }
      if (what === "all") {
        this.all = value;
      } else {
        args._value = value;
        this[what].push(args);
      }
    };
    Cache3.prototype._cacheGet = function(what, args) {
      var cached = false;
      var argsKeys = args ? Object.keys(args) : [];
      var findCacheDiff = function(item2) {
        for (var i4 = 0; i4 < argsKeys.length; i4++) {
          var key = argsKeys[i4];
          if (!argsMatch(args[key], item2[key])) {
            return true;
          }
        }
        return false;
      };
      var cachedObject = this[what];
      if (what === "all") {
        cached = this.all;
      } else if (isArray(cachedObject)) {
        for (var i3 = 0; i3 < cachedObject.length; i3++) {
          var item = cachedObject[i3];
          if (argsKeys.length && findCacheDiff(item))
            continue;
          cached = item._value;
          break;
        }
      }
      if (!cached && this.all) {
        var iterResult = new iterresult_default(what, args);
        for (var i3 = 0; i3 < this.all.length; i3++) {
          if (!iterResult.accept(this.all[i3]))
            break;
        }
        cached = iterResult.getValue();
        this._cacheAdd(what, cached, args);
      }
      return isArray(cached) ? cloneDates(cached) : cached instanceof Date ? clone(cached) : cached;
    };
    return Cache3;
  }()
);

// node_modules/rrule/dist/esm/masks.js
var M365MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], repeat(1, 31), true), repeat(2, 28), true), repeat(3, 31), true), repeat(4, 30), true), repeat(5, 31), true), repeat(6, 30), true), repeat(7, 31), true), repeat(8, 31), true), repeat(9, 30), true), repeat(10, 31), true), repeat(11, 30), true), repeat(12, 31), true), repeat(1, 7), true);
var M366MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], repeat(1, 31), true), repeat(2, 29), true), repeat(3, 31), true), repeat(4, 30), true), repeat(5, 31), true), repeat(6, 30), true), repeat(7, 31), true), repeat(8, 31), true), repeat(9, 30), true), repeat(10, 31), true), repeat(11, 30), true), repeat(12, 31), true), repeat(1, 7), true);
var M28 = range(1, 29);
var M29 = range(1, 30);
var M30 = range(1, 31);
var M31 = range(1, 32);
var MDAY366MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], M31, true), M29, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31.slice(0, 7), true);
var MDAY365MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], M31, true), M28, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31.slice(0, 7), true);
var NM28 = range(-28, 0);
var NM29 = range(-29, 0);
var NM30 = range(-30, 0);
var NM31 = range(-31, 0);
var NMDAY366MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], NM31, true), NM29, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31.slice(0, 7), true);
var NMDAY365MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], NM31, true), NM28, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31.slice(0, 7), true);
var M366RANGE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366];
var M365RANGE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365];
var WDAYMASK = function() {
  var wdaymask = [];
  for (var i3 = 0; i3 < 55; i3++)
    wdaymask = wdaymask.concat(range(7));
  return wdaymask;
}();

// node_modules/rrule/dist/esm/iterinfo/yearinfo.js
function rebuildYear(year, options) {
  var firstyday = datetime(year, 1, 1);
  var yearlen = isLeapYear(year) ? 366 : 365;
  var nextyearlen = isLeapYear(year + 1) ? 366 : 365;
  var yearordinal = toOrdinal(firstyday);
  var yearweekday = getWeekday(firstyday);
  var result = __assign(__assign({ yearlen, nextyearlen, yearordinal, yearweekday }, baseYearMasks(year)), { wnomask: null });
  if (empty(options.byweekno)) {
    return result;
  }
  result.wnomask = repeat(0, yearlen + 7);
  var firstwkst;
  var wyearlen;
  var no1wkst = firstwkst = pymod(7 - yearweekday + options.wkst, 7);
  if (no1wkst >= 4) {
    no1wkst = 0;
    wyearlen = result.yearlen + pymod(yearweekday - options.wkst, 7);
  } else {
    wyearlen = yearlen - no1wkst;
  }
  var div = Math.floor(wyearlen / 7);
  var mod = pymod(wyearlen, 7);
  var numweeks = Math.floor(div + mod / 4);
  for (var j4 = 0; j4 < options.byweekno.length; j4++) {
    var n2 = options.byweekno[j4];
    if (n2 < 0) {
      n2 += numweeks + 1;
    }
    if (!(n2 > 0 && n2 <= numweeks)) {
      continue;
    }
    var i3 = void 0;
    if (n2 > 1) {
      i3 = no1wkst + (n2 - 1) * 7;
      if (no1wkst !== firstwkst) {
        i3 -= 7 - firstwkst;
      }
    } else {
      i3 = no1wkst;
    }
    for (var k3 = 0; k3 < 7; k3++) {
      result.wnomask[i3] = 1;
      i3++;
      if (result.wdaymask[i3] === options.wkst)
        break;
    }
  }
  if (includes(options.byweekno, 1)) {
    var i3 = no1wkst + numweeks * 7;
    if (no1wkst !== firstwkst)
      i3 -= 7 - firstwkst;
    if (i3 < yearlen) {
      for (var j4 = 0; j4 < 7; j4++) {
        result.wnomask[i3] = 1;
        i3 += 1;
        if (result.wdaymask[i3] === options.wkst)
          break;
      }
    }
  }
  if (no1wkst) {
    var lnumweeks = void 0;
    if (!includes(options.byweekno, -1)) {
      var lyearweekday = getWeekday(datetime(year - 1, 1, 1));
      var lno1wkst = pymod(7 - lyearweekday.valueOf() + options.wkst, 7);
      var lyearlen = isLeapYear(year - 1) ? 366 : 365;
      var weekst = void 0;
      if (lno1wkst >= 4) {
        lno1wkst = 0;
        weekst = lyearlen + pymod(lyearweekday - options.wkst, 7);
      } else {
        weekst = yearlen - no1wkst;
      }
      lnumweeks = Math.floor(52 + pymod(weekst, 7) / 4);
    } else {
      lnumweeks = -1;
    }
    if (includes(options.byweekno, lnumweeks)) {
      for (var i3 = 0; i3 < no1wkst; i3++)
        result.wnomask[i3] = 1;
    }
  }
  return result;
}
function baseYearMasks(year) {
  var yearlen = isLeapYear(year) ? 366 : 365;
  var firstyday = datetime(year, 1, 1);
  var wday = getWeekday(firstyday);
  if (yearlen === 365) {
    return {
      mmask: M365MASK,
      mdaymask: MDAY365MASK,
      nmdaymask: NMDAY365MASK,
      wdaymask: WDAYMASK.slice(wday),
      mrange: M365RANGE
    };
  }
  return {
    mmask: M366MASK,
    mdaymask: MDAY366MASK,
    nmdaymask: NMDAY366MASK,
    wdaymask: WDAYMASK.slice(wday),
    mrange: M366RANGE
  };
}

// node_modules/rrule/dist/esm/iterinfo/monthinfo.js
function rebuildMonth(year, month, yearlen, mrange, wdaymask, options) {
  var result = {
    lastyear: year,
    lastmonth: month,
    nwdaymask: []
  };
  var ranges = [];
  if (options.freq === RRule.YEARLY) {
    if (empty(options.bymonth)) {
      ranges = [[0, yearlen]];
    } else {
      for (var j4 = 0; j4 < options.bymonth.length; j4++) {
        month = options.bymonth[j4];
        ranges.push(mrange.slice(month - 1, month + 1));
      }
    }
  } else if (options.freq === RRule.MONTHLY) {
    ranges = [mrange.slice(month - 1, month + 1)];
  }
  if (empty(ranges)) {
    return result;
  }
  result.nwdaymask = repeat(0, yearlen);
  for (var j4 = 0; j4 < ranges.length; j4++) {
    var rang = ranges[j4];
    var first = rang[0];
    var last = rang[1] - 1;
    for (var k3 = 0; k3 < options.bynweekday.length; k3++) {
      var i3 = void 0;
      var _a = options.bynweekday[k3], wday = _a[0], n2 = _a[1];
      if (n2 < 0) {
        i3 = last + (n2 + 1) * 7;
        i3 -= pymod(wdaymask[i3] - wday, 7);
      } else {
        i3 = first + (n2 - 1) * 7;
        i3 += pymod(7 - wdaymask[i3] + wday, 7);
      }
      if (first <= i3 && i3 <= last)
        result.nwdaymask[i3] = 1;
    }
  }
  return result;
}

// node_modules/rrule/dist/esm/iterinfo/easter.js
function easter(y3, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var a3 = y3 % 19;
  var b3 = Math.floor(y3 / 100);
  var c3 = y3 % 100;
  var d2 = Math.floor(b3 / 4);
  var e3 = b3 % 4;
  var f3 = Math.floor((b3 + 8) / 25);
  var g4 = Math.floor((b3 - f3 + 1) / 3);
  var h3 = Math.floor(19 * a3 + b3 - d2 - g4 + 15) % 30;
  var i3 = Math.floor(c3 / 4);
  var k3 = c3 % 4;
  var l3 = Math.floor(32 + 2 * e3 + 2 * i3 - h3 - k3) % 7;
  var m3 = Math.floor((a3 + 11 * h3 + 22 * l3) / 451);
  var month = Math.floor((h3 + l3 - 7 * m3 + 114) / 31);
  var day = (h3 + l3 - 7 * m3 + 114) % 31 + 1;
  var date = Date.UTC(y3, month - 1, day + offset);
  var yearStart = Date.UTC(y3, 0, 1);
  return [Math.ceil((date - yearStart) / (1e3 * 60 * 60 * 24))];
}

// node_modules/rrule/dist/esm/iterinfo/index.js
var Iterinfo = (
  /** @class */
  function() {
    function Iterinfo2(options) {
      this.options = options;
    }
    Iterinfo2.prototype.rebuild = function(year, month) {
      var options = this.options;
      if (year !== this.lastyear) {
        this.yearinfo = rebuildYear(year, options);
      }
      if (notEmpty(options.bynweekday) && (month !== this.lastmonth || year !== this.lastyear)) {
        var _a = this.yearinfo, yearlen = _a.yearlen, mrange = _a.mrange, wdaymask = _a.wdaymask;
        this.monthinfo = rebuildMonth(year, month, yearlen, mrange, wdaymask, options);
      }
      if (isPresent(options.byeaster)) {
        this.eastermask = easter(year, options.byeaster);
      }
    };
    Object.defineProperty(Iterinfo2.prototype, "lastyear", {
      get: function() {
        return this.monthinfo ? this.monthinfo.lastyear : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "lastmonth", {
      get: function() {
        return this.monthinfo ? this.monthinfo.lastmonth : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "yearlen", {
      get: function() {
        return this.yearinfo.yearlen;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "yearordinal", {
      get: function() {
        return this.yearinfo.yearordinal;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "mrange", {
      get: function() {
        return this.yearinfo.mrange;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "wdaymask", {
      get: function() {
        return this.yearinfo.wdaymask;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "mmask", {
      get: function() {
        return this.yearinfo.mmask;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "wnomask", {
      get: function() {
        return this.yearinfo.wnomask;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "nwdaymask", {
      get: function() {
        return this.monthinfo ? this.monthinfo.nwdaymask : [];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "nextyearlen", {
      get: function() {
        return this.yearinfo.nextyearlen;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "mdaymask", {
      get: function() {
        return this.yearinfo.mdaymask;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "nmdaymask", {
      get: function() {
        return this.yearinfo.nmdaymask;
      },
      enumerable: false,
      configurable: true
    });
    Iterinfo2.prototype.ydayset = function() {
      return [range(this.yearlen), 0, this.yearlen];
    };
    Iterinfo2.prototype.mdayset = function(_3, month) {
      var start = this.mrange[month - 1];
      var end = this.mrange[month];
      var set = repeat(null, this.yearlen);
      for (var i3 = start; i3 < end; i3++)
        set[i3] = i3;
      return [set, start, end];
    };
    Iterinfo2.prototype.wdayset = function(year, month, day) {
      var set = repeat(null, this.yearlen + 7);
      var i3 = toOrdinal(datetime(year, month, day)) - this.yearordinal;
      var start = i3;
      for (var j4 = 0; j4 < 7; j4++) {
        set[i3] = i3;
        ++i3;
        if (this.wdaymask[i3] === this.options.wkst)
          break;
      }
      return [set, start, i3];
    };
    Iterinfo2.prototype.ddayset = function(year, month, day) {
      var set = repeat(null, this.yearlen);
      var i3 = toOrdinal(datetime(year, month, day)) - this.yearordinal;
      set[i3] = i3;
      return [set, i3, i3 + 1];
    };
    Iterinfo2.prototype.htimeset = function(hour, _3, second, millisecond) {
      var _this = this;
      var set = [];
      this.options.byminute.forEach(function(minute) {
        set = set.concat(_this.mtimeset(hour, minute, second, millisecond));
      });
      sort(set);
      return set;
    };
    Iterinfo2.prototype.mtimeset = function(hour, minute, _3, millisecond) {
      var set = this.options.bysecond.map(function(second) {
        return new Time(hour, minute, second, millisecond);
      });
      sort(set);
      return set;
    };
    Iterinfo2.prototype.stimeset = function(hour, minute, second, millisecond) {
      return [new Time(hour, minute, second, millisecond)];
    };
    Iterinfo2.prototype.getdayset = function(freq) {
      switch (freq) {
        case Frequency.YEARLY:
          return this.ydayset.bind(this);
        case Frequency.MONTHLY:
          return this.mdayset.bind(this);
        case Frequency.WEEKLY:
          return this.wdayset.bind(this);
        case Frequency.DAILY:
          return this.ddayset.bind(this);
        default:
          return this.ddayset.bind(this);
      }
    };
    Iterinfo2.prototype.gettimeset = function(freq) {
      switch (freq) {
        case Frequency.HOURLY:
          return this.htimeset.bind(this);
        case Frequency.MINUTELY:
          return this.mtimeset.bind(this);
        case Frequency.SECONDLY:
          return this.stimeset.bind(this);
      }
    };
    return Iterinfo2;
  }()
);
var iterinfo_default = Iterinfo;

// node_modules/rrule/dist/esm/iter/poslist.js
function buildPoslist(bysetpos, timeset, start, end, ii, dayset) {
  var poslist = [];
  for (var j4 = 0; j4 < bysetpos.length; j4++) {
    var daypos = void 0;
    var timepos = void 0;
    var pos = bysetpos[j4];
    if (pos < 0) {
      daypos = Math.floor(pos / timeset.length);
      timepos = pymod(pos, timeset.length);
    } else {
      daypos = Math.floor((pos - 1) / timeset.length);
      timepos = pymod(pos - 1, timeset.length);
    }
    var tmp = [];
    for (var k3 = start; k3 < end; k3++) {
      var val = dayset[k3];
      if (!isPresent(val))
        continue;
      tmp.push(val);
    }
    var i3 = void 0;
    if (daypos < 0) {
      i3 = tmp.slice(daypos)[0];
    } else {
      i3 = tmp[daypos];
    }
    var time = timeset[timepos];
    var date = fromOrdinal(ii.yearordinal + i3);
    var res = combine(date, time);
    if (!includes(poslist, res))
      poslist.push(res);
  }
  sort(poslist);
  return poslist;
}

// node_modules/rrule/dist/esm/iter/index.js
function iter(iterResult, options) {
  var dtstart = options.dtstart, freq = options.freq, interval = options.interval, until = options.until, bysetpos = options.bysetpos;
  var count = options.count;
  if (count === 0 || interval === 0) {
    return emitResult(iterResult);
  }
  var counterDate = DateTime.fromDate(dtstart);
  var ii = new iterinfo_default(options);
  ii.rebuild(counterDate.year, counterDate.month);
  var timeset = makeTimeset(ii, counterDate, options);
  for (; ; ) {
    var _a = ii.getdayset(freq)(counterDate.year, counterDate.month, counterDate.day), dayset = _a[0], start = _a[1], end = _a[2];
    var filtered = removeFilteredDays(dayset, start, end, ii, options);
    if (notEmpty(bysetpos)) {
      var poslist = buildPoslist(bysetpos, timeset, start, end, ii, dayset);
      for (var j4 = 0; j4 < poslist.length; j4++) {
        var res = poslist[j4];
        if (until && res > until) {
          return emitResult(iterResult);
        }
        if (res >= dtstart) {
          var rezonedDate = rezoneIfNeeded(res, options);
          if (!iterResult.accept(rezonedDate)) {
            return emitResult(iterResult);
          }
          if (count) {
            --count;
            if (!count) {
              return emitResult(iterResult);
            }
          }
        }
      }
    } else {
      for (var j4 = start; j4 < end; j4++) {
        var currentDay = dayset[j4];
        if (!isPresent(currentDay)) {
          continue;
        }
        var date = fromOrdinal(ii.yearordinal + currentDay);
        for (var k3 = 0; k3 < timeset.length; k3++) {
          var time = timeset[k3];
          var res = combine(date, time);
          if (until && res > until) {
            return emitResult(iterResult);
          }
          if (res >= dtstart) {
            var rezonedDate = rezoneIfNeeded(res, options);
            if (!iterResult.accept(rezonedDate)) {
              return emitResult(iterResult);
            }
            if (count) {
              --count;
              if (!count) {
                return emitResult(iterResult);
              }
            }
          }
        }
      }
    }
    if (options.interval === 0) {
      return emitResult(iterResult);
    }
    counterDate.add(options, filtered);
    if (counterDate.year > MAXYEAR) {
      return emitResult(iterResult);
    }
    if (!freqIsDailyOrGreater(freq)) {
      timeset = ii.gettimeset(freq)(counterDate.hour, counterDate.minute, counterDate.second, 0);
    }
    ii.rebuild(counterDate.year, counterDate.month);
  }
}
function isFiltered(ii, currentDay, options) {
  var bymonth = options.bymonth, byweekno = options.byweekno, byweekday = options.byweekday, byeaster = options.byeaster, bymonthday = options.bymonthday, bynmonthday = options.bynmonthday, byyearday = options.byyearday;
  return notEmpty(bymonth) && !includes(bymonth, ii.mmask[currentDay]) || notEmpty(byweekno) && !ii.wnomask[currentDay] || notEmpty(byweekday) && !includes(byweekday, ii.wdaymask[currentDay]) || notEmpty(ii.nwdaymask) && !ii.nwdaymask[currentDay] || byeaster !== null && !includes(ii.eastermask, currentDay) || (notEmpty(bymonthday) || notEmpty(bynmonthday)) && !includes(bymonthday, ii.mdaymask[currentDay]) && !includes(bynmonthday, ii.nmdaymask[currentDay]) || notEmpty(byyearday) && (currentDay < ii.yearlen && !includes(byyearday, currentDay + 1) && !includes(byyearday, -ii.yearlen + currentDay) || currentDay >= ii.yearlen && !includes(byyearday, currentDay + 1 - ii.yearlen) && !includes(byyearday, -ii.nextyearlen + currentDay - ii.yearlen));
}
function rezoneIfNeeded(date, options) {
  return new DateWithZone(date, options.tzid).rezonedDate();
}
function emitResult(iterResult) {
  return iterResult.getValue();
}
function removeFilteredDays(dayset, start, end, ii, options) {
  var filtered = false;
  for (var dayCounter = start; dayCounter < end; dayCounter++) {
    var currentDay = dayset[dayCounter];
    filtered = isFiltered(ii, currentDay, options);
    if (filtered)
      dayset[currentDay] = null;
  }
  return filtered;
}
function makeTimeset(ii, counterDate, options) {
  var freq = options.freq, byhour = options.byhour, byminute = options.byminute, bysecond = options.bysecond;
  if (freqIsDailyOrGreater(freq)) {
    return buildTimeset(options);
  }
  if (freq >= RRule.HOURLY && notEmpty(byhour) && !includes(byhour, counterDate.hour) || freq >= RRule.MINUTELY && notEmpty(byminute) && !includes(byminute, counterDate.minute) || freq >= RRule.SECONDLY && notEmpty(bysecond) && !includes(bysecond, counterDate.second)) {
    return [];
  }
  return ii.gettimeset(freq)(counterDate.hour, counterDate.minute, counterDate.second, counterDate.millisecond);
}

// node_modules/rrule/dist/esm/rrule.js
var Days = {
  MO: new Weekday(0),
  TU: new Weekday(1),
  WE: new Weekday(2),
  TH: new Weekday(3),
  FR: new Weekday(4),
  SA: new Weekday(5),
  SU: new Weekday(6)
};
var DEFAULT_OPTIONS = {
  freq: Frequency.YEARLY,
  dtstart: null,
  interval: 1,
  wkst: Days.MO,
  count: null,
  until: null,
  tzid: null,
  bysetpos: null,
  bymonth: null,
  bymonthday: null,
  bynmonthday: null,
  byyearday: null,
  byweekno: null,
  byweekday: null,
  bynweekday: null,
  byhour: null,
  byminute: null,
  bysecond: null,
  byeaster: null
};
var defaultKeys = Object.keys(DEFAULT_OPTIONS);
var RRule = (
  /** @class */
  function() {
    function RRule2(options, noCache) {
      if (options === void 0) {
        options = {};
      }
      if (noCache === void 0) {
        noCache = false;
      }
      this._cache = noCache ? null : new Cache();
      this.origOptions = initializeOptions(options);
      var parsedOptions = parseOptions(options).parsedOptions;
      this.options = parsedOptions;
    }
    RRule2.parseText = function(text, language) {
      return parseText(text, language);
    };
    RRule2.fromText = function(text, language) {
      return fromText(text, language);
    };
    RRule2.fromString = function(str) {
      return new RRule2(RRule2.parseString(str) || void 0);
    };
    RRule2.prototype._iter = function(iterResult) {
      return iter(iterResult, this.options);
    };
    RRule2.prototype._cacheGet = function(what, args) {
      if (!this._cache)
        return false;
      return this._cache._cacheGet(what, args);
    };
    RRule2.prototype._cacheAdd = function(what, value, args) {
      if (!this._cache)
        return;
      return this._cache._cacheAdd(what, value, args);
    };
    RRule2.prototype.all = function(iterator) {
      if (iterator) {
        return this._iter(new callbackiterresult_default("all", {}, iterator));
      }
      var result = this._cacheGet("all");
      if (result === false) {
        result = this._iter(new iterresult_default("all", {}));
        this._cacheAdd("all", result);
      }
      return result;
    };
    RRule2.prototype.between = function(after, before, inc, iterator) {
      if (inc === void 0) {
        inc = false;
      }
      if (!isValidDate2(after) || !isValidDate2(before)) {
        throw new Error("Invalid date passed in to RRule.between");
      }
      var args = {
        before,
        after,
        inc
      };
      if (iterator) {
        return this._iter(new callbackiterresult_default("between", args, iterator));
      }
      var result = this._cacheGet("between", args);
      if (result === false) {
        result = this._iter(new iterresult_default("between", args));
        this._cacheAdd("between", result, args);
      }
      return result;
    };
    RRule2.prototype.before = function(dt, inc) {
      if (inc === void 0) {
        inc = false;
      }
      if (!isValidDate2(dt)) {
        throw new Error("Invalid date passed in to RRule.before");
      }
      var args = { dt, inc };
      var result = this._cacheGet("before", args);
      if (result === false) {
        result = this._iter(new iterresult_default("before", args));
        this._cacheAdd("before", result, args);
      }
      return result;
    };
    RRule2.prototype.after = function(dt, inc) {
      if (inc === void 0) {
        inc = false;
      }
      if (!isValidDate2(dt)) {
        throw new Error("Invalid date passed in to RRule.after");
      }
      var args = { dt, inc };
      var result = this._cacheGet("after", args);
      if (result === false) {
        result = this._iter(new iterresult_default("after", args));
        this._cacheAdd("after", result, args);
      }
      return result;
    };
    RRule2.prototype.count = function() {
      return this.all().length;
    };
    RRule2.prototype.toString = function() {
      return optionsToString(this.origOptions);
    };
    RRule2.prototype.toText = function(gettext, language, dateFormatter) {
      return toText(this, gettext, language, dateFormatter);
    };
    RRule2.prototype.isFullyConvertibleToText = function() {
      return isFullyConvertible(this);
    };
    RRule2.prototype.clone = function() {
      return new RRule2(this.origOptions);
    };
    RRule2.FREQUENCIES = [
      "YEARLY",
      "MONTHLY",
      "WEEKLY",
      "DAILY",
      "HOURLY",
      "MINUTELY",
      "SECONDLY"
    ];
    RRule2.YEARLY = Frequency.YEARLY;
    RRule2.MONTHLY = Frequency.MONTHLY;
    RRule2.WEEKLY = Frequency.WEEKLY;
    RRule2.DAILY = Frequency.DAILY;
    RRule2.HOURLY = Frequency.HOURLY;
    RRule2.MINUTELY = Frequency.MINUTELY;
    RRule2.SECONDLY = Frequency.SECONDLY;
    RRule2.MO = Days.MO;
    RRule2.TU = Days.TU;
    RRule2.WE = Days.WE;
    RRule2.TH = Days.TH;
    RRule2.FR = Days.FR;
    RRule2.SA = Days.SA;
    RRule2.SU = Days.SU;
    RRule2.parseString = parseString2;
    RRule2.optionsToString = optionsToString;
    return RRule2;
  }()
);

// node_modules/rrule/dist/esm/iterset.js
function iterSet(iterResult, _rrule, _exrule, _rdate, _exdate, tzid) {
  var _exdateHash = {};
  var _accept = iterResult.accept;
  function evalExdate(after, before) {
    _exrule.forEach(function(rrule) {
      rrule.between(after, before, true).forEach(function(date) {
        _exdateHash[Number(date)] = true;
      });
    });
  }
  _exdate.forEach(function(date) {
    var zonedDate2 = new DateWithZone(date, tzid).rezonedDate();
    _exdateHash[Number(zonedDate2)] = true;
  });
  iterResult.accept = function(date) {
    var dt = Number(date);
    if (isNaN(dt))
      return _accept.call(this, date);
    if (!_exdateHash[dt]) {
      evalExdate(new Date(dt - 1), new Date(dt + 1));
      if (!_exdateHash[dt]) {
        _exdateHash[dt] = true;
        return _accept.call(this, date);
      }
    }
    return true;
  };
  if (iterResult.method === "between") {
    evalExdate(iterResult.args.after, iterResult.args.before);
    iterResult.accept = function(date) {
      var dt = Number(date);
      if (!_exdateHash[dt]) {
        _exdateHash[dt] = true;
        return _accept.call(this, date);
      }
      return true;
    };
  }
  for (var i3 = 0; i3 < _rdate.length; i3++) {
    var zonedDate = new DateWithZone(_rdate[i3], tzid).rezonedDate();
    if (!iterResult.accept(new Date(zonedDate.getTime())))
      break;
  }
  _rrule.forEach(function(rrule) {
    iter(iterResult, rrule.options);
  });
  var res = iterResult._result;
  sort(res);
  switch (iterResult.method) {
    case "all":
    case "between":
      return res;
    case "before":
      return res.length && res[res.length - 1] || null;
    case "after":
    default:
      return res.length && res[0] || null;
  }
}

// node_modules/rrule/dist/esm/rrulestr.js
var DEFAULT_OPTIONS2 = {
  dtstart: null,
  cache: false,
  unfold: false,
  forceset: false,
  compatible: false,
  tzid: null
};
function parseInput(s3, options) {
  var rrulevals = [];
  var rdatevals = [];
  var exrulevals = [];
  var exdatevals = [];
  var parsedDtstart = parseDtstart(s3);
  var dtstart = parsedDtstart.dtstart;
  var tzid = parsedDtstart.tzid;
  var lines = splitIntoLines(s3, options.unfold);
  lines.forEach(function(line) {
    var _a;
    if (!line)
      return;
    var _b = breakDownLine(line), name = _b.name, parms = _b.parms, value = _b.value;
    switch (name.toUpperCase()) {
      case "RRULE":
        if (parms.length) {
          throw new Error("unsupported RRULE parm: ".concat(parms.join(",")));
        }
        rrulevals.push(parseString2(line));
        break;
      case "RDATE":
        var _c = (_a = /RDATE(?:;TZID=([^:=]+))?/i.exec(line)) !== null && _a !== void 0 ? _a : [], rdateTzid = _c[1];
        if (rdateTzid && !tzid) {
          tzid = rdateTzid;
        }
        rdatevals = rdatevals.concat(parseRDate(value, parms));
        break;
      case "EXRULE":
        if (parms.length) {
          throw new Error("unsupported EXRULE parm: ".concat(parms.join(",")));
        }
        exrulevals.push(parseString2(value));
        break;
      case "EXDATE":
        exdatevals = exdatevals.concat(parseRDate(value, parms));
        break;
      case "DTSTART":
        break;
      default:
        throw new Error("unsupported property: " + name);
    }
  });
  return {
    dtstart,
    tzid,
    rrulevals,
    rdatevals,
    exrulevals,
    exdatevals
  };
}
function buildRule(s3, options) {
  var _a = parseInput(s3, options), rrulevals = _a.rrulevals, rdatevals = _a.rdatevals, exrulevals = _a.exrulevals, exdatevals = _a.exdatevals, dtstart = _a.dtstart, tzid = _a.tzid;
  var noCache = options.cache === false;
  if (options.compatible) {
    options.forceset = true;
    options.unfold = true;
  }
  if (options.forceset || rrulevals.length > 1 || rdatevals.length || exrulevals.length || exdatevals.length) {
    var rset_1 = new RRuleSet(noCache);
    rset_1.dtstart(dtstart);
    rset_1.tzid(tzid || void 0);
    rrulevals.forEach(function(val2) {
      rset_1.rrule(new RRule(groomRruleOptions(val2, dtstart, tzid), noCache));
    });
    rdatevals.forEach(function(date) {
      rset_1.rdate(date);
    });
    exrulevals.forEach(function(val2) {
      rset_1.exrule(new RRule(groomRruleOptions(val2, dtstart, tzid), noCache));
    });
    exdatevals.forEach(function(date) {
      rset_1.exdate(date);
    });
    if (options.compatible && options.dtstart)
      rset_1.rdate(dtstart);
    return rset_1;
  }
  var val = rrulevals[0] || {};
  return new RRule(groomRruleOptions(val, val.dtstart || options.dtstart || dtstart, val.tzid || options.tzid || tzid), noCache);
}
function rrulestr(s3, options) {
  if (options === void 0) {
    options = {};
  }
  return buildRule(s3, initializeOptions2(options));
}
function groomRruleOptions(val, dtstart, tzid) {
  return __assign(__assign({}, val), { dtstart, tzid });
}
function initializeOptions2(options) {
  var invalid = [];
  var keys = Object.keys(options);
  var defaultKeys2 = Object.keys(DEFAULT_OPTIONS2);
  keys.forEach(function(key) {
    if (!includes(defaultKeys2, key))
      invalid.push(key);
  });
  if (invalid.length) {
    throw new Error("Invalid options: " + invalid.join(", "));
  }
  return __assign(__assign({}, DEFAULT_OPTIONS2), options);
}
function extractName(line) {
  if (line.indexOf(":") === -1) {
    return {
      name: "RRULE",
      value: line
    };
  }
  var _a = split(line, ":", 1), name = _a[0], value = _a[1];
  return {
    name,
    value
  };
}
function breakDownLine(line) {
  var _a = extractName(line), name = _a.name, value = _a.value;
  var parms = name.split(";");
  if (!parms)
    throw new Error("empty property name");
  return {
    name: parms[0].toUpperCase(),
    parms: parms.slice(1),
    value
  };
}
function splitIntoLines(s3, unfold) {
  if (unfold === void 0) {
    unfold = false;
  }
  s3 = s3 && s3.trim();
  if (!s3)
    throw new Error("Invalid empty string");
  if (!unfold) {
    return s3.split(/\s/);
  }
  var lines = s3.split("\n");
  var i3 = 0;
  while (i3 < lines.length) {
    var line = lines[i3] = lines[i3].replace(/\s+$/g, "");
    if (!line) {
      lines.splice(i3, 1);
    } else if (i3 > 0 && line[0] === " ") {
      lines[i3 - 1] += line.slice(1);
      lines.splice(i3, 1);
    } else {
      i3 += 1;
    }
  }
  return lines;
}
function validateDateParm(parms) {
  parms.forEach(function(parm) {
    if (!/(VALUE=DATE(-TIME)?)|(TZID=)/.test(parm)) {
      throw new Error("unsupported RDATE/EXDATE parm: " + parm);
    }
  });
}
function parseRDate(rdateval, parms) {
  validateDateParm(parms);
  return rdateval.split(",").map(function(datestr) {
    return untilStringToDate(datestr);
  });
}

// node_modules/rrule/dist/esm/rruleset.js
function createGetterSetter(fieldName) {
  var _this = this;
  return function(field) {
    if (field !== void 0) {
      _this["_".concat(fieldName)] = field;
    }
    if (_this["_".concat(fieldName)] !== void 0) {
      return _this["_".concat(fieldName)];
    }
    for (var i3 = 0; i3 < _this._rrule.length; i3++) {
      var field_1 = _this._rrule[i3].origOptions[fieldName];
      if (field_1) {
        return field_1;
      }
    }
  };
}
var RRuleSet = (
  /** @class */
  function(_super) {
    __extends(RRuleSet2, _super);
    function RRuleSet2(noCache) {
      if (noCache === void 0) {
        noCache = false;
      }
      var _this = _super.call(this, {}, noCache) || this;
      _this.dtstart = createGetterSetter.apply(_this, ["dtstart"]);
      _this.tzid = createGetterSetter.apply(_this, ["tzid"]);
      _this._rrule = [];
      _this._rdate = [];
      _this._exrule = [];
      _this._exdate = [];
      return _this;
    }
    RRuleSet2.prototype._iter = function(iterResult) {
      return iterSet(iterResult, this._rrule, this._exrule, this._rdate, this._exdate, this.tzid());
    };
    RRuleSet2.prototype.rrule = function(rrule) {
      _addRule(rrule, this._rrule);
    };
    RRuleSet2.prototype.exrule = function(rrule) {
      _addRule(rrule, this._exrule);
    };
    RRuleSet2.prototype.rdate = function(date) {
      _addDate(date, this._rdate);
    };
    RRuleSet2.prototype.exdate = function(date) {
      _addDate(date, this._exdate);
    };
    RRuleSet2.prototype.rrules = function() {
      return this._rrule.map(function(e3) {
        return rrulestr(e3.toString());
      });
    };
    RRuleSet2.prototype.exrules = function() {
      return this._exrule.map(function(e3) {
        return rrulestr(e3.toString());
      });
    };
    RRuleSet2.prototype.rdates = function() {
      return this._rdate.map(function(e3) {
        return new Date(e3.getTime());
      });
    };
    RRuleSet2.prototype.exdates = function() {
      return this._exdate.map(function(e3) {
        return new Date(e3.getTime());
      });
    };
    RRuleSet2.prototype.valueOf = function() {
      var result = [];
      if (!this._rrule.length && this._dtstart) {
        result = result.concat(optionsToString({ dtstart: this._dtstart }));
      }
      this._rrule.forEach(function(rrule) {
        result = result.concat(rrule.toString().split("\n"));
      });
      this._exrule.forEach(function(exrule) {
        result = result.concat(exrule.toString().split("\n").map(function(line) {
          return line.replace(/^RRULE:/, "EXRULE:");
        }).filter(function(line) {
          return !/^DTSTART/.test(line);
        }));
      });
      if (this._rdate.length) {
        result.push(rdatesToString("RDATE", this._rdate, this.tzid()));
      }
      if (this._exdate.length) {
        result.push(rdatesToString("EXDATE", this._exdate, this.tzid()));
      }
      return result;
    };
    RRuleSet2.prototype.toString = function() {
      return this.valueOf().join("\n");
    };
    RRuleSet2.prototype.clone = function() {
      var rrs = new RRuleSet2(!!this._cache);
      this._rrule.forEach(function(rule) {
        return rrs.rrule(rule.clone());
      });
      this._exrule.forEach(function(rule) {
        return rrs.exrule(rule.clone());
      });
      this._rdate.forEach(function(date) {
        return rrs.rdate(new Date(date.getTime()));
      });
      this._exdate.forEach(function(date) {
        return rrs.exdate(new Date(date.getTime()));
      });
      return rrs;
    };
    return RRuleSet2;
  }(RRule)
);
function _addRule(rrule, collection) {
  if (!(rrule instanceof RRule)) {
    throw new TypeError(String(rrule) + " is not RRule instance");
  }
  if (!includes(collection.map(String), String(rrule))) {
    collection.push(rrule);
  }
}
function _addDate(date, collection) {
  if (!(date instanceof Date)) {
    throw new TypeError(String(date) + " is not Date instance");
  }
  if (!includes(collection.map(Number), Number(date))) {
    collection.push(date);
    sort(collection);
  }
}
function rdatesToString(param, rdates, tzid) {
  var isUTC = !tzid || tzid.toUpperCase() === "UTC";
  var header = isUTC ? "".concat(param, ":") : "".concat(param, ";TZID=").concat(tzid, ":");
  var dateString = rdates.map(function(rdate) {
    return timeToUntilString(rdate.valueOf(), isUTC);
  }).join(",");
  return "".concat(header).concat(dateString);
}

// node_modules/@fullcalendar/rrule/index.js
var recurringType = {
  parse(eventProps, dateEnv) {
    if (eventProps.rrule != null) {
      let eventRRuleData = parseEventRRule(eventProps, dateEnv);
      if (eventRRuleData) {
        return {
          typeData: { rruleSet: eventRRuleData.rruleSet, isTimeZoneSpecified: eventRRuleData.isTimeZoneSpecified },
          allDayGuess: !eventRRuleData.isTimeSpecified,
          duration: eventProps.duration
        };
      }
    }
    return null;
  },
  expand(eventRRuleData, framingRange, dateEnv) {
    let dates;
    if (eventRRuleData.isTimeZoneSpecified) {
      dates = eventRRuleData.rruleSet.between(
        dateEnv.toDate(framingRange.start),
        // rrule lib will treat as UTC-zoned
        dateEnv.toDate(framingRange.end),
        // (same)
        true
      ).map((date) => dateEnv.createMarker(date));
    } else {
      dates = eventRRuleData.rruleSet.between(framingRange.start, framingRange.end, true);
    }
    return dates;
  }
};
function parseEventRRule(eventProps, dateEnv) {
  let rruleSet;
  let isTimeSpecified = false;
  let isTimeZoneSpecified = false;
  if (typeof eventProps.rrule === "string") {
    let res = parseRRuleString(eventProps.rrule);
    rruleSet = res.rruleSet;
    isTimeSpecified = res.isTimeSpecified;
    isTimeZoneSpecified = res.isTimeZoneSpecified;
  }
  if (typeof eventProps.rrule === "object" && eventProps.rrule) {
    let res = parseRRuleObject(eventProps.rrule, dateEnv);
    rruleSet = new RRuleSet();
    rruleSet.rrule(res.rrule);
    isTimeSpecified = res.isTimeSpecified;
    isTimeZoneSpecified = res.isTimeZoneSpecified;
  }
  let exdateInputs = [].concat(eventProps.exdate || []);
  let exruleInputs = [].concat(eventProps.exrule || []);
  for (let exdateInput of exdateInputs) {
    let res = parse(exdateInput);
    isTimeSpecified = isTimeSpecified || !res.isTimeUnspecified;
    isTimeZoneSpecified = isTimeZoneSpecified || res.timeZoneOffset !== null;
    rruleSet.exdate(new Date(res.marker.valueOf() - (res.timeZoneOffset || 0) * 60 * 1e3));
  }
  for (let exruleInput of exruleInputs) {
    let res = parseRRuleObject(exruleInput, dateEnv);
    isTimeSpecified = isTimeSpecified || res.isTimeSpecified;
    isTimeZoneSpecified = isTimeZoneSpecified || res.isTimeZoneSpecified;
    rruleSet.exrule(res.rrule);
  }
  return { rruleSet, isTimeSpecified, isTimeZoneSpecified };
}
function parseRRuleObject(rruleInput, dateEnv) {
  let isTimeSpecified = false;
  let isTimeZoneSpecified = false;
  function processDateInput(dateInput) {
    if (typeof dateInput === "string") {
      let markerData = parse(dateInput);
      if (markerData) {
        isTimeSpecified = isTimeSpecified || !markerData.isTimeUnspecified;
        isTimeZoneSpecified = isTimeZoneSpecified || markerData.timeZoneOffset !== null;
        return new Date(markerData.marker.valueOf() - (markerData.timeZoneOffset || 0) * 60 * 1e3);
      }
      return null;
    }
    return dateInput;
  }
  let rruleOptions = Object.assign(Object.assign({}, rruleInput), { dtstart: processDateInput(rruleInput.dtstart), until: processDateInput(rruleInput.until), freq: convertConstant(rruleInput.freq), wkst: rruleInput.wkst == null ? (dateEnv.weekDow - 1 + 7) % 7 : convertConstant(rruleInput.wkst), byweekday: convertConstants(rruleInput.byweekday) });
  return { rrule: new RRule(rruleOptions), isTimeSpecified, isTimeZoneSpecified };
}
function parseRRuleString(str) {
  let rruleSet = rrulestr(str, { forceset: true });
  let analysis = analyzeRRuleString(str);
  return Object.assign({ rruleSet }, analysis);
}
function analyzeRRuleString(str) {
  let isTimeSpecified = false;
  let isTimeZoneSpecified = false;
  function processMatch(whole, introPart, datePart) {
    let result = parse(datePart);
    isTimeSpecified = isTimeSpecified || !result.isTimeUnspecified;
    isTimeZoneSpecified = isTimeZoneSpecified || result.timeZoneOffset !== null;
  }
  str.replace(/\b(DTSTART:)([^\n]*)/, processMatch);
  str.replace(/\b(EXDATE:)([^\n]*)/, processMatch);
  str.replace(/\b(UNTIL=)([^;\n]*)/, processMatch);
  return { isTimeSpecified, isTimeZoneSpecified };
}
function convertConstants(input) {
  if (Array.isArray(input)) {
    return input.map(convertConstant);
  }
  return convertConstant(input);
}
function convertConstant(input) {
  if (typeof input === "string") {
    return RRule[input.toUpperCase()];
  }
  return input;
}
var RRULE_EVENT_REFINERS = {
  rrule: identity,
  exrule: identity,
  exdate: identity,
  duration: createDuration
};
var index3 = createPlugin({
  name: "@fullcalendar/rrule",
  recurringTypes: [recurringType],
  eventRefiners: RRULE_EVENT_REFINERS
});

// node_modules/@fullcalendar/list/internal.js
var ListViewHeaderRow = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.state = {
      textId: getUniqueDomId()
    };
  }
  render() {
    let { theme, dateEnv, options, viewApi } = this.context;
    let { cellId, dayDate, todayRange } = this.props;
    let { textId } = this.state;
    let dayMeta = getDateMeta(dayDate, todayRange);
    let text = options.listDayFormat ? dateEnv.format(dayDate, options.listDayFormat) : "";
    let sideText = options.listDaySideFormat ? dateEnv.format(dayDate, options.listDaySideFormat) : "";
    let renderProps = Object.assign({
      date: dateEnv.toDate(dayDate),
      view: viewApi,
      textId,
      text,
      sideText,
      navLinkAttrs: buildNavLinkAttrs(this.context, dayDate),
      sideNavLinkAttrs: buildNavLinkAttrs(this.context, dayDate, "day", false)
    }, dayMeta);
    return y(ContentContainer, { elTag: "tr", elClasses: [
      "fc-list-day",
      ...getDayClassNames(dayMeta, theme)
    ], elAttrs: {
      "data-date": formatDayString(dayDate)
    }, renderProps, generatorName: "dayHeaderContent", customGenerator: options.dayHeaderContent, defaultGenerator: renderInnerContent4, classNameGenerator: options.dayHeaderClassNames, didMount: options.dayHeaderDidMount, willUnmount: options.dayHeaderWillUnmount }, (InnerContent) => (
      // TODO: force-hide top border based on :first-child
      y(
        "th",
        { scope: "colgroup", colSpan: 3, id: cellId, "aria-labelledby": textId },
        y(InnerContent, { elTag: "div", elClasses: [
          "fc-list-day-cushion",
          theme.getClass("tableCellShaded")
        ] })
      )
    ));
  }
};
function renderInnerContent4(props) {
  return y(
    _,
    null,
    props.text && y("a", Object.assign({ id: props.textId, className: "fc-list-day-text" }, props.navLinkAttrs), props.text),
    props.sideText && /* not keyboard tabbable */
    y("a", Object.assign({ "aria-hidden": true, className: "fc-list-day-side-text" }, props.sideNavLinkAttrs), props.sideText)
  );
}
var DEFAULT_TIME_FORMAT2 = createFormatter({
  hour: "numeric",
  minute: "2-digit",
  meridiem: "short"
});
var ListViewEventRow = class extends BaseComponent {
  render() {
    let { props, context } = this;
    let { options } = context;
    let { seg, timeHeaderId, eventHeaderId, dateHeaderId } = props;
    let timeFormat = options.eventTimeFormat || DEFAULT_TIME_FORMAT2;
    return y(EventContainer, Object.assign({}, props, { elTag: "tr", elClasses: [
      "fc-list-event",
      seg.eventRange.def.url && "fc-event-forced-url"
    ], defaultGenerator: () => renderEventInnerContent(seg, context), seg, timeText: "", disableDragging: true, disableResizing: true }), (InnerContent, eventContentArg) => y(
      _,
      null,
      buildTimeContent(seg, timeFormat, context, timeHeaderId, dateHeaderId),
      y(
        "td",
        { "aria-hidden": true, className: "fc-list-event-graphic" },
        y("span", { className: "fc-list-event-dot", style: {
          borderColor: eventContentArg.borderColor || eventContentArg.backgroundColor
        } })
      ),
      y(InnerContent, { elTag: "td", elClasses: ["fc-list-event-title"], elAttrs: { headers: `${eventHeaderId} ${dateHeaderId}` } })
    ));
  }
};
function renderEventInnerContent(seg, context) {
  let interactiveAttrs = getSegAnchorAttrs(seg, context);
  return y("a", Object.assign({}, interactiveAttrs), seg.eventRange.def.title);
}
function buildTimeContent(seg, timeFormat, context, timeHeaderId, dateHeaderId) {
  let { options } = context;
  if (options.displayEventTime !== false) {
    let eventDef = seg.eventRange.def;
    let eventInstance = seg.eventRange.instance;
    let doAllDay = false;
    let timeText;
    if (eventDef.allDay) {
      doAllDay = true;
    } else if (isMultiDayRange(seg.eventRange.range)) {
      if (seg.isStart) {
        timeText = buildSegTimeText(seg, timeFormat, context, null, null, eventInstance.range.start, seg.end);
      } else if (seg.isEnd) {
        timeText = buildSegTimeText(seg, timeFormat, context, null, null, seg.start, eventInstance.range.end);
      } else {
        doAllDay = true;
      }
    } else {
      timeText = buildSegTimeText(seg, timeFormat, context);
    }
    if (doAllDay) {
      let renderProps = {
        text: context.options.allDayText,
        view: context.viewApi
      };
      return y(ContentContainer, { elTag: "td", elClasses: ["fc-list-event-time"], elAttrs: {
        headers: `${timeHeaderId} ${dateHeaderId}`
      }, renderProps, generatorName: "allDayContent", customGenerator: options.allDayContent, defaultGenerator: renderAllDayInner2, classNameGenerator: options.allDayClassNames, didMount: options.allDayDidMount, willUnmount: options.allDayWillUnmount });
    }
    return y("td", { className: "fc-list-event-time" }, timeText);
  }
  return null;
}
function renderAllDayInner2(renderProps) {
  return renderProps.text;
}
var ListView = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.computeDateVars = memoize(computeDateVars);
    this.eventStoreToSegs = memoize(this._eventStoreToSegs);
    this.state = {
      timeHeaderId: getUniqueDomId(),
      eventHeaderId: getUniqueDomId(),
      dateHeaderIdRoot: getUniqueDomId()
    };
    this.setRootEl = (rootEl) => {
      if (rootEl) {
        this.context.registerInteractiveComponent(this, {
          el: rootEl
        });
      } else {
        this.context.unregisterInteractiveComponent(this);
      }
    };
  }
  render() {
    let { props, context } = this;
    let { dayDates, dayRanges } = this.computeDateVars(props.dateProfile);
    let eventSegs = this.eventStoreToSegs(props.eventStore, props.eventUiBases, dayRanges);
    return y(
      ViewContainer,
      { elRef: this.setRootEl, elClasses: [
        "fc-list",
        context.theme.getClass("table"),
        context.options.stickyHeaderDates !== false ? "fc-list-sticky" : ""
      ], viewSpec: context.viewSpec },
      y(Scroller, { liquid: !props.isHeightAuto, overflowX: props.isHeightAuto ? "visible" : "hidden", overflowY: props.isHeightAuto ? "visible" : "auto" }, eventSegs.length > 0 ? this.renderSegList(eventSegs, dayDates) : this.renderEmptyMessage())
    );
  }
  renderEmptyMessage() {
    let { options, viewApi } = this.context;
    let renderProps = {
      text: options.noEventsText,
      view: viewApi
    };
    return y(ContentContainer, { elTag: "div", elClasses: ["fc-list-empty"], renderProps, generatorName: "noEventsContent", customGenerator: options.noEventsContent, defaultGenerator: renderNoEventsInner, classNameGenerator: options.noEventsClassNames, didMount: options.noEventsDidMount, willUnmount: options.noEventsWillUnmount }, (InnerContent) => y(InnerContent, { elTag: "div", elClasses: ["fc-list-empty-cushion"] }));
  }
  renderSegList(allSegs, dayDates) {
    let { theme, options } = this.context;
    let { timeHeaderId, eventHeaderId, dateHeaderIdRoot } = this.state;
    let segsByDay = groupSegsByDay(allSegs);
    return y(NowTimer, { unit: "day" }, (nowDate, todayRange) => {
      let innerNodes = [];
      for (let dayIndex = 0; dayIndex < segsByDay.length; dayIndex += 1) {
        let daySegs = segsByDay[dayIndex];
        if (daySegs) {
          let dayStr = formatDayString(dayDates[dayIndex]);
          let dateHeaderId = dateHeaderIdRoot + "-" + dayStr;
          innerNodes.push(y(ListViewHeaderRow, { key: dayStr, cellId: dateHeaderId, dayDate: dayDates[dayIndex], todayRange }));
          daySegs = sortEventSegs(daySegs, options.eventOrder);
          for (let seg of daySegs) {
            innerNodes.push(y(ListViewEventRow, Object.assign({ key: dayStr + ":" + seg.eventRange.instance.instanceId, seg, isDragging: false, isResizing: false, isDateSelecting: false, isSelected: false, timeHeaderId, eventHeaderId, dateHeaderId }, getSegMeta(seg, todayRange, nowDate))));
          }
        }
      }
      return y(
        "table",
        { className: "fc-list-table " + theme.getClass("table") },
        y(
          "thead",
          null,
          y(
            "tr",
            null,
            y("th", { scope: "col", id: timeHeaderId }, options.timeHint),
            y("th", { scope: "col", "aria-hidden": true }),
            y("th", { scope: "col", id: eventHeaderId }, options.eventHint)
          )
        ),
        y("tbody", null, innerNodes)
      );
    });
  }
  _eventStoreToSegs(eventStore, eventUiBases, dayRanges) {
    return this.eventRangesToSegs(sliceEventStore(eventStore, eventUiBases, this.props.dateProfile.activeRange, this.context.options.nextDayThreshold).fg, dayRanges);
  }
  eventRangesToSegs(eventRanges, dayRanges) {
    let segs = [];
    for (let eventRange of eventRanges) {
      segs.push(...this.eventRangeToSegs(eventRange, dayRanges));
    }
    return segs;
  }
  eventRangeToSegs(eventRange, dayRanges) {
    let { dateEnv } = this.context;
    let { nextDayThreshold } = this.context.options;
    let range2 = eventRange.range;
    let allDay = eventRange.def.allDay;
    let dayIndex;
    let segRange;
    let seg;
    let segs = [];
    for (dayIndex = 0; dayIndex < dayRanges.length; dayIndex += 1) {
      segRange = intersectRanges(range2, dayRanges[dayIndex]);
      if (segRange) {
        seg = {
          component: this,
          eventRange,
          start: segRange.start,
          end: segRange.end,
          isStart: eventRange.isStart && segRange.start.valueOf() === range2.start.valueOf(),
          isEnd: eventRange.isEnd && segRange.end.valueOf() === range2.end.valueOf(),
          dayIndex
        };
        segs.push(seg);
        if (!seg.isEnd && !allDay && dayIndex + 1 < dayRanges.length && range2.end < dateEnv.add(dayRanges[dayIndex + 1].start, nextDayThreshold)) {
          seg.end = range2.end;
          seg.isEnd = true;
          break;
        }
      }
    }
    return segs;
  }
};
function renderNoEventsInner(renderProps) {
  return renderProps.text;
}
function computeDateVars(dateProfile) {
  let dayStart = startOfDay(dateProfile.renderRange.start);
  let viewEnd = dateProfile.renderRange.end;
  let dayDates = [];
  let dayRanges = [];
  while (dayStart < viewEnd) {
    dayDates.push(dayStart);
    dayRanges.push({
      start: dayStart,
      end: addDays(dayStart, 1)
    });
    dayStart = addDays(dayStart, 1);
  }
  return { dayDates, dayRanges };
}
function groupSegsByDay(segs) {
  let segsByDay = [];
  let i3;
  let seg;
  for (i3 = 0; i3 < segs.length; i3 += 1) {
    seg = segs[i3];
    (segsByDay[seg.dayIndex] || (segsByDay[seg.dayIndex] = [])).push(seg);
  }
  return segsByDay;
}
var css_248z4 = ':root{--fc-list-event-dot-width:10px;--fc-list-event-hover-bg-color:#f5f5f5}.fc-theme-standard .fc-list{border:1px solid var(--fc-border-color)}.fc .fc-list-empty{align-items:center;background-color:var(--fc-neutral-bg-color);display:flex;height:100%;justify-content:center}.fc .fc-list-empty-cushion{margin:5em 0}.fc .fc-list-table{border-style:hidden;width:100%}.fc .fc-list-table tr>*{border-left:0;border-right:0}.fc .fc-list-sticky .fc-list-day>*{background:var(--fc-page-bg-color);position:sticky;top:0}.fc .fc-list-table thead{left:-10000px;position:absolute}.fc .fc-list-table tbody>tr:first-child th{border-top:0}.fc .fc-list-table th{padding:0}.fc .fc-list-day-cushion,.fc .fc-list-table td{padding:8px 14px}.fc .fc-list-day-cushion:after{clear:both;content:"";display:table}.fc-theme-standard .fc-list-day-cushion{background-color:var(--fc-neutral-bg-color)}.fc-direction-ltr .fc-list-day-text,.fc-direction-rtl .fc-list-day-side-text{float:left}.fc-direction-ltr .fc-list-day-side-text,.fc-direction-rtl .fc-list-day-text{float:right}.fc-direction-ltr .fc-list-table .fc-list-event-graphic{padding-right:0}.fc-direction-rtl .fc-list-table .fc-list-event-graphic{padding-left:0}.fc .fc-list-event.fc-event-forced-url{cursor:pointer}.fc .fc-list-event:hover td{background-color:var(--fc-list-event-hover-bg-color)}.fc .fc-list-event-graphic,.fc .fc-list-event-time{white-space:nowrap;width:1px}.fc .fc-list-event-dot{border:calc(var(--fc-list-event-dot-width)/2) solid var(--fc-event-border-color);border-radius:calc(var(--fc-list-event-dot-width)/2);box-sizing:content-box;display:inline-block;height:0;width:0}.fc .fc-list-event-title a{color:inherit;text-decoration:none}.fc .fc-list-event.fc-event-forced-url:hover a{text-decoration:underline}';
injectStyles(css_248z4);

// node_modules/@fullcalendar/list/index.js
var OPTION_REFINERS2 = {
  listDayFormat: createFalsableFormatter,
  listDaySideFormat: createFalsableFormatter,
  noEventsClassNames: identity,
  noEventsContent: identity,
  noEventsDidMount: identity,
  noEventsWillUnmount: identity
  // noEventsText is defined in base options
};
function createFalsableFormatter(input) {
  return input === false ? null : createFormatter(input);
}
var index4 = createPlugin({
  name: "@fullcalendar/list",
  optionRefiners: OPTION_REFINERS2,
  views: {
    list: {
      component: ListView,
      buttonTextKey: "list",
      listDayFormat: { month: "long", day: "numeric", year: "numeric" }
      // like "January 1, 2016"
    },
    listDay: {
      type: "list",
      duration: { days: 1 },
      listDayFormat: { weekday: "long" }
      // day-of-week is all we need. full date is probably in headerToolbar
    },
    listWeek: {
      type: "list",
      duration: { weeks: 1 },
      listDayFormat: { weekday: "long" },
      listDaySideFormat: { month: "long", day: "numeric", year: "numeric" }
    },
    listMonth: {
      type: "list",
      duration: { month: 1 },
      listDaySideFormat: { weekday: "long" }
      // day-of-week is nice-to-have
    },
    listYear: {
      type: "list",
      duration: { year: 1 },
      listDaySideFormat: { weekday: "long" }
      // day-of-week is nice-to-have
    }
  }
});

// node_modules/@fullcalendar/interaction/index.js
config.touchMouseIgnoreWait = 500;
var ignoreMouseDepth = 0;
var listenerCnt = 0;
var isWindowTouchMoveCancelled = false;
var PointerDragging = class {
  constructor(containerEl) {
    this.subjectEl = null;
    this.selector = "";
    this.handleSelector = "";
    this.shouldIgnoreMove = false;
    this.shouldWatchScroll = true;
    this.isDragging = false;
    this.isTouchDragging = false;
    this.wasTouchScroll = false;
    this.handleMouseDown = (ev) => {
      if (!this.shouldIgnoreMouse() && isPrimaryMouseButton(ev) && this.tryStart(ev)) {
        let pev = this.createEventFromMouse(ev, true);
        this.emitter.trigger("pointerdown", pev);
        this.initScrollWatch(pev);
        if (!this.shouldIgnoreMove) {
          document.addEventListener("mousemove", this.handleMouseMove);
        }
        document.addEventListener("mouseup", this.handleMouseUp);
      }
    };
    this.handleMouseMove = (ev) => {
      let pev = this.createEventFromMouse(ev);
      this.recordCoords(pev);
      this.emitter.trigger("pointermove", pev);
    };
    this.handleMouseUp = (ev) => {
      document.removeEventListener("mousemove", this.handleMouseMove);
      document.removeEventListener("mouseup", this.handleMouseUp);
      this.emitter.trigger("pointerup", this.createEventFromMouse(ev));
      this.cleanup();
    };
    this.handleTouchStart = (ev) => {
      if (this.tryStart(ev)) {
        this.isTouchDragging = true;
        let pev = this.createEventFromTouch(ev, true);
        this.emitter.trigger("pointerdown", pev);
        this.initScrollWatch(pev);
        let targetEl = ev.target;
        if (!this.shouldIgnoreMove) {
          targetEl.addEventListener("touchmove", this.handleTouchMove);
        }
        targetEl.addEventListener("touchend", this.handleTouchEnd);
        targetEl.addEventListener("touchcancel", this.handleTouchEnd);
        window.addEventListener("scroll", this.handleTouchScroll, true);
      }
    };
    this.handleTouchMove = (ev) => {
      let pev = this.createEventFromTouch(ev);
      this.recordCoords(pev);
      this.emitter.trigger("pointermove", pev);
    };
    this.handleTouchEnd = (ev) => {
      if (this.isDragging) {
        let targetEl = ev.target;
        targetEl.removeEventListener("touchmove", this.handleTouchMove);
        targetEl.removeEventListener("touchend", this.handleTouchEnd);
        targetEl.removeEventListener("touchcancel", this.handleTouchEnd);
        window.removeEventListener("scroll", this.handleTouchScroll, true);
        this.emitter.trigger("pointerup", this.createEventFromTouch(ev));
        this.cleanup();
        this.isTouchDragging = false;
        startIgnoringMouse();
      }
    };
    this.handleTouchScroll = () => {
      this.wasTouchScroll = true;
    };
    this.handleScroll = (ev) => {
      if (!this.shouldIgnoreMove) {
        let pageX = window.scrollX - this.prevScrollX + this.prevPageX;
        let pageY = window.scrollY - this.prevScrollY + this.prevPageY;
        this.emitter.trigger("pointermove", {
          origEvent: ev,
          isTouch: this.isTouchDragging,
          subjectEl: this.subjectEl,
          pageX,
          pageY,
          deltaX: pageX - this.origPageX,
          deltaY: pageY - this.origPageY
        });
      }
    };
    this.containerEl = containerEl;
    this.emitter = new Emitter();
    containerEl.addEventListener("mousedown", this.handleMouseDown);
    containerEl.addEventListener("touchstart", this.handleTouchStart, { passive: true });
    listenerCreated();
  }
  destroy() {
    this.containerEl.removeEventListener("mousedown", this.handleMouseDown);
    this.containerEl.removeEventListener("touchstart", this.handleTouchStart, { passive: true });
    listenerDestroyed();
  }
  tryStart(ev) {
    let subjectEl = this.querySubjectEl(ev);
    let downEl = ev.target;
    if (subjectEl && (!this.handleSelector || elementClosest(downEl, this.handleSelector))) {
      this.subjectEl = subjectEl;
      this.isDragging = true;
      this.wasTouchScroll = false;
      return true;
    }
    return false;
  }
  cleanup() {
    isWindowTouchMoveCancelled = false;
    this.isDragging = false;
    this.subjectEl = null;
    this.destroyScrollWatch();
  }
  querySubjectEl(ev) {
    if (this.selector) {
      return elementClosest(ev.target, this.selector);
    }
    return this.containerEl;
  }
  shouldIgnoreMouse() {
    return ignoreMouseDepth || this.isTouchDragging;
  }
  // can be called by user of this class, to cancel touch-based scrolling for the current drag
  cancelTouchScroll() {
    if (this.isDragging) {
      isWindowTouchMoveCancelled = true;
    }
  }
  // Scrolling that simulates pointermoves
  // ----------------------------------------------------------------------------------------------------
  initScrollWatch(ev) {
    if (this.shouldWatchScroll) {
      this.recordCoords(ev);
      window.addEventListener("scroll", this.handleScroll, true);
    }
  }
  recordCoords(ev) {
    if (this.shouldWatchScroll) {
      this.prevPageX = ev.pageX;
      this.prevPageY = ev.pageY;
      this.prevScrollX = window.scrollX;
      this.prevScrollY = window.scrollY;
    }
  }
  destroyScrollWatch() {
    if (this.shouldWatchScroll) {
      window.removeEventListener("scroll", this.handleScroll, true);
    }
  }
  // Event Normalization
  // ----------------------------------------------------------------------------------------------------
  createEventFromMouse(ev, isFirst) {
    let deltaX = 0;
    let deltaY = 0;
    if (isFirst) {
      this.origPageX = ev.pageX;
      this.origPageY = ev.pageY;
    } else {
      deltaX = ev.pageX - this.origPageX;
      deltaY = ev.pageY - this.origPageY;
    }
    return {
      origEvent: ev,
      isTouch: false,
      subjectEl: this.subjectEl,
      pageX: ev.pageX,
      pageY: ev.pageY,
      deltaX,
      deltaY
    };
  }
  createEventFromTouch(ev, isFirst) {
    let touches = ev.touches;
    let pageX;
    let pageY;
    let deltaX = 0;
    let deltaY = 0;
    if (touches && touches.length) {
      pageX = touches[0].pageX;
      pageY = touches[0].pageY;
    } else {
      pageX = ev.pageX;
      pageY = ev.pageY;
    }
    if (isFirst) {
      this.origPageX = pageX;
      this.origPageY = pageY;
    } else {
      deltaX = pageX - this.origPageX;
      deltaY = pageY - this.origPageY;
    }
    return {
      origEvent: ev,
      isTouch: true,
      subjectEl: this.subjectEl,
      pageX,
      pageY,
      deltaX,
      deltaY
    };
  }
};
function isPrimaryMouseButton(ev) {
  return ev.button === 0 && !ev.ctrlKey;
}
function startIgnoringMouse() {
  ignoreMouseDepth += 1;
  setTimeout(() => {
    ignoreMouseDepth -= 1;
  }, config.touchMouseIgnoreWait);
}
function listenerCreated() {
  listenerCnt += 1;
  if (listenerCnt === 1) {
    window.addEventListener("touchmove", onWindowTouchMove, { passive: false });
  }
}
function listenerDestroyed() {
  listenerCnt -= 1;
  if (!listenerCnt) {
    window.removeEventListener("touchmove", onWindowTouchMove, { passive: false });
  }
}
function onWindowTouchMove(ev) {
  if (isWindowTouchMoveCancelled) {
    ev.preventDefault();
  }
}
var ElementMirror = class {
  constructor() {
    this.isVisible = false;
    this.sourceEl = null;
    this.mirrorEl = null;
    this.sourceElRect = null;
    this.parentNode = document.body;
    this.zIndex = 9999;
    this.revertDuration = 0;
  }
  start(sourceEl, pageX, pageY) {
    this.sourceEl = sourceEl;
    this.sourceElRect = this.sourceEl.getBoundingClientRect();
    this.origScreenX = pageX - window.scrollX;
    this.origScreenY = pageY - window.scrollY;
    this.deltaX = 0;
    this.deltaY = 0;
    this.updateElPosition();
  }
  handleMove(pageX, pageY) {
    this.deltaX = pageX - window.scrollX - this.origScreenX;
    this.deltaY = pageY - window.scrollY - this.origScreenY;
    this.updateElPosition();
  }
  // can be called before start
  setIsVisible(bool) {
    if (bool) {
      if (!this.isVisible) {
        if (this.mirrorEl) {
          this.mirrorEl.style.display = "";
        }
        this.isVisible = bool;
        this.updateElPosition();
      }
    } else if (this.isVisible) {
      if (this.mirrorEl) {
        this.mirrorEl.style.display = "none";
      }
      this.isVisible = bool;
    }
  }
  // always async
  stop(needsRevertAnimation, callback) {
    let done = () => {
      this.cleanup();
      callback();
    };
    if (needsRevertAnimation && this.mirrorEl && this.isVisible && this.revertDuration && // if 0, transition won't work
    (this.deltaX || this.deltaY)) {
      this.doRevertAnimation(done, this.revertDuration);
    } else {
      setTimeout(done, 0);
    }
  }
  doRevertAnimation(callback, revertDuration) {
    let mirrorEl = this.mirrorEl;
    let finalSourceElRect = this.sourceEl.getBoundingClientRect();
    mirrorEl.style.transition = "top " + revertDuration + "ms,left " + revertDuration + "ms";
    applyStyle(mirrorEl, {
      left: finalSourceElRect.left,
      top: finalSourceElRect.top
    });
    whenTransitionDone(mirrorEl, () => {
      mirrorEl.style.transition = "";
      callback();
    });
  }
  cleanup() {
    if (this.mirrorEl) {
      removeElement(this.mirrorEl);
      this.mirrorEl = null;
    }
    this.sourceEl = null;
  }
  updateElPosition() {
    if (this.sourceEl && this.isVisible) {
      applyStyle(this.getMirrorEl(), {
        left: this.sourceElRect.left + this.deltaX,
        top: this.sourceElRect.top + this.deltaY
      });
    }
  }
  getMirrorEl() {
    let sourceElRect = this.sourceElRect;
    let mirrorEl = this.mirrorEl;
    if (!mirrorEl) {
      mirrorEl = this.mirrorEl = this.sourceEl.cloneNode(true);
      mirrorEl.style.userSelect = "none";
      mirrorEl.style.webkitUserSelect = "none";
      mirrorEl.style.pointerEvents = "none";
      mirrorEl.classList.add("fc-event-dragging");
      applyStyle(mirrorEl, {
        position: "fixed",
        zIndex: this.zIndex,
        visibility: "",
        boxSizing: "border-box",
        width: sourceElRect.right - sourceElRect.left,
        height: sourceElRect.bottom - sourceElRect.top,
        right: "auto",
        bottom: "auto",
        margin: 0
      });
      this.parentNode.appendChild(mirrorEl);
    }
    return mirrorEl;
  }
};
var ScrollGeomCache = class extends ScrollController {
  constructor(scrollController, doesListening) {
    super();
    this.handleScroll = () => {
      this.scrollTop = this.scrollController.getScrollTop();
      this.scrollLeft = this.scrollController.getScrollLeft();
      this.handleScrollChange();
    };
    this.scrollController = scrollController;
    this.doesListening = doesListening;
    this.scrollTop = this.origScrollTop = scrollController.getScrollTop();
    this.scrollLeft = this.origScrollLeft = scrollController.getScrollLeft();
    this.scrollWidth = scrollController.getScrollWidth();
    this.scrollHeight = scrollController.getScrollHeight();
    this.clientWidth = scrollController.getClientWidth();
    this.clientHeight = scrollController.getClientHeight();
    this.clientRect = this.computeClientRect();
    if (this.doesListening) {
      this.getEventTarget().addEventListener("scroll", this.handleScroll);
    }
  }
  destroy() {
    if (this.doesListening) {
      this.getEventTarget().removeEventListener("scroll", this.handleScroll);
    }
  }
  getScrollTop() {
    return this.scrollTop;
  }
  getScrollLeft() {
    return this.scrollLeft;
  }
  setScrollTop(top) {
    this.scrollController.setScrollTop(top);
    if (!this.doesListening) {
      this.scrollTop = Math.max(Math.min(top, this.getMaxScrollTop()), 0);
      this.handleScrollChange();
    }
  }
  setScrollLeft(top) {
    this.scrollController.setScrollLeft(top);
    if (!this.doesListening) {
      this.scrollLeft = Math.max(Math.min(top, this.getMaxScrollLeft()), 0);
      this.handleScrollChange();
    }
  }
  getClientWidth() {
    return this.clientWidth;
  }
  getClientHeight() {
    return this.clientHeight;
  }
  getScrollWidth() {
    return this.scrollWidth;
  }
  getScrollHeight() {
    return this.scrollHeight;
  }
  handleScrollChange() {
  }
};
var ElementScrollGeomCache = class extends ScrollGeomCache {
  constructor(el, doesListening) {
    super(new ElementScrollController(el), doesListening);
  }
  getEventTarget() {
    return this.scrollController.el;
  }
  computeClientRect() {
    return computeInnerRect(this.scrollController.el);
  }
};
var WindowScrollGeomCache = class extends ScrollGeomCache {
  constructor(doesListening) {
    super(new WindowScrollController(), doesListening);
  }
  getEventTarget() {
    return window;
  }
  computeClientRect() {
    return {
      left: this.scrollLeft,
      right: this.scrollLeft + this.clientWidth,
      top: this.scrollTop,
      bottom: this.scrollTop + this.clientHeight
    };
  }
  // the window is the only scroll object that changes it's rectangle relative
  // to the document's topleft as it scrolls
  handleScrollChange() {
    this.clientRect = this.computeClientRect();
  }
};
var getTime = typeof performance === "function" ? performance.now : Date.now;
var AutoScroller = class {
  constructor() {
    this.isEnabled = true;
    this.scrollQuery = [window, ".fc-scroller"];
    this.edgeThreshold = 50;
    this.maxVelocity = 300;
    this.pointerScreenX = null;
    this.pointerScreenY = null;
    this.isAnimating = false;
    this.scrollCaches = null;
    this.everMovedUp = false;
    this.everMovedDown = false;
    this.everMovedLeft = false;
    this.everMovedRight = false;
    this.animate = () => {
      if (this.isAnimating) {
        let edge = this.computeBestEdge(this.pointerScreenX + window.scrollX, this.pointerScreenY + window.scrollY);
        if (edge) {
          let now = getTime();
          this.handleSide(edge, (now - this.msSinceRequest) / 1e3);
          this.requestAnimation(now);
        } else {
          this.isAnimating = false;
        }
      }
    };
  }
  start(pageX, pageY, scrollStartEl) {
    if (this.isEnabled) {
      this.scrollCaches = this.buildCaches(scrollStartEl);
      this.pointerScreenX = null;
      this.pointerScreenY = null;
      this.everMovedUp = false;
      this.everMovedDown = false;
      this.everMovedLeft = false;
      this.everMovedRight = false;
      this.handleMove(pageX, pageY);
    }
  }
  handleMove(pageX, pageY) {
    if (this.isEnabled) {
      let pointerScreenX = pageX - window.scrollX;
      let pointerScreenY = pageY - window.scrollY;
      let yDelta = this.pointerScreenY === null ? 0 : pointerScreenY - this.pointerScreenY;
      let xDelta = this.pointerScreenX === null ? 0 : pointerScreenX - this.pointerScreenX;
      if (yDelta < 0) {
        this.everMovedUp = true;
      } else if (yDelta > 0) {
        this.everMovedDown = true;
      }
      if (xDelta < 0) {
        this.everMovedLeft = true;
      } else if (xDelta > 0) {
        this.everMovedRight = true;
      }
      this.pointerScreenX = pointerScreenX;
      this.pointerScreenY = pointerScreenY;
      if (!this.isAnimating) {
        this.isAnimating = true;
        this.requestAnimation(getTime());
      }
    }
  }
  stop() {
    if (this.isEnabled) {
      this.isAnimating = false;
      for (let scrollCache of this.scrollCaches) {
        scrollCache.destroy();
      }
      this.scrollCaches = null;
    }
  }
  requestAnimation(now) {
    this.msSinceRequest = now;
    requestAnimationFrame(this.animate);
  }
  handleSide(edge, seconds) {
    let { scrollCache } = edge;
    let { edgeThreshold } = this;
    let invDistance = edgeThreshold - edge.distance;
    let velocity = (
      // the closer to the edge, the faster we scroll
      invDistance * invDistance / (edgeThreshold * edgeThreshold) * // quadratic
      this.maxVelocity * seconds
    );
    let sign = 1;
    switch (edge.name) {
      case "left":
        sign = -1;
      case "right":
        scrollCache.setScrollLeft(scrollCache.getScrollLeft() + velocity * sign);
        break;
      case "top":
        sign = -1;
      case "bottom":
        scrollCache.setScrollTop(scrollCache.getScrollTop() + velocity * sign);
        break;
    }
  }
  // left/top are relative to document topleft
  computeBestEdge(left, top) {
    let { edgeThreshold } = this;
    let bestSide = null;
    let scrollCaches = this.scrollCaches || [];
    for (let scrollCache of scrollCaches) {
      let rect = scrollCache.clientRect;
      let leftDist = left - rect.left;
      let rightDist = rect.right - left;
      let topDist = top - rect.top;
      let bottomDist = rect.bottom - top;
      if (leftDist >= 0 && rightDist >= 0 && topDist >= 0 && bottomDist >= 0) {
        if (topDist <= edgeThreshold && this.everMovedUp && scrollCache.canScrollUp() && (!bestSide || bestSide.distance > topDist)) {
          bestSide = { scrollCache, name: "top", distance: topDist };
        }
        if (bottomDist <= edgeThreshold && this.everMovedDown && scrollCache.canScrollDown() && (!bestSide || bestSide.distance > bottomDist)) {
          bestSide = { scrollCache, name: "bottom", distance: bottomDist };
        }
        if (leftDist <= edgeThreshold && this.everMovedLeft && scrollCache.canScrollLeft() && (!bestSide || bestSide.distance > leftDist)) {
          bestSide = { scrollCache, name: "left", distance: leftDist };
        }
        if (rightDist <= edgeThreshold && this.everMovedRight && scrollCache.canScrollRight() && (!bestSide || bestSide.distance > rightDist)) {
          bestSide = { scrollCache, name: "right", distance: rightDist };
        }
      }
    }
    return bestSide;
  }
  buildCaches(scrollStartEl) {
    return this.queryScrollEls(scrollStartEl).map((el) => {
      if (el === window) {
        return new WindowScrollGeomCache(false);
      }
      return new ElementScrollGeomCache(el, false);
    });
  }
  queryScrollEls(scrollStartEl) {
    let els = [];
    for (let query of this.scrollQuery) {
      if (typeof query === "object") {
        els.push(query);
      } else {
        els.push(...Array.prototype.slice.call(scrollStartEl.getRootNode().querySelectorAll(query)));
      }
    }
    return els;
  }
};
var FeaturefulElementDragging = class extends ElementDragging {
  constructor(containerEl, selector) {
    super(containerEl);
    this.containerEl = containerEl;
    this.delay = null;
    this.minDistance = 0;
    this.touchScrollAllowed = true;
    this.mirrorNeedsRevert = false;
    this.isInteracting = false;
    this.isDragging = false;
    this.isDelayEnded = false;
    this.isDistanceSurpassed = false;
    this.delayTimeoutId = null;
    this.onPointerDown = (ev) => {
      if (!this.isDragging) {
        this.isInteracting = true;
        this.isDelayEnded = false;
        this.isDistanceSurpassed = false;
        preventSelection(document.body);
        preventContextMenu(document.body);
        if (!ev.isTouch) {
          ev.origEvent.preventDefault();
        }
        this.emitter.trigger("pointerdown", ev);
        if (this.isInteracting && // not destroyed via pointerdown handler
        !this.pointer.shouldIgnoreMove) {
          this.mirror.setIsVisible(false);
          this.mirror.start(ev.subjectEl, ev.pageX, ev.pageY);
          this.startDelay(ev);
          if (!this.minDistance) {
            this.handleDistanceSurpassed(ev);
          }
        }
      }
    };
    this.onPointerMove = (ev) => {
      if (this.isInteracting) {
        this.emitter.trigger("pointermove", ev);
        if (!this.isDistanceSurpassed) {
          let minDistance = this.minDistance;
          let distanceSq;
          let { deltaX, deltaY } = ev;
          distanceSq = deltaX * deltaX + deltaY * deltaY;
          if (distanceSq >= minDistance * minDistance) {
            this.handleDistanceSurpassed(ev);
          }
        }
        if (this.isDragging) {
          if (ev.origEvent.type !== "scroll") {
            this.mirror.handleMove(ev.pageX, ev.pageY);
            this.autoScroller.handleMove(ev.pageX, ev.pageY);
          }
          this.emitter.trigger("dragmove", ev);
        }
      }
    };
    this.onPointerUp = (ev) => {
      if (this.isInteracting) {
        this.isInteracting = false;
        allowSelection(document.body);
        allowContextMenu(document.body);
        this.emitter.trigger("pointerup", ev);
        if (this.isDragging) {
          this.autoScroller.stop();
          this.tryStopDrag(ev);
        }
        if (this.delayTimeoutId) {
          clearTimeout(this.delayTimeoutId);
          this.delayTimeoutId = null;
        }
      }
    };
    let pointer = this.pointer = new PointerDragging(containerEl);
    pointer.emitter.on("pointerdown", this.onPointerDown);
    pointer.emitter.on("pointermove", this.onPointerMove);
    pointer.emitter.on("pointerup", this.onPointerUp);
    if (selector) {
      pointer.selector = selector;
    }
    this.mirror = new ElementMirror();
    this.autoScroller = new AutoScroller();
  }
  destroy() {
    this.pointer.destroy();
    this.onPointerUp({});
  }
  startDelay(ev) {
    if (typeof this.delay === "number") {
      this.delayTimeoutId = setTimeout(() => {
        this.delayTimeoutId = null;
        this.handleDelayEnd(ev);
      }, this.delay);
    } else {
      this.handleDelayEnd(ev);
    }
  }
  handleDelayEnd(ev) {
    this.isDelayEnded = true;
    this.tryStartDrag(ev);
  }
  handleDistanceSurpassed(ev) {
    this.isDistanceSurpassed = true;
    this.tryStartDrag(ev);
  }
  tryStartDrag(ev) {
    if (this.isDelayEnded && this.isDistanceSurpassed) {
      if (!this.pointer.wasTouchScroll || this.touchScrollAllowed) {
        this.isDragging = true;
        this.mirrorNeedsRevert = false;
        this.autoScroller.start(ev.pageX, ev.pageY, this.containerEl);
        this.emitter.trigger("dragstart", ev);
        if (this.touchScrollAllowed === false) {
          this.pointer.cancelTouchScroll();
        }
      }
    }
  }
  tryStopDrag(ev) {
    this.mirror.stop(this.mirrorNeedsRevert, this.stopDrag.bind(this, ev));
  }
  stopDrag(ev) {
    this.isDragging = false;
    this.emitter.trigger("dragend", ev);
  }
  // fill in the implementations...
  setIgnoreMove(bool) {
    this.pointer.shouldIgnoreMove = bool;
  }
  setMirrorIsVisible(bool) {
    this.mirror.setIsVisible(bool);
  }
  setMirrorNeedsRevert(bool) {
    this.mirrorNeedsRevert = bool;
  }
  setAutoScrollEnabled(bool) {
    this.autoScroller.isEnabled = bool;
  }
};
var OffsetTracker = class {
  constructor(el) {
    this.el = el;
    this.origRect = computeRect(el);
    this.scrollCaches = getClippingParents(el).map((scrollEl) => new ElementScrollGeomCache(scrollEl, true));
  }
  destroy() {
    for (let scrollCache of this.scrollCaches) {
      scrollCache.destroy();
    }
  }
  computeLeft() {
    let left = this.origRect.left;
    for (let scrollCache of this.scrollCaches) {
      left += scrollCache.origScrollLeft - scrollCache.getScrollLeft();
    }
    return left;
  }
  computeTop() {
    let top = this.origRect.top;
    for (let scrollCache of this.scrollCaches) {
      top += scrollCache.origScrollTop - scrollCache.getScrollTop();
    }
    return top;
  }
  isWithinClipping(pageX, pageY) {
    let point = { left: pageX, top: pageY };
    for (let scrollCache of this.scrollCaches) {
      if (!isIgnoredClipping(scrollCache.getEventTarget()) && !pointInsideRect(point, scrollCache.clientRect)) {
        return false;
      }
    }
    return true;
  }
};
function isIgnoredClipping(node) {
  let tagName = node.tagName;
  return tagName === "HTML" || tagName === "BODY";
}
var HitDragging = class {
  constructor(dragging, droppableStore) {
    this.useSubjectCenter = false;
    this.requireInitial = true;
    this.disablePointCheck = false;
    this.initialHit = null;
    this.movingHit = null;
    this.finalHit = null;
    this.handlePointerDown = (ev) => {
      let { dragging: dragging2 } = this;
      this.initialHit = null;
      this.movingHit = null;
      this.finalHit = null;
      this.prepareHits();
      this.processFirstCoord(ev);
      if (this.initialHit || !this.requireInitial) {
        dragging2.setIgnoreMove(false);
        this.emitter.trigger("pointerdown", ev);
      } else {
        dragging2.setIgnoreMove(true);
      }
    };
    this.handleDragStart = (ev) => {
      this.emitter.trigger("dragstart", ev);
      this.handleMove(ev, true);
    };
    this.handleDragMove = (ev) => {
      this.emitter.trigger("dragmove", ev);
      this.handleMove(ev);
    };
    this.handlePointerUp = (ev) => {
      this.releaseHits();
      this.emitter.trigger("pointerup", ev);
    };
    this.handleDragEnd = (ev) => {
      if (this.movingHit) {
        this.emitter.trigger("hitupdate", null, true, ev);
      }
      this.finalHit = this.movingHit;
      this.movingHit = null;
      this.emitter.trigger("dragend", ev);
    };
    this.droppableStore = droppableStore;
    dragging.emitter.on("pointerdown", this.handlePointerDown);
    dragging.emitter.on("dragstart", this.handleDragStart);
    dragging.emitter.on("dragmove", this.handleDragMove);
    dragging.emitter.on("pointerup", this.handlePointerUp);
    dragging.emitter.on("dragend", this.handleDragEnd);
    this.dragging = dragging;
    this.emitter = new Emitter();
  }
  // sets initialHit
  // sets coordAdjust
  processFirstCoord(ev) {
    let origPoint = { left: ev.pageX, top: ev.pageY };
    let adjustedPoint = origPoint;
    let subjectEl = ev.subjectEl;
    let subjectRect;
    if (subjectEl instanceof HTMLElement) {
      subjectRect = computeRect(subjectEl);
      adjustedPoint = constrainPoint(adjustedPoint, subjectRect);
    }
    let initialHit = this.initialHit = this.queryHitForOffset(adjustedPoint.left, adjustedPoint.top);
    if (initialHit) {
      if (this.useSubjectCenter && subjectRect) {
        let slicedSubjectRect = intersectRects(subjectRect, initialHit.rect);
        if (slicedSubjectRect) {
          adjustedPoint = getRectCenter(slicedSubjectRect);
        }
      }
      this.coordAdjust = diffPoints(adjustedPoint, origPoint);
    } else {
      this.coordAdjust = { left: 0, top: 0 };
    }
  }
  handleMove(ev, forceHandle) {
    let hit = this.queryHitForOffset(ev.pageX + this.coordAdjust.left, ev.pageY + this.coordAdjust.top);
    if (forceHandle || !isHitsEqual(this.movingHit, hit)) {
      this.movingHit = hit;
      this.emitter.trigger("hitupdate", hit, false, ev);
    }
  }
  prepareHits() {
    this.offsetTrackers = mapHash(this.droppableStore, (interactionSettings) => {
      interactionSettings.component.prepareHits();
      return new OffsetTracker(interactionSettings.el);
    });
  }
  releaseHits() {
    let { offsetTrackers } = this;
    for (let id in offsetTrackers) {
      offsetTrackers[id].destroy();
    }
    this.offsetTrackers = {};
  }
  queryHitForOffset(offsetLeft, offsetTop) {
    let { droppableStore, offsetTrackers } = this;
    let bestHit = null;
    for (let id in droppableStore) {
      let component = droppableStore[id].component;
      let offsetTracker = offsetTrackers[id];
      if (offsetTracker && // wasn't destroyed mid-drag
      offsetTracker.isWithinClipping(offsetLeft, offsetTop)) {
        let originLeft = offsetTracker.computeLeft();
        let originTop = offsetTracker.computeTop();
        let positionLeft = offsetLeft - originLeft;
        let positionTop = offsetTop - originTop;
        let { origRect } = offsetTracker;
        let width = origRect.right - origRect.left;
        let height = origRect.bottom - origRect.top;
        if (
          // must be within the element's bounds
          positionLeft >= 0 && positionLeft < width && positionTop >= 0 && positionTop < height
        ) {
          let hit = component.queryHit(positionLeft, positionTop, width, height);
          if (hit && // make sure the hit is within activeRange, meaning it's not a dead cell
          rangeContainsRange(hit.dateProfile.activeRange, hit.dateSpan.range) && // Ensure the component we are querying for the hit is accessibly my the pointer
          // Prevents obscured calendars (ex: under a modal dialog) from accepting hit
          // https://github.com/fullcalendar/fullcalendar/issues/5026
          (this.disablePointCheck || offsetTracker.el.contains(offsetTracker.el.getRootNode().elementFromPoint(
            // add-back origins to get coordinate relative to top-left of window viewport
            positionLeft + originLeft - window.scrollX,
            positionTop + originTop - window.scrollY
          ))) && (!bestHit || hit.layer > bestHit.layer)) {
            hit.componentId = id;
            hit.context = component.context;
            hit.rect.left += originLeft;
            hit.rect.right += originLeft;
            hit.rect.top += originTop;
            hit.rect.bottom += originTop;
            bestHit = hit;
          }
        }
      }
    }
    return bestHit;
  }
};
function isHitsEqual(hit0, hit1) {
  if (!hit0 && !hit1) {
    return true;
  }
  if (Boolean(hit0) !== Boolean(hit1)) {
    return false;
  }
  return isDateSpansEqual(hit0.dateSpan, hit1.dateSpan);
}
function buildDatePointApiWithContext(dateSpan, context) {
  let props = {};
  for (let transform of context.pluginHooks.datePointTransforms) {
    Object.assign(props, transform(dateSpan, context));
  }
  Object.assign(props, buildDatePointApi(dateSpan, context.dateEnv));
  return props;
}
function buildDatePointApi(span, dateEnv) {
  return {
    date: dateEnv.toDate(span.range.start),
    dateStr: dateEnv.formatIso(span.range.start, { omitTime: span.allDay }),
    allDay: span.allDay
  };
}
var DateClicking = class extends Interaction {
  constructor(settings) {
    super(settings);
    this.handlePointerDown = (pev) => {
      let { dragging } = this;
      let downEl = pev.origEvent.target;
      dragging.setIgnoreMove(!this.component.isValidDateDownEl(downEl));
    };
    this.handleDragEnd = (ev) => {
      let { component } = this;
      let { pointer } = this.dragging;
      if (!pointer.wasTouchScroll) {
        let { initialHit, finalHit } = this.hitDragging;
        if (initialHit && finalHit && isHitsEqual(initialHit, finalHit)) {
          let { context } = component;
          let arg = Object.assign(Object.assign({}, buildDatePointApiWithContext(initialHit.dateSpan, context)), { dayEl: initialHit.dayEl, jsEvent: ev.origEvent, view: context.viewApi || context.calendarApi.view });
          context.emitter.trigger("dateClick", arg);
        }
      }
    };
    this.dragging = new FeaturefulElementDragging(settings.el);
    this.dragging.autoScroller.isEnabled = false;
    let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsToStore(settings));
    hitDragging.emitter.on("pointerdown", this.handlePointerDown);
    hitDragging.emitter.on("dragend", this.handleDragEnd);
  }
  destroy() {
    this.dragging.destroy();
  }
};
var DateSelecting = class extends Interaction {
  constructor(settings) {
    super(settings);
    this.dragSelection = null;
    this.handlePointerDown = (ev) => {
      let { component: component2, dragging: dragging2 } = this;
      let { options: options2 } = component2.context;
      let canSelect = options2.selectable && component2.isValidDateDownEl(ev.origEvent.target);
      dragging2.setIgnoreMove(!canSelect);
      dragging2.delay = ev.isTouch ? getComponentTouchDelay$1(component2) : null;
    };
    this.handleDragStart = (ev) => {
      this.component.context.calendarApi.unselect(ev);
    };
    this.handleHitUpdate = (hit, isFinal) => {
      let { context } = this.component;
      let dragSelection = null;
      let isInvalid = false;
      if (hit) {
        let initialHit = this.hitDragging.initialHit;
        let disallowed = hit.componentId === initialHit.componentId && this.isHitComboAllowed && !this.isHitComboAllowed(initialHit, hit);
        if (!disallowed) {
          dragSelection = joinHitsIntoSelection(initialHit, hit, context.pluginHooks.dateSelectionTransformers);
        }
        if (!dragSelection || !isDateSelectionValid(dragSelection, hit.dateProfile, context)) {
          isInvalid = true;
          dragSelection = null;
        }
      }
      if (dragSelection) {
        context.dispatch({ type: "SELECT_DATES", selection: dragSelection });
      } else if (!isFinal) {
        context.dispatch({ type: "UNSELECT_DATES" });
      }
      if (!isInvalid) {
        enableCursor();
      } else {
        disableCursor();
      }
      if (!isFinal) {
        this.dragSelection = dragSelection;
      }
    };
    this.handlePointerUp = (pev) => {
      if (this.dragSelection) {
        triggerDateSelect(this.dragSelection, pev, this.component.context);
        this.dragSelection = null;
      }
    };
    let { component } = settings;
    let { options } = component.context;
    let dragging = this.dragging = new FeaturefulElementDragging(settings.el);
    dragging.touchScrollAllowed = false;
    dragging.minDistance = options.selectMinDistance || 0;
    dragging.autoScroller.isEnabled = options.dragScroll;
    let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsToStore(settings));
    hitDragging.emitter.on("pointerdown", this.handlePointerDown);
    hitDragging.emitter.on("dragstart", this.handleDragStart);
    hitDragging.emitter.on("hitupdate", this.handleHitUpdate);
    hitDragging.emitter.on("pointerup", this.handlePointerUp);
  }
  destroy() {
    this.dragging.destroy();
  }
};
function getComponentTouchDelay$1(component) {
  let { options } = component.context;
  let delay = options.selectLongPressDelay;
  if (delay == null) {
    delay = options.longPressDelay;
  }
  return delay;
}
function joinHitsIntoSelection(hit0, hit1, dateSelectionTransformers) {
  let dateSpan0 = hit0.dateSpan;
  let dateSpan1 = hit1.dateSpan;
  let ms = [
    dateSpan0.range.start,
    dateSpan0.range.end,
    dateSpan1.range.start,
    dateSpan1.range.end
  ];
  ms.sort(compareNumbers);
  let props = {};
  for (let transformer of dateSelectionTransformers) {
    let res = transformer(hit0, hit1);
    if (res === false) {
      return null;
    }
    if (res) {
      Object.assign(props, res);
    }
  }
  props.range = { start: ms[0], end: ms[3] };
  props.allDay = dateSpan0.allDay;
  return props;
}
var EventDragging = class extends Interaction {
  constructor(settings) {
    super(settings);
    this.subjectEl = null;
    this.subjectSeg = null;
    this.isDragging = false;
    this.eventRange = null;
    this.relevantEvents = null;
    this.receivingContext = null;
    this.validMutation = null;
    this.mutatedRelevantEvents = null;
    this.handlePointerDown = (ev) => {
      let origTarget = ev.origEvent.target;
      let { component: component2, dragging: dragging2 } = this;
      let { mirror } = dragging2;
      let { options: options2 } = component2.context;
      let initialContext = component2.context;
      this.subjectEl = ev.subjectEl;
      let subjectSeg = this.subjectSeg = getElSeg(ev.subjectEl);
      let eventRange = this.eventRange = subjectSeg.eventRange;
      let eventInstanceId = eventRange.instance.instanceId;
      this.relevantEvents = getRelevantEvents(initialContext.getCurrentData().eventStore, eventInstanceId);
      dragging2.minDistance = ev.isTouch ? 0 : options2.eventDragMinDistance;
      dragging2.delay = // only do a touch delay if touch and this event hasn't been selected yet
      ev.isTouch && eventInstanceId !== component2.props.eventSelection ? getComponentTouchDelay(component2) : null;
      if (options2.fixedMirrorParent) {
        mirror.parentNode = options2.fixedMirrorParent;
      } else {
        mirror.parentNode = elementClosest(origTarget, ".fc");
      }
      mirror.revertDuration = options2.dragRevertDuration;
      let isValid = component2.isValidSegDownEl(origTarget) && !elementClosest(origTarget, ".fc-event-resizer");
      dragging2.setIgnoreMove(!isValid);
      this.isDragging = isValid && ev.subjectEl.classList.contains("fc-event-draggable");
    };
    this.handleDragStart = (ev) => {
      let initialContext = this.component.context;
      let eventRange = this.eventRange;
      let eventInstanceId = eventRange.instance.instanceId;
      if (ev.isTouch) {
        if (eventInstanceId !== this.component.props.eventSelection) {
          initialContext.dispatch({ type: "SELECT_EVENT", eventInstanceId });
        }
      } else {
        initialContext.dispatch({ type: "UNSELECT_EVENT" });
      }
      if (this.isDragging) {
        initialContext.calendarApi.unselect(ev);
        initialContext.emitter.trigger("eventDragStart", {
          el: this.subjectEl,
          event: new EventImpl(initialContext, eventRange.def, eventRange.instance),
          jsEvent: ev.origEvent,
          view: initialContext.viewApi
        });
      }
    };
    this.handleHitUpdate = (hit, isFinal) => {
      if (!this.isDragging) {
        return;
      }
      let relevantEvents = this.relevantEvents;
      let initialHit = this.hitDragging.initialHit;
      let initialContext = this.component.context;
      let receivingContext = null;
      let mutation = null;
      let mutatedRelevantEvents = null;
      let isInvalid = false;
      let interaction = {
        affectedEvents: relevantEvents,
        mutatedEvents: createEmptyEventStore(),
        isEvent: true
      };
      if (hit) {
        receivingContext = hit.context;
        let receivingOptions = receivingContext.options;
        if (initialContext === receivingContext || receivingOptions.editable && receivingOptions.droppable) {
          mutation = computeEventMutation(initialHit, hit, this.eventRange.instance.range.start, receivingContext.getCurrentData().pluginHooks.eventDragMutationMassagers);
          if (mutation) {
            mutatedRelevantEvents = applyMutationToEventStore(relevantEvents, receivingContext.getCurrentData().eventUiBases, mutation, receivingContext);
            interaction.mutatedEvents = mutatedRelevantEvents;
            if (!isInteractionValid(interaction, hit.dateProfile, receivingContext)) {
              isInvalid = true;
              mutation = null;
              mutatedRelevantEvents = null;
              interaction.mutatedEvents = createEmptyEventStore();
            }
          }
        } else {
          receivingContext = null;
        }
      }
      this.displayDrag(receivingContext, interaction);
      if (!isInvalid) {
        enableCursor();
      } else {
        disableCursor();
      }
      if (!isFinal) {
        if (initialContext === receivingContext && // TODO: write test for this
        isHitsEqual(initialHit, hit)) {
          mutation = null;
        }
        this.dragging.setMirrorNeedsRevert(!mutation);
        this.dragging.setMirrorIsVisible(!hit || !this.subjectEl.getRootNode().querySelector(".fc-event-mirror"));
        this.receivingContext = receivingContext;
        this.validMutation = mutation;
        this.mutatedRelevantEvents = mutatedRelevantEvents;
      }
    };
    this.handlePointerUp = () => {
      if (!this.isDragging) {
        this.cleanup();
      }
    };
    this.handleDragEnd = (ev) => {
      if (this.isDragging) {
        let initialContext = this.component.context;
        let initialView = initialContext.viewApi;
        let { receivingContext, validMutation } = this;
        let eventDef = this.eventRange.def;
        let eventInstance = this.eventRange.instance;
        let eventApi = new EventImpl(initialContext, eventDef, eventInstance);
        let relevantEvents = this.relevantEvents;
        let mutatedRelevantEvents = this.mutatedRelevantEvents;
        let { finalHit } = this.hitDragging;
        this.clearDrag();
        initialContext.emitter.trigger("eventDragStop", {
          el: this.subjectEl,
          event: eventApi,
          jsEvent: ev.origEvent,
          view: initialView
        });
        if (validMutation) {
          if (receivingContext === initialContext) {
            let updatedEventApi = new EventImpl(initialContext, mutatedRelevantEvents.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents.instances[eventInstance.instanceId] : null);
            initialContext.dispatch({
              type: "MERGE_EVENTS",
              eventStore: mutatedRelevantEvents
            });
            let eventChangeArg = {
              oldEvent: eventApi,
              event: updatedEventApi,
              relatedEvents: buildEventApis(mutatedRelevantEvents, initialContext, eventInstance),
              revert() {
                initialContext.dispatch({
                  type: "MERGE_EVENTS",
                  eventStore: relevantEvents
                  // the pre-change data
                });
              }
            };
            let transformed = {};
            for (let transformer of initialContext.getCurrentData().pluginHooks.eventDropTransformers) {
              Object.assign(transformed, transformer(validMutation, initialContext));
            }
            initialContext.emitter.trigger("eventDrop", Object.assign(Object.assign(Object.assign({}, eventChangeArg), transformed), { el: ev.subjectEl, delta: validMutation.datesDelta, jsEvent: ev.origEvent, view: initialView }));
            initialContext.emitter.trigger("eventChange", eventChangeArg);
          } else if (receivingContext) {
            let eventRemoveArg = {
              event: eventApi,
              relatedEvents: buildEventApis(relevantEvents, initialContext, eventInstance),
              revert() {
                initialContext.dispatch({
                  type: "MERGE_EVENTS",
                  eventStore: relevantEvents
                });
              }
            };
            initialContext.emitter.trigger("eventLeave", Object.assign(Object.assign({}, eventRemoveArg), { draggedEl: ev.subjectEl, view: initialView }));
            initialContext.dispatch({
              type: "REMOVE_EVENTS",
              eventStore: relevantEvents
            });
            initialContext.emitter.trigger("eventRemove", eventRemoveArg);
            let addedEventDef = mutatedRelevantEvents.defs[eventDef.defId];
            let addedEventInstance = mutatedRelevantEvents.instances[eventInstance.instanceId];
            let addedEventApi = new EventImpl(receivingContext, addedEventDef, addedEventInstance);
            receivingContext.dispatch({
              type: "MERGE_EVENTS",
              eventStore: mutatedRelevantEvents
            });
            let eventAddArg = {
              event: addedEventApi,
              relatedEvents: buildEventApis(mutatedRelevantEvents, receivingContext, addedEventInstance),
              revert() {
                receivingContext.dispatch({
                  type: "REMOVE_EVENTS",
                  eventStore: mutatedRelevantEvents
                });
              }
            };
            receivingContext.emitter.trigger("eventAdd", eventAddArg);
            if (ev.isTouch) {
              receivingContext.dispatch({
                type: "SELECT_EVENT",
                eventInstanceId: eventInstance.instanceId
              });
            }
            receivingContext.emitter.trigger("drop", Object.assign(Object.assign({}, buildDatePointApiWithContext(finalHit.dateSpan, receivingContext)), { draggedEl: ev.subjectEl, jsEvent: ev.origEvent, view: finalHit.context.viewApi }));
            receivingContext.emitter.trigger("eventReceive", Object.assign(Object.assign({}, eventAddArg), { draggedEl: ev.subjectEl, view: finalHit.context.viewApi }));
          }
        } else {
          initialContext.emitter.trigger("_noEventDrop");
        }
      }
      this.cleanup();
    };
    let { component } = this;
    let { options } = component.context;
    let dragging = this.dragging = new FeaturefulElementDragging(settings.el);
    dragging.pointer.selector = EventDragging.SELECTOR;
    dragging.touchScrollAllowed = false;
    dragging.autoScroller.isEnabled = options.dragScroll;
    let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsStore);
    hitDragging.useSubjectCenter = settings.useEventCenter;
    hitDragging.emitter.on("pointerdown", this.handlePointerDown);
    hitDragging.emitter.on("dragstart", this.handleDragStart);
    hitDragging.emitter.on("hitupdate", this.handleHitUpdate);
    hitDragging.emitter.on("pointerup", this.handlePointerUp);
    hitDragging.emitter.on("dragend", this.handleDragEnd);
  }
  destroy() {
    this.dragging.destroy();
  }
  // render a drag state on the next receivingCalendar
  displayDrag(nextContext, state) {
    let initialContext = this.component.context;
    let prevContext = this.receivingContext;
    if (prevContext && prevContext !== nextContext) {
      if (prevContext === initialContext) {
        prevContext.dispatch({
          type: "SET_EVENT_DRAG",
          state: {
            affectedEvents: state.affectedEvents,
            mutatedEvents: createEmptyEventStore(),
            isEvent: true
          }
        });
      } else {
        prevContext.dispatch({ type: "UNSET_EVENT_DRAG" });
      }
    }
    if (nextContext) {
      nextContext.dispatch({ type: "SET_EVENT_DRAG", state });
    }
  }
  clearDrag() {
    let initialCalendar = this.component.context;
    let { receivingContext } = this;
    if (receivingContext) {
      receivingContext.dispatch({ type: "UNSET_EVENT_DRAG" });
    }
    if (initialCalendar !== receivingContext) {
      initialCalendar.dispatch({ type: "UNSET_EVENT_DRAG" });
    }
  }
  cleanup() {
    this.subjectSeg = null;
    this.isDragging = false;
    this.eventRange = null;
    this.relevantEvents = null;
    this.receivingContext = null;
    this.validMutation = null;
    this.mutatedRelevantEvents = null;
  }
};
EventDragging.SELECTOR = ".fc-event-draggable, .fc-event-resizable";
function computeEventMutation(hit0, hit1, eventInstanceStart, massagers) {
  let dateSpan0 = hit0.dateSpan;
  let dateSpan1 = hit1.dateSpan;
  let date0 = dateSpan0.range.start;
  let date1 = dateSpan1.range.start;
  let standardProps = {};
  if (dateSpan0.allDay !== dateSpan1.allDay) {
    standardProps.allDay = dateSpan1.allDay;
    standardProps.hasEnd = hit1.context.options.allDayMaintainDuration;
    if (dateSpan1.allDay) {
      date0 = startOfDay(eventInstanceStart);
    } else {
      date0 = eventInstanceStart;
    }
  }
  let delta = diffDates(date0, date1, hit0.context.dateEnv, hit0.componentId === hit1.componentId ? hit0.largeUnit : null);
  if (delta.milliseconds) {
    standardProps.allDay = false;
  }
  let mutation = {
    datesDelta: delta,
    standardProps
  };
  for (let massager of massagers) {
    massager(mutation, hit0, hit1);
  }
  return mutation;
}
function getComponentTouchDelay(component) {
  let { options } = component.context;
  let delay = options.eventLongPressDelay;
  if (delay == null) {
    delay = options.longPressDelay;
  }
  return delay;
}
var EventResizing = class extends Interaction {
  constructor(settings) {
    super(settings);
    this.draggingSegEl = null;
    this.draggingSeg = null;
    this.eventRange = null;
    this.relevantEvents = null;
    this.validMutation = null;
    this.mutatedRelevantEvents = null;
    this.handlePointerDown = (ev) => {
      let { component: component2 } = this;
      let segEl = this.querySegEl(ev);
      let seg = getElSeg(segEl);
      let eventRange = this.eventRange = seg.eventRange;
      this.dragging.minDistance = component2.context.options.eventDragMinDistance;
      this.dragging.setIgnoreMove(!this.component.isValidSegDownEl(ev.origEvent.target) || ev.isTouch && this.component.props.eventSelection !== eventRange.instance.instanceId);
    };
    this.handleDragStart = (ev) => {
      let { context } = this.component;
      let eventRange = this.eventRange;
      this.relevantEvents = getRelevantEvents(context.getCurrentData().eventStore, this.eventRange.instance.instanceId);
      let segEl = this.querySegEl(ev);
      this.draggingSegEl = segEl;
      this.draggingSeg = getElSeg(segEl);
      context.calendarApi.unselect();
      context.emitter.trigger("eventResizeStart", {
        el: segEl,
        event: new EventImpl(context, eventRange.def, eventRange.instance),
        jsEvent: ev.origEvent,
        view: context.viewApi
      });
    };
    this.handleHitUpdate = (hit, isFinal, ev) => {
      let { context } = this.component;
      let relevantEvents = this.relevantEvents;
      let initialHit = this.hitDragging.initialHit;
      let eventInstance = this.eventRange.instance;
      let mutation = null;
      let mutatedRelevantEvents = null;
      let isInvalid = false;
      let interaction = {
        affectedEvents: relevantEvents,
        mutatedEvents: createEmptyEventStore(),
        isEvent: true
      };
      if (hit) {
        let disallowed = hit.componentId === initialHit.componentId && this.isHitComboAllowed && !this.isHitComboAllowed(initialHit, hit);
        if (!disallowed) {
          mutation = computeMutation(initialHit, hit, ev.subjectEl.classList.contains("fc-event-resizer-start"), eventInstance.range);
        }
      }
      if (mutation) {
        mutatedRelevantEvents = applyMutationToEventStore(relevantEvents, context.getCurrentData().eventUiBases, mutation, context);
        interaction.mutatedEvents = mutatedRelevantEvents;
        if (!isInteractionValid(interaction, hit.dateProfile, context)) {
          isInvalid = true;
          mutation = null;
          mutatedRelevantEvents = null;
          interaction.mutatedEvents = null;
        }
      }
      if (mutatedRelevantEvents) {
        context.dispatch({
          type: "SET_EVENT_RESIZE",
          state: interaction
        });
      } else {
        context.dispatch({ type: "UNSET_EVENT_RESIZE" });
      }
      if (!isInvalid) {
        enableCursor();
      } else {
        disableCursor();
      }
      if (!isFinal) {
        if (mutation && isHitsEqual(initialHit, hit)) {
          mutation = null;
        }
        this.validMutation = mutation;
        this.mutatedRelevantEvents = mutatedRelevantEvents;
      }
    };
    this.handleDragEnd = (ev) => {
      let { context } = this.component;
      let eventDef = this.eventRange.def;
      let eventInstance = this.eventRange.instance;
      let eventApi = new EventImpl(context, eventDef, eventInstance);
      let relevantEvents = this.relevantEvents;
      let mutatedRelevantEvents = this.mutatedRelevantEvents;
      context.emitter.trigger("eventResizeStop", {
        el: this.draggingSegEl,
        event: eventApi,
        jsEvent: ev.origEvent,
        view: context.viewApi
      });
      if (this.validMutation) {
        let updatedEventApi = new EventImpl(context, mutatedRelevantEvents.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents.instances[eventInstance.instanceId] : null);
        context.dispatch({
          type: "MERGE_EVENTS",
          eventStore: mutatedRelevantEvents
        });
        let eventChangeArg = {
          oldEvent: eventApi,
          event: updatedEventApi,
          relatedEvents: buildEventApis(mutatedRelevantEvents, context, eventInstance),
          revert() {
            context.dispatch({
              type: "MERGE_EVENTS",
              eventStore: relevantEvents
              // the pre-change events
            });
          }
        };
        context.emitter.trigger("eventResize", Object.assign(Object.assign({}, eventChangeArg), { el: this.draggingSegEl, startDelta: this.validMutation.startDelta || createDuration(0), endDelta: this.validMutation.endDelta || createDuration(0), jsEvent: ev.origEvent, view: context.viewApi }));
        context.emitter.trigger("eventChange", eventChangeArg);
      } else {
        context.emitter.trigger("_noEventResize");
      }
      this.draggingSeg = null;
      this.relevantEvents = null;
      this.validMutation = null;
    };
    let { component } = settings;
    let dragging = this.dragging = new FeaturefulElementDragging(settings.el);
    dragging.pointer.selector = ".fc-event-resizer";
    dragging.touchScrollAllowed = false;
    dragging.autoScroller.isEnabled = component.context.options.dragScroll;
    let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsToStore(settings));
    hitDragging.emitter.on("pointerdown", this.handlePointerDown);
    hitDragging.emitter.on("dragstart", this.handleDragStart);
    hitDragging.emitter.on("hitupdate", this.handleHitUpdate);
    hitDragging.emitter.on("dragend", this.handleDragEnd);
  }
  destroy() {
    this.dragging.destroy();
  }
  querySegEl(ev) {
    return elementClosest(ev.subjectEl, ".fc-event");
  }
};
function computeMutation(hit0, hit1, isFromStart, instanceRange) {
  let dateEnv = hit0.context.dateEnv;
  let date0 = hit0.dateSpan.range.start;
  let date1 = hit1.dateSpan.range.start;
  let delta = diffDates(date0, date1, dateEnv, hit0.largeUnit);
  if (isFromStart) {
    if (dateEnv.add(instanceRange.start, delta) < instanceRange.end) {
      return { startDelta: delta };
    }
  } else if (dateEnv.add(instanceRange.end, delta) > instanceRange.start) {
    return { endDelta: delta };
  }
  return null;
}
var UnselectAuto = class {
  constructor(context) {
    this.context = context;
    this.isRecentPointerDateSelect = false;
    this.matchesCancel = false;
    this.matchesEvent = false;
    this.onSelect = (selectInfo) => {
      if (selectInfo.jsEvent) {
        this.isRecentPointerDateSelect = true;
      }
    };
    this.onDocumentPointerDown = (pev) => {
      let unselectCancel = this.context.options.unselectCancel;
      let downEl = getEventTargetViaRoot(pev.origEvent);
      this.matchesCancel = !!elementClosest(downEl, unselectCancel);
      this.matchesEvent = !!elementClosest(downEl, EventDragging.SELECTOR);
    };
    this.onDocumentPointerUp = (pev) => {
      let { context: context2 } = this;
      let { documentPointer: documentPointer2 } = this;
      let calendarState = context2.getCurrentData();
      if (!documentPointer2.wasTouchScroll) {
        if (calendarState.dateSelection && // an existing date selection?
        !this.isRecentPointerDateSelect) {
          let unselectAuto = context2.options.unselectAuto;
          if (unselectAuto && (!unselectAuto || !this.matchesCancel)) {
            context2.calendarApi.unselect(pev);
          }
        }
        if (calendarState.eventSelection && // an existing event selected?
        !this.matchesEvent) {
          context2.dispatch({ type: "UNSELECT_EVENT" });
        }
      }
      this.isRecentPointerDateSelect = false;
    };
    let documentPointer = this.documentPointer = new PointerDragging(document);
    documentPointer.shouldIgnoreMove = true;
    documentPointer.shouldWatchScroll = false;
    documentPointer.emitter.on("pointerdown", this.onDocumentPointerDown);
    documentPointer.emitter.on("pointerup", this.onDocumentPointerUp);
    context.emitter.on("select", this.onSelect);
  }
  destroy() {
    this.context.emitter.off("select", this.onSelect);
    this.documentPointer.destroy();
  }
};
var OPTION_REFINERS3 = {
  fixedMirrorParent: identity
};
var LISTENER_REFINERS = {
  dateClick: identity,
  eventDragStart: identity,
  eventDragStop: identity,
  eventDrop: identity,
  eventResizeStart: identity,
  eventResizeStop: identity,
  eventResize: identity,
  drop: identity,
  eventReceive: identity,
  eventLeave: identity
};
config.dataAttrPrefix = "";
var index5 = createPlugin({
  name: "@fullcalendar/interaction",
  componentInteractions: [DateClicking, DateSelecting, EventDragging, EventResizing],
  calendarInteractions: [UnselectAuto],
  elementDraggingImpl: FeaturefulElementDragging,
  optionRefiners: OPTION_REFINERS3,
  listenerRefiners: LISTENER_REFINERS
});

// node_modules/@fullcalendar/google-calendar/index.js
var API_BASE = "https://www.googleapis.com/calendar/v3/calendars";
var eventSourceDef2 = {
  parseMeta(refined) {
    let { googleCalendarId } = refined;
    if (!googleCalendarId && refined.url) {
      googleCalendarId = parseGoogleCalendarId(refined.url);
    }
    if (googleCalendarId) {
      return {
        googleCalendarId,
        googleCalendarApiKey: refined.googleCalendarApiKey,
        googleCalendarApiBase: refined.googleCalendarApiBase,
        extraParams: refined.extraParams
      };
    }
    return null;
  },
  fetch(arg, successCallback, errorCallback) {
    let { dateEnv, options } = arg.context;
    let meta = arg.eventSource.meta;
    let apiKey = meta.googleCalendarApiKey || options.googleCalendarApiKey;
    if (!apiKey) {
      errorCallback(new Error("Specify a googleCalendarApiKey. See https://fullcalendar.io/docs/google-calendar"));
    } else {
      let url = buildUrl(meta);
      let { extraParams } = meta;
      let extraParamsObj = typeof extraParams === "function" ? extraParams() : extraParams;
      let requestParams = buildRequestParams2(arg.range, apiKey, extraParamsObj, dateEnv);
      return requestJson("GET", url, requestParams).then(([body, response]) => {
        if (body.error) {
          errorCallback(new JsonRequestError("Google Calendar API: " + body.error.message, response));
        } else {
          successCallback({
            rawEvents: gcalItemsToRawEventDefs(body.items, requestParams.timeZone),
            response
          });
        }
      }, errorCallback);
    }
  }
};
function parseGoogleCalendarId(url) {
  let match;
  if (/^[^/]+@([^/.]+\.)*(google|googlemail|gmail)\.com$/.test(url)) {
    return url;
  }
  if ((match = /^https:\/\/www.googleapis.com\/calendar\/v3\/calendars\/([^/]*)/.exec(url)) || (match = /^https?:\/\/www.google.com\/calendar\/feeds\/([^/]*)/.exec(url))) {
    return decodeURIComponent(match[1]);
  }
  return null;
}
function buildUrl(meta) {
  let apiBase = meta.googleCalendarApiBase;
  if (!apiBase) {
    apiBase = API_BASE;
  }
  return apiBase + "/" + encodeURIComponent(meta.googleCalendarId) + "/events";
}
function buildRequestParams2(range2, apiKey, extraParams, dateEnv) {
  let params;
  let startStr;
  let endStr;
  if (dateEnv.canComputeOffset) {
    startStr = dateEnv.formatIso(range2.start);
    endStr = dateEnv.formatIso(range2.end);
  } else {
    startStr = addDays(range2.start, -1).toISOString();
    endStr = addDays(range2.end, 1).toISOString();
  }
  params = Object.assign(Object.assign({}, extraParams || {}), { key: apiKey, timeMin: startStr, timeMax: endStr, singleEvents: true, maxResults: 9999 });
  if (dateEnv.timeZone !== "local") {
    params.timeZone = dateEnv.timeZone;
  }
  return params;
}
function gcalItemsToRawEventDefs(items, gcalTimezone) {
  return items.map((item) => gcalItemToRawEventDef(item, gcalTimezone));
}
function gcalItemToRawEventDef(item, gcalTimezone) {
  let url = item.htmlLink || null;
  if (url && gcalTimezone) {
    url = injectQsComponent(url, "ctz=" + gcalTimezone);
  }
  return {
    id: item.id,
    title: item.summary,
    start: item.start.dateTime || item.start.date,
    end: item.end.dateTime || item.end.date,
    url,
    location: item.location,
    description: item.description,
    attachments: item.attachments || [],
    extendedProps: (item.extendedProperties || {}).shared || {}
  };
}
function injectQsComponent(url, component) {
  return url.replace(/(\?.*?)?(#|$)/, (whole, qs, hash) => (qs ? qs + "&" : "?") + component + hash);
}
var OPTION_REFINERS4 = {
  googleCalendarApiKey: String
};
var EVENT_SOURCE_REFINERS2 = {
  googleCalendarApiKey: String,
  googleCalendarId: String,
  googleCalendarApiBase: String,
  extraParams: identity
};
var index6 = createPlugin({
  name: "@fullcalendar/google-calendar",
  eventSourceDefs: [eventSourceDef2],
  optionRefiners: OPTION_REFINERS4,
  eventSourceRefiners: EVENT_SOURCE_REFINERS2
});

// node_modules/@fullcalendar/icalendar/index.js
var ICAL = __toESM(require_ical(), 1);
var IcalExpander = class {
  constructor(opts) {
    this.maxIterations = opts.maxIterations != null ? opts.maxIterations : 1e3;
    this.skipInvalidDates = opts.skipInvalidDates != null ? opts.skipInvalidDates : false;
    this.jCalData = ICAL.parse(opts.ics);
    this.component = new ICAL.Component(this.jCalData);
    this.events = this.component.getAllSubcomponents("vevent").map((vevent) => new ICAL.Event(vevent));
    if (this.skipInvalidDates) {
      this.events = this.events.filter((evt) => {
        try {
          evt.startDate.toJSDate();
          evt.endDate.toJSDate();
          return true;
        } catch (err) {
          return false;
        }
      });
    }
  }
  between(after, before) {
    function isEventWithinRange(startTime, endTime) {
      return (!after || endTime >= after.getTime()) && (!before || startTime <= before.getTime());
    }
    function getTimes(eventOrOccurrence) {
      const startTime = eventOrOccurrence.startDate.toJSDate().getTime();
      let endTime = eventOrOccurrence.endDate.toJSDate().getTime();
      if (eventOrOccurrence.endDate.isDate && endTime > startTime) {
        endTime -= 1;
      }
      return { startTime, endTime };
    }
    const exceptions = [];
    this.events.forEach((event) => {
      if (event.isRecurrenceException())
        exceptions.push(event);
    });
    const ret = {
      events: [],
      occurrences: []
    };
    this.events.filter((e3) => !e3.isRecurrenceException()).forEach((event) => {
      const exdates = [];
      event.component.getAllProperties("exdate").forEach((exdateProp) => {
        const exdate = exdateProp.getFirstValue();
        exdates.push(exdate.toJSDate().getTime());
      });
      if (event.isRecurring()) {
        const iterator = event.iterator();
        let next;
        let i3 = 0;
        do {
          i3 += 1;
          next = iterator.next();
          if (next) {
            const occurrence = event.getOccurrenceDetails(next);
            const { startTime: startTime2, endTime: endTime2 } = getTimes(occurrence);
            const isOccurrenceExcluded = exdates.indexOf(startTime2) !== -1;
            const exception = exceptions.find((ex) => ex.uid === event.uid && ex.recurrenceId.toJSDate().getTime() === occurrence.startDate.toJSDate().getTime());
            if (before && startTime2 > before.getTime())
              break;
            if (isEventWithinRange(startTime2, endTime2)) {
              if (exception) {
                ret.events.push(exception);
              } else if (!isOccurrenceExcluded) {
                ret.occurrences.push(occurrence);
              }
            }
          }
        } while (next && (!this.maxIterations || i3 < this.maxIterations));
        return;
      }
      const { startTime, endTime } = getTimes(event);
      if (isEventWithinRange(startTime, endTime))
        ret.events.push(event);
    });
    return ret;
  }
  before(before) {
    return this.between(void 0, before);
  }
  after(after) {
    return this.between(after);
  }
  all() {
    return this.between();
  }
};
var eventSourceDef3 = {
  parseMeta(refined) {
    if (refined.url && refined.format === "ics") {
      return {
        url: refined.url,
        format: "ics"
      };
    }
    return null;
  },
  fetch(arg, successCallback, errorCallback) {
    let meta = arg.eventSource.meta;
    let { internalState } = meta;
    if (!internalState || arg.isRefetch) {
      internalState = meta.internalState = {
        response: null,
        iCalExpanderPromise: fetch(meta.url, { method: "GET" }).then((response) => {
          return response.text().then((icsText) => {
            internalState.response = response;
            return new IcalExpander({
              ics: icsText,
              skipInvalidDates: true
            });
          });
        })
      };
    }
    internalState.iCalExpanderPromise.then((iCalExpander) => {
      successCallback({
        rawEvents: expandICalEvents(iCalExpander, arg.range),
        response: internalState.response
      });
    }, errorCallback);
  }
};
function expandICalEvents(iCalExpander, range2) {
  let rangeStart = addDays(range2.start, -1);
  let rangeEnd = addDays(range2.end, 1);
  let iCalRes = iCalExpander.between(rangeStart, rangeEnd);
  let expanded = [];
  for (let iCalEvent of iCalRes.events) {
    expanded.push(Object.assign(Object.assign({}, buildNonDateProps(iCalEvent)), { start: iCalEvent.startDate.toString(), end: specifiesEnd(iCalEvent) && iCalEvent.endDate ? iCalEvent.endDate.toString() : null }));
  }
  for (let iCalOccurence of iCalRes.occurrences) {
    let iCalEvent = iCalOccurence.item;
    expanded.push(Object.assign(Object.assign({}, buildNonDateProps(iCalEvent)), { start: iCalOccurence.startDate.toString(), end: specifiesEnd(iCalEvent) && iCalOccurence.endDate ? iCalOccurence.endDate.toString() : null }));
  }
  return expanded;
}
function buildNonDateProps(iCalEvent) {
  return {
    title: iCalEvent.summary,
    url: extractEventUrl(iCalEvent),
    extendedProps: {
      location: iCalEvent.location,
      organizer: iCalEvent.organizer,
      description: iCalEvent.description
    }
  };
}
function extractEventUrl(iCalEvent) {
  let urlProp = iCalEvent.component.getFirstProperty("url");
  return urlProp ? urlProp.getFirstValue() : "";
}
function specifiesEnd(iCalEvent) {
  return Boolean(iCalEvent.component.getFirstProperty("dtend")) || Boolean(iCalEvent.component.getFirstProperty("duration"));
}
var index7 = createPlugin({
  name: "@fullcalendar/icalendar",
  eventSourceDefs: [eventSourceDef3]
});

// lib/obsidian-full-calendar/calendar.ts
index3.recurringTypes[0].expand = function(errd, fr, de) {
  const hours = errd.rruleSet._dtstart.getHours();
  return errd.rruleSet.between(de.toDate(fr.start), de.toDate(fr.end), true).map((d2) => {
    return new Date(
      Date.UTC(
        d2.getFullYear(),
        d2.getMonth(),
        d2.getDate(),
        hours,
        d2.getMinutes()
      )
    );
  });
};
function renderCalendar(containerEl, eventSources, settings) {
  var _a;
  const isMobile = window.innerWidth < 500;
  const isNarrow = (settings == null ? void 0 : settings.forceNarrow) || isMobile;
  const {
    eventClick,
    select,
    modifyEvent,
    eventMouseEnter,
    openContextMenuForEvent,
    toggleTask
  } = settings || {};
  const modifyEventCallback = modifyEvent && (async ({
    event,
    oldEvent,
    revert
  }) => {
    const success = await modifyEvent(event, oldEvent);
    if (!success) {
      revert();
    }
  });
  const cal = new Calendar(containerEl, {
    plugins: [
      // View plugins
      index,
      index2,
      index4,
      // multiMonthPlugin,
      // Drag + drop and editing
      index5,
      // Remote sources
      index6,
      index7,
      index3
    ],
    googleCalendarApiKey: "AIzaSyDIiklFwJXaLWuT_4y6I9ZRVVsPuf4xGrk",
    initialView: ((_a = settings == null ? void 0 : settings.initialView) == null ? void 0 : _a[isNarrow ? "mobile" : "desktop"]) || (isNarrow ? "timeGrid3Days" : "timeGridWeek"),
    nowIndicator: true,
    scrollTimeReset: false,
    dayMaxEvents: true,
    expandRows: true,
    slotDuration: (settings == null ? void 0 : settings.slotDuration) || "00:30:00",
    // multiMonthMaxColumns: 1,
    headerToolbar: !isNarrow ? {
      left: "prev,next today",
      center: "title",
      right: "timeGrid5Days,timeGridWeek,listWeek,dayGridMonth,dayGridYear"
    } : !isMobile ? {
      right: "today,prev,next",
      left: "dayGridMonth,timeGrid3Days,listWeek,dayGridYear"
    } : false,
    footerToolbar: isMobile ? {
      right: "today,prev,next",
      left: "timeGrid3Days,dayGridMonth,dayGridYear,timeGridWeek,listWeek"
    } : false,
    views: {
      timeGrid3Days: {
        type: "timeGrid",
        duration: { days: 3 },
        buttonText: "3"
      },
      timeGrid5Days: {
        type: "timeGrid",
        duration: { days: 5 },
        buttonText: "5"
      },
      dayGridMonth: {
        dayMaxEvents: false
      },
      dayGridYear: {
        dayMaxEvents: false
      }
    },
    firstDay: settings == null ? void 0 : settings.firstDay,
    ...(settings == null ? void 0 : settings.timeFormat24h) && {
      eventTimeFormat: {
        hour: "numeric",
        minute: "2-digit",
        hour12: false
      },
      slotLabelFormat: {
        hour: "numeric",
        minute: "2-digit",
        hour12: false
      }
    },
    eventSources,
    eventClick,
    selectable: select && true,
    selectMirror: select && true,
    select: select && (async (info) => {
      await select(info.start, info.end, info.allDay, info.view.type);
      info.view.calendar.unselect();
    }),
    editable: modifyEvent && true,
    eventDrop: modifyEventCallback,
    eventResize: modifyEventCallback,
    eventMouseEnter,
    eventDidMount: ({ event, el, textColor }) => {
      el.addEventListener("contextmenu", (e3) => {
        e3.preventDefault();
        openContextMenuForEvent && openContextMenuForEvent(event, e3);
      });
      if (toggleTask) {
        if (event.extendedProps.isTask) {
          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.checked = event.extendedProps.taskCompleted !== false;
          checkbox.onclick = async (e3) => {
            e3.stopPropagation();
            if (e3.target) {
              let ret = await toggleTask(
                event,
                e3.target.checked
              );
              if (!ret) {
                e3.target.checked = !e3.target.checked;
              }
            }
          };
          if (textColor == "black") {
            checkbox.addClass("ofc-checkbox-black");
          } else {
            checkbox.addClass("ofc-checkbox-white");
          }
          if (checkbox.checked) {
            el.addClass("ofc-task-completed");
          }
          const container = el.querySelector(".fc-event-time") || el.querySelector(".fc-event-title") || el.querySelector(".fc-list-event-title");
          container == null ? void 0 : container.addClass("ofc-has-checkbox");
          container == null ? void 0 : container.prepend(checkbox);
        }
      }
    },
    longPressDelay: 250
  });
  cal.render();
  return cal;
}

// src/views/CalendarView.ts
var CalendarView = class extends import_obsidian.ItemView {
  constructor(leaf, cache, idForCache, event_src, calendarSettings, fileManager, placeForCreatingNote) {
    super(leaf);
    this.calendar = null;
    this.selectedSrcPaths = /* @__PURE__ */ new Set();
    this.cache = cache;
    this.idForCache = idForCache;
    this.event_src = event_src;
    this.fileManager = fileManager;
    this.calendarSettings = calendarSettings;
    this.placeForCreatingNote = placeForCreatingNote;
    for (let src of event_src) {
      this.selectedSrcPaths.add(src.path);
    }
  }
  getViewType() {
    return VIEW_TYPE;
  }
  getDisplayText() {
    return "Calendar";
  }
  async onOpen() {
    if (import_obsidian.Platform.isMobile)
      this.containerEl.style.height = "95vh";
    const { containerEl } = this;
    const container = containerEl.children[1];
    container.empty();
    const calendarContainer = container.createDiv(
      /*{cls: 'class'}*/
    );
    const checkBoxContainer = container.createDiv(
      /*{cls: 'class'}*/
    );
    this.render(calendarContainer).then(
      () => this.renderSrcCheckboxes(checkBoxContainer)
    );
  }
  onResize() {
    var _a;
    (_a = this.calendar) == null ? void 0 : _a.render();
  }
  addFile(page) {
    var _a;
    if (!this.isPageInSelectedSrc(page.file.path)) {
      return;
    }
    const events = pageToEvents(page);
    for (let event of events)
      (_a = this.calendar) == null ? void 0 : _a.addEvent(event);
  }
  changeFile(newPage, oldPage) {
    var _a, _b;
    (_a = this.calendar) == null ? void 0 : _a.pauseRendering();
    this.deleteFile(oldPage);
    this.addFile(newPage);
    (_b = this.calendar) == null ? void 0 : _b.resumeRendering();
  }
  renameFile(newPage, oldPage) {
    this.changeFile(newPage, oldPage);
  }
  deleteFile(page) {
    var _a, _b;
    if (!this.calendar)
      return;
    (_a = this.calendar.getEventById(page.file.path)) == null ? void 0 : _a.remove();
    for (let tick of page.ticks) {
      (_b = this.calendar.getEventById(
        templateIDTick(page.file.path, tick.name)
      )) == null ? void 0 : _b.remove();
    }
  }
  reset() {
    this.onunload();
    this.onOpen();
  }
  onunload() {
    if (!this.calendar)
      return;
    this.calendar.destroy();
    this.calendar = null;
    this.cache.unsubscribe(this.idForCache);
  }
  renderSrcCheckboxes(srcCheckboxContainer) {
    srcCheckboxContainer.empty();
    srcCheckboxContainer.addClass("calendar-src-checkboxes");
    for (let src of this.event_src) {
      const checkboxContainer = srcCheckboxContainer.createDiv({ cls: "src-checkbox-item" });
      const checkbox = checkboxContainer.createEl("input", {
        type: "checkbox",
        attr: {
          id: `src-checkbox-${src.path}`,
          checked: this.selectedSrcPaths.has(src.path) ? "checked" : null
        }
      });
      checkbox.addEventListener("change", () => {
        if (checkbox.checked) {
          this.selectedSrcPaths.add(src.path);
        } else {
          this.selectedSrcPaths.delete(src.path);
        }
        this.refreshCalendar();
      });
      checkboxContainer.createEl("label", {
        text: src.path,
        attr: { for: `src-checkbox-${src.path}` }
      });
    }
  }
  isPathInSrc(pagePath) {
    for (const srcPath of this.selectedSrcPaths) {
      if (pagePath.startsWith(srcPath)) {
        return true;
      }
    }
    return false;
  }
  async refreshCalendar() {
    if (!this.calendar)
      return;
    this.calendar.removeAllEvents();
    const events = [];
    for (let [key, val] of this.localStorage) {
      if (!this.isPathInSrc(key))
        continue;
      for (let page of val)
        events.push(...pageToEvents(page));
    }
    this.calendar;
    events.forEach((event) => {
      var _a;
      return (_a = this.calendar) == null ? void 0 : _a.addEvent(event);
    });
  }
  async render(container) {
    this.localStorage = /* @__PURE__ */ new Map();
    const subscribedData = await this.cache.subscribe(this.idForCache, this.event_src, this);
    for (let data of subscribedData) {
      this.localStorage.set(data.src.path, data.pages);
    }
    const events = [];
    for (const data of subscribedData) {
      if (!this.selectedSrcPaths.has(data.src.path))
        continue;
      for (let page of data.pages) {
        events.push(...pageToEvents(page));
      }
    }
    this.calendar = renderCalendar(
      container,
      {
        //@ts-ignore // TODO remove
        events: [
          ...this.calendarSettings.restTime,
          ...events
        ]
      },
      // as EventSource,
      this.getSettingsCalendar()
    );
    this.calendar.setOption("weekNumbers", true);
    window.setTimeout(
      (_3) => {
        var _a, _b;
        if (import_obsidian.Platform.isMobile)
          (_a = this.calendar) == null ? void 0 : _a.changeView("timeGrid3Days");
        else
          (_b = this.calendar) == null ? void 0 : _b.changeView("timeGridWeek");
      },
      1
    );
    this.calendar.render();
  }
  getSettingsCalendar() {
    const result = {
      firstDay: 1,
      weekNumbers: true,
      timeFormat24h: true,
      // TODO remove any
      eventClick: (arg) => {
        const { event, jsEvent } = arg;
        this.fileManager.openNote(event);
      },
      // TODO remove any
      modifyEvent: async (newPos, oldPos) => {
        var _a, _b;
        const props = newPos.extendedProps;
        const event = {
          start: newPos.start,
          end: newPos.end,
          allDay: newPos.allDay
        };
        if (props.notePath) {
          const page = this.cache.getPage(props.notePath);
          if (!page) {
            console.warn(`${MSG_PLG_NAME}: can't find page by Event. eventID: ${props.notePath}`);
            return false;
          }
          const tick = page.ticks.find(
            (el) => el.name == props.tickName
          );
          if (!tick) {
            console.warn(`${MSG_PLG_NAME}: can't find tick by page. Page - tickName: ${props.notePath} - ${props.tickName}`);
            return false;
          }
          if (tick.ff_duration && oldPos.allDay && !newPos.allDay) {
            event.end = timeAdd(newPos.start, tick.ff_duration);
            newPos.setEnd(event.end);
          }
          const newProp = CalendarEventToIDate(event);
          if (newPos.allDay) {
            newProp["ff_duration"] = millisecToString(
              (_a = tick.ff_duration) == null ? void 0 : _a.as("milliseconds")
            );
          }
          this.fileManager.changeTickFile(props.notePath, props.tickName, newProp);
        } else {
          const page = this.cache.getPage(newPos.id);
          if (!page) {
            console.warn(`${MSG_PLG_NAME}: can't find page by Event. eventID: ${newPos.id}`);
            return false;
          }
          if (page.ff_duration && oldPos.allDay && !newPos.allDay) {
            event.end = timeAdd(newPos.start, page.ff_duration);
            newPos.setEnd(event.end);
          }
          const newProp = CalendarEventToIDate(event);
          if (newPos.allDay) {
            newProp["ff_duration"] = millisecToString(
              (_b = page.ff_duration) == null ? void 0 : _b.as("milliseconds")
            );
          }
          this.fileManager.changePropertyFile(newPos.id, newProp);
        }
        return true;
      },
      select: (start, end, allDay, __viewMode) => {
        new nameModal(
          this.app,
          async (nameOfFile) => {
            try {
              if (!nameOfFile)
                throw 1;
              const pathOfFile = this.placeForCreatingNote + `/${nameOfFile}.md`;
              await this.fileManager.createFile(pathOfFile);
              setTimeout(
                () => this.fileManager.changePropertyFile(
                  pathOfFile,
                  CalendarEventToIDate({ start, end, allDay })
                ),
                1500
              );
            } catch (e3) {
              console.error(e3);
              new import_obsidian.Notice("Hm... error...");
            }
          }
        ).open();
      },
      openContextMenuForEvent: (e3, mouseEvent) => {
        this.contextMenuForEvent(e3, mouseEvent);
      },
      slotDuration: this.calendarSettings.slotDuration
    };
    if (import_obsidian.Platform.isMobile) {
      result.eventClick = (arg) => {
        const { event, jsEvent } = arg;
        this.contextMenuForEvent(event, jsEvent);
      };
      result.openContextMenuForEvent = (_3, __) => {
      };
    }
    return result;
  }
  contextMenuForEvent(event, mouseEvent) {
    const menu = new import_obsidian.Menu();
    menu.addItem(
      (item) => item.setTitle(event.id).onClick(async () => this.fileManager.openNote(event))
    );
    menu.showAtMouseEvent(mouseEvent);
  }
};
var nameModal = class extends import_obsidian.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h1", { text: "Name of task" });
    new import_obsidian.Setting(contentEl).setName("Name").addText(
      (text) => text.onChange((value) => this.result = value)
    );
    new import_obsidian.Setting(contentEl).addButton(
      (btn) => btn.setButtonText("Submit").setCta().onClick(() => {
        this.close();
        this.onSubmit(this.result);
      })
    );
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/cache.ts
var import_obsidian2 = require("obsidian");
var Cache2 = class {
  constructor(parrentPointer, fileManager) {
    this.storage = /* @__PURE__ */ new Map();
    this.subscribers = /* @__PURE__ */ new Map();
    this.initSync = new Promise(
      (resolve) => this.initSyncResolve = resolve
    );
    this.isInited = false;
    this.parrentPointer = parrentPointer;
    this.parrentPointer.app.workspace.onLayoutReady(() => this.initStorage());
  }
  getPage(path) {
    return this.storage.get(path);
  }
  log() {
    console.log("storage", this.storage);
    console.log("subscribers", this.subscribers);
  }
  async subscribe(id, paths, subscriber) {
    this.subscribers.set(
      id,
      {
        paths,
        subscriber
      }
    );
    if (!this.isInited)
      await this.initSync;
    const result = [];
    for (let path of paths) {
      const pages = [];
      for (let [key, value] of this.storage) {
        if (key.startsWith(path.path)) {
          pages.push(value);
        }
      }
      result.push({
        src: path,
        pages
      });
    }
    return result;
  }
  unsubscribe(id) {
    this.subscribers.delete(id);
  }
  renameFile(file, oldPath) {
    if (!this.isInited)
      return;
    const oldPage = this.storage.get(oldPath);
    const page = { ...oldPage };
    page.file = { ...oldPage.file };
    page.file.path = file.path;
    page.file.name = file.basename;
    this.storage.delete(oldPath);
    this.storage.set(file.path, page);
    for (let [_3, { paths, subscriber }] of this.subscribers) {
      for (let path of paths) {
        if (file.path.startsWith(path.path) && oldPath.startsWith(path.path))
          subscriber.renameFile(page, oldPage);
        else if (oldPath.startsWith(path.path))
          subscriber.deleteFile(oldPage);
        else if (file.path.startsWith(path.path))
          subscriber.addFile(page);
      }
    }
  }
  async addFile(file) {
    if (!this.isInited)
      return;
    const page = await this.parrentPointer.fileManager.getPage(file);
    this.storage.set(file.path, page);
    for (let [_3, { paths, subscriber }] of this.subscribers) {
      for (let path of paths) {
        if (!file.path.startsWith(path.path))
          continue;
        subscriber.addFile(page);
      }
    }
  }
  async changeFile(file) {
    if (!this.isInited)
      return;
    const page = await this.parrentPointer.fileManager.getPage(file);
    const oldPage = this.storage.get(file.path);
    if (isEqualObj(page, oldPage))
      return;
    this.storage.set(file.path, page);
    for (let [_3, { paths, subscriber }] of this.subscribers) {
      for (let path of paths) {
        if (!file.path.startsWith(path.path))
          continue;
        subscriber.changeFile(page, oldPage);
      }
    }
  }
  deleteFile(file) {
    if (!this.isInited)
      return;
    const page = this.storage.get(file.path);
    this.storage.delete(file.path);
    for (let [_3, { paths, subscriber }] of this.subscribers) {
      for (let path of paths) {
        if (!file.path.startsWith(path.path))
          continue;
        subscriber.deleteFile(page);
      }
    }
  }
  async reset() {
    this.isInited = false;
    this.storage.clear();
    const tmp = this.subscribers;
    this.subscribers = /* @__PURE__ */ new Map();
    await this.initStorage();
    for (let [_3, { subscriber }] of tmp)
      subscriber.reset();
  }
  async initStorage() {
    const tFiles = this.parrentPointer.app.vault.getMarkdownFiles();
    const notice = new import_obsidian2.Notice(
      `${MSG_PLG_NAME}: there are ${tFiles.length} notes`,
      1e3 * 60
      // 60 seconds
    );
    for (let i3 in tFiles) {
      const tFile = tFiles[i3];
      notice.setMessage(`${MSG_PLG_NAME}: (${i3}/${tFiles.length}) added ${tFile.path}`);
      this.storage.set(
        tFile.path,
        await this.parrentPointer.fileManager.getPage(tFile)
      );
    }
    notice.hide();
    new import_obsidian2.Notice(`${MSG_PLG_NAME}: cache has been inited`);
    this.initSyncResolve();
    this.isInited = true;
  }
};

// src/setting.ts
var import_obsidian3 = require("obsidian");
var MySettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    let { containerEl } = this;
    containerEl.empty();
    const settings = this.plugin.getSettings();
    new import_obsidian3.Setting(containerEl).setHeading().setName("It's recommended to reload ObsidianApp after changing the settings");
    new import_obsidian3.Setting(containerEl).addButton(
      (btn) => {
        btn.setButtonText("Set Default Values").onClick(
          () => {
            this.plugin.saveSettings(DEFAULT_SETTINGS);
            new import_obsidian3.Notice(MSG_PLG_NAME + "The default settings has been applied");
          }
        );
      }
    );
    new import_obsidian3.Setting(containerEl).setHeading();
    new import_obsidian3.Setting(containerEl).setName("Calendar").setHeading();
    new import_obsidian3.Setting(containerEl).setName("Slot duration").setDesc(`Default: ${DEFAULT_SETTINGS.calendar.slotDuration}`).addText(
      (component) => {
        component.setPlaceholder("hh:mm:ss").setValue(settings.calendar.slotDuration).onChange(
          (value) => {
            settings.calendar.slotDuration = value;
            this.plugin.saveSettings(settings);
          }
        );
      }
    );
    new import_obsidian3.Setting(containerEl).setName("Colours").setHeading();
    for (let key of Object.keys(settings.calendar.colours)) {
      this.addColourSetting(
        containerEl,
        key,
        DEFAULT_SETTINGS.calendar.colours[key],
        settings.calendar.colours[key],
        (val) => {
          settings.calendar.colours[key] = val;
          this.plugin.saveSettings(settings);
        }
      );
    }
    new import_obsidian3.Setting(containerEl).setName("RestTime").setHeading();
    for (let index8 in settings.calendar.restTime) {
      const el = settings.calendar.restTime[index8];
      let name = "";
      if (el.color === COLOUR_REST) {
        name = "Rest time";
      } else if (el.color === COLOUR_SLEEP) {
        name = "Sleep time";
      } else
        continue;
      new import_obsidian3.Setting(containerEl).setName(`Start of ${name} (${index8})`).addText(
        (text) => {
          text.setValue(el.startTime).setPlaceholder("hh:mm:ss").onChange(
            (val) => {
              settings.calendar.restTime[index8].startTime = val;
              this.plugin.saveSettings(settings);
            }
          );
        }
      );
      new import_obsidian3.Setting(containerEl).setName(`End of ${name} (${index8})`).addText(
        (text) => {
          text.setValue(el.endTime).setPlaceholder("hh:mm:ss").onChange(
            (val) => {
              settings.calendar.restTime[index8].endTime = val;
              this.plugin.saveSettings(settings);
            }
          );
        }
      );
    }
    new import_obsidian3.Setting(containerEl).setHeading();
    new import_obsidian3.Setting(containerEl).setName("StatusCorrector").setHeading();
    const statusCorrector = settings.statusCorrector.isOn;
    new import_obsidian3.Setting(containerEl).setName("Enable tool").addToggle(
      (toggle) => toggle.setValue(statusCorrector).onChange(
        (value) => {
          settings.statusCorrector.isOn = value;
          this.plugin.saveSettings(settings);
          this.display();
        }
      )
    );
    if (statusCorrector) {
      new import_obsidian3.Setting(containerEl).setName("Start on Start Up").addToggle(
        (toggle) => toggle.setValue(settings.statusCorrector.startOnStartUp).onChange(
          (val) => {
            settings.statusCorrector.startOnStartUp = val;
            this.plugin.saveSettings(settings);
          }
        )
      );
    }
  }
  addColourSetting(containerEl, name, defaultValue, currentValue, callback) {
    new import_obsidian3.Setting(containerEl).setName(name).setDesc(`Default: ${defaultValue}`).addText(
      (component) => {
        component.setPlaceholder("#0f0f0f").setValue(currentValue).onChange((val) => callback(val));
      }
    );
  }
};

// src/fileManager.ts
var import_obsidian4 = require("obsidian");
var FileManager = class {
  constructor(plg) {
    this.app = plg.app;
  }
  async createFile(path) {
    await this.app.vault.create(path, "");
    new import_obsidian4.Notice(MSG_PLG_NAME + "created " + path);
  }
  async changePropertyFile(path, event) {
    const tFile = this.app.metadataCache.getFirstLinkpathDest(path, "");
    await this.app.fileManager.processFrontMatter(
      tFile,
      (property) => {
        property["ff_date"] = event["ff_date"].toISOString().slice(0, -14);
        property["ff_timeStart"] = event["ff_timeStart"];
        property["ff_duration"] = event["ff_duration"];
      }
    );
  }
  async changeStatusFile(path, status) {
    const tFile = this.app.metadataCache.getFirstLinkpathDest(path, "");
    await this.app.fileManager.processFrontMatter(
      tFile,
      (property) => {
        property["ff_status"] = status;
      }
    );
  }
  async changeTickFile(path, tickname, event) {
    const tFile = this.app.metadataCache.getFirstLinkpathDest(path, "");
    const text = await this.app.vault.read(tFile);
    const regExp = new RegExp(`\\[t::\\s*${tickname}(,[^\\]]*|)\\]`, "gm");
    const date = event["ff_date"].toISOString().slice(0, -14);
    const newString = `[t::${tickname},${date},${event["ff_timeStart"]},${event["ff_duration"]}]`;
    await this.app.vault.modify(
      tFile,
      text.replace(regExp, newString)
    );
  }
  openNote(event) {
    var _a;
    const tFile = this.app.metadataCache.getFirstLinkpathDest(
      ((_a = event == null ? void 0 : event.extendedProps) == null ? void 0 : _a.notePath) || event.id,
      ""
    );
    const leaf = this.app.workspace.getLeaf(true);
    tFile && leaf.openFile(tFile);
  }
  async getPage(file) {
    var _a;
    const result = {
      file: {
        path: file.path,
        name: file.basename
      },
      ticks: getTicksFromText(await this.app.vault.cachedRead(file)),
      ff_duration: "",
      ff_timeStart: "",
      // TODO - ,      ff_date,    null,   bad practice
      //@ts-ignore
      ff_date: null
    };
    const property = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
    if (!property) {
      return result;
    }
    const added = {
      ff_duration: dv.duration(property.ff_duration),
      ff_timeStart: dv.duration(property.ff_timeStart),
      ff_date: dv.date(property.ff_date),
      ff_status: property.ff_status
    };
    return {
      ...result,
      ...added
    };
  }
  getTaskCount(page) {
    var _a;
    const result = {
      done: 0,
      all: 0
    };
    const tFile = this.app.vault.getFileByPath(page.file.path);
    if (!tFile)
      return result;
    const items = (_a = this.app.metadataCache.getFileCache(tFile)) == null ? void 0 : _a.listItems;
    if (items)
      for (let item of items) {
        if (item.task == void 0)
          continue;
        if (item.task == "x") {
          ++result.done;
        }
        ++result.all;
      }
    return result;
  }
  async getText(path) {
    const tFile = this.app.metadataCache.getFirstLinkpathDest(path, "");
    const text = await this.app.vault.read(tFile);
    return text;
  }
  async setText(path, text) {
    const tFile = this.app.metadataCache.getFirstLinkpathDest(path, "");
    await this.app.vault.modify(tFile, text);
  }
};

// src/views/TickCheker.ts
var import_obsidian5 = require("obsidian");
var TickChecker = class {
  constructor(idForCache, event_src, ptr) {
    this.parent = ptr;
    this.idForCache = idForCache;
    this.parent.cache.subscribe(idForCache, event_src, this).then((data) => this.process(data));
  }
  async process(pages) {
    for (let page of pages) {
      for (let tick of page.ticks) {
        if (isNaN(safeParseInt(tick.name)))
          continue;
        let text = await this.parent.fileManager.getText(page.file.path);
        const regExp = new RegExp(`\\[t::\\s*${tick.name}(,[^\\]]*|)\\]`, "gm");
        await this.parent.fileManager.setText(
          page.file.path,
          text.replace(regExp, `[t::${tick.name}_$1]`)
        );
        new import_obsidian5.Notice(MSG_PLG_NAME + `change tickname in ${page.file.name}: ${tick.name}`);
      }
    }
    this.parent.cache.unsubscribe(this.idForCache);
  }
  renameFile(newPage, oldPage) {
  }
  deleteFile(page) {
  }
  addFile(page) {
  }
  changeFile(newPage, oldPage) {
  }
  reset() {
  }
};

// src/main.ts
var MyPlugin = class extends import_obsidian6.Plugin {
  constructor(app, manifest) {
    super(app, manifest);
    const fileManager = new FileManager(this);
    this.fileManager = fileManager;
    this.cache = new Cache2(this, fileManager);
  }
  async onload() {
    await this.loadSettings();
    this.initRegister();
    await new TickChecker(3 /* TICK_CHECKER */, this.settings.source.noteSources, this);
    this.registerView(
      VIEW_TYPE,
      (leaf) => new CalendarView(
        leaf,
        1 /* CALENDAR */,
        this.settings.source.noteSources,
        this,
        this.settings.source.defaultCreatePath
      )
    );
    this.addRibbonIcon("info", MSG_PLG_NAME + "Open Calendar", () => this.activateView());
    this.addCommand({
      id: "reset-cache",
      name: MSG_PLG_NAME + "Reset Cache",
      callback: () => {
        this.cache.reset();
      }
    });
    this.addCommand({
      id: "log-cache",
      name: MSG_PLG_NAME + "Log Cache",
      callback: () => {
        this.cache.log();
      }
    });
  }
  onunload() {
    if (this.settings.statusCorrector.isOn)
      this.statusCorrector.destroy();
  }
  initRegister() {
    this.registerEvent(
      this.app.metadataCache.on("changed", (file) => {
        this.cache.changeFile(file);
      })
    );
    this.registerEvent(
      this.app.vault.on(
        "rename",
        (file, oldPath) => {
          if (!file.basename)
            return;
          this.cache.renameFile(file, oldPath);
        }
      )
    );
    this.registerEvent(
      this.app.vault.on(
        "delete",
        (file) => this.cache.deleteFile(file)
      )
    );
    this.registerEvent(
      this.app.vault.on(
        "create",
        (file) => {
          if (!file.basename)
            return;
          this.cache.addFile(file);
        }
      )
    );
  }
  async activateView() {
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE);
    if (leaves.length === 0) {
      const leaf = this.app.workspace.getLeaf(false);
      await leaf.setViewState({
        type: VIEW_TYPE,
        active: true
      });
    } else if (leaves.length === 1) {
      leaves[0].view.onOpen();
      this.app.workspace.setActiveLeaf(leaves[0]);
    } else
      for (let leaf of leaves)
        leaf.detach();
  }
  // Settings
  getSettings() {
    return JSON.parse(
      JSON.stringify(this.settings)
    );
  }
  async saveSettings(settings) {
    this.settings = settings;
    await this.saveData(this.settings);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    this.addSettingTab(new MySettingTab(this.app, this));
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvZXJyb3JzLmpzIiwgIm5vZGVfbW9kdWxlcy9vYnNpZGlhbi1kYXRhdmlldy9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvZm9ybWF0cy5qcyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy96b25lLmpzIiwgIm5vZGVfbW9kdWxlcy9vYnNpZGlhbi1kYXRhdmlldy9ub2RlX21vZHVsZXMvbHV4b24vc3JjL3pvbmVzL3N5c3RlbVpvbmUuanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvem9uZXMvSUFOQVpvbmUuanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9sb2NhbGUuanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvem9uZXMvZml4ZWRPZmZzZXRab25lLmpzIiwgIm5vZGVfbW9kdWxlcy9vYnNpZGlhbi1kYXRhdmlldy9ub2RlX21vZHVsZXMvbHV4b24vc3JjL3pvbmVzL2ludmFsaWRab25lLmpzIiwgIm5vZGVfbW9kdWxlcy9vYnNpZGlhbi1kYXRhdmlldy9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvem9uZVV0aWwuanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvc2V0dGluZ3MuanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC91dGlsLmpzIiwgIm5vZGVfbW9kdWxlcy9vYnNpZGlhbi1kYXRhdmlldy9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvZW5nbGlzaC5qcyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2Zvcm1hdHRlci5qcyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2ludmFsaWQuanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9yZWdleFBhcnNlci5qcyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9kdXJhdGlvbi5qcyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbnRlcnZhbC5qcyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbmZvLmpzIiwgIm5vZGVfbW9kdWxlcy9vYnNpZGlhbi1kYXRhdmlldy9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvZGlmZi5qcyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2RpZ2l0cy5qcyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL3Rva2VuUGFyc2VyLmpzIiwgIm5vZGVfbW9kdWxlcy9vYnNpZGlhbi1kYXRhdmlldy9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvY29udmVyc2lvbnMuanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvZGF0ZXRpbWUuanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L3NyYy9zZXR0aW5ncy50cyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvc3JjL2FwaS9yZXN1bHQudHMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9wYXJzaW1tb24vYnVpbGQvcGFyc2ltbW9uLnVtZC5taW4uanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9lbW9qaS1yZWdleC9pbmRleC5tanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L3NyYy91dGlsL25vcm1hbGl6ZS50cyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvc3JjL2RhdGEtbW9kZWwvdmFsdWUudHMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L3NyYy9leHByZXNzaW9uL2ZpZWxkLnRzIiwgIm5vZGVfbW9kdWxlcy9vYnNpZGlhbi1kYXRhdmlldy9zcmMvZGF0YS1pbmRleC9zb3VyY2UudHMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L3NyYy9leHByZXNzaW9uL3BhcnNlLnRzIiwgIm5vZGVfbW9kdWxlcy9vYnNpZGlhbi1kYXRhdmlldy9zcmMvcXVlcnkvcXVlcnkudHMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L3NyYy9xdWVyeS9wYXJzZS50cyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvc3JjL2luZGV4LnRzIiwgIm5vZGVfbW9kdWxlcy9pY2FsLmpzL2J1aWxkL2ljYWwuanMiLCAic3JjL21haW4udHMiLCAic3JjL3ZpZXdzL0NhbGVuZGFyVmlldy50cyIsICJzcmMvdHlwZXMudHMiLCAic3JjL2NvbnN0YW50cy50cyIsICJzcmMvdXRpbC50cyIsICJub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL25vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL3V0aWwuanMiLCAibm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvY29yZS9ub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9vcHRpb25zLmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvbm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvY3JlYXRlLWVsZW1lbnQuanMiLCAibm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvY29yZS9ub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9kaWZmL3Byb3BzLmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvbm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvY29tcG9uZW50LmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvbm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvY3JlYXRlLWNvbnRleHQuanMiLCAibm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvY29yZS9ub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9jb25zdGFudHMuanMiLCAibm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvY29yZS9ub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9kaWZmL2NoaWxkcmVuLmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvbm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvZGlmZi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL25vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL3JlbmRlci5qcyIsICJub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL25vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL2Nsb25lLWVsZW1lbnQuanMiLCAibm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvY29yZS9ub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9kaWZmL2NhdGNoLWVycm9yLmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvbm9kZV9tb2R1bGVzL3ByZWFjdC9ob29rcy9zcmMvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvY29yZS9ub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvdXRpbC5qcyIsICJub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL25vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy9QdXJlQ29tcG9uZW50LmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvbm9kZV9tb2R1bGVzL3ByZWFjdC9jb21wYXQvc3JjL21lbW8uanMiLCAibm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvY29yZS9ub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvZm9yd2FyZFJlZi5qcyIsICJub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL25vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy9DaGlsZHJlbi5qcyIsICJub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL25vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy9zdXNwZW5zZS5qcyIsICJub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL25vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy9zdXNwZW5zZS1saXN0LmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvbm9kZV9tb2R1bGVzL3ByZWFjdC9jb21wYXQvc3JjL3BvcnRhbHMuanMiLCAibm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvY29yZS9ub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvcmVuZGVyLmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvbm9kZV9tb2R1bGVzL3ByZWFjdC9jb21wYXQvc3JjL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvaW50ZXJuYWwtY29tbW9uLmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvZGF5Z3JpZC9pbnRlcm5hbC5qcyIsICJub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9kYXlncmlkL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL3RpbWVncmlkL2ludGVybmFsLmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL3RpbWVncmlkL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvd2Vla2RheS50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2hlbHBlcnMudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9kYXRldXRpbC50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2l0ZXJyZXN1bHQudHMiLCAibm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2NhbGxiYWNraXRlcnJlc3VsdC50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL25scC9pMThuLnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvbmxwL3RvdGV4dC50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL25scC9wYXJzZXRleHQudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy90eXBlcy50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL25scC9pbmRleC50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2RhdGV0aW1lLnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvcGFyc2VvcHRpb25zLnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvcGFyc2VzdHJpbmcudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9kYXRld2l0aHpvbmUudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9vcHRpb25zdG9zdHJpbmcudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9jYWNoZS50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL21hc2tzLnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvaXRlcmluZm8veWVhcmluZm8udHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9pdGVyaW5mby9tb250aGluZm8udHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9pdGVyaW5mby9lYXN0ZXIudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9pdGVyaW5mby9pbmRleC50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2l0ZXIvcG9zbGlzdC50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2l0ZXIvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9ycnVsZS50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2l0ZXJzZXQudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9ycnVsZXN0ci50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL3JydWxlc2V0LnRzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL3JydWxlL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2xpc3QvaW50ZXJuYWwuanMiLCAibm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvbGlzdC9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9pbnRlcmFjdGlvbi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9nb29nbGUtY2FsZW5kYXIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvaWNhbGVuZGFyL2luZGV4LmpzIiwgImxpYi9vYnNpZGlhbi1mdWxsLWNhbGVuZGFyL2NhbGVuZGFyLnRzIiwgInNyYy9jYWNoZS50cyIsICJzcmMvc2V0dGluZy50cyIsICJzcmMvZmlsZU1hbmFnZXIudHMiLCAic3JjL3ZpZXdzL1RpY2tDaGVrZXIudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8vIHRoZXNlIGFyZW4ndCByZWFsbHkgcHJpdmF0ZSwgYnV0IG5vciBhcmUgdGhleSByZWFsbHkgdXNlZnVsIHRvIGRvY3VtZW50XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgTHV4b25FcnJvciBleHRlbmRzIEVycm9yIHt9XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWREYXRlVGltZUVycm9yIGV4dGVuZHMgTHV4b25FcnJvciB7XG4gIGNvbnN0cnVjdG9yKHJlYXNvbikge1xuICAgIHN1cGVyKGBJbnZhbGlkIERhdGVUaW1lOiAke3JlYXNvbi50b01lc3NhZ2UoKX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkSW50ZXJ2YWxFcnJvciBleHRlbmRzIEx1eG9uRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihyZWFzb24pIHtcbiAgICBzdXBlcihgSW52YWxpZCBJbnRlcnZhbDogJHtyZWFzb24udG9NZXNzYWdlKCl9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZER1cmF0aW9uRXJyb3IgZXh0ZW5kcyBMdXhvbkVycm9yIHtcbiAgY29uc3RydWN0b3IocmVhc29uKSB7XG4gICAgc3VwZXIoYEludmFsaWQgRHVyYXRpb246ICR7cmVhc29uLnRvTWVzc2FnZSgpfWApO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yIGV4dGVuZHMgTHV4b25FcnJvciB7fVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkVW5pdEVycm9yIGV4dGVuZHMgTHV4b25FcnJvciB7XG4gIGNvbnN0cnVjdG9yKHVuaXQpIHtcbiAgICBzdXBlcihgSW52YWxpZCB1bml0ICR7dW5pdH1gKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkQXJndW1lbnRFcnJvciBleHRlbmRzIEx1eG9uRXJyb3Ige31cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgWm9uZUlzQWJzdHJhY3RFcnJvciBleHRlbmRzIEx1eG9uRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIlpvbmUgaXMgYW4gYWJzdHJhY3QgY2xhc3NcIik7XG4gIH1cbn1cbiIsICIvKipcbiAqIEBwcml2YXRlXG4gKi9cblxuY29uc3QgbiA9IFwibnVtZXJpY1wiLFxuICBzID0gXCJzaG9ydFwiLFxuICBsID0gXCJsb25nXCI7XG5cbmV4cG9ydCBjb25zdCBEQVRFX1NIT1JUID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbixcbiAgZGF5OiBuLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVfTUVEID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogcyxcbiAgZGF5OiBuLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVfTUVEX1dJVEhfV0VFS0RBWSA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IHMsXG4gIGRheTogbixcbiAgd2Vla2RheTogcyxcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFX0ZVTEwgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBsLFxuICBkYXk6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgREFURV9IVUdFID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbCxcbiAgZGF5OiBuLFxuICB3ZWVrZGF5OiBsLFxufTtcblxuZXhwb3J0IGNvbnN0IFRJTUVfU0lNUExFID0ge1xuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgVElNRV9XSVRIX1NFQ09ORFMgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxufTtcblxuZXhwb3J0IGNvbnN0IFRJTUVfV0lUSF9TSE9SVF9PRkZTRVQgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxuICB0aW1lWm9uZU5hbWU6IHMsXG59O1xuXG5leHBvcnQgY29uc3QgVElNRV9XSVRIX0xPTkdfT0ZGU0VUID0ge1xuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbiAgdGltZVpvbmVOYW1lOiBsLFxufTtcblxuZXhwb3J0IGNvbnN0IFRJTUVfMjRfU0lNUExFID0ge1xuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIGhvdXJDeWNsZTogXCJoMjNcIixcbn07XG5cbmV4cG9ydCBjb25zdCBUSU1FXzI0X1dJVEhfU0VDT05EUyA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG4gIGhvdXJDeWNsZTogXCJoMjNcIixcbn07XG5cbmV4cG9ydCBjb25zdCBUSU1FXzI0X1dJVEhfU0hPUlRfT0ZGU0VUID0ge1xuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbiAgaG91ckN5Y2xlOiBcImgyM1wiLFxuICB0aW1lWm9uZU5hbWU6IHMsXG59O1xuXG5leHBvcnQgY29uc3QgVElNRV8yNF9XSVRIX0xPTkdfT0ZGU0VUID0ge1xuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbiAgaG91ckN5Y2xlOiBcImgyM1wiLFxuICB0aW1lWm9uZU5hbWU6IGwsXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfU0hPUlQgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBuLFxuICBkYXk6IG4sXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFVElNRV9TSE9SVF9XSVRIX1NFQ09ORFMgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBuLFxuICBkYXk6IG4sXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX01FRCA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IHMsXG4gIGRheTogbixcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX01FRF9XSVRIX1NFQ09ORFMgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBzLFxuICBkYXk6IG4sXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX01FRF9XSVRIX1dFRUtEQVkgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBzLFxuICBkYXk6IG4sXG4gIHdlZWtkYXk6IHMsXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFVElNRV9GVUxMID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbCxcbiAgZGF5OiBuLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHRpbWVab25lTmFtZTogcyxcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFVElNRV9GVUxMX1dJVEhfU0VDT05EUyA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IGwsXG4gIGRheTogbixcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG4gIHRpbWVab25lTmFtZTogcyxcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFVElNRV9IVUdFID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbCxcbiAgZGF5OiBuLFxuICB3ZWVrZGF5OiBsLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHRpbWVab25lTmFtZTogbCxcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFVElNRV9IVUdFX1dJVEhfU0VDT05EUyA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IGwsXG4gIGRheTogbixcbiAgd2Vla2RheTogbCxcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG4gIHRpbWVab25lTmFtZTogbCxcbn07XG4iLCAiaW1wb3J0IHsgWm9uZUlzQWJzdHJhY3RFcnJvciB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuXG4vKipcbiAqIEBpbnRlcmZhY2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgWm9uZSB7XG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB6b25lXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IHR5cGUoKSB7XG4gICAgdGhyb3cgbmV3IFpvbmVJc0Fic3RyYWN0RXJyb3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGlzIHpvbmUuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG5hbWUoKSB7XG4gICAgdGhyb3cgbmV3IFpvbmVJc0Fic3RyYWN0RXJyb3IoKTtcbiAgfVxuXG4gIGdldCBpYW5hTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgb2Zmc2V0IGlzIGtub3duIHRvIGJlIGZpeGVkIGZvciB0aGUgd2hvbGUgeWVhci5cbiAgICogQGFic3RyYWN0XG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzVW5pdmVyc2FsKCkge1xuICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb2Zmc2V0J3MgY29tbW9uIG5hbWUgKHN1Y2ggYXMgRVNUKSBhdCB0aGUgc3BlY2lmaWVkIHRpbWVzdGFtcFxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRzIC0gRXBvY2ggbWlsbGlzZWNvbmRzIGZvciB3aGljaCB0byBnZXQgdGhlIG5hbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBPcHRpb25zIHRvIGFmZmVjdCB0aGUgZm9ybWF0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLmZvcm1hdCAtIFdoYXQgc3R5bGUgb2Ygb2Zmc2V0IHRvIHJldHVybi4gQWNjZXB0cyAnbG9uZycgb3IgJ3Nob3J0Jy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubG9jYWxlIC0gV2hhdCBsb2NhbGUgdG8gcmV0dXJuIHRoZSBvZmZzZXQgbmFtZSBpbi5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgb2Zmc2V0TmFtZSh0cywgb3B0cykge1xuICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb2Zmc2V0J3MgdmFsdWUgYXMgYSBzdHJpbmdcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0cyAtIEVwb2NoIG1pbGxpc2Vjb25kcyBmb3Igd2hpY2ggdG8gZ2V0IHRoZSBvZmZzZXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdCAtIFdoYXQgc3R5bGUgb2Ygb2Zmc2V0IHRvIHJldHVybi5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIEFjY2VwdHMgJ25hcnJvdycsICdzaG9ydCcsIG9yICd0ZWNoaWUnLiBSZXR1cm5pbmcgJys2JywgJyswNjowMCcsIG9yICcrMDYwMCcgcmVzcGVjdGl2ZWx5XG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGZvcm1hdE9mZnNldCh0cywgZm9ybWF0KSB7XG4gICAgdGhyb3cgbmV3IFpvbmVJc0Fic3RyYWN0RXJyb3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG9mZnNldCBpbiBtaW51dGVzIGZvciB0aGlzIHpvbmUgYXQgdGhlIHNwZWNpZmllZCB0aW1lc3RhbXAuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge251bWJlcn0gdHMgLSBFcG9jaCBtaWxsaXNlY29uZHMgZm9yIHdoaWNoIHRvIGNvbXB1dGUgdGhlIG9mZnNldFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBvZmZzZXQodHMpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgWm9uZSBpcyBlcXVhbCB0byBhbm90aGVyIHpvbmVcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7Wm9uZX0gb3RoZXJab25lIC0gdGhlIHpvbmUgdG8gY29tcGFyZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZXF1YWxzKG90aGVyWm9uZSkge1xuICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBab25lIGlzIHZhbGlkLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG59XG4iLCAiaW1wb3J0IHsgZm9ybWF0T2Zmc2V0LCBwYXJzZVpvbmVJbmZvIH0gZnJvbSBcIi4uL2ltcGwvdXRpbC5qc1wiO1xuaW1wb3J0IFpvbmUgZnJvbSBcIi4uL3pvbmUuanNcIjtcblxubGV0IHNpbmdsZXRvbiA9IG51bGw7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgbG9jYWwgem9uZSBmb3IgdGhpcyBKYXZhU2NyaXB0IGVudmlyb25tZW50LlxuICogQGltcGxlbWVudHMge1pvbmV9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN5c3RlbVpvbmUgZXh0ZW5kcyBab25lIHtcbiAgLyoqXG4gICAqIEdldCBhIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiB0aGUgbG9jYWwgem9uZVxuICAgKiBAcmV0dXJuIHtTeXN0ZW1ab25lfVxuICAgKi9cbiAgc3RhdGljIGdldCBpbnN0YW5jZSgpIHtcbiAgICBpZiAoc2luZ2xldG9uID09PSBudWxsKSB7XG4gICAgICBzaW5nbGV0b24gPSBuZXcgU3lzdGVtWm9uZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc2luZ2xldG9uO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIFwic3lzdGVtXCI7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoKS5yZXNvbHZlZE9wdGlvbnMoKS50aW1lWm9uZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBpc1VuaXZlcnNhbCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBvZmZzZXROYW1lKHRzLCB7IGZvcm1hdCwgbG9jYWxlIH0pIHtcbiAgICByZXR1cm4gcGFyc2Vab25lSW5mbyh0cywgZm9ybWF0LCBsb2NhbGUpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZm9ybWF0T2Zmc2V0KHRzLCBmb3JtYXQpIHtcbiAgICByZXR1cm4gZm9ybWF0T2Zmc2V0KHRoaXMub2Zmc2V0KHRzKSwgZm9ybWF0KTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIG9mZnNldCh0cykge1xuICAgIHJldHVybiAtbmV3IERhdGUodHMpLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBlcXVhbHMob3RoZXJab25lKSB7XG4gICAgcmV0dXJuIG90aGVyWm9uZS50eXBlID09PSBcInN5c3RlbVwiO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBmb3JtYXRPZmZzZXQsIHBhcnNlWm9uZUluZm8sIGlzVW5kZWZpbmVkLCBvYmpUb0xvY2FsVFMgfSBmcm9tIFwiLi4vaW1wbC91dGlsLmpzXCI7XG5pbXBvcnQgWm9uZSBmcm9tIFwiLi4vem9uZS5qc1wiO1xuXG5sZXQgZHRmQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIG1ha2VEVEYoem9uZSkge1xuICBpZiAoIWR0ZkNhY2hlW3pvbmVdKSB7XG4gICAgZHRmQ2FjaGVbem9uZV0gPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChcImVuLVVTXCIsIHtcbiAgICAgIGhvdXIxMjogZmFsc2UsXG4gICAgICB0aW1lWm9uZTogem9uZSxcbiAgICAgIHllYXI6IFwibnVtZXJpY1wiLFxuICAgICAgbW9udGg6IFwiMi1kaWdpdFwiLFxuICAgICAgZGF5OiBcIjItZGlnaXRcIixcbiAgICAgIGhvdXI6IFwiMi1kaWdpdFwiLFxuICAgICAgbWludXRlOiBcIjItZGlnaXRcIixcbiAgICAgIHNlY29uZDogXCIyLWRpZ2l0XCIsXG4gICAgICBlcmE6IFwic2hvcnRcIixcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZHRmQ2FjaGVbem9uZV07XG59XG5cbmNvbnN0IHR5cGVUb1BvcyA9IHtcbiAgeWVhcjogMCxcbiAgbW9udGg6IDEsXG4gIGRheTogMixcbiAgZXJhOiAzLFxuICBob3VyOiA0LFxuICBtaW51dGU6IDUsXG4gIHNlY29uZDogNixcbn07XG5cbmZ1bmN0aW9uIGhhY2t5T2Zmc2V0KGR0ZiwgZGF0ZSkge1xuICBjb25zdCBmb3JtYXR0ZWQgPSBkdGYuZm9ybWF0KGRhdGUpLnJlcGxhY2UoL1xcdTIwMEUvZywgXCJcIiksXG4gICAgcGFyc2VkID0gLyhcXGQrKVxcLyhcXGQrKVxcLyhcXGQrKSAoQUR8QkMpLD8gKFxcZCspOihcXGQrKTooXFxkKykvLmV4ZWMoZm9ybWF0dGVkKSxcbiAgICBbLCBmTW9udGgsIGZEYXksIGZZZWFyLCBmYWRPckJjLCBmSG91ciwgZk1pbnV0ZSwgZlNlY29uZF0gPSBwYXJzZWQ7XG4gIHJldHVybiBbZlllYXIsIGZNb250aCwgZkRheSwgZmFkT3JCYywgZkhvdXIsIGZNaW51dGUsIGZTZWNvbmRdO1xufVxuXG5mdW5jdGlvbiBwYXJ0c09mZnNldChkdGYsIGRhdGUpIHtcbiAgY29uc3QgZm9ybWF0dGVkID0gZHRmLmZvcm1hdFRvUGFydHMoZGF0ZSk7XG4gIGNvbnN0IGZpbGxlZCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGZvcm1hdHRlZC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHsgdHlwZSwgdmFsdWUgfSA9IGZvcm1hdHRlZFtpXTtcbiAgICBjb25zdCBwb3MgPSB0eXBlVG9Qb3NbdHlwZV07XG5cbiAgICBpZiAodHlwZSA9PT0gXCJlcmFcIikge1xuICAgICAgZmlsbGVkW3Bvc10gPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKCFpc1VuZGVmaW5lZChwb3MpKSB7XG4gICAgICBmaWxsZWRbcG9zXSA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBmaWxsZWQ7XG59XG5cbmxldCBpYW5hWm9uZUNhY2hlID0ge307XG4vKipcbiAqIEEgem9uZSBpZGVudGlmaWVkIGJ5IGFuIElBTkEgaWRlbnRpZmllciwgbGlrZSBBbWVyaWNhL05ld19Zb3JrXG4gKiBAaW1wbGVtZW50cyB7Wm9uZX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSUFOQVpvbmUgZXh0ZW5kcyBab25lIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gWm9uZSBuYW1lXG4gICAqIEByZXR1cm4ge0lBTkFab25lfVxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZShuYW1lKSB7XG4gICAgaWYgKCFpYW5hWm9uZUNhY2hlW25hbWVdKSB7XG4gICAgICBpYW5hWm9uZUNhY2hlW25hbWVdID0gbmV3IElBTkFab25lKG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gaWFuYVpvbmVDYWNoZVtuYW1lXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCBsb2NhbCBjYWNoZXMuIFNob3VsZCBvbmx5IGJlIG5lY2Vzc2FyeSBpbiB0ZXN0aW5nIHNjZW5hcmlvcy5cbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIHN0YXRpYyByZXNldENhY2hlKCkge1xuICAgIGlhbmFab25lQ2FjaGUgPSB7fTtcbiAgICBkdGZDYWNoZSA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZWQgc3RyaW5nIGlzIGEgdmFsaWQgc3BlY2lmaWVyLiBUaGlzIG9ubHkgY2hlY2tzIHRoZSBzdHJpbmcncyBmb3JtYXQsIG5vdCB0aGF0IHRoZSBzcGVjaWZpZXIgaWRlbnRpZmllcyBhIGtub3duIHpvbmU7IHNlZSBpc1ZhbGlkWm9uZSBmb3IgdGhhdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHMgLSBUaGUgc3RyaW5nIHRvIGNoZWNrIHZhbGlkaXR5IG9uXG4gICAqIEBleGFtcGxlIElBTkFab25lLmlzVmFsaWRTcGVjaWZpZXIoXCJBbWVyaWNhL05ld19Zb3JrXCIpIC8vPT4gdHJ1ZVxuICAgKiBAZXhhbXBsZSBJQU5BWm9uZS5pc1ZhbGlkU3BlY2lmaWVyKFwiU3BvcnR+fmJsb3JwXCIpIC8vPT4gZmFsc2VcbiAgICogQGRlcHJlY2F0ZWQgVGhpcyBtZXRob2QgcmV0dXJucyBmYWxzZSBmb3Igc29tZSB2YWxpZCBJQU5BIG5hbWVzLiBVc2UgaXNWYWxpZFpvbmUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc1ZhbGlkU3BlY2lmaWVyKHMpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkWm9uZShzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHN0cmluZyBpZGVudGlmaWVzIGEgcmVhbCB6b25lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB6b25lIC0gVGhlIHN0cmluZyB0byBjaGVja1xuICAgKiBAZXhhbXBsZSBJQU5BWm9uZS5pc1ZhbGlkWm9uZShcIkFtZXJpY2EvTmV3X1lvcmtcIikgLy89PiB0cnVlXG4gICAqIEBleGFtcGxlIElBTkFab25lLmlzVmFsaWRab25lKFwiRmFudGFzaWEvQ2FzdGxlXCIpIC8vPT4gZmFsc2VcbiAgICogQGV4YW1wbGUgSUFOQVpvbmUuaXNWYWxpZFpvbmUoXCJTcG9ydH5+YmxvcnBcIikgLy89PiBmYWxzZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzVmFsaWRab25lKHpvbmUpIHtcbiAgICBpZiAoIXpvbmUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KFwiZW4tVVNcIiwgeyB0aW1lWm9uZTogem9uZSB9KS5mb3JtYXQoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKiogQHByaXZhdGUgKiovXG4gICAgdGhpcy56b25lTmFtZSA9IG5hbWU7XG4gICAgLyoqIEBwcml2YXRlICoqL1xuICAgIHRoaXMudmFsaWQgPSBJQU5BWm9uZS5pc1ZhbGlkWm9uZShuYW1lKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiBcImlhbmFcIjtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLnpvbmVOYW1lO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IGlzVW5pdmVyc2FsKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIG9mZnNldE5hbWUodHMsIHsgZm9ybWF0LCBsb2NhbGUgfSkge1xuICAgIHJldHVybiBwYXJzZVpvbmVJbmZvKHRzLCBmb3JtYXQsIGxvY2FsZSwgdGhpcy5uYW1lKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGZvcm1hdE9mZnNldCh0cywgZm9ybWF0KSB7XG4gICAgcmV0dXJuIGZvcm1hdE9mZnNldCh0aGlzLm9mZnNldCh0cyksIGZvcm1hdCk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBvZmZzZXQodHMpIHtcbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUodHMpO1xuXG4gICAgaWYgKGlzTmFOKGRhdGUpKSByZXR1cm4gTmFOO1xuXG4gICAgY29uc3QgZHRmID0gbWFrZURURih0aGlzLm5hbWUpO1xuICAgIGxldCBbeWVhciwgbW9udGgsIGRheSwgYWRPckJjLCBob3VyLCBtaW51dGUsIHNlY29uZF0gPSBkdGYuZm9ybWF0VG9QYXJ0c1xuICAgICAgPyBwYXJ0c09mZnNldChkdGYsIGRhdGUpXG4gICAgICA6IGhhY2t5T2Zmc2V0KGR0ZiwgZGF0ZSk7XG5cbiAgICBpZiAoYWRPckJjID09PSBcIkJDXCIpIHtcbiAgICAgIHllYXIgPSAtTWF0aC5hYnMoeWVhcikgKyAxO1xuICAgIH1cblxuICAgIC8vIGJlY2F1c2Ugd2UncmUgdXNpbmcgaG91cjEyIGFuZCBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMDI1NTY0JmNhbj0yJnE9JTIyMjQlM0EwMCUyMiUyMGRhdGV0aW1lZm9ybWF0XG4gICAgY29uc3QgYWRqdXN0ZWRIb3VyID0gaG91ciA9PT0gMjQgPyAwIDogaG91cjtcblxuICAgIGNvbnN0IGFzVVRDID0gb2JqVG9Mb2NhbFRTKHtcbiAgICAgIHllYXIsXG4gICAgICBtb250aCxcbiAgICAgIGRheSxcbiAgICAgIGhvdXI6IGFkanVzdGVkSG91cixcbiAgICAgIG1pbnV0ZSxcbiAgICAgIHNlY29uZCxcbiAgICAgIG1pbGxpc2Vjb25kOiAwLFxuICAgIH0pO1xuXG4gICAgbGV0IGFzVFMgPSArZGF0ZTtcbiAgICBjb25zdCBvdmVyID0gYXNUUyAlIDEwMDA7XG4gICAgYXNUUyAtPSBvdmVyID49IDAgPyBvdmVyIDogMTAwMCArIG92ZXI7XG4gICAgcmV0dXJuIChhc1VUQyAtIGFzVFMpIC8gKDYwICogMTAwMCk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBlcXVhbHMob3RoZXJab25lKSB7XG4gICAgcmV0dXJuIG90aGVyWm9uZS50eXBlID09PSBcImlhbmFcIiAmJiBvdGhlclpvbmUubmFtZSA9PT0gdGhpcy5uYW1lO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsaWQ7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBwYWRTdGFydCwgcm91bmRUbywgaGFzUmVsYXRpdmUsIGZvcm1hdE9mZnNldCB9IGZyb20gXCIuL3V0aWwuanNcIjtcbmltcG9ydCAqIGFzIEVuZ2xpc2ggZnJvbSBcIi4vZW5nbGlzaC5qc1wiO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gXCIuLi9zZXR0aW5ncy5qc1wiO1xuaW1wb3J0IERhdGVUaW1lIGZyb20gXCIuLi9kYXRldGltZS5qc1wiO1xuaW1wb3J0IElBTkFab25lIGZyb20gXCIuLi96b25lcy9JQU5BWm9uZS5qc1wiO1xuXG4vLyB0b2RvIC0gcmVtYXAgY2FjaGluZ1xuXG5sZXQgaW50bExGQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGdldENhY2hlZExGKGxvY1N0cmluZywgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KFtsb2NTdHJpbmcsIG9wdHNdKTtcbiAgbGV0IGR0ZiA9IGludGxMRkNhY2hlW2tleV07XG4gIGlmICghZHRmKSB7XG4gICAgZHRmID0gbmV3IEludGwuTGlzdEZvcm1hdChsb2NTdHJpbmcsIG9wdHMpO1xuICAgIGludGxMRkNhY2hlW2tleV0gPSBkdGY7XG4gIH1cbiAgcmV0dXJuIGR0Zjtcbn1cblxubGV0IGludGxEVENhY2hlID0ge307XG5mdW5jdGlvbiBnZXRDYWNoZWREVEYobG9jU3RyaW5nLCBvcHRzID0ge30pIHtcbiAgY29uc3Qga2V5ID0gSlNPTi5zdHJpbmdpZnkoW2xvY1N0cmluZywgb3B0c10pO1xuICBsZXQgZHRmID0gaW50bERUQ2FjaGVba2V5XTtcbiAgaWYgKCFkdGYpIHtcbiAgICBkdGYgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NTdHJpbmcsIG9wdHMpO1xuICAgIGludGxEVENhY2hlW2tleV0gPSBkdGY7XG4gIH1cbiAgcmV0dXJuIGR0Zjtcbn1cblxubGV0IGludGxOdW1DYWNoZSA9IHt9O1xuZnVuY3Rpb24gZ2V0Q2FjaGVkSU5GKGxvY1N0cmluZywgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KFtsb2NTdHJpbmcsIG9wdHNdKTtcbiAgbGV0IGluZiA9IGludGxOdW1DYWNoZVtrZXldO1xuICBpZiAoIWluZikge1xuICAgIGluZiA9IG5ldyBJbnRsLk51bWJlckZvcm1hdChsb2NTdHJpbmcsIG9wdHMpO1xuICAgIGludGxOdW1DYWNoZVtrZXldID0gaW5mO1xuICB9XG4gIHJldHVybiBpbmY7XG59XG5cbmxldCBpbnRsUmVsQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGdldENhY2hlZFJURihsb2NTdHJpbmcsIG9wdHMgPSB7fSkge1xuICBjb25zdCB7IGJhc2UsIC4uLmNhY2hlS2V5T3B0cyB9ID0gb3B0czsgLy8gZXhjbHVkZSBgYmFzZWAgZnJvbSB0aGUgb3B0aW9uc1xuICBjb25zdCBrZXkgPSBKU09OLnN0cmluZ2lmeShbbG9jU3RyaW5nLCBjYWNoZUtleU9wdHNdKTtcbiAgbGV0IGluZiA9IGludGxSZWxDYWNoZVtrZXldO1xuICBpZiAoIWluZikge1xuICAgIGluZiA9IG5ldyBJbnRsLlJlbGF0aXZlVGltZUZvcm1hdChsb2NTdHJpbmcsIG9wdHMpO1xuICAgIGludGxSZWxDYWNoZVtrZXldID0gaW5mO1xuICB9XG4gIHJldHVybiBpbmY7XG59XG5cbmxldCBzeXNMb2NhbGVDYWNoZSA9IG51bGw7XG5mdW5jdGlvbiBzeXN0ZW1Mb2NhbGUoKSB7XG4gIGlmIChzeXNMb2NhbGVDYWNoZSkge1xuICAgIHJldHVybiBzeXNMb2NhbGVDYWNoZTtcbiAgfSBlbHNlIHtcbiAgICBzeXNMb2NhbGVDYWNoZSA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KCkucmVzb2x2ZWRPcHRpb25zKCkubG9jYWxlO1xuICAgIHJldHVybiBzeXNMb2NhbGVDYWNoZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZUxvY2FsZVN0cmluZyhsb2NhbGVTdHIpIHtcbiAgLy8gSSByZWFsbHkgd2FudCB0byBhdm9pZCB3cml0aW5nIGEgQkNQIDQ3IHBhcnNlclxuICAvLyBzZWUsIGUuZy4gaHR0cHM6Ly9naXRodWIuY29tL3dvb29ybS9iY3AtNDdcbiAgLy8gSW5zdGVhZCwgd2UnbGwgZG8gdGhpczpcblxuICAvLyBhKSBpZiB0aGUgc3RyaW5nIGhhcyBubyAtdSBleHRlbnNpb25zLCBqdXN0IGxlYXZlIGl0IGFsb25lXG4gIC8vIGIpIGlmIGl0IGRvZXMsIHVzZSBJbnRsIHRvIHJlc29sdmUgZXZlcnl0aGluZ1xuICAvLyBjKSBpZiBJbnRsIGZhaWxzLCB0cnkgYWdhaW4gd2l0aG91dCB0aGUgLXVcblxuICAvLyBwcml2YXRlIHN1YnRhZ3MgYW5kIHVuaWNvZGUgc3VidGFncyBoYXZlIG9yZGVyaW5nIHJlcXVpcmVtZW50cyxcbiAgLy8gYW5kIHdlJ3JlIG5vdCBwcm9wZXJseSBwYXJzaW5nIHRoaXMsIHNvIGp1c3Qgc3RyaXAgb3V0IHRoZVxuICAvLyBwcml2YXRlIG9uZXMgaWYgdGhleSBleGlzdC5cbiAgY29uc3QgeEluZGV4ID0gbG9jYWxlU3RyLmluZGV4T2YoXCIteC1cIik7XG4gIGlmICh4SW5kZXggIT09IC0xKSB7XG4gICAgbG9jYWxlU3RyID0gbG9jYWxlU3RyLnN1YnN0cmluZygwLCB4SW5kZXgpO1xuICB9XG5cbiAgY29uc3QgdUluZGV4ID0gbG9jYWxlU3RyLmluZGV4T2YoXCItdS1cIik7XG4gIGlmICh1SW5kZXggPT09IC0xKSB7XG4gICAgcmV0dXJuIFtsb2NhbGVTdHJdO1xuICB9IGVsc2Uge1xuICAgIGxldCBvcHRpb25zO1xuICAgIGxldCBzZWxlY3RlZFN0cjtcbiAgICB0cnkge1xuICAgICAgb3B0aW9ucyA9IGdldENhY2hlZERURihsb2NhbGVTdHIpLnJlc29sdmVkT3B0aW9ucygpO1xuICAgICAgc2VsZWN0ZWRTdHIgPSBsb2NhbGVTdHI7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc3Qgc21hbGxlciA9IGxvY2FsZVN0ci5zdWJzdHJpbmcoMCwgdUluZGV4KTtcbiAgICAgIG9wdGlvbnMgPSBnZXRDYWNoZWREVEYoc21hbGxlcikucmVzb2x2ZWRPcHRpb25zKCk7XG4gICAgICBzZWxlY3RlZFN0ciA9IHNtYWxsZXI7XG4gICAgfVxuXG4gICAgY29uc3QgeyBudW1iZXJpbmdTeXN0ZW0sIGNhbGVuZGFyIH0gPSBvcHRpb25zO1xuICAgIHJldHVybiBbc2VsZWN0ZWRTdHIsIG51bWJlcmluZ1N5c3RlbSwgY2FsZW5kYXJdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludGxDb25maWdTdHJpbmcobG9jYWxlU3RyLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyKSB7XG4gIGlmIChvdXRwdXRDYWxlbmRhciB8fCBudW1iZXJpbmdTeXN0ZW0pIHtcbiAgICBpZiAoIWxvY2FsZVN0ci5pbmNsdWRlcyhcIi11LVwiKSkge1xuICAgICAgbG9jYWxlU3RyICs9IFwiLXVcIjtcbiAgICB9XG5cbiAgICBpZiAob3V0cHV0Q2FsZW5kYXIpIHtcbiAgICAgIGxvY2FsZVN0ciArPSBgLWNhLSR7b3V0cHV0Q2FsZW5kYXJ9YDtcbiAgICB9XG5cbiAgICBpZiAobnVtYmVyaW5nU3lzdGVtKSB7XG4gICAgICBsb2NhbGVTdHIgKz0gYC1udS0ke251bWJlcmluZ1N5c3RlbX1gO1xuICAgIH1cbiAgICByZXR1cm4gbG9jYWxlU3RyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsb2NhbGVTdHI7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFwTW9udGhzKGYpIHtcbiAgY29uc3QgbXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gMTI7IGkrKykge1xuICAgIGNvbnN0IGR0ID0gRGF0ZVRpbWUudXRjKDIwMDksIGksIDEpO1xuICAgIG1zLnB1c2goZihkdCkpO1xuICB9XG4gIHJldHVybiBtcztcbn1cblxuZnVuY3Rpb24gbWFwV2Vla2RheXMoZikge1xuICBjb25zdCBtcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMTsgaSA8PSA3OyBpKyspIHtcbiAgICBjb25zdCBkdCA9IERhdGVUaW1lLnV0YygyMDE2LCAxMSwgMTMgKyBpKTtcbiAgICBtcy5wdXNoKGYoZHQpKTtcbiAgfVxuICByZXR1cm4gbXM7XG59XG5cbmZ1bmN0aW9uIGxpc3RTdHVmZihsb2MsIGxlbmd0aCwgZW5nbGlzaEZuLCBpbnRsRm4pIHtcbiAgY29uc3QgbW9kZSA9IGxvYy5saXN0aW5nTW9kZSgpO1xuXG4gIGlmIChtb2RlID09PSBcImVycm9yXCIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIGlmIChtb2RlID09PSBcImVuXCIpIHtcbiAgICByZXR1cm4gZW5nbGlzaEZuKGxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGludGxGbihsZW5ndGgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN1cHBvcnRzRmFzdE51bWJlcnMobG9jKSB7XG4gIGlmIChsb2MubnVtYmVyaW5nU3lzdGVtICYmIGxvYy5udW1iZXJpbmdTeXN0ZW0gIT09IFwibGF0blwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoXG4gICAgICBsb2MubnVtYmVyaW5nU3lzdGVtID09PSBcImxhdG5cIiB8fFxuICAgICAgIWxvYy5sb2NhbGUgfHxcbiAgICAgIGxvYy5sb2NhbGUuc3RhcnRzV2l0aChcImVuXCIpIHx8XG4gICAgICBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2MuaW50bCkucmVzb2x2ZWRPcHRpb25zKCkubnVtYmVyaW5nU3lzdGVtID09PSBcImxhdG5cIlxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmNsYXNzIFBvbHlOdW1iZXJGb3JtYXR0ZXIge1xuICBjb25zdHJ1Y3RvcihpbnRsLCBmb3JjZVNpbXBsZSwgb3B0cykge1xuICAgIHRoaXMucGFkVG8gPSBvcHRzLnBhZFRvIHx8IDA7XG4gICAgdGhpcy5mbG9vciA9IG9wdHMuZmxvb3IgfHwgZmFsc2U7XG5cbiAgICBjb25zdCB7IHBhZFRvLCBmbG9vciwgLi4ub3RoZXJPcHRzIH0gPSBvcHRzO1xuXG4gICAgaWYgKCFmb3JjZVNpbXBsZSB8fCBPYmplY3Qua2V5cyhvdGhlck9wdHMpLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGludGxPcHRzID0geyB1c2VHcm91cGluZzogZmFsc2UsIC4uLm9wdHMgfTtcbiAgICAgIGlmIChvcHRzLnBhZFRvID4gMCkgaW50bE9wdHMubWluaW11bUludGVnZXJEaWdpdHMgPSBvcHRzLnBhZFRvO1xuICAgICAgdGhpcy5pbmYgPSBnZXRDYWNoZWRJTkYoaW50bCwgaW50bE9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIGZvcm1hdChpKSB7XG4gICAgaWYgKHRoaXMuaW5mKSB7XG4gICAgICBjb25zdCBmaXhlZCA9IHRoaXMuZmxvb3IgPyBNYXRoLmZsb29yKGkpIDogaTtcbiAgICAgIHJldHVybiB0aGlzLmluZi5mb3JtYXQoZml4ZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0byBtYXRjaCB0aGUgYnJvd3NlcidzIG51bWJlcmZvcm1hdHRlciBkZWZhdWx0c1xuICAgICAgY29uc3QgZml4ZWQgPSB0aGlzLmZsb29yID8gTWF0aC5mbG9vcihpKSA6IHJvdW5kVG8oaSwgMyk7XG4gICAgICByZXR1cm4gcGFkU3RhcnQoZml4ZWQsIHRoaXMucGFkVG8pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuY2xhc3MgUG9seURhdGVGb3JtYXR0ZXIge1xuICBjb25zdHJ1Y3RvcihkdCwgaW50bCwgb3B0cykge1xuICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgdGhpcy5vcmlnaW5hbFpvbmUgPSB1bmRlZmluZWQ7XG5cbiAgICBsZXQgeiA9IHVuZGVmaW5lZDtcbiAgICBpZiAodGhpcy5vcHRzLnRpbWVab25lKSB7XG4gICAgICAvLyBEb24ndCBhcHBseSBhbnkgd29ya2Fyb3VuZHMgaWYgYSB0aW1lWm9uZSBpcyBleHBsaWNpdGx5IHByb3ZpZGVkIGluIG9wdHNcbiAgICAgIHRoaXMuZHQgPSBkdDtcbiAgICB9IGVsc2UgaWYgKGR0LnpvbmUudHlwZSA9PT0gXCJmaXhlZFwiKSB7XG4gICAgICAvLyBVVEMtOCBvciBFdGMvVVRDLTggYXJlIG5vdCBwYXJ0IG9mIHR6ZGF0YSwgb25seSBFdGMvR01UKzggYW5kIHRoZSBsaWtlLlxuICAgICAgLy8gVGhhdCBpcyB3aHkgZml4ZWQtb2Zmc2V0IFRaIGlzIHNldCB0byB0aGF0IHVubGVzcyBpdCBpczpcbiAgICAgIC8vIDEuIFJlcHJlc2VudGluZyBvZmZzZXQgMCB3aGVuIFVUQyBpcyB1c2VkIHRvIG1haW50YWluIHByZXZpb3VzIGJlaGF2aW9yIGFuZCBkb2VzIG5vdCBiZWNvbWUgR01ULlxuICAgICAgLy8gMi4gVW5zdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXI6XG4gICAgICAvLyAgICAtIHNvbWUgZG8gbm90IHN1cHBvcnQgRXRjL1xuICAgICAgLy8gICAgLSA8IEV0Yy9HTVQtMTQsID4gRXRjL0dNVCsxMiwgYW5kIDMwLW1pbnV0ZSBvciA0NS1taW51dGUgb2Zmc2V0cyBhcmUgbm90IHBhcnQgb2YgdHpkYXRhXG4gICAgICBjb25zdCBnbXRPZmZzZXQgPSAtMSAqIChkdC5vZmZzZXQgLyA2MCk7XG4gICAgICBjb25zdCBvZmZzZXRaID0gZ210T2Zmc2V0ID49IDAgPyBgRXRjL0dNVCske2dtdE9mZnNldH1gIDogYEV0Yy9HTVQke2dtdE9mZnNldH1gO1xuICAgICAgaWYgKGR0Lm9mZnNldCAhPT0gMCAmJiBJQU5BWm9uZS5jcmVhdGUob2Zmc2V0WikudmFsaWQpIHtcbiAgICAgICAgeiA9IG9mZnNldFo7XG4gICAgICAgIHRoaXMuZHQgPSBkdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vdCBhbGwgZml4ZWQtb2Zmc2V0IHpvbmVzIGxpa2UgRXRjLys0OjMwIGFyZSBwcmVzZW50IGluIHR6ZGF0YSBzb1xuICAgICAgICAvLyB3ZSBtYW51YWxseSBhcHBseSB0aGUgb2Zmc2V0IGFuZCBzdWJzdGl0dXRlIHRoZSB6b25lIGFzIG5lZWRlZC5cbiAgICAgICAgeiA9IFwiVVRDXCI7XG4gICAgICAgIHRoaXMuZHQgPSBkdC5vZmZzZXQgPT09IDAgPyBkdCA6IGR0LnNldFpvbmUoXCJVVENcIikucGx1cyh7IG1pbnV0ZXM6IGR0Lm9mZnNldCB9KTtcbiAgICAgICAgdGhpcy5vcmlnaW5hbFpvbmUgPSBkdC56b25lO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZHQuem9uZS50eXBlID09PSBcInN5c3RlbVwiKSB7XG4gICAgICB0aGlzLmR0ID0gZHQ7XG4gICAgfSBlbHNlIGlmIChkdC56b25lLnR5cGUgPT09IFwiaWFuYVwiKSB7XG4gICAgICB0aGlzLmR0ID0gZHQ7XG4gICAgICB6ID0gZHQuem9uZS5uYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDdXN0b20gem9uZXMgY2FuIGhhdmUgYW55IG9mZnNldCAvIG9mZnNldE5hbWUgc28gd2UganVzdCBtYW51YWxseVxuICAgICAgLy8gYXBwbHkgdGhlIG9mZnNldCBhbmQgc3Vic3RpdHV0ZSB0aGUgem9uZSBhcyBuZWVkZWQuXG4gICAgICB6ID0gXCJVVENcIjtcbiAgICAgIHRoaXMuZHQgPSBkdC5zZXRab25lKFwiVVRDXCIpLnBsdXMoeyBtaW51dGVzOiBkdC5vZmZzZXQgfSk7XG4gICAgICB0aGlzLm9yaWdpbmFsWm9uZSA9IGR0LnpvbmU7XG4gICAgfVxuXG4gICAgY29uc3QgaW50bE9wdHMgPSB7IC4uLnRoaXMub3B0cyB9O1xuICAgIGludGxPcHRzLnRpbWVab25lID0gaW50bE9wdHMudGltZVpvbmUgfHwgejtcbiAgICB0aGlzLmR0ZiA9IGdldENhY2hlZERURihpbnRsLCBpbnRsT3B0cyk7XG4gIH1cblxuICBmb3JtYXQoKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luYWxab25lKSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlIHRvIHN1YnN0aXR1dGUgaW4gdGhlIGFjdHVhbCB6b25lIG5hbWUsIHdlIGhhdmUgdG8gdXNlXG4gICAgICAvLyBmb3JtYXRUb1BhcnRzIHNvIHRoYXQgdGhlIHRpbWV6b25lIGNhbiBiZSByZXBsYWNlZC5cbiAgICAgIHJldHVybiB0aGlzLmZvcm1hdFRvUGFydHMoKVxuICAgICAgICAubWFwKCh7IHZhbHVlIH0pID0+IHZhbHVlKVxuICAgICAgICAuam9pbihcIlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZHRmLmZvcm1hdCh0aGlzLmR0LnRvSlNEYXRlKCkpO1xuICB9XG5cbiAgZm9ybWF0VG9QYXJ0cygpIHtcbiAgICBjb25zdCBwYXJ0cyA9IHRoaXMuZHRmLmZvcm1hdFRvUGFydHModGhpcy5kdC50b0pTRGF0ZSgpKTtcbiAgICBpZiAodGhpcy5vcmlnaW5hbFpvbmUpIHtcbiAgICAgIHJldHVybiBwYXJ0cy5tYXAoKHBhcnQpID0+IHtcbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJ0aW1lWm9uZU5hbWVcIikge1xuICAgICAgICAgIGNvbnN0IG9mZnNldE5hbWUgPSB0aGlzLm9yaWdpbmFsWm9uZS5vZmZzZXROYW1lKHRoaXMuZHQudHMsIHtcbiAgICAgICAgICAgIGxvY2FsZTogdGhpcy5kdC5sb2NhbGUsXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMub3B0cy50aW1lWm9uZU5hbWUsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnBhcnQsXG4gICAgICAgICAgICB2YWx1ZTogb2Zmc2V0TmFtZSxcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBwYXJ0O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnRzO1xuICB9XG5cbiAgcmVzb2x2ZWRPcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmR0Zi5yZXNvbHZlZE9wdGlvbnMoKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFBvbHlSZWxGb3JtYXR0ZXIge1xuICBjb25zdHJ1Y3RvcihpbnRsLCBpc0VuZ2xpc2gsIG9wdHMpIHtcbiAgICB0aGlzLm9wdHMgPSB7IHN0eWxlOiBcImxvbmdcIiwgLi4ub3B0cyB9O1xuICAgIGlmICghaXNFbmdsaXNoICYmIGhhc1JlbGF0aXZlKCkpIHtcbiAgICAgIHRoaXMucnRmID0gZ2V0Q2FjaGVkUlRGKGludGwsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIGZvcm1hdChjb3VudCwgdW5pdCkge1xuICAgIGlmICh0aGlzLnJ0Zikge1xuICAgICAgcmV0dXJuIHRoaXMucnRmLmZvcm1hdChjb3VudCwgdW5pdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBFbmdsaXNoLmZvcm1hdFJlbGF0aXZlVGltZSh1bml0LCBjb3VudCwgdGhpcy5vcHRzLm51bWVyaWMsIHRoaXMub3B0cy5zdHlsZSAhPT0gXCJsb25nXCIpO1xuICAgIH1cbiAgfVxuXG4gIGZvcm1hdFRvUGFydHMoY291bnQsIHVuaXQpIHtcbiAgICBpZiAodGhpcy5ydGYpIHtcbiAgICAgIHJldHVybiB0aGlzLnJ0Zi5mb3JtYXRUb1BhcnRzKGNvdW50LCB1bml0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9jYWxlIHtcbiAgc3RhdGljIGZyb21PcHRzKG9wdHMpIHtcbiAgICByZXR1cm4gTG9jYWxlLmNyZWF0ZShvcHRzLmxvY2FsZSwgb3B0cy5udW1iZXJpbmdTeXN0ZW0sIG9wdHMub3V0cHV0Q2FsZW5kYXIsIG9wdHMuZGVmYXVsdFRvRU4pO1xuICB9XG5cbiAgc3RhdGljIGNyZWF0ZShsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgb3V0cHV0Q2FsZW5kYXIsIGRlZmF1bHRUb0VOID0gZmFsc2UpIHtcbiAgICBjb25zdCBzcGVjaWZpZWRMb2NhbGUgPSBsb2NhbGUgfHwgU2V0dGluZ3MuZGVmYXVsdExvY2FsZTtcbiAgICAvLyB0aGUgc3lzdGVtIGxvY2FsZSBpcyB1c2VmdWwgZm9yIGh1bWFuIHJlYWRhYmxlIHN0cmluZ3MgYnV0IGFubm95aW5nIGZvciBwYXJzaW5nL2Zvcm1hdHRpbmcga25vd24gZm9ybWF0c1xuICAgIGNvbnN0IGxvY2FsZVIgPSBzcGVjaWZpZWRMb2NhbGUgfHwgKGRlZmF1bHRUb0VOID8gXCJlbi1VU1wiIDogc3lzdGVtTG9jYWxlKCkpO1xuICAgIGNvbnN0IG51bWJlcmluZ1N5c3RlbVIgPSBudW1iZXJpbmdTeXN0ZW0gfHwgU2V0dGluZ3MuZGVmYXVsdE51bWJlcmluZ1N5c3RlbTtcbiAgICBjb25zdCBvdXRwdXRDYWxlbmRhclIgPSBvdXRwdXRDYWxlbmRhciB8fCBTZXR0aW5ncy5kZWZhdWx0T3V0cHV0Q2FsZW5kYXI7XG4gICAgcmV0dXJuIG5ldyBMb2NhbGUobG9jYWxlUiwgbnVtYmVyaW5nU3lzdGVtUiwgb3V0cHV0Q2FsZW5kYXJSLCBzcGVjaWZpZWRMb2NhbGUpO1xuICB9XG5cbiAgc3RhdGljIHJlc2V0Q2FjaGUoKSB7XG4gICAgc3lzTG9jYWxlQ2FjaGUgPSBudWxsO1xuICAgIGludGxEVENhY2hlID0ge307XG4gICAgaW50bE51bUNhY2hlID0ge307XG4gICAgaW50bFJlbENhY2hlID0ge307XG4gIH1cblxuICBzdGF0aWMgZnJvbU9iamVjdCh7IGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhciB9ID0ge30pIHtcbiAgICByZXR1cm4gTG9jYWxlLmNyZWF0ZShsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgb3V0cHV0Q2FsZW5kYXIpO1xuICB9XG5cbiAgY29uc3RydWN0b3IobG9jYWxlLCBudW1iZXJpbmcsIG91dHB1dENhbGVuZGFyLCBzcGVjaWZpZWRMb2NhbGUpIHtcbiAgICBjb25zdCBbcGFyc2VkTG9jYWxlLCBwYXJzZWROdW1iZXJpbmdTeXN0ZW0sIHBhcnNlZE91dHB1dENhbGVuZGFyXSA9IHBhcnNlTG9jYWxlU3RyaW5nKGxvY2FsZSk7XG5cbiAgICB0aGlzLmxvY2FsZSA9IHBhcnNlZExvY2FsZTtcbiAgICB0aGlzLm51bWJlcmluZ1N5c3RlbSA9IG51bWJlcmluZyB8fCBwYXJzZWROdW1iZXJpbmdTeXN0ZW0gfHwgbnVsbDtcbiAgICB0aGlzLm91dHB1dENhbGVuZGFyID0gb3V0cHV0Q2FsZW5kYXIgfHwgcGFyc2VkT3V0cHV0Q2FsZW5kYXIgfHwgbnVsbDtcbiAgICB0aGlzLmludGwgPSBpbnRsQ29uZmlnU3RyaW5nKHRoaXMubG9jYWxlLCB0aGlzLm51bWJlcmluZ1N5c3RlbSwgdGhpcy5vdXRwdXRDYWxlbmRhcik7XG5cbiAgICB0aGlzLndlZWtkYXlzQ2FjaGUgPSB7IGZvcm1hdDoge30sIHN0YW5kYWxvbmU6IHt9IH07XG4gICAgdGhpcy5tb250aHNDYWNoZSA9IHsgZm9ybWF0OiB7fSwgc3RhbmRhbG9uZToge30gfTtcbiAgICB0aGlzLm1lcmlkaWVtQ2FjaGUgPSBudWxsO1xuICAgIHRoaXMuZXJhQ2FjaGUgPSB7fTtcblxuICAgIHRoaXMuc3BlY2lmaWVkTG9jYWxlID0gc3BlY2lmaWVkTG9jYWxlO1xuICAgIHRoaXMuZmFzdE51bWJlcnNDYWNoZWQgPSBudWxsO1xuICB9XG5cbiAgZ2V0IGZhc3ROdW1iZXJzKCkge1xuICAgIGlmICh0aGlzLmZhc3ROdW1iZXJzQ2FjaGVkID09IG51bGwpIHtcbiAgICAgIHRoaXMuZmFzdE51bWJlcnNDYWNoZWQgPSBzdXBwb3J0c0Zhc3ROdW1iZXJzKHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZhc3ROdW1iZXJzQ2FjaGVkO1xuICB9XG5cbiAgbGlzdGluZ01vZGUoKSB7XG4gICAgY29uc3QgaXNBY3R1YWxseUVuID0gdGhpcy5pc0VuZ2xpc2goKTtcbiAgICBjb25zdCBoYXNOb1dlaXJkbmVzcyA9XG4gICAgICAodGhpcy5udW1iZXJpbmdTeXN0ZW0gPT09IG51bGwgfHwgdGhpcy5udW1iZXJpbmdTeXN0ZW0gPT09IFwibGF0blwiKSAmJlxuICAgICAgKHRoaXMub3V0cHV0Q2FsZW5kYXIgPT09IG51bGwgfHwgdGhpcy5vdXRwdXRDYWxlbmRhciA9PT0gXCJncmVnb3J5XCIpO1xuICAgIHJldHVybiBpc0FjdHVhbGx5RW4gJiYgaGFzTm9XZWlyZG5lc3MgPyBcImVuXCIgOiBcImludGxcIjtcbiAgfVxuXG4gIGNsb25lKGFsdHMpIHtcbiAgICBpZiAoIWFsdHMgfHwgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYWx0cykubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIExvY2FsZS5jcmVhdGUoXG4gICAgICAgIGFsdHMubG9jYWxlIHx8IHRoaXMuc3BlY2lmaWVkTG9jYWxlLFxuICAgICAgICBhbHRzLm51bWJlcmluZ1N5c3RlbSB8fCB0aGlzLm51bWJlcmluZ1N5c3RlbSxcbiAgICAgICAgYWx0cy5vdXRwdXRDYWxlbmRhciB8fCB0aGlzLm91dHB1dENhbGVuZGFyLFxuICAgICAgICBhbHRzLmRlZmF1bHRUb0VOIHx8IGZhbHNlXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHJlZGVmYXVsdFRvRU4oYWx0cyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoeyAuLi5hbHRzLCBkZWZhdWx0VG9FTjogdHJ1ZSB9KTtcbiAgfVxuXG4gIHJlZGVmYXVsdFRvU3lzdGVtKGFsdHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKHsgLi4uYWx0cywgZGVmYXVsdFRvRU46IGZhbHNlIH0pO1xuICB9XG5cbiAgbW9udGhzKGxlbmd0aCwgZm9ybWF0ID0gZmFsc2UpIHtcbiAgICByZXR1cm4gbGlzdFN0dWZmKHRoaXMsIGxlbmd0aCwgRW5nbGlzaC5tb250aHMsICgpID0+IHtcbiAgICAgIGNvbnN0IGludGwgPSBmb3JtYXQgPyB7IG1vbnRoOiBsZW5ndGgsIGRheTogXCJudW1lcmljXCIgfSA6IHsgbW9udGg6IGxlbmd0aCB9LFxuICAgICAgICBmb3JtYXRTdHIgPSBmb3JtYXQgPyBcImZvcm1hdFwiIDogXCJzdGFuZGFsb25lXCI7XG4gICAgICBpZiAoIXRoaXMubW9udGhzQ2FjaGVbZm9ybWF0U3RyXVtsZW5ndGhdKSB7XG4gICAgICAgIHRoaXMubW9udGhzQ2FjaGVbZm9ybWF0U3RyXVtsZW5ndGhdID0gbWFwTW9udGhzKChkdCkgPT4gdGhpcy5leHRyYWN0KGR0LCBpbnRsLCBcIm1vbnRoXCIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLm1vbnRoc0NhY2hlW2Zvcm1hdFN0cl1bbGVuZ3RoXTtcbiAgICB9KTtcbiAgfVxuXG4gIHdlZWtkYXlzKGxlbmd0aCwgZm9ybWF0ID0gZmFsc2UpIHtcbiAgICByZXR1cm4gbGlzdFN0dWZmKHRoaXMsIGxlbmd0aCwgRW5nbGlzaC53ZWVrZGF5cywgKCkgPT4ge1xuICAgICAgY29uc3QgaW50bCA9IGZvcm1hdFxuICAgICAgICAgID8geyB3ZWVrZGF5OiBsZW5ndGgsIHllYXI6IFwibnVtZXJpY1wiLCBtb250aDogXCJsb25nXCIsIGRheTogXCJudW1lcmljXCIgfVxuICAgICAgICAgIDogeyB3ZWVrZGF5OiBsZW5ndGggfSxcbiAgICAgICAgZm9ybWF0U3RyID0gZm9ybWF0ID8gXCJmb3JtYXRcIiA6IFwic3RhbmRhbG9uZVwiO1xuICAgICAgaWYgKCF0aGlzLndlZWtkYXlzQ2FjaGVbZm9ybWF0U3RyXVtsZW5ndGhdKSB7XG4gICAgICAgIHRoaXMud2Vla2RheXNDYWNoZVtmb3JtYXRTdHJdW2xlbmd0aF0gPSBtYXBXZWVrZGF5cygoZHQpID0+XG4gICAgICAgICAgdGhpcy5leHRyYWN0KGR0LCBpbnRsLCBcIndlZWtkYXlcIilcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLndlZWtkYXlzQ2FjaGVbZm9ybWF0U3RyXVtsZW5ndGhdO1xuICAgIH0pO1xuICB9XG5cbiAgbWVyaWRpZW1zKCkge1xuICAgIHJldHVybiBsaXN0U3R1ZmYoXG4gICAgICB0aGlzLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgKCkgPT4gRW5nbGlzaC5tZXJpZGllbXMsXG4gICAgICAoKSA9PiB7XG4gICAgICAgIC8vIEluIHRoZW9yeSB0aGVyZSBjb3VsZCBiZSBhcmliaXRyYXJ5IGRheSBwZXJpb2RzLiBXZSdyZSBnb25uYSBhc3N1bWUgdGhlcmUgYXJlIGV4YWN0bHkgdHdvXG4gICAgICAgIC8vIGZvciBBTSBhbmQgUE0uIFRoaXMgaXMgcHJvYmFibHkgd3JvbmcsIGJ1dCBpdCdzIG1ha2VzIHBhcnNpbmcgd2F5IGVhc2llci5cbiAgICAgICAgaWYgKCF0aGlzLm1lcmlkaWVtQ2FjaGUpIHtcbiAgICAgICAgICBjb25zdCBpbnRsID0geyBob3VyOiBcIm51bWVyaWNcIiwgaG91ckN5Y2xlOiBcImgxMlwiIH07XG4gICAgICAgICAgdGhpcy5tZXJpZGllbUNhY2hlID0gW0RhdGVUaW1lLnV0YygyMDE2LCAxMSwgMTMsIDkpLCBEYXRlVGltZS51dGMoMjAxNiwgMTEsIDEzLCAxOSldLm1hcChcbiAgICAgICAgICAgIChkdCkgPT4gdGhpcy5leHRyYWN0KGR0LCBpbnRsLCBcImRheXBlcmlvZFwiKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5tZXJpZGllbUNhY2hlO1xuICAgICAgfVxuICAgICk7XG4gIH1cblxuICBlcmFzKGxlbmd0aCkge1xuICAgIHJldHVybiBsaXN0U3R1ZmYodGhpcywgbGVuZ3RoLCBFbmdsaXNoLmVyYXMsICgpID0+IHtcbiAgICAgIGNvbnN0IGludGwgPSB7IGVyYTogbGVuZ3RoIH07XG5cbiAgICAgIC8vIFRoaXMgaXMgcHJvYmxlbWF0aWMuIERpZmZlcmVudCBjYWxlbmRhcnMgYXJlIGdvaW5nIHRvIGRlZmluZSBlcmFzIHRvdGFsbHkgZGlmZmVyZW50bHkuIFdoYXQgSSBuZWVkIGlzIHRoZSBtaW5pbXVtIHNldCBvZiBkYXRlc1xuICAgICAgLy8gdG8gZGVmaW5pdGVseSBlbnVtZXJhdGUgdGhlbS5cbiAgICAgIGlmICghdGhpcy5lcmFDYWNoZVtsZW5ndGhdKSB7XG4gICAgICAgIHRoaXMuZXJhQ2FjaGVbbGVuZ3RoXSA9IFtEYXRlVGltZS51dGMoLTQwLCAxLCAxKSwgRGF0ZVRpbWUudXRjKDIwMTcsIDEsIDEpXS5tYXAoKGR0KSA9PlxuICAgICAgICAgIHRoaXMuZXh0cmFjdChkdCwgaW50bCwgXCJlcmFcIilcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZXJhQ2FjaGVbbGVuZ3RoXTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4dHJhY3QoZHQsIGludGxPcHRzLCBmaWVsZCkge1xuICAgIGNvbnN0IGRmID0gdGhpcy5kdEZvcm1hdHRlcihkdCwgaW50bE9wdHMpLFxuICAgICAgcmVzdWx0cyA9IGRmLmZvcm1hdFRvUGFydHMoKSxcbiAgICAgIG1hdGNoaW5nID0gcmVzdWx0cy5maW5kKChtKSA9PiBtLnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gZmllbGQpO1xuICAgIHJldHVybiBtYXRjaGluZyA/IG1hdGNoaW5nLnZhbHVlIDogbnVsbDtcbiAgfVxuXG4gIG51bWJlckZvcm1hdHRlcihvcHRzID0ge30pIHtcbiAgICAvLyB0aGlzIGZvcmNlc2ltcGxlIG9wdGlvbiBpcyBuZXZlciB1c2VkICh0aGUgb25seSBjYWxsZXIgc2hvcnQtY2lyY3VpdHMgb24gaXQsIGJ1dCBpdCBzZWVtcyBzYWZlciB0byBsZWF2ZSlcbiAgICAvLyAoaW4gY29udHJhc3QsIHRoZSByZXN0IG9mIHRoZSBjb25kaXRpb24gaXMgdXNlZCBoZWF2aWx5KVxuICAgIHJldHVybiBuZXcgUG9seU51bWJlckZvcm1hdHRlcih0aGlzLmludGwsIG9wdHMuZm9yY2VTaW1wbGUgfHwgdGhpcy5mYXN0TnVtYmVycywgb3B0cyk7XG4gIH1cblxuICBkdEZvcm1hdHRlcihkdCwgaW50bE9wdHMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgUG9seURhdGVGb3JtYXR0ZXIoZHQsIHRoaXMuaW50bCwgaW50bE9wdHMpO1xuICB9XG5cbiAgcmVsRm9ybWF0dGVyKG9wdHMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgUG9seVJlbEZvcm1hdHRlcih0aGlzLmludGwsIHRoaXMuaXNFbmdsaXNoKCksIG9wdHMpO1xuICB9XG5cbiAgbGlzdEZvcm1hdHRlcihvcHRzID0ge30pIHtcbiAgICByZXR1cm4gZ2V0Q2FjaGVkTEYodGhpcy5pbnRsLCBvcHRzKTtcbiAgfVxuXG4gIGlzRW5nbGlzaCgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5sb2NhbGUgPT09IFwiZW5cIiB8fFxuICAgICAgdGhpcy5sb2NhbGUudG9Mb3dlckNhc2UoKSA9PT0gXCJlbi11c1wiIHx8XG4gICAgICBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCh0aGlzLmludGwpLnJlc29sdmVkT3B0aW9ucygpLmxvY2FsZS5zdGFydHNXaXRoKFwiZW4tdXNcIilcbiAgICApO1xuICB9XG5cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMubG9jYWxlID09PSBvdGhlci5sb2NhbGUgJiZcbiAgICAgIHRoaXMubnVtYmVyaW5nU3lzdGVtID09PSBvdGhlci5udW1iZXJpbmdTeXN0ZW0gJiZcbiAgICAgIHRoaXMub3V0cHV0Q2FsZW5kYXIgPT09IG90aGVyLm91dHB1dENhbGVuZGFyXG4gICAgKTtcbiAgfVxufVxuIiwgImltcG9ydCB7IGZvcm1hdE9mZnNldCwgc2lnbmVkT2Zmc2V0IH0gZnJvbSBcIi4uL2ltcGwvdXRpbC5qc1wiO1xuaW1wb3J0IFpvbmUgZnJvbSBcIi4uL3pvbmUuanNcIjtcblxubGV0IHNpbmdsZXRvbiA9IG51bGw7XG5cbi8qKlxuICogQSB6b25lIHdpdGggYSBmaXhlZCBvZmZzZXQgKG1lYW5pbmcgbm8gRFNUKVxuICogQGltcGxlbWVudHMge1pvbmV9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpeGVkT2Zmc2V0Wm9uZSBleHRlbmRzIFpvbmUge1xuICAvKipcbiAgICogR2V0IGEgc2luZ2xldG9uIGluc3RhbmNlIG9mIFVUQ1xuICAgKiBAcmV0dXJuIHtGaXhlZE9mZnNldFpvbmV9XG4gICAqL1xuICBzdGF0aWMgZ2V0IHV0Y0luc3RhbmNlKCkge1xuICAgIGlmIChzaW5nbGV0b24gPT09IG51bGwpIHtcbiAgICAgIHNpbmdsZXRvbiA9IG5ldyBGaXhlZE9mZnNldFpvbmUoMCk7XG4gICAgfVxuICAgIHJldHVybiBzaW5nbGV0b247XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIGluc3RhbmNlIHdpdGggYSBzcGVjaWZpZWQgb2Zmc2V0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBUaGUgb2Zmc2V0IGluIG1pbnV0ZXNcbiAgICogQHJldHVybiB7Rml4ZWRPZmZzZXRab25lfVxuICAgKi9cbiAgc3RhdGljIGluc3RhbmNlKG9mZnNldCkge1xuICAgIHJldHVybiBvZmZzZXQgPT09IDAgPyBGaXhlZE9mZnNldFpvbmUudXRjSW5zdGFuY2UgOiBuZXcgRml4ZWRPZmZzZXRab25lKG9mZnNldCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIGluc3RhbmNlIG9mIEZpeGVkT2Zmc2V0Wm9uZSBmcm9tIGEgVVRDIG9mZnNldCBzdHJpbmcsIGxpa2UgXCJVVEMrNlwiXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzIC0gVGhlIG9mZnNldCBzdHJpbmcgdG8gcGFyc2VcbiAgICogQGV4YW1wbGUgRml4ZWRPZmZzZXRab25lLnBhcnNlU3BlY2lmaWVyKFwiVVRDKzZcIilcbiAgICogQGV4YW1wbGUgRml4ZWRPZmZzZXRab25lLnBhcnNlU3BlY2lmaWVyKFwiVVRDKzA2XCIpXG4gICAqIEBleGFtcGxlIEZpeGVkT2Zmc2V0Wm9uZS5wYXJzZVNwZWNpZmllcihcIlVUQy02OjAwXCIpXG4gICAqIEByZXR1cm4ge0ZpeGVkT2Zmc2V0Wm9uZX1cbiAgICovXG4gIHN0YXRpYyBwYXJzZVNwZWNpZmllcihzKSB7XG4gICAgaWYgKHMpIHtcbiAgICAgIGNvbnN0IHIgPSBzLm1hdGNoKC9edXRjKD86KFsrLV1cXGR7MSwyfSkoPzo6KFxcZHsyfSkpPyk/JC9pKTtcbiAgICAgIGlmIChyKSB7XG4gICAgICAgIHJldHVybiBuZXcgRml4ZWRPZmZzZXRab25lKHNpZ25lZE9mZnNldChyWzFdLCByWzJdKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3RydWN0b3Iob2Zmc2V0KSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKiogQHByaXZhdGUgKiovXG4gICAgdGhpcy5maXhlZCA9IG9mZnNldDtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiBcImZpeGVkXCI7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5maXhlZCA9PT0gMCA/IFwiVVRDXCIgOiBgVVRDJHtmb3JtYXRPZmZzZXQodGhpcy5maXhlZCwgXCJuYXJyb3dcIil9YDtcbiAgfVxuXG4gIGdldCBpYW5hTmFtZSgpIHtcbiAgICBpZiAodGhpcy5maXhlZCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFwiRXRjL1VUQ1wiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYEV0Yy9HTVQke2Zvcm1hdE9mZnNldCgtdGhpcy5maXhlZCwgXCJuYXJyb3dcIil9YDtcbiAgICB9XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBvZmZzZXROYW1lKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWU7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBmb3JtYXRPZmZzZXQodHMsIGZvcm1hdCkge1xuICAgIHJldHVybiBmb3JtYXRPZmZzZXQodGhpcy5maXhlZCwgZm9ybWF0KTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBpc1VuaXZlcnNhbCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIG9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5maXhlZDtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGVxdWFscyhvdGhlclpvbmUpIHtcbiAgICByZXR1cm4gb3RoZXJab25lLnR5cGUgPT09IFwiZml4ZWRcIiAmJiBvdGhlclpvbmUuZml4ZWQgPT09IHRoaXMuZml4ZWQ7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuIiwgImltcG9ydCBab25lIGZyb20gXCIuLi96b25lLmpzXCI7XG5cbi8qKlxuICogQSB6b25lIHRoYXQgZmFpbGVkIHRvIHBhcnNlLiBZb3Ugc2hvdWxkIG5ldmVyIG5lZWQgdG8gaW5zdGFudGlhdGUgdGhpcy5cbiAqIEBpbXBsZW1lbnRzIHtab25lfVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbnZhbGlkWm9uZSBleHRlbmRzIFpvbmUge1xuICBjb25zdHJ1Y3Rvcih6b25lTmFtZSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqICBAcHJpdmF0ZSAqL1xuICAgIHRoaXMuem9uZU5hbWUgPSB6b25lTmFtZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiBcImludmFsaWRcIjtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLnpvbmVOYW1lO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IGlzVW5pdmVyc2FsKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIG9mZnNldE5hbWUoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBmb3JtYXRPZmZzZXQoKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBvZmZzZXQoKSB7XG4gICAgcmV0dXJuIE5hTjtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGVxdWFscygpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbiIsICIvKipcbiAqIEBwcml2YXRlXG4gKi9cblxuaW1wb3J0IFpvbmUgZnJvbSBcIi4uL3pvbmUuanNcIjtcbmltcG9ydCBJQU5BWm9uZSBmcm9tIFwiLi4vem9uZXMvSUFOQVpvbmUuanNcIjtcbmltcG9ydCBGaXhlZE9mZnNldFpvbmUgZnJvbSBcIi4uL3pvbmVzL2ZpeGVkT2Zmc2V0Wm9uZS5qc1wiO1xuaW1wb3J0IEludmFsaWRab25lIGZyb20gXCIuLi96b25lcy9pbnZhbGlkWm9uZS5qc1wiO1xuXG5pbXBvcnQgeyBpc1VuZGVmaW5lZCwgaXNTdHJpbmcsIGlzTnVtYmVyIH0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuaW1wb3J0IFN5c3RlbVpvbmUgZnJvbSBcIi4uL3pvbmVzL3N5c3RlbVpvbmUuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZVpvbmUoaW5wdXQsIGRlZmF1bHRab25lKSB7XG4gIGxldCBvZmZzZXQ7XG4gIGlmIChpc1VuZGVmaW5lZChpbnB1dCkgfHwgaW5wdXQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZGVmYXVsdFpvbmU7XG4gIH0gZWxzZSBpZiAoaW5wdXQgaW5zdGFuY2VvZiBab25lKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9IGVsc2UgaWYgKGlzU3RyaW5nKGlucHV0KSkge1xuICAgIGNvbnN0IGxvd2VyZWQgPSBpbnB1dC50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChsb3dlcmVkID09PSBcImRlZmF1bHRcIikgcmV0dXJuIGRlZmF1bHRab25lO1xuICAgIGVsc2UgaWYgKGxvd2VyZWQgPT09IFwibG9jYWxcIiB8fCBsb3dlcmVkID09PSBcInN5c3RlbVwiKSByZXR1cm4gU3lzdGVtWm9uZS5pbnN0YW5jZTtcbiAgICBlbHNlIGlmIChsb3dlcmVkID09PSBcInV0Y1wiIHx8IGxvd2VyZWQgPT09IFwiZ210XCIpIHJldHVybiBGaXhlZE9mZnNldFpvbmUudXRjSW5zdGFuY2U7XG4gICAgZWxzZSByZXR1cm4gRml4ZWRPZmZzZXRab25lLnBhcnNlU3BlY2lmaWVyKGxvd2VyZWQpIHx8IElBTkFab25lLmNyZWF0ZShpbnB1dCk7XG4gIH0gZWxzZSBpZiAoaXNOdW1iZXIoaW5wdXQpKSB7XG4gICAgcmV0dXJuIEZpeGVkT2Zmc2V0Wm9uZS5pbnN0YW5jZShpbnB1dCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSBcIm9iamVjdFwiICYmIFwib2Zmc2V0XCIgaW4gaW5wdXQgJiYgdHlwZW9mIGlucHV0Lm9mZnNldCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgLy8gVGhpcyBpcyBkdW1iLCBidXQgdGhlIGluc3RhbmNlb2YgY2hlY2sgYWJvdmUgZG9lc24ndCBzZWVtIHRvIHJlYWxseSB3b3JrXG4gICAgLy8gc28gd2UncmUgZHVjayBjaGVja2luZyBpdFxuICAgIHJldHVybiBpbnB1dDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEludmFsaWRab25lKGlucHV0KTtcbiAgfVxufVxuIiwgImltcG9ydCBTeXN0ZW1ab25lIGZyb20gXCIuL3pvbmVzL3N5c3RlbVpvbmUuanNcIjtcbmltcG9ydCBJQU5BWm9uZSBmcm9tIFwiLi96b25lcy9JQU5BWm9uZS5qc1wiO1xuaW1wb3J0IExvY2FsZSBmcm9tIFwiLi9pbXBsL2xvY2FsZS5qc1wiO1xuXG5pbXBvcnQgeyBub3JtYWxpemVab25lIH0gZnJvbSBcIi4vaW1wbC96b25lVXRpbC5qc1wiO1xuXG5sZXQgbm93ID0gKCkgPT4gRGF0ZS5ub3coKSxcbiAgZGVmYXVsdFpvbmUgPSBcInN5c3RlbVwiLFxuICBkZWZhdWx0TG9jYWxlID0gbnVsbCxcbiAgZGVmYXVsdE51bWJlcmluZ1N5c3RlbSA9IG51bGwsXG4gIGRlZmF1bHRPdXRwdXRDYWxlbmRhciA9IG51bGwsXG4gIHR3b0RpZ2l0Q3V0b2ZmWWVhciA9IDYwLFxuICB0aHJvd09uSW52YWxpZDtcblxuLyoqXG4gKiBTZXR0aW5ncyBjb250YWlucyBzdGF0aWMgZ2V0dGVycyBhbmQgc2V0dGVycyB0aGF0IGNvbnRyb2wgTHV4b24ncyBvdmVyYWxsIGJlaGF2aW9yLiBMdXhvbiBpcyBhIHNpbXBsZSBsaWJyYXJ5IHdpdGggZmV3IG9wdGlvbnMsIGJ1dCB0aGUgb25lcyBpdCBkb2VzIGhhdmUgbGl2ZSBoZXJlLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZXR0aW5ncyB7XG4gIC8qKlxuICAgKiBHZXQgdGhlIGNhbGxiYWNrIGZvciByZXR1cm5pbmcgdGhlIGN1cnJlbnQgdGltZXN0YW1wLlxuICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAqL1xuICBzdGF0aWMgZ2V0IG5vdygpIHtcbiAgICByZXR1cm4gbm93O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY2FsbGJhY2sgZm9yIHJldHVybmluZyB0aGUgY3VycmVudCB0aW1lc3RhbXAuXG4gICAqIFRoZSBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgbnVtYmVyLCB3aGljaCB3aWxsIGJlIGludGVycHJldGVkIGFzIGFuIEVwb2NoIG1pbGxpc2Vjb25kIGNvdW50XG4gICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICogQGV4YW1wbGUgU2V0dGluZ3Mubm93ID0gKCkgPT4gRGF0ZS5ub3coKSArIDMwMDAgLy8gcHJldGVuZCBpdCBpcyAzIHNlY29uZHMgaW4gdGhlIGZ1dHVyZVxuICAgKiBAZXhhbXBsZSBTZXR0aW5ncy5ub3cgPSAoKSA9PiAwIC8vIGFsd2F5cyBwcmV0ZW5kIGl0J3MgSmFuIDEsIDE5NzAgYXQgbWlkbmlnaHQgaW4gVVRDIHRpbWVcbiAgICovXG4gIHN0YXRpYyBzZXQgbm93KG4pIHtcbiAgICBub3cgPSBuO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZGVmYXVsdCB0aW1lIHpvbmUgdG8gY3JlYXRlIERhdGVUaW1lcyBpbi4gRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICogVXNlIHRoZSB2YWx1ZSBcInN5c3RlbVwiIHRvIHJlc2V0IHRoaXMgdmFsdWUgdG8gdGhlIHN5c3RlbSdzIHRpbWUgem9uZS5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBzZXQgZGVmYXVsdFpvbmUoem9uZSkge1xuICAgIGRlZmF1bHRab25lID0gem9uZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRlZmF1bHQgdGltZSB6b25lIG9iamVjdCBjdXJyZW50bHkgdXNlZCB0byBjcmVhdGUgRGF0ZVRpbWVzLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0aGUgc3lzdGVtJ3MgdGltZSB6b25lICh0aGUgb25lIHNldCBvbiB0aGUgbWFjaGluZSB0aGF0IHJ1bnMgdGhpcyBjb2RlKS5cbiAgICogQHR5cGUge1pvbmV9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRab25lKCkge1xuICAgIHJldHVybiBub3JtYWxpemVab25lKGRlZmF1bHRab25lLCBTeXN0ZW1ab25lLmluc3RhbmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRlZmF1bHQgbG9jYWxlIHRvIGNyZWF0ZSBEYXRlVGltZXMgd2l0aC4gRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdExvY2FsZSgpIHtcbiAgICByZXR1cm4gZGVmYXVsdExvY2FsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGRlZmF1bHQgbG9jYWxlIHRvIGNyZWF0ZSBEYXRlVGltZXMgd2l0aC4gRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBzZXQgZGVmYXVsdExvY2FsZShsb2NhbGUpIHtcbiAgICBkZWZhdWx0TG9jYWxlID0gbG9jYWxlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGVmYXVsdCBudW1iZXJpbmcgc3lzdGVtIHRvIGNyZWF0ZSBEYXRlVGltZXMgd2l0aC4gRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdE51bWJlcmluZ1N5c3RlbSgpIHtcbiAgICByZXR1cm4gZGVmYXVsdE51bWJlcmluZ1N5c3RlbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGRlZmF1bHQgbnVtYmVyaW5nIHN5c3RlbSB0byBjcmVhdGUgRGF0ZVRpbWVzIHdpdGguIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgc2V0IGRlZmF1bHROdW1iZXJpbmdTeXN0ZW0obnVtYmVyaW5nU3lzdGVtKSB7XG4gICAgZGVmYXVsdE51bWJlcmluZ1N5c3RlbSA9IG51bWJlcmluZ1N5c3RlbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRlZmF1bHQgb3V0cHV0IGNhbGVuZGFyIHRvIGNyZWF0ZSBEYXRlVGltZXMgd2l0aC4gRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdE91dHB1dENhbGVuZGFyKCkge1xuICAgIHJldHVybiBkZWZhdWx0T3V0cHV0Q2FsZW5kYXI7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBkZWZhdWx0IG91dHB1dCBjYWxlbmRhciB0byBjcmVhdGUgRGF0ZVRpbWVzIHdpdGguIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgc2V0IGRlZmF1bHRPdXRwdXRDYWxlbmRhcihvdXRwdXRDYWxlbmRhcikge1xuICAgIGRlZmF1bHRPdXRwdXRDYWxlbmRhciA9IG91dHB1dENhbGVuZGFyO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3V0b2ZmIHllYXIgYWZ0ZXIgd2hpY2ggYSBzdHJpbmcgZW5jb2RpbmcgYSB5ZWFyIGFzIHR3byBkaWdpdHMgaXMgaW50ZXJwcmV0ZWQgdG8gb2NjdXIgaW4gdGhlIGN1cnJlbnQgY2VudHVyeS5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHN0YXRpYyBnZXQgdHdvRGlnaXRDdXRvZmZZZWFyKCkge1xuICAgIHJldHVybiB0d29EaWdpdEN1dG9mZlllYXI7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBjdXRvZmYgeWVhciBhZnRlciB3aGljaCBhIHN0cmluZyBlbmNvZGluZyBhIHllYXIgYXMgdHdvIGRpZ2l0cyBpcyBpbnRlcnByZXRlZCB0byBvY2N1ciBpbiB0aGUgY3VycmVudCBjZW50dXJ5LlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZXhhbXBsZSBTZXR0aW5ncy50d29EaWdpdEN1dG9mZlllYXIgPSAwIC8vIGN1dC1vZmYgeWVhciBpcyAwLCBzbyBhbGwgJ3l5JyBhcmUgaW50ZXJwcmV0ZWQgYXMgY3VycmVudCBjZW50dXJ5XG4gICAqIEBleGFtcGxlIFNldHRpbmdzLnR3b0RpZ2l0Q3V0b2ZmWWVhciA9IDUwIC8vICc0OScgLT4gMTk0OTsgJzUwJyAtPiAyMDUwXG4gICAqIEBleGFtcGxlIFNldHRpbmdzLnR3b0RpZ2l0Q3V0b2ZmWWVhciA9IDE5NTAgLy8gaW50ZXJwcmV0ZWQgYXMgNTBcbiAgICogQGV4YW1wbGUgU2V0dGluZ3MudHdvRGlnaXRDdXRvZmZZZWFyID0gMjA1MCAvLyBBTFNPIGludGVycHJldGVkIGFzIDUwXG4gICAqL1xuICBzdGF0aWMgc2V0IHR3b0RpZ2l0Q3V0b2ZmWWVhcihjdXRvZmZZZWFyKSB7XG4gICAgdHdvRGlnaXRDdXRvZmZZZWFyID0gY3V0b2ZmWWVhciAlIDEwMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgd2hldGhlciBMdXhvbiB3aWxsIHRocm93IHdoZW4gaXQgZW5jb3VudGVycyBpbnZhbGlkIERhdGVUaW1lcywgRHVyYXRpb25zLCBvciBJbnRlcnZhbHNcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgZ2V0IHRocm93T25JbnZhbGlkKCkge1xuICAgIHJldHVybiB0aHJvd09uSW52YWxpZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgd2hldGhlciBMdXhvbiB3aWxsIHRocm93IHdoZW4gaXQgZW5jb3VudGVycyBpbnZhbGlkIERhdGVUaW1lcywgRHVyYXRpb25zLCBvciBJbnRlcnZhbHNcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgc2V0IHRocm93T25JbnZhbGlkKHQpIHtcbiAgICB0aHJvd09uSW52YWxpZCA9IHQ7XG4gIH1cblxuICAvKipcbiAgICogUmVzZXQgTHV4b24ncyBnbG9iYWwgY2FjaGVzLiBTaG91bGQgb25seSBiZSBuZWNlc3NhcnkgaW4gdGVzdGluZyBzY2VuYXJpb3MuXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBzdGF0aWMgcmVzZXRDYWNoZXMoKSB7XG4gICAgTG9jYWxlLnJlc2V0Q2FjaGUoKTtcbiAgICBJQU5BWm9uZS5yZXNldENhY2hlKCk7XG4gIH1cbn1cbiIsICIvKlxuICBUaGlzIGlzIGp1c3QgYSBqdW5rIGRyYXdlciwgY29udGFpbmluZyBhbnl0aGluZyB1c2VkIGFjcm9zcyBtdWx0aXBsZSBjbGFzc2VzLlxuICBCZWNhdXNlIEx1eG9uIGlzIHNtYWxsKGlzaCksIHRoaXMgc2hvdWxkIHN0YXkgc21hbGwgYW5kIHdlIHdvbid0IHdvcnJ5IGFib3V0IHNwbGl0dGluZ1xuICBpdCB1cCBpbnRvLCBzYXksIHBhcnNpbmdVdGlsLmpzIGFuZCBiYXNpY1V0aWwuanMgYW5kIHNvIG9uLiBCdXQgdGhleSBhcmUgZGl2aWRlZCB1cCBieSBmZWF0dXJlIGFyZWEuXG4qL1xuXG5pbXBvcnQgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9IGZyb20gXCIuLi9lcnJvcnMuanNcIjtcbmltcG9ydCBTZXR0aW5ncyBmcm9tIFwiLi4vc2V0dGluZ3MuanNcIjtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbi8vIFRZUEVTXG5cbmV4cG9ydCBmdW5jdGlvbiBpc1VuZGVmaW5lZChvKSB7XG4gIHJldHVybiB0eXBlb2YgbyA9PT0gXCJ1bmRlZmluZWRcIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTnVtYmVyKG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSBcIm51bWJlclwiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNJbnRlZ2VyKG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSBcIm51bWJlclwiICYmIG8gJSAxID09PSAwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpbmcobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09IFwic3RyaW5nXCI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0RhdGUobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pID09PSBcIltvYmplY3QgRGF0ZV1cIjtcbn1cblxuLy8gQ0FQQUJJTElUSUVTXG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNSZWxhdGl2ZSgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdHlwZW9mIEludGwgIT09IFwidW5kZWZpbmVkXCIgJiYgISFJbnRsLlJlbGF0aXZlVGltZUZvcm1hdDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vLyBPQkpFQ1RTIEFORCBBUlJBWVNcblxuZXhwb3J0IGZ1bmN0aW9uIG1heWJlQXJyYXkodGhpbmcpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodGhpbmcpID8gdGhpbmcgOiBbdGhpbmddO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmVzdEJ5KGFyciwgYnksIGNvbXBhcmUpIHtcbiAgaWYgKGFyci5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBhcnIucmVkdWNlKChiZXN0LCBuZXh0KSA9PiB7XG4gICAgY29uc3QgcGFpciA9IFtieShuZXh0KSwgbmV4dF07XG4gICAgaWYgKCFiZXN0KSB7XG4gICAgICByZXR1cm4gcGFpcjtcbiAgICB9IGVsc2UgaWYgKGNvbXBhcmUoYmVzdFswXSwgcGFpclswXSkgPT09IGJlc3RbMF0pIHtcbiAgICAgIHJldHVybiBiZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcGFpcjtcbiAgICB9XG4gIH0sIG51bGwpWzFdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGljayhvYmosIGtleXMpIHtcbiAgcmV0dXJuIGtleXMucmVkdWNlKChhLCBrKSA9PiB7XG4gICAgYVtrXSA9IG9ialtrXTtcbiAgICByZXR1cm4gYTtcbiAgfSwge30pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxuLy8gTlVNQkVSUyBBTkQgU1RSSU5HU1xuXG5leHBvcnQgZnVuY3Rpb24gaW50ZWdlckJldHdlZW4odGhpbmcsIGJvdHRvbSwgdG9wKSB7XG4gIHJldHVybiBpc0ludGVnZXIodGhpbmcpICYmIHRoaW5nID49IGJvdHRvbSAmJiB0aGluZyA8PSB0b3A7XG59XG5cbi8vIHggJSBuIGJ1dCB0YWtlcyB0aGUgc2lnbiBvZiBuIGluc3RlYWQgb2YgeFxuZXhwb3J0IGZ1bmN0aW9uIGZsb29yTW9kKHgsIG4pIHtcbiAgcmV0dXJuIHggLSBuICogTWF0aC5mbG9vcih4IC8gbik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYWRTdGFydChpbnB1dCwgbiA9IDIpIHtcbiAgY29uc3QgaXNOZWcgPSBpbnB1dCA8IDA7XG4gIGxldCBwYWRkZWQ7XG4gIGlmIChpc05lZykge1xuICAgIHBhZGRlZCA9IFwiLVwiICsgKFwiXCIgKyAtaW5wdXQpLnBhZFN0YXJ0KG4sIFwiMFwiKTtcbiAgfSBlbHNlIHtcbiAgICBwYWRkZWQgPSAoXCJcIiArIGlucHV0KS5wYWRTdGFydChuLCBcIjBcIik7XG4gIH1cbiAgcmV0dXJuIHBhZGRlZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSW50ZWdlcihzdHJpbmcpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHN0cmluZykgfHwgc3RyaW5nID09PSBudWxsIHx8IHN0cmluZyA9PT0gXCJcIikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHN0cmluZywgMTApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUZsb2F0aW5nKHN0cmluZykge1xuICBpZiAoaXNVbmRlZmluZWQoc3RyaW5nKSB8fCBzdHJpbmcgPT09IG51bGwgfHwgc3RyaW5nID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChzdHJpbmcpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZU1pbGxpcyhmcmFjdGlvbikge1xuICAvLyBSZXR1cm4gdW5kZWZpbmVkIChpbnN0ZWFkIG9mIDApIGluIHRoZXNlIGNhc2VzLCB3aGVyZSBmcmFjdGlvbiBpcyBub3Qgc2V0XG4gIGlmIChpc1VuZGVmaW5lZChmcmFjdGlvbikgfHwgZnJhY3Rpb24gPT09IG51bGwgfHwgZnJhY3Rpb24gPT09IFwiXCIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGYgPSBwYXJzZUZsb2F0KFwiMC5cIiArIGZyYWN0aW9uKSAqIDEwMDA7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoZik7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kVG8obnVtYmVyLCBkaWdpdHMsIHRvd2FyZFplcm8gPSBmYWxzZSkge1xuICBjb25zdCBmYWN0b3IgPSAxMCAqKiBkaWdpdHMsXG4gICAgcm91bmRlciA9IHRvd2FyZFplcm8gPyBNYXRoLnRydW5jIDogTWF0aC5yb3VuZDtcbiAgcmV0dXJuIHJvdW5kZXIobnVtYmVyICogZmFjdG9yKSAvIGZhY3Rvcjtcbn1cblxuLy8gREFURSBCQVNJQ1NcblxuZXhwb3J0IGZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcikge1xuICByZXR1cm4geWVhciAlIDQgPT09IDAgJiYgKHllYXIgJSAxMDAgIT09IDAgfHwgeWVhciAlIDQwMCA9PT0gMCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkYXlzSW5ZZWFyKHllYXIpIHtcbiAgcmV0dXJuIGlzTGVhcFllYXIoeWVhcikgPyAzNjYgOiAzNjU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkYXlzSW5Nb250aCh5ZWFyLCBtb250aCkge1xuICBjb25zdCBtb2RNb250aCA9IGZsb29yTW9kKG1vbnRoIC0gMSwgMTIpICsgMSxcbiAgICBtb2RZZWFyID0geWVhciArIChtb250aCAtIG1vZE1vbnRoKSAvIDEyO1xuXG4gIGlmIChtb2RNb250aCA9PT0gMikge1xuICAgIHJldHVybiBpc0xlYXBZZWFyKG1vZFllYXIpID8gMjkgOiAyODtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gWzMxLCBudWxsLCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV1bbW9kTW9udGggLSAxXTtcbiAgfVxufVxuXG4vLyBjb252ZXJ0IGEgY2FsZW5kYXIgb2JqZWN0IHRvIGEgbG9jYWwgdGltZXN0YW1wIChlcG9jaCwgYnV0IHdpdGggdGhlIG9mZnNldCBiYWtlZCBpbilcbmV4cG9ydCBmdW5jdGlvbiBvYmpUb0xvY2FsVFMob2JqKSB7XG4gIGxldCBkID0gRGF0ZS5VVEMoXG4gICAgb2JqLnllYXIsXG4gICAgb2JqLm1vbnRoIC0gMSxcbiAgICBvYmouZGF5LFxuICAgIG9iai5ob3VyLFxuICAgIG9iai5taW51dGUsXG4gICAgb2JqLnNlY29uZCxcbiAgICBvYmoubWlsbGlzZWNvbmRcbiAgKTtcblxuICAvLyBmb3IgbGVnYWN5IHJlYXNvbnMsIHllYXJzIGJldHdlZW4gMCBhbmQgOTkgYXJlIGludGVycHJldGVkIGFzIDE5WFg7IHJldmVydCB0aGF0XG4gIGlmIChvYmoueWVhciA8IDEwMCAmJiBvYmoueWVhciA+PSAwKSB7XG4gICAgZCA9IG5ldyBEYXRlKGQpO1xuICAgIC8vIHNldCB0aGUgbW9udGggYW5kIGRheSBhZ2FpbiwgdGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSB5ZWFyIDIwMDAgaXMgYSBsZWFwIHllYXIsIGJ1dCB5ZWFyIDEwMCBpcyBub3RcbiAgICAvLyBzbyBpZiBvYmoueWVhciBpcyBpbiA5OSwgYnV0IG9iai5kYXkgbWFrZXMgaXQgcm9sbCBvdmVyIGludG8geWVhciAxMDAsXG4gICAgLy8gdGhlIGNhbGN1bGF0aW9ucyBkb25lIGJ5IERhdGUuVVRDIGFyZSB1c2luZyB5ZWFyIDIwMDAgLSB3aGljaCBpcyBpbmNvcnJlY3RcbiAgICBkLnNldFVUQ0Z1bGxZZWFyKG9iai55ZWFyLCBvYmoubW9udGggLSAxLCBvYmouZGF5KTtcbiAgfVxuICByZXR1cm4gK2Q7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3ZWVrc0luV2Vla1llYXIod2Vla1llYXIpIHtcbiAgY29uc3QgcDEgPVxuICAgICAgKHdlZWtZZWFyICtcbiAgICAgICAgTWF0aC5mbG9vcih3ZWVrWWVhciAvIDQpIC1cbiAgICAgICAgTWF0aC5mbG9vcih3ZWVrWWVhciAvIDEwMCkgK1xuICAgICAgICBNYXRoLmZsb29yKHdlZWtZZWFyIC8gNDAwKSkgJVxuICAgICAgNyxcbiAgICBsYXN0ID0gd2Vla1llYXIgLSAxLFxuICAgIHAyID0gKGxhc3QgKyBNYXRoLmZsb29yKGxhc3QgLyA0KSAtIE1hdGguZmxvb3IobGFzdCAvIDEwMCkgKyBNYXRoLmZsb29yKGxhc3QgLyA0MDApKSAlIDc7XG4gIHJldHVybiBwMSA9PT0gNCB8fCBwMiA9PT0gMyA/IDUzIDogNTI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bnRydW5jYXRlWWVhcih5ZWFyKSB7XG4gIGlmICh5ZWFyID4gOTkpIHtcbiAgICByZXR1cm4geWVhcjtcbiAgfSBlbHNlIHJldHVybiB5ZWFyID4gU2V0dGluZ3MudHdvRGlnaXRDdXRvZmZZZWFyID8gMTkwMCArIHllYXIgOiAyMDAwICsgeWVhcjtcbn1cblxuLy8gUEFSU0lOR1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2Vab25lSW5mbyh0cywgb2Zmc2V0Rm9ybWF0LCBsb2NhbGUsIHRpbWVab25lID0gbnVsbCkge1xuICBjb25zdCBkYXRlID0gbmV3IERhdGUodHMpLFxuICAgIGludGxPcHRzID0ge1xuICAgICAgaG91ckN5Y2xlOiBcImgyM1wiLFxuICAgICAgeWVhcjogXCJudW1lcmljXCIsXG4gICAgICBtb250aDogXCIyLWRpZ2l0XCIsXG4gICAgICBkYXk6IFwiMi1kaWdpdFwiLFxuICAgICAgaG91cjogXCIyLWRpZ2l0XCIsXG4gICAgICBtaW51dGU6IFwiMi1kaWdpdFwiLFxuICAgIH07XG5cbiAgaWYgKHRpbWVab25lKSB7XG4gICAgaW50bE9wdHMudGltZVpvbmUgPSB0aW1lWm9uZTtcbiAgfVxuXG4gIGNvbnN0IG1vZGlmaWVkID0geyB0aW1lWm9uZU5hbWU6IG9mZnNldEZvcm1hdCwgLi4uaW50bE9wdHMgfTtcblxuICBjb25zdCBwYXJzZWQgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIG1vZGlmaWVkKVxuICAgIC5mb3JtYXRUb1BhcnRzKGRhdGUpXG4gICAgLmZpbmQoKG0pID0+IG0udHlwZS50b0xvd2VyQ2FzZSgpID09PSBcInRpbWV6b25lbmFtZVwiKTtcbiAgcmV0dXJuIHBhcnNlZCA/IHBhcnNlZC52YWx1ZSA6IG51bGw7XG59XG5cbi8vIHNpZ25lZE9mZnNldCgnLTUnLCAnMzAnKSAtPiAtMzMwXG5leHBvcnQgZnVuY3Rpb24gc2lnbmVkT2Zmc2V0KG9mZkhvdXJTdHIsIG9mZk1pbnV0ZVN0cikge1xuICBsZXQgb2ZmSG91ciA9IHBhcnNlSW50KG9mZkhvdXJTdHIsIDEwKTtcblxuICAvLyBkb24ndCB8fCB0aGlzIGJlY2F1c2Ugd2Ugd2FudCB0byBwcmVzZXJ2ZSAtMFxuICBpZiAoTnVtYmVyLmlzTmFOKG9mZkhvdXIpKSB7XG4gICAgb2ZmSG91ciA9IDA7XG4gIH1cblxuICBjb25zdCBvZmZNaW4gPSBwYXJzZUludChvZmZNaW51dGVTdHIsIDEwKSB8fCAwLFxuICAgIG9mZk1pblNpZ25lZCA9IG9mZkhvdXIgPCAwIHx8IE9iamVjdC5pcyhvZmZIb3VyLCAtMCkgPyAtb2ZmTWluIDogb2ZmTWluO1xuICByZXR1cm4gb2ZmSG91ciAqIDYwICsgb2ZmTWluU2lnbmVkO1xufVxuXG4vLyBDT0VSQ0lPTlxuXG5leHBvcnQgZnVuY3Rpb24gYXNOdW1iZXIodmFsdWUpIHtcbiAgY29uc3QgbnVtZXJpY1ZhbHVlID0gTnVtYmVyKHZhbHVlKTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIgfHwgdmFsdWUgPT09IFwiXCIgfHwgTnVtYmVyLmlzTmFOKG51bWVyaWNWYWx1ZSkpXG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKGBJbnZhbGlkIHVuaXQgdmFsdWUgJHt2YWx1ZX1gKTtcbiAgcmV0dXJuIG51bWVyaWNWYWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZU9iamVjdChvYmosIG5vcm1hbGl6ZXIpIHtcbiAgY29uc3Qgbm9ybWFsaXplZCA9IHt9O1xuICBmb3IgKGNvbnN0IHUgaW4gb2JqKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KG9iaiwgdSkpIHtcbiAgICAgIGNvbnN0IHYgPSBvYmpbdV07XG4gICAgICBpZiAodiA9PT0gdW5kZWZpbmVkIHx8IHYgPT09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgbm9ybWFsaXplZFtub3JtYWxpemVyKHUpXSA9IGFzTnVtYmVyKHYpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbm9ybWFsaXplZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdE9mZnNldChvZmZzZXQsIGZvcm1hdCkge1xuICBjb25zdCBob3VycyA9IE1hdGgudHJ1bmMoTWF0aC5hYnMob2Zmc2V0IC8gNjApKSxcbiAgICBtaW51dGVzID0gTWF0aC50cnVuYyhNYXRoLmFicyhvZmZzZXQgJSA2MCkpLFxuICAgIHNpZ24gPSBvZmZzZXQgPj0gMCA/IFwiK1wiIDogXCItXCI7XG5cbiAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICBjYXNlIFwic2hvcnRcIjpcbiAgICAgIHJldHVybiBgJHtzaWdufSR7cGFkU3RhcnQoaG91cnMsIDIpfToke3BhZFN0YXJ0KG1pbnV0ZXMsIDIpfWA7XG4gICAgY2FzZSBcIm5hcnJvd1wiOlxuICAgICAgcmV0dXJuIGAke3NpZ259JHtob3Vyc30ke21pbnV0ZXMgPiAwID8gYDoke21pbnV0ZXN9YCA6IFwiXCJ9YDtcbiAgICBjYXNlIFwidGVjaGllXCI6XG4gICAgICByZXR1cm4gYCR7c2lnbn0ke3BhZFN0YXJ0KGhvdXJzLCAyKX0ke3BhZFN0YXJ0KG1pbnV0ZXMsIDIpfWA7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBWYWx1ZSBmb3JtYXQgJHtmb3JtYXR9IGlzIG91dCBvZiByYW5nZSBmb3IgcHJvcGVydHkgZm9ybWF0YCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRpbWVPYmplY3Qob2JqKSB7XG4gIHJldHVybiBwaWNrKG9iaiwgW1wiaG91clwiLCBcIm1pbnV0ZVwiLCBcInNlY29uZFwiLCBcIm1pbGxpc2Vjb25kXCJdKTtcbn1cbiIsICJpbXBvcnQgKiBhcyBGb3JtYXRzIGZyb20gXCIuL2Zvcm1hdHMuanNcIjtcbmltcG9ydCB7IHBpY2sgfSBmcm9tIFwiLi91dGlsLmpzXCI7XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeShvYmopIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaiwgT2JqZWN0LmtleXMob2JqKS5zb3J0KCkpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0IGNvbnN0IG1vbnRoc0xvbmcgPSBbXG4gIFwiSmFudWFyeVwiLFxuICBcIkZlYnJ1YXJ5XCIsXG4gIFwiTWFyY2hcIixcbiAgXCJBcHJpbFwiLFxuICBcIk1heVwiLFxuICBcIkp1bmVcIixcbiAgXCJKdWx5XCIsXG4gIFwiQXVndXN0XCIsXG4gIFwiU2VwdGVtYmVyXCIsXG4gIFwiT2N0b2JlclwiLFxuICBcIk5vdmVtYmVyXCIsXG4gIFwiRGVjZW1iZXJcIixcbl07XG5cbmV4cG9ydCBjb25zdCBtb250aHNTaG9ydCA9IFtcbiAgXCJKYW5cIixcbiAgXCJGZWJcIixcbiAgXCJNYXJcIixcbiAgXCJBcHJcIixcbiAgXCJNYXlcIixcbiAgXCJKdW5cIixcbiAgXCJKdWxcIixcbiAgXCJBdWdcIixcbiAgXCJTZXBcIixcbiAgXCJPY3RcIixcbiAgXCJOb3ZcIixcbiAgXCJEZWNcIixcbl07XG5cbmV4cG9ydCBjb25zdCBtb250aHNOYXJyb3cgPSBbXCJKXCIsIFwiRlwiLCBcIk1cIiwgXCJBXCIsIFwiTVwiLCBcIkpcIiwgXCJKXCIsIFwiQVwiLCBcIlNcIiwgXCJPXCIsIFwiTlwiLCBcIkRcIl07XG5cbmV4cG9ydCBmdW5jdGlvbiBtb250aHMobGVuZ3RoKSB7XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSBcIm5hcnJvd1wiOlxuICAgICAgcmV0dXJuIFsuLi5tb250aHNOYXJyb3ddO1xuICAgIGNhc2UgXCJzaG9ydFwiOlxuICAgICAgcmV0dXJuIFsuLi5tb250aHNTaG9ydF07XG4gICAgY2FzZSBcImxvbmdcIjpcbiAgICAgIHJldHVybiBbLi4ubW9udGhzTG9uZ107XG4gICAgY2FzZSBcIm51bWVyaWNcIjpcbiAgICAgIHJldHVybiBbXCIxXCIsIFwiMlwiLCBcIjNcIiwgXCI0XCIsIFwiNVwiLCBcIjZcIiwgXCI3XCIsIFwiOFwiLCBcIjlcIiwgXCIxMFwiLCBcIjExXCIsIFwiMTJcIl07XG4gICAgY2FzZSBcIjItZGlnaXRcIjpcbiAgICAgIHJldHVybiBbXCIwMVwiLCBcIjAyXCIsIFwiMDNcIiwgXCIwNFwiLCBcIjA1XCIsIFwiMDZcIiwgXCIwN1wiLCBcIjA4XCIsIFwiMDlcIiwgXCIxMFwiLCBcIjExXCIsIFwiMTJcIl07XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCB3ZWVrZGF5c0xvbmcgPSBbXG4gIFwiTW9uZGF5XCIsXG4gIFwiVHVlc2RheVwiLFxuICBcIldlZG5lc2RheVwiLFxuICBcIlRodXJzZGF5XCIsXG4gIFwiRnJpZGF5XCIsXG4gIFwiU2F0dXJkYXlcIixcbiAgXCJTdW5kYXlcIixcbl07XG5cbmV4cG9ydCBjb25zdCB3ZWVrZGF5c1Nob3J0ID0gW1wiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCIsIFwiU3VuXCJdO1xuXG5leHBvcnQgY29uc3Qgd2Vla2RheXNOYXJyb3cgPSBbXCJNXCIsIFwiVFwiLCBcIldcIiwgXCJUXCIsIFwiRlwiLCBcIlNcIiwgXCJTXCJdO1xuXG5leHBvcnQgZnVuY3Rpb24gd2Vla2RheXMobGVuZ3RoKSB7XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSBcIm5hcnJvd1wiOlxuICAgICAgcmV0dXJuIFsuLi53ZWVrZGF5c05hcnJvd107XG4gICAgY2FzZSBcInNob3J0XCI6XG4gICAgICByZXR1cm4gWy4uLndlZWtkYXlzU2hvcnRdO1xuICAgIGNhc2UgXCJsb25nXCI6XG4gICAgICByZXR1cm4gWy4uLndlZWtkYXlzTG9uZ107XG4gICAgY2FzZSBcIm51bWVyaWNcIjpcbiAgICAgIHJldHVybiBbXCIxXCIsIFwiMlwiLCBcIjNcIiwgXCI0XCIsIFwiNVwiLCBcIjZcIiwgXCI3XCJdO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgbWVyaWRpZW1zID0gW1wiQU1cIiwgXCJQTVwiXTtcblxuZXhwb3J0IGNvbnN0IGVyYXNMb25nID0gW1wiQmVmb3JlIENocmlzdFwiLCBcIkFubm8gRG9taW5pXCJdO1xuXG5leHBvcnQgY29uc3QgZXJhc1Nob3J0ID0gW1wiQkNcIiwgXCJBRFwiXTtcblxuZXhwb3J0IGNvbnN0IGVyYXNOYXJyb3cgPSBbXCJCXCIsIFwiQVwiXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGVyYXMobGVuZ3RoKSB7XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSBcIm5hcnJvd1wiOlxuICAgICAgcmV0dXJuIFsuLi5lcmFzTmFycm93XTtcbiAgICBjYXNlIFwic2hvcnRcIjpcbiAgICAgIHJldHVybiBbLi4uZXJhc1Nob3J0XTtcbiAgICBjYXNlIFwibG9uZ1wiOlxuICAgICAgcmV0dXJuIFsuLi5lcmFzTG9uZ107XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJpZGllbUZvckRhdGVUaW1lKGR0KSB7XG4gIHJldHVybiBtZXJpZGllbXNbZHQuaG91ciA8IDEyID8gMCA6IDFdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2Vla2RheUZvckRhdGVUaW1lKGR0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIHdlZWtkYXlzKGxlbmd0aClbZHQud2Vla2RheSAtIDFdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbW9udGhGb3JEYXRlVGltZShkdCwgbGVuZ3RoKSB7XG4gIHJldHVybiBtb250aHMobGVuZ3RoKVtkdC5tb250aCAtIDFdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXJhRm9yRGF0ZVRpbWUoZHQsIGxlbmd0aCkge1xuICByZXR1cm4gZXJhcyhsZW5ndGgpW2R0LnllYXIgPCAwID8gMCA6IDFdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0UmVsYXRpdmVUaW1lKHVuaXQsIGNvdW50LCBudW1lcmljID0gXCJhbHdheXNcIiwgbmFycm93ID0gZmFsc2UpIHtcbiAgY29uc3QgdW5pdHMgPSB7XG4gICAgeWVhcnM6IFtcInllYXJcIiwgXCJ5ci5cIl0sXG4gICAgcXVhcnRlcnM6IFtcInF1YXJ0ZXJcIiwgXCJxdHIuXCJdLFxuICAgIG1vbnRoczogW1wibW9udGhcIiwgXCJtby5cIl0sXG4gICAgd2Vla3M6IFtcIndlZWtcIiwgXCJ3ay5cIl0sXG4gICAgZGF5czogW1wiZGF5XCIsIFwiZGF5XCIsIFwiZGF5c1wiXSxcbiAgICBob3VyczogW1wiaG91clwiLCBcImhyLlwiXSxcbiAgICBtaW51dGVzOiBbXCJtaW51dGVcIiwgXCJtaW4uXCJdLFxuICAgIHNlY29uZHM6IFtcInNlY29uZFwiLCBcInNlYy5cIl0sXG4gIH07XG5cbiAgY29uc3QgbGFzdGFibGUgPSBbXCJob3Vyc1wiLCBcIm1pbnV0ZXNcIiwgXCJzZWNvbmRzXCJdLmluZGV4T2YodW5pdCkgPT09IC0xO1xuXG4gIGlmIChudW1lcmljID09PSBcImF1dG9cIiAmJiBsYXN0YWJsZSkge1xuICAgIGNvbnN0IGlzRGF5ID0gdW5pdCA9PT0gXCJkYXlzXCI7XG4gICAgc3dpdGNoIChjb3VudCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gaXNEYXkgPyBcInRvbW9ycm93XCIgOiBgbmV4dCAke3VuaXRzW3VuaXRdWzBdfWA7XG4gICAgICBjYXNlIC0xOlxuICAgICAgICByZXR1cm4gaXNEYXkgPyBcInllc3RlcmRheVwiIDogYGxhc3QgJHt1bml0c1t1bml0XVswXX1gO1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gaXNEYXkgPyBcInRvZGF5XCIgOiBgdGhpcyAke3VuaXRzW3VuaXRdWzBdfWA7XG4gICAgICBkZWZhdWx0OiAvLyBmYWxsIHRocm91Z2hcbiAgICB9XG4gIH1cblxuICBjb25zdCBpc0luUGFzdCA9IE9iamVjdC5pcyhjb3VudCwgLTApIHx8IGNvdW50IDwgMCxcbiAgICBmbXRWYWx1ZSA9IE1hdGguYWJzKGNvdW50KSxcbiAgICBzaW5ndWxhciA9IGZtdFZhbHVlID09PSAxLFxuICAgIGxpbFVuaXRzID0gdW5pdHNbdW5pdF0sXG4gICAgZm10VW5pdCA9IG5hcnJvd1xuICAgICAgPyBzaW5ndWxhclxuICAgICAgICA/IGxpbFVuaXRzWzFdXG4gICAgICAgIDogbGlsVW5pdHNbMl0gfHwgbGlsVW5pdHNbMV1cbiAgICAgIDogc2luZ3VsYXJcbiAgICAgID8gdW5pdHNbdW5pdF1bMF1cbiAgICAgIDogdW5pdDtcbiAgcmV0dXJuIGlzSW5QYXN0ID8gYCR7Zm10VmFsdWV9ICR7Zm10VW5pdH0gYWdvYCA6IGBpbiAke2ZtdFZhbHVlfSAke2ZtdFVuaXR9YDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFN0cmluZyhrbm93bkZvcm1hdCkge1xuICAvLyB0aGVzZSBhbGwgaGF2ZSB0aGUgb2Zmc2V0cyByZW1vdmVkIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBhY2Nlc3MgdG8gdGhlbVxuICAvLyB3aXRob3V0IGFsbCB0aGUgaW50bCBzdHVmZiB0aGlzIGlzIGJhY2tmaWxsaW5nXG4gIGNvbnN0IGZpbHRlcmVkID0gcGljayhrbm93bkZvcm1hdCwgW1xuICAgICAgXCJ3ZWVrZGF5XCIsXG4gICAgICBcImVyYVwiLFxuICAgICAgXCJ5ZWFyXCIsXG4gICAgICBcIm1vbnRoXCIsXG4gICAgICBcImRheVwiLFxuICAgICAgXCJob3VyXCIsXG4gICAgICBcIm1pbnV0ZVwiLFxuICAgICAgXCJzZWNvbmRcIixcbiAgICAgIFwidGltZVpvbmVOYW1lXCIsXG4gICAgICBcImhvdXJDeWNsZVwiLFxuICAgIF0pLFxuICAgIGtleSA9IHN0cmluZ2lmeShmaWx0ZXJlZCksXG4gICAgZGF0ZVRpbWVIdWdlID0gXCJFRUVFLCBMTExMIGQsIHl5eXksIGg6bW0gYVwiO1xuICBzd2l0Y2ggKGtleSkge1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURV9TSE9SVCk6XG4gICAgICByZXR1cm4gXCJNL2QveXl5eVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURV9NRUQpOlxuICAgICAgcmV0dXJuIFwiTExMIGQsIHl5eXlcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVfTUVEX1dJVEhfV0VFS0RBWSk6XG4gICAgICByZXR1cm4gXCJFRUUsIExMTCBkLCB5eXl5XCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFX0ZVTEwpOlxuICAgICAgcmV0dXJuIFwiTExMTCBkLCB5eXl5XCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFX0hVR0UpOlxuICAgICAgcmV0dXJuIFwiRUVFRSwgTExMTCBkLCB5eXl5XCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5USU1FX1NJTVBMRSk6XG4gICAgICByZXR1cm4gXCJoOm1tIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLlRJTUVfV0lUSF9TRUNPTkRTKTpcbiAgICAgIHJldHVybiBcImg6bW06c3MgYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuVElNRV9XSVRIX1NIT1JUX09GRlNFVCk6XG4gICAgICByZXR1cm4gXCJoOm1tIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLlRJTUVfV0lUSF9MT05HX09GRlNFVCk6XG4gICAgICByZXR1cm4gXCJoOm1tIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLlRJTUVfMjRfU0lNUExFKTpcbiAgICAgIHJldHVybiBcIkhIOm1tXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5USU1FXzI0X1dJVEhfU0VDT05EUyk6XG4gICAgICByZXR1cm4gXCJISDptbTpzc1wiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuVElNRV8yNF9XSVRIX1NIT1JUX09GRlNFVCk6XG4gICAgICByZXR1cm4gXCJISDptbVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuVElNRV8yNF9XSVRIX0xPTkdfT0ZGU0VUKTpcbiAgICAgIHJldHVybiBcIkhIOm1tXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9TSE9SVCk6XG4gICAgICByZXR1cm4gXCJNL2QveXl5eSwgaDptbSBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9NRUQpOlxuICAgICAgcmV0dXJuIFwiTExMIGQsIHl5eXksIGg6bW0gYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfRlVMTCk6XG4gICAgICByZXR1cm4gXCJMTExMIGQsIHl5eXksIGg6bW0gYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfSFVHRSk6XG4gICAgICByZXR1cm4gZGF0ZVRpbWVIdWdlO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfU0hPUlRfV0lUSF9TRUNPTkRTKTpcbiAgICAgIHJldHVybiBcIk0vZC95eXl5LCBoOm1tOnNzIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX01FRF9XSVRIX1NFQ09ORFMpOlxuICAgICAgcmV0dXJuIFwiTExMIGQsIHl5eXksIGg6bW06c3MgYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfTUVEX1dJVEhfV0VFS0RBWSk6XG4gICAgICByZXR1cm4gXCJFRUUsIGQgTExMIHl5eXksIGg6bW0gYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfRlVMTF9XSVRIX1NFQ09ORFMpOlxuICAgICAgcmV0dXJuIFwiTExMTCBkLCB5eXl5LCBoOm1tOnNzIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX0hVR0VfV0lUSF9TRUNPTkRTKTpcbiAgICAgIHJldHVybiBcIkVFRUUsIExMTEwgZCwgeXl5eSwgaDptbTpzcyBhXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBkYXRlVGltZUh1Z2U7XG4gIH1cbn1cbiIsICJpbXBvcnQgKiBhcyBFbmdsaXNoIGZyb20gXCIuL2VuZ2xpc2guanNcIjtcbmltcG9ydCAqIGFzIEZvcm1hdHMgZnJvbSBcIi4vZm9ybWF0cy5qc1wiO1xuaW1wb3J0IHsgcGFkU3RhcnQgfSBmcm9tIFwiLi91dGlsLmpzXCI7XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeVRva2VucyhzcGxpdHMsIHRva2VuVG9TdHJpbmcpIHtcbiAgbGV0IHMgPSBcIlwiO1xuICBmb3IgKGNvbnN0IHRva2VuIG9mIHNwbGl0cykge1xuICAgIGlmICh0b2tlbi5saXRlcmFsKSB7XG4gICAgICBzICs9IHRva2VuLnZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcyArPSB0b2tlblRvU3RyaW5nKHRva2VuLnZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzO1xufVxuXG5jb25zdCBtYWNyb1Rva2VuVG9Gb3JtYXRPcHRzID0ge1xuICBEOiBGb3JtYXRzLkRBVEVfU0hPUlQsXG4gIEREOiBGb3JtYXRzLkRBVEVfTUVELFxuICBEREQ6IEZvcm1hdHMuREFURV9GVUxMLFxuICBEREREOiBGb3JtYXRzLkRBVEVfSFVHRSxcbiAgdDogRm9ybWF0cy5USU1FX1NJTVBMRSxcbiAgdHQ6IEZvcm1hdHMuVElNRV9XSVRIX1NFQ09ORFMsXG4gIHR0dDogRm9ybWF0cy5USU1FX1dJVEhfU0hPUlRfT0ZGU0VULFxuICB0dHR0OiBGb3JtYXRzLlRJTUVfV0lUSF9MT05HX09GRlNFVCxcbiAgVDogRm9ybWF0cy5USU1FXzI0X1NJTVBMRSxcbiAgVFQ6IEZvcm1hdHMuVElNRV8yNF9XSVRIX1NFQ09ORFMsXG4gIFRUVDogRm9ybWF0cy5USU1FXzI0X1dJVEhfU0hPUlRfT0ZGU0VULFxuICBUVFRUOiBGb3JtYXRzLlRJTUVfMjRfV0lUSF9MT05HX09GRlNFVCxcbiAgZjogRm9ybWF0cy5EQVRFVElNRV9TSE9SVCxcbiAgZmY6IEZvcm1hdHMuREFURVRJTUVfTUVELFxuICBmZmY6IEZvcm1hdHMuREFURVRJTUVfRlVMTCxcbiAgZmZmZjogRm9ybWF0cy5EQVRFVElNRV9IVUdFLFxuICBGOiBGb3JtYXRzLkRBVEVUSU1FX1NIT1JUX1dJVEhfU0VDT05EUyxcbiAgRkY6IEZvcm1hdHMuREFURVRJTUVfTUVEX1dJVEhfU0VDT05EUyxcbiAgRkZGOiBGb3JtYXRzLkRBVEVUSU1FX0ZVTExfV0lUSF9TRUNPTkRTLFxuICBGRkZGOiBGb3JtYXRzLkRBVEVUSU1FX0hVR0VfV0lUSF9TRUNPTkRTLFxufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZvcm1hdHRlciB7XG4gIHN0YXRpYyBjcmVhdGUobG9jYWxlLCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gbmV3IEZvcm1hdHRlcihsb2NhbGUsIG9wdHMpO1xuICB9XG5cbiAgc3RhdGljIHBhcnNlRm9ybWF0KGZtdCkge1xuICAgIC8vIHdoaXRlLXNwYWNlIGlzIGFsd2F5cyBjb25zaWRlcmVkIGEgbGl0ZXJhbCBpbiB1c2VyLXByb3ZpZGVkIGZvcm1hdHNcbiAgICAvLyB0aGUgXCIgXCIgdG9rZW4gaGFzIGEgc3BlY2lhbCBtZWFuaW5nIChzZWUgdW5pdEZvclRva2VuKVxuXG4gICAgbGV0IGN1cnJlbnQgPSBudWxsLFxuICAgICAgY3VycmVudEZ1bGwgPSBcIlwiLFxuICAgICAgYnJhY2tldGVkID0gZmFsc2U7XG4gICAgY29uc3Qgc3BsaXRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGMgPSBmbXQuY2hhckF0KGkpO1xuICAgICAgaWYgKGMgPT09IFwiJ1wiKSB7XG4gICAgICAgIGlmIChjdXJyZW50RnVsbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgc3BsaXRzLnB1c2goeyBsaXRlcmFsOiBicmFja2V0ZWQgfHwgL15cXHMrJC8udGVzdChjdXJyZW50RnVsbCksIHZhbDogY3VycmVudEZ1bGwgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IG51bGw7XG4gICAgICAgIGN1cnJlbnRGdWxsID0gXCJcIjtcbiAgICAgICAgYnJhY2tldGVkID0gIWJyYWNrZXRlZDtcbiAgICAgIH0gZWxzZSBpZiAoYnJhY2tldGVkKSB7XG4gICAgICAgIGN1cnJlbnRGdWxsICs9IGM7XG4gICAgICB9IGVsc2UgaWYgKGMgPT09IGN1cnJlbnQpIHtcbiAgICAgICAgY3VycmVudEZ1bGwgKz0gYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjdXJyZW50RnVsbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgc3BsaXRzLnB1c2goeyBsaXRlcmFsOiAvXlxccyskLy50ZXN0KGN1cnJlbnRGdWxsKSwgdmFsOiBjdXJyZW50RnVsbCB9KTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50RnVsbCA9IGM7XG4gICAgICAgIGN1cnJlbnQgPSBjO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjdXJyZW50RnVsbC5sZW5ndGggPiAwKSB7XG4gICAgICBzcGxpdHMucHVzaCh7IGxpdGVyYWw6IGJyYWNrZXRlZCB8fCAvXlxccyskLy50ZXN0KGN1cnJlbnRGdWxsKSwgdmFsOiBjdXJyZW50RnVsbCB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3BsaXRzO1xuICB9XG5cbiAgc3RhdGljIG1hY3JvVG9rZW5Ub0Zvcm1hdE9wdHModG9rZW4pIHtcbiAgICByZXR1cm4gbWFjcm9Ub2tlblRvRm9ybWF0T3B0c1t0b2tlbl07XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihsb2NhbGUsIGZvcm1hdE9wdHMpIHtcbiAgICB0aGlzLm9wdHMgPSBmb3JtYXRPcHRzO1xuICAgIHRoaXMubG9jID0gbG9jYWxlO1xuICAgIHRoaXMuc3lzdGVtTG9jID0gbnVsbDtcbiAgfVxuXG4gIGZvcm1hdFdpdGhTeXN0ZW1EZWZhdWx0KGR0LCBvcHRzKSB7XG4gICAgaWYgKHRoaXMuc3lzdGVtTG9jID09PSBudWxsKSB7XG4gICAgICB0aGlzLnN5c3RlbUxvYyA9IHRoaXMubG9jLnJlZGVmYXVsdFRvU3lzdGVtKCk7XG4gICAgfVxuICAgIGNvbnN0IGRmID0gdGhpcy5zeXN0ZW1Mb2MuZHRGb3JtYXR0ZXIoZHQsIHsgLi4udGhpcy5vcHRzLCAuLi5vcHRzIH0pO1xuICAgIHJldHVybiBkZi5mb3JtYXQoKTtcbiAgfVxuXG4gIGR0Rm9ybWF0dGVyKGR0LCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5sb2MuZHRGb3JtYXR0ZXIoZHQsIHsgLi4udGhpcy5vcHRzLCAuLi5vcHRzIH0pO1xuICB9XG5cbiAgZm9ybWF0RGF0ZVRpbWUoZHQsIG9wdHMpIHtcbiAgICByZXR1cm4gdGhpcy5kdEZvcm1hdHRlcihkdCwgb3B0cykuZm9ybWF0KCk7XG4gIH1cblxuICBmb3JtYXREYXRlVGltZVBhcnRzKGR0LCBvcHRzKSB7XG4gICAgcmV0dXJuIHRoaXMuZHRGb3JtYXR0ZXIoZHQsIG9wdHMpLmZvcm1hdFRvUGFydHMoKTtcbiAgfVxuXG4gIGZvcm1hdEludGVydmFsKGludGVydmFsLCBvcHRzKSB7XG4gICAgY29uc3QgZGYgPSB0aGlzLmR0Rm9ybWF0dGVyKGludGVydmFsLnN0YXJ0LCBvcHRzKTtcbiAgICByZXR1cm4gZGYuZHRmLmZvcm1hdFJhbmdlKGludGVydmFsLnN0YXJ0LnRvSlNEYXRlKCksIGludGVydmFsLmVuZC50b0pTRGF0ZSgpKTtcbiAgfVxuXG4gIHJlc29sdmVkT3B0aW9ucyhkdCwgb3B0cykge1xuICAgIHJldHVybiB0aGlzLmR0Rm9ybWF0dGVyKGR0LCBvcHRzKS5yZXNvbHZlZE9wdGlvbnMoKTtcbiAgfVxuXG4gIG51bShuLCBwID0gMCkge1xuICAgIC8vIHdlIGdldCBzb21lIHBlcmYgb3V0IG9mIGRvaW5nIHRoaXMgaGVyZSwgYW5ub3lpbmdseVxuICAgIGlmICh0aGlzLm9wdHMuZm9yY2VTaW1wbGUpIHtcbiAgICAgIHJldHVybiBwYWRTdGFydChuLCBwKTtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRzID0geyAuLi50aGlzLm9wdHMgfTtcblxuICAgIGlmIChwID4gMCkge1xuICAgICAgb3B0cy5wYWRUbyA9IHA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubG9jLm51bWJlckZvcm1hdHRlcihvcHRzKS5mb3JtYXQobik7XG4gIH1cblxuICBmb3JtYXREYXRlVGltZUZyb21TdHJpbmcoZHQsIGZtdCkge1xuICAgIGNvbnN0IGtub3duRW5nbGlzaCA9IHRoaXMubG9jLmxpc3RpbmdNb2RlKCkgPT09IFwiZW5cIixcbiAgICAgIHVzZURhdGVUaW1lRm9ybWF0dGVyID0gdGhpcy5sb2Mub3V0cHV0Q2FsZW5kYXIgJiYgdGhpcy5sb2Mub3V0cHV0Q2FsZW5kYXIgIT09IFwiZ3JlZ29yeVwiLFxuICAgICAgc3RyaW5nID0gKG9wdHMsIGV4dHJhY3QpID0+IHRoaXMubG9jLmV4dHJhY3QoZHQsIG9wdHMsIGV4dHJhY3QpLFxuICAgICAgZm9ybWF0T2Zmc2V0ID0gKG9wdHMpID0+IHtcbiAgICAgICAgaWYgKGR0LmlzT2Zmc2V0Rml4ZWQgJiYgZHQub2Zmc2V0ID09PSAwICYmIG9wdHMuYWxsb3daKSB7XG4gICAgICAgICAgcmV0dXJuIFwiWlwiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGR0LmlzVmFsaWQgPyBkdC56b25lLmZvcm1hdE9mZnNldChkdC50cywgb3B0cy5mb3JtYXQpIDogXCJcIjtcbiAgICAgIH0sXG4gICAgICBtZXJpZGllbSA9ICgpID0+XG4gICAgICAgIGtub3duRW5nbGlzaFxuICAgICAgICAgID8gRW5nbGlzaC5tZXJpZGllbUZvckRhdGVUaW1lKGR0KVxuICAgICAgICAgIDogc3RyaW5nKHsgaG91cjogXCJudW1lcmljXCIsIGhvdXJDeWNsZTogXCJoMTJcIiB9LCBcImRheXBlcmlvZFwiKSxcbiAgICAgIG1vbnRoID0gKGxlbmd0aCwgc3RhbmRhbG9uZSkgPT5cbiAgICAgICAga25vd25FbmdsaXNoXG4gICAgICAgICAgPyBFbmdsaXNoLm1vbnRoRm9yRGF0ZVRpbWUoZHQsIGxlbmd0aClcbiAgICAgICAgICA6IHN0cmluZyhzdGFuZGFsb25lID8geyBtb250aDogbGVuZ3RoIH0gOiB7IG1vbnRoOiBsZW5ndGgsIGRheTogXCJudW1lcmljXCIgfSwgXCJtb250aFwiKSxcbiAgICAgIHdlZWtkYXkgPSAobGVuZ3RoLCBzdGFuZGFsb25lKSA9PlxuICAgICAgICBrbm93bkVuZ2xpc2hcbiAgICAgICAgICA/IEVuZ2xpc2gud2Vla2RheUZvckRhdGVUaW1lKGR0LCBsZW5ndGgpXG4gICAgICAgICAgOiBzdHJpbmcoXG4gICAgICAgICAgICAgIHN0YW5kYWxvbmUgPyB7IHdlZWtkYXk6IGxlbmd0aCB9IDogeyB3ZWVrZGF5OiBsZW5ndGgsIG1vbnRoOiBcImxvbmdcIiwgZGF5OiBcIm51bWVyaWNcIiB9LFxuICAgICAgICAgICAgICBcIndlZWtkYXlcIlxuICAgICAgICAgICAgKSxcbiAgICAgIG1heWJlTWFjcm8gPSAodG9rZW4pID0+IHtcbiAgICAgICAgY29uc3QgZm9ybWF0T3B0cyA9IEZvcm1hdHRlci5tYWNyb1Rva2VuVG9Gb3JtYXRPcHRzKHRva2VuKTtcbiAgICAgICAgaWYgKGZvcm1hdE9wdHMpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXRXaXRoU3lzdGVtRGVmYXVsdChkdCwgZm9ybWF0T3B0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZXJhID0gKGxlbmd0aCkgPT5cbiAgICAgICAga25vd25FbmdsaXNoID8gRW5nbGlzaC5lcmFGb3JEYXRlVGltZShkdCwgbGVuZ3RoKSA6IHN0cmluZyh7IGVyYTogbGVuZ3RoIH0sIFwiZXJhXCIpLFxuICAgICAgdG9rZW5Ub1N0cmluZyA9ICh0b2tlbikgPT4ge1xuICAgICAgICAvLyBXaGVyZSBwb3NzaWJsZTogaHR0cHM6Ly9jbGRyLnVuaWNvZGUub3JnL3RyYW5zbGF0aW9uL2RhdGUtdGltZS9kYXRlLXRpbWUtc3ltYm9sc1xuICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgICAgLy8gbXNcbiAgICAgICAgICBjYXNlIFwiU1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0Lm1pbGxpc2Vjb25kKTtcbiAgICAgICAgICBjYXNlIFwidVwiOlxuICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgICAgICBjYXNlIFwiU1NTXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQubWlsbGlzZWNvbmQsIDMpO1xuICAgICAgICAgIC8vIHNlY29uZHNcbiAgICAgICAgICBjYXNlIFwic1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LnNlY29uZCk7XG4gICAgICAgICAgY2FzZSBcInNzXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQuc2Vjb25kLCAyKTtcbiAgICAgICAgICAvLyBmcmFjdGlvbmFsIHNlY29uZHNcbiAgICAgICAgICBjYXNlIFwidXVcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShNYXRoLmZsb29yKGR0Lm1pbGxpc2Vjb25kIC8gMTApLCAyKTtcbiAgICAgICAgICBjYXNlIFwidXV1XCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oTWF0aC5mbG9vcihkdC5taWxsaXNlY29uZCAvIDEwMCkpO1xuICAgICAgICAgIC8vIG1pbnV0ZXNcbiAgICAgICAgICBjYXNlIFwibVwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0Lm1pbnV0ZSk7XG4gICAgICAgICAgY2FzZSBcIm1tXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQubWludXRlLCAyKTtcbiAgICAgICAgICAvLyBob3Vyc1xuICAgICAgICAgIGNhc2UgXCJoXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQuaG91ciAlIDEyID09PSAwID8gMTIgOiBkdC5ob3VyICUgMTIpO1xuICAgICAgICAgIGNhc2UgXCJoaFwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LmhvdXIgJSAxMiA9PT0gMCA/IDEyIDogZHQuaG91ciAlIDEyLCAyKTtcbiAgICAgICAgICBjYXNlIFwiSFwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LmhvdXIpO1xuICAgICAgICAgIGNhc2UgXCJISFwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LmhvdXIsIDIpO1xuICAgICAgICAgIC8vIG9mZnNldFxuICAgICAgICAgIGNhc2UgXCJaXCI6XG4gICAgICAgICAgICAvLyBsaWtlICs2XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0T2Zmc2V0KHsgZm9ybWF0OiBcIm5hcnJvd1wiLCBhbGxvd1o6IHRoaXMub3B0cy5hbGxvd1ogfSk7XG4gICAgICAgICAgY2FzZSBcIlpaXCI6XG4gICAgICAgICAgICAvLyBsaWtlICswNjowMFxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE9mZnNldCh7IGZvcm1hdDogXCJzaG9ydFwiLCBhbGxvd1o6IHRoaXMub3B0cy5hbGxvd1ogfSk7XG4gICAgICAgICAgY2FzZSBcIlpaWlwiOlxuICAgICAgICAgICAgLy8gbGlrZSArMDYwMFxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE9mZnNldCh7IGZvcm1hdDogXCJ0ZWNoaWVcIiwgYWxsb3daOiB0aGlzLm9wdHMuYWxsb3daIH0pO1xuICAgICAgICAgIGNhc2UgXCJaWlpaXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEVTVFxuICAgICAgICAgICAgcmV0dXJuIGR0LnpvbmUub2Zmc2V0TmFtZShkdC50cywgeyBmb3JtYXQ6IFwic2hvcnRcIiwgbG9jYWxlOiB0aGlzLmxvYy5sb2NhbGUgfSk7XG4gICAgICAgICAgY2FzZSBcIlpaWlpaXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEVhc3Rlcm4gU3RhbmRhcmQgVGltZVxuICAgICAgICAgICAgcmV0dXJuIGR0LnpvbmUub2Zmc2V0TmFtZShkdC50cywgeyBmb3JtYXQ6IFwibG9uZ1wiLCBsb2NhbGU6IHRoaXMubG9jLmxvY2FsZSB9KTtcbiAgICAgICAgICAvLyB6b25lXG4gICAgICAgICAgY2FzZSBcInpcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgQW1lcmljYS9OZXdfWW9ya1xuICAgICAgICAgICAgcmV0dXJuIGR0LnpvbmVOYW1lO1xuICAgICAgICAgIC8vIG1lcmlkaWVtc1xuICAgICAgICAgIGNhc2UgXCJhXCI6XG4gICAgICAgICAgICByZXR1cm4gbWVyaWRpZW0oKTtcbiAgICAgICAgICAvLyBkYXRlc1xuICAgICAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXIgPyBzdHJpbmcoeyBkYXk6IFwibnVtZXJpY1wiIH0sIFwiZGF5XCIpIDogdGhpcy5udW0oZHQuZGF5KTtcbiAgICAgICAgICBjYXNlIFwiZGRcIjpcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlciA/IHN0cmluZyh7IGRheTogXCIyLWRpZ2l0XCIgfSwgXCJkYXlcIikgOiB0aGlzLm51bShkdC5kYXksIDIpO1xuICAgICAgICAgIC8vIHdlZWtkYXlzIC0gc3RhbmRhbG9uZVxuICAgICAgICAgIGNhc2UgXCJjXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDFcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC53ZWVrZGF5KTtcbiAgICAgICAgICBjYXNlIFwiY2NjXCI6XG4gICAgICAgICAgICAvLyBsaWtlICdUdWVzJ1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtkYXkoXCJzaG9ydFwiLCB0cnVlKTtcbiAgICAgICAgICBjYXNlIFwiY2NjY1wiOlxuICAgICAgICAgICAgLy8gbGlrZSAnVHVlc2RheSdcbiAgICAgICAgICAgIHJldHVybiB3ZWVrZGF5KFwibG9uZ1wiLCB0cnVlKTtcbiAgICAgICAgICBjYXNlIFwiY2NjY2NcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgJ1QnXG4gICAgICAgICAgICByZXR1cm4gd2Vla2RheShcIm5hcnJvd1wiLCB0cnVlKTtcbiAgICAgICAgICAvLyB3ZWVrZGF5cyAtIGZvcm1hdFxuICAgICAgICAgIGNhc2UgXCJFXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDFcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC53ZWVrZGF5KTtcbiAgICAgICAgICBjYXNlIFwiRUVFXCI6XG4gICAgICAgICAgICAvLyBsaWtlICdUdWVzJ1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtkYXkoXCJzaG9ydFwiLCBmYWxzZSk7XG4gICAgICAgICAgY2FzZSBcIkVFRUVcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgJ1R1ZXNkYXknXG4gICAgICAgICAgICByZXR1cm4gd2Vla2RheShcImxvbmdcIiwgZmFsc2UpO1xuICAgICAgICAgIGNhc2UgXCJFRUVFRVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAnVCdcbiAgICAgICAgICAgIHJldHVybiB3ZWVrZGF5KFwibmFycm93XCIsIGZhbHNlKTtcbiAgICAgICAgICAvLyBtb250aHMgLSBzdGFuZGFsb25lXG4gICAgICAgICAgY2FzZSBcIkxcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMVxuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyXG4gICAgICAgICAgICAgID8gc3RyaW5nKHsgbW9udGg6IFwibnVtZXJpY1wiLCBkYXk6IFwibnVtZXJpY1wiIH0sIFwibW9udGhcIilcbiAgICAgICAgICAgICAgOiB0aGlzLm51bShkdC5tb250aCk7XG4gICAgICAgICAgY2FzZSBcIkxMXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDAxLCBkb2Vzbid0IHNlZW0gdG8gd29ya1xuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyXG4gICAgICAgICAgICAgID8gc3RyaW5nKHsgbW9udGg6IFwiMi1kaWdpdFwiLCBkYXk6IFwibnVtZXJpY1wiIH0sIFwibW9udGhcIilcbiAgICAgICAgICAgICAgOiB0aGlzLm51bShkdC5tb250aCwgMik7XG4gICAgICAgICAgY2FzZSBcIkxMTFwiOlxuICAgICAgICAgICAgLy8gbGlrZSBKYW5cbiAgICAgICAgICAgIHJldHVybiBtb250aChcInNob3J0XCIsIHRydWUpO1xuICAgICAgICAgIGNhc2UgXCJMTExMXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEphbnVhcnlcbiAgICAgICAgICAgIHJldHVybiBtb250aChcImxvbmdcIiwgdHJ1ZSk7XG4gICAgICAgICAgY2FzZSBcIkxMTExMXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEpcbiAgICAgICAgICAgIHJldHVybiBtb250aChcIm5hcnJvd1wiLCB0cnVlKTtcbiAgICAgICAgICAvLyBtb250aHMgLSBmb3JtYXRcbiAgICAgICAgICBjYXNlIFwiTVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAxXG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXJcbiAgICAgICAgICAgICAgPyBzdHJpbmcoeyBtb250aDogXCJudW1lcmljXCIgfSwgXCJtb250aFwiKVxuICAgICAgICAgICAgICA6IHRoaXMubnVtKGR0Lm1vbnRoKTtcbiAgICAgICAgICBjYXNlIFwiTU1cIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMDFcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlclxuICAgICAgICAgICAgICA/IHN0cmluZyh7IG1vbnRoOiBcIjItZGlnaXRcIiB9LCBcIm1vbnRoXCIpXG4gICAgICAgICAgICAgIDogdGhpcy5udW0oZHQubW9udGgsIDIpO1xuICAgICAgICAgIGNhc2UgXCJNTU1cIjpcbiAgICAgICAgICAgIC8vIGxpa2UgSmFuXG4gICAgICAgICAgICByZXR1cm4gbW9udGgoXCJzaG9ydFwiLCBmYWxzZSk7XG4gICAgICAgICAgY2FzZSBcIk1NTU1cIjpcbiAgICAgICAgICAgIC8vIGxpa2UgSmFudWFyeVxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoKFwibG9uZ1wiLCBmYWxzZSk7XG4gICAgICAgICAgY2FzZSBcIk1NTU1NXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEpcbiAgICAgICAgICAgIHJldHVybiBtb250aChcIm5hcnJvd1wiLCBmYWxzZSk7XG4gICAgICAgICAgLy8geWVhcnNcbiAgICAgICAgICBjYXNlIFwieVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAyMDE0XG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXIgPyBzdHJpbmcoeyB5ZWFyOiBcIm51bWVyaWNcIiB9LCBcInllYXJcIikgOiB0aGlzLm51bShkdC55ZWFyKTtcbiAgICAgICAgICBjYXNlIFwieXlcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMTRcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlclxuICAgICAgICAgICAgICA/IHN0cmluZyh7IHllYXI6IFwiMi1kaWdpdFwiIH0sIFwieWVhclwiKVxuICAgICAgICAgICAgICA6IHRoaXMubnVtKGR0LnllYXIudG9TdHJpbmcoKS5zbGljZSgtMiksIDIpO1xuICAgICAgICAgIGNhc2UgXCJ5eXl5XCI6XG4gICAgICAgICAgICAvLyBsaWtlIDAwMTJcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlclxuICAgICAgICAgICAgICA/IHN0cmluZyh7IHllYXI6IFwibnVtZXJpY1wiIH0sIFwieWVhclwiKVxuICAgICAgICAgICAgICA6IHRoaXMubnVtKGR0LnllYXIsIDQpO1xuICAgICAgICAgIGNhc2UgXCJ5eXl5eXlcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMDAwMDEyXG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXJcbiAgICAgICAgICAgICAgPyBzdHJpbmcoeyB5ZWFyOiBcIm51bWVyaWNcIiB9LCBcInllYXJcIilcbiAgICAgICAgICAgICAgOiB0aGlzLm51bShkdC55ZWFyLCA2KTtcbiAgICAgICAgICAvLyBlcmFzXG4gICAgICAgICAgY2FzZSBcIkdcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgQURcbiAgICAgICAgICAgIHJldHVybiBlcmEoXCJzaG9ydFwiKTtcbiAgICAgICAgICBjYXNlIFwiR0dcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgQW5ubyBEb21pbmlcbiAgICAgICAgICAgIHJldHVybiBlcmEoXCJsb25nXCIpO1xuICAgICAgICAgIGNhc2UgXCJHR0dHR1wiOlxuICAgICAgICAgICAgcmV0dXJuIGVyYShcIm5hcnJvd1wiKTtcbiAgICAgICAgICBjYXNlIFwia2tcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC53ZWVrWWVhci50b1N0cmluZygpLnNsaWNlKC0yKSwgMik7XG4gICAgICAgICAgY2FzZSBcImtra2tcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC53ZWVrWWVhciwgNCk7XG4gICAgICAgICAgY2FzZSBcIldcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC53ZWVrTnVtYmVyKTtcbiAgICAgICAgICBjYXNlIFwiV1dcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC53ZWVrTnVtYmVyLCAyKTtcbiAgICAgICAgICBjYXNlIFwib1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0Lm9yZGluYWwpO1xuICAgICAgICAgIGNhc2UgXCJvb29cIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5vcmRpbmFsLCAzKTtcbiAgICAgICAgICBjYXNlIFwicVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAxXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQucXVhcnRlcik7XG4gICAgICAgICAgY2FzZSBcInFxXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDAxXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQucXVhcnRlciwgMik7XG4gICAgICAgICAgY2FzZSBcIlhcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShNYXRoLmZsb29yKGR0LnRzIC8gMTAwMCkpO1xuICAgICAgICAgIGNhc2UgXCJ4XCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQudHMpO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbWF5YmVNYWNybyh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICByZXR1cm4gc3RyaW5naWZ5VG9rZW5zKEZvcm1hdHRlci5wYXJzZUZvcm1hdChmbXQpLCB0b2tlblRvU3RyaW5nKTtcbiAgfVxuXG4gIGZvcm1hdER1cmF0aW9uRnJvbVN0cmluZyhkdXIsIGZtdCkge1xuICAgIGNvbnN0IHRva2VuVG9GaWVsZCA9ICh0b2tlbikgPT4ge1xuICAgICAgICBzd2l0Y2ggKHRva2VuWzBdKSB7XG4gICAgICAgICAgY2FzZSBcIlNcIjpcbiAgICAgICAgICAgIHJldHVybiBcIm1pbGxpc2Vjb25kXCI7XG4gICAgICAgICAgY2FzZSBcInNcIjpcbiAgICAgICAgICAgIHJldHVybiBcInNlY29uZFwiO1xuICAgICAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJtaW51dGVcIjtcbiAgICAgICAgICBjYXNlIFwiaFwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiaG91clwiO1xuICAgICAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJkYXlcIjtcbiAgICAgICAgICBjYXNlIFwid1wiOlxuICAgICAgICAgICAgcmV0dXJuIFwid2Vla1wiO1xuICAgICAgICAgIGNhc2UgXCJNXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJtb250aFwiO1xuICAgICAgICAgIGNhc2UgXCJ5XCI6XG4gICAgICAgICAgICByZXR1cm4gXCJ5ZWFyXCI7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdG9rZW5Ub1N0cmluZyA9IChsaWxkdXIpID0+ICh0b2tlbikgPT4ge1xuICAgICAgICBjb25zdCBtYXBwZWQgPSB0b2tlblRvRmllbGQodG9rZW4pO1xuICAgICAgICBpZiAobWFwcGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGxpbGR1ci5nZXQobWFwcGVkKSwgdG9rZW4ubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0b2tlbnMgPSBGb3JtYXR0ZXIucGFyc2VGb3JtYXQoZm10KSxcbiAgICAgIHJlYWxUb2tlbnMgPSB0b2tlbnMucmVkdWNlKFxuICAgICAgICAoZm91bmQsIHsgbGl0ZXJhbCwgdmFsIH0pID0+IChsaXRlcmFsID8gZm91bmQgOiBmb3VuZC5jb25jYXQodmFsKSksXG4gICAgICAgIFtdXG4gICAgICApLFxuICAgICAgY29sbGFwc2VkID0gZHVyLnNoaWZ0VG8oLi4ucmVhbFRva2Vucy5tYXAodG9rZW5Ub0ZpZWxkKS5maWx0ZXIoKHQpID0+IHQpKTtcbiAgICByZXR1cm4gc3RyaW5naWZ5VG9rZW5zKHRva2VucywgdG9rZW5Ub1N0cmluZyhjb2xsYXBzZWQpKTtcbiAgfVxufVxuIiwgImV4cG9ydCBkZWZhdWx0IGNsYXNzIEludmFsaWQge1xuICBjb25zdHJ1Y3RvcihyZWFzb24sIGV4cGxhbmF0aW9uKSB7XG4gICAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gICAgdGhpcy5leHBsYW5hdGlvbiA9IGV4cGxhbmF0aW9uO1xuICB9XG5cbiAgdG9NZXNzYWdlKCkge1xuICAgIGlmICh0aGlzLmV4cGxhbmF0aW9uKSB7XG4gICAgICByZXR1cm4gYCR7dGhpcy5yZWFzb259OiAke3RoaXMuZXhwbGFuYXRpb259YDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucmVhc29uO1xuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIHVudHJ1bmNhdGVZZWFyLFxuICBzaWduZWRPZmZzZXQsXG4gIHBhcnNlSW50ZWdlcixcbiAgcGFyc2VNaWxsaXMsXG4gIGlzVW5kZWZpbmVkLFxuICBwYXJzZUZsb2F0aW5nLFxufSBmcm9tIFwiLi91dGlsLmpzXCI7XG5pbXBvcnQgKiBhcyBFbmdsaXNoIGZyb20gXCIuL2VuZ2xpc2guanNcIjtcbmltcG9ydCBGaXhlZE9mZnNldFpvbmUgZnJvbSBcIi4uL3pvbmVzL2ZpeGVkT2Zmc2V0Wm9uZS5qc1wiO1xuaW1wb3J0IElBTkFab25lIGZyb20gXCIuLi96b25lcy9JQU5BWm9uZS5qc1wiO1xuXG4vKlxuICogVGhpcyBmaWxlIGhhbmRsZXMgcGFyc2luZyBmb3Igd2VsbC1zcGVjaWZpZWQgZm9ybWF0cy4gSGVyZSdzIGhvdyBpdCB3b3JrczpcbiAqIFR3byB0aGluZ3MgZ28gaW50byBwYXJzaW5nOiBhIHJlZ2V4IHRvIG1hdGNoIHdpdGggYW5kIGFuIGV4dHJhY3RvciB0byB0YWtlIGFwYXJ0IHRoZSBncm91cHMgaW4gdGhlIG1hdGNoLlxuICogQW4gZXh0cmFjdG9yIGlzIGp1c3QgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgcmVnZXggbWF0Y2ggYXJyYXkgYW5kIHJldHVybnMgYSB7IHllYXI6IC4uLiwgbW9udGg6IC4uLiB9IG9iamVjdFxuICogcGFyc2UoKSBkb2VzIHRoZSB3b3JrIG9mIGV4ZWN1dGluZyB0aGUgcmVnZXggYW5kIGFwcGx5aW5nIHRoZSBleHRyYWN0b3IuIEl0IHRha2VzIG11bHRpcGxlIHJlZ2V4L2V4dHJhY3RvciBwYWlycyB0byB0cnkgaW4gc2VxdWVuY2UuXG4gKiBFeHRyYWN0b3JzIGNhbiB0YWtlIGEgXCJjdXJzb3JcIiByZXByZXNlbnRpbmcgdGhlIG9mZnNldCBpbiB0aGUgbWF0Y2ggdG8gbG9vayBhdC4gVGhpcyBtYWtlcyBpdCBlYXN5IHRvIGNvbWJpbmUgZXh0cmFjdG9ycy5cbiAqIGNvbWJpbmVFeHRyYWN0b3JzKCkgZG9lcyB0aGUgd29yayBvZiBjb21iaW5pbmcgdGhlbSwga2VlcGluZyB0cmFjayBvZiB0aGUgY3Vyc29yIHRocm91Z2ggbXVsdGlwbGUgZXh0cmFjdGlvbnMuXG4gKiBTb21lIGV4dHJhY3Rpb25zIGFyZSBzdXBlciBkdW1iIGFuZCBzaW1wbGVQYXJzZSBhbmQgZnJvbVN0cmluZ3MgaGVscCBEUlkgdGhlbS5cbiAqL1xuXG5jb25zdCBpYW5hUmVnZXggPSAvW0EtWmEtel8rLV17MSwyNTZ9KD86Oj9cXC9bQS1aYS16MC05XystXXsxLDI1Nn0oPzpcXC9bQS1aYS16MC05XystXXsxLDI1Nn0pPyk/LztcblxuZnVuY3Rpb24gY29tYmluZVJlZ2V4ZXMoLi4ucmVnZXhlcykge1xuICBjb25zdCBmdWxsID0gcmVnZXhlcy5yZWR1Y2UoKGYsIHIpID0+IGYgKyByLnNvdXJjZSwgXCJcIik7XG4gIHJldHVybiBSZWdFeHAoYF4ke2Z1bGx9JGApO1xufVxuXG5mdW5jdGlvbiBjb21iaW5lRXh0cmFjdG9ycyguLi5leHRyYWN0b3JzKSB7XG4gIHJldHVybiAobSkgPT5cbiAgICBleHRyYWN0b3JzXG4gICAgICAucmVkdWNlKFxuICAgICAgICAoW21lcmdlZFZhbHMsIG1lcmdlZFpvbmUsIGN1cnNvcl0sIGV4KSA9PiB7XG4gICAgICAgICAgY29uc3QgW3ZhbCwgem9uZSwgbmV4dF0gPSBleChtLCBjdXJzb3IpO1xuICAgICAgICAgIHJldHVybiBbeyAuLi5tZXJnZWRWYWxzLCAuLi52YWwgfSwgem9uZSB8fCBtZXJnZWRab25lLCBuZXh0XTtcbiAgICAgICAgfSxcbiAgICAgICAgW3t9LCBudWxsLCAxXVxuICAgICAgKVxuICAgICAgLnNsaWNlKDAsIDIpO1xufVxuXG5mdW5jdGlvbiBwYXJzZShzLCAuLi5wYXR0ZXJucykge1xuICBpZiAocyA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtudWxsLCBudWxsXTtcbiAgfVxuXG4gIGZvciAoY29uc3QgW3JlZ2V4LCBleHRyYWN0b3JdIG9mIHBhdHRlcm5zKSB7XG4gICAgY29uc3QgbSA9IHJlZ2V4LmV4ZWMocyk7XG4gICAgaWYgKG0pIHtcbiAgICAgIHJldHVybiBleHRyYWN0b3IobSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBbbnVsbCwgbnVsbF07XG59XG5cbmZ1bmN0aW9uIHNpbXBsZVBhcnNlKC4uLmtleXMpIHtcbiAgcmV0dXJuIChtYXRjaCwgY3Vyc29yKSA9PiB7XG4gICAgY29uc3QgcmV0ID0ge307XG4gICAgbGV0IGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgcmV0W2tleXNbaV1dID0gcGFyc2VJbnRlZ2VyKG1hdGNoW2N1cnNvciArIGldKTtcbiAgICB9XG4gICAgcmV0dXJuIFtyZXQsIG51bGwsIGN1cnNvciArIGldO1xuICB9O1xufVxuXG4vLyBJU08gYW5kIFNRTCBwYXJzaW5nXG5jb25zdCBvZmZzZXRSZWdleCA9IC8oPzooWil8KFsrLV1cXGRcXGQpKD86Oj8oXFxkXFxkKSk/KS87XG5jb25zdCBpc29FeHRlbmRlZFpvbmUgPSBgKD86JHtvZmZzZXRSZWdleC5zb3VyY2V9Pyg/OlxcXFxbKCR7aWFuYVJlZ2V4LnNvdXJjZX0pXFxcXF0pPyk/YDtcbmNvbnN0IGlzb1RpbWVCYXNlUmVnZXggPSAvKFxcZFxcZCkoPzo6PyhcXGRcXGQpKD86Oj8oXFxkXFxkKSg/OlsuLF0oXFxkezEsMzB9KSk/KT8pPy87XG5jb25zdCBpc29UaW1lUmVnZXggPSBSZWdFeHAoYCR7aXNvVGltZUJhc2VSZWdleC5zb3VyY2V9JHtpc29FeHRlbmRlZFpvbmV9YCk7XG5jb25zdCBpc29UaW1lRXh0ZW5zaW9uUmVnZXggPSBSZWdFeHAoYCg/OlQke2lzb1RpbWVSZWdleC5zb3VyY2V9KT9gKTtcbmNvbnN0IGlzb1ltZFJlZ2V4ID0gLyhbKy1dXFxkezZ9fFxcZHs0fSkoPzotPyhcXGRcXGQpKD86LT8oXFxkXFxkKSk/KT8vO1xuY29uc3QgaXNvV2Vla1JlZ2V4ID0gLyhcXGR7NH0pLT9XKFxcZFxcZCkoPzotPyhcXGQpKT8vO1xuY29uc3QgaXNvT3JkaW5hbFJlZ2V4ID0gLyhcXGR7NH0pLT8oXFxkezN9KS87XG5jb25zdCBleHRyYWN0SVNPV2Vla0RhdGEgPSBzaW1wbGVQYXJzZShcIndlZWtZZWFyXCIsIFwid2Vla051bWJlclwiLCBcIndlZWtEYXlcIik7XG5jb25zdCBleHRyYWN0SVNPT3JkaW5hbERhdGEgPSBzaW1wbGVQYXJzZShcInllYXJcIiwgXCJvcmRpbmFsXCIpO1xuY29uc3Qgc3FsWW1kUmVnZXggPSAvKFxcZHs0fSktKFxcZFxcZCktKFxcZFxcZCkvOyAvLyBkdW1iZWQtZG93biB2ZXJzaW9uIG9mIHRoZSBJU08gb25lXG5jb25zdCBzcWxUaW1lUmVnZXggPSBSZWdFeHAoXG4gIGAke2lzb1RpbWVCYXNlUmVnZXguc291cmNlfSA/KD86JHtvZmZzZXRSZWdleC5zb3VyY2V9fCgke2lhbmFSZWdleC5zb3VyY2V9KSk/YFxuKTtcbmNvbnN0IHNxbFRpbWVFeHRlbnNpb25SZWdleCA9IFJlZ0V4cChgKD86ICR7c3FsVGltZVJlZ2V4LnNvdXJjZX0pP2ApO1xuXG5mdW5jdGlvbiBpbnQobWF0Y2gsIHBvcywgZmFsbGJhY2spIHtcbiAgY29uc3QgbSA9IG1hdGNoW3Bvc107XG4gIHJldHVybiBpc1VuZGVmaW5lZChtKSA/IGZhbGxiYWNrIDogcGFyc2VJbnRlZ2VyKG0pO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0SVNPWW1kKG1hdGNoLCBjdXJzb3IpIHtcbiAgY29uc3QgaXRlbSA9IHtcbiAgICB5ZWFyOiBpbnQobWF0Y2gsIGN1cnNvciksXG4gICAgbW9udGg6IGludChtYXRjaCwgY3Vyc29yICsgMSwgMSksXG4gICAgZGF5OiBpbnQobWF0Y2gsIGN1cnNvciArIDIsIDEpLFxuICB9O1xuXG4gIHJldHVybiBbaXRlbSwgbnVsbCwgY3Vyc29yICsgM107XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RJU09UaW1lKG1hdGNoLCBjdXJzb3IpIHtcbiAgY29uc3QgaXRlbSA9IHtcbiAgICBob3VyczogaW50KG1hdGNoLCBjdXJzb3IsIDApLFxuICAgIG1pbnV0ZXM6IGludChtYXRjaCwgY3Vyc29yICsgMSwgMCksXG4gICAgc2Vjb25kczogaW50KG1hdGNoLCBjdXJzb3IgKyAyLCAwKSxcbiAgICBtaWxsaXNlY29uZHM6IHBhcnNlTWlsbGlzKG1hdGNoW2N1cnNvciArIDNdKSxcbiAgfTtcblxuICByZXR1cm4gW2l0ZW0sIG51bGwsIGN1cnNvciArIDRdO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0SVNPT2Zmc2V0KG1hdGNoLCBjdXJzb3IpIHtcbiAgY29uc3QgbG9jYWwgPSAhbWF0Y2hbY3Vyc29yXSAmJiAhbWF0Y2hbY3Vyc29yICsgMV0sXG4gICAgZnVsbE9mZnNldCA9IHNpZ25lZE9mZnNldChtYXRjaFtjdXJzb3IgKyAxXSwgbWF0Y2hbY3Vyc29yICsgMl0pLFxuICAgIHpvbmUgPSBsb2NhbCA/IG51bGwgOiBGaXhlZE9mZnNldFpvbmUuaW5zdGFuY2UoZnVsbE9mZnNldCk7XG4gIHJldHVybiBbe30sIHpvbmUsIGN1cnNvciArIDNdO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0SUFOQVpvbmUobWF0Y2gsIGN1cnNvcikge1xuICBjb25zdCB6b25lID0gbWF0Y2hbY3Vyc29yXSA/IElBTkFab25lLmNyZWF0ZShtYXRjaFtjdXJzb3JdKSA6IG51bGw7XG4gIHJldHVybiBbe30sIHpvbmUsIGN1cnNvciArIDFdO1xufVxuXG4vLyBJU08gdGltZSBwYXJzaW5nXG5cbmNvbnN0IGlzb1RpbWVPbmx5ID0gUmVnRXhwKGBeVD8ke2lzb1RpbWVCYXNlUmVnZXguc291cmNlfSRgKTtcblxuLy8gSVNPIGR1cmF0aW9uIHBhcnNpbmdcblxuY29uc3QgaXNvRHVyYXRpb24gPVxuICAvXi0/UCg/Oig/OigtP1xcZHsxLDIwfSg/OlxcLlxcZHsxLDIwfSk/KVkpPyg/OigtP1xcZHsxLDIwfSg/OlxcLlxcZHsxLDIwfSk/KU0pPyg/OigtP1xcZHsxLDIwfSg/OlxcLlxcZHsxLDIwfSk/KVcpPyg/OigtP1xcZHsxLDIwfSg/OlxcLlxcZHsxLDIwfSk/KUQpPyg/OlQoPzooLT9cXGR7MSwyMH0oPzpcXC5cXGR7MSwyMH0pPylIKT8oPzooLT9cXGR7MSwyMH0oPzpcXC5cXGR7MSwyMH0pPylNKT8oPzooLT9cXGR7MSwyMH0pKD86Wy4sXSgtP1xcZHsxLDIwfSkpP1MpPyk/KSQvO1xuXG5mdW5jdGlvbiBleHRyYWN0SVNPRHVyYXRpb24obWF0Y2gpIHtcbiAgY29uc3QgW3MsIHllYXJTdHIsIG1vbnRoU3RyLCB3ZWVrU3RyLCBkYXlTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyLCBtaWxsaXNlY29uZHNTdHJdID1cbiAgICBtYXRjaDtcblxuICBjb25zdCBoYXNOZWdhdGl2ZVByZWZpeCA9IHNbMF0gPT09IFwiLVwiO1xuICBjb25zdCBuZWdhdGl2ZVNlY29uZHMgPSBzZWNvbmRTdHIgJiYgc2Vjb25kU3RyWzBdID09PSBcIi1cIjtcblxuICBjb25zdCBtYXliZU5lZ2F0ZSA9IChudW0sIGZvcmNlID0gZmFsc2UpID0+XG4gICAgbnVtICE9PSB1bmRlZmluZWQgJiYgKGZvcmNlIHx8IChudW0gJiYgaGFzTmVnYXRpdmVQcmVmaXgpKSA/IC1udW0gOiBudW07XG5cbiAgcmV0dXJuIFtcbiAgICB7XG4gICAgICB5ZWFyczogbWF5YmVOZWdhdGUocGFyc2VGbG9hdGluZyh5ZWFyU3RyKSksXG4gICAgICBtb250aHM6IG1heWJlTmVnYXRlKHBhcnNlRmxvYXRpbmcobW9udGhTdHIpKSxcbiAgICAgIHdlZWtzOiBtYXliZU5lZ2F0ZShwYXJzZUZsb2F0aW5nKHdlZWtTdHIpKSxcbiAgICAgIGRheXM6IG1heWJlTmVnYXRlKHBhcnNlRmxvYXRpbmcoZGF5U3RyKSksXG4gICAgICBob3VyczogbWF5YmVOZWdhdGUocGFyc2VGbG9hdGluZyhob3VyU3RyKSksXG4gICAgICBtaW51dGVzOiBtYXliZU5lZ2F0ZShwYXJzZUZsb2F0aW5nKG1pbnV0ZVN0cikpLFxuICAgICAgc2Vjb25kczogbWF5YmVOZWdhdGUocGFyc2VGbG9hdGluZyhzZWNvbmRTdHIpLCBzZWNvbmRTdHIgPT09IFwiLTBcIiksXG4gICAgICBtaWxsaXNlY29uZHM6IG1heWJlTmVnYXRlKHBhcnNlTWlsbGlzKG1pbGxpc2Vjb25kc1N0ciksIG5lZ2F0aXZlU2Vjb25kcyksXG4gICAgfSxcbiAgXTtcbn1cblxuLy8gVGhlc2UgYXJlIGEgbGl0dGxlIGJyYWluZGVhZC4gRURUICpzaG91bGQqIHRlbGwgdXMgdGhhdCB3ZSdyZSBpbiwgc2F5LCBBbWVyaWNhL05ld19Zb3JrXG4vLyBhbmQgbm90IGp1c3QgdGhhdCB3ZSdyZSBpbiAtMjQwICpyaWdodCBub3cqLiBCdXQgc2luY2UgSSBkb24ndCB0aGluayB0aGVzZSBhcmUgdXNlZCB0aGF0IG9mdGVuXG4vLyBJJ20ganVzdCBnb2luZyB0byBpZ25vcmUgdGhhdFxuY29uc3Qgb2JzT2Zmc2V0cyA9IHtcbiAgR01UOiAwLFxuICBFRFQ6IC00ICogNjAsXG4gIEVTVDogLTUgKiA2MCxcbiAgQ0RUOiAtNSAqIDYwLFxuICBDU1Q6IC02ICogNjAsXG4gIE1EVDogLTYgKiA2MCxcbiAgTVNUOiAtNyAqIDYwLFxuICBQRFQ6IC03ICogNjAsXG4gIFBTVDogLTggKiA2MCxcbn07XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmdzKHdlZWtkYXlTdHIsIHllYXJTdHIsIG1vbnRoU3RyLCBkYXlTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICB5ZWFyOiB5ZWFyU3RyLmxlbmd0aCA9PT0gMiA/IHVudHJ1bmNhdGVZZWFyKHBhcnNlSW50ZWdlcih5ZWFyU3RyKSkgOiBwYXJzZUludGVnZXIoeWVhclN0ciksXG4gICAgbW9udGg6IEVuZ2xpc2gubW9udGhzU2hvcnQuaW5kZXhPZihtb250aFN0cikgKyAxLFxuICAgIGRheTogcGFyc2VJbnRlZ2VyKGRheVN0ciksXG4gICAgaG91cjogcGFyc2VJbnRlZ2VyKGhvdXJTdHIpLFxuICAgIG1pbnV0ZTogcGFyc2VJbnRlZ2VyKG1pbnV0ZVN0ciksXG4gIH07XG5cbiAgaWYgKHNlY29uZFN0cikgcmVzdWx0LnNlY29uZCA9IHBhcnNlSW50ZWdlcihzZWNvbmRTdHIpO1xuICBpZiAod2Vla2RheVN0cikge1xuICAgIHJlc3VsdC53ZWVrZGF5ID1cbiAgICAgIHdlZWtkYXlTdHIubGVuZ3RoID4gM1xuICAgICAgICA/IEVuZ2xpc2gud2Vla2RheXNMb25nLmluZGV4T2Yod2Vla2RheVN0cikgKyAxXG4gICAgICAgIDogRW5nbGlzaC53ZWVrZGF5c1Nob3J0LmluZGV4T2Yod2Vla2RheVN0cikgKyAxO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gUkZDIDI4MjIvNTMyMlxuY29uc3QgcmZjMjgyMiA9XG4gIC9eKD86KE1vbnxUdWV8V2VkfFRodXxGcml8U2F0fFN1biksXFxzKT8oXFxkezEsMn0pXFxzKEphbnxGZWJ8TWFyfEFwcnxNYXl8SnVufEp1bHxBdWd8U2VwfE9jdHxOb3Z8RGVjKVxccyhcXGR7Miw0fSlcXHMoXFxkXFxkKTooXFxkXFxkKSg/OjooXFxkXFxkKSk/XFxzKD86KFVUfEdNVHxbRUNNUF1bU0RdVCl8KFtael0pfCg/OihbKy1dXFxkXFxkKShcXGRcXGQpKSkkLztcblxuZnVuY3Rpb24gZXh0cmFjdFJGQzI4MjIobWF0Y2gpIHtcbiAgY29uc3QgW1xuICAgICAgLFxuICAgICAgd2Vla2RheVN0cixcbiAgICAgIGRheVN0cixcbiAgICAgIG1vbnRoU3RyLFxuICAgICAgeWVhclN0cixcbiAgICAgIGhvdXJTdHIsXG4gICAgICBtaW51dGVTdHIsXG4gICAgICBzZWNvbmRTdHIsXG4gICAgICBvYnNPZmZzZXQsXG4gICAgICBtaWxPZmZzZXQsXG4gICAgICBvZmZIb3VyU3RyLFxuICAgICAgb2ZmTWludXRlU3RyLFxuICAgIF0gPSBtYXRjaCxcbiAgICByZXN1bHQgPSBmcm9tU3RyaW5ncyh3ZWVrZGF5U3RyLCB5ZWFyU3RyLCBtb250aFN0ciwgZGF5U3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0cik7XG5cbiAgbGV0IG9mZnNldDtcbiAgaWYgKG9ic09mZnNldCkge1xuICAgIG9mZnNldCA9IG9ic09mZnNldHNbb2JzT2Zmc2V0XTtcbiAgfSBlbHNlIGlmIChtaWxPZmZzZXQpIHtcbiAgICBvZmZzZXQgPSAwO1xuICB9IGVsc2Uge1xuICAgIG9mZnNldCA9IHNpZ25lZE9mZnNldChvZmZIb3VyU3RyLCBvZmZNaW51dGVTdHIpO1xuICB9XG5cbiAgcmV0dXJuIFtyZXN1bHQsIG5ldyBGaXhlZE9mZnNldFpvbmUob2Zmc2V0KV07XG59XG5cbmZ1bmN0aW9uIHByZXByb2Nlc3NSRkMyODIyKHMpIHtcbiAgLy8gUmVtb3ZlIGNvbW1lbnRzIGFuZCBmb2xkaW5nIHdoaXRlc3BhY2UgYW5kIHJlcGxhY2UgbXVsdGlwbGUtc3BhY2VzIHdpdGggYSBzaW5nbGUgc3BhY2VcbiAgcmV0dXJuIHNcbiAgICAucmVwbGFjZSgvXFwoW14oKV0qXFwpfFtcXG5cXHRdL2csIFwiIFwiKVxuICAgIC5yZXBsYWNlKC8oXFxzXFxzKykvZywgXCIgXCIpXG4gICAgLnRyaW0oKTtcbn1cblxuLy8gaHR0cCBkYXRlXG5cbmNvbnN0IHJmYzExMjMgPVxuICAgIC9eKE1vbnxUdWV8V2VkfFRodXxGcml8U2F0fFN1biksIChcXGRcXGQpIChKYW58RmVifE1hcnxBcHJ8TWF5fEp1bnxKdWx8QXVnfFNlcHxPY3R8Tm92fERlYykgKFxcZHs0fSkgKFxcZFxcZCk6KFxcZFxcZCk6KFxcZFxcZCkgR01UJC8sXG4gIHJmYzg1MCA9XG4gICAgL14oTW9uZGF5fFR1ZXNkYXl8V2VkbmVzZGF5fFRodXJzZGF5fEZyaWRheXxTYXR1cmRheXxTdW5kYXkpLCAoXFxkXFxkKS0oSmFufEZlYnxNYXJ8QXByfE1heXxKdW58SnVsfEF1Z3xTZXB8T2N0fE5vdnxEZWMpLShcXGRcXGQpIChcXGRcXGQpOihcXGRcXGQpOihcXGRcXGQpIEdNVCQvLFxuICBhc2NpaSA9XG4gICAgL14oTW9ufFR1ZXxXZWR8VGh1fEZyaXxTYXR8U3VuKSAoSmFufEZlYnxNYXJ8QXByfE1heXxKdW58SnVsfEF1Z3xTZXB8T2N0fE5vdnxEZWMpICggXFxkfFxcZFxcZCkgKFxcZFxcZCk6KFxcZFxcZCk6KFxcZFxcZCkgKFxcZHs0fSkkLztcblxuZnVuY3Rpb24gZXh0cmFjdFJGQzExMjNPcjg1MChtYXRjaCkge1xuICBjb25zdCBbLCB3ZWVrZGF5U3RyLCBkYXlTdHIsIG1vbnRoU3RyLCB5ZWFyU3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0cl0gPSBtYXRjaCxcbiAgICByZXN1bHQgPSBmcm9tU3RyaW5ncyh3ZWVrZGF5U3RyLCB5ZWFyU3RyLCBtb250aFN0ciwgZGF5U3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0cik7XG4gIHJldHVybiBbcmVzdWx0LCBGaXhlZE9mZnNldFpvbmUudXRjSW5zdGFuY2VdO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0QVNDSUkobWF0Y2gpIHtcbiAgY29uc3QgWywgd2Vla2RheVN0ciwgbW9udGhTdHIsIGRheVN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHIsIHllYXJTdHJdID0gbWF0Y2gsXG4gICAgcmVzdWx0ID0gZnJvbVN0cmluZ3Mod2Vla2RheVN0ciwgeWVhclN0ciwgbW9udGhTdHIsIGRheVN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHIpO1xuICByZXR1cm4gW3Jlc3VsdCwgRml4ZWRPZmZzZXRab25lLnV0Y0luc3RhbmNlXTtcbn1cblxuY29uc3QgaXNvWW1kV2l0aFRpbWVFeHRlbnNpb25SZWdleCA9IGNvbWJpbmVSZWdleGVzKGlzb1ltZFJlZ2V4LCBpc29UaW1lRXh0ZW5zaW9uUmVnZXgpO1xuY29uc3QgaXNvV2Vla1dpdGhUaW1lRXh0ZW5zaW9uUmVnZXggPSBjb21iaW5lUmVnZXhlcyhpc29XZWVrUmVnZXgsIGlzb1RpbWVFeHRlbnNpb25SZWdleCk7XG5jb25zdCBpc29PcmRpbmFsV2l0aFRpbWVFeHRlbnNpb25SZWdleCA9IGNvbWJpbmVSZWdleGVzKGlzb09yZGluYWxSZWdleCwgaXNvVGltZUV4dGVuc2lvblJlZ2V4KTtcbmNvbnN0IGlzb1RpbWVDb21iaW5lZFJlZ2V4ID0gY29tYmluZVJlZ2V4ZXMoaXNvVGltZVJlZ2V4KTtcblxuY29uc3QgZXh0cmFjdElTT1ltZFRpbWVBbmRPZmZzZXQgPSBjb21iaW5lRXh0cmFjdG9ycyhcbiAgZXh0cmFjdElTT1ltZCxcbiAgZXh0cmFjdElTT1RpbWUsXG4gIGV4dHJhY3RJU09PZmZzZXQsXG4gIGV4dHJhY3RJQU5BWm9uZVxuKTtcbmNvbnN0IGV4dHJhY3RJU09XZWVrVGltZUFuZE9mZnNldCA9IGNvbWJpbmVFeHRyYWN0b3JzKFxuICBleHRyYWN0SVNPV2Vla0RhdGEsXG4gIGV4dHJhY3RJU09UaW1lLFxuICBleHRyYWN0SVNPT2Zmc2V0LFxuICBleHRyYWN0SUFOQVpvbmVcbik7XG5jb25zdCBleHRyYWN0SVNPT3JkaW5hbERhdGVBbmRUaW1lID0gY29tYmluZUV4dHJhY3RvcnMoXG4gIGV4dHJhY3RJU09PcmRpbmFsRGF0YSxcbiAgZXh0cmFjdElTT1RpbWUsXG4gIGV4dHJhY3RJU09PZmZzZXQsXG4gIGV4dHJhY3RJQU5BWm9uZVxuKTtcbmNvbnN0IGV4dHJhY3RJU09UaW1lQW5kT2Zmc2V0ID0gY29tYmluZUV4dHJhY3RvcnMoXG4gIGV4dHJhY3RJU09UaW1lLFxuICBleHRyYWN0SVNPT2Zmc2V0LFxuICBleHRyYWN0SUFOQVpvbmVcbik7XG5cbi8qXG4gKiBAcHJpdmF0ZVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUlTT0RhdGUocykge1xuICByZXR1cm4gcGFyc2UoXG4gICAgcyxcbiAgICBbaXNvWW1kV2l0aFRpbWVFeHRlbnNpb25SZWdleCwgZXh0cmFjdElTT1ltZFRpbWVBbmRPZmZzZXRdLFxuICAgIFtpc29XZWVrV2l0aFRpbWVFeHRlbnNpb25SZWdleCwgZXh0cmFjdElTT1dlZWtUaW1lQW5kT2Zmc2V0XSxcbiAgICBbaXNvT3JkaW5hbFdpdGhUaW1lRXh0ZW5zaW9uUmVnZXgsIGV4dHJhY3RJU09PcmRpbmFsRGF0ZUFuZFRpbWVdLFxuICAgIFtpc29UaW1lQ29tYmluZWRSZWdleCwgZXh0cmFjdElTT1RpbWVBbmRPZmZzZXRdXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVJGQzI4MjJEYXRlKHMpIHtcbiAgcmV0dXJuIHBhcnNlKHByZXByb2Nlc3NSRkMyODIyKHMpLCBbcmZjMjgyMiwgZXh0cmFjdFJGQzI4MjJdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSFRUUERhdGUocykge1xuICByZXR1cm4gcGFyc2UoXG4gICAgcyxcbiAgICBbcmZjMTEyMywgZXh0cmFjdFJGQzExMjNPcjg1MF0sXG4gICAgW3JmYzg1MCwgZXh0cmFjdFJGQzExMjNPcjg1MF0sXG4gICAgW2FzY2lpLCBleHRyYWN0QVNDSUldXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUlTT0R1cmF0aW9uKHMpIHtcbiAgcmV0dXJuIHBhcnNlKHMsIFtpc29EdXJhdGlvbiwgZXh0cmFjdElTT0R1cmF0aW9uXSk7XG59XG5cbmNvbnN0IGV4dHJhY3RJU09UaW1lT25seSA9IGNvbWJpbmVFeHRyYWN0b3JzKGV4dHJhY3RJU09UaW1lKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSVNPVGltZU9ubHkocykge1xuICByZXR1cm4gcGFyc2UocywgW2lzb1RpbWVPbmx5LCBleHRyYWN0SVNPVGltZU9ubHldKTtcbn1cblxuY29uc3Qgc3FsWW1kV2l0aFRpbWVFeHRlbnNpb25SZWdleCA9IGNvbWJpbmVSZWdleGVzKHNxbFltZFJlZ2V4LCBzcWxUaW1lRXh0ZW5zaW9uUmVnZXgpO1xuY29uc3Qgc3FsVGltZUNvbWJpbmVkUmVnZXggPSBjb21iaW5lUmVnZXhlcyhzcWxUaW1lUmVnZXgpO1xuXG5jb25zdCBleHRyYWN0SVNPVGltZU9mZnNldEFuZElBTkFab25lID0gY29tYmluZUV4dHJhY3RvcnMoXG4gIGV4dHJhY3RJU09UaW1lLFxuICBleHRyYWN0SVNPT2Zmc2V0LFxuICBleHRyYWN0SUFOQVpvbmVcbik7XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVNRTChzKSB7XG4gIHJldHVybiBwYXJzZShcbiAgICBzLFxuICAgIFtzcWxZbWRXaXRoVGltZUV4dGVuc2lvblJlZ2V4LCBleHRyYWN0SVNPWW1kVGltZUFuZE9mZnNldF0sXG4gICAgW3NxbFRpbWVDb21iaW5lZFJlZ2V4LCBleHRyYWN0SVNPVGltZU9mZnNldEFuZElBTkFab25lXVxuICApO1xufVxuIiwgImltcG9ydCB7IEludmFsaWRBcmd1bWVudEVycm9yLCBJbnZhbGlkRHVyYXRpb25FcnJvciwgSW52YWxpZFVuaXRFcnJvciB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IEZvcm1hdHRlciBmcm9tIFwiLi9pbXBsL2Zvcm1hdHRlci5qc1wiO1xuaW1wb3J0IEludmFsaWQgZnJvbSBcIi4vaW1wbC9pbnZhbGlkLmpzXCI7XG5pbXBvcnQgTG9jYWxlIGZyb20gXCIuL2ltcGwvbG9jYWxlLmpzXCI7XG5pbXBvcnQgeyBwYXJzZUlTT0R1cmF0aW9uLCBwYXJzZUlTT1RpbWVPbmx5IH0gZnJvbSBcIi4vaW1wbC9yZWdleFBhcnNlci5qc1wiO1xuaW1wb3J0IHtcbiAgYXNOdW1iZXIsXG4gIGhhc093blByb3BlcnR5LFxuICBpc051bWJlcixcbiAgaXNVbmRlZmluZWQsXG4gIG5vcm1hbGl6ZU9iamVjdCxcbiAgcm91bmRUbyxcbn0gZnJvbSBcIi4vaW1wbC91dGlsLmpzXCI7XG5pbXBvcnQgU2V0dGluZ3MgZnJvbSBcIi4vc2V0dGluZ3MuanNcIjtcbmltcG9ydCBEYXRlVGltZSBmcm9tIFwiLi9kYXRldGltZS5qc1wiO1xuXG5jb25zdCBJTlZBTElEID0gXCJJbnZhbGlkIER1cmF0aW9uXCI7XG5cbi8vIHVuaXQgY29udmVyc2lvbiBjb25zdGFudHNcbmV4cG9ydCBjb25zdCBsb3dPcmRlck1hdHJpeCA9IHtcbiAgICB3ZWVrczoge1xuICAgICAgZGF5czogNyxcbiAgICAgIGhvdXJzOiA3ICogMjQsXG4gICAgICBtaW51dGVzOiA3ICogMjQgKiA2MCxcbiAgICAgIHNlY29uZHM6IDcgKiAyNCAqIDYwICogNjAsXG4gICAgICBtaWxsaXNlY29uZHM6IDcgKiAyNCAqIDYwICogNjAgKiAxMDAwLFxuICAgIH0sXG4gICAgZGF5czoge1xuICAgICAgaG91cnM6IDI0LFxuICAgICAgbWludXRlczogMjQgKiA2MCxcbiAgICAgIHNlY29uZHM6IDI0ICogNjAgKiA2MCxcbiAgICAgIG1pbGxpc2Vjb25kczogMjQgKiA2MCAqIDYwICogMTAwMCxcbiAgICB9LFxuICAgIGhvdXJzOiB7IG1pbnV0ZXM6IDYwLCBzZWNvbmRzOiA2MCAqIDYwLCBtaWxsaXNlY29uZHM6IDYwICogNjAgKiAxMDAwIH0sXG4gICAgbWludXRlczogeyBzZWNvbmRzOiA2MCwgbWlsbGlzZWNvbmRzOiA2MCAqIDEwMDAgfSxcbiAgICBzZWNvbmRzOiB7IG1pbGxpc2Vjb25kczogMTAwMCB9LFxuICB9LFxuICBjYXN1YWxNYXRyaXggPSB7XG4gICAgeWVhcnM6IHtcbiAgICAgIHF1YXJ0ZXJzOiA0LFxuICAgICAgbW9udGhzOiAxMixcbiAgICAgIHdlZWtzOiA1MixcbiAgICAgIGRheXM6IDM2NSxcbiAgICAgIGhvdXJzOiAzNjUgKiAyNCxcbiAgICAgIG1pbnV0ZXM6IDM2NSAqIDI0ICogNjAsXG4gICAgICBzZWNvbmRzOiAzNjUgKiAyNCAqIDYwICogNjAsXG4gICAgICBtaWxsaXNlY29uZHM6IDM2NSAqIDI0ICogNjAgKiA2MCAqIDEwMDAsXG4gICAgfSxcbiAgICBxdWFydGVyczoge1xuICAgICAgbW9udGhzOiAzLFxuICAgICAgd2Vla3M6IDEzLFxuICAgICAgZGF5czogOTEsXG4gICAgICBob3VyczogOTEgKiAyNCxcbiAgICAgIG1pbnV0ZXM6IDkxICogMjQgKiA2MCxcbiAgICAgIHNlY29uZHM6IDkxICogMjQgKiA2MCAqIDYwLFxuICAgICAgbWlsbGlzZWNvbmRzOiA5MSAqIDI0ICogNjAgKiA2MCAqIDEwMDAsXG4gICAgfSxcbiAgICBtb250aHM6IHtcbiAgICAgIHdlZWtzOiA0LFxuICAgICAgZGF5czogMzAsXG4gICAgICBob3VyczogMzAgKiAyNCxcbiAgICAgIG1pbnV0ZXM6IDMwICogMjQgKiA2MCxcbiAgICAgIHNlY29uZHM6IDMwICogMjQgKiA2MCAqIDYwLFxuICAgICAgbWlsbGlzZWNvbmRzOiAzMCAqIDI0ICogNjAgKiA2MCAqIDEwMDAsXG4gICAgfSxcblxuICAgIC4uLmxvd09yZGVyTWF0cml4LFxuICB9LFxuICBkYXlzSW5ZZWFyQWNjdXJhdGUgPSAxNDYwOTcuMCAvIDQwMCxcbiAgZGF5c0luTW9udGhBY2N1cmF0ZSA9IDE0NjA5Ny4wIC8gNDgwMCxcbiAgYWNjdXJhdGVNYXRyaXggPSB7XG4gICAgeWVhcnM6IHtcbiAgICAgIHF1YXJ0ZXJzOiA0LFxuICAgICAgbW9udGhzOiAxMixcbiAgICAgIHdlZWtzOiBkYXlzSW5ZZWFyQWNjdXJhdGUgLyA3LFxuICAgICAgZGF5czogZGF5c0luWWVhckFjY3VyYXRlLFxuICAgICAgaG91cnM6IGRheXNJblllYXJBY2N1cmF0ZSAqIDI0LFxuICAgICAgbWludXRlczogZGF5c0luWWVhckFjY3VyYXRlICogMjQgKiA2MCxcbiAgICAgIHNlY29uZHM6IGRheXNJblllYXJBY2N1cmF0ZSAqIDI0ICogNjAgKiA2MCxcbiAgICAgIG1pbGxpc2Vjb25kczogZGF5c0luWWVhckFjY3VyYXRlICogMjQgKiA2MCAqIDYwICogMTAwMCxcbiAgICB9LFxuICAgIHF1YXJ0ZXJzOiB7XG4gICAgICBtb250aHM6IDMsXG4gICAgICB3ZWVrczogZGF5c0luWWVhckFjY3VyYXRlIC8gMjgsXG4gICAgICBkYXlzOiBkYXlzSW5ZZWFyQWNjdXJhdGUgLyA0LFxuICAgICAgaG91cnM6IChkYXlzSW5ZZWFyQWNjdXJhdGUgKiAyNCkgLyA0LFxuICAgICAgbWludXRlczogKGRheXNJblllYXJBY2N1cmF0ZSAqIDI0ICogNjApIC8gNCxcbiAgICAgIHNlY29uZHM6IChkYXlzSW5ZZWFyQWNjdXJhdGUgKiAyNCAqIDYwICogNjApIC8gNCxcbiAgICAgIG1pbGxpc2Vjb25kczogKGRheXNJblllYXJBY2N1cmF0ZSAqIDI0ICogNjAgKiA2MCAqIDEwMDApIC8gNCxcbiAgICB9LFxuICAgIG1vbnRoczoge1xuICAgICAgd2Vla3M6IGRheXNJbk1vbnRoQWNjdXJhdGUgLyA3LFxuICAgICAgZGF5czogZGF5c0luTW9udGhBY2N1cmF0ZSxcbiAgICAgIGhvdXJzOiBkYXlzSW5Nb250aEFjY3VyYXRlICogMjQsXG4gICAgICBtaW51dGVzOiBkYXlzSW5Nb250aEFjY3VyYXRlICogMjQgKiA2MCxcbiAgICAgIHNlY29uZHM6IGRheXNJbk1vbnRoQWNjdXJhdGUgKiAyNCAqIDYwICogNjAsXG4gICAgICBtaWxsaXNlY29uZHM6IGRheXNJbk1vbnRoQWNjdXJhdGUgKiAyNCAqIDYwICogNjAgKiAxMDAwLFxuICAgIH0sXG4gICAgLi4ubG93T3JkZXJNYXRyaXgsXG4gIH07XG5cbi8vIHVuaXRzIG9yZGVyZWQgYnkgc2l6ZVxuY29uc3Qgb3JkZXJlZFVuaXRzID0gW1xuICBcInllYXJzXCIsXG4gIFwicXVhcnRlcnNcIixcbiAgXCJtb250aHNcIixcbiAgXCJ3ZWVrc1wiLFxuICBcImRheXNcIixcbiAgXCJob3Vyc1wiLFxuICBcIm1pbnV0ZXNcIixcbiAgXCJzZWNvbmRzXCIsXG4gIFwibWlsbGlzZWNvbmRzXCIsXG5dO1xuXG5jb25zdCByZXZlcnNlVW5pdHMgPSBvcmRlcmVkVW5pdHMuc2xpY2UoMCkucmV2ZXJzZSgpO1xuXG4vLyBjbG9uZSByZWFsbHkgbWVhbnMgXCJjcmVhdGUgYW5vdGhlciBpbnN0YW5jZSBqdXN0IGxpa2UgdGhpcyBvbmUsIGJ1dCB3aXRoIHRoZXNlIGNoYW5nZXNcIlxuZnVuY3Rpb24gY2xvbmUoZHVyLCBhbHRzLCBjbGVhciA9IGZhbHNlKSB7XG4gIC8vIGRlZXAgbWVyZ2UgZm9yIHZhbHNcbiAgY29uc3QgY29uZiA9IHtcbiAgICB2YWx1ZXM6IGNsZWFyID8gYWx0cy52YWx1ZXMgOiB7IC4uLmR1ci52YWx1ZXMsIC4uLihhbHRzLnZhbHVlcyB8fCB7fSkgfSxcbiAgICBsb2M6IGR1ci5sb2MuY2xvbmUoYWx0cy5sb2MpLFxuICAgIGNvbnZlcnNpb25BY2N1cmFjeTogYWx0cy5jb252ZXJzaW9uQWNjdXJhY3kgfHwgZHVyLmNvbnZlcnNpb25BY2N1cmFjeSxcbiAgICBtYXRyaXg6IGFsdHMubWF0cml4IHx8IGR1ci5tYXRyaXgsXG4gIH07XG4gIHJldHVybiBuZXcgRHVyYXRpb24oY29uZik7XG59XG5cbmZ1bmN0aW9uIGR1cmF0aW9uVG9NaWxsaXMobWF0cml4LCB2YWxzKSB7XG4gIGxldCBzdW0gPSB2YWxzLm1pbGxpc2Vjb25kcyA/PyAwO1xuICBmb3IgKGNvbnN0IHVuaXQgb2YgcmV2ZXJzZVVuaXRzLnNsaWNlKDEpKSB7XG4gICAgaWYgKHZhbHNbdW5pdF0pIHtcbiAgICAgIHN1bSArPSB2YWxzW3VuaXRdICogbWF0cml4W3VuaXRdW1wibWlsbGlzZWNvbmRzXCJdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3VtO1xufVxuXG4vLyBOQjogbXV0YXRlcyBwYXJhbWV0ZXJzXG5mdW5jdGlvbiBub3JtYWxpemVWYWx1ZXMobWF0cml4LCB2YWxzKSB7XG4gIC8vIHRoZSBsb2dpYyBiZWxvdyBhc3N1bWVzIHRoZSBvdmVyYWxsIHZhbHVlIG9mIHRoZSBkdXJhdGlvbiBpcyBwb3NpdGl2ZVxuICAvLyBpZiB0aGlzIGlzIG5vdCB0aGUgY2FzZSwgZmFjdG9yIGlzIHVzZWQgdG8gbWFrZSBpdCBzb1xuICBjb25zdCBmYWN0b3IgPSBkdXJhdGlvblRvTWlsbGlzKG1hdHJpeCwgdmFscykgPCAwID8gLTEgOiAxO1xuXG4gIG9yZGVyZWRVbml0cy5yZWR1Y2VSaWdodCgocHJldmlvdXMsIGN1cnJlbnQpID0+IHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHZhbHNbY3VycmVudF0pKSB7XG4gICAgICBpZiAocHJldmlvdXMpIHtcbiAgICAgICAgY29uc3QgcHJldmlvdXNWYWwgPSB2YWxzW3ByZXZpb3VzXSAqIGZhY3RvcjtcbiAgICAgICAgY29uc3QgY29udiA9IG1hdHJpeFtjdXJyZW50XVtwcmV2aW91c107XG5cbiAgICAgICAgLy8gaWYgKHByZXZpb3VzVmFsIDwgMCk6XG4gICAgICAgIC8vIGxvd2VyIG9yZGVyIHVuaXQgaXMgbmVnYXRpdmUgKGUuZy4geyB5ZWFyczogMiwgZGF5czogLTIgfSlcbiAgICAgICAgLy8gbm9ybWFsaXplIHRoaXMgYnkgcmVkdWNpbmcgdGhlIGhpZ2hlciBvcmRlciB1bml0IGJ5IHRoZSBhcHByb3ByaWF0ZSBhbW91bnRcbiAgICAgICAgLy8gYW5kIGluY3JlYXNpbmcgdGhlIGxvd2VyIG9yZGVyIHVuaXRcbiAgICAgICAgLy8gdGhpcyBjYW4gbmV2ZXIgbWFrZSB0aGUgaGlnaGVyIG9yZGVyIHVuaXQgbmVnYXRpdmUsIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBvbmx5IG9wZXJhdGVzXG4gICAgICAgIC8vIG9uIHBvc2l0aXZlIGR1cmF0aW9ucywgc28gdGhlIGFtb3VudCBvZiB0aW1lIHJlcHJlc2VudGVkIGJ5IHRoZSBsb3dlciBvcmRlciB1bml0IGNhbm5vdFxuICAgICAgICAvLyBiZSBsYXJnZXIgdGhhbiB0aGUgaGlnaGVyIG9yZGVyIHVuaXRcbiAgICAgICAgLy8gZWxzZTpcbiAgICAgICAgLy8gbG93ZXIgb3JkZXIgdW5pdCBpcyBwb3NpdGl2ZSAoZS5nLiB7IHllYXJzOiAyLCBkYXlzOiA0NTAgfSBvciB7IHllYXJzOiAtMiwgZGF5czogNDUwIH0pXG4gICAgICAgIC8vIGluIHRoaXMgY2FzZSB3ZSBhdHRlbXB0IHRvIGNvbnZlcnQgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBsb3dlciBvcmRlciB1bml0IGludG9cbiAgICAgICAgLy8gdGhlIGhpZ2hlciBvcmRlciBvbmVcbiAgICAgICAgLy9cbiAgICAgICAgLy8gTWF0aC5mbG9vciB0YWtlcyBjYXJlIG9mIGJvdGggb2YgdGhlc2UgY2FzZXMsIHJvdW5kaW5nIGF3YXkgZnJvbSAwXG4gICAgICAgIC8vIGlmIHByZXZpb3VzVmFsIDwgMCBpdCBtYWtlcyB0aGUgYWJzb2x1dGUgdmFsdWUgbGFyZ2VyXG4gICAgICAgIC8vIGlmIHByZXZpb3VzVmFsID49IGl0IG1ha2VzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBzbWFsbGVyXG4gICAgICAgIGNvbnN0IHJvbGxVcCA9IE1hdGguZmxvb3IocHJldmlvdXNWYWwgLyBjb252KTtcbiAgICAgICAgdmFsc1tjdXJyZW50XSArPSByb2xsVXAgKiBmYWN0b3I7XG4gICAgICAgIHZhbHNbcHJldmlvdXNdIC09IHJvbGxVcCAqIGNvbnYgKiBmYWN0b3I7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHByZXZpb3VzO1xuICAgIH1cbiAgfSwgbnVsbCk7XG5cbiAgLy8gdHJ5IHRvIGNvbnZlcnQgYW55IGRlY2ltYWxzIGludG8gc21hbGxlciB1bml0cyBpZiBwb3NzaWJsZVxuICAvLyBmb3IgZXhhbXBsZSBmb3IgeyB5ZWFyczogMi41LCBkYXlzOiAwLCBzZWNvbmRzOiAwIH0gd2Ugd2FudCB0byBnZXQgeyB5ZWFyczogMiwgZGF5czogMTgyLCBob3VyczogMTIgfVxuICBvcmRlcmVkVW5pdHMucmVkdWNlKChwcmV2aW91cywgY3VycmVudCkgPT4ge1xuICAgIGlmICghaXNVbmRlZmluZWQodmFsc1tjdXJyZW50XSkpIHtcbiAgICAgIGlmIChwcmV2aW91cykge1xuICAgICAgICBjb25zdCBmcmFjdGlvbiA9IHZhbHNbcHJldmlvdXNdICUgMTtcbiAgICAgICAgdmFsc1twcmV2aW91c10gLT0gZnJhY3Rpb247XG4gICAgICAgIHZhbHNbY3VycmVudF0gKz0gZnJhY3Rpb24gKiBtYXRyaXhbcHJldmlvdXNdW2N1cnJlbnRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwcmV2aW91cztcbiAgICB9XG4gIH0sIG51bGwpO1xufVxuXG4vLyBSZW1vdmUgYWxsIHByb3BlcnRpZXMgd2l0aCBhIHZhbHVlIG9mIDAgZnJvbSBhbiBvYmplY3RcbmZ1bmN0aW9uIHJlbW92ZVplcm9lcyh2YWxzKSB7XG4gIGNvbnN0IG5ld1ZhbHMgPSB7fTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModmFscykpIHtcbiAgICBpZiAodmFsdWUgIT09IDApIHtcbiAgICAgIG5ld1ZhbHNba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3VmFscztcbn1cblxuLyoqXG4gKiBBIER1cmF0aW9uIG9iamVjdCByZXByZXNlbnRzIGEgcGVyaW9kIG9mIHRpbWUsIGxpa2UgXCIyIG1vbnRoc1wiIG9yIFwiMSBkYXksIDEgaG91clwiLiBDb25jZXB0dWFsbHksIGl0J3MganVzdCBhIG1hcCBvZiB1bml0cyB0byB0aGVpciBxdWFudGl0aWVzLCBhY2NvbXBhbmllZCBieSBzb21lIGFkZGl0aW9uYWwgY29uZmlndXJhdGlvbiBhbmQgbWV0aG9kcyBmb3IgY3JlYXRpbmcsIHBhcnNpbmcsIGludGVycm9nYXRpbmcsIHRyYW5zZm9ybWluZywgYW5kIGZvcm1hdHRpbmcgdGhlbS4gVGhleSBjYW4gYmUgdXNlZCBvbiB0aGVpciBvd24gb3IgaW4gY29uanVuY3Rpb24gd2l0aCBvdGhlciBMdXhvbiB0eXBlczsgZm9yIGV4YW1wbGUsIHlvdSBjYW4gdXNlIHtAbGluayBEYXRlVGltZSNwbHVzfSB0byBhZGQgYSBEdXJhdGlvbiBvYmplY3QgdG8gYSBEYXRlVGltZSwgcHJvZHVjaW5nIGFub3RoZXIgRGF0ZVRpbWUuXG4gKlxuICogSGVyZSBpcyBhIGJyaWVmIG92ZXJ2aWV3IG9mIGNvbW1vbmx5IHVzZWQgbWV0aG9kcyBhbmQgZ2V0dGVycyBpbiBEdXJhdGlvbjpcbiAqXG4gKiAqICoqQ3JlYXRpb24qKiBUbyBjcmVhdGUgYSBEdXJhdGlvbiwgdXNlIHtAbGluayBEdXJhdGlvbi5mcm9tTWlsbGlzfSwge0BsaW5rIER1cmF0aW9uLmZyb21PYmplY3R9LCBvciB7QGxpbmsgRHVyYXRpb24uZnJvbUlTT30uXG4gKiAqICoqVW5pdCB2YWx1ZXMqKiBTZWUgdGhlIHtAbGluayBEdXJhdGlvbiN5ZWFyc30sIHtAbGluayBEdXJhdGlvbiNtb250aHN9LCB7QGxpbmsgRHVyYXRpb24jd2Vla3N9LCB7QGxpbmsgRHVyYXRpb24jZGF5c30sIHtAbGluayBEdXJhdGlvbiNob3Vyc30sIHtAbGluayBEdXJhdGlvbiNtaW51dGVzfSwge0BsaW5rIER1cmF0aW9uI3NlY29uZHN9LCB7QGxpbmsgRHVyYXRpb24jbWlsbGlzZWNvbmRzfSBhY2Nlc3NvcnMuXG4gKiAqICoqQ29uZmlndXJhdGlvbioqIFNlZSAge0BsaW5rIER1cmF0aW9uI2xvY2FsZX0gYW5kIHtAbGluayBEdXJhdGlvbiNudW1iZXJpbmdTeXN0ZW19IGFjY2Vzc29ycy5cbiAqICogKipUcmFuc2Zvcm1hdGlvbioqIFRvIGNyZWF0ZSBuZXcgRHVyYXRpb25zIG91dCBvZiBvbGQgb25lcyB1c2Uge0BsaW5rIER1cmF0aW9uI3BsdXN9LCB7QGxpbmsgRHVyYXRpb24jbWludXN9LCB7QGxpbmsgRHVyYXRpb24jbm9ybWFsaXplfSwge0BsaW5rIER1cmF0aW9uI3NldH0sIHtAbGluayBEdXJhdGlvbiNyZWNvbmZpZ3VyZX0sIHtAbGluayBEdXJhdGlvbiNzaGlmdFRvfSwgYW5kIHtAbGluayBEdXJhdGlvbiNuZWdhdGV9LlxuICogKiAqKk91dHB1dCoqIFRvIGNvbnZlcnQgdGhlIER1cmF0aW9uIGludG8gb3RoZXIgcmVwcmVzZW50YXRpb25zLCBzZWUge0BsaW5rIER1cmF0aW9uI2FzfSwge0BsaW5rIER1cmF0aW9uI3RvSVNPfSwge0BsaW5rIER1cmF0aW9uI3RvRm9ybWF0fSwgYW5kIHtAbGluayBEdXJhdGlvbiN0b0pTT059XG4gKlxuICogVGhlcmUncyBhcmUgbW9yZSBtZXRob2RzIGRvY3VtZW50ZWQgYmVsb3cuIEluIGFkZGl0aW9uLCBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBzdWJ0bGVyIHRvcGljcyBsaWtlIGludGVybmF0aW9uYWxpemF0aW9uIGFuZCB2YWxpZGl0eSwgc2VlIHRoZSBleHRlcm5hbCBkb2N1bWVudGF0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEdXJhdGlvbiB7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgY29uc3QgYWNjdXJhdGUgPSBjb25maWcuY29udmVyc2lvbkFjY3VyYWN5ID09PSBcImxvbmd0ZXJtXCIgfHwgZmFsc2U7XG4gICAgbGV0IG1hdHJpeCA9IGFjY3VyYXRlID8gYWNjdXJhdGVNYXRyaXggOiBjYXN1YWxNYXRyaXg7XG5cbiAgICBpZiAoY29uZmlnLm1hdHJpeCkge1xuICAgICAgbWF0cml4ID0gY29uZmlnLm1hdHJpeDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnZhbHVlcyA9IGNvbmZpZy52YWx1ZXM7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5sb2MgPSBjb25maWcubG9jIHx8IExvY2FsZS5jcmVhdGUoKTtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmNvbnZlcnNpb25BY2N1cmFjeSA9IGFjY3VyYXRlID8gXCJsb25ndGVybVwiIDogXCJjYXN1YWxcIjtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmludmFsaWQgPSBjb25maWcuaW52YWxpZCB8fCBudWxsO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubWF0cml4ID0gbWF0cml4O1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaXNMdXhvbkR1cmF0aW9uID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgRHVyYXRpb24gZnJvbSBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCBvZiBtaWxsaXNlY29uZHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIGZvciBwYXJzaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J2VuLVVTJ10gLSB0aGUgbG9jYWxlIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmNvbnZlcnNpb25BY2N1cmFjeT0nY2FzdWFsJ10gLSB0aGUgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgc3RhdGljIGZyb21NaWxsaXMoY291bnQsIG9wdHMpIHtcbiAgICByZXR1cm4gRHVyYXRpb24uZnJvbU9iamVjdCh7IG1pbGxpc2Vjb25kczogY291bnQgfSwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRHVyYXRpb24gZnJvbSBhIEphdmFTY3JpcHQgb2JqZWN0IHdpdGgga2V5cyBsaWtlICd5ZWFycycgYW5kICdob3VycycuXG4gICAqIElmIHRoaXMgb2JqZWN0IGlzIGVtcHR5IHRoZW4gYSB6ZXJvIG1pbGxpc2Vjb25kcyBkdXJhdGlvbiBpcyByZXR1cm5lZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIHRoZSBvYmplY3QgdG8gY3JlYXRlIHRoZSBEYXRlVGltZSBmcm9tXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoueWVhcnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5xdWFydGVyc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLm1vbnRoc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLndlZWtzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmouZGF5c1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLmhvdXJzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoubWludXRlc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLnNlY29uZHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5taWxsaXNlY29uZHNcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzPVtdXSAtIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoaXMgRHVyYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nZW4tVVMnXSAtIHRoZSBsb2NhbGUgdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29udmVyc2lvbkFjY3VyYWN5PSdjYXN1YWwnXSAtIHRoZSBwcmVzZXQgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5tYXRyaXg9T2JqZWN0XSAtIHRoZSBjdXN0b20gY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgc3RhdGljIGZyb21PYmplY3Qob2JqLCBvcHRzID0ge30pIHtcbiAgICBpZiAob2JqID09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFxuICAgICAgICBgRHVyYXRpb24uZnJvbU9iamVjdDogYXJndW1lbnQgZXhwZWN0ZWQgdG8gYmUgYW4gb2JqZWN0LCBnb3QgJHtcbiAgICAgICAgICBvYmogPT09IG51bGwgPyBcIm51bGxcIiA6IHR5cGVvZiBvYmpcbiAgICAgICAgfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBEdXJhdGlvbih7XG4gICAgICB2YWx1ZXM6IG5vcm1hbGl6ZU9iamVjdChvYmosIER1cmF0aW9uLm5vcm1hbGl6ZVVuaXQpLFxuICAgICAgbG9jOiBMb2NhbGUuZnJvbU9iamVjdChvcHRzKSxcbiAgICAgIGNvbnZlcnNpb25BY2N1cmFjeTogb3B0cy5jb252ZXJzaW9uQWNjdXJhY3ksXG4gICAgICBtYXRyaXg6IG9wdHMubWF0cml4LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIER1cmF0aW9uIGZyb20gRHVyYXRpb25MaWtlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdCB8IG51bWJlciB8IER1cmF0aW9ufSBkdXJhdGlvbkxpa2VcbiAgICogT25lIG9mOlxuICAgKiAtIG9iamVjdCB3aXRoIGtleXMgbGlrZSAneWVhcnMnIGFuZCAnaG91cnMnLlxuICAgKiAtIG51bWJlciByZXByZXNlbnRpbmcgbWlsbGlzZWNvbmRzXG4gICAqIC0gRHVyYXRpb24gaW5zdGFuY2VcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzdGF0aWMgZnJvbUR1cmF0aW9uTGlrZShkdXJhdGlvbkxpa2UpIHtcbiAgICBpZiAoaXNOdW1iZXIoZHVyYXRpb25MaWtlKSkge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmZyb21NaWxsaXMoZHVyYXRpb25MaWtlKTtcbiAgICB9IGVsc2UgaWYgKER1cmF0aW9uLmlzRHVyYXRpb24oZHVyYXRpb25MaWtlKSkge1xuICAgICAgcmV0dXJuIGR1cmF0aW9uTGlrZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkdXJhdGlvbkxpa2UgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5mcm9tT2JqZWN0KGR1cmF0aW9uTGlrZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcbiAgICAgICAgYFVua25vd24gZHVyYXRpb24gYXJndW1lbnQgJHtkdXJhdGlvbkxpa2V9IG9mIHR5cGUgJHt0eXBlb2YgZHVyYXRpb25MaWtlfWBcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIER1cmF0aW9uIGZyb20gYW4gSVNPIDg2MDEgZHVyYXRpb24gc3RyaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRleHQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIGZvciBwYXJzaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J2VuLVVTJ10gLSB0aGUgbG9jYWxlIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmNvbnZlcnNpb25BY2N1cmFjeT0nY2FzdWFsJ10gLSB0aGUgcHJlc2V0IGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubWF0cml4PU9iamVjdF0gLSB0aGUgcHJlc2V0IGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI0R1cmF0aW9uc1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tSVNPKCdQM1k2TTFXNERUMTJIMzBNNVMnKS50b09iamVjdCgpIC8vPT4geyB5ZWFyczogMywgbW9udGhzOiA2LCB3ZWVrczogMSwgZGF5czogNCwgaG91cnM6IDEyLCBtaW51dGVzOiAzMCwgc2Vjb25kczogNSB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU08oJ1BUMjNIJykudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDIzIH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTTygnUDVZM00nKS50b09iamVjdCgpIC8vPT4geyB5ZWFyczogNSwgbW9udGhzOiAzIH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzdGF0aWMgZnJvbUlTTyh0ZXh0LCBvcHRzKSB7XG4gICAgY29uc3QgW3BhcnNlZF0gPSBwYXJzZUlTT0R1cmF0aW9uKHRleHQpO1xuICAgIGlmIChwYXJzZWQpIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5mcm9tT2JqZWN0KHBhcnNlZCwgb3B0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5pbnZhbGlkKFwidW5wYXJzYWJsZVwiLCBgdGhlIGlucHV0IFwiJHt0ZXh0fVwiIGNhbid0IGJlIHBhcnNlZCBhcyBJU08gODYwMWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEdXJhdGlvbiBmcm9tIGFuIElTTyA4NjAxIHRpbWUgc3RyaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRleHQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIGZvciBwYXJzaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J2VuLVVTJ10gLSB0aGUgbG9jYWxlIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmNvbnZlcnNpb25BY2N1cmFjeT0nY2FzdWFsJ10gLSB0aGUgcHJlc2V0IGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubWF0cml4PU9iamVjdF0gLSB0aGUgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjVGltZXNcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTT1RpbWUoJzExOjIyOjMzLjQ0NCcpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMSwgbWludXRlczogMjIsIHNlY29uZHM6IDMzLCBtaWxsaXNlY29uZHM6IDQ0NCB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU09UaW1lKCcxMTowMCcpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMSwgbWludXRlczogMCwgc2Vjb25kczogMCB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU09UaW1lKCdUMTE6MDAnKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMTEsIG1pbnV0ZXM6IDAsIHNlY29uZHM6IDAgfVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tSVNPVGltZSgnMTEwMCcpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMSwgbWludXRlczogMCwgc2Vjb25kczogMCB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU09UaW1lKCdUMTEwMCcpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMSwgbWludXRlczogMCwgc2Vjb25kczogMCB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgc3RhdGljIGZyb21JU09UaW1lKHRleHQsIG9wdHMpIHtcbiAgICBjb25zdCBbcGFyc2VkXSA9IHBhcnNlSVNPVGltZU9ubHkodGV4dCk7XG4gICAgaWYgKHBhcnNlZCkge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmZyb21PYmplY3QocGFyc2VkLCBvcHRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmludmFsaWQoXCJ1bnBhcnNhYmxlXCIsIGB0aGUgaW5wdXQgXCIke3RleHR9XCIgY2FuJ3QgYmUgcGFyc2VkIGFzIElTTyA4NjAxYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnZhbGlkIER1cmF0aW9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uIC0gc2ltcGxlIHN0cmluZyBvZiB3aHkgdGhpcyBkYXRldGltZSBpcyBpbnZhbGlkLiBTaG91bGQgbm90IGNvbnRhaW4gcGFyYW1ldGVycyBvciBhbnl0aGluZyBlbHNlIGRhdGEtZGVwZW5kZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZXhwbGFuYXRpb249bnVsbF0gLSBsb25nZXIgZXhwbGFuYXRpb24sIG1heSBpbmNsdWRlIHBhcmFtZXRlcnMgYW5kIG90aGVyIHVzZWZ1bCBkZWJ1Z2dpbmcgaW5mb3JtYXRpb25cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzdGF0aWMgaW52YWxpZChyZWFzb24sIGV4cGxhbmF0aW9uID0gbnVsbCkge1xuICAgIGlmICghcmVhc29uKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJuZWVkIHRvIHNwZWNpZnkgYSByZWFzb24gdGhlIER1cmF0aW9uIGlzIGludmFsaWRcIik7XG4gICAgfVxuXG4gICAgY29uc3QgaW52YWxpZCA9IHJlYXNvbiBpbnN0YW5jZW9mIEludmFsaWQgPyByZWFzb24gOiBuZXcgSW52YWxpZChyZWFzb24sIGV4cGxhbmF0aW9uKTtcblxuICAgIGlmIChTZXR0aW5ncy50aHJvd09uSW52YWxpZCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWREdXJhdGlvbkVycm9yKGludmFsaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IER1cmF0aW9uKHsgaW52YWxpZCB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXRpYyBub3JtYWxpemVVbml0KHVuaXQpIHtcbiAgICBjb25zdCBub3JtYWxpemVkID0ge1xuICAgICAgeWVhcjogXCJ5ZWFyc1wiLFxuICAgICAgeWVhcnM6IFwieWVhcnNcIixcbiAgICAgIHF1YXJ0ZXI6IFwicXVhcnRlcnNcIixcbiAgICAgIHF1YXJ0ZXJzOiBcInF1YXJ0ZXJzXCIsXG4gICAgICBtb250aDogXCJtb250aHNcIixcbiAgICAgIG1vbnRoczogXCJtb250aHNcIixcbiAgICAgIHdlZWs6IFwid2Vla3NcIixcbiAgICAgIHdlZWtzOiBcIndlZWtzXCIsXG4gICAgICBkYXk6IFwiZGF5c1wiLFxuICAgICAgZGF5czogXCJkYXlzXCIsXG4gICAgICBob3VyOiBcImhvdXJzXCIsXG4gICAgICBob3VyczogXCJob3Vyc1wiLFxuICAgICAgbWludXRlOiBcIm1pbnV0ZXNcIixcbiAgICAgIG1pbnV0ZXM6IFwibWludXRlc1wiLFxuICAgICAgc2Vjb25kOiBcInNlY29uZHNcIixcbiAgICAgIHNlY29uZHM6IFwic2Vjb25kc1wiLFxuICAgICAgbWlsbGlzZWNvbmQ6IFwibWlsbGlzZWNvbmRzXCIsXG4gICAgICBtaWxsaXNlY29uZHM6IFwibWlsbGlzZWNvbmRzXCIsXG4gICAgfVt1bml0ID8gdW5pdC50b0xvd2VyQ2FzZSgpIDogdW5pdF07XG5cbiAgICBpZiAoIW5vcm1hbGl6ZWQpIHRocm93IG5ldyBJbnZhbGlkVW5pdEVycm9yKHVuaXQpO1xuXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gb2JqZWN0IGlzIGEgRHVyYXRpb24uIFdvcmtzIGFjcm9zcyBjb250ZXh0IGJvdW5kYXJpZXNcbiAgICogQHBhcmFtIHtvYmplY3R9IG9cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc0R1cmF0aW9uKG8pIHtcbiAgICByZXR1cm4gKG8gJiYgby5pc0x1eG9uRHVyYXRpb24pIHx8IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCAgdGhlIGxvY2FsZSBvZiBhIER1cmF0aW9uLCBzdWNoICdlbi1HQidcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBsb2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMubG9jLmxvY2FsZSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBudW1iZXJpbmcgc3lzdGVtIG9mIGEgRHVyYXRpb24sIHN1Y2ggJ2JlbmcnLiBUaGUgbnVtYmVyaW5nIHN5c3RlbSBpcyB1c2VkIHdoZW4gZm9ybWF0dGluZyB0aGUgRHVyYXRpb25cbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBudW1iZXJpbmdTeXN0ZW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMubG9jLm51bWJlcmluZ1N5c3RlbSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIER1cmF0aW9uIGZvcm1hdHRlZCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBmb3JtYXQgc3RyaW5nLiBZb3UgbWF5IHVzZSB0aGVzZSB0b2tlbnM6XG4gICAqICogYFNgIGZvciBtaWxsaXNlY29uZHNcbiAgICogKiBgc2AgZm9yIHNlY29uZHNcbiAgICogKiBgbWAgZm9yIG1pbnV0ZXNcbiAgICogKiBgaGAgZm9yIGhvdXJzXG4gICAqICogYGRgIGZvciBkYXlzXG4gICAqICogYHdgIGZvciB3ZWVrc1xuICAgKiAqIGBNYCBmb3IgbW9udGhzXG4gICAqICogYHlgIGZvciB5ZWFyc1xuICAgKiBOb3RlczpcbiAgICogKiBBZGQgcGFkZGluZyBieSByZXBlYXRpbmcgdGhlIHRva2VuLCBlLmcuIFwieXlcIiBwYWRzIHRoZSB5ZWFycyB0byB0d28gZGlnaXRzLCBcImhoaGhcIiBwYWRzIHRoZSBob3VycyBvdXQgdG8gZm91ciBkaWdpdHNcbiAgICogKiBUb2tlbnMgY2FuIGJlIGVzY2FwZWQgYnkgd3JhcHBpbmcgd2l0aCBzaW5nbGUgcXVvdGVzLlxuICAgKiAqIFRoZSBkdXJhdGlvbiB3aWxsIGJlIGNvbnZlcnRlZCB0byB0aGUgc2V0IG9mIHVuaXRzIGluIHRoZSBmb3JtYXQgc3RyaW5nIHVzaW5nIHtAbGluayBEdXJhdGlvbiNzaGlmdFRvfSBhbmQgdGhlIER1cmF0aW9ucydzIGNvbnZlcnNpb24gYWNjdXJhY3kgc2V0dGluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGZtdCAtIHRoZSBmb3JtYXQgc3RyaW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmZsb29yPXRydWVdIC0gZmxvb3IgbnVtZXJpY2FsIHZhbHVlc1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgeWVhcnM6IDEsIGRheXM6IDYsIHNlY29uZHM6IDIgfSkudG9Gb3JtYXQoXCJ5IGQgc1wiKSAvLz0+IFwiMSA2IDJcIlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgeWVhcnM6IDEsIGRheXM6IDYsIHNlY29uZHM6IDIgfSkudG9Gb3JtYXQoXCJ5eSBkZCBzc3NcIikgLy89PiBcIjAxIDA2IDAwMlwiXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMSwgZGF5czogNiwgc2Vjb25kczogMiB9KS50b0Zvcm1hdChcIk0gU1wiKSAvLz0+IFwiMTIgNTE4NDAyMDAwXCJcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9Gb3JtYXQoZm10LCBvcHRzID0ge30pIHtcbiAgICAvLyByZXZlcnNlLWNvbXBhdCBzaW5jZSAxLjI7IHdlIGFsd2F5cyByb3VuZCBkb3duIG5vdywgbmV2ZXIgdXAsIGFuZCB3ZSBkbyBpdCBieSBkZWZhdWx0XG4gICAgY29uc3QgZm10T3B0cyA9IHtcbiAgICAgIC4uLm9wdHMsXG4gICAgICBmbG9vcjogb3B0cy5yb3VuZCAhPT0gZmFsc2UgJiYgb3B0cy5mbG9vciAhPT0gZmFsc2UsXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkXG4gICAgICA/IEZvcm1hdHRlci5jcmVhdGUodGhpcy5sb2MsIGZtdE9wdHMpLmZvcm1hdER1cmF0aW9uRnJvbVN0cmluZyh0aGlzLCBmbXQpXG4gICAgICA6IElOVkFMSUQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIER1cmF0aW9uIHdpdGggYWxsIHVuaXRzIGluY2x1ZGVkLlxuICAgKiBUbyBtb2RpZnkgaXRzIGJlaGF2aW9yIHVzZSB0aGUgYGxpc3RTdHlsZWAgYW5kIGFueSBJbnRsLk51bWJlckZvcm1hdCBvcHRpb24sIHRob3VnaCBgdW5pdERpc3BsYXlgIGlzIGVzcGVjaWFsbHkgcmVsZXZhbnQuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvSW50bC9OdW1iZXJGb3JtYXRcbiAgICogQHBhcmFtIG9wdHMgLSBPbiBvcHRpb24gb2JqZWN0IHRvIG92ZXJyaWRlIHRoZSBmb3JtYXR0aW5nLiBBY2NlcHRzIHRoZSBzYW1lIGtleXMgYXMgdGhlIG9wdGlvbnMgcGFyYW1ldGVyIG9mIHRoZSBuYXRpdmUgYEludC5OdW1iZXJGb3JtYXRgIGNvbnN0cnVjdG9yLCBhcyB3ZWxsIGFzIGBsaXN0U3R5bGVgLlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiB2YXIgZHVyID0gRHVyYXRpb24uZnJvbU9iamVjdCh7IGRheXM6IDEsIGhvdXJzOiA1LCBtaW51dGVzOiA2IH0pXG4gICAqIGR1ci50b0h1bWFuKCkgLy89PiAnMSBkYXksIDUgaG91cnMsIDYgbWludXRlcydcbiAgICogZHVyLnRvSHVtYW4oeyBsaXN0U3R5bGU6IFwibG9uZ1wiIH0pIC8vPT4gJzEgZGF5LCA1IGhvdXJzLCBhbmQgNiBtaW51dGVzJ1xuICAgKiBkdXIudG9IdW1hbih7IHVuaXREaXNwbGF5OiBcInNob3J0XCIgfSkgLy89PiAnMSBkYXksIDUgaHIsIDYgbWluJ1xuICAgKiBgYGBcbiAgICovXG4gIHRvSHVtYW4ob3B0cyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBJTlZBTElEO1xuXG4gICAgY29uc3QgbCA9IG9yZGVyZWRVbml0c1xuICAgICAgLm1hcCgodW5pdCkgPT4ge1xuICAgICAgICBjb25zdCB2YWwgPSB0aGlzLnZhbHVlc1t1bml0XTtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbCkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5sb2NcbiAgICAgICAgICAubnVtYmVyRm9ybWF0dGVyKHsgc3R5bGU6IFwidW5pdFwiLCB1bml0RGlzcGxheTogXCJsb25nXCIsIC4uLm9wdHMsIHVuaXQ6IHVuaXQuc2xpY2UoMCwgLTEpIH0pXG4gICAgICAgICAgLmZvcm1hdCh2YWwpO1xuICAgICAgfSlcbiAgICAgIC5maWx0ZXIoKG4pID0+IG4pO1xuXG4gICAgcmV0dXJuIHRoaXMubG9jXG4gICAgICAubGlzdEZvcm1hdHRlcih7IHR5cGU6IFwiY29uanVuY3Rpb25cIiwgc3R5bGU6IG9wdHMubGlzdFN0eWxlIHx8IFwibmFycm93XCIsIC4uLm9wdHMgfSlcbiAgICAgIC5mb3JtYXQobCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIEphdmFTY3JpcHQgb2JqZWN0IHdpdGggdGhpcyBEdXJhdGlvbidzIHZhbHVlcy5cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IHllYXJzOiAxLCBkYXlzOiA2LCBzZWNvbmRzOiAyIH0pLnRvT2JqZWN0KCkgLy89PiB7IHllYXJzOiAxLCBkYXlzOiA2LCBzZWNvbmRzOiAyIH1cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgdG9PYmplY3QoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB7fTtcbiAgICByZXR1cm4geyAuLi50aGlzLnZhbHVlcyB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIER1cmF0aW9uLlxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI0R1cmF0aW9uc1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgeWVhcnM6IDMsIHNlY29uZHM6IDQ1IH0pLnRvSVNPKCkgLy89PiAnUDNZVDQ1UydcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IG1vbnRoczogNCwgc2Vjb25kczogNDUgfSkudG9JU08oKSAvLz0+ICdQNE1UNDVTJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbW9udGhzOiA1IH0pLnRvSVNPKCkgLy89PiAnUDVNJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbWludXRlczogNSB9KS50b0lTTygpIC8vPT4gJ1BUNU0nXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBtaWxsaXNlY29uZHM6IDYgfSkudG9JU08oKSAvLz0+ICdQVDAuMDA2UydcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9JU08oKSB7XG4gICAgLy8gd2UgY291bGQgdXNlIHRoZSBmb3JtYXR0ZXIsIGJ1dCB0aGlzIGlzIGFuIGVhc2llciB3YXkgdG8gZ2V0IHRoZSBtaW5pbXVtIHN0cmluZ1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gbnVsbDtcblxuICAgIGxldCBzID0gXCJQXCI7XG4gICAgaWYgKHRoaXMueWVhcnMgIT09IDApIHMgKz0gdGhpcy55ZWFycyArIFwiWVwiO1xuICAgIGlmICh0aGlzLm1vbnRocyAhPT0gMCB8fCB0aGlzLnF1YXJ0ZXJzICE9PSAwKSBzICs9IHRoaXMubW9udGhzICsgdGhpcy5xdWFydGVycyAqIDMgKyBcIk1cIjtcbiAgICBpZiAodGhpcy53ZWVrcyAhPT0gMCkgcyArPSB0aGlzLndlZWtzICsgXCJXXCI7XG4gICAgaWYgKHRoaXMuZGF5cyAhPT0gMCkgcyArPSB0aGlzLmRheXMgKyBcIkRcIjtcbiAgICBpZiAodGhpcy5ob3VycyAhPT0gMCB8fCB0aGlzLm1pbnV0ZXMgIT09IDAgfHwgdGhpcy5zZWNvbmRzICE9PSAwIHx8IHRoaXMubWlsbGlzZWNvbmRzICE9PSAwKVxuICAgICAgcyArPSBcIlRcIjtcbiAgICBpZiAodGhpcy5ob3VycyAhPT0gMCkgcyArPSB0aGlzLmhvdXJzICsgXCJIXCI7XG4gICAgaWYgKHRoaXMubWludXRlcyAhPT0gMCkgcyArPSB0aGlzLm1pbnV0ZXMgKyBcIk1cIjtcbiAgICBpZiAodGhpcy5zZWNvbmRzICE9PSAwIHx8IHRoaXMubWlsbGlzZWNvbmRzICE9PSAwKVxuICAgICAgLy8gdGhpcyB3aWxsIGhhbmRsZSBcImZsb2F0aW5nIHBvaW50IG1hZG5lc3NcIiBieSByZW1vdmluZyBleHRyYSBkZWNpbWFsIHBsYWNlc1xuICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTg4MDA0L2lzLWZsb2F0aW5nLXBvaW50LW1hdGgtYnJva2VuXG4gICAgICBzICs9IHJvdW5kVG8odGhpcy5zZWNvbmRzICsgdGhpcy5taWxsaXNlY29uZHMgLyAxMDAwLCAzKSArIFwiU1wiO1xuICAgIGlmIChzID09PSBcIlBcIikgcyArPSBcIlQwU1wiO1xuICAgIHJldHVybiBzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIER1cmF0aW9uLCBmb3JtYXR0ZWQgYXMgYSB0aW1lIG9mIGRheS5cbiAgICogTm90ZSB0aGF0IHRoaXMgd2lsbCByZXR1cm4gbnVsbCBpZiB0aGUgZHVyYXRpb24gaXMgaW52YWxpZCwgbmVnYXRpdmUsIG9yIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiAyNCBob3Vycy5cbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSNUaW1lc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zdXBwcmVzc01pbGxpc2Vjb25kcz1mYWxzZV0gLSBleGNsdWRlIG1pbGxpc2Vjb25kcyBmcm9tIHRoZSBmb3JtYXQgaWYgdGhleSdyZSAwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc3VwcHJlc3NTZWNvbmRzPWZhbHNlXSAtIGV4Y2x1ZGUgc2Vjb25kcyBmcm9tIHRoZSBmb3JtYXQgaWYgdGhleSdyZSAwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZVByZWZpeD1mYWxzZV0gLSBpbmNsdWRlIHRoZSBgVGAgcHJlZml4XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5mb3JtYXQ9J2V4dGVuZGVkJ10gLSBjaG9vc2UgYmV0d2VlbiB0aGUgYmFzaWMgYW5kIGV4dGVuZGVkIGZvcm1hdFxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDExIH0pLnRvSVNPVGltZSgpIC8vPT4gJzExOjAwOjAwLjAwMCdcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxMSB9KS50b0lTT1RpbWUoeyBzdXBwcmVzc01pbGxpc2Vjb25kczogdHJ1ZSB9KSAvLz0+ICcxMTowMDowMCdcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxMSB9KS50b0lTT1RpbWUoeyBzdXBwcmVzc1NlY29uZHM6IHRydWUgfSkgLy89PiAnMTE6MDAnXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMTEgfSkudG9JU09UaW1lKHsgaW5jbHVkZVByZWZpeDogdHJ1ZSB9KSAvLz0+ICdUMTE6MDA6MDAuMDAwJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDExIH0pLnRvSVNPVGltZSh7IGZvcm1hdDogJ2Jhc2ljJyB9KSAvLz0+ICcxMTAwMDAuMDAwJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0lTT1RpbWUob3B0cyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBudWxsO1xuXG4gICAgY29uc3QgbWlsbGlzID0gdGhpcy50b01pbGxpcygpO1xuICAgIGlmIChtaWxsaXMgPCAwIHx8IG1pbGxpcyA+PSA4NjQwMDAwMCkgcmV0dXJuIG51bGw7XG5cbiAgICBvcHRzID0ge1xuICAgICAgc3VwcHJlc3NNaWxsaXNlY29uZHM6IGZhbHNlLFxuICAgICAgc3VwcHJlc3NTZWNvbmRzOiBmYWxzZSxcbiAgICAgIGluY2x1ZGVQcmVmaXg6IGZhbHNlLFxuICAgICAgZm9ybWF0OiBcImV4dGVuZGVkXCIsXG4gICAgICAuLi5vcHRzLFxuICAgICAgaW5jbHVkZU9mZnNldDogZmFsc2UsXG4gICAgfTtcblxuICAgIGNvbnN0IGRhdGVUaW1lID0gRGF0ZVRpbWUuZnJvbU1pbGxpcyhtaWxsaXMsIHsgem9uZTogXCJVVENcIiB9KTtcbiAgICByZXR1cm4gZGF0ZVRpbWUudG9JU09UaW1lKG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEdXJhdGlvbiBhcHByb3ByaWF0ZSBmb3IgdXNlIGluIEpTT04uXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b0lTTygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEdXJhdGlvbiBhcHByb3ByaWF0ZSBmb3IgdXNlIGluIGRlYnVnZ2luZy5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9JU08oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG1pbGxpc2Vjb25kcyB2YWx1ZSBvZiB0aGlzIER1cmF0aW9uLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICB0b01pbGxpcygpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIE5hTjtcblxuICAgIHJldHVybiBkdXJhdGlvblRvTWlsbGlzKHRoaXMubWF0cml4LCB0aGlzLnZhbHVlcyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBtaWxsaXNlY29uZHMgdmFsdWUgb2YgdGhpcyBEdXJhdGlvbi4gQWxpYXMgb2Yge0BsaW5rIHRvTWlsbGlzfVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICB2YWx1ZU9mKCkge1xuICAgIHJldHVybiB0aGlzLnRvTWlsbGlzKCk7XG4gIH1cblxuICAvKipcbiAgICogTWFrZSB0aGlzIER1cmF0aW9uIGxvbmdlciBieSB0aGUgc3BlY2lmaWVkIGFtb3VudC4gUmV0dXJuIGEgbmV3bHktY29uc3RydWN0ZWQgRHVyYXRpb24uXG4gICAqIEBwYXJhbSB7RHVyYXRpb258T2JqZWN0fG51bWJlcn0gZHVyYXRpb24gLSBUaGUgYW1vdW50IHRvIGFkZC4gRWl0aGVyIGEgTHV4b24gRHVyYXRpb24sIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgdGhlIG9iamVjdCBhcmd1bWVudCB0byBEdXJhdGlvbi5mcm9tT2JqZWN0KClcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBwbHVzKGR1cmF0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuXG4gICAgY29uc3QgZHVyID0gRHVyYXRpb24uZnJvbUR1cmF0aW9uTGlrZShkdXJhdGlvbiksXG4gICAgICByZXN1bHQgPSB7fTtcblxuICAgIGZvciAoY29uc3QgayBvZiBvcmRlcmVkVW5pdHMpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eShkdXIudmFsdWVzLCBrKSB8fCBoYXNPd25Qcm9wZXJ0eSh0aGlzLnZhbHVlcywgaykpIHtcbiAgICAgICAgcmVzdWx0W2tdID0gZHVyLmdldChrKSArIHRoaXMuZ2V0KGspO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHZhbHVlczogcmVzdWx0IH0sIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2UgdGhpcyBEdXJhdGlvbiBzaG9ydGVyIGJ5IHRoZSBzcGVjaWZpZWQgYW1vdW50LiBSZXR1cm4gYSBuZXdseS1jb25zdHJ1Y3RlZCBEdXJhdGlvbi5cbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSBhbW91bnQgdG8gc3VidHJhY3QuIEVpdGhlciBhIEx1eG9uIER1cmF0aW9uLCBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIHRoZSBvYmplY3QgYXJndW1lbnQgdG8gRHVyYXRpb24uZnJvbU9iamVjdCgpXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgbWludXMoZHVyYXRpb24pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG5cbiAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tRHVyYXRpb25MaWtlKGR1cmF0aW9uKTtcbiAgICByZXR1cm4gdGhpcy5wbHVzKGR1ci5uZWdhdGUoKSk7XG4gIH1cblxuICAvKipcbiAgICogU2NhbGUgdGhpcyBEdXJhdGlvbiBieSB0aGUgc3BlY2lmaWVkIGFtb3VudC4gUmV0dXJuIGEgbmV3bHktY29uc3RydWN0ZWQgRHVyYXRpb24uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggdW5pdC4gQXJpdHkgaXMgMSBvciAyOiB0aGUgdmFsdWUgb2YgdGhlIHVuaXQgYW5kLCBvcHRpb25hbGx5LCB0aGUgdW5pdCBuYW1lLiBNdXN0IHJldHVybiBhIG51bWJlci5cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxLCBtaW51dGVzOiAzMCB9KS5tYXBVbml0cyh4ID0+IHggKiAyKSAvLz0+IHsgaG91cnM6IDIsIG1pbnV0ZXM6IDYwIH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxLCBtaW51dGVzOiAzMCB9KS5tYXBVbml0cygoeCwgdSkgPT4gdSA9PT0gXCJob3Vyc1wiID8geCAqIDIgOiB4KSAvLz0+IHsgaG91cnM6IDIsIG1pbnV0ZXM6IDMwIH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBtYXBVbml0cyhmbikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGsgb2YgT2JqZWN0LmtleXModGhpcy52YWx1ZXMpKSB7XG4gICAgICByZXN1bHRba10gPSBhc051bWJlcihmbih0aGlzLnZhbHVlc1trXSwgaykpO1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyB2YWx1ZXM6IHJlc3VsdCB9LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbHVlIG9mIHVuaXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1bml0IC0gYSB1bml0IHN1Y2ggYXMgJ21pbnV0ZScgb3IgJ2RheSdcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7eWVhcnM6IDIsIGRheXM6IDN9KS5nZXQoJ3llYXJzJykgLy89PiAyXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3Qoe3llYXJzOiAyLCBkYXlzOiAzfSkuZ2V0KCdtb250aHMnKSAvLz0+IDBcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7eWVhcnM6IDIsIGRheXM6IDN9KS5nZXQoJ2RheXMnKSAvLz0+IDNcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0KHVuaXQpIHtcbiAgICByZXR1cm4gdGhpc1tEdXJhdGlvbi5ub3JtYWxpemVVbml0KHVuaXQpXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSB2YWx1ZXMgb2Ygc3BlY2lmaWVkIHVuaXRzLiBSZXR1cm4gYSBuZXdseS1jb25zdHJ1Y3RlZCBEdXJhdGlvbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlcyAtIGEgbWFwcGluZyBvZiB1bml0cyB0byBudW1iZXJzXG4gICAqIEBleGFtcGxlIGR1ci5zZXQoeyB5ZWFyczogMjAxNyB9KVxuICAgKiBAZXhhbXBsZSBkdXIuc2V0KHsgaG91cnM6IDgsIG1pbnV0ZXM6IDMwIH0pXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgc2V0KHZhbHVlcykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcblxuICAgIGNvbnN0IG1peGVkID0geyAuLi50aGlzLnZhbHVlcywgLi4ubm9ybWFsaXplT2JqZWN0KHZhbHVlcywgRHVyYXRpb24ubm9ybWFsaXplVW5pdCkgfTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyB2YWx1ZXM6IG1peGVkIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhlIGxvY2FsZSBhbmQvb3IgbnVtYmVyaW5nU3lzdGVtLiAgUmV0dXJucyBhIG5ld2x5LWNvbnN0cnVjdGVkIER1cmF0aW9uLlxuICAgKiBAZXhhbXBsZSBkdXIucmVjb25maWd1cmUoeyBsb2NhbGU6ICdlbi1HQicgfSlcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICByZWNvbmZpZ3VyZSh7IGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBjb252ZXJzaW9uQWNjdXJhY3ksIG1hdHJpeCB9ID0ge30pIHtcbiAgICBjb25zdCBsb2MgPSB0aGlzLmxvYy5jbG9uZSh7IGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtIH0pO1xuICAgIGNvbnN0IG9wdHMgPSB7IGxvYywgbWF0cml4LCBjb252ZXJzaW9uQWNjdXJhY3kgfTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGR1cmF0aW9uIGluIHRoZSBzcGVjaWZpZWQgdW5pdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSBhIHVuaXQgc3VjaCBhcyAnbWludXRlcycgb3IgJ2RheXMnXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3Qoe3llYXJzOiAxfSkuYXMoJ2RheXMnKSAvLz0+IDM2NVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHt5ZWFyczogMX0pLmFzKCdtb250aHMnKSAvLz0+IDEyXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3Qoe2hvdXJzOiA2MH0pLmFzKCdkYXlzJykgLy89PiAyLjVcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgYXModW5pdCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnNoaWZ0VG8odW5pdCkuZ2V0KHVuaXQpIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZHVjZSB0aGlzIER1cmF0aW9uIHRvIGl0cyBjYW5vbmljYWwgcmVwcmVzZW50YXRpb24gaW4gaXRzIGN1cnJlbnQgdW5pdHMuXG4gICAqIEFzc3VtaW5nIHRoZSBvdmVyYWxsIHZhbHVlIG9mIHRoZSBEdXJhdGlvbiBpcyBwb3NpdGl2ZSwgdGhpcyBtZWFuczpcbiAgICogLSBleGNlc3NpdmUgdmFsdWVzIGZvciBsb3dlci1vcmRlciB1bml0cyBhcmUgY29udmVydGVkIHRvIGhpZ2hlci1vcmRlciB1bml0cyAoaWYgcG9zc2libGUsIHNlZSBmaXJzdCBhbmQgc2Vjb25kIGV4YW1wbGUpXG4gICAqIC0gbmVnYXRpdmUgbG93ZXItb3JkZXIgdW5pdHMgYXJlIGNvbnZlcnRlZCB0byBoaWdoZXIgb3JkZXIgdW5pdHMgKHRoZXJlIG11c3QgYmUgc3VjaCBhIGhpZ2hlciBvcmRlciB1bml0LCBvdGhlcndpc2VcbiAgICogICB0aGUgb3ZlcmFsbCB2YWx1ZSB3b3VsZCBiZSBuZWdhdGl2ZSwgc2VlIHNlY29uZCBleGFtcGxlKVxuICAgKiAtIGZyYWN0aW9uYWwgdmFsdWVzIGZvciBoaWdoZXItb3JkZXIgdW5pdHMgYXJlIGNvbnZlcnRlZCB0byBsb3dlci1vcmRlciB1bml0cyAoaWYgcG9zc2libGUsIHNlZSBmb3VydGggZXhhbXBsZSlcbiAgICpcbiAgICogSWYgdGhlIG92ZXJhbGwgdmFsdWUgaXMgbmVnYXRpdmUsIHRoZSByZXN1bHQgb2YgdGhpcyBtZXRob2QgaXMgZXF1aXZhbGVudCB0byBgdGhpcy5uZWdhdGUoKS5ub3JtYWxpemUoKS5uZWdhdGUoKWAuXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMiwgZGF5czogNTAwMCB9KS5ub3JtYWxpemUoKS50b09iamVjdCgpIC8vPT4geyB5ZWFyczogMTUsIGRheXM6IDI1NSB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBkYXlzOiA1MDAwIH0pLm5vcm1hbGl6ZSgpLnRvT2JqZWN0KCkgLy89PiB7IGRheXM6IDUwMDAgfVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDEyLCBtaW51dGVzOiAtNDUgfSkubm9ybWFsaXplKCkudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDExLCBtaW51dGVzOiAxNSB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMi41LCBkYXlzOiAwLCBob3VyczogMCB9KS5ub3JtYWxpemUoKS50b09iamVjdCgpIC8vPT4geyB5ZWFyczogMiwgZGF5czogMTgyLCBob3VyczogMTIgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIG5vcm1hbGl6ZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgdmFscyA9IHRoaXMudG9PYmplY3QoKTtcbiAgICBub3JtYWxpemVWYWx1ZXModGhpcy5tYXRyaXgsIHZhbHMpO1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHZhbHVlczogdmFscyB9LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNjYWxlIHVuaXRzIHRvIGl0cyBsYXJnZXN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBtaWxsaXNlY29uZHM6IDkwMDAwIH0pLnJlc2NhbGUoKS50b09iamVjdCgpIC8vPT4geyBtaW51dGVzOiAxLCBzZWNvbmRzOiAzMCB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgcmVzY2FsZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgdmFscyA9IHJlbW92ZVplcm9lcyh0aGlzLm5vcm1hbGl6ZSgpLnNoaWZ0VG9BbGwoKS50b09iamVjdCgpKTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyB2YWx1ZXM6IHZhbHMgfSwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCB0aGlzIER1cmF0aW9uIGludG8gaXRzIHJlcHJlc2VudGF0aW9uIGluIGEgZGlmZmVyZW50IHNldCBvZiB1bml0cy5cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxLCBzZWNvbmRzOiAzMCB9KS5zaGlmdFRvKCdtaW51dGVzJywgJ21pbGxpc2Vjb25kcycpLnRvT2JqZWN0KCkgLy89PiB7IG1pbnV0ZXM6IDYwLCBtaWxsaXNlY29uZHM6IDMwMDAwIH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzaGlmdFRvKC4uLnVuaXRzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKHVuaXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdW5pdHMgPSB1bml0cy5tYXAoKHUpID0+IER1cmF0aW9uLm5vcm1hbGl6ZVVuaXQodSkpO1xuXG4gICAgY29uc3QgYnVpbHQgPSB7fSxcbiAgICAgIGFjY3VtdWxhdGVkID0ge30sXG4gICAgICB2YWxzID0gdGhpcy50b09iamVjdCgpO1xuICAgIGxldCBsYXN0VW5pdDtcblxuICAgIGZvciAoY29uc3QgayBvZiBvcmRlcmVkVW5pdHMpIHtcbiAgICAgIGlmICh1bml0cy5pbmRleE9mKGspID49IDApIHtcbiAgICAgICAgbGFzdFVuaXQgPSBrO1xuXG4gICAgICAgIGxldCBvd24gPSAwO1xuXG4gICAgICAgIC8vIGFueXRoaW5nIHdlIGhhdmVuJ3QgYm9pbGVkIGRvd24geWV0IHNob3VsZCBnZXQgYm9pbGVkIHRvIHRoaXMgdW5pdFxuICAgICAgICBmb3IgKGNvbnN0IGFrIGluIGFjY3VtdWxhdGVkKSB7XG4gICAgICAgICAgb3duICs9IHRoaXMubWF0cml4W2FrXVtrXSAqIGFjY3VtdWxhdGVkW2FrXTtcbiAgICAgICAgICBhY2N1bXVsYXRlZFtha10gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGx1cyBhbnl0aGluZyB0aGF0J3MgYWxyZWFkeSBpbiB0aGlzIHVuaXRcbiAgICAgICAgaWYgKGlzTnVtYmVyKHZhbHNba10pKSB7XG4gICAgICAgICAgb3duICs9IHZhbHNba107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvbmx5IGtlZXAgdGhlIGludGVnZXIgcGFydCBmb3Igbm93IGluIHRoZSBob3BlcyBvZiBwdXR0aW5nIGFueSBkZWNpbWFsIHBhcnRcbiAgICAgICAgLy8gaW50byBhIHNtYWxsZXIgdW5pdCBsYXRlclxuICAgICAgICBjb25zdCBpID0gTWF0aC50cnVuYyhvd24pO1xuICAgICAgICBidWlsdFtrXSA9IGk7XG4gICAgICAgIGFjY3VtdWxhdGVkW2tdID0gKG93biAqIDEwMDAgLSBpICogMTAwMCkgLyAxMDAwO1xuXG4gICAgICAgIC8vIG90aGVyd2lzZSwga2VlcCBpdCBpbiB0aGUgd2luZ3MgdG8gYm9pbCBpdCBsYXRlclxuICAgICAgfSBlbHNlIGlmIChpc051bWJlcih2YWxzW2tdKSkge1xuICAgICAgICBhY2N1bXVsYXRlZFtrXSA9IHZhbHNba107XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYW55dGhpbmcgbGVmdG92ZXIgYmVjb21lcyB0aGUgZGVjaW1hbCBmb3IgdGhlIGxhc3QgdW5pdFxuICAgIC8vIGxhc3RVbml0IG11c3QgYmUgZGVmaW5lZCBzaW5jZSB1bml0cyBpcyBub3QgZW1wdHlcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhY2N1bXVsYXRlZCkge1xuICAgICAgaWYgKGFjY3VtdWxhdGVkW2tleV0gIT09IDApIHtcbiAgICAgICAgYnVpbHRbbGFzdFVuaXRdICs9XG4gICAgICAgICAga2V5ID09PSBsYXN0VW5pdCA/IGFjY3VtdWxhdGVkW2tleV0gOiBhY2N1bXVsYXRlZFtrZXldIC8gdGhpcy5tYXRyaXhbbGFzdFVuaXRdW2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgbm9ybWFsaXplVmFsdWVzKHRoaXMubWF0cml4LCBidWlsdCk7XG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIHsgdmFsdWVzOiBidWlsdCB9LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaGlmdCB0aGlzIER1cmF0aW9uIHRvIGFsbCBhdmFpbGFibGUgdW5pdHMuXG4gICAqIFNhbWUgYXMgc2hpZnRUbyhcInllYXJzXCIsIFwibW9udGhzXCIsIFwid2Vla3NcIiwgXCJkYXlzXCIsIFwiaG91cnNcIiwgXCJtaW51dGVzXCIsIFwic2Vjb25kc1wiLCBcIm1pbGxpc2Vjb25kc1wiKVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHNoaWZ0VG9BbGwoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIHJldHVybiB0aGlzLnNoaWZ0VG8oXG4gICAgICBcInllYXJzXCIsXG4gICAgICBcIm1vbnRoc1wiLFxuICAgICAgXCJ3ZWVrc1wiLFxuICAgICAgXCJkYXlzXCIsXG4gICAgICBcImhvdXJzXCIsXG4gICAgICBcIm1pbnV0ZXNcIixcbiAgICAgIFwic2Vjb25kc1wiLFxuICAgICAgXCJtaWxsaXNlY29uZHNcIlxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBuZWdhdGl2ZSBvZiB0aGlzIER1cmF0aW9uLlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDEsIHNlY29uZHM6IDMwIH0pLm5lZ2F0ZSgpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAtMSwgc2Vjb25kczogLTMwIH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBuZWdhdGUoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IG5lZ2F0ZWQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGsgb2YgT2JqZWN0LmtleXModGhpcy52YWx1ZXMpKSB7XG4gICAgICBuZWdhdGVkW2tdID0gdGhpcy52YWx1ZXNba10gPT09IDAgPyAwIDogLXRoaXMudmFsdWVzW2tdO1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyB2YWx1ZXM6IG5lZ2F0ZWQgfSwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB5ZWFycy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB5ZWFycygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMueWVhcnMgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHF1YXJ0ZXJzLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHF1YXJ0ZXJzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy5xdWFydGVycyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbW9udGhzLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1vbnRocygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMubW9udGhzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB3ZWVrc1xuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdlZWtzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy53ZWVrcyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGF5cy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBkYXlzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy5kYXlzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBob3Vycy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBob3VycygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMuaG91cnMgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1pbnV0ZXMuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbWludXRlcygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMubWludXRlcyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2Vjb25kcy5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHNlY29uZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLnNlY29uZHMgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1pbGxpc2Vjb25kcy5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1pbGxpc2Vjb25kcygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMubWlsbGlzZWNvbmRzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBEdXJhdGlvbiBpcyBpbnZhbGlkLiBJbnZhbGlkIGR1cmF0aW9ucyBhcmUgcmV0dXJuZWQgYnkgZGlmZiBvcGVyYXRpb25zXG4gICAqIG9uIGludmFsaWQgRGF0ZVRpbWVzIG9yIEludGVydmFscy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiB0aGlzLmludmFsaWQgPT09IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBlcnJvciBjb2RlIGlmIHRoaXMgRHVyYXRpb24gYmVjYW1lIGludmFsaWQsIG9yIG51bGwgaWYgdGhlIER1cmF0aW9uIGlzIHZhbGlkXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldCBpbnZhbGlkUmVhc29uKCkge1xuICAgIHJldHVybiB0aGlzLmludmFsaWQgPyB0aGlzLmludmFsaWQucmVhc29uIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGV4cGxhbmF0aW9uIG9mIHdoeSB0aGlzIER1cmF0aW9uIGJlY2FtZSBpbnZhbGlkLCBvciBudWxsIGlmIHRoZSBEdXJhdGlvbiBpcyB2YWxpZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGludmFsaWRFeHBsYW5hdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZhbGlkID8gdGhpcy5pbnZhbGlkLmV4cGxhbmF0aW9uIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBFcXVhbGl0eSBjaGVja1xuICAgKiBUd28gRHVyYXRpb25zIGFyZSBlcXVhbCBpZmYgdGhleSBoYXZlIHRoZSBzYW1lIHVuaXRzIGFuZCB0aGUgc2FtZSB2YWx1ZXMgZm9yIGVhY2ggdW5pdC5cbiAgICogQHBhcmFtIHtEdXJhdGlvbn0gb3RoZXJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGVxdWFscyhvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkIHx8ICFvdGhlci5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmxvYy5lcXVhbHMob3RoZXIubG9jKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVxKHYxLCB2Mikge1xuICAgICAgLy8gQ29uc2lkZXIgMCBhbmQgdW5kZWZpbmVkIGFzIGVxdWFsXG4gICAgICBpZiAodjEgPT09IHVuZGVmaW5lZCB8fCB2MSA9PT0gMCkgcmV0dXJuIHYyID09PSB1bmRlZmluZWQgfHwgdjIgPT09IDA7XG4gICAgICByZXR1cm4gdjEgPT09IHYyO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgdSBvZiBvcmRlcmVkVW5pdHMpIHtcbiAgICAgIGlmICghZXEodGhpcy52YWx1ZXNbdV0sIG90aGVyLnZhbHVlc1t1XSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuIiwgImltcG9ydCBEYXRlVGltZSwgeyBmcmllbmRseURhdGVUaW1lIH0gZnJvbSBcIi4vZGF0ZXRpbWUuanNcIjtcbmltcG9ydCBEdXJhdGlvbiBmcm9tIFwiLi9kdXJhdGlvbi5qc1wiO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gXCIuL3NldHRpbmdzLmpzXCI7XG5pbXBvcnQgeyBJbnZhbGlkQXJndW1lbnRFcnJvciwgSW52YWxpZEludGVydmFsRXJyb3IgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmltcG9ydCBJbnZhbGlkIGZyb20gXCIuL2ltcGwvaW52YWxpZC5qc1wiO1xuaW1wb3J0IEZvcm1hdHRlciBmcm9tIFwiLi9pbXBsL2Zvcm1hdHRlci5qc1wiO1xuaW1wb3J0ICogYXMgRm9ybWF0cyBmcm9tIFwiLi9pbXBsL2Zvcm1hdHMuanNcIjtcblxuY29uc3QgSU5WQUxJRCA9IFwiSW52YWxpZCBJbnRlcnZhbFwiO1xuXG4vLyBjaGVja3MgaWYgdGhlIHN0YXJ0IGlzIGVxdWFsIHRvIG9yIGJlZm9yZSB0aGUgZW5kXG5mdW5jdGlvbiB2YWxpZGF0ZVN0YXJ0RW5kKHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCB8fCAhc3RhcnQuaXNWYWxpZCkge1xuICAgIHJldHVybiBJbnRlcnZhbC5pbnZhbGlkKFwibWlzc2luZyBvciBpbnZhbGlkIHN0YXJ0XCIpO1xuICB9IGVsc2UgaWYgKCFlbmQgfHwgIWVuZC5pc1ZhbGlkKSB7XG4gICAgcmV0dXJuIEludGVydmFsLmludmFsaWQoXCJtaXNzaW5nIG9yIGludmFsaWQgZW5kXCIpO1xuICB9IGVsc2UgaWYgKGVuZCA8IHN0YXJ0KSB7XG4gICAgcmV0dXJuIEludGVydmFsLmludmFsaWQoXG4gICAgICBcImVuZCBiZWZvcmUgc3RhcnRcIixcbiAgICAgIGBUaGUgZW5kIG9mIGFuIGludGVydmFsIG11c3QgYmUgYWZ0ZXIgaXRzIHN0YXJ0LCBidXQgeW91IGhhZCBzdGFydD0ke3N0YXJ0LnRvSVNPKCl9IGFuZCBlbmQ9JHtlbmQudG9JU08oKX1gXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEFuIEludGVydmFsIG9iamVjdCByZXByZXNlbnRzIGEgaGFsZi1vcGVuIGludGVydmFsIG9mIHRpbWUsIHdoZXJlIGVhY2ggZW5kcG9pbnQgaXMgYSB7QGxpbmsgRGF0ZVRpbWV9LiBDb25jZXB0dWFsbHksIGl0J3MgYSBjb250YWluZXIgZm9yIHRob3NlIHR3byBlbmRwb2ludHMsIGFjY29tcGFuaWVkIGJ5IG1ldGhvZHMgZm9yIGNyZWF0aW5nLCBwYXJzaW5nLCBpbnRlcnJvZ2F0aW5nLCBjb21wYXJpbmcsIHRyYW5zZm9ybWluZywgYW5kIGZvcm1hdHRpbmcgdGhlbS5cbiAqXG4gKiBIZXJlIGlzIGEgYnJpZWYgb3ZlcnZpZXcgb2YgdGhlIG1vc3QgY29tbW9ubHkgdXNlZCBtZXRob2RzIGFuZCBnZXR0ZXJzIGluIEludGVydmFsOlxuICpcbiAqICogKipDcmVhdGlvbioqIFRvIGNyZWF0ZSBhbiBJbnRlcnZhbCwgdXNlIHtAbGluayBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzfSwge0BsaW5rIEludGVydmFsLmFmdGVyfSwge0BsaW5rIEludGVydmFsLmJlZm9yZX0sIG9yIHtAbGluayBJbnRlcnZhbC5mcm9tSVNPfS5cbiAqICogKipBY2Nlc3NvcnMqKiBVc2Uge0BsaW5rIEludGVydmFsI3N0YXJ0fSBhbmQge0BsaW5rIEludGVydmFsI2VuZH0gdG8gZ2V0IHRoZSBzdGFydCBhbmQgZW5kLlxuICogKiAqKkludGVycm9nYXRpb24qKiBUbyBhbmFseXplIHRoZSBJbnRlcnZhbCwgdXNlIHtAbGluayBJbnRlcnZhbCNjb3VudH0sIHtAbGluayBJbnRlcnZhbCNsZW5ndGh9LCB7QGxpbmsgSW50ZXJ2YWwjaGFzU2FtZX0sIHtAbGluayBJbnRlcnZhbCNjb250YWluc30sIHtAbGluayBJbnRlcnZhbCNpc0FmdGVyfSwgb3Ige0BsaW5rIEludGVydmFsI2lzQmVmb3JlfS5cbiAqICogKipUcmFuc2Zvcm1hdGlvbioqIFRvIGNyZWF0ZSBvdGhlciBJbnRlcnZhbHMgb3V0IG9mIHRoaXMgb25lLCB1c2Uge0BsaW5rIEludGVydmFsI3NldH0sIHtAbGluayBJbnRlcnZhbCNzcGxpdEF0fSwge0BsaW5rIEludGVydmFsI3NwbGl0Qnl9LCB7QGxpbmsgSW50ZXJ2YWwjZGl2aWRlRXF1YWxseX0sIHtAbGluayBJbnRlcnZhbC5tZXJnZX0sIHtAbGluayBJbnRlcnZhbC54b3J9LCB7QGxpbmsgSW50ZXJ2YWwjdW5pb259LCB7QGxpbmsgSW50ZXJ2YWwjaW50ZXJzZWN0aW9ufSwgb3Ige0BsaW5rIEludGVydmFsI2RpZmZlcmVuY2V9LlxuICogKiAqKkNvbXBhcmlzb24qKiBUbyBjb21wYXJlIHRoaXMgSW50ZXJ2YWwgdG8gYW5vdGhlciBvbmUsIHVzZSB7QGxpbmsgSW50ZXJ2YWwjZXF1YWxzfSwge0BsaW5rIEludGVydmFsI292ZXJsYXBzfSwge0BsaW5rIEludGVydmFsI2FidXRzU3RhcnR9LCB7QGxpbmsgSW50ZXJ2YWwjYWJ1dHNFbmR9LCB7QGxpbmsgSW50ZXJ2YWwjZW5ndWxmc31cbiAqICogKipPdXRwdXQqKiBUbyBjb252ZXJ0IHRoZSBJbnRlcnZhbCBpbnRvIG90aGVyIHJlcHJlc2VudGF0aW9ucywgc2VlIHtAbGluayBJbnRlcnZhbCN0b1N0cmluZ30sIHtAbGluayBJbnRlcnZhbCN0b0xvY2FsZVN0cmluZ30sIHtAbGluayBJbnRlcnZhbCN0b0lTT30sIHtAbGluayBJbnRlcnZhbCN0b0lTT0RhdGV9LCB7QGxpbmsgSW50ZXJ2YWwjdG9JU09UaW1lfSwge0BsaW5rIEludGVydmFsI3RvRm9ybWF0fSwgYW5kIHtAbGluayBJbnRlcnZhbCN0b0R1cmF0aW9ufS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW50ZXJ2YWwge1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucyA9IGNvbmZpZy5zdGFydDtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmUgPSBjb25maWcuZW5kO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaW52YWxpZCA9IGNvbmZpZy5pbnZhbGlkIHx8IG51bGw7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5pc0x1eG9uSW50ZXJ2YWwgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnZhbGlkIEludGVydmFsLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uIC0gc2ltcGxlIHN0cmluZyBvZiB3aHkgdGhpcyBJbnRlcnZhbCBpcyBpbnZhbGlkLiBTaG91bGQgbm90IGNvbnRhaW4gcGFyYW1ldGVycyBvciBhbnl0aGluZyBlbHNlIGRhdGEtZGVwZW5kZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZXhwbGFuYXRpb249bnVsbF0gLSBsb25nZXIgZXhwbGFuYXRpb24sIG1heSBpbmNsdWRlIHBhcmFtZXRlcnMgYW5kIG90aGVyIHVzZWZ1bCBkZWJ1Z2dpbmcgaW5mb3JtYXRpb25cbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICBzdGF0aWMgaW52YWxpZChyZWFzb24sIGV4cGxhbmF0aW9uID0gbnVsbCkge1xuICAgIGlmICghcmVhc29uKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJuZWVkIHRvIHNwZWNpZnkgYSByZWFzb24gdGhlIEludGVydmFsIGlzIGludmFsaWRcIik7XG4gICAgfVxuXG4gICAgY29uc3QgaW52YWxpZCA9IHJlYXNvbiBpbnN0YW5jZW9mIEludmFsaWQgPyByZWFzb24gOiBuZXcgSW52YWxpZChyZWFzb24sIGV4cGxhbmF0aW9uKTtcblxuICAgIGlmIChTZXR0aW5ncy50aHJvd09uSW52YWxpZCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRJbnRlcnZhbEVycm9yKGludmFsaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IEludGVydmFsKHsgaW52YWxpZCB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIEludGVydmFsIGZyb20gYSBzdGFydCBEYXRlVGltZSBhbmQgYW4gZW5kIERhdGVUaW1lLiBJbmNsdXNpdmUgb2YgdGhlIHN0YXJ0IGJ1dCBub3QgdGhlIGVuZC5cbiAgICogQHBhcmFtIHtEYXRlVGltZXxEYXRlfE9iamVjdH0gc3RhcnRcbiAgICogQHBhcmFtIHtEYXRlVGltZXxEYXRlfE9iamVjdH0gZW5kXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgc3RhdGljIGZyb21EYXRlVGltZXMoc3RhcnQsIGVuZCkge1xuICAgIGNvbnN0IGJ1aWx0U3RhcnQgPSBmcmllbmRseURhdGVUaW1lKHN0YXJ0KSxcbiAgICAgIGJ1aWx0RW5kID0gZnJpZW5kbHlEYXRlVGltZShlbmQpO1xuXG4gICAgY29uc3QgdmFsaWRhdGVFcnJvciA9IHZhbGlkYXRlU3RhcnRFbmQoYnVpbHRTdGFydCwgYnVpbHRFbmQpO1xuXG4gICAgaWYgKHZhbGlkYXRlRXJyb3IgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5ldyBJbnRlcnZhbCh7XG4gICAgICAgIHN0YXJ0OiBidWlsdFN0YXJ0LFxuICAgICAgICBlbmQ6IGJ1aWx0RW5kLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2YWxpZGF0ZUVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gSW50ZXJ2YWwgZnJvbSBhIHN0YXJ0IERhdGVUaW1lIGFuZCBhIER1cmF0aW9uIHRvIGV4dGVuZCB0by5cbiAgICogQHBhcmFtIHtEYXRlVGltZXxEYXRlfE9iamVjdH0gc3RhcnRcbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIHRoZSBsZW5ndGggb2YgdGhlIEludGVydmFsLlxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIHN0YXRpYyBhZnRlcihzdGFydCwgZHVyYXRpb24pIHtcbiAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tRHVyYXRpb25MaWtlKGR1cmF0aW9uKSxcbiAgICAgIGR0ID0gZnJpZW5kbHlEYXRlVGltZShzdGFydCk7XG4gICAgcmV0dXJuIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQsIGR0LnBsdXMoZHVyKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIEludGVydmFsIGZyb20gYW4gZW5kIERhdGVUaW1lIGFuZCBhIER1cmF0aW9uIHRvIGV4dGVuZCBiYWNrd2FyZHMgdG8uXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV8RGF0ZXxPYmplY3R9IGVuZFxuICAgKiBAcGFyYW0ge0R1cmF0aW9ufE9iamVjdHxudW1iZXJ9IGR1cmF0aW9uIC0gdGhlIGxlbmd0aCBvZiB0aGUgSW50ZXJ2YWwuXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgc3RhdGljIGJlZm9yZShlbmQsIGR1cmF0aW9uKSB7XG4gICAgY29uc3QgZHVyID0gRHVyYXRpb24uZnJvbUR1cmF0aW9uTGlrZShkdXJhdGlvbiksXG4gICAgICBkdCA9IGZyaWVuZGx5RGF0ZVRpbWUoZW5kKTtcbiAgICByZXR1cm4gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdC5taW51cyhkdXIpLCBkdCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIEludGVydmFsIGZyb20gYW4gSVNPIDg2MDEgc3RyaW5nLlxuICAgKiBBY2NlcHRzIGA8c3RhcnQ+LzxlbmQ+YCwgYDxzdGFydD4vPGR1cmF0aW9uPmAsIGFuZCBgPGR1cmF0aW9uPi88ZW5kPmAgZm9ybWF0cy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0aGUgSVNPIHN0cmluZyB0byBwYXJzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIC0gb3B0aW9ucyB0byBwYXNzIHtAbGluayBEYXRlVGltZSNmcm9tSVNPfSBhbmQgb3B0aW9uYWxseSB7QGxpbmsgRHVyYXRpb24jZnJvbUlTT31cbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSNUaW1lX2ludGVydmFsc1xuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIHN0YXRpYyBmcm9tSVNPKHRleHQsIG9wdHMpIHtcbiAgICBjb25zdCBbcywgZV0gPSAodGV4dCB8fCBcIlwiKS5zcGxpdChcIi9cIiwgMik7XG4gICAgaWYgKHMgJiYgZSkge1xuICAgICAgbGV0IHN0YXJ0LCBzdGFydElzVmFsaWQ7XG4gICAgICB0cnkge1xuICAgICAgICBzdGFydCA9IERhdGVUaW1lLmZyb21JU08ocywgb3B0cyk7XG4gICAgICAgIHN0YXJ0SXNWYWxpZCA9IHN0YXJ0LmlzVmFsaWQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHN0YXJ0SXNWYWxpZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBsZXQgZW5kLCBlbmRJc1ZhbGlkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZW5kID0gRGF0ZVRpbWUuZnJvbUlTTyhlLCBvcHRzKTtcbiAgICAgICAgZW5kSXNWYWxpZCA9IGVuZC5pc1ZhbGlkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlbmRJc1ZhbGlkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGFydElzVmFsaWQgJiYgZW5kSXNWYWxpZCkge1xuICAgICAgICByZXR1cm4gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhzdGFydCwgZW5kKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXJ0SXNWYWxpZCkge1xuICAgICAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tSVNPKGUsIG9wdHMpO1xuICAgICAgICBpZiAoZHVyLmlzVmFsaWQpIHtcbiAgICAgICAgICByZXR1cm4gSW50ZXJ2YWwuYWZ0ZXIoc3RhcnQsIGR1cik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZW5kSXNWYWxpZCkge1xuICAgICAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tSVNPKHMsIG9wdHMpO1xuICAgICAgICBpZiAoZHVyLmlzVmFsaWQpIHtcbiAgICAgICAgICByZXR1cm4gSW50ZXJ2YWwuYmVmb3JlKGVuZCwgZHVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSW50ZXJ2YWwuaW52YWxpZChcInVucGFyc2FibGVcIiwgYHRoZSBpbnB1dCBcIiR7dGV4dH1cIiBjYW4ndCBiZSBwYXJzZWQgYXMgSVNPIDg2MDFgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBvYmplY3QgaXMgYW4gSW50ZXJ2YWwuIFdvcmtzIGFjcm9zcyBjb250ZXh0IGJvdW5kYXJpZXNcbiAgICogQHBhcmFtIHtvYmplY3R9IG9cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc0ludGVydmFsKG8pIHtcbiAgICByZXR1cm4gKG8gJiYgby5pc0x1eG9uSW50ZXJ2YWwpIHx8IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN0YXJ0IG9mIHRoZSBJbnRlcnZhbFxuICAgKiBAdHlwZSB7RGF0ZVRpbWV9XG4gICAqL1xuICBnZXQgc3RhcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMucyA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZW5kIG9mIHRoZSBJbnRlcnZhbFxuICAgKiBAdHlwZSB7RGF0ZVRpbWV9XG4gICAqL1xuICBnZXQgZW5kKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmUgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGlzIEludGVydmFsJ3MgZW5kIGlzIGF0IGxlYXN0IGl0cyBzdGFydCwgbWVhbmluZyB0aGF0IHRoZSBJbnRlcnZhbCBpc24ndCAnYmFja3dhcmRzJy5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZhbGlkUmVhc29uID09PSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZXJyb3IgY29kZSBpZiB0aGlzIEludGVydmFsIGlzIGludmFsaWQsIG9yIG51bGwgaWYgdGhlIEludGVydmFsIGlzIHZhbGlkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgaW52YWxpZFJlYXNvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZhbGlkID8gdGhpcy5pbnZhbGlkLnJlYXNvbiA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBleHBsYW5hdGlvbiBvZiB3aHkgdGhpcyBJbnRlcnZhbCBiZWNhbWUgaW52YWxpZCwgb3IgbnVsbCBpZiB0aGUgSW50ZXJ2YWwgaXMgdmFsaWRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBpbnZhbGlkRXhwbGFuYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZCA/IHRoaXMuaW52YWxpZC5leHBsYW5hdGlvbiA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSBJbnRlcnZhbCBpbiB0aGUgc3BlY2lmaWVkIHVuaXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1bml0IC0gdGhlIHVuaXQgKHN1Y2ggYXMgJ2hvdXJzJyBvciAnZGF5cycpIHRvIHJldHVybiB0aGUgbGVuZ3RoIGluLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBsZW5ndGgodW5pdCA9IFwibWlsbGlzZWNvbmRzXCIpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy50b0R1cmF0aW9uKC4uLlt1bml0XSkuZ2V0KHVuaXQpIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvdW50IG9mIG1pbnV0ZXMsIGhvdXJzLCBkYXlzLCBtb250aHMsIG9yIHllYXJzIGluY2x1ZGVkIGluIHRoZSBJbnRlcnZhbCwgZXZlbiBpbiBwYXJ0LlxuICAgKiBVbmxpa2Uge0BsaW5rIEludGVydmFsI2xlbmd0aH0gdGhpcyBjb3VudHMgc2VjdGlvbnMgb2YgdGhlIGNhbGVuZGFyLCBub3QgcGVyaW9kcyBvZiB0aW1lLCBlLmcuIHNwZWNpZnlpbmcgJ2RheSdcbiAgICogYXNrcyAnd2hhdCBkYXRlcyBhcmUgaW5jbHVkZWQgaW4gdGhpcyBpbnRlcnZhbD8nLCBub3QgJ2hvdyBtYW55IGRheXMgbG9uZyBpcyB0aGlzIGludGVydmFsPydcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt1bml0PSdtaWxsaXNlY29uZHMnXSAtIHRoZSB1bml0IG9mIHRpbWUgdG8gY291bnQuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGNvdW50KHVuaXQgPSBcIm1pbGxpc2Vjb25kc1wiKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBOYU47XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLnN0YXJ0LnN0YXJ0T2YodW5pdCksXG4gICAgICBlbmQgPSB0aGlzLmVuZC5zdGFydE9mKHVuaXQpO1xuICAgIHJldHVybiBNYXRoLmZsb29yKGVuZC5kaWZmKHN0YXJ0LCB1bml0KS5nZXQodW5pdCkpICsgKGVuZC52YWx1ZU9mKCkgIT09IHRoaXMuZW5kLnZhbHVlT2YoKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwncyBzdGFydCBhbmQgZW5kIGFyZSBib3RoIGluIHRoZSBzYW1lIHVuaXQgb2YgdGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIHRoZSB1bml0IG9mIHRpbWUgdG8gY2hlY2sgc2FtZW5lc3Mgb25cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc1NhbWUodW5pdCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmlzRW1wdHkoKSB8fCB0aGlzLmUubWludXMoMSkuaGFzU2FtZSh0aGlzLnMsIHVuaXQpIDogZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCBoYXMgdGhlIHNhbWUgc3RhcnQgYW5kIGVuZCBEYXRlVGltZXMuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLnMudmFsdWVPZigpID09PSB0aGlzLmUudmFsdWVPZigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwncyBzdGFydCBpcyBhZnRlciB0aGUgc3BlY2lmaWVkIERhdGVUaW1lLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBkYXRlVGltZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNBZnRlcihkYXRlVGltZSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMucyA+IGRhdGVUaW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwncyBlbmQgaXMgYmVmb3JlIHRoZSBzcGVjaWZpZWQgRGF0ZVRpbWUuXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IGRhdGVUaW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0JlZm9yZShkYXRlVGltZSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMuZSA8PSBkYXRlVGltZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIEludGVydmFsIGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgRGF0ZVRpbWUuXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IGRhdGVUaW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBjb250YWlucyhkYXRlVGltZSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMucyA8PSBkYXRlVGltZSAmJiB0aGlzLmUgPiBkYXRlVGltZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldHNcIiB0aGUgc3RhcnQgYW5kL29yIGVuZCBkYXRlcy4gUmV0dXJucyBhIG5ld2x5LWNvbnN0cnVjdGVkIEludGVydmFsLlxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzIC0gdGhlIHZhbHVlcyB0byBzZXRcbiAgICogQHBhcmFtIHtEYXRlVGltZX0gdmFsdWVzLnN0YXJ0IC0gdGhlIHN0YXJ0aW5nIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IHZhbHVlcy5lbmQgLSB0aGUgZW5kaW5nIERhdGVUaW1lXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgc2V0KHsgc3RhcnQsIGVuZCB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgcmV0dXJuIEludGVydmFsLmZyb21EYXRlVGltZXMoc3RhcnQgfHwgdGhpcy5zLCBlbmQgfHwgdGhpcy5lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdCB0aGlzIEludGVydmFsIGF0IGVhY2ggb2YgdGhlIHNwZWNpZmllZCBEYXRlVGltZXNcbiAgICogQHBhcmFtIHsuLi5EYXRlVGltZX0gZGF0ZVRpbWVzIC0gdGhlIHVuaXQgb2YgdGltZSB0byBjb3VudC5cbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzcGxpdEF0KC4uLmRhdGVUaW1lcykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gW107XG4gICAgY29uc3Qgc29ydGVkID0gZGF0ZVRpbWVzXG4gICAgICAgIC5tYXAoZnJpZW5kbHlEYXRlVGltZSlcbiAgICAgICAgLmZpbHRlcigoZCkgPT4gdGhpcy5jb250YWlucyhkKSlcbiAgICAgICAgLnNvcnQoKSxcbiAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICBsZXQgeyBzIH0gPSB0aGlzLFxuICAgICAgaSA9IDA7XG5cbiAgICB3aGlsZSAocyA8IHRoaXMuZSkge1xuICAgICAgY29uc3QgYWRkZWQgPSBzb3J0ZWRbaV0gfHwgdGhpcy5lLFxuICAgICAgICBuZXh0ID0gK2FkZGVkID4gK3RoaXMuZSA/IHRoaXMuZSA6IGFkZGVkO1xuICAgICAgcmVzdWx0cy5wdXNoKEludGVydmFsLmZyb21EYXRlVGltZXMocywgbmV4dCkpO1xuICAgICAgcyA9IG5leHQ7XG4gICAgICBpICs9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXQgdGhpcyBJbnRlcnZhbCBpbnRvIHNtYWxsZXIgSW50ZXJ2YWxzLCBlYWNoIG9mIHRoZSBzcGVjaWZpZWQgbGVuZ3RoLlxuICAgKiBMZWZ0IG92ZXIgdGltZSBpcyBncm91cGVkIGludG8gYSBzbWFsbGVyIGludGVydmFsXG4gICAqIEBwYXJhbSB7RHVyYXRpb258T2JqZWN0fG51bWJlcn0gZHVyYXRpb24gLSBUaGUgbGVuZ3RoIG9mIGVhY2ggcmVzdWx0aW5nIGludGVydmFsLlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHNwbGl0QnkoZHVyYXRpb24pIHtcbiAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tRHVyYXRpb25MaWtlKGR1cmF0aW9uKTtcblxuICAgIGlmICghdGhpcy5pc1ZhbGlkIHx8ICFkdXIuaXNWYWxpZCB8fCBkdXIuYXMoXCJtaWxsaXNlY29uZHNcIikgPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBsZXQgeyBzIH0gPSB0aGlzLFxuICAgICAgaWR4ID0gMSxcbiAgICAgIG5leHQ7XG5cbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgd2hpbGUgKHMgPCB0aGlzLmUpIHtcbiAgICAgIGNvbnN0IGFkZGVkID0gdGhpcy5zdGFydC5wbHVzKGR1ci5tYXBVbml0cygoeCkgPT4geCAqIGlkeCkpO1xuICAgICAgbmV4dCA9ICthZGRlZCA+ICt0aGlzLmUgPyB0aGlzLmUgOiBhZGRlZDtcbiAgICAgIHJlc3VsdHMucHVzaChJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHMsIG5leHQpKTtcbiAgICAgIHMgPSBuZXh0O1xuICAgICAgaWR4ICs9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXQgdGhpcyBJbnRlcnZhbCBpbnRvIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIHNtYWxsZXIgaW50ZXJ2YWxzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyT2ZQYXJ0cyAtIFRoZSBudW1iZXIgb2YgSW50ZXJ2YWxzIHRvIGRpdmlkZSB0aGUgSW50ZXJ2YWwgaW50by5cbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBkaXZpZGVFcXVhbGx5KG51bWJlck9mUGFydHMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiB0aGlzLnNwbGl0QnkodGhpcy5sZW5ndGgoKSAvIG51bWJlck9mUGFydHMpLnNsaWNlKDAsIG51bWJlck9mUGFydHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwgb3ZlcmxhcHMgd2l0aCB0aGUgc3BlY2lmaWVkIEludGVydmFsXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBvdmVybGFwcyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmUgPiBvdGhlci5zICYmIHRoaXMucyA8IG90aGVyLmU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIGVuZCBpcyBhZGphY2VudCB0byB0aGUgc3BlY2lmaWVkIEludGVydmFsJ3Mgc3RhcnQuXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBhYnV0c1N0YXJ0KG90aGVyKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gK3RoaXMuZSA9PT0gK290aGVyLnM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIHN0YXJ0IGlzIGFkamFjZW50IHRvIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWwncyBlbmQuXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBhYnV0c0VuZChvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuICtvdGhlci5lID09PSArdGhpcy5zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwgZW5ndWxmcyB0aGUgc3RhcnQgYW5kIGVuZCBvZiB0aGUgc3BlY2lmaWVkIEludGVydmFsLlxuICAgKiBAcGFyYW0ge0ludGVydmFsfSBvdGhlclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZW5ndWxmcyhvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMucyA8PSBvdGhlci5zICYmIHRoaXMuZSA+PSBvdGhlci5lO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwgaGFzIHRoZSBzYW1lIHN0YXJ0IGFuZCBlbmQgYXMgdGhlIHNwZWNpZmllZCBJbnRlcnZhbC5cbiAgICogQHBhcmFtIHtJbnRlcnZhbH0gb3RoZXJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGVxdWFscyhvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkIHx8ICFvdGhlci5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucy5lcXVhbHMob3RoZXIucykgJiYgdGhpcy5lLmVxdWFscyhvdGhlci5lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gSW50ZXJ2YWwgcmVwcmVzZW50aW5nIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhpcyBJbnRlcnZhbCBhbmQgdGhlIHNwZWNpZmllZCBJbnRlcnZhbC5cbiAgICogU3BlY2lmaWNhbGx5LCB0aGUgcmVzdWx0aW5nIEludGVydmFsIGhhcyB0aGUgbWF4aW11bSBzdGFydCB0aW1lIGFuZCB0aGUgbWluaW11bSBlbmQgdGltZSBvZiB0aGUgdHdvIEludGVydmFscy5cbiAgICogUmV0dXJucyBudWxsIGlmIHRoZSBpbnRlcnNlY3Rpb24gaXMgZW1wdHksIG1lYW5pbmcsIHRoZSBpbnRlcnZhbHMgZG9uJ3QgaW50ZXJzZWN0LlxuICAgKiBAcGFyYW0ge0ludGVydmFsfSBvdGhlclxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIGludGVyc2VjdGlvbihvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCBzID0gdGhpcy5zID4gb3RoZXIucyA/IHRoaXMucyA6IG90aGVyLnMsXG4gICAgICBlID0gdGhpcy5lIDwgb3RoZXIuZSA/IHRoaXMuZSA6IG90aGVyLmU7XG5cbiAgICBpZiAocyA+PSBlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIEludGVydmFsLmZyb21EYXRlVGltZXMocywgZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBJbnRlcnZhbCByZXByZXNlbnRpbmcgdGhlIHVuaW9uIG9mIHRoaXMgSW50ZXJ2YWwgYW5kIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWwuXG4gICAqIFNwZWNpZmljYWxseSwgdGhlIHJlc3VsdGluZyBJbnRlcnZhbCBoYXMgdGhlIG1pbmltdW0gc3RhcnQgdGltZSBhbmQgdGhlIG1heGltdW0gZW5kIHRpbWUgb2YgdGhlIHR3byBJbnRlcnZhbHMuXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgdW5pb24ob3RoZXIpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgcyA9IHRoaXMucyA8IG90aGVyLnMgPyB0aGlzLnMgOiBvdGhlci5zLFxuICAgICAgZSA9IHRoaXMuZSA+IG90aGVyLmUgPyB0aGlzLmUgOiBvdGhlci5lO1xuICAgIHJldHVybiBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHMsIGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1lcmdlIGFuIGFycmF5IG9mIEludGVydmFscyBpbnRvIGEgZXF1aXZhbGVudCBtaW5pbWFsIHNldCBvZiBJbnRlcnZhbHMuXG4gICAqIENvbWJpbmVzIG92ZXJsYXBwaW5nIGFuZCBhZGphY2VudCBJbnRlcnZhbHMuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGludGVydmFsc1xuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyBtZXJnZShpbnRlcnZhbHMpIHtcbiAgICBjb25zdCBbZm91bmQsIGZpbmFsXSA9IGludGVydmFsc1xuICAgICAgLnNvcnQoKGEsIGIpID0+IGEucyAtIGIucylcbiAgICAgIC5yZWR1Y2UoXG4gICAgICAgIChbc29mYXIsIGN1cnJlbnRdLCBpdGVtKSA9PiB7XG4gICAgICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gW3NvZmFyLCBpdGVtXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnQub3ZlcmxhcHMoaXRlbSkgfHwgY3VycmVudC5hYnV0c1N0YXJ0KGl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gW3NvZmFyLCBjdXJyZW50LnVuaW9uKGl0ZW0pXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtzb2Zhci5jb25jYXQoW2N1cnJlbnRdKSwgaXRlbV07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBbW10sIG51bGxdXG4gICAgICApO1xuICAgIGlmIChmaW5hbCkge1xuICAgICAgZm91bmQucHVzaChmaW5hbCk7XG4gICAgfVxuICAgIHJldHVybiBmb3VuZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgSW50ZXJ2YWxzIHJlcHJlc2VudGluZyB0aGUgc3BhbnMgb2YgdGltZSB0aGF0IG9ubHkgYXBwZWFyIGluIG9uZSBvZiB0aGUgc3BlY2lmaWVkIEludGVydmFscy5cbiAgICogQHBhcmFtIHtBcnJheX0gaW50ZXJ2YWxzXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3RhdGljIHhvcihpbnRlcnZhbHMpIHtcbiAgICBsZXQgc3RhcnQgPSBudWxsLFxuICAgICAgY3VycmVudENvdW50ID0gMDtcbiAgICBjb25zdCByZXN1bHRzID0gW10sXG4gICAgICBlbmRzID0gaW50ZXJ2YWxzLm1hcCgoaSkgPT4gW1xuICAgICAgICB7IHRpbWU6IGkucywgdHlwZTogXCJzXCIgfSxcbiAgICAgICAgeyB0aW1lOiBpLmUsIHR5cGU6IFwiZVwiIH0sXG4gICAgICBdKSxcbiAgICAgIGZsYXR0ZW5lZCA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQoLi4uZW5kcyksXG4gICAgICBhcnIgPSBmbGF0dGVuZWQuc29ydCgoYSwgYikgPT4gYS50aW1lIC0gYi50aW1lKTtcblxuICAgIGZvciAoY29uc3QgaSBvZiBhcnIpIHtcbiAgICAgIGN1cnJlbnRDb3VudCArPSBpLnR5cGUgPT09IFwic1wiID8gMSA6IC0xO1xuXG4gICAgICBpZiAoY3VycmVudENvdW50ID09PSAxKSB7XG4gICAgICAgIHN0YXJ0ID0gaS50aW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHN0YXJ0ICYmICtzdGFydCAhPT0gK2kudGltZSkge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHN0YXJ0LCBpLnRpbWUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gSW50ZXJ2YWwubWVyZ2UocmVzdWx0cyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIEludGVydmFsIHJlcHJlc2VudGluZyB0aGUgc3BhbiBvZiB0aW1lIGluIHRoaXMgSW50ZXJ2YWwgdGhhdCBkb2Vzbid0IG92ZXJsYXAgd2l0aCBhbnkgb2YgdGhlIHNwZWNpZmllZCBJbnRlcnZhbHMuXG4gICAqIEBwYXJhbSB7Li4uSW50ZXJ2YWx9IGludGVydmFsc1xuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIGRpZmZlcmVuY2UoLi4uaW50ZXJ2YWxzKSB7XG4gICAgcmV0dXJuIEludGVydmFsLnhvcihbdGhpc10uY29uY2F0KGludGVydmFscykpXG4gICAgICAubWFwKChpKSA9PiB0aGlzLmludGVyc2VjdGlvbihpKSlcbiAgICAgIC5maWx0ZXIoKGkpID0+IGkgJiYgIWkuaXNFbXB0eSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgSW50ZXJ2YWwgYXBwcm9wcmlhdGUgZm9yIGRlYnVnZ2luZy5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBJTlZBTElEO1xuICAgIHJldHVybiBgWyR7dGhpcy5zLnRvSVNPKCl9IOKAkyAke3RoaXMuZS50b0lTTygpfSlgO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsb2NhbGl6ZWQgc3RyaW5nIHJlcHJlc2VudGluZyB0aGlzIEludGVydmFsLiBBY2NlcHRzIHRoZSBzYW1lIG9wdGlvbnMgYXMgdGhlXG4gICAqIEludGwuRGF0ZVRpbWVGb3JtYXQgY29uc3RydWN0b3IgYW5kIGFueSBwcmVzZXRzIGRlZmluZWQgYnkgTHV4b24sIHN1Y2ggYXNcbiAgICoge0BsaW5rIERhdGVUaW1lLkRBVEVfRlVMTH0gb3Ige0BsaW5rIERhdGVUaW1lLlRJTUVfU0lNUExFfS4gVGhlIGV4YWN0IGJlaGF2aW9yIG9mIHRoaXMgbWV0aG9kXG4gICAqIGlzIGJyb3dzZXItc3BlY2lmaWMsIGJ1dCBpbiBnZW5lcmFsIGl0IHdpbGwgcmV0dXJuIGFuIGFwcHJvcHJpYXRlIHJlcHJlc2VudGF0aW9uIG9mIHRoZVxuICAgKiBJbnRlcnZhbCBpbiB0aGUgYXNzaWduZWQgbG9jYWxlLiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlblxuICAgKiBzcGVjaWZpZWQuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZVRpbWVGb3JtYXRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtmb3JtYXRPcHRzPURhdGVUaW1lLkRBVEVfU0hPUlRdIC0gRWl0aGVyIGEgRGF0ZVRpbWUgcHJlc2V0IG9yXG4gICAqIEludGwuRGF0ZVRpbWVGb3JtYXQgY29uc3RydWN0b3Igb3B0aW9ucy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBPcHRpb25zIHRvIG92ZXJyaWRlIHRoZSBjb25maWd1cmF0aW9uIG9mIHRoZSBzdGFydCBEYXRlVGltZS5cbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbUlTTygnMjAyMi0xMS0wN1QwOTowMFovMjAyMi0xMS0wOFQwOTowMFonKS50b0xvY2FsZVN0cmluZygpOyAvLz0+IDExLzcvMjAyMiDigJMgMTEvOC8yMDIyXG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21JU08oJzIwMjItMTEtMDdUMDk6MDBaLzIwMjItMTEtMDhUMDk6MDBaJykudG9Mb2NhbGVTdHJpbmcoRGF0ZVRpbWUuREFURV9GVUxMKTsgLy89PiBOb3ZlbWJlciA3IOKAkyA4LCAyMDIyXG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21JU08oJzIwMjItMTEtMDdUMDk6MDBaLzIwMjItMTEtMDhUMDk6MDBaJykudG9Mb2NhbGVTdHJpbmcoRGF0ZVRpbWUuREFURV9GVUxMLCB7IGxvY2FsZTogJ2ZyLUZSJyB9KTsgLy89PiA34oCTOCBub3ZlbWJyZSAyMDIyXG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21JU08oJzIwMjItMTEtMDdUMTc6MDBaLzIwMjItMTEtMDdUMTk6MDBaJykudG9Mb2NhbGVTdHJpbmcoRGF0ZVRpbWUuVElNRV9TSU1QTEUpOyAvLz0+IDY6MDAg4oCTIDg6MDAgUE1cbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbUlTTygnMjAyMi0xMS0wN1QxNzowMFovMjAyMi0xMS0wN1QxOTowMFonKS50b0xvY2FsZVN0cmluZyh7IHdlZWtkYXk6ICdzaG9ydCcsIG1vbnRoOiAnc2hvcnQnLCBkYXk6ICcyLWRpZ2l0JywgaG91cjogJzItZGlnaXQnLCBtaW51dGU6ICcyLWRpZ2l0JyB9KTsgLy89PiBNb24sIE5vdiAwNywgNjowMCDigJMgODowMCBwXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvTG9jYWxlU3RyaW5nKGZvcm1hdE9wdHMgPSBGb3JtYXRzLkRBVEVfU0hPUlQsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWRcbiAgICAgID8gRm9ybWF0dGVyLmNyZWF0ZSh0aGlzLnMubG9jLmNsb25lKG9wdHMpLCBmb3JtYXRPcHRzKS5mb3JtYXRJbnRlcnZhbCh0aGlzKVxuICAgICAgOiBJTlZBTElEO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIEludGVydmFsLlxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI1RpbWVfaW50ZXJ2YWxzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gVGhlIHNhbWUgb3B0aW9ucyBhcyB7QGxpbmsgRGF0ZVRpbWUjdG9JU099XG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSVNPKG9wdHMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIElOVkFMSUQ7XG4gICAgcmV0dXJuIGAke3RoaXMucy50b0lTTyhvcHRzKX0vJHt0aGlzLmUudG9JU08ob3B0cyl9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgZGF0ZSBvZiB0aGlzIEludGVydmFsLlxuICAgKiBUaGUgdGltZSBjb21wb25lbnRzIGFyZSBpZ25vcmVkLlxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI1RpbWVfaW50ZXJ2YWxzXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSVNPRGF0ZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIElOVkFMSUQ7XG4gICAgcmV0dXJuIGAke3RoaXMucy50b0lTT0RhdGUoKX0vJHt0aGlzLmUudG9JU09EYXRlKCl9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGltZSBvZiB0aGlzIEludGVydmFsLlxuICAgKiBUaGUgZGF0ZSBjb21wb25lbnRzIGFyZSBpZ25vcmVkLlxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI1RpbWVfaW50ZXJ2YWxzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gVGhlIHNhbWUgb3B0aW9ucyBhcyB7QGxpbmsgRGF0ZVRpbWUjdG9JU099XG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSVNPVGltZShvcHRzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBJTlZBTElEO1xuICAgIHJldHVybiBgJHt0aGlzLnMudG9JU09UaW1lKG9wdHMpfS8ke3RoaXMuZS50b0lTT1RpbWUob3B0cyl9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgSW50ZXJ2YWwgZm9ybWF0dGVkIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIGZvcm1hdFxuICAgKiBzdHJpbmcuICoqWW91IG1heSBub3Qgd2FudCB0aGlzLioqIFNlZSB7QGxpbmsgSW50ZXJ2YWwjdG9Mb2NhbGVTdHJpbmd9IGZvciBhIG1vcmUgZmxleGlibGVcbiAgICogZm9ybWF0dGluZyB0b29sLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0ZUZvcm1hdCAtIFRoZSBmb3JtYXQgc3RyaW5nLiBUaGlzIHN0cmluZyBmb3JtYXRzIHRoZSBzdGFydCBhbmQgZW5kIHRpbWUuXG4gICAqIFNlZSB7QGxpbmsgRGF0ZVRpbWUjdG9Gb3JtYXR9IGZvciBkZXRhaWxzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIE9wdGlvbnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5zZXBhcmF0b3IgPSAgJyDigJMgJ10gLSBBIHNlcGFyYXRvciB0byBwbGFjZSBiZXR3ZWVuIHRoZSBzdGFydCBhbmQgZW5kXG4gICAqIHJlcHJlc2VudGF0aW9ucy5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9Gb3JtYXQoZGF0ZUZvcm1hdCwgeyBzZXBhcmF0b3IgPSBcIiDigJMgXCIgfSA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBJTlZBTElEO1xuICAgIHJldHVybiBgJHt0aGlzLnMudG9Gb3JtYXQoZGF0ZUZvcm1hdCl9JHtzZXBhcmF0b3J9JHt0aGlzLmUudG9Gb3JtYXQoZGF0ZUZvcm1hdCl9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBEdXJhdGlvbiByZXByZXNlbnRpbmcgdGhlIHRpbWUgc3Bhbm5lZCBieSB0aGlzIGludGVydmFsLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gW3VuaXQ9WydtaWxsaXNlY29uZHMnXV0gLSB0aGUgdW5pdCBvciB1bml0cyAoc3VjaCBhcyAnaG91cnMnIG9yICdkYXlzJykgdG8gaW5jbHVkZSBpbiB0aGUgZHVyYXRpb24uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0aGF0IGFmZmVjdCB0aGUgY3JlYXRpb24gb2YgdGhlIER1cmF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5jb252ZXJzaW9uQWNjdXJhY3k9J2Nhc3VhbCddIC0gdGhlIGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0MSwgZHQyKS50b0R1cmF0aW9uKCkudG9PYmplY3QoKSAvLz0+IHsgbWlsbGlzZWNvbmRzOiA4ODQ4OTI1NyB9XG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQxLCBkdDIpLnRvRHVyYXRpb24oJ2RheXMnKS50b09iamVjdCgpIC8vPT4geyBkYXlzOiAxLjAyNDE4MTIxNTI3Nzc3NzggfVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0MSwgZHQyKS50b0R1cmF0aW9uKFsnaG91cnMnLCAnbWludXRlcyddKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMjQsIG1pbnV0ZXM6IDM0LjgyMDk1IH1cbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdDEsIGR0MikudG9EdXJhdGlvbihbJ2hvdXJzJywgJ21pbnV0ZXMnLCAnc2Vjb25kcyddKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMjQsIG1pbnV0ZXM6IDM0LCBzZWNvbmRzOiA0OS4yNTcgfVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0MSwgZHQyKS50b0R1cmF0aW9uKCdzZWNvbmRzJykudG9PYmplY3QoKSAvLz0+IHsgc2Vjb25kczogODg0ODkuMjU3IH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICB0b0R1cmF0aW9uKHVuaXQsIG9wdHMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmludmFsaWQodGhpcy5pbnZhbGlkUmVhc29uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZS5kaWZmKHRoaXMucywgdW5pdCwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogUnVuIG1hcEZuIG9uIHRoZSBpbnRlcnZhbCBzdGFydCBhbmQgZW5kLCByZXR1cm5pbmcgYSBuZXcgSW50ZXJ2YWwgZnJvbSB0aGUgcmVzdWx0aW5nIERhdGVUaW1lc1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBtYXBGblxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdDEsIGR0MikubWFwRW5kcG9pbnRzKGVuZHBvaW50ID0+IGVuZHBvaW50LnRvVVRDKCkpXG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQxLCBkdDIpLm1hcEVuZHBvaW50cyhlbmRwb2ludCA9PiBlbmRwb2ludC5wbHVzKHsgaG91cnM6IDIgfSkpXG4gICAqL1xuICBtYXBFbmRwb2ludHMobWFwRm4pIHtcbiAgICByZXR1cm4gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhtYXBGbih0aGlzLnMpLCBtYXBGbih0aGlzLmUpKTtcbiAgfVxufVxuIiwgImltcG9ydCBEYXRlVGltZSBmcm9tIFwiLi9kYXRldGltZS5qc1wiO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gXCIuL3NldHRpbmdzLmpzXCI7XG5pbXBvcnQgTG9jYWxlIGZyb20gXCIuL2ltcGwvbG9jYWxlLmpzXCI7XG5pbXBvcnQgSUFOQVpvbmUgZnJvbSBcIi4vem9uZXMvSUFOQVpvbmUuanNcIjtcbmltcG9ydCB7IG5vcm1hbGl6ZVpvbmUgfSBmcm9tIFwiLi9pbXBsL3pvbmVVdGlsLmpzXCI7XG5cbmltcG9ydCB7IGhhc1JlbGF0aXZlIH0gZnJvbSBcIi4vaW1wbC91dGlsLmpzXCI7XG5cbi8qKlxuICogVGhlIEluZm8gY2xhc3MgY29udGFpbnMgc3RhdGljIG1ldGhvZHMgZm9yIHJldHJpZXZpbmcgZ2VuZXJhbCB0aW1lIGFuZCBkYXRlIHJlbGF0ZWQgZGF0YS4gRm9yIGV4YW1wbGUsIGl0IGhhcyBtZXRob2RzIGZvciBmaW5kaW5nIG91dCBpZiBhIHRpbWUgem9uZSBoYXMgYSBEU1QsIGZvciBsaXN0aW5nIHRoZSBtb250aHMgaW4gYW55IHN1cHBvcnRlZCBsb2NhbGUsIGFuZCBmb3IgZGlzY292ZXJpbmcgd2hpY2ggb2YgTHV4b24gZmVhdHVyZXMgYXJlIGF2YWlsYWJsZSBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5mbyB7XG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGUgc3BlY2lmaWVkIHpvbmUgY29udGFpbnMgYSBEU1QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFt6b25lPSdsb2NhbCddIC0gWm9uZSB0byBjaGVjay4gRGVmYXVsdHMgdG8gdGhlIGVudmlyb25tZW50J3MgbG9jYWwgem9uZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBoYXNEU1Qoem9uZSA9IFNldHRpbmdzLmRlZmF1bHRab25lKSB7XG4gICAgY29uc3QgcHJvdG8gPSBEYXRlVGltZS5ub3coKS5zZXRab25lKHpvbmUpLnNldCh7IG1vbnRoOiAxMiB9KTtcblxuICAgIHJldHVybiAhem9uZS5pc1VuaXZlcnNhbCAmJiBwcm90by5vZmZzZXQgIT09IHByb3RvLnNldCh7IG1vbnRoOiA2IH0pLm9mZnNldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGUgc3BlY2lmaWVkIHpvbmUgaXMgYSB2YWxpZCBJQU5BIHNwZWNpZmllci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHpvbmUgLSBab25lIHRvIGNoZWNrXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNWYWxpZElBTkFab25lKHpvbmUpIHtcbiAgICByZXR1cm4gSUFOQVpvbmUuaXNWYWxpZFpvbmUoem9uZSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdGhlIGlucHV0IGludG8gYSB7QGxpbmsgWm9uZX0gaW5zdGFuY2UuXG4gICAqXG4gICAqICogSWYgYGlucHV0YCBpcyBhbHJlYWR5IGEgWm9uZSBpbnN0YW5jZSwgaXQgaXMgcmV0dXJuZWQgdW5jaGFuZ2VkLlxuICAgKiAqIElmIGBpbnB1dGAgaXMgYSBzdHJpbmcgY29udGFpbmluZyBhIHZhbGlkIHRpbWUgem9uZSBuYW1lLCBhIFpvbmUgaW5zdGFuY2VcbiAgICogICB3aXRoIHRoYXQgbmFtZSBpcyByZXR1cm5lZC5cbiAgICogKiBJZiBgaW5wdXRgIGlzIGEgc3RyaW5nIHRoYXQgZG9lc24ndCByZWZlciB0byBhIGtub3duIHRpbWUgem9uZSwgYSBab25lXG4gICAqICAgaW5zdGFuY2Ugd2l0aCB7QGxpbmsgWm9uZSNpc1ZhbGlkfSA9PSBmYWxzZSBpcyByZXR1cm5lZC5cbiAgICogKiBJZiBgaW5wdXQgaXMgYSBudW1iZXIsIGEgWm9uZSBpbnN0YW5jZSB3aXRoIHRoZSBzcGVjaWZpZWQgZml4ZWQgb2Zmc2V0XG4gICAqICAgaW4gbWludXRlcyBpcyByZXR1cm5lZC5cbiAgICogKiBJZiBgaW5wdXRgIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYCwgdGhlIGRlZmF1bHQgem9uZSBpcyByZXR1cm5lZC5cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZXxudW1iZXJ9IFtpbnB1dF0gLSB0aGUgdmFsdWUgdG8gYmUgY29udmVydGVkXG4gICAqIEByZXR1cm4ge1pvbmV9XG4gICAqL1xuICBzdGF0aWMgbm9ybWFsaXplWm9uZShpbnB1dCkge1xuICAgIHJldHVybiBub3JtYWxpemVab25lKGlucHV0LCBTZXR0aW5ncy5kZWZhdWx0Wm9uZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGFycmF5IG9mIHN0YW5kYWxvbmUgbW9udGggbmFtZXMuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZVRpbWVGb3JtYXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsZW5ndGg9J2xvbmcnXSAtIHRoZSBsZW5ndGggb2YgdGhlIG1vbnRoIHJlcHJlc2VudGF0aW9uLCBzdWNoIGFzIFwibnVtZXJpY1wiLCBcIjItZGlnaXRcIiwgXCJuYXJyb3dcIiwgXCJzaG9ydFwiLCBcImxvbmdcIlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZV0gLSB0aGUgbG9jYWxlIGNvZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm51bWJlcmluZ1N5c3RlbT1udWxsXSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NPYmo9bnVsbF0gLSBhbiBleGlzdGluZyBsb2NhbGUgb2JqZWN0IHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMub3V0cHV0Q2FsZW5kYXI9J2dyZWdvcnknXSAtIHRoZSBjYWxlbmRhclxuICAgKiBAZXhhbXBsZSBJbmZvLm1vbnRocygpWzBdIC8vPT4gJ0phbnVhcnknXG4gICAqIEBleGFtcGxlIEluZm8ubW9udGhzKCdzaG9ydCcpWzBdIC8vPT4gJ0phbidcbiAgICogQGV4YW1wbGUgSW5mby5tb250aHMoJ251bWVyaWMnKVswXSAvLz0+ICcxJ1xuICAgKiBAZXhhbXBsZSBJbmZvLm1vbnRocygnc2hvcnQnLCB7IGxvY2FsZTogJ2ZyLUNBJyB9IClbMF0gLy89PiAnamFudi4nXG4gICAqIEBleGFtcGxlIEluZm8ubW9udGhzKCdudW1lcmljJywgeyBsb2NhbGU6ICdhcicgfSlbMF0gLy89PiAn2aEnXG4gICAqIEBleGFtcGxlIEluZm8ubW9udGhzKCdsb25nJywgeyBvdXRwdXRDYWxlbmRhcjogJ2lzbGFtaWMnIH0pWzBdIC8vPT4gJ1JhYmnKuyBJJ1xuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyBtb250aHMoXG4gICAgbGVuZ3RoID0gXCJsb25nXCIsXG4gICAgeyBsb2NhbGUgPSBudWxsLCBudW1iZXJpbmdTeXN0ZW0gPSBudWxsLCBsb2NPYmogPSBudWxsLCBvdXRwdXRDYWxlbmRhciA9IFwiZ3JlZ29yeVwiIH0gPSB7fVxuICApIHtcbiAgICByZXR1cm4gKGxvY09iaiB8fCBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhcikpLm1vbnRocyhsZW5ndGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBhcnJheSBvZiBmb3JtYXQgbW9udGggbmFtZXMuXG4gICAqIEZvcm1hdCBtb250aHMgZGlmZmVyIGZyb20gc3RhbmRhbG9uZSBtb250aHMgaW4gdGhhdCB0aGV5J3JlIG1lYW50IHRvIGFwcGVhciBuZXh0IHRvIHRoZSBkYXkgb2YgdGhlIG1vbnRoLiBJbiBzb21lIGxhbmd1YWdlcywgdGhhdFxuICAgKiBjaGFuZ2VzIHRoZSBzdHJpbmcuXG4gICAqIFNlZSB7QGxpbmsgSW5mbyNtb250aHN9XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGVuZ3RoPSdsb25nJ10gLSB0aGUgbGVuZ3RoIG9mIHRoZSBtb250aCByZXByZXNlbnRhdGlvbiwgc3VjaCBhcyBcIm51bWVyaWNcIiwgXCIyLWRpZ2l0XCIsIFwibmFycm93XCIsIFwic2hvcnRcIiwgXCJsb25nXCJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGVdIC0gdGhlIGxvY2FsZSBjb2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5udW1iZXJpbmdTeXN0ZW09bnVsbF0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jT2JqPW51bGxdIC0gYW4gZXhpc3RpbmcgbG9jYWxlIG9iamVjdCB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm91dHB1dENhbGVuZGFyPSdncmVnb3J5J10gLSB0aGUgY2FsZW5kYXJcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzdGF0aWMgbW9udGhzRm9ybWF0KFxuICAgIGxlbmd0aCA9IFwibG9uZ1wiLFxuICAgIHsgbG9jYWxlID0gbnVsbCwgbnVtYmVyaW5nU3lzdGVtID0gbnVsbCwgbG9jT2JqID0gbnVsbCwgb3V0cHV0Q2FsZW5kYXIgPSBcImdyZWdvcnlcIiB9ID0ge31cbiAgKSB7XG4gICAgcmV0dXJuIChsb2NPYmogfHwgTG9jYWxlLmNyZWF0ZShsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgb3V0cHV0Q2FsZW5kYXIpKS5tb250aHMobGVuZ3RoLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2Ygc3RhbmRhbG9uZSB3ZWVrIG5hbWVzLlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGVUaW1lRm9ybWF0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGVuZ3RoPSdsb25nJ10gLSB0aGUgbGVuZ3RoIG9mIHRoZSB3ZWVrZGF5IHJlcHJlc2VudGF0aW9uLCBzdWNoIGFzIFwibmFycm93XCIsIFwic2hvcnRcIiwgXCJsb25nXCIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlXSAtIHRoZSBsb2NhbGUgY29kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubnVtYmVyaW5nU3lzdGVtPW51bGxdIC0gdGhlIG51bWJlcmluZyBzeXN0ZW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY09iaj1udWxsXSAtIGFuIGV4aXN0aW5nIGxvY2FsZSBvYmplY3QgdG8gdXNlXG4gICAqIEBleGFtcGxlIEluZm8ud2Vla2RheXMoKVswXSAvLz0+ICdNb25kYXknXG4gICAqIEBleGFtcGxlIEluZm8ud2Vla2RheXMoJ3Nob3J0JylbMF0gLy89PiAnTW9uJ1xuICAgKiBAZXhhbXBsZSBJbmZvLndlZWtkYXlzKCdzaG9ydCcsIHsgbG9jYWxlOiAnZnItQ0EnIH0pWzBdIC8vPT4gJ2x1bi4nXG4gICAqIEBleGFtcGxlIEluZm8ud2Vla2RheXMoJ3Nob3J0JywgeyBsb2NhbGU6ICdhcicgfSlbMF0gLy89PiAn2KfZhNin2KvZhtmK2YYnXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3RhdGljIHdlZWtkYXlzKGxlbmd0aCA9IFwibG9uZ1wiLCB7IGxvY2FsZSA9IG51bGwsIG51bWJlcmluZ1N5c3RlbSA9IG51bGwsIGxvY09iaiA9IG51bGwgfSA9IHt9KSB7XG4gICAgcmV0dXJuIChsb2NPYmogfHwgTG9jYWxlLmNyZWF0ZShsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgbnVsbCkpLndlZWtkYXlzKGxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGFycmF5IG9mIGZvcm1hdCB3ZWVrIG5hbWVzLlxuICAgKiBGb3JtYXQgd2Vla2RheXMgZGlmZmVyIGZyb20gc3RhbmRhbG9uZSB3ZWVrZGF5cyBpbiB0aGF0IHRoZXkncmUgbWVhbnQgdG8gYXBwZWFyIG5leHQgdG8gbW9yZSBkYXRlIGluZm9ybWF0aW9uLiBJbiBzb21lIGxhbmd1YWdlcywgdGhhdFxuICAgKiBjaGFuZ2VzIHRoZSBzdHJpbmcuXG4gICAqIFNlZSB7QGxpbmsgSW5mbyN3ZWVrZGF5c31cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsZW5ndGg9J2xvbmcnXSAtIHRoZSBsZW5ndGggb2YgdGhlIG1vbnRoIHJlcHJlc2VudGF0aW9uLCBzdWNoIGFzIFwibmFycm93XCIsIFwic2hvcnRcIiwgXCJsb25nXCIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPW51bGxdIC0gdGhlIGxvY2FsZSBjb2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5udW1iZXJpbmdTeXN0ZW09bnVsbF0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jT2JqPW51bGxdIC0gYW4gZXhpc3RpbmcgbG9jYWxlIG9iamVjdCB0byB1c2VcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzdGF0aWMgd2Vla2RheXNGb3JtYXQoXG4gICAgbGVuZ3RoID0gXCJsb25nXCIsXG4gICAgeyBsb2NhbGUgPSBudWxsLCBudW1iZXJpbmdTeXN0ZW0gPSBudWxsLCBsb2NPYmogPSBudWxsIH0gPSB7fVxuICApIHtcbiAgICByZXR1cm4gKGxvY09iaiB8fCBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBudWxsKSkud2Vla2RheXMobGVuZ3RoLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgbWVyaWRpZW1zLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZV0gLSB0aGUgbG9jYWxlIGNvZGVcbiAgICogQGV4YW1wbGUgSW5mby5tZXJpZGllbXMoKSAvLz0+IFsgJ0FNJywgJ1BNJyBdXG4gICAqIEBleGFtcGxlIEluZm8ubWVyaWRpZW1zKHsgbG9jYWxlOiAnbXknIH0pIC8vPT4gWyAn4YCU4YC24YCU4YCA4YC6JywgJ+GAiuGAlOGAsScgXVxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyBtZXJpZGllbXMoeyBsb2NhbGUgPSBudWxsIH0gPSB7fSkge1xuICAgIHJldHVybiBMb2NhbGUuY3JlYXRlKGxvY2FsZSkubWVyaWRpZW1zKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGFycmF5IG9mIGVyYXMsIHN1Y2ggYXMgWydCQycsICdBRCddLiBUaGUgbG9jYWxlIGNhbiBiZSBzcGVjaWZpZWQsIGJ1dCB0aGUgY2FsZW5kYXIgc3lzdGVtIGlzIGFsd2F5cyBHcmVnb3JpYW4uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGVuZ3RoPSdzaG9ydCddIC0gdGhlIGxlbmd0aCBvZiB0aGUgZXJhIHJlcHJlc2VudGF0aW9uLCBzdWNoIGFzIFwic2hvcnRcIiBvciBcImxvbmdcIi5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGVdIC0gdGhlIGxvY2FsZSBjb2RlXG4gICAqIEBleGFtcGxlIEluZm8uZXJhcygpIC8vPT4gWyAnQkMnLCAnQUQnIF1cbiAgICogQGV4YW1wbGUgSW5mby5lcmFzKCdsb25nJykgLy89PiBbICdCZWZvcmUgQ2hyaXN0JywgJ0Fubm8gRG9taW5pJyBdXG4gICAqIEBleGFtcGxlIEluZm8uZXJhcygnbG9uZycsIHsgbG9jYWxlOiAnZnInIH0pIC8vPT4gWyAnYXZhbnQgSsOpc3VzLUNocmlzdCcsICdhcHLDqHMgSsOpc3VzLUNocmlzdCcgXVxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyBlcmFzKGxlbmd0aCA9IFwic2hvcnRcIiwgeyBsb2NhbGUgPSBudWxsIH0gPSB7fSkge1xuICAgIHJldHVybiBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVsbCwgXCJncmVnb3J5XCIpLmVyYXMobGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHNldCBvZiBhdmFpbGFibGUgZmVhdHVyZXMgaW4gdGhpcyBlbnZpcm9ubWVudC5cbiAgICogU29tZSBmZWF0dXJlcyBvZiBMdXhvbiBhcmUgbm90IGF2YWlsYWJsZSBpbiBhbGwgZW52aXJvbm1lbnRzLiBGb3IgZXhhbXBsZSwgb24gb2xkZXIgYnJvd3NlcnMsIHJlbGF0aXZlIHRpbWUgZm9ybWF0dGluZyBzdXBwb3J0IGlzIG5vdCBhdmFpbGFibGUuIFVzZSB0aGlzIGZ1bmN0aW9uIHRvIGZpZ3VyZSBvdXQgaWYgdGhhdCdzIHRoZSBjYXNlLlxuICAgKiBLZXlzOlxuICAgKiAqIGByZWxhdGl2ZWA6IHdoZXRoZXIgdGhpcyBlbnZpcm9ubWVudCBzdXBwb3J0cyByZWxhdGl2ZSB0aW1lIGZvcm1hdHRpbmdcbiAgICogQGV4YW1wbGUgSW5mby5mZWF0dXJlcygpIC8vPT4geyByZWxhdGl2ZTogZmFsc2UgfVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZmVhdHVyZXMoKSB7XG4gICAgcmV0dXJuIHsgcmVsYXRpdmU6IGhhc1JlbGF0aXZlKCkgfTtcbiAgfVxufVxuIiwgImltcG9ydCBEdXJhdGlvbiBmcm9tIFwiLi4vZHVyYXRpb24uanNcIjtcblxuZnVuY3Rpb24gZGF5RGlmZihlYXJsaWVyLCBsYXRlcikge1xuICBjb25zdCB1dGNEYXlTdGFydCA9IChkdCkgPT4gZHQudG9VVEMoMCwgeyBrZWVwTG9jYWxUaW1lOiB0cnVlIH0pLnN0YXJ0T2YoXCJkYXlcIikudmFsdWVPZigpLFxuICAgIG1zID0gdXRjRGF5U3RhcnQobGF0ZXIpIC0gdXRjRGF5U3RhcnQoZWFybGllcik7XG4gIHJldHVybiBNYXRoLmZsb29yKER1cmF0aW9uLmZyb21NaWxsaXMobXMpLmFzKFwiZGF5c1wiKSk7XG59XG5cbmZ1bmN0aW9uIGhpZ2hPcmRlckRpZmZzKGN1cnNvciwgbGF0ZXIsIHVuaXRzKSB7XG4gIGNvbnN0IGRpZmZlcnMgPSBbXG4gICAgW1wieWVhcnNcIiwgKGEsIGIpID0+IGIueWVhciAtIGEueWVhcl0sXG4gICAgW1wicXVhcnRlcnNcIiwgKGEsIGIpID0+IGIucXVhcnRlciAtIGEucXVhcnRlciArIChiLnllYXIgLSBhLnllYXIpICogNF0sXG4gICAgW1wibW9udGhzXCIsIChhLCBiKSA9PiBiLm1vbnRoIC0gYS5tb250aCArIChiLnllYXIgLSBhLnllYXIpICogMTJdLFxuICAgIFtcbiAgICAgIFwid2Vla3NcIixcbiAgICAgIChhLCBiKSA9PiB7XG4gICAgICAgIGNvbnN0IGRheXMgPSBkYXlEaWZmKGEsIGIpO1xuICAgICAgICByZXR1cm4gKGRheXMgLSAoZGF5cyAlIDcpKSAvIDc7XG4gICAgICB9LFxuICAgIF0sXG4gICAgW1wiZGF5c1wiLCBkYXlEaWZmXSxcbiAgXTtcblxuICBjb25zdCByZXN1bHRzID0ge307XG4gIGNvbnN0IGVhcmxpZXIgPSBjdXJzb3I7XG4gIGxldCBsb3dlc3RPcmRlciwgaGlnaFdhdGVyO1xuXG4gIC8qIFRoaXMgbG9vcCB0cmllcyB0byBkaWZmIHVzaW5nIGxhcmdlciB1bml0cyBmaXJzdC5cbiAgICAgSWYgd2Ugb3ZlcnNob290LCB3ZSBiYWNrdHJhY2sgYW5kIHRyeSB0aGUgbmV4dCBzbWFsbGVyIHVuaXQuXG4gICAgIFwiY3Vyc29yXCIgc3RhcnRzIG91dCBhdCB0aGUgZWFybGllciB0aW1lc3RhbXAgYW5kIG1vdmVzIGNsb3NlciBhbmQgY2xvc2VyIHRvIFwibGF0ZXJcIlxuICAgICBhcyB3ZSB1c2Ugc21hbGxlciBhbmQgc21hbGxlciB1bml0cy5cbiAgICAgaGlnaFdhdGVyIGtlZXBzIHRyYWNrIG9mIHdoZXJlIHdlIHdvdWxkIGJlIGlmIHdlIGFkZGVkIG9uZSBtb3JlIG9mIHRoZSBzbWFsbGVzdCB1bml0LFxuICAgICB0aGlzIGlzIHVzZWQgbGF0ZXIgdG8gcG90ZW50aWFsbHkgY29udmVydCBhbnkgZGlmZmVyZW5jZSBzbWFsbGVyIHRoYW4gdGhlIHNtYWxsZXN0IGhpZ2hlciBvcmRlciB1bml0XG4gICAgIGludG8gYSBmcmFjdGlvbiBvZiB0aGF0IHNtYWxsZXN0IGhpZ2hlciBvcmRlciB1bml0XG4gICovXG4gIGZvciAoY29uc3QgW3VuaXQsIGRpZmZlcl0gb2YgZGlmZmVycykge1xuICAgIGlmICh1bml0cy5pbmRleE9mKHVuaXQpID49IDApIHtcbiAgICAgIGxvd2VzdE9yZGVyID0gdW5pdDtcblxuICAgICAgcmVzdWx0c1t1bml0XSA9IGRpZmZlcihjdXJzb3IsIGxhdGVyKTtcbiAgICAgIGhpZ2hXYXRlciA9IGVhcmxpZXIucGx1cyhyZXN1bHRzKTtcblxuICAgICAgaWYgKGhpZ2hXYXRlciA+IGxhdGVyKSB7XG4gICAgICAgIC8vIHdlIG92ZXJzaG90IHRoZSBlbmQgcG9pbnQsIGJhY2t0cmFjayBjdXJzb3IgYnkgMVxuICAgICAgICByZXN1bHRzW3VuaXRdLS07XG4gICAgICAgIGN1cnNvciA9IGVhcmxpZXIucGx1cyhyZXN1bHRzKTtcblxuICAgICAgICAvLyBpZiB3ZSBhcmUgc3RpbGwgb3ZlcnNob290aW5nIG5vdywgd2UgbmVlZCB0byBiYWNrdHJhY2sgYWdhaW5cbiAgICAgICAgLy8gdGhpcyBoYXBwZW5zIGluIGNlcnRhaW4gc2l0dWF0aW9ucyB3aGVuIGRpZmZpbmcgdGltZXMgaW4gZGlmZmVyZW50IHpvbmVzLFxuICAgICAgICAvLyBiZWNhdXNlIHRoaXMgY2FsY3VsYXRpb24gaWdub3JlcyB0aW1lIHpvbmVzXG4gICAgICAgIGlmIChjdXJzb3IgPiBsYXRlcikge1xuICAgICAgICAgIC8vIGtlZXAgdGhlIFwib3ZlcnNob3QgYnkgMVwiIGFyb3VuZCBhcyBoaWdoV2F0ZXJcbiAgICAgICAgICBoaWdoV2F0ZXIgPSBjdXJzb3I7XG4gICAgICAgICAgLy8gYmFja3RyYWNrIGN1cnNvciBieSAxXG4gICAgICAgICAgcmVzdWx0c1t1bml0XS0tO1xuICAgICAgICAgIGN1cnNvciA9IGVhcmxpZXIucGx1cyhyZXN1bHRzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3Vyc29yID0gaGlnaFdhdGVyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbY3Vyc29yLCByZXN1bHRzLCBoaWdoV2F0ZXIsIGxvd2VzdE9yZGVyXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKGVhcmxpZXIsIGxhdGVyLCB1bml0cywgb3B0cykge1xuICBsZXQgW2N1cnNvciwgcmVzdWx0cywgaGlnaFdhdGVyLCBsb3dlc3RPcmRlcl0gPSBoaWdoT3JkZXJEaWZmcyhlYXJsaWVyLCBsYXRlciwgdW5pdHMpO1xuXG4gIGNvbnN0IHJlbWFpbmluZ01pbGxpcyA9IGxhdGVyIC0gY3Vyc29yO1xuXG4gIGNvbnN0IGxvd2VyT3JkZXJVbml0cyA9IHVuaXRzLmZpbHRlcihcbiAgICAodSkgPT4gW1wiaG91cnNcIiwgXCJtaW51dGVzXCIsIFwic2Vjb25kc1wiLCBcIm1pbGxpc2Vjb25kc1wiXS5pbmRleE9mKHUpID49IDBcbiAgKTtcblxuICBpZiAobG93ZXJPcmRlclVuaXRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChoaWdoV2F0ZXIgPCBsYXRlcikge1xuICAgICAgaGlnaFdhdGVyID0gY3Vyc29yLnBsdXMoeyBbbG93ZXN0T3JkZXJdOiAxIH0pO1xuICAgIH1cblxuICAgIGlmIChoaWdoV2F0ZXIgIT09IGN1cnNvcikge1xuICAgICAgcmVzdWx0c1tsb3dlc3RPcmRlcl0gPSAocmVzdWx0c1tsb3dlc3RPcmRlcl0gfHwgMCkgKyByZW1haW5pbmdNaWxsaXMgLyAoaGlnaFdhdGVyIC0gY3Vyc29yKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBkdXJhdGlvbiA9IER1cmF0aW9uLmZyb21PYmplY3QocmVzdWx0cywgb3B0cyk7XG5cbiAgaWYgKGxvd2VyT3JkZXJVbml0cy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIER1cmF0aW9uLmZyb21NaWxsaXMocmVtYWluaW5nTWlsbGlzLCBvcHRzKVxuICAgICAgLnNoaWZ0VG8oLi4ubG93ZXJPcmRlclVuaXRzKVxuICAgICAgLnBsdXMoZHVyYXRpb24pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBkdXJhdGlvbjtcbiAgfVxufVxuIiwgImNvbnN0IG51bWJlcmluZ1N5c3RlbXMgPSB7XG4gIGFyYWI6IFwiW1xcdTA2NjAtXFx1MDY2OV1cIixcbiAgYXJhYmV4dDogXCJbXFx1MDZGMC1cXHUwNkY5XVwiLFxuICBiYWxpOiBcIltcXHUxQjUwLVxcdTFCNTldXCIsXG4gIGJlbmc6IFwiW1xcdTA5RTYtXFx1MDlFRl1cIixcbiAgZGV2YTogXCJbXFx1MDk2Ni1cXHUwOTZGXVwiLFxuICBmdWxsd2lkZTogXCJbXFx1RkYxMC1cXHVGRjE5XVwiLFxuICBndWpyOiBcIltcXHUwQUU2LVxcdTBBRUZdXCIsXG4gIGhhbmlkZWM6IFwiW+OAh3zkuIB85LqMfOS4iXzlm5t85LqUfOWFrXzkuIN85YWrfOS5nV1cIixcbiAga2htcjogXCJbXFx1MTdFMC1cXHUxN0U5XVwiLFxuICBrbmRhOiBcIltcXHUwQ0U2LVxcdTBDRUZdXCIsXG4gIGxhb286IFwiW1xcdTBFRDAtXFx1MEVEOV1cIixcbiAgbGltYjogXCJbXFx1MTk0Ni1cXHUxOTRGXVwiLFxuICBtbHltOiBcIltcXHUwRDY2LVxcdTBENkZdXCIsXG4gIG1vbmc6IFwiW1xcdTE4MTAtXFx1MTgxOV1cIixcbiAgbXltcjogXCJbXFx1MTA0MC1cXHUxMDQ5XVwiLFxuICBvcnlhOiBcIltcXHUwQjY2LVxcdTBCNkZdXCIsXG4gIHRhbWxkZWM6IFwiW1xcdTBCRTYtXFx1MEJFRl1cIixcbiAgdGVsdTogXCJbXFx1MEM2Ni1cXHUwQzZGXVwiLFxuICB0aGFpOiBcIltcXHUwRTUwLVxcdTBFNTldXCIsXG4gIHRpYnQ6IFwiW1xcdTBGMjAtXFx1MEYyOV1cIixcbiAgbGF0bjogXCJcXFxcZFwiLFxufTtcblxuY29uc3QgbnVtYmVyaW5nU3lzdGVtc1VURjE2ID0ge1xuICBhcmFiOiBbMTYzMiwgMTY0MV0sXG4gIGFyYWJleHQ6IFsxNzc2LCAxNzg1XSxcbiAgYmFsaTogWzY5OTIsIDcwMDFdLFxuICBiZW5nOiBbMjUzNCwgMjU0M10sXG4gIGRldmE6IFsyNDA2LCAyNDE1XSxcbiAgZnVsbHdpZGU6IFs2NTI5NiwgNjUzMDNdLFxuICBndWpyOiBbMjc5MCwgMjc5OV0sXG4gIGtobXI6IFs2MTEyLCA2MTIxXSxcbiAga25kYTogWzMzMDIsIDMzMTFdLFxuICBsYW9vOiBbMzc5MiwgMzgwMV0sXG4gIGxpbWI6IFs2NDcwLCA2NDc5XSxcbiAgbWx5bTogWzM0MzAsIDM0MzldLFxuICBtb25nOiBbNjE2MCwgNjE2OV0sXG4gIG15bXI6IFs0MTYwLCA0MTY5XSxcbiAgb3J5YTogWzI5MTgsIDI5MjddLFxuICB0YW1sZGVjOiBbMzA0NiwgMzA1NV0sXG4gIHRlbHU6IFszMTc0LCAzMTgzXSxcbiAgdGhhaTogWzM2NjQsIDM2NzNdLFxuICB0aWJ0OiBbMzg3MiwgMzg4MV0sXG59O1xuXG5jb25zdCBoYW5pZGVjQ2hhcnMgPSBudW1iZXJpbmdTeXN0ZW1zLmhhbmlkZWMucmVwbGFjZSgvW1xcW3xcXF1dL2csIFwiXCIpLnNwbGl0KFwiXCIpO1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VEaWdpdHMoc3RyKSB7XG4gIGxldCB2YWx1ZSA9IHBhcnNlSW50KHN0ciwgMTApO1xuICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgdmFsdWUgPSBcIlwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgIGlmIChzdHJbaV0uc2VhcmNoKG51bWJlcmluZ1N5c3RlbXMuaGFuaWRlYykgIT09IC0xKSB7XG4gICAgICAgIHZhbHVlICs9IGhhbmlkZWNDaGFycy5pbmRleE9mKHN0cltpXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBudW1iZXJpbmdTeXN0ZW1zVVRGMTYpIHtcbiAgICAgICAgICBjb25zdCBbbWluLCBtYXhdID0gbnVtYmVyaW5nU3lzdGVtc1VURjE2W2tleV07XG4gICAgICAgICAgaWYgKGNvZGUgPj0gbWluICYmIGNvZGUgPD0gbWF4KSB7XG4gICAgICAgICAgICB2YWx1ZSArPSBjb2RlIC0gbWluO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpZ2l0UmVnZXgoeyBudW1iZXJpbmdTeXN0ZW0gfSwgYXBwZW5kID0gXCJcIikge1xuICByZXR1cm4gbmV3IFJlZ0V4cChgJHtudW1iZXJpbmdTeXN0ZW1zW251bWJlcmluZ1N5c3RlbSB8fCBcImxhdG5cIl19JHthcHBlbmR9YCk7XG59XG4iLCAiaW1wb3J0IHsgcGFyc2VNaWxsaXMsIGlzVW5kZWZpbmVkLCB1bnRydW5jYXRlWWVhciwgc2lnbmVkT2Zmc2V0LCBoYXNPd25Qcm9wZXJ0eSB9IGZyb20gXCIuL3V0aWwuanNcIjtcbmltcG9ydCBGb3JtYXR0ZXIgZnJvbSBcIi4vZm9ybWF0dGVyLmpzXCI7XG5pbXBvcnQgRml4ZWRPZmZzZXRab25lIGZyb20gXCIuLi96b25lcy9maXhlZE9mZnNldFpvbmUuanNcIjtcbmltcG9ydCBJQU5BWm9uZSBmcm9tIFwiLi4vem9uZXMvSUFOQVpvbmUuanNcIjtcbmltcG9ydCBEYXRlVGltZSBmcm9tIFwiLi4vZGF0ZXRpbWUuanNcIjtcbmltcG9ydCB7IGRpZ2l0UmVnZXgsIHBhcnNlRGlnaXRzIH0gZnJvbSBcIi4vZGlnaXRzLmpzXCI7XG5pbXBvcnQgeyBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvciB9IGZyb20gXCIuLi9lcnJvcnMuanNcIjtcblxuY29uc3QgTUlTU0lOR19GVFAgPSBcIm1pc3NpbmcgSW50bC5EYXRlVGltZUZvcm1hdC5mb3JtYXRUb1BhcnRzIHN1cHBvcnRcIjtcblxuZnVuY3Rpb24gaW50VW5pdChyZWdleCwgcG9zdCA9IChpKSA9PiBpKSB7XG4gIHJldHVybiB7IHJlZ2V4LCBkZXNlcjogKFtzXSkgPT4gcG9zdChwYXJzZURpZ2l0cyhzKSkgfTtcbn1cblxuY29uc3QgTkJTUCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMTYwKTtcbmNvbnN0IHNwYWNlT3JOQlNQID0gYFsgJHtOQlNQfV1gO1xuY29uc3Qgc3BhY2VPck5CU1BSZWdFeHAgPSBuZXcgUmVnRXhwKHNwYWNlT3JOQlNQLCBcImdcIik7XG5cbmZ1bmN0aW9uIGZpeExpc3RSZWdleChzKSB7XG4gIC8vIG1ha2UgZG90cyBvcHRpb25hbCBhbmQgYWxzbyBtYWtlIHRoZW0gbGl0ZXJhbFxuICAvLyBtYWtlIHNwYWNlIGFuZCBub24gYnJlYWthYmxlIHNwYWNlIGNoYXJhY3RlcnMgaW50ZXJjaGFuZ2VhYmxlXG4gIHJldHVybiBzLnJlcGxhY2UoL1xcLi9nLCBcIlxcXFwuP1wiKS5yZXBsYWNlKHNwYWNlT3JOQlNQUmVnRXhwLCBzcGFjZU9yTkJTUCk7XG59XG5cbmZ1bmN0aW9uIHN0cmlwSW5zZW5zaXRpdml0aWVzKHMpIHtcbiAgcmV0dXJuIHNcbiAgICAucmVwbGFjZSgvXFwuL2csIFwiXCIpIC8vIGlnbm9yZSBkb3RzIHRoYXQgd2VyZSBtYWRlIG9wdGlvbmFsXG4gICAgLnJlcGxhY2Uoc3BhY2VPck5CU1BSZWdFeHAsIFwiIFwiKSAvLyBpbnRlcmNoYW5nZSBzcGFjZSBhbmQgbmJzcFxuICAgIC50b0xvd2VyQ2FzZSgpO1xufVxuXG5mdW5jdGlvbiBvbmVPZihzdHJpbmdzLCBzdGFydEluZGV4KSB7XG4gIGlmIChzdHJpbmdzID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZ2V4OiBSZWdFeHAoc3RyaW5ncy5tYXAoZml4TGlzdFJlZ2V4KS5qb2luKFwifFwiKSksXG4gICAgICBkZXNlcjogKFtzXSkgPT5cbiAgICAgICAgc3RyaW5ncy5maW5kSW5kZXgoKGkpID0+IHN0cmlwSW5zZW5zaXRpdml0aWVzKHMpID09PSBzdHJpcEluc2Vuc2l0aXZpdGllcyhpKSkgKyBzdGFydEluZGV4LFxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gb2Zmc2V0KHJlZ2V4LCBncm91cHMpIHtcbiAgcmV0dXJuIHsgcmVnZXgsIGRlc2VyOiAoWywgaCwgbV0pID0+IHNpZ25lZE9mZnNldChoLCBtKSwgZ3JvdXBzIH07XG59XG5cbmZ1bmN0aW9uIHNpbXBsZShyZWdleCkge1xuICByZXR1cm4geyByZWdleCwgZGVzZXI6IChbc10pID0+IHMgfTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlVG9rZW4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL1tcXC1cXFtcXF17fSgpKis/LixcXFxcXFxeJHwjXFxzXS9nLCBcIlxcXFwkJlwiKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gdG9rZW5cbiAqIEBwYXJhbSB7TG9jYWxlfSBsb2NcbiAqL1xuZnVuY3Rpb24gdW5pdEZvclRva2VuKHRva2VuLCBsb2MpIHtcbiAgY29uc3Qgb25lID0gZGlnaXRSZWdleChsb2MpLFxuICAgIHR3byA9IGRpZ2l0UmVnZXgobG9jLCBcInsyfVwiKSxcbiAgICB0aHJlZSA9IGRpZ2l0UmVnZXgobG9jLCBcInszfVwiKSxcbiAgICBmb3VyID0gZGlnaXRSZWdleChsb2MsIFwiezR9XCIpLFxuICAgIHNpeCA9IGRpZ2l0UmVnZXgobG9jLCBcIns2fVwiKSxcbiAgICBvbmVPclR3byA9IGRpZ2l0UmVnZXgobG9jLCBcInsxLDJ9XCIpLFxuICAgIG9uZVRvVGhyZWUgPSBkaWdpdFJlZ2V4KGxvYywgXCJ7MSwzfVwiKSxcbiAgICBvbmVUb1NpeCA9IGRpZ2l0UmVnZXgobG9jLCBcInsxLDZ9XCIpLFxuICAgIG9uZVRvTmluZSA9IGRpZ2l0UmVnZXgobG9jLCBcInsxLDl9XCIpLFxuICAgIHR3b1RvRm91ciA9IGRpZ2l0UmVnZXgobG9jLCBcInsyLDR9XCIpLFxuICAgIGZvdXJUb1NpeCA9IGRpZ2l0UmVnZXgobG9jLCBcIns0LDZ9XCIpLFxuICAgIGxpdGVyYWwgPSAodCkgPT4gKHsgcmVnZXg6IFJlZ0V4cChlc2NhcGVUb2tlbih0LnZhbCkpLCBkZXNlcjogKFtzXSkgPT4gcywgbGl0ZXJhbDogdHJ1ZSB9KSxcbiAgICB1bml0YXRlID0gKHQpID0+IHtcbiAgICAgIGlmICh0b2tlbi5saXRlcmFsKSB7XG4gICAgICAgIHJldHVybiBsaXRlcmFsKHQpO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh0LnZhbCkge1xuICAgICAgICAvLyBlcmFcbiAgICAgICAgY2FzZSBcIkdcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLmVyYXMoXCJzaG9ydFwiKSwgMCk7XG4gICAgICAgIGNhc2UgXCJHR1wiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2MuZXJhcyhcImxvbmdcIiksIDApO1xuICAgICAgICAvLyB5ZWFyc1xuICAgICAgICBjYXNlIFwieVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZVRvU2l4KTtcbiAgICAgICAgY2FzZSBcInl5XCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvVG9Gb3VyLCB1bnRydW5jYXRlWWVhcik7XG4gICAgICAgIGNhc2UgXCJ5eXl5XCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQoZm91cik7XG4gICAgICAgIGNhc2UgXCJ5eXl5eVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KGZvdXJUb1NpeCk7XG4gICAgICAgIGNhc2UgXCJ5eXl5eXlcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChzaXgpO1xuICAgICAgICAvLyBtb250aHNcbiAgICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJNTVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIGNhc2UgXCJNTU1cIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLm1vbnRocyhcInNob3J0XCIsIHRydWUpLCAxKTtcbiAgICAgICAgY2FzZSBcIk1NTU1cIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLm1vbnRocyhcImxvbmdcIiwgdHJ1ZSksIDEpO1xuICAgICAgICBjYXNlIFwiTFwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcIkxMXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgICAgY2FzZSBcIkxMTFwiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2MubW9udGhzKFwic2hvcnRcIiwgZmFsc2UpLCAxKTtcbiAgICAgICAgY2FzZSBcIkxMTExcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLm1vbnRocyhcImxvbmdcIiwgZmFsc2UpLCAxKTtcbiAgICAgICAgLy8gZGF0ZXNcbiAgICAgICAgY2FzZSBcImRcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJkZFwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIC8vIG9yZGluYWxzXG4gICAgICAgIGNhc2UgXCJvXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lVG9UaHJlZSk7XG4gICAgICAgIGNhc2UgXCJvb29cIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0aHJlZSk7XG4gICAgICAgIC8vIHRpbWVcbiAgICAgICAgY2FzZSBcIkhIXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgICAgY2FzZSBcIkhcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJoaFwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIGNhc2UgXCJoXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwibW1cIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICBjYXNlIFwibVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcInFcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJxcVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIGNhc2UgXCJzXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwic3NcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICBjYXNlIFwiU1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZVRvVGhyZWUpO1xuICAgICAgICBjYXNlIFwiU1NTXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodGhyZWUpO1xuICAgICAgICBjYXNlIFwidVwiOlxuICAgICAgICAgIHJldHVybiBzaW1wbGUob25lVG9OaW5lKTtcbiAgICAgICAgY2FzZSBcInV1XCI6XG4gICAgICAgICAgcmV0dXJuIHNpbXBsZShvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJ1dXVcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmUpO1xuICAgICAgICAvLyBtZXJpZGllbVxuICAgICAgICBjYXNlIFwiYVwiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2MubWVyaWRpZW1zKCksIDApO1xuICAgICAgICAvLyB3ZWVrWWVhciAoaylcbiAgICAgICAgY2FzZSBcImtra2tcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChmb3VyKTtcbiAgICAgICAgY2FzZSBcImtrXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvVG9Gb3VyLCB1bnRydW5jYXRlWWVhcik7XG4gICAgICAgIC8vIHdlZWtOdW1iZXIgKFcpXG4gICAgICAgIGNhc2UgXCJXXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwiV1dcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICAvLyB3ZWVrZGF5c1xuICAgICAgICBjYXNlIFwiRVwiOlxuICAgICAgICBjYXNlIFwiY1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZSk7XG4gICAgICAgIGNhc2UgXCJFRUVcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLndlZWtkYXlzKFwic2hvcnRcIiwgZmFsc2UpLCAxKTtcbiAgICAgICAgY2FzZSBcIkVFRUVcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLndlZWtkYXlzKFwibG9uZ1wiLCBmYWxzZSksIDEpO1xuICAgICAgICBjYXNlIFwiY2NjXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy53ZWVrZGF5cyhcInNob3J0XCIsIHRydWUpLCAxKTtcbiAgICAgICAgY2FzZSBcImNjY2NcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLndlZWtkYXlzKFwibG9uZ1wiLCB0cnVlKSwgMSk7XG4gICAgICAgIC8vIG9mZnNldC96b25lXG4gICAgICAgIGNhc2UgXCJaXCI6XG4gICAgICAgIGNhc2UgXCJaWlwiOlxuICAgICAgICAgIHJldHVybiBvZmZzZXQobmV3IFJlZ0V4cChgKFsrLV0ke29uZU9yVHdvLnNvdXJjZX0pKD86Oigke3R3by5zb3VyY2V9KSk/YCksIDIpO1xuICAgICAgICBjYXNlIFwiWlpaXCI6XG4gICAgICAgICAgcmV0dXJuIG9mZnNldChuZXcgUmVnRXhwKGAoWystXSR7b25lT3JUd28uc291cmNlfSkoJHt0d28uc291cmNlfSk/YCksIDIpO1xuICAgICAgICAvLyB3ZSBkb24ndCBzdXBwb3J0IFpaWlogKFBTVCkgb3IgWlpaWlogKFBhY2lmaWMgU3RhbmRhcmQgVGltZSkgaW4gcGFyc2luZ1xuICAgICAgICAvLyBiZWNhdXNlIHdlIGRvbid0IGhhdmUgYW55IHdheSB0byBmaWd1cmUgb3V0IHdoYXQgdGhleSBhcmVcbiAgICAgICAgY2FzZSBcInpcIjpcbiAgICAgICAgICByZXR1cm4gc2ltcGxlKC9bYS16XystL117MSwyNTZ9Py9pKTtcbiAgICAgICAgLy8gdGhpcyBzcGVjaWFsLWNhc2UgXCJ0b2tlblwiIHJlcHJlc2VudHMgYSBwbGFjZSB3aGVyZSBhIG1hY3JvLXRva2VuIGV4cGFuZGVkIGludG8gYSB3aGl0ZS1zcGFjZSBsaXRlcmFsXG4gICAgICAgIC8vIGluIHRoaXMgY2FzZSB3ZSBhY2NlcHQgYW55IG5vbi1uZXdsaW5lIHdoaXRlLXNwYWNlXG4gICAgICAgIGNhc2UgXCIgXCI6XG4gICAgICAgICAgcmV0dXJuIHNpbXBsZSgvW15cXFNcXG5cXHJdLyk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGxpdGVyYWwodCk7XG4gICAgICB9XG4gICAgfTtcblxuICBjb25zdCB1bml0ID0gdW5pdGF0ZSh0b2tlbikgfHwge1xuICAgIGludmFsaWRSZWFzb246IE1JU1NJTkdfRlRQLFxuICB9O1xuXG4gIHVuaXQudG9rZW4gPSB0b2tlbjtcblxuICByZXR1cm4gdW5pdDtcbn1cblxuY29uc3QgcGFydFR5cGVTdHlsZVRvVG9rZW5WYWwgPSB7XG4gIHllYXI6IHtcbiAgICBcIjItZGlnaXRcIjogXCJ5eVwiLFxuICAgIG51bWVyaWM6IFwieXl5eXlcIixcbiAgfSxcbiAgbW9udGg6IHtcbiAgICBudW1lcmljOiBcIk1cIixcbiAgICBcIjItZGlnaXRcIjogXCJNTVwiLFxuICAgIHNob3J0OiBcIk1NTVwiLFxuICAgIGxvbmc6IFwiTU1NTVwiLFxuICB9LFxuICBkYXk6IHtcbiAgICBudW1lcmljOiBcImRcIixcbiAgICBcIjItZGlnaXRcIjogXCJkZFwiLFxuICB9LFxuICB3ZWVrZGF5OiB7XG4gICAgc2hvcnQ6IFwiRUVFXCIsXG4gICAgbG9uZzogXCJFRUVFXCIsXG4gIH0sXG4gIGRheXBlcmlvZDogXCJhXCIsXG4gIGRheVBlcmlvZDogXCJhXCIsXG4gIGhvdXIxMjoge1xuICAgIG51bWVyaWM6IFwiaFwiLFxuICAgIFwiMi1kaWdpdFwiOiBcImhoXCIsXG4gIH0sXG4gIGhvdXIyNDoge1xuICAgIG51bWVyaWM6IFwiSFwiLFxuICAgIFwiMi1kaWdpdFwiOiBcIkhIXCIsXG4gIH0sXG4gIG1pbnV0ZToge1xuICAgIG51bWVyaWM6IFwibVwiLFxuICAgIFwiMi1kaWdpdFwiOiBcIm1tXCIsXG4gIH0sXG4gIHNlY29uZDoge1xuICAgIG51bWVyaWM6IFwic1wiLFxuICAgIFwiMi1kaWdpdFwiOiBcInNzXCIsXG4gIH0sXG4gIHRpbWVab25lTmFtZToge1xuICAgIGxvbmc6IFwiWlpaWlpcIixcbiAgICBzaG9ydDogXCJaWlpcIixcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRva2VuRm9yUGFydChwYXJ0LCBmb3JtYXRPcHRzLCByZXNvbHZlZE9wdHMpIHtcbiAgY29uc3QgeyB0eXBlLCB2YWx1ZSB9ID0gcGFydDtcblxuICBpZiAodHlwZSA9PT0gXCJsaXRlcmFsXCIpIHtcbiAgICBjb25zdCBpc1NwYWNlID0gL15cXHMrJC8udGVzdCh2YWx1ZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpdGVyYWw6ICFpc1NwYWNlLFxuICAgICAgdmFsOiBpc1NwYWNlID8gXCIgXCIgOiB2YWx1ZSxcbiAgICB9O1xuICB9XG5cbiAgY29uc3Qgc3R5bGUgPSBmb3JtYXRPcHRzW3R5cGVdO1xuXG4gIC8vIFRoZSB1c2VyIG1pZ2h0IGhhdmUgZXhwbGljaXRseSBzcGVjaWZpZWQgaG91cjEyIG9yIGhvdXJDeWNsZVxuICAvLyBpZiBzbywgcmVzcGVjdCB0aGVpciBkZWNpc2lvblxuICAvLyBpZiBub3QsIHJlZmVyIGJhY2sgdG8gdGhlIHJlc29sdmVkT3B0cywgd2hpY2ggYXJlIGJhc2VkIG9uIHRoZSBsb2NhbGVcbiAgbGV0IGFjdHVhbFR5cGUgPSB0eXBlO1xuICBpZiAodHlwZSA9PT0gXCJob3VyXCIpIHtcbiAgICBpZiAoZm9ybWF0T3B0cy5ob3VyMTIgIT0gbnVsbCkge1xuICAgICAgYWN0dWFsVHlwZSA9IGZvcm1hdE9wdHMuaG91cjEyID8gXCJob3VyMTJcIiA6IFwiaG91cjI0XCI7XG4gICAgfSBlbHNlIGlmIChmb3JtYXRPcHRzLmhvdXJDeWNsZSAhPSBudWxsKSB7XG4gICAgICBpZiAoZm9ybWF0T3B0cy5ob3VyQ3ljbGUgPT09IFwiaDExXCIgfHwgZm9ybWF0T3B0cy5ob3VyQ3ljbGUgPT09IFwiaDEyXCIpIHtcbiAgICAgICAgYWN0dWFsVHlwZSA9IFwiaG91cjEyXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3R1YWxUeXBlID0gXCJob3VyMjRcIjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdG9rZW5zIG9ubHkgZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIDI0IGhvdXJzIG9yIG5vdCxcbiAgICAgIC8vIHNvIHdlIGRvIG5vdCBuZWVkIHRvIGNoZWNrIGhvdXJDeWNsZSBoZXJlLCB3aGljaCBpcyBsZXNzIHN1cHBvcnRlZCBhbnl3YXlzXG4gICAgICBhY3R1YWxUeXBlID0gcmVzb2x2ZWRPcHRzLmhvdXIxMiA/IFwiaG91cjEyXCIgOiBcImhvdXIyNFwiO1xuICAgIH1cbiAgfVxuICBsZXQgdmFsID0gcGFydFR5cGVTdHlsZVRvVG9rZW5WYWxbYWN0dWFsVHlwZV07XG4gIGlmICh0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiKSB7XG4gICAgdmFsID0gdmFsW3N0eWxlXTtcbiAgfVxuXG4gIGlmICh2YWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGl0ZXJhbDogZmFsc2UsXG4gICAgICB2YWwsXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUmVnZXgodW5pdHMpIHtcbiAgY29uc3QgcmUgPSB1bml0cy5tYXAoKHUpID0+IHUucmVnZXgpLnJlZHVjZSgoZiwgcikgPT4gYCR7Zn0oJHtyLnNvdXJjZX0pYCwgXCJcIik7XG4gIHJldHVybiBbYF4ke3JlfSRgLCB1bml0c107XG59XG5cbmZ1bmN0aW9uIG1hdGNoKGlucHV0LCByZWdleCwgaGFuZGxlcnMpIHtcbiAgY29uc3QgbWF0Y2hlcyA9IGlucHV0Lm1hdGNoKHJlZ2V4KTtcblxuICBpZiAobWF0Y2hlcykge1xuICAgIGNvbnN0IGFsbCA9IHt9O1xuICAgIGxldCBtYXRjaEluZGV4ID0gMTtcbiAgICBmb3IgKGNvbnN0IGkgaW4gaGFuZGxlcnMpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eShoYW5kbGVycywgaSkpIHtcbiAgICAgICAgY29uc3QgaCA9IGhhbmRsZXJzW2ldLFxuICAgICAgICAgIGdyb3VwcyA9IGguZ3JvdXBzID8gaC5ncm91cHMgKyAxIDogMTtcbiAgICAgICAgaWYgKCFoLmxpdGVyYWwgJiYgaC50b2tlbikge1xuICAgICAgICAgIGFsbFtoLnRva2VuLnZhbFswXV0gPSBoLmRlc2VyKG1hdGNoZXMuc2xpY2UobWF0Y2hJbmRleCwgbWF0Y2hJbmRleCArIGdyb3VwcykpO1xuICAgICAgICB9XG4gICAgICAgIG1hdGNoSW5kZXggKz0gZ3JvdXBzO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW21hdGNoZXMsIGFsbF07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFttYXRjaGVzLCB7fV07XG4gIH1cbn1cblxuZnVuY3Rpb24gZGF0ZVRpbWVGcm9tTWF0Y2hlcyhtYXRjaGVzKSB7XG4gIGNvbnN0IHRvRmllbGQgPSAodG9rZW4pID0+IHtcbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICBjYXNlIFwiU1wiOlxuICAgICAgICByZXR1cm4gXCJtaWxsaXNlY29uZFwiO1xuICAgICAgY2FzZSBcInNcIjpcbiAgICAgICAgcmV0dXJuIFwic2Vjb25kXCI7XG4gICAgICBjYXNlIFwibVwiOlxuICAgICAgICByZXR1cm4gXCJtaW51dGVcIjtcbiAgICAgIGNhc2UgXCJoXCI6XG4gICAgICBjYXNlIFwiSFwiOlxuICAgICAgICByZXR1cm4gXCJob3VyXCI7XG4gICAgICBjYXNlIFwiZFwiOlxuICAgICAgICByZXR1cm4gXCJkYXlcIjtcbiAgICAgIGNhc2UgXCJvXCI6XG4gICAgICAgIHJldHVybiBcIm9yZGluYWxcIjtcbiAgICAgIGNhc2UgXCJMXCI6XG4gICAgICBjYXNlIFwiTVwiOlxuICAgICAgICByZXR1cm4gXCJtb250aFwiO1xuICAgICAgY2FzZSBcInlcIjpcbiAgICAgICAgcmV0dXJuIFwieWVhclwiO1xuICAgICAgY2FzZSBcIkVcIjpcbiAgICAgIGNhc2UgXCJjXCI6XG4gICAgICAgIHJldHVybiBcIndlZWtkYXlcIjtcbiAgICAgIGNhc2UgXCJXXCI6XG4gICAgICAgIHJldHVybiBcIndlZWtOdW1iZXJcIjtcbiAgICAgIGNhc2UgXCJrXCI6XG4gICAgICAgIHJldHVybiBcIndlZWtZZWFyXCI7XG4gICAgICBjYXNlIFwicVwiOlxuICAgICAgICByZXR1cm4gXCJxdWFydGVyXCI7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgbGV0IHpvbmUgPSBudWxsO1xuICBsZXQgc3BlY2lmaWNPZmZzZXQ7XG4gIGlmICghaXNVbmRlZmluZWQobWF0Y2hlcy56KSkge1xuICAgIHpvbmUgPSBJQU5BWm9uZS5jcmVhdGUobWF0Y2hlcy56KTtcbiAgfVxuXG4gIGlmICghaXNVbmRlZmluZWQobWF0Y2hlcy5aKSkge1xuICAgIGlmICghem9uZSkge1xuICAgICAgem9uZSA9IG5ldyBGaXhlZE9mZnNldFpvbmUobWF0Y2hlcy5aKTtcbiAgICB9XG4gICAgc3BlY2lmaWNPZmZzZXQgPSBtYXRjaGVzLlo7XG4gIH1cblxuICBpZiAoIWlzVW5kZWZpbmVkKG1hdGNoZXMucSkpIHtcbiAgICBtYXRjaGVzLk0gPSAobWF0Y2hlcy5xIC0gMSkgKiAzICsgMTtcbiAgfVxuXG4gIGlmICghaXNVbmRlZmluZWQobWF0Y2hlcy5oKSkge1xuICAgIGlmIChtYXRjaGVzLmggPCAxMiAmJiBtYXRjaGVzLmEgPT09IDEpIHtcbiAgICAgIG1hdGNoZXMuaCArPSAxMjtcbiAgICB9IGVsc2UgaWYgKG1hdGNoZXMuaCA9PT0gMTIgJiYgbWF0Y2hlcy5hID09PSAwKSB7XG4gICAgICBtYXRjaGVzLmggPSAwO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtYXRjaGVzLkcgPT09IDAgJiYgbWF0Y2hlcy55KSB7XG4gICAgbWF0Y2hlcy55ID0gLW1hdGNoZXMueTtcbiAgfVxuXG4gIGlmICghaXNVbmRlZmluZWQobWF0Y2hlcy51KSkge1xuICAgIG1hdGNoZXMuUyA9IHBhcnNlTWlsbGlzKG1hdGNoZXMudSk7XG4gIH1cblxuICBjb25zdCB2YWxzID0gT2JqZWN0LmtleXMobWF0Y2hlcykucmVkdWNlKChyLCBrKSA9PiB7XG4gICAgY29uc3QgZiA9IHRvRmllbGQoayk7XG4gICAgaWYgKGYpIHtcbiAgICAgIHJbZl0gPSBtYXRjaGVzW2tdO1xuICAgIH1cblxuICAgIHJldHVybiByO1xuICB9LCB7fSk7XG5cbiAgcmV0dXJuIFt2YWxzLCB6b25lLCBzcGVjaWZpY09mZnNldF07XG59XG5cbmxldCBkdW1teURhdGVUaW1lQ2FjaGUgPSBudWxsO1xuXG5mdW5jdGlvbiBnZXREdW1teURhdGVUaW1lKCkge1xuICBpZiAoIWR1bW15RGF0ZVRpbWVDYWNoZSkge1xuICAgIGR1bW15RGF0ZVRpbWVDYWNoZSA9IERhdGVUaW1lLmZyb21NaWxsaXMoMTU1NTU1NTU1NTU1NSk7XG4gIH1cblxuICByZXR1cm4gZHVtbXlEYXRlVGltZUNhY2hlO1xufVxuXG5mdW5jdGlvbiBtYXliZUV4cGFuZE1hY3JvVG9rZW4odG9rZW4sIGxvY2FsZSkge1xuICBpZiAodG9rZW4ubGl0ZXJhbCkge1xuICAgIHJldHVybiB0b2tlbjtcbiAgfVxuXG4gIGNvbnN0IGZvcm1hdE9wdHMgPSBGb3JtYXR0ZXIubWFjcm9Ub2tlblRvRm9ybWF0T3B0cyh0b2tlbi52YWwpO1xuICBjb25zdCB0b2tlbnMgPSBmb3JtYXRPcHRzVG9Ub2tlbnMoZm9ybWF0T3B0cywgbG9jYWxlKTtcblxuICBpZiAodG9rZW5zID09IG51bGwgfHwgdG9rZW5zLmluY2x1ZGVzKHVuZGVmaW5lZCkpIHtcbiAgICByZXR1cm4gdG9rZW47XG4gIH1cblxuICByZXR1cm4gdG9rZW5zO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kTWFjcm9Ub2tlbnModG9rZW5zLCBsb2NhbGUpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQoLi4udG9rZW5zLm1hcCgodCkgPT4gbWF5YmVFeHBhbmRNYWNyb1Rva2VuKHQsIGxvY2FsZSkpKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBleHBsYWluRnJvbVRva2Vucyhsb2NhbGUsIGlucHV0LCBmb3JtYXQpIHtcbiAgY29uc3QgdG9rZW5zID0gZXhwYW5kTWFjcm9Ub2tlbnMoRm9ybWF0dGVyLnBhcnNlRm9ybWF0KGZvcm1hdCksIGxvY2FsZSksXG4gICAgdW5pdHMgPSB0b2tlbnMubWFwKCh0KSA9PiB1bml0Rm9yVG9rZW4odCwgbG9jYWxlKSksXG4gICAgZGlzcXVhbGlmeWluZ1VuaXQgPSB1bml0cy5maW5kKCh0KSA9PiB0LmludmFsaWRSZWFzb24pO1xuXG4gIGlmIChkaXNxdWFsaWZ5aW5nVW5pdCkge1xuICAgIHJldHVybiB7IGlucHV0LCB0b2tlbnMsIGludmFsaWRSZWFzb246IGRpc3F1YWxpZnlpbmdVbml0LmludmFsaWRSZWFzb24gfTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBbcmVnZXhTdHJpbmcsIGhhbmRsZXJzXSA9IGJ1aWxkUmVnZXgodW5pdHMpLFxuICAgICAgcmVnZXggPSBSZWdFeHAocmVnZXhTdHJpbmcsIFwiaVwiKSxcbiAgICAgIFtyYXdNYXRjaGVzLCBtYXRjaGVzXSA9IG1hdGNoKGlucHV0LCByZWdleCwgaGFuZGxlcnMpLFxuICAgICAgW3Jlc3VsdCwgem9uZSwgc3BlY2lmaWNPZmZzZXRdID0gbWF0Y2hlc1xuICAgICAgICA/IGRhdGVUaW1lRnJvbU1hdGNoZXMobWF0Y2hlcylcbiAgICAgICAgOiBbbnVsbCwgbnVsbCwgdW5kZWZpbmVkXTtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkobWF0Y2hlcywgXCJhXCIpICYmIGhhc093blByb3BlcnR5KG1hdGNoZXMsIFwiSFwiKSkge1xuICAgICAgdGhyb3cgbmV3IENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yKFxuICAgICAgICBcIkNhbid0IGluY2x1ZGUgbWVyaWRpZW0gd2hlbiBzcGVjaWZ5aW5nIDI0LWhvdXIgZm9ybWF0XCJcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7IGlucHV0LCB0b2tlbnMsIHJlZ2V4LCByYXdNYXRjaGVzLCBtYXRjaGVzLCByZXN1bHQsIHpvbmUsIHNwZWNpZmljT2Zmc2V0IH07XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRnJvbVRva2Vucyhsb2NhbGUsIGlucHV0LCBmb3JtYXQpIHtcbiAgY29uc3QgeyByZXN1bHQsIHpvbmUsIHNwZWNpZmljT2Zmc2V0LCBpbnZhbGlkUmVhc29uIH0gPSBleHBsYWluRnJvbVRva2Vucyhsb2NhbGUsIGlucHV0LCBmb3JtYXQpO1xuICByZXR1cm4gW3Jlc3VsdCwgem9uZSwgc3BlY2lmaWNPZmZzZXQsIGludmFsaWRSZWFzb25dO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0T3B0c1RvVG9rZW5zKGZvcm1hdE9wdHMsIGxvY2FsZSkge1xuICBpZiAoIWZvcm1hdE9wdHMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IGZvcm1hdHRlciA9IEZvcm1hdHRlci5jcmVhdGUobG9jYWxlLCBmb3JtYXRPcHRzKTtcbiAgY29uc3QgZGYgPSBmb3JtYXR0ZXIuZHRGb3JtYXR0ZXIoZ2V0RHVtbXlEYXRlVGltZSgpKTtcbiAgY29uc3QgcGFydHMgPSBkZi5mb3JtYXRUb1BhcnRzKCk7XG4gIGNvbnN0IHJlc29sdmVkT3B0cyA9IGRmLnJlc29sdmVkT3B0aW9ucygpO1xuICByZXR1cm4gcGFydHMubWFwKChwKSA9PiB0b2tlbkZvclBhcnQocCwgZm9ybWF0T3B0cywgcmVzb2x2ZWRPcHRzKSk7XG59XG4iLCAiaW1wb3J0IHtcbiAgaW50ZWdlckJldHdlZW4sXG4gIGlzTGVhcFllYXIsXG4gIHRpbWVPYmplY3QsXG4gIGRheXNJblllYXIsXG4gIGRheXNJbk1vbnRoLFxuICB3ZWVrc0luV2Vla1llYXIsXG4gIGlzSW50ZWdlcixcbn0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuaW1wb3J0IEludmFsaWQgZnJvbSBcIi4vaW52YWxpZC5qc1wiO1xuXG5jb25zdCBub25MZWFwTGFkZGVyID0gWzAsIDMxLCA1OSwgOTAsIDEyMCwgMTUxLCAxODEsIDIxMiwgMjQzLCAyNzMsIDMwNCwgMzM0XSxcbiAgbGVhcExhZGRlciA9IFswLCAzMSwgNjAsIDkxLCAxMjEsIDE1MiwgMTgyLCAyMTMsIDI0NCwgMjc0LCAzMDUsIDMzNV07XG5cbmZ1bmN0aW9uIHVuaXRPdXRPZlJhbmdlKHVuaXQsIHZhbHVlKSB7XG4gIHJldHVybiBuZXcgSW52YWxpZChcbiAgICBcInVuaXQgb3V0IG9mIHJhbmdlXCIsXG4gICAgYHlvdSBzcGVjaWZpZWQgJHt2YWx1ZX0gKG9mIHR5cGUgJHt0eXBlb2YgdmFsdWV9KSBhcyBhICR7dW5pdH0sIHdoaWNoIGlzIGludmFsaWRgXG4gICk7XG59XG5cbmZ1bmN0aW9uIGRheU9mV2Vlayh5ZWFyLCBtb250aCwgZGF5KSB7XG4gIGNvbnN0IGQgPSBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCAtIDEsIGRheSkpO1xuXG4gIGlmICh5ZWFyIDwgMTAwICYmIHllYXIgPj0gMCkge1xuICAgIGQuc2V0VVRDRnVsbFllYXIoZC5nZXRVVENGdWxsWWVhcigpIC0gMTkwMCk7XG4gIH1cblxuICBjb25zdCBqcyA9IGQuZ2V0VVRDRGF5KCk7XG5cbiAgcmV0dXJuIGpzID09PSAwID8gNyA6IGpzO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlT3JkaW5hbCh5ZWFyLCBtb250aCwgZGF5KSB7XG4gIHJldHVybiBkYXkgKyAoaXNMZWFwWWVhcih5ZWFyKSA/IGxlYXBMYWRkZXIgOiBub25MZWFwTGFkZGVyKVttb250aCAtIDFdO1xufVxuXG5mdW5jdGlvbiB1bmNvbXB1dGVPcmRpbmFsKHllYXIsIG9yZGluYWwpIHtcbiAgY29uc3QgdGFibGUgPSBpc0xlYXBZZWFyKHllYXIpID8gbGVhcExhZGRlciA6IG5vbkxlYXBMYWRkZXIsXG4gICAgbW9udGgwID0gdGFibGUuZmluZEluZGV4KChpKSA9PiBpIDwgb3JkaW5hbCksXG4gICAgZGF5ID0gb3JkaW5hbCAtIHRhYmxlW21vbnRoMF07XG4gIHJldHVybiB7IG1vbnRoOiBtb250aDAgKyAxLCBkYXkgfTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBncmVnb3JpYW5Ub1dlZWsoZ3JlZ09iaikge1xuICBjb25zdCB7IHllYXIsIG1vbnRoLCBkYXkgfSA9IGdyZWdPYmosXG4gICAgb3JkaW5hbCA9IGNvbXB1dGVPcmRpbmFsKHllYXIsIG1vbnRoLCBkYXkpLFxuICAgIHdlZWtkYXkgPSBkYXlPZldlZWsoeWVhciwgbW9udGgsIGRheSk7XG5cbiAgbGV0IHdlZWtOdW1iZXIgPSBNYXRoLmZsb29yKChvcmRpbmFsIC0gd2Vla2RheSArIDEwKSAvIDcpLFxuICAgIHdlZWtZZWFyO1xuXG4gIGlmICh3ZWVrTnVtYmVyIDwgMSkge1xuICAgIHdlZWtZZWFyID0geWVhciAtIDE7XG4gICAgd2Vla051bWJlciA9IHdlZWtzSW5XZWVrWWVhcih3ZWVrWWVhcik7XG4gIH0gZWxzZSBpZiAod2Vla051bWJlciA+IHdlZWtzSW5XZWVrWWVhcih5ZWFyKSkge1xuICAgIHdlZWtZZWFyID0geWVhciArIDE7XG4gICAgd2Vla051bWJlciA9IDE7XG4gIH0gZWxzZSB7XG4gICAgd2Vla1llYXIgPSB5ZWFyO1xuICB9XG5cbiAgcmV0dXJuIHsgd2Vla1llYXIsIHdlZWtOdW1iZXIsIHdlZWtkYXksIC4uLnRpbWVPYmplY3QoZ3JlZ09iaikgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdlZWtUb0dyZWdvcmlhbih3ZWVrRGF0YSkge1xuICBjb25zdCB7IHdlZWtZZWFyLCB3ZWVrTnVtYmVyLCB3ZWVrZGF5IH0gPSB3ZWVrRGF0YSxcbiAgICB3ZWVrZGF5T2ZKYW40ID0gZGF5T2ZXZWVrKHdlZWtZZWFyLCAxLCA0KSxcbiAgICB5ZWFySW5EYXlzID0gZGF5c0luWWVhcih3ZWVrWWVhcik7XG5cbiAgbGV0IG9yZGluYWwgPSB3ZWVrTnVtYmVyICogNyArIHdlZWtkYXkgLSB3ZWVrZGF5T2ZKYW40IC0gMyxcbiAgICB5ZWFyO1xuXG4gIGlmIChvcmRpbmFsIDwgMSkge1xuICAgIHllYXIgPSB3ZWVrWWVhciAtIDE7XG4gICAgb3JkaW5hbCArPSBkYXlzSW5ZZWFyKHllYXIpO1xuICB9IGVsc2UgaWYgKG9yZGluYWwgPiB5ZWFySW5EYXlzKSB7XG4gICAgeWVhciA9IHdlZWtZZWFyICsgMTtcbiAgICBvcmRpbmFsIC09IGRheXNJblllYXIod2Vla1llYXIpO1xuICB9IGVsc2Uge1xuICAgIHllYXIgPSB3ZWVrWWVhcjtcbiAgfVxuXG4gIGNvbnN0IHsgbW9udGgsIGRheSB9ID0gdW5jb21wdXRlT3JkaW5hbCh5ZWFyLCBvcmRpbmFsKTtcbiAgcmV0dXJuIHsgeWVhciwgbW9udGgsIGRheSwgLi4udGltZU9iamVjdCh3ZWVrRGF0YSkgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdyZWdvcmlhblRvT3JkaW5hbChncmVnRGF0YSkge1xuICBjb25zdCB7IHllYXIsIG1vbnRoLCBkYXkgfSA9IGdyZWdEYXRhO1xuICBjb25zdCBvcmRpbmFsID0gY29tcHV0ZU9yZGluYWwoeWVhciwgbW9udGgsIGRheSk7XG4gIHJldHVybiB7IHllYXIsIG9yZGluYWwsIC4uLnRpbWVPYmplY3QoZ3JlZ0RhdGEpIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvcmRpbmFsVG9HcmVnb3JpYW4ob3JkaW5hbERhdGEpIHtcbiAgY29uc3QgeyB5ZWFyLCBvcmRpbmFsIH0gPSBvcmRpbmFsRGF0YTtcbiAgY29uc3QgeyBtb250aCwgZGF5IH0gPSB1bmNvbXB1dGVPcmRpbmFsKHllYXIsIG9yZGluYWwpO1xuICByZXR1cm4geyB5ZWFyLCBtb250aCwgZGF5LCAuLi50aW1lT2JqZWN0KG9yZGluYWxEYXRhKSB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzSW52YWxpZFdlZWtEYXRhKG9iaikge1xuICBjb25zdCB2YWxpZFllYXIgPSBpc0ludGVnZXIob2JqLndlZWtZZWFyKSxcbiAgICB2YWxpZFdlZWsgPSBpbnRlZ2VyQmV0d2VlbihvYmoud2Vla051bWJlciwgMSwgd2Vla3NJbldlZWtZZWFyKG9iai53ZWVrWWVhcikpLFxuICAgIHZhbGlkV2Vla2RheSA9IGludGVnZXJCZXR3ZWVuKG9iai53ZWVrZGF5LCAxLCA3KTtcblxuICBpZiAoIXZhbGlkWWVhcikge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcIndlZWtZZWFyXCIsIG9iai53ZWVrWWVhcik7XG4gIH0gZWxzZSBpZiAoIXZhbGlkV2Vlaykge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcIndlZWtcIiwgb2JqLndlZWspO1xuICB9IGVsc2UgaWYgKCF2YWxpZFdlZWtkYXkpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJ3ZWVrZGF5XCIsIG9iai53ZWVrZGF5KTtcbiAgfSBlbHNlIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0ludmFsaWRPcmRpbmFsRGF0YShvYmopIHtcbiAgY29uc3QgdmFsaWRZZWFyID0gaXNJbnRlZ2VyKG9iai55ZWFyKSxcbiAgICB2YWxpZE9yZGluYWwgPSBpbnRlZ2VyQmV0d2VlbihvYmoub3JkaW5hbCwgMSwgZGF5c0luWWVhcihvYmoueWVhcikpO1xuXG4gIGlmICghdmFsaWRZZWFyKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwieWVhclwiLCBvYmoueWVhcik7XG4gIH0gZWxzZSBpZiAoIXZhbGlkT3JkaW5hbCkge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcIm9yZGluYWxcIiwgb2JqLm9yZGluYWwpO1xuICB9IGVsc2UgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzSW52YWxpZEdyZWdvcmlhbkRhdGEob2JqKSB7XG4gIGNvbnN0IHZhbGlkWWVhciA9IGlzSW50ZWdlcihvYmoueWVhciksXG4gICAgdmFsaWRNb250aCA9IGludGVnZXJCZXR3ZWVuKG9iai5tb250aCwgMSwgMTIpLFxuICAgIHZhbGlkRGF5ID0gaW50ZWdlckJldHdlZW4ob2JqLmRheSwgMSwgZGF5c0luTW9udGgob2JqLnllYXIsIG9iai5tb250aCkpO1xuXG4gIGlmICghdmFsaWRZZWFyKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwieWVhclwiLCBvYmoueWVhcik7XG4gIH0gZWxzZSBpZiAoIXZhbGlkTW9udGgpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJtb250aFwiLCBvYmoubW9udGgpO1xuICB9IGVsc2UgaWYgKCF2YWxpZERheSkge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcImRheVwiLCBvYmouZGF5KTtcbiAgfSBlbHNlIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0ludmFsaWRUaW1lRGF0YShvYmopIHtcbiAgY29uc3QgeyBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQgfSA9IG9iajtcbiAgY29uc3QgdmFsaWRIb3VyID1cbiAgICAgIGludGVnZXJCZXR3ZWVuKGhvdXIsIDAsIDIzKSB8fFxuICAgICAgKGhvdXIgPT09IDI0ICYmIG1pbnV0ZSA9PT0gMCAmJiBzZWNvbmQgPT09IDAgJiYgbWlsbGlzZWNvbmQgPT09IDApLFxuICAgIHZhbGlkTWludXRlID0gaW50ZWdlckJldHdlZW4obWludXRlLCAwLCA1OSksXG4gICAgdmFsaWRTZWNvbmQgPSBpbnRlZ2VyQmV0d2VlbihzZWNvbmQsIDAsIDU5KSxcbiAgICB2YWxpZE1pbGxpc2Vjb25kID0gaW50ZWdlckJldHdlZW4obWlsbGlzZWNvbmQsIDAsIDk5OSk7XG5cbiAgaWYgKCF2YWxpZEhvdXIpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJob3VyXCIsIGhvdXIpO1xuICB9IGVsc2UgaWYgKCF2YWxpZE1pbnV0ZSkge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcIm1pbnV0ZVwiLCBtaW51dGUpO1xuICB9IGVsc2UgaWYgKCF2YWxpZFNlY29uZCkge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcInNlY29uZFwiLCBzZWNvbmQpO1xuICB9IGVsc2UgaWYgKCF2YWxpZE1pbGxpc2Vjb25kKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwibWlsbGlzZWNvbmRcIiwgbWlsbGlzZWNvbmQpO1xuICB9IGVsc2UgcmV0dXJuIGZhbHNlO1xufVxuIiwgImltcG9ydCBEdXJhdGlvbiBmcm9tIFwiLi9kdXJhdGlvbi5qc1wiO1xuaW1wb3J0IEludGVydmFsIGZyb20gXCIuL2ludGVydmFsLmpzXCI7XG5pbXBvcnQgU2V0dGluZ3MgZnJvbSBcIi4vc2V0dGluZ3MuanNcIjtcbmltcG9ydCBJbmZvIGZyb20gXCIuL2luZm8uanNcIjtcbmltcG9ydCBGb3JtYXR0ZXIgZnJvbSBcIi4vaW1wbC9mb3JtYXR0ZXIuanNcIjtcbmltcG9ydCBGaXhlZE9mZnNldFpvbmUgZnJvbSBcIi4vem9uZXMvZml4ZWRPZmZzZXRab25lLmpzXCI7XG5pbXBvcnQgTG9jYWxlIGZyb20gXCIuL2ltcGwvbG9jYWxlLmpzXCI7XG5pbXBvcnQge1xuICBpc1VuZGVmaW5lZCxcbiAgbWF5YmVBcnJheSxcbiAgaXNEYXRlLFxuICBpc051bWJlcixcbiAgYmVzdEJ5LFxuICBkYXlzSW5Nb250aCxcbiAgZGF5c0luWWVhcixcbiAgaXNMZWFwWWVhcixcbiAgd2Vla3NJbldlZWtZZWFyLFxuICBub3JtYWxpemVPYmplY3QsXG4gIHJvdW5kVG8sXG4gIG9ialRvTG9jYWxUUyxcbiAgcGFkU3RhcnQsXG59IGZyb20gXCIuL2ltcGwvdXRpbC5qc1wiO1xuaW1wb3J0IHsgbm9ybWFsaXplWm9uZSB9IGZyb20gXCIuL2ltcGwvem9uZVV0aWwuanNcIjtcbmltcG9ydCBkaWZmIGZyb20gXCIuL2ltcGwvZGlmZi5qc1wiO1xuaW1wb3J0IHsgcGFyc2VSRkMyODIyRGF0ZSwgcGFyc2VJU09EYXRlLCBwYXJzZUhUVFBEYXRlLCBwYXJzZVNRTCB9IGZyb20gXCIuL2ltcGwvcmVnZXhQYXJzZXIuanNcIjtcbmltcG9ydCB7XG4gIHBhcnNlRnJvbVRva2VucyxcbiAgZXhwbGFpbkZyb21Ub2tlbnMsXG4gIGZvcm1hdE9wdHNUb1Rva2VucyxcbiAgZXhwYW5kTWFjcm9Ub2tlbnMsXG59IGZyb20gXCIuL2ltcGwvdG9rZW5QYXJzZXIuanNcIjtcbmltcG9ydCB7XG4gIGdyZWdvcmlhblRvV2VlayxcbiAgd2Vla1RvR3JlZ29yaWFuLFxuICBncmVnb3JpYW5Ub09yZGluYWwsXG4gIG9yZGluYWxUb0dyZWdvcmlhbixcbiAgaGFzSW52YWxpZEdyZWdvcmlhbkRhdGEsXG4gIGhhc0ludmFsaWRXZWVrRGF0YSxcbiAgaGFzSW52YWxpZE9yZGluYWxEYXRhLFxuICBoYXNJbnZhbGlkVGltZURhdGEsXG59IGZyb20gXCIuL2ltcGwvY29udmVyc2lvbnMuanNcIjtcbmltcG9ydCAqIGFzIEZvcm1hdHMgZnJvbSBcIi4vaW1wbC9mb3JtYXRzLmpzXCI7XG5pbXBvcnQge1xuICBJbnZhbGlkQXJndW1lbnRFcnJvcixcbiAgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IsXG4gIEludmFsaWRVbml0RXJyb3IsXG4gIEludmFsaWREYXRlVGltZUVycm9yLFxufSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmltcG9ydCBJbnZhbGlkIGZyb20gXCIuL2ltcGwvaW52YWxpZC5qc1wiO1xuXG5jb25zdCBJTlZBTElEID0gXCJJbnZhbGlkIERhdGVUaW1lXCI7XG5jb25zdCBNQVhfREFURSA9IDguNjRlMTU7XG5cbmZ1bmN0aW9uIHVuc3VwcG9ydGVkWm9uZSh6b25lKSB7XG4gIHJldHVybiBuZXcgSW52YWxpZChcInVuc3VwcG9ydGVkIHpvbmVcIiwgYHRoZSB6b25lIFwiJHt6b25lLm5hbWV9XCIgaXMgbm90IHN1cHBvcnRlZGApO1xufVxuXG4vLyB3ZSBjYWNoZSB3ZWVrIGRhdGEgb24gdGhlIERUIG9iamVjdCBhbmQgdGhpcyBpbnRlcm1lZGlhdGVzIHRoZSBjYWNoZVxuZnVuY3Rpb24gcG9zc2libHlDYWNoZWRXZWVrRGF0YShkdCkge1xuICBpZiAoZHQud2Vla0RhdGEgPT09IG51bGwpIHtcbiAgICBkdC53ZWVrRGF0YSA9IGdyZWdvcmlhblRvV2VlayhkdC5jKTtcbiAgfVxuICByZXR1cm4gZHQud2Vla0RhdGE7XG59XG5cbi8vIGNsb25lIHJlYWxseSBtZWFucywgXCJtYWtlIGEgbmV3IG9iamVjdCB3aXRoIHRoZXNlIG1vZGlmaWNhdGlvbnNcIi4gYWxsIFwic2V0dGVyc1wiIHJlYWxseSB1c2UgdGhpc1xuLy8gdG8gY3JlYXRlIGEgbmV3IG9iamVjdCB3aGlsZSBvbmx5IGNoYW5naW5nIHNvbWUgb2YgdGhlIHByb3BlcnRpZXNcbmZ1bmN0aW9uIGNsb25lKGluc3QsIGFsdHMpIHtcbiAgY29uc3QgY3VycmVudCA9IHtcbiAgICB0czogaW5zdC50cyxcbiAgICB6b25lOiBpbnN0LnpvbmUsXG4gICAgYzogaW5zdC5jLFxuICAgIG86IGluc3QubyxcbiAgICBsb2M6IGluc3QubG9jLFxuICAgIGludmFsaWQ6IGluc3QuaW52YWxpZCxcbiAgfTtcbiAgcmV0dXJuIG5ldyBEYXRlVGltZSh7IC4uLmN1cnJlbnQsIC4uLmFsdHMsIG9sZDogY3VycmVudCB9KTtcbn1cblxuLy8gZmluZCB0aGUgcmlnaHQgb2Zmc2V0IGEgZ2l2ZW4gbG9jYWwgdGltZS4gVGhlIG8gaW5wdXQgaXMgb3VyIGd1ZXNzLCB3aGljaCBkZXRlcm1pbmVzIHdoaWNoXG4vLyBvZmZzZXQgd2UnbGwgcGljayBpbiBhbWJpZ3VvdXMgY2FzZXMgKGUuZy4gdGhlcmUgYXJlIHR3byAzIEFNcyBiL2MgRmFsbGJhY2sgRFNUKVxuZnVuY3Rpb24gZml4T2Zmc2V0KGxvY2FsVFMsIG8sIHR6KSB7XG4gIC8vIE91ciBVVEMgdGltZSBpcyBqdXN0IGEgZ3Vlc3MgYmVjYXVzZSBvdXIgb2Zmc2V0IGlzIGp1c3QgYSBndWVzc1xuICBsZXQgdXRjR3Vlc3MgPSBsb2NhbFRTIC0gbyAqIDYwICogMTAwMDtcblxuICAvLyBUZXN0IHdoZXRoZXIgdGhlIHpvbmUgbWF0Y2hlcyB0aGUgb2Zmc2V0IGZvciB0aGlzIHRzXG4gIGNvbnN0IG8yID0gdHoub2Zmc2V0KHV0Y0d1ZXNzKTtcblxuICAvLyBJZiBzbywgb2Zmc2V0IGRpZG4ndCBjaGFuZ2UgYW5kIHdlJ3JlIGRvbmVcbiAgaWYgKG8gPT09IG8yKSB7XG4gICAgcmV0dXJuIFt1dGNHdWVzcywgb107XG4gIH1cblxuICAvLyBJZiBub3QsIGNoYW5nZSB0aGUgdHMgYnkgdGhlIGRpZmZlcmVuY2UgaW4gdGhlIG9mZnNldFxuICB1dGNHdWVzcyAtPSAobzIgLSBvKSAqIDYwICogMTAwMDtcblxuICAvLyBJZiB0aGF0IGdpdmVzIHVzIHRoZSBsb2NhbCB0aW1lIHdlIHdhbnQsIHdlJ3JlIGRvbmVcbiAgY29uc3QgbzMgPSB0ei5vZmZzZXQodXRjR3Vlc3MpO1xuICBpZiAobzIgPT09IG8zKSB7XG4gICAgcmV0dXJuIFt1dGNHdWVzcywgbzJdO1xuICB9XG5cbiAgLy8gSWYgaXQncyBkaWZmZXJlbnQsIHdlJ3JlIGluIGEgaG9sZSB0aW1lLiBUaGUgb2Zmc2V0IGhhcyBjaGFuZ2VkLCBidXQgdGhlIHdlIGRvbid0IGFkanVzdCB0aGUgdGltZVxuICByZXR1cm4gW2xvY2FsVFMgLSBNYXRoLm1pbihvMiwgbzMpICogNjAgKiAxMDAwLCBNYXRoLm1heChvMiwgbzMpXTtcbn1cblxuLy8gY29udmVydCBhbiBlcG9jaCB0aW1lc3RhbXAgaW50byBhIGNhbGVuZGFyIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBvZmZzZXRcbmZ1bmN0aW9uIHRzVG9PYmoodHMsIG9mZnNldCkge1xuICB0cyArPSBvZmZzZXQgKiA2MCAqIDEwMDA7XG5cbiAgY29uc3QgZCA9IG5ldyBEYXRlKHRzKTtcblxuICByZXR1cm4ge1xuICAgIHllYXI6IGQuZ2V0VVRDRnVsbFllYXIoKSxcbiAgICBtb250aDogZC5nZXRVVENNb250aCgpICsgMSxcbiAgICBkYXk6IGQuZ2V0VVRDRGF0ZSgpLFxuICAgIGhvdXI6IGQuZ2V0VVRDSG91cnMoKSxcbiAgICBtaW51dGU6IGQuZ2V0VVRDTWludXRlcygpLFxuICAgIHNlY29uZDogZC5nZXRVVENTZWNvbmRzKCksXG4gICAgbWlsbGlzZWNvbmQ6IGQuZ2V0VVRDTWlsbGlzZWNvbmRzKCksXG4gIH07XG59XG5cbi8vIGNvbnZlcnQgYSBjYWxlbmRhciBvYmplY3QgdG8gYSBlcG9jaCB0aW1lc3RhbXBcbmZ1bmN0aW9uIG9ialRvVFMob2JqLCBvZmZzZXQsIHpvbmUpIHtcbiAgcmV0dXJuIGZpeE9mZnNldChvYmpUb0xvY2FsVFMob2JqKSwgb2Zmc2V0LCB6b25lKTtcbn1cblxuLy8gY3JlYXRlIGEgbmV3IERUIGluc3RhbmNlIGJ5IGFkZGluZyBhIGR1cmF0aW9uLCBhZGp1c3RpbmcgZm9yIERTVHNcbmZ1bmN0aW9uIGFkanVzdFRpbWUoaW5zdCwgZHVyKSB7XG4gIGNvbnN0IG9QcmUgPSBpbnN0Lm8sXG4gICAgeWVhciA9IGluc3QuYy55ZWFyICsgTWF0aC50cnVuYyhkdXIueWVhcnMpLFxuICAgIG1vbnRoID0gaW5zdC5jLm1vbnRoICsgTWF0aC50cnVuYyhkdXIubW9udGhzKSArIE1hdGgudHJ1bmMoZHVyLnF1YXJ0ZXJzKSAqIDMsXG4gICAgYyA9IHtcbiAgICAgIC4uLmluc3QuYyxcbiAgICAgIHllYXIsXG4gICAgICBtb250aCxcbiAgICAgIGRheTpcbiAgICAgICAgTWF0aC5taW4oaW5zdC5jLmRheSwgZGF5c0luTW9udGgoeWVhciwgbW9udGgpKSArXG4gICAgICAgIE1hdGgudHJ1bmMoZHVyLmRheXMpICtcbiAgICAgICAgTWF0aC50cnVuYyhkdXIud2Vla3MpICogNyxcbiAgICB9LFxuICAgIG1pbGxpc1RvQWRkID0gRHVyYXRpb24uZnJvbU9iamVjdCh7XG4gICAgICB5ZWFyczogZHVyLnllYXJzIC0gTWF0aC50cnVuYyhkdXIueWVhcnMpLFxuICAgICAgcXVhcnRlcnM6IGR1ci5xdWFydGVycyAtIE1hdGgudHJ1bmMoZHVyLnF1YXJ0ZXJzKSxcbiAgICAgIG1vbnRoczogZHVyLm1vbnRocyAtIE1hdGgudHJ1bmMoZHVyLm1vbnRocyksXG4gICAgICB3ZWVrczogZHVyLndlZWtzIC0gTWF0aC50cnVuYyhkdXIud2Vla3MpLFxuICAgICAgZGF5czogZHVyLmRheXMgLSBNYXRoLnRydW5jKGR1ci5kYXlzKSxcbiAgICAgIGhvdXJzOiBkdXIuaG91cnMsXG4gICAgICBtaW51dGVzOiBkdXIubWludXRlcyxcbiAgICAgIHNlY29uZHM6IGR1ci5zZWNvbmRzLFxuICAgICAgbWlsbGlzZWNvbmRzOiBkdXIubWlsbGlzZWNvbmRzLFxuICAgIH0pLmFzKFwibWlsbGlzZWNvbmRzXCIpLFxuICAgIGxvY2FsVFMgPSBvYmpUb0xvY2FsVFMoYyk7XG5cbiAgbGV0IFt0cywgb10gPSBmaXhPZmZzZXQobG9jYWxUUywgb1ByZSwgaW5zdC56b25lKTtcblxuICBpZiAobWlsbGlzVG9BZGQgIT09IDApIHtcbiAgICB0cyArPSBtaWxsaXNUb0FkZDtcbiAgICAvLyB0aGF0IGNvdWxkIGhhdmUgY2hhbmdlZCB0aGUgb2Zmc2V0IGJ5IGdvaW5nIG92ZXIgYSBEU1QsIGJ1dCB3ZSB3YW50IHRvIGtlZXAgdGhlIHRzIHRoZSBzYW1lXG4gICAgbyA9IGluc3Quem9uZS5vZmZzZXQodHMpO1xuICB9XG5cbiAgcmV0dXJuIHsgdHMsIG8gfTtcbn1cblxuLy8gaGVscGVyIHVzZWZ1bCBpbiB0dXJuaW5nIHRoZSByZXN1bHRzIG9mIHBhcnNpbmcgaW50byByZWFsIGRhdGVzXG4vLyBieSBoYW5kbGluZyB0aGUgem9uZSBvcHRpb25zXG5mdW5jdGlvbiBwYXJzZURhdGFUb0RhdGVUaW1lKHBhcnNlZCwgcGFyc2VkWm9uZSwgb3B0cywgZm9ybWF0LCB0ZXh0LCBzcGVjaWZpY09mZnNldCkge1xuICBjb25zdCB7IHNldFpvbmUsIHpvbmUgfSA9IG9wdHM7XG4gIGlmICgocGFyc2VkICYmIE9iamVjdC5rZXlzKHBhcnNlZCkubGVuZ3RoICE9PSAwKSB8fCBwYXJzZWRab25lKSB7XG4gICAgY29uc3QgaW50ZXJwcmV0YXRpb25ab25lID0gcGFyc2VkWm9uZSB8fCB6b25lLFxuICAgICAgaW5zdCA9IERhdGVUaW1lLmZyb21PYmplY3QocGFyc2VkLCB7XG4gICAgICAgIC4uLm9wdHMsXG4gICAgICAgIHpvbmU6IGludGVycHJldGF0aW9uWm9uZSxcbiAgICAgICAgc3BlY2lmaWNPZmZzZXQsXG4gICAgICB9KTtcbiAgICByZXR1cm4gc2V0Wm9uZSA/IGluc3QgOiBpbnN0LnNldFpvbmUoem9uZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQoXG4gICAgICBuZXcgSW52YWxpZChcInVucGFyc2FibGVcIiwgYHRoZSBpbnB1dCBcIiR7dGV4dH1cIiBjYW4ndCBiZSBwYXJzZWQgYXMgJHtmb3JtYXR9YClcbiAgICApO1xuICB9XG59XG5cbi8vIGlmIHlvdSB3YW50IHRvIG91dHB1dCBhIHRlY2huaWNhbCBmb3JtYXQgKGUuZy4gUkZDIDI4MjIpLCB0aGlzIGhlbHBlclxuLy8gaGVscHMgaGFuZGxlIHRoZSBkZXRhaWxzXG5mdW5jdGlvbiB0b1RlY2hGb3JtYXQoZHQsIGZvcm1hdCwgYWxsb3daID0gdHJ1ZSkge1xuICByZXR1cm4gZHQuaXNWYWxpZFxuICAgID8gRm9ybWF0dGVyLmNyZWF0ZShMb2NhbGUuY3JlYXRlKFwiZW4tVVNcIiksIHtcbiAgICAgICAgYWxsb3daLFxuICAgICAgICBmb3JjZVNpbXBsZTogdHJ1ZSxcbiAgICAgIH0pLmZvcm1hdERhdGVUaW1lRnJvbVN0cmluZyhkdCwgZm9ybWF0KVxuICAgIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gdG9JU09EYXRlKG8sIGV4dGVuZGVkKSB7XG4gIGNvbnN0IGxvbmdGb3JtYXQgPSBvLmMueWVhciA+IDk5OTkgfHwgby5jLnllYXIgPCAwO1xuICBsZXQgYyA9IFwiXCI7XG4gIGlmIChsb25nRm9ybWF0ICYmIG8uYy55ZWFyID49IDApIGMgKz0gXCIrXCI7XG4gIGMgKz0gcGFkU3RhcnQoby5jLnllYXIsIGxvbmdGb3JtYXQgPyA2IDogNCk7XG5cbiAgaWYgKGV4dGVuZGVkKSB7XG4gICAgYyArPSBcIi1cIjtcbiAgICBjICs9IHBhZFN0YXJ0KG8uYy5tb250aCk7XG4gICAgYyArPSBcIi1cIjtcbiAgICBjICs9IHBhZFN0YXJ0KG8uYy5kYXkpO1xuICB9IGVsc2Uge1xuICAgIGMgKz0gcGFkU3RhcnQoby5jLm1vbnRoKTtcbiAgICBjICs9IHBhZFN0YXJ0KG8uYy5kYXkpO1xuICB9XG4gIHJldHVybiBjO1xufVxuXG5mdW5jdGlvbiB0b0lTT1RpbWUoXG4gIG8sXG4gIGV4dGVuZGVkLFxuICBzdXBwcmVzc1NlY29uZHMsXG4gIHN1cHByZXNzTWlsbGlzZWNvbmRzLFxuICBpbmNsdWRlT2Zmc2V0LFxuICBleHRlbmRlZFpvbmVcbikge1xuICBsZXQgYyA9IHBhZFN0YXJ0KG8uYy5ob3VyKTtcbiAgaWYgKGV4dGVuZGVkKSB7XG4gICAgYyArPSBcIjpcIjtcbiAgICBjICs9IHBhZFN0YXJ0KG8uYy5taW51dGUpO1xuICAgIGlmIChvLmMubWlsbGlzZWNvbmQgIT09IDAgfHwgby5jLnNlY29uZCAhPT0gMCB8fCAhc3VwcHJlc3NTZWNvbmRzKSB7XG4gICAgICBjICs9IFwiOlwiO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjICs9IHBhZFN0YXJ0KG8uYy5taW51dGUpO1xuICB9XG5cbiAgaWYgKG8uYy5taWxsaXNlY29uZCAhPT0gMCB8fCBvLmMuc2Vjb25kICE9PSAwIHx8ICFzdXBwcmVzc1NlY29uZHMpIHtcbiAgICBjICs9IHBhZFN0YXJ0KG8uYy5zZWNvbmQpO1xuXG4gICAgaWYgKG8uYy5taWxsaXNlY29uZCAhPT0gMCB8fCAhc3VwcHJlc3NNaWxsaXNlY29uZHMpIHtcbiAgICAgIGMgKz0gXCIuXCI7XG4gICAgICBjICs9IHBhZFN0YXJ0KG8uYy5taWxsaXNlY29uZCwgMyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGluY2x1ZGVPZmZzZXQpIHtcbiAgICBpZiAoby5pc09mZnNldEZpeGVkICYmIG8ub2Zmc2V0ID09PSAwICYmICFleHRlbmRlZFpvbmUpIHtcbiAgICAgIGMgKz0gXCJaXCI7XG4gICAgfSBlbHNlIGlmIChvLm8gPCAwKSB7XG4gICAgICBjICs9IFwiLVwiO1xuICAgICAgYyArPSBwYWRTdGFydChNYXRoLnRydW5jKC1vLm8gLyA2MCkpO1xuICAgICAgYyArPSBcIjpcIjtcbiAgICAgIGMgKz0gcGFkU3RhcnQoTWF0aC50cnVuYygtby5vICUgNjApKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYyArPSBcIitcIjtcbiAgICAgIGMgKz0gcGFkU3RhcnQoTWF0aC50cnVuYyhvLm8gLyA2MCkpO1xuICAgICAgYyArPSBcIjpcIjtcbiAgICAgIGMgKz0gcGFkU3RhcnQoTWF0aC50cnVuYyhvLm8gJSA2MCkpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChleHRlbmRlZFpvbmUpIHtcbiAgICBjICs9IFwiW1wiICsgby56b25lLmlhbmFOYW1lICsgXCJdXCI7XG4gIH1cbiAgcmV0dXJuIGM7XG59XG5cbi8vIGRlZmF1bHRzIGZvciB1bnNwZWNpZmllZCB1bml0cyBpbiB0aGUgc3VwcG9ydGVkIGNhbGVuZGFyc1xuY29uc3QgZGVmYXVsdFVuaXRWYWx1ZXMgPSB7XG4gICAgbW9udGg6IDEsXG4gICAgZGF5OiAxLFxuICAgIGhvdXI6IDAsXG4gICAgbWludXRlOiAwLFxuICAgIHNlY29uZDogMCxcbiAgICBtaWxsaXNlY29uZDogMCxcbiAgfSxcbiAgZGVmYXVsdFdlZWtVbml0VmFsdWVzID0ge1xuICAgIHdlZWtOdW1iZXI6IDEsXG4gICAgd2Vla2RheTogMSxcbiAgICBob3VyOiAwLFxuICAgIG1pbnV0ZTogMCxcbiAgICBzZWNvbmQ6IDAsXG4gICAgbWlsbGlzZWNvbmQ6IDAsXG4gIH0sXG4gIGRlZmF1bHRPcmRpbmFsVW5pdFZhbHVlcyA9IHtcbiAgICBvcmRpbmFsOiAxLFxuICAgIGhvdXI6IDAsXG4gICAgbWludXRlOiAwLFxuICAgIHNlY29uZDogMCxcbiAgICBtaWxsaXNlY29uZDogMCxcbiAgfTtcblxuLy8gVW5pdHMgaW4gdGhlIHN1cHBvcnRlZCBjYWxlbmRhcnMsIHNvcnRlZCBieSBiaWduZXNzXG5jb25zdCBvcmRlcmVkVW5pdHMgPSBbXCJ5ZWFyXCIsIFwibW9udGhcIiwgXCJkYXlcIiwgXCJob3VyXCIsIFwibWludXRlXCIsIFwic2Vjb25kXCIsIFwibWlsbGlzZWNvbmRcIl0sXG4gIG9yZGVyZWRXZWVrVW5pdHMgPSBbXG4gICAgXCJ3ZWVrWWVhclwiLFxuICAgIFwid2Vla051bWJlclwiLFxuICAgIFwid2Vla2RheVwiLFxuICAgIFwiaG91clwiLFxuICAgIFwibWludXRlXCIsXG4gICAgXCJzZWNvbmRcIixcbiAgICBcIm1pbGxpc2Vjb25kXCIsXG4gIF0sXG4gIG9yZGVyZWRPcmRpbmFsVW5pdHMgPSBbXCJ5ZWFyXCIsIFwib3JkaW5hbFwiLCBcImhvdXJcIiwgXCJtaW51dGVcIiwgXCJzZWNvbmRcIiwgXCJtaWxsaXNlY29uZFwiXTtcblxuLy8gc3RhbmRhcmRpemUgY2FzZSBhbmQgcGx1cmFsaXR5IGluIHVuaXRzXG5mdW5jdGlvbiBub3JtYWxpemVVbml0KHVuaXQpIHtcbiAgY29uc3Qgbm9ybWFsaXplZCA9IHtcbiAgICB5ZWFyOiBcInllYXJcIixcbiAgICB5ZWFyczogXCJ5ZWFyXCIsXG4gICAgbW9udGg6IFwibW9udGhcIixcbiAgICBtb250aHM6IFwibW9udGhcIixcbiAgICBkYXk6IFwiZGF5XCIsXG4gICAgZGF5czogXCJkYXlcIixcbiAgICBob3VyOiBcImhvdXJcIixcbiAgICBob3VyczogXCJob3VyXCIsXG4gICAgbWludXRlOiBcIm1pbnV0ZVwiLFxuICAgIG1pbnV0ZXM6IFwibWludXRlXCIsXG4gICAgcXVhcnRlcjogXCJxdWFydGVyXCIsXG4gICAgcXVhcnRlcnM6IFwicXVhcnRlclwiLFxuICAgIHNlY29uZDogXCJzZWNvbmRcIixcbiAgICBzZWNvbmRzOiBcInNlY29uZFwiLFxuICAgIG1pbGxpc2Vjb25kOiBcIm1pbGxpc2Vjb25kXCIsXG4gICAgbWlsbGlzZWNvbmRzOiBcIm1pbGxpc2Vjb25kXCIsXG4gICAgd2Vla2RheTogXCJ3ZWVrZGF5XCIsXG4gICAgd2Vla2RheXM6IFwid2Vla2RheVwiLFxuICAgIHdlZWtudW1iZXI6IFwid2Vla051bWJlclwiLFxuICAgIHdlZWtzbnVtYmVyOiBcIndlZWtOdW1iZXJcIixcbiAgICB3ZWVrbnVtYmVyczogXCJ3ZWVrTnVtYmVyXCIsXG4gICAgd2Vla3llYXI6IFwid2Vla1llYXJcIixcbiAgICB3ZWVreWVhcnM6IFwid2Vla1llYXJcIixcbiAgICBvcmRpbmFsOiBcIm9yZGluYWxcIixcbiAgfVt1bml0LnRvTG93ZXJDYXNlKCldO1xuXG4gIGlmICghbm9ybWFsaXplZCkgdGhyb3cgbmV3IEludmFsaWRVbml0RXJyb3IodW5pdCk7XG5cbiAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59XG5cbi8vIHRoaXMgaXMgYSBkdW1iZWQgZG93biB2ZXJzaW9uIG9mIGZyb21PYmplY3QoKSB0aGF0IHJ1bnMgYWJvdXQgNjAlIGZhc3RlclxuLy8gYnV0IGRvZXNuJ3QgZG8gYW55IHZhbGlkYXRpb24sIG1ha2VzIGEgYnVuY2ggb2YgYXNzdW1wdGlvbnMgYWJvdXQgd2hhdCB1bml0c1xuLy8gYXJlIHByZXNlbnQsIGFuZCBzbyBvbi5cbmZ1bmN0aW9uIHF1aWNrRFQob2JqLCBvcHRzKSB7XG4gIGNvbnN0IHpvbmUgPSBub3JtYWxpemVab25lKG9wdHMuem9uZSwgU2V0dGluZ3MuZGVmYXVsdFpvbmUpLFxuICAgIGxvYyA9IExvY2FsZS5mcm9tT2JqZWN0KG9wdHMpLFxuICAgIHRzTm93ID0gU2V0dGluZ3Mubm93KCk7XG5cbiAgbGV0IHRzLCBvO1xuXG4gIC8vIGFzc3VtZSB3ZSBoYXZlIHRoZSBoaWdoZXItb3JkZXIgdW5pdHNcbiAgaWYgKCFpc1VuZGVmaW5lZChvYmoueWVhcikpIHtcbiAgICBmb3IgKGNvbnN0IHUgb2Ygb3JkZXJlZFVuaXRzKSB7XG4gICAgICBpZiAoaXNVbmRlZmluZWQob2JqW3VdKSkge1xuICAgICAgICBvYmpbdV0gPSBkZWZhdWx0VW5pdFZhbHVlc1t1XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBpbnZhbGlkID0gaGFzSW52YWxpZEdyZWdvcmlhbkRhdGEob2JqKSB8fCBoYXNJbnZhbGlkVGltZURhdGEob2JqKTtcbiAgICBpZiAoaW52YWxpZCkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQoaW52YWxpZCk7XG4gICAgfVxuXG4gICAgY29uc3Qgb2Zmc2V0UHJvdmlzID0gem9uZS5vZmZzZXQodHNOb3cpO1xuICAgIFt0cywgb10gPSBvYmpUb1RTKG9iaiwgb2Zmc2V0UHJvdmlzLCB6b25lKTtcbiAgfSBlbHNlIHtcbiAgICB0cyA9IHRzTm93O1xuICB9XG5cbiAgcmV0dXJuIG5ldyBEYXRlVGltZSh7IHRzLCB6b25lLCBsb2MsIG8gfSk7XG59XG5cbmZ1bmN0aW9uIGRpZmZSZWxhdGl2ZShzdGFydCwgZW5kLCBvcHRzKSB7XG4gIGNvbnN0IHJvdW5kID0gaXNVbmRlZmluZWQob3B0cy5yb3VuZCkgPyB0cnVlIDogb3B0cy5yb3VuZCxcbiAgICBmb3JtYXQgPSAoYywgdW5pdCkgPT4ge1xuICAgICAgYyA9IHJvdW5kVG8oYywgcm91bmQgfHwgb3B0cy5jYWxlbmRhcnkgPyAwIDogMiwgdHJ1ZSk7XG4gICAgICBjb25zdCBmb3JtYXR0ZXIgPSBlbmQubG9jLmNsb25lKG9wdHMpLnJlbEZvcm1hdHRlcihvcHRzKTtcbiAgICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0KGMsIHVuaXQpO1xuICAgIH0sXG4gICAgZGlmZmVyID0gKHVuaXQpID0+IHtcbiAgICAgIGlmIChvcHRzLmNhbGVuZGFyeSkge1xuICAgICAgICBpZiAoIWVuZC5oYXNTYW1lKHN0YXJ0LCB1bml0KSkge1xuICAgICAgICAgIHJldHVybiBlbmQuc3RhcnRPZih1bml0KS5kaWZmKHN0YXJ0LnN0YXJ0T2YodW5pdCksIHVuaXQpLmdldCh1bml0KTtcbiAgICAgICAgfSBlbHNlIHJldHVybiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGVuZC5kaWZmKHN0YXJ0LCB1bml0KS5nZXQodW5pdCk7XG4gICAgICB9XG4gICAgfTtcblxuICBpZiAob3B0cy51bml0KSB7XG4gICAgcmV0dXJuIGZvcm1hdChkaWZmZXIob3B0cy51bml0KSwgb3B0cy51bml0KTtcbiAgfVxuXG4gIGZvciAoY29uc3QgdW5pdCBvZiBvcHRzLnVuaXRzKSB7XG4gICAgY29uc3QgY291bnQgPSBkaWZmZXIodW5pdCk7XG4gICAgaWYgKE1hdGguYWJzKGNvdW50KSA+PSAxKSB7XG4gICAgICByZXR1cm4gZm9ybWF0KGNvdW50LCB1bml0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZvcm1hdChzdGFydCA+IGVuZCA/IC0wIDogMCwgb3B0cy51bml0c1tvcHRzLnVuaXRzLmxlbmd0aCAtIDFdKTtcbn1cblxuZnVuY3Rpb24gbGFzdE9wdHMoYXJnTGlzdCkge1xuICBsZXQgb3B0cyA9IHt9LFxuICAgIGFyZ3M7XG4gIGlmIChhcmdMaXN0Lmxlbmd0aCA+IDAgJiYgdHlwZW9mIGFyZ0xpc3RbYXJnTGlzdC5sZW5ndGggLSAxXSA9PT0gXCJvYmplY3RcIikge1xuICAgIG9wdHMgPSBhcmdMaXN0W2FyZ0xpc3QubGVuZ3RoIC0gMV07XG4gICAgYXJncyA9IEFycmF5LmZyb20oYXJnTGlzdCkuc2xpY2UoMCwgYXJnTGlzdC5sZW5ndGggLSAxKTtcbiAgfSBlbHNlIHtcbiAgICBhcmdzID0gQXJyYXkuZnJvbShhcmdMaXN0KTtcbiAgfVxuICByZXR1cm4gW29wdHMsIGFyZ3NdO1xufVxuXG4vKipcbiAqIEEgRGF0ZVRpbWUgaXMgYW4gaW1tdXRhYmxlIGRhdGEgc3RydWN0dXJlIHJlcHJlc2VudGluZyBhIHNwZWNpZmljIGRhdGUgYW5kIHRpbWUgYW5kIGFjY29tcGFueWluZyBtZXRob2RzLiBJdCBjb250YWlucyBjbGFzcyBhbmQgaW5zdGFuY2UgbWV0aG9kcyBmb3IgY3JlYXRpbmcsIHBhcnNpbmcsIGludGVycm9nYXRpbmcsIHRyYW5zZm9ybWluZywgYW5kIGZvcm1hdHRpbmcgdGhlbS5cbiAqXG4gKiBBIERhdGVUaW1lIGNvbXByaXNlcyBvZjpcbiAqICogQSB0aW1lc3RhbXAuIEVhY2ggRGF0ZVRpbWUgaW5zdGFuY2UgcmVmZXJzIHRvIGEgc3BlY2lmaWMgbWlsbGlzZWNvbmQgb2YgdGhlIFVuaXggZXBvY2guXG4gKiAqIEEgdGltZSB6b25lLiBFYWNoIGluc3RhbmNlIGlzIGNvbnNpZGVyZWQgaW4gdGhlIGNvbnRleHQgb2YgYSBzcGVjaWZpYyB6b25lIChieSBkZWZhdWx0IHRoZSBsb2NhbCBzeXN0ZW0ncyB6b25lKS5cbiAqICogQ29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzIHRoYXQgZWZmZWN0IGhvdyBvdXRwdXQgc3RyaW5ncyBhcmUgZm9ybWF0dGVkLCBzdWNoIGFzIGBsb2NhbGVgLCBgbnVtYmVyaW5nU3lzdGVtYCwgYW5kIGBvdXRwdXRDYWxlbmRhcmAuXG4gKlxuICogSGVyZSBpcyBhIGJyaWVmIG92ZXJ2aWV3IG9mIHRoZSBtb3N0IGNvbW1vbmx5IHVzZWQgZnVuY3Rpb25hbGl0eSBpdCBwcm92aWRlczpcbiAqXG4gKiAqICoqQ3JlYXRpb24qKjogVG8gY3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBpdHMgY29tcG9uZW50cywgdXNlIG9uZSBvZiBpdHMgZmFjdG9yeSBjbGFzcyBtZXRob2RzOiB7QGxpbmsgRGF0ZVRpbWUubG9jYWx9LCB7QGxpbmsgRGF0ZVRpbWUudXRjfSwgYW5kIChtb3N0IGZsZXhpYmx5KSB7QGxpbmsgRGF0ZVRpbWUuZnJvbU9iamVjdH0uIFRvIGNyZWF0ZSBvbmUgZnJvbSBhIHN0YW5kYXJkIHN0cmluZyBmb3JtYXQsIHVzZSB7QGxpbmsgRGF0ZVRpbWUuZnJvbUlTT30sIHtAbGluayBEYXRlVGltZS5mcm9tSFRUUH0sIGFuZCB7QGxpbmsgRGF0ZVRpbWUuZnJvbVJGQzI4MjJ9LiBUbyBjcmVhdGUgb25lIGZyb20gYSBjdXN0b20gc3RyaW5nIGZvcm1hdCwgdXNlIHtAbGluayBEYXRlVGltZS5mcm9tRm9ybWF0fS4gVG8gY3JlYXRlIG9uZSBmcm9tIGEgbmF0aXZlIEpTIGRhdGUsIHVzZSB7QGxpbmsgRGF0ZVRpbWUuZnJvbUpTRGF0ZX0uXG4gKiAqICoqR3JlZ29yaWFuIGNhbGVuZGFyIGFuZCB0aW1lKio6IFRvIGV4YW1pbmUgdGhlIEdyZWdvcmlhbiBwcm9wZXJ0aWVzIG9mIGEgRGF0ZVRpbWUgaW5kaXZpZHVhbGx5IChpLmUgYXMgb3Bwb3NlZCB0byBjb2xsZWN0aXZlbHkgdGhyb3VnaCB7QGxpbmsgRGF0ZVRpbWUjdG9PYmplY3R9KSwgdXNlIHRoZSB7QGxpbmsgRGF0ZVRpbWUjeWVhcn0sIHtAbGluayBEYXRlVGltZSNtb250aH0sXG4gKiB7QGxpbmsgRGF0ZVRpbWUjZGF5fSwge0BsaW5rIERhdGVUaW1lI2hvdXJ9LCB7QGxpbmsgRGF0ZVRpbWUjbWludXRlfSwge0BsaW5rIERhdGVUaW1lI3NlY29uZH0sIHtAbGluayBEYXRlVGltZSNtaWxsaXNlY29uZH0gYWNjZXNzb3JzLlxuICogKiAqKldlZWsgY2FsZW5kYXIqKjogRm9yIElTTyB3ZWVrIGNhbGVuZGFyIGF0dHJpYnV0ZXMsIHNlZSB0aGUge0BsaW5rIERhdGVUaW1lI3dlZWtZZWFyfSwge0BsaW5rIERhdGVUaW1lI3dlZWtOdW1iZXJ9LCBhbmQge0BsaW5rIERhdGVUaW1lI3dlZWtkYXl9IGFjY2Vzc29ycy5cbiAqICogKipDb25maWd1cmF0aW9uKiogU2VlIHRoZSB7QGxpbmsgRGF0ZVRpbWUjbG9jYWxlfSBhbmQge0BsaW5rIERhdGVUaW1lI251bWJlcmluZ1N5c3RlbX0gYWNjZXNzb3JzLlxuICogKiAqKlRyYW5zZm9ybWF0aW9uKio6IFRvIHRyYW5zZm9ybSB0aGUgRGF0ZVRpbWUgaW50byBvdGhlciBEYXRlVGltZXMsIHVzZSB7QGxpbmsgRGF0ZVRpbWUjc2V0fSwge0BsaW5rIERhdGVUaW1lI3JlY29uZmlndXJlfSwge0BsaW5rIERhdGVUaW1lI3NldFpvbmV9LCB7QGxpbmsgRGF0ZVRpbWUjc2V0TG9jYWxlfSwge0BsaW5rIERhdGVUaW1lLnBsdXN9LCB7QGxpbmsgRGF0ZVRpbWUjbWludXN9LCB7QGxpbmsgRGF0ZVRpbWUjZW5kT2Z9LCB7QGxpbmsgRGF0ZVRpbWUjc3RhcnRPZn0sIHtAbGluayBEYXRlVGltZSN0b1VUQ30sIGFuZCB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbH0uXG4gKiAqICoqT3V0cHV0Kio6IFRvIGNvbnZlcnQgdGhlIERhdGVUaW1lIHRvIG90aGVyIHJlcHJlc2VudGF0aW9ucywgdXNlIHRoZSB7QGxpbmsgRGF0ZVRpbWUjdG9SZWxhdGl2ZX0sIHtAbGluayBEYXRlVGltZSN0b1JlbGF0aXZlQ2FsZW5kYXJ9LCB7QGxpbmsgRGF0ZVRpbWUjdG9KU09OfSwge0BsaW5rIERhdGVUaW1lI3RvSVNPfSwge0BsaW5rIERhdGVUaW1lI3RvSFRUUH0sIHtAbGluayBEYXRlVGltZSN0b09iamVjdH0sIHtAbGluayBEYXRlVGltZSN0b1JGQzI4MjJ9LCB7QGxpbmsgRGF0ZVRpbWUjdG9TdHJpbmd9LCB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9LCB7QGxpbmsgRGF0ZVRpbWUjdG9Gb3JtYXR9LCB7QGxpbmsgRGF0ZVRpbWUjdG9NaWxsaXN9IGFuZCB7QGxpbmsgRGF0ZVRpbWUjdG9KU0RhdGV9LlxuICpcbiAqIFRoZXJlJ3MgcGxlbnR5IG90aGVycyBkb2N1bWVudGVkIGJlbG93LiBJbiBhZGRpdGlvbiwgZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gc3VidGxlciB0b3BpY3MgbGlrZSBpbnRlcm5hdGlvbmFsaXphdGlvbiwgdGltZSB6b25lcywgYWx0ZXJuYXRpdmUgY2FsZW5kYXJzLCB2YWxpZGl0eSwgYW5kIHNvIG9uLCBzZWUgdGhlIGV4dGVybmFsIGRvY3VtZW50YXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERhdGVUaW1lIHtcbiAgLyoqXG4gICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgY29uc3Qgem9uZSA9IGNvbmZpZy56b25lIHx8IFNldHRpbmdzLmRlZmF1bHRab25lO1xuXG4gICAgbGV0IGludmFsaWQgPVxuICAgICAgY29uZmlnLmludmFsaWQgfHxcbiAgICAgIChOdW1iZXIuaXNOYU4oY29uZmlnLnRzKSA/IG5ldyBJbnZhbGlkKFwiaW52YWxpZCBpbnB1dFwiKSA6IG51bGwpIHx8XG4gICAgICAoIXpvbmUuaXNWYWxpZCA/IHVuc3VwcG9ydGVkWm9uZSh6b25lKSA6IG51bGwpO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudHMgPSBpc1VuZGVmaW5lZChjb25maWcudHMpID8gU2V0dGluZ3Mubm93KCkgOiBjb25maWcudHM7XG5cbiAgICBsZXQgYyA9IG51bGwsXG4gICAgICBvID0gbnVsbDtcbiAgICBpZiAoIWludmFsaWQpIHtcbiAgICAgIGNvbnN0IHVuY2hhbmdlZCA9IGNvbmZpZy5vbGQgJiYgY29uZmlnLm9sZC50cyA9PT0gdGhpcy50cyAmJiBjb25maWcub2xkLnpvbmUuZXF1YWxzKHpvbmUpO1xuXG4gICAgICBpZiAodW5jaGFuZ2VkKSB7XG4gICAgICAgIFtjLCBvXSA9IFtjb25maWcub2xkLmMsIGNvbmZpZy5vbGQub107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBvdCA9IHpvbmUub2Zmc2V0KHRoaXMudHMpO1xuICAgICAgICBjID0gdHNUb09iaih0aGlzLnRzLCBvdCk7XG4gICAgICAgIGludmFsaWQgPSBOdW1iZXIuaXNOYU4oYy55ZWFyKSA/IG5ldyBJbnZhbGlkKFwiaW52YWxpZCBpbnB1dFwiKSA6IG51bGw7XG4gICAgICAgIGMgPSBpbnZhbGlkID8gbnVsbCA6IGM7XG4gICAgICAgIG8gPSBpbnZhbGlkID8gbnVsbCA6IG90O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3pvbmUgPSB6b25lO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubG9jID0gY29uZmlnLmxvYyB8fCBMb2NhbGUuY3JlYXRlKCk7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5pbnZhbGlkID0gaW52YWxpZDtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLndlZWtEYXRhID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmMgPSBjO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubyA9IG87XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5pc0x1eG9uRGF0ZVRpbWUgPSB0cnVlO1xuICB9XG5cbiAgLy8gQ09OU1RSVUNUXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZvciB0aGUgY3VycmVudCBpbnN0YW50LCBpbiB0aGUgc3lzdGVtJ3MgdGltZSB6b25lLlxuICAgKlxuICAgKiBVc2UgU2V0dGluZ3MgdG8gb3ZlcnJpZGUgdGhlc2UgZGVmYXVsdCB2YWx1ZXMgaWYgbmVlZGVkLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0lTTygpIC8vfj4gbm93IGluIHRoZSBJU08gZm9ybWF0XG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIG5vdygpIHtcbiAgICByZXR1cm4gbmV3IERhdGVUaW1lKHt9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBsb2NhbCBEYXRlVGltZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW3llYXJdIC0gVGhlIGNhbGVuZGFyIHllYXIuIElmIG9taXR0ZWQgKGFzIGluLCBjYWxsIGBsb2NhbCgpYCB3aXRoIG5vIGFyZ3VtZW50cyksIHRoZSBjdXJyZW50IHRpbWUgd2lsbCBiZSB1c2VkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbW9udGg9MV0gLSBUaGUgbW9udGgsIDEtaW5kZXhlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RheT0xXSAtIFRoZSBkYXkgb2YgdGhlIG1vbnRoLCAxLWluZGV4ZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtob3VyPTBdIC0gVGhlIGhvdXIgb2YgdGhlIGRheSwgaW4gMjQtaG91ciB0aW1lXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbWludXRlPTBdIC0gVGhlIG1pbnV0ZSBvZiB0aGUgaG91ciwgbWVhbmluZyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDU5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc2Vjb25kPTBdIC0gVGhlIHNlY29uZCBvZiB0aGUgbWludXRlLCBtZWFuaW5nIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgNTlcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttaWxsaXNlY29uZD0wXSAtIFRoZSBtaWxsaXNlY29uZCBvZiB0aGUgc2Vjb25kLCBtZWFuaW5nIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgOTk5XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9+PiBub3dcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoeyB6b25lOiBcIkFtZXJpY2EvTmV3X1lvcmtcIiB9KSAgICAgIC8vfj4gbm93LCBpbiBVUyBlYXN0IGNvYXN0IHRpbWVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNykgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDEtMDFUMDA6MDA6MDBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMykgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMDFUMDA6MDA6MDBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMywgMTIsIHsgbG9jYWxlOiBcImZyXCIgfSkgICAgIC8vfj4gMjAxNy0wMy0xMlQwMDowMDowMCwgd2l0aCBhIEZyZW5jaCBsb2NhbGVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMywgMTIsIDUpICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6MDA6MDBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMywgMTIsIDUsIHsgem9uZTogXCJ1dGNcIiB9KSAgIC8vfj4gMjAxNy0wMy0xMlQwNTowMDowMCwgaW4gVVRDXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDMsIDEyLCA1LCA0NSkgICAgICAgICAgICAgICAgLy9+PiAyMDE3LTAzLTEyVDA1OjQ1OjAwXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDMsIDEyLCA1LCA0NSwgMTApICAgICAgICAgICAgLy9+PiAyMDE3LTAzLTEyVDA1OjQ1OjEwXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDMsIDEyLCA1LCA0NSwgMTAsIDc2NSkgICAgICAgLy9+PiAyMDE3LTAzLTEyVDA1OjQ1OjEwLjc2NVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBsb2NhbCgpIHtcbiAgICBjb25zdCBbb3B0cywgYXJnc10gPSBsYXN0T3B0cyhhcmd1bWVudHMpLFxuICAgICAgW3llYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZF0gPSBhcmdzO1xuICAgIHJldHVybiBxdWlja0RUKHsgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kIH0sIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGluIFVUQ1xuICAgKiBAcGFyYW0ge251bWJlcn0gW3llYXJdIC0gVGhlIGNhbGVuZGFyIHllYXIuIElmIG9taXR0ZWQgKGFzIGluLCBjYWxsIGB1dGMoKWAgd2l0aCBubyBhcmd1bWVudHMpLCB0aGUgY3VycmVudCB0aW1lIHdpbGwgYmUgdXNlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW21vbnRoPTFdIC0gVGhlIG1vbnRoLCAxLWluZGV4ZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkYXk9MV0gLSBUaGUgZGF5IG9mIHRoZSBtb250aFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2hvdXI9MF0gLSBUaGUgaG91ciBvZiB0aGUgZGF5LCBpbiAyNC1ob3VyIHRpbWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttaW51dGU9MF0gLSBUaGUgbWludXRlIG9mIHRoZSBob3VyLCBtZWFuaW5nIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgNTlcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzZWNvbmQ9MF0gLSBUaGUgc2Vjb25kIG9mIHRoZSBtaW51dGUsIG1lYW5pbmcgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCA1OVxuICAgKiBAcGFyYW0ge251bWJlcn0gW21pbGxpc2Vjb25kPTBdIC0gVGhlIG1pbGxpc2Vjb25kIG9mIHRoZSBzZWNvbmQsIG1lYW5pbmcgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCA5OTlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBEYXRlVGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubG9jYWxlXSAtIGEgbG9jYWxlIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5vdXRwdXRDYWxlbmRhcl0gLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5udW1iZXJpbmdTeXN0ZW1dIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9+PiBub3dcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTcpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9+PiAyMDE3LTAxLTAxVDAwOjAwOjAwWlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNywgMykgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMDFUMDA6MDA6MDBaXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3LCAzLCAxMikgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwMDowMDowMFpcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTcsIDMsIDEyLCA1KSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9+PiAyMDE3LTAzLTEyVDA1OjAwOjAwWlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNywgMywgMTIsIDUsIDQ1KSAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6NDU6MDBaXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3LCAzLCAxMiwgNSwgNDUsIHsgbG9jYWxlOiBcImZyXCIgfSkgICAgICAgICAgLy9+PiAyMDE3LTAzLTEyVDA1OjQ1OjAwWiB3aXRoIGEgRnJlbmNoIGxvY2FsZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNywgMywgMTIsIDUsIDQ1LCAxMCkgICAgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6NDU6MTBaXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3LCAzLCAxMiwgNSwgNDUsIDEwLCA3NjUsIHsgbG9jYWxlOiBcImZyXCIgfSkgLy9+PiAyMDE3LTAzLTEyVDA1OjQ1OjEwLjc2NVogd2l0aCBhIEZyZW5jaCBsb2NhbGVcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgdXRjKCkge1xuICAgIGNvbnN0IFtvcHRzLCBhcmdzXSA9IGxhc3RPcHRzKGFyZ3VtZW50cyksXG4gICAgICBbeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kXSA9IGFyZ3M7XG5cbiAgICBvcHRzLnpvbmUgPSBGaXhlZE9mZnNldFpvbmUudXRjSW5zdGFuY2U7XG4gICAgcmV0dXJuIHF1aWNrRFQoeyB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQgfSwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhIEphdmFTY3JpcHQgRGF0ZSBvYmplY3QuIFVzZXMgdGhlIGRlZmF1bHQgem9uZS5cbiAgICogQHBhcmFtIHtEYXRlfSBkYXRlIC0gYSBKYXZhU2NyaXB0IERhdGUgb2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdGlvbnMuem9uZT0nbG9jYWwnXSAtIHRoZSB6b25lIHRvIHBsYWNlIHRoZSBEYXRlVGltZSBpbnRvXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21KU0RhdGUoZGF0ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgdHMgPSBpc0RhdGUoZGF0ZSkgPyBkYXRlLnZhbHVlT2YoKSA6IE5hTjtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKHRzKSkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQoXCJpbnZhbGlkIGlucHV0XCIpO1xuICAgIH1cblxuICAgIGNvbnN0IHpvbmVUb1VzZSA9IG5vcm1hbGl6ZVpvbmUob3B0aW9ucy56b25lLCBTZXR0aW5ncy5kZWZhdWx0Wm9uZSk7XG4gICAgaWYgKCF6b25lVG9Vc2UuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQodW5zdXBwb3J0ZWRab25lKHpvbmVUb1VzZSkpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRGF0ZVRpbWUoe1xuICAgICAgdHM6IHRzLFxuICAgICAgem9uZTogem9uZVRvVXNlLFxuICAgICAgbG9jOiBMb2NhbGUuZnJvbU9iamVjdChvcHRpb25zKSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgZXBvY2ggKG1lYW5pbmcgc2luY2UgMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS4gVXNlcyB0aGUgZGVmYXVsdCB6b25lLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWlsbGlzZWNvbmRzIC0gYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIDE5NzAgVVRDXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdGlvbnMuem9uZT0nbG9jYWwnXSAtIHRoZSB6b25lIHRvIHBsYWNlIHRoZSBEYXRlVGltZSBpbnRvXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sb2NhbGVdIC0gYSBsb2NhbGUgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMub3V0cHV0Q2FsZW5kYXIgLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21NaWxsaXMobWlsbGlzZWNvbmRzLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIWlzTnVtYmVyKG1pbGxpc2Vjb25kcykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcbiAgICAgICAgYGZyb21NaWxsaXMgcmVxdWlyZXMgYSBudW1lcmljYWwgaW5wdXQsIGJ1dCByZWNlaXZlZCBhICR7dHlwZW9mIG1pbGxpc2Vjb25kc30gd2l0aCB2YWx1ZSAke21pbGxpc2Vjb25kc31gXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAobWlsbGlzZWNvbmRzIDwgLU1BWF9EQVRFIHx8IG1pbGxpc2Vjb25kcyA+IE1BWF9EQVRFKSB7XG4gICAgICAvLyB0aGlzIGlzbid0IHBlcmZlY3QgYmVjYXVzZSBiZWNhdXNlIHdlIGNhbiBzdGlsbCBlbmQgdXAgb3V0IG9mIHJhbmdlIGJlY2F1c2Ugb2YgYWRkaXRpb25hbCBzaGlmdGluZywgYnV0IGl0J3MgYSBzdGFydFxuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQoXCJUaW1lc3RhbXAgb3V0IG9mIHJhbmdlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IERhdGVUaW1lKHtcbiAgICAgICAgdHM6IG1pbGxpc2Vjb25kcyxcbiAgICAgICAgem9uZTogbm9ybWFsaXplWm9uZShvcHRpb25zLnpvbmUsIFNldHRpbmdzLmRlZmF1bHRab25lKSxcbiAgICAgICAgbG9jOiBMb2NhbGUuZnJvbU9iamVjdChvcHRpb25zKSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGEgbnVtYmVyIG9mIHNlY29uZHMgc2luY2UgdGhlIGVwb2NoIChtZWFuaW5nIHNpbmNlIDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuIFVzZXMgdGhlIGRlZmF1bHQgem9uZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNlY29uZHMgLSBhIG51bWJlciBvZiBzZWNvbmRzIHNpbmNlIDE5NzAgVVRDXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdGlvbnMuem9uZT0nbG9jYWwnXSAtIHRoZSB6b25lIHRvIHBsYWNlIHRoZSBEYXRlVGltZSBpbnRvXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sb2NhbGVdIC0gYSBsb2NhbGUgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMub3V0cHV0Q2FsZW5kYXIgLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21TZWNvbmRzKHNlY29uZHMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghaXNOdW1iZXIoc2Vjb25kcykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImZyb21TZWNvbmRzIHJlcXVpcmVzIGEgbnVtZXJpY2FsIGlucHV0XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IERhdGVUaW1lKHtcbiAgICAgICAgdHM6IHNlY29uZHMgKiAxMDAwLFxuICAgICAgICB6b25lOiBub3JtYWxpemVab25lKG9wdGlvbnMuem9uZSwgU2V0dGluZ3MuZGVmYXVsdFpvbmUpLFxuICAgICAgICBsb2M6IExvY2FsZS5mcm9tT2JqZWN0KG9wdGlvbnMpLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYSBKYXZhU2NyaXB0IG9iamVjdCB3aXRoIGtleXMgbGlrZSAneWVhcicgYW5kICdob3VyJyB3aXRoIHJlYXNvbmFibGUgZGVmYXVsdHMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSB0aGUgb2JqZWN0IHRvIGNyZWF0ZSB0aGUgRGF0ZVRpbWUgZnJvbVxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLnllYXIgLSBhIHllYXIsIHN1Y2ggYXMgMTk4N1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLm1vbnRoIC0gYSBtb250aCwgMS0xMlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLmRheSAtIGEgZGF5IG9mIHRoZSBtb250aCwgMS0zMSwgZGVwZW5kaW5nIG9uIHRoZSBtb250aFxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLm9yZGluYWwgLSBkYXkgb2YgdGhlIHllYXIsIDEtMzY1IG9yIDM2NlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLndlZWtZZWFyIC0gYW4gSVNPIHdlZWsgeWVhclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLndlZWtOdW1iZXIgLSBhbiBJU08gd2VlayBudW1iZXIsIGJldHdlZW4gMSBhbmQgNTIgb3IgNTMsIGRlcGVuZGluZyBvbiB0aGUgeWVhclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLndlZWtkYXkgLSBhbiBJU08gd2Vla2RheSwgMS03LCB3aGVyZSAxIGlzIE1vbmRheSBhbmQgNyBpcyBTdW5kYXlcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5ob3VyIC0gaG91ciBvZiB0aGUgZGF5LCAwLTIzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoubWludXRlIC0gbWludXRlIG9mIHRoZSBob3VyLCAwLTU5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmouc2Vjb25kIC0gc2Vjb25kIG9mIHRoZSBtaW51dGUsIDAtNTlcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5taWxsaXNlY29uZCAtIG1pbGxpc2Vjb25kIG9mIHRoZSBzZWNvbmQsIDAtOTk5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGhpcyBEYXRlVGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0cy56b25lPSdsb2NhbCddIC0gaW50ZXJwcmV0IHRoZSBudW1iZXJzIGluIHRoZSBjb250ZXh0IG9mIGEgcGFydGljdWxhciB6b25lLiBDYW4gdGFrZSBhbnkgdmFsdWUgdGFrZW4gYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHNldFpvbmUoKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdzeXN0ZW0ncyBsb2NhbGUnXSAtIGEgbG9jYWxlIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm91dHB1dENhbGVuZGFyIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tT2JqZWN0KHsgeWVhcjogMTk4MiwgbW9udGg6IDUsIGRheTogMjV9KS50b0lTT0RhdGUoKSAvLz0+ICcxOTgyLTA1LTI1J1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tT2JqZWN0KHsgeWVhcjogMTk4MiB9KS50b0lTT0RhdGUoKSAvLz0+ICcxOTgyLTAxLTAxJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tT2JqZWN0KHsgaG91cjogMTAsIG1pbnV0ZTogMjYsIHNlY29uZDogNiB9KSAvL34+IHRvZGF5IGF0IDEwOjI2OjA2XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyBob3VyOiAxMCwgbWludXRlOiAyNiwgc2Vjb25kOiA2IH0sIHsgem9uZTogJ3V0YycgfSksXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyBob3VyOiAxMCwgbWludXRlOiAyNiwgc2Vjb25kOiA2IH0sIHsgem9uZTogJ2xvY2FsJyB9KVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tT2JqZWN0KHsgaG91cjogMTAsIG1pbnV0ZTogMjYsIHNlY29uZDogNiB9LCB7IHpvbmU6ICdBbWVyaWNhL05ld19Zb3JrJyB9KVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tT2JqZWN0KHsgd2Vla1llYXI6IDIwMTYsIHdlZWtOdW1iZXI6IDIsIHdlZWtkYXk6IDMgfSkudG9JU09EYXRlKCkgLy89PiAnMjAxNi0wMS0xMydcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbU9iamVjdChvYmosIG9wdHMgPSB7fSkge1xuICAgIG9iaiA9IG9iaiB8fCB7fTtcbiAgICBjb25zdCB6b25lVG9Vc2UgPSBub3JtYWxpemVab25lKG9wdHMuem9uZSwgU2V0dGluZ3MuZGVmYXVsdFpvbmUpO1xuICAgIGlmICghem9uZVRvVXNlLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKHVuc3VwcG9ydGVkWm9uZSh6b25lVG9Vc2UpKTtcbiAgICB9XG5cbiAgICBjb25zdCB0c05vdyA9IFNldHRpbmdzLm5vdygpLFxuICAgICAgb2Zmc2V0UHJvdmlzID0gIWlzVW5kZWZpbmVkKG9wdHMuc3BlY2lmaWNPZmZzZXQpXG4gICAgICAgID8gb3B0cy5zcGVjaWZpY09mZnNldFxuICAgICAgICA6IHpvbmVUb1VzZS5vZmZzZXQodHNOb3cpLFxuICAgICAgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZU9iamVjdChvYmosIG5vcm1hbGl6ZVVuaXQpLFxuICAgICAgY29udGFpbnNPcmRpbmFsID0gIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQub3JkaW5hbCksXG4gICAgICBjb250YWluc0dyZWdvclllYXIgPSAhaXNVbmRlZmluZWQobm9ybWFsaXplZC55ZWFyKSxcbiAgICAgIGNvbnRhaW5zR3JlZ29yTUQgPSAhaXNVbmRlZmluZWQobm9ybWFsaXplZC5tb250aCkgfHwgIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQuZGF5KSxcbiAgICAgIGNvbnRhaW5zR3JlZ29yID0gY29udGFpbnNHcmVnb3JZZWFyIHx8IGNvbnRhaW5zR3JlZ29yTUQsXG4gICAgICBkZWZpbml0ZVdlZWtEZWYgPSBub3JtYWxpemVkLndlZWtZZWFyIHx8IG5vcm1hbGl6ZWQud2Vla051bWJlcixcbiAgICAgIGxvYyA9IExvY2FsZS5mcm9tT2JqZWN0KG9wdHMpO1xuXG4gICAgLy8gY2FzZXM6XG4gICAgLy8ganVzdCBhIHdlZWtkYXkgLT4gdGhpcyB3ZWVrJ3MgaW5zdGFuY2Ugb2YgdGhhdCB3ZWVrZGF5LCBubyB3b3JyaWVzXG4gICAgLy8gKGdyZWdvcmlhbiBkYXRhIG9yIG9yZGluYWwpICsgKHdlZWtZZWFyIG9yIHdlZWtOdW1iZXIpIC0+IGVycm9yXG4gICAgLy8gKGdyZWdvcmlhbiBtb250aCBvciBkYXkpICsgb3JkaW5hbCAtPiBlcnJvclxuICAgIC8vIG90aGVyd2lzZSBqdXN0IHVzZSB3ZWVrcyBvciBvcmRpbmFscyBvciBncmVnb3JpYW4sIGRlcGVuZGluZyBvbiB3aGF0J3Mgc3BlY2lmaWVkXG5cbiAgICBpZiAoKGNvbnRhaW5zR3JlZ29yIHx8IGNvbnRhaW5zT3JkaW5hbCkgJiYgZGVmaW5pdGVXZWVrRGVmKSB7XG4gICAgICB0aHJvdyBuZXcgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IoXG4gICAgICAgIFwiQ2FuJ3QgbWl4IHdlZWtZZWFyL3dlZWtOdW1iZXIgdW5pdHMgd2l0aCB5ZWFyL21vbnRoL2RheSBvciBvcmRpbmFsc1wiXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChjb250YWluc0dyZWdvck1EICYmIGNvbnRhaW5zT3JkaW5hbCkge1xuICAgICAgdGhyb3cgbmV3IENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yKFwiQ2FuJ3QgbWl4IG9yZGluYWwgZGF0ZXMgd2l0aCBtb250aC9kYXlcIik7XG4gICAgfVxuXG4gICAgY29uc3QgdXNlV2Vla0RhdGEgPSBkZWZpbml0ZVdlZWtEZWYgfHwgKG5vcm1hbGl6ZWQud2Vla2RheSAmJiAhY29udGFpbnNHcmVnb3IpO1xuXG4gICAgLy8gY29uZmlndXJlIG91cnNlbHZlcyB0byBkZWFsIHdpdGggZ3JlZ29yaWFuIGRhdGVzIG9yIHdlZWsgc3R1ZmZcbiAgICBsZXQgdW5pdHMsXG4gICAgICBkZWZhdWx0VmFsdWVzLFxuICAgICAgb2JqTm93ID0gdHNUb09iaih0c05vdywgb2Zmc2V0UHJvdmlzKTtcbiAgICBpZiAodXNlV2Vla0RhdGEpIHtcbiAgICAgIHVuaXRzID0gb3JkZXJlZFdlZWtVbml0cztcbiAgICAgIGRlZmF1bHRWYWx1ZXMgPSBkZWZhdWx0V2Vla1VuaXRWYWx1ZXM7XG4gICAgICBvYmpOb3cgPSBncmVnb3JpYW5Ub1dlZWsob2JqTm93KTtcbiAgICB9IGVsc2UgaWYgKGNvbnRhaW5zT3JkaW5hbCkge1xuICAgICAgdW5pdHMgPSBvcmRlcmVkT3JkaW5hbFVuaXRzO1xuICAgICAgZGVmYXVsdFZhbHVlcyA9IGRlZmF1bHRPcmRpbmFsVW5pdFZhbHVlcztcbiAgICAgIG9iak5vdyA9IGdyZWdvcmlhblRvT3JkaW5hbChvYmpOb3cpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1bml0cyA9IG9yZGVyZWRVbml0cztcbiAgICAgIGRlZmF1bHRWYWx1ZXMgPSBkZWZhdWx0VW5pdFZhbHVlcztcbiAgICB9XG5cbiAgICAvLyBzZXQgZGVmYXVsdCB2YWx1ZXMgZm9yIG1pc3Npbmcgc3R1ZmZcbiAgICBsZXQgZm91bmRGaXJzdCA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgdSBvZiB1bml0cykge1xuICAgICAgY29uc3QgdiA9IG5vcm1hbGl6ZWRbdV07XG4gICAgICBpZiAoIWlzVW5kZWZpbmVkKHYpKSB7XG4gICAgICAgIGZvdW5kRmlyc3QgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChmb3VuZEZpcnN0KSB7XG4gICAgICAgIG5vcm1hbGl6ZWRbdV0gPSBkZWZhdWx0VmFsdWVzW3VdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9ybWFsaXplZFt1XSA9IG9iak5vd1t1XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBtYWtlIHN1cmUgdGhlIHZhbHVlcyB3ZSBoYXZlIGFyZSBpbiByYW5nZVxuICAgIGNvbnN0IGhpZ2hlck9yZGVySW52YWxpZCA9IHVzZVdlZWtEYXRhXG4gICAgICAgID8gaGFzSW52YWxpZFdlZWtEYXRhKG5vcm1hbGl6ZWQpXG4gICAgICAgIDogY29udGFpbnNPcmRpbmFsXG4gICAgICAgID8gaGFzSW52YWxpZE9yZGluYWxEYXRhKG5vcm1hbGl6ZWQpXG4gICAgICAgIDogaGFzSW52YWxpZEdyZWdvcmlhbkRhdGEobm9ybWFsaXplZCksXG4gICAgICBpbnZhbGlkID0gaGlnaGVyT3JkZXJJbnZhbGlkIHx8IGhhc0ludmFsaWRUaW1lRGF0YShub3JtYWxpemVkKTtcblxuICAgIGlmIChpbnZhbGlkKSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChpbnZhbGlkKTtcbiAgICB9XG5cbiAgICAvLyBjb21wdXRlIHRoZSBhY3R1YWwgdGltZVxuICAgIGNvbnN0IGdyZWdvcmlhbiA9IHVzZVdlZWtEYXRhXG4gICAgICAgID8gd2Vla1RvR3JlZ29yaWFuKG5vcm1hbGl6ZWQpXG4gICAgICAgIDogY29udGFpbnNPcmRpbmFsXG4gICAgICAgID8gb3JkaW5hbFRvR3JlZ29yaWFuKG5vcm1hbGl6ZWQpXG4gICAgICAgIDogbm9ybWFsaXplZCxcbiAgICAgIFt0c0ZpbmFsLCBvZmZzZXRGaW5hbF0gPSBvYmpUb1RTKGdyZWdvcmlhbiwgb2Zmc2V0UHJvdmlzLCB6b25lVG9Vc2UpLFxuICAgICAgaW5zdCA9IG5ldyBEYXRlVGltZSh7XG4gICAgICAgIHRzOiB0c0ZpbmFsLFxuICAgICAgICB6b25lOiB6b25lVG9Vc2UsXG4gICAgICAgIG86IG9mZnNldEZpbmFsLFxuICAgICAgICBsb2MsXG4gICAgICB9KTtcblxuICAgIC8vIGdyZWdvcmlhbiBkYXRhICsgd2Vla2RheSBzZXJ2ZXMgb25seSB0byB2YWxpZGF0ZVxuICAgIGlmIChub3JtYWxpemVkLndlZWtkYXkgJiYgY29udGFpbnNHcmVnb3IgJiYgb2JqLndlZWtkYXkgIT09IGluc3Qud2Vla2RheSkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQoXG4gICAgICAgIFwibWlzbWF0Y2hlZCB3ZWVrZGF5XCIsXG4gICAgICAgIGB5b3UgY2FuJ3Qgc3BlY2lmeSBib3RoIGEgd2Vla2RheSBvZiAke25vcm1hbGl6ZWQud2Vla2RheX0gYW5kIGEgZGF0ZSBvZiAke2luc3QudG9JU08oKX1gXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBpbnN0O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYW4gSVNPIDg2MDEgc3RyaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGhlIElTTyBzdHJpbmdcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRvIGFmZmVjdCB0aGUgY3JlYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdHMuem9uZT0nbG9jYWwnXSAtIHVzZSB0aGlzIHpvbmUgaWYgbm8gb2Zmc2V0IGlzIHNwZWNpZmllZCBpbiB0aGUgaW5wdXQgc3RyaW5nIGl0c2VsZi4gV2lsbCBhbHNvIGNvbnZlcnQgdGhlIHRpbWUgdG8gdGhpcyB6b25lXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc2V0Wm9uZT1mYWxzZV0gLSBvdmVycmlkZSB0aGUgem9uZSB3aXRoIGEgZml4ZWQtb2Zmc2V0IHpvbmUgc3BlY2lmaWVkIGluIHRoZSBzdHJpbmcgaXRzZWxmLCBpZiBpdCBzcGVjaWZpZXMgb25lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J3N5c3RlbSdzIGxvY2FsZSddIC0gYSBsb2NhbGUgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm91dHB1dENhbGVuZGFyXSAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm51bWJlcmluZ1N5c3RlbV0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSVNPKCcyMDE2LTA1LTI1VDA5OjA4OjM0LjEyMycpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21JU08oJzIwMTYtMDUtMjVUMDk6MDg6MzQuMTIzKzA2OjAwJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUlTTygnMjAxNi0wNS0yNVQwOTowODozNC4xMjMrMDY6MDAnLCB7c2V0Wm9uZTogdHJ1ZX0pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21JU08oJzIwMTYtMDUtMjVUMDk6MDg6MzQuMTIzJywge3pvbmU6ICd1dGMnfSlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUlTTygnMjAxNi1XMDUtNCcpXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21JU08odGV4dCwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgW3ZhbHMsIHBhcnNlZFpvbmVdID0gcGFyc2VJU09EYXRlKHRleHQpO1xuICAgIHJldHVybiBwYXJzZURhdGFUb0RhdGVUaW1lKHZhbHMsIHBhcnNlZFpvbmUsIG9wdHMsIFwiSVNPIDg2MDFcIiwgdGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhbiBSRkMgMjgyMiBzdHJpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0aGUgUkZDIDI4MjIgc3RyaW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0byBhZmZlY3QgdGhlIGNyZWF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFtvcHRzLnpvbmU9J2xvY2FsJ10gLSBjb252ZXJ0IHRoZSB0aW1lIHRvIHRoaXMgem9uZS4gU2luY2UgdGhlIG9mZnNldCBpcyBhbHdheXMgc3BlY2lmaWVkIGluIHRoZSBzdHJpbmcgaXRzZWxmLCB0aGlzIGhhcyBubyBlZmZlY3Qgb24gdGhlIGludGVycHJldGF0aW9uIG9mIHN0cmluZywgbWVyZWx5IHRoZSB6b25lIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaXMgZXhwcmVzc2VkIGluLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnNldFpvbmU9ZmFsc2VdIC0gb3ZlcnJpZGUgdGhlIHpvbmUgd2l0aCBhIGZpeGVkLW9mZnNldCB6b25lIHNwZWNpZmllZCBpbiB0aGUgc3RyaW5nIGl0c2VsZiwgaWYgaXQgc3BlY2lmaWVzIG9uZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdzeXN0ZW0ncyBsb2NhbGUnXSAtIGEgbG9jYWxlIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm91dHB1dENhbGVuZGFyIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tUkZDMjgyMignMjUgTm92IDIwMTYgMTM6MjM6MTIgR01UJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVJGQzI4MjIoJ0ZyaSwgMjUgTm92IDIwMTYgMTM6MjM6MTIgKzA2MDAnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tUkZDMjgyMignMjUgTm92IDIwMTYgMTM6MjMgWicpXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21SRkMyODIyKHRleHQsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IFt2YWxzLCBwYXJzZWRab25lXSA9IHBhcnNlUkZDMjgyMkRhdGUodGV4dCk7XG4gICAgcmV0dXJuIHBhcnNlRGF0YVRvRGF0ZVRpbWUodmFscywgcGFyc2VkWm9uZSwgb3B0cywgXCJSRkMgMjgyMlwiLCB0ZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGFuIEhUVFAgaGVhZGVyIGRhdGVcbiAgICogQHNlZSBodHRwczovL3d3dy53My5vcmcvUHJvdG9jb2xzL3JmYzI2MTYvcmZjMjYxNi1zZWMzLmh0bWwjc2VjMy4zLjFcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0aGUgSFRUUCBoZWFkZXIgZGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdG8gYWZmZWN0IHRoZSBjcmVhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0cy56b25lPSdsb2NhbCddIC0gY29udmVydCB0aGUgdGltZSB0byB0aGlzIHpvbmUuIFNpbmNlIEhUVFAgZGF0ZXMgYXJlIGFsd2F5cyBpbiBVVEMsIHRoaXMgaGFzIG5vIGVmZmVjdCBvbiB0aGUgaW50ZXJwcmV0YXRpb24gb2Ygc3RyaW5nLCBtZXJlbHkgdGhlIHpvbmUgdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpcyBleHByZXNzZWQgaW4uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc2V0Wm9uZT1mYWxzZV0gLSBvdmVycmlkZSB0aGUgem9uZSB3aXRoIHRoZSBmaXhlZC1vZmZzZXQgem9uZSBzcGVjaWZpZWQgaW4gdGhlIHN0cmluZy4gRm9yIEhUVFAgZGF0ZXMsIHRoaXMgaXMgYWx3YXlzIFVUQywgc28gdGhpcyBvcHRpb24gaXMgZXF1aXZhbGVudCB0byBzZXR0aW5nIHRoZSBgem9uZWAgb3B0aW9uIHRvICd1dGMnLCBidXQgdGhpcyBvcHRpb24gaXMgaW5jbHVkZWQgZm9yIGNvbnNpc3RlbmN5IHdpdGggc2ltaWxhciBtZXRob2RzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdzeXN0ZW0ncyBsb2NhbGUnXSAtIGEgbG9jYWxlIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm91dHB1dENhbGVuZGFyIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSFRUUCgnU3VuLCAwNiBOb3YgMTk5NCAwODo0OTozNyBHTVQnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSFRUUCgnU3VuZGF5LCAwNi1Ob3YtOTQgMDg6NDk6MzcgR01UJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUhUVFAoJ1N1biBOb3YgIDYgMDg6NDk6MzcgMTk5NCcpXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21IVFRQKHRleHQsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IFt2YWxzLCBwYXJzZWRab25lXSA9IHBhcnNlSFRUUERhdGUodGV4dCk7XG4gICAgcmV0dXJuIHBhcnNlRGF0YVRvRGF0ZVRpbWUodmFscywgcGFyc2VkWm9uZSwgb3B0cywgXCJIVFRQXCIsIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYW4gaW5wdXQgc3RyaW5nIGFuZCBmb3JtYXQgc3RyaW5nLlxuICAgKiBEZWZhdWx0cyB0byBlbi1VUyBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkLCByZWdhcmRsZXNzIG9mIHRoZSBzeXN0ZW0ncyBsb2NhbGUuIEZvciBhIHRhYmxlIG9mIHRva2VucyBhbmQgdGhlaXIgaW50ZXJwcmV0YXRpb25zLCBzZWUgW2hlcmVdKGh0dHBzOi8vbW9tZW50LmdpdGh1Yi5pby9sdXhvbi8jL3BhcnNpbmc/aWQ9dGFibGUtb2YtdG9rZW5zKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0aGUgc3RyaW5nIHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmbXQgLSB0aGUgZm9ybWF0IHRoZSBzdHJpbmcgaXMgZXhwZWN0ZWQgdG8gYmUgaW4gKHNlZSB0aGUgbGluayBiZWxvdyBmb3IgdGhlIGZvcm1hdHMpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0byBhZmZlY3QgdGhlIGNyZWF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFtvcHRzLnpvbmU9J2xvY2FsJ10gLSB1c2UgdGhpcyB6b25lIGlmIG5vIG9mZnNldCBpcyBzcGVjaWZpZWQgaW4gdGhlIGlucHV0IHN0cmluZyBpdHNlbGYuIFdpbGwgYWxzbyBjb252ZXJ0IHRoZSBEYXRlVGltZSB0byB0aGlzIHpvbmVcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zZXRab25lPWZhbHNlXSAtIG92ZXJyaWRlIHRoZSB6b25lIHdpdGggYSB6b25lIHNwZWNpZmllZCBpbiB0aGUgc3RyaW5nIGl0c2VsZiwgaWYgaXQgc3BlY2lmaWVzIG9uZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdlbi1VUyddIC0gYSBsb2NhbGUgc3RyaW5nIHRvIHVzZSB3aGVuIHBhcnNpbmcuIFdpbGwgYWxzbyBzZXQgdGhlIERhdGVUaW1lIHRvIHRoaXMgbG9jYWxlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHVzZSB3aGVuIHBhcnNpbmcuIFdpbGwgYWxzbyBzZXQgdGhlIHJlc3VsdGluZyBEYXRlVGltZSB0byB0aGlzIG51bWJlcmluZyBzeXN0ZW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMub3V0cHV0Q2FsZW5kYXIgLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21Gb3JtYXQodGV4dCwgZm10LCBvcHRzID0ge30pIHtcbiAgICBpZiAoaXNVbmRlZmluZWQodGV4dCkgfHwgaXNVbmRlZmluZWQoZm10KSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiZnJvbUZvcm1hdCByZXF1aXJlcyBhbiBpbnB1dCBzdHJpbmcgYW5kIGEgZm9ybWF0XCIpO1xuICAgIH1cblxuICAgIGNvbnN0IHsgbG9jYWxlID0gbnVsbCwgbnVtYmVyaW5nU3lzdGVtID0gbnVsbCB9ID0gb3B0cyxcbiAgICAgIGxvY2FsZVRvVXNlID0gTG9jYWxlLmZyb21PcHRzKHtcbiAgICAgICAgbG9jYWxlLFxuICAgICAgICBudW1iZXJpbmdTeXN0ZW0sXG4gICAgICAgIGRlZmF1bHRUb0VOOiB0cnVlLFxuICAgICAgfSksXG4gICAgICBbdmFscywgcGFyc2VkWm9uZSwgc3BlY2lmaWNPZmZzZXQsIGludmFsaWRdID0gcGFyc2VGcm9tVG9rZW5zKGxvY2FsZVRvVXNlLCB0ZXh0LCBmbXQpO1xuICAgIGlmIChpbnZhbGlkKSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChpbnZhbGlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHBhcnNlRGF0YVRvRGF0ZVRpbWUodmFscywgcGFyc2VkWm9uZSwgb3B0cywgYGZvcm1hdCAke2ZtdH1gLCB0ZXh0LCBzcGVjaWZpY09mZnNldCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBmcm9tRm9ybWF0IGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBmcm9tU3RyaW5nKHRleHQsIGZtdCwgb3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIERhdGVUaW1lLmZyb21Gb3JtYXQodGV4dCwgZm10LCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGEgU1FMIGRhdGUsIHRpbWUsIG9yIGRhdGV0aW1lXG4gICAqIERlZmF1bHRzIHRvIGVuLVVTIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWQsIHJlZ2FyZGxlc3Mgb2YgdGhlIHN5c3RlbSdzIGxvY2FsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRvIGFmZmVjdCB0aGUgY3JlYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdHMuem9uZT0nbG9jYWwnXSAtIHVzZSB0aGlzIHpvbmUgaWYgbm8gb2Zmc2V0IGlzIHNwZWNpZmllZCBpbiB0aGUgaW5wdXQgc3RyaW5nIGl0c2VsZi4gV2lsbCBhbHNvIGNvbnZlcnQgdGhlIERhdGVUaW1lIHRvIHRoaXMgem9uZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnNldFpvbmU9ZmFsc2VdIC0gb3ZlcnJpZGUgdGhlIHpvbmUgd2l0aCBhIHpvbmUgc3BlY2lmaWVkIGluIHRoZSBzdHJpbmcgaXRzZWxmLCBpZiBpdCBzcGVjaWZpZXMgb25lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J2VuLVVTJ10gLSBhIGxvY2FsZSBzdHJpbmcgdG8gdXNlIHdoZW4gcGFyc2luZy4gV2lsbCBhbHNvIHNldCB0aGUgRGF0ZVRpbWUgdG8gdGhpcyBsb2NhbGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gdXNlIHdoZW4gcGFyc2luZy4gV2lsbCBhbHNvIHNldCB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIHRvIHRoaXMgbnVtYmVyaW5nIHN5c3RlbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5vdXRwdXRDYWxlbmRhciAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMjAxNy0wNS0xNScpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzIwMTctMDUtMTUgMDk6MTI6MzQnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcyMDE3LTA1LTE1IDA5OjEyOjM0LjM0MicpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzIwMTctMDUtMTUgMDk6MTI6MzQuMzQyKzA2OjAwJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMjAxNy0wNS0xNSAwOToxMjozNC4zNDIgQW1lcmljYS9Mb3NfQW5nZWxlcycpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzIwMTctMDUtMTUgMDk6MTI6MzQuMzQyIEFtZXJpY2EvTG9zX0FuZ2VsZXMnLCB7IHNldFpvbmU6IHRydWUgfSlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMjAxNy0wNS0xNSAwOToxMjozNC4zNDInLCB7IHpvbmU6ICdBbWVyaWNhL0xvc19BbmdlbGVzJyB9KVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcwOToxMjozNC4zNDInKVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tU1FMKHRleHQsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IFt2YWxzLCBwYXJzZWRab25lXSA9IHBhcnNlU1FMKHRleHQpO1xuICAgIHJldHVybiBwYXJzZURhdGFUb0RhdGVUaW1lKHZhbHMsIHBhcnNlZFpvbmUsIG9wdHMsIFwiU1FMXCIsIHRleHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnZhbGlkIERhdGVUaW1lLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uIC0gc2ltcGxlIHN0cmluZyBvZiB3aHkgdGhpcyBEYXRlVGltZSBpcyBpbnZhbGlkLiBTaG91bGQgbm90IGNvbnRhaW4gcGFyYW1ldGVycyBvciBhbnl0aGluZyBlbHNlIGRhdGEtZGVwZW5kZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2V4cGxhbmF0aW9uPW51bGxdIC0gbG9uZ2VyIGV4cGxhbmF0aW9uLCBtYXkgaW5jbHVkZSBwYXJhbWV0ZXJzIGFuZCBvdGhlciB1c2VmdWwgZGVidWdnaW5nIGluZm9ybWF0aW9uXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGludmFsaWQocmVhc29uLCBleHBsYW5hdGlvbiA9IG51bGwpIHtcbiAgICBpZiAoIXJlYXNvbikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwibmVlZCB0byBzcGVjaWZ5IGEgcmVhc29uIHRoZSBEYXRlVGltZSBpcyBpbnZhbGlkXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGludmFsaWQgPSByZWFzb24gaW5zdGFuY2VvZiBJbnZhbGlkID8gcmVhc29uIDogbmV3IEludmFsaWQocmVhc29uLCBleHBsYW5hdGlvbik7XG5cbiAgICBpZiAoU2V0dGluZ3MudGhyb3dPbkludmFsaWQpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkRGF0ZVRpbWVFcnJvcihpbnZhbGlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlVGltZSh7IGludmFsaWQgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIG9iamVjdCBpcyBhbiBpbnN0YW5jZSBvZiBEYXRlVGltZS4gV29ya3MgYWNyb3NzIGNvbnRleHQgYm91bmRhcmllc1xuICAgKiBAcGFyYW0ge29iamVjdH0gb1xuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzRGF0ZVRpbWUobykge1xuICAgIHJldHVybiAobyAmJiBvLmlzTHV4b25EYXRlVGltZSkgfHwgZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUHJvZHVjZSB0aGUgZm9ybWF0IHN0cmluZyBmb3IgYSBzZXQgb2Ygb3B0aW9uc1xuICAgKiBAcGFyYW0gZm9ybWF0T3B0c1xuICAgKiBAcGFyYW0gbG9jYWxlT3B0c1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIHBhcnNlRm9ybWF0Rm9yT3B0cyhmb3JtYXRPcHRzLCBsb2NhbGVPcHRzID0ge30pIHtcbiAgICBjb25zdCB0b2tlbkxpc3QgPSBmb3JtYXRPcHRzVG9Ub2tlbnMoZm9ybWF0T3B0cywgTG9jYWxlLmZyb21PYmplY3QobG9jYWxlT3B0cykpO1xuICAgIHJldHVybiAhdG9rZW5MaXN0ID8gbnVsbCA6IHRva2VuTGlzdC5tYXAoKHQpID0+ICh0ID8gdC52YWwgOiBudWxsKSkuam9pbihcIlwiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9kdWNlIHRoZSB0aGUgZnVsbHkgZXhwYW5kZWQgZm9ybWF0IHRva2VuIGZvciB0aGUgbG9jYWxlXG4gICAqIERvZXMgTk9UIHF1b3RlIGNoYXJhY3RlcnMsIHNvIHF1b3RlZCB0b2tlbnMgd2lsbCBub3Qgcm91bmQgdHJpcCBjb3JyZWN0bHlcbiAgICogQHBhcmFtIGZtdFxuICAgKiBAcGFyYW0gbG9jYWxlT3B0c1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGV4cGFuZEZvcm1hdChmbXQsIGxvY2FsZU9wdHMgPSB7fSkge1xuICAgIGNvbnN0IGV4cGFuZGVkID0gZXhwYW5kTWFjcm9Ub2tlbnMoRm9ybWF0dGVyLnBhcnNlRm9ybWF0KGZtdCksIExvY2FsZS5mcm9tT2JqZWN0KGxvY2FsZU9wdHMpKTtcbiAgICByZXR1cm4gZXhwYW5kZWQubWFwKCh0KSA9PiB0LnZhbCkuam9pbihcIlwiKTtcbiAgfVxuXG4gIC8vIElORk9cblxuICAvKipcbiAgICogR2V0IHRoZSB2YWx1ZSBvZiB1bml0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIGEgdW5pdCBzdWNoIGFzICdtaW51dGUnIG9yICdkYXknXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDcsIDQpLmdldCgnbW9udGgnKTsgLy89PiA3XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDcsIDQpLmdldCgnZGF5Jyk7IC8vPT4gNFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXQodW5pdCkge1xuICAgIHJldHVybiB0aGlzW3VuaXRdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgRGF0ZVRpbWUgaXMgdmFsaWQuIEludmFsaWQgRGF0ZVRpbWVzIG9jY3VyIHdoZW46XG4gICAqICogVGhlIERhdGVUaW1lIHdhcyBjcmVhdGVkIGZyb20gaW52YWxpZCBjYWxlbmRhciBpbmZvcm1hdGlvbiwgc3VjaCBhcyB0aGUgMTN0aCBtb250aCBvciBGZWJydWFyeSAzMFxuICAgKiAqIFRoZSBEYXRlVGltZSB3YXMgY3JlYXRlZCBieSBhbiBvcGVyYXRpb24gb24gYW5vdGhlciBpbnZhbGlkIGRhdGVcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZhbGlkID09PSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZXJyb3IgY29kZSBpZiB0aGlzIERhdGVUaW1lIGlzIGludmFsaWQsIG9yIG51bGwgaWYgdGhlIERhdGVUaW1lIGlzIHZhbGlkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgaW52YWxpZFJlYXNvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZhbGlkID8gdGhpcy5pbnZhbGlkLnJlYXNvbiA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBleHBsYW5hdGlvbiBvZiB3aHkgdGhpcyBEYXRlVGltZSBiZWNhbWUgaW52YWxpZCwgb3IgbnVsbCBpZiB0aGUgRGF0ZVRpbWUgaXMgdmFsaWRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBpbnZhbGlkRXhwbGFuYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZCA/IHRoaXMuaW52YWxpZC5leHBsYW5hdGlvbiA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsb2NhbGUgb2YgYSBEYXRlVGltZSwgc3VjaCAnZW4tR0InLiBUaGUgbG9jYWxlIGlzIHVzZWQgd2hlbiBmb3JtYXR0aW5nIHRoZSBEYXRlVGltZVxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGxvY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5sb2MubG9jYWxlIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG51bWJlcmluZyBzeXN0ZW0gb2YgYSBEYXRlVGltZSwgc3VjaCAnYmVuZycuIFRoZSBudW1iZXJpbmcgc3lzdGVtIGlzIHVzZWQgd2hlbiBmb3JtYXR0aW5nIHRoZSBEYXRlVGltZVxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG51bWJlcmluZ1N5c3RlbSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5sb2MubnVtYmVyaW5nU3lzdGVtIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG91dHB1dCBjYWxlbmRhciBvZiBhIERhdGVUaW1lLCBzdWNoICdpc2xhbWljJy4gVGhlIG91dHB1dCBjYWxlbmRhciBpcyB1c2VkIHdoZW4gZm9ybWF0dGluZyB0aGUgRGF0ZVRpbWVcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBvdXRwdXRDYWxlbmRhcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5sb2Mub3V0cHV0Q2FsZW5kYXIgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdGltZSB6b25lIGFzc29jaWF0ZWQgd2l0aCB0aGlzIERhdGVUaW1lLlxuICAgKiBAdHlwZSB7Wm9uZX1cbiAgICovXG4gIGdldCB6b25lKCkge1xuICAgIHJldHVybiB0aGlzLl96b25lO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmFtZSBvZiB0aGUgdGltZSB6b25lLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IHpvbmVOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnpvbmUubmFtZSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB5ZWFyXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS55ZWFyIC8vPT4gMjAxN1xuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHllYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuYy55ZWFyIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcXVhcnRlclxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSkucXVhcnRlciAvLz0+IDJcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBxdWFydGVyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBNYXRoLmNlaWwodGhpcy5jLm1vbnRoIC8gMykgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtb250aCAoMS0xMikuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS5tb250aCAvLz0+IDVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBtb250aCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5jLm1vbnRoIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGF5IG9mIHRoZSBtb250aCAoMS0zMGlzaCkuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS5kYXkgLy89PiAyNVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGRheSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5jLmRheSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGhvdXIgb2YgdGhlIGRheSAoMC0yMykuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1LCA5KS5ob3VyIC8vPT4gOVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGhvdXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuYy5ob3VyIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWludXRlIG9mIHRoZSBob3VyICgwLTU5KS5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUsIDksIDMwKS5taW51dGUgLy89PiAzMFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1pbnV0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5jLm1pbnV0ZSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNlY29uZCBvZiB0aGUgbWludXRlICgwLTU5KS5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUsIDksIDMwLCA1Mikuc2Vjb25kIC8vPT4gNTJcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBzZWNvbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuYy5zZWNvbmQgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtaWxsaXNlY29uZCBvZiB0aGUgc2Vjb25kICgwLTk5OSkuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1LCA5LCAzMCwgNTIsIDY1NCkubWlsbGlzZWNvbmQgLy89PiA2NTRcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBtaWxsaXNlY29uZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5jLm1pbGxpc2Vjb25kIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgd2VlayB5ZWFyXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAxMiwgMzEpLndlZWtZZWFyIC8vPT4gMjAxNVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdlZWtZZWFyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBwb3NzaWJseUNhY2hlZFdlZWtEYXRhKHRoaXMpLndlZWtZZWFyIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgd2VlayBudW1iZXIgb2YgdGhlIHdlZWsgeWVhciAoMS01MmlzaCkuXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSkud2Vla051bWJlciAvLz0+IDIxXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgd2Vla051bWJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gcG9zc2libHlDYWNoZWRXZWVrRGF0YSh0aGlzKS53ZWVrTnVtYmVyIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGF5IG9mIHRoZSB3ZWVrLlxuICAgKiAxIGlzIE1vbmRheSBhbmQgNyBpcyBTdW5kYXlcbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDExLCAzMSkud2Vla2RheSAvLz0+IDRcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB3ZWVrZGF5KCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBwb3NzaWJseUNhY2hlZFdlZWtEYXRhKHRoaXMpLndlZWtkYXkgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBvcmRpbmFsIChtZWFuaW5nIHRoZSBkYXkgb2YgdGhlIHllYXIpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS5vcmRpbmFsIC8vPT4gMTQ1XG4gICAqIEB0eXBlIHtudW1iZXJ8RGF0ZVRpbWV9XG4gICAqL1xuICBnZXQgb3JkaW5hbCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gZ3JlZ29yaWFuVG9PcmRpbmFsKHRoaXMuYykub3JkaW5hbCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGh1bWFuIHJlYWRhYmxlIHNob3J0IG1vbnRoIG5hbWUsIHN1Y2ggYXMgJ09jdCcuXG4gICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAxMCwgMzApLm1vbnRoU2hvcnQgLy89PiBPY3RcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBtb250aFNob3J0KCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBJbmZvLm1vbnRocyhcInNob3J0XCIsIHsgbG9jT2JqOiB0aGlzLmxvYyB9KVt0aGlzLm1vbnRoIC0gMV0gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaHVtYW4gcmVhZGFibGUgbG9uZyBtb250aCBuYW1lLCBzdWNoIGFzICdPY3RvYmVyJy5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDEwLCAzMCkubW9udGhMb25nIC8vPT4gT2N0b2JlclxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG1vbnRoTG9uZygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gSW5mby5tb250aHMoXCJsb25nXCIsIHsgbG9jT2JqOiB0aGlzLmxvYyB9KVt0aGlzLm1vbnRoIC0gMV0gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaHVtYW4gcmVhZGFibGUgc2hvcnQgd2Vla2RheSwgc3VjaCBhcyAnTW9uJy5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDEwLCAzMCkud2Vla2RheVNob3J0IC8vPT4gTW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgd2Vla2RheVNob3J0KCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBJbmZvLndlZWtkYXlzKFwic2hvcnRcIiwgeyBsb2NPYmo6IHRoaXMubG9jIH0pW3RoaXMud2Vla2RheSAtIDFdIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGh1bWFuIHJlYWRhYmxlIGxvbmcgd2Vla2RheSwgc3VjaCBhcyAnTW9uZGF5Jy5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDEwLCAzMCkud2Vla2RheUxvbmcgLy89PiBNb25kYXlcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCB3ZWVrZGF5TG9uZygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gSW5mby53ZWVrZGF5cyhcImxvbmdcIiwgeyBsb2NPYmo6IHRoaXMubG9jIH0pW3RoaXMud2Vla2RheSAtIDFdIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIFVUQyBvZmZzZXQgb2YgdGhpcyBEYXRlVGltZSBpbiBtaW51dGVzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLm9mZnNldCAvLz0+IC0yNDBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKCkub2Zmc2V0IC8vPT4gMFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gK3RoaXMubyA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNob3J0IGh1bWFuIG5hbWUgZm9yIHRoZSB6b25lJ3MgY3VycmVudCBvZmZzZXQsIGZvciBleGFtcGxlIFwiRVNUXCIgb3IgXCJFRFRcIi5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgb2Zmc2V0TmFtZVNob3J0KCkge1xuICAgIGlmICh0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnpvbmUub2Zmc2V0TmFtZSh0aGlzLnRzLCB7XG4gICAgICAgIGZvcm1hdDogXCJzaG9ydFwiLFxuICAgICAgICBsb2NhbGU6IHRoaXMubG9jYWxlLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxvbmcgaHVtYW4gbmFtZSBmb3IgdGhlIHpvbmUncyBjdXJyZW50IG9mZnNldCwgZm9yIGV4YW1wbGUgXCJFYXN0ZXJuIFN0YW5kYXJkIFRpbWVcIiBvciBcIkVhc3Rlcm4gRGF5bGlnaHQgVGltZVwiLlxuICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBvZmZzZXROYW1lTG9uZygpIHtcbiAgICBpZiAodGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gdGhpcy56b25lLm9mZnNldE5hbWUodGhpcy50cywge1xuICAgICAgICBmb3JtYXQ6IFwibG9uZ1wiLFxuICAgICAgICBsb2NhbGU6IHRoaXMubG9jYWxlLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgd2hldGhlciB0aGlzIHpvbmUncyBvZmZzZXQgZXZlciBjaGFuZ2VzLCBhcyBpbiBhIERTVC5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNPZmZzZXRGaXhlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy56b25lLmlzVW5pdmVyc2FsIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgd2hldGhlciB0aGUgRGF0ZVRpbWUgaXMgaW4gYSBEU1QuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzSW5EU1QoKSB7XG4gICAgaWYgKHRoaXMuaXNPZmZzZXRGaXhlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB0aGlzLm9mZnNldCA+IHRoaXMuc2V0KHsgbW9udGg6IDEsIGRheTogMSB9KS5vZmZzZXQgfHxcbiAgICAgICAgdGhpcy5vZmZzZXQgPiB0aGlzLnNldCh7IG1vbnRoOiA1IH0pLm9mZnNldFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRob3NlIERhdGVUaW1lcyB3aGljaCBoYXZlIHRoZSBzYW1lIGxvY2FsIHRpbWUgYXMgdGhpcyBEYXRlVGltZSwgYnV0IGEgZGlmZmVyZW50IG9mZnNldCBmcm9tIFVUQ1xuICAgKiBpbiB0aGlzIERhdGVUaW1lJ3Mgem9uZS4gRHVyaW5nIERTVCBjaGFuZ2VzIGxvY2FsIHRpbWUgY2FuIGJlIGFtYmlndW91cywgZm9yIGV4YW1wbGVcbiAgICogYDIwMjMtMTAtMjlUMDI6MzA6MDBgIGluIGBFdXJvcGUvQmVybGluYCBjYW4gaGF2ZSBvZmZzZXQgYCswMTowMGAgb3IgYCswMjowMGAuXG4gICAqIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGJvdGggcG9zc2libGUgRGF0ZVRpbWVzIGlmIHRoaXMgRGF0ZVRpbWUncyBsb2NhbCB0aW1lIGlzIGFtYmlndW91cy5cbiAgICogQHJldHVybnMge0RhdGVUaW1lW119XG4gICAqL1xuICBnZXRQb3NzaWJsZU9mZnNldHMoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQgfHwgdGhpcy5pc09mZnNldEZpeGVkKSB7XG4gICAgICByZXR1cm4gW3RoaXNdO1xuICAgIH1cbiAgICBjb25zdCBkYXlNcyA9IDg2NDAwMDAwO1xuICAgIGNvbnN0IG1pbnV0ZU1zID0gNjAwMDA7XG4gICAgY29uc3QgbG9jYWxUUyA9IG9ialRvTG9jYWxUUyh0aGlzLmMpO1xuICAgIGNvbnN0IG9FYXJsaWVyID0gdGhpcy56b25lLm9mZnNldChsb2NhbFRTIC0gZGF5TXMpO1xuICAgIGNvbnN0IG9MYXRlciA9IHRoaXMuem9uZS5vZmZzZXQobG9jYWxUUyArIGRheU1zKTtcblxuICAgIGNvbnN0IG8xID0gdGhpcy56b25lLm9mZnNldChsb2NhbFRTIC0gb0VhcmxpZXIgKiBtaW51dGVNcyk7XG4gICAgY29uc3QgbzIgPSB0aGlzLnpvbmUub2Zmc2V0KGxvY2FsVFMgLSBvTGF0ZXIgKiBtaW51dGVNcyk7XG4gICAgaWYgKG8xID09PSBvMikge1xuICAgICAgcmV0dXJuIFt0aGlzXTtcbiAgICB9XG4gICAgY29uc3QgdHMxID0gbG9jYWxUUyAtIG8xICogbWludXRlTXM7XG4gICAgY29uc3QgdHMyID0gbG9jYWxUUyAtIG8yICogbWludXRlTXM7XG4gICAgY29uc3QgYzEgPSB0c1RvT2JqKHRzMSwgbzEpO1xuICAgIGNvbnN0IGMyID0gdHNUb09iaih0czIsIG8yKTtcbiAgICBpZiAoXG4gICAgICBjMS5ob3VyID09PSBjMi5ob3VyICYmXG4gICAgICBjMS5taW51dGUgPT09IGMyLm1pbnV0ZSAmJlxuICAgICAgYzEuc2Vjb25kID09PSBjMi5zZWNvbmQgJiZcbiAgICAgIGMxLm1pbGxpc2Vjb25kID09PSBjMi5taWxsaXNlY29uZFxuICAgICkge1xuICAgICAgcmV0dXJuIFtjbG9uZSh0aGlzLCB7IHRzOiB0czEgfSksIGNsb25lKHRoaXMsIHsgdHM6IHRzMiB9KV07XG4gICAgfVxuICAgIHJldHVybiBbdGhpc107XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgRGF0ZVRpbWUgaXMgaW4gYSBsZWFwIHllYXIsIGZhbHNlIG90aGVyd2lzZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE2KS5pc0luTGVhcFllYXIgLy89PiB0cnVlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTMpLmlzSW5MZWFwWWVhciAvLz0+IGZhbHNlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzSW5MZWFwWWVhcigpIHtcbiAgICByZXR1cm4gaXNMZWFwWWVhcih0aGlzLnllYXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBkYXlzIGluIHRoaXMgRGF0ZVRpbWUncyBtb250aFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE2LCAyKS5kYXlzSW5Nb250aCAvLz0+IDI5XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTYsIDMpLmRheXNJbk1vbnRoIC8vPT4gMzFcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBkYXlzSW5Nb250aCgpIHtcbiAgICByZXR1cm4gZGF5c0luTW9udGgodGhpcy55ZWFyLCB0aGlzLm1vbnRoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZGF5cyBpbiB0aGlzIERhdGVUaW1lJ3MgeWVhclxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE2KS5kYXlzSW5ZZWFyIC8vPT4gMzY2XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTMpLmRheXNJblllYXIgLy89PiAzNjVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBkYXlzSW5ZZWFyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBkYXlzSW5ZZWFyKHRoaXMueWVhcikgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHdlZWtzIGluIHRoaXMgRGF0ZVRpbWUncyB5ZWFyXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDA0KS53ZWVrc0luV2Vla1llYXIgLy89PiA1M1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDEzKS53ZWVrc0luV2Vla1llYXIgLy89PiA1MlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdlZWtzSW5XZWVrWWVhcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gd2Vla3NJbldlZWtZZWFyKHRoaXMud2Vla1llYXIpIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlc29sdmVkIEludGwgb3B0aW9ucyBmb3IgdGhpcyBEYXRlVGltZS5cbiAgICogVGhpcyBpcyB1c2VmdWwgaW4gdW5kZXJzdGFuZGluZyB0aGUgYmVoYXZpb3Igb2YgZm9ybWF0dGluZyBtZXRob2RzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gdGhlIHNhbWUgb3B0aW9ucyBhcyB0b0xvY2FsZVN0cmluZ1xuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICByZXNvbHZlZExvY2FsZU9wdGlvbnMob3B0cyA9IHt9KSB7XG4gICAgY29uc3QgeyBsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgY2FsZW5kYXIgfSA9IEZvcm1hdHRlci5jcmVhdGUoXG4gICAgICB0aGlzLmxvYy5jbG9uZShvcHRzKSxcbiAgICAgIG9wdHNcbiAgICApLnJlc29sdmVkT3B0aW9ucyh0aGlzKTtcbiAgICByZXR1cm4geyBsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgb3V0cHV0Q2FsZW5kYXI6IGNhbGVuZGFyIH07XG4gIH1cblxuICAvLyBUUkFOU0ZPUk1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGUgRGF0ZVRpbWUncyB6b25lIHRvIFVUQy4gUmV0dXJucyBhIG5ld2x5LWNvbnN0cnVjdGVkIERhdGVUaW1lLlxuICAgKlxuICAgKiBFcXVpdmFsZW50IHRvIHtAbGluayBEYXRlVGltZSNzZXRab25lfSgndXRjJylcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvZmZzZXQ9MF0gLSBvcHRpb25hbGx5LCBhbiBvZmZzZXQgZnJvbSBVVEMgaW4gbWludXRlc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHM9e31dIC0gb3B0aW9ucyB0byBwYXNzIHRvIGBzZXRab25lKClgXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgdG9VVEMob2Zmc2V0ID0gMCwgb3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0Wm9uZShGaXhlZE9mZnNldFpvbmUuaW5zdGFuY2Uob2Zmc2V0KSwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGUgRGF0ZVRpbWUncyB6b25lIHRvIHRoZSBob3N0J3MgbG9jYWwgem9uZS4gUmV0dXJucyBhIG5ld2x5LWNvbnN0cnVjdGVkIERhdGVUaW1lLlxuICAgKlxuICAgKiBFcXVpdmFsZW50IHRvIGBzZXRab25lKCdsb2NhbCcpYFxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHRvTG9jYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0Wm9uZShTZXR0aW5ncy5kZWZhdWx0Wm9uZSk7XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGUgRGF0ZVRpbWUncyB6b25lIHRvIHNwZWNpZmllZCB6b25lLiBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRGF0ZVRpbWUuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHRoZSBzZXR0ZXIga2VlcHMgdGhlIHVuZGVybHlpbmcgdGltZSB0aGUgc2FtZSAoYXMgaW4sIHRoZSBzYW1lIHRpbWVzdGFtcCksIGJ1dCB0aGUgbmV3IGluc3RhbmNlIHdpbGwgcmVwb3J0IGRpZmZlcmVudCBsb2NhbCB0aW1lcyBhbmQgY29uc2lkZXIgRFNUcyB3aGVuIG1ha2luZyBjb21wdXRhdGlvbnMsIGFzIHdpdGgge0BsaW5rIERhdGVUaW1lI3BsdXN9LiBZb3UgbWF5IHdpc2ggdG8gdXNlIHtAbGluayBEYXRlVGltZSN0b0xvY2FsfSBhbmQge0BsaW5rIERhdGVUaW1lI3RvVVRDfSB3aGljaCBwcm92aWRlIHNpbXBsZSBjb252ZW5pZW5jZSB3cmFwcGVycyBmb3IgY29tbW9ubHkgdXNlZCB6b25lcy5cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW3pvbmU9J2xvY2FsJ10gLSBhIHpvbmUgaWRlbnRpZmllci4gQXMgYSBzdHJpbmcsIHRoYXQgY2FuIGJlIGFueSBJQU5BIHpvbmUgc3VwcG9ydGVkIGJ5IHRoZSBob3N0IGVudmlyb25tZW50LCBvciBhIGZpeGVkLW9mZnNldCBuYW1lIG9mIHRoZSBmb3JtICdVVEMrMycsIG9yIHRoZSBzdHJpbmdzICdsb2NhbCcgb3IgJ3V0YycuIFlvdSBtYXkgYWxzbyBzdXBwbHkgYW4gaW5zdGFuY2Ugb2YgYSB7QGxpbmsgRGF0ZVRpbWUjWm9uZX0gY2xhc3MuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmtlZXBMb2NhbFRpbWU9ZmFsc2VdIC0gSWYgdHJ1ZSwgYWRqdXN0IHRoZSB1bmRlcmx5aW5nIHRpbWUgc28gdGhhdCB0aGUgbG9jYWwgdGltZSBzdGF5cyB0aGUgc2FtZSwgYnV0IGluIHRoZSB0YXJnZXQgem9uZS4gWW91IHNob3VsZCByYXJlbHkgbmVlZCB0aGlzLlxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHNldFpvbmUoem9uZSwgeyBrZWVwTG9jYWxUaW1lID0gZmFsc2UsIGtlZXBDYWxlbmRhclRpbWUgPSBmYWxzZSB9ID0ge30pIHtcbiAgICB6b25lID0gbm9ybWFsaXplWm9uZSh6b25lLCBTZXR0aW5ncy5kZWZhdWx0Wm9uZSk7XG4gICAgaWYgKHpvbmUuZXF1YWxzKHRoaXMuem9uZSkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSBpZiAoIXpvbmUuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQodW5zdXBwb3J0ZWRab25lKHpvbmUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IG5ld1RTID0gdGhpcy50cztcbiAgICAgIGlmIChrZWVwTG9jYWxUaW1lIHx8IGtlZXBDYWxlbmRhclRpbWUpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0R3Vlc3MgPSB6b25lLm9mZnNldCh0aGlzLnRzKTtcbiAgICAgICAgY29uc3QgYXNPYmogPSB0aGlzLnRvT2JqZWN0KCk7XG4gICAgICAgIFtuZXdUU10gPSBvYmpUb1RTKGFzT2JqLCBvZmZzZXRHdWVzcywgem9uZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2xvbmUodGhpcywgeyB0czogbmV3VFMsIHpvbmUgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhlIGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvciBvdXRwdXRDYWxlbmRhci4gUmV0dXJucyBhIG5ld2x5LWNvbnN0cnVjdGVkIERhdGVUaW1lLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyAtIHRoZSBwcm9wZXJ0aWVzIHRvIHNldFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSkucmVjb25maWd1cmUoeyBsb2NhbGU6ICdlbi1HQicgfSlcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICByZWNvbmZpZ3VyZSh7IGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhciB9ID0ge30pIHtcbiAgICBjb25zdCBsb2MgPSB0aGlzLmxvYy5jbG9uZSh7IGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhciB9KTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyBsb2MgfSk7XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGUgbG9jYWxlLiBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRGF0ZVRpbWUuXG4gICAqIEp1c3QgYSBjb252ZW5pZW50IGFsaWFzIGZvciByZWNvbmZpZ3VyZSh7IGxvY2FsZSB9KVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSkuc2V0TG9jYWxlKCdlbi1HQicpXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc2V0TG9jYWxlKGxvY2FsZSkge1xuICAgIHJldHVybiB0aGlzLnJlY29uZmlndXJlKHsgbG9jYWxlIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhlIHZhbHVlcyBvZiBzcGVjaWZpZWQgdW5pdHMuIFJldHVybnMgYSBuZXdseS1jb25zdHJ1Y3RlZCBEYXRlVGltZS5cbiAgICogWW91IGNhbiBvbmx5IHNldCB1bml0cyB3aXRoIHRoaXMgbWV0aG9kOyBmb3IgXCJzZXR0aW5nXCIgbWV0YWRhdGEsIHNlZSB7QGxpbmsgRGF0ZVRpbWUjcmVjb25maWd1cmV9IGFuZCB7QGxpbmsgRGF0ZVRpbWUjc2V0Wm9uZX0uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXMgLSBhIG1hcHBpbmcgb2YgdW5pdHMgdG8gbnVtYmVyc1xuICAgKiBAZXhhbXBsZSBkdC5zZXQoeyB5ZWFyOiAyMDE3IH0pXG4gICAqIEBleGFtcGxlIGR0LnNldCh7IGhvdXI6IDgsIG1pbnV0ZTogMzAgfSlcbiAgICogQGV4YW1wbGUgZHQuc2V0KHsgd2Vla2RheTogNSB9KVxuICAgKiBAZXhhbXBsZSBkdC5zZXQoeyB5ZWFyOiAyMDA1LCBvcmRpbmFsOiAyMzQgfSlcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzZXQodmFsdWVzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuXG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZU9iamVjdCh2YWx1ZXMsIG5vcm1hbGl6ZVVuaXQpLFxuICAgICAgc2V0dGluZ1dlZWtTdHVmZiA9XG4gICAgICAgICFpc1VuZGVmaW5lZChub3JtYWxpemVkLndlZWtZZWFyKSB8fFxuICAgICAgICAhaXNVbmRlZmluZWQobm9ybWFsaXplZC53ZWVrTnVtYmVyKSB8fFxuICAgICAgICAhaXNVbmRlZmluZWQobm9ybWFsaXplZC53ZWVrZGF5KSxcbiAgICAgIGNvbnRhaW5zT3JkaW5hbCA9ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLm9yZGluYWwpLFxuICAgICAgY29udGFpbnNHcmVnb3JZZWFyID0gIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQueWVhciksXG4gICAgICBjb250YWluc0dyZWdvck1EID0gIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQubW9udGgpIHx8ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLmRheSksXG4gICAgICBjb250YWluc0dyZWdvciA9IGNvbnRhaW5zR3JlZ29yWWVhciB8fCBjb250YWluc0dyZWdvck1ELFxuICAgICAgZGVmaW5pdGVXZWVrRGVmID0gbm9ybWFsaXplZC53ZWVrWWVhciB8fCBub3JtYWxpemVkLndlZWtOdW1iZXI7XG5cbiAgICBpZiAoKGNvbnRhaW5zR3JlZ29yIHx8IGNvbnRhaW5zT3JkaW5hbCkgJiYgZGVmaW5pdGVXZWVrRGVmKSB7XG4gICAgICB0aHJvdyBuZXcgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IoXG4gICAgICAgIFwiQ2FuJ3QgbWl4IHdlZWtZZWFyL3dlZWtOdW1iZXIgdW5pdHMgd2l0aCB5ZWFyL21vbnRoL2RheSBvciBvcmRpbmFsc1wiXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChjb250YWluc0dyZWdvck1EICYmIGNvbnRhaW5zT3JkaW5hbCkge1xuICAgICAgdGhyb3cgbmV3IENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yKFwiQ2FuJ3QgbWl4IG9yZGluYWwgZGF0ZXMgd2l0aCBtb250aC9kYXlcIik7XG4gICAgfVxuXG4gICAgbGV0IG1peGVkO1xuICAgIGlmIChzZXR0aW5nV2Vla1N0dWZmKSB7XG4gICAgICBtaXhlZCA9IHdlZWtUb0dyZWdvcmlhbih7IC4uLmdyZWdvcmlhblRvV2Vlayh0aGlzLmMpLCAuLi5ub3JtYWxpemVkIH0pO1xuICAgIH0gZWxzZSBpZiAoIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQub3JkaW5hbCkpIHtcbiAgICAgIG1peGVkID0gb3JkaW5hbFRvR3JlZ29yaWFuKHsgLi4uZ3JlZ29yaWFuVG9PcmRpbmFsKHRoaXMuYyksIC4uLm5vcm1hbGl6ZWQgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1peGVkID0geyAuLi50aGlzLnRvT2JqZWN0KCksIC4uLm5vcm1hbGl6ZWQgfTtcblxuICAgICAgLy8gaWYgd2UgZGlkbid0IHNldCB0aGUgZGF5IGJ1dCB3ZSBlbmRlZCB1cCBvbiBhbiBvdmVyZmxvdyBkYXRlLFxuICAgICAgLy8gdXNlIHRoZSBsYXN0IGRheSBvZiB0aGUgcmlnaHQgbW9udGhcbiAgICAgIGlmIChpc1VuZGVmaW5lZChub3JtYWxpemVkLmRheSkpIHtcbiAgICAgICAgbWl4ZWQuZGF5ID0gTWF0aC5taW4oZGF5c0luTW9udGgobWl4ZWQueWVhciwgbWl4ZWQubW9udGgpLCBtaXhlZC5kYXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IFt0cywgb10gPSBvYmpUb1RTKG1peGVkLCB0aGlzLm8sIHRoaXMuem9uZSk7XG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIHsgdHMsIG8gfSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgcGVyaW9kIG9mIHRpbWUgdG8gdGhpcyBEYXRlVGltZSBhbmQgcmV0dXJuIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWVcbiAgICpcbiAgICogQWRkaW5nIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBvciBtaWxsaXNlY29uZHMgaW5jcmVhc2VzIHRoZSB0aW1lc3RhbXAgYnkgdGhlIHJpZ2h0IG51bWJlciBvZiBtaWxsaXNlY29uZHMuIEFkZGluZyBkYXlzLCBtb250aHMsIG9yIHllYXJzIHNoaWZ0cyB0aGUgY2FsZW5kYXIsIGFjY291bnRpbmcgZm9yIERTVHMgYW5kIGxlYXAgeWVhcnMgYWxvbmcgdGhlIHdheS4gVGh1cywgYGR0LnBsdXMoeyBob3VyczogMjQgfSlgIG1heSByZXN1bHQgaW4gYSBkaWZmZXJlbnQgdGltZSB0aGFuIGBkdC5wbHVzKHsgZGF5czogMSB9KWAgaWYgdGhlcmUncyBhIERTVCBzaGlmdCBpbiBiZXR3ZWVuLlxuICAgKiBAcGFyYW0ge0R1cmF0aW9ufE9iamVjdHxudW1iZXJ9IGR1cmF0aW9uIC0gVGhlIGFtb3VudCB0byBhZGQuIEVpdGhlciBhIEx1eG9uIER1cmF0aW9uLCBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIHRoZSBvYmplY3QgYXJndW1lbnQgdG8gRHVyYXRpb24uZnJvbU9iamVjdCgpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoMTIzKSAvL34+IGluIDEyMyBtaWxsaXNlY29uZHNcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IG1pbnV0ZXM6IDE1IH0pIC8vfj4gaW4gMTUgbWludXRlc1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKHsgZGF5czogMSB9KSAvL34+IHRoaXMgdGltZSB0b21vcnJvd1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKHsgZGF5czogLTEgfSkgLy9+PiB0aGlzIHRpbWUgeWVzdGVyZGF5XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBob3VyczogMywgbWludXRlczogMTMgfSkgLy9+PiBpbiAzIGhyLCAxMyBtaW5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyhEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDMsIG1pbnV0ZXM6IDEzIH0pKSAvL34+IGluIDMgaHIsIDEzIG1pblxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHBsdXMoZHVyYXRpb24pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgZHVyID0gRHVyYXRpb24uZnJvbUR1cmF0aW9uTGlrZShkdXJhdGlvbik7XG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIGFkanVzdFRpbWUodGhpcywgZHVyKSk7XG4gIH1cblxuICAvKipcbiAgICogU3VidHJhY3QgYSBwZXJpb2Qgb2YgdGltZSB0byB0aGlzIERhdGVUaW1lIGFuZCByZXR1cm4gdGhlIHJlc3VsdGluZyBEYXRlVGltZVxuICAgKiBTZWUge0BsaW5rIERhdGVUaW1lI3BsdXN9XG4gICAqIEBwYXJhbSB7RHVyYXRpb258T2JqZWN0fG51bWJlcn0gZHVyYXRpb24gLSBUaGUgYW1vdW50IHRvIHN1YnRyYWN0LiBFaXRoZXIgYSBMdXhvbiBEdXJhdGlvbiwgYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCB0aGUgb2JqZWN0IGFyZ3VtZW50IHRvIER1cmF0aW9uLmZyb21PYmplY3QoKVxuICAgQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBtaW51cyhkdXJhdGlvbikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tRHVyYXRpb25MaWtlKGR1cmF0aW9uKS5uZWdhdGUoKTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgYWRqdXN0VGltZSh0aGlzLCBkdXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoaXMgRGF0ZVRpbWUgdG8gdGhlIGJlZ2lubmluZyBvZiBhIHVuaXQgb2YgdGltZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSBUaGUgdW5pdCB0byBnbyB0byB0aGUgYmVnaW5uaW5nIG9mLiBDYW4gYmUgJ3llYXInLCAncXVhcnRlcicsICdtb250aCcsICd3ZWVrJywgJ2RheScsICdob3VyJywgJ21pbnV0ZScsICdzZWNvbmQnLCBvciAnbWlsbGlzZWNvbmQnLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzKS5zdGFydE9mKCdtb250aCcpLnRvSVNPRGF0ZSgpOyAvLz0+ICcyMDE0LTAzLTAxJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzKS5zdGFydE9mKCd5ZWFyJykudG9JU09EYXRlKCk7IC8vPT4gJzIwMTQtMDEtMDEnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMpLnN0YXJ0T2YoJ3dlZWsnKS50b0lTT0RhdGUoKTsgLy89PiAnMjAxNC0wMy0wMycsIHdlZWtzIGFsd2F5cyBzdGFydCBvbiBNb25kYXlzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMsIDUsIDMwKS5zdGFydE9mKCdkYXknKS50b0lTT1RpbWUoKTsgLy89PiAnMDA6MDAuMDAwLTA1OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzLCA1LCAzMCkuc3RhcnRPZignaG91cicpLnRvSVNPVGltZSgpOyAvLz0+ICcwNTowMDowMC4wMDAtMDU6MDAnXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhcnRPZih1bml0KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IG8gPSB7fSxcbiAgICAgIG5vcm1hbGl6ZWRVbml0ID0gRHVyYXRpb24ubm9ybWFsaXplVW5pdCh1bml0KTtcbiAgICBzd2l0Y2ggKG5vcm1hbGl6ZWRVbml0KSB7XG4gICAgICBjYXNlIFwieWVhcnNcIjpcbiAgICAgICAgby5tb250aCA9IDE7XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlIFwicXVhcnRlcnNcIjpcbiAgICAgIGNhc2UgXCJtb250aHNcIjpcbiAgICAgICAgby5kYXkgPSAxO1xuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSBcIndlZWtzXCI6XG4gICAgICBjYXNlIFwiZGF5c1wiOlxuICAgICAgICBvLmhvdXIgPSAwO1xuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSBcImhvdXJzXCI6XG4gICAgICAgIG8ubWludXRlID0gMDtcbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgXCJtaW51dGVzXCI6XG4gICAgICAgIG8uc2Vjb25kID0gMDtcbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgXCJzZWNvbmRzXCI6XG4gICAgICAgIG8ubWlsbGlzZWNvbmQgPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJtaWxsaXNlY29uZHNcIjpcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBubyBkZWZhdWx0LCBpbnZhbGlkIHVuaXRzIHRocm93IGluIG5vcm1hbGl6ZVVuaXQoKVxuICAgIH1cblxuICAgIGlmIChub3JtYWxpemVkVW5pdCA9PT0gXCJ3ZWVrc1wiKSB7XG4gICAgICBvLndlZWtkYXkgPSAxO1xuICAgIH1cblxuICAgIGlmIChub3JtYWxpemVkVW5pdCA9PT0gXCJxdWFydGVyc1wiKSB7XG4gICAgICBjb25zdCBxID0gTWF0aC5jZWlsKHRoaXMubW9udGggLyAzKTtcbiAgICAgIG8ubW9udGggPSAocSAtIDEpICogMyArIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc2V0KG8pO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhpcyBEYXRlVGltZSB0byB0aGUgZW5kIChtZWFuaW5nIHRoZSBsYXN0IG1pbGxpc2Vjb25kKSBvZiBhIHVuaXQgb2YgdGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIFRoZSB1bml0IHRvIGdvIHRvIHRoZSBlbmQgb2YuIENhbiBiZSAneWVhcicsICdxdWFydGVyJywgJ21vbnRoJywgJ3dlZWsnLCAnZGF5JywgJ2hvdXInLCAnbWludXRlJywgJ3NlY29uZCcsIG9yICdtaWxsaXNlY29uZCcuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMpLmVuZE9mKCdtb250aCcpLnRvSVNPKCk7IC8vPT4gJzIwMTQtMDMtMzFUMjM6NTk6NTkuOTk5LTA1OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzKS5lbmRPZigneWVhcicpLnRvSVNPKCk7IC8vPT4gJzIwMTQtMTItMzFUMjM6NTk6NTkuOTk5LTA1OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzKS5lbmRPZignd2VlaycpLnRvSVNPKCk7IC8vID0+ICcyMDE0LTAzLTA5VDIzOjU5OjU5Ljk5OS0wNTowMCcsIHdlZWtzIHN0YXJ0IG9uIE1vbmRheXNcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMywgNSwgMzApLmVuZE9mKCdkYXknKS50b0lTTygpOyAvLz0+ICcyMDE0LTAzLTAzVDIzOjU5OjU5Ljk5OS0wNTowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMywgNSwgMzApLmVuZE9mKCdob3VyJykudG9JU08oKTsgLy89PiAnMjAxNC0wMy0wM1QwNTo1OTo1OS45OTktMDU6MDAnXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgZW5kT2YodW5pdCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWRcbiAgICAgID8gdGhpcy5wbHVzKHsgW3VuaXRdOiAxIH0pXG4gICAgICAgICAgLnN0YXJ0T2YodW5pdClcbiAgICAgICAgICAubWludXMoMSlcbiAgICAgIDogdGhpcztcbiAgfVxuXG4gIC8vIE9VVFBVVFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgZm9ybWF0dGVkIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIGZvcm1hdCBzdHJpbmcuXG4gICAqICoqWW91IG1heSBub3Qgd2FudCB0aGlzLioqIFNlZSB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvciBhIG1vcmUgZmxleGlibGUgZm9ybWF0dGluZyB0b29sLiBGb3IgYSB0YWJsZSBvZiB0b2tlbnMgYW5kIHRoZWlyIGludGVycHJldGF0aW9ucywgc2VlIFtoZXJlXShodHRwczovL21vbWVudC5naXRodWIuaW8vbHV4b24vIy9mb3JtYXR0aW5nP2lkPXRhYmxlLW9mLXRva2VucykuXG4gICAqIERlZmF1bHRzIHRvIGVuLVVTIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWQsIHJlZ2FyZGxlc3Mgb2YgdGhlIHN5c3RlbSdzIGxvY2FsZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGZtdCAtIHRoZSBmb3JtYXQgc3RyaW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0cyB0byBvdmVycmlkZSB0aGUgY29uZmlndXJhdGlvbiBvcHRpb25zIG9uIHRoaXMgRGF0ZVRpbWVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Gb3JtYXQoJ3l5eXkgTExMIGRkJykgLy89PiAnMjAxNyBBcHIgMjInXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnNldExvY2FsZSgnZnInKS50b0Zvcm1hdCgneXl5eSBMTEwgZGQnKSAvLz0+ICcyMDE3IGF2ci4gMjInXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvRm9ybWF0KCd5eXl5IExMTCBkZCcsIHsgbG9jYWxlOiBcImZyXCIgfSkgLy89PiAnMjAxNyBhdnIuIDIyJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0Zvcm1hdChcIkhIICdob3VycyBhbmQnIG1tICdtaW51dGVzJ1wiKSAvLz0+ICcyMCBob3VycyBhbmQgNTUgbWludXRlcydcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9Gb3JtYXQoZm10LCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkXG4gICAgICA/IEZvcm1hdHRlci5jcmVhdGUodGhpcy5sb2MucmVkZWZhdWx0VG9FTihvcHRzKSkuZm9ybWF0RGF0ZVRpbWVGcm9tU3RyaW5nKHRoaXMsIGZtdClcbiAgICAgIDogSU5WQUxJRDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbG9jYWxpemVkIHN0cmluZyByZXByZXNlbnRpbmcgdGhpcyBkYXRlLiBBY2NlcHRzIHRoZSBzYW1lIG9wdGlvbnMgYXMgdGhlIEludGwuRGF0ZVRpbWVGb3JtYXQgY29uc3RydWN0b3IgYW5kIGFueSBwcmVzZXRzIGRlZmluZWQgYnkgTHV4b24sIHN1Y2ggYXMgYERhdGVUaW1lLkRBVEVfRlVMTGAgb3IgYERhdGVUaW1lLlRJTUVfU0lNUExFYC5cbiAgICogVGhlIGV4YWN0IGJlaGF2aW9yIG9mIHRoaXMgbWV0aG9kIGlzIGJyb3dzZXItc3BlY2lmaWMsIGJ1dCBpbiBnZW5lcmFsIGl0IHdpbGwgcmV0dXJuIGFuIGFwcHJvcHJpYXRlIHJlcHJlc2VudGF0aW9uXG4gICAqIG9mIHRoZSBEYXRlVGltZSBpbiB0aGUgYXNzaWduZWQgbG9jYWxlLlxuICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlVGltZUZvcm1hdFxuICAgKiBAcGFyYW0gZm9ybWF0T3B0cyB7T2JqZWN0fSAtIEludGwuRGF0ZVRpbWVGb3JtYXQgY29uc3RydWN0b3Igb3B0aW9ucyBhbmQgY29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0cyB0byBvdmVycmlkZSB0aGUgY29uZmlndXJhdGlvbiBvcHRpb25zIG9uIHRoaXMgRGF0ZVRpbWVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVTdHJpbmcoKTsgLy89PiA0LzIwLzIwMTdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkuc2V0TG9jYWxlKCdlbi1nYicpLnRvTG9jYWxlU3RyaW5nKCk7IC8vPT4gJzIwLzA0LzIwMTcnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKERhdGVUaW1lLkRBVEVfRlVMTCk7IC8vPT4gJ0FwcmlsIDIwLCAyMDE3J1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5EQVRFX0ZVTEwsIHsgbG9jYWxlOiAnZnInIH0pOyAvLz0+ICcyOCBhb8O7dCAyMDIyJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5USU1FX1NJTVBMRSk7IC8vPT4gJzExOjMyIEFNJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5EQVRFVElNRV9TSE9SVCk7IC8vPT4gJzQvMjAvMjAxNywgMTE6MzIgQU0nXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKHsgd2Vla2RheTogJ2xvbmcnLCBtb250aDogJ2xvbmcnLCBkYXk6ICcyLWRpZ2l0JyB9KTsgLy89PiAnVGh1cnNkYXksIEFwcmlsIDIwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVN0cmluZyh7IHdlZWtkYXk6ICdzaG9ydCcsIG1vbnRoOiAnc2hvcnQnLCBkYXk6ICcyLWRpZ2l0JywgaG91cjogJzItZGlnaXQnLCBtaW51dGU6ICcyLWRpZ2l0JyB9KTsgLy89PiAnVGh1LCBBcHIgMjAsIDExOjI3IEFNJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVN0cmluZyh7IGhvdXI6ICcyLWRpZ2l0JywgbWludXRlOiAnMi1kaWdpdCcsIGhvdXJDeWNsZTogJ2gyMycgfSk7IC8vPT4gJzExOjMyJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0xvY2FsZVN0cmluZyhmb3JtYXRPcHRzID0gRm9ybWF0cy5EQVRFX1NIT1JULCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkXG4gICAgICA/IEZvcm1hdHRlci5jcmVhdGUodGhpcy5sb2MuY2xvbmUob3B0cyksIGZvcm1hdE9wdHMpLmZvcm1hdERhdGVUaW1lKHRoaXMpXG4gICAgICA6IElOVkFMSUQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiBmb3JtYXQgXCJwYXJ0c1wiLCBtZWFuaW5nIGluZGl2aWR1YWwgdG9rZW5zIGFsb25nIHdpdGggbWV0YWRhdGEuIFRoaXMgaXMgYWxsb3dzIGNhbGxlcnMgdG8gcG9zdC1wcm9jZXNzIGluZGl2aWR1YWwgc2VjdGlvbnMgb2YgdGhlIGZvcm1hdHRlZCBvdXRwdXQuXG4gICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGVUaW1lRm9ybWF0L2Zvcm1hdFRvUGFydHNcbiAgICogQHBhcmFtIG9wdHMge09iamVjdH0gLSBJbnRsLkRhdGVUaW1lRm9ybWF0IGNvbnN0cnVjdG9yIG9wdGlvbnMsIHNhbWUgYXMgYHRvTG9jYWxlU3RyaW5nYC5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVQYXJ0cygpOyAvLz0+IFtcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vPT4gICB7IHR5cGU6ICdkYXknLCB2YWx1ZTogJzI1JyB9LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy89PiAgIHsgdHlwZTogJ2xpdGVyYWwnLCB2YWx1ZTogJy8nIH0sXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLz0+ICAgeyB0eXBlOiAnbW9udGgnLCB2YWx1ZTogJzA1JyB9LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy89PiAgIHsgdHlwZTogJ2xpdGVyYWwnLCB2YWx1ZTogJy8nIH0sXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLz0+ICAgeyB0eXBlOiAneWVhcicsIHZhbHVlOiAnMTk4MicgfVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy89PiBdXG4gICAqL1xuICB0b0xvY2FsZVBhcnRzKG9wdHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWRcbiAgICAgID8gRm9ybWF0dGVyLmNyZWF0ZSh0aGlzLmxvYy5jbG9uZShvcHRzKSwgb3B0cykuZm9ybWF0RGF0ZVRpbWVQYXJ0cyh0aGlzKVxuICAgICAgOiBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zdXBwcmVzc01pbGxpc2Vjb25kcz1mYWxzZV0gLSBleGNsdWRlIG1pbGxpc2Vjb25kcyBmcm9tIHRoZSBmb3JtYXQgaWYgdGhleSdyZSAwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc3VwcHJlc3NTZWNvbmRzPWZhbHNlXSAtIGV4Y2x1ZGUgc2Vjb25kcyBmcm9tIHRoZSBmb3JtYXQgaWYgdGhleSdyZSAwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZU9mZnNldD10cnVlXSAtIGluY2x1ZGUgdGhlIG9mZnNldCwgc3VjaCBhcyAnWicgb3IgJy0wNDowMCdcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5leHRlbmRlZFpvbmU9ZmFsc2VdIC0gYWRkIHRoZSB0aW1lIHpvbmUgZm9ybWF0IGV4dGVuc2lvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuZm9ybWF0PSdleHRlbmRlZCddIC0gY2hvb3NlIGJldHdlZW4gdGhlIGJhc2ljIGFuZCBleHRlbmRlZCBmb3JtYXRcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDE5ODMsIDUsIDI1KS50b0lTTygpIC8vPT4gJzE5ODItMDUtMjVUMDA6MDA6MDAuMDAwWidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9JU08oKSAvLz0+ICcyMDE3LTA0LTIyVDIwOjQ3OjA1LjMzNS0wNDowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9JU08oeyBpbmNsdWRlT2Zmc2V0OiBmYWxzZSB9KSAvLz0+ICcyMDE3LTA0LTIyVDIwOjQ3OjA1LjMzNSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9JU08oeyBmb3JtYXQ6ICdiYXNpYycgfSkgLy89PiAnMjAxNzA0MjJUMjA0NzA1LjMzNS0wNDAwJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0lTTyh7XG4gICAgZm9ybWF0ID0gXCJleHRlbmRlZFwiLFxuICAgIHN1cHByZXNzU2Vjb25kcyA9IGZhbHNlLFxuICAgIHN1cHByZXNzTWlsbGlzZWNvbmRzID0gZmFsc2UsXG4gICAgaW5jbHVkZU9mZnNldCA9IHRydWUsXG4gICAgZXh0ZW5kZWRab25lID0gZmFsc2UsXG4gIH0gPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBleHQgPSBmb3JtYXQgPT09IFwiZXh0ZW5kZWRcIjtcblxuICAgIGxldCBjID0gdG9JU09EYXRlKHRoaXMsIGV4dCk7XG4gICAgYyArPSBcIlRcIjtcbiAgICBjICs9IHRvSVNPVGltZSh0aGlzLCBleHQsIHN1cHByZXNzU2Vjb25kcywgc3VwcHJlc3NNaWxsaXNlY29uZHMsIGluY2x1ZGVPZmZzZXQsIGV4dGVuZGVkWm9uZSk7XG4gICAgcmV0dXJuIGM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUncyBkYXRlIGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmZvcm1hdD0nZXh0ZW5kZWQnXSAtIGNob29zZSBiZXR3ZWVuIHRoZSBiYXNpYyBhbmQgZXh0ZW5kZWQgZm9ybWF0XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygxOTgyLCA1LCAyNSkudG9JU09EYXRlKCkgLy89PiAnMTk4Mi0wNS0yNSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDE5ODIsIDUsIDI1KS50b0lTT0RhdGUoeyBmb3JtYXQ6ICdiYXNpYycgfSkgLy89PiAnMTk4MjA1MjUnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSVNPRGF0ZSh7IGZvcm1hdCA9IFwiZXh0ZW5kZWRcIiB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRvSVNPRGF0ZSh0aGlzLCBmb3JtYXQgPT09IFwiZXh0ZW5kZWRcIik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUncyB3ZWVrIGRhdGVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDE5ODIsIDUsIDI1KS50b0lTT1dlZWtEYXRlKCkgLy89PiAnMTk4Mi1XMjEtMidcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9JU09XZWVrRGF0ZSgpIHtcbiAgICByZXR1cm4gdG9UZWNoRm9ybWF0KHRoaXMsIFwia2tray0nVydXVy1jXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lJ3MgdGltZSBjb21wb25lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc3VwcHJlc3NNaWxsaXNlY29uZHM9ZmFsc2VdIC0gZXhjbHVkZSBtaWxsaXNlY29uZHMgZnJvbSB0aGUgZm9ybWF0IGlmIHRoZXkncmUgMFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnN1cHByZXNzU2Vjb25kcz1mYWxzZV0gLSBleGNsdWRlIHNlY29uZHMgZnJvbSB0aGUgZm9ybWF0IGlmIHRoZXkncmUgMFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVPZmZzZXQ9dHJ1ZV0gLSBpbmNsdWRlIHRoZSBvZmZzZXQsIHN1Y2ggYXMgJ1onIG9yICctMDQ6MDAnXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuZXh0ZW5kZWRab25lPXRydWVdIC0gYWRkIHRoZSB0aW1lIHpvbmUgZm9ybWF0IGV4dGVuc2lvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVQcmVmaXg9ZmFsc2VdIC0gaW5jbHVkZSB0aGUgYFRgIHByZWZpeFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuZm9ybWF0PSdleHRlbmRlZCddIC0gY2hvb3NlIGJldHdlZW4gdGhlIGJhc2ljIGFuZCBleHRlbmRlZCBmb3JtYXRcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKCkuc2V0KHsgaG91cjogNywgbWludXRlOiAzNCB9KS50b0lTT1RpbWUoKSAvLz0+ICcwNzozNDoxOS4zNjFaJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoKS5zZXQoeyBob3VyOiA3LCBtaW51dGU6IDM0LCBzZWNvbmRzOiAwLCBtaWxsaXNlY29uZHM6IDAgfSkudG9JU09UaW1lKHsgc3VwcHJlc3NTZWNvbmRzOiB0cnVlIH0pIC8vPT4gJzA3OjM0WidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKCkuc2V0KHsgaG91cjogNywgbWludXRlOiAzNCB9KS50b0lTT1RpbWUoeyBmb3JtYXQ6ICdiYXNpYycgfSkgLy89PiAnMDczNDE5LjM2MVonXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygpLnNldCh7IGhvdXI6IDcsIG1pbnV0ZTogMzQgfSkudG9JU09UaW1lKHsgaW5jbHVkZVByZWZpeDogdHJ1ZSB9KSAvLz0+ICdUMDc6MzQ6MTkuMzYxWidcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9JU09UaW1lKHtcbiAgICBzdXBwcmVzc01pbGxpc2Vjb25kcyA9IGZhbHNlLFxuICAgIHN1cHByZXNzU2Vjb25kcyA9IGZhbHNlLFxuICAgIGluY2x1ZGVPZmZzZXQgPSB0cnVlLFxuICAgIGluY2x1ZGVQcmVmaXggPSBmYWxzZSxcbiAgICBleHRlbmRlZFpvbmUgPSBmYWxzZSxcbiAgICBmb3JtYXQgPSBcImV4dGVuZGVkXCIsXG4gIH0gPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBsZXQgYyA9IGluY2x1ZGVQcmVmaXggPyBcIlRcIiA6IFwiXCI7XG4gICAgcmV0dXJuIChcbiAgICAgIGMgK1xuICAgICAgdG9JU09UaW1lKFxuICAgICAgICB0aGlzLFxuICAgICAgICBmb3JtYXQgPT09IFwiZXh0ZW5kZWRcIixcbiAgICAgICAgc3VwcHJlc3NTZWNvbmRzLFxuICAgICAgICBzdXBwcmVzc01pbGxpc2Vjb25kcyxcbiAgICAgICAgaW5jbHVkZU9mZnNldCxcbiAgICAgICAgZXh0ZW5kZWRab25lXG4gICAgICApXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIFJGQyAyODIyLWNvbXBhdGlibGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTQsIDcsIDEzKS50b1JGQzI4MjIoKSAvLz0+ICdTdW4sIDEzIEp1bCAyMDE0IDAwOjAwOjAwICswMDAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCA3LCAxMykudG9SRkMyODIyKCkgLy89PiAnU3VuLCAxMyBKdWwgMjAxNCAwMDowMDowMCAtMDQwMCdcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9SRkMyODIyKCkge1xuICAgIHJldHVybiB0b1RlY2hGb3JtYXQodGhpcywgXCJFRUUsIGRkIExMTCB5eXl5IEhIOm1tOnNzIFpaWlwiLCBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lIGFwcHJvcHJpYXRlIGZvciB1c2UgaW4gSFRUUCBoZWFkZXJzLiBUaGUgb3V0cHV0IGlzIGFsd2F5cyBleHByZXNzZWQgaW4gR01ULlxuICAgKiBTcGVjaWZpY2FsbHksIHRoZSBzdHJpbmcgY29uZm9ybXMgdG8gUkZDIDExMjMuXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1Byb3RvY29scy9yZmMyNjE2L3JmYzI2MTYtc2VjMy5odG1sI3NlYzMuMy4xXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE0LCA3LCAxMykudG9IVFRQKCkgLy89PiAnU3VuLCAxMyBKdWwgMjAxNCAwMDowMDowMCBHTVQnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE0LCA3LCAxMywgMTkpLnRvSFRUUCgpIC8vPT4gJ1N1biwgMTMgSnVsIDIwMTQgMTk6MDA6MDAgR01UJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0hUVFAoKSB7XG4gICAgcmV0dXJuIHRvVGVjaEZvcm1hdCh0aGlzLnRvVVRDKCksIFwiRUVFLCBkZCBMTEwgeXl5eSBISDptbTpzcyAnR01UJ1wiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBTUUwgRGF0ZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNCwgNywgMTMpLnRvU1FMRGF0ZSgpIC8vPT4gJzIwMTQtMDctMTMnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvU1FMRGF0ZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0b0lTT0RhdGUodGhpcywgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lIGFwcHJvcHJpYXRlIGZvciB1c2UgaW4gU1FMIFRpbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZVpvbmU9ZmFsc2VdIC0gaW5jbHVkZSB0aGUgem9uZSwgc3VjaCBhcyAnQW1lcmljYS9OZXdfWW9yaycuIE92ZXJyaWRlcyBpbmNsdWRlT2Zmc2V0LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVPZmZzZXQ9dHJ1ZV0gLSBpbmNsdWRlIHRoZSBvZmZzZXQsIHN1Y2ggYXMgJ1onIG9yICctMDQ6MDAnXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZU9mZnNldFNwYWNlPXRydWVdIC0gaW5jbHVkZSB0aGUgc3BhY2UgYmV0d2VlbiB0aGUgdGltZSBhbmQgdGhlIG9mZnNldCwgc3VjaCBhcyAnMDU6MTU6MTYuMzQ1IC0wNDowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKCkudG9TUUwoKSAvLz0+ICcwNToxNToxNi4zNDUnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvU1FMKCkgLy89PiAnMDU6MTU6MTYuMzQ1IC0wNDowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9TUUwoeyBpbmNsdWRlT2Zmc2V0OiBmYWxzZSB9KSAvLz0+ICcwNToxNToxNi4zNDUnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvU1FMKHsgaW5jbHVkZVpvbmU6IGZhbHNlIH0pIC8vPT4gJzA1OjE1OjE2LjM0NSBBbWVyaWNhL05ld19Zb3JrJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b1NRTFRpbWUoeyBpbmNsdWRlT2Zmc2V0ID0gdHJ1ZSwgaW5jbHVkZVpvbmUgPSBmYWxzZSwgaW5jbHVkZU9mZnNldFNwYWNlID0gdHJ1ZSB9ID0ge30pIHtcbiAgICBsZXQgZm10ID0gXCJISDptbTpzcy5TU1NcIjtcblxuICAgIGlmIChpbmNsdWRlWm9uZSB8fCBpbmNsdWRlT2Zmc2V0KSB7XG4gICAgICBpZiAoaW5jbHVkZU9mZnNldFNwYWNlKSB7XG4gICAgICAgIGZtdCArPSBcIiBcIjtcbiAgICAgIH1cbiAgICAgIGlmIChpbmNsdWRlWm9uZSkge1xuICAgICAgICBmbXQgKz0gXCJ6XCI7XG4gICAgICB9IGVsc2UgaWYgKGluY2x1ZGVPZmZzZXQpIHtcbiAgICAgICAgZm10ICs9IFwiWlpcIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdG9UZWNoRm9ybWF0KHRoaXMsIGZtdCwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lIGFwcHJvcHJpYXRlIGZvciB1c2UgaW4gU1FMIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVab25lPWZhbHNlXSAtIGluY2x1ZGUgdGhlIHpvbmUsIHN1Y2ggYXMgJ0FtZXJpY2EvTmV3X1lvcmsnLiBPdmVycmlkZXMgaW5jbHVkZU9mZnNldC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlT2Zmc2V0PXRydWVdIC0gaW5jbHVkZSB0aGUgb2Zmc2V0LCBzdWNoIGFzICdaJyBvciAnLTA0OjAwJ1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVPZmZzZXRTcGFjZT10cnVlXSAtIGluY2x1ZGUgdGhlIHNwYWNlIGJldHdlZW4gdGhlIHRpbWUgYW5kIHRoZSBvZmZzZXQsIHN1Y2ggYXMgJzA1OjE1OjE2LjM0NSAtMDQ6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE0LCA3LCAxMykudG9TUUwoKSAvLz0+ICcyMDE0LTA3LTEzIDAwOjAwOjAwLjAwMCBaJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCA3LCAxMykudG9TUUwoKSAvLz0+ICcyMDE0LTA3LTEzIDAwOjAwOjAwLjAwMCAtMDQ6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDcsIDEzKS50b1NRTCh7IGluY2x1ZGVPZmZzZXQ6IGZhbHNlIH0pIC8vPT4gJzIwMTQtMDctMTMgMDA6MDA6MDAuMDAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCA3LCAxMykudG9TUUwoeyBpbmNsdWRlWm9uZTogdHJ1ZSB9KSAvLz0+ICcyMDE0LTA3LTEzIDAwOjAwOjAwLjAwMCBBbWVyaWNhL05ld19Zb3JrJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b1NRTChvcHRzID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGAke3RoaXMudG9TUUxEYXRlKCl9ICR7dGhpcy50b1NRTFRpbWUob3B0cyl9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgYXBwcm9wcmlhdGUgZm9yIGRlYnVnZ2luZ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy50b0lTTygpIDogSU5WQUxJRDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlcG9jaCBtaWxsaXNlY29uZHMgb2YgdGhpcyBEYXRlVGltZS4gQWxpYXMgb2Yge0BsaW5rIERhdGVUaW1lI3RvTWlsbGlzfVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICB2YWx1ZU9mKCkge1xuICAgIHJldHVybiB0aGlzLnRvTWlsbGlzKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZXBvY2ggbWlsbGlzZWNvbmRzIG9mIHRoaXMgRGF0ZVRpbWUuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHRvTWlsbGlzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnRzIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVwb2NoIHNlY29uZHMgb2YgdGhpcyBEYXRlVGltZS5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgdG9TZWNvbmRzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnRzIC8gMTAwMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlcG9jaCBzZWNvbmRzIChhcyBhIHdob2xlIG51bWJlcikgb2YgdGhpcyBEYXRlVGltZS5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgdG9Vbml4SW50ZWdlcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gTWF0aC5mbG9vcih0aGlzLnRzIC8gMTAwMCkgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lIGFwcHJvcHJpYXRlIGZvciB1c2UgaW4gSlNPTi5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvSVNPKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIEJTT04gc2VyaWFsaXphYmxlIGVxdWl2YWxlbnQgdG8gdGhpcyBEYXRlVGltZS5cbiAgICogQHJldHVybiB7RGF0ZX1cbiAgICovXG4gIHRvQlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b0pTRGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBKYXZhU2NyaXB0IG9iamVjdCB3aXRoIHRoaXMgRGF0ZVRpbWUncyB5ZWFyLCBtb250aCwgZGF5LCBhbmQgc28gb24uXG4gICAqIEBwYXJhbSBvcHRzIC0gb3B0aW9ucyBmb3IgZ2VuZXJhdGluZyB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZUNvbmZpZz1mYWxzZV0gLSBpbmNsdWRlIGNvbmZpZ3VyYXRpb24gYXR0cmlidXRlcyBpbiB0aGUgb3V0cHV0XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvT2JqZWN0KCkgLy89PiB7IHllYXI6IDIwMTcsIG1vbnRoOiA0LCBkYXk6IDIyLCBob3VyOiAyMCwgbWludXRlOiA0OSwgc2Vjb25kOiA0MiwgbWlsbGlzZWNvbmQ6IDI2OCB9XG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHRvT2JqZWN0KG9wdHMgPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4ge307XG5cbiAgICBjb25zdCBiYXNlID0geyAuLi50aGlzLmMgfTtcblxuICAgIGlmIChvcHRzLmluY2x1ZGVDb25maWcpIHtcbiAgICAgIGJhc2Uub3V0cHV0Q2FsZW5kYXIgPSB0aGlzLm91dHB1dENhbGVuZGFyO1xuICAgICAgYmFzZS5udW1iZXJpbmdTeXN0ZW0gPSB0aGlzLmxvYy5udW1iZXJpbmdTeXN0ZW07XG4gICAgICBiYXNlLmxvY2FsZSA9IHRoaXMubG9jLmxvY2FsZTtcbiAgICB9XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIEphdmFTY3JpcHQgRGF0ZSBlcXVpdmFsZW50IHRvIHRoaXMgRGF0ZVRpbWUuXG4gICAqIEByZXR1cm4ge0RhdGV9XG4gICAqL1xuICB0b0pTRGF0ZSgpIHtcbiAgICByZXR1cm4gbmV3IERhdGUodGhpcy5pc1ZhbGlkID8gdGhpcy50cyA6IE5hTik7XG4gIH1cblxuICAvLyBDT01QQVJFXG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byBEYXRlVGltZXMgYXMgYSBEdXJhdGlvbi5cbiAgICogQHBhcmFtIHtEYXRlVGltZX0gb3RoZXJEYXRlVGltZSAtIHRoZSBEYXRlVGltZSB0byBjb21wYXJlIHRoaXMgb25lIHRvXG4gICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBbdW5pdD1bJ21pbGxpc2Vjb25kcyddXSAtIHRoZSB1bml0IG9yIGFycmF5IG9mIHVuaXRzIChzdWNoIGFzICdob3Vycycgb3IgJ2RheXMnKSB0byBpbmNsdWRlIGluIHRoZSBkdXJhdGlvbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRoYXQgYWZmZWN0IHRoZSBjcmVhdGlvbiBvZiB0aGUgRHVyYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmNvbnZlcnNpb25BY2N1cmFjeT0nY2FzdWFsJ10gLSB0aGUgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBpMSA9IERhdGVUaW1lLmZyb21JU08oJzE5ODItMDUtMjVUMDk6NDUnKSxcbiAgICogICAgIGkyID0gRGF0ZVRpbWUuZnJvbUlTTygnMTk4My0xMC0xNFQxMDozMCcpO1xuICAgKiBpMi5kaWZmKGkxKS50b09iamVjdCgpIC8vPT4geyBtaWxsaXNlY29uZHM6IDQzODA3NTAwMDAwIH1cbiAgICogaTIuZGlmZihpMSwgJ2hvdXJzJykudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDEyMTY4Ljc1IH1cbiAgICogaTIuZGlmZihpMSwgWydtb250aHMnLCAnZGF5cyddKS50b09iamVjdCgpIC8vPT4geyBtb250aHM6IDE2LCBkYXlzOiAxOS4wMzEyNSB9XG4gICAqIGkyLmRpZmYoaTEsIFsnbW9udGhzJywgJ2RheXMnLCAnaG91cnMnXSkudG9PYmplY3QoKSAvLz0+IHsgbW9udGhzOiAxNiwgZGF5czogMTksIGhvdXJzOiAwLjc1IH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBkaWZmKG90aGVyRGF0ZVRpbWUsIHVuaXQgPSBcIm1pbGxpc2Vjb25kc1wiLCBvcHRzID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCB8fCAhb3RoZXJEYXRlVGltZS5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gRHVyYXRpb24uaW52YWxpZChcImNyZWF0ZWQgYnkgZGlmZmluZyBhbiBpbnZhbGlkIERhdGVUaW1lXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGR1ck9wdHMgPSB7IGxvY2FsZTogdGhpcy5sb2NhbGUsIG51bWJlcmluZ1N5c3RlbTogdGhpcy5udW1iZXJpbmdTeXN0ZW0sIC4uLm9wdHMgfTtcblxuICAgIGNvbnN0IHVuaXRzID0gbWF5YmVBcnJheSh1bml0KS5tYXAoRHVyYXRpb24ubm9ybWFsaXplVW5pdCksXG4gICAgICBvdGhlcklzTGF0ZXIgPSBvdGhlckRhdGVUaW1lLnZhbHVlT2YoKSA+IHRoaXMudmFsdWVPZigpLFxuICAgICAgZWFybGllciA9IG90aGVySXNMYXRlciA/IHRoaXMgOiBvdGhlckRhdGVUaW1lLFxuICAgICAgbGF0ZXIgPSBvdGhlcklzTGF0ZXIgPyBvdGhlckRhdGVUaW1lIDogdGhpcyxcbiAgICAgIGRpZmZlZCA9IGRpZmYoZWFybGllciwgbGF0ZXIsIHVuaXRzLCBkdXJPcHRzKTtcblxuICAgIHJldHVybiBvdGhlcklzTGF0ZXIgPyBkaWZmZWQubmVnYXRlKCkgOiBkaWZmZWQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhpcyBEYXRlVGltZSBhbmQgcmlnaHQgbm93LlxuICAgKiBTZWUge0BsaW5rIERhdGVUaW1lI2RpZmZ9XG4gICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBbdW5pdD1bJ21pbGxpc2Vjb25kcyddXSAtIHRoZSB1bml0IG9yIHVuaXRzIHVuaXRzIChzdWNoIGFzICdob3Vycycgb3IgJ2RheXMnKSB0byBpbmNsdWRlIGluIHRoZSBkdXJhdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdGhhdCBhZmZlY3QgdGhlIGNyZWF0aW9uIG9mIHRoZSBEdXJhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29udmVyc2lvbkFjY3VyYWN5PSdjYXN1YWwnXSAtIHRoZSBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBkaWZmTm93KHVuaXQgPSBcIm1pbGxpc2Vjb25kc1wiLCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5kaWZmKERhdGVUaW1lLm5vdygpLCB1bml0LCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gSW50ZXJ2YWwgc3Bhbm5pbmcgYmV0d2VlbiB0aGlzIERhdGVUaW1lIGFuZCBhbm90aGVyIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IG90aGVyRGF0ZVRpbWUgLSB0aGUgb3RoZXIgZW5kIHBvaW50IG9mIHRoZSBJbnRlcnZhbFxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIHVudGlsKG90aGVyRGF0ZVRpbWUpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyh0aGlzLCBvdGhlckRhdGVUaW1lKSA6IHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBEYXRlVGltZSBpcyBpbiB0aGUgc2FtZSB1bml0IG9mIHRpbWUgYXMgYW5vdGhlciBEYXRlVGltZS5cbiAgICogSGlnaGVyLW9yZGVyIHVuaXRzIG11c3QgYWxzbyBiZSBpZGVudGljYWwgZm9yIHRoaXMgZnVuY3Rpb24gdG8gcmV0dXJuIGB0cnVlYC5cbiAgICogTm90ZSB0aGF0IHRpbWUgem9uZXMgYXJlICoqaWdub3JlZCoqIGluIHRoaXMgY29tcGFyaXNvbiwgd2hpY2ggY29tcGFyZXMgdGhlICoqbG9jYWwqKiBjYWxlbmRhciB0aW1lLiBVc2Uge0BsaW5rIERhdGVUaW1lI3NldFpvbmV9IHRvIGNvbnZlcnQgb25lIG9mIHRoZSBkYXRlcyBpZiBuZWVkZWQuXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IG90aGVyRGF0ZVRpbWUgLSB0aGUgb3RoZXIgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSB0aGUgdW5pdCBvZiB0aW1lIHRvIGNoZWNrIHNhbWVuZXNzIG9uXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLmhhc1NhbWUob3RoZXJEVCwgJ2RheScpOyAvL34+IHRydWUgaWYgb3RoZXJEVCBpcyBpbiB0aGUgc2FtZSBjdXJyZW50IGNhbGVuZGFyIGRheVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzU2FtZShvdGhlckRhdGVUaW1lLCB1bml0KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcblxuICAgIGNvbnN0IGlucHV0TXMgPSBvdGhlckRhdGVUaW1lLnZhbHVlT2YoKTtcbiAgICBjb25zdCBhZGp1c3RlZFRvWm9uZSA9IHRoaXMuc2V0Wm9uZShvdGhlckRhdGVUaW1lLnpvbmUsIHsga2VlcExvY2FsVGltZTogdHJ1ZSB9KTtcbiAgICByZXR1cm4gYWRqdXN0ZWRUb1pvbmUuc3RhcnRPZih1bml0KSA8PSBpbnB1dE1zICYmIGlucHV0TXMgPD0gYWRqdXN0ZWRUb1pvbmUuZW5kT2YodW5pdCk7XG4gIH1cblxuICAvKipcbiAgICogRXF1YWxpdHkgY2hlY2tcbiAgICogVHdvIERhdGVUaW1lcyBhcmUgZXF1YWwgaWYgYW5kIG9ubHkgaWYgdGhleSByZXByZXNlbnQgdGhlIHNhbWUgbWlsbGlzZWNvbmQsIGhhdmUgdGhlIHNhbWUgem9uZSBhbmQgbG9jYXRpb24sIGFuZCBhcmUgYm90aCB2YWxpZC5cbiAgICogVG8gY29tcGFyZSBqdXN0IHRoZSBtaWxsaXNlY29uZCB2YWx1ZXMsIHVzZSBgK2R0MSA9PT0gK2R0MmAuXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IG90aGVyIC0gdGhlIG90aGVyIERhdGVUaW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5pc1ZhbGlkICYmXG4gICAgICBvdGhlci5pc1ZhbGlkICYmXG4gICAgICB0aGlzLnZhbHVlT2YoKSA9PT0gb3RoZXIudmFsdWVPZigpICYmXG4gICAgICB0aGlzLnpvbmUuZXF1YWxzKG90aGVyLnpvbmUpICYmXG4gICAgICB0aGlzLmxvYy5lcXVhbHMob3RoZXIubG9jKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHRoaXMgdGltZSByZWxhdGl2ZSB0byBub3csIHN1Y2ggYXMgXCJpbiB0d28gZGF5c1wiLiBDYW4gb25seSBpbnRlcm5hdGlvbmFsaXplIGlmIHlvdXJcbiAgICogcGxhdGZvcm0gc3VwcG9ydHMgSW50bC5SZWxhdGl2ZVRpbWVGb3JtYXQuIFJvdW5kcyBkb3duIGJ5IGRlZmF1bHQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyB0aGF0IGFmZmVjdCB0aGUgb3V0cHV0XG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IFtvcHRpb25zLmJhc2U9RGF0ZVRpbWUubm93KCldIC0gdGhlIERhdGVUaW1lIHRvIHVzZSBhcyB0aGUgYmFzaXMgdG8gd2hpY2ggdGhpcyB0aW1lIGlzIGNvbXBhcmVkLiBEZWZhdWx0cyB0byBub3cuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zdHlsZT1cImxvbmdcIl0gLSB0aGUgc3R5bGUgb2YgdW5pdHMsIG11c3QgYmUgXCJsb25nXCIsIFwic2hvcnRcIiwgb3IgXCJuYXJyb3dcIlxuICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gb3B0aW9ucy51bml0IC0gdXNlIGEgc3BlY2lmaWMgdW5pdCBvciBhcnJheSBvZiB1bml0czsgaWYgb21pdHRlZCwgb3IgYW4gYXJyYXksIHRoZSBtZXRob2Qgd2lsbCBwaWNrIHRoZSBiZXN0IHVuaXQuIFVzZSBhbiBhcnJheSBvciBvbmUgb2YgXCJ5ZWFyc1wiLCBcInF1YXJ0ZXJzXCIsIFwibW9udGhzXCIsIFwid2Vla3NcIiwgXCJkYXlzXCIsIFwiaG91cnNcIiwgXCJtaW51dGVzXCIsIG9yIFwic2Vjb25kc1wiXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucm91bmQ9dHJ1ZV0gLSB3aGV0aGVyIHRvIHJvdW5kIHRoZSBudW1iZXJzIGluIHRoZSBvdXRwdXQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5wYWRkaW5nPTBdIC0gcGFkZGluZyBpbiBtaWxsaXNlY29uZHMuIFRoaXMgYWxsb3dzIHlvdSB0byByb3VuZCB1cCB0aGUgcmVzdWx0IGlmIGl0IGZpdHMgaW5zaWRlIHRoZSB0aHJlc2hvbGQuIERvbid0IHVzZSBpbiBjb21iaW5hdGlvbiB3aXRoIHtyb3VuZDogZmFsc2V9IGJlY2F1c2UgdGhlIGRlY2ltYWwgb3V0cHV0IHdpbGwgaW5jbHVkZSB0aGUgcGFkZGluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubG9jYWxlIC0gb3ZlcnJpZGUgdGhlIGxvY2FsZSBvZiB0aGlzIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm51bWJlcmluZ1N5c3RlbSAtIG92ZXJyaWRlIHRoZSBudW1iZXJpbmdTeXN0ZW0gb2YgdGhpcyBEYXRlVGltZS4gVGhlIEludGwgc3lzdGVtIG1heSBjaG9vc2Ugbm90IHRvIGhvbm9yIHRoaXNcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IGRheXM6IDEgfSkudG9SZWxhdGl2ZSgpIC8vPT4gXCJpbiAxIGRheVwiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnNldExvY2FsZShcImVzXCIpLnRvUmVsYXRpdmUoeyBkYXlzOiAxIH0pIC8vPT4gXCJkZW50cm8gZGUgMSBkw61hXCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IGRheXM6IDEgfSkudG9SZWxhdGl2ZSh7IGxvY2FsZTogXCJmclwiIH0pIC8vPT4gXCJkYW5zIDIzIGhldXJlc1wiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLm1pbnVzKHsgZGF5czogMiB9KS50b1JlbGF0aXZlKCkgLy89PiBcIjIgZGF5cyBhZ29cIlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5taW51cyh7IGRheXM6IDIgfSkudG9SZWxhdGl2ZSh7IHVuaXQ6IFwiaG91cnNcIiB9KSAvLz0+IFwiNDggaG91cnMgYWdvXCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkubWludXMoeyBob3VyczogMzYgfSkudG9SZWxhdGl2ZSh7IHJvdW5kOiBmYWxzZSB9KSAvLz0+IFwiMS41IGRheXMgYWdvXCJcbiAgICovXG4gIHRvUmVsYXRpdmUob3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGJhc2UgPSBvcHRpb25zLmJhc2UgfHwgRGF0ZVRpbWUuZnJvbU9iamVjdCh7fSwgeyB6b25lOiB0aGlzLnpvbmUgfSksXG4gICAgICBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nID8gKHRoaXMgPCBiYXNlID8gLW9wdGlvbnMucGFkZGluZyA6IG9wdGlvbnMucGFkZGluZykgOiAwO1xuICAgIGxldCB1bml0cyA9IFtcInllYXJzXCIsIFwibW9udGhzXCIsIFwiZGF5c1wiLCBcImhvdXJzXCIsIFwibWludXRlc1wiLCBcInNlY29uZHNcIl07XG4gICAgbGV0IHVuaXQgPSBvcHRpb25zLnVuaXQ7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy51bml0KSkge1xuICAgICAgdW5pdHMgPSBvcHRpb25zLnVuaXQ7XG4gICAgICB1bml0ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gZGlmZlJlbGF0aXZlKGJhc2UsIHRoaXMucGx1cyhwYWRkaW5nKSwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIG51bWVyaWM6IFwiYWx3YXlzXCIsXG4gICAgICB1bml0cyxcbiAgICAgIHVuaXQsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGRhdGUgcmVsYXRpdmUgdG8gdG9kYXksIHN1Y2ggYXMgXCJ5ZXN0ZXJkYXlcIiBvciBcIm5leHQgbW9udGhcIi5cbiAgICogT25seSBpbnRlcm5hdGlvbmFsaXplcyBvbiBwbGF0Zm9ybXMgdGhhdCBzdXBwb3J0cyBJbnRsLlJlbGF0aXZlVGltZUZvcm1hdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIHRoYXQgYWZmZWN0IHRoZSBvdXRwdXRcbiAgICogQHBhcmFtIHtEYXRlVGltZX0gW29wdGlvbnMuYmFzZT1EYXRlVGltZS5ub3coKV0gLSB0aGUgRGF0ZVRpbWUgdG8gdXNlIGFzIHRoZSBiYXNpcyB0byB3aGljaCB0aGlzIHRpbWUgaXMgY29tcGFyZWQuIERlZmF1bHRzIHRvIG5vdy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubG9jYWxlIC0gb3ZlcnJpZGUgdGhlIGxvY2FsZSBvZiB0aGlzIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnVuaXQgLSB1c2UgYSBzcGVjaWZpYyB1bml0OyBpZiBvbWl0dGVkLCB0aGUgbWV0aG9kIHdpbGwgcGljayB0aGUgdW5pdC4gVXNlIG9uZSBvZiBcInllYXJzXCIsIFwicXVhcnRlcnNcIiwgXCJtb250aHNcIiwgXCJ3ZWVrc1wiLCBvciBcImRheXNcIlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5udW1iZXJpbmdTeXN0ZW0gLSBvdmVycmlkZSB0aGUgbnVtYmVyaW5nU3lzdGVtIG9mIHRoaXMgRGF0ZVRpbWUuIFRoZSBJbnRsIHN5c3RlbSBtYXkgY2hvb3NlIG5vdCB0byBob25vciB0aGlzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBkYXlzOiAxIH0pLnRvUmVsYXRpdmVDYWxlbmRhcigpIC8vPT4gXCJ0b21vcnJvd1wiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnNldExvY2FsZShcImVzXCIpLnBsdXMoeyBkYXlzOiAxIH0pLnRvUmVsYXRpdmUoKSAvLz0+IFwiXCJtYcOxYW5hXCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IGRheXM6IDEgfSkudG9SZWxhdGl2ZUNhbGVuZGFyKHsgbG9jYWxlOiBcImZyXCIgfSkgLy89PiBcImRlbWFpblwiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLm1pbnVzKHsgZGF5czogMiB9KS50b1JlbGF0aXZlQ2FsZW5kYXIoKSAvLz0+IFwiMiBkYXlzIGFnb1wiXG4gICAqL1xuICB0b1JlbGF0aXZlQ2FsZW5kYXIob3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBudWxsO1xuXG4gICAgcmV0dXJuIGRpZmZSZWxhdGl2ZShvcHRpb25zLmJhc2UgfHwgRGF0ZVRpbWUuZnJvbU9iamVjdCh7fSwgeyB6b25lOiB0aGlzLnpvbmUgfSksIHRoaXMsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBudW1lcmljOiBcImF1dG9cIixcbiAgICAgIHVuaXRzOiBbXCJ5ZWFyc1wiLCBcIm1vbnRoc1wiLCBcImRheXNcIl0sXG4gICAgICBjYWxlbmRhcnk6IHRydWUsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBtaW4gb2Ygc2V2ZXJhbCBkYXRlIHRpbWVzXG4gICAqIEBwYXJhbSB7Li4uRGF0ZVRpbWV9IGRhdGVUaW1lcyAtIHRoZSBEYXRlVGltZXMgZnJvbSB3aGljaCB0byBjaG9vc2UgdGhlIG1pbmltdW1cbiAgICogQHJldHVybiB7RGF0ZVRpbWV9IHRoZSBtaW4gRGF0ZVRpbWUsIG9yIHVuZGVmaW5lZCBpZiBjYWxsZWQgd2l0aCBubyBhcmd1bWVudFxuICAgKi9cbiAgc3RhdGljIG1pbiguLi5kYXRlVGltZXMpIHtcbiAgICBpZiAoIWRhdGVUaW1lcy5ldmVyeShEYXRlVGltZS5pc0RhdGVUaW1lKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwibWluIHJlcXVpcmVzIGFsbCBhcmd1bWVudHMgYmUgRGF0ZVRpbWVzXCIpO1xuICAgIH1cbiAgICByZXR1cm4gYmVzdEJ5KGRhdGVUaW1lcywgKGkpID0+IGkudmFsdWVPZigpLCBNYXRoLm1pbik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBtYXggb2Ygc2V2ZXJhbCBkYXRlIHRpbWVzXG4gICAqIEBwYXJhbSB7Li4uRGF0ZVRpbWV9IGRhdGVUaW1lcyAtIHRoZSBEYXRlVGltZXMgZnJvbSB3aGljaCB0byBjaG9vc2UgdGhlIG1heGltdW1cbiAgICogQHJldHVybiB7RGF0ZVRpbWV9IHRoZSBtYXggRGF0ZVRpbWUsIG9yIHVuZGVmaW5lZCBpZiBjYWxsZWQgd2l0aCBubyBhcmd1bWVudFxuICAgKi9cbiAgc3RhdGljIG1heCguLi5kYXRlVGltZXMpIHtcbiAgICBpZiAoIWRhdGVUaW1lcy5ldmVyeShEYXRlVGltZS5pc0RhdGVUaW1lKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwibWF4IHJlcXVpcmVzIGFsbCBhcmd1bWVudHMgYmUgRGF0ZVRpbWVzXCIpO1xuICAgIH1cbiAgICByZXR1cm4gYmVzdEJ5KGRhdGVUaW1lcywgKGkpID0+IGkudmFsdWVPZigpLCBNYXRoLm1heCk7XG4gIH1cblxuICAvLyBNSVNDXG5cbiAgLyoqXG4gICAqIEV4cGxhaW4gaG93IGEgc3RyaW5nIHdvdWxkIGJlIHBhcnNlZCBieSBmcm9tRm9ybWF0KClcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0aGUgc3RyaW5nIHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmbXQgLSB0aGUgZm9ybWF0IHRoZSBzdHJpbmcgaXMgZXhwZWN0ZWQgdG8gYmUgaW4gKHNlZSBkZXNjcmlwdGlvbilcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIHRha2VuIGJ5IGZyb21Gb3JtYXQoKVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZnJvbUZvcm1hdEV4cGxhaW4odGV4dCwgZm10LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGxvY2FsZSA9IG51bGwsIG51bWJlcmluZ1N5c3RlbSA9IG51bGwgfSA9IG9wdGlvbnMsXG4gICAgICBsb2NhbGVUb1VzZSA9IExvY2FsZS5mcm9tT3B0cyh7XG4gICAgICAgIGxvY2FsZSxcbiAgICAgICAgbnVtYmVyaW5nU3lzdGVtLFxuICAgICAgICBkZWZhdWx0VG9FTjogdHJ1ZSxcbiAgICAgIH0pO1xuICAgIHJldHVybiBleHBsYWluRnJvbVRva2Vucyhsb2NhbGVUb1VzZSwgdGV4dCwgZm10KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgZnJvbUZvcm1hdEV4cGxhaW4gaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGZyb21TdHJpbmdFeHBsYWluKHRleHQsIGZtdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIERhdGVUaW1lLmZyb21Gb3JtYXRFeHBsYWluKHRleHQsIGZtdCwgb3B0aW9ucyk7XG4gIH1cblxuICAvLyBGT1JNQVQgUFJFU0VUU1xuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlIDEwLzE0LzE5ODNcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURV9TSE9SVCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFX1NIT1JUO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ09jdCAxNCwgMTk4MydcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURV9NRUQoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURV9NRUQ7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnRnJpLCBPY3QgMTQsIDE5ODMnXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVfTUVEX1dJVEhfV0VFS0RBWSgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFX01FRF9XSVRIX1dFRUtEQVk7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnT2N0b2JlciAxNCwgMTk4MydcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURV9GVUxMKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVfRlVMTDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdUdWVzZGF5LCBPY3RvYmVyIDE0LCAxOTgzJ1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFX0hVR0UoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURV9IVUdFO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFRJTUVfU0lNUExFKCkge1xuICAgIHJldHVybiBGb3JtYXRzLlRJTUVfU0lNUExFO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwOjIzIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFRJTUVfV0lUSF9TRUNPTkRTKCkge1xuICAgIHJldHVybiBGb3JtYXRzLlRJTUVfV0lUSF9TRUNPTkRTO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwOjIzIEFNIEVEVCcuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FX1dJVEhfU0hPUlRfT0ZGU0VUKCkge1xuICAgIHJldHVybiBGb3JtYXRzLlRJTUVfV0lUSF9TSE9SVF9PRkZTRVQ7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMDk6MzA6MjMgQU0gRWFzdGVybiBEYXlsaWdodCBUaW1lJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFRJTUVfV0lUSF9MT05HX09GRlNFVCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FX1dJVEhfTE9OR19PRkZTRVQ7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMDk6MzAnLCBhbHdheXMgMjQtaG91ci5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgVElNRV8yNF9TSU1QTEUoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuVElNRV8yNF9TSU1QTEU7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMDk6MzA6MjMnLCBhbHdheXMgMjQtaG91ci5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgVElNRV8yNF9XSVRIX1NFQ09ORFMoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuVElNRV8yNF9XSVRIX1NFQ09ORFM7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMDk6MzA6MjMgRURUJywgYWx3YXlzIDI0LWhvdXIuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFRJTUVfMjRfV0lUSF9TSE9SVF9PRkZTRVQoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuVElNRV8yNF9XSVRIX1NIT1JUX09GRlNFVDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMDoyMyBFYXN0ZXJuIERheWxpZ2h0IFRpbWUnLCBhbHdheXMgMjQtaG91ci5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgVElNRV8yNF9XSVRIX0xPTkdfT0ZGU0VUKCkge1xuICAgIHJldHVybiBGb3JtYXRzLlRJTUVfMjRfV0lUSF9MT05HX09GRlNFVDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcxMC8xNC8xOTgzLCA5OjMwIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX1NIT1JUKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVUSU1FX1NIT1JUO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzEwLzE0LzE5ODMsIDk6MzA6MzMgQU0nLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURVRJTUVfU0hPUlRfV0lUSF9TRUNPTkRTKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVUSU1FX1NIT1JUX1dJVEhfU0VDT05EUztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdPY3QgMTQsIDE5ODMsIDk6MzAgQU0nLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURVRJTUVfTUVEKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVUSU1FX01FRDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdPY3QgMTQsIDE5ODMsIDk6MzA6MzMgQU0nLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURVRJTUVfTUVEX1dJVEhfU0VDT05EUygpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9NRURfV0lUSF9TRUNPTkRTO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ0ZyaSwgMTQgT2N0IDE5ODMsIDk6MzAgQU0nLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURVRJTUVfTUVEX1dJVEhfV0VFS0RBWSgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9NRURfV0lUSF9XRUVLREFZO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ09jdG9iZXIgMTQsIDE5ODMsIDk6MzAgQU0gRURUJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX0ZVTEwoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfRlVMTDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdPY3RvYmVyIDE0LCAxOTgzLCA5OjMwOjMzIEFNIEVEVCcuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9GVUxMX1dJVEhfU0VDT05EUygpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9GVUxMX1dJVEhfU0VDT05EUztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdGcmlkYXksIE9jdG9iZXIgMTQsIDE5ODMsIDk6MzAgQU0gRWFzdGVybiBEYXlsaWdodCBUaW1lJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX0hVR0UoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfSFVHRTtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdGcmlkYXksIE9jdG9iZXIgMTQsIDE5ODMsIDk6MzA6MzMgQU0gRWFzdGVybiBEYXlsaWdodCBUaW1lJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX0hVR0VfV0lUSF9TRUNPTkRTKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVUSU1FX0hVR0VfV0lUSF9TRUNPTkRTO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyaWVuZGx5RGF0ZVRpbWUoZGF0ZVRpbWVpc2gpIHtcbiAgaWYgKERhdGVUaW1lLmlzRGF0ZVRpbWUoZGF0ZVRpbWVpc2gpKSB7XG4gICAgcmV0dXJuIGRhdGVUaW1laXNoO1xuICB9IGVsc2UgaWYgKGRhdGVUaW1laXNoICYmIGRhdGVUaW1laXNoLnZhbHVlT2YgJiYgaXNOdW1iZXIoZGF0ZVRpbWVpc2gudmFsdWVPZigpKSkge1xuICAgIHJldHVybiBEYXRlVGltZS5mcm9tSlNEYXRlKGRhdGVUaW1laXNoKTtcbiAgfSBlbHNlIGlmIChkYXRlVGltZWlzaCAmJiB0eXBlb2YgZGF0ZVRpbWVpc2ggPT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gRGF0ZVRpbWUuZnJvbU9iamVjdChkYXRlVGltZWlzaCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFxuICAgICAgYFVua25vd24gZGF0ZXRpbWUgYXJndW1lbnQ6ICR7ZGF0ZVRpbWVpc2h9LCBvZiB0eXBlICR7dHlwZW9mIGRhdGVUaW1laXNofWBcbiAgICApO1xuICB9XG59XG4iLCAiLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFF1ZXJ5IFNldHRpbmdzIC8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXJ5U2V0dGluZ3Mge1xuICAgIC8qKiBXaGF0IHRvIHJlbmRlciAnbnVsbCcgYXMgaW4gdGFibGVzLiBEZWZhdWx0cyB0byAnLScuICovXG4gICAgcmVuZGVyTnVsbEFzOiBzdHJpbmc7XG4gICAgLyoqIElmIGVuYWJsZWQsIHRhc2tzIGluIERhdGF2aWV3IHZpZXdzIHdpbGwgYXV0b21hdGljYWxseSBoYXZlIHRoZWlyIGNvbXBsZXRpb24gZGF0ZSBhcHBlbmRlZCB3aGVuIHRoZXkgYXJlIGNoZWNrZWQuICovXG4gICAgdGFza0NvbXBsZXRpb25UcmFja2luZzogYm9vbGVhbjtcbiAgICAvKiogSWYgZW5hYmxlZCwgYXV0b21hdGljIGNvbXBsZXRpb25zIHdpbGwgdXNlIGVtb2ppIHNob3J0aGFuZCDinIUgWVlZWS1NTS1ERCBpbnN0ZWFkIG9mIFtjb21wbGV0aW9uOjogZGF0ZV0uICovXG4gICAgdGFza0NvbXBsZXRpb25Vc2VFbW9qaVNob3J0aGFuZDogYm9vbGVhbjtcbiAgICAvKiogVGhlIG5hbWUgb2YgdGhlIGlubGluZSBmaWVsZCB0byBiZSBhZGRlZCBhcyBhIHRhc2sncyBjb21wbGV0aW9uIHdoZW4gY2hlY2tlZC4gT25seSB1c2VkIGlmIGNvbXBsZXRpb25UcmFja2luZyBpcyBlbmFibGVkIGFuZCBlbW9qaVNob3J0aGFuZCBpcyBub3QuICovXG4gICAgdGFza0NvbXBsZXRpb25UZXh0OiBzdHJpbmc7XG4gICAgLyoqIERhdGUgZm9ybWF0IG9mIHRoZSB0YXNrJ3MgY29tcGxldGlvbiB0aW1lc3RhbXAuIE9ubHkgdXNlZCBpZiBjb21wbGV0aW9uVHJhY2tpbmcgaXMgZW5hYmxlZCBhbmQgZW1vamlTaG9ydGhhbmQgaXMgbm90LiAqL1xuICAgIHRhc2tDb21wbGV0aW9uRGF0ZUZvcm1hdDogc3RyaW5nO1xuICAgIC8qKiBXaGV0aGVyIG9yIG5vdCBzdWJ0YXNrcyBzaG91bGQgYmUgcmVjdXJzaXZlbHkgY29tcGxldGVkIGluIGFkZGl0aW9uIHRvIHRoZWlyIHBhcmVudCB0YXNrLiAqL1xuICAgIHJlY3Vyc2l2ZVN1YlRhc2tDb21wbGV0aW9uOiBib29sZWFuO1xuICAgIC8qKiBJZiB0cnVlLCByZW5kZXIgYSBtb2RhbCB3aGljaCBzaG93cyBubyByZXN1bHRzIHdlcmUgcmV0dXJuZWQuICovXG4gICAgd2Fybk9uRW1wdHlSZXN1bHQ6IGJvb2xlYW47XG4gICAgLyoqIFdoZXRoZXIgb3Igbm90IGF1dG9tYXRpYyB2aWV3IHJlZnJlc2hpbmcgaXMgZW5hYmxlZC4gKi9cbiAgICByZWZyZXNoRW5hYmxlZDogYm9vbGVhbjtcbiAgICAvKiogVGhlIGludGVydmFsIHRoYXQgdmlld3MgYXJlIHJlZnJlc2hlZCwgYnkgZGVmYXVsdC4gKi9cbiAgICByZWZyZXNoSW50ZXJ2YWw6IG51bWJlcjtcbiAgICAvKiogVGhlIGRlZmF1bHQgZm9ybWF0IHRoYXQgZGF0ZXMgYXJlIHJlbmRlcmVkIGluICh1c2luZyBsdXhvbidzIG1vbWVudC1saWtlIGZvcm1hdHRpbmcpLiAqL1xuICAgIGRlZmF1bHREYXRlRm9ybWF0OiBzdHJpbmc7XG4gICAgLyoqIFRoZSBkZWZhdWx0IGZvcm1hdCB0aGF0IGRhdGUtdGltZXMgYXJlIHJlbmRlcmVkIGluICh1c2luZyBsdXhvbnMgbW9tZW50LWxpa2UgZm9ybWF0dGluZykuICovXG4gICAgZGVmYXVsdERhdGVUaW1lRm9ybWF0OiBzdHJpbmc7XG4gICAgLyoqIE1heGltdW0gZGVwdGggdGhhdCBvYmplY3RzIHdpbGwgYmUgZXhwYW5kZWQgd2hlbiBiZWluZyByZW5kZXJlZCByZWN1cnNpdmVseS4gKi9cbiAgICBtYXhSZWN1cnNpdmVSZW5kZXJEZXB0aDogbnVtYmVyO1xuICAgIC8qKiBUaGUgbmFtZSBvZiB0aGUgZGVmYXVsdCBJRCBmaWVsZCAoJ0ZpbGUnKS4gKi9cbiAgICB0YWJsZUlkQ29sdW1uTmFtZTogc3RyaW5nO1xuICAgIC8qKiBUaGUgbmFtZSBvZiBkZWZhdWx0IElEIGZpZWxkcyBvbiBncm91cGVkIGRhdGEgKCdHcm91cCcpLiAqL1xuICAgIHRhYmxlR3JvdXBDb2x1bW5OYW1lOiBzdHJpbmc7XG4gICAgLyoqIEluY2x1ZGUgdGhlIHJlc3VsdCBjb3VudCBhcyBwYXJ0IG9mIHRoZSBvdXRwdXQuICovXG4gICAgc2hvd1Jlc3VsdENvdW50OiBib29sZWFuO1xufVxuXG5leHBvcnQgY29uc3QgREVGQVVMVF9RVUVSWV9TRVRUSU5HUzogUXVlcnlTZXR0aW5ncyA9IHtcbiAgICByZW5kZXJOdWxsQXM6IFwiXFxcXC1cIixcbiAgICB0YXNrQ29tcGxldGlvblRyYWNraW5nOiBmYWxzZSxcbiAgICB0YXNrQ29tcGxldGlvblVzZUVtb2ppU2hvcnRoYW5kOiBmYWxzZSxcbiAgICB0YXNrQ29tcGxldGlvblRleHQ6IFwiY29tcGxldGlvblwiLFxuICAgIHRhc2tDb21wbGV0aW9uRGF0ZUZvcm1hdDogXCJ5eXl5LU1NLWRkXCIsXG4gICAgcmVjdXJzaXZlU3ViVGFza0NvbXBsZXRpb246IGZhbHNlLFxuICAgIHdhcm5PbkVtcHR5UmVzdWx0OiB0cnVlLFxuICAgIHJlZnJlc2hFbmFibGVkOiB0cnVlLFxuICAgIHJlZnJlc2hJbnRlcnZhbDogMjUwMCxcbiAgICBkZWZhdWx0RGF0ZUZvcm1hdDogXCJNTU1NIGRkLCB5eXl5XCIsXG4gICAgZGVmYXVsdERhdGVUaW1lRm9ybWF0OiBcImg6bW0gYSAtIE1NTU0gZGQsIHl5eXlcIixcbiAgICBtYXhSZWN1cnNpdmVSZW5kZXJEZXB0aDogNCxcblxuICAgIHRhYmxlSWRDb2x1bW5OYW1lOiBcIkZpbGVcIixcbiAgICB0YWJsZUdyb3VwQ29sdW1uTmFtZTogXCJHcm91cFwiLFxuICAgIHNob3dSZXN1bHRDb3VudDogdHJ1ZSxcbn07XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gRXhwb3J0IFNldHRpbmdzIC8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZXhwb3J0IGludGVyZmFjZSBFeHBvcnRTZXR0aW5ncyB7XG4gICAgLyoqIFdoZXRoZXIgb3Igbm90IEhUTUwgc2hvdWxkIGJlIHVzZWQgZm9yIGZvcm1hdHRpbmcgaW4gZXhwb3J0cy4gKi9cbiAgICBhbGxvd0h0bWw6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX0VYUE9SVF9TRVRUSU5HUzogRXhwb3J0U2V0dGluZ3MgPSB7XG4gICAgYWxsb3dIdG1sOiB0cnVlLFxufTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gR2VuZXJhbCBEYXRhdmlldyBTZXR0aW5ncyAvL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5leHBvcnQgaW50ZXJmYWNlIERhdGF2aWV3U2V0dGluZ3MgZXh0ZW5kcyBRdWVyeVNldHRpbmdzLCBFeHBvcnRTZXR0aW5ncyB7XG4gICAgLyoqIFRoZSBwcmVmaXggZm9yIGlubGluZSBxdWVyaWVzIGJ5IGRlZmF1bHQuICovXG4gICAgaW5saW5lUXVlcnlQcmVmaXg6IHN0cmluZztcbiAgICAvKiogVGhlIHByZWZpeCBmb3IgaW5saW5lIEpTIHF1ZXJpZXMgYnkgZGVmYXVsdC4gKi9cbiAgICBpbmxpbmVKc1F1ZXJ5UHJlZml4OiBzdHJpbmc7XG4gICAgLyoqIElmIHRydWUsIGlubGluZSBxdWVyaWVzIGFyZSBhbHNvIGV2YWx1YXRlZCBpbiBmdWxsIGNvZGVibG9ja3MuICovXG4gICAgaW5saW5lUXVlcmllc0luQ29kZWJsb2NrczogYm9vbGVhbjtcbiAgICAvKiogRW5hYmxlIG9yIGRpc2FibGUgZXhlY3V0aW5nIERhdGF2aWV3SlMgcXVlcmllcy4gKi9cbiAgICBlbmFibGVEYXRhdmlld0pzOiBib29sZWFuO1xuICAgIC8qKiBFbmFibGUgb3IgZGlzYWJsZSByZWd1bGFyIGlubGluZSBxdWVyaWVzLiAqL1xuICAgIGVuYWJsZUlubGluZURhdGF2aWV3OiBib29sZWFuO1xuICAgIC8qKiBFbmFibGUgb3IgZGlzYWJsZSBleGVjdXRpbmcgaW5saW5lIERhdGF2aWV3SlMgcXVlcmllcy4gKi9cbiAgICBlbmFibGVJbmxpbmVEYXRhdmlld0pzOiBib29sZWFuO1xuICAgIC8qKiBFbmFibGUgb3IgZGlzYWJsZSByZW5kZXJpbmcgaW5saW5lIGZpZWxkcyBwcmV0dGlseSBpbiBSZWFkaW5nIFZpZXcuICovXG4gICAgcHJldHR5UmVuZGVySW5saW5lRmllbGRzOiBib29sZWFuO1xuICAgIC8qKiBFbmFibGUgb3IgZGlzYWJsZSByZW5kZXJpbmcgaW5saW5lIGZpZWxkcyBwcmV0dGlseSBpbiBMaXZlIFByZXZpZXcuICovXG4gICAgcHJldHR5UmVuZGVySW5saW5lRmllbGRzSW5MaXZlUHJldmlldzogYm9vbGVhbjtcbiAgICAvKiogVGhlIGtleXdvcmQgZm9yIERhdGF2aWV3SlMgYmxvY2tzLiAqL1xuICAgIGRhdGF2aWV3SnNLZXl3b3JkOiBzdHJpbmc7XG59XG5cbi8qKiBEZWZhdWx0IHNldHRpbmdzIGZvciBkYXRhdmlldyBvbiBpbnN0YWxsLiAqL1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfU0VUVElOR1M6IERhdGF2aWV3U2V0dGluZ3MgPSB7XG4gICAgLi4uREVGQVVMVF9RVUVSWV9TRVRUSU5HUyxcbiAgICAuLi5ERUZBVUxUX0VYUE9SVF9TRVRUSU5HUyxcbiAgICAuLi57XG4gICAgICAgIGlubGluZVF1ZXJ5UHJlZml4OiBcIj1cIixcbiAgICAgICAgaW5saW5lSnNRdWVyeVByZWZpeDogXCIkPVwiLFxuICAgICAgICBpbmxpbmVRdWVyaWVzSW5Db2RlYmxvY2tzOiB0cnVlLFxuICAgICAgICBlbmFibGVJbmxpbmVEYXRhdmlldzogdHJ1ZSxcbiAgICAgICAgZW5hYmxlRGF0YXZpZXdKczogZmFsc2UsXG4gICAgICAgIGVuYWJsZUlubGluZURhdGF2aWV3SnM6IGZhbHNlLFxuICAgICAgICBwcmV0dHlSZW5kZXJJbmxpbmVGaWVsZHM6IHRydWUsXG4gICAgICAgIHByZXR0eVJlbmRlcklubGluZUZpZWxkc0luTGl2ZVByZXZpZXc6IHRydWUsXG4gICAgICAgIGRhdGF2aWV3SnNLZXl3b3JkOiBcImRhdGF2aWV3anNcIixcbiAgICB9LFxufTtcbiIsICIvKiogRnVuY3Rpb25hbCByZXR1cm4gdHlwZSBmb3IgZXJyb3IgaGFuZGxpbmcuICovXG5leHBvcnQgY2xhc3MgU3VjY2VzczxULCBFPiB7XG4gICAgcHVibGljIHN1Y2Nlc3NmdWw6IHRydWU7XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IocHVibGljIHZhbHVlOiBUKSB7XG4gICAgICAgIHRoaXMuc3VjY2Vzc2Z1bCA9IHRydWU7XG4gICAgfVxuXG4gICAgcHVibGljIG1hcDxVPihmOiAoYTogVCkgPT4gVSk6IFJlc3VsdDxVLCBFPiB7XG4gICAgICAgIHJldHVybiBuZXcgU3VjY2VzcyhmKHRoaXMudmFsdWUpKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZmxhdE1hcDxVPihmOiAoYTogVCkgPT4gUmVzdWx0PFUsIEU+KTogUmVzdWx0PFUsIEU+IHtcbiAgICAgICAgcmV0dXJuIGYodGhpcy52YWx1ZSk7XG4gICAgfVxuXG4gICAgcHVibGljIG1hcEVycjxVPihmOiAoZTogRSkgPT4gVSk6IFJlc3VsdDxULCBVPiB7XG4gICAgICAgIHJldHVybiB0aGlzIGFzIGFueSBhcyBSZXN1bHQ8VCwgVT47XG4gICAgfVxuXG4gICAgcHVibGljIGJpbWFwPFQyLCBFMj4oc3VjYzogKGE6IFQpID0+IFQyLCBfZmFpbDogKGI6IEUpID0+IEUyKTogUmVzdWx0PFQyLCBFMj4ge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAoc3VjYykgYXMgYW55O1xuICAgIH1cblxuICAgIHB1YmxpYyBvckVsc2UoX3ZhbHVlOiBUKTogVCB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cblxuICAgIHB1YmxpYyBjYXN0PFU+KCk6IFJlc3VsdDxVLCBFPiB7XG4gICAgICAgIHJldHVybiB0aGlzIGFzIGFueTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb3JFbHNlVGhyb3coX21lc3NhZ2U/OiAoZTogRSkgPT4gc3RyaW5nKTogVCB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbn1cblxuLyoqIEZ1bmN0aW9uYWwgcmV0dXJuIHR5cGUgZm9yIGVycm9yIGhhbmRsaW5nLiAqL1xuZXhwb3J0IGNsYXNzIEZhaWx1cmU8VCwgRT4ge1xuICAgIHB1YmxpYyBzdWNjZXNzZnVsOiBmYWxzZTtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihwdWJsaWMgZXJyb3I6IEUpIHtcbiAgICAgICAgdGhpcy5zdWNjZXNzZnVsID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcHVibGljIG1hcDxVPihfZjogKGE6IFQpID0+IFUpOiBSZXN1bHQ8VSwgRT4ge1xuICAgICAgICByZXR1cm4gdGhpcyBhcyBhbnkgYXMgRmFpbHVyZTxVLCBFPjtcbiAgICB9XG5cbiAgICBwdWJsaWMgZmxhdE1hcDxVPihfZjogKGE6IFQpID0+IFJlc3VsdDxVLCBFPik6IFJlc3VsdDxVLCBFPiB7XG4gICAgICAgIHJldHVybiB0aGlzIGFzIGFueSBhcyBGYWlsdXJlPFUsIEU+O1xuICAgIH1cblxuICAgIHB1YmxpYyBtYXBFcnI8VT4oZjogKGU6IEUpID0+IFUpOiBSZXN1bHQ8VCwgVT4ge1xuICAgICAgICByZXR1cm4gbmV3IEZhaWx1cmUoZih0aGlzLmVycm9yKSk7XG4gICAgfVxuXG4gICAgcHVibGljIGJpbWFwPFQyLCBFMj4oX3N1Y2M6IChhOiBUKSA9PiBUMiwgZmFpbDogKGI6IEUpID0+IEUyKTogUmVzdWx0PFQyLCBFMj4ge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXBFcnIoZmFpbCkgYXMgYW55O1xuICAgIH1cblxuICAgIHB1YmxpYyBvckVsc2UodmFsdWU6IFQpOiBUIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHB1YmxpYyBjYXN0PFU+KCk6IFJlc3VsdDxVLCBFPiB7XG4gICAgICAgIHJldHVybiB0aGlzIGFzIGFueTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb3JFbHNlVGhyb3cobWVzc2FnZT86IChlOiBFKSA9PiBzdHJpbmcpOiBUIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKHRoaXMuZXJyb3IpKTtcbiAgICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJcIiArIHRoaXMuZXJyb3IpO1xuICAgIH1cbn1cblxuZXhwb3J0IHR5cGUgUmVzdWx0PFQsIEU+ID0gU3VjY2VzczxULCBFPiB8IEZhaWx1cmU8VCwgRT47XG5cbi8qKiBNb25hZGljICdSZXN1bHQnIHR5cGUgd2hpY2ggZW5jYXBzdWxhdGVzIHdoZXRoZXIgYSBwcm9jZWR1cmUgc3VjY2VlZGVkIG9yIGZhaWxlZCwgYXMgd2VsbCBhcyBpdCdzIHJldHVybiB2YWx1ZS4gKi9cbmV4cG9ydCBuYW1lc3BhY2UgUmVzdWx0IHtcbiAgICAvKiogQ29uc3RydWN0IGEgbmV3IHN1Y2Nlc3MgcmVzdWx0IHdyYXBwaW5nIHRoZSBnaXZlbiB2YWx1ZS4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gc3VjY2VzczxULCBFPih2YWx1ZTogVCk6IFJlc3VsdDxULCBFPiB7XG4gICAgICAgIHJldHVybiBuZXcgU3VjY2Vzcyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqIENvbnN0cnVjdCBhIG5ldyBmYWlsdXJlIHZhbHVlIHdyYXBwaW5nIHRoZSBnaXZlbiBlcnJvci4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gZmFpbHVyZTxULCBFPihlcnJvcjogRSk6IFJlc3VsdDxULCBFPiB7XG4gICAgICAgIHJldHVybiBuZXcgRmFpbHVyZShlcnJvcik7XG4gICAgfVxuXG4gICAgLyoqIEpvaW4gdHdvIHJlc3VsdHMgd2l0aCBhIGJpLWZ1bmN0aW9uIGFuZCByZXR1cm4gYSBuZXcgcmVzdWx0LiAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiBmbGF0TWFwMjxUMSwgVDIsIE8sIEU+KFxuICAgICAgICBmaXJzdDogUmVzdWx0PFQxLCBFPixcbiAgICAgICAgc2Vjb25kOiBSZXN1bHQ8VDIsIEU+LFxuICAgICAgICBmOiAoYTogVDEsIGI6IFQyKSA9PiBSZXN1bHQ8TywgRT5cbiAgICApOiBSZXN1bHQ8TywgRT4ge1xuICAgICAgICBpZiAoZmlyc3Quc3VjY2Vzc2Z1bCkge1xuICAgICAgICAgICAgaWYgKHNlY29uZC5zdWNjZXNzZnVsKSByZXR1cm4gZihmaXJzdC52YWx1ZSwgc2Vjb25kLnZhbHVlKTtcbiAgICAgICAgICAgIGVsc2UgcmV0dXJuIGZhaWx1cmUoc2Vjb25kLmVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWlsdXJlKGZpcnN0LmVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBKb2luIHR3byByZXN1bHRzIHdpdGggYSBiaS1mdW5jdGlvbiBhbmQgcmV0dXJuIGEgbmV3IHJlc3VsdC4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gbWFwMjxUMSwgVDIsIE8sIEU+KFxuICAgICAgICBmaXJzdDogUmVzdWx0PFQxLCBFPixcbiAgICAgICAgc2Vjb25kOiBSZXN1bHQ8VDIsIEU+LFxuICAgICAgICBmOiAoYTogVDEsIGI6IFQyKSA9PiBPXG4gICAgKTogUmVzdWx0PE8sIEU+IHtcbiAgICAgICAgcmV0dXJuIGZsYXRNYXAyKGZpcnN0LCBzZWNvbmQsIChhLCBiKSA9PiBzdWNjZXNzKGYoYSwgYikpKTtcbiAgICB9XG59XG4iLCAiIWZ1bmN0aW9uKG4sdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9dCgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW10sdCk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0cy5QYXJzaW1tb249dCgpOm4uUGFyc2ltbW9uPXQoKX0oXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjp0aGlzLGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKG4pe3ZhciB0PXt9O2Z1bmN0aW9uIHIoZSl7aWYodFtlXSlyZXR1cm4gdFtlXS5leHBvcnRzO3ZhciB1PXRbZV09e2k6ZSxsOiExLGV4cG9ydHM6e319O3JldHVybiBuW2VdLmNhbGwodS5leHBvcnRzLHUsdS5leHBvcnRzLHIpLHUubD0hMCx1LmV4cG9ydHN9cmV0dXJuIHIubT1uLHIuYz10LHIuZD1mdW5jdGlvbihuLHQsZSl7ci5vKG4sdCl8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLHQse2NvbmZpZ3VyYWJsZTohMSxlbnVtZXJhYmxlOiEwLGdldDplfSl9LHIucj1mdW5jdGlvbihuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0sci5uPWZ1bmN0aW9uKG4pe3ZhciB0PW4mJm4uX19lc01vZHVsZT9mdW5jdGlvbigpe3JldHVybiBuLmRlZmF1bHR9OmZ1bmN0aW9uKCl7cmV0dXJuIG59O3JldHVybiByLmQodCxcImFcIix0KSx0fSxyLm89ZnVuY3Rpb24obix0KXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sdCl9LHIucD1cIlwiLHIoci5zPTApfShbZnVuY3Rpb24obix0LHIpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGUobil7aWYoISh0aGlzIGluc3RhbmNlb2YgZSkpcmV0dXJuIG5ldyBlKG4pO3RoaXMuXz1ufXZhciB1PWUucHJvdG90eXBlO2Z1bmN0aW9uIG8obix0KXtmb3IodmFyIHI9MDtyPG47cisrKXQocil9ZnVuY3Rpb24gaShuLHQscil7cmV0dXJuIGZ1bmN0aW9uKG4sdCl7byh0Lmxlbmd0aCxmdW5jdGlvbihyKXtuKHRbcl0scix0KX0pfShmdW5jdGlvbihyLGUsdSl7dD1uKHQscixlLHUpfSxyKSx0fWZ1bmN0aW9uIGEobix0KXtyZXR1cm4gaShmdW5jdGlvbih0LHIsZSx1KXtyZXR1cm4gdC5jb25jYXQoW24ocixlLHUpXSl9LFtdLHQpfWZ1bmN0aW9uIGYobix0KXt2YXIgcj17djowLGJ1Zjp0fTtyZXR1cm4gbyhuLGZ1bmN0aW9uKCl7dmFyIG47cj17djpyLnY8PDF8KG49ci5idWYsblswXT4+NyksYnVmOmZ1bmN0aW9uKG4pe3ZhciB0PWkoZnVuY3Rpb24obix0LHIsZSl7cmV0dXJuIG4uY29uY2F0KHI9PT1lLmxlbmd0aC0xP0J1ZmZlci5mcm9tKFt0LDBdKS5yZWFkVUludDE2QkUoMCk6ZS5yZWFkVUludDE2QkUocikpfSxbXSxuKTtyZXR1cm4gQnVmZmVyLmZyb20oYShmdW5jdGlvbihuKXtyZXR1cm4objw8MSY2NTUzNSk+Pjh9LHQpKX0oci5idWYpfX0pLHJ9ZnVuY3Rpb24gYygpe3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBCdWZmZXJ9ZnVuY3Rpb24gcygpe2lmKCFjKCkpdGhyb3cgbmV3IEVycm9yKFwiQnVmZmVyIGdsb2JhbCBkb2VzIG5vdCBleGlzdDsgcGxlYXNlIHVzZSB3ZWJwYWNrIGlmIHlvdSBuZWVkIHRvIHBhcnNlIEJ1ZmZlcnMgaW4gdGhlIGJyb3dzZXIuXCIpfWZ1bmN0aW9uIGwobil7cygpO3ZhciB0PWkoZnVuY3Rpb24obix0KXtyZXR1cm4gbit0fSwwLG4pO2lmKHQlOCE9MCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYml0cyBbXCIrbi5qb2luKFwiLCBcIikrXCJdIGFkZCB1cCB0byBcIit0K1wiIHdoaWNoIGlzIG5vdCBhbiBldmVuIG51bWJlciBvZiBieXRlczsgdGhlIHRvdGFsIHNob3VsZCBiZSBkaXZpc2libGUgYnkgOFwiKTt2YXIgcix1PXQvOCxvPShyPWZ1bmN0aW9uKG4pe3JldHVybiBuPjQ4fSxpKGZ1bmN0aW9uKG4sdCl7cmV0dXJuIG58fChyKHQpP3Q6bil9LG51bGwsbikpO2lmKG8pdGhyb3cgbmV3IEVycm9yKG8rXCIgYml0IHJhbmdlIHJlcXVlc3RlZCBleGNlZWRzIDQ4IGJpdCAoNiBieXRlKSBOdW1iZXIgbWF4LlwiKTtyZXR1cm4gbmV3IGUoZnVuY3Rpb24odCxyKXt2YXIgZT11K3I7cmV0dXJuIGU+dC5sZW5ndGg/eChyLHUudG9TdHJpbmcoKStcIiBieXRlc1wiKTpiKGUsaShmdW5jdGlvbihuLHQpe3ZhciByPWYodCxuLmJ1Zik7cmV0dXJue2NvbGw6bi5jb2xsLmNvbmNhdChyLnYpLGJ1ZjpyLmJ1Zn19LHtjb2xsOltdLGJ1Zjp0LnNsaWNlKHIsZSl9LG4pLmNvbGwpfSl9ZnVuY3Rpb24gaChuLHQpe3JldHVybiBuZXcgZShmdW5jdGlvbihyLGUpe3JldHVybiBzKCksZSt0PnIubGVuZ3RoP3goZSx0K1wiIGJ5dGVzIGZvciBcIituKTpiKGUrdCxyLnNsaWNlKGUsZSt0KSl9KX1mdW5jdGlvbiBwKG4sdCl7aWYoXCJudW1iZXJcIiE9dHlwZW9mKHI9dCl8fE1hdGguZmxvb3IocikhPT1yfHx0PDB8fHQ+Nil0aHJvdyBuZXcgRXJyb3IobitcIiByZXF1aXJlcyBpbnRlZ2VyIGxlbmd0aCBpbiByYW5nZSBbMCwgNl0uXCIpO3ZhciByfWZ1bmN0aW9uIGQobil7cmV0dXJuIHAoXCJ1aW50QkVcIixuKSxoKFwidWludEJFKFwiK24rXCIpXCIsbikubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnJlYWRVSW50QkUoMCxuKX0pfWZ1bmN0aW9uIHYobil7cmV0dXJuIHAoXCJ1aW50TEVcIixuKSxoKFwidWludExFKFwiK24rXCIpXCIsbikubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnJlYWRVSW50TEUoMCxuKX0pfWZ1bmN0aW9uIGcobil7cmV0dXJuIHAoXCJpbnRCRVwiLG4pLGgoXCJpbnRCRShcIituK1wiKVwiLG4pLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC5yZWFkSW50QkUoMCxuKX0pfWZ1bmN0aW9uIG0obil7cmV0dXJuIHAoXCJpbnRMRVwiLG4pLGgoXCJpbnRMRShcIituK1wiKVwiLG4pLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC5yZWFkSW50TEUoMCxuKX0pfWZ1bmN0aW9uIHkobil7cmV0dXJuIG4gaW5zdGFuY2VvZiBlfWZ1bmN0aW9uIEUobil7cmV0dXJuXCJbb2JqZWN0IEFycmF5XVwiPT09e30udG9TdHJpbmcuY2FsbChuKX1mdW5jdGlvbiB3KG4pe3JldHVybiBjKCkmJkJ1ZmZlci5pc0J1ZmZlcihuKX1mdW5jdGlvbiBiKG4sdCl7cmV0dXJue3N0YXR1czohMCxpbmRleDpuLHZhbHVlOnQsZnVydGhlc3Q6LTEsZXhwZWN0ZWQ6W119fWZ1bmN0aW9uIHgobix0KXtyZXR1cm4gRSh0KXx8KHQ9W3RdKSx7c3RhdHVzOiExLGluZGV4Oi0xLHZhbHVlOm51bGwsZnVydGhlc3Q6bixleHBlY3RlZDp0fX1mdW5jdGlvbiBCKG4sdCl7aWYoIXQpcmV0dXJuIG47aWYobi5mdXJ0aGVzdD50LmZ1cnRoZXN0KXJldHVybiBuO3ZhciByPW4uZnVydGhlc3Q9PT10LmZ1cnRoZXN0P2Z1bmN0aW9uKG4sdCl7aWYoZnVuY3Rpb24oKXtpZih2b2lkIDAhPT1lLl9zdXBwb3J0c1NldClyZXR1cm4gZS5fc3VwcG9ydHNTZXQ7dmFyIG49XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFNldDtyZXR1cm4gZS5fc3VwcG9ydHNTZXQ9bixufSgpJiZBcnJheS5mcm9tKXtmb3IodmFyIHI9bmV3IFNldChuKSx1PTA7dTx0Lmxlbmd0aDt1Kyspci5hZGQodFt1XSk7dmFyIG89QXJyYXkuZnJvbShyKTtyZXR1cm4gby5zb3J0KCksb31mb3IodmFyIGk9e30sYT0wO2E8bi5sZW5ndGg7YSsrKWlbblthXV09ITA7Zm9yKHZhciBmPTA7Zjx0Lmxlbmd0aDtmKyspaVt0W2ZdXT0hMDt2YXIgYz1bXTtmb3IodmFyIHMgaW4gaSkoe30pLmhhc093blByb3BlcnR5LmNhbGwoaSxzKSYmYy5wdXNoKHMpO3JldHVybiBjLnNvcnQoKSxjfShuLmV4cGVjdGVkLHQuZXhwZWN0ZWQpOnQuZXhwZWN0ZWQ7cmV0dXJue3N0YXR1czpuLnN0YXR1cyxpbmRleDpuLmluZGV4LHZhbHVlOm4udmFsdWUsZnVydGhlc3Q6dC5mdXJ0aGVzdCxleHBlY3RlZDpyfX12YXIgaj17fTtmdW5jdGlvbiBTKG4sdCl7aWYodyhuKSlyZXR1cm57b2Zmc2V0OnQsbGluZTotMSxjb2x1bW46LTF9O24gaW4ganx8KGpbbl09e30pO2Zvcih2YXIgcj1qW25dLGU9MCx1PTAsbz0wLGk9dDtpPj0wOyl7aWYoaSBpbiByKXtlPXJbaV0ubGluZSwwPT09byYmKG89cltpXS5saW5lU3RhcnQpO2JyZWFrfShcIlxcblwiPT09bi5jaGFyQXQoaSl8fFwiXFxyXCI9PT1uLmNoYXJBdChpKSYmXCJcXG5cIiE9PW4uY2hhckF0KGkrMSkpJiYodSsrLDA9PT1vJiYobz1pKzEpKSxpLS19dmFyIGE9ZSt1LGY9dC1vO3JldHVybiByW3RdPXtsaW5lOmEsbGluZVN0YXJ0Om99LHtvZmZzZXQ6dCxsaW5lOmErMSxjb2x1bW46ZisxfX1mdW5jdGlvbiBfKG4pe2lmKCF5KG4pKXRocm93IG5ldyBFcnJvcihcIm5vdCBhIHBhcnNlcjogXCIrbil9ZnVuY3Rpb24gTChuLHQpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBuP24uY2hhckF0KHQpOm5bdF19ZnVuY3Rpb24gTyhuKXtpZihcIm51bWJlclwiIT10eXBlb2Ygbil0aHJvdyBuZXcgRXJyb3IoXCJub3QgYSBudW1iZXI6IFwiK24pfWZ1bmN0aW9uIGsobil7aWYoXCJmdW5jdGlvblwiIT10eXBlb2Ygbil0aHJvdyBuZXcgRXJyb3IoXCJub3QgYSBmdW5jdGlvbjogXCIrbil9ZnVuY3Rpb24gUChuKXtpZihcInN0cmluZ1wiIT10eXBlb2Ygbil0aHJvdyBuZXcgRXJyb3IoXCJub3QgYSBzdHJpbmc6IFwiK24pfXZhciBxPTIsQT0zLEk9OCxGPTUqSSxNPTQqSSx6PVwiICBcIjtmdW5jdGlvbiBSKG4sdCl7cmV0dXJuIG5ldyBBcnJheSh0KzEpLmpvaW4obil9ZnVuY3Rpb24gVShuLHQscil7dmFyIGU9dC1uLmxlbmd0aDtyZXR1cm4gZTw9MD9uOlIocixlKStufWZ1bmN0aW9uIFcobix0LHIsZSl7cmV0dXJue2Zyb206bi10PjA/bi10OjAsdG86bityPmU/ZTpuK3J9fWZ1bmN0aW9uIEQobix0KXt2YXIgcixlLHUsbyxmLGM9dC5pbmRleCxzPWMub2Zmc2V0LGw9MTtpZihzPT09bi5sZW5ndGgpcmV0dXJuXCJHb3QgdGhlIGVuZCBvZiB0aGUgaW5wdXRcIjtpZih3KG4pKXt2YXIgaD1zLXMlSSxwPXMtaCxkPVcoaCxGLE0rSSxuLmxlbmd0aCksdj1hKGZ1bmN0aW9uKG4pe3JldHVybiBhKGZ1bmN0aW9uKG4pe3JldHVybiBVKG4udG9TdHJpbmcoMTYpLDIsXCIwXCIpfSxuKX0sZnVuY3Rpb24obix0KXt2YXIgcj1uLmxlbmd0aCxlPVtdLHU9MDtpZihyPD10KXJldHVybltuLnNsaWNlKCldO2Zvcih2YXIgbz0wO288cjtvKyspZVt1XXx8ZS5wdXNoKFtdKSxlW3VdLnB1c2gobltvXSksKG8rMSkldD09MCYmdSsrO3JldHVybiBlfShuLnNsaWNlKGQuZnJvbSxkLnRvKS50b0pTT04oKS5kYXRhLEkpKTtvPWZ1bmN0aW9uKG4pe3JldHVybiAwPT09bi5mcm9tJiYxPT09bi50bz97ZnJvbTpuLmZyb20sdG86bi50b306e2Zyb206bi5mcm9tL0ksdG86TWF0aC5mbG9vcihuLnRvL0kpfX0oZCksZT1oL0kscj0zKnAscD49NCYmKHIrPTEpLGw9Mix1PWEoZnVuY3Rpb24obil7cmV0dXJuIG4ubGVuZ3RoPD00P24uam9pbihcIiBcIik6bi5zbGljZSgwLDQpLmpvaW4oXCIgXCIpK1wiICBcIituLnNsaWNlKDQpLmpvaW4oXCIgXCIpfSx2KSwoZj0oOCooby50bz4wP28udG8tMTpvLnRvKSkudG9TdHJpbmcoMTYpLmxlbmd0aCk8MiYmKGY9Mil9ZWxzZXt2YXIgZz1uLnNwbGl0KC9cXHJcXG58W1xcblxcclxcdTIwMjhcXHUyMDI5XS8pO3I9Yy5jb2x1bW4tMSxlPWMubGluZS0xLG89VyhlLHEsQSxnLmxlbmd0aCksdT1nLnNsaWNlKG8uZnJvbSxvLnRvKSxmPW8udG8udG9TdHJpbmcoKS5sZW5ndGh9dmFyIG09ZS1vLmZyb207cmV0dXJuIHcobikmJihmPSg4KihvLnRvPjA/by50by0xOm8udG8pKS50b1N0cmluZygxNikubGVuZ3RoKTwyJiYoZj0yKSxpKGZ1bmN0aW9uKHQsZSx1KXt2YXIgaSxhPXU9PT1tLGM9YT9cIj4gXCI6ejtyZXR1cm4gaT13KG4pP1UoKDgqKG8uZnJvbSt1KSkudG9TdHJpbmcoMTYpLGYsXCIwXCIpOlUoKG8uZnJvbSt1KzEpLnRvU3RyaW5nKCksZixcIiBcIiksW10uY29uY2F0KHQsW2MraStcIiB8IFwiK2VdLGE/W3orUihcIiBcIixmKStcIiB8IFwiK1UoXCJcIixyLFwiIFwiKStSKFwiXlwiLGwpXTpbXSl9LFtdLHUpLmpvaW4oXCJcXG5cIil9ZnVuY3Rpb24gTihuLHQpe3JldHVybltcIlxcblwiLFwiLS0gUEFSU0lORyBGQUlMRUQgXCIrUihcIi1cIiw1MCksXCJcXG5cXG5cIixEKG4sdCksXCJcXG5cXG5cIiwocj10LmV4cGVjdGVkLDE9PT1yLmxlbmd0aD9cIkV4cGVjdGVkOlxcblxcblwiK3JbMF06XCJFeHBlY3RlZCBvbmUgb2YgdGhlIGZvbGxvd2luZzogXFxuXFxuXCIrci5qb2luKFwiLCBcIikpLFwiXFxuXCJdLmpvaW4oXCJcIik7dmFyIHJ9ZnVuY3Rpb24gRyhuKXtyZXR1cm4gdm9pZCAwIT09bi5mbGFncz9uLmZsYWdzOltuLmdsb2JhbD9cImdcIjpcIlwiLG4uaWdub3JlQ2FzZT9cImlcIjpcIlwiLG4ubXVsdGlsaW5lP1wibVwiOlwiXCIsbi51bmljb2RlP1widVwiOlwiXCIsbi5zdGlja3k/XCJ5XCI6XCJcIl0uam9pbihcIlwiKX1mdW5jdGlvbiBDKCl7Zm9yKHZhciBuPVtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSx0PW4ubGVuZ3RoLHI9MDtyPHQ7cis9MSlfKG5bcl0pO3JldHVybiBlKGZ1bmN0aW9uKHIsZSl7Zm9yKHZhciB1LG89bmV3IEFycmF5KHQpLGk9MDtpPHQ7aSs9MSl7aWYoISh1PUIobltpXS5fKHIsZSksdSkpLnN0YXR1cylyZXR1cm4gdTtvW2ldPXUudmFsdWUsZT11LmluZGV4fXJldHVybiBCKGIoZSxvKSx1KX0pfWZ1bmN0aW9uIEooKXt2YXIgbj1bXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7aWYoMD09PW4ubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInNlcU1hcCBuZWVkcyBhdCBsZWFzdCBvbmUgYXJndW1lbnRcIik7dmFyIHQ9bi5wb3AoKTtyZXR1cm4gayh0KSxDLmFwcGx5KG51bGwsbikubWFwKGZ1bmN0aW9uKG4pe3JldHVybiB0LmFwcGx5KG51bGwsbil9KX1mdW5jdGlvbiBUKCl7dmFyIG49W10uc2xpY2UuY2FsbChhcmd1bWVudHMpLHQ9bi5sZW5ndGg7aWYoMD09PXQpcmV0dXJuIFkoXCJ6ZXJvIGFsdGVybmF0ZXNcIik7Zm9yKHZhciByPTA7cjx0O3IrPTEpXyhuW3JdKTtyZXR1cm4gZShmdW5jdGlvbih0LHIpe2Zvcih2YXIgZSx1PTA7dTxuLmxlbmd0aDt1Kz0xKWlmKChlPUIoblt1XS5fKHQsciksZSkpLnN0YXR1cylyZXR1cm4gZTtyZXR1cm4gZX0pfWZ1bmN0aW9uIFYobix0KXtyZXR1cm4gSChuLHQpLm9yKFgoW10pKX1mdW5jdGlvbiBIKG4sdCl7cmV0dXJuIF8obiksXyh0KSxKKG4sdC50aGVuKG4pLm1hbnkoKSxmdW5jdGlvbihuLHQpe3JldHVybltuXS5jb25jYXQodCl9KX1mdW5jdGlvbiBLKG4pe1Aobik7dmFyIHQ9XCInXCIrbitcIidcIjtyZXR1cm4gZShmdW5jdGlvbihyLGUpe3ZhciB1PWUrbi5sZW5ndGgsbz1yLnNsaWNlKGUsdSk7cmV0dXJuIG89PT1uP2IodSxvKTp4KGUsdCl9KX1mdW5jdGlvbiBRKG4sdCl7IWZ1bmN0aW9uKG4pe2lmKCEobiBpbnN0YW5jZW9mIFJlZ0V4cCkpdGhyb3cgbmV3IEVycm9yKFwibm90IGEgcmVnZXhwOiBcIituKTtmb3IodmFyIHQ9RyhuKSxyPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBlPXQuY2hhckF0KHIpO2lmKFwiaVwiIT09ZSYmXCJtXCIhPT1lJiZcInVcIiE9PWUmJlwic1wiIT09ZSl0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkIHJlZ2V4cCBmbGFnIFwiJytlKydcIjogJytuKX19KG4pLGFyZ3VtZW50cy5sZW5ndGg+PTI/Tyh0KTp0PTA7dmFyIHI9ZnVuY3Rpb24obil7cmV0dXJuIFJlZ0V4cChcIl4oPzpcIituLnNvdXJjZStcIilcIixHKG4pKX0obiksdT1cIlwiK247cmV0dXJuIGUoZnVuY3Rpb24obixlKXt2YXIgbz1yLmV4ZWMobi5zbGljZShlKSk7aWYobyl7aWYoMDw9dCYmdDw9by5sZW5ndGgpe3ZhciBpPW9bMF0sYT1vW3RdO3JldHVybiBiKGUraS5sZW5ndGgsYSl9cmV0dXJuIHgoZSxcInZhbGlkIG1hdGNoIGdyb3VwICgwIHRvIFwiK28ubGVuZ3RoK1wiKSBpbiBcIit1KX1yZXR1cm4geChlLHUpfSl9ZnVuY3Rpb24gWChuKXtyZXR1cm4gZShmdW5jdGlvbih0LHIpe3JldHVybiBiKHIsbil9KX1mdW5jdGlvbiBZKG4pe3JldHVybiBlKGZ1bmN0aW9uKHQscil7cmV0dXJuIHgocixuKX0pfWZ1bmN0aW9uIFoobil7aWYoeShuKSlyZXR1cm4gZShmdW5jdGlvbih0LHIpe3ZhciBlPW4uXyh0LHIpO3JldHVybiBlLmluZGV4PXIsZS52YWx1ZT1cIlwiLGV9KTtpZihcInN0cmluZ1wiPT10eXBlb2YgbilyZXR1cm4gWihLKG4pKTtpZihuIGluc3RhbmNlb2YgUmVnRXhwKXJldHVybiBaKFEobikpO3Rocm93IG5ldyBFcnJvcihcIm5vdCBhIHN0cmluZywgcmVnZXhwLCBvciBwYXJzZXI6IFwiK24pfWZ1bmN0aW9uICQobil7cmV0dXJuIF8obiksZShmdW5jdGlvbih0LHIpe3ZhciBlPW4uXyh0LHIpLHU9dC5zbGljZShyLGUuaW5kZXgpO3JldHVybiBlLnN0YXR1cz94KHIsJ25vdCBcIicrdSsnXCInKTpiKHIsbnVsbCl9KX1mdW5jdGlvbiBubihuKXtyZXR1cm4gayhuKSxlKGZ1bmN0aW9uKHQscil7dmFyIGU9TCh0LHIpO3JldHVybiByPHQubGVuZ3RoJiZuKGUpP2IocisxLGUpOngocixcImEgY2hhcmFjdGVyL2J5dGUgbWF0Y2hpbmcgXCIrbil9KX1mdW5jdGlvbiB0bihuLHQpe2FyZ3VtZW50cy5sZW5ndGg8MiYmKHQ9bixuPXZvaWQgMCk7dmFyIHI9ZShmdW5jdGlvbihuLGUpe3JldHVybiByLl89dCgpLl8sci5fKG4sZSl9KTtyZXR1cm4gbj9yLmRlc2Mobik6cn1mdW5jdGlvbiBybigpe3JldHVybiBZKFwiZmFudGFzeS1sYW5kL2VtcHR5XCIpfXUucGFyc2U9ZnVuY3Rpb24obil7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIG4mJiF3KG4pKXRocm93IG5ldyBFcnJvcihcIi5wYXJzZSBtdXN0IGJlIGNhbGxlZCB3aXRoIGEgc3RyaW5nIG9yIEJ1ZmZlciBhcyBpdHMgYXJndW1lbnRcIik7dmFyIHQscj10aGlzLnNraXAoYW4pLl8obiwwKTtyZXR1cm4gdD1yLnN0YXR1cz97c3RhdHVzOiEwLHZhbHVlOnIudmFsdWV9OntzdGF0dXM6ITEsaW5kZXg6UyhuLHIuZnVydGhlc3QpLGV4cGVjdGVkOnIuZXhwZWN0ZWR9LGRlbGV0ZSBqW25dLHR9LHUudHJ5UGFyc2U9ZnVuY3Rpb24obil7dmFyIHQ9dGhpcy5wYXJzZShuKTtpZih0LnN0YXR1cylyZXR1cm4gdC52YWx1ZTt2YXIgcj1OKG4sdCksZT1uZXcgRXJyb3Iocik7dGhyb3cgZS50eXBlPVwiUGFyc2ltbW9uRXJyb3JcIixlLnJlc3VsdD10LGV9LHUuYXNzZXJ0PWZ1bmN0aW9uKG4sdCl7cmV0dXJuIHRoaXMuY2hhaW4oZnVuY3Rpb24ocil7cmV0dXJuIG4ocik/WChyKTpZKHQpfSl9LHUub3I9ZnVuY3Rpb24obil7cmV0dXJuIFQodGhpcyxuKX0sdS50cmltPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLndyYXAobixuKX0sdS53cmFwPWZ1bmN0aW9uKG4sdCl7cmV0dXJuIEoobix0aGlzLHQsZnVuY3Rpb24obix0KXtyZXR1cm4gdH0pfSx1LnRocnU9ZnVuY3Rpb24obil7cmV0dXJuIG4odGhpcyl9LHUudGhlbj1mdW5jdGlvbihuKXtyZXR1cm4gXyhuKSxDKHRoaXMsbikubWFwKGZ1bmN0aW9uKG4pe3JldHVybiBuWzFdfSl9LHUubWFueT1mdW5jdGlvbigpe3ZhciBuPXRoaXM7cmV0dXJuIGUoZnVuY3Rpb24odCxyKXtmb3IodmFyIGU9W10sdT12b2lkIDA7Oyl7aWYoISh1PUIobi5fKHQsciksdSkpLnN0YXR1cylyZXR1cm4gQihiKHIsZSksdSk7aWYocj09PXUuaW5kZXgpdGhyb3cgbmV3IEVycm9yKFwiaW5maW5pdGUgbG9vcCBkZXRlY3RlZCBpbiAubWFueSgpIHBhcnNlciAtLS0gY2FsbGluZyAubWFueSgpIG9uIGEgcGFyc2VyIHdoaWNoIGNhbiBhY2NlcHQgemVybyBjaGFyYWN0ZXJzIGlzIHVzdWFsbHkgdGhlIGNhdXNlXCIpO3I9dS5pbmRleCxlLnB1c2godS52YWx1ZSl9fSl9LHUudGllV2l0aD1mdW5jdGlvbihuKXtyZXR1cm4gUChuKSx0aGlzLm1hcChmdW5jdGlvbih0KXtpZihmdW5jdGlvbihuKXtpZighRShuKSl0aHJvdyBuZXcgRXJyb3IoXCJub3QgYW4gYXJyYXk6IFwiK24pfSh0KSx0Lmxlbmd0aCl7UCh0WzBdKTtmb3IodmFyIHI9dFswXSxlPTE7ZTx0Lmxlbmd0aDtlKyspUCh0W2VdKSxyKz1uK3RbZV07cmV0dXJuIHJ9cmV0dXJuXCJcIn0pfSx1LnRpZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRpZVdpdGgoXCJcIil9LHUudGltZXM9ZnVuY3Rpb24obix0KXt2YXIgcj10aGlzO3JldHVybiBhcmd1bWVudHMubGVuZ3RoPDImJih0PW4pLE8obiksTyh0KSxlKGZ1bmN0aW9uKGUsdSl7Zm9yKHZhciBvPVtdLGk9dm9pZCAwLGE9dm9pZCAwLGY9MDtmPG47Zis9MSl7aWYoYT1CKGk9ci5fKGUsdSksYSksIWkuc3RhdHVzKXJldHVybiBhO3U9aS5pbmRleCxvLnB1c2goaS52YWx1ZSl9Zm9yKDtmPHQmJihhPUIoaT1yLl8oZSx1KSxhKSxpLnN0YXR1cyk7Zis9MSl1PWkuaW5kZXgsby5wdXNoKGkudmFsdWUpO3JldHVybiBCKGIodSxvKSxhKX0pfSx1LnJlc3VsdD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oKXtyZXR1cm4gbn0pfSx1LmF0TW9zdD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy50aW1lcygwLG4pfSx1LmF0TGVhc3Q9ZnVuY3Rpb24obil7cmV0dXJuIEoodGhpcy50aW1lcyhuKSx0aGlzLm1hbnkoKSxmdW5jdGlvbihuLHQpe3JldHVybiBuLmNvbmNhdCh0KX0pfSx1Lm1hcD1mdW5jdGlvbihuKXtrKG4pO3ZhciB0PXRoaXM7cmV0dXJuIGUoZnVuY3Rpb24ocixlKXt2YXIgdT10Ll8ocixlKTtyZXR1cm4gdS5zdGF0dXM/QihiKHUuaW5kZXgsbih1LnZhbHVlKSksdSk6dX0pfSx1LmNvbnRyYW1hcD1mdW5jdGlvbihuKXtrKG4pO3ZhciB0PXRoaXM7cmV0dXJuIGUoZnVuY3Rpb24ocixlKXt2YXIgdT10LnBhcnNlKG4oci5zbGljZShlKSkpO3JldHVybiB1LnN0YXR1cz9iKGUrci5sZW5ndGgsdS52YWx1ZSk6dX0pfSx1LnByb21hcD1mdW5jdGlvbihuLHQpe3JldHVybiBrKG4pLGsodCksdGhpcy5jb250cmFtYXAobikubWFwKHQpfSx1LnNraXA9ZnVuY3Rpb24obil7cmV0dXJuIEModGhpcyxuKS5tYXAoZnVuY3Rpb24obil7cmV0dXJuIG5bMF19KX0sdS5tYXJrPWZ1bmN0aW9uKCl7cmV0dXJuIEooZW4sdGhpcyxlbixmdW5jdGlvbihuLHQscil7cmV0dXJue3N0YXJ0Om4sdmFsdWU6dCxlbmQ6cn19KX0sdS5ub2RlPWZ1bmN0aW9uKG4pe3JldHVybiBKKGVuLHRoaXMsZW4sZnVuY3Rpb24odCxyLGUpe3JldHVybntuYW1lOm4sdmFsdWU6cixzdGFydDp0LGVuZDplfX0pfSx1LnNlcEJ5PWZ1bmN0aW9uKG4pe3JldHVybiBWKHRoaXMsbil9LHUuc2VwQnkxPWZ1bmN0aW9uKG4pe3JldHVybiBIKHRoaXMsbil9LHUubG9va2FoZWFkPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLnNraXAoWihuKSl9LHUubm90Rm9sbG93ZWRCeT1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5za2lwKCQobikpfSx1LmRlc2M9ZnVuY3Rpb24obil7RShuKXx8KG49W25dKTt2YXIgdD10aGlzO3JldHVybiBlKGZ1bmN0aW9uKHIsZSl7dmFyIHU9dC5fKHIsZSk7cmV0dXJuIHUuc3RhdHVzfHwodS5leHBlY3RlZD1uKSx1fSl9LHUuZmFsbGJhY2s9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMub3IoWChuKSl9LHUuYXA9ZnVuY3Rpb24obil7cmV0dXJuIEoobix0aGlzLGZ1bmN0aW9uKG4sdCl7cmV0dXJuIG4odCl9KX0sdS5jaGFpbj1mdW5jdGlvbihuKXt2YXIgdD10aGlzO3JldHVybiBlKGZ1bmN0aW9uKHIsZSl7dmFyIHU9dC5fKHIsZSk7cmV0dXJuIHUuc3RhdHVzP0Iobih1LnZhbHVlKS5fKHIsdS5pbmRleCksdSk6dX0pfSx1LmNvbmNhdD11Lm9yLHUuZW1wdHk9cm4sdS5vZj1YLHVbXCJmYW50YXN5LWxhbmQvYXBcIl09dS5hcCx1W1wiZmFudGFzeS1sYW5kL2NoYWluXCJdPXUuY2hhaW4sdVtcImZhbnRhc3ktbGFuZC9jb25jYXRcIl09dS5jb25jYXQsdVtcImZhbnRhc3ktbGFuZC9lbXB0eVwiXT11LmVtcHR5LHVbXCJmYW50YXN5LWxhbmQvb2ZcIl09dS5vZix1W1wiZmFudGFzeS1sYW5kL21hcFwiXT11Lm1hcDt2YXIgZW49ZShmdW5jdGlvbihuLHQpe3JldHVybiBiKHQsUyhuLHQpKX0pLHVuPWUoZnVuY3Rpb24obix0KXtyZXR1cm4gdD49bi5sZW5ndGg/eCh0LFwiYW55IGNoYXJhY3Rlci9ieXRlXCIpOmIodCsxLEwobix0KSl9KSxvbj1lKGZ1bmN0aW9uKG4sdCl7cmV0dXJuIGIobi5sZW5ndGgsbi5zbGljZSh0KSl9KSxhbj1lKGZ1bmN0aW9uKG4sdCl7cmV0dXJuIHQ8bi5sZW5ndGg/eCh0LFwiRU9GXCIpOmIodCxudWxsKX0pLGZuPVEoL1swLTldLykuZGVzYyhcImEgZGlnaXRcIiksY249USgvWzAtOV0qLykuZGVzYyhcIm9wdGlvbmFsIGRpZ2l0c1wiKSxzbj1RKC9bYS16XS9pKS5kZXNjKFwiYSBsZXR0ZXJcIiksbG49USgvW2Etel0qL2kpLmRlc2MoXCJvcHRpb25hbCBsZXR0ZXJzXCIpLGhuPVEoL1xccyovKS5kZXNjKFwib3B0aW9uYWwgd2hpdGVzcGFjZVwiKSxwbj1RKC9cXHMrLykuZGVzYyhcIndoaXRlc3BhY2VcIiksZG49SyhcIlxcclwiKSx2bj1LKFwiXFxuXCIpLGduPUsoXCJcXHJcXG5cIiksbW49VChnbix2bixkbikuZGVzYyhcIm5ld2xpbmVcIikseW49VChtbixhbik7ZS5hbGw9b24sZS5hbHQ9VCxlLmFueT11bixlLmNyPWRuLGUuY3JlYXRlTGFuZ3VhZ2U9ZnVuY3Rpb24obil7dmFyIHQ9e307Zm9yKHZhciByIGluIG4pKHt9KS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4scikmJmZ1bmN0aW9uKHIpe3Rbcl09dG4oZnVuY3Rpb24oKXtyZXR1cm4gbltyXSh0KX0pfShyKTtyZXR1cm4gdH0sZS5jcmxmPWduLGUuY3VzdG9tPWZ1bmN0aW9uKG4pe3JldHVybiBlKG4oYix4KSl9LGUuZGlnaXQ9Zm4sZS5kaWdpdHM9Y24sZS5lbXB0eT1ybixlLmVuZD15bixlLmVvZj1hbixlLmZhaWw9WSxlLmZvcm1hdEVycm9yPU4sZS5pbmRleD1lbixlLmlzUGFyc2VyPXksZS5sYXp5PXRuLGUubGV0dGVyPXNuLGUubGV0dGVycz1sbixlLmxmPXZuLGUubG9va2FoZWFkPVosZS5tYWtlRmFpbHVyZT14LGUubWFrZVN1Y2Nlc3M9YixlLm5ld2xpbmU9bW4sZS5ub25lT2Y9ZnVuY3Rpb24obil7cmV0dXJuIG5uKGZ1bmN0aW9uKHQpe3JldHVybiBuLmluZGV4T2YodCk8MH0pLmRlc2MoXCJub25lIG9mICdcIituK1wiJ1wiKX0sZS5ub3RGb2xsb3dlZEJ5PSQsZS5vZj1YLGUub25lT2Y9ZnVuY3Rpb24obil7Zm9yKHZhciB0PW4uc3BsaXQoXCJcIikscj0wO3I8dC5sZW5ndGg7cisrKXRbcl09XCInXCIrdFtyXStcIidcIjtyZXR1cm4gbm4oZnVuY3Rpb24odCl7cmV0dXJuIG4uaW5kZXhPZih0KT49MH0pLmRlc2ModCl9LGUub3B0V2hpdGVzcGFjZT1obixlLlBhcnNlcj1lLGUucmFuZ2U9ZnVuY3Rpb24obix0KXtyZXR1cm4gbm4oZnVuY3Rpb24ocil7cmV0dXJuIG48PXImJnI8PXR9KS5kZXNjKG4rXCItXCIrdCl9LGUucmVnZXg9USxlLnJlZ2V4cD1RLGUuc2VwQnk9VixlLnNlcEJ5MT1ILGUuc2VxPUMsZS5zZXFNYXA9SixlLnNlcU9iaj1mdW5jdGlvbigpe2Zvcih2YXIgbix0PXt9LHI9MCx1PShuPWFyZ3VtZW50cyxBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChuKSksbz11Lmxlbmd0aCxpPTA7aTxvO2krPTEpe3ZhciBhPXVbaV07aWYoIXkoYSkpe2lmKEUoYSkmJjI9PT1hLmxlbmd0aCYmXCJzdHJpbmdcIj09dHlwZW9mIGFbMF0mJnkoYVsxXSkpe3ZhciBmPWFbMF07aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsZikpdGhyb3cgbmV3IEVycm9yKFwic2VxT2JqOiBkdXBsaWNhdGUga2V5IFwiK2YpO3RbZl09ITAscisrO2NvbnRpbnVlfXRocm93IG5ldyBFcnJvcihcInNlcU9iaiBhcmd1bWVudHMgbXVzdCBiZSBwYXJzZXJzIG9yIFtzdHJpbmcsIHBhcnNlcl0gYXJyYXkgcGFpcnMuXCIpfX1pZigwPT09cil0aHJvdyBuZXcgRXJyb3IoXCJzZXFPYmogZXhwZWN0cyBhdCBsZWFzdCBvbmUgbmFtZWQgcGFyc2VyLCBmb3VuZCB6ZXJvXCIpO3JldHVybiBlKGZ1bmN0aW9uKG4sdCl7Zm9yKHZhciByLGU9e30saT0wO2k8bztpKz0xKXt2YXIgYSxmO2lmKEUodVtpXSk/KGE9dVtpXVswXSxmPXVbaV1bMV0pOihhPW51bGwsZj11W2ldKSwhKHI9QihmLl8obix0KSxyKSkuc3RhdHVzKXJldHVybiByO2EmJihlW2FdPXIudmFsdWUpLHQ9ci5pbmRleH1yZXR1cm4gQihiKHQsZSkscil9KX0sZS5zdHJpbmc9SyxlLnN1Y2NlZWQ9WCxlLnRha2VXaGlsZT1mdW5jdGlvbihuKXtyZXR1cm4gayhuKSxlKGZ1bmN0aW9uKHQscil7Zm9yKHZhciBlPXI7ZTx0Lmxlbmd0aCYmbihMKHQsZSkpOyllKys7cmV0dXJuIGIoZSx0LnNsaWNlKHIsZSkpfSl9LGUudGVzdD1ubixlLndoaXRlc3BhY2U9cG4sZVtcImZhbnRhc3ktbGFuZC9lbXB0eVwiXT1ybixlW1wiZmFudGFzeS1sYW5kL29mXCJdPVgsZS5CaW5hcnk9e2JpdFNlcTpsLGJpdFNlcU9iajpmdW5jdGlvbihuKXtzKCk7dmFyIHQ9e30scj0wLGU9YShmdW5jdGlvbihuKXtpZihFKG4pKXt2YXIgZT1uO2lmKDIhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJbXCIrZS5qb2luKFwiLCBcIikrXCJdIHNob3VsZCBiZSBsZW5ndGggMiwgZ290IGxlbmd0aCBcIitlLmxlbmd0aCk7aWYoUChlWzBdKSxPKGVbMV0pLE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LGVbMF0pKXRocm93IG5ldyBFcnJvcihcImR1cGxpY2F0ZSBrZXkgaW4gYml0U2VxT2JqOiBcIitlWzBdKTtyZXR1cm4gdFtlWzBdXT0hMCxyKyssZX1yZXR1cm4gTyhuKSxbbnVsbCxuXX0sbik7aWYocjwxKXRocm93IG5ldyBFcnJvcihcImJpdFNlcU9iaiBleHBlY3RzIGF0IGxlYXN0IG9uZSBuYW1lZCBwYWlyLCBnb3QgW1wiK24uam9pbihcIiwgXCIpK1wiXVwiKTt2YXIgdT1hKGZ1bmN0aW9uKG4pe3JldHVybiBuWzBdfSxlKTtyZXR1cm4gbChhKGZ1bmN0aW9uKG4pe3JldHVybiBuWzFdfSxlKSkubWFwKGZ1bmN0aW9uKG4pe3JldHVybiBpKGZ1bmN0aW9uKG4sdCl7cmV0dXJuIG51bGwhPT10WzBdJiYoblt0WzBdXT10WzFdKSxufSx7fSxhKGZ1bmN0aW9uKHQscil7cmV0dXJuW3QsbltyXV19LHUpKX0pfSxieXRlOmZ1bmN0aW9uKG4pe2lmKHMoKSxPKG4pLG4+MjU1KXRocm93IG5ldyBFcnJvcihcIlZhbHVlIHNwZWNpZmllZCB0byBieXRlIGNvbnN0cnVjdG9yIChcIituK1wiPTB4XCIrbi50b1N0cmluZygxNikrXCIpIGlzIGxhcmdlciBpbiB2YWx1ZSB0aGFuIGEgc2luZ2xlIGJ5dGUuXCIpO3ZhciB0PShuPjE1P1wiMHhcIjpcIjB4MFwiKStuLnRvU3RyaW5nKDE2KTtyZXR1cm4gZShmdW5jdGlvbihyLGUpe3ZhciB1PUwocixlKTtyZXR1cm4gdT09PW4/YihlKzEsdSk6eChlLHQpfSl9LGJ1ZmZlcjpmdW5jdGlvbihuKXtyZXR1cm4gaChcImJ1ZmZlclwiLG4pLm1hcChmdW5jdGlvbihuKXtyZXR1cm4gQnVmZmVyLmZyb20obil9KX0sZW5jb2RlZFN0cmluZzpmdW5jdGlvbihuLHQpe3JldHVybiBoKFwic3RyaW5nXCIsdCkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnRvU3RyaW5nKG4pfSl9LHVpbnRCRTpkLHVpbnQ4QkU6ZCgxKSx1aW50MTZCRTpkKDIpLHVpbnQzMkJFOmQoNCksdWludExFOnYsdWludDhMRTp2KDEpLHVpbnQxNkxFOnYoMiksdWludDMyTEU6dig0KSxpbnRCRTpnLGludDhCRTpnKDEpLGludDE2QkU6ZygyKSxpbnQzMkJFOmcoNCksaW50TEU6bSxpbnQ4TEU6bSgxKSxpbnQxNkxFOm0oMiksaW50MzJMRTptKDQpLGZsb2F0QkU6aChcImZsb2F0QkVcIiw0KS5tYXAoZnVuY3Rpb24obil7cmV0dXJuIG4ucmVhZEZsb2F0QkUoMCl9KSxmbG9hdExFOmgoXCJmbG9hdExFXCIsNCkubWFwKGZ1bmN0aW9uKG4pe3JldHVybiBuLnJlYWRGbG9hdExFKDApfSksZG91YmxlQkU6aChcImRvdWJsZUJFXCIsOCkubWFwKGZ1bmN0aW9uKG4pe3JldHVybiBuLnJlYWREb3VibGVCRSgwKX0pLGRvdWJsZUxFOmgoXCJkb3VibGVMRVwiLDgpLm1hcChmdW5jdGlvbihuKXtyZXR1cm4gbi5yZWFkRG91YmxlTEUoMCl9KX0sbi5leHBvcnRzPWV9XSl9KTsiLCAiZXhwb3J0IGRlZmF1bHQgKCkgPT4ge1xuXHQvLyBodHRwczovL210aHMuYmUvZW1vamlcblx0cmV0dXJuIC9bIyowLTldXFx1RkUwRj9cXHUyMEUzfFtcXHhBOVxceEFFXFx1MjAzQ1xcdTIwNDlcXHUyMTIyXFx1MjEzOVxcdTIxOTQtXFx1MjE5OVxcdTIxQTlcXHUyMUFBXFx1MjMxQVxcdTIzMUJcXHUyMzI4XFx1MjNDRlxcdTIzRUQtXFx1MjNFRlxcdTIzRjFcXHUyM0YyXFx1MjNGOC1cXHUyM0ZBXFx1MjRDMlxcdTI1QUFcXHUyNUFCXFx1MjVCNlxcdTI1QzBcXHUyNUZCXFx1MjVGQ1xcdTI1RkVcXHUyNjAwLVxcdTI2MDRcXHUyNjBFXFx1MjYxMVxcdTI2MTRcXHUyNjE1XFx1MjYxOFxcdTI2MjBcXHUyNjIyXFx1MjYyM1xcdTI2MjZcXHUyNjJBXFx1MjYyRVxcdTI2MkZcXHUyNjM4LVxcdTI2M0FcXHUyNjQwXFx1MjY0MlxcdTI2NDgtXFx1MjY1M1xcdTI2NUZcXHUyNjYwXFx1MjY2M1xcdTI2NjVcXHUyNjY2XFx1MjY2OFxcdTI2N0JcXHUyNjdFXFx1MjY3RlxcdTI2OTJcXHUyNjk0LVxcdTI2OTdcXHUyNjk5XFx1MjY5QlxcdTI2OUNcXHUyNkEwXFx1MjZBN1xcdTI2QUFcXHUyNkIwXFx1MjZCMVxcdTI2QkRcXHUyNkJFXFx1MjZDNFxcdTI2QzhcXHUyNkNGXFx1MjZEMVxcdTI2RDNcXHUyNkU5XFx1MjZGMC1cXHUyNkY1XFx1MjZGN1xcdTI2RjhcXHUyNkZBXFx1MjcwMlxcdTI3MDhcXHUyNzA5XFx1MjcwRlxcdTI3MTJcXHUyNzE0XFx1MjcxNlxcdTI3MURcXHUyNzIxXFx1MjczM1xcdTI3MzRcXHUyNzQ0XFx1Mjc0N1xcdTI3NTdcXHUyNzYzXFx1MjdBMVxcdTI5MzRcXHUyOTM1XFx1MkIwNS1cXHUyQjA3XFx1MkIxQlxcdTJCMUNcXHUyQjU1XFx1MzAzMFxcdTMwM0RcXHUzMjk3XFx1MzI5OV1cXHVGRTBGP3xbXFx1MjYxRFxcdTI3MENcXHUyNzBEXSg/OlxcdUZFMEZ8XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKT98W1xcdTI3MEFcXHUyNzBCXSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSk/fFtcXHUyM0U5LVxcdTIzRUNcXHUyM0YwXFx1MjNGM1xcdTI1RkRcXHUyNjkzXFx1MjZBMVxcdTI2QUJcXHUyNkM1XFx1MjZDRVxcdTI2RDRcXHUyNkVBXFx1MjZGRFxcdTI3MDVcXHUyNzI4XFx1Mjc0Q1xcdTI3NEVcXHUyNzUzLVxcdTI3NTVcXHUyNzk1LVxcdTI3OTdcXHUyN0IwXFx1MjdCRlxcdTJCNTBdfFxcdTI2RjkoPzpcXHVGRTBGfFxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSk/KD86XFx1MjAwRFtcXHUyNjQwXFx1MjY0Ml1cXHVGRTBGPyk/fFxcdTI3NjRcXHVGRTBGPyg/OlxcdTIwMEQoPzpcXHVEODNEXFx1REQyNXxcXHVEODNFXFx1REU3OSkpP3xcXHVEODNDKD86W1xcdURDMDRcXHVERDcwXFx1REQ3MVxcdUREN0VcXHVERDdGXFx1REUwMlxcdURFMzdcXHVERjIxXFx1REYyNC1cXHVERjJDXFx1REYzNlxcdURGN0RcXHVERjk2XFx1REY5N1xcdURGOTktXFx1REY5QlxcdURGOUVcXHVERjlGXFx1REZDRFxcdURGQ0VcXHVERkQ0LVxcdURGREZcXHVERkY1XFx1REZGN11cXHVGRTBGP3xbXFx1REY4NVxcdURGQzJcXHVERkM3XSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSk/fFtcXHVERkMzXFx1REZDNFxcdURGQ0FdKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKT8oPzpcXHUyMDBEW1xcdTI2NDBcXHUyNjQyXVxcdUZFMEY/KT98W1xcdURGQ0JcXHVERkNDXSg/OlxcdUZFMEZ8XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKT8oPzpcXHUyMDBEW1xcdTI2NDBcXHUyNjQyXVxcdUZFMEY/KT98W1xcdURDQ0ZcXHVERDhFXFx1REQ5MS1cXHVERDlBXFx1REUwMVxcdURFMUFcXHVERTJGXFx1REUzMi1cXHVERTM2XFx1REUzOC1cXHVERTNBXFx1REU1MFxcdURFNTFcXHVERjAwLVxcdURGMjBcXHVERjJELVxcdURGMzVcXHVERjM3LVxcdURGN0NcXHVERjdFLVxcdURGODRcXHVERjg2LVxcdURGOTNcXHVERkEwLVxcdURGQzFcXHVERkM1XFx1REZDNlxcdURGQzhcXHVERkM5XFx1REZDRi1cXHVERkQzXFx1REZFMC1cXHVERkYwXFx1REZGOC1cXHVERkZGXXxcXHVEREU2XFx1RDgzQ1tcXHVEREU4LVxcdURERUNcXHVEREVFXFx1RERGMVxcdURERjJcXHVEREY0XFx1RERGNi1cXHVEREZBXFx1RERGQ1xcdURERkRcXHVEREZGXXxcXHVEREU3XFx1RDgzQ1tcXHVEREU2XFx1RERFN1xcdURERTktXFx1RERFRlxcdURERjEtXFx1RERGNFxcdURERjYtXFx1RERGOVxcdURERkJcXHVEREZDXFx1RERGRVxcdURERkZdfFxcdURERThcXHVEODNDW1xcdURERTZcXHVEREU4XFx1RERFOVxcdURERUItXFx1RERFRVxcdURERjAtXFx1RERGNVxcdURERjdcXHVEREZBLVxcdURERkZdfFxcdURERTlcXHVEODNDW1xcdURERUFcXHVEREVDXFx1RERFRlxcdURERjBcXHVEREYyXFx1RERGNFxcdURERkZdfFxcdURERUFcXHVEODNDW1xcdURERTZcXHVEREU4XFx1RERFQVxcdURERUNcXHVEREVEXFx1RERGNy1cXHVEREZBXXxcXHVEREVCXFx1RDgzQ1tcXHVEREVFLVxcdURERjBcXHVEREYyXFx1RERGNFxcdURERjddfFxcdURERUNcXHVEODNDW1xcdURERTZcXHVEREU3XFx1RERFOS1cXHVEREVFXFx1RERGMS1cXHVEREYzXFx1RERGNS1cXHVEREZBXFx1RERGQ1xcdURERkVdfFxcdURERURcXHVEODNDW1xcdURERjBcXHVEREYyXFx1RERGM1xcdURERjdcXHVEREY5XFx1RERGQV18XFx1RERFRVxcdUQ4M0NbXFx1RERFOC1cXHVEREVBXFx1RERGMS1cXHVEREY0XFx1RERGNi1cXHVEREY5XXxcXHVEREVGXFx1RDgzQ1tcXHVEREVBXFx1RERGMlxcdURERjRcXHVEREY1XXxcXHVEREYwXFx1RDgzQ1tcXHVEREVBXFx1RERFQy1cXHVEREVFXFx1RERGMlxcdURERjNcXHVEREY1XFx1RERGN1xcdURERkNcXHVEREZFXFx1RERGRl18XFx1RERGMVxcdUQ4M0NbXFx1RERFNi1cXHVEREU4XFx1RERFRVxcdURERjBcXHVEREY3LVxcdURERkJcXHVEREZFXXxcXHVEREYyXFx1RDgzQ1tcXHVEREU2XFx1RERFOC1cXHVEREVEXFx1RERGMC1cXHVEREZGXXxcXHVEREYzXFx1RDgzQ1tcXHVEREU2XFx1RERFOFxcdURERUEtXFx1RERFQ1xcdURERUVcXHVEREYxXFx1RERGNFxcdURERjVcXHVEREY3XFx1RERGQVxcdURERkZdfFxcdURERjRcXHVEODNDXFx1RERGMnxcXHVEREY1XFx1RDgzQ1tcXHVEREU2XFx1RERFQS1cXHVEREVEXFx1RERGMC1cXHVEREYzXFx1RERGNy1cXHVEREY5XFx1RERGQ1xcdURERkVdfFxcdURERjZcXHVEODNDXFx1RERFNnxcXHVEREY3XFx1RDgzQ1tcXHVEREVBXFx1RERGNFxcdURERjhcXHVEREZBXFx1RERGQ118XFx1RERGOFxcdUQ4M0NbXFx1RERFNi1cXHVEREVBXFx1RERFQy1cXHVEREY0XFx1RERGNy1cXHVEREY5XFx1RERGQlxcdURERkQtXFx1RERGRl18XFx1RERGOVxcdUQ4M0NbXFx1RERFNlxcdURERThcXHVEREU5XFx1RERFQi1cXHVEREVEXFx1RERFRi1cXHVEREY0XFx1RERGN1xcdURERjlcXHVEREZCXFx1RERGQ1xcdURERkZdfFxcdURERkFcXHVEODNDW1xcdURERTZcXHVEREVDXFx1RERGMlxcdURERjNcXHVEREY4XFx1RERGRVxcdURERkZdfFxcdURERkJcXHVEODNDW1xcdURERTZcXHVEREU4XFx1RERFQVxcdURERUNcXHVEREVFXFx1RERGM1xcdURERkFdfFxcdURERkNcXHVEODNDW1xcdURERUJcXHVEREY4XXxcXHVEREZEXFx1RDgzQ1xcdURERjB8XFx1RERGRVxcdUQ4M0NbXFx1RERFQVxcdURERjldfFxcdURERkZcXHVEODNDW1xcdURERTZcXHVEREYyXFx1RERGQ118XFx1REZGM1xcdUZFMEY/KD86XFx1MjAwRCg/OlxcdTI2QTdcXHVGRTBGP3xcXHVEODNDXFx1REYwOCkpP3xcXHVERkY0KD86XFx1MjAwRFxcdTI2MjBcXHVGRTBGP3xcXHVEQjQwXFx1REM2N1xcdURCNDBcXHVEQzYyXFx1REI0MCg/OlxcdURDNjVcXHVEQjQwXFx1REM2RVxcdURCNDBcXHVEQzY3fFxcdURDNzNcXHVEQjQwXFx1REM2M1xcdURCNDBcXHVEQzc0fFxcdURDNzdcXHVEQjQwXFx1REM2Q1xcdURCNDBcXHVEQzczKVxcdURCNDBcXHVEQzdGKT8pfFxcdUQ4M0QoPzpbXFx1REMwOFxcdURDMjZdKD86XFx1MjAwRFxcdTJCMUIpP3xbXFx1REMzRlxcdURDRkRcXHVERDQ5XFx1REQ0QVxcdURENkZcXHVERDcwXFx1REQ3M1xcdURENzYtXFx1REQ3OVxcdUREODdcXHVERDhBLVxcdUREOERcXHVEREE1XFx1RERBOFxcdUREQjFcXHVEREIyXFx1RERCQ1xcdUREQzItXFx1RERDNFxcdURERDEtXFx1REREM1xcdUREREMtXFx1RERERVxcdURERTFcXHVEREUzXFx1RERFOFxcdURERUZcXHVEREYzXFx1RERGQVxcdURFQ0JcXHVERUNELVxcdURFQ0ZcXHVERUUwLVxcdURFRTVcXHVERUU5XFx1REVGMFxcdURFRjNdXFx1RkUwRj98W1xcdURDNDJcXHVEQzQzXFx1REM0Ni1cXHVEQzUwXFx1REM2NlxcdURDNjdcXHVEQzZCLVxcdURDNkRcXHVEQzcyXFx1REM3NC1cXHVEQzc2XFx1REM3OFxcdURDN0NcXHVEQzgzXFx1REM4NVxcdURDOEZcXHVEQzkxXFx1RENBQVxcdUREN0FcXHVERDk1XFx1REQ5NlxcdURFNENcXHVERTRGXFx1REVDMFxcdURFQ0NdKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKT98W1xcdURDNkVcXHVEQzcwXFx1REM3MVxcdURDNzNcXHVEQzc3XFx1REM4MVxcdURDODJcXHVEQzg2XFx1REM4N1xcdURFNDUtXFx1REU0N1xcdURFNEJcXHVERTREXFx1REU0RVxcdURFQTNcXHVERUI0LVxcdURFQjZdKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKT8oPzpcXHUyMDBEW1xcdTI2NDBcXHUyNjQyXVxcdUZFMEY/KT98W1xcdURENzRcXHVERDkwXSg/OlxcdUZFMEZ8XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKT98W1xcdURDMDAtXFx1REMwN1xcdURDMDktXFx1REMxNFxcdURDMTYtXFx1REMyNVxcdURDMjctXFx1REMzQVxcdURDM0MtXFx1REMzRVxcdURDNDBcXHVEQzQ0XFx1REM0NVxcdURDNTEtXFx1REM2NVxcdURDNkFcXHVEQzc5LVxcdURDN0JcXHVEQzdELVxcdURDODBcXHVEQzg0XFx1REM4OC1cXHVEQzhFXFx1REM5MFxcdURDOTItXFx1RENBOVxcdURDQUItXFx1RENGQ1xcdURDRkYtXFx1REQzRFxcdURENEItXFx1REQ0RVxcdURENTAtXFx1REQ2N1xcdUREQTRcXHVEREZCLVxcdURFMkRcXHVERTJGLVxcdURFMzRcXHVERTM3LVxcdURFNDRcXHVERTQ4LVxcdURFNEFcXHVERTgwLVxcdURFQTJcXHVERUE0LVxcdURFQjNcXHVERUI3LVxcdURFQkZcXHVERUMxLVxcdURFQzVcXHVERUQwLVxcdURFRDJcXHVERUQ1LVxcdURFRDdcXHVERURDLVxcdURFREZcXHVERUVCXFx1REVFQ1xcdURFRjQtXFx1REVGQ1xcdURGRTAtXFx1REZFQlxcdURGRjBdfFxcdURDMTUoPzpcXHUyMDBEXFx1RDgzRVxcdUREQkEpP3xcXHVEQzNCKD86XFx1MjAwRFxcdTI3NDRcXHVGRTBGPyk/fFxcdURDNDFcXHVGRTBGPyg/OlxcdTIwMERcXHVEODNEXFx1RERFOFxcdUZFMEY/KT98XFx1REM2OCg/OlxcdTIwMEQoPzpbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XVxcdUZFMEY/fFxcdTI3NjRcXHVGRTBGP1xcdTIwMERcXHVEODNEKD86XFx1REM4QlxcdTIwMERcXHVEODNEKT9cXHVEQzY4fFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0QoPzpbXFx1REM2OFxcdURDNjldXFx1MjAwRFxcdUQ4M0QoPzpcXHVEQzY2KD86XFx1MjAwRFxcdUQ4M0RcXHVEQzY2KT98XFx1REM2Nyg/OlxcdTIwMERcXHVEODNEW1xcdURDNjZcXHVEQzY3XSk/KXxbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEQzY2KD86XFx1MjAwRFxcdUQ4M0RcXHVEQzY2KT98XFx1REM2Nyg/OlxcdTIwMERcXHVEODNEW1xcdURDNjZcXHVEQzY3XSk/KXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8XFx1RDgzQyg/OlxcdURGRkIoPzpcXHUyMDBEKD86W1xcdTI2OTVcXHUyNjk2XFx1MjcwOF1cXHVGRTBGP3xcXHUyNzY0XFx1RkUwRj9cXHUyMDBEXFx1RDgzRCg/OlxcdURDOEJcXHUyMDBEXFx1RDgzRCk/XFx1REM2OFxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRSg/OltcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF18XFx1REQxRFxcdTIwMERcXHVEODNEXFx1REM2OFxcdUQ4M0NbXFx1REZGQy1cXHVERkZGXSkpKT98XFx1REZGQyg/OlxcdTIwMEQoPzpbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XVxcdUZFMEY/fFxcdTI3NjRcXHVGRTBGP1xcdTIwMERcXHVEODNEKD86XFx1REM4QlxcdTIwMERcXHVEODNEKT9cXHVEQzY4XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFKD86W1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXXxcXHVERDFEXFx1MjAwRFxcdUQ4M0RcXHVEQzY4XFx1RDgzQ1tcXHVERkZCXFx1REZGRC1cXHVERkZGXSkpKT98XFx1REZGRCg/OlxcdTIwMEQoPzpbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XVxcdUZFMEY/fFxcdTI3NjRcXHVGRTBGP1xcdTIwMERcXHVEODNEKD86XFx1REM4QlxcdTIwMERcXHVEODNEKT9cXHVEQzY4XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFKD86W1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXXxcXHVERDFEXFx1MjAwRFxcdUQ4M0RcXHVEQzY4XFx1RDgzQ1tcXHVERkZCXFx1REZGQ1xcdURGRkVcXHVERkZGXSkpKT98XFx1REZGRSg/OlxcdTIwMEQoPzpbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XVxcdUZFMEY/fFxcdTI3NjRcXHVGRTBGP1xcdTIwMERcXHVEODNEKD86XFx1REM4QlxcdTIwMERcXHVEODNEKT9cXHVEQzY4XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFKD86W1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXXxcXHVERDFEXFx1MjAwRFxcdUQ4M0RcXHVEQzY4XFx1RDgzQ1tcXHVERkZCLVxcdURGRkRcXHVERkZGXSkpKT98XFx1REZGRig/OlxcdTIwMEQoPzpbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XVxcdUZFMEY/fFxcdTI3NjRcXHVGRTBGP1xcdTIwMERcXHVEODNEKD86XFx1REM4QlxcdTIwMERcXHVEODNEKT9cXHVEQzY4XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFKD86W1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXXxcXHVERDFEXFx1MjAwRFxcdUQ4M0RcXHVEQzY4XFx1RDgzQ1tcXHVERkZCLVxcdURGRkVdKSkpPykpP3xcXHVEQzY5KD86XFx1MjAwRCg/OltcXHUyNjk1XFx1MjY5NlxcdTI3MDhdXFx1RkUwRj98XFx1Mjc2NFxcdUZFMEY/XFx1MjAwRFxcdUQ4M0QoPzpcXHVEQzhCXFx1MjAwRFxcdUQ4M0QpP1tcXHVEQzY4XFx1REM2OV18XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRCg/OltcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdURDNjYoPzpcXHUyMDBEXFx1RDgzRFxcdURDNjYpP3xcXHVEQzY3KD86XFx1MjAwRFxcdUQ4M0RbXFx1REM2NlxcdURDNjddKT98XFx1REM2OVxcdTIwMERcXHVEODNEKD86XFx1REM2Nig/OlxcdTIwMERcXHVEODNEXFx1REM2Nik/fFxcdURDNjcoPzpcXHUyMDBEXFx1RDgzRFtcXHVEQzY2XFx1REM2N10pPykpfFxcdUQ4M0VbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdKXxcXHVEODNDKD86XFx1REZGQig/OlxcdTIwMEQoPzpbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XVxcdUZFMEY/fFxcdTI3NjRcXHVGRTBGP1xcdTIwMERcXHVEODNEKD86W1xcdURDNjhcXHVEQzY5XXxcXHVEQzhCXFx1MjAwRFxcdUQ4M0RbXFx1REM2OFxcdURDNjldKVxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRSg/OltcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF18XFx1REQxRFxcdTIwMERcXHVEODNEW1xcdURDNjhcXHVEQzY5XVxcdUQ4M0NbXFx1REZGQy1cXHVERkZGXSkpKT98XFx1REZGQyg/OlxcdTIwMEQoPzpbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XVxcdUZFMEY/fFxcdTI3NjRcXHVGRTBGP1xcdTIwMERcXHVEODNEKD86W1xcdURDNjhcXHVEQzY5XXxcXHVEQzhCXFx1MjAwRFxcdUQ4M0RbXFx1REM2OFxcdURDNjldKVxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRSg/OltcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF18XFx1REQxRFxcdTIwMERcXHVEODNEW1xcdURDNjhcXHVEQzY5XVxcdUQ4M0NbXFx1REZGQlxcdURGRkQtXFx1REZGRl0pKSk/fFxcdURGRkQoPzpcXHUyMDBEKD86W1xcdTI2OTVcXHUyNjk2XFx1MjcwOF1cXHVGRTBGP3xcXHUyNzY0XFx1RkUwRj9cXHUyMDBEXFx1RDgzRCg/OltcXHVEQzY4XFx1REM2OV18XFx1REM4QlxcdTIwMERcXHVEODNEW1xcdURDNjhcXHVEQzY5XSlcXHVEODNDW1xcdURGRkItXFx1REZGRl18XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0UoPzpbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdfFxcdUREMURcXHUyMDBEXFx1RDgzRFtcXHVEQzY4XFx1REM2OV1cXHVEODNDW1xcdURGRkJcXHVERkZDXFx1REZGRVxcdURGRkZdKSkpP3xcXHVERkZFKD86XFx1MjAwRCg/OltcXHUyNjk1XFx1MjY5NlxcdTI3MDhdXFx1RkUwRj98XFx1Mjc2NFxcdUZFMEY/XFx1MjAwRFxcdUQ4M0QoPzpbXFx1REM2OFxcdURDNjldfFxcdURDOEJcXHUyMDBEXFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pXFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFKD86W1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXXxcXHVERDFEXFx1MjAwRFxcdUQ4M0RbXFx1REM2OFxcdURDNjldXFx1RDgzQ1tcXHVERkZCLVxcdURGRkRcXHVERkZGXSkpKT98XFx1REZGRig/OlxcdTIwMEQoPzpbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XVxcdUZFMEY/fFxcdTI3NjRcXHVGRTBGP1xcdTIwMERcXHVEODNEKD86W1xcdURDNjhcXHVEQzY5XXxcXHVEQzhCXFx1MjAwRFxcdUQ4M0RbXFx1REM2OFxcdURDNjldKVxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRSg/OltcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF18XFx1REQxRFxcdTIwMERcXHVEODNEW1xcdURDNjhcXHVEQzY5XVxcdUQ4M0NbXFx1REZGQi1cXHVERkZFXSkpKT8pKT98XFx1REM2Rig/OlxcdTIwMERbXFx1MjY0MFxcdTI2NDJdXFx1RkUwRj8pP3xcXHVERDc1KD86XFx1RkUwRnxcXHVEODNDW1xcdURGRkItXFx1REZGRl0pPyg/OlxcdTIwMERbXFx1MjY0MFxcdTI2NDJdXFx1RkUwRj8pP3xcXHVERTJFKD86XFx1MjAwRFxcdUQ4M0RcXHVEQ0E4KT98XFx1REUzNSg/OlxcdTIwMERcXHVEODNEXFx1RENBQik/fFxcdURFMzYoPzpcXHUyMDBEXFx1RDgzQ1xcdURGMkJcXHVGRTBGPyk/KXxcXHVEODNFKD86W1xcdUREMENcXHVERDBGXFx1REQxOC1cXHVERDFGXFx1REQzMC1cXHVERDM0XFx1REQzNlxcdURENzdcXHVEREI1XFx1RERCNlxcdUREQkJcXHVEREQyXFx1REREM1xcdURERDVcXHVERUMzLVxcdURFQzVcXHVERUYwXFx1REVGMi1cXHVERUY4XSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSk/fFtcXHVERDI2XFx1REQzNVxcdUREMzctXFx1REQzOVxcdUREM0RcXHVERDNFXFx1RERCOFxcdUREQjlcXHVERENELVxcdUREQ0ZcXHVEREQ0XFx1RERENi1cXHVEREREXSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSk/KD86XFx1MjAwRFtcXHUyNjQwXFx1MjY0Ml1cXHVGRTBGPyk/fFtcXHVERERFXFx1RERERl0oPzpcXHUyMDBEW1xcdTI2NDBcXHUyNjQyXVxcdUZFMEY/KT98W1xcdUREMERcXHVERDBFXFx1REQxMC1cXHVERDE3XFx1REQyMC1cXHVERDI1XFx1REQyNy1cXHVERDJGXFx1REQzQVxcdUREM0YtXFx1REQ0NVxcdURENDctXFx1REQ3NlxcdURENzgtXFx1RERCNFxcdUREQjdcXHVEREJBXFx1RERCQy1cXHVERENDXFx1REREMFxcdURERTAtXFx1RERGRlxcdURFNzAtXFx1REU3Q1xcdURFODAtXFx1REU4OFxcdURFOTAtXFx1REVCRFxcdURFQkYtXFx1REVDMlxcdURFQ0UtXFx1REVEQlxcdURFRTAtXFx1REVFOF18XFx1REQzQyg/OlxcdTIwMERbXFx1MjY0MFxcdTI2NDJdXFx1RkUwRj98XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKT98XFx1REREMSg/OlxcdTIwMEQoPzpbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XVxcdUZFMEY/fFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY4NFxcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRSg/OltcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF18XFx1REQxRFxcdTIwMERcXHVEODNFXFx1REREMSkpfFxcdUQ4M0MoPzpcXHVERkZCKD86XFx1MjAwRCg/OltcXHUyNjk1XFx1MjY5NlxcdTI3MDhdXFx1RkUwRj98XFx1Mjc2NFxcdUZFMEY/XFx1MjAwRCg/OlxcdUQ4M0RcXHVEQzhCXFx1MjAwRCk/XFx1RDgzRVxcdURERDFcXHVEODNDW1xcdURGRkMtXFx1REZGRl18XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjg0XFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFKD86W1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXXxcXHVERDFEXFx1MjAwRFxcdUQ4M0VcXHVEREQxXFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKSkpP3xcXHVERkZDKD86XFx1MjAwRCg/OltcXHUyNjk1XFx1MjY5NlxcdTI3MDhdXFx1RkUwRj98XFx1Mjc2NFxcdUZFMEY/XFx1MjAwRCg/OlxcdUQ4M0RcXHVEQzhCXFx1MjAwRCk/XFx1RDgzRVxcdURERDFcXHVEODNDW1xcdURGRkJcXHVERkZELVxcdURGRkZdfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY4NFxcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRSg/OltcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF18XFx1REQxRFxcdTIwMERcXHVEODNFXFx1REREMVxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSkpKT98XFx1REZGRCg/OlxcdTIwMEQoPzpbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XVxcdUZFMEY/fFxcdTI3NjRcXHVGRTBGP1xcdTIwMEQoPzpcXHVEODNEXFx1REM4QlxcdTIwMEQpP1xcdUQ4M0VcXHVEREQxXFx1RDgzQ1tcXHVERkZCXFx1REZGQ1xcdURGRkVcXHVERkZGXXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGODRcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0UoPzpbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdfFxcdUREMURcXHUyMDBEXFx1RDgzRVxcdURERDFcXHVEODNDW1xcdURGRkItXFx1REZGRl0pKSk/fFxcdURGRkUoPzpcXHUyMDBEKD86W1xcdTI2OTVcXHUyNjk2XFx1MjcwOF1cXHVGRTBGP3xcXHUyNzY0XFx1RkUwRj9cXHUyMDBEKD86XFx1RDgzRFxcdURDOEJcXHUyMDBEKT9cXHVEODNFXFx1REREMVxcdUQ4M0NbXFx1REZGQi1cXHVERkZEXFx1REZGRl18XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjg0XFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFKD86W1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXXxcXHVERDFEXFx1MjAwRFxcdUQ4M0VcXHVEREQxXFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKSkpP3xcXHVERkZGKD86XFx1MjAwRCg/OltcXHUyNjk1XFx1MjY5NlxcdTI3MDhdXFx1RkUwRj98XFx1Mjc2NFxcdUZFMEY/XFx1MjAwRCg/OlxcdUQ4M0RcXHVEQzhCXFx1MjAwRCk/XFx1RDgzRVxcdURERDFcXHVEODNDW1xcdURGRkItXFx1REZGRV18XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjg0XFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFKD86W1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXXxcXHVERDFEXFx1MjAwRFxcdUQ4M0VcXHVEREQxXFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKSkpPykpP3xcXHVERUYxKD86XFx1RDgzQyg/OlxcdURGRkIoPzpcXHUyMDBEXFx1RDgzRVxcdURFRjJcXHVEODNDW1xcdURGRkMtXFx1REZGRl0pP3xcXHVERkZDKD86XFx1MjAwRFxcdUQ4M0VcXHVERUYyXFx1RDgzQ1tcXHVERkZCXFx1REZGRC1cXHVERkZGXSk/fFxcdURGRkQoPzpcXHUyMDBEXFx1RDgzRVxcdURFRjJcXHVEODNDW1xcdURGRkJcXHVERkZDXFx1REZGRVxcdURGRkZdKT98XFx1REZGRSg/OlxcdTIwMERcXHVEODNFXFx1REVGMlxcdUQ4M0NbXFx1REZGQi1cXHVERkZEXFx1REZGRl0pP3xcXHVERkZGKD86XFx1MjAwRFxcdUQ4M0VcXHVERUYyXFx1RDgzQ1tcXHVERkZCLVxcdURGRkVdKT8pKT8pL2c7XG59O1xuIiwgImltcG9ydCB7IERhdGVUaW1lLCBEdXJhdGlvbiB9IGZyb20gXCJsdXhvblwiO1xuaW1wb3J0IHsgUmVzdWx0IH0gZnJvbSBcImFwaS9yZXN1bHRcIjtcbmltcG9ydCAqIGFzIFAgZnJvbSBcInBhcnNpbW1vblwiO1xuaW1wb3J0IGVtb2ppUmVnZXggZnJvbSBcImVtb2ppLXJlZ2V4XCI7XG5pbXBvcnQgeyBRdWVyeVNldHRpbmdzIH0gZnJvbSBcInNldHRpbmdzXCI7XG5cbi8qKiBOb3JtYWxpemUgYSBkdXJhdGlvbiB0byBhbGwgb2YgdGhlIHByb3BlciB1bml0cy4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVEdXJhdGlvbihkdXI6IER1cmF0aW9uKSB7XG4gICAgaWYgKGR1ciA9PT0gdW5kZWZpbmVkIHx8IGR1ciA9PT0gbnVsbCkgcmV0dXJuIGR1cjtcblxuICAgIHJldHVybiBkdXIuc2hpZnRUb0FsbCgpLm5vcm1hbGl6ZSgpO1xufVxuXG4vKiogU3RyaXAgdGhlIHRpbWUgY29tcG9uZW50cyBvZiBhIGRhdGUgdGltZSBvYmplY3QuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaXBUaW1lKGR0OiBEYXRlVGltZSk6IERhdGVUaW1lIHtcbiAgICBpZiAoZHQgPT09IG51bGwgfHwgZHQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGR0O1xuXG4gICAgcmV0dXJuIERhdGVUaW1lLmZyb21PYmplY3Qoe1xuICAgICAgICB5ZWFyOiBkdC55ZWFyLFxuICAgICAgICBtb250aDogZHQubW9udGgsXG4gICAgICAgIGRheTogZHQuZGF5LFxuICAgIH0pO1xufVxuXG4vKiogVHJ5IHRvIGV4dHJhY3QgYSBZWVlZTU1ERCBkYXRlIGZyb20gYSBzdHJpbmcuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdERhdGUoc3RyOiBzdHJpbmcpOiBEYXRlVGltZSB8IHVuZGVmaW5lZCB7XG4gICAgbGV0IGRhdGVNYXRjaCA9IC8oXFxkezR9KS0oXFxkezJ9KS0oXFxkezJ9KS8uZXhlYyhzdHIpO1xuICAgIGlmICghZGF0ZU1hdGNoKSBkYXRlTWF0Y2ggPSAvKFxcZHs0fSkoXFxkezJ9KShcXGR7Mn0pLy5leGVjKHN0cik7XG4gICAgaWYgKGRhdGVNYXRjaCkge1xuICAgICAgICBsZXQgeWVhciA9IE51bWJlci5wYXJzZUludChkYXRlTWF0Y2hbMV0pO1xuICAgICAgICBsZXQgbW9udGggPSBOdW1iZXIucGFyc2VJbnQoZGF0ZU1hdGNoWzJdKTtcbiAgICAgICAgbGV0IGRheSA9IE51bWJlci5wYXJzZUludChkYXRlTWF0Y2hbM10pO1xuICAgICAgICByZXR1cm4gRGF0ZVRpbWUuZnJvbU9iamVjdCh7IHllYXIsIG1vbnRoLCBkYXkgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqIEdldCB0aGUgZm9sZGVyIGNvbnRhaW5pbmcgdGhlIGdpdmVuIHBhdGggKGkuZS4sIGxpa2UgY29tcHV0aW5nICdwYXRoLy4uJykuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFyZW50Rm9sZGVyKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHBhdGguc3BsaXQoXCIvXCIpLnNsaWNlKDAsIC0xKS5qb2luKFwiL1wiKTtcbn1cblxuLyoqIEdldCB0aGUgZmlsZSBuYW1lIGZvciB0aGUgZmlsZSByZWZlcmVuY2VkIGluIHRoZSBnaXZlbiBwYXRoLCBieSBzdHJpcHBpbmcgdGhlIHBhcmVudCBmb2xkZXJzLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZpbGVOYW1lKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHBhdGguaW5jbHVkZXMoXCIvXCIpID8gcGF0aC5zdWJzdHJpbmcocGF0aC5sYXN0SW5kZXhPZihcIi9cIikgKyAxKSA6IHBhdGg7XG59XG5cbi8qKiBHZXQgdGhlIFwidGl0bGVcIiBmb3IgYSBmaWxlLCBieSBzdHJpcHBpbmcgb3RoZXIgcGFydHMgb2YgdGhlIHBhdGggYXMgd2VsbCBhcyB0aGUgZXh0ZW5zaW9uLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZpbGVUaXRsZShwYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmIChwYXRoLmluY2x1ZGVzKFwiL1wiKSkgcGF0aCA9IHBhdGguc3Vic3RyaW5nKHBhdGgubGFzdEluZGV4T2YoXCIvXCIpICsgMSk7XG4gICAgaWYgKHBhdGguZW5kc1dpdGgoXCIubWRcIikpIHBhdGggPSBwYXRoLnN1YnN0cmluZygwLCBwYXRoLmxlbmd0aCAtIDMpO1xuICAgIHJldHVybiBwYXRoO1xufVxuXG4vKiogR2V0IHRoZSBleHRlbnNpb24gb2YgYSBmaWxlIGZyb20gdGhlIGZpbGUgcGF0aC4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRFeHRlbnNpb24ocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBpZiAoIXBhdGguaW5jbHVkZXMoXCIuXCIpKSByZXR1cm4gXCJcIjtcbiAgICByZXR1cm4gcGF0aC5zdWJzdHJpbmcocGF0aC5sYXN0SW5kZXhPZihcIi5cIikgKyAxKTtcbn1cblxuLyoqIFBhcnNlIGFsbCBzdWJ0YWdzIG91dCBvZiB0aGUgZ2l2ZW4gdGFnLiBJLmUuLCAjaGVsbG8vaS9hbSB3b3VsZCB5aWVsZCBbI2hlbGxvL2kvYW0sICNoZWxsby9pLCAjaGVsbG9dLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RTdWJ0YWdzKHRhZzogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIGxldCByZXN1bHQgPSBbdGFnXTtcbiAgICB3aGlsZSAodGFnLmluY2x1ZGVzKFwiL1wiKSkge1xuICAgICAgICB0YWcgPSB0YWcuc3Vic3RyaW5nKDAsIHRhZy5sYXN0SW5kZXhPZihcIi9cIikpO1xuICAgICAgICByZXN1bHQucHVzaCh0YWcpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKiBUcnkgY2FsbGluZyB0aGUgZ2l2ZW4gZnVuY3Rpb247IG9uIGZhaWx1cmUsIHJldHVybiB0aGUgZXJyb3IgbWVzc2FnZS4gICovXG5leHBvcnQgZnVuY3Rpb24gdHJ5T3JQcm9wb2dhdGU8VD4oZnVuYzogKCkgPT4gUmVzdWx0PFQsIHN0cmluZz4pOiBSZXN1bHQ8VCwgc3RyaW5nPiB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZ1bmMoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gUmVzdWx0LmZhaWx1cmUoXCJcIiArIGVycm9yICsgXCJcXG5cXG5cIiArIGVycm9yLnN0YWNrKTtcbiAgICB9XG59XG5cbi8qKiBUcnkgYXN5bmNocm9ub3VzbHkgY2FsbGluZyB0aGUgZ2l2ZW4gZnVuY3Rpb247IG9uIGZhaWx1cmUsIHJldHVybiB0aGUgZXJyb3IgbWVzc2FnZS4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3luY1RyeU9yUHJvcG9nYXRlPFQ+KGZ1bmM6ICgpID0+IFByb21pc2U8UmVzdWx0PFQsIHN0cmluZz4+KTogUHJvbWlzZTxSZXN1bHQ8VCwgc3RyaW5nPj4ge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBmdW5jKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIFJlc3VsdC5mYWlsdXJlKFwiXCIgKyBlcnJvciArIFwiXFxuXFxuXCIgKyBlcnJvci5zdGFjayk7XG4gICAgfVxufVxuXG4vKipcbiAqIEVzY2FwZSByZWdleCBjaGFyYWN0ZXJzIGluIGEgc3RyaW5nLlxuICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvR3VpZGUvUmVndWxhcl9FeHByZXNzaW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZVJlZ2V4KHN0cjogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgXCJcXFxcJCZcIik7XG59XG5cbi8qKiBBIHBhcnNpbW1vbiBwYXJzZXIgd2hpY2ggY2Fub25pY2FsaXplcyB2YXJpYWJsZSBuYW1lcyB3aGlsZSBwcm9wZXJseSByZXNwZWN0aW5nIGVtb2ppLiAqL1xuY29uc3QgVkFSX05BTUVfQ0FOT05JQ0FMSVpFUjogUC5QYXJzZXI8c3RyaW5nPiA9IFAuYWx0KFxuICAgIFAucmVnZXgobmV3IFJlZ0V4cChlbW9qaVJlZ2V4KCksIFwiXCIpKSxcbiAgICBQLnJlZ2V4KC9bMC05XFxwe0xldHRlcn1fLV0rL3UpLm1hcChzdHIgPT4gc3RyLnRvTG9jYWxlTG93ZXJDYXNlKCkpLFxuICAgIFAud2hpdGVzcGFjZS5tYXAoXyA9PiBcIi1cIiksXG4gICAgUC5hbnkubWFwKF8gPT4gXCJcIilcbilcbiAgICAubWFueSgpXG4gICAgLm1hcChyZXN1bHQgPT4gcmVzdWx0LmpvaW4oXCJcIikpO1xuXG4vKiogQ29udmVydCBhbiBhcmJpdHJhcnkgdmFyaWFibGUgbmFtZSBpbnRvIHNvbWV0aGluZyBKUy9xdWVyeSBmcmllbmRseS4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYW5vbmljYWxpemVWYXJOYW1lKG5hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIFZBUl9OQU1FX0NBTk9OSUNBTElaRVIudHJ5UGFyc2UobmFtZSk7XG59XG5cbmNvbnN0IEhFQURFUl9DQU5PTklDQUxJWkVSOiBQLlBhcnNlcjxzdHJpbmc+ID0gUC5hbHQoXG4gICAgUC5yZWdleChuZXcgUmVnRXhwKGVtb2ppUmVnZXgoKSwgXCJcIikpLFxuICAgIFAucmVnZXgoL1swLTlcXHB7TGV0dGVyfV8tXSsvdSksXG4gICAgUC53aGl0ZXNwYWNlLm1hcChfID0+IFwiIFwiKSxcbiAgICBQLmFueS5tYXAoXyA9PiBcIiBcIilcbilcbiAgICAubWFueSgpXG4gICAgLm1hcChyZXN1bHQgPT4ge1xuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCJcIikuc3BsaXQoL1xccysvKS5qb2luKFwiIFwiKS50cmltKCk7XG4gICAgfSk7XG5cbi8qKlxuICogTm9ybWFsaXplcyB0aGUgdGV4dCBpbiBhIGhlYWRlciB0byBiZSBzb21ldGhpbmcgdGhhdCBpcyBhY3R1YWxseSBsaW5rYWJsZSB0by4gVGhpcyBtaW1pY3NcbiAqIGhvdyBPYnNpZGlhbiBkb2VzIGl0J3Mgbm9ybWFsaXphdGlvbiwgY29sbGFwc2luZyByZXBlYXRlZCBzcGFjZXMgYW5kIHN0cmlwcGluZyBvdXQgY29udHJvbCBjaGFyYWN0ZXJzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplSGVhZGVyRm9yTGluayhoZWFkZXI6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIEhFQURFUl9DQU5PTklDQUxJWkVSLnRyeVBhcnNlKGhlYWRlcik7XG59XG5cbi8qKiBSZW5kZXIgYSBEYXRlVGltZSBpbiBhIG1pbmltYWwgZm9ybWF0IHRvIHNhdmUgc3BhY2UuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyTWluaW1hbERhdGUodGltZTogRGF0ZVRpbWUsIHNldHRpbmdzOiBRdWVyeVNldHRpbmdzLCBsb2NhbGU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gcmVsZXZhbnQgdGltZSBzcGVjaWZpZWQsIGZhbGwgYmFjayB0byBqdXN0IHJlbmRlcmluZyB0aGUgZGF0ZS5cbiAgICBpZiAodGltZS5zZWNvbmQgPT0gMCAmJiB0aW1lLm1pbnV0ZSA9PSAwICYmIHRpbWUuaG91ciA9PSAwKSB7XG4gICAgICAgIHJldHVybiB0aW1lLnRvTG9jYWwoKS50b0Zvcm1hdChzZXR0aW5ncy5kZWZhdWx0RGF0ZUZvcm1hdCwgeyBsb2NhbGUgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRpbWUudG9Mb2NhbCgpLnRvRm9ybWF0KHNldHRpbmdzLmRlZmF1bHREYXRlVGltZUZvcm1hdCwgeyBsb2NhbGUgfSk7XG59XG5cbi8qKiBSZW5kZXIgYSBkdXJhdGlvbiBpbiBhIG1pbmltYWwgZm9ybWF0IHRvIHNhdmUgc3BhY2UuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyTWluaW1hbER1cmF0aW9uKGR1cjogRHVyYXRpb24pOiBzdHJpbmcge1xuICAgIGR1ciA9IG5vcm1hbGl6ZUR1cmF0aW9uKGR1cik7XG5cbiAgICAvLyB0b0h1bWFuIG91dHB1dHMgemVybyBxdWFudGl0aWVzIGUuZy4gXCIwIHNlY29uZHNcIlxuICAgIGR1ciA9IER1cmF0aW9uLmZyb21PYmplY3QoXG4gICAgICAgIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhkdXIudG9PYmplY3QoKSkuZmlsdGVyKChbLCBxdWFudGl0eV0pID0+IHF1YW50aXR5ICE9IDApKVxuICAgICk7XG5cbiAgICByZXR1cm4gZHVyLnRvSHVtYW4oKTtcbn1cblxuLyoqIERldGVybWluZSBpZiB0d28gc2V0cyBhcmUgZXF1YWwgaW4gY29udGVudHMuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0c0VxdWFsPFQ+KGZpcnN0OiBTZXQ8VD4sIHNlY29uZDogU2V0PFQ+KTogYm9vbGVhbiB7XG4gICAgaWYgKGZpcnN0LnNpemUgIT0gc2Vjb25kLnNpemUpIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBlbGVtIG9mIGZpcnN0KSBpZiAoIXNlY29uZC5oYXMoZWxlbSkpIHJldHVybiBmYWxzZTtcblxuICAgIHJldHVybiB0cnVlO1xufVxuIiwgImltcG9ydCB7IERhdGVUaW1lLCBEdXJhdGlvbiB9IGZyb20gXCJsdXhvblwiO1xuaW1wb3J0IHsgREVGQVVMVF9RVUVSWV9TRVRUSU5HUywgUXVlcnlTZXR0aW5ncyB9IGZyb20gXCJzZXR0aW5nc1wiO1xuaW1wb3J0IHsgZ2V0RmlsZVRpdGxlLCBub3JtYWxpemVIZWFkZXJGb3JMaW5rLCByZW5kZXJNaW5pbWFsRHVyYXRpb24gfSBmcm9tIFwidXRpbC9ub3JtYWxpemVcIjtcblxuLyoqIFNob3J0aGFuZCBmb3IgYSBtYXBwaW5nIGZyb20ga2V5cyB0byB2YWx1ZXMuICovXG5leHBvcnQgdHlwZSBEYXRhT2JqZWN0ID0geyBba2V5OiBzdHJpbmddOiBMaXRlcmFsIH07XG4vKiogVGhlIGxpdGVyYWwgdHlwZXMgc3VwcG9ydGVkIGJ5IHRoZSBxdWVyeSBlbmdpbmUuICovXG5leHBvcnQgdHlwZSBMaXRlcmFsVHlwZSA9XG4gICAgfCBcImJvb2xlYW5cIlxuICAgIHwgXCJudW1iZXJcIlxuICAgIHwgXCJzdHJpbmdcIlxuICAgIHwgXCJkYXRlXCJcbiAgICB8IFwiZHVyYXRpb25cIlxuICAgIHwgXCJsaW5rXCJcbiAgICB8IFwiYXJyYXlcIlxuICAgIHwgXCJvYmplY3RcIlxuICAgIHwgXCJmdW5jdGlvblwiXG4gICAgfCBcIm51bGxcIlxuICAgIHwgXCJodG1sXCJcbiAgICB8IFwid2lkZ2V0XCI7XG4vKiogVGhlIHJhdyB2YWx1ZXMgdGhhdCBhIGxpdGVyYWwgY2FuIHRha2Ugb24uICovXG5leHBvcnQgdHlwZSBMaXRlcmFsID1cbiAgICB8IGJvb2xlYW5cbiAgICB8IG51bWJlclxuICAgIHwgc3RyaW5nXG4gICAgfCBEYXRlVGltZVxuICAgIHwgRHVyYXRpb25cbiAgICB8IExpbmtcbiAgICB8IEFycmF5PExpdGVyYWw+XG4gICAgfCBEYXRhT2JqZWN0XG4gICAgfCBGdW5jdGlvblxuICAgIHwgbnVsbFxuICAgIHwgSFRNTEVsZW1lbnRcbiAgICB8IFdpZGdldDtcblxuLyoqIEEgZ3JvdXBpbmcgb24gYSB0eXBlIHdoaWNoIHN1cHBvcnRzIHJlY3Vyc2l2ZWx5LW5lc3RlZCBncm91cHMuICovXG5leHBvcnQgdHlwZSBHcm91cEVsZW1lbnQ8VD4gPSB7IGtleTogTGl0ZXJhbDsgcm93czogR3JvdXBpbmc8VD4gfTtcbmV4cG9ydCB0eXBlIEdyb3VwaW5nPFQ+ID0gVFtdIHwgR3JvdXBFbGVtZW50PFQ+W107XG5cbi8qKiBNYXBzIHRoZSBzdHJpbmcgdHlwZSB0byBpdCdzIGV4dGVybmFsLCBBUEktZmFjaW5nIHJlcHJlc2VudGF0aW9uLiAqL1xuZXhwb3J0IHR5cGUgTGl0ZXJhbFJlcHI8VCBleHRlbmRzIExpdGVyYWxUeXBlPiA9IFQgZXh0ZW5kcyBcImJvb2xlYW5cIlxuICAgID8gYm9vbGVhblxuICAgIDogVCBleHRlbmRzIFwibnVtYmVyXCJcbiAgICA/IG51bWJlclxuICAgIDogVCBleHRlbmRzIFwic3RyaW5nXCJcbiAgICA/IHN0cmluZ1xuICAgIDogVCBleHRlbmRzIFwiZHVyYXRpb25cIlxuICAgID8gRHVyYXRpb25cbiAgICA6IFQgZXh0ZW5kcyBcImRhdGVcIlxuICAgID8gRGF0ZVRpbWVcbiAgICA6IFQgZXh0ZW5kcyBcIm51bGxcIlxuICAgID8gbnVsbFxuICAgIDogVCBleHRlbmRzIFwibGlua1wiXG4gICAgPyBMaW5rXG4gICAgOiBUIGV4dGVuZHMgXCJhcnJheVwiXG4gICAgPyBBcnJheTxMaXRlcmFsPlxuICAgIDogVCBleHRlbmRzIFwib2JqZWN0XCJcbiAgICA/IFJlY29yZDxzdHJpbmcsIExpdGVyYWw+XG4gICAgOiBUIGV4dGVuZHMgXCJmdW5jdGlvblwiXG4gICAgPyBGdW5jdGlvblxuICAgIDogVCBleHRlbmRzIFwiaHRtbFwiXG4gICAgPyBIVE1MRWxlbWVudFxuICAgIDogVCBleHRlbmRzIFwid2lkZ2V0XCJcbiAgICA/IFdpZGdldFxuICAgIDogYW55O1xuXG4vKiogQSB3cmFwcGVkIGxpdGVyYWwgdmFsdWUgd2hpY2ggY2FuIGJlIHN3aXRjaGVkIG9uLiAqL1xuZXhwb3J0IHR5cGUgV3JhcHBlZExpdGVyYWwgPVxuICAgIHwgTGl0ZXJhbFdyYXBwZXI8XCJzdHJpbmdcIj5cbiAgICB8IExpdGVyYWxXcmFwcGVyPFwibnVtYmVyXCI+XG4gICAgfCBMaXRlcmFsV3JhcHBlcjxcImJvb2xlYW5cIj5cbiAgICB8IExpdGVyYWxXcmFwcGVyPFwiZGF0ZVwiPlxuICAgIHwgTGl0ZXJhbFdyYXBwZXI8XCJkdXJhdGlvblwiPlxuICAgIHwgTGl0ZXJhbFdyYXBwZXI8XCJsaW5rXCI+XG4gICAgfCBMaXRlcmFsV3JhcHBlcjxcImFycmF5XCI+XG4gICAgfCBMaXRlcmFsV3JhcHBlcjxcIm9iamVjdFwiPlxuICAgIHwgTGl0ZXJhbFdyYXBwZXI8XCJodG1sXCI+XG4gICAgfCBMaXRlcmFsV3JhcHBlcjxcIndpZGdldFwiPlxuICAgIHwgTGl0ZXJhbFdyYXBwZXI8XCJmdW5jdGlvblwiPlxuICAgIHwgTGl0ZXJhbFdyYXBwZXI8XCJudWxsXCI+O1xuXG5leHBvcnQgaW50ZXJmYWNlIExpdGVyYWxXcmFwcGVyPFQgZXh0ZW5kcyBMaXRlcmFsVHlwZT4ge1xuICAgIHR5cGU6IFQ7XG4gICAgdmFsdWU6IExpdGVyYWxSZXByPFQ+O1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFZhbHVlcyB7XG4gICAgLyoqIENvbnZlcnQgYW4gYXJiaXRyYXJ5IHZhbHVlIGludG8gYSByZWFzb25hYmxlLCBNYXJrZG93bi1mcmllbmRseSBzdHJpbmcgaWYgcG9zc2libGUuICovXG4gICAgZXhwb3J0IGZ1bmN0aW9uIHRvU3RyaW5nKFxuICAgICAgICBmaWVsZDogYW55LFxuICAgICAgICBzZXR0aW5nOiBRdWVyeVNldHRpbmdzID0gREVGQVVMVF9RVUVSWV9TRVRUSU5HUyxcbiAgICAgICAgcmVjdXJzaXZlOiBib29sZWFuID0gZmFsc2VcbiAgICApOiBzdHJpbmcge1xuICAgICAgICBsZXQgd3JhcHBlZCA9IHdyYXBWYWx1ZShmaWVsZCk7XG4gICAgICAgIGlmICghd3JhcHBlZCkgcmV0dXJuIHNldHRpbmcucmVuZGVyTnVsbEFzO1xuXG4gICAgICAgIHN3aXRjaCAod3JhcHBlZC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwibnVsbFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBzZXR0aW5nLnJlbmRlck51bGxBcztcbiAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZC52YWx1ZTtcbiAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyB3cmFwcGVkLnZhbHVlO1xuICAgICAgICAgICAgY2FzZSBcImh0bWxcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZC52YWx1ZS5vdXRlckhUTUw7XG4gICAgICAgICAgICBjYXNlIFwid2lkZ2V0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWQudmFsdWUubWFya2Rvd24oKTtcbiAgICAgICAgICAgIGNhc2UgXCJsaW5rXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWQudmFsdWUubWFya2Rvd24oKTtcbiAgICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcIjxmdW5jdGlvbj5cIjtcbiAgICAgICAgICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGlmIChyZWN1cnNpdmUpIHJlc3VsdCArPSBcIltcIjtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gd3JhcHBlZC52YWx1ZS5tYXAoZiA9PiB0b1N0cmluZyhmLCBzZXR0aW5nLCB0cnVlKSkuam9pbihcIiwgXCIpO1xuICAgICAgICAgICAgICAgIGlmIChyZWN1cnNpdmUpIHJlc3VsdCArPSBcIl1cIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgIFwieyBcIiArXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHdyYXBwZWQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKGUgPT4gZVswXSArIFwiOiBcIiArIHRvU3RyaW5nKGVbMV0sIHNldHRpbmcsIHRydWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oXCIsIFwiKSArXG4gICAgICAgICAgICAgICAgICAgIFwiIH1cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjYXNlIFwiZGF0ZVwiOlxuICAgICAgICAgICAgICAgIGlmICh3cmFwcGVkLnZhbHVlLnNlY29uZCA9PSAwICYmIHdyYXBwZWQudmFsdWUuaG91ciA9PSAwICYmIHdyYXBwZWQudmFsdWUubWludXRlID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWQudmFsdWUudG9Gb3JtYXQoc2V0dGluZy5kZWZhdWx0RGF0ZUZvcm1hdCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWQudmFsdWUudG9Gb3JtYXQoc2V0dGluZy5kZWZhdWx0RGF0ZVRpbWVGb3JtYXQpO1xuICAgICAgICAgICAgY2FzZSBcImR1cmF0aW9uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlck1pbmltYWxEdXJhdGlvbih3cmFwcGVkLnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBXcmFwIGEgbGl0ZXJhbCB2YWx1ZSBzbyB5b3UgY2FuIHN3aXRjaCBvbiBpdCBlYXNpbHkuICovXG4gICAgZXhwb3J0IGZ1bmN0aW9uIHdyYXBWYWx1ZSh2YWw6IExpdGVyYWwpOiBXcmFwcGVkTGl0ZXJhbCB8IHVuZGVmaW5lZCB7XG4gICAgICAgIGlmIChpc051bGwodmFsKSkgcmV0dXJuIHsgdHlwZTogXCJudWxsXCIsIHZhbHVlOiB2YWwgfTtcbiAgICAgICAgZWxzZSBpZiAoaXNOdW1iZXIodmFsKSkgcmV0dXJuIHsgdHlwZTogXCJudW1iZXJcIiwgdmFsdWU6IHZhbCB9O1xuICAgICAgICBlbHNlIGlmIChpc1N0cmluZyh2YWwpKSByZXR1cm4geyB0eXBlOiBcInN0cmluZ1wiLCB2YWx1ZTogdmFsIH07XG4gICAgICAgIGVsc2UgaWYgKGlzQm9vbGVhbih2YWwpKSByZXR1cm4geyB0eXBlOiBcImJvb2xlYW5cIiwgdmFsdWU6IHZhbCB9O1xuICAgICAgICBlbHNlIGlmIChpc0R1cmF0aW9uKHZhbCkpIHJldHVybiB7IHR5cGU6IFwiZHVyYXRpb25cIiwgdmFsdWU6IHZhbCB9O1xuICAgICAgICBlbHNlIGlmIChpc0RhdGUodmFsKSkgcmV0dXJuIHsgdHlwZTogXCJkYXRlXCIsIHZhbHVlOiB2YWwgfTtcbiAgICAgICAgZWxzZSBpZiAoaXNXaWRnZXQodmFsKSkgcmV0dXJuIHsgdHlwZTogXCJ3aWRnZXRcIiwgdmFsdWU6IHZhbCB9O1xuICAgICAgICBlbHNlIGlmIChpc0FycmF5KHZhbCkpIHJldHVybiB7IHR5cGU6IFwiYXJyYXlcIiwgdmFsdWU6IHZhbCB9O1xuICAgICAgICBlbHNlIGlmIChpc0xpbmsodmFsKSkgcmV0dXJuIHsgdHlwZTogXCJsaW5rXCIsIHZhbHVlOiB2YWwgfTtcbiAgICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbih2YWwpKSByZXR1cm4geyB0eXBlOiBcImZ1bmN0aW9uXCIsIHZhbHVlOiB2YWwgfTtcbiAgICAgICAgZWxzZSBpZiAoaXNIdG1sKHZhbCkpIHJldHVybiB7IHR5cGU6IFwiaHRtbFwiLCB2YWx1ZTogdmFsIH07XG4gICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkpIHJldHVybiB7IHR5cGU6IFwib2JqZWN0XCIsIHZhbHVlOiB2YWwgfTtcbiAgICAgICAgZWxzZSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKiBSZWN1cnNpdmVseSBtYXAgY29tcGxleCBvYmplY3RzIGF0IHRoZSBsZWF2ZXMuICovXG4gICAgZXhwb3J0IGZ1bmN0aW9uIG1hcExlYXZlcyh2YWw6IExpdGVyYWwsIGZ1bmM6ICh0OiBMaXRlcmFsKSA9PiBMaXRlcmFsKTogTGl0ZXJhbCB7XG4gICAgICAgIGlmIChpc09iamVjdCh2YWwpKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0OiBEYXRhT2JqZWN0ID0ge307XG4gICAgICAgICAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModmFsKSkgcmVzdWx0W2tleV0gPSBtYXBMZWF2ZXModmFsdWUsIGZ1bmMpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbCkpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQ6IExpdGVyYWxbXSA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgdmFsdWUgb2YgdmFsKSByZXN1bHQucHVzaChtYXBMZWF2ZXModmFsdWUsIGZ1bmMpKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuYyh2YWwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIENvbXBhcmUgdHdvIGFyYml0cmFyeSBKYXZhU2NyaXB0IHZhbHVlcy4gUHJvZHVjZXMgYSB0b3RhbCBvcmRlcmluZyBvdmVyIEFOWSBwb3NzaWJsZSBkYXRhdmlldyB2YWx1ZS4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gY29tcGFyZVZhbHVlKHZhbDE6IExpdGVyYWwsIHZhbDI6IExpdGVyYWwsIGxpbmtOb3JtYWxpemVyPzogKGxpbms6IHN0cmluZykgPT4gc3RyaW5nKTogbnVtYmVyIHtcbiAgICAgICAgLy8gSGFuZGxlIHVuZGVmaW5lZC9udWxscyBmaXJzdC5cbiAgICAgICAgaWYgKHZhbDEgPT09IHVuZGVmaW5lZCkgdmFsMSA9IG51bGw7XG4gICAgICAgIGlmICh2YWwyID09PSB1bmRlZmluZWQpIHZhbDIgPSBudWxsO1xuICAgICAgICBpZiAodmFsMSA9PT0gbnVsbCAmJiB2YWwyID09PSBudWxsKSByZXR1cm4gMDtcbiAgICAgICAgZWxzZSBpZiAodmFsMSA9PT0gbnVsbCkgcmV0dXJuIC0xO1xuICAgICAgICBlbHNlIGlmICh2YWwyID09PSBudWxsKSByZXR1cm4gMTtcblxuICAgICAgICAvLyBBIG5vbi1udWxsIHZhbHVlIG5vdyB3aGljaCB3ZSBjYW4gd3JhcCAmIGNvbXBhcmUgb24uXG4gICAgICAgIGxldCB3cmFwMSA9IHdyYXBWYWx1ZSh2YWwxKTtcbiAgICAgICAgbGV0IHdyYXAyID0gd3JhcFZhbHVlKHZhbDIpO1xuXG4gICAgICAgIGlmICh3cmFwMSA9PT0gdW5kZWZpbmVkICYmIHdyYXAyID09PSB1bmRlZmluZWQpIHJldHVybiAwO1xuICAgICAgICBlbHNlIGlmICh3cmFwMSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gLTE7XG4gICAgICAgIGVsc2UgaWYgKHdyYXAyID09PSB1bmRlZmluZWQpIHJldHVybiAxO1xuXG4gICAgICAgIC8vIFNob3J0LWNpcmN1aXQgb24gZGlmZmVyZW50IHR5cGVzIG9yIG9uIHJlZmVyZW5jZSBlcXVhbGl0eS5cbiAgICAgICAgaWYgKHdyYXAxLnR5cGUgIT0gd3JhcDIudHlwZSkgcmV0dXJuIHdyYXAxLnR5cGUubG9jYWxlQ29tcGFyZSh3cmFwMi50eXBlKTtcbiAgICAgICAgaWYgKHdyYXAxLnZhbHVlID09PSB3cmFwMi52YWx1ZSkgcmV0dXJuIDA7XG5cbiAgICAgICAgc3dpdGNoICh3cmFwMS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXAxLnZhbHVlLmxvY2FsZUNvbXBhcmUod3JhcDIudmFsdWUgYXMgc3RyaW5nKTtcbiAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgICAgICBpZiAod3JhcDEudmFsdWUgPCAod3JhcDIudmFsdWUgYXMgbnVtYmVyKSkgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHdyYXAxLnZhbHVlID09ICh3cmFwMi52YWx1ZSBhcyBudW1iZXIpKSByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIGNhc2UgXCJudWxsXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgICAgIGlmICh3cmFwMS52YWx1ZSA9PSB3cmFwMi52YWx1ZSkgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgZWxzZSByZXR1cm4gd3JhcDEudmFsdWUgPyAxIDogLTE7XG4gICAgICAgICAgICBjYXNlIFwibGlua1wiOlxuICAgICAgICAgICAgICAgIGxldCBsaW5rMSA9IHdyYXAxLnZhbHVlO1xuICAgICAgICAgICAgICAgIGxldCBsaW5rMiA9IHdyYXAyLnZhbHVlIGFzIExpbms7XG4gICAgICAgICAgICAgICAgbGV0IG5vcm1hbGl6ZSA9IGxpbmtOb3JtYWxpemVyID8/ICgoeDogc3RyaW5nKSA9PiB4KTtcblxuICAgICAgICAgICAgICAgIC8vIFdlIGNhbid0IGNvbXBhcmUgYnkgZmlsZSBuYW1lIG9yIGRpc3BsYXksIHNpbmNlIHRoYXQgd291bGQgYnJlYWsgbGluayBlcXVhbGl0eS4gQ29tcGFyZSBieSBwYXRoLlxuICAgICAgICAgICAgICAgIGxldCBwYXRoQ29tcGFyZSA9IG5vcm1hbGl6ZShsaW5rMS5wYXRoKS5sb2NhbGVDb21wYXJlKG5vcm1hbGl6ZShsaW5rMi5wYXRoKSk7XG4gICAgICAgICAgICAgICAgaWYgKHBhdGhDb21wYXJlICE9IDApIHJldHVybiBwYXRoQ29tcGFyZTtcblxuICAgICAgICAgICAgICAgIC8vIFRoZW4gY29tcGFyZSBieSB0eXBlLlxuICAgICAgICAgICAgICAgIGxldCB0eXBlQ29tcGFyZSA9IGxpbmsxLnR5cGUubG9jYWxlQ29tcGFyZShsaW5rMi50eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZUNvbXBhcmUgIT0gMCkgcmV0dXJuIHR5cGVDb21wYXJlO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhlbiBjb21wYXJlIGJ5IHN1YnBhdGggZXhpc3RlbmNlLlxuICAgICAgICAgICAgICAgIGlmIChsaW5rMS5zdWJwYXRoICYmICFsaW5rMi5zdWJwYXRoKSByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICBpZiAoIWxpbmsxLnN1YnBhdGggJiYgbGluazIuc3VicGF0aCkgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIGlmICghbGluazEuc3VicGF0aCAmJiAhbGluazIuc3VicGF0aCkgcmV0dXJuIDA7XG5cbiAgICAgICAgICAgICAgICAvLyBTaW5jZSBib3RoIGhhdmUgYSBzdWJwYXRoLCBjb21wYXJlIGJ5IHN1YnBhdGguXG4gICAgICAgICAgICAgICAgcmV0dXJuIChsaW5rMS5zdWJwYXRoID8/IFwiXCIpLmxvY2FsZUNvbXBhcmUobGluazIuc3VicGF0aCA/PyBcIlwiKTtcbiAgICAgICAgICAgIGNhc2UgXCJkYXRlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXAxLnZhbHVlIDwgKHdyYXAyLnZhbHVlIGFzIERhdGVUaW1lKVxuICAgICAgICAgICAgICAgICAgICA/IC0xXG4gICAgICAgICAgICAgICAgICAgIDogd3JhcDEudmFsdWUuZXF1YWxzKHdyYXAyLnZhbHVlIGFzIERhdGVUaW1lKVxuICAgICAgICAgICAgICAgICAgICA/IDBcbiAgICAgICAgICAgICAgICAgICAgOiAxO1xuICAgICAgICAgICAgY2FzZSBcImR1cmF0aW9uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXAxLnZhbHVlIDwgKHdyYXAyLnZhbHVlIGFzIER1cmF0aW9uKVxuICAgICAgICAgICAgICAgICAgICA/IC0xXG4gICAgICAgICAgICAgICAgICAgIDogd3JhcDEudmFsdWUuZXF1YWxzKHdyYXAyLnZhbHVlIGFzIER1cmF0aW9uKVxuICAgICAgICAgICAgICAgICAgICA/IDBcbiAgICAgICAgICAgICAgICAgICAgOiAxO1xuICAgICAgICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgICAgICAgICAgbGV0IGYxID0gd3JhcDEudmFsdWU7XG4gICAgICAgICAgICAgICAgbGV0IGYyID0gd3JhcDIudmFsdWUgYXMgYW55W107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IE1hdGgubWluKGYxLmxlbmd0aCwgZjIubGVuZ3RoKTsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29tcCA9IGNvbXBhcmVWYWx1ZShmMVtpbmRleF0sIGYyW2luZGV4XSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wICE9IDApIHJldHVybiBjb21wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZjEubGVuZ3RoIC0gZjIubGVuZ3RoO1xuICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgICAgIGxldCBvMSA9IHdyYXAxLnZhbHVlO1xuICAgICAgICAgICAgICAgIGxldCBvMiA9IHdyYXAyLnZhbHVlIGFzIFJlY29yZDxzdHJpbmcsIGFueT47XG4gICAgICAgICAgICAgICAgbGV0IGsxID0gQXJyYXkuZnJvbShPYmplY3Qua2V5cyhvMSkpO1xuICAgICAgICAgICAgICAgIGxldCBrMiA9IEFycmF5LmZyb20oT2JqZWN0LmtleXMobzIpKTtcbiAgICAgICAgICAgICAgICBrMS5zb3J0KCk7XG4gICAgICAgICAgICAgICAgazIuc29ydCgpO1xuXG4gICAgICAgICAgICAgICAgbGV0IGtleUNvbXBhcmUgPSBjb21wYXJlVmFsdWUoazEsIGsyKTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5Q29tcGFyZSAhPSAwKSByZXR1cm4ga2V5Q29tcGFyZTtcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGtleSBvZiBrMSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29tcCA9IGNvbXBhcmVWYWx1ZShvMVtrZXldLCBvMltrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXAgIT0gMCkgcmV0dXJuIGNvbXA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICBjYXNlIFwid2lkZ2V0XCI6XG4gICAgICAgICAgICBjYXNlIFwiaHRtbFwiOlxuICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogRmluZCB0aGUgY29ycmVzcG9uZGluZyBEYXRhdmVpdyB0eXBlIGZvciBhbiBhcmJpdHJhcnkgdmFsdWUuICovXG4gICAgZXhwb3J0IGZ1bmN0aW9uIHR5cGVPZih2YWw6IGFueSk6IExpdGVyYWxUeXBlIHwgdW5kZWZpbmVkIHtcbiAgICAgICAgcmV0dXJuIHdyYXBWYWx1ZSh2YWwpPy50eXBlO1xuICAgIH1cblxuICAgIC8qKiBEZXRlcm1pbmUgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIFwidHJ1dGh5XCIgKGkuZS4sIGlzIG5vbi1udWxsIGFuZCBoYXMgZGF0YSBpbiBpdCkuICovXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGlzVHJ1dGh5KGZpZWxkOiBMaXRlcmFsKTogYm9vbGVhbiB7XG4gICAgICAgIGxldCB3cmFwcGVkID0gd3JhcFZhbHVlKGZpZWxkKTtcbiAgICAgICAgaWYgKCF3cmFwcGVkKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgc3dpdGNoICh3cmFwcGVkLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZC52YWx1ZSAhPSAwO1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkLnZhbHVlLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkLnZhbHVlO1xuICAgICAgICAgICAgY2FzZSBcImxpbmtcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gISF3cmFwcGVkLnZhbHVlLnBhdGg7XG4gICAgICAgICAgICBjYXNlIFwiZGF0ZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkLnZhbHVlLnRvTWlsbGlzKCkgIT0gMDtcbiAgICAgICAgICAgIGNhc2UgXCJkdXJhdGlvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkLnZhbHVlLmFzKFwic2Vjb25kc1wiKSAhPSAwO1xuICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh3cmFwcGVkLnZhbHVlKS5sZW5ndGggPiAwO1xuICAgICAgICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWQudmFsdWUubGVuZ3RoID4gMDtcbiAgICAgICAgICAgIGNhc2UgXCJudWxsXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY2FzZSBcImh0bWxcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ3aWRnZXRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIERlZXAgY29weSBhIGZpZWxkLiAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiBkZWVwQ29weTxUIGV4dGVuZHMgTGl0ZXJhbD4oZmllbGQ6IFQpOiBUIHtcbiAgICAgICAgaWYgKGZpZWxkID09PSBudWxsIHx8IGZpZWxkID09PSB1bmRlZmluZWQpIHJldHVybiBmaWVsZDtcblxuICAgICAgICBpZiAoVmFsdWVzLmlzQXJyYXkoZmllbGQpKSB7XG4gICAgICAgICAgICByZXR1cm4gKFtdIGFzIExpdGVyYWxbXSkuY29uY2F0KGZpZWxkLm1hcCh2ID0+IGRlZXBDb3B5KHYpKSkgYXMgVDtcbiAgICAgICAgfSBlbHNlIGlmIChWYWx1ZXMuaXNPYmplY3QoZmllbGQpKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0OiBSZWNvcmQ8c3RyaW5nLCBMaXRlcmFsPiA9IHt9O1xuICAgICAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGZpZWxkKSkgcmVzdWx0W2tleV0gPSBkZWVwQ29weSh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0IGFzIFQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmllbGQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gaXNTdHJpbmcodmFsOiBhbnkpOiB2YWwgaXMgc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWwgPT0gXCJzdHJpbmdcIjtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gaXNOdW1iZXIodmFsOiBhbnkpOiB2YWwgaXMgbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWwgPT0gXCJudW1iZXJcIjtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gaXNEYXRlKHZhbDogYW55KTogdmFsIGlzIERhdGVUaW1lIHtcbiAgICAgICAgcmV0dXJuIHZhbCBpbnN0YW5jZW9mIERhdGVUaW1lO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBpc0R1cmF0aW9uKHZhbDogYW55KTogdmFsIGlzIER1cmF0aW9uIHtcbiAgICAgICAgcmV0dXJuIHZhbCBpbnN0YW5jZW9mIER1cmF0aW9uO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBpc051bGwodmFsOiBhbnkpOiB2YWwgaXMgbnVsbCB8IHVuZGVmaW5lZCB7XG4gICAgICAgIHJldHVybiB2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXkodmFsOiBhbnkpOiB2YWwgaXMgYW55W10ge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWwpO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBpc0Jvb2xlYW4odmFsOiBhbnkpOiB2YWwgaXMgYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsID09PSBcImJvb2xlYW5cIjtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gaXNMaW5rKHZhbDogYW55KTogdmFsIGlzIExpbmsge1xuICAgICAgICByZXR1cm4gdmFsIGluc3RhbmNlb2YgTGluaztcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gaXNXaWRnZXQodmFsOiBhbnkpOiB2YWwgaXMgV2lkZ2V0IHtcbiAgICAgICAgcmV0dXJuIHZhbCBpbnN0YW5jZW9mIFdpZGdldDtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gaXNIdG1sKHZhbDogYW55KTogdmFsIGlzIEhUTUxFbGVtZW50IHtcbiAgICAgICAgaWYgKHR5cGVvZiBIVE1MRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gb2JqZWN0IChhbmQgbm90IGFueSBvdGhlciBkYXRhdmlldy1yZWNvZ25pemVkIG9iamVjdC1saWtlIHR5cGUpLiAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiBpc09iamVjdCh2YWw6IGFueSk6IHZhbCBpcyBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHR5cGVvZiB2YWwgPT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgIWlzSHRtbCh2YWwpICYmXG4gICAgICAgICAgICAhaXNXaWRnZXQodmFsKSAmJlxuICAgICAgICAgICAgIWlzQXJyYXkodmFsKSAmJlxuICAgICAgICAgICAgIWlzRHVyYXRpb24odmFsKSAmJlxuICAgICAgICAgICAgIWlzRGF0ZSh2YWwpICYmXG4gICAgICAgICAgICAhaXNMaW5rKHZhbCkgJiZcbiAgICAgICAgICAgIHZhbCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAhaXNOdWxsKHZhbClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWw6IGFueSk6IHZhbCBpcyBGdW5jdGlvbiB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsID09IFwiZnVuY3Rpb25cIjtcbiAgICB9XG59XG5cbi8vLy8vLy8vLy8vLy8vL1xuLy8gR3JvdXBpbmdzIC8vXG4vLy8vLy8vLy8vLy8vLy9cblxuZXhwb3J0IG5hbWVzcGFjZSBHcm91cGluZ3Mge1xuICAgIC8qKiBEZXRlcm1pbmVzIGlmIHRoZSBnaXZlbiBncm91cCBlbnRyeSBpcyBhIHN0YW5kYWxvbmUgdmFsdWUsIG9yIGEgZ3JvdXBpbmcgb2Ygc3ViLWVudHJpZXMuICovXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGlzRWxlbWVudEdyb3VwPFQ+KGVudHJ5OiBUIHwgR3JvdXBFbGVtZW50PFQ+KTogZW50cnkgaXMgR3JvdXBFbGVtZW50PFQ+IHtcbiAgICAgICAgcmV0dXJuIFZhbHVlcy5pc09iamVjdChlbnRyeSkgJiYgT2JqZWN0LmtleXMoZW50cnkpLmxlbmd0aCA9PSAyICYmIFwia2V5XCIgaW4gZW50cnkgJiYgXCJyb3dzXCIgaW4gZW50cnk7XG4gICAgfVxuXG4gICAgLyoqIERldGVybWluZXMgaWYgdGhlIGdpdmVuIGFycmF5IGlzIGEgZ3JvdXBpbmcgYXJyYXkuICovXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGlzR3JvdXBpbmc8VD4oZW50cnk6IEdyb3VwaW5nPFQ+KTogZW50cnkgaXMgR3JvdXBFbGVtZW50PFQ+W10ge1xuICAgICAgICBmb3IgKGxldCBlbGVtZW50IG9mIGVudHJ5KSBpZiAoIWlzRWxlbWVudEdyb3VwKGVsZW1lbnQpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqIENvdW50IHRoZSB0b3RhbCBudW1iZXIgb2YgZWxlbWVudHMgaW4gYSByZWN1cnNpdmUgZ3JvdXBpbmcuICovXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGNvdW50PFQ+KGVsZW1lbnRzOiBHcm91cGluZzxUPik6IG51bWJlciB7XG4gICAgICAgIGlmIChpc0dyb3VwaW5nKGVsZW1lbnRzKSkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBzdWJncm91cCBvZiBlbGVtZW50cykgcmVzdWx0ICs9IGNvdW50KHN1Ymdyb3VwLnJvd3MpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50cy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vLy8vLy8vLy9cbi8vIExJTksgLy9cbi8vLy8vLy8vLy9cblxuLyoqIFRoZSBPYnNpZGlhbiAnbGluaycsIHVzZWQgZm9yIHVuaXF1ZWx5IGRlc2NyaWJpbmcgYSBmaWxlLCBoZWFkZXIsIG9yIGJsb2NrLiAqL1xuZXhwb3J0IGNsYXNzIExpbmsge1xuICAgIC8qKiBUaGUgZmlsZSBwYXRoIHRoaXMgbGluayBwb2ludHMgdG8uICovXG4gICAgcHVibGljIHBhdGg6IHN0cmluZztcbiAgICAvKiogVGhlIGRpc3BsYXkgbmFtZSBhc3NvY2lhdGVkIHdpdGggdGhlIGxpbmsuICovXG4gICAgcHVibGljIGRpc3BsYXk/OiBzdHJpbmc7XG4gICAgLyoqIFRoZSBibG9jayBJRCBvciBoZWFkZXIgdGhpcyBsaW5rIHBvaW50cyB0byB3aXRoaW4gYSBmaWxlLCBpZiByZWxldmFudC4gKi9cbiAgICBwdWJsaWMgc3VicGF0aD86IHN0cmluZztcbiAgICAvKiogSXMgdGhpcyBsaW5rIGFuIGVtYmVkZGVkIGxpbmsgKCEpPyAqL1xuICAgIHB1YmxpYyBlbWJlZDogYm9vbGVhbjtcbiAgICAvKiogVGhlIHR5cGUgb2YgdGhpcyBsaW5rLCB3aGljaCBkZXRlcm1pbmVzIHdoYXQgJ3N1YnBhdGgnIHJlZmVycyB0bywgaWYgYW55dGhpbmcuICovXG4gICAgcHVibGljIHR5cGU6IFwiZmlsZVwiIHwgXCJoZWFkZXJcIiB8IFwiYmxvY2tcIjtcblxuICAgIC8qKiBDcmVhdGUgYSBsaW5rIHRvIGEgc3BlY2lmaWMgZmlsZS4gKi9cbiAgICBwdWJsaWMgc3RhdGljIGZpbGUocGF0aDogc3RyaW5nLCBlbWJlZDogYm9vbGVhbiA9IGZhbHNlLCBkaXNwbGF5Pzogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGluayh7XG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgZW1iZWQsXG4gICAgICAgICAgICBkaXNwbGF5LFxuICAgICAgICAgICAgc3VicGF0aDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgaW5mZXIobGlua3BhdGg6IHN0cmluZywgZW1iZWQ6IGJvb2xlYW4gPSBmYWxzZSwgZGlzcGxheT86IHN0cmluZykge1xuICAgICAgICBpZiAobGlua3BhdGguaW5jbHVkZXMoXCIjXlwiKSkge1xuICAgICAgICAgICAgbGV0IHNwbGl0ID0gbGlua3BhdGguc3BsaXQoXCIjXlwiKTtcbiAgICAgICAgICAgIHJldHVybiBMaW5rLmJsb2NrKHNwbGl0WzBdLCBzcGxpdFsxXSwgZW1iZWQsIGRpc3BsYXkpO1xuICAgICAgICB9IGVsc2UgaWYgKGxpbmtwYXRoLmluY2x1ZGVzKFwiI1wiKSkge1xuICAgICAgICAgICAgbGV0IHNwbGl0ID0gbGlua3BhdGguc3BsaXQoXCIjXCIpO1xuICAgICAgICAgICAgcmV0dXJuIExpbmsuaGVhZGVyKHNwbGl0WzBdLCBzcGxpdFsxXSwgZW1iZWQsIGRpc3BsYXkpO1xuICAgICAgICB9IGVsc2UgcmV0dXJuIExpbmsuZmlsZShsaW5rcGF0aCwgZW1iZWQsIGRpc3BsYXkpO1xuICAgIH1cblxuICAgIC8qKiBDcmVhdGUgYSBsaW5rIHRvIGEgc3BlY2lmaWMgZmlsZSBhbmQgaGVhZGVyIGluIHRoYXQgZmlsZS4gKi9cbiAgICBwdWJsaWMgc3RhdGljIGhlYWRlcihwYXRoOiBzdHJpbmcsIGhlYWRlcjogc3RyaW5nLCBlbWJlZD86IGJvb2xlYW4sIGRpc3BsYXk/OiBzdHJpbmcpIHtcbiAgICAgICAgLy8gSGVhZGVycyBuZWVkIHRvIGJlIG5vcm1hbGl6ZWQgdG8gYWxwaGEtbnVtZXJpYyAmIHdpdGggZXh0cmEgc3BhY2luZyByZW1vdmVkLlxuICAgICAgICByZXR1cm4gbmV3IExpbmsoe1xuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIGVtYmVkLFxuICAgICAgICAgICAgZGlzcGxheSxcbiAgICAgICAgICAgIHN1YnBhdGg6IG5vcm1hbGl6ZUhlYWRlckZvckxpbmsoaGVhZGVyKSxcbiAgICAgICAgICAgIHR5cGU6IFwiaGVhZGVyXCIsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKiBDcmVhdGUgYSBsaW5rIHRvIGEgc3BlY2lmaWMgZmlsZSBhbmQgYmxvY2sgaW4gdGhhdCBmaWxlLiAqL1xuICAgIHB1YmxpYyBzdGF0aWMgYmxvY2socGF0aDogc3RyaW5nLCBibG9ja0lkOiBzdHJpbmcsIGVtYmVkPzogYm9vbGVhbiwgZGlzcGxheT86IHN0cmluZykge1xuICAgICAgICByZXR1cm4gbmV3IExpbmsoe1xuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIGVtYmVkLFxuICAgICAgICAgICAgZGlzcGxheSxcbiAgICAgICAgICAgIHN1YnBhdGg6IGJsb2NrSWQsXG4gICAgICAgICAgICB0eXBlOiBcImJsb2NrXCIsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgZnJvbU9iamVjdChvYmplY3Q6IFJlY29yZDxzdHJpbmcsIGFueT4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5rKG9iamVjdCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihmaWVsZHM6IFBhcnRpYWw8TGluaz4pIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBmaWVsZHMpO1xuICAgIH1cblxuICAgIC8qKiBDaGVja3MgZm9yIGxpbmsgZXF1YWxpdHkgKGkuZS4sIHRoYXQgdGhlIGxpbmtzIGFyZSBwb2ludGluZyB0byB0aGUgc2FtZSBleGFjdCBsb2NhdGlvbikuICovXG4gICAgcHVibGljIGVxdWFscyhvdGhlcjogTGluayk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAob3RoZXIgPT0gdW5kZWZpbmVkIHx8IG90aGVyID09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICAgICAgICByZXR1cm4gdGhpcy5wYXRoID09IG90aGVyLnBhdGggJiYgdGhpcy50eXBlID09IG90aGVyLnR5cGUgJiYgdGhpcy5zdWJwYXRoID09IG90aGVyLnN1YnBhdGg7XG4gICAgfVxuXG4gICAgLyoqIENvbnZlcnQgdGhpcyBsaW5rIHRvIGl0J3MgbWFya2Rvd24gcmVwcmVzZW50YXRpb24uICovXG4gICAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcmtkb3duKCk7XG4gICAgfVxuXG4gICAgLyoqIENvbnZlcnQgdGhpcyBsaW5rIHRvIGEgcmF3IG9iamVjdCB3aGljaCBpcyBzZXJpYWxpemF0aW9uLWZyaWVuZGx5LiAqL1xuICAgIHB1YmxpYyB0b09iamVjdCgpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgICAgICAgcmV0dXJuIHsgcGF0aDogdGhpcy5wYXRoLCB0eXBlOiB0aGlzLnR5cGUsIHN1YnBhdGg6IHRoaXMuc3VicGF0aCwgZGlzcGxheTogdGhpcy5kaXNwbGF5LCBlbWJlZDogdGhpcy5lbWJlZCB9O1xuICAgIH1cblxuICAgIC8qKiBVcGRhdGUgdGhpcyBsaW5rIHdpdGggYSBuZXcgcGF0aC4gKi9cbiAgICAvL0B0cy1pZ25vcmU7IGVycm9yIGFwcGVhcmVkIGFmdGVyIHVwZGF0aW5nIE9ic2lkaWFuIHRvIDAuMTUuNDsgaXQgYWxzbyB1cGRhdGVkIG90aGVyIHBhY2thZ2VzIGJ1dCBkaWRuJ3Qgc2F5IHdoaWNoXG4gICAgcHVibGljIHdpdGhQYXRoKHBhdGg6IHN0cmluZykge1xuICAgICAgICByZXR1cm4gbmV3IExpbmsoT2JqZWN0LmFzc2lnbih7fSwgdGhpcywgeyBwYXRoIH0pKTtcbiAgICB9XG5cbiAgICAvKiogUmV0dXJuIGEgbmV3IGxpbmsgd2hpY2ggcG9pbnRzIHRvIHRoZSBzYW1lIGxvY2F0aW9uIGJ1dCB3aXRoIGEgbmV3IGRpc3BsYXkgdmFsdWUuICovXG4gICAgcHVibGljIHdpdGhEaXNwbGF5KGRpc3BsYXk/OiBzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5rKE9iamVjdC5hc3NpZ24oe30sIHRoaXMsIHsgZGlzcGxheSB9KSk7XG4gICAgfVxuXG4gICAgLyoqIENvbnZlcnQgYSBmaWxlIGxpbmsgaW50byBhIGxpbmsgdG8gYSBzcGVjaWZpYyBoZWFkZXIuICovXG4gICAgcHVibGljIHdpdGhIZWFkZXIoaGVhZGVyOiBzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIExpbmsuaGVhZGVyKHRoaXMucGF0aCwgaGVhZGVyLCB0aGlzLmVtYmVkLCB0aGlzLmRpc3BsYXkpO1xuICAgIH1cblxuICAgIC8qKiBDb252ZXJ0IGFueSBsaW5rIGludG8gYSBsaW5rIHRvIGl0cyBmaWxlLiAqL1xuICAgIHB1YmxpYyB0b0ZpbGUoKSB7XG4gICAgICAgIHJldHVybiBMaW5rLmZpbGUodGhpcy5wYXRoLCB0aGlzLmVtYmVkLCB0aGlzLmRpc3BsYXkpO1xuICAgIH1cblxuICAgIC8qKiBDb252ZXJ0IHRoaXMgbGluayBpbnRvIGFuIGVtYmVkZGVkIGxpbmsuICovXG4gICAgcHVibGljIHRvRW1iZWQoKTogTGluayB7XG4gICAgICAgIGlmICh0aGlzLmVtYmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBsaW5rID0gbmV3IExpbmsodGhpcyk7XG4gICAgICAgICAgICBsaW5rLmVtYmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBsaW5rO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIENvbnZlcnQgdGhpcyBsaW5rIGludG8gYSBub24tZW1iZWRkZWQgbGluay4gKi9cbiAgICBwdWJsaWMgZnJvbUVtYmVkKCk6IExpbmsge1xuICAgICAgICBpZiAoIXRoaXMuZW1iZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGxpbmsgPSBuZXcgTGluayh0aGlzKTtcbiAgICAgICAgICAgIGxpbmsuZW1iZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBsaW5rO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIENvbnZlcnQgdGhpcyBsaW5rIHRvIG1hcmtkb3duIHNvIGl0IGNhbiBiZSByZW5kZXJlZC4gKi9cbiAgICBwdWJsaWMgbWFya2Rvd24oKTogc3RyaW5nIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9ICh0aGlzLmVtYmVkID8gXCIhXCIgOiBcIlwiKSArIFwiW1tcIiArIHRoaXMub2JzaWRpYW5MaW5rKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuZGlzcGxheSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwifFwiICsgdGhpcy5kaXNwbGF5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwifFwiICsgZ2V0RmlsZVRpdGxlKHRoaXMucGF0aCk7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09IFwiaGVhZGVyXCIgfHwgdGhpcy50eXBlID09IFwiYmxvY2tcIikgcmVzdWx0ICs9IFwiID4gXCIgKyB0aGlzLnN1YnBhdGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgKz0gXCJdXVwiO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKiBDb252ZXJ0IHRoZSBpbm5lciBwYXJ0IG9mIHRoZSBsaW5rIHRvIHNvbWV0aGluZyB0aGF0IE9ic2lkaWFuIGNhbiBvcGVuIC8gdW5kZXJzdGFuZC4gKi9cbiAgICBwdWJsaWMgb2JzaWRpYW5MaW5rKCk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IGVzY2FwZWQgPSB0aGlzLnBhdGgucmVwbGFjZUFsbChcInxcIiwgXCJcXFxcfFwiKTtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PSBcImhlYWRlclwiKSByZXR1cm4gZXNjYXBlZCArIFwiI1wiICsgdGhpcy5zdWJwYXRoPy5yZXBsYWNlQWxsKFwifFwiLCBcIlxcXFx8XCIpO1xuICAgICAgICBpZiAodGhpcy50eXBlID09IFwiYmxvY2tcIikgcmV0dXJuIGVzY2FwZWQgKyBcIiNeXCIgKyB0aGlzLnN1YnBhdGg/LnJlcGxhY2VBbGwoXCJ8XCIsIFwiXFxcXHxcIik7XG4gICAgICAgIGVsc2UgcmV0dXJuIGVzY2FwZWQ7XG4gICAgfVxuXG4gICAgLyoqIFRoZSBzdHJpcHBlZCBuYW1lIG9mIHRoZSBmaWxlIHRoaXMgbGluayBwb2ludHMgdG8uICovXG4gICAgcHVibGljIGZpbGVOYW1lKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBnZXRGaWxlVGl0bGUodGhpcy5wYXRoKS5yZXBsYWNlKFwiLm1kXCIsIFwiXCIpO1xuICAgIH1cbn1cblxuLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdJREdFVCBCQVNFIC8vXG4vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEEgdHJpdmlhbCBiYXNlIGNsYXNzIHdoaWNoIGp1c3QgZGVmaW5lcyB0aGUgJyR3aWRnZXQnIGlkZW50aWZpZXIgdHlwZS4gU3VidHlwZXMgb2ZcbiAqIHdpZGdldCBhcmUgcmVzcG9uc2libGUgZm9yIGFkZGluZyB3aGF0ZXZlciBtZXRhZGF0YSBpcyByZWxldmFudC4gSWYgeW91IHdhbnQgeW91ciB3aWRnZXRcbiAqIHRvIGhhdmUgcmVuZGVyaW5nIGZ1bmN0aW9uYWxpdHkgKHdoaWNoIHlvdSBwcm9iYWJseSBkbyksIHlvdSBzaG91bGQgZXh0ZW5kIGBSZW5kZXJXaWRnZXRgLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgV2lkZ2V0IHtcbiAgICBwdWJsaWMgY29uc3RydWN0b3IocHVibGljICR3aWRnZXQ6IHN0cmluZykge31cblxuICAgIC8qKlxuICAgICAqIEF0dGVtcHQgdG8gcmVuZGVyIHRoaXMgd2lkZ2V0IGluIG1hcmtkb3duLCBpZiBwb3NzaWJsZTsgaWYgbWFya2Rvd24gaXMgbm90IHBvc3NpYmxlLFxuICAgICAqIHRoZW4gdGhpcyB3aWxsIGF0dGVtcHQgdG8gcmVuZGVyIGFzIEhUTUwuIE5vdGUgdGhhdCBtYW55IHdpZGdldHMgaGF2ZSBpbnRlcmFjdGl2ZVxuICAgICAqIGNvbXBvbmVudHMgb3IgZGlmZmljdWx0IGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhbmQgdGhlIGBtYXJrZG93bmAgZnVuY3Rpb24gY2FuIHNpbXBseVxuICAgICAqIHJldHVybiBhIHBsYWNlaG9sZGVyIGluIHRoaXMgY2FzZSAoc3VjaCBhcyBgPGZ1bmN0aW9uPmAgb3IgYDx0YXNrLWxpc3Q+YCkuXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IG1hcmtkb3duKCk6IHN0cmluZztcbn1cblxuLyoqIEEgdHJpdmlhbCB3aWRnZXQgd2hpY2ggcmVuZGVycyBhIChrZXksIHZhbHVlKSBwYWlyLCBhbmQgYWxsb3dzIGFjY2Vzc2luZyB0aGUga2V5IGFuZCB2YWx1ZS4gKi9cbmV4cG9ydCBjbGFzcyBMaXN0UGFpcldpZGdldCBleHRlbmRzIFdpZGdldCB7XG4gICAgcHVibGljIGNvbnN0cnVjdG9yKHB1YmxpYyBrZXk6IExpdGVyYWwsIHB1YmxpYyB2YWx1ZTogTGl0ZXJhbCkge1xuICAgICAgICBzdXBlcihcImRhdGF2aWV3Omxpc3QtcGFpclwiKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb3ZlcnJpZGUgbWFya2Rvd24oKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIGAke1ZhbHVlcy50b1N0cmluZyh0aGlzLmtleSl9OiAke1ZhbHVlcy50b1N0cmluZyh0aGlzLnZhbHVlKX1gO1xuICAgIH1cbn1cblxuLyoqIEEgc2ltcGxlIHdpZGdldCB3aGljaCByZW5kZXJzIGFuIGV4dGVybmFsIGxpbmsuICovXG5leHBvcnQgY2xhc3MgRXh0ZXJuYWxMaW5rV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0IHtcbiAgICBwdWJsaWMgY29uc3RydWN0b3IocHVibGljIHVybDogc3RyaW5nLCBwdWJsaWMgZGlzcGxheT86IHN0cmluZykge1xuICAgICAgICBzdXBlcihcImRhdGF2aWV3OmV4dGVybmFsLWxpbmtcIik7XG4gICAgfVxuXG4gICAgcHVibGljIG92ZXJyaWRlIG1hcmtkb3duKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBgWyR7dGhpcy5kaXNwbGF5ID8/IHRoaXMudXJsfV0oJHt0aGlzLnVybH0pYDtcbiAgICB9XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgV2lkZ2V0cyB7XG4gICAgLyoqIENyZWF0ZSBhIGxpc3QgcGFpciB3aWRnZXQgbWF0Y2hpbmcgdGhlIGdpdmVuIGtleSBhbmQgdmFsdWUuICovXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGxpc3RQYWlyKGtleTogTGl0ZXJhbCwgdmFsdWU6IExpdGVyYWwpOiBMaXN0UGFpcldpZGdldCB7XG4gICAgICAgIHJldHVybiBuZXcgTGlzdFBhaXJXaWRnZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqIENyZWF0ZSBhbiBleHRlcm5hbCBsaW5rIHdpZGdldCB3aGljaCByZW5kZXJzIGFuIGV4dGVybmFsIE9ic2lkaWFuIGxpbmsuICovXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGV4dGVybmFsTGluayh1cmw6IHN0cmluZywgZGlzcGxheT86IHN0cmluZyk6IEV4dGVybmFsTGlua1dpZGdldCB7XG4gICAgICAgIHJldHVybiBuZXcgRXh0ZXJuYWxMaW5rV2lkZ2V0KHVybCwgZGlzcGxheSk7XG4gICAgfVxuXG4gICAgLyoqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gd2lkZ2V0IGlzIGEgbGlzdCBwYWlyIHdpZGdldC4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gaXNMaXN0UGFpcih3aWRnZXQ6IFdpZGdldCk6IHdpZGdldCBpcyBMaXN0UGFpcldpZGdldCB7XG4gICAgICAgIHJldHVybiB3aWRnZXQuJHdpZGdldCA9PT0gXCJkYXRhdmlldzpsaXN0LXBhaXJcIjtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gaXNFeHRlcm5hbExpbmsod2lkZ2V0OiBXaWRnZXQpOiB3aWRnZXQgaXMgRXh0ZXJuYWxMaW5rV2lkZ2V0IHtcbiAgICAgICAgcmV0dXJuIHdpZGdldC4kd2lkZ2V0ID09PSBcImRhdGF2aWV3OmV4dGVybmFsLWxpbmtcIjtcbiAgICB9XG5cbiAgICAvKiogRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gd2lkZ2V0IGlzIGFueSBraW5kIG9mIGJ1aWx0LWluIHdpZGdldCB3aXRoIHNwZWNpYWwgcmVuZGVyaW5nIGhhbmRsaW5nLiAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiBpc0J1aWx0aW4od2lkZ2V0OiBXaWRnZXQpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGlzTGlzdFBhaXIod2lkZ2V0KSB8fCBpc0V4dGVybmFsTGluayh3aWRnZXQpO1xuICAgIH1cbn1cbiIsICIvKiogRGVmaW5lcyB0aGUgQVNUIGZvciBhIGZpZWxkIHdoaWNoIGNhbiBiZSBldmFsdWF0ZWQuICovXG5pbXBvcnQgeyBMaXRlcmFsIH0gZnJvbSBcImRhdGEtbW9kZWwvdmFsdWVcIjtcblxuLyoqIENvbXBhcmlzb24gb3BlcmF0b3JzIHdoaWNoIHlpZWxkIHRydWUvZmFsc2UuICovXG5leHBvcnQgdHlwZSBDb21wYXJlT3AgPSBcIj5cIiB8IFwiPj1cIiB8IFwiPD1cIiB8IFwiPFwiIHwgXCI9XCIgfCBcIiE9XCI7XG4vKiogQXJpdGhtZXRpYyBvcGVyYXRvcnMgd2hpY2ggeWllbGQgbnVtYmVycyBhbmQgb3RoZXIgdmFsdWVzLiAqL1xuZXhwb3J0IHR5cGUgQXJpdGhtZXRpY09wID0gXCIrXCIgfCBcIi1cIiB8IFwiKlwiIHwgXCIvXCIgfCBcIiVcIiB8IFwiJlwiIHwgXCJ8XCI7XG4vKiogQWxsIHZhbGlkIGJpbmFyeSBvcGVyYXRvcnMuICovXG5leHBvcnQgdHlwZSBCaW5hcnlPcCA9IENvbXBhcmVPcCB8IEFyaXRobWV0aWNPcDtcbi8qKiBBIChwb3RlbnRpYWxseSBjb21wdXRlZCkgZmllbGQgdG8gc2VsZWN0IG9yIGNvbXBhcmUgYWdhaW5zdC4gKi9cbmV4cG9ydCB0eXBlIEZpZWxkID1cbiAgICB8IEJpbmFyeU9wRmllbGRcbiAgICB8IFZhcmlhYmxlRmllbGRcbiAgICB8IExpdGVyYWxGaWVsZFxuICAgIHwgRnVuY3Rpb25GaWVsZFxuICAgIHwgSW5kZXhGaWVsZFxuICAgIHwgTmVnYXRlZEZpZWxkXG4gICAgfCBMYW1iZGFGaWVsZFxuICAgIHwgT2JqZWN0RmllbGRcbiAgICB8IExpc3RGaWVsZDtcblxuLyoqIExpdGVyYWwgcmVwcmVzZW50YXRpb24gb2Ygc29tZSBmaWVsZCB0eXBlLiAqL1xuZXhwb3J0IGludGVyZmFjZSBMaXRlcmFsRmllbGQge1xuICAgIHR5cGU6IFwibGl0ZXJhbFwiO1xuICAgIHZhbHVlOiBMaXRlcmFsO1xufVxuXG4vKiogQSB2YXJpYWJsZSBmaWVsZCBmb3IgYSB2YXJpYWJsZSB3aXRoIGEgZ2l2ZW4gbmFtZS4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVmFyaWFibGVGaWVsZCB7XG4gICAgdHlwZTogXCJ2YXJpYWJsZVwiO1xuICAgIG5hbWU6IHN0cmluZztcbn1cblxuLyoqIEEgbGlzdCwgd2hpY2ggaXMgYW4gb3JkZXJlZCBjb2xsZWN0aW9uIG9mIGZpZWxkcy4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTGlzdEZpZWxkIHtcbiAgICB0eXBlOiBcImxpc3RcIjtcbiAgICB2YWx1ZXM6IEZpZWxkW107XG59XG5cbi8qKiBBbiBvYmplY3QsIHdoaWNoIGlzIGEgbWFwcGluZyBvZiBuYW1lIHRvIGZpZWxkLiAqL1xuZXhwb3J0IGludGVyZmFjZSBPYmplY3RGaWVsZCB7XG4gICAgdHlwZTogXCJvYmplY3RcIjtcbiAgICB2YWx1ZXM6IFJlY29yZDxzdHJpbmcsIEZpZWxkPjtcbn1cblxuLyoqIEEgYmluYXJ5IG9wZXJhdG9yIGZpZWxkIHdoaWNoIGNvbWJpbmVzIHR3byBzdWJub2RlcyBzb21laG93LiAqL1xuZXhwb3J0IGludGVyZmFjZSBCaW5hcnlPcEZpZWxkIHtcbiAgICB0eXBlOiBcImJpbmFyeW9wXCI7XG4gICAgbGVmdDogRmllbGQ7XG4gICAgcmlnaHQ6IEZpZWxkO1xuICAgIG9wOiBCaW5hcnlPcDtcbn1cblxuLyoqIEEgZnVuY3Rpb24gZmllbGQgd2hpY2ggY2FsbHMgYSBmdW5jdGlvbiBvbiAwIG9yIG1vcmUgYXJndW1lbnRzLiAqL1xuZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvbkZpZWxkIHtcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCI7XG4gICAgLyoqIEVpdGhlciB0aGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24gYmVpbmcgY2FsbGVkLCBvciBhIEZ1bmN0aW9uIG9iamVjdC4gKi9cbiAgICBmdW5jOiBGaWVsZDtcbiAgICAvKiogVGhlIGFyZ3VtZW50cyBiZWluZyBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uLiAqL1xuICAgIGFyZ3VtZW50czogRmllbGRbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMYW1iZGFGaWVsZCB7XG4gICAgdHlwZTogXCJsYW1iZGFcIjtcbiAgICAvKiogQW4gb3JkZXJlZCBsaXN0IG9mIG5hbWVkIGFyZ3VtZW50cy4gKi9cbiAgICBhcmd1bWVudHM6IHN0cmluZ1tdO1xuICAgIC8qKiBUaGUgZmllbGQgd2hpY2ggc2hvdWxkIGJlIGV2YWx1YXRlZCB3aXRoIHRoZSBhcmd1bWVudHMgaW4gY29udGV4dC4gKi9cbiAgICB2YWx1ZTogRmllbGQ7XG59XG5cbi8qKiBBIGZpZWxkIHdoaWNoIGluZGV4ZXMgYSB2YXJpYWJsZSBpbnRvIGFub3RoZXIgdmFyaWFibGUuICovXG5leHBvcnQgaW50ZXJmYWNlIEluZGV4RmllbGQge1xuICAgIHR5cGU6IFwiaW5kZXhcIjtcbiAgICAvKiogVGhlIGZpZWxkIHRvIGluZGV4IGludG8uICovXG4gICAgb2JqZWN0OiBGaWVsZDtcbiAgICAvKiogVGhlIGluZGV4LiAqL1xuICAgIGluZGV4OiBGaWVsZDtcbn1cblxuLyoqIEEgZmllbGQgd2hpY2ggbmVnYXRlcyB0aGUgdmFsdWUgb2YgdGhlIG9yaWdpbmFsIGZpZWxkLiAqL1xuZXhwb3J0IGludGVyZmFjZSBOZWdhdGVkRmllbGQge1xuICAgIHR5cGU6IFwibmVnYXRlZFwiO1xuICAgIC8qKiBUaGUgY2hpbGQgZmllbGQgdG8gbmVnYXRlZC4gKi9cbiAgICBjaGlsZDogRmllbGQ7XG59XG5cbi8qKiBVdGlsaXR5IG1ldGhvZHMgZm9yIGNyZWF0aW5nICYgY29tcGFyaW5nIGZpZWxkcy4gKi9cbmV4cG9ydCBuYW1lc3BhY2UgRmllbGRzIHtcbiAgICBleHBvcnQgZnVuY3Rpb24gdmFyaWFibGUobmFtZTogc3RyaW5nKTogVmFyaWFibGVGaWVsZCB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwidmFyaWFibGVcIiwgbmFtZSB9O1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBsaXRlcmFsKHZhbHVlOiBMaXRlcmFsKTogTGl0ZXJhbEZpZWxkIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlIH07XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGJpbmFyeU9wKGxlZnQ6IEZpZWxkLCBvcDogQmluYXJ5T3AsIHJpZ2h0OiBGaWVsZCk6IEZpZWxkIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJiaW5hcnlvcFwiLCBsZWZ0LCBvcCwgcmlnaHQgfSBhcyBCaW5hcnlPcEZpZWxkO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBpbmRleChvYmo6IEZpZWxkLCBpbmRleDogRmllbGQpOiBJbmRleEZpZWxkIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJpbmRleFwiLCBvYmplY3Q6IG9iaiwgaW5kZXggfTtcbiAgICB9XG5cbiAgICAvKiogQ29udmVydHMgYSBzdHJpbmcgaW4gZG90LW5vdGF0aW9uLWZvcm1hdCBpbnRvIGEgdmFyaWFibGUgd2hpY2ggaW5kZXhlcy4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gaW5kZXhWYXJpYWJsZShuYW1lOiBzdHJpbmcpOiBGaWVsZCB7XG4gICAgICAgIGxldCBwYXJ0cyA9IG5hbWUuc3BsaXQoXCIuXCIpO1xuICAgICAgICBsZXQgcmVzdWx0OiBGaWVsZCA9IEZpZWxkcy52YXJpYWJsZShwYXJ0c1swXSk7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMTsgaW5kZXggPCBwYXJ0cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IEZpZWxkcy5pbmRleChyZXN1bHQsIEZpZWxkcy5saXRlcmFsKHBhcnRzW2luZGV4XSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gbGFtYmRhKGFyZ3M6IHN0cmluZ1tdLCB2YWx1ZTogRmllbGQpOiBMYW1iZGFGaWVsZCB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwibGFtYmRhXCIsIGFyZ3VtZW50czogYXJncywgdmFsdWUgfTtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gZnVuYyhmdW5jOiBGaWVsZCwgYXJnczogRmllbGRbXSk6IEZ1bmN0aW9uRmllbGQge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImZ1bmN0aW9uXCIsIGZ1bmMsIGFyZ3VtZW50czogYXJncyB9O1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBsaXN0KHZhbHVlczogRmllbGRbXSk6IExpc3RGaWVsZCB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwibGlzdFwiLCB2YWx1ZXMgfTtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gb2JqZWN0KHZhbHVlczogUmVjb3JkPHN0cmluZywgRmllbGQ+KTogT2JqZWN0RmllbGQge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcIm9iamVjdFwiLCB2YWx1ZXMgfTtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gbmVnYXRlKGNoaWxkOiBGaWVsZCk6IE5lZ2F0ZWRGaWVsZCB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwibmVnYXRlZFwiLCBjaGlsZCB9O1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBpc0NvbXBhcmVPcChvcDogQmluYXJ5T3ApOiBvcCBpcyBDb21wYXJlT3Age1xuICAgICAgICByZXR1cm4gb3AgPT0gXCI8PVwiIHx8IG9wID09IFwiPFwiIHx8IG9wID09IFwiPlwiIHx8IG9wID09IFwiPj1cIiB8fCBvcCA9PSBcIiE9XCIgfHwgb3AgPT0gXCI9XCI7XG4gICAgfVxuXG4gICAgZXhwb3J0IGNvbnN0IE5VTEwgPSBGaWVsZHMubGl0ZXJhbChudWxsKTtcbn1cbiIsICIvKiogQVNUIGltcGxlbWVudGF0aW9uIGZvciBxdWVyaWVzIG92ZXIgZGF0YSBzb3VyY2VzLiAqL1xuXG4vKiogVGhlIHNvdXJjZSBvZiBmaWxlcyBmb3IgYSBxdWVyeS4gKi9cbmV4cG9ydCB0eXBlIFNvdXJjZSA9IFRhZ1NvdXJjZSB8IENzdlNvdXJjZSB8IEZvbGRlclNvdXJjZSB8IExpbmtTb3VyY2UgfCBFbXB0eVNvdXJjZSB8IE5lZ2F0ZWRTb3VyY2UgfCBCaW5hcnlPcFNvdXJjZTtcbi8qKiBWYWxpZCBvcGVyYXRpb25zIGZvciBjb21iaW5pbmcgc291cmNlcy4gKi9cbmV4cG9ydCB0eXBlIFNvdXJjZU9wID0gXCImXCIgfCBcInxcIjtcblxuLyoqIEEgdGFnIGFzIGEgc291cmNlIG9mIGRhdGEuICovXG5leHBvcnQgaW50ZXJmYWNlIFRhZ1NvdXJjZSB7XG4gICAgdHlwZTogXCJ0YWdcIjtcbiAgICAvKiogVGhlIHRhZyB0byBzb3VyY2UgZnJvbS4gKi9cbiAgICB0YWc6IHN0cmluZztcbn1cblxuLyoqIEEgY3N2IGFzIGEgc291cmNlIG9mIGRhdGEuICovXG5leHBvcnQgaW50ZXJmYWNlIENzdlNvdXJjZSB7XG4gICAgdHlwZTogXCJjc3ZcIjtcbiAgICAvKiogVGhlIHBhdGggdG8gdGhlIENTViBmaWxlLiAqL1xuICAgIHBhdGg6IHN0cmluZztcbn1cblxuLyoqIEEgZm9sZGVyIHByZWZpeCBhcyBhIHNvdXJjZSBvZiBkYXRhLiAqL1xuZXhwb3J0IGludGVyZmFjZSBGb2xkZXJTb3VyY2Uge1xuICAgIHR5cGU6IFwiZm9sZGVyXCI7XG4gICAgLyoqIFRoZSBmb2xkZXIgcHJlZml4IHRvIHNvdXJjZSBmcm9tLiAqL1xuICAgIGZvbGRlcjogc3RyaW5nO1xufVxuXG4vKiogRWl0aGVyIGluY29taW5nIG9yIG91dGdvaW5nIGxpbmtzIHRvIGEgZ2l2ZW4gZmlsZS4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTGlua1NvdXJjZSB7XG4gICAgdHlwZTogXCJsaW5rXCI7XG4gICAgLyoqIFRoZSBmaWxlIHRvIGxvb2sgZm9yIGxpbmtzIHRvL2Zyb20uICAqL1xuICAgIGZpbGU6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBUaGUgZGlyZWN0aW9uIHRvIGxvb2sgLSBpZiBpbmNvbWluZywgdGhlbiBhbGwgZmlsZXMgbGlua2luZyB0byB0aGUgdGFyZ2V0IGZpbGUuIElmIG91dGdvaW5nLCB0aGVuIGFsbCBmaWxlc1xuICAgICAqIHdoaWNoIHRoZSBmaWxlIGxpbmtzIHRvLlxuICAgICAqL1xuICAgIGRpcmVjdGlvbjogXCJpbmNvbWluZ1wiIHwgXCJvdXRnb2luZ1wiO1xufVxuXG4vKiogQSBzb3VyY2Ugd2hpY2ggaXMgZXZlcnl0aGluZyBFWENFUFQgdGhlIGZpbGVzIHJldHVybmVkIGJ5IHRoZSBnaXZlbiBzb3VyY2UuICovXG5leHBvcnQgaW50ZXJmYWNlIE5lZ2F0ZWRTb3VyY2Uge1xuICAgIHR5cGU6IFwibmVnYXRlXCI7XG4gICAgLyoqIFRoZSBzb3VyY2UgdG8gbmVnYXRlLiAqL1xuICAgIGNoaWxkOiBTb3VyY2U7XG59XG5cbi8qKiBBIHNvdXJjZSB3aGljaCB5aWVsZHMgbm90aGluZy4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRW1wdHlTb3VyY2Uge1xuICAgIHR5cGU6IFwiZW1wdHlcIjtcbn1cblxuLyoqIEEgc291cmNlIG1hZGUgYnkgY29tYmluaW5nIHN1YnNvdXJjZXMgd2l0aCBhIGxvZ2ljYWwgb3BlcmF0b3JzLiAqL1xuZXhwb3J0IGludGVyZmFjZSBCaW5hcnlPcFNvdXJjZSB7XG4gICAgdHlwZTogXCJiaW5hcnlvcFwiO1xuICAgIG9wOiBTb3VyY2VPcDtcbiAgICBsZWZ0OiBTb3VyY2U7XG4gICAgcmlnaHQ6IFNvdXJjZTtcbn1cblxuLyoqIFV0aWxpdHkgZnVuY3Rpb25zIGZvciBjcmVhdGluZyBhbmQgbWFuaXB1bGF0aW5nIHNvdXJjZXMuICovXG5leHBvcnQgbmFtZXNwYWNlIFNvdXJjZXMge1xuICAgIC8qKiBDcmVhdGUgYSBzb3VyY2Ugd2hpY2ggc2VhcmNoZXMgZnJvbSBhIHRhZy4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gdGFnKHRhZzogc3RyaW5nKTogVGFnU291cmNlIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0YWdcIiwgdGFnIH07XG4gICAgfVxuXG4gICAgLyoqIENyZWF0ZSBhIHNvdXJjZSB3aGljaCBmZXRjaGVzIGZyb20gYSBDU1YgZmlsZS4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gY3N2KHBhdGg6IHN0cmluZyk6IENzdlNvdXJjZSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiY3N2XCIsIHBhdGggfTtcbiAgICB9XG5cbiAgICAvKiogQ3JlYXRlIGEgc291cmNlIHdoaWNoIHNlYXJjaGVzIGZvciBmaWxlcyB1bmRlciBhIGZvbGRlciBwcmVmaXguICovXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGZvbGRlcihwcmVmaXg6IHN0cmluZyk6IEZvbGRlclNvdXJjZSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiZm9sZGVyXCIsIGZvbGRlcjogcHJlZml4IH07XG4gICAgfVxuXG4gICAgLyoqIENyZWF0ZSBhIHNvdXJjZSB3aGljaCBzZWFyY2hlcyBmb3IgZmlsZXMgd2hpY2ggbGluayB0by9mcm9tIGEgZ2l2ZW4gZmlsZS4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gbGluayhmaWxlOiBzdHJpbmcsIGluY29taW5nOiBib29sZWFuKTogTGlua1NvdXJjZSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwibGlua1wiLCBmaWxlLCBkaXJlY3Rpb246IGluY29taW5nID8gXCJpbmNvbWluZ1wiIDogXCJvdXRnb2luZ1wiIH07XG4gICAgfVxuXG4gICAgLyoqIENyZWF0ZSBhIHNvdXJjZSB3aGljaCBqb2lucyB0d28gc291cmNlcyBieSBhIGxvZ2ljYWwgb3BlcmF0b3IgKGFuZC9vcikuICovXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGJpbmFyeU9wKGxlZnQ6IFNvdXJjZSwgb3A6IFNvdXJjZU9wLCByaWdodDogU291cmNlKTogU291cmNlIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJiaW5hcnlvcFwiLCBsZWZ0LCBvcCwgcmlnaHQgfTtcbiAgICB9XG5cbiAgICAvKiogQ3JlYXRlIGEgc291cmNlIHdoaWNoIHRha2VzIHRoZSBpbnRlcnNlY3Rpb24gb2YgdHdvIHNvdXJjZXMuICovXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGFuZChsZWZ0OiBTb3VyY2UsIHJpZ2h0OiBTb3VyY2UpOiBTb3VyY2Uge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImJpbmFyeW9wXCIsIGxlZnQsIG9wOiBcIiZcIiwgcmlnaHQgfTtcbiAgICB9XG5cbiAgICAvKiogQ3JlYXRlIGEgc291cmNlIHdoaWNoIHRha2VzIHRoZSB1bmlvbiBvZiB0d28gc291cmNlcy4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gb3IobGVmdDogU291cmNlLCByaWdodDogU291cmNlKTogU291cmNlIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJiaW5hcnlvcFwiLCBsZWZ0LCBvcDogXCJ8XCIsIHJpZ2h0IH07XG4gICAgfVxuXG4gICAgLyoqIENyZWF0ZSBhIHNvdXJjZSB3aGljaCBuZWdhdGVzIHRoZSB1bmRlcmx5aW5nIHNvdXJjZS4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gbmVnYXRlKGNoaWxkOiBTb3VyY2UpOiBOZWdhdGVkU291cmNlIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJuZWdhdGVcIiwgY2hpbGQgfTtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gZW1wdHkoKTogRW1wdHlTb3VyY2Uge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImVtcHR5XCIgfTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgRGF0ZVRpbWUsIER1cmF0aW9uIH0gZnJvbSBcImx1eG9uXCI7XG5pbXBvcnQgeyBMaXRlcmFsLCBMaW5rIH0gZnJvbSBcImRhdGEtbW9kZWwvdmFsdWVcIjtcbmltcG9ydCAqIGFzIFAgZnJvbSBcInBhcnNpbW1vblwiO1xuaW1wb3J0IHsgQmluYXJ5T3AsIEZpZWxkLCBGaWVsZHMsIExhbWJkYUZpZWxkLCBMaXN0RmllbGQsIExpdGVyYWxGaWVsZCwgT2JqZWN0RmllbGQsIFZhcmlhYmxlRmllbGQgfSBmcm9tIFwiLi9maWVsZFwiO1xuaW1wb3J0IHsgRm9sZGVyU291cmNlLCBOZWdhdGVkU291cmNlLCBTb3VyY2UsIFNvdXJjZU9wLCBTb3VyY2VzLCBUYWdTb3VyY2UsIENzdlNvdXJjZSB9IGZyb20gXCJkYXRhLWluZGV4L3NvdXJjZVwiO1xuaW1wb3J0IHsgbm9ybWFsaXplRHVyYXRpb24gfSBmcm9tIFwidXRpbC9ub3JtYWxpemVcIjtcbmltcG9ydCB7IFJlc3VsdCB9IGZyb20gXCJhcGkvcmVzdWx0XCI7XG5pbXBvcnQgZW1vamlSZWdleCBmcm9tIFwiZW1vamktcmVnZXhcIjtcblxuLyoqIEVtb2ppIHJlZ2V4IHdpdGhvdXQgYW55IGFkZGl0aW9uYWwgZmxhZ3MuICovXG5jb25zdCBFTU9KSV9SRUdFWCA9IG5ldyBSZWdFeHAoZW1vamlSZWdleCgpLCBcIlwiKTtcblxuLyoqIFByb3ZpZGVzIGEgbG9va3VwIHRhYmxlIGZvciB1bml0IGR1cmF0aW9ucyBvZiB0aGUgZ2l2ZW4gdHlwZS4gKi9cbmV4cG9ydCBjb25zdCBEVVJBVElPTl9UWVBFUyA9IHtcbiAgICB5ZWFyOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgeWVhcnM6IDEgfSksXG4gICAgeWVhcnM6IER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMSB9KSxcbiAgICB5cjogRHVyYXRpb24uZnJvbU9iamVjdCh7IHllYXJzOiAxIH0pLFxuICAgIHlyczogRHVyYXRpb24uZnJvbU9iamVjdCh7IHllYXJzOiAxIH0pLFxuXG4gICAgbW9udGg6IER1cmF0aW9uLmZyb21PYmplY3QoeyBtb250aHM6IDEgfSksXG4gICAgbW9udGhzOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbW9udGhzOiAxIH0pLFxuICAgIG1vOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbW9udGhzOiAxIH0pLFxuICAgIG1vczogRHVyYXRpb24uZnJvbU9iamVjdCh7IG1vbnRoczogMSB9KSxcblxuICAgIHdlZWs6IER1cmF0aW9uLmZyb21PYmplY3QoeyB3ZWVrczogMSB9KSxcbiAgICB3ZWVrczogRHVyYXRpb24uZnJvbU9iamVjdCh7IHdlZWtzOiAxIH0pLFxuICAgIHdrOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgd2Vla3M6IDEgfSksXG4gICAgd2tzOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgd2Vla3M6IDEgfSksXG4gICAgdzogRHVyYXRpb24uZnJvbU9iamVjdCh7IHdlZWtzOiAxIH0pLFxuXG4gICAgZGF5OiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgZGF5czogMSB9KSxcbiAgICBkYXlzOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgZGF5czogMSB9KSxcbiAgICBkOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgZGF5czogMSB9KSxcblxuICAgIGhvdXI6IER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMSB9KSxcbiAgICBob3VyczogRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxIH0pLFxuICAgIGhyOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDEgfSksXG4gICAgaHJzOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDEgfSksXG4gICAgaDogRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxIH0pLFxuXG4gICAgbWludXRlOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbWludXRlczogMSB9KSxcbiAgICBtaW51dGVzOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbWludXRlczogMSB9KSxcbiAgICBtaW46IER1cmF0aW9uLmZyb21PYmplY3QoeyBtaW51dGVzOiAxIH0pLFxuICAgIG1pbnM6IER1cmF0aW9uLmZyb21PYmplY3QoeyBtaW51dGVzOiAxIH0pLFxuICAgIG06IER1cmF0aW9uLmZyb21PYmplY3QoeyBtaW51dGVzOiAxIH0pLFxuXG4gICAgc2Vjb25kOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgc2Vjb25kczogMSB9KSxcbiAgICBzZWNvbmRzOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgc2Vjb25kczogMSB9KSxcbiAgICBzZWM6IER1cmF0aW9uLmZyb21PYmplY3QoeyBzZWNvbmRzOiAxIH0pLFxuICAgIHNlY3M6IER1cmF0aW9uLmZyb21PYmplY3QoeyBzZWNvbmRzOiAxIH0pLFxuICAgIHM6IER1cmF0aW9uLmZyb21PYmplY3QoeyBzZWNvbmRzOiAxIH0pLFxufTtcblxuLyoqIFNob3J0aGFuZCBmb3IgY29tbW9uIGRhdGVzIChyZWxhdGl2ZSB0byByaWdodCBub3cpLiAqL1xuZXhwb3J0IGNvbnN0IERBVEVfU0hPUlRIQU5EUyA9IHtcbiAgICBub3c6ICgpID0+IERhdGVUaW1lLmxvY2FsKCksXG4gICAgdG9kYXk6ICgpID0+IERhdGVUaW1lLmxvY2FsKCkuc3RhcnRPZihcImRheVwiKSxcbiAgICB5ZXN0ZXJkYXk6ICgpID0+XG4gICAgICAgIERhdGVUaW1lLmxvY2FsKClcbiAgICAgICAgICAgIC5zdGFydE9mKFwiZGF5XCIpXG4gICAgICAgICAgICAubWludXMoRHVyYXRpb24uZnJvbU9iamVjdCh7IGRheXM6IDEgfSkpLFxuICAgIHRvbW9ycm93OiAoKSA9PlxuICAgICAgICBEYXRlVGltZS5sb2NhbCgpXG4gICAgICAgICAgICAuc3RhcnRPZihcImRheVwiKVxuICAgICAgICAgICAgLnBsdXMoRHVyYXRpb24uZnJvbU9iamVjdCh7IGRheXM6IDEgfSkpLFxuICAgIHNvdzogKCkgPT4gRGF0ZVRpbWUubG9jYWwoKS5zdGFydE9mKFwid2Vla1wiKSxcbiAgICBcInN0YXJ0LW9mLXdlZWtcIjogKCkgPT4gRGF0ZVRpbWUubG9jYWwoKS5zdGFydE9mKFwid2Vla1wiKSxcbiAgICBlb3c6ICgpID0+IERhdGVUaW1lLmxvY2FsKCkuZW5kT2YoXCJ3ZWVrXCIpLFxuICAgIFwiZW5kLW9mLXdlZWtcIjogKCkgPT4gRGF0ZVRpbWUubG9jYWwoKS5lbmRPZihcIndlZWtcIiksXG4gICAgc295OiAoKSA9PiBEYXRlVGltZS5sb2NhbCgpLnN0YXJ0T2YoXCJ5ZWFyXCIpLFxuICAgIFwic3RhcnQtb2YteWVhclwiOiAoKSA9PiBEYXRlVGltZS5sb2NhbCgpLnN0YXJ0T2YoXCJ5ZWFyXCIpLFxuICAgIGVveTogKCkgPT4gRGF0ZVRpbWUubG9jYWwoKS5lbmRPZihcInllYXJcIiksXG4gICAgXCJlbmQtb2YteWVhclwiOiAoKSA9PiBEYXRlVGltZS5sb2NhbCgpLmVuZE9mKFwieWVhclwiKSxcbiAgICBzb206ICgpID0+IERhdGVUaW1lLmxvY2FsKCkuc3RhcnRPZihcIm1vbnRoXCIpLFxuICAgIFwic3RhcnQtb2YtbW9udGhcIjogKCkgPT4gRGF0ZVRpbWUubG9jYWwoKS5zdGFydE9mKFwibW9udGhcIiksXG4gICAgZW9tOiAoKSA9PiBEYXRlVGltZS5sb2NhbCgpLmVuZE9mKFwibW9udGhcIiksXG4gICAgXCJlbmQtb2YtbW9udGhcIjogKCkgPT4gRGF0ZVRpbWUubG9jYWwoKS5lbmRPZihcIm1vbnRoXCIpLFxufTtcblxuLyoqXG4gKiBLZXl3b3JkcyB3aGljaCBjYW5ub3QgYmUgdXNlZCBhcyB2YXJpYWJsZXMgZGlyZWN0bHkuIFVzZSBgcm93Ljx0aGluZz5gIGlmIGl0IGlzIGEgdmFyaWFibGUgeW91IGhhdmUgZGVmaW5lZCBhbmQgd2FudFxuICogdG8gYWNjZXNzLlxuICovXG5leHBvcnQgY29uc3QgS0VZV09SRFMgPSBbXCJGUk9NXCIsIFwiV0hFUkVcIiwgXCJMSU1JVFwiLCBcIkdST1VQXCIsIFwiRkxBVFRFTlwiXTtcblxuLy8vLy8vLy8vLy8vLy8vXG4vLyBVdGlsaXRpZXMgLy9cbi8vLy8vLy8vLy8vLy8vL1xuXG4vKiogU3BsaXQgb24gdW5lc2NhcGVkIHBpcGVzIGluIGFuIGlubmVyIGxpbmsuICovXG5mdW5jdGlvbiBzcGxpdE9uVW5lc2NhcGVkUGlwZShsaW5rOiBzdHJpbmcpOiBbc3RyaW5nLCBzdHJpbmcgfCB1bmRlZmluZWRdIHtcbiAgICBsZXQgcGlwZSA9IC0xO1xuICAgIHdoaWxlICgocGlwZSA9IGxpbmsuaW5kZXhPZihcInxcIiwgcGlwZSArIDEpKSA+PSAwKSB7XG4gICAgICAgIGlmIChwaXBlID4gMCAmJiBsaW5rW3BpcGUgLSAxXSA9PSBcIlxcXFxcIikgY29udGludWU7XG4gICAgICAgIHJldHVybiBbbGluay5zdWJzdHJpbmcoMCwgcGlwZSkucmVwbGFjZSgvXFxcXFxcfC9nLCBcInxcIiksIGxpbmsuc3Vic3RyaW5nKHBpcGUgKyAxKV07XG4gICAgfVxuXG4gICAgcmV0dXJuIFtsaW5rLnJlcGxhY2UoL1xcXFxcXHwvZywgXCJ8XCIpLCB1bmRlZmluZWRdO1xufVxuXG4vKiogQXR0ZW1wdCB0byBwYXJzZSB0aGUgaW5zaWRlIG9mIGEgbGluayB0byBwdWxsIG91dCBkaXNwbGF5IG5hbWUsIHN1YnBhdGgsIGV0Yy4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUlubmVyTGluayhyYXdsaW5rOiBzdHJpbmcpOiBMaW5rIHtcbiAgICBsZXQgW2xpbmssIGRpc3BsYXldID0gc3BsaXRPblVuZXNjYXBlZFBpcGUocmF3bGluayk7XG4gICAgcmV0dXJuIExpbmsuaW5mZXIobGluaywgZmFsc2UsIGRpc3BsYXkpO1xufVxuXG4vKiogQ3JlYXRlIGEgbGVmdC1hc3NvY2lhdGl2ZSBiaW5hcnkgcGFyc2VyIHdoaWNoIHBhcnNlcyB0aGUgZ2l2ZW4gc3ViLWVsZW1lbnQgYW5kIHNlcGFyYXRvci4gSGFuZGxlcyB3aGl0ZXNwYWNlLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUJpbmFyeVBhcnNlcjxULCBVPihcbiAgICBjaGlsZDogUC5QYXJzZXI8VD4sXG4gICAgc2VwOiBQLlBhcnNlcjxVPixcbiAgICBjb21iaW5lOiAoYTogVCwgYjogVSwgYzogVCkgPT4gVFxuKTogUC5QYXJzZXI8VD4ge1xuICAgIHJldHVybiBQLnNlcU1hcChjaGlsZCwgUC5zZXEoUC5vcHRXaGl0ZXNwYWNlLCBzZXAsIFAub3B0V2hpdGVzcGFjZSwgY2hpbGQpLm1hbnkoKSwgKGZpcnN0LCByZXN0KSA9PiB7XG4gICAgICAgIGlmIChyZXN0Lmxlbmd0aCA9PSAwKSByZXR1cm4gZmlyc3Q7XG5cbiAgICAgICAgbGV0IG5vZGUgPSBjb21iaW5lKGZpcnN0LCByZXN0WzBdWzFdLCByZXN0WzBdWzNdKTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAxOyBpbmRleCA8IHJlc3QubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBub2RlID0gY29tYmluZShub2RlLCByZXN0W2luZGV4XVsxXSwgcmVzdFtpbmRleF1bM10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hhaW5PcHQ8VD4oYmFzZTogUC5QYXJzZXI8VD4sIC4uLmZ1bmNzOiAoKHI6IFQpID0+IFAuUGFyc2VyPFQ+KVtdKTogUC5QYXJzZXI8VD4ge1xuICAgIHJldHVybiBQLmN1c3RvbSgoc3VjY2VzcywgZmFpbHVyZSkgPT4ge1xuICAgICAgICByZXR1cm4gKGlucHV0LCBpKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gKGJhc2UgYXMgYW55KS5fKGlucHV0LCBpKTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0LnN0YXR1cykgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICAgICAgZm9yIChsZXQgZnVuYyBvZiBmdW5jcykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gKGZ1bmMocmVzdWx0LnZhbHVlIGFzIFQpIGFzIGFueSkuXyhpbnB1dCwgcmVzdWx0LmluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoIW5leHQuc3RhdHVzKSByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV4dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBFeHByZXNzaW9uIFBhcnNpbmcgLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5leHBvcnQgdHlwZSBQb3N0Zml4RnJhZ21lbnQgPVxuICAgIHwgeyB0eXBlOiBcImRvdFwiOyBmaWVsZDogc3RyaW5nIH1cbiAgICB8IHsgdHlwZTogXCJpbmRleFwiOyBmaWVsZDogRmllbGQgfVxuICAgIHwgeyB0eXBlOiBcImZ1bmN0aW9uXCI7IGZpZWxkczogRmllbGRbXSB9O1xuXG5leHBvcnQgaW50ZXJmYWNlIEV4cHJlc3Npb25MYW5ndWFnZSB7XG4gICAgbnVtYmVyOiBudW1iZXI7XG4gICAgc3RyaW5nOiBzdHJpbmc7XG4gICAgZXNjYXBlQ2hhcmFjdGVyOiBzdHJpbmc7XG4gICAgYm9vbDogYm9vbGVhbjtcbiAgICB0YWc6IHN0cmluZztcbiAgICBpZGVudGlmaWVyOiBzdHJpbmc7XG4gICAgbGluazogTGluaztcbiAgICBlbWJlZExpbms6IExpbms7XG4gICAgcm9vdERhdGU6IERhdGVUaW1lO1xuICAgIGRhdGVTaG9ydGhhbmQ6IGtleW9mIHR5cGVvZiBEQVRFX1NIT1JUSEFORFM7XG4gICAgZGF0ZTogRGF0ZVRpbWU7XG4gICAgZGF0ZVBsdXM6IERhdGVUaW1lO1xuICAgIGR1cmF0aW9uVHlwZToga2V5b2YgdHlwZW9mIERVUkFUSU9OX1RZUEVTO1xuICAgIGR1cmF0aW9uOiBEdXJhdGlvbjtcbiAgICByYXdOdWxsOiBzdHJpbmc7XG5cbiAgICBiaW5hcnlQbHVzTWludXM6IEJpbmFyeU9wO1xuICAgIGJpbmFyeU11bERpdjogQmluYXJ5T3A7XG4gICAgYmluYXJ5Q29tcGFyZU9wOiBCaW5hcnlPcDtcbiAgICBiaW5hcnlCb29sZWFuT3A6IEJpbmFyeU9wO1xuXG4gICAgLy8gU291cmNlLXJlbGF0ZWQgcGFyc2Vycy5cbiAgICB0YWdTb3VyY2U6IFRhZ1NvdXJjZTtcbiAgICBjc3ZTb3VyY2U6IENzdlNvdXJjZTtcbiAgICBmb2xkZXJTb3VyY2U6IEZvbGRlclNvdXJjZTtcbiAgICBwYXJlbnNTb3VyY2U6IFNvdXJjZTtcbiAgICBhdG9tU291cmNlOiBTb3VyY2U7XG4gICAgbGlua0luY29taW5nU291cmNlOiBTb3VyY2U7XG4gICAgbGlua091dGdvaW5nU291cmNlOiBTb3VyY2U7XG4gICAgbmVnYXRlU291cmNlOiBOZWdhdGVkU291cmNlO1xuICAgIGJpbmFyeU9wU291cmNlOiBTb3VyY2U7XG4gICAgc291cmNlOiBTb3VyY2U7XG5cbiAgICAvLyBGaWVsZC1yZWxhdGVkIHBhcnNlcnMuXG4gICAgdmFyaWFibGVGaWVsZDogVmFyaWFibGVGaWVsZDtcbiAgICBudW1iZXJGaWVsZDogTGl0ZXJhbEZpZWxkO1xuICAgIGJvb2xGaWVsZDogTGl0ZXJhbEZpZWxkO1xuICAgIHN0cmluZ0ZpZWxkOiBMaXRlcmFsRmllbGQ7XG4gICAgZGF0ZUZpZWxkOiBMaXRlcmFsRmllbGQ7XG4gICAgZHVyYXRpb25GaWVsZDogTGl0ZXJhbEZpZWxkO1xuICAgIGxpbmtGaWVsZDogTGl0ZXJhbEZpZWxkO1xuICAgIG51bGxGaWVsZDogTGl0ZXJhbEZpZWxkO1xuXG4gICAgbGlzdEZpZWxkOiBMaXN0RmllbGQ7XG4gICAgb2JqZWN0RmllbGQ6IE9iamVjdEZpZWxkO1xuXG4gICAgYXRvbUlubGluZUZpZWxkOiBMaXRlcmFsO1xuICAgIGlubGluZUZpZWxkTGlzdDogTGl0ZXJhbFtdO1xuICAgIGlubGluZUZpZWxkOiBMaXRlcmFsO1xuXG4gICAgbmVnYXRlZEZpZWxkOiBGaWVsZDtcbiAgICBhdG9tRmllbGQ6IEZpZWxkO1xuICAgIGluZGV4RmllbGQ6IEZpZWxkO1xuICAgIGxhbWJkYUZpZWxkOiBMYW1iZGFGaWVsZDtcblxuICAgIC8vIFBvc3RmaXggcGFyc2VycyBmb3IgZnVuY3Rpb24gY2FsbHMgJiB0aGUgbGlrZS5cbiAgICBkb3RQb3N0Zml4OiBQb3N0Zml4RnJhZ21lbnQ7XG4gICAgaW5kZXhQb3N0Zml4OiBQb3N0Zml4RnJhZ21lbnQ7XG4gICAgZnVuY3Rpb25Qb3N0Zml4OiBQb3N0Zml4RnJhZ21lbnQ7XG5cbiAgICAvLyBCaW5hcnkgb3AgcGFyc2Vycy5cbiAgICBiaW5hcnlNdWxEaXZGaWVsZDogRmllbGQ7XG4gICAgYmluYXJ5UGx1c01pbnVzRmllbGQ6IEZpZWxkO1xuICAgIGJpbmFyeUNvbXBhcmVGaWVsZDogRmllbGQ7XG4gICAgYmluYXJ5Qm9vbGVhbkZpZWxkOiBGaWVsZDtcbiAgICBiaW5hcnlPcEZpZWxkOiBGaWVsZDtcbiAgICBwYXJlbnNGaWVsZDogRmllbGQ7XG4gICAgZmllbGQ6IEZpZWxkO1xufVxuXG5leHBvcnQgY29uc3QgRVhQUkVTU0lPTiA9IFAuY3JlYXRlTGFuZ3VhZ2U8RXhwcmVzc2lvbkxhbmd1YWdlPih7XG4gICAgLy8gQSBmbG9hdGluZyBwb2ludCBudW1iZXI7IHRoZSBkZWNpbWFsIHBvaW50IGlzIG9wdGlvbmFsLlxuICAgIG51bWJlcjogcSA9PlxuICAgICAgICBQLnJlZ2V4cCgvLT9bMC05XSsoXFwuWzAtOV0rKT8vKVxuICAgICAgICAgICAgLm1hcChzdHIgPT4gTnVtYmVyLnBhcnNlRmxvYXQoc3RyKSlcbiAgICAgICAgICAgIC5kZXNjKFwibnVtYmVyXCIpLFxuXG4gICAgLy8gQSBxdW90ZS1zdXJyb3VuZGVkIHN0cmluZyB3aGljaCBzdXBwb3J0cyBlc2NhcGUgY2hhcmFjdGVycyAoJ1xcJykuXG4gICAgc3RyaW5nOiBxID0+XG4gICAgICAgIFAuc3RyaW5nKCdcIicpXG4gICAgICAgICAgICAudGhlbihcbiAgICAgICAgICAgICAgICBQLmFsdChxLmVzY2FwZUNoYXJhY3RlciwgUC5ub25lT2YoJ1wiXFxcXCcpKVxuICAgICAgICAgICAgICAgICAgICAuYXRMZWFzdCgwKVxuICAgICAgICAgICAgICAgICAgICAubWFwKGNoYXJzID0+IGNoYXJzLmpvaW4oXCJcIikpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuc2tpcChQLnN0cmluZygnXCInKSlcbiAgICAgICAgICAgIC5kZXNjKFwic3RyaW5nXCIpLFxuXG4gICAgZXNjYXBlQ2hhcmFjdGVyOiBfID0+XG4gICAgICAgIFAuc3RyaW5nKFwiXFxcXFwiKVxuICAgICAgICAgICAgLnRoZW4oUC5hbnkpXG4gICAgICAgICAgICAubWFwKGVzY2FwZWQgPT4ge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBlc2NhcGluZyBhIGJhY2tzbGFzaCBvciBhIHF1b3RlLCBwYXNzIGluIG9uIGluIGVzY2FwZWQgZm9ybVxuICAgICAgICAgICAgICAgIGlmIChlc2NhcGVkID09PSAnXCInKSByZXR1cm4gJ1wiJztcbiAgICAgICAgICAgICAgICBpZiAoZXNjYXBlZCA9PT0gXCJcXFxcXCIpIHJldHVybiBcIlxcXFxcIjtcbiAgICAgICAgICAgICAgICBlbHNlIHJldHVybiBcIlxcXFxcIiArIGVzY2FwZWQ7XG4gICAgICAgICAgICB9KSxcblxuICAgIC8vIEEgYm9vbGVhbiB0cnVlL2ZhbHNlIHZhbHVlLlxuICAgIGJvb2w6IF8gPT5cbiAgICAgICAgUC5yZWdleHAoL3RydWV8ZmFsc2V8VHJ1ZXxGYWxzZS8pXG4gICAgICAgICAgICAubWFwKHN0ciA9PiBzdHIudG9Mb3dlckNhc2UoKSA9PSBcInRydWVcIilcbiAgICAgICAgICAgIC5kZXNjKFwiYm9vbGVhbiAoJ3RydWUnIG9yICdmYWxzZScpXCIpLFxuXG4gICAgLy8gQSB0YWcgb2YgdGhlIGZvcm0gJyNzdHVmZi9oZWxsby10aGVyZScuXG4gICAgdGFnOiBfID0+XG4gICAgICAgIFAuc2VxTWFwKFxuICAgICAgICAgICAgUC5zdHJpbmcoXCIjXCIpLFxuICAgICAgICAgICAgUC5hbHQoUC5yZWdleHAoL1teXFx1MjAwMC1cXHUyMDZGXFx1MkUwMC1cXHUyRTdGJyFcIiMkJSYoKSorLC46Ozw9Pj9AXmB7fH1+XFxbXFxdXFxcXFxcc10vKS5kZXNjKFwidGV4dFwiKSkubWFueSgpLFxuICAgICAgICAgICAgKHN0YXJ0LCByZXN0KSA9PiBzdGFydCArIHJlc3Quam9pbihcIlwiKVxuICAgICAgICApLmRlc2MoXCJ0YWcgKCcjaGVsbG8vc3R1ZmYnKVwiKSxcblxuICAgIC8vIEEgdmFyaWFibGUgaWRlbnRpZmllciwgd2hpY2ggaXMgYWxwaGFudW1lcmljIGFuZCBtdXN0IHN0YXJ0IHdpdGggYSBsZXR0ZXIgb3IuLi4gZW1vamkuXG4gICAgaWRlbnRpZmllcjogXyA9PlxuICAgICAgICBQLnNlcU1hcChcbiAgICAgICAgICAgIFAuYWx0KFAucmVnZXhwKC9cXHB7TGV0dGVyfS91KSwgUC5yZWdleHAoRU1PSklfUkVHRVgpLmRlc2MoXCJ0ZXh0XCIpKSxcbiAgICAgICAgICAgIFAuYWx0KFAucmVnZXhwKC9bMC05XFxwe0xldHRlcn1fLV0vdSksIFAucmVnZXhwKEVNT0pJX1JFR0VYKS5kZXNjKFwidGV4dFwiKSkubWFueSgpLFxuICAgICAgICAgICAgKGZpcnN0LCByZXN0KSA9PiBmaXJzdCArIHJlc3Quam9pbihcIlwiKVxuICAgICAgICApLmRlc2MoXCJ2YXJpYWJsZSBpZGVudGlmaWVyXCIpLFxuXG4gICAgLy8gQW4gT2JzaWRpYW4gbGluayBvZiB0aGUgZm9ybSBbWzxsaW5rPl1dLlxuICAgIGxpbms6IF8gPT5cbiAgICAgICAgUC5yZWdleHAoL1xcW1xcWyhbXlxcW1xcXV0qPylcXF1cXF0vdSwgMSlcbiAgICAgICAgICAgIC5tYXAobGlua0lubmVyID0+IHBhcnNlSW5uZXJMaW5rKGxpbmtJbm5lcikpXG4gICAgICAgICAgICAuZGVzYyhcImZpbGUgbGlua1wiKSxcblxuICAgIC8vIEFuIGVtYmVkZGFibGUgbGluayB3aGljaCBjYW4gc3RhcnQgd2l0aCAnIScuIFRoaXMgb3ZlcmxhcHMgd2l0aCB0aGUgbm9ybWFsIG5lZ2F0aW9uIG9wZXJhdG9yLCBzbyBpdCBpcyBvbmx5XG4gICAgLy8gcHJvdmlkZWQgZm9yIG1ldGFkYXRhIHBhcnNpbmcuXG4gICAgZW1iZWRMaW5rOiBxID0+XG4gICAgICAgIFAuc2VxTWFwKFAuc3RyaW5nKFwiIVwiKS5hdE1vc3QoMSksIHEubGluaywgKHAsIGwpID0+IHtcbiAgICAgICAgICAgIGlmIChwLmxlbmd0aCA+IDApIGwuZW1iZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGw7XG4gICAgICAgIH0pLmRlc2MoXCJmaWxlIGxpbmtcIiksXG5cbiAgICAvLyBCaW5hcnkgcGx1cyBvciBtaW51cyBvcGVyYXRvci5cbiAgICBiaW5hcnlQbHVzTWludXM6IF8gPT5cbiAgICAgICAgUC5yZWdleHAoL1xcK3wtLylcbiAgICAgICAgICAgIC5tYXAoc3RyID0+IHN0ciBhcyBCaW5hcnlPcClcbiAgICAgICAgICAgIC5kZXNjKFwiJysnIG9yICctJ1wiKSxcblxuICAgIC8vIEJpbmFyeSB0aW1lcyBvciBkaXZpZGUgb3BlcmF0b3IuXG4gICAgYmluYXJ5TXVsRGl2OiBfID0+XG4gICAgICAgIFAucmVnZXhwKC9cXCp8XFwvfCUvKVxuICAgICAgICAgICAgLm1hcChzdHIgPT4gc3RyIGFzIEJpbmFyeU9wKVxuICAgICAgICAgICAgLmRlc2MoXCInKicgb3IgJy8nIG9yICclJ1wiKSxcblxuICAgIC8vIEJpbmFyeSBjb21wYXJpc29uIG9wZXJhdG9yLlxuICAgIGJpbmFyeUNvbXBhcmVPcDogXyA9PlxuICAgICAgICBQLnJlZ2V4cCgvPj18PD18IT18Pnw8fD0vKVxuICAgICAgICAgICAgLm1hcChzdHIgPT4gc3RyIGFzIEJpbmFyeU9wKVxuICAgICAgICAgICAgLmRlc2MoXCInPj0nIG9yICc8PScgb3IgJyE9JyBvciAnPScgb3IgJz4nIG9yICc8J1wiKSxcblxuICAgIC8vIEJpbmFyeSBib29sZWFuIGNvbWJpbmF0aW9uIG9wZXJhdG9yLlxuICAgIGJpbmFyeUJvb2xlYW5PcDogXyA9PlxuICAgICAgICBQLnJlZ2V4cCgvYW5kfG9yfCZ8XFx8L2kpXG4gICAgICAgICAgICAubWFwKHN0ciA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHN0ci50b0xvd2VyQ2FzZSgpID09IFwiYW5kXCIpIHJldHVybiBcIiZcIjtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdHIudG9Mb3dlckNhc2UoKSA9PSBcIm9yXCIpIHJldHVybiBcInxcIjtcbiAgICAgICAgICAgICAgICBlbHNlIHJldHVybiBzdHIgYXMgQmluYXJ5T3A7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmRlc2MoXCInYW5kJyBvciAnb3InXCIpLFxuXG4gICAgLy8gQSBkYXRlIHdoaWNoIGNhbiBiZSBZWVlZLU1NWy1ERFRISDptbTpzc10uXG4gICAgcm9vdERhdGU6IF8gPT5cbiAgICAgICAgUC5zZXFNYXAoUC5yZWdleHAoL1xcZHs0fS8pLCBQLnN0cmluZyhcIi1cIiksIFAucmVnZXhwKC9cXGR7Mn0vKSwgKHllYXIsIF8sIG1vbnRoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gRGF0ZVRpbWUuZnJvbU9iamVjdCh7IHllYXI6IE51bWJlci5wYXJzZUludCh5ZWFyKSwgbW9udGg6IE51bWJlci5wYXJzZUludChtb250aCkgfSk7XG4gICAgICAgIH0pLmRlc2MoXCJkYXRlIGluIGZvcm1hdCBZWVlZLU1NWy1ERFRISC1NTS1TUy5NU11cIiksXG4gICAgZGF0ZVNob3J0aGFuZDogXyA9PlxuICAgICAgICBQLmFsdChcbiAgICAgICAgICAgIC4uLk9iamVjdC5rZXlzKERBVEVfU0hPUlRIQU5EUylcbiAgICAgICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYi5sZW5ndGggLSBhLmxlbmd0aClcbiAgICAgICAgICAgICAgICAubWFwKFAuc3RyaW5nKVxuICAgICAgICApIGFzIFAuUGFyc2VyPGtleW9mIHR5cGVvZiBEQVRFX1NIT1JUSEFORFM+LFxuICAgIGRhdGU6IHEgPT5cbiAgICAgICAgY2hhaW5PcHQ8RGF0ZVRpbWU+KFxuICAgICAgICAgICAgcS5yb290RGF0ZSxcbiAgICAgICAgICAgICh5bTogRGF0ZVRpbWUpID0+XG4gICAgICAgICAgICAgICAgUC5zZXFNYXAoUC5zdHJpbmcoXCItXCIpLCBQLnJlZ2V4cCgvXFxkezJ9LyksIChfLCBkYXkpID0+IHltLnNldCh7IGRheTogTnVtYmVyLnBhcnNlSW50KGRheSkgfSkpLFxuICAgICAgICAgICAgKHltZDogRGF0ZVRpbWUpID0+XG4gICAgICAgICAgICAgICAgUC5zZXFNYXAoUC5zdHJpbmcoXCJUXCIpLCBQLnJlZ2V4cCgvXFxkezJ9LyksIChfLCBob3VyKSA9PiB5bWQuc2V0KHsgaG91cjogTnVtYmVyLnBhcnNlSW50KGhvdXIpIH0pKSxcbiAgICAgICAgICAgICh5bWRoOiBEYXRlVGltZSkgPT5cbiAgICAgICAgICAgICAgICBQLnNlcU1hcChQLnN0cmluZyhcIjpcIiksIFAucmVnZXhwKC9cXGR7Mn0vKSwgKF8sIG1pbnV0ZSkgPT5cbiAgICAgICAgICAgICAgICAgICAgeW1kaC5zZXQoeyBtaW51dGU6IE51bWJlci5wYXJzZUludChtaW51dGUpIH0pXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICh5bWRobTogRGF0ZVRpbWUpID0+XG4gICAgICAgICAgICAgICAgUC5zZXFNYXAoUC5zdHJpbmcoXCI6XCIpLCBQLnJlZ2V4cCgvXFxkezJ9LyksIChfLCBzZWNvbmQpID0+XG4gICAgICAgICAgICAgICAgICAgIHltZGhtLnNldCh7IHNlY29uZDogTnVtYmVyLnBhcnNlSW50KHNlY29uZCkgfSlcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKHltZGhtczogRGF0ZVRpbWUpID0+XG4gICAgICAgICAgICAgICAgUC5hbHQoXG4gICAgICAgICAgICAgICAgICAgIFAuc2VxTWFwKFAuc3RyaW5nKFwiLlwiKSwgUC5yZWdleHAoL1xcZHszfS8pLCAoXywgbWlsbGlzZWNvbmQpID0+XG4gICAgICAgICAgICAgICAgICAgICAgICB5bWRobXMuc2V0KHsgbWlsbGlzZWNvbmQ6IE51bWJlci5wYXJzZUludChtaWxsaXNlY29uZCkgfSlcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgUC5zdWNjZWVkKHltZGhtcykgLy8gcGFzc1xuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAoZHQ6IERhdGVUaW1lKSA9PlxuICAgICAgICAgICAgICAgIFAuYWx0KFxuICAgICAgICAgICAgICAgICAgICBQLnNlcU1hcChQLnN0cmluZyhcIitcIikub3IoUC5zdHJpbmcoXCItXCIpKSwgUC5yZWdleHAoL1xcZHsxLDJ9KDpcXGR7Mn0pPy8pLCAocG0sIGhyKSA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgZHQuc2V0Wm9uZShcIlVUQ1wiICsgcG0gKyBociwgeyBrZWVwTG9jYWxUaW1lOiB0cnVlIH0pXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIFAuc2VxTWFwKFAuc3RyaW5nKFwiWlwiKSwgKCkgPT4gZHQuc2V0Wm9uZShcInV0Y1wiLCB7IGtlZXBMb2NhbFRpbWU6IHRydWUgfSkpLFxuICAgICAgICAgICAgICAgICAgICBQLnNlcU1hcChQLnN0cmluZyhcIltcIiksIFAucmVnZXhwKC9bMC05QS1aYS16Ky1cXC9dKy91KSwgUC5zdHJpbmcoXCJdXCIpLCAoX2EsIHpvbmUsIF9iKSA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgZHQuc2V0Wm9uZSh6b25lLCB7IGtlZXBMb2NhbFRpbWU6IHRydWUgfSlcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgICAgICAgLmFzc2VydCgoZHQ6IERhdGVUaW1lKSA9PiBkdC5pc1ZhbGlkLCBcInZhbGlkIGRhdGVcIilcbiAgICAgICAgICAgIC5kZXNjKFwiZGF0ZSBpbiBmb3JtYXQgWVlZWS1NTVstRERUSEgtTU0tU1MuTVNdXCIpLFxuXG4gICAgLy8gQSBkYXRlLCBwbHVzIHZhcmlvdXMgc2hvcnRoYW5kIHRpbWVzIG9mIGRheSBpdCBjb3VsZCBiZS5cbiAgICBkYXRlUGx1czogcSA9PlxuICAgICAgICBQLmFsdDxEYXRlVGltZT4oXG4gICAgICAgICAgICBxLmRhdGVTaG9ydGhhbmQubWFwKGQgPT4gREFURV9TSE9SVEhBTkRTW2RdKCkpLFxuICAgICAgICAgICAgcS5kYXRlXG4gICAgICAgICkuZGVzYyhcImRhdGUgaW4gZm9ybWF0IFlZWVktTU1bLUREVEhILU1NLVNTLk1TXSBvciBpbiBzaG9ydGhhbmRcIiksXG5cbiAgICAvLyBBIGR1cmF0aW9uIG9mIHRpbWUuXG4gICAgZHVyYXRpb25UeXBlOiBfID0+XG4gICAgICAgIFAuYWx0KFxuICAgICAgICAgICAgLi4uT2JqZWN0LmtleXMoRFVSQVRJT05fVFlQRVMpXG4gICAgICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGIubGVuZ3RoIC0gYS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgLm1hcChQLnN0cmluZylcbiAgICAgICAgKSBhcyBQLlBhcnNlcjxrZXlvZiB0eXBlb2YgRFVSQVRJT05fVFlQRVM+LFxuICAgIGR1cmF0aW9uOiBxID0+XG4gICAgICAgIFAuc2VxTWFwKHEubnVtYmVyLCBQLm9wdFdoaXRlc3BhY2UsIHEuZHVyYXRpb25UeXBlLCAoY291bnQsIF8sIHQpID0+IERVUkFUSU9OX1RZUEVTW3RdLm1hcFVuaXRzKHggPT4geCAqIGNvdW50KSlcbiAgICAgICAgICAgIC5zZXBCeTEoUC5zdHJpbmcoXCIsXCIpLnRyaW0oUC5vcHRXaGl0ZXNwYWNlKS5vcihQLm9wdFdoaXRlc3BhY2UpKVxuICAgICAgICAgICAgLm1hcChkdXJhdGlvbnMgPT4gZHVyYXRpb25zLnJlZHVjZSgocCwgYykgPT4gcC5wbHVzKGMpKSlcbiAgICAgICAgICAgIC5kZXNjKFwiZHVyYXRpb24gbGlrZSA0aHIybWluXCIpLFxuXG4gICAgLy8gQSByYXcgbnVsbCB2YWx1ZS5cbiAgICByYXdOdWxsOiBfID0+IFAuc3RyaW5nKFwibnVsbFwiKSxcblxuICAgIC8vIFNvdXJjZSBwYXJzaW5nLlxuICAgIHRhZ1NvdXJjZTogcSA9PiBxLnRhZy5tYXAodGFnID0+IFNvdXJjZXMudGFnKHRhZykpLFxuICAgIGNzdlNvdXJjZTogcSA9PlxuICAgICAgICBQLnNlcU1hcChQLnN0cmluZyhcImNzdihcIikuc2tpcChQLm9wdFdoaXRlc3BhY2UpLCBxLnN0cmluZywgUC5zdHJpbmcoXCIpXCIpLCAoXzEsIHBhdGgsIF8yKSA9PiBTb3VyY2VzLmNzdihwYXRoKSksXG4gICAgbGlua0luY29taW5nU291cmNlOiBxID0+IHEubGluay5tYXAobGluayA9PiBTb3VyY2VzLmxpbmsobGluay5wYXRoLCB0cnVlKSksXG4gICAgbGlua091dGdvaW5nU291cmNlOiBxID0+XG4gICAgICAgIFAuc2VxTWFwKFAuc3RyaW5nKFwib3V0Z29pbmcoXCIpLnNraXAoUC5vcHRXaGl0ZXNwYWNlKSwgcS5saW5rLCBQLnN0cmluZyhcIilcIiksIChfMSwgbGluaywgXzIpID0+XG4gICAgICAgICAgICBTb3VyY2VzLmxpbmsobGluay5wYXRoLCBmYWxzZSlcbiAgICAgICAgKSxcbiAgICBmb2xkZXJTb3VyY2U6IHEgPT4gcS5zdHJpbmcubWFwKHN0ciA9PiBTb3VyY2VzLmZvbGRlcihzdHIpKSxcbiAgICBwYXJlbnNTb3VyY2U6IHEgPT5cbiAgICAgICAgUC5zZXFNYXAoXG4gICAgICAgICAgICBQLnN0cmluZyhcIihcIiksXG4gICAgICAgICAgICBQLm9wdFdoaXRlc3BhY2UsXG4gICAgICAgICAgICBxLnNvdXJjZSxcbiAgICAgICAgICAgIFAub3B0V2hpdGVzcGFjZSxcbiAgICAgICAgICAgIFAuc3RyaW5nKFwiKVwiKSxcbiAgICAgICAgICAgIChfMSwgXzIsIGZpZWxkLCBfMywgXzQpID0+IGZpZWxkXG4gICAgICAgICksXG4gICAgbmVnYXRlU291cmNlOiBxID0+XG4gICAgICAgIFAuc2VxTWFwKFAuYWx0KFAuc3RyaW5nKFwiLVwiKSwgUC5zdHJpbmcoXCIhXCIpKSwgcS5hdG9tU291cmNlLCAoXywgc291cmNlKSA9PiBTb3VyY2VzLm5lZ2F0ZShzb3VyY2UpKSxcbiAgICBhdG9tU291cmNlOiBxID0+XG4gICAgICAgIFAuYWx0PFNvdXJjZT4oXG4gICAgICAgICAgICBxLnBhcmVuc1NvdXJjZSxcbiAgICAgICAgICAgIHEubmVnYXRlU291cmNlLFxuICAgICAgICAgICAgcS5saW5rT3V0Z29pbmdTb3VyY2UsXG4gICAgICAgICAgICBxLmxpbmtJbmNvbWluZ1NvdXJjZSxcbiAgICAgICAgICAgIHEuZm9sZGVyU291cmNlLFxuICAgICAgICAgICAgcS50YWdTb3VyY2UsXG4gICAgICAgICAgICBxLmNzdlNvdXJjZVxuICAgICAgICApLFxuICAgIGJpbmFyeU9wU291cmNlOiBxID0+XG4gICAgICAgIGNyZWF0ZUJpbmFyeVBhcnNlcihcbiAgICAgICAgICAgIHEuYXRvbVNvdXJjZSxcbiAgICAgICAgICAgIHEuYmluYXJ5Qm9vbGVhbk9wLm1hcChzID0+IHMgYXMgU291cmNlT3ApLFxuICAgICAgICAgICAgU291cmNlcy5iaW5hcnlPcFxuICAgICAgICApLFxuICAgIHNvdXJjZTogcSA9PiBxLmJpbmFyeU9wU291cmNlLFxuXG4gICAgLy8gRmllbGQgcGFyc2luZy5cbiAgICB2YXJpYWJsZUZpZWxkOiBxID0+XG4gICAgICAgIHEuaWRlbnRpZmllclxuICAgICAgICAgICAgLmNoYWluKHIgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChLRVlXT1JEUy5pbmNsdWRlcyhyLnRvVXBwZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQLmZhaWwoXCJWYXJpYWJsZSBmaWVsZHMgY2Fubm90IGJlIGEga2V5d29yZCAoXCIgKyBLRVlXT1JEUy5qb2luKFwiIG9yIFwiKSArIFwiKVwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUC5zdWNjZWVkKEZpZWxkcy52YXJpYWJsZShyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5kZXNjKFwidmFyaWFibGVcIiksXG4gICAgbnVtYmVyRmllbGQ6IHEgPT4gcS5udW1iZXIubWFwKHZhbCA9PiBGaWVsZHMubGl0ZXJhbCh2YWwpKS5kZXNjKFwibnVtYmVyXCIpLFxuICAgIHN0cmluZ0ZpZWxkOiBxID0+IHEuc3RyaW5nLm1hcCh2YWwgPT4gRmllbGRzLmxpdGVyYWwodmFsKSkuZGVzYyhcInN0cmluZ1wiKSxcbiAgICBib29sRmllbGQ6IHEgPT4gcS5ib29sLm1hcCh2YWwgPT4gRmllbGRzLmxpdGVyYWwodmFsKSkuZGVzYyhcImJvb2xlYW5cIiksXG4gICAgZGF0ZUZpZWxkOiBxID0+XG4gICAgICAgIFAuc2VxTWFwKFxuICAgICAgICAgICAgUC5zdHJpbmcoXCJkYXRlKFwiKSxcbiAgICAgICAgICAgIFAub3B0V2hpdGVzcGFjZSxcbiAgICAgICAgICAgIHEuZGF0ZVBsdXMsXG4gICAgICAgICAgICBQLm9wdFdoaXRlc3BhY2UsXG4gICAgICAgICAgICBQLnN0cmluZyhcIilcIiksXG4gICAgICAgICAgICAocHJlZml4LCBfMSwgZGF0ZSwgXzIsIHBvc3RmaXgpID0+IEZpZWxkcy5saXRlcmFsKGRhdGUpXG4gICAgICAgICkuZGVzYyhcImRhdGVcIiksXG4gICAgZHVyYXRpb25GaWVsZDogcSA9PlxuICAgICAgICBQLnNlcU1hcChcbiAgICAgICAgICAgIFAuc3RyaW5nKFwiZHVyKFwiKSxcbiAgICAgICAgICAgIFAub3B0V2hpdGVzcGFjZSxcbiAgICAgICAgICAgIHEuZHVyYXRpb24sXG4gICAgICAgICAgICBQLm9wdFdoaXRlc3BhY2UsXG4gICAgICAgICAgICBQLnN0cmluZyhcIilcIiksXG4gICAgICAgICAgICAocHJlZml4LCBfMSwgZHVyLCBfMiwgcG9zdGZpeCkgPT4gRmllbGRzLmxpdGVyYWwoZHVyKVxuICAgICAgICApLmRlc2MoXCJkdXJhdGlvblwiKSxcbiAgICBudWxsRmllbGQ6IHEgPT4gcS5yYXdOdWxsLm1hcChfID0+IEZpZWxkcy5OVUxMKSxcbiAgICBsaW5rRmllbGQ6IHEgPT4gcS5saW5rLm1hcChmID0+IEZpZWxkcy5saXRlcmFsKGYpKSxcbiAgICBsaXN0RmllbGQ6IHEgPT5cbiAgICAgICAgcS5maWVsZFxuICAgICAgICAgICAgLnNlcEJ5KFAuc3RyaW5nKFwiLFwiKS50cmltKFAub3B0V2hpdGVzcGFjZSkpXG4gICAgICAgICAgICAud3JhcChQLnN0cmluZyhcIltcIikuc2tpcChQLm9wdFdoaXRlc3BhY2UpLCBQLm9wdFdoaXRlc3BhY2UudGhlbihQLnN0cmluZyhcIl1cIikpKVxuICAgICAgICAgICAgLm1hcChsID0+IEZpZWxkcy5saXN0KGwpKVxuICAgICAgICAgICAgLmRlc2MoXCJsaXN0ICgnWzEsIDIsIDNdJylcIiksXG4gICAgb2JqZWN0RmllbGQ6IHEgPT5cbiAgICAgICAgUC5zZXFNYXAocS5pZGVudGlmaWVyLm9yKHEuc3RyaW5nKSwgUC5zdHJpbmcoXCI6XCIpLnRyaW0oUC5vcHRXaGl0ZXNwYWNlKSwgcS5maWVsZCwgKG5hbWUsIF9zZXAsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyBuYW1lLCB2YWx1ZSB9O1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnNlcEJ5KFAuc3RyaW5nKFwiLFwiKS50cmltKFAub3B0V2hpdGVzcGFjZSkpXG4gICAgICAgICAgICAud3JhcChQLnN0cmluZyhcIntcIikuc2tpcChQLm9wdFdoaXRlc3BhY2UpLCBQLm9wdFdoaXRlc3BhY2UudGhlbihQLnN0cmluZyhcIn1cIikpKVxuICAgICAgICAgICAgLm1hcCh2YWxzID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzOiBSZWNvcmQ8c3RyaW5nLCBGaWVsZD4gPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBlbnRyeSBvZiB2YWxzKSByZXNbZW50cnkubmFtZV0gPSBlbnRyeS52YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gRmllbGRzLm9iamVjdChyZXMpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5kZXNjKFwib2JqZWN0ICgneyBhOiAxLCBiOiAyIH0nKVwiKSxcblxuICAgIGF0b21JbmxpbmVGaWVsZDogcSA9PlxuICAgICAgICBQLmFsdChcbiAgICAgICAgICAgIHEuZGF0ZSxcbiAgICAgICAgICAgIHEuZHVyYXRpb24ubWFwKGQgPT4gbm9ybWFsaXplRHVyYXRpb24oZCkpLFxuICAgICAgICAgICAgcS5zdHJpbmcsXG4gICAgICAgICAgICBxLnRhZyxcbiAgICAgICAgICAgIHEuZW1iZWRMaW5rLFxuICAgICAgICAgICAgcS5ib29sLFxuICAgICAgICAgICAgcS5udW1iZXIsXG4gICAgICAgICAgICBxLnJhd051bGxcbiAgICAgICAgKSxcbiAgICBpbmxpbmVGaWVsZExpc3Q6IHEgPT4gcS5hdG9tSW5saW5lRmllbGQuc2VwQnkoUC5zdHJpbmcoXCIsXCIpLnRyaW0oUC5vcHRXaGl0ZXNwYWNlKS5sb29rYWhlYWQocS5hdG9tSW5saW5lRmllbGQpKSxcbiAgICBpbmxpbmVGaWVsZDogcSA9PlxuICAgICAgICBQLmFsdChcbiAgICAgICAgICAgIFAuc2VxTWFwKHEuYXRvbUlubGluZUZpZWxkLCBQLnN0cmluZyhcIixcIikudHJpbShQLm9wdFdoaXRlc3BhY2UpLCBxLmlubGluZUZpZWxkTGlzdCwgKGYsIF9zLCBsKSA9PlxuICAgICAgICAgICAgICAgIFtmXS5jb25jYXQobClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBxLmF0b21JbmxpbmVGaWVsZFxuICAgICAgICApLFxuXG4gICAgYXRvbUZpZWxkOiBxID0+XG4gICAgICAgIFAuYWx0KFxuICAgICAgICAgICAgLy8gUGxhY2UgZW1iZWQgbGlua3MgYWJvdmUgbmVnYXRlZCBmaWVsZHMgYXMgdGhleSBhcmUgdGhlIHNwZWNpYWwgcGFyc2VyIGNhc2UgJyFbW3RoaW5nXV0nIGFuZCBhcmUgZ2VuZXJhbGx5IHVuYW1iaWdpb3VzLlxuICAgICAgICAgICAgcS5lbWJlZExpbmsubWFwKGwgPT4gRmllbGRzLmxpdGVyYWwobCkpLFxuICAgICAgICAgICAgcS5uZWdhdGVkRmllbGQsXG4gICAgICAgICAgICBxLmxpbmtGaWVsZCxcbiAgICAgICAgICAgIHEubGlzdEZpZWxkLFxuICAgICAgICAgICAgcS5vYmplY3RGaWVsZCxcbiAgICAgICAgICAgIHEubGFtYmRhRmllbGQsXG4gICAgICAgICAgICBxLnBhcmVuc0ZpZWxkLFxuICAgICAgICAgICAgcS5ib29sRmllbGQsXG4gICAgICAgICAgICBxLm51bWJlckZpZWxkLFxuICAgICAgICAgICAgcS5zdHJpbmdGaWVsZCxcbiAgICAgICAgICAgIHEuZGF0ZUZpZWxkLFxuICAgICAgICAgICAgcS5kdXJhdGlvbkZpZWxkLFxuICAgICAgICAgICAgcS5udWxsRmllbGQsXG4gICAgICAgICAgICBxLnZhcmlhYmxlRmllbGRcbiAgICAgICAgKSxcbiAgICBpbmRleEZpZWxkOiBxID0+XG4gICAgICAgIFAuc2VxTWFwKHEuYXRvbUZpZWxkLCBQLmFsdChxLmRvdFBvc3RmaXgsIHEuaW5kZXhQb3N0Zml4LCBxLmZ1bmN0aW9uUG9zdGZpeCkubWFueSgpLCAob2JqLCBwb3N0Zml4ZXMpID0+IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBvYmo7XG4gICAgICAgICAgICBmb3IgKGxldCBwb3N0IG9mIHBvc3RmaXhlcykge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAocG9zdC50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkb3RcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IEZpZWxkcy5pbmRleChyZXN1bHQsIEZpZWxkcy5saXRlcmFsKHBvc3QuZmllbGQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaW5kZXhcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IEZpZWxkcy5pbmRleChyZXN1bHQsIHBvc3QuZmllbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gRmllbGRzLmZ1bmMocmVzdWx0LCBwb3N0LmZpZWxkcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pLFxuICAgIG5lZ2F0ZWRGaWVsZDogcSA9PiBQLnNlcU1hcChQLnN0cmluZyhcIiFcIiksIHEuaW5kZXhGaWVsZCwgKF8sIGZpZWxkKSA9PiBGaWVsZHMubmVnYXRlKGZpZWxkKSkuZGVzYyhcIm5lZ2F0ZWQgZmllbGRcIiksXG4gICAgcGFyZW5zRmllbGQ6IHEgPT5cbiAgICAgICAgUC5zZXFNYXAoXG4gICAgICAgICAgICBQLnN0cmluZyhcIihcIiksXG4gICAgICAgICAgICBQLm9wdFdoaXRlc3BhY2UsXG4gICAgICAgICAgICBxLmZpZWxkLFxuICAgICAgICAgICAgUC5vcHRXaGl0ZXNwYWNlLFxuICAgICAgICAgICAgUC5zdHJpbmcoXCIpXCIpLFxuICAgICAgICAgICAgKF8xLCBfMiwgZmllbGQsIF8zLCBfNCkgPT4gZmllbGRcbiAgICAgICAgKSxcbiAgICBsYW1iZGFGaWVsZDogcSA9PlxuICAgICAgICBQLnNlcU1hcChcbiAgICAgICAgICAgIHEuaWRlbnRpZmllclxuICAgICAgICAgICAgICAgIC5zZXBCeShQLnN0cmluZyhcIixcIikudHJpbShQLm9wdFdoaXRlc3BhY2UpKVxuICAgICAgICAgICAgICAgIC53cmFwKFAuc3RyaW5nKFwiKFwiKS50cmltKFAub3B0V2hpdGVzcGFjZSksIFAuc3RyaW5nKFwiKVwiKS50cmltKFAub3B0V2hpdGVzcGFjZSkpLFxuICAgICAgICAgICAgUC5zdHJpbmcoXCI9PlwiKS50cmltKFAub3B0V2hpdGVzcGFjZSksXG4gICAgICAgICAgICBxLmZpZWxkLFxuICAgICAgICAgICAgKGlkZW50LCBfaWdub3JlLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwibGFtYmRhXCIsIGFyZ3VtZW50czogaWRlbnQsIHZhbHVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICksXG5cbiAgICBkb3RQb3N0Zml4OiBxID0+XG4gICAgICAgIFAuc2VxTWFwKFAuc3RyaW5nKFwiLlwiKSwgcS5pZGVudGlmaWVyLCAoXywgZmllbGQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiZG90XCIsIGZpZWxkOiBmaWVsZCB9O1xuICAgICAgICB9KSxcbiAgICBpbmRleFBvc3RmaXg6IHEgPT5cbiAgICAgICAgUC5zZXFNYXAoUC5zdHJpbmcoXCJbXCIpLCBQLm9wdFdoaXRlc3BhY2UsIHEuZmllbGQsIFAub3B0V2hpdGVzcGFjZSwgUC5zdHJpbmcoXCJdXCIpLCAoXywgXzIsIGZpZWxkLCBfMywgXzQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiaW5kZXhcIiwgZmllbGQgfTtcbiAgICAgICAgfSksXG4gICAgZnVuY3Rpb25Qb3N0Zml4OiBxID0+XG4gICAgICAgIFAuc2VxTWFwKFxuICAgICAgICAgICAgUC5zdHJpbmcoXCIoXCIpLFxuICAgICAgICAgICAgUC5vcHRXaGl0ZXNwYWNlLFxuICAgICAgICAgICAgcS5maWVsZC5zZXBCeShQLnN0cmluZyhcIixcIikudHJpbShQLm9wdFdoaXRlc3BhY2UpKSxcbiAgICAgICAgICAgIFAub3B0V2hpdGVzcGFjZSxcbiAgICAgICAgICAgIFAuc3RyaW5nKFwiKVwiKSxcbiAgICAgICAgICAgIChfLCBfMSwgZmllbGRzLCBfMiwgXzMpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImZ1bmN0aW9uXCIsIGZpZWxkcyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICApLFxuXG4gICAgLy8gVGhlIHByZWNlZGVuY2UgaGllcmFyY2h5IG9mIG9wZXJhdG9ycyAtIG11bHRpcGx5L2RpdmlkZSwgYWRkL3N1YnRyYWN0LCBjb21wYXJlLCBhbmQgdGhlbiBib29sZWFuIG9wZXJhdGlvbnMuXG4gICAgYmluYXJ5TXVsRGl2RmllbGQ6IHEgPT4gY3JlYXRlQmluYXJ5UGFyc2VyKHEuaW5kZXhGaWVsZCwgcS5iaW5hcnlNdWxEaXYsIEZpZWxkcy5iaW5hcnlPcCksXG4gICAgYmluYXJ5UGx1c01pbnVzRmllbGQ6IHEgPT4gY3JlYXRlQmluYXJ5UGFyc2VyKHEuYmluYXJ5TXVsRGl2RmllbGQsIHEuYmluYXJ5UGx1c01pbnVzLCBGaWVsZHMuYmluYXJ5T3ApLFxuICAgIGJpbmFyeUNvbXBhcmVGaWVsZDogcSA9PiBjcmVhdGVCaW5hcnlQYXJzZXIocS5iaW5hcnlQbHVzTWludXNGaWVsZCwgcS5iaW5hcnlDb21wYXJlT3AsIEZpZWxkcy5iaW5hcnlPcCksXG4gICAgYmluYXJ5Qm9vbGVhbkZpZWxkOiBxID0+IGNyZWF0ZUJpbmFyeVBhcnNlcihxLmJpbmFyeUNvbXBhcmVGaWVsZCwgcS5iaW5hcnlCb29sZWFuT3AsIEZpZWxkcy5iaW5hcnlPcCksXG4gICAgYmluYXJ5T3BGaWVsZDogcSA9PiBxLmJpbmFyeUJvb2xlYW5GaWVsZCxcblxuICAgIGZpZWxkOiBxID0+IHEuYmluYXJ5T3BGaWVsZCxcbn0pO1xuXG4vKipcbiAqIEF0dGVtcHQgdG8gcGFyc2UgYSBmaWVsZCBmcm9tIHRoZSBnaXZlbiB0ZXh0LCByZXR1cm5pbmcgYSBzdHJpbmcgZXJyb3IgaWYgdGhlXG4gKiBwYXJzZSBmYWlsZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUZpZWxkKHRleHQ6IHN0cmluZyk6IFJlc3VsdDxGaWVsZCwgc3RyaW5nPiB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIFJlc3VsdC5zdWNjZXNzKEVYUFJFU1NJT04uZmllbGQudHJ5UGFyc2UodGV4dCkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBSZXN1bHQuZmFpbHVyZShcIlwiICsgZXJyb3IpO1xuICAgIH1cbn1cbiIsICIvKiogUHJvdmlkZXMgYW4gQVNUIGZvciBjb21wbGV4IHF1ZXJpZXMuICovXG5pbXBvcnQgeyBTb3VyY2UgfSBmcm9tIFwiZGF0YS1pbmRleC9zb3VyY2VcIjtcbmltcG9ydCB7IEZpZWxkIH0gZnJvbSBcImV4cHJlc3Npb24vZmllbGRcIjtcblxuLyoqIFRoZSBzdXBwb3J0ZWQgcXVlcnkgdHlwZXMgKGNvcnJlc3BvbmRpbmcgdG8gdmlldyB0eXBlcykuICovXG5leHBvcnQgdHlwZSBRdWVyeVR5cGUgPSBcImxpc3RcIiB8IFwidGFibGVcIiB8IFwidGFza1wiIHwgXCJjYWxlbmRhclwiO1xuXG4vKiogQSBzaW5nbGUtbGluZSBjb21tZW50LiAqL1xuZXhwb3J0IHR5cGUgQ29tbWVudCA9IHN0cmluZztcblxuLyoqIEZpZWxkcyB1c2VkIGluIHRoZSBxdWVyeSBwb3J0aW9uLiAqL1xuZXhwb3J0IGludGVyZmFjZSBOYW1lZEZpZWxkIHtcbiAgICAvKiogVGhlIGVmZmVjdGl2ZSBuYW1lIG9mIHRoaXMgZmllbGQuICovXG4gICAgbmFtZTogc3RyaW5nO1xuICAgIC8qKiBUaGUgdmFsdWUgb2YgdGhpcyBmaWVsZC4gKi9cbiAgICBmaWVsZDogRmllbGQ7XG59XG5cbi8qKiBBIHF1ZXJ5IHNvcnQgYnkgZmllbGQsIGZvciBkZXRlcm1pbmluZyBzb3J0IG9yZGVyLiAqL1xuZXhwb3J0IGludGVyZmFjZSBRdWVyeVNvcnRCeSB7XG4gICAgLyoqIFRoZSBmaWVsZCB0byBzb3J0IG9uLiAqL1xuICAgIGZpZWxkOiBGaWVsZDtcbiAgICAvKiogVGhlIGRpcmVjdGlvbiB0byBzb3J0IGluLiAqL1xuICAgIGRpcmVjdGlvbjogXCJhc2NlbmRpbmdcIiB8IFwiZGVzY2VuZGluZ1wiO1xufVxuXG4vKiogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIHF1aWNrbHkgY3JlYXRpbmcgZmllbGRzLiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBRdWVyeUZpZWxkcyB7XG4gICAgZXhwb3J0IGZ1bmN0aW9uIG5hbWVkKG5hbWU6IHN0cmluZywgZmllbGQ6IEZpZWxkKTogTmFtZWRGaWVsZCB7XG4gICAgICAgIHJldHVybiB7IG5hbWUsIGZpZWxkIH0gYXMgTmFtZWRGaWVsZDtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gc29ydEJ5KGZpZWxkOiBGaWVsZCwgZGlyOiBcImFzY2VuZGluZ1wiIHwgXCJkZXNjZW5kaW5nXCIpOiBRdWVyeVNvcnRCeSB7XG4gICAgICAgIHJldHVybiB7IGZpZWxkLCBkaXJlY3Rpb246IGRpciB9O1xuICAgIH1cbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gUXVlcnkgRGVmaW5pdGlvbiAvL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKiogQSBxdWVyeSB3aGljaCBzaG91bGQgcmVuZGVyIGEgbGlzdCBvZiBlbGVtZW50cy4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTGlzdFF1ZXJ5IHtcbiAgICB0eXBlOiBcImxpc3RcIjtcbiAgICAvKiogV2hhdCBzaG91bGQgYmUgcmVuZGVyZWQgaW4gdGhlIGxpc3QuICovXG4gICAgZm9ybWF0PzogRmllbGQ7XG4gICAgLyoqIElmIHRydWUsIHNob3cgdGhlIGRlZmF1bHQgREkgZmllbGQ7IG90aGVyd2lzZSwgZG9uJ3QuICovXG4gICAgc2hvd0lkOiBib29sZWFuO1xufVxuXG4vKiogQSBxdWVyeSB3aGljaCByZW5kZXJzIGEgdGFibGUgb2YgZWxlbWVudHMuICovXG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlUXVlcnkge1xuICAgIHR5cGU6IFwidGFibGVcIjtcbiAgICAvKiogVGhlIGZpZWxkcyAoY29tcHV0ZWQgb3Igb3RoZXJ3aXNlKSB0byBzZWxlY3QuICovXG4gICAgZmllbGRzOiBOYW1lZEZpZWxkW107XG4gICAgLyoqIElmIHRydWUsIHNob3cgdGhlIGRlZmF1bHQgSUQgZmllbGQ7IG90aGVyd2lzZSwgZG9uJ3QuICovXG4gICAgc2hvd0lkOiBib29sZWFuO1xufVxuXG4vKiogQSBxdWVyeSB3aGljaCByZW5kZXJzIGEgY29sbGVjdGlvbiBvZiB0YXNrcy4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGFza1F1ZXJ5IHtcbiAgICB0eXBlOiBcInRhc2tcIjtcbn1cblxuLyoqIEEgcXVlcnkgd2hpY2ggcmVuZGVycyBhIGNvbGxlY3Rpb24gb2Ygbm90ZXMgaW4gYSBjYWxlbmRhciB2aWV3LiAqL1xuZXhwb3J0IGludGVyZmFjZSBDYWxlbmRhclF1ZXJ5IHtcbiAgICB0eXBlOiBcImNhbGVuZGFyXCI7XG4gICAgLyoqIFRoZSBkYXRlIGZpZWxkIHRoYXQgd2UnbGwgYmUgZ3JvdXBpbmcgbm90ZXMgYnkgZm9yIHRoZSBjYWxlbmRhciB2aWV3ICovXG4gICAgZmllbGQ6IE5hbWVkRmllbGQ7XG59XG5cbmV4cG9ydCB0eXBlIFF1ZXJ5SGVhZGVyID0gTGlzdFF1ZXJ5IHwgVGFibGVRdWVyeSB8IFRhc2tRdWVyeSB8IENhbGVuZGFyUXVlcnk7XG5cbi8qKiBBIHN0ZXAgd2hpY2ggb25seSByZXRhaW5zIHJvd3Mgd2hvc2UgJ2NsYXVzZScgZmllbGQgaXMgdHJ1dGh5LiAqL1xuZXhwb3J0IGludGVyZmFjZSBXaGVyZVN0ZXAge1xuICAgIHR5cGU6IFwid2hlcmVcIjtcbiAgICBjbGF1c2U6IEZpZWxkO1xufVxuXG4vKiogQSBzdGVwIHdoaWNoIHNvcnRzIGFsbCBjdXJyZW50IHJvd3MgYnkgdGhlIGdpdmVuIGxpc3Qgb2Ygc29ydHMuICovXG5leHBvcnQgaW50ZXJmYWNlIFNvcnRCeVN0ZXAge1xuICAgIHR5cGU6IFwic29ydFwiO1xuICAgIGZpZWxkczogUXVlcnlTb3J0QnlbXTtcbn1cblxuLyoqIEEgc3RlcCB3aGljaCB0cnVuY2F0ZXMgdGhlIG51bWJlciBvZiByb3dzIHRvIHRoZSBnaXZlbiBhbW91bnQuICovXG5leHBvcnQgaW50ZXJmYWNlIExpbWl0U3RlcCB7XG4gICAgdHlwZTogXCJsaW1pdFwiO1xuICAgIGFtb3VudDogRmllbGQ7XG59XG5cbi8qKiBBIHN0ZXAgd2hpY2ggZmxhdHRlbnMgcm93cyBpbnRvIG11bHRpcGxlIGNoaWxkIHJvd3MuICovXG5leHBvcnQgaW50ZXJmYWNlIEZsYXR0ZW5TdGVwIHtcbiAgICB0eXBlOiBcImZsYXR0ZW5cIjtcbiAgICBmaWVsZDogTmFtZWRGaWVsZDtcbn1cblxuLyoqIEEgc3RlcCB3aGljaCBncm91cHMgcm93cyBpbnRvIGdyb3VwcyBieSB0aGUgZ2l2ZW4gZmllbGQuICovXG5leHBvcnQgaW50ZXJmYWNlIEdyb3VwU3RlcCB7XG4gICAgdHlwZTogXCJncm91cFwiO1xuICAgIGZpZWxkOiBOYW1lZEZpZWxkO1xufVxuXG4vKiogQSB2aXJ0dWFsIHN0ZXAgd2hpY2ggZXh0cmFjdHMgYW4gYXJyYXkgb2YgdmFsdWVzIGZyb20gZWFjaCByb3cuICovXG5leHBvcnQgaW50ZXJmYWNlIEV4dHJhY3RTdGVwIHtcbiAgICB0eXBlOiBcImV4dHJhY3RcIjtcbiAgICBmaWVsZHM6IFJlY29yZDxzdHJpbmcsIEZpZWxkPjtcbn1cblxuZXhwb3J0IHR5cGUgUXVlcnlPcGVyYXRpb24gPSBXaGVyZVN0ZXAgfCBTb3J0QnlTdGVwIHwgTGltaXRTdGVwIHwgRmxhdHRlblN0ZXAgfCBHcm91cFN0ZXAgfCBFeHRyYWN0U3RlcDtcblxuLyoqXG4gKiBBIHF1ZXJ5IG92ZXIgdGhlIE9ic2lkaWFuIGRhdGFiYXNlLiBRdWVyaWVzIGhhdmUgYSBzcGVjaWZpYyBhbmQgZGV0ZXJtaW5pc3RpYyBleGVjdXRpb24gb3JkZXI6XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUXVlcnkge1xuICAgIC8qKiBUaGUgdmlldyB0eXBlIHRvIHJlbmRlciB0aGlzIHF1ZXJ5IGluLiAqL1xuICAgIGhlYWRlcjogUXVlcnlIZWFkZXI7XG4gICAgLyoqIFRoZSBzb3VyY2UgdGhhdCBmaWxlIGNhbmRpZGF0ZXMgd2lsbCBjb21lIGZyb20uICovXG4gICAgc291cmNlOiBTb3VyY2U7XG4gICAgLyoqIFRoZSBvcGVyYXRpb25zIHRvIGFwcGx5IHRvIHRoZSBkYXRhIHRvIHByb2R1Y2UgdGhlIGZpbmFsIHJlc3VsdCB0aGF0IHdpbGwgYmUgcmVuZGVyZWQuICovXG4gICAgb3BlcmF0aW9uczogUXVlcnlPcGVyYXRpb25bXTtcbn1cbiIsICJpbXBvcnQgeyBFWFBSRVNTSU9OIH0gZnJvbSBcImV4cHJlc3Npb24vcGFyc2VcIjtcbmltcG9ydCAqIGFzIFAgZnJvbSBcInBhcnNpbW1vblwiO1xuaW1wb3J0IHtcbiAgICBGbGF0dGVuU3RlcCxcbiAgICBHcm91cFN0ZXAsXG4gICAgTGltaXRTdGVwLFxuICAgIE5hbWVkRmllbGQsXG4gICAgUXVlcnksXG4gICAgUXVlcnlGaWVsZHMsXG4gICAgUXVlcnlIZWFkZXIsXG4gICAgUXVlcnlPcGVyYXRpb24sXG4gICAgUXVlcnlTb3J0QnksXG4gICAgUXVlcnlUeXBlLFxuICAgIFNvcnRCeVN0ZXAsXG4gICAgV2hlcmVTdGVwLFxuICAgIENvbW1lbnQsXG59IGZyb20gXCIuL3F1ZXJ5XCI7XG5pbXBvcnQgeyBTb3VyY2UsIFNvdXJjZXMgfSBmcm9tIFwiZGF0YS1pbmRleC9zb3VyY2VcIjtcbmltcG9ydCB7IERFRkFVTFRfUVVFUllfU0VUVElOR1MgfSBmcm9tIFwic2V0dGluZ3NcIjtcbmltcG9ydCB7IFJlc3VsdCB9IGZyb20gXCJhcGkvcmVzdWx0XCI7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFF1ZXJ5IFBhcnNpbmcgLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqIFR5cGluZ3MgZm9yIHRoZSBvdXRwdXRzIG9mIGFsbCBvZiB0aGUgcGFyc2VyIGNvbWJpbmF0b3JzLiAqL1xuaW50ZXJmYWNlIFF1ZXJ5TGFuZ3VhZ2VUeXBlcyB7XG4gICAgcXVlcnlUeXBlOiBRdWVyeVR5cGU7XG4gICAgY29tbWVudDogQ29tbWVudDtcblxuICAgIGV4cGxpY2l0TmFtZWRGaWVsZDogTmFtZWRGaWVsZDtcbiAgICBuYW1lZEZpZWxkOiBOYW1lZEZpZWxkO1xuICAgIHNvcnRGaWVsZDogUXVlcnlTb3J0Qnk7XG5cbiAgICAvLyBFbnRpcmUgY2xhdXNlcyBpbiBxdWVyaWVzLlxuICAgIGhlYWRlckNsYXVzZTogUXVlcnlIZWFkZXI7XG4gICAgZnJvbUNsYXVzZTogU291cmNlO1xuICAgIHdoZXJlQ2xhdXNlOiBXaGVyZVN0ZXA7XG4gICAgc29ydEJ5Q2xhdXNlOiBTb3J0QnlTdGVwO1xuICAgIGxpbWl0Q2xhdXNlOiBMaW1pdFN0ZXA7XG4gICAgZmxhdHRlbkNsYXVzZTogRmxhdHRlblN0ZXA7XG4gICAgZ3JvdXBCeUNsYXVzZTogR3JvdXBTdGVwO1xuICAgIGNsYXVzZTogUXVlcnlPcGVyYXRpb247XG4gICAgcXVlcnk6IFF1ZXJ5O1xufVxuXG4vKiogUmV0dXJuIGEgbmV3IHBhcnNlciB3aGljaCBleGVjdXRlcyB0aGUgdW5kZXJseWluZyBwYXJzZXIgYW5kIHJldHVybnMgaXQncyByYXcgc3RyaW5nIHJlcHJlc2VudGF0aW9uLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhcHR1cmVSYXc8VD4oYmFzZTogUC5QYXJzZXI8VD4pOiBQLlBhcnNlcjxbVCwgc3RyaW5nXT4ge1xuICAgIHJldHVybiBQLmN1c3RvbSgoc3VjY2VzcywgZmFpbHVyZSkgPT4ge1xuICAgICAgICByZXR1cm4gKGlucHV0LCBpKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gKGJhc2UgYXMgYW55KS5fKGlucHV0LCBpKTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0LnN0YXR1cykgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHJlc3VsdCwgeyB2YWx1ZTogW3Jlc3VsdC52YWx1ZSwgaW5wdXQuc3Vic3RyaW5nKGksIHJlc3VsdC5pbmRleCldIH0pO1xuICAgICAgICB9O1xuICAgIH0pO1xufVxuXG4vKiogU3RyaXAgbmV3bGluZXMgYW5kIGV4Y2VzcyB3aGl0ZXNwYWNlIG91dCBvZiB0ZXh0LiAqL1xuZnVuY3Rpb24gc3RyaXBOZXdsaW5lcyh0ZXh0OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiB0ZXh0XG4gICAgICAgIC5zcGxpdCgvW1xcclxcbl0rLylcbiAgICAgICAgLm1hcCh0ID0+IHQudHJpbSgpKVxuICAgICAgICAuam9pbihcIlwiKTtcbn1cblxuLyoqIEdpdmVuIGBwYXJzZXJgLCByZXR1cm4gdGhlIHBhcnNlciB0aGF0IHJldHVybnMgYGlmX2VvZigpYCBpZiBFT0YgaXMgZm91bmQsXG4gKiBvdGhlcndpc2UgYHBhcnNlcmAgcHJlY2VkZWQgYnkgKG5vbi1vcHRpb25hbCkgd2hpdGVzcGFjZSAqL1xuZnVuY3Rpb24gcHJlY2VkZWRCeVdoaXRlc3BhY2VJZk5vdEVvZjxUPihpZl9lb2Y6IChfOiB1bmRlZmluZWQpID0+IFQsIHBhcnNlcjogUC5QYXJzZXI8VD4pOiBQLlBhcnNlcjxUPiB7XG4gICAgcmV0dXJuIFAuZW9mLm1hcChpZl9lb2YpLm9yKFAud2hpdGVzcGFjZS50aGVuKHBhcnNlcikpO1xufVxuXG4vKiogQSBwYXJzaW1tb24tcG93ZXJlZCBwYXJzZXItY29tYmluYXRvciBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgcXVlcnkgbGFuZ3VhZ2UuICovXG5leHBvcnQgY29uc3QgUVVFUllfTEFOR1VBR0UgPSBQLmNyZWF0ZUxhbmd1YWdlPFF1ZXJ5TGFuZ3VhZ2VUeXBlcz4oe1xuICAgIC8vIFNpbXBsZSBhdG9tIHBhcnNpbmcsIGxpa2Ugd29yZHMsIGlkZW50aWZpZXJzLCBudW1iZXJzLlxuICAgIHF1ZXJ5VHlwZTogcSA9PlxuICAgICAgICBQLmFsdDxzdHJpbmc+KFAucmVnZXhwKC9UQUJMRXxMSVNUfFRBU0t8Q0FMRU5EQVIvaSkpXG4gICAgICAgICAgICAubWFwKHN0ciA9PiBzdHIudG9Mb3dlckNhc2UoKSBhcyBRdWVyeVR5cGUpXG4gICAgICAgICAgICAuZGVzYyhcInF1ZXJ5IHR5cGUgKCdUQUJMRScsICdMSVNUJywgJ1RBU0snLCBvciAnQ0FMRU5EQVInKVwiKSxcbiAgICBleHBsaWNpdE5hbWVkRmllbGQ6IHEgPT5cbiAgICAgICAgUC5zZXFNYXAoXG4gICAgICAgICAgICBFWFBSRVNTSU9OLmZpZWxkLnNraXAoUC53aGl0ZXNwYWNlKSxcbiAgICAgICAgICAgIFAucmVnZXhwKC9BUy9pKS5za2lwKFAud2hpdGVzcGFjZSksXG4gICAgICAgICAgICBFWFBSRVNTSU9OLmlkZW50aWZpZXIub3IoRVhQUkVTU0lPTi5zdHJpbmcpLFxuICAgICAgICAgICAgKGZpZWxkLCBfYXMsIGlkZW50KSA9PiBRdWVyeUZpZWxkcy5uYW1lZChpZGVudCwgZmllbGQpXG4gICAgICAgICksXG4gICAgY29tbWVudDogKCkgPT5cbiAgICAgICAgUC5QYXJzZXIoKGlucHV0LCBpKSA9PiB7XG4gICAgICAgICAgICAvLyBQYXJzZSBhIGNvbW1lbnQsIHdoaWNoIGlzIGEgbGluZSBzdGFydGluZyB3aXRoIC8vLlxuICAgICAgICAgICAgbGV0IGxpbmUgPSBpbnB1dC5zdWJzdHJpbmcoaSk7XG4gICAgICAgICAgICBpZiAoIWxpbmUuc3RhcnRzV2l0aChcIi8vXCIpKSByZXR1cm4gUC5tYWtlRmFpbHVyZShpLCBcIk5vdCBhIGNvbW1lbnRcIik7XG4gICAgICAgICAgICAvLyBUaGUgY29tbWVudCBlbmRzIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4gICAgICAgICAgICBsaW5lID0gbGluZS5zcGxpdChcIlxcblwiKVswXTtcbiAgICAgICAgICAgIGxldCBjb21tZW50ID0gbGluZS5zdWJzdHJpbmcoMikudHJpbSgpO1xuICAgICAgICAgICAgcmV0dXJuIFAubWFrZVN1Y2Nlc3MoaSArIGxpbmUubGVuZ3RoLCBjb21tZW50KTtcbiAgICAgICAgfSksXG4gICAgbmFtZWRGaWVsZDogcSA9PlxuICAgICAgICBQLmFsdDxOYW1lZEZpZWxkPihcbiAgICAgICAgICAgIHEuZXhwbGljaXROYW1lZEZpZWxkLFxuICAgICAgICAgICAgY2FwdHVyZVJhdyhFWFBSRVNTSU9OLmZpZWxkKS5tYXAoKFt2YWx1ZSwgdGV4dF0pID0+IFF1ZXJ5RmllbGRzLm5hbWVkKHN0cmlwTmV3bGluZXModGV4dCksIHZhbHVlKSlcbiAgICAgICAgKSxcbiAgICBzb3J0RmllbGQ6IHEgPT5cbiAgICAgICAgUC5zZXFNYXAoXG4gICAgICAgICAgICBFWFBSRVNTSU9OLmZpZWxkLnNraXAoUC5vcHRXaGl0ZXNwYWNlKSxcbiAgICAgICAgICAgIFAucmVnZXhwKC9BU0NFTkRJTkd8REVTQ0VORElOR3xBU0N8REVTQy9pKS5hdE1vc3QoMSksXG4gICAgICAgICAgICAoZmllbGQsIGRpcikgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBkaXJlY3Rpb24gPSBkaXIubGVuZ3RoID09IDAgPyBcImFzY2VuZGluZ1wiIDogZGlyWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PSBcImRlc2NcIikgZGlyZWN0aW9uID0gXCJkZXNjZW5kaW5nXCI7XG4gICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PSBcImFzY1wiKSBkaXJlY3Rpb24gPSBcImFzY2VuZGluZ1wiO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb24gYXMgXCJhc2NlbmRpbmdcIiB8IFwiZGVzY2VuZGluZ1wiLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICksXG5cbiAgICBoZWFkZXJDbGF1c2U6IHEgPT5cbiAgICAgICAgcS5xdWVyeVR5cGVcbiAgICAgICAgICAgIC5jaGFpbih0eXBlID0+IHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRhYmxlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmVjZWRlZEJ5V2hpdGVzcGFjZUlmTm90RW9mKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgpID0+ICh7IHR5cGUsIGZpZWxkczogW10sIHNob3dJZDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQLnNlcU1hcChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUC5yZWdleHAoL1dJVEhPVVRcXHMrSUQvaSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5za2lwKFAub3B0V2hpdGVzcGFjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdE1vc3QoMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFAuc2VwQnkocS5uYW1lZEZpZWxkLCBQLnN0cmluZyhcIixcIikudHJpbShQLm9wdFdoaXRlc3BhY2UpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHdpdGhvdXRJZCwgZmllbGRzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlLCBmaWVsZHMsIHNob3dJZDogd2l0aG91dElkLmxlbmd0aCA9PSAwIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJsaXN0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJlY2VkZWRCeVdoaXRlc3BhY2VJZk5vdEVvZihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKSA9PiAoeyB0eXBlLCBmb3JtYXQ6IHVuZGVmaW5lZCwgc2hvd0lkOiB0cnVlIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFAuc2VxTWFwKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQLnJlZ2V4cCgvV0lUSE9VVFxccytJRC9pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNraXAoUC5vcHRXaGl0ZXNwYWNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0TW9zdCgxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRVhQUkVTU0lPTi5maWVsZC5hdE1vc3QoMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh3aXRob3V0SWQsIGZvcm1hdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdDogZm9ybWF0Lmxlbmd0aCA9PSAxID8gZm9ybWF0WzBdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3dJZDogd2l0aG91dElkLmxlbmd0aCA9PSAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0YXNrXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUC5zdWNjZWVkKHsgdHlwZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNhbGVuZGFyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUC53aGl0ZXNwYWNlLnRoZW4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUC5zZXFNYXAocS5uYW1lZEZpZWxkLCBmaWVsZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvd0lkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gYXMgUXVlcnlIZWFkZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUC5mYWlsKGBVbnJlY29nbml6ZWQgcXVlcnkgdHlwZSAnJHt0eXBlfSdgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmRlc2MoXCJUQUJMRSBvciBMSVNUIG9yIFRBU0sgb3IgQ0FMRU5EQVJcIiksXG4gICAgZnJvbUNsYXVzZTogcSA9PiBQLnNlcU1hcChQLnJlZ2V4cCgvRlJPTS9pKSwgUC53aGl0ZXNwYWNlLCBFWFBSRVNTSU9OLnNvdXJjZSwgKF8xLCBfMiwgc291cmNlKSA9PiBzb3VyY2UpLFxuICAgIHdoZXJlQ2xhdXNlOiBxID0+XG4gICAgICAgIFAuc2VxTWFwKFAucmVnZXhwKC9XSEVSRS9pKSwgUC53aGl0ZXNwYWNlLCBFWFBSRVNTSU9OLmZpZWxkLCAod2hlcmUsIF8sIGZpZWxkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcIndoZXJlXCIsIGNsYXVzZTogZmllbGQgfSBhcyBXaGVyZVN0ZXA7XG4gICAgICAgIH0pLmRlc2MoXCJXSEVSRSA8ZXhwcmVzc2lvbj5cIiksXG4gICAgc29ydEJ5Q2xhdXNlOiBxID0+XG4gICAgICAgIFAuc2VxTWFwKFxuICAgICAgICAgICAgUC5yZWdleHAoL1NPUlQvaSksXG4gICAgICAgICAgICBQLndoaXRlc3BhY2UsXG4gICAgICAgICAgICBxLnNvcnRGaWVsZC5zZXBCeTEoUC5zdHJpbmcoXCIsXCIpLnRyaW0oUC5vcHRXaGl0ZXNwYWNlKSksXG4gICAgICAgICAgICAoc29ydCwgXzEsIGZpZWxkcykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwic29ydFwiLCBmaWVsZHMgfSBhcyBTb3J0QnlTdGVwO1xuICAgICAgICAgICAgfVxuICAgICAgICApLmRlc2MoXCJTT1JUIGZpZWxkIFtBU0MvREVTQ11cIiksXG4gICAgbGltaXRDbGF1c2U6IHEgPT5cbiAgICAgICAgUC5zZXFNYXAoUC5yZWdleHAoL0xJTUlUL2kpLCBQLndoaXRlc3BhY2UsIEVYUFJFU1NJT04uZmllbGQsIChsaW1pdCwgXzEsIGZpZWxkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImxpbWl0XCIsIGFtb3VudDogZmllbGQgfSBhcyBMaW1pdFN0ZXA7XG4gICAgICAgIH0pLmRlc2MoXCJMSU1JVCA8dmFsdWU+XCIpLFxuICAgIGZsYXR0ZW5DbGF1c2U6IHEgPT5cbiAgICAgICAgUC5zZXFNYXAoUC5yZWdleHAoL0ZMQVRURU4vaSkuc2tpcChQLndoaXRlc3BhY2UpLCBxLm5hbWVkRmllbGQsIChfLCBmaWVsZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJmbGF0dGVuXCIsIGZpZWxkIH0gYXMgRmxhdHRlblN0ZXA7XG4gICAgICAgIH0pLmRlc2MoXCJGTEFUVEVOIDx2YWx1ZT4gW0FTIDxuYW1lPl1cIiksXG4gICAgZ3JvdXBCeUNsYXVzZTogcSA9PlxuICAgICAgICBQLnNlcU1hcChQLnJlZ2V4cCgvR1JPVVAgQlkvaSkuc2tpcChQLndoaXRlc3BhY2UpLCBxLm5hbWVkRmllbGQsIChfLCBmaWVsZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJncm91cFwiLCBmaWVsZCB9IGFzIEdyb3VwU3RlcDtcbiAgICAgICAgfSkuZGVzYyhcIkdST1VQIEJZIDx2YWx1ZT4gW0FTIDxuYW1lPl1cIiksXG4gICAgLy8gRnVsbCBxdWVyeSBwYXJzaW5nLlxuICAgIGNsYXVzZTogcSA9PiBQLmFsdChxLmZyb21DbGF1c2UsIHEud2hlcmVDbGF1c2UsIHEuc29ydEJ5Q2xhdXNlLCBxLmxpbWl0Q2xhdXNlLCBxLmdyb3VwQnlDbGF1c2UsIHEuZmxhdHRlbkNsYXVzZSksXG4gICAgcXVlcnk6IHEgPT5cbiAgICAgICAgUC5zZXFNYXAoXG4gICAgICAgICAgICBxLmhlYWRlckNsYXVzZS50cmltKG9wdGlvbmFsV2hpdGVzcGFjZU9yQ29tbWVudCksXG4gICAgICAgICAgICBxLmZyb21DbGF1c2UudHJpbShvcHRpb25hbFdoaXRlc3BhY2VPckNvbW1lbnQpLmF0TW9zdCgxKSxcbiAgICAgICAgICAgIHEuY2xhdXNlLnRyaW0ob3B0aW9uYWxXaGl0ZXNwYWNlT3JDb21tZW50KS5tYW55KCksXG4gICAgICAgICAgICAoaGVhZGVyLCBmcm9tLCBjbGF1c2VzKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGZyb20ubGVuZ3RoID09IDAgPyBTb3VyY2VzLmZvbGRlcihcIlwiKSA6IGZyb21bMF0sXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbnM6IGNsYXVzZXMsXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzOiBERUZBVUxUX1FVRVJZX1NFVFRJTkdTLFxuICAgICAgICAgICAgICAgIH0gYXMgUXVlcnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICksXG59KTtcblxuLyoqXG4gKiBBIHBhcnNlciBmb3Igb3B0aW9uYWwgd2hpdGVzcGFjZSBvciBjb21tZW50cy4gVGhpcyBpcyB1c2VkIHRvIGV4Y2x1ZGUgd2hpdGVzcGFjZSBhbmQgY29tbWVudHMgZnJvbSBvdGhlciBwYXJzZXJzLlxuICovXG5jb25zdCBvcHRpb25hbFdoaXRlc3BhY2VPckNvbW1lbnQ6IFAuUGFyc2VyPHN0cmluZz4gPSBQLmFsdChQLndoaXRlc3BhY2UsIFFVRVJZX0xBTkdVQUdFLmNvbW1lbnQpXG4gICAgLm1hbnkoKSAvLyBVc2UgbWFueSgpIHNpbmNlIHRoZXJlIG1heSBiZSB6ZXJvIHdoaXRlc3BhY2VzIG9yIGNvbW1lbnRzLlxuICAgIC8vIFRyYW5zZm9ybSB0aGUgbWFueSB0byBhIHNpbmdsZSByZXN1bHQuXG4gICAgLm1hcChhcnIgPT4gYXJyLmpvaW4oXCJcIikpO1xuXG4vKipcbiAqIEF0dGVtcHQgdG8gcGFyc2UgYSBxdWVyeSBmcm9tIHRoZSBnaXZlbiBxdWVyeSB0ZXh0LCByZXR1cm5pbmcgYSBzdHJpbmcgZXJyb3JcbiAqIGlmIHRoZSBwYXJzZSBmYWlsZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVF1ZXJ5KHRleHQ6IHN0cmluZyk6IFJlc3VsdDxRdWVyeSwgc3RyaW5nPiB7XG4gICAgdHJ5IHtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gUVVFUllfTEFOR1VBR0UucXVlcnkudHJ5UGFyc2UodGV4dCk7XG4gICAgICAgIHJldHVybiBSZXN1bHQuc3VjY2VzcyhxdWVyeSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIFJlc3VsdC5mYWlsdXJlKFwiXCIgKyBlcnJvcik7XG4gICAgfVxufVxuIiwgIi8vIEJhc2ljIEFQSSB0eXBlLlxuZXhwb3J0IHR5cGUgeyBEYXRhdmlld0FwaSB9IGZyb20gXCJhcGkvcGx1Z2luLWFwaVwiO1xuXG4vLyBDb3JlIERhdGF2aWV3IHR5cGVzLlxuZXhwb3J0IHR5cGUgeyBEYXRlVGltZSwgRHVyYXRpb24gfSBmcm9tIFwibHV4b25cIjtcbmV4cG9ydCB0eXBlIHtcbiAgICBMaW5rLFxuICAgIERhdGFPYmplY3QsXG4gICAgTGl0ZXJhbFR5cGUsXG4gICAgTGl0ZXJhbCxcbiAgICBMaXRlcmFsUmVwcixcbiAgICBXcmFwcGVkTGl0ZXJhbCxcbiAgICBMaXRlcmFsV3JhcHBlcixcbiAgICBXaWRnZXQsXG59IGZyb20gXCJkYXRhLW1vZGVsL3ZhbHVlXCI7XG5cbmV4cG9ydCB0eXBlIHsgUmVzdWx0LCBTdWNjZXNzLCBGYWlsdXJlIH0gZnJvbSBcImFwaS9yZXN1bHRcIjtcbmV4cG9ydCB0eXBlIHsgRGF0YUFycmF5IH0gZnJvbSBcImFwaS9kYXRhLWFycmF5XCI7XG5cbi8vIERhdGF2aWV3IEluZGV4LlxuZXhwb3J0IHR5cGUgeyBMaXN0SXRlbSwgUGFnZU1ldGFkYXRhIH0gZnJvbSBcImRhdGEtbW9kZWwvbWFya2Rvd25cIjtcbmV4cG9ydCB0eXBlIHsgRnVsbEluZGV4LCBQcmVmaXhJbmRleCwgSW5kZXhNYXAgfSBmcm9tIFwiZGF0YS1pbmRleC9pbmRleFwiO1xuXG4vLyBTZXJpYWxpemVkIHR5cGVzIHdoaWNoIGRlc2NyaWJlIGFsbCBvdXRwdXRzIG9mIHNlcmlhbGl6YXRpb24uXG5leHBvcnQgdHlwZSB7IFNNYXJrZG93blBhZ2UsIFNMaXN0RW50cnksIFNUYXNrIH0gZnJvbSBcImRhdGEtbW9kZWwvc2VyaWFsaXplZC9tYXJrZG93blwiO1xuXG4vLyBVc2VmdWwgdXRpbGl0aWVzIGZvciBkaXJlY3RseSB1c2luZyBkYXRhdmlldyBwYXJzZXJzLlxuZXhwb3J0IHtcbiAgICBEVVJBVElPTl9UWVBFUyxcbiAgICBEQVRFX1NIT1JUSEFORFMsXG4gICAgS0VZV09SRFMsXG4gICAgRXhwcmVzc2lvbkxhbmd1YWdlLFxuICAgIEVYUFJFU1NJT04sXG4gICAgcGFyc2VGaWVsZCxcbn0gZnJvbSBcImV4cHJlc3Npb24vcGFyc2VcIjtcbmV4cG9ydCB7IFFVRVJZX0xBTkdVQUdFIH0gZnJvbSBcInF1ZXJ5L3BhcnNlXCI7XG5leHBvcnQgeyBRdWVyeSB9IGZyb20gXCJxdWVyeS9xdWVyeVwiO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gSW1wbGVtZW50YXRpb24gLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmltcG9ydCB0eXBlIHsgRGF0YXZpZXdBcGkgfSBmcm9tIFwiYXBpL3BsdWdpbi1hcGlcIjtcblxuaW1wb3J0IFwib2JzaWRpYW5cIjtcbmltcG9ydCB0eXBlIHsgQXBwIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5cbi8vIFV0aWxpdHkgZnVuY3Rpb25zLlxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgRGF0YXZpZXcgQVBJIGZyb20gdGhlIGFwcCBpZiBwcm92aWRlZDsgaWYgbm90LCBpdCBpcyBpbmZlcnJlZCBmcm9tIHRoZSBnbG9iYWwgQVBJIG9iamVjdCBpbnN0YWxsZWRcbiAqIG9uIHRoZSB3aW5kb3cuXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRBUEkgPSAoYXBwPzogQXBwKTogRGF0YXZpZXdBcGkgfCB1bmRlZmluZWQgPT4ge1xuICAgIGlmIChhcHApIHJldHVybiBhcHAucGx1Z2lucy5wbHVnaW5zLmRhdGF2aWV3Py5hcGk7XG4gICAgZWxzZSByZXR1cm4gd2luZG93LkRhdGF2aWV3QVBJO1xufTtcblxuLyoqIERldGVybWluZSBpZiBEYXRhdmlldyBpcyBlbmFibGVkIGluIHRoZSBnaXZlbiBhcHBsaWNhdGlvbi4gKi9cbmV4cG9ydCBjb25zdCBpc1BsdWdpbkVuYWJsZWQgPSAoYXBwOiBBcHApID0+IGFwcC5wbHVnaW5zLmVuYWJsZWRQbHVnaW5zLmhhcyhcImRhdGF2aWV3XCIpO1xuIiwgIi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAyMSAqL1xuXG4vKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG52YXIgSUNBTDtcbihmdW5jdGlvbigpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKSB7XG4gICAgLy8gQ29tbW9uSlMsIHdoZXJlIGV4cG9ydHMgbWF5IGJlIGRpZmZlcmVudCBlYWNoIHRpbWUuXG4gICAgSUNBTCA9IG1vZHVsZS5leHBvcnRzO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBIVE1MU2NyaXB0RWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgJ25vTW9kdWxlJyBpbiBIVE1MU2NyaXB0RWxlbWVudC5wcm90b3R5cGUpIHtcbiAgICAvLyBVbnRpbCB3ZSB1c2UgRVM2IGV4cG9ydHMsIHVzaW5nIDxzY3JpcHQgdHlwZT1cIm1vZHVsZVwiPiB3ZSBkZWZpbmUgSUNBTCBvbiB0aGUgd2luZG93IGdsb2JhbC5cbiAgICB3aW5kb3cuSUNBTCA9IElDQUwgPSB7fTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgSUNBTCAhPT0gJ29iamVjdCcpIHtcbiAgICBJQ0FMID0ge307XG4gIH1cbn0pKCk7XG4vKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoLCAyMDExLTIwMTUgKi9cblxuLyoqXG4gKiBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgYmVmb3JlIGlDYWxlbmRhciBsaW5lIGZvbGRpbmcgc2hvdWxkIG9jY3VyXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQGRlZmF1bHQgNzVcbiAqL1xuSUNBTC5mb2xkTGVuZ3RoID0gNzU7XG5cblxuLyoqXG4gKiBUaGUgY2hhcmFjdGVyKHMpIHRvIGJlIHVzZWQgZm9yIGEgbmV3bGluZS4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgcHJvdmlkZWQgYnlcbiAqIHJmYzU1NDUuXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHQgXCJcXHJcXG5cIlxuICovXG5JQ0FMLm5ld0xpbmVDaGFyID0gJ1xcclxcbic7XG5cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb25zIHVzZWQgaW4gdmFyaW91cyBwbGFjZXMgd2l0aGluIGljYWwuanNcbiAqIEBuYW1lc3BhY2VcbiAqL1xuSUNBTC5oZWxwZXJzID0ge1xuICAvKipcbiAgICogQ29tcGlsZXMgYSBsaXN0IG9mIGFsbCByZWZlcmVuY2VkIFRaSURzIGluIGFsbCBzdWJjb21wb25lbnRzIGFuZFxuICAgKiByZW1vdmVzIGFueSBleHRyYSBWVElNRVpPTkUgc3ViY29tcG9uZW50cy4gSW4gYWRkaXRpb24sIGlmIGFueSBUWklEc1xuICAgKiBhcmUgcmVmZXJlbmNlZCBieSBhIGNvbXBvbmVudCwgYnV0IGEgVlRJTUVaT05FIGRvZXMgbm90IGV4aXN0LFxuICAgKiBhbiBhdHRlbXB0IHdpbGwgYmUgbWFkZSB0byBnZW5lcmF0ZSBhIFZUSU1FWk9ORSB1c2luZyBJQ0FMLlRpbWV6b25lU2VydmljZS5cbiAgICpcbiAgICogQHBhcmFtIHtJQ0FMLkNvbXBvbmVudH0gdmNhbCAgICAgVGhlIHRvcC1sZXZlbCBWQ0FMRU5EQVIgY29tcG9uZW50LlxuICAgKiBAcmV0dXJuIHtJQ0FMLkNvbXBvbmVudH0gICAgICAgICBUaGUgSUNBTC5Db21wb25lbnQgdGhhdCB3YXMgcGFzc2VkIGluLlxuICAgKi9cbiAgdXBkYXRlVGltZXpvbmVzOiBmdW5jdGlvbih2Y2FsKSB7XG4gICAgdmFyIGFsbHN1YnMsIHByb3BlcnRpZXMsIHZ0aW1lem9uZXMsIHJlcVR6aWQsIGksIHR6aWQ7XG5cbiAgICBpZiAoIXZjYWwgfHwgdmNhbC5uYW1lICE9PSBcInZjYWxlbmRhclwiKSB7XG4gICAgICAvL25vdCBhIHRvcC1sZXZlbCB2Y2FsZW5kYXIgY29tcG9uZW50XG4gICAgICByZXR1cm4gdmNhbDtcbiAgICB9XG5cbiAgICAvL1N0b3JlIHZ0aW1lem9uZSBzdWJjb21wb25lbnRzIGluIGFuIG9iamVjdCByZWZlcmVuY2UgYnkgdHppZC5cbiAgICAvL1N0b3JlIHByb3BlcnRpZXMgZnJvbSBldmVyeXRoaW5nIGVsc2UgaW4gYW5vdGhlciBhcnJheVxuICAgIGFsbHN1YnMgPSB2Y2FsLmdldEFsbFN1YmNvbXBvbmVudHMoKTtcbiAgICBwcm9wZXJ0aWVzID0gW107XG4gICAgdnRpbWV6b25lcyA9IHt9O1xuICAgIGZvciAoaSA9IDA7IGkgPCBhbGxzdWJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYWxsc3Vic1tpXS5uYW1lID09PSBcInZ0aW1lem9uZVwiKSB7XG4gICAgICAgIHR6aWQgPSBhbGxzdWJzW2ldLmdldEZpcnN0UHJvcGVydHkoXCJ0emlkXCIpLmdldEZpcnN0VmFsdWUoKTtcbiAgICAgICAgdnRpbWV6b25lc1t0emlkXSA9IGFsbHN1YnNbaV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wZXJ0aWVzID0gcHJvcGVydGllcy5jb25jYXQoYWxsc3Vic1tpXS5nZXRBbGxQcm9wZXJ0aWVzKCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vY3JlYXRlIGFuIG9iamVjdCB3aXRoIG9uZSBlbnRyeSBmb3IgZWFjaCByZXF1aXJlZCB0elxuICAgIHJlcVR6aWQgPSB7fTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCh0emlkID0gcHJvcGVydGllc1tpXS5nZXRQYXJhbWV0ZXIoXCJ0emlkXCIpKSkge1xuICAgICAgICByZXFUemlkW3R6aWRdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL2RlbGV0ZSBhbnkgdnRpbWV6b25lcyB0aGF0IGFyZSBub3Qgb24gdGhlIHJlcVR6aWQgbGlzdC5cbiAgICBmb3IgKGkgaW4gdnRpbWV6b25lcykge1xuICAgICAgaWYgKHZ0aW1lem9uZXMuaGFzT3duUHJvcGVydHkoaSkgJiYgIXJlcVR6aWRbaV0pIHtcbiAgICAgICAgdmNhbC5yZW1vdmVTdWJjb21wb25lbnQodnRpbWV6b25lc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9jcmVhdGUgYW55IG1pc3NpbmcsIGJ1dCByZWdpc3RlcmVkIHRpbWV6b25lc1xuICAgIGZvciAoaSBpbiByZXFUemlkKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHJlcVR6aWQuaGFzT3duUHJvcGVydHkoaSkgJiZcbiAgICAgICAgIXZ0aW1lem9uZXNbaV0gJiZcbiAgICAgICAgSUNBTC5UaW1lem9uZVNlcnZpY2UuaGFzKGkpXG4gICAgICApIHtcbiAgICAgICAgdmNhbC5hZGRTdWJjb21wb25lbnQoSUNBTC5UaW1lem9uZVNlcnZpY2UuZ2V0KGkpLmNvbXBvbmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZjYWw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdHlwZSBpcyBvZiB0aGUgbnVtYmVyIHR5cGUgYW5kIGFsc28gTmFOLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyICAgICBUaGUgbnVtYmVyIHRvIGNoZWNrXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgIFRydWUsIGlmIHRoZSBudW1iZXIgaXMgc3RyaWN0bHkgTmFOXG4gICAqL1xuICBpc1N0cmljdGx5TmFOOiBmdW5jdGlvbihudW1iZXIpIHtcbiAgICByZXR1cm4gdHlwZW9mKG51bWJlcikgPT09ICdudW1iZXInICYmIGlzTmFOKG51bWJlcik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhIHN0cmluZyB2YWx1ZSB0aGF0IGlzIGV4cGVjdGVkIHRvIGJlIGFuIGludGVnZXIsIHdoZW4gdGhlIHZhbGlkIGlzXG4gICAqIG5vdCBhbiBpbnRlZ2VyIHRocm93cyBhIGRlY29yYXRpb24gZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgICAgIFJhdyBzdHJpbmcgaW5wdXRcbiAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgUGFyc2VkIGludGVnZXJcbiAgICovXG4gIHN0cmljdFBhcnNlSW50OiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICB2YXIgcmVzdWx0ID0gcGFyc2VJbnQoc3RyaW5nLCAxMCk7XG5cbiAgICBpZiAoSUNBTC5oZWxwZXJzLmlzU3RyaWN0bHlOYU4ocmVzdWx0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnQ291bGQgbm90IGV4dHJhY3QgaW50ZWdlciBmcm9tIFwiJyArIHN0cmluZyArICdcIidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBvciByZXR1cm5zIGEgY2xhc3MgaW5zdGFuY2Ugb2YgYSBnaXZlbiB0eXBlIHdpdGggdGhlIGluaXRpYWxpemF0aW9uXG4gICAqIGRhdGEgaWYgdGhlIGRhdGEgaXMgbm90IGFscmVhZHkgYW4gaW5zdGFuY2Ugb2YgdGhlIGdpdmVuIHR5cGUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciB0aW1lID0gbmV3IElDQUwuVGltZSguLi4pO1xuICAgKiB2YXIgcmVzdWx0ID0gSUNBTC5oZWxwZXJzLmZvcm1hdENsYXNzVHlwZSh0aW1lLCBJQ0FMLlRpbWUpO1xuICAgKlxuICAgKiAocmVzdWx0IGluc3RhbmNlb2YgSUNBTC5UaW1lKVxuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIHJlc3VsdCA9IElDQUwuaGVscGVycy5mb3JtYXRDbGFzc1R5cGUoe30sIElDQUwuVGltZSk7XG4gICAqIChyZXN1bHQgaXNudGFuY2VvZiBJQ0FMLlRpbWUpXG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgICAgICAgb2JqZWN0IGluaXRpYWxpemF0aW9uIGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IHR5cGUgICAgICAgb2JqZWN0IHR5cGUgKGxpa2UgSUNBTC5UaW1lKVxuICAgKiBAcmV0dXJuIHs/fSAgICAgICAgICAgICAgICBBbiBpbnN0YW5jZSBvZiB0aGUgZm91bmQgdHlwZS5cbiAgICovXG4gIGZvcm1hdENsYXNzVHlwZTogZnVuY3Rpb24gZm9ybWF0Q2xhc3NUeXBlKGRhdGEsIHR5cGUpIHtcbiAgICBpZiAodHlwZW9mKGRhdGEpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIHR5cGUpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHR5cGUoZGF0YSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIElkZW50aWNhbCB0byBpbmRleE9mIGJ1dCB3aWxsIG9ubHkgbWF0Y2ggdmFsdWVzIHdoZW4gdGhleSBhcmUgbm90IHByZWNlZGVkXG4gICAqIGJ5IGEgYmFja3NsYXNoIGNoYXJhY3Rlci5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGJ1ZmZlciAgICAgICAgIFN0cmluZyB0byBzZWFyY2hcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNlYXJjaCAgICAgICAgIFZhbHVlIHRvIGxvb2sgZm9yXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwb3MgICAgICAgICAgICBTdGFydCBwb3NpdGlvblxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgICAgVGhlIHBvc2l0aW9uLCBvciAtMSBpZiBub3QgZm91bmRcbiAgICovXG4gIHVuZXNjYXBlZEluZGV4T2Y6IGZ1bmN0aW9uKGJ1ZmZlciwgc2VhcmNoLCBwb3MpIHtcbiAgICB3aGlsZSAoKHBvcyA9IGJ1ZmZlci5pbmRleE9mKHNlYXJjaCwgcG9zKSkgIT09IC0xKSB7XG4gICAgICBpZiAocG9zID4gMCAmJiBidWZmZXJbcG9zIC0gMV0gPT09ICdcXFxcJykge1xuICAgICAgICBwb3MgKz0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfSxcblxuICAvKipcbiAgICogRmluZCB0aGUgaW5kZXggZm9yIGluc2VydGlvbiB1c2luZyBiaW5hcnkgc2VhcmNoLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0ICAgICAgICAgICAgVGhlIGxpc3QgdG8gc2VhcmNoXG4gICAqIEBwYXJhbSB7P30gc2Vla1ZhbCAgICAgICAgICAgICBUaGUgdmFsdWUgdG8gaW5zZXJ0XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oPyw/KX0gY21wZnVuYyBUaGUgY29tcGFyaXNvbiBmdW5jLCB0aGF0IGNhblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wYXJlIHR3byBzZWVrVmFsc1xuICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgICAgVGhlIGluc2VydCBwb3NpdGlvblxuICAgKi9cbiAgYmluc2VhcmNoSW5zZXJ0OiBmdW5jdGlvbihsaXN0LCBzZWVrVmFsLCBjbXBmdW5jKSB7XG4gICAgaWYgKCFsaXN0Lmxlbmd0aClcbiAgICAgIHJldHVybiAwO1xuXG4gICAgdmFyIGxvdyA9IDAsIGhpZ2ggPSBsaXN0Lmxlbmd0aCAtIDEsXG4gICAgICAgIG1pZCwgY21wdmFsO1xuXG4gICAgd2hpbGUgKGxvdyA8PSBoaWdoKSB7XG4gICAgICBtaWQgPSBsb3cgKyBNYXRoLmZsb29yKChoaWdoIC0gbG93KSAvIDIpO1xuICAgICAgY21wdmFsID0gY21wZnVuYyhzZWVrVmFsLCBsaXN0W21pZF0pO1xuXG4gICAgICBpZiAoY21wdmFsIDwgMClcbiAgICAgICAgaGlnaCA9IG1pZCAtIDE7XG4gICAgICBlbHNlIGlmIChjbXB2YWwgPiAwKVxuICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgZWxzZVxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoY21wdmFsIDwgMClcbiAgICAgIHJldHVybiBtaWQ7IC8vIGluc2VydGlvbiBpcyBkaXNwbGFjaW5nLCBzbyB1c2UgbWlkIG91dHJpZ2h0LlxuICAgIGVsc2UgaWYgKGNtcHZhbCA+IDApXG4gICAgICByZXR1cm4gbWlkICsgMTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gbWlkO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgZGVidWcgb3V0cHV0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkdW1wbjogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFJQ0FMLmRlYnVnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiAoY29uc29sZSkgIT09ICd1bmRlZmluZWQnICYmICdsb2cnIGluIGNvbnNvbGUpIHtcbiAgICAgIElDQUwuaGVscGVycy5kdW1wbiA9IGZ1bmN0aW9uIGNvbnNvbGVEdW1wbihpbnB1dCkge1xuICAgICAgICBjb25zb2xlLmxvZyhpbnB1dCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBJQ0FMLmhlbHBlcnMuZHVtcG4gPSBmdW5jdGlvbiBnZWNrb0R1bXBuKGlucHV0KSB7XG4gICAgICAgIGR1bXAoaW5wdXQgKyAnXFxuJyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIElDQUwuaGVscGVycy5kdW1wbihhcmd1bWVudHNbMF0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDbG9uZSB0aGUgcGFzc2VkIG9iamVjdCBvciBwcmltaXRpdmUuIEJ5IGRlZmF1bHQgYSBzaGFsbG93IGNsb25lIHdpbGwgYmVcbiAgICogZXhlY3V0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gYVNyYyAgICAgICAgICAgIFRoZSB0aGluZyB0byBjbG9uZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW49fSBhRGVlcCAgICBJZiB0cnVlLCBhIGRlZXAgY2xvbmUgd2lsbCBiZSBwZXJmb3JtZWRcbiAgICogQHJldHVybiB7Kn0gICAgICAgICAgICAgICAgVGhlIGNvcHkgb2YgdGhlIHRoaW5nXG4gICAqL1xuICBjbG9uZTogZnVuY3Rpb24oYVNyYywgYURlZXApIHtcbiAgICBpZiAoIWFTcmMgfHwgdHlwZW9mIGFTcmMgIT0gXCJvYmplY3RcIikge1xuICAgICAgcmV0dXJuIGFTcmM7XG4gICAgfSBlbHNlIGlmIChhU3JjIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKGFTcmMuZ2V0VGltZSgpKTtcbiAgICB9IGVsc2UgaWYgKFwiY2xvbmVcIiBpbiBhU3JjKSB7XG4gICAgICByZXR1cm4gYVNyYy5jbG9uZSgpO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhU3JjKSkge1xuICAgICAgdmFyIGFyciA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhU3JjLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFyci5wdXNoKGFEZWVwID8gSUNBTC5oZWxwZXJzLmNsb25lKGFTcmNbaV0sIHRydWUpIDogYVNyY1tpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb2JqID0ge307XG4gICAgICBmb3IgKHZhciBuYW1lIGluIGFTcmMpIHtcbiAgICAgICAgLy8gdXNlcyBwcm90b3R5cGUgbWV0aG9kIHRvIGFsbG93IHVzZSBvZiBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFTcmMsIG5hbWUpKSB7XG4gICAgICAgICAgaWYgKGFEZWVwKSB7XG4gICAgICAgICAgICBvYmpbbmFtZV0gPSBJQ0FMLmhlbHBlcnMuY2xvbmUoYVNyY1tuYW1lXSwgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9ialtuYW1lXSA9IGFTcmNbbmFtZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUGVyZm9ybXMgaUNhbGVuZGFyIGxpbmUgZm9sZGluZy4gQSBsaW5lIGVuZGluZyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQgYW5kXG4gICAqIHRoZSBuZXh0IGxpbmUgYmVnaW5zIHdpdGggYSB3aGl0ZXNwYWNlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBTVU1NQVJZOlRoaXMgbGluZSB3aWxsIGJlIGZvbGRcbiAgICogIGVkIHJpZ2h0IGluIHRoZSBtaWRkbGUgb2YgYSB3b3JkLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYUxpbmUgICAgICBUaGUgbGluZSB0byBmb2xkXG4gICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgIFRoZSBmb2xkZWQgbGluZVxuICAgKi9cbiAgZm9sZGxpbmU6IGZ1bmN0aW9uIGZvbGRsaW5lKGFMaW5lKSB7XG4gICAgdmFyIHJlc3VsdCA9IFwiXCI7XG4gICAgdmFyIGxpbmUgPSBhTGluZSB8fCBcIlwiLCBwb3MgPSAwLCBsaW5lX2xlbmd0aCA9IDA7XG4gICAgLy9wb3MgY291bnRzIHBvc2l0aW9uIGluIGxpbmUgZm9yIHRoZSBVVEYtMTYgcHJlc2VudGF0aW9uXG4gICAgLy9saW5lX2xlbmd0aCBjb3VudHMgdGhlIGJ5dGVzIGZvciB0aGUgVVRGLTggcHJlc2VudGF0aW9uXG4gICAgd2hpbGUgKGxpbmUubGVuZ3RoKSB7XG4gICAgICB2YXIgY3AgPSBsaW5lLmNvZGVQb2ludEF0KHBvcyk7XG4gICAgICBpZiAoY3AgPCAxMjgpICsrbGluZV9sZW5ndGg7XG4gICAgICBlbHNlIGlmIChjcCA8IDIwNDgpIGxpbmVfbGVuZ3RoICs9IDI7Ly9uZWVkcyAyIFVURi04IGJ5dGVzXG4gICAgICBlbHNlIGlmIChjcCA8IDY1NTM2KSBsaW5lX2xlbmd0aCArPSAzO1xuICAgICAgZWxzZSBsaW5lX2xlbmd0aCArPSA0OyAvL2NwIGlzIGxlc3MgdGhhbiAxMTE0MTEyXG4gICAgICBpZiAobGluZV9sZW5ndGggPCBJQ0FMLmZvbGRMZW5ndGggKyAxKVxuICAgICAgICBwb3MgKz0gY3AgPiA2NTUzNSA/IDIgOiAxO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCArPSBJQ0FMLm5ld0xpbmVDaGFyICsgXCIgXCIgKyBsaW5lLnN1YnN0cmluZygwLCBwb3MpO1xuICAgICAgICBsaW5lID0gbGluZS5zdWJzdHJpbmcocG9zKTtcbiAgICAgICAgcG9zID0gbGluZV9sZW5ndGggPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LnN1YnN0cihJQ0FMLm5ld0xpbmVDaGFyLmxlbmd0aCArIDEpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBQYWRzIHRoZSBnaXZlbiBzdHJpbmcgb3IgbnVtYmVyIHdpdGggemVyb3Mgc28gaXQgd2lsbCBoYXZlIGF0IGxlYXN0IHR3b1xuICAgKiBjaGFyYWN0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGRhdGEgICAgVGhlIHN0cmluZyBvciBudW1iZXIgdG8gcGFkXG4gICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgICAgICBUaGUgbnVtYmVyIHBhZGRlZCBhcyBhIHN0cmluZ1xuICAgKi9cbiAgcGFkMjogZnVuY3Rpb24gcGFkKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mKGRhdGEpICE9PSAnc3RyaW5nJykge1xuICAgICAgLy8gaGFuZGxlIGZyYWN0aW9ucy5cbiAgICAgIGlmICh0eXBlb2YoZGF0YSkgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGRhdGEgPSBwYXJzZUludChkYXRhKTtcbiAgICAgIH1cbiAgICAgIGRhdGEgPSBTdHJpbmcoZGF0YSk7XG4gICAgfVxuXG4gICAgdmFyIGxlbiA9IGRhdGEubGVuZ3RoO1xuXG4gICAgc3dpdGNoIChsZW4pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuICcwMCc7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiAnMCcgKyBkYXRhO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBUcnVuY2F0ZXMgdGhlIGdpdmVuIG51bWJlciwgY29ycmVjdGx5IGhhbmRsaW5nIG5lZ2F0aXZlIG51bWJlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXIgICAgIFRoZSBudW1iZXIgdG8gdHJ1bmNhdGVcbiAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgVGhlIHRydW5jYXRlZCBudW1iZXJcbiAgICovXG4gIHRydW5jOiBmdW5jdGlvbiB0cnVuYyhudW1iZXIpIHtcbiAgICByZXR1cm4gKG51bWJlciA8IDAgPyBNYXRoLmNlaWwobnVtYmVyKSA6IE1hdGguZmxvb3IobnVtYmVyKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFBvb3ItbWFuJ3MgY3Jvc3MtYnJvd3NlciBpbmhlcml0YW5jZSBmb3IgSmF2YVNjcmlwdC4gRG9lc24ndCBzdXBwb3J0IGFsbFxuICAgKiB0aGUgZmVhdHVyZXMsIGJ1dCBlbm91Z2ggZm9yIG91ciB1c2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gYmFzZSAgICAgVGhlIGJhc2UgY2xhc3MgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNoaWxkICAgIFRoZSBjaGlsZCBjbGFzcyBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IGV4dHJhICAgICAgRXh0ZW5kcyB0aGUgcHJvdG90eXBlIHdpdGggZXh0cmEgcHJvcGVydGllc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCBtZXRob2RzXG4gICAqL1xuICBpbmhlcml0czogZnVuY3Rpb24oYmFzZSwgY2hpbGQsIGV4dHJhKSB7XG4gICAgZnVuY3Rpb24gRigpIHt9XG4gICAgRi5wcm90b3R5cGUgPSBiYXNlLnByb3RvdHlwZTtcbiAgICBjaGlsZC5wcm90b3R5cGUgPSBuZXcgRigpO1xuXG4gICAgaWYgKGV4dHJhKSB7XG4gICAgICBJQ0FMLmhlbHBlcnMuZXh0ZW5kKGV4dHJhLCBjaGlsZC5wcm90b3R5cGUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUG9vci1tYW4ncyBjcm9zcy1icm93c2VyIG9iamVjdCBleHRlbnNpb24uIERvZXNuJ3Qgc3VwcG9ydCBhbGwgdGhlXG4gICAqIGZlYXR1cmVzLCBidXQgZW5vdWdoIGZvciBvdXIgdXNhZ2UuIE5vdGUgdGhhdCB0aGUgdGFyZ2V0J3MgcHJvcGVydGllcyBhcmVcbiAgICogbm90IG92ZXJ3cml0dGVuIHdpdGggdGhlIHNvdXJjZSBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgY2hpbGQgPSBJQ0FMLmhlbHBlcnMuZXh0ZW5kKHBhcmVudCwge1xuICAgKiAgIFwiYmFyXCI6IDEyM1xuICAgKiB9KTtcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSAgICAgVGhlIG9iamVjdCB0byBleHRlbmRcbiAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCAgICAgVGhlIG9iamVjdCB0byBleHRlbmQgd2l0aFxuICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICBSZXR1cm5zIHRoZSB0YXJnZXQuXG4gICAqL1xuICBleHRlbmQ6IGZ1bmN0aW9uKHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgdmFyIGRlc2NyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSk7XG4gICAgICBpZiAoZGVzY3IgJiYgIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzY3IpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG59O1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoLCAyMDExLTIwMTUgKi9cblxuLyoqIEBuYW1lc3BhY2UgSUNBTCAqL1xuXG5cbi8qKlxuICogVGhpcyBzeW1ib2wgaXMgZnVydGhlciBkZXNjcmliZWQgbGF0ZXIgb25cbiAqIEBpZ25vcmVcbiAqL1xuSUNBTC5kZXNpZ24gPSAoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgRlJPTV9JQ0FMX05FV0xJTkUgPSAvXFxcXFxcXFx8XFxcXDt8XFxcXCx8XFxcXFtObl0vZztcbiAgdmFyIFRPX0lDQUxfTkVXTElORSA9IC9cXFxcfDt8LHxcXG4vZztcbiAgdmFyIEZST01fVkNBUkRfTkVXTElORSA9IC9cXFxcXFxcXHxcXFxcLHxcXFxcW05uXS9nO1xuICB2YXIgVE9fVkNBUkRfTkVXTElORSA9IC9cXFxcfCx8XFxuL2c7XG5cbiAgZnVuY3Rpb24gY3JlYXRlVGV4dFR5cGUoZnJvbU5ld2xpbmUsIHRvTmV3bGluZSkge1xuICAgIHZhciByZXN1bHQgPSB7XG4gICAgICBtYXRjaGVzOiAvLiovLFxuXG4gICAgICBmcm9tSUNBTDogZnVuY3Rpb24oYVZhbHVlLCBzdHJ1Y3R1cmVkRXNjYXBlKSB7XG4gICAgICAgIHJldHVybiByZXBsYWNlTmV3bGluZShhVmFsdWUsIGZyb21OZXdsaW5lLCBzdHJ1Y3R1cmVkRXNjYXBlKTtcbiAgICAgIH0sXG5cbiAgICAgIHRvSUNBTDogZnVuY3Rpb24oYVZhbHVlLCBzdHJ1Y3R1cmVkRXNjYXBlKSB7XG4gICAgICAgIHZhciByZWdFeCA9IHRvTmV3bGluZTtcbiAgICAgICAgaWYgKHN0cnVjdHVyZWRFc2NhcGUpXG4gICAgICAgICAgcmVnRXggPSBuZXcgUmVnRXhwKHJlZ0V4LnNvdXJjZSArICd8JyArIHN0cnVjdHVyZWRFc2NhcGUpO1xuICAgICAgICByZXR1cm4gYVZhbHVlLnJlcGxhY2UocmVnRXgsIGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgIHN3aXRjaCAoc3RyKSB7XG4gICAgICAgICAgY2FzZSBcIlxcXFxcIjpcbiAgICAgICAgICAgIHJldHVybiBcIlxcXFxcXFxcXCI7XG4gICAgICAgICAgY2FzZSBcIjtcIjpcbiAgICAgICAgICAgIHJldHVybiBcIlxcXFw7XCI7XG4gICAgICAgICAgY2FzZSBcIixcIjpcbiAgICAgICAgICAgIHJldHVybiBcIlxcXFwsXCI7XG4gICAgICAgICAgY2FzZSBcIlxcblwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiXFxcXG5cIjtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gZGVmYXVsdCB0eXBlcyB1c2VkIG11bHRpcGxlIHRpbWVzXG4gIHZhciBERUZBVUxUX1RZUEVfVEVYVCA9IHsgZGVmYXVsdFR5cGU6IFwidGV4dFwiIH07XG4gIHZhciBERUZBVUxUX1RZUEVfVEVYVF9NVUxUSSA9IHsgZGVmYXVsdFR5cGU6IFwidGV4dFwiLCBtdWx0aVZhbHVlOiBcIixcIiB9O1xuICB2YXIgREVGQVVMVF9UWVBFX1RFWFRfU1RSVUNUVVJFRCA9IHsgZGVmYXVsdFR5cGU6IFwidGV4dFwiLCBzdHJ1Y3R1cmVkVmFsdWU6IFwiO1wiIH07XG4gIHZhciBERUZBVUxUX1RZUEVfSU5URUdFUiA9IHsgZGVmYXVsdFR5cGU6IFwiaW50ZWdlclwiIH07XG4gIHZhciBERUZBVUxUX1RZUEVfREFURVRJTUVfREFURSA9IHsgZGVmYXVsdFR5cGU6IFwiZGF0ZS10aW1lXCIsIGFsbG93ZWRUeXBlczogW1wiZGF0ZS10aW1lXCIsIFwiZGF0ZVwiXSB9O1xuICB2YXIgREVGQVVMVF9UWVBFX0RBVEVUSU1FID0geyBkZWZhdWx0VHlwZTogXCJkYXRlLXRpbWVcIiB9O1xuICB2YXIgREVGQVVMVF9UWVBFX1VSSSA9IHsgZGVmYXVsdFR5cGU6IFwidXJpXCIgfTtcbiAgdmFyIERFRkFVTFRfVFlQRV9VVENPRkZTRVQgPSB7IGRlZmF1bHRUeXBlOiBcInV0Yy1vZmZzZXRcIiB9O1xuICB2YXIgREVGQVVMVF9UWVBFX1JFQ1VSID0geyBkZWZhdWx0VHlwZTogXCJyZWN1clwiIH07XG4gIHZhciBERUZBVUxUX1RZUEVfREFURV9BTkRPUl9USU1FID0geyBkZWZhdWx0VHlwZTogXCJkYXRlLWFuZC1vci10aW1lXCIsIGFsbG93ZWRUeXBlczogW1wiZGF0ZS10aW1lXCIsIFwiZGF0ZVwiLCBcInRleHRcIl0gfTtcblxuICBmdW5jdGlvbiByZXBsYWNlTmV3bGluZVJlcGxhY2Uoc3RyaW5nKSB7XG4gICAgc3dpdGNoIChzdHJpbmcpIHtcbiAgICAgIGNhc2UgXCJcXFxcXFxcXFwiOlxuICAgICAgICByZXR1cm4gXCJcXFxcXCI7XG4gICAgICBjYXNlIFwiXFxcXDtcIjpcbiAgICAgICAgcmV0dXJuIFwiO1wiO1xuICAgICAgY2FzZSBcIlxcXFwsXCI6XG4gICAgICAgIHJldHVybiBcIixcIjtcbiAgICAgIGNhc2UgXCJcXFxcblwiOlxuICAgICAgY2FzZSBcIlxcXFxOXCI6XG4gICAgICAgIHJldHVybiBcIlxcblwiO1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVwbGFjZU5ld2xpbmUodmFsdWUsIG5ld2xpbmUsIHN0cnVjdHVyZWRFc2NhcGUpIHtcbiAgICAvLyBhdm9pZCByZWdleCB3aGVuIHBvc3NpYmxlLlxuICAgIGlmICh2YWx1ZS5pbmRleE9mKCdcXFxcJykgPT09IC0xKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmIChzdHJ1Y3R1cmVkRXNjYXBlKVxuICAgICAgbmV3bGluZSA9IG5ldyBSZWdFeHAobmV3bGluZS5zb3VyY2UgKyAnfFxcXFxcXFxcJyArIHN0cnVjdHVyZWRFc2NhcGUpO1xuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKG5ld2xpbmUsIHJlcGxhY2VOZXdsaW5lUmVwbGFjZSk7XG4gIH1cblxuICB2YXIgY29tbW9uUHJvcGVydGllcyA9IHtcbiAgICBcImNhdGVnb3JpZXNcIjogREVGQVVMVF9UWVBFX1RFWFRfTVVMVEksXG4gICAgXCJ1cmxcIjogREVGQVVMVF9UWVBFX1VSSSxcbiAgICBcInZlcnNpb25cIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgXCJ1aWRcIjogREVGQVVMVF9UWVBFX1RFWFRcbiAgfTtcblxuICB2YXIgY29tbW9uVmFsdWVzID0ge1xuICAgIFwiYm9vbGVhblwiOiB7XG4gICAgICB2YWx1ZXM6IFtcIlRSVUVcIiwgXCJGQUxTRVwiXSxcblxuICAgICAgZnJvbUlDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICBzd2l0Y2ggKGFWYWx1ZSkge1xuICAgICAgICAgIGNhc2UgJ1RSVUUnOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgY2FzZSAnRkFMU0UnOlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvL1RPRE86IHBhcnNlciB3YXJuaW5nXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHRvSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIGlmIChhVmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gJ1RSVUUnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnRkFMU0UnO1xuICAgICAgfVxuXG4gICAgfSxcbiAgICBmbG9hdDoge1xuICAgICAgbWF0Y2hlczogL15bKy1dP1xcZCtcXC5cXGQrJC8sXG5cbiAgICAgIGZyb21JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlRmxvYXQoYVZhbHVlKTtcbiAgICAgICAgaWYgKElDQUwuaGVscGVycy5pc1N0cmljdGx5TmFOKHBhcnNlZCkpIHtcbiAgICAgICAgICAvLyBUT0RPOiBwYXJzZXIgd2FybmluZ1xuICAgICAgICAgIHJldHVybiAwLjA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICAgIH0sXG5cbiAgICAgIHRvSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcoYVZhbHVlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGludGVnZXI6IHtcbiAgICAgIGZyb21JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KGFWYWx1ZSk7XG4gICAgICAgIGlmIChJQ0FMLmhlbHBlcnMuaXNTdHJpY3RseU5hTihwYXJzZWQpKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICAgIH0sXG5cbiAgICAgIHRvSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcoYVZhbHVlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFwidXRjLW9mZnNldFwiOiB7XG4gICAgICB0b0lDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICBpZiAoYVZhbHVlLmxlbmd0aCA8IDcpIHtcbiAgICAgICAgICAvLyBubyBzZWNvbmRzXG4gICAgICAgICAgLy8gLTA1MDBcbiAgICAgICAgICByZXR1cm4gYVZhbHVlLnN1YnN0cigwLCAzKSArXG4gICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoNCwgMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gc2Vjb25kc1xuICAgICAgICAgIC8vIC0wNTAwMDBcbiAgICAgICAgICByZXR1cm4gYVZhbHVlLnN1YnN0cigwLCAzKSArXG4gICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoNCwgMikgK1xuICAgICAgICAgICAgICAgICBhVmFsdWUuc3Vic3RyKDcsIDIpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBmcm9tSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIGlmIChhVmFsdWUubGVuZ3RoIDwgNikge1xuICAgICAgICAgIC8vIG5vIHNlY29uZHNcbiAgICAgICAgICAvLyAtMDU6MDBcbiAgICAgICAgICByZXR1cm4gYVZhbHVlLnN1YnN0cigwLCAzKSArICc6JyArXG4gICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoMywgMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gc2Vjb25kc1xuICAgICAgICAgIC8vIC0wNTowMDowMFxuICAgICAgICAgIHJldHVybiBhVmFsdWUuc3Vic3RyKDAsIDMpICsgJzonICtcbiAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cigzLCAyKSArICc6JyArXG4gICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoNSwgMik7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIElDQUwuVXRjT2Zmc2V0LmZyb21TdHJpbmcoYVZhbHVlKTtcbiAgICAgIH0sXG5cbiAgICAgIHVuZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gYVZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBpY2FsUGFyYW1zID0ge1xuICAgIC8vIEFsdGhvdWdoIHRoZSBzeW50YXggaXMgRFFVT1RFIHVyaSBEUVVPVEUsIEkgZG9uJ3QgdGhpbmsgd2Ugc2hvdWxkXG4gICAgLy8gZW5mb2NlIGFueXRoaW5nIGFzaWRlIGZyb20gaXQgYmVpbmcgYSB2YWxpZCBjb250ZW50IGxpbmUuXG4gICAgLy9cbiAgICAvLyBBdCBsZWFzdCBzb21lIHBhcmFtcyByZXF1aXJlIC0gaWYgbXVsdGkgdmFsdWVzIGFyZSB1c2VkIC0gRFFVT1RFc1xuICAgIC8vIGZvciBlYWNoIG9mIGl0cyB2YWx1ZXMgLSBlLmcuIGRlbGVnYXRlZC1mcm9tPVwidXJpMVwiLFwidXJpMlwiXG4gICAgLy8gVG8gaW5kaWNhdGUgdGhpcywgSSBpbnRyb2R1Y2VkIHRoZSBuZXcgay92IHBhaXJcbiAgICAvLyBtdWx0aVZhbHVlU2VwYXJhdGVEUXVvdGU6IHRydWVcbiAgICAvL1xuICAgIC8vIFwiQUxUUkVQXCI6IHsgLi4uIH0sXG5cbiAgICAvLyBDTiBqdXN0IHdhbnRzIGEgcGFyYW0tdmFsdWVcbiAgICAvLyBcIkNOXCI6IHsgLi4uIH1cblxuICAgIFwiY3V0eXBlXCI6IHtcbiAgICAgIHZhbHVlczogW1wiSU5ESVZJRFVBTFwiLCBcIkdST1VQXCIsIFwiUkVTT1VSQ0VcIiwgXCJST09NXCIsIFwiVU5LTk9XTlwiXSxcbiAgICAgIGFsbG93WE5hbWU6IHRydWUsXG4gICAgICBhbGxvd0lhbmFUb2tlbjogdHJ1ZVxuICAgIH0sXG5cbiAgICBcImRlbGVnYXRlZC1mcm9tXCI6IHtcbiAgICAgIHZhbHVlVHlwZTogXCJjYWwtYWRkcmVzc1wiLFxuICAgICAgbXVsdGlWYWx1ZTogXCIsXCIsXG4gICAgICBtdWx0aVZhbHVlU2VwYXJhdGVEUXVvdGU6IHRydWVcbiAgICB9LFxuICAgIFwiZGVsZWdhdGVkLXRvXCI6IHtcbiAgICAgIHZhbHVlVHlwZTogXCJjYWwtYWRkcmVzc1wiLFxuICAgICAgbXVsdGlWYWx1ZTogXCIsXCIsXG4gICAgICBtdWx0aVZhbHVlU2VwYXJhdGVEUXVvdGU6IHRydWVcbiAgICB9LFxuICAgIC8vIFwiRElSXCI6IHsgLi4uIH0sIC8vIFNlZSBBTFRSRVBcbiAgICBcImVuY29kaW5nXCI6IHtcbiAgICAgIHZhbHVlczogW1wiOEJJVFwiLCBcIkJBU0U2NFwiXVxuICAgIH0sXG4gICAgLy8gXCJGTVRUWVBFXCI6IHsgLi4uIH0sIC8vIFNlZSBBTFRSRVBcbiAgICBcImZidHlwZVwiOiB7XG4gICAgICB2YWx1ZXM6IFtcIkZSRUVcIiwgXCJCVVNZXCIsIFwiQlVTWS1VTkFWQUlMQUJMRVwiLCBcIkJVU1ktVEVOVEFUSVZFXCJdLFxuICAgICAgYWxsb3dYTmFtZTogdHJ1ZSxcbiAgICAgIGFsbG93SWFuYVRva2VuOiB0cnVlXG4gICAgfSxcbiAgICAvLyBcIkxBTkdVQUdFXCI6IHsgLi4uIH0sIC8vIFNlZSBBTFRSRVBcbiAgICBcIm1lbWJlclwiOiB7XG4gICAgICB2YWx1ZVR5cGU6IFwiY2FsLWFkZHJlc3NcIixcbiAgICAgIG11bHRpVmFsdWU6IFwiLFwiLFxuICAgICAgbXVsdGlWYWx1ZVNlcGFyYXRlRFF1b3RlOiB0cnVlXG4gICAgfSxcbiAgICBcInBhcnRzdGF0XCI6IHtcbiAgICAgIC8vIFRPRE8gVGhlc2UgdmFsdWVzIGFyZSBhY3R1YWxseSBkaWZmZXJlbnQgcGVyLWNvbXBvbmVudFxuICAgICAgdmFsdWVzOiBbXCJORUVEUy1BQ1RJT05cIiwgXCJBQ0NFUFRFRFwiLCBcIkRFQ0xJTkVEXCIsIFwiVEVOVEFUSVZFXCIsXG4gICAgICAgICAgICAgICBcIkRFTEVHQVRFRFwiLCBcIkNPTVBMRVRFRFwiLCBcIklOLVBST0NFU1NcIl0sXG4gICAgICBhbGxvd1hOYW1lOiB0cnVlLFxuICAgICAgYWxsb3dJYW5hVG9rZW46IHRydWVcbiAgICB9LFxuICAgIFwicmFuZ2VcIjoge1xuICAgICAgdmFsdWVzOiBbXCJUSElTQU5ERlVUVVJFXCJdXG4gICAgfSxcbiAgICBcInJlbGF0ZWRcIjoge1xuICAgICAgdmFsdWVzOiBbXCJTVEFSVFwiLCBcIkVORFwiXVxuICAgIH0sXG4gICAgXCJyZWx0eXBlXCI6IHtcbiAgICAgIHZhbHVlczogW1wiUEFSRU5UXCIsIFwiQ0hJTERcIiwgXCJTSUJMSU5HXCJdLFxuICAgICAgYWxsb3dYTmFtZTogdHJ1ZSxcbiAgICAgIGFsbG93SWFuYVRva2VuOiB0cnVlXG4gICAgfSxcbiAgICBcInJvbGVcIjoge1xuICAgICAgdmFsdWVzOiBbXCJSRVEtUEFSVElDSVBBTlRcIiwgXCJDSEFJUlwiLFxuICAgICAgICAgICAgICAgXCJPUFQtUEFSVElDSVBBTlRcIiwgXCJOT04tUEFSVElDSVBBTlRcIl0sXG4gICAgICBhbGxvd1hOYW1lOiB0cnVlLFxuICAgICAgYWxsb3dJYW5hVG9rZW46IHRydWVcbiAgICB9LFxuICAgIFwicnN2cFwiOiB7XG4gICAgICB2YWx1ZXM6IFtcIlRSVUVcIiwgXCJGQUxTRVwiXVxuICAgIH0sXG4gICAgXCJzZW50LWJ5XCI6IHtcbiAgICAgIHZhbHVlVHlwZTogXCJjYWwtYWRkcmVzc1wiXG4gICAgfSxcbiAgICBcInR6aWRcIjoge1xuICAgICAgbWF0Y2hlczogL15cXC8vXG4gICAgfSxcbiAgICBcInZhbHVlXCI6IHtcbiAgICAgIC8vIHNpbmNlIHRoZSB2YWx1ZSBoZXJlIGlzIGEgJ3R5cGUnIGxvd2VyY2FzZSBpcyB1c2VkLlxuICAgICAgdmFsdWVzOiBbXCJiaW5hcnlcIiwgXCJib29sZWFuXCIsIFwiY2FsLWFkZHJlc3NcIiwgXCJkYXRlXCIsIFwiZGF0ZS10aW1lXCIsXG4gICAgICAgICAgICAgICBcImR1cmF0aW9uXCIsIFwiZmxvYXRcIiwgXCJpbnRlZ2VyXCIsIFwicGVyaW9kXCIsIFwicmVjdXJcIiwgXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICBcInRpbWVcIiwgXCJ1cmlcIiwgXCJ1dGMtb2Zmc2V0XCJdLFxuICAgICAgYWxsb3dYTmFtZTogdHJ1ZSxcbiAgICAgIGFsbG93SWFuYVRva2VuOiB0cnVlXG4gICAgfVxuICB9O1xuXG4gIC8vIFdoZW4gYWRkaW5nIGEgdmFsdWUgaGVyZSwgYmUgc3VyZSB0byBhZGQgaXQgdG8gdGhlIHBhcmFtZXRlciB0eXBlcyFcbiAgdmFyIGljYWxWYWx1ZXMgPSBJQ0FMLmhlbHBlcnMuZXh0ZW5kKGNvbW1vblZhbHVlcywge1xuICAgIHRleHQ6IGNyZWF0ZVRleHRUeXBlKEZST01fSUNBTF9ORVdMSU5FLCBUT19JQ0FMX05FV0xJTkUpLFxuXG4gICAgdXJpOiB7XG4gICAgICAvLyBUT0RPXG4gICAgICAvKiAuLi4gKi9cbiAgICB9LFxuXG4gICAgXCJiaW5hcnlcIjoge1xuICAgICAgZGVjb3JhdGU6IGZ1bmN0aW9uKGFTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIElDQUwuQmluYXJ5LmZyb21TdHJpbmcoYVN0cmluZyk7XG4gICAgICB9LFxuXG4gICAgICB1bmRlY29yYXRlOiBmdW5jdGlvbihhQmluYXJ5KSB7XG4gICAgICAgIHJldHVybiBhQmluYXJ5LnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBcImNhbC1hZGRyZXNzXCI6IHtcbiAgICAgIC8vIG5lZWRzIHRvIGJlIGFuIHVyaVxuICAgIH0sXG4gICAgXCJkYXRlXCI6IHtcbiAgICAgIGRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUsIGFQcm9wKSB7XG4gICAgICAgIGlmIChkZXNpZ24uc3RyaWN0KSB7XG4gICAgICAgICAgcmV0dXJuIElDQUwuVGltZS5mcm9tRGF0ZVN0cmluZyhhVmFsdWUsIGFQcm9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gSUNBTC5UaW1lLmZyb21TdHJpbmcoYVZhbHVlLCBhUHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogdW5kZWNvcmF0ZXMgYSB0aW1lIG9iamVjdC5cbiAgICAgICAqL1xuICAgICAgdW5kZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhVmFsdWUudG9TdHJpbmcoKTtcbiAgICAgIH0sXG5cbiAgICAgIGZyb21JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgLy8gZnJvbTogMjAxMjA5MDFcbiAgICAgICAgLy8gdG86IDIwMTItMDktMDFcbiAgICAgICAgaWYgKCFkZXNpZ24uc3RyaWN0ICYmIGFWYWx1ZS5sZW5ndGggPj0gMTUpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGEgZGF0ZS10aW1lLCBlLmcuIDIwMTIwOTAxVDEzMDAwMFpcbiAgICAgICAgICByZXR1cm4gaWNhbFZhbHVlc1tcImRhdGUtdGltZVwiXS5mcm9tSUNBTChhVmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBhVmFsdWUuc3Vic3RyKDAsIDQpICsgJy0nICtcbiAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cig0LCAyKSArICctJyArXG4gICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoNiwgMik7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHRvSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIC8vIGZyb206IDIwMTItMDktMDFcbiAgICAgICAgLy8gdG86IDIwMTIwOTAxXG4gICAgICAgIHZhciBsZW4gPSBhVmFsdWUubGVuZ3RoO1xuXG4gICAgICAgIGlmIChsZW4gPT0gMTApIHtcbiAgICAgICAgICByZXR1cm4gYVZhbHVlLnN1YnN0cigwLCA0KSArXG4gICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoNSwgMikgK1xuICAgICAgICAgICAgICAgICBhVmFsdWUuc3Vic3RyKDgsIDIpO1xuICAgICAgICB9IGVsc2UgaWYgKGxlbiA+PSAxOSkge1xuICAgICAgICAgIHJldHVybiBpY2FsVmFsdWVzW1wiZGF0ZS10aW1lXCJdLnRvSUNBTChhVmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vVE9ETzogc2VyaWFsaXplIHdhcm5pbmc/XG4gICAgICAgICAgcmV0dXJuIGFWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgfSxcbiAgICBcImRhdGUtdGltZVwiOiB7XG4gICAgICBmcm9tSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIC8vIGZyb206IDIwMTIwOTAxVDEzMDAwMFxuICAgICAgICAvLyB0bzogMjAxMi0wOS0wMVQxMzowMDowMFxuICAgICAgICBpZiAoIWRlc2lnbi5zdHJpY3QgJiYgYVZhbHVlLmxlbmd0aCA9PSA4KSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBwcm9iYWJseSBhIGRhdGUsIGUuZy4gMjAxMjA5MDFcbiAgICAgICAgICByZXR1cm4gaWNhbFZhbHVlcy5kYXRlLmZyb21JQ0FMKGFWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGFWYWx1ZS5zdWJzdHIoMCwgNCkgKyAnLScgK1xuICAgICAgICAgICAgICAgICAgICAgICBhVmFsdWUuc3Vic3RyKDQsIDIpICsgJy0nICtcbiAgICAgICAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cig2LCAyKSArICdUJyArXG4gICAgICAgICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoOSwgMikgKyAnOicgK1xuICAgICAgICAgICAgICAgICAgICAgICBhVmFsdWUuc3Vic3RyKDExLCAyKSArICc6JyArXG4gICAgICAgICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoMTMsIDIpO1xuXG4gICAgICAgICAgaWYgKGFWYWx1ZVsxNV0gJiYgYVZhbHVlWzE1XSA9PT0gJ1onKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJ1onO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHRvSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIC8vIGZyb206IDIwMTItMDktMDFUMTM6MDA6MDBcbiAgICAgICAgLy8gdG86IDIwMTIwOTAxVDEzMDAwMFxuICAgICAgICB2YXIgbGVuID0gYVZhbHVlLmxlbmd0aDtcblxuICAgICAgICBpZiAobGVuID09IDEwICYmICFkZXNpZ24uc3RyaWN0KSB7XG4gICAgICAgICAgcmV0dXJuIGljYWxWYWx1ZXMuZGF0ZS50b0lDQUwoYVZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChsZW4gPj0gMTkpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gYVZhbHVlLnN1YnN0cigwLCA0KSArXG4gICAgICAgICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoNSwgMikgK1xuICAgICAgICAgICAgICAgICAgICAgICAvLyBncmFiIHRoZSAoRERUSEgpIHNlZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cig4LCA1KSArXG4gICAgICAgICAgICAgICAgICAgICAgIC8vIE1NXG4gICAgICAgICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoMTQsIDIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgLy8gU1NcbiAgICAgICAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cigxNywgMik7XG5cbiAgICAgICAgICBpZiAoYVZhbHVlWzE5XSAmJiBhVmFsdWVbMTldID09PSAnWicpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnWic7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVE9ETzogZXJyb3JcbiAgICAgICAgICByZXR1cm4gYVZhbHVlO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBkZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlLCBhUHJvcCkge1xuICAgICAgICBpZiAoZGVzaWduLnN0cmljdCkge1xuICAgICAgICAgIHJldHVybiBJQ0FMLlRpbWUuZnJvbURhdGVUaW1lU3RyaW5nKGFWYWx1ZSwgYVByb3ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBJQ0FMLlRpbWUuZnJvbVN0cmluZyhhVmFsdWUsIGFQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgdW5kZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhVmFsdWUudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGR1cmF0aW9uOiB7XG4gICAgICBkZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBJQ0FMLkR1cmF0aW9uLmZyb21TdHJpbmcoYVZhbHVlKTtcbiAgICAgIH0sXG4gICAgICB1bmRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFWYWx1ZS50b1N0cmluZygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcGVyaW9kOiB7XG5cbiAgICAgIGZyb21JQ0FMOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgdmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCcvJyk7XG4gICAgICAgIHBhcnRzWzBdID0gaWNhbFZhbHVlc1snZGF0ZS10aW1lJ10uZnJvbUlDQUwocGFydHNbMF0pO1xuXG4gICAgICAgIGlmICghSUNBTC5EdXJhdGlvbi5pc1ZhbHVlU3RyaW5nKHBhcnRzWzFdKSkge1xuICAgICAgICAgIHBhcnRzWzFdID0gaWNhbFZhbHVlc1snZGF0ZS10aW1lJ10uZnJvbUlDQUwocGFydHNbMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnRzO1xuICAgICAgfSxcblxuICAgICAgdG9JQ0FMOiBmdW5jdGlvbihwYXJ0cykge1xuICAgICAgICBpZiAoIWRlc2lnbi5zdHJpY3QgJiYgcGFydHNbMF0ubGVuZ3RoID09IDEwKSB7XG4gICAgICAgICAgcGFydHNbMF0gPSBpY2FsVmFsdWVzLmRhdGUudG9JQ0FMKHBhcnRzWzBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJ0c1swXSA9IGljYWxWYWx1ZXNbJ2RhdGUtdGltZSddLnRvSUNBTChwYXJ0c1swXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUlDQUwuRHVyYXRpb24uaXNWYWx1ZVN0cmluZyhwYXJ0c1sxXSkpIHtcbiAgICAgICAgICBpZiAoIWRlc2lnbi5zdHJpY3QgJiYgcGFydHNbMV0ubGVuZ3RoID09IDEwKSB7XG4gICAgICAgICAgICBwYXJ0c1sxXSA9IGljYWxWYWx1ZXMuZGF0ZS50b0lDQUwocGFydHNbMV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJ0c1sxXSA9IGljYWxWYWx1ZXNbJ2RhdGUtdGltZSddLnRvSUNBTChwYXJ0c1sxXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oXCIvXCIpO1xuICAgICAgfSxcblxuICAgICAgZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSwgYVByb3ApIHtcbiAgICAgICAgcmV0dXJuIElDQUwuUGVyaW9kLmZyb21KU09OKGFWYWx1ZSwgYVByb3AsICFkZXNpZ24uc3RyaWN0KTtcbiAgICAgIH0sXG5cbiAgICAgIHVuZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gYVZhbHVlLnRvSlNPTigpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVjdXI6IHtcbiAgICAgIGZyb21JQ0FMOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIElDQUwuUmVjdXIuX3N0cmluZ1RvRGF0YShzdHJpbmcsIHRydWUpO1xuICAgICAgfSxcblxuICAgICAgdG9JQ0FMOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciBzdHIgPSBcIlwiO1xuICAgICAgICBmb3IgKHZhciBrIGluIGRhdGEpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB2YWwgPSBkYXRhW2tdO1xuICAgICAgICAgIGlmIChrID09IFwidW50aWxcIikge1xuICAgICAgICAgICAgaWYgKHZhbC5sZW5ndGggPiAxMCkge1xuICAgICAgICAgICAgICB2YWwgPSBpY2FsVmFsdWVzWydkYXRlLXRpbWUnXS50b0lDQUwodmFsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhbCA9IGljYWxWYWx1ZXMuZGF0ZS50b0lDQUwodmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGsgPT0gXCJ3a3N0XCIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICB2YWwgPSBJQ0FMLlJlY3VyLm51bWVyaWNEYXlUb0ljYWxEYXkodmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICAgICAgdmFsID0gdmFsLmpvaW4oXCIsXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHIgKz0gay50b1VwcGVyQ2FzZSgpICsgXCI9XCIgKyB2YWwgKyBcIjtcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyLnN1YnN0cigwLCBzdHIubGVuZ3RoIC0gMSk7XG4gICAgICB9LFxuXG4gICAgICBkZWNvcmF0ZTogZnVuY3Rpb24gZGVjb3JhdGUoYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBJQ0FMLlJlY3VyLmZyb21EYXRhKGFWYWx1ZSk7XG4gICAgICB9LFxuXG4gICAgICB1bmRlY29yYXRlOiBmdW5jdGlvbihhUmVjdXIpIHtcbiAgICAgICAgcmV0dXJuIGFSZWN1ci50b0pTT04oKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdGltZToge1xuICAgICAgZnJvbUlDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICAvLyBmcm9tOiBNTUhIU1MoWik/XG4gICAgICAgIC8vIHRvOiBISDpNTTpTUyhaKT9cbiAgICAgICAgaWYgKGFWYWx1ZS5sZW5ndGggPCA2KSB7XG4gICAgICAgICAgLy8gVE9ETzogcGFyc2VyIGV4Y2VwdGlvbj9cbiAgICAgICAgICByZXR1cm4gYVZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSEg6Ok1NOjpTU1o/XG4gICAgICAgIHZhciByZXN1bHQgPSBhVmFsdWUuc3Vic3RyKDAsIDIpICsgJzonICtcbiAgICAgICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoMiwgMikgKyAnOicgK1xuICAgICAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cig0LCAyKTtcblxuICAgICAgICBpZiAoYVZhbHVlWzZdID09PSAnWicpIHtcbiAgICAgICAgICByZXN1bHQgKz0gJ1onO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sXG5cbiAgICAgIHRvSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIC8vIGZyb206IEhIOk1NOlNTKFopP1xuICAgICAgICAvLyB0bzogTU1ISFNTKFopP1xuICAgICAgICBpZiAoYVZhbHVlLmxlbmd0aCA8IDgpIHtcbiAgICAgICAgICAvL1RPRE86IGVycm9yXG4gICAgICAgICAgcmV0dXJuIGFWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSBhVmFsdWUuc3Vic3RyKDAsIDIpICtcbiAgICAgICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoMywgMikgK1xuICAgICAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cig2LCAyKTtcblxuICAgICAgICBpZiAoYVZhbHVlWzhdID09PSAnWicpIHtcbiAgICAgICAgICByZXN1bHQgKz0gJ1onO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHZhciBpY2FsUHJvcGVydGllcyA9IElDQUwuaGVscGVycy5leHRlbmQoY29tbW9uUHJvcGVydGllcywge1xuXG4gICAgXCJhY3Rpb25cIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgXCJhdHRhY2hcIjogeyBkZWZhdWx0VHlwZTogXCJ1cmlcIiB9LFxuICAgIFwiYXR0ZW5kZWVcIjogeyBkZWZhdWx0VHlwZTogXCJjYWwtYWRkcmVzc1wiIH0sXG4gICAgXCJjYWxzY2FsZVwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBcImNsYXNzXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIFwiY29tbWVudFwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBcImNvbXBsZXRlZFwiOiBERUZBVUxUX1RZUEVfREFURVRJTUUsXG4gICAgXCJjb250YWN0XCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIFwiY3JlYXRlZFwiOiBERUZBVUxUX1RZUEVfREFURVRJTUUsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBcImR0ZW5kXCI6IERFRkFVTFRfVFlQRV9EQVRFVElNRV9EQVRFLFxuICAgIFwiZHRzdGFtcFwiOiBERUZBVUxUX1RZUEVfREFURVRJTUUsXG4gICAgXCJkdHN0YXJ0XCI6IERFRkFVTFRfVFlQRV9EQVRFVElNRV9EQVRFLFxuICAgIFwiZHVlXCI6IERFRkFVTFRfVFlQRV9EQVRFVElNRV9EQVRFLFxuICAgIFwiZHVyYXRpb25cIjogeyBkZWZhdWx0VHlwZTogXCJkdXJhdGlvblwiIH0sXG4gICAgXCJleGRhdGVcIjoge1xuICAgICAgZGVmYXVsdFR5cGU6IFwiZGF0ZS10aW1lXCIsXG4gICAgICBhbGxvd2VkVHlwZXM6IFtcImRhdGUtdGltZVwiLCBcImRhdGVcIl0sXG4gICAgICBtdWx0aVZhbHVlOiAnLCdcbiAgICB9LFxuICAgIFwiZXhydWxlXCI6IERFRkFVTFRfVFlQRV9SRUNVUixcbiAgICBcImZyZWVidXN5XCI6IHsgZGVmYXVsdFR5cGU6IFwicGVyaW9kXCIsIG11bHRpVmFsdWU6IFwiLFwiIH0sXG4gICAgXCJnZW9cIjogeyBkZWZhdWx0VHlwZTogXCJmbG9hdFwiLCBzdHJ1Y3R1cmVkVmFsdWU6IFwiO1wiIH0sXG4gICAgXCJsYXN0LW1vZGlmaWVkXCI6IERFRkFVTFRfVFlQRV9EQVRFVElNRSxcbiAgICBcImxvY2F0aW9uXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIFwibWV0aG9kXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIFwib3JnYW5pemVyXCI6IHsgZGVmYXVsdFR5cGU6IFwiY2FsLWFkZHJlc3NcIiB9LFxuICAgIFwicGVyY2VudC1jb21wbGV0ZVwiOiBERUZBVUxUX1RZUEVfSU5URUdFUixcbiAgICBcInByaW9yaXR5XCI6IERFRkFVTFRfVFlQRV9JTlRFR0VSLFxuICAgIFwicHJvZGlkXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIFwicmVsYXRlZC10b1wiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBcInJlcGVhdFwiOiBERUZBVUxUX1RZUEVfSU5URUdFUixcbiAgICBcInJkYXRlXCI6IHtcbiAgICAgIGRlZmF1bHRUeXBlOiBcImRhdGUtdGltZVwiLFxuICAgICAgYWxsb3dlZFR5cGVzOiBbXCJkYXRlLXRpbWVcIiwgXCJkYXRlXCIsIFwicGVyaW9kXCJdLFxuICAgICAgbXVsdGlWYWx1ZTogJywnLFxuICAgICAgZGV0ZWN0VHlwZTogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIGlmIChzdHJpbmcuaW5kZXhPZignLycpICE9PSAtMSkge1xuICAgICAgICAgIHJldHVybiAncGVyaW9kJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHN0cmluZy5pbmRleE9mKCdUJykgPT09IC0xKSA/ICdkYXRlJyA6ICdkYXRlLXRpbWUnO1xuICAgICAgfVxuICAgIH0sXG4gICAgXCJyZWN1cnJlbmNlLWlkXCI6IERFRkFVTFRfVFlQRV9EQVRFVElNRV9EQVRFLFxuICAgIFwicmVzb3VyY2VzXCI6IERFRkFVTFRfVFlQRV9URVhUX01VTFRJLFxuICAgIFwicmVxdWVzdC1zdGF0dXNcIjogREVGQVVMVF9UWVBFX1RFWFRfU1RSVUNUVVJFRCxcbiAgICBcInJydWxlXCI6IERFRkFVTFRfVFlQRV9SRUNVUixcbiAgICBcInNlcXVlbmNlXCI6IERFRkFVTFRfVFlQRV9JTlRFR0VSLFxuICAgIFwic3RhdHVzXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIFwic3VtbWFyeVwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBcInRyYW5zcFwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBcInRyaWdnZXJcIjogeyBkZWZhdWx0VHlwZTogXCJkdXJhdGlvblwiLCBhbGxvd2VkVHlwZXM6IFtcImR1cmF0aW9uXCIsIFwiZGF0ZS10aW1lXCJdIH0sXG4gICAgXCJ0em9mZnNldGZyb21cIjogREVGQVVMVF9UWVBFX1VUQ09GRlNFVCxcbiAgICBcInR6b2Zmc2V0dG9cIjogREVGQVVMVF9UWVBFX1VUQ09GRlNFVCxcbiAgICBcInR6dXJsXCI6IERFRkFVTFRfVFlQRV9VUkksXG4gICAgXCJ0emlkXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIFwidHpuYW1lXCI6IERFRkFVTFRfVFlQRV9URVhUXG4gIH0pO1xuXG4gIC8vIFdoZW4gYWRkaW5nIGEgdmFsdWUgaGVyZSwgYmUgc3VyZSB0byBhZGQgaXQgdG8gdGhlIHBhcmFtZXRlciB0eXBlcyFcbiAgdmFyIHZjYXJkVmFsdWVzID0gSUNBTC5oZWxwZXJzLmV4dGVuZChjb21tb25WYWx1ZXMsIHtcbiAgICB0ZXh0OiBjcmVhdGVUZXh0VHlwZShGUk9NX1ZDQVJEX05FV0xJTkUsIFRPX1ZDQVJEX05FV0xJTkUpLFxuICAgIHVyaTogY3JlYXRlVGV4dFR5cGUoRlJPTV9WQ0FSRF9ORVdMSU5FLCBUT19WQ0FSRF9ORVdMSU5FKSxcblxuICAgIGRhdGU6IHtcbiAgICAgIGRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIElDQUwuVkNhcmRUaW1lLmZyb21EYXRlQW5kT3JUaW1lU3RyaW5nKGFWYWx1ZSwgXCJkYXRlXCIpO1xuICAgICAgfSxcbiAgICAgIHVuZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gYVZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICB9LFxuICAgICAgZnJvbUlDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICBpZiAoYVZhbHVlLmxlbmd0aCA9PSA4KSB7XG4gICAgICAgICAgcmV0dXJuIGljYWxWYWx1ZXMuZGF0ZS5mcm9tSUNBTChhVmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGFWYWx1ZVswXSA9PSAnLScgJiYgYVZhbHVlLmxlbmd0aCA9PSA2KSB7XG4gICAgICAgICAgcmV0dXJuIGFWYWx1ZS5zdWJzdHIoMCwgNCkgKyAnLScgKyBhVmFsdWUuc3Vic3RyKDQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBhVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0b0lDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICBpZiAoYVZhbHVlLmxlbmd0aCA9PSAxMCkge1xuICAgICAgICAgIHJldHVybiBpY2FsVmFsdWVzLmRhdGUudG9JQ0FMKGFWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYVZhbHVlWzBdID09ICctJyAmJiBhVmFsdWUubGVuZ3RoID09IDcpIHtcbiAgICAgICAgICByZXR1cm4gYVZhbHVlLnN1YnN0cigwLCA0KSArIGFWYWx1ZS5zdWJzdHIoNSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGFWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICB0aW1lOiB7XG4gICAgICBkZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBJQ0FMLlZDYXJkVGltZS5mcm9tRGF0ZUFuZE9yVGltZVN0cmluZyhcIlRcIiArIGFWYWx1ZSwgXCJ0aW1lXCIpO1xuICAgICAgfSxcbiAgICAgIHVuZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gYVZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICB9LFxuICAgICAgZnJvbUlDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICB2YXIgc3BsaXR6b25lID0gdmNhcmRWYWx1ZXMudGltZS5fc3BsaXRab25lKGFWYWx1ZSwgdHJ1ZSk7XG4gICAgICAgIHZhciB6b25lID0gc3BsaXR6b25lWzBdLCB2YWx1ZSA9IHNwbGl0em9uZVsxXTtcblxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiU1BMSVQ6IFwiLHNwbGl0em9uZSk7XG5cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PSA2KSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHIoMCwgMikgKyAnOicgK1xuICAgICAgICAgICAgICAgICAgdmFsdWUuc3Vic3RyKDIsIDIpICsgJzonICtcbiAgICAgICAgICAgICAgICAgIHZhbHVlLnN1YnN0cig0LCAyKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZS5sZW5ndGggPT0gNCAmJiB2YWx1ZVswXSAhPSAnLScpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cigwLCAyKSArICc6JyArIHZhbHVlLnN1YnN0cigyLCAyKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZS5sZW5ndGggPT0gNSkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyKDAsIDMpICsgJzonICsgdmFsdWUuc3Vic3RyKDMsIDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHpvbmUubGVuZ3RoID09IDUgJiYgKHpvbmVbMF0gPT0gJy0nIHx8IHpvbmVbMF0gPT0gJysnKSkge1xuICAgICAgICAgIHpvbmUgPSB6b25lLnN1YnN0cigwLCAzKSArICc6JyArIHpvbmUuc3Vic3RyKDMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlICsgem9uZTtcbiAgICAgIH0sXG5cbiAgICAgIHRvSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHZhciBzcGxpdHpvbmUgPSB2Y2FyZFZhbHVlcy50aW1lLl9zcGxpdFpvbmUoYVZhbHVlKTtcbiAgICAgICAgdmFyIHpvbmUgPSBzcGxpdHpvbmVbMF0sIHZhbHVlID0gc3BsaXR6b25lWzFdO1xuXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT0gOCkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyKDAsIDIpICtcbiAgICAgICAgICAgICAgICAgIHZhbHVlLnN1YnN0cigzLCAyKSArXG4gICAgICAgICAgICAgICAgICB2YWx1ZS5zdWJzdHIoNiwgMik7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUubGVuZ3RoID09IDUgJiYgdmFsdWVbMF0gIT0gJy0nKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHIoMCwgMikgKyB2YWx1ZS5zdWJzdHIoMywgMik7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUubGVuZ3RoID09IDYpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cigwLCAzKSArIHZhbHVlLnN1YnN0cig0LCAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh6b25lLmxlbmd0aCA9PSA2ICYmICh6b25lWzBdID09ICctJyB8fCB6b25lWzBdID09ICcrJykpIHtcbiAgICAgICAgICB6b25lID0gem9uZS5zdWJzdHIoMCwgMykgKyB6b25lLnN1YnN0cig0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZSArIHpvbmU7XG4gICAgICB9LFxuXG4gICAgICBfc3BsaXRab25lOiBmdW5jdGlvbihhVmFsdWUsIGlzRnJvbUljYWwpIHtcbiAgICAgICAgdmFyIGxhc3RDaGFyID0gYVZhbHVlLmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBzaWduQ2hhciA9IGFWYWx1ZS5sZW5ndGggLSAoaXNGcm9tSWNhbCA/IDUgOiA2KTtcbiAgICAgICAgdmFyIHNpZ24gPSBhVmFsdWVbc2lnbkNoYXJdO1xuICAgICAgICB2YXIgem9uZSwgdmFsdWU7XG5cbiAgICAgICAgaWYgKGFWYWx1ZVtsYXN0Q2hhcl0gPT0gJ1onKSB7XG4gICAgICAgICAgem9uZSA9IGFWYWx1ZVtsYXN0Q2hhcl07XG4gICAgICAgICAgdmFsdWUgPSBhVmFsdWUuc3Vic3RyKDAsIGxhc3RDaGFyKTtcbiAgICAgICAgfSBlbHNlIGlmIChhVmFsdWUubGVuZ3RoID4gNiAmJiAoc2lnbiA9PSAnLScgfHwgc2lnbiA9PSAnKycpKSB7XG4gICAgICAgICAgem9uZSA9IGFWYWx1ZS5zdWJzdHIoc2lnbkNoYXIpO1xuICAgICAgICAgIHZhbHVlID0gYVZhbHVlLnN1YnN0cigwLCBzaWduQ2hhcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgem9uZSA9IFwiXCI7XG4gICAgICAgICAgdmFsdWUgPSBhVmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW3pvbmUsIHZhbHVlXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJkYXRlLXRpbWVcIjoge1xuICAgICAgZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gSUNBTC5WQ2FyZFRpbWUuZnJvbURhdGVBbmRPclRpbWVTdHJpbmcoYVZhbHVlLCBcImRhdGUtdGltZVwiKTtcbiAgICAgIH0sXG5cbiAgICAgIHVuZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gYVZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICB9LFxuXG4gICAgICBmcm9tSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2Y2FyZFZhbHVlc1snZGF0ZS1hbmQtb3ItdGltZSddLmZyb21JQ0FMKGFWYWx1ZSk7XG4gICAgICB9LFxuXG4gICAgICB0b0lDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdmNhcmRWYWx1ZXNbJ2RhdGUtYW5kLW9yLXRpbWUnXS50b0lDQUwoYVZhbHVlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJkYXRlLWFuZC1vci10aW1lXCI6IHtcbiAgICAgIGRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIElDQUwuVkNhcmRUaW1lLmZyb21EYXRlQW5kT3JUaW1lU3RyaW5nKGFWYWx1ZSwgXCJkYXRlLWFuZC1vci10aW1lXCIpO1xuICAgICAgfSxcblxuICAgICAgdW5kZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhVmFsdWUudG9TdHJpbmcoKTtcbiAgICAgIH0sXG5cbiAgICAgIGZyb21JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgdmFyIHBhcnRzID0gYVZhbHVlLnNwbGl0KCdUJyk7XG4gICAgICAgIHJldHVybiAocGFydHNbMF0gPyB2Y2FyZFZhbHVlcy5kYXRlLmZyb21JQ0FMKHBhcnRzWzBdKSA6ICcnKSArXG4gICAgICAgICAgICAgICAocGFydHNbMV0gPyAnVCcgKyB2Y2FyZFZhbHVlcy50aW1lLmZyb21JQ0FMKHBhcnRzWzFdKSA6ICcnKTtcbiAgICAgIH0sXG5cbiAgICAgIHRvSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IGFWYWx1ZS5zcGxpdCgnVCcpO1xuICAgICAgICByZXR1cm4gdmNhcmRWYWx1ZXMuZGF0ZS50b0lDQUwocGFydHNbMF0pICtcbiAgICAgICAgICAgICAgIChwYXJ0c1sxXSA/ICdUJyArIHZjYXJkVmFsdWVzLnRpbWUudG9JQ0FMKHBhcnRzWzFdKSA6ICcnKTtcblxuICAgICAgfVxuICAgIH0sXG4gICAgdGltZXN0YW1wOiBpY2FsVmFsdWVzWydkYXRlLXRpbWUnXSxcbiAgICBcImxhbmd1YWdlLXRhZ1wiOiB7XG4gICAgICBtYXRjaGVzOiAvXlthLXpBLVowLTktXSskLyAvLyBDb3VsZCBnbyB3aXRoIGEgbW9yZSBzdHJpY3QgcmVnZXggaGVyZVxuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHZjYXJkUGFyYW1zID0ge1xuICAgIFwidHlwZVwiOiB7XG4gICAgICB2YWx1ZVR5cGU6IFwidGV4dFwiLFxuICAgICAgbXVsdGlWYWx1ZTogXCIsXCJcbiAgICB9LFxuICAgIFwidmFsdWVcIjoge1xuICAgICAgLy8gc2luY2UgdGhlIHZhbHVlIGhlcmUgaXMgYSAndHlwZScgbG93ZXJjYXNlIGlzIHVzZWQuXG4gICAgICB2YWx1ZXM6IFtcInRleHRcIiwgXCJ1cmlcIiwgXCJkYXRlXCIsIFwidGltZVwiLCBcImRhdGUtdGltZVwiLCBcImRhdGUtYW5kLW9yLXRpbWVcIixcbiAgICAgICAgICAgICAgIFwidGltZXN0YW1wXCIsIFwiYm9vbGVhblwiLCBcImludGVnZXJcIiwgXCJmbG9hdFwiLCBcInV0Yy1vZmZzZXRcIixcbiAgICAgICAgICAgICAgIFwibGFuZ3VhZ2UtdGFnXCJdLFxuICAgICAgYWxsb3dYTmFtZTogdHJ1ZSxcbiAgICAgIGFsbG93SWFuYVRva2VuOiB0cnVlXG4gICAgfVxuICB9O1xuXG4gIHZhciB2Y2FyZFByb3BlcnRpZXMgPSBJQ0FMLmhlbHBlcnMuZXh0ZW5kKGNvbW1vblByb3BlcnRpZXMsIHtcbiAgICBcImFkclwiOiB7IGRlZmF1bHRUeXBlOiBcInRleHRcIiwgc3RydWN0dXJlZFZhbHVlOiBcIjtcIiwgbXVsdGlWYWx1ZTogXCIsXCIgfSxcbiAgICBcImFubml2ZXJzYXJ5XCI6IERFRkFVTFRfVFlQRV9EQVRFX0FORE9SX1RJTUUsXG4gICAgXCJiZGF5XCI6IERFRkFVTFRfVFlQRV9EQVRFX0FORE9SX1RJTUUsXG4gICAgXCJjYWxhZHJ1cmlcIjogREVGQVVMVF9UWVBFX1VSSSxcbiAgICBcImNhbHVyaVwiOiBERUZBVUxUX1RZUEVfVVJJLFxuICAgIFwiY2xpZW50cGlkbWFwXCI6IERFRkFVTFRfVFlQRV9URVhUX1NUUlVDVFVSRUQsXG4gICAgXCJlbWFpbFwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBcImZidXJsXCI6IERFRkFVTFRfVFlQRV9VUkksXG4gICAgXCJmblwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBcImdlbmRlclwiOiBERUZBVUxUX1RZUEVfVEVYVF9TVFJVQ1RVUkVELFxuICAgIFwiZ2VvXCI6IERFRkFVTFRfVFlQRV9VUkksXG4gICAgXCJpbXBwXCI6IERFRkFVTFRfVFlQRV9VUkksXG4gICAgXCJrZXlcIjogREVGQVVMVF9UWVBFX1VSSSxcbiAgICBcImtpbmRcIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgXCJsYW5nXCI6IHsgZGVmYXVsdFR5cGU6IFwibGFuZ3VhZ2UtdGFnXCIgfSxcbiAgICBcImxvZ29cIjogREVGQVVMVF9UWVBFX1VSSSxcbiAgICBcIm1lbWJlclwiOiBERUZBVUxUX1RZUEVfVVJJLFxuICAgIFwiblwiOiB7IGRlZmF1bHRUeXBlOiBcInRleHRcIiwgc3RydWN0dXJlZFZhbHVlOiBcIjtcIiwgbXVsdGlWYWx1ZTogXCIsXCIgfSxcbiAgICBcIm5pY2tuYW1lXCI6IERFRkFVTFRfVFlQRV9URVhUX01VTFRJLFxuICAgIFwibm90ZVwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBcIm9yZ1wiOiB7IGRlZmF1bHRUeXBlOiBcInRleHRcIiwgc3RydWN0dXJlZFZhbHVlOiBcIjtcIiB9LFxuICAgIFwicGhvdG9cIjogREVGQVVMVF9UWVBFX1VSSSxcbiAgICBcInJlbGF0ZWRcIjogREVGQVVMVF9UWVBFX1VSSSxcbiAgICBcInJldlwiOiB7IGRlZmF1bHRUeXBlOiBcInRpbWVzdGFtcFwiIH0sXG4gICAgXCJyb2xlXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIFwic291bmRcIjogREVGQVVMVF9UWVBFX1VSSSxcbiAgICBcInNvdXJjZVwiOiBERUZBVUxUX1RZUEVfVVJJLFxuICAgIFwidGVsXCI6IHsgZGVmYXVsdFR5cGU6IFwidXJpXCIsIGFsbG93ZWRUeXBlczogW1widXJpXCIsIFwidGV4dFwiXSB9LFxuICAgIFwidGl0bGVcIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgXCJ0elwiOiB7IGRlZmF1bHRUeXBlOiBcInRleHRcIiwgYWxsb3dlZFR5cGVzOiBbXCJ0ZXh0XCIsIFwidXRjLW9mZnNldFwiLCBcInVyaVwiXSB9LFxuICAgIFwieG1sXCI6IERFRkFVTFRfVFlQRV9URVhUXG4gIH0pO1xuXG4gIHZhciB2Y2FyZDNWYWx1ZXMgPSBJQ0FMLmhlbHBlcnMuZXh0ZW5kKGNvbW1vblZhbHVlcywge1xuICAgIGJpbmFyeTogaWNhbFZhbHVlcy5iaW5hcnksXG4gICAgZGF0ZTogdmNhcmRWYWx1ZXMuZGF0ZSxcbiAgICBcImRhdGUtdGltZVwiOiB2Y2FyZFZhbHVlc1tcImRhdGUtdGltZVwiXSxcbiAgICBcInBob25lLW51bWJlclwiOiB7XG4gICAgICAvLyBUT0RPXG4gICAgICAvKiAuLi4gKi9cbiAgICB9LFxuICAgIHVyaTogaWNhbFZhbHVlcy51cmksXG4gICAgdGV4dDogaWNhbFZhbHVlcy50ZXh0LFxuICAgIHRpbWU6IGljYWxWYWx1ZXMudGltZSxcbiAgICB2Y2FyZDogaWNhbFZhbHVlcy50ZXh0LFxuICAgIFwidXRjLW9mZnNldFwiOiB7XG4gICAgICB0b0lDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gYVZhbHVlLnN1YnN0cigwLCA3KTtcbiAgICAgIH0sXG5cbiAgICAgIGZyb21JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFWYWx1ZS5zdWJzdHIoMCwgNyk7XG4gICAgICB9LFxuXG4gICAgICBkZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBJQ0FMLlV0Y09mZnNldC5mcm9tU3RyaW5nKGFWYWx1ZSk7XG4gICAgICB9LFxuXG4gICAgICB1bmRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFWYWx1ZS50b1N0cmluZygpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHZjYXJkM1BhcmFtcyA9IHtcbiAgICBcInR5cGVcIjoge1xuICAgICAgdmFsdWVUeXBlOiBcInRleHRcIixcbiAgICAgIG11bHRpVmFsdWU6IFwiLFwiXG4gICAgfSxcbiAgICBcInZhbHVlXCI6IHtcbiAgICAgIC8vIHNpbmNlIHRoZSB2YWx1ZSBoZXJlIGlzIGEgJ3R5cGUnIGxvd2VyY2FzZSBpcyB1c2VkLlxuICAgICAgdmFsdWVzOiBbXCJ0ZXh0XCIsIFwidXJpXCIsIFwiZGF0ZVwiLCBcImRhdGUtdGltZVwiLCBcInBob25lLW51bWJlclwiLCBcInRpbWVcIixcbiAgICAgICAgICAgICAgIFwiYm9vbGVhblwiLCBcImludGVnZXJcIiwgXCJmbG9hdFwiLCBcInV0Yy1vZmZzZXRcIiwgXCJ2Y2FyZFwiLCBcImJpbmFyeVwiXSxcbiAgICAgIGFsbG93WE5hbWU6IHRydWUsXG4gICAgICBhbGxvd0lhbmFUb2tlbjogdHJ1ZVxuICAgIH1cbiAgfTtcblxuICB2YXIgdmNhcmQzUHJvcGVydGllcyA9IElDQUwuaGVscGVycy5leHRlbmQoY29tbW9uUHJvcGVydGllcywge1xuICAgIGZuOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBuOiB7IGRlZmF1bHRUeXBlOiBcInRleHRcIiwgc3RydWN0dXJlZFZhbHVlOiBcIjtcIiwgbXVsdGlWYWx1ZTogXCIsXCIgfSxcbiAgICBuaWNrbmFtZTogREVGQVVMVF9UWVBFX1RFWFRfTVVMVEksXG4gICAgcGhvdG86IHsgZGVmYXVsdFR5cGU6IFwiYmluYXJ5XCIsIGFsbG93ZWRUeXBlczogW1wiYmluYXJ5XCIsIFwidXJpXCJdIH0sXG4gICAgYmRheToge1xuICAgICAgZGVmYXVsdFR5cGU6IFwiZGF0ZS10aW1lXCIsXG4gICAgICBhbGxvd2VkVHlwZXM6IFtcImRhdGUtdGltZVwiLCBcImRhdGVcIl0sXG4gICAgICBkZXRlY3RUeXBlOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIChzdHJpbmcuaW5kZXhPZignVCcpID09PSAtMSkgPyAnZGF0ZScgOiAnZGF0ZS10aW1lJztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWRyOiB7IGRlZmF1bHRUeXBlOiBcInRleHRcIiwgc3RydWN0dXJlZFZhbHVlOiBcIjtcIiwgbXVsdGlWYWx1ZTogXCIsXCIgfSxcbiAgICBsYWJlbDogREVGQVVMVF9UWVBFX1RFWFQsXG5cbiAgICB0ZWw6IHsgZGVmYXVsdFR5cGU6IFwicGhvbmUtbnVtYmVyXCIgfSxcbiAgICBlbWFpbDogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgbWFpbGVyOiBERUZBVUxUX1RZUEVfVEVYVCxcblxuICAgIHR6OiB7IGRlZmF1bHRUeXBlOiBcInV0Yy1vZmZzZXRcIiwgYWxsb3dlZFR5cGVzOiBbXCJ1dGMtb2Zmc2V0XCIsIFwidGV4dFwiXSB9LFxuICAgIGdlbzogeyBkZWZhdWx0VHlwZTogXCJmbG9hdFwiLCBzdHJ1Y3R1cmVkVmFsdWU6IFwiO1wiIH0sXG5cbiAgICB0aXRsZTogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgcm9sZTogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgbG9nbzogeyBkZWZhdWx0VHlwZTogXCJiaW5hcnlcIiwgYWxsb3dlZFR5cGVzOiBbXCJiaW5hcnlcIiwgXCJ1cmlcIl0gfSxcbiAgICBhZ2VudDogeyBkZWZhdWx0VHlwZTogXCJ2Y2FyZFwiLCBhbGxvd2VkVHlwZXM6IFtcInZjYXJkXCIsIFwidGV4dFwiLCBcInVyaVwiXSB9LFxuICAgIG9yZzogREVGQVVMVF9UWVBFX1RFWFRfU1RSVUNUVVJFRCxcblxuICAgIG5vdGU6IERFRkFVTFRfVFlQRV9URVhUX01VTFRJLFxuICAgIHByb2RpZDogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgcmV2OiB7XG4gICAgICBkZWZhdWx0VHlwZTogXCJkYXRlLXRpbWVcIixcbiAgICAgIGFsbG93ZWRUeXBlczogW1wiZGF0ZS10aW1lXCIsIFwiZGF0ZVwiXSxcbiAgICAgIGRldGVjdFR5cGU6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICByZXR1cm4gKHN0cmluZy5pbmRleE9mKCdUJykgPT09IC0xKSA/ICdkYXRlJyA6ICdkYXRlLXRpbWUnO1xuICAgICAgfVxuICAgIH0sXG4gICAgXCJzb3J0LXN0cmluZ1wiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBzb3VuZDogeyBkZWZhdWx0VHlwZTogXCJiaW5hcnlcIiwgYWxsb3dlZFR5cGVzOiBbXCJiaW5hcnlcIiwgXCJ1cmlcIl0gfSxcblxuICAgIGNsYXNzOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBrZXk6IHsgZGVmYXVsdFR5cGU6IFwiYmluYXJ5XCIsIGFsbG93ZWRUeXBlczogW1wiYmluYXJ5XCIsIFwidGV4dFwiXSB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBpQ2FsZW5kYXIgZGVzaWduIHNldFxuICAgKiBAdHlwZSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fVxuICAgKi9cbiAgdmFyIGljYWxTZXQgPSB7XG4gICAgdmFsdWU6IGljYWxWYWx1ZXMsXG4gICAgcGFyYW06IGljYWxQYXJhbXMsXG4gICAgcHJvcGVydHk6IGljYWxQcm9wZXJ0aWVzXG4gIH07XG5cbiAgLyoqXG4gICAqIHZDYXJkIDQuMCBkZXNpZ24gc2V0XG4gICAqIEB0eXBlIHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9XG4gICAqL1xuICB2YXIgdmNhcmRTZXQgPSB7XG4gICAgdmFsdWU6IHZjYXJkVmFsdWVzLFxuICAgIHBhcmFtOiB2Y2FyZFBhcmFtcyxcbiAgICBwcm9wZXJ0eTogdmNhcmRQcm9wZXJ0aWVzXG4gIH07XG5cbiAgLyoqXG4gICAqIHZDYXJkIDMuMCBkZXNpZ24gc2V0XG4gICAqIEB0eXBlIHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9XG4gICAqL1xuICB2YXIgdmNhcmQzU2V0ID0ge1xuICAgIHZhbHVlOiB2Y2FyZDNWYWx1ZXMsXG4gICAgcGFyYW06IHZjYXJkM1BhcmFtcyxcbiAgICBwcm9wZXJ0eTogdmNhcmQzUHJvcGVydGllc1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgZGVzaWduIGRhdGEsIHVzZWQgYnkgdGhlIHBhcnNlciB0byBkZXRlcm1pbmUgdHlwZXMgZm9yIHByb3BlcnRpZXMgYW5kXG4gICAqIG90aGVyIG1ldGFkYXRhIG5lZWRlZCB0byBwcm9kdWNlIGNvcnJlY3QgakNhcmQvakNhbCBkYXRhLlxuICAgKlxuICAgKiBAYWxpYXMgSUNBTC5kZXNpZ25cbiAgICogQG5hbWVzcGFjZVxuICAgKi9cbiAgdmFyIGRlc2lnbiA9IHtcbiAgICAvKipcbiAgICAgKiBBIGRlc2lnblNldCBkZXNjcmliZXMgdmFsdWUsIHBhcmFtZXRlciBhbmQgcHJvcGVydHkgZGF0YS4gSXQgaXMgdXNlZCBieVxuICAgICAqIHRoZXIgcGFyc2VyIGFuZCBzdHJpbmdpZmllciBpbiBjb21wb25lbnRzIGFuZCBwcm9wZXJ0aWVzIHRvIGRldGVybWluZSB0aGV5XG4gICAgICogc2hvdWxkIGJlIHJlcHJlc2VudGVkLlxuICAgICAqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gZGVzaWduU2V0XG4gICAgICogQG1lbWJlck9mIElDQUwuZGVzaWduXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IHZhbHVlICAgICAgIERlZmluaXRpb25zIGZvciB2YWx1ZSB0eXBlcywga2V5cyBhcmUgdHlwZSBuYW1lc1xuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBwYXJhbSAgICAgICBEZWZpbml0aW9ucyBmb3IgcGFyYW1zLCBrZXlzIGFyZSBwYXJhbSBuYW1lc1xuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBwcm9wZXJ0eSAgICBEZWZpbnRpb25zIGZvciBwcm9wZXJ0aWVzLCBrZXlzIGFyZSBwcm9wZXJ0eSBuYW1lc1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQ2FuIGJlIHNldCB0byBmYWxzZSB0byBtYWtlIHRoZSBwYXJzZXIgbW9yZSBsZW5pZW50LlxuICAgICAqL1xuICAgIHN0cmljdDogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IHNldCBmb3IgbmV3IHByb3BlcnRpZXMgYW5kIGNvbXBvbmVudHMgaWYgbm9uZSBpcyBzcGVjaWZpZWQuXG4gICAgICogQHR5cGUge0lDQUwuZGVzaWduLmRlc2lnblNldH1cbiAgICAgKi9cbiAgICBkZWZhdWx0U2V0OiBpY2FsU2V0LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgdHlwZSBmb3IgdW5rbm93biBwcm9wZXJ0aWVzXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBkZWZhdWx0VHlwZTogJ3Vua25vd24nLFxuXG4gICAgLyoqXG4gICAgICogSG9sZHMgdGhlIGRlc2lnbiBzZXQgZm9yIGtub3duIHRvcC1sZXZlbCBjb21wb25lbnRzXG4gICAgICpcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fSB2Y2FyZCAgICAgICB2Q2FyZCBWQ0FSRFxuICAgICAqIEBwcm9wZXJ0eSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fSB2ZXZlbnQgICAgICBpQ2FsZW5kYXIgVkVWRU5UXG4gICAgICogQHByb3BlcnR5IHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9IHZ0b2RvICAgICAgIGlDYWxlbmRhciBWVE9ET1xuICAgICAqIEBwcm9wZXJ0eSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fSB2am91cm5hbCAgICBpQ2FsZW5kYXIgVkpPVVJOQUxcbiAgICAgKiBAcHJvcGVydHkge0lDQUwuZGVzaWduLmRlc2lnblNldH0gdmFsYXJtICAgICAgaUNhbGVuZGFyIFZBTEFSTVxuICAgICAqIEBwcm9wZXJ0eSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fSB2dGltZXpvbmUgICBpQ2FsZW5kYXIgVlRJTUVaT05FXG4gICAgICogQHByb3BlcnR5IHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9IGRheWxpZ2h0ICAgIGlDYWxlbmRhciBEQVlMSUdIVFxuICAgICAqIEBwcm9wZXJ0eSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fSBzdGFuZGFyZCAgICBpQ2FsZW5kYXIgU1RBTkRBUkRcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIHByb3BlcnR5TmFtZSA9ICdmbic7XG4gICAgICogdmFyIGNvbXBvbmVudERlc2lnbiA9IElDQUwuZGVzaWduLmNvbXBvbmVudHMudmNhcmQ7XG4gICAgICogdmFyIHByb3BlcnR5RGV0YWlscyA9IGNvbXBvbmVudERlc2lnbi5wcm9wZXJ0eVtwcm9wZXJ0eU5hbWVdO1xuICAgICAqIGlmIChwcm9wZXJ0eURldGFpbHMuZGVmYXVsdFR5cGUgPT0gJ3RleHQnKSB7XG4gICAgICogICAvLyBZZXAsIHN1cmUgaXMuLi5cbiAgICAgKiB9XG4gICAgICovXG4gICAgY29tcG9uZW50czoge1xuICAgICAgdmNhcmQ6IHZjYXJkU2V0LFxuICAgICAgdmNhcmQzOiB2Y2FyZDNTZXQsXG4gICAgICB2ZXZlbnQ6IGljYWxTZXQsXG4gICAgICB2dG9kbzogaWNhbFNldCxcbiAgICAgIHZqb3VybmFsOiBpY2FsU2V0LFxuICAgICAgdmFsYXJtOiBpY2FsU2V0LFxuICAgICAgdnRpbWV6b25lOiBpY2FsU2V0LFxuICAgICAgZGF5bGlnaHQ6IGljYWxTZXQsXG4gICAgICBzdGFuZGFyZDogaWNhbFNldFxuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIFRoZSBkZXNpZ24gc2V0IGZvciBpQ2FsZW5kYXIgKHJmYzU1NDUvcmZjNzI2NSkgY29tcG9uZW50cy5cbiAgICAgKiBAdHlwZSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fVxuICAgICAqL1xuICAgIGljYWxlbmRhcjogaWNhbFNldCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZXNpZ24gc2V0IGZvciB2Q2FyZCAocmZjNjM1MC9yZmM3MDk1KSBjb21wb25lbnRzLlxuICAgICAqIEB0eXBlIHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9XG4gICAgICovXG4gICAgdmNhcmQ6IHZjYXJkU2V0LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGRlc2lnbiBzZXQgZm9yIHZDYXJkIChyZmMyNDI1L3JmYzI0MjYvcmZjNzA5NSkgY29tcG9uZW50cy5cbiAgICAgKiBAdHlwZSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fVxuICAgICAqL1xuICAgIHZjYXJkMzogdmNhcmQzU2V0LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGVzaWduIHNldCBmb3IgdGhlIGdpdmVuIGNvbXBvbmVudCBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbXBvbmVudE5hbWUgICAgICAgIFRoZSBuYW1lIG9mIHRoZSBjb21wb25lbnRcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9ICAgICAgVGhlIGRlc2lnbiBzZXQgZm9yIHRoZSBjb21wb25lbnRcbiAgICAgKi9cbiAgICBnZXREZXNpZ25TZXQ6IGZ1bmN0aW9uKGNvbXBvbmVudE5hbWUpIHtcbiAgICAgIHZhciBpc0luRGVzaWduID0gY29tcG9uZW50TmFtZSAmJiBjb21wb25lbnROYW1lIGluIGRlc2lnbi5jb21wb25lbnRzO1xuICAgICAgcmV0dXJuIGlzSW5EZXNpZ24gPyBkZXNpZ24uY29tcG9uZW50c1tjb21wb25lbnROYW1lXSA6IGRlc2lnbi5kZWZhdWx0U2V0O1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gZGVzaWduO1xufSgpKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAxMS0yMDE1ICovXG5cblxuLyoqXG4gKiBDb250YWlucyB2YXJpb3VzIGZ1bmN0aW9ucyB0byBjb252ZXJ0IGpDYWwgYW5kIGpDYXJkIGRhdGEgYmFjayBpbnRvXG4gKiBpQ2FsZW5kYXIgYW5kIHZDYXJkLlxuICogQG5hbWVzcGFjZVxuICovXG5JQ0FMLnN0cmluZ2lmeSA9IChmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBMSU5FX0VORElORyA9ICdcXHJcXG4nO1xuICB2YXIgREVGQVVMVF9WQUxVRV9UWVBFID0gJ3Vua25vd24nO1xuXG4gIHZhciBkZXNpZ24gPSBJQ0FMLmRlc2lnbjtcbiAgdmFyIGhlbHBlcnMgPSBJQ0FMLmhlbHBlcnM7XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBmdWxsIGpDYWwvakNhcmQgYXJyYXkgaW50byBhIGlDYWxlbmRhci92Q2FyZCBzdHJpbmcuXG4gICAqXG4gICAqIEBmdW5jdGlvbiBJQ0FMLnN0cmluZ2lmeVxuICAgKiBAdmFyaWF0aW9uIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7QXJyYXl9IGpDYWwgICAgVGhlIGpDYWwvakNhcmQgZG9jdW1lbnRcbiAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICBUaGUgc3RyaW5naWZpZWQgaUNhbGVuZGFyL3ZDYXJkIGRvY3VtZW50XG4gICAqL1xuICBmdW5jdGlvbiBzdHJpbmdpZnkoakNhbCkge1xuICAgIGlmICh0eXBlb2YgakNhbFswXSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgc2luZ2xlIGNvbXBvbmVudFxuICAgICAgakNhbCA9IFtqQ2FsXTtcbiAgICB9XG5cbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IGpDYWwubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcblxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHJlc3VsdCArPSBzdHJpbmdpZnkuY29tcG9uZW50KGpDYWxbaV0pICsgTElORV9FTkRJTkc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhbiBqQ2FsIGNvbXBvbmVudCBhcnJheSBpbnRvIGEgSUNBTCBzdHJpbmcuXG4gICAqIFJlY3Vyc2l2ZSB3aWxsIHJlc29sdmUgc3ViLWNvbXBvbmVudHMuXG4gICAqXG4gICAqIEV4YWN0IGNvbXBvbmVudC9wcm9wZXJ0eSBvcmRlciBpcyBub3Qgc2F2ZWQgYWxsXG4gICAqIHByb3BlcnRpZXMgd2lsbCBjb21lIGJlZm9yZSBzdWJjb21wb25lbnRzLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gSUNBTC5zdHJpbmdpZnkuY29tcG9uZW50XG4gICAqIEBwYXJhbSB7QXJyYXl9IGNvbXBvbmVudFxuICAgKiAgICAgICAgakNhbC9qQ2FyZCBmcmFnbWVudCBvZiBhIGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge0lDQUwuZGVzaWduLmRlc2lnblNldH0gZGVzaWduU2V0XG4gICAqICAgICAgICBUaGUgZGVzaWduIGRhdGEgdG8gdXNlIGZvciB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgIFRoZSBpQ2FsZW5kYXIvdkNhcmQgc3RyaW5nXG4gICAqL1xuICBzdHJpbmdpZnkuY29tcG9uZW50ID0gZnVuY3Rpb24oY29tcG9uZW50LCBkZXNpZ25TZXQpIHtcbiAgICB2YXIgbmFtZSA9IGNvbXBvbmVudFswXS50b1VwcGVyQ2FzZSgpO1xuICAgIHZhciByZXN1bHQgPSAnQkVHSU46JyArIG5hbWUgKyBMSU5FX0VORElORztcblxuICAgIHZhciBwcm9wcyA9IGNvbXBvbmVudFsxXTtcbiAgICB2YXIgcHJvcElkeCA9IDA7XG4gICAgdmFyIHByb3BMZW4gPSBwcm9wcy5sZW5ndGg7XG5cbiAgICB2YXIgZGVzaWduU2V0TmFtZSA9IGNvbXBvbmVudFswXTtcbiAgICAvLyByZmM2MzUwIHJlcXVpcmVzIHRoYXQgaW4gdkNhcmQgNC4wIHRoZSBmaXJzdCBjb21wb25lbnQgaXMgdGhlIFZFUlNJT05cbiAgICAvLyBjb21wb25lbnQgd2l0aCBhcyB2YWx1ZSA0LjAsIG5vdGUgdGhhdCAzLjAgZG9lcyBub3QgaGF2ZSB0aGlzIHJlcXVpcmVtZW50LlxuICAgIGlmIChkZXNpZ25TZXROYW1lID09PSAndmNhcmQnICYmIGNvbXBvbmVudFsxXS5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAhKGNvbXBvbmVudFsxXVswXVswXSA9PT0gXCJ2ZXJzaW9uXCIgJiYgY29tcG9uZW50WzFdWzBdWzNdID09PSBcIjQuMFwiKSkge1xuICAgICAgZGVzaWduU2V0TmFtZSA9IFwidmNhcmQzXCI7XG4gICAgfVxuICAgIGRlc2lnblNldCA9IGRlc2lnblNldCB8fCBkZXNpZ24uZ2V0RGVzaWduU2V0KGRlc2lnblNldE5hbWUpO1xuXG4gICAgZm9yICg7IHByb3BJZHggPCBwcm9wTGVuOyBwcm9wSWR4KyspIHtcbiAgICAgIHJlc3VsdCArPSBzdHJpbmdpZnkucHJvcGVydHkocHJvcHNbcHJvcElkeF0sIGRlc2lnblNldCkgKyBMSU5FX0VORElORztcbiAgICB9XG5cbiAgICAvLyBJZ25vcmUgc3ViY29tcG9uZW50cyBpZiBub25lIGV4aXN0LCBlLmcuIGluIHZDYXJkLlxuICAgIHZhciBjb21wcyA9IGNvbXBvbmVudFsyXSB8fCBbXTtcbiAgICB2YXIgY29tcElkeCA9IDA7XG4gICAgdmFyIGNvbXBMZW4gPSBjb21wcy5sZW5ndGg7XG5cbiAgICBmb3IgKDsgY29tcElkeCA8IGNvbXBMZW47IGNvbXBJZHgrKykge1xuICAgICAgcmVzdWx0ICs9IHN0cmluZ2lmeS5jb21wb25lbnQoY29tcHNbY29tcElkeF0sIGRlc2lnblNldCkgKyBMSU5FX0VORElORztcbiAgICB9XG5cbiAgICByZXN1bHQgKz0gJ0VORDonICsgbmFtZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIHNpbmdsZSBqQ2FsL2pDYXJkIHByb3BlcnR5IHRvIGEgaUNhbGVuZGFyL3ZDYXJkIHN0cmluZy5cbiAgICpcbiAgICogQGZ1bmN0aW9uIElDQUwuc3RyaW5naWZ5LnByb3BlcnR5XG4gICAqIEBwYXJhbSB7QXJyYXl9IHByb3BlcnR5XG4gICAqICAgICAgICBqQ2FsL2pDYXJkIHByb3BlcnR5IGFycmF5XG4gICAqIEBwYXJhbSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fSBkZXNpZ25TZXRcbiAgICogICAgICAgIFRoZSBkZXNpZ24gZGF0YSB0byB1c2UgZm9yIHRoaXMgcHJvcGVydHlcbiAgICogQHBhcmFtIHtCb29sZWFufSBub0ZvbGRcbiAgICogICAgICAgIElmIHRydWUsIHRoZSBsaW5lIGlzIG5vdCBmb2xkZWRcbiAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICBUaGUgaUNhbGVuZGFyL3ZDYXJkIHN0cmluZ1xuICAgKi9cbiAgc3RyaW5naWZ5LnByb3BlcnR5ID0gZnVuY3Rpb24ocHJvcGVydHksIGRlc2lnblNldCwgbm9Gb2xkKSB7XG4gICAgdmFyIG5hbWUgPSBwcm9wZXJ0eVswXS50b1VwcGVyQ2FzZSgpO1xuICAgIHZhciBqc05hbWUgPSBwcm9wZXJ0eVswXTtcbiAgICB2YXIgcGFyYW1zID0gcHJvcGVydHlbMV07XG5cbiAgICB2YXIgbGluZSA9IG5hbWU7XG5cbiAgICB2YXIgcGFyYW1OYW1lO1xuICAgIGZvciAocGFyYW1OYW1lIGluIHBhcmFtcykge1xuICAgICAgdmFyIHZhbHVlID0gcGFyYW1zW3BhcmFtTmFtZV07XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocGFyYW1zLmhhc093blByb3BlcnR5KHBhcmFtTmFtZSkpIHtcbiAgICAgICAgdmFyIG11bHRpVmFsdWUgPSAocGFyYW1OYW1lIGluIGRlc2lnblNldC5wYXJhbSkgJiYgZGVzaWduU2V0LnBhcmFtW3BhcmFtTmFtZV0ubXVsdGlWYWx1ZTtcbiAgICAgICAgaWYgKG11bHRpVmFsdWUgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBpZiAoZGVzaWduU2V0LnBhcmFtW3BhcmFtTmFtZV0ubXVsdGlWYWx1ZVNlcGFyYXRlRFF1b3RlKSB7XG4gICAgICAgICAgICBtdWx0aVZhbHVlID0gJ1wiJyArIG11bHRpVmFsdWUgKyAnXCInO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLm1hcChzdHJpbmdpZnkuX3JmYzY4NjhVbmVzY2FwZSk7XG4gICAgICAgICAgdmFsdWUgPSBzdHJpbmdpZnkubXVsdGlWYWx1ZSh2YWx1ZSwgbXVsdGlWYWx1ZSwgXCJ1bmtub3duXCIsIG51bGwsIGRlc2lnblNldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBzdHJpbmdpZnkuX3JmYzY4NjhVbmVzY2FwZSh2YWx1ZSk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGxpbmUgKz0gJzsnICsgcGFyYW1OYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGxpbmUgKz0gJz0nICsgc3RyaW5naWZ5LnByb3BlcnR5VmFsdWUodmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcm9wZXJ0eS5sZW5ndGggPT09IDMpIHtcbiAgICAgIC8vIElmIHRoZXJlIGFyZSBubyB2YWx1ZXMsIHdlIG11c3QgYXNzdW1lIGEgYmxhbmsgdmFsdWVcbiAgICAgIHJldHVybiBsaW5lICsgJzonO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZVR5cGUgPSBwcm9wZXJ0eVsyXTtcblxuICAgIGlmICghZGVzaWduU2V0KSB7XG4gICAgICBkZXNpZ25TZXQgPSBkZXNpZ24uZGVmYXVsdFNldDtcbiAgICB9XG5cbiAgICB2YXIgcHJvcERldGFpbHM7XG4gICAgdmFyIG11bHRpVmFsdWUgPSBmYWxzZTtcbiAgICB2YXIgc3RydWN0dXJlZFZhbHVlID0gZmFsc2U7XG4gICAgdmFyIGlzRGVmYXVsdCA9IGZhbHNlO1xuXG4gICAgaWYgKGpzTmFtZSBpbiBkZXNpZ25TZXQucHJvcGVydHkpIHtcbiAgICAgIHByb3BEZXRhaWxzID0gZGVzaWduU2V0LnByb3BlcnR5W2pzTmFtZV07XG5cbiAgICAgIGlmICgnbXVsdGlWYWx1ZScgaW4gcHJvcERldGFpbHMpIHtcbiAgICAgICAgbXVsdGlWYWx1ZSA9IHByb3BEZXRhaWxzLm11bHRpVmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmICgoJ3N0cnVjdHVyZWRWYWx1ZScgaW4gcHJvcERldGFpbHMpICYmIEFycmF5LmlzQXJyYXkocHJvcGVydHlbM10pKSB7XG4gICAgICAgIHN0cnVjdHVyZWRWYWx1ZSA9IHByb3BEZXRhaWxzLnN0cnVjdHVyZWRWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCdkZWZhdWx0VHlwZScgaW4gcHJvcERldGFpbHMpIHtcbiAgICAgICAgaWYgKHZhbHVlVHlwZSA9PT0gcHJvcERldGFpbHMuZGVmYXVsdFR5cGUpIHtcbiAgICAgICAgICBpc0RlZmF1bHQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodmFsdWVUeXBlID09PSBERUZBVUxUX1ZBTFVFX1RZUEUpIHtcbiAgICAgICAgICBpc0RlZmF1bHQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh2YWx1ZVR5cGUgPT09IERFRkFVTFRfVkFMVUVfVFlQRSkge1xuICAgICAgICBpc0RlZmF1bHQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHB1c2ggdGhlIFZBTFVFIHByb3BlcnR5IGlmIHR5cGUgaXMgbm90IHRoZSBkZWZhdWx0XG4gICAgLy8gZm9yIHRoZSBjdXJyZW50IHByb3BlcnR5LlxuICAgIGlmICghaXNEZWZhdWx0KSB7XG4gICAgICAvLyB2YWx1ZSB3aWxsIG5ldmVyIGNvbnRhaW4gOy86Lywgc28gd2UgZG9uJ3QgZXNjYXBlIGl0IGhlcmUuXG4gICAgICBsaW5lICs9ICc7VkFMVUU9JyArIHZhbHVlVHlwZS50b1VwcGVyQ2FzZSgpO1xuICAgIH1cblxuICAgIGxpbmUgKz0gJzonO1xuXG4gICAgaWYgKG11bHRpVmFsdWUgJiYgc3RydWN0dXJlZFZhbHVlKSB7XG4gICAgICBsaW5lICs9IHN0cmluZ2lmeS5tdWx0aVZhbHVlKFxuICAgICAgICBwcm9wZXJ0eVszXSwgc3RydWN0dXJlZFZhbHVlLCB2YWx1ZVR5cGUsIG11bHRpVmFsdWUsIGRlc2lnblNldCwgc3RydWN0dXJlZFZhbHVlXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAobXVsdGlWYWx1ZSkge1xuICAgICAgbGluZSArPSBzdHJpbmdpZnkubXVsdGlWYWx1ZShcbiAgICAgICAgcHJvcGVydHkuc2xpY2UoMyksIG11bHRpVmFsdWUsIHZhbHVlVHlwZSwgbnVsbCwgZGVzaWduU2V0LCBmYWxzZVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHN0cnVjdHVyZWRWYWx1ZSkge1xuICAgICAgbGluZSArPSBzdHJpbmdpZnkubXVsdGlWYWx1ZShcbiAgICAgICAgcHJvcGVydHlbM10sIHN0cnVjdHVyZWRWYWx1ZSwgdmFsdWVUeXBlLCBudWxsLCBkZXNpZ25TZXQsIHN0cnVjdHVyZWRWYWx1ZVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZSArPSBzdHJpbmdpZnkudmFsdWUocHJvcGVydHlbM10sIHZhbHVlVHlwZSwgZGVzaWduU2V0LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vRm9sZCA/IGxpbmUgOiBJQ0FMLmhlbHBlcnMuZm9sZGxpbmUobGluZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgZXNjYXBpbmcgb2YgcHJvcGVydHkgdmFsdWVzIHRoYXQgbWF5IGNvbnRhaW46XG4gICAqXG4gICAqICAgIENPTE9OICg6KSwgU0VNSUNPTE9OICg7KSwgb3IgQ09NTUEgKCwpXG4gICAqXG4gICAqIElmIGFueSBvZiB0aGUgYWJvdmUgYXJlIHByZXNlbnQgdGhlIHJlc3VsdCBpcyB3cmFwcGVkXG4gICAqIGluIGRvdWJsZSBxdW90ZXMuXG4gICAqXG4gICAqIEBmdW5jdGlvbiBJQ0FMLnN0cmluZ2lmeS5wcm9wZXJ0eVZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSAgICAgIFJhdyBwcm9wZXJ0eSB2YWx1ZVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICBHaXZlbiBvciBlc2NhcGVkIHZhbHVlIHdoZW4gbmVlZGVkXG4gICAqL1xuICBzdHJpbmdpZnkucHJvcGVydHlWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cbiAgICBpZiAoKGhlbHBlcnMudW5lc2NhcGVkSW5kZXhPZih2YWx1ZSwgJywnKSA9PT0gLTEpICYmXG4gICAgICAgIChoZWxwZXJzLnVuZXNjYXBlZEluZGV4T2YodmFsdWUsICc6JykgPT09IC0xKSAmJlxuICAgICAgICAoaGVscGVycy51bmVzY2FwZWRJbmRleE9mKHZhbHVlLCAnOycpID09PSAtMSkpIHtcblxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiAnXCInICsgdmFsdWUgKyAnXCInO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhbiBhcnJheSBvZiBpY2FsIHZhbHVlcyBpbnRvIGEgc2luZ2xlXG4gICAqIHN0cmluZyBiYXNlZCBvbiBhIHR5cGUgYW5kIGEgZGVsaW1pdGVyIHZhbHVlIChsaWtlIFwiLFwiKS5cbiAgICpcbiAgICogQGZ1bmN0aW9uIElDQUwuc3RyaW5naWZ5Lm11bHRpVmFsdWVcbiAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzICAgICAgTGlzdCBvZiB2YWx1ZXMgdG8gY29udmVydFxuICAgKiBAcGFyYW0ge1N0cmluZ30gZGVsaW0gICAgICBVc2VkIHRvIGpvaW4gdGhlIHZhbHVlcyAoXCIsXCIsIFwiO1wiLCBcIjpcIilcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgICAgICAgTG93ZWNhc2UgaWNhbCB2YWx1ZSB0eXBlXG4gICAqICAgICAgICAobGlrZSBib29sZWFuLCBkYXRlLXRpbWUsIGV0Yy4uKVxuICAgKiBAcGFyYW0gez9TdHJpbmd9IGlubmVyTXVsdGkgSWYgc2V0LCBlYWNoIHZhbHVlIHdpbGwgYWdhaW4gYmUgcHJvY2Vzc2VkXG4gICAqICAgICAgICBVc2VkIGZvciBzdHJ1Y3R1cmVkIHZhbHVlc1xuICAgKiBAcGFyYW0ge0lDQUwuZGVzaWduLmRlc2lnblNldH0gZGVzaWduU2V0XG4gICAqICAgICAgICBUaGUgZGVzaWduIGRhdGEgdG8gdXNlIGZvciB0aGlzIHByb3BlcnR5XG4gICAqXG4gICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgIGlDYWxlbmRhci92Q2FyZCBzdHJpbmcgZm9yIHZhbHVlXG4gICAqL1xuICBzdHJpbmdpZnkubXVsdGlWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlcywgZGVsaW0sIHR5cGUsIGlubmVyTXVsdGksIGRlc2lnblNldCwgc3RydWN0dXJlZFZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBsZW4gPSB2YWx1ZXMubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcblxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChpbm5lck11bHRpICYmIEFycmF5LmlzQXJyYXkodmFsdWVzW2ldKSkge1xuICAgICAgICByZXN1bHQgKz0gc3RyaW5naWZ5Lm11bHRpVmFsdWUodmFsdWVzW2ldLCBpbm5lck11bHRpLCB0eXBlLCBudWxsLCBkZXNpZ25TZXQsIHN0cnVjdHVyZWRWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgKz0gc3RyaW5naWZ5LnZhbHVlKHZhbHVlc1tpXSwgdHlwZSwgZGVzaWduU2V0LCBzdHJ1Y3R1cmVkVmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaSAhPT0gKGxlbiAtIDEpKSB7XG4gICAgICAgIHJlc3VsdCArPSBkZWxpbTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcm9jZXNzZXMgYSBzaW5nbGUgaWNhbCB2YWx1ZSBydW5zIHRoZSBhc3NvY2lhdGVkIFwidG9JQ0FMXCIgbWV0aG9kIGZyb20gdGhlXG4gICAqIGRlc2lnbiB2YWx1ZSB0eXBlIGlmIGF2YWlsYWJsZSB0byBjb252ZXJ0IHRoZSB2YWx1ZS5cbiAgICpcbiAgICogQGZ1bmN0aW9uIElDQUwuc3RyaW5naWZ5LnZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsdWUgICAgICAgQSBmb3JtYXR0ZWQgdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgICAgICAgICAgICAgICBMb3dlcmNhc2UgaUNhbGVuZGFyL3ZDYXJkIHZhbHVlIHR5cGVcbiAgICogIChsaWtlIGJvb2xlYW4sIGRhdGUtdGltZSwgZXRjLi4pXG4gICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgICAgICAgICAgaUNhbGVuZGFyL3ZDYXJkIHZhbHVlIGZvciBzaW5nbGUgdmFsdWVcbiAgICovXG4gIHN0cmluZ2lmeS52YWx1ZSA9IGZ1bmN0aW9uKHZhbHVlLCB0eXBlLCBkZXNpZ25TZXQsIHN0cnVjdHVyZWRWYWx1ZSkge1xuICAgIGlmICh0eXBlIGluIGRlc2lnblNldC52YWx1ZSAmJiAndG9JQ0FMJyBpbiBkZXNpZ25TZXQudmFsdWVbdHlwZV0pIHtcbiAgICAgIHJldHVybiBkZXNpZ25TZXQudmFsdWVbdHlwZV0udG9JQ0FMKHZhbHVlLCBzdHJ1Y3R1cmVkVmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEludGVybmFsIGhlbHBlciBmb3IgcmZjNjg2OC4gRXhwb3NpbmcgdGhpcyBvbiBJQ0FMLnN0cmluZ2lmeSBzbyB0aGF0XG4gICAqIGhhY2tlcnMgY2FuIGRpc2FibGUgdGhlIHJmYzY4NjggcGFyc2luZyBpZiB0aGUgcmVhbGx5IG5lZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWwgICAgICAgIFRoZSB2YWx1ZSB0byB1bmVzY2FwZVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICBUaGUgZXNjYXBlZCB2YWx1ZVxuICAgKi9cbiAgc3RyaW5naWZ5Ll9yZmM2ODY4VW5lc2NhcGUgPSBmdW5jdGlvbih2YWwpIHtcbiAgICByZXR1cm4gdmFsLnJlcGxhY2UoL1tcXG5eXCJdL2csIGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBSRkM2ODY4X1JFUExBQ0VfTUFQW3hdO1xuICAgIH0pO1xuICB9O1xuICB2YXIgUkZDNjg2OF9SRVBMQUNFX01BUCA9IHsgJ1wiJzogXCJeJ1wiLCBcIlxcblwiOiBcIl5uXCIsIFwiXlwiOiBcIl5eXCIgfTtcblxuICByZXR1cm4gc3RyaW5naWZ5O1xufSgpKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAxMS0yMDE1ICovXG5cblxuLyoqXG4gKiBDb250YWlucyB2YXJpb3VzIGZ1bmN0aW9ucyB0byBwYXJzZSBpQ2FsZW5kYXIgYW5kIHZDYXJkIGRhdGEuXG4gKiBAbmFtZXNwYWNlXG4gKi9cbklDQUwucGFyc2UgPSAoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgQ0hBUiA9IC9bXiBcXHRdLztcbiAgdmFyIE1VTFRJVkFMVUVfREVMSU1JVEVSID0gJywnO1xuICB2YXIgVkFMVUVfREVMSU1JVEVSID0gJzonO1xuICB2YXIgUEFSQU1fREVMSU1JVEVSID0gJzsnO1xuICB2YXIgUEFSQU1fTkFNRV9ERUxJTUlURVIgPSAnPSc7XG4gIHZhciBERUZBVUxUX1ZBTFVFX1RZUEUgPSAndW5rbm93bic7XG4gIHZhciBERUZBVUxUX1BBUkFNX1RZUEUgPSAndGV4dCc7XG5cbiAgdmFyIGRlc2lnbiA9IElDQUwuZGVzaWduO1xuICB2YXIgaGVscGVycyA9IElDQUwuaGVscGVycztcblxuICAvKipcbiAgICogQW4gZXJyb3IgdGhhdCBvY2N1cnJlZCBkdXJpbmcgcGFyc2luZy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgICAgICAgIFRoZSBlcnJvciBtZXNzYWdlXG4gICAqIEBtZW1iZXJvZiBJQ0FMLnBhcnNlXG4gICAqIEBleHRlbmRzIHtFcnJvcn1cbiAgICogQGNsYXNzXG4gICAqL1xuICBmdW5jdGlvbiBQYXJzZXJFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLm5hbWUgPSAnUGFyc2VyRXJyb3InO1xuXG4gICAgdHJ5IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLnN0YWNrKSB7XG4gICAgICAgIHZhciBzcGxpdCA9IGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgICBzcGxpdC5zaGlmdCgpO1xuICAgICAgICB0aGlzLnN0YWNrID0gc3BsaXQuam9pbignXFxuJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgUGFyc2VyRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiBQYXJzZXMgaUNhbGVuZGFyIG9yIHZDYXJkIGRhdGEgaW50byBhIHJhdyBqQ2FsIG9iamVjdC4gQ29uc3VsdFxuICAgKiBkb2N1bWVudGF0aW9uIG9uIHRoZSB7QHR1dG9yaWFsIGxheWVyc3xsYXllcnMgb2YgcGFyc2luZ30gZm9yIG1vcmVcbiAgICogZGV0YWlscy5cbiAgICpcbiAgICogQGZ1bmN0aW9uIElDQUwucGFyc2VcbiAgICogQHZhcmlhdGlvbiBmdW5jdGlvblxuICAgKiBAdG9kbyBGaXggdGhlIEFQSSB0byBiZSBtb3JlIGNsZWFyIG9uIHRoZSByZXR1cm4gdHlwZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgICAgICBUaGUgc3RyaW5nIGRhdGEgdG8gcGFyc2VcbiAgICogQHJldHVybiB7T2JqZWN0fE9iamVjdFtdfSAgQSBzaW5nbGUgakNhbCBvYmplY3QsIG9yIGFuIGFycmF5IHRoZXJlb2ZcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlcihpbnB1dCkge1xuICAgIHZhciBzdGF0ZSA9IHt9O1xuICAgIHZhciByb290ID0gc3RhdGUuY29tcG9uZW50ID0gW107XG5cbiAgICBzdGF0ZS5zdGFjayA9IFtyb290XTtcblxuICAgIHBhcnNlci5fZWFjaExpbmUoaW5wdXQsIGZ1bmN0aW9uKGVyciwgbGluZSkge1xuICAgICAgcGFyc2VyLl9oYW5kbGVDb250ZW50TGluZShsaW5lLCBzdGF0ZSk7XG4gICAgfSk7XG5cblxuICAgIC8vIHdoZW4gdGhlcmUgYXJlIHN0aWxsIGl0ZW1zIG9uIHRoZSBzdGFja1xuICAgIC8vIHRocm93IGEgZmF0YWwgZXJyb3IsIGEgY29tcG9uZW50IHdhcyBub3QgY2xvc2VkXG4gICAgLy8gY29ycmVjdGx5IGluIHRoYXQgY2FzZS5cbiAgICBpZiAoc3RhdGUuc3RhY2subGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlckVycm9yKFxuICAgICAgICAnaW52YWxpZCBpY2FsIGJvZHkuIGNvbXBvbmVudCBiZWdhbiBidXQgZGlkIG5vdCBlbmQnXG4gICAgICApO1xuICAgIH1cblxuICAgIHN0YXRlID0gbnVsbDtcblxuICAgIHJldHVybiAocm9vdC5sZW5ndGggPT0gMSA/IHJvb3RbMF0gOiByb290KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBhbiBpQ2FsZW5kYXIgcHJvcGVydHkgdmFsdWUgaW50byB0aGUgakNhbCBmb3IgYSBzaW5nbGUgcHJvcGVydHlcbiAgICpcbiAgICogQGZ1bmN0aW9uIElDQUwucGFyc2UucHJvcGVydHlcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICAgKiAgIFRoZSBpQ2FsZW5kYXIgcHJvcGVydHkgc3RyaW5nIHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0PX0gZGVzaWduU2V0XG4gICAqICAgVGhlIGRlc2lnbiBkYXRhIHRvIHVzZSBmb3IgdGhpcyBwcm9wZXJ0eVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqICAgVGhlIGpDYWwgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIHByb3BlcnR5XG4gICAqL1xuICBwYXJzZXIucHJvcGVydHkgPSBmdW5jdGlvbihzdHIsIGRlc2lnblNldCkge1xuICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgIGNvbXBvbmVudDogW1tdLCBbXV0sXG4gICAgICBkZXNpZ25TZXQ6IGRlc2lnblNldCB8fCBkZXNpZ24uZGVmYXVsdFNldFxuICAgIH07XG4gICAgcGFyc2VyLl9oYW5kbGVDb250ZW50TGluZShzdHIsIHN0YXRlKTtcbiAgICByZXR1cm4gc3RhdGUuY29tcG9uZW50WzFdWzBdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gcGFyc2UgYSBjb21wb25lbnQuIFlvdSBjYW4gdXNlIElDQUwucGFyc2UoKSBkaXJlY3RseVxuICAgKiBpbnN0ZWFkLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gSUNBTC5wYXJzZS5jb21wb25lbnRcbiAgICogQHNlZSBJQ0FMLnBhcnNlKGZ1bmN0aW9uKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyICAgIFRoZSBpQ2FsZW5kYXIgY29tcG9uZW50IHN0cmluZyB0byBwYXJzZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgIFRoZSBqQ2FsIE9iamVjdCBjb250YWluaW5nIHRoZSBjb21wb25lbnRcbiAgICovXG4gIHBhcnNlci5jb21wb25lbnQgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gcGFyc2VyKHN0cik7XG4gIH07XG5cbiAgLy8gY2xhc3NlcyAmIGNvbnN0YW50c1xuICBwYXJzZXIuUGFyc2VyRXJyb3IgPSBQYXJzZXJFcnJvcjtcblxuICAvKipcbiAgICogVGhlIHN0YXRlIGZvciBwYXJzaW5nIGNvbnRlbnQgbGluZXMgZnJvbSBhbiBpQ2FsZW5kYXIvdkNhcmQgc3RyaW5nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWVtYmVyb2YgSUNBTC5wYXJzZVxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBwYXJzZXJTdGF0ZVxuICAgKiBAcHJvcGVydHkge0lDQUwuZGVzaWduLmRlc2lnblNldH0gZGVzaWduU2V0ICAgIFRoZSBkZXNpZ24gc2V0IHRvIHVzZSBmb3IgcGFyc2luZ1xuICAgKiBAcHJvcGVydHkge0lDQUwuQ29tcG9uZW50W119IHN0YWNrICAgICAgICAgICAgIFRoZSBzdGFjayBvZiBjb21wb25lbnRzIGJlaW5nIHByb2Nlc3NlZFxuICAgKiBAcHJvcGVydHkge0lDQUwuQ29tcG9uZW50fSBjb21wb25lbnQgICAgICAgICAgIFRoZSBjdXJyZW50bHkgYWN0aXZlIGNvbXBvbmVudFxuICAgKi9cblxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGEgc2luZ2xlIGxpbmUgb2YgaUNhbGVuZGFyL3ZDYXJkLCB1cGRhdGluZyB0aGUgc3RhdGUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBmdW5jdGlvbiBJQ0FMLnBhcnNlLl9oYW5kbGVDb250ZW50TGluZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbGluZSAgICAgICAgICAgICAgIFRoZSBjb250ZW50IGxpbmUgdG8gcHJvY2Vzc1xuICAgKiBAcGFyYW0ge0lDQUwucGFyc2UucGFyc2VyU3RhdGV9ICAgIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBsaW5lIHBhcnNpbmdcbiAgICovXG4gIHBhcnNlci5faGFuZGxlQ29udGVudExpbmUgPSBmdW5jdGlvbihsaW5lLCBzdGF0ZSkge1xuICAgIC8vIGJyZWFrIHVwIHRoZSBwYXJ0cyBvZiB0aGUgbGluZVxuICAgIHZhciB2YWx1ZVBvcyA9IGxpbmUuaW5kZXhPZihWQUxVRV9ERUxJTUlURVIpO1xuICAgIHZhciBwYXJhbVBvcyA9IGxpbmUuaW5kZXhPZihQQVJBTV9ERUxJTUlURVIpO1xuXG4gICAgdmFyIGxhc3RQYXJhbUluZGV4O1xuICAgIHZhciBsYXN0VmFsdWVQb3M7XG5cbiAgICAvLyBuYW1lIG9mIHByb3BlcnR5IG9yIGJlZ2luL2VuZFxuICAgIHZhciBuYW1lO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBwYXJhbXMgaXMgb25seSBvdmVycmlkZGVuIGlmIHBhcmFtUG9zICE9PSAtMS5cbiAgICAvLyB3ZSBjYW4ndCBkbyBwYXJhbXMgPSBwYXJhbXMgfHwge30gbGF0ZXIgb25cbiAgICAvLyBiZWNhdXNlIGl0IHNhY3JpZmljZXMgb3BzLlxuICAgIHZhciBwYXJhbXMgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIERpZmZlcmVudCBwcm9wZXJ0eSBjYXNlc1xuICAgICAqXG4gICAgICpcbiAgICAgKiAxLiBSUlVMRTpGUkVRPWZvb1xuICAgICAqICAgIC8vIEZSRVE9IGlzIG5vdCBhIHBhcmFtIGJ1dCB0aGUgdmFsdWVcbiAgICAgKlxuICAgICAqIDIuIEFUVEVOREVFO1JPTEU9UkVRLVBBUlRJQ0lQQU5UO1xuICAgICAqICAgIC8vIFJPTEU9IGlzIGEgcGFyYW0gYmVjYXVzZSA6IGhhcyBub3QgaGFwcGVuZWQgeWV0XG4gICAgICovXG4gICAgICAvLyB3aGVuIHRoZSBwYXJhbWV0ZXIgZGVsaW1pdGVyIGlzIGFmdGVyIHRoZVxuICAgICAgLy8gdmFsdWUgZGVsaW1pdGVyIHRoZW4gaXQgaXMgbm90IGEgcGFyYW1ldGVyLlxuXG4gICAgaWYgKChwYXJhbVBvcyAhPT0gLTEgJiYgdmFsdWVQb3MgIT09IC0xKSkge1xuICAgICAgLy8gd2hlbiB0aGUgcGFyYW1ldGVyIGRlbGltaXRlciBpcyBhZnRlciB0aGVcbiAgICAgIC8vIHZhbHVlIGRlbGltaXRlciB0aGVuIGl0IGlzIG5vdCBhIHBhcmFtZXRlci5cbiAgICAgIGlmIChwYXJhbVBvcyA+IHZhbHVlUG9zKSB7XG4gICAgICAgIHBhcmFtUG9zID0gLTE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHBhcnNlZFBhcmFtcztcbiAgICBpZiAocGFyYW1Qb3MgIT09IC0xKSB7XG4gICAgICBuYW1lID0gbGluZS5zdWJzdHJpbmcoMCwgcGFyYW1Qb3MpLnRvTG93ZXJDYXNlKCk7XG4gICAgICBwYXJzZWRQYXJhbXMgPSBwYXJzZXIuX3BhcnNlUGFyYW1ldGVycyhsaW5lLnN1YnN0cmluZyhwYXJhbVBvcyksIDAsIHN0YXRlLmRlc2lnblNldCk7XG4gICAgICBpZiAocGFyc2VkUGFyYW1zWzJdID09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZXJFcnJvcihcIkludmFsaWQgcGFyYW1ldGVycyBpbiAnXCIgKyBsaW5lICsgXCInXCIpO1xuICAgICAgfVxuICAgICAgcGFyYW1zID0gcGFyc2VkUGFyYW1zWzBdO1xuICAgICAgbGFzdFBhcmFtSW5kZXggPSBwYXJzZWRQYXJhbXNbMV0ubGVuZ3RoICsgcGFyc2VkUGFyYW1zWzJdICsgcGFyYW1Qb3M7XG4gICAgICBpZiAoKGxhc3RWYWx1ZVBvcyA9XG4gICAgICAgIGxpbmUuc3Vic3RyaW5nKGxhc3RQYXJhbUluZGV4KS5pbmRleE9mKFZBTFVFX0RFTElNSVRFUikpICE9PSAtMSkge1xuICAgICAgICB2YWx1ZSA9IGxpbmUuc3Vic3RyaW5nKGxhc3RQYXJhbUluZGV4ICsgbGFzdFZhbHVlUG9zICsgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VyRXJyb3IoXCJNaXNzaW5nIHBhcmFtZXRlciB2YWx1ZSBpbiAnXCIgKyBsaW5lICsgXCInXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodmFsdWVQb3MgIT09IC0xKSB7XG4gICAgICAvLyB3aXRob3V0IHBhcm1ldGVycyAoQkVHSU46VkNBRU5EQVIsIENMQVNTOlBVQkxJQylcbiAgICAgIG5hbWUgPSBsaW5lLnN1YnN0cmluZygwLCB2YWx1ZVBvcykudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhbHVlID0gbGluZS5zdWJzdHJpbmcodmFsdWVQb3MgKyAxKTtcblxuICAgICAgaWYgKG5hbWUgPT09ICdiZWdpbicpIHtcbiAgICAgICAgdmFyIG5ld0NvbXBvbmVudCA9IFt2YWx1ZS50b0xvd2VyQ2FzZSgpLCBbXSwgW11dO1xuICAgICAgICBpZiAoc3RhdGUuc3RhY2subGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgc3RhdGUuY29tcG9uZW50LnB1c2gobmV3Q29tcG9uZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS5jb21wb25lbnRbMl0ucHVzaChuZXdDb21wb25lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnN0YWNrLnB1c2goc3RhdGUuY29tcG9uZW50KTtcbiAgICAgICAgc3RhdGUuY29tcG9uZW50ID0gbmV3Q29tcG9uZW50O1xuICAgICAgICBpZiAoIXN0YXRlLmRlc2lnblNldCkge1xuICAgICAgICAgIHN0YXRlLmRlc2lnblNldCA9IGRlc2lnbi5nZXREZXNpZ25TZXQoc3RhdGUuY29tcG9uZW50WzBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdlbmQnKSB7XG4gICAgICAgIHN0YXRlLmNvbXBvbmVudCA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBJZiBpdCBpcyBub3QgYmVnaW4vZW5kLCB0aGVuIHRoaXMgaXMgYSBwcm9wZXJ0eSB3aXRoIGFuIGVtcHR5IHZhbHVlLFxuICAgICAgLy8gd2hpY2ggc2hvdWxkIGJlIGNvbnNpZGVyZWQgdmFsaWQuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKlxuICAgICAgICogSW52YWxpZCBsaW5lLlxuICAgICAgICogVGhlIHJhdGlvbmFsIHRvIHRocm93IGFuIGVycm9yIGlzIHdlIHdpbGxcbiAgICAgICAqIG5ldmVyIGJlIGNlcnRhaW4gdGhhdCB0aGUgcmVzdCBvZiB0aGUgZmlsZVxuICAgICAgICogaXMgc2FuZSBhbmQgaXQgaXMgdW5saWtlbHkgdGhhdCB3ZSBjYW4gc2VyaWFsaXplXG4gICAgICAgKiB0aGUgcmVzdWx0IGNvcnJlY3RseSBlaXRoZXIuXG4gICAgICAgKi9cbiAgICAgIHRocm93IG5ldyBQYXJzZXJFcnJvcihcbiAgICAgICAgJ2ludmFsaWQgbGluZSAobm8gdG9rZW4gXCI7XCIgb3IgXCI6XCIpIFwiJyArIGxpbmUgKyAnXCInXG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZVR5cGU7XG4gICAgdmFyIG11bHRpVmFsdWUgPSBmYWxzZTtcbiAgICB2YXIgc3RydWN0dXJlZFZhbHVlID0gZmFsc2U7XG4gICAgdmFyIHByb3BlcnR5RGV0YWlscztcblxuICAgIGlmIChuYW1lIGluIHN0YXRlLmRlc2lnblNldC5wcm9wZXJ0eSkge1xuICAgICAgcHJvcGVydHlEZXRhaWxzID0gc3RhdGUuZGVzaWduU2V0LnByb3BlcnR5W25hbWVdO1xuXG4gICAgICBpZiAoJ211bHRpVmFsdWUnIGluIHByb3BlcnR5RGV0YWlscykge1xuICAgICAgICBtdWx0aVZhbHVlID0gcHJvcGVydHlEZXRhaWxzLm11bHRpVmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmICgnc3RydWN0dXJlZFZhbHVlJyBpbiBwcm9wZXJ0eURldGFpbHMpIHtcbiAgICAgICAgc3RydWN0dXJlZFZhbHVlID0gcHJvcGVydHlEZXRhaWxzLnN0cnVjdHVyZWRWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlICYmICdkZXRlY3RUeXBlJyBpbiBwcm9wZXJ0eURldGFpbHMpIHtcbiAgICAgICAgdmFsdWVUeXBlID0gcHJvcGVydHlEZXRhaWxzLmRldGVjdFR5cGUodmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGF0dGVtcHQgdG8gZGV0ZXJtaW5lIHZhbHVlXG4gICAgaWYgKCF2YWx1ZVR5cGUpIHtcbiAgICAgIGlmICghKCd2YWx1ZScgaW4gcGFyYW1zKSkge1xuICAgICAgICBpZiAocHJvcGVydHlEZXRhaWxzKSB7XG4gICAgICAgICAgdmFsdWVUeXBlID0gcHJvcGVydHlEZXRhaWxzLmRlZmF1bHRUeXBlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlVHlwZSA9IERFRkFVTFRfVkFMVUVfVFlQRTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcG9zc2libGUgdG8gYXZvaWQgdGhpcz9cbiAgICAgICAgdmFsdWVUeXBlID0gcGFyYW1zLnZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVsZXRlIHBhcmFtcy52YWx1ZTtcblxuICAgIC8qKlxuICAgICAqIE5vdGUgb24gYHZhciByZXN1bHRgIGp1Z2dsaW5nOlxuICAgICAqXG4gICAgICogSSBvYnNlcnZlZCB0aGF0IGJ1aWxkaW5nIHRoZSBhcnJheSBpbiBwaWVjZXMgaGFzIGFkdmVyc2VcbiAgICAgKiBlZmZlY3RzIG9uIHBlcmZvcm1hbmNlLCBzbyB3aGVyZSBwb3NzaWJsZSB3ZSBpbmxpbmUgdGhlIGNyZWF0aW9uLlxuICAgICAqIEl0IGlzIGEgbGl0dGxlIHVnbHkgYnV0IHJlc3VsdGVkIGluIH4yMDAwIGFkZGl0aW9uYWwgb3BzL3NlYy5cbiAgICAgKi9cblxuICAgIHZhciByZXN1bHQ7XG4gICAgaWYgKG11bHRpVmFsdWUgJiYgc3RydWN0dXJlZFZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IHBhcnNlci5fcGFyc2VNdWx0aVZhbHVlKHZhbHVlLCBzdHJ1Y3R1cmVkVmFsdWUsIHZhbHVlVHlwZSwgW10sIG11bHRpVmFsdWUsIHN0YXRlLmRlc2lnblNldCwgc3RydWN0dXJlZFZhbHVlKTtcbiAgICAgIHJlc3VsdCA9IFtuYW1lLCBwYXJhbXMsIHZhbHVlVHlwZSwgdmFsdWVdO1xuICAgIH0gZWxzZSBpZiAobXVsdGlWYWx1ZSkge1xuICAgICAgcmVzdWx0ID0gW25hbWUsIHBhcmFtcywgdmFsdWVUeXBlXTtcbiAgICAgIHBhcnNlci5fcGFyc2VNdWx0aVZhbHVlKHZhbHVlLCBtdWx0aVZhbHVlLCB2YWx1ZVR5cGUsIHJlc3VsdCwgbnVsbCwgc3RhdGUuZGVzaWduU2V0LCBmYWxzZSk7XG4gICAgfSBlbHNlIGlmIChzdHJ1Y3R1cmVkVmFsdWUpIHtcbiAgICAgIHZhbHVlID0gcGFyc2VyLl9wYXJzZU11bHRpVmFsdWUodmFsdWUsIHN0cnVjdHVyZWRWYWx1ZSwgdmFsdWVUeXBlLCBbXSwgbnVsbCwgc3RhdGUuZGVzaWduU2V0LCBzdHJ1Y3R1cmVkVmFsdWUpO1xuICAgICAgcmVzdWx0ID0gW25hbWUsIHBhcmFtcywgdmFsdWVUeXBlLCB2YWx1ZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gcGFyc2VyLl9wYXJzZVZhbHVlKHZhbHVlLCB2YWx1ZVR5cGUsIHN0YXRlLmRlc2lnblNldCwgZmFsc2UpO1xuICAgICAgcmVzdWx0ID0gW25hbWUsIHBhcmFtcywgdmFsdWVUeXBlLCB2YWx1ZV07XG4gICAgfVxuICAgIC8vIHJmYzYzNTAgcmVxdWlyZXMgdGhhdCBpbiB2Q2FyZCA0LjAgdGhlIGZpcnN0IGNvbXBvbmVudCBpcyB0aGUgVkVSU0lPTlxuICAgIC8vIGNvbXBvbmVudCB3aXRoIGFzIHZhbHVlIDQuMCwgbm90ZSB0aGF0IDMuMCBkb2VzIG5vdCBoYXZlIHRoaXMgcmVxdWlyZW1lbnQuXG4gICAgaWYgKHN0YXRlLmNvbXBvbmVudFswXSA9PT0gJ3ZjYXJkJyAmJiBzdGF0ZS5jb21wb25lbnRbMV0ubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICAhKG5hbWUgPT09ICd2ZXJzaW9uJyAmJiB2YWx1ZSA9PT0gJzQuMCcpKSB7XG4gICAgICBzdGF0ZS5kZXNpZ25TZXQgPSBkZXNpZ24uZ2V0RGVzaWduU2V0KFwidmNhcmQzXCIpO1xuICAgIH1cbiAgICBzdGF0ZS5jb21wb25lbnRbMV0ucHVzaChyZXN1bHQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQYXJzZSBhIHZhbHVlIGZyb20gdGhlIHJhdyB2YWx1ZSBpbnRvIHRoZSBqQ2FyZC9qQ2FsIHZhbHVlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAZnVuY3Rpb24gSUNBTC5wYXJzZS5fcGFyc2VWYWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgICAgICAgICAgT3JpZ2luYWwgdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgICAgICAgICAgIFR5cGUgb2YgdmFsdWVcbiAgICogQHBhcmFtIHtPYmplY3R9IGRlc2lnblNldCAgICAgIFRoZSBkZXNpZ24gZGF0YSB0byB1c2UgZm9yIHRoaXMgdmFsdWVcbiAgICogQHJldHVybiB7T2JqZWN0fSB2YXJpZXMgb24gdHlwZVxuICAgKi9cbiAgcGFyc2VyLl9wYXJzZVZhbHVlID0gZnVuY3Rpb24odmFsdWUsIHR5cGUsIGRlc2lnblNldCwgc3RydWN0dXJlZFZhbHVlKSB7XG4gICAgaWYgKHR5cGUgaW4gZGVzaWduU2V0LnZhbHVlICYmICdmcm9tSUNBTCcgaW4gZGVzaWduU2V0LnZhbHVlW3R5cGVdKSB7XG4gICAgICByZXR1cm4gZGVzaWduU2V0LnZhbHVlW3R5cGVdLmZyb21JQ0FMKHZhbHVlLCBzdHJ1Y3R1cmVkVmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhcnNlIHBhcmFtZXRlcnMgZnJvbSBhIHN0cmluZyB0byBvYmplY3QuXG4gICAqXG4gICAqIEBmdW5jdGlvbiBJQ0FMLnBhcnNlLl9wYXJzZVBhcmFtZXRlcnNcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGxpbmUgICAgICAgICAgIEEgc2luZ2xlIHVuZm9sZGVkIGxpbmVcbiAgICogQHBhcmFtIHtOdW1lcmljfSBzdGFydCAgICAgICAgIFBvc2l0aW9uIHRvIHN0YXJ0IGxvb2tpbmcgZm9yIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IGRlc2lnblNldCAgICAgIFRoZSBkZXNpZ24gZGF0YSB0byB1c2UgZm9yIHRoaXMgcHJvcGVydHlcbiAgICogQHJldHVybiB7T2JqZWN0fSBrZXkvdmFsdWUgcGFpcnNcbiAgICovXG4gIHBhcnNlci5fcGFyc2VQYXJhbWV0ZXJzID0gZnVuY3Rpb24obGluZSwgc3RhcnQsIGRlc2lnblNldCkge1xuICAgIHZhciBsYXN0UGFyYW0gPSBzdGFydDtcbiAgICB2YXIgcG9zID0gMDtcbiAgICB2YXIgZGVsaW0gPSBQQVJBTV9OQU1FX0RFTElNSVRFUjtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIG5hbWUsIGxjbmFtZTtcbiAgICB2YXIgdmFsdWUsIHZhbHVlUG9zID0gLTE7XG4gICAgdmFyIHR5cGUsIG11bHRpVmFsdWUsIG12ZGVsaW07XG5cbiAgICAvLyBmaW5kIHRoZSBuZXh0ICc9JyBzaWduXG4gICAgLy8gdXNlIGxhc3RQYXJhbSBhbmQgcG9zIHRvIGZpbmQgbmFtZVxuICAgIC8vIGNoZWNrIGlmIFwiIGlzIHVzZWQgaWYgc28gZ2V0IHZhbHVlIGZyb20gXCItPlwiXG4gICAgLy8gdGhlbiBpbmNyZW1lbnQgcG9zIHRvIGZpbmQgbmV4dCA7XG5cbiAgICB3aGlsZSAoKHBvcyAhPT0gZmFsc2UpICYmXG4gICAgICAgICAgIChwb3MgPSBoZWxwZXJzLnVuZXNjYXBlZEluZGV4T2YobGluZSwgZGVsaW0sIHBvcyArIDEpKSAhPT0gLTEpIHtcblxuICAgICAgbmFtZSA9IGxpbmUuc3Vic3RyKGxhc3RQYXJhbSArIDEsIHBvcyAtIGxhc3RQYXJhbSAtIDEpO1xuICAgICAgaWYgKG5hbWUubGVuZ3RoID09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlckVycm9yKFwiRW1wdHkgcGFyYW1ldGVyIG5hbWUgaW4gJ1wiICsgbGluZSArIFwiJ1wiKTtcbiAgICAgIH1cbiAgICAgIGxjbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIG12ZGVsaW0gPSBmYWxzZTtcbiAgICAgIG11bHRpVmFsdWUgPSBmYWxzZTtcblxuICAgICAgaWYgKGxjbmFtZSBpbiBkZXNpZ25TZXQucGFyYW0gJiYgZGVzaWduU2V0LnBhcmFtW2xjbmFtZV0udmFsdWVUeXBlKSB7XG4gICAgICAgIHR5cGUgPSBkZXNpZ25TZXQucGFyYW1bbGNuYW1lXS52YWx1ZVR5cGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlID0gREVGQVVMVF9QQVJBTV9UWVBFO1xuICAgICAgfVxuXG4gICAgICBpZiAobGNuYW1lIGluIGRlc2lnblNldC5wYXJhbSkge1xuICAgICAgICBtdWx0aVZhbHVlID0gZGVzaWduU2V0LnBhcmFtW2xjbmFtZV0ubXVsdGlWYWx1ZTtcbiAgICAgICAgaWYgKGRlc2lnblNldC5wYXJhbVtsY25hbWVdLm11bHRpVmFsdWVTZXBhcmF0ZURRdW90ZSkge1xuICAgICAgICAgIG12ZGVsaW0gPSBwYXJzZXIuX3JmYzY4NjhFc2NhcGUoJ1wiJyArIG11bHRpVmFsdWUgKyAnXCInKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbmV4dENoYXIgPSBsaW5lW3BvcyArIDFdO1xuICAgICAgaWYgKG5leHRDaGFyID09PSAnXCInKSB7XG4gICAgICAgIHZhbHVlUG9zID0gcG9zICsgMjtcbiAgICAgICAgcG9zID0gaGVscGVycy51bmVzY2FwZWRJbmRleE9mKGxpbmUsICdcIicsIHZhbHVlUG9zKTtcbiAgICAgICAgaWYgKG11bHRpVmFsdWUgJiYgcG9zICE9IC0xKSB7XG4gICAgICAgICAgICB2YXIgZXh0ZW5kZWRWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICB3aGlsZSAoZXh0ZW5kZWRWYWx1ZSkge1xuICAgICAgICAgICAgICBpZiAobGluZVtwb3MgKyAxXSA9PSBtdWx0aVZhbHVlICYmIGxpbmVbcG9zICsgMl0gPT0gJ1wiJykge1xuICAgICAgICAgICAgICAgIHBvcyA9IGhlbHBlcnMudW5lc2NhcGVkSW5kZXhPZihsaW5lLCAnXCInLCBwb3MgKyAzKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBleHRlbmRlZFZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlckVycm9yKFxuICAgICAgICAgICAgJ2ludmFsaWQgbGluZSAobm8gbWF0Y2hpbmcgZG91YmxlIHF1b3RlKSBcIicgKyBsaW5lICsgJ1wiJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSBsaW5lLnN1YnN0cih2YWx1ZVBvcywgcG9zIC0gdmFsdWVQb3MpO1xuICAgICAgICBsYXN0UGFyYW0gPSBoZWxwZXJzLnVuZXNjYXBlZEluZGV4T2YobGluZSwgUEFSQU1fREVMSU1JVEVSLCBwb3MpO1xuICAgICAgICBpZiAobGFzdFBhcmFtID09PSAtMSkge1xuICAgICAgICAgIHBvcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZVBvcyA9IHBvcyArIDE7XG5cbiAgICAgICAgLy8gbW92ZSB0byBuZXh0IFwiO1wiXG4gICAgICAgIHZhciBuZXh0UG9zID0gaGVscGVycy51bmVzY2FwZWRJbmRleE9mKGxpbmUsIFBBUkFNX0RFTElNSVRFUiwgdmFsdWVQb3MpO1xuICAgICAgICB2YXIgcHJvcFZhbHVlUG9zID0gaGVscGVycy51bmVzY2FwZWRJbmRleE9mKGxpbmUsIFZBTFVFX0RFTElNSVRFUiwgdmFsdWVQb3MpO1xuICAgICAgICBpZiAocHJvcFZhbHVlUG9zICE9PSAtMSAmJiBuZXh0UG9zID4gcHJvcFZhbHVlUG9zKSB7XG4gICAgICAgICAgLy8gdGhpcyBpcyBhIGRlbGltaXRlciBpbiB0aGUgcHJvcGVydHkgdmFsdWUsIGxldCdzIHN0b3AgaGVyZVxuICAgICAgICAgIG5leHRQb3MgPSBwcm9wVmFsdWVQb3M7XG4gICAgICAgICAgcG9zID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAobmV4dFBvcyA9PT0gLTEpIHtcbiAgICAgICAgICAvLyBubyBcIjtcIlxuICAgICAgICAgIGlmIChwcm9wVmFsdWVQb3MgPT09IC0xKSB7XG4gICAgICAgICAgICBuZXh0UG9zID0gbGluZS5sZW5ndGg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHRQb3MgPSBwcm9wVmFsdWVQb3M7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBvcyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhc3RQYXJhbSA9IG5leHRQb3M7XG4gICAgICAgICAgcG9zID0gbmV4dFBvcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gbGluZS5zdWJzdHIodmFsdWVQb3MsIG5leHRQb3MgLSB2YWx1ZVBvcyk7XG4gICAgICB9XG5cbiAgICAgIHZhbHVlID0gcGFyc2VyLl9yZmM2ODY4RXNjYXBlKHZhbHVlKTtcbiAgICAgIGlmIChtdWx0aVZhbHVlKSB7XG4gICAgICAgIHZhciBkZWxpbWl0ZXIgPSBtdmRlbGltIHx8IG11bHRpVmFsdWU7XG4gICAgICAgIHZhbHVlID0gcGFyc2VyLl9wYXJzZU11bHRpVmFsdWUodmFsdWUsIGRlbGltaXRlciwgdHlwZSwgW10sIG51bGwsIGRlc2lnblNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IHBhcnNlci5fcGFyc2VWYWx1ZSh2YWx1ZSwgdHlwZSwgZGVzaWduU2V0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKG11bHRpVmFsdWUgJiYgKGxjbmFtZSBpbiByZXN1bHQpKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdFtsY25hbWVdKSkge1xuICAgICAgICAgIHJlc3VsdFtsY25hbWVdLnB1c2godmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdFtsY25hbWVdID0gW1xuICAgICAgICAgICAgcmVzdWx0W2xjbmFtZV0sXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtsY25hbWVdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbcmVzdWx0LCB2YWx1ZSwgdmFsdWVQb3NdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBoZWxwZXIgZm9yIHJmYzY4NjguIEV4cG9zaW5nIHRoaXMgb24gSUNBTC5wYXJzZSBzbyB0aGF0XG4gICAqIGhhY2tlcnMgY2FuIGRpc2FibGUgdGhlIHJmYzY4NjggcGFyc2luZyBpZiB0aGUgcmVhbGx5IG5lZWQgdG8uXG4gICAqXG4gICAqIEBmdW5jdGlvbiBJQ0FMLnBhcnNlLl9yZmM2ODY4RXNjYXBlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWwgICAgICAgIFRoZSB2YWx1ZSB0byBlc2NhcGVcbiAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICAgVGhlIGVzY2FwZWQgdmFsdWVcbiAgICovXG4gIHBhcnNlci5fcmZjNjg2OEVzY2FwZSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgIHJldHVybiB2YWwucmVwbGFjZSgvXFxeWyduXl0vZywgZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIFJGQzY4NjhfUkVQTEFDRV9NQVBbeF07XG4gICAgfSk7XG4gIH07XG4gIHZhciBSRkM2ODY4X1JFUExBQ0VfTUFQID0geyBcIl4nXCI6ICdcIicsIFwiXm5cIjogXCJcXG5cIiwgXCJeXlwiOiBcIl5cIiB9O1xuXG4gIC8qKlxuICAgKiBQYXJzZSBhIG11bHRpIHZhbHVlIHN0cmluZy4gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGVpdGhlciBmb3IgcGFyc2luZ1xuICAgKiBhY3R1YWwgbXVsdGktdmFsdWUgcHJvcGVydHkncyB2YWx1ZXMsIG9yIGZvciBoYW5kbGluZyBwYXJhbWV0ZXIgdmFsdWVzLiBJdFxuICAgKiBjYW4gYmUgdXNlZCBmb3IgYm90aCBtdWx0aS12YWx1ZSBwcm9wZXJ0aWVzIGFuZCBzdHJ1Y3R1cmVkIHZhbHVlIHByb3BlcnRpZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBmdW5jdGlvbiBJQ0FMLnBhcnNlLl9wYXJzZU11bHRpVmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGJ1ZmZlciAgICAgVGhlIGJ1ZmZlciBjb250YWluaW5nIHRoZSBmdWxsIHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkZWxpbSAgICAgIFRoZSBtdWx0aS12YWx1ZSBkZWxpbWl0ZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgICAgICAgVGhlIHZhbHVlIHR5cGUgdG8gYmUgcGFyc2VkXG4gICAqIEBwYXJhbSB7QXJyYXkuPD8+fSByZXN1bHQgICAgICAgIFRoZSBhcnJheSB0byBhcHBlbmQgcmVzdWx0cyB0bywgdmFyaWVzIG9uIHZhbHVlIHR5cGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGlubmVyTXVsdGkgVGhlIGlubmVyIGRlbGltaXRlciB0byBzcGxpdCBlYWNoIHZhbHVlIHdpdGhcbiAgICogQHBhcmFtIHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9IGRlc2lnblNldCAgIFRoZSBkZXNpZ24gZGF0YSBmb3IgdGhpcyB2YWx1ZVxuICAgKiBAcmV0dXJuIHs/fEFycmF5Ljw/Pn0gICAgICAgICAgICBFaXRoZXIgYW4gYXJyYXkgb2YgcmVzdWx0cywgb3IgdGhlIGZpcnN0IHJlc3VsdFxuICAgKi9cbiAgcGFyc2VyLl9wYXJzZU11bHRpVmFsdWUgPSBmdW5jdGlvbihidWZmZXIsIGRlbGltLCB0eXBlLCByZXN1bHQsIGlubmVyTXVsdGksIGRlc2lnblNldCwgc3RydWN0dXJlZFZhbHVlKSB7XG4gICAgdmFyIHBvcyA9IDA7XG4gICAgdmFyIGxhc3RQb3MgPSAwO1xuICAgIHZhciB2YWx1ZTtcbiAgICBpZiAoZGVsaW0ubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH1cblxuICAgIC8vIHNwbGl0IGVhY2ggcGllY2VcbiAgICB3aGlsZSAoKHBvcyA9IGhlbHBlcnMudW5lc2NhcGVkSW5kZXhPZihidWZmZXIsIGRlbGltLCBsYXN0UG9zKSkgIT09IC0xKSB7XG4gICAgICB2YWx1ZSA9IGJ1ZmZlci5zdWJzdHIobGFzdFBvcywgcG9zIC0gbGFzdFBvcyk7XG4gICAgICBpZiAoaW5uZXJNdWx0aSkge1xuICAgICAgICB2YWx1ZSA9IHBhcnNlci5fcGFyc2VNdWx0aVZhbHVlKHZhbHVlLCBpbm5lck11bHRpLCB0eXBlLCBbXSwgbnVsbCwgZGVzaWduU2V0LCBzdHJ1Y3R1cmVkVmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBwYXJzZXIuX3BhcnNlVmFsdWUodmFsdWUsIHR5cGUsIGRlc2lnblNldCwgc3RydWN0dXJlZFZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgIGxhc3RQb3MgPSBwb3MgKyBkZWxpbS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLy8gb24gdGhlIGxhc3QgcGllY2UgdGFrZSB0aGUgcmVzdCBvZiBzdHJpbmdcbiAgICB2YWx1ZSA9IGJ1ZmZlci5zdWJzdHIobGFzdFBvcyk7XG4gICAgaWYgKGlubmVyTXVsdGkpIHtcbiAgICAgIHZhbHVlID0gcGFyc2VyLl9wYXJzZU11bHRpVmFsdWUodmFsdWUsIGlubmVyTXVsdGksIHR5cGUsIFtdLCBudWxsLCBkZXNpZ25TZXQsIHN0cnVjdHVyZWRWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gcGFyc2VyLl9wYXJzZVZhbHVlKHZhbHVlLCB0eXBlLCBkZXNpZ25TZXQsIHN0cnVjdHVyZWRWYWx1ZSk7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcblxuICAgIHJldHVybiByZXN1bHQubGVuZ3RoID09IDEgPyByZXN1bHRbMF0gOiByZXN1bHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgYSBjb21wbGV0ZSBidWZmZXIgb2YgaUNhbGVuZGFyL3ZDYXJkIGRhdGEgbGluZSBieSBsaW5lLCBjb3JyZWN0bHlcbiAgICogdW5mb2xkaW5nIGNvbnRlbnQuIEVhY2ggbGluZSB3aWxsIGJlIHByb2Nlc3NlZCB3aXRoIHRoZSBnaXZlbiBjYWxsYmFja1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAZnVuY3Rpb24gSUNBTC5wYXJzZS5fZWFjaExpbmVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGJ1ZmZlciAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgYnVmZmVyIHRvIHByb2Nlc3NcbiAgICogQHBhcmFtIHtmdW5jdGlvbig/U3RyaW5nLCBTdHJpbmcpfSBjYWxsYmFjayAgICBUaGUgY2FsbGJhY2sgZm9yIGVhY2ggbGluZVxuICAgKi9cbiAgcGFyc2VyLl9lYWNoTGluZSA9IGZ1bmN0aW9uKGJ1ZmZlciwgY2FsbGJhY2spIHtcbiAgICB2YXIgbGVuID0gYnVmZmVyLmxlbmd0aDtcbiAgICB2YXIgbGFzdFBvcyA9IGJ1ZmZlci5zZWFyY2goQ0hBUik7XG4gICAgdmFyIHBvcyA9IGxhc3RQb3M7XG4gICAgdmFyIGxpbmU7XG4gICAgdmFyIGZpcnN0Q2hhcjtcblxuICAgIHZhciBuZXdsaW5lT2Zmc2V0O1xuXG4gICAgZG8ge1xuICAgICAgcG9zID0gYnVmZmVyLmluZGV4T2YoJ1xcbicsIGxhc3RQb3MpICsgMTtcblxuICAgICAgaWYgKHBvcyA+IDEgJiYgYnVmZmVyW3BvcyAtIDJdID09PSAnXFxyJykge1xuICAgICAgICBuZXdsaW5lT2Zmc2V0ID0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld2xpbmVPZmZzZXQgPSAxO1xuICAgICAgfVxuXG4gICAgICBpZiAocG9zID09PSAwKSB7XG4gICAgICAgIHBvcyA9IGxlbjtcbiAgICAgICAgbmV3bGluZU9mZnNldCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGZpcnN0Q2hhciA9IGJ1ZmZlcltsYXN0UG9zXTtcblxuICAgICAgaWYgKGZpcnN0Q2hhciA9PT0gJyAnIHx8IGZpcnN0Q2hhciA9PT0gJ1xcdCcpIHtcbiAgICAgICAgLy8gYWRkIHRvIGxpbmVcbiAgICAgICAgbGluZSArPSBidWZmZXIuc3Vic3RyKFxuICAgICAgICAgIGxhc3RQb3MgKyAxLFxuICAgICAgICAgIHBvcyAtIGxhc3RQb3MgLSAobmV3bGluZU9mZnNldCArIDEpXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobGluZSlcbiAgICAgICAgICBjYWxsYmFjayhudWxsLCBsaW5lKTtcbiAgICAgICAgLy8gcHVzaCBsaW5lXG4gICAgICAgIGxpbmUgPSBidWZmZXIuc3Vic3RyKFxuICAgICAgICAgIGxhc3RQb3MsXG4gICAgICAgICAgcG9zIC0gbGFzdFBvcyAtIG5ld2xpbmVPZmZzZXRcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgbGFzdFBvcyA9IHBvcztcbiAgICB9IHdoaWxlIChwb3MgIT09IGxlbik7XG5cbiAgICAvLyBleHRyYSBlbmRpbmcgbGluZVxuICAgIGxpbmUgPSBsaW5lLnRyaW0oKTtcblxuICAgIGlmIChsaW5lLmxlbmd0aClcbiAgICAgIGNhbGxiYWNrKG51bGwsIGxpbmUpO1xuICB9O1xuXG4gIHJldHVybiBwYXJzZXI7XG5cbn0oKSk7XG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICogUG9ydGlvbnMgQ29weXJpZ2h0IChDKSBQaGlsaXBwIEtld2lzY2gsIDIwMTEtMjAxNSAqL1xuXG5cbi8qKlxuICogVGhpcyBzeW1ib2wgaXMgZnVydGhlciBkZXNjcmliZWQgbGF0ZXIgb25cbiAqIEBpZ25vcmVcbiAqL1xuSUNBTC5Db21wb25lbnQgPSAoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgUFJPUEVSVFlfSU5ERVggPSAxO1xuICB2YXIgQ09NUE9ORU5UX0lOREVYID0gMjtcbiAgdmFyIE5BTUVfSU5ERVggPSAwO1xuXG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIFdyYXBzIGEgakNhbCBjb21wb25lbnQsIGFkZGluZyBjb252ZW5pZW5jZSBtZXRob2RzIHRvIGFkZCwgcmVtb3ZlIGFuZFxuICAgKiB1cGRhdGUgc3ViY29tcG9uZW50cyBhbmQgcHJvcGVydGllcy5cbiAgICpcbiAgICogQGNsYXNzXG4gICAqIEBhbGlhcyBJQ0FMLkNvbXBvbmVudFxuICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gakNhbCAgICAgICAgIFJhdyBqQ2FsIGNvbXBvbmVudCBkYXRhIE9SIG5hbWUgb2YgbmV3XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRcbiAgICogQHBhcmFtIHtJQ0FMLkNvbXBvbmVudH0gcGFyZW50ICAgICBQYXJlbnQgY29tcG9uZW50IHRvIGFzc29jaWF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gQ29tcG9uZW50KGpDYWwsIHBhcmVudCkge1xuICAgIGlmICh0eXBlb2YoakNhbCkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBqQ2FsIHNwZWMgKG5hbWUsIHByb3BlcnRpZXMsIGNvbXBvbmVudHMpXG4gICAgICBqQ2FsID0gW2pDYWwsIFtdLCBbXV07XG4gICAgfVxuXG4gICAgLy8gbW9zdGx5IGZvciBsZWdhY3kgcmVhc29ucy5cbiAgICB0aGlzLmpDYWwgPSBqQ2FsO1xuXG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQgfHwgbnVsbDtcbiAgfVxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogSHlkcmF0ZWQgcHJvcGVydGllcyBhcmUgaW5zZXJ0ZWQgaW50byB0aGUgX3Byb3BlcnRpZXMgYXJyYXkgYXQgdGhlIHNhbWVcbiAgICAgKiBwb3NpdGlvbiBhcyBpbiB0aGUgakNhbCBhcnJheSwgc28gaXQgaXMgcG9zc2libGUgdGhhdCB0aGUgYXJyYXkgY29udGFpbnNcbiAgICAgKiB1bmRlZmluZWQgdmFsdWVzIGZvciB1bmh5ZHJkYXRlZCBwcm9wZXJ0aWVzLiBUbyBhdm9pZCBpdGVyYXRpbmcgdGhlXG4gICAgICogYXJyYXkgd2hlbiBjaGVja2luZyBpZiBhbGwgcHJvcGVydGllcyBoYXZlIGJlZW4gaHlkcmF0ZWQsIHdlIHNhdmUgdGhlXG4gICAgICogY291bnQgaGVyZS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaHlkcmF0ZWRQcm9wZXJ0eUNvdW50OiAwLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHNhbWUgY291bnQgYXMgZm9yIF9oeWRyYXRlZFByb3BlcnR5Q291bnQsIGJ1dCBmb3Igc3ViY29tcG9uZW50c1xuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9oeWRyYXRlZENvbXBvbmVudENvdW50OiAwLFxuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhpcyBjb21wb25lbnRcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmpDYWxbTkFNRV9JTkRFWF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZXNpZ24gc2V0IGZvciB0aGlzIGNvbXBvbmVudCwgZS5nLiBpY2FsZW5kYXIgdnMgdmNhcmRcbiAgICAgKlxuICAgICAqIEB0eXBlIHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXQgX2Rlc2lnblNldCgpIHtcbiAgICAgIHZhciBwYXJlbnREZXNpZ24gPSB0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5fZGVzaWduU2V0O1xuICAgICAgcmV0dXJuIHBhcmVudERlc2lnbiB8fCBJQ0FMLmRlc2lnbi5nZXREZXNpZ25TZXQodGhpcy5uYW1lKTtcbiAgICB9LFxuXG4gICAgX2h5ZHJhdGVDb21wb25lbnQ6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICBpZiAoIXRoaXMuX2NvbXBvbmVudHMpIHtcbiAgICAgICAgdGhpcy5fY29tcG9uZW50cyA9IFtdO1xuICAgICAgICB0aGlzLl9oeWRyYXRlZENvbXBvbmVudENvdW50ID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2NvbXBvbmVudHNbaW5kZXhdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRzW2luZGV4XTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbXAgPSBuZXcgQ29tcG9uZW50KFxuICAgICAgICB0aGlzLmpDYWxbQ09NUE9ORU5UX0lOREVYXVtpbmRleF0sXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG5cbiAgICAgIHRoaXMuX2h5ZHJhdGVkQ29tcG9uZW50Q291bnQrKztcbiAgICAgIHJldHVybiAodGhpcy5fY29tcG9uZW50c1tpbmRleF0gPSBjb21wKTtcbiAgICB9LFxuXG4gICAgX2h5ZHJhdGVQcm9wZXJ0eTogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIGlmICghdGhpcy5fcHJvcGVydGllcykge1xuICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzID0gW107XG4gICAgICAgIHRoaXMuX2h5ZHJhdGVkUHJvcGVydHlDb3VudCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9wcm9wZXJ0aWVzW2luZGV4XSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJvcGVydGllc1tpbmRleF07XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wID0gbmV3IElDQUwuUHJvcGVydHkoXG4gICAgICAgIHRoaXMuakNhbFtQUk9QRVJUWV9JTkRFWF1baW5kZXhdLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuXG4gICAgICB0aGlzLl9oeWRyYXRlZFByb3BlcnR5Q291bnQrKztcbiAgICAgIHJldHVybiAodGhpcy5fcHJvcGVydGllc1tpbmRleF0gPSBwcm9wKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZHMgZmlyc3Qgc3ViIGNvbXBvbmVudCwgb3B0aW9uYWxseSBmaWx0ZXJlZCBieSBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmc9fSBuYW1lICAgICAgICBPcHRpb25hbCBuYW1lIHRvIGZpbHRlciBieVxuICAgICAqIEByZXR1cm4gez9JQ0FMLkNvbXBvbmVudH0gICAgIFRoZSBmb3VuZCBzdWJjb21wb25lbnRcbiAgICAgKi9cbiAgICBnZXRGaXJzdFN1YmNvbXBvbmVudDogZnVuY3Rpb24obmFtZSkge1xuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgY29tcHMgPSB0aGlzLmpDYWxbQ09NUE9ORU5UX0lOREVYXTtcbiAgICAgICAgdmFyIGxlbiA9IGNvbXBzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWYgKGNvbXBzW2ldW05BTUVfSU5ERVhdID09PSBuYW1lKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5faHlkcmF0ZUNvbXBvbmVudChpKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5qQ2FsW0NPTVBPTkVOVF9JTkRFWF0ubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2h5ZHJhdGVDb21wb25lbnQoMCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZW5zdXJlIHdlIHJldHVybiBhIHZhbHVlIChzdHJpY3QgbW9kZSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyBhbGwgc3ViIGNvbXBvbmVudHMsIG9wdGlvbmFsbHkgZmlsdGVyaW5nIGJ5IG5hbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZz19IG5hbWUgICAgICAgICAgICBPcHRpb25hbCBuYW1lIHRvIGZpbHRlciBieVxuICAgICAqIEByZXR1cm4ge0lDQUwuQ29tcG9uZW50W119ICAgICAgIFRoZSBmb3VuZCBzdWIgY29tcG9uZW50c1xuICAgICAqL1xuICAgIGdldEFsbFN1YmNvbXBvbmVudHM6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciBqQ2FsTGVuID0gdGhpcy5qQ2FsW0NPTVBPTkVOVF9JTkRFWF0ubGVuZ3RoO1xuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICB2YXIgY29tcHMgPSB0aGlzLmpDYWxbQ09NUE9ORU5UX0lOREVYXTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGZvciAoOyBpIDwgakNhbExlbjsgaSsrKSB7XG4gICAgICAgICAgaWYgKG5hbWUgPT09IGNvbXBzW2ldW05BTUVfSU5ERVhdKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICAgICAgdGhpcy5faHlkcmF0ZUNvbXBvbmVudChpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdGhpcy5fY29tcG9uZW50cyB8fFxuICAgICAgICAgICAgKHRoaXMuX2h5ZHJhdGVkQ29tcG9uZW50Q291bnQgIT09IGpDYWxMZW4pKSB7XG4gICAgICAgICAgZm9yICg7IGkgPCBqQ2FsTGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX2h5ZHJhdGVDb21wb25lbnQoaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudHMgfHwgW107XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSB3aGVuIGEgbmFtZWQgcHJvcGVydHkgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgICAgIFRoZSBwcm9wZXJ0eSBuYW1lXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgIFRydWUsIHdoZW4gcHJvcGVydHkgaXMgZm91bmRcbiAgICAgKi9cbiAgICBoYXNQcm9wZXJ0eTogZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIHByb3BzID0gdGhpcy5qQ2FsW1BST1BFUlRZX0lOREVYXTtcbiAgICAgIHZhciBsZW4gPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgIHZhciBpID0gMDtcbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgLy8gMCBpcyBwcm9wZXJ0eSBuYW1lXG4gICAgICAgIGlmIChwcm9wc1tpXVtOQU1FX0lOREVYXSA9PT0gbmFtZSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIGZpcnN0IHByb3BlcnR5LCBvcHRpb25hbGx5IHdpdGggdGhlIGdpdmVuIG5hbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZz19IG5hbWUgICAgICAgIExvd2VyY2FzZSBwcm9wZXJ0eSBuYW1lXG4gICAgICogQHJldHVybiB7P0lDQUwuUHJvcGVydHl9ICAgICBUaGUgZm91bmQgcHJvcGVydHlcbiAgICAgKi9cbiAgICBnZXRGaXJzdFByb3BlcnR5OiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMuakNhbFtQUk9QRVJUWV9JTkRFWF07XG4gICAgICAgIHZhciBsZW4gPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmIChwcm9wc1tpXVtOQU1FX0lOREVYXSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2h5ZHJhdGVQcm9wZXJ0eShpKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5qQ2FsW1BST1BFUlRZX0lOREVYXS5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5faHlkcmF0ZVByb3BlcnR5KDApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGZpcnN0IHByb3BlcnR5J3MgdmFsdWUsIGlmIGF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nPX0gbmFtZSAgICBMb3dlcmNhc2UgcHJvcGVydHkgbmFtZVxuICAgICAqIEByZXR1cm4gez9TdHJpbmd9ICAgICAgICBUaGUgZm91bmQgcHJvcGVydHkgdmFsdWUuXG4gICAgICovXG4gICAgZ2V0Rmlyc3RQcm9wZXJ0eVZhbHVlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgcHJvcCA9IHRoaXMuZ2V0Rmlyc3RQcm9wZXJ0eShuYW1lKTtcbiAgICAgIGlmIChwcm9wKSB7XG4gICAgICAgIHJldHVybiBwcm9wLmdldEZpcnN0VmFsdWUoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgcHJvcGVydGllcyBpbiB0aGUgY29tcG9uZW50LCBvcHRpb25hbGx5IGZpbHRlcmVkIGJ5IG5hbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZz19IG5hbWUgICAgICAgIExvd2VyY2FzZSBwcm9wZXJ0eSBuYW1lXG4gICAgICogQHJldHVybiB7SUNBTC5Qcm9wZXJ0eVtdfSAgICBMaXN0IG9mIHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBnZXRBbGxQcm9wZXJ0aWVzOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgakNhbExlbiA9IHRoaXMuakNhbFtQUk9QRVJUWV9JTkRFWF0ubGVuZ3RoO1xuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLmpDYWxbUFJPUEVSVFlfSU5ERVhdO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgZm9yICg7IGkgPCBqQ2FsTGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAobmFtZSA9PT0gcHJvcHNbaV1bTkFNRV9JTkRFWF0pIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgICAgICB0aGlzLl9oeWRyYXRlUHJvcGVydHkoaSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXRoaXMuX3Byb3BlcnRpZXMgfHxcbiAgICAgICAgICAgICh0aGlzLl9oeWRyYXRlZFByb3BlcnR5Q291bnQgIT09IGpDYWxMZW4pKSB7XG4gICAgICAgICAgZm9yICg7IGkgPCBqQ2FsTGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX2h5ZHJhdGVQcm9wZXJ0eShpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fcHJvcGVydGllcyB8fCBbXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX3JlbW92ZU9iamVjdEJ5SW5kZXg6IGZ1bmN0aW9uKGpDYWxJbmRleCwgY2FjaGUsIGluZGV4KSB7XG4gICAgICBjYWNoZSA9IGNhY2hlIHx8IFtdO1xuICAgICAgLy8gcmVtb3ZlIGNhY2hlZCB2ZXJzaW9uXG4gICAgICBpZiAoY2FjaGVbaW5kZXhdKSB7XG4gICAgICAgIHZhciBvYmogPSBjYWNoZVtpbmRleF07XG4gICAgICAgIGlmIChcInBhcmVudFwiIGluIG9iaikge1xuICAgICAgICAgICAgb2JqLnBhcmVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2FjaGUuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgLy8gcmVtb3ZlIGl0IGZyb20gdGhlIGpDYWxcbiAgICAgIHRoaXMuakNhbFtqQ2FsSW5kZXhdLnNwbGljZShpbmRleCwgMSk7XG4gICAgfSxcblxuICAgIF9yZW1vdmVPYmplY3Q6IGZ1bmN0aW9uKGpDYWxJbmRleCwgY2FjaGUsIG5hbWVPck9iamVjdCkge1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIG9iamVjdHMgPSB0aGlzLmpDYWxbakNhbEluZGV4XTtcbiAgICAgIHZhciBsZW4gPSBvYmplY3RzLmxlbmd0aDtcbiAgICAgIHZhciBjYWNoZWQgPSB0aGlzW2NhY2hlXTtcblxuICAgICAgaWYgKHR5cGVvZihuYW1lT3JPYmplY3QpID09PSAnc3RyaW5nJykge1xuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWYgKG9iamVjdHNbaV1bTkFNRV9JTkRFWF0gPT09IG5hbWVPck9iamVjdCkge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlT2JqZWN0QnlJbmRleChqQ2FsSW5kZXgsIGNhY2hlZCwgaSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2FjaGVkKSB7XG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAoY2FjaGVkW2ldICYmIGNhY2hlZFtpXSA9PT0gbmFtZU9yT2JqZWN0KSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVPYmplY3RCeUluZGV4KGpDYWxJbmRleCwgY2FjaGVkLCBpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIF9yZW1vdmVBbGxPYmplY3RzOiBmdW5jdGlvbihqQ2FsSW5kZXgsIGNhY2hlLCBuYW1lKSB7XG4gICAgICB2YXIgY2FjaGVkID0gdGhpc1tjYWNoZV07XG5cbiAgICAgIC8vIFVuZm9ydHVuYXRlbHkgd2UgaGF2ZSB0byBydW4gdGhyb3VnaCBhbGwgY2hpbGRyZW4gdG8gcmVzZXQgdGhlaXJcbiAgICAgIC8vIHBhcmVudCBwcm9wZXJ0eS5cbiAgICAgIHZhciBvYmplY3RzID0gdGhpcy5qQ2FsW2pDYWxJbmRleF07XG4gICAgICB2YXIgaSA9IG9iamVjdHMubGVuZ3RoIC0gMTtcblxuICAgICAgLy8gZGVzY2VuZGluZyBzZWFyY2ggcmVxdWlyZWQgYmVjYXVzZSBzcGxpY2VcbiAgICAgIC8vIGlzIHVzZWQgYW5kIHdpbGwgZWZmZWN0IHRoZSBpbmRpY2VzLlxuICAgICAgZm9yICg7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmICghbmFtZSB8fCBvYmplY3RzW2ldW05BTUVfSU5ERVhdID09PSBuYW1lKSB7XG4gICAgICAgICAgdGhpcy5fcmVtb3ZlT2JqZWN0QnlJbmRleChqQ2FsSW5kZXgsIGNhY2hlZCwgaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHNpbmdsZSBzdWIgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLkNvbXBvbmVudH0gY29tcG9uZW50ICAgICAgICBUaGUgY29tcG9uZW50IHRvIGFkZFxuICAgICAqIEByZXR1cm4ge0lDQUwuQ29tcG9uZW50fSAgICAgICAgICAgICAgICAgVGhlIHBhc3NlZCBpbiBjb21wb25lbnRcbiAgICAgKi9cbiAgICBhZGRTdWJjb21wb25lbnQ6IGZ1bmN0aW9uKGNvbXBvbmVudCkge1xuICAgICAgaWYgKCF0aGlzLl9jb21wb25lbnRzKSB7XG4gICAgICAgIHRoaXMuX2NvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5faHlkcmF0ZWRDb21wb25lbnRDb3VudCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb21wb25lbnQucGFyZW50KSB7XG4gICAgICAgIGNvbXBvbmVudC5wYXJlbnQucmVtb3ZlU3ViY29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpZHggPSB0aGlzLmpDYWxbQ09NUE9ORU5UX0lOREVYXS5wdXNoKGNvbXBvbmVudC5qQ2FsKTtcbiAgICAgIHRoaXMuX2NvbXBvbmVudHNbaWR4IC0gMV0gPSBjb21wb25lbnQ7XG4gICAgICB0aGlzLl9oeWRyYXRlZENvbXBvbmVudENvdW50Kys7XG4gICAgICBjb21wb25lbnQucGFyZW50ID0gdGhpcztcbiAgICAgIHJldHVybiBjb21wb25lbnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBzaW5nbGUgY29tcG9uZW50IGJ5IG5hbWUgb3IgdGhlIGluc3RhbmNlIG9mIGEgc3BlY2lmaWNcbiAgICAgKiBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuQ29tcG9uZW50fFN0cmluZ30gbmFtZU9yQ29tcCAgICBOYW1lIG9mIGNvbXBvbmVudCwgb3IgY29tcG9uZW50XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgICAgICAgICAgICAgICAgICAgVHJ1ZSB3aGVuIGNvbXAgaXMgcmVtb3ZlZFxuICAgICAqL1xuICAgIHJlbW92ZVN1YmNvbXBvbmVudDogZnVuY3Rpb24obmFtZU9yQ29tcCkge1xuICAgICAgdmFyIHJlbW92ZWQgPSB0aGlzLl9yZW1vdmVPYmplY3QoQ09NUE9ORU5UX0lOREVYLCAnX2NvbXBvbmVudHMnLCBuYW1lT3JDb21wKTtcbiAgICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICAgIHRoaXMuX2h5ZHJhdGVkQ29tcG9uZW50Q291bnQtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBjb21wb25lbnRzIG9yIChpZiBnaXZlbikgYWxsIGNvbXBvbmVudHMgYnkgYSBwYXJ0aWN1bGFyXG4gICAgICogbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nPX0gbmFtZSAgICAgICAgICAgIExvd2VyY2FzZSBjb21wb25lbnQgbmFtZVxuICAgICAqL1xuICAgIHJlbW92ZUFsbFN1YmNvbXBvbmVudHM6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciByZW1vdmVkID0gdGhpcy5fcmVtb3ZlQWxsT2JqZWN0cyhDT01QT05FTlRfSU5ERVgsICdfY29tcG9uZW50cycsIG5hbWUpO1xuICAgICAgdGhpcy5faHlkcmF0ZWRDb21wb25lbnRDb3VudCA9IDA7XG4gICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbiB7QGxpbmsgSUNBTC5Qcm9wZXJ0eX0gdG8gdGhlIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SUNBTC5Qcm9wZXJ0eX0gcHJvcGVydHkgICAgICBUaGUgcHJvcGVydHkgdG8gYWRkXG4gICAgICogQHJldHVybiB7SUNBTC5Qcm9wZXJ0eX0gICAgICAgICAgICAgIFRoZSBwYXNzZWQgaW4gcHJvcGVydHlcbiAgICAgKi9cbiAgICBhZGRQcm9wZXJ0eTogZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgIGlmICghKHByb3BlcnR5IGluc3RhbmNlb2YgSUNBTC5Qcm9wZXJ0eSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbXVzdCBpbnN0YW5jZSBvZiBJQ0FMLlByb3BlcnR5Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5fcHJvcGVydGllcykge1xuICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzID0gW107XG4gICAgICAgIHRoaXMuX2h5ZHJhdGVkUHJvcGVydHlDb3VudCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wZXJ0eS5wYXJlbnQpIHtcbiAgICAgICAgcHJvcGVydHkucGFyZW50LnJlbW92ZVByb3BlcnR5KHByb3BlcnR5KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlkeCA9IHRoaXMuakNhbFtQUk9QRVJUWV9JTkRFWF0ucHVzaChwcm9wZXJ0eS5qQ2FsKTtcbiAgICAgIHRoaXMuX3Byb3BlcnRpZXNbaWR4IC0gMV0gPSBwcm9wZXJ0eTtcbiAgICAgIHRoaXMuX2h5ZHJhdGVkUHJvcGVydHlDb3VudCsrO1xuICAgICAgcHJvcGVydHkucGFyZW50ID0gdGhpcztcbiAgICAgIHJldHVybiBwcm9wZXJ0eTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBhZGQgYSBwcm9wZXJ0eSB3aXRoIGEgdmFsdWUgdG8gdGhlIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgICAgICAgICAgIG5hbWUgICAgICAgICBQcm9wZXJ0eSBuYW1lIHRvIGFkZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcnxPYmplY3R9IHZhbHVlICAgICAgICBQcm9wZXJ0eSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0lDQUwuUHJvcGVydHl9ICAgICAgICAgICAgICAgICAgICBUaGUgY3JlYXRlZCBwcm9wZXJ0eVxuICAgICAqL1xuICAgIGFkZFByb3BlcnR5V2l0aFZhbHVlOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIHByb3AgPSBuZXcgSUNBTC5Qcm9wZXJ0eShuYW1lKTtcbiAgICAgIHByb3Auc2V0VmFsdWUodmFsdWUpO1xuXG4gICAgICB0aGlzLmFkZFByb3BlcnR5KHByb3ApO1xuXG4gICAgICByZXR1cm4gcHJvcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0aGF0IHdpbGwgdXBkYXRlIG9yIGNyZWF0ZSBhIHByb3BlcnR5IG9mIHRoZSBnaXZlbiBuYW1lXG4gICAgICogYW5kIHNldHMgaXRzIHZhbHVlLiBJZiBtdWx0aXBsZSBwcm9wZXJ0aWVzIHdpdGggdGhlIGdpdmVuIG5hbWUgZXhpc3QsXG4gICAgICogb25seSB0aGUgZmlyc3QgaXMgdXBkYXRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgICAgICAgICAgIG5hbWUgICAgICAgICBQcm9wZXJ0eSBuYW1lIHRvIHVwZGF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcnxPYmplY3R9IHZhbHVlICAgICAgICBQcm9wZXJ0eSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0lDQUwuUHJvcGVydHl9ICAgICAgICAgICAgICAgICAgICBUaGUgY3JlYXRlZCBwcm9wZXJ0eVxuICAgICAqL1xuICAgIHVwZGF0ZVByb3BlcnR5V2l0aFZhbHVlOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIHByb3AgPSB0aGlzLmdldEZpcnN0UHJvcGVydHkobmFtZSk7XG5cbiAgICAgIGlmIChwcm9wKSB7XG4gICAgICAgIHByb3Auc2V0VmFsdWUodmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcCA9IHRoaXMuYWRkUHJvcGVydHlXaXRoVmFsdWUobmFtZSwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHNpbmdsZSBwcm9wZXJ0eSBieSBuYW1lIG9yIHRoZSBpbnN0YW5jZSBvZiB0aGUgc3BlY2lmaWNcbiAgICAgKiBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfElDQUwuUHJvcGVydHl9IG5hbWVPclByb3AgICAgIFByb3BlcnR5IG5hbWUgb3IgaW5zdGFuY2UgdG8gcmVtb3ZlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgICAgICAgICAgICAgICAgICAgVHJ1ZSwgd2hlbiBkZWxldGVkXG4gICAgICovXG4gICAgcmVtb3ZlUHJvcGVydHk6IGZ1bmN0aW9uKG5hbWVPclByb3ApIHtcbiAgICAgIHZhciByZW1vdmVkID0gdGhpcy5fcmVtb3ZlT2JqZWN0KFBST1BFUlRZX0lOREVYLCAnX3Byb3BlcnRpZXMnLCBuYW1lT3JQcm9wKTtcbiAgICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICAgIHRoaXMuX2h5ZHJhdGVkUHJvcGVydHlDb3VudC0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlbW92ZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIHByb3BlcnRpZXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY29tcG9uZW50LCBvcHRpb25hbGx5XG4gICAgICogZmlsdGVyZWQgYnkgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nPX0gbmFtZSAgICAgICAgTG93ZXJjYXNlIHByb3BlcnR5IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICAgIFRydWUsIHdoZW4gZGVsZXRlZFxuICAgICAqL1xuICAgIHJlbW92ZUFsbFByb3BlcnRpZXM6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciByZW1vdmVkID0gdGhpcy5fcmVtb3ZlQWxsT2JqZWN0cyhQUk9QRVJUWV9JTkRFWCwgJ19wcm9wZXJ0aWVzJywgbmFtZSk7XG4gICAgICB0aGlzLl9oeWRyYXRlZFByb3BlcnR5Q291bnQgPSAwO1xuICAgICAgcmV0dXJuIHJlbW92ZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbXBvbmVudC4gVGhlIHJldHVybmVkIG9iamVjdFxuICAgICAqIGlzIGEgbGl2ZSBqQ2FsIG9iamVjdCBhbmQgc2hvdWxkIGJlIGNsb25lZCBpZiBtb2RpZmllZC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmpDYWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBjb21wb25lbnQuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBJQ0FMLnN0cmluZ2lmeS5jb21wb25lbnQoXG4gICAgICAgIHRoaXMuakNhbCwgdGhpcy5fZGVzaWduU2V0XG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIHtAbGluayBJQ0FMLkNvbXBvbmVudH0gYnkgcGFyc2luZyB0aGUgcGFzc2VkIGlDYWxlbmRhciBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgICAgICAgIFRoZSBpQ2FsZW5kYXIgc3RyaW5nIHRvIHBhcnNlXG4gICAqL1xuICBDb21wb25lbnQuZnJvbVN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgQ29tcG9uZW50KElDQUwucGFyc2UuY29tcG9uZW50KHN0cikpO1xuICB9O1xuXG4gIHJldHVybiBDb21wb25lbnQ7XG59KCkpO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoLCAyMDExLTIwMTUgKi9cblxuXG4vKipcbiAqIFRoaXMgc3ltYm9sIGlzIGZ1cnRoZXIgZGVzY3JpYmVkIGxhdGVyIG9uXG4gKiBAaWdub3JlXG4gKi9cbklDQUwuUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgTkFNRV9JTkRFWCA9IDA7XG4gIHZhciBQUk9QX0lOREVYID0gMTtcbiAgdmFyIFRZUEVfSU5ERVggPSAyO1xuICB2YXIgVkFMVUVfSU5ERVggPSAzO1xuXG4gIHZhciBkZXNpZ24gPSBJQ0FMLmRlc2lnbjtcblxuICAvKipcbiAgICogQGNsYXNzZGVzY1xuICAgKiBQcm92aWRlcyBhIGxheWVyIG9uIHRvcCBvZiB0aGUgcmF3IGpDYWwgb2JqZWN0IGZvciBtYW5pcHVsYXRpbmcgYSBzaW5nbGVcbiAgICogcHJvcGVydHksIHdpdGggaXRzIHBhcmFtZXRlcnMgYW5kIHZhbHVlLlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogSXQgaXMgaW1wb3J0YW50IHRvIG5vdGUgdGhhdCBtdXRhdGlvbnMgZG9uZSBpbiB0aGUgd3JhcHBlclxuICAgKiBkaXJlY3RseSBtdXRhdGUgdGhlIGpDYWwgb2JqZWN0IHVzZWQgdG8gaW5pdGlhbGl6ZS5cbiAgICpcbiAgICogQ2FuIGFsc28gYmUgdXNlZCB0byBjcmVhdGUgbmV3IHByb3BlcnRpZXMgYnkgcGFzc2luZ1xuICAgKiB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgKGFzIGEgU3RyaW5nKS5cbiAgICpcbiAgICogQGNsYXNzXG4gICAqIEBhbGlhcyBJQ0FMLlByb3BlcnR5XG4gICAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBqQ2FsICAgICAgICAgUmF3IGpDYWwgcmVwcmVzZW50YXRpb24gT1JcbiAgICogIHRoZSBuZXcgbmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICpcbiAgICogQHBhcmFtIHtJQ0FMLkNvbXBvbmVudD19IHBhcmVudCAgICBQYXJlbnQgY29tcG9uZW50XG4gICAqL1xuICBmdW5jdGlvbiBQcm9wZXJ0eShqQ2FsLCBwYXJlbnQpIHtcbiAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQgfHwgbnVsbDtcblxuICAgIGlmICh0eXBlb2YoakNhbCkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBXZSBhcmUgY3JlYXRpbmcgdGhlIHByb3BlcnR5IGJ5IG5hbWUgYW5kIG5lZWQgdG8gZGV0ZWN0IHRoZSB0eXBlXG4gICAgICB0aGlzLmpDYWwgPSBbakNhbCwge30sIGRlc2lnbi5kZWZhdWx0VHlwZV07XG4gICAgICB0aGlzLmpDYWxbVFlQRV9JTkRFWF0gPSB0aGlzLmdldERlZmF1bHRUeXBlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuakNhbCA9IGpDYWw7XG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZVR5cGUoKTtcbiAgfVxuXG4gIFByb3BlcnR5LnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSB0eXBlIGZvciB0aGlzIHByb3BlcnR5XG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmpDYWxbVFlQRV9JTkRFWF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoaXMgcHJvcGVydHksIGluIGxvd2VyY2FzZS5cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgcmV0dXJuIHRoaXMuakNhbFtOQU1FX0lOREVYXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHBhcmVudCBjb21wb25lbnQgZm9yIHRoaXMgcHJvcGVydHkuXG4gICAgICogQHR5cGUge0lDQUwuQ29tcG9uZW50fVxuICAgICAqL1xuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFyZW50O1xuICAgIH0sXG5cbiAgICBzZXQgcGFyZW50KHApIHtcbiAgICAgIC8vIEJlZm9yZSBzZXR0aW5nIHRoZSBwYXJlbnQsIGNoZWNrIGlmIHRoZSBkZXNpZ24gc2V0IGhhcyBjaGFuZ2VkLiBJZiBpdFxuICAgICAgLy8gaGFzLCB3ZSBsYXRlciBuZWVkIHRvIHVwZGF0ZSB0aGUgdHlwZSBpZiBpdCB3YXMgdW5rbm93biBiZWZvcmUuXG4gICAgICB2YXIgZGVzaWduU2V0Q2hhbmdlZCA9ICF0aGlzLl9wYXJlbnQgfHwgKHAgJiYgcC5fZGVzaWduU2V0ICE9IHRoaXMuX3BhcmVudC5fZGVzaWduU2V0KTtcblxuICAgICAgdGhpcy5fcGFyZW50ID0gcDtcblxuICAgICAgaWYgKHRoaXMudHlwZSA9PSBkZXNpZ24uZGVmYXVsdFR5cGUgJiYgZGVzaWduU2V0Q2hhbmdlZCkge1xuICAgICAgICB0aGlzLmpDYWxbVFlQRV9JTkRFWF0gPSB0aGlzLmdldERlZmF1bHRUeXBlKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVR5cGUoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZXNpZ24gc2V0IGZvciB0aGlzIHByb3BlcnR5LCBlLmcuIGljYWxlbmRhciB2cyB2Y2FyZFxuICAgICAqXG4gICAgICogQHR5cGUge0lDQUwuZGVzaWduLmRlc2lnblNldH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldCBfZGVzaWduU2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQuX2Rlc2lnblNldCA6IGRlc2lnbi5kZWZhdWx0U2V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSB0eXBlIG1ldGFkYXRhIGZyb20gdGhlIGN1cnJlbnQgakNhbCB0eXBlIGFuZCBkZXNpZ24gc2V0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlVHlwZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGVzaWduU2V0ID0gdGhpcy5fZGVzaWduU2V0O1xuXG4gICAgICBpZiAodGhpcy50eXBlIGluIGRlc2lnblNldC52YWx1ZSkge1xuICAgICAgICB2YXIgZGVzaWduVHlwZSA9IGRlc2lnblNldC52YWx1ZVt0aGlzLnR5cGVdO1xuXG4gICAgICAgIGlmICgnZGVjb3JhdGUnIGluIGRlc2lnblNldC52YWx1ZVt0aGlzLnR5cGVdKSB7XG4gICAgICAgICAgdGhpcy5pc0RlY29yYXRlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5pc0RlY29yYXRlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubmFtZSBpbiBkZXNpZ25TZXQucHJvcGVydHkpIHtcbiAgICAgICAgICB0aGlzLmlzTXVsdGlWYWx1ZSA9ICgnbXVsdGlWYWx1ZScgaW4gZGVzaWduU2V0LnByb3BlcnR5W3RoaXMubmFtZV0pO1xuICAgICAgICAgIHRoaXMuaXNTdHJ1Y3R1cmVkVmFsdWUgPSAoJ3N0cnVjdHVyZWRWYWx1ZScgaW4gZGVzaWduU2V0LnByb3BlcnR5W3RoaXMubmFtZV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEh5ZHJhdGUgYSBzaW5nbGUgdmFsdWUuIFRoZSBhY3Qgb2YgaHlkcmF0aW5nIG1lYW5zIHR1cm5pbmcgdGhlIHJhdyBqQ2FsXG4gICAgICogdmFsdWUgaW50byBhIHBvdGVudGlhbGx5IHdyYXBwZWQgb2JqZWN0LCBmb3IgZXhhbXBsZSB7QGxpbmsgSUNBTC5UaW1lfS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4ICAgICAgICBUaGUgaW5kZXggb2YgdGhlIHZhbHVlIHRvIGh5ZHJhdGVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICAgIFRoZSBkZWNvcmF0ZWQgdmFsdWUuXG4gICAgICovXG4gICAgX2h5ZHJhdGVWYWx1ZTogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIGlmICh0aGlzLl92YWx1ZXMgJiYgdGhpcy5fdmFsdWVzW2luZGV4XSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWVzW2luZGV4XTtcbiAgICAgIH1cblxuICAgICAgLy8gZm9yIHRoZSBjYXNlIHdoZXJlIHRoZXJlIGlzIG5vIHZhbHVlLlxuICAgICAgaWYgKHRoaXMuakNhbC5sZW5ndGggPD0gKFZBTFVFX0lOREVYICsgaW5kZXgpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pc0RlY29yYXRlZCkge1xuICAgICAgICBpZiAoIXRoaXMuX3ZhbHVlcykge1xuICAgICAgICAgIHRoaXMuX3ZhbHVlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGhpcy5fdmFsdWVzW2luZGV4XSA9IHRoaXMuX2RlY29yYXRlKFxuICAgICAgICAgIHRoaXMuakNhbFtWQUxVRV9JTkRFWCArIGluZGV4XVxuICAgICAgICApKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmpDYWxbVkFMVUVfSU5ERVggKyBpbmRleF07XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlY29yYXRlIGEgc2luZ2xlIHZhbHVlLCByZXR1cm5pbmcgaXRzIHdyYXBwZWQgb2JqZWN0LiBUaGlzIGlzIHVzZWQgYnlcbiAgICAgKiB0aGUgaHlkcmF0ZSBmdW5jdGlvbiB0byBhY3R1YWxseSB3cmFwIHRoZSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZSAgICAgICAgIFRoZSB2YWx1ZSB0byBkZWNvcmF0ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICBUaGUgZGVjb3JhdGVkIHZhbHVlXG4gICAgICovXG4gICAgX2RlY29yYXRlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Rlc2lnblNldC52YWx1ZVt0aGlzLnR5cGVdLmRlY29yYXRlKHZhbHVlLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVW5kZWNvcmF0ZSBhIHNpbmdsZSB2YWx1ZSwgcmV0dXJuaW5nIGl0cyByYXcgakNhbCBkYXRhLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgICAgICAgICBUaGUgdmFsdWUgdG8gdW5kZWNvcmF0ZVxuICAgICAqIEByZXR1cm4gez99ICAgICAgICAgICAgICAgICAgIFRoZSB1bmRlY29yYXRlZCB2YWx1ZVxuICAgICAqL1xuICAgIF91bmRlY29yYXRlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Rlc2lnblNldC52YWx1ZVt0aGlzLnR5cGVdLnVuZGVjb3JhdGUodmFsdWUsIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gaW5kZXggd2hpbGUgYWxzbyBoeWRyYXRpbmcgaXQuIFRoZSBwYXNzZWRcbiAgICAgKiB2YWx1ZSBjYW4gZWl0aGVyIGJlIGEgZGVjb3JhdGVkIG9yIHVuZGVjb3JhdGVkIHZhbHVlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlICAgICAgICAgICAgIFRoZSB2YWx1ZSB0byBzZXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggICAgICAgIFRoZSBpbmRleCB0byBzZXQgaXQgYXRcbiAgICAgKi9cbiAgICBfc2V0RGVjb3JhdGVkVmFsdWU6IGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgICAgaWYgKCF0aGlzLl92YWx1ZXMpIHtcbiAgICAgICAgdGhpcy5fdmFsdWVzID0gW107XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YodmFsdWUpID09PSAnb2JqZWN0JyAmJiAnaWNhbHR5cGUnIGluIHZhbHVlKSB7XG4gICAgICAgIC8vIGRlY29yYXRlZCB2YWx1ZVxuICAgICAgICB0aGlzLmpDYWxbVkFMVUVfSU5ERVggKyBpbmRleF0gPSB0aGlzLl91bmRlY29yYXRlKHZhbHVlKTtcbiAgICAgICAgdGhpcy5fdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdW5kZWNvcmF0ZWQgdmFsdWVcbiAgICAgICAgdGhpcy5qQ2FsW1ZBTFVFX0lOREVYICsgaW5kZXhdID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX3ZhbHVlc1tpbmRleF0gPSB0aGlzLl9kZWNvcmF0ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgYSBwYXJhbWV0ZXIgb24gdGhlIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgICAgICBuYW1lICAgUGFyYW1ldGVyIG5hbWUgKGxvd2VyY2FzZSlcbiAgICAgKiBAcmV0dXJuIHtBcnJheXxTdHJpbmd9ICAgICAgICBQYXJhbWV0ZXIgdmFsdWVcbiAgICAgKi9cbiAgICBnZXRQYXJhbWV0ZXI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIGlmIChuYW1lIGluIHRoaXMuakNhbFtQUk9QX0lOREVYXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5qQ2FsW1BST1BfSU5ERVhdW25hbWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyBmaXJzdCBwYXJhbWV0ZXIgb24gdGhlIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgICAgICBuYW1lICAgUGFyYW1ldGVyIG5hbWUgKGxvd2VyY2FzZSlcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICBQYXJhbWV0ZXIgdmFsdWVcbiAgICAgKi9cbiAgICBnZXRGaXJzdFBhcmFtZXRlcjogZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIHBhcmFtZXRlcnMgPSB0aGlzLmdldFBhcmFtZXRlcihuYW1lKTtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW1ldGVycykpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnNbMF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXJhbWV0ZXJzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgcGFyYW1ldGVyIG9uIHRoZSBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgICBuYW1lICAgICBUaGUgcGFyYW1ldGVyIG5hbWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gdmFsdWUgICAgVGhlIHBhcmFtZXRlciB2YWx1ZVxuICAgICAqL1xuICAgIHNldFBhcmFtZXRlcjogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBsY25hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgbGNuYW1lIGluIHRoaXMuX2Rlc2lnblNldC5wYXJhbSAmJlxuICAgICAgICAgICdtdWx0aVZhbHVlJyBpbiB0aGlzLl9kZXNpZ25TZXQucGFyYW1bbGNuYW1lXSkge1xuICAgICAgICAgIHZhbHVlID0gW3ZhbHVlXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuakNhbFtQUk9QX0lOREVYXVtuYW1lXSA9IHZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgcGFyYW1ldGVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAgICAgVGhlIHBhcmFtZXRlciBuYW1lXG4gICAgICovXG4gICAgcmVtb3ZlUGFyYW1ldGVyOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICBkZWxldGUgdGhpcy5qQ2FsW1BST1BfSU5ERVhdW25hbWVdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGRlZmF1bHQgdHlwZSBiYXNlZCBvbiB0aGlzIHByb3BlcnR5J3MgbmFtZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgIFRoZSBkZWZhdWx0IHR5cGUgZm9yIHRoaXMgcHJvcGVydHlcbiAgICAgKi9cbiAgICBnZXREZWZhdWx0VHlwZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbmFtZSA9IHRoaXMuakNhbFtOQU1FX0lOREVYXTtcbiAgICAgIHZhciBkZXNpZ25TZXQgPSB0aGlzLl9kZXNpZ25TZXQ7XG5cbiAgICAgIGlmIChuYW1lIGluIGRlc2lnblNldC5wcm9wZXJ0eSkge1xuICAgICAgICB2YXIgZGV0YWlscyA9IGRlc2lnblNldC5wcm9wZXJ0eVtuYW1lXTtcbiAgICAgICAgaWYgKCdkZWZhdWx0VHlwZScgaW4gZGV0YWlscykge1xuICAgICAgICAgIHJldHVybiBkZXRhaWxzLmRlZmF1bHRUeXBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVzaWduLmRlZmF1bHRUeXBlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHR5cGUgb2YgcHJvcGVydHkgYW5kIGNsZWFycyBvdXQgYW55IGV4aXN0aW5nIHZhbHVlcyBvZiB0aGUgY3VycmVudFxuICAgICAqIHR5cGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAgICAgTmV3IGlDQUwgdHlwZSAoc2VlIGRlc2lnbi4qLnZhbHVlcylcbiAgICAgKi9cbiAgICByZXNldFR5cGU6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHRoaXMucmVtb3ZlQWxsVmFsdWVzKCk7XG4gICAgICB0aGlzLmpDYWxbVFlQRV9JTkRFWF0gPSB0eXBlO1xuICAgICAgdGhpcy5fdXBkYXRlVHlwZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgZmlyc3QgcHJvcGVydHkgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgRmlyc3QgcHJvcGVydHkgdmFsdWVcbiAgICAgKi9cbiAgICBnZXRGaXJzdFZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9oeWRyYXRlVmFsdWUoMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIHZhbHVlcyBvbiB0aGUgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBOT1RFOiB0aGlzIGNyZWF0ZXMgYW4gYXJyYXkgZHVyaW5nIGVhY2ggY2FsbC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICBMaXN0IG9mIHZhbHVlc1xuICAgICAqL1xuICAgIGdldFZhbHVlczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGVuID0gdGhpcy5qQ2FsLmxlbmd0aCAtIFZBTFVFX0lOREVYO1xuXG4gICAgICBpZiAobGVuIDwgMSkge1xuICAgICAgICAvLyBpdCBpcyBwb3NzaWJsZSBmb3IgYSBwcm9wZXJ0eSB0byBoYXZlIG5vIHZhbHVlLlxuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG5cbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICByZXN1bHRbaV0gPSB0aGlzLl9oeWRyYXRlVmFsdWUoaSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIHZhbHVlcyBmcm9tIHRoaXMgcHJvcGVydHlcbiAgICAgKi9cbiAgICByZW1vdmVBbGxWYWx1ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuX3ZhbHVlcykge1xuICAgICAgICB0aGlzLl92YWx1ZXMubGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMuakNhbC5sZW5ndGggPSAzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2YWx1ZXMgb2YgdGhlIHByb3BlcnR5LiAgV2lsbCBvdmVyd3JpdGUgdGhlIGV4aXN0aW5nIHZhbHVlcy5cbiAgICAgKiBUaGlzIGNhbiBvbmx5IGJlIHVzZWQgZm9yIG11bHRpLXZhbHVlIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgICAgQW4gYXJyYXkgb2YgdmFsdWVzXG4gICAgICovXG4gICAgc2V0VmFsdWVzOiBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICAgIGlmICghdGhpcy5pc011bHRpVmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIHRoaXMubmFtZSArICc6IGRvZXMgbm90IG5vdCBzdXBwb3J0IG11bGl0VmFsdWUuXFxuJyArXG4gICAgICAgICAgJ292ZXJyaWRlIGlzTXVsdGlWYWx1ZSdcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlbiA9IHZhbHVlcy5sZW5ndGg7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB0aGlzLnJlbW92ZUFsbFZhbHVlcygpO1xuXG4gICAgICBpZiAobGVuID4gMCAmJlxuICAgICAgICAgIHR5cGVvZih2YWx1ZXNbMF0pID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICdpY2FsdHlwZScgaW4gdmFsdWVzWzBdKSB7XG4gICAgICAgIHRoaXMucmVzZXRUeXBlKHZhbHVlc1swXS5pY2FsdHlwZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmlzRGVjb3JhdGVkKSB7XG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICB0aGlzLl9zZXREZWNvcmF0ZWRWYWx1ZSh2YWx1ZXNbaV0sIGkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5qQ2FsW1ZBTFVFX0lOREVYICsgaV0gPSB2YWx1ZXNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgcHJvcGVydHkuIElmIHRoaXMgaXMgYSBtdWx0aS12YWx1ZVxuICAgICAqIHByb3BlcnR5LCBhbGwgb3RoZXIgdmFsdWVzIHdpbGwgYmUgcmVtb3ZlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gdmFsdWUgICAgIE5ldyBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgKi9cbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHRoaXMucmVtb3ZlQWxsVmFsdWVzKCk7XG4gICAgICBpZiAodHlwZW9mKHZhbHVlKSA9PT0gJ29iamVjdCcgJiYgJ2ljYWx0eXBlJyBpbiB2YWx1ZSkge1xuICAgICAgICB0aGlzLnJlc2V0VHlwZSh2YWx1ZS5pY2FsdHlwZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmlzRGVjb3JhdGVkKSB7XG4gICAgICAgIHRoaXMuX3NldERlY29yYXRlZFZhbHVlKHZhbHVlLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuakNhbFtWQUxVRV9JTkRFWF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgY29tcG9uZW50LiBUaGUgcmV0dXJuZWQgb2JqZWN0XG4gICAgICogaXMgYSBsaXZlIGpDYWwgb2JqZWN0IGFuZCBzaG91bGQgYmUgY2xvbmVkIGlmIG1vZGlmaWVkLlxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT046IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuakNhbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbXBvbmVudC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9JQ0FMU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBJQ0FMLnN0cmluZ2lmeS5wcm9wZXJ0eShcbiAgICAgICAgdGhpcy5qQ2FsLCB0aGlzLl9kZXNpZ25TZXQsIHRydWVcbiAgICAgICk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4ge0BsaW5rIElDQUwuUHJvcGVydHl9IGJ5IHBhcnNpbmcgdGhlIHBhc3NlZCBpQ2FsZW5kYXIgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGlDYWxlbmRhciBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXQ9fSBkZXNpZ25TZXQgIFRoZSBkZXNpZ24gZGF0YSB0byB1c2UgZm9yIHRoaXMgcHJvcGVydHlcbiAgICogQHJldHVybiB7SUNBTC5Qcm9wZXJ0eX0gICAgICAgICAgICAgICAgICAgIFRoZSBjcmVhdGVkIGlDYWxlbmRhciBwcm9wZXJ0eVxuICAgKi9cbiAgUHJvcGVydHkuZnJvbVN0cmluZyA9IGZ1bmN0aW9uKHN0ciwgZGVzaWduU2V0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9wZXJ0eShJQ0FMLnBhcnNlLnByb3BlcnR5KHN0ciwgZGVzaWduU2V0KSk7XG4gIH07XG5cbiAgcmV0dXJuIFByb3BlcnR5O1xufSgpKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAxMS0yMDE1ICovXG5cblxuLyoqXG4gKiBUaGlzIHN5bWJvbCBpcyBmdXJ0aGVyIGRlc2NyaWJlZCBsYXRlciBvblxuICogQGlnbm9yZVxuICovXG5JQ0FMLlV0Y09mZnNldCA9IChmdW5jdGlvbigpIHtcblxuICAvKipcbiAgICogQGNsYXNzZGVzY1xuICAgKiBUaGlzIGNsYXNzIHJlcHJlc2VudHMgdGhlIFwiZHVyYXRpb25cIiB2YWx1ZSB0eXBlLCB3aXRoIHZhcmlvdXMgY2FsY3VsYXRpb25cbiAgICogYW5kIG1hbmlwdWxhdGlvbiBtZXRob2RzLlxuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQGFsaWFzIElDQUwuVXRjT2Zmc2V0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhRGF0YSAgICAgICAgICBBbiBvYmplY3Qgd2l0aCBtZW1iZXJzIG9mIHRoZSB1dGMgb2Zmc2V0XG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEuaG91cnMgICBUaGUgaG91cnMgZm9yIHRoZSB1dGMgb2Zmc2V0XG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEubWludXRlcyBUaGUgbWludXRlcyBpbiB0aGUgdXRjIG9mZnNldFxuICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLmZhY3RvciAgVGhlIGZhY3RvciBmb3IgdGhlIHV0Yy1vZmZzZXQsIGVpdGhlciAtMSBvciAxXG4gICAqL1xuICBmdW5jdGlvbiBVdGNPZmZzZXQoYURhdGEpIHtcbiAgICB0aGlzLmZyb21EYXRhKGFEYXRhKTtcbiAgfVxuXG4gIFV0Y09mZnNldC5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaG91cnMgaW4gdGhlIHV0Yy1vZmZzZXRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIGhvdXJzOiAwLFxuXG4gICAgLyoqXG4gICAgICogVGhlIG1pbnV0ZXMgaW4gdGhlIHV0Yy1vZmZzZXRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIG1pbnV0ZXM6IDAsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2lnbiBvZiB0aGUgdXRjIG9mZnNldCwgMSBmb3IgcG9zaXRpdmUgb2Zmc2V0LCAtMSBmb3IgbmVnYXRpdmVcbiAgICAgKiBvZmZzZXRzLlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZmFjdG9yOiAxLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgbmFtZSwgdG8gYmUgdXNlZCBpbiB0aGUgakNhbCBvYmplY3QuXG4gICAgICogQGNvbnN0YW50XG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBcInV0Yy1vZmZzZXRcIlxuICAgICAqL1xuICAgIGljYWx0eXBlOiBcInV0Yy1vZmZzZXRcIixcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgdXRjIG9mZnNldCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlV0Y09mZnNldH0gICAgIFRoZSBjbG9uZWQgb2JqZWN0XG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIElDQUwuVXRjT2Zmc2V0LmZyb21TZWNvbmRzKHRoaXMudG9TZWNvbmRzKCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIHRoZSBjdXJyZW50IGluc3RhbmNlIHVzaW5nIG1lbWJlcnMgZnJvbSB0aGUgcGFzc2VkIGRhdGEgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFEYXRhICAgICAgICAgIEFuIG9iamVjdCB3aXRoIG1lbWJlcnMgb2YgdGhlIHV0YyBvZmZzZXRcbiAgICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLmhvdXJzICAgVGhlIGhvdXJzIGZvciB0aGUgdXRjIG9mZnNldFxuICAgICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEubWludXRlcyBUaGUgbWludXRlcyBpbiB0aGUgdXRjIG9mZnNldFxuICAgICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEuZmFjdG9yICBUaGUgZmFjdG9yIGZvciB0aGUgdXRjLW9mZnNldCwgZWl0aGVyIC0xIG9yIDFcbiAgICAgKi9cbiAgICBmcm9tRGF0YTogZnVuY3Rpb24oYURhdGEpIHtcbiAgICAgIGlmIChhRGF0YSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gYURhdGEpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgIGlmIChhRGF0YS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICB0aGlzW2tleV0gPSBhRGF0YVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fbm9ybWFsaXplKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdXAgdGhlIGN1cnJlbnQgaW5zdGFuY2UgZnJvbSB0aGUgZ2l2ZW4gc2Vjb25kcyB2YWx1ZS4gVGhlIHNlY29uZHNcbiAgICAgKiB2YWx1ZSBpcyB0cnVuY2F0ZWQgdG8gdGhlIG1pbnV0ZS4gT2Zmc2V0cyBhcmUgd3JhcHBlZCB3aGVuIHRoZSB3b3JsZFxuICAgICAqIGVuZHMsIHRoZSBob3VyIGFmdGVyIFVUQysxNDowMCBpcyBVVEMtMTI6MDAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYVNlY29uZHMgICAgICAgICBUaGUgc2Vjb25kcyB0byBjb252ZXJ0IGludG8gYW4gb2Zmc2V0XG4gICAgICovXG4gICAgZnJvbVNlY29uZHM6IGZ1bmN0aW9uKGFTZWNvbmRzKSB7XG4gICAgICB2YXIgc2VjcyA9IE1hdGguYWJzKGFTZWNvbmRzKTtcblxuICAgICAgdGhpcy5mYWN0b3IgPSBhU2Vjb25kcyA8IDAgPyAtMSA6IDE7XG4gICAgICB0aGlzLmhvdXJzID0gSUNBTC5oZWxwZXJzLnRydW5jKHNlY3MgLyAzNjAwKTtcblxuICAgICAgc2VjcyAtPSAodGhpcy5ob3VycyAqIDM2MDApO1xuICAgICAgdGhpcy5taW51dGVzID0gSUNBTC5oZWxwZXJzLnRydW5jKHNlY3MgLyA2MCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCB0aGUgY3VycmVudCBvZmZzZXQgdG8gYSB2YWx1ZSBpbiBzZWNvbmRzXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgICAgICBUaGUgb2Zmc2V0IGluIHNlY29uZHNcbiAgICAgKi9cbiAgICB0b1NlY29uZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmFjdG9yICogKDYwICogdGhpcy5taW51dGVzICsgMzYwMCAqIHRoaXMuaG91cnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb21wYXJlIHRoaXMgdXRjIG9mZnNldCB3aXRoIGFub3RoZXIgb25lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLlV0Y09mZnNldH0gb3RoZXIgICAgICAgIFRoZSBvdGhlciBvZmZzZXQgdG8gY29tcGFyZSB3aXRoXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgICAgICAgICAgIC0xLCAwIG9yIDEgZm9yIGxlc3MvZXF1YWwvZ3JlYXRlclxuICAgICAqL1xuICAgIGNvbXBhcmU6IGZ1bmN0aW9uIGljYWx0aW1lX2NvbXBhcmUob3RoZXIpIHtcbiAgICAgIHZhciBhID0gdGhpcy50b1NlY29uZHMoKTtcbiAgICAgIHZhciBiID0gb3RoZXIudG9TZWNvbmRzKCk7XG4gICAgICByZXR1cm4gKGEgPiBiKSAtIChiID4gYSk7XG4gICAgfSxcblxuICAgIF9ub3JtYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gUmFuZ2U6IDk3MjAwIHNlY29uZHMgKHdpdGggMSBob3VyIGluYmV0d2VlbilcbiAgICAgIHZhciBzZWNzID0gdGhpcy50b1NlY29uZHMoKTtcbiAgICAgIHZhciBmYWN0b3IgPSB0aGlzLmZhY3RvcjtcbiAgICAgIHdoaWxlIChzZWNzIDwgLTQzMjAwKSB7IC8vID0gVVRDLTEyOjAwXG4gICAgICAgIHNlY3MgKz0gOTcyMDA7XG4gICAgICB9XG4gICAgICB3aGlsZSAoc2VjcyA+IDUwNDAwKSB7IC8vID0gVVRDKzE0OjAwXG4gICAgICAgIHNlY3MgLT0gOTcyMDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZnJvbVNlY29uZHMoc2Vjcyk7XG5cbiAgICAgIC8vIEF2b2lkIGNoYW5naW5nIHRoZSBmYWN0b3Igd2hlbiBvbiB6ZXJvIHNlY29uZHNcbiAgICAgIGlmIChzZWNzID09IDApIHtcbiAgICAgICAgdGhpcy5mYWN0b3IgPSBmYWN0b3I7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBpQ2FsZW5kYXIgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdXRjLW9mZnNldC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9JQ0FMU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBJQ0FMLmRlc2lnbi5pY2FsZW5kYXIudmFsdWVbJ3V0Yy1vZmZzZXQnXS50b0lDQUwodGhpcy50b1N0cmluZygpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHV0Yy1vZmZzZXQuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiAodGhpcy5mYWN0b3IgPT0gMSA/IFwiK1wiIDogXCItXCIpICtcbiAgICAgICAgICAgICAgSUNBTC5oZWxwZXJzLnBhZDIodGhpcy5ob3VycykgKyAnOicgK1xuICAgICAgICAgICAgICBJQ0FMLmhlbHBlcnMucGFkMih0aGlzLm1pbnV0ZXMpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgSUNBTC5VdGNPZmZzZXR9IGluc3RhbmNlIGZyb20gdGhlIHBhc3NlZCBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhU3RyaW5nICAgIFRoZSBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHJldHVybiB7SUNBTC5EdXJhdGlvbn0gICAgVGhlIGNyZWF0ZWQgdXRjLW9mZnNldCBpbnN0YW5jZVxuICAgKi9cbiAgVXRjT2Zmc2V0LmZyb21TdHJpbmcgPSBmdW5jdGlvbihhU3RyaW5nKSB7XG4gICAgLy8gLTA1OjAwXG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICAvL1RPRE86IHN1cHBvcnQgc2Vjb25kcyBwZXIgcmZjNTU0NSA/XG4gICAgb3B0aW9ucy5mYWN0b3IgPSAoYVN0cmluZ1swXSA9PT0gJysnKSA/IDEgOiAtMTtcbiAgICBvcHRpb25zLmhvdXJzID0gSUNBTC5oZWxwZXJzLnN0cmljdFBhcnNlSW50KGFTdHJpbmcuc3Vic3RyKDEsIDIpKTtcbiAgICBvcHRpb25zLm1pbnV0ZXMgPSBJQ0FMLmhlbHBlcnMuc3RyaWN0UGFyc2VJbnQoYVN0cmluZy5zdWJzdHIoNCwgMikpO1xuXG4gICAgcmV0dXJuIG5ldyBJQ0FMLlV0Y09mZnNldChvcHRpb25zKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgSUNBTC5VdGNPZmZzZXR9IGluc3RhbmNlIGZyb20gdGhlIHBhc3NlZCBzZWNvbmRzXG4gICAqIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gYVNlY29uZHMgICAgICAgVGhlIG51bWJlciBvZiBzZWNvbmRzIHRvIGNvbnZlcnRcbiAgICovXG4gIFV0Y09mZnNldC5mcm9tU2Vjb25kcyA9IGZ1bmN0aW9uKGFTZWNvbmRzKSB7XG4gICAgdmFyIGluc3RhbmNlID0gbmV3IFV0Y09mZnNldCgpO1xuICAgIGluc3RhbmNlLmZyb21TZWNvbmRzKGFTZWNvbmRzKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG5cbiAgcmV0dXJuIFV0Y09mZnNldDtcbn0oKSk7XG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICogUG9ydGlvbnMgQ29weXJpZ2h0IChDKSBQaGlsaXBwIEtld2lzY2gsIDIwMTEtMjAxNSAqL1xuXG5cbi8qKlxuICogVGhpcyBzeW1ib2wgaXMgZnVydGhlciBkZXNjcmliZWQgbGF0ZXIgb25cbiAqIEBpZ25vcmVcbiAqL1xuSUNBTC5CaW5hcnkgPSAoZnVuY3Rpb24oKSB7XG5cbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogUmVwcmVzZW50cyB0aGUgQklOQVJZIHZhbHVlIHR5cGUsIHdoaWNoIGNvbnRhaW5zIGV4dHJhIG1ldGhvZHMgZm9yXG4gICAqIGVuY29kaW5nIGFuZCBkZWNvZGluZy5cbiAgICpcbiAgICogQGNsYXNzXG4gICAqIEBhbGlhcyBJQ0FMLkJpbmFyeVxuICAgKiBAcGFyYW0ge1N0cmluZ30gYVZhbHVlICAgICBUaGUgYmluYXJ5IGRhdGEgZm9yIHRoaXMgdmFsdWVcbiAgICovXG4gIGZ1bmN0aW9uIEJpbmFyeShhVmFsdWUpIHtcbiAgICB0aGlzLnZhbHVlID0gYVZhbHVlO1xuICB9XG5cbiAgQmluYXJ5LnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBuYW1lLCB0byBiZSB1c2VkIGluIHRoZSBqQ2FsIG9iamVjdC5cbiAgICAgKiBAZGVmYXVsdCBcImJpbmFyeVwiXG4gICAgICogQGNvbnN0YW50XG4gICAgICovXG4gICAgaWNhbHR5cGU6IFwiYmluYXJ5XCIsXG5cbiAgICAvKipcbiAgICAgKiBCYXNlNjQgZGVjb2RlIHRoZSBjdXJyZW50IHZhbHVlXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgVGhlIGJhc2U2NC1kZWNvZGVkIHZhbHVlXG4gICAgICovXG4gICAgZGVjb2RlVmFsdWU6IGZ1bmN0aW9uIGRlY29kZVZhbHVlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2I2NF9kZWNvZGUodGhpcy52YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgdGhlIHBhc3NlZCBwYXJhbWV0ZXIgd2l0aCBiYXNlNjQgYW5kIHNldHMgdGhlIGludGVybmFsXG4gICAgICogdmFsdWUgdG8gdGhlIHJlc3VsdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhVmFsdWUgICAgICBUaGUgcmF3IGJpbmFyeSB2YWx1ZSB0byBlbmNvZGVcbiAgICAgKi9cbiAgICBzZXRFbmNvZGVkVmFsdWU6IGZ1bmN0aW9uIHNldEVuY29kZWRWYWx1ZShhVmFsdWUpIHtcbiAgICAgIHRoaXMudmFsdWUgPSB0aGlzLl9iNjRfZW5jb2RlKGFWYWx1ZSk7XG4gICAgfSxcblxuICAgIF9iNjRfZW5jb2RlOiBmdW5jdGlvbiBiYXNlNjRfZW5jb2RlKGRhdGEpIHtcbiAgICAgIC8vIGh0dHA6Ly9rZXZpbi52YW56b25uZXZlbGQubmV0XG4gICAgICAvLyArICAgb3JpZ2luYWwgYnk6IFR5bGVyIEFraW5zIChodHRwOi8vcnVta2luLmNvbSlcbiAgICAgIC8vICsgICBpbXByb3ZlZCBieTogQmF5cm9uIEd1ZXZhcmFcbiAgICAgIC8vICsgICBpbXByb3ZlZCBieTogVGh1bmRlci5tXG4gICAgICAvLyArICAgaW1wcm92ZWQgYnk6IEtldmluIHZhbiBab25uZXZlbGQgKGh0dHA6Ly9rZXZpbi52YW56b25uZXZlbGQubmV0KVxuICAgICAgLy8gKyAgIGJ1Z2ZpeGVkIGJ5OiBQZWxsZW50ZXNxdWUgTWFsZXN1YWRhXG4gICAgICAvLyArICAgaW1wcm92ZWQgYnk6IEtldmluIHZhbiBab25uZXZlbGQgKGh0dHA6Ly9rZXZpbi52YW56b25uZXZlbGQubmV0KVxuICAgICAgLy8gKyAgIGltcHJvdmVkIGJ5OiBSYWZhXHUwMTQyIEt1a2F3c2tpIChodHRwOi8va3VrYXdza2kucGwpXG4gICAgICAvLyAqICAgICBleGFtcGxlIDE6IGJhc2U2NF9lbmNvZGUoJ0tldmluIHZhbiBab25uZXZlbGQnKTtcbiAgICAgIC8vICogICAgIHJldHVybnMgMTogJ1MyVjJhVzRnZG1GdUlGcHZibTVsZG1Wc1pBPT0nXG4gICAgICAvLyBtb3ppbGxhIGhhcyB0aGlzIG5hdGl2ZVxuICAgICAgLy8gLSBidXQgYnJlYWtzIGluIDIuMC4wLjEyIVxuICAgICAgLy9pZiAodHlwZW9mIHRoaXMud2luZG93WydhdG9iJ10gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gICAgcmV0dXJuIGF0b2IoZGF0YSk7XG4gICAgICAvL31cbiAgICAgIHZhciBiNjQgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXCIgK1xuICAgICAgICAgICAgICAgIFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCI7XG4gICAgICB2YXIgbzEsIG8yLCBvMywgaDEsIGgyLCBoMywgaDQsIGJpdHMsIGkgPSAwLFxuICAgICAgICBhYyA9IDAsXG4gICAgICAgIGVuYyA9IFwiXCIsXG4gICAgICAgIHRtcF9hcnIgPSBbXTtcblxuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuXG4gICAgICBkbyB7IC8vIHBhY2sgdGhyZWUgb2N0ZXRzIGludG8gZm91ciBoZXhldHNcbiAgICAgICAgbzEgPSBkYXRhLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgbzIgPSBkYXRhLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgbzMgPSBkYXRhLmNoYXJDb2RlQXQoaSsrKTtcblxuICAgICAgICBiaXRzID0gbzEgPDwgMTYgfCBvMiA8PCA4IHwgbzM7XG5cbiAgICAgICAgaDEgPSBiaXRzID4+IDE4ICYgMHgzZjtcbiAgICAgICAgaDIgPSBiaXRzID4+IDEyICYgMHgzZjtcbiAgICAgICAgaDMgPSBiaXRzID4+IDYgJiAweDNmO1xuICAgICAgICBoNCA9IGJpdHMgJiAweDNmO1xuXG4gICAgICAgIC8vIHVzZSBoZXhldHMgdG8gaW5kZXggaW50byBiNjQsIGFuZCBhcHBlbmQgcmVzdWx0IHRvIGVuY29kZWQgc3RyaW5nXG4gICAgICAgIHRtcF9hcnJbYWMrK10gPSBiNjQuY2hhckF0KGgxKSArIGI2NC5jaGFyQXQoaDIpICsgYjY0LmNoYXJBdChoMykgKyBiNjQuY2hhckF0KGg0KTtcbiAgICAgIH0gd2hpbGUgKGkgPCBkYXRhLmxlbmd0aCk7XG5cbiAgICAgIGVuYyA9IHRtcF9hcnIuam9pbignJyk7XG5cbiAgICAgIHZhciByID0gZGF0YS5sZW5ndGggJSAzO1xuXG4gICAgICByZXR1cm4gKHIgPyBlbmMuc2xpY2UoMCwgciAtIDMpIDogZW5jKSArICc9PT0nLnNsaWNlKHIgfHwgMyk7XG5cbiAgICB9LFxuXG4gICAgX2I2NF9kZWNvZGU6IGZ1bmN0aW9uIGJhc2U2NF9kZWNvZGUoZGF0YSkge1xuICAgICAgLy8gaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXRcbiAgICAgIC8vICsgICBvcmlnaW5hbCBieTogVHlsZXIgQWtpbnMgKGh0dHA6Ly9ydW1raW4uY29tKVxuICAgICAgLy8gKyAgIGltcHJvdmVkIGJ5OiBUaHVuZGVyLm1cbiAgICAgIC8vICsgICAgICBpbnB1dCBieTogQW1hbiBHdXB0YVxuICAgICAgLy8gKyAgIGltcHJvdmVkIGJ5OiBLZXZpbiB2YW4gWm9ubmV2ZWxkIChodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldClcbiAgICAgIC8vICsgICBidWdmaXhlZCBieTogT25ubyBNYXJzbWFuXG4gICAgICAvLyArICAgYnVnZml4ZWQgYnk6IFBlbGxlbnRlc3F1ZSBNYWxlc3VhZGFcbiAgICAgIC8vICsgICBpbXByb3ZlZCBieTogS2V2aW4gdmFuIFpvbm5ldmVsZCAoaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXQpXG4gICAgICAvLyArICAgICAgaW5wdXQgYnk6IEJyZXR0IFphbWlyIChodHRwOi8vYnJldHQtemFtaXIubWUpXG4gICAgICAvLyArICAgYnVnZml4ZWQgYnk6IEtldmluIHZhbiBab25uZXZlbGQgKGh0dHA6Ly9rZXZpbi52YW56b25uZXZlbGQubmV0KVxuICAgICAgLy8gKiAgICAgZXhhbXBsZSAxOiBiYXNlNjRfZGVjb2RlKCdTMlYyYVc0Z2RtRnVJRnB2Ym01bGRtVnNaQT09Jyk7XG4gICAgICAvLyAqICAgICByZXR1cm5zIDE6ICdLZXZpbiB2YW4gWm9ubmV2ZWxkJ1xuICAgICAgLy8gbW96aWxsYSBoYXMgdGhpcyBuYXRpdmVcbiAgICAgIC8vIC0gYnV0IGJyZWFrcyBpbiAyLjAuMC4xMiFcbiAgICAgIC8vaWYgKHR5cGVvZiB0aGlzLndpbmRvd1snYnRvYSddID09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vICAgIHJldHVybiBidG9hKGRhdGEpO1xuICAgICAgLy99XG4gICAgICB2YXIgYjY0ID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlwiICtcbiAgICAgICAgICAgICAgICBcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwiO1xuICAgICAgdmFyIG8xLCBvMiwgbzMsIGgxLCBoMiwgaDMsIGg0LCBiaXRzLCBpID0gMCxcbiAgICAgICAgYWMgPSAwLFxuICAgICAgICBkZWMgPSBcIlwiLFxuICAgICAgICB0bXBfYXJyID0gW107XG5cbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH1cblxuICAgICAgZGF0YSArPSAnJztcblxuICAgICAgZG8geyAvLyB1bnBhY2sgZm91ciBoZXhldHMgaW50byB0aHJlZSBvY3RldHMgdXNpbmcgaW5kZXggcG9pbnRzIGluIGI2NFxuICAgICAgICBoMSA9IGI2NC5pbmRleE9mKGRhdGEuY2hhckF0KGkrKykpO1xuICAgICAgICBoMiA9IGI2NC5pbmRleE9mKGRhdGEuY2hhckF0KGkrKykpO1xuICAgICAgICBoMyA9IGI2NC5pbmRleE9mKGRhdGEuY2hhckF0KGkrKykpO1xuICAgICAgICBoNCA9IGI2NC5pbmRleE9mKGRhdGEuY2hhckF0KGkrKykpO1xuXG4gICAgICAgIGJpdHMgPSBoMSA8PCAxOCB8IGgyIDw8IDEyIHwgaDMgPDwgNiB8IGg0O1xuXG4gICAgICAgIG8xID0gYml0cyA+PiAxNiAmIDB4ZmY7XG4gICAgICAgIG8yID0gYml0cyA+PiA4ICYgMHhmZjtcbiAgICAgICAgbzMgPSBiaXRzICYgMHhmZjtcblxuICAgICAgICBpZiAoaDMgPT0gNjQpIHtcbiAgICAgICAgICB0bXBfYXJyW2FjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZShvMSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaDQgPT0gNjQpIHtcbiAgICAgICAgICB0bXBfYXJyW2FjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZShvMSwgbzIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRtcF9hcnJbYWMrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG8xLCBvMiwgbzMpO1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlIChpIDwgZGF0YS5sZW5ndGgpO1xuXG4gICAgICBkZWMgPSB0bXBfYXJyLmpvaW4oJycpO1xuXG4gICAgICByZXR1cm4gZGVjO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgYmluYXJ5IHZhbHVlIGZyb20gdGhlIGdpdmVuIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFTdHJpbmcgICAgICAgIFRoZSBiaW5hcnkgdmFsdWUgc3RyaW5nXG4gICAqIEByZXR1cm4ge0lDQUwuQmluYXJ5fSAgICAgICAgICBUaGUgYmluYXJ5IHZhbHVlIGluc3RhbmNlXG4gICAqL1xuICBCaW5hcnkuZnJvbVN0cmluZyA9IGZ1bmN0aW9uKGFTdHJpbmcpIHtcbiAgICByZXR1cm4gbmV3IEJpbmFyeShhU3RyaW5nKTtcbiAgfTtcblxuICByZXR1cm4gQmluYXJ5O1xufSgpKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAxMS0yMDE1ICovXG5cblxuXG4oZnVuY3Rpb24oKSB7XG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIFRoaXMgY2xhc3MgcmVwcmVzZW50cyB0aGUgXCJwZXJpb2RcIiB2YWx1ZSB0eXBlLCB3aXRoIHZhcmlvdXMgY2FsY3VsYXRpb25cbiAgICogYW5kIG1hbmlwdWxhdGlvbiBtZXRob2RzLlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogVGhlIHBhc3NlZCBkYXRhIG9iamVjdCBjYW5ub3QgY29udGFpbiBib3RoIGFuZCBlbmQgZGF0ZSBhbmQgYSBkdXJhdGlvbi5cbiAgICpcbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhRGF0YSAgICAgICAgICAgICAgICAgIEFuIG9iamVjdCB3aXRoIG1lbWJlcnMgb2YgdGhlIHBlcmlvZFxuICAgKiBAcGFyYW0ge0lDQUwuVGltZT19IGFEYXRhLnN0YXJ0ICAgICAgICBUaGUgc3RhcnQgb2YgdGhlIHBlcmlvZFxuICAgKiBAcGFyYW0ge0lDQUwuVGltZT19IGFEYXRhLmVuZCAgICAgICAgICBUaGUgZW5kIG9mIHRoZSBwZXJpb2RcbiAgICogQHBhcmFtIHtJQ0FMLkR1cmF0aW9uPX0gYURhdGEuZHVyYXRpb24gVGhlIGR1cmF0aW9uIG9mIHRoZSBwZXJpb2RcbiAgICovXG4gIElDQUwuUGVyaW9kID0gZnVuY3Rpb24gaWNhbHBlcmlvZChhRGF0YSkge1xuICAgIHRoaXMud3JhcHBlZEpTT2JqZWN0ID0gdGhpcztcblxuICAgIGlmIChhRGF0YSAmJiAnc3RhcnQnIGluIGFEYXRhKSB7XG4gICAgICBpZiAoYURhdGEuc3RhcnQgJiYgIShhRGF0YS5zdGFydCBpbnN0YW5jZW9mIElDQUwuVGltZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignLnN0YXJ0IG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgSUNBTC5UaW1lJyk7XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXJ0ID0gYURhdGEuc3RhcnQ7XG4gICAgfVxuXG4gICAgaWYgKGFEYXRhICYmIGFEYXRhLmVuZCAmJiBhRGF0YS5kdXJhdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgYWNjZXB0IGJvdGggZW5kIGFuZCBkdXJhdGlvbicpO1xuICAgIH1cblxuICAgIGlmIChhRGF0YSAmJiAnZW5kJyBpbiBhRGF0YSkge1xuICAgICAgaWYgKGFEYXRhLmVuZCAmJiAhKGFEYXRhLmVuZCBpbnN0YW5jZW9mIElDQUwuVGltZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignLmVuZCBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIElDQUwuVGltZScpO1xuICAgICAgfVxuICAgICAgdGhpcy5lbmQgPSBhRGF0YS5lbmQ7XG4gICAgfVxuXG4gICAgaWYgKGFEYXRhICYmICdkdXJhdGlvbicgaW4gYURhdGEpIHtcbiAgICAgIGlmIChhRGF0YS5kdXJhdGlvbiAmJiAhKGFEYXRhLmR1cmF0aW9uIGluc3RhbmNlb2YgSUNBTC5EdXJhdGlvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignLmR1cmF0aW9uIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgSUNBTC5EdXJhdGlvbicpO1xuICAgICAgfVxuICAgICAgdGhpcy5kdXJhdGlvbiA9IGFEYXRhLmR1cmF0aW9uO1xuICAgIH1cbiAgfTtcblxuICBJQ0FMLlBlcmlvZC5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RhcnQgb2YgdGhlIHBlcmlvZFxuICAgICAqIEB0eXBlIHtJQ0FMLlRpbWV9XG4gICAgICovXG4gICAgc3RhcnQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZW5kIG9mIHRoZSBwZXJpb2RcbiAgICAgKiBAdHlwZSB7SUNBTC5UaW1lfVxuICAgICAqL1xuICAgIGVuZDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBkdXJhdGlvbiBvZiB0aGUgcGVyaW9kXG4gICAgICogQHR5cGUge0lDQUwuRHVyYXRpb259XG4gICAgICovXG4gICAgZHVyYXRpb246IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2xhc3MgaWRlbnRpZmllci5cbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IFwiaWNhbHBlcmlvZFwiXG4gICAgICovXG4gICAgaWNhbGNsYXNzOiBcImljYWxwZXJpb2RcIixcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG5hbWUsIHRvIGJlIHVzZWQgaW4gdGhlIGpDYWwgb2JqZWN0LlxuICAgICAqIEBjb25zdGFudFxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgXCJwZXJpb2RcIlxuICAgICAqL1xuICAgIGljYWx0eXBlOiBcInBlcmlvZFwiLFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBkdXJhdGlvbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlBlcmlvZH0gICAgICBUaGUgY2xvbmVkIG9iamVjdFxuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBJQ0FMLlBlcmlvZC5mcm9tRGF0YSh7XG4gICAgICAgIHN0YXJ0OiB0aGlzLnN0YXJ0ID8gdGhpcy5zdGFydC5jbG9uZSgpIDogbnVsbCxcbiAgICAgICAgZW5kOiB0aGlzLmVuZCA/IHRoaXMuZW5kLmNsb25lKCkgOiBudWxsLFxuICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbiA/IHRoaXMuZHVyYXRpb24uY2xvbmUoKSA6IG51bGxcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBkdXJhdGlvbiBvZiB0aGUgcGVyaW9kLCBlaXRoZXIgZGlyZWN0bHkgb3IgYnkgc3VidHJhY3RpbmdcbiAgICAgKiBzdGFydCBmcm9tIGVuZCBkYXRlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7SUNBTC5EdXJhdGlvbn0gICAgICBUaGUgY2FsY3VsYXRlZCBkdXJhdGlvblxuICAgICAqL1xuICAgIGdldER1cmF0aW9uOiBmdW5jdGlvbiBkdXJhdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmR1cmF0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmR1cmF0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kLnN1YnRyYWN0RGF0ZSh0aGlzLnN0YXJ0KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgZW5kIGRhdGUgb2YgdGhlIHBlcmlvZCwgZWl0aGVyIGRpcmVjdGx5IG9yIGJ5IGFkZGluZ1xuICAgICAqIGR1cmF0aW9uIHRvIHN0YXJ0IGRhdGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlRpbWV9ICAgICAgICAgIFRoZSBjYWxjdWxhdGVkIGVuZCBkYXRlXG4gICAgICovXG4gICAgZ2V0RW5kOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmVuZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5zdGFydC5jbG9uZSgpO1xuICAgICAgICBlbmQuYWRkRHVyYXRpb24odGhpcy5kdXJhdGlvbik7XG4gICAgICAgIHJldHVybiBlbmQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBwZXJpb2QuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YXJ0ICsgXCIvXCIgKyAodGhpcy5lbmQgfHwgdGhpcy5kdXJhdGlvbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBqQ2FsIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgcGVyaW9kIHR5cGUuXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gW3RoaXMuc3RhcnQudG9TdHJpbmcoKSwgKHRoaXMuZW5kIHx8IHRoaXMuZHVyYXRpb24pLnRvU3RyaW5nKCldO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgaUNhbGVuZGFyIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHBlcmlvZC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9JQ0FMU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YXJ0LnRvSUNBTFN0cmluZygpICsgXCIvXCIgK1xuICAgICAgICAgICAgICh0aGlzLmVuZCB8fCB0aGlzLmR1cmF0aW9uKS50b0lDQUxTdHJpbmcoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIElDQUwuUGVyaW9kfSBpbnN0YW5jZSBmcm9tIHRoZSBwYXNzZWQgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyICAgICAgICAgICAgVGhlIHN0cmluZyB0byBwYXJzZVxuICAgKiBAcGFyYW0ge0lDQUwuUHJvcGVydHl9IHByb3AgICAgVGhlIHByb3BlcnR5IHRoaXMgcGVyaW9kIHdpbGwgYmUgb25cbiAgICogQHJldHVybiB7SUNBTC5QZXJpb2R9ICAgICAgICAgIFRoZSBjcmVhdGVkIHBlcmlvZCBpbnN0YW5jZVxuICAgKi9cbiAgSUNBTC5QZXJpb2QuZnJvbVN0cmluZyA9IGZ1bmN0aW9uIGZyb21TdHJpbmcoc3RyLCBwcm9wKSB7XG4gICAgdmFyIHBhcnRzID0gc3RyLnNwbGl0KCcvJyk7XG5cbiAgICBpZiAocGFydHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJbnZhbGlkIHN0cmluZyB2YWx1ZTogXCInICsgc3RyICsgJ1wiIG11c3QgY29udGFpbiBhIFwiL1wiIGNoYXIuJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIHN0YXJ0OiBJQ0FMLlRpbWUuZnJvbURhdGVUaW1lU3RyaW5nKHBhcnRzWzBdLCBwcm9wKVxuICAgIH07XG5cbiAgICB2YXIgZW5kID0gcGFydHNbMV07XG5cbiAgICBpZiAoSUNBTC5EdXJhdGlvbi5pc1ZhbHVlU3RyaW5nKGVuZCkpIHtcbiAgICAgIG9wdGlvbnMuZHVyYXRpb24gPSBJQ0FMLkR1cmF0aW9uLmZyb21TdHJpbmcoZW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucy5lbmQgPSBJQ0FMLlRpbWUuZnJvbURhdGVUaW1lU3RyaW5nKGVuZCwgcHJvcCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBJQ0FMLlBlcmlvZChvcHRpb25zKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgSUNBTC5QZXJpb2R9IGluc3RhbmNlIGZyb20gdGhlIGdpdmVuIGRhdGEgb2JqZWN0LlxuICAgKiBUaGUgcGFzc2VkIGRhdGEgb2JqZWN0IGNhbm5vdCBjb250YWluIGJvdGggYW5kIGVuZCBkYXRlIGFuZCBhIGR1cmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYURhdGEgICAgICAgICAgICAgICAgICBBbiBvYmplY3Qgd2l0aCBtZW1iZXJzIG9mIHRoZSBwZXJpb2RcbiAgICogQHBhcmFtIHtJQ0FMLlRpbWU9fSBhRGF0YS5zdGFydCAgICAgICAgVGhlIHN0YXJ0IG9mIHRoZSBwZXJpb2RcbiAgICogQHBhcmFtIHtJQ0FMLlRpbWU9fSBhRGF0YS5lbmQgICAgICAgICAgVGhlIGVuZCBvZiB0aGUgcGVyaW9kXG4gICAqIEBwYXJhbSB7SUNBTC5EdXJhdGlvbj19IGFEYXRhLmR1cmF0aW9uIFRoZSBkdXJhdGlvbiBvZiB0aGUgcGVyaW9kXG4gICAqIEByZXR1cm4ge0lDQUwuUGVyaW9kfSAgICAgICAgICAgICAgICAgIFRoZSBwZXJpb2QgaW5zdGFuY2VcbiAgICovXG4gIElDQUwuUGVyaW9kLmZyb21EYXRhID0gZnVuY3Rpb24gZnJvbURhdGEoYURhdGEpIHtcbiAgICByZXR1cm4gbmV3IElDQUwuUGVyaW9kKGFEYXRhKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBwZXJpb2QgaW5zdGFuY2UgZnJvbSB0aGUgZ2l2ZW4gakNhbCBkYXRhIGFycmF5LiBUaGUgZmlyc3RcbiAgICogbWVtYmVyIGlzIGFsd2F5cyB0aGUgc3RhcnQgZGF0ZSBzdHJpbmcsIHRoZSBzZWNvbmQgbWVtYmVyIGlzIGVpdGhlciBhXG4gICAqIGR1cmF0aW9uIG9yIGVuZCBkYXRlIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxTdHJpbmcsU3RyaW5nPn0gYURhdGEgICAgVGhlIGpDYWwgZGF0YSBhcnJheVxuICAgKiBAcGFyYW0ge0lDQUwuUHJvcGVydHl9IGFQcm9wICAgICAgICAgICBUaGUgcHJvcGVydHkgdGhpcyBqQ2FsIGRhdGEgaXMgb25cbiAgICogQHBhcmFtIHtCb29sZWFufSBhTGVuaWVudCAgICAgICAgICAgICAgSWYgdHJ1ZSwgZGF0YSB2YWx1ZSBjYW4gYmUgYm90aCBkYXRlIGFuZCBkYXRlLXRpbWVcbiAgICogQHJldHVybiB7SUNBTC5QZXJpb2R9ICAgICAgICAgICAgICAgICAgVGhlIHBlcmlvZCBpbnN0YW5jZVxuICAgKi9cbiAgSUNBTC5QZXJpb2QuZnJvbUpTT04gPSBmdW5jdGlvbihhRGF0YSwgYVByb3AsIGFMZW5pZW50KSB7XG4gICAgZnVuY3Rpb24gZnJvbURhdGVPckRhdGVUaW1lU3RyaW5nKGFWYWx1ZSwgYVByb3ApIHtcbiAgICAgIGlmIChhTGVuaWVudCkge1xuICAgICAgICByZXR1cm4gSUNBTC5UaW1lLmZyb21TdHJpbmcoYVZhbHVlLCBhUHJvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gSUNBTC5UaW1lLmZyb21EYXRlVGltZVN0cmluZyhhVmFsdWUsIGFQcm9wKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoSUNBTC5EdXJhdGlvbi5pc1ZhbHVlU3RyaW5nKGFEYXRhWzFdKSkge1xuICAgICAgcmV0dXJuIElDQUwuUGVyaW9kLmZyb21EYXRhKHtcbiAgICAgICAgc3RhcnQ6IGZyb21EYXRlT3JEYXRlVGltZVN0cmluZyhhRGF0YVswXSwgYVByb3ApLFxuICAgICAgICBkdXJhdGlvbjogSUNBTC5EdXJhdGlvbi5mcm9tU3RyaW5nKGFEYXRhWzFdKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBJQ0FMLlBlcmlvZC5mcm9tRGF0YSh7XG4gICAgICAgIHN0YXJ0OiBmcm9tRGF0ZU9yRGF0ZVRpbWVTdHJpbmcoYURhdGFbMF0sIGFQcm9wKSxcbiAgICAgICAgZW5kOiBmcm9tRGF0ZU9yRGF0ZVRpbWVTdHJpbmcoYURhdGFbMV0sIGFQcm9wKVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufSkoKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAxMS0yMDE1ICovXG5cblxuXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBEVVJBVElPTl9MRVRURVJTID0gLyhbUERXSE1UU117MSwxfSkvO1xuXG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIFRoaXMgY2xhc3MgcmVwcmVzZW50cyB0aGUgXCJkdXJhdGlvblwiIHZhbHVlIHR5cGUsIHdpdGggdmFyaW91cyBjYWxjdWxhdGlvblxuICAgKiBhbmQgbWFuaXB1bGF0aW9uIG1ldGhvZHMuXG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAYWxpYXMgSUNBTC5EdXJhdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAgICAgICAgICAgICAgIEFuIG9iamVjdCB3aXRoIG1lbWJlcnMgb2YgdGhlIGR1cmF0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLndlZWtzICAgICAgICAgRHVyYXRpb24gaW4gd2Vla3NcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEuZGF5cyAgICAgICAgICBEdXJhdGlvbiBpbiBkYXlzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLmhvdXJzICAgICAgICAgRHVyYXRpb24gaW4gaG91cnNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEubWludXRlcyAgICAgICBEdXJhdGlvbiBpbiBtaW51dGVzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLnNlY29uZHMgICAgICAgRHVyYXRpb24gaW4gc2Vjb25kc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRhdGEuaXNOZWdhdGl2ZSAgIElmIHRydWUsIHRoZSBkdXJhdGlvbiBpcyBuZWdhdGl2ZVxuICAgKi9cbiAgSUNBTC5EdXJhdGlvbiA9IGZ1bmN0aW9uIGljYWxkdXJhdGlvbihkYXRhKSB7XG4gICAgdGhpcy53cmFwcGVkSlNPYmplY3QgPSB0aGlzO1xuICAgIHRoaXMuZnJvbURhdGEoZGF0YSk7XG4gIH07XG5cbiAgSUNBTC5EdXJhdGlvbi5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogVGhlIHdlZWtzIGluIHRoaXMgZHVyYXRpb25cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB3ZWVrczogMCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBkYXlzIGluIHRoaXMgZHVyYXRpb25cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICBkYXlzOiAwLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGRheXMgaW4gdGhpcyBkdXJhdGlvblxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIGhvdXJzOiAwLFxuXG4gICAgLyoqXG4gICAgICogVGhlIG1pbnV0ZXMgaW4gdGhpcyBkdXJhdGlvblxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIG1pbnV0ZXM6IDAsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2Vjb25kcyBpbiB0aGlzIGR1cmF0aW9uXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgc2Vjb25kczogMCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzZWNvbmRzIGluIHRoaXMgZHVyYXRpb25cbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIGlzTmVnYXRpdmU6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGNsYXNzIGlkZW50aWZpZXIuXG4gICAgICogQGNvbnN0YW50XG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBcImljYWxkdXJhdGlvblwiXG4gICAgICovXG4gICAgaWNhbGNsYXNzOiBcImljYWxkdXJhdGlvblwiLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgbmFtZSwgdG8gYmUgdXNlZCBpbiB0aGUgakNhbCBvYmplY3QuXG4gICAgICogQGNvbnN0YW50XG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBcImR1cmF0aW9uXCJcbiAgICAgKi9cbiAgICBpY2FsdHlwZTogXCJkdXJhdGlvblwiLFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBkdXJhdGlvbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLkR1cmF0aW9ufSAgICAgIFRoZSBjbG9uZWQgb2JqZWN0XG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgcmV0dXJuIElDQUwuRHVyYXRpb24uZnJvbURhdGEodGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBkdXJhdGlvbiB2YWx1ZSBleHByZXNzZWQgYXMgYSBudW1iZXIgb2Ygc2Vjb25kcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgVGhlIGR1cmF0aW9uIHZhbHVlIGluIHNlY29uZHNcbiAgICAgKi9cbiAgICB0b1NlY29uZHM6IGZ1bmN0aW9uIHRvU2Vjb25kcygpIHtcbiAgICAgIHZhciBzZWNvbmRzID0gdGhpcy5zZWNvbmRzICsgNjAgKiB0aGlzLm1pbnV0ZXMgKyAzNjAwICogdGhpcy5ob3VycyArXG4gICAgICAgICAgICAgICAgICAgIDg2NDAwICogdGhpcy5kYXlzICsgNyAqIDg2NDAwICogdGhpcy53ZWVrcztcbiAgICAgIHJldHVybiAodGhpcy5pc05lZ2F0aXZlID8gLXNlY29uZHMgOiBzZWNvbmRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVhZHMgdGhlIHBhc3NlZCBzZWNvbmRzIHZhbHVlIGludG8gdGhpcyBkdXJhdGlvbiBvYmplY3QuIEFmdGVyd2FyZHMsXG4gICAgICogbWVtYmVycyBsaWtlIHtAbGluayBJQ0FMLkR1cmF0aW9uI2RheXMgZGF5c30gYW5kIHtAbGluayBJQ0FMLkR1cmF0aW9uI3dlZWtzIHdlZWtzfSB3aWxsIGJlIHNldCB1cFxuICAgICAqIGFjY29yZGluZ2x5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFTZWNvbmRzICAgICBUaGUgZHVyYXRpb24gdmFsdWUgaW4gc2Vjb25kc1xuICAgICAqIEByZXR1cm4ge0lDQUwuRHVyYXRpb259ICAgICAgUmV0dXJucyB0aGlzIGluc3RhbmNlXG4gICAgICovXG4gICAgZnJvbVNlY29uZHM6IGZ1bmN0aW9uIGZyb21TZWNvbmRzKGFTZWNvbmRzKSB7XG4gICAgICB2YXIgc2VjcyA9IE1hdGguYWJzKGFTZWNvbmRzKTtcblxuICAgICAgdGhpcy5pc05lZ2F0aXZlID0gKGFTZWNvbmRzIDwgMCk7XG4gICAgICB0aGlzLmRheXMgPSBJQ0FMLmhlbHBlcnMudHJ1bmMoc2VjcyAvIDg2NDAwKTtcblxuICAgICAgLy8gSWYgd2UgaGF2ZSBhIGZsYXQgbnVtYmVyIG9mIHdlZWtzLCB1c2UgdGhlbS5cbiAgICAgIGlmICh0aGlzLmRheXMgJSA3ID09IDApIHtcbiAgICAgICAgdGhpcy53ZWVrcyA9IHRoaXMuZGF5cyAvIDc7XG4gICAgICAgIHRoaXMuZGF5cyA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLndlZWtzID0gMDtcbiAgICAgIH1cblxuICAgICAgc2VjcyAtPSAodGhpcy5kYXlzICsgNyAqIHRoaXMud2Vla3MpICogODY0MDA7XG5cbiAgICAgIHRoaXMuaG91cnMgPSBJQ0FMLmhlbHBlcnMudHJ1bmMoc2VjcyAvIDM2MDApO1xuICAgICAgc2VjcyAtPSB0aGlzLmhvdXJzICogMzYwMDtcblxuICAgICAgdGhpcy5taW51dGVzID0gSUNBTC5oZWxwZXJzLnRydW5jKHNlY3MgLyA2MCk7XG4gICAgICBzZWNzIC09IHRoaXMubWludXRlcyAqIDYwO1xuXG4gICAgICB0aGlzLnNlY29uZHMgPSBzZWNzO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdXAgdGhlIGN1cnJlbnQgaW5zdGFuY2UgdXNpbmcgbWVtYmVycyBmcm9tIHRoZSBwYXNzZWQgZGF0YSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYURhdGEgICAgICAgICAgICAgICBBbiBvYmplY3Qgd2l0aCBtZW1iZXJzIG9mIHRoZSBkdXJhdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhRGF0YS53ZWVrcyAgICAgICAgIER1cmF0aW9uIGluIHdlZWtzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXRhLmRheXMgICAgICAgICAgRHVyYXRpb24gaW4gZGF5c1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhRGF0YS5ob3VycyAgICAgICAgIER1cmF0aW9uIGluIGhvdXJzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXRhLm1pbnV0ZXMgICAgICAgRHVyYXRpb24gaW4gbWludXRlc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhRGF0YS5zZWNvbmRzICAgICAgIER1cmF0aW9uIGluIHNlY29uZHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFEYXRhLmlzTmVnYXRpdmUgICBJZiB0cnVlLCB0aGUgZHVyYXRpb24gaXMgbmVnYXRpdmVcbiAgICAgKi9cbiAgICBmcm9tRGF0YTogZnVuY3Rpb24gZnJvbURhdGEoYURhdGEpIHtcbiAgICAgIHZhciBwcm9wc1RvQ29weSA9IFtcIndlZWtzXCIsIFwiZGF5c1wiLCBcImhvdXJzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgXCJtaW51dGVzXCIsIFwic2Vjb25kc1wiLCBcImlzTmVnYXRpdmVcIl07XG4gICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHNUb0NvcHkpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghcHJvcHNUb0NvcHkuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9wID0gcHJvcHNUb0NvcHlba2V5XTtcbiAgICAgICAgaWYgKGFEYXRhICYmIHByb3AgaW4gYURhdGEpIHtcbiAgICAgICAgICB0aGlzW3Byb3BdID0gYURhdGFbcHJvcF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpc1twcm9wXSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBkdXJhdGlvbiBpbnN0YW5jZSB0byB0aGUgZGVmYXVsdCB2YWx1ZXMsIGkuZS4gUFQwU1xuICAgICAqL1xuICAgIHJlc2V0OiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIHRoaXMuaXNOZWdhdGl2ZSA9IGZhbHNlO1xuICAgICAgdGhpcy53ZWVrcyA9IDA7XG4gICAgICB0aGlzLmRheXMgPSAwO1xuICAgICAgdGhpcy5ob3VycyA9IDA7XG4gICAgICB0aGlzLm1pbnV0ZXMgPSAwO1xuICAgICAgdGhpcy5zZWNvbmRzID0gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29tcGFyZXMgdGhlIGR1cmF0aW9uIGluc3RhbmNlIHdpdGggYW5vdGhlciBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuRHVyYXRpb259IGFPdGhlciAgICAgICAgVGhlIGluc3RhbmNlIHRvIGNvbXBhcmUgd2l0aFxuICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgICAgICAgICAtMSwgMCBvciAxIGZvciBsZXNzL2VxdWFsL2dyZWF0ZXJcbiAgICAgKi9cbiAgICBjb21wYXJlOiBmdW5jdGlvbiBjb21wYXJlKGFPdGhlcikge1xuICAgICAgdmFyIHRoaXNTZWNvbmRzID0gdGhpcy50b1NlY29uZHMoKTtcbiAgICAgIHZhciBvdGhlclNlY29uZHMgPSBhT3RoZXIudG9TZWNvbmRzKCk7XG4gICAgICByZXR1cm4gKHRoaXNTZWNvbmRzID4gb3RoZXJTZWNvbmRzKSAtICh0aGlzU2Vjb25kcyA8IG90aGVyU2Vjb25kcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZXMgdGhlIGR1cmF0aW9uIGluc3RhbmNlLiBGb3IgZXhhbXBsZSwgYSBkdXJhdGlvbiB3aXRoIGEgdmFsdWVcbiAgICAgKiBvZiA2MSBzZWNvbmRzIHdpbGwgYmUgbm9ybWFsaXplZCB0byAxIG1pbnV0ZSBhbmQgMSBzZWNvbmQuXG4gICAgICovXG4gICAgbm9ybWFsaXplOiBmdW5jdGlvbiBub3JtYWxpemUoKSB7XG4gICAgICB0aGlzLmZyb21TZWNvbmRzKHRoaXMudG9TZWNvbmRzKCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZHVyYXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIGlmICh0aGlzLnRvU2Vjb25kcygpID09IDApIHtcbiAgICAgICAgcmV0dXJuIFwiUFQwU1wiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHN0ciA9IFwiXCI7XG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUpIHN0ciArPSBcIi1cIjtcbiAgICAgICAgc3RyICs9IFwiUFwiO1xuICAgICAgICBpZiAodGhpcy53ZWVrcykgc3RyICs9IHRoaXMud2Vla3MgKyBcIldcIjtcbiAgICAgICAgaWYgKHRoaXMuZGF5cykgc3RyICs9IHRoaXMuZGF5cyArIFwiRFwiO1xuXG4gICAgICAgIGlmICh0aGlzLmhvdXJzIHx8IHRoaXMubWludXRlcyB8fCB0aGlzLnNlY29uZHMpIHtcbiAgICAgICAgICBzdHIgKz0gXCJUXCI7XG4gICAgICAgICAgaWYgKHRoaXMuaG91cnMpIHN0ciArPSB0aGlzLmhvdXJzICsgXCJIXCI7XG4gICAgICAgICAgaWYgKHRoaXMubWludXRlcykgc3RyICs9IHRoaXMubWludXRlcyArIFwiTVwiO1xuICAgICAgICAgIGlmICh0aGlzLnNlY29uZHMpIHN0ciArPSB0aGlzLnNlY29uZHMgKyBcIlNcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgaUNhbGVuZGFyIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGR1cmF0aW9uLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICB0b0lDQUxTdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgSUNBTC5EdXJhdGlvbiBpbnN0YW5jZSBmcm9tIHRoZSBwYXNzZWQgc2Vjb25kcyB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFTZWNvbmRzICAgICAgIFRoZSBzZWNvbmRzIHRvIGNyZWF0ZSB0aGUgaW5zdGFuY2UgZnJvbVxuICAgKiBAcmV0dXJuIHtJQ0FMLkR1cmF0aW9ufSAgICAgICAgVGhlIG5ld2x5IGNyZWF0ZWQgZHVyYXRpb24gaW5zdGFuY2VcbiAgICovXG4gIElDQUwuRHVyYXRpb24uZnJvbVNlY29uZHMgPSBmdW5jdGlvbiBpY2FsZHVyYXRpb25fZnJvbV9zZWNvbmRzKGFTZWNvbmRzKSB7XG4gICAgcmV0dXJuIChuZXcgSUNBTC5EdXJhdGlvbigpKS5mcm9tU2Vjb25kcyhhU2Vjb25kcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEludGVybmFsIGhlbHBlciBmdW5jdGlvbiB0byBoYW5kbGUgYSBjaHVuayBvZiBhIGR1cmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbGV0dGVyIHR5cGUgb2YgZHVyYXRpb24gY2h1bmtcbiAgICogQHBhcmFtIHtTdHJpbmd9IG51bWJlciBudW1lcmljIHZhbHVlIG9yIC0vK1xuICAgKiBAcGFyYW0ge09iamVjdH0gZGljdCB0YXJnZXQgdG8gYXNzaWduIHZhbHVlcyB0b1xuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VEdXJhdGlvbkNodW5rKGxldHRlciwgbnVtYmVyLCBvYmplY3QpIHtcbiAgICB2YXIgdHlwZTtcbiAgICBzd2l0Y2ggKGxldHRlcikge1xuICAgICAgY2FzZSAnUCc6XG4gICAgICAgIGlmIChudW1iZXIgJiYgbnVtYmVyID09PSAnLScpIHtcbiAgICAgICAgICBvYmplY3QuaXNOZWdhdGl2ZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2JqZWN0LmlzTmVnYXRpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwZXJpb2RcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdEJzpcbiAgICAgICAgdHlwZSA9ICdkYXlzJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdXJzpcbiAgICAgICAgdHlwZSA9ICd3ZWVrcyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnSCc6XG4gICAgICAgIHR5cGUgPSAnaG91cnMnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ00nOlxuICAgICAgICB0eXBlID0gJ21pbnV0ZXMnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1MnOlxuICAgICAgICB0eXBlID0gJ3NlY29uZHMnO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIE5vdCBhIHZhbGlkIGNodW5rXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmICh0eXBlKSB7XG4gICAgICBpZiAoIW51bWJlciAmJiBudW1iZXIgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdpbnZhbGlkIGR1cmF0aW9uIHZhbHVlOiBNaXNzaW5nIG51bWJlciBiZWZvcmUgXCInICsgbGV0dGVyICsgJ1wiJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdmFyIG51bSA9IHBhcnNlSW50KG51bWJlciwgMTApO1xuICAgICAgaWYgKElDQUwuaGVscGVycy5pc1N0cmljdGx5TmFOKG51bSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdpbnZhbGlkIGR1cmF0aW9uIHZhbHVlOiBJbnZhbGlkIG51bWJlciBcIicgKyBudW1iZXIgKyAnXCIgYmVmb3JlIFwiJyArIGxldHRlciArICdcIidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIG9iamVjdFt0eXBlXSA9IG51bTtcbiAgICB9XG5cbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIHN0cmluZyBpcyBhbiBpQ2FsZW5kYXIgZHVyYXRpb24gdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSAgICAgIFRoZSByYXcgaWNhbCB2YWx1ZVxuICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICBUcnVlLCBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgb2YgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gaWNhbCB0eXBlXG4gICAqL1xuICBJQ0FMLkR1cmF0aW9uLmlzVmFsdWVTdHJpbmcgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICByZXR1cm4gKHN0cmluZ1swXSA9PT0gJ1AnIHx8IHN0cmluZ1sxXSA9PT0gJ1AnKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgSUNBTC5EdXJhdGlvbn0gaW5zdGFuY2UgZnJvbSB0aGUgcGFzc2VkIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFTdHIgICAgICAgVGhlIHN0cmluZyB0byBwYXJzZVxuICAgKiBAcmV0dXJuIHtJQ0FMLkR1cmF0aW9ufSAgICBUaGUgY3JlYXRlZCBkdXJhdGlvbiBpbnN0YW5jZVxuICAgKi9cbiAgSUNBTC5EdXJhdGlvbi5mcm9tU3RyaW5nID0gZnVuY3Rpb24gaWNhbGR1cmF0aW9uX2Zyb21fc3RyaW5nKGFTdHIpIHtcbiAgICB2YXIgcG9zID0gMDtcbiAgICB2YXIgZGljdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIGNodW5rcyA9IDA7XG5cbiAgICB3aGlsZSAoKHBvcyA9IGFTdHIuc2VhcmNoKERVUkFUSU9OX0xFVFRFUlMpKSAhPT0gLTEpIHtcbiAgICAgIHZhciB0eXBlID0gYVN0cltwb3NdO1xuICAgICAgdmFyIG51bWVyaWMgPSBhU3RyLnN1YnN0cigwLCBwb3MpO1xuICAgICAgYVN0ciA9IGFTdHIuc3Vic3RyKHBvcyArIDEpO1xuXG4gICAgICBjaHVua3MgKz0gcGFyc2VEdXJhdGlvbkNodW5rKHR5cGUsIG51bWVyaWMsIGRpY3QpO1xuICAgIH1cblxuICAgIGlmIChjaHVua3MgPCAyKSB7XG4gICAgICAvLyBUaGVyZSBtdXN0IGJlIGF0IGxlYXN0IGEgY2h1bmsgd2l0aCBcIlBcIiBhbmQgc29tZSB1bml0IGNodW5rXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdpbnZhbGlkIGR1cmF0aW9uIHZhbHVlOiBOb3QgZW5vdWdoIGR1cmF0aW9uIGNvbXBvbmVudHMgaW4gXCInICsgYVN0ciArICdcIidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBJQ0FMLkR1cmF0aW9uKGRpY3QpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IElDQUwuRHVyYXRpb24gaW5zdGFuY2UgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhRGF0YSAgICAgICAgICAgICAgIEFuIG9iamVjdCB3aXRoIG1lbWJlcnMgb2YgdGhlIGR1cmF0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhRGF0YS53ZWVrcyAgICAgICAgIER1cmF0aW9uIGluIHdlZWtzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhRGF0YS5kYXlzICAgICAgICAgIER1cmF0aW9uIGluIGRheXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXRhLmhvdXJzICAgICAgICAgRHVyYXRpb24gaW4gaG91cnNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXRhLm1pbnV0ZXMgICAgICAgRHVyYXRpb24gaW4gbWludXRlc1xuICAgKiBAcGFyYW0ge051bWJlcn0gYURhdGEuc2Vjb25kcyAgICAgICBEdXJhdGlvbiBpbiBzZWNvbmRzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYURhdGEuaXNOZWdhdGl2ZSAgIElmIHRydWUsIHRoZSBkdXJhdGlvbiBpcyBuZWdhdGl2ZVxuICAgKiBAcmV0dXJuIHtJQ0FMLkR1cmF0aW9ufSAgICAgICAgICAgICBUaGUgY3JlYXRlYWQgZHVyYXRpb24gaW5zdGFuY2VcbiAgICovXG4gIElDQUwuRHVyYXRpb24uZnJvbURhdGEgPSBmdW5jdGlvbiBpY2FsZHVyYXRpb25fZnJvbV9kYXRhKGFEYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBJQ0FMLkR1cmF0aW9uKGFEYXRhKTtcbiAgfTtcbn0pKCk7XG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICogUG9ydGlvbnMgQ29weXJpZ2h0IChDKSBQaGlsaXBwIEtld2lzY2gsIDIwMTEtMjAxMiAqL1xuXG5cblxuKGZ1bmN0aW9uKCkge1xuICB2YXIgT1BUSU9OUyA9IFtcInR6aWRcIiwgXCJsb2NhdGlvblwiLCBcInR6bmFtZXNcIixcbiAgICAgICAgICAgICAgICAgXCJsYXRpdHVkZVwiLCBcImxvbmdpdHVkZVwiXTtcblxuICAvKipcbiAgICogQGNsYXNzZGVzY1xuICAgKiBUaW1lem9uZSByZXByZXNlbnRhdGlvbiwgY3JlYXRlZCBieSBwYXNzaW5nIGluIGEgdHppZCBhbmQgY29tcG9uZW50LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgdmNhbGVuZGFyO1xuICAgKiB2YXIgdGltZXpvbmVDb21wID0gdmNhbGVuZGFyLmdldEZpcnN0U3ViY29tcG9uZW50KCd2dGltZXpvbmUnKTtcbiAgICogdmFyIHR6aWQgPSB0aW1lem9uZUNvbXAuZ2V0Rmlyc3RQcm9wZXJ0eVZhbHVlKCd0emlkJyk7XG4gICAqXG4gICAqIHZhciB0aW1lem9uZSA9IG5ldyBJQ0FMLlRpbWV6b25lKHtcbiAgICogICBjb21wb25lbnQ6IHRpbWV6b25lQ29tcCxcbiAgICogICB0emlkXG4gICAqIH0pO1xuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHtJQ0FMLkNvbXBvbmVudHxPYmplY3R9IGRhdGEgb3B0aW9ucyBmb3IgY2xhc3NcbiAgICogQHBhcmFtIHtTdHJpbmd8SUNBTC5Db21wb25lbnR9IGRhdGEuY29tcG9uZW50XG4gICAqICAgICAgICBJZiBkYXRhIGlzIGEgc2ltcGxlIG9iamVjdCwgdGhlbiB0aGlzIG1lbWJlciBjYW4gYmUgc2V0IHRvIGVpdGhlciBhXG4gICAqICAgICAgICBzdHJpbmcgY29udGFpbmluZyB0aGUgY29tcG9uZW50IGRhdGEsIG9yIGFuIGFscmVhZHkgcGFyc2VkXG4gICAqICAgICAgICBJQ0FMLkNvbXBvbmVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS50emlkICAgICAgVGhlIHRpbWV6b25lIGlkZW50aWZpZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEubG9jYXRpb24gIFRoZSB0aW1lem9uZSBsb2NhdGlvbndcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEudHpuYW1lcyAgIEFuIGFsdGVybmF0aXZlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXpvbmVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEubGF0aXR1ZGUgIFRoZSBsYXRpdHVkZSBvZiB0aGUgdGltZXpvbmVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEubG9uZ2l0dWRlIFRoZSBsb25naXR1ZGUgb2YgdGhlIHRpbWV6b25lXG4gICAqL1xuICBJQ0FMLlRpbWV6b25lID0gZnVuY3Rpb24gaWNhbHRpbWV6b25lKGRhdGEpIHtcbiAgICB0aGlzLndyYXBwZWRKU09iamVjdCA9IHRoaXM7XG4gICAgdGhpcy5mcm9tRGF0YShkYXRhKTtcbiAgfTtcblxuICBJQ0FMLlRpbWV6b25lLnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIFRpbWV6b25lIGlkZW50aWZpZXJcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIHR6aWQ6IFwiXCIsXG5cbiAgICAvKipcbiAgICAgKiBUaW1lem9uZSBsb2NhdGlvblxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgbG9jYXRpb246IFwiXCIsXG5cbiAgICAvKipcbiAgICAgKiBBbHRlcm5hdGl2ZSB0aW1lem9uZSBuYW1lLCBmb3IgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgdHpuYW1lczogXCJcIixcblxuICAgIC8qKlxuICAgICAqIFRoZSBwcmltYXJ5IGxhdGl0dWRlIGZvciB0aGUgdGltZXpvbmUuXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBsYXRpdHVkZTogMC4wLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHByaW1hcnkgbG9uZ2l0dWRlIGZvciB0aGUgdGltZXpvbmUuXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBsb25naXR1ZGU6IDAuMCxcblxuICAgIC8qKlxuICAgICAqIFRoZSB2dGltZXpvbmUgY29tcG9uZW50IGZvciB0aGlzIHRpbWV6b25lLlxuICAgICAqIEB0eXBlIHtJQ0FMLkNvbXBvbmVudH1cbiAgICAgKi9cbiAgICBjb21wb25lbnQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgeWVhciB0aGlzIHRpbWV6b25lIGhhcyBiZWVuIGV4cGFuZGVkIHRvLiBBbGwgdGltZXpvbmUgdHJhbnNpdGlvblxuICAgICAqIGRhdGVzIHVudGlsIHRoaXMgeWVhciBhcmUga25vd24gYW5kIGNhbiBiZSB1c2VkIGZvciBjYWxjdWxhdGlvblxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIGV4cGFuZGVkVW50aWxZZWFyOiAwLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGNsYXNzIGlkZW50aWZpZXIuXG4gICAgICogQGNvbnN0YW50XG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBcImljYWx0aW1lem9uZVwiXG4gICAgICovXG4gICAgaWNhbGNsYXNzOiBcImljYWx0aW1lem9uZVwiLFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB1cCB0aGUgY3VycmVudCBpbnN0YW5jZSB1c2luZyBtZW1iZXJzIGZyb20gdGhlIHBhc3NlZCBkYXRhIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SUNBTC5Db21wb25lbnR8T2JqZWN0fSBhRGF0YSBvcHRpb25zIGZvciBjbGFzc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfElDQUwuQ29tcG9uZW50fSBhRGF0YS5jb21wb25lbnRcbiAgICAgKiAgICAgICAgSWYgYURhdGEgaXMgYSBzaW1wbGUgb2JqZWN0LCB0aGVuIHRoaXMgbWVtYmVyIGNhbiBiZSBzZXQgdG8gZWl0aGVyIGFcbiAgICAgKiAgICAgICAgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIGNvbXBvbmVudCBkYXRhLCBvciBhbiBhbHJlYWR5IHBhcnNlZFxuICAgICAqICAgICAgICBJQ0FMLkNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhRGF0YS50emlkICAgICAgVGhlIHRpbWV6b25lIGlkZW50aWZpZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYURhdGEubG9jYXRpb24gIFRoZSB0aW1lem9uZSBsb2NhdGlvbndcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYURhdGEudHpuYW1lcyAgIEFuIGFsdGVybmF0aXZlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lem9uZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhRGF0YS5sYXRpdHVkZSAgVGhlIGxhdGl0dWRlIG9mIHRoZSB0aW1lem9uZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhRGF0YS5sb25naXR1ZGUgVGhlIGxvbmdpdHVkZSBvZiB0aGUgdGltZXpvbmVcbiAgICAgKi9cbiAgICBmcm9tRGF0YTogZnVuY3Rpb24gZnJvbURhdGEoYURhdGEpIHtcbiAgICAgIHRoaXMuZXhwYW5kZWRVbnRpbFllYXIgPSAwO1xuICAgICAgdGhpcy5jaGFuZ2VzID0gW107XG5cbiAgICAgIGlmIChhRGF0YSBpbnN0YW5jZW9mIElDQUwuQ29tcG9uZW50KSB7XG4gICAgICAgIC8vIEVpdGhlciBhIGNvbXBvbmVudCBpcyBwYXNzZWQgZGlyZWN0bHlcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBhRGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSB0aGUgY29tcG9uZW50IG1heSBiZSBpbiB0aGUgZGF0YSBvYmplY3RcbiAgICAgICAgaWYgKGFEYXRhICYmIFwiY29tcG9uZW50XCIgaW4gYURhdGEpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGFEYXRhLmNvbXBvbmVudCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBhIHN0cmluZyB3YXMgcGFzc2VkLCBwYXJzZSBpdCBhcyBhIGNvbXBvbmVudFxuICAgICAgICAgICAgdmFyIGpDYWwgPSBJQ0FMLnBhcnNlKGFEYXRhLmNvbXBvbmVudCk7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudCA9IG5ldyBJQ0FMLkNvbXBvbmVudChqQ2FsKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGFEYXRhLmNvbXBvbmVudCBpbnN0YW5jZW9mIElDQUwuQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAvLyBJZiBpdCB3YXMgYSBjb21wb25lbnQgYWxyZWFkeSwgdGhlbiBqdXN0IHNldCBpdFxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQgPSBhRGF0YS5jb21wb25lbnQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBqdXN0IG51bGwgb3V0IHRoZSBjb21wb25lbnRcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb3B5IHJlbWFpbmluZyBwYXNzZWQgcHJvcGVydGllc1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gT1BUSU9OUykge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgaWYgKE9QVElPTlMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgdmFyIHByb3AgPSBPUFRJT05TW2tleV07XG4gICAgICAgICAgICBpZiAoYURhdGEgJiYgcHJvcCBpbiBhRGF0YSkge1xuICAgICAgICAgICAgICB0aGlzW3Byb3BdID0gYURhdGFbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHdlIGhhdmUgYSBjb21wb25lbnQgYnV0IG5vIFRaSUQsIGF0dGVtcHQgdG8gZ2V0IGl0IGZyb20gdGhlXG4gICAgICAvLyBjb21wb25lbnQncyBwcm9wZXJ0aWVzLlxuICAgICAgaWYgKHRoaXMuY29tcG9uZW50IGluc3RhbmNlb2YgSUNBTC5Db21wb25lbnQgJiYgIXRoaXMudHppZCkge1xuICAgICAgICB0aGlzLnR6aWQgPSB0aGlzLmNvbXBvbmVudC5nZXRGaXJzdFByb3BlcnR5VmFsdWUoJ3R6aWQnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSB1dGNPZmZzZXQgdGhlIGdpdmVuIHRpbWUgd291bGQgb2NjdXIgaW4gdGhpcyB0aW1lem9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SUNBTC5UaW1lfSB0dCAgICAgICAgVGhlIHRpbWUgdG8gY2hlY2sgZm9yXG4gICAgICogQHJldHVybiB7TnVtYmVyfSB1dGMgb2Zmc2V0IGluIHNlY29uZHNcbiAgICAgKi9cbiAgICB1dGNPZmZzZXQ6IGZ1bmN0aW9uIHV0Y09mZnNldCh0dCkge1xuICAgICAgaWYgKHRoaXMgPT0gSUNBTC5UaW1lem9uZS51dGNUaW1lem9uZSB8fCB0aGlzID09IElDQUwuVGltZXpvbmUubG9jYWxUaW1lem9uZSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZW5zdXJlQ292ZXJhZ2UodHQueWVhcik7XG5cbiAgICAgIGlmICghdGhpcy5jaGFuZ2VzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIHR0X2NoYW5nZSA9IHtcbiAgICAgICAgeWVhcjogdHQueWVhcixcbiAgICAgICAgbW9udGg6IHR0Lm1vbnRoLFxuICAgICAgICBkYXk6IHR0LmRheSxcbiAgICAgICAgaG91cjogdHQuaG91cixcbiAgICAgICAgbWludXRlOiB0dC5taW51dGUsXG4gICAgICAgIHNlY29uZDogdHQuc2Vjb25kXG4gICAgICB9O1xuXG4gICAgICB2YXIgY2hhbmdlX251bSA9IHRoaXMuX2ZpbmROZWFyYnlDaGFuZ2UodHRfY2hhbmdlKTtcbiAgICAgIHZhciBjaGFuZ2VfbnVtX3RvX3VzZSA9IC0xO1xuICAgICAgdmFyIHN0ZXAgPSAxO1xuXG4gICAgICAvLyBUT0RPOiByZXBsYWNlIHdpdGggYmluIHNlYXJjaD9cbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgdmFyIGNoYW5nZSA9IElDQUwuaGVscGVycy5jbG9uZSh0aGlzLmNoYW5nZXNbY2hhbmdlX251bV0sIHRydWUpO1xuICAgICAgICBpZiAoY2hhbmdlLnV0Y09mZnNldCA8IGNoYW5nZS5wcmV2VXRjT2Zmc2V0KSB7XG4gICAgICAgICAgSUNBTC5UaW1lem9uZS5hZGp1c3RfY2hhbmdlKGNoYW5nZSwgMCwgMCwgMCwgY2hhbmdlLnV0Y09mZnNldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgSUNBTC5UaW1lem9uZS5hZGp1c3RfY2hhbmdlKGNoYW5nZSwgMCwgMCwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZS5wcmV2VXRjT2Zmc2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjbXAgPSBJQ0FMLlRpbWV6b25lLl9jb21wYXJlX2NoYW5nZV9mbih0dF9jaGFuZ2UsIGNoYW5nZSk7XG5cbiAgICAgICAgaWYgKGNtcCA+PSAwKSB7XG4gICAgICAgICAgY2hhbmdlX251bV90b191c2UgPSBjaGFuZ2VfbnVtO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ZXAgPSAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGVwID09IC0xICYmIGNoYW5nZV9udW1fdG9fdXNlICE9IC0xKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBjaGFuZ2VfbnVtICs9IHN0ZXA7XG5cbiAgICAgICAgaWYgKGNoYW5nZV9udW0gPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hhbmdlX251bSA+PSB0aGlzLmNoYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHpvbmVfY2hhbmdlID0gdGhpcy5jaGFuZ2VzW2NoYW5nZV9udW1fdG9fdXNlXTtcbiAgICAgIHZhciB1dGNPZmZzZXRfY2hhbmdlID0gem9uZV9jaGFuZ2UudXRjT2Zmc2V0IC0gem9uZV9jaGFuZ2UucHJldlV0Y09mZnNldDtcblxuICAgICAgaWYgKHV0Y09mZnNldF9jaGFuZ2UgPCAwICYmIGNoYW5nZV9udW1fdG9fdXNlID4gMCkge1xuICAgICAgICB2YXIgdG1wX2NoYW5nZSA9IElDQUwuaGVscGVycy5jbG9uZSh6b25lX2NoYW5nZSwgdHJ1ZSk7XG4gICAgICAgIElDQUwuVGltZXpvbmUuYWRqdXN0X2NoYW5nZSh0bXBfY2hhbmdlLCAwLCAwLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcF9jaGFuZ2UucHJldlV0Y09mZnNldCk7XG5cbiAgICAgICAgaWYgKElDQUwuVGltZXpvbmUuX2NvbXBhcmVfY2hhbmdlX2ZuKHR0X2NoYW5nZSwgdG1wX2NoYW5nZSkgPCAwKSB7XG4gICAgICAgICAgdmFyIHByZXZfem9uZV9jaGFuZ2UgPSB0aGlzLmNoYW5nZXNbY2hhbmdlX251bV90b191c2UgLSAxXTtcblxuICAgICAgICAgIHZhciB3YW50X2RheWxpZ2h0ID0gZmFsc2U7IC8vIFRPRE9cblxuICAgICAgICAgIGlmICh6b25lX2NoYW5nZS5pc19kYXlsaWdodCAhPSB3YW50X2RheWxpZ2h0ICYmXG4gICAgICAgICAgICAgIHByZXZfem9uZV9jaGFuZ2UuaXNfZGF5bGlnaHQgPT0gd2FudF9kYXlsaWdodCkge1xuICAgICAgICAgICAgem9uZV9jaGFuZ2UgPSBwcmV2X3pvbmVfY2hhbmdlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUT0RPIHJldHVybiBpc19kYXlsaWdodD9cbiAgICAgIHJldHVybiB6b25lX2NoYW5nZS51dGNPZmZzZXQ7XG4gICAgfSxcblxuICAgIF9maW5kTmVhcmJ5Q2hhbmdlOiBmdW5jdGlvbiBpY2FsdGltZXpvbmVfZmluZF9uZWFyYnlfY2hhbmdlKGNoYW5nZSkge1xuICAgICAgLy8gZmluZCB0aGUgY2xvc2VzdCBtYXRjaFxuICAgICAgdmFyIGlkeCA9IElDQUwuaGVscGVycy5iaW5zZWFyY2hJbnNlcnQoXG4gICAgICAgIHRoaXMuY2hhbmdlcyxcbiAgICAgICAgY2hhbmdlLFxuICAgICAgICBJQ0FMLlRpbWV6b25lLl9jb21wYXJlX2NoYW5nZV9mblxuICAgICAgKTtcblxuICAgICAgaWYgKGlkeCA+PSB0aGlzLmNoYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5nZXMubGVuZ3RoIC0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGlkeDtcbiAgICB9LFxuXG4gICAgX2Vuc3VyZUNvdmVyYWdlOiBmdW5jdGlvbihhWWVhcikge1xuICAgICAgaWYgKElDQUwuVGltZXpvbmUuX21pbmltdW1FeHBhbnNpb25ZZWFyID09IC0xKSB7XG4gICAgICAgIHZhciB0b2RheSA9IElDQUwuVGltZS5ub3coKTtcbiAgICAgICAgSUNBTC5UaW1lem9uZS5fbWluaW11bUV4cGFuc2lvblllYXIgPSB0b2RheS55ZWFyO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2hhbmdlc0VuZFllYXIgPSBhWWVhcjtcbiAgICAgIGlmIChjaGFuZ2VzRW5kWWVhciA8IElDQUwuVGltZXpvbmUuX21pbmltdW1FeHBhbnNpb25ZZWFyKSB7XG4gICAgICAgIGNoYW5nZXNFbmRZZWFyID0gSUNBTC5UaW1lem9uZS5fbWluaW11bUV4cGFuc2lvblllYXI7XG4gICAgICB9XG5cbiAgICAgIGNoYW5nZXNFbmRZZWFyICs9IElDQUwuVGltZXpvbmUuRVhUUkFfQ09WRVJBR0U7XG5cbiAgICAgIGlmIChjaGFuZ2VzRW5kWWVhciA+IElDQUwuVGltZXpvbmUuTUFYX1lFQVIpIHtcbiAgICAgICAgY2hhbmdlc0VuZFllYXIgPSBJQ0FMLlRpbWV6b25lLk1BWF9ZRUFSO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuY2hhbmdlcy5sZW5ndGggfHwgdGhpcy5leHBhbmRlZFVudGlsWWVhciA8IGFZZWFyKSB7XG4gICAgICAgIHZhciBzdWJjb21wcyA9IHRoaXMuY29tcG9uZW50LmdldEFsbFN1YmNvbXBvbmVudHMoKTtcbiAgICAgICAgdmFyIGNvbXBMZW4gPSBzdWJjb21wcy5sZW5ndGg7XG4gICAgICAgIHZhciBjb21wSWR4ID0gMDtcblxuICAgICAgICBmb3IgKDsgY29tcElkeCA8IGNvbXBMZW47IGNvbXBJZHgrKykge1xuICAgICAgICAgIHRoaXMuX2V4cGFuZENvbXBvbmVudChcbiAgICAgICAgICAgIHN1YmNvbXBzW2NvbXBJZHhdLCBjaGFuZ2VzRW5kWWVhciwgdGhpcy5jaGFuZ2VzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2hhbmdlcy5zb3J0KElDQUwuVGltZXpvbmUuX2NvbXBhcmVfY2hhbmdlX2ZuKTtcbiAgICAgICAgdGhpcy5leHBhbmRlZFVudGlsWWVhciA9IGNoYW5nZXNFbmRZZWFyO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfZXhwYW5kQ29tcG9uZW50OiBmdW5jdGlvbihhQ29tcG9uZW50LCBhWWVhciwgY2hhbmdlcykge1xuICAgICAgaWYgKCFhQ29tcG9uZW50Lmhhc1Byb3BlcnR5KFwiZHRzdGFydFwiKSB8fFxuICAgICAgICAgICFhQ29tcG9uZW50Lmhhc1Byb3BlcnR5KFwidHpvZmZzZXR0b1wiKSB8fFxuICAgICAgICAgICFhQ29tcG9uZW50Lmhhc1Byb3BlcnR5KFwidHpvZmZzZXRmcm9tXCIpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgZHRzdGFydCA9IGFDb21wb25lbnQuZ2V0Rmlyc3RQcm9wZXJ0eShcImR0c3RhcnRcIikuZ2V0Rmlyc3RWYWx1ZSgpO1xuICAgICAgdmFyIGNoYW5nZTtcblxuICAgICAgZnVuY3Rpb24gY29udmVydF90em9mZnNldChvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG9mZnNldC5mYWN0b3IgKiAob2Zmc2V0LmhvdXJzICogMzYwMCArIG9mZnNldC5taW51dGVzICogNjApO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpbml0X2NoYW5nZXMoKSB7XG4gICAgICAgIHZhciBjaGFuZ2ViYXNlID0ge307XG4gICAgICAgIGNoYW5nZWJhc2UuaXNfZGF5bGlnaHQgPSAoYUNvbXBvbmVudC5uYW1lID09IFwiZGF5bGlnaHRcIik7XG4gICAgICAgIGNoYW5nZWJhc2UudXRjT2Zmc2V0ID0gY29udmVydF90em9mZnNldChcbiAgICAgICAgICBhQ29tcG9uZW50LmdldEZpcnN0UHJvcGVydHkoXCJ0em9mZnNldHRvXCIpLmdldEZpcnN0VmFsdWUoKVxuICAgICAgICApO1xuXG4gICAgICAgIGNoYW5nZWJhc2UucHJldlV0Y09mZnNldCA9IGNvbnZlcnRfdHpvZmZzZXQoXG4gICAgICAgICAgYUNvbXBvbmVudC5nZXRGaXJzdFByb3BlcnR5KFwidHpvZmZzZXRmcm9tXCIpLmdldEZpcnN0VmFsdWUoKVxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBjaGFuZ2ViYXNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWFDb21wb25lbnQuaGFzUHJvcGVydHkoXCJycnVsZVwiKSAmJiAhYUNvbXBvbmVudC5oYXNQcm9wZXJ0eShcInJkYXRlXCIpKSB7XG4gICAgICAgIGNoYW5nZSA9IGluaXRfY2hhbmdlcygpO1xuICAgICAgICBjaGFuZ2UueWVhciA9IGR0c3RhcnQueWVhcjtcbiAgICAgICAgY2hhbmdlLm1vbnRoID0gZHRzdGFydC5tb250aDtcbiAgICAgICAgY2hhbmdlLmRheSA9IGR0c3RhcnQuZGF5O1xuICAgICAgICBjaGFuZ2UuaG91ciA9IGR0c3RhcnQuaG91cjtcbiAgICAgICAgY2hhbmdlLm1pbnV0ZSA9IGR0c3RhcnQubWludXRlO1xuICAgICAgICBjaGFuZ2Uuc2Vjb25kID0gZHRzdGFydC5zZWNvbmQ7XG5cbiAgICAgICAgSUNBTC5UaW1lem9uZS5hZGp1c3RfY2hhbmdlKGNoYW5nZSwgMCwgMCwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtY2hhbmdlLnByZXZVdGNPZmZzZXQpO1xuICAgICAgICBjaGFuZ2VzLnB1c2goY2hhbmdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwcm9wcyA9IGFDb21wb25lbnQuZ2V0QWxsUHJvcGVydGllcyhcInJkYXRlXCIpO1xuICAgICAgICBmb3IgKHZhciByZGF0ZWtleSBpbiBwcm9wcykge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmICghcHJvcHMuaGFzT3duUHJvcGVydHkocmRhdGVrZXkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJkYXRlID0gcHJvcHNbcmRhdGVrZXldO1xuICAgICAgICAgIHZhciB0aW1lID0gcmRhdGUuZ2V0Rmlyc3RWYWx1ZSgpO1xuICAgICAgICAgIGNoYW5nZSA9IGluaXRfY2hhbmdlcygpO1xuXG4gICAgICAgICAgY2hhbmdlLnllYXIgPSB0aW1lLnllYXI7XG4gICAgICAgICAgY2hhbmdlLm1vbnRoID0gdGltZS5tb250aDtcbiAgICAgICAgICBjaGFuZ2UuZGF5ID0gdGltZS5kYXk7XG5cbiAgICAgICAgICBpZiAodGltZS5pc0RhdGUpIHtcbiAgICAgICAgICAgIGNoYW5nZS5ob3VyID0gZHRzdGFydC5ob3VyO1xuICAgICAgICAgICAgY2hhbmdlLm1pbnV0ZSA9IGR0c3RhcnQubWludXRlO1xuICAgICAgICAgICAgY2hhbmdlLnNlY29uZCA9IGR0c3RhcnQuc2Vjb25kO1xuXG4gICAgICAgICAgICBpZiAoZHRzdGFydC56b25lICE9IElDQUwuVGltZXpvbmUudXRjVGltZXpvbmUpIHtcbiAgICAgICAgICAgICAgSUNBTC5UaW1lem9uZS5hZGp1c3RfY2hhbmdlKGNoYW5nZSwgMCwgMCwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtY2hhbmdlLnByZXZVdGNPZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGFuZ2UuaG91ciA9IHRpbWUuaG91cjtcbiAgICAgICAgICAgIGNoYW5nZS5taW51dGUgPSB0aW1lLm1pbnV0ZTtcbiAgICAgICAgICAgIGNoYW5nZS5zZWNvbmQgPSB0aW1lLnNlY29uZDtcblxuICAgICAgICAgICAgaWYgKHRpbWUuem9uZSAhPSBJQ0FMLlRpbWV6b25lLnV0Y1RpbWV6b25lKSB7XG4gICAgICAgICAgICAgIElDQUwuVGltZXpvbmUuYWRqdXN0X2NoYW5nZShjaGFuZ2UsIDAsIDAsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLWNoYW5nZS5wcmV2VXRjT2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjaGFuZ2VzLnB1c2goY2hhbmdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBycnVsZSA9IGFDb21wb25lbnQuZ2V0Rmlyc3RQcm9wZXJ0eShcInJydWxlXCIpO1xuXG4gICAgICAgIGlmIChycnVsZSkge1xuICAgICAgICAgIHJydWxlID0gcnJ1bGUuZ2V0Rmlyc3RWYWx1ZSgpO1xuICAgICAgICAgIGNoYW5nZSA9IGluaXRfY2hhbmdlcygpO1xuXG4gICAgICAgICAgaWYgKHJydWxlLnVudGlsICYmIHJydWxlLnVudGlsLnpvbmUgPT0gSUNBTC5UaW1lem9uZS51dGNUaW1lem9uZSkge1xuICAgICAgICAgICAgcnJ1bGUudW50aWwuYWRqdXN0KDAsIDAsIDAsIGNoYW5nZS5wcmV2VXRjT2Zmc2V0KTtcbiAgICAgICAgICAgIHJydWxlLnVudGlsLnpvbmUgPSBJQ0FMLlRpbWV6b25lLmxvY2FsVGltZXpvbmU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gcnJ1bGUuaXRlcmF0b3IoZHRzdGFydCk7XG5cbiAgICAgICAgICB2YXIgb2NjO1xuICAgICAgICAgIHdoaWxlICgob2NjID0gaXRlcmF0b3IubmV4dCgpKSkge1xuICAgICAgICAgICAgY2hhbmdlID0gaW5pdF9jaGFuZ2VzKCk7XG4gICAgICAgICAgICBpZiAob2NjLnllYXIgPiBhWWVhciB8fCAhb2NjKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaGFuZ2UueWVhciA9IG9jYy55ZWFyO1xuICAgICAgICAgICAgY2hhbmdlLm1vbnRoID0gb2NjLm1vbnRoO1xuICAgICAgICAgICAgY2hhbmdlLmRheSA9IG9jYy5kYXk7XG4gICAgICAgICAgICBjaGFuZ2UuaG91ciA9IG9jYy5ob3VyO1xuICAgICAgICAgICAgY2hhbmdlLm1pbnV0ZSA9IG9jYy5taW51dGU7XG4gICAgICAgICAgICBjaGFuZ2Uuc2Vjb25kID0gb2NjLnNlY29uZDtcbiAgICAgICAgICAgIGNoYW5nZS5pc0RhdGUgPSBvY2MuaXNEYXRlO1xuXG4gICAgICAgICAgICBJQ0FMLlRpbWV6b25lLmFkanVzdF9jaGFuZ2UoY2hhbmdlLCAwLCAwLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtY2hhbmdlLnByZXZVdGNPZmZzZXQpO1xuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKGNoYW5nZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaGFuZ2VzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdGltZXpvbmUuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiAodGhpcy50em5hbWVzID8gdGhpcy50em5hbWVzIDogdGhpcy50emlkKTtcbiAgICB9XG4gIH07XG5cbiAgSUNBTC5UaW1lem9uZS5fY29tcGFyZV9jaGFuZ2VfZm4gPSBmdW5jdGlvbiBpY2FsdGltZXpvbmVfY29tcGFyZV9jaGFuZ2VfZm4oYSwgYikge1xuICAgIGlmIChhLnllYXIgPCBiLnllYXIpIHJldHVybiAtMTtcbiAgICBlbHNlIGlmIChhLnllYXIgPiBiLnllYXIpIHJldHVybiAxO1xuXG4gICAgaWYgKGEubW9udGggPCBiLm1vbnRoKSByZXR1cm4gLTE7XG4gICAgZWxzZSBpZiAoYS5tb250aCA+IGIubW9udGgpIHJldHVybiAxO1xuXG4gICAgaWYgKGEuZGF5IDwgYi5kYXkpIHJldHVybiAtMTtcbiAgICBlbHNlIGlmIChhLmRheSA+IGIuZGF5KSByZXR1cm4gMTtcblxuICAgIGlmIChhLmhvdXIgPCBiLmhvdXIpIHJldHVybiAtMTtcbiAgICBlbHNlIGlmIChhLmhvdXIgPiBiLmhvdXIpIHJldHVybiAxO1xuXG4gICAgaWYgKGEubWludXRlIDwgYi5taW51dGUpIHJldHVybiAtMTtcbiAgICBlbHNlIGlmIChhLm1pbnV0ZSA+IGIubWludXRlKSByZXR1cm4gMTtcblxuICAgIGlmIChhLnNlY29uZCA8IGIuc2Vjb25kKSByZXR1cm4gLTE7XG4gICAgZWxzZSBpZiAoYS5zZWNvbmQgPiBiLnNlY29uZCkgcmV0dXJuIDE7XG5cbiAgICByZXR1cm4gMDtcbiAgfTtcblxuICAvKipcbiAgICogQ29udmVydCB0aGUgZGF0ZS90aW1lIGZyb20gb25lIHpvbmUgdG8gdGhlIG5leHQuXG4gICAqXG4gICAqIEBwYXJhbSB7SUNBTC5UaW1lfSB0dCAgICAgICAgICAgICAgICAgIFRoZSB0aW1lIHRvIGNvbnZlcnRcbiAgICogQHBhcmFtIHtJQ0FMLlRpbWV6b25lfSBmcm9tX3pvbmUgICAgICAgVGhlIHNvdXJjZSB6b25lIHRvIGNvbnZlcnQgZnJvbVxuICAgKiBAcGFyYW0ge0lDQUwuVGltZXpvbmV9IHRvX3pvbmUgICAgICAgICBUaGUgdGFyZ2V0IHpvbmUgdG8gY29udmVydCB0b1xuICAgKiBAcmV0dXJuIHtJQ0FMLlRpbWV9ICAgICAgICAgICAgICAgICAgICBUaGUgY29udmVydGVkIGRhdGUvdGltZSBvYmplY3RcbiAgICovXG4gIElDQUwuVGltZXpvbmUuY29udmVydF90aW1lID0gZnVuY3Rpb24gaWNhbHRpbWV6b25lX2NvbnZlcnRfdGltZSh0dCwgZnJvbV96b25lLCB0b196b25lKSB7XG4gICAgaWYgKHR0LmlzRGF0ZSB8fFxuICAgICAgICBmcm9tX3pvbmUudHppZCA9PSB0b196b25lLnR6aWQgfHxcbiAgICAgICAgZnJvbV96b25lID09IElDQUwuVGltZXpvbmUubG9jYWxUaW1lem9uZSB8fFxuICAgICAgICB0b196b25lID09IElDQUwuVGltZXpvbmUubG9jYWxUaW1lem9uZSkge1xuICAgICAgdHQuem9uZSA9IHRvX3pvbmU7XG4gICAgICByZXR1cm4gdHQ7XG4gICAgfVxuXG4gICAgdmFyIHV0Y09mZnNldCA9IGZyb21fem9uZS51dGNPZmZzZXQodHQpO1xuICAgIHR0LmFkanVzdCgwLCAwLCAwLCAtIHV0Y09mZnNldCk7XG5cbiAgICB1dGNPZmZzZXQgPSB0b196b25lLnV0Y09mZnNldCh0dCk7XG4gICAgdHQuYWRqdXN0KDAsIDAsIDAsIHV0Y09mZnNldCk7XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBJQ0FMLlRpbWV6b25lIGluc3RhbmNlIGZyb20gdGhlIHBhc3NlZCBkYXRhIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtJQ0FMLkNvbXBvbmVudHxPYmplY3R9IGFEYXRhIG9wdGlvbnMgZm9yIGNsYXNzXG4gICAqIEBwYXJhbSB7U3RyaW5nfElDQUwuQ29tcG9uZW50fSBhRGF0YS5jb21wb25lbnRcbiAgICogICAgICAgIElmIGFEYXRhIGlzIGEgc2ltcGxlIG9iamVjdCwgdGhlbiB0aGlzIG1lbWJlciBjYW4gYmUgc2V0IHRvIGVpdGhlciBhXG4gICAqICAgICAgICBzdHJpbmcgY29udGFpbmluZyB0aGUgY29tcG9uZW50IGRhdGEsIG9yIGFuIGFscmVhZHkgcGFyc2VkXG4gICAqICAgICAgICBJQ0FMLkNvbXBvbmVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gYURhdGEudHppZCAgICAgIFRoZSB0aW1lem9uZSBpZGVudGlmaWVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhRGF0YS5sb2NhdGlvbiAgVGhlIHRpbWV6b25lIGxvY2F0aW9ud1xuICAgKiBAcGFyYW0ge1N0cmluZ30gYURhdGEudHpuYW1lcyAgIEFuIGFsdGVybmF0aXZlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXpvbmVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXRhLmxhdGl0dWRlICBUaGUgbGF0aXR1ZGUgb2YgdGhlIHRpbWV6b25lXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhRGF0YS5sb25naXR1ZGUgVGhlIGxvbmdpdHVkZSBvZiB0aGUgdGltZXpvbmVcbiAgICovXG4gIElDQUwuVGltZXpvbmUuZnJvbURhdGEgPSBmdW5jdGlvbiBpY2FsdGltZXpvbmVfZnJvbURhdGEoYURhdGEpIHtcbiAgICB2YXIgdHQgPSBuZXcgSUNBTC5UaW1lem9uZSgpO1xuICAgIHJldHVybiB0dC5mcm9tRGF0YShhRGF0YSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoZSBpbnN0YW5jZSBkZXNjcmliaW5nIHRoZSBVVEMgdGltZXpvbmVcbiAgICogQHR5cGUge0lDQUwuVGltZXpvbmV9XG4gICAqIEBjb25zdGFudFxuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIElDQUwuVGltZXpvbmUudXRjVGltZXpvbmUgPSBJQ0FMLlRpbWV6b25lLmZyb21EYXRhKHtcbiAgICB0emlkOiBcIlVUQ1wiXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBUaGUgaW5zdGFuY2UgZGVzY3JpYmluZyB0aGUgbG9jYWwgdGltZXpvbmVcbiAgICogQHR5cGUge0lDQUwuVGltZXpvbmV9XG4gICAqIEBjb25zdGFudFxuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIElDQUwuVGltZXpvbmUubG9jYWxUaW1lem9uZSA9IElDQUwuVGltZXpvbmUuZnJvbURhdGEoe1xuICAgIHR6aWQ6IFwiZmxvYXRpbmdcIlxuICB9KTtcblxuICAvKipcbiAgICogQWRqdXN0IGEgdGltZXpvbmUgY2hhbmdlIG9iamVjdC5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGNoYW5nZSAgICAgVGhlIHRpbWV6b25lIGNoYW5nZSBvYmplY3RcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRheXMgICAgICAgVGhlIGV4dHJhIGFtb3VudCBvZiBkYXlzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBob3VycyAgICAgIFRoZSBleHRyYSBhbW91bnQgb2YgaG91cnNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1pbnV0ZXMgICAgVGhlIGV4dHJhIGFtb3VudCBvZiBtaW51dGVzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzZWNvbmRzICAgIFRoZSBleHRyYSBhbW91bnQgb2Ygc2Vjb25kc1xuICAgKi9cbiAgSUNBTC5UaW1lem9uZS5hZGp1c3RfY2hhbmdlID0gZnVuY3Rpb24gaWNhbHRpbWV6b25lX2FkanVzdF9jaGFuZ2UoY2hhbmdlLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcykge1xuICAgIHJldHVybiBJQ0FMLlRpbWUucHJvdG90eXBlLmFkanVzdC5jYWxsKFxuICAgICAgY2hhbmdlLFxuICAgICAgZGF5cyxcbiAgICAgIGhvdXJzLFxuICAgICAgbWludXRlcyxcbiAgICAgIHNlY29uZHMsXG4gICAgICBjaGFuZ2VcbiAgICApO1xuICB9O1xuXG4gIElDQUwuVGltZXpvbmUuX21pbmltdW1FeHBhbnNpb25ZZWFyID0gLTE7XG4gIElDQUwuVGltZXpvbmUuTUFYX1lFQVIgPSAyMDM1OyAvLyBUT0RPIHRoaXMgaXMgYmVjYXVzZSBvZiB0aW1lX3QsIHdoaWNoIHdlIGRvbid0IG5lZWQuIFN0aWxsIHVzZWZ1bGw/XG4gIElDQUwuVGltZXpvbmUuRVhUUkFfQ09WRVJBR0UgPSA1O1xufSkoKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAxMS0yMDE1ICovXG5cblxuLyoqXG4gKiBUaGlzIHN5bWJvbCBpcyBmdXJ0aGVyIGRlc2NyaWJlZCBsYXRlciBvblxuICogQGlnbm9yZVxuICovXG5JQ0FMLlRpbWV6b25lU2VydmljZSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHpvbmVzO1xuXG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIFNpbmdsZXRvbiBjbGFzcyB0byBjb250YWluIHRpbWV6b25lcy4gIFJpZ2h0IG5vdyBpdCBpcyBhbGwgbWFudWFsIHJlZ2lzdHJ5IGluXG4gICAqIHRoZSBmdXR1cmUgd2UgbWF5IHVzZSB0aGlzIGNsYXNzIHRvIGRvd25sb2FkIHRpbWV6b25lIGluZm9ybWF0aW9uIG9yIGhhbmRsZVxuICAgKiBsb2FkaW5nIHByZS1leHBhbmRlZCB0aW1lem9uZXMuXG4gICAqXG4gICAqIEBuYW1lc3BhY2VcbiAgICogQGFsaWFzIElDQUwuVGltZXpvbmVTZXJ2aWNlXG4gICAqL1xuICB2YXIgVGltZXpvbmVTZXJ2aWNlID0ge1xuICAgIGdldCBjb3VudCgpIHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh6b25lcykubGVuZ3RoO1xuICAgIH0sXG5cbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICB6b25lcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB2YXIgdXRjID0gSUNBTC5UaW1lem9uZS51dGNUaW1lem9uZTtcblxuICAgICAgem9uZXMuWiA9IHV0YztcbiAgICAgIHpvbmVzLlVUQyA9IHV0YztcbiAgICAgIHpvbmVzLkdNVCA9IHV0YztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRpbWV6b25lIGlkIGhhcyBiZWVuIHJlZ2lzdGVyZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHppZCAgICAgVGltZXpvbmUgaWRlbnRpZmllciAoZS5nLiBBbWVyaWNhL0xvc19BbmdlbGVzKVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICBGYWxzZSwgd2hlbiBub3QgcHJlc2VudFxuICAgICAqL1xuICAgIGhhczogZnVuY3Rpb24odHppZCkge1xuICAgICAgcmV0dXJuICEhem9uZXNbdHppZF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB0aW1lem9uZSBieSBpdHMgdHppZCBpZiBwcmVzZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR6aWQgICAgIFRpbWV6b25lIGlkZW50aWZpZXIgKGUuZy4gQW1lcmljYS9Mb3NfQW5nZWxlcylcbiAgICAgKiBAcmV0dXJuIHs/SUNBTC5UaW1lem9uZX0gVGhlIHRpbWV6b25lLCBvciBudWxsIGlmIG5vdCBmb3VuZFxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24odHppZCkge1xuICAgICAgcmV0dXJuIHpvbmVzW3R6aWRdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSB0aW1lem9uZSBvYmplY3Qgb3IgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmc9fSBuYW1lXG4gICAgICogICAgICAgIFRoZSBuYW1lIG9mIHRoZSB0aW1lem9uZS4gRGVmYXVsdHMgdG8gdGhlIGNvbXBvbmVudCdzIFRaSUQgaWYgbm90XG4gICAgICogICAgICAgIHBhc3NlZC5cbiAgICAgKiBAcGFyYW0ge0lDQUwuQ29tcG9uZW50fElDQUwuVGltZXpvbmV9IHpvbmVcbiAgICAgKiAgICAgICAgVGhlIGluaXRpYWxpemVkIHpvbmUgb3IgdnRpbWV6b25lLlxuICAgICAqL1xuICAgIHJlZ2lzdGVyOiBmdW5jdGlvbihuYW1lLCB0aW1lem9uZSkge1xuICAgICAgaWYgKG5hbWUgaW5zdGFuY2VvZiBJQ0FMLkNvbXBvbmVudCkge1xuICAgICAgICBpZiAobmFtZS5uYW1lID09PSAndnRpbWV6b25lJykge1xuICAgICAgICAgIHRpbWV6b25lID0gbmV3IElDQUwuVGltZXpvbmUobmFtZSk7XG4gICAgICAgICAgbmFtZSA9IHRpbWV6b25lLnR6aWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRpbWV6b25lIGluc3RhbmNlb2YgSUNBTC5UaW1lem9uZSkge1xuICAgICAgICB6b25lc1tuYW1lXSA9IHRpbWV6b25lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGltZXpvbmUgbXVzdCBiZSBJQ0FMLlRpbWV6b25lIG9yIElDQUwuQ29tcG9uZW50Jyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSB0aW1lem9uZSBieSBpdHMgdHppZCBmcm9tIHRoZSBsaXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR6aWQgICAgIFRpbWV6b25lIGlkZW50aWZpZXIgKGUuZy4gQW1lcmljYS9Mb3NfQW5nZWxlcylcbiAgICAgKiBAcmV0dXJuIHs/SUNBTC5UaW1lem9uZX0gVGhlIHJlbW92ZWQgdGltZXpvbmUsIG9yIG51bGwgaWYgbm90IHJlZ2lzdGVyZWRcbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uKHR6aWQpIHtcbiAgICAgIHJldHVybiAoZGVsZXRlIHpvbmVzW3R6aWRdKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gaW5pdGlhbGl6ZSBkZWZhdWx0c1xuICBUaW1lem9uZVNlcnZpY2UucmVzZXQoKTtcblxuICByZXR1cm4gVGltZXpvbmVTZXJ2aWNlO1xufSgpKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAxMS0yMDE1ICovXG5cblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogaUNhbGVuZGFyIFRpbWUgcmVwcmVzZW50YXRpb24gKHNpbWlsYXIgdG8gSlMgRGF0ZSBvYmplY3QpLiAgRnVsbHlcbiAgICogaW5kZXBlbmRlbnQgb2Ygc3lzdGVtIChPUykgdGltZXpvbmUgLyB0aW1lLiAgVW5saWtlIEpTIERhdGUsIHRoZSBtb250aFxuICAgKiBKYW51YXJ5IGlzIDEsIG5vdCB6ZXJvLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgdGltZSA9IG5ldyBJQ0FMLlRpbWUoe1xuICAgKiAgIHllYXI6IDIwMTIsXG4gICAqICAgbW9udGg6IDEwLFxuICAgKiAgIGRheTogMTFcbiAgICogICBtaW51dGU6IDAsXG4gICAqICAgc2Vjb25kOiAwLFxuICAgKiAgIGlzRGF0ZTogZmFsc2VcbiAgICogfSk7XG4gICAqXG4gICAqXG4gICAqIEBhbGlhcyBJQ0FMLlRpbWVcbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhICAgICAgICAgICBUaW1lIGluaXRpYWxpemF0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS55ZWFyICAgICBUaGUgeWVhciBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS5tb250aCAgICBUaGUgbW9udGggZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcj19IGRhdGEuZGF5ICAgICAgVGhlIGRheSBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS5ob3VyICAgICBUaGUgaG91ciBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS5taW51dGUgICBUaGUgbWludXRlIGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLnNlY29uZCAgIFRoZSBzZWNvbmQgZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW49fSBkYXRhLmlzRGF0ZSAgSWYgdHJ1ZSwgdGhlIGluc3RhbmNlIHJlcHJlc2VudHMgYSBkYXRlIChhc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHBvc2VkIHRvIGEgZGF0ZS10aW1lKVxuICAgKiBAcGFyYW0ge0lDQUwuVGltZXpvbmV9IHpvbmUgdGltZXpvbmUgdGhpcyBwb3NpdGlvbiBvY2N1cnMgaW5cbiAgICovXG4gIElDQUwuVGltZSA9IGZ1bmN0aW9uIGljYWx0aW1lKGRhdGEsIHpvbmUpIHtcbiAgICB0aGlzLndyYXBwZWRKU09iamVjdCA9IHRoaXM7XG4gICAgdmFyIHRpbWUgPSB0aGlzLl90aW1lID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIC8qIHRpbWUgZGVmYXVsdHMgKi9cbiAgICB0aW1lLnllYXIgPSAwO1xuICAgIHRpbWUubW9udGggPSAxO1xuICAgIHRpbWUuZGF5ID0gMTtcbiAgICB0aW1lLmhvdXIgPSAwO1xuICAgIHRpbWUubWludXRlID0gMDtcbiAgICB0aW1lLnNlY29uZCA9IDA7XG4gICAgdGltZS5pc0RhdGUgPSBmYWxzZTtcblxuICAgIHRoaXMuZnJvbURhdGEoZGF0YSwgem9uZSk7XG4gIH07XG5cbiAgSUNBTC5UaW1lLl9kb3dDYWNoZSA9IHt9O1xuICBJQ0FMLlRpbWUuX3duQ2FjaGUgPSB7fTtcblxuICBJQ0FMLlRpbWUucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNsYXNzIGlkZW50aWZpZXIuXG4gICAgICogQGNvbnN0YW50XG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBcImljYWx0aW1lXCJcbiAgICAgKi9cbiAgICBpY2FsY2xhc3M6IFwiaWNhbHRpbWVcIixcbiAgICBfY2FjaGVkVW5peFRpbWU6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBuYW1lLCB0byBiZSB1c2VkIGluIHRoZSBqQ2FsIG9iamVjdC4gVGhpcyB2YWx1ZSBtYXkgY2hhbmdlIGFuZFxuICAgICAqIGlzIHN0cmljdGx5IGRlZmluZWQgYnkgdGhlIHtAbGluayBJQ0FMLlRpbWUjaXNEYXRlIGlzRGF0ZX0gbWVtYmVyLlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgXCJkYXRlLXRpbWVcIlxuICAgICAqL1xuICAgIGdldCBpY2FsdHlwZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzRGF0ZSA/ICdkYXRlJyA6ICdkYXRlLXRpbWUnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGltZXpvbmUgZm9yIHRoaXMgdGltZS5cbiAgICAgKiBAdHlwZSB7SUNBTC5UaW1lem9uZX1cbiAgICAgKi9cbiAgICB6b25lOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgdXNlcyB0byBpbmRpY2F0ZSB0aGF0IGEgY2hhbmdlIGhhcyBiZWVuIG1hZGUgYW5kIHRoZSBuZXh0IHJlYWRcbiAgICAgKiBvcGVyYXRpb24gbXVzdCBhdHRlbXB0IHRvIG5vcm1hbGl6ZSB0aGUgdmFsdWUgKGZvciBleGFtcGxlIGNoYW5naW5nIHRoZVxuICAgICAqIGRheSB0byAzMykuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9wZW5kaW5nTm9ybWFsaXphdGlvbjogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIHRpbWUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHJldHVybiB7SUNBTC5UaW1lfSAgICAgICAgICAgICAgVGhlIGNsb25lZCBvYmplY3RcbiAgICAgKi9cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IElDQUwuVGltZSh0aGlzLl90aW1lLCB0aGlzLnpvbmUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgdGltZSBpbnN0YW5jZSB0byBlcG9jaCB0aW1lXG4gICAgICovXG4gICAgcmVzZXQ6IGZ1bmN0aW9uIGljYWx0aW1lX3Jlc2V0KCkge1xuICAgICAgdGhpcy5mcm9tRGF0YShJQ0FMLlRpbWUuZXBvY2hUaW1lKTtcbiAgICAgIHRoaXMuem9uZSA9IElDQUwuVGltZXpvbmUudXRjVGltZXpvbmU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSB0aW1lIGluc3RhbmNlIHRvIHRoZSBnaXZlbiBkYXRlL3RpbWUgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHllYXIgICAgICAgICAgICAgVGhlIHllYXIgdG8gc2V0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1vbnRoICAgICAgICAgICAgVGhlIG1vbnRoIHRvIHNldFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXkgICAgICAgICAgICAgIFRoZSBkYXkgdG8gc2V0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhvdXIgICAgICAgICAgICAgVGhlIGhvdXIgdG8gc2V0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1pbnV0ZSAgICAgICAgICAgVGhlIG1pbnV0ZSB0byBzZXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2Vjb25kICAgICAgICAgICBUaGUgc2Vjb25kIHRvIHNldFxuICAgICAqIEBwYXJhbSB7SUNBTC5UaW1lem9uZX0gdGltZXpvbmUgIFRoZSB0aW1lem9uZSB0byBzZXRcbiAgICAgKi9cbiAgICByZXNldFRvOiBmdW5jdGlvbiBpY2FsdGltZV9yZXNldFRvKHllYXIsIG1vbnRoLCBkYXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3VyLCBtaW51dGUsIHNlY29uZCwgdGltZXpvbmUpIHtcbiAgICAgIHRoaXMuZnJvbURhdGEoe1xuICAgICAgICB5ZWFyOiB5ZWFyLFxuICAgICAgICBtb250aDogbW9udGgsXG4gICAgICAgIGRheTogZGF5LFxuICAgICAgICBob3VyOiBob3VyLFxuICAgICAgICBtaW51dGU6IG1pbnV0ZSxcbiAgICAgICAgc2Vjb25kOiBzZWNvbmQsXG4gICAgICAgIHpvbmU6IHRpbWV6b25lXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHVwIHRoZSBjdXJyZW50IGluc3RhbmNlIGZyb20gdGhlIEphdmFzY3JpcHQgZGF0ZSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P0RhdGV9IGFEYXRlICAgICBUaGUgSmF2YXNjcmlwdCBEYXRlIHRvIHJlYWQsIG9yIG51bGwgdG8gcmVzZXRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHVzZVVUQyAgSWYgdHJ1ZSwgdGhlIFVUQyB2YWx1ZXMgb2YgdGhlIGRhdGUgd2lsbCBiZSB1c2VkXG4gICAgICovXG4gICAgZnJvbUpTRGF0ZTogZnVuY3Rpb24gaWNhbHRpbWVfZnJvbUpTRGF0ZShhRGF0ZSwgdXNlVVRDKSB7XG4gICAgICBpZiAoIWFEYXRlKSB7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh1c2VVVEMpIHtcbiAgICAgICAgICB0aGlzLnpvbmUgPSBJQ0FMLlRpbWV6b25lLnV0Y1RpbWV6b25lO1xuICAgICAgICAgIHRoaXMueWVhciA9IGFEYXRlLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgICAgICAgdGhpcy5tb250aCA9IGFEYXRlLmdldFVUQ01vbnRoKCkgKyAxO1xuICAgICAgICAgIHRoaXMuZGF5ID0gYURhdGUuZ2V0VVRDRGF0ZSgpO1xuICAgICAgICAgIHRoaXMuaG91ciA9IGFEYXRlLmdldFVUQ0hvdXJzKCk7XG4gICAgICAgICAgdGhpcy5taW51dGUgPSBhRGF0ZS5nZXRVVENNaW51dGVzKCk7XG4gICAgICAgICAgdGhpcy5zZWNvbmQgPSBhRGF0ZS5nZXRVVENTZWNvbmRzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy56b25lID0gSUNBTC5UaW1lem9uZS5sb2NhbFRpbWV6b25lO1xuICAgICAgICAgIHRoaXMueWVhciA9IGFEYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgdGhpcy5tb250aCA9IGFEYXRlLmdldE1vbnRoKCkgKyAxO1xuICAgICAgICAgIHRoaXMuZGF5ID0gYURhdGUuZ2V0RGF0ZSgpO1xuICAgICAgICAgIHRoaXMuaG91ciA9IGFEYXRlLmdldEhvdXJzKCk7XG4gICAgICAgICAgdGhpcy5taW51dGUgPSBhRGF0ZS5nZXRNaW51dGVzKCk7XG4gICAgICAgICAgdGhpcy5zZWNvbmQgPSBhRGF0ZS5nZXRTZWNvbmRzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2NhY2hlZFVuaXhUaW1lID0gbnVsbDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIHRoZSBjdXJyZW50IGluc3RhbmNlIHVzaW5nIG1lbWJlcnMgZnJvbSB0aGUgcGFzc2VkIGRhdGEgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFEYXRhICAgICAgICAgICAgVGltZSBpbml0aWFsaXphdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEueWVhciAgICAgIFRoZSB5ZWFyIGZvciB0aGlzIGRhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLm1vbnRoICAgICBUaGUgbW9udGggZm9yIHRoaXMgZGF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEuZGF5ICAgICAgIFRoZSBkYXkgZm9yIHRoaXMgZGF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEuaG91ciAgICAgIFRoZSBob3VyIGZvciB0aGlzIGRhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLm1pbnV0ZSAgICBUaGUgbWludXRlIGZvciB0aGlzIGRhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLnNlY29uZCAgICBUaGUgc2Vjb25kIGZvciB0aGlzIGRhdGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW49fSBhRGF0YS5pc0RhdGUgICBJZiB0cnVlLCB0aGUgaW5zdGFuY2UgcmVwcmVzZW50cyBhIGRhdGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChhcyBvcHBvc2VkIHRvIGEgZGF0ZS10aW1lKVxuICAgICAqIEBwYXJhbSB7SUNBTC5UaW1lem9uZT19IGFab25lICAgIFRpbWV6b25lIHRoaXMgcG9zaXRpb24gb2NjdXJzIGluXG4gICAgICovXG4gICAgZnJvbURhdGE6IGZ1bmN0aW9uIGZyb21EYXRhKGFEYXRhLCBhWm9uZSkge1xuICAgICAgaWYgKGFEYXRhKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBhRGF0YSkge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhRGF0YSwga2V5KSkge1xuICAgICAgICAgICAgLy8gaWNhbCB0eXBlIGNhbm5vdCBiZSBzZXRcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdpY2FsdHlwZScpIGNvbnRpbnVlO1xuICAgICAgICAgICAgdGhpc1trZXldID0gYURhdGFba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGFab25lKSB7XG4gICAgICAgIHRoaXMuem9uZSA9IGFab25lO1xuICAgICAgfVxuXG4gICAgICBpZiAoYURhdGEgJiYgIShcImlzRGF0ZVwiIGluIGFEYXRhKSkge1xuICAgICAgICB0aGlzLmlzRGF0ZSA9ICEoXCJob3VyXCIgaW4gYURhdGEpO1xuICAgICAgfSBlbHNlIGlmIChhRGF0YSAmJiAoXCJpc0RhdGVcIiBpbiBhRGF0YSkpIHtcbiAgICAgICAgdGhpcy5pc0RhdGUgPSBhRGF0YS5pc0RhdGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChhRGF0YSAmJiBcInRpbWV6b25lXCIgaW4gYURhdGEpIHtcbiAgICAgICAgdmFyIHpvbmUgPSBJQ0FMLlRpbWV6b25lU2VydmljZS5nZXQoXG4gICAgICAgICAgYURhdGEudGltZXpvbmVcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLnpvbmUgPSB6b25lIHx8IElDQUwuVGltZXpvbmUubG9jYWxUaW1lem9uZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFEYXRhICYmIFwiem9uZVwiIGluIGFEYXRhKSB7XG4gICAgICAgIHRoaXMuem9uZSA9IGFEYXRhLnpvbmU7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy56b25lKSB7XG4gICAgICAgIHRoaXMuem9uZSA9IElDQUwuVGltZXpvbmUubG9jYWxUaW1lem9uZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY2FjaGVkVW5peFRpbWUgPSBudWxsO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgZGF5IG9mIHdlZWsuXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWUud2Vla0RheT19IGFXZWVrU3RhcnRcbiAgICAgKiAgICAgICAgVGhlIHdlZWsgc3RhcnQgd2Vla2RheSwgZGVmYXVsdHMgdG8gU1VOREFZXG4gICAgICogQHJldHVybiB7SUNBTC5UaW1lLndlZWtEYXl9XG4gICAgICovXG4gICAgZGF5T2ZXZWVrOiBmdW5jdGlvbiBpY2FsdGltZV9kYXlPZldlZWsoYVdlZWtTdGFydCkge1xuICAgICAgdmFyIGZpcnN0RG93ID0gYVdlZWtTdGFydCB8fCBJQ0FMLlRpbWUuU1VOREFZO1xuICAgICAgdmFyIGRvd0NhY2hlS2V5ID0gKHRoaXMueWVhciA8PCAxMikgKyAodGhpcy5tb250aCA8PCA4KSArICh0aGlzLmRheSA8PCAzKSArIGZpcnN0RG93O1xuICAgICAgaWYgKGRvd0NhY2hlS2V5IGluIElDQUwuVGltZS5fZG93Q2FjaGUpIHtcbiAgICAgICAgcmV0dXJuIElDQUwuVGltZS5fZG93Q2FjaGVbZG93Q2FjaGVLZXldO1xuICAgICAgfVxuXG4gICAgICAvLyBVc2luZyBaZWxsZXIncyBhbGdvcml0aG1cbiAgICAgIHZhciBxID0gdGhpcy5kYXk7XG4gICAgICB2YXIgbSA9IHRoaXMubW9udGggKyAodGhpcy5tb250aCA8IDMgPyAxMiA6IDApO1xuICAgICAgdmFyIFkgPSB0aGlzLnllYXIgLSAodGhpcy5tb250aCA8IDMgPyAxIDogMCk7XG5cbiAgICAgIHZhciBoID0gKHEgKyBZICsgSUNBTC5oZWxwZXJzLnRydW5jKCgobSArIDEpICogMjYpIC8gMTApICsgSUNBTC5oZWxwZXJzLnRydW5jKFkgLyA0KSk7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHRydWUgLyogZ3JlZ29yaWFuICovKSB7XG4gICAgICAgIGggKz0gSUNBTC5oZWxwZXJzLnRydW5jKFkgLyAxMDApICogNiArIElDQUwuaGVscGVycy50cnVuYyhZIC8gNDAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGggKz0gNTtcbiAgICAgIH1cblxuICAgICAgLy8gTm9ybWFsaXplIHRvIDEgPSB3a3N0XG4gICAgICBoID0gKChoICsgNyAtIGZpcnN0RG93KSAlIDcpICsgMTtcbiAgICAgIElDQUwuVGltZS5fZG93Q2FjaGVbZG93Q2FjaGVLZXldID0gaDtcbiAgICAgIHJldHVybiBoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGRheSBvZiB5ZWFyLlxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBkYXlPZlllYXI6IGZ1bmN0aW9uIGRheU9mWWVhcigpIHtcbiAgICAgIHZhciBpc19sZWFwID0gKElDQUwuVGltZS5pc0xlYXBZZWFyKHRoaXMueWVhcikgPyAxIDogMCk7XG4gICAgICB2YXIgZGl5cG0gPSBJQ0FMLlRpbWUuZGF5c0luWWVhclBhc3NlZE1vbnRoO1xuICAgICAgcmV0dXJuIGRpeXBtW2lzX2xlYXBdW3RoaXMubW9udGggLSAxXSArIHRoaXMuZGF5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBkYXRlL3RpbWUsIHJld291bmQgdG8gdGhlIHN0YXJ0IG9mIHRoZVxuICAgICAqIHdlZWsuIFRoZSByZXN1bHRpbmcgSUNBTC5UaW1lIGluc3RhbmNlIGlzIG9mIGljYWx0eXBlIGRhdGUsIGV2ZW4gaWYgdGhpc1xuICAgICAqIGlzIGEgZGF0ZS10aW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWUud2Vla0RheT19IGFXZWVrU3RhcnRcbiAgICAgKiAgICAgICAgVGhlIHdlZWsgc3RhcnQgd2Vla2RheSwgZGVmYXVsdHMgdG8gU1VOREFZXG4gICAgICogQHJldHVybiB7SUNBTC5UaW1lfSAgICAgIFRoZSBzdGFydCBvZiB0aGUgd2VlayAoY2xvbmVkKVxuICAgICAqL1xuICAgIHN0YXJ0T2ZXZWVrOiBmdW5jdGlvbiBzdGFydE9mV2VlayhhV2Vla1N0YXJ0KSB7XG4gICAgICB2YXIgZmlyc3REb3cgPSBhV2Vla1N0YXJ0IHx8IElDQUwuVGltZS5TVU5EQVk7XG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgcmVzdWx0LmRheSAtPSAoKHRoaXMuZGF5T2ZXZWVrKCkgKyA3IC0gZmlyc3REb3cpICUgNyk7XG4gICAgICByZXN1bHQuaXNEYXRlID0gdHJ1ZTtcbiAgICAgIHJlc3VsdC5ob3VyID0gMDtcbiAgICAgIHJlc3VsdC5taW51dGUgPSAwO1xuICAgICAgcmVzdWx0LnNlY29uZCA9IDA7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBkYXRlL3RpbWUsIHNoaWZ0ZWQgdG8gdGhlIGVuZCBvZiB0aGUgd2Vlay5cbiAgICAgKiBUaGUgcmVzdWx0aW5nIElDQUwuVGltZSBpbnN0YW5jZSBpcyBvZiBpY2FsdHlwZSBkYXRlLCBldmVuIGlmIHRoaXMgaXMgYVxuICAgICAqIGRhdGUtdGltZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SUNBTC5UaW1lLndlZWtEYXk9fSBhV2Vla1N0YXJ0XG4gICAgICogICAgICAgIFRoZSB3ZWVrIHN0YXJ0IHdlZWtkYXksIGRlZmF1bHRzIHRvIFNVTkRBWVxuICAgICAqIEByZXR1cm4ge0lDQUwuVGltZX0gICAgICBUaGUgZW5kIG9mIHRoZSB3ZWVrIChjbG9uZWQpXG4gICAgICovXG4gICAgZW5kT2ZXZWVrOiBmdW5jdGlvbiBlbmRPZldlZWsoYVdlZWtTdGFydCkge1xuICAgICAgdmFyIGZpcnN0RG93ID0gYVdlZWtTdGFydCB8fCBJQ0FMLlRpbWUuU1VOREFZO1xuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgIHJlc3VsdC5kYXkgKz0gKDcgLSB0aGlzLmRheU9mV2VlaygpICsgZmlyc3REb3cgLSBJQ0FMLlRpbWUuU1VOREFZKSAlIDc7XG4gICAgICByZXN1bHQuaXNEYXRlID0gdHJ1ZTtcbiAgICAgIHJlc3VsdC5ob3VyID0gMDtcbiAgICAgIHJlc3VsdC5taW51dGUgPSAwO1xuICAgICAgcmVzdWx0LnNlY29uZCA9IDA7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBkYXRlL3RpbWUsIHJld291bmQgdG8gdGhlIHN0YXJ0IG9mIHRoZVxuICAgICAqIG1vbnRoLiBUaGUgcmVzdWx0aW5nIElDQUwuVGltZSBpbnN0YW5jZSBpcyBvZiBpY2FsdHlwZSBkYXRlLCBldmVuIGlmXG4gICAgICogdGhpcyBpcyBhIGRhdGUtdGltZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0lDQUwuVGltZX0gICAgICBUaGUgc3RhcnQgb2YgdGhlIG1vbnRoIChjbG9uZWQpXG4gICAgICovXG4gICAgc3RhcnRPZk1vbnRoOiBmdW5jdGlvbiBzdGFydE9mTW9udGgoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgcmVzdWx0LmRheSA9IDE7XG4gICAgICByZXN1bHQuaXNEYXRlID0gdHJ1ZTtcbiAgICAgIHJlc3VsdC5ob3VyID0gMDtcbiAgICAgIHJlc3VsdC5taW51dGUgPSAwO1xuICAgICAgcmVzdWx0LnNlY29uZCA9IDA7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBkYXRlL3RpbWUsIHNoaWZ0ZWQgdG8gdGhlIGVuZCBvZiB0aGVcbiAgICAgKiBtb250aC4gIFRoZSByZXN1bHRpbmcgSUNBTC5UaW1lIGluc3RhbmNlIGlzIG9mIGljYWx0eXBlIGRhdGUsIGV2ZW4gaWZcbiAgICAgKiB0aGlzIGlzIGEgZGF0ZS10aW1lLlxuICAgICAqXG4gICAgICogQHJldHVybiB7SUNBTC5UaW1lfSAgICAgIFRoZSBlbmQgb2YgdGhlIG1vbnRoIChjbG9uZWQpXG4gICAgICovXG4gICAgZW5kT2ZNb250aDogZnVuY3Rpb24gZW5kT2ZNb250aCgpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNsb25lKCk7XG4gICAgICByZXN1bHQuZGF5ID0gSUNBTC5UaW1lLmRheXNJbk1vbnRoKHJlc3VsdC5tb250aCwgcmVzdWx0LnllYXIpO1xuICAgICAgcmVzdWx0LmlzRGF0ZSA9IHRydWU7XG4gICAgICByZXN1bHQuaG91ciA9IDA7XG4gICAgICByZXN1bHQubWludXRlID0gMDtcbiAgICAgIHJlc3VsdC5zZWNvbmQgPSAwO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgZGF0ZS90aW1lLCByZXdvdW5kIHRvIHRoZSBzdGFydCBvZiB0aGVcbiAgICAgKiB5ZWFyLiBUaGUgcmVzdWx0aW5nIElDQUwuVGltZSBpbnN0YW5jZSBpcyBvZiBpY2FsdHlwZSBkYXRlLCBldmVuIGlmXG4gICAgICogdGhpcyBpcyBhIGRhdGUtdGltZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0lDQUwuVGltZX0gICAgICBUaGUgc3RhcnQgb2YgdGhlIHllYXIgKGNsb25lZClcbiAgICAgKi9cbiAgICBzdGFydE9mWWVhcjogZnVuY3Rpb24gc3RhcnRPZlllYXIoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgcmVzdWx0LmRheSA9IDE7XG4gICAgICByZXN1bHQubW9udGggPSAxO1xuICAgICAgcmVzdWx0LmlzRGF0ZSA9IHRydWU7XG4gICAgICByZXN1bHQuaG91ciA9IDA7XG4gICAgICByZXN1bHQubWludXRlID0gMDtcbiAgICAgIHJlc3VsdC5zZWNvbmQgPSAwO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgZGF0ZS90aW1lLCBzaGlmdGVkIHRvIHRoZSBlbmQgb2YgdGhlXG4gICAgICogeWVhci4gIFRoZSByZXN1bHRpbmcgSUNBTC5UaW1lIGluc3RhbmNlIGlzIG9mIGljYWx0eXBlIGRhdGUsIGV2ZW4gaWZcbiAgICAgKiB0aGlzIGlzIGEgZGF0ZS10aW1lLlxuICAgICAqXG4gICAgICogQHJldHVybiB7SUNBTC5UaW1lfSAgICAgIFRoZSBlbmQgb2YgdGhlIHllYXIgKGNsb25lZClcbiAgICAgKi9cbiAgICBlbmRPZlllYXI6IGZ1bmN0aW9uIGVuZE9mWWVhcigpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNsb25lKCk7XG4gICAgICByZXN1bHQuZGF5ID0gMzE7XG4gICAgICByZXN1bHQubW9udGggPSAxMjtcbiAgICAgIHJlc3VsdC5pc0RhdGUgPSB0cnVlO1xuICAgICAgcmVzdWx0LmhvdXIgPSAwO1xuICAgICAgcmVzdWx0Lm1pbnV0ZSA9IDA7XG4gICAgICByZXN1bHQuc2Vjb25kID0gMDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpcnN0IGNhbGN1bGF0ZXMgdGhlIHN0YXJ0IG9mIHRoZSB3ZWVrLCB0aGVuIHJldHVybnMgdGhlIGRheSBvZiB5ZWFyIGZvclxuICAgICAqIHRoaXMgZGF0ZS4gSWYgdGhlIGRheSBmYWxscyBpbnRvIHRoZSBwcmV2aW91cyB5ZWFyLCB0aGUgZGF5IGlzIHplcm8gb3IgbmVnYXRpdmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZS53ZWVrRGF5PX0gYUZpcnN0RGF5T2ZXZWVrXG4gICAgICogICAgICAgIFRoZSB3ZWVrIHN0YXJ0IHdlZWtkYXksIGRlZmF1bHRzIHRvIFNVTkRBWVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgIFRoZSBjYWxjdWxhdGVkIGRheSBvZiB5ZWFyXG4gICAgICovXG4gICAgc3RhcnREb3lXZWVrOiBmdW5jdGlvbiBzdGFydERveVdlZWsoYUZpcnN0RGF5T2ZXZWVrKSB7XG4gICAgICB2YXIgZmlyc3REb3cgPSBhRmlyc3REYXlPZldlZWsgfHwgSUNBTC5UaW1lLlNVTkRBWTtcbiAgICAgIHZhciBkZWx0YSA9IHRoaXMuZGF5T2ZXZWVrKCkgLSBmaXJzdERvdztcbiAgICAgIGlmIChkZWx0YSA8IDApIGRlbHRhICs9IDc7XG4gICAgICByZXR1cm4gdGhpcy5kYXlPZlllYXIoKSAtIGRlbHRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGRvbWluaWNhbCBsZXR0ZXIgZm9yIHRoZSBjdXJyZW50IHllYXIuIExldHRlcnMgcmFuZ2UgZnJvbSBBIC0gR1xuICAgICAqIGZvciBjb21tb24geWVhcnMsIGFuZCBBRyB0byBHRiBmb3IgbGVhcCB5ZWFycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5ciAgICAgICAgICAgVGhlIHllYXIgdG8gcmV0cmlldmUgdGhlIGxldHRlciBmb3JcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICAgIFRoZSBkb21pbmljYWwgbGV0dGVyLlxuICAgICAqL1xuICAgIGdldERvbWluaWNhbExldHRlcjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gSUNBTC5UaW1lLmdldERvbWluaWNhbExldHRlcih0aGlzLnllYXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgbnRoV2Vla0RheSByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBtb250aCAobm90IGRheSkuICBUaGVcbiAgICAgKiByZXR1cm5lZCB2YWx1ZSBpcyBhIGRheSByZWxhdGl2ZSB0aGUgbW9udGggdGhhdCB0aGlzIG1vbnRoIGJlbG9uZ3MgdG8gc29cbiAgICAgKiAxIHdvdWxkIGluZGljYXRlIHRoZSBmaXJzdCBvZiB0aGUgbW9udGggYW5kIDQwIHdvdWxkIGluZGljYXRlIGEgZGF5IGluXG4gICAgICogdGhlIGZvbGxvd2luZyBtb250aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhRGF5T2ZXZWVrICAgRGF5IG9mIHRoZSB3ZWVrIHNlZSB0aGUgZGF5IG5hbWUgY29uc3RhbnRzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFQb3MgICAgICAgICBOdGggb2NjdXJyZW5jZSBvZiBhIGdpdmVuIHdlZWsgZGF5IHZhbHVlc1xuICAgICAqICAgICAgICBvZiAxIGFuZCAwIGJvdGggaW5kaWNhdGUgdGhlIGZpcnN0IHdlZWtkYXkgb2YgdGhhdCB0eXBlLiBhUG9zIG1heVxuICAgICAqICAgICAgICBiZSBlaXRoZXIgcG9zaXRpdmUgb3IgbmVnYXRpdmVcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gbnVtZXJpYyB2YWx1ZSBpbmRpY2F0aW5nIGEgZGF5IHJlbGF0aXZlXG4gICAgICogICAgICAgICAgICAgICAgICAgdG8gdGhlIGN1cnJlbnQgbW9udGggb2YgdGhpcyB0aW1lIG9iamVjdFxuICAgICAqL1xuICAgIG50aFdlZWtEYXk6IGZ1bmN0aW9uIGljYWx0aW1lX250aFdlZWtEYXkoYURheU9mV2VlaywgYVBvcykge1xuICAgICAgdmFyIGRheXNJbk1vbnRoID0gSUNBTC5UaW1lLmRheXNJbk1vbnRoKHRoaXMubW9udGgsIHRoaXMueWVhcik7XG4gICAgICB2YXIgd2Vla2RheTtcbiAgICAgIHZhciBwb3MgPSBhUG9zO1xuXG4gICAgICB2YXIgc3RhcnQgPSAwO1xuXG4gICAgICB2YXIgb3RoZXJEYXkgPSB0aGlzLmNsb25lKCk7XG5cbiAgICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgICBvdGhlckRheS5kYXkgPSAxO1xuXG4gICAgICAgIC8vIGJlY2F1c2UgMCBtZWFucyBubyBwb3NpdGlvbiBoYXMgYmVlbiBnaXZlblxuICAgICAgICAvLyAxIGFuZCAwIGluZGljYXRlIHRoZSBzYW1lIGRheS5cbiAgICAgICAgaWYgKHBvcyAhPSAwKSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIHRoZSBleHRyYSBudW1lcmljIHZhbHVlXG4gICAgICAgICAgcG9zLS07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgY3VycmVudCBzdGFydCBvZmZzZXQgdG8gY3VycmVudCBkYXkuXG4gICAgICAgIHN0YXJ0ID0gb3RoZXJEYXkuZGF5O1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIGN1cnJlbnQgZGF5IG9mIHdlZWtcbiAgICAgICAgdmFyIHN0YXJ0RG93ID0gb3RoZXJEYXkuZGF5T2ZXZWVrKCk7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gY3VycmVudFxuICAgICAgICAvLyBkYXkgb2YgdGhlIHdlZWsgYW5kIGRlc2lyZWQgZGF5IG9mIHRoZSB3ZWVrXG4gICAgICAgIHZhciBvZmZzZXQgPSBhRGF5T2ZXZWVrIC0gc3RhcnREb3c7XG5cblxuICAgICAgICAvLyBpZiB0aGUgb2Zmc2V0IGdvZXMgaW50byB0aGUgcGFzdFxuICAgICAgICAvLyB3ZWVrIHdlIGFkZCA3IHNvIGl0IGdvZXMgaW50byB0aGUgbmV4dFxuICAgICAgICAvLyB3ZWVrLiBXZSBvbmx5IHdhbnQgdG8gZ28gZm9yd2FyZCBpbiB0aW1lIGhlcmUuXG4gICAgICAgIGlmIChvZmZzZXQgPCAwKVxuICAgICAgICAgIC8vIHRoaXMgaXMgcmVhbGx5IGltcG9ydGFudCBvdGhlcndpc2Ugd2Ugd291bGRcbiAgICAgICAgICAvLyBlbmQgdXAgd2l0aCBkYXRlcyBmcm9tIGluIHRoZSBwYXN0LlxuICAgICAgICAgIG9mZnNldCArPSA3O1xuXG4gICAgICAgIC8vIGFkZCBvZmZzZXQgdG8gc3RhcnQgc28gc3RhcnQgaXMgdGhlIHNhbWVcbiAgICAgICAgLy8gZGF5IG9mIHRoZSB3ZWVrIGFzIHRoZSBkZXNpcmVkIGRheSBvZiB3ZWVrLlxuICAgICAgICBzdGFydCArPSBvZmZzZXQ7XG5cbiAgICAgICAgLy8gYmVjYXVzZSB3ZSBhcmUgZ29pbmcgdG8gYWRkIChhbmQgbXVsdGlwbHkpXG4gICAgICAgIC8vIHRoZSBudW1lcmljIHZhbHVlIG9mIHRoZSBkYXkgd2Ugc3VidHJhY3QgaXRcbiAgICAgICAgLy8gZnJvbSB0aGUgc3RhcnQgcG9zaXRpb24gc28gbm90IHRvIGFkZCBpdCB0d2ljZS5cbiAgICAgICAgc3RhcnQgLT0gYURheU9mV2VlaztcblxuICAgICAgICAvLyBzZXQgd2VlayBkYXlcbiAgICAgICAgd2Vla2RheSA9IGFEYXlPZldlZWs7XG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIHRoZW4gd2Ugc2V0IGl0IHRvIHRoZSBsYXN0IGRheSBpbiB0aGUgY3VycmVudCBtb250aFxuICAgICAgICBvdGhlckRheS5kYXkgPSBkYXlzSW5Nb250aDtcblxuICAgICAgICAvLyBmaW5kIHRoZSBlbmRzIHdlZWtkYXlcbiAgICAgICAgdmFyIGVuZERvdyA9IG90aGVyRGF5LmRheU9mV2VlaygpO1xuXG4gICAgICAgIHBvcysrO1xuXG4gICAgICAgIHdlZWtkYXkgPSAoZW5kRG93IC0gYURheU9mV2Vlayk7XG5cbiAgICAgICAgaWYgKHdlZWtkYXkgPCAwKSB7XG4gICAgICAgICAgd2Vla2RheSArPSA3O1xuICAgICAgICB9XG5cbiAgICAgICAgd2Vla2RheSA9IGRheXNJbk1vbnRoIC0gd2Vla2RheTtcbiAgICAgIH1cblxuICAgICAgd2Vla2RheSArPSBwb3MgKiA3O1xuXG4gICAgICByZXR1cm4gc3RhcnQgKyB3ZWVrZGF5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgY3VycmVudCB0aW1lIGlzIHRoZSBudGggd2Vla2RheSwgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnRcbiAgICAgKiBtb250aC4gIFdpbGwgYWx3YXlzIHJldHVybiBmYWxzZSB3aGVuIHJ1bGUgcmVzb2x2ZXMgb3V0c2lkZSBvZiBjdXJyZW50XG4gICAgICogbW9udGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZS53ZWVrRGF5fSBhRGF5T2ZXZWVrICAgICAgIERheSBvZiB3ZWVrIHRvIGNoZWNrXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFQb3MgICAgICAgICAgICAgICAgICAgICAgICBSZWxhdGl2ZSBwb3NpdGlvblxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgICAgICAgICAgICAgICAgICAgVHJ1ZSwgaWYgaXQgaXMgdGhlIG50aCB3ZWVrZGF5XG4gICAgICovXG4gICAgaXNOdGhXZWVrRGF5OiBmdW5jdGlvbihhRGF5T2ZXZWVrLCBhUG9zKSB7XG4gICAgICB2YXIgZG93ID0gdGhpcy5kYXlPZldlZWsoKTtcblxuICAgICAgaWYgKGFQb3MgPT09IDAgJiYgZG93ID09PSBhRGF5T2ZXZWVrKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBnZXQgcG9zXG4gICAgICB2YXIgZGF5ID0gdGhpcy5udGhXZWVrRGF5KGFEYXlPZldlZWssIGFQb3MpO1xuXG4gICAgICBpZiAoZGF5ID09PSB0aGlzLmRheSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBJU08gODYwMSB3ZWVrIG51bWJlci4gVGhlIGZpcnN0IHdlZWsgb2YgYSB5ZWFyIGlzIHRoZVxuICAgICAqIHdlZWsgdGhhdCBjb250YWlucyB0aGUgZmlyc3QgVGh1cnNkYXkuIFRoZSB5ZWFyIGNhbiBoYXZlIDUzIHdlZWtzLCBpZlxuICAgICAqIEphbnVhcnkgMXN0IGlzIGEgRnJpZGF5LlxuICAgICAqXG4gICAgICogTm90ZSB0aGVyZSBhcmUgcmVnaW9ucyB3aGVyZSB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhciBpcyB0aGUgb25lIHRoYXRcbiAgICAgKiBzdGFydHMgb24gSmFudWFyeSAxc3QsIHdoaWNoIG1heSBvZmZzZXQgdGhlIHdlZWsgbnVtYmVyLiBBbHNvLCBpZiBhXG4gICAgICogZGlmZmVyZW50IHdlZWsgc3RhcnQgaXMgc3BlY2lmaWVkLCB0aGlzIHdpbGwgYWxzbyBhZmZlY3QgdGhlIHdlZWtcbiAgICAgKiBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAc2VlIElDQUwuVGltZS53ZWVrT25lU3RhcnRzXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWUud2Vla0RheX0gYVdlZWtTdGFydCAgICAgICAgVGhlIHdlZWtkYXkgdGhlIHdlZWsgc3RhcnRzIHdpdGhcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgSVNPIHdlZWsgbnVtYmVyXG4gICAgICovXG4gICAgd2Vla051bWJlcjogZnVuY3Rpb24gd2Vla051bWJlcihhV2Vla1N0YXJ0KSB7XG4gICAgICB2YXIgd25DYWNoZUtleSA9ICh0aGlzLnllYXIgPDwgMTIpICsgKHRoaXMubW9udGggPDwgOCkgKyAodGhpcy5kYXkgPDwgMykgKyBhV2Vla1N0YXJ0O1xuICAgICAgaWYgKHduQ2FjaGVLZXkgaW4gSUNBTC5UaW1lLl93bkNhY2hlKSB7XG4gICAgICAgIHJldHVybiBJQ0FMLlRpbWUuX3duQ2FjaGVbd25DYWNoZUtleV07XG4gICAgICB9XG4gICAgICAvLyBUaGlzIGZ1bmN0aW9uIGNvdXJ0ZXN0eSBvZiBKdWxpYW4gQnVja25hbGwsIHB1Ymxpc2hlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAgICAgIC8vIGh0dHA6Ly93d3cuYm95ZXQuY29tL2FydGljbGVzL3B1Ymxpc2hlZGFydGljbGVzL2NhbGN1bGF0aW5ndGhlaXNvd2Vla251bWIuaHRtbFxuICAgICAgLy8gcGx1cyBzb21lIGZpeGVzIHRvIGJlIGFibGUgdG8gdXNlIGRpZmZlcmVudCB3ZWVrIHN0YXJ0cy5cbiAgICAgIHZhciB3ZWVrMTtcblxuICAgICAgdmFyIGR0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgZHQuaXNEYXRlID0gdHJ1ZTtcbiAgICAgIHZhciBpc295ZWFyID0gdGhpcy55ZWFyO1xuXG4gICAgICBpZiAoZHQubW9udGggPT0gMTIgJiYgZHQuZGF5ID4gMjUpIHtcbiAgICAgICAgd2VlazEgPSBJQ0FMLlRpbWUud2Vla09uZVN0YXJ0cyhpc295ZWFyICsgMSwgYVdlZWtTdGFydCk7XG4gICAgICAgIGlmIChkdC5jb21wYXJlKHdlZWsxKSA8IDApIHtcbiAgICAgICAgICB3ZWVrMSA9IElDQUwuVGltZS53ZWVrT25lU3RhcnRzKGlzb3llYXIsIGFXZWVrU3RhcnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlzb3llYXIrKztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2VlazEgPSBJQ0FMLlRpbWUud2Vla09uZVN0YXJ0cyhpc295ZWFyLCBhV2Vla1N0YXJ0KTtcbiAgICAgICAgaWYgKGR0LmNvbXBhcmUod2VlazEpIDwgMCkge1xuICAgICAgICAgIHdlZWsxID0gSUNBTC5UaW1lLndlZWtPbmVTdGFydHMoLS1pc295ZWFyLCBhV2Vla1N0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZGF5c0JldHdlZW4gPSAoZHQuc3VidHJhY3REYXRlKHdlZWsxKS50b1NlY29uZHMoKSAvIDg2NDAwKTtcbiAgICAgIHZhciBhbnN3ZXIgPSBJQ0FMLmhlbHBlcnMudHJ1bmMoZGF5c0JldHdlZW4gLyA3KSArIDE7XG4gICAgICBJQ0FMLlRpbWUuX3duQ2FjaGVbd25DYWNoZUtleV0gPSBhbnN3ZXI7XG4gICAgICByZXR1cm4gYW5zd2VyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBkdXJhdGlvbiB0byB0aGUgY3VycmVudCB0aW1lLiBUaGUgaW5zdGFuY2UgaXMgbW9kaWZpZWQgaW5cbiAgICAgKiBwbGFjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SUNBTC5EdXJhdGlvbn0gYUR1cmF0aW9uICAgICAgICAgVGhlIGR1cmF0aW9uIHRvIGFkZFxuICAgICAqL1xuICAgIGFkZER1cmF0aW9uOiBmdW5jdGlvbiBpY2FsdGltZV9hZGQoYUR1cmF0aW9uKSB7XG4gICAgICB2YXIgbXVsdCA9IChhRHVyYXRpb24uaXNOZWdhdGl2ZSA/IC0xIDogMSk7XG5cbiAgICAgIC8vIGJlY2F1c2Ugb2YgdGhlIGR1cmF0aW9uIG9wdGltaXphdGlvbnMgaXQgaXMgbXVjaFxuICAgICAgLy8gbW9yZSBlZmZpY2llbnQgdG8gZ3JhYiBhbGwgdGhlIHZhbHVlcyB1cCBmcm9udFxuICAgICAgLy8gdGhlbiBzZXQgdGhlbSBkaXJlY3RseSAod2hpY2ggd2lsbCBhdm9pZCBhIG5vcm1hbGl6YXRpb24gY2FsbCkuXG4gICAgICAvLyBTbyB3ZSBkb24ndCBhY3R1YWxseSBub3JtYWxpemUgdW50aWwgd2UgbmVlZCBpdC5cbiAgICAgIHZhciBzZWNvbmQgPSB0aGlzLnNlY29uZDtcbiAgICAgIHZhciBtaW51dGUgPSB0aGlzLm1pbnV0ZTtcbiAgICAgIHZhciBob3VyID0gdGhpcy5ob3VyO1xuICAgICAgdmFyIGRheSA9IHRoaXMuZGF5O1xuXG4gICAgICBzZWNvbmQgKz0gbXVsdCAqIGFEdXJhdGlvbi5zZWNvbmRzO1xuICAgICAgbWludXRlICs9IG11bHQgKiBhRHVyYXRpb24ubWludXRlcztcbiAgICAgIGhvdXIgKz0gbXVsdCAqIGFEdXJhdGlvbi5ob3VycztcbiAgICAgIGRheSArPSBtdWx0ICogYUR1cmF0aW9uLmRheXM7XG4gICAgICBkYXkgKz0gbXVsdCAqIDcgKiBhRHVyYXRpb24ud2Vla3M7XG5cbiAgICAgIHRoaXMuc2Vjb25kID0gc2Vjb25kO1xuICAgICAgdGhpcy5taW51dGUgPSBtaW51dGU7XG4gICAgICB0aGlzLmhvdXIgPSBob3VyO1xuICAgICAgdGhpcy5kYXkgPSBkYXk7XG5cbiAgICAgIHRoaXMuX2NhY2hlZFVuaXhUaW1lID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3VidHJhY3QgdGhlIGRhdGUgZGV0YWlscyAoX2V4Y2x1ZGluZ18gdGltZXpvbmUpLiAgVXNlZnVsIGZvciBmaW5kaW5nXG4gICAgICogdGhlIHJlbGF0aXZlIGRpZmZlcmVuY2UgYmV0d2VlbiB0d28gdGltZSBvYmplY3RzIGV4Y2x1ZGluZyB0aGVpclxuICAgICAqIHRpbWV6b25lIGRpZmZlcmVuY2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWV9IGFEYXRlICAgICBUaGUgZGF0ZSB0byBzdWJzdHJhY3RcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLkR1cmF0aW9ufSAgICAgIFRoZSBkaWZmZXJlbmNlIGFzIGEgZHVyYXRpb25cbiAgICAgKi9cbiAgICBzdWJ0cmFjdERhdGU6IGZ1bmN0aW9uIGljYWx0aW1lX3N1YnRyYWN0KGFEYXRlKSB7XG4gICAgICB2YXIgdW5peFRpbWUgPSB0aGlzLnRvVW5peFRpbWUoKSArIHRoaXMudXRjT2Zmc2V0KCk7XG4gICAgICB2YXIgb3RoZXIgPSBhRGF0ZS50b1VuaXhUaW1lKCkgKyBhRGF0ZS51dGNPZmZzZXQoKTtcbiAgICAgIHJldHVybiBJQ0FMLkR1cmF0aW9uLmZyb21TZWNvbmRzKHVuaXhUaW1lIC0gb3RoZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdCB0aGUgZGF0ZSBkZXRhaWxzLCB0YWtpbmcgdGltZXpvbmVzIGludG8gYWNjb3VudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SUNBTC5UaW1lfSBhRGF0ZSAgVGhlIGRhdGUgdG8gc3VidHJhY3RcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLkR1cmF0aW9ufSAgVGhlIGRpZmZlcmVuY2UgaW4gZHVyYXRpb25cbiAgICAgKi9cbiAgICBzdWJ0cmFjdERhdGVUejogZnVuY3Rpb24gaWNhbHRpbWVfc3VidHJhY3RfYWJzKGFEYXRlKSB7XG4gICAgICB2YXIgdW5peFRpbWUgPSB0aGlzLnRvVW5peFRpbWUoKTtcbiAgICAgIHZhciBvdGhlciA9IGFEYXRlLnRvVW5peFRpbWUoKTtcbiAgICAgIHJldHVybiBJQ0FMLkR1cmF0aW9uLmZyb21TZWNvbmRzKHVuaXhUaW1lIC0gb3RoZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb21wYXJlcyB0aGUgSUNBTC5UaW1lIGluc3RhbmNlIHdpdGggYW5vdGhlciBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuRHVyYXRpb259IGFPdGhlciAgICAgICAgVGhlIGluc3RhbmNlIHRvIGNvbXBhcmUgd2l0aFxuICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgICAgICAgICAtMSwgMCBvciAxIGZvciBsZXNzL2VxdWFsL2dyZWF0ZXJcbiAgICAgKi9cbiAgICBjb21wYXJlOiBmdW5jdGlvbiBpY2FsdGltZV9jb21wYXJlKG90aGVyKSB7XG4gICAgICB2YXIgYSA9IHRoaXMudG9Vbml4VGltZSgpO1xuICAgICAgdmFyIGIgPSBvdGhlci50b1VuaXhUaW1lKCk7XG5cbiAgICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gICAgICBpZiAoYiA+IGEpIHJldHVybiAtMTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb21wYXJlcyBvbmx5IHRoZSBkYXRlIHBhcnQgb2YgdGhpcyBpbnN0YW5jZSB3aXRoIGFub3RoZXIgb25lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLkR1cmF0aW9ufSBvdGhlciAgICAgICAgIFRoZSBpbnN0YW5jZSB0byBjb21wYXJlIHdpdGhcbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZXpvbmV9IHR6ICAgICAgICAgICAgVGhlIHRpbWV6b25lIHRvIGNvbXBhcmUgaW5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgICAgICAgICAgLTEsIDAgb3IgMSBmb3IgbGVzcy9lcXVhbC9ncmVhdGVyXG4gICAgICovXG4gICAgY29tcGFyZURhdGVPbmx5VHo6IGZ1bmN0aW9uIGljYWx0aW1lX2NvbXBhcmVEYXRlT25seVR6KG90aGVyLCB0eikge1xuICAgICAgZnVuY3Rpb24gY21wKGF0dHIpIHtcbiAgICAgICAgcmV0dXJuIElDQUwuVGltZS5fY21wX2F0dHIoYSwgYiwgYXR0cik7XG4gICAgICB9XG4gICAgICB2YXIgYSA9IHRoaXMuY29udmVydFRvWm9uZSh0eik7XG4gICAgICB2YXIgYiA9IG90aGVyLmNvbnZlcnRUb1pvbmUodHopO1xuICAgICAgdmFyIHJjID0gMDtcblxuICAgICAgaWYgKChyYyA9IGNtcChcInllYXJcIikpICE9IDApIHJldHVybiByYztcbiAgICAgIGlmICgocmMgPSBjbXAoXCJtb250aFwiKSkgIT0gMCkgcmV0dXJuIHJjO1xuICAgICAgaWYgKChyYyA9IGNtcChcImRheVwiKSkgIT0gMCkgcmV0dXJuIHJjO1xuXG4gICAgICByZXR1cm4gcmM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdGhlIGluc3RhbmNlIGludG8gYW5vdGhlciB0aW1lem9uZS4gVGhlIHJldHVybmVkIElDQUwuVGltZVxuICAgICAqIGluc3RhbmNlIGlzIGFsd2F5cyBhIGNvcHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZXpvbmV9IHpvbmUgICAgICBUaGUgem9uZSB0byBjb252ZXJ0IHRvXG4gICAgICogQHJldHVybiB7SUNBTC5UaW1lfSAgICAgICAgICAgICAgVGhlIGNvcHksIGNvbnZlcnRlZCB0byB0aGUgem9uZVxuICAgICAqL1xuICAgIGNvbnZlcnRUb1pvbmU6IGZ1bmN0aW9uIGNvbnZlcnRUb1pvbmUoem9uZSkge1xuICAgICAgdmFyIGNvcHkgPSB0aGlzLmNsb25lKCk7XG4gICAgICB2YXIgem9uZV9lcXVhbHMgPSAodGhpcy56b25lLnR6aWQgPT0gem9uZS50emlkKTtcblxuICAgICAgaWYgKCF0aGlzLmlzRGF0ZSAmJiAhem9uZV9lcXVhbHMpIHtcbiAgICAgICAgSUNBTC5UaW1lem9uZS5jb252ZXJ0X3RpbWUoY29weSwgdGhpcy56b25lLCB6b25lKTtcbiAgICAgIH1cblxuICAgICAgY29weS56b25lID0gem9uZTtcbiAgICAgIHJldHVybiBjb3B5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBVVEMgb2Zmc2V0IG9mIHRoZSBjdXJyZW50IGRhdGUvdGltZSBpbiB0aGUgdGltZXpvbmUgaXQgaXNcbiAgICAgKiBpbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgIFVUQyBvZmZzZXQgaW4gc2Vjb25kc1xuICAgICAqL1xuICAgIHV0Y09mZnNldDogZnVuY3Rpb24gdXRjX29mZnNldCgpIHtcbiAgICAgIGlmICh0aGlzLnpvbmUgPT0gSUNBTC5UaW1lem9uZS5sb2NhbFRpbWV6b25lIHx8XG4gICAgICAgICAgdGhpcy56b25lID09IElDQUwuVGltZXpvbmUudXRjVGltZXpvbmUpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy56b25lLnV0Y09mZnNldCh0aGlzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBSRkMgNTU0NSBjb21wbGlhbnQgaWNhbCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gaWNhbCBkYXRlL2RhdGUtdGltZVxuICAgICAqL1xuICAgIHRvSUNBTFN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc3RyaW5nID0gdGhpcy50b1N0cmluZygpO1xuXG4gICAgICBpZiAoc3RyaW5nLmxlbmd0aCA+IDEwKSB7XG4gICAgICAgIHJldHVybiBJQ0FMLmRlc2lnbi5pY2FsZW5kYXIudmFsdWVbJ2RhdGUtdGltZSddLnRvSUNBTChzdHJpbmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIElDQUwuZGVzaWduLmljYWxlbmRhci52YWx1ZS5kYXRlLnRvSUNBTChzdHJpbmcpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZGF0ZS90aW1lLCBpbiBqQ2FsIGZvcm1cbiAgICAgKiAoaW5jbHVkaW5nIDogYW5kIC0gc2VwYXJhdG9ycykuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLnllYXIgKyAnLScgK1xuICAgICAgICAgICAgICAgICAgIElDQUwuaGVscGVycy5wYWQyKHRoaXMubW9udGgpICsgJy0nICtcbiAgICAgICAgICAgICAgICAgICBJQ0FMLmhlbHBlcnMucGFkMih0aGlzLmRheSk7XG5cbiAgICAgIGlmICghdGhpcy5pc0RhdGUpIHtcbiAgICAgICAgICByZXN1bHQgKz0gJ1QnICsgSUNBTC5oZWxwZXJzLnBhZDIodGhpcy5ob3VyKSArICc6JyArXG4gICAgICAgICAgICAgICAgICAgIElDQUwuaGVscGVycy5wYWQyKHRoaXMubWludXRlKSArICc6JyArXG4gICAgICAgICAgICAgICAgICAgIElDQUwuaGVscGVycy5wYWQyKHRoaXMuc2Vjb25kKTtcblxuICAgICAgICBpZiAodGhpcy56b25lID09PSBJQ0FMLlRpbWV6b25lLnV0Y1RpbWV6b25lKSB7XG4gICAgICAgICAgcmVzdWx0ICs9ICdaJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgY3VycmVudCBpbnN0YW5jZSB0byBhIEphdmFzY3JpcHQgZGF0ZVxuICAgICAqIEByZXR1cm4ge0RhdGV9XG4gICAgICovXG4gICAgdG9KU0RhdGU6IGZ1bmN0aW9uIHRvSlNEYXRlKCkge1xuICAgICAgaWYgKHRoaXMuem9uZSA9PSBJQ0FMLlRpbWV6b25lLmxvY2FsVGltZXpvbmUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMueWVhciwgdGhpcy5tb250aCAtIDEsIHRoaXMuZGF5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy55ZWFyLCB0aGlzLm1vbnRoIC0gMSwgdGhpcy5kYXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaG91ciwgdGhpcy5taW51dGUsIHRoaXMuc2Vjb25kLCAwKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudG9Vbml4VGltZSgpICogMTAwMCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9ub3JtYWxpemU6IGZ1bmN0aW9uIGljYWx0aW1lX25vcm1hbGl6ZSgpIHtcbiAgICAgIHZhciBpc0RhdGUgPSB0aGlzLl90aW1lLmlzRGF0ZTtcbiAgICAgIGlmICh0aGlzLl90aW1lLmlzRGF0ZSkge1xuICAgICAgICB0aGlzLl90aW1lLmhvdXIgPSAwO1xuICAgICAgICB0aGlzLl90aW1lLm1pbnV0ZSA9IDA7XG4gICAgICAgIHRoaXMuX3RpbWUuc2Vjb25kID0gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWRqdXN0KDAsIDAsIDAsIDApO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRqdXN0IHRoZSBkYXRlL3RpbWUgYnkgdGhlIGdpdmVuIG9mZnNldFxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFFeHRyYURheXMgICAgICAgVGhlIGV4dHJhIGFtb3VudCBvZiBkYXlzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFFeHRyYUhvdXJzICAgICAgVGhlIGV4dHJhIGFtb3VudCBvZiBob3Vyc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhRXh0cmFNaW51dGVzICAgIFRoZSBleHRyYSBhbW91bnQgb2YgbWludXRlc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhRXh0cmFTZWNvbmRzICAgIFRoZSBleHRyYSBhbW91bnQgb2Ygc2Vjb25kc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyPX0gYVRpbWUgICAgICAgICAgIFRoZSB0aW1lIHRvIGFkanVzdCwgZGVmYXVsdHMgdG8gdGhlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50IGluc3RhbmNlLlxuICAgICAqL1xuICAgIGFkanVzdDogZnVuY3Rpb24gaWNhbHRpbWVfYWRqdXN0KGFFeHRyYURheXMsIGFFeHRyYUhvdXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFFeHRyYU1pbnV0ZXMsIGFFeHRyYVNlY29uZHMsIGFUaW1lKSB7XG5cbiAgICAgIHZhciBtaW51dGVzT3ZlcmZsb3csIGhvdXJzT3ZlcmZsb3csXG4gICAgICAgICAgZGF5c092ZXJmbG93ID0gMCwgeWVhcnNPdmVyZmxvdyA9IDA7XG5cbiAgICAgIHZhciBzZWNvbmQsIG1pbnV0ZSwgaG91ciwgZGF5O1xuICAgICAgdmFyIGRheXNJbk1vbnRoO1xuXG4gICAgICB2YXIgdGltZSA9IGFUaW1lIHx8IHRoaXMuX3RpbWU7XG5cbiAgICAgIGlmICghdGltZS5pc0RhdGUpIHtcbiAgICAgICAgc2Vjb25kID0gdGltZS5zZWNvbmQgKyBhRXh0cmFTZWNvbmRzO1xuICAgICAgICB0aW1lLnNlY29uZCA9IHNlY29uZCAlIDYwO1xuICAgICAgICBtaW51dGVzT3ZlcmZsb3cgPSBJQ0FMLmhlbHBlcnMudHJ1bmMoc2Vjb25kIC8gNjApO1xuICAgICAgICBpZiAodGltZS5zZWNvbmQgPCAwKSB7XG4gICAgICAgICAgdGltZS5zZWNvbmQgKz0gNjA7XG4gICAgICAgICAgbWludXRlc092ZXJmbG93LS07XG4gICAgICAgIH1cblxuICAgICAgICBtaW51dGUgPSB0aW1lLm1pbnV0ZSArIGFFeHRyYU1pbnV0ZXMgKyBtaW51dGVzT3ZlcmZsb3c7XG4gICAgICAgIHRpbWUubWludXRlID0gbWludXRlICUgNjA7XG4gICAgICAgIGhvdXJzT3ZlcmZsb3cgPSBJQ0FMLmhlbHBlcnMudHJ1bmMobWludXRlIC8gNjApO1xuICAgICAgICBpZiAodGltZS5taW51dGUgPCAwKSB7XG4gICAgICAgICAgdGltZS5taW51dGUgKz0gNjA7XG4gICAgICAgICAgaG91cnNPdmVyZmxvdy0tO1xuICAgICAgICB9XG5cbiAgICAgICAgaG91ciA9IHRpbWUuaG91ciArIGFFeHRyYUhvdXJzICsgaG91cnNPdmVyZmxvdztcblxuICAgICAgICB0aW1lLmhvdXIgPSBob3VyICUgMjQ7XG4gICAgICAgIGRheXNPdmVyZmxvdyA9IElDQUwuaGVscGVycy50cnVuYyhob3VyIC8gMjQpO1xuICAgICAgICBpZiAodGltZS5ob3VyIDwgMCkge1xuICAgICAgICAgIHRpbWUuaG91ciArPSAyNDtcbiAgICAgICAgICBkYXlzT3ZlcmZsb3ctLTtcbiAgICAgICAgfVxuICAgICAgfVxuXG5cbiAgICAgIC8vIEFkanVzdCBtb250aCBhbmQgeWVhciBmaXJzdCwgYmVjYXVzZSB3ZSBuZWVkIHRvIGtub3cgd2hhdCBtb250aCB0aGUgZGF5XG4gICAgICAvLyBpcyBpbiBiZWZvcmUgYWRqdXN0aW5nIGl0LlxuICAgICAgaWYgKHRpbWUubW9udGggPiAxMikge1xuICAgICAgICB5ZWFyc092ZXJmbG93ID0gSUNBTC5oZWxwZXJzLnRydW5jKCh0aW1lLm1vbnRoIC0gMSkgLyAxMik7XG4gICAgICB9IGVsc2UgaWYgKHRpbWUubW9udGggPCAxKSB7XG4gICAgICAgIHllYXJzT3ZlcmZsb3cgPSBJQ0FMLmhlbHBlcnMudHJ1bmModGltZS5tb250aCAvIDEyKSAtIDE7XG4gICAgICB9XG5cbiAgICAgIHRpbWUueWVhciArPSB5ZWFyc092ZXJmbG93O1xuICAgICAgdGltZS5tb250aCAtPSAxMiAqIHllYXJzT3ZlcmZsb3c7XG5cbiAgICAgIC8vIE5vdyB0YWtlIGNhcmUgb2YgdGhlIGRheXMgKGFuZCBhZGp1c3QgbW9udGggaWYgbmVlZGVkKVxuICAgICAgZGF5ID0gdGltZS5kYXkgKyBhRXh0cmFEYXlzICsgZGF5c092ZXJmbG93O1xuXG4gICAgICBpZiAoZGF5ID4gMCkge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgZGF5c0luTW9udGggPSBJQ0FMLlRpbWUuZGF5c0luTW9udGgodGltZS5tb250aCwgdGltZS55ZWFyKTtcbiAgICAgICAgICBpZiAoZGF5IDw9IGRheXNJbk1vbnRoKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aW1lLm1vbnRoKys7XG4gICAgICAgICAgaWYgKHRpbWUubW9udGggPiAxMikge1xuICAgICAgICAgICAgdGltZS55ZWFyKys7XG4gICAgICAgICAgICB0aW1lLm1vbnRoID0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkYXkgLT0gZGF5c0luTW9udGg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdoaWxlIChkYXkgPD0gMCkge1xuICAgICAgICAgIGlmICh0aW1lLm1vbnRoID09IDEpIHtcbiAgICAgICAgICAgIHRpbWUueWVhci0tO1xuICAgICAgICAgICAgdGltZS5tb250aCA9IDEyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aW1lLm1vbnRoLS07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGF5ICs9IElDQUwuVGltZS5kYXlzSW5Nb250aCh0aW1lLm1vbnRoLCB0aW1lLnllYXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRpbWUuZGF5ID0gZGF5O1xuXG4gICAgICB0aGlzLl9jYWNoZWRVbml4VGltZSA9IG51bGw7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB1cCB0aGUgY3VycmVudCBpbnN0YW5jZSBmcm9tIHVuaXggdGltZSwgdGhlIG51bWJlciBvZiBzZWNvbmRzIHNpbmNlXG4gICAgICogSmFudWFyeSAxc3QsIDE5NzAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2Vjb25kcyAgICAgIFRoZSBzZWNvbmRzIHRvIHNldCB1cCB3aXRoXG4gICAgICovXG4gICAgZnJvbVVuaXhUaW1lOiBmdW5jdGlvbiBmcm9tVW5peFRpbWUoc2Vjb25kcykge1xuICAgICAgdGhpcy56b25lID0gSUNBTC5UaW1lem9uZS51dGNUaW1lem9uZTtcbiAgICAgIHZhciBlcG9jaCA9IElDQUwuVGltZS5lcG9jaFRpbWUuY2xvbmUoKTtcbiAgICAgIGVwb2NoLmFkanVzdCgwLCAwLCAwLCBzZWNvbmRzKTtcblxuICAgICAgdGhpcy55ZWFyID0gZXBvY2gueWVhcjtcbiAgICAgIHRoaXMubW9udGggPSBlcG9jaC5tb250aDtcbiAgICAgIHRoaXMuZGF5ID0gZXBvY2guZGF5O1xuICAgICAgdGhpcy5ob3VyID0gZXBvY2guaG91cjtcbiAgICAgIHRoaXMubWludXRlID0gZXBvY2gubWludXRlO1xuICAgICAgdGhpcy5zZWNvbmQgPSBNYXRoLmZsb29yKGVwb2NoLnNlY29uZCk7XG5cbiAgICAgIHRoaXMuX2NhY2hlZFVuaXhUaW1lID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGN1cnJlbnQgaW5zdGFuY2UgdG8gc2Vjb25kcyBzaW5jZSBKYW51YXJ5IDFzdCAxOTcwLlxuICAgICAqXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgIFNlY29uZHMgc2luY2UgMTk3MFxuICAgICAqL1xuICAgIHRvVW5peFRpbWU6IGZ1bmN0aW9uIHRvVW5peFRpbWUoKSB7XG4gICAgICBpZiAodGhpcy5fY2FjaGVkVW5peFRpbWUgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZFVuaXhUaW1lO1xuICAgICAgfVxuICAgICAgdmFyIG9mZnNldCA9IHRoaXMudXRjT2Zmc2V0KCk7XG5cbiAgICAgIC8vIHdlIHVzZSB0aGUgb2Zmc2V0IHRyaWNrIHRvIGVuc3VyZVxuICAgICAgLy8gdGhhdCB3ZSBhcmUgZ2V0dGluZyB0aGUgYWN0dWFsIFVUQyB0aW1lXG4gICAgICB2YXIgbXMgPSBEYXRlLlVUQyhcbiAgICAgICAgdGhpcy55ZWFyLFxuICAgICAgICB0aGlzLm1vbnRoIC0gMSxcbiAgICAgICAgdGhpcy5kYXksXG4gICAgICAgIHRoaXMuaG91cixcbiAgICAgICAgdGhpcy5taW51dGUsXG4gICAgICAgIHRoaXMuc2Vjb25kIC0gb2Zmc2V0XG4gICAgICApO1xuXG4gICAgICAvLyBzZWNvbmRzXG4gICAgICB0aGlzLl9jYWNoZWRVbml4VGltZSA9IG1zIC8gMTAwMDtcbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRVbml4VGltZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGltZSB0byBpbnRvIE9iamVjdCB3aGljaCBjYW4gYmUgc2VyaWFsaXplZCB0aGVuIHJlLWNyZWF0ZWRcbiAgICAgKiB1c2luZyB0aGUgY29uc3RydWN0b3IuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIHRvSlNPTiB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgY2FsbGVkXG4gICAgICogdmFyIGpzb24gPSBKU09OLnN0cmluZ2lmeShteXRpbWUpO1xuICAgICAqXG4gICAgICogdmFyIGRlc2VyaWFsaXplZCA9IEpTT04ucGFyc2UoanNvbik7XG4gICAgICpcbiAgICAgKiB2YXIgdGltZSA9IG5ldyBJQ0FMLlRpbWUoZGVzZXJpYWxpemVkKTtcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT046IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNvcHkgPSBbXG4gICAgICAgICd5ZWFyJyxcbiAgICAgICAgJ21vbnRoJyxcbiAgICAgICAgJ2RheScsXG4gICAgICAgICdob3VyJyxcbiAgICAgICAgJ21pbnV0ZScsXG4gICAgICAgICdzZWNvbmQnLFxuICAgICAgICAnaXNEYXRlJ1xuICAgICAgXTtcblxuICAgICAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBsZW4gPSBjb3B5Lmxlbmd0aDtcbiAgICAgIHZhciBwcm9wO1xuXG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHByb3AgPSBjb3B5W2ldO1xuICAgICAgICByZXN1bHRbcHJvcF0gPSB0aGlzW3Byb3BdO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy56b25lKSB7XG4gICAgICAgIHJlc3VsdC50aW1lem9uZSA9IHRoaXMuem9uZS50emlkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICB9O1xuXG4gIChmdW5jdGlvbiBzZXR1cE5vcm1hbGl6ZUF0dHJpYnV0ZXMoKSB7XG4gICAgLy8gVGhpcyBuZWVkcyB0byBydW4gYmVmb3JlIGFueSBpbnN0YW5jZXMgYXJlIGNyZWF0ZWQhXG4gICAgZnVuY3Rpb24gZGVmaW5lQXR0cihhdHRyKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSUNBTC5UaW1lLnByb3RvdHlwZSwgYXR0ciwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldFRpbWVBdHRyKCkge1xuICAgICAgICAgIGlmICh0aGlzLl9wZW5kaW5nTm9ybWFsaXphdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fbm9ybWFsaXplKCk7XG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nTm9ybWFsaXphdGlvbiA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aGlzLl90aW1lW2F0dHJdO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldFRpbWVBdHRyKHZhbCkge1xuICAgICAgICAgIC8vIENoZWNrIGlmIGlzRGF0ZSB3aWxsIGJlIHNldCBhbmQgaWYgd2FzIG5vdCBzZXQgdG8gbm9ybWFsaXplIGRhdGUuXG4gICAgICAgICAgLy8gVGhpcyBhdm9pZHMgbG9zaW5nIGRheXMgd2hlbiBzZWNvbmRzLCBtaW51dGVzIGFuZCBob3VycyBhcmUgemVyb2VkXG4gICAgICAgICAgLy8gd2hhdCBub3JtYWxpemUgd2lsbCBkbyB3aGVuIHRpbWUgaXMgYSBkYXRlLlxuICAgICAgICAgIGlmIChhdHRyID09PSBcImlzRGF0ZVwiICYmIHZhbCAmJiAhdGhpcy5fdGltZS5pc0RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0KDAsIDAsIDAsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9jYWNoZWRVbml4VGltZSA9IG51bGw7XG4gICAgICAgICAgdGhpcy5fcGVuZGluZ05vcm1hbGl6YXRpb24gPSB0cnVlO1xuICAgICAgICAgIHRoaXMuX3RpbWVbYXR0cl0gPSB2YWw7XG5cbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgIH1cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKFwiZGVmaW5lUHJvcGVydHlcIiBpbiBPYmplY3QpIHtcbiAgICAgIGRlZmluZUF0dHIoXCJ5ZWFyXCIpO1xuICAgICAgZGVmaW5lQXR0cihcIm1vbnRoXCIpO1xuICAgICAgZGVmaW5lQXR0cihcImRheVwiKTtcbiAgICAgIGRlZmluZUF0dHIoXCJob3VyXCIpO1xuICAgICAgZGVmaW5lQXR0cihcIm1pbnV0ZVwiKTtcbiAgICAgIGRlZmluZUF0dHIoXCJzZWNvbmRcIik7XG4gICAgICBkZWZpbmVBdHRyKFwiaXNEYXRlXCIpO1xuICAgIH1cbiAgfSkoKTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGF5cyBpbiB0aGUgZ2l2ZW4gbW9udGhcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1vbnRoICAgICAgVGhlIG1vbnRoIHRvIGNoZWNrXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5ZWFyICAgICAgIFRoZSB5ZWFyIHRvIGNoZWNrXG4gICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgIFRoZSBudW1iZXIgb2YgZGF5cyBpbiB0aGUgbW9udGhcbiAgICovXG4gIElDQUwuVGltZS5kYXlzSW5Nb250aCA9IGZ1bmN0aW9uIGljYWx0aW1lX2RheXNJbk1vbnRoKG1vbnRoLCB5ZWFyKSB7XG4gICAgdmFyIF9kYXlzSW5Nb250aCA9IFswLCAzMSwgMjgsIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXTtcbiAgICB2YXIgZGF5cyA9IDMwO1xuXG4gICAgaWYgKG1vbnRoIDwgMSB8fCBtb250aCA+IDEyKSByZXR1cm4gZGF5cztcblxuICAgIGRheXMgPSBfZGF5c0luTW9udGhbbW9udGhdO1xuXG4gICAgaWYgKG1vbnRoID09IDIpIHtcbiAgICAgIGRheXMgKz0gSUNBTC5UaW1lLmlzTGVhcFllYXIoeWVhcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRheXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgeWVhciBpcyBhIGxlYXAgeWVhclxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0geWVhciAgICAgICBUaGUgeWVhciB0byBjaGVja1xuICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICBUcnVlLCBpZiB0aGUgeWVhciBpcyBhIGxlYXAgeWVhclxuICAgKi9cbiAgSUNBTC5UaW1lLmlzTGVhcFllYXIgPSBmdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcbiAgICBpZiAoeWVhciA8PSAxNzUyKSB7XG4gICAgICByZXR1cm4gKCh5ZWFyICUgNCkgPT0gMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoKCh5ZWFyICUgNCA9PSAwKSAmJiAoeWVhciAlIDEwMCAhPSAwKSkgfHwgKHllYXIgJSA0MDAgPT0gMCkpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IElDQUwuVGltZSBmcm9tIHRoZSBkYXkgb2YgeWVhciBhbmQgeWVhci4gVGhlIGRhdGUgaXMgcmV0dXJuZWRcbiAgICogaW4gZmxvYXRpbmcgdGltZXpvbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhRGF5T2ZZZWFyICAgICBUaGUgZGF5IG9mIHllYXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFZZWFyICAgICAgICAgIFRoZSB5ZWFyIHRvIGNyZWF0ZSB0aGUgaW5zdGFuY2UgaW5cbiAgICogQHJldHVybiB7SUNBTC5UaW1lfSAgICAgICAgICAgIFRoZSBjcmVhdGVkIGluc3RhbmNlIHdpdGggdGhlIGNhbGN1bGF0ZWQgZGF0ZVxuICAgKi9cbiAgSUNBTC5UaW1lLmZyb21EYXlPZlllYXIgPSBmdW5jdGlvbiBpY2FsdGltZV9mcm9tRGF5T2ZZZWFyKGFEYXlPZlllYXIsIGFZZWFyKSB7XG4gICAgdmFyIHllYXIgPSBhWWVhcjtcbiAgICB2YXIgZG95ID0gYURheU9mWWVhcjtcbiAgICB2YXIgdHQgPSBuZXcgSUNBTC5UaW1lKCk7XG4gICAgdHQuYXV0b19ub3JtYWxpemUgPSBmYWxzZTtcbiAgICB2YXIgaXNfbGVhcCA9IChJQ0FMLlRpbWUuaXNMZWFwWWVhcih5ZWFyKSA/IDEgOiAwKTtcblxuICAgIGlmIChkb3kgPCAxKSB7XG4gICAgICB5ZWFyLS07XG4gICAgICBpc19sZWFwID0gKElDQUwuVGltZS5pc0xlYXBZZWFyKHllYXIpID8gMSA6IDApO1xuICAgICAgZG95ICs9IElDQUwuVGltZS5kYXlzSW5ZZWFyUGFzc2VkTW9udGhbaXNfbGVhcF1bMTJdO1xuICAgICAgcmV0dXJuIElDQUwuVGltZS5mcm9tRGF5T2ZZZWFyKGRveSwgeWVhcik7XG4gICAgfSBlbHNlIGlmIChkb3kgPiBJQ0FMLlRpbWUuZGF5c0luWWVhclBhc3NlZE1vbnRoW2lzX2xlYXBdWzEyXSkge1xuICAgICAgaXNfbGVhcCA9IChJQ0FMLlRpbWUuaXNMZWFwWWVhcih5ZWFyKSA/IDEgOiAwKTtcbiAgICAgIGRveSAtPSBJQ0FMLlRpbWUuZGF5c0luWWVhclBhc3NlZE1vbnRoW2lzX2xlYXBdWzEyXTtcbiAgICAgIHllYXIrKztcbiAgICAgIHJldHVybiBJQ0FMLlRpbWUuZnJvbURheU9mWWVhcihkb3ksIHllYXIpO1xuICAgIH1cblxuICAgIHR0LnllYXIgPSB5ZWFyO1xuICAgIHR0LmlzRGF0ZSA9IHRydWU7XG5cbiAgICBmb3IgKHZhciBtb250aCA9IDExOyBtb250aCA+PSAwOyBtb250aC0tKSB7XG4gICAgICBpZiAoZG95ID4gSUNBTC5UaW1lLmRheXNJblllYXJQYXNzZWRNb250aFtpc19sZWFwXVttb250aF0pIHtcbiAgICAgICAgdHQubW9udGggPSBtb250aCArIDE7XG4gICAgICAgIHR0LmRheSA9IGRveSAtIElDQUwuVGltZS5kYXlzSW5ZZWFyUGFzc2VkTW9udGhbaXNfbGVhcF1bbW9udGhdO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0dC5hdXRvX25vcm1hbGl6ZSA9IHRydWU7XG4gICAgcmV0dXJuIHR0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IElDQUwuVGltZSBpbnN0YW5jZSBmcm9tIGEgZGF0ZSBzdHJpbmcsIGUuZyAyMDE1LTAxLTAyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCAgICAgICAgICAgICAgICBVc2Uge0BsaW5rIElDQUwuVGltZS5mcm9tRGF0ZVN0cmluZ30gaW5zdGVhZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyICAgICAgICBUaGUgc3RyaW5nIHRvIGNyZWF0ZSBmcm9tXG4gICAqIEByZXR1cm4ge0lDQUwuVGltZX0gICAgICAgIFRoZSBkYXRlL3RpbWUgaW5zdGFuY2VcbiAgICovXG4gIElDQUwuVGltZS5mcm9tU3RyaW5ndjIgPSBmdW5jdGlvbiBmcm9tU3RyaW5nKHN0cikge1xuICAgIHJldHVybiBuZXcgSUNBTC5UaW1lKHtcbiAgICAgIHllYXI6IHBhcnNlSW50KHN0ci5zdWJzdHIoMCwgNCksIDEwKSxcbiAgICAgIG1vbnRoOiBwYXJzZUludChzdHIuc3Vic3RyKDUsIDIpLCAxMCksXG4gICAgICBkYXk6IHBhcnNlSW50KHN0ci5zdWJzdHIoOCwgMiksIDEwKSxcbiAgICAgIGlzRGF0ZTogdHJ1ZVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IElDQUwuVGltZSBpbnN0YW5jZSBmcm9tIGEgZGF0ZSBzdHJpbmcsIGUuZyAyMDE1LTAxLTAyLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYVZhbHVlICAgICBUaGUgc3RyaW5nIHRvIGNyZWF0ZSBmcm9tXG4gICAqIEByZXR1cm4ge0lDQUwuVGltZX0gICAgICAgIFRoZSBkYXRlL3RpbWUgaW5zdGFuY2VcbiAgICovXG4gIElDQUwuVGltZS5mcm9tRGF0ZVN0cmluZyA9IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgIC8vIERhdGVzIHNob3VsZCBoYXZlIG5vIHRpbWV6b25lLlxuICAgIC8vIEdvb2dsZSBsaWtlcyB0byBzb21ldGltZXMgc3BlY2lmeSBaIG9uIGRhdGVzXG4gICAgLy8gd2Ugc3BlY2lmaWNhbGx5IGlnbm9yZSB0aGF0IHRvIGF2b2lkIGlzc3Vlcy5cblxuICAgIC8vIFlZWVktTU0tRERcbiAgICAvLyAyMDEyLTEwLTEwXG4gICAgcmV0dXJuIG5ldyBJQ0FMLlRpbWUoe1xuICAgICAgeWVhcjogSUNBTC5oZWxwZXJzLnN0cmljdFBhcnNlSW50KGFWYWx1ZS5zdWJzdHIoMCwgNCkpLFxuICAgICAgbW9udGg6IElDQUwuaGVscGVycy5zdHJpY3RQYXJzZUludChhVmFsdWUuc3Vic3RyKDUsIDIpKSxcbiAgICAgIGRheTogSUNBTC5oZWxwZXJzLnN0cmljdFBhcnNlSW50KGFWYWx1ZS5zdWJzdHIoOCwgMikpLFxuICAgICAgaXNEYXRlOiB0cnVlXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgSUNBTC5UaW1lIGluc3RhbmNlIGZyb20gYSBkYXRlLXRpbWUgc3RyaW5nLCBlLmdcbiAgICogMjAxNS0wMS0wMlQwMzowNDowNS4gSWYgYSBwcm9wZXJ0eSBpcyBzcGVjaWZpZWQsIHRoZSB0aW1lem9uZSBpcyBzZXQgdXBcbiAgICogZnJvbSB0aGUgcHJvcGVydHkncyBUWklEIHBhcmFtZXRlci5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFWYWx1ZSAgICAgICAgIFRoZSBzdHJpbmcgdG8gY3JlYXRlIGZyb21cbiAgICogQHBhcmFtIHtJQ0FMLlByb3BlcnR5PX0gcHJvcCAgIFRoZSBwcm9wZXJ0eSB0aGUgZGF0ZSBiZWxvbmdzIHRvXG4gICAqIEByZXR1cm4ge0lDQUwuVGltZX0gICAgICAgICAgICBUaGUgZGF0ZS90aW1lIGluc3RhbmNlXG4gICAqL1xuICBJQ0FMLlRpbWUuZnJvbURhdGVUaW1lU3RyaW5nID0gZnVuY3Rpb24oYVZhbHVlLCBwcm9wKSB7XG4gICAgaWYgKGFWYWx1ZS5sZW5ndGggPCAxOSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnaW52YWxpZCBkYXRlLXRpbWUgdmFsdWU6IFwiJyArIGFWYWx1ZSArICdcIidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIHpvbmU7XG5cbiAgICBpZiAoYVZhbHVlWzE5XSAmJiBhVmFsdWVbMTldID09PSAnWicpIHtcbiAgICAgIHpvbmUgPSAnWic7XG4gICAgfSBlbHNlIGlmIChwcm9wKSB7XG4gICAgICB6b25lID0gcHJvcC5nZXRQYXJhbWV0ZXIoJ3R6aWQnKTtcbiAgICB9XG5cbiAgICAvLyAyMDEyLTEwLTEwVDEwOjEwOjEwKFopP1xuICAgIHZhciB0aW1lID0gbmV3IElDQUwuVGltZSh7XG4gICAgICB5ZWFyOiBJQ0FMLmhlbHBlcnMuc3RyaWN0UGFyc2VJbnQoYVZhbHVlLnN1YnN0cigwLCA0KSksXG4gICAgICBtb250aDogSUNBTC5oZWxwZXJzLnN0cmljdFBhcnNlSW50KGFWYWx1ZS5zdWJzdHIoNSwgMikpLFxuICAgICAgZGF5OiBJQ0FMLmhlbHBlcnMuc3RyaWN0UGFyc2VJbnQoYVZhbHVlLnN1YnN0cig4LCAyKSksXG4gICAgICBob3VyOiBJQ0FMLmhlbHBlcnMuc3RyaWN0UGFyc2VJbnQoYVZhbHVlLnN1YnN0cigxMSwgMikpLFxuICAgICAgbWludXRlOiBJQ0FMLmhlbHBlcnMuc3RyaWN0UGFyc2VJbnQoYVZhbHVlLnN1YnN0cigxNCwgMikpLFxuICAgICAgc2Vjb25kOiBJQ0FMLmhlbHBlcnMuc3RyaWN0UGFyc2VJbnQoYVZhbHVlLnN1YnN0cigxNywgMikpLFxuICAgICAgdGltZXpvbmU6IHpvbmVcbiAgICB9KTtcblxuICAgIHJldHVybiB0aW1lO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IElDQUwuVGltZSBpbnN0YW5jZSBmcm9tIGEgZGF0ZSBvciBkYXRlLXRpbWUgc3RyaW5nLFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYVZhbHVlICAgICAgICAgVGhlIHN0cmluZyB0byBjcmVhdGUgZnJvbVxuICAgKiBAcGFyYW0ge0lDQUwuUHJvcGVydHk9fSBwcm9wICAgVGhlIHByb3BlcnR5IHRoZSBkYXRlIGJlbG9uZ3MgdG9cbiAgICogQHJldHVybiB7SUNBTC5UaW1lfSAgICAgICAgICAgIFRoZSBkYXRlL3RpbWUgaW5zdGFuY2VcbiAgICovXG4gIElDQUwuVGltZS5mcm9tU3RyaW5nID0gZnVuY3Rpb24gZnJvbVN0cmluZyhhVmFsdWUsIGFQcm9wZXJ0eSkge1xuICAgIGlmIChhVmFsdWUubGVuZ3RoID4gMTApIHtcbiAgICAgIHJldHVybiBJQ0FMLlRpbWUuZnJvbURhdGVUaW1lU3RyaW5nKGFWYWx1ZSwgYVByb3BlcnR5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIElDQUwuVGltZS5mcm9tRGF0ZVN0cmluZyhhVmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBJQ0FMLlRpbWUgaW5zdGFuY2UgZnJvbSB0aGUgZ2l2ZW4gSmF2YXNjcmlwdCBEYXRlLlxuICAgKlxuICAgKiBAcGFyYW0gez9EYXRlfSBhRGF0ZSAgICAgVGhlIEphdmFzY3JpcHQgRGF0ZSB0byByZWFkLCBvciBudWxsIHRvIHJlc2V0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdXNlVVRDICBJZiB0cnVlLCB0aGUgVVRDIHZhbHVlcyBvZiB0aGUgZGF0ZSB3aWxsIGJlIHVzZWRcbiAgICovXG4gIElDQUwuVGltZS5mcm9tSlNEYXRlID0gZnVuY3Rpb24gZnJvbUpTRGF0ZShhRGF0ZSwgdXNlVVRDKSB7XG4gICAgdmFyIHR0ID0gbmV3IElDQUwuVGltZSgpO1xuICAgIHJldHVybiB0dC5mcm9tSlNEYXRlKGFEYXRlLCB1c2VVVEMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IElDQUwuVGltZSBpbnN0YW5jZSBmcm9tIHRoZSB0aGUgcGFzc2VkIGRhdGEgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYURhdGEgICAgICAgICAgICBUaW1lIGluaXRpYWxpemF0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEueWVhciAgICAgIFRoZSB5ZWFyIGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5tb250aCAgICAgVGhlIG1vbnRoIGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5kYXkgICAgICAgVGhlIGRheSBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEuaG91ciAgICAgIFRoZSBob3VyIGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5taW51dGUgICAgVGhlIG1pbnV0ZSBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEuc2Vjb25kICAgIFRoZSBzZWNvbmQgZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW49fSBhRGF0YS5pc0RhdGUgICBJZiB0cnVlLCB0aGUgaW5zdGFuY2UgcmVwcmVzZW50cyBhIGRhdGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYXMgb3Bwb3NlZCB0byBhIGRhdGUtdGltZSlcbiAgICogQHBhcmFtIHtJQ0FMLlRpbWV6b25lPX0gYVpvbmUgICAgVGltZXpvbmUgdGhpcyBwb3NpdGlvbiBvY2N1cnMgaW5cbiAgICovXG4gIElDQUwuVGltZS5mcm9tRGF0YSA9IGZ1bmN0aW9uIGZyb21EYXRhKGFEYXRhLCBhWm9uZSkge1xuICAgIHZhciB0ID0gbmV3IElDQUwuVGltZSgpO1xuICAgIHJldHVybiB0LmZyb21EYXRhKGFEYXRhLCBhWm9uZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgSUNBTC5UaW1lIGluc3RhbmNlIGZyb20gdGhlIGN1cnJlbnQgbW9tZW50LlxuICAgKiBUaGUgaW5zdGFuY2UgaXMgXHUyMDFDZmxvYXRpbmdcdTIwMUQgLSBoYXMgbm8gdGltZXpvbmUgcmVsYXRpb24uXG4gICAqIFRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBjb25zaWRlcmluZyB0aGUgdGltZSB6b25lLCBjYWxsXG4gICAqIElDQUwuVGltZS5mcm9tSlNEYXRlKG5ldyBEYXRlKCksIHRydWUpXG4gICAqIEByZXR1cm4ge0lDQUwuVGltZX1cbiAgICovXG4gIElDQUwuVGltZS5ub3cgPSBmdW5jdGlvbiBpY2FsdGltZV9ub3coKSB7XG4gICAgcmV0dXJuIElDQUwuVGltZS5mcm9tSlNEYXRlKG5ldyBEYXRlKCksIGZhbHNlKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGF0ZSBvbiB3aGljaCBJU08gd2VlayBudW1iZXIgMSBzdGFydHMuXG4gICAqXG4gICAqIEBzZWUgSUNBTC5UaW1lI3dlZWtOdW1iZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFZZWFyICAgICAgICAgICAgICAgICAgVGhlIHllYXIgdG8gc2VhcmNoIGluXG4gICAqIEBwYXJhbSB7SUNBTC5UaW1lLndlZWtEYXk9fSBhV2Vla1N0YXJ0IFRoZSB3ZWVrIHN0YXJ0IHdlZWtkYXksIHVzZWQgZm9yIGNhbGN1bGF0aW9uLlxuICAgKiBAcmV0dXJuIHtJQ0FMLlRpbWV9ICAgICAgICAgICAgICAgICAgICBUaGUgZGF0ZSBvbiB3aGljaCB3ZWVrIG51bWJlciAxIHN0YXJ0c1xuICAgKi9cbiAgSUNBTC5UaW1lLndlZWtPbmVTdGFydHMgPSBmdW5jdGlvbiB3ZWVrT25lU3RhcnRzKGFZZWFyLCBhV2Vla1N0YXJ0KSB7XG4gICAgdmFyIHQgPSBJQ0FMLlRpbWUuZnJvbURhdGEoe1xuICAgICAgeWVhcjogYVllYXIsXG4gICAgICBtb250aDogMSxcbiAgICAgIGRheTogMSxcbiAgICAgIGlzRGF0ZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgdmFyIGRvdyA9IHQuZGF5T2ZXZWVrKCk7XG4gICAgdmFyIHdrc3QgPSBhV2Vla1N0YXJ0IHx8IElDQUwuVGltZS5ERUZBVUxUX1dFRUtfU1RBUlQ7XG4gICAgaWYgKGRvdyA+IElDQUwuVGltZS5USFVSU0RBWSkge1xuICAgICAgdC5kYXkgKz0gNztcbiAgICB9XG4gICAgaWYgKHdrc3QgPiBJQ0FMLlRpbWUuVEhVUlNEQVkpIHtcbiAgICAgIHQuZGF5IC09IDc7XG4gICAgfVxuXG4gICAgdC5kYXkgLT0gZG93IC0gd2tzdDtcblxuICAgIHJldHVybiB0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRvbWluaWNhbCBsZXR0ZXIgZm9yIHRoZSBnaXZlbiB5ZWFyLiBMZXR0ZXJzIHJhbmdlIGZyb20gQSAtIEcgZm9yXG4gICAqIGNvbW1vbiB5ZWFycywgYW5kIEFHIHRvIEdGIGZvciBsZWFwIHllYXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0geXIgICAgICAgICAgIFRoZSB5ZWFyIHRvIHJldHJpZXZlIHRoZSBsZXR0ZXIgZm9yXG4gICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgICAgVGhlIGRvbWluaWNhbCBsZXR0ZXIuXG4gICAqL1xuICBJQ0FMLlRpbWUuZ2V0RG9taW5pY2FsTGV0dGVyID0gZnVuY3Rpb24oeXIpIHtcbiAgICB2YXIgTFRSUyA9IFwiR0ZFRENCQVwiO1xuICAgIHZhciBkb20gPSAoeXIgKyAoeXIgLyA0IHwgMCkgKyAoeXIgLyA0MDAgfCAwKSAtICh5ciAvIDEwMCB8IDApIC0gMSkgJSA3O1xuICAgIHZhciBpc0xlYXAgPSBJQ0FMLlRpbWUuaXNMZWFwWWVhcih5cik7XG4gICAgaWYgKGlzTGVhcCkge1xuICAgICAgcmV0dXJuIExUUlNbKGRvbSArIDYpICUgN10gKyBMVFJTW2RvbV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBMVFJTW2RvbV07XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBKYW51YXJ5IDFzdCwgMTk3MCBhcyBhbiBJQ0FMLlRpbWUuXG4gICAqIEB0eXBlIHtJQ0FMLlRpbWV9XG4gICAqIEBjb25zdGFudFxuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIElDQUwuVGltZS5lcG9jaFRpbWUgPSBJQ0FMLlRpbWUuZnJvbURhdGEoe1xuICAgIHllYXI6IDE5NzAsXG4gICAgbW9udGg6IDEsXG4gICAgZGF5OiAxLFxuICAgIGhvdXI6IDAsXG4gICAgbWludXRlOiAwLFxuICAgIHNlY29uZDogMCxcbiAgICBpc0RhdGU6IGZhbHNlLFxuICAgIHRpbWV6b25lOiBcIlpcIlxuICB9KTtcblxuICBJQ0FMLlRpbWUuX2NtcF9hdHRyID0gZnVuY3Rpb24gX2NtcF9hdHRyKGEsIGIsIGF0dHIpIHtcbiAgICBpZiAoYVthdHRyXSA+IGJbYXR0cl0pIHJldHVybiAxO1xuICAgIGlmIChhW2F0dHJdIDwgYlthdHRyXSkgcmV0dXJuIC0xO1xuICAgIHJldHVybiAwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgZGF5cyB0aGF0IGhhdmUgcGFzc2VkIGluIHRoZSB5ZWFyIGFmdGVyIGEgZ2l2ZW4gbW9udGguIFRoZSBhcnJheSBoYXNcbiAgICogdHdvIG1lbWJlcnMsIG9uZSBiZWluZyBhbiBhcnJheSBvZiBwYXNzZWQgZGF5cyBmb3Igbm9uLWxlYXAgeWVhcnMsIHRoZVxuICAgKiBvdGhlciBhbmFsb2cgZm9yIGxlYXAgeWVhcnMuXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBpc0xlYXBZZWFyID0gSUNBTC5UaW1lLmlzTGVhcFllYXIoeWVhcik7XG4gICAqIHZhciBwYXNzZWREYXlzID0gSUNBTC5UaW1lLmRheXNJblllYXJQYXNzZWRNb250aFtpc0xlYXBZZWFyXVttb250aF07XG4gICAqIEB0eXBlIHtBcnJheS48QXJyYXkuPE51bWJlcj4+fVxuICAgKi9cbiAgSUNBTC5UaW1lLmRheXNJblllYXJQYXNzZWRNb250aCA9IFtcbiAgICBbMCwgMzEsIDU5LCA5MCwgMTIwLCAxNTEsIDE4MSwgMjEyLCAyNDMsIDI3MywgMzA0LCAzMzQsIDM2NV0sXG4gICAgWzAsIDMxLCA2MCwgOTEsIDEyMSwgMTUyLCAxODIsIDIxMywgMjQ0LCAyNzQsIDMwNSwgMzM1LCAzNjZdXG4gIF07XG5cbiAgLyoqXG4gICAqIFRoZSB3ZWVrZGF5LCAxID0gU1VOREFZLCA3ID0gU0FUVVJEQVkuIEFjY2VzcyB2aWFcbiAgICogSUNBTC5UaW1lLk1PTkRBWSwgSUNBTC5UaW1lLlRVRVNEQVksIC4uLlxuICAgKlxuICAgKiBAdHlwZWRlZiB7TnVtYmVyfSB3ZWVrRGF5XG4gICAqIEBtZW1iZXJvZiBJQ0FMLlRpbWVcbiAgICovXG5cbiAgSUNBTC5UaW1lLlNVTkRBWSA9IDE7XG4gIElDQUwuVGltZS5NT05EQVkgPSAyO1xuICBJQ0FMLlRpbWUuVFVFU0RBWSA9IDM7XG4gIElDQUwuVGltZS5XRURORVNEQVkgPSA0O1xuICBJQ0FMLlRpbWUuVEhVUlNEQVkgPSA1O1xuICBJQ0FMLlRpbWUuRlJJREFZID0gNjtcbiAgSUNBTC5UaW1lLlNBVFVSREFZID0gNztcblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgd2Vla2RheSBmb3IgdGhlIFdLU1QgcGFydC5cbiAgICogQGNvbnN0YW50XG4gICAqIEBkZWZhdWx0IElDQUwuVGltZS5NT05EQVlcbiAgICovXG4gIElDQUwuVGltZS5ERUZBVUxUX1dFRUtfU1RBUlQgPSBJQ0FMLlRpbWUuTU9OREFZO1xufSkoKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAxNSAqL1xuXG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8qKlxuICAgKiBEZXNjcmliZXMgYSB2Q2FyZCB0aW1lLCB3aGljaCBoYXMgc2xpZ2h0IGRpZmZlcmVuY2VzIHRvIHRoZSBJQ0FMLlRpbWUuXG4gICAqIFByb3BlcnRpZXMgY2FuIGJlIG51bGwgaWYgbm90IHNwZWNpZmllZCwgZm9yIGV4YW1wbGUgZm9yIGRhdGVzIHdpdGhcbiAgICogcmVkdWNlZCBhY2N1cmFjeSBvciB0cnVuY2F0aW9uLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgY3VycmVudGx5IG5vdCBhbGwgbWV0aG9kcyBhcmUgY29ycmVjdGx5IHJlLWltcGxlbWVudGVkIGZvclxuICAgKiBWQ2FyZFRpbWUuIEZvciBleGFtcGxlLCBjb21wYXJpc29uIHdpbGwgaGF2ZSB1bmRlZmluZWQgcmVzdWx0cyB3aGVuIHNvbWVcbiAgICogbWVtYmVycyBhcmUgbnVsbC5cbiAgICpcbiAgICogQWxzbywgbm9ybWFsaXphdGlvbiBpcyBub3QgeWV0IGltcGxlbWVudGVkIGZvciB0aGlzIGNsYXNzIVxuICAgKlxuICAgKiBAYWxpYXMgSUNBTC5WQ2FyZFRpbWVcbiAgICogQGNsYXNzXG4gICAqIEBleHRlbmRzIHtJQ0FMLlRpbWV9XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGRhdGEgZm9yIHRoZSB0aW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS55ZWFyICAgICAgICAgICAgICAgICAgICAgVGhlIHllYXIgZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcj19IGRhdGEubW9udGggICAgICAgICAgICAgICAgICAgIFRoZSBtb250aCBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS5kYXkgICAgICAgICAgICAgICAgICAgICAgVGhlIGRheSBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS5ob3VyICAgICAgICAgICAgICAgICAgICAgVGhlIGhvdXIgZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcj19IGRhdGEubWludXRlICAgICAgICAgICAgICAgICAgIFRoZSBtaW51dGUgZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcj19IGRhdGEuc2Vjb25kICAgICAgICAgICAgICAgICAgIFRoZSBzZWNvbmQgZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge0lDQUwuVGltZXpvbmV8SUNBTC5VdGNPZmZzZXR9IHpvbmUgICAgIFRoZSB0aW1lem9uZSB0byB1c2VcbiAgICogQHBhcmFtIHtTdHJpbmd9IGljYWx0eXBlICAgICAgICAgICAgICAgICAgICAgICBUaGUgdHlwZSBmb3IgdGhpcyBkYXRlL3RpbWUgb2JqZWN0XG4gICAqL1xuICBJQ0FMLlZDYXJkVGltZSA9IGZ1bmN0aW9uKGRhdGEsIHpvbmUsIGljYWx0eXBlKSB7XG4gICAgdGhpcy53cmFwcGVkSlNPYmplY3QgPSB0aGlzO1xuICAgIHZhciB0aW1lID0gdGhpcy5fdGltZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICB0aW1lLnllYXIgPSBudWxsO1xuICAgIHRpbWUubW9udGggPSBudWxsO1xuICAgIHRpbWUuZGF5ID0gbnVsbDtcbiAgICB0aW1lLmhvdXIgPSBudWxsO1xuICAgIHRpbWUubWludXRlID0gbnVsbDtcbiAgICB0aW1lLnNlY29uZCA9IG51bGw7XG5cbiAgICB0aGlzLmljYWx0eXBlID0gaWNhbHR5cGUgfHwgXCJkYXRlLWFuZC1vci10aW1lXCI7XG5cbiAgICB0aGlzLmZyb21EYXRhKGRhdGEsIHpvbmUpO1xuICB9O1xuICBJQ0FMLmhlbHBlcnMuaW5oZXJpdHMoSUNBTC5UaW1lLCBJQ0FMLlZDYXJkVGltZSwgLyoqIEBsZW5kcyBJQ0FMLlZDYXJkVGltZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2xhc3MgaWRlbnRpZmllci5cbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IFwidmNhcmR0aW1lXCJcbiAgICAgKi9cbiAgICBpY2FsY2xhc3M6IFwidmNhcmR0aW1lXCIsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBuYW1lLCB0byBiZSB1c2VkIGluIHRoZSBqQ2FsIG9iamVjdC5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IFwiZGF0ZS1hbmQtb3ItdGltZVwiXG4gICAgICovXG4gICAgaWNhbHR5cGU6IFwiZGF0ZS1hbmQtb3ItdGltZVwiLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHRpbWV6b25lLiBUaGlzIGNhbiBlaXRoZXIgYmUgZmxvYXRpbmcsIFVUQywgb3IgYW4gaW5zdGFuY2Ugb2ZcbiAgICAgKiBJQ0FMLlV0Y09mZnNldC5cbiAgICAgKiBAdHlwZSB7SUNBTC5UaW1lem9uZXxJQ0FMLlV0Y09GZnNldH1cbiAgICAgKi9cbiAgICB6b25lOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSB2Y2FyZCBkYXRlL3RpbWUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHJldHVybiB7SUNBTC5WQ2FyZFRpbWV9ICAgICBUaGUgY2xvbmVkIG9iamVjdFxuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgSUNBTC5WQ2FyZFRpbWUodGhpcy5fdGltZSwgdGhpcy56b25lLCB0aGlzLmljYWx0eXBlKTtcbiAgICB9LFxuXG4gICAgX25vcm1hbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGluaGVyaXRkb2NcbiAgICAgKi9cbiAgICB1dGNPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuem9uZSBpbnN0YW5jZW9mIElDQUwuVXRjT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnpvbmUudG9TZWNvbmRzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gSUNBTC5UaW1lLnByb3RvdHlwZS51dGNPZmZzZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBSRkMgNjM1MCBjb21wbGlhbnQgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgdmNhcmQgZGF0ZS90aW1lIHN0cmluZ1xuICAgICAqL1xuICAgIHRvSUNBTFN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gSUNBTC5kZXNpZ24udmNhcmQudmFsdWVbdGhpcy5pY2FsdHlwZV0udG9JQ0FMKHRoaXMudG9TdHJpbmcoKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBkYXRlL3RpbWUsIGluIGpDYXJkIGZvcm1cbiAgICAgKiAoaW5jbHVkaW5nIDogYW5kIC0gc2VwYXJhdG9ycykuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHZhciBwMiA9IElDQUwuaGVscGVycy5wYWQyO1xuICAgICAgdmFyIHkgPSB0aGlzLnllYXIsIG0gPSB0aGlzLm1vbnRoLCBkID0gdGhpcy5kYXk7XG4gICAgICB2YXIgaCA9IHRoaXMuaG91ciwgbW0gPSB0aGlzLm1pbnV0ZSwgcyA9IHRoaXMuc2Vjb25kO1xuXG4gICAgICB2YXIgaGFzWWVhciA9IHkgIT09IG51bGwsIGhhc01vbnRoID0gbSAhPT0gbnVsbCwgaGFzRGF5ID0gZCAhPT0gbnVsbDtcbiAgICAgIHZhciBoYXNIb3VyID0gaCAhPT0gbnVsbCwgaGFzTWludXRlID0gbW0gIT09IG51bGwsIGhhc1NlY29uZCA9IHMgIT09IG51bGw7XG5cbiAgICAgIHZhciBkYXRlcGFydCA9IChoYXNZZWFyID8gcDIoeSkgKyAoaGFzTW9udGggfHwgaGFzRGF5ID8gJy0nIDogJycpIDogKGhhc01vbnRoIHx8IGhhc0RheSA/ICctLScgOiAnJykpICtcbiAgICAgICAgICAgICAgICAgICAgIChoYXNNb250aCA/IHAyKG0pIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgIChoYXNEYXkgPyAnLScgKyBwMihkKSA6ICcnKTtcbiAgICAgIHZhciB0aW1lcGFydCA9IChoYXNIb3VyID8gcDIoaCkgOiAnLScpICsgKGhhc0hvdXIgJiYgaGFzTWludXRlID8gJzonIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgIChoYXNNaW51dGUgPyBwMihtbSkgOiAnJykgKyAoIWhhc0hvdXIgJiYgIWhhc01pbnV0ZSA/ICctJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICAoaGFzTWludXRlICYmIGhhc1NlY29uZCA/ICc6JyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICAoaGFzU2Vjb25kID8gcDIocykgOiAnJyk7XG5cbiAgICAgIHZhciB6b25lO1xuICAgICAgaWYgKHRoaXMuem9uZSA9PT0gSUNBTC5UaW1lem9uZS51dGNUaW1lem9uZSkge1xuICAgICAgICB6b25lID0gJ1onO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnpvbmUgaW5zdGFuY2VvZiBJQ0FMLlV0Y09mZnNldCkge1xuICAgICAgICB6b25lID0gdGhpcy56b25lLnRvU3RyaW5nKCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuem9uZSA9PT0gSUNBTC5UaW1lem9uZS5sb2NhbFRpbWV6b25lKSB7XG4gICAgICAgIHpvbmUgPSAnJztcbiAgICAgIH0gZWxzZSBpZiAodGhpcy56b25lIGluc3RhbmNlb2YgSUNBTC5UaW1lem9uZSkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gSUNBTC5VdGNPZmZzZXQuZnJvbVNlY29uZHModGhpcy56b25lLnV0Y09mZnNldCh0aGlzKSk7XG4gICAgICAgIHpvbmUgPSBvZmZzZXQudG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHpvbmUgPSAnJztcbiAgICAgIH1cblxuICAgICAgc3dpdGNoICh0aGlzLmljYWx0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJ0aW1lXCI6XG4gICAgICAgICAgcmV0dXJuIHRpbWVwYXJ0ICsgem9uZTtcbiAgICAgICAgY2FzZSBcImRhdGUtYW5kLW9yLXRpbWVcIjpcbiAgICAgICAgY2FzZSBcImRhdGUtdGltZVwiOlxuICAgICAgICAgIHJldHVybiBkYXRlcGFydCArICh0aW1lcGFydCA9PSAnLS0nID8gJycgOiAnVCcgKyB0aW1lcGFydCArIHpvbmUpO1xuICAgICAgICBjYXNlIFwiZGF0ZVwiOlxuICAgICAgICAgIHJldHVybiBkYXRlcGFydDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgSUNBTC5WQ2FyZFRpbWUgaW5zdGFuY2UgZnJvbSBhIGRhdGUgYW5kL29yIHRpbWUgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYVZhbHVlICAgICBUaGUgc3RyaW5nIHRvIGNyZWF0ZSBmcm9tXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhSWNhbFR5cGUgIFRoZSB0eXBlIGZvciB0aGlzIGluc3RhbmNlLCBlLmcuIGRhdGUtYW5kLW9yLXRpbWVcbiAgICogQHJldHVybiB7SUNBTC5WQ2FyZFRpbWV9ICAgVGhlIGRhdGUvdGltZSBpbnN0YW5jZVxuICAgKi9cbiAgSUNBTC5WQ2FyZFRpbWUuZnJvbURhdGVBbmRPclRpbWVTdHJpbmcgPSBmdW5jdGlvbihhVmFsdWUsIGFJY2FsVHlwZSkge1xuICAgIGZ1bmN0aW9uIHBhcnQodiwgcywgZSkge1xuICAgICAgcmV0dXJuIHYgPyBJQ0FMLmhlbHBlcnMuc3RyaWN0UGFyc2VJbnQodi5zdWJzdHIocywgZSkpIDogbnVsbDtcbiAgICB9XG4gICAgdmFyIHBhcnRzID0gYVZhbHVlLnNwbGl0KCdUJyk7XG4gICAgdmFyIGR0ID0gcGFydHNbMF0sIHRteiA9IHBhcnRzWzFdO1xuICAgIHZhciBzcGxpdHpvbmUgPSB0bXogPyBJQ0FMLmRlc2lnbi52Y2FyZC52YWx1ZS50aW1lLl9zcGxpdFpvbmUodG16KSA6IFtdO1xuICAgIHZhciB6b25lID0gc3BsaXR6b25lWzBdLCB0bSA9IHNwbGl0em9uZVsxXTtcblxuICAgIHZhciBzdG9pID0gSUNBTC5oZWxwZXJzLnN0cmljdFBhcnNlSW50O1xuICAgIHZhciBkdGxlbiA9IGR0ID8gZHQubGVuZ3RoIDogMDtcbiAgICB2YXIgdG1sZW4gPSB0bSA/IHRtLmxlbmd0aCA6IDA7XG5cbiAgICB2YXIgaGFzRGFzaERhdGUgPSBkdCAmJiBkdFswXSA9PSAnLScgJiYgZHRbMV0gPT0gJy0nO1xuICAgIHZhciBoYXNEYXNoVGltZSA9IHRtICYmIHRtWzBdID09ICctJztcblxuICAgIHZhciBvID0ge1xuICAgICAgeWVhcjogaGFzRGFzaERhdGUgPyBudWxsIDogcGFydChkdCwgMCwgNCksXG4gICAgICBtb250aDogaGFzRGFzaERhdGUgJiYgKGR0bGVuID09IDQgfHwgZHRsZW4gPT0gNykgPyBwYXJ0KGR0LCAyLCAyKSA6IGR0bGVuID09IDcgPyBwYXJ0KGR0LCA1LCAyKSA6IGR0bGVuID09IDEwID8gcGFydChkdCwgNSwgMikgOiBudWxsLFxuICAgICAgZGF5OiBkdGxlbiA9PSA1ID8gcGFydChkdCwgMywgMikgOiBkdGxlbiA9PSA3ICYmIGhhc0Rhc2hEYXRlID8gcGFydChkdCwgNSwgMikgOiBkdGxlbiA9PSAxMCA/IHBhcnQoZHQsIDgsIDIpIDogbnVsbCxcblxuICAgICAgaG91cjogaGFzRGFzaFRpbWUgPyBudWxsIDogcGFydCh0bSwgMCwgMiksXG4gICAgICBtaW51dGU6IGhhc0Rhc2hUaW1lICYmIHRtbGVuID09IDMgPyBwYXJ0KHRtLCAxLCAyKSA6IHRtbGVuID4gNCA/IGhhc0Rhc2hUaW1lID8gcGFydCh0bSwgMSwgMikgOiBwYXJ0KHRtLCAzLCAyKSA6IG51bGwsXG4gICAgICBzZWNvbmQ6IHRtbGVuID09IDQgPyBwYXJ0KHRtLCAyLCAyKSA6IHRtbGVuID09IDYgPyBwYXJ0KHRtLCA0LCAyKSA6IHRtbGVuID09IDggPyBwYXJ0KHRtLCA2LCAyKSA6IG51bGxcbiAgICB9O1xuXG4gICAgaWYgKHpvbmUgPT0gJ1onKSB7XG4gICAgICB6b25lID0gSUNBTC5UaW1lem9uZS51dGNUaW1lem9uZTtcbiAgICB9IGVsc2UgaWYgKHpvbmUgJiYgem9uZVszXSA9PSAnOicpIHtcbiAgICAgIHpvbmUgPSBJQ0FMLlV0Y09mZnNldC5mcm9tU3RyaW5nKHpvbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB6b25lID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IElDQUwuVkNhcmRUaW1lKG8sIHpvbmUsIGFJY2FsVHlwZSk7XG4gIH07XG59KSgpO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoLCAyMDExLTIwMTUgKi9cblxuXG5cbihmdW5jdGlvbigpIHtcbiAgdmFyIERPV19NQVAgPSB7XG4gICAgU1U6IElDQUwuVGltZS5TVU5EQVksXG4gICAgTU86IElDQUwuVGltZS5NT05EQVksXG4gICAgVFU6IElDQUwuVGltZS5UVUVTREFZLFxuICAgIFdFOiBJQ0FMLlRpbWUuV0VETkVTREFZLFxuICAgIFRIOiBJQ0FMLlRpbWUuVEhVUlNEQVksXG4gICAgRlI6IElDQUwuVGltZS5GUklEQVksXG4gICAgU0E6IElDQUwuVGltZS5TQVRVUkRBWVxuICB9O1xuXG4gIHZhciBSRVZFUlNFX0RPV19NQVAgPSB7fTtcbiAgZm9yICh2YXIga2V5IGluIERPV19NQVApIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChET1dfTUFQLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIFJFVkVSU0VfRE9XX01BUFtET1dfTUFQW2tleV1dID0ga2V5O1xuICAgIH1cbiAgfVxuXG4gIHZhciBDT1BZX1BBUlRTID0gW1wiQllTRUNPTkRcIiwgXCJCWU1JTlVURVwiLCBcIkJZSE9VUlwiLCBcIkJZREFZXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiQllNT05USERBWVwiLCBcIkJZWUVBUkRBWVwiLCBcIkJZV0VFS05PXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiQllNT05USFwiLCBcIkJZU0VUUE9TXCJdO1xuXG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIFRoaXMgY2xhc3MgcmVwcmVzZW50cyB0aGUgXCJyZWN1clwiIHZhbHVlIHR5cGUsIHdpdGggdmFyaW91cyBjYWxjdWxhdGlvblxuICAgKiBhbmQgbWFuaXB1bGF0aW9uIG1ldGhvZHMuXG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAYWxpYXMgSUNBTC5SZWN1clxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbiBvYmplY3Qgd2l0aCBtZW1iZXJzIG9mIHRoZSByZWN1cnJlbmNlXG4gICAqIEBwYXJhbSB7SUNBTC5SZWN1ci5mcmVxdWVuY3lWYWx1ZXM9fSBkYXRhLmZyZXEgICAgIFRoZSBmcmVxdWVuY3kgdmFsdWVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLmludGVydmFsICAgICAgICAgICAgICAgICAgICAgVGhlIElOVEVSVkFMIHZhbHVlXG4gICAqIEBwYXJhbSB7SUNBTC5UaW1lLndlZWtEYXk9fSBkYXRhLndrc3QgICAgICAgICAgICAgIFRoZSB3ZWVrIHN0YXJ0IHZhbHVlXG4gICAqIEBwYXJhbSB7SUNBTC5UaW1lPX0gZGF0YS51bnRpbCAgICAgICAgICAgICAgICAgICAgIFRoZSBlbmQgb2YgdGhlIHJlY3VycmVuY2Ugc2V0XG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS5jb3VudCAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBudW1iZXIgb2Ygb2NjdXJyZW5jZXNcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGRhdGEuYnlzZWNvbmQgICAgICAgICAgICAgVGhlIHNlY29uZHMgZm9yIHRoZSBCWVNFQ09ORCBwYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBkYXRhLmJ5bWludXRlICAgICAgICAgICAgIFRoZSBtaW51dGVzIGZvciB0aGUgQllNSU5VVEUgcGFydFxuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gZGF0YS5ieWhvdXIgICAgICAgICAgICAgICBUaGUgaG91cnMgZm9yIHRoZSBCWUhPVVIgcGFydFxuICAgKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+PX0gZGF0YS5ieWRheSAgICAgICAgICAgICAgICBUaGUgQllEQVkgdmFsdWVzXG4gICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBkYXRhLmJ5bW9udGhkYXkgICAgICAgICAgIFRoZSBkYXlzIGZvciB0aGUgQllNT05USERBWSBwYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBkYXRhLmJ5eWVhcmRheSAgICAgICAgICAgIFRoZSBkYXlzIGZvciB0aGUgQllZRUFSREFZIHBhcnRcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGRhdGEuYnl3ZWVrbm8gICAgICAgICAgICAgVGhlIHdlZWtzIGZvciB0aGUgQllXRUVLTk8gcGFydFxuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gZGF0YS5ieW1vbnRoICAgICAgICAgICAgICBUaGUgbW9udGggZm9yIHRoZSBCWU1PTlRIIHBhcnRcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGRhdGEuYnlzZXRwb3MgICAgICAgICAgICAgVGhlIHBvc2l0aW9uYWxzIGZvciB0aGUgQllTRVRQT1MgcGFydFxuICAgKi9cbiAgSUNBTC5SZWN1ciA9IGZ1bmN0aW9uIGljYWxyZWN1cihkYXRhKSB7XG4gICAgdGhpcy53cmFwcGVkSlNPYmplY3QgPSB0aGlzO1xuICAgIHRoaXMucGFydHMgPSB7fTtcblxuICAgIGlmIChkYXRhICYmIHR5cGVvZihkYXRhKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHRoaXMuZnJvbURhdGEoZGF0YSk7XG4gICAgfVxuICB9O1xuXG4gIElDQUwuUmVjdXIucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCBob2xkaW5nIHRoZSBCWS1wYXJ0cyBvZiB0aGUgcmVjdXJyZW5jZSBydWxlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICBwYXJ0czogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnRlcnZhbCB2YWx1ZSBmb3IgdGhlIHJlY3VycmVuY2UgcnVsZS5cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIGludGVydmFsOiAxLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHdlZWsgc3RhcnQgZGF5XG4gICAgICpcbiAgICAgKiBAdHlwZSB7SUNBTC5UaW1lLndlZWtEYXl9XG4gICAgICogQGRlZmF1bHQgSUNBTC5UaW1lLk1PTkRBWVxuICAgICAqL1xuICAgIHdrc3Q6IElDQUwuVGltZS5NT05EQVksXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZW5kIG9mIHRoZSByZWN1cnJlbmNlXG4gICAgICogQHR5cGUgez9JQ0FMLlRpbWV9XG4gICAgICovXG4gICAgdW50aWw6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2Ygb2NjdXJyZW5jZXNcbiAgICAgKiBAdHlwZSB7P051bWJlcn1cbiAgICAgKi9cbiAgICBjb3VudDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBmcmVxdWVuY3kgdmFsdWUuXG4gICAgICogQHR5cGUge0lDQUwuUmVjdXIuZnJlcXVlbmN5VmFsdWVzfVxuICAgICAqL1xuICAgIGZyZXE6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2xhc3MgaWRlbnRpZmllci5cbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IFwiaWNhbHJlY3VyXCJcbiAgICAgKi9cbiAgICBpY2FsY2xhc3M6IFwiaWNhbHJlY3VyXCIsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBuYW1lLCB0byBiZSB1c2VkIGluIHRoZSBqQ2FsIG9iamVjdC5cbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IFwicmVjdXJcIlxuICAgICAqL1xuICAgIGljYWx0eXBlOiBcInJlY3VyXCIsXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgaXRlcmF0b3IgZm9yIHRoaXMgcmVjdXJyZW5jZSBydWxlLiBUaGUgcGFzc2VkIHN0YXJ0IGRhdGVcbiAgICAgKiBtdXN0IGJlIHRoZSBzdGFydCBkYXRlIG9mIHRoZSBldmVudCwgbm90IHRoZSBzdGFydCBvZiB0aGUgcmFuZ2UgdG9cbiAgICAgKiBzZWFyY2ggaW4uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciByZWN1ciA9IGNvbXAuZ2V0Rmlyc3RQcm9wZXJ0eVZhbHVlKCdycnVsZScpO1xuICAgICAqIHZhciBkdHN0YXJ0ID0gY29tcC5nZXRGaXJzdFByb3BlcnR5VmFsdWUoJ2R0c3RhcnQnKTtcbiAgICAgKiB2YXIgaXRlciA9IHJlY3VyLml0ZXJhdG9yKGR0c3RhcnQpO1xuICAgICAqIGZvciAodmFyIG5leHQgPSBpdGVyLm5leHQoKTsgbmV4dDsgbmV4dCA9IGl0ZXIubmV4dCgpKSB7XG4gICAgICogICBpZiAobmV4dC5jb21wYXJlKHJhbmdlU3RhcnQpIDwgMCkge1xuICAgICAqICAgICBjb250aW51ZTtcbiAgICAgKiAgIH1cbiAgICAgKiAgIGNvbnNvbGUubG9nKG5leHQudG9TdHJpbmcoKSk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWV9IGFTdGFydCAgICAgICAgVGhlIGl0ZW0ncyBzdGFydCBkYXRlXG4gICAgICogQHJldHVybiB7SUNBTC5SZWN1ckl0ZXJhdG9yfSAgICAgVGhlIHJlY3VycmVuY2UgaXRlcmF0b3JcbiAgICAgKi9cbiAgICBpdGVyYXRvcjogZnVuY3Rpb24oYVN0YXJ0KSB7XG4gICAgICByZXR1cm4gbmV3IElDQUwuUmVjdXJJdGVyYXRvcih7XG4gICAgICAgIHJ1bGU6IHRoaXMsXG4gICAgICAgIGR0c3RhcnQ6IGFTdGFydFxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgcmVjdXJyZW5jZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlJlY3VyfSAgICAgIFRoZSBjbG9uZWQgb2JqZWN0XG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgcmV0dXJuIG5ldyBJQ0FMLlJlY3VyKHRoaXMudG9KU09OKCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGN1cnJlbnQgcnVsZSBpcyBmaW5pdGUsIGkuZS4gaGFzIGEgY291bnQgb3IgdW50aWwgcGFydC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICBUcnVlLCBpZiB0aGUgcnVsZSBpcyBmaW5pdGVcbiAgICAgKi9cbiAgICBpc0Zpbml0ZTogZnVuY3Rpb24gaXNmaW5pdGUoKSB7XG4gICAgICByZXR1cm4gISEodGhpcy5jb3VudCB8fCB0aGlzLnVudGlsKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBjdXJyZW50IHJ1bGUgaGFzIGEgY291bnQgcGFydCwgYW5kIG5vdCBsaW1pdGVkIGJ5IGFuIHVudGlsXG4gICAgICogcGFydC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICBUcnVlLCBpZiB0aGUgcnVsZSBpcyBieSBjb3VudFxuICAgICAqL1xuICAgIGlzQnlDb3VudDogZnVuY3Rpb24gaXNieWNvdW50KCkge1xuICAgICAgcmV0dXJuICEhKHRoaXMuY291bnQgJiYgIXRoaXMudW50aWwpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgY29tcG9uZW50IChwYXJ0KSB0byB0aGUgcmVjdXJyZW5jZSBydWxlLiBUaGlzIGlzIG5vdCBhIGNvbXBvbmVudFxuICAgICAqIGluIHRoZSBzZW5zZSBvZiB7QGxpbmsgSUNBTC5Db21wb25lbnR9LCBidXQgYSBwYXJ0IG9mIHRoZSByZWN1cnJlbmNlXG4gICAgICogcnVsZSwgaS5lLiBCWU1PTlRILlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFUeXBlICAgICAgICAgICAgVGhlIG5hbWUgb2YgdGhlIGNvbXBvbmVudCBwYXJ0XG4gICAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IGFWYWx1ZSAgICAgVGhlIGNvbXBvbmVudCB2YWx1ZVxuICAgICAqL1xuICAgIGFkZENvbXBvbmVudDogZnVuY3Rpb24gYWRkUGFydChhVHlwZSwgYVZhbHVlKSB7XG4gICAgICB2YXIgdWNuYW1lID0gYVR5cGUudG9VcHBlckNhc2UoKTtcbiAgICAgIGlmICh1Y25hbWUgaW4gdGhpcy5wYXJ0cykge1xuICAgICAgICB0aGlzLnBhcnRzW3VjbmFtZV0ucHVzaChhVmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXJ0c1t1Y25hbWVdID0gW2FWYWx1ZV07XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNvbXBvbmVudCB2YWx1ZSBmb3IgdGhlIGdpdmVuIGJ5LXBhcnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYVR5cGUgICAgICAgIFRoZSBjb21wb25lbnQgcGFydCBuYW1lXG4gICAgICogQHBhcmFtIHtBcnJheX0gYVZhbHVlcyAgICAgICBUaGUgY29tcG9uZW50IHZhbHVlc1xuICAgICAqL1xuICAgIHNldENvbXBvbmVudDogZnVuY3Rpb24gc2V0Q29tcG9uZW50KGFUeXBlLCBhVmFsdWVzKSB7XG4gICAgICB0aGlzLnBhcnRzW2FUeXBlLnRvVXBwZXJDYXNlKCldID0gYVZhbHVlcy5zbGljZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIChhIGNvcHkpIG9mIHRoZSByZXF1ZXN0ZWQgY29tcG9uZW50IHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFUeXBlICAgICAgICBUaGUgY29tcG9uZW50IHBhcnQgbmFtZVxuICAgICAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICAgICAgVGhlIGNvbXBvbmVudCBwYXJ0IHZhbHVlXG4gICAgICovXG4gICAgZ2V0Q29tcG9uZW50OiBmdW5jdGlvbiBnZXRDb21wb25lbnQoYVR5cGUpIHtcbiAgICAgIHZhciB1Y25hbWUgPSBhVHlwZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgcmV0dXJuICh1Y25hbWUgaW4gdGhpcy5wYXJ0cyA/IHRoaXMucGFydHNbdWNuYW1lXS5zbGljZSgpIDogW10pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIG5leHQgb2NjdXJyZW5jZSBhZnRlciB0aGUgZ2l2ZW4gcmVjdXJyZW5jZSBpZC4gU2VlIHRoZVxuICAgICAqIGd1aWRlIG9uIHtAdHV0b3JpYWwgdGVybWlub2xvZ3l9IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBOT1RFOiBDdXJyZW50bHksIHRoaXMgbWV0aG9kIGl0ZXJhdGVzIGFsbCBvY2N1cnJlbmNlcyBmcm9tIHRoZSBzdGFydFxuICAgICAqIGRhdGUuIEl0IHNob3VsZCBub3QgYmUgY2FsbGVkIGluIGEgbG9vcCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4gSWYgeW91XG4gICAgICogd291bGQgbGlrZSB0byBnZXQgbW9yZSB0aGFuIG9uZSBvY2N1cnJlbmNlLCB5b3UgY2FuIGl0ZXJhdGUgdGhlXG4gICAgICogb2NjdXJyZW5jZXMgbWFudWFsbHksIHNlZSB0aGUgZXhhbXBsZSBvbiB0aGVcbiAgICAgKiB7QGxpbmsgSUNBTC5SZWN1ciNpdGVyYXRvciBpdGVyYXRvcn0gbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWV9IGFTdGFydFRpbWUgICAgICAgIFRoZSBzdGFydCBvZiB0aGUgZXZlbnQgc2VyaWVzXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWV9IGFSZWN1cnJlbmNlSWQgICAgIFRoZSBkYXRlIG9mIHRoZSBsYXN0IG9jY3VycmVuY2VcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlRpbWV9ICAgICAgICAgICAgICAgICAgVGhlIG5leHQgb2NjdXJyZW5jZSBhZnRlclxuICAgICAqL1xuICAgIGdldE5leHRPY2N1cnJlbmNlOiBmdW5jdGlvbiBnZXROZXh0T2NjdXJyZW5jZShhU3RhcnRUaW1lLCBhUmVjdXJyZW5jZUlkKSB7XG4gICAgICB2YXIgaXRlciA9IHRoaXMuaXRlcmF0b3IoYVN0YXJ0VGltZSk7XG4gICAgICB2YXIgbmV4dCwgY2R0O1xuXG4gICAgICBkbyB7XG4gICAgICAgIG5leHQgPSBpdGVyLm5leHQoKTtcbiAgICAgIH0gd2hpbGUgKG5leHQgJiYgbmV4dC5jb21wYXJlKGFSZWN1cnJlbmNlSWQpIDw9IDApO1xuXG4gICAgICBpZiAobmV4dCAmJiBhUmVjdXJyZW5jZUlkLnpvbmUpIHtcbiAgICAgICAgbmV4dC56b25lID0gYVJlY3VycmVuY2VJZC56b25lO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB1cCB0aGUgY3VycmVudCBpbnN0YW5jZSB1c2luZyBtZW1iZXJzIGZyb20gdGhlIHBhc3NlZCBkYXRhIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFuIG9iamVjdCB3aXRoIG1lbWJlcnMgb2YgdGhlIHJlY3VycmVuY2VcbiAgICAgKiBAcGFyYW0ge0lDQUwuUmVjdXIuZnJlcXVlbmN5VmFsdWVzPX0gZGF0YS5mcmVxICAgICBUaGUgZnJlcXVlbmN5IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLmludGVydmFsICAgICAgICAgICAgICAgICAgICAgVGhlIElOVEVSVkFMIHZhbHVlXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWUud2Vla0RheT19IGRhdGEud2tzdCAgICAgICAgICAgICAgVGhlIHdlZWsgc3RhcnQgdmFsdWVcbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZT19IGRhdGEudW50aWwgICAgICAgICAgICAgICAgICAgICBUaGUgZW5kIG9mIHRoZSByZWN1cnJlbmNlIHNldFxuICAgICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS5jb3VudCAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBudW1iZXIgb2Ygb2NjdXJyZW5jZXNcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gZGF0YS5ieXNlY29uZCAgICAgICAgICAgICBUaGUgc2Vjb25kcyBmb3IgdGhlIEJZU0VDT05EIHBhcnRcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gZGF0YS5ieW1pbnV0ZSAgICAgICAgICAgICBUaGUgbWludXRlcyBmb3IgdGhlIEJZTUlOVVRFIHBhcnRcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gZGF0YS5ieWhvdXIgICAgICAgICAgICAgICBUaGUgaG91cnMgZm9yIHRoZSBCWUhPVVIgcGFydFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz49fSBkYXRhLmJ5ZGF5ICAgICAgICAgICAgICAgIFRoZSBCWURBWSB2YWx1ZXNcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gZGF0YS5ieW1vbnRoZGF5ICAgICAgICAgICBUaGUgZGF5cyBmb3IgdGhlIEJZTU9OVEhEQVkgcGFydFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBkYXRhLmJ5eWVhcmRheSAgICAgICAgICAgIFRoZSBkYXlzIGZvciB0aGUgQllZRUFSREFZIHBhcnRcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gZGF0YS5ieXdlZWtubyAgICAgICAgICAgICBUaGUgd2Vla3MgZm9yIHRoZSBCWVdFRUtOTyBwYXJ0XG4gICAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGRhdGEuYnltb250aCAgICAgICAgICAgICAgVGhlIG1vbnRoIGZvciB0aGUgQllNT05USCBwYXJ0XG4gICAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGRhdGEuYnlzZXRwb3MgICAgICAgICAgICAgVGhlIHBvc2l0aW9uYWxzIGZvciB0aGUgQllTRVRQT1MgcGFydFxuICAgICAqL1xuICAgIGZyb21EYXRhOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICB2YXIgdWNrZXkgPSBrZXkudG9VcHBlckNhc2UoKTtcblxuICAgICAgICBpZiAodWNrZXkgaW4gcGFydERlc2lnbikge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGFba2V5XSkpIHtcbiAgICAgICAgICAgIHRoaXMucGFydHNbdWNrZXldID0gZGF0YVtrZXldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBhcnRzW3Vja2V5XSA9IFtkYXRhW2tleV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzW2tleV0gPSBkYXRhW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaW50ZXJ2YWwgJiYgdHlwZW9mIHRoaXMuaW50ZXJ2YWwgIT0gXCJudW1iZXJcIikge1xuICAgICAgICBvcHRpb25EZXNpZ24uSU5URVJWQUwodGhpcy5pbnRlcnZhbCwgdGhpcyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLndrc3QgJiYgdHlwZW9mIHRoaXMud2tzdCAhPSBcIm51bWJlclwiKSB7XG4gICAgICAgIHRoaXMud2tzdCA9IElDQUwuUmVjdXIuaWNhbERheVRvTnVtZXJpY0RheSh0aGlzLndrc3QpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy51bnRpbCAmJiAhKHRoaXMudW50aWwgaW5zdGFuY2VvZiBJQ0FMLlRpbWUpKSB7XG4gICAgICAgIHRoaXMudW50aWwgPSBJQ0FMLlRpbWUuZnJvbVN0cmluZyh0aGlzLnVudGlsKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGpDYWwgcmVwcmVzZW50YXRpb24gb2YgdGhpcyByZWN1cnJlbmNlIHR5cGUuXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHJlcy5mcmVxID0gdGhpcy5mcmVxO1xuXG4gICAgICBpZiAodGhpcy5jb3VudCkge1xuICAgICAgICByZXMuY291bnQgPSB0aGlzLmNvdW50O1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pbnRlcnZhbCA+IDEpIHtcbiAgICAgICAgcmVzLmludGVydmFsID0gdGhpcy5pbnRlcnZhbDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgayBpbiB0aGlzLnBhcnRzKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIXRoaXMucGFydHMuaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIga3BhcnRzID0gdGhpcy5wYXJ0c1trXTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoa3BhcnRzKSAmJiBrcGFydHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICByZXNbay50b0xvd2VyQ2FzZSgpXSA9IGtwYXJ0c1swXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNbay50b0xvd2VyQ2FzZSgpXSA9IElDQUwuaGVscGVycy5jbG9uZSh0aGlzLnBhcnRzW2tdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy51bnRpbCkge1xuICAgICAgICByZXMudW50aWwgPSB0aGlzLnVudGlsLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICBpZiAoJ3drc3QnIGluIHRoaXMgJiYgdGhpcy53a3N0ICE9PSBJQ0FMLlRpbWUuREVGQVVMVF9XRUVLX1NUQVJUKSB7XG4gICAgICAgIHJlcy53a3N0ID0gSUNBTC5SZWN1ci5udW1lcmljRGF5VG9JY2FsRGF5KHRoaXMud2tzdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgcmVjdXJyZW5jZSBydWxlLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24gaWNhbHJlY3VyX3RvU3RyaW5nKCkge1xuICAgICAgLy8gVE9ETyByZXRhaW4gb3JkZXJcbiAgICAgIHZhciBzdHIgPSBcIkZSRVE9XCIgKyB0aGlzLmZyZXE7XG4gICAgICBpZiAodGhpcy5jb3VudCkge1xuICAgICAgICBzdHIgKz0gXCI7Q09VTlQ9XCIgKyB0aGlzLmNvdW50O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaW50ZXJ2YWwgPiAxKSB7XG4gICAgICAgIHN0ciArPSBcIjtJTlRFUlZBTD1cIiArIHRoaXMuaW50ZXJ2YWw7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrIGluIHRoaXMucGFydHMpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKHRoaXMucGFydHMuaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICBzdHIgKz0gXCI7XCIgKyBrICsgXCI9XCIgKyB0aGlzLnBhcnRzW2tdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy51bnRpbCkge1xuICAgICAgICBzdHIgKz0gJztVTlRJTD0nICsgdGhpcy51bnRpbC50b0lDQUxTdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGlmICgnd2tzdCcgaW4gdGhpcyAmJiB0aGlzLndrc3QgIT09IElDQUwuVGltZS5ERUZBVUxUX1dFRUtfU1RBUlQpIHtcbiAgICAgICAgc3RyICs9ICc7V0tTVD0nICsgSUNBTC5SZWN1ci5udW1lcmljRGF5VG9JY2FsRGF5KHRoaXMud2tzdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZU51bWVyaWNWYWx1ZSh0eXBlLCBtaW4sIG1heCwgdmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gdmFsdWU7XG5cbiAgICBpZiAodmFsdWVbMF0gPT09ICcrJykge1xuICAgICAgcmVzdWx0ID0gdmFsdWUuc3Vic3RyKDEpO1xuICAgIH1cblxuICAgIHJlc3VsdCA9IElDQUwuaGVscGVycy5zdHJpY3RQYXJzZUludChyZXN1bHQpO1xuXG4gICAgaWYgKG1pbiAhPT0gdW5kZWZpbmVkICYmIHZhbHVlIDwgbWluKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIHR5cGUgKyAnOiBpbnZhbGlkIHZhbHVlIFwiJyArIHZhbHVlICsgJ1wiIG11c3QgYmUgPiAnICsgbWluXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChtYXggIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA+IG1heCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICB0eXBlICsgJzogaW52YWxpZCB2YWx1ZSBcIicgKyB2YWx1ZSArICdcIiBtdXN0IGJlIDwgJyArIG1pblxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYW4gaWNhbCByZXByZXNlbnRhdGlvbiBvZiBhIGRheSAoU1UsIE1PLCBldGMuLilcbiAgICogaW50byBhIG51bWVyaWMgdmFsdWUgb2YgdGhhdCBkYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgICAgIFRoZSBpQ2FsZW5kYXIgZGF5IG5hbWVcbiAgICogQHBhcmFtIHtJQ0FMLlRpbWUud2Vla0RheT19IGFXZWVrU3RhcnRcbiAgICogICAgICAgIFRoZSB3ZWVrIHN0YXJ0IHdlZWtkYXksIGRlZmF1bHRzIHRvIFNVTkRBWVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICBOdW1lcmljIHZhbHVlIG9mIGdpdmVuIGRheVxuICAgKi9cbiAgSUNBTC5SZWN1ci5pY2FsRGF5VG9OdW1lcmljRGF5ID0gZnVuY3Rpb24gdG9OdW1lcmljRGF5KHN0cmluZywgYVdlZWtTdGFydCkge1xuICAgIC8vWFhYOiB0aGlzIGlzIGhlcmUgc28gd2UgY2FuIGRlYWxcbiAgICAvLyAgICAgd2l0aCBwb3NzaWJseSBpbnZhbGlkIHN0cmluZyB2YWx1ZXMuXG4gICAgdmFyIGZpcnN0RG93ID0gYVdlZWtTdGFydCB8fCBJQ0FMLlRpbWUuU1VOREFZO1xuICAgIHJldHVybiAoKERPV19NQVBbc3RyaW5nXSAtIGZpcnN0RG93ICsgNykgJSA3KSArIDE7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBudW1lcmljIGRheSB2YWx1ZSBpbnRvIGl0cyBpY2FsIHJlcHJlc2VudGF0aW9uIChTVSwgTU8sIGV0Yy4uKVxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gbnVtICAgICAgICBOdW1lcmljIHZhbHVlIG9mIGdpdmVuIGRheVxuICAgKiBAcGFyYW0ge0lDQUwuVGltZS53ZWVrRGF5PX0gYVdlZWtTdGFydFxuICAgKiAgICAgICAgVGhlIHdlZWsgc3RhcnQgd2Vla2RheSwgZGVmYXVsdHMgdG8gU1VOREFZXG4gICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgIFRoZSBJQ0FMIGRheSB2YWx1ZSwgZS5nIFNVLE1PLC4uLlxuICAgKi9cbiAgSUNBTC5SZWN1ci5udW1lcmljRGF5VG9JY2FsRGF5ID0gZnVuY3Rpb24gdG9JY2FsRGF5KG51bSwgYVdlZWtTdGFydCkge1xuICAgIC8vWFhYOiB0aGlzIGlzIGhlcmUgc28gd2UgY2FuIGRlYWwgd2l0aCBwb3NzaWJseSBpbnZhbGlkIG51bWJlciB2YWx1ZXMuXG4gICAgLy8gICAgIEFsc28sIHRoaXMgYWxsb3dzIGNvbnNpc3RlbnQgbWFwcGluZyBiZXR3ZWVuIGRheSBudW1iZXJzIGFuZCBkYXlcbiAgICAvLyAgICAgbmFtZXMgZm9yIGV4dGVybmFsIHVzZXJzLlxuICAgIHZhciBmaXJzdERvdyA9IGFXZWVrU3RhcnQgfHwgSUNBTC5UaW1lLlNVTkRBWTtcbiAgICB2YXIgZG93ID0gKG51bSArIGZpcnN0RG93IC0gSUNBTC5UaW1lLlNVTkRBWSk7XG4gICAgaWYgKGRvdyA+IDcpIHtcbiAgICAgIGRvdyAtPSA3O1xuICAgIH1cbiAgICByZXR1cm4gUkVWRVJTRV9ET1dfTUFQW2Rvd107XG4gIH07XG5cbiAgdmFyIFZBTElEX0RBWV9OQU1FUyA9IC9eKFNVfE1PfFRVfFdFfFRIfEZSfFNBKSQvO1xuICB2YXIgVkFMSURfQllEQVlfUEFSVCA9IC9eKFsrLV0pPyg1WzAtM118WzEtNF1bMC05XXxbMS05XSk/KFNVfE1PfFRVfFdFfFRIfEZSfFNBKSQvO1xuXG4gIC8qKlxuICAgKiBQb3NzaWJsZSBmcmVxdWVuY3kgdmFsdWVzIGZvciB0aGUgRlJFUSBwYXJ0XG4gICAqIChZRUFSTFksIE1PTlRITFksIFdFRUtMWSwgREFJTFksIEhPVVJMWSwgTUlOVVRFTFksIFNFQ09ORExZKVxuICAgKlxuICAgKiBAdHlwZWRlZiB7U3RyaW5nfSBmcmVxdWVuY3lWYWx1ZXNcbiAgICogQG1lbWJlcm9mIElDQUwuUmVjdXJcbiAgICovXG5cbiAgdmFyIEFMTE9XRURfRlJFUSA9IFsnU0VDT05ETFknLCAnTUlOVVRFTFknLCAnSE9VUkxZJyxcbiAgICAgICAgICAgICAgICAgICAgICAnREFJTFknLCAnV0VFS0xZJywgJ01PTlRITFknLCAnWUVBUkxZJ107XG5cbiAgdmFyIG9wdGlvbkRlc2lnbiA9IHtcbiAgICBGUkVROiBmdW5jdGlvbih2YWx1ZSwgZGljdCwgZm10SWNhbCkge1xuICAgICAgLy8geWVzIHRoaXMgaXMgYWN0dWFsbHkgZXF1YWwgb3IgZmFzdGVyIHRoZW4gcmVnZXguXG4gICAgICAvLyB1cHNpZGUgaGVyZSBpcyB3ZSBjYW4gZW51bWVyYXRlIHRoZSB2YWxpZCB2YWx1ZXMuXG4gICAgICBpZiAoQUxMT1dFRF9GUkVRLmluZGV4T2YodmFsdWUpICE9PSAtMSkge1xuICAgICAgICBkaWN0LmZyZXEgPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnaW52YWxpZCBmcmVxdWVuY3kgXCInICsgdmFsdWUgKyAnXCIgZXhwZWN0ZWQ6IFwiJyArXG4gICAgICAgICAgQUxMT1dFRF9GUkVRLmpvaW4oJywgJykgKyAnXCInXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIENPVU5UOiBmdW5jdGlvbih2YWx1ZSwgZGljdCwgZm10SWNhbCkge1xuICAgICAgZGljdC5jb3VudCA9IElDQUwuaGVscGVycy5zdHJpY3RQYXJzZUludCh2YWx1ZSk7XG4gICAgfSxcblxuICAgIElOVEVSVkFMOiBmdW5jdGlvbih2YWx1ZSwgZGljdCwgZm10SWNhbCkge1xuICAgICAgZGljdC5pbnRlcnZhbCA9IElDQUwuaGVscGVycy5zdHJpY3RQYXJzZUludCh2YWx1ZSk7XG4gICAgICBpZiAoZGljdC5pbnRlcnZhbCA8IDEpIHtcbiAgICAgICAgLy8gMCBvciBuZWdhdGl2ZSB2YWx1ZXMgYXJlIG5vdCBhbGxvd2VkLCBzb21lIGVuZ2luZXMgc2VlbSB0byBnZW5lcmF0ZVxuICAgICAgICAvLyBpdCB0aG91Z2guIEFzc3VtZSAxIGluc3RlYWQuXG4gICAgICAgIGRpY3QuaW50ZXJ2YWwgPSAxO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBVTlRJTDogZnVuY3Rpb24odmFsdWUsIGRpY3QsIGZtdEljYWwpIHtcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAxMCkge1xuICAgICAgICBkaWN0LnVudGlsID0gSUNBTC5kZXNpZ24uaWNhbGVuZGFyLnZhbHVlWydkYXRlLXRpbWUnXS5mcm9tSUNBTCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaWN0LnVudGlsID0gSUNBTC5kZXNpZ24uaWNhbGVuZGFyLnZhbHVlLmRhdGUuZnJvbUlDQUwodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKCFmbXRJY2FsKSB7XG4gICAgICAgIGRpY3QudW50aWwgPSBJQ0FMLlRpbWUuZnJvbVN0cmluZyhkaWN0LnVudGlsKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgV0tTVDogZnVuY3Rpb24odmFsdWUsIGRpY3QsIGZtdEljYWwpIHtcbiAgICAgIGlmIChWQUxJRF9EQVlfTkFNRVMudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgZGljdC53a3N0ID0gSUNBTC5SZWN1ci5pY2FsRGF5VG9OdW1lcmljRGF5KHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBXS1NUIHZhbHVlIFwiJyArIHZhbHVlICsgJ1wiJyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBwYXJ0RGVzaWduID0ge1xuICAgIEJZU0VDT05EOiBwYXJzZU51bWVyaWNWYWx1ZS5iaW5kKHRoaXMsICdCWVNFQ09ORCcsIDAsIDYwKSxcbiAgICBCWU1JTlVURTogcGFyc2VOdW1lcmljVmFsdWUuYmluZCh0aGlzLCAnQllNSU5VVEUnLCAwLCA1OSksXG4gICAgQllIT1VSOiBwYXJzZU51bWVyaWNWYWx1ZS5iaW5kKHRoaXMsICdCWUhPVVInLCAwLCAyMyksXG4gICAgQllEQVk6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAoVkFMSURfQllEQVlfUEFSVC50ZXN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgQllEQVkgdmFsdWUgXCInICsgdmFsdWUgKyAnXCInKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIEJZTU9OVEhEQVk6IHBhcnNlTnVtZXJpY1ZhbHVlLmJpbmQodGhpcywgJ0JZTU9OVEhEQVknLCAtMzEsIDMxKSxcbiAgICBCWVlFQVJEQVk6IHBhcnNlTnVtZXJpY1ZhbHVlLmJpbmQodGhpcywgJ0JZWUVBUkRBWScsIC0zNjYsIDM2NiksXG4gICAgQllXRUVLTk86IHBhcnNlTnVtZXJpY1ZhbHVlLmJpbmQodGhpcywgJ0JZV0VFS05PJywgLTUzLCA1MyksXG4gICAgQllNT05USDogcGFyc2VOdW1lcmljVmFsdWUuYmluZCh0aGlzLCAnQllNT05USCcsIDEsIDEyKSxcbiAgICBCWVNFVFBPUzogcGFyc2VOdW1lcmljVmFsdWUuYmluZCh0aGlzLCAnQllTRVRQT1MnLCAtMzY2LCAzNjYpXG4gIH07XG5cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgSUNBTC5SZWN1cn0gaW5zdGFuY2UgZnJvbSB0aGUgcGFzc2VkIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyAgICAgICAgIFRoZSBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHJldHVybiB7SUNBTC5SZWN1cn0gICAgICAgICAgIFRoZSBjcmVhdGVkIHJlY3VycmVuY2UgaW5zdGFuY2VcbiAgICovXG4gIElDQUwuUmVjdXIuZnJvbVN0cmluZyA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHZhciBkYXRhID0gSUNBTC5SZWN1ci5fc3RyaW5nVG9EYXRhKHN0cmluZywgZmFsc2UpO1xuICAgIHJldHVybiBuZXcgSUNBTC5SZWN1cihkYXRhKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgSUNBTC5SZWN1cn0gaW5zdGFuY2UgdXNpbmcgbWVtYmVycyBmcm9tIHRoZSBwYXNzZWRcbiAgICogZGF0YSBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhRGF0YSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFuIG9iamVjdCB3aXRoIG1lbWJlcnMgb2YgdGhlIHJlY3VycmVuY2VcbiAgICogQHBhcmFtIHtJQ0FMLlJlY3VyLmZyZXF1ZW5jeVZhbHVlcz19IGFEYXRhLmZyZXEgICAgVGhlIGZyZXF1ZW5jeSB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLmludGVydmFsICAgICAgICAgICAgICAgICAgICBUaGUgSU5URVJWQUwgdmFsdWVcbiAgICogQHBhcmFtIHtJQ0FMLlRpbWUud2Vla0RheT19IGFEYXRhLndrc3QgICAgICAgICAgICAgVGhlIHdlZWsgc3RhcnQgdmFsdWVcbiAgICogQHBhcmFtIHtJQ0FMLlRpbWU9fSBhRGF0YS51bnRpbCAgICAgICAgICAgICAgICAgICAgVGhlIGVuZCBvZiB0aGUgcmVjdXJyZW5jZSBzZXRcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5jb3VudCAgICAgICAgICAgICAgICAgICAgICAgVGhlIG51bWJlciBvZiBvY2N1cnJlbmNlc1xuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gYURhdGEuYnlzZWNvbmQgICAgICAgICAgICBUaGUgc2Vjb25kcyBmb3IgdGhlIEJZU0VDT05EIHBhcnRcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGFEYXRhLmJ5bWludXRlICAgICAgICAgICAgVGhlIG1pbnV0ZXMgZm9yIHRoZSBCWU1JTlVURSBwYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBhRGF0YS5ieWhvdXIgICAgICAgICAgICAgIFRoZSBob3VycyBmb3IgdGhlIEJZSE9VUiBwYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz49fSBhRGF0YS5ieWRheSAgICAgICAgICAgICAgIFRoZSBCWURBWSB2YWx1ZXNcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGFEYXRhLmJ5bW9udGhkYXkgICAgICAgICAgVGhlIGRheXMgZm9yIHRoZSBCWU1PTlRIREFZIHBhcnRcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGFEYXRhLmJ5eWVhcmRheSAgICAgICAgICAgVGhlIGRheXMgZm9yIHRoZSBCWVlFQVJEQVkgcGFydFxuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gYURhdGEuYnl3ZWVrbm8gICAgICAgICAgICBUaGUgd2Vla3MgZm9yIHRoZSBCWVdFRUtOTyBwYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBhRGF0YS5ieW1vbnRoICAgICAgICAgICAgIFRoZSBtb250aCBmb3IgdGhlIEJZTU9OVEggcGFydFxuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gYURhdGEuYnlzZXRwb3MgICAgICAgICAgICBUaGUgcG9zaXRpb25hbHMgZm9yIHRoZSBCWVNFVFBPUyBwYXJ0XG4gICAqL1xuICBJQ0FMLlJlY3VyLmZyb21EYXRhID0gZnVuY3Rpb24oYURhdGEpIHtcbiAgICByZXR1cm4gbmV3IElDQUwuUmVjdXIoYURhdGEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIHJlY3VycmVuY2Ugc3RyaW5nIHRvIGEgZGF0YSBvYmplY3QsIHN1aXRhYmxlIGZvciB0aGUgZnJvbURhdGFcbiAgICogbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nICAgICBUaGUgc3RyaW5nIHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZm10SWNhbCAgIElmIHRydWUsIHRoZSBzdHJpbmcgaXMgY29uc2lkZXJlZCB0byBiZSBhblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlDYWxlbmRhciBzdHJpbmdcbiAgICogQHJldHVybiB7SUNBTC5SZWN1cn0gICAgICAgVGhlIHJlY3VycmVuY2UgaW5zdGFuY2VcbiAgICovXG4gIElDQUwuUmVjdXIuX3N0cmluZ1RvRGF0YSA9IGZ1bmN0aW9uKHN0cmluZywgZm10SWNhbCkge1xuICAgIHZhciBkaWN0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIC8vIHNwbGl0IGlzIHNsb3dlciBpbiBGRiBidXQgZmFzdCBlbm91Z2guXG4gICAgLy8gdjggaG93ZXZlciB0aGlzIGlzIGZhc3RlciB0aGVuIG1hbnVhbCBzcGxpdD9cbiAgICB2YXIgdmFsdWVzID0gc3RyaW5nLnNwbGl0KCc7Jyk7XG4gICAgdmFyIGxlbiA9IHZhbHVlcy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgcGFydHMgPSB2YWx1ZXNbaV0uc3BsaXQoJz0nKTtcbiAgICAgIHZhciB1Y25hbWUgPSBwYXJ0c1swXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgdmFyIGxjbmFtZSA9IHBhcnRzWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgbmFtZSA9IChmbXRJY2FsID8gbGNuYW1lIDogdWNuYW1lKTtcbiAgICAgIHZhciB2YWx1ZSA9IHBhcnRzWzFdO1xuXG4gICAgICBpZiAodWNuYW1lIGluIHBhcnREZXNpZ24pIHtcbiAgICAgICAgdmFyIHBhcnRBcnIgPSB2YWx1ZS5zcGxpdCgnLCcpO1xuICAgICAgICB2YXIgcGFydEFycklkeCA9IDA7XG4gICAgICAgIHZhciBwYXJ0QXJyTGVuID0gcGFydEFyci5sZW5ndGg7XG5cbiAgICAgICAgZm9yICg7IHBhcnRBcnJJZHggPCBwYXJ0QXJyTGVuOyBwYXJ0QXJySWR4KyspIHtcbiAgICAgICAgICBwYXJ0QXJyW3BhcnRBcnJJZHhdID0gcGFydERlc2lnblt1Y25hbWVdKHBhcnRBcnJbcGFydEFycklkeF0pO1xuICAgICAgICB9XG4gICAgICAgIGRpY3RbbmFtZV0gPSAocGFydEFyci5sZW5ndGggPT0gMSA/IHBhcnRBcnJbMF0gOiBwYXJ0QXJyKTtcbiAgICAgIH0gZWxzZSBpZiAodWNuYW1lIGluIG9wdGlvbkRlc2lnbikge1xuICAgICAgICBvcHRpb25EZXNpZ25bdWNuYW1lXSh2YWx1ZSwgZGljdCwgZm10SWNhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBEb24ndCBzd2FsbG93IHVua25vd24gdmFsdWVzLiBKdXN0IHNldCB0aGVtIGFzIHRoZXkgYXJlLlxuICAgICAgICBkaWN0W2xjbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGljdDtcbiAgfTtcbn0pKCk7XG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICogUG9ydGlvbnMgQ29weXJpZ2h0IChDKSBQaGlsaXBwIEtld2lzY2gsIDIwMTEtMjAxNSAqL1xuXG5cbi8qKlxuICogVGhpcyBzeW1ib2wgaXMgZnVydGhlciBkZXNjcmliZWQgbGF0ZXIgb25cbiAqIEBpZ25vcmVcbiAqL1xuSUNBTC5SZWN1ckl0ZXJhdG9yID0gKGZ1bmN0aW9uKCkge1xuXG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIEFuIGl0ZXJhdG9yIGZvciBhIHNpbmdsZSByZWN1cnJlbmNlIHJ1bGUuIFRoaXMgY2xhc3MgdXN1YWxseSBkb2Vzbid0IGhhdmVcbiAgICogdG8gYmUgaW5zdGFuY2lhdGVkIGRpcmVjdGx5LCB0aGUgY29udmVuaWVuY2UgbWV0aG9kXG4gICAqIHtAbGluayBJQ0FMLlJlY3VyI2l0ZXJhdG9yfSBjYW4gYmUgdXNlZC5cbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFRoZSBvcHRpb25zIG9iamVjdCBtYXkgY29udGFpbiBhZGRpdGlvbmFsIG1lbWJlcnMgd2hlbiByZXN1bWluZyBpdGVyYXRpb24gZnJvbSBhIHByZXZpb3VzIHJ1blxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogVGhlIG9wdGlvbnMgb2JqZWN0IG1heSBjb250YWluIGFkZGl0aW9uYWwgbWVtYmVycyB3aGVuIHJlc3VtaW5nIGl0ZXJhdGlvblxuICAgKiBmcm9tIGEgcHJldmlvdXMgcnVuLlxuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQGFsaWFzIElDQUwuUmVjdXJJdGVyYXRvclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAgICAgICAgICAgICAgICBUaGUgaXRlcmF0b3Igb3B0aW9uc1xuICAgKiBAcGFyYW0ge0lDQUwuUmVjdXJ9IG9wdGlvbnMucnVsZSAgICAgICBUaGUgcnVsZSB0byBpdGVyYXRlLlxuICAgKiBAcGFyYW0ge0lDQUwuVGltZX0gb3B0aW9ucy5kdHN0YXJ0ICAgICBUaGUgc3RhcnQgZGF0ZSBvZiB0aGUgZXZlbnQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbj19IG9wdGlvbnMuaW5pdGlhbGl6ZWQgIFdoZW4gdHJ1ZSwgYXNzdW1lIHRoYXQgb3B0aW9ucyBhcmVcbiAgICogICAgICAgIGZyb20gYSBwcmV2aW91c2x5IGNvbnN0cnVjdGVkIGl0ZXJhdG9yLiBJbml0aWFsaXphdGlvbiB3aWxsIG5vdCBiZVxuICAgKiAgICAgICAgcmVwZWF0ZWQuXG4gICAqL1xuICBmdW5jdGlvbiBpY2FscmVjdXJfaXRlcmF0b3Iob3B0aW9ucykge1xuICAgIHRoaXMuZnJvbURhdGEob3B0aW9ucyk7XG4gIH1cblxuICBpY2FscmVjdXJfaXRlcmF0b3IucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogVHJ1ZSB3aGVuIGl0ZXJhdGlvbiBpcyBmaW5pc2hlZC5cbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBjb21wbGV0ZWQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHJ1bGUgdGhhdCBpcyBiZWluZyBpdGVyYXRlZFxuICAgICAqIEB0eXBlIHtJQ0FMLlJlY3VyfVxuICAgICAqL1xuICAgIHJ1bGU6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RhcnQgZGF0ZSBvZiB0aGUgZXZlbnQgYmVpbmcgaXRlcmF0ZWQuXG4gICAgICogQHR5cGUge0lDQUwuVGltZX1cbiAgICAgKi9cbiAgICBkdHN0YXJ0OiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGxhc3Qgb2NjdXJyZW5jZSB0aGF0IHdhcyByZXR1cm5lZCBmcm9tIHRoZVxuICAgICAqIHtAbGluayBJQ0FMLlJlY3VySXRlcmF0b3IjbmV4dH0gbWV0aG9kLlxuICAgICAqIEB0eXBlIHtJQ0FMLlRpbWV9XG4gICAgICovXG4gICAgbGFzdDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzZXF1ZW5jZSBudW1iZXIgZnJvbSB0aGUgb2NjdXJyZW5jZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgb2NjdXJyZW5jZV9udW1iZXI6IDAsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5kaWNlcyB1c2VkIGZvciB0aGUge0BsaW5rIElDQUwuUmVjdXJJdGVyYXRvciNieV9kYXRhfSBvYmplY3QuXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGJ5X2luZGljZXM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCB0aGUgaXRlcmF0b3IgaGFzIGFscmVhZHkgYmVlbiBpbml0aWFsaXplZFxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZWQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGluaXRpYWxpemQgYnktZGF0YS5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYnlfZGF0YTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBleHBhbmRlZCB5ZWFyZGF5c1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGRheXM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5kZXggaW4gdGhlIHtAbGluayBJQ0FMLlJlY3VySXRlcmF0b3IjZGF5c30gYXJyYXkuXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGRheXNfaW5kZXg6IDAsXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHRoZSByZWN1cnJlbmNlIGl0ZXJhdG9yIGZyb20gdGhlIHBhc3NlZCBkYXRhIG9iamVjdC4gVGhpc1xuICAgICAqIG1ldGhvZCBpcyB1c3VhbGx5IG5vdCBjYWxsZWQgZGlyZWN0bHksIHlvdSBjYW4gaW5pdGlhbGl6ZSB0aGUgaXRlcmF0b3JcbiAgICAgKiB0aHJvdWdoIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zICAgICAgICAgICAgICAgIFRoZSBpdGVyYXRvciBvcHRpb25zXG4gICAgICogQHBhcmFtIHtJQ0FMLlJlY3VyfSBvcHRpb25zLnJ1bGUgICAgICAgVGhlIHJ1bGUgdG8gaXRlcmF0ZS5cbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZX0gb3B0aW9ucy5kdHN0YXJ0ICAgICBUaGUgc3RhcnQgZGF0ZSBvZiB0aGUgZXZlbnQuXG4gICAgICogQHBhcmFtIHtCb29sZWFuPX0gb3B0aW9ucy5pbml0aWFsaXplZCAgV2hlbiB0cnVlLCBhc3N1bWUgdGhhdCBvcHRpb25zIGFyZVxuICAgICAqICAgICAgICBmcm9tIGEgcHJldmlvdXNseSBjb25zdHJ1Y3RlZCBpdGVyYXRvci4gSW5pdGlhbGl6YXRpb24gd2lsbCBub3QgYmVcbiAgICAgKiAgICAgICAgcmVwZWF0ZWQuXG4gICAgICovXG4gICAgZnJvbURhdGE6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMucnVsZSA9IElDQUwuaGVscGVycy5mb3JtYXRDbGFzc1R5cGUob3B0aW9ucy5ydWxlLCBJQ0FMLlJlY3VyKTtcblxuICAgICAgaWYgKCF0aGlzLnJ1bGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpdGVyYXRvciByZXF1aXJlcyBhIChJQ0FMLlJlY3VyKSBydWxlJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZHRzdGFydCA9IElDQUwuaGVscGVycy5mb3JtYXRDbGFzc1R5cGUob3B0aW9ucy5kdHN0YXJ0LCBJQ0FMLlRpbWUpO1xuXG4gICAgICBpZiAoIXRoaXMuZHRzdGFydCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2l0ZXJhdG9yIHJlcXVpcmVzIGEgKElDQUwuVGltZSkgZHRzdGFydCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5ieV9kYXRhKSB7XG4gICAgICAgIHRoaXMuYnlfZGF0YSA9IG9wdGlvbnMuYnlfZGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYnlfZGF0YSA9IElDQUwuaGVscGVycy5jbG9uZSh0aGlzLnJ1bGUucGFydHMsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5vY2N1cnJlbmNlX251bWJlcilcbiAgICAgICAgdGhpcy5vY2N1cnJlbmNlX251bWJlciA9IG9wdGlvbnMub2NjdXJyZW5jZV9udW1iZXI7XG5cbiAgICAgIHRoaXMuZGF5cyA9IG9wdGlvbnMuZGF5cyB8fCBbXTtcbiAgICAgIGlmIChvcHRpb25zLmxhc3QpIHtcbiAgICAgICAgdGhpcy5sYXN0ID0gSUNBTC5oZWxwZXJzLmZvcm1hdENsYXNzVHlwZShvcHRpb25zLmxhc3QsIElDQUwuVGltZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYnlfaW5kaWNlcyA9IG9wdGlvbnMuYnlfaW5kaWNlcztcblxuICAgICAgaWYgKCF0aGlzLmJ5X2luZGljZXMpIHtcbiAgICAgICAgdGhpcy5ieV9pbmRpY2VzID0ge1xuICAgICAgICAgIFwiQllTRUNPTkRcIjogMCxcbiAgICAgICAgICBcIkJZTUlOVVRFXCI6IDAsXG4gICAgICAgICAgXCJCWUhPVVJcIjogMCxcbiAgICAgICAgICBcIkJZREFZXCI6IDAsXG4gICAgICAgICAgXCJCWU1PTlRIXCI6IDAsXG4gICAgICAgICAgXCJCWVdFRUtOT1wiOiAwLFxuICAgICAgICAgIFwiQllNT05USERBWVwiOiAwXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBvcHRpb25zLmluaXRpYWxpemVkIHx8IGZhbHNlO1xuXG4gICAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEludGlhbGl6ZSB0aGUgaXRlcmF0b3JcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uIGljYWxyZWN1cl9pdGVyYXRvcl9pbml0KCkge1xuICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICB0aGlzLmxhc3QgPSB0aGlzLmR0c3RhcnQuY2xvbmUoKTtcbiAgICAgIHZhciBwYXJ0cyA9IHRoaXMuYnlfZGF0YTtcblxuICAgICAgaWYgKFwiQllEQVlcIiBpbiBwYXJ0cykge1xuICAgICAgICAvLyBsaWJpY2FsIGRvZXMgdGhpcyBlYXJsaWVyIHdoZW4gdGhlIHJ1bGUgaXMgbG9hZGVkLCBidXQgd2UgcG9zdHBvbmUgdG9cbiAgICAgICAgLy8gbm93IHNvIHdlIGNhbiBwcmVzZXJ2ZSB0aGUgb3JpZ2luYWwgb3JkZXIuXG4gICAgICAgIHRoaXMuc29ydF9ieWRheV9ydWxlcyhwYXJ0cy5CWURBWSk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBCWVlFQVJEQVkgYXBwYXJlcywgbm8gb3RoZXIgZGF0ZSBydWxlIHBhcnQgbWF5IGFwcGVhclxuICAgICAgaWYgKFwiQllZRUFSREFZXCIgaW4gcGFydHMpIHtcbiAgICAgICAgaWYgKFwiQllNT05USFwiIGluIHBhcnRzIHx8IFwiQllXRUVLTk9cIiBpbiBwYXJ0cyB8fFxuICAgICAgICAgICAgXCJCWU1PTlRIREFZXCIgaW4gcGFydHMgfHwgXCJCWURBWVwiIGluIHBhcnRzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBCWVlFQVJEQVkgcnVsZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBCWVdFRUtOTyBhbmQgQllNT05USERBWSBydWxlIHBhcnRzIG1heSBub3QgYm90aCBhcHBlYXJcbiAgICAgIGlmIChcIkJZV0VFS05PXCIgaW4gcGFydHMgJiYgXCJCWU1PTlRIREFZXCIgaW4gcGFydHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQllXRUVLTk8gZG9lcyBub3QgZml0IHRvIEJZTU9OVEhEQVlcIik7XG4gICAgICB9XG5cbiAgICAgIC8vIEZvciBNT05USExZIHJlY3VycmVuY2VzIChGUkVRPU1PTlRITFkpIG5laXRoZXIgQllZRUFSREFZIG5vclxuICAgICAgLy8gQllXRUVLTk8gbWF5IGFwcGVhci5cbiAgICAgIGlmICh0aGlzLnJ1bGUuZnJlcSA9PSBcIk1PTlRITFlcIiAmJlxuICAgICAgICAgIChcIkJZWUVBUkRBWVwiIGluIHBhcnRzIHx8IFwiQllXRUVLTk9cIiBpbiBwYXJ0cykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRm9yIE1PTlRITFkgcmVjdXJyZW5jZXMgbmVpdGhlciBCWVlFQVJEQVkgbm9yIEJZV0VFS05PIG1heSBhcHBlYXJcIik7XG4gICAgICB9XG5cbiAgICAgIC8vIEZvciBXRUVLTFkgcmVjdXJyZW5jZXMgKEZSRVE9V0VFS0xZKSBuZWl0aGVyIEJZTU9OVEhEQVkgbm9yXG4gICAgICAvLyBCWVlFQVJEQVkgbWF5IGFwcGVhci5cbiAgICAgIGlmICh0aGlzLnJ1bGUuZnJlcSA9PSBcIldFRUtMWVwiICYmXG4gICAgICAgICAgKFwiQllZRUFSREFZXCIgaW4gcGFydHMgfHwgXCJCWU1PTlRIREFZXCIgaW4gcGFydHMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZvciBXRUVLTFkgcmVjdXJyZW5jZXMgbmVpdGhlciBCWU1PTlRIREFZIG5vciBCWVlFQVJEQVkgbWF5IGFwcGVhclwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gQllZRUFSREFZIG1heSBvbmx5IGFwcGVhciBpbiBZRUFSTFkgcnVsZXNcbiAgICAgIGlmICh0aGlzLnJ1bGUuZnJlcSAhPSBcIllFQVJMWVwiICYmIFwiQllZRUFSREFZXCIgaW4gcGFydHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQllZRUFSREFZIG1heSBvbmx5IGFwcGVhciBpbiBZRUFSTFkgcnVsZXNcIik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGFzdC5zZWNvbmQgPSB0aGlzLnNldHVwX2RlZmF1bHRzKFwiQllTRUNPTkRcIiwgXCJTRUNPTkRMWVwiLCB0aGlzLmR0c3RhcnQuc2Vjb25kKTtcbiAgICAgIHRoaXMubGFzdC5taW51dGUgPSB0aGlzLnNldHVwX2RlZmF1bHRzKFwiQllNSU5VVEVcIiwgXCJNSU5VVEVMWVwiLCB0aGlzLmR0c3RhcnQubWludXRlKTtcbiAgICAgIHRoaXMubGFzdC5ob3VyID0gdGhpcy5zZXR1cF9kZWZhdWx0cyhcIkJZSE9VUlwiLCBcIkhPVVJMWVwiLCB0aGlzLmR0c3RhcnQuaG91cik7XG4gICAgICB0aGlzLmxhc3QuZGF5ID0gdGhpcy5zZXR1cF9kZWZhdWx0cyhcIkJZTU9OVEhEQVlcIiwgXCJEQUlMWVwiLCB0aGlzLmR0c3RhcnQuZGF5KTtcbiAgICAgIHRoaXMubGFzdC5tb250aCA9IHRoaXMuc2V0dXBfZGVmYXVsdHMoXCJCWU1PTlRIXCIsIFwiTU9OVEhMWVwiLCB0aGlzLmR0c3RhcnQubW9udGgpO1xuXG4gICAgICBpZiAodGhpcy5ydWxlLmZyZXEgPT0gXCJXRUVLTFlcIikge1xuICAgICAgICBpZiAoXCJCWURBWVwiIGluIHBhcnRzKSB7XG4gICAgICAgICAgdmFyIGJ5ZGF5UGFydHMgPSB0aGlzLnJ1bGVEYXlPZldlZWsocGFydHMuQllEQVlbMF0sIHRoaXMucnVsZS53a3N0KTtcbiAgICAgICAgICB2YXIgcG9zID0gYnlkYXlQYXJ0c1swXTtcbiAgICAgICAgICB2YXIgZG93ID0gYnlkYXlQYXJ0c1sxXTtcbiAgICAgICAgICB2YXIgd2tkeSA9IGRvdyAtIHRoaXMubGFzdC5kYXlPZldlZWsodGhpcy5ydWxlLndrc3QpO1xuICAgICAgICAgIGlmICgodGhpcy5sYXN0LmRheU9mV2Vlayh0aGlzLnJ1bGUud2tzdCkgPCBkb3cgJiYgd2tkeSA+PSAwKSB8fCB3a2R5IDwgMCkge1xuICAgICAgICAgICAgLy8gSW5pdGlhbCB0aW1lIGlzIGFmdGVyIGZpcnN0IGRheSBvZiBCWURBWSBkYXRhXG4gICAgICAgICAgICB0aGlzLmxhc3QuZGF5ICs9IHdrZHk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBkYXlOYW1lID0gSUNBTC5SZWN1ci5udW1lcmljRGF5VG9JY2FsRGF5KHRoaXMuZHRzdGFydC5kYXlPZldlZWsoKSk7XG4gICAgICAgICAgcGFydHMuQllEQVkgPSBbZGF5TmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucnVsZS5mcmVxID09IFwiWUVBUkxZXCIpIHtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIHRoaXMuZXhwYW5kX3llYXJfZGF5cyh0aGlzLmxhc3QueWVhcik7XG4gICAgICAgICAgaWYgKHRoaXMuZGF5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5pbmNyZW1lbnRfeWVhcih0aGlzLnJ1bGUuaW50ZXJ2YWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbmV4dEJ5WWVhckRheSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5ydWxlLmZyZXEgPT0gXCJNT05USExZXCIgJiYgdGhpcy5oYXNfYnlfZGF0YShcIkJZREFZXCIpKSB7XG4gICAgICAgIHZhciB0ZW1wTGFzdCA9IG51bGw7XG4gICAgICAgIHZhciBpbml0TGFzdCA9IHRoaXMubGFzdC5jbG9uZSgpO1xuICAgICAgICB2YXIgZGF5c0luTW9udGggPSBJQ0FMLlRpbWUuZGF5c0luTW9udGgodGhpcy5sYXN0Lm1vbnRoLCB0aGlzLmxhc3QueWVhcik7XG5cbiAgICAgICAgLy8gQ2hlY2sgZXZlcnkgd2Vla2RheSBpbiBCWURBWSB3aXRoIHJlbGF0aXZlIGRvdyBhbmQgcG9zLlxuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuYnlfZGF0YS5CWURBWSkge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmICghdGhpcy5ieV9kYXRhLkJZREFZLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5sYXN0ID0gaW5pdExhc3QuY2xvbmUoKTtcbiAgICAgICAgICB2YXIgYnlkYXlQYXJ0cyA9IHRoaXMucnVsZURheU9mV2Vlayh0aGlzLmJ5X2RhdGEuQllEQVlbaV0pO1xuICAgICAgICAgIHZhciBwb3MgPSBieWRheVBhcnRzWzBdO1xuICAgICAgICAgIHZhciBkb3cgPSBieWRheVBhcnRzWzFdO1xuICAgICAgICAgIHZhciBkYXlPZk1vbnRoID0gdGhpcy5sYXN0Lm50aFdlZWtEYXkoZG93LCBwb3MpO1xuXG4gICAgICAgICAgLy8gSWYgfHBvc3wgPj0gNiwgdGhlIGJ5ZGF5IGlzIGludmFsaWQgZm9yIGEgbW9udGhseSBydWxlLlxuICAgICAgICAgIGlmIChwb3MgPj0gNiB8fCBwb3MgPD0gLTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1hbGZvcm1lZCB2YWx1ZXMgaW4gQllEQVkgcGFydFwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiBhIEJ5ZGF5IHdpdGggcG9zPSsvLTUgaXMgbm90IGluIHRoZSBjdXJyZW50IG1vbnRoIGl0XG4gICAgICAgICAgLy8gbXVzdCBiZSBzZWFyY2hlZCBpbiB0aGUgbmV4dCBtb250aHMuXG4gICAgICAgICAgaWYgKGRheU9mTW9udGggPiBkYXlzSW5Nb250aCB8fCBkYXlPZk1vbnRoIDw9IDApIHtcbiAgICAgICAgICAgIC8vIFNraXAgaWYgd2UgaGF2ZSBhbHJlYWR5IGZvdW5kIGEgXCJsYXN0XCIgaW4gdGhpcyBtb250aC5cbiAgICAgICAgICAgIGlmICh0ZW1wTGFzdCAmJiB0ZW1wTGFzdC5tb250aCA9PSBpbml0TGFzdC5tb250aCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChkYXlPZk1vbnRoID4gZGF5c0luTW9udGggfHwgZGF5T2ZNb250aCA8PSAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuaW5jcmVtZW50X21vbnRoKCk7XG4gICAgICAgICAgICAgIGRheXNJbk1vbnRoID0gSUNBTC5UaW1lLmRheXNJbk1vbnRoKHRoaXMubGFzdC5tb250aCwgdGhpcy5sYXN0LnllYXIpO1xuICAgICAgICAgICAgICBkYXlPZk1vbnRoID0gdGhpcy5sYXN0Lm50aFdlZWtEYXkoZG93LCBwb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMubGFzdC5kYXkgPSBkYXlPZk1vbnRoO1xuICAgICAgICAgIGlmICghdGVtcExhc3QgfHwgdGhpcy5sYXN0LmNvbXBhcmUodGVtcExhc3QpIDwgMCkge1xuICAgICAgICAgICAgdGVtcExhc3QgPSB0aGlzLmxhc3QuY2xvbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0ID0gdGVtcExhc3QuY2xvbmUoKTtcblxuICAgICAgICAvL1hYWDogVGhpcyBmZWVscyBsaWtlIGEgaGFjaywgYnV0IHdlIG5lZWQgdG8gaW5pdGlhbGl6ZVxuICAgICAgICAvLyAgICAgdGhlIEJZTU9OVEhEQVkgY2FzZSBjb3JyZWN0bHkgYW5kIGJ5RGF5QW5kTW9udGhEYXkgaGFuZGxlc1xuICAgICAgICAvLyAgICAgdGhpcyBjYXNlLiBJdCBhY2NlcHRzIGEgc3BlY2lhbCBmbGFnIHdoaWNoIHdpbGwgYXZvaWQgaW5jcmVtZW50aW5nXG4gICAgICAgIC8vICAgICB0aGUgaW5pdGlhbCB2YWx1ZSB3aXRob3V0IHRoZSBmbGFnIGRheXMgdGhhdCBtYXRjaCB0aGUgc3RhcnQgdGltZVxuICAgICAgICAvLyAgICAgd291bGQgYmUgbWlzc2VkLlxuICAgICAgICBpZiAodGhpcy5oYXNfYnlfZGF0YSgnQllNT05USERBWScpKSB7XG4gICAgICAgICAgdGhpcy5fYnlEYXlBbmRNb250aERheSh0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmxhc3QuZGF5ID4gZGF5c0luTW9udGggfHwgdGhpcy5sYXN0LmRheSA9PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWFsZm9ybWVkIHZhbHVlcyBpbiBCWURBWSBwYXJ0XCIpO1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5oYXNfYnlfZGF0YShcIkJZTU9OVEhEQVlcIikpIHtcbiAgICAgICAgaWYgKHRoaXMubGFzdC5kYXkgPCAwKSB7XG4gICAgICAgICAgdmFyIGRheXNJbk1vbnRoID0gSUNBTC5UaW1lLmRheXNJbk1vbnRoKHRoaXMubGFzdC5tb250aCwgdGhpcy5sYXN0LnllYXIpO1xuICAgICAgICAgIHRoaXMubGFzdC5kYXkgPSBkYXlzSW5Nb250aCArIHRoaXMubGFzdC5kYXkgKyAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIG5leHQgb2NjdXJyZW5jZSBmcm9tIHRoZSBpdGVyYXRvci5cbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlRpbWV9XG4gICAgICovXG4gICAgbmV4dDogZnVuY3Rpb24gaWNhbHJlY3VyX2l0ZXJhdG9yX25leHQoKSB7XG4gICAgICB2YXIgYmVmb3JlID0gKHRoaXMubGFzdCA/IHRoaXMubGFzdC5jbG9uZSgpIDogbnVsbCk7XG5cbiAgICAgIGlmICgodGhpcy5ydWxlLmNvdW50ICYmIHRoaXMub2NjdXJyZW5jZV9udW1iZXIgPj0gdGhpcy5ydWxlLmNvdW50KSB8fFxuICAgICAgICAgICh0aGlzLnJ1bGUudW50aWwgJiYgdGhpcy5sYXN0LmNvbXBhcmUodGhpcy5ydWxlLnVudGlsKSA+IDApKSB7XG5cbiAgICAgICAgLy9YWFg6IHJpZ2h0IG5vdyB0aGlzIGlzIGp1c3QgYSBmbGFnIGFuZCBoYXMgbm8gaW1wYWN0XG4gICAgICAgIC8vICAgICB3ZSBjYW4gc2ltcGxpZnkgdGhlIGFib3ZlIGNhc2UgdG8gY2hlY2sgZm9yIGNvbXBsZXRlZCBsYXRlci5cbiAgICAgICAgdGhpcy5jb21wbGV0ZWQgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vY2N1cnJlbmNlX251bWJlciA9PSAwICYmIHRoaXMubGFzdC5jb21wYXJlKHRoaXMuZHRzdGFydCkgPj0gMCkge1xuICAgICAgICAvLyBGaXJzdCBvZiBhbGwsIGdpdmUgdGhlIGluc3RhbmNlIHRoYXQgd2FzIGluaXRpYWxpemVkXG4gICAgICAgIHRoaXMub2NjdXJyZW5jZV9udW1iZXIrKztcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdDtcbiAgICAgIH1cblxuXG4gICAgICB2YXIgdmFsaWQ7XG4gICAgICBkbyB7XG4gICAgICAgIHZhbGlkID0gMTtcblxuICAgICAgICBzd2l0Y2ggKHRoaXMucnVsZS5mcmVxKSB7XG4gICAgICAgIGNhc2UgXCJTRUNPTkRMWVwiOlxuICAgICAgICAgIHRoaXMubmV4dF9zZWNvbmQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIk1JTlVURUxZXCI6XG4gICAgICAgICAgdGhpcy5uZXh0X21pbnV0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiSE9VUkxZXCI6XG4gICAgICAgICAgdGhpcy5uZXh0X2hvdXIoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkRBSUxZXCI6XG4gICAgICAgICAgdGhpcy5uZXh0X2RheSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiV0VFS0xZXCI6XG4gICAgICAgICAgdGhpcy5uZXh0X3dlZWsoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIk1PTlRITFlcIjpcbiAgICAgICAgICB2YWxpZCA9IHRoaXMubmV4dF9tb250aCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiWUVBUkxZXCI6XG4gICAgICAgICAgdGhpcy5uZXh0X3llYXIoKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlICghdGhpcy5jaGVja19jb250cmFjdGluZ19ydWxlcygpIHx8XG4gICAgICAgICAgICAgICB0aGlzLmxhc3QuY29tcGFyZSh0aGlzLmR0c3RhcnQpIDwgMCB8fFxuICAgICAgICAgICAgICAgIXZhbGlkKTtcblxuICAgICAgLy8gVE9ETyBpcyB0aGlzIHZhbGlkP1xuICAgICAgaWYgKHRoaXMubGFzdC5jb21wYXJlKGJlZm9yZSkgPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTYW1lIG9jY3VycmVuY2UgZm91bmQgdHdpY2UsIHByb3RlY3RpbmcgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ5b3UgZnJvbSBkZWF0aCBieSByZWN1cnNpb25cIik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnJ1bGUudW50aWwgJiYgdGhpcy5sYXN0LmNvbXBhcmUodGhpcy5ydWxlLnVudGlsKSA+IDApIHtcbiAgICAgICAgdGhpcy5jb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub2NjdXJyZW5jZV9udW1iZXIrKztcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgbmV4dF9zZWNvbmQ6IGZ1bmN0aW9uIG5leHRfc2Vjb25kKCkge1xuICAgICAgcmV0dXJuIHRoaXMubmV4dF9nZW5lcmljKFwiQllTRUNPTkRcIiwgXCJTRUNPTkRMWVwiLCBcInNlY29uZFwiLCBcIm1pbnV0ZVwiKTtcbiAgICB9LFxuXG4gICAgaW5jcmVtZW50X3NlY29uZDogZnVuY3Rpb24gaW5jcmVtZW50X3NlY29uZChpbmMpIHtcbiAgICAgIHJldHVybiB0aGlzLmluY3JlbWVudF9nZW5lcmljKGluYywgXCJzZWNvbmRcIiwgNjAsIFwibWludXRlXCIpO1xuICAgIH0sXG5cbiAgICBuZXh0X21pbnV0ZTogZnVuY3Rpb24gbmV4dF9taW51dGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5uZXh0X2dlbmVyaWMoXCJCWU1JTlVURVwiLCBcIk1JTlVURUxZXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtaW51dGVcIiwgXCJob3VyXCIsIFwibmV4dF9zZWNvbmRcIik7XG4gICAgfSxcblxuICAgIGluY3JlbWVudF9taW51dGU6IGZ1bmN0aW9uIGluY3JlbWVudF9taW51dGUoaW5jKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbmNyZW1lbnRfZ2VuZXJpYyhpbmMsIFwibWludXRlXCIsIDYwLCBcImhvdXJcIik7XG4gICAgfSxcblxuICAgIG5leHRfaG91cjogZnVuY3Rpb24gbmV4dF9ob3VyKCkge1xuICAgICAgcmV0dXJuIHRoaXMubmV4dF9nZW5lcmljKFwiQllIT1VSXCIsIFwiSE9VUkxZXCIsIFwiaG91clwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibW9udGhkYXlcIiwgXCJuZXh0X21pbnV0ZVwiKTtcbiAgICB9LFxuXG4gICAgaW5jcmVtZW50X2hvdXI6IGZ1bmN0aW9uIGluY3JlbWVudF9ob3VyKGluYykge1xuICAgICAgdGhpcy5pbmNyZW1lbnRfZ2VuZXJpYyhpbmMsIFwiaG91clwiLCAyNCwgXCJtb250aGRheVwiKTtcbiAgICB9LFxuXG4gICAgbmV4dF9kYXk6IGZ1bmN0aW9uIG5leHRfZGF5KCkge1xuICAgICAgdmFyIGhhc19ieV9kYXkgPSAoXCJCWURBWVwiIGluIHRoaXMuYnlfZGF0YSk7XG4gICAgICB2YXIgdGhpc19mcmVxID0gKHRoaXMucnVsZS5mcmVxID09IFwiREFJTFlcIik7XG5cbiAgICAgIGlmICh0aGlzLm5leHRfaG91cigpID09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzX2ZyZXEpIHtcbiAgICAgICAgdGhpcy5pbmNyZW1lbnRfbW9udGhkYXkodGhpcy5ydWxlLmludGVydmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaW5jcmVtZW50X21vbnRoZGF5KDEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgbmV4dF93ZWVrOiBmdW5jdGlvbiBuZXh0X3dlZWsoKSB7XG4gICAgICB2YXIgZW5kX29mX2RhdGEgPSAwO1xuXG4gICAgICBpZiAodGhpcy5uZXh0X3dlZWtkYXlfYnlfd2VlaygpID09IDApIHtcbiAgICAgICAgcmV0dXJuIGVuZF9vZl9kYXRhO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5oYXNfYnlfZGF0YShcIkJZV0VFS05PXCIpKSB7XG4gICAgICAgIHZhciBpZHggPSArK3RoaXMuYnlfaW5kaWNlcy5CWVdFRUtOTztcblxuICAgICAgICBpZiAodGhpcy5ieV9pbmRpY2VzLkJZV0VFS05PID09IHRoaXMuYnlfZGF0YS5CWVdFRUtOTy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmJ5X2luZGljZXMuQllXRUVLTk8gPSAwO1xuICAgICAgICAgIGVuZF9vZl9kYXRhID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhBQ0sgc2hvdWxkIGJlIGZpcnN0IG1vbnRoIG9mIHRoZSB5ZWFyXG4gICAgICAgIHRoaXMubGFzdC5tb250aCA9IDE7XG4gICAgICAgIHRoaXMubGFzdC5kYXkgPSAxO1xuXG4gICAgICAgIHZhciB3ZWVrX25vID0gdGhpcy5ieV9kYXRhLkJZV0VFS05PW3RoaXMuYnlfaW5kaWNlcy5CWVdFRUtOT107XG5cbiAgICAgICAgdGhpcy5sYXN0LmRheSArPSA3ICogd2Vla19ubztcblxuICAgICAgICBpZiAoZW5kX29mX2RhdGEpIHtcbiAgICAgICAgICB0aGlzLmluY3JlbWVudF95ZWFyKDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBKdW1wIHRvIHRoZSBuZXh0IHdlZWtcbiAgICAgICAgdGhpcy5pbmNyZW1lbnRfbW9udGhkYXkoNyAqIHRoaXMucnVsZS5pbnRlcnZhbCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbmRfb2ZfZGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplIGVhY2ggYnkgZGF5IHJ1bGUgZm9yIGEgZ2l2ZW4geWVhci9tb250aC5cbiAgICAgKiBUYWtlcyBpbnRvIGFjY291bnQgb3JkZXJpbmcgYW5kIG5lZ2F0aXZlIHJ1bGVzXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5ZWFyICAgICAgICAgQ3VycmVudCB5ZWFyLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtb250aCAgICAgICAgQ3VycmVudCBtb250aC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgcnVsZXMgICAgICAgIEFycmF5IG9mIHJ1bGVzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7QXJyYXl9IHNvcnRlZCBhbmQgbm9ybWFsaXplZCBydWxlcy5cbiAgICAgKiAgICAgICAgICAgICAgICAgTmVnYXRpdmUgcnVsZXMgd2lsbCBiZSBleHBhbmRlZCB0byB0aGVpclxuICAgICAqICAgICAgICAgICAgICAgICBjb3JyZWN0IHBvc2l0aXZlIHZhbHVlcyBmb3IgZWFzaWVyIHByb2Nlc3NpbmcuXG4gICAgICovXG4gICAgbm9ybWFsaXplQnlNb250aERheVJ1bGVzOiBmdW5jdGlvbih5ZWFyLCBtb250aCwgcnVsZXMpIHtcbiAgICAgIHZhciBkYXlzSW5Nb250aCA9IElDQUwuVGltZS5kYXlzSW5Nb250aChtb250aCwgeWVhcik7XG5cbiAgICAgIC8vIFhYWDogVGhpcyBpcyBwcm9iYWJseSBiYWQgZm9yIHBlcmZvcm1hbmNlIHRvIGFsbG9jYXRlXG4gICAgICAvLyAgICAgIGEgbmV3IGFycmF5IGZvciBlYWNoIG1vbnRoIHdlIHNjYW4sIGlmIHBvc3NpYmxlXG4gICAgICAvLyAgICAgIHdlIHNob3VsZCB0cnkgdG8gb3B0aW1pemUgdGhpcy4uLlxuICAgICAgdmFyIG5ld1J1bGVzID0gW107XG5cbiAgICAgIHZhciBydWxlSWR4ID0gMDtcbiAgICAgIHZhciBsZW4gPSBydWxlcy5sZW5ndGg7XG4gICAgICB2YXIgcnVsZTtcblxuICAgICAgZm9yICg7IHJ1bGVJZHggPCBsZW47IHJ1bGVJZHgrKykge1xuICAgICAgICBydWxlID0gcnVsZXNbcnVsZUlkeF07XG5cbiAgICAgICAgLy8gaWYgdGhpcyBydWxlIGZhbGxzIG91dHNpZGUgb2YgZ2l2ZW5cbiAgICAgICAgLy8gbW9udGggZGlzY2FyZCBpdC5cbiAgICAgICAgaWYgKE1hdGguYWJzKHJ1bGUpID4gZGF5c0luTW9udGgpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5lZ2F0aXZlIGNhc2VcbiAgICAgICAgaWYgKHJ1bGUgPCAwKSB7XG4gICAgICAgICAgLy8gd2UgYWRkIChub3Qgc3VidHJhY3QgaXQgaXMgYSBuZWdhdGl2ZSBudW1iZXIpXG4gICAgICAgICAgLy8gb25lIGZyb20gdGhlIHJ1bGUgYmVjYXVzZSAxID09PSBsYXN0IGRheSBvZiBtb250aFxuICAgICAgICAgIHJ1bGUgPSBkYXlzSW5Nb250aCArIChydWxlICsgMSk7XG4gICAgICAgIH0gZWxzZSBpZiAocnVsZSA9PT0gMCkge1xuICAgICAgICAgIC8vIHNraXAgemVybzogaXQgaXMgaW52YWxpZC5cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG9ubHkgYWRkIHVuaXF1ZSBpdGVtcy4uLlxuICAgICAgICBpZiAobmV3UnVsZXMuaW5kZXhPZihydWxlKSA9PT0gLTEpIHtcbiAgICAgICAgICBuZXdSdWxlcy5wdXNoKHJ1bGUpO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgLy8gdW5pcXVlIGFuZCBzb3J0XG4gICAgICByZXR1cm4gbmV3UnVsZXMuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhIC0gYjsgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE5PVEVTOlxuICAgICAqIFdlIGFyZSBnaXZlbiBhIGxpc3Qgb2YgZGF0ZXMgaW4gdGhlIG1vbnRoIChCWU1PTlRIREFZKSAoMjMsIGV0Yy4uKVxuICAgICAqIEFsc28gd2UgYXJlIGdpdmVuIGEgbGlzdCBvZiBkYXlzIChCWURBWSkgKE1PLCAyU1UsIGV0Yy4uKSB3aGVuXG4gICAgICogYm90aCBjb25kaXRpb25zIG1hdGNoIGEgZ2l2ZW4gZGF0ZSAodGhpcy5sYXN0LmRheSkgaXRlcmF0aW9uIHN0b3BzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW49fSBpc0luaXQgICAgIFdoZW4gZ2l2ZW4gdHJ1ZSB3aWxsIG5vdCBpbmNyZW1lbnQgdGhlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgZGF5ICh0aGlzLmxhc3QpLlxuICAgICAqL1xuICAgIF9ieURheUFuZE1vbnRoRGF5OiBmdW5jdGlvbihpc0luaXQpIHtcbiAgICAgIHZhciBieU1vbnRoRGF5OyAvLyBzZXR1cCBpbiBpbml0TW9udGhcbiAgICAgIHZhciBieURheSA9IHRoaXMuYnlfZGF0YS5CWURBWTtcblxuICAgICAgdmFyIGRhdGU7XG4gICAgICB2YXIgZGF0ZUlkeCA9IDA7XG4gICAgICB2YXIgZGF0ZUxlbjsgLy8gc2V0dXAgaW4gaW5pdE1vbnRoXG4gICAgICB2YXIgZGF5TGVuID0gYnlEYXkubGVuZ3RoO1xuXG4gICAgICAvLyB3ZSBhcmUgbm90IHZhbGlkIGJ5IGRlZmF1bHRcbiAgICAgIHZhciBkYXRhSXNWYWxpZCA9IDA7XG5cbiAgICAgIHZhciBkYXlzSW5Nb250aDtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIC8vIHdlIG5lZWQgYSBjb3B5IG9mIHRoaXMsIGJlY2F1c2UgYSBEYXRlVGltZSBnZXRzIG5vcm1hbGl6ZWRcbiAgICAgIC8vIGF1dG9tYXRpY2FsbHkgaWYgdGhlIGRheSBpcyBvdXQgb2YgcmFuZ2UuIEF0IHNvbWUgcG9pbnRzIHdlXG4gICAgICAvLyBzZXQgdGhlIGxhc3QgZGF5IHRvIDAgdG8gc3RhcnQgY291bnRpbmcuXG4gICAgICB2YXIgbGFzdERheSA9IHRoaXMubGFzdC5kYXk7XG5cbiAgICAgIGZ1bmN0aW9uIGluaXRNb250aCgpIHtcbiAgICAgICAgZGF5c0luTW9udGggPSBJQ0FMLlRpbWUuZGF5c0luTW9udGgoXG4gICAgICAgICAgc2VsZi5sYXN0Lm1vbnRoLCBzZWxmLmxhc3QueWVhclxuICAgICAgICApO1xuXG4gICAgICAgIGJ5TW9udGhEYXkgPSBzZWxmLm5vcm1hbGl6ZUJ5TW9udGhEYXlSdWxlcyhcbiAgICAgICAgICBzZWxmLmxhc3QueWVhcixcbiAgICAgICAgICBzZWxmLmxhc3QubW9udGgsXG4gICAgICAgICAgc2VsZi5ieV9kYXRhLkJZTU9OVEhEQVlcbiAgICAgICAgKTtcblxuICAgICAgICBkYXRlTGVuID0gYnlNb250aERheS5sZW5ndGg7XG5cbiAgICAgICAgLy8gRm9yIHRoZSBjYXNlIG9mIG1vcmUgdGhhbiBvbmUgb2NjdXJyZW5jZSBpbiBvbmUgbW9udGhcbiAgICAgICAgLy8gd2UgaGF2ZSB0byBiZSBzdXJlIHRvIHN0YXJ0IHNlYXJjaGluZyBhZnRlciB0aGUgbGFzdFxuICAgICAgICAvLyBmb3VuZCBkYXRlIG9yIGF0IHRoZSBsYXN0IEJZTU9OVEhEQVksIHVubGVzcyB3ZSBhcmVcbiAgICAgICAgLy8gaW5pdGlhbGl6aW5nIHRoZSBpdGVyYXRvciBiZWNhdXNlIGluIHRoaXMgY2FzZSB3ZSBoYXZlXG4gICAgICAgIC8vIHRvIGNvbnNpZGVyIHRoZSBsYXN0IGZvdW5kIGRhdGUgdG9vLlxuICAgICAgICB3aGlsZSAoYnlNb250aERheVtkYXRlSWR4XSA8PSBsYXN0RGF5ICYmXG4gICAgICAgICAgICAgICAhKGlzSW5pdCAmJiBieU1vbnRoRGF5W2RhdGVJZHhdID09IGxhc3REYXkpICYmXG4gICAgICAgICAgICAgICBkYXRlSWR4IDwgZGF0ZUxlbiAtIDEpIHtcbiAgICAgICAgICBkYXRlSWR4Kys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbmV4dE1vbnRoKCkge1xuICAgICAgICAvLyBzaW5jZSB0aGUgZGF5IGlzIGluY3JlbWVudGVkIGF0IHRoZSBzdGFydFxuICAgICAgICAvLyBvZiB0aGUgbG9vcCBiZWxvdywgd2UgbmVlZCB0byBzdGFydCBhdCAwXG4gICAgICAgIGxhc3REYXkgPSAwO1xuICAgICAgICBzZWxmLmluY3JlbWVudF9tb250aCgpO1xuICAgICAgICBkYXRlSWR4ID0gMDtcbiAgICAgICAgaW5pdE1vbnRoKCk7XG4gICAgICB9XG5cbiAgICAgIGluaXRNb250aCgpO1xuXG4gICAgICAvLyBzaG91bGQgY29tZSBhZnRlciBpbml0TW9udGhcbiAgICAgIGlmIChpc0luaXQpIHtcbiAgICAgICAgbGFzdERheSAtPSAxO1xuICAgICAgfVxuXG4gICAgICAvLyBVc2UgYSBjb3VudGVyIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3Agd2l0aCBtYWxmb3JtZWQgcnVsZXMuXG4gICAgICAvLyBTdG9wIGNoZWNraW5nIGFmdGVyIDQgeWVhcnMgc28gd2UgY29uc2lkZXIgYWxzbyBhIGxlYXAgeWVhci5cbiAgICAgIHZhciBtb250aHNDb3VudGVyID0gNDg7XG5cbiAgICAgIHdoaWxlICghZGF0YUlzVmFsaWQgJiYgbW9udGhzQ291bnRlcikge1xuICAgICAgICBtb250aHNDb3VudGVyLS07XG4gICAgICAgIC8vIGluY3JlbWVudCB0aGUgY3VycmVudCBkYXRlLiBUaGlzIGlzIHJlYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgb3RoZXJ3aXNlIHdlIG1heSBmYWxsIGludG8gdGhlIGluZmluaXRlXG4gICAgICAgIC8vIGxvb3AgdHJhcC4gVGhlIGluaXRpYWwgZGF0ZSB0YWtlcyBjYXJlIG9mIHRoZSBjYXNlXG4gICAgICAgIC8vIHdoZXJlIHRoZSBjdXJyZW50IGRhdGUgaXMgdGhlIGRhdGUgd2UgYXJlIGxvb2tpbmdcbiAgICAgICAgLy8gZm9yLlxuICAgICAgICBkYXRlID0gbGFzdERheSArIDE7XG5cbiAgICAgICAgaWYgKGRhdGUgPiBkYXlzSW5Nb250aCkge1xuICAgICAgICAgIG5leHRNb250aCgpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluZCBuZXh0IGRhdGVcbiAgICAgICAgdmFyIG5leHQgPSBieU1vbnRoRGF5W2RhdGVJZHgrK107XG5cbiAgICAgICAgLy8gdGhpcyBsb2dpYyBpcyBkZXBlbmRhbnQgb24gdGhlIEJZTU9OVEhEQVlTXG4gICAgICAgIC8vIGJlaW5nIGluIG9yZGVyICh3aGljaCBpcyBkb25lIGJ5ICNub3JtYWxpemVCeU1vbnRoRGF5UnVsZXMpXG4gICAgICAgIGlmIChuZXh0ID49IGRhdGUpIHtcbiAgICAgICAgICAvLyBpZiB0aGUgbmV4dCBtb250aCBkYXkgaXMgaW4gdGhlIGZ1dHVyZSBqdW1wIHRvIGl0LlxuICAgICAgICAgIGxhc3REYXkgPSBuZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGluIHRoaXMgY2FzZSB0aGUgJ25leHQnIG1vbnRoZGF5IGhhcyBwYXN0XG4gICAgICAgICAgLy8gd2UgbXVzdCBtb3ZlIHRvIHRoZSBtb250aC5cbiAgICAgICAgICBuZXh0TW9udGgoKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vdyB3ZSBjYW4gbG9vcCB0aHJvdWdoIHRoZSBkYXkgcnVsZXMgdG8gc2VlXG4gICAgICAgIC8vIGlmIG9uZSBtYXRjaGVzIHRoZSBjdXJyZW50IG1vbnRoIGRhdGUuXG4gICAgICAgIGZvciAodmFyIGRheUlkeCA9IDA7IGRheUlkeCA8IGRheUxlbjsgZGF5SWR4KyspIHtcbiAgICAgICAgICB2YXIgcGFydHMgPSB0aGlzLnJ1bGVEYXlPZldlZWsoYnlEYXlbZGF5SWR4XSk7XG4gICAgICAgICAgdmFyIHBvcyA9IHBhcnRzWzBdO1xuICAgICAgICAgIHZhciBkb3cgPSBwYXJ0c1sxXTtcblxuICAgICAgICAgIHRoaXMubGFzdC5kYXkgPSBsYXN0RGF5O1xuICAgICAgICAgIGlmICh0aGlzLmxhc3QuaXNOdGhXZWVrRGF5KGRvdywgcG9zKSkge1xuICAgICAgICAgICAgLy8gd2hlbiB3ZSBmaW5kIHRoZSB2YWxpZCBvbmUgd2UgY2FuIG1hcmtcbiAgICAgICAgICAgIC8vIHRoZSBjb25kaXRpb25zIGFzIG1ldCBhbmQgYnJlYWsgdGhlIGxvb3AuXG4gICAgICAgICAgICAvLyAoQmVjYXVzZSB3ZSBoYXZlIHRoaXMgY29uZGl0aW9uIGFib3ZlXG4gICAgICAgICAgICAvLyAgaXQgd2lsbCBhbHNvIGJyZWFrIHRoZSBwYXJlbnQgbG9vcCkuXG4gICAgICAgICAgICBkYXRhSXNWYWxpZCA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJdCBpcyBjb21wbGV0ZWx5IHBvc3NpYmxlIHRoYXQgdGhlIGNvbWJpbmF0aW9uXG4gICAgICAgIC8vIGNhbm5vdCBiZSBtYXRjaGVkIGluIHRoZSBjdXJyZW50IG1vbnRoLlxuICAgICAgICAvLyBXaGVuIHdlIHJlYWNoIHRoZSBlbmQgb2YgcG9zc2libGUgY29tYmluYXRpb25zXG4gICAgICAgIC8vIGluIHRoZSBjdXJyZW50IG1vbnRoIHdlIGl0ZXJhdGUgdG8gdGhlIG5leHQgb25lLlxuICAgICAgICAvLyBzaW5jZSBkYXRlSWR4IGlzIGluY3JlbWVudGVkIHJpZ2h0IGFmdGVyIGdldHRpbmdcbiAgICAgICAgLy8gXCJuZXh0XCIsIHdlIGRvbid0IG5lZWQgZGF0ZUxlbiAtMSBoZXJlLlxuICAgICAgICBpZiAoIWRhdGFJc1ZhbGlkICYmIGRhdGVJZHggPT09IGRhdGVMZW4pIHtcbiAgICAgICAgICBuZXh0TW9udGgoKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobW9udGhzQ291bnRlciA8PSAwKSB7XG4gICAgICAgIC8vIENoZWNrZWQgNCB5ZWFycyB3aXRob3V0IGZpbmRpbmcgYSBCeWRheSB0aGF0IG1hdGNoZXNcbiAgICAgICAgLy8gYSBCeW1vbnRoZGF5LiBNYXliZSB0aGUgcnVsZSBpcyBub3QgY29ycmVjdC5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWFsZm9ybWVkIHZhbHVlcyBpbiBCWURBWSBjb21iaW5lZCB3aXRoIEJZTU9OVEhEQVkgcGFydHNcIik7XG4gICAgICB9XG5cblxuICAgICAgcmV0dXJuIGRhdGFJc1ZhbGlkO1xuICAgIH0sXG5cbiAgICBuZXh0X21vbnRoOiBmdW5jdGlvbiBuZXh0X21vbnRoKCkge1xuICAgICAgdmFyIHRoaXNfZnJlcSA9ICh0aGlzLnJ1bGUuZnJlcSA9PSBcIk1PTlRITFlcIik7XG4gICAgICB2YXIgZGF0YV92YWxpZCA9IDE7XG5cbiAgICAgIGlmICh0aGlzLm5leHRfaG91cigpID09IDApIHtcbiAgICAgICAgcmV0dXJuIGRhdGFfdmFsaWQ7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmhhc19ieV9kYXRhKFwiQllEQVlcIikgJiYgdGhpcy5oYXNfYnlfZGF0YShcIkJZTU9OVEhEQVlcIikpIHtcbiAgICAgICAgZGF0YV92YWxpZCA9IHRoaXMuX2J5RGF5QW5kTW9udGhEYXkoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5oYXNfYnlfZGF0YShcIkJZREFZXCIpKSB7XG4gICAgICAgIHZhciBkYXlzSW5Nb250aCA9IElDQUwuVGltZS5kYXlzSW5Nb250aCh0aGlzLmxhc3QubW9udGgsIHRoaXMubGFzdC55ZWFyKTtcbiAgICAgICAgdmFyIHNldHBvcyA9IDA7XG4gICAgICAgIHZhciBzZXRwb3NfdG90YWwgPSAwO1xuXG4gICAgICAgIGlmICh0aGlzLmhhc19ieV9kYXRhKFwiQllTRVRQT1NcIikpIHtcbiAgICAgICAgICB2YXIgbGFzdF9kYXkgPSB0aGlzLmxhc3QuZGF5O1xuICAgICAgICAgIGZvciAodmFyIGRheSA9IDE7IGRheSA8PSBkYXlzSW5Nb250aDsgZGF5KyspIHtcbiAgICAgICAgICAgIHRoaXMubGFzdC5kYXkgPSBkYXk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc19kYXlfaW5fYnlkYXkodGhpcy5sYXN0KSkge1xuICAgICAgICAgICAgICBzZXRwb3NfdG90YWwrKztcbiAgICAgICAgICAgICAgaWYgKGRheSA8PSBsYXN0X2RheSkge1xuICAgICAgICAgICAgICAgIHNldHBvcysrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubGFzdC5kYXkgPSBsYXN0X2RheTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGFfdmFsaWQgPSAwO1xuICAgICAgICBmb3IgKHZhciBkYXkgPSB0aGlzLmxhc3QuZGF5ICsgMTsgZGF5IDw9IGRheXNJbk1vbnRoOyBkYXkrKykge1xuICAgICAgICAgIHRoaXMubGFzdC5kYXkgPSBkYXk7XG5cbiAgICAgICAgICBpZiAodGhpcy5pc19kYXlfaW5fYnlkYXkodGhpcy5sYXN0KSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmhhc19ieV9kYXRhKFwiQllTRVRQT1NcIikgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrX3NldF9wb3NpdGlvbigrK3NldHBvcykgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrX3NldF9wb3NpdGlvbihzZXRwb3MgLSBzZXRwb3NfdG90YWwgLSAxKSkge1xuXG4gICAgICAgICAgICAgIGRhdGFfdmFsaWQgPSAxO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF5ID4gZGF5c0luTW9udGgpIHtcbiAgICAgICAgICB0aGlzLmxhc3QuZGF5ID0gMTtcbiAgICAgICAgICB0aGlzLmluY3JlbWVudF9tb250aCgpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuaXNfZGF5X2luX2J5ZGF5KHRoaXMubGFzdCkpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5oYXNfYnlfZGF0YShcIkJZU0VUUE9TXCIpIHx8IHRoaXMuY2hlY2tfc2V0X3Bvc2l0aW9uKDEpKSB7XG4gICAgICAgICAgICAgIGRhdGFfdmFsaWQgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhX3ZhbGlkID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5oYXNfYnlfZGF0YShcIkJZTU9OVEhEQVlcIikpIHtcbiAgICAgICAgdGhpcy5ieV9pbmRpY2VzLkJZTU9OVEhEQVkrKztcblxuICAgICAgICBpZiAodGhpcy5ieV9pbmRpY2VzLkJZTU9OVEhEQVkgPj0gdGhpcy5ieV9kYXRhLkJZTU9OVEhEQVkubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5ieV9pbmRpY2VzLkJZTU9OVEhEQVkgPSAwO1xuICAgICAgICAgIHRoaXMuaW5jcmVtZW50X21vbnRoKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF5c0luTW9udGggPSBJQ0FMLlRpbWUuZGF5c0luTW9udGgodGhpcy5sYXN0Lm1vbnRoLCB0aGlzLmxhc3QueWVhcik7XG4gICAgICAgIHZhciBkYXkgPSB0aGlzLmJ5X2RhdGEuQllNT05USERBWVt0aGlzLmJ5X2luZGljZXMuQllNT05USERBWV07XG5cbiAgICAgICAgaWYgKGRheSA8IDApIHtcbiAgICAgICAgICBkYXkgPSBkYXlzSW5Nb250aCArIGRheSArIDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF5ID4gZGF5c0luTW9udGgpIHtcbiAgICAgICAgICB0aGlzLmxhc3QuZGF5ID0gMTtcbiAgICAgICAgICBkYXRhX3ZhbGlkID0gdGhpcy5pc19kYXlfaW5fYnlkYXkodGhpcy5sYXN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxhc3QuZGF5ID0gZGF5O1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaW5jcmVtZW50X21vbnRoKCk7XG4gICAgICAgIHZhciBkYXlzSW5Nb250aCA9IElDQUwuVGltZS5kYXlzSW5Nb250aCh0aGlzLmxhc3QubW9udGgsIHRoaXMubGFzdC55ZWFyKTtcbiAgICAgICAgaWYgKHRoaXMuYnlfZGF0YS5CWU1PTlRIREFZWzBdID4gZGF5c0luTW9udGgpIHtcbiAgICAgICAgICBkYXRhX3ZhbGlkID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxhc3QuZGF5ID0gdGhpcy5ieV9kYXRhLkJZTU9OVEhEQVlbMF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGFfdmFsaWQ7XG4gICAgfSxcblxuICAgIG5leHRfd2Vla2RheV9ieV93ZWVrOiBmdW5jdGlvbiBuZXh0X3dlZWtkYXlfYnlfd2VlaygpIHtcbiAgICAgIHZhciBlbmRfb2ZfZGF0YSA9IDA7XG5cbiAgICAgIGlmICh0aGlzLm5leHRfaG91cigpID09IDApIHtcbiAgICAgICAgcmV0dXJuIGVuZF9vZl9kYXRhO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuaGFzX2J5X2RhdGEoXCJCWURBWVwiKSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7Oykge1xuICAgICAgICB2YXIgdHQgPSBuZXcgSUNBTC5UaW1lKCk7XG4gICAgICAgIHRoaXMuYnlfaW5kaWNlcy5CWURBWSsrO1xuXG4gICAgICAgIGlmICh0aGlzLmJ5X2luZGljZXMuQllEQVkgPT0gT2JqZWN0LmtleXModGhpcy5ieV9kYXRhLkJZREFZKS5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmJ5X2luZGljZXMuQllEQVkgPSAwO1xuICAgICAgICAgIGVuZF9vZl9kYXRhID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb2RlZF9kYXkgPSB0aGlzLmJ5X2RhdGEuQllEQVlbdGhpcy5ieV9pbmRpY2VzLkJZREFZXTtcbiAgICAgICAgdmFyIHBhcnRzID0gdGhpcy5ydWxlRGF5T2ZXZWVrKGNvZGVkX2RheSk7XG4gICAgICAgIHZhciBkb3cgPSBwYXJ0c1sxXTtcblxuICAgICAgICBkb3cgLT0gdGhpcy5ydWxlLndrc3Q7XG5cbiAgICAgICAgaWYgKGRvdyA8IDApIHtcbiAgICAgICAgICBkb3cgKz0gNztcbiAgICAgICAgfVxuXG4gICAgICAgIHR0LnllYXIgPSB0aGlzLmxhc3QueWVhcjtcbiAgICAgICAgdHQubW9udGggPSB0aGlzLmxhc3QubW9udGg7XG4gICAgICAgIHR0LmRheSA9IHRoaXMubGFzdC5kYXk7XG5cbiAgICAgICAgdmFyIHN0YXJ0T2ZXZWVrID0gdHQuc3RhcnREb3lXZWVrKHRoaXMucnVsZS53a3N0KTtcblxuICAgICAgICBpZiAoZG93ICsgc3RhcnRPZldlZWsgPCAxKSB7XG4gICAgICAgICAgLy8gVGhlIHNlbGVjdGVkIGRhdGUgaXMgaW4gdGhlIHByZXZpb3VzIHllYXJcbiAgICAgICAgICBpZiAoIWVuZF9vZl9kYXRhKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV4dCA9IElDQUwuVGltZS5mcm9tRGF5T2ZZZWFyKHN0YXJ0T2ZXZWVrICsgZG93LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3QueWVhcik7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBub3JtYWxpemF0aW9uIGhvcnJvcnMgYmVsb3cgYXJlIGR1ZSB0b1xuICAgICAgICAgKiB0aGUgZmFjdCB0aGF0IHdoZW4gdGhlIHllYXIvbW9udGgvZGF5IGNoYW5nZXNcbiAgICAgICAgICogaXQgY2FuIGVmZmVjdCB0aGUgb3RoZXIgb3BlcmF0aW9ucyB0aGF0IGNvbWUgYWZ0ZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxhc3QueWVhciA9IG5leHQueWVhcjtcbiAgICAgICAgdGhpcy5sYXN0Lm1vbnRoID0gbmV4dC5tb250aDtcbiAgICAgICAgdGhpcy5sYXN0LmRheSA9IG5leHQuZGF5O1xuXG4gICAgICAgIHJldHVybiBlbmRfb2ZfZGF0YTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgbmV4dF95ZWFyOiBmdW5jdGlvbiBuZXh0X3llYXIoKSB7XG5cbiAgICAgIGlmICh0aGlzLm5leHRfaG91cigpID09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIGlmICgrK3RoaXMuZGF5c19pbmRleCA9PSB0aGlzLmRheXMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuZGF5c19pbmRleCA9IDA7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICB0aGlzLmluY3JlbWVudF95ZWFyKHRoaXMucnVsZS5pbnRlcnZhbCk7XG4gICAgICAgICAgdGhpcy5leHBhbmRfeWVhcl9kYXlzKHRoaXMubGFzdC55ZWFyKTtcbiAgICAgICAgfSB3aGlsZSAodGhpcy5kYXlzLmxlbmd0aCA9PSAwKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fbmV4dEJ5WWVhckRheSgpO1xuXG4gICAgICByZXR1cm4gMTtcbiAgICB9LFxuXG4gICAgX25leHRCeVllYXJEYXk6IGZ1bmN0aW9uIF9uZXh0QnlZZWFyRGF5KCkge1xuICAgICAgICB2YXIgZG95ID0gdGhpcy5kYXlzW3RoaXMuZGF5c19pbmRleF07XG4gICAgICAgIHZhciB5ZWFyID0gdGhpcy5sYXN0LnllYXI7XG4gICAgICAgIGlmIChkb3kgPCAxKSB7XG4gICAgICAgICAgICAvLyBUaW1lLmZyb21EYXlPZlllYXIoZG95LCB5ZWFyKSBpbmRleGVzIHJlbGF0aXZlIHRvIHRoZVxuICAgICAgICAgICAgLy8gc3RhcnQgb2YgdGhlIGdpdmVuIHllYXIuIFRoYXQgaXMgZGlmZmVyZW50IGZyb20gdGhlXG4gICAgICAgICAgICAvLyBzZW1hbnRpY3Mgb2YgQllZRUFSREFZIHdoZXJlIG5lZ2F0aXZlIGluZGV4ZXMgYXJlIGFuXG4gICAgICAgICAgICAvLyBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIHRoZSBnaXZlbiB5ZWFyLlxuICAgICAgICAgICAgZG95ICs9IDE7XG4gICAgICAgICAgICB5ZWFyICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5leHQgPSBJQ0FMLlRpbWUuZnJvbURheU9mWWVhcihkb3ksIHllYXIpO1xuICAgICAgICB0aGlzLmxhc3QuZGF5ID0gbmV4dC5kYXk7XG4gICAgICAgIHRoaXMubGFzdC5tb250aCA9IG5leHQubW9udGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBkb3cgKGVnOiAnMVRVJywgJy0xTU8nKVxuICAgICAqIEBwYXJhbSB7SUNBTC5UaW1lLndlZWtEYXk9fSBhV2Vla1N0YXJ0IFRoZSB3ZWVrIHN0YXJ0IHdlZWtkYXlcbiAgICAgKiBAcmV0dXJuIFtwb3MsIG51bWVyaWNEb3ddIChlZzogWzEsIDNdKSBudW1lcmljRG93IGlzIHJlbGF0aXZlIHRvIGFXZWVrU3RhcnRcbiAgICAgKi9cbiAgICBydWxlRGF5T2ZXZWVrOiBmdW5jdGlvbiBydWxlRGF5T2ZXZWVrKGRvdywgYVdlZWtTdGFydCkge1xuICAgICAgdmFyIG1hdGNoZXMgPSBkb3cubWF0Y2goLyhbKy1dP1swLTldKT8oTU98VFV8V0V8VEh8RlJ8U0F8U1UpLyk7XG4gICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICB2YXIgcG9zID0gcGFyc2VJbnQobWF0Y2hlc1sxXSB8fCAwLCAxMCk7XG4gICAgICAgIGRvdyA9IElDQUwuUmVjdXIuaWNhbERheVRvTnVtZXJpY0RheShtYXRjaGVzWzJdLCBhV2Vla1N0YXJ0KTtcbiAgICAgICAgcmV0dXJuIFtwb3MsIGRvd107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gWzAsIDBdO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBuZXh0X2dlbmVyaWM6IGZ1bmN0aW9uIG5leHRfZ2VuZXJpYyhhUnVsZVR5cGUsIGFJbnRlcnZhbCwgYURhdGVBdHRyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFGb2xsb3dpbmdBdHRyLCBhUHJldmlvdXNJbmNyKSB7XG4gICAgICB2YXIgaGFzX2J5X3J1bGUgPSAoYVJ1bGVUeXBlIGluIHRoaXMuYnlfZGF0YSk7XG4gICAgICB2YXIgdGhpc19mcmVxID0gKHRoaXMucnVsZS5mcmVxID09IGFJbnRlcnZhbCk7XG4gICAgICB2YXIgZW5kX29mX2RhdGEgPSAwO1xuXG4gICAgICBpZiAoYVByZXZpb3VzSW5jciAmJiB0aGlzW2FQcmV2aW91c0luY3JdKCkgPT0gMCkge1xuICAgICAgICByZXR1cm4gZW5kX29mX2RhdGE7XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNfYnlfcnVsZSkge1xuICAgICAgICB0aGlzLmJ5X2luZGljZXNbYVJ1bGVUeXBlXSsrO1xuICAgICAgICB2YXIgaWR4ID0gdGhpcy5ieV9pbmRpY2VzW2FSdWxlVHlwZV07XG4gICAgICAgIHZhciBkdGEgPSB0aGlzLmJ5X2RhdGFbYVJ1bGVUeXBlXTtcblxuICAgICAgICBpZiAodGhpcy5ieV9pbmRpY2VzW2FSdWxlVHlwZV0gPT0gZHRhLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuYnlfaW5kaWNlc1thUnVsZVR5cGVdID0gMDtcbiAgICAgICAgICBlbmRfb2ZfZGF0YSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0W2FEYXRlQXR0cl0gPSBkdGFbdGhpcy5ieV9pbmRpY2VzW2FSdWxlVHlwZV1dO1xuICAgICAgfSBlbHNlIGlmICh0aGlzX2ZyZXEpIHtcbiAgICAgICAgdGhpc1tcImluY3JlbWVudF9cIiArIGFEYXRlQXR0cl0odGhpcy5ydWxlLmludGVydmFsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhc19ieV9ydWxlICYmIGVuZF9vZl9kYXRhICYmIHRoaXNfZnJlcSkge1xuICAgICAgICB0aGlzW1wiaW5jcmVtZW50X1wiICsgYUZvbGxvd2luZ0F0dHJdKDEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZW5kX29mX2RhdGE7XG4gICAgfSxcblxuICAgIGluY3JlbWVudF9tb250aGRheTogZnVuY3Rpb24gaW5jcmVtZW50X21vbnRoZGF5KGluYykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmM7IGkrKykge1xuICAgICAgICB2YXIgZGF5c0luTW9udGggPSBJQ0FMLlRpbWUuZGF5c0luTW9udGgodGhpcy5sYXN0Lm1vbnRoLCB0aGlzLmxhc3QueWVhcik7XG4gICAgICAgIHRoaXMubGFzdC5kYXkrKztcblxuICAgICAgICBpZiAodGhpcy5sYXN0LmRheSA+IGRheXNJbk1vbnRoKSB7XG4gICAgICAgICAgdGhpcy5sYXN0LmRheSAtPSBkYXlzSW5Nb250aDtcbiAgICAgICAgICB0aGlzLmluY3JlbWVudF9tb250aCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGluY3JlbWVudF9tb250aDogZnVuY3Rpb24gaW5jcmVtZW50X21vbnRoKCkge1xuICAgICAgdGhpcy5sYXN0LmRheSA9IDE7XG4gICAgICBpZiAodGhpcy5oYXNfYnlfZGF0YShcIkJZTU9OVEhcIikpIHtcbiAgICAgICAgdGhpcy5ieV9pbmRpY2VzLkJZTU9OVEgrKztcblxuICAgICAgICBpZiAodGhpcy5ieV9pbmRpY2VzLkJZTU9OVEggPT0gdGhpcy5ieV9kYXRhLkJZTU9OVEgubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5ieV9pbmRpY2VzLkJZTU9OVEggPSAwO1xuICAgICAgICAgIHRoaXMuaW5jcmVtZW50X3llYXIoMSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxhc3QubW9udGggPSB0aGlzLmJ5X2RhdGEuQllNT05USFt0aGlzLmJ5X2luZGljZXMuQllNT05USF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5ydWxlLmZyZXEgPT0gXCJNT05USExZXCIpIHtcbiAgICAgICAgICB0aGlzLmxhc3QubW9udGggKz0gdGhpcy5ydWxlLmludGVydmFsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubGFzdC5tb250aCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sYXN0Lm1vbnRoLS07XG4gICAgICAgIHZhciB5ZWFycyA9IElDQUwuaGVscGVycy50cnVuYyh0aGlzLmxhc3QubW9udGggLyAxMik7XG4gICAgICAgIHRoaXMubGFzdC5tb250aCAlPSAxMjtcbiAgICAgICAgdGhpcy5sYXN0Lm1vbnRoKys7XG5cbiAgICAgICAgaWYgKHllYXJzICE9IDApIHtcbiAgICAgICAgICB0aGlzLmluY3JlbWVudF95ZWFyKHllYXJzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBpbmNyZW1lbnRfeWVhcjogZnVuY3Rpb24gaW5jcmVtZW50X3llYXIoaW5jKSB7XG4gICAgICB0aGlzLmxhc3QueWVhciArPSBpbmM7XG4gICAgfSxcblxuICAgIGluY3JlbWVudF9nZW5lcmljOiBmdW5jdGlvbiBpbmNyZW1lbnRfZ2VuZXJpYyhpbmMsIGFEYXRlQXR0cixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYUZhY3RvciwgYU5leHRJbmNyZW1lbnQpIHtcbiAgICAgIHRoaXMubGFzdFthRGF0ZUF0dHJdICs9IGluYztcbiAgICAgIHZhciBuZXh0dW5pdCA9IElDQUwuaGVscGVycy50cnVuYyh0aGlzLmxhc3RbYURhdGVBdHRyXSAvIGFGYWN0b3IpO1xuICAgICAgdGhpcy5sYXN0W2FEYXRlQXR0cl0gJT0gYUZhY3RvcjtcbiAgICAgIGlmIChuZXh0dW5pdCAhPSAwKSB7XG4gICAgICAgIHRoaXNbXCJpbmNyZW1lbnRfXCIgKyBhTmV4dEluY3JlbWVudF0obmV4dHVuaXQpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBoYXNfYnlfZGF0YTogZnVuY3Rpb24gaGFzX2J5X2RhdGEoYVJ1bGVUeXBlKSB7XG4gICAgICByZXR1cm4gKGFSdWxlVHlwZSBpbiB0aGlzLnJ1bGUucGFydHMpO1xuICAgIH0sXG5cbiAgICBleHBhbmRfeWVhcl9kYXlzOiBmdW5jdGlvbiBleHBhbmRfeWVhcl9kYXlzKGFZZWFyKSB7XG4gICAgICB2YXIgdCA9IG5ldyBJQ0FMLlRpbWUoKTtcbiAgICAgIHRoaXMuZGF5cyA9IFtdO1xuXG4gICAgICAvLyBXZSBuZWVkIG91ciBvd24gY29weSB3aXRoIGEgZmV3IGtleXMgc2V0XG4gICAgICB2YXIgcGFydHMgPSB7fTtcbiAgICAgIHZhciBydWxlcyA9IFtcIkJZREFZXCIsIFwiQllXRUVLTk9cIiwgXCJCWU1PTlRIREFZXCIsIFwiQllNT05USFwiLCBcIkJZWUVBUkRBWVwiXTtcbiAgICAgIGZvciAodmFyIHAgaW4gcnVsZXMpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKHJ1bGVzLmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICAgICAgdmFyIHBhcnQgPSBydWxlc1twXTtcbiAgICAgICAgICBpZiAocGFydCBpbiB0aGlzLnJ1bGUucGFydHMpIHtcbiAgICAgICAgICAgIHBhcnRzW3BhcnRdID0gdGhpcy5ydWxlLnBhcnRzW3BhcnRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoXCJCWU1PTlRIXCIgaW4gcGFydHMgJiYgXCJCWVdFRUtOT1wiIGluIHBhcnRzKSB7XG4gICAgICAgIHZhciB2YWxpZCA9IDE7XG4gICAgICAgIHZhciB2YWxpZFdlZWtzID0ge307XG4gICAgICAgIHQueWVhciA9IGFZZWFyO1xuICAgICAgICB0LmlzRGF0ZSA9IHRydWU7XG5cbiAgICAgICAgZm9yICh2YXIgbW9udGhJZHggPSAwOyBtb250aElkeCA8IHRoaXMuYnlfZGF0YS5CWU1PTlRILmxlbmd0aDsgbW9udGhJZHgrKykge1xuICAgICAgICAgIHZhciBtb250aCA9IHRoaXMuYnlfZGF0YS5CWU1PTlRIW21vbnRoSWR4XTtcbiAgICAgICAgICB0Lm1vbnRoID0gbW9udGg7XG4gICAgICAgICAgdC5kYXkgPSAxO1xuICAgICAgICAgIHZhciBmaXJzdF93ZWVrID0gdC53ZWVrTnVtYmVyKHRoaXMucnVsZS53a3N0KTtcbiAgICAgICAgICB0LmRheSA9IElDQUwuVGltZS5kYXlzSW5Nb250aChtb250aCwgYVllYXIpO1xuICAgICAgICAgIHZhciBsYXN0X3dlZWsgPSB0LndlZWtOdW1iZXIodGhpcy5ydWxlLndrc3QpO1xuICAgICAgICAgIGZvciAobW9udGhJZHggPSBmaXJzdF93ZWVrOyBtb250aElkeCA8IGxhc3Rfd2VlazsgbW9udGhJZHgrKykge1xuICAgICAgICAgICAgdmFsaWRXZWVrc1ttb250aElkeF0gPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIHdlZWtJZHggPSAwOyB3ZWVrSWR4IDwgdGhpcy5ieV9kYXRhLkJZV0VFS05PLmxlbmd0aCAmJiB2YWxpZDsgd2Vla0lkeCsrKSB7XG4gICAgICAgICAgdmFyIHdlZWtubyA9IHRoaXMuYnlfZGF0YS5CWVdFRUtOT1t3ZWVrSWR4XTtcbiAgICAgICAgICBpZiAod2Vla25vIDwgNTIpIHtcbiAgICAgICAgICAgIHZhbGlkICY9IHZhbGlkV2Vla3Nbd2Vla0lkeF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbGlkID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgICBkZWxldGUgcGFydHMuQllNT05USDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgcGFydHMuQllXRUVLTk87XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHBhcnRDb3VudCA9IE9iamVjdC5rZXlzKHBhcnRzKS5sZW5ndGg7XG5cbiAgICAgIGlmIChwYXJ0Q291bnQgPT0gMCkge1xuICAgICAgICB2YXIgdDEgPSB0aGlzLmR0c3RhcnQuY2xvbmUoKTtcbiAgICAgICAgdDEueWVhciA9IHRoaXMubGFzdC55ZWFyO1xuICAgICAgICB0aGlzLmRheXMucHVzaCh0MS5kYXlPZlllYXIoKSk7XG4gICAgICB9IGVsc2UgaWYgKHBhcnRDb3VudCA9PSAxICYmIFwiQllNT05USFwiIGluIHBhcnRzKSB7XG4gICAgICAgIGZvciAodmFyIG1vbnRoa2V5IGluIHRoaXMuYnlfZGF0YS5CWU1PTlRIKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKCF0aGlzLmJ5X2RhdGEuQllNT05USC5oYXNPd25Qcm9wZXJ0eShtb250aGtleSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdDIgPSB0aGlzLmR0c3RhcnQuY2xvbmUoKTtcbiAgICAgICAgICB0Mi55ZWFyID0gYVllYXI7XG4gICAgICAgICAgdDIubW9udGggPSB0aGlzLmJ5X2RhdGEuQllNT05USFttb250aGtleV07XG4gICAgICAgICAgdDIuaXNEYXRlID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmRheXMucHVzaCh0Mi5kYXlPZlllYXIoKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFydENvdW50ID09IDEgJiYgXCJCWU1PTlRIREFZXCIgaW4gcGFydHMpIHtcbiAgICAgICAgZm9yICh2YXIgbW9udGhkYXlrZXkgaW4gdGhpcy5ieV9kYXRhLkJZTU9OVEhEQVkpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAoIXRoaXMuYnlfZGF0YS5CWU1PTlRIREFZLmhhc093blByb3BlcnR5KG1vbnRoZGF5a2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB0MyA9IHRoaXMuZHRzdGFydC5jbG9uZSgpO1xuICAgICAgICAgIHZhciBkYXlfID0gdGhpcy5ieV9kYXRhLkJZTU9OVEhEQVlbbW9udGhkYXlrZXldO1xuICAgICAgICAgIGlmIChkYXlfIDwgMCkge1xuICAgICAgICAgICAgdmFyIGRheXNJbk1vbnRoID0gSUNBTC5UaW1lLmRheXNJbk1vbnRoKHQzLm1vbnRoLCBhWWVhcik7XG4gICAgICAgICAgICBkYXlfID0gZGF5XyArIGRheXNJbk1vbnRoICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdDMuZGF5ID0gZGF5XztcbiAgICAgICAgICB0My55ZWFyID0gYVllYXI7XG4gICAgICAgICAgdDMuaXNEYXRlID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmRheXMucHVzaCh0My5kYXlPZlllYXIoKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFydENvdW50ID09IDIgJiZcbiAgICAgICAgICAgICAgICAgXCJCWU1PTlRIREFZXCIgaW4gcGFydHMgJiZcbiAgICAgICAgICAgICAgICAgXCJCWU1PTlRIXCIgaW4gcGFydHMpIHtcbiAgICAgICAgZm9yICh2YXIgbW9udGhrZXkgaW4gdGhpcy5ieV9kYXRhLkJZTU9OVEgpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAoIXRoaXMuYnlfZGF0YS5CWU1PTlRILmhhc093blByb3BlcnR5KG1vbnRoa2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBtb250aF8gPSB0aGlzLmJ5X2RhdGEuQllNT05USFttb250aGtleV07XG4gICAgICAgICAgdmFyIGRheXNJbk1vbnRoID0gSUNBTC5UaW1lLmRheXNJbk1vbnRoKG1vbnRoXywgYVllYXIpO1xuICAgICAgICAgIGZvciAodmFyIG1vbnRoZGF5a2V5IGluIHRoaXMuYnlfZGF0YS5CWU1PTlRIREFZKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICghdGhpcy5ieV9kYXRhLkJZTU9OVEhEQVkuaGFzT3duUHJvcGVydHkobW9udGhkYXlrZXkpKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRheV8gPSB0aGlzLmJ5X2RhdGEuQllNT05USERBWVttb250aGRheWtleV07XG4gICAgICAgICAgICBpZiAoZGF5XyA8IDApIHtcbiAgICAgICAgICAgICAgZGF5XyA9IGRheV8gKyBkYXlzSW5Nb250aCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0LmRheSA9IGRheV87XG4gICAgICAgICAgICB0Lm1vbnRoID0gbW9udGhfO1xuICAgICAgICAgICAgdC55ZWFyID0gYVllYXI7XG4gICAgICAgICAgICB0LmlzRGF0ZSA9IHRydWU7XG5cbiAgICAgICAgICAgIHRoaXMuZGF5cy5wdXNoKHQuZGF5T2ZZZWFyKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJ0Q291bnQgPT0gMSAmJiBcIkJZV0VFS05PXCIgaW4gcGFydHMpIHtcbiAgICAgICAgLy8gVE9ETyB1bmltcGxlbWVudGVkIGluIGxpYmljYWxcbiAgICAgIH0gZWxzZSBpZiAocGFydENvdW50ID09IDIgJiZcbiAgICAgICAgICAgICAgICAgXCJCWVdFRUtOT1wiIGluIHBhcnRzICYmXG4gICAgICAgICAgICAgICAgIFwiQllNT05USERBWVwiIGluIHBhcnRzKSB7XG4gICAgICAgIC8vIFRPRE8gdW5pbXBsZW1lbnRlZCBpbiBsaWJpY2FsXG4gICAgICB9IGVsc2UgaWYgKHBhcnRDb3VudCA9PSAxICYmIFwiQllEQVlcIiBpbiBwYXJ0cykge1xuICAgICAgICB0aGlzLmRheXMgPSB0aGlzLmRheXMuY29uY2F0KHRoaXMuZXhwYW5kX2J5X2RheShhWWVhcikpO1xuICAgICAgfSBlbHNlIGlmIChwYXJ0Q291bnQgPT0gMiAmJiBcIkJZREFZXCIgaW4gcGFydHMgJiYgXCJCWU1PTlRIXCIgaW4gcGFydHMpIHtcbiAgICAgICAgZm9yICh2YXIgbW9udGhrZXkgaW4gdGhpcy5ieV9kYXRhLkJZTU9OVEgpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAoIXRoaXMuYnlfZGF0YS5CWU1PTlRILmhhc093blByb3BlcnR5KG1vbnRoa2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBtb250aCA9IHRoaXMuYnlfZGF0YS5CWU1PTlRIW21vbnRoa2V5XTtcbiAgICAgICAgICB2YXIgZGF5c0luTW9udGggPSBJQ0FMLlRpbWUuZGF5c0luTW9udGgobW9udGgsIGFZZWFyKTtcblxuICAgICAgICAgIHQueWVhciA9IGFZZWFyO1xuICAgICAgICAgIHQubW9udGggPSB0aGlzLmJ5X2RhdGEuQllNT05USFttb250aGtleV07XG4gICAgICAgICAgdC5kYXkgPSAxO1xuICAgICAgICAgIHQuaXNEYXRlID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBmaXJzdF9kb3cgPSB0LmRheU9mV2VlaygpO1xuICAgICAgICAgIHZhciBkb3lfb2Zmc2V0ID0gdC5kYXlPZlllYXIoKSAtIDE7XG5cbiAgICAgICAgICB0LmRheSA9IGRheXNJbk1vbnRoO1xuICAgICAgICAgIHZhciBsYXN0X2RvdyA9IHQuZGF5T2ZXZWVrKCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5oYXNfYnlfZGF0YShcIkJZU0VUUE9TXCIpKSB7XG4gICAgICAgICAgICB2YXIgc2V0X3Bvc19jb3VudGVyID0gMDtcbiAgICAgICAgICAgIHZhciBieV9tb250aF9kYXkgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGRheSA9IDE7IGRheSA8PSBkYXlzSW5Nb250aDsgZGF5KyspIHtcbiAgICAgICAgICAgICAgdC5kYXkgPSBkYXk7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmlzX2RheV9pbl9ieWRheSh0KSkge1xuICAgICAgICAgICAgICAgIGJ5X21vbnRoX2RheS5wdXNoKGRheSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgc3BJbmRleCA9IDA7IHNwSW5kZXggPCBieV9tb250aF9kYXkubGVuZ3RoOyBzcEluZGV4KyspIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2tfc2V0X3Bvc2l0aW9uKHNwSW5kZXggKyAxKSB8fFxuICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja19zZXRfcG9zaXRpb24oc3BJbmRleCAtIGJ5X21vbnRoX2RheS5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXlzLnB1c2goZG95X29mZnNldCArIGJ5X21vbnRoX2RheVtzcEluZGV4XSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgZGF5Y29kZWRrZXkgaW4gdGhpcy5ieV9kYXRhLkJZREFZKSB7XG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICBpZiAoIXRoaXMuYnlfZGF0YS5CWURBWS5oYXNPd25Qcm9wZXJ0eShkYXljb2RlZGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgY29kZWRfZGF5ID0gdGhpcy5ieV9kYXRhLkJZREFZW2RheWNvZGVka2V5XTtcbiAgICAgICAgICAgICAgdmFyIGJ5ZGF5UGFydHMgPSB0aGlzLnJ1bGVEYXlPZldlZWsoY29kZWRfZGF5KTtcbiAgICAgICAgICAgICAgdmFyIHBvcyA9IGJ5ZGF5UGFydHNbMF07XG4gICAgICAgICAgICAgIHZhciBkb3cgPSBieWRheVBhcnRzWzFdO1xuICAgICAgICAgICAgICB2YXIgbW9udGhfZGF5O1xuXG4gICAgICAgICAgICAgIHZhciBmaXJzdF9tYXRjaGluZ19kYXkgPSAoKGRvdyArIDcgLSBmaXJzdF9kb3cpICUgNykgKyAxO1xuICAgICAgICAgICAgICB2YXIgbGFzdF9tYXRjaGluZ19kYXkgPSBkYXlzSW5Nb250aCAtICgobGFzdF9kb3cgKyA3IC0gZG93KSAlIDcpO1xuXG4gICAgICAgICAgICAgIGlmIChwb3MgPT0gMCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGRheSA9IGZpcnN0X21hdGNoaW5nX2RheTsgZGF5IDw9IGRheXNJbk1vbnRoOyBkYXkgKz0gNykge1xuICAgICAgICAgICAgICAgICAgdGhpcy5kYXlzLnB1c2goZG95X29mZnNldCArIGRheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBvcyA+IDApIHtcbiAgICAgICAgICAgICAgICBtb250aF9kYXkgPSBmaXJzdF9tYXRjaGluZ19kYXkgKyAocG9zIC0gMSkgKiA3O1xuXG4gICAgICAgICAgICAgICAgaWYgKG1vbnRoX2RheSA8PSBkYXlzSW5Nb250aCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5kYXlzLnB1c2goZG95X29mZnNldCArIG1vbnRoX2RheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vbnRoX2RheSA9IGxhc3RfbWF0Y2hpbmdfZGF5ICsgKHBvcyArIDEpICogNztcblxuICAgICAgICAgICAgICAgIGlmIChtb250aF9kYXkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmRheXMucHVzaChkb3lfb2Zmc2V0ICsgbW9udGhfZGF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIGRhdGVzIGluIG9yZGVyIG9mIG9jY3VycmVuY2UgKDEsMiwzLC4uLikgaW5zdGVhZFxuICAgICAgICAvLyBvZiBieSBncm91cHMgb2Ygd2Vla2RheXMgKDEsOCwxNSwuLi4sMiw5LDE2LC4uLikuXG4gICAgICAgIHRoaXMuZGF5cy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEgLSBiOyB9KTsgLy8gQ29tcGFyYXRvciBmdW5jdGlvbiBhbGxvd3MgdG8gc29ydCBudW1iZXJzLlxuICAgICAgfSBlbHNlIGlmIChwYXJ0Q291bnQgPT0gMiAmJiBcIkJZREFZXCIgaW4gcGFydHMgJiYgXCJCWU1PTlRIREFZXCIgaW4gcGFydHMpIHtcbiAgICAgICAgdmFyIGV4cGFuZGVkRGF5cyA9IHRoaXMuZXhwYW5kX2J5X2RheShhWWVhcik7XG5cbiAgICAgICAgZm9yICh2YXIgZGF5a2V5IGluIGV4cGFuZGVkRGF5cykge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmICghZXhwYW5kZWREYXlzLmhhc093blByb3BlcnR5KGRheWtleSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZGF5ID0gZXhwYW5kZWREYXlzW2RheWtleV07XG4gICAgICAgICAgdmFyIHR0ID0gSUNBTC5UaW1lLmZyb21EYXlPZlllYXIoZGF5LCBhWWVhcik7XG4gICAgICAgICAgaWYgKHRoaXMuYnlfZGF0YS5CWU1PTlRIREFZLmluZGV4T2YodHQuZGF5KSA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRheXMucHVzaChkYXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJ0Q291bnQgPT0gMyAmJlxuICAgICAgICAgICAgICAgICBcIkJZREFZXCIgaW4gcGFydHMgJiZcbiAgICAgICAgICAgICAgICAgXCJCWU1PTlRIREFZXCIgaW4gcGFydHMgJiZcbiAgICAgICAgICAgICAgICAgXCJCWU1PTlRIXCIgaW4gcGFydHMpIHtcbiAgICAgICAgdmFyIGV4cGFuZGVkRGF5cyA9IHRoaXMuZXhwYW5kX2J5X2RheShhWWVhcik7XG5cbiAgICAgICAgZm9yICh2YXIgZGF5a2V5IGluIGV4cGFuZGVkRGF5cykge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmICghZXhwYW5kZWREYXlzLmhhc093blByb3BlcnR5KGRheWtleSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZGF5ID0gZXhwYW5kZWREYXlzW2RheWtleV07XG4gICAgICAgICAgdmFyIHR0ID0gSUNBTC5UaW1lLmZyb21EYXlPZlllYXIoZGF5LCBhWWVhcik7XG5cbiAgICAgICAgICBpZiAodGhpcy5ieV9kYXRhLkJZTU9OVEguaW5kZXhPZih0dC5tb250aCkgPj0gMCAmJlxuICAgICAgICAgICAgICB0aGlzLmJ5X2RhdGEuQllNT05USERBWS5pbmRleE9mKHR0LmRheSkgPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5kYXlzLnB1c2goZGF5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFydENvdW50ID09IDIgJiYgXCJCWURBWVwiIGluIHBhcnRzICYmIFwiQllXRUVLTk9cIiBpbiBwYXJ0cykge1xuICAgICAgICB2YXIgZXhwYW5kZWREYXlzID0gdGhpcy5leHBhbmRfYnlfZGF5KGFZZWFyKTtcblxuICAgICAgICBmb3IgKHZhciBkYXlrZXkgaW4gZXhwYW5kZWREYXlzKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKCFleHBhbmRlZERheXMuaGFzT3duUHJvcGVydHkoZGF5a2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBkYXkgPSBleHBhbmRlZERheXNbZGF5a2V5XTtcbiAgICAgICAgICB2YXIgdHQgPSBJQ0FMLlRpbWUuZnJvbURheU9mWWVhcihkYXksIGFZZWFyKTtcbiAgICAgICAgICB2YXIgd2Vla25vID0gdHQud2Vla051bWJlcih0aGlzLnJ1bGUud2tzdCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5ieV9kYXRhLkJZV0VFS05PLmluZGV4T2Yod2Vla25vKSkge1xuICAgICAgICAgICAgdGhpcy5kYXlzLnB1c2goZGF5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFydENvdW50ID09IDMgJiZcbiAgICAgICAgICAgICAgICAgXCJCWURBWVwiIGluIHBhcnRzICYmXG4gICAgICAgICAgICAgICAgIFwiQllXRUVLTk9cIiBpbiBwYXJ0cyAmJlxuICAgICAgICAgICAgICAgICBcIkJZTU9OVEhEQVlcIiBpbiBwYXJ0cykge1xuICAgICAgICAvLyBUT0RPIHVuaW1wbGVtdGVkIGluIGxpYmljYWxcbiAgICAgIH0gZWxzZSBpZiAocGFydENvdW50ID09IDEgJiYgXCJCWVlFQVJEQVlcIiBpbiBwYXJ0cykge1xuICAgICAgICB0aGlzLmRheXMgPSB0aGlzLmRheXMuY29uY2F0KHRoaXMuYnlfZGF0YS5CWVlFQVJEQVkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kYXlzID0gW107XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgZXhwYW5kX2J5X2RheTogZnVuY3Rpb24gZXhwYW5kX2J5X2RheShhWWVhcikge1xuXG4gICAgICB2YXIgZGF5c19saXN0ID0gW107XG4gICAgICB2YXIgdG1wID0gdGhpcy5sYXN0LmNsb25lKCk7XG5cbiAgICAgIHRtcC55ZWFyID0gYVllYXI7XG4gICAgICB0bXAubW9udGggPSAxO1xuICAgICAgdG1wLmRheSA9IDE7XG4gICAgICB0bXAuaXNEYXRlID0gdHJ1ZTtcblxuICAgICAgdmFyIHN0YXJ0X2RvdyA9IHRtcC5kYXlPZldlZWsoKTtcblxuICAgICAgdG1wLm1vbnRoID0gMTI7XG4gICAgICB0bXAuZGF5ID0gMzE7XG4gICAgICB0bXAuaXNEYXRlID0gdHJ1ZTtcblxuICAgICAgdmFyIGVuZF9kb3cgPSB0bXAuZGF5T2ZXZWVrKCk7XG4gICAgICB2YXIgZW5kX3llYXJfZGF5ID0gdG1wLmRheU9mWWVhcigpO1xuXG4gICAgICBmb3IgKHZhciBkYXlrZXkgaW4gdGhpcy5ieV9kYXRhLkJZREFZKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIXRoaXMuYnlfZGF0YS5CWURBWS5oYXNPd25Qcm9wZXJ0eShkYXlrZXkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRheSA9IHRoaXMuYnlfZGF0YS5CWURBWVtkYXlrZXldO1xuICAgICAgICB2YXIgcGFydHMgPSB0aGlzLnJ1bGVEYXlPZldlZWsoZGF5KTtcbiAgICAgICAgdmFyIHBvcyA9IHBhcnRzWzBdO1xuICAgICAgICB2YXIgZG93ID0gcGFydHNbMV07XG5cbiAgICAgICAgaWYgKHBvcyA9PSAwKSB7XG4gICAgICAgICAgdmFyIHRtcF9zdGFydF9kb3kgPSAoKGRvdyArIDcgLSBzdGFydF9kb3cpICUgNykgKyAxO1xuXG4gICAgICAgICAgZm9yICh2YXIgZG95ID0gdG1wX3N0YXJ0X2RveTsgZG95IDw9IGVuZF95ZWFyX2RheTsgZG95ICs9IDcpIHtcbiAgICAgICAgICAgIGRheXNfbGlzdC5wdXNoKGRveSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAocG9zID4gMCkge1xuICAgICAgICAgIHZhciBmaXJzdDtcbiAgICAgICAgICBpZiAoZG93ID49IHN0YXJ0X2Rvdykge1xuICAgICAgICAgICAgZmlyc3QgPSBkb3cgLSBzdGFydF9kb3cgKyAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmaXJzdCA9IGRvdyAtIHN0YXJ0X2RvdyArIDg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGF5c19saXN0LnB1c2goZmlyc3QgKyAocG9zIC0gMSkgKiA3KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbGFzdDtcbiAgICAgICAgICBwb3MgPSAtcG9zO1xuXG4gICAgICAgICAgaWYgKGRvdyA8PSBlbmRfZG93KSB7XG4gICAgICAgICAgICBsYXN0ID0gZW5kX3llYXJfZGF5IC0gZW5kX2RvdyArIGRvdztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFzdCA9IGVuZF95ZWFyX2RheSAtIGVuZF9kb3cgKyBkb3cgLSA3O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRheXNfbGlzdC5wdXNoKGxhc3QgLSAocG9zIC0gMSkgKiA3KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRheXNfbGlzdDtcbiAgICB9LFxuXG4gICAgaXNfZGF5X2luX2J5ZGF5OiBmdW5jdGlvbiBpc19kYXlfaW5fYnlkYXkodHQpIHtcbiAgICAgIGZvciAodmFyIGRheWtleSBpbiB0aGlzLmJ5X2RhdGEuQllEQVkpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghdGhpcy5ieV9kYXRhLkJZREFZLmhhc093blByb3BlcnR5KGRheWtleSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF5ID0gdGhpcy5ieV9kYXRhLkJZREFZW2RheWtleV07XG4gICAgICAgIHZhciBwYXJ0cyA9IHRoaXMucnVsZURheU9mV2VlayhkYXkpO1xuICAgICAgICB2YXIgcG9zID0gcGFydHNbMF07XG4gICAgICAgIHZhciBkb3cgPSBwYXJ0c1sxXTtcbiAgICAgICAgdmFyIHRoaXNfZG93ID0gdHQuZGF5T2ZXZWVrKCk7XG5cbiAgICAgICAgaWYgKChwb3MgPT0gMCAmJiBkb3cgPT0gdGhpc19kb3cpIHx8XG4gICAgICAgICAgICAodHQubnRoV2Vla0RheShkb3csIHBvcykgPT0gdHQuZGF5KSkge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgZ2l2ZW4gdmFsdWUgaXMgaW4gQllTRVRQT1MuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtZXJpY30gYVBvcyBwb3NpdGlvbiB0byBjaGVjayBmb3IuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gZmFsc2UgdW5sZXNzIEJZU0VUUE9TIHJ1bGVzIGV4aXN0XG4gICAgICogICAgICAgICAgICAgICAgICAgYW5kIHRoZSBnaXZlbiB2YWx1ZSBpcyBwcmVzZW50IGluIHJ1bGVzLlxuICAgICAqL1xuICAgIGNoZWNrX3NldF9wb3NpdGlvbjogZnVuY3Rpb24gY2hlY2tfc2V0X3Bvc2l0aW9uKGFQb3MpIHtcbiAgICAgIGlmICh0aGlzLmhhc19ieV9kYXRhKCdCWVNFVFBPUycpKSB7XG4gICAgICAgIHZhciBpZHggPSB0aGlzLmJ5X2RhdGEuQllTRVRQT1MuaW5kZXhPZihhUG9zKTtcbiAgICAgICAgLy8gbmVnYXRpdmUgbnVtYmVycyBhcmUgbm90IGZhbHNlLXlcbiAgICAgICAgcmV0dXJuIGlkeCAhPT0gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIHNvcnRfYnlkYXlfcnVsZXM6IGZ1bmN0aW9uIGljYWxyZWN1cl9zb3J0X2J5ZGF5X3J1bGVzKGFSdWxlcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhUnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpOyBqKyspIHtcbiAgICAgICAgICB2YXIgb25lID0gdGhpcy5ydWxlRGF5T2ZXZWVrKGFSdWxlc1tqXSwgdGhpcy5ydWxlLndrc3QpWzFdO1xuICAgICAgICAgIHZhciB0d28gPSB0aGlzLnJ1bGVEYXlPZldlZWsoYVJ1bGVzW2ldLCB0aGlzLnJ1bGUud2tzdClbMV07XG5cbiAgICAgICAgICBpZiAob25lID4gdHdvKSB7XG4gICAgICAgICAgICB2YXIgdG1wID0gYVJ1bGVzW2ldO1xuICAgICAgICAgICAgYVJ1bGVzW2ldID0gYVJ1bGVzW2pdO1xuICAgICAgICAgICAgYVJ1bGVzW2pdID0gdG1wO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBjaGVja19jb250cmFjdF9yZXN0cmljdGlvbjogZnVuY3Rpb24gY2hlY2tfY29udHJhY3RfcmVzdHJpY3Rpb24oYVJ1bGVUeXBlLCB2KSB7XG4gICAgICB2YXIgaW5kZXhNYXBWYWx1ZSA9IGljYWxyZWN1cl9pdGVyYXRvci5faW5kZXhNYXBbYVJ1bGVUeXBlXTtcbiAgICAgIHZhciBydWxlTWFwVmFsdWUgPSBpY2FscmVjdXJfaXRlcmF0b3IuX2V4cGFuZE1hcFt0aGlzLnJ1bGUuZnJlcV1baW5kZXhNYXBWYWx1ZV07XG4gICAgICB2YXIgcGFzcyA9IGZhbHNlO1xuXG4gICAgICBpZiAoYVJ1bGVUeXBlIGluIHRoaXMuYnlfZGF0YSAmJlxuICAgICAgICAgIHJ1bGVNYXBWYWx1ZSA9PSBpY2FscmVjdXJfaXRlcmF0b3IuQ09OVFJBQ1QpIHtcblxuICAgICAgICB2YXIgcnVsZVR5cGUgPSB0aGlzLmJ5X2RhdGFbYVJ1bGVUeXBlXTtcblxuICAgICAgICBmb3IgKHZhciBieWRhdGFrZXkgaW4gcnVsZVR5cGUpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgIGlmIChydWxlVHlwZS5oYXNPd25Qcm9wZXJ0eShieWRhdGFrZXkpKSB7XG4gICAgICAgICAgICBpZiAocnVsZVR5cGVbYnlkYXRha2V5XSA9PSB2KSB7XG4gICAgICAgICAgICAgIHBhc3MgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vdCBhIGNvbnRyYWN0aW5nIGJ5cnVsZSBvciBoYXMgbm8gZGF0YSwgdGVzdCBwYXNzZXNcbiAgICAgICAgcGFzcyA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFzcztcbiAgICB9LFxuXG4gICAgY2hlY2tfY29udHJhY3RpbmdfcnVsZXM6IGZ1bmN0aW9uIGNoZWNrX2NvbnRyYWN0aW5nX3J1bGVzKCkge1xuICAgICAgdmFyIGRvdyA9IHRoaXMubGFzdC5kYXlPZldlZWsoKTtcbiAgICAgIHZhciB3ZWVrTm8gPSB0aGlzLmxhc3Qud2Vla051bWJlcih0aGlzLnJ1bGUud2tzdCk7XG4gICAgICB2YXIgZG95ID0gdGhpcy5sYXN0LmRheU9mWWVhcigpO1xuXG4gICAgICByZXR1cm4gKHRoaXMuY2hlY2tfY29udHJhY3RfcmVzdHJpY3Rpb24oXCJCWVNFQ09ORFwiLCB0aGlzLmxhc3Quc2Vjb25kKSAmJlxuICAgICAgICAgICAgICB0aGlzLmNoZWNrX2NvbnRyYWN0X3Jlc3RyaWN0aW9uKFwiQllNSU5VVEVcIiwgdGhpcy5sYXN0Lm1pbnV0ZSkgJiZcbiAgICAgICAgICAgICAgdGhpcy5jaGVja19jb250cmFjdF9yZXN0cmljdGlvbihcIkJZSE9VUlwiLCB0aGlzLmxhc3QuaG91cikgJiZcbiAgICAgICAgICAgICAgdGhpcy5jaGVja19jb250cmFjdF9yZXN0cmljdGlvbihcIkJZREFZXCIsIElDQUwuUmVjdXIubnVtZXJpY0RheVRvSWNhbERheShkb3cpKSAmJlxuICAgICAgICAgICAgICB0aGlzLmNoZWNrX2NvbnRyYWN0X3Jlc3RyaWN0aW9uKFwiQllXRUVLTk9cIiwgd2Vla05vKSAmJlxuICAgICAgICAgICAgICB0aGlzLmNoZWNrX2NvbnRyYWN0X3Jlc3RyaWN0aW9uKFwiQllNT05USERBWVwiLCB0aGlzLmxhc3QuZGF5KSAmJlxuICAgICAgICAgICAgICB0aGlzLmNoZWNrX2NvbnRyYWN0X3Jlc3RyaWN0aW9uKFwiQllNT05USFwiLCB0aGlzLmxhc3QubW9udGgpICYmXG4gICAgICAgICAgICAgIHRoaXMuY2hlY2tfY29udHJhY3RfcmVzdHJpY3Rpb24oXCJCWVlFQVJEQVlcIiwgZG95KSk7XG4gICAgfSxcblxuICAgIHNldHVwX2RlZmF1bHRzOiBmdW5jdGlvbiBzZXR1cF9kZWZhdWx0cyhhUnVsZVR5cGUsIHJlcSwgZGVmdGltZSkge1xuICAgICAgdmFyIGluZGV4TWFwVmFsdWUgPSBpY2FscmVjdXJfaXRlcmF0b3IuX2luZGV4TWFwW2FSdWxlVHlwZV07XG4gICAgICB2YXIgcnVsZU1hcFZhbHVlID0gaWNhbHJlY3VyX2l0ZXJhdG9yLl9leHBhbmRNYXBbdGhpcy5ydWxlLmZyZXFdW2luZGV4TWFwVmFsdWVdO1xuXG4gICAgICBpZiAocnVsZU1hcFZhbHVlICE9IGljYWxyZWN1cl9pdGVyYXRvci5DT05UUkFDVCkge1xuICAgICAgICBpZiAoIShhUnVsZVR5cGUgaW4gdGhpcy5ieV9kYXRhKSkge1xuICAgICAgICAgIHRoaXMuYnlfZGF0YVthUnVsZVR5cGVdID0gW2RlZnRpbWVdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJ1bGUuZnJlcSAhPSByZXEpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5ieV9kYXRhW2FSdWxlVHlwZV1bMF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWZ0aW1lO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGl0ZXJhdG9yIGludG8gYSBzZXJpYWxpemUtYWJsZSBvYmplY3QuICBXaWxsIHByZXNlcnZlIGN1cnJlbnRcbiAgICAgKiBpdGVyYXRpb24gc2VxdWVuY2UgdG8gZW5zdXJlIHRoZSBzZWFtbGVzcyBjb250aW51YXRpb24gb2YgdGhlIHJlY3VycmVuY2VcbiAgICAgKiBydWxlLlxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT046IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgIHJlc3VsdC5pbml0aWFsaXplZCA9IHRoaXMuaW5pdGlhbGl6ZWQ7XG4gICAgICByZXN1bHQucnVsZSA9IHRoaXMucnVsZS50b0pTT04oKTtcbiAgICAgIHJlc3VsdC5kdHN0YXJ0ID0gdGhpcy5kdHN0YXJ0LnRvSlNPTigpO1xuICAgICAgcmVzdWx0LmJ5X2RhdGEgPSB0aGlzLmJ5X2RhdGE7XG4gICAgICByZXN1bHQuZGF5cyA9IHRoaXMuZGF5cztcbiAgICAgIHJlc3VsdC5sYXN0ID0gdGhpcy5sYXN0LnRvSlNPTigpO1xuICAgICAgcmVzdWx0LmJ5X2luZGljZXMgPSB0aGlzLmJ5X2luZGljZXM7XG4gICAgICByZXN1bHQub2NjdXJyZW5jZV9udW1iZXIgPSB0aGlzLm9jY3VycmVuY2VfbnVtYmVyO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfTtcblxuICBpY2FscmVjdXJfaXRlcmF0b3IuX2luZGV4TWFwID0ge1xuICAgIFwiQllTRUNPTkRcIjogMCxcbiAgICBcIkJZTUlOVVRFXCI6IDEsXG4gICAgXCJCWUhPVVJcIjogMixcbiAgICBcIkJZREFZXCI6IDMsXG4gICAgXCJCWU1PTlRIREFZXCI6IDQsXG4gICAgXCJCWVlFQVJEQVlcIjogNSxcbiAgICBcIkJZV0VFS05PXCI6IDYsXG4gICAgXCJCWU1PTlRIXCI6IDcsXG4gICAgXCJCWVNFVFBPU1wiOiA4XG4gIH07XG5cbiAgaWNhbHJlY3VyX2l0ZXJhdG9yLl9leHBhbmRNYXAgPSB7XG4gICAgXCJTRUNPTkRMWVwiOiBbMSwgMSwgMSwgMSwgMSwgMSwgMSwgMV0sXG4gICAgXCJNSU5VVEVMWVwiOiBbMiwgMSwgMSwgMSwgMSwgMSwgMSwgMV0sXG4gICAgXCJIT1VSTFlcIjogWzIsIDIsIDEsIDEsIDEsIDEsIDEsIDFdLFxuICAgIFwiREFJTFlcIjogWzIsIDIsIDIsIDEsIDEsIDEsIDEsIDFdLFxuICAgIFwiV0VFS0xZXCI6IFsyLCAyLCAyLCAyLCAzLCAzLCAxLCAxXSxcbiAgICBcIk1PTlRITFlcIjogWzIsIDIsIDIsIDIsIDIsIDMsIDMsIDFdLFxuICAgIFwiWUVBUkxZXCI6IFsyLCAyLCAyLCAyLCAyLCAyLCAyLCAyXVxuICB9O1xuICBpY2FscmVjdXJfaXRlcmF0b3IuVU5LTk9XTiA9IDA7XG4gIGljYWxyZWN1cl9pdGVyYXRvci5DT05UUkFDVCA9IDE7XG4gIGljYWxyZWN1cl9pdGVyYXRvci5FWFBBTkQgPSAyO1xuICBpY2FscmVjdXJfaXRlcmF0b3IuSUxMRUdBTCA9IDM7XG5cbiAgcmV0dXJuIGljYWxyZWN1cl9pdGVyYXRvcjtcblxufSgpKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAxMS0yMDE1ICovXG5cblxuLyoqXG4gKiBUaGlzIHN5bWJvbCBpcyBmdXJ0aGVyIGRlc2NyaWJlZCBsYXRlciBvblxuICogQGlnbm9yZVxuICovXG5JQ0FMLlJlY3VyRXhwYW5zaW9uID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBmb3JtYXRUaW1lKGl0ZW0pIHtcbiAgICByZXR1cm4gSUNBTC5oZWxwZXJzLmZvcm1hdENsYXNzVHlwZShpdGVtLCBJQ0FMLlRpbWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcGFyZVRpbWUoYSwgYikge1xuICAgIHJldHVybiBhLmNvbXBhcmUoYik7XG4gIH1cblxuICBmdW5jdGlvbiBpc1JlY3VycmluZ0NvbXBvbmVudChjb21wKSB7XG4gICAgcmV0dXJuIGNvbXAuaGFzUHJvcGVydHkoJ3JkYXRlJykgfHxcbiAgICAgICAgICAgY29tcC5oYXNQcm9wZXJ0eSgncnJ1bGUnKSB8fFxuICAgICAgICAgICBjb21wLmhhc1Byb3BlcnR5KCdyZWN1cnJlbmNlLWlkJyk7XG4gIH1cblxuICAvKipcbiAgICogQGNsYXNzZGVzY1xuICAgKiBQcmltYXJ5IGNsYXNzIGZvciBleHBhbmRpbmcgcmVjdXJyaW5nIHJ1bGVzLiAgQ2FuIHRha2UgbXVsdGlwbGUgcnJ1bGVzLFxuICAgKiByZGF0ZXMsIGV4ZGF0ZShzKSBhbmQgaXRlcmF0ZSAoaW4gb3JkZXIpIG92ZXIgZWFjaCBuZXh0IG9jY3VycmVuY2UuXG4gICAqXG4gICAqIE9uY2UgaW5pdGlhbGl6ZWQgdGhpcyBjbGFzcyBjYW4gYWxzbyBiZSBzZXJpYWxpemVkIHNhdmVkIGFuZCBjb250aW51ZVxuICAgKiBpdGVyYXRpb24gZnJvbSB0aGUgbGFzdCBwb2ludC5cbiAgICpcbiAgICogTk9URTogaXQgaXMgaW50ZW5kZWQgdGhhdCB0aGlzIGNsYXNzIGlzIHRvIGJlIHVzZWRcbiAgICogICAgICAgd2l0aCBJQ0FMLkV2ZW50IHdoaWNoIGhhbmRsZXMgcmVjdXJyZW5jZSBleGNlcHRpb25zLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBhc3N1bWluZyBldmVudCBpcyBhIHBhcnNlZCBpY2FsIGNvbXBvbmVudFxuICAgKiB2YXIgZXZlbnQ7XG4gICAqXG4gICAqIHZhciBleHBhbmQgPSBuZXcgSUNBTC5SZWN1ckV4cGFuc2lvbih7XG4gICAqICAgY29tcG9uZW50OiBldmVudCxcbiAgICogICBkdHN0YXJ0OiBldmVudC5nZXRGaXJzdFByb3BlcnR5VmFsdWUoJ2R0c3RhcnQnKVxuICAgKiB9KTtcbiAgICpcbiAgICogLy8gcmVtZW1iZXIgdGhlcmUgYXJlIGluZmluaXRlIHJ1bGVzXG4gICAqIC8vIHNvIGl0IGlzIGEgZ29vZCBpZGVhIHRvIGxpbWl0IHRoZSBzY29wZVxuICAgKiAvLyBvZiB0aGUgaXRlcmF0aW9ucyB0aGVuIHJlc3VtZSBsYXRlciBvbi5cbiAgICpcbiAgICogLy8gbmV4dCBpcyBhbHdheXMgYW4gSUNBTC5UaW1lIG9yIG51bGxcbiAgICogdmFyIG5leHQ7XG4gICAqXG4gICAqIHdoaWxlIChzb21lQ29uZGl0aW9uICYmIChuZXh0ID0gZXhwYW5kLm5leHQoKSkpIHtcbiAgICogICAvLyBkbyBzb21ldGhpbmcgd2l0aCBuZXh0XG4gICAqIH1cbiAgICpcbiAgICogLy8gc2F2ZSBpbnN0YW5jZSBmb3IgbGF0ZXJcbiAgICogdmFyIGpzb24gPSBKU09OLnN0cmluZ2lmeShleHBhbmQpO1xuICAgKlxuICAgKiAvLy4uLlxuICAgKlxuICAgKiAvLyBOT1RFOiBpZiB0aGUgY29tcG9uZW50J3MgcHJvcGVydGllcyBoYXZlXG4gICAqIC8vICAgICAgIGNoYW5nZWQgeW91IHdpbGwgbmVlZCB0byByZWJ1aWxkIHRoZVxuICAgKiAvLyAgICAgICBjbGFzcyBhbmQgc3RhcnQgb3Zlci4gVGhpcyBvbmx5IHdvcmtzXG4gICAqIC8vICAgICAgIHdoZW4gdGhlIGNvbXBvbmVudCdzIHJlY3VycmVuY2UgaW5mbyBpcyB0aGUgc2FtZS5cbiAgICogdmFyIGV4cGFuZCA9IG5ldyBJQ0FMLlJlY3VyRXhwYW5zaW9uKEpTT04ucGFyc2UoanNvbikpO1xuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogVGhlIG9wdGlvbnMgb2JqZWN0IGNhbiBiZSBmaWxsZWQgd2l0aCB0aGUgc3BlY2lmaWVkIGluaXRpYWwgdmFsdWVzLiBJdCBjYW5cbiAgICogYWxzbyBjb250YWluIGFkZGl0aW9uYWwgbWVtYmVycywgYXMgYSByZXN1bHQgb2Ygc2VyaWFsaXppbmcgYSBwcmV2aW91c1xuICAgKiBleHBhbnNpb24gc3RhdGUsIGFzIHNob3duIGluIHRoZSBleGFtcGxlLlxuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQGFsaWFzIElDQUwuUmVjdXJFeHBhbnNpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogICAgICAgIFJlY3VycmVuY2UgZXhwYW5zaW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtJQ0FMLlRpbWV9IG9wdGlvbnMuZHRzdGFydFxuICAgKiAgICAgICAgU3RhcnQgdGltZSBvZiB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtJQ0FMLkNvbXBvbmVudD19IG9wdGlvbnMuY29tcG9uZW50XG4gICAqICAgICAgICBDb21wb25lbnQgZm9yIGV4cGFuc2lvbiwgcmVxdWlyZWQgaWYgbm90IHJlc3VtaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gUmVjdXJFeHBhbnNpb24ob3B0aW9ucykge1xuICAgIHRoaXMucnVsZURhdGVzID0gW107XG4gICAgdGhpcy5leERhdGVzID0gW107XG4gICAgdGhpcy5mcm9tRGF0YShvcHRpb25zKTtcbiAgfVxuXG4gIFJlY3VyRXhwYW5zaW9uLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBUcnVlIHdoZW4gaXRlcmF0aW9uIGlzIGZ1bGx5IGNvbXBsZXRlZC5cbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBjb21wbGV0ZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBvZiBycnVsZSBpdGVyYXRvcnMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7SUNBTC5SZWN1ckl0ZXJhdG9yW119XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBydWxlSXRlcmF0b3JzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQXJyYXkgb2YgcmRhdGUgaW5zdGFuY2VzLlxuICAgICAqXG4gICAgICogQHR5cGUge0lDQUwuVGltZVtdfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcnVsZURhdGVzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQXJyYXkgb2YgZXhkYXRlIGluc3RhbmNlcy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtJQ0FMLlRpbWVbXX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGV4RGF0ZXM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHBvc2l0aW9uIGluIHJ1bGVEYXRlcyBhcnJheS5cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcnVsZURhdGVJbmM6IDAsXG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHBvc2l0aW9uIGluIGV4RGF0ZXMgYXJyYXlcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZXhEYXRlSW5jOiAwLFxuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBuZWdhdGl2ZSBkYXRlLlxuICAgICAqXG4gICAgICogQHR5cGUge0lDQUwuVGltZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGV4RGF0ZTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgYWRkaXRpb25hbCBkYXRlLlxuICAgICAqXG4gICAgICogQHR5cGUge0lDQUwuVGltZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHJ1bGVEYXRlOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogU3RhcnQgZGF0ZSBvZiByZWN1cnJpbmcgcnVsZXMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7SUNBTC5UaW1lfVxuICAgICAqL1xuICAgIGR0c3RhcnQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBMYXN0IGV4cGFuZGVkIHRpbWVcbiAgICAgKlxuICAgICAqIEB0eXBlIHtJQ0FMLlRpbWV9XG4gICAgICovXG4gICAgbGFzdDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGhlIHJlY3VycmVuY2UgZXhwYW5zaW9uIGZyb20gdGhlIGRhdGEgb2JqZWN0LiBUaGUgb3B0aW9uc1xuICAgICAqIG9iamVjdCBtYXkgYWxzbyBjb250YWluIGFkZGl0aW9uYWwgbWVtYmVycywgc2VlIHRoZVxuICAgICAqIHtAbGluayBJQ0FMLlJlY3VyRXhwYW5zaW9uIGNvbnN0cnVjdG9yfSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiAgICAgICAgUmVjdXJyZW5jZSBleHBhbnNpb24gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7SUNBTC5UaW1lfSBvcHRpb25zLmR0c3RhcnRcbiAgICAgKiAgICAgICAgU3RhcnQgdGltZSBvZiB0aGUgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0lDQUwuQ29tcG9uZW50PX0gb3B0aW9ucy5jb21wb25lbnRcbiAgICAgKiAgICAgICAgQ29tcG9uZW50IGZvciBleHBhbnNpb24sIHJlcXVpcmVkIGlmIG5vdCByZXN1bWluZy5cbiAgICAgKi9cbiAgICBmcm9tRGF0YTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIHN0YXJ0ID0gSUNBTC5oZWxwZXJzLmZvcm1hdENsYXNzVHlwZShvcHRpb25zLmR0c3RhcnQsIElDQUwuVGltZSk7XG5cbiAgICAgIGlmICghc3RhcnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCcuZHRzdGFydCAoSUNBTC5UaW1lKSBtdXN0IGJlIGdpdmVuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmR0c3RhcnQgPSBzdGFydDtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuY29tcG9uZW50KSB7XG4gICAgICAgIHRoaXMuX2luaXQob3B0aW9ucy5jb21wb25lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sYXN0ID0gZm9ybWF0VGltZShvcHRpb25zLmxhc3QpIHx8IHN0YXJ0LmNsb25lKCk7XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLnJ1bGVJdGVyYXRvcnMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJy5ydWxlSXRlcmF0b3JzIG9yIC5jb21wb25lbnQgbXVzdCBiZSBnaXZlbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ydWxlSXRlcmF0b3JzID0gb3B0aW9ucy5ydWxlSXRlcmF0b3JzLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgcmV0dXJuIElDQUwuaGVscGVycy5mb3JtYXRDbGFzc1R5cGUoaXRlbSwgSUNBTC5SZWN1ckl0ZXJhdG9yKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5ydWxlRGF0ZUluYyA9IG9wdGlvbnMucnVsZURhdGVJbmM7XG4gICAgICAgIHRoaXMuZXhEYXRlSW5jID0gb3B0aW9ucy5leERhdGVJbmM7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMucnVsZURhdGVzKSB7XG4gICAgICAgICAgdGhpcy5ydWxlRGF0ZXMgPSBvcHRpb25zLnJ1bGVEYXRlcy5tYXAoZm9ybWF0VGltZSk7XG4gICAgICAgICAgdGhpcy5ydWxlRGF0ZSA9IHRoaXMucnVsZURhdGVzW3RoaXMucnVsZURhdGVJbmNdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZXhEYXRlcykge1xuICAgICAgICAgIHRoaXMuZXhEYXRlcyA9IG9wdGlvbnMuZXhEYXRlcy5tYXAoZm9ybWF0VGltZSk7XG4gICAgICAgICAgdGhpcy5leERhdGUgPSB0aGlzLmV4RGF0ZXNbdGhpcy5leERhdGVJbmNdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZihvcHRpb25zLmNvbXBsZXRlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlID0gb3B0aW9ucy5jb21wbGV0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgbmV4dCBvY2N1cnJlbmNlIGluIHRoZSBzZXJpZXMuXG4gICAgICogQHJldHVybiB7SUNBTC5UaW1lfVxuICAgICAqL1xuICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGl0ZXI7XG4gICAgICB2YXIgcnVsZU9mRGF5O1xuICAgICAgdmFyIG5leHQ7XG4gICAgICB2YXIgY29tcGFyZTtcblxuICAgICAgdmFyIG1heFRyaWVzID0gNTAwO1xuICAgICAgdmFyIGN1cnJlbnRUcnkgPSAwO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAoY3VycmVudFRyeSsrID4gbWF4VHJpZXMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnbWF4IHRyaWVzIGhhdmUgb2NjdXJlZCwgcnVsZSBtYXkgYmUgaW1wb3NzaWJsZSB0byBmb3JmaWxsLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV4dCA9IHRoaXMucnVsZURhdGU7XG4gICAgICAgIGl0ZXIgPSB0aGlzLl9uZXh0UmVjdXJyZW5jZUl0ZXIodGhpcy5sYXN0KTtcblxuICAgICAgICAvLyBubyBtb3JlIG1hdGNoZXNcbiAgICAgICAgLy8gYmVjYXVzZSB3ZSBpbmNyZW1lbnQgdGhlIHJ1bGUgZGF5IG9yIHJ1bGVcbiAgICAgICAgLy8gX2FmdGVyXyB3ZSBjaG9vc2UgYSB2YWx1ZSB0aGlzIHNob3VsZCBiZVxuICAgICAgICAvLyB0aGUgb25seSBzcG90IHdoZXJlIHdlIG5lZWQgdG8gd29ycnkgYWJvdXQgdGhlXG4gICAgICAgIC8vIGVuZCBvZiBldmVudHMuXG4gICAgICAgIGlmICghbmV4dCAmJiAhaXRlcikge1xuICAgICAgICAgIC8vIHRoZXJlIGFyZSBubyBtb3JlIGl0ZXJhdG9ycyBvciByZGF0ZXNcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vIG5leHQgcnVsZSBkYXkgb3IgcmVjdXJyZW5jZSBydWxlIGlzIGZpcnN0LlxuICAgICAgICBpZiAoIW5leHQgfHwgKGl0ZXIgJiYgbmV4dC5jb21wYXJlKGl0ZXIubGFzdCkgPiAwKSkge1xuICAgICAgICAgIC8vIG11c3QgYmUgY2xvbmVkLCByZWN1ciB3aWxsIHJldXNlIHRoZSB0aW1lIGVsZW1lbnQuXG4gICAgICAgICAgbmV4dCA9IGl0ZXIubGFzdC5jbG9uZSgpO1xuICAgICAgICAgIC8vIG1vdmUgdG8gbmV4dCBzbyB3ZSBjYW4gY29udGludWVcbiAgICAgICAgICBpdGVyLm5leHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZSBydWxlRGF0ZSBpcyBzdGlsbCBuZXh0IGluY3JlbWVudCBpdC5cbiAgICAgICAgaWYgKHRoaXMucnVsZURhdGUgPT09IG5leHQpIHtcbiAgICAgICAgICB0aGlzLl9uZXh0UnVsZURheSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sYXN0ID0gbmV4dDtcblxuICAgICAgICAvLyBjaGVjayB0aGUgbmVnYXRpdmUgcnVsZXNcbiAgICAgICAgaWYgKHRoaXMuZXhEYXRlKSB7XG4gICAgICAgICAgY29tcGFyZSA9IHRoaXMuZXhEYXRlLmNvbXBhcmUodGhpcy5sYXN0KTtcblxuICAgICAgICAgIGlmIChjb21wYXJlIDwgMCkge1xuICAgICAgICAgICAgdGhpcy5fbmV4dEV4RGF5KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaWYgdGhlIGN1cnJlbnQgcnVsZSBpcyBleGNsdWRlZCBza2lwIGl0LlxuICAgICAgICAgIGlmIChjb21wYXJlID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9uZXh0RXhEYXkoKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vWFhYOiBUaGUgc3BlYyBzdGF0ZXMgdGhhdCBhZnRlciB3ZSByZXNvbHZlIHRoZSBmaW5hbFxuICAgICAgICAvLyAgICAgbGlzdCBvZiBkYXRlcyB3ZSBleGVjdXRlIGV4ZGF0ZSB0aGlzIHNlZW1zIHNvbWV3aGF0IGNvdW50ZXJcbiAgICAgICAgLy8gICAgIGludHVpdGl2ZSB0byB3aGF0IEkgaGF2ZSBzZWVuIG1vc3Qgc2VydmVycyBkbyBzbyBmb3Igbm93XG4gICAgICAgIC8vICAgICBJIGV4Y2x1ZGUgYmFzZWQgb24gdGhlIG9yaWdpbmFsIGRhdGUgbm90IHRoZSBvbmUgdGhhdCBtYXlcbiAgICAgICAgLy8gICAgIGhhdmUgYmVlbiBtb2RpZmllZCBieSB0aGUgZXhjZXB0aW9uLlxuICAgICAgICByZXR1cm4gdGhpcy5sYXN0O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBvYmplY3QgaW50byBhIHNlcmlhbGl6ZS1hYmxlIGZvcm1hdC4gVGhpcyBmb3JtYXQgY2FuIGJlIHBhc3NlZFxuICAgICAqIGJhY2sgaW50byB0aGUgZXhwYW5zaW9uIHRvIHJlc3VtZSBpdGVyYXRpb24uXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgICBmdW5jdGlvbiB0b0pTT04oaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbS50b0pTT04oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICByZXN1bHQucnVsZUl0ZXJhdG9ycyA9IHRoaXMucnVsZUl0ZXJhdG9ycy5tYXAodG9KU09OKTtcblxuICAgICAgaWYgKHRoaXMucnVsZURhdGVzKSB7XG4gICAgICAgIHJlc3VsdC5ydWxlRGF0ZXMgPSB0aGlzLnJ1bGVEYXRlcy5tYXAodG9KU09OKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZXhEYXRlcykge1xuICAgICAgICByZXN1bHQuZXhEYXRlcyA9IHRoaXMuZXhEYXRlcy5tYXAodG9KU09OKTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0LnJ1bGVEYXRlSW5jID0gdGhpcy5ydWxlRGF0ZUluYztcbiAgICAgIHJlc3VsdC5leERhdGVJbmMgPSB0aGlzLmV4RGF0ZUluYztcbiAgICAgIHJlc3VsdC5sYXN0ID0gdGhpcy5sYXN0LnRvSlNPTigpO1xuICAgICAgcmVzdWx0LmR0c3RhcnQgPSB0aGlzLmR0c3RhcnQudG9KU09OKCk7XG4gICAgICByZXN1bHQuY29tcGxldGUgPSB0aGlzLmNvbXBsZXRlO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0IGFsbCBkYXRlcyBmcm9tIHRoZSBwcm9wZXJ0aWVzIGluIHRoZSBnaXZlbiBjb21wb25lbnQuIFRoZVxuICAgICAqIHByb3BlcnRpZXMgd2lsbCBiZSBmaWx0ZXJlZCBieSB0aGUgcHJvcGVydHkgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtJQ0FMLkNvbXBvbmVudH0gY29tcG9uZW50ICAgICAgICBUaGUgY29tcG9uZW50IHRvIHNlYXJjaCBpblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eU5hbWUgICAgICAgICAgICAgVGhlIHByb3BlcnR5IG5hbWUgdG8gc2VhcmNoIGZvclxuICAgICAqIEByZXR1cm4ge0lDQUwuVGltZVtdfSAgICAgICAgICAgICAgICAgICAgVGhlIGV4dHJhY3RlZCBkYXRlcy5cbiAgICAgKi9cbiAgICBfZXh0cmFjdERhdGVzOiBmdW5jdGlvbihjb21wb25lbnQsIHByb3BlcnR5TmFtZSkge1xuICAgICAgZnVuY3Rpb24gaGFuZGxlUHJvcChwcm9wKSB7XG4gICAgICAgIGlkeCA9IElDQUwuaGVscGVycy5iaW5zZWFyY2hJbnNlcnQoXG4gICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgIHByb3AsXG4gICAgICAgICAgY29tcGFyZVRpbWVcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBvcmRlcmVkIGluc2VydFxuICAgICAgICByZXN1bHQuc3BsaWNlKGlkeCwgMCwgcHJvcCk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHZhciBwcm9wcyA9IGNvbXBvbmVudC5nZXRBbGxQcm9wZXJ0aWVzKHByb3BlcnR5TmFtZSk7XG4gICAgICB2YXIgbGVuID0gcHJvcHMubGVuZ3RoO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIHByb3A7XG5cbiAgICAgIHZhciBpZHg7XG5cbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcHJvcHNbaV0uZ2V0VmFsdWVzKCkuZm9yRWFjaChoYW5kbGVQcm9wKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgcmVjdXJyZW5jZSBleHBhbnNpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7SUNBTC5Db21wb25lbnR9IGNvbXBvbmVudCAgICBUaGUgY29tcG9uZW50IHRvIGluaXRpYWxpemUgZnJvbS5cbiAgICAgKi9cbiAgICBfaW5pdDogZnVuY3Rpb24oY29tcG9uZW50KSB7XG4gICAgICB0aGlzLnJ1bGVJdGVyYXRvcnMgPSBbXTtcblxuICAgICAgdGhpcy5sYXN0ID0gdGhpcy5kdHN0YXJ0LmNsb25lKCk7XG5cbiAgICAgIC8vIHRvIHByb3ZpZGUgYXBpIGNvbnNpc3RlbmN5IG5vbi1yZWN1cnJpbmdcbiAgICAgIC8vIGV2ZW50cyBjYW4gYWxzbyB1c2UgdGhlIGl0ZXJhdG9yIHRob3VnaCBpdCB3aWxsXG4gICAgICAvLyBvbmx5IHJldHVybiBhIHNpbmdsZSB0aW1lLlxuICAgICAgaWYgKCFpc1JlY3VycmluZ0NvbXBvbmVudChjb21wb25lbnQpKSB7XG4gICAgICAgIHRoaXMucnVsZURhdGUgPSB0aGlzLmxhc3QuY2xvbmUoKTtcbiAgICAgICAgdGhpcy5jb21wbGV0ZSA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbXBvbmVudC5oYXNQcm9wZXJ0eSgncmRhdGUnKSkge1xuICAgICAgICB0aGlzLnJ1bGVEYXRlcyA9IHRoaXMuX2V4dHJhY3REYXRlcyhjb21wb25lbnQsICdyZGF0ZScpO1xuXG4gICAgICAgIC8vIHNwZWNpYWwgaGFjayBmb3IgY2FzZXMgd2hlcmUgZmlyc3QgcmRhdGUgaXMgcHJpb3JcbiAgICAgICAgLy8gdG8gdGhlIHN0YXJ0IGRhdGUuIFdlIG9ubHkgY2hlY2sgZm9yIHRoZSBmaXJzdCByZGF0ZS5cbiAgICAgICAgLy8gVGhpcyBpcyBtb3N0bHkgZm9yIGdvb2dsZSdzIGNyYXp5IHJlY3VycmluZyBkYXRlIGxvZ2ljXG4gICAgICAgIC8vIChjb250YWN0cyBiaXJ0aGRheXMpLlxuICAgICAgICBpZiAoKHRoaXMucnVsZURhdGVzWzBdKSAmJlxuICAgICAgICAgICAgKHRoaXMucnVsZURhdGVzWzBdLmNvbXBhcmUodGhpcy5kdHN0YXJ0KSA8IDApKSB7XG5cbiAgICAgICAgICB0aGlzLnJ1bGVEYXRlSW5jID0gMDtcbiAgICAgICAgICB0aGlzLmxhc3QgPSB0aGlzLnJ1bGVEYXRlc1swXS5jbG9uZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucnVsZURhdGVJbmMgPSBJQ0FMLmhlbHBlcnMuYmluc2VhcmNoSW5zZXJ0KFxuICAgICAgICAgICAgdGhpcy5ydWxlRGF0ZXMsXG4gICAgICAgICAgICB0aGlzLmxhc3QsXG4gICAgICAgICAgICBjb21wYXJlVGltZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJ1bGVEYXRlID0gdGhpcy5ydWxlRGF0ZXNbdGhpcy5ydWxlRGF0ZUluY107XG4gICAgICB9XG5cbiAgICAgIGlmIChjb21wb25lbnQuaGFzUHJvcGVydHkoJ3JydWxlJykpIHtcbiAgICAgICAgdmFyIHJ1bGVzID0gY29tcG9uZW50LmdldEFsbFByb3BlcnRpZXMoJ3JydWxlJyk7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxlbiA9IHJ1bGVzLmxlbmd0aDtcblxuICAgICAgICB2YXIgcnVsZTtcbiAgICAgICAgdmFyIGl0ZXI7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHJ1bGUgPSBydWxlc1tpXS5nZXRGaXJzdFZhbHVlKCk7XG4gICAgICAgICAgaXRlciA9IHJ1bGUuaXRlcmF0b3IodGhpcy5kdHN0YXJ0KTtcbiAgICAgICAgICB0aGlzLnJ1bGVJdGVyYXRvcnMucHVzaChpdGVyKTtcblxuICAgICAgICAgIC8vIGluY3JlbWVudCB0byB0aGUgbmV4dCBvY2N1cnJlbmNlIHNvIGZ1dHVyZVxuICAgICAgICAgIC8vIGNhbGxzIHRvIG5leHQgcmV0dXJuIHRpbWVzIGJleW9uZCB0aGUgaW5pdGlhbCBpdGVyYXRpb24uXG4gICAgICAgICAgLy8gWFhYOiBJIGZpbmQgdGhpcyBzdXNwaWNpb3VzIG1pZ2h0IGJlIGEgYnVnP1xuICAgICAgICAgIGl0ZXIubmV4dCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjb21wb25lbnQuaGFzUHJvcGVydHkoJ2V4ZGF0ZScpKSB7XG4gICAgICAgIHRoaXMuZXhEYXRlcyA9IHRoaXMuX2V4dHJhY3REYXRlcyhjb21wb25lbnQsICdleGRhdGUnKTtcbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIC5sYXN0IGRheSB3ZSBpbmNyZW1lbnQgdGhlIGluZGV4IHRvIGJleW9uZCBpdC5cbiAgICAgICAgdGhpcy5leERhdGVJbmMgPSBJQ0FMLmhlbHBlcnMuYmluc2VhcmNoSW5zZXJ0KFxuICAgICAgICAgIHRoaXMuZXhEYXRlcyxcbiAgICAgICAgICB0aGlzLmxhc3QsXG4gICAgICAgICAgY29tcGFyZVRpbWVcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLmV4RGF0ZSA9IHRoaXMuZXhEYXRlc1t0aGlzLmV4RGF0ZUluY107XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkdmFuY2UgdG8gdGhlIG5leHQgZXhkYXRlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbmV4dEV4RGF5OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZXhEYXRlID0gdGhpcy5leERhdGVzWysrdGhpcy5leERhdGVJbmNdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZHZhbmNlIHRvIHRoZSBuZXh0IHJ1bGUgZGF0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX25leHRSdWxlRGF5OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMucnVsZURhdGUgPSB0aGlzLnJ1bGVEYXRlc1srK3RoaXMucnVsZURhdGVJbmNdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGFuZCByZXR1cm4gdGhlIHJlY3VycmVuY2UgcnVsZSB3aXRoIHRoZSBtb3N0IHJlY2VudCBldmVudCBhbmRcbiAgICAgKiByZXR1cm4gaXQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4gez9JQ0FMLlJlY3VySXRlcmF0b3J9ICAgIEZvdW5kIGl0ZXJhdG9yLlxuICAgICAqL1xuICAgIF9uZXh0UmVjdXJyZW5jZUl0ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGl0ZXJzID0gdGhpcy5ydWxlSXRlcmF0b3JzO1xuXG4gICAgICBpZiAoaXRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuID0gaXRlcnMubGVuZ3RoO1xuICAgICAgdmFyIGl0ZXI7XG4gICAgICB2YXIgaXRlclRpbWU7XG4gICAgICB2YXIgaXRlcklkeCA9IDA7XG4gICAgICB2YXIgY2hvc2VuSXRlcjtcblxuICAgICAgLy8gbG9vcCB0aHJvdWdoIGVhY2ggaXRlcmF0b3JcbiAgICAgIGZvciAoOyBpdGVySWR4IDwgbGVuOyBpdGVySWR4KyspIHtcbiAgICAgICAgaXRlciA9IGl0ZXJzW2l0ZXJJZHhdO1xuICAgICAgICBpdGVyVGltZSA9IGl0ZXIubGFzdDtcblxuICAgICAgICAvLyBpZiBpdGVyYXRpb24gaXMgY29tcGxldGVcbiAgICAgICAgLy8gdGhlbiB3ZSBtdXN0IGV4Y2x1ZGUgaXQgZnJvbVxuICAgICAgICAvLyB0aGUgc2VhcmNoIGFuZCByZW1vdmUgaXQuXG4gICAgICAgIGlmIChpdGVyLmNvbXBsZXRlZCkge1xuICAgICAgICAgIGxlbi0tO1xuICAgICAgICAgIGlmIChpdGVySWR4ICE9PSAwKSB7XG4gICAgICAgICAgICBpdGVySWR4LS07XG4gICAgICAgICAgfVxuICAgICAgICAgIGl0ZXJzLnNwbGljZShpdGVySWR4LCAxKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmQgdGhlIG1vc3QgcmVjZW50IHBvc3NpYmxlIGNob2ljZVxuICAgICAgICBpZiAoIWNob3Nlbkl0ZXIgfHwgY2hvc2VuSXRlci5sYXN0LmNvbXBhcmUoaXRlclRpbWUpID4gMCkge1xuICAgICAgICAgIC8vIHRoYXQgaXRlcmF0b3IgaXMgc2F2ZWRcbiAgICAgICAgICBjaG9zZW5JdGVyID0gaXRlcjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyB0aGUgY2hvc2VuIGl0ZXJhdG9yIGlzIHJldHVybmVkIGJ1dCBub3QgbXV0YXRlZFxuICAgICAgLy8gdGhpcyBpdGVyYXRvciBjb250YWlucyB0aGUgbW9zdCByZWNlbnQgZXZlbnQuXG4gICAgICByZXR1cm4gY2hvc2VuSXRlcjtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFJlY3VyRXhwYW5zaW9uO1xufSgpKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAxMS0yMDE1ICovXG5cblxuLyoqXG4gKiBUaGlzIHN5bWJvbCBpcyBmdXJ0aGVyIGRlc2NyaWJlZCBsYXRlciBvblxuICogQGlnbm9yZVxuICovXG5JQ0FMLkV2ZW50ID0gKGZ1bmN0aW9uKCkge1xuXG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIElDQUwuanMgaXMgb3JnYW5pemVkIGludG8gbXVsdGlwbGUgbGF5ZXJzLiBUaGUgYm90dG9tIGxheWVyIGlzIGEgcmF3IGpDYWxcbiAgICogb2JqZWN0LCBmb2xsb3dlZCBieSB0aGUgY29tcG9uZW50L3Byb3BlcnR5IGxheWVyLiBUaGUgaGlnaGVzdCBsZXZlbCBpcyB0aGVcbiAgICogZXZlbnQgcmVwcmVzZW50YXRpb24sIHdoaWNoIHRoaXMgY2xhc3MgaXMgcGFydCBvZi4gU2VlIHRoZVxuICAgKiB7QHR1dG9yaWFsIGxheWVyc30gZ3VpZGUgZm9yIG1vcmUgZGV0YWlscy5cbiAgICpcbiAgICogQGNsYXNzXG4gICAqIEBhbGlhcyBJQ0FMLkV2ZW50XG4gICAqIEBwYXJhbSB7SUNBTC5Db21wb25lbnQ9fSBjb21wb25lbnQgICAgICAgICBUaGUgSUNBTC5Db21wb25lbnQgdG8gYmFzZSB0aGlzIGV2ZW50IG9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zICAgICAgICAgICAgICAgICAgICBPcHRpb25zIGZvciB0aGlzIGV2ZW50XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5zdHJpY3RFeGNlcHRpb25zXG4gICAqICAgICAgICAgIFdoZW4gdHJ1ZSwgd2lsbCB2ZXJpZnkgZXhjZXB0aW9ucyBhcmUgcmVsYXRlZCBieSB0aGVpciBVVUlEXG4gICAqIEBwYXJhbSB7QXJyYXk8SUNBTC5Db21wb25lbnR8SUNBTC5FdmVudD59IG9wdGlvbnMuZXhjZXB0aW9uc1xuICAgKiAgICAgICAgICBFeGNlcHRpb25zIHRvIHRoaXMgZXZlbnQsIGVpdGhlciBhcyBjb21wb25lbnRzIG9yIGV2ZW50cy4gSWYgbm90XG4gICAqICAgICAgICAgICAgc3BlY2lmaWVkIGV4Y2VwdGlvbnMgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIHNldCBpbiByZWxhdGlvbiBvZlxuICAgKiAgICAgICAgICAgIGNvbXBvbmVudCdzIHBhcmVudFxuICAgKi9cbiAgZnVuY3Rpb24gRXZlbnQoY29tcG9uZW50LCBvcHRpb25zKSB7XG4gICAgaWYgKCEoY29tcG9uZW50IGluc3RhbmNlb2YgSUNBTC5Db21wb25lbnQpKSB7XG4gICAgICBvcHRpb25zID0gY29tcG9uZW50O1xuICAgICAgY29tcG9uZW50ID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb21wb25lbnQgPSBuZXcgSUNBTC5Db21wb25lbnQoJ3ZldmVudCcpO1xuICAgIH1cblxuICAgIHRoaXMuX3JhbmdlRXhjZXB0aW9uQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuZXhjZXB0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5yYW5nZUV4Y2VwdGlvbnMgPSBbXTtcblxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc3RyaWN0RXhjZXB0aW9ucykge1xuICAgICAgdGhpcy5zdHJpY3RFeGNlcHRpb25zID0gb3B0aW9ucy5zdHJpY3RFeGNlcHRpb25zO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZXhjZXB0aW9ucykge1xuICAgICAgb3B0aW9ucy5leGNlcHRpb25zLmZvckVhY2godGhpcy5yZWxhdGVFeGNlcHRpb24sIHRoaXMpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5jb21wb25lbnQucGFyZW50ICYmICF0aGlzLmlzUmVjdXJyZW5jZUV4Y2VwdGlvbigpKSB7XG4gICAgICB0aGlzLmNvbXBvbmVudC5wYXJlbnQuZ2V0QWxsU3ViY29tcG9uZW50cygndmV2ZW50JykuZm9yRWFjaChmdW5jdGlvbihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuaGFzUHJvcGVydHkoJ3JlY3VycmVuY2UtaWQnKSkge1xuICAgICAgICAgIHRoaXMucmVsYXRlRXhjZXB0aW9uKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9XG5cbiAgRXZlbnQucHJvdG90eXBlID0ge1xuXG4gICAgVEhJU0FOREZVVFVSRTogJ1RISVNBTkRGVVRVUkUnLFxuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiByZWxhdGVkIGV2ZW50IGV4Y2VwdGlvbnMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7SUNBTC5FdmVudFtdfVxuICAgICAqL1xuICAgIGV4Y2VwdGlvbnM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIHdpbGwgdmVyaWZ5IGV4Y2VwdGlvbnMgYXJlIHJlbGF0ZWQgYnkgdGhlaXIgVVVJRC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0cmljdEV4Y2VwdGlvbnM6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogUmVsYXRlcyBhIGdpdmVuIGV2ZW50IGV4Y2VwdGlvbiB0byB0aGlzIG9iamVjdC4gIElmIHRoZSBnaXZlbiBjb21wb25lbnRcbiAgICAgKiBkb2VzIG5vdCBzaGFyZSB0aGUgVUlEIG9mIHRoaXMgZXZlbnQgaXQgY2Fubm90IGJlIHJlbGF0ZWQgYW5kIHdpbGwgdGhyb3dcbiAgICAgKiBhbiBleGNlcHRpb24uXG4gICAgICpcbiAgICAgKiBJZiB0aGlzIGNvbXBvbmVudCBpcyBhbiBleGNlcHRpb24gaXQgY2Fubm90IGhhdmUgb3RoZXIgZXhjZXB0aW9uc1xuICAgICAqIHJlbGF0ZWQgdG8gaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuQ29tcG9uZW50fElDQUwuRXZlbnR9IG9iaiAgICAgICBDb21wb25lbnQgb3IgZXZlbnRcbiAgICAgKi9cbiAgICByZWxhdGVFeGNlcHRpb246IGZ1bmN0aW9uKG9iaikge1xuICAgICAgaWYgKHRoaXMuaXNSZWN1cnJlbmNlRXhjZXB0aW9uKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgcmVsYXRlIGV4Y2VwdGlvbiB0byBleGNlcHRpb25zJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBJQ0FMLkNvbXBvbmVudCkge1xuICAgICAgICBvYmogPSBuZXcgSUNBTC5FdmVudChvYmopO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zdHJpY3RFeGNlcHRpb25zICYmIG9iai51aWQgIT09IHRoaXMudWlkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXR0ZW1wdGVkIHRvIHJlbGF0ZSB1bnJlbGF0ZWQgZXhjZXB0aW9uJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpZCA9IG9iai5yZWN1cnJlbmNlSWQudG9TdHJpbmcoKTtcblxuICAgICAgLy8gd2UgZG9uJ3Qgc29ydCBvciBtYW5hZ2UgZXhjZXB0aW9ucyBkaXJlY3RseVxuICAgICAgLy8gaGVyZSB0aGUgcmVjdXJyZW5jZSBleHBhbmRlciBoYW5kbGVzIHRoYXQuXG4gICAgICB0aGlzLmV4Y2VwdGlvbnNbaWRdID0gb2JqO1xuXG4gICAgICAvLyBpbmRleCBSQU5HRT1USElTQU5ERlVUVVJFIGV4Y2VwdGlvbnMgc28gd2UgY2FuXG4gICAgICAvLyBsb29rIHRoZW0gdXAgbGF0ZXIgaW4gZ2V0T2NjdXJyZW5jZURldGFpbHMuXG4gICAgICBpZiAob2JqLm1vZGlmaWVzRnV0dXJlKCkpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBbXG4gICAgICAgICAgb2JqLnJlY3VycmVuY2VJZC50b1VuaXhUaW1lKCksIGlkXG4gICAgICAgIF07XG5cbiAgICAgICAgLy8gd2Uga2VlcCB0aGVtIHNvcnRlZCBzbyB3ZSBjYW4gZmluZCB0aGUgbmVhcmVzdFxuICAgICAgICAvLyB2YWx1ZSBsYXRlciBvbi4uLlxuICAgICAgICB2YXIgaWR4ID0gSUNBTC5oZWxwZXJzLmJpbnNlYXJjaEluc2VydChcbiAgICAgICAgICB0aGlzLnJhbmdlRXhjZXB0aW9ucyxcbiAgICAgICAgICBpdGVtLFxuICAgICAgICAgIGNvbXBhcmVSYW5nZUV4Y2VwdGlvblxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMucmFuZ2VFeGNlcHRpb25zLnNwbGljZShpZHgsIDAsIGl0ZW0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhpcyByZWNvcmQgaXMgYW4gZXhjZXB0aW9uIGFuZCBoYXMgdGhlIFJBTkdFPVRISVNBTkRGVVRVUkVcbiAgICAgKiB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICBUcnVlLCB3aGVuIGV4Y2VwdGlvbiBpcyB3aXRoaW4gcmFuZ2VcbiAgICAgKi9cbiAgICBtb2RpZmllc0Z1dHVyZTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuY29tcG9uZW50Lmhhc1Byb3BlcnR5KCdyZWN1cnJlbmNlLWlkJykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLmNvbXBvbmVudC5nZXRGaXJzdFByb3BlcnR5KCdyZWN1cnJlbmNlLWlkJykuZ2V0UGFyYW1ldGVyKCdyYW5nZScpO1xuICAgICAgcmV0dXJuIHJhbmdlID09PSB0aGlzLlRISVNBTkRGVVRVUkU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSByYW5nZSBleGNlcHRpb24gbmVhcmVzdCB0byB0aGUgZ2l2ZW4gZGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SUNBTC5UaW1lfSB0aW1lIHVzdWFsbHkgYW4gb2NjdXJyZW5jZSB0aW1lIG9mIGFuIGV2ZW50XG4gICAgICogQHJldHVybiB7P0lDQUwuRXZlbnR9IHRoZSByZWxhdGVkIGV2ZW50L2V4Y2VwdGlvbiBvciBudWxsXG4gICAgICovXG4gICAgZmluZFJhbmdlRXhjZXB0aW9uOiBmdW5jdGlvbih0aW1lKSB7XG4gICAgICBpZiAoIXRoaXMucmFuZ2VFeGNlcHRpb25zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHV0YyA9IHRpbWUudG9Vbml4VGltZSgpO1xuICAgICAgdmFyIGlkeCA9IElDQUwuaGVscGVycy5iaW5zZWFyY2hJbnNlcnQoXG4gICAgICAgIHRoaXMucmFuZ2VFeGNlcHRpb25zLFxuICAgICAgICBbdXRjXSxcbiAgICAgICAgY29tcGFyZVJhbmdlRXhjZXB0aW9uXG4gICAgICApO1xuXG4gICAgICBpZHggLT0gMTtcblxuICAgICAgLy8gb2NjdXJzIGJlZm9yZVxuICAgICAgaWYgKGlkeCA8IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByYW5nZUl0ZW0gPSB0aGlzLnJhbmdlRXhjZXB0aW9uc1tpZHhdO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogc2FuaXR5IGNoZWNrIG9ubHkgKi9cbiAgICAgIGlmICh1dGMgPCByYW5nZUl0ZW1bMF0pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByYW5nZUl0ZW1bMV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgb2JqZWN0IGlzIHJldHVybmVkIGJ5IHtAbGluayBJQ0FMLkV2ZW50I2dldE9jY3VycmVuY2VEZXRhaWxzIGdldE9jY3VycmVuY2VEZXRhaWxzfVxuICAgICAqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gb2NjdXJyZW5jZURldGFpbHNcbiAgICAgKiBAbWVtYmVyb2YgSUNBTC5FdmVudFxuICAgICAqIEBwcm9wZXJ0eSB7SUNBTC5UaW1lfSByZWN1cnJlbmNlSWQgICAgICAgVGhlIHBhc3NlZCBpbiByZWN1cnJlbmNlIGlkXG4gICAgICogQHByb3BlcnR5IHtJQ0FMLkV2ZW50fSBpdGVtICAgICAgICAgICAgICBUaGUgb2NjdXJyZW5jZVxuICAgICAqIEBwcm9wZXJ0eSB7SUNBTC5UaW1lfSBzdGFydERhdGUgICAgICAgICAgVGhlIHN0YXJ0IG9mIHRoZSBvY2N1cnJlbmNlXG4gICAgICogQHByb3BlcnR5IHtJQ0FMLlRpbWV9IGVuZERhdGUgICAgICAgICAgICBUaGUgZW5kIG9mIHRoZSBvY2N1cnJlbmNlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBvY2N1cnJlbmNlIGRldGFpbHMgYmFzZWQgb24gaXRzIHN0YXJ0IHRpbWUuICBJZiB0aGVcbiAgICAgKiBvY2N1cnJlbmNlIGhhcyBhbiBleGNlcHRpb24gd2lsbCByZXR1cm4gdGhlIGRldGFpbHMgZm9yIHRoYXQgZXhjZXB0aW9uLlxuICAgICAqXG4gICAgICogTk9URTogdGhpcyBtZXRob2QgaXMgaW50ZW5kIHRvIGJlIHVzZWQgaW4gY29uanVuY3Rpb25cbiAgICAgKiAgICAgICB3aXRoIHRoZSB7QGxpbmsgSUNBTC5FdmVudCNpdGVyYXRvciBpdGVyYXRvcn0gbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWV9IG9jY3VycmVuY2UgdGltZSBvY2N1cnJlbmNlXG4gICAgICogQHJldHVybiB7SUNBTC5FdmVudC5vY2N1cnJlbmNlRGV0YWlsc30gSW5mb3JtYXRpb24gYWJvdXQgdGhlIG9jY3VycmVuY2VcbiAgICAgKi9cbiAgICBnZXRPY2N1cnJlbmNlRGV0YWlsczogZnVuY3Rpb24ob2NjdXJyZW5jZSkge1xuICAgICAgdmFyIGlkID0gb2NjdXJyZW5jZS50b1N0cmluZygpO1xuICAgICAgdmFyIHV0Y0lkID0gb2NjdXJyZW5jZS5jb252ZXJ0VG9ab25lKElDQUwuVGltZXpvbmUudXRjVGltZXpvbmUpLnRvU3RyaW5nKCk7XG4gICAgICB2YXIgaXRlbTtcbiAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgIC8vWFhYOiBDbG9uZT9cbiAgICAgICAgcmVjdXJyZW5jZUlkOiBvY2N1cnJlbmNlXG4gICAgICB9O1xuXG4gICAgICBpZiAoaWQgaW4gdGhpcy5leGNlcHRpb25zKSB7XG4gICAgICAgIGl0ZW0gPSByZXN1bHQuaXRlbSA9IHRoaXMuZXhjZXB0aW9uc1tpZF07XG4gICAgICAgIHJlc3VsdC5zdGFydERhdGUgPSBpdGVtLnN0YXJ0RGF0ZTtcbiAgICAgICAgcmVzdWx0LmVuZERhdGUgPSBpdGVtLmVuZERhdGU7XG4gICAgICAgIHJlc3VsdC5pdGVtID0gaXRlbTtcbiAgICAgIH0gZWxzZSBpZiAodXRjSWQgaW4gdGhpcy5leGNlcHRpb25zKSB7XG4gICAgICAgIGl0ZW0gPSB0aGlzLmV4Y2VwdGlvbnNbdXRjSWRdO1xuICAgICAgICByZXN1bHQuc3RhcnREYXRlID0gaXRlbS5zdGFydERhdGU7XG4gICAgICAgIHJlc3VsdC5lbmREYXRlID0gaXRlbS5lbmREYXRlO1xuICAgICAgICByZXN1bHQuaXRlbSA9IGl0ZW07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByYW5nZSBleGNlcHRpb25zIChSQU5HRT1USElTQU5ERlVUVVJFKSBoYXZlIGFcbiAgICAgICAgLy8gbG93ZXIgcHJpb3JpdHkgdGhlbiBkaXJlY3QgZXhjZXB0aW9ucyBidXRcbiAgICAgICAgLy8gbXVzdCBiZSBhY2NvdW50ZWQgZm9yIGZpcnN0LiBUaGVpciBpdGVtIGlzXG4gICAgICAgIC8vIGFsd2F5cyB0aGUgZmlyc3QgZXhjZXB0aW9uIHdpdGggdGhlIHJhbmdlIHByb3AuXG4gICAgICAgIHZhciByYW5nZUV4Y2VwdGlvbklkID0gdGhpcy5maW5kUmFuZ2VFeGNlcHRpb24oXG4gICAgICAgICAgb2NjdXJyZW5jZVxuICAgICAgICApO1xuICAgICAgICB2YXIgZW5kO1xuXG4gICAgICAgIGlmIChyYW5nZUV4Y2VwdGlvbklkKSB7XG4gICAgICAgICAgdmFyIGV4Y2VwdGlvbiA9IHRoaXMuZXhjZXB0aW9uc1tyYW5nZUV4Y2VwdGlvbklkXTtcblxuICAgICAgICAgIC8vIHJhbmdlIGV4Y2VwdGlvbiBtdXN0IG1vZGlmeSBzdGFuZGFyZCB0aW1lXG4gICAgICAgICAgLy8gYnkgdGhlIGRpZmZlcmVuY2UgKGlmIGFueSkgaW4gc3RhcnQvZW5kIHRpbWVzLlxuICAgICAgICAgIHJlc3VsdC5pdGVtID0gZXhjZXB0aW9uO1xuXG4gICAgICAgICAgdmFyIHN0YXJ0RGlmZiA9IHRoaXMuX3JhbmdlRXhjZXB0aW9uQ2FjaGVbcmFuZ2VFeGNlcHRpb25JZF07XG5cbiAgICAgICAgICBpZiAoIXN0YXJ0RGlmZikge1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsID0gZXhjZXB0aW9uLnJlY3VycmVuY2VJZC5jbG9uZSgpO1xuICAgICAgICAgICAgdmFyIG5ld1N0YXJ0ID0gZXhjZXB0aW9uLnN0YXJ0RGF0ZS5jbG9uZSgpO1xuXG4gICAgICAgICAgICAvLyB6b25lcyBtdXN0IGJlIHNhbWUgb3RoZXJ3aXNlIHN1YnRyYWN0IG1heSBiZSBpbmNvcnJlY3QuXG4gICAgICAgICAgICBvcmlnaW5hbC56b25lID0gbmV3U3RhcnQuem9uZTtcbiAgICAgICAgICAgIHN0YXJ0RGlmZiA9IG5ld1N0YXJ0LnN1YnRyYWN0RGF0ZShvcmlnaW5hbCk7XG5cbiAgICAgICAgICAgIHRoaXMuX3JhbmdlRXhjZXB0aW9uQ2FjaGVbcmFuZ2VFeGNlcHRpb25JZF0gPSBzdGFydERpZmY7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHN0YXJ0ID0gb2NjdXJyZW5jZS5jbG9uZSgpO1xuICAgICAgICAgIHN0YXJ0LnpvbmUgPSBleGNlcHRpb24uc3RhcnREYXRlLnpvbmU7XG4gICAgICAgICAgc3RhcnQuYWRkRHVyYXRpb24oc3RhcnREaWZmKTtcblxuICAgICAgICAgIGVuZCA9IHN0YXJ0LmNsb25lKCk7XG4gICAgICAgICAgZW5kLmFkZER1cmF0aW9uKGV4Y2VwdGlvbi5kdXJhdGlvbik7XG5cbiAgICAgICAgICByZXN1bHQuc3RhcnREYXRlID0gc3RhcnQ7XG4gICAgICAgICAgcmVzdWx0LmVuZERhdGUgPSBlbmQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbm8gcmFuZ2UgZXhjZXB0aW9uIHN0YW5kYXJkIGV4cGFuc2lvblxuICAgICAgICAgIGVuZCA9IG9jY3VycmVuY2UuY2xvbmUoKTtcbiAgICAgICAgICBlbmQuYWRkRHVyYXRpb24odGhpcy5kdXJhdGlvbik7XG5cbiAgICAgICAgICByZXN1bHQuZW5kRGF0ZSA9IGVuZDtcbiAgICAgICAgICByZXN1bHQuc3RhcnREYXRlID0gb2NjdXJyZW5jZTtcbiAgICAgICAgICByZXN1bHQuaXRlbSA9IHRoaXM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQnVpbGRzIGEgcmVjdXIgZXhwYW5zaW9uIGluc3RhbmNlIGZvciBhIHNwZWNpZmljIHBvaW50IGluIHRpbWUgKGRlZmF1bHRzXG4gICAgICogdG8gc3RhcnREYXRlKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SUNBTC5UaW1lfSBzdGFydFRpbWUgICAgIFN0YXJ0aW5nIHBvaW50IGZvciBleHBhbnNpb25cbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlJlY3VyRXhwYW5zaW9ufSAgICBFeHBhbnNpb24gb2JqZWN0XG4gICAgICovXG4gICAgaXRlcmF0b3I6IGZ1bmN0aW9uKHN0YXJ0VGltZSkge1xuICAgICAgcmV0dXJuIG5ldyBJQ0FMLlJlY3VyRXhwYW5zaW9uKHtcbiAgICAgICAgY29tcG9uZW50OiB0aGlzLmNvbXBvbmVudCxcbiAgICAgICAgZHRzdGFydDogc3RhcnRUaW1lIHx8IHRoaXMuc3RhcnREYXRlXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBldmVudCBpcyByZWN1cnJpbmdcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICBUcnVlLCBpZiBldmVudCBpcyByZWN1cnJpbmdcbiAgICAgKi9cbiAgICBpc1JlY3VycmluZzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29tcCA9IHRoaXMuY29tcG9uZW50O1xuICAgICAgcmV0dXJuIGNvbXAuaGFzUHJvcGVydHkoJ3JydWxlJykgfHwgY29tcC5oYXNQcm9wZXJ0eSgncmRhdGUnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBldmVudCBkZXNjcmliZXMgYSByZWN1cnJlbmNlIGV4Y2VwdGlvbi4gU2VlXG4gICAgICoge0B0dXRvcmlhbCB0ZXJtaW5vbG9neX0gZm9yIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICBUcnVlLCBpZiB0aGUgZXZlbnQgZGVzY3JpYmVzIGEgcmVjdXJyZW5jZSBleGNlcHRpb25cbiAgICAgKi9cbiAgICBpc1JlY3VycmVuY2VFeGNlcHRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50Lmhhc1Byb3BlcnR5KCdyZWN1cnJlbmNlLWlkJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHR5cGVzIG9mIHJlY3VycmVuY2VzIHRoaXMgZXZlbnQgbWF5IGhhdmUuXG4gICAgICpcbiAgICAgKiBSZXR1cm5lZCBhcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHBvc3NpYmxlIGtleXM6XG4gICAgICpcbiAgICAgKiAgICAtIFlFQVJMWVxuICAgICAqICAgIC0gTU9OVEhMWVxuICAgICAqICAgIC0gV0VFS0xZXG4gICAgICogICAgLSBEQUlMWVxuICAgICAqICAgIC0gTUlOVVRFTFlcbiAgICAgKiAgICAtIFNFQ09ORExZXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtPYmplY3QuPElDQUwuUmVjdXIuZnJlcXVlbmN5VmFsdWVzLCBCb29sZWFuPn1cbiAgICAgKiAgICAgICAgICBPYmplY3Qgb2YgcmVjdXJyZW5jZSBmbGFnc1xuICAgICAqL1xuICAgIGdldFJlY3VycmVuY2VUeXBlczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcnVsZXMgPSB0aGlzLmNvbXBvbmVudC5nZXRBbGxQcm9wZXJ0aWVzKCdycnVsZScpO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGxlbiA9IHJ1bGVzLmxlbmd0aDtcbiAgICAgIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJ1bGVzW2ldLmdldEZpcnN0VmFsdWUoKTtcbiAgICAgICAgcmVzdWx0W3ZhbHVlLmZyZXFdID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHVpZCBvZiB0aGlzIGV2ZW50XG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgdWlkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpcnN0UHJvcCgndWlkJyk7XG4gICAgfSxcblxuICAgIHNldCB1aWQodmFsdWUpIHtcbiAgICAgIHRoaXMuX3NldFByb3AoJ3VpZCcsIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHN0YXJ0IGRhdGVcbiAgICAgKiBAdHlwZSB7SUNBTC5UaW1lfVxuICAgICAqL1xuICAgIGdldCBzdGFydERhdGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmlyc3RQcm9wKCdkdHN0YXJ0Jyk7XG4gICAgfSxcblxuICAgIHNldCBzdGFydERhdGUodmFsdWUpIHtcbiAgICAgIHRoaXMuX3NldFRpbWUoJ2R0c3RhcnQnLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlbmQgZGF0ZS4gVGhpcyBjYW4gYmUgdGhlIHJlc3VsdCBkaXJlY3RseSBmcm9tIHRoZSBwcm9wZXJ0eSwgb3IgdGhlXG4gICAgICogZW5kIGRhdGUgY2FsY3VsYXRlZCBmcm9tIHN0YXJ0IGRhdGUgYW5kIGR1cmF0aW9uLiBTZXR0aW5nIHRoZSBwcm9wZXJ0eVxuICAgICAqIHdpbGwgcmVtb3ZlIGFueSBkdXJhdGlvbiBwcm9wZXJ0aWVzLlxuICAgICAqIEB0eXBlIHtJQ0FMLlRpbWV9XG4gICAgICovXG4gICAgZ2V0IGVuZERhdGUoKSB7XG4gICAgICB2YXIgZW5kRGF0ZSA9IHRoaXMuX2ZpcnN0UHJvcCgnZHRlbmQnKTtcbiAgICAgIGlmICghZW5kRGF0ZSkge1xuICAgICAgICAgIHZhciBkdXJhdGlvbiA9IHRoaXMuX2ZpcnN0UHJvcCgnZHVyYXRpb24nKTtcbiAgICAgICAgICBlbmREYXRlID0gdGhpcy5zdGFydERhdGUuY2xvbmUoKTtcbiAgICAgICAgICBpZiAoZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgZW5kRGF0ZS5hZGREdXJhdGlvbihkdXJhdGlvbik7XG4gICAgICAgICAgfSBlbHNlIGlmIChlbmREYXRlLmlzRGF0ZSkge1xuICAgICAgICAgICAgICBlbmREYXRlLmRheSArPSAxO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBlbmREYXRlO1xuICAgIH0sXG5cbiAgICBzZXQgZW5kRGF0ZSh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMuY29tcG9uZW50Lmhhc1Byb3BlcnR5KCdkdXJhdGlvbicpKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50LnJlbW92ZVByb3BlcnR5KCdkdXJhdGlvbicpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2V0VGltZSgnZHRlbmQnLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBkdXJhdGlvbi4gVGhpcyBjYW4gYmUgdGhlIHJlc3VsdCBkaXJlY3RseSBmcm9tIHRoZSBwcm9wZXJ0eSwgb3IgdGhlXG4gICAgICogZHVyYXRpb24gY2FsY3VsYXRlZCBmcm9tIHN0YXJ0IGRhdGUgYW5kIGVuZCBkYXRlLiBTZXR0aW5nIHRoZSBwcm9wZXJ0eVxuICAgICAqIHdpbGwgcmVtb3ZlIGFueSBgZHRlbmRgIHByb3BlcnRpZXMuXG4gICAgICogQHR5cGUge0lDQUwuRHVyYXRpb259XG4gICAgICovXG4gICAgZ2V0IGR1cmF0aW9uKCkge1xuICAgICAgdmFyIGR1cmF0aW9uID0gdGhpcy5fZmlyc3RQcm9wKCdkdXJhdGlvbicpO1xuICAgICAgaWYgKCFkdXJhdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmREYXRlLnN1YnRyYWN0RGF0ZVR6KHRoaXMuc3RhcnREYXRlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkdXJhdGlvbjtcbiAgICB9LFxuXG4gICAgc2V0IGR1cmF0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5jb21wb25lbnQuaGFzUHJvcGVydHkoJ2R0ZW5kJykpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnQucmVtb3ZlUHJvcGVydHkoJ2R0ZW5kJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3NldFByb3AoJ2R1cmF0aW9uJywgdmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbG9jYXRpb24gb2YgdGhlIGV2ZW50LlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGxvY2F0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpcnN0UHJvcCgnbG9jYXRpb24nKTtcbiAgICB9LFxuXG4gICAgc2V0IGxvY2F0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2V0UHJvcCgnbG9jYXRpb24nLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBhdHRlbmRlZXMgaW4gdGhlIGV2ZW50XG4gICAgICogQHR5cGUge0lDQUwuUHJvcGVydHlbXX1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBnZXQgYXR0ZW5kZWVzKCkge1xuICAgICAgLy9YWFg6IFRoaXMgaXMgd2F5IGxhbWUgd2Ugc2hvdWxkIGhhdmUgYSBiZXR0ZXJcbiAgICAgIC8vICAgICBkYXRhIHN0cnVjdHVyZSBmb3IgdGhpcyBsYXRlci5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudC5nZXRBbGxQcm9wZXJ0aWVzKCdhdHRlbmRlZScpO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIFRoZSBldmVudCBzdW1tYXJ5XG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgc3VtbWFyeSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9maXJzdFByb3AoJ3N1bW1hcnknKTtcbiAgICB9LFxuXG4gICAgc2V0IHN1bW1hcnkodmFsdWUpIHtcbiAgICAgIHRoaXMuX3NldFByb3AoJ3N1bW1hcnknLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBldmVudCBkZXNjcmlwdGlvbi5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBkZXNjcmlwdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9maXJzdFByb3AoJ2Rlc2NyaXB0aW9uJyk7XG4gICAgfSxcblxuICAgIHNldCBkZXNjcmlwdGlvbih2YWx1ZSkge1xuICAgICAgdGhpcy5fc2V0UHJvcCgnZGVzY3JpcHRpb24nLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBldmVudCBjb2xvciBmcm9tIFtyZmM3OTg2XShodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzc5ODYpXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgY29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmlyc3RQcm9wKCdjb2xvcicpO1xuICAgIH0sXG5cbiAgICBzZXQgY29sb3IodmFsdWUpIHtcbiAgICAgIHRoaXMuX3NldFByb3AoJ2NvbG9yJywgdmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3JnYW5pemVyIHZhbHVlIGFzIGFuIHVyaS4gSW4gbW9zdCBjYXNlcyB0aGlzIGlzIGEgbWFpbHRvOiB1cmksIGJ1dFxuICAgICAqIGl0IGNhbiBhbHNvIGJlIHNvbWV0aGluZyBlbHNlLCBsaWtlIHVybjp1dWlkOi4uLlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IG9yZ2FuaXplcigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9maXJzdFByb3AoJ29yZ2FuaXplcicpO1xuICAgIH0sXG5cbiAgICBzZXQgb3JnYW5pemVyKHZhbHVlKSB7XG4gICAgICB0aGlzLl9zZXRQcm9wKCdvcmdhbml6ZXInLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzZXF1ZW5jZSB2YWx1ZSBmb3IgdGhpcyBldmVudC4gVXNlZCBmb3Igc2NoZWR1bGluZ1xuICAgICAqIHNlZSB7QHR1dG9yaWFsIHRlcm1pbm9sb2d5fS5cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBzZXF1ZW5jZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9maXJzdFByb3AoJ3NlcXVlbmNlJyk7XG4gICAgfSxcblxuICAgIHNldCBzZXF1ZW5jZSh2YWx1ZSkge1xuICAgICAgdGhpcy5fc2V0UHJvcCgnc2VxdWVuY2UnLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSByZWN1cnJlbmNlIGlkIGZvciB0aGlzIGV2ZW50LiBTZWUge0B0dXRvcmlhbCB0ZXJtaW5vbG9neX0gZm9yIGRldGFpbHMuXG4gICAgICogQHR5cGUge0lDQUwuVGltZX1cbiAgICAgKi9cbiAgICBnZXQgcmVjdXJyZW5jZUlkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpcnN0UHJvcCgncmVjdXJyZW5jZS1pZCcpO1xuICAgIH0sXG5cbiAgICBzZXQgcmVjdXJyZW5jZUlkKHZhbHVlKSB7XG4gICAgICB0aGlzLl9zZXRUaW1lKCdyZWN1cnJlbmNlLWlkJywgdmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQvdXBkYXRlIGEgdGltZSBwcm9wZXJ0eSdzIHZhbHVlLlxuICAgICAqIFRoaXMgd2lsbCBhbHNvIHVwZGF0ZSB0aGUgVFpJRCBvZiB0aGUgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBUT0RPOiB0aGlzIG1ldGhvZCBoYW5kbGVzIHRoZSBjYXNlIHdoZXJlIHdlIGFyZSBzd2l0Y2hpbmdcbiAgICAgKiBmcm9tIGEga25vd24gdGltZXpvbmUgdG8gYW4gaW1wbGllZCB0aW1lem9uZSAob25lIHdpdGhvdXQgVFpJRCkuXG4gICAgICogVGhpcyBkb2VzIF9ub3RfIGhhbmRsZSB0aGUgY2FzZSBvZiBtb3ZpbmcgYmV0d2VlbiBhIGtub3duXG4gICAgICogIChieSBUaW1lem9uZVNlcnZpY2UpIHRpbWV6b25lIHRvIGFuIHVua25vd24gdGltZXpvbmUuLi5cbiAgICAgKlxuICAgICAqIFdlIHdpbGwgbm90IGFkZC9yZW1vdmUvdXBkYXRlIHRoZSBWVElNRVpPTkUgc3ViY29tcG9uZW50c1xuICAgICAqICBsZWFkaW5nIHRvIGludmFsaWQgSUNBTCBkYXRhLi4uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcE5hbWUgICAgIFRoZSBwcm9wZXJ0eSBuYW1lXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWV9IHRpbWUgICAgICBUaGUgdGltZSB0byBzZXRcbiAgICAgKi9cbiAgICBfc2V0VGltZTogZnVuY3Rpb24ocHJvcE5hbWUsIHRpbWUpIHtcbiAgICAgIHZhciBwcm9wID0gdGhpcy5jb21wb25lbnQuZ2V0Rmlyc3RQcm9wZXJ0eShwcm9wTmFtZSk7XG5cbiAgICAgIGlmICghcHJvcCkge1xuICAgICAgICBwcm9wID0gbmV3IElDQUwuUHJvcGVydHkocHJvcE5hbWUpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudC5hZGRQcm9wZXJ0eShwcm9wKTtcbiAgICAgIH1cblxuICAgICAgLy8gdXRjIGFuZCBsb2NhbCBkb24ndCBnZXQgYSB0emlkXG4gICAgICBpZiAoXG4gICAgICAgIHRpbWUuem9uZSA9PT0gSUNBTC5UaW1lem9uZS5sb2NhbFRpbWV6b25lIHx8XG4gICAgICAgIHRpbWUuem9uZSA9PT0gSUNBTC5UaW1lem9uZS51dGNUaW1lem9uZVxuICAgICAgKSB7XG4gICAgICAgIC8vIHJlbW92ZSB0aGUgdHppZFxuICAgICAgICBwcm9wLnJlbW92ZVBhcmFtZXRlcigndHppZCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcC5zZXRQYXJhbWV0ZXIoJ3R6aWQnLCB0aW1lLnpvbmUudHppZCk7XG4gICAgICB9XG5cbiAgICAgIHByb3Auc2V0VmFsdWUodGltZSk7XG4gICAgfSxcblxuICAgIF9zZXRQcm9wOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgdGhpcy5jb21wb25lbnQudXBkYXRlUHJvcGVydHlXaXRoVmFsdWUobmFtZSwgdmFsdWUpO1xuICAgIH0sXG5cbiAgICBfZmlyc3RQcm9wOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21wb25lbnQuZ2V0Rmlyc3RQcm9wZXJ0eVZhbHVlKG5hbWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZXZlbnQuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudC50b1N0cmluZygpO1xuICAgIH1cblxuICB9O1xuXG4gIGZ1bmN0aW9uIGNvbXBhcmVSYW5nZUV4Y2VwdGlvbihhLCBiKSB7XG4gICAgaWYgKGFbMF0gPiBiWzBdKSByZXR1cm4gMTtcbiAgICBpZiAoYlswXSA+IGFbMF0pIHJldHVybiAtMTtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiBFdmVudDtcbn0oKSk7XG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICogUG9ydGlvbnMgQ29weXJpZ2h0IChDKSBQaGlsaXBwIEtld2lzY2gsIDIwMTEtMjAxNSAqL1xuXG5cbi8qKlxuICogVGhpcyBzeW1ib2wgaXMgZnVydGhlciBkZXNjcmliZWQgbGF0ZXIgb25cbiAqIEBpZ25vcmVcbiAqL1xuSUNBTC5Db21wb25lbnRQYXJzZXIgPSAoZnVuY3Rpb24oKSB7XG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIFRoZSBDb21wb25lbnRQYXJzZXIgaXMgdXNlZCB0byBwcm9jZXNzIGEgU3RyaW5nIG9yIGpDYWwgT2JqZWN0LFxuICAgKiBmaXJpbmcgY2FsbGJhY2tzIGZvciB2YXJpb3VzIGZvdW5kIGNvbXBvbmVudHMsIGFzIHdlbGwgYXMgY29tcGxldGlvbi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogdmFyIG9wdGlvbnMgPSB7XG4gICAqICAgLy8gd2hlbiBmYWxzZSBubyBldmVudHMgd2lsbCBiZSBlbWl0dGVkIGZvciB0eXBlXG4gICAqICAgcGFyc2VFdmVudDogdHJ1ZSxcbiAgICogICBwYXJzZVRpbWV6b25lOiB0cnVlXG4gICAqIH07XG4gICAqXG4gICAqIHZhciBwYXJzZXIgPSBuZXcgSUNBTC5Db21wb25lbnRQYXJzZXIob3B0aW9ucyk7XG4gICAqXG4gICAqIHBhcnNlci5vbmV2ZW50KGV2ZW50Q29tcG9uZW50KSB7XG4gICAqICAgLy8uLi5cbiAgICogfVxuICAgKlxuICAgKiAvLyBvbnRpbWV6b25lLCBldGMuLi5cbiAgICpcbiAgICogcGFyc2VyLm9uY29tcGxldGUgPSBmdW5jdGlvbigpIHtcbiAgICpcbiAgICogfTtcbiAgICpcbiAgICogcGFyc2VyLnByb2Nlc3Moc3RyaW5nT3JDb21wb25lbnQpO1xuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQGFsaWFzIElDQUwuQ29tcG9uZW50UGFyc2VyXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyAgICAgICAgQ29tcG9uZW50IHBhcnNlciBvcHRpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5wYXJzZUV2ZW50ICAgICAgICBXaGV0aGVyIGV2ZW50cyBzaG91bGQgYmUgcGFyc2VkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5wYXJzZVRpbWV6ZW9uZSAgICBXaGV0aGVyIHRpbWV6b25lcyBzaG91bGQgYmUgcGFyc2VkXG4gICAqL1xuICBmdW5jdGlvbiBDb21wb25lbnRQYXJzZXIob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Yob3B0aW9ucykgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdmFyIGtleTtcbiAgICBmb3IgKGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICB0aGlzW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgQ29tcG9uZW50UGFyc2VyLnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgcGFyc2UgZXZlbnRzXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBwYXJzZUV2ZW50OiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCBwYXJzZSB0aW1lem9uZXNcbiAgICAgKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHBhcnNlVGltZXpvbmU6IHRydWUsXG5cblxuICAgIC8qIFNBWCBsaWtlIGV2ZW50cyBoZXJlIGZvciByZWZlcmVuY2UgKi9cblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gcGFyc2luZyBpcyBjb21wbGV0ZVxuICAgICAqIEBjYWxsYmFja1xuICAgICAqL1xuICAgIG9uY29tcGxldGU6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uKCkge30sXG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCBpZiBhbiBlcnJvciBvY2N1cnMgZHVyaW5nIHBhcnNpbmcuXG4gICAgICpcbiAgICAgKiBAY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0ge0Vycm9yfSBlcnIgZGV0YWlscyBvZiBlcnJvclxuICAgICAqL1xuICAgIG9uZXJyb3I6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uKGVycikge30sXG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIGEgdG9wIGxldmVsIGNvbXBvbmVudCAoVlRJTUVaT05FKSBpcyBmb3VuZFxuICAgICAqXG4gICAgICogQGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWV6b25lfSBjb21wb25lbnQgICAgIFRpbWV6b25lIG9iamVjdFxuICAgICAqL1xuICAgIG9udGltZXpvbmU6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uKGNvbXBvbmVudCkge30sXG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIGEgdG9wIGxldmVsIGNvbXBvbmVudCAoVkVWRU5UKSBpcyBmb3VuZC5cbiAgICAgKlxuICAgICAqIEBjYWxsYmFja1xuICAgICAqIEBwYXJhbSB7SUNBTC5FdmVudH0gY29tcG9uZW50ICAgIFRvcCBsZXZlbCBjb21wb25lbnRcbiAgICAgKi9cbiAgICBvbmV2ZW50OiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmdW5jdGlvbihjb21wb25lbnQpIHt9LFxuXG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBhIHN0cmluZyBvciBwYXJzZSBpY2FsIG9iamVjdC4gIFRoaXMgZnVuY3Rpb24gaXRzZWxmIHdpbGwgcmV0dXJuXG4gICAgICogbm90aGluZyBidXQgd2lsbCBzdGFydCB0aGUgcGFyc2luZyBwcm9jZXNzLlxuICAgICAqXG4gICAgICogRXZlbnRzIG11c3QgYmUgcmVnaXN0ZXJlZCBwcmlvciB0byBjYWxsaW5nIHRoaXMgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLkNvbXBvbmVudHxTdHJpbmd8T2JqZWN0fSBpY2FsICAgICAgVGhlIGNvbXBvbmVudCB0byBwcm9jZXNzLFxuICAgICAqICAgICAgICBlaXRoZXIgaW4gaXRzIGZpbmFsIGZvcm0sIGFzIGEgakNhbCBPYmplY3QsIG9yIHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgICAqL1xuICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGljYWwpIHtcbiAgICAgIC8vVE9ETzogdGhpcyBpcyBzeW5jIG5vdyBpbiB0aGUgZnV0dXJlIHdlIHdpbGwgaGF2ZSBhIGluY3JlbWVudGFsIHBhcnNlci5cbiAgICAgIGlmICh0eXBlb2YoaWNhbCkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGljYWwgPSBJQ0FMLnBhcnNlKGljYWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIShpY2FsIGluc3RhbmNlb2YgSUNBTC5Db21wb25lbnQpKSB7XG4gICAgICAgIGljYWwgPSBuZXcgSUNBTC5Db21wb25lbnQoaWNhbCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb21wb25lbnRzID0gaWNhbC5nZXRBbGxTdWJjb21wb25lbnRzKCk7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgbGVuID0gY29tcG9uZW50cy5sZW5ndGg7XG4gICAgICB2YXIgY29tcG9uZW50O1xuXG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbaV07XG5cbiAgICAgICAgc3dpdGNoIChjb21wb25lbnQubmFtZSkge1xuICAgICAgICAgIGNhc2UgJ3Z0aW1lem9uZSc6XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJzZVRpbWV6b25lKSB7XG4gICAgICAgICAgICAgIHZhciB0emlkID0gY29tcG9uZW50LmdldEZpcnN0UHJvcGVydHlWYWx1ZSgndHppZCcpO1xuICAgICAgICAgICAgICBpZiAodHppZCkge1xuICAgICAgICAgICAgICAgIHRoaXMub250aW1lem9uZShuZXcgSUNBTC5UaW1lem9uZSh7XG4gICAgICAgICAgICAgICAgICB0emlkOiB0emlkLFxuICAgICAgICAgICAgICAgICAgY29tcG9uZW50OiBjb21wb25lbnRcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3ZldmVudCc6XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJzZUV2ZW50KSB7XG4gICAgICAgICAgICAgIHRoaXMub25ldmVudChuZXcgSUNBTC5FdmVudChjb21wb25lbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvL1hYWDogaWRlYWxseSB3ZSBzaG91bGQgZG8gYSBcIm5leHRUaWNrXCIgaGVyZVxuICAgICAgLy8gICAgIHNvIGluIGFsbCBjYXNlcyB0aGlzIGlzIGFjdHVhbGx5IGFzeW5jLlxuICAgICAgdGhpcy5vbmNvbXBsZXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBDb21wb25lbnRQYXJzZXI7XG59KCkpO1xuIiwgIi8vIGltcG9ydCB7IEFwcCwgRWRpdG9yLCBNYXJrZG93blZpZXcsIE1vZGFsLCBOb3RpY2UsIFBsdWdpbiwgUGx1Z2luU2V0dGluZ1RhYiwgU2V0dGluZywgSXRlbVZpZXcsIFBsYXRmb3JtLCBXb3Jrc3BhY2VMZWFmIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgQXBwLCBOb3RpY2UsIFBsdWdpbiwgUGx1Z2luTWFuaWZlc3QsIFRGaWxlLCBXb3Jrc3BhY2VMZWFmIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgQ2FsZW5kYXJWaWV3fSBmcm9tIFwiLi92aWV3cy9DYWxlbmRhclZpZXdcIlxuaW1wb3J0IHsgQ2FjaGUgfSBmcm9tIFwiLi9jYWNoZVwiXG5pbXBvcnQgeyBQbHVnaW5TZXR0aW5ncyB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgTXlTZXR0aW5nVGFiIH0gZnJvbSAnLi9zZXR0aW5nJztcbmltcG9ydCB7IERFRkFVTFRfU0VUVElOR1MsIENBQ0hFX0lELCBNU0dfUExHX05BTUUsIFZJRVdfVFlQRSB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCBTdGF0dXNDb3JyZWN0b3IgZnJvbSAnLi92aWV3cy9zdGF0dXNDb3JyZWN0b3InO1xuaW1wb3J0IEZpbGVNYW5hZ2VyIGZyb20gJy4vZmlsZU1hbmFnZXInO1xuaW1wb3J0IHsgVGlja0NoZWNrZXIgfSBmcm9tICcuL3ZpZXdzL1RpY2tDaGVrZXInO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE15UGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcbiAgcHVibGljIGZpbGVNYW5hZ2VyOiBGaWxlTWFuYWdlclxuXG4gIHB1YmxpYyBjYWNoZTogQ2FjaGVcblxuICBwcml2YXRlIHN0YXR1c0NvcnJlY3RvcjogU3RhdHVzQ29ycmVjdG9yXG5cbiAgcHJpdmF0ZSBzZXR0aW5nczogUGx1Z2luU2V0dGluZ3NcblxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgbWFuaWZlc3Q6IFBsdWdpbk1hbmlmZXN0KSB7XG4gICAgc3VwZXIoYXBwLCBtYW5pZmVzdClcblxuICAgIGNvbnN0IGZpbGVNYW5hZ2VyID0gbmV3IEZpbGVNYW5hZ2VyKHRoaXMpXG4gICAgdGhpcy5maWxlTWFuYWdlciA9IGZpbGVNYW5hZ2VyXG5cbiAgICAvLyBcdTA0NDFcdTA0M0VcdTA0MzdcdTA0MzRcdTA0MzBcdTA0MzJcdTA0MzBcdTA0NDJcdTA0NEMgXHUwNDNGXHUwNDQwXHUwNDM4IG9ubG9hZCBcdTA0MzggXHUwNDQyXHUwNDNFXHUwNDMzXHUwNDM0XHUwNDMwIFx1MDQzNlx1MDQzNSBcdTA0MzdcdTA0MzBcdTA0M0ZcdTA0NDNcdTA0NDFcdTA0M0FcdTA0MzBcdTA0NDJcdTA0NEMgaW5pdFN0b3JhZ2VcbiAgICB0aGlzLmNhY2hlID0gbmV3IENhY2hlKHRoaXMsIGZpbGVNYW5hZ2VyKVxuICB9XG5cbiAgcHVibGljIGFzeW5jIG9ubG9hZCgpIHtcbiAgICBhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpXG5cbiAgICB0aGlzLmluaXRSZWdpc3RlcigpXG5cbiAgICBhd2FpdCBuZXcgVGlja0NoZWNrZXIoQ0FDSEVfSUQuVElDS19DSEVDS0VSLCB0aGlzLnNldHRpbmdzLnNvdXJjZS5ub3RlU291cmNlcywgdGhpcylcblxuICAgIC8vIGlmICh0aGlzLnNldHRpbmdzLnN0YXR1c0NvcnJlY3Rvci5pc09uKSB7XG4gICAgLy8gICB0aGlzLnN0YXR1c0NvcnJlY3RvciA9IG5ldyBTdGF0dXNDb3JyZWN0b3IoQ0FDSEVfSUQuU1RBVFVTX0NPUlJFQ1RPUiwgdGhpcy5zZXR0aW5ncy5zb3VyY2Uubm90ZVNvdXJjZXMsIHRoaXMpXG5cbiAgICAvLyAgIGlmICh0aGlzLnNldHRpbmdzLnN0YXR1c0NvcnJlY3Rvci5zdGFydE9uU3RhcnRVcClcbiAgICAvLyAgICAgdGhpcy5zdGF0dXNDb3JyZWN0b3IuY29ycmVjdEFsbE5vdGVzKClcblxuICAgIC8vICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAvLyAgICAgaWQ6ICdmdWxsU3RhdHVzQ29ycmVjdCcsXG4gICAgLy8gICAgIG5hbWU6IE1TR19QTEdfTkFNRSArICdGdWxsIFN0YXR1c0NvcnJlY3RvcicsXG4gICAgLy8gICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgLy8gICAgICAgdGhpcy5zdGF0dXNDb3JyZWN0b3IuY29ycmVjdEFsbE5vdGVzKClcbiAgICAvLyAgICAgfVxuICAgIC8vICAgfSk7XG4gICAgLy8gfVxuXG4gICAgdGhpcy5yZWdpc3RlclZpZXcoXG4gICAgICAgIFZJRVdfVFlQRSxcbiAgICAgICAgKGxlYWY6IFdvcmtzcGFjZUxlYWYpID0+IG5ldyBDYWxlbmRhclZpZXcoXG4gICAgICAgICAgbGVhZixcbiAgICAgICAgICBDQUNIRV9JRC5DQUxFTkRBUixcbiAgICAgICAgICB0aGlzLnNldHRpbmdzLnNvdXJjZS5ub3RlU291cmNlcyxcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIHRoaXMuc2V0dGluZ3Muc291cmNlLmRlZmF1bHRDcmVhdGVQYXRoXG4gICAgICAgIClcbiAgICApXG5cbiAgICB0aGlzLmFkZFJpYmJvbkljb24oXCJpbmZvXCIsIE1TR19QTEdfTkFNRSArIFwiT3BlbiBDYWxlbmRhclwiLCAoKSA9PiB0aGlzLmFjdGl2YXRlVmlldygpKVxuXG4gICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgIGlkOiAncmVzZXQtY2FjaGUnLFxuICAgICAgbmFtZTogTVNHX1BMR19OQU1FICsgJ1Jlc2V0IENhY2hlJyxcbiAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuY2FjaGUucmVzZXQoKVxuICAgICAgfVxuICAgIH0pXG4gICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgIGlkOiAnbG9nLWNhY2hlJyxcbiAgICAgIG5hbWU6IE1TR19QTEdfTkFNRSArICdMb2cgQ2FjaGUnLFxuICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgdGhpcy5jYWNoZS5sb2coKVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIG9udW5sb2FkKCkge1xuICAgIC8vIFRPRE8gXHUwNDNBXHUwNDMwXHUwNDNBIFx1MDQzMVx1MDQ0M1x1MDQzNFx1MDQ0Mlx1MDQzRSBcdTA0MzRcdTA0NDBcdTA0NDNcdTA0MzNcdTA0MzhcdTA0NDUgXHUwNDNEXHUwNDM1IFx1MDQ0NVx1MDQzMlx1MDQzMFx1MDQ0Mlx1MDQzMFx1MDQzNVx1MDQ0MiBkZXN0b3lcbiAgICBpZiAodGhpcy5zZXR0aW5ncy5zdGF0dXNDb3JyZWN0b3IuaXNPbilcbiAgICAgIHRoaXMuc3RhdHVzQ29ycmVjdG9yLmRlc3Ryb3koKVxuICB9XG5cbiAgcHJpdmF0ZSBpbml0UmVnaXN0ZXIoKSB7XG4gICAgdGhpcy5yZWdpc3RlckV2ZW50KFxuICAgICAgdGhpcy5hcHAubWV0YWRhdGFDYWNoZS5vbihcImNoYW5nZWRcIiwgZmlsZSA9PiB7XG4gICAgICAgIHRoaXMuY2FjaGUuY2hhbmdlRmlsZShmaWxlKVxuICAgICAgfSlcbiAgICApXG5cbiAgICB0aGlzLnJlZ2lzdGVyRXZlbnQoXG4gICAgICB0aGlzLmFwcC52YXVsdC5vbihcbiAgICAgICAgXCJyZW5hbWVcIixcbiAgICAgICAgKGZpbGUsIG9sZFBhdGgpID0+IHtcbiAgICAgICAgICAvLyBcdTA0M0ZcdTA0NDBcdTA0M0VcdTA0MzJcdTA0MzVcdTA0NDBcdTA0M0FcdTA0MzAgXHUwNDNEXHUwNDMwIFx1MDQ0Mlx1MDQzRSwgXHUwNDQ3XHUwNDQyXHUwNDNFIFx1MDQ0RFx1MDQ0Mlx1MDQzRSBcdTA0NDRcdTA0MzBcdTA0MzlcdTA0M0IsIFx1MDQzMCBcdTA0M0RcdTA0MzUgXHUwNDNGXHUwNDMwXHUwNDNGXHUwNDNBXHUwNDMwXG4gICAgICAgICAgaWYgKCEoZmlsZSBhcyBURmlsZSkuYmFzZW5hbWUpXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICAgIHRoaXMuY2FjaGUucmVuYW1lRmlsZShmaWxlIGFzIFRGaWxlLCBvbGRQYXRoKVxuICAgICAgICB9XG4gICAgICApXG4gICAgKVxuXG4gICAgdGhpcy5yZWdpc3RlckV2ZW50KFxuICAgICAgdGhpcy5hcHAudmF1bHQub24oXG4gICAgICAgIFwiZGVsZXRlXCIsXG4gICAgICAgIGZpbGUgPT4gdGhpcy5jYWNoZS5kZWxldGVGaWxlKGZpbGUpXG4gICAgICApXG4gICAgKVxuXG4gICAgdGhpcy5yZWdpc3RlckV2ZW50KFxuICAgICAgdGhpcy5hcHAudmF1bHQub24oXG4gICAgICAgIFwiY3JlYXRlXCIsXG4gICAgICAgIGZpbGUgPT4ge1xuICAgICAgICAgIC8vIFx1MDQzRlx1MDQ0MFx1MDQzRVx1MDQzMlx1MDQzNVx1MDQ0MFx1MDQzQVx1MDQzMCBcdTA0M0RcdTA0MzAgXHUwNDQyXHUwNDNFLCBcdTA0NDdcdTA0NDJcdTA0M0UgXHUwNDREXHUwNDQyXHUwNDNFIFx1MDQ0NFx1MDQzMFx1MDQzOVx1MDQzQiwgXHUwNDMwIFx1MDQzRFx1MDQzNSBcdTA0M0ZcdTA0MzBcdTA0M0ZcdTA0M0FcdTA0MzBcbiAgICAgICAgICBpZiAoIShmaWxlIGFzIFRGaWxlKS5iYXNlbmFtZSlcbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgICAgdGhpcy5jYWNoZS5hZGRGaWxlKGZpbGUgYXMgVEZpbGUpXG4gICAgICAgIH1cbiAgICAgIClcbiAgICApXG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGFjdGl2YXRlVmlldygpIHtcbiAgICBjb25zdCBsZWF2ZXMgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0TGVhdmVzT2ZUeXBlKFZJRVdfVFlQRSlcbiAgICBpZiAobGVhdmVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc3QgbGVhZiA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRMZWFmKGZhbHNlKTtcbiAgICAgIGF3YWl0IGxlYWYuc2V0Vmlld1N0YXRlKHtcbiAgICAgICAgdHlwZTogVklFV19UWVBFLFxuICAgICAgICBhY3RpdmU6IHRydWUsXG4gICAgICB9KVxuICAgIH1cbiAgICBlbHNlIGlmIChsZWF2ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAobGVhdmVzWzBdLnZpZXcgYXMgQ2FsZW5kYXJWaWV3KS5vbk9wZW4oKVxuICAgICAgdGhpcy5hcHAud29ya3NwYWNlLnNldEFjdGl2ZUxlYWYobGVhdmVzWzBdKVxuICAgIH1cbiAgICBlbHNlIGZvciAobGV0IGxlYWYgb2YgbGVhdmVzKVxuICAgICAgbGVhZi5kZXRhY2goKVxuICB9XG5cblxuICAvLyBTZXR0aW5nc1xuXG4gIHB1YmxpYyBnZXRTZXR0aW5ncygpOiBQbHVnaW5TZXR0aW5ncyB7XG4gICAgLy8gTk9URTogZnVsbCBjb3B5XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoXG4gICAgICBKU09OLnN0cmluZ2lmeSh0aGlzLnNldHRpbmdzKVxuICAgIClcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBzYXZlU2V0dGluZ3Moc2V0dGluZ3M6IFBsdWdpblNldHRpbmdzKSB7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzXG4gICAgYXdhaXQgdGhpcy5zYXZlRGF0YSh0aGlzLnNldHRpbmdzKTtcbiAgfVxuXG5cblxuICBwcml2YXRlIGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcbiAgICB0aGlzLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9TRVRUSU5HUywgYXdhaXQgdGhpcy5sb2FkRGF0YSgpKVxuXG4gICAgdGhpcy5hZGRTZXR0aW5nVGFiKG5ldyBNeVNldHRpbmdUYWIodGhpcy5hcHAsIHRoaXMpKTtcbiAgfVxufVxuIiwgImltcG9ydCB7IEl0ZW1WaWV3LCBQbGF0Zm9ybSwgV29ya3NwYWNlTGVhZiwgTm90aWNlLCBNb2RhbCwgQXBwLCBTZXR0aW5nLCBNZW51LCBDb21wb25lbnQgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgTXlQbHVnaW4gZnJvbSBcIi4uL21haW5cIlxuaW1wb3J0IHsgTVNHX1BMR19OQU1FLCBURVhUX0RPTkUsIFZJRVdfVFlQRSB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBDYWxlbmRhckV2ZW50LCBDYWxlbmRhclNldHRpbmdzLCBJRXZlbnQsIElQYWdlLCBJU3Vic2NyaWJlciwgU3JjIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgQ2FsZW5kYXJFdmVudFRvSURhdGUsIGdldENvbG91ckZyb21QYXRoLCBJRGF0ZVRvQ2FsZW5kYXJFdmVudCwgbWlsbGlzZWNUb1N0cmluZywgcGFnZVRvRXZlbnRzLCB0ZW1wbGF0ZUlEVGljaywgdGVtcGxhdGVOYW1lVGljaywgdGltZUFkZCB9IGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IHsgcmVuZGVyQ2FsZW5kYXIgfSBmcm9tICdsaWIvb2JzaWRpYW4tZnVsbC1jYWxlbmRhci9jYWxlbmRhcic7XG5pbXBvcnQgeyBDYWxlbmRhciB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29yZSc7XG5pbXBvcnQgeyBDYWNoZSB9IGZyb20gJ3NyYy9jYWNoZSc7XG5pbXBvcnQgRmlsZU1hbmFnZXIgZnJvbSAnc3JjL2ZpbGVNYW5hZ2VyJztcblxuZXhwb3J0IGNsYXNzIENhbGVuZGFyVmlldyBleHRlbmRzIEl0ZW1WaWV3IGltcGxlbWVudHMgSVN1YnNjcmliZXIge1xuICAvLyBwcml2YXRlIHBhcnJlbnRQb2ludGVyOiBNeVBsdWdpblxuXG4gIHByaXZhdGUgY2FjaGU6IENhY2hlXG5cbiAgcHJpdmF0ZSBjYWxlbmRhcjogQ2FsZW5kYXIgfCBudWxsID0gbnVsbFxuXG4gIHByaXZhdGUgaWRGb3JDYWNoZTogbnVtYmVyXG5cbiAgcHJpdmF0ZSBldmVudF9zcmM6IFNyY1tdXG5cbiAgcHJpdmF0ZSBsb2NhbFN0b3JhZ2U6IE1hcDxzdHJpbmcsIElQYWdlW10+XG5cbiAgcHJpdmF0ZSBzZWxlY3RlZFNyY1BhdGhzOiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQoKVxuXG4gIHByaXZhdGUgZmlsZU1hbmFnZXI6IEZpbGVNYW5hZ2VyXG5cbiAgcHJpdmF0ZSBjYWxlbmRhclNldHRpbmdzOiBDYWxlbmRhclNldHRpbmdzXG5cbiAgLy8gcHJpdmF0ZSBzcmNDaGVja2JveENvbnRhaW5lcjogSFRNTEVsZW1lbnQgfCBudWxsID0gbnVsbFxuICBwcml2YXRlIHBsYWNlRm9yQ3JlYXRpbmdOb3RlOiBzdHJpbmdcblxuICBjb25zdHJ1Y3RvcihcbiAgICBsZWFmOiBXb3Jrc3BhY2VMZWFmLFxuICAgIGNhY2hlOiBDYWNoZSxcbiAgICBpZEZvckNhY2hlOiBudW1iZXIsXG4gICAgZXZlbnRfc3JjOiBTcmNbXSxcbiAgICBjYWxlbmRhclNldHRpbmdzOiBDYWxlbmRhclNldHRpbmdzLFxuICAgIGZpbGVNYW5hZ2VyOiBGaWxlTWFuYWdlcixcbiAgICBwbGFjZUZvckNyZWF0aW5nTm90ZTogc3RyaW5nLFxuICAgIC8vIHBhcnJlbnRQb2ludGVyOiBNeVBsdWdpbixcbiAgICAvLyBiYWNrR3JvdW5kRXZlbnRzOlxuICApIHtcbiAgICBzdXBlcihsZWFmKVxuXG4gICAgdGhpcy5jYWNoZSA9IGNhY2hlXG4gICAgdGhpcy5pZEZvckNhY2hlID0gaWRGb3JDYWNoZVxuICAgIHRoaXMuZXZlbnRfc3JjID0gZXZlbnRfc3JjXG4gICAgdGhpcy5maWxlTWFuYWdlciA9IGZpbGVNYW5hZ2VyXG4gICAgdGhpcy5jYWxlbmRhclNldHRpbmdzID0gY2FsZW5kYXJTZXR0aW5nc1xuICAgIHRoaXMucGxhY2VGb3JDcmVhdGluZ05vdGUgPSBwbGFjZUZvckNyZWF0aW5nTm90ZVxuXG4gICAgZm9yIChsZXQgc3JjIG9mIGV2ZW50X3NyYykge1xuICAgICAgdGhpcy5zZWxlY3RlZFNyY1BhdGhzLmFkZChzcmMucGF0aClcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0Vmlld1R5cGUoKSB7cmV0dXJuIFZJRVdfVFlQRX1cblxuICBwdWJsaWMgZ2V0RGlzcGxheVRleHQoKSB7cmV0dXJuIFwiQ2FsZW5kYXJcIn1cblxuICBwdWJsaWMgYXN5bmMgb25PcGVuKCkge1xuICAgIGlmIChQbGF0Zm9ybS5pc01vYmlsZSlcbiAgICAgIHRoaXMuY29udGFpbmVyRWwuc3R5bGUuaGVpZ2h0ID0gXCI5NXZoXCJcblxuICAgIGNvbnN0IHsgY29udGFpbmVyRWwgfSA9IHRoaXNcbiAgICBjb25zdCBjb250YWluZXIgPSBjb250YWluZXJFbC5jaGlsZHJlblsxXSAvLyBUT0RPIFx1MDQ0N1x1MDQ0Mlx1MDQzRSBcdTA0MzdcdTA0MzAgXHUwNDM0XHUwNDM1XHUwNDQyXHUwNDM4IChcdTA0NDdcdTA0NDJcdTA0M0UgXHUwNDMyIFx1MDQzNFx1MDQ0MFx1MDQ0M1x1MDQzM1x1MDQzOFx1MDQ0NSBcdTA0MzhcdTA0M0RcdTA0MzRcdTA0MzVcdTA0M0FcdTA0NDFcdTA0MzBcdTA0NDU/KVxuICAgIGNvbnRhaW5lci5lbXB0eSgpXG4gICAgY29uc3QgY2FsZW5kYXJDb250YWluZXIgPSBjb250YWluZXIuY3JlYXRlRGl2KC8qe2NsczogJ2NsYXNzJ30qLylcbiAgICBjb25zdCBjaGVja0JveENvbnRhaW5lciA9IGNvbnRhaW5lci5jcmVhdGVEaXYoLyp7Y2xzOiAnY2xhc3MnfSovKVxuXG4gICAgLy8gXHUwNDIxXHUwNDNFXHUwNDM3XHUwNDM0XHUwNDMwXHUwNDM1XHUwNDNDIFx1MDQzQVx1MDQzRVx1MDQzRFx1MDQ0Mlx1MDQzNVx1MDQzOVx1MDQzRFx1MDQzNVx1MDQ0MCBcdTA0MzRcdTA0M0JcdTA0NEYgXHUwNDQ3XHUwNDM1XHUwNDNBXHUwNDMxXHUwNDNFXHUwNDNBXHUwNDQxXHUwNDNFXHUwNDMyXG4gICAgLy8gdGhpcy5zcmNDaGVja2JveENvbnRhaW5lciA9IGNvbnRhaW5lci5jcmVhdGVEaXYoe2NsczogJ2NhbGVuZGFyLXNyYy1jaGVja2JveGVzJ30pXG5cbiAgICB0aGlzLnJlbmRlcihjYWxlbmRhckNvbnRhaW5lcilcbiAgICAudGhlbihcbiAgICAgICgpID0+IHRoaXMucmVuZGVyU3JjQ2hlY2tib3hlcyhjaGVja0JveENvbnRhaW5lcilcbiAgICApXG4gIH1cblxuICBwdWJsaWMgb25SZXNpemUoKSB7XG4gICAgdGhpcy5jYWxlbmRhcj8ucmVuZGVyKCk7XG4gIH1cblxuICBwdWJsaWMgYWRkRmlsZShwYWdlOiBTcmMpOiB2b2lkIHtcbiAgICAvLyBcdTA0MUZcdTA0NDBcdTA0M0VcdTA0MzJcdTA0MzVcdTA0NDBcdTA0NEZcdTA0MzVcdTA0M0MsIFx1MDQ0MVx1MDQzRVx1MDQzRVx1MDQ0Mlx1MDQzMlx1MDQzNVx1MDQ0Mlx1MDQ0MVx1MDQ0Mlx1MDQzMlx1MDQ0M1x1MDQzNVx1MDQ0MiBcdTA0M0JcdTA0MzggXHUwNDNGXHUwNDQzXHUwNDQyXHUwNDRDIFx1MDQ0MVx1MDQ0Mlx1MDQ0MFx1MDQzMFx1MDQzRFx1MDQzOFx1MDQ0Nlx1MDQ0QiBcdTA0MzJcdTA0NEJcdTA0MzFcdTA0NDBcdTA0MzBcdTA0M0RcdTA0M0RcdTA0NEJcdTA0M0MgXHUwNDM4XHUwNDQxXHUwNDQyXHUwNDNFXHUwNDQ3XHUwNDNEXHUwNDM4XHUwNDNBXHUwNDMwXHUwNDNDXG4gICAgaWYgKCF0aGlzLmlzUGFnZUluU2VsZWN0ZWRTcmMocGFnZS5maWxlLnBhdGgpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBldmVudHMgPSBwYWdlVG9FdmVudHMocGFnZSlcbiAgICBmb3IgKGxldCBldmVudCBvZiBldmVudHMpXG4gICAgICB0aGlzLmNhbGVuZGFyPy5hZGRFdmVudChldmVudClcbiAgfVxuXG4gIHB1YmxpYyBjaGFuZ2VGaWxlKG5ld1BhZ2U6IFNyYywgb2xkUGFnZTogU3JjKTogdm9pZCB7XG4gICAgdGhpcy5jYWxlbmRhcj8ucGF1c2VSZW5kZXJpbmcoKVxuICAgIHRoaXMuZGVsZXRlRmlsZShvbGRQYWdlKVxuICAgIHRoaXMuYWRkRmlsZShuZXdQYWdlKVxuICAgIHRoaXMuY2FsZW5kYXI/LnJlc3VtZVJlbmRlcmluZygpXG4gIH1cblxuICBwdWJsaWMgcmVuYW1lRmlsZShuZXdQYWdlOiBTcmMsIG9sZFBhZ2U6IFNyYyk6IHZvaWQge1xuICAgIHRoaXMuY2hhbmdlRmlsZShuZXdQYWdlLCBvbGRQYWdlKVxuICB9XG5cbiAgcHVibGljIGRlbGV0ZUZpbGUocGFnZTogU3JjKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmNhbGVuZGFyKVxuICAgICAgcmV0dXJuXG5cbiAgICB0aGlzLmNhbGVuZGFyLmdldEV2ZW50QnlJZChwYWdlLmZpbGUucGF0aCk/LnJlbW92ZSgpXG5cbiAgICBmb3IgKGxldCB0aWNrIG9mIHBhZ2UudGlja3MpIHtcbiAgICAgIHRoaXMuY2FsZW5kYXIuZ2V0RXZlbnRCeUlkKFxuICAgICAgICB0ZW1wbGF0ZUlEVGljayhwYWdlLmZpbGUucGF0aCwgdGljay5uYW1lKVxuICAgICAgKT8ucmVtb3ZlKClcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgcmVzZXQoKSB7XG4gICAgdGhpcy5vbnVubG9hZCgpXG4gICAgdGhpcy5vbk9wZW4oKVxuICB9XG5cbiAgb251bmxvYWQoKSB7XG4gICAgaWYgKCF0aGlzLmNhbGVuZGFyKVxuICAgICAgcmV0dXJuXG5cbiAgICB0aGlzLmNhbGVuZGFyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmNhbGVuZGFyID0gbnVsbDtcbiAgICB0aGlzLmNhY2hlLnVuc3Vic2NyaWJlKHRoaXMuaWRGb3JDYWNoZSlcbiAgfVxuXG4gIHByaXZhdGUgcmVuZGVyU3JjQ2hlY2tib3hlcyhzcmNDaGVja2JveENvbnRhaW5lcjogSFRNTEVsZW1lbnQpIHtcbiAgICBzcmNDaGVja2JveENvbnRhaW5lci5lbXB0eSgpXG4gICAgc3JjQ2hlY2tib3hDb250YWluZXIuYWRkQ2xhc3MoXCJjYWxlbmRhci1zcmMtY2hlY2tib3hlc1wiKVxuXG4gICAgZm9yIChsZXQgc3JjIG9mIHRoaXMuZXZlbnRfc3JjKSB7XG4gICAgICBjb25zdCBjaGVja2JveENvbnRhaW5lciA9IHNyY0NoZWNrYm94Q29udGFpbmVyIS5jcmVhdGVEaXYoe2NsczogJ3NyYy1jaGVja2JveC1pdGVtJ30pXG5cbiAgICAgIGNvbnN0IGNoZWNrYm94ID0gY2hlY2tib3hDb250YWluZXIuY3JlYXRlRWwoJ2lucHV0Jywge1xuICAgICAgICB0eXBlOiAnY2hlY2tib3gnLFxuICAgICAgICBhdHRyOiB7XG4gICAgICAgICAgaWQ6IGBzcmMtY2hlY2tib3gtJHtzcmMucGF0aH1gLFxuICAgICAgICAgIGNoZWNrZWQ6IHRoaXMuc2VsZWN0ZWRTcmNQYXRocy5oYXMoc3JjLnBhdGgpID8gJ2NoZWNrZWQnIDogbnVsbFxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICBjaGVja2JveC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgIGlmIChjaGVja2JveC5jaGVja2VkKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3RlZFNyY1BhdGhzLmFkZChzcmMucGF0aClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGVkU3JjUGF0aHMuZGVsZXRlKHNyYy5wYXRoKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVmcmVzaENhbGVuZGFyKClcbiAgICAgIH0pXG5cbiAgICAgIGNoZWNrYm94Q29udGFpbmVyLmNyZWF0ZUVsKCdsYWJlbCcsIHtcbiAgICAgICAgdGV4dDogc3JjLnBhdGgsXG4gICAgICAgIGF0dHI6IHtmb3I6IGBzcmMtY2hlY2tib3gtJHtzcmMucGF0aH1gfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGlzUGF0aEluU3JjKHBhZ2VQYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAvLyBUT0RPIFx1MDQzN1x1MDQzNFx1MDQzNVx1MDQ0MVx1MDQ0QyBcdTA0M0RcdTA0MzUgXHUwNDQzXHUwNDQ3XHUwNDM4XHUwNDQyXHUwNDRCXHUwNDMyXHUwNDMwXHUwNDRFXHUwNDQyXHUwNDQxXHUwNDRGIFx1MDQzOFx1MDQ0MVx1MDQzQVx1MDQzQlx1MDQ0RVx1MDQ0N1x1MDQzNVx1MDQzRFx1MDQzOFx1MDQ0RlxuICAgIGZvciAoY29uc3Qgc3JjUGF0aCBvZiB0aGlzLnNlbGVjdGVkU3JjUGF0aHMpIHtcbiAgICAgIGlmIChwYWdlUGF0aC5zdGFydHNXaXRoKHNyY1BhdGgpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyByZWZyZXNoQ2FsZW5kYXIoKSB7XG4gICAgaWYgKCF0aGlzLmNhbGVuZGFyKVxuICAgICAgcmV0dXJuXG5cbiAgICB0aGlzLmNhbGVuZGFyLnJlbW92ZUFsbEV2ZW50cygpXG5cbiAgICBjb25zdCBldmVudHM6IElFdmVudFtdID0gW11cbiAgICBmb3IgKGxldCBba2V5LCB2YWxdIG9mIHRoaXMubG9jYWxTdG9yYWdlKSB7XG4gICAgICBpZiAoICF0aGlzLmlzUGF0aEluU3JjKGtleSkgKVxuICAgICAgICBjb250aW51ZVxuXG4gICAgICBmb3IgKGxldCBwYWdlIG9mIHZhbClcbiAgICAgICAgZXZlbnRzLnB1c2goIC4uLnBhZ2VUb0V2ZW50cyhwYWdlKSApXG4gICAgfVxuXG4gICAgdGhpcy5jYWxlbmRhclxuICAgIGV2ZW50cy5mb3JFYWNoKGV2ZW50ID0+IHRoaXMuY2FsZW5kYXI/LmFkZEV2ZW50KGV2ZW50KSlcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgcmVuZGVyKGNvbnRhaW5lcjogRWxlbWVudCkgIHtcbiAgICB0aGlzLmxvY2FsU3RvcmFnZSA9IG5ldyBNYXBcblxuICAgIGNvbnN0IHN1YnNjcmliZWREYXRhID0gYXdhaXQgdGhpcy5jYWNoZS5zdWJzY3JpYmUodGhpcy5pZEZvckNhY2hlLCB0aGlzLmV2ZW50X3NyYywgdGhpcylcbiAgICBmb3IgKGxldCBkYXRhIG9mIHN1YnNjcmliZWREYXRhKSB7XG4gICAgICB0aGlzLmxvY2FsU3RvcmFnZS5zZXQoZGF0YS5zcmMucGF0aCwgZGF0YS5wYWdlcylcbiAgICB9XG5cbiAgICBjb25zdCBldmVudHM6IElFdmVudFtdID0gW11cbiAgICBmb3IgKGNvbnN0IGRhdGEgb2Ygc3Vic2NyaWJlZERhdGEpIHtcbiAgICAgIGlmICghdGhpcy5zZWxlY3RlZFNyY1BhdGhzLmhhcyhkYXRhLnNyYy5wYXRoKSlcbiAgICAgICAgY29udGludWVcblxuICAgICAgZm9yIChsZXQgcGFnZSBvZiBkYXRhLnBhZ2VzKSB7XG4gICAgICAgIGV2ZW50cy5wdXNoKCAuLi5wYWdlVG9FdmVudHMocGFnZSkgKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuY2FsZW5kYXIgPSByZW5kZXJDYWxlbmRhcihcbiAgICAgIGNvbnRhaW5lciBhcyBIVE1MRWxlbWVudCxcbiAgICAgIHtcbiAgICAgICAgLy9AdHMtaWdub3JlIC8vIFRPRE8gcmVtb3ZlXG4gICAgICAgIGV2ZW50czogW1xuICAgICAgICAgIC4uLnRoaXMuY2FsZW5kYXJTZXR0aW5ncy5yZXN0VGltZSxcbiAgICAgICAgICAuLi5ldmVudHNcbiAgICAgICAgXVxuICAgICAgfSwvLyBhcyBFdmVudFNvdXJjZSxcbiAgICAgICAgdGhpcy5nZXRTZXR0aW5nc0NhbGVuZGFyKCksXG4gICAgKVxuICAgIHRoaXMuY2FsZW5kYXIuc2V0T3B0aW9uKCd3ZWVrTnVtYmVycycsIHRydWUpXG5cbiAgICAvLyBOT1RFIHRvIGZpeCBidWcgZmlyc3QgcmVuZGVyXG4gICAgd2luZG93LnNldFRpbWVvdXQoXG4gICAgICAoXzogYW55KSA9PiB7XG4gICAgICAgIGlmIChQbGF0Zm9ybS5pc01vYmlsZSlcbiAgICAgICAgICB0aGlzLmNhbGVuZGFyPy5jaGFuZ2VWaWV3KCd0aW1lR3JpZDNEYXlzJylcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRoaXMuY2FsZW5kYXI/LmNoYW5nZVZpZXcoJ3RpbWVHcmlkV2VlaycpXG4gICAgICB9LCAxXG4gICAgKVxuICAgIHRoaXMuY2FsZW5kYXIucmVuZGVyKClcbiAgfVxuXG4gIHByaXZhdGUgZ2V0U2V0dGluZ3NDYWxlbmRhcigpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICBmaXJzdERheTogMSxcbiAgICAgIHdlZWtOdW1iZXJzOiB0cnVlLFxuICAgICAgdGltZUZvcm1hdDI0aDogdHJ1ZSxcblxuICAgICAgLy8gVE9ETyByZW1vdmUgYW55XG4gICAgICBldmVudENsaWNrOiAoYXJnOiBhbnkpID0+IHtcbiAgICAgICAgY29uc3Qge2V2ZW50LCBqc0V2ZW50fSA9IGFyZ1xuICAgICAgICB0aGlzLmZpbGVNYW5hZ2VyLm9wZW5Ob3RlKGV2ZW50KVxuICAgICAgfSxcblxuICAgICAgLy8gVE9ETyByZW1vdmUgYW55XG4gICAgICBtb2RpZnlFdmVudDogYXN5bmMgKG5ld1BvczogYW55LCBvbGRQb3M6IGFueSkgPT4ge1xuICAgICAgICBjb25zdCBwcm9wcyA9IG5ld1Bvcy5leHRlbmRlZFByb3BzXG5cbiAgICAgICAgY29uc3QgZXZlbnQ6IENhbGVuZGFyRXZlbnQgPSB7XG4gICAgICAgICAgc3RhcnQ6IG5ld1Bvcy5zdGFydCxcbiAgICAgICAgICBlbmQ6IG5ld1Bvcy5lbmQsXG4gICAgICAgICAgYWxsRGF5OiBuZXdQb3MuYWxsRGF5XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvcHMubm90ZVBhdGgpIHtcbiAgICAgICAgICBjb25zdCBwYWdlID0gdGhpcy5jYWNoZS5nZXRQYWdlKHByb3BzLm5vdGVQYXRoKVxuXG4gICAgICAgICAgaWYgKCFwYWdlKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7TVNHX1BMR19OQU1FfTogY2FuJ3QgZmluZCBwYWdlIGJ5IEV2ZW50LiBldmVudElEOiAke3Byb3BzLm5vdGVQYXRofWApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB0aWNrID0gcGFnZS50aWNrcy5maW5kKFxuICAgICAgICAgICAgZWwgPT4gZWwubmFtZSA9PSBwcm9wcy50aWNrTmFtZVxuICAgICAgICAgIClcbiAgICAgICAgICBpZiAoIXRpY2spIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHtNU0dfUExHX05BTUV9OiBjYW4ndCBmaW5kIHRpY2sgYnkgcGFnZS4gUGFnZSAtIHRpY2tOYW1lOiAke3Byb3BzLm5vdGVQYXRofSAtICR7cHJvcHMudGlja05hbWV9YClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aWNrLmZmX2R1cmF0aW9uICYmIG9sZFBvcy5hbGxEYXkgJiYgIW5ld1Bvcy5hbGxEYXkpIHtcbiAgICAgICAgICAgIGV2ZW50LmVuZCA9IHRpbWVBZGQobmV3UG9zLnN0YXJ0LCB0aWNrLmZmX2R1cmF0aW9uKVxuICAgICAgICAgICAgbmV3UG9zLnNldEVuZChldmVudC5lbmQpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgbmV3UHJvcCA9IENhbGVuZGFyRXZlbnRUb0lEYXRlKGV2ZW50KVxuICAgICAgICAgIGlmIChuZXdQb3MuYWxsRGF5KSB7XG4gICAgICAgICAgICBuZXdQcm9wWydmZl9kdXJhdGlvbiddID0gbWlsbGlzZWNUb1N0cmluZyhcbiAgICAgICAgICAgICAgdGljay5mZl9kdXJhdGlvbj8uYXMoXCJtaWxsaXNlY29uZHNcIilcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmZpbGVNYW5hZ2VyLmNoYW5nZVRpY2tGaWxlKHByb3BzLm5vdGVQYXRoLCBwcm9wcy50aWNrTmFtZSwgbmV3UHJvcClcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb25zdCBwYWdlID0gdGhpcy5jYWNoZS5nZXRQYWdlKG5ld1Bvcy5pZClcblxuICAgICAgICAgIGlmICghcGFnZSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGAke01TR19QTEdfTkFNRX06IGNhbid0IGZpbmQgcGFnZSBieSBFdmVudC4gZXZlbnRJRDogJHtuZXdQb3MuaWR9YClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwYWdlLmZmX2R1cmF0aW9uICYmIG9sZFBvcy5hbGxEYXkgJiYgIW5ld1Bvcy5hbGxEYXkpIHtcbiAgICAgICAgICAgIGV2ZW50LmVuZCA9IHRpbWVBZGQobmV3UG9zLnN0YXJ0LCBwYWdlLmZmX2R1cmF0aW9uKVxuICAgICAgICAgICAgbmV3UG9zLnNldEVuZChldmVudC5lbmQpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgbmV3UHJvcCA9IENhbGVuZGFyRXZlbnRUb0lEYXRlKGV2ZW50KVxuICAgICAgICAgIGlmIChuZXdQb3MuYWxsRGF5KSB7XG4gICAgICAgICAgICBuZXdQcm9wWydmZl9kdXJhdGlvbiddID0gbWlsbGlzZWNUb1N0cmluZyhcbiAgICAgICAgICAgICAgcGFnZS5mZl9kdXJhdGlvbj8uYXMoXCJtaWxsaXNlY29uZHNcIilcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmZpbGVNYW5hZ2VyLmNoYW5nZVByb3BlcnR5RmlsZShuZXdQb3MuaWQsIG5ld1Byb3ApXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSxcbiAgICAgIHNlbGVjdDogKHN0YXJ0OiBEYXRlLCBlbmQ6IERhdGUsIGFsbERheTogYm9vbGVhbiwgX192aWV3TW9kZTogYW55KSA9PiB7XG4gICAgICAgIG5ldyBuYW1lTW9kYWwoXG4gICAgICAgICAgdGhpcy5hcHAsXG4gICAgICAgICAgYXN5bmMgKG5hbWVPZkZpbGU6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKCFuYW1lT2ZGaWxlKVxuICAgICAgICAgICAgICAgIHRocm93IDFcblxuICAgICAgICAgICAgICBjb25zdCBwYXRoT2ZGaWxlID0gdGhpcy5wbGFjZUZvckNyZWF0aW5nTm90ZSArIGAvJHtuYW1lT2ZGaWxlfS5tZGBcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy5maWxlTWFuYWdlci5jcmVhdGVGaWxlKHBhdGhPZkZpbGUpXG5cbiAgICAgICAgICAgICAgc2V0VGltZW91dChcbiAgICAgICAgICAgICAgICAoKSA9PiB0aGlzLmZpbGVNYW5hZ2VyLmNoYW5nZVByb3BlcnR5RmlsZShcbiAgICAgICAgICAgICAgICAgIHBhdGhPZkZpbGUsXG4gICAgICAgICAgICAgICAgICBDYWxlbmRhckV2ZW50VG9JRGF0ZSh7c3RhcnQsIGVuZCwgYWxsRGF5fSlcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIDE1MDBcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKVxuICAgICAgICAgICAgICBuZXcgTm90aWNlKFwiSG0uLi4gZXJyb3IuLi5cIilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICkub3BlbigpXG4gICAgICB9LFxuICAgICAgb3BlbkNvbnRleHRNZW51Rm9yRXZlbnQ6IChlOiBJRXZlbnQsIG1vdXNlRXZlbnQ6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAgICAgdGhpcy5jb250ZXh0TWVudUZvckV2ZW50KGUsIG1vdXNlRXZlbnQpXG4gICAgICB9LFxuICAgICAgc2xvdER1cmF0aW9uOiB0aGlzLmNhbGVuZGFyU2V0dGluZ3Muc2xvdER1cmF0aW9uXG4gICAgfVxuXG4gICAgaWYgKFBsYXRmb3JtLmlzTW9iaWxlKSB7XG4gICAgICByZXN1bHQuZXZlbnRDbGljayA9IChhcmc6IGFueSkgPT4ge1xuICAgICAgICBjb25zdCB7ZXZlbnQsIGpzRXZlbnR9ID0gYXJnXG4gICAgICAgIHRoaXMuY29udGV4dE1lbnVGb3JFdmVudChldmVudCwganNFdmVudClcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5vcGVuQ29udGV4dE1lbnVGb3JFdmVudCA9IChfOklFdmVudCwgX186TW91c2VFdmVudCkgPT4ge31cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBwcml2YXRlIGNvbnRleHRNZW51Rm9yRXZlbnQoZXZlbnQ6IElFdmVudCwgbW91c2VFdmVudDogTW91c2VFdmVudCkge1xuICAgIGNvbnN0IG1lbnUgPSBuZXcgTWVudVxuXG4gICAgbWVudS5hZGRJdGVtKFxuICAgICAgKGl0ZW0pID0+IGl0ZW0uc2V0VGl0bGUoZXZlbnQuaWQpXG4gICAgICAgIC5vbkNsaWNrKGFzeW5jICgpID0+IHRoaXMuZmlsZU1hbmFnZXIub3Blbk5vdGUoZXZlbnQpKVxuICAgIClcblxuICAgIG1lbnUuc2hvd0F0TW91c2VFdmVudChtb3VzZUV2ZW50KVxuICB9XG59XG5cbmNsYXNzIG5hbWVNb2RhbCBleHRlbmRzIE1vZGFsIHtcbiAgcHJpdmF0ZSByZXN1bHQ6IHN0cmluZ1xuICBwcml2YXRlIG9uU3VibWl0OiBGdW5jdGlvblxuXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBvblN1Ym1pdDogRnVuY3Rpb24pIHtcbiAgICBzdXBlcihhcHApO1xuICAgIHRoaXMub25TdWJtaXQgPSBvblN1Ym1pdDtcbiAgfVxuXG4gIG9uT3BlbigpIHtcbiAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpc1xuXG4gICAgY29udGVudEVsLmNyZWF0ZUVsKFwiaDFcIiwgeyB0ZXh0OiBcIk5hbWUgb2YgdGFza1wiIH0pXG5cbiAgICBuZXcgU2V0dGluZyhjb250ZW50RWwpXG4gICAgLnNldE5hbWUoXCJOYW1lXCIpXG4gICAgLmFkZFRleHQoXG4gICAgICB0ZXh0ID0+IHRleHQub25DaGFuZ2UodmFsdWUgPT4gdGhpcy5yZXN1bHQgPSB2YWx1ZSlcbiAgICApXG5cbiAgICBuZXcgU2V0dGluZyhjb250ZW50RWwpXG4gICAgLmFkZEJ1dHRvbihcbiAgICAgIChidG4pID0+IGJ0bi5zZXRCdXR0b25UZXh0KFwiU3VibWl0XCIpXG4gICAgICAgIC5zZXRDdGEoKVxuICAgICAgICAub25DbGljaygoKSA9PiB7XG4gICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgIHRoaXMub25TdWJtaXQodGhpcy5yZXN1bHQpO1xuICAgICAgICB9KSk7XG4gIH1cblxuICBvbkNsb3NlKCkge1xuICAgIHRoaXMuY29udGVudEVsLmVtcHR5KCk7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBEVVJBVElPTl9UWVBFUyB9IGZyb20gXCJvYnNpZGlhbi1kYXRhdmlld1wiXG5cbmV4cG9ydCBjbGFzcyBTcmMge1xuICBjb25zdHJ1Y3RvcihwYXRoOnN0cmluZykge1xuICAgIHRoaXMuX3BhdGggPSBwYXRoXG4gIH1cblxuICBwdWJsaWMgYWRkRXhjbHVkZXMoZXhjbHVkZXM6IHN0cmluZ1tdKTogYm9vbGVhbiB7XG4gICAgLy8gVE9ETyBcdTA0M0ZcdTA0MzVcdTA0NDBcdTA0MzVcdTA0MzQgXHUwNDM0XHUwNDNFXHUwNDMxXHUwNDMwXHUwNDMyXHUwNDNCXHUwNDM1XHUwNDNEXHUwNDM4XHUwNDM1XHUwNDNDIFx1MDQzRlx1MDQ0MFx1MDQzRVx1MDQzMlx1MDQzNVx1MDQ0MFx1MDQ0Rlx1MDQ0Mlx1MDQ0QywgXHUwNDQ3XHUwNDQyXHUwNDNFIGV4Y2x1ZGUgXHUwNDMyXHUwNDNEXHUwNDQzXHUwNDQyXHUwNDQwXHUwNDM4IHBhdGhcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgcHJpdmF0ZSBfcGF0aDogc3RyaW5nXG5cbiAgZ2V0IHBhdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhdGhcbiAgfVxuXG4gIHByaXZhdGUgX2V4Y2x1ZGVzOiBzdHJpbmdbXVxuXG4gIGdldCBleGNsdWRlcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHN0cnVjdHVyZWRDbG9uZSh0aGlzLl9leGNsdWRlcylcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBDYWxlbmRhclNldHRpbmdzID0ge1xuICAgIHNsb3REdXJhdGlvbjogc3RyaW5nLFxuICAgIGNvbG91cnM6IHtcbiAgICAgIGZyZXF1ZW5jeTogc3RyaW5nLFxuICAgICAgZG9uZSAgICAgOiBzdHJpbmcsXG4gICAgICB0aWNrICAgICA6IHN0cmluZyxcbiAgICAgIGRlZmF1bHQgIDogc3RyaW5nLFxuICAgIH0sXG4gICAgcmVzdFRpbWU6IHtcbiAgICAgICAgc3RhcnRUaW1lOiBzdHJpbmcsXG4gICAgICAgIGVuZFRpbWU6IHN0cmluZyxcbiAgICAgICAgY29sb3I6IHN0cmluZyxcblxuICAgICAgICAvLyBUT0RPIHJlbW92ZSBhbnlcbiAgICAgICAgZGF5c09mV2VlazphbnksZGlzcGxheTphbnksXG4gICAgfVtdXG4gIH1cblxuZXhwb3J0IHR5cGUgUGx1Z2luU2V0dGluZ3MgPSB7XG4gIHN0YXR1c0NvcnJlY3Rvcjoge1xuICAgIGlzT246IGJvb2xlYW4sXG4gICAgc3RhcnRPblN0YXJ0VXA6IGJvb2xlYW5cbiAgfSxcbiAgY2FsZW5kYXI6IENhbGVuZGFyU2V0dGluZ3MsXG4gIHNvdXJjZToge1xuICAgIG5vdGVTb3VyY2VzOiBTcmNbXSxcblxuICAgIC8vIE5PVEUgZGVmYXVsdCBwYXRoIHdoZXJlIG5vdGUgd2lsbCBiZSBjcmVhdGVkXG4gICAgZGVmYXVsdENyZWF0ZVBhdGg6IHN0cmluZ1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSURhdGUge1xuICAvLyBUT0RPIGRhdGUgXHUwNDNDXHUwNDNFXHUwNDM2XHUwNDM1XHUwNDQyIFx1MDQzOCBcdTA0M0RcdTA0MzUgXHUwNDMxXHUwNDRCXHUwNDQyXHUwNDRDIChcdTA0NDFcdTA0M0MuIGZpbGVNYW5hZ2VyLnRzL2dldFBhZ2UpXG4gIGZmX2RhdGU6IERhdGVcbiAgZmZfdGltZVN0YXJ0OiBEVVJBVElPTl9UWVBFU1xuICBmZl9kdXJhdGlvbjogRFVSQVRJT05fVFlQRVNcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJVGljayBleHRlbmRzIElEYXRlIHtcbiAgbmFtZTogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVBhZ2UgZXh0ZW5kcyBJRGF0ZSB7XG4gIGZpbGU6IHtcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgbmFtZTogc3RyaW5nXG4gIH0sXG4gIHRpY2tzOiBJVGlja1tdXG4gIGZmX2ZyZXF1ZW5jeT86IHN0cmluZ1xuICBmZl9zdGF0dXM/OiBzdHJpbmdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJRXZlbnQge1xuICBzdGFydDogRGF0ZVxuICBlbmQ/OiBEYXRlXG4gIGlkOiBzdHJpbmdcbiAgdGl0bGU6IHN0cmluZ1xuICBhbGxEYXk6IGJvb2xlYW5cbiAgY29sb3I/OiBzdHJpbmdcbiAgYm9yZGVyQ29sb3I6IHN0cmluZ1xuICBlZGl0YWJsZTogYm9vbGVhblxuICBleHRlbmRlZFByb3BzPzoge1xuICAgIHRpY2tOYW1lOiBzdHJpbmdcbiAgICBub3RlUGF0aDogc3RyaW5nXG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDYWxlbmRhckV2ZW50IHtcbiAgc3RhcnQ6IERhdGVcbiAgYWxsRGF5OiBib29sZWFuXG4gIGVuZD86IERhdGVcbn1cblxuLy8gSU5GTyBcdTA0NERcdTA0NDJcdTA0M0UgXHUwNDM4XHUwNDNEXHUwNDQyXHUwNDM1XHUwNDQwXHUwNDQ0XHUwNDM1XHUwNDM5XHUwNDQxIFx1MDQzNFx1MDQzQlx1MDQ0RiBDYWNoZVxuLy8gVE9ETyBcdTA0M0ZcdTA0MzVcdTA0NDBcdTA0MzVcdTA0M0ZcdTA0MzhcdTA0NDFcdTA0MzBcdTA0NDJcdTA0NEMgXHUwNDQyXHUwNDM4XHUwNDNGXHUwNDRCXG5leHBvcnQgaW50ZXJmYWNlIElTdWJzY3JpYmVyIHtcbiAgcmVzZXQoKTogdm9pZFxuICBhZGRGaWxlKF86IFNyYyk6IHZvaWRcbiAgZGVsZXRlRmlsZShfOiBTcmMpOiB2b2lkXG4gIGNoYW5nZUZpbGUobmV3UGFnZTogU3JjLCBvbGRQYWdlOiBTcmMpOiB2b2lkXG4gIHJlbmFtZUZpbGUobmV3UGFnZTogU3JjLCBvbGRQYWdlOiBTcmMpOiB2b2lkXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVRhc2tzIHtcbiAgZG9uZTogbnVtYmVyLFxuICBhbGw6IG51bWJlclxufVxuIiwgImltcG9ydCB7IFBsdWdpblNldHRpbmdzLCBTcmMgfSBmcm9tIFwiLi90eXBlc1wiXG5cbmV4cG9ydCBjb25zdCBNU0dfUExHX05BTUUgPSBcIk15Q2FsZW5kYXJcIlxuXG5jb25zdCBFVkVOVF9TUkMgPSBcImRhdGFiYXNlc1wiXG5jb25zdCBQTEFDRV9GT1JfQ1JFQVRJTkdfTk9URSA9IFwiZGF0YWJhc2VzXCJcblxuY29uc3QgZGF5c09mV2VlayA9IFsgJzEnLCcyJywnMycsJzQnLCc1JywnNicsJzAnIF0gLy8gdGhlc2UgcmVjdXJyZW50IGV2ZW50cyBtb3ZlIHNlcGFyYXRlbHlcbmNvbnN0IGRpc3BsYXkgPSAnYmFja2dyb3VuZCdcbmV4cG9ydCBjb25zdCBDT0xPVVJfUkVTVCAgPSAnIzMwNUI2MCdcbmV4cG9ydCBjb25zdCBDT0xPVVJfU0xFRVAgPSAnI2NjMDAwMCdcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfU0VUVElOR1M6IFBsdWdpblNldHRpbmdzID0ge1xuICBzdGF0dXNDb3JyZWN0b3I6IHtcbiAgICBpc09uOiB0cnVlLFxuICAgIHN0YXJ0T25TdGFydFVwOiB0cnVlXG4gIH0sXG4gIGNhbGVuZGFyOiB7XG4gICAgc2xvdER1cmF0aW9uOiBcIjAwOjMwOjAwXCIsXG4gICAgY29sb3Vyczoge1xuICAgICAgZnJlcXVlbmN5OiBcIiM4QTE3MTdcIixcbiAgICAgIGRvbmUgICAgIDogXCIjMDA4RTA0XCIsXG4gICAgICB0aWNrICAgICA6IFwiIzQ1N0U3RVwiLFxuICAgICAgZGVmYXVsdCAgOiBcIiM1ZTNmYThcIixcbiAgICB9LFxuICAgIHJlc3RUaW1lOiBbXG4gICAgICB7ZGF5c09mV2VlayxkaXNwbGF5LFxuICAgICAgICAgIHN0YXJ0VGltZTogJzA6MDA6MDAnLFxuICAgICAgICAgIGVuZFRpbWU6ICc4OjAwOjAwJyxcbiAgICAgICAgICBjb2xvcjogQ09MT1VSX1NMRUVQLFxuICAgICAgfSxcbiAgICAgIHtkYXlzT2ZXZWVrLGRpc3BsYXksXG4gICAgICAgICAgc3RhcnRUaW1lOiAnMjQ6MDA6MDAnLFxuICAgICAgICAgIGVuZFRpbWU6ICcyNDowMDowMCcsXG4gICAgICAgICAgY29sb3I6IENPTE9VUl9TTEVFUCxcbiAgICAgIH0sXG4gICAgICB7ZGF5c09mV2VlayxkaXNwbGF5LFxuICAgICAgICAgIHN0YXJ0VGltZTogJzA6MDA6MDAnLFxuICAgICAgICAgIGVuZFRpbWU6ICc4OjMwOjAwJyxcbiAgICAgICAgICBjb2xvcjogQ09MT1VSX1JFU1QsXG4gICAgICB9LFxuICAgICAge2RheXNPZldlZWssZGlzcGxheSxcbiAgICAgICAgICBzdGFydFRpbWU6ICcyMzowMDowMCcsXG4gICAgICAgICAgZW5kVGltZTogJzI0OjAwOjAwJyxcbiAgICAgICAgICBjb2xvcjogQ09MT1VSX1JFU1QsXG4gICAgICB9XG4gICAgXVxuICB9LFxuICBzb3VyY2U6IHtcbiAgICBub3RlU291cmNlczogW25ldyBTcmMoRVZFTlRfU1JDKV0sXG5cbiAgICAvLyBOT1RFIGRlZmF1bHQgcGF0aCB3aGVyZSBub3RlIHdpbGwgYmUgY3JlYXRlZFxuICAgIGRlZmF1bHRDcmVhdGVQYXRoOiBQTEFDRV9GT1JfQ1JFQVRJTkdfTk9URVxuICB9XG5cbn1cblxuZXhwb3J0IGVudW0gQ0FDSEVfSUQge1xuICBDQUxFTkRBUiA9IDEsXG4gIFNUQVRVU19DT1JSRUNUT1IsXG4gIFRJQ0tfQ0hFQ0tFUlxufVxuXG5leHBvcnQgY29uc3QgVklFV19UWVBFID0gXCJteS1vYnNpZGlhbi1jYWxlbmRhci1wbHVnaW5cIlxuXG5cbi8vIFRPRE8gXHUwNDNGXHUwNDM1XHUwNDQwXHUwNDM1XHUwNDM0XHUwNDM1XHUwNDNCXHUwNDMwXHUwNDQyXHUwNDRDIFx1MDQzMiBURVhUID0ge0RPTkUuLi5CTE9DS0VEfVxuZXhwb3J0IGNvbnN0IFRFWFRfRE9ORSA9IFwiXHVEODNEXHVERkUyZG9uZVwiXG5leHBvcnQgY29uc3QgVEVYVF9JTl9QUk9HUkVTUyA9IFwiXHVEODNEXHVERDM1aW4gcHJvZ3Jlc3NcIlxuZXhwb3J0IGNvbnN0IFRFWFRfU09PTiA9IFwiXHVEODNEXHVERkUzc29vblwiXG5leHBvcnQgY29uc3QgVEVYVF9DSElMRF9JTl9QUk9HUkVTUyA9IFwiXHVEODNEXHVERkUxXHVEODNEXHVERkU2Y2hpbGQgaW4gcHJvZ3Jlc3NcIlxuZXhwb3J0IGNvbnN0IFRFWFRfQkxPQ0tFRCA9IFwiXHVEODNEXHVERkUxYmxvY2tlZFwiXG5cbmV4cG9ydCBjb25zdCBGT1JNQVRfREFZID0gJ2QnXG5leHBvcnQgY29uc3QgRk9STUFUX0hPVVIgPSAnaCdcbmV4cG9ydCBjb25zdCBGT1JNQVRfTUlOVVRFID0gJ20nXG5cbmV4cG9ydCBjb25zdCBCQUNLR1JPVU5EX0NPTE9VUiA9IHtcbiAgICBodWU6IHtcbiAgICAgICAgc2hpZnQ6IDAsXG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgbWF4OiAzNjBcbiAgICB9LFxuICAgIHNhdHVyYXRpb246IHtcbiAgICAgICAgc2hpZnQ6IDAsXG4gICAgICAgIG1pbjogNzAsXG4gICAgICAgIG1heDogOTBcbiAgICB9LFxuICAgIGxpZ2h0bmVzczoge1xuICAgICAgICBzaGlmdDogMCxcbiAgICAgICAgbWluOiAzMCxcbiAgICAgICAgbWF4OiA1MFxuICAgIH1cbn1cblxuXG5jb25zdCBNaWxsaXNlY3NJblNlY29uZCA9IDEwMDBcbmNvbnN0IFNlY3NJbk1pbnV0ZSA9IDYwXG5jb25zdCBNaW51dGVzSW5Ib3VyID0gNjBcbmV4cG9ydCBjb25zdCBIb3Vyc0luRGF5ID0gMjRcbmV4cG9ydCBjb25zdCBNaWxsaXNlY3NJbk1pbnV0ZSA9IE1pbGxpc2Vjc0luU2Vjb25kICogU2Vjc0luTWludXRlXG5leHBvcnQgY29uc3QgTWlsbGlzZWNzSW5Ib3VyID0gTWlsbGlzZWNzSW5NaW51dGUgKiBNaW51dGVzSW5Ib3VyXG5leHBvcnQgY29uc3QgTWlsbGlzZWNzSW5EYXkgPSBNaWxsaXNlY3NJbkhvdXIgKiBIb3Vyc0luRGF5XG4iLCAiaW1wb3J0IHsgSVBhZ2UsIElUaWNrLCBJRGF0ZSwgQ2FsZW5kYXJFdmVudCwgSVRhc2tzLCBJRXZlbnQgfSBmcm9tIFwiLi90eXBlc1wiO1xuaW1wb3J0IHsgRGF0YXZpZXdBcGkgfSBmcm9tIFwib2JzaWRpYW4tZGF0YXZpZXcvbGliL2FwaS9wbHVnaW4tYXBpXCJcbmltcG9ydCB7IGdldEFQSSB9IGZyb20gXCJvYnNpZGlhbi1kYXRhdmlld1wiXG5pbXBvcnQgeyBEVVJBVElPTl9UWVBFUyB9IGZyb20gXCJvYnNpZGlhbi1kYXRhdmlld1wiXG5cbmltcG9ydCB7XG4gIFRFWFRfRE9ORSxcbiAgTWlsbGlzZWNzSW5Ib3VyLFxuICBNaWxsaXNlY3NJbkRheSxcbiAgTWlsbGlzZWNzSW5NaW51dGUsXG4gIEZPUk1BVF9EQVksXG4gIEZPUk1BVF9IT1VSLFxuICBGT1JNQVRfTUlOVVRFLFxuICBCQUNLR1JPVU5EX0NPTE9VUixcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcbmltcG9ydCBNeVBsdWdpbiBmcm9tIFwiLi9tYWluXCI7XG5cbmNvbnN0IFNMRUVQX1RJTUUgPSAxMDAwIC8vIG1zXG5cbmV4cG9ydCBjb25zdCBkdiA9IGdldEFQSSgpIGFzIERhdGF2aWV3QXBpXG5cbmZ1bmN0aW9uIHBhdGhUb0ZpbGVXaXRob3V0RmlsZU5hbWUocGF0aDogc3RyaW5nKSB7XG4gIGNvbnN0IHBhdGhfc2VwYXJhdG9yID0gcGF0aC5sYXN0SW5kZXhPZihcIi9cIik7XG4gIGlmIChwYXRoX3NlcGFyYXRvciAhPT0gLTEpXG4gICAgcmV0dXJuIHBhdGguc2xpY2UoMCwgcGF0aF9zZXBhcmF0b3IpO1xuICByZXR1cm4gXCJcIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIElEYXRlVG9DYWxlbmRhckV2ZW50KGFyZ3M6IElEYXRlKTogQ2FsZW5kYXJFdmVudCB7XG4gIGNvbnN0IHN0cnVjdHVyZTogQ2FsZW5kYXJFdmVudCA9IHtcbiAgICBzdGFydDogbmV3IERhdGUoYXJncy5mZl9kYXRlKSxcbiAgICBhbGxEYXk6IGZhbHNlLFxuICB9XG5cbiAgaWYgKGFyZ3MuZmZfZHVyYXRpb24pIHtcbiAgICBzdHJ1Y3R1cmUuc3RhcnQuc2V0SG91cnMgIChhcmdzLmZmX3RpbWVTdGFydD8udmFsdWVzPy5ob3VycyAgIHx8IDApXG4gICAgc3RydWN0dXJlLnN0YXJ0LnNldE1pbnV0ZXMoYXJncy5mZl90aW1lU3RhcnQ/LnZhbHVlcz8ubWludXRlcyB8fCAwKVxuXG4gICAgbGV0IHRtcFRpbWUgPSBuZXcgRGF0ZShzdHJ1Y3R1cmUuc3RhcnQpXG4gICAgaWYgKGFyZ3MuZmZfZHVyYXRpb24/LnZhbHVlcz8ubWludXRlcyB8fCBhcmdzLmZmX2R1cmF0aW9uPy52YWx1ZXM/LmhvdXJzIHx8IGFyZ3MuZmZfZHVyYXRpb24/LnZhbHVlcz8uZGF5cykge1xuICAgICAgY29uc3QgZHVyYXRpb24gPSBhcmdzLmZmX2R1cmF0aW9uLnZhbHVlc1xuXG4gICAgICB0bXBUaW1lLnNldE1pbnV0ZXMoXG4gICAgICAgIHRtcFRpbWUuZ2V0TWludXRlcygpICsgKGR1cmF0aW9uLm1pbnV0ZXMgfHwgMClcbiAgICAgIClcbiAgICAgIHRtcFRpbWUuc2V0SG91cnMoXG4gICAgICAgIHRtcFRpbWUuZ2V0SG91cnMoKSArIChkdXJhdGlvbi5ob3VycyB8fCAwKVxuICAgICAgKVxuICAgICAgdG1wVGltZS5zZXREYXRlKFxuICAgICAgICB0bXBUaW1lLmdldERhdGUoKSArIChkdXJhdGlvbi5kYXlzIHx8IDApXG4gICAgICApXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc3RydWN0dXJlLmFsbERheSA9IHRydWVcbiAgICB9XG5cbiAgICBpZiAoIWFyZ3MuZmZfdGltZVN0YXJ0Py52YWx1ZXMpXG4gICAgICBzdHJ1Y3R1cmUuYWxsRGF5ID0gdHJ1ZVxuXG4gICAgc3RydWN0dXJlLmVuZCA9IHRtcFRpbWVcbiAgfVxuICBlbHNlIGlmIChhcmdzLmZmX2R1cmF0aW9uKSB7XG4gICAgc3RydWN0dXJlLmFsbERheSA9IHRydWVcbiAgfVxuICBlbHNlIHN0cnVjdHVyZS5hbGxEYXkgPSB0cnVlXG5cbiAgcmV0dXJuIHN0cnVjdHVyZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gQ2FsZW5kYXJFdmVudFRvSURhdGUoZXZlbnQ6IENhbGVuZGFyRXZlbnQpOiBJRGF0ZSB7XG4gIGNvbnN0IHtzdGFydCwgZW5kLCBhbGxEYXl9ID0gZXZlbnRcbiAgLy8gISBcdTA0MzRcdTA0M0JcdTA0NEYgSVNPIChcdTA0M0VcdTA0M0QgXHUwNDNGXHUwNDM1XHUwNDQwXHUwNDM1XHUwNDMyXHUwNDNFXHUwNDM0XHUwNDM4XHUwNDQyIFx1MDQzMiBcdTA0MzNcdTA0NDBcdTA0MzhcdTA0M0RcdTA0MzJcdTA0MzhcdTA0NDcgXHUwNDNDXHUwNDNFXHUwNDM1IFx1MDQzMlx1MDQ0MFx1MDQzNVx1MDQzQ1x1MDQ0RilcbiAgLy8gXHUwNDRGIFx1MDQ0Mlx1MDQ0M1x1MDQ0MiBcdTA0MzNcdTA0M0VcdTA0MzJcdTA0M0VcdTA0NDBcdTA0NEUsIFx1MDQ0N1x1MDQ0Mlx1MDQzRSBcdTA0NEYgXHUwNDMyIFx1MDQzM1x1MDQ0MFx1MDQzOFx1MDQzRFx1MDQzMlx1MDQzOFx1MDQ0N1x1MDQzNVxuICBzdGFydC5zZXRNaW51dGVzKFxuICAgIHN0YXJ0LmdldE1pbnV0ZXMoKSAtIHN0YXJ0LmdldFRpbWV6b25lT2Zmc2V0KClcbiAgKVxuXG4gIGNvbnN0IHJlc3VsdDogSURhdGUgPSB7XG4gICAgZmZfZHVyYXRpb246IFwiXCIsXG4gICAgZmZfdGltZVN0YXJ0OiBcIlwiLFxuICAgIGZmX2RhdGU6IG5ldyBEYXRlKHN0YXJ0KVxuICB9XG5cbiAgLy8gISBcdTA0NDJcdTA0NDNcdTA0NDIgXHUwNDQzXHUwNDMxXHUwNDM4XHUwNDQwXHUwNDMwXHUwNDRFIFx1MDQzM1x1MDQ0MFx1MDQzOFx1MDQzRFx1MDQzMlx1MDQzOFx1MDQ0NyBcdTA0MzRcdTA0M0JcdTA0NEYgZ2V0J1x1MDQzNVx1MDQ0MFx1MDQzRVx1MDQzMiBcdTA0MzJcdTA0M0RcdTA0MzhcdTA0MzdcdTA0NDNcbiAgc3RhcnQuc2V0TWludXRlcyhcbiAgICBzdGFydC5nZXRNaW51dGVzKCkgKyBzdGFydC5nZXRUaW1lem9uZU9mZnNldCgpXG4gIClcblxuICBsZXQgc3JjTWlsbGlzZWMgPSBlbmRcbiAgLy8gQHRzLWlnbm9yZVxuICA/IGVuZCAtIHN0YXJ0XG4gIDogTWlsbGlzZWNzSW5Ib3VyXG5cbiAgaWYgKGFsbERheSkge1xuICAgIHJlc3VsdFsnZmZfdGltZVN0YXJ0J10gPSBcIlwiXG4gICAgaWYgKHNyY01pbGxpc2VjIDw9IE1pbGxpc2Vjc0luRGF5KVxuICAgICAgc3JjTWlsbGlzZWMgPSAwXG4gIH1cbiAgZWxzZVxuICAgIHJlc3VsdFsnZmZfdGltZVN0YXJ0J10gPSBzdGFydC5nZXRIb3VycygpICsgJ2gnICsgc3RhcnQuZ2V0TWludXRlcygpICsgJ20nXG5cbiAgcmVzdWx0WydmZl9kdXJhdGlvbiddID0gbWlsbGlzZWNUb1N0cmluZyhzcmNNaWxsaXNlYylcblxuICByZXR1cm4gcmVzdWx0XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUaWNrc0Zyb21UZXh0KHRleHQ6IHN0cmluZyk6IElUaWNrW10ge1xuICBjb25zdCByZXN1bHQgPSBbXVxuICBjb25zdCByZWdFeHBUaWNrcyA9IC9cXFt0OjouK1xcXS9nbVxuICBjb25zdCBtYXRjaGVzID0gdGV4dC5tYXRjaChyZWdFeHBUaWNrcylcblxuICBpZiAobWF0Y2hlcykgZm9yIChsZXQgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgIGNvbnN0IGFyZ3MgPSBtYXRjaC5zbGljZSgxLCAtMSkuc3BsaXQoXCI6OlwiKVsxXS5zcGxpdCgnLCcpXG4gICAgaWYgKCFhcmdzKVxuICAgICAgY29udGludWVcblxuICAgIGNvbnN0IG5hbWUgPSBhcmdzWzBdPy50cmltKClcbiAgICBjb25zdCBmZl9kYXRlID0gZHYuZGF0ZShhcmdzWzFdPy50cmltKCkpXG4gICAgY29uc3QgZmZfdGltZVN0YXJ0ID0gZHYuZHVyYXRpb24oYXJnc1syXT8udHJpbSgpKVxuXG4gICAgY29uc3QgdGVtcER1cmF0aW9uID0gYXJnc1szXT8udHJpbSgpXG4gICAgY29uc3QgZmZfZHVyYXRpb24gPSB0ZW1wRHVyYXRpb24gPT0gJ3gnXG4gICAgPyAneCdcbiAgICA6IGR2LmR1cmF0aW9uKGFyZ3NbM10/LnRyaW0oKSlcblxuICAgIGlmIChuYW1lID09ICcnKVxuICAgICAgY29udGludWVcblxuICAgIHJlc3VsdC5wdXNoKFxuICAgICAge25hbWUsIGZmX2RhdGUsIGZmX3RpbWVTdGFydCwgZmZfZHVyYXRpb259XG4gICAgKVxuXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWlsbGlzZWNUb1N0cmluZyhtaWxsaXNlYzpudW1iZXIpOiBzdHJpbmcge1xuICBjb25zdCBkYXlzID0gTWF0aC5mbG9vcihcbiAgICAgIG1pbGxpc2VjIC8gKE1pbGxpc2Vjc0luRGF5KVxuICApXG4gIG1pbGxpc2VjIC09IGRheXMgKiBNaWxsaXNlY3NJbkRheVxuXG4gIGNvbnN0IGhvdXJzID0gTWF0aC5mbG9vcihcbiAgICAgIG1pbGxpc2VjIC8gKE1pbGxpc2Vjc0luSG91cilcbiAgKVxuICBtaWxsaXNlYyAtPSBob3VycyAqIE1pbGxpc2Vjc0luSG91clxuXG4gIGNvbnN0IG1pbnV0ZXMgPSBNYXRoLmZsb29yKFxuICAgICAgbWlsbGlzZWMgLyAoTWlsbGlzZWNzSW5NaW51dGUpXG4gIClcbiAgbWlsbGlzZWMgLT0gbWludXRlcyAqIE1pbGxpc2Vjc0luTWludXRlXG5cbiAgbGV0IHJlc1N0cmluZyA9ICcnXG4gIGlmIChkYXlzKVxuICAgIHJlc1N0cmluZyArPSBkYXlzLnRvU3RyaW5nKCkgKyBGT1JNQVRfREFZXG4gIGlmIChob3VycylcbiAgICByZXNTdHJpbmcgKz0gaG91cnMudG9TdHJpbmcoKSArIEZPUk1BVF9IT1VSXG4gIGlmIChtaW51dGVzKVxuICAgIHJlc1N0cmluZyArPSBtaW51dGVzLnRvU3RyaW5nKCkgKyBGT1JNQVRfTUlOVVRFXG5cbiAgcmV0dXJuIHJlc1N0cmluZ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNFcXVhbE9iaihvYmplY3QxOmFueSwgb2JqZWN0MjphbnkpIHtcbiAgY29uc3Qga2V5czEgPSBPYmplY3Qua2V5cyhvYmplY3QxKTtcbiAgY29uc3Qga2V5czIgPSBPYmplY3Qua2V5cyhvYmplY3QyKTtcblxuICBpZiAoa2V5czEubGVuZ3RoICE9PSBrZXlzMi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzMSkge1xuICAgIGNvbnN0IHZhbDEgPSBvYmplY3QxW2tleV07XG4gICAgY29uc3QgdmFsMiA9IG9iamVjdDJba2V5XTtcbiAgICBjb25zdCBhcmVPYmplY3RzID0gaXNPYmplY3QodmFsMSkgJiYgaXNPYmplY3QodmFsMik7XG4gICAgaWYgKFxuICAgICAgYXJlT2JqZWN0cyAmJiAhaXNFcXVhbE9iaih2YWwxLCB2YWwyKSB8fFxuICAgICAgIWFyZU9iamVjdHMgJiYgdmFsMSAhPT0gdmFsMlxuICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChvYmplY3Q6IGFueSkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCc7XG59XG5cbi8vIFx1MDQzQVx1MDQzMFx1MDQzQVx1MDQzOFx1MDQzQyBcdTA0MzFcdTA0NDNcdTA0MzRcdTA0MzVcdTA0NDIgSUQgXHUwNDMyIFx1MDQzQVx1MDQzMFx1MDQzQlx1MDQzNVx1MDQzRFx1MDQzNFx1MDQzMFx1MDQ0MFx1MDQzNSBcdTA0NDJcdTA0MzhcdTA0M0FcbmV4cG9ydCBmdW5jdGlvbiB0ZW1wbGF0ZUlEVGljayhwYXRoOiBzdHJpbmcsIHRpY2tOYW1lOnN0cmluZykge1xuICByZXR1cm4gcGF0aCArIHRpY2tOYW1lXG59XG5cbi8vIFx1MDQzQVx1MDQzMFx1MDQzQSBcdTA0MzFcdTA0NDNcdTA0MzRcdTA0MzVcdTA0NDIgXHUwNDNFXHUwNDQyXHUwNDNFXHUwNDMxXHUwNDQwXHUwNDMwXHUwNDM2XHUwNDMwXHUwNDQyXHUwNDRDXHUwNDQxXHUwNDRGIFx1MDQzMiBcdTA0M0FcdTA0MzBcdTA0M0JcdTA0MzVcdTA0M0RcdTA0MzRcdTA0MzBcdTA0NDBcdTA0MzUgXHUwNDQyXHUwNDM4XHUwNDNBXG5leHBvcnQgZnVuY3Rpb24gdGVtcGxhdGVOYW1lVGljayhmaWxlTmFtZTogc3RyaW5nLCB0aWNrTmFtZTpzdHJpbmcpIHtcbiAgcmV0dXJuIFwiKFwiK2ZpbGVOYW1lK1wiKVwiICsgdGlja05hbWVcbn1cblxuZnVuY3Rpb24gaGFzaFN0cmluZyhzdHI6IHN0cmluZykge1xuICBsZXQgaGFzaCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgaGFzaCA9IChoYXNoIDw8IDUpIC0gaGFzaCArIHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gIH1cbiAgcmV0dXJuIGhhc2g7XG59XG5cbi8vIFRPRE8gXHUwNDNEXHUwNDM1IFx1MDQ0MFx1MDQzMFx1MDQzMVx1MDQzRVx1MDQ0Mlx1MDQzMFx1MDQzNVx1MDQ0MiBcdTA0M0RcdTA0MzAgXHUwNDNFXHUwNDQyXHUwNDQwXHUwNDM4XHUwNDQ2XHUwNDMwXHUwNDQyXHUwNDM1XHUwNDNCXHUwNDRDXHUwNDNEXHUwNDRCXHUwNDQ1IFx1MDQ0N1x1MDQzOFx1MDQ0MVx1MDQzQlx1MDQzMFx1MDQ0NVxuLy8gXHUwNDM4IFx1MDQzRlx1MDQ0MFx1MDQzOCBtaW4gPiBtYXhcbmZ1bmN0aW9uIHRvUmFuZ2Uoc3JjOiBudW1iZXIsIG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcikge1xuICBtYXggLT0gbWluXG4gIHNyYyAlPSBtYXgrMVxuXG4gIHJldHVybiAoc3JjICsgbWluKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29sb3VyRnJvbVBhdGgocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3Qgc3RyID0gcGF0aFRvRmlsZVdpdGhvdXRGaWxlTmFtZShwYXRoKVxuXG4gIC8vIE5PVEUgXHUwNDQyXHUwNDM4XHUwNDNGXHUwNDMwIFx1MDQzQVx1MDQzMFx1MDQzNlx1MDQzNFx1MDQ0Qlx1MDQzOSBcdTA0M0ZcdTA0MzVcdTA0NDBcdTA0MzJcdTA0NEJcdTA0MzksIFx1MDQzMlx1MDQ0Mlx1MDQzRVx1MDQ0MFx1MDQzRVx1MDQzOSBcdTA0MzhcdTA0M0JcdTA0MzggXHUwNDQyXHUwNDQwXHUwNDM1XHUwNDQyXHUwNDM4XHUwNDM5IFx1MDQ0MVx1MDQzOFx1MDQzQ1x1MDQzMlx1MDQzRVx1MDQzQiBcdTA0NDFcdTA0NDJcdTA0NDBcdTA0M0VcdTA0M0FcdTA0MzhcbiAgY29uc3Qgc3RyMSA9IGhhc2hTdHJpbmcoWy4uLnN0cl0uZmlsdGVyKChfLCBpbmRleCkgPT4gKGluZGV4ICsgMSkgJSAzICE9PSAwKS5qb2luKFwiXCIpKVxuICBjb25zdCBzdHIyID0gaGFzaFN0cmluZyhbLi4uc3RyXS5maWx0ZXIoKF8sIGluZGV4KSA9PiAoaW5kZXggKyAyKSAlIDMgIT09IDApLmpvaW4oXCJcIikpXG4gIGNvbnN0IHN0cjMgPSBoYXNoU3RyaW5nKFsuLi5zdHJdLmZpbHRlcigoXywgaW5kZXgpID0+IChpbmRleCArIDMpICUgMyAhPT0gMCkuam9pbihcIlwiKSlcblxuICBjb25zdCBodWUgPSB0b1JhbmdlKHN0cjEgKyBCQUNLR1JPVU5EX0NPTE9VUi5odWUuc2hpZnQsXG4gICAgQkFDS0dST1VORF9DT0xPVVIuaHVlLm1pbixcbiAgICBCQUNLR1JPVU5EX0NPTE9VUi5odWUubWF4XG4gIClcbiAgY29uc3Qgc2F0dXJhdGlvbiA9IHRvUmFuZ2Uoc3RyMiArIEJBQ0tHUk9VTkRfQ09MT1VSLnNhdHVyYXRpb24uc2hpZnQsXG4gICAgQkFDS0dST1VORF9DT0xPVVIuc2F0dXJhdGlvbi5taW4sXG4gICAgQkFDS0dST1VORF9DT0xPVVIuc2F0dXJhdGlvbi5tYXgpXG4gIGNvbnN0IGxpZ2h0bmVzcyAgPSB0b1JhbmdlKHN0cjMgKyBCQUNLR1JPVU5EX0NPTE9VUi5saWdodG5lc3Muc2hpZnQsXG4gICAgQkFDS0dST1VORF9DT0xPVVIubGlnaHRuZXNzLm1pbixcbiAgICBCQUNLR1JPVU5EX0NPTE9VUi5saWdodG5lc3MubWF4XG4gIClcbiAgcmV0dXJuIGBoc2woJHtodWV9LCAke3NhdHVyYXRpb259JSwgJHtsaWdodG5lc3N9JSlgXG59XG5cbmFzeW5jIGZ1bmN0aW9uIHdhaXREdkluaXQoKSB7XG4gIHdoaWxlICghZHYuaW5kZXguaW5pdGlhbGl6ZWQpXG4gICAgYXdhaXQgc2xlZXAoU0xFRVBfVElNRSlcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE5vdGVzV2l0aG91dFBhcmVudChzcmM6IHN0cmluZyk6IFByb21pc2U8SVBhZ2VbXT4ge1xuICBhd2FpdCB3YWl0RHZJbml0KClcblxuICBjb25zdCBjaGlsZCA9IGR2LnBhZ2VzKGBcIiR7c3JjfVwiYCkud2hlcmUoXG4gICAgKHBhZ2U6IGFueSkgPT4gIXBhZ2UuZmZfcGFyZW50XG4gICkuYXJyYXkoKVxuXG4gIHJldHVybiBjaGlsZCBhcyBJUGFnZVtdXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQcm9ncmVzcyhwbGc6IE15UGx1Z2luLCBwYWdlOiBJUGFnZSk6IFByb21pc2U8SVRhc2tzPiB7XG4gIGNvbnN0IHJlc3VsdCA9IHtkb25lOjAsIGFsbDowfVxuICBjb25zdCBjYWNoZSA9IHBsZy5jYWNoZVxuICBjb25zdCBmaWxlTWFuYWdlciA9IHBsZy5maWxlTWFuYWdlclxuXG4gIGF3YWl0IHdhaXREdkluaXQoKVxuXG4gIGNvbnN0IHBhZ2VzID0gbmV3IFNldCgpXG4gIGNvbnN0IHN0YWNrID0gW3BhZ2UuZmlsZS5wYXRoXVxuICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IHBhdGggPSBzdGFjay5wb3AoKSBhcyBzdHJpbmdcbiAgICBjb25zdCBwYWdlID0gY2FjaGUuZ2V0UGFnZShwYXRoKVxuICAgIGNvbnN0IG1ldGEgPSBkdi5wYWdlKHBhdGgpXG5cbiAgICBpZiAoIXBhZ2UgfHwgIW1ldGEpXG4gICAgICBjb250aW51ZVxuXG4gICAgY29uc3QgdGFza3MgPSBmaWxlTWFuYWdlci5nZXRUYXNrQ291bnQocGFnZSlcblxuICAgIHJlc3VsdC5hbGwgICs9ICB0YXNrcy5hbGxcbiAgICByZXN1bHQuZG9uZSAgKz0gIHRhc2tzLmRvbmVcblxuXG4gICAgY29uc3QgaW5saW5rcyA9IG1ldGEuZmlsZS5pbmxpbmtzLmFycmF5KClcbiAgICAvLyBpZiAoaW5saW5rcy5sZW5ndGggPT0gMCkge1xuICAgIGlmIChwYWdlLmZmX3N0YXR1cykge1xuICAgICAgKytyZXN1bHQuYWxsXG5cbiAgICAgIGlmIChwYWdlLmZmX3N0YXR1cyA9PSBURVhUX0RPTkUpXG4gICAgICAgICsrcmVzdWx0LmRvbmVcbiAgICB9XG4gICAgLy8gfVxuXG4gICAgZm9yIChsZXQgaW5saW5rIG9mIGlubGlua3MgKSB7XG4gICAgICBpZiAocGFnZXMuaGFzKGlubGluay5wYXRoKSlcbiAgICAgICAgY29udGludWVcblxuICAgICAgcGFnZXMuYWRkKGlubGluay5wYXRoKVxuICAgICAgc3RhY2sucHVzaChpbmxpbmsucGF0aClcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDaGlsZE5vdGVQYXRocyhwYXRoOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gIGF3YWl0IHdhaXREdkluaXQoKVxuXG4gIGNvbnN0IG1ldGEgPSBkdi5wYWdlKHBhdGgpXG4gIGNvbnN0IGlubGlua3MgPSBtZXRhPy5maWxlLmlubGlua3MuYXJyYXkoKVxuXG4gIGNvbnN0IHJlc3VsdDogc3RyaW5nW10gPSBbXVxuICBmb3IgKGxldCBpbmxpbmsgb2YgaW5saW5rcykge1xuICAgIHJlc3VsdC5wdXNoKCBpbmxpbmsucGF0aCApXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQYXJlbnROb3RlKHBhZ2U6IElQYWdlKTogUHJvbWlzZTwoSVBhZ2V8dW5kZWZpbmVkKVtdPiB7XG4gIGF3YWl0IHdhaXREdkluaXQoKVxuXG4gIGNvbnN0IG1ldGEgPSBkdi5wYWdlKHBhZ2UuZmlsZS5wYXRoKVxuICBjb25zdCBvdXRsaW5rcyA9IG1ldGE/LmZpbGUub3V0bGlua3MuYXJyYXkoKVxuXG4gIGNvbnN0IHJlc3VsdDogSVBhZ2VbXSA9IFtdXG4gIGZvciAobGV0IG91dGxpbmsgb2Ygb3V0bGlua3MpIHtcbiAgICByZXN1bHQucHVzaCggZHYucGFnZShvdXRsaW5rLnBhdGgpIGFzIElQYWdlIClcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNhZmVQYXJzZUludChzdHI6IHN0cmluZyk6IG51bWJlciB7XG4gIGNvbnN0IG51bSA9IE51bWJlcihzdHIpO1xuICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcihudW0pID8gbnVtIDogTmFOO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGltZUFkZChzdGFydDogRGF0ZSwgZHVyYXRpb246IERVUkFUSU9OX1RZUEVTKTogRGF0ZSB7XG4gIGNvbnN0IGR1ciA9IGR1cmF0aW9uLmFzKFwibWludXRlc1wiKVxuXG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBEYXRlKHN0YXJ0KVxuICByZXN1bHQuc2V0TWludXRlcyhyZXN1bHQuZ2V0TWludXRlcygpICsgZHVyKVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhZ2VUb0V2ZW50cyhwYWdlOiBJUGFnZSk6IElFdmVudFtdIHtcbiAgY29uc3QgcmVzdWx0OiBJRXZlbnRbXSA9IFtdXG5cbiAgY29uc3QgY29sb3VycyA9IHRoaXMuY2FsZW5kYXJTZXR0aW5ncy5jb2xvdXJzXG5cbiAgY29uc3Qgc3RydWN0dXJlVGVtcGxhdGUgPSB7XG4gICAgaWQ6IFwiXCIsXG4gICAgdGl0bGU6IFwiXCIsXG4gICAgYm9yZGVyQ29sb3I6IGNvbG91cnMuZGVmYXVsdCxcbiAgICBjb2xvcjogZ2V0Q29sb3VyRnJvbVBhdGgocGFnZS5maWxlLnBhdGgpLFxuICAgIGVkaXRhYmxlOiB0cnVlLFxuICB9XG5cbiAgaWYgKHBhZ2UuZmZfZGF0ZSkge1xuICAgIGNvbnN0IHN0cnVjdHVyZTogSUV2ZW50ID0ge1xuICAgICAgLi4uc3RydWN0dXJlVGVtcGxhdGUsXG4gICAgICBpZDogcGFnZS5maWxlLnBhdGgsXG4gICAgICB0aXRsZTogcGFnZS5maWxlLm5hbWUsXG4gICAgICAuLi5JRGF0ZVRvQ2FsZW5kYXJFdmVudChwYWdlKVxuICAgIH1cbiAgICBpZiAocGFnZS5mZl9mcmVxdWVuY3kpXG4gICAgICBzdHJ1Y3R1cmUuYm9yZGVyQ29sb3IgPSBjb2xvdXJzLmZyZXF1ZW5jeVxuICAgIGlmIChwYWdlLmZmX3N0YXR1cyA9PSBURVhUX0RPTkUpXG4gICAgICBzdHJ1Y3R1cmUuYm9yZGVyQ29sb3IgPSBjb2xvdXJzLmRvbmVcblxuICAgIHJlc3VsdC5wdXNoKHN0cnVjdHVyZSlcbiAgfVxuICBmb3IgKGxldCB0aWNrIG9mIHBhZ2UudGlja3MpIHtcbiAgICBjb25zdCBzdHJ1Y3R1cmU6IElFdmVudCA9IHtcbiAgICAgIC4uLnN0cnVjdHVyZVRlbXBsYXRlLFxuICAgICAgaWQ6IHRlbXBsYXRlSURUaWNrKHBhZ2UuZmlsZS5wYXRoLCB0aWNrLm5hbWUpLFxuICAgICAgdGl0bGU6IHRlbXBsYXRlTmFtZVRpY2socGFnZS5maWxlLm5hbWUsIHRpY2submFtZSksXG4gICAgICBib3JkZXJDb2xvcjogY29sb3Vycy50aWNrLFxuICAgICAgZXh0ZW5kZWRQcm9wczoge1xuICAgICAgICB0aWNrTmFtZTogdGljay5uYW1lLFxuICAgICAgICBub3RlUGF0aDogcGFnZS5maWxlLnBhdGhcbiAgICAgIH0sXG4gICAgICAuLi5JRGF0ZVRvQ2FsZW5kYXJFdmVudCh0aWNrKVxuICAgIH1cbiAgICByZXN1bHQucHVzaChzdHJ1Y3R1cmUpXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG4iLCAiaW1wb3J0IHsgRU1QVFlfQVJSIH0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XG5cbi8qKlxuICogQXNzaWduIHByb3BlcnRpZXMgZnJvbSBgcHJvcHNgIHRvIGBvYmpgXG4gKiBAdGVtcGxhdGUgTywgUCBUaGUgb2JqIGFuZCBwcm9wcyB0eXBlc1xuICogQHBhcmFtIHtPfSBvYmogVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG9cbiAqIEBwYXJhbSB7UH0gcHJvcHMgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbVxuICogQHJldHVybnMge08gJiBQfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKG9iaiwgcHJvcHMpIHtcblx0Ly8gQHRzLWlnbm9yZSBXZSBjaGFuZ2UgdGhlIHR5cGUgb2YgYG9iamAgdG8gYmUgYE8gJiBQYFxuXHRmb3IgKGxldCBpIGluIHByb3BzKSBvYmpbaV0gPSBwcm9wc1tpXTtcblx0cmV0dXJuIC8qKiBAdHlwZSB7TyAmIFB9ICovIChvYmopO1xufVxuXG4vKipcbiAqIFJlbW92ZSBhIGNoaWxkIG5vZGUgZnJvbSBpdHMgcGFyZW50IGlmIGF0dGFjaGVkLiBUaGlzIGlzIGEgd29ya2Fyb3VuZCBmb3JcbiAqIElFMTEgd2hpY2ggZG9lc24ndCBzdXBwb3J0IGBFbGVtZW50LnByb3RvdHlwZS5yZW1vdmUoKWAuIFVzaW5nIHRoaXMgZnVuY3Rpb25cbiAqIGlzIHNtYWxsZXIgdGhhbiBpbmNsdWRpbmcgYSBkZWRpY2F0ZWQgcG9seWZpbGwuXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIG5vZGUgdG8gcmVtb3ZlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVOb2RlKG5vZGUpIHtcblx0bGV0IHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG5cdGlmIChwYXJlbnROb2RlKSBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xufVxuXG5leHBvcnQgY29uc3Qgc2xpY2UgPSBFTVBUWV9BUlIuc2xpY2U7XG4iLCAiaW1wb3J0IHsgX2NhdGNoRXJyb3IgfSBmcm9tICcuL2RpZmYvY2F0Y2gtZXJyb3InO1xuXG4vKipcbiAqIFRoZSBgb3B0aW9uYCBvYmplY3QgY2FuIHBvdGVudGlhbGx5IGNvbnRhaW4gY2FsbGJhY2sgZnVuY3Rpb25zXG4gKiB0aGF0IGFyZSBjYWxsZWQgZHVyaW5nIHZhcmlvdXMgc3RhZ2VzIG9mIG91ciByZW5kZXJlci4gVGhpcyBpcyB0aGVcbiAqIGZvdW5kYXRpb24gb24gd2hpY2ggYWxsIG91ciBhZGRvbnMgbGlrZSBgcHJlYWN0L2RlYnVnYCwgYHByZWFjdC9jb21wYXRgLFxuICogYW5kIGBwcmVhY3QvaG9va3NgIGFyZSBiYXNlZCBvbi4gU2VlIHRoZSBgT3B0aW9uc2AgdHlwZSBpbiBgaW50ZXJuYWwuZC50c2BcbiAqIGZvciBhIGZ1bGwgbGlzdCBvZiBhdmFpbGFibGUgb3B0aW9uIGhvb2tzIChtb3N0IGVkaXRvcnMvSURFcyBhbGxvdyB5b3UgdG9cbiAqIGN0cmwrY2xpY2sgb3IgY21kK2NsaWNrIG9uIG1hYyB0aGUgdHlwZSBkZWZpbml0aW9uIGJlbG93KS5cbiAqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5PcHRpb25zfVxuICovXG5jb25zdCBvcHRpb25zID0ge1xuXHRfY2F0Y2hFcnJvclxufTtcblxuZXhwb3J0IGRlZmF1bHQgb3B0aW9ucztcbiIsICJpbXBvcnQgeyBzbGljZSB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgb3B0aW9ucyBmcm9tICcuL29wdGlvbnMnO1xuXG5sZXQgdm5vZGVJZCA9IDA7XG5cbi8qKlxuICogQ3JlYXRlIGFuIHZpcnR1YWwgbm9kZSAodXNlZCBmb3IgSlNYKVxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZVtcInR5cGVcIl19IHR5cGUgVGhlIG5vZGUgbmFtZSBvciBDb21wb25lbnRcbiAqIGNvbnN0cnVjdG9yIGZvciB0aGlzIHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtvYmplY3QgfCBudWxsIHwgdW5kZWZpbmVkfSBbcHJvcHNdIFRoZSBwcm9wZXJ0aWVzIG9mIHRoZSB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuJykuQ29tcG9uZW50Q2hpbGRyZW4+fSBbY2hpbGRyZW5dIFRoZSBjaGlsZHJlbiBvZiB0aGUgdmlydHVhbCBub2RlXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFbGVtZW50KHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xuXHRsZXQgbm9ybWFsaXplZFByb3BzID0ge30sXG5cdFx0a2V5LFxuXHRcdHJlZixcblx0XHRpO1xuXHRmb3IgKGkgaW4gcHJvcHMpIHtcblx0XHRpZiAoaSA9PSAna2V5Jykga2V5ID0gcHJvcHNbaV07XG5cdFx0ZWxzZSBpZiAoaSA9PSAncmVmJykgcmVmID0gcHJvcHNbaV07XG5cdFx0ZWxzZSBub3JtYWxpemVkUHJvcHNbaV0gPSBwcm9wc1tpXTtcblx0fVxuXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuXHRcdG5vcm1hbGl6ZWRQcm9wcy5jaGlsZHJlbiA9XG5cdFx0XHRhcmd1bWVudHMubGVuZ3RoID4gMyA/IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSA6IGNoaWxkcmVuO1xuXHR9XG5cblx0Ly8gSWYgYSBDb21wb25lbnQgVk5vZGUsIGNoZWNrIGZvciBhbmQgYXBwbHkgZGVmYXVsdFByb3BzXG5cdC8vIE5vdGU6IHR5cGUgbWF5IGJlIHVuZGVmaW5lZCBpbiBkZXZlbG9wbWVudCwgbXVzdCBuZXZlciBlcnJvciBoZXJlLlxuXHRpZiAodHlwZW9mIHR5cGUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlLmRlZmF1bHRQcm9wcyAhPSBudWxsKSB7XG5cdFx0Zm9yIChpIGluIHR5cGUuZGVmYXVsdFByb3BzKSB7XG5cdFx0XHRpZiAobm9ybWFsaXplZFByb3BzW2ldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0bm9ybWFsaXplZFByb3BzW2ldID0gdHlwZS5kZWZhdWx0UHJvcHNbaV07XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIG5vcm1hbGl6ZWRQcm9wcywga2V5LCByZWYsIG51bGwpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIFZOb2RlICh1c2VkIGludGVybmFsbHkgYnkgUHJlYWN0KVxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZVtcInR5cGVcIl19IHR5cGUgVGhlIG5vZGUgbmFtZSBvciBDb21wb25lbnRcbiAqIENvbnN0cnVjdG9yIGZvciB0aGlzIHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtvYmplY3QgfCBzdHJpbmcgfCBudW1iZXIgfCBudWxsfSBwcm9wcyBUaGUgcHJvcGVydGllcyBvZiB0aGlzIHZpcnR1YWwgbm9kZS5cbiAqIElmIHRoaXMgdmlydHVhbCBub2RlIHJlcHJlc2VudHMgYSB0ZXh0IG5vZGUsIHRoaXMgaXMgdGhlIHRleHQgb2YgdGhlIG5vZGUgKHN0cmluZyBvciBudW1iZXIpLlxuICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXIgfCBudWxsfSBrZXkgVGhlIGtleSBmb3IgdGhpcyB2aXJ0dWFsIG5vZGUsIHVzZWQgd2hlblxuICogZGlmZmluZyBpdCBhZ2FpbnN0IGl0cyBjaGlsZHJlblxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZVtcInJlZlwiXX0gcmVmIFRoZSByZWYgcHJvcGVydHkgdGhhdCB3aWxsXG4gKiByZWNlaXZlIGEgcmVmZXJlbmNlIHRvIGl0cyBjcmVhdGVkIGNoaWxkXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVWTm9kZSh0eXBlLCBwcm9wcywga2V5LCByZWYsIG9yaWdpbmFsKSB7XG5cdC8vIFY4IHNlZW1zIHRvIGJlIGJldHRlciBhdCBkZXRlY3RpbmcgdHlwZSBzaGFwZXMgaWYgdGhlIG9iamVjdCBpcyBhbGxvY2F0ZWQgZnJvbSB0aGUgc2FtZSBjYWxsIHNpdGVcblx0Ly8gRG8gbm90IGlubGluZSBpbnRvIGNyZWF0ZUVsZW1lbnQgYW5kIGNvZXJjZVRvVk5vZGUhXG5cdGNvbnN0IHZub2RlID0ge1xuXHRcdHR5cGUsXG5cdFx0cHJvcHMsXG5cdFx0a2V5LFxuXHRcdHJlZixcblx0XHRfY2hpbGRyZW46IG51bGwsXG5cdFx0X3BhcmVudDogbnVsbCxcblx0XHRfZGVwdGg6IDAsXG5cdFx0X2RvbTogbnVsbCxcblx0XHQvLyBfbmV4dERvbSBtdXN0IGJlIGluaXRpYWxpemVkIHRvIHVuZGVmaW5lZCBiL2MgaXQgd2lsbCBldmVudHVhbGx5XG5cdFx0Ly8gYmUgc2V0IHRvIGRvbS5uZXh0U2libGluZyB3aGljaCBjYW4gcmV0dXJuIGBudWxsYCBhbmQgaXQgaXMgaW1wb3J0YW50XG5cdFx0Ly8gdG8gYmUgYWJsZSB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIGFuIHVuaW5pdGlhbGl6ZWQgX25leHREb20gYW5kXG5cdFx0Ly8gYSBfbmV4dERvbSB0aGF0IGhhcyBiZWVuIHNldCB0byBgbnVsbGBcblx0XHRfbmV4dERvbTogdW5kZWZpbmVkLFxuXHRcdF9jb21wb25lbnQ6IG51bGwsXG5cdFx0X2h5ZHJhdGluZzogbnVsbCxcblx0XHRjb25zdHJ1Y3RvcjogdW5kZWZpbmVkLFxuXHRcdF9vcmlnaW5hbDogb3JpZ2luYWwgPT0gbnVsbCA/ICsrdm5vZGVJZCA6IG9yaWdpbmFsXG5cdH07XG5cblx0Ly8gT25seSBpbnZva2UgdGhlIHZub2RlIGhvb2sgaWYgdGhpcyB3YXMgKm5vdCogYSBkaXJlY3QgY29weTpcblx0aWYgKG9yaWdpbmFsID09IG51bGwgJiYgb3B0aW9ucy52bm9kZSAhPSBudWxsKSBvcHRpb25zLnZub2RlKHZub2RlKTtcblxuXHRyZXR1cm4gdm5vZGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSZWYoKSB7XG5cdHJldHVybiB7IGN1cnJlbnQ6IG51bGwgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEZyYWdtZW50KHByb3BzKSB7XG5cdHJldHVybiBwcm9wcy5jaGlsZHJlbjtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHRoZSBhcmd1bWVudCBpcyBhIHZhbGlkIFByZWFjdCBWTm9kZS5cbiAqIEBwYXJhbSB7Kn0gdm5vZGVcbiAqIEByZXR1cm5zIHt2bm9kZSBpcyBpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX1cbiAqL1xuZXhwb3J0IGNvbnN0IGlzVmFsaWRFbGVtZW50ID0gdm5vZGUgPT5cblx0dm5vZGUgIT0gbnVsbCAmJiB2bm9kZS5jb25zdHJ1Y3RvciA9PT0gdW5kZWZpbmVkO1xuIiwgImltcG9ydCB7IElTX05PTl9ESU1FTlNJT05BTCB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgb3B0aW9ucyBmcm9tICcuLi9vcHRpb25zJztcblxuLyoqXG4gKiBEaWZmIHRoZSBvbGQgYW5kIG5ldyBwcm9wZXJ0aWVzIG9mIGEgVk5vZGUgYW5kIGFwcGx5IGNoYW5nZXMgdG8gdGhlIERPTSBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBkb20gVGhlIERPTSBub2RlIHRvIGFwcGx5XG4gKiBjaGFuZ2VzIHRvXG4gKiBAcGFyYW0ge29iamVjdH0gbmV3UHJvcHMgVGhlIG5ldyBwcm9wc1xuICogQHBhcmFtIHtvYmplY3R9IG9sZFByb3BzIFRoZSBvbGQgcHJvcHNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdmcgV2hldGhlciBvciBub3QgdGhpcyBub2RlIGlzIGFuIFNWRyBub2RlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGh5ZHJhdGUgV2hldGhlciBvciBub3Qgd2UgYXJlIGluIGh5ZHJhdGlvbiBtb2RlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaWZmUHJvcHMoZG9tLCBuZXdQcm9wcywgb2xkUHJvcHMsIGlzU3ZnLCBoeWRyYXRlKSB7XG5cdGxldCBpO1xuXG5cdGZvciAoaSBpbiBvbGRQcm9wcykge1xuXHRcdGlmIChpICE9PSAnY2hpbGRyZW4nICYmIGkgIT09ICdrZXknICYmICEoaSBpbiBuZXdQcm9wcykpIHtcblx0XHRcdHNldFByb3BlcnR5KGRvbSwgaSwgbnVsbCwgb2xkUHJvcHNbaV0sIGlzU3ZnKTtcblx0XHR9XG5cdH1cblxuXHRmb3IgKGkgaW4gbmV3UHJvcHMpIHtcblx0XHRpZiAoXG5cdFx0XHQoIWh5ZHJhdGUgfHwgdHlwZW9mIG5ld1Byb3BzW2ldID09ICdmdW5jdGlvbicpICYmXG5cdFx0XHRpICE9PSAnY2hpbGRyZW4nICYmXG5cdFx0XHRpICE9PSAna2V5JyAmJlxuXHRcdFx0aSAhPT0gJ3ZhbHVlJyAmJlxuXHRcdFx0aSAhPT0gJ2NoZWNrZWQnICYmXG5cdFx0XHRvbGRQcm9wc1tpXSAhPT0gbmV3UHJvcHNbaV1cblx0XHQpIHtcblx0XHRcdHNldFByb3BlcnR5KGRvbSwgaSwgbmV3UHJvcHNbaV0sIG9sZFByb3BzW2ldLCBpc1N2Zyk7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHNldFN0eWxlKHN0eWxlLCBrZXksIHZhbHVlKSB7XG5cdGlmIChrZXlbMF0gPT09ICctJykge1xuXHRcdHN0eWxlLnNldFByb3BlcnR5KGtleSwgdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWUpO1xuXHR9IGVsc2UgaWYgKHZhbHVlID09IG51bGwpIHtcblx0XHRzdHlsZVtrZXldID0gJyc7XG5cdH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9ICdudW1iZXInIHx8IElTX05PTl9ESU1FTlNJT05BTC50ZXN0KGtleSkpIHtcblx0XHRzdHlsZVtrZXldID0gdmFsdWU7XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGVba2V5XSA9IHZhbHVlICsgJ3B4Jztcblx0fVxufVxuXG4vKipcbiAqIFNldCBhIHByb3BlcnR5IHZhbHVlIG9uIGEgRE9NIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IGRvbSBUaGUgRE9NIG5vZGUgdG8gbW9kaWZ5XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gc2V0XG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQgdGhlIHByb3BlcnR5IHRvXG4gKiBAcGFyYW0geyp9IG9sZFZhbHVlIFRoZSBvbGQgdmFsdWUgdGhlIHByb3BlcnR5IGhhZFxuICogQHBhcmFtIHtib29sZWFufSBpc1N2ZyBXaGV0aGVyIG9yIG5vdCB0aGlzIERPTSBub2RlIGlzIGFuIFNWRyBub2RlIG9yIG5vdFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0UHJvcGVydHkoZG9tLCBuYW1lLCB2YWx1ZSwgb2xkVmFsdWUsIGlzU3ZnKSB7XG5cdGxldCB1c2VDYXB0dXJlO1xuXG5cdG86IGlmIChuYW1lID09PSAnc3R5bGUnKSB7XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuXHRcdFx0ZG9tLnN0eWxlLmNzc1RleHQgPSB2YWx1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKHR5cGVvZiBvbGRWYWx1ZSA9PSAnc3RyaW5nJykge1xuXHRcdFx0XHRkb20uc3R5bGUuY3NzVGV4dCA9IG9sZFZhbHVlID0gJyc7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvbGRWYWx1ZSkge1xuXHRcdFx0XHRmb3IgKG5hbWUgaW4gb2xkVmFsdWUpIHtcblx0XHRcdFx0XHRpZiAoISh2YWx1ZSAmJiBuYW1lIGluIHZhbHVlKSkge1xuXHRcdFx0XHRcdFx0c2V0U3R5bGUoZG9tLnN0eWxlLCBuYW1lLCAnJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0XHRmb3IgKG5hbWUgaW4gdmFsdWUpIHtcblx0XHRcdFx0XHRpZiAoIW9sZFZhbHVlIHx8IHZhbHVlW25hbWVdICE9PSBvbGRWYWx1ZVtuYW1lXSkge1xuXHRcdFx0XHRcdFx0c2V0U3R5bGUoZG9tLnN0eWxlLCBuYW1lLCB2YWx1ZVtuYW1lXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdC8vIEJlbmNobWFyayBmb3IgY29tcGFyaXNvbjogaHR0cHM6Ly9lc2JlbmNoLmNvbS9iZW5jaC81NzRjOTU0YmRiOTY1YjlhMDA5NjVhYzZcblx0ZWxzZSBpZiAobmFtZVswXSA9PT0gJ28nICYmIG5hbWVbMV0gPT09ICduJykge1xuXHRcdHVzZUNhcHR1cmUgPSBuYW1lICE9PSAobmFtZSA9IG5hbWUucmVwbGFjZSgvQ2FwdHVyZSQvLCAnJykpO1xuXG5cdFx0Ly8gSW5mZXIgY29ycmVjdCBjYXNpbmcgZm9yIERPTSBidWlsdC1pbiBldmVudHM6XG5cdFx0aWYgKG5hbWUudG9Mb3dlckNhc2UoKSBpbiBkb20pIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMik7XG5cdFx0ZWxzZSBuYW1lID0gbmFtZS5zbGljZSgyKTtcblxuXHRcdGlmICghZG9tLl9saXN0ZW5lcnMpIGRvbS5fbGlzdGVuZXJzID0ge307XG5cdFx0ZG9tLl9saXN0ZW5lcnNbbmFtZSArIHVzZUNhcHR1cmVdID0gdmFsdWU7XG5cblx0XHRpZiAodmFsdWUpIHtcblx0XHRcdGlmICghb2xkVmFsdWUpIHtcblx0XHRcdFx0Y29uc3QgaGFuZGxlciA9IHVzZUNhcHR1cmUgPyBldmVudFByb3h5Q2FwdHVyZSA6IGV2ZW50UHJveHk7XG5cdFx0XHRcdGRvbS5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIsIHVzZUNhcHR1cmUpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCBoYW5kbGVyID0gdXNlQ2FwdHVyZSA/IGV2ZW50UHJveHlDYXB0dXJlIDogZXZlbnRQcm94eTtcblx0XHRcdGRvbS5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIsIHVzZUNhcHR1cmUpO1xuXHRcdH1cblx0fSBlbHNlIGlmIChuYW1lICE9PSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnKSB7XG5cdFx0aWYgKGlzU3ZnKSB7XG5cdFx0XHQvLyBOb3JtYWxpemUgaW5jb3JyZWN0IHByb3AgdXNhZ2UgZm9yIFNWRzpcblx0XHRcdC8vIC0geGxpbms6aHJlZiAvIHhsaW5rSHJlZiAtLT4gaHJlZiAoeGxpbms6aHJlZiB3YXMgcmVtb3ZlZCBmcm9tIFNWRyBhbmQgaXNuJ3QgbmVlZGVkKVxuXHRcdFx0Ly8gLSBjbGFzc05hbWUgLS0+IGNsYXNzXG5cdFx0XHRuYW1lID0gbmFtZS5yZXBsYWNlKC94bGluayhIfDpoKS8sICdoJykucmVwbGFjZSgvc05hbWUkLywgJ3MnKTtcblx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0bmFtZSAhPT0gJ3dpZHRoJyAmJlxuXHRcdFx0bmFtZSAhPT0gJ2hlaWdodCcgJiZcblx0XHRcdG5hbWUgIT09ICdocmVmJyAmJlxuXHRcdFx0bmFtZSAhPT0gJ2xpc3QnICYmXG5cdFx0XHRuYW1lICE9PSAnZm9ybScgJiZcblx0XHRcdC8vIERlZmF1bHQgdmFsdWUgaW4gYnJvd3NlcnMgaXMgYC0xYCBhbmQgYW4gZW1wdHkgc3RyaW5nIGlzXG5cdFx0XHQvLyBjYXN0IHRvIGAwYCBpbnN0ZWFkXG5cdFx0XHRuYW1lICE9PSAndGFiSW5kZXgnICYmXG5cdFx0XHRuYW1lICE9PSAnZG93bmxvYWQnICYmXG5cdFx0XHRuYW1lIGluIGRvbVxuXHRcdCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZG9tW25hbWVdID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG5cdFx0XHRcdC8vIGxhYmVsbGVkIGJyZWFrIGlzIDFiIHNtYWxsZXIgaGVyZSB0aGFuIGEgcmV0dXJuIHN0YXRlbWVudCAoc29ycnkpXG5cdFx0XHRcdGJyZWFrIG87XG5cdFx0XHR9IGNhdGNoIChlKSB7fVxuXHRcdH1cblxuXHRcdC8vIEFSSUEtYXR0cmlidXRlcyBoYXZlIGEgZGlmZmVyZW50IG5vdGlvbiBvZiBib29sZWFuIHZhbHVlcy5cblx0XHQvLyBUaGUgdmFsdWUgYGZhbHNlYCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgYXR0cmlidXRlIG5vdFxuXHRcdC8vIGV4aXN0aW5nIG9uIHRoZSBET00sIHNvIHdlIGNhbid0IHJlbW92ZSBpdC4gRm9yIG5vbi1ib29sZWFuXG5cdFx0Ly8gQVJJQS1hdHRyaWJ1dGVzIHdlIGNvdWxkIHRyZWF0IGZhbHNlIGFzIGEgcmVtb3ZhbCwgYnV0IHRoZVxuXHRcdC8vIGFtb3VudCBvZiBleGNlcHRpb25zIHdvdWxkIGNvc3QgdXMgdG9vIG1hbnkgYnl0ZXMuIE9uIHRvcCBvZlxuXHRcdC8vIHRoYXQgb3RoZXIgVkRPTSBmcmFtZXdvcmtzIGFsc28gYWx3YXlzIHN0cmluZ2lmeSBgZmFsc2VgLlxuXG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Ly8gbmV2ZXIgc2VyaWFsaXplIGZ1bmN0aW9ucyBhcyBhdHRyaWJ1dGUgdmFsdWVzXG5cdFx0fSBlbHNlIGlmICh2YWx1ZSAhPSBudWxsICYmICh2YWx1ZSAhPT0gZmFsc2UgfHwgbmFtZS5pbmRleE9mKCctJykgIT0gLTEpKSB7XG5cdFx0XHRkb20uc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZG9tLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcblx0XHR9XG5cdH1cbn1cblxuZXhwb3J0IGxldCBpbkV2ZW50ID0gZmFsc2U7XG5cbi8qKlxuICogUHJveHkgYW4gZXZlbnQgdG8gaG9va2VkIGV2ZW50IGhhbmRsZXJzXG4gKiBAcGFyYW0ge0V2ZW50fSBlIFRoZSBldmVudCBvYmplY3QgZnJvbSB0aGUgYnJvd3NlclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXZlbnRQcm94eShlKSB7XG5cdGluRXZlbnQgPSB0cnVlO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzLl9saXN0ZW5lcnNbZS50eXBlICsgZmFsc2VdKFxuXHRcdFx0b3B0aW9ucy5ldmVudCA/IG9wdGlvbnMuZXZlbnQoZSkgOiBlXG5cdFx0KTtcblx0fSBmaW5hbGx5IHtcblx0XHRpbkV2ZW50ID0gZmFsc2U7XG5cdH1cbn1cblxuZnVuY3Rpb24gZXZlbnRQcm94eUNhcHR1cmUoZSkge1xuXHRpbkV2ZW50ID0gdHJ1ZTtcblx0dHJ5IHtcblx0XHRyZXR1cm4gdGhpcy5fbGlzdGVuZXJzW2UudHlwZSArIHRydWVdKG9wdGlvbnMuZXZlbnQgPyBvcHRpb25zLmV2ZW50KGUpIDogZSk7XG5cdH0gZmluYWxseSB7XG5cdFx0aW5FdmVudCA9IGZhbHNlO1xuXHR9XG59XG4iLCAiaW1wb3J0IHsgYXNzaWduIH0gZnJvbSAnLi91dGlsJztcbmltcG9ydCB7IGRpZmYsIGNvbW1pdFJvb3QgfSBmcm9tICcuL2RpZmYvaW5kZXgnO1xuaW1wb3J0IG9wdGlvbnMgZnJvbSAnLi9vcHRpb25zJztcbmltcG9ydCB7IEZyYWdtZW50IH0gZnJvbSAnLi9jcmVhdGUtZWxlbWVudCc7XG5pbXBvcnQgeyBpbkV2ZW50IH0gZnJvbSAnLi9kaWZmL3Byb3BzJztcblxuLyoqXG4gKiBCYXNlIENvbXBvbmVudCBjbGFzcy4gUHJvdmlkZXMgYHNldFN0YXRlKClgIGFuZCBgZm9yY2VVcGRhdGUoKWAsIHdoaWNoXG4gKiB0cmlnZ2VyIHJlbmRlcmluZ1xuICogQHBhcmFtIHtvYmplY3R9IHByb3BzIFRoZSBpbml0aWFsIGNvbXBvbmVudCBwcm9wc1xuICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHQgVGhlIGluaXRpYWwgY29udGV4dCBmcm9tIHBhcmVudCBjb21wb25lbnRzJ1xuICogZ2V0Q2hpbGRDb250ZXh0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBDb21wb25lbnQocHJvcHMsIGNvbnRleHQpIHtcblx0dGhpcy5wcm9wcyA9IHByb3BzO1xuXHR0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xufVxuXG4vKipcbiAqIFVwZGF0ZSBjb21wb25lbnQgc3RhdGUgYW5kIHNjaGVkdWxlIGEgcmUtcmVuZGVyLlxuICogQHRoaXMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH1cbiAqIEBwYXJhbSB7b2JqZWN0IHwgKChzOiBvYmplY3QsIHA6IG9iamVjdCkgPT4gb2JqZWN0KX0gdXBkYXRlIEEgaGFzaCBvZiBzdGF0ZVxuICogcHJvcGVydGllcyB0byB1cGRhdGUgd2l0aCBuZXcgdmFsdWVzIG9yIGEgZnVuY3Rpb24gdGhhdCBnaXZlbiB0aGUgY3VycmVudFxuICogc3RhdGUgYW5kIHByb3BzIHJldHVybnMgYSBuZXcgcGFydGlhbCBzdGF0ZVxuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBbY2FsbGJhY2tdIEEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uY2UgY29tcG9uZW50IHN0YXRlIGlzXG4gKiB1cGRhdGVkXG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbih1cGRhdGUsIGNhbGxiYWNrKSB7XG5cdC8vIG9ubHkgY2xvbmUgc3RhdGUgd2hlbiBjb3B5aW5nIHRvIG5leHRTdGF0ZSB0aGUgZmlyc3QgdGltZS5cblx0bGV0IHM7XG5cdGlmICh0aGlzLl9uZXh0U3RhdGUgIT0gbnVsbCAmJiB0aGlzLl9uZXh0U3RhdGUgIT09IHRoaXMuc3RhdGUpIHtcblx0XHRzID0gdGhpcy5fbmV4dFN0YXRlO1xuXHR9IGVsc2Uge1xuXHRcdHMgPSB0aGlzLl9uZXh0U3RhdGUgPSBhc3NpZ24oe30sIHRoaXMuc3RhdGUpO1xuXHR9XG5cblx0aWYgKHR5cGVvZiB1cGRhdGUgPT0gJ2Z1bmN0aW9uJykge1xuXHRcdC8vIFNvbWUgbGlicmFyaWVzIGxpa2UgYGltbWVyYCBtYXJrIHRoZSBjdXJyZW50IHN0YXRlIGFzIHJlYWRvbmx5LFxuXHRcdC8vIHByZXZlbnRpbmcgdXMgZnJvbSBtdXRhdGluZyBpdCwgc28gd2UgbmVlZCB0byBjbG9uZSBpdC4gU2VlICMyNzE2XG5cdFx0dXBkYXRlID0gdXBkYXRlKGFzc2lnbih7fSwgcyksIHRoaXMucHJvcHMpO1xuXHR9XG5cblx0aWYgKHVwZGF0ZSkge1xuXHRcdGFzc2lnbihzLCB1cGRhdGUpO1xuXHR9XG5cblx0Ly8gU2tpcCB1cGRhdGUgaWYgdXBkYXRlciBmdW5jdGlvbiByZXR1cm5lZCBudWxsXG5cdGlmICh1cGRhdGUgPT0gbnVsbCkgcmV0dXJuO1xuXG5cdGlmICh0aGlzLl92bm9kZSkge1xuXHRcdGlmIChjYWxsYmFjaykge1xuXHRcdFx0dGhpcy5fc3RhdGVDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG5cdFx0fVxuXHRcdGVucXVldWVSZW5kZXIodGhpcyk7XG5cdH1cbn07XG5cbi8qKlxuICogSW1tZWRpYXRlbHkgcGVyZm9ybSBhIHN5bmNocm9ub3VzIHJlLXJlbmRlciBvZiB0aGUgY29tcG9uZW50XG4gKiBAdGhpcyB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fVxuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBbY2FsbGJhY2tdIEEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpc1xuICogcmUtcmVuZGVyZWRcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdGlmICh0aGlzLl92bm9kZSkge1xuXHRcdC8vIFNldCByZW5kZXIgbW9kZSBzbyB0aGF0IHdlIGNhbiBkaWZmZXJlbnRpYXRlIHdoZXJlIHRoZSByZW5kZXIgcmVxdWVzdFxuXHRcdC8vIGlzIGNvbWluZyBmcm9tLiBXZSBuZWVkIHRoaXMgYmVjYXVzZSBmb3JjZVVwZGF0ZSBzaG91bGQgbmV2ZXIgY2FsbFxuXHRcdC8vIHNob3VsZENvbXBvbmVudFVwZGF0ZVxuXHRcdHRoaXMuX2ZvcmNlID0gdHJ1ZTtcblx0XHRpZiAoY2FsbGJhY2spIHRoaXMuX3JlbmRlckNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcblx0XHRlbnF1ZXVlUmVuZGVyKHRoaXMpO1xuXHR9XG59O1xuXG4vKipcbiAqIEFjY2VwdHMgYHByb3BzYCBhbmQgYHN0YXRlYCwgYW5kIHJldHVybnMgYSBuZXcgVmlydHVhbCBET00gdHJlZSB0byBidWlsZC5cbiAqIFZpcnR1YWwgRE9NIGlzIGdlbmVyYWxseSBjb25zdHJ1Y3RlZCB2aWEgW0pTWF0oaHR0cDovL2phc29uZm9ybWF0LmNvbS93dGYtaXMtanN4KS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcyBQcm9wcyAoZWc6IEpTWCBhdHRyaWJ1dGVzKSByZWNlaXZlZCBmcm9tIHBhcmVudFxuICogZWxlbWVudC9jb21wb25lbnRcbiAqIEBwYXJhbSB7b2JqZWN0fSBzdGF0ZSBUaGUgY29tcG9uZW50J3MgY3VycmVudCBzdGF0ZVxuICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHQgQ29udGV4dCBvYmplY3QsIGFzIHJldHVybmVkIGJ5IHRoZSBuZWFyZXN0XG4gKiBhbmNlc3RvcidzIGBnZXRDaGlsZENvbnRleHQoKWBcbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vaW5kZXgnKS5Db21wb25lbnRDaGlsZHJlbiB8IHZvaWR9XG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyID0gRnJhZ21lbnQ7XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGVcbiAqIEBwYXJhbSB7bnVtYmVyIHwgbnVsbH0gW2NoaWxkSW5kZXhdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREb21TaWJsaW5nKHZub2RlLCBjaGlsZEluZGV4KSB7XG5cdGlmIChjaGlsZEluZGV4ID09IG51bGwpIHtcblx0XHQvLyBVc2UgY2hpbGRJbmRleD09bnVsbCBhcyBhIHNpZ25hbCB0byByZXN1bWUgdGhlIHNlYXJjaCBmcm9tIHRoZSB2bm9kZSdzIHNpYmxpbmdcblx0XHRyZXR1cm4gdm5vZGUuX3BhcmVudFxuXHRcdFx0PyBnZXREb21TaWJsaW5nKHZub2RlLl9wYXJlbnQsIHZub2RlLl9wYXJlbnQuX2NoaWxkcmVuLmluZGV4T2Yodm5vZGUpICsgMSlcblx0XHRcdDogbnVsbDtcblx0fVxuXG5cdGxldCBzaWJsaW5nO1xuXHRmb3IgKDsgY2hpbGRJbmRleCA8IHZub2RlLl9jaGlsZHJlbi5sZW5ndGg7IGNoaWxkSW5kZXgrKykge1xuXHRcdHNpYmxpbmcgPSB2bm9kZS5fY2hpbGRyZW5bY2hpbGRJbmRleF07XG5cblx0XHRpZiAoc2libGluZyAhPSBudWxsICYmIHNpYmxpbmcuX2RvbSAhPSBudWxsKSB7XG5cdFx0XHQvLyBTaW5jZSB1cGRhdGVQYXJlbnREb21Qb2ludGVycyBrZWVwcyBfZG9tIHBvaW50ZXIgY29ycmVjdCxcblx0XHRcdC8vIHdlIGNhbiByZWx5IG9uIF9kb20gdG8gdGVsbCB1cyBpZiB0aGlzIHN1YnRyZWUgY29udGFpbnMgYVxuXHRcdFx0Ly8gcmVuZGVyZWQgRE9NIG5vZGUsIGFuZCB3aGF0IHRoZSBmaXJzdCByZW5kZXJlZCBET00gbm9kZSBpc1xuXHRcdFx0cmV0dXJuIHNpYmxpbmcuX2RvbTtcblx0XHR9XG5cdH1cblxuXHQvLyBJZiB3ZSBnZXQgaGVyZSwgd2UgaGF2ZSBub3QgZm91bmQgYSBET00gbm9kZSBpbiB0aGlzIHZub2RlJ3MgY2hpbGRyZW4uXG5cdC8vIFdlIG11c3QgcmVzdW1lIGZyb20gdGhpcyB2bm9kZSdzIHNpYmxpbmcgKGluIGl0J3MgcGFyZW50IF9jaGlsZHJlbiBhcnJheSlcblx0Ly8gT25seSBjbGltYiB1cCBhbmQgc2VhcmNoIHRoZSBwYXJlbnQgaWYgd2UgYXJlbid0IHNlYXJjaGluZyB0aHJvdWdoIGEgRE9NXG5cdC8vIFZOb2RlIChtZWFuaW5nIHdlIHJlYWNoZWQgdGhlIERPTSBwYXJlbnQgb2YgdGhlIG9yaWdpbmFsIHZub2RlIHRoYXQgYmVnYW5cblx0Ly8gdGhlIHNlYXJjaClcblx0cmV0dXJuIHR5cGVvZiB2bm9kZS50eXBlID09ICdmdW5jdGlvbicgPyBnZXREb21TaWJsaW5nKHZub2RlKSA6IG51bGw7XG59XG5cbi8qKlxuICogVHJpZ2dlciBpbi1wbGFjZSByZS1yZW5kZXJpbmcgb2YgYSBjb21wb25lbnQuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gY29tcG9uZW50IFRoZSBjb21wb25lbnQgdG8gcmVyZW5kZXJcbiAqL1xuZnVuY3Rpb24gcmVuZGVyQ29tcG9uZW50KGNvbXBvbmVudCkge1xuXHRsZXQgdm5vZGUgPSBjb21wb25lbnQuX3Zub2RlLFxuXHRcdG9sZERvbSA9IHZub2RlLl9kb20sXG5cdFx0cGFyZW50RG9tID0gY29tcG9uZW50Ll9wYXJlbnREb207XG5cblx0aWYgKHBhcmVudERvbSkge1xuXHRcdGxldCBjb21taXRRdWV1ZSA9IFtdO1xuXHRcdGNvbnN0IG9sZFZOb2RlID0gYXNzaWduKHt9LCB2bm9kZSk7XG5cdFx0b2xkVk5vZGUuX29yaWdpbmFsID0gdm5vZGUuX29yaWdpbmFsICsgMTtcblxuXHRcdGRpZmYoXG5cdFx0XHRwYXJlbnREb20sXG5cdFx0XHR2bm9kZSxcblx0XHRcdG9sZFZOb2RlLFxuXHRcdFx0Y29tcG9uZW50Ll9nbG9iYWxDb250ZXh0LFxuXHRcdFx0cGFyZW50RG9tLm93bmVyU1ZHRWxlbWVudCAhPT0gdW5kZWZpbmVkLFxuXHRcdFx0dm5vZGUuX2h5ZHJhdGluZyAhPSBudWxsID8gW29sZERvbV0gOiBudWxsLFxuXHRcdFx0Y29tbWl0UXVldWUsXG5cdFx0XHRvbGREb20gPT0gbnVsbCA/IGdldERvbVNpYmxpbmcodm5vZGUpIDogb2xkRG9tLFxuXHRcdFx0dm5vZGUuX2h5ZHJhdGluZ1xuXHRcdCk7XG5cdFx0Y29tbWl0Um9vdChjb21taXRRdWV1ZSwgdm5vZGUpO1xuXG5cdFx0aWYgKHZub2RlLl9kb20gIT0gb2xkRG9tKSB7XG5cdFx0XHR1cGRhdGVQYXJlbnREb21Qb2ludGVycyh2bm9kZSk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGVcbiAqL1xuZnVuY3Rpb24gdXBkYXRlUGFyZW50RG9tUG9pbnRlcnModm5vZGUpIHtcblx0aWYgKCh2bm9kZSA9IHZub2RlLl9wYXJlbnQpICE9IG51bGwgJiYgdm5vZGUuX2NvbXBvbmVudCAhPSBudWxsKSB7XG5cdFx0dm5vZGUuX2RvbSA9IHZub2RlLl9jb21wb25lbnQuYmFzZSA9IG51bGw7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB2bm9kZS5fY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdGxldCBjaGlsZCA9IHZub2RlLl9jaGlsZHJlbltpXTtcblx0XHRcdGlmIChjaGlsZCAhPSBudWxsICYmIGNoaWxkLl9kb20gIT0gbnVsbCkge1xuXHRcdFx0XHR2bm9kZS5fZG9tID0gdm5vZGUuX2NvbXBvbmVudC5iYXNlID0gY2hpbGQuX2RvbTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVwZGF0ZVBhcmVudERvbVBvaW50ZXJzKHZub2RlKTtcblx0fVxufVxuXG4vKipcbiAqIFRoZSByZW5kZXIgcXVldWVcbiAqIEB0eXBlIHtBcnJheTxpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnQ+fVxuICovXG5sZXQgcmVyZW5kZXJRdWV1ZSA9IFtdO1xuXG4vKlxuICogVGhlIHZhbHVlIG9mIGBDb21wb25lbnQuZGVib3VuY2VgIG11c3QgYXN5bmNocm9ub3VzbHkgaW52b2tlIHRoZSBwYXNzZWQgaW4gY2FsbGJhY2suIEl0IGlzXG4gKiBpbXBvcnRhbnQgdGhhdCBjb250cmlidXRvcnMgdG8gUHJlYWN0IGNhbiBjb25zaXN0ZW50bHkgcmVhc29uIGFib3V0IHdoYXQgY2FsbHMgdG8gYHNldFN0YXRlYCwgZXRjLlxuICogZG8sIGFuZCB3aGVuIHRoZWlyIGVmZmVjdHMgd2lsbCBiZSBhcHBsaWVkLiBTZWUgdGhlIGxpbmtzIGJlbG93IGZvciBzb21lIGZ1cnRoZXIgcmVhZGluZyBvbiBkZXNpZ25pbmdcbiAqIGFzeW5jaHJvbm91cyBBUElzLlxuICogKiBbRGVzaWduaW5nIEFQSXMgZm9yIEFzeW5jaHJvbnldKGh0dHBzOi8vYmxvZy5penMubWUvMjAxMy8wOC9kZXNpZ25pbmctYXBpcy1mb3ItYXN5bmNocm9ueSlcbiAqICogW0NhbGxiYWNrcyBzeW5jaHJvbm91cyBhbmQgYXN5bmNocm9ub3VzXShodHRwczovL2Jsb2cub21ldGVyLmNvbS8yMDExLzA3LzI0L2NhbGxiYWNrcy1zeW5jaHJvbm91cy1hbmQtYXN5bmNocm9ub3VzLylcbiAqL1xuXG5sZXQgcHJldkRlYm91bmNlO1xuXG5jb25zdCBtaWNyb1RpY2sgPVxuXHR0eXBlb2YgUHJvbWlzZSA9PSAnZnVuY3Rpb24nXG5cdFx0PyBQcm9taXNlLnByb3RvdHlwZS50aGVuLmJpbmQoUHJvbWlzZS5yZXNvbHZlKCkpXG5cdFx0OiBzZXRUaW1lb3V0O1xuZnVuY3Rpb24gZGVmZXIoY2IpIHtcblx0aWYgKGluRXZlbnQpIHtcblx0XHRzZXRUaW1lb3V0KGNiKTtcblx0fSBlbHNlIHtcblx0XHRtaWNyb1RpY2soY2IpO1xuXHR9XG59XG5cbi8qKlxuICogRW5xdWV1ZSBhIHJlcmVuZGVyIG9mIGEgY29tcG9uZW50XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gYyBUaGUgY29tcG9uZW50IHRvIHJlcmVuZGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnF1ZXVlUmVuZGVyKGMpIHtcblx0aWYgKFxuXHRcdCghYy5fZGlydHkgJiZcblx0XHRcdChjLl9kaXJ0eSA9IHRydWUpICYmXG5cdFx0XHRyZXJlbmRlclF1ZXVlLnB1c2goYykgJiZcblx0XHRcdCFwcm9jZXNzLl9yZXJlbmRlckNvdW50KyspIHx8XG5cdFx0cHJldkRlYm91bmNlICE9PSBvcHRpb25zLmRlYm91bmNlUmVuZGVyaW5nXG5cdCkge1xuXHRcdHByZXZEZWJvdW5jZSA9IG9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmc7XG5cdFx0KHByZXZEZWJvdW5jZSB8fCBkZWZlcikocHJvY2Vzcyk7XG5cdH1cbn1cblxuLyoqIEZsdXNoIHRoZSByZW5kZXIgcXVldWUgYnkgcmVyZW5kZXJpbmcgYWxsIHF1ZXVlZCBjb21wb25lbnRzICovXG5mdW5jdGlvbiBwcm9jZXNzKCkge1xuXHRsZXQgYztcblx0cmVyZW5kZXJRdWV1ZS5zb3J0KChhLCBiKSA9PiBhLl92bm9kZS5fZGVwdGggLSBiLl92bm9kZS5fZGVwdGgpO1xuXHQvLyBEb24ndCB1cGRhdGUgYHJlbmRlckNvdW50YCB5ZXQuIEtlZXAgaXRzIHZhbHVlIG5vbi16ZXJvIHRvIHByZXZlbnQgdW5uZWNlc3Nhcnlcblx0Ly8gcHJvY2VzcygpIGNhbGxzIGZyb20gZ2V0dGluZyBzY2hlZHVsZWQgd2hpbGUgYHF1ZXVlYCBpcyBzdGlsbCBiZWluZyBjb25zdW1lZC5cblx0d2hpbGUgKChjID0gcmVyZW5kZXJRdWV1ZS5zaGlmdCgpKSkge1xuXHRcdGlmIChjLl9kaXJ0eSkge1xuXHRcdFx0bGV0IHJlbmRlclF1ZXVlTGVuZ3RoID0gcmVyZW5kZXJRdWV1ZS5sZW5ndGg7XG5cdFx0XHRyZW5kZXJDb21wb25lbnQoYyk7XG5cdFx0XHRpZiAocmVyZW5kZXJRdWV1ZS5sZW5ndGggPiByZW5kZXJRdWV1ZUxlbmd0aCkge1xuXHRcdFx0XHQvLyBXaGVuIGkuZS4gcmVyZW5kZXJpbmcgYSBwcm92aWRlciBhZGRpdGlvbmFsIG5ldyBpdGVtcyBjYW4gYmUgaW5qZWN0ZWQsIHdlIHdhbnQgdG9cblx0XHRcdFx0Ly8ga2VlcCB0aGUgb3JkZXIgZnJvbSB0b3AgdG8gYm90dG9tIHdpdGggdGhvc2UgbmV3IGl0ZW1zIHNvIHdlIGNhbiBoYW5kbGUgdGhlbSBpbiBhXG5cdFx0XHRcdC8vIHNpbmdsZSBwYXNzXG5cdFx0XHRcdHJlcmVuZGVyUXVldWUuc29ydCgoYSwgYikgPT4gYS5fdm5vZGUuX2RlcHRoIC0gYi5fdm5vZGUuX2RlcHRoKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cHJvY2Vzcy5fcmVyZW5kZXJDb3VudCA9IDA7XG59XG5cbnByb2Nlc3MuX3JlcmVuZGVyQ291bnQgPSAwO1xuIiwgImltcG9ydCB7IGVucXVldWVSZW5kZXIgfSBmcm9tICcuL2NvbXBvbmVudCc7XG5cbmV4cG9ydCBsZXQgaSA9IDA7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb250ZXh0KGRlZmF1bHRWYWx1ZSwgY29udGV4dElkKSB7XG5cdGNvbnRleHRJZCA9ICdfX2NDJyArIGkrKztcblxuXHRjb25zdCBjb250ZXh0ID0ge1xuXHRcdF9pZDogY29udGV4dElkLFxuXHRcdF9kZWZhdWx0VmFsdWU6IGRlZmF1bHRWYWx1ZSxcblx0XHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkZ1bmN0aW9uQ29tcG9uZW50fSAqL1xuXHRcdENvbnN1bWVyKHByb3BzLCBjb250ZXh0VmFsdWUpIHtcblx0XHRcdC8vIHJldHVybiBwcm9wcy5jaGlsZHJlbihcblx0XHRcdC8vIFx0Y29udGV4dFtjb250ZXh0SWRdID8gY29udGV4dFtjb250ZXh0SWRdLnByb3BzLnZhbHVlIDogZGVmYXVsdFZhbHVlXG5cdFx0XHQvLyApO1xuXHRcdFx0cmV0dXJuIHByb3BzLmNoaWxkcmVuKGNvbnRleHRWYWx1ZSk7XG5cdFx0fSxcblx0XHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkZ1bmN0aW9uQ29tcG9uZW50fSAqL1xuXHRcdFByb3ZpZGVyKHByb3BzKSB7XG5cdFx0XHRpZiAoIXRoaXMuZ2V0Q2hpbGRDb250ZXh0KSB7XG5cdFx0XHRcdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50W119ICovXG5cdFx0XHRcdGxldCBzdWJzID0gW107XG5cdFx0XHRcdGxldCBjdHggPSB7fTtcblx0XHRcdFx0Y3R4W2NvbnRleHRJZF0gPSB0aGlzO1xuXG5cdFx0XHRcdHRoaXMuZ2V0Q2hpbGRDb250ZXh0ID0gKCkgPT4gY3R4O1xuXG5cdFx0XHRcdHRoaXMuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZnVuY3Rpb24oX3Byb3BzKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMucHJvcHMudmFsdWUgIT09IF9wcm9wcy52YWx1ZSkge1xuXHRcdFx0XHRcdFx0Ly8gSSB0aGluayB0aGUgZm9yY2VkIHZhbHVlIHByb3BhZ2F0aW9uIGhlcmUgd2FzIG9ubHkgbmVlZGVkIHdoZW4gYG9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmdgIHdhcyBiZWluZyBieXBhc3NlZDpcblx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmVhY3Rqcy9wcmVhY3QvY29tbWl0LzRkMzM5ZmI4MDNiZWEwOWU5ZjE5OGFiZjM4Y2ExYmY4ZWE0Yjc3NzEjZGlmZi01NDY4MmNlMzgwOTM1YTcxN2U0MWI4YmZjNTQ3MzdmNlIzNThcblx0XHRcdFx0XHRcdC8vIEluIHRob3NlIGNhc2VzIHRob3VnaCwgZXZlbiB3aXRoIHRoZSB2YWx1ZSBjb3JyZWN0ZWQsIHdlJ3JlIGRvdWJsZS1yZW5kZXJpbmcgYWxsIG5vZGVzLlxuXHRcdFx0XHRcdFx0Ly8gSXQgbWlnaHQgYmUgYmV0dGVyIHRvIGp1c3QgdGVsbCBmb2xrcyBub3QgdG8gdXNlIGZvcmNlLXN5bmMgbW9kZS5cblx0XHRcdFx0XHRcdC8vIEN1cnJlbnRseSwgdXNpbmcgYHVzZUNvbnRleHQoKWAgaW4gYSBjbGFzcyBjb21wb25lbnQgd2lsbCBvdmVyd3JpdGUgaXRzIGB0aGlzLmNvbnRleHRgIHZhbHVlLlxuXHRcdFx0XHRcdFx0Ly8gc3Vicy5zb21lKGMgPT4ge1xuXHRcdFx0XHRcdFx0Ly8gXHRjLmNvbnRleHQgPSBfcHJvcHMudmFsdWU7XG5cdFx0XHRcdFx0XHQvLyBcdGVucXVldWVSZW5kZXIoYyk7XG5cdFx0XHRcdFx0XHQvLyB9KTtcblxuXHRcdFx0XHRcdFx0Ly8gc3Vicy5zb21lKGMgPT4ge1xuXHRcdFx0XHRcdFx0Ly8gXHRjLmNvbnRleHRbY29udGV4dElkXSA9IF9wcm9wcy52YWx1ZTtcblx0XHRcdFx0XHRcdC8vIFx0ZW5xdWV1ZVJlbmRlcihjKTtcblx0XHRcdFx0XHRcdC8vIH0pO1xuXHRcdFx0XHRcdFx0c3Vicy5zb21lKGMgPT4ge1xuXHRcdFx0XHRcdFx0XHRjLl9mb3JjZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdGVucXVldWVSZW5kZXIoYyk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0dGhpcy5zdWIgPSBjID0+IHtcblx0XHRcdFx0XHRzdWJzLnB1c2goYyk7XG5cdFx0XHRcdFx0bGV0IG9sZCA9IGMuY29tcG9uZW50V2lsbFVubW91bnQ7XG5cdFx0XHRcdFx0Yy5jb21wb25lbnRXaWxsVW5tb3VudCA9ICgpID0+IHtcblx0XHRcdFx0XHRcdHN1YnMuc3BsaWNlKHN1YnMuaW5kZXhPZihjKSwgMSk7XG5cdFx0XHRcdFx0XHRpZiAob2xkKSBvbGQuY2FsbChjKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcHJvcHMuY2hpbGRyZW47XG5cdFx0fVxuXHR9O1xuXG5cdC8vIERldnRvb2xzIG5lZWRzIGFjY2VzcyB0byB0aGUgY29udGV4dCBvYmplY3Qgd2hlbiBpdFxuXHQvLyBlbmNvdW50ZXJzIGEgUHJvdmlkZXIuIFRoaXMgaXMgbmVjZXNzYXJ5IHRvIHN1cHBvcnRcblx0Ly8gc2V0dGluZyBgZGlzcGxheU5hbWVgIG9uIHRoZSBjb250ZXh0IG9iamVjdCBpbnN0ZWFkXG5cdC8vIG9mIG9uIHRoZSBjb21wb25lbnQgaXRzZWxmLiBTZWU6XG5cdC8vIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9jb250ZXh0Lmh0bWwjY29udGV4dGRpc3BsYXluYW1lXG5cblx0cmV0dXJuIChjb250ZXh0LlByb3ZpZGVyLl9jb250ZXh0UmVmID0gY29udGV4dC5Db25zdW1lci5jb250ZXh0VHlwZSA9IGNvbnRleHQpO1xufVxuIiwgImV4cG9ydCBjb25zdCBFTVBUWV9PQkogPSB7fTtcbmV4cG9ydCBjb25zdCBFTVBUWV9BUlIgPSBbXTtcbmV4cG9ydCBjb25zdCBJU19OT05fRElNRU5TSU9OQUwgPSAvYWNpdHxleCg/OnN8Z3xufHB8JCl8cnBofGdyaWR8b3dzfG1uY3xudHd8aW5lW2NoXXx6b298Xm9yZHxpdGVyYS9pO1xuIiwgImltcG9ydCB7IGRpZmYsIHVubW91bnQsIGFwcGx5UmVmIH0gZnJvbSAnLi9pbmRleCc7XG5pbXBvcnQgeyBjcmVhdGVWTm9kZSwgRnJhZ21lbnQgfSBmcm9tICcuLi9jcmVhdGUtZWxlbWVudCc7XG5pbXBvcnQgeyBFTVBUWV9PQkosIEVNUFRZX0FSUiB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBnZXREb21TaWJsaW5nIH0gZnJvbSAnLi4vY29tcG9uZW50JztcblxuLyoqXG4gKiBEaWZmIHRoZSBjaGlsZHJlbiBvZiBhIHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gcGFyZW50RG9tIFRoZSBET00gZWxlbWVudCB3aG9zZVxuICogY2hpbGRyZW4gYXJlIGJlaW5nIGRpZmZlZFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuQ29tcG9uZW50Q2hpbGRyZW5bXX0gcmVuZGVyUmVzdWx0XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gbmV3UGFyZW50Vk5vZGUgVGhlIG5ldyB2aXJ0dWFsXG4gKiBub2RlIHdob3NlIGNoaWxkcmVuIHNob3VsZCBiZSBkaWZmJ2VkIGFnYWluc3Qgb2xkUGFyZW50Vk5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBvbGRQYXJlbnRWTm9kZSBUaGUgb2xkIHZpcnR1YWxcbiAqIG5vZGUgd2hvc2UgY2hpbGRyZW4gc2hvdWxkIGJlIGRpZmYnZWQgYWdhaW5zdCBuZXdQYXJlbnRWTm9kZVxuICogQHBhcmFtIHtvYmplY3R9IGdsb2JhbENvbnRleHQgVGhlIGN1cnJlbnQgY29udGV4dCBvYmplY3QgLSBtb2RpZmllZCBieSBnZXRDaGlsZENvbnRleHRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdmcgV2hldGhlciBvciBub3QgdGhpcyBET00gbm9kZSBpcyBhbiBTVkcgbm9kZVxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudD59IGV4Y2Vzc0RvbUNoaWxkcmVuXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5Db21wb25lbnQ+fSBjb21taXRRdWV1ZSBMaXN0IG9mIGNvbXBvbmVudHNcbiAqIHdoaWNoIGhhdmUgY2FsbGJhY2tzIHRvIGludm9rZSBpbiBjb21taXRSb290XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBvbGREb20gVGhlIGN1cnJlbnQgYXR0YWNoZWQgRE9NXG4gKiBlbGVtZW50IGFueSBuZXcgZG9tIGVsZW1lbnRzIHNob3VsZCBiZSBwbGFjZWQgYXJvdW5kLiBMaWtlbHkgYG51bGxgIG9uIGZpcnN0XG4gKiByZW5kZXIgKGV4Y2VwdCB3aGVuIGh5ZHJhdGluZykuIENhbiBiZSBhIHNpYmxpbmcgRE9NIGVsZW1lbnQgd2hlbiBkaWZmaW5nXG4gKiBGcmFnbWVudHMgdGhhdCBoYXZlIHNpYmxpbmdzLiBJbiBtb3N0IGNhc2VzLCBpdCBzdGFydHMgb3V0IGFzIGBvbGRDaGlsZHJlblswXS5fZG9tYC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNIeWRyYXRpbmcgV2hldGhlciBvciBub3Qgd2UgYXJlIGluIGh5ZHJhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlmZkNoaWxkcmVuKFxuXHRwYXJlbnREb20sXG5cdHJlbmRlclJlc3VsdCxcblx0bmV3UGFyZW50Vk5vZGUsXG5cdG9sZFBhcmVudFZOb2RlLFxuXHRnbG9iYWxDb250ZXh0LFxuXHRpc1N2Zyxcblx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdGNvbW1pdFF1ZXVlLFxuXHRvbGREb20sXG5cdGlzSHlkcmF0aW5nXG4pIHtcblx0bGV0IGksIGosIG9sZFZOb2RlLCBjaGlsZFZOb2RlLCBuZXdEb20sIGZpcnN0Q2hpbGREb20sIHJlZnM7XG5cblx0Ly8gVGhpcyBpcyBhIGNvbXByZXNzaW9uIG9mIG9sZFBhcmVudFZOb2RlIT1udWxsICYmIG9sZFBhcmVudFZOb2RlICE9IEVNUFRZX09CSiAmJiBvbGRQYXJlbnRWTm9kZS5fY2hpbGRyZW4gfHwgRU1QVFlfQVJSXG5cdC8vIGFzIEVNUFRZX09CSi5fY2hpbGRyZW4gc2hvdWxkIGJlIGB1bmRlZmluZWRgLlxuXHRsZXQgb2xkQ2hpbGRyZW4gPSAob2xkUGFyZW50Vk5vZGUgJiYgb2xkUGFyZW50Vk5vZGUuX2NoaWxkcmVuKSB8fCBFTVBUWV9BUlI7XG5cblx0bGV0IG9sZENoaWxkcmVuTGVuZ3RoID0gb2xkQ2hpbGRyZW4ubGVuZ3RoO1xuXG5cdG5ld1BhcmVudFZOb2RlLl9jaGlsZHJlbiA9IFtdO1xuXHRmb3IgKGkgPSAwOyBpIDwgcmVuZGVyUmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0Y2hpbGRWTm9kZSA9IHJlbmRlclJlc3VsdFtpXTtcblxuXHRcdGlmIChjaGlsZFZOb2RlID09IG51bGwgfHwgdHlwZW9mIGNoaWxkVk5vZGUgPT0gJ2Jvb2xlYW4nKSB7XG5cdFx0XHRjaGlsZFZOb2RlID0gbmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuW2ldID0gbnVsbDtcblx0XHR9XG5cdFx0Ly8gSWYgdGhpcyBuZXdWTm9kZSBpcyBiZWluZyByZXVzZWQgKGUuZy4gPGRpdj57cmV1c2V9e3JldXNlfTwvZGl2PikgaW4gdGhlIHNhbWUgZGlmZixcblx0XHQvLyBvciB3ZSBhcmUgcmVuZGVyaW5nIGEgY29tcG9uZW50IChlLmcuIHNldFN0YXRlKSBjb3B5IHRoZSBvbGRWTm9kZXMgc28gaXQgY2FuIGhhdmVcblx0XHQvLyBpdCdzIG93biBET00gJiBldGMuIHBvaW50ZXJzXG5cdFx0ZWxzZSBpZiAoXG5cdFx0XHR0eXBlb2YgY2hpbGRWTm9kZSA9PSAnc3RyaW5nJyB8fFxuXHRcdFx0dHlwZW9mIGNoaWxkVk5vZGUgPT0gJ251bWJlcicgfHxcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB2YWxpZC10eXBlb2Zcblx0XHRcdHR5cGVvZiBjaGlsZFZOb2RlID09ICdiaWdpbnQnXG5cdFx0KSB7XG5cdFx0XHRjaGlsZFZOb2RlID0gbmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuW2ldID0gY3JlYXRlVk5vZGUoXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdGNoaWxkVk5vZGUsXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdGNoaWxkVk5vZGVcblx0XHRcdCk7XG5cdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNoaWxkVk5vZGUpKSB7XG5cdFx0XHRjaGlsZFZOb2RlID0gbmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuW2ldID0gY3JlYXRlVk5vZGUoXG5cdFx0XHRcdEZyYWdtZW50LFxuXHRcdFx0XHR7IGNoaWxkcmVuOiBjaGlsZFZOb2RlIH0sXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdG51bGxcblx0XHRcdCk7XG5cdFx0fSBlbHNlIGlmIChjaGlsZFZOb2RlLl9kZXB0aCA+IDApIHtcblx0XHRcdC8vIFZOb2RlIGlzIGFscmVhZHkgaW4gdXNlLCBjbG9uZSBpdC4gVGhpcyBjYW4gaGFwcGVuIGluIHRoZSBmb2xsb3dpbmdcblx0XHRcdC8vIHNjZW5hcmlvOlxuXHRcdFx0Ly8gICBjb25zdCByZXVzZSA9IDxkaXYgLz5cblx0XHRcdC8vICAgPGRpdj57cmV1c2V9PHNwYW4gLz57cmV1c2V9PC9kaXY+XG5cdFx0XHRjaGlsZFZOb2RlID0gbmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuW2ldID0gY3JlYXRlVk5vZGUoXG5cdFx0XHRcdGNoaWxkVk5vZGUudHlwZSxcblx0XHRcdFx0Y2hpbGRWTm9kZS5wcm9wcyxcblx0XHRcdFx0Y2hpbGRWTm9kZS5rZXksXG5cdFx0XHRcdGNoaWxkVk5vZGUucmVmID8gY2hpbGRWTm9kZS5yZWYgOiBudWxsLFxuXHRcdFx0XHRjaGlsZFZOb2RlLl9vcmlnaW5hbFxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2hpbGRWTm9kZSA9IG5ld1BhcmVudFZOb2RlLl9jaGlsZHJlbltpXSA9IGNoaWxkVk5vZGU7XG5cdFx0fVxuXG5cdFx0Ly8gVGVyc2VyIHJlbW92ZXMgdGhlIGBjb250aW51ZWAgaGVyZSBhbmQgd3JhcHMgdGhlIGxvb3AgYm9keVxuXHRcdC8vIGluIGEgYGlmIChjaGlsZFZOb2RlKSB7IC4uLiB9IGNvbmRpdGlvblxuXHRcdGlmIChjaGlsZFZOb2RlID09IG51bGwpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGNoaWxkVk5vZGUuX3BhcmVudCA9IG5ld1BhcmVudFZOb2RlO1xuXHRcdGNoaWxkVk5vZGUuX2RlcHRoID0gbmV3UGFyZW50Vk5vZGUuX2RlcHRoICsgMTtcblxuXHRcdC8vIENoZWNrIGlmIHdlIGZpbmQgYSBjb3JyZXNwb25kaW5nIGVsZW1lbnQgaW4gb2xkQ2hpbGRyZW4uXG5cdFx0Ly8gSWYgZm91bmQsIGRlbGV0ZSB0aGUgYXJyYXkgaXRlbSBieSBzZXR0aW5nIHRvIGB1bmRlZmluZWRgLlxuXHRcdC8vIFdlIHVzZSBgdW5kZWZpbmVkYCwgYXMgYG51bGxgIGlzIHJlc2VydmVkIGZvciBlbXB0eSBwbGFjZWhvbGRlcnNcblx0XHQvLyAoaG9sZXMpLlxuXHRcdG9sZFZOb2RlID0gb2xkQ2hpbGRyZW5baV07XG5cblx0XHRpZiAoXG5cdFx0XHRvbGRWTm9kZSA9PT0gbnVsbCB8fFxuXHRcdFx0KG9sZFZOb2RlICYmXG5cdFx0XHRcdGNoaWxkVk5vZGUua2V5ID09IG9sZFZOb2RlLmtleSAmJlxuXHRcdFx0XHRjaGlsZFZOb2RlLnR5cGUgPT09IG9sZFZOb2RlLnR5cGUpXG5cdFx0KSB7XG5cdFx0XHRvbGRDaGlsZHJlbltpXSA9IHVuZGVmaW5lZDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gRWl0aGVyIG9sZFZOb2RlID09PSB1bmRlZmluZWQgb3Igb2xkQ2hpbGRyZW5MZW5ndGggPiAwLFxuXHRcdFx0Ly8gc28gYWZ0ZXIgdGhpcyBsb29wIG9sZFZOb2RlID09IG51bGwgb3Igb2xkVk5vZGUgaXMgYSB2YWxpZCB2YWx1ZS5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBvbGRDaGlsZHJlbkxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdG9sZFZOb2RlID0gb2xkQ2hpbGRyZW5bal07XG5cdFx0XHRcdC8vIElmIGNoaWxkVk5vZGUgaXMgdW5rZXllZCwgd2Ugb25seSBtYXRjaCBzaW1pbGFybHkgdW5rZXllZCBub2Rlcywgb3RoZXJ3aXNlIHdlIG1hdGNoIGJ5IGtleS5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIG1hdGNoIGJ5IHR5cGUgKGluIGVpdGhlciBjYXNlKS5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdG9sZFZOb2RlICYmXG5cdFx0XHRcdFx0Y2hpbGRWTm9kZS5rZXkgPT0gb2xkVk5vZGUua2V5ICYmXG5cdFx0XHRcdFx0Y2hpbGRWTm9kZS50eXBlID09PSBvbGRWTm9kZS50eXBlXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdG9sZENoaWxkcmVuW2pdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG9sZFZOb2RlID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRvbGRWTm9kZSA9IG9sZFZOb2RlIHx8IEVNUFRZX09CSjtcblxuXHRcdC8vIE1vcnBoIHRoZSBvbGQgZWxlbWVudCBpbnRvIHRoZSBuZXcgb25lLCBidXQgZG9uJ3QgYXBwZW5kIGl0IHRvIHRoZSBkb20geWV0XG5cdFx0ZGlmZihcblx0XHRcdHBhcmVudERvbSxcblx0XHRcdGNoaWxkVk5vZGUsXG5cdFx0XHRvbGRWTm9kZSxcblx0XHRcdGdsb2JhbENvbnRleHQsXG5cdFx0XHRpc1N2Zyxcblx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuLFxuXHRcdFx0Y29tbWl0UXVldWUsXG5cdFx0XHRvbGREb20sXG5cdFx0XHRpc0h5ZHJhdGluZ1xuXHRcdCk7XG5cblx0XHRuZXdEb20gPSBjaGlsZFZOb2RlLl9kb207XG5cblx0XHRpZiAoKGogPSBjaGlsZFZOb2RlLnJlZikgJiYgb2xkVk5vZGUucmVmICE9IGopIHtcblx0XHRcdGlmICghcmVmcykgcmVmcyA9IFtdO1xuXHRcdFx0aWYgKG9sZFZOb2RlLnJlZikgcmVmcy5wdXNoKG9sZFZOb2RlLnJlZiwgbnVsbCwgY2hpbGRWTm9kZSk7XG5cdFx0XHRyZWZzLnB1c2goaiwgY2hpbGRWTm9kZS5fY29tcG9uZW50IHx8IG5ld0RvbSwgY2hpbGRWTm9kZSk7XG5cdFx0fVxuXG5cdFx0aWYgKG5ld0RvbSAhPSBudWxsKSB7XG5cdFx0XHRpZiAoZmlyc3RDaGlsZERvbSA9PSBudWxsKSB7XG5cdFx0XHRcdGZpcnN0Q2hpbGREb20gPSBuZXdEb207XG5cdFx0XHR9XG5cblx0XHRcdGlmIChcblx0XHRcdFx0dHlwZW9mIGNoaWxkVk5vZGUudHlwZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0XHRcdGNoaWxkVk5vZGUuX2NoaWxkcmVuID09PSBvbGRWTm9kZS5fY2hpbGRyZW5cblx0XHRcdCkge1xuXHRcdFx0XHRjaGlsZFZOb2RlLl9uZXh0RG9tID0gb2xkRG9tID0gcmVvcmRlckNoaWxkcmVuKFxuXHRcdFx0XHRcdGNoaWxkVk5vZGUsXG5cdFx0XHRcdFx0b2xkRG9tLFxuXHRcdFx0XHRcdHBhcmVudERvbVxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2xkRG9tID0gcGxhY2VDaGlsZChcblx0XHRcdFx0XHRwYXJlbnREb20sXG5cdFx0XHRcdFx0Y2hpbGRWTm9kZSxcblx0XHRcdFx0XHRvbGRWTm9kZSxcblx0XHRcdFx0XHRvbGRDaGlsZHJlbixcblx0XHRcdFx0XHRuZXdEb20sXG5cdFx0XHRcdFx0b2xkRG9tXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0eXBlb2YgbmV3UGFyZW50Vk5vZGUudHlwZSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdC8vIEJlY2F1c2UgdGhlIG5ld1BhcmVudFZOb2RlIGlzIEZyYWdtZW50LWxpa2UsIHdlIG5lZWQgdG8gc2V0IGl0J3Ncblx0XHRcdFx0Ly8gX25leHREb20gcHJvcGVydHkgdG8gdGhlIG5leHRTaWJsaW5nIG9mIGl0cyBsYXN0IGNoaWxkIERPTSBub2RlLlxuXHRcdFx0XHQvL1xuXHRcdFx0XHQvLyBgb2xkRG9tYCBjb250YWlucyB0aGUgY29ycmVjdCB2YWx1ZSBoZXJlIGJlY2F1c2UgaWYgdGhlIGxhc3QgY2hpbGRcblx0XHRcdFx0Ly8gaXMgYSBGcmFnbWVudC1saWtlLCB0aGVuIG9sZERvbSBoYXMgYWxyZWFkeSBiZWVuIHNldCB0byB0aGF0IGNoaWxkJ3MgX25leHREb20uXG5cdFx0XHRcdC8vIElmIHRoZSBsYXN0IGNoaWxkIGlzIGEgRE9NIFZOb2RlLCB0aGVuIG9sZERvbSB3aWxsIGJlIHNldCB0byB0aGF0IERPTVxuXHRcdFx0XHQvLyBub2RlJ3MgbmV4dFNpYmxpbmcuXG5cdFx0XHRcdG5ld1BhcmVudFZOb2RlLl9uZXh0RG9tID0gb2xkRG9tO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRvbGREb20gJiZcblx0XHRcdG9sZFZOb2RlLl9kb20gPT0gb2xkRG9tICYmXG5cdFx0XHRvbGREb20ucGFyZW50Tm9kZSAhPSBwYXJlbnREb21cblx0XHQpIHtcblx0XHRcdC8vIFRoZSBhYm92ZSBjb25kaXRpb24gaXMgdG8gaGFuZGxlIG51bGwgcGxhY2Vob2xkZXJzLiBTZWUgdGVzdCBpbiBwbGFjZWhvbGRlci50ZXN0LmpzOlxuXHRcdFx0Ly8gYGVmZmljaWVudGx5IHJlcGxhY2UgbnVsbCBwbGFjZWhvbGRlcnMgaW4gcGFyZW50IHJlcmVuZGVyc2Bcblx0XHRcdG9sZERvbSA9IGdldERvbVNpYmxpbmcob2xkVk5vZGUpO1xuXHRcdH1cblx0fVxuXG5cdG5ld1BhcmVudFZOb2RlLl9kb20gPSBmaXJzdENoaWxkRG9tO1xuXG5cdC8vIFJlbW92ZSByZW1haW5pbmcgb2xkQ2hpbGRyZW4gaWYgdGhlcmUgYXJlIGFueS5cblx0Zm9yIChpID0gb2xkQ2hpbGRyZW5MZW5ndGg7IGktLTsgKSB7XG5cdFx0aWYgKG9sZENoaWxkcmVuW2ldICE9IG51bGwpIHtcblx0XHRcdGlmIChcblx0XHRcdFx0dHlwZW9mIG5ld1BhcmVudFZOb2RlLnR5cGUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdFx0XHRvbGRDaGlsZHJlbltpXS5fZG9tICE9IG51bGwgJiZcblx0XHRcdFx0b2xkQ2hpbGRyZW5baV0uX2RvbSA9PSBuZXdQYXJlbnRWTm9kZS5fbmV4dERvbVxuXHRcdFx0KSB7XG5cdFx0XHRcdC8vIElmIHRoZSBuZXdQYXJlbnRWTm9kZS5fX25leHREb20gcG9pbnRzIHRvIGEgZG9tIG5vZGUgdGhhdCBpcyBhYm91dCB0b1xuXHRcdFx0XHQvLyBiZSB1bm1vdW50ZWQsIHRoZW4gZ2V0IHRoZSBuZXh0IHNpYmxpbmcgb2YgdGhhdCB2bm9kZSBhbmQgc2V0XG5cdFx0XHRcdC8vIF9uZXh0RG9tIHRvIGl0XG5cdFx0XHRcdG5ld1BhcmVudFZOb2RlLl9uZXh0RG9tID0gZ2V0TGFzdERvbShvbGRQYXJlbnRWTm9kZSkubmV4dFNpYmxpbmc7XG5cdFx0XHR9XG5cblx0XHRcdHVubW91bnQob2xkQ2hpbGRyZW5baV0sIG9sZENoaWxkcmVuW2ldKTtcblx0XHR9XG5cdH1cblxuXHQvLyBTZXQgcmVmcyBvbmx5IGFmdGVyIHVubW91bnRcblx0aWYgKHJlZnMpIHtcblx0XHRmb3IgKGkgPSAwOyBpIDwgcmVmcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0YXBwbHlSZWYocmVmc1tpXSwgcmVmc1srK2ldLCByZWZzWysraV0pO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiByZW9yZGVyQ2hpbGRyZW4oY2hpbGRWTm9kZSwgb2xkRG9tLCBwYXJlbnREb20pIHtcblx0Ly8gTm90ZTogVk5vZGVzIGluIG5lc3RlZCBzdXNwZW5kZWQgdHJlZXMgbWF5IGJlIG1pc3NpbmcgX2NoaWxkcmVuLlxuXHRsZXQgYyA9IGNoaWxkVk5vZGUuX2NoaWxkcmVuO1xuXHRsZXQgdG1wID0gMDtcblx0Zm9yICg7IGMgJiYgdG1wIDwgYy5sZW5ndGg7IHRtcCsrKSB7XG5cdFx0bGV0IHZub2RlID0gY1t0bXBdO1xuXHRcdGlmICh2bm9kZSkge1xuXHRcdFx0Ly8gV2UgdHlwaWNhbGx5IGVudGVyIHRoaXMgY29kZSBwYXRoIG9uIHNDVSBiYWlsb3V0LCB3aGVyZSB3ZSBjb3B5XG5cdFx0XHQvLyBvbGRWTm9kZS5fY2hpbGRyZW4gdG8gbmV3Vk5vZGUuX2NoaWxkcmVuLiBJZiB0aGF0IGlzIHRoZSBjYXNlLCB3ZSBuZWVkXG5cdFx0XHQvLyB0byB1cGRhdGUgdGhlIG9sZCBjaGlsZHJlbidzIF9wYXJlbnQgcG9pbnRlciB0byBwb2ludCB0byB0aGUgbmV3Vk5vZGVcblx0XHRcdC8vIChjaGlsZFZOb2RlIGhlcmUpLlxuXHRcdFx0dm5vZGUuX3BhcmVudCA9IGNoaWxkVk5vZGU7XG5cblx0XHRcdGlmICh0eXBlb2Ygdm5vZGUudHlwZSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdG9sZERvbSA9IHJlb3JkZXJDaGlsZHJlbih2bm9kZSwgb2xkRG9tLCBwYXJlbnREb20pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2xkRG9tID0gcGxhY2VDaGlsZChwYXJlbnREb20sIHZub2RlLCB2bm9kZSwgYywgdm5vZGUuX2RvbSwgb2xkRG9tKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gb2xkRG9tO1xufVxuXG4vKipcbiAqIEZsYXR0ZW4gYW5kIGxvb3AgdGhyb3VnaCB0aGUgY2hpbGRyZW4gb2YgYSB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbmRleCcpLkNvbXBvbmVudENoaWxkcmVufSBjaGlsZHJlbiBUaGUgdW5mbGF0dGVuZWRcbiAqIGNoaWxkcmVuIG9mIGEgdmlydHVhbCBub2RlXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlW119XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0NoaWxkQXJyYXkoY2hpbGRyZW4sIG91dCkge1xuXHRvdXQgPSBvdXQgfHwgW107XG5cdGlmIChjaGlsZHJlbiA9PSBudWxsIHx8IHR5cGVvZiBjaGlsZHJlbiA9PSAnYm9vbGVhbicpIHtcblx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuXHRcdGNoaWxkcmVuLnNvbWUoY2hpbGQgPT4ge1xuXHRcdFx0dG9DaGlsZEFycmF5KGNoaWxkLCBvdXQpO1xuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdG91dC5wdXNoKGNoaWxkcmVuKTtcblx0fVxuXHRyZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiBwbGFjZUNoaWxkKFxuXHRwYXJlbnREb20sXG5cdGNoaWxkVk5vZGUsXG5cdG9sZFZOb2RlLFxuXHRvbGRDaGlsZHJlbixcblx0bmV3RG9tLFxuXHRvbGREb21cbikge1xuXHRsZXQgbmV4dERvbTtcblx0aWYgKGNoaWxkVk5vZGUuX25leHREb20gIT09IHVuZGVmaW5lZCkge1xuXHRcdC8vIE9ubHkgRnJhZ21lbnRzIG9yIGNvbXBvbmVudHMgdGhhdCByZXR1cm4gRnJhZ21lbnQgbGlrZSBWTm9kZXMgd2lsbFxuXHRcdC8vIGhhdmUgYSBub24tdW5kZWZpbmVkIF9uZXh0RG9tLiBDb250aW51ZSB0aGUgZGlmZiBmcm9tIHRoZSBzaWJsaW5nXG5cdFx0Ly8gb2YgbGFzdCBET00gY2hpbGQgb2YgdGhpcyBjaGlsZCBWTm9kZVxuXHRcdG5leHREb20gPSBjaGlsZFZOb2RlLl9uZXh0RG9tO1xuXG5cdFx0Ly8gRWFnZXJseSBjbGVhbnVwIF9uZXh0RG9tLiBXZSBkb24ndCBuZWVkIHRvIHBlcnNpc3QgdGhlIHZhbHVlIGJlY2F1c2Vcblx0XHQvLyBpdCBpcyBvbmx5IHVzZWQgYnkgYGRpZmZDaGlsZHJlbmAgdG8gZGV0ZXJtaW5lIHdoZXJlIHRvIHJlc3VtZSB0aGUgZGlmZiBhZnRlclxuXHRcdC8vIGRpZmZpbmcgQ29tcG9uZW50cyBhbmQgRnJhZ21lbnRzLiBPbmNlIHdlIHN0b3JlIGl0IHRoZSBuZXh0RE9NIGxvY2FsIHZhciwgd2Vcblx0XHQvLyBjYW4gY2xlYW4gdXAgdGhlIHByb3BlcnR5XG5cdFx0Y2hpbGRWTm9kZS5fbmV4dERvbSA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmIChcblx0XHRvbGRWTm9kZSA9PSBudWxsIHx8XG5cdFx0bmV3RG9tICE9IG9sZERvbSB8fFxuXHRcdG5ld0RvbS5wYXJlbnROb2RlID09IG51bGxcblx0KSB7XG5cdFx0b3V0ZXI6IGlmIChvbGREb20gPT0gbnVsbCB8fCBvbGREb20ucGFyZW50Tm9kZSAhPT0gcGFyZW50RG9tKSB7XG5cdFx0XHRwYXJlbnREb20uYXBwZW5kQ2hpbGQobmV3RG9tKTtcblx0XHRcdG5leHREb20gPSBudWxsO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBgajxvbGRDaGlsZHJlbkxlbmd0aDsgais9MmAgaXMgYW4gYWx0ZXJuYXRpdmUgdG8gYGorKzxvbGRDaGlsZHJlbkxlbmd0aC8yYFxuXHRcdFx0Zm9yIChcblx0XHRcdFx0bGV0IHNpYkRvbSA9IG9sZERvbSwgaiA9IDA7XG5cdFx0XHRcdChzaWJEb20gPSBzaWJEb20ubmV4dFNpYmxpbmcpICYmIGogPCBvbGRDaGlsZHJlbi5sZW5ndGg7XG5cdFx0XHRcdGogKz0gMVxuXHRcdFx0KSB7XG5cdFx0XHRcdGlmIChzaWJEb20gPT0gbmV3RG9tKSB7XG5cdFx0XHRcdFx0YnJlYWsgb3V0ZXI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHBhcmVudERvbS5pbnNlcnRCZWZvcmUobmV3RG9tLCBvbGREb20pO1xuXHRcdFx0bmV4dERvbSA9IG9sZERvbTtcblx0XHR9XG5cdH1cblxuXHQvLyBJZiB3ZSBoYXZlIHByZS1jYWxjdWxhdGVkIHRoZSBuZXh0RE9NIG5vZGUsIHVzZSBpdC4gRWxzZSBjYWxjdWxhdGUgaXQgbm93XG5cdC8vIFN0cmljdGx5IGNoZWNrIGZvciBgdW5kZWZpbmVkYCBoZXJlIGN1eiBgbnVsbGAgaXMgYSB2YWxpZCB2YWx1ZSBvZiBgbmV4dERvbWAuXG5cdC8vIFNlZSBtb3JlIGRldGFpbCBpbiBjcmVhdGUtZWxlbWVudC5qczpjcmVhdGVWTm9kZVxuXHRpZiAobmV4dERvbSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0b2xkRG9tID0gbmV4dERvbTtcblx0fSBlbHNlIHtcblx0XHRvbGREb20gPSBuZXdEb20ubmV4dFNpYmxpbmc7XG5cdH1cblxuXHRyZXR1cm4gb2xkRG9tO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICovXG5mdW5jdGlvbiBnZXRMYXN0RG9tKHZub2RlKSB7XG5cdGlmICh2bm9kZS50eXBlID09IG51bGwgfHwgdHlwZW9mIHZub2RlLnR5cGUgPT09ICdzdHJpbmcnKSB7XG5cdFx0cmV0dXJuIHZub2RlLl9kb207XG5cdH1cblxuXHRpZiAodm5vZGUuX2NoaWxkcmVuKSB7XG5cdFx0Zm9yIChsZXQgaSA9IHZub2RlLl9jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0bGV0IGNoaWxkID0gdm5vZGUuX2NoaWxkcmVuW2ldO1xuXHRcdFx0aWYgKGNoaWxkKSB7XG5cdFx0XHRcdGxldCBsYXN0RG9tID0gZ2V0TGFzdERvbShjaGlsZCk7XG5cdFx0XHRcdGlmIChsYXN0RG9tKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGxhc3REb207XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbnVsbDtcbn1cbiIsICJpbXBvcnQgeyBFTVBUWV9PQkogfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBnZXREb21TaWJsaW5nIH0gZnJvbSAnLi4vY29tcG9uZW50JztcbmltcG9ydCB7IEZyYWdtZW50IH0gZnJvbSAnLi4vY3JlYXRlLWVsZW1lbnQnO1xuaW1wb3J0IHsgZGlmZkNoaWxkcmVuIH0gZnJvbSAnLi9jaGlsZHJlbic7XG5pbXBvcnQgeyBkaWZmUHJvcHMsIHNldFByb3BlcnR5IH0gZnJvbSAnLi9wcm9wcyc7XG5pbXBvcnQgeyBhc3NpZ24sIHJlbW92ZU5vZGUsIHNsaWNlIH0gZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgb3B0aW9ucyBmcm9tICcuLi9vcHRpb25zJztcblxuLyoqXG4gKiBEaWZmIHR3byB2aXJ0dWFsIG5vZGVzIGFuZCBhcHBseSBwcm9wZXIgY2hhbmdlcyB0byB0aGUgRE9NXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBwYXJlbnREb20gVGhlIHBhcmVudCBvZiB0aGUgRE9NIGVsZW1lbnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBuZXdWTm9kZSBUaGUgbmV3IHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IG9sZFZOb2RlIFRoZSBvbGQgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gZ2xvYmFsQ29udGV4dCBUaGUgY3VycmVudCBjb250ZXh0IG9iamVjdC4gTW9kaWZpZWQgYnkgZ2V0Q2hpbGRDb250ZXh0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3ZnIFdoZXRoZXIgb3Igbm90IHRoaXMgZWxlbWVudCBpcyBhbiBTVkcgbm9kZVxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudD59IGV4Y2Vzc0RvbUNoaWxkcmVuXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5Db21wb25lbnQ+fSBjb21taXRRdWV1ZSBMaXN0IG9mIGNvbXBvbmVudHNcbiAqIHdoaWNoIGhhdmUgY2FsbGJhY2tzIHRvIGludm9rZSBpbiBjb21taXRSb290XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBvbGREb20gVGhlIGN1cnJlbnQgYXR0YWNoZWQgRE9NXG4gKiBlbGVtZW50IGFueSBuZXcgZG9tIGVsZW1lbnRzIHNob3VsZCBiZSBwbGFjZWQgYXJvdW5kLiBMaWtlbHkgYG51bGxgIG9uIGZpcnN0XG4gKiByZW5kZXIgKGV4Y2VwdCB3aGVuIGh5ZHJhdGluZykuIENhbiBiZSBhIHNpYmxpbmcgRE9NIGVsZW1lbnQgd2hlbiBkaWZmaW5nXG4gKiBGcmFnbWVudHMgdGhhdCBoYXZlIHNpYmxpbmdzLiBJbiBtb3N0IGNhc2VzLCBpdCBzdGFydHMgb3V0IGFzIGBvbGRDaGlsZHJlblswXS5fZG9tYC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzSHlkcmF0aW5nXSBXaGV0aGVyIG9yIG5vdCB3ZSBhcmUgaW4gaHlkcmF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaWZmKFxuXHRwYXJlbnREb20sXG5cdG5ld1ZOb2RlLFxuXHRvbGRWTm9kZSxcblx0Z2xvYmFsQ29udGV4dCxcblx0aXNTdmcsXG5cdGV4Y2Vzc0RvbUNoaWxkcmVuLFxuXHRjb21taXRRdWV1ZSxcblx0b2xkRG9tLFxuXHRpc0h5ZHJhdGluZ1xuKSB7XG5cdGxldCB0bXAsXG5cdFx0bmV3VHlwZSA9IG5ld1ZOb2RlLnR5cGU7XG5cblx0Ly8gV2hlbiBwYXNzaW5nIHRocm91Z2ggY3JlYXRlRWxlbWVudCBpdCBhc3NpZ25zIHRoZSBvYmplY3Rcblx0Ly8gY29uc3RydWN0b3IgYXMgdW5kZWZpbmVkLiBUaGlzIHRvIHByZXZlbnQgSlNPTi1pbmplY3Rpb24uXG5cdGlmIChuZXdWTm9kZS5jb25zdHJ1Y3RvciAhPT0gdW5kZWZpbmVkKSByZXR1cm4gbnVsbDtcblxuXHQvLyBJZiB0aGUgcHJldmlvdXMgZGlmZiBiYWlsZWQgb3V0LCByZXN1bWUgY3JlYXRpbmcvaHlkcmF0aW5nLlxuXHRpZiAob2xkVk5vZGUuX2h5ZHJhdGluZyAhPSBudWxsKSB7XG5cdFx0aXNIeWRyYXRpbmcgPSBvbGRWTm9kZS5faHlkcmF0aW5nO1xuXHRcdG9sZERvbSA9IG5ld1ZOb2RlLl9kb20gPSBvbGRWTm9kZS5fZG9tO1xuXHRcdC8vIGlmIHdlIHJlc3VtZSwgd2Ugd2FudCB0aGUgdHJlZSB0byBiZSBcInVubG9ja2VkXCJcblx0XHRuZXdWTm9kZS5faHlkcmF0aW5nID0gbnVsbDtcblx0XHRleGNlc3NEb21DaGlsZHJlbiA9IFtvbGREb21dO1xuXHR9XG5cblx0aWYgKCh0bXAgPSBvcHRpb25zLl9kaWZmKSkgdG1wKG5ld1ZOb2RlKTtcblxuXHR0cnkge1xuXHRcdG91dGVyOiBpZiAodHlwZW9mIG5ld1R5cGUgPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0bGV0IGMsIGlzTmV3LCBvbGRQcm9wcywgb2xkU3RhdGUsIHNuYXBzaG90LCBjbGVhclByb2Nlc3NpbmdFeGNlcHRpb247XG5cdFx0XHRsZXQgbmV3UHJvcHMgPSBuZXdWTm9kZS5wcm9wcztcblxuXHRcdFx0Ly8gTmVjZXNzYXJ5IGZvciBjcmVhdGVDb250ZXh0IGFwaS4gU2V0dGluZyB0aGlzIHByb3BlcnR5IHdpbGwgcGFzc1xuXHRcdFx0Ly8gdGhlIGNvbnRleHQgdmFsdWUgYXMgYHRoaXMuY29udGV4dGAganVzdCBmb3IgdGhpcyBjb21wb25lbnQuXG5cdFx0XHR0bXAgPSBuZXdUeXBlLmNvbnRleHRUeXBlO1xuXHRcdFx0bGV0IHByb3ZpZGVyID0gdG1wICYmIGdsb2JhbENvbnRleHRbdG1wLl9pZF07XG5cdFx0XHRsZXQgY29tcG9uZW50Q29udGV4dCA9IHRtcFxuXHRcdFx0XHQ/IHByb3ZpZGVyXG5cdFx0XHRcdFx0PyBwcm92aWRlci5wcm9wcy52YWx1ZVxuXHRcdFx0XHRcdDogdG1wLl9kZWZhdWx0VmFsdWVcblx0XHRcdFx0OiBnbG9iYWxDb250ZXh0O1xuXG5cdFx0XHQvLyBHZXQgY29tcG9uZW50IGFuZCBzZXQgaXQgdG8gYGNgXG5cdFx0XHRpZiAob2xkVk5vZGUuX2NvbXBvbmVudCkge1xuXHRcdFx0XHRjID0gbmV3Vk5vZGUuX2NvbXBvbmVudCA9IG9sZFZOb2RlLl9jb21wb25lbnQ7XG5cdFx0XHRcdGNsZWFyUHJvY2Vzc2luZ0V4Y2VwdGlvbiA9IGMuX3Byb2Nlc3NpbmdFeGNlcHRpb24gPSBjLl9wZW5kaW5nRXJyb3I7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBJbnN0YW50aWF0ZSB0aGUgbmV3IGNvbXBvbmVudFxuXHRcdFx0XHRpZiAoJ3Byb3RvdHlwZScgaW4gbmV3VHlwZSAmJiBuZXdUeXBlLnByb3RvdHlwZS5yZW5kZXIpIHtcblx0XHRcdFx0XHQvLyBAdHMtaWdub3JlIFRoZSBjaGVjayBhYm92ZSB2ZXJpZmllcyB0aGF0IG5ld1R5cGUgaXMgc3VwcG9zZSB0byBiZSBjb25zdHJ1Y3RlZFxuXHRcdFx0XHRcdG5ld1ZOb2RlLl9jb21wb25lbnQgPSBjID0gbmV3IG5ld1R5cGUobmV3UHJvcHMsIGNvbXBvbmVudENvbnRleHQpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5ldy1jYXBcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBAdHMtaWdub3JlIFRydXN0IG1lLCBDb21wb25lbnQgaW1wbGVtZW50cyB0aGUgaW50ZXJmYWNlIHdlIHdhbnRcblx0XHRcdFx0XHRuZXdWTm9kZS5fY29tcG9uZW50ID0gYyA9IG5ldyBDb21wb25lbnQobmV3UHJvcHMsIGNvbXBvbmVudENvbnRleHQpO1xuXHRcdFx0XHRcdGMuY29uc3RydWN0b3IgPSBuZXdUeXBlO1xuXHRcdFx0XHRcdGMucmVuZGVyID0gZG9SZW5kZXI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHByb3ZpZGVyKSBwcm92aWRlci5zdWIoYyk7XG5cblx0XHRcdFx0Yy5wcm9wcyA9IG5ld1Byb3BzO1xuXHRcdFx0XHRpZiAoIWMuc3RhdGUpIGMuc3RhdGUgPSB7fTtcblx0XHRcdFx0Yy5jb250ZXh0ID0gY29tcG9uZW50Q29udGV4dDtcblx0XHRcdFx0Yy5fZ2xvYmFsQ29udGV4dCA9IGdsb2JhbENvbnRleHQ7XG5cdFx0XHRcdGlzTmV3ID0gYy5fZGlydHkgPSB0cnVlO1xuXHRcdFx0XHRjLl9yZW5kZXJDYWxsYmFja3MgPSBbXTtcblx0XHRcdFx0Yy5fc3RhdGVDYWxsYmFja3MgPSBbXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSW52b2tlIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc1xuXHRcdFx0aWYgKGMuX25leHRTdGF0ZSA9PSBudWxsKSB7XG5cdFx0XHRcdGMuX25leHRTdGF0ZSA9IGMuc3RhdGU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChuZXdUeXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAhPSBudWxsKSB7XG5cdFx0XHRcdGlmIChjLl9uZXh0U3RhdGUgPT0gYy5zdGF0ZSkge1xuXHRcdFx0XHRcdGMuX25leHRTdGF0ZSA9IGFzc2lnbih7fSwgYy5fbmV4dFN0YXRlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGFzc2lnbihcblx0XHRcdFx0XHRjLl9uZXh0U3RhdGUsXG5cdFx0XHRcdFx0bmV3VHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV3UHJvcHMsIGMuX25leHRTdGF0ZSlcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0b2xkUHJvcHMgPSBjLnByb3BzO1xuXHRcdFx0b2xkU3RhdGUgPSBjLnN0YXRlO1xuXHRcdFx0Yy5fdm5vZGUgPSBuZXdWTm9kZTtcblxuXHRcdFx0Ly8gSW52b2tlIHByZS1yZW5kZXIgbGlmZWN5Y2xlIG1ldGhvZHNcblx0XHRcdGlmIChpc05ldykge1xuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0bmV3VHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT0gbnVsbCAmJlxuXHRcdFx0XHRcdGMuY29tcG9uZW50V2lsbE1vdW50ICE9IG51bGxcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0Yy5jb21wb25lbnRXaWxsTW91bnQoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjLmNvbXBvbmVudERpZE1vdW50ICE9IG51bGwpIHtcblx0XHRcdFx0XHRjLl9yZW5kZXJDYWxsYmFja3MucHVzaChjLmNvbXBvbmVudERpZE1vdW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdG5ld1R5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09IG51bGwgJiZcblx0XHRcdFx0XHRuZXdQcm9wcyAhPT0gb2xkUHJvcHMgJiZcblx0XHRcdFx0XHRjLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgIT0gbnVsbFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRjLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMsIGNvbXBvbmVudENvbnRleHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdCghYy5fZm9yY2UgJiZcblx0XHRcdFx0XHRcdGMuc2hvdWxkQ29tcG9uZW50VXBkYXRlICE9IG51bGwgJiZcblx0XHRcdFx0XHRcdGMuc2hvdWxkQ29tcG9uZW50VXBkYXRlKFxuXHRcdFx0XHRcdFx0XHRuZXdQcm9wcyxcblx0XHRcdFx0XHRcdFx0Yy5fbmV4dFN0YXRlLFxuXHRcdFx0XHRcdFx0XHRjb21wb25lbnRDb250ZXh0XG5cdFx0XHRcdFx0XHQpID09PSBmYWxzZSkgfHxcblx0XHRcdFx0XHRuZXdWTm9kZS5fb3JpZ2luYWwgPT09IG9sZFZOb2RlLl9vcmlnaW5hbFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHQvLyBNb3JlIGluZm8gYWJvdXQgdGhpcyBoZXJlOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9Kb3ZpRGVDcm9vY2svYmVjNWYyY2U5MzU0NGQyZTYwNzBlZjhlMDAzNmU0ZThcblx0XHRcdFx0XHRpZiAobmV3Vk5vZGUuX29yaWdpbmFsICE9PSBvbGRWTm9kZS5fb3JpZ2luYWwpIHtcblx0XHRcdFx0XHRcdC8vIFdoZW4gd2UgYXJlIGRlYWxpbmcgd2l0aCBhIGJhaWwgYmVjYXVzZSBvZiBzQ1Ugd2UgaGF2ZSB0byB1cGRhdGVcblx0XHRcdFx0XHRcdC8vIHRoZSBwcm9wcywgc3RhdGUgYW5kIGRpcnR5LXN0YXRlLlxuXHRcdFx0XHRcdFx0Ly8gd2hlbiB3ZSBhcmUgZGVhbGluZyB3aXRoIHN0cmljdC1lcXVhbGl0eSB3ZSBkb24ndCBhcyB0aGUgY2hpbGQgY291bGQgc3RpbGxcblx0XHRcdFx0XHRcdC8vIGJlIGRpcnRpZWQgc2VlICMzODgzXG5cdFx0XHRcdFx0XHRjLnByb3BzID0gbmV3UHJvcHM7XG5cdFx0XHRcdFx0XHRjLnN0YXRlID0gYy5fbmV4dFN0YXRlO1xuXHRcdFx0XHRcdFx0Yy5fZGlydHkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bmV3Vk5vZGUuX2RvbSA9IG9sZFZOb2RlLl9kb207XG5cdFx0XHRcdFx0bmV3Vk5vZGUuX2NoaWxkcmVuID0gb2xkVk5vZGUuX2NoaWxkcmVuO1xuXHRcdFx0XHRcdG5ld1ZOb2RlLl9jaGlsZHJlbi5mb3JFYWNoKHZub2RlID0+IHtcblx0XHRcdFx0XHRcdGlmICh2bm9kZSkgdm5vZGUuX3BhcmVudCA9IG5ld1ZOb2RlO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjLl9zdGF0ZUNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0Yy5fcmVuZGVyQ2FsbGJhY2tzLnB1c2goYy5fc3RhdGVDYWxsYmFja3NbaV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjLl9zdGF0ZUNhbGxiYWNrcyA9IFtdO1xuXG5cdFx0XHRcdFx0aWYgKGMuX3JlbmRlckNhbGxiYWNrcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdGNvbW1pdFF1ZXVlLnB1c2goYyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWsgb3V0ZXI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoYy5jb21wb25lbnRXaWxsVXBkYXRlICE9IG51bGwpIHtcblx0XHRcdFx0XHRjLmNvbXBvbmVudFdpbGxVcGRhdGUobmV3UHJvcHMsIGMuX25leHRTdGF0ZSwgY29tcG9uZW50Q29udGV4dCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoYy5jb21wb25lbnREaWRVcGRhdGUgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGMuX3JlbmRlckNhbGxiYWNrcy5wdXNoKCgpID0+IHtcblx0XHRcdFx0XHRcdGMuY29tcG9uZW50RGlkVXBkYXRlKG9sZFByb3BzLCBvbGRTdGF0ZSwgc25hcHNob3QpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGMuY29udGV4dCA9IGNvbXBvbmVudENvbnRleHQ7XG5cdFx0XHRjLnByb3BzID0gbmV3UHJvcHM7XG5cdFx0XHRjLl9wYXJlbnREb20gPSBwYXJlbnREb207XG5cblx0XHRcdGxldCByZW5kZXJIb29rID0gb3B0aW9ucy5fcmVuZGVyLFxuXHRcdFx0XHRjb3VudCA9IDA7XG5cdFx0XHRpZiAoJ3Byb3RvdHlwZScgaW4gbmV3VHlwZSAmJiBuZXdUeXBlLnByb3RvdHlwZS5yZW5kZXIpIHtcblx0XHRcdFx0Yy5zdGF0ZSA9IGMuX25leHRTdGF0ZTtcblx0XHRcdFx0Yy5fZGlydHkgPSBmYWxzZTtcblxuXHRcdFx0XHRpZiAocmVuZGVySG9vaykgcmVuZGVySG9vayhuZXdWTm9kZSk7XG5cblx0XHRcdFx0dG1wID0gYy5yZW5kZXIoYy5wcm9wcywgYy5zdGF0ZSwgYy5jb250ZXh0KTtcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGMuX3N0YXRlQ2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0Yy5fcmVuZGVyQ2FsbGJhY2tzLnB1c2goYy5fc3RhdGVDYWxsYmFja3NbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGMuX3N0YXRlQ2FsbGJhY2tzID0gW107XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0Yy5fZGlydHkgPSBmYWxzZTtcblx0XHRcdFx0XHRpZiAocmVuZGVySG9vaykgcmVuZGVySG9vayhuZXdWTm9kZSk7XG5cblx0XHRcdFx0XHR0bXAgPSBjLnJlbmRlcihjLnByb3BzLCBjLnN0YXRlLCBjLmNvbnRleHQpO1xuXG5cdFx0XHRcdFx0Ly8gSGFuZGxlIHNldFN0YXRlIGNhbGxlZCBpbiByZW5kZXIsIHNlZSAjMjU1M1xuXHRcdFx0XHRcdGMuc3RhdGUgPSBjLl9uZXh0U3RhdGU7XG5cdFx0XHRcdH0gd2hpbGUgKGMuX2RpcnR5ICYmICsrY291bnQgPCAyNSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhhbmRsZSBzZXRTdGF0ZSBjYWxsZWQgaW4gcmVuZGVyLCBzZWUgIzI1NTNcblx0XHRcdGMuc3RhdGUgPSBjLl9uZXh0U3RhdGU7XG5cblx0XHRcdGlmIChjLmdldENoaWxkQ29udGV4dCAhPSBudWxsKSB7XG5cdFx0XHRcdGdsb2JhbENvbnRleHQgPSBhc3NpZ24oYXNzaWduKHt9LCBnbG9iYWxDb250ZXh0KSwgYy5nZXRDaGlsZENvbnRleHQoKSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghaXNOZXcgJiYgYy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSAhPSBudWxsKSB7XG5cdFx0XHRcdHNuYXBzaG90ID0gYy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZShvbGRQcm9wcywgb2xkU3RhdGUpO1xuXHRcdFx0fVxuXG5cdFx0XHRsZXQgaXNUb3BMZXZlbEZyYWdtZW50ID1cblx0XHRcdFx0dG1wICE9IG51bGwgJiYgdG1wLnR5cGUgPT09IEZyYWdtZW50ICYmIHRtcC5rZXkgPT0gbnVsbDtcblx0XHRcdGxldCByZW5kZXJSZXN1bHQgPSBpc1RvcExldmVsRnJhZ21lbnQgPyB0bXAucHJvcHMuY2hpbGRyZW4gOiB0bXA7XG5cblx0XHRcdGRpZmZDaGlsZHJlbihcblx0XHRcdFx0cGFyZW50RG9tLFxuXHRcdFx0XHRBcnJheS5pc0FycmF5KHJlbmRlclJlc3VsdCkgPyByZW5kZXJSZXN1bHQgOiBbcmVuZGVyUmVzdWx0XSxcblx0XHRcdFx0bmV3Vk5vZGUsXG5cdFx0XHRcdG9sZFZOb2RlLFxuXHRcdFx0XHRnbG9iYWxDb250ZXh0LFxuXHRcdFx0XHRpc1N2Zyxcblx0XHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdFx0XHRcdGNvbW1pdFF1ZXVlLFxuXHRcdFx0XHRvbGREb20sXG5cdFx0XHRcdGlzSHlkcmF0aW5nXG5cdFx0XHQpO1xuXG5cdFx0XHRjLmJhc2UgPSBuZXdWTm9kZS5fZG9tO1xuXG5cdFx0XHQvLyBXZSBzdWNjZXNzZnVsbHkgcmVuZGVyZWQgdGhpcyBWTm9kZSwgdW5zZXQgYW55IHN0b3JlZCBoeWRyYXRpb24vYmFpbG91dCBzdGF0ZTpcblx0XHRcdG5ld1ZOb2RlLl9oeWRyYXRpbmcgPSBudWxsO1xuXG5cdFx0XHRpZiAoYy5fcmVuZGVyQ2FsbGJhY2tzLmxlbmd0aCkge1xuXHRcdFx0XHRjb21taXRRdWV1ZS5wdXNoKGMpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoY2xlYXJQcm9jZXNzaW5nRXhjZXB0aW9uKSB7XG5cdFx0XHRcdGMuX3BlbmRpbmdFcnJvciA9IGMuX3Byb2Nlc3NpbmdFeGNlcHRpb24gPSBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRjLl9mb3JjZSA9IGZhbHNlO1xuXHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRleGNlc3NEb21DaGlsZHJlbiA9PSBudWxsICYmXG5cdFx0XHRuZXdWTm9kZS5fb3JpZ2luYWwgPT09IG9sZFZOb2RlLl9vcmlnaW5hbFxuXHRcdCkge1xuXHRcdFx0bmV3Vk5vZGUuX2NoaWxkcmVuID0gb2xkVk5vZGUuX2NoaWxkcmVuO1xuXHRcdFx0bmV3Vk5vZGUuX2RvbSA9IG9sZFZOb2RlLl9kb207XG5cdFx0fSBlbHNlIHtcblx0XHRcdG5ld1ZOb2RlLl9kb20gPSBkaWZmRWxlbWVudE5vZGVzKFxuXHRcdFx0XHRvbGRWTm9kZS5fZG9tLFxuXHRcdFx0XHRuZXdWTm9kZSxcblx0XHRcdFx0b2xkVk5vZGUsXG5cdFx0XHRcdGdsb2JhbENvbnRleHQsXG5cdFx0XHRcdGlzU3ZnLFxuXHRcdFx0XHRleGNlc3NEb21DaGlsZHJlbixcblx0XHRcdFx0Y29tbWl0UXVldWUsXG5cdFx0XHRcdGlzSHlkcmF0aW5nXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGlmICgodG1wID0gb3B0aW9ucy5kaWZmZWQpKSB0bXAobmV3Vk5vZGUpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0bmV3Vk5vZGUuX29yaWdpbmFsID0gbnVsbDtcblx0XHQvLyBpZiBoeWRyYXRpbmcgb3IgY3JlYXRpbmcgaW5pdGlhbCB0cmVlLCBiYWlsb3V0IHByZXNlcnZlcyBET006XG5cdFx0aWYgKGlzSHlkcmF0aW5nIHx8IGV4Y2Vzc0RvbUNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRcdG5ld1ZOb2RlLl9kb20gPSBvbGREb207XG5cdFx0XHRuZXdWTm9kZS5faHlkcmF0aW5nID0gISFpc0h5ZHJhdGluZztcblx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuW2V4Y2Vzc0RvbUNoaWxkcmVuLmluZGV4T2Yob2xkRG9tKV0gPSBudWxsO1xuXHRcdFx0Ly8gXiBjb3VsZCBwb3NzaWJseSBiZSBzaW1wbGlmaWVkIHRvOlxuXHRcdFx0Ly8gZXhjZXNzRG9tQ2hpbGRyZW4ubGVuZ3RoID0gMDtcblx0XHR9XG5cdFx0b3B0aW9ucy5fY2F0Y2hFcnJvcihlLCBuZXdWTm9kZSwgb2xkVk5vZGUpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4uL2ludGVybmFsJykuQ29tcG9uZW50Pn0gY29tbWl0UXVldWUgTGlzdCBvZiBjb21wb25lbnRzXG4gKiB3aGljaCBoYXZlIGNhbGxiYWNrcyB0byBpbnZva2UgaW4gY29tbWl0Um9vdFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IHJvb3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbW1pdFJvb3QoY29tbWl0UXVldWUsIHJvb3QpIHtcblx0aWYgKG9wdGlvbnMuX2NvbW1pdCkgb3B0aW9ucy5fY29tbWl0KHJvb3QsIGNvbW1pdFF1ZXVlKTtcblxuXHRjb21taXRRdWV1ZS5zb21lKGMgPT4ge1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBAdHMtaWdub3JlIFJldXNlIHRoZSBjb21taXRRdWV1ZSB2YXJpYWJsZSBoZXJlIHNvIHRoZSB0eXBlIGNoYW5nZXNcblx0XHRcdGNvbW1pdFF1ZXVlID0gYy5fcmVuZGVyQ2FsbGJhY2tzO1xuXHRcdFx0Yy5fcmVuZGVyQ2FsbGJhY2tzID0gW107XG5cdFx0XHRjb21taXRRdWV1ZS5zb21lKGNiID0+IHtcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZSBTZWUgYWJvdmUgdHMtaWdub3JlIG9uIGNvbW1pdFF1ZXVlXG5cdFx0XHRcdGNiLmNhbGwoYyk7XG5cdFx0XHR9KTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRvcHRpb25zLl9jYXRjaEVycm9yKGUsIGMuX3Zub2RlKTtcblx0XHR9XG5cdH0pO1xufVxuXG4vKipcbiAqIERpZmYgdHdvIHZpcnR1YWwgbm9kZXMgcmVwcmVzZW50aW5nIERPTSBlbGVtZW50XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBkb20gVGhlIERPTSBlbGVtZW50IHJlcHJlc2VudGluZ1xuICogdGhlIHZpcnR1YWwgbm9kZXMgYmVpbmcgZGlmZmVkXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gbmV3Vk5vZGUgVGhlIG5ldyB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBvbGRWTm9kZSBUaGUgb2xkIHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IGdsb2JhbENvbnRleHQgVGhlIGN1cnJlbnQgY29udGV4dCBvYmplY3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdmcgV2hldGhlciBvciBub3QgdGhpcyBET00gbm9kZSBpcyBhbiBTVkcgbm9kZVxuICogQHBhcmFtIHsqfSBleGNlc3NEb21DaGlsZHJlblxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4uL2ludGVybmFsJykuQ29tcG9uZW50Pn0gY29tbWl0UXVldWUgTGlzdCBvZiBjb21wb25lbnRzXG4gKiB3aGljaCBoYXZlIGNhbGxiYWNrcyB0byBpbnZva2UgaW4gY29tbWl0Um9vdFxuICogQHBhcmFtIHtib29sZWFufSBpc0h5ZHJhdGluZyBXaGV0aGVyIG9yIG5vdCB3ZSBhcmUgaW4gaHlkcmF0aW9uXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9XG4gKi9cbmZ1bmN0aW9uIGRpZmZFbGVtZW50Tm9kZXMoXG5cdGRvbSxcblx0bmV3Vk5vZGUsXG5cdG9sZFZOb2RlLFxuXHRnbG9iYWxDb250ZXh0LFxuXHRpc1N2Zyxcblx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdGNvbW1pdFF1ZXVlLFxuXHRpc0h5ZHJhdGluZ1xuKSB7XG5cdGxldCBvbGRQcm9wcyA9IG9sZFZOb2RlLnByb3BzO1xuXHRsZXQgbmV3UHJvcHMgPSBuZXdWTm9kZS5wcm9wcztcblx0bGV0IG5vZGVUeXBlID0gbmV3Vk5vZGUudHlwZTtcblx0bGV0IGkgPSAwO1xuXG5cdC8vIFRyYWNrcyBlbnRlcmluZyBhbmQgZXhpdGluZyBTVkcgbmFtZXNwYWNlIHdoZW4gZGVzY2VuZGluZyB0aHJvdWdoIHRoZSB0cmVlLlxuXHRpZiAobm9kZVR5cGUgPT09ICdzdmcnKSBpc1N2ZyA9IHRydWU7XG5cblx0aWYgKGV4Y2Vzc0RvbUNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRmb3IgKDsgaSA8IGV4Y2Vzc0RvbUNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBjaGlsZCA9IGV4Y2Vzc0RvbUNoaWxkcmVuW2ldO1xuXG5cdFx0XHQvLyBpZiBuZXdWTm9kZSBtYXRjaGVzIGFuIGVsZW1lbnQgaW4gZXhjZXNzRG9tQ2hpbGRyZW4gb3IgdGhlIGBkb21gXG5cdFx0XHQvLyBhcmd1bWVudCBtYXRjaGVzIGFuIGVsZW1lbnQgaW4gZXhjZXNzRG9tQ2hpbGRyZW4sIHJlbW92ZSBpdCBmcm9tXG5cdFx0XHQvLyBleGNlc3NEb21DaGlsZHJlbiBzbyBpdCBpc24ndCBsYXRlciByZW1vdmVkIGluIGRpZmZDaGlsZHJlblxuXHRcdFx0aWYgKFxuXHRcdFx0XHRjaGlsZCAmJlxuXHRcdFx0XHQnc2V0QXR0cmlidXRlJyBpbiBjaGlsZCA9PT0gISFub2RlVHlwZSAmJlxuXHRcdFx0XHQobm9kZVR5cGUgPyBjaGlsZC5sb2NhbE5hbWUgPT09IG5vZGVUeXBlIDogY2hpbGQubm9kZVR5cGUgPT09IDMpXG5cdFx0XHQpIHtcblx0XHRcdFx0ZG9tID0gY2hpbGQ7XG5cdFx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuW2ldID0gbnVsbDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKGRvbSA9PSBudWxsKSB7XG5cdFx0aWYgKG5vZGVUeXBlID09PSBudWxsKSB7XG5cdFx0XHQvLyBAdHMtaWdub3JlIGNyZWF0ZVRleHROb2RlIHJldHVybnMgVGV4dCwgd2UgZXhwZWN0IFByZWFjdEVsZW1lbnRcblx0XHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShuZXdQcm9wcyk7XG5cdFx0fVxuXG5cdFx0aWYgKGlzU3ZnKSB7XG5cdFx0XHRkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXG5cdFx0XHRcdCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG5cdFx0XHRcdC8vIEB0cy1pZ25vcmUgV2Uga25vdyBgbmV3Vk5vZGUudHlwZWAgaXMgYSBzdHJpbmdcblx0XHRcdFx0bm9kZVR5cGVcblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXG5cdFx0XHRcdC8vIEB0cy1pZ25vcmUgV2Uga25vdyBgbmV3Vk5vZGUudHlwZWAgaXMgYSBzdHJpbmdcblx0XHRcdFx0bm9kZVR5cGUsXG5cdFx0XHRcdG5ld1Byb3BzLmlzICYmIG5ld1Byb3BzXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdC8vIHdlIGNyZWF0ZWQgYSBuZXcgcGFyZW50LCBzbyBub25lIG9mIHRoZSBwcmV2aW91c2x5IGF0dGFjaGVkIGNoaWxkcmVuIGNhbiBiZSByZXVzZWQ6XG5cdFx0ZXhjZXNzRG9tQ2hpbGRyZW4gPSBudWxsO1xuXHRcdC8vIHdlIGFyZSBjcmVhdGluZyBhIG5ldyBub2RlLCBzbyB3ZSBjYW4gYXNzdW1lIHRoaXMgaXMgYSBuZXcgc3VidHJlZSAoaW4gY2FzZSB3ZSBhcmUgaHlkcmF0aW5nKSwgdGhpcyBkZW9wdHMgdGhlIGh5ZHJhdGVcblx0XHRpc0h5ZHJhdGluZyA9IGZhbHNlO1xuXHR9XG5cblx0aWYgKG5vZGVUeXBlID09PSBudWxsKSB7XG5cdFx0Ly8gRHVyaW5nIGh5ZHJhdGlvbiwgd2Ugc3RpbGwgaGF2ZSB0byBzcGxpdCBtZXJnZWQgdGV4dCBmcm9tIFNTUidkIEhUTUwuXG5cdFx0aWYgKG9sZFByb3BzICE9PSBuZXdQcm9wcyAmJiAoIWlzSHlkcmF0aW5nIHx8IGRvbS5kYXRhICE9PSBuZXdQcm9wcykpIHtcblx0XHRcdGRvbS5kYXRhID0gbmV3UHJvcHM7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdC8vIElmIGV4Y2Vzc0RvbUNoaWxkcmVuIHdhcyBub3QgbnVsbCwgcmVwb3B1bGF0ZSBpdCB3aXRoIHRoZSBjdXJyZW50IGVsZW1lbnQncyBjaGlsZHJlbjpcblx0XHRleGNlc3NEb21DaGlsZHJlbiA9IGV4Y2Vzc0RvbUNoaWxkcmVuICYmIHNsaWNlLmNhbGwoZG9tLmNoaWxkTm9kZXMpO1xuXG5cdFx0b2xkUHJvcHMgPSBvbGRWTm9kZS5wcm9wcyB8fCBFTVBUWV9PQko7XG5cblx0XHRsZXQgb2xkSHRtbCA9IG9sZFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MO1xuXHRcdGxldCBuZXdIdG1sID0gbmV3UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw7XG5cblx0XHQvLyBEdXJpbmcgaHlkcmF0aW9uLCBwcm9wcyBhcmUgbm90IGRpZmZlZCBhdCBhbGwgKGluY2x1ZGluZyBkYW5nZXJvdXNseVNldElubmVySFRNTClcblx0XHQvLyBAVE9ETyB3ZSBzaG91bGQgd2FybiBpbiBkZWJ1ZyBtb2RlIHdoZW4gcHJvcHMgZG9uJ3QgbWF0Y2ggaGVyZS5cblx0XHRpZiAoIWlzSHlkcmF0aW5nKSB7XG5cdFx0XHQvLyBCdXQsIGlmIHdlIGFyZSBpbiBhIHNpdHVhdGlvbiB3aGVyZSB3ZSBhcmUgdXNpbmcgZXhpc3RpbmcgRE9NIChlLmcuIHJlcGxhY2VOb2RlKVxuXHRcdFx0Ly8gd2Ugc2hvdWxkIHJlYWQgdGhlIGV4aXN0aW5nIERPTSBhdHRyaWJ1dGVzIHRvIGRpZmYgdGhlbVxuXHRcdFx0aWYgKGV4Y2Vzc0RvbUNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRcdFx0b2xkUHJvcHMgPSB7fTtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGRvbS5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0b2xkUHJvcHNbZG9tLmF0dHJpYnV0ZXNbaV0ubmFtZV0gPSBkb20uYXR0cmlidXRlc1tpXS52YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAobmV3SHRtbCB8fCBvbGRIdG1sKSB7XG5cdFx0XHRcdC8vIEF2b2lkIHJlLWFwcGx5aW5nIHRoZSBzYW1lICdfX2h0bWwnIGlmIGl0IGRpZCBub3QgY2hhbmdlZCBiZXR3ZWVuIHJlLXJlbmRlclxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0IW5ld0h0bWwgfHxcblx0XHRcdFx0XHQoKCFvbGRIdG1sIHx8IG5ld0h0bWwuX19odG1sICE9IG9sZEh0bWwuX19odG1sKSAmJlxuXHRcdFx0XHRcdFx0bmV3SHRtbC5fX2h0bWwgIT09IGRvbS5pbm5lckhUTUwpXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGRvbS5pbm5lckhUTUwgPSAobmV3SHRtbCAmJiBuZXdIdG1sLl9faHRtbCkgfHwgJyc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRkaWZmUHJvcHMoZG9tLCBuZXdQcm9wcywgb2xkUHJvcHMsIGlzU3ZnLCBpc0h5ZHJhdGluZyk7XG5cblx0XHQvLyBJZiB0aGUgbmV3IHZub2RlIGRpZG4ndCBoYXZlIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLCBkaWZmIGl0cyBjaGlsZHJlblxuXHRcdGlmIChuZXdIdG1sKSB7XG5cdFx0XHRuZXdWTm9kZS5fY2hpbGRyZW4gPSBbXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aSA9IG5ld1ZOb2RlLnByb3BzLmNoaWxkcmVuO1xuXHRcdFx0ZGlmZkNoaWxkcmVuKFxuXHRcdFx0XHRkb20sXG5cdFx0XHRcdEFycmF5LmlzQXJyYXkoaSkgPyBpIDogW2ldLFxuXHRcdFx0XHRuZXdWTm9kZSxcblx0XHRcdFx0b2xkVk5vZGUsXG5cdFx0XHRcdGdsb2JhbENvbnRleHQsXG5cdFx0XHRcdGlzU3ZnICYmIG5vZGVUeXBlICE9PSAnZm9yZWlnbk9iamVjdCcsXG5cdFx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuLFxuXHRcdFx0XHRjb21taXRRdWV1ZSxcblx0XHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW5cblx0XHRcdFx0XHQ/IGV4Y2Vzc0RvbUNoaWxkcmVuWzBdXG5cdFx0XHRcdFx0OiBvbGRWTm9kZS5fY2hpbGRyZW4gJiYgZ2V0RG9tU2libGluZyhvbGRWTm9kZSwgMCksXG5cdFx0XHRcdGlzSHlkcmF0aW5nXG5cdFx0XHQpO1xuXG5cdFx0XHQvLyBSZW1vdmUgY2hpbGRyZW4gdGhhdCBhcmUgbm90IHBhcnQgb2YgYW55IHZub2RlLlxuXHRcdFx0aWYgKGV4Y2Vzc0RvbUNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRcdFx0Zm9yIChpID0gZXhjZXNzRG9tQ2hpbGRyZW4ubGVuZ3RoOyBpLS07ICkge1xuXHRcdFx0XHRcdGlmIChleGNlc3NEb21DaGlsZHJlbltpXSAhPSBudWxsKSByZW1vdmVOb2RlKGV4Y2Vzc0RvbUNoaWxkcmVuW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIChhcyBhYm92ZSwgZG9uJ3QgZGlmZiBwcm9wcyBkdXJpbmcgaHlkcmF0aW9uKVxuXHRcdGlmICghaXNIeWRyYXRpbmcpIHtcblx0XHRcdGlmIChcblx0XHRcdFx0J3ZhbHVlJyBpbiBuZXdQcm9wcyAmJlxuXHRcdFx0XHQoaSA9IG5ld1Byb3BzLnZhbHVlKSAhPT0gdW5kZWZpbmVkICYmXG5cdFx0XHRcdC8vICMyNzU2IEZvciB0aGUgPHByb2dyZXNzPi1lbGVtZW50IHRoZSBpbml0aWFsIHZhbHVlIGlzIDAsXG5cdFx0XHRcdC8vIGRlc3BpdGUgdGhlIGF0dHJpYnV0ZSBub3QgYmVpbmcgcHJlc2VudC4gV2hlbiB0aGUgYXR0cmlidXRlXG5cdFx0XHRcdC8vIGlzIG1pc3NpbmcgdGhlIHByb2dyZXNzIGJhciBpcyB0cmVhdGVkIGFzIGluZGV0ZXJtaW5hdGUuXG5cdFx0XHRcdC8vIFRvIGZpeCB0aGF0IHdlJ2xsIGFsd2F5cyB1cGRhdGUgaXQgd2hlbiBpdCBpcyAwIGZvciBwcm9ncmVzcyBlbGVtZW50c1xuXHRcdFx0XHQoaSAhPT0gZG9tLnZhbHVlIHx8XG5cdFx0XHRcdFx0KG5vZGVUeXBlID09PSAncHJvZ3Jlc3MnICYmICFpKSB8fFxuXHRcdFx0XHRcdC8vIFRoaXMgaXMgb25seSBmb3IgSUUgMTEgdG8gZml4IDxzZWxlY3Q+IHZhbHVlIG5vdCBiZWluZyB1cGRhdGVkLlxuXHRcdFx0XHRcdC8vIFRvIGF2b2lkIGEgc3RhbGUgc2VsZWN0IHZhbHVlIHdlIG5lZWQgdG8gc2V0IHRoZSBvcHRpb24udmFsdWVcblx0XHRcdFx0XHQvLyBhZ2Fpbiwgd2hpY2ggdHJpZ2dlcnMgSUUxMSB0byByZS1ldmFsdWF0ZSB0aGUgc2VsZWN0IHZhbHVlXG5cdFx0XHRcdFx0KG5vZGVUeXBlID09PSAnb3B0aW9uJyAmJiBpICE9PSBvbGRQcm9wcy52YWx1ZSkpXG5cdFx0XHQpIHtcblx0XHRcdFx0c2V0UHJvcGVydHkoZG9tLCAndmFsdWUnLCBpLCBvbGRQcm9wcy52YWx1ZSwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKFxuXHRcdFx0XHQnY2hlY2tlZCcgaW4gbmV3UHJvcHMgJiZcblx0XHRcdFx0KGkgPSBuZXdQcm9wcy5jaGVja2VkKSAhPT0gdW5kZWZpbmVkICYmXG5cdFx0XHRcdGkgIT09IGRvbS5jaGVja2VkXG5cdFx0XHQpIHtcblx0XHRcdFx0c2V0UHJvcGVydHkoZG9tLCAnY2hlY2tlZCcsIGksIG9sZFByb3BzLmNoZWNrZWQsIGZhbHNlKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZG9tO1xufVxuXG4vKipcbiAqIEludm9rZSBvciB1cGRhdGUgYSByZWYsIGRlcGVuZGluZyBvbiB3aGV0aGVyIGl0IGlzIGEgZnVuY3Rpb24gb3Igb2JqZWN0IHJlZi5cbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSByZWZcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IHZub2RlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVJlZihyZWYsIHZhbHVlLCB2bm9kZSkge1xuXHR0cnkge1xuXHRcdGlmICh0eXBlb2YgcmVmID09ICdmdW5jdGlvbicpIHJlZih2YWx1ZSk7XG5cdFx0ZWxzZSByZWYuY3VycmVudCA9IHZhbHVlO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0b3B0aW9ucy5fY2F0Y2hFcnJvcihlLCB2bm9kZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBVbm1vdW50IGEgdmlydHVhbCBub2RlIGZyb20gdGhlIHRyZWUgYW5kIGFwcGx5IERPTSBjaGFuZ2VzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGUgVGhlIHZpcnR1YWwgbm9kZSB0byB1bm1vdW50XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gcGFyZW50Vk5vZGUgVGhlIHBhcmVudCBvZiB0aGUgVk5vZGUgdGhhdFxuICogaW5pdGlhdGVkIHRoZSB1bm1vdW50XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtza2lwUmVtb3ZlXSBGbGFnIHRoYXQgaW5kaWNhdGVzIHRoYXQgYSBwYXJlbnQgbm9kZSBvZiB0aGVcbiAqIGN1cnJlbnQgZWxlbWVudCBpcyBhbHJlYWR5IGRldGFjaGVkIGZyb20gdGhlIERPTS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVubW91bnQodm5vZGUsIHBhcmVudFZOb2RlLCBza2lwUmVtb3ZlKSB7XG5cdGxldCByO1xuXHRpZiAob3B0aW9ucy51bm1vdW50KSBvcHRpb25zLnVubW91bnQodm5vZGUpO1xuXG5cdGlmICgociA9IHZub2RlLnJlZikpIHtcblx0XHRpZiAoIXIuY3VycmVudCB8fCByLmN1cnJlbnQgPT09IHZub2RlLl9kb20pIHtcblx0XHRcdGFwcGx5UmVmKHIsIG51bGwsIHBhcmVudFZOb2RlKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoKHIgPSB2bm9kZS5fY29tcG9uZW50KSAhPSBudWxsKSB7XG5cdFx0aWYgKHIuY29tcG9uZW50V2lsbFVubW91bnQpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHIuY29tcG9uZW50V2lsbFVubW91bnQoKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0b3B0aW9ucy5fY2F0Y2hFcnJvcihlLCBwYXJlbnRWTm9kZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ci5iYXNlID0gci5fcGFyZW50RG9tID0gbnVsbDtcblx0XHR2bm9kZS5fY29tcG9uZW50ID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0aWYgKChyID0gdm5vZGUuX2NoaWxkcmVuKSkge1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgci5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHJbaV0pIHtcblx0XHRcdFx0dW5tb3VudChcblx0XHRcdFx0XHRyW2ldLFxuXHRcdFx0XHRcdHBhcmVudFZOb2RlLFxuXHRcdFx0XHRcdHNraXBSZW1vdmUgfHwgdHlwZW9mIHZub2RlLnR5cGUgIT09ICdmdW5jdGlvbidcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoIXNraXBSZW1vdmUgJiYgdm5vZGUuX2RvbSAhPSBudWxsKSB7XG5cdFx0cmVtb3ZlTm9kZSh2bm9kZS5fZG9tKTtcblx0fVxuXG5cdC8vIE11c3QgYmUgc2V0IHRvIGB1bmRlZmluZWRgIHRvIHByb3Blcmx5IGNsZWFuIHVwIGBfbmV4dERvbWBcblx0Ly8gZm9yIHdoaWNoIGBudWxsYCBpcyBhIHZhbGlkIHZhbHVlLiBTZWUgY29tbWVudCBpbiBgY3JlYXRlLWVsZW1lbnQuanNgXG5cdHZub2RlLl9wYXJlbnQgPSB2bm9kZS5fZG9tID0gdm5vZGUuX25leHREb20gPSB1bmRlZmluZWQ7XG59XG5cbi8qKiBUaGUgYC5yZW5kZXIoKWAgbWV0aG9kIGZvciBhIFBGQyBiYWNraW5nIGluc3RhbmNlLiAqL1xuZnVuY3Rpb24gZG9SZW5kZXIocHJvcHMsIHN0YXRlLCBjb250ZXh0KSB7XG5cdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKHByb3BzLCBjb250ZXh0KTtcbn1cbiIsICJpbXBvcnQgeyBFTVBUWV9PQkogfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBjb21taXRSb290LCBkaWZmIH0gZnJvbSAnLi9kaWZmL2luZGV4JztcbmltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIEZyYWdtZW50IH0gZnJvbSAnLi9jcmVhdGUtZWxlbWVudCc7XG5pbXBvcnQgb3B0aW9ucyBmcm9tICcuL29wdGlvbnMnO1xuaW1wb3J0IHsgc2xpY2UgfSBmcm9tICcuL3V0aWwnO1xuXG4vKipcbiAqIFJlbmRlciBhIFByZWFjdCB2aXJ0dWFsIG5vZGUgaW50byBhIERPTSBlbGVtZW50XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudENoaWxkfSB2bm9kZSBUaGUgdmlydHVhbCBub2RlIHRvIHJlbmRlclxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBwYXJlbnREb20gVGhlIERPTSBlbGVtZW50IHRvXG4gKiByZW5kZXIgaW50b1xuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50IHwgb2JqZWN0fSBbcmVwbGFjZU5vZGVdIE9wdGlvbmFsOiBBdHRlbXB0IHRvIHJlLXVzZSBhblxuICogZXhpc3RpbmcgRE9NIHRyZWUgcm9vdGVkIGF0IGByZXBsYWNlTm9kZWBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcih2bm9kZSwgcGFyZW50RG9tLCByZXBsYWNlTm9kZSkge1xuXHRpZiAob3B0aW9ucy5fcm9vdCkgb3B0aW9ucy5fcm9vdCh2bm9kZSwgcGFyZW50RG9tKTtcblxuXHQvLyBXZSBhYnVzZSB0aGUgYHJlcGxhY2VOb2RlYCBwYXJhbWV0ZXIgaW4gYGh5ZHJhdGUoKWAgdG8gc2lnbmFsIGlmIHdlIGFyZSBpblxuXHQvLyBoeWRyYXRpb24gbW9kZSBvciBub3QgYnkgcGFzc2luZyB0aGUgYGh5ZHJhdGVgIGZ1bmN0aW9uIGluc3RlYWQgb2YgYSBET01cblx0Ly8gZWxlbWVudC4uXG5cdGxldCBpc0h5ZHJhdGluZyA9IHR5cGVvZiByZXBsYWNlTm9kZSA9PT0gJ2Z1bmN0aW9uJztcblxuXHQvLyBUbyBiZSBhYmxlIHRvIHN1cHBvcnQgY2FsbGluZyBgcmVuZGVyKClgIG11bHRpcGxlIHRpbWVzIG9uIHRoZSBzYW1lXG5cdC8vIERPTSBub2RlLCB3ZSBuZWVkIHRvIG9idGFpbiBhIHJlZmVyZW5jZSB0byB0aGUgcHJldmlvdXMgdHJlZS4gV2UgZG9cblx0Ly8gdGhpcyBieSBhc3NpZ25pbmcgYSBuZXcgYF9jaGlsZHJlbmAgcHJvcGVydHkgdG8gRE9NIG5vZGVzIHdoaWNoIHBvaW50c1xuXHQvLyB0byB0aGUgbGFzdCByZW5kZXJlZCB0cmVlLiBCeSBkZWZhdWx0IHRoaXMgcHJvcGVydHkgaXMgbm90IHByZXNlbnQsIHdoaWNoXG5cdC8vIG1lYW5zIHRoYXQgd2UgYXJlIG1vdW50aW5nIGEgbmV3IHRyZWUgZm9yIHRoZSBmaXJzdCB0aW1lLlxuXHRsZXQgb2xkVk5vZGUgPSBpc0h5ZHJhdGluZ1xuXHRcdD8gbnVsbFxuXHRcdDogKHJlcGxhY2VOb2RlICYmIHJlcGxhY2VOb2RlLl9jaGlsZHJlbikgfHwgcGFyZW50RG9tLl9jaGlsZHJlbjtcblxuXHR2bm9kZSA9IChcblx0XHQoIWlzSHlkcmF0aW5nICYmIHJlcGxhY2VOb2RlKSB8fFxuXHRcdHBhcmVudERvbVxuXHQpLl9jaGlsZHJlbiA9IGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIFt2bm9kZV0pO1xuXG5cdC8vIExpc3Qgb2YgZWZmZWN0cyB0aGF0IG5lZWQgdG8gYmUgY2FsbGVkIGFmdGVyIGRpZmZpbmcuXG5cdGxldCBjb21taXRRdWV1ZSA9IFtdO1xuXHRkaWZmKFxuXHRcdHBhcmVudERvbSxcblx0XHQvLyBEZXRlcm1pbmUgdGhlIG5ldyB2bm9kZSB0cmVlIGFuZCBzdG9yZSBpdCBvbiB0aGUgRE9NIGVsZW1lbnQgb25cblx0XHQvLyBvdXIgY3VzdG9tIGBfY2hpbGRyZW5gIHByb3BlcnR5LlxuXHRcdHZub2RlLFxuXHRcdG9sZFZOb2RlIHx8IEVNUFRZX09CSixcblx0XHRFTVBUWV9PQkosXG5cdFx0cGFyZW50RG9tLm93bmVyU1ZHRWxlbWVudCAhPT0gdW5kZWZpbmVkLFxuXHRcdCFpc0h5ZHJhdGluZyAmJiByZXBsYWNlTm9kZVxuXHRcdFx0PyBbcmVwbGFjZU5vZGVdXG5cdFx0XHQ6IG9sZFZOb2RlXG5cdFx0XHQ/IG51bGxcblx0XHRcdDogcGFyZW50RG9tLmZpcnN0Q2hpbGRcblx0XHRcdD8gc2xpY2UuY2FsbChwYXJlbnREb20uY2hpbGROb2Rlcylcblx0XHRcdDogbnVsbCxcblx0XHRjb21taXRRdWV1ZSxcblx0XHQhaXNIeWRyYXRpbmcgJiYgcmVwbGFjZU5vZGVcblx0XHRcdD8gcmVwbGFjZU5vZGVcblx0XHRcdDogb2xkVk5vZGVcblx0XHRcdD8gb2xkVk5vZGUuX2RvbVxuXHRcdFx0OiBwYXJlbnREb20uZmlyc3RDaGlsZCxcblx0XHRpc0h5ZHJhdGluZ1xuXHQpO1xuXG5cdC8vIEZsdXNoIGFsbCBxdWV1ZWQgZWZmZWN0c1xuXHRjb21taXRSb290KGNvbW1pdFF1ZXVlLCB2bm9kZSk7XG59XG5cbi8qKlxuICogVXBkYXRlIGFuIGV4aXN0aW5nIERPTSBlbGVtZW50IHdpdGggZGF0YSBmcm9tIGEgUHJlYWN0IHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnRDaGlsZH0gdm5vZGUgVGhlIHZpcnR1YWwgbm9kZSB0byByZW5kZXJcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gcGFyZW50RG9tIFRoZSBET00gZWxlbWVudCB0b1xuICogdXBkYXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoeWRyYXRlKHZub2RlLCBwYXJlbnREb20pIHtcblx0cmVuZGVyKHZub2RlLCBwYXJlbnREb20sIGh5ZHJhdGUpO1xufVxuIiwgImltcG9ydCB7IGFzc2lnbiwgc2xpY2UgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsgY3JlYXRlVk5vZGUgfSBmcm9tICcuL2NyZWF0ZS1lbGVtZW50JztcblxuLyoqXG4gKiBDbG9uZXMgdGhlIGdpdmVuIFZOb2RlLCBvcHRpb25hbGx5IGFkZGluZyBhdHRyaWJ1dGVzL3Byb3BzIGFuZCByZXBsYWNpbmcgaXRzIGNoaWxkcmVuLlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGUgVGhlIHZpcnR1YWwgRE9NIGVsZW1lbnQgdG8gY2xvbmVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcyBBdHRyaWJ1dGVzL3Byb3BzIHRvIGFkZCB3aGVuIGNsb25pbmdcbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50Q2hpbGRyZW4+fSByZXN0IEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyB3aWxsIGJlIHVzZWQgYXMgcmVwbGFjZW1lbnQgY2hpbGRyZW4uXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZUVsZW1lbnQodm5vZGUsIHByb3BzLCBjaGlsZHJlbikge1xuXHRsZXQgbm9ybWFsaXplZFByb3BzID0gYXNzaWduKHt9LCB2bm9kZS5wcm9wcyksXG5cdFx0a2V5LFxuXHRcdHJlZixcblx0XHRpO1xuXHRmb3IgKGkgaW4gcHJvcHMpIHtcblx0XHRpZiAoaSA9PSAna2V5Jykga2V5ID0gcHJvcHNbaV07XG5cdFx0ZWxzZSBpZiAoaSA9PSAncmVmJykgcmVmID0gcHJvcHNbaV07XG5cdFx0ZWxzZSBub3JtYWxpemVkUHJvcHNbaV0gPSBwcm9wc1tpXTtcblx0fVxuXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuXHRcdG5vcm1hbGl6ZWRQcm9wcy5jaGlsZHJlbiA9XG5cdFx0XHRhcmd1bWVudHMubGVuZ3RoID4gMyA/IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSA6IGNoaWxkcmVuO1xuXHR9XG5cblx0cmV0dXJuIGNyZWF0ZVZOb2RlKFxuXHRcdHZub2RlLnR5cGUsXG5cdFx0bm9ybWFsaXplZFByb3BzLFxuXHRcdGtleSB8fCB2bm9kZS5rZXksXG5cdFx0cmVmIHx8IHZub2RlLnJlZixcblx0XHRudWxsXG5cdCk7XG59XG4iLCAiLyoqXG4gKiBGaW5kIHRoZSBjbG9zZXN0IGVycm9yIGJvdW5kYXJ5IHRvIGEgdGhyb3duIGVycm9yIGFuZCBjYWxsIGl0XG4gKiBAcGFyYW0ge29iamVjdH0gZXJyb3IgVGhlIHRocm93biB2YWx1ZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IHZub2RlIFRoZSB2bm9kZSB0aGF0IHRocmV3XG4gKiB0aGUgZXJyb3IgdGhhdCB3YXMgY2F1Z2h0IChleGNlcHQgZm9yIHVubW91bnRpbmcgd2hlbiB0aGlzIHBhcmFtZXRlclxuICogaXMgdGhlIGhpZ2hlc3QgcGFyZW50IHRoYXQgd2FzIGJlaW5nIHVubW91bnRlZClcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBbb2xkVk5vZGVdXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5FcnJvckluZm99IFtlcnJvckluZm9dXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfY2F0Y2hFcnJvcihlcnJvciwgdm5vZGUsIG9sZFZOb2RlLCBlcnJvckluZm8pIHtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4uL2ludGVybmFsJykuQ29tcG9uZW50fSAqL1xuXHRsZXQgY29tcG9uZW50LCBjdG9yLCBoYW5kbGVkO1xuXG5cdGZvciAoOyAodm5vZGUgPSB2bm9kZS5fcGFyZW50KTsgKSB7XG5cdFx0aWYgKChjb21wb25lbnQgPSB2bm9kZS5fY29tcG9uZW50KSAmJiAhY29tcG9uZW50Ll9wcm9jZXNzaW5nRXhjZXB0aW9uKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjdG9yID0gY29tcG9uZW50LmNvbnN0cnVjdG9yO1xuXG5cdFx0XHRcdGlmIChjdG9yICYmIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yICE9IG51bGwpIHtcblx0XHRcdFx0XHRjb21wb25lbnQuc2V0U3RhdGUoY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3IpKTtcblx0XHRcdFx0XHRoYW5kbGVkID0gY29tcG9uZW50Ll9kaXJ0eTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjb21wb25lbnQuY29tcG9uZW50RGlkQ2F0Y2ggIT0gbnVsbCkge1xuXHRcdFx0XHRcdGNvbXBvbmVudC5jb21wb25lbnREaWRDYXRjaChlcnJvciwgZXJyb3JJbmZvIHx8IHt9KTtcblx0XHRcdFx0XHRoYW5kbGVkID0gY29tcG9uZW50Ll9kaXJ0eTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRoaXMgaXMgYW4gZXJyb3IgYm91bmRhcnkuIE1hcmsgaXQgYXMgaGF2aW5nIGJhaWxlZCBvdXQsIGFuZCB3aGV0aGVyIGl0IHdhcyBtaWQtaHlkcmF0aW9uLlxuXHRcdFx0XHRpZiAoaGFuZGxlZCkge1xuXHRcdFx0XHRcdHJldHVybiAoY29tcG9uZW50Ll9wZW5kaW5nRXJyb3IgPSBjb21wb25lbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdGVycm9yID0gZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHR0aHJvdyBlcnJvcjtcbn1cbiIsICJpbXBvcnQgeyBvcHRpb25zIH0gZnJvbSAncHJlYWN0JztcblxuLyoqIEB0eXBlIHtudW1iZXJ9ICovXG5sZXQgY3VycmVudEluZGV4O1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gKi9cbmxldCBjdXJyZW50Q29tcG9uZW50O1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gKi9cbmxldCBwcmV2aW91c0NvbXBvbmVudDtcblxuLyoqIEB0eXBlIHtudW1iZXJ9ICovXG5sZXQgY3VycmVudEhvb2sgPSAwO1xuXG4vKiogQHR5cGUge0FycmF5PGltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59ICovXG5sZXQgYWZ0ZXJQYWludEVmZmVjdHMgPSBbXTtcblxubGV0IEVNUFRZID0gW107XG5cbmxldCBvbGRCZWZvcmVEaWZmID0gb3B0aW9ucy5fZGlmZjtcbmxldCBvbGRCZWZvcmVSZW5kZXIgPSBvcHRpb25zLl9yZW5kZXI7XG5sZXQgb2xkQWZ0ZXJEaWZmID0gb3B0aW9ucy5kaWZmZWQ7XG5sZXQgb2xkQ29tbWl0ID0gb3B0aW9ucy5fY29tbWl0O1xubGV0IG9sZEJlZm9yZVVubW91bnQgPSBvcHRpb25zLnVubW91bnQ7XG5cbmNvbnN0IFJBRl9USU1FT1VUID0gMTAwO1xubGV0IHByZXZSYWY7XG5cbm9wdGlvbnMuX2RpZmYgPSB2bm9kZSA9PiB7XG5cdGN1cnJlbnRDb21wb25lbnQgPSBudWxsO1xuXHRpZiAob2xkQmVmb3JlRGlmZikgb2xkQmVmb3JlRGlmZih2bm9kZSk7XG59O1xuXG5vcHRpb25zLl9yZW5kZXIgPSB2bm9kZSA9PiB7XG5cdGlmIChvbGRCZWZvcmVSZW5kZXIpIG9sZEJlZm9yZVJlbmRlcih2bm9kZSk7XG5cblx0Y3VycmVudENvbXBvbmVudCA9IHZub2RlLl9jb21wb25lbnQ7XG5cdGN1cnJlbnRJbmRleCA9IDA7XG5cblx0Y29uc3QgaG9va3MgPSBjdXJyZW50Q29tcG9uZW50Ll9faG9va3M7XG5cdGlmIChob29rcykge1xuXHRcdGlmIChwcmV2aW91c0NvbXBvbmVudCA9PT0gY3VycmVudENvbXBvbmVudCkge1xuXHRcdFx0aG9va3MuX3BlbmRpbmdFZmZlY3RzID0gW107XG5cdFx0XHRjdXJyZW50Q29tcG9uZW50Ll9yZW5kZXJDYWxsYmFja3MgPSBbXTtcblx0XHRcdGhvb2tzLl9saXN0LmZvckVhY2goaG9va0l0ZW0gPT4ge1xuXHRcdFx0XHRpZiAoaG9va0l0ZW0uX25leHRWYWx1ZSkge1xuXHRcdFx0XHRcdGhvb2tJdGVtLl92YWx1ZSA9IGhvb2tJdGVtLl9uZXh0VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aG9va0l0ZW0uX3BlbmRpbmdWYWx1ZSA9IEVNUFRZO1xuXHRcdFx0XHRob29rSXRlbS5fbmV4dFZhbHVlID0gaG9va0l0ZW0uX3BlbmRpbmdBcmdzID0gdW5kZWZpbmVkO1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGhvb2tzLl9wZW5kaW5nRWZmZWN0cy5mb3JFYWNoKGludm9rZUNsZWFudXApO1xuXHRcdFx0aG9va3MuX3BlbmRpbmdFZmZlY3RzLmZvckVhY2goaW52b2tlRWZmZWN0KTtcblx0XHRcdGhvb2tzLl9wZW5kaW5nRWZmZWN0cyA9IFtdO1xuXHRcdH1cblx0fVxuXHRwcmV2aW91c0NvbXBvbmVudCA9IGN1cnJlbnRDb21wb25lbnQ7XG59O1xuXG5vcHRpb25zLmRpZmZlZCA9IHZub2RlID0+IHtcblx0aWYgKG9sZEFmdGVyRGlmZikgb2xkQWZ0ZXJEaWZmKHZub2RlKTtcblxuXHRjb25zdCBjID0gdm5vZGUuX2NvbXBvbmVudDtcblx0aWYgKGMgJiYgYy5fX2hvb2tzKSB7XG5cdFx0aWYgKGMuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMubGVuZ3RoKSBhZnRlclBhaW50KGFmdGVyUGFpbnRFZmZlY3RzLnB1c2goYykpO1xuXHRcdGMuX19ob29rcy5fbGlzdC5mb3JFYWNoKGhvb2tJdGVtID0+IHtcblx0XHRcdGlmIChob29rSXRlbS5fcGVuZGluZ0FyZ3MpIHtcblx0XHRcdFx0aG9va0l0ZW0uX2FyZ3MgPSBob29rSXRlbS5fcGVuZGluZ0FyZ3M7XG5cdFx0XHR9XG5cdFx0XHRpZiAoaG9va0l0ZW0uX3BlbmRpbmdWYWx1ZSAhPT0gRU1QVFkpIHtcblx0XHRcdFx0aG9va0l0ZW0uX3ZhbHVlID0gaG9va0l0ZW0uX3BlbmRpbmdWYWx1ZTtcblx0XHRcdH1cblx0XHRcdGhvb2tJdGVtLl9wZW5kaW5nQXJncyA9IHVuZGVmaW5lZDtcblx0XHRcdGhvb2tJdGVtLl9wZW5kaW5nVmFsdWUgPSBFTVBUWTtcblx0XHR9KTtcblx0fVxuXHRwcmV2aW91c0NvbXBvbmVudCA9IGN1cnJlbnRDb21wb25lbnQgPSBudWxsO1xufTtcblxub3B0aW9ucy5fY29tbWl0ID0gKHZub2RlLCBjb21taXRRdWV1ZSkgPT4ge1xuXHRjb21taXRRdWV1ZS5zb21lKGNvbXBvbmVudCA9PiB7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbXBvbmVudC5fcmVuZGVyQ2FsbGJhY2tzLmZvckVhY2goaW52b2tlQ2xlYW51cCk7XG5cdFx0XHRjb21wb25lbnQuX3JlbmRlckNhbGxiYWNrcyA9IGNvbXBvbmVudC5fcmVuZGVyQ2FsbGJhY2tzLmZpbHRlcihjYiA9PlxuXHRcdFx0XHRjYi5fdmFsdWUgPyBpbnZva2VFZmZlY3QoY2IpIDogdHJ1ZVxuXHRcdFx0KTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRjb21taXRRdWV1ZS5zb21lKGMgPT4ge1xuXHRcdFx0XHRpZiAoYy5fcmVuZGVyQ2FsbGJhY2tzKSBjLl9yZW5kZXJDYWxsYmFja3MgPSBbXTtcblx0XHRcdH0pO1xuXHRcdFx0Y29tbWl0UXVldWUgPSBbXTtcblx0XHRcdG9wdGlvbnMuX2NhdGNoRXJyb3IoZSwgY29tcG9uZW50Ll92bm9kZSk7XG5cdFx0fVxuXHR9KTtcblxuXHRpZiAob2xkQ29tbWl0KSBvbGRDb21taXQodm5vZGUsIGNvbW1pdFF1ZXVlKTtcbn07XG5cbm9wdGlvbnMudW5tb3VudCA9IHZub2RlID0+IHtcblx0aWYgKG9sZEJlZm9yZVVubW91bnQpIG9sZEJlZm9yZVVubW91bnQodm5vZGUpO1xuXG5cdGNvbnN0IGMgPSB2bm9kZS5fY29tcG9uZW50O1xuXHRpZiAoYyAmJiBjLl9faG9va3MpIHtcblx0XHRsZXQgaGFzRXJyb3JlZDtcblx0XHRjLl9faG9va3MuX2xpc3QuZm9yRWFjaChzID0+IHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGludm9rZUNsZWFudXAocyk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdGhhc0Vycm9yZWQgPSBlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGMuX19ob29rcyA9IHVuZGVmaW5lZDtcblx0XHRpZiAoaGFzRXJyb3JlZCkgb3B0aW9ucy5fY2F0Y2hFcnJvcihoYXNFcnJvcmVkLCBjLl92bm9kZSk7XG5cdH1cbn07XG5cbi8qKlxuICogR2V0IGEgaG9vaydzIHN0YXRlIGZyb20gdGhlIGN1cnJlbnRDb21wb25lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGhvb2sgdG8gZ2V0XG4gKiBAcGFyYW0ge251bWJlcn0gdHlwZSBUaGUgaW5kZXggb2YgdGhlIGhvb2sgdG8gZ2V0XG4gKiBAcmV0dXJucyB7YW55fVxuICovXG5mdW5jdGlvbiBnZXRIb29rU3RhdGUoaW5kZXgsIHR5cGUpIHtcblx0aWYgKG9wdGlvbnMuX2hvb2spIHtcblx0XHRvcHRpb25zLl9ob29rKGN1cnJlbnRDb21wb25lbnQsIGluZGV4LCBjdXJyZW50SG9vayB8fCB0eXBlKTtcblx0fVxuXHRjdXJyZW50SG9vayA9IDA7XG5cblx0Ly8gTGFyZ2VseSBpbnNwaXJlZCBieTpcblx0Ly8gKiBodHRwczovL2dpdGh1Yi5jb20vbWljaGFlbC1rbGVpbi9mdW5jeS5qcy9ibG9iL2Y2YmU3MzQ2OGU2ZWM0NmIwZmY1YWEzY2M0YzliYWY3MmEyOTAyNWEvc3JjL2hvb2tzL2NvcmVfaG9va3MubWpzXG5cdC8vICogaHR0cHM6Ly9naXRodWIuY29tL21pY2hhZWwta2xlaW4vZnVuY3kuanMvYmxvYi82NTBiZWFhNThjNDNjMzNhNzQ4MjBhM2M5OGIzYzcwNzljZjJlMzMzL3NyYy9yZW5kZXJlci5tanNcblx0Ly8gT3RoZXIgaW1wbGVtZW50YXRpb25zIHRvIGxvb2sgYXQ6XG5cdC8vICogaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL21ub3gwNXFwOFxuXHRjb25zdCBob29rcyA9XG5cdFx0Y3VycmVudENvbXBvbmVudC5fX2hvb2tzIHx8XG5cdFx0KGN1cnJlbnRDb21wb25lbnQuX19ob29rcyA9IHtcblx0XHRcdF9saXN0OiBbXSxcblx0XHRcdF9wZW5kaW5nRWZmZWN0czogW11cblx0XHR9KTtcblxuXHRpZiAoaW5kZXggPj0gaG9va3MuX2xpc3QubGVuZ3RoKSB7XG5cdFx0aG9va3MuX2xpc3QucHVzaCh7IF9wZW5kaW5nVmFsdWU6IEVNUFRZIH0pO1xuXHR9XG5cdHJldHVybiBob29rcy5fbGlzdFtpbmRleF07XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW5kZXgnKS5TdGF0ZVVwZGF0ZXI8YW55Pn0gW2luaXRpYWxTdGF0ZV1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YXRlKGluaXRpYWxTdGF0ZSkge1xuXHRjdXJyZW50SG9vayA9IDE7XG5cdHJldHVybiB1c2VSZWR1Y2VyKGludm9rZU9yUmV0dXJuLCBpbml0aWFsU3RhdGUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2luZGV4JykuUmVkdWNlcjxhbnksIGFueT59IHJlZHVjZXJcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2luZGV4JykuU3RhdGVVcGRhdGVyPGFueT59IGluaXRpYWxTdGF0ZVxuICogQHBhcmFtIHsoaW5pdGlhbFN0YXRlOiBhbnkpID0+IHZvaWR9IFtpbml0XVxuICogQHJldHVybnMge1sgYW55LCAoc3RhdGU6IGFueSkgPT4gdm9pZCBdfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsU3RhdGUsIGluaXQpIHtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5SZWR1Y2VySG9va1N0YXRlfSAqL1xuXHRjb25zdCBob29rU3RhdGUgPSBnZXRIb29rU3RhdGUoY3VycmVudEluZGV4KyssIDIpO1xuXHRob29rU3RhdGUuX3JlZHVjZXIgPSByZWR1Y2VyO1xuXHRpZiAoIWhvb2tTdGF0ZS5fY29tcG9uZW50KSB7XG5cdFx0aG9va1N0YXRlLl92YWx1ZSA9IFtcblx0XHRcdCFpbml0ID8gaW52b2tlT3JSZXR1cm4odW5kZWZpbmVkLCBpbml0aWFsU3RhdGUpIDogaW5pdChpbml0aWFsU3RhdGUpLFxuXG5cdFx0XHRhY3Rpb24gPT4ge1xuXHRcdFx0XHRjb25zdCBjdXJyZW50VmFsdWUgPSBob29rU3RhdGUuX25leHRWYWx1ZVxuXHRcdFx0XHRcdD8gaG9va1N0YXRlLl9uZXh0VmFsdWVbMF1cblx0XHRcdFx0XHQ6IGhvb2tTdGF0ZS5fdmFsdWVbMF07XG5cdFx0XHRcdGNvbnN0IG5leHRWYWx1ZSA9IGhvb2tTdGF0ZS5fcmVkdWNlcihjdXJyZW50VmFsdWUsIGFjdGlvbik7XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSAhPT0gbmV4dFZhbHVlKSB7XG5cdFx0XHRcdFx0aG9va1N0YXRlLl9uZXh0VmFsdWUgPSBbbmV4dFZhbHVlLCBob29rU3RhdGUuX3ZhbHVlWzFdXTtcblx0XHRcdFx0XHRob29rU3RhdGUuX2NvbXBvbmVudC5zZXRTdGF0ZSh7fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRdO1xuXG5cdFx0aG9va1N0YXRlLl9jb21wb25lbnQgPSBjdXJyZW50Q29tcG9uZW50O1xuXG5cdFx0aWYgKCFjdXJyZW50Q29tcG9uZW50Ll9oYXNTY3VGcm9tSG9va3MpIHtcblx0XHRcdGN1cnJlbnRDb21wb25lbnQuX2hhc1NjdUZyb21Ib29rcyA9IHRydWU7XG5cdFx0XHRjb25zdCBwcmV2U2N1ID0gY3VycmVudENvbXBvbmVudC5zaG91bGRDb21wb25lbnRVcGRhdGU7XG5cblx0XHRcdC8vIFRoaXMgU0NVIGhhcyB0aGUgcHVycG9zZSBvZiBiYWlsaW5nIG91dCBhZnRlciByZXBlYXRlZCB1cGRhdGVzXG5cdFx0XHQvLyB0byBzdGF0ZWZ1bCBob29rcy5cblx0XHRcdC8vIHdlIHN0b3JlIHRoZSBuZXh0IHZhbHVlIGluIF9uZXh0VmFsdWVbMF0gYW5kIGtlZXAgZG9pbmcgdGhhdCBmb3IgYWxsXG5cdFx0XHQvLyBzdGF0ZSBzZXR0ZXJzLCBpZiB3ZSBoYXZlIG5leHQgc3RhdGVzIGFuZFxuXHRcdFx0Ly8gYWxsIG5leHQgc3RhdGVzIHdpdGhpbiBhIGNvbXBvbmVudCBlbmQgdXAgYmVpbmcgZXF1YWwgdG8gdGhlaXIgb3JpZ2luYWwgc3RhdGVcblx0XHRcdC8vIHdlIGFyZSBzYWZlIHRvIGJhaWwgb3V0IGZvciB0aGlzIHNwZWNpZmljIGNvbXBvbmVudC5cblx0XHRcdGN1cnJlbnRDb21wb25lbnQuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZnVuY3Rpb24ocCwgcywgYykge1xuXHRcdFx0XHRpZiAoIWhvb2tTdGF0ZS5fY29tcG9uZW50Ll9faG9va3MpIHJldHVybiB0cnVlO1xuXG5cdFx0XHRcdGNvbnN0IHN0YXRlSG9va3MgPSBob29rU3RhdGUuX2NvbXBvbmVudC5fX2hvb2tzLl9saXN0LmZpbHRlcihcblx0XHRcdFx0XHR4ID0+IHguX2NvbXBvbmVudFxuXHRcdFx0XHQpO1xuXHRcdFx0XHRjb25zdCBhbGxIb29rc0VtcHR5ID0gc3RhdGVIb29rcy5ldmVyeSh4ID0+ICF4Ll9uZXh0VmFsdWUpO1xuXHRcdFx0XHQvLyBXaGVuIHdlIGhhdmUgbm8gdXBkYXRlZCBob29rcyBpbiB0aGUgY29tcG9uZW50IHdlIGludm9rZSB0aGUgcHJldmlvdXMgU0NVIG9yXG5cdFx0XHRcdC8vIHRyYXZlcnNlIHRoZSBWRE9NIHRyZWUgZnVydGhlci5cblx0XHRcdFx0aWYgKGFsbEhvb2tzRW1wdHkpIHtcblx0XHRcdFx0XHRyZXR1cm4gcHJldlNjdSA/IHByZXZTY3UuY2FsbCh0aGlzLCBwLCBzLCBjKSA6IHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBXZSBjaGVjayB3aGV0aGVyIHdlIGhhdmUgY29tcG9uZW50cyB3aXRoIGEgbmV4dFZhbHVlIHNldCB0aGF0XG5cdFx0XHRcdC8vIGhhdmUgdmFsdWVzIHRoYXQgYXJlbid0IGVxdWFsIHRvIG9uZSBhbm90aGVyIHRoaXMgcHVzaGVzXG5cdFx0XHRcdC8vIHVzIHRvIHVwZGF0ZSBmdXJ0aGVyIGRvd24gdGhlIHRyZWVcblx0XHRcdFx0bGV0IHNob3VsZFVwZGF0ZSA9IGZhbHNlO1xuXHRcdFx0XHRzdGF0ZUhvb2tzLmZvckVhY2goaG9va0l0ZW0gPT4ge1xuXHRcdFx0XHRcdGlmIChob29rSXRlbS5fbmV4dFZhbHVlKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBjdXJyZW50VmFsdWUgPSBob29rSXRlbS5fdmFsdWVbMF07XG5cdFx0XHRcdFx0XHRob29rSXRlbS5fdmFsdWUgPSBob29rSXRlbS5fbmV4dFZhbHVlO1xuXHRcdFx0XHRcdFx0aG9va0l0ZW0uX25leHRWYWx1ZSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgIT09IGhvb2tJdGVtLl92YWx1ZVswXSkgc2hvdWxkVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHJldHVybiBzaG91bGRVcGRhdGUgfHwgaG9va1N0YXRlLl9jb21wb25lbnQucHJvcHMgIT09IHBcblx0XHRcdFx0XHQ/IHByZXZTY3Vcblx0XHRcdFx0XHRcdD8gcHJldlNjdS5jYWxsKHRoaXMsIHAsIHMsIGMpXG5cdFx0XHRcdFx0XHQ6IHRydWVcblx0XHRcdFx0XHQ6IGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gaG9va1N0YXRlLl9uZXh0VmFsdWUgfHwgaG9va1N0YXRlLl92YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdH0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUVmZmVjdChjYWxsYmFjaywgYXJncykge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdEhvb2tTdGF0ZX0gKi9cblx0Y29uc3Qgc3RhdGUgPSBnZXRIb29rU3RhdGUoY3VycmVudEluZGV4KyssIDMpO1xuXHRpZiAoIW9wdGlvbnMuX3NraXBFZmZlY3RzICYmIGFyZ3NDaGFuZ2VkKHN0YXRlLl9hcmdzLCBhcmdzKSkge1xuXHRcdHN0YXRlLl92YWx1ZSA9IGNhbGxiYWNrO1xuXHRcdHN0YXRlLl9wZW5kaW5nQXJncyA9IGFyZ3M7XG5cblx0XHRjdXJyZW50Q29tcG9uZW50Ll9faG9va3MuX3BlbmRpbmdFZmZlY3RzLnB1c2goc3RhdGUpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5FZmZlY3R9IGNhbGxiYWNrXG4gKiBAcGFyYW0ge2FueVtdfSBhcmdzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VMYXlvdXRFZmZlY3QoY2FsbGJhY2ssIGFyZ3MpIHtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5FZmZlY3RIb29rU3RhdGV9ICovXG5cdGNvbnN0IHN0YXRlID0gZ2V0SG9va1N0YXRlKGN1cnJlbnRJbmRleCsrLCA0KTtcblx0aWYgKCFvcHRpb25zLl9za2lwRWZmZWN0cyAmJiBhcmdzQ2hhbmdlZChzdGF0ZS5fYXJncywgYXJncykpIHtcblx0XHRzdGF0ZS5fdmFsdWUgPSBjYWxsYmFjaztcblx0XHRzdGF0ZS5fcGVuZGluZ0FyZ3MgPSBhcmdzO1xuXG5cdFx0Y3VycmVudENvbXBvbmVudC5fcmVuZGVyQ2FsbGJhY2tzLnB1c2goc3RhdGUpO1xuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VSZWYoaW5pdGlhbFZhbHVlKSB7XG5cdGN1cnJlbnRIb29rID0gNTtcblx0cmV0dXJuIHVzZU1lbW8oKCkgPT4gKHsgY3VycmVudDogaW5pdGlhbFZhbHVlIH0pLCBbXSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IHJlZlxuICogQHBhcmFtIHsoKSA9PiBvYmplY3R9IGNyZWF0ZUhhbmRsZVxuICogQHBhcmFtIHthbnlbXX0gYXJnc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZUhhbmRsZSwgYXJncykge1xuXHRjdXJyZW50SG9vayA9IDY7XG5cdHVzZUxheW91dEVmZmVjdChcblx0XHQoKSA9PiB7XG5cdFx0XHRpZiAodHlwZW9mIHJlZiA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHJlZihjcmVhdGVIYW5kbGUoKSk7XG5cdFx0XHRcdHJldHVybiAoKSA9PiByZWYobnVsbCk7XG5cdFx0XHR9IGVsc2UgaWYgKHJlZikge1xuXHRcdFx0XHRyZWYuY3VycmVudCA9IGNyZWF0ZUhhbmRsZSgpO1xuXHRcdFx0XHRyZXR1cm4gKCkgPT4gKHJlZi5jdXJyZW50ID0gbnVsbCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRhcmdzID09IG51bGwgPyBhcmdzIDogYXJncy5jb25jYXQocmVmKVxuXHQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7KCkgPT4gYW55fSBmYWN0b3J5XG4gKiBAcGFyYW0ge2FueVtdfSBhcmdzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNZW1vKGZhY3RvcnksIGFyZ3MpIHtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5NZW1vSG9va1N0YXRlfSAqL1xuXHRjb25zdCBzdGF0ZSA9IGdldEhvb2tTdGF0ZShjdXJyZW50SW5kZXgrKywgNyk7XG5cdGlmIChhcmdzQ2hhbmdlZChzdGF0ZS5fYXJncywgYXJncykpIHtcblx0XHRzdGF0ZS5fcGVuZGluZ1ZhbHVlID0gZmFjdG9yeSgpO1xuXHRcdHN0YXRlLl9wZW5kaW5nQXJncyA9IGFyZ3M7XG5cdFx0c3RhdGUuX2ZhY3RvcnkgPSBmYWN0b3J5O1xuXHRcdHJldHVybiBzdGF0ZS5fcGVuZGluZ1ZhbHVlO1xuXHR9XG5cblx0cmV0dXJuIHN0YXRlLl92YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IGNhbGxiYWNrXG4gKiBAcGFyYW0ge2FueVtdfSBhcmdzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VDYWxsYmFjayhjYWxsYmFjaywgYXJncykge1xuXHRjdXJyZW50SG9vayA9IDg7XG5cdHJldHVybiB1c2VNZW1vKCgpID0+IGNhbGxiYWNrLCBhcmdzKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlByZWFjdENvbnRleHR9IGNvbnRleHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNvbnRleHQoY29udGV4dCkge1xuXHRjb25zdCBwcm92aWRlciA9IGN1cnJlbnRDb21wb25lbnQuY29udGV4dFtjb250ZXh0Ll9pZF07XG5cdC8vIFdlIGNvdWxkIHNraXAgdGhpcyBjYWxsIGhlcmUsIGJ1dCB0aGFuIHdlJ2Qgbm90IGNhbGxcblx0Ly8gYG9wdGlvbnMuX2hvb2tgLiBXZSBuZWVkIHRvIGRvIHRoYXQgaW4gb3JkZXIgdG8gbWFrZVxuXHQvLyB0aGUgZGV2dG9vbHMgYXdhcmUgb2YgdGhpcyBob29rLlxuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbnRleHRIb29rU3RhdGV9ICovXG5cdGNvbnN0IHN0YXRlID0gZ2V0SG9va1N0YXRlKGN1cnJlbnRJbmRleCsrLCA5KTtcblx0Ly8gVGhlIGRldnRvb2xzIG5lZWRzIGFjY2VzcyB0byB0aGUgY29udGV4dCBvYmplY3QgdG9cblx0Ly8gYmUgYWJsZSB0byBwdWxsIG9mIHRoZSBkZWZhdWx0IHZhbHVlIHdoZW4gbm8gcHJvdmlkZXJcblx0Ly8gaXMgcHJlc2VudCBpbiB0aGUgdHJlZS5cblx0c3RhdGUuX2NvbnRleHQgPSBjb250ZXh0O1xuXHRpZiAoIXByb3ZpZGVyKSByZXR1cm4gY29udGV4dC5fZGVmYXVsdFZhbHVlO1xuXHQvLyBUaGlzIGlzIHByb2JhYmx5IG5vdCBzYWZlIHRvIGNvbnZlcnQgdG8gXCIhXCJcblx0aWYgKHN0YXRlLl92YWx1ZSA9PSBudWxsKSB7XG5cdFx0c3RhdGUuX3ZhbHVlID0gdHJ1ZTtcblx0XHRwcm92aWRlci5zdWIoY3VycmVudENvbXBvbmVudCk7XG5cdH1cblx0cmV0dXJuIHByb3ZpZGVyLnByb3BzLnZhbHVlO1xufVxuXG4vKipcbiAqIERpc3BsYXkgYSBjdXN0b20gbGFiZWwgZm9yIGEgY3VzdG9tIGhvb2sgZm9yIHRoZSBkZXZ0b29scyBwYW5lbFxuICogQHR5cGUgezxUPih2YWx1ZTogVCwgY2I/OiAodmFsdWU6IFQpID0+IHN0cmluZyB8IG51bWJlcikgPT4gdm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZURlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlcikge1xuXHRpZiAob3B0aW9ucy51c2VEZWJ1Z1ZhbHVlKSB7XG5cdFx0b3B0aW9ucy51c2VEZWJ1Z1ZhbHVlKGZvcm1hdHRlciA/IGZvcm1hdHRlcih2YWx1ZSkgOiB2YWx1ZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0geyhlcnJvcjogYW55LCBlcnJvckluZm86IGltcG9ydCgncHJlYWN0JykuRXJyb3JJbmZvKSA9PiB2b2lkfSBjYlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRXJyb3JCb3VuZGFyeShjYikge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVycm9yQm91bmRhcnlIb29rU3RhdGV9ICovXG5cdGNvbnN0IHN0YXRlID0gZ2V0SG9va1N0YXRlKGN1cnJlbnRJbmRleCsrLCAxMCk7XG5cdGNvbnN0IGVyclN0YXRlID0gdXNlU3RhdGUoKTtcblx0c3RhdGUuX3ZhbHVlID0gY2I7XG5cdGlmICghY3VycmVudENvbXBvbmVudC5jb21wb25lbnREaWRDYXRjaCkge1xuXHRcdGN1cnJlbnRDb21wb25lbnQuY29tcG9uZW50RGlkQ2F0Y2ggPSAoZXJyLCBlcnJvckluZm8pID0+IHtcblx0XHRcdGlmIChzdGF0ZS5fdmFsdWUpIHN0YXRlLl92YWx1ZShlcnIsIGVycm9ySW5mbyk7XG5cdFx0XHRlcnJTdGF0ZVsxXShlcnIpO1xuXHRcdH07XG5cdH1cblx0cmV0dXJuIFtcblx0XHRlcnJTdGF0ZVswXSxcblx0XHQoKSA9PiB7XG5cdFx0XHRlcnJTdGF0ZVsxXSh1bmRlZmluZWQpO1xuXHRcdH1cblx0XTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUlkKCkge1xuXHRjb25zdCBzdGF0ZSA9IGdldEhvb2tTdGF0ZShjdXJyZW50SW5kZXgrKywgMTEpO1xuXHRpZiAoIXN0YXRlLl92YWx1ZSkge1xuXHRcdC8vIEdyYWIgZWl0aGVyIHRoZSByb290IG5vZGUgb3IgdGhlIG5lYXJlc3QgYXN5bmMgYm91bmRhcnkgbm9kZS5cblx0XHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbC5kJykuVk5vZGV9ICovXG5cdFx0bGV0IHJvb3QgPSBjdXJyZW50Q29tcG9uZW50Ll92bm9kZTtcblx0XHR3aGlsZSAocm9vdCAhPT0gbnVsbCAmJiAhcm9vdC5fbWFzayAmJiByb290Ll9wYXJlbnQgIT09IG51bGwpIHtcblx0XHRcdHJvb3QgPSByb290Ll9wYXJlbnQ7XG5cdFx0fVxuXG5cdFx0bGV0IG1hc2sgPSByb290Ll9tYXNrIHx8IChyb290Ll9tYXNrID0gWzAsIDBdKTtcblx0XHRzdGF0ZS5fdmFsdWUgPSAnUCcgKyBtYXNrWzBdICsgJy0nICsgbWFza1sxXSsrO1xuXHR9XG5cblx0cmV0dXJuIHN0YXRlLl92YWx1ZTtcbn1cbi8qKlxuICogQWZ0ZXIgcGFpbnQgZWZmZWN0cyBjb25zdW1lci5cbiAqL1xuZnVuY3Rpb24gZmx1c2hBZnRlclBhaW50RWZmZWN0cygpIHtcblx0bGV0IGNvbXBvbmVudDtcblx0d2hpbGUgKChjb21wb25lbnQgPSBhZnRlclBhaW50RWZmZWN0cy5zaGlmdCgpKSkge1xuXHRcdGlmICghY29tcG9uZW50Ll9wYXJlbnREb20gfHwgIWNvbXBvbmVudC5fX2hvb2tzKSBjb250aW51ZTtcblx0XHR0cnkge1xuXHRcdFx0Y29tcG9uZW50Ll9faG9va3MuX3BlbmRpbmdFZmZlY3RzLmZvckVhY2goaW52b2tlQ2xlYW51cCk7XG5cdFx0XHRjb21wb25lbnQuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMuZm9yRWFjaChpbnZva2VFZmZlY3QpO1xuXHRcdFx0Y29tcG9uZW50Ll9faG9va3MuX3BlbmRpbmdFZmZlY3RzID0gW107XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0Y29tcG9uZW50Ll9faG9va3MuX3BlbmRpbmdFZmZlY3RzID0gW107XG5cdFx0XHRvcHRpb25zLl9jYXRjaEVycm9yKGUsIGNvbXBvbmVudC5fdm5vZGUpO1xuXHRcdH1cblx0fVxufVxuXG5sZXQgSEFTX1JBRiA9IHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT0gJ2Z1bmN0aW9uJztcblxuLyoqXG4gKiBTY2hlZHVsZSBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgYWZ0ZXIgdGhlIGJyb3dzZXIgaGFzIGEgY2hhbmNlIHRvIHBhaW50IGEgbmV3IGZyYW1lLlxuICogRG8gdGhpcyBieSBjb21iaW5pbmcgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIChyQUYpICsgc2V0VGltZW91dCB0byBpbnZva2UgYSBjYWxsYmFjayBhZnRlclxuICogdGhlIG5leHQgYnJvd3NlciBmcmFtZS5cbiAqXG4gKiBBbHNvLCBzY2hlZHVsZSBhIHRpbWVvdXQgaW4gcGFyYWxsZWwgdG8gdGhlIHRoZSByQUYgdG8gZW5zdXJlIHRoZSBjYWxsYmFjayBpcyBpbnZva2VkXG4gKiBldmVuIGlmIFJBRiBkb2Vzbid0IGZpcmUgKGZvciBleGFtcGxlIGlmIHRoZSBicm93c2VyIHRhYiBpcyBub3QgdmlzaWJsZSlcbiAqXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IGNhbGxiYWNrXG4gKi9cbmZ1bmN0aW9uIGFmdGVyTmV4dEZyYW1lKGNhbGxiYWNrKSB7XG5cdGNvbnN0IGRvbmUgPSAoKSA9PiB7XG5cdFx0Y2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXHRcdGlmIChIQVNfUkFGKSBjYW5jZWxBbmltYXRpb25GcmFtZShyYWYpO1xuXHRcdHNldFRpbWVvdXQoY2FsbGJhY2spO1xuXHR9O1xuXHRjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dChkb25lLCBSQUZfVElNRU9VVCk7XG5cblx0bGV0IHJhZjtcblx0aWYgKEhBU19SQUYpIHtcblx0XHRyYWYgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZG9uZSk7XG5cdH1cbn1cblxuLy8gTm90ZTogaWYgc29tZW9uZSB1c2VkIG9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmcgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUsXG4vLyB0aGVuIGVmZmVjdHMgd2lsbCBBTFdBWVMgcnVuIG9uIHRoZSBORVhUIGZyYW1lIGluc3RlYWQgb2YgdGhlIGN1cnJlbnQgb25lLCBpbmN1cnJpbmcgYSB+MTZtcyBkZWxheS5cbi8vIFBlcmhhcHMgdGhpcyBpcyBub3Qgc3VjaCBhIGJpZyBkZWFsLlxuLyoqXG4gKiBTY2hlZHVsZSBhZnRlclBhaW50RWZmZWN0cyBmbHVzaCBhZnRlciB0aGUgYnJvd3NlciBwYWludHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZXdRdWV1ZUxlbmd0aFxuICovXG5mdW5jdGlvbiBhZnRlclBhaW50KG5ld1F1ZXVlTGVuZ3RoKSB7XG5cdGlmIChuZXdRdWV1ZUxlbmd0aCA9PT0gMSB8fCBwcmV2UmFmICE9PSBvcHRpb25zLnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuXHRcdHByZXZSYWYgPSBvcHRpb25zLnJlcXVlc3RBbmltYXRpb25GcmFtZTtcblx0XHQocHJldlJhZiB8fCBhZnRlck5leHRGcmFtZSkoZmx1c2hBZnRlclBhaW50RWZmZWN0cyk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdEhvb2tTdGF0ZX0gaG9va1xuICovXG5mdW5jdGlvbiBpbnZva2VDbGVhbnVwKGhvb2spIHtcblx0Ly8gQSBob29rIGNsZWFudXAgY2FuIGludHJvZHVjZSBhIGNhbGwgdG8gcmVuZGVyIHdoaWNoIGNyZWF0ZXMgYSBuZXcgcm9vdCwgdGhpcyB3aWxsIGNhbGwgb3B0aW9ucy52bm9kZVxuXHQvLyBhbmQgbW92ZSB0aGUgY3VycmVudENvbXBvbmVudCBhd2F5LlxuXHRjb25zdCBjb21wID0gY3VycmVudENvbXBvbmVudDtcblx0bGV0IGNsZWFudXAgPSBob29rLl9jbGVhbnVwO1xuXHRpZiAodHlwZW9mIGNsZWFudXAgPT0gJ2Z1bmN0aW9uJykge1xuXHRcdGhvb2suX2NsZWFudXAgPSB1bmRlZmluZWQ7XG5cdFx0Y2xlYW51cCgpO1xuXHR9XG5cblx0Y3VycmVudENvbXBvbmVudCA9IGNvbXA7XG59XG5cbi8qKlxuICogSW52b2tlIGEgSG9vaydzIGVmZmVjdFxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5FZmZlY3RIb29rU3RhdGV9IGhvb2tcbiAqL1xuZnVuY3Rpb24gaW52b2tlRWZmZWN0KGhvb2spIHtcblx0Ly8gQSBob29rIGNhbGwgY2FuIGludHJvZHVjZSBhIGNhbGwgdG8gcmVuZGVyIHdoaWNoIGNyZWF0ZXMgYSBuZXcgcm9vdCwgdGhpcyB3aWxsIGNhbGwgb3B0aW9ucy52bm9kZVxuXHQvLyBhbmQgbW92ZSB0aGUgY3VycmVudENvbXBvbmVudCBhd2F5LlxuXHRjb25zdCBjb21wID0gY3VycmVudENvbXBvbmVudDtcblx0aG9vay5fY2xlYW51cCA9IGhvb2suX3ZhbHVlKCk7XG5cdGN1cnJlbnRDb21wb25lbnQgPSBjb21wO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55W119IG9sZEFyZ3NcbiAqIEBwYXJhbSB7YW55W119IG5ld0FyZ3NcbiAqL1xuZnVuY3Rpb24gYXJnc0NoYW5nZWQob2xkQXJncywgbmV3QXJncykge1xuXHRyZXR1cm4gKFxuXHRcdCFvbGRBcmdzIHx8XG5cdFx0b2xkQXJncy5sZW5ndGggIT09IG5ld0FyZ3MubGVuZ3RoIHx8XG5cdFx0bmV3QXJncy5zb21lKChhcmcsIGluZGV4KSA9PiBhcmcgIT09IG9sZEFyZ3NbaW5kZXhdKVxuXHQpO1xufVxuXG5mdW5jdGlvbiBpbnZva2VPclJldHVybihhcmcsIGYpIHtcblx0cmV0dXJuIHR5cGVvZiBmID09ICdmdW5jdGlvbicgPyBmKGFyZykgOiBmO1xufVxuIiwgIi8qKlxuICogQXNzaWduIHByb3BlcnRpZXMgZnJvbSBgcHJvcHNgIHRvIGBvYmpgXG4gKiBAdGVtcGxhdGUgTywgUCBUaGUgb2JqIGFuZCBwcm9wcyB0eXBlc1xuICogQHBhcmFtIHtPfSBvYmogVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG9cbiAqIEBwYXJhbSB7UH0gcHJvcHMgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbVxuICogQHJldHVybnMge08gJiBQfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKG9iaiwgcHJvcHMpIHtcblx0Zm9yIChsZXQgaSBpbiBwcm9wcykgb2JqW2ldID0gcHJvcHNbaV07XG5cdHJldHVybiAvKiogQHR5cGUge08gJiBQfSAqLyAob2JqKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gb2JqZWN0cyBoYXZlIGEgZGlmZmVyZW50IHNoYXBlXG4gKiBAcGFyYW0ge29iamVjdH0gYVxuICogQHBhcmFtIHtvYmplY3R9IGJcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2hhbGxvd0RpZmZlcnMoYSwgYikge1xuXHRmb3IgKGxldCBpIGluIGEpIGlmIChpICE9PSAnX19zb3VyY2UnICYmICEoaSBpbiBiKSkgcmV0dXJuIHRydWU7XG5cdGZvciAobGV0IGkgaW4gYikgaWYgKGkgIT09ICdfX3NvdXJjZScgJiYgYVtpXSAhPT0gYltpXSkgcmV0dXJuIHRydWU7XG5cdHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZU5vZGUobm9kZSkge1xuXHRsZXQgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcblx0aWYgKHBhcmVudE5vZGUpIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHZhbHVlcyBhcmUgdGhlIHNhbWUgdmFsdWVcbiAqIEBwYXJhbSB7Kn0geFxuICogQHBhcmFtIHsqfSB5XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzKHgsIHkpIHtcblx0cmV0dXJuICh4ID09PSB5ICYmICh4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSkpIHx8ICh4ICE9PSB4ICYmIHkgIT09IHkpO1xufVxuIiwgImltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgeyBzaGFsbG93RGlmZmVycyB9IGZyb20gJy4vdXRpbCc7XG5cbi8qKlxuICogQ29tcG9uZW50IGNsYXNzIHdpdGggYSBwcmVkZWZpbmVkIGBzaG91bGRDb21wb25lbnRVcGRhdGVgIGltcGxlbWVudGF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBQdXJlQ29tcG9uZW50KHApIHtcblx0dGhpcy5wcm9wcyA9IHA7XG59XG5QdXJlQ29tcG9uZW50LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnQoKTtcbi8vIFNvbWUgdGhpcmQtcGFydHkgbGlicmFyaWVzIGNoZWNrIGlmIHRoaXMgcHJvcGVydHkgaXMgcHJlc2VudFxuUHVyZUNvbXBvbmVudC5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuUHVyZUNvbXBvbmVudC5wcm90b3R5cGUuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZnVuY3Rpb24ocHJvcHMsIHN0YXRlKSB7XG5cdHJldHVybiBzaGFsbG93RGlmZmVycyh0aGlzLnByb3BzLCBwcm9wcykgfHwgc2hhbGxvd0RpZmZlcnModGhpcy5zdGF0ZSwgc3RhdGUpO1xufTtcbiIsICJpbXBvcnQgeyBjcmVhdGVFbGVtZW50IH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCB7IHNoYWxsb3dEaWZmZXJzIH0gZnJvbSAnLi91dGlsJztcblxuLyoqXG4gKiBNZW1vaXplIGEgY29tcG9uZW50LCBzbyB0aGF0IGl0IG9ubHkgdXBkYXRlcyB3aGVuIHRoZSBwcm9wcyBhY3R1YWxseSBoYXZlXG4gKiBjaGFuZ2VkLiBUaGlzIHdhcyBwcmV2aW91c2x5IGtub3duIGFzIGBSZWFjdC5wdXJlYC5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuRnVuY3Rpb25Db21wb25lbnR9IGMgZnVuY3Rpb25hbCBjb21wb25lbnRcbiAqIEBwYXJhbSB7KHByZXY6IG9iamVjdCwgbmV4dDogb2JqZWN0KSA9PiBib29sZWFufSBbY29tcGFyZXJdIEN1c3RvbSBlcXVhbGl0eSBmdW5jdGlvblxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkZ1bmN0aW9uQ29tcG9uZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVtbyhjLCBjb21wYXJlcikge1xuXHRmdW5jdGlvbiBzaG91bGRVcGRhdGUobmV4dFByb3BzKSB7XG5cdFx0bGV0IHJlZiA9IHRoaXMucHJvcHMucmVmO1xuXHRcdGxldCB1cGRhdGVSZWYgPSByZWYgPT0gbmV4dFByb3BzLnJlZjtcblx0XHRpZiAoIXVwZGF0ZVJlZiAmJiByZWYpIHtcblx0XHRcdHJlZi5jYWxsID8gcmVmKG51bGwpIDogKHJlZi5jdXJyZW50ID0gbnVsbCk7XG5cdFx0fVxuXG5cdFx0aWYgKCFjb21wYXJlcikge1xuXHRcdFx0cmV0dXJuIHNoYWxsb3dEaWZmZXJzKHRoaXMucHJvcHMsIG5leHRQcm9wcyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICFjb21wYXJlcih0aGlzLnByb3BzLCBuZXh0UHJvcHMpIHx8ICF1cGRhdGVSZWY7XG5cdH1cblxuXHRmdW5jdGlvbiBNZW1vZWQocHJvcHMpIHtcblx0XHR0aGlzLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IHNob3VsZFVwZGF0ZTtcblx0XHRyZXR1cm4gY3JlYXRlRWxlbWVudChjLCBwcm9wcyk7XG5cdH1cblx0TWVtb2VkLmRpc3BsYXlOYW1lID0gJ01lbW8oJyArIChjLmRpc3BsYXlOYW1lIHx8IGMubmFtZSkgKyAnKSc7XG5cdE1lbW9lZC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHRydWU7XG5cdE1lbW9lZC5fZm9yd2FyZGVkID0gdHJ1ZTtcblx0cmV0dXJuIE1lbW9lZDtcbn1cbiIsICJpbXBvcnQgeyBvcHRpb25zIH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCB7IGFzc2lnbiB9IGZyb20gJy4vdXRpbCc7XG5cbmxldCBvbGREaWZmSG9vayA9IG9wdGlvbnMuX2RpZmY7XG5vcHRpb25zLl9kaWZmID0gdm5vZGUgPT4ge1xuXHRpZiAodm5vZGUudHlwZSAmJiB2bm9kZS50eXBlLl9mb3J3YXJkZWQgJiYgdm5vZGUucmVmKSB7XG5cdFx0dm5vZGUucHJvcHMucmVmID0gdm5vZGUucmVmO1xuXHRcdHZub2RlLnJlZiA9IG51bGw7XG5cdH1cblx0aWYgKG9sZERpZmZIb29rKSBvbGREaWZmSG9vayh2bm9kZSk7XG59O1xuXG5leHBvcnQgY29uc3QgUkVBQ1RfRk9SV0FSRF9TWU1CT0wgPVxuXHQodHlwZW9mIFN5bWJvbCAhPSAndW5kZWZpbmVkJyAmJlxuXHRcdFN5bWJvbC5mb3IgJiZcblx0XHRTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpKSB8fFxuXHQweGY0NztcblxuLyoqXG4gKiBQYXNzIHJlZiBkb3duIHRvIGEgY2hpbGQuIFRoaXMgaXMgbWFpbmx5IHVzZWQgaW4gbGlicmFyaWVzIHdpdGggSE9DcyB0aGF0XG4gKiB3cmFwIGNvbXBvbmVudHMuIFVzaW5nIGBmb3J3YXJkUmVmYCB0aGVyZSBpcyBhbiBlYXN5IHdheSB0byBnZXQgYSByZWZlcmVuY2VcbiAqIG9mIHRoZSB3cmFwcGVkIGNvbXBvbmVudCBpbnN0ZWFkIG9mIG9uZSBvZiB0aGUgd3JhcHBlciBpdHNlbGYuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbmRleCcpLkZvcndhcmRGbn0gZm5cbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5GdW5jdGlvbkNvbXBvbmVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcndhcmRSZWYoZm4pIHtcblx0ZnVuY3Rpb24gRm9yd2FyZGVkKHByb3BzKSB7XG5cdFx0bGV0IGNsb25lID0gYXNzaWduKHt9LCBwcm9wcyk7XG5cdFx0ZGVsZXRlIGNsb25lLnJlZjtcblx0XHRyZXR1cm4gZm4oY2xvbmUsIHByb3BzLnJlZiB8fCBudWxsKTtcblx0fVxuXG5cdC8vIG1vYngtcmVhY3QgY2hlY2tzIGZvciB0aGlzIGJlaW5nIHByZXNlbnRcblx0Rm9yd2FyZGVkLiQkdHlwZW9mID0gUkVBQ1RfRk9SV0FSRF9TWU1CT0w7XG5cdC8vIG1vYngtcmVhY3QgaGVhdmlseSByZWxpZXMgb24gaW1wbGVtZW50YXRpb24gZGV0YWlscy5cblx0Ly8gSXQgZXhwZWN0cyBhbiBvYmplY3QgaGVyZSB3aXRoIGEgYHJlbmRlcmAgcHJvcGVydHksXG5cdC8vIGFuZCBwcm90b3R5cGUucmVuZGVyIHdpbGwgZmFpbC4gV2l0aG91dCB0aGlzXG5cdC8vIG1vYngtcmVhY3QgdGhyb3dzLlxuXHRGb3J3YXJkZWQucmVuZGVyID0gRm9yd2FyZGVkO1xuXG5cdEZvcndhcmRlZC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IEZvcndhcmRlZC5fZm9yd2FyZGVkID0gdHJ1ZTtcblx0Rm9yd2FyZGVkLmRpc3BsYXlOYW1lID0gJ0ZvcndhcmRSZWYoJyArIChmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lKSArICcpJztcblx0cmV0dXJuIEZvcndhcmRlZDtcbn1cbiIsICJpbXBvcnQgeyB0b0NoaWxkQXJyYXkgfSBmcm9tICdwcmVhY3QnO1xuXG5jb25zdCBtYXBGbiA9IChjaGlsZHJlbiwgZm4pID0+IHtcblx0aWYgKGNoaWxkcmVuID09IG51bGwpIHJldHVybiBudWxsO1xuXHRyZXR1cm4gdG9DaGlsZEFycmF5KHRvQ2hpbGRBcnJheShjaGlsZHJlbikubWFwKGZuKSk7XG59O1xuXG4vLyBUaGlzIEFQSSBpcyBjb21wbGV0ZWx5IHVubmVjZXNzYXJ5IGZvciBQcmVhY3QsIHNvIGl0J3MgYmFzaWNhbGx5IHBhc3N0aHJvdWdoLlxuZXhwb3J0IGNvbnN0IENoaWxkcmVuID0ge1xuXHRtYXA6IG1hcEZuLFxuXHRmb3JFYWNoOiBtYXBGbixcblx0Y291bnQoY2hpbGRyZW4pIHtcblx0XHRyZXR1cm4gY2hpbGRyZW4gPyB0b0NoaWxkQXJyYXkoY2hpbGRyZW4pLmxlbmd0aCA6IDA7XG5cdH0sXG5cdG9ubHkoY2hpbGRyZW4pIHtcblx0XHRjb25zdCBub3JtYWxpemVkID0gdG9DaGlsZEFycmF5KGNoaWxkcmVuKTtcblx0XHRpZiAobm9ybWFsaXplZC5sZW5ndGggIT09IDEpIHRocm93ICdDaGlsZHJlbi5vbmx5Jztcblx0XHRyZXR1cm4gbm9ybWFsaXplZFswXTtcblx0fSxcblx0dG9BcnJheTogdG9DaGlsZEFycmF5XG59O1xuIiwgImltcG9ydCB7IENvbXBvbmVudCwgY3JlYXRlRWxlbWVudCwgb3B0aW9ucywgRnJhZ21lbnQgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgYXNzaWduIH0gZnJvbSAnLi91dGlsJztcblxuY29uc3Qgb2xkQ2F0Y2hFcnJvciA9IG9wdGlvbnMuX2NhdGNoRXJyb3I7XG5vcHRpb25zLl9jYXRjaEVycm9yID0gZnVuY3Rpb24oZXJyb3IsIG5ld1ZOb2RlLCBvbGRWTm9kZSwgZXJyb3JJbmZvKSB7XG5cdGlmIChlcnJvci50aGVuKSB7XG5cdFx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9ICovXG5cdFx0bGV0IGNvbXBvbmVudDtcblx0XHRsZXQgdm5vZGUgPSBuZXdWTm9kZTtcblxuXHRcdGZvciAoOyAodm5vZGUgPSB2bm9kZS5fcGFyZW50KTsgKSB7XG5cdFx0XHRpZiAoKGNvbXBvbmVudCA9IHZub2RlLl9jb21wb25lbnQpICYmIGNvbXBvbmVudC5fY2hpbGREaWRTdXNwZW5kKSB7XG5cdFx0XHRcdGlmIChuZXdWTm9kZS5fZG9tID09IG51bGwpIHtcblx0XHRcdFx0XHRuZXdWTm9kZS5fZG9tID0gb2xkVk5vZGUuX2RvbTtcblx0XHRcdFx0XHRuZXdWTm9kZS5fY2hpbGRyZW4gPSBvbGRWTm9kZS5fY2hpbGRyZW47XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gRG9uJ3QgY2FsbCBvbGRDYXRjaEVycm9yIGlmIHdlIGZvdW5kIGEgU3VzcGVuc2Vcblx0XHRcdFx0cmV0dXJuIGNvbXBvbmVudC5fY2hpbGREaWRTdXNwZW5kKGVycm9yLCBuZXdWTm9kZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdG9sZENhdGNoRXJyb3IoZXJyb3IsIG5ld1ZOb2RlLCBvbGRWTm9kZSwgZXJyb3JJbmZvKTtcbn07XG5cbmNvbnN0IG9sZFVubW91bnQgPSBvcHRpb25zLnVubW91bnQ7XG5vcHRpb25zLnVubW91bnQgPSBmdW5jdGlvbih2bm9kZSkge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gKi9cblx0Y29uc3QgY29tcG9uZW50ID0gdm5vZGUuX2NvbXBvbmVudDtcblx0aWYgKGNvbXBvbmVudCAmJiBjb21wb25lbnQuX29uUmVzb2x2ZSkge1xuXHRcdGNvbXBvbmVudC5fb25SZXNvbHZlKCk7XG5cdH1cblxuXHQvLyBpZiB0aGUgY29tcG9uZW50IGlzIHN0aWxsIGh5ZHJhdGluZ1xuXHQvLyBtb3N0IGxpa2VseSBpdCBpcyBiZWNhdXNlIHRoZSBjb21wb25lbnQgaXMgc3VzcGVuZGVkXG5cdC8vIHdlIHNldCB0aGUgdm5vZGUudHlwZSBhcyBgbnVsbGAgc28gdGhhdCBpdCBpcyBub3QgYSB0eXBlb2YgZnVuY3Rpb25cblx0Ly8gc28gdGhlIHVubW91bnQgd2lsbCByZW1vdmUgdGhlIHZub2RlLl9kb21cblx0aWYgKGNvbXBvbmVudCAmJiB2bm9kZS5faHlkcmF0aW5nID09PSB0cnVlKSB7XG5cdFx0dm5vZGUudHlwZSA9IG51bGw7XG5cdH1cblxuXHRpZiAob2xkVW5tb3VudCkgb2xkVW5tb3VudCh2bm9kZSk7XG59O1xuXG5mdW5jdGlvbiBkZXRhY2hlZENsb25lKHZub2RlLCBkZXRhY2hlZFBhcmVudCwgcGFyZW50RG9tKSB7XG5cdGlmICh2bm9kZSkge1xuXHRcdGlmICh2bm9kZS5fY29tcG9uZW50ICYmIHZub2RlLl9jb21wb25lbnQuX19ob29rcykge1xuXHRcdFx0dm5vZGUuX2NvbXBvbmVudC5fX2hvb2tzLl9saXN0LmZvckVhY2goZWZmZWN0ID0+IHtcblx0XHRcdFx0aWYgKHR5cGVvZiBlZmZlY3QuX2NsZWFudXAgPT0gJ2Z1bmN0aW9uJykgZWZmZWN0Ll9jbGVhbnVwKCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0dm5vZGUuX2NvbXBvbmVudC5fX2hvb2tzID0gbnVsbDtcblx0XHR9XG5cblx0XHR2bm9kZSA9IGFzc2lnbih7fSwgdm5vZGUpO1xuXHRcdGlmICh2bm9kZS5fY29tcG9uZW50ICE9IG51bGwpIHtcblx0XHRcdGlmICh2bm9kZS5fY29tcG9uZW50Ll9wYXJlbnREb20gPT09IHBhcmVudERvbSkge1xuXHRcdFx0XHR2bm9kZS5fY29tcG9uZW50Ll9wYXJlbnREb20gPSBkZXRhY2hlZFBhcmVudDtcblx0XHRcdH1cblx0XHRcdHZub2RlLl9jb21wb25lbnQgPSBudWxsO1xuXHRcdH1cblxuXHRcdHZub2RlLl9jaGlsZHJlbiA9XG5cdFx0XHR2bm9kZS5fY2hpbGRyZW4gJiZcblx0XHRcdHZub2RlLl9jaGlsZHJlbi5tYXAoY2hpbGQgPT5cblx0XHRcdFx0ZGV0YWNoZWRDbG9uZShjaGlsZCwgZGV0YWNoZWRQYXJlbnQsIHBhcmVudERvbSlcblx0XHRcdCk7XG5cdH1cblxuXHRyZXR1cm4gdm5vZGU7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZU9yaWdpbmFsKHZub2RlLCBkZXRhY2hlZFBhcmVudCwgb3JpZ2luYWxQYXJlbnQpIHtcblx0aWYgKHZub2RlKSB7XG5cdFx0dm5vZGUuX29yaWdpbmFsID0gbnVsbDtcblx0XHR2bm9kZS5fY2hpbGRyZW4gPVxuXHRcdFx0dm5vZGUuX2NoaWxkcmVuICYmXG5cdFx0XHR2bm9kZS5fY2hpbGRyZW4ubWFwKGNoaWxkID0+XG5cdFx0XHRcdHJlbW92ZU9yaWdpbmFsKGNoaWxkLCBkZXRhY2hlZFBhcmVudCwgb3JpZ2luYWxQYXJlbnQpXG5cdFx0XHQpO1xuXG5cdFx0aWYgKHZub2RlLl9jb21wb25lbnQpIHtcblx0XHRcdGlmICh2bm9kZS5fY29tcG9uZW50Ll9wYXJlbnREb20gPT09IGRldGFjaGVkUGFyZW50KSB7XG5cdFx0XHRcdGlmICh2bm9kZS5fZG9tKSB7XG5cdFx0XHRcdFx0b3JpZ2luYWxQYXJlbnQuaW5zZXJ0QmVmb3JlKHZub2RlLl9kb20sIHZub2RlLl9uZXh0RG9tKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2bm9kZS5fY29tcG9uZW50Ll9mb3JjZSA9IHRydWU7XG5cdFx0XHRcdHZub2RlLl9jb21wb25lbnQuX3BhcmVudERvbSA9IG9yaWdpbmFsUGFyZW50O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB2bm9kZTtcbn1cblxuLy8gaGF2aW5nIGN1c3RvbSBpbmhlcml0YW5jZSBpbnN0ZWFkIG9mIGEgY2xhc3MgaGVyZSBzYXZlcyBhIGxvdCBvZiBieXRlc1xuZXhwb3J0IGZ1bmN0aW9uIFN1c3BlbnNlKCkge1xuXHQvLyB3ZSBkbyBub3QgY2FsbCBzdXBlciBoZXJlIHRvIGdvbGYgc29tZSBieXRlcy4uLlxuXHR0aGlzLl9wZW5kaW5nU3VzcGVuc2lvbkNvdW50ID0gMDtcblx0dGhpcy5fc3VzcGVuZGVycyA9IG51bGw7XG5cdHRoaXMuX2RldGFjaE9uTmV4dFJlbmRlciA9IG51bGw7XG59XG5cbi8vIFRoaW5ncyB3ZSBkbyBoZXJlIHRvIHNhdmUgc29tZSBieXRlcyBidXQgYXJlIG5vdCBwcm9wZXIgSlMgaW5oZXJpdGFuY2U6XG4vLyAtIGNhbGwgYG5ldyBDb21wb25lbnQoKWAgYXMgdGhlIHByb3RvdHlwZVxuLy8gLSBkbyBub3Qgc2V0IGBTdXNwZW5zZS5wcm90b3R5cGUuY29uc3RydWN0b3JgIHRvIGBTdXNwZW5zZWBcblN1c3BlbnNlLnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnQoKTtcblxuLyoqXG4gKiBAdGhpcyB7aW1wb3J0KCcuL2ludGVybmFsJykuU3VzcGVuc2VDb21wb25lbnR9XG4gKiBAcGFyYW0ge1Byb21pc2V9IHByb21pc2UgVGhlIHRocm93biBwcm9taXNlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlPGFueSwgYW55Pn0gc3VzcGVuZGluZ1ZOb2RlIFRoZSBzdXNwZW5kaW5nIGNvbXBvbmVudFxuICovXG5TdXNwZW5zZS5wcm90b3R5cGUuX2NoaWxkRGlkU3VzcGVuZCA9IGZ1bmN0aW9uKHByb21pc2UsIHN1c3BlbmRpbmdWTm9kZSkge1xuXHRjb25zdCBzdXNwZW5kaW5nQ29tcG9uZW50ID0gc3VzcGVuZGluZ1ZOb2RlLl9jb21wb25lbnQ7XG5cblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5TdXNwZW5zZUNvbXBvbmVudH0gKi9cblx0Y29uc3QgYyA9IHRoaXM7XG5cblx0aWYgKGMuX3N1c3BlbmRlcnMgPT0gbnVsbCkge1xuXHRcdGMuX3N1c3BlbmRlcnMgPSBbXTtcblx0fVxuXHRjLl9zdXNwZW5kZXJzLnB1c2goc3VzcGVuZGluZ0NvbXBvbmVudCk7XG5cblx0Y29uc3QgcmVzb2x2ZSA9IHN1c3BlbmRlZChjLl92bm9kZSk7XG5cblx0bGV0IHJlc29sdmVkID0gZmFsc2U7XG5cdGNvbnN0IG9uUmVzb2x2ZWQgPSAoKSA9PiB7XG5cdFx0aWYgKHJlc29sdmVkKSByZXR1cm47XG5cblx0XHRyZXNvbHZlZCA9IHRydWU7XG5cdFx0c3VzcGVuZGluZ0NvbXBvbmVudC5fb25SZXNvbHZlID0gbnVsbDtcblxuXHRcdGlmIChyZXNvbHZlKSB7XG5cdFx0XHRyZXNvbHZlKG9uU3VzcGVuc2lvbkNvbXBsZXRlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0b25TdXNwZW5zaW9uQ29tcGxldGUoKTtcblx0XHR9XG5cdH07XG5cblx0c3VzcGVuZGluZ0NvbXBvbmVudC5fb25SZXNvbHZlID0gb25SZXNvbHZlZDtcblxuXHRjb25zdCBvblN1c3BlbnNpb25Db21wbGV0ZSA9ICgpID0+IHtcblx0XHRpZiAoIS0tYy5fcGVuZGluZ1N1c3BlbnNpb25Db3VudCkge1xuXHRcdFx0Ly8gSWYgdGhlIHN1c3BlbnNpb24gd2FzIGR1cmluZyBoeWRyYXRpb24gd2UgZG9uJ3QgbmVlZCB0byByZXN0b3JlIHRoZVxuXHRcdFx0Ly8gc3VzcGVuZGVkIGNoaWxkcmVuIGludG8gdGhlIF9jaGlsZHJlbiBhcnJheVxuXHRcdFx0aWYgKGMuc3RhdGUuX3N1c3BlbmRlZCkge1xuXHRcdFx0XHRjb25zdCBzdXNwZW5kZWRWTm9kZSA9IGMuc3RhdGUuX3N1c3BlbmRlZDtcblx0XHRcdFx0Yy5fdm5vZGUuX2NoaWxkcmVuWzBdID0gcmVtb3ZlT3JpZ2luYWwoXG5cdFx0XHRcdFx0c3VzcGVuZGVkVk5vZGUsXG5cdFx0XHRcdFx0c3VzcGVuZGVkVk5vZGUuX2NvbXBvbmVudC5fcGFyZW50RG9tLFxuXHRcdFx0XHRcdHN1c3BlbmRlZFZOb2RlLl9jb21wb25lbnQuX29yaWdpbmFsUGFyZW50RG9tXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdGMuc2V0U3RhdGUoeyBfc3VzcGVuZGVkOiAoYy5fZGV0YWNoT25OZXh0UmVuZGVyID0gbnVsbCkgfSk7XG5cblx0XHRcdGxldCBzdXNwZW5kZWQ7XG5cdFx0XHR3aGlsZSAoKHN1c3BlbmRlZCA9IGMuX3N1c3BlbmRlcnMucG9wKCkpKSB7XG5cdFx0XHRcdHN1c3BlbmRlZC5mb3JjZVVwZGF0ZSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogV2UgZG8gbm90IHNldCBgc3VzcGVuZGVkOiB0cnVlYCBkdXJpbmcgaHlkcmF0aW9uIGJlY2F1c2Ugd2Ugd2FudCB0aGUgYWN0dWFsIG1hcmt1cFxuXHQgKiB0byByZW1haW4gb24gc2NyZWVuIGFuZCBoeWRyYXRlIGl0IHdoZW4gdGhlIHN1c3BlbnNlIGFjdHVhbGx5IGdldHMgcmVzb2x2ZWQuXG5cdCAqIFdoaWxlIGluIG5vbi1oeWRyYXRpb24gY2FzZXMgdGhlIHVzdWFsIGZhbGxiYWNrIC0+IGNvbXBvbmVudCBmbG93IHdvdWxkIG9jY291ci5cblx0ICovXG5cdGNvbnN0IHdhc0h5ZHJhdGluZyA9IHN1c3BlbmRpbmdWTm9kZS5faHlkcmF0aW5nID09PSB0cnVlO1xuXHRpZiAoIWMuX3BlbmRpbmdTdXNwZW5zaW9uQ291bnQrKyAmJiAhd2FzSHlkcmF0aW5nKSB7XG5cdFx0Yy5zZXRTdGF0ZSh7IF9zdXNwZW5kZWQ6IChjLl9kZXRhY2hPbk5leHRSZW5kZXIgPSBjLl92bm9kZS5fY2hpbGRyZW5bMF0pIH0pO1xuXHR9XG5cdHByb21pc2UudGhlbihvblJlc29sdmVkLCBvblJlc29sdmVkKTtcbn07XG5cblN1c3BlbnNlLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLl9zdXNwZW5kZXJzID0gW107XG59O1xuXG4vKipcbiAqIEB0aGlzIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5TdXNwZW5zZUNvbXBvbmVudH1cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuU3VzcGVuc2VDb21wb25lbnRbXCJwcm9wc1wiXX0gcHJvcHNcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuU3VzcGVuc2VTdGF0ZX0gc3RhdGVcbiAqL1xuU3VzcGVuc2UucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHByb3BzLCBzdGF0ZSkge1xuXHRpZiAodGhpcy5fZGV0YWNoT25OZXh0UmVuZGVyKSB7XG5cdFx0Ly8gV2hlbiB0aGUgU3VzcGVuc2UncyBfdm5vZGUgd2FzIGNyZWF0ZWQgYnkgYSBjYWxsIHRvIGNyZWF0ZVZOb2RlXG5cdFx0Ly8gKGkuZS4gZHVlIHRvIGEgc2V0U3RhdGUgZnVydGhlciB1cCBpbiB0aGUgdHJlZSlcblx0XHQvLyBpdCdzIF9jaGlsZHJlbiBwcm9wIGlzIG51bGwsIGluIHRoaXMgY2FzZSB3ZSBcImZvcmdldFwiIGFib3V0IHRoZSBwYXJrZWQgdm5vZGVzIHRvIGRldGFjaFxuXHRcdGlmICh0aGlzLl92bm9kZS5fY2hpbGRyZW4pIHtcblx0XHRcdGNvbnN0IGRldGFjaGVkUGFyZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0XHRjb25zdCBkZXRhY2hlZENvbXBvbmVudCA9IHRoaXMuX3Zub2RlLl9jaGlsZHJlblswXS5fY29tcG9uZW50O1xuXHRcdFx0dGhpcy5fdm5vZGUuX2NoaWxkcmVuWzBdID0gZGV0YWNoZWRDbG9uZShcblx0XHRcdFx0dGhpcy5fZGV0YWNoT25OZXh0UmVuZGVyLFxuXHRcdFx0XHRkZXRhY2hlZFBhcmVudCxcblx0XHRcdFx0KGRldGFjaGVkQ29tcG9uZW50Ll9vcmlnaW5hbFBhcmVudERvbSA9IGRldGFjaGVkQ29tcG9uZW50Ll9wYXJlbnREb20pXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2RldGFjaE9uTmV4dFJlbmRlciA9IG51bGw7XG5cdH1cblxuXHQvLyBXcmFwIGZhbGxiYWNrIHRyZWUgaW4gYSBWTm9kZSB0aGF0IHByZXZlbnRzIGl0c2VsZiBmcm9tIGJlaW5nIG1hcmtlZCBhcyBhYm9ydGluZyBtaWQtaHlkcmF0aW9uOlxuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSAqL1xuXHRjb25zdCBmYWxsYmFjayA9XG5cdFx0c3RhdGUuX3N1c3BlbmRlZCAmJiBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBwcm9wcy5mYWxsYmFjayk7XG5cdGlmIChmYWxsYmFjaykgZmFsbGJhY2suX2h5ZHJhdGluZyA9IG51bGw7XG5cblx0cmV0dXJuIFtcblx0XHRjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBzdGF0ZS5fc3VzcGVuZGVkID8gbnVsbCA6IHByb3BzLmNoaWxkcmVuKSxcblx0XHRmYWxsYmFja1xuXHRdO1xufTtcblxuLyoqXG4gKiBDaGVja3MgYW5kIGNhbGxzIHRoZSBwYXJlbnQgY29tcG9uZW50J3MgX3N1c3BlbmRlZCBtZXRob2QsIHBhc3NpbmcgaW4gdGhlXG4gKiBzdXNwZW5kZWQgdm5vZGUuIFRoaXMgaXMgYSB3YXkgZm9yIGEgcGFyZW50IChlLmcuIFN1c3BlbnNlTGlzdCkgdG8gZ2V0IG5vdGlmaWVkXG4gKiB0aGF0IG9uZSBvZiBpdHMgY2hpbGRyZW4vZGVzY2VuZGFudHMgc3VzcGVuZGVkLlxuICpcbiAqIFRoZSBwYXJlbnQgTUFZIHJldHVybiBhIGNhbGxiYWNrLiBUaGUgY2FsbGJhY2sgd2lsbCBnZXQgY2FsbGVkIHdoZW4gdGhlXG4gKiBzdXNwZW5zaW9uIHJlc29sdmVzLCBub3RpZnlpbmcgdGhlIHBhcmVudCBvZiB0aGUgZmFjdC5cbiAqIE1vcmVvdmVyLCB0aGUgY2FsbGJhY2sgZ2V0cyBmdW5jdGlvbiBgdW5zdXNwZW5kYCBhcyBhIHBhcmFtZXRlci4gVGhlIHJlc29sdmVkXG4gKiBjaGlsZCBkZXNjZW5kYW50IHdpbGwgbm90IGFjdHVhbGx5IGdldCB1bnN1c3BlbmRlZCB1bnRpbCBgdW5zdXNwZW5kYCBnZXRzIGNhbGxlZC5cbiAqIFRoaXMgaXMgYSB3YXkgZm9yIHRoZSBwYXJlbnQgdG8gZGVsYXkgdW5zdXNwZW5kaW5nLlxuICpcbiAqIElmIHRoZSBwYXJlbnQgZG9lcyBub3QgcmV0dXJuIGEgY2FsbGJhY2sgdGhlbiB0aGUgcmVzb2x2ZWQgdm5vZGVcbiAqIGdldHMgdW5zdXNwZW5kZWQgaW1tZWRpYXRlbHkgd2hlbiBpdCByZXNvbHZlcy5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICogQHJldHVybnMgeygodW5zdXNwZW5kOiAoKSA9PiB2b2lkKSA9PiB2b2lkKT99XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdXNwZW5kZWQodm5vZGUpIHtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9ICovXG5cdGxldCBjb21wb25lbnQgPSB2bm9kZS5fcGFyZW50Ll9jb21wb25lbnQ7XG5cdHJldHVybiBjb21wb25lbnQgJiYgY29tcG9uZW50Ll9zdXNwZW5kZWQgJiYgY29tcG9uZW50Ll9zdXNwZW5kZWQodm5vZGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGF6eShsb2FkZXIpIHtcblx0bGV0IHByb207XG5cdGxldCBjb21wb25lbnQ7XG5cdGxldCBlcnJvcjtcblxuXHRmdW5jdGlvbiBMYXp5KHByb3BzKSB7XG5cdFx0aWYgKCFwcm9tKSB7XG5cdFx0XHRwcm9tID0gbG9hZGVyKCk7XG5cdFx0XHRwcm9tLnRoZW4oXG5cdFx0XHRcdGV4cG9ydHMgPT4ge1xuXHRcdFx0XHRcdGNvbXBvbmVudCA9IGV4cG9ydHMuZGVmYXVsdCB8fCBleHBvcnRzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRlID0+IHtcblx0XHRcdFx0XHRlcnJvciA9IGU7XG5cdFx0XHRcdH1cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0aWYgKGVycm9yKSB7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cblx0XHRpZiAoIWNvbXBvbmVudCkge1xuXHRcdFx0dGhyb3cgcHJvbTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY3JlYXRlRWxlbWVudChjb21wb25lbnQsIHByb3BzKTtcblx0fVxuXG5cdExhenkuZGlzcGxheU5hbWUgPSAnTGF6eSc7XG5cdExhenkuX2ZvcndhcmRlZCA9IHRydWU7XG5cdHJldHVybiBMYXp5O1xufVxuIiwgImltcG9ydCB7IENvbXBvbmVudCwgdG9DaGlsZEFycmF5IH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCB7IHN1c3BlbmRlZCB9IGZyb20gJy4vc3VzcGVuc2UuanMnO1xuXG4vLyBJbmRleGVzIHRvIGxpbmtlZCBsaXN0IG5vZGVzIChub2RlcyBhcmUgc3RvcmVkIGFzIGFycmF5cyB0byBzYXZlIGJ5dGVzKS5cbmNvbnN0IFNVU1BFTkRFRF9DT1VOVCA9IDA7XG5jb25zdCBSRVNPTFZFRF9DT1VOVCA9IDE7XG5jb25zdCBORVhUX05PREUgPSAyO1xuXG4vLyBIYXZpbmcgY3VzdG9tIGluaGVyaXRhbmNlIGluc3RlYWQgb2YgYSBjbGFzcyBoZXJlIHNhdmVzIGEgbG90IG9mIGJ5dGVzLlxuZXhwb3J0IGZ1bmN0aW9uIFN1c3BlbnNlTGlzdCgpIHtcblx0dGhpcy5fbmV4dCA9IG51bGw7XG5cdHRoaXMuX21hcCA9IG51bGw7XG59XG5cbi8vIE1hcmsgb25lIG9mIGNoaWxkJ3MgZWFybGllciBzdXNwZW5zaW9ucyBhcyByZXNvbHZlZC5cbi8vIFNvbWUgcGVuZGluZyBjYWxsYmFja3MgbWF5IGJlY29tZSBjYWxsYWJsZSBkdWUgdG8gdGhpc1xuLy8gKGUuZy4gdGhlIGxhc3Qgc3VzcGVuZGVkIGRlc2NlbmRhbnQgZ2V0cyByZXNvbHZlZCB3aGVuXG4vLyByZXZlYWxPcmRlciA9PT0gJ3RvZ2V0aGVyJykuIFByb2Nlc3MgdGhvc2UgY2FsbGJhY2tzIGFzIHdlbGwuXG5jb25zdCByZXNvbHZlID0gKGxpc3QsIGNoaWxkLCBub2RlKSA9PiB7XG5cdGlmICgrK25vZGVbUkVTT0xWRURfQ09VTlRdID09PSBub2RlW1NVU1BFTkRFRF9DT1VOVF0pIHtcblx0XHQvLyBUaGUgbnVtYmVyIGEgY2hpbGQgKG9yIGFueSBvZiBpdHMgZGVzY2VuZGFudHMpIGhhcyBiZWVuIHN1c3BlbmRlZFxuXHRcdC8vIG1hdGNoZXMgdGhlIG51bWJlciBvZiB0aW1lcyBpdCdzIGJlZW4gcmVzb2x2ZWQuIFRoZXJlZm9yZSB3ZVxuXHRcdC8vIG1hcmsgdGhlIGNoaWxkIGFzIGNvbXBsZXRlbHkgcmVzb2x2ZWQgYnkgZGVsZXRpbmcgaXQgZnJvbSAuX21hcC5cblx0XHQvLyBUaGlzIGlzIHVzZWQgdG8gZmlndXJlIG91dCB3aGVuICphbGwqIGNoaWxkcmVuIGhhdmUgYmVlbiBjb21wbGV0ZWx5XG5cdFx0Ly8gcmVzb2x2ZWQgd2hlbiByZXZlYWxPcmRlciBpcyAndG9nZXRoZXInLlxuXHRcdGxpc3QuX21hcC5kZWxldGUoY2hpbGQpO1xuXHR9XG5cblx0Ly8gSWYgcmV2ZWFsT3JkZXIgaXMgZmFsc3kgdGhlbiB3ZSBjYW4gZG8gYW4gZWFybHkgZXhpdCwgYXMgdGhlXG5cdC8vIGNhbGxiYWNrcyB3b24ndCBnZXQgcXVldWVkIGluIHRoZSBub2RlIGFueXdheS5cblx0Ly8gSWYgcmV2ZWFsT3JkZXIgaXMgJ3RvZ2V0aGVyJyB0aGVuIGFsc28gZG8gYW4gZWFybHkgZXhpdFxuXHQvLyBpZiBhbGwgc3VzcGVuZGVkIGRlc2NlbmRhbnRzIGhhdmUgbm90IHlldCBiZWVuIHJlc29sdmVkLlxuXHRpZiAoXG5cdFx0IWxpc3QucHJvcHMucmV2ZWFsT3JkZXIgfHxcblx0XHQobGlzdC5wcm9wcy5yZXZlYWxPcmRlclswXSA9PT0gJ3QnICYmIGxpc3QuX21hcC5zaXplKVxuXHQpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBXYWxrIHRoZSBjdXJyZW50bHkgc3VzcGVuZGVkIGNoaWxkcmVuIGluIG9yZGVyLCBjYWxsaW5nIHRoZWlyXG5cdC8vIHN0b3JlZCBjYWxsYmFja3Mgb24gdGhlIHdheS4gU3RvcCBpZiB3ZSBlbmNvdW50ZXIgYSBjaGlsZCB0aGF0XG5cdC8vIGhhcyBub3QgYmVlbiBjb21wbGV0ZWx5IHJlc29sdmVkIHlldC5cblx0bm9kZSA9IGxpc3QuX25leHQ7XG5cdHdoaWxlIChub2RlKSB7XG5cdFx0d2hpbGUgKG5vZGUubGVuZ3RoID4gMykge1xuXHRcdFx0bm9kZS5wb3AoKSgpO1xuXHRcdH1cblx0XHRpZiAobm9kZVtSRVNPTFZFRF9DT1VOVF0gPCBub2RlW1NVU1BFTkRFRF9DT1VOVF0pIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHRsaXN0Ll9uZXh0ID0gbm9kZSA9IG5vZGVbTkVYVF9OT0RFXTtcblx0fVxufTtcblxuLy8gVGhpbmdzIHdlIGRvIGhlcmUgdG8gc2F2ZSBzb21lIGJ5dGVzIGJ1dCBhcmUgbm90IHByb3BlciBKUyBpbmhlcml0YW5jZTpcbi8vIC0gY2FsbCBgbmV3IENvbXBvbmVudCgpYCBhcyB0aGUgcHJvdG90eXBlXG4vLyAtIGRvIG5vdCBzZXQgYFN1c3BlbnNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvcmAgdG8gYFN1c3BlbnNlYFxuU3VzcGVuc2VMaXN0LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnQoKTtcblxuU3VzcGVuc2VMaXN0LnByb3RvdHlwZS5fc3VzcGVuZGVkID0gZnVuY3Rpb24oY2hpbGQpIHtcblx0Y29uc3QgbGlzdCA9IHRoaXM7XG5cdGNvbnN0IGRlbGVnYXRlZCA9IHN1c3BlbmRlZChsaXN0Ll92bm9kZSk7XG5cblx0bGV0IG5vZGUgPSBsaXN0Ll9tYXAuZ2V0KGNoaWxkKTtcblx0bm9kZVtTVVNQRU5ERURfQ09VTlRdKys7XG5cblx0cmV0dXJuIHVuc3VzcGVuZCA9PiB7XG5cdFx0Y29uc3Qgd3JhcHBlZFVuc3VzcGVuZCA9ICgpID0+IHtcblx0XHRcdGlmICghbGlzdC5wcm9wcy5yZXZlYWxPcmRlcikge1xuXHRcdFx0XHQvLyBTcGVjaWFsIGNhc2UgdGhlIHVuZGVmaW5lZCAoZmFsc3kpIHJldmVhbE9yZGVyLCBhcyB0aGVyZVxuXHRcdFx0XHQvLyBpcyBubyBuZWVkIHRvIGNvb3JkaW5hdGUgYSBzcGVjaWZpYyBvcmRlciBvciB1bnN1c3BlbmRzLlxuXHRcdFx0XHR1bnN1c3BlbmQoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5vZGUucHVzaCh1bnN1c3BlbmQpO1xuXHRcdFx0XHRyZXNvbHZlKGxpc3QsIGNoaWxkLCBub2RlKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdGlmIChkZWxlZ2F0ZWQpIHtcblx0XHRcdGRlbGVnYXRlZCh3cmFwcGVkVW5zdXNwZW5kKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0d3JhcHBlZFVuc3VzcGVuZCgpO1xuXHRcdH1cblx0fTtcbn07XG5cblN1c3BlbnNlTGlzdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24ocHJvcHMpIHtcblx0dGhpcy5fbmV4dCA9IG51bGw7XG5cdHRoaXMuX21hcCA9IG5ldyBNYXAoKTtcblxuXHRjb25zdCBjaGlsZHJlbiA9IHRvQ2hpbGRBcnJheShwcm9wcy5jaGlsZHJlbik7XG5cdGlmIChwcm9wcy5yZXZlYWxPcmRlciAmJiBwcm9wcy5yZXZlYWxPcmRlclswXSA9PT0gJ2InKSB7XG5cdFx0Ly8gSWYgb3JkZXIgPT09ICdiYWNrd2FyZHMnIChvciwgd2VsbCwgYW55dGhpbmcgc3RhcnRpbmcgd2l0aCBhICdiJylcblx0XHQvLyB0aGVuIGZsaXAgdGhlIGNoaWxkIGxpc3QgYXJvdW5kIHNvIHRoYXQgdGhlIGxhc3QgY2hpbGQgd2lsbCBiZVxuXHRcdC8vIHRoZSBmaXJzdCBpbiB0aGUgbGlua2VkIGxpc3QuXG5cdFx0Y2hpbGRyZW4ucmV2ZXJzZSgpO1xuXHR9XG5cdC8vIEJ1aWxkIHRoZSBsaW5rZWQgbGlzdC4gSXRlcmF0ZSB0aHJvdWdoIHRoZSBjaGlsZHJlbiBpbiByZXZlcnNlIG9yZGVyXG5cdC8vIHNvIHRoYXQgYF9uZXh0YCBwb2ludHMgdG8gdGhlIGZpcnN0IGxpbmtlZCBsaXN0IG5vZGUgdG8gYmUgcmVzb2x2ZWQuXG5cdGZvciAobGV0IGkgPSBjaGlsZHJlbi5sZW5ndGg7IGktLTsgKSB7XG5cdFx0Ly8gQ3JlYXRlIGEgbmV3IGxpbmtlZCBsaXN0IG5vZGUgYXMgYW4gYXJyYXkgb2YgZm9ybTpcblx0XHQvLyBcdFtzdXNwZW5kZWRfY291bnQsIHJlc29sdmVkX2NvdW50LCBuZXh0X25vZGVdXG5cdFx0Ly8gd2hlcmUgc3VzcGVuZGVkX2NvdW50IGFuZCByZXNvbHZlZF9jb3VudCBhcmUgbnVtZXJpYyBjb3VudGVycyBmb3Jcblx0XHQvLyBrZWVwaW5nIHRyYWNrIGhvdyBtYW55IHRpbWVzIGEgbm9kZSBoYXMgYmVlbiBzdXNwZW5kZWQgYW5kIHJlc29sdmVkLlxuXHRcdC8vXG5cdFx0Ly8gTm90ZSB0aGF0IHN1c3BlbmRlZF9jb3VudCBzdGFydHMgZnJvbSAxIGluc3RlYWQgb2YgMCwgc28gd2UgY2FuIGJsb2NrXG5cdFx0Ly8gcHJvY2Vzc2luZyBjYWxsYmFja3MgdW50aWwgY29tcG9uZW50RGlkTW91bnQgaGFzIGJlZW4gY2FsbGVkLiBJbiBhIHNlbnNlXG5cdFx0Ly8gbm9kZSBpcyBzdXNwZW5kZWQgYXQgbGVhc3QgdW50aWwgY29tcG9uZW50RGlkTW91bnQgZ2V0cyBjYWxsZWQhXG5cdFx0Ly9cblx0XHQvLyBQZW5kaW5nIGNhbGxiYWNrcyBhcmUgYWRkZWQgdG8gdGhlIGVuZCBvZiB0aGUgbm9kZTpcblx0XHQvLyBcdFtzdXNwZW5kZWRfY291bnQsIHJlc29sdmVkX2NvdW50LCBuZXh0X25vZGUsIGNhbGxiYWNrXzAsIGNhbGxiYWNrXzEsIC4uLl1cblx0XHR0aGlzLl9tYXAuc2V0KGNoaWxkcmVuW2ldLCAodGhpcy5fbmV4dCA9IFsxLCAwLCB0aGlzLl9uZXh0XSkpO1xuXHR9XG5cdHJldHVybiBwcm9wcy5jaGlsZHJlbjtcbn07XG5cblN1c3BlbnNlTGlzdC5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gU3VzcGVuc2VMaXN0LnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uKCkge1xuXHQvLyBJdGVyYXRlIHRocm91Z2ggYWxsIGNoaWxkcmVuIGFmdGVyIG1vdW50aW5nIGZvciB0d28gcmVhc29uczpcblx0Ly8gMS4gQXMgZWFjaCBub2RlW1NVU1BFTkRFRF9DT1VOVF0gc3RhcnRzIGZyb20gMSwgdGhpcyBpdGVyYXRpb24gaW5jcmVhc2VzXG5cdC8vICAgIGVhY2ggbm9kZVtSRUxFQVNFRF9DT1VOVF0gYnkgMSwgdGhlcmVmb3JlIGJhbGFuY2luZyB0aGUgY291bnRlcnMuXG5cdC8vICAgIFRoZSBub2RlcyBjYW4gbm93IGJlIGNvbXBsZXRlbHkgY29uc3VtZWQgZnJvbSB0aGUgbGlua2VkIGxpc3QuXG5cdC8vIDIuIEhhbmRsZSBub2RlcyB0aGF0IG1pZ2h0IGhhdmUgZ290dGVuIHJlc29sdmVkIGJldHdlZW4gcmVuZGVyIGFuZFxuXHQvLyAgICBjb21wb25lbnREaWRNb3VudC5cblx0dGhpcy5fbWFwLmZvckVhY2goKG5vZGUsIGNoaWxkKSA9PiB7XG5cdFx0cmVzb2x2ZSh0aGlzLCBjaGlsZCwgbm9kZSk7XG5cdH0pO1xufTtcbiIsICJpbXBvcnQgeyBjcmVhdGVFbGVtZW50LCByZW5kZXIgfSBmcm9tICdwcmVhY3QnO1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi9zcmMvaW5kZXgnKS5SZW5kZXJhYmxlUHJvcHM8eyBjb250ZXh0OiBhbnkgfT59IHByb3BzXG4gKi9cbmZ1bmN0aW9uIENvbnRleHRQcm92aWRlcihwcm9wcykge1xuXHR0aGlzLmdldENoaWxkQ29udGV4dCA9ICgpID0+IHByb3BzLmNvbnRleHQ7XG5cdHJldHVybiBwcm9wcy5jaGlsZHJlbjtcbn1cblxuLyoqXG4gKiBQb3J0YWwgY29tcG9uZW50XG4gKiBAdGhpcyB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fVxuICogQHBhcmFtIHtvYmplY3QgfCBudWxsIHwgdW5kZWZpbmVkfSBwcm9wc1xuICpcbiAqIFRPRE86IHVzZSBjcmVhdGVSb290KCkgaW5zdGVhZCBvZiBmYWtlIHJvb3RcbiAqL1xuZnVuY3Rpb24gUG9ydGFsKHByb3BzKSB7XG5cdGNvbnN0IF90aGlzID0gdGhpcztcblx0bGV0IGNvbnRhaW5lciA9IHByb3BzLl9jb250YWluZXI7XG5cblx0X3RoaXMuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbigpIHtcblx0XHRyZW5kZXIobnVsbCwgX3RoaXMuX3RlbXApO1xuXHRcdF90aGlzLl90ZW1wID0gbnVsbDtcblx0XHRfdGhpcy5fY29udGFpbmVyID0gbnVsbDtcblx0fTtcblxuXHQvLyBXaGVuIHdlIGNoYW5nZSBjb250YWluZXIgd2Ugc2hvdWxkIGNsZWFyIG91ciBvbGQgY29udGFpbmVyIGFuZFxuXHQvLyBpbmRpY2F0ZSBhIG5ldyBtb3VudC5cblx0aWYgKF90aGlzLl9jb250YWluZXIgJiYgX3RoaXMuX2NvbnRhaW5lciAhPT0gY29udGFpbmVyKSB7XG5cdFx0X3RoaXMuY29tcG9uZW50V2lsbFVubW91bnQoKTtcblx0fVxuXG5cdC8vIFdoZW4gcHJvcHMudm5vZGUgaXMgdW5kZWZpbmVkL2ZhbHNlL251bGwgd2UgYXJlIGRlYWxpbmcgd2l0aCBzb21lIGtpbmQgb2Zcblx0Ly8gY29uZGl0aW9uYWwgdm5vZGUuIFRoaXMgc2hvdWxkIG5vdCB0cmlnZ2VyIGEgcmVuZGVyLlxuXHRpZiAocHJvcHMuX3Zub2RlKSB7XG5cdFx0aWYgKCFfdGhpcy5fdGVtcCkge1xuXHRcdFx0X3RoaXMuX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcblxuXHRcdFx0Ly8gQ3JlYXRlIGEgZmFrZSBET00gcGFyZW50IG5vZGUgdGhhdCBtYW5hZ2VzIGEgc3Vic2V0IG9mIGBjb250YWluZXJgJ3MgY2hpbGRyZW46XG5cdFx0XHRfdGhpcy5fdGVtcCA9IHtcblx0XHRcdFx0bm9kZVR5cGU6IDEsXG5cdFx0XHRcdHBhcmVudE5vZGU6IGNvbnRhaW5lcixcblx0XHRcdFx0Y2hpbGROb2RlczogW10sXG5cdFx0XHRcdGFwcGVuZENoaWxkKGNoaWxkKSB7XG5cdFx0XHRcdFx0dGhpcy5jaGlsZE5vZGVzLnB1c2goY2hpbGQpO1xuXHRcdFx0XHRcdF90aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRpbnNlcnRCZWZvcmUoY2hpbGQsIGJlZm9yZSkge1xuXHRcdFx0XHRcdHRoaXMuY2hpbGROb2Rlcy5wdXNoKGNoaWxkKTtcblx0XHRcdFx0XHRfdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKGNoaWxkKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0cmVtb3ZlQ2hpbGQoY2hpbGQpIHtcblx0XHRcdFx0XHR0aGlzLmNoaWxkTm9kZXMuc3BsaWNlKHRoaXMuY2hpbGROb2Rlcy5pbmRleE9mKGNoaWxkKSA+Pj4gMSwgMSk7XG5cdFx0XHRcdFx0X3RoaXMuX2NvbnRhaW5lci5yZW1vdmVDaGlsZChjaGlsZCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gUmVuZGVyIG91ciB3cmFwcGluZyBlbGVtZW50IGludG8gdGVtcC5cblx0XHRyZW5kZXIoXG5cdFx0XHRjcmVhdGVFbGVtZW50KENvbnRleHRQcm92aWRlciwgeyBjb250ZXh0OiBfdGhpcy5jb250ZXh0IH0sIHByb3BzLl92bm9kZSksXG5cdFx0XHRfdGhpcy5fdGVtcFxuXHRcdCk7XG5cdH1cblx0Ly8gV2hlbiB3ZSBjb21lIGZyb20gYSBjb25kaXRpb25hbCByZW5kZXIsIG9uIGEgbW91bnRlZFxuXHQvLyBwb3J0YWwgd2Ugc2hvdWxkIGNsZWFyIHRoZSBET00uXG5cdGVsc2UgaWYgKF90aGlzLl90ZW1wKSB7XG5cdFx0X3RoaXMuY29tcG9uZW50V2lsbFVubW91bnQoKTtcblx0fVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIGBQb3J0YWxgIHRvIGNvbnRpbnVlIHJlbmRlcmluZyB0aGUgdm5vZGUgdHJlZSBhdCBhIGRpZmZlcmVudCBET00gbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGUgVGhlIHZub2RlIHRvIHJlbmRlclxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBjb250YWluZXIgVGhlIERPTSBub2RlIHRvIGNvbnRpbnVlIHJlbmRlcmluZyBpbiB0by5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVBvcnRhbCh2bm9kZSwgY29udGFpbmVyKSB7XG5cdGNvbnN0IGVsID0gY3JlYXRlRWxlbWVudChQb3J0YWwsIHsgX3Zub2RlOiB2bm9kZSwgX2NvbnRhaW5lcjogY29udGFpbmVyIH0pO1xuXHRlbC5jb250YWluZXJJbmZvID0gY29udGFpbmVyO1xuXHRyZXR1cm4gZWw7XG59XG4iLCAiaW1wb3J0IHtcblx0cmVuZGVyIGFzIHByZWFjdFJlbmRlcixcblx0aHlkcmF0ZSBhcyBwcmVhY3RIeWRyYXRlLFxuXHRvcHRpb25zLFxuXHR0b0NoaWxkQXJyYXksXG5cdENvbXBvbmVudFxufSBmcm9tICdwcmVhY3QnO1xuXG5leHBvcnQgY29uc3QgUkVBQ1RfRUxFTUVOVF9UWVBFID1cblx0KHR5cGVvZiBTeW1ib2wgIT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLmZvciAmJiBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykpIHx8XG5cdDB4ZWFjNztcblxuY29uc3QgQ0FNRUxfUFJPUFMgPSAvXig/OmFjY2VudHxhbGlnbm1lbnR8YXJhYmljfGJhc2VsaW5lfGNhcHxjbGlwKD8hUGF0aFUpfGNvbG9yfGRvbWluYW50fGZpbGx8Zmxvb2R8Zm9udHxnbHlwaCg/IVIpfGhvcml6fGltYWdlfGxldHRlcnxsaWdodGluZ3xtYXJrZXIoPyFIfFd8VSl8b3ZlcmxpbmV8cGFpbnR8cG9pbnRlcnxzaGFwZXxzdG9wfHN0cmlrZXRocm91Z2h8c3Ryb2tlfHRleHQoPyFMKXx0cmFuc2Zvcm18dW5kZXJsaW5lfHVuaWNvZGV8dW5pdHN8dnx2ZWN0b3J8dmVydHx3b3JkfHdyaXRpbmd8eCg/IUMpKVtBLVpdLztcblxuY29uc3QgSVNfRE9NID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcblxuLy8gSW5wdXQgdHlwZXMgZm9yIHdoaWNoIG9uY2hhbmdlIHNob3VsZCBub3QgYmUgY29udmVydGVkIHRvIG9uaW5wdXQuXG4vLyB0eXBlPVwiZmlsZXxjaGVja2JveHxyYWRpb1wiLCBwbHVzIFwicmFuZ2VcIiBpbiBJRTExLlxuLy8gKElFMTEgZG9lc24ndCBzdXBwb3J0IFN5bWJvbCwgd2hpY2ggd2UgdXNlIGhlcmUgdG8gdHVybiBgcmFkYCBpbnRvIGByYWAgd2hpY2ggbWF0Y2hlcyBcInJhbmdlXCIpXG5jb25zdCBvbkNoYW5nZUlucHV0VHlwZSA9IHR5cGUgPT5cblx0KHR5cGVvZiBTeW1ib2wgIT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIFN5bWJvbCgpID09ICdzeW1ib2wnXG5cdFx0PyAvZmlsfGNoZXxyYWQvaVxuXHRcdDogL2ZpbHxjaGV8cmEvaVxuXHQpLnRlc3QodHlwZSk7XG5cbi8vIFNvbWUgbGlicmFyaWVzIGxpa2UgYHJlYWN0LXZpcnR1YWxpemVkYCBleHBsaWNpdGx5IGNoZWNrIGZvciB0aGlzLlxuQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG5cbi8vIGBVTlNBRkVfKmAgbGlmZWN5Y2xlIGhvb2tzXG4vLyBQcmVhY3Qgb25seSBldmVyIGludm9rZXMgdGhlIHVucHJlZml4ZWQgbWV0aG9kcy5cbi8vIEhlcmUgd2UgcHJvdmlkZSBhIGJhc2UgXCJmYWxsYmFja1wiIGltcGxlbWVudGF0aW9uIHRoYXQgY2FsbHMgYW55IGRlZmluZWQgVU5TQUZFXyBwcmVmaXhlZCBtZXRob2QuXG4vLyAtIElmIGEgY29tcG9uZW50IGRlZmluZXMgaXRzIG93biBgY29tcG9uZW50RGlkTW91bnQoKWAgKGluY2x1ZGluZyB2aWEgZGVmaW5lUHJvcGVydHkpLCB1c2UgdGhhdC5cbi8vIC0gSWYgYSBjb21wb25lbnQgZGVmaW5lcyBgVU5TQUZFX2NvbXBvbmVudERpZE1vdW50KClgLCBgY29tcG9uZW50RGlkTW91bnRgIGlzIHRoZSBhbGlhcyBnZXR0ZXIvc2V0dGVyLlxuLy8gLSBJZiBhbnl0aGluZyBhc3NpZ25zIHRvIGFuIGBVTlNBRkVfKmAgcHJvcGVydHksIHRoZSBhc3NpZ25tZW50IGlzIGZvcndhcmRlZCB0byB0aGUgdW5wcmVmaXhlZCBwcm9wZXJ0eS5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJlYWN0anMvcHJlYWN0L2lzc3Vlcy8xOTQxXG5bXG5cdCdjb21wb25lbnRXaWxsTW91bnQnLFxuXHQnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcycsXG5cdCdjb21wb25lbnRXaWxsVXBkYXRlJ1xuXS5mb3JFYWNoKGtleSA9PiB7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBrZXksIHtcblx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0Z2V0KCkge1xuXHRcdFx0cmV0dXJuIHRoaXNbJ1VOU0FGRV8nICsga2V5XTtcblx0XHR9LFxuXHRcdHNldCh2KSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdHZhbHVlOiB2XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0pO1xufSk7XG5cbi8qKlxuICogUHJveHkgcmVuZGVyKCkgc2luY2UgUmVhY3QgcmV0dXJucyBhIENvbXBvbmVudCByZWZlcmVuY2UuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZSBWTm9kZSB0cmVlIHRvIHJlbmRlclxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBwYXJlbnQgRE9NIG5vZGUgdG8gcmVuZGVyIHZub2RlIHRyZWUgaW50b1xuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBbY2FsbGJhY2tdIE9wdGlvbmFsIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgcmVuZGVyaW5nXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50IHwgbnVsbH0gVGhlIHJvb3QgY29tcG9uZW50IHJlZmVyZW5jZSBvciBudWxsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXIodm5vZGUsIHBhcmVudCwgY2FsbGJhY2spIHtcblx0Ly8gUmVhY3QgZGVzdHJveXMgYW55IGV4aXN0aW5nIERPTSBub2Rlcywgc2VlICMxNzI3XG5cdC8vIC4uLmJ1dCBvbmx5IG9uIHRoZSBmaXJzdCByZW5kZXIsIHNlZSAjMTgyOFxuXHRpZiAocGFyZW50Ll9jaGlsZHJlbiA9PSBudWxsKSB7XG5cdFx0cGFyZW50LnRleHRDb250ZW50ID0gJyc7XG5cdH1cblxuXHRwcmVhY3RSZW5kZXIodm5vZGUsIHBhcmVudCk7XG5cdGlmICh0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2soKTtcblxuXHRyZXR1cm4gdm5vZGUgPyB2bm9kZS5fY29tcG9uZW50IDogbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGh5ZHJhdGUodm5vZGUsIHBhcmVudCwgY2FsbGJhY2spIHtcblx0cHJlYWN0SHlkcmF0ZSh2bm9kZSwgcGFyZW50KTtcblx0aWYgKHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nKSBjYWxsYmFjaygpO1xuXG5cdHJldHVybiB2bm9kZSA/IHZub2RlLl9jb21wb25lbnQgOiBudWxsO1xufVxuXG5sZXQgb2xkRXZlbnRIb29rID0gb3B0aW9ucy5ldmVudDtcbm9wdGlvbnMuZXZlbnQgPSBlID0+IHtcblx0aWYgKG9sZEV2ZW50SG9vaykgZSA9IG9sZEV2ZW50SG9vayhlKTtcblx0ZS5wZXJzaXN0ID0gZW1wdHk7XG5cdGUuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBpc1Byb3BhZ2F0aW9uU3RvcHBlZDtcblx0ZS5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBpc0RlZmF1bHRQcmV2ZW50ZWQ7XG5cdHJldHVybiAoZS5uYXRpdmVFdmVudCA9IGUpO1xufTtcblxuZnVuY3Rpb24gZW1wdHkoKSB7fVxuXG5mdW5jdGlvbiBpc1Byb3BhZ2F0aW9uU3RvcHBlZCgpIHtcblx0cmV0dXJuIHRoaXMuY2FuY2VsQnViYmxlO1xufVxuXG5mdW5jdGlvbiBpc0RlZmF1bHRQcmV2ZW50ZWQoKSB7XG5cdHJldHVybiB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQ7XG59XG5cbmxldCBjbGFzc05hbWVEZXNjcmlwdG9yID0ge1xuXHRjb25maWd1cmFibGU6IHRydWUsXG5cdGdldCgpIHtcblx0XHRyZXR1cm4gdGhpcy5jbGFzcztcblx0fVxufTtcblxubGV0IG9sZFZOb2RlSG9vayA9IG9wdGlvbnMudm5vZGU7XG5vcHRpb25zLnZub2RlID0gdm5vZGUgPT4ge1xuXHRsZXQgdHlwZSA9IHZub2RlLnR5cGU7XG5cdGxldCBwcm9wcyA9IHZub2RlLnByb3BzO1xuXHRsZXQgbm9ybWFsaXplZFByb3BzID0gcHJvcHM7XG5cblx0Ly8gb25seSBub3JtYWxpemUgcHJvcHMgb24gRWxlbWVudCBub2Rlc1xuXHRpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG5cdFx0Y29uc3Qgbm9uQ3VzdG9tRWxlbWVudCA9IHR5cGUuaW5kZXhPZignLScpID09PSAtMTtcblx0XHRub3JtYWxpemVkUHJvcHMgPSB7fTtcblxuXHRcdGZvciAobGV0IGkgaW4gcHJvcHMpIHtcblx0XHRcdGxldCB2YWx1ZSA9IHByb3BzW2ldO1xuXG5cdFx0XHRpZiAoSVNfRE9NICYmIGkgPT09ICdjaGlsZHJlbicgJiYgdHlwZSA9PT0gJ25vc2NyaXB0Jykge1xuXHRcdFx0XHQvLyBFbXVsYXRlIFJlYWN0J3MgYmVoYXZpb3Igb2Ygbm90IHJlbmRlcmluZyB0aGUgY29udGVudHMgb2Ygbm9zY3JpcHQgdGFncyBvbiB0aGUgY2xpZW50LlxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH0gZWxzZSBpZiAoaSA9PT0gJ3ZhbHVlJyAmJiAnZGVmYXVsdFZhbHVlJyBpbiBwcm9wcyAmJiB2YWx1ZSA9PSBudWxsKSB7XG5cdFx0XHRcdC8vIFNraXAgYXBwbHlpbmcgdmFsdWUgaWYgaXQgaXMgbnVsbC91bmRlZmluZWQgYW5kIHdlIGFscmVhZHkgc2V0XG5cdFx0XHRcdC8vIGEgZGVmYXVsdCB2YWx1ZVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRcdGkgPT09ICdkZWZhdWx0VmFsdWUnICYmXG5cdFx0XHRcdCd2YWx1ZScgaW4gcHJvcHMgJiZcblx0XHRcdFx0cHJvcHMudmFsdWUgPT0gbnVsbFxuXHRcdFx0KSB7XG5cdFx0XHRcdC8vIGBkZWZhdWx0VmFsdWVgIGlzIHRyZWF0ZWQgYXMgYSBmYWxsYmFjayBgdmFsdWVgIHdoZW4gYSB2YWx1ZSBwcm9wIGlzIHByZXNlbnQgYnV0IG51bGwvdW5kZWZpbmVkLlxuXHRcdFx0XHQvLyBgZGVmYXVsdFZhbHVlYCBmb3IgRWxlbWVudHMgd2l0aCBubyB2YWx1ZSBwcm9wIGlzIHRoZSBzYW1lIGFzIHRoZSBET00gZGVmYXVsdFZhbHVlIHByb3BlcnR5LlxuXHRcdFx0XHRpID0gJ3ZhbHVlJztcblx0XHRcdH0gZWxzZSBpZiAoaSA9PT0gJ2Rvd25sb2FkJyAmJiB2YWx1ZSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHQvLyBDYWxsaW5nIGBzZXRBdHRyaWJ1dGVgIHdpdGggYSB0cnV0aHkgdmFsdWUgd2lsbCBsZWFkIHRvIGl0IGJlaW5nXG5cdFx0XHRcdC8vIHBhc3NlZCBhcyBhIHN0cmluZ2lmaWVkIHZhbHVlLCBlLmcuIGBkb3dubG9hZD1cInRydWVcImAuIFJlYWN0XG5cdFx0XHRcdC8vIGNvbnZlcnRzIGl0IHRvIGFuIGVtcHR5IHN0cmluZyBpbnN0ZWFkLCBvdGhlcndpc2UgdGhlIGF0dHJpYnV0ZVxuXHRcdFx0XHQvLyB2YWx1ZSB3aWxsIGJlIHVzZWQgYXMgdGhlIGZpbGUgbmFtZSBhbmQgdGhlIGZpbGUgd2lsbCBiZSBjYWxsZWRcblx0XHRcdFx0Ly8gXCJ0cnVlXCIgdXBvbiBkb3dubG9hZGluZyBpdC5cblx0XHRcdFx0dmFsdWUgPSAnJztcblx0XHRcdH0gZWxzZSBpZiAoL29uZG91YmxlY2xpY2svaS50ZXN0KGkpKSB7XG5cdFx0XHRcdGkgPSAnb25kYmxjbGljayc7XG5cdFx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0XHQvXm9uY2hhbmdlKHRleHRhcmVhfGlucHV0KS9pLnRlc3QoaSArIHR5cGUpICYmXG5cdFx0XHRcdCFvbkNoYW5nZUlucHV0VHlwZShwcm9wcy50eXBlKVxuXHRcdFx0KSB7XG5cdFx0XHRcdGkgPSAnb25pbnB1dCc7XG5cdFx0XHR9IGVsc2UgaWYgKC9eb25mb2N1cyQvaS50ZXN0KGkpKSB7XG5cdFx0XHRcdGkgPSAnb25mb2N1c2luJztcblx0XHRcdH0gZWxzZSBpZiAoL15vbmJsdXIkL2kudGVzdChpKSkge1xuXHRcdFx0XHRpID0gJ29uZm9jdXNvdXQnO1xuXHRcdFx0fSBlbHNlIGlmICgvXm9uKEFuaXxUcmF8VG91fEJlZm9yZUlucHxDb21wbykvLnRlc3QoaSkpIHtcblx0XHRcdFx0aSA9IGkudG9Mb3dlckNhc2UoKTtcblx0XHRcdH0gZWxzZSBpZiAobm9uQ3VzdG9tRWxlbWVudCAmJiBDQU1FTF9QUk9QUy50ZXN0KGkpKSB7XG5cdFx0XHRcdGkgPSBpLnJlcGxhY2UoL1tBLVowLTldL2csICctJCYnKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuXHRcdFx0XHR2YWx1ZSA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHN1cHBvcnQgZm9yIG9uSW5wdXQgYW5kIG9uQ2hhbmdlLCBzZWUgIzM1NjFcblx0XHRcdC8vIGlmIHdlIGhhdmUgYW4gb25pbnB1dCBwcm9wIGFscmVhZHkgY2hhbmdlIGl0IHRvIG9uaW5wdXRDYXB0dXJlXG5cdFx0XHRpZiAoL15vbmlucHV0JC9pLnRlc3QoaSkpIHtcblx0XHRcdFx0aSA9IGkudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0aWYgKG5vcm1hbGl6ZWRQcm9wc1tpXSkge1xuXHRcdFx0XHRcdGkgPSAnb25pbnB1dENhcHR1cmUnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdG5vcm1hbGl6ZWRQcm9wc1tpXSA9IHZhbHVlO1xuXHRcdH1cblxuXHRcdC8vIEFkZCBzdXBwb3J0IGZvciBhcnJheSBzZWxlY3QgdmFsdWVzOiA8c2VsZWN0IG11bHRpcGxlIHZhbHVlPXtbXX0gLz5cblx0XHRpZiAoXG5cdFx0XHR0eXBlID09ICdzZWxlY3QnICYmXG5cdFx0XHRub3JtYWxpemVkUHJvcHMubXVsdGlwbGUgJiZcblx0XHRcdEFycmF5LmlzQXJyYXkobm9ybWFsaXplZFByb3BzLnZhbHVlKVxuXHRcdCkge1xuXHRcdFx0Ly8gZm9yRWFjaCgpIGFsd2F5cyByZXR1cm5zIHVuZGVmaW5lZCwgd2hpY2ggd2UgYWJ1c2UgaGVyZSB0byB1bnNldCB0aGUgdmFsdWUgcHJvcC5cblx0XHRcdG5vcm1hbGl6ZWRQcm9wcy52YWx1ZSA9IHRvQ2hpbGRBcnJheShwcm9wcy5jaGlsZHJlbikuZm9yRWFjaChjaGlsZCA9PiB7XG5cdFx0XHRcdGNoaWxkLnByb3BzLnNlbGVjdGVkID1cblx0XHRcdFx0XHRub3JtYWxpemVkUHJvcHMudmFsdWUuaW5kZXhPZihjaGlsZC5wcm9wcy52YWx1ZSkgIT0gLTE7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvLyBBZGRpbmcgc3VwcG9ydCBmb3IgZGVmYXVsdFZhbHVlIGluIHNlbGVjdCB0YWdcblx0XHRpZiAodHlwZSA9PSAnc2VsZWN0JyAmJiBub3JtYWxpemVkUHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcblx0XHRcdG5vcm1hbGl6ZWRQcm9wcy52YWx1ZSA9IHRvQ2hpbGRBcnJheShwcm9wcy5jaGlsZHJlbikuZm9yRWFjaChjaGlsZCA9PiB7XG5cdFx0XHRcdGlmIChub3JtYWxpemVkUHJvcHMubXVsdGlwbGUpIHtcblx0XHRcdFx0XHRjaGlsZC5wcm9wcy5zZWxlY3RlZCA9XG5cdFx0XHRcdFx0XHRub3JtYWxpemVkUHJvcHMuZGVmYXVsdFZhbHVlLmluZGV4T2YoY2hpbGQucHJvcHMudmFsdWUpICE9IC0xO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNoaWxkLnByb3BzLnNlbGVjdGVkID1cblx0XHRcdFx0XHRcdG5vcm1hbGl6ZWRQcm9wcy5kZWZhdWx0VmFsdWUgPT0gY2hpbGQucHJvcHMudmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHZub2RlLnByb3BzID0gbm9ybWFsaXplZFByb3BzO1xuXG5cdFx0aWYgKHByb3BzLmNsYXNzICE9IHByb3BzLmNsYXNzTmFtZSkge1xuXHRcdFx0Y2xhc3NOYW1lRGVzY3JpcHRvci5lbnVtZXJhYmxlID0gJ2NsYXNzTmFtZScgaW4gcHJvcHM7XG5cdFx0XHRpZiAocHJvcHMuY2xhc3NOYW1lICE9IG51bGwpIG5vcm1hbGl6ZWRQcm9wcy5jbGFzcyA9IHByb3BzLmNsYXNzTmFtZTtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShub3JtYWxpemVkUHJvcHMsICdjbGFzc05hbWUnLCBjbGFzc05hbWVEZXNjcmlwdG9yKTtcblx0XHR9XG5cdH1cblxuXHR2bm9kZS4kJHR5cGVvZiA9IFJFQUNUX0VMRU1FTlRfVFlQRTtcblxuXHRpZiAob2xkVk5vZGVIb29rKSBvbGRWTm9kZUhvb2sodm5vZGUpO1xufTtcblxuLy8gT25seSBuZWVkZWQgZm9yIHJlYWN0LXJlbGF5XG5sZXQgY3VycmVudENvbXBvbmVudDtcbmNvbnN0IG9sZEJlZm9yZVJlbmRlciA9IG9wdGlvbnMuX3JlbmRlcjtcbm9wdGlvbnMuX3JlbmRlciA9IGZ1bmN0aW9uKHZub2RlKSB7XG5cdGlmIChvbGRCZWZvcmVSZW5kZXIpIHtcblx0XHRvbGRCZWZvcmVSZW5kZXIodm5vZGUpO1xuXHR9XG5cdGN1cnJlbnRDb21wb25lbnQgPSB2bm9kZS5fY29tcG9uZW50O1xufTtcblxuLy8gVGhpcyBpcyBhIHZlcnkgdmVyeSBwcml2YXRlIGludGVybmFsIGZ1bmN0aW9uIGZvciBSZWFjdCBpdFxuLy8gaXMgdXNlZCB0byBzb3J0LW9mIGRvIHJ1bnRpbWUgZGVwZW5kZW5jeSBpbmplY3Rpb24uIFNvIGZhclxuLy8gb25seSBgcmVhY3QtcmVsYXlgIG1ha2VzIHVzZSBvZiBpdC4gSXQgdXNlcyBpdCB0byByZWFkIHRoZVxuLy8gY29udGV4dCB2YWx1ZS5cbmV4cG9ydCBjb25zdCBfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCA9IHtcblx0UmVhY3RDdXJyZW50RGlzcGF0Y2hlcjoge1xuXHRcdGN1cnJlbnQ6IHtcblx0XHRcdHJlYWRDb250ZXh0KGNvbnRleHQpIHtcblx0XHRcdFx0cmV0dXJuIGN1cnJlbnRDb21wb25lbnQuX2dsb2JhbENvbnRleHRbY29udGV4dC5faWRdLnByb3BzLnZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcbiIsICJpbXBvcnQge1xuXHRjcmVhdGVFbGVtZW50LFxuXHRyZW5kZXIgYXMgcHJlYWN0UmVuZGVyLFxuXHRjbG9uZUVsZW1lbnQgYXMgcHJlYWN0Q2xvbmVFbGVtZW50LFxuXHRjcmVhdGVSZWYsXG5cdENvbXBvbmVudCxcblx0Y3JlYXRlQ29udGV4dCxcblx0RnJhZ21lbnRcbn0gZnJvbSAncHJlYWN0JztcbmltcG9ydCB7XG5cdHVzZVN0YXRlLFxuXHR1c2VJZCxcblx0dXNlUmVkdWNlcixcblx0dXNlRWZmZWN0LFxuXHR1c2VMYXlvdXRFZmZlY3QsXG5cdHVzZVJlZixcblx0dXNlSW1wZXJhdGl2ZUhhbmRsZSxcblx0dXNlTWVtbyxcblx0dXNlQ2FsbGJhY2ssXG5cdHVzZUNvbnRleHQsXG5cdHVzZURlYnVnVmFsdWVcbn0gZnJvbSAncHJlYWN0L2hvb2tzJztcbmltcG9ydCB7IFB1cmVDb21wb25lbnQgfSBmcm9tICcuL1B1cmVDb21wb25lbnQnO1xuaW1wb3J0IHsgbWVtbyB9IGZyb20gJy4vbWVtbyc7XG5pbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAnLi9mb3J3YXJkUmVmJztcbmltcG9ydCB7IENoaWxkcmVuIH0gZnJvbSAnLi9DaGlsZHJlbic7XG5pbXBvcnQgeyBTdXNwZW5zZSwgbGF6eSB9IGZyb20gJy4vc3VzcGVuc2UnO1xuaW1wb3J0IHsgU3VzcGVuc2VMaXN0IH0gZnJvbSAnLi9zdXNwZW5zZS1saXN0JztcbmltcG9ydCB7IGNyZWF0ZVBvcnRhbCB9IGZyb20gJy4vcG9ydGFscyc7XG5pbXBvcnQgeyBpcyB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQge1xuXHRoeWRyYXRlLFxuXHRyZW5kZXIsXG5cdFJFQUNUX0VMRU1FTlRfVFlQRSxcblx0X19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRURcbn0gZnJvbSAnLi9yZW5kZXInO1xuXG5jb25zdCB2ZXJzaW9uID0gJzE3LjAuMic7IC8vIHRyaWNrIGxpYnJhcmllcyB0byB0aGluayB3ZSBhcmUgcmVhY3RcblxuLyoqXG4gKiBMZWdhY3kgdmVyc2lvbiBvZiBjcmVhdGVFbGVtZW50LlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZVtcInR5cGVcIl19IHR5cGUgVGhlIG5vZGUgbmFtZSBvciBDb21wb25lbnQgY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRmFjdG9yeSh0eXBlKSB7XG5cdHJldHVybiBjcmVhdGVFbGVtZW50LmJpbmQobnVsbCwgdHlwZSk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHBhc3NlZCBlbGVtZW50IGlzIGEgdmFsaWQgKHApcmVhY3Qgbm9kZS5cbiAqIEBwYXJhbSB7Kn0gZWxlbWVudCBUaGUgZWxlbWVudCB0byBjaGVja1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KGVsZW1lbnQpIHtcblx0cmV0dXJuICEhZWxlbWVudCAmJiBlbGVtZW50LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5cbi8qKlxuICogV3JhcCBgY2xvbmVFbGVtZW50YCB0byBhYm9ydCBpZiB0aGUgcGFzc2VkIGVsZW1lbnQgaXMgbm90IGEgdmFsaWQgZWxlbWVudCBhbmQgYXBwbHlcbiAqIGFsbCB2bm9kZSBub3JtYWxpemF0aW9ucy5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9IGVsZW1lbnQgVGhlIHZub2RlIHRvIGNsb25lXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgUHJvcHMgdG8gYWRkIHdoZW4gY2xvbmluZ1xuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnRDaGlsZHJlbj59IHJlc3QgT3B0aW9uYWwgY29tcG9uZW50IGNoaWxkcmVuXG4gKi9cbmZ1bmN0aW9uIGNsb25lRWxlbWVudChlbGVtZW50KSB7XG5cdGlmICghaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkpIHJldHVybiBlbGVtZW50O1xuXHRyZXR1cm4gcHJlYWN0Q2xvbmVFbGVtZW50LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICogUmVtb3ZlIGEgY29tcG9uZW50IHRyZWUgZnJvbSB0aGUgRE9NLCBpbmNsdWRpbmcgc3RhdGUgYW5kIGV2ZW50IGhhbmRsZXJzLlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBjb250YWluZXJcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiB1bm1vdW50Q29tcG9uZW50QXROb2RlKGNvbnRhaW5lcikge1xuXHRpZiAoY29udGFpbmVyLl9jaGlsZHJlbikge1xuXHRcdHByZWFjdFJlbmRlcihudWxsLCBjb250YWluZXIpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG1hdGNoaW5nIERPTSBub2RlIGZvciBhIGNvbXBvbmVudFxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9IGNvbXBvbmVudFxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnQgfCBudWxsfVxuICovXG5mdW5jdGlvbiBmaW5kRE9NTm9kZShjb21wb25lbnQpIHtcblx0cmV0dXJuIChcblx0XHQoY29tcG9uZW50ICYmXG5cdFx0XHQoY29tcG9uZW50LmJhc2UgfHwgKGNvbXBvbmVudC5ub2RlVHlwZSA9PT0gMSAmJiBjb21wb25lbnQpKSkgfHxcblx0XHRudWxsXG5cdCk7XG59XG5cbi8qKlxuICogRGVwcmVjYXRlZCB3YXkgdG8gY29udHJvbCBiYXRjaGVkIHJlbmRlcmluZyBpbnNpZGUgdGhlIHJlY29uY2lsZXIsIGJ1dCB3ZVxuICogYWxyZWFkeSBzY2hlZHVsZSBpbiBiYXRjaGVzIGluc2lkZSBvdXIgcmVuZGVyaW5nIGNvZGVcbiAqIEB0ZW1wbGF0ZSBBcmdcbiAqIEBwYXJhbSB7KGFyZzogQXJnKSA9PiB2b2lkfSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHRyaWdnZXJzIHRoZSB1cGRhdGVkXG4gKiBAcGFyYW0ge0FyZ30gW2FyZ10gT3B0aW9uYWwgYXJndW1lbnQgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIHRoZSBjYWxsYmFja1xuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FtZWxjYXNlXG5jb25zdCB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyA9IChjYWxsYmFjaywgYXJnKSA9PiBjYWxsYmFjayhhcmcpO1xuXG4vKipcbiAqIEluIFJlYWN0LCBgZmx1c2hTeW5jYCBmbHVzaGVzIHRoZSBlbnRpcmUgdHJlZSBhbmQgZm9yY2VzIGEgcmVyZW5kZXIuIEl0J3NcbiAqIGltcGxtZW50ZWQgaGVyZSBhcyBhIG5vLW9wLlxuICogQHRlbXBsYXRlIEFyZ1xuICogQHRlbXBsYXRlIFJlc3VsdFxuICogQHBhcmFtIHsoYXJnOiBBcmcpID0+IFJlc3VsdH0gY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBydW5zIGJlZm9yZSB0aGUgZmx1c2hcbiAqIEBwYXJhbSB7QXJnfSBbYXJnXSBPcHRpb25hbCBhcmd1bWVudCB0aGF0IGNhbiBiZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrXG4gKiBAcmV0dXJuc1xuICovXG5jb25zdCBmbHVzaFN5bmMgPSAoY2FsbGJhY2ssIGFyZykgPT4gY2FsbGJhY2soYXJnKTtcblxuLyoqXG4gKiBTdHJpY3QgTW9kZSBpcyBub3QgaW1wbGVtZW50ZWQgaW4gUHJlYWN0LCBzbyB3ZSBwcm92aWRlIGEgc3RhbmQtaW4gZm9yIGl0XG4gKiB0aGF0IGp1c3QgcmVuZGVycyBpdHMgY2hpbGRyZW4gd2l0aG91dCBpbXBvc2luZyBhbnkgcmVzdHJpY3Rpb25zLlxuICovXG5jb25zdCBTdHJpY3RNb2RlID0gRnJhZ21lbnQ7XG5cbmV4cG9ydCBmdW5jdGlvbiBzdGFydFRyYW5zaXRpb24oY2IpIHtcblx0Y2IoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZURlZmVycmVkVmFsdWUodmFsKSB7XG5cdHJldHVybiB2YWw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VUcmFuc2l0aW9uKCkge1xuXHRyZXR1cm4gW2ZhbHNlLCBzdGFydFRyYW5zaXRpb25dO1xufVxuXG4vLyBUT0RPOiBpbiB0aGVvcnkgdGhpcyBzaG91bGQgYmUgZG9uZSBhZnRlciBhIFZOb2RlIGlzIGRpZmZlZCBhcyB3ZSB3YW50IHRvIGluc2VydFxuLy8gc3R5bGVzLy4uLiBiZWZvcmUgaXQgYXR0YWNoZXNcbmV4cG9ydCBjb25zdCB1c2VJbnNlcnRpb25FZmZlY3QgPSB1c2VMYXlvdXRFZmZlY3Q7XG5cbi8qKlxuICogVGhpcyBpcyB0YWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL21haW4vcGFja2FnZXMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvc3JjL3VzZVN5bmNFeHRlcm5hbFN0b3JlU2hpbUNsaWVudC5qcyNMODRcbiAqIG9uIGEgaGlnaCBsZXZlbCB0aGlzIGN1dHMgb3V0IHRoZSB3YXJuaW5ncywgLi4uIGFuZCBhdHRlbXB0cyBhIHNtYWxsZXIgaW1wbGVtZW50YXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QpIHtcblx0Y29uc3QgdmFsdWUgPSBnZXRTbmFwc2hvdCgpO1xuXG5cdGNvbnN0IFt7IF9pbnN0YW5jZSB9LCBmb3JjZVVwZGF0ZV0gPSB1c2VTdGF0ZSh7XG5cdFx0X2luc3RhbmNlOiB7IF92YWx1ZTogdmFsdWUsIF9nZXRTbmFwc2hvdDogZ2V0U25hcHNob3QgfVxuXHR9KTtcblxuXHR1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuXHRcdF9pbnN0YW5jZS5fdmFsdWUgPSB2YWx1ZTtcblx0XHRfaW5zdGFuY2UuX2dldFNuYXBzaG90ID0gZ2V0U25hcHNob3Q7XG5cblx0XHRpZiAoIWlzKF9pbnN0YW5jZS5fdmFsdWUsIGdldFNuYXBzaG90KCkpKSB7XG5cdFx0XHRmb3JjZVVwZGF0ZSh7IF9pbnN0YW5jZSB9KTtcblx0XHR9XG5cdH0sIFtzdWJzY3JpYmUsIHZhbHVlLCBnZXRTbmFwc2hvdF0pO1xuXG5cdHVzZUVmZmVjdCgoKSA9PiB7XG5cdFx0aWYgKCFpcyhfaW5zdGFuY2UuX3ZhbHVlLCBfaW5zdGFuY2UuX2dldFNuYXBzaG90KCkpKSB7XG5cdFx0XHRmb3JjZVVwZGF0ZSh7IF9pbnN0YW5jZSB9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gc3Vic2NyaWJlKCgpID0+IHtcblx0XHRcdGlmICghaXMoX2luc3RhbmNlLl92YWx1ZSwgX2luc3RhbmNlLl9nZXRTbmFwc2hvdCgpKSkge1xuXHRcdFx0XHRmb3JjZVVwZGF0ZSh7IF9pbnN0YW5jZSB9KTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSwgW3N1YnNjcmliZV0pO1xuXG5cdHJldHVybiB2YWx1ZTtcbn1cblxuZXhwb3J0ICogZnJvbSAncHJlYWN0L2hvb2tzJztcbmV4cG9ydCB7XG5cdHZlcnNpb24sXG5cdENoaWxkcmVuLFxuXHRyZW5kZXIsXG5cdGh5ZHJhdGUsXG5cdHVubW91bnRDb21wb25lbnRBdE5vZGUsXG5cdGNyZWF0ZVBvcnRhbCxcblx0Y3JlYXRlRWxlbWVudCxcblx0Y3JlYXRlQ29udGV4dCxcblx0Y3JlYXRlRmFjdG9yeSxcblx0Y2xvbmVFbGVtZW50LFxuXHRjcmVhdGVSZWYsXG5cdEZyYWdtZW50LFxuXHRpc1ZhbGlkRWxlbWVudCxcblx0ZmluZERPTU5vZGUsXG5cdENvbXBvbmVudCxcblx0UHVyZUNvbXBvbmVudCxcblx0bWVtbyxcblx0Zm9yd2FyZFJlZixcblx0Zmx1c2hTeW5jLFxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FtZWxjYXNlXG5cdHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzLFxuXHRTdHJpY3RNb2RlLFxuXHRTdXNwZW5zZSxcblx0U3VzcGVuc2VMaXN0LFxuXHRsYXp5LFxuXHRfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRFxufTtcblxuLy8gUmVhY3QgY29waWVzIHRoZSBuYW1lZCBleHBvcnRzIHRvIHRoZSBkZWZhdWx0IG9uZS5cbmV4cG9ydCBkZWZhdWx0IHtcblx0dXNlU3RhdGUsXG5cdHVzZUlkLFxuXHR1c2VSZWR1Y2VyLFxuXHR1c2VFZmZlY3QsXG5cdHVzZUxheW91dEVmZmVjdCxcblx0dXNlSW5zZXJ0aW9uRWZmZWN0LFxuXHR1c2VUcmFuc2l0aW9uLFxuXHR1c2VEZWZlcnJlZFZhbHVlLFxuXHR1c2VTeW5jRXh0ZXJuYWxTdG9yZSxcblx0c3RhcnRUcmFuc2l0aW9uLFxuXHR1c2VSZWYsXG5cdHVzZUltcGVyYXRpdmVIYW5kbGUsXG5cdHVzZU1lbW8sXG5cdHVzZUNhbGxiYWNrLFxuXHR1c2VDb250ZXh0LFxuXHR1c2VEZWJ1Z1ZhbHVlLFxuXHR2ZXJzaW9uLFxuXHRDaGlsZHJlbixcblx0cmVuZGVyLFxuXHRoeWRyYXRlLFxuXHR1bm1vdW50Q29tcG9uZW50QXROb2RlLFxuXHRjcmVhdGVQb3J0YWwsXG5cdGNyZWF0ZUVsZW1lbnQsXG5cdGNyZWF0ZUNvbnRleHQsXG5cdGNyZWF0ZUZhY3RvcnksXG5cdGNsb25lRWxlbWVudCxcblx0Y3JlYXRlUmVmLFxuXHRGcmFnbWVudCxcblx0aXNWYWxpZEVsZW1lbnQsXG5cdGZpbmRET01Ob2RlLFxuXHRDb21wb25lbnQsXG5cdFB1cmVDb21wb25lbnQsXG5cdG1lbW8sXG5cdGZvcndhcmRSZWYsXG5cdGZsdXNoU3luYyxcblx0dW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMsXG5cdFN0cmljdE1vZGUsXG5cdFN1c3BlbnNlLFxuXHRTdXNwZW5zZUxpc3QsXG5cdGxhenksXG5cdF9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEXG59O1xuIiwgImltcG9ydCAqIGFzIHByZWFjdCBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBjcmVhdGVFbGVtZW50LCBpc1ZhbGlkRWxlbWVudCwgRnJhZ21lbnQgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgY3JlYXRlUG9ydGFsIH0gZnJvbSAncHJlYWN0L2NvbXBhdCc7XG5cbmNvbnN0IHN0eWxlVGV4dHMgPSBbXTtcbmNvbnN0IHN0eWxlRWxzID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gaW5qZWN0U3R5bGVzKHN0eWxlVGV4dCkge1xuICAgIHN0eWxlVGV4dHMucHVzaChzdHlsZVRleHQpO1xuICAgIHN0eWxlRWxzLmZvckVhY2goKHN0eWxlRWwpID0+IHtcbiAgICAgICAgYXBwZW5kU3R5bGVzVG8oc3R5bGVFbCwgc3R5bGVUZXh0KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUVsSGFzU3R5bGVzKGVsKSB7XG4gICAgaWYgKGVsLmlzQ29ubmVjdGVkICYmIC8vIHNvbWV0aW1lcyB0cnVlIGlmIFNTUiBzeXN0ZW0gc2ltdWxhdGVzIERPTVxuICAgICAgICBlbC5nZXRSb290Tm9kZSAvLyBzb21ldGltZXMgdW5kZWZpbmVkIGlmIFNTUiBzeXN0ZW0gc2ltdWxhdGVzIERPTVxuICAgICkge1xuICAgICAgICByZWdpc3RlclN0eWxlc1Jvb3QoZWwuZ2V0Um9vdE5vZGUoKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVnaXN0ZXJTdHlsZXNSb290KHJvb3ROb2RlKSB7XG4gICAgbGV0IHN0eWxlRWwgPSBzdHlsZUVscy5nZXQocm9vdE5vZGUpO1xuICAgIGlmICghc3R5bGVFbCB8fCAhc3R5bGVFbC5pc0Nvbm5lY3RlZCkge1xuICAgICAgICBzdHlsZUVsID0gcm9vdE5vZGUucXVlcnlTZWxlY3Rvcignc3R5bGVbZGF0YS1mdWxsY2FsZW5kYXJdJyk7XG4gICAgICAgIGlmICghc3R5bGVFbCkge1xuICAgICAgICAgICAgc3R5bGVFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgICAgICBzdHlsZUVsLnNldEF0dHJpYnV0ZSgnZGF0YS1mdWxsY2FsZW5kYXInLCAnJyk7XG4gICAgICAgICAgICBjb25zdCBub25jZSA9IGdldE5vbmNlVmFsdWUoKTtcbiAgICAgICAgICAgIGlmIChub25jZSkge1xuICAgICAgICAgICAgICAgIHN0eWxlRWwubm9uY2UgPSBub25jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhcmVudEVsID0gcm9vdE5vZGUgPT09IGRvY3VtZW50ID8gZG9jdW1lbnQuaGVhZCA6IHJvb3ROb2RlO1xuICAgICAgICAgICAgY29uc3QgaW5zZXJ0QmVmb3JlID0gcm9vdE5vZGUgPT09IGRvY3VtZW50XG4gICAgICAgICAgICAgICAgPyBwYXJlbnRFbC5xdWVyeVNlbGVjdG9yKCdzY3JpcHQsbGlua1tyZWw9c3R5bGVzaGVldF0sbGlua1thcz1zdHlsZV0sc3R5bGUnKVxuICAgICAgICAgICAgICAgIDogcGFyZW50RWwuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHBhcmVudEVsLmluc2VydEJlZm9yZShzdHlsZUVsLCBpbnNlcnRCZWZvcmUpO1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlRWxzLnNldChyb290Tm9kZSwgc3R5bGVFbCk7XG4gICAgICAgIGh5ZHJhdGVTdHlsZXNSb290KHN0eWxlRWwpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGh5ZHJhdGVTdHlsZXNSb290KHN0eWxlRWwpIHtcbiAgICBmb3IgKGNvbnN0IHN0eWxlVGV4dCBvZiBzdHlsZVRleHRzKSB7XG4gICAgICAgIGFwcGVuZFN0eWxlc1RvKHN0eWxlRWwsIHN0eWxlVGV4dCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwZW5kU3R5bGVzVG8oc3R5bGVFbCwgc3R5bGVUZXh0KSB7XG4gICAgY29uc3QgeyBzaGVldCB9ID0gc3R5bGVFbDtcbiAgICBjb25zdCBydWxlQ250ID0gc2hlZXQuY3NzUnVsZXMubGVuZ3RoO1xuICAgIHN0eWxlVGV4dC5zcGxpdCgnfScpLmZvckVhY2goKHN0eWxlU3RyLCBpKSA9PiB7XG4gICAgICAgIHN0eWxlU3RyID0gc3R5bGVTdHIudHJpbSgpO1xuICAgICAgICBpZiAoc3R5bGVTdHIpIHtcbiAgICAgICAgICAgIHNoZWV0Lmluc2VydFJ1bGUoc3R5bGVTdHIgKyAnfScsIHJ1bGVDbnQgKyBpKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLy8gbm9uY2Vcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmxldCBxdWVyaWVkTm9uY2VWYWx1ZTtcbmZ1bmN0aW9uIGdldE5vbmNlVmFsdWUoKSB7XG4gICAgaWYgKHF1ZXJpZWROb25jZVZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcXVlcmllZE5vbmNlVmFsdWUgPSBxdWVyeU5vbmNlVmFsdWUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHF1ZXJpZWROb25jZVZhbHVlO1xufVxuLypcblRPRE86IGRpc2NvdXJhZ2UgbWV0YSB0YWcgYW5kIGluc3RlYWQgcHV0IG5vbmNlIGF0dHJpYnV0ZSBvbiBwbGFjZWhvbGRlciA8c3R5bGU+IHRhZ1xuKi9cbmZ1bmN0aW9uIHF1ZXJ5Tm9uY2VWYWx1ZSgpIHtcbiAgICBjb25zdCBtZXRhV2l0aE5vbmNlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPVwiY3NwLW5vbmNlXCJdJyk7XG4gICAgaWYgKG1ldGFXaXRoTm9uY2UgJiYgbWV0YVdpdGhOb25jZS5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnQnKSkge1xuICAgICAgICByZXR1cm4gbWV0YVdpdGhOb25jZS5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnKTtcbiAgICB9XG4gICAgY29uc3QgZWxXaXRoTm9uY2UgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzY3JpcHRbbm9uY2VdJyk7XG4gICAgaWYgKGVsV2l0aE5vbmNlKSB7XG4gICAgICAgIHJldHVybiBlbFdpdGhOb25jZS5ub25jZSB8fCAnJztcbiAgICB9XG4gICAgcmV0dXJuICcnO1xufVxuLy8gbWFpblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZWdpc3RlclN0eWxlc1Jvb3QoZG9jdW1lbnQpO1xufVxuXG52YXIgY3NzXzI0OHogPSBcIjpyb290ey0tZmMtc21hbGwtZm9udC1zaXplOi44NWVtOy0tZmMtcGFnZS1iZy1jb2xvcjojZmZmOy0tZmMtbmV1dHJhbC1iZy1jb2xvcjpoc2xhKDAsMCUsODIlLC4zKTstLWZjLW5ldXRyYWwtdGV4dC1jb2xvcjpncmV5Oy0tZmMtYm9yZGVyLWNvbG9yOiNkZGQ7LS1mYy1idXR0b24tdGV4dC1jb2xvcjojZmZmOy0tZmMtYnV0dG9uLWJnLWNvbG9yOiMyYzNlNTA7LS1mYy1idXR0b24tYm9yZGVyLWNvbG9yOiMyYzNlNTA7LS1mYy1idXR0b24taG92ZXItYmctY29sb3I6IzFlMmIzNzstLWZjLWJ1dHRvbi1ob3Zlci1ib3JkZXItY29sb3I6IzFhMjUyZjstLWZjLWJ1dHRvbi1hY3RpdmUtYmctY29sb3I6IzFhMjUyZjstLWZjLWJ1dHRvbi1hY3RpdmUtYm9yZGVyLWNvbG9yOiMxNTFlMjc7LS1mYy1ldmVudC1iZy1jb2xvcjojMzc4OGQ4Oy0tZmMtZXZlbnQtYm9yZGVyLWNvbG9yOiMzNzg4ZDg7LS1mYy1ldmVudC10ZXh0LWNvbG9yOiNmZmY7LS1mYy1ldmVudC1zZWxlY3RlZC1vdmVybGF5LWNvbG9yOnJnYmEoMCwwLDAsLjI1KTstLWZjLW1vcmUtbGluay1iZy1jb2xvcjojZDBkMGQwOy0tZmMtbW9yZS1saW5rLXRleHQtY29sb3I6aW5oZXJpdDstLWZjLWV2ZW50LXJlc2l6ZXItdGhpY2tuZXNzOjhweDstLWZjLWV2ZW50LXJlc2l6ZXItZG90LXRvdGFsLXdpZHRoOjhweDstLWZjLWV2ZW50LXJlc2l6ZXItZG90LWJvcmRlci13aWR0aDoxcHg7LS1mYy1ub24tYnVzaW5lc3MtY29sb3I6aHNsYSgwLDAlLDg0JSwuMyk7LS1mYy1iZy1ldmVudC1jb2xvcjojOGZkZjgyOy0tZmMtYmctZXZlbnQtb3BhY2l0eTowLjM7LS1mYy1oaWdobGlnaHQtY29sb3I6cmdiYSgxODgsMjMyLDI0MSwuMyk7LS1mYy10b2RheS1iZy1jb2xvcjpyZ2JhKDI1NSwyMjAsNDAsLjE1KTstLWZjLW5vdy1pbmRpY2F0b3ItY29sb3I6cmVkfS5mYy1ub3QtYWxsb3dlZCwuZmMtbm90LWFsbG93ZWQgLmZjLWV2ZW50e2N1cnNvcjpub3QtYWxsb3dlZH0uZmN7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjtmb250LXNpemU6MWVtfS5mYywuZmMgKiwuZmMgOmFmdGVyLC5mYyA6YmVmb3Jle2JveC1zaXppbmc6Ym9yZGVyLWJveH0uZmMgdGFibGV7Ym9yZGVyLWNvbGxhcHNlOmNvbGxhcHNlO2JvcmRlci1zcGFjaW5nOjA7Zm9udC1zaXplOjFlbX0uZmMgdGh7dGV4dC1hbGlnbjpjZW50ZXJ9LmZjIHRkLC5mYyB0aHtwYWRkaW5nOjA7dmVydGljYWwtYWxpZ246dG9wfS5mYyBhW2RhdGEtbmF2bGlua117Y3Vyc29yOnBvaW50ZXJ9LmZjIGFbZGF0YS1uYXZsaW5rXTpob3Zlcnt0ZXh0LWRlY29yYXRpb246dW5kZXJsaW5lfS5mYy1kaXJlY3Rpb24tbHRye2RpcmVjdGlvbjpsdHI7dGV4dC1hbGlnbjpsZWZ0fS5mYy1kaXJlY3Rpb24tcnRse2RpcmVjdGlvbjpydGw7dGV4dC1hbGlnbjpyaWdodH0uZmMtdGhlbWUtc3RhbmRhcmQgdGQsLmZjLXRoZW1lLXN0YW5kYXJkIHRoe2JvcmRlcjoxcHggc29saWQgdmFyKC0tZmMtYm9yZGVyLWNvbG9yKX0uZmMtbGlxdWlkLWhhY2sgdGQsLmZjLWxpcXVpZC1oYWNrIHRoe3Bvc2l0aW9uOnJlbGF0aXZlfUBmb250LWZhY2V7Zm9udC1mYW1pbHk6ZmNpY29ucztmb250LXN0eWxlOm5vcm1hbDtmb250LXdlaWdodDo0MDA7c3JjOnVybChcXFwiZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtdHRmO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LEFBRUFBQUFMQUlBQUF3QXdUMU12TWc4U0JmQUFBQUM4QUFBQVlHTnRZWEFYVnRLTkFBQUJIQUFBQUZSbllYTndBQUFBRUFBQUFYQUFBQUFJWjJ4NVpnWXlkeElBQUFGNEFBQUZOR2hsWVdRVUo3Y0lBQUFHckFBQUFEWm9hR1ZoQjIwRHpBQUFCdVFBQUFBa2FHMTBlQ0lBQmhRQUFBY0lBQUFBTEd4dlkyRUQ0QVU2QUFBSE5BQUFBQmh0WVhod0FBOEFqQUFBQjB3QUFBQWdibUZ0WlhzcjY5MEFBQWRzQUFBQmhuQnZjM1FBQXdBQUFBQUk5QUFBQUNBQUF3UEFBWkFBQlFBQUFwa0N6QUFBQUk4Q21RTE1BQUFCNndBekFRa0FBQUFBQUFBQUFBQUFBQUFBQUFBQkVBQUFBQUFBQUFBQUFBQUFBQUFBQUFCQUFBRHBCZ1BBLzhBQVFBUEFBRUFBQUFBQkFBQUFBQUFBQUFBQUFBQWdBQUFBQUFBREFBQUFBd0FBQUJ3QUFRQURBQUFBSEFBREFBRUFBQUFjQUFRQU9BQUFBQW9BQ0FBQ0FBSUFBUUFnNlFiLy9mLy9BQUFBQUFBZzZRRC8vZi8vQUFILzR4Y0VBQU1BQVFBQUFBQUFBQUFBQUFBQUFRQUIvLzhBRHdBQkFBQUFBQUFBQUFBQUFnQUFOemtCQUFBQUFBRUFBQUFBQUFBQUFBQUNBQUEzT1FFQUFBQUFBUUFBQUFBQUFBQUFBQUlBQURjNUFRQUFBQUFCQVdJQWpRS2VBc2tBRXdBQUpTYzNOalFuSmlJSEFRWVVGd0VXTWpjMk5DY0NudUxpRFEwTUpBei9BQTBOQVFBTUpBd05EY25pNGd3akRRd00vd0FOSXd6L0FBME5EQ01OQUFBQUFRRmlBSTBDbmdMSkFCTUFBQ1VCTmpRbkFTWWlCd1lVSHdFSEJoUVhGakkzQVo0QkFBME4vd0FNSkF3TkRlTGlEUTBNSkF5TkFRQU1JdzBCQUF3TURTTU00dUlOSXd3TkRRQUFBQUlBNGdDM0F4NENuZ0FUQUNjQUFDVW5OelkwSnlZaUR3RUdGQjhCRmpJM05qUW5JU2MzTmpRbkppSVBBUVlVSHdFV01qYzJOQ2NCODdlM0RRME1JdzNWRFEzVkRTTU1EUTBCSzdlM0RRME1KQXpWRFEzVkRDUU1EUTN6dUxjTUpBd05EZFVOSXd6V0RBd05Jd3k0dHd3a0RBME4xUTBqRE5ZTURBMGpEQUFBQWdEaUFMY0RIZ0tlQUJNQUp3QUFKVGMyTkM4QkppSUhCaFFmQVFjR0ZCY1dNamNoTnpZMEx3RW1JZ2NHRkI4QkJ3WVVGeFl5TndKSjFRME4xUTBqREEwTnQ3Y05EUXdqRGY3VjFRME4xUXdrREEwTnQ3Y05EUXdrRExmV0RDTU4xUTBORENRTXQ3Z01JdzBNRE5ZTUl3M1ZEUTBNSkF5M3VBd2pEUXdNQUFBREFGVUFBQU9yQTFVQU13Qm9BSGNBQUJNaUJnY09BUWNPQVFjT0FSVVJGQllYSGdFWEhnRVhIZ0V6SVRJMk56NEJOejRCTno0Qk5SRTBKaWN1QVNjdUFTY3VBU01GSVRJV0Z4NEJGeDRCRng0QkZSRVVCZ2NPQVFjT0FRY09BU01oSWlZbkxnRW5MZ0VuTGdFMUVUUTJOejRCTno0Qk56NEJNeE1oTWpZMU5DWWpJU0lHRlJRV005VU5HQXdMRlFrSkRnVUZCUVVGQlE0SkNSVUxEQmdOQWxZTkdBd0xGUWtKRGdVRkJRVUZCUTRKQ1JVTERCZ04vYW9DVmdRSUJBUUhBd01GQVFJQkFRSUJCUU1EQndRRUNBVDlxZ1FJQkFRSEF3TUZBUUlCQVFJQkJRTURCd1FFQ0FTQUFWWVJHUmtSL3FvUkdSa1JBMVVGQkFVT0NRa1ZEQXNaRGYyckRSa0xEQlVKQ0E0RkJRVUZCUVVPQ1FnVkRBc1pEUUpWRFJrTERCVUpDUTRGQkFWVkFnRUNCUU1DQndRRUNBWDlxd1FKQXdRSEF3TUZBUUlDQWdJQkJRTURCd1FEQ1FRQ1ZRVUlCQVFIQWdNRkFnRUMvb0FaRWhFWkdSRVNHUUFBQUFBREFGVUFBQU9yQTFVQU13Qm9BSWtBQUJNaUJnY09BUWNPQVFjT0FSVVJGQllYSGdFWEhnRVhIZ0V6SVRJMk56NEJOejRCTno0Qk5SRTBKaWN1QVNjdUFTY3VBU01GSVRJV0Z4NEJGeDRCRng0QkZSRVVCZ2NPQVFjT0FRY09BU01oSWlZbkxnRW5MZ0VuTGdFMUVUUTJOejRCTno0Qk56NEJNeE16RlJRV016STJQUUV6TWpZMU5DWXJBVFUwSmlNaUJoMEJJeUlHRlJRV005VU5HQXdMRlFrSkRnVUZCUVVGQlE0SkNSVUxEQmdOQWxZTkdBd0xGUWtKRGdVRkJRVUZCUTRKQ1JVTERCZ04vYW9DVmdRSUJBUUhBd01GQVFJQkFRSUJCUU1EQndRRUNBVDlxZ1FJQkFRSEF3TUZBUUlCQVFJQkJRTURCd1FFQ0FTQWdCa1NFaG1BRVJrWkVZQVpFaElaZ0JFWkdSRURWUVVFQlE0SkNSVU1DeGtOL2FzTkdRc01GUWtJRGdVRkJRVUZCUTRKQ0JVTUN4a05BbFVOR1FzTUZRa0pEZ1VFQlZVQ0FRSUZBd0lIQkFRSUJmMnJCQWtEQkFjREF3VUJBZ0lDQWdFRkF3TUhCQU1KQkFKVkJRZ0VCQWNDQXdVQ0FRTCtnSUFTR1JrU2dCa1NFUm1BRWhrWkVvQVpFUklaQUFBQkFPSUFqUU1lQXNrQUlBQUFFeGNIQmhRWEZqSS9BUmNXTWpjMk5DOEJOelkwSnlZaUR3RW5KaUlIQmhRWDR1TGlEUTBNSkF6aTRnd2tEQTBONHVJTkRRd2tET0xpRENRTURRMENqZUxpRFNNTURRM2g0UTBORENNTjR1SU1JdzBNRE9MaURBd05Jd3dBQUFBQkFBQUFBUUFBYTVuMHkxOFBQUFVBQ3dRQUFBQUFBTml2T1ZzQUFBQUEySzg1V3dBQUFBQURxd05WQUFBQUNBQUNBQUFBQUFBQUFBRUFBQVBBLzhBQUFBUUFBQUFBQUFPckFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBTEJBQUFBQUFBQUFBQUFBQUFBZ0FBQUFRQUFXSUVBQUZpQkFBQTRnUUFBT0lFQUFCVkJBQUFWUVFBQU9JQUFBQUFBQW9BRkFBZUFFUUFhZ0NxQU9vQm5nSmtBcG9BQVFBQUFBc0FpZ0FEQUFBQUFBQUNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQTRBcmdBQkFBQUFBQUFCQUFjQUFBQUJBQUFBQUFBQ0FBY0FZQUFCQUFBQUFBQURBQWNBTmdBQkFBQUFBQUFFQUFjQWRRQUJBQUFBQUFBRkFBc0FGUUFCQUFBQUFBQUdBQWNBU3dBQkFBQUFBQUFLQUJvQWlnQURBQUVFQ1FBQkFBNEFCd0FEQUFFRUNRQUNBQTRBWndBREFBRUVDUUFEQUE0QVBRQURBQUVFQ1FBRUFBNEFmQUFEQUFFRUNRQUZBQllBSUFBREFBRUVDUUFHQUE0QVVnQURBQUVFQ1FBS0FEUUFwR1pqYVdOdmJuTUFaZ0JqQUdrQVl3QnZBRzRBYzFabGNuTnBiMjRnTVM0d0FGWUFaUUJ5QUhNQWFRQnZBRzRBSUFBeEFDNEFNR1pqYVdOdmJuTUFaZ0JqQUdrQVl3QnZBRzRBYzJaamFXTnZibk1BWmdCakFHa0FZd0J2QUc0QWMxSmxaM1ZzWVhJQVVnQmxBR2NBZFFCc0FHRUFjbVpqYVdOdmJuTUFaZ0JqQUdrQVl3QnZBRzRBYzBadmJuUWdaMlZ1WlhKaGRHVmtJR0o1SUVsamIwMXZiMjR1QUVZQWJ3QnVBSFFBSUFCbkFHVUFiZ0JsQUhJQVlRQjBBR1VBWkFBZ0FHSUFlUUFnQUVrQVl3QnZBRTBBYndCdkFHNEFMZ0FBQUFNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQT1cXFwiKSBmb3JtYXQoXFxcInRydWV0eXBlXFxcIil9LmZjLWljb257c3BlYWs6bm9uZTstd2Via2l0LWZvbnQtc21vb3RoaW5nOmFudGlhbGlhc2VkOy1tb3otb3N4LWZvbnQtc21vb3RoaW5nOmdyYXlzY2FsZTtkaXNwbGF5OmlubGluZS1ibG9jaztmb250LWZhbWlseTpmY2ljb25zIWltcG9ydGFudDtmb250LXN0eWxlOm5vcm1hbDtmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0OjQwMDtoZWlnaHQ6MWVtO2xpbmUtaGVpZ2h0OjE7dGV4dC1hbGlnbjpjZW50ZXI7dGV4dC10cmFuc2Zvcm06bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZTt3aWR0aDoxZW19LmZjLWljb24tY2hldnJvbi1sZWZ0OmJlZm9yZXtjb250ZW50OlxcXCJcXFxcZTkwMFxcXCJ9LmZjLWljb24tY2hldnJvbi1yaWdodDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXGU5MDFcXFwifS5mYy1pY29uLWNoZXZyb25zLWxlZnQ6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxlOTAyXFxcIn0uZmMtaWNvbi1jaGV2cm9ucy1yaWdodDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXGU5MDNcXFwifS5mYy1pY29uLW1pbnVzLXNxdWFyZTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXGU5MDRcXFwifS5mYy1pY29uLXBsdXMtc3F1YXJlOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcZTkwNVxcXCJ9LmZjLWljb24teDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXGU5MDZcXFwifS5mYyAuZmMtYnV0dG9ue2JvcmRlci1yYWRpdXM6MDtmb250LWZhbWlseTppbmhlcml0O2ZvbnQtc2l6ZTppbmhlcml0O2xpbmUtaGVpZ2h0OmluaGVyaXQ7bWFyZ2luOjA7b3ZlcmZsb3c6dmlzaWJsZTt0ZXh0LXRyYW5zZm9ybTpub25lfS5mYyAuZmMtYnV0dG9uOmZvY3Vze291dGxpbmU6MXB4IGRvdHRlZDtvdXRsaW5lOjVweCBhdXRvIC13ZWJraXQtZm9jdXMtcmluZy1jb2xvcn0uZmMgLmZjLWJ1dHRvbnstd2Via2l0LWFwcGVhcmFuY2U6YnV0dG9ufS5mYyAuZmMtYnV0dG9uOm5vdCg6ZGlzYWJsZWQpe2N1cnNvcjpwb2ludGVyfS5mYyAuZmMtYnV0dG9ue2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnQ7Ym9yZGVyOjFweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItcmFkaXVzOi4yNWVtO2Rpc3BsYXk6aW5saW5lLWJsb2NrO2ZvbnQtc2l6ZToxZW07Zm9udC13ZWlnaHQ6NDAwO2xpbmUtaGVpZ2h0OjEuNTtwYWRkaW5nOi40ZW0gLjY1ZW07dGV4dC1hbGlnbjpjZW50ZXI7LW1vei11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmU7dmVydGljYWwtYWxpZ246bWlkZGxlfS5mYyAuZmMtYnV0dG9uOmhvdmVye3RleHQtZGVjb3JhdGlvbjpub25lfS5mYyAuZmMtYnV0dG9uOmZvY3Vze2JveC1zaGFkb3c6MCAwIDAgLjJyZW0gcmdiYSg0NCw2Miw4MCwuMjUpO291dGxpbmU6MH0uZmMgLmZjLWJ1dHRvbjpkaXNhYmxlZHtvcGFjaXR5Oi42NX0uZmMgLmZjLWJ1dHRvbi1wcmltYXJ5e2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmMtYnV0dG9uLWJnLWNvbG9yKTtib3JkZXItY29sb3I6dmFyKC0tZmMtYnV0dG9uLWJvcmRlci1jb2xvcik7Y29sb3I6dmFyKC0tZmMtYnV0dG9uLXRleHQtY29sb3IpfS5mYyAuZmMtYnV0dG9uLXByaW1hcnk6aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1mYy1idXR0b24taG92ZXItYmctY29sb3IpO2JvcmRlci1jb2xvcjp2YXIoLS1mYy1idXR0b24taG92ZXItYm9yZGVyLWNvbG9yKTtjb2xvcjp2YXIoLS1mYy1idXR0b24tdGV4dC1jb2xvcil9LmZjIC5mYy1idXR0b24tcHJpbWFyeTpkaXNhYmxlZHtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWZjLWJ1dHRvbi1iZy1jb2xvcik7Ym9yZGVyLWNvbG9yOnZhcigtLWZjLWJ1dHRvbi1ib3JkZXItY29sb3IpO2NvbG9yOnZhcigtLWZjLWJ1dHRvbi10ZXh0LWNvbG9yKX0uZmMgLmZjLWJ1dHRvbi1wcmltYXJ5OmZvY3Vze2JveC1zaGFkb3c6MCAwIDAgLjJyZW0gcmdiYSg3Niw5MSwxMDYsLjUpfS5mYyAuZmMtYnV0dG9uLXByaW1hcnk6bm90KDpkaXNhYmxlZCkuZmMtYnV0dG9uLWFjdGl2ZSwuZmMgLmZjLWJ1dHRvbi1wcmltYXJ5Om5vdCg6ZGlzYWJsZWQpOmFjdGl2ZXtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWZjLWJ1dHRvbi1hY3RpdmUtYmctY29sb3IpO2JvcmRlci1jb2xvcjp2YXIoLS1mYy1idXR0b24tYWN0aXZlLWJvcmRlci1jb2xvcik7Y29sb3I6dmFyKC0tZmMtYnV0dG9uLXRleHQtY29sb3IpfS5mYyAuZmMtYnV0dG9uLXByaW1hcnk6bm90KDpkaXNhYmxlZCkuZmMtYnV0dG9uLWFjdGl2ZTpmb2N1cywuZmMgLmZjLWJ1dHRvbi1wcmltYXJ5Om5vdCg6ZGlzYWJsZWQpOmFjdGl2ZTpmb2N1c3tib3gtc2hhZG93OjAgMCAwIC4ycmVtIHJnYmEoNzYsOTEsMTA2LC41KX0uZmMgLmZjLWJ1dHRvbiAuZmMtaWNvbntmb250LXNpemU6MS41ZW07dmVydGljYWwtYWxpZ246bWlkZGxlfS5mYyAuZmMtYnV0dG9uLWdyb3Vwe2Rpc3BsYXk6aW5saW5lLWZsZXg7cG9zaXRpb246cmVsYXRpdmU7dmVydGljYWwtYWxpZ246bWlkZGxlfS5mYyAuZmMtYnV0dG9uLWdyb3VwPi5mYy1idXR0b257ZmxleDoxIDEgYXV0bztwb3NpdGlvbjpyZWxhdGl2ZX0uZmMgLmZjLWJ1dHRvbi1ncm91cD4uZmMtYnV0dG9uLmZjLWJ1dHRvbi1hY3RpdmUsLmZjIC5mYy1idXR0b24tZ3JvdXA+LmZjLWJ1dHRvbjphY3RpdmUsLmZjIC5mYy1idXR0b24tZ3JvdXA+LmZjLWJ1dHRvbjpmb2N1cywuZmMgLmZjLWJ1dHRvbi1ncm91cD4uZmMtYnV0dG9uOmhvdmVye3otaW5kZXg6MX0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtYnV0dG9uLWdyb3VwPi5mYy1idXR0b246bm90KDpmaXJzdC1jaGlsZCl7Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czowO2JvcmRlci10b3AtbGVmdC1yYWRpdXM6MDttYXJnaW4tbGVmdDotMXB4fS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1idXR0b24tZ3JvdXA+LmZjLWJ1dHRvbjpub3QoOmxhc3QtY2hpbGQpe2JvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOjA7Ym9yZGVyLXRvcC1yaWdodC1yYWRpdXM6MH0uZmMtZGlyZWN0aW9uLXJ0bCAuZmMtYnV0dG9uLWdyb3VwPi5mYy1idXR0b246bm90KDpmaXJzdC1jaGlsZCl7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6MDtib3JkZXItdG9wLXJpZ2h0LXJhZGl1czowO21hcmdpbi1yaWdodDotMXB4fS5mYy1kaXJlY3Rpb24tcnRsIC5mYy1idXR0b24tZ3JvdXA+LmZjLWJ1dHRvbjpub3QoOmxhc3QtY2hpbGQpe2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6MDtib3JkZXItdG9wLWxlZnQtcmFkaXVzOjB9LmZjIC5mYy10b29sYmFye2FsaWduLWl0ZW1zOmNlbnRlcjtkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW59LmZjIC5mYy10b29sYmFyLmZjLWhlYWRlci10b29sYmFye21hcmdpbi1ib3R0b206MS41ZW19LmZjIC5mYy10b29sYmFyLmZjLWZvb3Rlci10b29sYmFye21hcmdpbi10b3A6MS41ZW19LmZjIC5mYy10b29sYmFyLXRpdGxle2ZvbnQtc2l6ZToxLjc1ZW07bWFyZ2luOjB9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLXRvb2xiYXI+Kj46bm90KDpmaXJzdC1jaGlsZCl7bWFyZ2luLWxlZnQ6Ljc1ZW19LmZjLWRpcmVjdGlvbi1ydGwgLmZjLXRvb2xiYXI+Kj46bm90KDpmaXJzdC1jaGlsZCl7bWFyZ2luLXJpZ2h0Oi43NWVtfS5mYy1kaXJlY3Rpb24tcnRsIC5mYy10b29sYmFyLWx0cntmbGV4LWRpcmVjdGlvbjpyb3ctcmV2ZXJzZX0uZmMgLmZjLXNjcm9sbGVyey13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOnRvdWNoO3Bvc2l0aW9uOnJlbGF0aXZlfS5mYyAuZmMtc2Nyb2xsZXItbGlxdWlke2hlaWdodDoxMDAlfS5mYyAuZmMtc2Nyb2xsZXItbGlxdWlkLWFic29sdXRle2JvdHRvbTowO2xlZnQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO3RvcDowfS5mYyAuZmMtc2Nyb2xsZXItaGFybmVzc3tkaXJlY3Rpb246bHRyO292ZXJmbG93OmhpZGRlbjtwb3NpdGlvbjpyZWxhdGl2ZX0uZmMgLmZjLXNjcm9sbGVyLWhhcm5lc3MtbGlxdWlke2hlaWdodDoxMDAlfS5mYy1kaXJlY3Rpb24tcnRsIC5mYy1zY3JvbGxlci1oYXJuZXNzPi5mYy1zY3JvbGxlcntkaXJlY3Rpb246cnRsfS5mYy10aGVtZS1zdGFuZGFyZCAuZmMtc2Nyb2xsZ3JpZHtib3JkZXI6MXB4IHNvbGlkIHZhcigtLWZjLWJvcmRlci1jb2xvcil9LmZjIC5mYy1zY3JvbGxncmlkLC5mYyAuZmMtc2Nyb2xsZ3JpZCB0YWJsZXt0YWJsZS1sYXlvdXQ6Zml4ZWQ7d2lkdGg6MTAwJX0uZmMgLmZjLXNjcm9sbGdyaWQgdGFibGV7Ym9yZGVyLWxlZnQtc3R5bGU6aGlkZGVuO2JvcmRlci1yaWdodC1zdHlsZTpoaWRkZW47Ym9yZGVyLXRvcC1zdHlsZTpoaWRkZW59LmZjIC5mYy1zY3JvbGxncmlke2JvcmRlci1ib3R0b20td2lkdGg6MDtib3JkZXItY29sbGFwc2U6c2VwYXJhdGU7Ym9yZGVyLXJpZ2h0LXdpZHRoOjB9LmZjIC5mYy1zY3JvbGxncmlkLWxpcXVpZHtoZWlnaHQ6MTAwJX0uZmMgLmZjLXNjcm9sbGdyaWQtc2VjdGlvbiwuZmMgLmZjLXNjcm9sbGdyaWQtc2VjdGlvbiB0YWJsZSwuZmMgLmZjLXNjcm9sbGdyaWQtc2VjdGlvbj50ZHtoZWlnaHQ6MXB4fS5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLWxpcXVpZD50ZHtoZWlnaHQ6MTAwJX0uZmMgLmZjLXNjcm9sbGdyaWQtc2VjdGlvbj4qe2JvcmRlci1sZWZ0LXdpZHRoOjA7Ym9yZGVyLXRvcC13aWR0aDowfS5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLWZvb3Rlcj4qLC5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLWhlYWRlcj4qe2JvcmRlci1ib3R0b20td2lkdGg6MH0uZmMgLmZjLXNjcm9sbGdyaWQtc2VjdGlvbi1ib2R5IHRhYmxlLC5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLWZvb3RlciB0YWJsZXtib3JkZXItYm90dG9tLXN0eWxlOmhpZGRlbn0uZmMgLmZjLXNjcm9sbGdyaWQtc2VjdGlvbi1zdGlja3k+KntiYWNrZ3JvdW5kOnZhcigtLWZjLXBhZ2UtYmctY29sb3IpO3Bvc2l0aW9uOnN0aWNreTt6LWluZGV4OjN9LmZjIC5mYy1zY3JvbGxncmlkLXNlY3Rpb24taGVhZGVyLmZjLXNjcm9sbGdyaWQtc2VjdGlvbi1zdGlja3k+Knt0b3A6MH0uZmMgLmZjLXNjcm9sbGdyaWQtc2VjdGlvbi1mb290ZXIuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLXN0aWNreT4qe2JvdHRvbTowfS5mYyAuZmMtc2Nyb2xsZ3JpZC1zdGlja3ktc2hpbXtoZWlnaHQ6MXB4O21hcmdpbi1ib3R0b206LTFweH0uZmMtc3RpY2t5e3Bvc2l0aW9uOnN0aWNreX0uZmMgLmZjLXZpZXctaGFybmVzc3tmbGV4LWdyb3c6MTtwb3NpdGlvbjpyZWxhdGl2ZX0uZmMgLmZjLXZpZXctaGFybmVzcy1hY3RpdmU+LmZjLXZpZXd7Ym90dG9tOjA7bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7dG9wOjB9LmZjIC5mYy1jb2wtaGVhZGVyLWNlbGwtY3VzaGlvbntkaXNwbGF5OmlubGluZS1ibG9jaztwYWRkaW5nOjJweCA0cHh9LmZjIC5mYy1iZy1ldmVudCwuZmMgLmZjLWhpZ2hsaWdodCwuZmMgLmZjLW5vbi1idXNpbmVzc3tib3R0b206MDtsZWZ0OjA7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MDt0b3A6MH0uZmMgLmZjLW5vbi1idXNpbmVzc3tiYWNrZ3JvdW5kOnZhcigtLWZjLW5vbi1idXNpbmVzcy1jb2xvcil9LmZjIC5mYy1iZy1ldmVudHtiYWNrZ3JvdW5kOnZhcigtLWZjLWJnLWV2ZW50LWNvbG9yKTtvcGFjaXR5OnZhcigtLWZjLWJnLWV2ZW50LW9wYWNpdHkpfS5mYyAuZmMtYmctZXZlbnQgLmZjLWV2ZW50LXRpdGxle2ZvbnQtc2l6ZTp2YXIoLS1mYy1zbWFsbC1mb250LXNpemUpO2ZvbnQtc3R5bGU6aXRhbGljO21hcmdpbjouNWVtfS5mYyAuZmMtaGlnaGxpZ2h0e2JhY2tncm91bmQ6dmFyKC0tZmMtaGlnaGxpZ2h0LWNvbG9yKX0uZmMgLmZjLWNlbGwtc2hhZGVkLC5mYyAuZmMtZGF5LWRpc2FibGVke2JhY2tncm91bmQ6dmFyKC0tZmMtbmV1dHJhbC1iZy1jb2xvcil9YS5mYy1ldmVudCxhLmZjLWV2ZW50OmhvdmVye3RleHQtZGVjb3JhdGlvbjpub25lfS5mYy1ldmVudC5mYy1ldmVudC1kcmFnZ2FibGUsLmZjLWV2ZW50W2hyZWZde2N1cnNvcjpwb2ludGVyfS5mYy1ldmVudCAuZmMtZXZlbnQtbWFpbntwb3NpdGlvbjpyZWxhdGl2ZTt6LWluZGV4OjJ9LmZjLWV2ZW50LWRyYWdnaW5nOm5vdCguZmMtZXZlbnQtc2VsZWN0ZWQpe29wYWNpdHk6Ljc1fS5mYy1ldmVudC1kcmFnZ2luZy5mYy1ldmVudC1zZWxlY3RlZHtib3gtc2hhZG93OjAgMnB4IDdweCByZ2JhKDAsMCwwLC4zKX0uZmMtZXZlbnQgLmZjLWV2ZW50LXJlc2l6ZXJ7ZGlzcGxheTpub25lO3Bvc2l0aW9uOmFic29sdXRlO3otaW5kZXg6NH0uZmMtZXZlbnQtc2VsZWN0ZWQgLmZjLWV2ZW50LXJlc2l6ZXIsLmZjLWV2ZW50OmhvdmVyIC5mYy1ldmVudC1yZXNpemVye2Rpc3BsYXk6YmxvY2t9LmZjLWV2ZW50LXNlbGVjdGVkIC5mYy1ldmVudC1yZXNpemVye2JhY2tncm91bmQ6dmFyKC0tZmMtcGFnZS1iZy1jb2xvcik7Ym9yZGVyLWNvbG9yOmluaGVyaXQ7Ym9yZGVyLXJhZGl1czpjYWxjKHZhcigtLWZjLWV2ZW50LXJlc2l6ZXItZG90LXRvdGFsLXdpZHRoKS8yKTtib3JkZXItc3R5bGU6c29saWQ7Ym9yZGVyLXdpZHRoOnZhcigtLWZjLWV2ZW50LXJlc2l6ZXItZG90LWJvcmRlci13aWR0aCk7aGVpZ2h0OnZhcigtLWZjLWV2ZW50LXJlc2l6ZXItZG90LXRvdGFsLXdpZHRoKTt3aWR0aDp2YXIoLS1mYy1ldmVudC1yZXNpemVyLWRvdC10b3RhbC13aWR0aCl9LmZjLWV2ZW50LXNlbGVjdGVkIC5mYy1ldmVudC1yZXNpemVyOmJlZm9yZXtib3R0b206LTIwcHg7Y29udGVudDpcXFwiXFxcIjtsZWZ0Oi0yMHB4O3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0Oi0yMHB4O3RvcDotMjBweH0uZmMtZXZlbnQtc2VsZWN0ZWQsLmZjLWV2ZW50OmZvY3Vze2JveC1zaGFkb3c6MCAycHggNXB4IHJnYmEoMCwwLDAsLjIpfS5mYy1ldmVudC1zZWxlY3RlZDpiZWZvcmUsLmZjLWV2ZW50OmZvY3VzOmJlZm9yZXtib3R0b206MDtjb250ZW50OlxcXCJcXFwiO2xlZnQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO3RvcDowO3otaW5kZXg6M30uZmMtZXZlbnQtc2VsZWN0ZWQ6YWZ0ZXIsLmZjLWV2ZW50OmZvY3VzOmFmdGVye2JhY2tncm91bmQ6dmFyKC0tZmMtZXZlbnQtc2VsZWN0ZWQtb3ZlcmxheS1jb2xvcik7Ym90dG9tOi0xcHg7Y29udGVudDpcXFwiXFxcIjtsZWZ0Oi0xcHg7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6LTFweDt0b3A6LTFweDt6LWluZGV4OjF9LmZjLWgtZXZlbnR7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1mYy1ldmVudC1iZy1jb2xvcik7Ym9yZGVyOjFweCBzb2xpZCB2YXIoLS1mYy1ldmVudC1ib3JkZXItY29sb3IpO2Rpc3BsYXk6YmxvY2t9LmZjLWgtZXZlbnQgLmZjLWV2ZW50LW1haW57Y29sb3I6dmFyKC0tZmMtZXZlbnQtdGV4dC1jb2xvcil9LmZjLWgtZXZlbnQgLmZjLWV2ZW50LW1haW4tZnJhbWV7ZGlzcGxheTpmbGV4fS5mYy1oLWV2ZW50IC5mYy1ldmVudC10aW1le21heC13aWR0aDoxMDAlO292ZXJmbG93OmhpZGRlbn0uZmMtaC1ldmVudCAuZmMtZXZlbnQtdGl0bGUtY29udGFpbmVye2ZsZXgtZ3JvdzoxO2ZsZXgtc2hyaW5rOjE7bWluLXdpZHRoOjB9LmZjLWgtZXZlbnQgLmZjLWV2ZW50LXRpdGxle2Rpc3BsYXk6aW5saW5lLWJsb2NrO2xlZnQ6MDttYXgtd2lkdGg6MTAwJTtvdmVyZmxvdzpoaWRkZW47cmlnaHQ6MDt2ZXJ0aWNhbC1hbGlnbjp0b3B9LmZjLWgtZXZlbnQuZmMtZXZlbnQtc2VsZWN0ZWQ6YmVmb3Jle2JvdHRvbTotMTBweDt0b3A6LTEwcHh9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLWRheWdyaWQtYmxvY2stZXZlbnQ6bm90KC5mYy1ldmVudC1zdGFydCksLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWRheWdyaWQtYmxvY2stZXZlbnQ6bm90KC5mYy1ldmVudC1lbmQpe2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6MDtib3JkZXItbGVmdC13aWR0aDowO2JvcmRlci10b3AtbGVmdC1yYWRpdXM6MH0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtZGF5Z3JpZC1ibG9jay1ldmVudDpub3QoLmZjLWV2ZW50LWVuZCksLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWRheWdyaWQtYmxvY2stZXZlbnQ6bm90KC5mYy1ldmVudC1zdGFydCl7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6MDtib3JkZXItcmlnaHQtd2lkdGg6MDtib3JkZXItdG9wLXJpZ2h0LXJhZGl1czowfS5mYy1oLWV2ZW50Om5vdCguZmMtZXZlbnQtc2VsZWN0ZWQpIC5mYy1ldmVudC1yZXNpemVye2JvdHRvbTowO3RvcDowO3dpZHRoOnZhcigtLWZjLWV2ZW50LXJlc2l6ZXItdGhpY2tuZXNzKX0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtaC1ldmVudDpub3QoLmZjLWV2ZW50LXNlbGVjdGVkKSAuZmMtZXZlbnQtcmVzaXplci1zdGFydCwuZmMtZGlyZWN0aW9uLXJ0bCAuZmMtaC1ldmVudDpub3QoLmZjLWV2ZW50LXNlbGVjdGVkKSAuZmMtZXZlbnQtcmVzaXplci1lbmR7Y3Vyc29yOnctcmVzaXplO2xlZnQ6Y2FsYyh2YXIoLS1mYy1ldmVudC1yZXNpemVyLXRoaWNrbmVzcykqLS41KX0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtaC1ldmVudDpub3QoLmZjLWV2ZW50LXNlbGVjdGVkKSAuZmMtZXZlbnQtcmVzaXplci1lbmQsLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWgtZXZlbnQ6bm90KC5mYy1ldmVudC1zZWxlY3RlZCkgLmZjLWV2ZW50LXJlc2l6ZXItc3RhcnR7Y3Vyc29yOmUtcmVzaXplO3JpZ2h0OmNhbGModmFyKC0tZmMtZXZlbnQtcmVzaXplci10aGlja25lc3MpKi0uNSl9LmZjLWgtZXZlbnQuZmMtZXZlbnQtc2VsZWN0ZWQgLmZjLWV2ZW50LXJlc2l6ZXJ7bWFyZ2luLXRvcDpjYWxjKHZhcigtLWZjLWV2ZW50LXJlc2l6ZXItZG90LXRvdGFsLXdpZHRoKSotLjUpO3RvcDo1MCV9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLWgtZXZlbnQuZmMtZXZlbnQtc2VsZWN0ZWQgLmZjLWV2ZW50LXJlc2l6ZXItc3RhcnQsLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWgtZXZlbnQuZmMtZXZlbnQtc2VsZWN0ZWQgLmZjLWV2ZW50LXJlc2l6ZXItZW5ke2xlZnQ6Y2FsYyh2YXIoLS1mYy1ldmVudC1yZXNpemVyLWRvdC10b3RhbC13aWR0aCkqLS41KX0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtaC1ldmVudC5mYy1ldmVudC1zZWxlY3RlZCAuZmMtZXZlbnQtcmVzaXplci1lbmQsLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWgtZXZlbnQuZmMtZXZlbnQtc2VsZWN0ZWQgLmZjLWV2ZW50LXJlc2l6ZXItc3RhcnR7cmlnaHQ6Y2FsYyh2YXIoLS1mYy1ldmVudC1yZXNpemVyLWRvdC10b3RhbC13aWR0aCkqLS41KX0uZmMgLmZjLXBvcG92ZXJ7Ym94LXNoYWRvdzowIDJweCA2cHggcmdiYSgwLDAsMCwuMTUpO3Bvc2l0aW9uOmFic29sdXRlO3otaW5kZXg6OTk5OX0uZmMgLmZjLXBvcG92ZXItaGVhZGVye2FsaWduLWl0ZW1zOmNlbnRlcjtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246cm93O2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVuO3BhZGRpbmc6M3B4IDRweH0uZmMgLmZjLXBvcG92ZXItdGl0bGV7bWFyZ2luOjAgMnB4fS5mYyAuZmMtcG9wb3Zlci1jbG9zZXtjdXJzb3I6cG9pbnRlcjtmb250LXNpemU6MS4xZW07b3BhY2l0eTouNjV9LmZjLXRoZW1lLXN0YW5kYXJkIC5mYy1wb3BvdmVye2JhY2tncm91bmQ6dmFyKC0tZmMtcGFnZS1iZy1jb2xvcik7Ym9yZGVyOjFweCBzb2xpZCB2YXIoLS1mYy1ib3JkZXItY29sb3IpfS5mYy10aGVtZS1zdGFuZGFyZCAuZmMtcG9wb3Zlci1oZWFkZXJ7YmFja2dyb3VuZDp2YXIoLS1mYy1uZXV0cmFsLWJnLWNvbG9yKX1cIjtcbmluamVjdFN0eWxlcyhjc3NfMjQ4eik7XG5cbmNsYXNzIERlbGF5ZWRSdW5uZXIge1xuICAgIGNvbnN0cnVjdG9yKGRyYWluZWRPcHRpb24pIHtcbiAgICAgICAgdGhpcy5kcmFpbmVkT3B0aW9uID0gZHJhaW5lZE9wdGlvbjtcbiAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0RpcnR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGF1c2VEZXB0aHMgPSB7fTtcbiAgICAgICAgdGhpcy50aW1lb3V0SWQgPSAwO1xuICAgIH1cbiAgICByZXF1ZXN0KGRlbGF5KSB7XG4gICAgICAgIHRoaXMuaXNEaXJ0eSA9IHRydWU7XG4gICAgICAgIGlmICghdGhpcy5pc1BhdXNlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICAgICAgICAgICAgaWYgKGRlbGF5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyeURyYWluKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVvdXRJZCA9IHNldFRpbWVvdXQoLy8gTk9UIE9QVElNQUwhIFRPRE86IGxvb2sgYXQgZGVib3VuY2VcbiAgICAgICAgICAgICAgICB0aGlzLnRyeURyYWluLmJpbmQodGhpcyksIGRlbGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXVzZShzY29wZSA9ICcnKSB7XG4gICAgICAgIGxldCB7IHBhdXNlRGVwdGhzIH0gPSB0aGlzO1xuICAgICAgICBwYXVzZURlcHRoc1tzY29wZV0gPSAocGF1c2VEZXB0aHNbc2NvcGVdIHx8IDApICsgMTtcbiAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgICB9XG4gICAgcmVzdW1lKHNjb3BlID0gJycsIGZvcmNlKSB7XG4gICAgICAgIGxldCB7IHBhdXNlRGVwdGhzIH0gPSB0aGlzO1xuICAgICAgICBpZiAoc2NvcGUgaW4gcGF1c2VEZXB0aHMpIHtcbiAgICAgICAgICAgIGlmIChmb3JjZSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXVzZURlcHRoc1tzY29wZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXVzZURlcHRoc1tzY29wZV0gLT0gMTtcbiAgICAgICAgICAgICAgICBsZXQgZGVwdGggPSBwYXVzZURlcHRoc1tzY29wZV07XG4gICAgICAgICAgICAgICAgaWYgKGRlcHRoIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhdXNlRGVwdGhzW3Njb3BlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRyeURyYWluKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNQYXVzZWQoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnBhdXNlRGVwdGhzKS5sZW5ndGg7XG4gICAgfVxuICAgIHRyeURyYWluKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNSdW5uaW5nICYmICF0aGlzLmlzUGF1c2VkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuaXNSdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLmlzRGlydHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzRGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWluZWQoKTsgLy8gbWlnaHQgc2V0IGlzRGlydHkgdG8gdHJ1ZSBhZ2FpblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgICAgICAgdGhpcy5pc0RpcnR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGF1c2VEZXB0aHMgPSB7fTtcbiAgICB9XG4gICAgY2xlYXJUaW1lb3V0KCkge1xuICAgICAgICBpZiAodGhpcy50aW1lb3V0SWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZCk7XG4gICAgICAgICAgICB0aGlzLnRpbWVvdXRJZCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZHJhaW5lZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhaW5lZE9wdGlvbikge1xuICAgICAgICAgICAgdGhpcy5kcmFpbmVkT3B0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUVsZW1lbnQoZWwpIHtcbiAgICBpZiAoZWwucGFyZW50Tm9kZSkge1xuICAgICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICB9XG59XG4vLyBRdWVyeWluZ1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gZWxlbWVudENsb3Nlc3QoZWwsIHNlbGVjdG9yKSB7XG4gICAgaWYgKGVsLmNsb3Nlc3QpIHtcbiAgICAgICAgcmV0dXJuIGVsLmNsb3Nlc3Qoc2VsZWN0b3IpO1xuICAgICAgICAvLyByZWFsbHkgYmFkIGZhbGxiYWNrIGZvciBJRVxuICAgICAgICAvLyBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L2Nsb3Nlc3RcbiAgICB9XG4gICAgaWYgKCFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMoZWwpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBkbyB7XG4gICAgICAgIGlmIChlbGVtZW50TWF0Y2hlcyhlbCwgc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH1cbiAgICAgICAgZWwgPSAoZWwucGFyZW50RWxlbWVudCB8fCBlbC5wYXJlbnROb2RlKTtcbiAgICB9IHdoaWxlIChlbCAhPT0gbnVsbCAmJiBlbC5ub2RlVHlwZSA9PT0gMSk7XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBlbGVtZW50TWF0Y2hlcyhlbCwgc2VsZWN0b3IpIHtcbiAgICBsZXQgbWV0aG9kID0gZWwubWF0Y2hlcyB8fCBlbC5tYXRjaGVzU2VsZWN0b3IgfHwgZWwubXNNYXRjaGVzU2VsZWN0b3I7XG4gICAgcmV0dXJuIG1ldGhvZC5jYWxsKGVsLCBzZWxlY3Rvcik7XG59XG4vLyBhY2NlcHRzIG11bHRpcGxlIHN1YmplY3QgZWxzXG4vLyByZXR1cm5zIGEgcmVhbCBhcnJheS4gZ29vZCBmb3IgbWV0aG9kcyBsaWtlIGZvckVhY2hcbi8vIFRPRE86IGFjY2VwdCB0aGUgZG9jdW1lbnRcbmZ1bmN0aW9uIGZpbmRFbGVtZW50cyhjb250YWluZXIsIHNlbGVjdG9yKSB7XG4gICAgbGV0IGNvbnRhaW5lcnMgPSBjb250YWluZXIgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCA/IFtjb250YWluZXJdIDogY29udGFpbmVyO1xuICAgIGxldCBhbGxNYXRjaGVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250YWluZXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGxldCBtYXRjaGVzID0gY29udGFpbmVyc1tpXS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtYXRjaGVzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICBhbGxNYXRjaGVzLnB1c2gobWF0Y2hlc1tqXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFsbE1hdGNoZXM7XG59XG4vLyBhY2NlcHRzIG11bHRpcGxlIHN1YmplY3QgZWxzXG4vLyBvbmx5IHF1ZXJpZXMgZGlyZWN0IGNoaWxkIGVsZW1lbnRzIC8vIFRPRE86IHJlbmFtZSB0byBmaW5kRGlyZWN0Q2hpbGRyZW4hXG5mdW5jdGlvbiBmaW5kRGlyZWN0Q2hpbGRyZW4ocGFyZW50LCBzZWxlY3Rvcikge1xuICAgIGxldCBwYXJlbnRzID0gcGFyZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgPyBbcGFyZW50XSA6IHBhcmVudDtcbiAgICBsZXQgYWxsTWF0Y2hlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBsZXQgY2hpbGROb2RlcyA9IHBhcmVudHNbaV0uY2hpbGRyZW47IC8vIG9ubHkgZXZlciBlbGVtZW50c1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNoaWxkTm9kZXMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgIGxldCBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzW2pdO1xuICAgICAgICAgICAgaWYgKCFzZWxlY3RvciB8fCBlbGVtZW50TWF0Y2hlcyhjaGlsZE5vZGUsIHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICAgIGFsbE1hdGNoZXMucHVzaChjaGlsZE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhbGxNYXRjaGVzO1xufVxuLy8gU3R5bGVcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmNvbnN0IFBJWEVMX1BST1BfUkUgPSAvKHRvcHxsZWZ0fHJpZ2h0fGJvdHRvbXx3aWR0aHxoZWlnaHQpJC9pO1xuZnVuY3Rpb24gYXBwbHlTdHlsZShlbCwgcHJvcHMpIHtcbiAgICBmb3IgKGxldCBwcm9wTmFtZSBpbiBwcm9wcykge1xuICAgICAgICBhcHBseVN0eWxlUHJvcChlbCwgcHJvcE5hbWUsIHByb3BzW3Byb3BOYW1lXSk7XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwbHlTdHlsZVByb3AoZWwsIG5hbWUsIHZhbCkge1xuICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICBlbC5zdHlsZVtuYW1lXSA9ICcnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiBQSVhFTF9QUk9QX1JFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgZWwuc3R5bGVbbmFtZV0gPSBgJHt2YWx9cHhgO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZWwuc3R5bGVbbmFtZV0gPSB2YWw7XG4gICAgfVxufVxuLy8gRXZlbnQgSGFuZGxpbmdcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGlmIGludGVyY2VwdGluZyBidWJibGVkIGV2ZW50cyBhdCB0aGUgZG9jdW1lbnQvd2luZG93L2JvZHkgbGV2ZWwsXG4vLyBhbmQgd2FudCB0byBzZWUgb3JpZ2luYXRpbmcgZWxlbWVudCAodGhlICd0YXJnZXQnKSwgdXNlIHRoaXMgdXRpbCBpbnN0ZWFkXG4vLyBvZiBgZXYudGFyZ2V0YCBiZWNhdXNlIGl0IGdvZXMgd2l0aGluIHdlYi1jb21wb25lbnQgYm91bmRhcmllcy5cbmZ1bmN0aW9uIGdldEV2ZW50VGFyZ2V0VmlhUm9vdChldikge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IGV2LmNvbXBvc2VkUGF0aCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoZXYpWzBdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBldi50YXJnZXQ7XG59XG4vLyBVbmlxdWUgSUQgZm9yIERPTSBhdHRyaWJ1dGVcbmxldCBndWlkJDEgPSAwO1xuZnVuY3Rpb24gZ2V0VW5pcXVlRG9tSWQoKSB7XG4gICAgZ3VpZCQxICs9IDE7XG4gICAgcmV0dXJuICdmYy1kb20tJyArIGd1aWQkMTtcbn1cblxuLy8gU3RvcHMgYSBtb3VzZS90b3VjaCBldmVudCBmcm9tIGRvaW5nIGl0J3MgbmF0aXZlIGJyb3dzZXIgYWN0aW9uXG5mdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldikge1xuICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG59XG4vLyBFdmVudCBEZWxlZ2F0aW9uXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBidWlsZERlbGVnYXRpb25IYW5kbGVyKHNlbGVjdG9yLCBoYW5kbGVyKSB7XG4gICAgcmV0dXJuIChldikgPT4ge1xuICAgICAgICBsZXQgbWF0Y2hlZENoaWxkID0gZWxlbWVudENsb3Nlc3QoZXYudGFyZ2V0LCBzZWxlY3Rvcik7XG4gICAgICAgIGlmIChtYXRjaGVkQ2hpbGQpIHtcbiAgICAgICAgICAgIGhhbmRsZXIuY2FsbChtYXRjaGVkQ2hpbGQsIGV2LCBtYXRjaGVkQ2hpbGQpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGxpc3RlbkJ5U2VsZWN0b3IoY29udGFpbmVyLCBldmVudFR5cGUsIHNlbGVjdG9yLCBoYW5kbGVyKSB7XG4gICAgbGV0IGF0dGFjaGVkSGFuZGxlciA9IGJ1aWxkRGVsZWdhdGlvbkhhbmRsZXIoc2VsZWN0b3IsIGhhbmRsZXIpO1xuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgYXR0YWNoZWRIYW5kbGVyKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGF0dGFjaGVkSGFuZGxlcik7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGxpc3RlblRvSG92ZXJCeVNlbGVjdG9yKGNvbnRhaW5lciwgc2VsZWN0b3IsIG9uTW91c2VFbnRlciwgb25Nb3VzZUxlYXZlKSB7XG4gICAgbGV0IGN1cnJlbnRNYXRjaGVkQ2hpbGQ7XG4gICAgcmV0dXJuIGxpc3RlbkJ5U2VsZWN0b3IoY29udGFpbmVyLCAnbW91c2VvdmVyJywgc2VsZWN0b3IsIChtb3VzZU92ZXJFdiwgbWF0Y2hlZENoaWxkKSA9PiB7XG4gICAgICAgIGlmIChtYXRjaGVkQ2hpbGQgIT09IGN1cnJlbnRNYXRjaGVkQ2hpbGQpIHtcbiAgICAgICAgICAgIGN1cnJlbnRNYXRjaGVkQ2hpbGQgPSBtYXRjaGVkQ2hpbGQ7XG4gICAgICAgICAgICBvbk1vdXNlRW50ZXIobW91c2VPdmVyRXYsIG1hdGNoZWRDaGlsZCk7XG4gICAgICAgICAgICBsZXQgcmVhbE9uTW91c2VMZWF2ZSA9IChtb3VzZUxlYXZlRXYpID0+IHtcbiAgICAgICAgICAgICAgICBjdXJyZW50TWF0Y2hlZENoaWxkID0gbnVsbDtcbiAgICAgICAgICAgICAgICBvbk1vdXNlTGVhdmUobW91c2VMZWF2ZUV2LCBtYXRjaGVkQ2hpbGQpO1xuICAgICAgICAgICAgICAgIG1hdGNoZWRDaGlsZC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgcmVhbE9uTW91c2VMZWF2ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gbGlzdGVuIHRvIHRoZSBuZXh0IG1vdXNlbGVhdmUsIGFuZCB0aGVuIHVuYXR0YWNoXG4gICAgICAgICAgICBtYXRjaGVkQ2hpbGQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHJlYWxPbk1vdXNlTGVhdmUpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vLyBBbmltYXRpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmNvbnN0IHRyYW5zaXRpb25FdmVudE5hbWVzID0gW1xuICAgICd3ZWJraXRUcmFuc2l0aW9uRW5kJyxcbiAgICAnb3RyYW5zaXRpb25lbmQnLFxuICAgICdvVHJhbnNpdGlvbkVuZCcsXG4gICAgJ21zVHJhbnNpdGlvbkVuZCcsXG4gICAgJ3RyYW5zaXRpb25lbmQnLFxuXTtcbi8vIHRyaWdnZXJlZCBvbmx5IHdoZW4gdGhlIG5leHQgc2luZ2xlIHN1YnNlcXVlbnQgdHJhbnNpdGlvbiBmaW5pc2hlc1xuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25Eb25lKGVsLCBjYWxsYmFjaykge1xuICAgIGxldCByZWFsQ2FsbGJhY2sgPSAoZXYpID0+IHtcbiAgICAgICAgY2FsbGJhY2soZXYpO1xuICAgICAgICB0cmFuc2l0aW9uRXZlbnROYW1lcy5mb3JFYWNoKChldmVudE5hbWUpID0+IHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCByZWFsQ2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHRyYW5zaXRpb25FdmVudE5hbWVzLmZvckVhY2goKGV2ZW50TmFtZSkgPT4ge1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgcmVhbENhbGxiYWNrKTsgLy8gY3Jvc3MtYnJvd3NlciB3YXkgdG8gZGV0ZXJtaW5lIHdoZW4gdGhlIHRyYW5zaXRpb24gZmluaXNoZXNcbiAgICB9KTtcbn1cbi8vIEFSSUEgd29ya2Fyb3VuZHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGNyZWF0ZUFyaWFDbGlja0F0dHJzKGhhbmRsZXIpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IG9uQ2xpY2s6IGhhbmRsZXIgfSwgY3JlYXRlQXJpYUtleWJvYXJkQXR0cnMoaGFuZGxlcikpO1xufVxuZnVuY3Rpb24gY3JlYXRlQXJpYUtleWJvYXJkQXR0cnMoaGFuZGxlcikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHRhYkluZGV4OiAwLFxuICAgICAgICBvbktleURvd24oZXYpIHtcbiAgICAgICAgICAgIGlmIChldi5rZXkgPT09ICdFbnRlcicgfHwgZXYua2V5ID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyKGV2KTtcbiAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpOyAvLyBpZiBzcGFjZSwgZG9uJ3Qgc2Nyb2xsIGRvd24gcGFnZVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG59XG5cbmxldCBndWlkTnVtYmVyID0gMDtcbmZ1bmN0aW9uIGd1aWQoKSB7XG4gICAgZ3VpZE51bWJlciArPSAxO1xuICAgIHJldHVybiBTdHJpbmcoZ3VpZE51bWJlcik7XG59XG4vKiBGdWxsQ2FsZW5kYXItc3BlY2lmaWMgRE9NIFV0aWxpdGllc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vLyBNYWtlIHRoZSBtb3VzZSBjdXJzb3IgZXhwcmVzcyB0aGF0IGFuIGV2ZW50IGlzIG5vdCBhbGxvd2VkIGluIHRoZSBjdXJyZW50IGFyZWFcbmZ1bmN0aW9uIGRpc2FibGVDdXJzb3IoKSB7XG4gICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKCdmYy1ub3QtYWxsb3dlZCcpO1xufVxuLy8gUmV0dXJucyB0aGUgbW91c2UgY3Vyc29yIHRvIGl0cyBvcmlnaW5hbCBsb29rXG5mdW5jdGlvbiBlbmFibGVDdXJzb3IoKSB7XG4gICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKCdmYy1ub3QtYWxsb3dlZCcpO1xufVxuLyogU2VsZWN0aW9uXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmZ1bmN0aW9uIHByZXZlbnRTZWxlY3Rpb24oZWwpIHtcbiAgICBlbC5zdHlsZS51c2VyU2VsZWN0ID0gJ25vbmUnO1xuICAgIGVsLnN0eWxlLndlYmtpdFVzZXJTZWxlY3QgPSAnbm9uZSc7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0c3RhcnQnLCBwcmV2ZW50RGVmYXVsdCk7XG59XG5mdW5jdGlvbiBhbGxvd1NlbGVjdGlvbihlbCkge1xuICAgIGVsLnN0eWxlLnVzZXJTZWxlY3QgPSAnJztcbiAgICBlbC5zdHlsZS53ZWJraXRVc2VyU2VsZWN0ID0gJyc7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2VsZWN0c3RhcnQnLCBwcmV2ZW50RGVmYXVsdCk7XG59XG4vKiBDb250ZXh0IE1lbnVcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZnVuY3Rpb24gcHJldmVudENvbnRleHRNZW51KGVsKSB7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBwcmV2ZW50RGVmYXVsdCk7XG59XG5mdW5jdGlvbiBhbGxvd0NvbnRleHRNZW51KGVsKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBwcmV2ZW50RGVmYXVsdCk7XG59XG5mdW5jdGlvbiBwYXJzZUZpZWxkU3BlY3MoaW5wdXQpIHtcbiAgICBsZXQgc3BlY3MgPSBbXTtcbiAgICBsZXQgdG9rZW5zID0gW107XG4gICAgbGV0IGk7XG4gICAgbGV0IHRva2VuO1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRva2VucyA9IGlucHV0LnNwbGl0KC9cXHMqLFxccyovKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRva2VucyA9IFtpbnB1dF07XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIHRva2VucyA9IGlucHV0O1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc3BlY3MucHVzaCh0b2tlbi5jaGFyQXQoMCkgPT09ICctJyA/XG4gICAgICAgICAgICAgICAgeyBmaWVsZDogdG9rZW4uc3Vic3RyaW5nKDEpLCBvcmRlcjogLTEgfSA6XG4gICAgICAgICAgICAgICAgeyBmaWVsZDogdG9rZW4sIG9yZGVyOiAxIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc3BlY3MucHVzaCh7IGZ1bmM6IHRva2VuIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzcGVjcztcbn1cbmZ1bmN0aW9uIGNvbXBhcmVCeUZpZWxkU3BlY3Mob2JqMCwgb2JqMSwgZmllbGRTcGVjcykge1xuICAgIGxldCBpO1xuICAgIGxldCBjbXA7XG4gICAgZm9yIChpID0gMDsgaSA8IGZpZWxkU3BlY3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY21wID0gY29tcGFyZUJ5RmllbGRTcGVjKG9iajAsIG9iajEsIGZpZWxkU3BlY3NbaV0pO1xuICAgICAgICBpZiAoY21wKSB7XG4gICAgICAgICAgICByZXR1cm4gY21wO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuZnVuY3Rpb24gY29tcGFyZUJ5RmllbGRTcGVjKG9iajAsIG9iajEsIGZpZWxkU3BlYykge1xuICAgIGlmIChmaWVsZFNwZWMuZnVuYykge1xuICAgICAgICByZXR1cm4gZmllbGRTcGVjLmZ1bmMob2JqMCwgb2JqMSk7XG4gICAgfVxuICAgIHJldHVybiBmbGV4aWJsZUNvbXBhcmUob2JqMFtmaWVsZFNwZWMuZmllbGRdLCBvYmoxW2ZpZWxkU3BlYy5maWVsZF0pXG4gICAgICAgICogKGZpZWxkU3BlYy5vcmRlciB8fCAxKTtcbn1cbmZ1bmN0aW9uIGZsZXhpYmxlQ29tcGFyZShhLCBiKSB7XG4gICAgaWYgKCFhICYmICFiKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAoYiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgaWYgKGEgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgYiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhhKS5sb2NhbGVDb21wYXJlKFN0cmluZyhiKSk7XG4gICAgfVxuICAgIHJldHVybiBhIC0gYjtcbn1cbi8qIFN0cmluZyBVdGlsaXRpZXNcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZnVuY3Rpb24gcGFkU3RhcnQodmFsLCBsZW4pIHtcbiAgICBsZXQgcyA9IFN0cmluZyh2YWwpO1xuICAgIHJldHVybiAnMDAwJy5zdWJzdHIoMCwgbGVuIC0gcy5sZW5ndGgpICsgcztcbn1cbmZ1bmN0aW9uIGZvcm1hdFdpdGhPcmRpbmFscyhmb3JtYXR0ZXIsIGFyZ3MsIGZhbGxiYWNrVGV4dCkge1xuICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXR0ZXIoLi4uYXJncyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnc3RyaW5nJykgeyAvLyBub24tYmxhbmsgc3RyaW5nXG4gICAgICAgIHJldHVybiBhcmdzLnJlZHVjZSgoc3RyLCBhcmcsIGluZGV4KSA9PiAoc3RyLnJlcGxhY2UoJyQnICsgaW5kZXgsIGFyZyB8fCAnJykpLCBmb3JtYXR0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsbGJhY2tUZXh0O1xufVxuLyogTnVtYmVyIFV0aWxpdGllc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5mdW5jdGlvbiBjb21wYXJlTnVtYmVycyhhLCBiKSB7XG4gICAgcmV0dXJuIGEgLSBiO1xufVxuZnVuY3Rpb24gaXNJbnQobikge1xuICAgIHJldHVybiBuICUgMSA9PT0gMDtcbn1cbi8qIEZDLXNwZWNpZmljIERPTSBkaW1lbnNpb24gc3R1ZmZcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZnVuY3Rpb24gY29tcHV0ZVNtYWxsZXN0Q2VsbFdpZHRoKGNlbGxFbCkge1xuICAgIGxldCBhbGxXaWR0aEVsID0gY2VsbEVsLnF1ZXJ5U2VsZWN0b3IoJy5mYy1zY3JvbGxncmlkLXNocmluay1mcmFtZScpO1xuICAgIGxldCBjb250ZW50V2lkdGhFbCA9IGNlbGxFbC5xdWVyeVNlbGVjdG9yKCcuZmMtc2Nyb2xsZ3JpZC1zaHJpbmstY3VzaGlvbicpO1xuICAgIGlmICghYWxsV2lkdGhFbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25lZWRzIGZjLXNjcm9sbGdyaWQtc2hyaW5rLWZyYW1lIGNsYXNzTmFtZScpOyAvLyBUT0RPOiB1c2UgY29uc3RcbiAgICB9XG4gICAgaWYgKCFjb250ZW50V2lkdGhFbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25lZWRzIGZjLXNjcm9sbGdyaWQtc2hyaW5rLWN1c2hpb24gY2xhc3NOYW1lJyk7XG4gICAgfVxuICAgIHJldHVybiBjZWxsRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggLSBhbGxXaWR0aEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICsgLy8gdGhlIGNlbGwgcGFkZGluZytib3JkZXJcbiAgICAgICAgY29udGVudFdpZHRoRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG59XG5cbmNvbnN0IElOVEVSTkFMX1VOSVRTID0gWyd5ZWFycycsICdtb250aHMnLCAnZGF5cycsICdtaWxsaXNlY29uZHMnXTtcbmNvbnN0IFBBUlNFX1JFID0gL14oLT8pKD86KFxcZCspXFwuKT8oXFxkKyk6KFxcZFxcZCkoPzo6KFxcZFxcZCkoPzpcXC4oXFxkXFxkXFxkKSk/KT8vO1xuLy8gUGFyc2luZyBhbmQgQ3JlYXRpb25cbmZ1bmN0aW9uIGNyZWF0ZUR1cmF0aW9uKGlucHV0LCB1bml0KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlU3RyaW5nKGlucHV0KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiYgaW5wdXQpIHsgLy8gbm9uLW51bGwgb2JqZWN0XG4gICAgICAgIHJldHVybiBwYXJzZU9iamVjdChpbnB1dCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBwYXJzZU9iamVjdCh7IFt1bml0IHx8ICdtaWxsaXNlY29uZHMnXTogaW5wdXQgfSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcGFyc2VTdHJpbmcocykge1xuICAgIGxldCBtID0gUEFSU0VfUkUuZXhlYyhzKTtcbiAgICBpZiAobSkge1xuICAgICAgICBsZXQgc2lnbiA9IG1bMV0gPyAtMSA6IDE7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5ZWFyczogMCxcbiAgICAgICAgICAgIG1vbnRoczogMCxcbiAgICAgICAgICAgIGRheXM6IHNpZ24gKiAobVsyXSA/IHBhcnNlSW50KG1bMl0sIDEwKSA6IDApLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiBzaWduICogKChtWzNdID8gcGFyc2VJbnQobVszXSwgMTApIDogMCkgKiA2MCAqIDYwICogMTAwMCArIC8vIGhvdXJzXG4gICAgICAgICAgICAgICAgKG1bNF0gPyBwYXJzZUludChtWzRdLCAxMCkgOiAwKSAqIDYwICogMTAwMCArIC8vIG1pbnV0ZXNcbiAgICAgICAgICAgICAgICAobVs1XSA/IHBhcnNlSW50KG1bNV0sIDEwKSA6IDApICogMTAwMCArIC8vIHNlY29uZHNcbiAgICAgICAgICAgICAgICAobVs2XSA/IHBhcnNlSW50KG1bNl0sIDEwKSA6IDApIC8vIG1zXG4gICAgICAgICAgICApLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHBhcnNlT2JqZWN0KG9iaikge1xuICAgIGxldCBkdXJhdGlvbiA9IHtcbiAgICAgICAgeWVhcnM6IG9iai55ZWFycyB8fCBvYmoueWVhciB8fCAwLFxuICAgICAgICBtb250aHM6IG9iai5tb250aHMgfHwgb2JqLm1vbnRoIHx8IDAsXG4gICAgICAgIGRheXM6IG9iai5kYXlzIHx8IG9iai5kYXkgfHwgMCxcbiAgICAgICAgbWlsbGlzZWNvbmRzOiAob2JqLmhvdXJzIHx8IG9iai5ob3VyIHx8IDApICogNjAgKiA2MCAqIDEwMDAgKyAvLyBob3Vyc1xuICAgICAgICAgICAgKG9iai5taW51dGVzIHx8IG9iai5taW51dGUgfHwgMCkgKiA2MCAqIDEwMDAgKyAvLyBtaW51dGVzXG4gICAgICAgICAgICAob2JqLnNlY29uZHMgfHwgb2JqLnNlY29uZCB8fCAwKSAqIDEwMDAgKyAvLyBzZWNvbmRzXG4gICAgICAgICAgICAob2JqLm1pbGxpc2Vjb25kcyB8fCBvYmoubWlsbGlzZWNvbmQgfHwgb2JqLm1zIHx8IDApLCAvLyBtc1xuICAgIH07XG4gICAgbGV0IHdlZWtzID0gb2JqLndlZWtzIHx8IG9iai53ZWVrO1xuICAgIGlmICh3ZWVrcykge1xuICAgICAgICBkdXJhdGlvbi5kYXlzICs9IHdlZWtzICogNztcbiAgICAgICAgZHVyYXRpb24uc3BlY2lmaWVkV2Vla3MgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZHVyYXRpb247XG59XG4vLyBFcXVhbGl0eVxuZnVuY3Rpb24gZHVyYXRpb25zRXF1YWwoZDAsIGQxKSB7XG4gICAgcmV0dXJuIGQwLnllYXJzID09PSBkMS55ZWFycyAmJlxuICAgICAgICBkMC5tb250aHMgPT09IGQxLm1vbnRocyAmJlxuICAgICAgICBkMC5kYXlzID09PSBkMS5kYXlzICYmXG4gICAgICAgIGQwLm1pbGxpc2Vjb25kcyA9PT0gZDEubWlsbGlzZWNvbmRzO1xufVxuZnVuY3Rpb24gYXNDbGVhbkRheXMoZHVyKSB7XG4gICAgaWYgKCFkdXIueWVhcnMgJiYgIWR1ci5tb250aHMgJiYgIWR1ci5taWxsaXNlY29uZHMpIHtcbiAgICAgICAgcmV0dXJuIGR1ci5kYXlzO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbi8vIFNpbXBsZSBNYXRoXG5mdW5jdGlvbiBhZGREdXJhdGlvbnMoZDAsIGQxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcnM6IGQwLnllYXJzICsgZDEueWVhcnMsXG4gICAgICAgIG1vbnRoczogZDAubW9udGhzICsgZDEubW9udGhzLFxuICAgICAgICBkYXlzOiBkMC5kYXlzICsgZDEuZGF5cyxcbiAgICAgICAgbWlsbGlzZWNvbmRzOiBkMC5taWxsaXNlY29uZHMgKyBkMS5taWxsaXNlY29uZHMsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHN1YnRyYWN0RHVyYXRpb25zKGQxLCBkMCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHllYXJzOiBkMS55ZWFycyAtIGQwLnllYXJzLFxuICAgICAgICBtb250aHM6IGQxLm1vbnRocyAtIGQwLm1vbnRocyxcbiAgICAgICAgZGF5czogZDEuZGF5cyAtIGQwLmRheXMsXG4gICAgICAgIG1pbGxpc2Vjb25kczogZDEubWlsbGlzZWNvbmRzIC0gZDAubWlsbGlzZWNvbmRzLFxuICAgIH07XG59XG5mdW5jdGlvbiBtdWx0aXBseUR1cmF0aW9uKGQsIG4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB5ZWFyczogZC55ZWFycyAqIG4sXG4gICAgICAgIG1vbnRoczogZC5tb250aHMgKiBuLFxuICAgICAgICBkYXlzOiBkLmRheXMgKiBuLFxuICAgICAgICBtaWxsaXNlY29uZHM6IGQubWlsbGlzZWNvbmRzICogbixcbiAgICB9O1xufVxuLy8gQ29udmVyc2lvbnNcbi8vIFwiUm91Z2hcIiBiZWNhdXNlIHRoZXkgYXJlIGJhc2VkIG9uIGF2ZXJhZ2UtY2FzZSBHcmVnb3JpYW4gbW9udGhzL3llYXJzXG5mdW5jdGlvbiBhc1JvdWdoWWVhcnMoZHVyKSB7XG4gICAgcmV0dXJuIGFzUm91Z2hEYXlzKGR1cikgLyAzNjU7XG59XG5mdW5jdGlvbiBhc1JvdWdoTW9udGhzKGR1cikge1xuICAgIHJldHVybiBhc1JvdWdoRGF5cyhkdXIpIC8gMzA7XG59XG5mdW5jdGlvbiBhc1JvdWdoRGF5cyhkdXIpIHtcbiAgICByZXR1cm4gYXNSb3VnaE1zKGR1cikgLyA4NjRlNTtcbn1cbmZ1bmN0aW9uIGFzUm91Z2hNaW51dGVzKGR1cikge1xuICAgIHJldHVybiBhc1JvdWdoTXMoZHVyKSAvICgxMDAwICogNjApO1xufVxuZnVuY3Rpb24gYXNSb3VnaFNlY29uZHMoZHVyKSB7XG4gICAgcmV0dXJuIGFzUm91Z2hNcyhkdXIpIC8gMTAwMDtcbn1cbmZ1bmN0aW9uIGFzUm91Z2hNcyhkdXIpIHtcbiAgICByZXR1cm4gZHVyLnllYXJzICogKDM2NSAqIDg2NGU1KSArXG4gICAgICAgIGR1ci5tb250aHMgKiAoMzAgKiA4NjRlNSkgK1xuICAgICAgICBkdXIuZGF5cyAqIDg2NGU1ICtcbiAgICAgICAgZHVyLm1pbGxpc2Vjb25kcztcbn1cbi8vIEFkdmFuY2VkIE1hdGhcbmZ1bmN0aW9uIHdob2xlRGl2aWRlRHVyYXRpb25zKG51bWVyYXRvciwgZGVub21pbmF0b3IpIHtcbiAgICBsZXQgcmVzID0gbnVsbDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IElOVEVSTkFMX1VOSVRTLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGxldCB1bml0ID0gSU5URVJOQUxfVU5JVFNbaV07XG4gICAgICAgIGlmIChkZW5vbWluYXRvclt1bml0XSkge1xuICAgICAgICAgICAgbGV0IGxvY2FsUmVzID0gbnVtZXJhdG9yW3VuaXRdIC8gZGVub21pbmF0b3JbdW5pdF07XG4gICAgICAgICAgICBpZiAoIWlzSW50KGxvY2FsUmVzKSB8fCAocmVzICE9PSBudWxsICYmIHJlcyAhPT0gbG9jYWxSZXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMgPSBsb2NhbFJlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChudW1lcmF0b3JbdW5pdF0pIHtcbiAgICAgICAgICAgIC8vIG5lZWRzIHRvIGRpdmlkZSBieSBzb21ldGhpbmcgYnV0IGNhbid0IVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvcihkdXIpIHtcbiAgICBsZXQgbXMgPSBkdXIubWlsbGlzZWNvbmRzO1xuICAgIGlmIChtcykge1xuICAgICAgICBpZiAobXMgJSAxMDAwICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnbWlsbGlzZWNvbmQnLCB2YWx1ZTogbXMgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXMgJSAoMTAwMCAqIDYwKSAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ3NlY29uZCcsIHZhbHVlOiBtcyAvIDEwMDAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXMgJSAoMTAwMCAqIDYwICogNjApICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnbWludXRlJywgdmFsdWU6IG1zIC8gKDEwMDAgKiA2MCkgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXMpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdob3VyJywgdmFsdWU6IG1zIC8gKDEwMDAgKiA2MCAqIDYwKSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChkdXIuZGF5cykge1xuICAgICAgICBpZiAoZHVyLnNwZWNpZmllZFdlZWtzICYmIGR1ci5kYXlzICUgNyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ3dlZWsnLCB2YWx1ZTogZHVyLmRheXMgLyA3IH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdW5pdDogJ2RheScsIHZhbHVlOiBkdXIuZGF5cyB9O1xuICAgIH1cbiAgICBpZiAoZHVyLm1vbnRocykge1xuICAgICAgICByZXR1cm4geyB1bml0OiAnbW9udGgnLCB2YWx1ZTogZHVyLm1vbnRocyB9O1xuICAgIH1cbiAgICBpZiAoZHVyLnllYXJzKSB7XG4gICAgICAgIHJldHVybiB7IHVuaXQ6ICd5ZWFyJywgdmFsdWU6IGR1ci55ZWFycyB9O1xuICAgIH1cbiAgICByZXR1cm4geyB1bml0OiAnbWlsbGlzZWNvbmQnLCB2YWx1ZTogMCB9O1xufVxuXG4vLyBUT0RPOiBuZXcgdXRpbCBhcnJheWlmeT9cbmZ1bmN0aW9uIHJlbW92ZUV4YWN0KGFycmF5LCBleGFjdFZhbCkge1xuICAgIGxldCByZW1vdmVDbnQgPSAwO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFycmF5Lmxlbmd0aCkge1xuICAgICAgICBpZiAoYXJyYXlbaV0gPT09IGV4YWN0VmFsKSB7XG4gICAgICAgICAgICBhcnJheS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICByZW1vdmVDbnQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVtb3ZlQ250O1xufVxuZnVuY3Rpb24gaXNBcnJheXNFcXVhbChhMCwgYTEsIGVxdWFsaXR5RnVuYykge1xuICAgIGlmIChhMCA9PT0gYTEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxldCBsZW4gPSBhMC5sZW5ndGg7XG4gICAgbGV0IGk7XG4gICAgaWYgKGxlbiAhPT0gYTEubGVuZ3RoKSB7IC8vIG5vdCBhcnJheT8gb3Igbm90IHNhbWUgbGVuZ3RoP1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBpZiAoIShlcXVhbGl0eUZ1bmMgPyBlcXVhbGl0eUZ1bmMoYTBbaV0sIGExW2ldKSA6IGEwW2ldID09PSBhMVtpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuY29uc3QgREFZX0lEUyA9IFsnc3VuJywgJ21vbicsICd0dWUnLCAnd2VkJywgJ3RodScsICdmcmknLCAnc2F0J107XG4vLyBBZGRpbmdcbmZ1bmN0aW9uIGFkZFdlZWtzKG0sIG4pIHtcbiAgICBsZXQgYSA9IGRhdGVUb1V0Y0FycmF5KG0pO1xuICAgIGFbMl0gKz0gbiAqIDc7XG4gICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKGEpO1xufVxuZnVuY3Rpb24gYWRkRGF5cyhtLCBuKSB7XG4gICAgbGV0IGEgPSBkYXRlVG9VdGNBcnJheShtKTtcbiAgICBhWzJdICs9IG47XG4gICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKGEpO1xufVxuZnVuY3Rpb24gYWRkTXMobSwgbikge1xuICAgIGxldCBhID0gZGF0ZVRvVXRjQXJyYXkobSk7XG4gICAgYVs2XSArPSBuO1xuICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShhKTtcbn1cbi8vIERpZmZpbmcgKGFsbCByZXR1cm4gZmxvYXRzKVxuLy8gVE9ETzogd2h5IG5vdCB1c2UgcmFuZ2VzP1xuZnVuY3Rpb24gZGlmZldlZWtzKG0wLCBtMSkge1xuICAgIHJldHVybiBkaWZmRGF5cyhtMCwgbTEpIC8gNztcbn1cbmZ1bmN0aW9uIGRpZmZEYXlzKG0wLCBtMSkge1xuICAgIHJldHVybiAobTEudmFsdWVPZigpIC0gbTAudmFsdWVPZigpKSAvICgxMDAwICogNjAgKiA2MCAqIDI0KTtcbn1cbmZ1bmN0aW9uIGRpZmZIb3VycyhtMCwgbTEpIHtcbiAgICByZXR1cm4gKG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSkgLyAoMTAwMCAqIDYwICogNjApO1xufVxuZnVuY3Rpb24gZGlmZk1pbnV0ZXMobTAsIG0xKSB7XG4gICAgcmV0dXJuIChtMS52YWx1ZU9mKCkgLSBtMC52YWx1ZU9mKCkpIC8gKDEwMDAgKiA2MCk7XG59XG5mdW5jdGlvbiBkaWZmU2Vjb25kcyhtMCwgbTEpIHtcbiAgICByZXR1cm4gKG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSkgLyAxMDAwO1xufVxuZnVuY3Rpb24gZGlmZkRheUFuZFRpbWUobTAsIG0xKSB7XG4gICAgbGV0IG0wZGF5ID0gc3RhcnRPZkRheShtMCk7XG4gICAgbGV0IG0xZGF5ID0gc3RhcnRPZkRheShtMSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcnM6IDAsXG4gICAgICAgIG1vbnRoczogMCxcbiAgICAgICAgZGF5czogTWF0aC5yb3VuZChkaWZmRGF5cyhtMGRheSwgbTFkYXkpKSxcbiAgICAgICAgbWlsbGlzZWNvbmRzOiAobTEudmFsdWVPZigpIC0gbTFkYXkudmFsdWVPZigpKSAtIChtMC52YWx1ZU9mKCkgLSBtMGRheS52YWx1ZU9mKCkpLFxuICAgIH07XG59XG4vLyBEaWZmaW5nIFdob2xlIFVuaXRzXG5mdW5jdGlvbiBkaWZmV2hvbGVXZWVrcyhtMCwgbTEpIHtcbiAgICBsZXQgZCA9IGRpZmZXaG9sZURheXMobTAsIG0xKTtcbiAgICBpZiAoZCAhPT0gbnVsbCAmJiBkICUgNyA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZCAvIDc7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZGlmZldob2xlRGF5cyhtMCwgbTEpIHtcbiAgICBpZiAodGltZUFzTXMobTApID09PSB0aW1lQXNNcyhtMSkpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoZGlmZkRheXMobTAsIG0xKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLy8gU3RhcnQtT2ZcbmZ1bmN0aW9uIHN0YXJ0T2ZEYXkobSkge1xuICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShbXG4gICAgICAgIG0uZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgbS5nZXRVVENNb250aCgpLFxuICAgICAgICBtLmdldFVUQ0RhdGUoKSxcbiAgICBdKTtcbn1cbmZ1bmN0aW9uIHN0YXJ0T2ZIb3VyKG0pIHtcbiAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoW1xuICAgICAgICBtLmdldFVUQ0Z1bGxZZWFyKCksXG4gICAgICAgIG0uZ2V0VVRDTW9udGgoKSxcbiAgICAgICAgbS5nZXRVVENEYXRlKCksXG4gICAgICAgIG0uZ2V0VVRDSG91cnMoKSxcbiAgICBdKTtcbn1cbmZ1bmN0aW9uIHN0YXJ0T2ZNaW51dGUobSkge1xuICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShbXG4gICAgICAgIG0uZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgbS5nZXRVVENNb250aCgpLFxuICAgICAgICBtLmdldFVUQ0RhdGUoKSxcbiAgICAgICAgbS5nZXRVVENIb3VycygpLFxuICAgICAgICBtLmdldFVUQ01pbnV0ZXMoKSxcbiAgICBdKTtcbn1cbmZ1bmN0aW9uIHN0YXJ0T2ZTZWNvbmQobSkge1xuICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShbXG4gICAgICAgIG0uZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgbS5nZXRVVENNb250aCgpLFxuICAgICAgICBtLmdldFVUQ0RhdGUoKSxcbiAgICAgICAgbS5nZXRVVENIb3VycygpLFxuICAgICAgICBtLmdldFVUQ01pbnV0ZXMoKSxcbiAgICAgICAgbS5nZXRVVENTZWNvbmRzKCksXG4gICAgXSk7XG59XG4vLyBXZWVrIENvbXB1dGF0aW9uXG5mdW5jdGlvbiB3ZWVrT2ZZZWFyKG1hcmtlciwgZG93LCBkb3kpIHtcbiAgICBsZXQgeSA9IG1hcmtlci5nZXRVVENGdWxsWWVhcigpO1xuICAgIGxldCB3ID0gd2Vla09mR2l2ZW5ZZWFyKG1hcmtlciwgeSwgZG93LCBkb3kpO1xuICAgIGlmICh3IDwgMSkge1xuICAgICAgICByZXR1cm4gd2Vla09mR2l2ZW5ZZWFyKG1hcmtlciwgeSAtIDEsIGRvdywgZG95KTtcbiAgICB9XG4gICAgbGV0IG5leHRXID0gd2Vla09mR2l2ZW5ZZWFyKG1hcmtlciwgeSArIDEsIGRvdywgZG95KTtcbiAgICBpZiAobmV4dFcgPj0gMSkge1xuICAgICAgICByZXR1cm4gTWF0aC5taW4odywgbmV4dFcpO1xuICAgIH1cbiAgICByZXR1cm4gdztcbn1cbmZ1bmN0aW9uIHdlZWtPZkdpdmVuWWVhcihtYXJrZXIsIHllYXIsIGRvdywgZG95KSB7XG4gICAgbGV0IGZpcnN0V2Vla1N0YXJ0ID0gYXJyYXlUb1V0Y0RhdGUoW3llYXIsIDAsIDEgKyBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpXSk7XG4gICAgbGV0IGRheVN0YXJ0ID0gc3RhcnRPZkRheShtYXJrZXIpO1xuICAgIGxldCBkYXlzID0gTWF0aC5yb3VuZChkaWZmRGF5cyhmaXJzdFdlZWtTdGFydCwgZGF5U3RhcnQpKTtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihkYXlzIC8gNykgKyAxOyAvLyB6ZXJvLWluZGV4ZWRcbn1cbi8vIHN0YXJ0LW9mLWZpcnN0LXdlZWsgLSBzdGFydC1vZi15ZWFyXG5mdW5jdGlvbiBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpIHtcbiAgICAvLyBmaXJzdC13ZWVrIGRheSAtLSB3aGljaCBqYW51YXJ5IGlzIGFsd2F5cyBpbiB0aGUgZmlyc3Qgd2VlayAoNCBmb3IgaXNvLCAxIGZvciBvdGhlcilcbiAgICBsZXQgZndkID0gNyArIGRvdyAtIGRveTtcbiAgICAvLyBmaXJzdC13ZWVrIGRheSBsb2NhbCB3ZWVrZGF5IC0tIHdoaWNoIGxvY2FsIHdlZWtkYXkgaXMgZndkXG4gICAgbGV0IGZ3ZGx3ID0gKDcgKyBhcnJheVRvVXRjRGF0ZShbeWVhciwgMCwgZndkXSkuZ2V0VVRDRGF5KCkgLSBkb3cpICUgNztcbiAgICByZXR1cm4gLWZ3ZGx3ICsgZndkIC0gMTtcbn1cbi8vIEFycmF5IENvbnZlcnNpb25cbmZ1bmN0aW9uIGRhdGVUb0xvY2FsQXJyYXkoZGF0ZSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGRhdGUuZ2V0RnVsbFllYXIoKSxcbiAgICAgICAgZGF0ZS5nZXRNb250aCgpLFxuICAgICAgICBkYXRlLmdldERhdGUoKSxcbiAgICAgICAgZGF0ZS5nZXRIb3VycygpLFxuICAgICAgICBkYXRlLmdldE1pbnV0ZXMoKSxcbiAgICAgICAgZGF0ZS5nZXRTZWNvbmRzKCksXG4gICAgICAgIGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCksXG4gICAgXTtcbn1cbmZ1bmN0aW9uIGFycmF5VG9Mb2NhbERhdGUoYSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShhWzBdLCBhWzFdIHx8IDAsIGFbMl0gPT0gbnVsbCA/IDEgOiBhWzJdLCAvLyBkYXkgb2YgbW9udGhcbiAgICBhWzNdIHx8IDAsIGFbNF0gfHwgMCwgYVs1XSB8fCAwKTtcbn1cbmZ1bmN0aW9uIGRhdGVUb1V0Y0FycmF5KGRhdGUpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBkYXRlLmdldFVUQ0Z1bGxZZWFyKCksXG4gICAgICAgIGRhdGUuZ2V0VVRDTW9udGgoKSxcbiAgICAgICAgZGF0ZS5nZXRVVENEYXRlKCksXG4gICAgICAgIGRhdGUuZ2V0VVRDSG91cnMoKSxcbiAgICAgICAgZGF0ZS5nZXRVVENNaW51dGVzKCksXG4gICAgICAgIGRhdGUuZ2V0VVRDU2Vjb25kcygpLFxuICAgICAgICBkYXRlLmdldFVUQ01pbGxpc2Vjb25kcygpLFxuICAgIF07XG59XG5mdW5jdGlvbiBhcnJheVRvVXRjRGF0ZShhKSB7XG4gICAgLy8gYWNjb3JkaW5nIHRvIHdlYiBzdGFuZGFyZHMgKGFuZCBTYWZhcmkpLCBhIG1vbnRoIGluZGV4IGlzIHJlcXVpcmVkLlxuICAgIC8vIG1hc3NhZ2UgaWYgb25seSBnaXZlbiBhIHllYXIuXG4gICAgaWYgKGEubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGEgPSBhLmNvbmNhdChbMF0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoLi4uYSkpO1xufVxuLy8gT3RoZXIgVXRpbHNcbmZ1bmN0aW9uIGlzVmFsaWREYXRlKG0pIHtcbiAgICByZXR1cm4gIWlzTmFOKG0udmFsdWVPZigpKTtcbn1cbmZ1bmN0aW9uIHRpbWVBc01zKG0pIHtcbiAgICByZXR1cm4gbS5nZXRVVENIb3VycygpICogMTAwMCAqIDYwICogNjAgK1xuICAgICAgICBtLmdldFVUQ01pbnV0ZXMoKSAqIDEwMDAgKiA2MCArXG4gICAgICAgIG0uZ2V0VVRDU2Vjb25kcygpICogMTAwMCArXG4gICAgICAgIG0uZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG59XG5cbi8vIHRpbWVab25lT2Zmc2V0IGlzIGluIG1pbnV0ZXNcbmZ1bmN0aW9uIGJ1aWxkSXNvU3RyaW5nKG1hcmtlciwgdGltZVpvbmVPZmZzZXQsIHN0cmlwWmVyb1RpbWUgPSBmYWxzZSkge1xuICAgIGxldCBzID0gbWFya2VyLnRvSVNPU3RyaW5nKCk7XG4gICAgcyA9IHMucmVwbGFjZSgnLjAwMCcsICcnKTtcbiAgICBpZiAoc3RyaXBaZXJvVGltZSkge1xuICAgICAgICBzID0gcy5yZXBsYWNlKCdUMDA6MDA6MDBaJywgJycpO1xuICAgIH1cbiAgICBpZiAocy5sZW5ndGggPiAxMCkgeyAvLyB0aW1lIHBhcnQgd2Fzbid0IHN0cmlwcGVkLCBjYW4gYWRkIHRpbWV6b25lIGluZm9cbiAgICAgICAgaWYgKHRpbWVab25lT2Zmc2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoJ1onLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGltZVpvbmVPZmZzZXQgIT09IDApIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoJ1onLCBmb3JtYXRUaW1lWm9uZU9mZnNldCh0aW1lWm9uZU9mZnNldCwgdHJ1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG90aGVyd2lzZSwgaXRzIFVUQy0wIGFuZCB3ZSB3YW50IHRvIGtlZXAgdGhlIFpcbiAgICB9XG4gICAgcmV0dXJuIHM7XG59XG4vLyBmb3JtYXRzIHRoZSBkYXRlLCBidXQgd2l0aCBubyB0aW1lIHBhcnRcbi8vIFRPRE86IHNvbWVob3cgbWVyZ2Ugd2l0aCBidWlsZElzb1N0cmluZyBhbmQgc3RyaXBaZXJvVGltZVxuLy8gVE9ETzogcmVuYW1lLiBvbWl0IFwic3RyaW5nXCJcbmZ1bmN0aW9uIGZvcm1hdERheVN0cmluZyhtYXJrZXIpIHtcbiAgICByZXR1cm4gbWFya2VyLnRvSVNPU3RyaW5nKCkucmVwbGFjZSgvVC4qJC8sICcnKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdElzb01vbnRoU3RyKG1hcmtlcikge1xuICAgIHJldHVybiBtYXJrZXIudG9JU09TdHJpbmcoKS5tYXRjaCgvXlxcZHs0fS1cXGR7Mn0vKVswXTtcbn1cbi8vIFRPRE86IHVzZSBEYXRlOjp0b0lTT1N0cmluZyBhbmQgdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIFQ/XG5mdW5jdGlvbiBmb3JtYXRJc29UaW1lU3RyaW5nKG1hcmtlcikge1xuICAgIHJldHVybiBwYWRTdGFydChtYXJrZXIuZ2V0VVRDSG91cnMoKSwgMikgKyAnOicgK1xuICAgICAgICBwYWRTdGFydChtYXJrZXIuZ2V0VVRDTWludXRlcygpLCAyKSArICc6JyArXG4gICAgICAgIHBhZFN0YXJ0KG1hcmtlci5nZXRVVENTZWNvbmRzKCksIDIpO1xufVxuZnVuY3Rpb24gZm9ybWF0VGltZVpvbmVPZmZzZXQobWludXRlcywgZG9Jc28gPSBmYWxzZSkge1xuICAgIGxldCBzaWduID0gbWludXRlcyA8IDAgPyAnLScgOiAnKyc7XG4gICAgbGV0IGFicyA9IE1hdGguYWJzKG1pbnV0ZXMpO1xuICAgIGxldCBob3VycyA9IE1hdGguZmxvb3IoYWJzIC8gNjApO1xuICAgIGxldCBtaW5zID0gTWF0aC5yb3VuZChhYnMgJSA2MCk7XG4gICAgaWYgKGRvSXNvKSB7XG4gICAgICAgIHJldHVybiBgJHtzaWduICsgcGFkU3RhcnQoaG91cnMsIDIpfToke3BhZFN0YXJ0KG1pbnMsIDIpfWA7XG4gICAgfVxuICAgIHJldHVybiBgR01UJHtzaWdufSR7aG91cnN9JHttaW5zID8gYDoke3BhZFN0YXJ0KG1pbnMsIDIpfWAgOiAnJ31gO1xufVxuXG5mdW5jdGlvbiBtZW1vaXplKHdvcmtlckZ1bmMsIHJlc0VxdWFsaXR5LCB0ZWFyZG93bkZ1bmMpIHtcbiAgICBsZXQgY3VycmVudEFyZ3M7XG4gICAgbGV0IGN1cnJlbnRSZXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5uZXdBcmdzKSB7XG4gICAgICAgIGlmICghY3VycmVudEFyZ3MpIHtcbiAgICAgICAgICAgIGN1cnJlbnRSZXMgPSB3b3JrZXJGdW5jLmFwcGx5KHRoaXMsIG5ld0FyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpc0FycmF5c0VxdWFsKGN1cnJlbnRBcmdzLCBuZXdBcmdzKSkge1xuICAgICAgICAgICAgaWYgKHRlYXJkb3duRnVuYykge1xuICAgICAgICAgICAgICAgIHRlYXJkb3duRnVuYyhjdXJyZW50UmVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZXMgPSB3b3JrZXJGdW5jLmFwcGx5KHRoaXMsIG5ld0FyZ3MpO1xuICAgICAgICAgICAgaWYgKCFyZXNFcXVhbGl0eSB8fCAhcmVzRXF1YWxpdHkocmVzLCBjdXJyZW50UmVzKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRSZXMgPSByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEFyZ3MgPSBuZXdBcmdzO1xuICAgICAgICByZXR1cm4gY3VycmVudFJlcztcbiAgICB9O1xufVxuZnVuY3Rpb24gbWVtb2l6ZU9iakFyZyh3b3JrZXJGdW5jLCByZXNFcXVhbGl0eSwgdGVhcmRvd25GdW5jKSB7XG4gICAgbGV0IGN1cnJlbnRBcmc7XG4gICAgbGV0IGN1cnJlbnRSZXM7XG4gICAgcmV0dXJuIChuZXdBcmcpID0+IHtcbiAgICAgICAgaWYgKCFjdXJyZW50QXJnKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVzID0gd29ya2VyRnVuYy5jYWxsKHRoaXMsIG5ld0FyZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWlzUHJvcHNFcXVhbChjdXJyZW50QXJnLCBuZXdBcmcpKSB7XG4gICAgICAgICAgICBpZiAodGVhcmRvd25GdW5jKSB7XG4gICAgICAgICAgICAgICAgdGVhcmRvd25GdW5jKGN1cnJlbnRSZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlcyA9IHdvcmtlckZ1bmMuY2FsbCh0aGlzLCBuZXdBcmcpO1xuICAgICAgICAgICAgaWYgKCFyZXNFcXVhbGl0eSB8fCAhcmVzRXF1YWxpdHkocmVzLCBjdXJyZW50UmVzKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRSZXMgPSByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEFyZyA9IG5ld0FyZztcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRSZXM7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1lbW9pemVBcnJheWxpa2UoLy8gdXNlZCBhdCBhbGw/XG53b3JrZXJGdW5jLCByZXNFcXVhbGl0eSwgdGVhcmRvd25GdW5jKSB7XG4gICAgbGV0IGN1cnJlbnRBcmdTZXRzID0gW107XG4gICAgbGV0IGN1cnJlbnRSZXN1bHRzID0gW107XG4gICAgcmV0dXJuIChuZXdBcmdTZXRzKSA9PiB7XG4gICAgICAgIGxldCBjdXJyZW50TGVuID0gY3VycmVudEFyZ1NldHMubGVuZ3RoO1xuICAgICAgICBsZXQgbmV3TGVuID0gbmV3QXJnU2V0cy5sZW5ndGg7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yICg7IGkgPCBjdXJyZW50TGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmICghbmV3QXJnU2V0c1tpXSkgeyAvLyBvbmUgb2YgdGhlIG9sZCBzZXRzIG5vIGxvbmdlciBleGlzdHNcbiAgICAgICAgICAgICAgICBpZiAodGVhcmRvd25GdW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlYXJkb3duRnVuYyhjdXJyZW50UmVzdWx0c1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzQXJyYXlzRXF1YWwoY3VycmVudEFyZ1NldHNbaV0sIG5ld0FyZ1NldHNbaV0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRlYXJkb3duRnVuYykge1xuICAgICAgICAgICAgICAgICAgICB0ZWFyZG93bkZ1bmMoY3VycmVudFJlc3VsdHNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcmVzID0gd29ya2VyRnVuYy5hcHBseSh0aGlzLCBuZXdBcmdTZXRzW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc0VxdWFsaXR5IHx8ICFyZXNFcXVhbGl0eShyZXMsIGN1cnJlbnRSZXN1bHRzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVzdWx0c1tpXSA9IHJlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IGkgPCBuZXdMZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgY3VycmVudFJlc3VsdHNbaV0gPSB3b3JrZXJGdW5jLmFwcGx5KHRoaXMsIG5ld0FyZ1NldHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRBcmdTZXRzID0gbmV3QXJnU2V0cztcbiAgICAgICAgY3VycmVudFJlc3VsdHMuc3BsaWNlKG5ld0xlbik7IC8vIHJlbW92ZSBleGNlc3NcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRSZXN1bHRzO1xuICAgIH07XG59XG5mdW5jdGlvbiBtZW1vaXplSGFzaGxpa2Uod29ya2VyRnVuYywgcmVzRXF1YWxpdHksIHRlYXJkb3duRnVuYykge1xuICAgIGxldCBjdXJyZW50QXJnSGFzaCA9IHt9O1xuICAgIGxldCBjdXJyZW50UmVzSGFzaCA9IHt9O1xuICAgIHJldHVybiAobmV3QXJnSGFzaCkgPT4ge1xuICAgICAgICBsZXQgbmV3UmVzSGFzaCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBrZXkgaW4gbmV3QXJnSGFzaCkge1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50UmVzSGFzaFtrZXldKSB7XG4gICAgICAgICAgICAgICAgbmV3UmVzSGFzaFtrZXldID0gd29ya2VyRnVuYy5hcHBseSh0aGlzLCBuZXdBcmdIYXNoW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzQXJyYXlzRXF1YWwoY3VycmVudEFyZ0hhc2hba2V5XSwgbmV3QXJnSGFzaFtrZXldKSkge1xuICAgICAgICAgICAgICAgIGlmICh0ZWFyZG93bkZ1bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVhcmRvd25GdW5jKGN1cnJlbnRSZXNIYXNoW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcmVzID0gd29ya2VyRnVuYy5hcHBseSh0aGlzLCBuZXdBcmdIYXNoW2tleV0pO1xuICAgICAgICAgICAgICAgIG5ld1Jlc0hhc2hba2V5XSA9IChyZXNFcXVhbGl0eSAmJiByZXNFcXVhbGl0eShyZXMsIGN1cnJlbnRSZXNIYXNoW2tleV0pKVxuICAgICAgICAgICAgICAgICAgICA/IGN1cnJlbnRSZXNIYXNoW2tleV1cbiAgICAgICAgICAgICAgICAgICAgOiByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdSZXNIYXNoW2tleV0gPSBjdXJyZW50UmVzSGFzaFtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRBcmdIYXNoID0gbmV3QXJnSGFzaDtcbiAgICAgICAgY3VycmVudFJlc0hhc2ggPSBuZXdSZXNIYXNoO1xuICAgICAgICByZXR1cm4gbmV3UmVzSGFzaDtcbiAgICB9O1xufVxuXG5jb25zdCBFWFRFTkRFRF9TRVRUSU5HU19BTkRfU0VWRVJJVElFUyA9IHtcbiAgICB3ZWVrOiAzLFxuICAgIHNlcGFyYXRvcjogMCxcbiAgICBvbWl0WmVyb01pbnV0ZTogMCxcbiAgICBtZXJpZGllbTogMCxcbiAgICBvbWl0Q29tbWFzOiAwLFxufTtcbmNvbnN0IFNUQU5EQVJEX0RBVEVfUFJPUF9TRVZFUklUSUVTID0ge1xuICAgIHRpbWVab25lTmFtZTogNyxcbiAgICBlcmE6IDYsXG4gICAgeWVhcjogNSxcbiAgICBtb250aDogNCxcbiAgICBkYXk6IDIsXG4gICAgd2Vla2RheTogMixcbiAgICBob3VyOiAxLFxuICAgIG1pbnV0ZTogMSxcbiAgICBzZWNvbmQ6IDEsXG59O1xuY29uc3QgTUVSSURJRU1fUkUgPSAvXFxzKihbYXBdKVxcLj9tXFwuPy9pOyAvLyBlYXRzIHVwIGxlYWRpbmcgc3BhY2VzIHRvb1xuY29uc3QgQ09NTUFfUkUgPSAvLC9nOyAvLyB3ZSBuZWVkIHJlIGZvciBnbG9iYWxuZXNzXG5jb25zdCBNVUxUSV9TUEFDRV9SRSA9IC9cXHMrL2c7XG5jb25zdCBMVFJfUkUgPSAvXFx1MjAwZS9nOyAvLyBjb250cm9sIGNoYXJhY3RlclxuY29uc3QgVVRDX1JFID0gL1VUQ3xHTVQvO1xuY2xhc3MgTmF0aXZlRm9ybWF0dGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihmb3JtYXRTZXR0aW5ncykge1xuICAgICAgICBsZXQgc3RhbmRhcmREYXRlUHJvcHMgPSB7fTtcbiAgICAgICAgbGV0IGV4dGVuZGVkU2V0dGluZ3MgPSB7fTtcbiAgICAgICAgbGV0IHNldmVyaXR5ID0gMDtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBmb3JtYXRTZXR0aW5ncykge1xuICAgICAgICAgICAgaWYgKG5hbWUgaW4gRVhURU5ERURfU0VUVElOR1NfQU5EX1NFVkVSSVRJRVMpIHtcbiAgICAgICAgICAgICAgICBleHRlbmRlZFNldHRpbmdzW25hbWVdID0gZm9ybWF0U2V0dGluZ3NbbmFtZV07XG4gICAgICAgICAgICAgICAgc2V2ZXJpdHkgPSBNYXRoLm1heChFWFRFTkRFRF9TRVRUSU5HU19BTkRfU0VWRVJJVElFU1tuYW1lXSwgc2V2ZXJpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhbmRhcmREYXRlUHJvcHNbbmFtZV0gPSBmb3JtYXRTZXR0aW5nc1tuYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSBpbiBTVEFOREFSRF9EQVRFX1BST1BfU0VWRVJJVElFUykgeyAvLyBUT0RPOiB3aGF0IGFib3V0IGhvdXIxMj8gbm8gc2V2ZXJpdHlcbiAgICAgICAgICAgICAgICAgICAgc2V2ZXJpdHkgPSBNYXRoLm1heChTVEFOREFSRF9EQVRFX1BST1BfU0VWRVJJVElFU1tuYW1lXSwgc2V2ZXJpdHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YW5kYXJkRGF0ZVByb3BzID0gc3RhbmRhcmREYXRlUHJvcHM7XG4gICAgICAgIHRoaXMuZXh0ZW5kZWRTZXR0aW5ncyA9IGV4dGVuZGVkU2V0dGluZ3M7XG4gICAgICAgIHRoaXMuc2V2ZXJpdHkgPSBzZXZlcml0eTtcbiAgICAgICAgdGhpcy5idWlsZEZvcm1hdHRpbmdGdW5jID0gbWVtb2l6ZShidWlsZEZvcm1hdHRpbmdGdW5jKTtcbiAgICB9XG4gICAgZm9ybWF0KGRhdGUsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRGb3JtYXR0aW5nRnVuYyh0aGlzLnN0YW5kYXJkRGF0ZVByb3BzLCB0aGlzLmV4dGVuZGVkU2V0dGluZ3MsIGNvbnRleHQpKGRhdGUpO1xuICAgIH1cbiAgICBmb3JtYXRSYW5nZShzdGFydCwgZW5kLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSB7XG4gICAgICAgIGxldCB7IHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgZGlmZlNldmVyaXR5ID0gY29tcHV0ZU1hcmtlckRpZmZTZXZlcml0eShzdGFydC5tYXJrZXIsIGVuZC5tYXJrZXIsIGNvbnRleHQuY2FsZW5kYXJTeXN0ZW0pO1xuICAgICAgICBpZiAoIWRpZmZTZXZlcml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KHN0YXJ0LCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYmlnZ2VzdFVuaXRGb3JQYXJ0aWFsID0gZGlmZlNldmVyaXR5O1xuICAgICAgICBpZiAoYmlnZ2VzdFVuaXRGb3JQYXJ0aWFsID4gMSAmJiAvLyB0aGUgdHdvIGRhdGVzIGFyZSBkaWZmZXJlbnQgaW4gYSB3YXkgdGhhdCdzIGxhcmdlciBzY2FsZSB0aGFuIHRpbWVcbiAgICAgICAgICAgIChzdGFuZGFyZERhdGVQcm9wcy55ZWFyID09PSAnbnVtZXJpYycgfHwgc3RhbmRhcmREYXRlUHJvcHMueWVhciA9PT0gJzItZGlnaXQnKSAmJlxuICAgICAgICAgICAgKHN0YW5kYXJkRGF0ZVByb3BzLm1vbnRoID09PSAnbnVtZXJpYycgfHwgc3RhbmRhcmREYXRlUHJvcHMubW9udGggPT09ICcyLWRpZ2l0JykgJiZcbiAgICAgICAgICAgIChzdGFuZGFyZERhdGVQcm9wcy5kYXkgPT09ICdudW1lcmljJyB8fCBzdGFuZGFyZERhdGVQcm9wcy5kYXkgPT09ICcyLWRpZ2l0JykpIHtcbiAgICAgICAgICAgIGJpZ2dlc3RVbml0Rm9yUGFydGlhbCA9IDE7IC8vIG1ha2UgaXQgbG9vayBsaWtlIHRoZSBkYXRlcyBhcmUgb25seSBkaWZmZXJlbnQgaW4gdGVybXMgb2YgdGltZVxuICAgICAgICB9XG4gICAgICAgIGxldCBmdWxsMCA9IHRoaXMuZm9ybWF0KHN0YXJ0LCBjb250ZXh0KTtcbiAgICAgICAgbGV0IGZ1bGwxID0gdGhpcy5mb3JtYXQoZW5kLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKGZ1bGwwID09PSBmdWxsMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bGwwO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJ0aWFsRGF0ZVByb3BzID0gY29tcHV0ZVBhcnRpYWxGb3JtYXR0aW5nT3B0aW9ucyhzdGFuZGFyZERhdGVQcm9wcywgYmlnZ2VzdFVuaXRGb3JQYXJ0aWFsKTtcbiAgICAgICAgbGV0IHBhcnRpYWxGb3JtYXR0aW5nRnVuYyA9IGJ1aWxkRm9ybWF0dGluZ0Z1bmMocGFydGlhbERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCk7XG4gICAgICAgIGxldCBwYXJ0aWFsMCA9IHBhcnRpYWxGb3JtYXR0aW5nRnVuYyhzdGFydCk7XG4gICAgICAgIGxldCBwYXJ0aWFsMSA9IHBhcnRpYWxGb3JtYXR0aW5nRnVuYyhlbmQpO1xuICAgICAgICBsZXQgaW5zZXJ0aW9uID0gZmluZENvbW1vbkluc2VydGlvbihmdWxsMCwgcGFydGlhbDAsIGZ1bGwxLCBwYXJ0aWFsMSk7XG4gICAgICAgIGxldCBzZXBhcmF0b3IgPSBleHRlbmRlZFNldHRpbmdzLnNlcGFyYXRvciB8fCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yIHx8IGNvbnRleHQuZGVmYXVsdFNlcGFyYXRvciB8fCAnJztcbiAgICAgICAgaWYgKGluc2VydGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGluc2VydGlvbi5iZWZvcmUgKyBwYXJ0aWFsMCArIHNlcGFyYXRvciArIHBhcnRpYWwxICsgaW5zZXJ0aW9uLmFmdGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdWxsMCArIHNlcGFyYXRvciArIGZ1bGwxO1xuICAgIH1cbiAgICBnZXRMYXJnZXN0VW5pdCgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnNldmVyaXR5KSB7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgcmV0dXJuICd5ZWFyJztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ21vbnRoJztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3dlZWsnO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiAnZGF5JztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICd0aW1lJzsgLy8gcmVhbGx5P1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYnVpbGRGb3JtYXR0aW5nRnVuYyhzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCkge1xuICAgIGxldCBzdGFuZGFyZERhdGVQcm9wQ250ID0gT2JqZWN0LmtleXMoc3RhbmRhcmREYXRlUHJvcHMpLmxlbmd0aDtcbiAgICBpZiAoc3RhbmRhcmREYXRlUHJvcENudCA9PT0gMSAmJiBzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZU5hbWUgPT09ICdzaG9ydCcpIHtcbiAgICAgICAgcmV0dXJuIChkYXRlKSA9PiAoZm9ybWF0VGltZVpvbmVPZmZzZXQoZGF0ZS50aW1lWm9uZU9mZnNldCkpO1xuICAgIH1cbiAgICBpZiAoc3RhbmRhcmREYXRlUHJvcENudCA9PT0gMCAmJiBleHRlbmRlZFNldHRpbmdzLndlZWspIHtcbiAgICAgICAgcmV0dXJuIChkYXRlKSA9PiAoZm9ybWF0V2Vla051bWJlcihjb250ZXh0LmNvbXB1dGVXZWVrTnVtYmVyKGRhdGUubWFya2VyKSwgY29udGV4dC53ZWVrVGV4dCwgY29udGV4dC53ZWVrVGV4dExvbmcsIGNvbnRleHQubG9jYWxlLCBleHRlbmRlZFNldHRpbmdzLndlZWspKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1aWxkTmF0aXZlRm9ybWF0dGluZ0Z1bmMoc3RhbmRhcmREYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MsIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gYnVpbGROYXRpdmVGb3JtYXR0aW5nRnVuYyhzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCkge1xuICAgIHN0YW5kYXJkRGF0ZVByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhbmRhcmREYXRlUHJvcHMpOyAvLyBjb3B5XG4gICAgZXh0ZW5kZWRTZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIGV4dGVuZGVkU2V0dGluZ3MpOyAvLyBjb3B5XG4gICAgc2FuaXRpemVTZXR0aW5ncyhzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncyk7XG4gICAgc3RhbmRhcmREYXRlUHJvcHMudGltZVpvbmUgPSAnVVRDJzsgLy8gd2UgbGV2ZXJhZ2UgdGhlIG9ubHkgZ3VhcmFudGVlZCB0aW1lWm9uZSBmb3Igb3VyIFVUQyBtYXJrZXJzXG4gICAgbGV0IG5vcm1hbEZvcm1hdCA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGNvbnRleHQubG9jYWxlLmNvZGVzLCBzdGFuZGFyZERhdGVQcm9wcyk7XG4gICAgbGV0IHplcm9Gb3JtYXQ7IC8vIG5lZWRlZD9cbiAgICBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5vbWl0WmVyb01pbnV0ZSkge1xuICAgICAgICBsZXQgemVyb1Byb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhbmRhcmREYXRlUHJvcHMpO1xuICAgICAgICBkZWxldGUgemVyb1Byb3BzLm1pbnV0ZTsgLy8gc2Vjb25kcyBhbmQgbXMgd2VyZSBhbHJlYWR5IGNvbnNpZGVyZWQgaW4gc2FuaXRpemVTZXR0aW5nc1xuICAgICAgICB6ZXJvRm9ybWF0ID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoY29udGV4dC5sb2NhbGUuY29kZXMsIHplcm9Qcm9wcyk7XG4gICAgfVxuICAgIHJldHVybiAoZGF0ZSkgPT4ge1xuICAgICAgICBsZXQgeyBtYXJrZXIgfSA9IGRhdGU7XG4gICAgICAgIGxldCBmb3JtYXQ7XG4gICAgICAgIGlmICh6ZXJvRm9ybWF0ICYmICFtYXJrZXIuZ2V0VVRDTWludXRlcygpKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSB6ZXJvRm9ybWF0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9ybWF0ID0gbm9ybWFsRm9ybWF0O1xuICAgICAgICB9XG4gICAgICAgIGxldCBzID0gZm9ybWF0LmZvcm1hdChtYXJrZXIpO1xuICAgICAgICByZXR1cm4gcG9zdFByb2Nlc3MocywgZGF0ZSwgc3RhbmRhcmREYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MsIGNvbnRleHQpO1xuICAgIH07XG59XG5mdW5jdGlvbiBzYW5pdGl6ZVNldHRpbmdzKHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzKSB7XG4gICAgLy8gZGVhbCB3aXRoIGEgYnJvd3NlciBpbmNvbnNpc3RlbmN5IHdoZXJlIGZvcm1hdHRpbmcgdGhlIHRpbWV6b25lXG4gICAgLy8gcmVxdWlyZXMgdGhhdCB0aGUgaG91ci9taW51dGUgYmUgcHJlc2VudC5cbiAgICBpZiAoc3RhbmRhcmREYXRlUHJvcHMudGltZVpvbmVOYW1lKSB7XG4gICAgICAgIGlmICghc3RhbmRhcmREYXRlUHJvcHMuaG91cikge1xuICAgICAgICAgICAgc3RhbmRhcmREYXRlUHJvcHMuaG91ciA9ICcyLWRpZ2l0JztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0YW5kYXJkRGF0ZVByb3BzLm1pbnV0ZSkge1xuICAgICAgICAgICAgc3RhbmRhcmREYXRlUHJvcHMubWludXRlID0gJzItZGlnaXQnO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIG9ubHkgc3VwcG9ydCBzaG9ydCB0aW1lem9uZSBuYW1lc1xuICAgIGlmIChzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZU5hbWUgPT09ICdsb25nJykge1xuICAgICAgICBzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZU5hbWUgPSAnc2hvcnQnO1xuICAgIH1cbiAgICAvLyBpZiByZXF1ZXN0aW5nIHRvIGRpc3BsYXkgc2Vjb25kcywgTVVTVCBkaXNwbGF5IG1pbnV0ZXNcbiAgICBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5vbWl0WmVyb01pbnV0ZSAmJiAoc3RhbmRhcmREYXRlUHJvcHMuc2Vjb25kIHx8IHN0YW5kYXJkRGF0ZVByb3BzLm1pbGxpc2Vjb25kKSkge1xuICAgICAgICBkZWxldGUgZXh0ZW5kZWRTZXR0aW5ncy5vbWl0WmVyb01pbnV0ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBwb3N0UHJvY2VzcyhzLCBkYXRlLCBzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCkge1xuICAgIHMgPSBzLnJlcGxhY2UoTFRSX1JFLCAnJyk7IC8vIHJlbW92ZSBsZWZ0LXRvLXJpZ2h0IGNvbnRyb2wgY2hhcnMuIGRvIGZpcnN0LiBnb29kIGZvciBvdGhlciByZWdleGVzXG4gICAgaWYgKHN0YW5kYXJkRGF0ZVByb3BzLnRpbWVab25lTmFtZSA9PT0gJ3Nob3J0Jykge1xuICAgICAgICBzID0gaW5qZWN0VHpvU3RyKHMsIChjb250ZXh0LnRpbWVab25lID09PSAnVVRDJyB8fCBkYXRlLnRpbWVab25lT2Zmc2V0ID09IG51bGwpID9cbiAgICAgICAgICAgICdVVEMnIDogLy8gaW1wb3J0YW50IHRvIG5vcm1hbGl6ZSBmb3IgSUUsIHdoaWNoIGRvZXMgXCJHTVRcIlxuICAgICAgICAgICAgZm9ybWF0VGltZVpvbmVPZmZzZXQoZGF0ZS50aW1lWm9uZU9mZnNldCkpO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5vbWl0Q29tbWFzKSB7XG4gICAgICAgIHMgPSBzLnJlcGxhY2UoQ09NTUFfUkUsICcnKS50cmltKCk7XG4gICAgfVxuICAgIGlmIChleHRlbmRlZFNldHRpbmdzLm9taXRaZXJvTWludXRlKSB7XG4gICAgICAgIHMgPSBzLnJlcGxhY2UoJzowMCcsICcnKTsgLy8gemVyb0Zvcm1hdCBkb2Vzbid0IGFsd2F5cyBhY2hpZXZlIHRoaXNcbiAgICB9XG4gICAgLy8gXiBkbyBhbnl0aGluZyB0aGF0IG1pZ2h0IGNyZWF0ZSBhZGphY2VudCBzcGFjZXMgYmVmb3JlIHRoaXMgcG9pbnQsXG4gICAgLy8gYmVjYXVzZSBNRVJJRElFTV9SRSBsaWtlcyB0byBlYXQgdXAgbG9hZGluZyBzcGFjZXNcbiAgICBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5tZXJpZGllbSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcyA9IHMucmVwbGFjZShNRVJJRElFTV9SRSwgJycpLnRyaW0oKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5tZXJpZGllbSA9PT0gJ25hcnJvdycpIHsgLy8gYS9wXG4gICAgICAgIHMgPSBzLnJlcGxhY2UoTUVSSURJRU1fUkUsIChtMCwgbTEpID0+IG0xLnRvTG9jYWxlTG93ZXJDYXNlKCkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHRlbmRlZFNldHRpbmdzLm1lcmlkaWVtID09PSAnc2hvcnQnKSB7IC8vIGFtL3BtXG4gICAgICAgIHMgPSBzLnJlcGxhY2UoTUVSSURJRU1fUkUsIChtMCwgbTEpID0+IGAke20xLnRvTG9jYWxlTG93ZXJDYXNlKCl9bWApO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHRlbmRlZFNldHRpbmdzLm1lcmlkaWVtID09PSAnbG93ZXJjYXNlJykgeyAvLyBvdGhlciBtZXJpZGllbSB0cmFuc2Zvcm1lcnMgYWxyZWFkeSBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlXG4gICAgICAgIHMgPSBzLnJlcGxhY2UoTUVSSURJRU1fUkUsIChtMCkgPT4gbTAudG9Mb2NhbGVMb3dlckNhc2UoKSk7XG4gICAgfVxuICAgIHMgPSBzLnJlcGxhY2UoTVVMVElfU1BBQ0VfUkUsICcgJyk7XG4gICAgcyA9IHMudHJpbSgpO1xuICAgIHJldHVybiBzO1xufVxuZnVuY3Rpb24gaW5qZWN0VHpvU3RyKHMsIHR6b1N0cikge1xuICAgIGxldCByZXBsYWNlZCA9IGZhbHNlO1xuICAgIHMgPSBzLnJlcGxhY2UoVVRDX1JFLCAoKSA9PiB7XG4gICAgICAgIHJlcGxhY2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHR6b1N0cjtcbiAgICB9KTtcbiAgICAvLyBJRTExIGRvZXNuJ3QgaW5jbHVkZSBVVEMvR01UIGluIHRoZSBvcmlnaW5hbCBzdHJpbmcsIHNvIGFwcGVuZCB0byBlbmRcbiAgICBpZiAoIXJlcGxhY2VkKSB7XG4gICAgICAgIHMgKz0gYCAke3R6b1N0cn1gO1xuICAgIH1cbiAgICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIGZvcm1hdFdlZWtOdW1iZXIobnVtLCB3ZWVrVGV4dCwgd2Vla1RleHRMb25nLCBsb2NhbGUsIGRpc3BsYXkpIHtcbiAgICBsZXQgcGFydHMgPSBbXTtcbiAgICBpZiAoZGlzcGxheSA9PT0gJ2xvbmcnKSB7XG4gICAgICAgIHBhcnRzLnB1c2god2Vla1RleHRMb25nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGlzcGxheSA9PT0gJ3Nob3J0JyB8fCBkaXNwbGF5ID09PSAnbmFycm93Jykge1xuICAgICAgICBwYXJ0cy5wdXNoKHdlZWtUZXh0KTtcbiAgICB9XG4gICAgaWYgKGRpc3BsYXkgPT09ICdsb25nJyB8fCBkaXNwbGF5ID09PSAnc2hvcnQnKSB7XG4gICAgICAgIHBhcnRzLnB1c2goJyAnKTtcbiAgICB9XG4gICAgcGFydHMucHVzaChsb2NhbGUuc2ltcGxlTnVtYmVyRm9ybWF0LmZvcm1hdChudW0pKTtcbiAgICBpZiAobG9jYWxlLm9wdGlvbnMuZGlyZWN0aW9uID09PSAncnRsJykgeyAvLyBUT0RPOiB1c2UgY29udHJvbCBjaGFyYWN0ZXJzIGluc3RlYWQ/XG4gICAgICAgIHBhcnRzLnJldmVyc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oJycpO1xufVxuLy8gUmFuZ2UgRm9ybWF0dGluZyBVdGlsc1xuLy8gMCA9IGV4YWN0bHkgdGhlIHNhbWVcbi8vIDEgPSBkaWZmZXJlbnQgYnkgdGltZVxuLy8gYW5kIGJpZ2dlclxuZnVuY3Rpb24gY29tcHV0ZU1hcmtlckRpZmZTZXZlcml0eShkMCwgZDEsIGNhKSB7XG4gICAgaWYgKGNhLmdldE1hcmtlclllYXIoZDApICE9PSBjYS5nZXRNYXJrZXJZZWFyKGQxKSkge1xuICAgICAgICByZXR1cm4gNTtcbiAgICB9XG4gICAgaWYgKGNhLmdldE1hcmtlck1vbnRoKGQwKSAhPT0gY2EuZ2V0TWFya2VyTW9udGgoZDEpKSB7XG4gICAgICAgIHJldHVybiA0O1xuICAgIH1cbiAgICBpZiAoY2EuZ2V0TWFya2VyRGF5KGQwKSAhPT0gY2EuZ2V0TWFya2VyRGF5KGQxKSkge1xuICAgICAgICByZXR1cm4gMjtcbiAgICB9XG4gICAgaWYgKHRpbWVBc01zKGQwKSAhPT0gdGltZUFzTXMoZDEpKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVQYXJ0aWFsRm9ybWF0dGluZ09wdGlvbnMob3B0aW9ucywgYmlnZ2VzdFVuaXQpIHtcbiAgICBsZXQgcGFydGlhbE9wdGlvbnMgPSB7fTtcbiAgICBmb3IgKGxldCBuYW1lIGluIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCEobmFtZSBpbiBTVEFOREFSRF9EQVRFX1BST1BfU0VWRVJJVElFUykgfHwgLy8gbm90IGEgZGF0ZSBwYXJ0IHByb3AgKGxpa2UgdGltZVpvbmUpXG4gICAgICAgICAgICBTVEFOREFSRF9EQVRFX1BST1BfU0VWRVJJVElFU1tuYW1lXSA8PSBiaWdnZXN0VW5pdCkge1xuICAgICAgICAgICAgcGFydGlhbE9wdGlvbnNbbmFtZV0gPSBvcHRpb25zW25hbWVdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJ0aWFsT3B0aW9ucztcbn1cbmZ1bmN0aW9uIGZpbmRDb21tb25JbnNlcnRpb24oZnVsbDAsIHBhcnRpYWwwLCBmdWxsMSwgcGFydGlhbDEpIHtcbiAgICBsZXQgaTAgPSAwO1xuICAgIHdoaWxlIChpMCA8IGZ1bGwwLmxlbmd0aCkge1xuICAgICAgICBsZXQgZm91bmQwID0gZnVsbDAuaW5kZXhPZihwYXJ0aWFsMCwgaTApO1xuICAgICAgICBpZiAoZm91bmQwID09PSAtMSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJlZm9yZTAgPSBmdWxsMC5zdWJzdHIoMCwgZm91bmQwKTtcbiAgICAgICAgaTAgPSBmb3VuZDAgKyBwYXJ0aWFsMC5sZW5ndGg7XG4gICAgICAgIGxldCBhZnRlcjAgPSBmdWxsMC5zdWJzdHIoaTApO1xuICAgICAgICBsZXQgaTEgPSAwO1xuICAgICAgICB3aGlsZSAoaTEgPCBmdWxsMS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBmb3VuZDEgPSBmdWxsMS5pbmRleE9mKHBhcnRpYWwxLCBpMSk7XG4gICAgICAgICAgICBpZiAoZm91bmQxID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGJlZm9yZTEgPSBmdWxsMS5zdWJzdHIoMCwgZm91bmQxKTtcbiAgICAgICAgICAgIGkxID0gZm91bmQxICsgcGFydGlhbDEubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGFmdGVyMSA9IGZ1bGwxLnN1YnN0cihpMSk7XG4gICAgICAgICAgICBpZiAoYmVmb3JlMCA9PT0gYmVmb3JlMSAmJiBhZnRlcjAgPT09IGFmdGVyMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZTogYmVmb3JlMCxcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXI6IGFmdGVyMCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBleHBhbmRab25lZE1hcmtlcihkYXRlSW5mbywgY2FsZW5kYXJTeXN0ZW0pIHtcbiAgICBsZXQgYSA9IGNhbGVuZGFyU3lzdGVtLm1hcmtlclRvQXJyYXkoZGF0ZUluZm8ubWFya2VyKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBtYXJrZXI6IGRhdGVJbmZvLm1hcmtlcixcbiAgICAgICAgdGltZVpvbmVPZmZzZXQ6IGRhdGVJbmZvLnRpbWVab25lT2Zmc2V0LFxuICAgICAgICBhcnJheTogYSxcbiAgICAgICAgeWVhcjogYVswXSxcbiAgICAgICAgbW9udGg6IGFbMV0sXG4gICAgICAgIGRheTogYVsyXSxcbiAgICAgICAgaG91cjogYVszXSxcbiAgICAgICAgbWludXRlOiBhWzRdLFxuICAgICAgICBzZWNvbmQ6IGFbNV0sXG4gICAgICAgIG1pbGxpc2Vjb25kOiBhWzZdLFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVZlcmJvc2VGb3JtYXR0aW5nQXJnKHN0YXJ0LCBlbmQsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpIHtcbiAgICBsZXQgc3RhcnRJbmZvID0gZXhwYW5kWm9uZWRNYXJrZXIoc3RhcnQsIGNvbnRleHQuY2FsZW5kYXJTeXN0ZW0pO1xuICAgIGxldCBlbmRJbmZvID0gZW5kID8gZXhwYW5kWm9uZWRNYXJrZXIoZW5kLCBjb250ZXh0LmNhbGVuZGFyU3lzdGVtKSA6IG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGF0ZTogc3RhcnRJbmZvLFxuICAgICAgICBzdGFydDogc3RhcnRJbmZvLFxuICAgICAgICBlbmQ6IGVuZEluZm8sXG4gICAgICAgIHRpbWVab25lOiBjb250ZXh0LnRpbWVab25lLFxuICAgICAgICBsb2NhbGVDb2RlczogY29udGV4dC5sb2NhbGUuY29kZXMsXG4gICAgICAgIGRlZmF1bHRTZXBhcmF0b3I6IGJldHRlckRlZmF1bHRTZXBhcmF0b3IgfHwgY29udGV4dC5kZWZhdWx0U2VwYXJhdG9yLFxuICAgIH07XG59XG5cbi8qXG5UT0RPOiBmaXggdGhlIHRlcm1pbm9sb2d5IG9mIFwiZm9ybWF0dGVyXCIgdnMgXCJmb3JtYXR0aW5nIGZ1bmNcIlxuKi9cbi8qXG5BdCB0aGUgdGltZSBvZiBpbnN0YW50aWF0aW9uLCB0aGlzIG9iamVjdCBkb2VzIG5vdCBrbm93IHdoaWNoIGNtZC1mb3JtYXR0aW5nIHN5c3RlbSBpdCB3aWxsIHVzZS5cbkl0IHJlY2VpdmVzIHRoaXMgYXQgdGhlIHRpbWUgb2YgZm9ybWF0dGluZywgYXMgYSBzZXR0aW5nLlxuKi9cbmNsYXNzIENtZEZvcm1hdHRlciB7XG4gICAgY29uc3RydWN0b3IoY21kU3RyKSB7XG4gICAgICAgIHRoaXMuY21kU3RyID0gY21kU3RyO1xuICAgIH1cbiAgICBmb3JtYXQoZGF0ZSwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gY29udGV4dC5jbWRGb3JtYXR0ZXIodGhpcy5jbWRTdHIsIGNyZWF0ZVZlcmJvc2VGb3JtYXR0aW5nQXJnKGRhdGUsIG51bGwsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpKTtcbiAgICB9XG4gICAgZm9ybWF0UmFuZ2Uoc3RhcnQsIGVuZCwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gY29udGV4dC5jbWRGb3JtYXR0ZXIodGhpcy5jbWRTdHIsIGNyZWF0ZVZlcmJvc2VGb3JtYXR0aW5nQXJnKHN0YXJ0LCBlbmQsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpKTtcbiAgICB9XG59XG5cbmNsYXNzIEZ1bmNGb3JtYXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGZ1bmMpIHtcbiAgICAgICAgdGhpcy5mdW5jID0gZnVuYztcbiAgICB9XG4gICAgZm9ybWF0KGRhdGUsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnVuYyhjcmVhdGVWZXJib3NlRm9ybWF0dGluZ0FyZyhkYXRlLCBudWxsLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSk7XG4gICAgfVxuICAgIGZvcm1hdFJhbmdlKHN0YXJ0LCBlbmQsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnVuYyhjcmVhdGVWZXJib3NlRm9ybWF0dGluZ0FyZyhzdGFydCwgZW5kLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVGb3JtYXR0ZXIoaW5wdXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiBpbnB1dCkgeyAvLyBub24tbnVsbCBvYmplY3RcbiAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVGb3JtYXR0ZXIoaW5wdXQpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gbmV3IENtZEZvcm1hdHRlcihpbnB1dCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jRm9ybWF0dGVyKGlucHV0KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbi8vIGJhc2Ugb3B0aW9uc1xuLy8gLS0tLS0tLS0tLS0tXG5jb25zdCBCQVNFX09QVElPTl9SRUZJTkVSUyA9IHtcbiAgICBuYXZMaW5rRGF5Q2xpY2s6IGlkZW50aXR5LFxuICAgIG5hdkxpbmtXZWVrQ2xpY2s6IGlkZW50aXR5LFxuICAgIGR1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBib290c3RyYXBGb250QXdlc29tZTogaWRlbnRpdHksXG4gICAgYnV0dG9uSWNvbnM6IGlkZW50aXR5LFxuICAgIGN1c3RvbUJ1dHRvbnM6IGlkZW50aXR5LFxuICAgIGRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBkZWZhdWx0VGltZWRFdmVudER1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBuZXh0RGF5VGhyZXNob2xkOiBjcmVhdGVEdXJhdGlvbixcbiAgICBzY3JvbGxUaW1lOiBjcmVhdGVEdXJhdGlvbixcbiAgICBzY3JvbGxUaW1lUmVzZXQ6IEJvb2xlYW4sXG4gICAgc2xvdE1pblRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxuICAgIHNsb3RNYXhUaW1lOiBjcmVhdGVEdXJhdGlvbixcbiAgICBkYXlQb3BvdmVyRm9ybWF0OiBjcmVhdGVGb3JtYXR0ZXIsXG4gICAgc2xvdER1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBzbmFwRHVyYXRpb246IGNyZWF0ZUR1cmF0aW9uLFxuICAgIGhlYWRlclRvb2xiYXI6IGlkZW50aXR5LFxuICAgIGZvb3RlclRvb2xiYXI6IGlkZW50aXR5LFxuICAgIGRlZmF1bHRSYW5nZVNlcGFyYXRvcjogU3RyaW5nLFxuICAgIHRpdGxlUmFuZ2VTZXBhcmF0b3I6IFN0cmluZyxcbiAgICBmb3JjZUV2ZW50RHVyYXRpb246IEJvb2xlYW4sXG4gICAgZGF5SGVhZGVyczogQm9vbGVhbixcbiAgICBkYXlIZWFkZXJGb3JtYXQ6IGNyZWF0ZUZvcm1hdHRlcixcbiAgICBkYXlIZWFkZXJDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBkYXlIZWFkZXJDb250ZW50OiBpZGVudGl0eSxcbiAgICBkYXlIZWFkZXJEaWRNb3VudDogaWRlbnRpdHksXG4gICAgZGF5SGVhZGVyV2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIGRheUNlbGxDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBkYXlDZWxsQ29udGVudDogaWRlbnRpdHksXG4gICAgZGF5Q2VsbERpZE1vdW50OiBpZGVudGl0eSxcbiAgICBkYXlDZWxsV2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIGluaXRpYWxWaWV3OiBTdHJpbmcsXG4gICAgYXNwZWN0UmF0aW86IE51bWJlcixcbiAgICB3ZWVrZW5kczogQm9vbGVhbixcbiAgICB3ZWVrTnVtYmVyQ2FsY3VsYXRpb246IGlkZW50aXR5LFxuICAgIHdlZWtOdW1iZXJzOiBCb29sZWFuLFxuICAgIHdlZWtOdW1iZXJDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICB3ZWVrTnVtYmVyQ29udGVudDogaWRlbnRpdHksXG4gICAgd2Vla051bWJlckRpZE1vdW50OiBpZGVudGl0eSxcbiAgICB3ZWVrTnVtYmVyV2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIGVkaXRhYmxlOiBCb29sZWFuLFxuICAgIHZpZXdDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICB2aWV3RGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIHZpZXdXaWxsVW5tb3VudDogaWRlbnRpdHksXG4gICAgbm93SW5kaWNhdG9yOiBCb29sZWFuLFxuICAgIG5vd0luZGljYXRvckNsYXNzTmFtZXM6IGlkZW50aXR5LFxuICAgIG5vd0luZGljYXRvckNvbnRlbnQ6IGlkZW50aXR5LFxuICAgIG5vd0luZGljYXRvckRpZE1vdW50OiBpZGVudGl0eSxcbiAgICBub3dJbmRpY2F0b3JXaWxsVW5tb3VudDogaWRlbnRpdHksXG4gICAgc2hvd05vbkN1cnJlbnREYXRlczogQm9vbGVhbixcbiAgICBsYXp5RmV0Y2hpbmc6IEJvb2xlYW4sXG4gICAgc3RhcnRQYXJhbTogU3RyaW5nLFxuICAgIGVuZFBhcmFtOiBTdHJpbmcsXG4gICAgdGltZVpvbmVQYXJhbTogU3RyaW5nLFxuICAgIHRpbWVab25lOiBTdHJpbmcsXG4gICAgbG9jYWxlczogaWRlbnRpdHksXG4gICAgbG9jYWxlOiBpZGVudGl0eSxcbiAgICB0aGVtZVN5c3RlbTogU3RyaW5nLFxuICAgIGRyYWdSZXZlcnREdXJhdGlvbjogTnVtYmVyLFxuICAgIGRyYWdTY3JvbGw6IEJvb2xlYW4sXG4gICAgYWxsRGF5TWFpbnRhaW5EdXJhdGlvbjogQm9vbGVhbixcbiAgICB1bnNlbGVjdEF1dG86IEJvb2xlYW4sXG4gICAgZHJvcEFjY2VwdDogaWRlbnRpdHksXG4gICAgZXZlbnRPcmRlcjogcGFyc2VGaWVsZFNwZWNzLFxuICAgIGV2ZW50T3JkZXJTdHJpY3Q6IEJvb2xlYW4sXG4gICAgaGFuZGxlV2luZG93UmVzaXplOiBCb29sZWFuLFxuICAgIHdpbmRvd1Jlc2l6ZURlbGF5OiBOdW1iZXIsXG4gICAgbG9uZ1ByZXNzRGVsYXk6IE51bWJlcixcbiAgICBldmVudERyYWdNaW5EaXN0YW5jZTogTnVtYmVyLFxuICAgIGV4cGFuZFJvd3M6IEJvb2xlYW4sXG4gICAgaGVpZ2h0OiBpZGVudGl0eSxcbiAgICBjb250ZW50SGVpZ2h0OiBpZGVudGl0eSxcbiAgICBkaXJlY3Rpb246IFN0cmluZyxcbiAgICB3ZWVrTnVtYmVyRm9ybWF0OiBjcmVhdGVGb3JtYXR0ZXIsXG4gICAgZXZlbnRSZXNpemFibGVGcm9tU3RhcnQ6IEJvb2xlYW4sXG4gICAgZGlzcGxheUV2ZW50VGltZTogQm9vbGVhbixcbiAgICBkaXNwbGF5RXZlbnRFbmQ6IEJvb2xlYW4sXG4gICAgd2Vla1RleHQ6IFN0cmluZyxcbiAgICB3ZWVrVGV4dExvbmc6IFN0cmluZyxcbiAgICBwcm9ncmVzc2l2ZUV2ZW50UmVuZGVyaW5nOiBCb29sZWFuLFxuICAgIGJ1c2luZXNzSG91cnM6IGlkZW50aXR5LFxuICAgIGluaXRpYWxEYXRlOiBpZGVudGl0eSxcbiAgICBub3c6IGlkZW50aXR5LFxuICAgIGV2ZW50RGF0YVRyYW5zZm9ybTogaWRlbnRpdHksXG4gICAgc3RpY2t5SGVhZGVyRGF0ZXM6IGlkZW50aXR5LFxuICAgIHN0aWNreUZvb3RlclNjcm9sbGJhcjogaWRlbnRpdHksXG4gICAgdmlld0hlaWdodDogaWRlbnRpdHksXG4gICAgZGVmYXVsdEFsbERheTogQm9vbGVhbixcbiAgICBldmVudFNvdXJjZUZhaWx1cmU6IGlkZW50aXR5LFxuICAgIGV2ZW50U291cmNlU3VjY2VzczogaWRlbnRpdHksXG4gICAgZXZlbnREaXNwbGF5OiBTdHJpbmcsXG4gICAgZXZlbnRTdGFydEVkaXRhYmxlOiBCb29sZWFuLFxuICAgIGV2ZW50RHVyYXRpb25FZGl0YWJsZTogQm9vbGVhbixcbiAgICBldmVudE92ZXJsYXA6IGlkZW50aXR5LFxuICAgIGV2ZW50Q29uc3RyYWludDogaWRlbnRpdHksXG4gICAgZXZlbnRBbGxvdzogaWRlbnRpdHksXG4gICAgZXZlbnRCYWNrZ3JvdW5kQ29sb3I6IFN0cmluZyxcbiAgICBldmVudEJvcmRlckNvbG9yOiBTdHJpbmcsXG4gICAgZXZlbnRUZXh0Q29sb3I6IFN0cmluZyxcbiAgICBldmVudENvbG9yOiBTdHJpbmcsXG4gICAgZXZlbnRDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBldmVudENvbnRlbnQ6IGlkZW50aXR5LFxuICAgIGV2ZW50RGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIGV2ZW50V2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIHNlbGVjdENvbnN0cmFpbnQ6IGlkZW50aXR5LFxuICAgIHNlbGVjdE92ZXJsYXA6IGlkZW50aXR5LFxuICAgIHNlbGVjdEFsbG93OiBpZGVudGl0eSxcbiAgICBkcm9wcGFibGU6IEJvb2xlYW4sXG4gICAgdW5zZWxlY3RDYW5jZWw6IFN0cmluZyxcbiAgICBzbG90TGFiZWxGb3JtYXQ6IGlkZW50aXR5LFxuICAgIHNsb3RMYW5lQ2xhc3NOYW1lczogaWRlbnRpdHksXG4gICAgc2xvdExhbmVDb250ZW50OiBpZGVudGl0eSxcbiAgICBzbG90TGFuZURpZE1vdW50OiBpZGVudGl0eSxcbiAgICBzbG90TGFuZVdpbGxVbm1vdW50OiBpZGVudGl0eSxcbiAgICBzbG90TGFiZWxDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBzbG90TGFiZWxDb250ZW50OiBpZGVudGl0eSxcbiAgICBzbG90TGFiZWxEaWRNb3VudDogaWRlbnRpdHksXG4gICAgc2xvdExhYmVsV2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIGRheU1heEV2ZW50czogaWRlbnRpdHksXG4gICAgZGF5TWF4RXZlbnRSb3dzOiBpZGVudGl0eSxcbiAgICBkYXlNaW5XaWR0aDogTnVtYmVyLFxuICAgIHNsb3RMYWJlbEludGVydmFsOiBjcmVhdGVEdXJhdGlvbixcbiAgICBhbGxEYXlUZXh0OiBTdHJpbmcsXG4gICAgYWxsRGF5Q2xhc3NOYW1lczogaWRlbnRpdHksXG4gICAgYWxsRGF5Q29udGVudDogaWRlbnRpdHksXG4gICAgYWxsRGF5RGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIGFsbERheVdpbGxVbm1vdW50OiBpZGVudGl0eSxcbiAgICBzbG90TWluV2lkdGg6IE51bWJlcixcbiAgICBuYXZMaW5rczogQm9vbGVhbixcbiAgICBldmVudFRpbWVGb3JtYXQ6IGNyZWF0ZUZvcm1hdHRlcixcbiAgICByZXJlbmRlckRlbGF5OiBOdW1iZXIsXG4gICAgbW9yZUxpbmtUZXh0OiBpZGVudGl0eSxcbiAgICBtb3JlTGlua0hpbnQ6IGlkZW50aXR5LFxuICAgIHNlbGVjdE1pbkRpc3RhbmNlOiBOdW1iZXIsXG4gICAgc2VsZWN0YWJsZTogQm9vbGVhbixcbiAgICBzZWxlY3RMb25nUHJlc3NEZWxheTogTnVtYmVyLFxuICAgIGV2ZW50TG9uZ1ByZXNzRGVsYXk6IE51bWJlcixcbiAgICBzZWxlY3RNaXJyb3I6IEJvb2xlYW4sXG4gICAgZXZlbnRNYXhTdGFjazogTnVtYmVyLFxuICAgIGV2ZW50TWluSGVpZ2h0OiBOdW1iZXIsXG4gICAgZXZlbnRNaW5XaWR0aDogTnVtYmVyLFxuICAgIGV2ZW50U2hvcnRIZWlnaHQ6IE51bWJlcixcbiAgICBzbG90RXZlbnRPdmVybGFwOiBCb29sZWFuLFxuICAgIHBsdWdpbnM6IGlkZW50aXR5LFxuICAgIGZpcnN0RGF5OiBOdW1iZXIsXG4gICAgZGF5Q291bnQ6IE51bWJlcixcbiAgICBkYXRlQWxpZ25tZW50OiBTdHJpbmcsXG4gICAgZGF0ZUluY3JlbWVudDogY3JlYXRlRHVyYXRpb24sXG4gICAgaGlkZGVuRGF5czogaWRlbnRpdHksXG4gICAgZml4ZWRXZWVrQ291bnQ6IEJvb2xlYW4sXG4gICAgdmFsaWRSYW5nZTogaWRlbnRpdHksXG4gICAgdmlzaWJsZVJhbmdlOiBpZGVudGl0eSxcbiAgICB0aXRsZUZvcm1hdDogaWRlbnRpdHksXG4gICAgZXZlbnRJbnRlcmFjdGl2ZTogQm9vbGVhbixcbiAgICAvLyBvbmx5IHVzZWQgYnkgbGlzdC12aWV3LCBidXQgbGFuZ3VhZ2VzIGRlZmluZSB0aGUgdmFsdWUsIHNvIHdlIG5lZWQgaXQgaW4gYmFzZSBvcHRpb25zXG4gICAgbm9FdmVudHNUZXh0OiBTdHJpbmcsXG4gICAgdmlld0hpbnQ6IGlkZW50aXR5LFxuICAgIG5hdkxpbmtIaW50OiBpZGVudGl0eSxcbiAgICBjbG9zZUhpbnQ6IFN0cmluZyxcbiAgICB0aW1lSGludDogU3RyaW5nLFxuICAgIGV2ZW50SGludDogU3RyaW5nLFxuICAgIG1vcmVMaW5rQ2xpY2s6IGlkZW50aXR5LFxuICAgIG1vcmVMaW5rQ2xhc3NOYW1lczogaWRlbnRpdHksXG4gICAgbW9yZUxpbmtDb250ZW50OiBpZGVudGl0eSxcbiAgICBtb3JlTGlua0RpZE1vdW50OiBpZGVudGl0eSxcbiAgICBtb3JlTGlua1dpbGxVbm1vdW50OiBpZGVudGl0eSxcbiAgICBtb250aFN0YXJ0Rm9ybWF0OiBjcmVhdGVGb3JtYXR0ZXIsXG4gICAgLy8gZm9yIGNvbm5lY3RvcnNcbiAgICAvLyAoY2FuJ3QgYmUgcGFydCBvZiBwbHVnaW4gc3lzdGVtIGIvYyBtdXN0IGJlIHByb3ZpZGVkIGF0IHJ1bnRpbWUpXG4gICAgaGFuZGxlQ3VzdG9tUmVuZGVyaW5nOiBpZGVudGl0eSxcbiAgICBjdXN0b21SZW5kZXJpbmdNZXRhTWFwOiBpZGVudGl0eSxcbiAgICBjdXN0b21SZW5kZXJpbmdSZXBsYWNlczogQm9vbGVhbixcbn07XG4vLyBkbyBOT1QgZ2l2ZSBhIHR5cGUgaGVyZS4gbmVlZCBgdHlwZW9mIEJBU0VfT1BUSU9OX0RFRkFVTFRTYCB0byBnaXZlIHJlYWwgcmVzdWx0cy5cbi8vIHJhdyB2YWx1ZXMuXG5jb25zdCBCQVNFX09QVElPTl9ERUZBVUxUUyA9IHtcbiAgICBldmVudERpc3BsYXk6ICdhdXRvJyxcbiAgICBkZWZhdWx0UmFuZ2VTZXBhcmF0b3I6ICcgLSAnLFxuICAgIHRpdGxlUmFuZ2VTZXBhcmF0b3I6ICcgXFx1MjAxMyAnLFxuICAgIGRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb246ICcwMTowMDowMCcsXG4gICAgZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb246IHsgZGF5OiAxIH0sXG4gICAgZm9yY2VFdmVudER1cmF0aW9uOiBmYWxzZSxcbiAgICBuZXh0RGF5VGhyZXNob2xkOiAnMDA6MDA6MDAnLFxuICAgIGRheUhlYWRlcnM6IHRydWUsXG4gICAgaW5pdGlhbFZpZXc6ICcnLFxuICAgIGFzcGVjdFJhdGlvOiAxLjM1LFxuICAgIGhlYWRlclRvb2xiYXI6IHtcbiAgICAgICAgc3RhcnQ6ICd0aXRsZScsXG4gICAgICAgIGNlbnRlcjogJycsXG4gICAgICAgIGVuZDogJ3RvZGF5IHByZXYsbmV4dCcsXG4gICAgfSxcbiAgICB3ZWVrZW5kczogdHJ1ZSxcbiAgICB3ZWVrTnVtYmVyczogZmFsc2UsXG4gICAgd2Vla051bWJlckNhbGN1bGF0aW9uOiAnbG9jYWwnLFxuICAgIGVkaXRhYmxlOiBmYWxzZSxcbiAgICBub3dJbmRpY2F0b3I6IGZhbHNlLFxuICAgIHNjcm9sbFRpbWU6ICcwNjowMDowMCcsXG4gICAgc2Nyb2xsVGltZVJlc2V0OiB0cnVlLFxuICAgIHNsb3RNaW5UaW1lOiAnMDA6MDA6MDAnLFxuICAgIHNsb3RNYXhUaW1lOiAnMjQ6MDA6MDAnLFxuICAgIHNob3dOb25DdXJyZW50RGF0ZXM6IHRydWUsXG4gICAgbGF6eUZldGNoaW5nOiB0cnVlLFxuICAgIHN0YXJ0UGFyYW06ICdzdGFydCcsXG4gICAgZW5kUGFyYW06ICdlbmQnLFxuICAgIHRpbWVab25lUGFyYW06ICd0aW1lWm9uZScsXG4gICAgdGltZVpvbmU6ICdsb2NhbCcsXG4gICAgbG9jYWxlczogW10sXG4gICAgbG9jYWxlOiAnJyxcbiAgICB0aGVtZVN5c3RlbTogJ3N0YW5kYXJkJyxcbiAgICBkcmFnUmV2ZXJ0RHVyYXRpb246IDUwMCxcbiAgICBkcmFnU2Nyb2xsOiB0cnVlLFxuICAgIGFsbERheU1haW50YWluRHVyYXRpb246IGZhbHNlLFxuICAgIHVuc2VsZWN0QXV0bzogdHJ1ZSxcbiAgICBkcm9wQWNjZXB0OiAnKicsXG4gICAgZXZlbnRPcmRlcjogJ3N0YXJ0LC1kdXJhdGlvbixhbGxEYXksdGl0bGUnLFxuICAgIGRheVBvcG92ZXJGb3JtYXQ6IHsgbW9udGg6ICdsb25nJywgZGF5OiAnbnVtZXJpYycsIHllYXI6ICdudW1lcmljJyB9LFxuICAgIGhhbmRsZVdpbmRvd1Jlc2l6ZTogdHJ1ZSxcbiAgICB3aW5kb3dSZXNpemVEZWxheTogMTAwLFxuICAgIGxvbmdQcmVzc0RlbGF5OiAxMDAwLFxuICAgIGV2ZW50RHJhZ01pbkRpc3RhbmNlOiA1LFxuICAgIGV4cGFuZFJvd3M6IGZhbHNlLFxuICAgIG5hdkxpbmtzOiBmYWxzZSxcbiAgICBzZWxlY3RhYmxlOiBmYWxzZSxcbiAgICBldmVudE1pbkhlaWdodDogMTUsXG4gICAgZXZlbnRNaW5XaWR0aDogMzAsXG4gICAgZXZlbnRTaG9ydEhlaWdodDogMzAsXG4gICAgbW9udGhTdGFydEZvcm1hdDogeyBtb250aDogJ2xvbmcnLCBkYXk6ICdudW1lcmljJyB9LFxufTtcbi8vIGNhbGVuZGFyIGxpc3RlbmVyc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG5jb25zdCBDQUxFTkRBUl9MSVNURU5FUl9SRUZJTkVSUyA9IHtcbiAgICBkYXRlc1NldDogaWRlbnRpdHksXG4gICAgZXZlbnRzU2V0OiBpZGVudGl0eSxcbiAgICBldmVudEFkZDogaWRlbnRpdHksXG4gICAgZXZlbnRDaGFuZ2U6IGlkZW50aXR5LFxuICAgIGV2ZW50UmVtb3ZlOiBpZGVudGl0eSxcbiAgICB3aW5kb3dSZXNpemU6IGlkZW50aXR5LFxuICAgIGV2ZW50Q2xpY2s6IGlkZW50aXR5LFxuICAgIGV2ZW50TW91c2VFbnRlcjogaWRlbnRpdHksXG4gICAgZXZlbnRNb3VzZUxlYXZlOiBpZGVudGl0eSxcbiAgICBzZWxlY3Q6IGlkZW50aXR5LFxuICAgIHVuc2VsZWN0OiBpZGVudGl0eSxcbiAgICBsb2FkaW5nOiBpZGVudGl0eSxcbiAgICAvLyBpbnRlcm5hbFxuICAgIF91bm1vdW50OiBpZGVudGl0eSxcbiAgICBfYmVmb3JlcHJpbnQ6IGlkZW50aXR5LFxuICAgIF9hZnRlcnByaW50OiBpZGVudGl0eSxcbiAgICBfbm9FdmVudERyb3A6IGlkZW50aXR5LFxuICAgIF9ub0V2ZW50UmVzaXplOiBpZGVudGl0eSxcbiAgICBfcmVzaXplOiBpZGVudGl0eSxcbiAgICBfc2Nyb2xsUmVxdWVzdDogaWRlbnRpdHksXG59O1xuLy8gY2FsZW5kYXItc3BlY2lmaWMgb3B0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuY29uc3QgQ0FMRU5EQVJfT1BUSU9OX1JFRklORVJTID0ge1xuICAgIGJ1dHRvblRleHQ6IGlkZW50aXR5LFxuICAgIGJ1dHRvbkhpbnRzOiBpZGVudGl0eSxcbiAgICB2aWV3czogaWRlbnRpdHksXG4gICAgcGx1Z2luczogaWRlbnRpdHksXG4gICAgaW5pdGlhbEV2ZW50czogaWRlbnRpdHksXG4gICAgZXZlbnRzOiBpZGVudGl0eSxcbiAgICBldmVudFNvdXJjZXM6IGlkZW50aXR5LFxufTtcbmNvbnN0IENPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTID0ge1xuICAgIGhlYWRlclRvb2xiYXI6IGlzTWF5YmVPYmplY3RzRXF1YWwsXG4gICAgZm9vdGVyVG9vbGJhcjogaXNNYXliZU9iamVjdHNFcXVhbCxcbiAgICBidXR0b25UZXh0OiBpc01heWJlT2JqZWN0c0VxdWFsLFxuICAgIGJ1dHRvbkhpbnRzOiBpc01heWJlT2JqZWN0c0VxdWFsLFxuICAgIGJ1dHRvbkljb25zOiBpc01heWJlT2JqZWN0c0VxdWFsLFxuICAgIGRhdGVJbmNyZW1lbnQ6IGlzTWF5YmVPYmplY3RzRXF1YWwsXG4gICAgcGx1Z2luczogaXNNYXliZUFycmF5c0VxdWFsLFxuICAgIGV2ZW50czogaXNNYXliZUFycmF5c0VxdWFsLFxuICAgIGV2ZW50U291cmNlczogaXNNYXliZUFycmF5c0VxdWFsLFxuICAgIFsncmVzb3VyY2VzJ106IGlzTWF5YmVBcnJheXNFcXVhbCxcbn07XG5mdW5jdGlvbiBpc01heWJlT2JqZWN0c0VxdWFsKGEsIGIpIHtcbiAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnICYmIHR5cGVvZiBiID09PSAnb2JqZWN0JyAmJiBhICYmIGIpIHsgLy8gYm90aCBub24tbnVsbCBvYmplY3RzXG4gICAgICAgIHJldHVybiBpc1Byb3BzRXF1YWwoYSwgYik7XG4gICAgfVxuICAgIHJldHVybiBhID09PSBiO1xufVxuZnVuY3Rpb24gaXNNYXliZUFycmF5c0VxdWFsKGEsIGIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSAmJiBBcnJheS5pc0FycmF5KGIpKSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5c0VxdWFsKGEsIGIpO1xuICAgIH1cbiAgICByZXR1cm4gYSA9PT0gYjtcbn1cbi8vIHZpZXctc3BlY2lmaWMgb3B0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5jb25zdCBWSUVXX09QVElPTl9SRUZJTkVSUyA9IHtcbiAgICB0eXBlOiBTdHJpbmcsXG4gICAgY29tcG9uZW50OiBpZGVudGl0eSxcbiAgICBidXR0b25UZXh0OiBTdHJpbmcsXG4gICAgYnV0dG9uVGV4dEtleTogU3RyaW5nLFxuICAgIGRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3M6IGlkZW50aXR5LFxuICAgIHVzZXNNaW5NYXhUaW1lOiBCb29sZWFuLFxuICAgIGNsYXNzTmFtZXM6IGlkZW50aXR5LFxuICAgIGNvbnRlbnQ6IGlkZW50aXR5LFxuICAgIGRpZE1vdW50OiBpZGVudGl0eSxcbiAgICB3aWxsVW5tb3VudDogaWRlbnRpdHksXG59O1xuLy8gdXRpbCBmdW5jc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gbWVyZ2VSYXdPcHRpb25zKG9wdGlvblNldHMpIHtcbiAgICByZXR1cm4gbWVyZ2VQcm9wcyhvcHRpb25TZXRzLCBDT01QTEVYX09QVElPTl9DT01QQVJBVE9SUyk7XG59XG5mdW5jdGlvbiByZWZpbmVQcm9wcyhpbnB1dCwgcmVmaW5lcnMpIHtcbiAgICBsZXQgcmVmaW5lZCA9IHt9O1xuICAgIGxldCBleHRyYSA9IHt9O1xuICAgIGZvciAobGV0IHByb3BOYW1lIGluIHJlZmluZXJzKSB7XG4gICAgICAgIGlmIChwcm9wTmFtZSBpbiBpbnB1dCkge1xuICAgICAgICAgICAgcmVmaW5lZFtwcm9wTmFtZV0gPSByZWZpbmVyc1twcm9wTmFtZV0oaW5wdXRbcHJvcE5hbWVdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBwcm9wTmFtZSBpbiBpbnB1dCkge1xuICAgICAgICBpZiAoIShwcm9wTmFtZSBpbiByZWZpbmVycykpIHtcbiAgICAgICAgICAgIGV4dHJhW3Byb3BOYW1lXSA9IGlucHV0W3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyByZWZpbmVkLCBleHRyYSB9O1xufVxuZnVuY3Rpb24gaWRlbnRpdHkocmF3KSB7XG4gICAgcmV0dXJuIHJhdztcbn1cblxuY29uc3QgeyBoYXNPd25Qcm9wZXJ0eSB9ID0gT2JqZWN0LnByb3RvdHlwZTtcbi8vIE1lcmdlcyBhbiBhcnJheSBvZiBvYmplY3RzIGludG8gYSBzaW5nbGUgb2JqZWN0LlxuLy8gVGhlIHNlY29uZCBhcmd1bWVudCBhbGxvd3MgZm9yIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIHdobydzIG9iamVjdCB2YWx1ZXMgd2lsbCBiZSBtZXJnZWQgdG9nZXRoZXIuXG5mdW5jdGlvbiBtZXJnZVByb3BzKHByb3BPYmpzLCBjb21wbGV4UHJvcHNNYXApIHtcbiAgICBsZXQgZGVzdCA9IHt9O1xuICAgIGlmIChjb21wbGV4UHJvcHNNYXApIHtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBjb21wbGV4UHJvcHNNYXApIHtcbiAgICAgICAgICAgIGlmIChjb21wbGV4UHJvcHNNYXBbbmFtZV0gPT09IGlzTWF5YmVPYmplY3RzRXF1YWwpIHsgLy8gaW1wbGllcyB0aGF0IGl0J3Mgb2JqZWN0LW1lcmdlYWJsZVxuICAgICAgICAgICAgICAgIGxldCBjb21wbGV4T2JqcyA9IFtdO1xuICAgICAgICAgICAgICAgIC8vIGNvbGxlY3QgdGhlIHRyYWlsaW5nIG9iamVjdCB2YWx1ZXMsIHN0b3BwaW5nIHdoZW4gYSBub24tb2JqZWN0IGlzIGRpc2NvdmVyZWRcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gcHJvcE9ianMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbCA9IHByb3BPYmpzW2ldW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdmFsKSB7IC8vIG5vbi1udWxsIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxleE9ianMudW5zaGlmdCh2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0W25hbWVdID0gdmFsOyAvLyBpZiB0aGVyZSB3ZXJlIG5vIG9iamVjdHMsIHRoaXMgdmFsdWUgd2lsbCBiZSB1c2VkXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgdHJhaWxpbmcgdmFsdWVzIHdlcmUgb2JqZWN0cywgdXNlIHRoZSBtZXJnZWQgdmFsdWVcbiAgICAgICAgICAgICAgICBpZiAoY29tcGxleE9ianMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc3RbbmFtZV0gPSBtZXJnZVByb3BzKGNvbXBsZXhPYmpzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gY29weSB2YWx1ZXMgaW50byB0aGUgZGVzdGluYXRpb24sIGdvaW5nIGZyb20gbGFzdCB0byBmaXJzdFxuICAgIGZvciAobGV0IGkgPSBwcm9wT2Jqcy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICBsZXQgcHJvcHMgPSBwcm9wT2Jqc1tpXTtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBwcm9wcykge1xuICAgICAgICAgICAgaWYgKCEobmFtZSBpbiBkZXN0KSkgeyAvLyBpZiBhbHJlYWR5IGFzc2lnbmVkIGJ5IHByZXZpb3VzIHByb3BzIG9yIGNvbXBsZXggcHJvcHMsIGRvbid0IHJlYXNzaWduXG4gICAgICAgICAgICAgICAgZGVzdFtuYW1lXSA9IHByb3BzW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xufVxuZnVuY3Rpb24gZmlsdGVySGFzaChoYXNoLCBmdW5jKSB7XG4gICAgbGV0IGZpbHRlcmVkID0ge307XG4gICAgZm9yIChsZXQga2V5IGluIGhhc2gpIHtcbiAgICAgICAgaWYgKGZ1bmMoaGFzaFtrZXldLCBrZXkpKSB7XG4gICAgICAgICAgICBmaWx0ZXJlZFtrZXldID0gaGFzaFtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmaWx0ZXJlZDtcbn1cbmZ1bmN0aW9uIG1hcEhhc2goaGFzaCwgZnVuYykge1xuICAgIGxldCBuZXdIYXNoID0ge307XG4gICAgZm9yIChsZXQga2V5IGluIGhhc2gpIHtcbiAgICAgICAgbmV3SGFzaFtrZXldID0gZnVuYyhoYXNoW2tleV0sIGtleSk7XG4gICAgfVxuICAgIHJldHVybiBuZXdIYXNoO1xufVxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYSkge1xuICAgIGxldCBoYXNoID0ge307XG4gICAgZm9yIChsZXQgaXRlbSBvZiBhKSB7XG4gICAgICAgIGhhc2hbaXRlbV0gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gaGFzaDtcbn1cbi8vIFRPRE86IHJlYXNzZXNzIGJyb3dzZXIgc3VwcG9ydFxuLy8gaHR0cHM6Ly9jYW5pdXNlLmNvbS8/c2VhcmNoPW9iamVjdC52YWx1ZXNcbmZ1bmN0aW9uIGhhc2hWYWx1ZXNUb0FycmF5KG9iaikge1xuICAgIGxldCBhID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG9iaikge1xuICAgICAgICBhLnB1c2gob2JqW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbn1cbmZ1bmN0aW9uIGlzUHJvcHNFcXVhbChvYmowLCBvYmoxKSB7XG4gICAgaWYgKG9iajAgPT09IG9iajEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZvciAobGV0IGtleSBpbiBvYmowKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iajAsIGtleSkpIHtcbiAgICAgICAgICAgIGlmICghKGtleSBpbiBvYmoxKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBrZXkgaW4gb2JqMSkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmoxLCBrZXkpKSB7XG4gICAgICAgICAgICBpZiAob2JqMFtrZXldICE9PSBvYmoxW2tleV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5jb25zdCBIQU5ETEVSX1JFID0gL15vbltBLVpdLztcbmZ1bmN0aW9uIGlzTm9uSGFuZGxlclByb3BzRXF1YWwob2JqMCwgb2JqMSkge1xuICAgIGNvbnN0IGtleXMgPSBnZXRVbmVxdWFsUHJvcHMob2JqMCwgb2JqMSk7XG4gICAgZm9yIChsZXQga2V5IG9mIGtleXMpIHtcbiAgICAgICAgaWYgKCFIQU5ETEVSX1JFLnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0VW5lcXVhbFByb3BzKG9iajAsIG9iajEpIHtcbiAgICBsZXQga2V5cyA9IFtdO1xuICAgIGZvciAobGV0IGtleSBpbiBvYmowKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iajAsIGtleSkpIHtcbiAgICAgICAgICAgIGlmICghKGtleSBpbiBvYmoxKSkge1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGtleSBpbiBvYmoxKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iajEsIGtleSkpIHtcbiAgICAgICAgICAgIGlmIChvYmowW2tleV0gIT09IG9iajFba2V5XSkge1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xufVxuZnVuY3Rpb24gY29tcGFyZU9ianMob2xkUHJvcHMsIG5ld1Byb3BzLCBlcXVhbGl0eUZ1bmNzID0ge30pIHtcbiAgICBpZiAob2xkUHJvcHMgPT09IG5ld1Byb3BzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmb3IgKGxldCBrZXkgaW4gbmV3UHJvcHMpIHtcbiAgICAgICAgaWYgKGtleSBpbiBvbGRQcm9wcyAmJiBpc09ialZhbHNFcXVhbChvbGRQcm9wc1trZXldLCBuZXdQcm9wc1trZXldLCBlcXVhbGl0eUZ1bmNzW2tleV0pKSA7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGNoZWNrIGZvciBwcm9wcyB0aGF0IHdlcmUgb21pdHRlZCBpbiB0aGUgbmV3XG4gICAgZm9yIChsZXQga2V5IGluIG9sZFByb3BzKSB7XG4gICAgICAgIGlmICghKGtleSBpbiBuZXdQcm9wcykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qXG5hc3N1bWVkIFwidHJ1ZVwiIGVxdWFsaXR5IGZvciBoYW5kbGVyIG5hbWVzIGxpa2UgXCJvblJlY2VpdmVTb21ldGhpbmdcIlxuKi9cbmZ1bmN0aW9uIGlzT2JqVmFsc0VxdWFsKHZhbDAsIHZhbDEsIGNvbXBhcmF0b3IpIHtcbiAgICBpZiAodmFsMCA9PT0gdmFsMSB8fCBjb21wYXJhdG9yID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoY29tcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gY29tcGFyYXRvcih2YWwwLCB2YWwxKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY29sbGVjdEZyb21IYXNoKGhhc2gsIHN0YXJ0SW5kZXggPSAwLCBlbmRJbmRleCwgc3RlcCA9IDEpIHtcbiAgICBsZXQgcmVzID0gW107XG4gICAgaWYgKGVuZEluZGV4ID09IG51bGwpIHtcbiAgICAgICAgZW5kSW5kZXggPSBPYmplY3Qua2V5cyhoYXNoKS5sZW5ndGg7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXg7IGkgKz0gc3RlcCkge1xuICAgICAgICBsZXQgdmFsID0gaGFzaFtpXTtcbiAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7IC8vIHdpbGwgZGlzcmVnYXJkIHVuZGVmaW5lZCBmb3Igc3BhcnNlIGFycmF5c1xuICAgICAgICAgICAgcmVzLnB1c2godmFsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5sZXQgY2FsZW5kYXJTeXN0ZW1DbGFzc01hcCA9IHt9O1xuZnVuY3Rpb24gcmVnaXN0ZXJDYWxlbmRhclN5c3RlbShuYW1lLCB0aGVDbGFzcykge1xuICAgIGNhbGVuZGFyU3lzdGVtQ2xhc3NNYXBbbmFtZV0gPSB0aGVDbGFzcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNhbGVuZGFyU3lzdGVtKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IGNhbGVuZGFyU3lzdGVtQ2xhc3NNYXBbbmFtZV0oKTtcbn1cbmNsYXNzIEdyZWdvcmlhbkNhbGVuZGFyU3lzdGVtIHtcbiAgICBnZXRNYXJrZXJZZWFyKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICB9XG4gICAgZ2V0TWFya2VyTW9udGgoZCkge1xuICAgICAgICByZXR1cm4gZC5nZXRVVENNb250aCgpO1xuICAgIH1cbiAgICBnZXRNYXJrZXJEYXkoZCkge1xuICAgICAgICByZXR1cm4gZC5nZXRVVENEYXRlKCk7XG4gICAgfVxuICAgIGFycmF5VG9NYXJrZXIoYXJyKSB7XG4gICAgICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShhcnIpO1xuICAgIH1cbiAgICBtYXJrZXJUb0FycmF5KG1hcmtlcikge1xuICAgICAgICByZXR1cm4gZGF0ZVRvVXRjQXJyYXkobWFya2VyKTtcbiAgICB9XG59XG5yZWdpc3RlckNhbGVuZGFyU3lzdGVtKCdncmVnb3J5JywgR3JlZ29yaWFuQ2FsZW5kYXJTeXN0ZW0pO1xuXG5jb25zdCBJU09fUkUgPSAvXlxccyooXFxkezR9KSgtPyhcXGR7Mn0pKC0/KFxcZHsyfSkoW1QgXShcXGR7Mn0pOj8oXFxkezJ9KSg6PyhcXGR7Mn0pKFxcLihcXGQrKSk/KT8oWnwoKFstK10pKFxcZHsyfSkoOj8oXFxkezJ9KSk/KSk/KT8pPyk/JC87XG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgICBsZXQgbSA9IElTT19SRS5leGVjKHN0cik7XG4gICAgaWYgKG0pIHtcbiAgICAgICAgbGV0IG1hcmtlciA9IG5ldyBEYXRlKERhdGUuVVRDKE51bWJlcihtWzFdKSwgbVszXSA/IE51bWJlcihtWzNdKSAtIDEgOiAwLCBOdW1iZXIobVs1XSB8fCAxKSwgTnVtYmVyKG1bN10gfHwgMCksIE51bWJlcihtWzhdIHx8IDApLCBOdW1iZXIobVsxMF0gfHwgMCksIG1bMTJdID8gTnVtYmVyKGAwLiR7bVsxMl19YCkgKiAxMDAwIDogMCkpO1xuICAgICAgICBpZiAoaXNWYWxpZERhdGUobWFya2VyKSkge1xuICAgICAgICAgICAgbGV0IHRpbWVab25lT2Zmc2V0ID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChtWzEzXSkge1xuICAgICAgICAgICAgICAgIHRpbWVab25lT2Zmc2V0ID0gKG1bMTVdID09PSAnLScgPyAtMSA6IDEpICogKE51bWJlcihtWzE2XSB8fCAwKSAqIDYwICtcbiAgICAgICAgICAgICAgICAgICAgTnVtYmVyKG1bMThdIHx8IDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWFya2VyLFxuICAgICAgICAgICAgICAgIGlzVGltZVVuc3BlY2lmaWVkOiAhbVs2XSxcbiAgICAgICAgICAgICAgICB0aW1lWm9uZU9mZnNldCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmNsYXNzIERhdGVFbnYge1xuICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgICAgIGxldCB0aW1lWm9uZSA9IHRoaXMudGltZVpvbmUgPSBzZXR0aW5ncy50aW1lWm9uZTtcbiAgICAgICAgbGV0IGlzTmFtZWRUaW1lWm9uZSA9IHRpbWVab25lICE9PSAnbG9jYWwnICYmIHRpbWVab25lICE9PSAnVVRDJztcbiAgICAgICAgaWYgKHNldHRpbmdzLm5hbWVkVGltZVpvbmVJbXBsICYmIGlzTmFtZWRUaW1lWm9uZSkge1xuICAgICAgICAgICAgdGhpcy5uYW1lZFRpbWVab25lSW1wbCA9IG5ldyBzZXR0aW5ncy5uYW1lZFRpbWVab25lSW1wbCh0aW1lWm9uZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYW5Db21wdXRlT2Zmc2V0ID0gQm9vbGVhbighaXNOYW1lZFRpbWVab25lIHx8IHRoaXMubmFtZWRUaW1lWm9uZUltcGwpO1xuICAgICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtID0gY3JlYXRlQ2FsZW5kYXJTeXN0ZW0oc2V0dGluZ3MuY2FsZW5kYXJTeXN0ZW0pO1xuICAgICAgICB0aGlzLmxvY2FsZSA9IHNldHRpbmdzLmxvY2FsZTtcbiAgICAgICAgdGhpcy53ZWVrRG93ID0gc2V0dGluZ3MubG9jYWxlLndlZWsuZG93O1xuICAgICAgICB0aGlzLndlZWtEb3kgPSBzZXR0aW5ncy5sb2NhbGUud2Vlay5kb3k7XG4gICAgICAgIGlmIChzZXR0aW5ncy53ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPT09ICdJU08nKSB7XG4gICAgICAgICAgICB0aGlzLndlZWtEb3cgPSAxO1xuICAgICAgICAgICAgdGhpcy53ZWVrRG95ID0gNDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLmZpcnN0RGF5ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy53ZWVrRG93ID0gc2V0dGluZ3MuZmlyc3REYXk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy53ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMud2Vla051bWJlckZ1bmMgPSBzZXR0aW5ncy53ZWVrTnVtYmVyQ2FsY3VsYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53ZWVrVGV4dCA9IHNldHRpbmdzLndlZWtUZXh0ICE9IG51bGwgPyBzZXR0aW5ncy53ZWVrVGV4dCA6IHNldHRpbmdzLmxvY2FsZS5vcHRpb25zLndlZWtUZXh0O1xuICAgICAgICB0aGlzLndlZWtUZXh0TG9uZyA9IChzZXR0aW5ncy53ZWVrVGV4dExvbmcgIT0gbnVsbCA/IHNldHRpbmdzLndlZWtUZXh0TG9uZyA6IHNldHRpbmdzLmxvY2FsZS5vcHRpb25zLndlZWtUZXh0TG9uZykgfHwgdGhpcy53ZWVrVGV4dDtcbiAgICAgICAgdGhpcy5jbWRGb3JtYXR0ZXIgPSBzZXR0aW5ncy5jbWRGb3JtYXR0ZXI7XG4gICAgICAgIHRoaXMuZGVmYXVsdFNlcGFyYXRvciA9IHNldHRpbmdzLmRlZmF1bHRTZXBhcmF0b3I7XG4gICAgfVxuICAgIC8vIENyZWF0aW5nIC8gUGFyc2luZ1xuICAgIGNyZWF0ZU1hcmtlcihpbnB1dCkge1xuICAgICAgICBsZXQgbWV0YSA9IHRoaXMuY3JlYXRlTWFya2VyTWV0YShpbnB1dCk7XG4gICAgICAgIGlmIChtZXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWV0YS5tYXJrZXI7XG4gICAgfVxuICAgIGNyZWF0ZU5vd01hcmtlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuQ29tcHV0ZU9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGltZXN0YW1wVG9NYXJrZXIobmV3IERhdGUoKS52YWx1ZU9mKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHdlIGNhbid0IGNvbXB1dGUgdGhlIGN1cnJlbnQgZGF0ZSB2YWwgZm9yIGEgdGltZXpvbmUsXG4gICAgICAgIC8vIGJldHRlciB0byBnaXZlIHRoZSBjdXJyZW50IGxvY2FsIGRhdGUgdmFscyB0aGFuIFVUQ1xuICAgICAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoZGF0ZVRvTG9jYWxBcnJheShuZXcgRGF0ZSgpKSk7XG4gICAgfVxuICAgIGNyZWF0ZU1hcmtlck1ldGEoaW5wdXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbWFya2VyID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIG1hcmtlciA9IHRoaXMudGltZXN0YW1wVG9NYXJrZXIoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgICAgICBpZiAoIWlzTmFOKGlucHV0KSkge1xuICAgICAgICAgICAgICAgIG1hcmtlciA9IHRoaXMudGltZXN0YW1wVG9NYXJrZXIoaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICBtYXJrZXIgPSBhcnJheVRvVXRjRGF0ZShpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmtlciA9PT0gbnVsbCB8fCAhaXNWYWxpZERhdGUobWFya2VyKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbWFya2VyLCBpc1RpbWVVbnNwZWNpZmllZDogZmFsc2UsIGZvcmNlZFR6bzogbnVsbCB9O1xuICAgIH1cbiAgICBwYXJzZShzKSB7XG4gICAgICAgIGxldCBwYXJ0cyA9IHBhcnNlKHMpO1xuICAgICAgICBpZiAocGFydHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IG1hcmtlciB9ID0gcGFydHM7XG4gICAgICAgIGxldCBmb3JjZWRUem8gPSBudWxsO1xuICAgICAgICBpZiAocGFydHMudGltZVpvbmVPZmZzZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbkNvbXB1dGVPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXIgPSB0aGlzLnRpbWVzdGFtcFRvTWFya2VyKG1hcmtlci52YWx1ZU9mKCkgLSBwYXJ0cy50aW1lWm9uZU9mZnNldCAqIDYwICogMTAwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3JjZWRUem8gPSBwYXJ0cy50aW1lWm9uZU9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtYXJrZXIsIGlzVGltZVVuc3BlY2lmaWVkOiBwYXJ0cy5pc1RpbWVVbnNwZWNpZmllZCwgZm9yY2VkVHpvIH07XG4gICAgfVxuICAgIC8vIEFjY2Vzc29yc1xuICAgIGdldFllYXIobWFya2VyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobWFya2VyKTtcbiAgICB9XG4gICAgZ2V0TW9udGgobWFya2VyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG1hcmtlcik7XG4gICAgfVxuICAgIGdldERheShtYXJrZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyRGF5KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIEFkZGluZyAvIFN1YnRyYWN0aW5nXG4gICAgYWRkKG1hcmtlciwgZHVyKSB7XG4gICAgICAgIGxldCBhID0gdGhpcy5jYWxlbmRhclN5c3RlbS5tYXJrZXJUb0FycmF5KG1hcmtlcik7XG4gICAgICAgIGFbMF0gKz0gZHVyLnllYXJzO1xuICAgICAgICBhWzFdICs9IGR1ci5tb250aHM7XG4gICAgICAgIGFbMl0gKz0gZHVyLmRheXM7XG4gICAgICAgIGFbNl0gKz0gZHVyLm1pbGxpc2Vjb25kcztcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihhKTtcbiAgICB9XG4gICAgc3VidHJhY3QobWFya2VyLCBkdXIpIHtcbiAgICAgICAgbGV0IGEgPSB0aGlzLmNhbGVuZGFyU3lzdGVtLm1hcmtlclRvQXJyYXkobWFya2VyKTtcbiAgICAgICAgYVswXSAtPSBkdXIueWVhcnM7XG4gICAgICAgIGFbMV0gLT0gZHVyLm1vbnRocztcbiAgICAgICAgYVsyXSAtPSBkdXIuZGF5cztcbiAgICAgICAgYVs2XSAtPSBkdXIubWlsbGlzZWNvbmRzO1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5hcnJheVRvTWFya2VyKGEpO1xuICAgIH1cbiAgICBhZGRZZWFycyhtYXJrZXIsIG4pIHtcbiAgICAgICAgbGV0IGEgPSB0aGlzLmNhbGVuZGFyU3lzdGVtLm1hcmtlclRvQXJyYXkobWFya2VyKTtcbiAgICAgICAgYVswXSArPSBuO1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5hcnJheVRvTWFya2VyKGEpO1xuICAgIH1cbiAgICBhZGRNb250aHMobWFya2VyLCBuKSB7XG4gICAgICAgIGxldCBhID0gdGhpcy5jYWxlbmRhclN5c3RlbS5tYXJrZXJUb0FycmF5KG1hcmtlcik7XG4gICAgICAgIGFbMV0gKz0gbjtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihhKTtcbiAgICB9XG4gICAgLy8gRGlmZmluZyBXaG9sZSBVbml0c1xuICAgIGRpZmZXaG9sZVllYXJzKG0wLCBtMSkge1xuICAgICAgICBsZXQgeyBjYWxlbmRhclN5c3RlbSB9ID0gdGhpcztcbiAgICAgICAgaWYgKHRpbWVBc01zKG0wKSA9PT0gdGltZUFzTXMobTEpICYmXG4gICAgICAgICAgICBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJEYXkobTApID09PSBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJEYXkobTEpICYmXG4gICAgICAgICAgICBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtMCkgPT09IGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG0xKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobTEpIC0gY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGRpZmZXaG9sZU1vbnRocyhtMCwgbTEpIHtcbiAgICAgICAgbGV0IHsgY2FsZW5kYXJTeXN0ZW0gfSA9IHRoaXM7XG4gICAgICAgIGlmICh0aW1lQXNNcyhtMCkgPT09IHRpbWVBc01zKG0xKSAmJlxuICAgICAgICAgICAgY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyRGF5KG0wKSA9PT0gY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyRGF5KG0xKSkge1xuICAgICAgICAgICAgcmV0dXJuIChjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtMSkgLSBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtMCkpICtcbiAgICAgICAgICAgICAgICAoY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtMSkgLSBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG0wKSkgKiAxMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gUmFuZ2UgLyBEdXJhdGlvblxuICAgIGdyZWF0ZXN0V2hvbGVVbml0KG0wLCBtMSkge1xuICAgICAgICBsZXQgbiA9IHRoaXMuZGlmZldob2xlWWVhcnMobTAsIG0xKTtcbiAgICAgICAgaWYgKG4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICd5ZWFyJywgdmFsdWU6IG4gfTtcbiAgICAgICAgfVxuICAgICAgICBuID0gdGhpcy5kaWZmV2hvbGVNb250aHMobTAsIG0xKTtcbiAgICAgICAgaWYgKG4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdtb250aCcsIHZhbHVlOiBuIH07XG4gICAgICAgIH1cbiAgICAgICAgbiA9IGRpZmZXaG9sZVdlZWtzKG0wLCBtMSk7XG4gICAgICAgIGlmIChuICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnd2VlaycsIHZhbHVlOiBuIH07XG4gICAgICAgIH1cbiAgICAgICAgbiA9IGRpZmZXaG9sZURheXMobTAsIG0xKTtcbiAgICAgICAgaWYgKG4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdkYXknLCB2YWx1ZTogbiB9O1xuICAgICAgICB9XG4gICAgICAgIG4gPSBkaWZmSG91cnMobTAsIG0xKTtcbiAgICAgICAgaWYgKGlzSW50KG4pKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnaG91cicsIHZhbHVlOiBuIH07XG4gICAgICAgIH1cbiAgICAgICAgbiA9IGRpZmZNaW51dGVzKG0wLCBtMSk7XG4gICAgICAgIGlmIChpc0ludChuKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ21pbnV0ZScsIHZhbHVlOiBuIH07XG4gICAgICAgIH1cbiAgICAgICAgbiA9IGRpZmZTZWNvbmRzKG0wLCBtMSk7XG4gICAgICAgIGlmIChpc0ludChuKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ3NlY29uZCcsIHZhbHVlOiBuIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdW5pdDogJ21pbGxpc2Vjb25kJywgdmFsdWU6IG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSB9O1xuICAgIH1cbiAgICBjb3VudER1cmF0aW9uc0JldHdlZW4obTAsIG0xLCBkKSB7XG4gICAgICAgIC8vIFRPRE86IGNhbiB1c2UgZ3JlYXRlc3RXaG9sZVVuaXRcbiAgICAgICAgbGV0IGRpZmY7XG4gICAgICAgIGlmIChkLnllYXJzKSB7XG4gICAgICAgICAgICBkaWZmID0gdGhpcy5kaWZmV2hvbGVZZWFycyhtMCwgbTEpO1xuICAgICAgICAgICAgaWYgKGRpZmYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlmZiAvIGFzUm91Z2hZZWFycyhkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZC5tb250aHMpIHtcbiAgICAgICAgICAgIGRpZmYgPSB0aGlzLmRpZmZXaG9sZU1vbnRocyhtMCwgbTEpO1xuICAgICAgICAgICAgaWYgKGRpZmYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlmZiAvIGFzUm91Z2hNb250aHMoZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGQuZGF5cykge1xuICAgICAgICAgICAgZGlmZiA9IGRpZmZXaG9sZURheXMobTAsIG0xKTtcbiAgICAgICAgICAgIGlmIChkaWZmICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpZmYgLyBhc1JvdWdoRGF5cyhkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSkgLyBhc1JvdWdoTXMoZCk7XG4gICAgfVxuICAgIC8vIFN0YXJ0LU9mXG4gICAgLy8gdGhlc2UgRE9OJ1QgcmV0dXJuIHpvbmVkLWRhdGVzLiBvbmx5IFVUQyBzdGFydC1vZiBkYXRlc1xuICAgIHN0YXJ0T2YobSwgdW5pdCkge1xuICAgICAgICBpZiAodW5pdCA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydE9mWWVhcihtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5pdCA9PT0gJ21vbnRoJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRPZk1vbnRoKG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0ID09PSAnd2VlaycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0T2ZXZWVrKG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0ID09PSAnZGF5Jykge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0T2ZEYXkobSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuaXQgPT09ICdob3VyJykge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0T2ZIb3VyKG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0ID09PSAnbWludXRlJykge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0T2ZNaW51dGUobSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuaXQgPT09ICdzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnRPZlNlY29uZChtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc3RhcnRPZlllYXIobSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5hcnJheVRvTWFya2VyKFtcbiAgICAgICAgICAgIHRoaXMuY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtKSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIHN0YXJ0T2ZNb250aChtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoW1xuICAgICAgICAgICAgdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG0pLFxuICAgICAgICAgICAgdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtKSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIHN0YXJ0T2ZXZWVrKG0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihbXG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobSksXG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG0pLFxuICAgICAgICAgICAgbS5nZXRVVENEYXRlKCkgLSAoKG0uZ2V0VVRDRGF5KCkgLSB0aGlzLndlZWtEb3cgKyA3KSAlIDcpLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLy8gV2VlayBOdW1iZXJcbiAgICBjb21wdXRlV2Vla051bWJlcihtYXJrZXIpIHtcbiAgICAgICAgaWYgKHRoaXMud2Vla051bWJlckZ1bmMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndlZWtOdW1iZXJGdW5jKHRoaXMudG9EYXRlKG1hcmtlcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKG1hcmtlciwgdGhpcy53ZWVrRG93LCB0aGlzLndlZWtEb3kpO1xuICAgIH1cbiAgICAvLyBUT0RPOiBjaG9rZSBvbiB0aW1lWm9uZU5hbWU6IGxvbmdcbiAgICBmb3JtYXQobWFya2VyLCBmb3JtYXR0ZXIsIGRhdGVPcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXQoe1xuICAgICAgICAgICAgbWFya2VyLFxuICAgICAgICAgICAgdGltZVpvbmVPZmZzZXQ6IGRhdGVPcHRpb25zLmZvcmNlZFR6byAhPSBudWxsID9cbiAgICAgICAgICAgICAgICBkYXRlT3B0aW9ucy5mb3JjZWRUem8gOlxuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0Rm9yTWFya2VyKG1hcmtlciksXG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgICBmb3JtYXRSYW5nZShzdGFydCwgZW5kLCBmb3JtYXR0ZXIsIGRhdGVPcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKGRhdGVPcHRpb25zLmlzRW5kRXhjbHVzaXZlKSB7XG4gICAgICAgICAgICBlbmQgPSBhZGRNcyhlbmQsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdFJhbmdlKHtcbiAgICAgICAgICAgIG1hcmtlcjogc3RhcnQsXG4gICAgICAgICAgICB0aW1lWm9uZU9mZnNldDogZGF0ZU9wdGlvbnMuZm9yY2VkU3RhcnRUem8gIT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgZGF0ZU9wdGlvbnMuZm9yY2VkU3RhcnRUem8gOlxuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0Rm9yTWFya2VyKHN0YXJ0KSxcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbWFya2VyOiBlbmQsXG4gICAgICAgICAgICB0aW1lWm9uZU9mZnNldDogZGF0ZU9wdGlvbnMuZm9yY2VkRW5kVHpvICE9IG51bGwgP1xuICAgICAgICAgICAgICAgIGRhdGVPcHRpb25zLmZvcmNlZEVuZFR6byA6XG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRGb3JNYXJrZXIoZW5kKSxcbiAgICAgICAgfSwgdGhpcywgZGF0ZU9wdGlvbnMuZGVmYXVsdFNlcGFyYXRvcik7XG4gICAgfVxuICAgIC8qXG4gICAgRFVNQjogdGhlIG9taXRUaW1lIGFyZyBpcyBkdW1iLiBpZiB3ZSBvbWl0IHRoZSB0aW1lLCB3ZSB3YW50IHRvIG9taXQgdGhlIHRpbWV6b25lIG9mZnNldC4gYW5kIGlmIHdlIGRvIHRoYXQsXG4gICAgbWlnaHQgYXMgd2VsbCB1c2UgYnVpbGRJc29TdHJpbmcgb3Igc29tZSBvdGhlciB1dGlsIGRpcmVjdGx5XG4gICAgKi9cbiAgICBmb3JtYXRJc28obWFya2VyLCBleHRyYU9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgdGltZVpvbmVPZmZzZXQgPSBudWxsO1xuICAgICAgICBpZiAoIWV4dHJhT3B0aW9ucy5vbWl0VGltZVpvbmVPZmZzZXQpIHtcbiAgICAgICAgICAgIGlmIChleHRyYU9wdGlvbnMuZm9yY2VkVHpvICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aW1lWm9uZU9mZnNldCA9IGV4dHJhT3B0aW9ucy5mb3JjZWRUem87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aW1lWm9uZU9mZnNldCA9IHRoaXMub2Zmc2V0Rm9yTWFya2VyKG1hcmtlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1aWxkSXNvU3RyaW5nKG1hcmtlciwgdGltZVpvbmVPZmZzZXQsIGV4dHJhT3B0aW9ucy5vbWl0VGltZSk7XG4gICAgfVxuICAgIC8vIFRpbWVab25lXG4gICAgdGltZXN0YW1wVG9NYXJrZXIobXMpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZVpvbmUgPT09ICdsb2NhbCcpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShkYXRlVG9Mb2NhbEFycmF5KG5ldyBEYXRlKG1zKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRpbWVab25lID09PSAnVVRDJyB8fCAhdGhpcy5uYW1lZFRpbWVab25lSW1wbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG1zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUodGhpcy5uYW1lZFRpbWVab25lSW1wbC50aW1lc3RhbXBUb0FycmF5KG1zKSk7XG4gICAgfVxuICAgIG9mZnNldEZvck1hcmtlcihtKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVab25lID09PSAnbG9jYWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gLWFycmF5VG9Mb2NhbERhdGUoZGF0ZVRvVXRjQXJyYXkobSkpLmdldFRpbWV6b25lT2Zmc2V0KCk7IC8vIGNvbnZlcnQgXCJpbnZlcnNlXCIgb2Zmc2V0IHRvIFwibm9ybWFsXCIgb2Zmc2V0XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudGltZVpvbmUgPT09ICdVVEMnKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5uYW1lZFRpbWVab25lSW1wbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmFtZWRUaW1lWm9uZUltcGwub2Zmc2V0Rm9yQXJyYXkoZGF0ZVRvVXRjQXJyYXkobSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBDb252ZXJzaW9uXG4gICAgdG9EYXRlKG0sIGZvcmNlZFR6bykge1xuICAgICAgICBpZiAodGhpcy50aW1lWm9uZSA9PT0gJ2xvY2FsJykge1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5VG9Mb2NhbERhdGUoZGF0ZVRvVXRjQXJyYXkobSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRpbWVab25lID09PSAnVVRDJykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG0udmFsdWVPZigpKTsgLy8gbWFrZSBzdXJlIGl0J3MgYSBjb3B5XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm5hbWVkVGltZVpvbmVJbXBsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUobS52YWx1ZU9mKCkgLSAoZm9yY2VkVHpvIHx8IDApKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IERhdGUobS52YWx1ZU9mKCkgLVxuICAgICAgICAgICAgdGhpcy5uYW1lZFRpbWVab25lSW1wbC5vZmZzZXRGb3JBcnJheShkYXRlVG9VdGNBcnJheShtKSkgKiAxMDAwICogNjApO1xuICAgIH1cbn1cblxuY2xhc3MgVGhlbWUge1xuICAgIGNvbnN0cnVjdG9yKGNhbGVuZGFyT3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5pY29uT3ZlcnJpZGVPcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SWNvbk92ZXJyaWRlKGNhbGVuZGFyT3B0aW9uc1t0aGlzLmljb25PdmVycmlkZU9wdGlvbl0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldEljb25PdmVycmlkZShpY29uT3ZlcnJpZGVIYXNoKSB7XG4gICAgICAgIGxldCBpY29uQ2xhc3Nlc0NvcHk7XG4gICAgICAgIGxldCBidXR0b25OYW1lO1xuICAgICAgICBpZiAodHlwZW9mIGljb25PdmVycmlkZUhhc2ggPT09ICdvYmplY3QnICYmIGljb25PdmVycmlkZUhhc2gpIHsgLy8gbm9uLW51bGwgb2JqZWN0XG4gICAgICAgICAgICBpY29uQ2xhc3Nlc0NvcHkgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmljb25DbGFzc2VzKTtcbiAgICAgICAgICAgIGZvciAoYnV0dG9uTmFtZSBpbiBpY29uT3ZlcnJpZGVIYXNoKSB7XG4gICAgICAgICAgICAgICAgaWNvbkNsYXNzZXNDb3B5W2J1dHRvbk5hbWVdID0gdGhpcy5hcHBseUljb25PdmVycmlkZVByZWZpeChpY29uT3ZlcnJpZGVIYXNoW2J1dHRvbk5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaWNvbkNsYXNzZXMgPSBpY29uQ2xhc3Nlc0NvcHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaWNvbk92ZXJyaWRlSGFzaCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuaWNvbkNsYXNzZXMgPSB7fTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhcHBseUljb25PdmVycmlkZVByZWZpeChjbGFzc05hbWUpIHtcbiAgICAgICAgbGV0IHByZWZpeCA9IHRoaXMuaWNvbk92ZXJyaWRlUHJlZml4O1xuICAgICAgICBpZiAocHJlZml4ICYmIGNsYXNzTmFtZS5pbmRleE9mKHByZWZpeCkgIT09IDApIHsgLy8gaWYgbm90IGFscmVhZHkgcHJlc2VudFxuICAgICAgICAgICAgY2xhc3NOYW1lID0gcHJlZml4ICsgY2xhc3NOYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbGFzc05hbWU7XG4gICAgfVxuICAgIGdldENsYXNzKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGFzc2VzW2tleV0gfHwgJyc7XG4gICAgfVxuICAgIGdldEljb25DbGFzcyhidXR0b25OYW1lLCBpc1J0bCkge1xuICAgICAgICBsZXQgY2xhc3NOYW1lO1xuICAgICAgICBpZiAoaXNSdGwgJiYgdGhpcy5ydGxJY29uQ2xhc3Nlcykge1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gdGhpcy5ydGxJY29uQ2xhc3Nlc1tidXR0b25OYW1lXSB8fCB0aGlzLmljb25DbGFzc2VzW2J1dHRvbk5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gdGhpcy5pY29uQ2xhc3Nlc1tidXR0b25OYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5iYXNlSWNvbkNsYXNzfSAke2NsYXNzTmFtZX1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgZ2V0Q3VzdG9tQnV0dG9uSWNvbkNsYXNzKGN1c3RvbUJ1dHRvblByb3BzKSB7XG4gICAgICAgIGxldCBjbGFzc05hbWU7XG4gICAgICAgIGlmICh0aGlzLmljb25PdmVycmlkZUN1c3RvbUJ1dHRvbk9wdGlvbikge1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gY3VzdG9tQnV0dG9uUHJvcHNbdGhpcy5pY29uT3ZlcnJpZGVDdXN0b21CdXR0b25PcHRpb25dO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLmJhc2VJY29uQ2xhc3N9ICR7dGhpcy5hcHBseUljb25PdmVycmlkZVByZWZpeChjbGFzc05hbWUpfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbn1cblRoZW1lLnByb3RvdHlwZS5jbGFzc2VzID0ge307XG5UaGVtZS5wcm90b3R5cGUuaWNvbkNsYXNzZXMgPSB7fTtcblRoZW1lLnByb3RvdHlwZS5iYXNlSWNvbkNsYXNzID0gJyc7XG5UaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlUHJlZml4ID0gJyc7XG5cbi8qXG5OT1RFOiB0aGlzIGNhbiBiZSBhIHB1YmxpYyBBUEksIGVzcGVjaWFsbHkgY3JlYXRlRWxlbWVudCBmb3IgaG9va3MuXG5TZWUgZXhhbXBsZXMvdHlwZXNjcmlwdC1zY2hlZHVsZXIvc3JjL2luZGV4LnRzXG4qL1xuZnVuY3Rpb24gZmx1c2hTeW5jKHJ1bkJlZm9yZUZsdXNoKSB7XG4gICAgcnVuQmVmb3JlRmx1c2goKTtcbiAgICBsZXQgb2xkRGVib3VuY2VSZW5kZXJpbmcgPSBwcmVhY3Qub3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZzsgLy8gb3JpZ1xuICAgIGxldCBjYWxsYmFja1EgPSBbXTtcbiAgICBmdW5jdGlvbiBleGVjQ2FsbGJhY2tTeW5jKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrUS5wdXNoKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgcHJlYWN0Lm9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmcgPSBleGVjQ2FsbGJhY2tTeW5jO1xuICAgIHByZWFjdC5yZW5kZXIocHJlYWN0LmNyZWF0ZUVsZW1lbnQoRmFrZUNvbXBvbmVudCwge30pLCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSk7XG4gICAgd2hpbGUgKGNhbGxiYWNrUS5sZW5ndGgpIHtcbiAgICAgICAgY2FsbGJhY2tRLnNoaWZ0KCkoKTtcbiAgICB9XG4gICAgcHJlYWN0Lm9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmcgPSBvbGREZWJvdW5jZVJlbmRlcmluZztcbn1cbmNsYXNzIEZha2VDb21wb25lbnQgZXh0ZW5kcyBwcmVhY3QuQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7IHJldHVybiBwcmVhY3QuY3JlYXRlRWxlbWVudCgnZGl2Jywge30pOyB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7IHRoaXMuc2V0U3RhdGUoe30pOyB9XG59XG4vLyBUT0RPOiB1c2UgcHJlYWN0L2NvbXBhdCBpbnN0ZWFkP1xuZnVuY3Rpb24gY3JlYXRlQ29udGV4dChkZWZhdWx0VmFsdWUpIHtcbiAgICBsZXQgQ29udGV4dFR5cGUgPSBwcmVhY3QuY3JlYXRlQ29udGV4dChkZWZhdWx0VmFsdWUpO1xuICAgIGxldCBvcmlnUHJvdmlkZXIgPSBDb250ZXh0VHlwZS5Qcm92aWRlcjtcbiAgICBDb250ZXh0VHlwZS5Qcm92aWRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbGV0IGlzTmV3ID0gIXRoaXMuZ2V0Q2hpbGRDb250ZXh0O1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBvcmlnUHJvdmlkZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItcmVzdC1wYXJhbXNcbiAgICAgICAgaWYgKGlzTmV3KSB7XG4gICAgICAgICAgICBsZXQgc3VicyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5zaG91bGRDb21wb25lbnRVcGRhdGUgPSAoX3Byb3BzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMudmFsdWUgIT09IF9wcm9wcy52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzdWJzLmZvckVhY2goKGMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuY29udGV4dCA9IF9wcm9wcy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuc3ViID0gKGMpID0+IHtcbiAgICAgICAgICAgICAgICBzdWJzLnB1c2goYyk7XG4gICAgICAgICAgICAgICAgbGV0IG9sZCA9IGMuY29tcG9uZW50V2lsbFVubW91bnQ7XG4gICAgICAgICAgICAgICAgYy5jb21wb25lbnRXaWxsVW5tb3VudCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc3Vicy5zcGxpY2Uoc3Vicy5pbmRleE9mKGMpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgb2xkICYmIG9sZC5jYWxsKGMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICB9O1xuICAgIHJldHVybiBDb250ZXh0VHlwZTtcbn1cblxuY2xhc3MgU2Nyb2xsUmVzcG9uZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihleGVjRnVuYywgZW1pdHRlciwgc2Nyb2xsVGltZSwgc2Nyb2xsVGltZVJlc2V0KSB7XG4gICAgICAgIHRoaXMuZXhlY0Z1bmMgPSBleGVjRnVuYztcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gZW1pdHRlcjtcbiAgICAgICAgdGhpcy5zY3JvbGxUaW1lID0gc2Nyb2xsVGltZTtcbiAgICAgICAgdGhpcy5zY3JvbGxUaW1lUmVzZXQgPSBzY3JvbGxUaW1lUmVzZXQ7XG4gICAgICAgIHRoaXMuaGFuZGxlU2Nyb2xsUmVxdWVzdCA9IChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnF1ZXVlZFJlcXVlc3QgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnF1ZXVlZFJlcXVlc3QgfHwge30sIHJlcXVlc3QpO1xuICAgICAgICAgICAgdGhpcy5kcmFpbigpO1xuICAgICAgICB9O1xuICAgICAgICBlbWl0dGVyLm9uKCdfc2Nyb2xsUmVxdWVzdCcsIHRoaXMuaGFuZGxlU2Nyb2xsUmVxdWVzdCk7XG4gICAgICAgIHRoaXMuZmlyZUluaXRpYWxTY3JvbGwoKTtcbiAgICB9XG4gICAgZGV0YWNoKCkge1xuICAgICAgICB0aGlzLmVtaXR0ZXIub2ZmKCdfc2Nyb2xsUmVxdWVzdCcsIHRoaXMuaGFuZGxlU2Nyb2xsUmVxdWVzdCk7XG4gICAgfVxuICAgIHVwZGF0ZShpc0RhdGVzTmV3KSB7XG4gICAgICAgIGlmIChpc0RhdGVzTmV3ICYmIHRoaXMuc2Nyb2xsVGltZVJlc2V0KSB7XG4gICAgICAgICAgICB0aGlzLmZpcmVJbml0aWFsU2Nyb2xsKCk7IC8vIHdpbGwgZHJhaW5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZHJhaW4oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaXJlSW5pdGlhbFNjcm9sbCgpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGxSZXF1ZXN0KHtcbiAgICAgICAgICAgIHRpbWU6IHRoaXMuc2Nyb2xsVGltZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRyYWluKCkge1xuICAgICAgICBpZiAodGhpcy5xdWV1ZWRSZXF1ZXN0ICYmIHRoaXMuZXhlY0Z1bmModGhpcy5xdWV1ZWRSZXF1ZXN0KSkge1xuICAgICAgICAgICAgdGhpcy5xdWV1ZWRSZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgVmlld0NvbnRleHRUeXBlID0gY3JlYXRlQ29udGV4dCh7fSk7IC8vIGZvciBDb21wb25lbnRzXG5mdW5jdGlvbiBidWlsZFZpZXdDb250ZXh0KHZpZXdTcGVjLCB2aWV3QXBpLCB2aWV3T3B0aW9ucywgZGF0ZVByb2ZpbGVHZW5lcmF0b3IsIGRhdGVFbnYsIHRoZW1lLCBwbHVnaW5Ib29rcywgZGlzcGF0Y2gsIGdldEN1cnJlbnREYXRhLCBlbWl0dGVyLCBjYWxlbmRhckFwaSwgcmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCwgdW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGF0ZUVudixcbiAgICAgICAgb3B0aW9uczogdmlld09wdGlvbnMsXG4gICAgICAgIHBsdWdpbkhvb2tzLFxuICAgICAgICBlbWl0dGVyLFxuICAgICAgICBkaXNwYXRjaCxcbiAgICAgICAgZ2V0Q3VycmVudERhdGEsXG4gICAgICAgIGNhbGVuZGFyQXBpLFxuICAgICAgICB2aWV3U3BlYyxcbiAgICAgICAgdmlld0FwaSxcbiAgICAgICAgZGF0ZVByb2ZpbGVHZW5lcmF0b3IsXG4gICAgICAgIHRoZW1lLFxuICAgICAgICBpc1J0bDogdmlld09wdGlvbnMuZGlyZWN0aW9uID09PSAncnRsJyxcbiAgICAgICAgYWRkUmVzaXplSGFuZGxlcihoYW5kbGVyKSB7XG4gICAgICAgICAgICBlbWl0dGVyLm9uKCdfcmVzaXplJywgaGFuZGxlcik7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZVJlc2l6ZUhhbmRsZXIoaGFuZGxlcikge1xuICAgICAgICAgICAgZW1pdHRlci5vZmYoJ19yZXNpemUnLCBoYW5kbGVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlU2Nyb2xsUmVzcG9uZGVyKGV4ZWNGdW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNjcm9sbFJlc3BvbmRlcihleGVjRnVuYywgZW1pdHRlciwgY3JlYXRlRHVyYXRpb24odmlld09wdGlvbnMuc2Nyb2xsVGltZSksIHZpZXdPcHRpb25zLnNjcm9sbFRpbWVSZXNldCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQsXG4gICAgICAgIHVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCxcbiAgICB9O1xufVxuXG4vKiBlc2xpbnQgbWF4LWNsYXNzZXMtcGVyLWZpbGU6IG9mZiAqL1xuY2xhc3MgUHVyZUNvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlKSB7XG4gICAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgY29uc29sZS5sb2coZ2V0VW5lcXVhbFByb3BzKG5leHRQcm9wcywgdGhpcy5wcm9wcyksIGdldFVuZXF1YWxQcm9wcyhuZXh0U3RhdGUsIHRoaXMuc3RhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIWNvbXBhcmVPYmpzKHRoaXMucHJvcHMsIG5leHRQcm9wcywgdGhpcy5wcm9wRXF1YWxpdHkpIHx8XG4gICAgICAgICAgICAhY29tcGFyZU9ianModGhpcy5zdGF0ZSwgbmV4dFN0YXRlLCB0aGlzLnN0YXRlRXF1YWxpdHkpO1xuICAgIH1cbiAgICAvLyBIQUNLIGZvciBmcmVha2luJyBSZWFjdCBTdHJpY3RNb2RlXG4gICAgc2FmZVNldFN0YXRlKG5ld1N0YXRlKSB7XG4gICAgICAgIGlmICghY29tcGFyZU9ianModGhpcy5zdGF0ZSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnN0YXRlKSwgbmV3U3RhdGUpLCB0aGlzLnN0YXRlRXF1YWxpdHkpKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKG5ld1N0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblB1cmVDb21wb25lbnQuYWRkUHJvcHNFcXVhbGl0eSA9IGFkZFByb3BzRXF1YWxpdHk7XG5QdXJlQ29tcG9uZW50LmFkZFN0YXRlRXF1YWxpdHkgPSBhZGRTdGF0ZUVxdWFsaXR5O1xuUHVyZUNvbXBvbmVudC5jb250ZXh0VHlwZSA9IFZpZXdDb250ZXh0VHlwZTtcblB1cmVDb21wb25lbnQucHJvdG90eXBlLnByb3BFcXVhbGl0eSA9IHt9O1xuUHVyZUNvbXBvbmVudC5wcm90b3R5cGUuc3RhdGVFcXVhbGl0eSA9IHt9O1xuY2xhc3MgQmFzZUNvbXBvbmVudCBleHRlbmRzIFB1cmVDb21wb25lbnQge1xufVxuQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZSA9IFZpZXdDb250ZXh0VHlwZTtcbmZ1bmN0aW9uIGFkZFByb3BzRXF1YWxpdHkocHJvcEVxdWFsaXR5KSB7XG4gICAgbGV0IGhhc2ggPSBPYmplY3QuY3JlYXRlKHRoaXMucHJvdG90eXBlLnByb3BFcXVhbGl0eSk7XG4gICAgT2JqZWN0LmFzc2lnbihoYXNoLCBwcm9wRXF1YWxpdHkpO1xuICAgIHRoaXMucHJvdG90eXBlLnByb3BFcXVhbGl0eSA9IGhhc2g7XG59XG5mdW5jdGlvbiBhZGRTdGF0ZUVxdWFsaXR5KHN0YXRlRXF1YWxpdHkpIHtcbiAgICBsZXQgaGFzaCA9IE9iamVjdC5jcmVhdGUodGhpcy5wcm90b3R5cGUuc3RhdGVFcXVhbGl0eSk7XG4gICAgT2JqZWN0LmFzc2lnbihoYXNoLCBzdGF0ZUVxdWFsaXR5KTtcbiAgICB0aGlzLnByb3RvdHlwZS5zdGF0ZUVxdWFsaXR5ID0gaGFzaDtcbn1cbi8vIHVzZSBvdGhlciBvbmVcbmZ1bmN0aW9uIHNldFJlZihyZWYsIGN1cnJlbnQpIHtcbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZWYoY3VycmVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlZikge1xuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzAyOVxuICAgICAgICByZWYuY3VycmVudCA9IGN1cnJlbnQ7XG4gICAgfVxufVxuXG5jbGFzcyBDb250ZW50SW5qZWN0b3IgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5pZCA9IGd1aWQoKTtcbiAgICAgICAgdGhpcy5xdWV1ZWREb21Ob2RlcyA9IFtdO1xuICAgICAgICB0aGlzLmN1cnJlbnREb21Ob2RlcyA9IFtdO1xuICAgICAgICB0aGlzLmhhbmRsZUVsID0gKGVsKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG9wdGlvbnMgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgICAgIGNvbnN0IHsgZ2VuZXJhdG9yTmFtZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5jdXN0b21SZW5kZXJpbmdSZXBsYWNlcyB8fCAhaGFzQ3VzdG9tUmVuZGVyaW5nSGFuZGxlcihnZW5lcmF0b3JOYW1lLCBvcHRpb25zKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRWxSZWYoZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZUVsUmVmID0gKGVsKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5lbFJlZikge1xuICAgICAgICAgICAgICAgIHNldFJlZih0aGlzLnByb3BzLmVsUmVmLCBlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSBjb250ZXh0O1xuICAgICAgICBjb25zdCB7IGN1c3RvbUdlbmVyYXRvciwgZGVmYXVsdEdlbmVyYXRvciwgcmVuZGVyUHJvcHMgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCBhdHRycyA9IGJ1aWxkRWxBdHRycyhwcm9wcywgW10sIHRoaXMuaGFuZGxlRWwpO1xuICAgICAgICBsZXQgdXNlRGVmYXVsdCA9IGZhbHNlO1xuICAgICAgICBsZXQgaW5uZXJDb250ZW50O1xuICAgICAgICBsZXQgcXVldWVkRG9tTm9kZXMgPSBbXTtcbiAgICAgICAgbGV0IGN1cnJlbnRHZW5lcmF0b3JNZXRhO1xuICAgICAgICBpZiAoY3VzdG9tR2VuZXJhdG9yICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1c3RvbUdlbmVyYXRvclJlcyA9IHR5cGVvZiBjdXN0b21HZW5lcmF0b3IgPT09ICdmdW5jdGlvbicgP1xuICAgICAgICAgICAgICAgIGN1c3RvbUdlbmVyYXRvcihyZW5kZXJQcm9wcywgY3JlYXRlRWxlbWVudCkgOlxuICAgICAgICAgICAgICAgIGN1c3RvbUdlbmVyYXRvcjtcbiAgICAgICAgICAgIGlmIChjdXN0b21HZW5lcmF0b3JSZXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB1c2VEZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzT2JqZWN0ID0gY3VzdG9tR2VuZXJhdG9yUmVzICYmIHR5cGVvZiBjdXN0b21HZW5lcmF0b3JSZXMgPT09ICdvYmplY3QnOyAvLyBub24tbnVsbFxuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdCAmJiAoJ2h0bWwnIGluIGN1c3RvbUdlbmVyYXRvclJlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cnMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPSB7IF9faHRtbDogY3VzdG9tR2VuZXJhdG9yUmVzLmh0bWwgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QgJiYgKCdkb21Ob2RlcycgaW4gY3VzdG9tR2VuZXJhdG9yUmVzKSkge1xuICAgICAgICAgICAgICAgICAgICBxdWV1ZWREb21Ob2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGN1c3RvbUdlbmVyYXRvclJlcy5kb21Ob2Rlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0XG4gICAgICAgICAgICAgICAgICAgID8gaXNWYWxpZEVsZW1lbnQoY3VzdG9tR2VuZXJhdG9yUmVzKSAvLyB2ZG9tIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgOiB0eXBlb2YgY3VzdG9tR2VuZXJhdG9yUmVzICE9PSAnZnVuY3Rpb24nIC8vIHByaW1pdGl2ZSB2YWx1ZSAobGlrZSBzdHJpbmcgb3IgbnVtYmVyKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAvLyB1c2UgaW4gdmRvbVxuICAgICAgICAgICAgICAgICAgICBpbm5lckNvbnRlbnQgPSBjdXN0b21HZW5lcmF0b3JSZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBhbiBleG90aWMgb2JqZWN0IGZvciBoYW5kbGVDdXN0b21SZW5kZXJpbmdcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEdlbmVyYXRvck1ldGEgPSBjdXN0b21HZW5lcmF0b3JSZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXNlRGVmYXVsdCA9ICFoYXNDdXN0b21SZW5kZXJpbmdIYW5kbGVyKHByb3BzLmdlbmVyYXRvck5hbWUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VEZWZhdWx0ICYmIGRlZmF1bHRHZW5lcmF0b3IpIHtcbiAgICAgICAgICAgIGlubmVyQ29udGVudCA9IGRlZmF1bHRHZW5lcmF0b3IocmVuZGVyUHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucXVldWVkRG9tTm9kZXMgPSBxdWV1ZWREb21Ob2RlcztcbiAgICAgICAgdGhpcy5jdXJyZW50R2VuZXJhdG9yTWV0YSA9IGN1cnJlbnRHZW5lcmF0b3JNZXRhO1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChwcm9wcy5lbFRhZywgYXR0cnMsIGlubmVyQ29udGVudCk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLmFwcGx5UXVldWV1ZERvbU5vZGVzKCk7XG4gICAgICAgIHRoaXMudHJpZ2dlckN1c3RvbVJlbmRlcmluZyh0cnVlKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICB0aGlzLmFwcGx5UXVldWV1ZERvbU5vZGVzKCk7XG4gICAgICAgIHRoaXMudHJpZ2dlckN1c3RvbVJlbmRlcmluZyh0cnVlKTtcbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlckN1c3RvbVJlbmRlcmluZyhmYWxzZSk7IC8vIFRPRE86IGRpZmZlcmVudCBBUEkgZm9yIHJlbW92YWw/XG4gICAgfVxuICAgIHRyaWdnZXJDdXN0b21SZW5kZXJpbmcoaXNBY3RpdmUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGhhbmRsZUN1c3RvbVJlbmRlcmluZywgY3VzdG9tUmVuZGVyaW5nTWV0YU1hcCB9ID0gY29udGV4dC5vcHRpb25zO1xuICAgICAgICBpZiAoaGFuZGxlQ3VzdG9tUmVuZGVyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBnZW5lcmF0b3JNZXRhID0gKF9hID0gdGhpcy5jdXJyZW50R2VuZXJhdG9yTWV0YSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY3VzdG9tUmVuZGVyaW5nTWV0YU1hcCA9PT0gbnVsbCB8fCBjdXN0b21SZW5kZXJpbmdNZXRhTWFwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXN0b21SZW5kZXJpbmdNZXRhTWFwW3Byb3BzLmdlbmVyYXRvck5hbWVdO1xuICAgICAgICAgICAgaWYgKGdlbmVyYXRvck1ldGEpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVDdXN0b21SZW5kZXJpbmcoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgaWQ6IHRoaXMuaWQsIGlzQWN0aXZlLCBjb250YWluZXJFbDogdGhpcy5iYXNlLCByZXBvcnROZXdDb250YWluZXJFbDogdGhpcy51cGRhdGVFbFJlZiwgLy8gZnJvbnQtZW5kIGZyYW1ld29yayB0ZWxscyB1cyBhYm91dCBuZXcgY29udGFpbmVyIGVsc1xuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0b3JNZXRhIH0sIHByb3BzKSwgeyBlbENsYXNzZXM6IChwcm9wcy5lbENsYXNzZXMgfHwgW10pLmZpbHRlcihpc1RydXRoeSkgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFwcGx5UXVldWV1ZERvbU5vZGVzKCkge1xuICAgICAgICBjb25zdCB7IHF1ZXVlZERvbU5vZGVzLCBjdXJyZW50RG9tTm9kZXMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGVsID0gdGhpcy5iYXNlO1xuICAgICAgICBpZiAoIWlzQXJyYXlzRXF1YWwocXVldWVkRG9tTm9kZXMsIGN1cnJlbnREb21Ob2RlcykpIHtcbiAgICAgICAgICAgIGN1cnJlbnREb21Ob2Rlcy5mb3JFYWNoKHJlbW92ZUVsZW1lbnQpO1xuICAgICAgICAgICAgZm9yIChsZXQgbmV3Tm9kZSBvZiBxdWV1ZWREb21Ob2Rlcykge1xuICAgICAgICAgICAgICAgIGVsLmFwcGVuZENoaWxkKG5ld05vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jdXJyZW50RG9tTm9kZXMgPSBxdWV1ZWREb21Ob2RlcztcbiAgICAgICAgfVxuICAgIH1cbn1cbkNvbnRlbnRJbmplY3Rvci5hZGRQcm9wc0VxdWFsaXR5KHtcbiAgICBlbENsYXNzZXM6IGlzQXJyYXlzRXF1YWwsXG4gICAgZWxTdHlsZTogaXNQcm9wc0VxdWFsLFxuICAgIGVsQXR0cnM6IGlzTm9uSGFuZGxlclByb3BzRXF1YWwsXG4gICAgcmVuZGVyUHJvcHM6IGlzUHJvcHNFcXVhbCxcbn0pO1xuLy8gVXRpbFxuLypcbkRvZXMgVUktZnJhbWV3b3JrIHByb3ZpZGUgY3VzdG9tIHdheSBvZiByZW5kZXJpbmcgdGhhdCBkb2VzIG5vdCB1c2UgUHJlYWN0IFZET01cbkFORCBkb2VzIHRoZSBjYWxlbmRhcidzIG9wdGlvbnMgZGVmaW5lIGN1c3RvbSByZW5kZXJpbmc/XG5BS0EuIFNob3VsZCB3ZSBOT1QgcmVuZGVyIHRoZSBkZWZhdWx0IGNvbnRlbnQ/XG4qL1xuZnVuY3Rpb24gaGFzQ3VzdG9tUmVuZGVyaW5nSGFuZGxlcihnZW5lcmF0b3JOYW1lLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBCb29sZWFuKG9wdGlvbnMuaGFuZGxlQ3VzdG9tUmVuZGVyaW5nICYmXG4gICAgICAgIGdlbmVyYXRvck5hbWUgJiZcbiAgICAgICAgKChfYSA9IG9wdGlvbnMuY3VzdG9tUmVuZGVyaW5nTWV0YU1hcCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2dlbmVyYXRvck5hbWVdKSk7XG59XG5mdW5jdGlvbiBidWlsZEVsQXR0cnMocHJvcHMsIGV4dHJhQ2xhc3NOYW1lcywgZWxSZWYpIHtcbiAgICBjb25zdCBhdHRycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMuZWxBdHRycyksIHsgcmVmOiBlbFJlZiB9KTtcbiAgICBpZiAocHJvcHMuZWxDbGFzc2VzIHx8IGV4dHJhQ2xhc3NOYW1lcykge1xuICAgICAgICBhdHRycy5jbGFzc05hbWUgPSAocHJvcHMuZWxDbGFzc2VzIHx8IFtdKVxuICAgICAgICAgICAgLmNvbmNhdChleHRyYUNsYXNzTmFtZXMgfHwgW10pXG4gICAgICAgICAgICAuY29uY2F0KGF0dHJzLmNsYXNzTmFtZSB8fCBbXSlcbiAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgICAgIC5qb2luKCcgJyk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5lbFN0eWxlKSB7XG4gICAgICAgIGF0dHJzLnN0eWxlID0gcHJvcHMuZWxTdHlsZTtcbiAgICB9XG4gICAgcmV0dXJuIGF0dHJzO1xufVxuZnVuY3Rpb24gaXNUcnV0aHkodmFsKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odmFsKTtcbn1cblxuY29uc3QgUmVuZGVySWQgPSBjcmVhdGVDb250ZXh0KDApO1xuXG5jbGFzcyBDb250ZW50Q29udGFpbmVyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5Jbm5lckNvbnRlbnQgPSBJbm5lckNvbnRlbnRJbmplY3Rvci5iaW5kKHVuZGVmaW5lZCwgdGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlRWwgPSAoZWwpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLmVsUmVmKSB7XG4gICAgICAgICAgICAgICAgc2V0UmVmKHRoaXMucHJvcHMuZWxSZWYsIGVsKTtcbiAgICAgICAgICAgICAgICBpZiAoZWwgJiYgdGhpcy5kaWRNb3VudE1pc2ZpcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnREaWRNb3VudCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBnZW5lcmF0ZWRDbGFzc05hbWVzID0gZ2VuZXJhdGVDbGFzc05hbWVzKHByb3BzLmNsYXNzTmFtZUdlbmVyYXRvciwgcHJvcHMucmVuZGVyUHJvcHMpO1xuICAgICAgICBpZiAocHJvcHMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGVsQXR0cnMgPSBidWlsZEVsQXR0cnMocHJvcHMsIGdlbmVyYXRlZENsYXNzTmFtZXMsIHRoaXMuaGFuZGxlRWwpO1xuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbih0aGlzLklubmVyQ29udGVudCwgcHJvcHMucmVuZGVyUHJvcHMsIGVsQXR0cnMpO1xuICAgICAgICAgICAgaWYgKHByb3BzLmVsVGFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQocHJvcHMuZWxUYWcsIGVsQXR0cnMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KChDb250ZW50SW5qZWN0b3IpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByb3BzKSwgeyBlbFJlZjogdGhpcy5oYW5kbGVFbCwgZWxUYWc6IHByb3BzLmVsVGFnIHx8ICdkaXYnLCBlbENsYXNzZXM6IChwcm9wcy5lbENsYXNzZXMgfHwgW10pLmNvbmNhdChnZW5lcmF0ZWRDbGFzc05hbWVzKSwgcmVuZGVySWQ6IHRoaXMuY29udGV4dCB9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICh0aGlzLmVsKSB7XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLnByb3BzKS5kaWRNb3VudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcy5yZW5kZXJQcm9wcyksIHsgZWw6IHRoaXMuZWwgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kaWRNb3VudE1pc2ZpcmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLnByb3BzKS53aWxsVW5tb3VudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcy5yZW5kZXJQcm9wcyksIHsgZWw6IHRoaXMuZWwgfSkpO1xuICAgIH1cbn1cbkNvbnRlbnRDb250YWluZXIuY29udGV4dFR5cGUgPSBSZW5kZXJJZDtcbmZ1bmN0aW9uIElubmVyQ29udGVudEluamVjdG9yKGNvbnRhaW5lckNvbXBvbmVudCwgcHJvcHMpIHtcbiAgICBjb25zdCBwYXJlbnRQcm9wcyA9IGNvbnRhaW5lckNvbXBvbmVudC5wcm9wcztcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgoQ29udGVudEluamVjdG9yKSwgT2JqZWN0LmFzc2lnbih7IHJlbmRlclByb3BzOiBwYXJlbnRQcm9wcy5yZW5kZXJQcm9wcywgZ2VuZXJhdG9yTmFtZTogcGFyZW50UHJvcHMuZ2VuZXJhdG9yTmFtZSwgY3VzdG9tR2VuZXJhdG9yOiBwYXJlbnRQcm9wcy5jdXN0b21HZW5lcmF0b3IsIGRlZmF1bHRHZW5lcmF0b3I6IHBhcmVudFByb3BzLmRlZmF1bHRHZW5lcmF0b3IsIHJlbmRlcklkOiBjb250YWluZXJDb21wb25lbnQuY29udGV4dCB9LCBwcm9wcykpO1xufVxuLy8gVXRpbHNcbmZ1bmN0aW9uIGdlbmVyYXRlQ2xhc3NOYW1lcyhjbGFzc05hbWVHZW5lcmF0b3IsIHJlbmRlclByb3BzKSB7XG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IHR5cGVvZiBjbGFzc05hbWVHZW5lcmF0b3IgPT09ICdmdW5jdGlvbicgP1xuICAgICAgICBjbGFzc05hbWVHZW5lcmF0b3IocmVuZGVyUHJvcHMpIDpcbiAgICAgICAgY2xhc3NOYW1lR2VuZXJhdG9yIHx8IFtdO1xuICAgIHJldHVybiB0eXBlb2YgY2xhc3NOYW1lcyA9PT0gJ3N0cmluZycgPyBbY2xhc3NOYW1lc10gOiBjbGFzc05hbWVzO1xufVxuXG5jbGFzcyBWaWV3Q29udGFpbmVyIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgb3B0aW9ucyB9ID0gY29udGV4dDtcbiAgICAgICAgbGV0IHJlbmRlclByb3BzID0geyB2aWV3OiBjb250ZXh0LnZpZXdBcGkgfTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KENvbnRlbnRDb250YWluZXIsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCB7IGVsVGFnOiBwcm9wcy5lbFRhZyB8fCAnZGl2JywgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgLi4uYnVpbGRWaWV3Q2xhc3NOYW1lcyhwcm9wcy52aWV3U3BlYyksXG4gICAgICAgICAgICAgICAgLi4uKHByb3BzLmVsQ2xhc3NlcyB8fCBbXSksXG4gICAgICAgICAgICBdLCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy52aWV3Q2xhc3NOYW1lcywgZ2VuZXJhdG9yTmFtZTogdW5kZWZpbmVkLCBkaWRNb3VudDogb3B0aW9ucy52aWV3RGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLnZpZXdXaWxsVW5tb3VudCB9KSwgKCkgPT4gcHJvcHMuY2hpbGRyZW4pKTtcbiAgICB9XG59XG5mdW5jdGlvbiBidWlsZFZpZXdDbGFzc05hbWVzKHZpZXdTcGVjKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgYGZjLSR7dmlld1NwZWMudHlwZX0tdmlld2AsXG4gICAgICAgICdmYy12aWV3JyxcbiAgICBdO1xufVxuXG5mdW5jdGlvbiBwYXJzZVJhbmdlKGlucHV0LCBkYXRlRW52KSB7XG4gICAgbGV0IHN0YXJ0ID0gbnVsbDtcbiAgICBsZXQgZW5kID0gbnVsbDtcbiAgICBpZiAoaW5wdXQuc3RhcnQpIHtcbiAgICAgICAgc3RhcnQgPSBkYXRlRW52LmNyZWF0ZU1hcmtlcihpbnB1dC5zdGFydCk7XG4gICAgfVxuICAgIGlmIChpbnB1dC5lbmQpIHtcbiAgICAgICAgZW5kID0gZGF0ZUVudi5jcmVhdGVNYXJrZXIoaW5wdXQuZW5kKTtcbiAgICB9XG4gICAgaWYgKCFzdGFydCAmJiAhZW5kKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoc3RhcnQgJiYgZW5kICYmIGVuZCA8IHN0YXJ0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4geyBzdGFydCwgZW5kIH07XG59XG4vLyBTSURFLUVGRkVDVDogd2lsbCBtdXRhdGUgcmFuZ2VzLlxuLy8gV2lsbCByZXR1cm4gYSBuZXcgYXJyYXkgcmVzdWx0LlxuZnVuY3Rpb24gaW52ZXJ0UmFuZ2VzKHJhbmdlcywgY29uc3RyYWludFJhbmdlKSB7XG4gICAgbGV0IGludmVydGVkUmFuZ2VzID0gW107XG4gICAgbGV0IHsgc3RhcnQgfSA9IGNvbnN0cmFpbnRSYW5nZTsgLy8gdGhlIGVuZCBvZiB0aGUgcHJldmlvdXMgcmFuZ2UuIHRoZSBzdGFydCBvZiB0aGUgbmV3IHJhbmdlXG4gICAgbGV0IGk7XG4gICAgbGV0IGRhdGVSYW5nZTtcbiAgICAvLyByYW5nZXMgbmVlZCB0byBiZSBpbiBvcmRlci4gcmVxdWlyZWQgZm9yIG91ciBkYXRlLXdhbGtpbmcgYWxnb3JpdGhtXG4gICAgcmFuZ2VzLnNvcnQoY29tcGFyZVJhbmdlcyk7XG4gICAgZm9yIChpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBkYXRlUmFuZ2UgPSByYW5nZXNbaV07XG4gICAgICAgIC8vIGFkZCB0aGUgc3BhbiBvZiB0aW1lIGJlZm9yZSB0aGUgZXZlbnQgKGlmIHRoZXJlIGlzIGFueSlcbiAgICAgICAgaWYgKGRhdGVSYW5nZS5zdGFydCA+IHN0YXJ0KSB7IC8vIGNvbXBhcmUgbWlsbGlzZWNvbmQgdGltZSAoc2tpcCBhbnkgYW1iaWcgbG9naWMpXG4gICAgICAgICAgICBpbnZlcnRlZFJhbmdlcy5wdXNoKHsgc3RhcnQsIGVuZDogZGF0ZVJhbmdlLnN0YXJ0IH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRlUmFuZ2UuZW5kID4gc3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gZGF0ZVJhbmdlLmVuZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBhZGQgdGhlIHNwYW4gb2YgdGltZSBhZnRlciB0aGUgbGFzdCBldmVudCAoaWYgdGhlcmUgaXMgYW55KVxuICAgIGlmIChzdGFydCA8IGNvbnN0cmFpbnRSYW5nZS5lbmQpIHsgLy8gY29tcGFyZSBtaWxsaXNlY29uZCB0aW1lIChza2lwIGFueSBhbWJpZyBsb2dpYylcbiAgICAgICAgaW52ZXJ0ZWRSYW5nZXMucHVzaCh7IHN0YXJ0LCBlbmQ6IGNvbnN0cmFpbnRSYW5nZS5lbmQgfSk7XG4gICAgfVxuICAgIHJldHVybiBpbnZlcnRlZFJhbmdlcztcbn1cbmZ1bmN0aW9uIGNvbXBhcmVSYW5nZXMocmFuZ2UwLCByYW5nZTEpIHtcbiAgICByZXR1cm4gcmFuZ2UwLnN0YXJ0LnZhbHVlT2YoKSAtIHJhbmdlMS5zdGFydC52YWx1ZU9mKCk7IC8vIGVhcmxpZXIgcmFuZ2VzIGdvIGZpcnN0XG59XG5mdW5jdGlvbiBpbnRlcnNlY3RSYW5nZXMocmFuZ2UwLCByYW5nZTEpIHtcbiAgICBsZXQgeyBzdGFydCwgZW5kIH0gPSByYW5nZTA7XG4gICAgbGV0IG5ld1JhbmdlID0gbnVsbDtcbiAgICBpZiAocmFuZ2UxLnN0YXJ0ICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhcnQgPSByYW5nZTEuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFydCA9IG5ldyBEYXRlKE1hdGgubWF4KHN0YXJ0LnZhbHVlT2YoKSwgcmFuZ2UxLnN0YXJ0LnZhbHVlT2YoKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChyYW5nZTEuZW5kICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZW5kID0gcmFuZ2UxLmVuZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVuZCA9IG5ldyBEYXRlKE1hdGgubWluKGVuZC52YWx1ZU9mKCksIHJhbmdlMS5lbmQudmFsdWVPZigpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YXJ0ID09PSBudWxsIHx8IGVuZCA9PT0gbnVsbCB8fCBzdGFydCA8IGVuZCkge1xuICAgICAgICBuZXdSYW5nZSA9IHsgc3RhcnQsIGVuZCB9O1xuICAgIH1cbiAgICByZXR1cm4gbmV3UmFuZ2U7XG59XG5mdW5jdGlvbiByYW5nZXNFcXVhbChyYW5nZTAsIHJhbmdlMSkge1xuICAgIHJldHVybiAocmFuZ2UwLnN0YXJ0ID09PSBudWxsID8gbnVsbCA6IHJhbmdlMC5zdGFydC52YWx1ZU9mKCkpID09PSAocmFuZ2UxLnN0YXJ0ID09PSBudWxsID8gbnVsbCA6IHJhbmdlMS5zdGFydC52YWx1ZU9mKCkpICYmXG4gICAgICAgIChyYW5nZTAuZW5kID09PSBudWxsID8gbnVsbCA6IHJhbmdlMC5lbmQudmFsdWVPZigpKSA9PT0gKHJhbmdlMS5lbmQgPT09IG51bGwgPyBudWxsIDogcmFuZ2UxLmVuZC52YWx1ZU9mKCkpO1xufVxuZnVuY3Rpb24gcmFuZ2VzSW50ZXJzZWN0KHJhbmdlMCwgcmFuZ2UxKSB7XG4gICAgcmV0dXJuIChyYW5nZTAuZW5kID09PSBudWxsIHx8IHJhbmdlMS5zdGFydCA9PT0gbnVsbCB8fCByYW5nZTAuZW5kID4gcmFuZ2UxLnN0YXJ0KSAmJlxuICAgICAgICAocmFuZ2UwLnN0YXJ0ID09PSBudWxsIHx8IHJhbmdlMS5lbmQgPT09IG51bGwgfHwgcmFuZ2UwLnN0YXJ0IDwgcmFuZ2UxLmVuZCk7XG59XG5mdW5jdGlvbiByYW5nZUNvbnRhaW5zUmFuZ2Uob3V0ZXJSYW5nZSwgaW5uZXJSYW5nZSkge1xuICAgIHJldHVybiAob3V0ZXJSYW5nZS5zdGFydCA9PT0gbnVsbCB8fCAoaW5uZXJSYW5nZS5zdGFydCAhPT0gbnVsbCAmJiBpbm5lclJhbmdlLnN0YXJ0ID49IG91dGVyUmFuZ2Uuc3RhcnQpKSAmJlxuICAgICAgICAob3V0ZXJSYW5nZS5lbmQgPT09IG51bGwgfHwgKGlubmVyUmFuZ2UuZW5kICE9PSBudWxsICYmIGlubmVyUmFuZ2UuZW5kIDw9IG91dGVyUmFuZ2UuZW5kKSk7XG59XG5mdW5jdGlvbiByYW5nZUNvbnRhaW5zTWFya2VyKHJhbmdlLCBkYXRlKSB7XG4gICAgcmV0dXJuIChyYW5nZS5zdGFydCA9PT0gbnVsbCB8fCBkYXRlID49IHJhbmdlLnN0YXJ0KSAmJlxuICAgICAgICAocmFuZ2UuZW5kID09PSBudWxsIHx8IGRhdGUgPCByYW5nZS5lbmQpO1xufVxuLy8gSWYgdGhlIGdpdmVuIGRhdGUgaXMgbm90IHdpdGhpbiB0aGUgZ2l2ZW4gcmFuZ2UsIG1vdmUgaXQgaW5zaWRlLlxuLy8gKElmIGl0J3MgcGFzdCB0aGUgZW5kLCBtYWtlIGl0IG9uZSBtaWxsaXNlY29uZCBiZWZvcmUgdGhlIGVuZCkuXG5mdW5jdGlvbiBjb25zdHJhaW5NYXJrZXJUb1JhbmdlKGRhdGUsIHJhbmdlKSB7XG4gICAgaWYgKHJhbmdlLnN0YXJ0ICE9IG51bGwgJiYgZGF0ZSA8IHJhbmdlLnN0YXJ0KSB7XG4gICAgICAgIHJldHVybiByYW5nZS5zdGFydDtcbiAgICB9XG4gICAgaWYgKHJhbmdlLmVuZCAhPSBudWxsICYmIGRhdGUgPj0gcmFuZ2UuZW5kKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShyYW5nZS5lbmQudmFsdWVPZigpIC0gMSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRlO1xufVxuXG4vKiBEYXRlIHN0dWZmIHRoYXQgZG9lc24ndCBiZWxvbmcgaW4gZGF0ZWxpYiBjb3JlXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8vIGdpdmVuIGEgdGltZWQgcmFuZ2UsIGNvbXB1dGVzIGFuIGFsbC1kYXkgcmFuZ2UgdGhhdCBoYXMgdGhlIHNhbWUgZXhhY3QgZHVyYXRpb24sXG4vLyBidXQgd2hvc2Ugc3RhcnQgdGltZSBpcyBhbGlnbmVkIHdpdGggdGhlIHN0YXJ0IG9mIHRoZSBkYXkuXG5mdW5jdGlvbiBjb21wdXRlQWxpZ25lZERheVJhbmdlKHRpbWVkUmFuZ2UpIHtcbiAgICBsZXQgZGF5Q250ID0gTWF0aC5mbG9vcihkaWZmRGF5cyh0aW1lZFJhbmdlLnN0YXJ0LCB0aW1lZFJhbmdlLmVuZCkpIHx8IDE7XG4gICAgbGV0IHN0YXJ0ID0gc3RhcnRPZkRheSh0aW1lZFJhbmdlLnN0YXJ0KTtcbiAgICBsZXQgZW5kID0gYWRkRGF5cyhzdGFydCwgZGF5Q250KTtcbiAgICByZXR1cm4geyBzdGFydCwgZW5kIH07XG59XG4vLyBnaXZlbiBhIHRpbWVkIHJhbmdlLCBjb21wdXRlcyBhbiBhbGwtZGF5IHJhbmdlIGJhc2VkIG9uIGhvdyBmb3IgdGhlIGVuZCBkYXRlIGJsZWVkcyBpbnRvIHRoZSBuZXh0IGRheVxuLy8gVE9ETzogZ2l2ZSBuZXh0RGF5VGhyZXNob2xkIGEgZGVmYXVsdCBhcmdcbmZ1bmN0aW9uIGNvbXB1dGVWaXNpYmxlRGF5UmFuZ2UodGltZWRSYW5nZSwgbmV4dERheVRocmVzaG9sZCA9IGNyZWF0ZUR1cmF0aW9uKDApKSB7XG4gICAgbGV0IHN0YXJ0RGF5ID0gbnVsbDtcbiAgICBsZXQgZW5kRGF5ID0gbnVsbDtcbiAgICBpZiAodGltZWRSYW5nZS5lbmQpIHtcbiAgICAgICAgZW5kRGF5ID0gc3RhcnRPZkRheSh0aW1lZFJhbmdlLmVuZCk7XG4gICAgICAgIGxldCBlbmRUaW1lTVMgPSB0aW1lZFJhbmdlLmVuZC52YWx1ZU9mKCkgLSBlbmREYXkudmFsdWVPZigpOyAvLyAjIG9mIG1pbGxpc2Vjb25kcyBpbnRvIGBlbmREYXlgXG4gICAgICAgIC8vIElmIHRoZSBlbmQgdGltZSBpcyBhY3R1YWxseSBpbmNsdXNpdmVseSBwYXJ0IG9mIHRoZSBuZXh0IGRheSBhbmQgaXMgZXF1YWwgdG8gb3JcbiAgICAgICAgLy8gYmV5b25kIHRoZSBuZXh0IGRheSB0aHJlc2hvbGQsIGFkanVzdCB0aGUgZW5kIHRvIGJlIHRoZSBleGNsdXNpdmUgZW5kIG9mIGBlbmREYXlgLlxuICAgICAgICAvLyBPdGhlcndpc2UsIGxlYXZpbmcgaXQgYXMgaW5jbHVzaXZlIHdpbGwgY2F1c2UgaXQgdG8gZXhjbHVkZSBgZW5kRGF5YC5cbiAgICAgICAgaWYgKGVuZFRpbWVNUyAmJiBlbmRUaW1lTVMgPj0gYXNSb3VnaE1zKG5leHREYXlUaHJlc2hvbGQpKSB7XG4gICAgICAgICAgICBlbmREYXkgPSBhZGREYXlzKGVuZERheSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRpbWVkUmFuZ2Uuc3RhcnQpIHtcbiAgICAgICAgc3RhcnREYXkgPSBzdGFydE9mRGF5KHRpbWVkUmFuZ2Uuc3RhcnQpOyAvLyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBkYXkgdGhlIHJhbmdlIHN0YXJ0c1xuICAgICAgICAvLyBJZiBlbmQgaXMgd2l0aGluIGBzdGFydERheWAgYnV0IG5vdCBwYXN0IG5leHREYXlUaHJlc2hvbGQsIGFzc2lnbiB0aGUgZGVmYXVsdCBkdXJhdGlvbiBvZiBvbmUgZGF5LlxuICAgICAgICBpZiAoZW5kRGF5ICYmIGVuZERheSA8PSBzdGFydERheSkge1xuICAgICAgICAgICAgZW5kRGF5ID0gYWRkRGF5cyhzdGFydERheSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0RGF5LCBlbmQ6IGVuZERheSB9O1xufVxuLy8gc3BhbnMgZnJvbSBvbmUgZGF5IGludG8gYW5vdGhlcj9cbmZ1bmN0aW9uIGlzTXVsdGlEYXlSYW5nZShyYW5nZSkge1xuICAgIGxldCB2aXNpYmxlUmFuZ2UgPSBjb21wdXRlVmlzaWJsZURheVJhbmdlKHJhbmdlKTtcbiAgICByZXR1cm4gZGlmZkRheXModmlzaWJsZVJhbmdlLnN0YXJ0LCB2aXNpYmxlUmFuZ2UuZW5kKSA+IDE7XG59XG5mdW5jdGlvbiBkaWZmRGF0ZXMoZGF0ZTAsIGRhdGUxLCBkYXRlRW52LCBsYXJnZVVuaXQpIHtcbiAgICBpZiAobGFyZ2VVbml0ID09PSAneWVhcicpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKGRhdGVFbnYuZGlmZldob2xlWWVhcnMoZGF0ZTAsIGRhdGUxKSwgJ3llYXInKTtcbiAgICB9XG4gICAgaWYgKGxhcmdlVW5pdCA9PT0gJ21vbnRoJykge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oZGF0ZUVudi5kaWZmV2hvbGVNb250aHMoZGF0ZTAsIGRhdGUxKSwgJ21vbnRoJyk7XG4gICAgfVxuICAgIHJldHVybiBkaWZmRGF5QW5kVGltZShkYXRlMCwgZGF0ZTEpOyAvLyByZXR1cm5zIGEgZHVyYXRpb25cbn1cblxuZnVuY3Rpb24gcmVkdWNlQ3VycmVudERhdGUoY3VycmVudERhdGUsIGFjdGlvbikge1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnQ0hBTkdFX0RBVEUnOlxuICAgICAgICAgICAgcmV0dXJuIGFjdGlvbi5kYXRlTWFya2VyO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnREYXRlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEluaXRpYWxEYXRlKG9wdGlvbnMsIGRhdGVFbnYpIHtcbiAgICBsZXQgaW5pdGlhbERhdGVJbnB1dCA9IG9wdGlvbnMuaW5pdGlhbERhdGU7XG4gICAgLy8gY29tcHV0ZSB0aGUgaW5pdGlhbCBhbWJpZy10aW1lem9uZSBkYXRlXG4gICAgaWYgKGluaXRpYWxEYXRlSW5wdXQgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZGF0ZUVudi5jcmVhdGVNYXJrZXIoaW5pdGlhbERhdGVJbnB1dCk7XG4gICAgfVxuICAgIHJldHVybiBnZXROb3cob3B0aW9ucy5ub3csIGRhdGVFbnYpOyAvLyBnZXROb3cgYWxyZWFkeSByZXR1cm5zIHVuem9uZWRcbn1cbmZ1bmN0aW9uIGdldE5vdyhub3dJbnB1dCwgZGF0ZUVudikge1xuICAgIGlmICh0eXBlb2Ygbm93SW5wdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgbm93SW5wdXQgPSBub3dJbnB1dCgpO1xuICAgIH1cbiAgICBpZiAobm93SW5wdXQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZGF0ZUVudi5jcmVhdGVOb3dNYXJrZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGVFbnYuY3JlYXRlTWFya2VyKG5vd0lucHV0KTtcbn1cblxuY2xhc3MgRGF0ZVByb2ZpbGVHZW5lcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgICAgdGhpcy5ub3dEYXRlID0gZ2V0Tm93KHByb3BzLm5vd0lucHV0LCBwcm9wcy5kYXRlRW52KTtcbiAgICAgICAgdGhpcy5pbml0SGlkZGVuRGF5cygpO1xuICAgIH1cbiAgICAvKiBEYXRlIFJhbmdlIENvbXB1dGF0aW9uXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgICAvLyBCdWlsZHMgYSBzdHJ1Y3R1cmUgd2l0aCBpbmZvIGFib3V0IHdoYXQgdGhlIGRhdGVzL3JhbmdlcyB3aWxsIGJlIGZvciB0aGUgXCJwcmV2XCIgdmlldy5cbiAgICBidWlsZFByZXYoY3VycmVudERhdGVQcm9maWxlLCBjdXJyZW50RGF0ZSwgZm9yY2VUb1ZhbGlkKSB7XG4gICAgICAgIGxldCB7IGRhdGVFbnYgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCBwcmV2RGF0ZSA9IGRhdGVFbnYuc3VidHJhY3QoZGF0ZUVudi5zdGFydE9mKGN1cnJlbnREYXRlLCBjdXJyZW50RGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdCksIC8vIGltcG9ydGFudCBmb3Igc3RhcnQtb2YtbW9udGhcbiAgICAgICAgY3VycmVudERhdGVQcm9maWxlLmRhdGVJbmNyZW1lbnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5idWlsZChwcmV2RGF0ZSwgLTEsIGZvcmNlVG9WYWxpZCk7XG4gICAgfVxuICAgIC8vIEJ1aWxkcyBhIHN0cnVjdHVyZSB3aXRoIGluZm8gYWJvdXQgd2hhdCB0aGUgZGF0ZXMvcmFuZ2VzIHdpbGwgYmUgZm9yIHRoZSBcIm5leHRcIiB2aWV3LlxuICAgIGJ1aWxkTmV4dChjdXJyZW50RGF0ZVByb2ZpbGUsIGN1cnJlbnREYXRlLCBmb3JjZVRvVmFsaWQpIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IG5leHREYXRlID0gZGF0ZUVudi5hZGQoZGF0ZUVudi5zdGFydE9mKGN1cnJlbnREYXRlLCBjdXJyZW50RGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdCksIC8vIGltcG9ydGFudCBmb3Igc3RhcnQtb2YtbW9udGhcbiAgICAgICAgY3VycmVudERhdGVQcm9maWxlLmRhdGVJbmNyZW1lbnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5idWlsZChuZXh0RGF0ZSwgMSwgZm9yY2VUb1ZhbGlkKTtcbiAgICB9XG4gICAgLy8gQnVpbGRzIGEgc3RydWN0dXJlIGhvbGRpbmcgZGF0ZXMvcmFuZ2VzIGZvciByZW5kZXJpbmcgYXJvdW5kIHRoZSBnaXZlbiBkYXRlLlxuICAgIC8vIE9wdGlvbmFsIGRpcmVjdGlvbiBwYXJhbSBpbmRpY2F0ZXMgd2hldGhlciB0aGUgZGF0ZSBpcyBiZWluZyBpbmNyZW1lbnRlZC9kZWNyZW1lbnRlZFxuICAgIC8vIGZyb20gaXRzIHByZXZpb3VzIHZhbHVlLiBkZWNyZW1lbnRlZCA9IC0xLCBpbmNyZW1lbnRlZCA9IDEgKGRlZmF1bHQpLlxuICAgIGJ1aWxkKGN1cnJlbnREYXRlLCBkaXJlY3Rpb24sIGZvcmNlVG9WYWxpZCA9IHRydWUpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB2YWxpZFJhbmdlO1xuICAgICAgICBsZXQgY3VycmVudEluZm87XG4gICAgICAgIGxldCBpc1JhbmdlQWxsRGF5O1xuICAgICAgICBsZXQgcmVuZGVyUmFuZ2U7XG4gICAgICAgIGxldCBhY3RpdmVSYW5nZTtcbiAgICAgICAgbGV0IGlzVmFsaWQ7XG4gICAgICAgIHZhbGlkUmFuZ2UgPSB0aGlzLmJ1aWxkVmFsaWRSYW5nZSgpO1xuICAgICAgICB2YWxpZFJhbmdlID0gdGhpcy50cmltSGlkZGVuRGF5cyh2YWxpZFJhbmdlKTtcbiAgICAgICAgaWYgKGZvcmNlVG9WYWxpZCkge1xuICAgICAgICAgICAgY3VycmVudERhdGUgPSBjb25zdHJhaW5NYXJrZXJUb1JhbmdlKGN1cnJlbnREYXRlLCB2YWxpZFJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50SW5mbyA9IHRoaXMuYnVpbGRDdXJyZW50UmFuZ2VJbmZvKGN1cnJlbnREYXRlLCBkaXJlY3Rpb24pO1xuICAgICAgICBpc1JhbmdlQWxsRGF5ID0gL14oeWVhcnxtb250aHx3ZWVrfGRheSkkLy50ZXN0KGN1cnJlbnRJbmZvLnVuaXQpO1xuICAgICAgICByZW5kZXJSYW5nZSA9IHRoaXMuYnVpbGRSZW5kZXJSYW5nZSh0aGlzLnRyaW1IaWRkZW5EYXlzKGN1cnJlbnRJbmZvLnJhbmdlKSwgY3VycmVudEluZm8udW5pdCwgaXNSYW5nZUFsbERheSk7XG4gICAgICAgIHJlbmRlclJhbmdlID0gdGhpcy50cmltSGlkZGVuRGF5cyhyZW5kZXJSYW5nZSk7XG4gICAgICAgIGFjdGl2ZVJhbmdlID0gcmVuZGVyUmFuZ2U7XG4gICAgICAgIGlmICghcHJvcHMuc2hvd05vbkN1cnJlbnREYXRlcykge1xuICAgICAgICAgICAgYWN0aXZlUmFuZ2UgPSBpbnRlcnNlY3RSYW5nZXMoYWN0aXZlUmFuZ2UsIGN1cnJlbnRJbmZvLnJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBhY3RpdmVSYW5nZSA9IHRoaXMuYWRqdXN0QWN0aXZlUmFuZ2UoYWN0aXZlUmFuZ2UpO1xuICAgICAgICBhY3RpdmVSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhhY3RpdmVSYW5nZSwgdmFsaWRSYW5nZSk7IC8vIG1pZ2h0IHJldHVybiBudWxsXG4gICAgICAgIC8vIGl0J3MgaW52YWxpZCBpZiB0aGUgb3JpZ2luYWxseSByZXF1ZXN0ZWQgZGF0ZSBpcyBub3QgY29udGFpbmVkLFxuICAgICAgICAvLyBvciBpZiB0aGUgcmFuZ2UgaXMgY29tcGxldGVseSBvdXRzaWRlIG9mIHRoZSB2YWxpZCByYW5nZS5cbiAgICAgICAgaXNWYWxpZCA9IHJhbmdlc0ludGVyc2VjdChjdXJyZW50SW5mby5yYW5nZSwgdmFsaWRSYW5nZSk7XG4gICAgICAgIC8vIEhBQ0s6IGNvbnN0cmFpbiB0byByZW5kZXItcmFuZ2Ugc28gYGN1cnJlbnREYXRlYCBpcyBtb3JlIHVzZWZ1bCB0byB2aWV3IHJlbmRlcmluZ1xuICAgICAgICBpZiAoIXJhbmdlQ29udGFpbnNNYXJrZXIocmVuZGVyUmFuZ2UsIGN1cnJlbnREYXRlKSkge1xuICAgICAgICAgICAgY3VycmVudERhdGUgPSByZW5kZXJSYW5nZS5zdGFydDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3VycmVudERhdGUsXG4gICAgICAgICAgICAvLyBjb25zdHJhaW50IGZvciB3aGVyZSBwcmV2L25leHQgb3BlcmF0aW9ucyBjYW4gZ28gYW5kIHdoZXJlIGV2ZW50cyBjYW4gYmUgZHJhZ2dlZC9yZXNpemVkIHRvLlxuICAgICAgICAgICAgLy8gYW4gb2JqZWN0IHdpdGggb3B0aW9uYWwgc3RhcnQgYW5kIGVuZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgdmFsaWRSYW5nZSxcbiAgICAgICAgICAgIC8vIHJhbmdlIHRoZSB2aWV3IGlzIGZvcm1hbGx5IHJlc3BvbnNpYmxlIGZvci5cbiAgICAgICAgICAgIC8vIGZvciBleGFtcGxlLCBhIG1vbnRoIHZpZXcgbWlnaHQgaGF2ZSAxc3QtMzFzdCwgZXhjbHVkaW5nIHBhZGRlZCBkYXRlc1xuICAgICAgICAgICAgY3VycmVudFJhbmdlOiBjdXJyZW50SW5mby5yYW5nZSxcbiAgICAgICAgICAgIC8vIG5hbWUgb2YgbGFyZ2VzdCB1bml0IGJlaW5nIGRpc3BsYXllZCwgbGlrZSBcIm1vbnRoXCIgb3IgXCJ3ZWVrXCJcbiAgICAgICAgICAgIGN1cnJlbnRSYW5nZVVuaXQ6IGN1cnJlbnRJbmZvLnVuaXQsXG4gICAgICAgICAgICBpc1JhbmdlQWxsRGF5LFxuICAgICAgICAgICAgLy8gZGF0ZXMgdGhhdCBkaXNwbGF5IGV2ZW50cyBhbmQgYWNjZXB0IGRyYWctbi1kcm9wXG4gICAgICAgICAgICAvLyB3aWxsIGJlIGBudWxsYCBpZiBubyBkYXRlcyBhY2NlcHQgZXZlbnRzXG4gICAgICAgICAgICBhY3RpdmVSYW5nZSxcbiAgICAgICAgICAgIC8vIGRhdGUgcmFuZ2Ugd2l0aCBhIHJlbmRlcmVkIHNrZWxldG9uXG4gICAgICAgICAgICAvLyBpbmNsdWRlcyBub3QtYWN0aXZlIGRheXMgdGhhdCBuZWVkIHNvbWUgc29ydCBvZiBET01cbiAgICAgICAgICAgIHJlbmRlclJhbmdlLFxuICAgICAgICAgICAgLy8gRHVyYXRpb24gb2JqZWN0IHRoYXQgZGVub3RlcyB0aGUgZmlyc3QgdmlzaWJsZSB0aW1lIG9mIGFueSBnaXZlbiBkYXlcbiAgICAgICAgICAgIHNsb3RNaW5UaW1lOiBwcm9wcy5zbG90TWluVGltZSxcbiAgICAgICAgICAgIC8vIER1cmF0aW9uIG9iamVjdCB0aGF0IGRlbm90ZXMgdGhlIGV4Y2x1c2l2ZSB2aXNpYmxlIGVuZCB0aW1lIG9mIGFueSBnaXZlbiBkYXlcbiAgICAgICAgICAgIHNsb3RNYXhUaW1lOiBwcm9wcy5zbG90TWF4VGltZSxcbiAgICAgICAgICAgIGlzVmFsaWQsXG4gICAgICAgICAgICAvLyBob3cgZmFyIHRoZSBjdXJyZW50IGRhdGUgd2lsbCBtb3ZlIGZvciBhIHByZXYvbmV4dCBvcGVyYXRpb25cbiAgICAgICAgICAgIGRhdGVJbmNyZW1lbnQ6IHRoaXMuYnVpbGREYXRlSW5jcmVtZW50KGN1cnJlbnRJbmZvLmR1cmF0aW9uKSxcbiAgICAgICAgICAgIC8vIHBhc3MgYSBmYWxsYmFjayAobWlnaHQgYmUgbnVsbCkgXlxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBCdWlsZHMgYW4gb2JqZWN0IHdpdGggb3B0aW9uYWwgc3RhcnQvZW5kIHByb3BlcnRpZXMuXG4gICAgLy8gSW5kaWNhdGVzIHRoZSBtaW5pbXVtL21heGltdW0gZGF0ZXMgdG8gZGlzcGxheS5cbiAgICAvLyBub3QgcmVzcG9uc2libGUgZm9yIHRyaW1taW5nIGhpZGRlbiBkYXlzLlxuICAgIGJ1aWxkVmFsaWRSYW5nZSgpIHtcbiAgICAgICAgbGV0IGlucHV0ID0gdGhpcy5wcm9wcy52YWxpZFJhbmdlSW5wdXQ7XG4gICAgICAgIGxldCBzaW1wbGVJbnB1dCA9IHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBpbnB1dC5jYWxsKHRoaXMucHJvcHMuY2FsZW5kYXJBcGksIHRoaXMubm93RGF0ZSlcbiAgICAgICAgICAgIDogaW5wdXQ7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZmluZVJhbmdlKHNpbXBsZUlucHV0KSB8fFxuICAgICAgICAgICAgeyBzdGFydDogbnVsbCwgZW5kOiBudWxsIH07IC8vIGNvbXBsZXRlbHkgb3Blbi1lbmRlZFxuICAgIH1cbiAgICAvLyBCdWlsZHMgYSBzdHJ1Y3R1cmUgd2l0aCBpbmZvIGFib3V0IHRoZSBcImN1cnJlbnRcIiByYW5nZSwgdGhlIHJhbmdlIHRoYXQgaXNcbiAgICAvLyBoaWdobGlnaHRlZCBhcyBiZWluZyB0aGUgY3VycmVudCBtb250aCBmb3IgZXhhbXBsZS5cbiAgICAvLyBTZWUgYnVpbGQoKSBmb3IgYSBkZXNjcmlwdGlvbiBvZiBgZGlyZWN0aW9uYC5cbiAgICAvLyBHdWFyYW50ZWVkIHRvIGhhdmUgYHJhbmdlYCBhbmQgYHVuaXRgIHByb3BlcnRpZXMuIGBkdXJhdGlvbmAgaXMgb3B0aW9uYWwuXG4gICAgYnVpbGRDdXJyZW50UmFuZ2VJbmZvKGRhdGUsIGRpcmVjdGlvbikge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGR1cmF0aW9uID0gbnVsbDtcbiAgICAgICAgbGV0IHVuaXQgPSBudWxsO1xuICAgICAgICBsZXQgcmFuZ2UgPSBudWxsO1xuICAgICAgICBsZXQgZGF5Q291bnQ7XG4gICAgICAgIGlmIChwcm9wcy5kdXJhdGlvbikge1xuICAgICAgICAgICAgZHVyYXRpb24gPSBwcm9wcy5kdXJhdGlvbjtcbiAgICAgICAgICAgIHVuaXQgPSBwcm9wcy5kdXJhdGlvblVuaXQ7XG4gICAgICAgICAgICByYW5nZSA9IHRoaXMuYnVpbGRSYW5nZUZyb21EdXJhdGlvbihkYXRlLCBkaXJlY3Rpb24sIGR1cmF0aW9uLCB1bml0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoZGF5Q291bnQgPSB0aGlzLnByb3BzLmRheUNvdW50KSkge1xuICAgICAgICAgICAgdW5pdCA9ICdkYXknO1xuICAgICAgICAgICAgcmFuZ2UgPSB0aGlzLmJ1aWxkUmFuZ2VGcm9tRGF5Q291bnQoZGF0ZSwgZGlyZWN0aW9uLCBkYXlDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHJhbmdlID0gdGhpcy5idWlsZEN1c3RvbVZpc2libGVSYW5nZShkYXRlKSkpIHtcbiAgICAgICAgICAgIHVuaXQgPSBwcm9wcy5kYXRlRW52LmdyZWF0ZXN0V2hvbGVVbml0KHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQpLnVuaXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHRoaXMuZ2V0RmFsbGJhY2tEdXJhdGlvbigpO1xuICAgICAgICAgICAgdW5pdCA9IGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvcihkdXJhdGlvbikudW5pdDtcbiAgICAgICAgICAgIHJhbmdlID0gdGhpcy5idWlsZFJhbmdlRnJvbUR1cmF0aW9uKGRhdGUsIGRpcmVjdGlvbiwgZHVyYXRpb24sIHVuaXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGR1cmF0aW9uLCB1bml0LCByYW5nZSB9O1xuICAgIH1cbiAgICBnZXRGYWxsYmFja0R1cmF0aW9uKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oeyBkYXk6IDEgfSk7XG4gICAgfVxuICAgIC8vIFJldHVybnMgYSBuZXcgYWN0aXZlUmFuZ2UgdG8gaGF2ZSB0aW1lIHZhbHVlcyAodW4tYW1iaWd1YXRlKVxuICAgIC8vIHNsb3RNaW5UaW1lIG9yIHNsb3RNYXhUaW1lIGNhdXNlcyB0aGUgcmFuZ2UgdG8gZXhwYW5kLlxuICAgIGFkanVzdEFjdGl2ZVJhbmdlKHJhbmdlKSB7XG4gICAgICAgIGxldCB7IGRhdGVFbnYsIHVzZXNNaW5NYXhUaW1lLCBzbG90TWluVGltZSwgc2xvdE1heFRpbWUgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCB7IHN0YXJ0LCBlbmQgfSA9IHJhbmdlO1xuICAgICAgICBpZiAodXNlc01pbk1heFRpbWUpIHtcbiAgICAgICAgICAgIC8vIGV4cGFuZCBhY3RpdmUgcmFuZ2UgaWYgc2xvdE1pblRpbWUgaXMgbmVnYXRpdmUgKHdoeSBub3Qgd2hlbiBwb3NpdGl2ZT8pXG4gICAgICAgICAgICBpZiAoYXNSb3VnaERheXMoc2xvdE1pblRpbWUpIDwgMCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnRPZkRheShzdGFydCk7IC8vIG5lY2Vzc2FyeT9cbiAgICAgICAgICAgICAgICBzdGFydCA9IGRhdGVFbnYuYWRkKHN0YXJ0LCBzbG90TWluVGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBleHBhbmQgYWN0aXZlIHJhbmdlIGlmIHNsb3RNYXhUaW1lIGlzIGJleW9uZCBvbmUgZGF5ICh3aHkgbm90IHdoZW4gbmVnYXRpdmU/KVxuICAgICAgICAgICAgaWYgKGFzUm91Z2hEYXlzKHNsb3RNYXhUaW1lKSA+IDEpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBzdGFydE9mRGF5KGVuZCk7IC8vIG5lY2Vzc2FyeT9cbiAgICAgICAgICAgICAgICBlbmQgPSBhZGREYXlzKGVuZCwgLTEpO1xuICAgICAgICAgICAgICAgIGVuZCA9IGRhdGVFbnYuYWRkKGVuZCwgc2xvdE1heFRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXJ0LCBlbmQgfTtcbiAgICB9XG4gICAgLy8gQnVpbGRzIHRoZSBcImN1cnJlbnRcIiByYW5nZSB3aGVuIGl0IGlzIHNwZWNpZmllZCBhcyBhbiBleHBsaWNpdCBkdXJhdGlvbi5cbiAgICAvLyBgdW5pdGAgaXMgdGhlIGFscmVhZHktY29tcHV0ZWQgZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yIHVuaXQgb2YgZHVyYXRpb24uXG4gICAgYnVpbGRSYW5nZUZyb21EdXJhdGlvbihkYXRlLCBkaXJlY3Rpb24sIGR1cmF0aW9uLCB1bml0KSB7XG4gICAgICAgIGxldCB7IGRhdGVFbnYsIGRhdGVBbGlnbm1lbnQgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCBzdGFydDtcbiAgICAgICAgbGV0IGVuZDtcbiAgICAgICAgbGV0IHJlcztcbiAgICAgICAgLy8gY29tcHV0ZSB3aGF0IHRoZSBhbGlnbm1lbnQgc2hvdWxkIGJlXG4gICAgICAgIGlmICghZGF0ZUFsaWdubWVudCkge1xuICAgICAgICAgICAgbGV0IHsgZGF0ZUluY3JlbWVudCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGlmIChkYXRlSW5jcmVtZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gdXNlIHRoZSBzbWFsbGVyIG9mIHRoZSB0d28gdW5pdHNcbiAgICAgICAgICAgICAgICBpZiAoYXNSb3VnaE1zKGRhdGVJbmNyZW1lbnQpIDwgYXNSb3VnaE1zKGR1cmF0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRlQWxpZ25tZW50ID0gZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yKGRhdGVJbmNyZW1lbnQpLnVuaXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkYXRlQWxpZ25tZW50ID0gdW5pdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRlQWxpZ25tZW50ID0gdW5pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgdmlldyBkaXNwbGF5cyBhIHNpbmdsZSBkYXkgb3Igc21hbGxlclxuICAgICAgICBpZiAoYXNSb3VnaERheXMoZHVyYXRpb24pIDw9IDEpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSGlkZGVuRGF5KHN0YXJ0KSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5za2lwSGlkZGVuRGF5cyhzdGFydCwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHN0YXJ0T2ZEYXkoc3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNvbXB1dGVSZXMoKSB7XG4gICAgICAgICAgICBzdGFydCA9IGRhdGVFbnYuc3RhcnRPZihkYXRlLCBkYXRlQWxpZ25tZW50KTtcbiAgICAgICAgICAgIGVuZCA9IGRhdGVFbnYuYWRkKHN0YXJ0LCBkdXJhdGlvbik7XG4gICAgICAgICAgICByZXMgPSB7IHN0YXJ0LCBlbmQgfTtcbiAgICAgICAgfVxuICAgICAgICBjb21wdXRlUmVzKCk7XG4gICAgICAgIC8vIGlmIHJhbmdlIGlzIGNvbXBsZXRlbHkgZW52ZWxvcGVkIGJ5IGhpZGRlbiBkYXlzLCBnbyBwYXN0IHRoZSBoaWRkZW4gZGF5c1xuICAgICAgICBpZiAoIXRoaXMudHJpbUhpZGRlbkRheXMocmVzKSkge1xuICAgICAgICAgICAgZGF0ZSA9IHRoaXMuc2tpcEhpZGRlbkRheXMoZGF0ZSwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIGNvbXB1dGVSZXMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICAvLyBCdWlsZHMgdGhlIFwiY3VycmVudFwiIHJhbmdlIHdoZW4gYSBkYXlDb3VudCBpcyBzcGVjaWZpZWQuXG4gICAgYnVpbGRSYW5nZUZyb21EYXlDb3VudChkYXRlLCBkaXJlY3Rpb24sIGRheUNvdW50KSB7XG4gICAgICAgIGxldCB7IGRhdGVFbnYsIGRhdGVBbGlnbm1lbnQgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCBydW5uaW5nQ291bnQgPSAwO1xuICAgICAgICBsZXQgc3RhcnQgPSBkYXRlO1xuICAgICAgICBsZXQgZW5kO1xuICAgICAgICBpZiAoZGF0ZUFsaWdubWVudCkge1xuICAgICAgICAgICAgc3RhcnQgPSBkYXRlRW52LnN0YXJ0T2Yoc3RhcnQsIGRhdGVBbGlnbm1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0ID0gc3RhcnRPZkRheShzdGFydCk7XG4gICAgICAgIHN0YXJ0ID0gdGhpcy5za2lwSGlkZGVuRGF5cyhzdGFydCwgZGlyZWN0aW9uKTtcbiAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGVuZCA9IGFkZERheXMoZW5kLCAxKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0hpZGRlbkRheShlbmQpKSB7XG4gICAgICAgICAgICAgICAgcnVubmluZ0NvdW50ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKHJ1bm5pbmdDb3VudCA8IGRheUNvdW50KTtcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQsIGVuZCB9O1xuICAgIH1cbiAgICAvLyBCdWlsZHMgYSBub3JtYWxpemVkIHJhbmdlIG9iamVjdCBmb3IgdGhlIFwidmlzaWJsZVwiIHJhbmdlLFxuICAgIC8vIHdoaWNoIGlzIGEgd2F5IHRvIGRlZmluZSB0aGUgY3VycmVudFJhbmdlIGFuZCBhY3RpdmVSYW5nZSBhdCB0aGUgc2FtZSB0aW1lLlxuICAgIGJ1aWxkQ3VzdG9tVmlzaWJsZVJhbmdlKGRhdGUpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBpbnB1dCA9IHByb3BzLnZpc2libGVSYW5nZUlucHV0O1xuICAgICAgICBsZXQgc2ltcGxlSW5wdXQgPSB0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gaW5wdXQuY2FsbChwcm9wcy5jYWxlbmRhckFwaSwgcHJvcHMuZGF0ZUVudi50b0RhdGUoZGF0ZSkpXG4gICAgICAgICAgICA6IGlucHV0O1xuICAgICAgICBsZXQgcmFuZ2UgPSB0aGlzLnJlZmluZVJhbmdlKHNpbXBsZUlucHV0KTtcbiAgICAgICAgaWYgKHJhbmdlICYmIChyYW5nZS5zdGFydCA9PSBudWxsIHx8IHJhbmdlLmVuZCA9PSBudWxsKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH1cbiAgICAvLyBDb21wdXRlcyB0aGUgcmFuZ2UgdGhhdCB3aWxsIHJlcHJlc2VudCB0aGUgZWxlbWVudC9jZWxscyBmb3IgKnJlbmRlcmluZyosXG4gICAgLy8gYnV0IHdoaWNoIG1heSBoYXZlIHZvaWRlZCBkYXlzL3RpbWVzLlxuICAgIC8vIG5vdCByZXNwb25zaWJsZSBmb3IgdHJpbW1pbmcgaGlkZGVuIGRheXMuXG4gICAgYnVpbGRSZW5kZXJSYW5nZShjdXJyZW50UmFuZ2UsIGN1cnJlbnRSYW5nZVVuaXQsIGlzUmFuZ2VBbGxEYXkpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRSYW5nZTtcbiAgICB9XG4gICAgLy8gQ29tcHV0ZSB0aGUgZHVyYXRpb24gdmFsdWUgdGhhdCBzaG91bGQgYmUgYWRkZWQvc3Vic3RyYWN0ZWQgdG8gdGhlIGN1cnJlbnQgZGF0ZVxuICAgIC8vIHdoZW4gYSBwcmV2L25leHQgb3BlcmF0aW9uIGhhcHBlbnMuXG4gICAgYnVpbGREYXRlSW5jcmVtZW50KGZhbGxiYWNrKSB7XG4gICAgICAgIGxldCB7IGRhdGVJbmNyZW1lbnQgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCBjdXN0b21BbGlnbm1lbnQ7XG4gICAgICAgIGlmIChkYXRlSW5jcmVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0ZUluY3JlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGN1c3RvbUFsaWdubWVudCA9IHRoaXMucHJvcHMuZGF0ZUFsaWdubWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbigxLCBjdXN0b21BbGlnbm1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7IGRheXM6IDEgfSk7XG4gICAgfVxuICAgIHJlZmluZVJhbmdlKHJhbmdlSW5wdXQpIHtcbiAgICAgICAgaWYgKHJhbmdlSW5wdXQpIHtcbiAgICAgICAgICAgIGxldCByYW5nZSA9IHBhcnNlUmFuZ2UocmFuZ2VJbnB1dCwgdGhpcy5wcm9wcy5kYXRlRW52KTtcbiAgICAgICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgICAgIHJhbmdlID0gY29tcHV0ZVZpc2libGVEYXlSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qIEhpZGRlbiBEYXlzXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgICAvLyBJbml0aWFsaXplcyBpbnRlcm5hbCB2YXJpYWJsZXMgcmVsYXRlZCB0byBjYWxjdWxhdGluZyBoaWRkZW4gZGF5cy1vZi13ZWVrXG4gICAgaW5pdEhpZGRlbkRheXMoKSB7XG4gICAgICAgIGxldCBoaWRkZW5EYXlzID0gdGhpcy5wcm9wcy5oaWRkZW5EYXlzIHx8IFtdOyAvLyBhcnJheSBvZiBkYXktb2Ytd2VlayBpbmRpY2VzIHRoYXQgYXJlIGhpZGRlblxuICAgICAgICBsZXQgaXNIaWRkZW5EYXlIYXNoID0gW107IC8vIGlzIHRoZSBkYXktb2Ytd2VlayBoaWRkZW4/IChoYXNoIHdpdGggZGF5LW9mLXdlZWstaW5kZXggLT4gYm9vbClcbiAgICAgICAgbGV0IGRheUNudCA9IDA7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy53ZWVrZW5kcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGhpZGRlbkRheXMucHVzaCgwLCA2KTsgLy8gMD1zdW5kYXksIDY9c2F0dXJkYXlcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAoIShpc0hpZGRlbkRheUhhc2hbaV0gPSBoaWRkZW5EYXlzLmluZGV4T2YoaSkgIT09IC0xKSkge1xuICAgICAgICAgICAgICAgIGRheUNudCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZGF5Q250KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaGlkZGVuRGF5cycpOyAvLyBhbGwgZGF5cyB3ZXJlIGhpZGRlbj8gYmFkLlxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNIaWRkZW5EYXlIYXNoID0gaXNIaWRkZW5EYXlIYXNoO1xuICAgIH1cbiAgICAvLyBSZW1vdmUgZGF5cyBmcm9tIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiB0aGUgcmFuZ2UgdGhhdCBhcmUgY29tcHV0ZWQgYXMgaGlkZGVuLlxuICAgIC8vIElmIHRoZSB3aG9sZSByYW5nZSBpcyB0cmltbWVkIG9mZiwgcmV0dXJucyBudWxsXG4gICAgdHJpbUhpZGRlbkRheXMocmFuZ2UpIHtcbiAgICAgICAgbGV0IHsgc3RhcnQsIGVuZCB9ID0gcmFuZ2U7XG4gICAgICAgIGlmIChzdGFydCkge1xuICAgICAgICAgICAgc3RhcnQgPSB0aGlzLnNraXBIaWRkZW5EYXlzKHN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kKSB7XG4gICAgICAgICAgICBlbmQgPSB0aGlzLnNraXBIaWRkZW5EYXlzKGVuZCwgLTEsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCA9PSBudWxsIHx8IGVuZCA9PSBudWxsIHx8IHN0YXJ0IDwgZW5kKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdGFydCwgZW5kIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIElzIHRoZSBjdXJyZW50IGRheSBoaWRkZW4/XG4gICAgLy8gYGRheWAgaXMgYSBkYXktb2Ytd2VlayBpbmRleCAoMC02KSwgb3IgYSBEYXRlICh1c2VkIGZvciBVVEMpXG4gICAgaXNIaWRkZW5EYXkoZGF5KSB7XG4gICAgICAgIGlmIChkYXkgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICBkYXkgPSBkYXkuZ2V0VVRDRGF5KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaXNIaWRkZW5EYXlIYXNoW2RheV07XG4gICAgfVxuICAgIC8vIEluY3JlbWVudGluZyB0aGUgY3VycmVudCBkYXkgdW50aWwgaXQgaXMgbm8gbG9uZ2VyIGEgaGlkZGVuIGRheSwgcmV0dXJuaW5nIGEgY29weS5cbiAgICAvLyBET0VTIE5PVCBDT05TSURFUiB2YWxpZFJhbmdlIVxuICAgIC8vIElmIHRoZSBpbml0aWFsIHZhbHVlIG9mIGBkYXRlYCBpcyBub3QgYSBoaWRkZW4gZGF5LCBkb24ndCBkbyBhbnl0aGluZy5cbiAgICAvLyBQYXNzIGBpc0V4Y2x1c2l2ZWAgYXMgYHRydWVgIGlmIHlvdSBhcmUgZGVhbGluZyB3aXRoIGFuIGVuZCBkYXRlLlxuICAgIC8vIGBpbmNgIGRlZmF1bHRzIHRvIGAxYCAoaW5jcmVtZW50IG9uZSBkYXkgZm9yd2FyZCBlYWNoIHRpbWUpXG4gICAgc2tpcEhpZGRlbkRheXMoZGF0ZSwgaW5jID0gMSwgaXNFeGNsdXNpdmUgPSBmYWxzZSkge1xuICAgICAgICB3aGlsZSAodGhpcy5pc0hpZGRlbkRheUhhc2hbKGRhdGUuZ2V0VVRDRGF5KCkgKyAoaXNFeGNsdXNpdmUgPyBpbmMgOiAwKSArIDcpICUgN10pIHtcbiAgICAgICAgICAgIGRhdGUgPSBhZGREYXlzKGRhdGUsIGluYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFdmVudEluc3RhbmNlKGRlZklkLCByYW5nZSwgZm9yY2VkU3RhcnRUem8sIGZvcmNlZEVuZFR6bykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGluc3RhbmNlSWQ6IGd1aWQoKSxcbiAgICAgICAgZGVmSWQsXG4gICAgICAgIHJhbmdlLFxuICAgICAgICBmb3JjZWRTdGFydFR6bzogZm9yY2VkU3RhcnRUem8gPT0gbnVsbCA/IG51bGwgOiBmb3JjZWRTdGFydFR6byxcbiAgICAgICAgZm9yY2VkRW5kVHpvOiBmb3JjZWRFbmRUem8gPT0gbnVsbCA/IG51bGwgOiBmb3JjZWRFbmRUem8sXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VSZWN1cnJpbmcocmVmaW5lZCwgZGVmYXVsdEFsbERheSwgZGF0ZUVudiwgcmVjdXJyaW5nVHlwZXMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY3VycmluZ1R5cGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGxldCBwYXJzZWQgPSByZWN1cnJpbmdUeXBlc1tpXS5wYXJzZShyZWZpbmVkLCBkYXRlRW52KTtcbiAgICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICAgICAgbGV0IHsgYWxsRGF5IH0gPSByZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGFsbERheSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYWxsRGF5ID0gZGVmYXVsdEFsbERheTtcbiAgICAgICAgICAgICAgICBpZiAoYWxsRGF5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsRGF5ID0gcGFyc2VkLmFsbERheUd1ZXNzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWxsRGF5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbERheSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhbGxEYXksXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IHBhcnNlZC5kdXJhdGlvbixcbiAgICAgICAgICAgICAgICB0eXBlRGF0YTogcGFyc2VkLnR5cGVEYXRhLFxuICAgICAgICAgICAgICAgIHR5cGVJZDogaSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBleHBhbmRSZWN1cnJpbmcoZXZlbnRTdG9yZSwgZnJhbWluZ1JhbmdlLCBjb250ZXh0KSB7XG4gICAgbGV0IHsgZGF0ZUVudiwgcGx1Z2luSG9va3MsIG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgbGV0IHsgZGVmcywgaW5zdGFuY2VzIH0gPSBldmVudFN0b3JlO1xuICAgIC8vIHJlbW92ZSBleGlzdGluZyByZWN1cnJpbmcgaW5zdGFuY2VzXG4gICAgLy8gVE9ETzogYmFkLiBhbHdheXMgZXhwYW5kIGV2ZW50cyBhcyBhIHNlY29uZCBzdGVwXG4gICAgaW5zdGFuY2VzID0gZmlsdGVySGFzaChpbnN0YW5jZXMsIChpbnN0YW5jZSkgPT4gIWRlZnNbaW5zdGFuY2UuZGVmSWRdLnJlY3VycmluZ0RlZik7XG4gICAgZm9yIChsZXQgZGVmSWQgaW4gZGVmcykge1xuICAgICAgICBsZXQgZGVmID0gZGVmc1tkZWZJZF07XG4gICAgICAgIGlmIChkZWYucmVjdXJyaW5nRGVmKSB7XG4gICAgICAgICAgICBsZXQgeyBkdXJhdGlvbiB9ID0gZGVmLnJlY3VycmluZ0RlZjtcbiAgICAgICAgICAgIGlmICghZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IGRlZi5hbGxEYXkgP1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uIDpcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kZWZhdWx0VGltZWRFdmVudER1cmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHN0YXJ0cyA9IGV4cGFuZFJlY3VycmluZ1JhbmdlcyhkZWYsIGR1cmF0aW9uLCBmcmFtaW5nUmFuZ2UsIGRhdGVFbnYsIHBsdWdpbkhvb2tzLnJlY3VycmluZ1R5cGVzKTtcbiAgICAgICAgICAgIGZvciAobGV0IHN0YXJ0IG9mIHN0YXJ0cykge1xuICAgICAgICAgICAgICAgIGxldCBpbnN0YW5jZSA9IGNyZWF0ZUV2ZW50SW5zdGFuY2UoZGVmSWQsIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogZGF0ZUVudi5hZGQoc3RhcnQsIGR1cmF0aW9uKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZXNbaW5zdGFuY2UuaW5zdGFuY2VJZF0gPSBpbnN0YW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBkZWZzLCBpbnN0YW5jZXMgfTtcbn1cbi8qXG5FdmVudCBNVVNUIGhhdmUgYSByZWN1cnJpbmdEZWZcbiovXG5mdW5jdGlvbiBleHBhbmRSZWN1cnJpbmdSYW5nZXMoZXZlbnREZWYsIGR1cmF0aW9uLCBmcmFtaW5nUmFuZ2UsIGRhdGVFbnYsIHJlY3VycmluZ1R5cGVzKSB7XG4gICAgbGV0IHR5cGVEZWYgPSByZWN1cnJpbmdUeXBlc1tldmVudERlZi5yZWN1cnJpbmdEZWYudHlwZUlkXTtcbiAgICBsZXQgbWFya2VycyA9IHR5cGVEZWYuZXhwYW5kKGV2ZW50RGVmLnJlY3VycmluZ0RlZi50eXBlRGF0YSwge1xuICAgICAgICBzdGFydDogZGF0ZUVudi5zdWJ0cmFjdChmcmFtaW5nUmFuZ2Uuc3RhcnQsIGR1cmF0aW9uKSxcbiAgICAgICAgZW5kOiBmcmFtaW5nUmFuZ2UuZW5kLFxuICAgIH0sIGRhdGVFbnYpO1xuICAgIC8vIHRoZSByZWN1cnJlbmNlIHBsdWdpbnMgZG9uJ3QgZ3VhcmFudGVlIHRoYXQgYWxsLWRheSBldmVudHMgYXJlIHN0YXJ0LW9mLWRheSwgc28gd2UgaGF2ZSB0b1xuICAgIGlmIChldmVudERlZi5hbGxEYXkpIHtcbiAgICAgICAgbWFya2VycyA9IG1hcmtlcnMubWFwKHN0YXJ0T2ZEYXkpO1xuICAgIH1cbiAgICByZXR1cm4gbWFya2Vycztcbn1cblxuY29uc3QgRVZFTlRfTk9OX0RBVEVfUkVGSU5FUlMgPSB7XG4gICAgaWQ6IFN0cmluZyxcbiAgICBncm91cElkOiBTdHJpbmcsXG4gICAgdGl0bGU6IFN0cmluZyxcbiAgICB1cmw6IFN0cmluZyxcbiAgICBpbnRlcmFjdGl2ZTogQm9vbGVhbixcbn07XG5jb25zdCBFVkVOVF9EQVRFX1JFRklORVJTID0ge1xuICAgIHN0YXJ0OiBpZGVudGl0eSxcbiAgICBlbmQ6IGlkZW50aXR5LFxuICAgIGRhdGU6IGlkZW50aXR5LFxuICAgIGFsbERheTogQm9vbGVhbixcbn07XG5jb25zdCBFVkVOVF9SRUZJTkVSUyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBFVkVOVF9OT05fREFURV9SRUZJTkVSUyksIEVWRU5UX0RBVEVfUkVGSU5FUlMpLCB7IGV4dGVuZGVkUHJvcHM6IGlkZW50aXR5IH0pO1xuZnVuY3Rpb24gcGFyc2VFdmVudChyYXcsIGV2ZW50U291cmNlLCBjb250ZXh0LCBhbGxvd09wZW5SYW5nZSwgcmVmaW5lcnMgPSBidWlsZEV2ZW50UmVmaW5lcnMoY29udGV4dCksIGRlZklkTWFwLCBpbnN0YW5jZUlkTWFwKSB7XG4gICAgbGV0IHsgcmVmaW5lZCwgZXh0cmEgfSA9IHJlZmluZUV2ZW50RGVmKHJhdywgY29udGV4dCwgcmVmaW5lcnMpO1xuICAgIGxldCBkZWZhdWx0QWxsRGF5ID0gY29tcHV0ZUlzRGVmYXVsdEFsbERheShldmVudFNvdXJjZSwgY29udGV4dCk7XG4gICAgbGV0IHJlY3VycmluZ1JlcyA9IHBhcnNlUmVjdXJyaW5nKHJlZmluZWQsIGRlZmF1bHRBbGxEYXksIGNvbnRleHQuZGF0ZUVudiwgY29udGV4dC5wbHVnaW5Ib29rcy5yZWN1cnJpbmdUeXBlcyk7XG4gICAgaWYgKHJlY3VycmluZ1Jlcykge1xuICAgICAgICBsZXQgZGVmID0gcGFyc2VFdmVudERlZihyZWZpbmVkLCBleHRyYSwgZXZlbnRTb3VyY2UgPyBldmVudFNvdXJjZS5zb3VyY2VJZCA6ICcnLCByZWN1cnJpbmdSZXMuYWxsRGF5LCBCb29sZWFuKHJlY3VycmluZ1Jlcy5kdXJhdGlvbiksIGNvbnRleHQsIGRlZklkTWFwKTtcbiAgICAgICAgZGVmLnJlY3VycmluZ0RlZiA9IHtcbiAgICAgICAgICAgIHR5cGVJZDogcmVjdXJyaW5nUmVzLnR5cGVJZCxcbiAgICAgICAgICAgIHR5cGVEYXRhOiByZWN1cnJpbmdSZXMudHlwZURhdGEsXG4gICAgICAgICAgICBkdXJhdGlvbjogcmVjdXJyaW5nUmVzLmR1cmF0aW9uLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4geyBkZWYsIGluc3RhbmNlOiBudWxsIH07XG4gICAgfVxuICAgIGxldCBzaW5nbGVSZXMgPSBwYXJzZVNpbmdsZShyZWZpbmVkLCBkZWZhdWx0QWxsRGF5LCBjb250ZXh0LCBhbGxvd09wZW5SYW5nZSk7XG4gICAgaWYgKHNpbmdsZVJlcykge1xuICAgICAgICBsZXQgZGVmID0gcGFyc2VFdmVudERlZihyZWZpbmVkLCBleHRyYSwgZXZlbnRTb3VyY2UgPyBldmVudFNvdXJjZS5zb3VyY2VJZCA6ICcnLCBzaW5nbGVSZXMuYWxsRGF5LCBzaW5nbGVSZXMuaGFzRW5kLCBjb250ZXh0LCBkZWZJZE1hcCk7XG4gICAgICAgIGxldCBpbnN0YW5jZSA9IGNyZWF0ZUV2ZW50SW5zdGFuY2UoZGVmLmRlZklkLCBzaW5nbGVSZXMucmFuZ2UsIHNpbmdsZVJlcy5mb3JjZWRTdGFydFR6bywgc2luZ2xlUmVzLmZvcmNlZEVuZFR6byk7XG4gICAgICAgIGlmIChpbnN0YW5jZUlkTWFwICYmIGRlZi5wdWJsaWNJZCAmJiBpbnN0YW5jZUlkTWFwW2RlZi5wdWJsaWNJZF0pIHtcbiAgICAgICAgICAgIGluc3RhbmNlLmluc3RhbmNlSWQgPSBpbnN0YW5jZUlkTWFwW2RlZi5wdWJsaWNJZF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZGVmLCBpbnN0YW5jZSB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHJlZmluZUV2ZW50RGVmKHJhdywgY29udGV4dCwgcmVmaW5lcnMgPSBidWlsZEV2ZW50UmVmaW5lcnMoY29udGV4dCkpIHtcbiAgICByZXR1cm4gcmVmaW5lUHJvcHMocmF3LCByZWZpbmVycyk7XG59XG5mdW5jdGlvbiBidWlsZEV2ZW50UmVmaW5lcnMoY29udGV4dCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgRVZFTlRfVUlfUkVGSU5FUlMpLCBFVkVOVF9SRUZJTkVSUyksIGNvbnRleHQucGx1Z2luSG9va3MuZXZlbnRSZWZpbmVycyk7XG59XG4vKlxuV2lsbCBOT1QgcG9wdWxhdGUgZXh0ZW5kZWRQcm9wcyB3aXRoIHRoZSBsZWZ0b3ZlciBwcm9wZXJ0aWVzLlxuV2lsbCBOT1QgcG9wdWxhdGUgZGF0ZS1yZWxhdGVkIHByb3BzLlxuKi9cbmZ1bmN0aW9uIHBhcnNlRXZlbnREZWYocmVmaW5lZCwgZXh0cmEsIHNvdXJjZUlkLCBhbGxEYXksIGhhc0VuZCwgY29udGV4dCwgZGVmSWRNYXApIHtcbiAgICBsZXQgZGVmID0ge1xuICAgICAgICB0aXRsZTogcmVmaW5lZC50aXRsZSB8fCAnJyxcbiAgICAgICAgZ3JvdXBJZDogcmVmaW5lZC5ncm91cElkIHx8ICcnLFxuICAgICAgICBwdWJsaWNJZDogcmVmaW5lZC5pZCB8fCAnJyxcbiAgICAgICAgdXJsOiByZWZpbmVkLnVybCB8fCAnJyxcbiAgICAgICAgcmVjdXJyaW5nRGVmOiBudWxsLFxuICAgICAgICBkZWZJZDogKChkZWZJZE1hcCAmJiByZWZpbmVkLmlkKSA/IGRlZklkTWFwW3JlZmluZWQuaWRdIDogJycpIHx8IGd1aWQoKSxcbiAgICAgICAgc291cmNlSWQsXG4gICAgICAgIGFsbERheSxcbiAgICAgICAgaGFzRW5kLFxuICAgICAgICBpbnRlcmFjdGl2ZTogcmVmaW5lZC5pbnRlcmFjdGl2ZSxcbiAgICAgICAgdWk6IGNyZWF0ZUV2ZW50VWkocmVmaW5lZCwgY29udGV4dCksXG4gICAgICAgIGV4dGVuZGVkUHJvcHM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKHJlZmluZWQuZXh0ZW5kZWRQcm9wcyB8fCB7fSkpLCBleHRyYSksXG4gICAgfTtcbiAgICBmb3IgKGxldCBtZW1iZXJBZGRlciBvZiBjb250ZXh0LnBsdWdpbkhvb2tzLmV2ZW50RGVmTWVtYmVyQWRkZXJzKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oZGVmLCBtZW1iZXJBZGRlcihyZWZpbmVkKSk7XG4gICAgfVxuICAgIC8vIGhlbHAgb3V0IEV2ZW50SW1wbCBmcm9tIGhhdmluZyB1c2VyIG1vZGlmeSBwcm9wc1xuICAgIE9iamVjdC5mcmVlemUoZGVmLnVpLmNsYXNzTmFtZXMpO1xuICAgIE9iamVjdC5mcmVlemUoZGVmLmV4dGVuZGVkUHJvcHMpO1xuICAgIHJldHVybiBkZWY7XG59XG5mdW5jdGlvbiBwYXJzZVNpbmdsZShyZWZpbmVkLCBkZWZhdWx0QWxsRGF5LCBjb250ZXh0LCBhbGxvd09wZW5SYW5nZSkge1xuICAgIGxldCB7IGFsbERheSB9ID0gcmVmaW5lZDtcbiAgICBsZXQgc3RhcnRNZXRhO1xuICAgIGxldCBzdGFydE1hcmtlciA9IG51bGw7XG4gICAgbGV0IGhhc0VuZCA9IGZhbHNlO1xuICAgIGxldCBlbmRNZXRhO1xuICAgIGxldCBlbmRNYXJrZXIgPSBudWxsO1xuICAgIGxldCBzdGFydElucHV0ID0gcmVmaW5lZC5zdGFydCAhPSBudWxsID8gcmVmaW5lZC5zdGFydCA6IHJlZmluZWQuZGF0ZTtcbiAgICBzdGFydE1ldGEgPSBjb250ZXh0LmRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShzdGFydElucHV0KTtcbiAgICBpZiAoc3RhcnRNZXRhKSB7XG4gICAgICAgIHN0YXJ0TWFya2VyID0gc3RhcnRNZXRhLm1hcmtlcjtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWFsbG93T3BlblJhbmdlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAocmVmaW5lZC5lbmQgIT0gbnVsbCkge1xuICAgICAgICBlbmRNZXRhID0gY29udGV4dC5kYXRlRW52LmNyZWF0ZU1hcmtlck1ldGEocmVmaW5lZC5lbmQpO1xuICAgIH1cbiAgICBpZiAoYWxsRGF5ID09IG51bGwpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRBbGxEYXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgYWxsRGF5ID0gZGVmYXVsdEFsbERheTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZhbGwgYmFjayB0byB0aGUgZGF0ZSBwcm9wcyBMQVNUXG4gICAgICAgICAgICBhbGxEYXkgPSAoIXN0YXJ0TWV0YSB8fCBzdGFydE1ldGEuaXNUaW1lVW5zcGVjaWZpZWQpICYmXG4gICAgICAgICAgICAgICAgKCFlbmRNZXRhIHx8IGVuZE1ldGEuaXNUaW1lVW5zcGVjaWZpZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChhbGxEYXkgJiYgc3RhcnRNYXJrZXIpIHtcbiAgICAgICAgc3RhcnRNYXJrZXIgPSBzdGFydE9mRGF5KHN0YXJ0TWFya2VyKTtcbiAgICB9XG4gICAgaWYgKGVuZE1ldGEpIHtcbiAgICAgICAgZW5kTWFya2VyID0gZW5kTWV0YS5tYXJrZXI7XG4gICAgICAgIGlmIChhbGxEYXkpIHtcbiAgICAgICAgICAgIGVuZE1hcmtlciA9IHN0YXJ0T2ZEYXkoZW5kTWFya2VyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRNYXJrZXIgJiYgZW5kTWFya2VyIDw9IHN0YXJ0TWFya2VyKSB7XG4gICAgICAgICAgICBlbmRNYXJrZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChlbmRNYXJrZXIpIHtcbiAgICAgICAgaGFzRW5kID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWFsbG93T3BlblJhbmdlKSB7XG4gICAgICAgIGhhc0VuZCA9IGNvbnRleHQub3B0aW9ucy5mb3JjZUV2ZW50RHVyYXRpb24gfHwgZmFsc2U7XG4gICAgICAgIGVuZE1hcmtlciA9IGNvbnRleHQuZGF0ZUVudi5hZGQoc3RhcnRNYXJrZXIsIGFsbERheSA/XG4gICAgICAgICAgICBjb250ZXh0Lm9wdGlvbnMuZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb24gOlxuICAgICAgICAgICAgY29udGV4dC5vcHRpb25zLmRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBhbGxEYXksXG4gICAgICAgIGhhc0VuZCxcbiAgICAgICAgcmFuZ2U6IHsgc3RhcnQ6IHN0YXJ0TWFya2VyLCBlbmQ6IGVuZE1hcmtlciB9LFxuICAgICAgICBmb3JjZWRTdGFydFR6bzogc3RhcnRNZXRhID8gc3RhcnRNZXRhLmZvcmNlZFR6byA6IG51bGwsXG4gICAgICAgIGZvcmNlZEVuZFR6bzogZW5kTWV0YSA/IGVuZE1ldGEuZm9yY2VkVHpvIDogbnVsbCxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcHV0ZUlzRGVmYXVsdEFsbERheShldmVudFNvdXJjZSwgY29udGV4dCkge1xuICAgIGxldCByZXMgPSBudWxsO1xuICAgIGlmIChldmVudFNvdXJjZSkge1xuICAgICAgICByZXMgPSBldmVudFNvdXJjZS5kZWZhdWx0QWxsRGF5O1xuICAgIH1cbiAgICBpZiAocmVzID09IG51bGwpIHtcbiAgICAgICAgcmVzID0gY29udGV4dC5vcHRpb25zLmRlZmF1bHRBbGxEYXk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRXZlbnRzKHJhd0V2ZW50cywgZXZlbnRTb3VyY2UsIGNvbnRleHQsIGFsbG93T3BlblJhbmdlLCBkZWZJZE1hcCwgaW5zdGFuY2VJZE1hcCkge1xuICAgIGxldCBldmVudFN0b3JlID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7XG4gICAgbGV0IGV2ZW50UmVmaW5lcnMgPSBidWlsZEV2ZW50UmVmaW5lcnMoY29udGV4dCk7XG4gICAgZm9yIChsZXQgcmF3RXZlbnQgb2YgcmF3RXZlbnRzKSB7XG4gICAgICAgIGxldCB0dXBsZSA9IHBhcnNlRXZlbnQocmF3RXZlbnQsIGV2ZW50U291cmNlLCBjb250ZXh0LCBhbGxvd09wZW5SYW5nZSwgZXZlbnRSZWZpbmVycywgZGVmSWRNYXAsIGluc3RhbmNlSWRNYXApO1xuICAgICAgICBpZiAodHVwbGUpIHtcbiAgICAgICAgICAgIGV2ZW50VHVwbGVUb1N0b3JlKHR1cGxlLCBldmVudFN0b3JlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXZlbnRTdG9yZTtcbn1cbmZ1bmN0aW9uIGV2ZW50VHVwbGVUb1N0b3JlKHR1cGxlLCBldmVudFN0b3JlID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCkpIHtcbiAgICBldmVudFN0b3JlLmRlZnNbdHVwbGUuZGVmLmRlZklkXSA9IHR1cGxlLmRlZjtcbiAgICBpZiAodHVwbGUuaW5zdGFuY2UpIHtcbiAgICAgICAgZXZlbnRTdG9yZS5pbnN0YW5jZXNbdHVwbGUuaW5zdGFuY2UuaW5zdGFuY2VJZF0gPSB0dXBsZS5pbnN0YW5jZTtcbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50U3RvcmU7XG59XG4vLyByZXRyaWV2ZXMgZXZlbnRzIHRoYXQgaGF2ZSB0aGUgc2FtZSBncm91cElkIGFzIHRoZSBpbnN0YW5jZSBzcGVjaWZpZWQgYnkgYGluc3RhbmNlSWRgXG4vLyBvciB0aGV5IGFyZSB0aGUgc2FtZSBhcyB0aGUgaW5zdGFuY2UuXG4vLyB3aHkgbWlnaHQgaW5zdGFuY2VJZCBub3QgYmUgaW4gdGhlIHN0b3JlPyBhbiBldmVudCBmcm9tIGFub3RoZXIgY2FsZW5kYXI/XG5mdW5jdGlvbiBnZXRSZWxldmFudEV2ZW50cyhldmVudFN0b3JlLCBpbnN0YW5jZUlkKSB7XG4gICAgbGV0IGluc3RhbmNlID0gZXZlbnRTdG9yZS5pbnN0YW5jZXNbaW5zdGFuY2VJZF07XG4gICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgIGxldCBkZWYgPSBldmVudFN0b3JlLmRlZnNbaW5zdGFuY2UuZGVmSWRdO1xuICAgICAgICAvLyBnZXQgZXZlbnRzL2luc3RhbmNlcyB3aXRoIHNhbWUgZ3JvdXBcbiAgICAgICAgbGV0IG5ld1N0b3JlID0gZmlsdGVyRXZlbnRTdG9yZURlZnMoZXZlbnRTdG9yZSwgKGxvb2tEZWYpID0+IGlzRXZlbnREZWZzR3JvdXBlZChkZWYsIGxvb2tEZWYpKTtcbiAgICAgICAgLy8gYWRkIHRoZSBvcmlnaW5hbFxuICAgICAgICAvLyBUT0RPOiB3aXNoIHdlIGNvdWxkIHVzZSBldmVudFR1cGxlVG9TdG9yZSBvciBzb21ldGhpbmcgbGlrZSBpdFxuICAgICAgICBuZXdTdG9yZS5kZWZzW2RlZi5kZWZJZF0gPSBkZWY7XG4gICAgICAgIG5ld1N0b3JlLmluc3RhbmNlc1tpbnN0YW5jZS5pbnN0YW5jZUlkXSA9IGluc3RhbmNlO1xuICAgICAgICByZXR1cm4gbmV3U3RvcmU7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTtcbn1cbmZ1bmN0aW9uIGlzRXZlbnREZWZzR3JvdXBlZChkZWYwLCBkZWYxKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4oZGVmMC5ncm91cElkICYmIGRlZjAuZ3JvdXBJZCA9PT0gZGVmMS5ncm91cElkKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpIHtcbiAgICByZXR1cm4geyBkZWZzOiB7fSwgaW5zdGFuY2VzOiB7fSB9O1xufVxuZnVuY3Rpb24gbWVyZ2VFdmVudFN0b3JlcyhzdG9yZTAsIHN0b3JlMSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlZnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RvcmUwLmRlZnMpLCBzdG9yZTEuZGVmcyksXG4gICAgICAgIGluc3RhbmNlczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdG9yZTAuaW5zdGFuY2VzKSwgc3RvcmUxLmluc3RhbmNlcyksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZpbHRlckV2ZW50U3RvcmVEZWZzKGV2ZW50U3RvcmUsIGZpbHRlckZ1bmMpIHtcbiAgICBsZXQgZGVmcyA9IGZpbHRlckhhc2goZXZlbnRTdG9yZS5kZWZzLCBmaWx0ZXJGdW5jKTtcbiAgICBsZXQgaW5zdGFuY2VzID0gZmlsdGVySGFzaChldmVudFN0b3JlLmluc3RhbmNlcywgKGluc3RhbmNlKSA9PiAoZGVmc1tpbnN0YW5jZS5kZWZJZF0gLy8gc3RpbGwgZXhpc3RzP1xuICAgICkpO1xuICAgIHJldHVybiB7IGRlZnMsIGluc3RhbmNlcyB9O1xufVxuZnVuY3Rpb24gZXhjbHVkZVN1YkV2ZW50U3RvcmUobWFzdGVyLCBzdWIpIHtcbiAgICBsZXQgeyBkZWZzLCBpbnN0YW5jZXMgfSA9IG1hc3RlcjtcbiAgICBsZXQgZmlsdGVyZWREZWZzID0ge307XG4gICAgbGV0IGZpbHRlcmVkSW5zdGFuY2VzID0ge307XG4gICAgZm9yIChsZXQgZGVmSWQgaW4gZGVmcykge1xuICAgICAgICBpZiAoIXN1Yi5kZWZzW2RlZklkXSkgeyAvLyBub3QgZXhwbGljaXRseSBleGNsdWRlZFxuICAgICAgICAgICAgZmlsdGVyZWREZWZzW2RlZklkXSA9IGRlZnNbZGVmSWRdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGluc3RhbmNlSWQgaW4gaW5zdGFuY2VzKSB7XG4gICAgICAgIGlmICghc3ViLmluc3RhbmNlc1tpbnN0YW5jZUlkXSAmJiAvLyBub3QgZXhwbGljaXRseSBleGNsdWRlZFxuICAgICAgICAgICAgZmlsdGVyZWREZWZzW2luc3RhbmNlc1tpbnN0YW5jZUlkXS5kZWZJZF0gLy8gZGVmIHdhc24ndCBmaWx0ZXJlZCBhd2F5XG4gICAgICAgICkge1xuICAgICAgICAgICAgZmlsdGVyZWRJbnN0YW5jZXNbaW5zdGFuY2VJZF0gPSBpbnN0YW5jZXNbaW5zdGFuY2VJZF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVmczogZmlsdGVyZWREZWZzLFxuICAgICAgICBpbnN0YW5jZXM6IGZpbHRlcmVkSW5zdGFuY2VzLFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbnN0cmFpbnQoaW5wdXQsIGNvbnRleHQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRXZlbnRzKGlucHV0LCBudWxsLCBjb250ZXh0LCB0cnVlKTsgLy8gYWxsb3dPcGVuUmFuZ2U9dHJ1ZVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiBpbnB1dCkgeyAvLyBub24tbnVsbCBvYmplY3RcbiAgICAgICAgcmV0dXJuIHBhcnNlRXZlbnRzKFtpbnB1dF0sIG51bGwsIGNvbnRleHQsIHRydWUpOyAvLyBhbGxvd09wZW5SYW5nZT10cnVlXG4gICAgfVxuICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcoaW5wdXQpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcGFyc2VDbGFzc05hbWVzKHJhdykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJhdykpIHtcbiAgICAgICAgcmV0dXJuIHJhdztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiByYXcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiByYXcuc3BsaXQoL1xccysvKTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufVxuXG4vLyBUT0RPOiBiZXR0ZXIgY2FsbGVkIFwiRXZlbnRTZXR0aW5nc1wiIG9yIFwiRXZlbnRDb25maWdcIlxuLy8gVE9ETzogbW92ZSB0aGlzIGZpbGUgaW50byBzdHJ1Y3RzXG4vLyBUT0RPOiBzZXBhcmF0ZSBjb25zdHJhaW50L292ZXJsYXAvYWxsb3csIGJlY2F1c2Ugc2VsZWN0aW9uIHVzZXMgb25seSB0aGF0LCBub3Qgb3RoZXIgcHJvcHNcbmNvbnN0IEVWRU5UX1VJX1JFRklORVJTID0ge1xuICAgIGRpc3BsYXk6IFN0cmluZyxcbiAgICBlZGl0YWJsZTogQm9vbGVhbixcbiAgICBzdGFydEVkaXRhYmxlOiBCb29sZWFuLFxuICAgIGR1cmF0aW9uRWRpdGFibGU6IEJvb2xlYW4sXG4gICAgY29uc3RyYWludDogaWRlbnRpdHksXG4gICAgb3ZlcmxhcDogaWRlbnRpdHksXG4gICAgYWxsb3c6IGlkZW50aXR5LFxuICAgIGNsYXNzTmFtZTogcGFyc2VDbGFzc05hbWVzLFxuICAgIGNsYXNzTmFtZXM6IHBhcnNlQ2xhc3NOYW1lcyxcbiAgICBjb2xvcjogU3RyaW5nLFxuICAgIGJhY2tncm91bmRDb2xvcjogU3RyaW5nLFxuICAgIGJvcmRlckNvbG9yOiBTdHJpbmcsXG4gICAgdGV4dENvbG9yOiBTdHJpbmcsXG59O1xuY29uc3QgRU1QVFlfRVZFTlRfVUkgPSB7XG4gICAgZGlzcGxheTogbnVsbCxcbiAgICBzdGFydEVkaXRhYmxlOiBudWxsLFxuICAgIGR1cmF0aW9uRWRpdGFibGU6IG51bGwsXG4gICAgY29uc3RyYWludHM6IFtdLFxuICAgIG92ZXJsYXA6IG51bGwsXG4gICAgYWxsb3dzOiBbXSxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICcnLFxuICAgIGJvcmRlckNvbG9yOiAnJyxcbiAgICB0ZXh0Q29sb3I6ICcnLFxuICAgIGNsYXNzTmFtZXM6IFtdLFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50VWkocmVmaW5lZCwgY29udGV4dCkge1xuICAgIGxldCBjb25zdHJhaW50ID0gbm9ybWFsaXplQ29uc3RyYWludChyZWZpbmVkLmNvbnN0cmFpbnQsIGNvbnRleHQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRpc3BsYXk6IHJlZmluZWQuZGlzcGxheSB8fCBudWxsLFxuICAgICAgICBzdGFydEVkaXRhYmxlOiByZWZpbmVkLnN0YXJ0RWRpdGFibGUgIT0gbnVsbCA/IHJlZmluZWQuc3RhcnRFZGl0YWJsZSA6IHJlZmluZWQuZWRpdGFibGUsXG4gICAgICAgIGR1cmF0aW9uRWRpdGFibGU6IHJlZmluZWQuZHVyYXRpb25FZGl0YWJsZSAhPSBudWxsID8gcmVmaW5lZC5kdXJhdGlvbkVkaXRhYmxlIDogcmVmaW5lZC5lZGl0YWJsZSxcbiAgICAgICAgY29uc3RyYWludHM6IGNvbnN0cmFpbnQgIT0gbnVsbCA/IFtjb25zdHJhaW50XSA6IFtdLFxuICAgICAgICBvdmVybGFwOiByZWZpbmVkLm92ZXJsYXAgIT0gbnVsbCA/IHJlZmluZWQub3ZlcmxhcCA6IG51bGwsXG4gICAgICAgIGFsbG93czogcmVmaW5lZC5hbGxvdyAhPSBudWxsID8gW3JlZmluZWQuYWxsb3ddIDogW10sXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogcmVmaW5lZC5iYWNrZ3JvdW5kQ29sb3IgfHwgcmVmaW5lZC5jb2xvciB8fCAnJyxcbiAgICAgICAgYm9yZGVyQ29sb3I6IHJlZmluZWQuYm9yZGVyQ29sb3IgfHwgcmVmaW5lZC5jb2xvciB8fCAnJyxcbiAgICAgICAgdGV4dENvbG9yOiByZWZpbmVkLnRleHRDb2xvciB8fCAnJyxcbiAgICAgICAgY2xhc3NOYW1lczogKHJlZmluZWQuY2xhc3NOYW1lIHx8IFtdKS5jb25jYXQocmVmaW5lZC5jbGFzc05hbWVzIHx8IFtdKSwgLy8gam9pbiBzaW5ndWxhciBhbmQgcGx1cmFsXG4gICAgfTtcbn1cbi8vIFRPRE86IHByZXZlbnQgYWdhaW5zdCBwcm9ibGVtcyB3aXRoIDwyIGFyZ3MhXG5mdW5jdGlvbiBjb21iaW5lRXZlbnRVaXModWlzKSB7XG4gICAgcmV0dXJuIHVpcy5yZWR1Y2UoY29tYmluZVR3b0V2ZW50VWlzLCBFTVBUWV9FVkVOVF9VSSk7XG59XG5mdW5jdGlvbiBjb21iaW5lVHdvRXZlbnRVaXMoaXRlbTAsIGl0ZW0xKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGlzcGxheTogaXRlbTEuZGlzcGxheSAhPSBudWxsID8gaXRlbTEuZGlzcGxheSA6IGl0ZW0wLmRpc3BsYXksXG4gICAgICAgIHN0YXJ0RWRpdGFibGU6IGl0ZW0xLnN0YXJ0RWRpdGFibGUgIT0gbnVsbCA/IGl0ZW0xLnN0YXJ0RWRpdGFibGUgOiBpdGVtMC5zdGFydEVkaXRhYmxlLFxuICAgICAgICBkdXJhdGlvbkVkaXRhYmxlOiBpdGVtMS5kdXJhdGlvbkVkaXRhYmxlICE9IG51bGwgPyBpdGVtMS5kdXJhdGlvbkVkaXRhYmxlIDogaXRlbTAuZHVyYXRpb25FZGl0YWJsZSxcbiAgICAgICAgY29uc3RyYWludHM6IGl0ZW0wLmNvbnN0cmFpbnRzLmNvbmNhdChpdGVtMS5jb25zdHJhaW50cyksXG4gICAgICAgIG92ZXJsYXA6IHR5cGVvZiBpdGVtMS5vdmVybGFwID09PSAnYm9vbGVhbicgPyBpdGVtMS5vdmVybGFwIDogaXRlbTAub3ZlcmxhcCxcbiAgICAgICAgYWxsb3dzOiBpdGVtMC5hbGxvd3MuY29uY2F0KGl0ZW0xLmFsbG93cyksXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogaXRlbTEuYmFja2dyb3VuZENvbG9yIHx8IGl0ZW0wLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgYm9yZGVyQ29sb3I6IGl0ZW0xLmJvcmRlckNvbG9yIHx8IGl0ZW0wLmJvcmRlckNvbG9yLFxuICAgICAgICB0ZXh0Q29sb3I6IGl0ZW0xLnRleHRDb2xvciB8fCBpdGVtMC50ZXh0Q29sb3IsXG4gICAgICAgIGNsYXNzTmFtZXM6IGl0ZW0wLmNsYXNzTmFtZXMuY29uY2F0KGl0ZW0xLmNsYXNzTmFtZXMpLFxuICAgIH07XG59XG5cbmNvbnN0IEVWRU5UX1NPVVJDRV9SRUZJTkVSUyA9IHtcbiAgICBpZDogU3RyaW5nLFxuICAgIGRlZmF1bHRBbGxEYXk6IEJvb2xlYW4sXG4gICAgdXJsOiBTdHJpbmcsXG4gICAgZm9ybWF0OiBTdHJpbmcsXG4gICAgZXZlbnRzOiBpZGVudGl0eSxcbiAgICBldmVudERhdGFUcmFuc2Zvcm06IGlkZW50aXR5LFxuICAgIC8vIGZvciBhbnkgbmV0d29yay1yZWxhdGVkIHNvdXJjZXNcbiAgICBzdWNjZXNzOiBpZGVudGl0eSxcbiAgICBmYWlsdXJlOiBpZGVudGl0eSxcbn07XG5mdW5jdGlvbiBwYXJzZUV2ZW50U291cmNlKHJhdywgY29udGV4dCwgcmVmaW5lcnMgPSBidWlsZEV2ZW50U291cmNlUmVmaW5lcnMoY29udGV4dCkpIHtcbiAgICBsZXQgcmF3T2JqO1xuICAgIGlmICh0eXBlb2YgcmF3ID09PSAnc3RyaW5nJykge1xuICAgICAgICByYXdPYmogPSB7IHVybDogcmF3IH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiByYXcgPT09ICdmdW5jdGlvbicgfHwgQXJyYXkuaXNBcnJheShyYXcpKSB7XG4gICAgICAgIHJhd09iaiA9IHsgZXZlbnRzOiByYXcgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHJhdyA9PT0gJ29iamVjdCcgJiYgcmF3KSB7IC8vIG5vdCBudWxsXG4gICAgICAgIHJhd09iaiA9IHJhdztcbiAgICB9XG4gICAgaWYgKHJhd09iaikge1xuICAgICAgICBsZXQgeyByZWZpbmVkLCBleHRyYSB9ID0gcmVmaW5lUHJvcHMocmF3T2JqLCByZWZpbmVycyk7XG4gICAgICAgIGxldCBtZXRhUmVzID0gYnVpbGRFdmVudFNvdXJjZU1ldGEocmVmaW5lZCwgY29udGV4dCk7XG4gICAgICAgIGlmIChtZXRhUmVzKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIF9yYXc6IHJhdyxcbiAgICAgICAgICAgICAgICBpc0ZldGNoaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBsYXRlc3RGZXRjaElkOiAnJyxcbiAgICAgICAgICAgICAgICBmZXRjaFJhbmdlOiBudWxsLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRBbGxEYXk6IHJlZmluZWQuZGVmYXVsdEFsbERheSxcbiAgICAgICAgICAgICAgICBldmVudERhdGFUcmFuc2Zvcm06IHJlZmluZWQuZXZlbnREYXRhVHJhbnNmb3JtLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHJlZmluZWQuc3VjY2VzcyxcbiAgICAgICAgICAgICAgICBmYWlsdXJlOiByZWZpbmVkLmZhaWx1cmUsXG4gICAgICAgICAgICAgICAgcHVibGljSWQ6IHJlZmluZWQuaWQgfHwgJycsXG4gICAgICAgICAgICAgICAgc291cmNlSWQ6IGd1aWQoKSxcbiAgICAgICAgICAgICAgICBzb3VyY2VEZWZJZDogbWV0YVJlcy5zb3VyY2VEZWZJZCxcbiAgICAgICAgICAgICAgICBtZXRhOiBtZXRhUmVzLm1ldGEsXG4gICAgICAgICAgICAgICAgdWk6IGNyZWF0ZUV2ZW50VWkocmVmaW5lZCwgY29udGV4dCksXG4gICAgICAgICAgICAgICAgZXh0ZW5kZWRQcm9wczogZXh0cmEsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gYnVpbGRFdmVudFNvdXJjZVJlZmluZXJzKGNvbnRleHQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIEVWRU5UX1VJX1JFRklORVJTKSwgRVZFTlRfU09VUkNFX1JFRklORVJTKSwgY29udGV4dC5wbHVnaW5Ib29rcy5ldmVudFNvdXJjZVJlZmluZXJzKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRXZlbnRTb3VyY2VNZXRhKHJhdywgY29udGV4dCkge1xuICAgIGxldCBkZWZzID0gY29udGV4dC5wbHVnaW5Ib29rcy5ldmVudFNvdXJjZURlZnM7XG4gICAgZm9yIChsZXQgaSA9IGRlZnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHsgLy8gbGF0ZXItYWRkZWQgcGx1Z2lucyB0YWtlIHByZWNlZGVuY2VcbiAgICAgICAgbGV0IGRlZiA9IGRlZnNbaV07XG4gICAgICAgIGxldCBtZXRhID0gZGVmLnBhcnNlTWV0YShyYXcpO1xuICAgICAgICBpZiAobWV0YSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgc291cmNlRGVmSWQ6IGksIG1ldGEgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcmVkdWNlRXZlbnRTdG9yZShldmVudFN0b3JlLCBhY3Rpb24sIGV2ZW50U291cmNlcywgZGF0ZVByb2ZpbGUsIGNvbnRleHQpIHtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ1JFQ0VJVkVfRVZFTlRTJzogLy8gcmF3XG4gICAgICAgICAgICByZXR1cm4gcmVjZWl2ZVJhd0V2ZW50cyhldmVudFN0b3JlLCBldmVudFNvdXJjZXNbYWN0aW9uLnNvdXJjZUlkXSwgYWN0aW9uLmZldGNoSWQsIGFjdGlvbi5mZXRjaFJhbmdlLCBhY3Rpb24ucmF3RXZlbnRzLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSAnUkVTRVRfUkFXX0VWRU5UUyc6XG4gICAgICAgICAgICByZXR1cm4gcmVzZXRSYXdFdmVudHMoZXZlbnRTdG9yZSwgZXZlbnRTb3VyY2VzW2FjdGlvbi5zb3VyY2VJZF0sIGFjdGlvbi5yYXdFdmVudHMsIGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSAnQUREX0VWRU5UUyc6IC8vIGFscmVhZHkgcGFyc2VkLCBidXQgbm90IGV4cGFuZGVkXG4gICAgICAgICAgICByZXR1cm4gYWRkRXZlbnQoZXZlbnRTdG9yZSwgYWN0aW9uLmV2ZW50U3RvcmUsIC8vIG5ldyBvbmVzXG4gICAgICAgICAgICBkYXRlUHJvZmlsZSA/IGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlIDogbnVsbCwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgJ1JFU0VUX0VWRU5UUyc6XG4gICAgICAgICAgICByZXR1cm4gYWN0aW9uLmV2ZW50U3RvcmU7XG4gICAgICAgIGNhc2UgJ01FUkdFX0VWRU5UUyc6IC8vIGFscmVhZHkgcGFyc2VkIGFuZCBleHBhbmRlZFxuICAgICAgICAgICAgcmV0dXJuIG1lcmdlRXZlbnRTdG9yZXMoZXZlbnRTdG9yZSwgYWN0aW9uLmV2ZW50U3RvcmUpO1xuICAgICAgICBjYXNlICdQUkVWJzogLy8gVE9ETzogaG93IGRvIHdlIHRyYWNrIGFsbCBhY3Rpb25zIHRoYXQgYWZmZWN0IGRhdGVQcm9maWxlIDooXG4gICAgICAgIGNhc2UgJ05FWFQnOlxuICAgICAgICBjYXNlICdDSEFOR0VfREFURSc6XG4gICAgICAgIGNhc2UgJ0NIQU5HRV9WSUVXX1RZUEUnOlxuICAgICAgICAgICAgaWYgKGRhdGVQcm9maWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cGFuZFJlY3VycmluZyhldmVudFN0b3JlLCBkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRTdG9yZTtcbiAgICAgICAgY2FzZSAnUkVNT1ZFX0VWRU5UUyc6XG4gICAgICAgICAgICByZXR1cm4gZXhjbHVkZVN1YkV2ZW50U3RvcmUoZXZlbnRTdG9yZSwgYWN0aW9uLmV2ZW50U3RvcmUpO1xuICAgICAgICBjYXNlICdSRU1PVkVfRVZFTlRfU09VUkNFJzpcbiAgICAgICAgICAgIHJldHVybiBleGNsdWRlRXZlbnRzQnlTb3VyY2VJZChldmVudFN0b3JlLCBhY3Rpb24uc291cmNlSWQpO1xuICAgICAgICBjYXNlICdSRU1PVkVfQUxMX0VWRU5UX1NPVVJDRVMnOlxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlckV2ZW50U3RvcmVEZWZzKGV2ZW50U3RvcmUsIChldmVudERlZikgPT4gKCFldmVudERlZi5zb3VyY2VJZCAvLyBvbmx5IGtlZXAgZXZlbnRzIHdpdGggbm8gc291cmNlIGlkXG4gICAgICAgICAgICApKTtcbiAgICAgICAgY2FzZSAnUkVNT1ZFX0FMTF9FVkVOVFMnOlxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50U3RvcmU7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVjZWl2ZVJhd0V2ZW50cyhldmVudFN0b3JlLCBldmVudFNvdXJjZSwgZmV0Y2hJZCwgZmV0Y2hSYW5nZSwgcmF3RXZlbnRzLCBjb250ZXh0KSB7XG4gICAgaWYgKGV2ZW50U291cmNlICYmIC8vIG5vdCBhbHJlYWR5IHJlbW92ZWRcbiAgICAgICAgZmV0Y2hJZCA9PT0gZXZlbnRTb3VyY2UubGF0ZXN0RmV0Y2hJZCAvLyBUT0RPOiB3aXNoIHRoaXMgbG9naWMgd2FzIGFsd2F5cyBpbiBldmVudC1zb3VyY2VzXG4gICAgKSB7XG4gICAgICAgIGxldCBzdWJzZXQgPSBwYXJzZUV2ZW50cyh0cmFuc2Zvcm1SYXdFdmVudHMocmF3RXZlbnRzLCBldmVudFNvdXJjZSwgY29udGV4dCksIGV2ZW50U291cmNlLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKGZldGNoUmFuZ2UpIHtcbiAgICAgICAgICAgIHN1YnNldCA9IGV4cGFuZFJlY3VycmluZyhzdWJzZXQsIGZldGNoUmFuZ2UsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXJnZUV2ZW50U3RvcmVzKGV4Y2x1ZGVFdmVudHNCeVNvdXJjZUlkKGV2ZW50U3RvcmUsIGV2ZW50U291cmNlLnNvdXJjZUlkKSwgc3Vic2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50U3RvcmU7XG59XG5mdW5jdGlvbiByZXNldFJhd0V2ZW50cyhleGlzdGluZ0V2ZW50U3RvcmUsIGV2ZW50U291cmNlLCByYXdFdmVudHMsIGFjdGl2ZVJhbmdlLCBjb250ZXh0KSB7XG4gICAgY29uc3QgeyBkZWZJZE1hcCwgaW5zdGFuY2VJZE1hcCB9ID0gYnVpbGRQdWJsaWNJZE1hcHMoZXhpc3RpbmdFdmVudFN0b3JlKTtcbiAgICBsZXQgbmV3RXZlbnRTdG9yZSA9IHBhcnNlRXZlbnRzKHRyYW5zZm9ybVJhd0V2ZW50cyhyYXdFdmVudHMsIGV2ZW50U291cmNlLCBjb250ZXh0KSwgZXZlbnRTb3VyY2UsIGNvbnRleHQsIGZhbHNlLCBkZWZJZE1hcCwgaW5zdGFuY2VJZE1hcCk7XG4gICAgcmV0dXJuIGV4cGFuZFJlY3VycmluZyhuZXdFdmVudFN0b3JlLCBhY3RpdmVSYW5nZSwgY29udGV4dCk7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1SYXdFdmVudHMocmF3RXZlbnRzLCBldmVudFNvdXJjZSwgY29udGV4dCkge1xuICAgIGxldCBjYWxFYWNoVHJhbnNmb3JtID0gY29udGV4dC5vcHRpb25zLmV2ZW50RGF0YVRyYW5zZm9ybTtcbiAgICBsZXQgc291cmNlRWFjaFRyYW5zZm9ybSA9IGV2ZW50U291cmNlID8gZXZlbnRTb3VyY2UuZXZlbnREYXRhVHJhbnNmb3JtIDogbnVsbDtcbiAgICBpZiAoc291cmNlRWFjaFRyYW5zZm9ybSkge1xuICAgICAgICByYXdFdmVudHMgPSB0cmFuc2Zvcm1FYWNoUmF3RXZlbnQocmF3RXZlbnRzLCBzb3VyY2VFYWNoVHJhbnNmb3JtKTtcbiAgICB9XG4gICAgaWYgKGNhbEVhY2hUcmFuc2Zvcm0pIHtcbiAgICAgICAgcmF3RXZlbnRzID0gdHJhbnNmb3JtRWFjaFJhd0V2ZW50KHJhd0V2ZW50cywgY2FsRWFjaFRyYW5zZm9ybSk7XG4gICAgfVxuICAgIHJldHVybiByYXdFdmVudHM7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1FYWNoUmF3RXZlbnQocmF3RXZlbnRzLCBmdW5jKSB7XG4gICAgbGV0IHJlZmluZWRFdmVudHM7XG4gICAgaWYgKCFmdW5jKSB7XG4gICAgICAgIHJlZmluZWRFdmVudHMgPSByYXdFdmVudHM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZWZpbmVkRXZlbnRzID0gW107XG4gICAgICAgIGZvciAobGV0IHJhd0V2ZW50IG9mIHJhd0V2ZW50cykge1xuICAgICAgICAgICAgbGV0IHJlZmluZWRFdmVudCA9IGZ1bmMocmF3RXZlbnQpO1xuICAgICAgICAgICAgaWYgKHJlZmluZWRFdmVudCkge1xuICAgICAgICAgICAgICAgIHJlZmluZWRFdmVudHMucHVzaChyZWZpbmVkRXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVmaW5lZEV2ZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZWZpbmVkRXZlbnRzLnB1c2gocmF3RXZlbnQpO1xuICAgICAgICAgICAgfSAvLyBpZiBhIGRpZmZlcmVudCBmYWxzeSB2YWx1ZSwgZG8gbm90aGluZ1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZWZpbmVkRXZlbnRzO1xufVxuZnVuY3Rpb24gYWRkRXZlbnQoZXZlbnRTdG9yZSwgc3Vic2V0LCBleHBhbmRSYW5nZSwgY29udGV4dCkge1xuICAgIGlmIChleHBhbmRSYW5nZSkge1xuICAgICAgICBzdWJzZXQgPSBleHBhbmRSZWN1cnJpbmcoc3Vic2V0LCBleHBhbmRSYW5nZSwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBtZXJnZUV2ZW50U3RvcmVzKGV2ZW50U3RvcmUsIHN1YnNldCk7XG59XG5mdW5jdGlvbiByZXpvbmVFdmVudFN0b3JlRGF0ZXMoZXZlbnRTdG9yZSwgb2xkRGF0ZUVudiwgbmV3RGF0ZUVudikge1xuICAgIGxldCB7IGRlZnMgfSA9IGV2ZW50U3RvcmU7XG4gICAgbGV0IGluc3RhbmNlcyA9IG1hcEhhc2goZXZlbnRTdG9yZS5pbnN0YW5jZXMsIChpbnN0YW5jZSkgPT4ge1xuICAgICAgICBsZXQgZGVmID0gZGVmc1tpbnN0YW5jZS5kZWZJZF07XG4gICAgICAgIGlmIChkZWYuYWxsRGF5KSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7IC8vIGlzbid0IGRlcGVuZGVudCBvbiB0aW1lem9uZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGluc3RhbmNlKSwgeyByYW5nZToge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBuZXdEYXRlRW52LmNyZWF0ZU1hcmtlcihvbGREYXRlRW52LnRvRGF0ZShpbnN0YW5jZS5yYW5nZS5zdGFydCwgaW5zdGFuY2UuZm9yY2VkU3RhcnRUem8pKSxcbiAgICAgICAgICAgICAgICBlbmQ6IG5ld0RhdGVFbnYuY3JlYXRlTWFya2VyKG9sZERhdGVFbnYudG9EYXRlKGluc3RhbmNlLnJhbmdlLmVuZCwgaW5zdGFuY2UuZm9yY2VkRW5kVHpvKSksXG4gICAgICAgICAgICB9LCBmb3JjZWRTdGFydFR6bzogbmV3RGF0ZUVudi5jYW5Db21wdXRlT2Zmc2V0ID8gbnVsbCA6IGluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLCBmb3JjZWRFbmRUem86IG5ld0RhdGVFbnYuY2FuQ29tcHV0ZU9mZnNldCA/IG51bGwgOiBpbnN0YW5jZS5mb3JjZWRFbmRUem8gfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgZGVmcywgaW5zdGFuY2VzIH07XG59XG5mdW5jdGlvbiBleGNsdWRlRXZlbnRzQnlTb3VyY2VJZChldmVudFN0b3JlLCBzb3VyY2VJZCkge1xuICAgIHJldHVybiBmaWx0ZXJFdmVudFN0b3JlRGVmcyhldmVudFN0b3JlLCAoZXZlbnREZWYpID0+IGV2ZW50RGVmLnNvdXJjZUlkICE9PSBzb3VyY2VJZCk7XG59XG4vLyBRVUVTVElPTjogd2h5IG5vdCBqdXN0IHJldHVybiBpbnN0YW5jZXM/IGRvIGEgZ2VuZXJhbCBvYmplY3QtcHJvcGVydHktZXhjbHVzaW9uIHV0aWxcbmZ1bmN0aW9uIGV4Y2x1ZGVJbnN0YW5jZXMoZXZlbnRTdG9yZSwgcmVtb3ZhbHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWZzOiBldmVudFN0b3JlLmRlZnMsXG4gICAgICAgIGluc3RhbmNlczogZmlsdGVySGFzaChldmVudFN0b3JlLmluc3RhbmNlcywgKGluc3RhbmNlKSA9PiAhcmVtb3ZhbHNbaW5zdGFuY2UuaW5zdGFuY2VJZF0pLFxuICAgIH07XG59XG5mdW5jdGlvbiBidWlsZFB1YmxpY0lkTWFwcyhldmVudFN0b3JlKSB7XG4gICAgY29uc3QgeyBkZWZzLCBpbnN0YW5jZXMgfSA9IGV2ZW50U3RvcmU7XG4gICAgY29uc3QgZGVmSWRNYXAgPSB7fTtcbiAgICBjb25zdCBpbnN0YW5jZUlkTWFwID0ge307XG4gICAgZm9yIChsZXQgZGVmSWQgaW4gZGVmcykge1xuICAgICAgICBjb25zdCBkZWYgPSBkZWZzW2RlZklkXTtcbiAgICAgICAgY29uc3QgeyBwdWJsaWNJZCB9ID0gZGVmO1xuICAgICAgICBpZiAocHVibGljSWQpIHtcbiAgICAgICAgICAgIGRlZklkTWFwW3B1YmxpY0lkXSA9IGRlZklkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGluc3RhbmNlSWQgaW4gaW5zdGFuY2VzKSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gaW5zdGFuY2VzW2luc3RhbmNlSWRdO1xuICAgICAgICBjb25zdCBkZWYgPSBkZWZzW2luc3RhbmNlLmRlZklkXTtcbiAgICAgICAgY29uc3QgeyBwdWJsaWNJZCB9ID0gZGVmO1xuICAgICAgICBpZiAocHVibGljSWQpIHtcbiAgICAgICAgICAgIGluc3RhbmNlSWRNYXBbcHVibGljSWRdID0gaW5zdGFuY2VJZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBkZWZJZE1hcCwgaW5zdGFuY2VJZE1hcCB9O1xufVxuXG5jbGFzcyBFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IHt9O1xuICAgICAgICB0aGlzLnRoaXNDb250ZXh0ID0gbnVsbDtcbiAgICB9XG4gICAgc2V0VGhpc0NvbnRleHQodGhpc0NvbnRleHQpIHtcbiAgICAgICAgdGhpcy50aGlzQ29udGV4dCA9IHRoaXNDb250ZXh0O1xuICAgIH1cbiAgICBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgb24odHlwZSwgaGFuZGxlcikge1xuICAgICAgICBhZGRUb0hhc2godGhpcy5oYW5kbGVycywgdHlwZSwgaGFuZGxlcik7XG4gICAgfVxuICAgIG9mZih0eXBlLCBoYW5kbGVyKSB7XG4gICAgICAgIHJlbW92ZUZyb21IYXNoKHRoaXMuaGFuZGxlcnMsIHR5cGUsIGhhbmRsZXIpO1xuICAgIH1cbiAgICB0cmlnZ2VyKHR5cGUsIC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IGF0dGFjaGVkSGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzW3R5cGVdIHx8IFtdO1xuICAgICAgICBsZXQgb3B0aW9uSGFuZGxlciA9IHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnNbdHlwZV07XG4gICAgICAgIGxldCBoYW5kbGVycyA9IFtdLmNvbmNhdChvcHRpb25IYW5kbGVyIHx8IFtdLCBhdHRhY2hlZEhhbmRsZXJzKTtcbiAgICAgICAgZm9yIChsZXQgaGFuZGxlciBvZiBoYW5kbGVycykge1xuICAgICAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLnRoaXNDb250ZXh0LCBhcmdzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYXNIYW5kbGVycyh0eXBlKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKCh0aGlzLmhhbmRsZXJzW3R5cGVdICYmIHRoaXMuaGFuZGxlcnNbdHlwZV0ubGVuZ3RoKSB8fFxuICAgICAgICAgICAgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnNbdHlwZV0pKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRUb0hhc2goaGFzaCwgdHlwZSwgaGFuZGxlcikge1xuICAgIChoYXNoW3R5cGVdIHx8IChoYXNoW3R5cGVdID0gW10pKVxuICAgICAgICAucHVzaChoYW5kbGVyKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUZyb21IYXNoKGhhc2gsIHR5cGUsIGhhbmRsZXIpIHtcbiAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICBpZiAoaGFzaFt0eXBlXSkge1xuICAgICAgICAgICAgaGFzaFt0eXBlXSA9IGhhc2hbdHlwZV0uZmlsdGVyKChmdW5jKSA9PiBmdW5jICE9PSBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZGVsZXRlIGhhc2hbdHlwZV07IC8vIHJlbW92ZSBhbGwgaGFuZGxlciBmdW5jcyBmb3IgdGhpcyB0eXBlXG4gICAgfVxufVxuXG5jb25zdCBERUZfREVGQVVMVFMgPSB7XG4gICAgc3RhcnRUaW1lOiAnMDk6MDAnLFxuICAgIGVuZFRpbWU6ICcxNzowMCcsXG4gICAgZGF5c09mV2VlazogWzEsIDIsIDMsIDQsIDVdLFxuICAgIGRpc3BsYXk6ICdpbnZlcnNlLWJhY2tncm91bmQnLFxuICAgIGNsYXNzTmFtZXM6ICdmYy1ub24tYnVzaW5lc3MnLFxuICAgIGdyb3VwSWQ6ICdfYnVzaW5lc3NIb3VycycsIC8vIHNvIG11bHRpcGxlIGRlZnMgZ2V0IGdyb3VwZWRcbn07XG4vKlxuVE9ETzogcGFzcyBhcm91bmQgYXMgRXZlbnREZWZIYXNoISEhXG4qL1xuZnVuY3Rpb24gcGFyc2VCdXNpbmVzc0hvdXJzKGlucHV0LCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHBhcnNlRXZlbnRzKHJlZmluZUlucHV0cyhpbnB1dCksIG51bGwsIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gcmVmaW5lSW5wdXRzKGlucHV0KSB7XG4gICAgbGV0IHJhd0RlZnM7XG4gICAgaWYgKGlucHV0ID09PSB0cnVlKSB7XG4gICAgICAgIHJhd0RlZnMgPSBbe31dOyAvLyB3aWxsIGdldCBERUZfREVGQVVMVFMgdmVyYmF0aW1cbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgLy8gaWYgc3BlY2lmeWluZyBhbiBhcnJheSwgZXZlcnkgc3ViLWRlZmluaXRpb24gTkVFRFMgYSBkYXktb2Ytd2Vla1xuICAgICAgICByYXdEZWZzID0gaW5wdXQuZmlsdGVyKChyYXdEZWYpID0+IHJhd0RlZi5kYXlzT2ZXZWVrKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiBpbnB1dCkgeyAvLyBub24tbnVsbCBvYmplY3RcbiAgICAgICAgcmF3RGVmcyA9IFtpbnB1dF07XG4gICAgfVxuICAgIGVsc2UgeyAvLyBpcyBwcm9iYWJseSBmYWxzZVxuICAgICAgICByYXdEZWZzID0gW107XG4gICAgfVxuICAgIHJhd0RlZnMgPSByYXdEZWZzLm1hcCgocmF3RGVmKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBERUZfREVGQVVMVFMpLCByYXdEZWYpKSk7XG4gICAgcmV0dXJuIHJhd0RlZnM7XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXJEYXRlU2VsZWN0KHNlbGVjdGlvbiwgcGV2LCBjb250ZXh0KSB7XG4gICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ3NlbGVjdCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYnVpbGREYXRlU3BhbkFwaVdpdGhDb250ZXh0KHNlbGVjdGlvbiwgY29udGV4dCkpLCB7IGpzRXZlbnQ6IHBldiA/IHBldi5vcmlnRXZlbnQgOiBudWxsLCB2aWV3OiBjb250ZXh0LnZpZXdBcGkgfHwgY29udGV4dC5jYWxlbmRhckFwaS52aWV3IH0pKTtcbn1cbmZ1bmN0aW9uIHRyaWdnZXJEYXRlVW5zZWxlY3QocGV2LCBjb250ZXh0KSB7XG4gICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ3Vuc2VsZWN0Jywge1xuICAgICAgICBqc0V2ZW50OiBwZXYgPyBwZXYub3JpZ0V2ZW50IDogbnVsbCxcbiAgICAgICAgdmlldzogY29udGV4dC52aWV3QXBpIHx8IGNvbnRleHQuY2FsZW5kYXJBcGkudmlldyxcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRGF0ZVNwYW5BcGlXaXRoQ29udGV4dChkYXRlU3BhbiwgY29udGV4dCkge1xuICAgIGxldCBwcm9wcyA9IHt9O1xuICAgIGZvciAobGV0IHRyYW5zZm9ybSBvZiBjb250ZXh0LnBsdWdpbkhvb2tzLmRhdGVTcGFuVHJhbnNmb3Jtcykge1xuICAgICAgICBPYmplY3QuYXNzaWduKHByb3BzLCB0cmFuc2Zvcm0oZGF0ZVNwYW4sIGNvbnRleHQpKTtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbihwcm9wcywgYnVpbGREYXRlU3BhbkFwaShkYXRlU3BhbiwgY29udGV4dC5kYXRlRW52KSk7XG4gICAgcmV0dXJuIHByb3BzO1xufVxuLy8gR2l2ZW4gYW4gZXZlbnQncyBhbGxEYXkgc3RhdHVzIGFuZCBzdGFydCBkYXRlLCByZXR1cm4gd2hhdCBpdHMgZmFsbGJhY2sgZW5kIGRhdGUgc2hvdWxkIGJlLlxuLy8gVE9ETzogcmVuYW1lIHRvIGNvbXB1dGVEZWZhdWx0RXZlbnRFbmRcbmZ1bmN0aW9uIGdldERlZmF1bHRFdmVudEVuZChhbGxEYXksIG1hcmtlciwgY29udGV4dCkge1xuICAgIGxldCB7IGRhdGVFbnYsIG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgbGV0IGVuZCA9IG1hcmtlcjtcbiAgICBpZiAoYWxsRGF5KSB7XG4gICAgICAgIGVuZCA9IHN0YXJ0T2ZEYXkoZW5kKTtcbiAgICAgICAgZW5kID0gZGF0ZUVudi5hZGQoZW5kLCBvcHRpb25zLmRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVuZCA9IGRhdGVFbnYuYWRkKGVuZCwgb3B0aW9ucy5kZWZhdWx0VGltZWRFdmVudER1cmF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIGVuZDtcbn1cblxuLy8gYXBwbGllcyB0aGUgbXV0YXRpb24gdG8gQUxMIGRlZnMvaW5zdGFuY2VzIHdpdGhpbiB0aGUgZXZlbnQgc3RvcmVcbmZ1bmN0aW9uIGFwcGx5TXV0YXRpb25Ub0V2ZW50U3RvcmUoZXZlbnRTdG9yZSwgZXZlbnRDb25maWdCYXNlLCBtdXRhdGlvbiwgY29udGV4dCkge1xuICAgIGxldCBldmVudENvbmZpZ3MgPSBjb21waWxlRXZlbnRVaXMoZXZlbnRTdG9yZS5kZWZzLCBldmVudENvbmZpZ0Jhc2UpO1xuICAgIGxldCBkZXN0ID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7XG4gICAgZm9yIChsZXQgZGVmSWQgaW4gZXZlbnRTdG9yZS5kZWZzKSB7XG4gICAgICAgIGxldCBkZWYgPSBldmVudFN0b3JlLmRlZnNbZGVmSWRdO1xuICAgICAgICBkZXN0LmRlZnNbZGVmSWRdID0gYXBwbHlNdXRhdGlvblRvRXZlbnREZWYoZGVmLCBldmVudENvbmZpZ3NbZGVmSWRdLCBtdXRhdGlvbiwgY29udGV4dCk7XG4gICAgfVxuICAgIGZvciAobGV0IGluc3RhbmNlSWQgaW4gZXZlbnRTdG9yZS5pbnN0YW5jZXMpIHtcbiAgICAgICAgbGV0IGluc3RhbmNlID0gZXZlbnRTdG9yZS5pbnN0YW5jZXNbaW5zdGFuY2VJZF07XG4gICAgICAgIGxldCBkZWYgPSBkZXN0LmRlZnNbaW5zdGFuY2UuZGVmSWRdOyAvLyBpbXBvcnRhbnQgdG8gZ3JhYiB0aGUgbmV3bHkgbW9kaWZpZWQgZGVmXG4gICAgICAgIGRlc3QuaW5zdGFuY2VzW2luc3RhbmNlSWRdID0gYXBwbHlNdXRhdGlvblRvRXZlbnRJbnN0YW5jZShpbnN0YW5jZSwgZGVmLCBldmVudENvbmZpZ3NbaW5zdGFuY2UuZGVmSWRdLCBtdXRhdGlvbiwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xufVxuZnVuY3Rpb24gYXBwbHlNdXRhdGlvblRvRXZlbnREZWYoZXZlbnREZWYsIGV2ZW50Q29uZmlnLCBtdXRhdGlvbiwgY29udGV4dCkge1xuICAgIGxldCBzdGFuZGFyZFByb3BzID0gbXV0YXRpb24uc3RhbmRhcmRQcm9wcyB8fCB7fTtcbiAgICAvLyBpZiBoYXNFbmQgaGFzIG5vdCBiZWVuIHNwZWNpZmllZCwgZ3Vlc3MgYSBnb29kIHZhbHVlIGJhc2VkIG9uIGRlbHRhcy5cbiAgICAvLyBpZiBkdXJhdGlvbiB3aWxsIGNoYW5nZSwgdGhlcmUncyBubyB3YXkgdGhlIGRlZmF1bHQgZHVyYXRpb24gd2lsbCBwZXJzaXN0LFxuICAgIC8vIGFuZCB0aHVzLCB3ZSBuZWVkIHRvIG1hcmsgdGhlIGV2ZW50IGFzIGhhdmluZyBhIHJlYWwgZW5kXG4gICAgaWYgKHN0YW5kYXJkUHJvcHMuaGFzRW5kID09IG51bGwgJiZcbiAgICAgICAgZXZlbnRDb25maWcuZHVyYXRpb25FZGl0YWJsZSAmJlxuICAgICAgICAobXV0YXRpb24uc3RhcnREZWx0YSB8fCBtdXRhdGlvbi5lbmREZWx0YSkpIHtcbiAgICAgICAgc3RhbmRhcmRQcm9wcy5oYXNFbmQgPSB0cnVlOyAvLyBUT0RPOiBpcyB0aGlzIG11dGF0aW9uIG9rYXk/XG4gICAgfVxuICAgIGxldCBjb3B5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV2ZW50RGVmKSwgc3RhbmRhcmRQcm9wcyksIHsgdWk6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXZlbnREZWYudWkpLCBzdGFuZGFyZFByb3BzLnVpKSB9KTtcbiAgICBpZiAobXV0YXRpb24uZXh0ZW5kZWRQcm9wcykge1xuICAgICAgICBjb3B5LmV4dGVuZGVkUHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvcHkuZXh0ZW5kZWRQcm9wcyksIG11dGF0aW9uLmV4dGVuZGVkUHJvcHMpO1xuICAgIH1cbiAgICBmb3IgKGxldCBhcHBsaWVyIG9mIGNvbnRleHQucGx1Z2luSG9va3MuZXZlbnREZWZNdXRhdGlvbkFwcGxpZXJzKSB7XG4gICAgICAgIGFwcGxpZXIoY29weSwgbXV0YXRpb24sIGNvbnRleHQpO1xuICAgIH1cbiAgICBpZiAoIWNvcHkuaGFzRW5kICYmIGNvbnRleHQub3B0aW9ucy5mb3JjZUV2ZW50RHVyYXRpb24pIHtcbiAgICAgICAgY29weS5oYXNFbmQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gY29weTtcbn1cbmZ1bmN0aW9uIGFwcGx5TXV0YXRpb25Ub0V2ZW50SW5zdGFuY2UoZXZlbnRJbnN0YW5jZSwgZXZlbnREZWYsIC8vIG11c3QgZmlyc3QgYmUgbW9kaWZpZWQgYnkgYXBwbHlNdXRhdGlvblRvRXZlbnREZWZcbmV2ZW50Q29uZmlnLCBtdXRhdGlvbiwgY29udGV4dCkge1xuICAgIGxldCB7IGRhdGVFbnYgfSA9IGNvbnRleHQ7XG4gICAgbGV0IGZvcmNlQWxsRGF5ID0gbXV0YXRpb24uc3RhbmRhcmRQcm9wcyAmJiBtdXRhdGlvbi5zdGFuZGFyZFByb3BzLmFsbERheSA9PT0gdHJ1ZTtcbiAgICBsZXQgY2xlYXJFbmQgPSBtdXRhdGlvbi5zdGFuZGFyZFByb3BzICYmIG11dGF0aW9uLnN0YW5kYXJkUHJvcHMuaGFzRW5kID09PSBmYWxzZTtcbiAgICBsZXQgY29weSA9IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50SW5zdGFuY2UpO1xuICAgIGlmIChmb3JjZUFsbERheSkge1xuICAgICAgICBjb3B5LnJhbmdlID0gY29tcHV0ZUFsaWduZWREYXlSYW5nZShjb3B5LnJhbmdlKTtcbiAgICB9XG4gICAgaWYgKG11dGF0aW9uLmRhdGVzRGVsdGEgJiYgZXZlbnRDb25maWcuc3RhcnRFZGl0YWJsZSkge1xuICAgICAgICBjb3B5LnJhbmdlID0ge1xuICAgICAgICAgICAgc3RhcnQ6IGRhdGVFbnYuYWRkKGNvcHkucmFuZ2Uuc3RhcnQsIG11dGF0aW9uLmRhdGVzRGVsdGEpLFxuICAgICAgICAgICAgZW5kOiBkYXRlRW52LmFkZChjb3B5LnJhbmdlLmVuZCwgbXV0YXRpb24uZGF0ZXNEZWx0YSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChtdXRhdGlvbi5zdGFydERlbHRhICYmIGV2ZW50Q29uZmlnLmR1cmF0aW9uRWRpdGFibGUpIHtcbiAgICAgICAgY29weS5yYW5nZSA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiBkYXRlRW52LmFkZChjb3B5LnJhbmdlLnN0YXJ0LCBtdXRhdGlvbi5zdGFydERlbHRhKSxcbiAgICAgICAgICAgIGVuZDogY29weS5yYW5nZS5lbmQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChtdXRhdGlvbi5lbmREZWx0YSAmJiBldmVudENvbmZpZy5kdXJhdGlvbkVkaXRhYmxlKSB7XG4gICAgICAgIGNvcHkucmFuZ2UgPSB7XG4gICAgICAgICAgICBzdGFydDogY29weS5yYW5nZS5zdGFydCxcbiAgICAgICAgICAgIGVuZDogZGF0ZUVudi5hZGQoY29weS5yYW5nZS5lbmQsIG11dGF0aW9uLmVuZERlbHRhKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGNsZWFyRW5kKSB7XG4gICAgICAgIGNvcHkucmFuZ2UgPSB7XG4gICAgICAgICAgICBzdGFydDogY29weS5yYW5nZS5zdGFydCxcbiAgICAgICAgICAgIGVuZDogZ2V0RGVmYXVsdEV2ZW50RW5kKGV2ZW50RGVmLmFsbERheSwgY29weS5yYW5nZS5zdGFydCwgY29udGV4dCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIGluIGNhc2UgZXZlbnQgd2FzIGFsbC1kYXkgYnV0IHRoZSBzdXBwbGllZCBkZWx0YXMgd2VyZSBub3RcbiAgICAvLyBiZXR0ZXIgdXRpbCBmb3IgdGhpcz9cbiAgICBpZiAoZXZlbnREZWYuYWxsRGF5KSB7XG4gICAgICAgIGNvcHkucmFuZ2UgPSB7XG4gICAgICAgICAgICBzdGFydDogc3RhcnRPZkRheShjb3B5LnJhbmdlLnN0YXJ0KSxcbiAgICAgICAgICAgIGVuZDogc3RhcnRPZkRheShjb3B5LnJhbmdlLmVuZCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIGhhbmRsZSBpbnZhbGlkIGR1cmF0aW9uc1xuICAgIGlmIChjb3B5LnJhbmdlLmVuZCA8IGNvcHkucmFuZ2Uuc3RhcnQpIHtcbiAgICAgICAgY29weS5yYW5nZS5lbmQgPSBnZXREZWZhdWx0RXZlbnRFbmQoZXZlbnREZWYuYWxsRGF5LCBjb3B5LnJhbmdlLnN0YXJ0LCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvcHk7XG59XG5cbmNsYXNzIEV2ZW50U291cmNlSW1wbCB7XG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgaW50ZXJuYWxFdmVudFNvdXJjZSkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmludGVybmFsRXZlbnRTb3VyY2UgPSBpbnRlcm5hbEV2ZW50U291cmNlO1xuICAgIH1cbiAgICByZW1vdmUoKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnUkVNT1ZFX0VWRU5UX1NPVVJDRScsXG4gICAgICAgICAgICBzb3VyY2VJZDogdGhpcy5pbnRlcm5hbEV2ZW50U291cmNlLnNvdXJjZUlkLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVmZXRjaCgpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdGRVRDSF9FVkVOVF9TT1VSQ0VTJyxcbiAgICAgICAgICAgIHNvdXJjZUlkczogW3RoaXMuaW50ZXJuYWxFdmVudFNvdXJjZS5zb3VyY2VJZF0sXG4gICAgICAgICAgICBpc1JlZmV0Y2g6IHRydWUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsRXZlbnRTb3VyY2UucHVibGljSWQ7XG4gICAgfVxuICAgIGdldCB1cmwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsRXZlbnRTb3VyY2UubWV0YS51cmw7XG4gICAgfVxuICAgIGdldCBmb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsRXZlbnRTb3VyY2UubWV0YS5mb3JtYXQ7IC8vIFRPRE86IGJhZC4gbm90IGd1YXJhbnRlZWRcbiAgICB9XG59XG5cbmNsYXNzIEV2ZW50SW1wbCB7XG4gICAgLy8gaW5zdGFuY2Ugd2lsbCBiZSBudWxsIGlmIGV4cHJlc3NpbmcgYSByZWN1cnJpbmcgZXZlbnQgdGhhdCBoYXMgbm8gY3VycmVudCBpbnN0YW5jZXMsXG4gICAgLy8gT1IgaWYgdHJ5aW5nIHRvIHZhbGlkYXRlIGFuIGluY29taW5nIGV4dGVybmFsIGV2ZW50IHRoYXQgaGFzIG5vIGRhdGVzIGFzc2lnbmVkXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgZGVmLCBpbnN0YW5jZSkge1xuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5fZGVmID0gZGVmO1xuICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IGluc3RhbmNlIHx8IG51bGw7XG4gICAgfVxuICAgIC8qXG4gICAgVE9ETzogbWFrZSBldmVudCBzdHJ1Y3QgbW9yZSByZXNwb25zaWJsZSBmb3IgdGhpc1xuICAgICovXG4gICAgc2V0UHJvcChuYW1lLCB2YWwpIHtcbiAgICAgICAgaWYgKG5hbWUgaW4gRVZFTlRfREFURV9SRUZJTkVSUykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3Qgc2V0IGRhdGUtcmVsYXRlZCBwcm9wIFxcJ25hbWVcXCcuIFVzZSBvbmUgb2YgdGhlIGRhdGUtcmVsYXRlZCBtZXRob2RzIGluc3RlYWQuJyk7XG4gICAgICAgICAgICAvLyBUT0RPOiBtYWtlIHByb3BlciBhbGlhc2luZyBzeXN0ZW0/XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gJ2lkJykge1xuICAgICAgICAgICAgdmFsID0gRVZFTlRfTk9OX0RBVEVfUkVGSU5FUlNbbmFtZV0odmFsKTtcbiAgICAgICAgICAgIHRoaXMubXV0YXRlKHtcbiAgICAgICAgICAgICAgICBzdGFuZGFyZFByb3BzOiB7IHB1YmxpY0lkOiB2YWwgfSwgLy8gaGFyZGNvZGVkIGludGVybmFsIG5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWUgaW4gRVZFTlRfTk9OX0RBVEVfUkVGSU5FUlMpIHtcbiAgICAgICAgICAgIHZhbCA9IEVWRU5UX05PTl9EQVRFX1JFRklORVJTW25hbWVdKHZhbCk7XG4gICAgICAgICAgICB0aGlzLm11dGF0ZSh7XG4gICAgICAgICAgICAgICAgc3RhbmRhcmRQcm9wczogeyBbbmFtZV06IHZhbCB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmFtZSBpbiBFVkVOVF9VSV9SRUZJTkVSUykge1xuICAgICAgICAgICAgbGV0IHVpID0gRVZFTlRfVUlfUkVGSU5FUlNbbmFtZV0odmFsKTtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnY29sb3InKSB7XG4gICAgICAgICAgICAgICAgdWkgPSB7IGJhY2tncm91bmRDb2xvcjogdmFsLCBib3JkZXJDb2xvcjogdmFsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnZWRpdGFibGUnKSB7XG4gICAgICAgICAgICAgICAgdWkgPSB7IHN0YXJ0RWRpdGFibGU6IHZhbCwgZHVyYXRpb25FZGl0YWJsZTogdmFsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1aSA9IHsgW25hbWVdOiB2YWwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubXV0YXRlKHtcbiAgICAgICAgICAgICAgICBzdGFuZGFyZFByb3BzOiB7IHVpIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgQ291bGQgbm90IHNldCBwcm9wICcke25hbWV9Jy4gVXNlIHNldEV4dGVuZGVkUHJvcCBpbnN0ZWFkLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldEV4dGVuZGVkUHJvcChuYW1lLCB2YWwpIHtcbiAgICAgICAgdGhpcy5tdXRhdGUoe1xuICAgICAgICAgICAgZXh0ZW5kZWRQcm9wczogeyBbbmFtZV06IHZhbCB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2V0U3RhcnQoc3RhcnRJbnB1dCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCB7IGRhdGVFbnYgfSA9IHRoaXMuX2NvbnRleHQ7XG4gICAgICAgIGxldCBzdGFydCA9IGRhdGVFbnYuY3JlYXRlTWFya2VyKHN0YXJ0SW5wdXQpO1xuICAgICAgICBpZiAoc3RhcnQgJiYgdGhpcy5faW5zdGFuY2UpIHsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXG4gICAgICAgICAgICBsZXQgaW5zdGFuY2VSYW5nZSA9IHRoaXMuX2luc3RhbmNlLnJhbmdlO1xuICAgICAgICAgICAgbGV0IHN0YXJ0RGVsdGEgPSBkaWZmRGF0ZXMoaW5zdGFuY2VSYW5nZS5zdGFydCwgc3RhcnQsIGRhdGVFbnYsIG9wdGlvbnMuZ3JhbnVsYXJpdHkpOyAvLyB3aGF0IGlmIHBhcnNlZCBiYWQhP1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMubWFpbnRhaW5EdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgZGF0ZXNEZWx0YTogc3RhcnREZWx0YSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhcnREZWx0YSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRFbmQoZW5kSW5wdXQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgeyBkYXRlRW52IH0gPSB0aGlzLl9jb250ZXh0O1xuICAgICAgICBsZXQgZW5kO1xuICAgICAgICBpZiAoZW5kSW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgZW5kID0gZGF0ZUVudi5jcmVhdGVNYXJrZXIoZW5kSW5wdXQpO1xuICAgICAgICAgICAgaWYgKCFlbmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIFRPRE86IHdhcm5pbmcgaWYgcGFyc2VkIGJhZFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgICAgICAgaWYgKGVuZCkge1xuICAgICAgICAgICAgICAgIGxldCBlbmREZWx0YSA9IGRpZmZEYXRlcyh0aGlzLl9pbnN0YW5jZS5yYW5nZS5lbmQsIGVuZCwgZGF0ZUVudiwgb3B0aW9ucy5ncmFudWxhcml0eSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tdXRhdGUoeyBlbmREZWx0YSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhbmRhcmRQcm9wczogeyBoYXNFbmQ6IGZhbHNlIH0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0RGF0ZXMoc3RhcnRJbnB1dCwgZW5kSW5wdXQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgeyBkYXRlRW52IH0gPSB0aGlzLl9jb250ZXh0O1xuICAgICAgICBsZXQgc3RhbmRhcmRQcm9wcyA9IHsgYWxsRGF5OiBvcHRpb25zLmFsbERheSB9O1xuICAgICAgICBsZXQgc3RhcnQgPSBkYXRlRW52LmNyZWF0ZU1hcmtlcihzdGFydElucHV0KTtcbiAgICAgICAgbGV0IGVuZDtcbiAgICAgICAgaWYgKCFzdGFydCkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kSW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgZW5kID0gZGF0ZUVudi5jcmVhdGVNYXJrZXIoZW5kSW5wdXQpO1xuICAgICAgICAgICAgaWYgKCFlbmQpIHsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgICAgICAgbGV0IGluc3RhbmNlUmFuZ2UgPSB0aGlzLl9pbnN0YW5jZS5yYW5nZTtcbiAgICAgICAgICAgIC8vIHdoZW4gY29tcHV0aW5nIHRoZSBkaWZmIGZvciBhbiBldmVudCBiZWluZyBjb252ZXJ0ZWQgdG8gYWxsLWRheSxcbiAgICAgICAgICAgIC8vIGNvbXB1dGUgZGlmZiBvZmYgb2YgdGhlIGFsbC1kYXkgdmFsdWVzIHRoZSB3YXkgZXZlbnQtbXV0YXRpb24gZG9lcy5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFsbERheSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlUmFuZ2UgPSBjb21wdXRlQWxpZ25lZERheVJhbmdlKGluc3RhbmNlUmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHN0YXJ0RGVsdGEgPSBkaWZmRGF0ZXMoaW5zdGFuY2VSYW5nZS5zdGFydCwgc3RhcnQsIGRhdGVFbnYsIG9wdGlvbnMuZ3JhbnVsYXJpdHkpO1xuICAgICAgICAgICAgaWYgKGVuZCkge1xuICAgICAgICAgICAgICAgIGxldCBlbmREZWx0YSA9IGRpZmZEYXRlcyhpbnN0YW5jZVJhbmdlLmVuZCwgZW5kLCBkYXRlRW52LCBvcHRpb25zLmdyYW51bGFyaXR5KTtcbiAgICAgICAgICAgICAgICBpZiAoZHVyYXRpb25zRXF1YWwoc3RhcnREZWx0YSwgZW5kRGVsdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgZGF0ZXNEZWx0YTogc3RhcnREZWx0YSwgc3RhbmRhcmRQcm9wcyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhcnREZWx0YSwgZW5kRGVsdGEsIHN0YW5kYXJkUHJvcHMgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7IC8vIG1lYW5zIFwiY2xlYXIgdGhlIGVuZFwiXG4gICAgICAgICAgICAgICAgc3RhbmRhcmRQcm9wcy5oYXNFbmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLm11dGF0ZSh7IGRhdGVzRGVsdGE6IHN0YXJ0RGVsdGEsIHN0YW5kYXJkUHJvcHMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW92ZVN0YXJ0KGRlbHRhSW5wdXQpIHtcbiAgICAgICAgbGV0IGRlbHRhID0gY3JlYXRlRHVyYXRpb24oZGVsdGFJbnB1dCk7XG4gICAgICAgIGlmIChkZWx0YSkgeyAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcbiAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhcnREZWx0YTogZGVsdGEgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW92ZUVuZChkZWx0YUlucHV0KSB7XG4gICAgICAgIGxldCBkZWx0YSA9IGNyZWF0ZUR1cmF0aW9uKGRlbHRhSW5wdXQpO1xuICAgICAgICBpZiAoZGVsdGEpIHsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXG4gICAgICAgICAgICB0aGlzLm11dGF0ZSh7IGVuZERlbHRhOiBkZWx0YSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtb3ZlRGF0ZXMoZGVsdGFJbnB1dCkge1xuICAgICAgICBsZXQgZGVsdGEgPSBjcmVhdGVEdXJhdGlvbihkZWx0YUlucHV0KTtcbiAgICAgICAgaWYgKGRlbHRhKSB7IC8vIFRPRE86IHdhcm5pbmcgaWYgcGFyc2VkIGJhZFxuICAgICAgICAgICAgdGhpcy5tdXRhdGUoeyBkYXRlc0RlbHRhOiBkZWx0YSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRBbGxEYXkoYWxsRGF5LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgbGV0IHN0YW5kYXJkUHJvcHMgPSB7IGFsbERheSB9O1xuICAgICAgICBsZXQgeyBtYWludGFpbkR1cmF0aW9uIH0gPSBvcHRpb25zO1xuICAgICAgICBpZiAobWFpbnRhaW5EdXJhdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICBtYWludGFpbkR1cmF0aW9uID0gdGhpcy5fY29udGV4dC5vcHRpb25zLmFsbERheU1haW50YWluRHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2RlZi5hbGxEYXkgIT09IGFsbERheSkge1xuICAgICAgICAgICAgc3RhbmRhcmRQcm9wcy5oYXNFbmQgPSBtYWludGFpbkR1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubXV0YXRlKHsgc3RhbmRhcmRQcm9wcyB9KTtcbiAgICB9XG4gICAgZm9ybWF0UmFuZ2UoZm9ybWF0SW5wdXQpIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5fY29udGV4dDtcbiAgICAgICAgbGV0IGluc3RhbmNlID0gdGhpcy5faW5zdGFuY2U7XG4gICAgICAgIGxldCBmb3JtYXR0ZXIgPSBjcmVhdGVGb3JtYXR0ZXIoZm9ybWF0SW5wdXQpO1xuICAgICAgICBpZiAodGhpcy5fZGVmLmhhc0VuZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0UmFuZ2UoaW5zdGFuY2UucmFuZ2Uuc3RhcnQsIGluc3RhbmNlLnJhbmdlLmVuZCwgZm9ybWF0dGVyLCB7XG4gICAgICAgICAgICAgICAgZm9yY2VkU3RhcnRUem86IGluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLFxuICAgICAgICAgICAgICAgIGZvcmNlZEVuZFR6bzogaW5zdGFuY2UuZm9yY2VkRW5kVHpvLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0KGluc3RhbmNlLnJhbmdlLnN0YXJ0LCBmb3JtYXR0ZXIsIHtcbiAgICAgICAgICAgIGZvcmNlZFR6bzogaW5zdGFuY2UuZm9yY2VkU3RhcnRUem8sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtdXRhdGUobXV0YXRpb24pIHtcbiAgICAgICAgbGV0IGluc3RhbmNlID0gdGhpcy5faW5zdGFuY2U7XG4gICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgbGV0IGRlZiA9IHRoaXMuX2RlZjtcbiAgICAgICAgICAgIGxldCBjb250ZXh0ID0gdGhpcy5fY29udGV4dDtcbiAgICAgICAgICAgIGxldCB7IGV2ZW50U3RvcmUgfSA9IGNvbnRleHQuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgICAgIGxldCByZWxldmFudEV2ZW50cyA9IGdldFJlbGV2YW50RXZlbnRzKGV2ZW50U3RvcmUsIGluc3RhbmNlLmluc3RhbmNlSWQpO1xuICAgICAgICAgICAgbGV0IGV2ZW50Q29uZmlnQmFzZSA9IHtcbiAgICAgICAgICAgICAgICAnJzoge1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnJyxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRFZGl0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb25FZGl0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBvdmVybGFwOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd3M6IFtdLFxuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcnLFxuICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogJycsXG4gICAgICAgICAgICAgICAgICAgIHRleHRDb2xvcjogJycsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZXM6IFtdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVsZXZhbnRFdmVudHMgPSBhcHBseU11dGF0aW9uVG9FdmVudFN0b3JlKHJlbGV2YW50RXZlbnRzLCBldmVudENvbmZpZ0Jhc2UsIG11dGF0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGxldCBvbGRFdmVudCA9IG5ldyBFdmVudEltcGwoY29udGV4dCwgZGVmLCBpbnN0YW5jZSk7IC8vIHNuYXBzaG90XG4gICAgICAgICAgICB0aGlzLl9kZWYgPSByZWxldmFudEV2ZW50cy5kZWZzW2RlZi5kZWZJZF07XG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IHJlbGV2YW50RXZlbnRzLmluc3RhbmNlc1tpbnN0YW5jZS5pbnN0YW5jZUlkXTtcbiAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdNRVJHRV9FVkVOVFMnLFxuICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IHJlbGV2YW50RXZlbnRzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRDaGFuZ2UnLCB7XG4gICAgICAgICAgICAgICAgb2xkRXZlbnQsXG4gICAgICAgICAgICAgICAgZXZlbnQ6IHRoaXMsXG4gICAgICAgICAgICAgICAgcmVsYXRlZEV2ZW50czogYnVpbGRFdmVudEFwaXMocmVsZXZhbnRFdmVudHMsIGNvbnRleHQsIGluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICByZXZlcnQoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1JFU0VUX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlLCAvLyB0aGUgT1JJR0lOQUwgc3RvcmVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZSgpIHtcbiAgICAgICAgbGV0IGNvbnRleHQgPSB0aGlzLl9jb250ZXh0O1xuICAgICAgICBsZXQgYXNTdG9yZSA9IGV2ZW50QXBpVG9TdG9yZSh0aGlzKTtcbiAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnUkVNT1ZFX0VWRU5UUycsXG4gICAgICAgICAgICBldmVudFN0b3JlOiBhc1N0b3JlLFxuICAgICAgICB9KTtcbiAgICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50UmVtb3ZlJywge1xuICAgICAgICAgICAgZXZlbnQ6IHRoaXMsXG4gICAgICAgICAgICByZWxhdGVkRXZlbnRzOiBbXSxcbiAgICAgICAgICAgIHJldmVydCgpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ01FUkdFX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IGFzU3RvcmUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IHNvdXJjZSgpIHtcbiAgICAgICAgbGV0IHsgc291cmNlSWQgfSA9IHRoaXMuX2RlZjtcbiAgICAgICAgaWYgKHNvdXJjZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50U291cmNlSW1wbCh0aGlzLl9jb250ZXh0LCB0aGlzLl9jb250ZXh0LmdldEN1cnJlbnREYXRhKCkuZXZlbnRTb3VyY2VzW3NvdXJjZUlkXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldCBzdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RhbmNlID9cbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZGF0ZUVudi50b0RhdGUodGhpcy5faW5zdGFuY2UucmFuZ2Uuc3RhcnQpIDpcbiAgICAgICAgICAgIG51bGw7XG4gICAgfVxuICAgIGdldCBlbmQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5faW5zdGFuY2UgJiYgdGhpcy5fZGVmLmhhc0VuZCkgP1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5kYXRlRW52LnRvRGF0ZSh0aGlzLl9pbnN0YW5jZS5yYW5nZS5lbmQpIDpcbiAgICAgICAgICAgIG51bGw7XG4gICAgfVxuICAgIGdldCBzdGFydFN0cigpIHtcbiAgICAgICAgbGV0IGluc3RhbmNlID0gdGhpcy5faW5zdGFuY2U7XG4gICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuZGF0ZUVudi5mb3JtYXRJc28oaW5zdGFuY2UucmFuZ2Uuc3RhcnQsIHtcbiAgICAgICAgICAgICAgICBvbWl0VGltZTogdGhpcy5fZGVmLmFsbERheSxcbiAgICAgICAgICAgICAgICBmb3JjZWRUem86IGluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBnZXQgZW5kU3RyKCkge1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIHRoaXMuX2RlZi5oYXNFbmQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmRhdGVFbnYuZm9ybWF0SXNvKGluc3RhbmNlLnJhbmdlLmVuZCwge1xuICAgICAgICAgICAgICAgIG9taXRUaW1lOiB0aGlzLl9kZWYuYWxsRGF5LFxuICAgICAgICAgICAgICAgIGZvcmNlZFR6bzogaW5zdGFuY2UuZm9yY2VkRW5kVHpvLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICAvLyBjb21wdXRhYmxlIHByb3BzIHRoYXQgYWxsIGFjY2VzcyB0aGUgZGVmXG4gICAgLy8gVE9ETzogZmluZCBhIFR5cGVTY3JpcHQtY29tcGF0aWJsZSB3YXkgdG8gZG8gdGhpcyBhdCBzY2FsZVxuICAgIGdldCBpZCgpIHsgcmV0dXJuIHRoaXMuX2RlZi5wdWJsaWNJZDsgfVxuICAgIGdldCBncm91cElkKCkgeyByZXR1cm4gdGhpcy5fZGVmLmdyb3VwSWQ7IH1cbiAgICBnZXQgYWxsRGF5KCkgeyByZXR1cm4gdGhpcy5fZGVmLmFsbERheTsgfVxuICAgIGdldCB0aXRsZSgpIHsgcmV0dXJuIHRoaXMuX2RlZi50aXRsZTsgfVxuICAgIGdldCB1cmwoKSB7IHJldHVybiB0aGlzLl9kZWYudXJsOyB9XG4gICAgZ2V0IGRpc3BsYXkoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuZGlzcGxheSB8fCAnYXV0byc7IH0gLy8gYmFkLiBqdXN0IG5vcm1hbGl6ZSB0aGUgdHlwZSBlYXJsaWVyXG4gICAgZ2V0IHN0YXJ0RWRpdGFibGUoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuc3RhcnRFZGl0YWJsZTsgfVxuICAgIGdldCBkdXJhdGlvbkVkaXRhYmxlKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmR1cmF0aW9uRWRpdGFibGU7IH1cbiAgICBnZXQgY29uc3RyYWludCgpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5jb25zdHJhaW50c1swXSB8fCBudWxsOyB9XG4gICAgZ2V0IG92ZXJsYXAoKSB7IHJldHVybiB0aGlzLl9kZWYudWkub3ZlcmxhcDsgfVxuICAgIGdldCBhbGxvdygpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5hbGxvd3NbMF0gfHwgbnVsbDsgfVxuICAgIGdldCBiYWNrZ3JvdW5kQ29sb3IoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuYmFja2dyb3VuZENvbG9yOyB9XG4gICAgZ2V0IGJvcmRlckNvbG9yKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmJvcmRlckNvbG9yOyB9XG4gICAgZ2V0IHRleHRDb2xvcigpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS50ZXh0Q29sb3I7IH1cbiAgICAvLyBOT1RFOiB1c2VyIGNhbid0IG1vZGlmeSB0aGVzZSBiZWNhdXNlIE9iamVjdC5mcmVlemUgd2FzIGNhbGxlZCBpbiBldmVudC1kZWYgcGFyc2luZ1xuICAgIGdldCBjbGFzc05hbWVzKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmNsYXNzTmFtZXM7IH1cbiAgICBnZXQgZXh0ZW5kZWRQcm9wcygpIHsgcmV0dXJuIHRoaXMuX2RlZi5leHRlbmRlZFByb3BzOyB9XG4gICAgdG9QbGFpbk9iamVjdChzZXR0aW5ncyA9IHt9KSB7XG4gICAgICAgIGxldCBkZWYgPSB0aGlzLl9kZWY7XG4gICAgICAgIGxldCB7IHVpIH0gPSBkZWY7XG4gICAgICAgIGxldCB7IHN0YXJ0U3RyLCBlbmRTdHIgfSA9IHRoaXM7XG4gICAgICAgIGxldCByZXMgPSB7XG4gICAgICAgICAgICBhbGxEYXk6IGRlZi5hbGxEYXksXG4gICAgICAgIH07XG4gICAgICAgIGlmIChkZWYudGl0bGUpIHtcbiAgICAgICAgICAgIHJlcy50aXRsZSA9IGRlZi50aXRsZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRTdHIpIHtcbiAgICAgICAgICAgIHJlcy5zdGFydCA9IHN0YXJ0U3RyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmRTdHIpIHtcbiAgICAgICAgICAgIHJlcy5lbmQgPSBlbmRTdHI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi5wdWJsaWNJZCkge1xuICAgICAgICAgICAgcmVzLmlkID0gZGVmLnB1YmxpY0lkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYuZ3JvdXBJZCkge1xuICAgICAgICAgICAgcmVzLmdyb3VwSWQgPSBkZWYuZ3JvdXBJZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmLnVybCkge1xuICAgICAgICAgICAgcmVzLnVybCA9IGRlZi51cmw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVpLmRpc3BsYXkgJiYgdWkuZGlzcGxheSAhPT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICByZXMuZGlzcGxheSA9IHVpLmRpc3BsYXk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogd2hhdCBhYm91dCByZWN1cnJpbmctZXZlbnQgcHJvcGVydGllcz8/P1xuICAgICAgICAvLyBUT0RPOiBpbmNsdWRlIHN0YXJ0RWRpdGFibGUvZHVyYXRpb25FZGl0YWJsZS9jb25zdHJhaW50L292ZXJsYXAvYWxsb3dcbiAgICAgICAgaWYgKHNldHRpbmdzLmNvbGxhcHNlQ29sb3IgJiYgdWkuYmFja2dyb3VuZENvbG9yICYmIHVpLmJhY2tncm91bmRDb2xvciA9PT0gdWkuYm9yZGVyQ29sb3IpIHtcbiAgICAgICAgICAgIHJlcy5jb2xvciA9IHVpLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh1aS5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgICAgICAgICByZXMuYmFja2dyb3VuZENvbG9yID0gdWkuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVpLmJvcmRlckNvbG9yKSB7XG4gICAgICAgICAgICAgICAgcmVzLmJvcmRlckNvbG9yID0gdWkuYm9yZGVyQ29sb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVpLnRleHRDb2xvcikge1xuICAgICAgICAgICAgcmVzLnRleHRDb2xvciA9IHVpLnRleHRDb2xvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodWkuY2xhc3NOYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlcy5jbGFzc05hbWVzID0gdWkuY2xhc3NOYW1lcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoT2JqZWN0LmtleXMoZGVmLmV4dGVuZGVkUHJvcHMpLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmNvbGxhcHNlRXh0ZW5kZWRQcm9wcykge1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVzLCBkZWYuZXh0ZW5kZWRQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXMuZXh0ZW5kZWRQcm9wcyA9IGRlZi5leHRlbmRlZFByb3BzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9QbGFpbk9iamVjdCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGV2ZW50QXBpVG9TdG9yZShldmVudEFwaSkge1xuICAgIGxldCBkZWYgPSBldmVudEFwaS5fZGVmO1xuICAgIGxldCBpbnN0YW5jZSA9IGV2ZW50QXBpLl9pbnN0YW5jZTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWZzOiB7IFtkZWYuZGVmSWRdOiBkZWYgfSxcbiAgICAgICAgaW5zdGFuY2VzOiBpbnN0YW5jZVxuICAgICAgICAgICAgPyB7IFtpbnN0YW5jZS5pbnN0YW5jZUlkXTogaW5zdGFuY2UgfVxuICAgICAgICAgICAgOiB7fSxcbiAgICB9O1xufVxuZnVuY3Rpb24gYnVpbGRFdmVudEFwaXMoZXZlbnRTdG9yZSwgY29udGV4dCwgZXhjbHVkZUluc3RhbmNlKSB7XG4gICAgbGV0IHsgZGVmcywgaW5zdGFuY2VzIH0gPSBldmVudFN0b3JlO1xuICAgIGxldCBldmVudEFwaXMgPSBbXTtcbiAgICBsZXQgZXhjbHVkZUluc3RhbmNlSWQgPSBleGNsdWRlSW5zdGFuY2UgPyBleGNsdWRlSW5zdGFuY2UuaW5zdGFuY2VJZCA6ICcnO1xuICAgIGZvciAobGV0IGlkIGluIGluc3RhbmNlcykge1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSBpbnN0YW5jZXNbaWRdO1xuICAgICAgICBsZXQgZGVmID0gZGVmc1tpbnN0YW5jZS5kZWZJZF07XG4gICAgICAgIGlmIChpbnN0YW5jZS5pbnN0YW5jZUlkICE9PSBleGNsdWRlSW5zdGFuY2VJZCkge1xuICAgICAgICAgICAgZXZlbnRBcGlzLnB1c2gobmV3IEV2ZW50SW1wbChjb250ZXh0LCBkZWYsIGluc3RhbmNlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50QXBpcztcbn1cblxuLypcblNwZWNpZnlpbmcgbmV4dERheVRocmVzaG9sZCBzaWduYWxzIHRoYXQgYWxsLWRheSByYW5nZXMgc2hvdWxkIGJlIHNsaWNlZC5cbiovXG5mdW5jdGlvbiBzbGljZUV2ZW50U3RvcmUoZXZlbnRTdG9yZSwgZXZlbnRVaUJhc2VzLCBmcmFtaW5nUmFuZ2UsIG5leHREYXlUaHJlc2hvbGQpIHtcbiAgICBsZXQgaW52ZXJzZUJnQnlHcm91cElkID0ge307XG4gICAgbGV0IGludmVyc2VCZ0J5RGVmSWQgPSB7fTtcbiAgICBsZXQgZGVmQnlHcm91cElkID0ge307XG4gICAgbGV0IGJnUmFuZ2VzID0gW107XG4gICAgbGV0IGZnUmFuZ2VzID0gW107XG4gICAgbGV0IGV2ZW50VWlzID0gY29tcGlsZUV2ZW50VWlzKGV2ZW50U3RvcmUuZGVmcywgZXZlbnRVaUJhc2VzKTtcbiAgICBmb3IgKGxldCBkZWZJZCBpbiBldmVudFN0b3JlLmRlZnMpIHtcbiAgICAgICAgbGV0IGRlZiA9IGV2ZW50U3RvcmUuZGVmc1tkZWZJZF07XG4gICAgICAgIGxldCB1aSA9IGV2ZW50VWlzW2RlZi5kZWZJZF07XG4gICAgICAgIGlmICh1aS5kaXNwbGF5ID09PSAnaW52ZXJzZS1iYWNrZ3JvdW5kJykge1xuICAgICAgICAgICAgaWYgKGRlZi5ncm91cElkKSB7XG4gICAgICAgICAgICAgICAgaW52ZXJzZUJnQnlHcm91cElkW2RlZi5ncm91cElkXSA9IFtdO1xuICAgICAgICAgICAgICAgIGlmICghZGVmQnlHcm91cElkW2RlZi5ncm91cElkXSkge1xuICAgICAgICAgICAgICAgICAgICBkZWZCeUdyb3VwSWRbZGVmLmdyb3VwSWRdID0gZGVmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGludmVyc2VCZ0J5RGVmSWRbZGVmSWRdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaW5zdGFuY2VJZCBpbiBldmVudFN0b3JlLmluc3RhbmNlcykge1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSBldmVudFN0b3JlLmluc3RhbmNlc1tpbnN0YW5jZUlkXTtcbiAgICAgICAgbGV0IGRlZiA9IGV2ZW50U3RvcmUuZGVmc1tpbnN0YW5jZS5kZWZJZF07XG4gICAgICAgIGxldCB1aSA9IGV2ZW50VWlzW2RlZi5kZWZJZF07XG4gICAgICAgIGxldCBvcmlnUmFuZ2UgPSBpbnN0YW5jZS5yYW5nZTtcbiAgICAgICAgbGV0IG5vcm1hbFJhbmdlID0gKCFkZWYuYWxsRGF5ICYmIG5leHREYXlUaHJlc2hvbGQpID9cbiAgICAgICAgICAgIGNvbXB1dGVWaXNpYmxlRGF5UmFuZ2Uob3JpZ1JhbmdlLCBuZXh0RGF5VGhyZXNob2xkKSA6XG4gICAgICAgICAgICBvcmlnUmFuZ2U7XG4gICAgICAgIGxldCBzbGljZWRSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhub3JtYWxSYW5nZSwgZnJhbWluZ1JhbmdlKTtcbiAgICAgICAgaWYgKHNsaWNlZFJhbmdlKSB7XG4gICAgICAgICAgICBpZiAodWkuZGlzcGxheSA9PT0gJ2ludmVyc2UtYmFja2dyb3VuZCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVmLmdyb3VwSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW52ZXJzZUJnQnlHcm91cElkW2RlZi5ncm91cElkXS5wdXNoKHNsaWNlZFJhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGludmVyc2VCZ0J5RGVmSWRbaW5zdGFuY2UuZGVmSWRdLnB1c2goc2xpY2VkUmFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHVpLmRpc3BsYXkgIT09ICdub25lJykge1xuICAgICAgICAgICAgICAgICh1aS5kaXNwbGF5ID09PSAnYmFja2dyb3VuZCcgPyBiZ1JhbmdlcyA6IGZnUmFuZ2VzKS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgZGVmLFxuICAgICAgICAgICAgICAgICAgICB1aSxcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBzbGljZWRSYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgaXNTdGFydDogbm9ybWFsUmFuZ2Uuc3RhcnQgJiYgbm9ybWFsUmFuZ2Uuc3RhcnQudmFsdWVPZigpID09PSBzbGljZWRSYW5nZS5zdGFydC52YWx1ZU9mKCksXG4gICAgICAgICAgICAgICAgICAgIGlzRW5kOiBub3JtYWxSYW5nZS5lbmQgJiYgbm9ybWFsUmFuZ2UuZW5kLnZhbHVlT2YoKSA9PT0gc2xpY2VkUmFuZ2UuZW5kLnZhbHVlT2YoKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBncm91cElkIGluIGludmVyc2VCZ0J5R3JvdXBJZCkgeyAvLyBCWSBHUk9VUFxuICAgICAgICBsZXQgcmFuZ2VzID0gaW52ZXJzZUJnQnlHcm91cElkW2dyb3VwSWRdO1xuICAgICAgICBsZXQgaW52ZXJ0ZWRSYW5nZXMgPSBpbnZlcnRSYW5nZXMocmFuZ2VzLCBmcmFtaW5nUmFuZ2UpO1xuICAgICAgICBmb3IgKGxldCBpbnZlcnRlZFJhbmdlIG9mIGludmVydGVkUmFuZ2VzKSB7XG4gICAgICAgICAgICBsZXQgZGVmID0gZGVmQnlHcm91cElkW2dyb3VwSWRdO1xuICAgICAgICAgICAgbGV0IHVpID0gZXZlbnRVaXNbZGVmLmRlZklkXTtcbiAgICAgICAgICAgIGJnUmFuZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgIGRlZixcbiAgICAgICAgICAgICAgICB1aSxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTogbnVsbCxcbiAgICAgICAgICAgICAgICByYW5nZTogaW52ZXJ0ZWRSYW5nZSxcbiAgICAgICAgICAgICAgICBpc1N0YXJ0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc0VuZDogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBkZWZJZCBpbiBpbnZlcnNlQmdCeURlZklkKSB7XG4gICAgICAgIGxldCByYW5nZXMgPSBpbnZlcnNlQmdCeURlZklkW2RlZklkXTtcbiAgICAgICAgbGV0IGludmVydGVkUmFuZ2VzID0gaW52ZXJ0UmFuZ2VzKHJhbmdlcywgZnJhbWluZ1JhbmdlKTtcbiAgICAgICAgZm9yIChsZXQgaW52ZXJ0ZWRSYW5nZSBvZiBpbnZlcnRlZFJhbmdlcykge1xuICAgICAgICAgICAgYmdSYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgZGVmOiBldmVudFN0b3JlLmRlZnNbZGVmSWRdLFxuICAgICAgICAgICAgICAgIHVpOiBldmVudFVpc1tkZWZJZF0sXG4gICAgICAgICAgICAgICAgaW5zdGFuY2U6IG51bGwsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IGludmVydGVkUmFuZ2UsXG4gICAgICAgICAgICAgICAgaXNTdGFydDogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNFbmQ6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgYmc6IGJnUmFuZ2VzLCBmZzogZmdSYW5nZXMgfTtcbn1cbmZ1bmN0aW9uIGhhc0JnUmVuZGVyaW5nKGRlZikge1xuICAgIHJldHVybiBkZWYudWkuZGlzcGxheSA9PT0gJ2JhY2tncm91bmQnIHx8IGRlZi51aS5kaXNwbGF5ID09PSAnaW52ZXJzZS1iYWNrZ3JvdW5kJztcbn1cbmZ1bmN0aW9uIHNldEVsU2VnKGVsLCBzZWcpIHtcbiAgICBlbC5mY1NlZyA9IHNlZztcbn1cbmZ1bmN0aW9uIGdldEVsU2VnKGVsKSB7XG4gICAgcmV0dXJuIGVsLmZjU2VnIHx8XG4gICAgICAgIGVsLnBhcmVudE5vZGUuZmNTZWcgfHwgLy8gZm9yIHRoZSBoYXJuZXNzXG4gICAgICAgIG51bGw7XG59XG4vLyBldmVudCB1aSBjb21wdXRhdGlvblxuZnVuY3Rpb24gY29tcGlsZUV2ZW50VWlzKGV2ZW50RGVmcywgZXZlbnRVaUJhc2VzKSB7XG4gICAgcmV0dXJuIG1hcEhhc2goZXZlbnREZWZzLCAoZXZlbnREZWYpID0+IGNvbXBpbGVFdmVudFVpKGV2ZW50RGVmLCBldmVudFVpQmFzZXMpKTtcbn1cbmZ1bmN0aW9uIGNvbXBpbGVFdmVudFVpKGV2ZW50RGVmLCBldmVudFVpQmFzZXMpIHtcbiAgICBsZXQgdWlzID0gW107XG4gICAgaWYgKGV2ZW50VWlCYXNlc1snJ10pIHtcbiAgICAgICAgdWlzLnB1c2goZXZlbnRVaUJhc2VzWycnXSk7XG4gICAgfVxuICAgIGlmIChldmVudFVpQmFzZXNbZXZlbnREZWYuZGVmSWRdKSB7XG4gICAgICAgIHVpcy5wdXNoKGV2ZW50VWlCYXNlc1tldmVudERlZi5kZWZJZF0pO1xuICAgIH1cbiAgICB1aXMucHVzaChldmVudERlZi51aSk7XG4gICAgcmV0dXJuIGNvbWJpbmVFdmVudFVpcyh1aXMpO1xufVxuZnVuY3Rpb24gc29ydEV2ZW50U2VncyhzZWdzLCBldmVudE9yZGVyU3BlY3MpIHtcbiAgICBsZXQgb2JqcyA9IHNlZ3MubWFwKGJ1aWxkU2VnQ29tcGFyZU9iaik7XG4gICAgb2Jqcy5zb3J0KChvYmowLCBvYmoxKSA9PiBjb21wYXJlQnlGaWVsZFNwZWNzKG9iajAsIG9iajEsIGV2ZW50T3JkZXJTcGVjcykpO1xuICAgIHJldHVybiBvYmpzLm1hcCgoYykgPT4gYy5fc2VnKTtcbn1cbi8vIHJldHVybnMgYSBvYmplY3Qgd2l0aCBhbGwgcHJpbWl0aXZlIHByb3BzIHRoYXQgY2FuIGJlIGNvbXBhcmVkXG5mdW5jdGlvbiBidWlsZFNlZ0NvbXBhcmVPYmooc2VnKSB7XG4gICAgbGV0IHsgZXZlbnRSYW5nZSB9ID0gc2VnO1xuICAgIGxldCBldmVudERlZiA9IGV2ZW50UmFuZ2UuZGVmO1xuICAgIGxldCByYW5nZSA9IGV2ZW50UmFuZ2UuaW5zdGFuY2UgPyBldmVudFJhbmdlLmluc3RhbmNlLnJhbmdlIDogZXZlbnRSYW5nZS5yYW5nZTtcbiAgICBsZXQgc3RhcnQgPSByYW5nZS5zdGFydCA/IHJhbmdlLnN0YXJ0LnZhbHVlT2YoKSA6IDA7IC8vIFRPRE86IGJldHRlciBzdXBwb3J0IGZvciBvcGVuLXJhbmdlIGV2ZW50c1xuICAgIGxldCBlbmQgPSByYW5nZS5lbmQgPyByYW5nZS5lbmQudmFsdWVPZigpIDogMDsgLy8gXCJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV2ZW50RGVmLmV4dGVuZGVkUHJvcHMpLCBldmVudERlZiksIHsgaWQ6IGV2ZW50RGVmLnB1YmxpY0lkLCBzdGFydCxcbiAgICAgICAgZW5kLCBkdXJhdGlvbjogZW5kIC0gc3RhcnQsIGFsbERheTogTnVtYmVyKGV2ZW50RGVmLmFsbERheSksIF9zZWc6IHNlZyB9KTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVTZWdEcmFnZ2FibGUoc2VnLCBjb250ZXh0KSB7XG4gICAgbGV0IHsgcGx1Z2luSG9va3MgfSA9IGNvbnRleHQ7XG4gICAgbGV0IHRyYW5zZm9ybWVycyA9IHBsdWdpbkhvb2tzLmlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzO1xuICAgIGxldCB7IGRlZiwgdWkgfSA9IHNlZy5ldmVudFJhbmdlO1xuICAgIGxldCB2YWwgPSB1aS5zdGFydEVkaXRhYmxlO1xuICAgIGZvciAobGV0IHRyYW5zZm9ybWVyIG9mIHRyYW5zZm9ybWVycykge1xuICAgICAgICB2YWwgPSB0cmFuc2Zvcm1lcih2YWwsIGRlZiwgdWksIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xufVxuZnVuY3Rpb24gY29tcHV0ZVNlZ1N0YXJ0UmVzaXphYmxlKHNlZywgY29udGV4dCkge1xuICAgIHJldHVybiBzZWcuaXNTdGFydCAmJiBzZWcuZXZlbnRSYW5nZS51aS5kdXJhdGlvbkVkaXRhYmxlICYmIGNvbnRleHQub3B0aW9ucy5ldmVudFJlc2l6YWJsZUZyb21TdGFydDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVTZWdFbmRSZXNpemFibGUoc2VnLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHNlZy5pc0VuZCAmJiBzZWcuZXZlbnRSYW5nZS51aS5kdXJhdGlvbkVkaXRhYmxlO1xufVxuZnVuY3Rpb24gYnVpbGRTZWdUaW1lVGV4dChzZWcsIHRpbWVGb3JtYXQsIGNvbnRleHQsIGRlZmF1bHREaXNwbGF5RXZlbnRUaW1lLCAvLyBkZWZhdWx0cyB0byB0cnVlXG5kZWZhdWx0RGlzcGxheUV2ZW50RW5kLCAvLyBkZWZhdWx0cyB0byB0cnVlXG5zdGFydE92ZXJyaWRlLCBlbmRPdmVycmlkZSkge1xuICAgIGxldCB7IGRhdGVFbnYsIG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgbGV0IHsgZGlzcGxheUV2ZW50VGltZSwgZGlzcGxheUV2ZW50RW5kIH0gPSBvcHRpb25zO1xuICAgIGxldCBldmVudERlZiA9IHNlZy5ldmVudFJhbmdlLmRlZjtcbiAgICBsZXQgZXZlbnRJbnN0YW5jZSA9IHNlZy5ldmVudFJhbmdlLmluc3RhbmNlO1xuICAgIGlmIChkaXNwbGF5RXZlbnRUaW1lID09IG51bGwpIHtcbiAgICAgICAgZGlzcGxheUV2ZW50VGltZSA9IGRlZmF1bHREaXNwbGF5RXZlbnRUaW1lICE9PSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRpc3BsYXlFdmVudEVuZCA9PSBudWxsKSB7XG4gICAgICAgIGRpc3BsYXlFdmVudEVuZCA9IGRlZmF1bHREaXNwbGF5RXZlbnRFbmQgIT09IGZhbHNlO1xuICAgIH1cbiAgICBsZXQgd2hvbGVFdmVudFN0YXJ0ID0gZXZlbnRJbnN0YW5jZS5yYW5nZS5zdGFydDtcbiAgICBsZXQgd2hvbGVFdmVudEVuZCA9IGV2ZW50SW5zdGFuY2UucmFuZ2UuZW5kO1xuICAgIGxldCBzZWdTdGFydCA9IHN0YXJ0T3ZlcnJpZGUgfHwgc2VnLnN0YXJ0IHx8IHNlZy5ldmVudFJhbmdlLnJhbmdlLnN0YXJ0O1xuICAgIGxldCBzZWdFbmQgPSBlbmRPdmVycmlkZSB8fCBzZWcuZW5kIHx8IHNlZy5ldmVudFJhbmdlLnJhbmdlLmVuZDtcbiAgICBsZXQgaXNTdGFydERheSA9IHN0YXJ0T2ZEYXkod2hvbGVFdmVudFN0YXJ0KS52YWx1ZU9mKCkgPT09IHN0YXJ0T2ZEYXkoc2VnU3RhcnQpLnZhbHVlT2YoKTtcbiAgICBsZXQgaXNFbmREYXkgPSBzdGFydE9mRGF5KGFkZE1zKHdob2xlRXZlbnRFbmQsIC0xKSkudmFsdWVPZigpID09PSBzdGFydE9mRGF5KGFkZE1zKHNlZ0VuZCwgLTEpKS52YWx1ZU9mKCk7XG4gICAgaWYgKGRpc3BsYXlFdmVudFRpbWUgJiYgIWV2ZW50RGVmLmFsbERheSAmJiAoaXNTdGFydERheSB8fCBpc0VuZERheSkpIHtcbiAgICAgICAgc2VnU3RhcnQgPSBpc1N0YXJ0RGF5ID8gd2hvbGVFdmVudFN0YXJ0IDogc2VnU3RhcnQ7XG4gICAgICAgIHNlZ0VuZCA9IGlzRW5kRGF5ID8gd2hvbGVFdmVudEVuZCA6IHNlZ0VuZDtcbiAgICAgICAgaWYgKGRpc3BsYXlFdmVudEVuZCAmJiBldmVudERlZi5oYXNFbmQpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdFJhbmdlKHNlZ1N0YXJ0LCBzZWdFbmQsIHRpbWVGb3JtYXQsIHtcbiAgICAgICAgICAgICAgICBmb3JjZWRTdGFydFR6bzogc3RhcnRPdmVycmlkZSA/IG51bGwgOiBldmVudEluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLFxuICAgICAgICAgICAgICAgIGZvcmNlZEVuZFR6bzogZW5kT3ZlcnJpZGUgPyBudWxsIDogZXZlbnRJbnN0YW5jZS5mb3JjZWRFbmRUem8sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXQoc2VnU3RhcnQsIHRpbWVGb3JtYXQsIHtcbiAgICAgICAgICAgIGZvcmNlZFR6bzogc3RhcnRPdmVycmlkZSA/IG51bGwgOiBldmVudEluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLCAvLyBub29vb28sIHNhbWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAnJztcbn1cbmZ1bmN0aW9uIGdldFNlZ01ldGEoc2VnLCB0b2RheVJhbmdlLCBub3dEYXRlKSB7XG4gICAgbGV0IHNlZ1JhbmdlID0gc2VnLmV2ZW50UmFuZ2UucmFuZ2U7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaXNQYXN0OiBzZWdSYW5nZS5lbmQgPD0gKG5vd0RhdGUgfHwgdG9kYXlSYW5nZS5zdGFydCksXG4gICAgICAgIGlzRnV0dXJlOiBzZWdSYW5nZS5zdGFydCA+PSAobm93RGF0ZSB8fCB0b2RheVJhbmdlLmVuZCksXG4gICAgICAgIGlzVG9kYXk6IHRvZGF5UmFuZ2UgJiYgcmFuZ2VDb250YWluc01hcmtlcih0b2RheVJhbmdlLCBzZWdSYW5nZS5zdGFydCksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldEV2ZW50Q2xhc3NOYW1lcyhwcm9wcykge1xuICAgIGxldCBjbGFzc05hbWVzID0gWydmYy1ldmVudCddO1xuICAgIGlmIChwcm9wcy5pc01pcnJvcikge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LW1pcnJvcicpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNEcmFnZ2FibGUpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1kcmFnZ2FibGUnKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmlzU3RhcnRSZXNpemFibGUgfHwgcHJvcHMuaXNFbmRSZXNpemFibGUpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1yZXNpemFibGUnKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmlzRHJhZ2dpbmcpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1kcmFnZ2luZycpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNSZXNpemluZykge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LXJlc2l6aW5nJyk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pc1NlbGVjdGVkKSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtc2VsZWN0ZWQnKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmlzU3RhcnQpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1zdGFydCcpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNFbmQpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1lbmQnKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmlzUGFzdCkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LXBhc3QnKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmlzVG9kYXkpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC10b2RheScpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNGdXR1cmUpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1mdXR1cmUnKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzTmFtZXM7XG59XG5mdW5jdGlvbiBidWlsZEV2ZW50UmFuZ2VLZXkoZXZlbnRSYW5nZSkge1xuICAgIHJldHVybiBldmVudFJhbmdlLmluc3RhbmNlXG4gICAgICAgID8gZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkXG4gICAgICAgIDogYCR7ZXZlbnRSYW5nZS5kZWYuZGVmSWR9OiR7ZXZlbnRSYW5nZS5yYW5nZS5zdGFydC50b0lTT1N0cmluZygpfWA7XG4gICAgLy8gaW52ZXJzZS1iYWNrZ3JvdW5kIGV2ZW50cyBkb24ndCBoYXZlIHNwZWNpZmljIGluc3RhbmNlcy4gVE9ETzogYmV0dGVyIHNvbHV0aW9uXG59XG5mdW5jdGlvbiBnZXRTZWdBbmNob3JBdHRycyhzZWcsIGNvbnRleHQpIHtcbiAgICBsZXQgeyBkZWYsIGluc3RhbmNlIH0gPSBzZWcuZXZlbnRSYW5nZTtcbiAgICBsZXQgeyB1cmwgfSA9IGRlZjtcbiAgICBpZiAodXJsKSB7XG4gICAgICAgIHJldHVybiB7IGhyZWY6IHVybCB9O1xuICAgIH1cbiAgICBsZXQgeyBlbWl0dGVyLCBvcHRpb25zIH0gPSBjb250ZXh0O1xuICAgIGxldCB7IGV2ZW50SW50ZXJhY3RpdmUgfSA9IG9wdGlvbnM7XG4gICAgaWYgKGV2ZW50SW50ZXJhY3RpdmUgPT0gbnVsbCkge1xuICAgICAgICBldmVudEludGVyYWN0aXZlID0gZGVmLmludGVyYWN0aXZlO1xuICAgICAgICBpZiAoZXZlbnRJbnRlcmFjdGl2ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBldmVudEludGVyYWN0aXZlID0gQm9vbGVhbihlbWl0dGVyLmhhc0hhbmRsZXJzKCdldmVudENsaWNrJykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIG1vY2sgd2hhdCBoYXBwZW5zIGluIEV2ZW50Q2xpY2tpbmdcbiAgICBpZiAoZXZlbnRJbnRlcmFjdGl2ZSkge1xuICAgICAgICAvLyBvbmx5IGF0dGFjaCBrZXlib2FyZC1yZWxhdGVkIGhhbmRsZXJzIGJlY2F1c2UgY2xpY2sgaGFuZGxlciBpcyBhbHJlYWR5IGRvbmUgaW4gRXZlbnRDbGlja2luZ1xuICAgICAgICByZXR1cm4gY3JlYXRlQXJpYUtleWJvYXJkQXR0cnMoKGV2KSA9PiB7XG4gICAgICAgICAgICBlbWl0dGVyLnRyaWdnZXIoJ2V2ZW50Q2xpY2snLCB7XG4gICAgICAgICAgICAgICAgZWw6IGV2LnRhcmdldCxcbiAgICAgICAgICAgICAgICBldmVudDogbmV3IEV2ZW50SW1wbChjb250ZXh0LCBkZWYsIGluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICBqc0V2ZW50OiBldixcbiAgICAgICAgICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7fTtcbn1cblxuY29uc3QgU1RBTkRBUkRfUFJPUFMgPSB7XG4gICAgc3RhcnQ6IGlkZW50aXR5LFxuICAgIGVuZDogaWRlbnRpdHksXG4gICAgYWxsRGF5OiBCb29sZWFuLFxufTtcbmZ1bmN0aW9uIHBhcnNlRGF0ZVNwYW4ocmF3LCBkYXRlRW52LCBkZWZhdWx0RHVyYXRpb24pIHtcbiAgICBsZXQgc3BhbiA9IHBhcnNlT3BlbkRhdGVTcGFuKHJhdywgZGF0ZUVudik7XG4gICAgbGV0IHsgcmFuZ2UgfSA9IHNwYW47XG4gICAgaWYgKCFyYW5nZS5zdGFydCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFyYW5nZS5lbmQpIHtcbiAgICAgICAgaWYgKGRlZmF1bHREdXJhdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByYW5nZS5lbmQgPSBkYXRlRW52LmFkZChyYW5nZS5zdGFydCwgZGVmYXVsdER1cmF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHNwYW47XG59XG4vKlxuVE9ETzogc29tZWhvdyBjb21iaW5lIHdpdGggcGFyc2VSYW5nZT9cbldpbGwgcmV0dXJuIG51bGwgaWYgdGhlIHN0YXJ0L2VuZCBwcm9wcyB3ZXJlIHByZXNlbnQgYnV0IHBhcnNlZCBpbnZhbGlkbHkuXG4qL1xuZnVuY3Rpb24gcGFyc2VPcGVuRGF0ZVNwYW4ocmF3LCBkYXRlRW52KSB7XG4gICAgbGV0IHsgcmVmaW5lZDogc3RhbmRhcmRQcm9wcywgZXh0cmEgfSA9IHJlZmluZVByb3BzKHJhdywgU1RBTkRBUkRfUFJPUFMpO1xuICAgIGxldCBzdGFydE1ldGEgPSBzdGFuZGFyZFByb3BzLnN0YXJ0ID8gZGF0ZUVudi5jcmVhdGVNYXJrZXJNZXRhKHN0YW5kYXJkUHJvcHMuc3RhcnQpIDogbnVsbDtcbiAgICBsZXQgZW5kTWV0YSA9IHN0YW5kYXJkUHJvcHMuZW5kID8gZGF0ZUVudi5jcmVhdGVNYXJrZXJNZXRhKHN0YW5kYXJkUHJvcHMuZW5kKSA6IG51bGw7XG4gICAgbGV0IHsgYWxsRGF5IH0gPSBzdGFuZGFyZFByb3BzO1xuICAgIGlmIChhbGxEYXkgPT0gbnVsbCkge1xuICAgICAgICBhbGxEYXkgPSAoc3RhcnRNZXRhICYmIHN0YXJ0TWV0YS5pc1RpbWVVbnNwZWNpZmllZCkgJiZcbiAgICAgICAgICAgICghZW5kTWV0YSB8fCBlbmRNZXRhLmlzVGltZVVuc3BlY2lmaWVkKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyByYW5nZToge1xuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0TWV0YSA/IHN0YXJ0TWV0YS5tYXJrZXIgOiBudWxsLFxuICAgICAgICAgICAgZW5kOiBlbmRNZXRhID8gZW5kTWV0YS5tYXJrZXIgOiBudWxsLFxuICAgICAgICB9LCBhbGxEYXkgfSwgZXh0cmEpO1xufVxuZnVuY3Rpb24gaXNEYXRlU3BhbnNFcXVhbChzcGFuMCwgc3BhbjEpIHtcbiAgICByZXR1cm4gcmFuZ2VzRXF1YWwoc3BhbjAucmFuZ2UsIHNwYW4xLnJhbmdlKSAmJlxuICAgICAgICBzcGFuMC5hbGxEYXkgPT09IHNwYW4xLmFsbERheSAmJlxuICAgICAgICBpc1NwYW5Qcm9wc0VxdWFsKHNwYW4wLCBzcGFuMSk7XG59XG4vLyB0aGUgTk9OLURBVEUtUkVMQVRFRCBwcm9wc1xuZnVuY3Rpb24gaXNTcGFuUHJvcHNFcXVhbChzcGFuMCwgc3BhbjEpIHtcbiAgICBmb3IgKGxldCBwcm9wTmFtZSBpbiBzcGFuMSkge1xuICAgICAgICBpZiAocHJvcE5hbWUgIT09ICdyYW5nZScgJiYgcHJvcE5hbWUgIT09ICdhbGxEYXknKSB7XG4gICAgICAgICAgICBpZiAoc3BhbjBbcHJvcE5hbWVdICE9PSBzcGFuMVtwcm9wTmFtZV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYXJlIHRoZXJlIGFueSBwcm9wcyB0aGF0IHNwYW4wIGhhcyB0aGF0IHNwYW4xIERPRVNOJ1QgaGF2ZT9cbiAgICAvLyBib3RoIGhhdmUgcmFuZ2UvYWxsRGF5LCBzbyBubyBuZWVkIHRvIHNwZWNpYWwtY2FzZS5cbiAgICBmb3IgKGxldCBwcm9wTmFtZSBpbiBzcGFuMCkge1xuICAgICAgICBpZiAoIShwcm9wTmFtZSBpbiBzcGFuMSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRGF0ZVNwYW5BcGkoc3BhbiwgZGF0ZUVudikge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJ1aWxkUmFuZ2VBcGkoc3Bhbi5yYW5nZSwgZGF0ZUVudiwgc3Bhbi5hbGxEYXkpKSwgeyBhbGxEYXk6IHNwYW4uYWxsRGF5IH0pO1xufVxuZnVuY3Rpb24gYnVpbGRSYW5nZUFwaVdpdGhUaW1lWm9uZShyYW5nZSwgZGF0ZUVudiwgb21pdFRpbWUpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBidWlsZFJhbmdlQXBpKHJhbmdlLCBkYXRlRW52LCBvbWl0VGltZSkpLCB7IHRpbWVab25lOiBkYXRlRW52LnRpbWVab25lIH0pO1xufVxuZnVuY3Rpb24gYnVpbGRSYW5nZUFwaShyYW5nZSwgZGF0ZUVudiwgb21pdFRpbWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogZGF0ZUVudi50b0RhdGUocmFuZ2Uuc3RhcnQpLFxuICAgICAgICBlbmQ6IGRhdGVFbnYudG9EYXRlKHJhbmdlLmVuZCksXG4gICAgICAgIHN0YXJ0U3RyOiBkYXRlRW52LmZvcm1hdElzbyhyYW5nZS5zdGFydCwgeyBvbWl0VGltZSB9KSxcbiAgICAgICAgZW5kU3RyOiBkYXRlRW52LmZvcm1hdElzbyhyYW5nZS5lbmQsIHsgb21pdFRpbWUgfSksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZhYnJpY2F0ZUV2ZW50UmFuZ2UoZGF0ZVNwYW4sIGV2ZW50VWlCYXNlcywgY29udGV4dCkge1xuICAgIGxldCByZXMgPSByZWZpbmVFdmVudERlZih7IGVkaXRhYmxlOiBmYWxzZSB9LCBjb250ZXh0KTtcbiAgICBsZXQgZGVmID0gcGFyc2VFdmVudERlZihyZXMucmVmaW5lZCwgcmVzLmV4dHJhLCAnJywgLy8gc291cmNlSWRcbiAgICBkYXRlU3Bhbi5hbGxEYXksIHRydWUsIC8vIGhhc0VuZFxuICAgIGNvbnRleHQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlZixcbiAgICAgICAgdWk6IGNvbXBpbGVFdmVudFVpKGRlZiwgZXZlbnRVaUJhc2VzKSxcbiAgICAgICAgaW5zdGFuY2U6IGNyZWF0ZUV2ZW50SW5zdGFuY2UoZGVmLmRlZklkLCBkYXRlU3Bhbi5yYW5nZSksXG4gICAgICAgIHJhbmdlOiBkYXRlU3Bhbi5yYW5nZSxcbiAgICAgICAgaXNTdGFydDogdHJ1ZSxcbiAgICAgICAgaXNFbmQ6IHRydWUsXG4gICAgfTtcbn1cblxuLypcbmdpdmVuIGEgZnVuY3Rpb24gdGhhdCByZXNvbHZlcyBhIHJlc3VsdCBhc3luY2hyb25vdXNseS5cbnRoZSBmdW5jdGlvbiBjYW4gZWl0aGVyIGNhbGwgcGFzc2VkLWluIHN1Y2Nlc3MgYW5kIGZhaWx1cmUgY2FsbGJhY2tzLFxub3IgaXQgY2FuIHJldHVybiBhIHByb21pc2UuXG5pZiB5b3UgbmVlZCB0byBwYXNzIGFkZGl0aW9uYWwgcGFyYW1zIHRvIGZ1bmMsIGJpbmQgdGhlbSBmaXJzdC5cbiovXG5mdW5jdGlvbiB1bnByb21pc2lmeShmdW5jLCBub3JtYWxpemVkU3VjY2Vzc0NhbGxiYWNrLCBub3JtYWxpemVkRmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgLy8gZ3VhcmQgYWdhaW5zdCBzdWNjZXNzL2ZhaWx1cmUgY2FsbGJhY2tzIGJlaW5nIGNhbGxlZCBtb3JlIHRoYW4gb25jZVxuICAgIC8vIGFuZCBndWFyZCBhZ2FpbnN0IGEgcHJvbWlzZSBBTkQgY2FsbGJhY2sgYmVpbmcgdXNlZCB0b2dldGhlci5cbiAgICBsZXQgaXNSZXNvbHZlZCA9IGZhbHNlO1xuICAgIGxldCB3cmFwcGVkU3VjY2VzcyA9IGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgaWYgKCFpc1Jlc29sdmVkKSB7XG4gICAgICAgICAgICBpc1Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRTdWNjZXNzQ2FsbGJhY2socmVzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgbGV0IHdyYXBwZWRGYWlsdXJlID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGlmICghaXNSZXNvbHZlZCkge1xuICAgICAgICAgICAgaXNSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICBub3JtYWxpemVkRmFpbHVyZUNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgbGV0IHJlcyA9IGZ1bmMod3JhcHBlZFN1Y2Nlc3MsIHdyYXBwZWRGYWlsdXJlKTtcbiAgICBpZiAocmVzICYmIHR5cGVvZiByZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXMudGhlbih3cmFwcGVkU3VjY2Vzcywgd3JhcHBlZEZhaWx1cmUpO1xuICAgIH1cbn1cblxuY2xhc3MgSnNvblJlcXVlc3RFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCByZXNwb25zZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlcXVlc3RKc29uKG1ldGhvZCwgdXJsLCBwYXJhbXMpIHtcbiAgICBtZXRob2QgPSBtZXRob2QudG9VcHBlckNhc2UoKTtcbiAgICBjb25zdCBmZXRjaE9wdGlvbnMgPSB7XG4gICAgICAgIG1ldGhvZCxcbiAgICB9O1xuICAgIGlmIChtZXRob2QgPT09ICdHRVQnKSB7XG4gICAgICAgIHVybCArPSAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICtcbiAgICAgICAgICAgIG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZldGNoT3B0aW9ucy5ib2R5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbXMpO1xuICAgICAgICBmZXRjaE9wdGlvbnMuaGVhZGVycyA9IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZldGNoKHVybCwgZmV0Y2hPcHRpb25zKS50aGVuKChmZXRjaFJlcykgPT4ge1xuICAgICAgICBpZiAoZmV0Y2hSZXMub2spIHtcbiAgICAgICAgICAgIHJldHVybiBmZXRjaFJlcy5qc29uKCkudGhlbigocGFyc2VkUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3BhcnNlZFJlc3BvbnNlLCBmZXRjaFJlc107XG4gICAgICAgICAgICB9LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEpzb25SZXF1ZXN0RXJyb3IoJ0ZhaWx1cmUgcGFyc2luZyBKU09OJywgZmV0Y2hSZXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSnNvblJlcXVlc3RFcnJvcignUmVxdWVzdCBmYWlsZWQnLCBmZXRjaFJlcyk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxubGV0IGNhblZHcm93V2l0aGluQ2VsbDtcbmZ1bmN0aW9uIGdldENhblZHcm93V2l0aGluQ2VsbCgpIHtcbiAgICBpZiAoY2FuVkdyb3dXaXRoaW5DZWxsID09IG51bGwpIHtcbiAgICAgICAgY2FuVkdyb3dXaXRoaW5DZWxsID0gY29tcHV0ZUNhblZHcm93V2l0aGluQ2VsbCgpO1xuICAgIH1cbiAgICByZXR1cm4gY2FuVkdyb3dXaXRoaW5DZWxsO1xufVxuZnVuY3Rpb24gY29tcHV0ZUNhblZHcm93V2l0aGluQ2VsbCgpIHtcbiAgICAvLyBmb3IgU1NSLCBiZWNhdXNlIHRoaXMgZnVuY3Rpb24gaXMgY2FsbCBpbW1lZGlhdGVseSBhdCB0b3AtbGV2ZWxcbiAgICAvLyBUT0RPOiBqdXN0IG1ha2UgdGhpcyBsb2dpYyBleGVjdXRlIHRvcC1sZXZlbCwgaW1tZWRpYXRlbHksIGluc3RlYWQgb2YgZG9pbmcgbGF6aWx5XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxldCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGVsLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBlbC5zdHlsZS50b3AgPSAnMHB4JztcbiAgICBlbC5zdHlsZS5sZWZ0ID0gJzBweCc7XG4gICAgZWwuaW5uZXJIVE1MID0gJzx0YWJsZT48dHI+PHRkPjxkaXY+PC9kaXY+PC90ZD48L3RyPjwvdGFibGU+JztcbiAgICBlbC5xdWVyeVNlbGVjdG9yKCd0YWJsZScpLnN0eWxlLmhlaWdodCA9ICcxMDBweCc7XG4gICAgZWwucXVlcnlTZWxlY3RvcignZGl2Jykuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWwpO1xuICAgIGxldCBkaXYgPSBlbC5xdWVyeVNlbGVjdG9yKCdkaXYnKTtcbiAgICBsZXQgcG9zc2libGUgPSBkaXYub2Zmc2V0SGVpZ2h0ID4gMDtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsKTtcbiAgICByZXR1cm4gcG9zc2libGU7XG59XG5cbmNsYXNzIENhbGVuZGFyUm9vdCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgZm9yUHJpbnQ6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUJlZm9yZVByaW50ID0gKCkgPT4ge1xuICAgICAgICAgICAgZmx1c2hTeW5jKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgZm9yUHJpbnQ6IHRydWUgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVBZnRlclByaW50ID0gKCkgPT4ge1xuICAgICAgICAgICAgZmx1c2hTeW5jKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgZm9yUHJpbnQ6IGZhbHNlIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IHByb3BzO1xuICAgICAgICBsZXQgeyBmb3JQcmludCB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgbGV0IGlzSGVpZ2h0QXV0byA9IGZvclByaW50IHx8IG9wdGlvbnMuaGVpZ2h0ID09PSAnYXV0bycgfHwgb3B0aW9ucy5jb250ZW50SGVpZ2h0ID09PSAnYXV0byc7XG4gICAgICAgIGxldCBoZWlnaHQgPSAoIWlzSGVpZ2h0QXV0byAmJiBvcHRpb25zLmhlaWdodCAhPSBudWxsKSA/IG9wdGlvbnMuaGVpZ2h0IDogJyc7XG4gICAgICAgIGxldCBjbGFzc05hbWVzID0gW1xuICAgICAgICAgICAgJ2ZjJyxcbiAgICAgICAgICAgIGZvclByaW50ID8gJ2ZjLW1lZGlhLXByaW50JyA6ICdmYy1tZWRpYS1zY3JlZW4nLFxuICAgICAgICAgICAgYGZjLWRpcmVjdGlvbi0ke29wdGlvbnMuZGlyZWN0aW9ufWAsXG4gICAgICAgICAgICBwcm9wcy50aGVtZS5nZXRDbGFzcygncm9vdCcpLFxuICAgICAgICBdO1xuICAgICAgICBpZiAoIWdldENhblZHcm93V2l0aGluQ2VsbCgpKSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWxpcXVpZC1oYWNrJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3BzLmNoaWxkcmVuKGNsYXNzTmFtZXMsIGhlaWdodCwgaXNIZWlnaHRBdXRvLCBmb3JQcmludCk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBsZXQgeyBlbWl0dGVyIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBlbWl0dGVyLm9uKCdfYmVmb3JlcHJpbnQnLCB0aGlzLmhhbmRsZUJlZm9yZVByaW50KTtcbiAgICAgICAgZW1pdHRlci5vbignX2FmdGVycHJpbnQnLCB0aGlzLmhhbmRsZUFmdGVyUHJpbnQpO1xuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgbGV0IHsgZW1pdHRlciB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgZW1pdHRlci5vZmYoJ19iZWZvcmVwcmludCcsIHRoaXMuaGFuZGxlQmVmb3JlUHJpbnQpO1xuICAgICAgICBlbWl0dGVyLm9mZignX2FmdGVycHJpbnQnLCB0aGlzLmhhbmRsZUFmdGVyUHJpbnQpO1xuICAgIH1cbn1cblxuY2xhc3MgSW50ZXJhY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gc2V0dGluZ3MuY29tcG9uZW50O1xuICAgICAgICB0aGlzLmlzSGl0Q29tYm9BbGxvd2VkID0gc2V0dGluZ3MuaXNIaXRDb21ib0FsbG93ZWQgfHwgbnVsbDtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZUludGVyYWN0aW9uU2V0dGluZ3MoY29tcG9uZW50LCBpbnB1dCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbXBvbmVudCxcbiAgICAgICAgZWw6IGlucHV0LmVsLFxuICAgICAgICB1c2VFdmVudENlbnRlcjogaW5wdXQudXNlRXZlbnRDZW50ZXIgIT0gbnVsbCA/IGlucHV0LnVzZUV2ZW50Q2VudGVyIDogdHJ1ZSxcbiAgICAgICAgaXNIaXRDb21ib0FsbG93ZWQ6IGlucHV0LmlzSGl0Q29tYm9BbGxvd2VkIHx8IG51bGwsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGludGVyYWN0aW9uU2V0dGluZ3NUb1N0b3JlKHNldHRpbmdzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgW3NldHRpbmdzLmNvbXBvbmVudC51aWRdOiBzZXR0aW5ncyxcbiAgICB9O1xufVxuLy8gZ2xvYmFsIHN0YXRlXG5jb25zdCBpbnRlcmFjdGlvblNldHRpbmdzU3RvcmUgPSB7fTtcblxuY2xhc3MgQ2FsZW5kYXJJbXBsIHtcbiAgICBnZXRDdXJyZW50RGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudERhdGFNYW5hZ2VyLmdldEN1cnJlbnREYXRhKCk7XG4gICAgfVxuICAgIGRpc3BhdGNoKGFjdGlvbikge1xuICAgICAgICB0aGlzLmN1cnJlbnREYXRhTWFuYWdlci5kaXNwYXRjaChhY3Rpb24pO1xuICAgIH1cbiAgICBnZXQgdmlldygpIHsgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudERhdGEoKS52aWV3QXBpOyB9XG4gICAgYmF0Y2hSZW5kZXJpbmcoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gICAgdXBkYXRlU2l6ZSgpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdfcmVzaXplJywgdHJ1ZSk7XG4gICAgfVxuICAgIC8vIE9wdGlvbnNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHNldE9wdGlvbihuYW1lLCB2YWwpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnU0VUX09QVElPTicsXG4gICAgICAgICAgICBvcHRpb25OYW1lOiBuYW1lLFxuICAgICAgICAgICAgcmF3T3B0aW9uVmFsdWU6IHZhbCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldE9wdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnREYXRhTWFuYWdlci5jdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXRbbmFtZV07XG4gICAgfVxuICAgIGdldEF2YWlsYWJsZUxvY2FsZUNvZGVzKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5nZXRDdXJyZW50RGF0YSgpLmF2YWlsYWJsZVJhd0xvY2FsZXMpO1xuICAgIH1cbiAgICAvLyBUcmlnZ2VyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBvbihoYW5kbGVyTmFtZSwgaGFuZGxlcikge1xuICAgICAgICBsZXQgeyBjdXJyZW50RGF0YU1hbmFnZXIgfSA9IHRoaXM7XG4gICAgICAgIGlmIChjdXJyZW50RGF0YU1hbmFnZXIuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZXJzW2hhbmRsZXJOYW1lXSkge1xuICAgICAgICAgICAgY3VycmVudERhdGFNYW5hZ2VyLmVtaXR0ZXIub24oaGFuZGxlck5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBVbmtub3duIGxpc3RlbmVyIG5hbWUgJyR7aGFuZGxlck5hbWV9J2ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9mZihoYW5kbGVyTmFtZSwgaGFuZGxlcikge1xuICAgICAgICB0aGlzLmN1cnJlbnREYXRhTWFuYWdlci5lbWl0dGVyLm9mZihoYW5kbGVyTmFtZSwgaGFuZGxlcik7XG4gICAgfVxuICAgIC8vIG5vdCBtZWFudCBmb3IgcHVibGljIHVzZVxuICAgIHRyaWdnZXIoaGFuZGxlck5hbWUsIC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50RGF0YU1hbmFnZXIuZW1pdHRlci50cmlnZ2VyKGhhbmRsZXJOYW1lLCAuLi5hcmdzKTtcbiAgICB9XG4gICAgLy8gVmlld1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgY2hhbmdlVmlldyh2aWV3VHlwZSwgZGF0ZU9yUmFuZ2UpIHtcbiAgICAgICAgdGhpcy5iYXRjaFJlbmRlcmluZygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgICAgICBpZiAoZGF0ZU9yUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0ZU9yUmFuZ2Uuc3RhcnQgJiYgZGF0ZU9yUmFuZ2UuZW5kKSB7IC8vIGEgcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX1ZJRVdfVFlQRScsXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1NFVF9PUFRJT04nLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uTmFtZTogJ3Zpc2libGVSYW5nZScsXG4gICAgICAgICAgICAgICAgICAgICAgICByYXdPcHRpb25WYWx1ZTogZGF0ZU9yUmFuZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfVklFV19UWVBFJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZU1hcmtlcjogZGF0ZUVudi5jcmVhdGVNYXJrZXIoZGF0ZU9yUmFuZ2UpLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0NIQU5HRV9WSUVXX1RZUEUnLFxuICAgICAgICAgICAgICAgICAgICB2aWV3VHlwZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEZvcmNlcyBuYXZpZ2F0aW9uIHRvIGEgdmlldyBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gICAgLy8gYHZpZXdUeXBlYCBjYW4gYmUgYSBzcGVjaWZpYyB2aWV3IG5hbWUgb3IgYSBnZW5lcmljIG9uZSBsaWtlIFwid2Vla1wiIG9yIFwiZGF5XCIuXG4gICAgLy8gbmVlZHMgdG8gY2hhbmdlXG4gICAgem9vbVRvKGRhdGVNYXJrZXIsIHZpZXdUeXBlKSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgbGV0IHNwZWM7XG4gICAgICAgIHZpZXdUeXBlID0gdmlld1R5cGUgfHwgJ2RheSc7IC8vIGRheSBpcyBkZWZhdWx0IHpvb21cbiAgICAgICAgc3BlYyA9IHN0YXRlLnZpZXdTcGVjc1t2aWV3VHlwZV0gfHwgdGhpcy5nZXRVbml0Vmlld1NwZWModmlld1R5cGUpO1xuICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgIGlmIChzcGVjKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX1ZJRVdfVFlQRScsXG4gICAgICAgICAgICAgICAgdmlld1R5cGU6IHNwZWMudHlwZSxcbiAgICAgICAgICAgICAgICBkYXRlTWFya2VyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX0RBVEUnLFxuICAgICAgICAgICAgICAgIGRhdGVNYXJrZXIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBHaXZlbiBhIGR1cmF0aW9uIHNpbmd1bGFyIHVuaXQsIGxpa2UgXCJ3ZWVrXCIgb3IgXCJkYXlcIiwgZmluZHMgYSBtYXRjaGluZyB2aWV3IHNwZWMuXG4gICAgLy8gUHJlZmVyZW5jZSBpcyBnaXZlbiB0byB2aWV3cyB0aGF0IGhhdmUgY29ycmVzcG9uZGluZyBidXR0b25zLlxuICAgIGdldFVuaXRWaWV3U3BlYyh1bml0KSB7XG4gICAgICAgIGxldCB7IHZpZXdTcGVjcywgdG9vbGJhckNvbmZpZyB9ID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICBsZXQgdmlld1R5cGVzID0gW10uY29uY2F0KHRvb2xiYXJDb25maWcuaGVhZGVyID8gdG9vbGJhckNvbmZpZy5oZWFkZXIudmlld3NXaXRoQnV0dG9ucyA6IFtdLCB0b29sYmFyQ29uZmlnLmZvb3RlciA/IHRvb2xiYXJDb25maWcuZm9vdGVyLnZpZXdzV2l0aEJ1dHRvbnMgOiBbXSk7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBsZXQgc3BlYztcbiAgICAgICAgZm9yIChsZXQgdmlld1R5cGUgaW4gdmlld1NwZWNzKSB7XG4gICAgICAgICAgICB2aWV3VHlwZXMucHVzaCh2aWV3VHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHZpZXdUeXBlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgc3BlYyA9IHZpZXdTcGVjc1t2aWV3VHlwZXNbaV1dO1xuICAgICAgICAgICAgaWYgKHNwZWMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3BlYy5zaW5nbGVVbml0ID09PSB1bml0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzcGVjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gQ3VycmVudCBEYXRlXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBwcmV2KCkge1xuICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnUFJFVicgfSk7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIHRoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdORVhUJyB9KTtcbiAgICB9XG4gICAgcHJldlllYXIoKSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgdGhpcy51bnNlbGVjdCgpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfREFURScsXG4gICAgICAgICAgICBkYXRlTWFya2VyOiBzdGF0ZS5kYXRlRW52LmFkZFllYXJzKHN0YXRlLmN1cnJlbnREYXRlLCAtMSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZXh0WWVhcigpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ0NIQU5HRV9EQVRFJyxcbiAgICAgICAgICAgIGRhdGVNYXJrZXI6IHN0YXRlLmRhdGVFbnYuYWRkWWVhcnMoc3RhdGUuY3VycmVudERhdGUsIDEpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdG9kYXkoKSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgdGhpcy51bnNlbGVjdCgpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfREFURScsXG4gICAgICAgICAgICBkYXRlTWFya2VyOiBnZXROb3coc3RhdGUuY2FsZW5kYXJPcHRpb25zLm5vdywgc3RhdGUuZGF0ZUVudiksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnb3RvRGF0ZSh6b25lZERhdGVJbnB1dCkge1xuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIHRoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX0RBVEUnLFxuICAgICAgICAgICAgZGF0ZU1hcmtlcjogc3RhdGUuZGF0ZUVudi5jcmVhdGVNYXJrZXIoem9uZWREYXRlSW5wdXQpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW5jcmVtZW50RGF0ZShkZWx0YUlucHV0KSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgbGV0IGRlbHRhID0gY3JlYXRlRHVyYXRpb24oZGVsdGFJbnB1dCk7XG4gICAgICAgIGlmIChkZWx0YSkgeyAvLyBlbHNlLCB3YXJuIGFib3V0IGludmFsaWQgaW5wdXQ/XG4gICAgICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX0RBVEUnLFxuICAgICAgICAgICAgICAgIGRhdGVNYXJrZXI6IHN0YXRlLmRhdGVFbnYuYWRkKHN0YXRlLmN1cnJlbnREYXRlLCBkZWx0YSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXREYXRlKCkge1xuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIHJldHVybiBzdGF0ZS5kYXRlRW52LnRvRGF0ZShzdGF0ZS5jdXJyZW50RGF0ZSk7XG4gICAgfVxuICAgIC8vIERhdGUgRm9ybWF0dGluZyBVdGlsc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZm9ybWF0RGF0ZShkLCBmb3JtYXR0ZXIpIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXQoZGF0ZUVudi5jcmVhdGVNYXJrZXIoZCksIGNyZWF0ZUZvcm1hdHRlcihmb3JtYXR0ZXIpKTtcbiAgICB9XG4gICAgLy8gYHNldHRpbmdzYCBpcyBmb3IgZm9ybWF0dGVyIEFORCBpc0VuZEV4Y2x1c2l2ZVxuICAgIGZvcm1hdFJhbmdlKGQwLCBkMSwgc2V0dGluZ3MpIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXRSYW5nZShkYXRlRW52LmNyZWF0ZU1hcmtlcihkMCksIGRhdGVFbnYuY3JlYXRlTWFya2VyKGQxKSwgY3JlYXRlRm9ybWF0dGVyKHNldHRpbmdzKSwgc2V0dGluZ3MpO1xuICAgIH1cbiAgICBmb3JtYXRJc28oZCwgb21pdFRpbWUpIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXRJc28oZGF0ZUVudi5jcmVhdGVNYXJrZXIoZCksIHsgb21pdFRpbWUgfSk7XG4gICAgfVxuICAgIC8vIERhdGUgU2VsZWN0aW9uIC8gRXZlbnQgU2VsZWN0aW9uIC8gRGF5Q2xpY2tcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHNlbGVjdChkYXRlT3JPYmosIGVuZERhdGUpIHtcbiAgICAgICAgbGV0IHNlbGVjdGlvbklucHV0O1xuICAgICAgICBpZiAoZW5kRGF0ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoZGF0ZU9yT2JqLnN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25JbnB1dCA9IGRhdGVPck9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbklucHV0ID0ge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogZGF0ZU9yT2JqLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbklucHV0ID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBkYXRlT3JPYmosXG4gICAgICAgICAgICAgICAgZW5kOiBlbmREYXRlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSBwYXJzZURhdGVTcGFuKHNlbGVjdGlvbklucHV0LCBzdGF0ZS5kYXRlRW52LCBjcmVhdGVEdXJhdGlvbih7IGRheXM6IDEgfSkpO1xuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7IC8vIHRocm93IHBhcnNlIGVycm9yIG90aGVyd2lzZT9cbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnU0VMRUNUX0RBVEVTJywgc2VsZWN0aW9uIH0pO1xuICAgICAgICAgICAgdHJpZ2dlckRhdGVTZWxlY3Qoc2VsZWN0aW9uLCBudWxsLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5zZWxlY3QocGV2KSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgaWYgKHN0YXRlLmRhdGVTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRUxFQ1RfREFURVMnIH0pO1xuICAgICAgICAgICAgdHJpZ2dlckRhdGVVbnNlbGVjdChwZXYsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBQdWJsaWMgRXZlbnRzIEFQSVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgYWRkRXZlbnQoZXZlbnRJbnB1dCwgc291cmNlSW5wdXQpIHtcbiAgICAgICAgaWYgKGV2ZW50SW5wdXQgaW5zdGFuY2VvZiBFdmVudEltcGwpIHtcbiAgICAgICAgICAgIGxldCBkZWYgPSBldmVudElucHV0Ll9kZWY7XG4gICAgICAgICAgICBsZXQgaW5zdGFuY2UgPSBldmVudElucHV0Ll9pbnN0YW5jZTtcbiAgICAgICAgICAgIGxldCBjdXJyZW50RGF0YSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgICAgIC8vIG5vdCBhbHJlYWR5IHByZXNlbnQ/IGRvbid0IHdhbnQgdG8gYWRkIGFuIG9sZCBzbmFwc2hvdFxuICAgICAgICAgICAgaWYgKCFjdXJyZW50RGF0YS5ldmVudFN0b3JlLmRlZnNbZGVmLmRlZklkXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQUREX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IGV2ZW50VHVwbGVUb1N0b3JlKHsgZGVmLCBpbnN0YW5jZSB9KSwgLy8gVE9ETzogYmV0dGVyIHV0aWwgZm9yIHR3byBhcmdzP1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50QWRkKGV2ZW50SW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50SW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICBsZXQgZXZlbnRTb3VyY2U7XG4gICAgICAgIGlmIChzb3VyY2VJbnB1dCBpbnN0YW5jZW9mIEV2ZW50U291cmNlSW1wbCkge1xuICAgICAgICAgICAgZXZlbnRTb3VyY2UgPSBzb3VyY2VJbnB1dC5pbnRlcm5hbEV2ZW50U291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzb3VyY2VJbnB1dCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlSW5wdXQpIHsgLy8gdHJ1ZS4gcGFydCBvZiB0aGUgZmlyc3QgZXZlbnQgc291cmNlXG4gICAgICAgICAgICAgICAgW2V2ZW50U291cmNlXSA9IGhhc2hWYWx1ZXNUb0FycmF5KHN0YXRlLmV2ZW50U291cmNlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc291cmNlSW5wdXQgIT0gbnVsbCkgeyAvLyBhbiBJRC4gYWNjZXB0cyBhIG51bWJlciB0b29cbiAgICAgICAgICAgIGxldCBzb3VyY2VBcGkgPSB0aGlzLmdldEV2ZW50U291cmNlQnlJZChzb3VyY2VJbnB1dCk7IC8vIFRPRE86IHVzZSBhbiBpbnRlcm5hbCBmdW5jdGlvblxuICAgICAgICAgICAgaWYgKCFzb3VyY2VBcGkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYENvdWxkIG5vdCBmaW5kIGFuIGV2ZW50IHNvdXJjZSB3aXRoIElEIFwiJHtzb3VyY2VJbnB1dH1cImApOyAvLyBUT0RPOiB0ZXN0XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldmVudFNvdXJjZSA9IHNvdXJjZUFwaS5pbnRlcm5hbEV2ZW50U291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0dXBsZSA9IHBhcnNlRXZlbnQoZXZlbnRJbnB1dCwgZXZlbnRTb3VyY2UsIHN0YXRlLCBmYWxzZSk7XG4gICAgICAgIGlmICh0dXBsZSkge1xuICAgICAgICAgICAgbGV0IG5ld0V2ZW50QXBpID0gbmV3IEV2ZW50SW1wbChzdGF0ZSwgdHVwbGUuZGVmLCB0dXBsZS5kZWYucmVjdXJyaW5nRGVmID8gbnVsbCA6IHR1cGxlLmluc3RhbmNlKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdBRERfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICBldmVudFN0b3JlOiBldmVudFR1cGxlVG9TdG9yZSh0dXBsZSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50QWRkKG5ld0V2ZW50QXBpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXdFdmVudEFwaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdHJpZ2dlckV2ZW50QWRkKGV2ZW50QXBpKSB7XG4gICAgICAgIGxldCB7IGVtaXR0ZXIgfSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgZW1pdHRlci50cmlnZ2VyKCdldmVudEFkZCcsIHtcbiAgICAgICAgICAgIGV2ZW50OiBldmVudEFwaSxcbiAgICAgICAgICAgIHJlbGF0ZWRFdmVudHM6IFtdLFxuICAgICAgICAgICAgcmV2ZXJ0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdSRU1PVkVfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogZXZlbnRBcGlUb1N0b3JlKGV2ZW50QXBpKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBUT0RPOiBvcHRpbWl6ZVxuICAgIGdldEV2ZW50QnlJZChpZCkge1xuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIGxldCB7IGRlZnMsIGluc3RhbmNlcyB9ID0gc3RhdGUuZXZlbnRTdG9yZTtcbiAgICAgICAgaWQgPSBTdHJpbmcoaWQpO1xuICAgICAgICBmb3IgKGxldCBkZWZJZCBpbiBkZWZzKSB7XG4gICAgICAgICAgICBsZXQgZGVmID0gZGVmc1tkZWZJZF07XG4gICAgICAgICAgICBpZiAoZGVmLnB1YmxpY0lkID09PSBpZCkge1xuICAgICAgICAgICAgICAgIGlmIChkZWYucmVjdXJyaW5nRGVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRJbXBsKHN0YXRlLCBkZWYsIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpbnN0YW5jZUlkIGluIGluc3RhbmNlcykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5zdGFuY2UgPSBpbnN0YW5jZXNbaW5zdGFuY2VJZF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5kZWZJZCA9PT0gZGVmLmRlZklkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50SW1wbChzdGF0ZSwgZGVmLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldEV2ZW50cygpIHtcbiAgICAgICAgbGV0IGN1cnJlbnREYXRhID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICByZXR1cm4gYnVpbGRFdmVudEFwaXMoY3VycmVudERhdGEuZXZlbnRTdG9yZSwgY3VycmVudERhdGEpO1xuICAgIH1cbiAgICByZW1vdmVBbGxFdmVudHMoKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnUkVNT1ZFX0FMTF9FVkVOVFMnIH0pO1xuICAgIH1cbiAgICAvLyBQdWJsaWMgRXZlbnQgU291cmNlcyBBUElcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGdldEV2ZW50U291cmNlcygpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICBsZXQgc291cmNlSGFzaCA9IHN0YXRlLmV2ZW50U291cmNlcztcbiAgICAgICAgbGV0IHNvdXJjZUFwaXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW50ZXJuYWxJZCBpbiBzb3VyY2VIYXNoKSB7XG4gICAgICAgICAgICBzb3VyY2VBcGlzLnB1c2gobmV3IEV2ZW50U291cmNlSW1wbChzdGF0ZSwgc291cmNlSGFzaFtpbnRlcm5hbElkXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzb3VyY2VBcGlzO1xuICAgIH1cbiAgICBnZXRFdmVudFNvdXJjZUJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICBsZXQgc291cmNlSGFzaCA9IHN0YXRlLmV2ZW50U291cmNlcztcbiAgICAgICAgaWQgPSBTdHJpbmcoaWQpO1xuICAgICAgICBmb3IgKGxldCBzb3VyY2VJZCBpbiBzb3VyY2VIYXNoKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlSGFzaFtzb3VyY2VJZF0ucHVibGljSWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudFNvdXJjZUltcGwoc3RhdGUsIHNvdXJjZUhhc2hbc291cmNlSWRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYWRkRXZlbnRTb3VyY2Uoc291cmNlSW5wdXQpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICBpZiAoc291cmNlSW5wdXQgaW5zdGFuY2VvZiBFdmVudFNvdXJjZUltcGwpIHtcbiAgICAgICAgICAgIC8vIG5vdCBhbHJlYWR5IHByZXNlbnQ/IGRvbid0IHdhbnQgdG8gYWRkIGFuIG9sZCBzbmFwc2hvdFxuICAgICAgICAgICAgaWYgKCFzdGF0ZS5ldmVudFNvdXJjZXNbc291cmNlSW5wdXQuaW50ZXJuYWxFdmVudFNvdXJjZS5zb3VyY2VJZF0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0FERF9FVkVOVF9TT1VSQ0VTJyxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlczogW3NvdXJjZUlucHV0LmludGVybmFsRXZlbnRTb3VyY2VdLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZUlucHV0O1xuICAgICAgICB9XG4gICAgICAgIGxldCBldmVudFNvdXJjZSA9IHBhcnNlRXZlbnRTb3VyY2Uoc291cmNlSW5wdXQsIHN0YXRlKTtcbiAgICAgICAgaWYgKGV2ZW50U291cmNlKSB7IC8vIFRPRE86IGVycm9yIG90aGVyd2lzZT9cbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnQUREX0VWRU5UX1NPVVJDRVMnLCBzb3VyY2VzOiBbZXZlbnRTb3VyY2VdIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudFNvdXJjZUltcGwoc3RhdGUsIGV2ZW50U291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmVtb3ZlQWxsRXZlbnRTb3VyY2VzKCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHsgdHlwZTogJ1JFTU9WRV9BTExfRVZFTlRfU09VUkNFUycgfSk7XG4gICAgfVxuICAgIHJlZmV0Y2hFdmVudHMoKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnRkVUQ0hfRVZFTlRfU09VUkNFUycsIGlzUmVmZXRjaDogdHJ1ZSB9KTtcbiAgICB9XG4gICAgLy8gU2Nyb2xsXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBzY3JvbGxUb1RpbWUodGltZUlucHV0KSB7XG4gICAgICAgIGxldCB0aW1lID0gY3JlYXRlRHVyYXRpb24odGltZUlucHV0KTtcbiAgICAgICAgaWYgKHRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignX3Njcm9sbFJlcXVlc3QnLCB7IHRpbWUgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHBvaW50SW5zaWRlUmVjdChwb2ludCwgcmVjdCkge1xuICAgIHJldHVybiBwb2ludC5sZWZ0ID49IHJlY3QubGVmdCAmJlxuICAgICAgICBwb2ludC5sZWZ0IDwgcmVjdC5yaWdodCAmJlxuICAgICAgICBwb2ludC50b3AgPj0gcmVjdC50b3AgJiZcbiAgICAgICAgcG9pbnQudG9wIDwgcmVjdC5ib3R0b207XG59XG4vLyBSZXR1cm5zIGEgbmV3IHJlY3RhbmdsZSB0aGF0IGlzIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhlIHR3byByZWN0YW5nbGVzLiBJZiB0aGV5IGRvbid0IGludGVyc2VjdCwgcmV0dXJucyBmYWxzZVxuZnVuY3Rpb24gaW50ZXJzZWN0UmVjdHMocmVjdDEsIHJlY3QyKSB7XG4gICAgbGV0IHJlcyA9IHtcbiAgICAgICAgbGVmdDogTWF0aC5tYXgocmVjdDEubGVmdCwgcmVjdDIubGVmdCksXG4gICAgICAgIHJpZ2h0OiBNYXRoLm1pbihyZWN0MS5yaWdodCwgcmVjdDIucmlnaHQpLFxuICAgICAgICB0b3A6IE1hdGgubWF4KHJlY3QxLnRvcCwgcmVjdDIudG9wKSxcbiAgICAgICAgYm90dG9tOiBNYXRoLm1pbihyZWN0MS5ib3R0b20sIHJlY3QyLmJvdHRvbSksXG4gICAgfTtcbiAgICBpZiAocmVzLmxlZnQgPCByZXMucmlnaHQgJiYgcmVzLnRvcCA8IHJlcy5ib3R0b20pIHtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gdHJhbnNsYXRlUmVjdChyZWN0LCBkZWx0YVgsIGRlbHRhWSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IHJlY3QubGVmdCArIGRlbHRhWCxcbiAgICAgICAgcmlnaHQ6IHJlY3QucmlnaHQgKyBkZWx0YVgsXG4gICAgICAgIHRvcDogcmVjdC50b3AgKyBkZWx0YVksXG4gICAgICAgIGJvdHRvbTogcmVjdC5ib3R0b20gKyBkZWx0YVksXG4gICAgfTtcbn1cbi8vIFJldHVybnMgYSBuZXcgcG9pbnQgdGhhdCB3aWxsIGhhdmUgYmVlbiBtb3ZlZCB0byByZXNpZGUgd2l0aGluIHRoZSBnaXZlbiByZWN0YW5nbGVcbmZ1bmN0aW9uIGNvbnN0cmFpblBvaW50KHBvaW50LCByZWN0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogTWF0aC5taW4oTWF0aC5tYXgocG9pbnQubGVmdCwgcmVjdC5sZWZ0KSwgcmVjdC5yaWdodCksXG4gICAgICAgIHRvcDogTWF0aC5taW4oTWF0aC5tYXgocG9pbnQudG9wLCByZWN0LnRvcCksIHJlY3QuYm90dG9tKSxcbiAgICB9O1xufVxuLy8gUmV0dXJucyBhIHBvaW50IHRoYXQgaXMgdGhlIGNlbnRlciBvZiB0aGUgZ2l2ZW4gcmVjdGFuZ2xlXG5mdW5jdGlvbiBnZXRSZWN0Q2VudGVyKHJlY3QpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyLFxuICAgICAgICB0b3A6IChyZWN0LnRvcCArIHJlY3QuYm90dG9tKSAvIDIsXG4gICAgfTtcbn1cbi8vIFN1YnRyYWN0cyBwb2ludDIncyBjb29yZGluYXRlcyBmcm9tIHBvaW50MSdzIGNvb3JkaW5hdGVzLCByZXR1cm5pbmcgYSBkZWx0YVxuZnVuY3Rpb24gZGlmZlBvaW50cyhwb2ludDEsIHBvaW50Mikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IHBvaW50MS5sZWZ0IC0gcG9pbnQyLmxlZnQsXG4gICAgICAgIHRvcDogcG9pbnQxLnRvcCAtIHBvaW50Mi50b3AsXG4gICAgfTtcbn1cblxuY29uc3QgRU1QVFlfRVZFTlRfU1RPUkUgPSBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTsgLy8gZm9yIHB1cmVjb21wb25lbnRzLiBUT0RPOiBrZWVwIGVsc2V3aGVyZVxuY2xhc3MgU3BsaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmdldEtleXNGb3JFdmVudERlZnMgPSBtZW1vaXplKHRoaXMuX2dldEtleXNGb3JFdmVudERlZnMpO1xuICAgICAgICB0aGlzLnNwbGl0RGF0ZVNlbGVjdGlvbiA9IG1lbW9pemUodGhpcy5fc3BsaXREYXRlU3Bhbik7XG4gICAgICAgIHRoaXMuc3BsaXRFdmVudFN0b3JlID0gbWVtb2l6ZSh0aGlzLl9zcGxpdEV2ZW50U3RvcmUpO1xuICAgICAgICB0aGlzLnNwbGl0SW5kaXZpZHVhbFVpID0gbWVtb2l6ZSh0aGlzLl9zcGxpdEluZGl2aWR1YWxVaSk7XG4gICAgICAgIHRoaXMuc3BsaXRFdmVudERyYWcgPSBtZW1vaXplKHRoaXMuX3NwbGl0SW50ZXJhY3Rpb24pO1xuICAgICAgICB0aGlzLnNwbGl0RXZlbnRSZXNpemUgPSBtZW1vaXplKHRoaXMuX3NwbGl0SW50ZXJhY3Rpb24pO1xuICAgICAgICB0aGlzLmV2ZW50VWlCdWlsZGVycyA9IHt9OyAvLyBUT0RPOiB0eXBlc2NyaXB0IHByb3RlY3Rpb25cbiAgICB9XG4gICAgc3BsaXRQcm9wcyhwcm9wcykge1xuICAgICAgICBsZXQga2V5SW5mb3MgPSB0aGlzLmdldEtleUluZm8ocHJvcHMpO1xuICAgICAgICBsZXQgZGVmS2V5cyA9IHRoaXMuZ2V0S2V5c0ZvckV2ZW50RGVmcyhwcm9wcy5ldmVudFN0b3JlKTtcbiAgICAgICAgbGV0IGRhdGVTZWxlY3Rpb25zID0gdGhpcy5zcGxpdERhdGVTZWxlY3Rpb24ocHJvcHMuZGF0ZVNlbGVjdGlvbik7XG4gICAgICAgIGxldCBpbmRpdmlkdWFsVWkgPSB0aGlzLnNwbGl0SW5kaXZpZHVhbFVpKHByb3BzLmV2ZW50VWlCYXNlcywgZGVmS2V5cyk7IC8vIHRoZSBpbmRpdmlkdWFsICpiYXNlcypcbiAgICAgICAgbGV0IGV2ZW50U3RvcmVzID0gdGhpcy5zcGxpdEV2ZW50U3RvcmUocHJvcHMuZXZlbnRTdG9yZSwgZGVmS2V5cyk7XG4gICAgICAgIGxldCBldmVudERyYWdzID0gdGhpcy5zcGxpdEV2ZW50RHJhZyhwcm9wcy5ldmVudERyYWcpO1xuICAgICAgICBsZXQgZXZlbnRSZXNpemVzID0gdGhpcy5zcGxpdEV2ZW50UmVzaXplKHByb3BzLmV2ZW50UmVzaXplKTtcbiAgICAgICAgbGV0IHNwbGl0UHJvcHMgPSB7fTtcbiAgICAgICAgdGhpcy5ldmVudFVpQnVpbGRlcnMgPSBtYXBIYXNoKGtleUluZm9zLCAoaW5mbywga2V5KSA9PiB0aGlzLmV2ZW50VWlCdWlsZGVyc1trZXldIHx8IG1lbW9pemUoYnVpbGRFdmVudFVpRm9yS2V5KSk7XG4gICAgICAgIGZvciAobGV0IGtleSBpbiBrZXlJbmZvcykge1xuICAgICAgICAgICAgbGV0IGtleUluZm8gPSBrZXlJbmZvc1trZXldO1xuICAgICAgICAgICAgbGV0IGV2ZW50U3RvcmUgPSBldmVudFN0b3Jlc1trZXldIHx8IEVNUFRZX0VWRU5UX1NUT1JFO1xuICAgICAgICAgICAgbGV0IGJ1aWxkRXZlbnRVaSA9IHRoaXMuZXZlbnRVaUJ1aWxkZXJzW2tleV07XG4gICAgICAgICAgICBzcGxpdFByb3BzW2tleV0gPSB7XG4gICAgICAgICAgICAgICAgYnVzaW5lc3NIb3Vyczoga2V5SW5mby5idXNpbmVzc0hvdXJzIHx8IHByb3BzLmJ1c2luZXNzSG91cnMsXG4gICAgICAgICAgICAgICAgZGF0ZVNlbGVjdGlvbjogZGF0ZVNlbGVjdGlvbnNba2V5XSB8fCBudWxsLFxuICAgICAgICAgICAgICAgIGV2ZW50U3RvcmUsXG4gICAgICAgICAgICAgICAgZXZlbnRVaUJhc2VzOiBidWlsZEV2ZW50VWkocHJvcHMuZXZlbnRVaUJhc2VzWycnXSwga2V5SW5mby51aSwgaW5kaXZpZHVhbFVpW2tleV0pLFxuICAgICAgICAgICAgICAgIGV2ZW50U2VsZWN0aW9uOiBldmVudFN0b3JlLmluc3RhbmNlc1twcm9wcy5ldmVudFNlbGVjdGlvbl0gPyBwcm9wcy5ldmVudFNlbGVjdGlvbiA6ICcnLFxuICAgICAgICAgICAgICAgIGV2ZW50RHJhZzogZXZlbnREcmFnc1trZXldIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgZXZlbnRSZXNpemU6IGV2ZW50UmVzaXplc1trZXldIHx8IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGxpdFByb3BzO1xuICAgIH1cbiAgICBfc3BsaXREYXRlU3BhbihkYXRlU3Bhbikge1xuICAgICAgICBsZXQgZGF0ZVNwYW5zID0ge307XG4gICAgICAgIGlmIChkYXRlU3Bhbikge1xuICAgICAgICAgICAgbGV0IGtleXMgPSB0aGlzLmdldEtleXNGb3JEYXRlU3BhbihkYXRlU3Bhbik7XG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgb2Yga2V5cykge1xuICAgICAgICAgICAgICAgIGRhdGVTcGFuc1trZXldID0gZGF0ZVNwYW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGVTcGFucztcbiAgICB9XG4gICAgX2dldEtleXNGb3JFdmVudERlZnMoZXZlbnRTdG9yZSkge1xuICAgICAgICByZXR1cm4gbWFwSGFzaChldmVudFN0b3JlLmRlZnMsIChldmVudERlZikgPT4gdGhpcy5nZXRLZXlzRm9yRXZlbnREZWYoZXZlbnREZWYpKTtcbiAgICB9XG4gICAgX3NwbGl0RXZlbnRTdG9yZShldmVudFN0b3JlLCBkZWZLZXlzKSB7XG4gICAgICAgIGxldCB7IGRlZnMsIGluc3RhbmNlcyB9ID0gZXZlbnRTdG9yZTtcbiAgICAgICAgbGV0IHNwbGl0U3RvcmVzID0ge307XG4gICAgICAgIGZvciAobGV0IGRlZklkIGluIGRlZnMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBvZiBkZWZLZXlzW2RlZklkXSkge1xuICAgICAgICAgICAgICAgIGlmICghc3BsaXRTdG9yZXNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBzcGxpdFN0b3Jlc1trZXldID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNwbGl0U3RvcmVzW2tleV0uZGVmc1tkZWZJZF0gPSBkZWZzW2RlZklkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpbnN0YW5jZUlkIGluIGluc3RhbmNlcykge1xuICAgICAgICAgICAgbGV0IGluc3RhbmNlID0gaW5zdGFuY2VzW2luc3RhbmNlSWRdO1xuICAgICAgICAgICAgZm9yIChsZXQga2V5IG9mIGRlZktleXNbaW5zdGFuY2UuZGVmSWRdKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNwbGl0U3RvcmVzW2tleV0pIHsgLy8gbXVzdCBoYXZlIGFscmVhZHkgYmVlbiBjcmVhdGVkXG4gICAgICAgICAgICAgICAgICAgIHNwbGl0U3RvcmVzW2tleV0uaW5zdGFuY2VzW2luc3RhbmNlSWRdID0gaW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGxpdFN0b3JlcztcbiAgICB9XG4gICAgX3NwbGl0SW5kaXZpZHVhbFVpKGV2ZW50VWlCYXNlcywgZGVmS2V5cykge1xuICAgICAgICBsZXQgc3BsaXRIYXNoZXMgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgZGVmSWQgaW4gZXZlbnRVaUJhc2VzKSB7XG4gICAgICAgICAgICBpZiAoZGVmSWQpIHsgLy8gbm90IHRoZSAnJyBrZXlcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrZXkgb2YgZGVmS2V5c1tkZWZJZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzcGxpdEhhc2hlc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGxpdEhhc2hlc1trZXldID0ge307XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3BsaXRIYXNoZXNba2V5XVtkZWZJZF0gPSBldmVudFVpQmFzZXNbZGVmSWRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BsaXRIYXNoZXM7XG4gICAgfVxuICAgIF9zcGxpdEludGVyYWN0aW9uKGludGVyYWN0aW9uKSB7XG4gICAgICAgIGxldCBzcGxpdFN0YXRlcyA9IHt9O1xuICAgICAgICBpZiAoaW50ZXJhY3Rpb24pIHtcbiAgICAgICAgICAgIGxldCBhZmZlY3RlZFN0b3JlcyA9IHRoaXMuX3NwbGl0RXZlbnRTdG9yZShpbnRlcmFjdGlvbi5hZmZlY3RlZEV2ZW50cywgdGhpcy5fZ2V0S2V5c0ZvckV2ZW50RGVmcyhpbnRlcmFjdGlvbi5hZmZlY3RlZEV2ZW50cykpO1xuICAgICAgICAgICAgLy8gY2FuJ3QgcmVseSBvbiBkZWZLZXlzIGJlY2F1c2UgZXZlbnQgZGF0YSBpcyBtdXRhdGVkXG4gICAgICAgICAgICBsZXQgbXV0YXRlZEtleXNCeURlZklkID0gdGhpcy5fZ2V0S2V5c0ZvckV2ZW50RGVmcyhpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzKTtcbiAgICAgICAgICAgIGxldCBtdXRhdGVkU3RvcmVzID0gdGhpcy5fc3BsaXRFdmVudFN0b3JlKGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMsIG11dGF0ZWRLZXlzQnlEZWZJZCk7XG4gICAgICAgICAgICBsZXQgcG9wdWxhdGUgPSAoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFzcGxpdFN0YXRlc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwbGl0U3RhdGVzW2tleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZmZlY3RlZEV2ZW50czogYWZmZWN0ZWRTdG9yZXNba2V5XSB8fCBFTVBUWV9FVkVOVF9TVE9SRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0ZWRFdmVudHM6IG11dGF0ZWRTdG9yZXNba2V5XSB8fCBFTVBUWV9FVkVOVF9TVE9SRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRXZlbnQ6IGludGVyYWN0aW9uLmlzRXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBhZmZlY3RlZFN0b3Jlcykge1xuICAgICAgICAgICAgICAgIHBvcHVsYXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gbXV0YXRlZFN0b3Jlcykge1xuICAgICAgICAgICAgICAgIHBvcHVsYXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwbGl0U3RhdGVzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkRXZlbnRVaUZvcktleShhbGxVaSwgZXZlbnRVaUZvcktleSwgaW5kaXZpZHVhbFVpKSB7XG4gICAgbGV0IGJhc2VQYXJ0cyA9IFtdO1xuICAgIGlmIChhbGxVaSkge1xuICAgICAgICBiYXNlUGFydHMucHVzaChhbGxVaSk7XG4gICAgfVxuICAgIGlmIChldmVudFVpRm9yS2V5KSB7XG4gICAgICAgIGJhc2VQYXJ0cy5wdXNoKGV2ZW50VWlGb3JLZXkpO1xuICAgIH1cbiAgICBsZXQgc3R1ZmYgPSB7XG4gICAgICAgICcnOiBjb21iaW5lRXZlbnRVaXMoYmFzZVBhcnRzKSxcbiAgICB9O1xuICAgIGlmIChpbmRpdmlkdWFsVWkpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihzdHVmZiwgaW5kaXZpZHVhbFVpKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0dWZmO1xufVxuXG5mdW5jdGlvbiBnZXREYXRlTWV0YShkYXRlLCB0b2RheVJhbmdlLCBub3dEYXRlLCBkYXRlUHJvZmlsZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGRvdzogZGF0ZS5nZXRVVENEYXkoKSxcbiAgICAgICAgaXNEaXNhYmxlZDogQm9vbGVhbihkYXRlUHJvZmlsZSAmJiAhcmFuZ2VDb250YWluc01hcmtlcihkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgZGF0ZSkpLFxuICAgICAgICBpc090aGVyOiBCb29sZWFuKGRhdGVQcm9maWxlICYmICFyYW5nZUNvbnRhaW5zTWFya2VyKGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZSwgZGF0ZSkpLFxuICAgICAgICBpc1RvZGF5OiBCb29sZWFuKHRvZGF5UmFuZ2UgJiYgcmFuZ2VDb250YWluc01hcmtlcih0b2RheVJhbmdlLCBkYXRlKSksXG4gICAgICAgIGlzUGFzdDogQm9vbGVhbihub3dEYXRlID8gKGRhdGUgPCBub3dEYXRlKSA6IHRvZGF5UmFuZ2UgPyAoZGF0ZSA8IHRvZGF5UmFuZ2Uuc3RhcnQpIDogZmFsc2UpLFxuICAgICAgICBpc0Z1dHVyZTogQm9vbGVhbihub3dEYXRlID8gKGRhdGUgPiBub3dEYXRlKSA6IHRvZGF5UmFuZ2UgPyAoZGF0ZSA+PSB0b2RheVJhbmdlLmVuZCkgOiBmYWxzZSksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldERheUNsYXNzTmFtZXMobWV0YSwgdGhlbWUpIHtcbiAgICBsZXQgY2xhc3NOYW1lcyA9IFtcbiAgICAgICAgJ2ZjLWRheScsXG4gICAgICAgIGBmYy1kYXktJHtEQVlfSURTW21ldGEuZG93XX1gLFxuICAgIF07XG4gICAgaWYgKG1ldGEuaXNEaXNhYmxlZCkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWRheS1kaXNhYmxlZCcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKG1ldGEuaXNUb2RheSkge1xuICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1kYXktdG9kYXknKTtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCh0aGVtZS5nZXRDbGFzcygndG9kYXknKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuaXNQYXN0KSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWRheS1wYXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuaXNGdXR1cmUpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZGF5LWZ1dHVyZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhLmlzT3RoZXIpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZGF5LW90aGVyJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzTmFtZXM7XG59XG5mdW5jdGlvbiBnZXRTbG90Q2xhc3NOYW1lcyhtZXRhLCB0aGVtZSkge1xuICAgIGxldCBjbGFzc05hbWVzID0gW1xuICAgICAgICAnZmMtc2xvdCcsXG4gICAgICAgIGBmYy1zbG90LSR7REFZX0lEU1ttZXRhLmRvd119YCxcbiAgICBdO1xuICAgIGlmIChtZXRhLmlzRGlzYWJsZWQpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1zbG90LWRpc2FibGVkJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAobWV0YS5pc1RvZGF5KSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNsb3QtdG9kYXknKTtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCh0aGVtZS5nZXRDbGFzcygndG9kYXknKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuaXNQYXN0KSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNsb3QtcGFzdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhLmlzRnV0dXJlKSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNsb3QtZnV0dXJlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzTmFtZXM7XG59XG5cbmNvbnN0IERBWV9GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoeyB5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnbG9uZycsIGRheTogJ251bWVyaWMnIH0pO1xuY29uc3QgV0VFS19GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoeyB3ZWVrOiAnbG9uZycgfSk7XG5mdW5jdGlvbiBidWlsZE5hdkxpbmtBdHRycyhjb250ZXh0LCBkYXRlTWFya2VyLCB2aWV3VHlwZSA9ICdkYXknLCBpc1RhYmJhYmxlID0gdHJ1ZSkge1xuICAgIGNvbnN0IHsgZGF0ZUVudiwgb3B0aW9ucywgY2FsZW5kYXJBcGkgfSA9IGNvbnRleHQ7XG4gICAgbGV0IGRhdGVTdHIgPSBkYXRlRW52LmZvcm1hdChkYXRlTWFya2VyLCB2aWV3VHlwZSA9PT0gJ3dlZWsnID8gV0VFS19GT1JNQVQgOiBEQVlfRk9STUFUKTtcbiAgICBpZiAob3B0aW9ucy5uYXZMaW5rcykge1xuICAgICAgICBsZXQgem9uZWREYXRlID0gZGF0ZUVudi50b0RhdGUoZGF0ZU1hcmtlcik7XG4gICAgICAgIGNvbnN0IGhhbmRsZUludGVyYWN0aW9uID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBsZXQgY3VzdG9tQWN0aW9uID0gdmlld1R5cGUgPT09ICdkYXknID8gb3B0aW9ucy5uYXZMaW5rRGF5Q2xpY2sgOlxuICAgICAgICAgICAgICAgIHZpZXdUeXBlID09PSAnd2VlaycgPyBvcHRpb25zLm5hdkxpbmtXZWVrQ2xpY2sgOiBudWxsO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXN0b21BY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjdXN0b21BY3Rpb24uY2FsbChjYWxlbmRhckFwaSwgZGF0ZUVudi50b0RhdGUoZGF0ZU1hcmtlciksIGV2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3VzdG9tQWN0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB2aWV3VHlwZSA9IGN1c3RvbUFjdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsZW5kYXJBcGkuem9vbVRvKGRhdGVNYXJrZXIsIHZpZXdUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyB0aXRsZTogZm9ybWF0V2l0aE9yZGluYWxzKG9wdGlvbnMubmF2TGlua0hpbnQsIFtkYXRlU3RyLCB6b25lZERhdGVdLCBkYXRlU3RyKSwgJ2RhdGEtbmF2bGluayc6ICcnIH0sIChpc1RhYmJhYmxlXG4gICAgICAgICAgICA/IGNyZWF0ZUFyaWFDbGlja0F0dHJzKGhhbmRsZUludGVyYWN0aW9uKVxuICAgICAgICAgICAgOiB7IG9uQ2xpY2s6IGhhbmRsZUludGVyYWN0aW9uIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgJ2FyaWEtbGFiZWwnOiBkYXRlU3RyIH07XG59XG5cbmxldCBfaXNSdGxTY3JvbGxiYXJPbkxlZnQgPSBudWxsO1xuZnVuY3Rpb24gZ2V0SXNSdGxTY3JvbGxiYXJPbkxlZnQoKSB7XG4gICAgaWYgKF9pc1J0bFNjcm9sbGJhck9uTGVmdCA9PT0gbnVsbCkge1xuICAgICAgICBfaXNSdGxTY3JvbGxiYXJPbkxlZnQgPSBjb21wdXRlSXNSdGxTY3JvbGxiYXJPbkxlZnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9pc1J0bFNjcm9sbGJhck9uTGVmdDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVJc1J0bFNjcm9sbGJhck9uTGVmdCgpIHtcbiAgICBsZXQgb3V0ZXJFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGFwcGx5U3R5bGUob3V0ZXJFbCwge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgdG9wOiAtMTAwMCxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgYm9yZGVyOiAwLFxuICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICBvdmVyZmxvdzogJ3Njcm9sbCcsXG4gICAgICAgIGRpcmVjdGlvbjogJ3J0bCcsXG4gICAgfSk7XG4gICAgb3V0ZXJFbC5pbm5lckhUTUwgPSAnPGRpdj48L2Rpdj4nO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQob3V0ZXJFbCk7XG4gICAgbGV0IGlubmVyRWwgPSBvdXRlckVsLmZpcnN0Q2hpbGQ7XG4gICAgbGV0IHJlcyA9IGlubmVyRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCA+IG91dGVyRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcbiAgICByZW1vdmVFbGVtZW50KG91dGVyRWwpO1xuICAgIHJldHVybiByZXM7XG59XG5cbmxldCBfc2Nyb2xsYmFyV2lkdGhzO1xuZnVuY3Rpb24gZ2V0U2Nyb2xsYmFyV2lkdGhzKCkge1xuICAgIGlmICghX3Njcm9sbGJhcldpZHRocykge1xuICAgICAgICBfc2Nyb2xsYmFyV2lkdGhzID0gY29tcHV0ZVNjcm9sbGJhcldpZHRocygpO1xuICAgIH1cbiAgICByZXR1cm4gX3Njcm9sbGJhcldpZHRocztcbn1cbmZ1bmN0aW9uIGNvbXB1dGVTY3JvbGxiYXJXaWR0aHMoKSB7XG4gICAgbGV0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWwuc3R5bGUub3ZlcmZsb3cgPSAnc2Nyb2xsJztcbiAgICBlbC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgZWwuc3R5bGUudG9wID0gJy05OTk5cHgnO1xuICAgIGVsLnN0eWxlLmxlZnQgPSAnLTk5OTlweCc7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbCk7XG4gICAgbGV0IHJlcyA9IGNvbXB1dGVTY3JvbGxiYXJXaWR0aHNGb3JFbChlbCk7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlbCk7XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIFdBUk5JTkc6IHdpbGwgaW5jbHVkZSBib3JkZXJcbmZ1bmN0aW9uIGNvbXB1dGVTY3JvbGxiYXJXaWR0aHNGb3JFbChlbCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGVsLm9mZnNldEhlaWdodCAtIGVsLmNsaWVudEhlaWdodCxcbiAgICAgICAgeTogZWwub2Zmc2V0V2lkdGggLSBlbC5jbGllbnRXaWR0aCxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBjb21wdXRlRWRnZXMoZWwsIGdldFBhZGRpbmcgPSBmYWxzZSkge1xuICAgIGxldCBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgIGxldCBib3JkZXJMZWZ0ID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5ib3JkZXJMZWZ0V2lkdGgsIDEwKSB8fCAwO1xuICAgIGxldCBib3JkZXJSaWdodCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuYm9yZGVyUmlnaHRXaWR0aCwgMTApIHx8IDA7XG4gICAgbGV0IGJvcmRlclRvcCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuYm9yZGVyVG9wV2lkdGgsIDEwKSB8fCAwO1xuICAgIGxldCBib3JkZXJCb3R0b20gPSBwYXJzZUludChjb21wdXRlZFN0eWxlLmJvcmRlckJvdHRvbVdpZHRoLCAxMCkgfHwgMDtcbiAgICBsZXQgYmFkU2Nyb2xsYmFyV2lkdGhzID0gY29tcHV0ZVNjcm9sbGJhcldpZHRoc0ZvckVsKGVsKTsgLy8gaW5jbHVkZXMgYm9yZGVyIVxuICAgIGxldCBzY3JvbGxiYXJMZWZ0UmlnaHQgPSBiYWRTY3JvbGxiYXJXaWR0aHMueSAtIGJvcmRlckxlZnQgLSBib3JkZXJSaWdodDtcbiAgICBsZXQgc2Nyb2xsYmFyQm90dG9tID0gYmFkU2Nyb2xsYmFyV2lkdGhzLnggLSBib3JkZXJUb3AgLSBib3JkZXJCb3R0b207XG4gICAgbGV0IHJlcyA9IHtcbiAgICAgICAgYm9yZGVyTGVmdCxcbiAgICAgICAgYm9yZGVyUmlnaHQsXG4gICAgICAgIGJvcmRlclRvcCxcbiAgICAgICAgYm9yZGVyQm90dG9tLFxuICAgICAgICBzY3JvbGxiYXJCb3R0b20sXG4gICAgICAgIHNjcm9sbGJhckxlZnQ6IDAsXG4gICAgICAgIHNjcm9sbGJhclJpZ2h0OiAwLFxuICAgIH07XG4gICAgaWYgKGdldElzUnRsU2Nyb2xsYmFyT25MZWZ0KCkgJiYgY29tcHV0ZWRTdHlsZS5kaXJlY3Rpb24gPT09ICdydGwnKSB7IC8vIGlzIHRoZSBzY3JvbGxiYXIgb24gdGhlIGxlZnQgc2lkZT9cbiAgICAgICAgcmVzLnNjcm9sbGJhckxlZnQgPSBzY3JvbGxiYXJMZWZ0UmlnaHQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXMuc2Nyb2xsYmFyUmlnaHQgPSBzY3JvbGxiYXJMZWZ0UmlnaHQ7XG4gICAgfVxuICAgIGlmIChnZXRQYWRkaW5nKSB7XG4gICAgICAgIHJlcy5wYWRkaW5nTGVmdCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUucGFkZGluZ0xlZnQsIDEwKSB8fCAwO1xuICAgICAgICByZXMucGFkZGluZ1JpZ2h0ID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nUmlnaHQsIDEwKSB8fCAwO1xuICAgICAgICByZXMucGFkZGluZ1RvcCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUucGFkZGluZ1RvcCwgMTApIHx8IDA7XG4gICAgICAgIHJlcy5wYWRkaW5nQm90dG9tID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nQm90dG9tLCAxMCkgfHwgMDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGNvbXB1dGVJbm5lclJlY3QoZWwsIGdvV2l0aGluUGFkZGluZyA9IGZhbHNlLCBkb0Zyb21XaW5kb3dWaWV3cG9ydCkge1xuICAgIGxldCBvdXRlclJlY3QgPSBkb0Zyb21XaW5kb3dWaWV3cG9ydCA/IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogY29tcHV0ZVJlY3QoZWwpO1xuICAgIGxldCBlZGdlcyA9IGNvbXB1dGVFZGdlcyhlbCwgZ29XaXRoaW5QYWRkaW5nKTtcbiAgICBsZXQgcmVzID0ge1xuICAgICAgICBsZWZ0OiBvdXRlclJlY3QubGVmdCArIGVkZ2VzLmJvcmRlckxlZnQgKyBlZGdlcy5zY3JvbGxiYXJMZWZ0LFxuICAgICAgICByaWdodDogb3V0ZXJSZWN0LnJpZ2h0IC0gZWRnZXMuYm9yZGVyUmlnaHQgLSBlZGdlcy5zY3JvbGxiYXJSaWdodCxcbiAgICAgICAgdG9wOiBvdXRlclJlY3QudG9wICsgZWRnZXMuYm9yZGVyVG9wLFxuICAgICAgICBib3R0b206IG91dGVyUmVjdC5ib3R0b20gLSBlZGdlcy5ib3JkZXJCb3R0b20gLSBlZGdlcy5zY3JvbGxiYXJCb3R0b20sXG4gICAgfTtcbiAgICBpZiAoZ29XaXRoaW5QYWRkaW5nKSB7XG4gICAgICAgIHJlcy5sZWZ0ICs9IGVkZ2VzLnBhZGRpbmdMZWZ0O1xuICAgICAgICByZXMucmlnaHQgLT0gZWRnZXMucGFkZGluZ1JpZ2h0O1xuICAgICAgICByZXMudG9wICs9IGVkZ2VzLnBhZGRpbmdUb3A7XG4gICAgICAgIHJlcy5ib3R0b20gLT0gZWRnZXMucGFkZGluZ0JvdHRvbTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGNvbXB1dGVSZWN0KGVsKSB7XG4gICAgbGV0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiByZWN0LmxlZnQgKyB3aW5kb3cuc2Nyb2xsWCxcbiAgICAgICAgdG9wOiByZWN0LnRvcCArIHdpbmRvdy5zY3JvbGxZLFxuICAgICAgICByaWdodDogcmVjdC5yaWdodCArIHdpbmRvdy5zY3JvbGxYLFxuICAgICAgICBib3R0b206IHJlY3QuYm90dG9tICsgd2luZG93LnNjcm9sbFksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVDbGlwcGVkQ2xpZW50UmVjdChlbCkge1xuICAgIGxldCBjbGlwcGluZ1BhcmVudHMgPSBnZXRDbGlwcGluZ1BhcmVudHMoZWwpO1xuICAgIGxldCByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgZm9yIChsZXQgY2xpcHBpbmdQYXJlbnQgb2YgY2xpcHBpbmdQYXJlbnRzKSB7XG4gICAgICAgIGxldCBpbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3RSZWN0cyhyZWN0LCBjbGlwcGluZ1BhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG4gICAgICAgIGlmIChpbnRlcnNlY3Rpb24pIHtcbiAgICAgICAgICAgIHJlY3QgPSBpbnRlcnNlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVjdDtcbn1cbi8vIGRvZXMgbm90IHJldHVybiB3aW5kb3dcbmZ1bmN0aW9uIGdldENsaXBwaW5nUGFyZW50cyhlbCkge1xuICAgIGxldCBwYXJlbnRzID0gW107XG4gICAgd2hpbGUgKGVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHsgLy8gd2lsbCBzdG9wIHdoZW4gZ2V0cyB0byBkb2N1bWVudCBvciBudWxsXG4gICAgICAgIGxldCBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgICAgICBpZiAoY29tcHV0ZWRTdHlsZS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgvKGF1dG98c2Nyb2xsKS8pLnRlc3QoY29tcHV0ZWRTdHlsZS5vdmVyZmxvdyArIGNvbXB1dGVkU3R5bGUub3ZlcmZsb3dZICsgY29tcHV0ZWRTdHlsZS5vdmVyZmxvd1gpKSB7XG4gICAgICAgICAgICBwYXJlbnRzLnB1c2goZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsID0gZWwucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudHM7XG59XG5cbi8qXG5SZWNvcmRzIG9mZnNldCBpbmZvcm1hdGlvbiBmb3IgYSBzZXQgb2YgZWxlbWVudHMsIHJlbGF0aXZlIHRvIGFuIG9yaWdpbiBlbGVtZW50LlxuQ2FuIHJlY29yZCB0aGUgbGVmdC9yaWdodCBPUiB0aGUgdG9wL2JvdHRvbSBPUiBib3RoLlxuUHJvdmlkZXMgbWV0aG9kcyBmb3IgcXVlcnlpbmcgdGhlIGNhY2hlIGJ5IHBvc2l0aW9uLlxuKi9cbmNsYXNzIFBvc2l0aW9uQ2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKG9yaWdpbkVsLCBlbHMsIGlzSG9yaXpvbnRhbCwgaXNWZXJ0aWNhbCkge1xuICAgICAgICB0aGlzLmVscyA9IGVscztcbiAgICAgICAgbGV0IG9yaWdpbkNsaWVudFJlY3QgPSB0aGlzLm9yaWdpbkNsaWVudFJlY3QgPSBvcmlnaW5FbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgLy8gcmVsYXRpdmUgdG8gdmlld3BvcnQgdG9wLWxlZnRcbiAgICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgdGhpcy5idWlsZEVsSG9yaXpvbnRhbHMob3JpZ2luQ2xpZW50UmVjdC5sZWZ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNWZXJ0aWNhbCkge1xuICAgICAgICAgICAgdGhpcy5idWlsZEVsVmVydGljYWxzKG9yaWdpbkNsaWVudFJlY3QudG9wKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBQb3B1bGF0ZXMgdGhlIGxlZnQvcmlnaHQgaW50ZXJuYWwgY29vcmRpbmF0ZSBhcnJheXNcbiAgICBidWlsZEVsSG9yaXpvbnRhbHMob3JpZ2luQ2xpZW50TGVmdCkge1xuICAgICAgICBsZXQgbGVmdHMgPSBbXTtcbiAgICAgICAgbGV0IHJpZ2h0cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBlbCBvZiB0aGlzLmVscykge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGxlZnRzLnB1c2gocmVjdC5sZWZ0IC0gb3JpZ2luQ2xpZW50TGVmdCk7XG4gICAgICAgICAgICByaWdodHMucHVzaChyZWN0LnJpZ2h0IC0gb3JpZ2luQ2xpZW50TGVmdCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZWZ0cyA9IGxlZnRzO1xuICAgICAgICB0aGlzLnJpZ2h0cyA9IHJpZ2h0cztcbiAgICB9XG4gICAgLy8gUG9wdWxhdGVzIHRoZSB0b3AvYm90dG9tIGludGVybmFsIGNvb3JkaW5hdGUgYXJyYXlzXG4gICAgYnVpbGRFbFZlcnRpY2FscyhvcmlnaW5DbGllbnRUb3ApIHtcbiAgICAgICAgbGV0IHRvcHMgPSBbXTtcbiAgICAgICAgbGV0IGJvdHRvbXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZWwgb2YgdGhpcy5lbHMpIHtcbiAgICAgICAgICAgIGxldCByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB0b3BzLnB1c2gocmVjdC50b3AgLSBvcmlnaW5DbGllbnRUb3ApO1xuICAgICAgICAgICAgYm90dG9tcy5wdXNoKHJlY3QuYm90dG9tIC0gb3JpZ2luQ2xpZW50VG9wKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvcHMgPSB0b3BzO1xuICAgICAgICB0aGlzLmJvdHRvbXMgPSBib3R0b21zO1xuICAgIH1cbiAgICAvLyBHaXZlbiBhIGxlZnQgb2Zmc2V0IChmcm9tIGRvY3VtZW50IGxlZnQpLCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZWwgdGhhdCBpdCBob3Jpem9udGFsbHkgaW50ZXJzZWN0cy5cbiAgICAvLyBJZiBubyBpbnRlcnNlY3Rpb24gaXMgbWFkZSwgcmV0dXJucyB1bmRlZmluZWQuXG4gICAgbGVmdFRvSW5kZXgobGVmdFBvc2l0aW9uKSB7XG4gICAgICAgIGxldCB7IGxlZnRzLCByaWdodHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBsZW4gPSBsZWZ0cy5sZW5ndGg7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChsZWZ0UG9zaXRpb24gPj0gbGVmdHNbaV0gJiYgbGVmdFBvc2l0aW9uIDwgcmlnaHRzW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDsgLy8gVE9ETzogYmV0dGVyXG4gICAgfVxuICAgIC8vIEdpdmVuIGEgdG9wIG9mZnNldCAoZnJvbSBkb2N1bWVudCB0b3ApLCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZWwgdGhhdCBpdCB2ZXJ0aWNhbGx5IGludGVyc2VjdHMuXG4gICAgLy8gSWYgbm8gaW50ZXJzZWN0aW9uIGlzIG1hZGUsIHJldHVybnMgdW5kZWZpbmVkLlxuICAgIHRvcFRvSW5kZXgodG9wUG9zaXRpb24pIHtcbiAgICAgICAgbGV0IHsgdG9wcywgYm90dG9tcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGxlbiA9IHRvcHMubGVuZ3RoO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAodG9wUG9zaXRpb24gPj0gdG9wc1tpXSAmJiB0b3BQb3NpdGlvbiA8IGJvdHRvbXNbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkOyAvLyBUT0RPOiBiZXR0ZXJcbiAgICB9XG4gICAgLy8gR2V0cyB0aGUgd2lkdGggb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4XG4gICAgZ2V0V2lkdGgobGVmdEluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJpZ2h0c1tsZWZ0SW5kZXhdIC0gdGhpcy5sZWZ0c1tsZWZ0SW5kZXhdO1xuICAgIH1cbiAgICAvLyBHZXRzIHRoZSBoZWlnaHQgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4XG4gICAgZ2V0SGVpZ2h0KHRvcEluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvdHRvbXNbdG9wSW5kZXhdIC0gdGhpcy50b3BzW3RvcEluZGV4XTtcbiAgICB9XG4gICAgc2ltaWxhclRvKG90aGVyQ2FjaGUpIHtcbiAgICAgICAgcmV0dXJuIHNpbWlsYXJOdW1BcnJheXModGhpcy50b3BzIHx8IFtdLCBvdGhlckNhY2hlLnRvcHMgfHwgW10pICYmXG4gICAgICAgICAgICBzaW1pbGFyTnVtQXJyYXlzKHRoaXMuYm90dG9tcyB8fCBbXSwgb3RoZXJDYWNoZS5ib3R0b21zIHx8IFtdKSAmJlxuICAgICAgICAgICAgc2ltaWxhck51bUFycmF5cyh0aGlzLmxlZnRzIHx8IFtdLCBvdGhlckNhY2hlLmxlZnRzIHx8IFtdKSAmJlxuICAgICAgICAgICAgc2ltaWxhck51bUFycmF5cyh0aGlzLnJpZ2h0cyB8fCBbXSwgb3RoZXJDYWNoZS5yaWdodHMgfHwgW10pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNpbWlsYXJOdW1BcnJheXMoYSwgYikge1xuICAgIGNvbnN0IGxlbiA9IGEubGVuZ3RoO1xuICAgIGlmIChsZW4gIT09IGIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoTWF0aC5yb3VuZChhW2ldKSAhPT0gTWF0aC5yb3VuZChiW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vKiBlc2xpbnQgbWF4LWNsYXNzZXMtcGVyLWZpbGU6IFwib2ZmXCIgKi9cbi8qXG5BbiBvYmplY3QgZm9yIGdldHRpbmcvc2V0dGluZyBzY3JvbGwtcmVsYXRlZCBpbmZvcm1hdGlvbiBmb3IgYW4gZWxlbWVudC5cbkludGVybmFsbHksIHRoaXMgaXMgZG9uZSB2ZXJ5IGRpZmZlcmVudGx5IGZvciB3aW5kb3cgdmVyc3VzIERPTSBlbGVtZW50LFxuc28gdGhpcyBvYmplY3Qgc2VydmVzIGFzIGEgY29tbW9uIGludGVyZmFjZS5cbiovXG5jbGFzcyBTY3JvbGxDb250cm9sbGVyIHtcbiAgICBnZXRNYXhTY3JvbGxUb3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNjcm9sbEhlaWdodCgpIC0gdGhpcy5nZXRDbGllbnRIZWlnaHQoKTtcbiAgICB9XG4gICAgZ2V0TWF4U2Nyb2xsTGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2Nyb2xsV2lkdGgoKSAtIHRoaXMuZ2V0Q2xpZW50V2lkdGgoKTtcbiAgICB9XG4gICAgY2FuU2Nyb2xsVmVydGljYWxseSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWF4U2Nyb2xsVG9wKCkgPiAwO1xuICAgIH1cbiAgICBjYW5TY3JvbGxIb3Jpem9udGFsbHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1heFNjcm9sbExlZnQoKSA+IDA7XG4gICAgfVxuICAgIGNhblNjcm9sbFVwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTY3JvbGxUb3AoKSA+IDA7XG4gICAgfVxuICAgIGNhblNjcm9sbERvd24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNjcm9sbFRvcCgpIDwgdGhpcy5nZXRNYXhTY3JvbGxUb3AoKTtcbiAgICB9XG4gICAgY2FuU2Nyb2xsTGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2Nyb2xsTGVmdCgpID4gMDtcbiAgICB9XG4gICAgY2FuU2Nyb2xsUmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNjcm9sbExlZnQoKSA8IHRoaXMuZ2V0TWF4U2Nyb2xsTGVmdCgpO1xuICAgIH1cbn1cbmNsYXNzIEVsZW1lbnRTY3JvbGxDb250cm9sbGVyIGV4dGVuZHMgU2Nyb2xsQ29udHJvbGxlciB7XG4gICAgY29uc3RydWN0b3IoZWwpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgIH1cbiAgICBnZXRTY3JvbGxUb3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnNjcm9sbFRvcDtcbiAgICB9XG4gICAgZ2V0U2Nyb2xsTGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuc2Nyb2xsTGVmdDtcbiAgICB9XG4gICAgc2V0U2Nyb2xsVG9wKHRvcCkge1xuICAgICAgICB0aGlzLmVsLnNjcm9sbFRvcCA9IHRvcDtcbiAgICB9XG4gICAgc2V0U2Nyb2xsTGVmdChsZWZ0KSB7XG4gICAgICAgIHRoaXMuZWwuc2Nyb2xsTGVmdCA9IGxlZnQ7XG4gICAgfVxuICAgIGdldFNjcm9sbFdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zY3JvbGxXaWR0aDtcbiAgICB9XG4gICAgZ2V0U2Nyb2xsSGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zY3JvbGxIZWlnaHQ7XG4gICAgfVxuICAgIGdldENsaWVudEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuY2xpZW50SGVpZ2h0O1xuICAgIH1cbiAgICBnZXRDbGllbnRXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuY2xpZW50V2lkdGg7XG4gICAgfVxufVxuY2xhc3MgV2luZG93U2Nyb2xsQ29udHJvbGxlciBleHRlbmRzIFNjcm9sbENvbnRyb2xsZXIge1xuICAgIGdldFNjcm9sbFRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5zY3JvbGxZO1xuICAgIH1cbiAgICBnZXRTY3JvbGxMZWZ0KCkge1xuICAgICAgICByZXR1cm4gd2luZG93LnNjcm9sbFg7XG4gICAgfVxuICAgIHNldFNjcm9sbFRvcChuKSB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGwod2luZG93LnNjcm9sbFgsIG4pO1xuICAgIH1cbiAgICBzZXRTY3JvbGxMZWZ0KG4pIHtcbiAgICAgICAgd2luZG93LnNjcm9sbChuLCB3aW5kb3cuc2Nyb2xsWSk7XG4gICAgfVxuICAgIGdldFNjcm9sbFdpZHRoKCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFdpZHRoO1xuICAgIH1cbiAgICBnZXRTY3JvbGxIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0O1xuICAgIH1cbiAgICBnZXRDbGllbnRIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgIH1cbiAgICBnZXRDbGllbnRXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICB9XG59XG5cbi8qXG5hbiBJTlRFUkFDVEFCTEUgZGF0ZSBjb21wb25lbnRcblxuUFVSUE9TRVM6XG4tIGhvb2sgdXAgdG8gZmcsIGZpbGwsIGFuZCBtaXJyb3IgcmVuZGVyZXJzXG4tIGludGVyZmFjZSBmb3IgZHJhZ2dpbmcgYW5kIGhpdHNcbiovXG5jbGFzcyBEYXRlQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudWlkID0gZ3VpZCgpO1xuICAgIH1cbiAgICAvLyBIaXQgU3lzdGVtXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBwcmVwYXJlSGl0cygpIHtcbiAgICB9XG4gICAgcXVlcnlIaXQocG9zaXRpb25MZWZ0LCBwb3NpdGlvblRvcCwgZWxXaWR0aCwgZWxIZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7IC8vIHRoaXMgc2hvdWxkIGJlIGFic3RyYWN0XG4gICAgfVxuICAgIC8vIFBvaW50ZXIgSW50ZXJhY3Rpb24gVXRpbHNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGlzVmFsaWRTZWdEb3duRWwoZWwpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLnByb3BzLmV2ZW50RHJhZyAmJiAvLyBIQUNLXG4gICAgICAgICAgICAhdGhpcy5wcm9wcy5ldmVudFJlc2l6ZSAmJiAvLyBIQUNLXG4gICAgICAgICAgICAhZWxlbWVudENsb3Nlc3QoZWwsICcuZmMtZXZlbnQtbWlycm9yJyk7XG4gICAgfVxuICAgIGlzVmFsaWREYXRlRG93bkVsKGVsKSB7XG4gICAgICAgIHJldHVybiAhZWxlbWVudENsb3Nlc3QoZWwsICcuZmMtZXZlbnQ6bm90KC5mYy1iZy1ldmVudCknKSAmJlxuICAgICAgICAgICAgIWVsZW1lbnRDbG9zZXN0KGVsLCAnLmZjLW1vcmUtbGluaycpICYmIC8vIGEgXCJtb3JlLi5cIiBsaW5rXG4gICAgICAgICAgICAhZWxlbWVudENsb3Nlc3QoZWwsICdhW2RhdGEtbmF2bGlua10nKSAmJiAvLyBhIGNsaWNrYWJsZSBuYXYgbGlua1xuICAgICAgICAgICAgIWVsZW1lbnRDbG9zZXN0KGVsLCAnLmZjLXBvcG92ZXInKTsgLy8gaGFja1xuICAgIH1cbn1cblxuY2xhc3MgTmFtZWRUaW1lWm9uZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKHRpbWVab25lTmFtZSkge1xuICAgICAgICB0aGlzLnRpbWVab25lTmFtZSA9IHRpbWVab25lTmFtZTtcbiAgICB9XG59XG5cbmNsYXNzIFNlZ0hpZXJhcmNoeSB7XG4gICAgY29uc3RydWN0b3IoZ2V0RW50cnlUaGlja25lc3MgPSAoZW50cnkpID0+IHtcbiAgICAgICAgLy8gaWYgbm8gdGhpY2tuZXNzIGtub3duLCBhc3N1bWUgMSAoaWYgMCwgc28gc21hbGwgaXQgYWx3YXlzIGZpdHMpXG4gICAgICAgIHJldHVybiBlbnRyeS50aGlja25lc3MgfHwgMTtcbiAgICB9KSB7XG4gICAgICAgIHRoaXMuZ2V0RW50cnlUaGlja25lc3MgPSBnZXRFbnRyeVRoaWNrbmVzcztcbiAgICAgICAgLy8gc2V0dGluZ3NcbiAgICAgICAgdGhpcy5zdHJpY3RPcmRlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFsbG93UmVzbGljaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWF4Q29vcmQgPSAtMTsgLy8gLTEgbWVhbnMgbm8gbWF4XG4gICAgICAgIHRoaXMubWF4U3RhY2tDbnQgPSAtMTsgLy8gLTEgbWVhbnMgbm8gbWF4XG4gICAgICAgIHRoaXMubGV2ZWxDb29yZHMgPSBbXTsgLy8gb3JkZXJlZFxuICAgICAgICB0aGlzLmVudHJpZXNCeUxldmVsID0gW107IC8vIHBhcmFsbGVsIHdpdGggbGV2ZWxDb29yZHNcbiAgICAgICAgdGhpcy5zdGFja0NudHMgPSB7fTsgLy8gVE9ETzogdXNlIGJldHRlciB0ZWNobmlxdWUhP1xuICAgIH1cbiAgICBhZGRTZWdzKGlucHV0cykge1xuICAgICAgICBsZXQgaGlkZGVuRW50cmllcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpbnB1dCBvZiBpbnB1dHMpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0RW50cnkoaW5wdXQsIGhpZGRlbkVudHJpZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoaWRkZW5FbnRyaWVzO1xuICAgIH1cbiAgICBpbnNlcnRFbnRyeShlbnRyeSwgaGlkZGVuRW50cmllcykge1xuICAgICAgICBsZXQgaW5zZXJ0aW9uID0gdGhpcy5maW5kSW5zZXJ0aW9uKGVudHJ5KTtcbiAgICAgICAgaWYgKHRoaXMuaXNJbnNlcnRpb25WYWxpZChpbnNlcnRpb24sIGVudHJ5KSkge1xuICAgICAgICAgICAgdGhpcy5pbnNlcnRFbnRyeUF0KGVudHJ5LCBpbnNlcnRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVJbnZhbGlkSW5zZXJ0aW9uKGluc2VydGlvbiwgZW50cnksIGhpZGRlbkVudHJpZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzSW5zZXJ0aW9uVmFsaWQoaW5zZXJ0aW9uLCBlbnRyeSkge1xuICAgICAgICByZXR1cm4gKHRoaXMubWF4Q29vcmQgPT09IC0xIHx8IGluc2VydGlvbi5sZXZlbENvb3JkICsgdGhpcy5nZXRFbnRyeVRoaWNrbmVzcyhlbnRyeSkgPD0gdGhpcy5tYXhDb29yZCkgJiZcbiAgICAgICAgICAgICh0aGlzLm1heFN0YWNrQ250ID09PSAtMSB8fCBpbnNlcnRpb24uc3RhY2tDbnQgPCB0aGlzLm1heFN0YWNrQ250KTtcbiAgICB9XG4gICAgaGFuZGxlSW52YWxpZEluc2VydGlvbihpbnNlcnRpb24sIGVudHJ5LCBoaWRkZW5FbnRyaWVzKSB7XG4gICAgICAgIGlmICh0aGlzLmFsbG93UmVzbGljaW5nICYmIGluc2VydGlvbi50b3VjaGluZ0VudHJ5KSB7XG4gICAgICAgICAgICBjb25zdCBoaWRkZW5FbnRyeSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZW50cnkpLCB7IHNwYW46IGludGVyc2VjdFNwYW5zKGVudHJ5LnNwYW4sIGluc2VydGlvbi50b3VjaGluZ0VudHJ5LnNwYW4pIH0pO1xuICAgICAgICAgICAgaGlkZGVuRW50cmllcy5wdXNoKGhpZGRlbkVudHJ5KTtcbiAgICAgICAgICAgIHRoaXMuc3BsaXRFbnRyeShlbnRyeSwgaW5zZXJ0aW9uLnRvdWNoaW5nRW50cnksIGhpZGRlbkVudHJpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGlkZGVuRW50cmllcy5wdXNoKGVudHJ5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKlxuICAgIERvZXMgTk9UIGFkZCB3aGF0IGhpdCB0aGUgYGJhcnJpZXJgIGludG8gaGlkZGVuRW50cmllcy4gU2hvdWxkIGFscmVhZHkgYmUgZG9uZS5cbiAgICAqL1xuICAgIHNwbGl0RW50cnkoZW50cnksIGJhcnJpZXIsIGhpZGRlbkVudHJpZXMpIHtcbiAgICAgICAgbGV0IGVudHJ5U3BhbiA9IGVudHJ5LnNwYW47XG4gICAgICAgIGxldCBiYXJyaWVyU3BhbiA9IGJhcnJpZXIuc3BhbjtcbiAgICAgICAgaWYgKGVudHJ5U3Bhbi5zdGFydCA8IGJhcnJpZXJTcGFuLnN0YXJ0KSB7XG4gICAgICAgICAgICB0aGlzLmluc2VydEVudHJ5KHtcbiAgICAgICAgICAgICAgICBpbmRleDogZW50cnkuaW5kZXgsXG4gICAgICAgICAgICAgICAgdGhpY2tuZXNzOiBlbnRyeS50aGlja25lc3MsXG4gICAgICAgICAgICAgICAgc3BhbjogeyBzdGFydDogZW50cnlTcGFuLnN0YXJ0LCBlbmQ6IGJhcnJpZXJTcGFuLnN0YXJ0IH0sXG4gICAgICAgICAgICB9LCBoaWRkZW5FbnRyaWVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW50cnlTcGFuLmVuZCA+IGJhcnJpZXJTcGFuLmVuZCkge1xuICAgICAgICAgICAgdGhpcy5pbnNlcnRFbnRyeSh7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGVudHJ5LmluZGV4LFxuICAgICAgICAgICAgICAgIHRoaWNrbmVzczogZW50cnkudGhpY2tuZXNzLFxuICAgICAgICAgICAgICAgIHNwYW46IHsgc3RhcnQ6IGJhcnJpZXJTcGFuLmVuZCwgZW5kOiBlbnRyeVNwYW4uZW5kIH0sXG4gICAgICAgICAgICB9LCBoaWRkZW5FbnRyaWVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbnNlcnRFbnRyeUF0KGVudHJ5LCBpbnNlcnRpb24pIHtcbiAgICAgICAgbGV0IHsgZW50cmllc0J5TGV2ZWwsIGxldmVsQ29vcmRzIH0gPSB0aGlzO1xuICAgICAgICBpZiAoaW5zZXJ0aW9uLmxhdGVyYWwgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgYSBuZXcgbGV2ZWxcbiAgICAgICAgICAgIGluc2VydEF0KGxldmVsQ29vcmRzLCBpbnNlcnRpb24ubGV2ZWwsIGluc2VydGlvbi5sZXZlbENvb3JkKTtcbiAgICAgICAgICAgIGluc2VydEF0KGVudHJpZXNCeUxldmVsLCBpbnNlcnRpb24ubGV2ZWwsIFtlbnRyeV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaW5zZXJ0IGludG8gZXhpc3RpbmcgbGV2ZWxcbiAgICAgICAgICAgIGluc2VydEF0KGVudHJpZXNCeUxldmVsW2luc2VydGlvbi5sZXZlbF0sIGluc2VydGlvbi5sYXRlcmFsLCBlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFja0NudHNbYnVpbGRFbnRyeUtleShlbnRyeSldID0gaW5zZXJ0aW9uLnN0YWNrQ250O1xuICAgIH1cbiAgICAvKlxuICAgIGRvZXMgbm90IGNhcmUgYWJvdXQgbGltaXRzXG4gICAgKi9cbiAgICBmaW5kSW5zZXJ0aW9uKG5ld0VudHJ5KSB7XG4gICAgICAgIGxldCB7IGxldmVsQ29vcmRzLCBlbnRyaWVzQnlMZXZlbCwgc3RyaWN0T3JkZXIsIHN0YWNrQ250cyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGxldmVsQ250ID0gbGV2ZWxDb29yZHMubGVuZ3RoO1xuICAgICAgICBsZXQgY2FuZGlkYXRlQ29vcmQgPSAwO1xuICAgICAgICBsZXQgdG91Y2hpbmdMZXZlbCA9IC0xO1xuICAgICAgICBsZXQgdG91Y2hpbmdMYXRlcmFsID0gLTE7XG4gICAgICAgIGxldCB0b3VjaGluZ0VudHJ5ID0gbnVsbDtcbiAgICAgICAgbGV0IHN0YWNrQ250ID0gMDtcbiAgICAgICAgZm9yIChsZXQgdHJhY2tpbmdMZXZlbCA9IDA7IHRyYWNraW5nTGV2ZWwgPCBsZXZlbENudDsgdHJhY2tpbmdMZXZlbCArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCB0cmFja2luZ0Nvb3JkID0gbGV2ZWxDb29yZHNbdHJhY2tpbmdMZXZlbF07XG4gICAgICAgICAgICAvLyBpZiB0aGUgY3VycmVudCBsZXZlbCBpcyBwYXN0IHRoZSBwbGFjZWQgZW50cnksIHdlIGhhdmUgZm91bmQgYSBnb29kIGVtcHR5IHNwYWNlIGFuZCBjYW4gc3RvcC5cbiAgICAgICAgICAgIC8vIGlmIHN0cmljdE9yZGVyLCBrZWVwIGZpbmRpbmcgbW9yZSBsYXRlcmFsIGludGVyc2VjdGlvbnMuXG4gICAgICAgICAgICBpZiAoIXN0cmljdE9yZGVyICYmIHRyYWNraW5nQ29vcmQgPj0gY2FuZGlkYXRlQ29vcmQgKyB0aGlzLmdldEVudHJ5VGhpY2tuZXNzKG5ld0VudHJ5KSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRyYWNraW5nRW50cmllcyA9IGVudHJpZXNCeUxldmVsW3RyYWNraW5nTGV2ZWxdO1xuICAgICAgICAgICAgbGV0IHRyYWNraW5nRW50cnk7XG4gICAgICAgICAgICBsZXQgc2VhcmNoUmVzID0gYmluYXJ5U2VhcmNoKHRyYWNraW5nRW50cmllcywgbmV3RW50cnkuc3Bhbi5zdGFydCwgZ2V0RW50cnlTcGFuRW5kKTsgLy8gZmluZCBmaXJzdCBlbnRyeSBhZnRlciBuZXdFbnRyeSdzIGVuZFxuICAgICAgICAgICAgbGV0IGxhdGVyYWxJbmRleCA9IHNlYXJjaFJlc1swXSArIHNlYXJjaFJlc1sxXTsgLy8gaWYgZXhhY3QgbWF0Y2ggKHdoaWNoIGRvZXNuJ3QgY29sbGlkZSksIGdvIHRvIG5leHQgb25lXG4gICAgICAgICAgICB3aGlsZSAoIC8vIGxvb3AgdGhyb3VnaCBlbnRyaWVzIHRoYXQgaG9yaXpvbnRhbGx5IGludGVyc2VjdFxuICAgICAgICAgICAgKHRyYWNraW5nRW50cnkgPSB0cmFja2luZ0VudHJpZXNbbGF0ZXJhbEluZGV4XSkgJiYgLy8gYnV0IG5vdCBwYXN0IHRoZSB3aG9sZSBlbnRyeSBsaXN0XG4gICAgICAgICAgICAgICAgdHJhY2tpbmdFbnRyeS5zcGFuLnN0YXJ0IDwgbmV3RW50cnkuc3Bhbi5lbmQgLy8gYW5kIG5vdCBlbnRpcmVseSBwYXN0IG5ld0VudHJ5XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBsZXQgdHJhY2tpbmdFbnRyeUJvdHRvbSA9IHRyYWNraW5nQ29vcmQgKyB0aGlzLmdldEVudHJ5VGhpY2tuZXNzKHRyYWNraW5nRW50cnkpO1xuICAgICAgICAgICAgICAgIC8vIGludGVyc2VjdHMgaW50byB0aGUgdG9wIG9mIHRoZSBjYW5kaWRhdGU/XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNraW5nRW50cnlCb3R0b20gPiBjYW5kaWRhdGVDb29yZCkge1xuICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGVDb29yZCA9IHRyYWNraW5nRW50cnlCb3R0b207XG4gICAgICAgICAgICAgICAgICAgIHRvdWNoaW5nRW50cnkgPSB0cmFja2luZ0VudHJ5O1xuICAgICAgICAgICAgICAgICAgICB0b3VjaGluZ0xldmVsID0gdHJhY2tpbmdMZXZlbDtcbiAgICAgICAgICAgICAgICAgICAgdG91Y2hpbmdMYXRlcmFsID0gbGF0ZXJhbEluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBidXR0cyB1cCBhZ2FpbnN0IHRvcCBvZiBjYW5kaWRhdGU/ICh3aWxsIGhhcHBlbiBpZiBqdXN0IGludGVyc2VjdGVkIGFzIHdlbGwpXG4gICAgICAgICAgICAgICAgaWYgKHRyYWNraW5nRW50cnlCb3R0b20gPT09IGNhbmRpZGF0ZUNvb3JkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFjY3VtdWxhdGUgdGhlIGhpZ2hlc3QgcG9zc2libGUgc3RhY2tDbnQgb2YgdGhlIHRyYWNraW5nRW50cmllcyB0aGF0IGJ1dHQgdXBcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tDbnQgPSBNYXRoLm1heChzdGFja0NudCwgc3RhY2tDbnRzW2J1aWxkRW50cnlLZXkodHJhY2tpbmdFbnRyeSldICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhdGVyYWxJbmRleCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSBkZXN0aW5hdGlvbiBsZXZlbCB3aWxsIGJlIGFmdGVyIHRvdWNoaW5nRW50cnkncyBsZXZlbC4gZmluZCBpdFxuICAgICAgICBsZXQgZGVzdExldmVsID0gMDtcbiAgICAgICAgaWYgKHRvdWNoaW5nRW50cnkpIHtcbiAgICAgICAgICAgIGRlc3RMZXZlbCA9IHRvdWNoaW5nTGV2ZWwgKyAxO1xuICAgICAgICAgICAgd2hpbGUgKGRlc3RMZXZlbCA8IGxldmVsQ250ICYmIGxldmVsQ29vcmRzW2Rlc3RMZXZlbF0gPCBjYW5kaWRhdGVDb29yZCkge1xuICAgICAgICAgICAgICAgIGRlc3RMZXZlbCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGFkZGluZyB0byBhbiBleGlzdGluZyBsZXZlbCwgZmluZCB3aGVyZSB0byBpbnNlcnRcbiAgICAgICAgbGV0IGRlc3RMYXRlcmFsID0gLTE7XG4gICAgICAgIGlmIChkZXN0TGV2ZWwgPCBsZXZlbENudCAmJiBsZXZlbENvb3Jkc1tkZXN0TGV2ZWxdID09PSBjYW5kaWRhdGVDb29yZCkge1xuICAgICAgICAgICAgZGVzdExhdGVyYWwgPSBiaW5hcnlTZWFyY2goZW50cmllc0J5TGV2ZWxbZGVzdExldmVsXSwgbmV3RW50cnkuc3Bhbi5lbmQsIGdldEVudHJ5U3BhbkVuZClbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvdWNoaW5nTGV2ZWwsXG4gICAgICAgICAgICB0b3VjaGluZ0xhdGVyYWwsXG4gICAgICAgICAgICB0b3VjaGluZ0VudHJ5LFxuICAgICAgICAgICAgc3RhY2tDbnQsXG4gICAgICAgICAgICBsZXZlbENvb3JkOiBjYW5kaWRhdGVDb29yZCxcbiAgICAgICAgICAgIGxldmVsOiBkZXN0TGV2ZWwsXG4gICAgICAgICAgICBsYXRlcmFsOiBkZXN0TGF0ZXJhbCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gc29ydGVkIGJ5IGxldmVsQ29vcmQgKGxvd2VzdCB0byBoaWdoZXN0KVxuICAgIHRvUmVjdHMoKSB7XG4gICAgICAgIGxldCB7IGVudHJpZXNCeUxldmVsLCBsZXZlbENvb3JkcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGxldmVsQ250ID0gZW50cmllc0J5TGV2ZWwubGVuZ3RoO1xuICAgICAgICBsZXQgcmVjdHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgbGV2ZWwgPSAwOyBsZXZlbCA8IGxldmVsQ250OyBsZXZlbCArPSAxKSB7XG4gICAgICAgICAgICBsZXQgZW50cmllcyA9IGVudHJpZXNCeUxldmVsW2xldmVsXTtcbiAgICAgICAgICAgIGxldCBsZXZlbENvb3JkID0gbGV2ZWxDb29yZHNbbGV2ZWxdO1xuICAgICAgICAgICAgZm9yIChsZXQgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICAgICAgICAgIHJlY3RzLnB1c2goT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBlbnRyeSksIHsgdGhpY2tuZXNzOiB0aGlzLmdldEVudHJ5VGhpY2tuZXNzKGVudHJ5KSwgbGV2ZWxDb29yZCB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlY3RzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEVudHJ5U3BhbkVuZChlbnRyeSkge1xuICAgIHJldHVybiBlbnRyeS5zcGFuLmVuZDtcbn1cbmZ1bmN0aW9uIGJ1aWxkRW50cnlLZXkoZW50cnkpIHtcbiAgICByZXR1cm4gZW50cnkuaW5kZXggKyAnOicgKyBlbnRyeS5zcGFuLnN0YXJ0O1xufVxuLy8gcmV0dXJucyBncm91cHMgd2l0aCBlbnRyaWVzIHNvcnRlZCBieSBpbnB1dCBvcmRlclxuZnVuY3Rpb24gZ3JvdXBJbnRlcnNlY3RpbmdFbnRyaWVzKGVudHJpZXMpIHtcbiAgICBsZXQgbWVyZ2VzID0gW107XG4gICAgZm9yIChsZXQgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICBsZXQgZmlsdGVyZWRNZXJnZXMgPSBbXTtcbiAgICAgICAgbGV0IGh1bmdyeU1lcmdlID0ge1xuICAgICAgICAgICAgc3BhbjogZW50cnkuc3BhbixcbiAgICAgICAgICAgIGVudHJpZXM6IFtlbnRyeV0sXG4gICAgICAgIH07XG4gICAgICAgIGZvciAobGV0IG1lcmdlIG9mIG1lcmdlcykge1xuICAgICAgICAgICAgaWYgKGludGVyc2VjdFNwYW5zKG1lcmdlLnNwYW4sIGh1bmdyeU1lcmdlLnNwYW4pKSB7XG4gICAgICAgICAgICAgICAgaHVuZ3J5TWVyZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIGVudHJpZXM6IG1lcmdlLmVudHJpZXMuY29uY2F0KGh1bmdyeU1lcmdlLmVudHJpZXMpLFxuICAgICAgICAgICAgICAgICAgICBzcGFuOiBqb2luU3BhbnMobWVyZ2Uuc3BhbiwgaHVuZ3J5TWVyZ2Uuc3BhbiksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpbHRlcmVkTWVyZ2VzLnB1c2gobWVyZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbHRlcmVkTWVyZ2VzLnB1c2goaHVuZ3J5TWVyZ2UpO1xuICAgICAgICBtZXJnZXMgPSBmaWx0ZXJlZE1lcmdlcztcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlcztcbn1cbmZ1bmN0aW9uIGpvaW5TcGFucyhzcGFuMCwgc3BhbjEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogTWF0aC5taW4oc3BhbjAuc3RhcnQsIHNwYW4xLnN0YXJ0KSxcbiAgICAgICAgZW5kOiBNYXRoLm1heChzcGFuMC5lbmQsIHNwYW4xLmVuZCksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGludGVyc2VjdFNwYW5zKHNwYW4wLCBzcGFuMSkge1xuICAgIGxldCBzdGFydCA9IE1hdGgubWF4KHNwYW4wLnN0YXJ0LCBzcGFuMS5zdGFydCk7XG4gICAgbGV0IGVuZCA9IE1hdGgubWluKHNwYW4wLmVuZCwgc3BhbjEuZW5kKTtcbiAgICBpZiAoc3RhcnQgPCBlbmQpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQsIGVuZCB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8vIGdlbmVyYWwgdXRpbFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBpbnNlcnRBdChhcnIsIGluZGV4LCBpdGVtKSB7XG4gICAgYXJyLnNwbGljZShpbmRleCwgMCwgaXRlbSk7XG59XG5mdW5jdGlvbiBiaW5hcnlTZWFyY2goYSwgc2VhcmNoVmFsLCBnZXRJdGVtVmFsKSB7XG4gICAgbGV0IHN0YXJ0SW5kZXggPSAwO1xuICAgIGxldCBlbmRJbmRleCA9IGEubGVuZ3RoOyAvLyBleGNsdXNpdmVcbiAgICBpZiAoIWVuZEluZGV4IHx8IHNlYXJjaFZhbCA8IGdldEl0ZW1WYWwoYVtzdGFydEluZGV4XSkpIHsgLy8gbm8gaXRlbXMgT1IgYmVmb3JlIGZpcnN0IGl0ZW1cbiAgICAgICAgcmV0dXJuIFswLCAwXTtcbiAgICB9XG4gICAgaWYgKHNlYXJjaFZhbCA+IGdldEl0ZW1WYWwoYVtlbmRJbmRleCAtIDFdKSkgeyAvLyBhZnRlciBsYXN0IGl0ZW1cbiAgICAgICAgcmV0dXJuIFtlbmRJbmRleCwgMF07XG4gICAgfVxuICAgIHdoaWxlIChzdGFydEluZGV4IDwgZW5kSW5kZXgpIHtcbiAgICAgICAgbGV0IG1pZGRsZUluZGV4ID0gTWF0aC5mbG9vcihzdGFydEluZGV4ICsgKGVuZEluZGV4IC0gc3RhcnRJbmRleCkgLyAyKTtcbiAgICAgICAgbGV0IG1pZGRsZVZhbCA9IGdldEl0ZW1WYWwoYVttaWRkbGVJbmRleF0pO1xuICAgICAgICBpZiAoc2VhcmNoVmFsIDwgbWlkZGxlVmFsKSB7XG4gICAgICAgICAgICBlbmRJbmRleCA9IG1pZGRsZUluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNlYXJjaFZhbCA+IG1pZGRsZVZhbCkge1xuICAgICAgICAgICAgc3RhcnRJbmRleCA9IG1pZGRsZUluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gZXF1YWwhXG4gICAgICAgICAgICByZXR1cm4gW21pZGRsZUluZGV4LCAxXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW3N0YXJ0SW5kZXgsIDBdO1xufVxuXG4vKlxuQW4gYWJzdHJhY3Rpb24gZm9yIGEgZHJhZ2dpbmcgaW50ZXJhY3Rpb24gb3JpZ2luYXRpbmcgb24gYW4gZXZlbnQuXG5Eb2VzIGhpZ2hlci1sZXZlbCB0aGluZ3MgdGhhbiBQb2ludGVyRHJhZ2dlciwgc3VjaCBhcyBwb3NzaWJseTpcbi0gYSBcIm1pcnJvclwiIHRoYXQgbW92ZXMgd2l0aCB0aGUgcG9pbnRlclxuLSBhIG1pbmltdW0gbnVtYmVyIG9mIHBpeGVscyBvciBvdGhlciBjcml0ZXJpYSBmb3IgYSB0cnVlIGRyYWcgdG8gYmVnaW5cblxuc3ViY2xhc3NlcyBtdXN0IGVtaXQ6XG4tIHBvaW50ZXJkb3duXG4tIGRyYWdzdGFydFxuLSBkcmFnbW92ZVxuLSBwb2ludGVydXBcbi0gZHJhZ2VuZFxuKi9cbmNsYXNzIEVsZW1lbnREcmFnZ2luZyB7XG4gICAgY29uc3RydWN0b3IoZWwsIHNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgfVxuICAgIHNldE1pcnJvcklzVmlzaWJsZShib29sKSB7XG4gICAgICAgIC8vIG9wdGlvbmFsIGlmIHN1YmNsYXNzIGRvZXNuJ3Qgd2FudCB0byBzdXBwb3J0IGEgbWlycm9yXG4gICAgfVxuICAgIHNldE1pcnJvck5lZWRzUmV2ZXJ0KGJvb2wpIHtcbiAgICAgICAgLy8gb3B0aW9uYWwgaWYgc3ViY2xhc3MgZG9lc24ndCB3YW50IHRvIHN1cHBvcnQgYSBtaXJyb3JcbiAgICB9XG4gICAgc2V0QXV0b1Njcm9sbEVuYWJsZWQoYm9vbCkge1xuICAgICAgICAvLyBvcHRpb25hbFxuICAgIH1cbn1cblxuLy8gVE9ETzogZ2V0IHJpZCBvZiB0aGlzIGluIGZhdm9yIG9mIG9wdGlvbnMgc3lzdGVtLFxuLy8gdGhvIGl0J3MgcmVhbGx5IGVhc3kgdG8gYWNjZXNzIHRoaXMgZ2xvYmFsbHkgcmF0aGVyIHRoYW4gcGFzcyB0aHJ1IG9wdGlvbnMuXG5jb25zdCBjb25maWcgPSB7fTtcblxuLypcbkluZm9ybWF0aW9uIGFib3V0IHdoYXQgd2lsbCBoYXBwZW4gd2hlbiBhbiBleHRlcm5hbCBlbGVtZW50IGlzIGRyYWdnZWQtYW5kLWRyb3BwZWRcbm9udG8gYSBjYWxlbmRhci4gQ29udGFpbnMgaW5mb3JtYXRpb24gZm9yIGNyZWF0aW5nIGFuIGV2ZW50LlxuKi9cbmNvbnN0IERSQUdfTUVUQV9SRUZJTkVSUyA9IHtcbiAgICBzdGFydFRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxuICAgIGR1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBjcmVhdGU6IEJvb2xlYW4sXG4gICAgc291cmNlSWQ6IFN0cmluZyxcbn07XG5mdW5jdGlvbiBwYXJzZURyYWdNZXRhKHJhdykge1xuICAgIGxldCB7IHJlZmluZWQsIGV4dHJhIH0gPSByZWZpbmVQcm9wcyhyYXcsIERSQUdfTUVUQV9SRUZJTkVSUyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnRUaW1lOiByZWZpbmVkLnN0YXJ0VGltZSB8fCBudWxsLFxuICAgICAgICBkdXJhdGlvbjogcmVmaW5lZC5kdXJhdGlvbiB8fCBudWxsLFxuICAgICAgICBjcmVhdGU6IHJlZmluZWQuY3JlYXRlICE9IG51bGwgPyByZWZpbmVkLmNyZWF0ZSA6IHRydWUsXG4gICAgICAgIHNvdXJjZUlkOiByZWZpbmVkLnNvdXJjZUlkLFxuICAgICAgICBsZWZ0b3ZlclByb3BzOiBleHRyYSxcbiAgICB9O1xufVxuXG4vLyBDb21wdXRlcyBhIGRlZmF1bHQgY29sdW1uIGhlYWRlciBmb3JtYXR0aW5nIHN0cmluZyBpZiBgY29sRm9ybWF0YCBpcyBub3QgZXhwbGljaXRseSBkZWZpbmVkXG5mdW5jdGlvbiBjb21wdXRlRmFsbGJhY2tIZWFkZXJGb3JtYXQoZGF0ZXNSZXBEaXN0aW5jdERheXMsIGRheUNudCkge1xuICAgIC8vIGlmIG1vcmUgdGhhbiBvbmUgd2VlayByb3csIG9yIGlmIHRoZXJlIGFyZSBhIGxvdCBvZiBjb2x1bW5zIHdpdGggbm90IG11Y2ggc3BhY2UsXG4gICAgLy8gcHV0IGp1c3QgdGhlIGRheSBudW1iZXJzIHdpbGwgYmUgaW4gZWFjaCBjZWxsXG4gICAgaWYgKCFkYXRlc1JlcERpc3RpbmN0RGF5cyB8fCBkYXlDbnQgPiAxMCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRm9ybWF0dGVyKHsgd2Vla2RheTogJ3Nob3J0JyB9KTsgLy8gXCJTYXRcIlxuICAgIH1cbiAgICBpZiAoZGF5Q250ID4gMSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRm9ybWF0dGVyKHsgd2Vla2RheTogJ3Nob3J0JywgbW9udGg6ICdudW1lcmljJywgZGF5OiAnbnVtZXJpYycsIG9taXRDb21tYXM6IHRydWUgfSk7IC8vIFwiU2F0IDExLzEyXCJcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUZvcm1hdHRlcih7IHdlZWtkYXk6ICdsb25nJyB9KTsgLy8gXCJTYXR1cmRheVwiXG59XG5cbmNvbnN0IENMQVNTX05BTUUgPSAnZmMtY29sLWhlYWRlci1jZWxsJzsgLy8gZG8gdGhlIGN1c2hpb24gdG9vPyBub1xuZnVuY3Rpb24gcmVuZGVySW5uZXIkMShyZW5kZXJQcm9wcykge1xuICAgIHJldHVybiByZW5kZXJQcm9wcy50ZXh0O1xufVxuXG4vLyBCQUQgbmFtZSBmb3IgdGhpcyBjbGFzcyBub3cuIHVzZWQgaW4gdGhlIEhlYWRlclxuY2xhc3MgVGFibGVEYXRlQ2VsbCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiwgb3B0aW9ucywgdGhlbWUsIHZpZXdBcGkgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IGRhdGUsIGRhdGVQcm9maWxlIH0gPSBwcm9wcztcbiAgICAgICAgbGV0IGRheU1ldGEgPSBnZXREYXRlTWV0YShkYXRlLCBwcm9wcy50b2RheVJhbmdlLCBudWxsLCBkYXRlUHJvZmlsZSk7XG4gICAgICAgIGxldCBjbGFzc05hbWVzID0gW0NMQVNTX05BTUVdLmNvbmNhdChnZXREYXlDbGFzc05hbWVzKGRheU1ldGEsIHRoZW1lKSk7XG4gICAgICAgIGxldCB0ZXh0ID0gZGF0ZUVudi5mb3JtYXQoZGF0ZSwgcHJvcHMuZGF5SGVhZGVyRm9ybWF0KTtcbiAgICAgICAgLy8gaWYgY29sQ250IGlzIDEsIHdlIGFyZSBhbHJlYWR5IGluIGEgZGF5LXZpZXcgYW5kIGRvbid0IG5lZWQgYSBuYXZsaW5rXG4gICAgICAgIGxldCBuYXZMaW5rQXR0cnMgPSAoIWRheU1ldGEuaXNEaXNhYmxlZCAmJiBwcm9wcy5jb2xDbnQgPiAxKVxuICAgICAgICAgICAgPyBidWlsZE5hdkxpbmtBdHRycyh0aGlzLmNvbnRleHQsIGRhdGUpXG4gICAgICAgICAgICA6IHt9O1xuICAgICAgICBsZXQgcmVuZGVyUHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IGRhdGU6IGRhdGVFbnYudG9EYXRlKGRhdGUpLCB2aWV3OiB2aWV3QXBpIH0sIHByb3BzLmV4dHJhUmVuZGVyUHJvcHMpLCB7IHRleHQgfSksIGRheU1ldGEpO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoQ29udGVudENvbnRhaW5lciwgeyBlbFRhZzogXCJ0aFwiLCBlbENsYXNzZXM6IGNsYXNzTmFtZXMsIGVsQXR0cnM6IE9iamVjdC5hc3NpZ24oeyByb2xlOiAnY29sdW1uaGVhZGVyJywgY29sU3BhbjogcHJvcHMuY29sU3BhbiwgJ2RhdGEtZGF0ZSc6ICFkYXlNZXRhLmlzRGlzYWJsZWQgPyBmb3JtYXREYXlTdHJpbmcoZGF0ZSkgOiB1bmRlZmluZWQgfSwgcHJvcHMuZXh0cmFEYXRhQXR0cnMpLCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGdlbmVyYXRvck5hbWU6IFwiZGF5SGVhZGVyQ29udGVudFwiLCBjdXN0b21HZW5lcmF0b3I6IG9wdGlvbnMuZGF5SGVhZGVyQ29udGVudCwgZGVmYXVsdEdlbmVyYXRvcjogcmVuZGVySW5uZXIkMSwgY2xhc3NOYW1lR2VuZXJhdG9yOiBvcHRpb25zLmRheUhlYWRlckNsYXNzTmFtZXMsIGRpZE1vdW50OiBvcHRpb25zLmRheUhlYWRlckRpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy5kYXlIZWFkZXJXaWxsVW5tb3VudCB9LCAoSW5uZXJDb250YWluZXIpID0+IChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXNjcm9sbGdyaWQtc3luYy1pbm5lclwiIH0sICFkYXlNZXRhLmlzRGlzYWJsZWQgJiYgKGNyZWF0ZUVsZW1lbnQoSW5uZXJDb250YWluZXIsIHsgZWxUYWc6IFwiYVwiLCBlbEF0dHJzOiBuYXZMaW5rQXR0cnMsIGVsQ2xhc3NlczogW1xuICAgICAgICAgICAgICAgICdmYy1jb2wtaGVhZGVyLWNlbGwtY3VzaGlvbicsXG4gICAgICAgICAgICAgICAgcHJvcHMuaXNTdGlja3kgJiYgJ2ZjLXN0aWNreScsXG4gICAgICAgICAgICBdIH0pKSkpKSk7XG4gICAgfVxufVxuXG5jb25zdCBXRUVLREFZX0ZPUk1BVCA9IGNyZWF0ZUZvcm1hdHRlcih7IHdlZWtkYXk6ICdsb25nJyB9KTtcbmNsYXNzIFRhYmxlRG93Q2VsbCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IGRhdGVFbnYsIHRoZW1lLCB2aWV3QXBpLCBvcHRpb25zIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBkYXRlID0gYWRkRGF5cyhuZXcgRGF0ZSgyNTkyMDAwMDApLCBwcm9wcy5kb3cpOyAvLyBzdGFydCB3aXRoIFN1biwgMDQgSmFuIDE5NzAgMDA6MDA6MDAgR01UXG4gICAgICAgIGxldCBkYXRlTWV0YSA9IHtcbiAgICAgICAgICAgIGRvdzogcHJvcHMuZG93LFxuICAgICAgICAgICAgaXNEaXNhYmxlZDogZmFsc2UsXG4gICAgICAgICAgICBpc0Z1dHVyZTogZmFsc2UsXG4gICAgICAgICAgICBpc1Bhc3Q6IGZhbHNlLFxuICAgICAgICAgICAgaXNUb2RheTogZmFsc2UsXG4gICAgICAgICAgICBpc090aGVyOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHRleHQgPSBkYXRlRW52LmZvcm1hdChkYXRlLCBwcm9wcy5kYXlIZWFkZXJGb3JtYXQpO1xuICAgICAgICBsZXQgcmVuZGVyUHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgLy8gVE9ETzogbWFrZSB0aGlzIHB1YmxpYz9cbiAgICAgICAgICAgIGRhdGUgfSwgZGF0ZU1ldGEpLCB7IHZpZXc6IHZpZXdBcGkgfSksIHByb3BzLmV4dHJhUmVuZGVyUHJvcHMpLCB7IHRleHQgfSk7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChDb250ZW50Q29udGFpbmVyLCB7IGVsVGFnOiBcInRoXCIsIGVsQ2xhc3NlczogW1xuICAgICAgICAgICAgICAgIENMQVNTX05BTUUsXG4gICAgICAgICAgICAgICAgLi4uZ2V0RGF5Q2xhc3NOYW1lcyhkYXRlTWV0YSwgdGhlbWUpLFxuICAgICAgICAgICAgICAgIC4uLihwcm9wcy5leHRyYUNsYXNzTmFtZXMgfHwgW10pLFxuICAgICAgICAgICAgXSwgZWxBdHRyczogT2JqZWN0LmFzc2lnbih7IHJvbGU6ICdjb2x1bW5oZWFkZXInLCBjb2xTcGFuOiBwcm9wcy5jb2xTcGFuIH0sIHByb3BzLmV4dHJhRGF0YUF0dHJzKSwgcmVuZGVyUHJvcHM6IHJlbmRlclByb3BzLCBnZW5lcmF0b3JOYW1lOiBcImRheUhlYWRlckNvbnRlbnRcIiwgY3VzdG9tR2VuZXJhdG9yOiBvcHRpb25zLmRheUhlYWRlckNvbnRlbnQsIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlcklubmVyJDEsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy5kYXlIZWFkZXJDbGFzc05hbWVzLCBkaWRNb3VudDogb3B0aW9ucy5kYXlIZWFkZXJEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMuZGF5SGVhZGVyV2lsbFVubW91bnQgfSwgKElubmVyQ29udGVudCkgPT4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtc2Nyb2xsZ3JpZC1zeW5jLWlubmVyXCIgfSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoSW5uZXJDb250ZW50LCB7IGVsVGFnOiBcImFcIiwgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgICAgICdmYy1jb2wtaGVhZGVyLWNlbGwtY3VzaGlvbicsXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLmlzU3RpY2t5ICYmICdmYy1zdGlja3knLFxuICAgICAgICAgICAgICAgIF0sIGVsQXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2FyaWEtbGFiZWwnOiBkYXRlRW52LmZvcm1hdChkYXRlLCBXRUVLREFZX0ZPUk1BVCksXG4gICAgICAgICAgICAgICAgfSB9KSkpKSk7XG4gICAgfVxufVxuXG5jbGFzcyBOb3dUaW1lciBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMsIGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIocHJvcHMsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLmluaXRpYWxOb3dEYXRlID0gZ2V0Tm93KGNvbnRleHQub3B0aW9ucy5ub3csIGNvbnRleHQuZGF0ZUVudik7XG4gICAgICAgIHRoaXMuaW5pdGlhbE5vd1F1ZXJpZWRNcyA9IG5ldyBEYXRlKCkudmFsdWVPZigpO1xuICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5jb21wdXRlVGltaW5nKCkuY3VycmVudFN0YXRlO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBzdGF0ZSB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHByb3BzLmNoaWxkcmVuKHN0YXRlLm5vd0RhdGUsIHN0YXRlLnRvZGF5UmFuZ2UpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5zZXRUaW1lb3V0KCk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgICAgaWYgKHByZXZQcm9wcy51bml0ICE9PSB0aGlzLnByb3BzLnVuaXQpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJUaW1lb3V0KCk7XG4gICAgICAgICAgICB0aGlzLnNldFRpbWVvdXQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgICB9XG4gICAgY29tcHV0ZVRpbWluZygpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCB1bnJvdW5kZWROb3cgPSBhZGRNcyh0aGlzLmluaXRpYWxOb3dEYXRlLCBuZXcgRGF0ZSgpLnZhbHVlT2YoKSAtIHRoaXMuaW5pdGlhbE5vd1F1ZXJpZWRNcyk7XG4gICAgICAgIGxldCBjdXJyZW50VW5pdFN0YXJ0ID0gY29udGV4dC5kYXRlRW52LnN0YXJ0T2YodW5yb3VuZGVkTm93LCBwcm9wcy51bml0KTtcbiAgICAgICAgbGV0IG5leHRVbml0U3RhcnQgPSBjb250ZXh0LmRhdGVFbnYuYWRkKGN1cnJlbnRVbml0U3RhcnQsIGNyZWF0ZUR1cmF0aW9uKDEsIHByb3BzLnVuaXQpKTtcbiAgICAgICAgbGV0IHdhaXRNcyA9IG5leHRVbml0U3RhcnQudmFsdWVPZigpIC0gdW5yb3VuZGVkTm93LnZhbHVlT2YoKTtcbiAgICAgICAgLy8gdGhlcmUgaXMgYSBtYXggc2V0VGltZW91dCBtcyB2YWx1ZSAoaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM0Njg2NTAvOTYzNDIpXG4gICAgICAgIC8vIGVuc3VyZSBubyBsb25nZXIgdGhhbiBhIGRheVxuICAgICAgICB3YWl0TXMgPSBNYXRoLm1pbigxMDAwICogNjAgKiA2MCAqIDI0LCB3YWl0TXMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3VycmVudFN0YXRlOiB7IG5vd0RhdGU6IGN1cnJlbnRVbml0U3RhcnQsIHRvZGF5UmFuZ2U6IGJ1aWxkRGF5UmFuZ2UoY3VycmVudFVuaXRTdGFydCkgfSxcbiAgICAgICAgICAgIG5leHRTdGF0ZTogeyBub3dEYXRlOiBuZXh0VW5pdFN0YXJ0LCB0b2RheVJhbmdlOiBidWlsZERheVJhbmdlKG5leHRVbml0U3RhcnQpIH0sXG4gICAgICAgICAgICB3YWl0TXMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHNldFRpbWVvdXQoKSB7XG4gICAgICAgIGxldCB7IG5leHRTdGF0ZSwgd2FpdE1zIH0gPSB0aGlzLmNvbXB1dGVUaW1pbmcoKTtcbiAgICAgICAgdGhpcy50aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUobmV4dFN0YXRlLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRUaW1lb3V0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgd2FpdE1zKTtcbiAgICB9XG4gICAgY2xlYXJUaW1lb3V0KCkge1xuICAgICAgICBpZiAodGhpcy50aW1lb3V0SWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5Ob3dUaW1lci5jb250ZXh0VHlwZSA9IFZpZXdDb250ZXh0VHlwZTtcbmZ1bmN0aW9uIGJ1aWxkRGF5UmFuZ2UoZGF0ZSkge1xuICAgIGxldCBzdGFydCA9IHN0YXJ0T2ZEYXkoZGF0ZSk7XG4gICAgbGV0IGVuZCA9IGFkZERheXMoc3RhcnQsIDEpO1xuICAgIHJldHVybiB7IHN0YXJ0LCBlbmQgfTtcbn1cblxuY2xhc3MgRGF5SGVhZGVyIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuY3JlYXRlRGF5SGVhZGVyRm9ybWF0dGVyID0gbWVtb2l6ZShjcmVhdGVEYXlIZWFkZXJGb3JtYXR0ZXIpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IGRhdGVzLCBkYXRlUHJvZmlsZSwgZGF0ZXNSZXBEaXN0aW5jdERheXMsIHJlbmRlckludHJvIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBsZXQgZGF5SGVhZGVyRm9ybWF0ID0gdGhpcy5jcmVhdGVEYXlIZWFkZXJGb3JtYXR0ZXIoY29udGV4dC5vcHRpb25zLmRheUhlYWRlckZvcm1hdCwgZGF0ZXNSZXBEaXN0aW5jdERheXMsIGRhdGVzLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChOb3dUaW1lciwgeyB1bml0OiBcImRheVwiIH0sIChub3dEYXRlLCB0b2RheVJhbmdlKSA9PiAoY3JlYXRlRWxlbWVudChcInRyXCIsIHsgcm9sZTogXCJyb3dcIiB9LFxuICAgICAgICAgICAgcmVuZGVySW50cm8gJiYgcmVuZGVySW50cm8oJ2RheScpLFxuICAgICAgICAgICAgZGF0ZXMubWFwKChkYXRlKSA9PiAoZGF0ZXNSZXBEaXN0aW5jdERheXMgPyAoY3JlYXRlRWxlbWVudChUYWJsZURhdGVDZWxsLCB7IGtleTogZGF0ZS50b0lTT1N0cmluZygpLCBkYXRlOiBkYXRlLCBkYXRlUHJvZmlsZTogZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2U6IHRvZGF5UmFuZ2UsIGNvbENudDogZGF0ZXMubGVuZ3RoLCBkYXlIZWFkZXJGb3JtYXQ6IGRheUhlYWRlckZvcm1hdCB9KSkgOiAoY3JlYXRlRWxlbWVudChUYWJsZURvd0NlbGwsIHsga2V5OiBkYXRlLmdldFVUQ0RheSgpLCBkb3c6IGRhdGUuZ2V0VVRDRGF5KCksIGRheUhlYWRlckZvcm1hdDogZGF5SGVhZGVyRm9ybWF0IH0pKSkpKSkpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVEYXlIZWFkZXJGb3JtYXR0ZXIoZXhwbGljaXRGb3JtYXQsIGRhdGVzUmVwRGlzdGluY3REYXlzLCBkYXRlQ250KSB7XG4gICAgcmV0dXJuIGV4cGxpY2l0Rm9ybWF0IHx8IGNvbXB1dGVGYWxsYmFja0hlYWRlckZvcm1hdChkYXRlc1JlcERpc3RpbmN0RGF5cywgZGF0ZUNudCk7XG59XG5cbmNsYXNzIERheVNlcmllc01vZGVsIHtcbiAgICBjb25zdHJ1Y3RvcihyYW5nZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IpIHtcbiAgICAgICAgbGV0IGRhdGUgPSByYW5nZS5zdGFydDtcbiAgICAgICAgbGV0IHsgZW5kIH0gPSByYW5nZTtcbiAgICAgICAgbGV0IGluZGljZXMgPSBbXTtcbiAgICAgICAgbGV0IGRhdGVzID0gW107XG4gICAgICAgIGxldCBkYXlJbmRleCA9IC0xO1xuICAgICAgICB3aGlsZSAoZGF0ZSA8IGVuZCkgeyAvLyBsb29wIGVhY2ggZGF5IGZyb20gc3RhcnQgdG8gZW5kXG4gICAgICAgICAgICBpZiAoZGF0ZVByb2ZpbGVHZW5lcmF0b3IuaXNIaWRkZW5EYXkoZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2goZGF5SW5kZXggKyAwLjUpOyAvLyBtYXJrIHRoYXQgaXQncyBiZXR3ZWVuIGluZGljZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRheUluZGV4ICs9IDE7XG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGRheUluZGV4KTtcbiAgICAgICAgICAgICAgICBkYXRlcy5wdXNoKGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0ZSA9IGFkZERheXMoZGF0ZSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRlcyA9IGRhdGVzO1xuICAgICAgICB0aGlzLmluZGljZXMgPSBpbmRpY2VzO1xuICAgICAgICB0aGlzLmNudCA9IGRhdGVzLmxlbmd0aDtcbiAgICB9XG4gICAgc2xpY2VSYW5nZShyYW5nZSkge1xuICAgICAgICBsZXQgZmlyc3RJbmRleCA9IHRoaXMuZ2V0RGF0ZURheUluZGV4KHJhbmdlLnN0YXJ0KTsgLy8gaW5jbHVzaXZlIGZpcnN0IGluZGV4XG4gICAgICAgIGxldCBsYXN0SW5kZXggPSB0aGlzLmdldERhdGVEYXlJbmRleChhZGREYXlzKHJhbmdlLmVuZCwgLTEpKTsgLy8gaW5jbHVzaXZlIGxhc3QgaW5kZXhcbiAgICAgICAgbGV0IGNsaXBwZWRGaXJzdEluZGV4ID0gTWF0aC5tYXgoMCwgZmlyc3RJbmRleCk7XG4gICAgICAgIGxldCBjbGlwcGVkTGFzdEluZGV4ID0gTWF0aC5taW4odGhpcy5jbnQgLSAxLCBsYXN0SW5kZXgpO1xuICAgICAgICAvLyBkZWFsIHdpdGggaW4tYmV0d2VlbiBpbmRpY2VzXG4gICAgICAgIGNsaXBwZWRGaXJzdEluZGV4ID0gTWF0aC5jZWlsKGNsaXBwZWRGaXJzdEluZGV4KTsgLy8gaW4tYmV0d2VlbiBzdGFydHMgcm91bmQgdG8gbmV4dCBjZWxsXG4gICAgICAgIGNsaXBwZWRMYXN0SW5kZXggPSBNYXRoLmZsb29yKGNsaXBwZWRMYXN0SW5kZXgpOyAvLyBpbi1iZXR3ZWVuIGVuZHMgcm91bmQgdG8gcHJldiBjZWxsXG4gICAgICAgIGlmIChjbGlwcGVkRmlyc3RJbmRleCA8PSBjbGlwcGVkTGFzdEluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZpcnN0SW5kZXg6IGNsaXBwZWRGaXJzdEluZGV4LFxuICAgICAgICAgICAgICAgIGxhc3RJbmRleDogY2xpcHBlZExhc3RJbmRleCxcbiAgICAgICAgICAgICAgICBpc1N0YXJ0OiBmaXJzdEluZGV4ID09PSBjbGlwcGVkRmlyc3RJbmRleCxcbiAgICAgICAgICAgICAgICBpc0VuZDogbGFzdEluZGV4ID09PSBjbGlwcGVkTGFzdEluZGV4LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gR2l2ZW4gYSBkYXRlLCByZXR1cm5zIGl0cyBjaHJvbm9sb2NpYWwgY2VsbC1pbmRleCBmcm9tIHRoZSBmaXJzdCBjZWxsIG9mIHRoZSBncmlkLlxuICAgIC8vIElmIHRoZSBkYXRlIGxpZXMgYmV0d2VlbiBjZWxscyAoYmVjYXVzZSBvZiBoaWRkZW5EYXlzKSwgcmV0dXJucyBhIGZsb2F0aW5nLXBvaW50IHZhbHVlIGJldHdlZW4gb2Zmc2V0cy5cbiAgICAvLyBJZiBiZWZvcmUgdGhlIGZpcnN0IG9mZnNldCwgcmV0dXJucyBhIG5lZ2F0aXZlIG51bWJlci5cbiAgICAvLyBJZiBhZnRlciB0aGUgbGFzdCBvZmZzZXQsIHJldHVybnMgYW4gb2Zmc2V0IHBhc3QgdGhlIGxhc3QgY2VsbCBvZmZzZXQuXG4gICAgLy8gT25seSB3b3JrcyBmb3IgKnN0YXJ0KiBkYXRlcyBvZiBjZWxscy4gV2lsbCBub3Qgd29yayBmb3IgZXhjbHVzaXZlIGVuZCBkYXRlcyBmb3IgY2VsbHMuXG4gICAgZ2V0RGF0ZURheUluZGV4KGRhdGUpIHtcbiAgICAgICAgbGV0IHsgaW5kaWNlcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGRheU9mZnNldCA9IE1hdGguZmxvb3IoZGlmZkRheXModGhpcy5kYXRlc1swXSwgZGF0ZSkpO1xuICAgICAgICBpZiAoZGF5T2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIGluZGljZXNbMF0gLSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXlPZmZzZXQgPj0gaW5kaWNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmRpY2VzW2luZGljZXMubGVuZ3RoIC0gMV0gKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRpY2VzW2RheU9mZnNldF07XG4gICAgfVxufVxuXG5jbGFzcyBEYXlUYWJsZU1vZGVsIHtcbiAgICBjb25zdHJ1Y3RvcihkYXlTZXJpZXMsIGJyZWFrT25XZWVrcykge1xuICAgICAgICBsZXQgeyBkYXRlcyB9ID0gZGF5U2VyaWVzO1xuICAgICAgICBsZXQgZGF5c1BlclJvdztcbiAgICAgICAgbGV0IGZpcnN0RGF5O1xuICAgICAgICBsZXQgcm93Q250O1xuICAgICAgICBpZiAoYnJlYWtPbldlZWtzKSB7XG4gICAgICAgICAgICAvLyBjb3VudCBjb2x1bW5zIHVudGlsIHRoZSBkYXktb2Ytd2VlayByZXBlYXRzXG4gICAgICAgICAgICBmaXJzdERheSA9IGRhdGVzWzBdLmdldFVUQ0RheSgpO1xuICAgICAgICAgICAgZm9yIChkYXlzUGVyUm93ID0gMTsgZGF5c1BlclJvdyA8IGRhdGVzLmxlbmd0aDsgZGF5c1BlclJvdyArPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGVzW2RheXNQZXJSb3ddLmdldFVUQ0RheSgpID09PSBmaXJzdERheSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3dDbnQgPSBNYXRoLmNlaWwoZGF0ZXMubGVuZ3RoIC8gZGF5c1BlclJvdyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByb3dDbnQgPSAxO1xuICAgICAgICAgICAgZGF5c1BlclJvdyA9IGRhdGVzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJvd0NudCA9IHJvd0NudDtcbiAgICAgICAgdGhpcy5jb2xDbnQgPSBkYXlzUGVyUm93O1xuICAgICAgICB0aGlzLmRheVNlcmllcyA9IGRheVNlcmllcztcbiAgICAgICAgdGhpcy5jZWxscyA9IHRoaXMuYnVpbGRDZWxscygpO1xuICAgICAgICB0aGlzLmhlYWRlckRhdGVzID0gdGhpcy5idWlsZEhlYWRlckRhdGVzKCk7XG4gICAgfVxuICAgIGJ1aWxkQ2VsbHMoKSB7XG4gICAgICAgIGxldCByb3dzID0gW107XG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHRoaXMucm93Q250OyByb3cgKz0gMSkge1xuICAgICAgICAgICAgbGV0IGNlbGxzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCB0aGlzLmNvbENudDsgY29sICs9IDEpIHtcbiAgICAgICAgICAgICAgICBjZWxscy5wdXNoKHRoaXMuYnVpbGRDZWxsKHJvdywgY29sKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3dzLnB1c2goY2VsbHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3dzO1xuICAgIH1cbiAgICBidWlsZENlbGwocm93LCBjb2wpIHtcbiAgICAgICAgbGV0IGRhdGUgPSB0aGlzLmRheVNlcmllcy5kYXRlc1tyb3cgKiB0aGlzLmNvbENudCArIGNvbF07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrZXk6IGRhdGUudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIGRhdGUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGJ1aWxkSGVhZGVyRGF0ZXMoKSB7XG4gICAgICAgIGxldCBkYXRlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCB0aGlzLmNvbENudDsgY29sICs9IDEpIHtcbiAgICAgICAgICAgIGRhdGVzLnB1c2godGhpcy5jZWxsc1swXVtjb2xdLmRhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlcztcbiAgICB9XG4gICAgc2xpY2VSYW5nZShyYW5nZSkge1xuICAgICAgICBsZXQgeyBjb2xDbnQgfSA9IHRoaXM7XG4gICAgICAgIGxldCBzZXJpZXNTZWcgPSB0aGlzLmRheVNlcmllcy5zbGljZVJhbmdlKHJhbmdlKTtcbiAgICAgICAgbGV0IHNlZ3MgPSBbXTtcbiAgICAgICAgaWYgKHNlcmllc1NlZykge1xuICAgICAgICAgICAgbGV0IHsgZmlyc3RJbmRleCwgbGFzdEluZGV4IH0gPSBzZXJpZXNTZWc7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSBmaXJzdEluZGV4O1xuICAgICAgICAgICAgd2hpbGUgKGluZGV4IDw9IGxhc3RJbmRleCkge1xuICAgICAgICAgICAgICAgIGxldCByb3cgPSBNYXRoLmZsb29yKGluZGV4IC8gY29sQ250KTtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dEluZGV4ID0gTWF0aC5taW4oKHJvdyArIDEpICogY29sQ250LCBsYXN0SW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICBzZWdzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICByb3csXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0Q29sOiBpbmRleCAlIGNvbENudCxcbiAgICAgICAgICAgICAgICAgICAgbGFzdENvbDogKG5leHRJbmRleCAtIDEpICUgY29sQ250LFxuICAgICAgICAgICAgICAgICAgICBpc1N0YXJ0OiBzZXJpZXNTZWcuaXNTdGFydCAmJiBpbmRleCA9PT0gZmlyc3RJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgaXNFbmQ6IHNlcmllc1NlZy5pc0VuZCAmJiAobmV4dEluZGV4IC0gMSkgPT09IGxhc3RJbmRleCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpbmRleCA9IG5leHRJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VncztcbiAgICB9XG59XG5cbmNsYXNzIFNsaWNlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc2xpY2VCdXNpbmVzc0hvdXJzID0gbWVtb2l6ZSh0aGlzLl9zbGljZUJ1c2luZXNzSG91cnMpO1xuICAgICAgICB0aGlzLnNsaWNlRGF0ZVNlbGVjdGlvbiA9IG1lbW9pemUodGhpcy5fc2xpY2VEYXRlU3Bhbik7XG4gICAgICAgIHRoaXMuc2xpY2VFdmVudFN0b3JlID0gbWVtb2l6ZSh0aGlzLl9zbGljZUV2ZW50U3RvcmUpO1xuICAgICAgICB0aGlzLnNsaWNlRXZlbnREcmFnID0gbWVtb2l6ZSh0aGlzLl9zbGljZUludGVyYWN0aW9uKTtcbiAgICAgICAgdGhpcy5zbGljZUV2ZW50UmVzaXplID0gbWVtb2l6ZSh0aGlzLl9zbGljZUludGVyYWN0aW9uKTtcbiAgICAgICAgdGhpcy5mb3JjZURheUlmTGlzdEl0ZW0gPSBmYWxzZTsgLy8gaGFja1xuICAgIH1cbiAgICBzbGljZVByb3BzKHByb3BzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgY29udGV4dCwgLi4uZXh0cmFBcmdzKSB7XG4gICAgICAgIGxldCB7IGV2ZW50VWlCYXNlcyB9ID0gcHJvcHM7XG4gICAgICAgIGxldCBldmVudFNlZ3MgPSB0aGlzLnNsaWNlRXZlbnRTdG9yZShwcm9wcy5ldmVudFN0b3JlLCBldmVudFVpQmFzZXMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCAuLi5leHRyYUFyZ3MpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0ZVNlbGVjdGlvblNlZ3M6IHRoaXMuc2xpY2VEYXRlU2VsZWN0aW9uKHByb3BzLmRhdGVTZWxlY3Rpb24sIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCBldmVudFVpQmFzZXMsIGNvbnRleHQsIC4uLmV4dHJhQXJncyksXG4gICAgICAgICAgICBidXNpbmVzc0hvdXJTZWdzOiB0aGlzLnNsaWNlQnVzaW5lc3NIb3Vycyhwcm9wcy5idXNpbmVzc0hvdXJzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgY29udGV4dCwgLi4uZXh0cmFBcmdzKSxcbiAgICAgICAgICAgIGZnRXZlbnRTZWdzOiBldmVudFNlZ3MuZmcsXG4gICAgICAgICAgICBiZ0V2ZW50U2VnczogZXZlbnRTZWdzLmJnLFxuICAgICAgICAgICAgZXZlbnREcmFnOiB0aGlzLnNsaWNlRXZlbnREcmFnKHByb3BzLmV2ZW50RHJhZywgZXZlbnRVaUJhc2VzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgLi4uZXh0cmFBcmdzKSxcbiAgICAgICAgICAgIGV2ZW50UmVzaXplOiB0aGlzLnNsaWNlRXZlbnRSZXNpemUocHJvcHMuZXZlbnRSZXNpemUsIGV2ZW50VWlCYXNlcywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIC4uLmV4dHJhQXJncyksXG4gICAgICAgICAgICBldmVudFNlbGVjdGlvbjogcHJvcHMuZXZlbnRTZWxlY3Rpb24sXG4gICAgICAgIH07IC8vIFRPRE86IGdpdmUgaW50ZXJhY3Rpb25TZWdzP1xuICAgIH1cbiAgICBzbGljZU5vd0RhdGUoLy8gZG9lcyBub3QgbWVtb2l6ZVxuICAgIGRhdGUsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCBjb250ZXh0LCAuLi5leHRyYUFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NsaWNlRGF0ZVNwYW4oeyByYW5nZTogeyBzdGFydDogZGF0ZSwgZW5kOiBhZGRNcyhkYXRlLCAxKSB9LCBhbGxEYXk6IGZhbHNlIH0sIC8vIGFkZCAxIG1zLCBwcm90ZWN0IGFnYWluc3QgbnVsbCByYW5nZVxuICAgICAgICBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwge30sIGNvbnRleHQsIC4uLmV4dHJhQXJncyk7XG4gICAgfVxuICAgIF9zbGljZUJ1c2luZXNzSG91cnMoYnVzaW5lc3NIb3VycywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIGNvbnRleHQsIC4uLmV4dHJhQXJncykge1xuICAgICAgICBpZiAoIWJ1c2luZXNzSG91cnMpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc2xpY2VFdmVudFN0b3JlKGV4cGFuZFJlY3VycmluZyhidXNpbmVzc0hvdXJzLCBjb21wdXRlQWN0aXZlUmFuZ2UoZGF0ZVByb2ZpbGUsIEJvb2xlYW4obmV4dERheVRocmVzaG9sZCkpLCBjb250ZXh0KSwge30sIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCAuLi5leHRyYUFyZ3MpLmJnO1xuICAgIH1cbiAgICBfc2xpY2VFdmVudFN0b3JlKGV2ZW50U3RvcmUsIGV2ZW50VWlCYXNlcywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIC4uLmV4dHJhQXJncykge1xuICAgICAgICBpZiAoZXZlbnRTdG9yZSkge1xuICAgICAgICAgICAgbGV0IHJhbmdlUmVzID0gc2xpY2VFdmVudFN0b3JlKGV2ZW50U3RvcmUsIGV2ZW50VWlCYXNlcywgY29tcHV0ZUFjdGl2ZVJhbmdlKGRhdGVQcm9maWxlLCBCb29sZWFuKG5leHREYXlUaHJlc2hvbGQpKSwgbmV4dERheVRocmVzaG9sZCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJnOiB0aGlzLnNsaWNlRXZlbnRSYW5nZXMocmFuZ2VSZXMuYmcsIGV4dHJhQXJncyksXG4gICAgICAgICAgICAgICAgZmc6IHRoaXMuc2xpY2VFdmVudFJhbmdlcyhyYW5nZVJlcy5mZywgZXh0cmFBcmdzKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgYmc6IFtdLCBmZzogW10gfTtcbiAgICB9XG4gICAgX3NsaWNlSW50ZXJhY3Rpb24oaW50ZXJhY3Rpb24sIGV2ZW50VWlCYXNlcywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIC4uLmV4dHJhQXJncykge1xuICAgICAgICBpZiAoIWludGVyYWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmFuZ2VSZXMgPSBzbGljZUV2ZW50U3RvcmUoaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cywgZXZlbnRVaUJhc2VzLCBjb21wdXRlQWN0aXZlUmFuZ2UoZGF0ZVByb2ZpbGUsIEJvb2xlYW4obmV4dERheVRocmVzaG9sZCkpLCBuZXh0RGF5VGhyZXNob2xkKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNlZ3M6IHRoaXMuc2xpY2VFdmVudFJhbmdlcyhyYW5nZVJlcy5mZywgZXh0cmFBcmdzKSxcbiAgICAgICAgICAgIGFmZmVjdGVkSW5zdGFuY2VzOiBpbnRlcmFjdGlvbi5hZmZlY3RlZEV2ZW50cy5pbnN0YW5jZXMsXG4gICAgICAgICAgICBpc0V2ZW50OiBpbnRlcmFjdGlvbi5pc0V2ZW50LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfc2xpY2VEYXRlU3BhbihkYXRlU3BhbiwgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIGV2ZW50VWlCYXNlcywgY29udGV4dCwgLi4uZXh0cmFBcmdzKSB7XG4gICAgICAgIGlmICghZGF0ZVNwYW4pIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYWN0aXZlUmFuZ2UgPSBjb21wdXRlQWN0aXZlUmFuZ2UoZGF0ZVByb2ZpbGUsIEJvb2xlYW4obmV4dERheVRocmVzaG9sZCkpO1xuICAgICAgICBsZXQgYWN0aXZlRGF0ZVNwYW5SYW5nZSA9IGludGVyc2VjdFJhbmdlcyhkYXRlU3Bhbi5yYW5nZSwgYWN0aXZlUmFuZ2UpO1xuICAgICAgICBpZiAoYWN0aXZlRGF0ZVNwYW5SYW5nZSkge1xuICAgICAgICAgICAgZGF0ZVNwYW4gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRhdGVTcGFuKSwgeyByYW5nZTogYWN0aXZlRGF0ZVNwYW5SYW5nZSB9KTtcbiAgICAgICAgICAgIGxldCBldmVudFJhbmdlID0gZmFicmljYXRlRXZlbnRSYW5nZShkYXRlU3BhbiwgZXZlbnRVaUJhc2VzLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGxldCBzZWdzID0gdGhpcy5zbGljZVJhbmdlKGRhdGVTcGFuLnJhbmdlLCAuLi5leHRyYUFyZ3MpO1xuICAgICAgICAgICAgZm9yIChsZXQgc2VnIG9mIHNlZ3MpIHtcbiAgICAgICAgICAgICAgICBzZWcuZXZlbnRSYW5nZSA9IGV2ZW50UmFuZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2VncztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIC8qXG4gICAgXCJjb21wbGV0ZVwiIHNlZyBtZWFucyBpdCBoYXMgY29tcG9uZW50IGFuZCBldmVudFJhbmdlXG4gICAgKi9cbiAgICBzbGljZUV2ZW50UmFuZ2VzKGV2ZW50UmFuZ2VzLCBleHRyYUFyZ3MpIHtcbiAgICAgICAgbGV0IHNlZ3MgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZXZlbnRSYW5nZSBvZiBldmVudFJhbmdlcykge1xuICAgICAgICAgICAgc2Vncy5wdXNoKC4uLnRoaXMuc2xpY2VFdmVudFJhbmdlKGV2ZW50UmFuZ2UsIGV4dHJhQXJncykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWdzO1xuICAgIH1cbiAgICAvKlxuICAgIFwiY29tcGxldGVcIiBzZWcgbWVhbnMgaXQgaGFzIGNvbXBvbmVudCBhbmQgZXZlbnRSYW5nZVxuICAgICovXG4gICAgc2xpY2VFdmVudFJhbmdlKGV2ZW50UmFuZ2UsIGV4dHJhQXJncykge1xuICAgICAgICBsZXQgZGF0ZVJhbmdlID0gZXZlbnRSYW5nZS5yYW5nZTtcbiAgICAgICAgLy8gaGFjayB0byBtYWtlIG11bHRpLWRheSBldmVudHMgdGhhdCBhcmUgYmVpbmcgZm9yY2UtZGlzcGxheWVkIGFzIGxpc3QtaXRlbXMgdG8gdGFrZSB1cCBvbmx5IG9uZSBkYXlcbiAgICAgICAgaWYgKHRoaXMuZm9yY2VEYXlJZkxpc3RJdGVtICYmIGV2ZW50UmFuZ2UudWkuZGlzcGxheSA9PT0gJ2xpc3QtaXRlbScpIHtcbiAgICAgICAgICAgIGRhdGVSYW5nZSA9IHtcbiAgICAgICAgICAgICAgICBzdGFydDogZGF0ZVJhbmdlLnN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZDogYWRkRGF5cyhkYXRlUmFuZ2Uuc3RhcnQsIDEpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2VncyA9IHRoaXMuc2xpY2VSYW5nZShkYXRlUmFuZ2UsIC4uLmV4dHJhQXJncyk7XG4gICAgICAgIGZvciAobGV0IHNlZyBvZiBzZWdzKSB7XG4gICAgICAgICAgICBzZWcuZXZlbnRSYW5nZSA9IGV2ZW50UmFuZ2U7XG4gICAgICAgICAgICBzZWcuaXNTdGFydCA9IGV2ZW50UmFuZ2UuaXNTdGFydCAmJiBzZWcuaXNTdGFydDtcbiAgICAgICAgICAgIHNlZy5pc0VuZCA9IGV2ZW50UmFuZ2UuaXNFbmQgJiYgc2VnLmlzRW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWdzO1xuICAgIH1cbn1cbi8qXG5mb3IgaW5jb3Jwb3JhdGluZyBzbG90TWluVGltZS9zbG90TWF4VGltZSBpZiBhcHByb3ByaWF0ZVxuVE9ETzogc2hvdWxkIGJlIHBhcnQgb2YgRGF0ZVByb2ZpbGUhXG5UaW1lbGluZURhdGVQcm9maWxlIGFscmVhZHkgZG9lcyB0aGlzIGJ0d1xuKi9cbmZ1bmN0aW9uIGNvbXB1dGVBY3RpdmVSYW5nZShkYXRlUHJvZmlsZSwgaXNDb21wb25lbnRBbGxEYXkpIHtcbiAgICBsZXQgcmFuZ2UgPSBkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZTtcbiAgICBpZiAoaXNDb21wb25lbnRBbGxEYXkpIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogYWRkTXMocmFuZ2Uuc3RhcnQsIGRhdGVQcm9maWxlLnNsb3RNaW5UaW1lLm1pbGxpc2Vjb25kcyksXG4gICAgICAgIGVuZDogYWRkTXMocmFuZ2UuZW5kLCBkYXRlUHJvZmlsZS5zbG90TWF4VGltZS5taWxsaXNlY29uZHMgLSA4NjRlNSksIC8vIDg2NGU1ID0gbXMgaW4gYSBkYXlcbiAgICB9O1xufVxuXG4vLyBoaWdoLWxldmVsIHNlZ21lbnRpbmctYXdhcmUgdGVzdGVyIGZ1bmN0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBpc0ludGVyYWN0aW9uVmFsaWQoaW50ZXJhY3Rpb24sIGRhdGVQcm9maWxlLCBjb250ZXh0KSB7XG4gICAgbGV0IHsgaW5zdGFuY2VzIH0gPSBpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzO1xuICAgIGZvciAobGV0IGluc3RhbmNlSWQgaW4gaW5zdGFuY2VzKSB7XG4gICAgICAgIGlmICghcmFuZ2VDb250YWluc1JhbmdlKGRhdGVQcm9maWxlLnZhbGlkUmFuZ2UsIGluc3RhbmNlc1tpbnN0YW5jZUlkXS5yYW5nZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaXNOZXdQcm9wc1ZhbGlkKHsgZXZlbnREcmFnOiBpbnRlcmFjdGlvbiB9LCBjb250ZXh0KTsgLy8gSEFDSzogdGhlIGV2ZW50RHJhZyBwcm9wcyBpcyB1c2VkIGZvciBBTEwgaW50ZXJhY3Rpb25zXG59XG5mdW5jdGlvbiBpc0RhdGVTZWxlY3Rpb25WYWxpZChkYXRlU2VsZWN0aW9uLCBkYXRlUHJvZmlsZSwgY29udGV4dCkge1xuICAgIGlmICghcmFuZ2VDb250YWluc1JhbmdlKGRhdGVQcm9maWxlLnZhbGlkUmFuZ2UsIGRhdGVTZWxlY3Rpb24ucmFuZ2UpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzTmV3UHJvcHNWYWxpZCh7IGRhdGVTZWxlY3Rpb24gfSwgY29udGV4dCk7XG59XG5mdW5jdGlvbiBpc05ld1Byb3BzVmFsaWQobmV3UHJvcHMsIGNvbnRleHQpIHtcbiAgICBsZXQgY2FsZW5kYXJTdGF0ZSA9IGNvbnRleHQuZ2V0Q3VycmVudERhdGEoKTtcbiAgICBsZXQgcHJvcHMgPSBPYmplY3QuYXNzaWduKHsgYnVzaW5lc3NIb3VyczogY2FsZW5kYXJTdGF0ZS5idXNpbmVzc0hvdXJzLCBkYXRlU2VsZWN0aW9uOiAnJywgZXZlbnRTdG9yZTogY2FsZW5kYXJTdGF0ZS5ldmVudFN0b3JlLCBldmVudFVpQmFzZXM6IGNhbGVuZGFyU3RhdGUuZXZlbnRVaUJhc2VzLCBldmVudFNlbGVjdGlvbjogJycsIGV2ZW50RHJhZzogbnVsbCwgZXZlbnRSZXNpemU6IG51bGwgfSwgbmV3UHJvcHMpO1xuICAgIHJldHVybiAoY29udGV4dC5wbHVnaW5Ib29rcy5pc1Byb3BzVmFsaWQgfHwgaXNQcm9wc1ZhbGlkKShwcm9wcywgY29udGV4dCk7XG59XG5mdW5jdGlvbiBpc1Byb3BzVmFsaWQoc3RhdGUsIGNvbnRleHQsIGRhdGVTcGFuTWV0YSA9IHt9LCBmaWx0ZXJDb25maWcpIHtcbiAgICBpZiAoc3RhdGUuZXZlbnREcmFnICYmICFpc0ludGVyYWN0aW9uUHJvcHNWYWxpZChzdGF0ZSwgY29udGV4dCwgZGF0ZVNwYW5NZXRhLCBmaWx0ZXJDb25maWcpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLmRhdGVTZWxlY3Rpb24gJiYgIWlzRGF0ZVNlbGVjdGlvblByb3BzVmFsaWQoc3RhdGUsIGNvbnRleHQsIGRhdGVTcGFuTWV0YSwgZmlsdGVyQ29uZmlnKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLy8gTW92aW5nIEV2ZW50IFZhbGlkYXRpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gaXNJbnRlcmFjdGlvblByb3BzVmFsaWQoc3RhdGUsIGNvbnRleHQsIGRhdGVTcGFuTWV0YSwgZmlsdGVyQ29uZmlnKSB7XG4gICAgbGV0IGN1cnJlbnRTdGF0ZSA9IGNvbnRleHQuZ2V0Q3VycmVudERhdGEoKTtcbiAgICBsZXQgaW50ZXJhY3Rpb24gPSBzdGF0ZS5ldmVudERyYWc7IC8vIEhBQ0s6IHRoZSBldmVudERyYWcgcHJvcHMgaXMgdXNlZCBmb3IgQUxMIGludGVyYWN0aW9uc1xuICAgIGxldCBzdWJqZWN0RXZlbnRTdG9yZSA9IGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHM7XG4gICAgbGV0IHN1YmplY3REZWZzID0gc3ViamVjdEV2ZW50U3RvcmUuZGVmcztcbiAgICBsZXQgc3ViamVjdEluc3RhbmNlcyA9IHN1YmplY3RFdmVudFN0b3JlLmluc3RhbmNlcztcbiAgICBsZXQgc3ViamVjdENvbmZpZ3MgPSBjb21waWxlRXZlbnRVaXMoc3ViamVjdERlZnMsIGludGVyYWN0aW9uLmlzRXZlbnQgP1xuICAgICAgICBzdGF0ZS5ldmVudFVpQmFzZXMgOlxuICAgICAgICB7ICcnOiBjdXJyZW50U3RhdGUuc2VsZWN0aW9uQ29uZmlnIH0pO1xuICAgIGlmIChmaWx0ZXJDb25maWcpIHtcbiAgICAgICAgc3ViamVjdENvbmZpZ3MgPSBtYXBIYXNoKHN1YmplY3RDb25maWdzLCBmaWx0ZXJDb25maWcpO1xuICAgIH1cbiAgICAvLyBleGNsdWRlIHRoZSBzdWJqZWN0IGV2ZW50cy4gVE9ETzogZXhjbHVkZSBkZWZzIHRvbz9cbiAgICBsZXQgb3RoZXJFdmVudFN0b3JlID0gZXhjbHVkZUluc3RhbmNlcyhzdGF0ZS5ldmVudFN0b3JlLCBpbnRlcmFjdGlvbi5hZmZlY3RlZEV2ZW50cy5pbnN0YW5jZXMpO1xuICAgIGxldCBvdGhlckRlZnMgPSBvdGhlckV2ZW50U3RvcmUuZGVmcztcbiAgICBsZXQgb3RoZXJJbnN0YW5jZXMgPSBvdGhlckV2ZW50U3RvcmUuaW5zdGFuY2VzO1xuICAgIGxldCBvdGhlckNvbmZpZ3MgPSBjb21waWxlRXZlbnRVaXMob3RoZXJEZWZzLCBzdGF0ZS5ldmVudFVpQmFzZXMpO1xuICAgIGZvciAobGV0IHN1YmplY3RJbnN0YW5jZUlkIGluIHN1YmplY3RJbnN0YW5jZXMpIHtcbiAgICAgICAgbGV0IHN1YmplY3RJbnN0YW5jZSA9IHN1YmplY3RJbnN0YW5jZXNbc3ViamVjdEluc3RhbmNlSWRdO1xuICAgICAgICBsZXQgc3ViamVjdFJhbmdlID0gc3ViamVjdEluc3RhbmNlLnJhbmdlO1xuICAgICAgICBsZXQgc3ViamVjdENvbmZpZyA9IHN1YmplY3RDb25maWdzW3N1YmplY3RJbnN0YW5jZS5kZWZJZF07XG4gICAgICAgIGxldCBzdWJqZWN0RGVmID0gc3ViamVjdERlZnNbc3ViamVjdEluc3RhbmNlLmRlZklkXTtcbiAgICAgICAgLy8gY29uc3RyYWludFxuICAgICAgICBpZiAoIWFsbENvbnN0cmFpbnRzUGFzcyhzdWJqZWN0Q29uZmlnLmNvbnN0cmFpbnRzLCBzdWJqZWN0UmFuZ2UsIG90aGVyRXZlbnRTdG9yZSwgc3RhdGUuYnVzaW5lc3NIb3VycywgY29udGV4dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvdmVybGFwXG4gICAgICAgIGxldCB7IGV2ZW50T3ZlcmxhcCB9ID0gY29udGV4dC5vcHRpb25zO1xuICAgICAgICBsZXQgZXZlbnRPdmVybGFwRnVuYyA9IHR5cGVvZiBldmVudE92ZXJsYXAgPT09ICdmdW5jdGlvbicgPyBldmVudE92ZXJsYXAgOiBudWxsO1xuICAgICAgICBmb3IgKGxldCBvdGhlckluc3RhbmNlSWQgaW4gb3RoZXJJbnN0YW5jZXMpIHtcbiAgICAgICAgICAgIGxldCBvdGhlckluc3RhbmNlID0gb3RoZXJJbnN0YW5jZXNbb3RoZXJJbnN0YW5jZUlkXTtcbiAgICAgICAgICAgIC8vIGludGVyc2VjdCEgZXZhbHVhdGVcbiAgICAgICAgICAgIGlmIChyYW5nZXNJbnRlcnNlY3Qoc3ViamVjdFJhbmdlLCBvdGhlckluc3RhbmNlLnJhbmdlKSkge1xuICAgICAgICAgICAgICAgIGxldCBvdGhlck92ZXJsYXAgPSBvdGhlckNvbmZpZ3Nbb3RoZXJJbnN0YW5jZS5kZWZJZF0ub3ZlcmxhcDtcbiAgICAgICAgICAgICAgICAvLyBjb25zaWRlciB0aGUgb3RoZXIgZXZlbnQncyBvdmVybGFwLiBvbmx5IGRvIHRoaXMgaWYgdGhlIHN1YmplY3QgZXZlbnQgaXMgYSBcInJlYWxcIiBldmVudFxuICAgICAgICAgICAgICAgIGlmIChvdGhlck92ZXJsYXAgPT09IGZhbHNlICYmIGludGVyYWN0aW9uLmlzRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3ViamVjdENvbmZpZy5vdmVybGFwID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChldmVudE92ZXJsYXBGdW5jICYmICFldmVudE92ZXJsYXBGdW5jKG5ldyBFdmVudEltcGwoY29udGV4dCwgb3RoZXJEZWZzW290aGVySW5zdGFuY2UuZGVmSWRdLCBvdGhlckluc3RhbmNlKSwgLy8gc3RpbGwgZXZlbnRcbiAgICAgICAgICAgICAgICBuZXcgRXZlbnRJbXBsKGNvbnRleHQsIHN1YmplY3REZWYsIHN1YmplY3RJbnN0YW5jZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWxsb3cgKGEgZnVuY3Rpb24pXG4gICAgICAgIGxldCBjYWxlbmRhckV2ZW50U3RvcmUgPSBjdXJyZW50U3RhdGUuZXZlbnRTdG9yZTsgLy8gbmVlZCBnbG9iYWwtdG8tY2FsZW5kYXIsIG5vdCBsb2NhbCB0byBjb21wb25lbnQgKHNwbGl0dGFibGUpc3RhdGVcbiAgICAgICAgZm9yIChsZXQgc3ViamVjdEFsbG93IG9mIHN1YmplY3RDb25maWcuYWxsb3dzKSB7XG4gICAgICAgICAgICBsZXQgc3ViamVjdERhdGVTcGFuID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkYXRlU3Bhbk1ldGEpLCB7IHJhbmdlOiBzdWJqZWN0SW5zdGFuY2UucmFuZ2UsIGFsbERheTogc3ViamVjdERlZi5hbGxEYXkgfSk7XG4gICAgICAgICAgICBsZXQgb3JpZ0RlZiA9IGNhbGVuZGFyRXZlbnRTdG9yZS5kZWZzW3N1YmplY3REZWYuZGVmSWRdO1xuICAgICAgICAgICAgbGV0IG9yaWdJbnN0YW5jZSA9IGNhbGVuZGFyRXZlbnRTdG9yZS5pbnN0YW5jZXNbc3ViamVjdEluc3RhbmNlSWRdO1xuICAgICAgICAgICAgbGV0IGV2ZW50QXBpO1xuICAgICAgICAgICAgaWYgKG9yaWdEZWYpIHsgLy8gd2FzIHByZXZpb3VzbHkgaW4gdGhlIGNhbGVuZGFyXG4gICAgICAgICAgICAgICAgZXZlbnRBcGkgPSBuZXcgRXZlbnRJbXBsKGNvbnRleHQsIG9yaWdEZWYsIG9yaWdJbnN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHsgLy8gd2FzIGFuIGV4dGVybmFsIGV2ZW50XG4gICAgICAgICAgICAgICAgZXZlbnRBcGkgPSBuZXcgRXZlbnRJbXBsKGNvbnRleHQsIHN1YmplY3REZWYpOyAvLyBubyBpbnN0YW5jZSwgYmVjYXVzZSBoYWQgbm8gZGF0ZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3ViamVjdEFsbG93KGJ1aWxkRGF0ZVNwYW5BcGlXaXRoQ29udGV4dChzdWJqZWN0RGF0ZVNwYW4sIGNvbnRleHQpLCBldmVudEFwaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyBEYXRlIFNlbGVjdGlvbiBWYWxpZGF0aW9uXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGlzRGF0ZVNlbGVjdGlvblByb3BzVmFsaWQoc3RhdGUsIGNvbnRleHQsIGRhdGVTcGFuTWV0YSwgZmlsdGVyQ29uZmlnKSB7XG4gICAgbGV0IHJlbGV2YW50RXZlbnRTdG9yZSA9IHN0YXRlLmV2ZW50U3RvcmU7XG4gICAgbGV0IHJlbGV2YW50RGVmcyA9IHJlbGV2YW50RXZlbnRTdG9yZS5kZWZzO1xuICAgIGxldCByZWxldmFudEluc3RhbmNlcyA9IHJlbGV2YW50RXZlbnRTdG9yZS5pbnN0YW5jZXM7XG4gICAgbGV0IHNlbGVjdGlvbiA9IHN0YXRlLmRhdGVTZWxlY3Rpb247XG4gICAgbGV0IHNlbGVjdGlvblJhbmdlID0gc2VsZWN0aW9uLnJhbmdlO1xuICAgIGxldCB7IHNlbGVjdGlvbkNvbmZpZyB9ID0gY29udGV4dC5nZXRDdXJyZW50RGF0YSgpO1xuICAgIGlmIChmaWx0ZXJDb25maWcpIHtcbiAgICAgICAgc2VsZWN0aW9uQ29uZmlnID0gZmlsdGVyQ29uZmlnKHNlbGVjdGlvbkNvbmZpZyk7XG4gICAgfVxuICAgIC8vIGNvbnN0cmFpbnRcbiAgICBpZiAoIWFsbENvbnN0cmFpbnRzUGFzcyhzZWxlY3Rpb25Db25maWcuY29uc3RyYWludHMsIHNlbGVjdGlvblJhbmdlLCByZWxldmFudEV2ZW50U3RvcmUsIHN0YXRlLmJ1c2luZXNzSG91cnMsIGNvbnRleHQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gb3ZlcmxhcFxuICAgIGxldCB7IHNlbGVjdE92ZXJsYXAgfSA9IGNvbnRleHQub3B0aW9ucztcbiAgICBsZXQgc2VsZWN0T3ZlcmxhcEZ1bmMgPSB0eXBlb2Ygc2VsZWN0T3ZlcmxhcCA9PT0gJ2Z1bmN0aW9uJyA/IHNlbGVjdE92ZXJsYXAgOiBudWxsO1xuICAgIGZvciAobGV0IHJlbGV2YW50SW5zdGFuY2VJZCBpbiByZWxldmFudEluc3RhbmNlcykge1xuICAgICAgICBsZXQgcmVsZXZhbnRJbnN0YW5jZSA9IHJlbGV2YW50SW5zdGFuY2VzW3JlbGV2YW50SW5zdGFuY2VJZF07XG4gICAgICAgIC8vIGludGVyc2VjdCEgZXZhbHVhdGVcbiAgICAgICAgaWYgKHJhbmdlc0ludGVyc2VjdChzZWxlY3Rpb25SYW5nZSwgcmVsZXZhbnRJbnN0YW5jZS5yYW5nZSkpIHtcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb25Db25maWcub3ZlcmxhcCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZWN0T3ZlcmxhcEZ1bmMgJiYgIXNlbGVjdE92ZXJsYXBGdW5jKG5ldyBFdmVudEltcGwoY29udGV4dCwgcmVsZXZhbnREZWZzW3JlbGV2YW50SW5zdGFuY2UuZGVmSWRdLCByZWxldmFudEluc3RhbmNlKSwgbnVsbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYWxsb3cgKGEgZnVuY3Rpb24pXG4gICAgZm9yIChsZXQgc2VsZWN0aW9uQWxsb3cgb2Ygc2VsZWN0aW9uQ29uZmlnLmFsbG93cykge1xuICAgICAgICBsZXQgZnVsbERhdGVTcGFuID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkYXRlU3Bhbk1ldGEpLCBzZWxlY3Rpb24pO1xuICAgICAgICBpZiAoIXNlbGVjdGlvbkFsbG93KGJ1aWxkRGF0ZVNwYW5BcGlXaXRoQ29udGV4dChmdWxsRGF0ZVNwYW4sIGNvbnRleHQpLCBudWxsKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLy8gQ29uc3RyYWludCBVdGlsc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBhbGxDb25zdHJhaW50c1Bhc3MoY29uc3RyYWludHMsIHN1YmplY3RSYW5nZSwgb3RoZXJFdmVudFN0b3JlLCBidXNpbmVzc0hvdXJzVW5leHBhbmRlZCwgY29udGV4dCkge1xuICAgIGZvciAobGV0IGNvbnN0cmFpbnQgb2YgY29uc3RyYWludHMpIHtcbiAgICAgICAgaWYgKCFhbnlSYW5nZXNDb250YWluUmFuZ2UoY29uc3RyYWludFRvUmFuZ2VzKGNvbnN0cmFpbnQsIHN1YmplY3RSYW5nZSwgb3RoZXJFdmVudFN0b3JlLCBidXNpbmVzc0hvdXJzVW5leHBhbmRlZCwgY29udGV4dCksIHN1YmplY3RSYW5nZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNvbnN0cmFpbnRUb1Jhbmdlcyhjb25zdHJhaW50LCBzdWJqZWN0UmFuZ2UsIC8vIGZvciBleHBhbmRpbmcgYSByZWN1cnJpbmcgY29uc3RyYWludCwgb3IgZXhwYW5kaW5nIGJ1c2luZXNzIGhvdXJzXG5vdGhlckV2ZW50U3RvcmUsIC8vIGZvciBpZiBjb25zdHJhaW50IGlzIGFuIGV2ZW4gZ3JvdXAgSURcbmJ1c2luZXNzSG91cnNVbmV4cGFuZGVkLCAvLyBmb3IgaWYgY29uc3RyYWludCBpcyAnYnVzaW5lc3NIb3VycydcbmNvbnRleHQpIHtcbiAgICBpZiAoY29uc3RyYWludCA9PT0gJ2J1c2luZXNzSG91cnMnKSB7XG4gICAgICAgIHJldHVybiBldmVudFN0b3JlVG9SYW5nZXMoZXhwYW5kUmVjdXJyaW5nKGJ1c2luZXNzSG91cnNVbmV4cGFuZGVkLCBzdWJqZWN0UmFuZ2UsIGNvbnRleHQpKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb25zdHJhaW50ID09PSAnc3RyaW5nJykgeyAvLyBhbiBncm91cCBJRFxuICAgICAgICByZXR1cm4gZXZlbnRTdG9yZVRvUmFuZ2VzKGZpbHRlckV2ZW50U3RvcmVEZWZzKG90aGVyRXZlbnRTdG9yZSwgKGV2ZW50RGVmKSA9PiBldmVudERlZi5ncm91cElkID09PSBjb25zdHJhaW50KSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY29uc3RyYWludCA9PT0gJ29iamVjdCcgJiYgY29uc3RyYWludCkgeyAvLyBub24tbnVsbCBvYmplY3RcbiAgICAgICAgcmV0dXJuIGV2ZW50U3RvcmVUb1JhbmdlcyhleHBhbmRSZWN1cnJpbmcoY29uc3RyYWludCwgc3ViamVjdFJhbmdlLCBjb250ZXh0KSk7XG4gICAgfVxuICAgIHJldHVybiBbXTsgLy8gaWYgaXQncyBmYWxzZVxufVxuLy8gVE9ETzogbW92ZSB0byBldmVudC1zdG9yZSBmaWxlP1xuZnVuY3Rpb24gZXZlbnRTdG9yZVRvUmFuZ2VzKGV2ZW50U3RvcmUpIHtcbiAgICBsZXQgeyBpbnN0YW5jZXMgfSA9IGV2ZW50U3RvcmU7XG4gICAgbGV0IHJhbmdlcyA9IFtdO1xuICAgIGZvciAobGV0IGluc3RhbmNlSWQgaW4gaW5zdGFuY2VzKSB7XG4gICAgICAgIHJhbmdlcy5wdXNoKGluc3RhbmNlc1tpbnN0YW5jZUlkXS5yYW5nZSk7XG4gICAgfVxuICAgIHJldHVybiByYW5nZXM7XG59XG4vLyBUT0RPOiBtb3ZlIHRvIGdlb20gZmlsZT9cbmZ1bmN0aW9uIGFueVJhbmdlc0NvbnRhaW5SYW5nZShvdXRlclJhbmdlcywgaW5uZXJSYW5nZSkge1xuICAgIGZvciAobGV0IG91dGVyUmFuZ2Ugb2Ygb3V0ZXJSYW5nZXMpIHtcbiAgICAgICAgaWYgKHJhbmdlQ29udGFpbnNSYW5nZShvdXRlclJhbmdlLCBpbm5lclJhbmdlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5jb25zdCBWSVNJQkxFX0hJRERFTl9SRSA9IC9eKHZpc2libGV8aGlkZGVuKSQvO1xuY2xhc3MgU2Nyb2xsZXIgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVFbCA9IChlbCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICAgICAgc2V0UmVmKHRoaXMucHJvcHMuZWxSZWYsIGVsKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgbGlxdWlkLCBsaXF1aWRJc0Fic29sdXRlIH0gPSBwcm9wcztcbiAgICAgICAgbGV0IGlzQWJzb2x1dGUgPSBsaXF1aWQgJiYgbGlxdWlkSXNBYnNvbHV0ZTtcbiAgICAgICAgbGV0IGNsYXNzTmFtZSA9IFsnZmMtc2Nyb2xsZXInXTtcbiAgICAgICAgaWYgKGxpcXVpZCkge1xuICAgICAgICAgICAgaWYgKGxpcXVpZElzQWJzb2x1dGUpIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWUucHVzaCgnZmMtc2Nyb2xsZXItbGlxdWlkLWFic29sdXRlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWUucHVzaCgnZmMtc2Nyb2xsZXItbGlxdWlkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiB0aGlzLmhhbmRsZUVsLCBjbGFzc05hbWU6IGNsYXNzTmFtZS5qb2luKCcgJyksIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3dYOiBwcm9wcy5vdmVyZmxvd1gsXG4gICAgICAgICAgICAgICAgb3ZlcmZsb3dZOiBwcm9wcy5vdmVyZmxvd1ksXG4gICAgICAgICAgICAgICAgbGVmdDogKGlzQWJzb2x1dGUgJiYgLShwcm9wcy5vdmVyY29tZUxlZnQgfHwgMCkpIHx8ICcnLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiAoaXNBYnNvbHV0ZSAmJiAtKHByb3BzLm92ZXJjb21lUmlnaHQgfHwgMCkpIHx8ICcnLFxuICAgICAgICAgICAgICAgIGJvdHRvbTogKGlzQWJzb2x1dGUgJiYgLShwcm9wcy5vdmVyY29tZUJvdHRvbSB8fCAwKSkgfHwgJycsXG4gICAgICAgICAgICAgICAgbWFyZ2luTGVmdDogKCFpc0Fic29sdXRlICYmIC0ocHJvcHMub3ZlcmNvbWVMZWZ0IHx8IDApKSB8fCAnJyxcbiAgICAgICAgICAgICAgICBtYXJnaW5SaWdodDogKCFpc0Fic29sdXRlICYmIC0ocHJvcHMub3ZlcmNvbWVSaWdodCB8fCAwKSkgfHwgJycsXG4gICAgICAgICAgICAgICAgbWFyZ2luQm90dG9tOiAoIWlzQWJzb2x1dGUgJiYgLShwcm9wcy5vdmVyY29tZUJvdHRvbSB8fCAwKSkgfHwgJycsXG4gICAgICAgICAgICAgICAgbWF4SGVpZ2h0OiBwcm9wcy5tYXhIZWlnaHQgfHwgJycsXG4gICAgICAgICAgICB9IH0sIHByb3BzLmNoaWxkcmVuKSk7XG4gICAgfVxuICAgIG5lZWRzWFNjcm9sbGluZygpIHtcbiAgICAgICAgaWYgKFZJU0lCTEVfSElEREVOX1JFLnRlc3QodGhpcy5wcm9wcy5vdmVyZmxvd1gpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGVzdGluZyBzY3JvbGxXaWR0aD5jbGllbnRXaWR0aCBpcyB1bnJlbGlhYmxlIGNyb3NzLWJyb3dzZXIgd2hlbiBwaXhlbCBoZWlnaHRzIGFyZW4ndCBpbnRlZ2Vycy5cbiAgICAgICAgLy8gbXVjaCBtb3JlIHJlbGlhYmxlIHRvIHNlZSBpZiBjaGlsZHJlbiBhcmUgdGFsbGVyIHRoYW4gdGhlIHNjcm9sbGVyLCBldmVuIHRobyBkb2Vzbid0IGFjY291bnQgZm9yXG4gICAgICAgIC8vIGlubmVyLWNoaWxkIG1hcmdpbnMgYW5kIGFic29sdXRlIHBvc2l0aW9uaW5nXG4gICAgICAgIGxldCB7IGVsIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcmVhbENsaWVudFdpZHRoID0gdGhpcy5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCAtIHRoaXMuZ2V0WVNjcm9sbGJhcldpZHRoKCk7XG4gICAgICAgIGxldCB7IGNoaWxkcmVuIH0gPSBlbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgbGV0IGNoaWxkRWwgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChjaGlsZEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoID4gcmVhbENsaWVudFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBuZWVkc1lTY3JvbGxpbmcoKSB7XG4gICAgICAgIGlmIChWSVNJQkxFX0hJRERFTl9SRS50ZXN0KHRoaXMucHJvcHMub3ZlcmZsb3dZKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRlc3Rpbmcgc2Nyb2xsSGVpZ2h0PmNsaWVudEhlaWdodCBpcyB1bnJlbGlhYmxlIGNyb3NzLWJyb3dzZXIgd2hlbiBwaXhlbCBoZWlnaHRzIGFyZW4ndCBpbnRlZ2Vycy5cbiAgICAgICAgLy8gbXVjaCBtb3JlIHJlbGlhYmxlIHRvIHNlZSBpZiBjaGlsZHJlbiBhcmUgdGFsbGVyIHRoYW4gdGhlIHNjcm9sbGVyLCBldmVuIHRobyBkb2Vzbid0IGFjY291bnQgZm9yXG4gICAgICAgIC8vIGlubmVyLWNoaWxkIG1hcmdpbnMgYW5kIGFic29sdXRlIHBvc2l0aW9uaW5nXG4gICAgICAgIGxldCB7IGVsIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcmVhbENsaWVudEhlaWdodCA9IHRoaXMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0IC0gdGhpcy5nZXRYU2Nyb2xsYmFyV2lkdGgoKTtcbiAgICAgICAgbGV0IHsgY2hpbGRyZW4gfSA9IGVsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGRFbCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKGNoaWxkRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0ID4gcmVhbENsaWVudEhlaWdodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0WFNjcm9sbGJhcldpZHRoKCkge1xuICAgICAgICBpZiAoVklTSUJMRV9ISURERU5fUkUudGVzdCh0aGlzLnByb3BzLm92ZXJmbG93WCkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVsLm9mZnNldEhlaWdodCAtIHRoaXMuZWwuY2xpZW50SGVpZ2h0OyAvLyBvbmx5IHdvcmtzIGJlY2F1c2Ugd2UgZ3VhcmFudGVlIG5vIGJvcmRlcnMuIFRPRE86IGFkZCB0byBDU1Mgd2l0aCBpbXBvcnRhbnQ/XG4gICAgfVxuICAgIGdldFlTY3JvbGxiYXJXaWR0aCgpIHtcbiAgICAgICAgaWYgKFZJU0lCTEVfSElEREVOX1JFLnRlc3QodGhpcy5wcm9wcy5vdmVyZmxvd1kpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lbC5vZmZzZXRXaWR0aCAtIHRoaXMuZWwuY2xpZW50V2lkdGg7IC8vIG9ubHkgd29ya3MgYmVjYXVzZSB3ZSBndWFyYW50ZWUgbm8gYm9yZGVycy4gVE9ETzogYWRkIHRvIENTUyB3aXRoIGltcG9ydGFudD9cbiAgICB9XG59XG5cbi8qXG5UT0RPOiBzb21laG93IGluZmVyIE90aGVyQXJncyBmcm9tIG1hc3RlckNhbGxiYWNrP1xuVE9ETzogaW5mZXIgUmVmVHlwZSBmcm9tIG1hc3RlckNhbGxiYWNrIGlmIHByb3ZpZGVkXG4qL1xuY2xhc3MgUmVmTWFwIHtcbiAgICBjb25zdHJ1Y3RvcihtYXN0ZXJDYWxsYmFjaykge1xuICAgICAgICB0aGlzLm1hc3RlckNhbGxiYWNrID0gbWFzdGVyQ2FsbGJhY2s7XG4gICAgICAgIHRoaXMuY3VycmVudE1hcCA9IHt9O1xuICAgICAgICB0aGlzLmRlcHRocyA9IHt9O1xuICAgICAgICB0aGlzLmNhbGxiYWNrTWFwID0ge307XG4gICAgICAgIHRoaXMuaGFuZGxlVmFsdWUgPSAodmFsLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGxldCB7IGRlcHRocywgY3VycmVudE1hcCB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCByZW1vdmVkID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgYWRkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh2YWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBmb3IgYnVnLi4uIEFDVFVBTExZOiBjYW4gcHJvYmFibHkgZG8gYXdheSB3aXRoIHRoaXMgbm93IHRoYXQgY2FsbGVycyBkb24ndCBzaGFyZSBudW1lcmljIGluZGljZXMgYW55bW9yZVxuICAgICAgICAgICAgICAgIHJlbW92ZWQgPSAoa2V5IGluIGN1cnJlbnRNYXApO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRNYXBba2V5XSA9IHZhbDtcbiAgICAgICAgICAgICAgICBkZXB0aHNba2V5XSA9IChkZXB0aHNba2V5XSB8fCAwKSArIDE7XG4gICAgICAgICAgICAgICAgYWRkZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVwdGhzW2tleV0gLT0gMTtcbiAgICAgICAgICAgICAgICBpZiAoIWRlcHRoc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjdXJyZW50TWFwW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNhbGxiYWNrTWFwW2tleV07XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm1hc3RlckNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXN0ZXJDYWxsYmFjayhudWxsLCBTdHJpbmcoa2V5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhZGRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hc3RlckNhbGxiYWNrKHZhbCwgU3RyaW5nKGtleSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgY3JlYXRlUmVmKGtleSkge1xuICAgICAgICBsZXQgcmVmQ2FsbGJhY2sgPSB0aGlzLmNhbGxiYWNrTWFwW2tleV07XG4gICAgICAgIGlmICghcmVmQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJlZkNhbGxiYWNrID0gdGhpcy5jYWxsYmFja01hcFtrZXldID0gKHZhbCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlVmFsdWUodmFsLCBTdHJpbmcoa2V5KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWZDYWxsYmFjaztcbiAgICB9XG4gICAgLy8gVE9ETzogY2hlY2sgY2FsbGVycyB0aGF0IGRvbid0IGNhcmUgYWJvdXQgb3JkZXIuIHNob3VsZCB1c2UgZ2V0QWxsIGluc3RlYWRcbiAgICAvLyBOT1RFOiB0aGlzIG1ldGhvZCBoYXMgYmVjb21lIGxlc3MgdmFsdWFibGUgbm93IHRoYXQgd2UgYXJlIGVuY291cmFnZWQgdG8gbWFwIG9yZGVyIGJ5IHNvbWUgb3RoZXIgaW5kZXhcbiAgICAvLyBUT0RPOiBwcm92aWRlIE9ORSBhcnJheS1leHBvcnQgZnVuY3Rpb24sIGJ1aWxkQXJyYXksIHdoaWNoIGZhaWxzIG9uIG5vbi1udW1lcmljIGluZGV4ZXMuIGNhbGxlciBjYW4gbWFuaXB1bGF0ZSBhbmQgXCJjb2xsZWN0XCJcbiAgICBjb2xsZWN0KHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBzdGVwKSB7XG4gICAgICAgIHJldHVybiBjb2xsZWN0RnJvbUhhc2godGhpcy5jdXJyZW50TWFwLCBzdGFydEluZGV4LCBlbmRJbmRleCwgc3RlcCk7XG4gICAgfVxuICAgIGdldEFsbCgpIHtcbiAgICAgICAgcmV0dXJuIGhhc2hWYWx1ZXNUb0FycmF5KHRoaXMuY3VycmVudE1hcCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjb21wdXRlU2hyaW5rV2lkdGgoY2h1bmtFbHMpIHtcbiAgICBsZXQgc2hyaW5rQ2VsbHMgPSBmaW5kRWxlbWVudHMoY2h1bmtFbHMsICcuZmMtc2Nyb2xsZ3JpZC1zaHJpbmsnKTtcbiAgICBsZXQgbGFyZ2VzdFdpZHRoID0gMDtcbiAgICBmb3IgKGxldCBzaHJpbmtDZWxsIG9mIHNocmlua0NlbGxzKSB7XG4gICAgICAgIGxhcmdlc3RXaWR0aCA9IE1hdGgubWF4KGxhcmdlc3RXaWR0aCwgY29tcHV0ZVNtYWxsZXN0Q2VsbFdpZHRoKHNocmlua0NlbGwpKTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGguY2VpbChsYXJnZXN0V2lkdGgpOyAvLyA8dGFibGU+IGVsZW1lbnRzIHdvcmsgYmVzdCB3aXRoIGludGVnZXJzLiByb3VuZCB1cCB0byBlbnN1cmUgY29udGVudHMgZml0c1xufVxuZnVuY3Rpb24gZ2V0U2VjdGlvbkhhc0xpcXVpZEhlaWdodChwcm9wcywgc2VjdGlvbkNvbmZpZykge1xuICAgIHJldHVybiBwcm9wcy5saXF1aWQgJiYgc2VjdGlvbkNvbmZpZy5saXF1aWQ7IC8vIGRvZXMgdGhlIHNlY3Rpb24gZG8gbGlxdWlkLWhlaWdodD8gKG5lZWQgdG8gaGF2ZSB3aG9sZSBzY3JvbGxncmlkIGxpcXVpZC1oZWlnaHQgYXMgd2VsbClcbn1cbmZ1bmN0aW9uIGdldEFsbG93WVNjcm9sbGluZyhwcm9wcywgc2VjdGlvbkNvbmZpZykge1xuICAgIHJldHVybiBzZWN0aW9uQ29uZmlnLm1heEhlaWdodCAhPSBudWxsIHx8IC8vIGlmIGl0cyBwb3NzaWJsZSBmb3IgdGhlIGhlaWdodCB0byBtYXggb3V0LCB3ZSBtaWdodCBuZWVkIHNjcm9sbGJhcnNcbiAgICAgICAgZ2V0U2VjdGlvbkhhc0xpcXVpZEhlaWdodChwcm9wcywgc2VjdGlvbkNvbmZpZyk7IC8vIGlmIHRoZSBzZWN0aW9uIGlzIGxpcXVpZCBoZWlnaHQsIGl0IG1pZ2h0IGNvbmRlbnNlIGVub3VnaCB0byByZXF1aXJlIHNjcm9sbGJhcnNcbn1cbi8vIFRPRE86IE9OTFkgdXNlIGBhcmdgLiBmb3JjZSBvdXQgaW50ZXJuYWwgZnVuY3Rpb24gdG8gdXNlIHNhbWUgQVBJXG5mdW5jdGlvbiByZW5kZXJDaHVua0NvbnRlbnQoc2VjdGlvbkNvbmZpZywgY2h1bmtDb25maWcsIGFyZywgaXNIZWFkZXIpIHtcbiAgICBsZXQgeyBleHBhbmRSb3dzIH0gPSBhcmc7XG4gICAgbGV0IGNvbnRlbnQgPSB0eXBlb2YgY2h1bmtDb25maWcuY29udGVudCA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgIGNodW5rQ29uZmlnLmNvbnRlbnQoYXJnKSA6XG4gICAgICAgIGNyZWF0ZUVsZW1lbnQoJ3RhYmxlJywge1xuICAgICAgICAgICAgcm9sZTogJ3ByZXNlbnRhdGlvbicsXG4gICAgICAgICAgICBjbGFzc05hbWU6IFtcbiAgICAgICAgICAgICAgICBjaHVua0NvbmZpZy50YWJsZUNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICBzZWN0aW9uQ29uZmlnLnN5bmNSb3dIZWlnaHRzID8gJ2ZjLXNjcm9sbGdyaWQtc3luYy10YWJsZScgOiAnJyxcbiAgICAgICAgICAgIF0uam9pbignICcpLFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBtaW5XaWR0aDogYXJnLnRhYmxlTWluV2lkdGgsXG4gICAgICAgICAgICAgICAgd2lkdGg6IGFyZy5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGV4cGFuZFJvd3MgPyBhcmcuY2xpZW50SGVpZ2h0IDogJycsIC8vIGNzcyBgaGVpZ2h0YCBvbiBhIDx0YWJsZT4gc2VydmVzIGFzIGEgbWluLWhlaWdodFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSwgYXJnLnRhYmxlQ29sR3JvdXBOb2RlLCBjcmVhdGVFbGVtZW50KGlzSGVhZGVyID8gJ3RoZWFkJyA6ICd0Ym9keScsIHtcbiAgICAgICAgICAgIHJvbGU6ICdwcmVzZW50YXRpb24nLFxuICAgICAgICB9LCB0eXBlb2YgY2h1bmtDb25maWcucm93Q29udGVudCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBjaHVua0NvbmZpZy5yb3dDb250ZW50KGFyZylcbiAgICAgICAgICAgIDogY2h1bmtDb25maWcucm93Q29udGVudCkpO1xuICAgIHJldHVybiBjb250ZW50O1xufVxuZnVuY3Rpb24gaXNDb2xQcm9wc0VxdWFsKGNvbHMwLCBjb2xzMSkge1xuICAgIHJldHVybiBpc0FycmF5c0VxdWFsKGNvbHMwLCBjb2xzMSwgaXNQcm9wc0VxdWFsKTtcbn1cbmZ1bmN0aW9uIHJlbmRlck1pY3JvQ29sR3JvdXAoY29scywgc2hyaW5rV2lkdGgpIHtcbiAgICBsZXQgY29sTm9kZXMgPSBbXTtcbiAgICAvKlxuICAgIGZvciBDb2xQcm9wcyB3aXRoIHNwYW5zLCBpdCB3b3VsZCBoYXZlIGJlZW4gZ3JlYXQgdG8gbWFrZSBhIHNpbmdsZSA8Y29sIHNwYW49XCJcIj5cbiAgICBIT1dFVkVSLCBDaHJvbWUgd2FzIGdldHRpbmcgbWVzc2luZyB1cCBkaXN0cmlidXRpbmcgdGhlIHdpZHRoIHRvIDx0ZD4vPHRoPiBlbGVtZW50cyB3aXRoIGNvbHNwYW5zLlxuICAgIFNPTFVUSU9OOiBtYWtpbmcgaW5kaXZpZHVhbCA8Y29sPiBlbGVtZW50cyBtYWtlcyBDaHJvbWUgYmVoYXZlLlxuICAgICovXG4gICAgZm9yIChsZXQgY29sUHJvcHMgb2YgY29scykge1xuICAgICAgICBsZXQgc3BhbiA9IGNvbFByb3BzLnNwYW4gfHwgMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGFuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbE5vZGVzLnB1c2goY3JlYXRlRWxlbWVudChcImNvbFwiLCB7IHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjb2xQcm9wcy53aWR0aCA9PT0gJ3NocmluaycgPyBzYW5pdGl6ZVNocmlua1dpZHRoKHNocmlua1dpZHRoKSA6IChjb2xQcm9wcy53aWR0aCB8fCAnJyksXG4gICAgICAgICAgICAgICAgICAgIG1pbldpZHRoOiBjb2xQcm9wcy5taW5XaWR0aCB8fCAnJyxcbiAgICAgICAgICAgICAgICB9IH0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgnY29sZ3JvdXAnLCB7fSwgLi4uY29sTm9kZXMpO1xufVxuZnVuY3Rpb24gc2FuaXRpemVTaHJpbmtXaWR0aChzaHJpbmtXaWR0aCkge1xuICAgIC8qIHdoeSA0PyBpZiB3ZSBkbyAwLCBpdCB3aWxsIGtpbGwgYW55IGJvcmRlciwgd2hpY2ggYXJlIG5lZWRlZCBmb3IgY29tcHV0ZVNtYWxsZXN0Q2VsbFdpZHRoXG4gICAgNCBhY2NvdW50cyBmb3IgMiAyLXBpeGVsIGJvcmRlcnMuIFRPRE86IGJldHRlciBzb2x1dGlvbj8gKi9cbiAgICByZXR1cm4gc2hyaW5rV2lkdGggPT0gbnVsbCA/IDQgOiBzaHJpbmtXaWR0aDtcbn1cbmZ1bmN0aW9uIGhhc1Nocmlua1dpZHRoKGNvbHMpIHtcbiAgICBmb3IgKGxldCBjb2wgb2YgY29scykge1xuICAgICAgICBpZiAoY29sLndpZHRoID09PSAnc2hyaW5rJykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0U2Nyb2xsR3JpZENsYXNzTmFtZXMobGlxdWlkLCBjb250ZXh0KSB7XG4gICAgbGV0IGNsYXNzTmFtZXMgPSBbXG4gICAgICAgICdmYy1zY3JvbGxncmlkJyxcbiAgICAgICAgY29udGV4dC50aGVtZS5nZXRDbGFzcygndGFibGUnKSxcbiAgICBdO1xuICAgIGlmIChsaXF1aWQpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1zY3JvbGxncmlkLWxpcXVpZCcpO1xuICAgIH1cbiAgICByZXR1cm4gY2xhc3NOYW1lcztcbn1cbmZ1bmN0aW9uIGdldFNlY3Rpb25DbGFzc05hbWVzKHNlY3Rpb25Db25maWcsIHdob2xlVGFibGVWR3Jvdykge1xuICAgIGxldCBjbGFzc05hbWVzID0gW1xuICAgICAgICAnZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uJyxcbiAgICAgICAgYGZjLXNjcm9sbGdyaWQtc2VjdGlvbi0ke3NlY3Rpb25Db25maWcudHlwZX1gLFxuICAgICAgICBzZWN0aW9uQ29uZmlnLmNsYXNzTmFtZSwgLy8gdXNlZD9cbiAgICBdO1xuICAgIGlmICh3aG9sZVRhYmxlVkdyb3cgJiYgc2VjdGlvbkNvbmZpZy5saXF1aWQgJiYgc2VjdGlvbkNvbmZpZy5tYXhIZWlnaHQgPT0gbnVsbCkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNjcm9sbGdyaWQtc2VjdGlvbi1saXF1aWQnKTtcbiAgICB9XG4gICAgaWYgKHNlY3Rpb25Db25maWcuaXNTdGlja3kpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1zY3JvbGxncmlkLXNlY3Rpb24tc3RpY2t5Jyk7XG4gICAgfVxuICAgIHJldHVybiBjbGFzc05hbWVzO1xufVxuZnVuY3Rpb24gcmVuZGVyU2Nyb2xsU2hpbShhcmcpIHtcbiAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtc2Nyb2xsZ3JpZC1zdGlja3ktc2hpbVwiLCBzdHlsZToge1xuICAgICAgICAgICAgd2lkdGg6IGFyZy5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgIG1pbldpZHRoOiBhcmcudGFibGVNaW5XaWR0aCxcbiAgICAgICAgfSB9KSk7XG59XG5mdW5jdGlvbiBnZXRTdGlja3lIZWFkZXJEYXRlcyhvcHRpb25zKSB7XG4gICAgbGV0IHsgc3RpY2t5SGVhZGVyRGF0ZXMgfSA9IG9wdGlvbnM7XG4gICAgaWYgKHN0aWNreUhlYWRlckRhdGVzID09IG51bGwgfHwgc3RpY2t5SGVhZGVyRGF0ZXMgPT09ICdhdXRvJykge1xuICAgICAgICBzdGlja3lIZWFkZXJEYXRlcyA9IG9wdGlvbnMuaGVpZ2h0ID09PSAnYXV0bycgfHwgb3B0aW9ucy52aWV3SGVpZ2h0ID09PSAnYXV0byc7XG4gICAgfVxuICAgIHJldHVybiBzdGlja3lIZWFkZXJEYXRlcztcbn1cbmZ1bmN0aW9uIGdldFN0aWNreUZvb3RlclNjcm9sbGJhcihvcHRpb25zKSB7XG4gICAgbGV0IHsgc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyIH0gPSBvcHRpb25zO1xuICAgIGlmIChzdGlja3lGb290ZXJTY3JvbGxiYXIgPT0gbnVsbCB8fCBzdGlja3lGb290ZXJTY3JvbGxiYXIgPT09ICdhdXRvJykge1xuICAgICAgICBzdGlja3lGb290ZXJTY3JvbGxiYXIgPSBvcHRpb25zLmhlaWdodCA9PT0gJ2F1dG8nIHx8IG9wdGlvbnMudmlld0hlaWdodCA9PT0gJ2F1dG8nO1xuICAgIH1cbiAgICByZXR1cm4gc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyO1xufVxuXG5jbGFzcyBTaW1wbGVTY3JvbGxHcmlkIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMucHJvY2Vzc0NvbHMgPSBtZW1vaXplKChhKSA9PiBhLCBpc0NvbFByb3BzRXF1YWwpOyAvLyBzbyB3ZSBnZXQgc2FtZSBgY29sc2AgcHJvcHMgZXZlcnkgdGltZVxuICAgICAgICAvLyB5dWNreSB0byBtZW1vaXplIFZOb2RlcywgYnV0IG11Y2ggbW9yZSBlZmZpY2llbnQgZm9yIGNvbnN1bWVyc1xuICAgICAgICB0aGlzLnJlbmRlck1pY3JvQ29sR3JvdXAgPSBtZW1vaXplKHJlbmRlck1pY3JvQ29sR3JvdXApO1xuICAgICAgICB0aGlzLnNjcm9sbGVyUmVmcyA9IG5ldyBSZWZNYXAoKTtcbiAgICAgICAgdGhpcy5zY3JvbGxlckVsUmVmcyA9IG5ldyBSZWZNYXAodGhpcy5faGFuZGxlU2Nyb2xsZXJFbC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHNocmlua1dpZHRoOiBudWxsLFxuICAgICAgICAgICAgZm9yY2VZU2Nyb2xsYmFyczogZmFsc2UsXG4gICAgICAgICAgICBzY3JvbGxlckNsaWVudFdpZHRoczoge30sXG4gICAgICAgICAgICBzY3JvbGxlckNsaWVudEhlaWdodHM6IHt9LFxuICAgICAgICB9O1xuICAgICAgICAvLyBUT0RPOiBjYW4gZG8gYSByZWFsbHkgc2ltcGxlIHByaW50LXZpZXcuIGRvbnQgbmVlZCB0byBqb2luIHJvd3NcbiAgICAgICAgdGhpcy5oYW5kbGVTaXppbmcgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNhZmVTZXRTdGF0ZShPYmplY3QuYXNzaWduKHsgc2hyaW5rV2lkdGg6IHRoaXMuY29tcHV0ZVNocmlua1dpZHRoKCkgfSwgdGhpcy5jb21wdXRlU2Nyb2xsZXJEaW1zKCkpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgc3RhdGUsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCBzZWN0aW9uQ29uZmlncyA9IHByb3BzLnNlY3Rpb25zIHx8IFtdO1xuICAgICAgICBsZXQgY29scyA9IHRoaXMucHJvY2Vzc0NvbHMocHJvcHMuY29scyk7XG4gICAgICAgIGxldCBtaWNyb0NvbEdyb3VwTm9kZSA9IHRoaXMucmVuZGVyTWljcm9Db2xHcm91cChjb2xzLCBzdGF0ZS5zaHJpbmtXaWR0aCk7XG4gICAgICAgIGxldCBjbGFzc05hbWVzID0gZ2V0U2Nyb2xsR3JpZENsYXNzTmFtZXMocHJvcHMubGlxdWlkLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHByb3BzLmNvbGxhcHNpYmxlV2lkdGgpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtc2Nyb2xsZ3JpZC1jb2xsYXBzaWJsZScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IG1ha2UgRFJZXG4gICAgICAgIGxldCBjb25maWdDbnQgPSBzZWN0aW9uQ29uZmlncy5sZW5ndGg7XG4gICAgICAgIGxldCBjb25maWdJID0gMDtcbiAgICAgICAgbGV0IGN1cnJlbnRDb25maWc7XG4gICAgICAgIGxldCBoZWFkU2VjdGlvbk5vZGVzID0gW107XG4gICAgICAgIGxldCBib2R5U2VjdGlvbk5vZGVzID0gW107XG4gICAgICAgIGxldCBmb290U2VjdGlvbk5vZGVzID0gW107XG4gICAgICAgIHdoaWxlIChjb25maWdJIDwgY29uZmlnQ250ICYmIChjdXJyZW50Q29uZmlnID0gc2VjdGlvbkNvbmZpZ3NbY29uZmlnSV0pLnR5cGUgPT09ICdoZWFkZXInKSB7XG4gICAgICAgICAgICBoZWFkU2VjdGlvbk5vZGVzLnB1c2godGhpcy5yZW5kZXJTZWN0aW9uKGN1cnJlbnRDb25maWcsIG1pY3JvQ29sR3JvdXBOb2RlLCB0cnVlKSk7XG4gICAgICAgICAgICBjb25maWdJICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGNvbmZpZ0kgPCBjb25maWdDbnQgJiYgKGN1cnJlbnRDb25maWcgPSBzZWN0aW9uQ29uZmlnc1tjb25maWdJXSkudHlwZSA9PT0gJ2JvZHknKSB7XG4gICAgICAgICAgICBib2R5U2VjdGlvbk5vZGVzLnB1c2godGhpcy5yZW5kZXJTZWN0aW9uKGN1cnJlbnRDb25maWcsIG1pY3JvQ29sR3JvdXBOb2RlLCBmYWxzZSkpO1xuICAgICAgICAgICAgY29uZmlnSSArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChjb25maWdJIDwgY29uZmlnQ250ICYmIChjdXJyZW50Q29uZmlnID0gc2VjdGlvbkNvbmZpZ3NbY29uZmlnSV0pLnR5cGUgPT09ICdmb290ZXInKSB7XG4gICAgICAgICAgICBmb290U2VjdGlvbk5vZGVzLnB1c2godGhpcy5yZW5kZXJTZWN0aW9uKGN1cnJlbnRDb25maWcsIG1pY3JvQ29sR3JvdXBOb2RlLCB0cnVlKSk7XG4gICAgICAgICAgICBjb25maWdJICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmlyZWZveCBidWc6IHdoZW4gc2V0dGluZyBoZWlnaHQgb24gdGFibGUgYW5kIHRoZXJlIGlzIGEgdGhlYWQgb3IgdGZvb3QsXG4gICAgICAgIC8vIHRoZSBuZWNlc3NhcnkgaGVpZ2h0OjEwMCUgb24gdGhlIGxpcXVpZC1oZWlnaHQgYm9keSBzZWN0aW9uIGZvcmNlcyB0aGUgKndob2xlKiB0YWJsZSB0byBiZSB0YWxsZXIuIChidWcgIzU1MjQpXG4gICAgICAgIC8vIHVzZSBnZXRDYW5WR3Jvd1dpdGhpbkNlbGwgYXMgYSB3YXkgdG8gZGV0ZWN0IHRhYmxlLXN0dXBpZCBmaXJlZm94LlxuICAgICAgICAvLyBpZiBzbywgdXNlIGEgc2ltcGxlciBkb20gc3RydWN0dXJlLCBqYW0gZXZlcnl0aGluZyBpbnRvIGEgbG9uZSB0Ym9keS5cbiAgICAgICAgbGV0IGlzQnVnZ3kgPSAhZ2V0Q2FuVkdyb3dXaXRoaW5DZWxsKCk7XG4gICAgICAgIGNvbnN0IHJvbGVBdHRycyA9IHsgcm9sZTogJ3Jvd2dyb3VwJyB9O1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgndGFibGUnLCB7XG4gICAgICAgICAgICByb2xlOiAnZ3JpZCcsXG4gICAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZXMuam9pbignICcpLFxuICAgICAgICAgICAgc3R5bGU6IHsgaGVpZ2h0OiBwcm9wcy5oZWlnaHQgfSxcbiAgICAgICAgfSwgQm9vbGVhbighaXNCdWdneSAmJiBoZWFkU2VjdGlvbk5vZGVzLmxlbmd0aCkgJiYgY3JlYXRlRWxlbWVudCgndGhlYWQnLCByb2xlQXR0cnMsIC4uLmhlYWRTZWN0aW9uTm9kZXMpLCBCb29sZWFuKCFpc0J1Z2d5ICYmIGJvZHlTZWN0aW9uTm9kZXMubGVuZ3RoKSAmJiBjcmVhdGVFbGVtZW50KCd0Ym9keScsIHJvbGVBdHRycywgLi4uYm9keVNlY3Rpb25Ob2RlcyksIEJvb2xlYW4oIWlzQnVnZ3kgJiYgZm9vdFNlY3Rpb25Ob2Rlcy5sZW5ndGgpICYmIGNyZWF0ZUVsZW1lbnQoJ3Rmb290Jywgcm9sZUF0dHJzLCAuLi5mb290U2VjdGlvbk5vZGVzKSwgaXNCdWdneSAmJiBjcmVhdGVFbGVtZW50KCd0Ym9keScsIHJvbGVBdHRycywgLi4uaGVhZFNlY3Rpb25Ob2RlcywgLi4uYm9keVNlY3Rpb25Ob2RlcywgLi4uZm9vdFNlY3Rpb25Ob2RlcykpO1xuICAgIH1cbiAgICByZW5kZXJTZWN0aW9uKHNlY3Rpb25Db25maWcsIG1pY3JvQ29sR3JvdXBOb2RlLCBpc0hlYWRlcikge1xuICAgICAgICBpZiAoJ291dGVyQ29udGVudCcgaW4gc2VjdGlvbkNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEZyYWdtZW50LCB7IGtleTogc2VjdGlvbkNvbmZpZy5rZXkgfSwgc2VjdGlvbkNvbmZpZy5vdXRlckNvbnRlbnQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IGtleTogc2VjdGlvbkNvbmZpZy5rZXksIHJvbGU6IFwicHJlc2VudGF0aW9uXCIsIGNsYXNzTmFtZTogZ2V0U2VjdGlvbkNsYXNzTmFtZXMoc2VjdGlvbkNvbmZpZywgdGhpcy5wcm9wcy5saXF1aWQpLmpvaW4oJyAnKSB9LCB0aGlzLnJlbmRlckNodW5rVGQoc2VjdGlvbkNvbmZpZywgbWljcm9Db2xHcm91cE5vZGUsIHNlY3Rpb25Db25maWcuY2h1bmssIGlzSGVhZGVyKSkpO1xuICAgIH1cbiAgICByZW5kZXJDaHVua1RkKHNlY3Rpb25Db25maWcsIG1pY3JvQ29sR3JvdXBOb2RlLCBjaHVua0NvbmZpZywgaXNIZWFkZXIpIHtcbiAgICAgICAgaWYgKCdvdXRlckNvbnRlbnQnIGluIGNodW5rQ29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm4gY2h1bmtDb25maWcub3V0ZXJDb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBmb3JjZVlTY3JvbGxiYXJzLCBzY3JvbGxlckNsaWVudFdpZHRocywgc2Nyb2xsZXJDbGllbnRIZWlnaHRzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBsZXQgbmVlZHNZU2Nyb2xsaW5nID0gZ2V0QWxsb3dZU2Nyb2xsaW5nKHByb3BzLCBzZWN0aW9uQ29uZmlnKTsgLy8gVE9ETzogZG8gbGF6aWx5LiBkbyBpbiBzZWN0aW9uIGNvbmZpZz9cbiAgICAgICAgbGV0IGlzTGlxdWlkID0gZ2V0U2VjdGlvbkhhc0xpcXVpZEhlaWdodChwcm9wcywgc2VjdGlvbkNvbmZpZyk7XG4gICAgICAgIC8vIGZvciBgIXByb3BzLmxpcXVpZGAgLSBpcyBXSE9MRSBzY3JvbGxncmlkIG5hdHVyYWwgaGVpZ2h0P1xuICAgICAgICAvLyBUT0RPOiBkbyBzYW1lIHRoaW5nIGluIGFkdmFuY2VkIHNjcm9sbGdyaWQ/IHByb2xseSBub3QgYi9jIGFsd2F5cyBoYXMgaG9yaXpvbnRhbCBzY3JvbGxiYXJzXG4gICAgICAgIGxldCBvdmVyZmxvd1kgPSAhcHJvcHMubGlxdWlkID8gJ3Zpc2libGUnIDpcbiAgICAgICAgICAgIGZvcmNlWVNjcm9sbGJhcnMgPyAnc2Nyb2xsJyA6XG4gICAgICAgICAgICAgICAgIW5lZWRzWVNjcm9sbGluZyA/ICdoaWRkZW4nIDpcbiAgICAgICAgICAgICAgICAgICAgJ2F1dG8nO1xuICAgICAgICBsZXQgc2VjdGlvbktleSA9IHNlY3Rpb25Db25maWcua2V5O1xuICAgICAgICBsZXQgY29udGVudCA9IHJlbmRlckNodW5rQ29udGVudChzZWN0aW9uQ29uZmlnLCBjaHVua0NvbmZpZywge1xuICAgICAgICAgICAgdGFibGVDb2xHcm91cE5vZGU6IG1pY3JvQ29sR3JvdXBOb2RlLFxuICAgICAgICAgICAgdGFibGVNaW5XaWR0aDogJycsXG4gICAgICAgICAgICBjbGllbnRXaWR0aDogKCFwcm9wcy5jb2xsYXBzaWJsZVdpZHRoICYmIHNjcm9sbGVyQ2xpZW50V2lkdGhzW3NlY3Rpb25LZXldICE9PSB1bmRlZmluZWQpID8gc2Nyb2xsZXJDbGllbnRXaWR0aHNbc2VjdGlvbktleV0gOiBudWxsLFxuICAgICAgICAgICAgY2xpZW50SGVpZ2h0OiBzY3JvbGxlckNsaWVudEhlaWdodHNbc2VjdGlvbktleV0gIT09IHVuZGVmaW5lZCA/IHNjcm9sbGVyQ2xpZW50SGVpZ2h0c1tzZWN0aW9uS2V5XSA6IG51bGwsXG4gICAgICAgICAgICBleHBhbmRSb3dzOiBzZWN0aW9uQ29uZmlnLmV4cGFuZFJvd3MsXG4gICAgICAgICAgICBzeW5jUm93SGVpZ2h0czogZmFsc2UsXG4gICAgICAgICAgICByb3dTeW5jSGVpZ2h0czogW10sXG4gICAgICAgICAgICByZXBvcnRSb3dIZWlnaHRDaGFuZ2U6ICgpID0+IHsgfSxcbiAgICAgICAgfSwgaXNIZWFkZXIpO1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChpc0hlYWRlciA/ICd0aCcgOiAndGQnLCB7XG4gICAgICAgICAgICByZWY6IGNodW5rQ29uZmlnLmVsUmVmLFxuICAgICAgICAgICAgcm9sZTogJ3ByZXNlbnRhdGlvbicsXG4gICAgICAgIH0sIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGBmYy1zY3JvbGxlci1oYXJuZXNzJHtpc0xpcXVpZCA/ICcgZmMtc2Nyb2xsZXItaGFybmVzcy1saXF1aWQnIDogJyd9YCB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChTY3JvbGxlciwgeyByZWY6IHRoaXMuc2Nyb2xsZXJSZWZzLmNyZWF0ZVJlZihzZWN0aW9uS2V5KSwgZWxSZWY6IHRoaXMuc2Nyb2xsZXJFbFJlZnMuY3JlYXRlUmVmKHNlY3Rpb25LZXkpLCBvdmVyZmxvd1k6IG92ZXJmbG93WSwgb3ZlcmZsb3dYOiAhcHJvcHMubGlxdWlkID8gJ3Zpc2libGUnIDogJ2hpZGRlbicgLyogbmF0dXJhbCBoZWlnaHQ/ICovLCBtYXhIZWlnaHQ6IHNlY3Rpb25Db25maWcubWF4SGVpZ2h0LCBsaXF1aWQ6IGlzTGlxdWlkLCBsaXF1aWRJc0Fic29sdXRlIC8vIGJlY2F1c2UgaXRzIHdpdGhpbiBhIGhhcm5lc3NcbiAgICAgICAgICAgICAgICA6IHRydWUgfSwgY29udGVudCkpKTtcbiAgICB9XG4gICAgX2hhbmRsZVNjcm9sbGVyRWwoc2Nyb2xsZXJFbCwga2V5KSB7XG4gICAgICAgIGxldCBzZWN0aW9uID0gZ2V0U2VjdGlvbkJ5S2V5KHRoaXMucHJvcHMuc2VjdGlvbnMsIGtleSk7XG4gICAgICAgIGlmIChzZWN0aW9uKSB7XG4gICAgICAgICAgICBzZXRSZWYoc2VjdGlvbi5jaHVuay5zY3JvbGxlckVsUmVmLCBzY3JvbGxlckVsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVTaXppbmcoKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmFkZFJlc2l6ZUhhbmRsZXIodGhpcy5oYW5kbGVTaXppbmcpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgIC8vIFRPRE86IG5lZWQgYmV0dGVyIHNvbHV0aW9uIHdoZW4gc3RhdGUgY29udGFpbnMgbm9uLXNpemluZyB0aGluZ3NcbiAgICAgICAgdGhpcy5oYW5kbGVTaXppbmcoKTtcbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5yZW1vdmVSZXNpemVIYW5kbGVyKHRoaXMuaGFuZGxlU2l6aW5nKTtcbiAgICB9XG4gICAgY29tcHV0ZVNocmlua1dpZHRoKCkge1xuICAgICAgICByZXR1cm4gaGFzU2hyaW5rV2lkdGgodGhpcy5wcm9wcy5jb2xzKVxuICAgICAgICAgICAgPyBjb21wdXRlU2hyaW5rV2lkdGgodGhpcy5zY3JvbGxlckVsUmVmcy5nZXRBbGwoKSlcbiAgICAgICAgICAgIDogMDtcbiAgICB9XG4gICAgY29tcHV0ZVNjcm9sbGVyRGltcygpIHtcbiAgICAgICAgbGV0IHNjcm9sbGJhcldpZHRoID0gZ2V0U2Nyb2xsYmFyV2lkdGhzKCk7XG4gICAgICAgIGxldCB7IHNjcm9sbGVyUmVmcywgc2Nyb2xsZXJFbFJlZnMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBmb3JjZVlTY3JvbGxiYXJzID0gZmFsc2U7XG4gICAgICAgIGxldCBzY3JvbGxlckNsaWVudFdpZHRocyA9IHt9O1xuICAgICAgICBsZXQgc2Nyb2xsZXJDbGllbnRIZWlnaHRzID0ge307XG4gICAgICAgIGZvciAobGV0IHNlY3Rpb25LZXkgaW4gc2Nyb2xsZXJSZWZzLmN1cnJlbnRNYXApIHtcbiAgICAgICAgICAgIGxldCBzY3JvbGxlciA9IHNjcm9sbGVyUmVmcy5jdXJyZW50TWFwW3NlY3Rpb25LZXldO1xuICAgICAgICAgICAgaWYgKHNjcm9sbGVyICYmIHNjcm9sbGVyLm5lZWRzWVNjcm9sbGluZygpKSB7XG4gICAgICAgICAgICAgICAgZm9yY2VZU2Nyb2xsYmFycyA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgc2VjdGlvbiBvZiB0aGlzLnByb3BzLnNlY3Rpb25zKSB7XG4gICAgICAgICAgICBsZXQgc2VjdGlvbktleSA9IHNlY3Rpb24ua2V5O1xuICAgICAgICAgICAgbGV0IHNjcm9sbGVyRWwgPSBzY3JvbGxlckVsUmVmcy5jdXJyZW50TWFwW3NlY3Rpb25LZXldO1xuICAgICAgICAgICAgaWYgKHNjcm9sbGVyRWwpIHtcbiAgICAgICAgICAgICAgICBsZXQgaGFybmVzc0VsID0gc2Nyb2xsZXJFbC5wYXJlbnROb2RlOyAvLyBUT0RPOiB3ZWlyZCB3YXkgdG8gZ2V0IHRoaXMuIG5lZWQgaGFybmVzcyBiL2MgZG9lc24ndCBpbmNsdWRlIHRhYmxlIGJvcmRlcnNcbiAgICAgICAgICAgICAgICBzY3JvbGxlckNsaWVudFdpZHRoc1tzZWN0aW9uS2V5XSA9IE1hdGguZmxvb3IoaGFybmVzc0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC0gKGZvcmNlWVNjcm9sbGJhcnNcbiAgICAgICAgICAgICAgICAgICAgPyBzY3JvbGxiYXJXaWR0aC55IC8vIHVzZSBnbG9iYWwgYmVjYXVzZSBzY3JvbGxlciBtaWdodCBub3QgaGF2ZSBzY3JvbGxiYXJzIHlldCBidXQgd2lsbCBuZWVkIHRoZW0gaW4gZnV0dXJlXG4gICAgICAgICAgICAgICAgICAgIDogMCkpO1xuICAgICAgICAgICAgICAgIHNjcm9sbGVyQ2xpZW50SGVpZ2h0c1tzZWN0aW9uS2V5XSA9IE1hdGguZmxvb3IoaGFybmVzc0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZm9yY2VZU2Nyb2xsYmFycywgc2Nyb2xsZXJDbGllbnRXaWR0aHMsIHNjcm9sbGVyQ2xpZW50SGVpZ2h0cyB9O1xuICAgIH1cbn1cblNpbXBsZVNjcm9sbEdyaWQuYWRkU3RhdGVFcXVhbGl0eSh7XG4gICAgc2Nyb2xsZXJDbGllbnRXaWR0aHM6IGlzUHJvcHNFcXVhbCxcbiAgICBzY3JvbGxlckNsaWVudEhlaWdodHM6IGlzUHJvcHNFcXVhbCxcbn0pO1xuZnVuY3Rpb24gZ2V0U2VjdGlvbkJ5S2V5KHNlY3Rpb25zLCBrZXkpIHtcbiAgICBmb3IgKGxldCBzZWN0aW9uIG9mIHNlY3Rpb25zKSB7XG4gICAgICAgIGlmIChzZWN0aW9uLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gc2VjdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuY2xhc3MgRXZlbnRDb250YWluZXIgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVFbCA9IChlbCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICAgICAgc2V0RWxTZWcoZWwsIHRoaXMucHJvcHMuc2VnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgICAgIGNvbnN0IHsgc2VnIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgeyBldmVudFJhbmdlIH0gPSBzZWc7XG4gICAgICAgIGNvbnN0IHsgdWkgfSA9IGV2ZW50UmFuZ2U7XG4gICAgICAgIGNvbnN0IHJlbmRlclByb3BzID0ge1xuICAgICAgICAgICAgZXZlbnQ6IG5ldyBFdmVudEltcGwoY29udGV4dCwgZXZlbnRSYW5nZS5kZWYsIGV2ZW50UmFuZ2UuaW5zdGFuY2UpLFxuICAgICAgICAgICAgdmlldzogY29udGV4dC52aWV3QXBpLFxuICAgICAgICAgICAgdGltZVRleHQ6IHByb3BzLnRpbWVUZXh0LFxuICAgICAgICAgICAgdGV4dENvbG9yOiB1aS50ZXh0Q29sb3IsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHVpLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiB1aS5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgIGlzRHJhZ2dhYmxlOiAhcHJvcHMuZGlzYWJsZURyYWdnaW5nICYmIGNvbXB1dGVTZWdEcmFnZ2FibGUoc2VnLCBjb250ZXh0KSxcbiAgICAgICAgICAgIGlzU3RhcnRSZXNpemFibGU6ICFwcm9wcy5kaXNhYmxlUmVzaXppbmcgJiYgY29tcHV0ZVNlZ1N0YXJ0UmVzaXphYmxlKHNlZywgY29udGV4dCksXG4gICAgICAgICAgICBpc0VuZFJlc2l6YWJsZTogIXByb3BzLmRpc2FibGVSZXNpemluZyAmJiBjb21wdXRlU2VnRW5kUmVzaXphYmxlKHNlZyksXG4gICAgICAgICAgICBpc01pcnJvcjogQm9vbGVhbihwcm9wcy5pc0RyYWdnaW5nIHx8IHByb3BzLmlzUmVzaXppbmcgfHwgcHJvcHMuaXNEYXRlU2VsZWN0aW5nKSxcbiAgICAgICAgICAgIGlzU3RhcnQ6IEJvb2xlYW4oc2VnLmlzU3RhcnQpLFxuICAgICAgICAgICAgaXNFbmQ6IEJvb2xlYW4oc2VnLmlzRW5kKSxcbiAgICAgICAgICAgIGlzUGFzdDogQm9vbGVhbihwcm9wcy5pc1Bhc3QpLFxuICAgICAgICAgICAgaXNGdXR1cmU6IEJvb2xlYW4ocHJvcHMuaXNGdXR1cmUpLFxuICAgICAgICAgICAgaXNUb2RheTogQm9vbGVhbihwcm9wcy5pc1RvZGF5KSxcbiAgICAgICAgICAgIGlzU2VsZWN0ZWQ6IEJvb2xlYW4ocHJvcHMuaXNTZWxlY3RlZCksXG4gICAgICAgICAgICBpc0RyYWdnaW5nOiBCb29sZWFuKHByb3BzLmlzRHJhZ2dpbmcpLFxuICAgICAgICAgICAgaXNSZXNpemluZzogQm9vbGVhbihwcm9wcy5pc1Jlc2l6aW5nKSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KENvbnRlbnRDb250YWluZXIsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzIC8qIGNvbnRhaW5zIGNoaWxkcmVuICovLCB7IGVsUmVmOiB0aGlzLmhhbmRsZUVsLCBlbENsYXNzZXM6IFtcbiAgICAgICAgICAgICAgICAuLi5nZXRFdmVudENsYXNzTmFtZXMocmVuZGVyUHJvcHMpLFxuICAgICAgICAgICAgICAgIC4uLnNlZy5ldmVudFJhbmdlLnVpLmNsYXNzTmFtZXMsXG4gICAgICAgICAgICAgICAgLi4uKHByb3BzLmVsQ2xhc3NlcyB8fCBbXSksXG4gICAgICAgICAgICBdLCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGdlbmVyYXRvck5hbWU6IFwiZXZlbnRDb250ZW50XCIsIGN1c3RvbUdlbmVyYXRvcjogb3B0aW9ucy5ldmVudENvbnRlbnQsIGRlZmF1bHRHZW5lcmF0b3I6IHByb3BzLmRlZmF1bHRHZW5lcmF0b3IsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy5ldmVudENsYXNzTmFtZXMsIGRpZE1vdW50OiBvcHRpb25zLmV2ZW50RGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLmV2ZW50V2lsbFVubW91bnQgfSkpKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgICBpZiAodGhpcy5lbCAmJiB0aGlzLnByb3BzLnNlZyAhPT0gcHJldlByb3BzLnNlZykge1xuICAgICAgICAgICAgc2V0RWxTZWcodGhpcy5lbCwgdGhpcy5wcm9wcy5zZWcpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBzaG91bGQgbm90IGJlIGEgcHVyZWNvbXBvbmVudFxuY2xhc3MgU3RhbmRhcmRFdmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgICAgIGxldCB7IHNlZyB9ID0gcHJvcHM7XG4gICAgICAgIGxldCB7IHVpIH0gPSBzZWcuZXZlbnRSYW5nZTtcbiAgICAgICAgbGV0IHRpbWVGb3JtYXQgPSBvcHRpb25zLmV2ZW50VGltZUZvcm1hdCB8fCBwcm9wcy5kZWZhdWx0VGltZUZvcm1hdDtcbiAgICAgICAgbGV0IHRpbWVUZXh0ID0gYnVpbGRTZWdUaW1lVGV4dChzZWcsIHRpbWVGb3JtYXQsIGNvbnRleHQsIHByb3BzLmRlZmF1bHREaXNwbGF5RXZlbnRUaW1lLCBwcm9wcy5kZWZhdWx0RGlzcGxheUV2ZW50RW5kKTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEV2ZW50Q29udGFpbmVyLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcyAvKiBpbmNsdWRlcyBlbFJlZiAqLywgeyBlbFRhZzogXCJhXCIsIGVsU3R5bGU6IHtcbiAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogdWkuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB1aS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICB9LCBlbEF0dHJzOiBnZXRTZWdBbmNob3JBdHRycyhzZWcsIGNvbnRleHQpLCBkZWZhdWx0R2VuZXJhdG9yOiByZW5kZXJJbm5lckNvbnRlbnQkMSwgdGltZVRleHQ6IHRpbWVUZXh0IH0pLCAoSW5uZXJDb250ZW50LCBldmVudENvbnRlbnRBcmcpID0+IChjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChJbm5lckNvbnRlbnQsIHsgZWxUYWc6IFwiZGl2XCIsIGVsQ2xhc3NlczogWydmYy1ldmVudC1tYWluJ10sIGVsU3R5bGU6IHsgY29sb3I6IGV2ZW50Q29udGVudEFyZy50ZXh0Q29sb3IgfSB9KSxcbiAgICAgICAgICAgIEJvb2xlYW4oZXZlbnRDb250ZW50QXJnLmlzU3RhcnRSZXNpemFibGUpICYmIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXJlc2l6ZXIgZmMtZXZlbnQtcmVzaXplci1zdGFydFwiIH0pKSxcbiAgICAgICAgICAgIEJvb2xlYW4oZXZlbnRDb250ZW50QXJnLmlzRW5kUmVzaXphYmxlKSAmJiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1ldmVudC1yZXNpemVyIGZjLWV2ZW50LXJlc2l6ZXItZW5kXCIgfSkpKSkpKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZW5kZXJJbm5lckNvbnRlbnQkMShpbm5lclByb3BzKSB7XG4gICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LW1haW4tZnJhbWVcIiB9LFxuICAgICAgICBpbm5lclByb3BzLnRpbWVUZXh0ICYmIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXRpbWVcIiB9LCBpbm5lclByb3BzLnRpbWVUZXh0KSksXG4gICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZXZlbnQtdGl0bGUtY29udGFpbmVyXCIgfSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZXZlbnQtdGl0bGUgZmMtc3RpY2t5XCIgfSwgaW5uZXJQcm9wcy5ldmVudC50aXRsZSB8fCBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBcIlxcdTAwQTBcIikpKSkpO1xufVxuXG5jb25zdCBOb3dJbmRpY2F0b3JDb250YWluZXIgPSAocHJvcHMpID0+IChjcmVhdGVFbGVtZW50KFZpZXdDb250ZXh0VHlwZS5Db25zdW1lciwgbnVsbCwgKGNvbnRleHQpID0+IHtcbiAgICBsZXQgeyBvcHRpb25zIH0gPSBjb250ZXh0O1xuICAgIGxldCByZW5kZXJQcm9wcyA9IHtcbiAgICAgICAgaXNBeGlzOiBwcm9wcy5pc0F4aXMsXG4gICAgICAgIGRhdGU6IGNvbnRleHQuZGF0ZUVudi50b0RhdGUocHJvcHMuZGF0ZSksXG4gICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICB9O1xuICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChDb250ZW50Q29udGFpbmVyLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcyAvKiBpbmNsdWRlcyBjaGlsZHJlbiAqLywgeyBlbFRhZzogcHJvcHMuZWxUYWcgfHwgJ2RpdicsIHJlbmRlclByb3BzOiByZW5kZXJQcm9wcywgZ2VuZXJhdG9yTmFtZTogXCJub3dJbmRpY2F0b3JDb250ZW50XCIsIGN1c3RvbUdlbmVyYXRvcjogb3B0aW9ucy5ub3dJbmRpY2F0b3JDb250ZW50LCBjbGFzc05hbWVHZW5lcmF0b3I6IG9wdGlvbnMubm93SW5kaWNhdG9yQ2xhc3NOYW1lcywgZGlkTW91bnQ6IG9wdGlvbnMubm93SW5kaWNhdG9yRGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLm5vd0luZGljYXRvcldpbGxVbm1vdW50IH0pKSk7XG59KSk7XG5cbmNvbnN0IERBWV9OVU1fRk9STUFUID0gY3JlYXRlRm9ybWF0dGVyKHsgZGF5OiAnbnVtZXJpYycgfSk7XG5jbGFzcyBEYXlDZWxsQ29udGFpbmVyIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMucmVmaW5lUmVuZGVyUHJvcHMgPSBtZW1vaXplT2JqQXJnKHJlZmluZVJlbmRlclByb3BzKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgb3B0aW9ucyB9ID0gY29udGV4dDtcbiAgICAgICAgbGV0IHJlbmRlclByb3BzID0gdGhpcy5yZWZpbmVSZW5kZXJQcm9wcyh7XG4gICAgICAgICAgICBkYXRlOiBwcm9wcy5kYXRlLFxuICAgICAgICAgICAgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLFxuICAgICAgICAgICAgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSxcbiAgICAgICAgICAgIGlzTW9udGhTdGFydDogcHJvcHMuaXNNb250aFN0YXJ0IHx8IGZhbHNlLFxuICAgICAgICAgICAgc2hvd0RheU51bWJlcjogcHJvcHMuc2hvd0RheU51bWJlcixcbiAgICAgICAgICAgIGV4dHJhUmVuZGVyUHJvcHM6IHByb3BzLmV4dHJhUmVuZGVyUHJvcHMsXG4gICAgICAgICAgICB2aWV3QXBpOiBjb250ZXh0LnZpZXdBcGksXG4gICAgICAgICAgICBkYXRlRW52OiBjb250ZXh0LmRhdGVFbnYsXG4gICAgICAgICAgICBtb250aFN0YXJ0Rm9ybWF0OiBvcHRpb25zLm1vbnRoU3RhcnRGb3JtYXQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoQ29udGVudENvbnRhaW5lciwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMgLyogaW5jbHVkZXMgY2hpbGRyZW4gKi8sIHsgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgLi4uZ2V0RGF5Q2xhc3NOYW1lcyhyZW5kZXJQcm9wcywgY29udGV4dC50aGVtZSksXG4gICAgICAgICAgICAgICAgLi4uKHByb3BzLmVsQ2xhc3NlcyB8fCBbXSksXG4gICAgICAgICAgICBdLCBlbEF0dHJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByb3BzLmVsQXR0cnMpLCAocmVuZGVyUHJvcHMuaXNEaXNhYmxlZCA/IHt9IDogeyAnZGF0YS1kYXRlJzogZm9ybWF0RGF5U3RyaW5nKHByb3BzLmRhdGUpIH0pKSwgcmVuZGVyUHJvcHM6IHJlbmRlclByb3BzLCBnZW5lcmF0b3JOYW1lOiBcImRheUNlbGxDb250ZW50XCIsIGN1c3RvbUdlbmVyYXRvcjogb3B0aW9ucy5kYXlDZWxsQ29udGVudCwgZGVmYXVsdEdlbmVyYXRvcjogcHJvcHMuZGVmYXVsdEdlbmVyYXRvciwgY2xhc3NOYW1lR2VuZXJhdG9yOiBcbiAgICAgICAgICAgIC8vIGRvbid0IHVzZSBjdXN0b20gY2xhc3NOYW1lcyBpZiBkaXNhYmxlZFxuICAgICAgICAgICAgcmVuZGVyUHJvcHMuaXNEaXNhYmxlZCA/IHVuZGVmaW5lZCA6IG9wdGlvbnMuZGF5Q2VsbENsYXNzTmFtZXMsIGRpZE1vdW50OiBvcHRpb25zLmRheUNlbGxEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMuZGF5Q2VsbFdpbGxVbm1vdW50IH0pKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFzQ3VzdG9tRGF5Q2VsbENvbnRlbnQob3B0aW9ucykge1xuICAgIHJldHVybiBCb29sZWFuKG9wdGlvbnMuZGF5Q2VsbENvbnRlbnQgfHwgaGFzQ3VzdG9tUmVuZGVyaW5nSGFuZGxlcignZGF5Q2VsbENvbnRlbnQnLCBvcHRpb25zKSk7XG59XG5mdW5jdGlvbiByZWZpbmVSZW5kZXJQcm9wcyhyYXcpIHtcbiAgICBsZXQgeyBkYXRlLCBkYXRlRW52LCBkYXRlUHJvZmlsZSwgaXNNb250aFN0YXJ0IH0gPSByYXc7XG4gICAgbGV0IGRheU1ldGEgPSBnZXREYXRlTWV0YShkYXRlLCByYXcudG9kYXlSYW5nZSwgbnVsbCwgZGF0ZVByb2ZpbGUpO1xuICAgIGxldCBkYXlOdW1iZXJUZXh0ID0gcmF3LnNob3dEYXlOdW1iZXIgPyAoZGF0ZUVudi5mb3JtYXQoZGF0ZSwgaXNNb250aFN0YXJ0ID8gcmF3Lm1vbnRoU3RhcnRGb3JtYXQgOiBEQVlfTlVNX0ZPUk1BVCkpIDogJyc7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgZGF0ZTogZGF0ZUVudi50b0RhdGUoZGF0ZSksIHZpZXc6IHJhdy52aWV3QXBpIH0sIGRheU1ldGEpLCB7IGlzTW9udGhTdGFydCxcbiAgICAgICAgZGF5TnVtYmVyVGV4dCB9KSwgcmF3LmV4dHJhUmVuZGVyUHJvcHMpO1xufVxuXG5jbGFzcyBCZ0V2ZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgc2VnIH0gPSBwcm9wcztcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEV2ZW50Q29udGFpbmVyLCB7IGVsVGFnOiBcImRpdlwiLCBlbENsYXNzZXM6IFsnZmMtYmctZXZlbnQnXSwgZWxTdHlsZTogeyBiYWNrZ3JvdW5kQ29sb3I6IHNlZy5ldmVudFJhbmdlLnVpLmJhY2tncm91bmRDb2xvciB9LCBkZWZhdWx0R2VuZXJhdG9yOiByZW5kZXJJbm5lckNvbnRlbnQsIHNlZzogc2VnLCB0aW1lVGV4dDogXCJcIiwgaXNEcmFnZ2luZzogZmFsc2UsIGlzUmVzaXppbmc6IGZhbHNlLCBpc0RhdGVTZWxlY3Rpbmc6IGZhbHNlLCBpc1NlbGVjdGVkOiBmYWxzZSwgaXNQYXN0OiBwcm9wcy5pc1Bhc3QsIGlzRnV0dXJlOiBwcm9wcy5pc0Z1dHVyZSwgaXNUb2RheTogcHJvcHMuaXNUb2RheSwgZGlzYWJsZURyYWdnaW5nOiB0cnVlLCBkaXNhYmxlUmVzaXppbmc6IHRydWUgfSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbmRlcklubmVyQ29udGVudChwcm9wcykge1xuICAgIGxldCB7IHRpdGxlIH0gPSBwcm9wcy5ldmVudDtcbiAgICByZXR1cm4gdGl0bGUgJiYgKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZXZlbnQtdGl0bGVcIiB9LCBwcm9wcy5ldmVudC50aXRsZSkpO1xufVxuZnVuY3Rpb24gcmVuZGVyRmlsbChmaWxsVHlwZSkge1xuICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogYGZjLSR7ZmlsbFR5cGV9YCB9KSk7XG59XG5cbmNvbnN0IFdlZWtOdW1iZXJDb250YWluZXIgPSAocHJvcHMpID0+IChjcmVhdGVFbGVtZW50KFZpZXdDb250ZXh0VHlwZS5Db25zdW1lciwgbnVsbCwgKGNvbnRleHQpID0+IHtcbiAgICBsZXQgeyBkYXRlRW52LCBvcHRpb25zIH0gPSBjb250ZXh0O1xuICAgIGxldCB7IGRhdGUgfSA9IHByb3BzO1xuICAgIGxldCBmb3JtYXQgPSBvcHRpb25zLndlZWtOdW1iZXJGb3JtYXQgfHwgcHJvcHMuZGVmYXVsdEZvcm1hdDtcbiAgICBsZXQgbnVtID0gZGF0ZUVudi5jb21wdXRlV2Vla051bWJlcihkYXRlKTsgLy8gVE9ETzogc29tZWhvdyB1c2UgZm9yIGZvcm1hdHRpbmcgYXMgd2VsbD9cbiAgICBsZXQgdGV4dCA9IGRhdGVFbnYuZm9ybWF0KGRhdGUsIGZvcm1hdCk7XG4gICAgbGV0IHJlbmRlclByb3BzID0geyBudW0sIHRleHQsIGRhdGUgfTtcbiAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoQ29udGVudENvbnRhaW5lciAvLyB3aHkgaXNuJ3QgV2Vla051bWJlckNvbnRlbnRBcmcgYmVpbmcgYXV0by1kZXRlY3RlZD9cbiAgICAsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzIC8qIGluY2x1ZGVzIGNoaWxkcmVuICovLCB7IHJlbmRlclByb3BzOiByZW5kZXJQcm9wcywgZ2VuZXJhdG9yTmFtZTogXCJ3ZWVrTnVtYmVyQ29udGVudFwiLCBjdXN0b21HZW5lcmF0b3I6IG9wdGlvbnMud2Vla051bWJlckNvbnRlbnQsIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlcklubmVyLCBjbGFzc05hbWVHZW5lcmF0b3I6IG9wdGlvbnMud2Vla051bWJlckNsYXNzTmFtZXMsIGRpZE1vdW50OiBvcHRpb25zLndlZWtOdW1iZXJEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMud2Vla051bWJlcldpbGxVbm1vdW50IH0pKSk7XG59KSk7XG5mdW5jdGlvbiByZW5kZXJJbm5lcihpbm5lclByb3BzKSB7XG4gICAgcmV0dXJuIGlubmVyUHJvcHMudGV4dDtcbn1cblxuY29uc3QgUEFERElOR19GUk9NX1ZJRVdQT1JUID0gMTA7XG5jbGFzcyBQb3BvdmVyIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICB0aXRsZUlkOiBnZXRVbmlxdWVEb21JZCgpLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVJvb3RFbCA9IChlbCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yb290RWwgPSBlbDtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLmVsUmVmKSB7XG4gICAgICAgICAgICAgICAgc2V0UmVmKHRoaXMucHJvcHMuZWxSZWYsIGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gVHJpZ2dlcmVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzICphbnl3aGVyZSogaW4gdGhlIGRvY3VtZW50LCBmb3IgdGhlIGF1dG9IaWRlIGZlYXR1cmVcbiAgICAgICAgdGhpcy5oYW5kbGVEb2N1bWVudE1vdXNlRG93biA9IChldikgPT4ge1xuICAgICAgICAgICAgLy8gb25seSBoaWRlIHRoZSBwb3BvdmVyIGlmIHRoZSBjbGljayBoYXBwZW5lZCBvdXRzaWRlIHRoZSBwb3BvdmVyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXRFdmVudFRhcmdldFZpYVJvb3QoZXYpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJvb3RFbC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVDbG9zZUNsaWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlRG9jdW1lbnRLZXlEb3duID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXYua2V5ID09PSAnRXNjYXBlJykge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2xvc2VDbGljaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUNsb3NlQ2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBvbkNsb3NlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgaWYgKG9uQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICBvbkNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgdGhlbWUsIG9wdGlvbnMgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHsgcHJvcHMsIHN0YXRlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgY2xhc3NOYW1lcyA9IFtcbiAgICAgICAgICAgICdmYy1wb3BvdmVyJyxcbiAgICAgICAgICAgIHRoZW1lLmdldENsYXNzKCdwb3BvdmVyJyksXG4gICAgICAgIF0uY29uY2F0KHByb3BzLmV4dHJhQ2xhc3NOYW1lcyB8fCBbXSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVQb3J0YWwoY3JlYXRlRWxlbWVudChcImRpdlwiLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcy5leHRyYUF0dHJzLCB7IGlkOiBwcm9wcy5pZCwgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmpvaW4oJyAnKSwgXCJhcmlhLWxhYmVsbGVkYnlcIjogc3RhdGUudGl0bGVJZCwgcmVmOiB0aGlzLmhhbmRsZVJvb3RFbCB9KSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6ICdmYy1wb3BvdmVyLWhlYWRlciAnICsgdGhlbWUuZ2V0Q2xhc3MoJ3BvcG92ZXJIZWFkZXInKSB9LFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcImZjLXBvcG92ZXItdGl0bGVcIiwgaWQ6IHN0YXRlLnRpdGxlSWQgfSwgcHJvcHMudGl0bGUpLFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiAnZmMtcG9wb3Zlci1jbG9zZSAnICsgdGhlbWUuZ2V0SWNvbkNsYXNzKCdjbG9zZScpLCB0aXRsZTogb3B0aW9ucy5jbG9zZUhpbnQsIG9uQ2xpY2s6IHRoaXMuaGFuZGxlQ2xvc2VDbGljayB9KSksXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiAnZmMtcG9wb3Zlci1ib2R5ICcgKyB0aGVtZS5nZXRDbGFzcygncG9wb3ZlckNvbnRlbnQnKSB9LCBwcm9wcy5jaGlsZHJlbikpLCBwcm9wcy5wYXJlbnRFbCk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZURvY3VtZW50TW91c2VEb3duKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlRG9jdW1lbnRLZXlEb3duKTtcbiAgICAgICAgdGhpcy51cGRhdGVTaXplKCk7XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZURvY3VtZW50TW91c2VEb3duKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlRG9jdW1lbnRLZXlEb3duKTtcbiAgICB9XG4gICAgdXBkYXRlU2l6ZSgpIHtcbiAgICAgICAgbGV0IHsgaXNSdGwgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHsgYWxpZ25tZW50RWwsIGFsaWduR3JpZFRvcCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IHsgcm9vdEVsIH0gPSB0aGlzO1xuICAgICAgICBsZXQgYWxpZ25tZW50UmVjdCA9IGNvbXB1dGVDbGlwcGVkQ2xpZW50UmVjdChhbGlnbm1lbnRFbCk7XG4gICAgICAgIGlmIChhbGlnbm1lbnRSZWN0KSB7XG4gICAgICAgICAgICBsZXQgcG9wb3ZlckRpbXMgPSByb290RWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAvLyBwb3NpdGlvbiByZWxhdGl2ZSB0byB2aWV3cG9ydFxuICAgICAgICAgICAgbGV0IHBvcG92ZXJUb3AgPSBhbGlnbkdyaWRUb3BcbiAgICAgICAgICAgICAgICA/IGVsZW1lbnRDbG9zZXN0KGFsaWdubWVudEVsLCAnLmZjLXNjcm9sbGdyaWQnKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3BcbiAgICAgICAgICAgICAgICA6IGFsaWdubWVudFJlY3QudG9wO1xuICAgICAgICAgICAgbGV0IHBvcG92ZXJMZWZ0ID0gaXNSdGwgPyBhbGlnbm1lbnRSZWN0LnJpZ2h0IC0gcG9wb3ZlckRpbXMud2lkdGggOiBhbGlnbm1lbnRSZWN0LmxlZnQ7XG4gICAgICAgICAgICAvLyBjb25zdHJhaW5cbiAgICAgICAgICAgIHBvcG92ZXJUb3AgPSBNYXRoLm1heChwb3BvdmVyVG9wLCBQQURESU5HX0ZST01fVklFV1BPUlQpO1xuICAgICAgICAgICAgcG9wb3ZlckxlZnQgPSBNYXRoLm1pbihwb3BvdmVyTGVmdCwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIC0gUEFERElOR19GUk9NX1ZJRVdQT1JUIC0gcG9wb3ZlckRpbXMud2lkdGgpO1xuICAgICAgICAgICAgcG9wb3ZlckxlZnQgPSBNYXRoLm1heChwb3BvdmVyTGVmdCwgUEFERElOR19GUk9NX1ZJRVdQT1JUKTtcbiAgICAgICAgICAgIGxldCBvcmlnaW4gPSByb290RWwub2Zmc2V0UGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgYXBwbHlTdHlsZShyb290RWwsIHtcbiAgICAgICAgICAgICAgICB0b3A6IHBvcG92ZXJUb3AgLSBvcmlnaW4udG9wLFxuICAgICAgICAgICAgICAgIGxlZnQ6IHBvcG92ZXJMZWZ0IC0gb3JpZ2luLmxlZnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgTW9yZVBvcG92ZXIgZXh0ZW5kcyBEYXRlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVSb290RWwgPSAocm9vdEVsKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJvb3RFbCA9IHJvb3RFbDtcbiAgICAgICAgICAgIGlmIChyb290RWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCh0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgIGVsOiByb290RWwsXG4gICAgICAgICAgICAgICAgICAgIHVzZUV2ZW50Q2VudGVyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC51bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgb3B0aW9ucywgZGF0ZUVudiB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgc3RhcnREYXRlLCB0b2RheVJhbmdlLCBkYXRlUHJvZmlsZSB9ID0gcHJvcHM7XG4gICAgICAgIGxldCB0aXRsZSA9IGRhdGVFbnYuZm9ybWF0KHN0YXJ0RGF0ZSwgb3B0aW9ucy5kYXlQb3BvdmVyRm9ybWF0KTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KERheUNlbGxDb250YWluZXIsIHsgZWxSZWY6IHRoaXMuaGFuZGxlUm9vdEVsLCBkYXRlOiBzdGFydERhdGUsIGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogdG9kYXlSYW5nZSB9LCAoSW5uZXJDb250ZW50LCByZW5kZXJQcm9wcywgZWxBdHRycykgPT4gKGNyZWF0ZUVsZW1lbnQoUG9wb3ZlciwgeyBlbFJlZjogZWxBdHRycy5yZWYsIGlkOiBwcm9wcy5pZCwgdGl0bGU6IHRpdGxlLCBleHRyYUNsYXNzTmFtZXM6IFsnZmMtbW9yZS1wb3BvdmVyJ10uY29uY2F0KGVsQXR0cnMuY2xhc3NOYW1lIHx8IFtdKSwgZXh0cmFBdHRyczogZWxBdHRycyAvKiBUT0RPOiBtYWtlIHRoZXNlIHRpbWUtYmFzZWQgd2hlbiBub3Qgd2hvbGUtZGF5PyAqLywgcGFyZW50RWw6IHByb3BzLnBhcmVudEVsLCBhbGlnbm1lbnRFbDogcHJvcHMuYWxpZ25tZW50RWwsIGFsaWduR3JpZFRvcDogcHJvcHMuYWxpZ25HcmlkVG9wLCBvbkNsb3NlOiBwcm9wcy5vbkNsb3NlIH0sXG4gICAgICAgICAgICBoYXNDdXN0b21EYXlDZWxsQ29udGVudChvcHRpb25zKSAmJiAoY3JlYXRlRWxlbWVudChJbm5lckNvbnRlbnQsIHsgZWxUYWc6IFwiZGl2XCIsIGVsQ2xhc3NlczogWydmYy1tb3JlLXBvcG92ZXItbWlzYyddIH0pKSxcbiAgICAgICAgICAgIHByb3BzLmNoaWxkcmVuKSkpKTtcbiAgICB9XG4gICAgcXVlcnlIaXQocG9zaXRpb25MZWZ0LCBwb3NpdGlvblRvcCwgZWxXaWR0aCwgZWxIZWlnaHQpIHtcbiAgICAgICAgbGV0IHsgcm9vdEVsLCBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgaWYgKHBvc2l0aW9uTGVmdCA+PSAwICYmIHBvc2l0aW9uTGVmdCA8IGVsV2lkdGggJiZcbiAgICAgICAgICAgIHBvc2l0aW9uVG9wID49IDAgJiYgcG9zaXRpb25Ub3AgPCBlbEhlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsXG4gICAgICAgICAgICAgICAgZGF0ZVNwYW46IE9iamVjdC5hc3NpZ24oeyBhbGxEYXk6ICFwcm9wcy5mb3JjZVRpbWVkLCByYW5nZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHByb3BzLnN0YXJ0RGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogcHJvcHMuZW5kRGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgfSB9LCBwcm9wcy5leHRyYURhdGVTcGFuKSxcbiAgICAgICAgICAgICAgICBkYXlFbDogcm9vdEVsLFxuICAgICAgICAgICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgICAgICByaWdodDogZWxXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tOiBlbEhlaWdodCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGxheWVyOiAxLCAvLyBpbXBvcnRhbnQgd2hlbiBjb21wYXJpbmcgd2l0aCBoaXRzIGZyb20gb3RoZXIgY29tcG9uZW50c1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbmNsYXNzIE1vcmVMaW5rQ29udGFpbmVyIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBpc1BvcG92ZXJPcGVuOiBmYWxzZSxcbiAgICAgICAgICAgIHBvcG92ZXJJZDogZ2V0VW5pcXVlRG9tSWQoKSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVMaW5rRWwgPSAobGlua0VsKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxpbmtFbCA9IGxpbmtFbDtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLmVsUmVmKSB7XG4gICAgICAgICAgICAgICAgc2V0UmVmKHRoaXMucHJvcHMuZWxSZWYsIGxpbmtFbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlQ2xpY2sgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IHsgbW9yZUxpbmtDbGljayB9ID0gY29udGV4dC5vcHRpb25zO1xuICAgICAgICAgICAgbGV0IGRhdGUgPSBjb21wdXRlUmFuZ2UocHJvcHMpLnN0YXJ0O1xuICAgICAgICAgICAgZnVuY3Rpb24gYnVpbGRQdWJsaWNTZWcoc2VnKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgZGVmLCBpbnN0YW5jZSwgcmFuZ2UgfSA9IHNlZy5ldmVudFJhbmdlO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBuZXcgRXZlbnRJbXBsKGNvbnRleHQsIGRlZiwgaW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogY29udGV4dC5kYXRlRW52LnRvRGF0ZShyYW5nZS5zdGFydCksXG4gICAgICAgICAgICAgICAgICAgIGVuZDogY29udGV4dC5kYXRlRW52LnRvRGF0ZShyYW5nZS5lbmQpLFxuICAgICAgICAgICAgICAgICAgICBpc1N0YXJ0OiBzZWcuaXNTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgaXNFbmQ6IHNlZy5pc0VuZCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtb3JlTGlua0NsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgbW9yZUxpbmtDbGljayA9IG1vcmVMaW5rQ2xpY2soe1xuICAgICAgICAgICAgICAgICAgICBkYXRlLFxuICAgICAgICAgICAgICAgICAgICBhbGxEYXk6IEJvb2xlYW4ocHJvcHMuYWxsRGF5RGF0ZSksXG4gICAgICAgICAgICAgICAgICAgIGFsbFNlZ3M6IHByb3BzLmFsbFNlZ3MubWFwKGJ1aWxkUHVibGljU2VnKSxcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuU2VnczogcHJvcHMuaGlkZGVuU2Vncy5tYXAoYnVpbGRQdWJsaWNTZWcpLFxuICAgICAgICAgICAgICAgICAgICBqc0V2ZW50OiBldixcbiAgICAgICAgICAgICAgICAgICAgdmlldzogY29udGV4dC52aWV3QXBpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFtb3JlTGlua0NsaWNrIHx8IG1vcmVMaW5rQ2xpY2sgPT09ICdwb3BvdmVyJykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBpc1BvcG92ZXJPcGVuOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1vcmVMaW5rQ2xpY2sgPT09ICdzdHJpbmcnKSB7IC8vIGEgdmlldyBuYW1lXG4gICAgICAgICAgICAgICAgY29udGV4dC5jYWxlbmRhckFwaS56b29tVG8oZGF0ZSwgbW9yZUxpbmtDbGljayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUG9wb3ZlckNsb3NlID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGlzUG9wb3Zlck9wZW46IGZhbHNlIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBzdGF0ZSB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFZpZXdDb250ZXh0VHlwZS5Db25zdW1lciwgbnVsbCwgKGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgIGxldCB7IHZpZXdBcGksIG9wdGlvbnMsIGNhbGVuZGFyQXBpIH0gPSBjb250ZXh0O1xuICAgICAgICAgICAgbGV0IHsgbW9yZUxpbmtUZXh0IH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgbGV0IHsgbW9yZUNudCB9ID0gcHJvcHM7XG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSBjb21wdXRlUmFuZ2UocHJvcHMpO1xuICAgICAgICAgICAgbGV0IHRleHQgPSB0eXBlb2YgbW9yZUxpbmtUZXh0ID09PSAnZnVuY3Rpb24nIC8vIFRPRE86IGV2ZW50dWFsbHkgdXNlIGZvcm1hdFdpdGhPcmRpbmFsc1xuICAgICAgICAgICAgICAgID8gbW9yZUxpbmtUZXh0LmNhbGwoY2FsZW5kYXJBcGksIG1vcmVDbnQpXG4gICAgICAgICAgICAgICAgOiBgKyR7bW9yZUNudH0gJHttb3JlTGlua1RleHR9YDtcbiAgICAgICAgICAgIGxldCBoaW50ID0gZm9ybWF0V2l0aE9yZGluYWxzKG9wdGlvbnMubW9yZUxpbmtIaW50LCBbbW9yZUNudF0sIHRleHQpO1xuICAgICAgICAgICAgbGV0IHJlbmRlclByb3BzID0ge1xuICAgICAgICAgICAgICAgIG51bTogbW9yZUNudCxcbiAgICAgICAgICAgICAgICBzaG9ydFRleHQ6IGArJHttb3JlQ250fWAsXG4gICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICB2aWV3OiB2aWV3QXBpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCxcbiAgICAgICAgICAgICAgICBCb29sZWFuKHByb3BzLm1vcmVDbnQpICYmIChjcmVhdGVFbGVtZW50KENvbnRlbnRDb250YWluZXIsIHsgZWxUYWc6IHByb3BzLmVsVGFnIHx8ICdhJywgZWxSZWY6IHRoaXMuaGFuZGxlTGlua0VsLCBlbENsYXNzZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLihwcm9wcy5lbENsYXNzZXMgfHwgW10pLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLW1vcmUtbGluaycsXG4gICAgICAgICAgICAgICAgICAgIF0sIGVsU3R5bGU6IHByb3BzLmVsU3R5bGUsIGVsQXR0cnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcm9wcy5lbEF0dHJzKSwgY3JlYXRlQXJpYUNsaWNrQXR0cnModGhpcy5oYW5kbGVDbGljaykpLCB7IHRpdGxlOiBoaW50LCAnYXJpYS1leHBhbmRlZCc6IHN0YXRlLmlzUG9wb3Zlck9wZW4sICdhcmlhLWNvbnRyb2xzJzogc3RhdGUuaXNQb3BvdmVyT3BlbiA/IHN0YXRlLnBvcG92ZXJJZCA6ICcnIH0pLCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGdlbmVyYXRvck5hbWU6IFwibW9yZUxpbmtDb250ZW50XCIsIGN1c3RvbUdlbmVyYXRvcjogb3B0aW9ucy5tb3JlTGlua0NvbnRlbnQsIGRlZmF1bHRHZW5lcmF0b3I6IHByb3BzLmRlZmF1bHRHZW5lcmF0b3IgfHwgcmVuZGVyTW9yZUxpbmtJbm5lciwgY2xhc3NOYW1lR2VuZXJhdG9yOiBvcHRpb25zLm1vcmVMaW5rQ2xhc3NOYW1lcywgZGlkTW91bnQ6IG9wdGlvbnMubW9yZUxpbmtEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMubW9yZUxpbmtXaWxsVW5tb3VudCB9LCBwcm9wcy5jaGlsZHJlbikpLFxuICAgICAgICAgICAgICAgIHN0YXRlLmlzUG9wb3Zlck9wZW4gJiYgKGNyZWF0ZUVsZW1lbnQoTW9yZVBvcG92ZXIsIHsgaWQ6IHN0YXRlLnBvcG92ZXJJZCwgc3RhcnREYXRlOiByYW5nZS5zdGFydCwgZW5kRGF0ZTogcmFuZ2UuZW5kLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsIGV4dHJhRGF0ZVNwYW46IHByb3BzLmV4dHJhRGF0ZVNwYW4sIHBhcmVudEVsOiB0aGlzLnBhcmVudEVsLCBhbGlnbm1lbnRFbDogcHJvcHMuYWxpZ25tZW50RWxSZWYgP1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMuYWxpZ25tZW50RWxSZWYuY3VycmVudCA6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmtFbCwgYWxpZ25HcmlkVG9wOiBwcm9wcy5hbGlnbkdyaWRUb3AsIGZvcmNlVGltZWQ6IHByb3BzLmZvcmNlVGltZWQsIG9uQ2xvc2U6IHRoaXMuaGFuZGxlUG9wb3ZlckNsb3NlIH0sIHByb3BzLnBvcG92ZXJDb250ZW50KCkpKSkpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVBhcmVudEVsKCk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVQYXJlbnRFbCgpO1xuICAgIH1cbiAgICB1cGRhdGVQYXJlbnRFbCgpIHtcbiAgICAgICAgaWYgKHRoaXMubGlua0VsKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudEVsID0gZWxlbWVudENsb3Nlc3QodGhpcy5saW5rRWwsICcuZmMtdmlldy1oYXJuZXNzJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiByZW5kZXJNb3JlTGlua0lubmVyKHByb3BzKSB7XG4gICAgcmV0dXJuIHByb3BzLnRleHQ7XG59XG5mdW5jdGlvbiBjb21wdXRlUmFuZ2UocHJvcHMpIHtcbiAgICBpZiAocHJvcHMuYWxsRGF5RGF0ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhcnQ6IHByb3BzLmFsbERheURhdGUsXG4gICAgICAgICAgICBlbmQ6IGFkZERheXMocHJvcHMuYWxsRGF5RGF0ZSwgMSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGxldCB7IGhpZGRlblNlZ3MgfSA9IHByb3BzO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiBjb21wdXRlRWFybGllc3RTZWdTdGFydChoaWRkZW5TZWdzKSxcbiAgICAgICAgZW5kOiBjb21wdXRlTGF0ZXN0U2VnRW5kKGhpZGRlblNlZ3MpLFxuICAgIH07XG59XG5mdW5jdGlvbiBjb21wdXRlRWFybGllc3RTZWdTdGFydChzZWdzKSB7XG4gICAgcmV0dXJuIHNlZ3MucmVkdWNlKHBpY2tFYXJsaWVzdFN0YXJ0KS5ldmVudFJhbmdlLnJhbmdlLnN0YXJ0O1xufVxuZnVuY3Rpb24gcGlja0VhcmxpZXN0U3RhcnQoc2VnMCwgc2VnMSkge1xuICAgIHJldHVybiBzZWcwLmV2ZW50UmFuZ2UucmFuZ2Uuc3RhcnQgPCBzZWcxLmV2ZW50UmFuZ2UucmFuZ2Uuc3RhcnQgPyBzZWcwIDogc2VnMTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVMYXRlc3RTZWdFbmQoc2Vncykge1xuICAgIHJldHVybiBzZWdzLnJlZHVjZShwaWNrTGF0ZXN0RW5kKS5ldmVudFJhbmdlLnJhbmdlLmVuZDtcbn1cbmZ1bmN0aW9uIHBpY2tMYXRlc3RFbmQoc2VnMCwgc2VnMSkge1xuICAgIHJldHVybiBzZWcwLmV2ZW50UmFuZ2UucmFuZ2UuZW5kID4gc2VnMS5ldmVudFJhbmdlLnJhbmdlLmVuZCA/IHNlZzAgOiBzZWcxO1xufVxuXG5jbGFzcyBTdG9yZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSBbXTtcbiAgICB9XG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gdmFsdWU7XG4gICAgICAgIGZvciAobGV0IGhhbmRsZXIgb2YgdGhpcy5oYW5kbGVycykge1xuICAgICAgICAgICAgaGFuZGxlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3Vic2NyaWJlKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaGFuZGxlcih0aGlzLmN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qXG5TdWJzY3JpYmVycyB3aWxsIGdldCBhIExJU1Qgb2YgQ3VzdG9tUmVuZGVyaW5nc1xuKi9cbmNsYXNzIEN1c3RvbVJlbmRlcmluZ1N0b3JlIGV4dGVuZHMgU3RvcmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm1hcCA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgLy8gZm9yIGNvbnNpc3RlbnQgb3JkZXJcbiAgICBoYW5kbGUoY3VzdG9tUmVuZGVyaW5nKSB7XG4gICAgICAgIGNvbnN0IHsgbWFwIH0gPSB0aGlzO1xuICAgICAgICBsZXQgdXBkYXRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoY3VzdG9tUmVuZGVyaW5nLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICBtYXAuc2V0KGN1c3RvbVJlbmRlcmluZy5pZCwgY3VzdG9tUmVuZGVyaW5nKTtcbiAgICAgICAgICAgIHVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1hcC5oYXMoY3VzdG9tUmVuZGVyaW5nLmlkKSkge1xuICAgICAgICAgICAgbWFwLmRlbGV0ZShjdXN0b21SZW5kZXJpbmcuaWQpO1xuICAgICAgICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KG1hcCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCB7IGVsZW1lbnRDbG9zZXN0IGFzICQsIG1lbW9pemVPYmpBcmcgYXMgQSwgQmFzZUNvbXBvbmVudCBhcyBCLCBDb250ZW50Q29udGFpbmVyIGFzIEMsIERlbGF5ZWRSdW5uZXIgYXMgRCwgaXNQcm9wc0VxdWFsIGFzIEUsIEVtaXR0ZXIgYXMgRiwgZ2V0SW5pdGlhbERhdGUgYXMgRywgcmFuZ2VDb250YWluc01hcmtlciBhcyBILCBjcmVhdGVFbXB0eUV2ZW50U3RvcmUgYXMgSSwgcmVkdWNlQ3VycmVudERhdGUgYXMgSiwgcmVkdWNlRXZlbnRTdG9yZSBhcyBLLCByZXpvbmVFdmVudFN0b3JlRGF0ZXMgYXMgTCwgbWVyZ2VSYXdPcHRpb25zIGFzIE0sIEJBU0VfT1BUSU9OX1JFRklORVJTIGFzIE4sIENBTEVOREFSX0xJU1RFTkVSX1JFRklORVJTIGFzIE8sIENBTEVOREFSX09QVElPTl9SRUZJTkVSUyBhcyBQLCBDT01QTEVYX09QVElPTl9DT01QQVJBVE9SUyBhcyBRLCBWSUVXX09QVElPTl9SRUZJTkVSUyBhcyBSLCBEYXRlRW52IGFzIFMsIFRoZW1lIGFzIFQsIERhdGVQcm9maWxlR2VuZXJhdG9yIGFzIFUsIFZpZXdDb250ZXh0VHlwZSBhcyBWLCBjcmVhdGVFdmVudFVpIGFzIFcsIHBhcnNlQnVzaW5lc3NIb3VycyBhcyBYLCBzZXRSZWYgYXMgWSwgSW50ZXJhY3Rpb24gYXMgWiwgZ2V0RWxTZWcgYXMgXywgbWFwSGFzaCBhcyBhLCBnZXRTbG90Q2xhc3NOYW1lcyBhcyBhJCwgRXZlbnRJbXBsIGFzIGEwLCBsaXN0ZW5CeVNlbGVjdG9yIGFzIGExLCBsaXN0ZW5Ub0hvdmVyQnlTZWxlY3RvciBhcyBhMiwgUHVyZUNvbXBvbmVudCBhcyBhMywgYnVpbGRWaWV3Q29udGV4dCBhcyBhNCwgZ2V0VW5pcXVlRG9tSWQgYXMgYTUsIHBhcnNlSW50ZXJhY3Rpb25TZXR0aW5ncyBhcyBhNiwgaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlIGFzIGE3LCBnZXROb3cgYXMgYTgsIENhbGVuZGFySW1wbCBhcyBhOSwgZGlmZkRhdGVzIGFzIGFBLCByZW1vdmVFeGFjdCBhcyBhQiwgbWVtb2l6ZUFycmF5bGlrZSBhcyBhQywgbWVtb2l6ZUhhc2hsaWtlIGFzIGFELCBpbnRlcnNlY3RSZWN0cyBhcyBhRSwgcG9pbnRJbnNpZGVSZWN0IGFzIGFGLCBjb25zdHJhaW5Qb2ludCBhcyBhRywgZ2V0UmVjdENlbnRlciBhcyBhSCwgZGlmZlBvaW50cyBhcyBhSSwgdHJhbnNsYXRlUmVjdCBhcyBhSiwgY29tcGFyZU9ianMgYXMgYUssIGNvbGxlY3RGcm9tSGFzaCBhcyBhTCwgZmluZEVsZW1lbnRzIGFzIGFNLCBmaW5kRGlyZWN0Q2hpbGRyZW4gYXMgYU4sIHJlbW92ZUVsZW1lbnQgYXMgYU8sIGFwcGx5U3R5bGUgYXMgYVAsIGVsZW1lbnRNYXRjaGVzIGFzIGFRLCBnZXRFdmVudFRhcmdldFZpYVJvb3QgYXMgYVIsIHBhcnNlQ2xhc3NOYW1lcyBhcyBhUywgZ2V0Q2FuVkdyb3dXaXRoaW5DZWxsIGFzIGFULCBtZXJnZUV2ZW50U3RvcmVzIGFzIGFVLCBnZXRSZWxldmFudEV2ZW50cyBhcyBhViwgZXZlbnRUdXBsZVRvU3RvcmUgYXMgYVcsIGNvbWJpbmVFdmVudFVpcyBhcyBhWCwgU3BsaXR0ZXIgYXMgYVksIGdldERheUNsYXNzTmFtZXMgYXMgYVosIGdldERhdGVNZXRhIGFzIGFfLCBmbHVzaFN5bmMgYXMgYWEsIENhbGVuZGFyUm9vdCBhcyBhYiwgUmVuZGVySWQgYXMgYWMsIGVuc3VyZUVsSGFzU3R5bGVzIGFzIGFkLCBhcHBseVN0eWxlUHJvcCBhcyBhZSwgc2xpY2VFdmVudFN0b3JlIGFzIGFmLCBKc29uUmVxdWVzdEVycm9yIGFzIGFnLCBjcmVhdGVDb250ZXh0IGFzIGFoLCByZWZpbmVQcm9wcyBhcyBhaSwgY3JlYXRlRXZlbnRJbnN0YW5jZSBhcyBhaiwgcGFyc2VFdmVudERlZiBhcyBhaywgcmVmaW5lRXZlbnREZWYgYXMgYWwsIHBhZFN0YXJ0IGFzIGFtLCBpc0ludCBhcyBhbiwgcGFyc2VGaWVsZFNwZWNzIGFzIGFvLCBjb21wYXJlQnlGaWVsZFNwZWNzIGFzIGFwLCBmbGV4aWJsZUNvbXBhcmUgYXMgYXEsIHByZXZlbnRTZWxlY3Rpb24gYXMgYXIsIGFsbG93U2VsZWN0aW9uIGFzIGFzLCBwcmV2ZW50Q29udGV4dE1lbnUgYXMgYXQsIGFsbG93Q29udGV4dE1lbnUgYXMgYXUsIGNvbXBhcmVOdW1iZXJzIGFzIGF2LCBlbmFibGVDdXJzb3IgYXMgYXcsIGRpc2FibGVDdXJzb3IgYXMgYXgsIGNvbXB1dGVWaXNpYmxlRGF5UmFuZ2UgYXMgYXksIGlzTXVsdGlEYXlSYW5nZSBhcyBheiwgYnVpbGRWaWV3Q2xhc3NOYW1lcyBhcyBiLCBTaW1wbGVTY3JvbGxHcmlkIGFzIGIkLCBidWlsZE5hdkxpbmtBdHRycyBhcyBiMCwgcHJldmVudERlZmF1bHQgYXMgYjEsIHdoZW5UcmFuc2l0aW9uRG9uZSBhcyBiMiwgY29tcHV0ZUlubmVyUmVjdCBhcyBiMywgY29tcHV0ZUVkZ2VzIGFzIGI0LCBnZXRDbGlwcGluZ1BhcmVudHMgYXMgYjUsIGNvbXB1dGVSZWN0IGFzIGI2LCByYW5nZXNFcXVhbCBhcyBiNywgcmFuZ2VzSW50ZXJzZWN0IGFzIGI4LCByYW5nZUNvbnRhaW5zUmFuZ2UgYXMgYjksIFNlZ0hpZXJhcmNoeSBhcyBiQSwgYnVpbGRFbnRyeUtleSBhcyBiQiwgZ2V0RW50cnlTcGFuRW5kIGFzIGJDLCBiaW5hcnlTZWFyY2ggYXMgYkQsIGdyb3VwSW50ZXJzZWN0aW5nRW50cmllcyBhcyBiRSwgaW50ZXJzZWN0U3BhbnMgYXMgYkYsIGludGVyYWN0aW9uU2V0dGluZ3NUb1N0b3JlIGFzIGJHLCBFbGVtZW50RHJhZ2dpbmcgYXMgYkgsIGNvbmZpZyBhcyBiSSwgcGFyc2VEcmFnTWV0YSBhcyBiSiwgRGF5SGVhZGVyIGFzIGJLLCBjb21wdXRlRmFsbGJhY2tIZWFkZXJGb3JtYXQgYXMgYkwsIFRhYmxlRGF0ZUNlbGwgYXMgYk0sIFRhYmxlRG93Q2VsbCBhcyBiTiwgRGF5U2VyaWVzTW9kZWwgYXMgYk8sIGhhc0JnUmVuZGVyaW5nIGFzIGJQLCBidWlsZFNlZ1RpbWVUZXh0IGFzIGJRLCBzb3J0RXZlbnRTZWdzIGFzIGJSLCBnZXRTZWdNZXRhIGFzIGJTLCBidWlsZEV2ZW50UmFuZ2VLZXkgYXMgYlQsIGdldFNlZ0FuY2hvckF0dHJzIGFzIGJVLCBEYXlUYWJsZU1vZGVsIGFzIGJWLCBTbGljZXIgYXMgYlcsIGFwcGx5TXV0YXRpb25Ub0V2ZW50U3RvcmUgYXMgYlgsIGlzUHJvcHNWYWxpZCBhcyBiWSwgaXNJbnRlcmFjdGlvblZhbGlkIGFzIGJaLCBpc0RhdGVTZWxlY3Rpb25WYWxpZCBhcyBiXywgUG9zaXRpb25DYWNoZSBhcyBiYSwgU2Nyb2xsQ29udHJvbGxlciBhcyBiYiwgRWxlbWVudFNjcm9sbENvbnRyb2xsZXIgYXMgYmMsIFdpbmRvd1Njcm9sbENvbnRyb2xsZXIgYXMgYmQsIERhdGVDb21wb25lbnQgYXMgYmUsIGlzRGF0ZVNwYW5zRXF1YWwgYXMgYmYsIGFkZE1zIGFzIGJnLCBhZGRXZWVrcyBhcyBiaCwgZGlmZldlZWtzIGFzIGJpLCBkaWZmV2hvbGVXZWVrcyBhcyBiaiwgZGlmZkRheUFuZFRpbWUgYXMgYmssIGRpZmZEYXlzIGFzIGJsLCBpc1ZhbGlkRGF0ZSBhcyBibSwgYXNDbGVhbkRheXMgYXMgYm4sIG11bHRpcGx5RHVyYXRpb24gYXMgYm8sIGFkZER1cmF0aW9ucyBhcyBicCwgYXNSb3VnaE1pbnV0ZXMgYXMgYnEsIGFzUm91Z2hTZWNvbmRzIGFzIGJyLCBhc1JvdWdoTXMgYXMgYnMsIHdob2xlRGl2aWRlRHVyYXRpb25zIGFzIGJ0LCBmb3JtYXRJc29UaW1lU3RyaW5nIGFzIGJ1LCBmb3JtYXREYXlTdHJpbmcgYXMgYnYsIGJ1aWxkSXNvU3RyaW5nIGFzIGJ3LCBmb3JtYXRJc29Nb250aFN0ciBhcyBieCwgTmFtZWRUaW1lWm9uZUltcGwgYXMgYnksIHBhcnNlIGFzIGJ6LCBncmVhdGVzdER1cmF0aW9uRGVub21pbmF0b3IgYXMgYywgaGFzU2hyaW5rV2lkdGggYXMgYzAsIHJlbmRlck1pY3JvQ29sR3JvdXAgYXMgYzEsIGdldFNjcm9sbEdyaWRDbGFzc05hbWVzIGFzIGMyLCBnZXRTZWN0aW9uQ2xhc3NOYW1lcyBhcyBjMywgZ2V0U2VjdGlvbkhhc0xpcXVpZEhlaWdodCBhcyBjNCwgZ2V0QWxsb3dZU2Nyb2xsaW5nIGFzIGM1LCByZW5kZXJDaHVua0NvbnRlbnQgYXMgYzYsIGNvbXB1dGVTaHJpbmtXaWR0aCBhcyBjNywgc2FuaXRpemVTaHJpbmtXaWR0aCBhcyBjOCwgaXNDb2xQcm9wc0VxdWFsIGFzIGM5LCByZW5kZXJTY3JvbGxTaGltIGFzIGNhLCBnZXRTdGlja3lGb290ZXJTY3JvbGxiYXIgYXMgY2IsIGdldFN0aWNreUhlYWRlckRhdGVzIGFzIGNjLCBTY3JvbGxlciBhcyBjZCwgZ2V0U2Nyb2xsYmFyV2lkdGhzIGFzIGNlLCBSZWZNYXAgYXMgY2YsIGdldElzUnRsU2Nyb2xsYmFyT25MZWZ0IGFzIGNnLCBOb3dUaW1lciBhcyBjaCwgU2Nyb2xsUmVzcG9uZGVyIGFzIGNpLCBTdGFuZGFyZEV2ZW50IGFzIGNqLCBOb3dJbmRpY2F0b3JDb250YWluZXIgYXMgY2ssIERheUNlbGxDb250YWluZXIgYXMgY2wsIGhhc0N1c3RvbURheUNlbGxDb250ZW50IGFzIGNtLCBFdmVudENvbnRhaW5lciBhcyBjbiwgcmVuZGVyRmlsbCBhcyBjbywgQmdFdmVudCBhcyBjcCwgV2Vla051bWJlckNvbnRhaW5lciBhcyBjcSwgTW9yZUxpbmtDb250YWluZXIgYXMgY3IsIGNvbXB1dGVFYXJsaWVzdFNlZ1N0YXJ0IGFzIGNzLCBWaWV3Q29udGFpbmVyIGFzIGN0LCB0cmlnZ2VyRGF0ZVNlbGVjdCBhcyBjdSwgZ2V0RGVmYXVsdEV2ZW50RW5kIGFzIGN2LCBpbmplY3RTdHlsZXMgYXMgY3csIGJ1aWxkRWxBdHRycyBhcyBjeCwgQ3VzdG9tUmVuZGVyaW5nU3RvcmUgYXMgY3ksIGNyZWF0ZUR1cmF0aW9uIGFzIGQsIEJBU0VfT1BUSU9OX0RFRkFVTFRTIGFzIGUsIGFycmF5VG9IYXNoIGFzIGYsIGd1aWQgYXMgZywgZmlsdGVySGFzaCBhcyBoLCBpc0FycmF5c0VxdWFsIGFzIGksIGJ1aWxkRXZlbnRTb3VyY2VSZWZpbmVycyBhcyBqLCBmb3JtYXRXaXRoT3JkaW5hbHMgYXMgaywgYnVpbGRSYW5nZUFwaVdpdGhUaW1lWm9uZSBhcyBsLCBtZXJnZVByb3BzIGFzIG0sIGlkZW50aXR5IGFzIG4sIGludGVyc2VjdFJhbmdlcyBhcyBvLCBwYXJzZUV2ZW50U291cmNlIGFzIHAsIHN0YXJ0T2ZEYXkgYXMgcSwgcmVxdWVzdEpzb24gYXMgciwgc3VidHJhY3REdXJhdGlvbnMgYXMgcywgYWRkRGF5cyBhcyB0LCB1bnByb21pc2lmeSBhcyB1LCBoYXNoVmFsdWVzVG9BcnJheSBhcyB2LCBidWlsZEV2ZW50QXBpcyBhcyB3LCBjcmVhdGVGb3JtYXR0ZXIgYXMgeCwgZGlmZldob2xlRGF5cyBhcyB5LCBtZW1vaXplIGFzIHogfTtcbiIsICJpbXBvcnQgeyBtIGFzIG1lcmdlUHJvcHMsIGcgYXMgZ3VpZCwgaSBhcyBpc0FycmF5c0VxdWFsLCBUIGFzIFRoZW1lLCBhIGFzIG1hcEhhc2gsIEIgYXMgQmFzZUNvbXBvbmVudCwgViBhcyBWaWV3Q29udGV4dFR5cGUsIEMgYXMgQ29udGVudENvbnRhaW5lciwgYiBhcyBidWlsZFZpZXdDbGFzc05hbWVzLCBjIGFzIGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvciwgZCBhcyBjcmVhdGVEdXJhdGlvbiwgZSBhcyBCQVNFX09QVElPTl9ERUZBVUxUUywgZiBhcyBhcnJheVRvSGFzaCwgaCBhcyBmaWx0ZXJIYXNoLCBqIGFzIGJ1aWxkRXZlbnRTb3VyY2VSZWZpbmVycywgcCBhcyBwYXJzZUV2ZW50U291cmNlLCBrIGFzIGZvcm1hdFdpdGhPcmRpbmFscywgdSBhcyB1bnByb21pc2lmeSwgbCBhcyBidWlsZFJhbmdlQXBpV2l0aFRpbWVab25lLCBuIGFzIGlkZW50aXR5LCByIGFzIHJlcXVlc3RKc29uLCBzIGFzIHN1YnRyYWN0RHVyYXRpb25zLCBvIGFzIGludGVyc2VjdFJhbmdlcywgcSBhcyBzdGFydE9mRGF5LCB0IGFzIGFkZERheXMsIHYgYXMgaGFzaFZhbHVlc1RvQXJyYXksIHcgYXMgYnVpbGRFdmVudEFwaXMsIEQgYXMgRGVsYXllZFJ1bm5lciwgeCBhcyBjcmVhdGVGb3JtYXR0ZXIsIHkgYXMgZGlmZldob2xlRGF5cywgeiBhcyBtZW1vaXplLCBBIGFzIG1lbW9pemVPYmpBcmcsIEUgYXMgaXNQcm9wc0VxdWFsLCBGIGFzIEVtaXR0ZXIsIEcgYXMgZ2V0SW5pdGlhbERhdGUsIEggYXMgcmFuZ2VDb250YWluc01hcmtlciwgSSBhcyBjcmVhdGVFbXB0eUV2ZW50U3RvcmUsIEogYXMgcmVkdWNlQ3VycmVudERhdGUsIEsgYXMgcmVkdWNlRXZlbnRTdG9yZSwgTCBhcyByZXpvbmVFdmVudFN0b3JlRGF0ZXMsIE0gYXMgbWVyZ2VSYXdPcHRpb25zLCBOIGFzIEJBU0VfT1BUSU9OX1JFRklORVJTLCBPIGFzIENBTEVOREFSX0xJU1RFTkVSX1JFRklORVJTLCBQIGFzIENBTEVOREFSX09QVElPTl9SRUZJTkVSUywgUSBhcyBDT01QTEVYX09QVElPTl9DT01QQVJBVE9SUywgUiBhcyBWSUVXX09QVElPTl9SRUZJTkVSUywgUyBhcyBEYXRlRW52LCBVIGFzIERhdGVQcm9maWxlR2VuZXJhdG9yLCBXIGFzIGNyZWF0ZUV2ZW50VWksIFggYXMgcGFyc2VCdXNpbmVzc0hvdXJzLCBZIGFzIHNldFJlZiwgWiBhcyBJbnRlcmFjdGlvbiwgXyBhcyBnZXRFbFNlZywgJCBhcyBlbGVtZW50Q2xvc2VzdCwgYTAgYXMgRXZlbnRJbXBsLCBhMSBhcyBsaXN0ZW5CeVNlbGVjdG9yLCBhMiBhcyBsaXN0ZW5Ub0hvdmVyQnlTZWxlY3RvciwgYTMgYXMgUHVyZUNvbXBvbmVudCwgYTQgYXMgYnVpbGRWaWV3Q29udGV4dCwgYTUgYXMgZ2V0VW5pcXVlRG9tSWQsIGE2IGFzIHBhcnNlSW50ZXJhY3Rpb25TZXR0aW5ncywgYTcgYXMgaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlLCBhOCBhcyBnZXROb3csIGE5IGFzIENhbGVuZGFySW1wbCwgYWEgYXMgZmx1c2hTeW5jLCBhYiBhcyBDYWxlbmRhclJvb3QsIGFjIGFzIFJlbmRlcklkLCBhZCBhcyBlbnN1cmVFbEhhc1N0eWxlcywgYWUgYXMgYXBwbHlTdHlsZVByb3AsIGFmIGFzIHNsaWNlRXZlbnRTdG9yZSB9IGZyb20gJy4vaW50ZXJuYWwtY29tbW9uLmpzJztcbmV4cG9ydCB7IGFnIGFzIEpzb25SZXF1ZXN0RXJyb3IgfSBmcm9tICcuL2ludGVybmFsLWNvbW1vbi5qcyc7XG5pbXBvcnQgeyBjcmVhdGVFbGVtZW50LCBjcmVhdGVSZWYsIEZyYWdtZW50LCByZW5kZXIgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0ICdwcmVhY3QvY29tcGF0JztcblxuY29uc3QgZ2xvYmFsTG9jYWxlcyA9IFtdO1xuXG5jb25zdCBNSU5JTUFMX1JBV19FTl9MT0NBTEUgPSB7XG4gICAgY29kZTogJ2VuJyxcbiAgICB3ZWVrOiB7XG4gICAgICAgIGRvdzogMCxcbiAgICAgICAgZG95OiA0LCAvLyA0IGRheXMgbmVlZCB0byBiZSB3aXRoaW4gdGhlIHllYXIgdG8gYmUgY29uc2lkZXJlZCB0aGUgZmlyc3Qgd2Vla1xuICAgIH0sXG4gICAgZGlyZWN0aW9uOiAnbHRyJyxcbiAgICBidXR0b25UZXh0OiB7XG4gICAgICAgIHByZXY6ICdwcmV2JyxcbiAgICAgICAgbmV4dDogJ25leHQnLFxuICAgICAgICBwcmV2WWVhcjogJ3ByZXYgeWVhcicsXG4gICAgICAgIG5leHRZZWFyOiAnbmV4dCB5ZWFyJyxcbiAgICAgICAgeWVhcjogJ3llYXInLFxuICAgICAgICB0b2RheTogJ3RvZGF5JyxcbiAgICAgICAgbW9udGg6ICdtb250aCcsXG4gICAgICAgIHdlZWs6ICd3ZWVrJyxcbiAgICAgICAgZGF5OiAnZGF5JyxcbiAgICAgICAgbGlzdDogJ2xpc3QnLFxuICAgIH0sXG4gICAgd2Vla1RleHQ6ICdXJyxcbiAgICB3ZWVrVGV4dExvbmc6ICdXZWVrJyxcbiAgICBjbG9zZUhpbnQ6ICdDbG9zZScsXG4gICAgdGltZUhpbnQ6ICdUaW1lJyxcbiAgICBldmVudEhpbnQ6ICdFdmVudCcsXG4gICAgYWxsRGF5VGV4dDogJ2FsbC1kYXknLFxuICAgIG1vcmVMaW5rVGV4dDogJ21vcmUnLFxuICAgIG5vRXZlbnRzVGV4dDogJ05vIGV2ZW50cyB0byBkaXNwbGF5Jyxcbn07XG5jb25zdCBSQVdfRU5fTE9DQUxFID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBNSU5JTUFMX1JBV19FTl9MT0NBTEUpLCB7IFxuICAgIC8vIEluY2x1ZGVzIHRoaW5ncyB3ZSBkb24ndCB3YW50IG90aGVyIGxvY2FsZXMgdG8gaW5oZXJpdCxcbiAgICAvLyB0aGluZ3MgdGhhdCBkZXJpdmUgZnJvbSBvdGhlciB0cmFuc2xhdGFibGUgc3RyaW5ncy5cbiAgICBidXR0b25IaW50czoge1xuICAgICAgICBwcmV2OiAnUHJldmlvdXMgJDAnLFxuICAgICAgICBuZXh0OiAnTmV4dCAkMCcsXG4gICAgICAgIHRvZGF5KGJ1dHRvblRleHQsIHVuaXQpIHtcbiAgICAgICAgICAgIHJldHVybiAodW5pdCA9PT0gJ2RheScpXG4gICAgICAgICAgICAgICAgPyAnVG9kYXknXG4gICAgICAgICAgICAgICAgOiBgVGhpcyAke2J1dHRvblRleHR9YDtcbiAgICAgICAgfSxcbiAgICB9LCB2aWV3SGludDogJyQwIHZpZXcnLCBuYXZMaW5rSGludDogJ0dvIHRvICQwJywgbW9yZUxpbmtIaW50KGV2ZW50Q250KSB7XG4gICAgICAgIHJldHVybiBgU2hvdyAke2V2ZW50Q250fSBtb3JlIGV2ZW50JHtldmVudENudCA9PT0gMSA/ICcnIDogJ3MnfWA7XG4gICAgfSB9KTtcbmZ1bmN0aW9uIG9yZ2FuaXplUmF3TG9jYWxlcyhleHBsaWNpdFJhd0xvY2FsZXMpIHtcbiAgICBsZXQgZGVmYXVsdENvZGUgPSBleHBsaWNpdFJhd0xvY2FsZXMubGVuZ3RoID4gMCA/IGV4cGxpY2l0UmF3TG9jYWxlc1swXS5jb2RlIDogJ2VuJztcbiAgICBsZXQgYWxsUmF3TG9jYWxlcyA9IGdsb2JhbExvY2FsZXMuY29uY2F0KGV4cGxpY2l0UmF3TG9jYWxlcyk7XG4gICAgbGV0IHJhd0xvY2FsZU1hcCA9IHtcbiAgICAgICAgZW46IFJBV19FTl9MT0NBTEUsXG4gICAgfTtcbiAgICBmb3IgKGxldCByYXdMb2NhbGUgb2YgYWxsUmF3TG9jYWxlcykge1xuICAgICAgICByYXdMb2NhbGVNYXBbcmF3TG9jYWxlLmNvZGVdID0gcmF3TG9jYWxlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBtYXA6IHJhd0xvY2FsZU1hcCxcbiAgICAgICAgZGVmYXVsdENvZGUsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkTG9jYWxlKGlucHV0U2luZ3VsYXIsIGF2YWlsYWJsZSkge1xuICAgIGlmICh0eXBlb2YgaW5wdXRTaW5ndWxhciA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoaW5wdXRTaW5ndWxhcikpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlTG9jYWxlKGlucHV0U2luZ3VsYXIuY29kZSwgW2lucHV0U2luZ3VsYXIuY29kZV0sIGlucHV0U2luZ3VsYXIpO1xuICAgIH1cbiAgICByZXR1cm4gcXVlcnlMb2NhbGUoaW5wdXRTaW5ndWxhciwgYXZhaWxhYmxlKTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5TG9jYWxlKGNvZGVBcmcsIGF2YWlsYWJsZSkge1xuICAgIGxldCBjb2RlcyA9IFtdLmNvbmNhdChjb2RlQXJnIHx8IFtdKTsgLy8gd2lsbCBjb252ZXJ0IHRvIGFycmF5XG4gICAgbGV0IHJhdyA9IHF1ZXJ5UmF3TG9jYWxlKGNvZGVzLCBhdmFpbGFibGUpIHx8IFJBV19FTl9MT0NBTEU7XG4gICAgcmV0dXJuIHBhcnNlTG9jYWxlKGNvZGVBcmcsIGNvZGVzLCByYXcpO1xufVxuZnVuY3Rpb24gcXVlcnlSYXdMb2NhbGUoY29kZXMsIGF2YWlsYWJsZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29kZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgbGV0IHBhcnRzID0gY29kZXNbaV0udG9Mb2NhbGVMb3dlckNhc2UoKS5zcGxpdCgnLScpO1xuICAgICAgICBmb3IgKGxldCBqID0gcGFydHMubGVuZ3RoOyBqID4gMDsgaiAtPSAxKSB7XG4gICAgICAgICAgICBsZXQgc2ltcGxlSWQgPSBwYXJ0cy5zbGljZSgwLCBqKS5qb2luKCctJyk7XG4gICAgICAgICAgICBpZiAoYXZhaWxhYmxlW3NpbXBsZUlkXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhdmFpbGFibGVbc2ltcGxlSWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcGFyc2VMb2NhbGUoY29kZUFyZywgY29kZXMsIHJhdykge1xuICAgIGxldCBtZXJnZWQgPSBtZXJnZVByb3BzKFtNSU5JTUFMX1JBV19FTl9MT0NBTEUsIHJhd10sIFsnYnV0dG9uVGV4dCddKTtcbiAgICBkZWxldGUgbWVyZ2VkLmNvZGU7IC8vIGRvbid0IHdhbnQgdGhpcyBwYXJ0IG9mIHRoZSBvcHRpb25zXG4gICAgbGV0IHsgd2VlayB9ID0gbWVyZ2VkO1xuICAgIGRlbGV0ZSBtZXJnZWQud2VlaztcbiAgICByZXR1cm4ge1xuICAgICAgICBjb2RlQXJnLFxuICAgICAgICBjb2RlcyxcbiAgICAgICAgd2VlayxcbiAgICAgICAgc2ltcGxlTnVtYmVyRm9ybWF0OiBuZXcgSW50bC5OdW1iZXJGb3JtYXQoY29kZUFyZyksXG4gICAgICAgIG9wdGlvbnM6IG1lcmdlZCxcbiAgICB9O1xufVxuXG4vLyBUT0RPOiBlYXNpZXIgd2F5IHRvIGFkZCBuZXcgaG9va3M/IG5lZWQgdG8gdXBkYXRlIGEgbWlsbGlvbiB0aGluZ3NcbmZ1bmN0aW9uIGNyZWF0ZVBsdWdpbihpbnB1dCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBndWlkKCksXG4gICAgICAgIG5hbWU6IGlucHV0Lm5hbWUsXG4gICAgICAgIHByZW1pdW1SZWxlYXNlRGF0ZTogaW5wdXQucHJlbWl1bVJlbGVhc2VEYXRlID8gbmV3IERhdGUoaW5wdXQucHJlbWl1bVJlbGVhc2VEYXRlKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZGVwczogaW5wdXQuZGVwcyB8fCBbXSxcbiAgICAgICAgcmVkdWNlcnM6IGlucHV0LnJlZHVjZXJzIHx8IFtdLFxuICAgICAgICBpc0xvYWRpbmdGdW5jczogaW5wdXQuaXNMb2FkaW5nRnVuY3MgfHwgW10sXG4gICAgICAgIGNvbnRleHRJbml0OiBbXS5jb25jYXQoaW5wdXQuY29udGV4dEluaXQgfHwgW10pLFxuICAgICAgICBldmVudFJlZmluZXJzOiBpbnB1dC5ldmVudFJlZmluZXJzIHx8IHt9LFxuICAgICAgICBldmVudERlZk1lbWJlckFkZGVyczogaW5wdXQuZXZlbnREZWZNZW1iZXJBZGRlcnMgfHwgW10sXG4gICAgICAgIGV2ZW50U291cmNlUmVmaW5lcnM6IGlucHV0LmV2ZW50U291cmNlUmVmaW5lcnMgfHwge30sXG4gICAgICAgIGlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzOiBpbnB1dC5pc0RyYWdnYWJsZVRyYW5zZm9ybWVycyB8fCBbXSxcbiAgICAgICAgZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnM6IGlucHV0LmV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzIHx8IFtdLFxuICAgICAgICBldmVudERlZk11dGF0aW9uQXBwbGllcnM6IGlucHV0LmV2ZW50RGVmTXV0YXRpb25BcHBsaWVycyB8fCBbXSxcbiAgICAgICAgZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVyczogaW5wdXQuZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVycyB8fCBbXSxcbiAgICAgICAgZGF0ZVBvaW50VHJhbnNmb3JtczogaW5wdXQuZGF0ZVBvaW50VHJhbnNmb3JtcyB8fCBbXSxcbiAgICAgICAgZGF0ZVNwYW5UcmFuc2Zvcm1zOiBpbnB1dC5kYXRlU3BhblRyYW5zZm9ybXMgfHwgW10sXG4gICAgICAgIHZpZXdzOiBpbnB1dC52aWV3cyB8fCB7fSxcbiAgICAgICAgdmlld1Byb3BzVHJhbnNmb3JtZXJzOiBpbnB1dC52aWV3UHJvcHNUcmFuc2Zvcm1lcnMgfHwgW10sXG4gICAgICAgIGlzUHJvcHNWYWxpZDogaW5wdXQuaXNQcm9wc1ZhbGlkIHx8IG51bGwsXG4gICAgICAgIGV4dGVybmFsRGVmVHJhbnNmb3JtczogaW5wdXQuZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zIHx8IFtdLFxuICAgICAgICB2aWV3Q29udGFpbmVyQXBwZW5kczogaW5wdXQudmlld0NvbnRhaW5lckFwcGVuZHMgfHwgW10sXG4gICAgICAgIGV2ZW50RHJvcFRyYW5zZm9ybWVyczogaW5wdXQuZXZlbnREcm9wVHJhbnNmb3JtZXJzIHx8IFtdLFxuICAgICAgICBjb21wb25lbnRJbnRlcmFjdGlvbnM6IGlucHV0LmNvbXBvbmVudEludGVyYWN0aW9ucyB8fCBbXSxcbiAgICAgICAgY2FsZW5kYXJJbnRlcmFjdGlvbnM6IGlucHV0LmNhbGVuZGFySW50ZXJhY3Rpb25zIHx8IFtdLFxuICAgICAgICB0aGVtZUNsYXNzZXM6IGlucHV0LnRoZW1lQ2xhc3NlcyB8fCB7fSxcbiAgICAgICAgZXZlbnRTb3VyY2VEZWZzOiBpbnB1dC5ldmVudFNvdXJjZURlZnMgfHwgW10sXG4gICAgICAgIGNtZEZvcm1hdHRlcjogaW5wdXQuY21kRm9ybWF0dGVyLFxuICAgICAgICByZWN1cnJpbmdUeXBlczogaW5wdXQucmVjdXJyaW5nVHlwZXMgfHwgW10sXG4gICAgICAgIG5hbWVkVGltZVpvbmVkSW1wbDogaW5wdXQubmFtZWRUaW1lWm9uZWRJbXBsLFxuICAgICAgICBpbml0aWFsVmlldzogaW5wdXQuaW5pdGlhbFZpZXcgfHwgJycsXG4gICAgICAgIGVsZW1lbnREcmFnZ2luZ0ltcGw6IGlucHV0LmVsZW1lbnREcmFnZ2luZ0ltcGwsXG4gICAgICAgIG9wdGlvbkNoYW5nZUhhbmRsZXJzOiBpbnB1dC5vcHRpb25DaGFuZ2VIYW5kbGVycyB8fCB7fSxcbiAgICAgICAgc2Nyb2xsR3JpZEltcGw6IGlucHV0LnNjcm9sbEdyaWRJbXBsIHx8IG51bGwsXG4gICAgICAgIGxpc3RlbmVyUmVmaW5lcnM6IGlucHV0Lmxpc3RlbmVyUmVmaW5lcnMgfHwge30sXG4gICAgICAgIG9wdGlvblJlZmluZXJzOiBpbnB1dC5vcHRpb25SZWZpbmVycyB8fCB7fSxcbiAgICAgICAgcHJvcFNldEhhbmRsZXJzOiBpbnB1dC5wcm9wU2V0SGFuZGxlcnMgfHwge30sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkUGx1Z2luSG9va3MocGx1Z2luRGVmcywgZ2xvYmFsRGVmcykge1xuICAgIGxldCBjdXJyZW50UGx1Z2luSWRzID0ge307XG4gICAgbGV0IGhvb2tzID0ge1xuICAgICAgICBwcmVtaXVtUmVsZWFzZURhdGU6IHVuZGVmaW5lZCxcbiAgICAgICAgcmVkdWNlcnM6IFtdLFxuICAgICAgICBpc0xvYWRpbmdGdW5jczogW10sXG4gICAgICAgIGNvbnRleHRJbml0OiBbXSxcbiAgICAgICAgZXZlbnRSZWZpbmVyczoge30sXG4gICAgICAgIGV2ZW50RGVmTWVtYmVyQWRkZXJzOiBbXSxcbiAgICAgICAgZXZlbnRTb3VyY2VSZWZpbmVyczoge30sXG4gICAgICAgIGlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzOiBbXSxcbiAgICAgICAgZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnM6IFtdLFxuICAgICAgICBldmVudERlZk11dGF0aW9uQXBwbGllcnM6IFtdLFxuICAgICAgICBkYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzOiBbXSxcbiAgICAgICAgZGF0ZVBvaW50VHJhbnNmb3JtczogW10sXG4gICAgICAgIGRhdGVTcGFuVHJhbnNmb3JtczogW10sXG4gICAgICAgIHZpZXdzOiB7fSxcbiAgICAgICAgdmlld1Byb3BzVHJhbnNmb3JtZXJzOiBbXSxcbiAgICAgICAgaXNQcm9wc1ZhbGlkOiBudWxsLFxuICAgICAgICBleHRlcm5hbERlZlRyYW5zZm9ybXM6IFtdLFxuICAgICAgICB2aWV3Q29udGFpbmVyQXBwZW5kczogW10sXG4gICAgICAgIGV2ZW50RHJvcFRyYW5zZm9ybWVyczogW10sXG4gICAgICAgIGNvbXBvbmVudEludGVyYWN0aW9uczogW10sXG4gICAgICAgIGNhbGVuZGFySW50ZXJhY3Rpb25zOiBbXSxcbiAgICAgICAgdGhlbWVDbGFzc2VzOiB7fSxcbiAgICAgICAgZXZlbnRTb3VyY2VEZWZzOiBbXSxcbiAgICAgICAgY21kRm9ybWF0dGVyOiBudWxsLFxuICAgICAgICByZWN1cnJpbmdUeXBlczogW10sXG4gICAgICAgIG5hbWVkVGltZVpvbmVkSW1wbDogbnVsbCxcbiAgICAgICAgaW5pdGlhbFZpZXc6ICcnLFxuICAgICAgICBlbGVtZW50RHJhZ2dpbmdJbXBsOiBudWxsLFxuICAgICAgICBvcHRpb25DaGFuZ2VIYW5kbGVyczoge30sXG4gICAgICAgIHNjcm9sbEdyaWRJbXBsOiBudWxsLFxuICAgICAgICBsaXN0ZW5lclJlZmluZXJzOiB7fSxcbiAgICAgICAgb3B0aW9uUmVmaW5lcnM6IHt9LFxuICAgICAgICBwcm9wU2V0SGFuZGxlcnM6IHt9LFxuICAgIH07XG4gICAgZnVuY3Rpb24gYWRkRGVmcyhkZWZzKSB7XG4gICAgICAgIGZvciAobGV0IGRlZiBvZiBkZWZzKSB7XG4gICAgICAgICAgICBjb25zdCBwbHVnaW5OYW1lID0gZGVmLm5hbWU7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50SWQgPSBjdXJyZW50UGx1Z2luSWRzW3BsdWdpbk5hbWVdO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFBsdWdpbklkc1twbHVnaW5OYW1lXSA9IGRlZi5pZDtcbiAgICAgICAgICAgICAgICBhZGREZWZzKGRlZi5kZXBzKTtcbiAgICAgICAgICAgICAgICBob29rcyA9IGNvbWJpbmVIb29rcyhob29rcywgZGVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnRJZCAhPT0gZGVmLmlkKSB7XG4gICAgICAgICAgICAgICAgLy8gZGlmZmVyZW50IElEIHRoYW4gdGhlIG9uZSBhbHJlYWR5IGFkZGVkXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBEdXBsaWNhdGUgcGx1Z2luICcke3BsdWdpbk5hbWV9J2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwbHVnaW5EZWZzKSB7XG4gICAgICAgIGFkZERlZnMocGx1Z2luRGVmcyk7XG4gICAgfVxuICAgIGFkZERlZnMoZ2xvYmFsRGVmcyk7XG4gICAgcmV0dXJuIGhvb2tzO1xufVxuZnVuY3Rpb24gYnVpbGRCdWlsZFBsdWdpbkhvb2tzKCkge1xuICAgIGxldCBjdXJyZW50T3ZlcnJpZGVEZWZzID0gW107XG4gICAgbGV0IGN1cnJlbnRHbG9iYWxEZWZzID0gW107XG4gICAgbGV0IGN1cnJlbnRIb29rcztcbiAgICByZXR1cm4gKG92ZXJyaWRlRGVmcywgZ2xvYmFsRGVmcykgPT4ge1xuICAgICAgICBpZiAoIWN1cnJlbnRIb29rcyB8fCAhaXNBcnJheXNFcXVhbChvdmVycmlkZURlZnMsIGN1cnJlbnRPdmVycmlkZURlZnMpIHx8ICFpc0FycmF5c0VxdWFsKGdsb2JhbERlZnMsIGN1cnJlbnRHbG9iYWxEZWZzKSkge1xuICAgICAgICAgICAgY3VycmVudEhvb2tzID0gYnVpbGRQbHVnaW5Ib29rcyhvdmVycmlkZURlZnMsIGdsb2JhbERlZnMpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRPdmVycmlkZURlZnMgPSBvdmVycmlkZURlZnM7XG4gICAgICAgIGN1cnJlbnRHbG9iYWxEZWZzID0gZ2xvYmFsRGVmcztcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRIb29rcztcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tYmluZUhvb2tzKGhvb2tzMCwgaG9va3MxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJlbWl1bVJlbGVhc2VEYXRlOiBjb21wYXJlT3B0aW9uYWxEYXRlcyhob29rczAucHJlbWl1bVJlbGVhc2VEYXRlLCBob29rczEucHJlbWl1bVJlbGVhc2VEYXRlKSxcbiAgICAgICAgcmVkdWNlcnM6IGhvb2tzMC5yZWR1Y2Vycy5jb25jYXQoaG9va3MxLnJlZHVjZXJzKSxcbiAgICAgICAgaXNMb2FkaW5nRnVuY3M6IGhvb2tzMC5pc0xvYWRpbmdGdW5jcy5jb25jYXQoaG9va3MxLmlzTG9hZGluZ0Z1bmNzKSxcbiAgICAgICAgY29udGV4dEluaXQ6IGhvb2tzMC5jb250ZXh0SW5pdC5jb25jYXQoaG9va3MxLmNvbnRleHRJbml0KSxcbiAgICAgICAgZXZlbnRSZWZpbmVyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBob29rczAuZXZlbnRSZWZpbmVycyksIGhvb2tzMS5ldmVudFJlZmluZXJzKSxcbiAgICAgICAgZXZlbnREZWZNZW1iZXJBZGRlcnM6IGhvb2tzMC5ldmVudERlZk1lbWJlckFkZGVycy5jb25jYXQoaG9va3MxLmV2ZW50RGVmTWVtYmVyQWRkZXJzKSxcbiAgICAgICAgZXZlbnRTb3VyY2VSZWZpbmVyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBob29rczAuZXZlbnRTb3VyY2VSZWZpbmVycyksIGhvb2tzMS5ldmVudFNvdXJjZVJlZmluZXJzKSxcbiAgICAgICAgaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnM6IGhvb2tzMC5pc0RyYWdnYWJsZVRyYW5zZm9ybWVycy5jb25jYXQoaG9va3MxLmlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzKSxcbiAgICAgICAgZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnM6IGhvb2tzMC5ldmVudERyYWdNdXRhdGlvbk1hc3NhZ2Vycy5jb25jYXQoaG9va3MxLmV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzKSxcbiAgICAgICAgZXZlbnREZWZNdXRhdGlvbkFwcGxpZXJzOiBob29rczAuZXZlbnREZWZNdXRhdGlvbkFwcGxpZXJzLmNvbmNhdChob29rczEuZXZlbnREZWZNdXRhdGlvbkFwcGxpZXJzKSxcbiAgICAgICAgZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVyczogaG9va3MwLmRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnMuY29uY2F0KGhvb2tzMS5kYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzKSxcbiAgICAgICAgZGF0ZVBvaW50VHJhbnNmb3JtczogaG9va3MwLmRhdGVQb2ludFRyYW5zZm9ybXMuY29uY2F0KGhvb2tzMS5kYXRlUG9pbnRUcmFuc2Zvcm1zKSxcbiAgICAgICAgZGF0ZVNwYW5UcmFuc2Zvcm1zOiBob29rczAuZGF0ZVNwYW5UcmFuc2Zvcm1zLmNvbmNhdChob29rczEuZGF0ZVNwYW5UcmFuc2Zvcm1zKSxcbiAgICAgICAgdmlld3M6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaG9va3MwLnZpZXdzKSwgaG9va3MxLnZpZXdzKSxcbiAgICAgICAgdmlld1Byb3BzVHJhbnNmb3JtZXJzOiBob29rczAudmlld1Byb3BzVHJhbnNmb3JtZXJzLmNvbmNhdChob29rczEudmlld1Byb3BzVHJhbnNmb3JtZXJzKSxcbiAgICAgICAgaXNQcm9wc1ZhbGlkOiBob29rczEuaXNQcm9wc1ZhbGlkIHx8IGhvb2tzMC5pc1Byb3BzVmFsaWQsXG4gICAgICAgIGV4dGVybmFsRGVmVHJhbnNmb3JtczogaG9va3MwLmV4dGVybmFsRGVmVHJhbnNmb3Jtcy5jb25jYXQoaG9va3MxLmV4dGVybmFsRGVmVHJhbnNmb3JtcyksXG4gICAgICAgIHZpZXdDb250YWluZXJBcHBlbmRzOiBob29rczAudmlld0NvbnRhaW5lckFwcGVuZHMuY29uY2F0KGhvb2tzMS52aWV3Q29udGFpbmVyQXBwZW5kcyksXG4gICAgICAgIGV2ZW50RHJvcFRyYW5zZm9ybWVyczogaG9va3MwLmV2ZW50RHJvcFRyYW5zZm9ybWVycy5jb25jYXQoaG9va3MxLmV2ZW50RHJvcFRyYW5zZm9ybWVycyksXG4gICAgICAgIGNhbGVuZGFySW50ZXJhY3Rpb25zOiBob29rczAuY2FsZW5kYXJJbnRlcmFjdGlvbnMuY29uY2F0KGhvb2tzMS5jYWxlbmRhckludGVyYWN0aW9ucyksXG4gICAgICAgIGNvbXBvbmVudEludGVyYWN0aW9uczogaG9va3MwLmNvbXBvbmVudEludGVyYWN0aW9ucy5jb25jYXQoaG9va3MxLmNvbXBvbmVudEludGVyYWN0aW9ucyksXG4gICAgICAgIHRoZW1lQ2xhc3NlczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBob29rczAudGhlbWVDbGFzc2VzKSwgaG9va3MxLnRoZW1lQ2xhc3NlcyksXG4gICAgICAgIGV2ZW50U291cmNlRGVmczogaG9va3MwLmV2ZW50U291cmNlRGVmcy5jb25jYXQoaG9va3MxLmV2ZW50U291cmNlRGVmcyksXG4gICAgICAgIGNtZEZvcm1hdHRlcjogaG9va3MxLmNtZEZvcm1hdHRlciB8fCBob29rczAuY21kRm9ybWF0dGVyLFxuICAgICAgICByZWN1cnJpbmdUeXBlczogaG9va3MwLnJlY3VycmluZ1R5cGVzLmNvbmNhdChob29rczEucmVjdXJyaW5nVHlwZXMpLFxuICAgICAgICBuYW1lZFRpbWVab25lZEltcGw6IGhvb2tzMS5uYW1lZFRpbWVab25lZEltcGwgfHwgaG9va3MwLm5hbWVkVGltZVpvbmVkSW1wbCxcbiAgICAgICAgaW5pdGlhbFZpZXc6IGhvb2tzMC5pbml0aWFsVmlldyB8fCBob29rczEuaW5pdGlhbFZpZXcsXG4gICAgICAgIGVsZW1lbnREcmFnZ2luZ0ltcGw6IGhvb2tzMC5lbGVtZW50RHJhZ2dpbmdJbXBsIHx8IGhvb2tzMS5lbGVtZW50RHJhZ2dpbmdJbXBsLFxuICAgICAgICBvcHRpb25DaGFuZ2VIYW5kbGVyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBob29rczAub3B0aW9uQ2hhbmdlSGFuZGxlcnMpLCBob29rczEub3B0aW9uQ2hhbmdlSGFuZGxlcnMpLFxuICAgICAgICBzY3JvbGxHcmlkSW1wbDogaG9va3MxLnNjcm9sbEdyaWRJbXBsIHx8IGhvb2tzMC5zY3JvbGxHcmlkSW1wbCxcbiAgICAgICAgbGlzdGVuZXJSZWZpbmVyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBob29rczAubGlzdGVuZXJSZWZpbmVycyksIGhvb2tzMS5saXN0ZW5lclJlZmluZXJzKSxcbiAgICAgICAgb3B0aW9uUmVmaW5lcnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaG9va3MwLm9wdGlvblJlZmluZXJzKSwgaG9va3MxLm9wdGlvblJlZmluZXJzKSxcbiAgICAgICAgcHJvcFNldEhhbmRsZXJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGhvb2tzMC5wcm9wU2V0SGFuZGxlcnMpLCBob29rczEucHJvcFNldEhhbmRsZXJzKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcGFyZU9wdGlvbmFsRGF0ZXMoZGF0ZTAsIGRhdGUxKSB7XG4gICAgaWYgKGRhdGUwID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGRhdGUxO1xuICAgIH1cbiAgICBpZiAoZGF0ZTEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZGF0ZTA7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGF0ZShNYXRoLm1heChkYXRlMC52YWx1ZU9mKCksIGRhdGUxLnZhbHVlT2YoKSkpO1xufVxuXG5jbGFzcyBTdGFuZGFyZFRoZW1lIGV4dGVuZHMgVGhlbWUge1xufVxuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuY2xhc3NlcyA9IHtcbiAgICByb290OiAnZmMtdGhlbWUtc3RhbmRhcmQnLFxuICAgIHRhYmxlQ2VsbFNoYWRlZDogJ2ZjLWNlbGwtc2hhZGVkJyxcbiAgICBidXR0b25Hcm91cDogJ2ZjLWJ1dHRvbi1ncm91cCcsXG4gICAgYnV0dG9uOiAnZmMtYnV0dG9uIGZjLWJ1dHRvbi1wcmltYXJ5JyxcbiAgICBidXR0b25BY3RpdmU6ICdmYy1idXR0b24tYWN0aXZlJyxcbn07XG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5iYXNlSWNvbkNsYXNzID0gJ2ZjLWljb24nO1xuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuaWNvbkNsYXNzZXMgPSB7XG4gICAgY2xvc2U6ICdmYy1pY29uLXgnLFxuICAgIHByZXY6ICdmYy1pY29uLWNoZXZyb24tbGVmdCcsXG4gICAgbmV4dDogJ2ZjLWljb24tY2hldnJvbi1yaWdodCcsXG4gICAgcHJldlllYXI6ICdmYy1pY29uLWNoZXZyb25zLWxlZnQnLFxuICAgIG5leHRZZWFyOiAnZmMtaWNvbi1jaGV2cm9ucy1yaWdodCcsXG59O1xuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUucnRsSWNvbkNsYXNzZXMgPSB7XG4gICAgcHJldjogJ2ZjLWljb24tY2hldnJvbi1yaWdodCcsXG4gICAgbmV4dDogJ2ZjLWljb24tY2hldnJvbi1sZWZ0JyxcbiAgICBwcmV2WWVhcjogJ2ZjLWljb24tY2hldnJvbnMtcmlnaHQnLFxuICAgIG5leHRZZWFyOiAnZmMtaWNvbi1jaGV2cm9ucy1sZWZ0Jyxcbn07XG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVPcHRpb24gPSAnYnV0dG9uSWNvbnMnOyAvLyBUT0RPOiBtYWtlIFRTLWZyaWVuZGx5XG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVDdXN0b21CdXR0b25PcHRpb24gPSAnaWNvbic7XG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVQcmVmaXggPSAnZmMtaWNvbi0nO1xuXG5mdW5jdGlvbiBjb21waWxlVmlld0RlZnMoZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncykge1xuICAgIGxldCBoYXNoID0ge307XG4gICAgbGV0IHZpZXdUeXBlO1xuICAgIGZvciAodmlld1R5cGUgaW4gZGVmYXVsdENvbmZpZ3MpIHtcbiAgICAgICAgZW5zdXJlVmlld0RlZih2aWV3VHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncyk7XG4gICAgfVxuICAgIGZvciAodmlld1R5cGUgaW4gb3ZlcnJpZGVDb25maWdzKSB7XG4gICAgICAgIGVuc3VyZVZpZXdEZWYodmlld1R5cGUsIGhhc2gsIGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gaGFzaDtcbn1cbmZ1bmN0aW9uIGVuc3VyZVZpZXdEZWYodmlld1R5cGUsIGhhc2gsIGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpIHtcbiAgICBpZiAoaGFzaFt2aWV3VHlwZV0pIHtcbiAgICAgICAgcmV0dXJuIGhhc2hbdmlld1R5cGVdO1xuICAgIH1cbiAgICBsZXQgdmlld0RlZiA9IGJ1aWxkVmlld0RlZih2aWV3VHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncyk7XG4gICAgaWYgKHZpZXdEZWYpIHtcbiAgICAgICAgaGFzaFt2aWV3VHlwZV0gPSB2aWV3RGVmO1xuICAgIH1cbiAgICByZXR1cm4gdmlld0RlZjtcbn1cbmZ1bmN0aW9uIGJ1aWxkVmlld0RlZih2aWV3VHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncykge1xuICAgIGxldCBkZWZhdWx0Q29uZmlnID0gZGVmYXVsdENvbmZpZ3Nbdmlld1R5cGVdO1xuICAgIGxldCBvdmVycmlkZUNvbmZpZyA9IG92ZXJyaWRlQ29uZmlnc1t2aWV3VHlwZV07XG4gICAgbGV0IHF1ZXJ5UHJvcCA9IChuYW1lKSA9PiAoKGRlZmF1bHRDb25maWcgJiYgZGVmYXVsdENvbmZpZ1tuYW1lXSAhPT0gbnVsbCkgPyBkZWZhdWx0Q29uZmlnW25hbWVdIDpcbiAgICAgICAgKChvdmVycmlkZUNvbmZpZyAmJiBvdmVycmlkZUNvbmZpZ1tuYW1lXSAhPT0gbnVsbCkgPyBvdmVycmlkZUNvbmZpZ1tuYW1lXSA6IG51bGwpKTtcbiAgICBsZXQgdGhlQ29tcG9uZW50ID0gcXVlcnlQcm9wKCdjb21wb25lbnQnKTtcbiAgICBsZXQgc3VwZXJUeXBlID0gcXVlcnlQcm9wKCdzdXBlclR5cGUnKTtcbiAgICBsZXQgc3VwZXJEZWYgPSBudWxsO1xuICAgIGlmIChzdXBlclR5cGUpIHtcbiAgICAgICAgaWYgKHN1cGVyVHlwZSA9PT0gdmlld1R5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBoYXZlIGEgY3VzdG9tIHZpZXcgdHlwZSB0aGF0IHJlZmVyZW5jZXMgaXRzZWxmJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXJEZWYgPSBlbnN1cmVWaWV3RGVmKHN1cGVyVHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncyk7XG4gICAgfVxuICAgIGlmICghdGhlQ29tcG9uZW50ICYmIHN1cGVyRGVmKSB7XG4gICAgICAgIHRoZUNvbXBvbmVudCA9IHN1cGVyRGVmLmNvbXBvbmVudDtcbiAgICB9XG4gICAgaWYgKCF0aGVDb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7IC8vIGRvbid0IHRocm93IGEgd2FybmluZywgbWlnaHQgYmUgc2V0dGluZ3MgZm9yIGEgc2luZ2xlLXVuaXQgdmlld1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiB2aWV3VHlwZSxcbiAgICAgICAgY29tcG9uZW50OiB0aGVDb21wb25lbnQsXG4gICAgICAgIGRlZmF1bHRzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChzdXBlckRlZiA/IHN1cGVyRGVmLmRlZmF1bHRzIDoge30pKSwgKGRlZmF1bHRDb25maWcgPyBkZWZhdWx0Q29uZmlnLnJhd09wdGlvbnMgOiB7fSkpLFxuICAgICAgICBvdmVycmlkZXM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKHN1cGVyRGVmID8gc3VwZXJEZWYub3ZlcnJpZGVzIDoge30pKSwgKG92ZXJyaWRlQ29uZmlnID8gb3ZlcnJpZGVDb25maWcucmF3T3B0aW9ucyA6IHt9KSksXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VWaWV3Q29uZmlncyhpbnB1dHMpIHtcbiAgICByZXR1cm4gbWFwSGFzaChpbnB1dHMsIHBhcnNlVmlld0NvbmZpZyk7XG59XG5mdW5jdGlvbiBwYXJzZVZpZXdDb25maWcoaW5wdXQpIHtcbiAgICBsZXQgcmF3T3B0aW9ucyA9IHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgIHsgY29tcG9uZW50OiBpbnB1dCB9IDpcbiAgICAgICAgaW5wdXQ7XG4gICAgbGV0IHsgY29tcG9uZW50IH0gPSByYXdPcHRpb25zO1xuICAgIGlmIChyYXdPcHRpb25zLmNvbnRlbnQpIHtcbiAgICAgICAgLy8gVE9ETzogcmVtb3ZlIGNvbnRlbnQvY2xhc3NOYW1lcy9kaWRNb3VudC9ldGMgZnJvbSBvcHRpb25zP1xuICAgICAgICBjb21wb25lbnQgPSBjcmVhdGVWaWV3SG9va0NvbXBvbmVudChyYXdPcHRpb25zKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29tcG9uZW50ICYmICEoY29tcG9uZW50LnByb3RvdHlwZSBpbnN0YW5jZW9mIEJhc2VDb21wb25lbnQpKSB7XG4gICAgICAgIC8vIFdIWT86IHBlb3BsZSB3ZXJlIHVzaW5nIGBjb21wb25lbnRgIHByb3BlcnR5IGZvciBgY29udGVudGBcbiAgICAgICAgLy8gVE9ETzogY29udmVyZ2Ugb24gb25lIHNldHRpbmcgbmFtZVxuICAgICAgICBjb21wb25lbnQgPSBjcmVhdGVWaWV3SG9va0NvbXBvbmVudChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJhd09wdGlvbnMpLCB7IGNvbnRlbnQ6IGNvbXBvbmVudCB9KSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHN1cGVyVHlwZTogcmF3T3B0aW9ucy50eXBlLFxuICAgICAgICBjb21wb25lbnQ6IGNvbXBvbmVudCxcbiAgICAgICAgcmF3T3B0aW9ucywgLy8gaW5jbHVkZXMgdHlwZSBhbmQgY29tcG9uZW50IHRvbyA6KFxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVWaWV3SG9va0NvbXBvbmVudChvcHRpb25zKSB7XG4gICAgcmV0dXJuICh2aWV3UHJvcHMpID0+IChjcmVhdGVFbGVtZW50KFZpZXdDb250ZXh0VHlwZS5Db25zdW1lciwgbnVsbCwgKGNvbnRleHQpID0+IChjcmVhdGVFbGVtZW50KENvbnRlbnRDb250YWluZXIsIHsgZWxUYWc6IFwiZGl2XCIsIGVsQ2xhc3NlczogYnVpbGRWaWV3Q2xhc3NOYW1lcyhjb250ZXh0LnZpZXdTcGVjKSwgcmVuZGVyUHJvcHM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdmlld1Byb3BzKSwgeyBuZXh0RGF5VGhyZXNob2xkOiBjb250ZXh0Lm9wdGlvbnMubmV4dERheVRocmVzaG9sZCB9KSwgZ2VuZXJhdG9yTmFtZTogdW5kZWZpbmVkLCBjdXN0b21HZW5lcmF0b3I6IG9wdGlvbnMuY29udGVudCwgY2xhc3NOYW1lR2VuZXJhdG9yOiBvcHRpb25zLmNsYXNzTmFtZXMsIGRpZE1vdW50OiBvcHRpb25zLmRpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy53aWxsVW5tb3VudCB9KSkpKTtcbn1cblxuZnVuY3Rpb24gYnVpbGRWaWV3U3BlY3MoZGVmYXVsdElucHV0cywgb3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBsb2NhbGVEZWZhdWx0cykge1xuICAgIGxldCBkZWZhdWx0Q29uZmlncyA9IHBhcnNlVmlld0NvbmZpZ3MoZGVmYXVsdElucHV0cyk7XG4gICAgbGV0IG92ZXJyaWRlQ29uZmlncyA9IHBhcnNlVmlld0NvbmZpZ3Mob3B0aW9uT3ZlcnJpZGVzLnZpZXdzKTtcbiAgICBsZXQgdmlld0RlZnMgPSBjb21waWxlVmlld0RlZnMoZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncyk7XG4gICAgcmV0dXJuIG1hcEhhc2godmlld0RlZnMsICh2aWV3RGVmKSA9PiBidWlsZFZpZXdTcGVjKHZpZXdEZWYsIG92ZXJyaWRlQ29uZmlncywgb3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBsb2NhbGVEZWZhdWx0cykpO1xufVxuZnVuY3Rpb24gYnVpbGRWaWV3U3BlYyh2aWV3RGVmLCBvdmVycmlkZUNvbmZpZ3MsIG9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcywgbG9jYWxlRGVmYXVsdHMpIHtcbiAgICBsZXQgZHVyYXRpb25JbnB1dCA9IHZpZXdEZWYub3ZlcnJpZGVzLmR1cmF0aW9uIHx8XG4gICAgICAgIHZpZXdEZWYuZGVmYXVsdHMuZHVyYXRpb24gfHxcbiAgICAgICAgZHluYW1pY09wdGlvbk92ZXJyaWRlcy5kdXJhdGlvbiB8fFxuICAgICAgICBvcHRpb25PdmVycmlkZXMuZHVyYXRpb247XG4gICAgbGV0IGR1cmF0aW9uID0gbnVsbDtcbiAgICBsZXQgZHVyYXRpb25Vbml0ID0gJyc7XG4gICAgbGV0IHNpbmdsZVVuaXQgPSAnJztcbiAgICBsZXQgc2luZ2xlVW5pdE92ZXJyaWRlcyA9IHt9O1xuICAgIGlmIChkdXJhdGlvbklucHV0KSB7XG4gICAgICAgIGR1cmF0aW9uID0gY3JlYXRlRHVyYXRpb25DYWNoZWQoZHVyYXRpb25JbnB1dCk7XG4gICAgICAgIGlmIChkdXJhdGlvbikgeyAvLyB2YWxpZD9cbiAgICAgICAgICAgIGxldCBkZW5vbSA9IGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvcihkdXJhdGlvbik7XG4gICAgICAgICAgICBkdXJhdGlvblVuaXQgPSBkZW5vbS51bml0O1xuICAgICAgICAgICAgaWYgKGRlbm9tLnZhbHVlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgc2luZ2xlVW5pdCA9IGR1cmF0aW9uVW5pdDtcbiAgICAgICAgICAgICAgICBzaW5nbGVVbml0T3ZlcnJpZGVzID0gb3ZlcnJpZGVDb25maWdzW2R1cmF0aW9uVW5pdF0gPyBvdmVycmlkZUNvbmZpZ3NbZHVyYXRpb25Vbml0XS5yYXdPcHRpb25zIDoge307XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHF1ZXJ5QnV0dG9uVGV4dCA9IChvcHRpb25zU3Vic2V0KSA9PiB7XG4gICAgICAgIGxldCBidXR0b25UZXh0TWFwID0gb3B0aW9uc1N1YnNldC5idXR0b25UZXh0IHx8IHt9O1xuICAgICAgICBsZXQgYnV0dG9uVGV4dEtleSA9IHZpZXdEZWYuZGVmYXVsdHMuYnV0dG9uVGV4dEtleTtcbiAgICAgICAgaWYgKGJ1dHRvblRleHRLZXkgIT0gbnVsbCAmJiBidXR0b25UZXh0TWFwW2J1dHRvblRleHRLZXldICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBidXR0b25UZXh0TWFwW2J1dHRvblRleHRLZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidXR0b25UZXh0TWFwW3ZpZXdEZWYudHlwZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1dHRvblRleHRNYXBbdmlld0RlZi50eXBlXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnV0dG9uVGV4dE1hcFtzaW5nbGVVbml0XSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYnV0dG9uVGV4dE1hcFtzaW5nbGVVbml0XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIGxldCBxdWVyeUJ1dHRvblRpdGxlID0gKG9wdGlvbnNTdWJzZXQpID0+IHtcbiAgICAgICAgbGV0IGJ1dHRvbkhpbnRzID0gb3B0aW9uc1N1YnNldC5idXR0b25IaW50cyB8fCB7fTtcbiAgICAgICAgbGV0IGJ1dHRvbktleSA9IHZpZXdEZWYuZGVmYXVsdHMuYnV0dG9uVGV4dEtleTsgLy8gdXNlIHNhbWUga2V5IGFzIHRleHRcbiAgICAgICAgaWYgKGJ1dHRvbktleSAhPSBudWxsICYmIGJ1dHRvbkhpbnRzW2J1dHRvbktleV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1dHRvbkhpbnRzW2J1dHRvbktleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1dHRvbkhpbnRzW3ZpZXdEZWYudHlwZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1dHRvbkhpbnRzW3ZpZXdEZWYudHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1dHRvbkhpbnRzW3NpbmdsZVVuaXRdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBidXR0b25IaW50c1tzaW5nbGVVbml0XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHZpZXdEZWYudHlwZSxcbiAgICAgICAgY29tcG9uZW50OiB2aWV3RGVmLmNvbXBvbmVudCxcbiAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIGR1cmF0aW9uVW5pdCxcbiAgICAgICAgc2luZ2xlVW5pdCxcbiAgICAgICAgb3B0aW9uRGVmYXVsdHM6IHZpZXdEZWYuZGVmYXVsdHMsXG4gICAgICAgIG9wdGlvbk92ZXJyaWRlczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzaW5nbGVVbml0T3ZlcnJpZGVzKSwgdmlld0RlZi5vdmVycmlkZXMpLFxuICAgICAgICBidXR0b25UZXh0T3ZlcnJpZGU6IHF1ZXJ5QnV0dG9uVGV4dChkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKSB8fFxuICAgICAgICAgICAgcXVlcnlCdXR0b25UZXh0KG9wdGlvbk92ZXJyaWRlcykgfHwgLy8gY29uc3RydWN0b3Itc3BlY2lmaWVkIGJ1dHRvblRleHQgbG9va3VwIGhhc2ggdGFrZXMgcHJlY2VkZW5jZVxuICAgICAgICAgICAgdmlld0RlZi5vdmVycmlkZXMuYnV0dG9uVGV4dCxcbiAgICAgICAgYnV0dG9uVGV4dERlZmF1bHQ6IHF1ZXJ5QnV0dG9uVGV4dChsb2NhbGVEZWZhdWx0cykgfHxcbiAgICAgICAgICAgIHZpZXdEZWYuZGVmYXVsdHMuYnV0dG9uVGV4dCB8fFxuICAgICAgICAgICAgcXVlcnlCdXR0b25UZXh0KEJBU0VfT1BUSU9OX0RFRkFVTFRTKSB8fFxuICAgICAgICAgICAgdmlld0RlZi50eXBlLFxuICAgICAgICAvLyBub3QgRFJZXG4gICAgICAgIGJ1dHRvblRpdGxlT3ZlcnJpZGU6IHF1ZXJ5QnV0dG9uVGl0bGUoZHluYW1pY09wdGlvbk92ZXJyaWRlcykgfHxcbiAgICAgICAgICAgIHF1ZXJ5QnV0dG9uVGl0bGUob3B0aW9uT3ZlcnJpZGVzKSB8fFxuICAgICAgICAgICAgdmlld0RlZi5vdmVycmlkZXMuYnV0dG9uSGludCxcbiAgICAgICAgYnV0dG9uVGl0bGVEZWZhdWx0OiBxdWVyeUJ1dHRvblRpdGxlKGxvY2FsZURlZmF1bHRzKSB8fFxuICAgICAgICAgICAgdmlld0RlZi5kZWZhdWx0cy5idXR0b25IaW50IHx8XG4gICAgICAgICAgICBxdWVyeUJ1dHRvblRpdGxlKEJBU0VfT1BUSU9OX0RFRkFVTFRTKSxcbiAgICAgICAgLy8gd2lsbCBldmVudHVhbGx5IGZhbGwgYmFjayB0byBidXR0b25UZXh0XG4gICAgfTtcbn1cbi8vIGhhY2sgdG8gZ2V0IG1lbW9pemF0aW9uIHdvcmtpbmdcbmxldCBkdXJhdGlvbklucHV0TWFwID0ge307XG5mdW5jdGlvbiBjcmVhdGVEdXJhdGlvbkNhY2hlZChkdXJhdGlvbklucHV0KSB7XG4gICAgbGV0IGpzb24gPSBKU09OLnN0cmluZ2lmeShkdXJhdGlvbklucHV0KTtcbiAgICBsZXQgcmVzID0gZHVyYXRpb25JbnB1dE1hcFtqc29uXTtcbiAgICBpZiAocmVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzID0gY3JlYXRlRHVyYXRpb24oZHVyYXRpb25JbnB1dCk7XG4gICAgICAgIGR1cmF0aW9uSW5wdXRNYXBbanNvbl0gPSByZXM7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIHJlZHVjZVZpZXdUeXBlKHZpZXdUeXBlLCBhY3Rpb24pIHtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ0NIQU5HRV9WSUVXX1RZUEUnOlxuICAgICAgICAgICAgdmlld1R5cGUgPSBhY3Rpb24udmlld1R5cGU7XG4gICAgfVxuICAgIHJldHVybiB2aWV3VHlwZTtcbn1cblxuZnVuY3Rpb24gcmVkdWNlRHluYW1pY09wdGlvbk92ZXJyaWRlcyhkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBhY3Rpb24pIHtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ1NFVF9PUFRJT04nOlxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZHluYW1pY09wdGlvbk92ZXJyaWRlcyksIHsgW2FjdGlvbi5vcHRpb25OYW1lXTogYWN0aW9uLnJhd09wdGlvblZhbHVlIH0pO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGR5bmFtaWNPcHRpb25PdmVycmlkZXM7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWR1Y2VEYXRlUHJvZmlsZShjdXJyZW50RGF0ZVByb2ZpbGUsIGFjdGlvbiwgY3VycmVudERhdGUsIGRhdGVQcm9maWxlR2VuZXJhdG9yKSB7XG4gICAgbGV0IGRwO1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnQ0hBTkdFX1ZJRVdfVFlQRSc6XG4gICAgICAgICAgICByZXR1cm4gZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGQoYWN0aW9uLmRhdGVNYXJrZXIgfHwgY3VycmVudERhdGUpO1xuICAgICAgICBjYXNlICdDSEFOR0VfREFURSc6XG4gICAgICAgICAgICByZXR1cm4gZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGQoYWN0aW9uLmRhdGVNYXJrZXIpO1xuICAgICAgICBjYXNlICdQUkVWJzpcbiAgICAgICAgICAgIGRwID0gZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGRQcmV2KGN1cnJlbnREYXRlUHJvZmlsZSwgY3VycmVudERhdGUpO1xuICAgICAgICAgICAgaWYgKGRwLmlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZHA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnTkVYVCc6XG4gICAgICAgICAgICBkcCA9IGRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkTmV4dChjdXJyZW50RGF0ZVByb2ZpbGUsIGN1cnJlbnREYXRlKTtcbiAgICAgICAgICAgIGlmIChkcC5pc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50RGF0ZVByb2ZpbGU7XG59XG5cbmZ1bmN0aW9uIGluaXRFdmVudFNvdXJjZXMoY2FsZW5kYXJPcHRpb25zLCBkYXRlUHJvZmlsZSwgY29udGV4dCkge1xuICAgIGxldCBhY3RpdmVSYW5nZSA9IGRhdGVQcm9maWxlID8gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UgOiBudWxsO1xuICAgIHJldHVybiBhZGRTb3VyY2VzKHt9LCBwYXJzZUluaXRpYWxTb3VyY2VzKGNhbGVuZGFyT3B0aW9ucywgY29udGV4dCksIGFjdGl2ZVJhbmdlLCBjb250ZXh0KTtcbn1cbmZ1bmN0aW9uIHJlZHVjZUV2ZW50U291cmNlcyhldmVudFNvdXJjZXMsIGFjdGlvbiwgZGF0ZVByb2ZpbGUsIGNvbnRleHQpIHtcbiAgICBsZXQgYWN0aXZlUmFuZ2UgPSBkYXRlUHJvZmlsZSA/IGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlIDogbnVsbDsgLy8gbmVlZCB0aGlzIGNoZWNrP1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnQUREX0VWRU5UX1NPVVJDRVMnOiAvLyBhbHJlYWR5IHBhcnNlZFxuICAgICAgICAgICAgcmV0dXJuIGFkZFNvdXJjZXMoZXZlbnRTb3VyY2VzLCBhY3Rpb24uc291cmNlcywgYWN0aXZlUmFuZ2UsIGNvbnRleHQpO1xuICAgICAgICBjYXNlICdSRU1PVkVfRVZFTlRfU09VUkNFJzpcbiAgICAgICAgICAgIHJldHVybiByZW1vdmVTb3VyY2UoZXZlbnRTb3VyY2VzLCBhY3Rpb24uc291cmNlSWQpO1xuICAgICAgICBjYXNlICdQUkVWJzogLy8gVE9ETzogaG93IGRvIHdlIHRyYWNrIGFsbCBhY3Rpb25zIHRoYXQgYWZmZWN0IGRhdGVQcm9maWxlIDooXG4gICAgICAgIGNhc2UgJ05FWFQnOlxuICAgICAgICBjYXNlICdDSEFOR0VfREFURSc6XG4gICAgICAgIGNhc2UgJ0NIQU5HRV9WSUVXX1RZUEUnOlxuICAgICAgICAgICAgaWYgKGRhdGVQcm9maWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZldGNoRGlydHlTb3VyY2VzKGV2ZW50U291cmNlcywgYWN0aXZlUmFuZ2UsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50U291cmNlcztcbiAgICAgICAgY2FzZSAnRkVUQ0hfRVZFTlRfU09VUkNFUyc6XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2hTb3VyY2VzQnlJZHMoZXZlbnRTb3VyY2VzLCBhY3Rpb24uc291cmNlSWRzID8gLy8gd2h5IG5vIHR5cGU/XG4gICAgICAgICAgICAgICAgYXJyYXlUb0hhc2goYWN0aW9uLnNvdXJjZUlkcykgOlxuICAgICAgICAgICAgICAgIGV4Y2x1ZGVTdGF0aWNTb3VyY2VzKGV2ZW50U291cmNlcywgY29udGV4dCksIGFjdGl2ZVJhbmdlLCBhY3Rpb24uaXNSZWZldGNoIHx8IGZhbHNlLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSAnUkVDRUlWRV9FVkVOVFMnOlxuICAgICAgICBjYXNlICdSRUNFSVZFX0VWRU5UX0VSUk9SJzpcbiAgICAgICAgICAgIHJldHVybiByZWNlaXZlUmVzcG9uc2UoZXZlbnRTb3VyY2VzLCBhY3Rpb24uc291cmNlSWQsIGFjdGlvbi5mZXRjaElkLCBhY3Rpb24uZmV0Y2hSYW5nZSk7XG4gICAgICAgIGNhc2UgJ1JFTU9WRV9BTExfRVZFTlRfU09VUkNFUyc6XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRTb3VyY2VzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlZHVjZUV2ZW50U291cmNlc05ld1RpbWVab25lKGV2ZW50U291cmNlcywgZGF0ZVByb2ZpbGUsIGNvbnRleHQpIHtcbiAgICBsZXQgYWN0aXZlUmFuZ2UgPSBkYXRlUHJvZmlsZSA/IGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlIDogbnVsbDsgLy8gbmVlZCB0aGlzIGNoZWNrP1xuICAgIHJldHVybiBmZXRjaFNvdXJjZXNCeUlkcyhldmVudFNvdXJjZXMsIGV4Y2x1ZGVTdGF0aWNTb3VyY2VzKGV2ZW50U291cmNlcywgY29udGV4dCksIGFjdGl2ZVJhbmdlLCB0cnVlLCBjb250ZXh0KTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVFdmVudFNvdXJjZXNMb2FkaW5nKGV2ZW50U291cmNlcykge1xuICAgIGZvciAobGV0IHNvdXJjZUlkIGluIGV2ZW50U291cmNlcykge1xuICAgICAgICBpZiAoZXZlbnRTb3VyY2VzW3NvdXJjZUlkXS5pc0ZldGNoaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBhZGRTb3VyY2VzKGV2ZW50U291cmNlSGFzaCwgc291cmNlcywgZmV0Y2hSYW5nZSwgY29udGV4dCkge1xuICAgIGxldCBoYXNoID0ge307XG4gICAgZm9yIChsZXQgc291cmNlIG9mIHNvdXJjZXMpIHtcbiAgICAgICAgaGFzaFtzb3VyY2Uuc291cmNlSWRdID0gc291cmNlO1xuICAgIH1cbiAgICBpZiAoZmV0Y2hSYW5nZSkge1xuICAgICAgICBoYXNoID0gZmV0Y2hEaXJ0eVNvdXJjZXMoaGFzaCwgZmV0Y2hSYW5nZSwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV2ZW50U291cmNlSGFzaCksIGhhc2gpO1xufVxuZnVuY3Rpb24gcmVtb3ZlU291cmNlKGV2ZW50U291cmNlSGFzaCwgc291cmNlSWQpIHtcbiAgICByZXR1cm4gZmlsdGVySGFzaChldmVudFNvdXJjZUhhc2gsIChldmVudFNvdXJjZSkgPT4gZXZlbnRTb3VyY2Uuc291cmNlSWQgIT09IHNvdXJjZUlkKTtcbn1cbmZ1bmN0aW9uIGZldGNoRGlydHlTb3VyY2VzKHNvdXJjZUhhc2gsIGZldGNoUmFuZ2UsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gZmV0Y2hTb3VyY2VzQnlJZHMoc291cmNlSGFzaCwgZmlsdGVySGFzaChzb3VyY2VIYXNoLCAoZXZlbnRTb3VyY2UpID0+IGlzU291cmNlRGlydHkoZXZlbnRTb3VyY2UsIGZldGNoUmFuZ2UsIGNvbnRleHQpKSwgZmV0Y2hSYW5nZSwgZmFsc2UsIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gaXNTb3VyY2VEaXJ0eShldmVudFNvdXJjZSwgZmV0Y2hSYW5nZSwgY29udGV4dCkge1xuICAgIGlmICghZG9lc1NvdXJjZU5lZWRSYW5nZShldmVudFNvdXJjZSwgY29udGV4dCkpIHtcbiAgICAgICAgcmV0dXJuICFldmVudFNvdXJjZS5sYXRlc3RGZXRjaElkO1xuICAgIH1cbiAgICByZXR1cm4gIWNvbnRleHQub3B0aW9ucy5sYXp5RmV0Y2hpbmcgfHxcbiAgICAgICAgIWV2ZW50U291cmNlLmZldGNoUmFuZ2UgfHxcbiAgICAgICAgZXZlbnRTb3VyY2UuaXNGZXRjaGluZyB8fCAvLyBhbHdheXMgY2FuY2VsIG91dGRhdGVkIGluLXByb2dyZXNzIGZldGNoZXNcbiAgICAgICAgZmV0Y2hSYW5nZS5zdGFydCA8IGV2ZW50U291cmNlLmZldGNoUmFuZ2Uuc3RhcnQgfHxcbiAgICAgICAgZmV0Y2hSYW5nZS5lbmQgPiBldmVudFNvdXJjZS5mZXRjaFJhbmdlLmVuZDtcbn1cbmZ1bmN0aW9uIGZldGNoU291cmNlc0J5SWRzKHByZXZTb3VyY2VzLCBzb3VyY2VJZEhhc2gsIGZldGNoUmFuZ2UsIGlzUmVmZXRjaCwgY29udGV4dCkge1xuICAgIGxldCBuZXh0U291cmNlcyA9IHt9O1xuICAgIGZvciAobGV0IHNvdXJjZUlkIGluIHByZXZTb3VyY2VzKSB7XG4gICAgICAgIGxldCBzb3VyY2UgPSBwcmV2U291cmNlc1tzb3VyY2VJZF07XG4gICAgICAgIGlmIChzb3VyY2VJZEhhc2hbc291cmNlSWRdKSB7XG4gICAgICAgICAgICBuZXh0U291cmNlc1tzb3VyY2VJZF0gPSBmZXRjaFNvdXJjZShzb3VyY2UsIGZldGNoUmFuZ2UsIGlzUmVmZXRjaCwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXh0U291cmNlc1tzb3VyY2VJZF0gPSBzb3VyY2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5leHRTb3VyY2VzO1xufVxuZnVuY3Rpb24gZmV0Y2hTb3VyY2UoZXZlbnRTb3VyY2UsIGZldGNoUmFuZ2UsIGlzUmVmZXRjaCwgY29udGV4dCkge1xuICAgIGxldCB7IG9wdGlvbnMsIGNhbGVuZGFyQXBpIH0gPSBjb250ZXh0O1xuICAgIGxldCBzb3VyY2VEZWYgPSBjb250ZXh0LnBsdWdpbkhvb2tzLmV2ZW50U291cmNlRGVmc1tldmVudFNvdXJjZS5zb3VyY2VEZWZJZF07XG4gICAgbGV0IGZldGNoSWQgPSBndWlkKCk7XG4gICAgc291cmNlRGVmLmZldGNoKHtcbiAgICAgICAgZXZlbnRTb3VyY2UsXG4gICAgICAgIHJhbmdlOiBmZXRjaFJhbmdlLFxuICAgICAgICBpc1JlZmV0Y2gsXG4gICAgICAgIGNvbnRleHQsXG4gICAgfSwgKHJlcykgPT4ge1xuICAgICAgICBsZXQgeyByYXdFdmVudHMgfSA9IHJlcztcbiAgICAgICAgaWYgKG9wdGlvbnMuZXZlbnRTb3VyY2VTdWNjZXNzKSB7XG4gICAgICAgICAgICByYXdFdmVudHMgPSBvcHRpb25zLmV2ZW50U291cmNlU3VjY2Vzcy5jYWxsKGNhbGVuZGFyQXBpLCByYXdFdmVudHMsIHJlcy5yZXNwb25zZSkgfHwgcmF3RXZlbnRzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudFNvdXJjZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICByYXdFdmVudHMgPSBldmVudFNvdXJjZS5zdWNjZXNzLmNhbGwoY2FsZW5kYXJBcGksIHJhd0V2ZW50cywgcmVzLnJlc3BvbnNlKSB8fCByYXdFdmVudHM7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnUkVDRUlWRV9FVkVOVFMnLFxuICAgICAgICAgICAgc291cmNlSWQ6IGV2ZW50U291cmNlLnNvdXJjZUlkLFxuICAgICAgICAgICAgZmV0Y2hJZCxcbiAgICAgICAgICAgIGZldGNoUmFuZ2UsXG4gICAgICAgICAgICByYXdFdmVudHMsXG4gICAgICAgIH0pO1xuICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICBsZXQgZXJyb3JIYW5kbGVkID0gZmFsc2U7XG4gICAgICAgIGlmIChvcHRpb25zLmV2ZW50U291cmNlRmFpbHVyZSkge1xuICAgICAgICAgICAgb3B0aW9ucy5ldmVudFNvdXJjZUZhaWx1cmUuY2FsbChjYWxlbmRhckFwaSwgZXJyb3IpO1xuICAgICAgICAgICAgZXJyb3JIYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnRTb3VyY2UuZmFpbHVyZSkge1xuICAgICAgICAgICAgZXZlbnRTb3VyY2UuZmFpbHVyZShlcnJvcik7XG4gICAgICAgICAgICBlcnJvckhhbmRsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZXJyb3JIYW5kbGVkKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oZXJyb3IubWVzc2FnZSwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ1JFQ0VJVkVfRVZFTlRfRVJST1InLFxuICAgICAgICAgICAgc291cmNlSWQ6IGV2ZW50U291cmNlLnNvdXJjZUlkLFxuICAgICAgICAgICAgZmV0Y2hJZCxcbiAgICAgICAgICAgIGZldGNoUmFuZ2UsXG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRTb3VyY2UpLCB7IGlzRmV0Y2hpbmc6IHRydWUsIGxhdGVzdEZldGNoSWQ6IGZldGNoSWQgfSk7XG59XG5mdW5jdGlvbiByZWNlaXZlUmVzcG9uc2Uoc291cmNlSGFzaCwgc291cmNlSWQsIGZldGNoSWQsIGZldGNoUmFuZ2UpIHtcbiAgICBsZXQgZXZlbnRTb3VyY2UgPSBzb3VyY2VIYXNoW3NvdXJjZUlkXTtcbiAgICBpZiAoZXZlbnRTb3VyY2UgJiYgLy8gbm90IGFscmVhZHkgcmVtb3ZlZFxuICAgICAgICBmZXRjaElkID09PSBldmVudFNvdXJjZS5sYXRlc3RGZXRjaElkKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNvdXJjZUhhc2gpLCB7IFtzb3VyY2VJZF06IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRTb3VyY2UpLCB7IGlzRmV0Y2hpbmc6IGZhbHNlLCBmZXRjaFJhbmdlIH0pIH0pO1xuICAgIH1cbiAgICByZXR1cm4gc291cmNlSGFzaDtcbn1cbmZ1bmN0aW9uIGV4Y2x1ZGVTdGF0aWNTb3VyY2VzKGV2ZW50U291cmNlcywgY29udGV4dCkge1xuICAgIHJldHVybiBmaWx0ZXJIYXNoKGV2ZW50U291cmNlcywgKGV2ZW50U291cmNlKSA9PiBkb2VzU291cmNlTmVlZFJhbmdlKGV2ZW50U291cmNlLCBjb250ZXh0KSk7XG59XG5mdW5jdGlvbiBwYXJzZUluaXRpYWxTb3VyY2VzKHJhd09wdGlvbnMsIGNvbnRleHQpIHtcbiAgICBsZXQgcmVmaW5lcnMgPSBidWlsZEV2ZW50U291cmNlUmVmaW5lcnMoY29udGV4dCk7XG4gICAgbGV0IHJhd1NvdXJjZXMgPSBbXS5jb25jYXQocmF3T3B0aW9ucy5ldmVudFNvdXJjZXMgfHwgW10pO1xuICAgIGxldCBzb3VyY2VzID0gW107IC8vIHBhcnNlZFxuICAgIGlmIChyYXdPcHRpb25zLmluaXRpYWxFdmVudHMpIHtcbiAgICAgICAgcmF3U291cmNlcy51bnNoaWZ0KHJhd09wdGlvbnMuaW5pdGlhbEV2ZW50cyk7XG4gICAgfVxuICAgIGlmIChyYXdPcHRpb25zLmV2ZW50cykge1xuICAgICAgICByYXdTb3VyY2VzLnVuc2hpZnQocmF3T3B0aW9ucy5ldmVudHMpO1xuICAgIH1cbiAgICBmb3IgKGxldCByYXdTb3VyY2Ugb2YgcmF3U291cmNlcykge1xuICAgICAgICBsZXQgc291cmNlID0gcGFyc2VFdmVudFNvdXJjZShyYXdTb3VyY2UsIGNvbnRleHQsIHJlZmluZXJzKTtcbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgc291cmNlcy5wdXNoKHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZXM7XG59XG5mdW5jdGlvbiBkb2VzU291cmNlTmVlZFJhbmdlKGV2ZW50U291cmNlLCBjb250ZXh0KSB7XG4gICAgbGV0IGRlZnMgPSBjb250ZXh0LnBsdWdpbkhvb2tzLmV2ZW50U291cmNlRGVmcztcbiAgICByZXR1cm4gIWRlZnNbZXZlbnRTb3VyY2Uuc291cmNlRGVmSWRdLmlnbm9yZVJhbmdlO1xufVxuXG5mdW5jdGlvbiByZWR1Y2VEYXRlU2VsZWN0aW9uKGN1cnJlbnRTZWxlY3Rpb24sIGFjdGlvbikge1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnVU5TRUxFQ1RfREFURVMnOlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgJ1NFTEVDVF9EQVRFUyc6XG4gICAgICAgICAgICByZXR1cm4gYWN0aW9uLnNlbGVjdGlvbjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50U2VsZWN0aW9uO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVkdWNlU2VsZWN0ZWRFdmVudChjdXJyZW50SW5zdGFuY2VJZCwgYWN0aW9uKSB7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdVTlNFTEVDVF9FVkVOVCc6XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIGNhc2UgJ1NFTEVDVF9FVkVOVCc6XG4gICAgICAgICAgICByZXR1cm4gYWN0aW9uLmV2ZW50SW5zdGFuY2VJZDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50SW5zdGFuY2VJZDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlZHVjZUV2ZW50RHJhZyhjdXJyZW50RHJhZywgYWN0aW9uKSB7XG4gICAgbGV0IG5ld0RyYWc7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdVTlNFVF9FVkVOVF9EUkFHJzpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlICdTRVRfRVZFTlRfRFJBRyc6XG4gICAgICAgICAgICBuZXdEcmFnID0gYWN0aW9uLnN0YXRlO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhZmZlY3RlZEV2ZW50czogbmV3RHJhZy5hZmZlY3RlZEV2ZW50cyxcbiAgICAgICAgICAgICAgICBtdXRhdGVkRXZlbnRzOiBuZXdEcmFnLm11dGF0ZWRFdmVudHMsXG4gICAgICAgICAgICAgICAgaXNFdmVudDogbmV3RHJhZy5pc0V2ZW50LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50RHJhZztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlZHVjZUV2ZW50UmVzaXplKGN1cnJlbnRSZXNpemUsIGFjdGlvbikge1xuICAgIGxldCBuZXdSZXNpemU7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdVTlNFVF9FVkVOVF9SRVNJWkUnOlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgJ1NFVF9FVkVOVF9SRVNJWkUnOlxuICAgICAgICAgICAgbmV3UmVzaXplID0gYWN0aW9uLnN0YXRlO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhZmZlY3RlZEV2ZW50czogbmV3UmVzaXplLmFmZmVjdGVkRXZlbnRzLFxuICAgICAgICAgICAgICAgIG11dGF0ZWRFdmVudHM6IG5ld1Jlc2l6ZS5tdXRhdGVkRXZlbnRzLFxuICAgICAgICAgICAgICAgIGlzRXZlbnQ6IG5ld1Jlc2l6ZS5pc0V2ZW50LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50UmVzaXplO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VUb29sYmFycyhjYWxlbmRhck9wdGlvbnMsIGNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzLCB0aGVtZSwgdmlld1NwZWNzLCBjYWxlbmRhckFwaSkge1xuICAgIGxldCBoZWFkZXIgPSBjYWxlbmRhck9wdGlvbnMuaGVhZGVyVG9vbGJhciA/IHBhcnNlVG9vbGJhcihjYWxlbmRhck9wdGlvbnMuaGVhZGVyVG9vbGJhciwgY2FsZW5kYXJPcHRpb25zLCBjYWxlbmRhck9wdGlvbk92ZXJyaWRlcywgdGhlbWUsIHZpZXdTcGVjcywgY2FsZW5kYXJBcGkpIDogbnVsbDtcbiAgICBsZXQgZm9vdGVyID0gY2FsZW5kYXJPcHRpb25zLmZvb3RlclRvb2xiYXIgPyBwYXJzZVRvb2xiYXIoY2FsZW5kYXJPcHRpb25zLmZvb3RlclRvb2xiYXIsIGNhbGVuZGFyT3B0aW9ucywgY2FsZW5kYXJPcHRpb25PdmVycmlkZXMsIHRoZW1lLCB2aWV3U3BlY3MsIGNhbGVuZGFyQXBpKSA6IG51bGw7XG4gICAgcmV0dXJuIHsgaGVhZGVyLCBmb290ZXIgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlVG9vbGJhcihzZWN0aW9uU3RySGFzaCwgY2FsZW5kYXJPcHRpb25zLCBjYWxlbmRhck9wdGlvbk92ZXJyaWRlcywgdGhlbWUsIHZpZXdTcGVjcywgY2FsZW5kYXJBcGkpIHtcbiAgICBsZXQgc2VjdGlvbldpZGdldHMgPSB7fTtcbiAgICBsZXQgdmlld3NXaXRoQnV0dG9ucyA9IFtdO1xuICAgIGxldCBoYXNUaXRsZSA9IGZhbHNlO1xuICAgIGZvciAobGV0IHNlY3Rpb25OYW1lIGluIHNlY3Rpb25TdHJIYXNoKSB7XG4gICAgICAgIGxldCBzZWN0aW9uU3RyID0gc2VjdGlvblN0ckhhc2hbc2VjdGlvbk5hbWVdO1xuICAgICAgICBsZXQgc2VjdGlvblJlcyA9IHBhcnNlU2VjdGlvbihzZWN0aW9uU3RyLCBjYWxlbmRhck9wdGlvbnMsIGNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzLCB0aGVtZSwgdmlld1NwZWNzLCBjYWxlbmRhckFwaSk7XG4gICAgICAgIHNlY3Rpb25XaWRnZXRzW3NlY3Rpb25OYW1lXSA9IHNlY3Rpb25SZXMud2lkZ2V0cztcbiAgICAgICAgdmlld3NXaXRoQnV0dG9ucy5wdXNoKC4uLnNlY3Rpb25SZXMudmlld3NXaXRoQnV0dG9ucyk7XG4gICAgICAgIGhhc1RpdGxlID0gaGFzVGl0bGUgfHwgc2VjdGlvblJlcy5oYXNUaXRsZTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc2VjdGlvbldpZGdldHMsIHZpZXdzV2l0aEJ1dHRvbnMsIGhhc1RpdGxlIH07XG59XG4vKlxuQkFEOiBxdWVyeWluZyBpY29ucyBhbmQgdGV4dCBoZXJlLiBzaG91bGQgYmUgZG9uZSBhdCByZW5kZXIgdGltZVxuKi9cbmZ1bmN0aW9uIHBhcnNlU2VjdGlvbihzZWN0aW9uU3RyLCBjYWxlbmRhck9wdGlvbnMsIC8vIGRlZmF1bHRzK292ZXJyaWRlcywgdGhlbiByZWZpbmVkXG5jYWxlbmRhck9wdGlvbk92ZXJyaWRlcywgLy8gb3ZlcnJpZGVzIG9ubHkhLCB1bnJlZmluZWQgOihcbnRoZW1lLCB2aWV3U3BlY3MsIGNhbGVuZGFyQXBpKSB7XG4gICAgbGV0IGlzUnRsID0gY2FsZW5kYXJPcHRpb25zLmRpcmVjdGlvbiA9PT0gJ3J0bCc7XG4gICAgbGV0IGNhbGVuZGFyQ3VzdG9tQnV0dG9ucyA9IGNhbGVuZGFyT3B0aW9ucy5jdXN0b21CdXR0b25zIHx8IHt9O1xuICAgIGxldCBjYWxlbmRhckJ1dHRvblRleHRPdmVycmlkZXMgPSBjYWxlbmRhck9wdGlvbk92ZXJyaWRlcy5idXR0b25UZXh0IHx8IHt9O1xuICAgIGxldCBjYWxlbmRhckJ1dHRvblRleHQgPSBjYWxlbmRhck9wdGlvbnMuYnV0dG9uVGV4dCB8fCB7fTtcbiAgICBsZXQgY2FsZW5kYXJCdXR0b25IaW50T3ZlcnJpZGVzID0gY2FsZW5kYXJPcHRpb25PdmVycmlkZXMuYnV0dG9uSGludHMgfHwge307XG4gICAgbGV0IGNhbGVuZGFyQnV0dG9uSGludHMgPSBjYWxlbmRhck9wdGlvbnMuYnV0dG9uSGludHMgfHwge307XG4gICAgbGV0IHNlY3Rpb25TdWJzdHJzID0gc2VjdGlvblN0ciA/IHNlY3Rpb25TdHIuc3BsaXQoJyAnKSA6IFtdO1xuICAgIGxldCB2aWV3c1dpdGhCdXR0b25zID0gW107XG4gICAgbGV0IGhhc1RpdGxlID0gZmFsc2U7XG4gICAgbGV0IHdpZGdldHMgPSBzZWN0aW9uU3Vic3Rycy5tYXAoKGJ1dHRvbkdyb3VwU3RyKSA9PiAoYnV0dG9uR3JvdXBTdHIuc3BsaXQoJywnKS5tYXAoKGJ1dHRvbk5hbWUpID0+IHtcbiAgICAgICAgaWYgKGJ1dHRvbk5hbWUgPT09ICd0aXRsZScpIHtcbiAgICAgICAgICAgIGhhc1RpdGxlID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB7IGJ1dHRvbk5hbWUgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3VzdG9tQnV0dG9uUHJvcHM7XG4gICAgICAgIGxldCB2aWV3U3BlYztcbiAgICAgICAgbGV0IGJ1dHRvbkNsaWNrO1xuICAgICAgICBsZXQgYnV0dG9uSWNvbjsgLy8gb25seSBvbmUgb2YgdGhlc2Ugd2lsbCBiZSBzZXRcbiAgICAgICAgbGV0IGJ1dHRvblRleHQ7IC8vIFwiXG4gICAgICAgIGxldCBidXR0b25IaW50O1xuICAgICAgICAvLyBeIGZvciB0aGUgdGl0bGU9XCJcIiBhdHRyaWJ1dGUsIGZvciBhY2Nlc3NpYmlsaXR5XG4gICAgICAgIGlmICgoY3VzdG9tQnV0dG9uUHJvcHMgPSBjYWxlbmRhckN1c3RvbUJ1dHRvbnNbYnV0dG9uTmFtZV0pKSB7XG4gICAgICAgICAgICBidXR0b25DbGljayA9IChldikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjdXN0b21CdXR0b25Qcm9wcy5jbGljaykge1xuICAgICAgICAgICAgICAgICAgICBjdXN0b21CdXR0b25Qcm9wcy5jbGljay5jYWxsKGV2LnRhcmdldCwgZXYsIGV2LnRhcmdldCk7IC8vIFRPRE86IHVzZSBDYWxlbmRhciB0aGlzIGNvbnRleHQ/XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIChidXR0b25JY29uID0gdGhlbWUuZ2V0Q3VzdG9tQnV0dG9uSWNvbkNsYXNzKGN1c3RvbUJ1dHRvblByb3BzKSkgfHxcbiAgICAgICAgICAgICAgICAoYnV0dG9uSWNvbiA9IHRoZW1lLmdldEljb25DbGFzcyhidXR0b25OYW1lLCBpc1J0bCkpIHx8XG4gICAgICAgICAgICAgICAgKGJ1dHRvblRleHQgPSBjdXN0b21CdXR0b25Qcm9wcy50ZXh0KTtcbiAgICAgICAgICAgIGJ1dHRvbkhpbnQgPSBjdXN0b21CdXR0b25Qcm9wcy5oaW50IHx8IGN1c3RvbUJ1dHRvblByb3BzLnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHZpZXdTcGVjID0gdmlld1NwZWNzW2J1dHRvbk5hbWVdKSkge1xuICAgICAgICAgICAgdmlld3NXaXRoQnV0dG9ucy5wdXNoKGJ1dHRvbk5hbWUpO1xuICAgICAgICAgICAgYnV0dG9uQ2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2FsZW5kYXJBcGkuY2hhbmdlVmlldyhidXR0b25OYW1lKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAoYnV0dG9uVGV4dCA9IHZpZXdTcGVjLmJ1dHRvblRleHRPdmVycmlkZSkgfHxcbiAgICAgICAgICAgICAgICAoYnV0dG9uSWNvbiA9IHRoZW1lLmdldEljb25DbGFzcyhidXR0b25OYW1lLCBpc1J0bCkpIHx8XG4gICAgICAgICAgICAgICAgKGJ1dHRvblRleHQgPSB2aWV3U3BlYy5idXR0b25UZXh0RGVmYXVsdCk7XG4gICAgICAgICAgICBsZXQgdGV4dEZhbGxiYWNrID0gdmlld1NwZWMuYnV0dG9uVGV4dE92ZXJyaWRlIHx8XG4gICAgICAgICAgICAgICAgdmlld1NwZWMuYnV0dG9uVGV4dERlZmF1bHQ7XG4gICAgICAgICAgICBidXR0b25IaW50ID0gZm9ybWF0V2l0aE9yZGluYWxzKHZpZXdTcGVjLmJ1dHRvblRpdGxlT3ZlcnJpZGUgfHxcbiAgICAgICAgICAgICAgICB2aWV3U3BlYy5idXR0b25UaXRsZURlZmF1bHQgfHxcbiAgICAgICAgICAgICAgICBjYWxlbmRhck9wdGlvbnMudmlld0hpbnQsIFt0ZXh0RmFsbGJhY2ssIGJ1dHRvbk5hbWVdLCAvLyB2aWV3LW5hbWUgPSBidXR0b25OYW1lXG4gICAgICAgICAgICB0ZXh0RmFsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNhbGVuZGFyQXBpW2J1dHRvbk5hbWVdKSB7IC8vIGEgY2FsZW5kYXJBcGkgbWV0aG9kXG4gICAgICAgICAgICBidXR0b25DbGljayA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjYWxlbmRhckFwaVtidXR0b25OYW1lXSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIChidXR0b25UZXh0ID0gY2FsZW5kYXJCdXR0b25UZXh0T3ZlcnJpZGVzW2J1dHRvbk5hbWVdKSB8fFxuICAgICAgICAgICAgICAgIChidXR0b25JY29uID0gdGhlbWUuZ2V0SWNvbkNsYXNzKGJ1dHRvbk5hbWUsIGlzUnRsKSkgfHxcbiAgICAgICAgICAgICAgICAoYnV0dG9uVGV4dCA9IGNhbGVuZGFyQnV0dG9uVGV4dFtidXR0b25OYW1lXSk7IC8vIGV2ZXJ5dGhpbmcgZWxzZSBpcyBjb25zaWRlcmVkIGRlZmF1bHRcbiAgICAgICAgICAgIGlmIChidXR0b25OYW1lID09PSAncHJldlllYXInIHx8IGJ1dHRvbk5hbWUgPT09ICduZXh0WWVhcicpIHtcbiAgICAgICAgICAgICAgICBsZXQgcHJldk9yTmV4dCA9IGJ1dHRvbk5hbWUgPT09ICdwcmV2WWVhcicgPyAncHJldicgOiAnbmV4dCc7XG4gICAgICAgICAgICAgICAgYnV0dG9uSGludCA9IGZvcm1hdFdpdGhPcmRpbmFscyhjYWxlbmRhckJ1dHRvbkhpbnRPdmVycmlkZXNbcHJldk9yTmV4dF0gfHxcbiAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXJCdXR0b25IaW50c1twcmV2T3JOZXh0XSwgW1xuICAgICAgICAgICAgICAgICAgICBjYWxlbmRhckJ1dHRvblRleHQueWVhciB8fCAneWVhcicsXG4gICAgICAgICAgICAgICAgICAgICd5ZWFyJyxcbiAgICAgICAgICAgICAgICBdLCBjYWxlbmRhckJ1dHRvblRleHRbYnV0dG9uTmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnV0dG9uSGludCA9IChuYXZVbml0KSA9PiBmb3JtYXRXaXRoT3JkaW5hbHMoY2FsZW5kYXJCdXR0b25IaW50T3ZlcnJpZGVzW2J1dHRvbk5hbWVdIHx8XG4gICAgICAgICAgICAgICAgICAgIGNhbGVuZGFyQnV0dG9uSGludHNbYnV0dG9uTmFtZV0sIFtcbiAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXJCdXR0b25UZXh0W25hdlVuaXRdIHx8IG5hdlVuaXQsXG4gICAgICAgICAgICAgICAgICAgIG5hdlVuaXQsXG4gICAgICAgICAgICAgICAgXSwgY2FsZW5kYXJCdXR0b25UZXh0W2J1dHRvbk5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBidXR0b25OYW1lLCBidXR0b25DbGljaywgYnV0dG9uSWNvbiwgYnV0dG9uVGV4dCwgYnV0dG9uSGludCB9O1xuICAgIH0pKSk7XG4gICAgcmV0dXJuIHsgd2lkZ2V0cywgdmlld3NXaXRoQnV0dG9ucywgaGFzVGl0bGUgfTtcbn1cblxuLy8gYWx3YXlzIHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgdmlldy4gb3RoZXJ3aXNlLCBpdCdkIG5lZWQgdG8gY2hhbmdlIHZhbHVlIGV2ZXJ5IHRpbWUgZGF0ZSBjaGFuZ2VzXG5jbGFzcyBWaWV3SW1wbCB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgZ2V0Q3VycmVudERhdGEsIGRhdGVFbnYpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5nZXRDdXJyZW50RGF0YSA9IGdldEN1cnJlbnREYXRhO1xuICAgICAgICB0aGlzLmRhdGVFbnYgPSBkYXRlRW52O1xuICAgIH1cbiAgICBnZXQgY2FsZW5kYXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnREYXRhKCkuY2FsZW5kYXJBcGk7XG4gICAgfVxuICAgIGdldCB0aXRsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudERhdGEoKS52aWV3VGl0bGU7XG4gICAgfVxuICAgIGdldCBhY3RpdmVTdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZUVudi50b0RhdGUodGhpcy5nZXRDdXJyZW50RGF0YSgpLmRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLnN0YXJ0KTtcbiAgICB9XG4gICAgZ2V0IGFjdGl2ZUVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZUVudi50b0RhdGUodGhpcy5nZXRDdXJyZW50RGF0YSgpLmRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLmVuZCk7XG4gICAgfVxuICAgIGdldCBjdXJyZW50U3RhcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGVFbnYudG9EYXRlKHRoaXMuZ2V0Q3VycmVudERhdGEoKS5kYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2Uuc3RhcnQpO1xuICAgIH1cbiAgICBnZXQgY3VycmVudEVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZUVudi50b0RhdGUodGhpcy5nZXRDdXJyZW50RGF0YSgpLmRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5lbmQpO1xuICAgIH1cbiAgICBnZXRPcHRpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50RGF0YSgpLm9wdGlvbnNbbmFtZV07IC8vIGFyZSB0aGUgdmlldy1zcGVjaWZpYyBvcHRpb25zXG4gICAgfVxufVxuXG5sZXQgZXZlbnRTb3VyY2VEZWYkMiA9IHtcbiAgICBpZ25vcmVSYW5nZTogdHJ1ZSxcbiAgICBwYXJzZU1ldGEocmVmaW5lZCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZWZpbmVkLmV2ZW50cykpIHtcbiAgICAgICAgICAgIHJldHVybiByZWZpbmVkLmV2ZW50cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGZldGNoKGFyZywgc3VjY2Vzc0NhbGxiYWNrKSB7XG4gICAgICAgIHN1Y2Nlc3NDYWxsYmFjayh7XG4gICAgICAgICAgICByYXdFdmVudHM6IGFyZy5ldmVudFNvdXJjZS5tZXRhLFxuICAgICAgICB9KTtcbiAgICB9LFxufTtcbmNvbnN0IGFycmF5RXZlbnRTb3VyY2VQbHVnaW4gPSBjcmVhdGVQbHVnaW4oe1xuICAgIG5hbWU6ICdhcnJheS1ldmVudC1zb3VyY2UnLFxuICAgIGV2ZW50U291cmNlRGVmczogW2V2ZW50U291cmNlRGVmJDJdLFxufSk7XG5cbmxldCBldmVudFNvdXJjZURlZiQxID0ge1xuICAgIHBhcnNlTWV0YShyZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVmaW5lZC5ldmVudHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiByZWZpbmVkLmV2ZW50cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGZldGNoKGFyZywgc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHsgZGF0ZUVudiB9ID0gYXJnLmNvbnRleHQ7XG4gICAgICAgIGNvbnN0IGZ1bmMgPSBhcmcuZXZlbnRTb3VyY2UubWV0YTtcbiAgICAgICAgdW5wcm9taXNpZnkoZnVuYy5iaW5kKG51bGwsIGJ1aWxkUmFuZ2VBcGlXaXRoVGltZVpvbmUoYXJnLnJhbmdlLCBkYXRlRW52KSksIChyYXdFdmVudHMpID0+IHN1Y2Nlc3NDYWxsYmFjayh7IHJhd0V2ZW50cyB9KSwgZXJyb3JDYWxsYmFjayk7XG4gICAgfSxcbn07XG5jb25zdCBmdW5jRXZlbnRTb3VyY2VQbHVnaW4gPSBjcmVhdGVQbHVnaW4oe1xuICAgIG5hbWU6ICdmdW5jLWV2ZW50LXNvdXJjZScsXG4gICAgZXZlbnRTb3VyY2VEZWZzOiBbZXZlbnRTb3VyY2VEZWYkMV0sXG59KTtcblxuY29uc3QgSlNPTl9GRUVEX0VWRU5UX1NPVVJDRV9SRUZJTkVSUyA9IHtcbiAgICBtZXRob2Q6IFN0cmluZyxcbiAgICBleHRyYVBhcmFtczogaWRlbnRpdHksXG4gICAgc3RhcnRQYXJhbTogU3RyaW5nLFxuICAgIGVuZFBhcmFtOiBTdHJpbmcsXG4gICAgdGltZVpvbmVQYXJhbTogU3RyaW5nLFxufTtcblxubGV0IGV2ZW50U291cmNlRGVmID0ge1xuICAgIHBhcnNlTWV0YShyZWZpbmVkKSB7XG4gICAgICAgIGlmIChyZWZpbmVkLnVybCAmJiAocmVmaW5lZC5mb3JtYXQgPT09ICdqc29uJyB8fCAhcmVmaW5lZC5mb3JtYXQpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogcmVmaW5lZC51cmwsXG4gICAgICAgICAgICAgICAgZm9ybWF0OiAnanNvbicsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAocmVmaW5lZC5tZXRob2QgfHwgJ0dFVCcpLnRvVXBwZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgZXh0cmFQYXJhbXM6IHJlZmluZWQuZXh0cmFQYXJhbXMsXG4gICAgICAgICAgICAgICAgc3RhcnRQYXJhbTogcmVmaW5lZC5zdGFydFBhcmFtLFxuICAgICAgICAgICAgICAgIGVuZFBhcmFtOiByZWZpbmVkLmVuZFBhcmFtLFxuICAgICAgICAgICAgICAgIHRpbWVab25lUGFyYW06IHJlZmluZWQudGltZVpvbmVQYXJhbSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBmZXRjaChhcmcsIHN1Y2Nlc3NDYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xuICAgICAgICBjb25zdCB7IG1ldGEgfSA9IGFyZy5ldmVudFNvdXJjZTtcbiAgICAgICAgY29uc3QgcmVxdWVzdFBhcmFtcyA9IGJ1aWxkUmVxdWVzdFBhcmFtcyhtZXRhLCBhcmcucmFuZ2UsIGFyZy5jb250ZXh0KTtcbiAgICAgICAgcmVxdWVzdEpzb24obWV0YS5tZXRob2QsIG1ldGEudXJsLCByZXF1ZXN0UGFyYW1zKS50aGVuKChbcmF3RXZlbnRzLCByZXNwb25zZV0pID0+IHtcbiAgICAgICAgICAgIHN1Y2Nlc3NDYWxsYmFjayh7IHJhd0V2ZW50cywgcmVzcG9uc2UgfSk7XG4gICAgICAgIH0sIGVycm9yQ2FsbGJhY2spO1xuICAgIH0sXG59O1xuY29uc3QganNvbkZlZWRFdmVudFNvdXJjZVBsdWdpbiA9IGNyZWF0ZVBsdWdpbih7XG4gICAgbmFtZTogJ2pzb24tZXZlbnQtc291cmNlJyxcbiAgICBldmVudFNvdXJjZVJlZmluZXJzOiBKU09OX0ZFRURfRVZFTlRfU09VUkNFX1JFRklORVJTLFxuICAgIGV2ZW50U291cmNlRGVmczogW2V2ZW50U291cmNlRGVmXSxcbn0pO1xuZnVuY3Rpb24gYnVpbGRSZXF1ZXN0UGFyYW1zKG1ldGEsIHJhbmdlLCBjb250ZXh0KSB7XG4gICAgbGV0IHsgZGF0ZUVudiwgb3B0aW9ucyB9ID0gY29udGV4dDtcbiAgICBsZXQgc3RhcnRQYXJhbTtcbiAgICBsZXQgZW5kUGFyYW07XG4gICAgbGV0IHRpbWVab25lUGFyYW07XG4gICAgbGV0IGN1c3RvbVJlcXVlc3RQYXJhbXM7XG4gICAgbGV0IHBhcmFtcyA9IHt9O1xuICAgIHN0YXJ0UGFyYW0gPSBtZXRhLnN0YXJ0UGFyYW07XG4gICAgaWYgKHN0YXJ0UGFyYW0gPT0gbnVsbCkge1xuICAgICAgICBzdGFydFBhcmFtID0gb3B0aW9ucy5zdGFydFBhcmFtO1xuICAgIH1cbiAgICBlbmRQYXJhbSA9IG1ldGEuZW5kUGFyYW07XG4gICAgaWYgKGVuZFBhcmFtID09IG51bGwpIHtcbiAgICAgICAgZW5kUGFyYW0gPSBvcHRpb25zLmVuZFBhcmFtO1xuICAgIH1cbiAgICB0aW1lWm9uZVBhcmFtID0gbWV0YS50aW1lWm9uZVBhcmFtO1xuICAgIGlmICh0aW1lWm9uZVBhcmFtID09IG51bGwpIHtcbiAgICAgICAgdGltZVpvbmVQYXJhbSA9IG9wdGlvbnMudGltZVpvbmVQYXJhbTtcbiAgICB9XG4gICAgLy8gcmV0cmlldmUgYW55IG91dGJvdW5kIEdFVC9QT1NUIGRhdGEgZnJvbSB0aGUgb3B0aW9uc1xuICAgIGlmICh0eXBlb2YgbWV0YS5leHRyYVBhcmFtcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBzdXBwbGllZCBhcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGtleS92YWx1ZSBvYmplY3RcbiAgICAgICAgY3VzdG9tUmVxdWVzdFBhcmFtcyA9IG1ldGEuZXh0cmFQYXJhbXMoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIHByb2JhYmx5IHN1cHBsaWVkIGFzIGEgc3RyYWlnaHQga2V5L3ZhbHVlIG9iamVjdFxuICAgICAgICBjdXN0b21SZXF1ZXN0UGFyYW1zID0gbWV0YS5leHRyYVBhcmFtcyB8fCB7fTtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbihwYXJhbXMsIGN1c3RvbVJlcXVlc3RQYXJhbXMpO1xuICAgIHBhcmFtc1tzdGFydFBhcmFtXSA9IGRhdGVFbnYuZm9ybWF0SXNvKHJhbmdlLnN0YXJ0KTtcbiAgICBwYXJhbXNbZW5kUGFyYW1dID0gZGF0ZUVudi5mb3JtYXRJc28ocmFuZ2UuZW5kKTtcbiAgICBpZiAoZGF0ZUVudi50aW1lWm9uZSAhPT0gJ2xvY2FsJykge1xuICAgICAgICBwYXJhbXNbdGltZVpvbmVQYXJhbV0gPSBkYXRlRW52LnRpbWVab25lO1xuICAgIH1cbiAgICByZXR1cm4gcGFyYW1zO1xufVxuXG5jb25zdCBTSU1QTEVfUkVDVVJSSU5HX1JFRklORVJTID0ge1xuICAgIGRheXNPZldlZWs6IGlkZW50aXR5LFxuICAgIHN0YXJ0VGltZTogY3JlYXRlRHVyYXRpb24sXG4gICAgZW5kVGltZTogY3JlYXRlRHVyYXRpb24sXG4gICAgZHVyYXRpb246IGNyZWF0ZUR1cmF0aW9uLFxuICAgIHN0YXJ0UmVjdXI6IGlkZW50aXR5LFxuICAgIGVuZFJlY3VyOiBpZGVudGl0eSxcbn07XG5cbmxldCByZWN1cnJpbmcgPSB7XG4gICAgcGFyc2UocmVmaW5lZCwgZGF0ZUVudikge1xuICAgICAgICBpZiAocmVmaW5lZC5kYXlzT2ZXZWVrIHx8IHJlZmluZWQuc3RhcnRUaW1lIHx8IHJlZmluZWQuZW5kVGltZSB8fCByZWZpbmVkLnN0YXJ0UmVjdXIgfHwgcmVmaW5lZC5lbmRSZWN1cikge1xuICAgICAgICAgICAgbGV0IHJlY3VycmluZ0RhdGEgPSB7XG4gICAgICAgICAgICAgICAgZGF5c09mV2VlazogcmVmaW5lZC5kYXlzT2ZXZWVrIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lOiByZWZpbmVkLnN0YXJ0VGltZSB8fCBudWxsLFxuICAgICAgICAgICAgICAgIGVuZFRpbWU6IHJlZmluZWQuZW5kVGltZSB8fCBudWxsLFxuICAgICAgICAgICAgICAgIHN0YXJ0UmVjdXI6IHJlZmluZWQuc3RhcnRSZWN1ciA/IGRhdGVFbnYuY3JlYXRlTWFya2VyKHJlZmluZWQuc3RhcnRSZWN1cikgOiBudWxsLFxuICAgICAgICAgICAgICAgIGVuZFJlY3VyOiByZWZpbmVkLmVuZFJlY3VyID8gZGF0ZUVudi5jcmVhdGVNYXJrZXIocmVmaW5lZC5lbmRSZWN1cikgOiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBkdXJhdGlvbjtcbiAgICAgICAgICAgIGlmIChyZWZpbmVkLmR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb24gPSByZWZpbmVkLmR1cmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkdXJhdGlvbiAmJiByZWZpbmVkLnN0YXJ0VGltZSAmJiByZWZpbmVkLmVuZFRpbWUpIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IHN1YnRyYWN0RHVyYXRpb25zKHJlZmluZWQuZW5kVGltZSwgcmVmaW5lZC5zdGFydFRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhbGxEYXlHdWVzczogQm9vbGVhbighcmVmaW5lZC5zdGFydFRpbWUgJiYgIXJlZmluZWQuZW5kVGltZSksXG4gICAgICAgICAgICAgICAgZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgdHlwZURhdGE6IHJlY3VycmluZ0RhdGEsIC8vIGRvZXNuJ3QgbmVlZCBlbmRUaW1lIGFueW1vcmUgYnV0IG9oIHdlbGxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBleHBhbmQodHlwZURhdGEsIGZyYW1pbmdSYW5nZSwgZGF0ZUVudikge1xuICAgICAgICBsZXQgY2xpcHBlZEZyYW1pbmdSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhmcmFtaW5nUmFuZ2UsIHsgc3RhcnQ6IHR5cGVEYXRhLnN0YXJ0UmVjdXIsIGVuZDogdHlwZURhdGEuZW5kUmVjdXIgfSk7XG4gICAgICAgIGlmIChjbGlwcGVkRnJhbWluZ1JhbmdlKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwYW5kUmFuZ2VzKHR5cGVEYXRhLmRheXNPZldlZWssIHR5cGVEYXRhLnN0YXJ0VGltZSwgY2xpcHBlZEZyYW1pbmdSYW5nZSwgZGF0ZUVudik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG59O1xuY29uc3Qgc2ltcGxlUmVjdXJyaW5nRXZlbnRzUGx1Z2luID0gY3JlYXRlUGx1Z2luKHtcbiAgICBuYW1lOiAnc2ltcGxlLXJlY3VycmluZy1ldmVudCcsXG4gICAgcmVjdXJyaW5nVHlwZXM6IFtyZWN1cnJpbmddLFxuICAgIGV2ZW50UmVmaW5lcnM6IFNJTVBMRV9SRUNVUlJJTkdfUkVGSU5FUlMsXG59KTtcbmZ1bmN0aW9uIGV4cGFuZFJhbmdlcyhkYXlzT2ZXZWVrLCBzdGFydFRpbWUsIGZyYW1pbmdSYW5nZSwgZGF0ZUVudikge1xuICAgIGxldCBkb3dIYXNoID0gZGF5c09mV2VlayA/IGFycmF5VG9IYXNoKGRheXNPZldlZWspIDogbnVsbDtcbiAgICBsZXQgZGF5TWFya2VyID0gc3RhcnRPZkRheShmcmFtaW5nUmFuZ2Uuc3RhcnQpO1xuICAgIGxldCBlbmRNYXJrZXIgPSBmcmFtaW5nUmFuZ2UuZW5kO1xuICAgIGxldCBpbnN0YW5jZVN0YXJ0cyA9IFtdO1xuICAgIHdoaWxlIChkYXlNYXJrZXIgPCBlbmRNYXJrZXIpIHtcbiAgICAgICAgbGV0IGluc3RhbmNlU3RhcnQ7XG4gICAgICAgIC8vIGlmIGV2ZXJ5ZGF5LCBvciB0aGlzIHBhcnRpY3VsYXIgZGF5LW9mLXdlZWtcbiAgICAgICAgaWYgKCFkb3dIYXNoIHx8IGRvd0hhc2hbZGF5TWFya2VyLmdldFVUQ0RheSgpXSkge1xuICAgICAgICAgICAgaWYgKHN0YXJ0VGltZSkge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlU3RhcnQgPSBkYXRlRW52LmFkZChkYXlNYXJrZXIsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZVN0YXJ0ID0gZGF5TWFya2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5zdGFuY2VTdGFydHMucHVzaChpbnN0YW5jZVN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBkYXlNYXJrZXIgPSBhZGREYXlzKGRheU1hcmtlciwgMSk7XG4gICAgfVxuICAgIHJldHVybiBpbnN0YW5jZVN0YXJ0cztcbn1cblxuY29uc3QgY2hhbmdlSGFuZGxlclBsdWdpbiA9IGNyZWF0ZVBsdWdpbih7XG4gICAgbmFtZTogJ2NoYW5nZS1oYW5kbGVyJyxcbiAgICBvcHRpb25DaGFuZ2VIYW5kbGVyczoge1xuICAgICAgICBldmVudHMoZXZlbnRzLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBoYW5kbGVFdmVudFNvdXJjZXMoW2V2ZW50c10sIGNvbnRleHQpO1xuICAgICAgICB9LFxuICAgICAgICBldmVudFNvdXJjZXM6IGhhbmRsZUV2ZW50U291cmNlcyxcbiAgICB9LFxufSk7XG4vKlxuQlVHOiBpZiBgZXZlbnRgIHdhcyBzdXBwbGllZCwgYWxsIHByZXZpb3VzbHktZ2l2ZW4gYGV2ZW50U291cmNlc2Agd2lsbCBiZSB3aXBlZCBvdXRcbiovXG5mdW5jdGlvbiBoYW5kbGVFdmVudFNvdXJjZXMoaW5wdXRzLCBjb250ZXh0KSB7XG4gICAgbGV0IHVuZm91bmRTb3VyY2VzID0gaGFzaFZhbHVlc1RvQXJyYXkoY29udGV4dC5nZXRDdXJyZW50RGF0YSgpLmV2ZW50U291cmNlcyk7XG4gICAgaWYgKHVuZm91bmRTb3VyY2VzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICBpbnB1dHMubGVuZ3RoID09PSAxICYmXG4gICAgICAgIEFycmF5LmlzQXJyYXkodW5mb3VuZFNvdXJjZXNbMF0uX3JhdykgJiZcbiAgICAgICAgQXJyYXkuaXNBcnJheShpbnB1dHNbMF0pKSB7XG4gICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ1JFU0VUX1JBV19FVkVOVFMnLFxuICAgICAgICAgICAgc291cmNlSWQ6IHVuZm91bmRTb3VyY2VzWzBdLnNvdXJjZUlkLFxuICAgICAgICAgICAgcmF3RXZlbnRzOiBpbnB1dHNbMF0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBuZXdJbnB1dHMgPSBbXTtcbiAgICBmb3IgKGxldCBpbnB1dCBvZiBpbnB1dHMpIHtcbiAgICAgICAgbGV0IGlucHV0Rm91bmQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1bmZvdW5kU291cmNlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKHVuZm91bmRTb3VyY2VzW2ldLl9yYXcgPT09IGlucHV0KSB7XG4gICAgICAgICAgICAgICAgdW5mb3VuZFNvdXJjZXMuc3BsaWNlKGksIDEpOyAvLyBkZWxldGVcbiAgICAgICAgICAgICAgICBpbnB1dEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlucHV0Rm91bmQpIHtcbiAgICAgICAgICAgIG5ld0lucHV0cy5wdXNoKGlucHV0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCB1bmZvdW5kU291cmNlIG9mIHVuZm91bmRTb3VyY2VzKSB7XG4gICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ1JFTU9WRV9FVkVOVF9TT1VSQ0UnLFxuICAgICAgICAgICAgc291cmNlSWQ6IHVuZm91bmRTb3VyY2Uuc291cmNlSWQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKGxldCBuZXdJbnB1dCBvZiBuZXdJbnB1dHMpIHtcbiAgICAgICAgY29udGV4dC5jYWxlbmRhckFwaS5hZGRFdmVudFNvdXJjZShuZXdJbnB1dCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVEYXRlUHJvZmlsZShkYXRlUHJvZmlsZSwgY29udGV4dCkge1xuICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdkYXRlc1NldCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYnVpbGRSYW5nZUFwaVdpdGhUaW1lWm9uZShkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgY29udGV4dC5kYXRlRW52KSksIHsgdmlldzogY29udGV4dC52aWV3QXBpIH0pKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlRXZlbnRTdG9yZShldmVudFN0b3JlLCBjb250ZXh0KSB7XG4gICAgbGV0IHsgZW1pdHRlciB9ID0gY29udGV4dDtcbiAgICBpZiAoZW1pdHRlci5oYXNIYW5kbGVycygnZXZlbnRzU2V0JykpIHtcbiAgICAgICAgZW1pdHRlci50cmlnZ2VyKCdldmVudHNTZXQnLCBidWlsZEV2ZW50QXBpcyhldmVudFN0b3JlLCBjb250ZXh0KSk7XG4gICAgfVxufVxuXG4vKlxudGhpcyBhcnJheSBpcyBleHBvc2VkIG9uIHRoZSByb290IG5hbWVzcGFjZSBzbyB0aGF0IFVNRCBwbHVnaW5zIGNhbiBhZGQgdG8gaXQuXG5zZWUgdGhlIHJvbGx1cC1idW5kbGVzIHNjcmlwdC5cbiovXG5jb25zdCBnbG9iYWxQbHVnaW5zID0gW1xuICAgIGFycmF5RXZlbnRTb3VyY2VQbHVnaW4sXG4gICAgZnVuY0V2ZW50U291cmNlUGx1Z2luLFxuICAgIGpzb25GZWVkRXZlbnRTb3VyY2VQbHVnaW4sXG4gICAgc2ltcGxlUmVjdXJyaW5nRXZlbnRzUGx1Z2luLFxuICAgIGNoYW5nZUhhbmRsZXJQbHVnaW4sXG4gICAgY3JlYXRlUGx1Z2luKHtcbiAgICAgICAgbmFtZTogJ21pc2MnLFxuICAgICAgICBpc0xvYWRpbmdGdW5jczogW1xuICAgICAgICAgICAgKHN0YXRlKSA9PiBjb21wdXRlRXZlbnRTb3VyY2VzTG9hZGluZyhzdGF0ZS5ldmVudFNvdXJjZXMpLFxuICAgICAgICBdLFxuICAgICAgICBwcm9wU2V0SGFuZGxlcnM6IHtcbiAgICAgICAgICAgIGRhdGVQcm9maWxlOiBoYW5kbGVEYXRlUHJvZmlsZSxcbiAgICAgICAgICAgIGV2ZW50U3RvcmU6IGhhbmRsZUV2ZW50U3RvcmUsXG4gICAgICAgIH0sXG4gICAgfSksXG5dO1xuXG5jbGFzcyBUYXNrUnVubmVyIHtcbiAgICBjb25zdHJ1Y3RvcihydW5UYXNrT3B0aW9uLCBkcmFpbmVkT3B0aW9uKSB7XG4gICAgICAgIHRoaXMucnVuVGFza09wdGlvbiA9IHJ1blRhc2tPcHRpb247XG4gICAgICAgIHRoaXMuZHJhaW5lZE9wdGlvbiA9IGRyYWluZWRPcHRpb247XG4gICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5kZWxheWVkUnVubmVyID0gbmV3IERlbGF5ZWRSdW5uZXIodGhpcy5kcmFpbi5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgcmVxdWVzdCh0YXNrLCBkZWxheSkge1xuICAgICAgICB0aGlzLnF1ZXVlLnB1c2godGFzayk7XG4gICAgICAgIHRoaXMuZGVsYXllZFJ1bm5lci5yZXF1ZXN0KGRlbGF5KTtcbiAgICB9XG4gICAgcGF1c2Uoc2NvcGUpIHtcbiAgICAgICAgdGhpcy5kZWxheWVkUnVubmVyLnBhdXNlKHNjb3BlKTtcbiAgICB9XG4gICAgcmVzdW1lKHNjb3BlLCBmb3JjZSkge1xuICAgICAgICB0aGlzLmRlbGF5ZWRSdW5uZXIucmVzdW1lKHNjb3BlLCBmb3JjZSk7XG4gICAgfVxuICAgIGRyYWluKCkge1xuICAgICAgICBsZXQgeyBxdWV1ZSB9ID0gdGhpcztcbiAgICAgICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGNvbXBsZXRlZFRhc2tzID0gW107XG4gICAgICAgICAgICBsZXQgdGFzaztcbiAgICAgICAgICAgIHdoaWxlICgodGFzayA9IHF1ZXVlLnNoaWZ0KCkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5UYXNrKHRhc2spO1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlZFRhc2tzLnB1c2godGFzayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRyYWluZWQoY29tcGxldGVkVGFza3MpO1xuICAgICAgICB9IC8vIGtlZXAgZ29pbmcsIGluIGNhc2UgbmV3IHRhc2tzIHdlcmUgYWRkZWQgaW4gdGhlIGRyYWluZWQgaGFuZGxlclxuICAgIH1cbiAgICBydW5UYXNrKHRhc2spIHtcbiAgICAgICAgaWYgKHRoaXMucnVuVGFza09wdGlvbikge1xuICAgICAgICAgICAgdGhpcy5ydW5UYXNrT3B0aW9uKHRhc2spO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRyYWluZWQoY29tcGxldGVkVGFza3MpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhaW5lZE9wdGlvbikge1xuICAgICAgICAgICAgdGhpcy5kcmFpbmVkT3B0aW9uKGNvbXBsZXRlZFRhc2tzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gQ29tcHV0ZXMgd2hhdCB0aGUgdGl0bGUgYXQgdGhlIHRvcCBvZiB0aGUgY2FsZW5kYXJBcGkgc2hvdWxkIGJlIGZvciB0aGlzIHZpZXdcbmZ1bmN0aW9uIGJ1aWxkVGl0bGUoZGF0ZVByb2ZpbGUsIHZpZXdPcHRpb25zLCBkYXRlRW52KSB7XG4gICAgbGV0IHJhbmdlO1xuICAgIC8vIGZvciB2aWV3cyB0aGF0IHNwYW4gYSBsYXJnZSB1bml0IG9mIHRpbWUsIHNob3cgdGhlIHByb3BlciBpbnRlcnZhbCwgaWdub3Jpbmcgc3RyYXkgZGF5cyBiZWZvcmUgYW5kIGFmdGVyXG4gICAgaWYgKC9eKHllYXJ8bW9udGgpJC8udGVzdChkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2VVbml0KSkge1xuICAgICAgICByYW5nZSA9IGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZTtcbiAgICB9XG4gICAgZWxzZSB7IC8vIGZvciBkYXkgdW5pdHMgb3Igc21hbGxlciwgdXNlIHRoZSBhY3R1YWwgZGF5IHJhbmdlXG4gICAgICAgIHJhbmdlID0gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2U7XG4gICAgfVxuICAgIHJldHVybiBkYXRlRW52LmZvcm1hdFJhbmdlKHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQsIGNyZWF0ZUZvcm1hdHRlcih2aWV3T3B0aW9ucy50aXRsZUZvcm1hdCB8fCBidWlsZFRpdGxlRm9ybWF0KGRhdGVQcm9maWxlKSksIHtcbiAgICAgICAgaXNFbmRFeGNsdXNpdmU6IGRhdGVQcm9maWxlLmlzUmFuZ2VBbGxEYXksXG4gICAgICAgIGRlZmF1bHRTZXBhcmF0b3I6IHZpZXdPcHRpb25zLnRpdGxlUmFuZ2VTZXBhcmF0b3IsXG4gICAgfSk7XG59XG4vLyBHZW5lcmF0ZXMgdGhlIGZvcm1hdCBzdHJpbmcgdGhhdCBzaG91bGQgYmUgdXNlZCB0byBnZW5lcmF0ZSB0aGUgdGl0bGUgZm9yIHRoZSBjdXJyZW50IGRhdGUgcmFuZ2UuXG4vLyBBdHRlbXB0cyB0byBjb21wdXRlIHRoZSBtb3N0IGFwcHJvcHJpYXRlIGZvcm1hdCBpZiBub3QgZXhwbGljaXRseSBzcGVjaWZpZWQgd2l0aCBgdGl0bGVGb3JtYXRgLlxuZnVuY3Rpb24gYnVpbGRUaXRsZUZvcm1hdChkYXRlUHJvZmlsZSkge1xuICAgIGxldCB7IGN1cnJlbnRSYW5nZVVuaXQgfSA9IGRhdGVQcm9maWxlO1xuICAgIGlmIChjdXJyZW50UmFuZ2VVbml0ID09PSAneWVhcicpIHtcbiAgICAgICAgcmV0dXJuIHsgeWVhcjogJ251bWVyaWMnIH07XG4gICAgfVxuICAgIGlmIChjdXJyZW50UmFuZ2VVbml0ID09PSAnbW9udGgnKSB7XG4gICAgICAgIHJldHVybiB7IHllYXI6ICdudW1lcmljJywgbW9udGg6ICdsb25nJyB9OyAvLyBsaWtlIFwiU2VwdGVtYmVyIDIwMTRcIlxuICAgIH1cbiAgICBsZXQgZGF5cyA9IGRpZmZXaG9sZURheXMoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLnN0YXJ0LCBkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2UuZW5kKTtcbiAgICBpZiAoZGF5cyAhPT0gbnVsbCAmJiBkYXlzID4gMSkge1xuICAgICAgICAvLyBtdWx0aS1kYXkgcmFuZ2UuIHNob3J0ZXIsIGxpa2UgXCJTZXAgOSAtIDEwIDIwMTRcIlxuICAgICAgICByZXR1cm4geyB5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnc2hvcnQnLCBkYXk6ICdudW1lcmljJyB9O1xuICAgIH1cbiAgICAvLyBvbmUgZGF5LiBsb25nZXIsIGxpa2UgXCJTZXB0ZW1iZXIgOSAyMDE0XCJcbiAgICByZXR1cm4geyB5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnbG9uZycsIGRheTogJ251bWVyaWMnIH07XG59XG5cbi8vIGluIGZ1dHVyZSByZWZhY3RvciwgZG8gdGhlIHJlZHV4LXN0eWxlIGZ1bmN0aW9uKHN0YXRlPWluaXRpYWwpIGZvciBpbml0aWFsLXN0YXRlXG4vLyBhbHNvLCB3aGF0ZXZlciBpcyBoYXBwZW5pbmcgaW4gY29uc3RydWN0b3IsIGhhdmUgaXQgaGFwcGVuIGluIGFjdGlvbiBxdWV1ZSB0b29cbmNsYXNzIENhbGVuZGFyRGF0YU1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHRoaXMuY29tcHV0ZUN1cnJlbnRWaWV3RGF0YSA9IG1lbW9pemUodGhpcy5fY29tcHV0ZUN1cnJlbnRWaWV3RGF0YSk7XG4gICAgICAgIHRoaXMub3JnYW5pemVSYXdMb2NhbGVzID0gbWVtb2l6ZShvcmdhbml6ZVJhd0xvY2FsZXMpO1xuICAgICAgICB0aGlzLmJ1aWxkTG9jYWxlID0gbWVtb2l6ZShidWlsZExvY2FsZSk7XG4gICAgICAgIHRoaXMuYnVpbGRQbHVnaW5Ib29rcyA9IGJ1aWxkQnVpbGRQbHVnaW5Ib29rcygpO1xuICAgICAgICB0aGlzLmJ1aWxkRGF0ZUVudiA9IG1lbW9pemUoYnVpbGREYXRlRW52JDEpO1xuICAgICAgICB0aGlzLmJ1aWxkVGhlbWUgPSBtZW1vaXplKGJ1aWxkVGhlbWUpO1xuICAgICAgICB0aGlzLnBhcnNlVG9vbGJhcnMgPSBtZW1vaXplKHBhcnNlVG9vbGJhcnMpO1xuICAgICAgICB0aGlzLmJ1aWxkVmlld1NwZWNzID0gbWVtb2l6ZShidWlsZFZpZXdTcGVjcyk7XG4gICAgICAgIHRoaXMuYnVpbGREYXRlUHJvZmlsZUdlbmVyYXRvciA9IG1lbW9pemVPYmpBcmcoYnVpbGREYXRlUHJvZmlsZUdlbmVyYXRvcik7XG4gICAgICAgIHRoaXMuYnVpbGRWaWV3QXBpID0gbWVtb2l6ZShidWlsZFZpZXdBcGkpO1xuICAgICAgICB0aGlzLmJ1aWxkVmlld1VpUHJvcHMgPSBtZW1vaXplT2JqQXJnKGJ1aWxkVmlld1VpUHJvcHMpO1xuICAgICAgICB0aGlzLmJ1aWxkRXZlbnRVaUJ5U291cmNlID0gbWVtb2l6ZShidWlsZEV2ZW50VWlCeVNvdXJjZSwgaXNQcm9wc0VxdWFsKTtcbiAgICAgICAgdGhpcy5idWlsZEV2ZW50VWlCYXNlcyA9IG1lbW9pemUoYnVpbGRFdmVudFVpQmFzZXMpO1xuICAgICAgICB0aGlzLnBhcnNlQ29udGV4dEJ1c2luZXNzSG91cnMgPSBtZW1vaXplT2JqQXJnKHBhcnNlQ29udGV4dEJ1c2luZXNzSG91cnMpO1xuICAgICAgICB0aGlzLmJ1aWxkVGl0bGUgPSBtZW1vaXplKGJ1aWxkVGl0bGUpO1xuICAgICAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xuICAgICAgICB0aGlzLmFjdGlvblJ1bm5lciA9IG5ldyBUYXNrUnVubmVyKHRoaXMuX2hhbmRsZUFjdGlvbi5iaW5kKHRoaXMpLCB0aGlzLnVwZGF0ZURhdGEuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc0lucHV0ID0ge307XG4gICAgICAgIHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZWQgPSB7fTtcbiAgICAgICAgdGhpcy5jdXJyZW50Vmlld09wdGlvbnNJbnB1dCA9IHt9O1xuICAgICAgICB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc1JlZmluZWQgPSB7fTtcbiAgICAgICAgdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lcnMgPSB7fTtcbiAgICAgICAgdGhpcy5vcHRpb25zRm9yUmVmaW5pbmcgPSBbXTtcbiAgICAgICAgdGhpcy5vcHRpb25zRm9ySGFuZGxpbmcgPSBbXTtcbiAgICAgICAgdGhpcy5nZXRDdXJyZW50RGF0YSA9ICgpID0+IHRoaXMuZGF0YTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCA9IChhY3Rpb24pID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uUnVubmVyLnJlcXVlc3QoYWN0aW9uKTsgLy8gcHJvdGVjdHMgYWdhaW5zdCByZWN1cnNpdmUgY2FsbHMgdG8gX2hhbmRsZUFjdGlvblxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICAgIHRoaXMuYWN0aW9uUnVubmVyLnBhdXNlKCk7XG4gICAgICAgIGxldCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzID0ge307XG4gICAgICAgIGxldCBvcHRpb25zRGF0YSA9IHRoaXMuY29tcHV0ZU9wdGlvbnNEYXRhKHByb3BzLm9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcywgcHJvcHMuY2FsZW5kYXJBcGkpO1xuICAgICAgICBsZXQgY3VycmVudFZpZXdUeXBlID0gb3B0aW9uc0RhdGEuY2FsZW5kYXJPcHRpb25zLmluaXRpYWxWaWV3IHx8IG9wdGlvbnNEYXRhLnBsdWdpbkhvb2tzLmluaXRpYWxWaWV3O1xuICAgICAgICBsZXQgY3VycmVudFZpZXdEYXRhID0gdGhpcy5jb21wdXRlQ3VycmVudFZpZXdEYXRhKGN1cnJlbnRWaWV3VHlwZSwgb3B0aW9uc0RhdGEsIHByb3BzLm9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcyk7XG4gICAgICAgIC8vIHdpcmUgdGhpbmdzIHVwXG4gICAgICAgIC8vIFRPRE86IG5vdCBEUllcbiAgICAgICAgcHJvcHMuY2FsZW5kYXJBcGkuY3VycmVudERhdGFNYW5hZ2VyID0gdGhpcztcbiAgICAgICAgdGhpcy5lbWl0dGVyLnNldFRoaXNDb250ZXh0KHByb3BzLmNhbGVuZGFyQXBpKTtcbiAgICAgICAgdGhpcy5lbWl0dGVyLnNldE9wdGlvbnMoY3VycmVudFZpZXdEYXRhLm9wdGlvbnMpO1xuICAgICAgICBsZXQgY3VycmVudERhdGUgPSBnZXRJbml0aWFsRGF0ZShvcHRpb25zRGF0YS5jYWxlbmRhck9wdGlvbnMsIG9wdGlvbnNEYXRhLmRhdGVFbnYpO1xuICAgICAgICBsZXQgZGF0ZVByb2ZpbGUgPSBjdXJyZW50Vmlld0RhdGEuZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGQoY3VycmVudERhdGUpO1xuICAgICAgICBpZiAoIXJhbmdlQ29udGFpbnNNYXJrZXIoZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UsIGN1cnJlbnREYXRlKSkge1xuICAgICAgICAgICAgY3VycmVudERhdGUgPSBkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2Uuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNhbGVuZGFyQ29udGV4dCA9IHtcbiAgICAgICAgICAgIGRhdGVFbnY6IG9wdGlvbnNEYXRhLmRhdGVFbnYsXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zRGF0YS5jYWxlbmRhck9wdGlvbnMsXG4gICAgICAgICAgICBwbHVnaW5Ib29rczogb3B0aW9uc0RhdGEucGx1Z2luSG9va3MsXG4gICAgICAgICAgICBjYWxlbmRhckFwaTogcHJvcHMuY2FsZW5kYXJBcGksXG4gICAgICAgICAgICBkaXNwYXRjaDogdGhpcy5kaXNwYXRjaCxcbiAgICAgICAgICAgIGVtaXR0ZXI6IHRoaXMuZW1pdHRlcixcbiAgICAgICAgICAgIGdldEN1cnJlbnREYXRhOiB0aGlzLmdldEN1cnJlbnREYXRhLFxuICAgICAgICB9O1xuICAgICAgICAvLyBuZWVkcyB0byBiZSBhZnRlciBzZXRUaGlzQ29udGV4dFxuICAgICAgICBmb3IgKGxldCBjYWxsYmFjayBvZiBvcHRpb25zRGF0YS5wbHVnaW5Ib29rcy5jb250ZXh0SW5pdCkge1xuICAgICAgICAgICAgY2FsbGJhY2soY2FsZW5kYXJDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOT1QgRFJZXG4gICAgICAgIGxldCBldmVudFNvdXJjZXMgPSBpbml0RXZlbnRTb3VyY2VzKG9wdGlvbnNEYXRhLmNhbGVuZGFyT3B0aW9ucywgZGF0ZVByb2ZpbGUsIGNhbGVuZGFyQ29udGV4dCk7XG4gICAgICAgIGxldCBpbml0aWFsU3RhdGUgPSB7XG4gICAgICAgICAgICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICAgICAgY3VycmVudFZpZXdUeXBlLFxuICAgICAgICAgICAgY3VycmVudERhdGUsXG4gICAgICAgICAgICBkYXRlUHJvZmlsZSxcbiAgICAgICAgICAgIGJ1c2luZXNzSG91cnM6IHRoaXMucGFyc2VDb250ZXh0QnVzaW5lc3NIb3VycyhjYWxlbmRhckNvbnRleHQpLFxuICAgICAgICAgICAgZXZlbnRTb3VyY2VzLFxuICAgICAgICAgICAgZXZlbnRVaUJhc2VzOiB7fSxcbiAgICAgICAgICAgIGV2ZW50U3RvcmU6IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpLFxuICAgICAgICAgICAgcmVuZGVyYWJsZUV2ZW50U3RvcmU6IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpLFxuICAgICAgICAgICAgZGF0ZVNlbGVjdGlvbjogbnVsbCxcbiAgICAgICAgICAgIGV2ZW50U2VsZWN0aW9uOiAnJyxcbiAgICAgICAgICAgIGV2ZW50RHJhZzogbnVsbCxcbiAgICAgICAgICAgIGV2ZW50UmVzaXplOiBudWxsLFxuICAgICAgICAgICAgc2VsZWN0aW9uQ29uZmlnOiB0aGlzLmJ1aWxkVmlld1VpUHJvcHMoY2FsZW5kYXJDb250ZXh0KS5zZWxlY3Rpb25Db25maWcsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBjb250ZXh0QW5kU3RhdGUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNhbGVuZGFyQ29udGV4dCksIGluaXRpYWxTdGF0ZSk7XG4gICAgICAgIGZvciAobGV0IHJlZHVjZXIgb2Ygb3B0aW9uc0RhdGEucGx1Z2luSG9va3MucmVkdWNlcnMpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaW5pdGlhbFN0YXRlLCByZWR1Y2VyKG51bGwsIG51bGwsIGNvbnRleHRBbmRTdGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wdXRlSXNMb2FkaW5nKGluaXRpYWxTdGF0ZSwgY2FsZW5kYXJDb250ZXh0KSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2xvYWRpbmcnLCB0cnVlKTsgLy8gTk9UIERSWVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gICAgICAgIHRoaXMudXBkYXRlRGF0YSgpO1xuICAgICAgICB0aGlzLmFjdGlvblJ1bm5lci5yZXN1bWUoKTtcbiAgICB9XG4gICAgcmVzZXRPcHRpb25zKG9wdGlvbk92ZXJyaWRlcywgY2hhbmdlZE9wdGlvbk5hbWVzKSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBpZiAoY2hhbmdlZE9wdGlvbk5hbWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHByb3BzLm9wdGlvbk92ZXJyaWRlcyA9IG9wdGlvbk92ZXJyaWRlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByb3BzLm9wdGlvbk92ZXJyaWRlcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKHByb3BzLm9wdGlvbk92ZXJyaWRlcyB8fCB7fSkpLCBvcHRpb25PdmVycmlkZXMpO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zRm9yUmVmaW5pbmcucHVzaCguLi5jaGFuZ2VkT3B0aW9uTmFtZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VkT3B0aW9uTmFtZXMgPT09IHVuZGVmaW5lZCB8fCBjaGFuZ2VkT3B0aW9uTmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGlvblJ1bm5lci5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnTk9USElORycsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaGFuZGxlQWN0aW9uKGFjdGlvbikge1xuICAgICAgICBsZXQgeyBwcm9wcywgc3RhdGUsIGVtaXR0ZXIgfSA9IHRoaXM7XG4gICAgICAgIGxldCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzID0gcmVkdWNlRHluYW1pY09wdGlvbk92ZXJyaWRlcyhzdGF0ZS5keW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBhY3Rpb24pO1xuICAgICAgICBsZXQgb3B0aW9uc0RhdGEgPSB0aGlzLmNvbXB1dGVPcHRpb25zRGF0YShwcm9wcy5vcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsIHByb3BzLmNhbGVuZGFyQXBpKTtcbiAgICAgICAgbGV0IGN1cnJlbnRWaWV3VHlwZSA9IHJlZHVjZVZpZXdUeXBlKHN0YXRlLmN1cnJlbnRWaWV3VHlwZSwgYWN0aW9uKTtcbiAgICAgICAgbGV0IGN1cnJlbnRWaWV3RGF0YSA9IHRoaXMuY29tcHV0ZUN1cnJlbnRWaWV3RGF0YShjdXJyZW50Vmlld1R5cGUsIG9wdGlvbnNEYXRhLCBwcm9wcy5vcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMpO1xuICAgICAgICAvLyB3aXJlIHRoaW5ncyB1cFxuICAgICAgICAvLyBUT0RPOiBub3QgRFJZXG4gICAgICAgIHByb3BzLmNhbGVuZGFyQXBpLmN1cnJlbnREYXRhTWFuYWdlciA9IHRoaXM7XG4gICAgICAgIGVtaXR0ZXIuc2V0VGhpc0NvbnRleHQocHJvcHMuY2FsZW5kYXJBcGkpO1xuICAgICAgICBlbWl0dGVyLnNldE9wdGlvbnMoY3VycmVudFZpZXdEYXRhLm9wdGlvbnMpO1xuICAgICAgICBsZXQgY2FsZW5kYXJDb250ZXh0ID0ge1xuICAgICAgICAgICAgZGF0ZUVudjogb3B0aW9uc0RhdGEuZGF0ZUVudixcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNEYXRhLmNhbGVuZGFyT3B0aW9ucyxcbiAgICAgICAgICAgIHBsdWdpbkhvb2tzOiBvcHRpb25zRGF0YS5wbHVnaW5Ib29rcyxcbiAgICAgICAgICAgIGNhbGVuZGFyQXBpOiBwcm9wcy5jYWxlbmRhckFwaSxcbiAgICAgICAgICAgIGRpc3BhdGNoOiB0aGlzLmRpc3BhdGNoLFxuICAgICAgICAgICAgZW1pdHRlcixcbiAgICAgICAgICAgIGdldEN1cnJlbnREYXRhOiB0aGlzLmdldEN1cnJlbnREYXRhLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgeyBjdXJyZW50RGF0ZSwgZGF0ZVByb2ZpbGUgfSA9IHN0YXRlO1xuICAgICAgICBpZiAodGhpcy5kYXRhICYmIHRoaXMuZGF0YS5kYXRlUHJvZmlsZUdlbmVyYXRvciAhPT0gY3VycmVudFZpZXdEYXRhLmRhdGVQcm9maWxlR2VuZXJhdG9yKSB7IC8vIGhhY2tcbiAgICAgICAgICAgIGRhdGVQcm9maWxlID0gY3VycmVudFZpZXdEYXRhLmRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkKGN1cnJlbnREYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50RGF0ZSA9IHJlZHVjZUN1cnJlbnREYXRlKGN1cnJlbnREYXRlLCBhY3Rpb24pO1xuICAgICAgICBkYXRlUHJvZmlsZSA9IHJlZHVjZURhdGVQcm9maWxlKGRhdGVQcm9maWxlLCBhY3Rpb24sIGN1cnJlbnREYXRlLCBjdXJyZW50Vmlld0RhdGEuZGF0ZVByb2ZpbGVHZW5lcmF0b3IpO1xuICAgICAgICBpZiAoYWN0aW9uLnR5cGUgPT09ICdQUkVWJyB8fCAvLyBUT0RPOiBtb3ZlIHRoaXMgbG9naWMgaW50byBEYXRlUHJvZmlsZUdlbmVyYXRvclxuICAgICAgICAgICAgYWN0aW9uLnR5cGUgPT09ICdORVhUJyB8fCAvLyBcIlxuICAgICAgICAgICAgIXJhbmdlQ29udGFpbnNNYXJrZXIoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLCBjdXJyZW50RGF0ZSkpIHtcbiAgICAgICAgICAgIGN1cnJlbnREYXRlID0gZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGxldCBldmVudFNvdXJjZXMgPSByZWR1Y2VFdmVudFNvdXJjZXMoc3RhdGUuZXZlbnRTb3VyY2VzLCBhY3Rpb24sIGRhdGVQcm9maWxlLCBjYWxlbmRhckNvbnRleHQpO1xuICAgICAgICBsZXQgZXZlbnRTdG9yZSA9IHJlZHVjZUV2ZW50U3RvcmUoc3RhdGUuZXZlbnRTdG9yZSwgYWN0aW9uLCBldmVudFNvdXJjZXMsIGRhdGVQcm9maWxlLCBjYWxlbmRhckNvbnRleHQpO1xuICAgICAgICBsZXQgaXNFdmVudHNMb2FkaW5nID0gY29tcHV0ZUV2ZW50U291cmNlc0xvYWRpbmcoZXZlbnRTb3VyY2VzKTsgLy8gQkFELiBhbHNvIGNhbGxlZCBpbiB0aGlzIGZ1bmMgaW4gY29tcHV0ZUlzTG9hZGluZ1xuICAgICAgICBsZXQgcmVuZGVyYWJsZUV2ZW50U3RvcmUgPSAoaXNFdmVudHNMb2FkaW5nICYmICFjdXJyZW50Vmlld0RhdGEub3B0aW9ucy5wcm9ncmVzc2l2ZUV2ZW50UmVuZGVyaW5nKSA/XG4gICAgICAgICAgICAoc3RhdGUucmVuZGVyYWJsZUV2ZW50U3RvcmUgfHwgZXZlbnRTdG9yZSkgOiAvLyB0cnkgZnJvbSBwcmV2aW91cyBzdGF0ZVxuICAgICAgICAgICAgZXZlbnRTdG9yZTtcbiAgICAgICAgbGV0IHsgZXZlbnRVaVNpbmdsZUJhc2UsIHNlbGVjdGlvbkNvbmZpZyB9ID0gdGhpcy5idWlsZFZpZXdVaVByb3BzKGNhbGVuZGFyQ29udGV4dCk7IC8vIHdpbGwgbWVtb2l6ZSBvYmpcbiAgICAgICAgbGV0IGV2ZW50VWlCeVNvdXJjZSA9IHRoaXMuYnVpbGRFdmVudFVpQnlTb3VyY2UoZXZlbnRTb3VyY2VzKTtcbiAgICAgICAgbGV0IGV2ZW50VWlCYXNlcyA9IHRoaXMuYnVpbGRFdmVudFVpQmFzZXMocmVuZGVyYWJsZUV2ZW50U3RvcmUuZGVmcywgZXZlbnRVaVNpbmdsZUJhc2UsIGV2ZW50VWlCeVNvdXJjZSk7XG4gICAgICAgIGxldCBuZXdTdGF0ZSA9IHtcbiAgICAgICAgICAgIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsXG4gICAgICAgICAgICBjdXJyZW50Vmlld1R5cGUsXG4gICAgICAgICAgICBjdXJyZW50RGF0ZSxcbiAgICAgICAgICAgIGRhdGVQcm9maWxlLFxuICAgICAgICAgICAgZXZlbnRTb3VyY2VzLFxuICAgICAgICAgICAgZXZlbnRTdG9yZSxcbiAgICAgICAgICAgIHJlbmRlcmFibGVFdmVudFN0b3JlLFxuICAgICAgICAgICAgc2VsZWN0aW9uQ29uZmlnLFxuICAgICAgICAgICAgZXZlbnRVaUJhc2VzLFxuICAgICAgICAgICAgYnVzaW5lc3NIb3VyczogdGhpcy5wYXJzZUNvbnRleHRCdXNpbmVzc0hvdXJzKGNhbGVuZGFyQ29udGV4dCksXG4gICAgICAgICAgICBkYXRlU2VsZWN0aW9uOiByZWR1Y2VEYXRlU2VsZWN0aW9uKHN0YXRlLmRhdGVTZWxlY3Rpb24sIGFjdGlvbiksXG4gICAgICAgICAgICBldmVudFNlbGVjdGlvbjogcmVkdWNlU2VsZWN0ZWRFdmVudChzdGF0ZS5ldmVudFNlbGVjdGlvbiwgYWN0aW9uKSxcbiAgICAgICAgICAgIGV2ZW50RHJhZzogcmVkdWNlRXZlbnREcmFnKHN0YXRlLmV2ZW50RHJhZywgYWN0aW9uKSxcbiAgICAgICAgICAgIGV2ZW50UmVzaXplOiByZWR1Y2VFdmVudFJlc2l6ZShzdGF0ZS5ldmVudFJlc2l6ZSwgYWN0aW9uKSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGNvbnRleHRBbmRTdGF0ZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY2FsZW5kYXJDb250ZXh0KSwgbmV3U3RhdGUpO1xuICAgICAgICBmb3IgKGxldCByZWR1Y2VyIG9mIG9wdGlvbnNEYXRhLnBsdWdpbkhvb2tzLnJlZHVjZXJzKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG5ld1N0YXRlLCByZWR1Y2VyKHN0YXRlLCBhY3Rpb24sIGNvbnRleHRBbmRTdGF0ZSkpOyAvLyBnaXZlIHRoZSBPTEQgc3RhdGUsIGZvciBvbGQgdmFsdWVcbiAgICAgICAgfVxuICAgICAgICBsZXQgd2FzTG9hZGluZyA9IGNvbXB1dGVJc0xvYWRpbmcoc3RhdGUsIGNhbGVuZGFyQ29udGV4dCk7XG4gICAgICAgIGxldCBpc0xvYWRpbmcgPSBjb21wdXRlSXNMb2FkaW5nKG5ld1N0YXRlLCBjYWxlbmRhckNvbnRleHQpO1xuICAgICAgICAvLyBUT0RPOiB1c2UgcHJvcFNldEhhbmRsZXJzIGluIHBsdWdpbiBzeXN0ZW1cbiAgICAgICAgaWYgKCF3YXNMb2FkaW5nICYmIGlzTG9hZGluZykge1xuICAgICAgICAgICAgZW1pdHRlci50cmlnZ2VyKCdsb2FkaW5nJywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAod2FzTG9hZGluZyAmJiAhaXNMb2FkaW5nKSB7XG4gICAgICAgICAgICBlbWl0dGVyLnRyaWdnZXIoJ2xvYWRpbmcnLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICBpZiAocHJvcHMub25BY3Rpb24pIHtcbiAgICAgICAgICAgIHByb3BzLm9uQWN0aW9uKGFjdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlRGF0YSgpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIHN0YXRlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgb2xkRGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgbGV0IG9wdGlvbnNEYXRhID0gdGhpcy5jb21wdXRlT3B0aW9uc0RhdGEocHJvcHMub3B0aW9uT3ZlcnJpZGVzLCBzdGF0ZS5keW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBwcm9wcy5jYWxlbmRhckFwaSk7XG4gICAgICAgIGxldCBjdXJyZW50Vmlld0RhdGEgPSB0aGlzLmNvbXB1dGVDdXJyZW50Vmlld0RhdGEoc3RhdGUuY3VycmVudFZpZXdUeXBlLCBvcHRpb25zRGF0YSwgcHJvcHMub3B0aW9uT3ZlcnJpZGVzLCBzdGF0ZS5keW5hbWljT3B0aW9uT3ZlcnJpZGVzKTtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmRhdGEgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IHZpZXdUaXRsZTogdGhpcy5idWlsZFRpdGxlKHN0YXRlLmRhdGVQcm9maWxlLCBjdXJyZW50Vmlld0RhdGEub3B0aW9ucywgb3B0aW9uc0RhdGEuZGF0ZUVudiksIGNhbGVuZGFyQXBpOiBwcm9wcy5jYWxlbmRhckFwaSwgZGlzcGF0Y2g6IHRoaXMuZGlzcGF0Y2gsIGVtaXR0ZXI6IHRoaXMuZW1pdHRlciwgZ2V0Q3VycmVudERhdGE6IHRoaXMuZ2V0Q3VycmVudERhdGEgfSwgb3B0aW9uc0RhdGEpLCBjdXJyZW50Vmlld0RhdGEpLCBzdGF0ZSk7XG4gICAgICAgIGxldCBjaGFuZ2VIYW5kbGVycyA9IG9wdGlvbnNEYXRhLnBsdWdpbkhvb2tzLm9wdGlvbkNoYW5nZUhhbmRsZXJzO1xuICAgICAgICBsZXQgb2xkQ2FsZW5kYXJPcHRpb25zID0gb2xkRGF0YSAmJiBvbGREYXRhLmNhbGVuZGFyT3B0aW9ucztcbiAgICAgICAgbGV0IG5ld0NhbGVuZGFyT3B0aW9ucyA9IG9wdGlvbnNEYXRhLmNhbGVuZGFyT3B0aW9ucztcbiAgICAgICAgaWYgKG9sZENhbGVuZGFyT3B0aW9ucyAmJiBvbGRDYWxlbmRhck9wdGlvbnMgIT09IG5ld0NhbGVuZGFyT3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKG9sZENhbGVuZGFyT3B0aW9ucy50aW1lWm9uZSAhPT0gbmV3Q2FsZW5kYXJPcHRpb25zLnRpbWVab25lKSB7XG4gICAgICAgICAgICAgICAgLy8gaGFja1xuICAgICAgICAgICAgICAgIHN0YXRlLmV2ZW50U291cmNlcyA9IGRhdGEuZXZlbnRTb3VyY2VzID0gcmVkdWNlRXZlbnRTb3VyY2VzTmV3VGltZVpvbmUoZGF0YS5ldmVudFNvdXJjZXMsIHN0YXRlLmRhdGVQcm9maWxlLCBkYXRhKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5ldmVudFN0b3JlID0gZGF0YS5ldmVudFN0b3JlID0gcmV6b25lRXZlbnRTdG9yZURhdGVzKGRhdGEuZXZlbnRTdG9yZSwgb2xkRGF0YS5kYXRlRW52LCBkYXRhLmRhdGVFbnYpO1xuICAgICAgICAgICAgICAgIHN0YXRlLnJlbmRlcmFibGVFdmVudFN0b3JlID0gZGF0YS5yZW5kZXJhYmxlRXZlbnRTdG9yZSA9IHJlem9uZUV2ZW50U3RvcmVEYXRlcyhkYXRhLnJlbmRlcmFibGVFdmVudFN0b3JlLCBvbGREYXRhLmRhdGVFbnYsIGRhdGEuZGF0ZUVudik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBvcHRpb25OYW1lIGluIGNoYW5nZUhhbmRsZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uc0ZvckhhbmRsaW5nLmluZGV4T2Yob3B0aW9uTmFtZSkgIT09IC0xIHx8XG4gICAgICAgICAgICAgICAgICAgIG9sZENhbGVuZGFyT3B0aW9uc1tvcHRpb25OYW1lXSAhPT0gbmV3Q2FsZW5kYXJPcHRpb25zW29wdGlvbk5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUhhbmRsZXJzW29wdGlvbk5hbWVdKG5ld0NhbGVuZGFyT3B0aW9uc1tvcHRpb25OYW1lXSwgZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9uc0ZvckhhbmRsaW5nID0gW107XG4gICAgICAgIGlmIChwcm9wcy5vbkRhdGEpIHtcbiAgICAgICAgICAgIHByb3BzLm9uRGF0YShkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wdXRlT3B0aW9uc0RhdGEob3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBjYWxlbmRhckFwaSkge1xuICAgICAgICAvLyBUT0RPOiBibGFja2xpc3Qgb3B0aW9ucyB0aGF0IGFyZSBoYW5kbGVkIGJ5IG9wdGlvbkNoYW5nZUhhbmRsZXJzXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zRm9yUmVmaW5pbmcubGVuZ3RoICYmXG4gICAgICAgICAgICBvcHRpb25PdmVycmlkZXMgPT09IHRoaXMuc3RhYmxlT3B0aW9uT3ZlcnJpZGVzICYmXG4gICAgICAgICAgICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzID09PSB0aGlzLnN0YWJsZUR5bmFtaWNPcHRpb25PdmVycmlkZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YWJsZUNhbGVuZGFyT3B0aW9uc0RhdGE7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgcmVmaW5lZE9wdGlvbnMsIHBsdWdpbkhvb2tzLCBsb2NhbGVEZWZhdWx0cywgYXZhaWxhYmxlTG9jYWxlRGF0YSwgZXh0cmEsIH0gPSB0aGlzLnByb2Nlc3NSYXdDYWxlbmRhck9wdGlvbnMob3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKTtcbiAgICAgICAgd2FyblVua25vd25PcHRpb25zKGV4dHJhKTtcbiAgICAgICAgbGV0IGRhdGVFbnYgPSB0aGlzLmJ1aWxkRGF0ZUVudihyZWZpbmVkT3B0aW9ucy50aW1lWm9uZSwgcmVmaW5lZE9wdGlvbnMubG9jYWxlLCByZWZpbmVkT3B0aW9ucy53ZWVrTnVtYmVyQ2FsY3VsYXRpb24sIHJlZmluZWRPcHRpb25zLmZpcnN0RGF5LCByZWZpbmVkT3B0aW9ucy53ZWVrVGV4dCwgcGx1Z2luSG9va3MsIGF2YWlsYWJsZUxvY2FsZURhdGEsIHJlZmluZWRPcHRpb25zLmRlZmF1bHRSYW5nZVNlcGFyYXRvcik7XG4gICAgICAgIGxldCB2aWV3U3BlY3MgPSB0aGlzLmJ1aWxkVmlld1NwZWNzKHBsdWdpbkhvb2tzLnZpZXdzLCB0aGlzLnN0YWJsZU9wdGlvbk92ZXJyaWRlcywgdGhpcy5zdGFibGVEeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBsb2NhbGVEZWZhdWx0cyk7XG4gICAgICAgIGxldCB0aGVtZSA9IHRoaXMuYnVpbGRUaGVtZShyZWZpbmVkT3B0aW9ucywgcGx1Z2luSG9va3MpO1xuICAgICAgICBsZXQgdG9vbGJhckNvbmZpZyA9IHRoaXMucGFyc2VUb29sYmFycyhyZWZpbmVkT3B0aW9ucywgdGhpcy5zdGFibGVPcHRpb25PdmVycmlkZXMsIHRoZW1lLCB2aWV3U3BlY3MsIGNhbGVuZGFyQXBpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhYmxlQ2FsZW5kYXJPcHRpb25zRGF0YSA9IHtcbiAgICAgICAgICAgIGNhbGVuZGFyT3B0aW9uczogcmVmaW5lZE9wdGlvbnMsXG4gICAgICAgICAgICBwbHVnaW5Ib29rcyxcbiAgICAgICAgICAgIGRhdGVFbnYsXG4gICAgICAgICAgICB2aWV3U3BlY3MsXG4gICAgICAgICAgICB0aGVtZSxcbiAgICAgICAgICAgIHRvb2xiYXJDb25maWcsXG4gICAgICAgICAgICBsb2NhbGVEZWZhdWx0cyxcbiAgICAgICAgICAgIGF2YWlsYWJsZVJhd0xvY2FsZXM6IGF2YWlsYWJsZUxvY2FsZURhdGEubWFwLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBhbHdheXMgY2FsbGVkIGZyb20gYmVoaW5kIGEgbWVtb2l6ZXJcbiAgICBwcm9jZXNzUmF3Q2FsZW5kYXJPcHRpb25zKG9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcykge1xuICAgICAgICBsZXQgeyBsb2NhbGVzLCBsb2NhbGUgfSA9IG1lcmdlUmF3T3B0aW9ucyhbXG4gICAgICAgICAgICBCQVNFX09QVElPTl9ERUZBVUxUUyxcbiAgICAgICAgICAgIG9wdGlvbk92ZXJyaWRlcyxcbiAgICAgICAgICAgIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsXG4gICAgICAgIF0pO1xuICAgICAgICBsZXQgYXZhaWxhYmxlTG9jYWxlRGF0YSA9IHRoaXMub3JnYW5pemVSYXdMb2NhbGVzKGxvY2FsZXMpO1xuICAgICAgICBsZXQgYXZhaWxhYmxlUmF3TG9jYWxlcyA9IGF2YWlsYWJsZUxvY2FsZURhdGEubWFwO1xuICAgICAgICBsZXQgbG9jYWxlRGVmYXVsdHMgPSB0aGlzLmJ1aWxkTG9jYWxlKGxvY2FsZSB8fCBhdmFpbGFibGVMb2NhbGVEYXRhLmRlZmF1bHRDb2RlLCBhdmFpbGFibGVSYXdMb2NhbGVzKS5vcHRpb25zO1xuICAgICAgICBsZXQgcGx1Z2luSG9va3MgPSB0aGlzLmJ1aWxkUGx1Z2luSG9va3Mob3B0aW9uT3ZlcnJpZGVzLnBsdWdpbnMgfHwgW10sIGdsb2JhbFBsdWdpbnMpO1xuICAgICAgICBsZXQgcmVmaW5lcnMgPSB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgQkFTRV9PUFRJT05fUkVGSU5FUlMpLCBDQUxFTkRBUl9MSVNURU5FUl9SRUZJTkVSUyksIENBTEVOREFSX09QVElPTl9SRUZJTkVSUyksIHBsdWdpbkhvb2tzLmxpc3RlbmVyUmVmaW5lcnMpLCBwbHVnaW5Ib29rcy5vcHRpb25SZWZpbmVycyk7XG4gICAgICAgIGxldCBleHRyYSA9IHt9O1xuICAgICAgICBsZXQgcmF3ID0gbWVyZ2VSYXdPcHRpb25zKFtcbiAgICAgICAgICAgIEJBU0VfT1BUSU9OX0RFRkFVTFRTLFxuICAgICAgICAgICAgbG9jYWxlRGVmYXVsdHMsXG4gICAgICAgICAgICBvcHRpb25PdmVycmlkZXMsXG4gICAgICAgICAgICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICBdKTtcbiAgICAgICAgbGV0IHJlZmluZWQgPSB7fTtcbiAgICAgICAgbGV0IGN1cnJlbnRSYXcgPSB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dDtcbiAgICAgICAgbGV0IGN1cnJlbnRSZWZpbmVkID0gdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lZDtcbiAgICAgICAgbGV0IGFueUNoYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgb3B0aW9uTmFtZSBpbiByYXcpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNGb3JSZWZpbmluZy5pbmRleE9mKG9wdGlvbk5hbWUpID09PSAtMSAmJiAocmF3W29wdGlvbk5hbWVdID09PSBjdXJyZW50UmF3W29wdGlvbk5hbWVdIHx8IChDT01QTEVYX09QVElPTl9DT01QQVJBVE9SU1tvcHRpb25OYW1lXSAmJlxuICAgICAgICAgICAgICAgIChvcHRpb25OYW1lIGluIGN1cnJlbnRSYXcpICYmXG4gICAgICAgICAgICAgICAgQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlNbb3B0aW9uTmFtZV0oY3VycmVudFJhd1tvcHRpb25OYW1lXSwgcmF3W29wdGlvbk5hbWVdKSkpKSB7XG4gICAgICAgICAgICAgICAgcmVmaW5lZFtvcHRpb25OYW1lXSA9IGN1cnJlbnRSZWZpbmVkW29wdGlvbk5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVmaW5lcnNbb3B0aW9uTmFtZV0pIHtcbiAgICAgICAgICAgICAgICByZWZpbmVkW29wdGlvbk5hbWVdID0gcmVmaW5lcnNbb3B0aW9uTmFtZV0ocmF3W29wdGlvbk5hbWVdKTtcbiAgICAgICAgICAgICAgICBhbnlDaGFuZ2VzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4dHJhW29wdGlvbk5hbWVdID0gY3VycmVudFJhd1tvcHRpb25OYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYW55Q2hhbmdlcykge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXQgPSByYXc7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVkID0gcmVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuc3RhYmxlT3B0aW9uT3ZlcnJpZGVzID0gb3B0aW9uT3ZlcnJpZGVzO1xuICAgICAgICAgICAgdGhpcy5zdGFibGVEeW5hbWljT3B0aW9uT3ZlcnJpZGVzID0gZHluYW1pY09wdGlvbk92ZXJyaWRlcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnNGb3JIYW5kbGluZy5wdXNoKC4uLnRoaXMub3B0aW9uc0ZvclJlZmluaW5nKTtcbiAgICAgICAgdGhpcy5vcHRpb25zRm9yUmVmaW5pbmcgPSBbXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhd09wdGlvbnM6IHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc0lucHV0LFxuICAgICAgICAgICAgcmVmaW5lZE9wdGlvbnM6IHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZWQsXG4gICAgICAgICAgICBwbHVnaW5Ib29rcyxcbiAgICAgICAgICAgIGF2YWlsYWJsZUxvY2FsZURhdGEsXG4gICAgICAgICAgICBsb2NhbGVEZWZhdWx0cyxcbiAgICAgICAgICAgIGV4dHJhLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfY29tcHV0ZUN1cnJlbnRWaWV3RGF0YSh2aWV3VHlwZSwgb3B0aW9uc0RhdGEsIG9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcykge1xuICAgICAgICBsZXQgdmlld1NwZWMgPSBvcHRpb25zRGF0YS52aWV3U3BlY3Nbdmlld1R5cGVdO1xuICAgICAgICBpZiAoIXZpZXdTcGVjKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHZpZXdUeXBlIFwiJHt2aWV3VHlwZX1cIiBpcyBub3QgYXZhaWxhYmxlLiBQbGVhc2UgbWFrZSBzdXJlIHlvdSd2ZSBsb2FkZWQgYWxsIG5lY2Nlc3NhcnkgcGx1Z2luc2ApO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IHJlZmluZWRPcHRpb25zLCBleHRyYSB9ID0gdGhpcy5wcm9jZXNzUmF3Vmlld09wdGlvbnModmlld1NwZWMsIG9wdGlvbnNEYXRhLnBsdWdpbkhvb2tzLCBvcHRpb25zRGF0YS5sb2NhbGVEZWZhdWx0cywgb3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKTtcbiAgICAgICAgd2FyblVua25vd25PcHRpb25zKGV4dHJhKTtcbiAgICAgICAgbGV0IGRhdGVQcm9maWxlR2VuZXJhdG9yID0gdGhpcy5idWlsZERhdGVQcm9maWxlR2VuZXJhdG9yKHtcbiAgICAgICAgICAgIGRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3M6IHZpZXdTcGVjLm9wdGlvbkRlZmF1bHRzLmRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3MsXG4gICAgICAgICAgICBkdXJhdGlvbjogdmlld1NwZWMuZHVyYXRpb24sXG4gICAgICAgICAgICBkdXJhdGlvblVuaXQ6IHZpZXdTcGVjLmR1cmF0aW9uVW5pdCxcbiAgICAgICAgICAgIHVzZXNNaW5NYXhUaW1lOiB2aWV3U3BlYy5vcHRpb25EZWZhdWx0cy51c2VzTWluTWF4VGltZSxcbiAgICAgICAgICAgIGRhdGVFbnY6IG9wdGlvbnNEYXRhLmRhdGVFbnYsXG4gICAgICAgICAgICBjYWxlbmRhckFwaTogdGhpcy5wcm9wcy5jYWxlbmRhckFwaSxcbiAgICAgICAgICAgIHNsb3RNaW5UaW1lOiByZWZpbmVkT3B0aW9ucy5zbG90TWluVGltZSxcbiAgICAgICAgICAgIHNsb3RNYXhUaW1lOiByZWZpbmVkT3B0aW9ucy5zbG90TWF4VGltZSxcbiAgICAgICAgICAgIHNob3dOb25DdXJyZW50RGF0ZXM6IHJlZmluZWRPcHRpb25zLnNob3dOb25DdXJyZW50RGF0ZXMsXG4gICAgICAgICAgICBkYXlDb3VudDogcmVmaW5lZE9wdGlvbnMuZGF5Q291bnQsXG4gICAgICAgICAgICBkYXRlQWxpZ25tZW50OiByZWZpbmVkT3B0aW9ucy5kYXRlQWxpZ25tZW50LFxuICAgICAgICAgICAgZGF0ZUluY3JlbWVudDogcmVmaW5lZE9wdGlvbnMuZGF0ZUluY3JlbWVudCxcbiAgICAgICAgICAgIGhpZGRlbkRheXM6IHJlZmluZWRPcHRpb25zLmhpZGRlbkRheXMsXG4gICAgICAgICAgICB3ZWVrZW5kczogcmVmaW5lZE9wdGlvbnMud2Vla2VuZHMsXG4gICAgICAgICAgICBub3dJbnB1dDogcmVmaW5lZE9wdGlvbnMubm93LFxuICAgICAgICAgICAgdmFsaWRSYW5nZUlucHV0OiByZWZpbmVkT3B0aW9ucy52YWxpZFJhbmdlLFxuICAgICAgICAgICAgdmlzaWJsZVJhbmdlSW5wdXQ6IHJlZmluZWRPcHRpb25zLnZpc2libGVSYW5nZSxcbiAgICAgICAgICAgIGZpeGVkV2Vla0NvdW50OiByZWZpbmVkT3B0aW9ucy5maXhlZFdlZWtDb3VudCxcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCB2aWV3QXBpID0gdGhpcy5idWlsZFZpZXdBcGkodmlld1R5cGUsIHRoaXMuZ2V0Q3VycmVudERhdGEsIG9wdGlvbnNEYXRhLmRhdGVFbnYpO1xuICAgICAgICByZXR1cm4geyB2aWV3U3BlYywgb3B0aW9uczogcmVmaW5lZE9wdGlvbnMsIGRhdGVQcm9maWxlR2VuZXJhdG9yLCB2aWV3QXBpIH07XG4gICAgfVxuICAgIHByb2Nlc3NSYXdWaWV3T3B0aW9ucyh2aWV3U3BlYywgcGx1Z2luSG9va3MsIGxvY2FsZURlZmF1bHRzLCBvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMpIHtcbiAgICAgICAgbGV0IHJhdyA9IG1lcmdlUmF3T3B0aW9ucyhbXG4gICAgICAgICAgICBCQVNFX09QVElPTl9ERUZBVUxUUyxcbiAgICAgICAgICAgIHZpZXdTcGVjLm9wdGlvbkRlZmF1bHRzLFxuICAgICAgICAgICAgbG9jYWxlRGVmYXVsdHMsXG4gICAgICAgICAgICBvcHRpb25PdmVycmlkZXMsXG4gICAgICAgICAgICB2aWV3U3BlYy5vcHRpb25PdmVycmlkZXMsXG4gICAgICAgICAgICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICBdKTtcbiAgICAgICAgbGV0IHJlZmluZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIEJBU0VfT1BUSU9OX1JFRklORVJTKSwgQ0FMRU5EQVJfTElTVEVORVJfUkVGSU5FUlMpLCBDQUxFTkRBUl9PUFRJT05fUkVGSU5FUlMpLCBWSUVXX09QVElPTl9SRUZJTkVSUyksIHBsdWdpbkhvb2tzLmxpc3RlbmVyUmVmaW5lcnMpLCBwbHVnaW5Ib29rcy5vcHRpb25SZWZpbmVycyk7XG4gICAgICAgIGxldCByZWZpbmVkID0ge307XG4gICAgICAgIGxldCBjdXJyZW50UmF3ID0gdGhpcy5jdXJyZW50Vmlld09wdGlvbnNJbnB1dDtcbiAgICAgICAgbGV0IGN1cnJlbnRSZWZpbmVkID0gdGhpcy5jdXJyZW50Vmlld09wdGlvbnNSZWZpbmVkO1xuICAgICAgICBsZXQgYW55Q2hhbmdlcyA9IGZhbHNlO1xuICAgICAgICBsZXQgZXh0cmEgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgb3B0aW9uTmFtZSBpbiByYXcpIHtcbiAgICAgICAgICAgIGlmIChyYXdbb3B0aW9uTmFtZV0gPT09IGN1cnJlbnRSYXdbb3B0aW9uTmFtZV0gfHxcbiAgICAgICAgICAgICAgICAoQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlNbb3B0aW9uTmFtZV0gJiZcbiAgICAgICAgICAgICAgICAgICAgQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlNbb3B0aW9uTmFtZV0ocmF3W29wdGlvbk5hbWVdLCBjdXJyZW50UmF3W29wdGlvbk5hbWVdKSkpIHtcbiAgICAgICAgICAgICAgICByZWZpbmVkW29wdGlvbk5hbWVdID0gY3VycmVudFJlZmluZWRbb3B0aW9uTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocmF3W29wdGlvbk5hbWVdID09PSB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dFtvcHRpb25OYW1lXSB8fFxuICAgICAgICAgICAgICAgICAgICAoQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlNbb3B0aW9uTmFtZV0gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIENPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTW29wdGlvbk5hbWVdKHJhd1tvcHRpb25OYW1lXSwgdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXRbb3B0aW9uTmFtZV0pKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9uTmFtZSBpbiB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVkKSB7IC8vIG1pZ2h0IGJlIGFuIFwiZXh0cmFcIiBwcm9wXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZpbmVkW29wdGlvbk5hbWVdID0gdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lZFtvcHRpb25OYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWZpbmVyc1tvcHRpb25OYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICByZWZpbmVkW29wdGlvbk5hbWVdID0gcmVmaW5lcnNbb3B0aW9uTmFtZV0ocmF3W29wdGlvbk5hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhW29wdGlvbk5hbWVdID0gcmF3W29wdGlvbk5hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhbnlDaGFuZ2VzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYW55Q2hhbmdlcykge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Vmlld09wdGlvbnNJbnB1dCA9IHJhdztcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFZpZXdPcHRpb25zUmVmaW5lZCA9IHJlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhd09wdGlvbnM6IHRoaXMuY3VycmVudFZpZXdPcHRpb25zSW5wdXQsXG4gICAgICAgICAgICByZWZpbmVkT3B0aW9uczogdGhpcy5jdXJyZW50Vmlld09wdGlvbnNSZWZpbmVkLFxuICAgICAgICAgICAgZXh0cmEsXG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gYnVpbGREYXRlRW52JDEodGltZVpvbmUsIGV4cGxpY2l0TG9jYWxlLCB3ZWVrTnVtYmVyQ2FsY3VsYXRpb24sIGZpcnN0RGF5LCB3ZWVrVGV4dCwgcGx1Z2luSG9va3MsIGF2YWlsYWJsZUxvY2FsZURhdGEsIGRlZmF1bHRTZXBhcmF0b3IpIHtcbiAgICBsZXQgbG9jYWxlID0gYnVpbGRMb2NhbGUoZXhwbGljaXRMb2NhbGUgfHwgYXZhaWxhYmxlTG9jYWxlRGF0YS5kZWZhdWx0Q29kZSwgYXZhaWxhYmxlTG9jYWxlRGF0YS5tYXApO1xuICAgIHJldHVybiBuZXcgRGF0ZUVudih7XG4gICAgICAgIGNhbGVuZGFyU3lzdGVtOiAnZ3JlZ29yeScsXG4gICAgICAgIHRpbWVab25lLFxuICAgICAgICBuYW1lZFRpbWVab25lSW1wbDogcGx1Z2luSG9va3MubmFtZWRUaW1lWm9uZWRJbXBsLFxuICAgICAgICBsb2NhbGUsXG4gICAgICAgIHdlZWtOdW1iZXJDYWxjdWxhdGlvbixcbiAgICAgICAgZmlyc3REYXksXG4gICAgICAgIHdlZWtUZXh0LFxuICAgICAgICBjbWRGb3JtYXR0ZXI6IHBsdWdpbkhvb2tzLmNtZEZvcm1hdHRlcixcbiAgICAgICAgZGVmYXVsdFNlcGFyYXRvcixcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGJ1aWxkVGhlbWUob3B0aW9ucywgcGx1Z2luSG9va3MpIHtcbiAgICBsZXQgVGhlbWVDbGFzcyA9IHBsdWdpbkhvb2tzLnRoZW1lQ2xhc3Nlc1tvcHRpb25zLnRoZW1lU3lzdGVtXSB8fCBTdGFuZGFyZFRoZW1lO1xuICAgIHJldHVybiBuZXcgVGhlbWVDbGFzcyhvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRGF0ZVByb2ZpbGVHZW5lcmF0b3IocHJvcHMpIHtcbiAgICBsZXQgRGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyA9IHByb3BzLmRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3MgfHwgRGF0ZVByb2ZpbGVHZW5lcmF0b3I7XG4gICAgcmV0dXJuIG5ldyBEYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzKHByb3BzKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkVmlld0FwaSh0eXBlLCBnZXRDdXJyZW50RGF0YSwgZGF0ZUVudikge1xuICAgIHJldHVybiBuZXcgVmlld0ltcGwodHlwZSwgZ2V0Q3VycmVudERhdGEsIGRhdGVFbnYpO1xufVxuZnVuY3Rpb24gYnVpbGRFdmVudFVpQnlTb3VyY2UoZXZlbnRTb3VyY2VzKSB7XG4gICAgcmV0dXJuIG1hcEhhc2goZXZlbnRTb3VyY2VzLCAoZXZlbnRTb3VyY2UpID0+IGV2ZW50U291cmNlLnVpKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRXZlbnRVaUJhc2VzKGV2ZW50RGVmcywgZXZlbnRVaVNpbmdsZUJhc2UsIGV2ZW50VWlCeVNvdXJjZSkge1xuICAgIGxldCBldmVudFVpQmFzZXMgPSB7ICcnOiBldmVudFVpU2luZ2xlQmFzZSB9O1xuICAgIGZvciAobGV0IGRlZklkIGluIGV2ZW50RGVmcykge1xuICAgICAgICBsZXQgZGVmID0gZXZlbnREZWZzW2RlZklkXTtcbiAgICAgICAgaWYgKGRlZi5zb3VyY2VJZCAmJiBldmVudFVpQnlTb3VyY2VbZGVmLnNvdXJjZUlkXSkge1xuICAgICAgICAgICAgZXZlbnRVaUJhc2VzW2RlZklkXSA9IGV2ZW50VWlCeVNvdXJjZVtkZWYuc291cmNlSWRdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBldmVudFVpQmFzZXM7XG59XG5mdW5jdGlvbiBidWlsZFZpZXdVaVByb3BzKGNhbGVuZGFyQ29udGV4dCkge1xuICAgIGxldCB7IG9wdGlvbnMgfSA9IGNhbGVuZGFyQ29udGV4dDtcbiAgICByZXR1cm4ge1xuICAgICAgICBldmVudFVpU2luZ2xlQmFzZTogY3JlYXRlRXZlbnRVaSh7XG4gICAgICAgICAgICBkaXNwbGF5OiBvcHRpb25zLmV2ZW50RGlzcGxheSxcbiAgICAgICAgICAgIGVkaXRhYmxlOiBvcHRpb25zLmVkaXRhYmxlLFxuICAgICAgICAgICAgc3RhcnRFZGl0YWJsZTogb3B0aW9ucy5ldmVudFN0YXJ0RWRpdGFibGUsXG4gICAgICAgICAgICBkdXJhdGlvbkVkaXRhYmxlOiBvcHRpb25zLmV2ZW50RHVyYXRpb25FZGl0YWJsZSxcbiAgICAgICAgICAgIGNvbnN0cmFpbnQ6IG9wdGlvbnMuZXZlbnRDb25zdHJhaW50LFxuICAgICAgICAgICAgb3ZlcmxhcDogdHlwZW9mIG9wdGlvbnMuZXZlbnRPdmVybGFwID09PSAnYm9vbGVhbicgPyBvcHRpb25zLmV2ZW50T3ZlcmxhcCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGFsbG93OiBvcHRpb25zLmV2ZW50QWxsb3csXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuZXZlbnRCYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogb3B0aW9ucy5ldmVudEJvcmRlckNvbG9yLFxuICAgICAgICAgICAgdGV4dENvbG9yOiBvcHRpb25zLmV2ZW50VGV4dENvbG9yLFxuICAgICAgICAgICAgY29sb3I6IG9wdGlvbnMuZXZlbnRDb2xvcixcbiAgICAgICAgICAgIC8vIGNsYXNzTmFtZXM6IG9wdGlvbnMuZXZlbnRDbGFzc05hbWVzIC8vIHJlbmRlciBob29rIHdpbGwgaGFuZGxlIHRoaXNcbiAgICAgICAgfSwgY2FsZW5kYXJDb250ZXh0KSxcbiAgICAgICAgc2VsZWN0aW9uQ29uZmlnOiBjcmVhdGVFdmVudFVpKHtcbiAgICAgICAgICAgIGNvbnN0cmFpbnQ6IG9wdGlvbnMuc2VsZWN0Q29uc3RyYWludCxcbiAgICAgICAgICAgIG92ZXJsYXA6IHR5cGVvZiBvcHRpb25zLnNlbGVjdE92ZXJsYXAgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuc2VsZWN0T3ZlcmxhcCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGFsbG93OiBvcHRpb25zLnNlbGVjdEFsbG93LFxuICAgICAgICB9LCBjYWxlbmRhckNvbnRleHQpLFxuICAgIH07XG59XG5mdW5jdGlvbiBjb21wdXRlSXNMb2FkaW5nKHN0YXRlLCBjb250ZXh0KSB7XG4gICAgZm9yIChsZXQgaXNMb2FkaW5nRnVuYyBvZiBjb250ZXh0LnBsdWdpbkhvb2tzLmlzTG9hZGluZ0Z1bmNzKSB7XG4gICAgICAgIGlmIChpc0xvYWRpbmdGdW5jKHN0YXRlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gcGFyc2VDb250ZXh0QnVzaW5lc3NIb3VycyhjYWxlbmRhckNvbnRleHQpIHtcbiAgICByZXR1cm4gcGFyc2VCdXNpbmVzc0hvdXJzKGNhbGVuZGFyQ29udGV4dC5vcHRpb25zLmJ1c2luZXNzSG91cnMsIGNhbGVuZGFyQ29udGV4dCk7XG59XG5mdW5jdGlvbiB3YXJuVW5rbm93bk9wdGlvbnMob3B0aW9ucywgdmlld05hbWUpIHtcbiAgICBmb3IgKGxldCBvcHRpb25OYW1lIGluIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBVbmtub3duIG9wdGlvbiAnJHtvcHRpb25OYW1lfSdgICtcbiAgICAgICAgICAgICh2aWV3TmFtZSA/IGAgZm9yIHZpZXcgJyR7dmlld05hbWV9J2AgOiAnJykpO1xuICAgIH1cbn1cblxuY2xhc3MgVG9vbGJhclNlY3Rpb24gZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IHRoaXMucHJvcHMud2lkZ2V0R3JvdXBzLm1hcCgod2lkZ2V0R3JvdXApID0+IHRoaXMucmVuZGVyV2lkZ2V0R3JvdXAod2lkZ2V0R3JvdXApKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHsgY2xhc3NOYW1lOiAnZmMtdG9vbGJhci1jaHVuaycgfSwgLi4uY2hpbGRyZW4pO1xuICAgIH1cbiAgICByZW5kZXJXaWRnZXRHcm91cCh3aWRnZXRHcm91cCkge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgdGhlbWUgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gW107XG4gICAgICAgIGxldCBpc09ubHlCdXR0b25zID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgd2lkZ2V0IG9mIHdpZGdldEdyb3VwKSB7XG4gICAgICAgICAgICBsZXQgeyBidXR0b25OYW1lLCBidXR0b25DbGljaywgYnV0dG9uVGV4dCwgYnV0dG9uSWNvbiwgYnV0dG9uSGludCB9ID0gd2lkZ2V0O1xuICAgICAgICAgICAgaWYgKGJ1dHRvbk5hbWUgPT09ICd0aXRsZScpIHtcbiAgICAgICAgICAgICAgICBpc09ubHlCdXR0b25zID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChjcmVhdGVFbGVtZW50KFwiaDJcIiwgeyBjbGFzc05hbWU6IFwiZmMtdG9vbGJhci10aXRsZVwiLCBpZDogcHJvcHMudGl0bGVJZCB9LCBwcm9wcy50aXRsZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGlzUHJlc3NlZCA9IGJ1dHRvbk5hbWUgPT09IHByb3BzLmFjdGl2ZUJ1dHRvbjtcbiAgICAgICAgICAgICAgICBsZXQgaXNEaXNhYmxlZCA9ICghcHJvcHMuaXNUb2RheUVuYWJsZWQgJiYgYnV0dG9uTmFtZSA9PT0gJ3RvZGF5JykgfHxcbiAgICAgICAgICAgICAgICAgICAgKCFwcm9wcy5pc1ByZXZFbmFibGVkICYmIGJ1dHRvbk5hbWUgPT09ICdwcmV2JykgfHxcbiAgICAgICAgICAgICAgICAgICAgKCFwcm9wcy5pc05leHRFbmFibGVkICYmIGJ1dHRvbk5hbWUgPT09ICduZXh0Jyk7XG4gICAgICAgICAgICAgICAgbGV0IGJ1dHRvbkNsYXNzZXMgPSBbYGZjLSR7YnV0dG9uTmFtZX0tYnV0dG9uYCwgdGhlbWUuZ2V0Q2xhc3MoJ2J1dHRvbicpXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNQcmVzc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbkNsYXNzZXMucHVzaCh0aGVtZS5nZXRDbGFzcygnYnV0dG9uQWN0aXZlJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgeyB0eXBlOiBcImJ1dHRvblwiLCB0aXRsZTogdHlwZW9mIGJ1dHRvbkhpbnQgPT09ICdmdW5jdGlvbicgPyBidXR0b25IaW50KHByb3BzLm5hdlVuaXQpIDogYnV0dG9uSGludCwgZGlzYWJsZWQ6IGlzRGlzYWJsZWQsIFwiYXJpYS1wcmVzc2VkXCI6IGlzUHJlc3NlZCwgY2xhc3NOYW1lOiBidXR0b25DbGFzc2VzLmpvaW4oJyAnKSwgb25DbGljazogYnV0dG9uQ2xpY2sgfSwgYnV0dG9uVGV4dCB8fCAoYnV0dG9uSWNvbiA/IGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBidXR0b25JY29uLCByb2xlOiBcImltZ1wiIH0pIDogJycpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGxldCBncm91cENsYXNzTmFtZSA9IChpc09ubHlCdXR0b25zICYmIHRoZW1lLmdldENsYXNzKCdidXR0b25Hcm91cCcpKSB8fCAnJztcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCdkaXYnLCB7IGNsYXNzTmFtZTogZ3JvdXBDbGFzc05hbWUgfSwgLi4uY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZHJlblswXTtcbiAgICB9XG59XG5cbmNsYXNzIFRvb2xiYXIgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IG1vZGVsLCBleHRyYUNsYXNzTmFtZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IGZvcmNlTHRyID0gZmFsc2U7XG4gICAgICAgIGxldCBzdGFydENvbnRlbnQ7XG4gICAgICAgIGxldCBlbmRDb250ZW50O1xuICAgICAgICBsZXQgc2VjdGlvbldpZGdldHMgPSBtb2RlbC5zZWN0aW9uV2lkZ2V0cztcbiAgICAgICAgbGV0IGNlbnRlckNvbnRlbnQgPSBzZWN0aW9uV2lkZ2V0cy5jZW50ZXI7XG4gICAgICAgIGlmIChzZWN0aW9uV2lkZ2V0cy5sZWZ0KSB7XG4gICAgICAgICAgICBmb3JjZUx0ciA9IHRydWU7XG4gICAgICAgICAgICBzdGFydENvbnRlbnQgPSBzZWN0aW9uV2lkZ2V0cy5sZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnRDb250ZW50ID0gc2VjdGlvbldpZGdldHMuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlY3Rpb25XaWRnZXRzLnJpZ2h0KSB7XG4gICAgICAgICAgICBmb3JjZUx0ciA9IHRydWU7XG4gICAgICAgICAgICBlbmRDb250ZW50ID0gc2VjdGlvbldpZGdldHMucmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbmRDb250ZW50ID0gc2VjdGlvbldpZGdldHMuZW5kO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjbGFzc05hbWVzID0gW1xuICAgICAgICAgICAgZXh0cmFDbGFzc05hbWUgfHwgJycsXG4gICAgICAgICAgICAnZmMtdG9vbGJhcicsXG4gICAgICAgICAgICBmb3JjZUx0ciA/ICdmYy10b29sYmFyLWx0cicgOiAnJyxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmpvaW4oJyAnKSB9LFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJTZWN0aW9uKCdzdGFydCcsIHN0YXJ0Q29udGVudCB8fCBbXSksXG4gICAgICAgICAgICB0aGlzLnJlbmRlclNlY3Rpb24oJ2NlbnRlcicsIGNlbnRlckNvbnRlbnQgfHwgW10pLFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJTZWN0aW9uKCdlbmQnLCBlbmRDb250ZW50IHx8IFtdKSkpO1xuICAgIH1cbiAgICByZW5kZXJTZWN0aW9uKGtleSwgd2lkZ2V0R3JvdXBzKSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVG9vbGJhclNlY3Rpb24sIHsga2V5OiBrZXksIHdpZGdldEdyb3Vwczogd2lkZ2V0R3JvdXBzLCB0aXRsZTogcHJvcHMudGl0bGUsIG5hdlVuaXQ6IHByb3BzLm5hdlVuaXQsIGFjdGl2ZUJ1dHRvbjogcHJvcHMuYWN0aXZlQnV0dG9uLCBpc1RvZGF5RW5hYmxlZDogcHJvcHMuaXNUb2RheUVuYWJsZWQsIGlzUHJldkVuYWJsZWQ6IHByb3BzLmlzUHJldkVuYWJsZWQsIGlzTmV4dEVuYWJsZWQ6IHByb3BzLmlzTmV4dEVuYWJsZWQsIHRpdGxlSWQ6IHByb3BzLnRpdGxlSWQgfSkpO1xuICAgIH1cbn1cblxuY2xhc3MgVmlld0hhcm5lc3MgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGF2YWlsYWJsZVdpZHRoOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUVsID0gKGVsKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgICAgICBzZXRSZWYodGhpcy5wcm9wcy5lbFJlZiwgZWwpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVBdmFpbGFibGVXaWR0aCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVJlc2l6ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQXZhaWxhYmxlV2lkdGgoKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgc3RhdGUgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IGFzcGVjdFJhdGlvIH0gPSBwcm9wcztcbiAgICAgICAgbGV0IGNsYXNzTmFtZXMgPSBbXG4gICAgICAgICAgICAnZmMtdmlldy1oYXJuZXNzJyxcbiAgICAgICAgICAgIChhc3BlY3RSYXRpbyB8fCBwcm9wcy5saXF1aWQgfHwgcHJvcHMuaGVpZ2h0KVxuICAgICAgICAgICAgICAgID8gJ2ZjLXZpZXctaGFybmVzcy1hY3RpdmUnIC8vIGhhcm5lc3MgY29udHJvbHMgdGhlIGhlaWdodFxuICAgICAgICAgICAgICAgIDogJ2ZjLXZpZXctaGFybmVzcy1wYXNzaXZlJywgLy8gbGV0IHRoZSB2aWV3IGRvIHRoZSBoZWlnaHRcbiAgICAgICAgXTtcbiAgICAgICAgbGV0IGhlaWdodCA9ICcnO1xuICAgICAgICBsZXQgcGFkZGluZ0JvdHRvbSA9ICcnO1xuICAgICAgICBpZiAoYXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5hdmFpbGFibGVXaWR0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IHN0YXRlLmF2YWlsYWJsZVdpZHRoIC8gYXNwZWN0UmF0aW87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB3aGlsZSB3YWl0aW5nIHRvIGtub3cgYXZhaWxhYmxlV2lkdGgsIHdlIGNhbid0IHNldCBoZWlnaHQgdG8gKnplcm8qXG4gICAgICAgICAgICAgICAgLy8gYmVjYXVzZSB3aWxsIGNhdXNlIGxvdHMgb2YgdW5uZWNlc3Nhcnkgc2Nyb2xsYmFycyB3aXRoaW4gc2Nyb2xsZ3JpZC5cbiAgICAgICAgICAgICAgICAvLyBCRVRURVI6IGRvbid0IHN0YXJ0IHJlbmRlcmluZyBBTllUSElORyB5ZXQgdW50aWwgd2Uga25vdyBjb250YWluZXIgd2lkdGhcbiAgICAgICAgICAgICAgICAvLyBOT1RFOiB3aHkgbm90IGFsd2F5cyB1c2UgcGFkZGluZ0JvdHRvbT8gQ2F1c2VzIGhlaWdodCBvc2NpbGxhdGlvbiAoaXNzdWUgNTYwNilcbiAgICAgICAgICAgICAgICBwYWRkaW5nQm90dG9tID0gYCR7KDEgLyBhc3BlY3RSYXRpbykgKiAxMDB9JWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoZWlnaHQgPSBwcm9wcy5oZWlnaHQgfHwgJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgXCJhcmlhLWxhYmVsbGVkYnlcIjogcHJvcHMubGFiZWxlZEJ5SWQsIHJlZjogdGhpcy5oYW5kbGVFbCwgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmpvaW4oJyAnKSwgc3R5bGU6IHsgaGVpZ2h0LCBwYWRkaW5nQm90dG9tIH0gfSwgcHJvcHMuY2hpbGRyZW4pKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5hZGRSZXNpemVIYW5kbGVyKHRoaXMuaGFuZGxlUmVzaXplKTtcbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5yZW1vdmVSZXNpemVIYW5kbGVyKHRoaXMuaGFuZGxlUmVzaXplKTtcbiAgICB9XG4gICAgdXBkYXRlQXZhaWxhYmxlV2lkdGgoKSB7XG4gICAgICAgIGlmICh0aGlzLmVsICYmIC8vIG5lZWRlZC4gYnV0IHdoeT9cbiAgICAgICAgICAgIHRoaXMucHJvcHMuYXNwZWN0UmF0aW8gLy8gYXNwZWN0UmF0aW8gaXMgdGhlIG9ubHkgaGVpZ2h0IHNldHRpbmcgdGhhdCBuZWVkcyBhdmFpbGFibGVXaWR0aFxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBhdmFpbGFibGVXaWR0aDogdGhpcy5lbC5vZmZzZXRXaWR0aCB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLypcbkRldGVjdHMgd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gYW4gZXZlbnQgd2l0aGluIGEgRGF0ZUNvbXBvbmVudFxuKi9cbmNsYXNzIEV2ZW50Q2xpY2tpbmcgZXh0ZW5kcyBJbnRlcmFjdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICAgICAgc3VwZXIoc2V0dGluZ3MpO1xuICAgICAgICB0aGlzLmhhbmRsZVNlZ0NsaWNrID0gKGV2LCBzZWdFbCkgPT4ge1xuICAgICAgICAgICAgbGV0IHsgY29tcG9uZW50IH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IHsgY29udGV4dCB9ID0gY29tcG9uZW50O1xuICAgICAgICAgICAgbGV0IHNlZyA9IGdldEVsU2VnKHNlZ0VsKTtcbiAgICAgICAgICAgIGlmIChzZWcgJiYgLy8gbWlnaHQgYmUgdGhlIDxkaXY+IHN1cnJvdW5kaW5nIHRoZSBtb3JlIGxpbmtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuaXNWYWxpZFNlZ0Rvd25FbChldi50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgLy8gb3VyIHdheSB0byBzaW11bGF0ZSBhIGxpbmsgY2xpY2sgZm9yIGVsZW1lbnRzIHRoYXQgY2FuJ3QgYmUgPGE+IHRhZ3NcbiAgICAgICAgICAgICAgICAvLyBncmFiIGJlZm9yZSB0cmlnZ2VyIGZpcmVkIGluIGNhc2UgdHJpZ2dlciB0cmFzaGVzIERPTSB0aHJ1IHJlcmVuZGVyaW5nXG4gICAgICAgICAgICAgICAgbGV0IGhhc1VybENvbnRhaW5lciA9IGVsZW1lbnRDbG9zZXN0KGV2LnRhcmdldCwgJy5mYy1ldmVudC1mb3JjZWQtdXJsJyk7XG4gICAgICAgICAgICAgICAgbGV0IHVybCA9IGhhc1VybENvbnRhaW5lciA/IGhhc1VybENvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCdhW2hyZWZdJykuaHJlZiA6ICcnO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudENsaWNrJywge1xuICAgICAgICAgICAgICAgICAgICBlbDogc2VnRWwsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBuZXcgRXZlbnRJbXBsKGNvbXBvbmVudC5jb250ZXh0LCBzZWcuZXZlbnRSYW5nZS5kZWYsIHNlZy5ldmVudFJhbmdlLmluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICAgICAganNFdmVudDogZXYsXG4gICAgICAgICAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAodXJsICYmICFldi5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZXN0cm95ID0gbGlzdGVuQnlTZWxlY3RvcihzZXR0aW5ncy5lbCwgJ2NsaWNrJywgJy5mYy1ldmVudCcsIC8vIG9uIGJvdGggZmcgYW5kIGJnIGV2ZW50c1xuICAgICAgICB0aGlzLmhhbmRsZVNlZ0NsaWNrKTtcbiAgICB9XG59XG5cbi8qXG5UcmlnZ2VycyBldmVudHMgYW5kIGFkZHMvcmVtb3ZlcyBjb3JlIGNsYXNzTmFtZXMgd2hlbiB0aGUgdXNlcidzIHBvaW50ZXJcbmVudGVycy9sZWF2ZXMgZXZlbnQtZWxlbWVudHMgb2YgYSBjb21wb25lbnQuXG4qL1xuY2xhc3MgRXZlbnRIb3ZlcmluZyBleHRlbmRzIEludGVyYWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgICAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgICAgIC8vIGZvciBzaW11bGF0aW5nIGFuIGV2ZW50TW91c2VMZWF2ZSB3aGVuIHRoZSBldmVudCBlbCBpcyBkZXN0cm95ZWQgd2hpbGUgbW91c2UgaXMgb3ZlciBpdFxuICAgICAgICB0aGlzLmhhbmRsZUV2ZW50RWxSZW1vdmUgPSAoZWwpID0+IHtcbiAgICAgICAgICAgIGlmIChlbCA9PT0gdGhpcy5jdXJyZW50U2VnRWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVNlZ0xlYXZlKG51bGwsIHRoaXMuY3VycmVudFNlZ0VsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVTZWdFbnRlciA9IChldiwgc2VnRWwpID0+IHtcbiAgICAgICAgICAgIGlmIChnZXRFbFNlZyhzZWdFbCkpIHsgLy8gVE9ETzogYmV0dGVyIHdheSB0byBtYWtlIHN1cmUgbm90IGhvdmVyaW5nIG92ZXIgbW9yZSsgbGluayBvciBpdHMgd3JhcHBlclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNlZ0VsID0gc2VnRWw7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQoJ2V2ZW50TW91c2VFbnRlcicsIGV2LCBzZWdFbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlU2VnTGVhdmUgPSAoZXYsIHNlZ0VsKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50U2VnRWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTZWdFbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQoJ2V2ZW50TW91c2VMZWF2ZScsIGV2LCBzZWdFbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVtb3ZlSG92ZXJMaXN0ZW5lcnMgPSBsaXN0ZW5Ub0hvdmVyQnlTZWxlY3RvcihzZXR0aW5ncy5lbCwgJy5mYy1ldmVudCcsIC8vIG9uIGJvdGggZmcgYW5kIGJnIGV2ZW50c1xuICAgICAgICB0aGlzLmhhbmRsZVNlZ0VudGVyLCB0aGlzLmhhbmRsZVNlZ0xlYXZlKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVIb3Zlckxpc3RlbmVycygpO1xuICAgIH1cbiAgICB0cmlnZ2VyRXZlbnQocHVibGljRXZOYW1lLCBldiwgc2VnRWwpIHtcbiAgICAgICAgbGV0IHsgY29tcG9uZW50IH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBjb250ZXh0IH0gPSBjb21wb25lbnQ7XG4gICAgICAgIGxldCBzZWcgPSBnZXRFbFNlZyhzZWdFbCk7XG4gICAgICAgIGlmICghZXYgfHwgY29tcG9uZW50LmlzVmFsaWRTZWdEb3duRWwoZXYudGFyZ2V0KSkge1xuICAgICAgICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIocHVibGljRXZOYW1lLCB7XG4gICAgICAgICAgICAgICAgZWw6IHNlZ0VsLFxuICAgICAgICAgICAgICAgIGV2ZW50OiBuZXcgRXZlbnRJbXBsKGNvbnRleHQsIHNlZy5ldmVudFJhbmdlLmRlZiwgc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgIGpzRXZlbnQ6IGV2LFxuICAgICAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBDYWxlbmRhckNvbnRlbnQgZXh0ZW5kcyBQdXJlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5idWlsZFZpZXdDb250ZXh0ID0gbWVtb2l6ZShidWlsZFZpZXdDb250ZXh0KTtcbiAgICAgICAgdGhpcy5idWlsZFZpZXdQcm9wVHJhbnNmb3JtZXJzID0gbWVtb2l6ZShidWlsZFZpZXdQcm9wVHJhbnNmb3JtZXJzKTtcbiAgICAgICAgdGhpcy5idWlsZFRvb2xiYXJQcm9wcyA9IG1lbW9pemUoYnVpbGRUb29sYmFyUHJvcHMpO1xuICAgICAgICB0aGlzLmhlYWRlclJlZiA9IGNyZWF0ZVJlZigpO1xuICAgICAgICB0aGlzLmZvb3RlclJlZiA9IGNyZWF0ZVJlZigpO1xuICAgICAgICB0aGlzLmludGVyYWN0aW9uc1N0b3JlID0ge307XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgdmlld0xhYmVsSWQ6IGdldFVuaXF1ZURvbUlkKCksXG4gICAgICAgIH07XG4gICAgICAgIC8vIENvbXBvbmVudCBSZWdpc3RyYXRpb25cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgdGhpcy5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50ID0gKGNvbXBvbmVudCwgc2V0dGluZ3NJbnB1dCkgPT4ge1xuICAgICAgICAgICAgbGV0IHNldHRpbmdzID0gcGFyc2VJbnRlcmFjdGlvblNldHRpbmdzKGNvbXBvbmVudCwgc2V0dGluZ3NJbnB1dCk7XG4gICAgICAgICAgICBsZXQgREVGQVVMVF9JTlRFUkFDVElPTlMgPSBbXG4gICAgICAgICAgICAgICAgRXZlbnRDbGlja2luZyxcbiAgICAgICAgICAgICAgICBFdmVudEhvdmVyaW5nLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGxldCBpbnRlcmFjdGlvbkNsYXNzZXMgPSBERUZBVUxUX0lOVEVSQUNUSU9OUy5jb25jYXQodGhpcy5wcm9wcy5wbHVnaW5Ib29rcy5jb21wb25lbnRJbnRlcmFjdGlvbnMpO1xuICAgICAgICAgICAgbGV0IGludGVyYWN0aW9ucyA9IGludGVyYWN0aW9uQ2xhc3Nlcy5tYXAoKFRoZUludGVyYWN0aW9uQ2xhc3MpID0+IG5ldyBUaGVJbnRlcmFjdGlvbkNsYXNzKHNldHRpbmdzKSk7XG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uc1N0b3JlW2NvbXBvbmVudC51aWRdID0gaW50ZXJhY3Rpb25zO1xuICAgICAgICAgICAgaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlW2NvbXBvbmVudC51aWRdID0gc2V0dGluZ3M7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50ID0gKGNvbXBvbmVudCkgPT4ge1xuICAgICAgICAgICAgbGV0IGxpc3RlbmVycyA9IHRoaXMuaW50ZXJhY3Rpb25zU3RvcmVbY29tcG9uZW50LnVpZF07XG4gICAgICAgICAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuaW50ZXJhY3Rpb25zU3RvcmVbY29tcG9uZW50LnVpZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlW2NvbXBvbmVudC51aWRdO1xuICAgICAgICB9O1xuICAgICAgICAvLyBSZXNpemluZ1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICB0aGlzLnJlc2l6ZVJ1bm5lciA9IG5ldyBEZWxheWVkUnVubmVyKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMuZW1pdHRlci50cmlnZ2VyKCdfcmVzaXplJywgdHJ1ZSk7IC8vIHNob3VsZCB3aW5kb3cgcmVzaXplcyBiZSBjb25zaWRlcmVkIFwiZm9yY2VkXCIgP1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5lbWl0dGVyLnRyaWdnZXIoJ3dpbmRvd1Jlc2l6ZScsIHsgdmlldzogdGhpcy5wcm9wcy52aWV3QXBpIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5oYW5kbGVXaW5kb3dSZXNpemUgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5oYW5kbGVXaW5kb3dSZXNpemUgJiZcbiAgICAgICAgICAgICAgICBldi50YXJnZXQgPT09IHdpbmRvdyAvLyBhdm9pZCBqcXVpIGV2ZW50c1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNpemVSdW5uZXIucmVxdWVzdChvcHRpb25zLndpbmRvd1Jlc2l6ZURlbGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLypcbiAgICByZW5kZXJzIElOU0lERSBvZiBhbiBvdXRlciBkaXZcbiAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IHRvb2xiYXJDb25maWcsIG9wdGlvbnMgfSA9IHByb3BzO1xuICAgICAgICBsZXQgdG9vbGJhclByb3BzID0gdGhpcy5idWlsZFRvb2xiYXJQcm9wcyhwcm9wcy52aWV3U3BlYywgcHJvcHMuZGF0ZVByb2ZpbGUsIHByb3BzLmRhdGVQcm9maWxlR2VuZXJhdG9yLCBwcm9wcy5jdXJyZW50RGF0ZSwgZ2V0Tm93KHByb3BzLm9wdGlvbnMubm93LCBwcm9wcy5kYXRlRW52KSwgLy8gVE9ETzogdXNlIE5vd1RpbWVyPz8/P1xuICAgICAgICBwcm9wcy52aWV3VGl0bGUpO1xuICAgICAgICBsZXQgdmlld1ZHcm93ID0gZmFsc2U7XG4gICAgICAgIGxldCB2aWV3SGVpZ2h0ID0gJyc7XG4gICAgICAgIGxldCB2aWV3QXNwZWN0UmF0aW87XG4gICAgICAgIGlmIChwcm9wcy5pc0hlaWdodEF1dG8gfHwgcHJvcHMuZm9yUHJpbnQpIHtcbiAgICAgICAgICAgIHZpZXdIZWlnaHQgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLmhlaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICB2aWV3Vkdyb3cgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuY29udGVudEhlaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICB2aWV3SGVpZ2h0ID0gb3B0aW9ucy5jb250ZW50SGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmlld0FzcGVjdFJhdGlvID0gTWF0aC5tYXgob3B0aW9ucy5hc3BlY3RSYXRpbywgMC41KTsgLy8gcHJldmVudCBmcm9tIGdldHRpbmcgdG9vIHRhbGxcbiAgICAgICAgfVxuICAgICAgICBsZXQgdmlld0NvbnRleHQgPSB0aGlzLmJ1aWxkVmlld0NvbnRleHQocHJvcHMudmlld1NwZWMsIHByb3BzLnZpZXdBcGksIHByb3BzLm9wdGlvbnMsIHByb3BzLmRhdGVQcm9maWxlR2VuZXJhdG9yLCBwcm9wcy5kYXRlRW52LCBwcm9wcy50aGVtZSwgcHJvcHMucGx1Z2luSG9va3MsIHByb3BzLmRpc3BhdGNoLCBwcm9wcy5nZXRDdXJyZW50RGF0YSwgcHJvcHMuZW1pdHRlciwgcHJvcHMuY2FsZW5kYXJBcGksIHRoaXMucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCwgdGhpcy51bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQpO1xuICAgICAgICBsZXQgdmlld0xhYmVsSWQgPSAodG9vbGJhckNvbmZpZy5oZWFkZXIgJiYgdG9vbGJhckNvbmZpZy5oZWFkZXIuaGFzVGl0bGUpXG4gICAgICAgICAgICA/IHRoaXMuc3RhdGUudmlld0xhYmVsSWRcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVmlld0NvbnRleHRUeXBlLlByb3ZpZGVyLCB7IHZhbHVlOiB2aWV3Q29udGV4dCB9LFxuICAgICAgICAgICAgdG9vbGJhckNvbmZpZy5oZWFkZXIgJiYgKGNyZWF0ZUVsZW1lbnQoVG9vbGJhciwgT2JqZWN0LmFzc2lnbih7IHJlZjogdGhpcy5oZWFkZXJSZWYsIGV4dHJhQ2xhc3NOYW1lOiBcImZjLWhlYWRlci10b29sYmFyXCIsIG1vZGVsOiB0b29sYmFyQ29uZmlnLmhlYWRlciwgdGl0bGVJZDogdmlld0xhYmVsSWQgfSwgdG9vbGJhclByb3BzKSkpLFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChWaWV3SGFybmVzcywgeyBsaXF1aWQ6IHZpZXdWR3JvdywgaGVpZ2h0OiB2aWV3SGVpZ2h0LCBhc3BlY3RSYXRpbzogdmlld0FzcGVjdFJhdGlvLCBsYWJlbGVkQnlJZDogdmlld0xhYmVsSWQgfSxcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclZpZXcocHJvcHMpLFxuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRBcHBlbmRDb250ZW50KCkpLFxuICAgICAgICAgICAgdG9vbGJhckNvbmZpZy5mb290ZXIgJiYgKGNyZWF0ZUVsZW1lbnQoVG9vbGJhciwgT2JqZWN0LmFzc2lnbih7IHJlZjogdGhpcy5mb290ZXJSZWYsIGV4dHJhQ2xhc3NOYW1lOiBcImZjLWZvb3Rlci10b29sYmFyXCIsIG1vZGVsOiB0b29sYmFyQ29uZmlnLmZvb3RlciwgdGl0bGVJZDogXCJcIiB9LCB0b29sYmFyUHJvcHMpKSkpKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmNhbGVuZGFySW50ZXJhY3Rpb25zID0gcHJvcHMucGx1Z2luSG9va3MuY2FsZW5kYXJJbnRlcmFjdGlvbnNcbiAgICAgICAgICAgIC5tYXAoKENhbGVuZGFySW50ZXJhY3Rpb25DbGFzcykgPT4gbmV3IENhbGVuZGFySW50ZXJhY3Rpb25DbGFzcyhwcm9wcykpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5oYW5kbGVXaW5kb3dSZXNpemUpO1xuICAgICAgICBsZXQgeyBwcm9wU2V0SGFuZGxlcnMgfSA9IHByb3BzLnBsdWdpbkhvb2tzO1xuICAgICAgICBmb3IgKGxldCBwcm9wTmFtZSBpbiBwcm9wU2V0SGFuZGxlcnMpIHtcbiAgICAgICAgICAgIHByb3BTZXRIYW5kbGVyc1twcm9wTmFtZV0ocHJvcHNbcHJvcE5hbWVdLCBwcm9wcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgcHJvcFNldEhhbmRsZXJzIH0gPSBwcm9wcy5wbHVnaW5Ib29rcztcbiAgICAgICAgZm9yIChsZXQgcHJvcE5hbWUgaW4gcHJvcFNldEhhbmRsZXJzKSB7XG4gICAgICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdICE9PSBwcmV2UHJvcHNbcHJvcE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgcHJvcFNldEhhbmRsZXJzW3Byb3BOYW1lXShwcm9wc1twcm9wTmFtZV0sIHByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuaGFuZGxlV2luZG93UmVzaXplKTtcbiAgICAgICAgdGhpcy5yZXNpemVSdW5uZXIuY2xlYXIoKTtcbiAgICAgICAgZm9yIChsZXQgaW50ZXJhY3Rpb24gb2YgdGhpcy5jYWxlbmRhckludGVyYWN0aW9ucykge1xuICAgICAgICAgICAgaW50ZXJhY3Rpb24uZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvcHMuZW1pdHRlci50cmlnZ2VyKCdfdW5tb3VudCcpO1xuICAgIH1cbiAgICBidWlsZEFwcGVuZENvbnRlbnQoKSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBwcm9wcy5wbHVnaW5Ib29rcy52aWV3Q29udGFpbmVyQXBwZW5kcy5tYXAoKGJ1aWxkQXBwZW5kQ29udGVudCkgPT4gYnVpbGRBcHBlbmRDb250ZW50KHByb3BzKSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCB7fSwgLi4uY2hpbGRyZW4pO1xuICAgIH1cbiAgICByZW5kZXJWaWV3KHByb3BzKSB7XG4gICAgICAgIGxldCB7IHBsdWdpbkhvb2tzIH0gPSBwcm9wcztcbiAgICAgICAgbGV0IHsgdmlld1NwZWMgfSA9IHByb3BzO1xuICAgICAgICBsZXQgdmlld1Byb3BzID0ge1xuICAgICAgICAgICAgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLFxuICAgICAgICAgICAgYnVzaW5lc3NIb3VyczogcHJvcHMuYnVzaW5lc3NIb3VycyxcbiAgICAgICAgICAgIGV2ZW50U3RvcmU6IHByb3BzLnJlbmRlcmFibGVFdmVudFN0b3JlLFxuICAgICAgICAgICAgZXZlbnRVaUJhc2VzOiBwcm9wcy5ldmVudFVpQmFzZXMsXG4gICAgICAgICAgICBkYXRlU2VsZWN0aW9uOiBwcm9wcy5kYXRlU2VsZWN0aW9uLFxuICAgICAgICAgICAgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLFxuICAgICAgICAgICAgZXZlbnREcmFnOiBwcm9wcy5ldmVudERyYWcsXG4gICAgICAgICAgICBldmVudFJlc2l6ZTogcHJvcHMuZXZlbnRSZXNpemUsXG4gICAgICAgICAgICBpc0hlaWdodEF1dG86IHByb3BzLmlzSGVpZ2h0QXV0byxcbiAgICAgICAgICAgIGZvclByaW50OiBwcm9wcy5mb3JQcmludCxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVycyA9IHRoaXMuYnVpbGRWaWV3UHJvcFRyYW5zZm9ybWVycyhwbHVnaW5Ib29rcy52aWV3UHJvcHNUcmFuc2Zvcm1lcnMpO1xuICAgICAgICBmb3IgKGxldCB0cmFuc2Zvcm1lciBvZiB0cmFuc2Zvcm1lcnMpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odmlld1Byb3BzLCB0cmFuc2Zvcm1lci50cmFuc2Zvcm0odmlld1Byb3BzLCBwcm9wcykpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBWaWV3Q29tcG9uZW50ID0gdmlld1NwZWMuY29tcG9uZW50O1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVmlld0NvbXBvbmVudCwgT2JqZWN0LmFzc2lnbih7fSwgdmlld1Byb3BzKSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkVG9vbGJhclByb3BzKHZpZXdTcGVjLCBkYXRlUHJvZmlsZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IsIGN1cnJlbnREYXRlLCBub3csIHRpdGxlKSB7XG4gICAgLy8gZG9uJ3QgZm9yY2UgYW55IGRhdGUtcHJvZmlsZXMgdG8gdmFsaWQgZGF0ZSBwcm9maWxlcyAodGhlIGBmYWxzZWApIHNvIHRoYXQgd2UgY2FuIHRlbGwgaWYgaXQncyBpbnZhbGlkXG4gICAgbGV0IHRvZGF5SW5mbyA9IGRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkKG5vdywgdW5kZWZpbmVkLCBmYWxzZSk7IC8vIFRPRE86IG5lZWQgYHVuZGVmaW5lZGAgb3IgZWxzZSBJTkZJTklURSBMT09QIGZvciBzb21lIHJlYXNvblxuICAgIGxldCBwcmV2SW5mbyA9IGRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkUHJldihkYXRlUHJvZmlsZSwgY3VycmVudERhdGUsIGZhbHNlKTtcbiAgICBsZXQgbmV4dEluZm8gPSBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZE5leHQoZGF0ZVByb2ZpbGUsIGN1cnJlbnREYXRlLCBmYWxzZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGl0bGUsXG4gICAgICAgIGFjdGl2ZUJ1dHRvbjogdmlld1NwZWMudHlwZSxcbiAgICAgICAgbmF2VW5pdDogdmlld1NwZWMuc2luZ2xlVW5pdCxcbiAgICAgICAgaXNUb2RheUVuYWJsZWQ6IHRvZGF5SW5mby5pc1ZhbGlkICYmICFyYW5nZUNvbnRhaW5zTWFya2VyKGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZSwgbm93KSxcbiAgICAgICAgaXNQcmV2RW5hYmxlZDogcHJldkluZm8uaXNWYWxpZCxcbiAgICAgICAgaXNOZXh0RW5hYmxlZDogbmV4dEluZm8uaXNWYWxpZCxcbiAgICB9O1xufVxuLy8gUGx1Z2luXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gYnVpbGRWaWV3UHJvcFRyYW5zZm9ybWVycyh0aGVDbGFzc2VzKSB7XG4gICAgcmV0dXJuIHRoZUNsYXNzZXMubWFwKChUaGVDbGFzcykgPT4gbmV3IFRoZUNsYXNzKCkpO1xufVxuXG5jbGFzcyBDYWxlbmRhciBleHRlbmRzIENhbGVuZGFySW1wbCB7XG4gICAgY29uc3RydWN0b3IoZWwsIG9wdGlvbk92ZXJyaWRlcyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaXNSZW5kZXJpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1JlbmRlcmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY3VycmVudENsYXNzTmFtZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jdXN0b21Db250ZW50UmVuZGVySWQgPSAwO1xuICAgICAgICB0aGlzLmhhbmRsZUFjdGlvbiA9IChhY3Rpb24pID0+IHtcbiAgICAgICAgICAgIC8vIGFjdGlvbnMgd2Uga25vdyB3ZSB3YW50IHRvIHJlbmRlciBpbW1lZGlhdGVseVxuICAgICAgICAgICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ1NFVF9FVkVOVF9EUkFHJzpcbiAgICAgICAgICAgICAgICBjYXNlICdTRVRfRVZFTlRfUkVTSVpFJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJSdW5uZXIudHJ5RHJhaW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVEYXRhID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudERhdGEgPSBkYXRhO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJSdW5uZXIucmVxdWVzdChkYXRhLmNhbGVuZGFyT3B0aW9ucy5yZXJlbmRlckRlbGF5KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVSZW5kZXJSZXF1ZXN0ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNSZW5kZXJpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzUmVuZGVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGxldCB7IGN1cnJlbnREYXRhIH0gPSB0aGlzO1xuICAgICAgICAgICAgICAgIGZsdXNoU3luYygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcihjcmVhdGVFbGVtZW50KENhbGVuZGFyUm9vdCwgeyBvcHRpb25zOiBjdXJyZW50RGF0YS5jYWxlbmRhck9wdGlvbnMsIHRoZW1lOiBjdXJyZW50RGF0YS50aGVtZSwgZW1pdHRlcjogY3VycmVudERhdGEuZW1pdHRlciB9LCAoY2xhc3NOYW1lcywgaGVpZ2h0LCBpc0hlaWdodEF1dG8sIGZvclByaW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldENsYXNzTmFtZXMoY2xhc3NOYW1lcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEhlaWdodChoZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFJlbmRlcklkLlByb3ZpZGVyLCB7IHZhbHVlOiB0aGlzLmN1c3RvbUNvbnRlbnRSZW5kZXJJZCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoQ2FsZW5kYXJDb250ZW50LCBPYmplY3QuYXNzaWduKHsgaXNIZWlnaHRBdXRvOiBpc0hlaWdodEF1dG8sIGZvclByaW50OiBmb3JQcmludCB9LCBjdXJyZW50RGF0YSkpKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pLCB0aGlzLmVsKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaXNSZW5kZXJlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNSZW5kZXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJlbmRlcihudWxsLCB0aGlzLmVsKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldENsYXNzTmFtZXMoW10pO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0SGVpZ2h0KCcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZW5zdXJlRWxIYXNTdHlsZXMoZWwpO1xuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMucmVuZGVyUnVubmVyID0gbmV3IERlbGF5ZWRSdW5uZXIodGhpcy5oYW5kbGVSZW5kZXJSZXF1ZXN0KTtcbiAgICAgICAgbmV3IENhbGVuZGFyRGF0YU1hbmFnZXIoe1xuICAgICAgICAgICAgb3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICAgICAgY2FsZW5kYXJBcGk6IHRoaXMsXG4gICAgICAgICAgICBvbkFjdGlvbjogdGhpcy5oYW5kbGVBY3Rpb24sXG4gICAgICAgICAgICBvbkRhdGE6IHRoaXMuaGFuZGxlRGF0YSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHdhc1JlbmRlcmluZyA9IHRoaXMuaXNSZW5kZXJpbmc7XG4gICAgICAgIGlmICghd2FzUmVuZGVyaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmlzUmVuZGVyaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tQ29udGVudFJlbmRlcklkICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW5kZXJSdW5uZXIucmVxdWVzdCgpO1xuICAgICAgICBpZiAod2FzUmVuZGVyaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNpemUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5pc1JlbmRlcmluZykge1xuICAgICAgICAgICAgdGhpcy5pc1JlbmRlcmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJSdW5uZXIucmVxdWVzdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZVNpemUoKSB7XG4gICAgICAgIGZsdXNoU3luYygoKSA9PiB7XG4gICAgICAgICAgICBzdXBlci51cGRhdGVTaXplKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBiYXRjaFJlbmRlcmluZyhmdW5jKSB7XG4gICAgICAgIHRoaXMucmVuZGVyUnVubmVyLnBhdXNlKCdiYXRjaFJlbmRlcmluZycpO1xuICAgICAgICBmdW5jKCk7XG4gICAgICAgIHRoaXMucmVuZGVyUnVubmVyLnJlc3VtZSgnYmF0Y2hSZW5kZXJpbmcnKTtcbiAgICB9XG4gICAgcGF1c2VSZW5kZXJpbmcoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyUnVubmVyLnBhdXNlKCdwYXVzZVJlbmRlcmluZycpO1xuICAgIH1cbiAgICByZXN1bWVSZW5kZXJpbmcoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyUnVubmVyLnJlc3VtZSgncGF1c2VSZW5kZXJpbmcnLCB0cnVlKTtcbiAgICB9XG4gICAgcmVzZXRPcHRpb25zKG9wdGlvbk92ZXJyaWRlcywgY2hhbmdlZE9wdGlvbk5hbWVzKSB7XG4gICAgICAgIHRoaXMuY3VycmVudERhdGFNYW5hZ2VyLnJlc2V0T3B0aW9ucyhvcHRpb25PdmVycmlkZXMsIGNoYW5nZWRPcHRpb25OYW1lcyk7XG4gICAgfVxuICAgIHNldENsYXNzTmFtZXMoY2xhc3NOYW1lcykge1xuICAgICAgICBpZiAoIWlzQXJyYXlzRXF1YWwoY2xhc3NOYW1lcywgdGhpcy5jdXJyZW50Q2xhc3NOYW1lcykpIHtcbiAgICAgICAgICAgIGxldCB7IGNsYXNzTGlzdCB9ID0gdGhpcy5lbDtcbiAgICAgICAgICAgIGZvciAobGV0IGNsYXNzTmFtZSBvZiB0aGlzLmN1cnJlbnRDbGFzc05hbWVzKSB7XG4gICAgICAgICAgICAgICAgY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgY2xhc3NOYW1lIG9mIGNsYXNzTmFtZXMpIHtcbiAgICAgICAgICAgICAgICBjbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDbGFzc05hbWVzID0gY2xhc3NOYW1lcztcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRIZWlnaHQoaGVpZ2h0KSB7XG4gICAgICAgIGFwcGx5U3R5bGVQcm9wKHRoaXMuZWwsICdoZWlnaHQnLCBoZWlnaHQpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlSW5wdXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBkYXRlRW52ID0gYnVpbGREYXRlRW52KG9wdGlvbnMpO1xuICAgIGxldCBmb3JtYXR0ZXIgPSBjcmVhdGVGb3JtYXR0ZXIob3B0aW9ucyk7XG4gICAgbGV0IGRhdGVNZXRhID0gZGF0ZUVudi5jcmVhdGVNYXJrZXJNZXRhKGRhdGVJbnB1dCk7XG4gICAgaWYgKCFkYXRlTWV0YSkgeyAvLyBUT0RPOiB3YXJuaW5nP1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBkYXRlRW52LmZvcm1hdChkYXRlTWV0YS5tYXJrZXIsIGZvcm1hdHRlciwge1xuICAgICAgICBmb3JjZWRUem86IGRhdGVNZXRhLmZvcmNlZFR6byxcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFJhbmdlKHN0YXJ0SW5wdXQsIGVuZElucHV0LCBvcHRpb25zKSB7XG4gICAgbGV0IGRhdGVFbnYgPSBidWlsZERhdGVFbnYodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMgPyBvcHRpb25zIDoge30pOyAvLyBwYXNzIGluIGlmIG5vbi1udWxsIG9iamVjdFxuICAgIGxldCBmb3JtYXR0ZXIgPSBjcmVhdGVGb3JtYXR0ZXIob3B0aW9ucyk7XG4gICAgbGV0IHN0YXJ0TWV0YSA9IGRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShzdGFydElucHV0KTtcbiAgICBsZXQgZW5kTWV0YSA9IGRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShlbmRJbnB1dCk7XG4gICAgaWYgKCFzdGFydE1ldGEgfHwgIWVuZE1ldGEpIHsgLy8gVE9ETzogd2FybmluZz9cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXRSYW5nZShzdGFydE1ldGEubWFya2VyLCBlbmRNZXRhLm1hcmtlciwgZm9ybWF0dGVyLCB7XG4gICAgICAgIGZvcmNlZFN0YXJ0VHpvOiBzdGFydE1ldGEuZm9yY2VkVHpvLFxuICAgICAgICBmb3JjZWRFbmRUem86IGVuZE1ldGEuZm9yY2VkVHpvLFxuICAgICAgICBpc0VuZEV4Y2x1c2l2ZTogb3B0aW9ucy5pc0VuZEV4Y2x1c2l2ZSxcbiAgICAgICAgZGVmYXVsdFNlcGFyYXRvcjogQkFTRV9PUFRJT05fREVGQVVMVFMuZGVmYXVsdFJhbmdlU2VwYXJhdG9yLFxuICAgIH0pO1xufVxuLy8gVE9ETzogbW9yZSBEUlkgYW5kIG9wdGltaXplZFxuZnVuY3Rpb24gYnVpbGREYXRlRW52KHNldHRpbmdzKSB7XG4gICAgbGV0IGxvY2FsZSA9IGJ1aWxkTG9jYWxlKHNldHRpbmdzLmxvY2FsZSB8fCAnZW4nLCBvcmdhbml6ZVJhd0xvY2FsZXMoW10pLm1hcCk7IC8vIFRPRE86IGRvbid0IGhhcmRjb2RlICdlbicgZXZlcnl3aGVyZVxuICAgIHJldHVybiBuZXcgRGF0ZUVudihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyB0aW1lWm9uZTogQkFTRV9PUFRJT05fREVGQVVMVFMudGltZVpvbmUsIGNhbGVuZGFyU3lzdGVtOiAnZ3JlZ29yeScgfSwgc2V0dGluZ3MpLCB7IGxvY2FsZSB9KSk7XG59XG5cbi8vIEhFTFBFUlNcbi8qXG5pZiBuZXh0RGF5VGhyZXNob2xkIGlzIHNwZWNpZmllZCwgc2xpY2luZyBpcyBkb25lIGluIGFuIGFsbC1kYXkgZmFzaGlvbi5cbnlvdSBjYW4gZ2V0IG5leHREYXlUaHJlc2hvbGQgZnJvbSBjb250ZXh0Lm5leHREYXlUaHJlc2hvbGRcbiovXG5mdW5jdGlvbiBzbGljZUV2ZW50cyhwcm9wcywgYWxsRGF5KSB7XG4gICAgcmV0dXJuIHNsaWNlRXZlbnRTdG9yZShwcm9wcy5ldmVudFN0b3JlLCBwcm9wcy5ldmVudFVpQmFzZXMsIHByb3BzLmRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLCBhbGxEYXkgPyBwcm9wcy5uZXh0RGF5VGhyZXNob2xkIDogbnVsbCkuZmc7XG59XG5cbmNvbnN0IHZlcnNpb24gPSAnNi4xLjE1JztcblxuZXhwb3J0IHsgQ2FsZW5kYXIsIGNyZWF0ZVBsdWdpbiwgZm9ybWF0RGF0ZSwgZm9ybWF0UmFuZ2UsIGdsb2JhbExvY2FsZXMsIGdsb2JhbFBsdWdpbnMsIHNsaWNlRXZlbnRzLCB2ZXJzaW9uIH07XG4iLCAiaW1wb3J0IHsgRGF0ZUNvbXBvbmVudCwgZ2V0U3RpY2t5SGVhZGVyRGF0ZXMsIFZpZXdDb250YWluZXIsIFNpbXBsZVNjcm9sbEdyaWQsIGdldFN0aWNreUZvb3RlclNjcm9sbGJhciwgcmVuZGVyU2Nyb2xsU2hpbSwgY3JlYXRlRm9ybWF0dGVyLCBCYXNlQ29tcG9uZW50LCBTdGFuZGFyZEV2ZW50LCBidWlsZFNlZ1RpbWVUZXh0LCBFdmVudENvbnRhaW5lciwgZ2V0U2VnQW5jaG9yQXR0cnMsIG1lbW9pemUsIE1vcmVMaW5rQ29udGFpbmVyLCBnZXRTZWdNZXRhLCBnZXRVbmlxdWVEb21JZCwgc2V0UmVmLCBEYXlDZWxsQ29udGFpbmVyLCBXZWVrTnVtYmVyQ29udGFpbmVyLCBidWlsZE5hdkxpbmtBdHRycywgaGFzQ3VzdG9tRGF5Q2VsbENvbnRlbnQsIGFkZE1zLCBpbnRlcnNlY3RSYW5nZXMsIGFkZERheXMsIFNlZ0hpZXJhcmNoeSwgYnVpbGRFbnRyeUtleSwgaW50ZXJzZWN0U3BhbnMsIFJlZk1hcCwgc29ydEV2ZW50U2VncywgaXNQcm9wc0VxdWFsLCBidWlsZEV2ZW50UmFuZ2VLZXksIEJnRXZlbnQsIHJlbmRlckZpbGwsIFBvc2l0aW9uQ2FjaGUsIE5vd1RpbWVyLCBmb3JtYXRJc29Nb250aFN0ciwgZm9ybWF0RGF5U3RyaW5nLCBTbGljZXIsIERheUhlYWRlciwgRGF5U2VyaWVzTW9kZWwsIERheVRhYmxlTW9kZWwsIERhdGVQcm9maWxlR2VuZXJhdG9yLCBhZGRXZWVrcywgZGlmZldlZWtzLCBpbmplY3RTdHlsZXMgfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvcmUvaW50ZXJuYWwuanMnO1xuaW1wb3J0IHsgY3JlYXRlUmVmLCBjcmVhdGVFbGVtZW50LCBGcmFnbWVudCB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29yZS9wcmVhY3QuanMnO1xuXG4vKiBBbiBhYnN0cmFjdCBjbGFzcyBmb3IgdGhlIGRheWdyaWQgdmlld3MsIGFzIHdlbGwgYXMgbW9udGggdmlldy4gUmVuZGVycyBvbmUgb3IgbW9yZSByb3dzIG9mIGRheSBjZWxscy5cbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLy8gSXQgaXMgYSBtYW5hZ2VyIGZvciBhIFRhYmxlIHN1YmNvbXBvbmVudCwgd2hpY2ggZG9lcyBtb3N0IG9mIHRoZSBoZWF2eSBsaWZ0aW5nLlxuLy8gSXQgaXMgcmVzcG9uc2libGUgZm9yIG1hbmFnaW5nIHdpZHRoL2hlaWdodC5cbmNsYXNzIFRhYmxlVmlldyBleHRlbmRzIERhdGVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmhlYWRlckVsUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgfVxuICAgIHJlbmRlclNpbXBsZUxheW91dChoZWFkZXJSb3dDb250ZW50LCBib2R5Q29udGVudCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHNlY3Rpb25zID0gW107XG4gICAgICAgIGxldCBzdGlja3lIZWFkZXJEYXRlcyA9IGdldFN0aWNreUhlYWRlckRhdGVzKGNvbnRleHQub3B0aW9ucyk7XG4gICAgICAgIGlmIChoZWFkZXJSb3dDb250ZW50KSB7XG4gICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaGVhZGVyJyxcbiAgICAgICAgICAgICAgICBrZXk6ICdoZWFkZXInLFxuICAgICAgICAgICAgICAgIGlzU3RpY2t5OiBzdGlja3lIZWFkZXJEYXRlcyxcbiAgICAgICAgICAgICAgICBjaHVuazoge1xuICAgICAgICAgICAgICAgICAgICBlbFJlZjogdGhpcy5oZWFkZXJFbFJlZixcbiAgICAgICAgICAgICAgICAgICAgdGFibGVDbGFzc05hbWU6ICdmYy1jb2wtaGVhZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgcm93Q29udGVudDogaGVhZGVyUm93Q29udGVudCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnYm9keScsXG4gICAgICAgICAgICBrZXk6ICdib2R5JyxcbiAgICAgICAgICAgIGxpcXVpZDogdHJ1ZSxcbiAgICAgICAgICAgIGNodW5rOiB7IGNvbnRlbnQ6IGJvZHlDb250ZW50IH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVmlld0NvbnRhaW5lciwgeyBlbENsYXNzZXM6IFsnZmMtZGF5Z3JpZCddLCB2aWV3U3BlYzogY29udGV4dC52aWV3U3BlYyB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChTaW1wbGVTY3JvbGxHcmlkLCB7IGxpcXVpZDogIXByb3BzLmlzSGVpZ2h0QXV0byAmJiAhcHJvcHMuZm9yUHJpbnQsIGNvbGxhcHNpYmxlV2lkdGg6IHByb3BzLmZvclByaW50LCBjb2xzOiBbXSAvKiBUT0RPOiBtYWtlIG9wdGlvbmFsPyAqLywgc2VjdGlvbnM6IHNlY3Rpb25zIH0pKSk7XG4gICAgfVxuICAgIHJlbmRlckhTY3JvbGxMYXlvdXQoaGVhZGVyUm93Q29udGVudCwgYm9keUNvbnRlbnQsIGNvbENudCwgZGF5TWluV2lkdGgpIHtcbiAgICAgICAgbGV0IFNjcm9sbEdyaWQgPSB0aGlzLmNvbnRleHQucGx1Z2luSG9va3Muc2Nyb2xsR3JpZEltcGw7XG4gICAgICAgIGlmICghU2Nyb2xsR3JpZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBTY3JvbGxHcmlkIGltcGxlbWVudGF0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCBzdGlja3lIZWFkZXJEYXRlcyA9ICFwcm9wcy5mb3JQcmludCAmJiBnZXRTdGlja3lIZWFkZXJEYXRlcyhjb250ZXh0Lm9wdGlvbnMpO1xuICAgICAgICBsZXQgc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyID0gIXByb3BzLmZvclByaW50ICYmIGdldFN0aWNreUZvb3RlclNjcm9sbGJhcihjb250ZXh0Lm9wdGlvbnMpO1xuICAgICAgICBsZXQgc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgaWYgKGhlYWRlclJvd0NvbnRlbnQpIHtcbiAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdoZWFkZXInLFxuICAgICAgICAgICAgICAgIGtleTogJ2hlYWRlcicsXG4gICAgICAgICAgICAgICAgaXNTdGlja3k6IHN0aWNreUhlYWRlckRhdGVzLFxuICAgICAgICAgICAgICAgIGNodW5rczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ21haW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxSZWY6IHRoaXMuaGVhZGVyRWxSZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWJsZUNsYXNzTmFtZTogJ2ZjLWNvbC1oZWFkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm93Q29udGVudDogaGVhZGVyUm93Q29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdib2R5JyxcbiAgICAgICAgICAgIGtleTogJ2JvZHknLFxuICAgICAgICAgICAgbGlxdWlkOiB0cnVlLFxuICAgICAgICAgICAgY2h1bmtzOiBbe1xuICAgICAgICAgICAgICAgICAgICBrZXk6ICdtYWluJyxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogYm9keUNvbnRlbnQsXG4gICAgICAgICAgICAgICAgfV0sXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyKSB7XG4gICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZm9vdGVyJyxcbiAgICAgICAgICAgICAgICBrZXk6ICdmb290ZXInLFxuICAgICAgICAgICAgICAgIGlzU3RpY2t5OiB0cnVlLFxuICAgICAgICAgICAgICAgIGNodW5rczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ21haW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogcmVuZGVyU2Nyb2xsU2hpbSxcbiAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVmlld0NvbnRhaW5lciwgeyBlbENsYXNzZXM6IFsnZmMtZGF5Z3JpZCddLCB2aWV3U3BlYzogY29udGV4dC52aWV3U3BlYyB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChTY3JvbGxHcmlkLCB7IGxpcXVpZDogIXByb3BzLmlzSGVpZ2h0QXV0byAmJiAhcHJvcHMuZm9yUHJpbnQsIGZvclByaW50OiBwcm9wcy5mb3JQcmludCwgY29sbGFwc2libGVXaWR0aDogcHJvcHMuZm9yUHJpbnQsIGNvbEdyb3VwczogW3sgY29sczogW3sgc3BhbjogY29sQ250LCBtaW5XaWR0aDogZGF5TWluV2lkdGggfV0gfV0sIHNlY3Rpb25zOiBzZWN0aW9ucyB9KSkpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc3BsaXRTZWdzQnlSb3coc2Vncywgcm93Q250KSB7XG4gICAgbGV0IGJ5Um93ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dDbnQ7IGkgKz0gMSkge1xuICAgICAgICBieVJvd1tpXSA9IFtdO1xuICAgIH1cbiAgICBmb3IgKGxldCBzZWcgb2Ygc2Vncykge1xuICAgICAgICBieVJvd1tzZWcucm93XS5wdXNoKHNlZyk7XG4gICAgfVxuICAgIHJldHVybiBieVJvdztcbn1cbmZ1bmN0aW9uIHNwbGl0U2Vnc0J5Rmlyc3RDb2woc2VncywgY29sQ250KSB7XG4gICAgbGV0IGJ5Q29sID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xDbnQ7IGkgKz0gMSkge1xuICAgICAgICBieUNvbFtpXSA9IFtdO1xuICAgIH1cbiAgICBmb3IgKGxldCBzZWcgb2Ygc2Vncykge1xuICAgICAgICBieUNvbFtzZWcuZmlyc3RDb2xdLnB1c2goc2VnKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5Q29sO1xufVxuZnVuY3Rpb24gc3BsaXRJbnRlcmFjdGlvbkJ5Um93KHVpLCByb3dDbnQpIHtcbiAgICBsZXQgYnlSb3cgPSBbXTtcbiAgICBpZiAoIXVpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93Q250OyBpICs9IDEpIHtcbiAgICAgICAgICAgIGJ5Um93W2ldID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dDbnQ7IGkgKz0gMSkge1xuICAgICAgICAgICAgYnlSb3dbaV0gPSB7XG4gICAgICAgICAgICAgICAgYWZmZWN0ZWRJbnN0YW5jZXM6IHVpLmFmZmVjdGVkSW5zdGFuY2VzLFxuICAgICAgICAgICAgICAgIGlzRXZlbnQ6IHVpLmlzRXZlbnQsXG4gICAgICAgICAgICAgICAgc2VnczogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHNlZyBvZiB1aS5zZWdzKSB7XG4gICAgICAgICAgICBieVJvd1tzZWcucm93XS5zZWdzLnB1c2goc2VnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYnlSb3c7XG59XG5cbmNvbnN0IERFRkFVTFRfVEFCTEVfRVZFTlRfVElNRV9GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoe1xuICAgIGhvdXI6ICdudW1lcmljJyxcbiAgICBtaW51dGU6ICcyLWRpZ2l0JyxcbiAgICBvbWl0WmVyb01pbnV0ZTogdHJ1ZSxcbiAgICBtZXJpZGllbTogJ25hcnJvdycsXG59KTtcbmZ1bmN0aW9uIGhhc0xpc3RJdGVtRGlzcGxheShzZWcpIHtcbiAgICBsZXQgeyBkaXNwbGF5IH0gPSBzZWcuZXZlbnRSYW5nZS51aTtcbiAgICByZXR1cm4gZGlzcGxheSA9PT0gJ2xpc3QtaXRlbScgfHwgKGRpc3BsYXkgPT09ICdhdXRvJyAmJlxuICAgICAgICAhc2VnLmV2ZW50UmFuZ2UuZGVmLmFsbERheSAmJlxuICAgICAgICBzZWcuZmlyc3RDb2wgPT09IHNlZy5sYXN0Q29sICYmIC8vIGNhbid0IGJlIG11bHRpLWRheVxuICAgICAgICBzZWcuaXNTdGFydCAmJiAvLyBcIlxuICAgICAgICBzZWcuaXNFbmQgLy8gXCJcbiAgICApO1xufVxuXG5jbGFzcyBUYWJsZUJsb2NrRXZlbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoU3RhbmRhcmRFdmVudCwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMsIHsgZWxDbGFzc2VzOiBbJ2ZjLWRheWdyaWQtZXZlbnQnLCAnZmMtZGF5Z3JpZC1ibG9jay1ldmVudCcsICdmYy1oLWV2ZW50J10sIGRlZmF1bHRUaW1lRm9ybWF0OiBERUZBVUxUX1RBQkxFX0VWRU5UX1RJTUVfRk9STUFULCBkZWZhdWx0RGlzcGxheUV2ZW50RW5kOiBwcm9wcy5kZWZhdWx0RGlzcGxheUV2ZW50RW5kLCBkaXNhYmxlUmVzaXppbmc6ICFwcm9wcy5zZWcuZXZlbnRSYW5nZS5kZWYuYWxsRGF5IH0pKSk7XG4gICAgfVxufVxuXG5jbGFzcyBUYWJsZUxpc3RJdGVtRXZlbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSBjb250ZXh0O1xuICAgICAgICBsZXQgeyBzZWcgfSA9IHByb3BzO1xuICAgICAgICBsZXQgdGltZUZvcm1hdCA9IG9wdGlvbnMuZXZlbnRUaW1lRm9ybWF0IHx8IERFRkFVTFRfVEFCTEVfRVZFTlRfVElNRV9GT1JNQVQ7XG4gICAgICAgIGxldCB0aW1lVGV4dCA9IGJ1aWxkU2VnVGltZVRleHQoc2VnLCB0aW1lRm9ybWF0LCBjb250ZXh0LCB0cnVlLCBwcm9wcy5kZWZhdWx0RGlzcGxheUV2ZW50RW5kKTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEV2ZW50Q29udGFpbmVyLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcywgeyBlbFRhZzogXCJhXCIsIGVsQ2xhc3NlczogWydmYy1kYXlncmlkLWV2ZW50JywgJ2ZjLWRheWdyaWQtZG90LWV2ZW50J10sIGVsQXR0cnM6IGdldFNlZ0FuY2hvckF0dHJzKHByb3BzLnNlZywgY29udGV4dCksIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlcklubmVyQ29udGVudCwgdGltZVRleHQ6IHRpbWVUZXh0LCBpc1Jlc2l6aW5nOiBmYWxzZSwgaXNEYXRlU2VsZWN0aW5nOiBmYWxzZSB9KSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbmRlcklubmVyQ29udGVudChyZW5kZXJQcm9wcykge1xuICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCxcbiAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWV2ZW50LWRvdFwiLCBzdHlsZTogeyBib3JkZXJDb2xvcjogcmVuZGVyUHJvcHMuYm9yZGVyQ29sb3IgfHwgcmVuZGVyUHJvcHMuYmFja2dyb3VuZENvbG9yIH0gfSksXG4gICAgICAgIHJlbmRlclByb3BzLnRpbWVUZXh0ICYmIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXRpbWVcIiB9LCByZW5kZXJQcm9wcy50aW1lVGV4dCkpLFxuICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXRpdGxlXCIgfSwgcmVuZGVyUHJvcHMuZXZlbnQudGl0bGUgfHwgY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCwgXCJcXHUwMEEwXCIpKSkpO1xufVxuXG5jbGFzcyBUYWJsZUNlbGxNb3JlTGluayBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmNvbXBpbGVTZWdzID0gbWVtb2l6ZShjb21waWxlU2Vncyk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IGFsbFNlZ3MsIGludmlzaWJsZVNlZ3MgfSA9IHRoaXMuY29tcGlsZVNlZ3MocHJvcHMuc2luZ2xlUGxhY2VtZW50cyk7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChNb3JlTGlua0NvbnRhaW5lciwgeyBlbENsYXNzZXM6IFsnZmMtZGF5Z3JpZC1tb3JlLWxpbmsnXSwgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlLCBhbGxEYXlEYXRlOiBwcm9wcy5hbGxEYXlEYXRlLCBtb3JlQ250OiBwcm9wcy5tb3JlQ250LCBhbGxTZWdzOiBhbGxTZWdzLCBoaWRkZW5TZWdzOiBpbnZpc2libGVTZWdzLCBhbGlnbm1lbnRFbFJlZjogcHJvcHMuYWxpZ25tZW50RWxSZWYsIGFsaWduR3JpZFRvcDogcHJvcHMuYWxpZ25HcmlkVG9wLCBleHRyYURhdGVTcGFuOiBwcm9wcy5leHRyYURhdGVTcGFuLCBwb3BvdmVyQ29udGVudDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBpc0ZvcmNlZEludmlzaWJsZSA9IChwcm9wcy5ldmVudERyYWcgPyBwcm9wcy5ldmVudERyYWcuYWZmZWN0ZWRJbnN0YW5jZXMgOiBudWxsKSB8fFxuICAgICAgICAgICAgICAgICAgICAocHJvcHMuZXZlbnRSZXNpemUgPyBwcm9wcy5ldmVudFJlc2l6ZS5hZmZlY3RlZEluc3RhbmNlcyA6IG51bGwpIHx8XG4gICAgICAgICAgICAgICAgICAgIHt9O1xuICAgICAgICAgICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCwgYWxsU2Vncy5tYXAoKHNlZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5zdGFuY2VJZCA9IHNlZy5ldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWV2ZW50LWhhcm5lc3NcIiwga2V5OiBpbnN0YW5jZUlkLCBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IGlzRm9yY2VkSW52aXNpYmxlW2luc3RhbmNlSWRdID8gJ2hpZGRlbicgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gfSwgaGFzTGlzdEl0ZW1EaXNwbGF5KHNlZykgPyAoY3JlYXRlRWxlbWVudChUYWJsZUxpc3RJdGVtRXZlbnQsIE9iamVjdC5hc3NpZ24oeyBzZWc6IHNlZywgaXNEcmFnZ2luZzogZmFsc2UsIGlzU2VsZWN0ZWQ6IGluc3RhbmNlSWQgPT09IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBkZWZhdWx0RGlzcGxheUV2ZW50RW5kOiBmYWxzZSB9LCBnZXRTZWdNZXRhKHNlZywgcHJvcHMudG9kYXlSYW5nZSkpKSkgOiAoY3JlYXRlRWxlbWVudChUYWJsZUJsb2NrRXZlbnQsIE9iamVjdC5hc3NpZ24oeyBzZWc6IHNlZywgaXNEcmFnZ2luZzogZmFsc2UsIGlzUmVzaXppbmc6IGZhbHNlLCBpc0RhdGVTZWxlY3Rpbmc6IGZhbHNlLCBpc1NlbGVjdGVkOiBpbnN0YW5jZUlkID09PSBwcm9wcy5ldmVudFNlbGVjdGlvbiwgZGVmYXVsdERpc3BsYXlFdmVudEVuZDogZmFsc2UgfSwgZ2V0U2VnTWV0YShzZWcsIHByb3BzLnRvZGF5UmFuZ2UpKSkpKSk7XG4gICAgICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgIH0gfSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXBpbGVTZWdzKHNpbmdsZVBsYWNlbWVudHMpIHtcbiAgICBsZXQgYWxsU2VncyA9IFtdO1xuICAgIGxldCBpbnZpc2libGVTZWdzID0gW107XG4gICAgZm9yIChsZXQgcGxhY2VtZW50IG9mIHNpbmdsZVBsYWNlbWVudHMpIHtcbiAgICAgICAgYWxsU2Vncy5wdXNoKHBsYWNlbWVudC5zZWcpO1xuICAgICAgICBpZiAoIXBsYWNlbWVudC5pc1Zpc2libGUpIHtcbiAgICAgICAgICAgIGludmlzaWJsZVNlZ3MucHVzaChwbGFjZW1lbnQuc2VnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBhbGxTZWdzLCBpbnZpc2libGVTZWdzIH07XG59XG5cbmNvbnN0IERFRkFVTFRfV0VFS19OVU1fRk9STUFUID0gY3JlYXRlRm9ybWF0dGVyKHsgd2VlazogJ25hcnJvdycgfSk7XG5jbGFzcyBUYWJsZUNlbGwgZXh0ZW5kcyBEYXRlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5yb290RWxSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGRheU51bWJlcklkOiBnZXRVbmlxdWVEb21JZCgpLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVJvb3RFbCA9IChlbCkgPT4ge1xuICAgICAgICAgICAgc2V0UmVmKHRoaXMucm9vdEVsUmVmLCBlbCk7XG4gICAgICAgICAgICBzZXRSZWYodGhpcy5wcm9wcy5lbFJlZiwgZWwpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IGNvbnRleHQsIHByb3BzLCBzdGF0ZSwgcm9vdEVsUmVmIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBvcHRpb25zLCBkYXRlRW52IH0gPSBjb250ZXh0O1xuICAgICAgICBsZXQgeyBkYXRlLCBkYXRlUHJvZmlsZSB9ID0gcHJvcHM7XG4gICAgICAgIC8vIFRPRE86IG1lbW9pemUgdGhpcz9cbiAgICAgICAgY29uc3QgaXNNb250aFN0YXJ0ID0gcHJvcHMuc2hvd0RheU51bWJlciAmJlxuICAgICAgICAgICAgc2hvdWxkRGlzcGxheU1vbnRoU3RhcnQoZGF0ZSwgZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLCBkYXRlRW52KTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KERheUNlbGxDb250YWluZXIsIHsgZWxUYWc6IFwidGRcIiwgZWxSZWY6IHRoaXMuaGFuZGxlUm9vdEVsLCBlbENsYXNzZXM6IFtcbiAgICAgICAgICAgICAgICAnZmMtZGF5Z3JpZC1kYXknLFxuICAgICAgICAgICAgICAgIC4uLihwcm9wcy5leHRyYUNsYXNzTmFtZXMgfHwgW10pLFxuICAgICAgICAgICAgXSwgZWxBdHRyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByb3BzLmV4dHJhRGF0YUF0dHJzKSwgKHByb3BzLnNob3dEYXlOdW1iZXIgPyB7ICdhcmlhLWxhYmVsbGVkYnknOiBzdGF0ZS5kYXlOdW1iZXJJZCB9IDoge30pKSwgeyByb2xlOiAnZ3JpZGNlbGwnIH0pLCBkZWZhdWx0R2VuZXJhdG9yOiByZW5kZXJUb3BJbm5lciwgZGF0ZTogZGF0ZSwgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLCB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlLCBzaG93RGF5TnVtYmVyOiBwcm9wcy5zaG93RGF5TnVtYmVyLCBpc01vbnRoU3RhcnQ6IGlzTW9udGhTdGFydCwgZXh0cmFSZW5kZXJQcm9wczogcHJvcHMuZXh0cmFSZW5kZXJQcm9wcyB9LCAoSW5uZXJDb250ZW50LCByZW5kZXJQcm9wcykgPT4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IHByb3BzLmlubmVyRWxSZWYsIGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWRheS1mcmFtZSBmYy1zY3JvbGxncmlkLXN5bmMtaW5uZXJcIiwgc3R5bGU6IHsgbWluSGVpZ2h0OiBwcm9wcy5taW5IZWlnaHQgfSB9LFxuICAgICAgICAgICAgcHJvcHMuc2hvd1dlZWtOdW1iZXIgJiYgKGNyZWF0ZUVsZW1lbnQoV2Vla051bWJlckNvbnRhaW5lciwgeyBlbFRhZzogXCJhXCIsIGVsQ2xhc3NlczogWydmYy1kYXlncmlkLXdlZWstbnVtYmVyJ10sIGVsQXR0cnM6IGJ1aWxkTmF2TGlua0F0dHJzKGNvbnRleHQsIGRhdGUsICd3ZWVrJyksIGRhdGU6IGRhdGUsIGRlZmF1bHRGb3JtYXQ6IERFRkFVTFRfV0VFS19OVU1fRk9STUFUIH0pKSxcbiAgICAgICAgICAgICFyZW5kZXJQcm9wcy5pc0Rpc2FibGVkICYmXG4gICAgICAgICAgICAgICAgKHByb3BzLnNob3dEYXlOdW1iZXIgfHwgaGFzQ3VzdG9tRGF5Q2VsbENvbnRlbnQob3B0aW9ucykgfHwgcHJvcHMuZm9yY2VEYXlUb3ApID8gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZGF5Z3JpZC1kYXktdG9wXCIgfSxcbiAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KElubmVyQ29udGVudCwgeyBlbFRhZzogXCJhXCIsIGVsQ2xhc3NlczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLWRheWdyaWQtZGF5LW51bWJlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc01vbnRoU3RhcnQgJiYgJ2ZjLWRheWdyaWQtbW9udGgtc3RhcnQnLFxuICAgICAgICAgICAgICAgICAgICBdLCBlbEF0dHJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJ1aWxkTmF2TGlua0F0dHJzKGNvbnRleHQsIGRhdGUpKSwgeyBpZDogc3RhdGUuZGF5TnVtYmVySWQgfSkgfSkpKSA6IHByb3BzLnNob3dEYXlOdW1iZXIgPyAoXG4gICAgICAgICAgICAvLyBmb3IgY3JlYXRpbmcgY29ycmVjdCBhbW91bnQgb2Ygc3BhY2UgKHNlZSBpc3N1ZSAjNzE2MilcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZGF5Z3JpZC1kYXktdG9wXCIsIHN0eWxlOiB7IHZpc2liaWxpdHk6ICdoaWRkZW4nIH0gfSxcbiAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiYVwiLCB7IGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWRheS1udW1iZXJcIiB9LCBcIlxcdTAwQTBcIikpKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZGF5Z3JpZC1kYXktZXZlbnRzXCIsIHJlZjogcHJvcHMuZmdDb250ZW50RWxSZWYgfSxcbiAgICAgICAgICAgICAgICBwcm9wcy5mZ0NvbnRlbnQsXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWRheS1ib3R0b21cIiwgc3R5bGU6IHsgbWFyZ2luVG9wOiBwcm9wcy5tb3JlTWFyZ2luVG9wIH0gfSxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChUYWJsZUNlbGxNb3JlTGluaywgeyBhbGxEYXlEYXRlOiBkYXRlLCBzaW5nbGVQbGFjZW1lbnRzOiBwcm9wcy5zaW5nbGVQbGFjZW1lbnRzLCBtb3JlQ250OiBwcm9wcy5tb3JlQ250LCBhbGlnbm1lbnRFbFJlZjogcm9vdEVsUmVmLCBhbGlnbkdyaWRUb3A6ICFwcm9wcy5zaG93RGF5TnVtYmVyLCBleHRyYURhdGVTcGFuOiBwcm9wcy5leHRyYURhdGVTcGFuLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIGV2ZW50U2VsZWN0aW9uOiBwcm9wcy5ldmVudFNlbGVjdGlvbiwgZXZlbnREcmFnOiBwcm9wcy5ldmVudERyYWcsIGV2ZW50UmVzaXplOiBwcm9wcy5ldmVudFJlc2l6ZSwgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSB9KSkpLFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWRheS1iZ1wiIH0sIHByb3BzLmJnQ29udGVudCkpKSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbmRlclRvcElubmVyKHByb3BzKSB7XG4gICAgcmV0dXJuIHByb3BzLmRheU51bWJlclRleHQgfHwgY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCwgXCJcXHUwMEEwXCIpO1xufVxuZnVuY3Rpb24gc2hvdWxkRGlzcGxheU1vbnRoU3RhcnQoZGF0ZSwgY3VycmVudFJhbmdlLCBkYXRlRW52KSB7XG4gICAgY29uc3QgeyBzdGFydDogY3VycmVudFN0YXJ0LCBlbmQ6IGN1cnJlbnRFbmQgfSA9IGN1cnJlbnRSYW5nZTtcbiAgICBjb25zdCBjdXJyZW50RW5kSW5jbCA9IGFkZE1zKGN1cnJlbnRFbmQsIC0xKTtcbiAgICBjb25zdCBjdXJyZW50Rmlyc3RZZWFyID0gZGF0ZUVudi5nZXRZZWFyKGN1cnJlbnRTdGFydCk7XG4gICAgY29uc3QgY3VycmVudEZpcnN0TW9udGggPSBkYXRlRW52LmdldE1vbnRoKGN1cnJlbnRTdGFydCk7XG4gICAgY29uc3QgY3VycmVudExhc3RZZWFyID0gZGF0ZUVudi5nZXRZZWFyKGN1cnJlbnRFbmRJbmNsKTtcbiAgICBjb25zdCBjdXJyZW50TGFzdE1vbnRoID0gZGF0ZUVudi5nZXRNb250aChjdXJyZW50RW5kSW5jbCk7XG4gICAgLy8gc3BhbnMgbW9yZSB0aGFuIG9uZSBtb250aD9cbiAgICByZXR1cm4gIShjdXJyZW50Rmlyc3RZZWFyID09PSBjdXJyZW50TGFzdFllYXIgJiYgY3VycmVudEZpcnN0TW9udGggPT09IGN1cnJlbnRMYXN0TW9udGgpICYmXG4gICAgICAgIEJvb2xlYW4oXG4gICAgICAgIC8vIGZpcnN0IGRhdGUgaW4gY3VycmVudCB2aWV3P1xuICAgICAgICBkYXRlLnZhbHVlT2YoKSA9PT0gY3VycmVudFN0YXJ0LnZhbHVlT2YoKSB8fFxuICAgICAgICAgICAgLy8gYSBtb250aC1zdGFydCB0aGF0J3Mgd2l0aGluIHRoZSBjdXJyZW50IHJhbmdlP1xuICAgICAgICAgICAgKGRhdGVFbnYuZ2V0RGF5KGRhdGUpID09PSAxICYmIGRhdGUudmFsdWVPZigpIDwgY3VycmVudEVuZC52YWx1ZU9mKCkpKTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVTZWdLZXkoc2VnKSB7XG4gICAgcmV0dXJuIHNlZy5ldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWQgKyAnOicgKyBzZWcuZmlyc3RDb2w7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVNlZ1VpZChzZWcpIHtcbiAgICByZXR1cm4gZ2VuZXJhdGVTZWdLZXkoc2VnKSArICc6JyArIHNlZy5sYXN0Q29sO1xufVxuZnVuY3Rpb24gY29tcHV0ZUZnU2VnUGxhY2VtZW50KHNlZ3MsIC8vIGFzc3VtZWQgYWxyZWFkeSBzb3J0ZWRcbmRheU1heEV2ZW50cywgZGF5TWF4RXZlbnRSb3dzLCBzdHJpY3RPcmRlciwgc2VnSGVpZ2h0cywgbWF4Q29udGVudEhlaWdodCwgY2VsbHMpIHtcbiAgICBsZXQgaGllcmFyY2h5ID0gbmV3IERheUdyaWRTZWdIaWVyYXJjaHkoKHNlZ0VudHJ5KSA9PiB7XG4gICAgICAgIC8vIFRPRE86IG1vcmUgRFJZIHdpdGggZ2VuZXJhdGVTZWdVaWRcbiAgICAgICAgbGV0IHNlZ1VpZCA9IHNlZ3Nbc2VnRW50cnkuaW5kZXhdLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZCArXG4gICAgICAgICAgICAnOicgKyBzZWdFbnRyeS5zcGFuLnN0YXJ0ICtcbiAgICAgICAgICAgICc6JyArIChzZWdFbnRyeS5zcGFuLmVuZCAtIDEpO1xuICAgICAgICAvLyBpZiBubyB0aGlja25lc3Mga25vd24sIGFzc3VtZSAxIChpZiAwLCBzbyBzbWFsbCBpdCBhbHdheXMgZml0cylcbiAgICAgICAgcmV0dXJuIHNlZ0hlaWdodHNbc2VnVWlkXSB8fCAxO1xuICAgIH0pO1xuICAgIGhpZXJhcmNoeS5hbGxvd1Jlc2xpY2luZyA9IHRydWU7XG4gICAgaGllcmFyY2h5LnN0cmljdE9yZGVyID0gc3RyaWN0T3JkZXI7XG4gICAgaWYgKGRheU1heEV2ZW50cyA9PT0gdHJ1ZSB8fCBkYXlNYXhFdmVudFJvd3MgPT09IHRydWUpIHtcbiAgICAgICAgaGllcmFyY2h5Lm1heENvb3JkID0gbWF4Q29udGVudEhlaWdodDtcbiAgICAgICAgaGllcmFyY2h5LmhpZGRlbkNvbnN1bWVzID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRheU1heEV2ZW50cyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaGllcmFyY2h5Lm1heFN0YWNrQ250ID0gZGF5TWF4RXZlbnRzO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGF5TWF4RXZlbnRSb3dzID09PSAnbnVtYmVyJykge1xuICAgICAgICBoaWVyYXJjaHkubWF4U3RhY2tDbnQgPSBkYXlNYXhFdmVudFJvd3M7XG4gICAgICAgIGhpZXJhcmNoeS5oaWRkZW5Db25zdW1lcyA9IHRydWU7XG4gICAgfVxuICAgIC8vIGNyZWF0ZSBzZWdJbnB1dHMgb25seSBmb3Igc2VncyB3aXRoIGtub3duIGhlaWdodHNcbiAgICBsZXQgc2VnSW5wdXRzID0gW107XG4gICAgbGV0IHVua25vd25IZWlnaHRTZWdzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGxldCBzZWcgPSBzZWdzW2ldO1xuICAgICAgICBsZXQgc2VnVWlkID0gZ2VuZXJhdGVTZWdVaWQoc2VnKTtcbiAgICAgICAgbGV0IGV2ZW50SGVpZ2h0ID0gc2VnSGVpZ2h0c1tzZWdVaWRdO1xuICAgICAgICBpZiAoZXZlbnRIZWlnaHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2VnSW5wdXRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgIHNwYW46IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHNlZy5maXJzdENvbCxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBzZWcubGFzdENvbCArIDEsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdW5rbm93bkhlaWdodFNlZ3MucHVzaChzZWcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBoaWRkZW5FbnRyaWVzID0gaGllcmFyY2h5LmFkZFNlZ3Moc2VnSW5wdXRzKTtcbiAgICBsZXQgc2VnUmVjdHMgPSBoaWVyYXJjaHkudG9SZWN0cygpO1xuICAgIGxldCB7IHNpbmdsZUNvbFBsYWNlbWVudHMsIG11bHRpQ29sUGxhY2VtZW50cywgbGVmdG92ZXJNYXJnaW5zIH0gPSBwbGFjZVJlY3RzKHNlZ1JlY3RzLCBzZWdzLCBjZWxscyk7XG4gICAgbGV0IG1vcmVDbnRzID0gW107XG4gICAgbGV0IG1vcmVNYXJnaW5Ub3BzID0gW107XG4gICAgLy8gYWRkIHNlZ3Mgd2l0aCB1bmtub3duIGhlaWdodHNcbiAgICBmb3IgKGxldCBzZWcgb2YgdW5rbm93bkhlaWdodFNlZ3MpIHtcbiAgICAgICAgbXVsdGlDb2xQbGFjZW1lbnRzW3NlZy5maXJzdENvbF0ucHVzaCh7XG4gICAgICAgICAgICBzZWcsXG4gICAgICAgICAgICBpc1Zpc2libGU6IGZhbHNlLFxuICAgICAgICAgICAgaXNBYnNvbHV0ZTogdHJ1ZSxcbiAgICAgICAgICAgIGFic29sdXRlVG9wOiAwLFxuICAgICAgICAgICAgbWFyZ2luVG9wOiAwLFxuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChsZXQgY29sID0gc2VnLmZpcnN0Q29sOyBjb2wgPD0gc2VnLmxhc3RDb2w7IGNvbCArPSAxKSB7XG4gICAgICAgICAgICBzaW5nbGVDb2xQbGFjZW1lbnRzW2NvbF0ucHVzaCh7XG4gICAgICAgICAgICAgICAgc2VnOiByZXNsaWNlU2VnKHNlZywgY29sLCBjb2wgKyAxLCBjZWxscyksXG4gICAgICAgICAgICAgICAgaXNWaXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc0Fic29sdXRlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhYnNvbHV0ZVRvcDogMCxcbiAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6IDAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBhZGQgdGhlIGhpZGRlbiBlbnRyaWVzXG4gICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgY2VsbHMubGVuZ3RoOyBjb2wgKz0gMSkge1xuICAgICAgICBtb3JlQ250cy5wdXNoKDApO1xuICAgIH1cbiAgICBmb3IgKGxldCBoaWRkZW5FbnRyeSBvZiBoaWRkZW5FbnRyaWVzKSB7XG4gICAgICAgIGxldCBzZWcgPSBzZWdzW2hpZGRlbkVudHJ5LmluZGV4XTtcbiAgICAgICAgbGV0IGhpZGRlblNwYW4gPSBoaWRkZW5FbnRyeS5zcGFuO1xuICAgICAgICBtdWx0aUNvbFBsYWNlbWVudHNbaGlkZGVuU3Bhbi5zdGFydF0ucHVzaCh7XG4gICAgICAgICAgICBzZWc6IHJlc2xpY2VTZWcoc2VnLCBoaWRkZW5TcGFuLnN0YXJ0LCBoaWRkZW5TcGFuLmVuZCwgY2VsbHMpLFxuICAgICAgICAgICAgaXNWaXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGlzQWJzb2x1dGU6IHRydWUsXG4gICAgICAgICAgICBhYnNvbHV0ZVRvcDogMCxcbiAgICAgICAgICAgIG1hcmdpblRvcDogMCxcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAobGV0IGNvbCA9IGhpZGRlblNwYW4uc3RhcnQ7IGNvbCA8IGhpZGRlblNwYW4uZW5kOyBjb2wgKz0gMSkge1xuICAgICAgICAgICAgbW9yZUNudHNbY29sXSArPSAxO1xuICAgICAgICAgICAgc2luZ2xlQ29sUGxhY2VtZW50c1tjb2xdLnB1c2goe1xuICAgICAgICAgICAgICAgIHNlZzogcmVzbGljZVNlZyhzZWcsIGNvbCwgY29sICsgMSwgY2VsbHMpLFxuICAgICAgICAgICAgICAgIGlzVmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNBYnNvbHV0ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgYWJzb2x1dGVUb3A6IDAsXG4gICAgICAgICAgICAgICAgbWFyZ2luVG9wOiAwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZGVhbCB3aXRoIGxlZnRvdmVyIG1hcmdpbnNcbiAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjZWxscy5sZW5ndGg7IGNvbCArPSAxKSB7XG4gICAgICAgIG1vcmVNYXJnaW5Ub3BzLnB1c2gobGVmdG92ZXJNYXJnaW5zW2NvbF0pO1xuICAgIH1cbiAgICByZXR1cm4geyBzaW5nbGVDb2xQbGFjZW1lbnRzLCBtdWx0aUNvbFBsYWNlbWVudHMsIG1vcmVDbnRzLCBtb3JlTWFyZ2luVG9wcyB9O1xufVxuLy8gcmVjdHMgb3JkZXJlZCBieSB0b3AgY29vcmQsIHRoZW4gbGVmdFxuZnVuY3Rpb24gcGxhY2VSZWN0cyhhbGxSZWN0cywgc2VncywgY2VsbHMpIHtcbiAgICBsZXQgcmVjdHNCeUVhY2hDb2wgPSBncm91cFJlY3RzQnlFYWNoQ29sKGFsbFJlY3RzLCBjZWxscy5sZW5ndGgpO1xuICAgIGxldCBzaW5nbGVDb2xQbGFjZW1lbnRzID0gW107XG4gICAgbGV0IG11bHRpQ29sUGxhY2VtZW50cyA9IFtdO1xuICAgIGxldCBsZWZ0b3Zlck1hcmdpbnMgPSBbXTtcbiAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjZWxscy5sZW5ndGg7IGNvbCArPSAxKSB7XG4gICAgICAgIGxldCByZWN0cyA9IHJlY3RzQnlFYWNoQ29sW2NvbF07XG4gICAgICAgIC8vIGNvbXB1dGUgYWxsIHN0YXRpYyBzZWdzIGluIHNpbmdsZVBsYWNlbWVudHNcbiAgICAgICAgbGV0IHNpbmdsZVBsYWNlbWVudHMgPSBbXTtcbiAgICAgICAgbGV0IGN1cnJlbnRIZWlnaHQgPSAwO1xuICAgICAgICBsZXQgY3VycmVudE1hcmdpblRvcCA9IDA7XG4gICAgICAgIGZvciAobGV0IHJlY3Qgb2YgcmVjdHMpIHtcbiAgICAgICAgICAgIGxldCBzZWcgPSBzZWdzW3JlY3QuaW5kZXhdO1xuICAgICAgICAgICAgc2luZ2xlUGxhY2VtZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBzZWc6IHJlc2xpY2VTZWcoc2VnLCBjb2wsIGNvbCArIDEsIGNlbGxzKSxcbiAgICAgICAgICAgICAgICBpc1Zpc2libGU6IHRydWUsXG4gICAgICAgICAgICAgICAgaXNBYnNvbHV0ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgYWJzb2x1dGVUb3A6IHJlY3QubGV2ZWxDb29yZCxcbiAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6IHJlY3QubGV2ZWxDb29yZCAtIGN1cnJlbnRIZWlnaHQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGN1cnJlbnRIZWlnaHQgPSByZWN0LmxldmVsQ29vcmQgKyByZWN0LnRoaWNrbmVzcztcbiAgICAgICAgfVxuICAgICAgICAvLyBjb21wdXRlIG1peGVkIHN0YXRpYy9hYnNvbHV0ZSBzZWdzIGluIG11bHRpUGxhY2VtZW50c1xuICAgICAgICBsZXQgbXVsdGlQbGFjZW1lbnRzID0gW107XG4gICAgICAgIGN1cnJlbnRIZWlnaHQgPSAwO1xuICAgICAgICBjdXJyZW50TWFyZ2luVG9wID0gMDtcbiAgICAgICAgZm9yIChsZXQgcmVjdCBvZiByZWN0cykge1xuICAgICAgICAgICAgbGV0IHNlZyA9IHNlZ3NbcmVjdC5pbmRleF07XG4gICAgICAgICAgICBsZXQgaXNBYnNvbHV0ZSA9IHJlY3Quc3Bhbi5lbmQgLSByZWN0LnNwYW4uc3RhcnQgPiAxOyAvLyBtdWx0aS1jb2x1bW4/XG4gICAgICAgICAgICBsZXQgaXNGaXJzdENvbCA9IHJlY3Quc3Bhbi5zdGFydCA9PT0gY29sO1xuICAgICAgICAgICAgY3VycmVudE1hcmdpblRvcCArPSByZWN0LmxldmVsQ29vcmQgLSBjdXJyZW50SGVpZ2h0OyAvLyBhbW91bnQgb2Ygc3BhY2Ugc2luY2UgYm90dG9tIG9mIHByZXZpb3VzIHNlZ1xuICAgICAgICAgICAgY3VycmVudEhlaWdodCA9IHJlY3QubGV2ZWxDb29yZCArIHJlY3QudGhpY2tuZXNzOyAvLyBoZWlnaHQgd2lsbCBub3cgYmUgYm90dG9tIG9mIGN1cnJlbnQgc2VnXG4gICAgICAgICAgICBpZiAoaXNBYnNvbHV0ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRNYXJnaW5Ub3AgKz0gcmVjdC50aGlja25lc3M7XG4gICAgICAgICAgICAgICAgaWYgKGlzRmlyc3RDb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlQbGFjZW1lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VnOiByZXNsaWNlU2VnKHNlZywgcmVjdC5zcGFuLnN0YXJ0LCByZWN0LnNwYW4uZW5kLCBjZWxscyksXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1Zpc2libGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0Fic29sdXRlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWJzb2x1dGVUb3A6IHJlY3QubGV2ZWxDb29yZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpblRvcDogMCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNGaXJzdENvbCkge1xuICAgICAgICAgICAgICAgIG11bHRpUGxhY2VtZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgc2VnOiByZXNsaWNlU2VnKHNlZywgcmVjdC5zcGFuLnN0YXJ0LCByZWN0LnNwYW4uZW5kLCBjZWxscyksXG4gICAgICAgICAgICAgICAgICAgIGlzVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaXNBYnNvbHV0ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGFic29sdXRlVG9wOiByZWN0LmxldmVsQ29vcmQsXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpblRvcDogY3VycmVudE1hcmdpblRvcCwgLy8gY2xhaW0gdGhlIG1hcmdpblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRNYXJnaW5Ub3AgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNpbmdsZUNvbFBsYWNlbWVudHMucHVzaChzaW5nbGVQbGFjZW1lbnRzKTtcbiAgICAgICAgbXVsdGlDb2xQbGFjZW1lbnRzLnB1c2gobXVsdGlQbGFjZW1lbnRzKTtcbiAgICAgICAgbGVmdG92ZXJNYXJnaW5zLnB1c2goY3VycmVudE1hcmdpblRvcCk7XG4gICAgfVxuICAgIHJldHVybiB7IHNpbmdsZUNvbFBsYWNlbWVudHMsIG11bHRpQ29sUGxhY2VtZW50cywgbGVmdG92ZXJNYXJnaW5zIH07XG59XG5mdW5jdGlvbiBncm91cFJlY3RzQnlFYWNoQ29sKHJlY3RzLCBjb2xDbnQpIHtcbiAgICBsZXQgcmVjdHNCeUVhY2hDb2wgPSBbXTtcbiAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjb2xDbnQ7IGNvbCArPSAxKSB7XG4gICAgICAgIHJlY3RzQnlFYWNoQ29sLnB1c2goW10pO1xuICAgIH1cbiAgICBmb3IgKGxldCByZWN0IG9mIHJlY3RzKSB7XG4gICAgICAgIGZvciAobGV0IGNvbCA9IHJlY3Quc3Bhbi5zdGFydDsgY29sIDwgcmVjdC5zcGFuLmVuZDsgY29sICs9IDEpIHtcbiAgICAgICAgICAgIHJlY3RzQnlFYWNoQ29sW2NvbF0ucHVzaChyZWN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVjdHNCeUVhY2hDb2w7XG59XG5mdW5jdGlvbiByZXNsaWNlU2VnKHNlZywgc3BhblN0YXJ0LCBzcGFuRW5kLCBjZWxscykge1xuICAgIGlmIChzZWcuZmlyc3RDb2wgPT09IHNwYW5TdGFydCAmJiBzZWcubGFzdENvbCA9PT0gc3BhbkVuZCAtIDEpIHtcbiAgICAgICAgcmV0dXJuIHNlZztcbiAgICB9XG4gICAgbGV0IGV2ZW50UmFuZ2UgPSBzZWcuZXZlbnRSYW5nZTtcbiAgICBsZXQgb3JpZ1JhbmdlID0gZXZlbnRSYW5nZS5yYW5nZTtcbiAgICBsZXQgc2xpY2VkUmFuZ2UgPSBpbnRlcnNlY3RSYW5nZXMob3JpZ1JhbmdlLCB7XG4gICAgICAgIHN0YXJ0OiBjZWxsc1tzcGFuU3RhcnRdLmRhdGUsXG4gICAgICAgIGVuZDogYWRkRGF5cyhjZWxsc1tzcGFuRW5kIC0gMV0uZGF0ZSwgMSksXG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc2VnKSwgeyBmaXJzdENvbDogc3BhblN0YXJ0LCBsYXN0Q29sOiBzcGFuRW5kIC0gMSwgZXZlbnRSYW5nZToge1xuICAgICAgICAgICAgZGVmOiBldmVudFJhbmdlLmRlZixcbiAgICAgICAgICAgIHVpOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV2ZW50UmFuZ2UudWkpLCB7IGR1cmF0aW9uRWRpdGFibGU6IGZhbHNlIH0pLFxuICAgICAgICAgICAgaW5zdGFuY2U6IGV2ZW50UmFuZ2UuaW5zdGFuY2UsXG4gICAgICAgICAgICByYW5nZTogc2xpY2VkUmFuZ2UsXG4gICAgICAgIH0sIGlzU3RhcnQ6IHNlZy5pc1N0YXJ0ICYmIHNsaWNlZFJhbmdlLnN0YXJ0LnZhbHVlT2YoKSA9PT0gb3JpZ1JhbmdlLnN0YXJ0LnZhbHVlT2YoKSwgaXNFbmQ6IHNlZy5pc0VuZCAmJiBzbGljZWRSYW5nZS5lbmQudmFsdWVPZigpID09PSBvcmlnUmFuZ2UuZW5kLnZhbHVlT2YoKSB9KTtcbn1cbmNsYXNzIERheUdyaWRTZWdIaWVyYXJjaHkgZXh0ZW5kcyBTZWdIaWVyYXJjaHkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAvLyBjb25maWdcbiAgICAgICAgdGhpcy5oaWRkZW5Db25zdW1lcyA9IGZhbHNlO1xuICAgICAgICAvLyBhbGxvd3MgdXMgdG8ga2VlcCBoaWRkZW4gZW50cmllcyBpbiB0aGUgaGllcmFyY2h5IHNvIHRoZXkgdGFrZSB1cCBzcGFjZVxuICAgICAgICB0aGlzLmZvcmNlSGlkZGVuID0ge307XG4gICAgfVxuICAgIGFkZFNlZ3Moc2VnSW5wdXRzKSB7XG4gICAgICAgIGNvbnN0IGhpZGRlblNlZ3MgPSBzdXBlci5hZGRTZWdzKHNlZ0lucHV0cyk7XG4gICAgICAgIGNvbnN0IHsgZW50cmllc0J5TGV2ZWwgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGV4Y2x1ZGVIaWRkZW4gPSAoZW50cnkpID0+ICF0aGlzLmZvcmNlSGlkZGVuW2J1aWxkRW50cnlLZXkoZW50cnkpXTtcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBmb3JjZWQtaGlkZGVuIHNlZ3NcbiAgICAgICAgZm9yIChsZXQgbGV2ZWwgPSAwOyBsZXZlbCA8IGVudHJpZXNCeUxldmVsLmxlbmd0aDsgbGV2ZWwgKz0gMSkge1xuICAgICAgICAgICAgZW50cmllc0J5TGV2ZWxbbGV2ZWxdID0gZW50cmllc0J5TGV2ZWxbbGV2ZWxdLmZpbHRlcihleGNsdWRlSGlkZGVuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGlkZGVuU2VncztcbiAgICB9XG4gICAgaGFuZGxlSW52YWxpZEluc2VydGlvbihpbnNlcnRpb24sIGVudHJ5LCBoaWRkZW5FbnRyaWVzKSB7XG4gICAgICAgIGNvbnN0IHsgZW50cmllc0J5TGV2ZWwsIGZvcmNlSGlkZGVuIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHRvdWNoaW5nRW50cnksIHRvdWNoaW5nTGV2ZWwsIHRvdWNoaW5nTGF0ZXJhbCB9ID0gaW5zZXJ0aW9uO1xuICAgICAgICAvLyB0aGUgZW50cnkgdGhhdCB0aGUgbmV3IGluc2VydGlvbiBpcyB0b3VjaGluZyBtdXN0IGJlIGhpZGRlblxuICAgICAgICBpZiAodGhpcy5oaWRkZW5Db25zdW1lcyAmJiB0b3VjaGluZ0VudHJ5KSB7XG4gICAgICAgICAgICBjb25zdCB0b3VjaGluZ0VudHJ5SWQgPSBidWlsZEVudHJ5S2V5KHRvdWNoaW5nRW50cnkpO1xuICAgICAgICAgICAgaWYgKCFmb3JjZUhpZGRlblt0b3VjaGluZ0VudHJ5SWRdKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYWxsb3dSZXNsaWNpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3BsaXQgdXAgdGhlIHRvdWNoaW5nRW50cnksIHJlaW5zZXJ0IGl0XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhpZGRlbkVudHJ5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0b3VjaGluZ0VudHJ5KSwgeyBzcGFuOiBpbnRlcnNlY3RTcGFucyh0b3VjaGluZ0VudHJ5LnNwYW4sIGVudHJ5LnNwYW4pIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyByZWluc2VydCB0aGUgYXJlYSB0aGF0IHR1cm5lZCBpbnRvIGEgXCJtb3JlXCIgbGluayAoc28gbm8gb3RoZXIgZW50cmllcyB0cnkgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gb2NjdXB5IHRoZSBzcGFjZSkgYnV0IG1hcmsgaXQgZm9yY2VkLWhpZGRlblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBoaWRkZW5FbnRyeUlkID0gYnVpbGRFbnRyeUtleShoaWRkZW5FbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgIGZvcmNlSGlkZGVuW2hpZGRlbkVudHJ5SWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZW50cmllc0J5TGV2ZWxbdG91Y2hpbmdMZXZlbF1bdG91Y2hpbmdMYXRlcmFsXSA9IGhpZGRlbkVudHJ5O1xuICAgICAgICAgICAgICAgICAgICBoaWRkZW5FbnRyaWVzLnB1c2goaGlkZGVuRW50cnkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwbGl0RW50cnkodG91Y2hpbmdFbnRyeSwgZW50cnksIGhpZGRlbkVudHJpZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VIaWRkZW5bdG91Y2hpbmdFbnRyeUlkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGhpZGRlbkVudHJpZXMucHVzaCh0b3VjaGluZ0VudHJ5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2lsbCB0cnkgdG8gcmVzbGljZS4uLlxuICAgICAgICBzdXBlci5oYW5kbGVJbnZhbGlkSW5zZXJ0aW9uKGluc2VydGlvbiwgZW50cnksIGhpZGRlbkVudHJpZXMpO1xuICAgIH1cbn1cblxuY2xhc3MgVGFibGVSb3cgZXh0ZW5kcyBEYXRlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5jZWxsRWxSZWZzID0gbmV3IFJlZk1hcCgpOyAvLyB0aGUgPHRkPlxuICAgICAgICB0aGlzLmZyYW1lRWxSZWZzID0gbmV3IFJlZk1hcCgpOyAvLyB0aGUgZmMtZGF5Z3JpZC1kYXktZnJhbWVcbiAgICAgICAgdGhpcy5mZ0VsUmVmcyA9IG5ldyBSZWZNYXAoKTsgLy8gdGhlIGZjLWRheWdyaWQtZGF5LWV2ZW50c1xuICAgICAgICB0aGlzLnNlZ0hhcm5lc3NSZWZzID0gbmV3IFJlZk1hcCgpOyAvLyBpbmRleGVkIGJ5IFwiaW5zdGFuY2VJZDpmaXJzdENvbFwiXG4gICAgICAgIHRoaXMucm9vdEVsUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBmcmFtZVBvc2l0aW9uczogbnVsbCxcbiAgICAgICAgICAgIG1heENvbnRlbnRIZWlnaHQ6IG51bGwsXG4gICAgICAgICAgICBzZWdIZWlnaHRzOiB7fSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVSZXNpemUgPSAoaXNGb3JjZWQpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0ZvcmNlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU2l6aW5nKHRydWUpOyAvLyBpc0V4dGVybmFsPXRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgc3RhdGUsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgICAgIGxldCBjb2xDbnQgPSBwcm9wcy5jZWxscy5sZW5ndGg7XG4gICAgICAgIGxldCBidXNpbmVzc0hvdXJzQnlDb2wgPSBzcGxpdFNlZ3NCeUZpcnN0Q29sKHByb3BzLmJ1c2luZXNzSG91clNlZ3MsIGNvbENudCk7XG4gICAgICAgIGxldCBiZ0V2ZW50U2Vnc0J5Q29sID0gc3BsaXRTZWdzQnlGaXJzdENvbChwcm9wcy5iZ0V2ZW50U2VncywgY29sQ250KTtcbiAgICAgICAgbGV0IGhpZ2hsaWdodFNlZ3NCeUNvbCA9IHNwbGl0U2Vnc0J5Rmlyc3RDb2wodGhpcy5nZXRIaWdobGlnaHRTZWdzKCksIGNvbENudCk7XG4gICAgICAgIGxldCBtaXJyb3JTZWdzQnlDb2wgPSBzcGxpdFNlZ3NCeUZpcnN0Q29sKHRoaXMuZ2V0TWlycm9yU2VncygpLCBjb2xDbnQpO1xuICAgICAgICBsZXQgeyBzaW5nbGVDb2xQbGFjZW1lbnRzLCBtdWx0aUNvbFBsYWNlbWVudHMsIG1vcmVDbnRzLCBtb3JlTWFyZ2luVG9wcyB9ID0gY29tcHV0ZUZnU2VnUGxhY2VtZW50KHNvcnRFdmVudFNlZ3MocHJvcHMuZmdFdmVudFNlZ3MsIG9wdGlvbnMuZXZlbnRPcmRlciksIHByb3BzLmRheU1heEV2ZW50cywgcHJvcHMuZGF5TWF4RXZlbnRSb3dzLCBvcHRpb25zLmV2ZW50T3JkZXJTdHJpY3QsIHN0YXRlLnNlZ0hlaWdodHMsIHN0YXRlLm1heENvbnRlbnRIZWlnaHQsIHByb3BzLmNlbGxzKTtcbiAgICAgICAgbGV0IGlzRm9yY2VkSW52aXNpYmxlID0gLy8gVE9ETzogbWVzc3kgd2F5IHRvIGNvbXB1dGUgdGhpc1xuICAgICAgICAgKHByb3BzLmV2ZW50RHJhZyAmJiBwcm9wcy5ldmVudERyYWcuYWZmZWN0ZWRJbnN0YW5jZXMpIHx8XG4gICAgICAgICAgICAocHJvcHMuZXZlbnRSZXNpemUgJiYgcHJvcHMuZXZlbnRSZXNpemUuYWZmZWN0ZWRJbnN0YW5jZXMpIHx8XG4gICAgICAgICAgICB7fTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwidHJcIiwgeyByZWY6IHRoaXMucm9vdEVsUmVmLCByb2xlOiBcInJvd1wiIH0sXG4gICAgICAgICAgICBwcm9wcy5yZW5kZXJJbnRybyAmJiBwcm9wcy5yZW5kZXJJbnRybygpLFxuICAgICAgICAgICAgcHJvcHMuY2VsbHMubWFwKChjZWxsLCBjb2wpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgbm9ybWFsRmdOb2RlcyA9IHRoaXMucmVuZGVyRmdTZWdzKGNvbCwgcHJvcHMuZm9yUHJpbnQgPyBzaW5nbGVDb2xQbGFjZW1lbnRzW2NvbF0gOiBtdWx0aUNvbFBsYWNlbWVudHNbY29sXSwgcHJvcHMudG9kYXlSYW5nZSwgaXNGb3JjZWRJbnZpc2libGUpO1xuICAgICAgICAgICAgICAgIGxldCBtaXJyb3JGZ05vZGVzID0gdGhpcy5yZW5kZXJGZ1NlZ3MoY29sLCBidWlsZE1pcnJvclBsYWNlbWVudHMobWlycm9yU2Vnc0J5Q29sW2NvbF0sIG11bHRpQ29sUGxhY2VtZW50cyksIHByb3BzLnRvZGF5UmFuZ2UsIHt9LCBCb29sZWFuKHByb3BzLmV2ZW50RHJhZyksIEJvb2xlYW4ocHJvcHMuZXZlbnRSZXNpemUpLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFRhYmxlQ2VsbCwgeyBrZXk6IGNlbGwua2V5LCBlbFJlZjogdGhpcy5jZWxsRWxSZWZzLmNyZWF0ZVJlZihjZWxsLmtleSksIGlubmVyRWxSZWY6IHRoaXMuZnJhbWVFbFJlZnMuY3JlYXRlUmVmKGNlbGwua2V5KSAvKiBGRiA8dGQ+IHByb2JsZW0sIGJ1dCBva2F5IHRvIHVzZSBmb3IgbGVmdC9yaWdodC4gVE9ETzogcmVuYW1lIHByb3AgKi8sIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgZGF0ZTogY2VsbC5kYXRlLCBzaG93RGF5TnVtYmVyOiBwcm9wcy5zaG93RGF5TnVtYmVycywgc2hvd1dlZWtOdW1iZXI6IHByb3BzLnNob3dXZWVrTnVtYmVycyAmJiBjb2wgPT09IDAsIGZvcmNlRGF5VG9wOiBwcm9wcy5zaG93V2Vla051bWJlcnMgLyogZXZlbiBkaXNwbGF5aW5nIHdlZWtudW0gZm9yIHJvdywgbm90IG5lY2Vzc2FyaWx5IGRheSAqLywgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSwgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBldmVudERyYWc6IHByb3BzLmV2ZW50RHJhZywgZXZlbnRSZXNpemU6IHByb3BzLmV2ZW50UmVzaXplLCBleHRyYVJlbmRlclByb3BzOiBjZWxsLmV4dHJhUmVuZGVyUHJvcHMsIGV4dHJhRGF0YUF0dHJzOiBjZWxsLmV4dHJhRGF0YUF0dHJzLCBleHRyYUNsYXNzTmFtZXM6IGNlbGwuZXh0cmFDbGFzc05hbWVzLCBleHRyYURhdGVTcGFuOiBjZWxsLmV4dHJhRGF0ZVNwYW4sIG1vcmVDbnQ6IG1vcmVDbnRzW2NvbF0sIG1vcmVNYXJnaW5Ub3A6IG1vcmVNYXJnaW5Ub3BzW2NvbF0sIHNpbmdsZVBsYWNlbWVudHM6IHNpbmdsZUNvbFBsYWNlbWVudHNbY29sXSwgZmdDb250ZW50RWxSZWY6IHRoaXMuZmdFbFJlZnMuY3JlYXRlUmVmKGNlbGwua2V5KSwgZmdDb250ZW50OiAoIC8vIEZyYWdtZW50IHNjb3BlcyB0aGUga2V5c1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCwgbm9ybWFsRmdOb2RlcyksXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBtaXJyb3JGZ05vZGVzKSkpLCBiZ0NvbnRlbnQ6ICggLy8gRnJhZ21lbnQgc2NvcGVzIHRoZSBrZXlzXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckZpbGxTZWdzKGhpZ2hsaWdodFNlZ3NCeUNvbFtjb2xdLCAnaGlnaGxpZ2h0JyksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckZpbGxTZWdzKGJ1c2luZXNzSG91cnNCeUNvbFtjb2xdLCAnbm9uLWJ1c2luZXNzJyksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckZpbGxTZWdzKGJnRXZlbnRTZWdzQnlDb2xbY29sXSwgJ2JnLWV2ZW50JykpKSwgbWluSGVpZ2h0OiBwcm9wcy5jZWxsTWluSGVpZ2h0IH0pKTtcbiAgICAgICAgICAgIH0pKSk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVNpemluZyh0cnVlKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmFkZFJlc2l6ZUhhbmRsZXIodGhpcy5oYW5kbGVSZXNpemUpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUpIHtcbiAgICAgICAgbGV0IGN1cnJlbnRQcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHRoaXMudXBkYXRlU2l6aW5nKCFpc1Byb3BzRXF1YWwocHJldlByb3BzLCBjdXJyZW50UHJvcHMpKTtcbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5yZW1vdmVSZXNpemVIYW5kbGVyKHRoaXMuaGFuZGxlUmVzaXplKTtcbiAgICB9XG4gICAgZ2V0SGlnaGxpZ2h0U2VncygpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGlmIChwcm9wcy5ldmVudERyYWcgJiYgcHJvcHMuZXZlbnREcmFnLnNlZ3MubGVuZ3RoKSB7IC8vIG1lc3N5IGNoZWNrXG4gICAgICAgICAgICByZXR1cm4gcHJvcHMuZXZlbnREcmFnLnNlZ3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BzLmV2ZW50UmVzaXplICYmIHByb3BzLmV2ZW50UmVzaXplLnNlZ3MubGVuZ3RoKSB7IC8vIG1lc3N5IGNoZWNrXG4gICAgICAgICAgICByZXR1cm4gcHJvcHMuZXZlbnRSZXNpemUuc2VncztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvcHMuZGF0ZVNlbGVjdGlvblNlZ3M7XG4gICAgfVxuICAgIGdldE1pcnJvclNlZ3MoKSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBpZiAocHJvcHMuZXZlbnRSZXNpemUgJiYgcHJvcHMuZXZlbnRSZXNpemUuc2Vncy5sZW5ndGgpIHsgLy8gbWVzc3kgY2hlY2tcbiAgICAgICAgICAgIHJldHVybiBwcm9wcy5ldmVudFJlc2l6ZS5zZWdzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmVuZGVyRmdTZWdzKGNvbCwgc2VnUGxhY2VtZW50cywgdG9kYXlSYW5nZSwgaXNGb3JjZWRJbnZpc2libGUsIGlzRHJhZ2dpbmcsIGlzUmVzaXppbmcsIGlzRGF0ZVNlbGVjdGluZykge1xuICAgICAgICBsZXQgeyBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBldmVudFNlbGVjdGlvbiB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IHsgZnJhbWVQb3NpdGlvbnMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGxldCBkZWZhdWx0RGlzcGxheUV2ZW50RW5kID0gdGhpcy5wcm9wcy5jZWxscy5sZW5ndGggPT09IDE7IC8vIGNvbENudCA9PT0gMVxuICAgICAgICBsZXQgaXNNaXJyb3IgPSBpc0RyYWdnaW5nIHx8IGlzUmVzaXppbmcgfHwgaXNEYXRlU2VsZWN0aW5nO1xuICAgICAgICBsZXQgbm9kZXMgPSBbXTtcbiAgICAgICAgaWYgKGZyYW1lUG9zaXRpb25zKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBwbGFjZW1lbnQgb2Ygc2VnUGxhY2VtZW50cykge1xuICAgICAgICAgICAgICAgIGxldCB7IHNlZyB9ID0gcGxhY2VtZW50O1xuICAgICAgICAgICAgICAgIGxldCB7IGluc3RhbmNlSWQgfSA9IHNlZy5ldmVudFJhbmdlLmluc3RhbmNlO1xuICAgICAgICAgICAgICAgIGxldCBpc1Zpc2libGUgPSBwbGFjZW1lbnQuaXNWaXNpYmxlICYmICFpc0ZvcmNlZEludmlzaWJsZVtpbnN0YW5jZUlkXTtcbiAgICAgICAgICAgICAgICBsZXQgaXNBYnNvbHV0ZSA9IHBsYWNlbWVudC5pc0Fic29sdXRlO1xuICAgICAgICAgICAgICAgIGxldCBsZWZ0ID0gJyc7XG4gICAgICAgICAgICAgICAgbGV0IHJpZ2h0ID0gJyc7XG4gICAgICAgICAgICAgICAgaWYgKGlzQWJzb2x1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuaXNSdGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBmcmFtZVBvc2l0aW9ucy5sZWZ0c1tzZWcubGFzdENvbF0gLSBmcmFtZVBvc2l0aW9ucy5sZWZ0c1tzZWcuZmlyc3RDb2xdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IGZyYW1lUG9zaXRpb25zLnJpZ2h0c1tzZWcuZmlyc3RDb2xdIC0gZnJhbWVQb3NpdGlvbnMucmlnaHRzW3NlZy5sYXN0Q29sXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgIGtub3duIGJ1ZzogZXZlbnRzIHRoYXQgYXJlIGZvcmNlIHRvIGJlIGxpc3QtaXRlbSBidXQgc3BhbiBtdWx0aXBsZSBkYXlzIHN0aWxsIHRha2UgdXAgc3BhY2UgaW4gbGF0ZXIgY29sdW1uc1xuICAgICAgICAgICAgICAgIHRvZG86IGluIHByaW50IHZpZXcsIGZvciBtdWx0aS1kYXkgZXZlbnRzLCBkb24ndCBkaXNwbGF5IHRpdGxlIHdpdGhpbiBub24tc3RhcnQvZW5kIHNlZ3NcbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogJ2ZjLWRheWdyaWQtZXZlbnQtaGFybmVzcycgKyAoaXNBYnNvbHV0ZSA/ICcgZmMtZGF5Z3JpZC1ldmVudC1oYXJuZXNzLWFicycgOiAnJyksIGtleTogZ2VuZXJhdGVTZWdLZXkoc2VnKSwgcmVmOiBpc01pcnJvciA/IG51bGwgOiB0aGlzLnNlZ0hhcm5lc3NSZWZzLmNyZWF0ZVJlZihnZW5lcmF0ZVNlZ1VpZChzZWcpKSwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IGlzVmlzaWJsZSA/ICcnIDogJ2hpZGRlbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6IGlzQWJzb2x1dGUgPyAnJyA6IHBsYWNlbWVudC5tYXJnaW5Ub3AsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IGlzQWJzb2x1dGUgPyBwbGFjZW1lbnQuYWJzb2x1dGVUb3AgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCxcbiAgICAgICAgICAgICAgICAgICAgfSB9LCBoYXNMaXN0SXRlbURpc3BsYXkoc2VnKSA/IChjcmVhdGVFbGVtZW50KFRhYmxlTGlzdEl0ZW1FdmVudCwgT2JqZWN0LmFzc2lnbih7IHNlZzogc2VnLCBpc0RyYWdnaW5nOiBpc0RyYWdnaW5nLCBpc1NlbGVjdGVkOiBpbnN0YW5jZUlkID09PSBldmVudFNlbGVjdGlvbiwgZGVmYXVsdERpc3BsYXlFdmVudEVuZDogZGVmYXVsdERpc3BsYXlFdmVudEVuZCB9LCBnZXRTZWdNZXRhKHNlZywgdG9kYXlSYW5nZSkpKSkgOiAoY3JlYXRlRWxlbWVudChUYWJsZUJsb2NrRXZlbnQsIE9iamVjdC5hc3NpZ24oeyBzZWc6IHNlZywgaXNEcmFnZ2luZzogaXNEcmFnZ2luZywgaXNSZXNpemluZzogaXNSZXNpemluZywgaXNEYXRlU2VsZWN0aW5nOiBpc0RhdGVTZWxlY3RpbmcsIGlzU2VsZWN0ZWQ6IGluc3RhbmNlSWQgPT09IGV2ZW50U2VsZWN0aW9uLCBkZWZhdWx0RGlzcGxheUV2ZW50RW5kOiBkZWZhdWx0RGlzcGxheUV2ZW50RW5kIH0sIGdldFNlZ01ldGEoc2VnLCB0b2RheVJhbmdlKSkpKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG4gICAgcmVuZGVyRmlsbFNlZ3Moc2VncywgZmlsbFR5cGUpIHtcbiAgICAgICAgbGV0IHsgaXNSdGwgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHsgdG9kYXlSYW5nZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IHsgZnJhbWVQb3NpdGlvbnMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGxldCBub2RlcyA9IFtdO1xuICAgICAgICBpZiAoZnJhbWVQb3NpdGlvbnMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHNlZyBvZiBzZWdzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxlZnRSaWdodENzcyA9IGlzUnRsID8ge1xuICAgICAgICAgICAgICAgICAgICByaWdodDogMCxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogZnJhbWVQb3NpdGlvbnMubGVmdHNbc2VnLmxhc3RDb2xdIC0gZnJhbWVQb3NpdGlvbnMubGVmdHNbc2VnLmZpcnN0Q29sXSxcbiAgICAgICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgICAgICByaWdodDogZnJhbWVQb3NpdGlvbnMucmlnaHRzW3NlZy5maXJzdENvbF0gLSBmcmFtZVBvc2l0aW9ucy5yaWdodHNbc2VnLmxhc3RDb2xdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsga2V5OiBidWlsZEV2ZW50UmFuZ2VLZXkoc2VnLmV2ZW50UmFuZ2UpLCBjbGFzc05hbWU6IFwiZmMtZGF5Z3JpZC1iZy1oYXJuZXNzXCIsIHN0eWxlOiBsZWZ0UmlnaHRDc3MgfSwgZmlsbFR5cGUgPT09ICdiZy1ldmVudCcgP1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KEJnRXZlbnQsIE9iamVjdC5hc3NpZ24oeyBzZWc6IHNlZyB9LCBnZXRTZWdNZXRhKHNlZywgdG9kYXlSYW5nZSkpKSA6XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlckZpbGwoZmlsbFR5cGUpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIHt9LCAuLi5ub2Rlcyk7XG4gICAgfVxuICAgIHVwZGF0ZVNpemluZyhpc0V4dGVybmFsU2l6aW5nQ2hhbmdlKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBzdGF0ZSwgZnJhbWVFbFJlZnMgfSA9IHRoaXM7XG4gICAgICAgIGlmICghcHJvcHMuZm9yUHJpbnQgJiZcbiAgICAgICAgICAgIHByb3BzLmNsaWVudFdpZHRoICE9PSBudWxsIC8vIHBvc2l0aW9uaW5nIHJlYWR5P1xuICAgICAgICApIHtcbiAgICAgICAgICAgIGlmIChpc0V4dGVybmFsU2l6aW5nQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyYW1lRWxzID0gcHJvcHMuY2VsbHMubWFwKChjZWxsKSA9PiBmcmFtZUVsUmVmcy5jdXJyZW50TWFwW2NlbGwua2V5XSk7XG4gICAgICAgICAgICAgICAgaWYgKGZyYW1lRWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb3JpZ2luRWwgPSB0aGlzLnJvb3RFbFJlZi5jdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3UG9zaXRpb25DYWNoZSA9IG5ldyBQb3NpdGlvbkNhY2hlKG9yaWdpbkVsLCBmcmFtZUVscywgdHJ1ZSwgLy8gaXNIb3Jpem9udGFsXG4gICAgICAgICAgICAgICAgICAgIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5mcmFtZVBvc2l0aW9ucyB8fCAhc3RhdGUuZnJhbWVQb3NpdGlvbnMuc2ltaWxhclRvKG5ld1Bvc2l0aW9uQ2FjaGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZVBvc2l0aW9uczogbmV3IFBvc2l0aW9uQ2FjaGUob3JpZ2luRWwsIGZyYW1lRWxzLCB0cnVlLCAvLyBpc0hvcml6b250YWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9sZFNlZ0hlaWdodHMgPSB0aGlzLnN0YXRlLnNlZ0hlaWdodHM7XG4gICAgICAgICAgICBjb25zdCBuZXdTZWdIZWlnaHRzID0gdGhpcy5xdWVyeVNlZ0hlaWdodHMoKTtcbiAgICAgICAgICAgIGNvbnN0IGxpbWl0QnlDb250ZW50SGVpZ2h0ID0gcHJvcHMuZGF5TWF4RXZlbnRzID09PSB0cnVlIHx8IHByb3BzLmRheU1heEV2ZW50Um93cyA9PT0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc2FmZVNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAvLyBIQUNLIHRvIHByZXZlbnQgb3NjaWxsYXRpb25zIG9mIGV2ZW50cyBiZWluZyBzaG93bi9oaWRkZW4gZnJvbSBtYXgtZXZlbnQtcm93c1xuICAgICAgICAgICAgICAgIC8vIEVzc2VudGlhbGx5LCBvbmNlIHlvdSBjb21wdXRlIGFuIGVsZW1lbnQncyBoZWlnaHQsIG5ldmVyIG51bGwtb3V0LlxuICAgICAgICAgICAgICAgIC8vIFRPRE86IGFsd2F5cyBkaXNwbGF5IGFsbCBldmVudHMsIGFzIHZpc2liaWxpdHk6aGlkZGVuP1xuICAgICAgICAgICAgICAgIHNlZ0hlaWdodHM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb2xkU2VnSGVpZ2h0cyksIG5ld1NlZ0hlaWdodHMpLFxuICAgICAgICAgICAgICAgIG1heENvbnRlbnRIZWlnaHQ6IGxpbWl0QnlDb250ZW50SGVpZ2h0ID8gdGhpcy5jb21wdXRlTWF4Q29udGVudEhlaWdodCgpIDogbnVsbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXJ5U2VnSGVpZ2h0cygpIHtcbiAgICAgICAgbGV0IHNlZ0VsTWFwID0gdGhpcy5zZWdIYXJuZXNzUmVmcy5jdXJyZW50TWFwO1xuICAgICAgICBsZXQgc2VnSGVpZ2h0cyA9IHt9O1xuICAgICAgICAvLyBnZXQgdGhlIG1heCBoZWlnaHQgYW1vbmdzdCBpbnN0YW5jZSBzZWdzXG4gICAgICAgIGZvciAobGV0IHNlZ1VpZCBpbiBzZWdFbE1hcCkge1xuICAgICAgICAgICAgbGV0IGhlaWdodCA9IE1hdGgucm91bmQoc2VnRWxNYXBbc2VnVWlkXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQpO1xuICAgICAgICAgICAgc2VnSGVpZ2h0c1tzZWdVaWRdID0gTWF0aC5tYXgoc2VnSGVpZ2h0c1tzZWdVaWRdIHx8IDAsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlZ0hlaWdodHM7XG4gICAgfVxuICAgIGNvbXB1dGVNYXhDb250ZW50SGVpZ2h0KCkge1xuICAgICAgICBsZXQgZmlyc3RLZXkgPSB0aGlzLnByb3BzLmNlbGxzWzBdLmtleTtcbiAgICAgICAgbGV0IGNlbGxFbCA9IHRoaXMuY2VsbEVsUmVmcy5jdXJyZW50TWFwW2ZpcnN0S2V5XTtcbiAgICAgICAgbGV0IGZjQ29udGFpbmVyRWwgPSB0aGlzLmZnRWxSZWZzLmN1cnJlbnRNYXBbZmlyc3RLZXldO1xuICAgICAgICByZXR1cm4gY2VsbEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbSAtIGZjQ29udGFpbmVyRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xuICAgIH1cbiAgICBnZXRDZWxsRWxzKCkge1xuICAgICAgICBsZXQgZWxNYXAgPSB0aGlzLmNlbGxFbFJlZnMuY3VycmVudE1hcDtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY2VsbHMubWFwKChjZWxsKSA9PiBlbE1hcFtjZWxsLmtleV0pO1xuICAgIH1cbn1cblRhYmxlUm93LmFkZFN0YXRlRXF1YWxpdHkoe1xuICAgIHNlZ0hlaWdodHM6IGlzUHJvcHNFcXVhbCxcbn0pO1xuZnVuY3Rpb24gYnVpbGRNaXJyb3JQbGFjZW1lbnRzKG1pcnJvclNlZ3MsIGNvbFBsYWNlbWVudHMpIHtcbiAgICBpZiAoIW1pcnJvclNlZ3MubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgbGV0IHRvcHNCeUluc3RhbmNlSWQgPSBidWlsZEFic29sdXRlVG9wSGFzaChjb2xQbGFjZW1lbnRzKTsgLy8gVE9ETzogY2FjaGUgdGhpcyBhdCBmaXJzdCByZW5kZXI/XG4gICAgcmV0dXJuIG1pcnJvclNlZ3MubWFwKChzZWcpID0+ICh7XG4gICAgICAgIHNlZyxcbiAgICAgICAgaXNWaXNpYmxlOiB0cnVlLFxuICAgICAgICBpc0Fic29sdXRlOiB0cnVlLFxuICAgICAgICBhYnNvbHV0ZVRvcDogdG9wc0J5SW5zdGFuY2VJZFtzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkXSxcbiAgICAgICAgbWFyZ2luVG9wOiAwLFxuICAgIH0pKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkQWJzb2x1dGVUb3BIYXNoKGNvbFBsYWNlbWVudHMpIHtcbiAgICBsZXQgdG9wc0J5SW5zdGFuY2VJZCA9IHt9O1xuICAgIGZvciAobGV0IHBsYWNlbWVudHMgb2YgY29sUGxhY2VtZW50cykge1xuICAgICAgICBmb3IgKGxldCBwbGFjZW1lbnQgb2YgcGxhY2VtZW50cykge1xuICAgICAgICAgICAgdG9wc0J5SW5zdGFuY2VJZFtwbGFjZW1lbnQuc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZF0gPSBwbGFjZW1lbnQuYWJzb2x1dGVUb3A7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvcHNCeUluc3RhbmNlSWQ7XG59XG5cbmNsYXNzIFRhYmxlUm93cyBleHRlbmRzIERhdGVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnNwbGl0QnVzaW5lc3NIb3VyU2VncyA9IG1lbW9pemUoc3BsaXRTZWdzQnlSb3cpO1xuICAgICAgICB0aGlzLnNwbGl0QmdFdmVudFNlZ3MgPSBtZW1vaXplKHNwbGl0U2Vnc0J5Um93KTtcbiAgICAgICAgdGhpcy5zcGxpdEZnRXZlbnRTZWdzID0gbWVtb2l6ZShzcGxpdFNlZ3NCeVJvdyk7XG4gICAgICAgIHRoaXMuc3BsaXREYXRlU2VsZWN0aW9uU2VncyA9IG1lbW9pemUoc3BsaXRTZWdzQnlSb3cpO1xuICAgICAgICB0aGlzLnNwbGl0RXZlbnREcmFnID0gbWVtb2l6ZShzcGxpdEludGVyYWN0aW9uQnlSb3cpO1xuICAgICAgICB0aGlzLnNwbGl0RXZlbnRSZXNpemUgPSBtZW1vaXplKHNwbGl0SW50ZXJhY3Rpb25CeVJvdyk7XG4gICAgICAgIHRoaXMucm93UmVmcyA9IG5ldyBSZWZNYXAoKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHJvd0NudCA9IHByb3BzLmNlbGxzLmxlbmd0aDtcbiAgICAgICAgbGV0IGJ1c2luZXNzSG91clNlZ3NCeVJvdyA9IHRoaXMuc3BsaXRCdXNpbmVzc0hvdXJTZWdzKHByb3BzLmJ1c2luZXNzSG91clNlZ3MsIHJvd0NudCk7XG4gICAgICAgIGxldCBiZ0V2ZW50U2Vnc0J5Um93ID0gdGhpcy5zcGxpdEJnRXZlbnRTZWdzKHByb3BzLmJnRXZlbnRTZWdzLCByb3dDbnQpO1xuICAgICAgICBsZXQgZmdFdmVudFNlZ3NCeVJvdyA9IHRoaXMuc3BsaXRGZ0V2ZW50U2Vncyhwcm9wcy5mZ0V2ZW50U2Vncywgcm93Q250KTtcbiAgICAgICAgbGV0IGRhdGVTZWxlY3Rpb25TZWdzQnlSb3cgPSB0aGlzLnNwbGl0RGF0ZVNlbGVjdGlvblNlZ3MocHJvcHMuZGF0ZVNlbGVjdGlvblNlZ3MsIHJvd0NudCk7XG4gICAgICAgIGxldCBldmVudERyYWdCeVJvdyA9IHRoaXMuc3BsaXRFdmVudERyYWcocHJvcHMuZXZlbnREcmFnLCByb3dDbnQpO1xuICAgICAgICBsZXQgZXZlbnRSZXNpemVCeVJvdyA9IHRoaXMuc3BsaXRFdmVudFJlc2l6ZShwcm9wcy5ldmVudFJlc2l6ZSwgcm93Q250KTtcbiAgICAgICAgLy8gZm9yIERheUdyaWQgdmlldyB3aXRoIG1hbnkgcm93cywgZm9yY2UgYSBtaW4taGVpZ2h0IG9uIGNlbGxzIHNvIGRvZXNuJ3QgYXBwZWFyIHNxdWlzaGVkXG4gICAgICAgIC8vIGNob29zZSA3IGJlY2F1c2UgYSBtb250aCB2aWV3IHdpbGwgaGF2ZSBtYXggNiByb3dzXG4gICAgICAgIGxldCBjZWxsTWluSGVpZ2h0ID0gKHJvd0NudCA+PSA3ICYmIHByb3BzLmNsaWVudFdpZHRoKSA/XG4gICAgICAgICAgICBwcm9wcy5jbGllbnRXaWR0aCAvIGNvbnRleHQub3B0aW9ucy5hc3BlY3RSYXRpbyAvIDYgOlxuICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KE5vd1RpbWVyLCB7IHVuaXQ6IFwiZGF5XCIgfSwgKG5vd0RhdGUsIHRvZGF5UmFuZ2UpID0+IChjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBwcm9wcy5jZWxscy5tYXAoKGNlbGxzLCByb3cpID0+IChjcmVhdGVFbGVtZW50KFRhYmxlUm93LCB7IHJlZjogdGhpcy5yb3dSZWZzLmNyZWF0ZVJlZihyb3cpLCBrZXk6IGNlbGxzLmxlbmd0aFxuICAgICAgICAgICAgICAgID8gY2VsbHNbMF0uZGF0ZS50b0lTT1N0cmluZygpIC8qIGJlc3Q/IG9yIHB1dCBrZXkgb24gY2VsbD8gb3IgdXNlIGRpZmYgZm9ybWF0dGVyPyAqL1xuICAgICAgICAgICAgICAgIDogcm93IC8vIGluIGNhc2UgdGhlcmUgYXJlIG5vIGNlbGxzIChsaWtlIHdoZW4gcmVzb3VyY2UgdmlldyBpcyBsb2FkaW5nKVxuICAgICAgICAgICAgLCBzaG93RGF5TnVtYmVyczogcm93Q250ID4gMSwgc2hvd1dlZWtOdW1iZXJzOiBwcm9wcy5zaG93V2Vla051bWJlcnMsIHRvZGF5UmFuZ2U6IHRvZGF5UmFuZ2UsIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgY2VsbHM6IGNlbGxzLCByZW5kZXJJbnRybzogcHJvcHMucmVuZGVyUm93SW50cm8sIGJ1c2luZXNzSG91clNlZ3M6IGJ1c2luZXNzSG91clNlZ3NCeVJvd1tyb3ddLCBldmVudFNlbGVjdGlvbjogcHJvcHMuZXZlbnRTZWxlY3Rpb24sIGJnRXZlbnRTZWdzOiBiZ0V2ZW50U2Vnc0J5Um93W3Jvd10uZmlsdGVyKGlzU2VnQWxsRGF5KSAvKiBoYWNrICovLCBmZ0V2ZW50U2VnczogZmdFdmVudFNlZ3NCeVJvd1tyb3ddLCBkYXRlU2VsZWN0aW9uU2VnczogZGF0ZVNlbGVjdGlvblNlZ3NCeVJvd1tyb3ddLCBldmVudERyYWc6IGV2ZW50RHJhZ0J5Um93W3Jvd10sIGV2ZW50UmVzaXplOiBldmVudFJlc2l6ZUJ5Um93W3Jvd10sIGRheU1heEV2ZW50czogcHJvcHMuZGF5TWF4RXZlbnRzLCBkYXlNYXhFdmVudFJvd3M6IHByb3BzLmRheU1heEV2ZW50Um93cywgY2xpZW50V2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQ6IHByb3BzLmNsaWVudEhlaWdodCwgY2VsbE1pbkhlaWdodDogY2VsbE1pbkhlaWdodCwgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50IH0pKSkpKSkpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KCk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgLy8gZm9yIGlmIHN0YXJ0ZWQgd2l0aCB6ZXJvIGNlbGxzXG4gICAgICAgIHRoaXMucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCgpO1xuICAgIH1cbiAgICByZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMucm9vdEVsKSB7XG4gICAgICAgICAgICAvLyBIQUNLOiBuZWVkIGEgZGF5Z3JpZCB3cmFwcGVyIHBhcmVudCB0byBkbyBwb3NpdGlvbmluZ1xuICAgICAgICAgICAgLy8gTk9URTogYSBkYXlncmlkIHJlc291cmNlIHZpZXcgdy9vIHJlc291cmNlcyBjYW4gaGF2ZSB6ZXJvIGNlbGxzXG4gICAgICAgICAgICBjb25zdCBmaXJzdENlbGxFbCA9IHRoaXMucm93UmVmcy5jdXJyZW50TWFwWzBdLmdldENlbGxFbHMoKVswXTtcbiAgICAgICAgICAgIGNvbnN0IHJvb3RFbCA9IGZpcnN0Q2VsbEVsID8gZmlyc3RDZWxsRWwuY2xvc2VzdCgnLmZjLWRheWdyaWQtYm9keScpIDogbnVsbDtcbiAgICAgICAgICAgIGlmIChyb290RWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3RFbCA9IHJvb3RFbDtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCh0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgIGVsOiByb290RWwsXG4gICAgICAgICAgICAgICAgICAgIGlzSGl0Q29tYm9BbGxvd2VkOiB0aGlzLnByb3BzLmlzSGl0Q29tYm9BbGxvd2VkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICBpZiAodGhpcy5yb290RWwpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC51bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnJvb3RFbCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSGl0IFN5c3RlbVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBwcmVwYXJlSGl0cygpIHtcbiAgICAgICAgdGhpcy5yb3dQb3NpdGlvbnMgPSBuZXcgUG9zaXRpb25DYWNoZSh0aGlzLnJvb3RFbCwgdGhpcy5yb3dSZWZzLmNvbGxlY3QoKS5tYXAoKHJvd09iaikgPT4gcm93T2JqLmdldENlbGxFbHMoKVswXSksIC8vIGZpcnN0IGNlbGwgZWwgaW4gZWFjaCByb3cuIFRPRE86IG5vdCBvcHRpbWFsXG4gICAgICAgIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgdGhpcy5jb2xQb3NpdGlvbnMgPSBuZXcgUG9zaXRpb25DYWNoZSh0aGlzLnJvb3RFbCwgdGhpcy5yb3dSZWZzLmN1cnJlbnRNYXBbMF0uZ2V0Q2VsbEVscygpLCAvLyBjZWxsIGVscyBpbiBmaXJzdCByb3dcbiAgICAgICAgdHJ1ZSwgLy8gaG9yaXpvbnRhbFxuICAgICAgICBmYWxzZSk7XG4gICAgfVxuICAgIHF1ZXJ5SGl0KHBvc2l0aW9uTGVmdCwgcG9zaXRpb25Ub3ApIHtcbiAgICAgICAgbGV0IHsgY29sUG9zaXRpb25zLCByb3dQb3NpdGlvbnMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBjb2wgPSBjb2xQb3NpdGlvbnMubGVmdFRvSW5kZXgocG9zaXRpb25MZWZ0KTtcbiAgICAgICAgbGV0IHJvdyA9IHJvd1Bvc2l0aW9ucy50b3BUb0luZGV4KHBvc2l0aW9uVG9wKTtcbiAgICAgICAgaWYgKHJvdyAhPSBudWxsICYmIGNvbCAhPSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgY2VsbCA9IHRoaXMucHJvcHMuY2VsbHNbcm93XVtjb2xdO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRlUHJvZmlsZTogdGhpcy5wcm9wcy5kYXRlUHJvZmlsZSxcbiAgICAgICAgICAgICAgICBkYXRlU3BhbjogT2JqZWN0LmFzc2lnbih7IHJhbmdlOiB0aGlzLmdldENlbGxSYW5nZShyb3csIGNvbCksIGFsbERheTogdHJ1ZSB9LCBjZWxsLmV4dHJhRGF0ZVNwYW4pLFxuICAgICAgICAgICAgICAgIGRheUVsOiB0aGlzLmdldENlbGxFbChyb3csIGNvbCksXG4gICAgICAgICAgICAgICAgcmVjdDoge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBjb2xQb3NpdGlvbnMubGVmdHNbY29sXSxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGNvbFBvc2l0aW9ucy5yaWdodHNbY29sXSxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiByb3dQb3NpdGlvbnMudG9wc1tyb3ddLFxuICAgICAgICAgICAgICAgICAgICBib3R0b206IHJvd1Bvc2l0aW9ucy5ib3R0b21zW3Jvd10sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBsYXllcjogMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldENlbGxFbChyb3csIGNvbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3dSZWZzLmN1cnJlbnRNYXBbcm93XS5nZXRDZWxsRWxzKClbY29sXTsgLy8gVE9ETzogbm90IG9wdGltYWxcbiAgICB9XG4gICAgZ2V0Q2VsbFJhbmdlKHJvdywgY29sKSB7XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMucHJvcHMuY2VsbHNbcm93XVtjb2xdLmRhdGU7XG4gICAgICAgIGxldCBlbmQgPSBhZGREYXlzKHN0YXJ0LCAxKTtcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQsIGVuZCB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzU2VnQWxsRGF5KHNlZykge1xuICAgIHJldHVybiBzZWcuZXZlbnRSYW5nZS5kZWYuYWxsRGF5O1xufVxuXG5jbGFzcyBUYWJsZSBleHRlbmRzIERhdGVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmVsUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIHRoaXMubmVlZHNTY3JvbGxSZXNldCA9IGZhbHNlO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBkYXlNYXhFdmVudFJvd3MsIGRheU1heEV2ZW50cywgZXhwYW5kUm93cyB9ID0gcHJvcHM7XG4gICAgICAgIGxldCBsaW1pdFZpYUJhbGFuY2VkID0gZGF5TWF4RXZlbnRzID09PSB0cnVlIHx8IGRheU1heEV2ZW50Um93cyA9PT0gdHJ1ZTtcbiAgICAgICAgLy8gaWYgcm93cyBjYW4ndCBleHBhbmQgdG8gZmlsbCBmaXhlZCBoZWlnaHQsIGNhbid0IGRvIGJhbGFuY2VkLWhlaWdodCBldmVudCBsaW1pdFxuICAgICAgICAvLyBUT0RPOiBiZXN0IHBsYWNlIHRvIG5vcm1hbGl6ZSB0aGVzZSBvcHRpb25zP1xuICAgICAgICBpZiAobGltaXRWaWFCYWxhbmNlZCAmJiAhZXhwYW5kUm93cykge1xuICAgICAgICAgICAgbGltaXRWaWFCYWxhbmNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZGF5TWF4RXZlbnRSb3dzID0gbnVsbDtcbiAgICAgICAgICAgIGRheU1heEV2ZW50cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNsYXNzTmFtZXMgPSBbXG4gICAgICAgICAgICAnZmMtZGF5Z3JpZC1ib2R5JyxcbiAgICAgICAgICAgIGxpbWl0VmlhQmFsYW5jZWQgPyAnZmMtZGF5Z3JpZC1ib2R5LWJhbGFuY2VkJyA6ICdmYy1kYXlncmlkLWJvZHktdW5iYWxhbmNlZCcsXG4gICAgICAgICAgICBleHBhbmRSb3dzID8gJycgOiAnZmMtZGF5Z3JpZC1ib2R5LW5hdHVyYWwnLCAvLyB3aWxsIGhlaWdodCBvZiBvbmUgcm93IGRlcGVuZCBvbiB0aGUgb3RoZXJzP1xuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IHRoaXMuZWxSZWYsIGNsYXNzTmFtZTogY2xhc3NOYW1lcy5qb2luKCcgJyksIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgLy8gdGhlc2UgcHJvcHMgYXJlIGltcG9ydGFudCB0byBnaXZlIHRoaXMgd3JhcHBlciBjb3JyZWN0IGRpbWVuc2lvbnMgZm9yIGludGVyYWN0aW9uc1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGlmIHdlIHNldCBpdCBoZXJlLCBjYW4gd2UgYXZvaWQgZ2l2aW5nIHRvIGlubmVyIHRhYmxlcz9cbiAgICAgICAgICAgICAgICB3aWR0aDogcHJvcHMuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICAgICAgbWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsXG4gICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwidGFibGVcIiwgeyByb2xlOiBcInByZXNlbnRhdGlvblwiLCBjbGFzc05hbWU6IFwiZmMtc2Nyb2xsZ3JpZC1zeW5jLXRhYmxlXCIsIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgbWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogZXhwYW5kUm93cyA/IHByb3BzLmNsaWVudEhlaWdodCA6ICcnLFxuICAgICAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgICAgICBwcm9wcy5jb2xHcm91cE5vZGUsXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRib2R5XCIsIHsgcm9sZTogXCJwcmVzZW50YXRpb25cIiB9LFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFRhYmxlUm93cywgeyBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIGNlbGxzOiBwcm9wcy5jZWxscywgcmVuZGVyUm93SW50cm86IHByb3BzLnJlbmRlclJvd0ludHJvLCBzaG93V2Vla051bWJlcnM6IHByb3BzLnNob3dXZWVrTnVtYmVycywgY2xpZW50V2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQ6IHByb3BzLmNsaWVudEhlaWdodCwgYnVzaW5lc3NIb3VyU2VnczogcHJvcHMuYnVzaW5lc3NIb3VyU2VncywgYmdFdmVudFNlZ3M6IHByb3BzLmJnRXZlbnRTZWdzLCBmZ0V2ZW50U2VnczogcHJvcHMuZmdFdmVudFNlZ3MsIGRhdGVTZWxlY3Rpb25TZWdzOiBwcm9wcy5kYXRlU2VsZWN0aW9uU2VncywgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBldmVudERyYWc6IHByb3BzLmV2ZW50RHJhZywgZXZlbnRSZXNpemU6IHByb3BzLmV2ZW50UmVzaXplLCBkYXlNYXhFdmVudHM6IGRheU1heEV2ZW50cywgZGF5TWF4RXZlbnRSb3dzOiBkYXlNYXhFdmVudFJvd3MsIGZvclByaW50OiBwcm9wcy5mb3JQcmludCwgaXNIaXRDb21ib0FsbG93ZWQ6IHByb3BzLmlzSGl0Q29tYm9BbGxvd2VkIH0pKSkpKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdFNjcm9sbFJlc2V0KCk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgICAgaWYgKHByZXZQcm9wcy5kYXRlUHJvZmlsZSAhPT0gdGhpcy5wcm9wcy5kYXRlUHJvZmlsZSkge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0U2Nyb2xsUmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hTY3JvbGxSZXNldCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcXVlc3RTY3JvbGxSZXNldCgpIHtcbiAgICAgICAgdGhpcy5uZWVkc1Njcm9sbFJlc2V0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5mbHVzaFNjcm9sbFJlc2V0KCk7XG4gICAgfVxuICAgIGZsdXNoU2Nyb2xsUmVzZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLm5lZWRzU2Nyb2xsUmVzZXQgJiZcbiAgICAgICAgICAgIHRoaXMucHJvcHMuY2xpZW50V2lkdGggLy8gc2l6ZXMgY29tcHV0ZWQ/XG4gICAgICAgICkge1xuICAgICAgICAgICAgY29uc3Qgc3ViamVjdEVsID0gZ2V0U2Nyb2xsU3ViamVjdEVsKHRoaXMuZWxSZWYuY3VycmVudCwgdGhpcy5wcm9wcy5kYXRlUHJvZmlsZSk7XG4gICAgICAgICAgICBpZiAoc3ViamVjdEVsKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luRWwgPSBzdWJqZWN0RWwuY2xvc2VzdCgnLmZjLWRheWdyaWQtYm9keScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjcm9sbEVsID0gb3JpZ2luRWwuY2xvc2VzdCgnLmZjLXNjcm9sbGVyJyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2Nyb2xsVG9wID0gc3ViamVjdEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCAtXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbkVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcbiAgICAgICAgICAgICAgICBzY3JvbGxFbC5zY3JvbGxUb3AgPSBzY3JvbGxUb3AgPyAoc2Nyb2xsVG9wICsgMSkgOiAwOyAvLyBvdmVyY29tZSBib3JkZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubmVlZHNTY3JvbGxSZXNldCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0U2Nyb2xsU3ViamVjdEVsKGNvbnRhaW5lckVsLCBkYXRlUHJvZmlsZSkge1xuICAgIGxldCBlbDtcbiAgICBpZiAoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdC5tYXRjaCgveWVhcnxtb250aC8pKSB7XG4gICAgICAgIGVsID0gY29udGFpbmVyRWwucXVlcnlTZWxlY3RvcihgW2RhdGEtZGF0ZT1cIiR7Zm9ybWF0SXNvTW9udGhTdHIoZGF0ZVByb2ZpbGUuY3VycmVudERhdGUpfS0wMVwiXWApO1xuICAgICAgICAvLyBldmVuIGlmIHZpZXcgaXMgbW9udGgtYmFzZWQsIGZpcnN0LW9mLW1vbnRoIG1pZ2h0IGJlIGhpZGRlbi4uLlxuICAgIH1cbiAgICBpZiAoIWVsKSB7XG4gICAgICAgIGVsID0gY29udGFpbmVyRWwucXVlcnlTZWxlY3RvcihgW2RhdGEtZGF0ZT1cIiR7Zm9ybWF0RGF5U3RyaW5nKGRhdGVQcm9maWxlLmN1cnJlbnREYXRlKX1cIl1gKTtcbiAgICAgICAgLy8gY291bGQgc3RpbGwgYmUgaGlkZGVuIGlmIGFuIGludGVyaW9yLXZpZXcgaGlkZGVuIGRheVxuICAgIH1cbiAgICByZXR1cm4gZWw7XG59XG5cbmNsYXNzIERheVRhYmxlU2xpY2VyIGV4dGVuZHMgU2xpY2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5mb3JjZURheUlmTGlzdEl0ZW0gPSB0cnVlO1xuICAgIH1cbiAgICBzbGljZVJhbmdlKGRhdGVSYW5nZSwgZGF5VGFibGVNb2RlbCkge1xuICAgICAgICByZXR1cm4gZGF5VGFibGVNb2RlbC5zbGljZVJhbmdlKGRhdGVSYW5nZSk7XG4gICAgfVxufVxuXG5jbGFzcyBEYXlUYWJsZSBleHRlbmRzIERhdGVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnNsaWNlciA9IG5ldyBEYXlUYWJsZVNsaWNlcigpO1xuICAgICAgICB0aGlzLnRhYmxlUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChUYWJsZSwgT2JqZWN0LmFzc2lnbih7IHJlZjogdGhpcy50YWJsZVJlZiB9LCB0aGlzLnNsaWNlci5zbGljZVByb3BzKHByb3BzLCBwcm9wcy5kYXRlUHJvZmlsZSwgcHJvcHMubmV4dERheVRocmVzaG9sZCwgY29udGV4dCwgcHJvcHMuZGF5VGFibGVNb2RlbCksIHsgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCBjZWxsczogcHJvcHMuZGF5VGFibGVNb2RlbC5jZWxscywgY29sR3JvdXBOb2RlOiBwcm9wcy5jb2xHcm91cE5vZGUsIHRhYmxlTWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsIHJlbmRlclJvd0ludHJvOiBwcm9wcy5yZW5kZXJSb3dJbnRybywgZGF5TWF4RXZlbnRzOiBwcm9wcy5kYXlNYXhFdmVudHMsIGRheU1heEV2ZW50Um93czogcHJvcHMuZGF5TWF4RXZlbnRSb3dzLCBzaG93V2Vla051bWJlcnM6IHByb3BzLnNob3dXZWVrTnVtYmVycywgZXhwYW5kUm93czogcHJvcHMuZXhwYW5kUm93cywgaGVhZGVyQWxpZ25FbFJlZjogcHJvcHMuaGVhZGVyQWxpZ25FbFJlZiwgY2xpZW50V2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQ6IHByb3BzLmNsaWVudEhlaWdodCwgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50IH0pKSk7XG4gICAgfVxufVxuXG5jbGFzcyBEYXlUYWJsZVZpZXcgZXh0ZW5kcyBUYWJsZVZpZXcge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmJ1aWxkRGF5VGFibGVNb2RlbCA9IG1lbW9pemUoYnVpbGREYXlUYWJsZU1vZGVsKTtcbiAgICAgICAgdGhpcy5oZWFkZXJSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICAgICAgdGhpcy50YWJsZVJlZiA9IGNyZWF0ZVJlZigpO1xuICAgICAgICAvLyBjYW4ndCBvdmVycmlkZSBhbnkgbGlmZWN5Y2xlIG1ldGhvZHMgZnJvbSBwYXJlbnRcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBvcHRpb25zLCBkYXRlUHJvZmlsZUdlbmVyYXRvciB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGRheVRhYmxlTW9kZWwgPSB0aGlzLmJ1aWxkRGF5VGFibGVNb2RlbChwcm9wcy5kYXRlUHJvZmlsZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IpO1xuICAgICAgICBsZXQgaGVhZGVyQ29udGVudCA9IG9wdGlvbnMuZGF5SGVhZGVycyAmJiAoY3JlYXRlRWxlbWVudChEYXlIZWFkZXIsIHsgcmVmOiB0aGlzLmhlYWRlclJlZiwgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCBkYXRlczogZGF5VGFibGVNb2RlbC5oZWFkZXJEYXRlcywgZGF0ZXNSZXBEaXN0aW5jdERheXM6IGRheVRhYmxlTW9kZWwucm93Q250ID09PSAxIH0pKTtcbiAgICAgICAgbGV0IGJvZHlDb250ZW50ID0gKGNvbnRlbnRBcmcpID0+IChjcmVhdGVFbGVtZW50KERheVRhYmxlLCB7IHJlZjogdGhpcy50YWJsZVJlZiwgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCBkYXlUYWJsZU1vZGVsOiBkYXlUYWJsZU1vZGVsLCBidXNpbmVzc0hvdXJzOiBwcm9wcy5idXNpbmVzc0hvdXJzLCBkYXRlU2VsZWN0aW9uOiBwcm9wcy5kYXRlU2VsZWN0aW9uLCBldmVudFN0b3JlOiBwcm9wcy5ldmVudFN0b3JlLCBldmVudFVpQmFzZXM6IHByb3BzLmV2ZW50VWlCYXNlcywgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBldmVudERyYWc6IHByb3BzLmV2ZW50RHJhZywgZXZlbnRSZXNpemU6IHByb3BzLmV2ZW50UmVzaXplLCBuZXh0RGF5VGhyZXNob2xkOiBvcHRpb25zLm5leHREYXlUaHJlc2hvbGQsIGNvbEdyb3VwTm9kZTogY29udGVudEFyZy50YWJsZUNvbEdyb3VwTm9kZSwgdGFibGVNaW5XaWR0aDogY29udGVudEFyZy50YWJsZU1pbldpZHRoLCBkYXlNYXhFdmVudHM6IG9wdGlvbnMuZGF5TWF4RXZlbnRzLCBkYXlNYXhFdmVudFJvd3M6IG9wdGlvbnMuZGF5TWF4RXZlbnRSb3dzLCBzaG93V2Vla051bWJlcnM6IG9wdGlvbnMud2Vla051bWJlcnMsIGV4cGFuZFJvd3M6ICFwcm9wcy5pc0hlaWdodEF1dG8sIGhlYWRlckFsaWduRWxSZWY6IHRoaXMuaGVhZGVyRWxSZWYsIGNsaWVudFdpZHRoOiBjb250ZW50QXJnLmNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQ6IGNvbnRlbnRBcmcuY2xpZW50SGVpZ2h0LCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQgfSkpO1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5kYXlNaW5XaWR0aFxuICAgICAgICAgICAgPyB0aGlzLnJlbmRlckhTY3JvbGxMYXlvdXQoaGVhZGVyQ29udGVudCwgYm9keUNvbnRlbnQsIGRheVRhYmxlTW9kZWwuY29sQ250LCBvcHRpb25zLmRheU1pbldpZHRoKVxuICAgICAgICAgICAgOiB0aGlzLnJlbmRlclNpbXBsZUxheW91dChoZWFkZXJDb250ZW50LCBib2R5Q29udGVudCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYnVpbGREYXlUYWJsZU1vZGVsKGRhdGVQcm9maWxlLCBkYXRlUHJvZmlsZUdlbmVyYXRvcikge1xuICAgIGxldCBkYXlTZXJpZXMgPSBuZXcgRGF5U2VyaWVzTW9kZWwoZGF0ZVByb2ZpbGUucmVuZGVyUmFuZ2UsIGRhdGVQcm9maWxlR2VuZXJhdG9yKTtcbiAgICByZXR1cm4gbmV3IERheVRhYmxlTW9kZWwoZGF5U2VyaWVzLCAveWVhcnxtb250aHx3ZWVrLy50ZXN0KGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZVVuaXQpKTtcbn1cblxuY2xhc3MgVGFibGVEYXRlUHJvZmlsZUdlbmVyYXRvciBleHRlbmRzIERhdGVQcm9maWxlR2VuZXJhdG9yIHtcbiAgICAvLyBDb21wdXRlcyB0aGUgZGF0ZSByYW5nZSB0aGF0IHdpbGwgYmUgcmVuZGVyZWRcbiAgICBidWlsZFJlbmRlclJhbmdlKGN1cnJlbnRSYW5nZSwgY3VycmVudFJhbmdlVW5pdCwgaXNSYW5nZUFsbERheSkge1xuICAgICAgICBsZXQgcmVuZGVyUmFuZ2UgPSBzdXBlci5idWlsZFJlbmRlclJhbmdlKGN1cnJlbnRSYW5nZSwgY3VycmVudFJhbmdlVW5pdCwgaXNSYW5nZUFsbERheSk7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gYnVpbGREYXlUYWJsZVJlbmRlclJhbmdlKHtcbiAgICAgICAgICAgIGN1cnJlbnRSYW5nZTogcmVuZGVyUmFuZ2UsXG4gICAgICAgICAgICBzbmFwVG9XZWVrOiAvXih5ZWFyfG1vbnRoKSQvLnRlc3QoY3VycmVudFJhbmdlVW5pdCksXG4gICAgICAgICAgICBmaXhlZFdlZWtDb3VudDogcHJvcHMuZml4ZWRXZWVrQ291bnQsXG4gICAgICAgICAgICBkYXRlRW52OiBwcm9wcy5kYXRlRW52LFxuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBidWlsZERheVRhYmxlUmVuZGVyUmFuZ2UocHJvcHMpIHtcbiAgICBsZXQgeyBkYXRlRW52LCBjdXJyZW50UmFuZ2UgfSA9IHByb3BzO1xuICAgIGxldCB7IHN0YXJ0LCBlbmQgfSA9IGN1cnJlbnRSYW5nZTtcbiAgICBsZXQgZW5kT2ZXZWVrO1xuICAgIC8vIHllYXIgYW5kIG1vbnRoIHZpZXdzIHNob3VsZCBiZSBhbGlnbmVkIHdpdGggd2Vla3MuIHRoaXMgaXMgYWxyZWFkeSBkb25lIGZvciB3ZWVrXG4gICAgaWYgKHByb3BzLnNuYXBUb1dlZWspIHtcbiAgICAgICAgc3RhcnQgPSBkYXRlRW52LnN0YXJ0T2ZXZWVrKHN0YXJ0KTtcbiAgICAgICAgLy8gbWFrZSBlbmQtb2Ytd2VlayBpZiBub3QgYWxyZWFkeVxuICAgICAgICBlbmRPZldlZWsgPSBkYXRlRW52LnN0YXJ0T2ZXZWVrKGVuZCk7XG4gICAgICAgIGlmIChlbmRPZldlZWsudmFsdWVPZigpICE9PSBlbmQudmFsdWVPZigpKSB7XG4gICAgICAgICAgICBlbmQgPSBhZGRXZWVrcyhlbmRPZldlZWssIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGVuc3VyZSA2IHdlZWtzXG4gICAgaWYgKHByb3BzLmZpeGVkV2Vla0NvdW50KSB7XG4gICAgICAgIC8vIFRPRE86IGluc3RlYWQgb2YgdGhlc2UgZGF0ZS1tYXRoIGd5bW5hc3RpY3MgKGZvciBtdWx0aW1vbnRoIHZpZXcpLFxuICAgICAgICAvLyBjb21wdXRlIGRhdGVwcm9maWxlcyBvZiBhbGwgbW9udGhzLCB0aGVuIHVzZSBzdGFydCBvZiBmaXJzdCBhbmQgZW5kIG9mIGxhc3QuXG4gICAgICAgIGxldCBsYXN0TW9udGhSZW5kZXJTdGFydCA9IGRhdGVFbnYuc3RhcnRPZldlZWsoZGF0ZUVudi5zdGFydE9mTW9udGgoYWRkRGF5cyhjdXJyZW50UmFuZ2UuZW5kLCAtMSkpKTtcbiAgICAgICAgbGV0IHJvd0NudCA9IE1hdGguY2VpbCgvLyBjb3VsZCBiZSBwYXJ0aWFsIHdlZWtzIGR1ZSB0byBoaWRkZW5EYXlzXG4gICAgICAgIGRpZmZXZWVrcyhsYXN0TW9udGhSZW5kZXJTdGFydCwgZW5kKSk7XG4gICAgICAgIGVuZCA9IGFkZFdlZWtzKGVuZCwgNiAtIHJvd0NudCk7XG4gICAgfVxuICAgIHJldHVybiB7IHN0YXJ0LCBlbmQgfTtcbn1cblxudmFyIGNzc18yNDh6ID0gXCI6cm9vdHstLWZjLWRheWdyaWQtZXZlbnQtZG90LXdpZHRoOjhweH0uZmMtZGF5Z3JpZC1kYXktZXZlbnRzOmFmdGVyLC5mYy1kYXlncmlkLWRheS1ldmVudHM6YmVmb3JlLC5mYy1kYXlncmlkLWRheS1mcmFtZTphZnRlciwuZmMtZGF5Z3JpZC1kYXktZnJhbWU6YmVmb3JlLC5mYy1kYXlncmlkLWV2ZW50LWhhcm5lc3M6YWZ0ZXIsLmZjLWRheWdyaWQtZXZlbnQtaGFybmVzczpiZWZvcmV7Y2xlYXI6Ym90aDtjb250ZW50OlxcXCJcXFwiO2Rpc3BsYXk6dGFibGV9LmZjIC5mYy1kYXlncmlkLWJvZHl7cG9zaXRpb246cmVsYXRpdmU7ei1pbmRleDoxfS5mYyAuZmMtZGF5Z3JpZC1kYXkuZmMtZGF5LXRvZGF5e2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmMtdG9kYXktYmctY29sb3IpfS5mYyAuZmMtZGF5Z3JpZC1kYXktZnJhbWV7bWluLWhlaWdodDoxMDAlO3Bvc2l0aW9uOnJlbGF0aXZlfS5mYyAuZmMtZGF5Z3JpZC1kYXktdG9we2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpyb3ctcmV2ZXJzZX0uZmMgLmZjLWRheS1vdGhlciAuZmMtZGF5Z3JpZC1kYXktdG9we29wYWNpdHk6LjN9LmZjIC5mYy1kYXlncmlkLWRheS1udW1iZXJ7cGFkZGluZzo0cHg7cG9zaXRpb246cmVsYXRpdmU7ei1pbmRleDo0fS5mYyAuZmMtZGF5Z3JpZC1tb250aC1zdGFydHtmb250LXNpemU6MS4xZW07Zm9udC13ZWlnaHQ6NzAwfS5mYyAuZmMtZGF5Z3JpZC1kYXktZXZlbnRze21hcmdpbi10b3A6MXB4fS5mYyAuZmMtZGF5Z3JpZC1ib2R5LWJhbGFuY2VkIC5mYy1kYXlncmlkLWRheS1ldmVudHN7bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjB9LmZjIC5mYy1kYXlncmlkLWJvZHktdW5iYWxhbmNlZCAuZmMtZGF5Z3JpZC1kYXktZXZlbnRze21pbi1oZWlnaHQ6MmVtO3Bvc2l0aW9uOnJlbGF0aXZlfS5mYyAuZmMtZGF5Z3JpZC1ib2R5LW5hdHVyYWwgLmZjLWRheWdyaWQtZGF5LWV2ZW50c3ttYXJnaW4tYm90dG9tOjFlbX0uZmMgLmZjLWRheWdyaWQtZXZlbnQtaGFybmVzc3twb3NpdGlvbjpyZWxhdGl2ZX0uZmMgLmZjLWRheWdyaWQtZXZlbnQtaGFybmVzcy1hYnN7bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7dG9wOjB9LmZjIC5mYy1kYXlncmlkLWJnLWhhcm5lc3N7Ym90dG9tOjA7cG9zaXRpb246YWJzb2x1dGU7dG9wOjB9LmZjIC5mYy1kYXlncmlkLWRheS1iZyAuZmMtbm9uLWJ1c2luZXNze3otaW5kZXg6MX0uZmMgLmZjLWRheWdyaWQtZGF5LWJnIC5mYy1iZy1ldmVudHt6LWluZGV4OjJ9LmZjIC5mYy1kYXlncmlkLWRheS1iZyAuZmMtaGlnaGxpZ2h0e3otaW5kZXg6M30uZmMgLmZjLWRheWdyaWQtZXZlbnR7bWFyZ2luLXRvcDoxcHg7ei1pbmRleDo2fS5mYyAuZmMtZGF5Z3JpZC1ldmVudC5mYy1ldmVudC1taXJyb3J7ei1pbmRleDo3fS5mYyAuZmMtZGF5Z3JpZC1kYXktYm90dG9te2ZvbnQtc2l6ZTouODVlbTttYXJnaW46MCAycHh9LmZjIC5mYy1kYXlncmlkLWRheS1ib3R0b206YWZ0ZXIsLmZjIC5mYy1kYXlncmlkLWRheS1ib3R0b206YmVmb3Jle2NsZWFyOmJvdGg7Y29udGVudDpcXFwiXFxcIjtkaXNwbGF5OnRhYmxlfS5mYyAuZmMtZGF5Z3JpZC1tb3JlLWxpbmt7Ym9yZGVyLXJhZGl1czozcHg7Y3Vyc29yOnBvaW50ZXI7bGluZS1oZWlnaHQ6MTttYXJnaW4tdG9wOjFweDttYXgtd2lkdGg6MTAwJTtvdmVyZmxvdzpoaWRkZW47cGFkZGluZzoycHg7cG9zaXRpb246cmVsYXRpdmU7d2hpdGUtc3BhY2U6bm93cmFwO3otaW5kZXg6NH0uZmMgLmZjLWRheWdyaWQtbW9yZS1saW5rOmhvdmVye2JhY2tncm91bmQtY29sb3I6cmdiYSgwLDAsMCwuMSl9LmZjIC5mYy1kYXlncmlkLXdlZWstbnVtYmVye2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmMtbmV1dHJhbC1iZy1jb2xvcik7Y29sb3I6dmFyKC0tZmMtbmV1dHJhbC10ZXh0LWNvbG9yKTttaW4td2lkdGg6MS41ZW07cGFkZGluZzoycHg7cG9zaXRpb246YWJzb2x1dGU7dGV4dC1hbGlnbjpjZW50ZXI7dG9wOjA7ei1pbmRleDo1fS5mYyAuZmMtbW9yZS1wb3BvdmVyIC5mYy1wb3BvdmVyLWJvZHl7bWluLXdpZHRoOjIyMHB4O3BhZGRpbmc6MTBweH0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtZGF5Z3JpZC1ldmVudC5mYy1ldmVudC1zdGFydCwuZmMtZGlyZWN0aW9uLXJ0bCAuZmMtZGF5Z3JpZC1ldmVudC5mYy1ldmVudC1lbmR7bWFyZ2luLWxlZnQ6MnB4fS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1kYXlncmlkLWV2ZW50LmZjLWV2ZW50LWVuZCwuZmMtZGlyZWN0aW9uLXJ0bCAuZmMtZGF5Z3JpZC1ldmVudC5mYy1ldmVudC1zdGFydHttYXJnaW4tcmlnaHQ6MnB4fS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1kYXlncmlkLW1vcmUtbGlua3tmbG9hdDpsZWZ0fS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1kYXlncmlkLXdlZWstbnVtYmVye2JvcmRlci1yYWRpdXM6MCAwIDNweCAwO2xlZnQ6MH0uZmMtZGlyZWN0aW9uLXJ0bCAuZmMtZGF5Z3JpZC1tb3JlLWxpbmt7ZmxvYXQ6cmlnaHR9LmZjLWRpcmVjdGlvbi1ydGwgLmZjLWRheWdyaWQtd2Vlay1udW1iZXJ7Ym9yZGVyLXJhZGl1czowIDAgMCAzcHg7cmlnaHQ6MH0uZmMtbGlxdWlkLWhhY2sgLmZjLWRheWdyaWQtZGF5LWZyYW1le3Bvc2l0aW9uOnN0YXRpY30uZmMtZGF5Z3JpZC1ldmVudHtib3JkZXItcmFkaXVzOjNweDtmb250LXNpemU6dmFyKC0tZmMtc21hbGwtZm9udC1zaXplKTtwb3NpdGlvbjpyZWxhdGl2ZTt3aGl0ZS1zcGFjZTpub3dyYXB9LmZjLWRheWdyaWQtYmxvY2stZXZlbnQgLmZjLWV2ZW50LXRpbWV7Zm9udC13ZWlnaHQ6NzAwfS5mYy1kYXlncmlkLWJsb2NrLWV2ZW50IC5mYy1ldmVudC10aW1lLC5mYy1kYXlncmlkLWJsb2NrLWV2ZW50IC5mYy1ldmVudC10aXRsZXtwYWRkaW5nOjFweH0uZmMtZGF5Z3JpZC1kb3QtZXZlbnR7YWxpZ24taXRlbXM6Y2VudGVyO2Rpc3BsYXk6ZmxleDtwYWRkaW5nOjJweCAwfS5mYy1kYXlncmlkLWRvdC1ldmVudCAuZmMtZXZlbnQtdGl0bGV7ZmxleC1ncm93OjE7ZmxleC1zaHJpbms6MTtmb250LXdlaWdodDo3MDA7bWluLXdpZHRoOjA7b3ZlcmZsb3c6aGlkZGVufS5mYy1kYXlncmlkLWRvdC1ldmVudC5mYy1ldmVudC1taXJyb3IsLmZjLWRheWdyaWQtZG90LWV2ZW50OmhvdmVye2JhY2tncm91bmQ6cmdiYSgwLDAsMCwuMSl9LmZjLWRheWdyaWQtZG90LWV2ZW50LmZjLWV2ZW50LXNlbGVjdGVkOmJlZm9yZXtib3R0b206LTEwcHg7dG9wOi0xMHB4fS5mYy1kYXlncmlkLWV2ZW50LWRvdHtib3JkZXI6Y2FsYyh2YXIoLS1mYy1kYXlncmlkLWV2ZW50LWRvdC13aWR0aCkvMikgc29saWQgdmFyKC0tZmMtZXZlbnQtYm9yZGVyLWNvbG9yKTtib3JkZXItcmFkaXVzOmNhbGModmFyKC0tZmMtZGF5Z3JpZC1ldmVudC1kb3Qtd2lkdGgpLzIpO2JveC1zaXppbmc6Y29udGVudC1ib3g7aGVpZ2h0OjA7bWFyZ2luOjAgNHB4O3dpZHRoOjB9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLWRheWdyaWQtZXZlbnQgLmZjLWV2ZW50LXRpbWV7bWFyZ2luLXJpZ2h0OjNweH0uZmMtZGlyZWN0aW9uLXJ0bCAuZmMtZGF5Z3JpZC1ldmVudCAuZmMtZXZlbnQtdGltZXttYXJnaW4tbGVmdDozcHh9XCI7XG5pbmplY3RTdHlsZXMoY3NzXzI0OHopO1xuXG5leHBvcnQgeyBEYXlUYWJsZVZpZXcgYXMgRGF5R3JpZFZpZXcsIERheVRhYmxlLCBEYXlUYWJsZVNsaWNlciwgVGFibGUsIFRhYmxlRGF0ZVByb2ZpbGVHZW5lcmF0b3IsIFRhYmxlUm93cywgVGFibGVWaWV3LCBidWlsZERheVRhYmxlTW9kZWwsIGJ1aWxkRGF5VGFibGVSZW5kZXJSYW5nZSB9O1xuIiwgImltcG9ydCB7IGNyZWF0ZVBsdWdpbiB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29yZS9pbmRleC5qcyc7XG5pbXBvcnQgeyBEYXlHcmlkVmlldyBhcyBEYXlUYWJsZVZpZXcsIFRhYmxlRGF0ZVByb2ZpbGVHZW5lcmF0b3IgfSBmcm9tICcuL2ludGVybmFsLmpzJztcbmltcG9ydCAnQGZ1bGxjYWxlbmRhci9jb3JlL2ludGVybmFsLmpzJztcbmltcG9ydCAnQGZ1bGxjYWxlbmRhci9jb3JlL3ByZWFjdC5qcyc7XG5cbnZhciBpbmRleCA9IGNyZWF0ZVBsdWdpbih7XG4gICAgbmFtZTogJ0BmdWxsY2FsZW5kYXIvZGF5Z3JpZCcsXG4gICAgaW5pdGlhbFZpZXc6ICdkYXlHcmlkTW9udGgnLFxuICAgIHZpZXdzOiB7XG4gICAgICAgIGRheUdyaWQ6IHtcbiAgICAgICAgICAgIGNvbXBvbmVudDogRGF5VGFibGVWaWV3LFxuICAgICAgICAgICAgZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzczogVGFibGVEYXRlUHJvZmlsZUdlbmVyYXRvcixcbiAgICAgICAgfSxcbiAgICAgICAgZGF5R3JpZERheToge1xuICAgICAgICAgICAgdHlwZTogJ2RheUdyaWQnLFxuICAgICAgICAgICAgZHVyYXRpb246IHsgZGF5czogMSB9LFxuICAgICAgICB9LFxuICAgICAgICBkYXlHcmlkV2Vlazoge1xuICAgICAgICAgICAgdHlwZTogJ2RheUdyaWQnLFxuICAgICAgICAgICAgZHVyYXRpb246IHsgd2Vla3M6IDEgfSxcbiAgICAgICAgfSxcbiAgICAgICAgZGF5R3JpZE1vbnRoOiB7XG4gICAgICAgICAgICB0eXBlOiAnZGF5R3JpZCcsXG4gICAgICAgICAgICBkdXJhdGlvbjogeyBtb250aHM6IDEgfSxcbiAgICAgICAgICAgIGZpeGVkV2Vla0NvdW50OiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICBkYXlHcmlkWWVhcjoge1xuICAgICAgICAgICAgdHlwZTogJ2RheUdyaWQnLFxuICAgICAgICAgICAgZHVyYXRpb246IHsgeWVhcnM6IDEgfSxcbiAgICAgICAgfSxcbiAgICB9LFxufSk7XG5cbmV4cG9ydCB7IGluZGV4IGFzIGRlZmF1bHQgfTtcbiIsICJpbXBvcnQgeyBTcGxpdHRlciwgaGFzQmdSZW5kZXJpbmcsIGNyZWF0ZUZvcm1hdHRlciwgVmlld0NvbnRleHRUeXBlLCBDb250ZW50Q29udGFpbmVyLCBCYXNlQ29tcG9uZW50LCBEYXRlQ29tcG9uZW50LCBkaWZmRGF5cywgYnVpbGROYXZMaW5rQXR0cnMsIFdlZWtOdW1iZXJDb250YWluZXIsIGdldFN0aWNreUhlYWRlckRhdGVzLCBWaWV3Q29udGFpbmVyLCBTaW1wbGVTY3JvbGxHcmlkLCBnZXRTdGlja3lGb290ZXJTY3JvbGxiYXIsIE5vd1RpbWVyLCBOb3dJbmRpY2F0b3JDb250YWluZXIsIHJlbmRlclNjcm9sbFNoaW0sIHJhbmdlQ29udGFpbnNNYXJrZXIsIHN0YXJ0T2ZEYXksIGFzUm91Z2hNcywgY3JlYXRlRHVyYXRpb24sIFJlZk1hcCwgUG9zaXRpb25DYWNoZSwgTW9yZUxpbmtDb250YWluZXIsIFNlZ0hpZXJhcmNoeSwgZ3JvdXBJbnRlcnNlY3RpbmdFbnRyaWVzLCBiaW5hcnlTZWFyY2gsIGdldEVudHJ5U3BhbkVuZCwgYnVpbGRFbnRyeUtleSwgU3RhbmRhcmRFdmVudCwgbWVtb2l6ZSwgc29ydEV2ZW50U2VncywgRGF5Q2VsbENvbnRhaW5lciwgaGFzQ3VzdG9tRGF5Q2VsbENvbnRlbnQsIGdldFNlZ01ldGEsIGJ1aWxkSXNvU3RyaW5nLCBjb21wdXRlRWFybGllc3RTZWdTdGFydCwgYnVpbGRFdmVudFJhbmdlS2V5LCBCZ0V2ZW50LCByZW5kZXJGaWxsLCBhZGREdXJhdGlvbnMsIG11bHRpcGx5RHVyYXRpb24sIHdob2xlRGl2aWRlRHVyYXRpb25zLCBTbGljZXIsIGludGVyc2VjdFJhbmdlcywgZm9ybWF0SXNvVGltZVN0cmluZywgRGF5SGVhZGVyLCBEYXlTZXJpZXNNb2RlbCwgRGF5VGFibGVNb2RlbCwgaW5qZWN0U3R5bGVzIH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb3JlL2ludGVybmFsLmpzJztcbmltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIGNyZWF0ZVJlZiwgRnJhZ21lbnQgfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvcmUvcHJlYWN0LmpzJztcbmltcG9ydCB7IERheVRhYmxlIH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9kYXlncmlkL2ludGVybmFsLmpzJztcblxuY2xhc3MgQWxsRGF5U3BsaXR0ZXIgZXh0ZW5kcyBTcGxpdHRlciB7XG4gICAgZ2V0S2V5SW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFsbERheToge30sXG4gICAgICAgICAgICB0aW1lZDoge30sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldEtleXNGb3JEYXRlU3BhbihkYXRlU3Bhbikge1xuICAgICAgICBpZiAoZGF0ZVNwYW4uYWxsRGF5KSB7XG4gICAgICAgICAgICByZXR1cm4gWydhbGxEYXknXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWyd0aW1lZCddO1xuICAgIH1cbiAgICBnZXRLZXlzRm9yRXZlbnREZWYoZXZlbnREZWYpIHtcbiAgICAgICAgaWYgKCFldmVudERlZi5hbGxEYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBbJ3RpbWVkJ107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0JnUmVuZGVyaW5nKGV2ZW50RGVmKSkge1xuICAgICAgICAgICAgcmV0dXJuIFsndGltZWQnLCAnYWxsRGF5J107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFsnYWxsRGF5J107XG4gICAgfVxufVxuXG5jb25zdCBERUZBVUxUX1NMQVRfTEFCRUxfRk9STUFUID0gY3JlYXRlRm9ybWF0dGVyKHtcbiAgICBob3VyOiAnbnVtZXJpYycsXG4gICAgbWludXRlOiAnMi1kaWdpdCcsXG4gICAgb21pdFplcm9NaW51dGU6IHRydWUsXG4gICAgbWVyaWRpZW06ICdzaG9ydCcsXG59KTtcbmZ1bmN0aW9uIFRpbWVDb2xzQXhpc0NlbGwocHJvcHMpIHtcbiAgICBsZXQgY2xhc3NOYW1lcyA9IFtcbiAgICAgICAgJ2ZjLXRpbWVncmlkLXNsb3QnLFxuICAgICAgICAnZmMtdGltZWdyaWQtc2xvdC1sYWJlbCcsXG4gICAgICAgIHByb3BzLmlzTGFiZWxlZCA/ICdmYy1zY3JvbGxncmlkLXNocmluaycgOiAnZmMtdGltZWdyaWQtc2xvdC1taW5vcicsXG4gICAgXTtcbiAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVmlld0NvbnRleHRUeXBlLkNvbnN1bWVyLCBudWxsLCAoY29udGV4dCkgPT4ge1xuICAgICAgICBpZiAoIXByb3BzLmlzTGFiZWxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwidGRcIiwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMuam9pbignICcpLCBcImRhdGEtdGltZVwiOiBwcm9wcy5pc29UaW1lU3RyIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBkYXRlRW52LCBvcHRpb25zLCB2aWV3QXBpIH0gPSBjb250ZXh0O1xuICAgICAgICBsZXQgbGFiZWxGb3JtYXQgPSAvLyBUT0RPOiBmdWxseSBwcmUtcGFyc2VcbiAgICAgICAgIG9wdGlvbnMuc2xvdExhYmVsRm9ybWF0ID09IG51bGwgPyBERUZBVUxUX1NMQVRfTEFCRUxfRk9STUFUIDpcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkob3B0aW9ucy5zbG90TGFiZWxGb3JtYXQpID8gY3JlYXRlRm9ybWF0dGVyKG9wdGlvbnMuc2xvdExhYmVsRm9ybWF0WzBdKSA6XG4gICAgICAgICAgICAgICAgY3JlYXRlRm9ybWF0dGVyKG9wdGlvbnMuc2xvdExhYmVsRm9ybWF0KTtcbiAgICAgICAgbGV0IHJlbmRlclByb3BzID0ge1xuICAgICAgICAgICAgbGV2ZWw6IDAsXG4gICAgICAgICAgICB0aW1lOiBwcm9wcy50aW1lLFxuICAgICAgICAgICAgZGF0ZTogZGF0ZUVudi50b0RhdGUocHJvcHMuZGF0ZSksXG4gICAgICAgICAgICB2aWV3OiB2aWV3QXBpLFxuICAgICAgICAgICAgdGV4dDogZGF0ZUVudi5mb3JtYXQocHJvcHMuZGF0ZSwgbGFiZWxGb3JtYXQpLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoQ29udGVudENvbnRhaW5lciwgeyBlbFRhZzogXCJ0ZFwiLCBlbENsYXNzZXM6IGNsYXNzTmFtZXMsIGVsQXR0cnM6IHtcbiAgICAgICAgICAgICAgICAnZGF0YS10aW1lJzogcHJvcHMuaXNvVGltZVN0cixcbiAgICAgICAgICAgIH0sIHJlbmRlclByb3BzOiByZW5kZXJQcm9wcywgZ2VuZXJhdG9yTmFtZTogXCJzbG90TGFiZWxDb250ZW50XCIsIGN1c3RvbUdlbmVyYXRvcjogb3B0aW9ucy5zbG90TGFiZWxDb250ZW50LCBkZWZhdWx0R2VuZXJhdG9yOiByZW5kZXJJbm5lckNvbnRlbnQsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy5zbG90TGFiZWxDbGFzc05hbWVzLCBkaWRNb3VudDogb3B0aW9ucy5zbG90TGFiZWxEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMuc2xvdExhYmVsV2lsbFVubW91bnQgfSwgKElubmVyQ29udGVudCkgPT4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtc2xvdC1sYWJlbC1mcmFtZSBmYy1zY3JvbGxncmlkLXNocmluay1mcmFtZVwiIH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KElubmVyQ29udGVudCwgeyBlbFRhZzogXCJkaXZcIiwgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgICAgICdmYy10aW1lZ3JpZC1zbG90LWxhYmVsLWN1c2hpb24nLFxuICAgICAgICAgICAgICAgICAgICAnZmMtc2Nyb2xsZ3JpZC1zaHJpbmstY3VzaGlvbicsXG4gICAgICAgICAgICAgICAgXSB9KSkpKSk7XG4gICAgfSkpO1xufVxuZnVuY3Rpb24gcmVuZGVySW5uZXJDb250ZW50KHByb3BzKSB7XG4gICAgcmV0dXJuIHByb3BzLnRleHQ7XG59XG5cbmNsYXNzIFRpbWVCb2R5QXhpcyBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuc2xhdE1ldGFzLm1hcCgoc2xhdE1ldGEpID0+IChjcmVhdGVFbGVtZW50KFwidHJcIiwgeyBrZXk6IHNsYXRNZXRhLmtleSB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChUaW1lQ29sc0F4aXNDZWxsLCBPYmplY3QuYXNzaWduKHt9LCBzbGF0TWV0YSkpKSkpO1xuICAgIH1cbn1cblxuY29uc3QgREVGQVVMVF9XRUVLX05VTV9GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoeyB3ZWVrOiAnc2hvcnQnIH0pO1xuY29uc3QgQVVUT19BTExfREFZX01BWF9FVkVOVF9ST1dTID0gNTtcbmNsYXNzIFRpbWVDb2xzVmlldyBleHRlbmRzIERhdGVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmFsbERheVNwbGl0dGVyID0gbmV3IEFsbERheVNwbGl0dGVyKCk7IC8vIGZvciB1c2UgYnkgc3ViY2xhc3Nlc1xuICAgICAgICB0aGlzLmhlYWRlckVsUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIHRoaXMucm9vdEVsUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIHRoaXMuc2Nyb2xsZXJFbFJlZiA9IGNyZWF0ZVJlZigpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgc2xhdENvb3JkczogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGxUb3BSZXF1ZXN0ID0gKHNjcm9sbFRvcCkgPT4ge1xuICAgICAgICAgICAgbGV0IHNjcm9sbGVyRWwgPSB0aGlzLnNjcm9sbGVyRWxSZWYuY3VycmVudDtcbiAgICAgICAgICAgIGlmIChzY3JvbGxlckVsKSB7IC8vIFRPRE86IG5vdCBzdXJlIGhvdyB0aGlzIGNvdWxkIGV2ZXIgYmUgbnVsbC4gd2VpcmRuZXNzIHdpdGggdGhlIHJlZHVjZXJcbiAgICAgICAgICAgICAgICBzY3JvbGxlckVsLnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyogSGVhZGVyIFJlbmRlciBNZXRob2RzXG4gICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gICAgICAgIHRoaXMucmVuZGVySGVhZEF4aXMgPSAocm93S2V5LCBmcmFtZUhlaWdodCA9ICcnKSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgICAgICBsZXQgeyBkYXRlUHJvZmlsZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGxldCByYW5nZSA9IGRhdGVQcm9maWxlLnJlbmRlclJhbmdlO1xuICAgICAgICAgICAgbGV0IGRheUNudCA9IGRpZmZEYXlzKHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQpO1xuICAgICAgICAgICAgLy8gb25seSBkbyBpbiBkYXkgdmlld3MgKHRvIGF2b2lkIGRvaW5nIGluIHdlZWsgdmlld3MgdGhhdCBkb250IG5lZWQgaXQpXG4gICAgICAgICAgICBsZXQgbmF2TGlua0F0dHJzID0gKGRheUNudCA9PT0gMSlcbiAgICAgICAgICAgICAgICA/IGJ1aWxkTmF2TGlua0F0dHJzKHRoaXMuY29udGV4dCwgcmFuZ2Uuc3RhcnQsICd3ZWVrJylcbiAgICAgICAgICAgICAgICA6IHt9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMud2Vla051bWJlcnMgJiYgcm93S2V5ID09PSAnZGF5Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChXZWVrTnVtYmVyQ29udGFpbmVyLCB7IGVsVGFnOiBcInRoXCIsIGVsQ2xhc3NlczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLXRpbWVncmlkLWF4aXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLXNjcm9sbGdyaWQtc2hyaW5rJyxcbiAgICAgICAgICAgICAgICAgICAgXSwgZWxBdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2FyaWEtaGlkZGVuJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSwgZGF0ZTogcmFuZ2Uuc3RhcnQsIGRlZmF1bHRGb3JtYXQ6IERFRkFVTFRfV0VFS19OVU1fRk9STUFUIH0sIChJbm5lckNvbnRlbnQpID0+IChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmMtdGltZWdyaWQtYXhpcy1mcmFtZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmMtc2Nyb2xsZ3JpZC1zaHJpbmstZnJhbWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLXRpbWVncmlkLWF4aXMtZnJhbWUtbGlxdWlkJyxcbiAgICAgICAgICAgICAgICAgICAgXS5qb2luKCcgJyksIHN0eWxlOiB7IGhlaWdodDogZnJhbWVIZWlnaHQgfSB9LFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KElubmVyQ29udGVudCwgeyBlbFRhZzogXCJhXCIsIGVsQ2xhc3NlczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdmYy10aW1lZ3JpZC1heGlzLWN1c2hpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdmYy1zY3JvbGxncmlkLXNocmluay1jdXNoaW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZmMtc2Nyb2xsZ3JpZC1zeW5jLWlubmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sIGVsQXR0cnM6IG5hdkxpbmtBdHRycyB9KSkpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJ0aFwiLCB7IFwiYXJpYS1oaWRkZW5cIjogdHJ1ZSwgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWF4aXNcIiB9LFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtYXhpcy1mcmFtZVwiLCBzdHlsZTogeyBoZWlnaHQ6IGZyYW1lSGVpZ2h0IH0gfSkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyogVGFibGUgQ29tcG9uZW50IFJlbmRlciBNZXRob2RzXG4gICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gICAgICAgIC8vIG9ubHkgYSBvbmUtd2F5IGhlaWdodCBzeW5jLiB3ZSBkb24ndCBzZW5kIHRoZSBheGlzIGlubmVyLWNvbnRlbnQgaGVpZ2h0IHRvIHRoZSBEYXlHcmlkLFxuICAgICAgICAvLyBidXQgRGF5R3JpZCBzdGlsbCBuZWVkcyB0byBoYXZlIGNsYXNzTmFtZXMgb24gaW5uZXIgZWxlbWVudHMgaW4gb3JkZXIgdG8gbWVhc3VyZS5cbiAgICAgICAgdGhpcy5yZW5kZXJUYWJsZVJvd0F4aXMgPSAocm93SGVpZ2h0KSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBvcHRpb25zLCB2aWV3QXBpIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgICAgICBsZXQgcmVuZGVyUHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgdGV4dDogb3B0aW9ucy5hbGxEYXlUZXh0LFxuICAgICAgICAgICAgICAgIHZpZXc6IHZpZXdBcGksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIC8vIFRPRE86IG1ha2UgcmV1c2FibGUgaG9vay4gdXNlZCBpbiBsaXN0IHZpZXcgdG9vXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KENvbnRlbnRDb250YWluZXIsIHsgZWxUYWc6IFwidGRcIiwgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgICAgICdmYy10aW1lZ3JpZC1heGlzJyxcbiAgICAgICAgICAgICAgICAgICAgJ2ZjLXNjcm9sbGdyaWQtc2hyaW5rJyxcbiAgICAgICAgICAgICAgICBdLCBlbEF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICdhcmlhLWhpZGRlbic6IHRydWUsXG4gICAgICAgICAgICAgICAgfSwgcmVuZGVyUHJvcHM6IHJlbmRlclByb3BzLCBnZW5lcmF0b3JOYW1lOiBcImFsbERheUNvbnRlbnRcIiwgY3VzdG9tR2VuZXJhdG9yOiBvcHRpb25zLmFsbERheUNvbnRlbnQsIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlckFsbERheUlubmVyLCBjbGFzc05hbWVHZW5lcmF0b3I6IG9wdGlvbnMuYWxsRGF5Q2xhc3NOYW1lcywgZGlkTW91bnQ6IG9wdGlvbnMuYWxsRGF5RGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLmFsbERheVdpbGxVbm1vdW50IH0sIChJbm5lckNvbnRlbnQpID0+IChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBbXG4gICAgICAgICAgICAgICAgICAgICdmYy10aW1lZ3JpZC1heGlzLWZyYW1lJyxcbiAgICAgICAgICAgICAgICAgICAgJ2ZjLXNjcm9sbGdyaWQtc2hyaW5rLWZyYW1lJyxcbiAgICAgICAgICAgICAgICAgICAgcm93SGVpZ2h0ID09IG51bGwgPyAnIGZjLXRpbWVncmlkLWF4aXMtZnJhbWUtbGlxdWlkJyA6ICcnLFxuICAgICAgICAgICAgICAgIF0uam9pbignICcpLCBzdHlsZTogeyBoZWlnaHQ6IHJvd0hlaWdodCB9IH0sXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChJbm5lckNvbnRlbnQsIHsgZWxUYWc6IFwic3BhblwiLCBlbENsYXNzZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdmYy10aW1lZ3JpZC1heGlzLWN1c2hpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLXNjcm9sbGdyaWQtc2hyaW5rLWN1c2hpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLXNjcm9sbGdyaWQtc3luYy1pbm5lcicsXG4gICAgICAgICAgICAgICAgICAgIF0gfSkpKSkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVNsYXRDb29yZHMgPSAoc2xhdENvb3JkcykgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IHNsYXRDb29yZHMgfSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIHJlbmRlcmluZ1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICByZW5kZXJTaW1wbGVMYXlvdXQoaGVhZGVyUm93Q29udGVudCwgYWxsRGF5Q29udGVudCwgdGltZUNvbnRlbnQpIHtcbiAgICAgICAgbGV0IHsgY29udGV4dCwgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBzZWN0aW9ucyA9IFtdO1xuICAgICAgICBsZXQgc3RpY2t5SGVhZGVyRGF0ZXMgPSBnZXRTdGlja3lIZWFkZXJEYXRlcyhjb250ZXh0Lm9wdGlvbnMpO1xuICAgICAgICBpZiAoaGVhZGVyUm93Q29udGVudCkge1xuICAgICAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2hlYWRlcicsXG4gICAgICAgICAgICAgICAga2V5OiAnaGVhZGVyJyxcbiAgICAgICAgICAgICAgICBpc1N0aWNreTogc3RpY2t5SGVhZGVyRGF0ZXMsXG4gICAgICAgICAgICAgICAgY2h1bms6IHtcbiAgICAgICAgICAgICAgICAgICAgZWxSZWY6IHRoaXMuaGVhZGVyRWxSZWYsXG4gICAgICAgICAgICAgICAgICAgIHRhYmxlQ2xhc3NOYW1lOiAnZmMtY29sLWhlYWRlcicsXG4gICAgICAgICAgICAgICAgICAgIHJvd0NvbnRlbnQ6IGhlYWRlclJvd0NvbnRlbnQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbGxEYXlDb250ZW50KSB7XG4gICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYm9keScsXG4gICAgICAgICAgICAgICAga2V5OiAnYWxsLWRheScsXG4gICAgICAgICAgICAgICAgY2h1bms6IHsgY29udGVudDogYWxsRGF5Q29udGVudCB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYm9keScsXG4gICAgICAgICAgICAgICAga2V5OiAnYWxsLWRheS1kaXZpZGVyJyxcbiAgICAgICAgICAgICAgICBvdXRlckNvbnRlbnQ6ICggLy8gVE9ETzogcmVuYW1lIHRvIGNlbGxDb250ZW50IHNvIGRvbid0IG5lZWQgdG8gZGVmaW5lIDx0cj4/XG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRyXCIsIHsgcm9sZTogXCJwcmVzZW50YXRpb25cIiwgY2xhc3NOYW1lOiBcImZjLXNjcm9sbGdyaWQtc2VjdGlvblwiIH0sXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IGNsYXNzTmFtZTogJ2ZjLXRpbWVncmlkLWRpdmlkZXIgJyArIGNvbnRleHQudGhlbWUuZ2V0Q2xhc3MoJ3RhYmxlQ2VsbFNoYWRlZCcpIH0pKSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdib2R5JyxcbiAgICAgICAgICAgIGtleTogJ2JvZHknLFxuICAgICAgICAgICAgbGlxdWlkOiB0cnVlLFxuICAgICAgICAgICAgZXhwYW5kUm93czogQm9vbGVhbihjb250ZXh0Lm9wdGlvbnMuZXhwYW5kUm93cyksXG4gICAgICAgICAgICBjaHVuazoge1xuICAgICAgICAgICAgICAgIHNjcm9sbGVyRWxSZWY6IHRoaXMuc2Nyb2xsZXJFbFJlZixcbiAgICAgICAgICAgICAgICBjb250ZW50OiB0aW1lQ29udGVudCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVmlld0NvbnRhaW5lciwgeyBlbFJlZjogdGhpcy5yb290RWxSZWYsIGVsQ2xhc3NlczogWydmYy10aW1lZ3JpZCddLCB2aWV3U3BlYzogY29udGV4dC52aWV3U3BlYyB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChTaW1wbGVTY3JvbGxHcmlkLCB7IGxpcXVpZDogIXByb3BzLmlzSGVpZ2h0QXV0byAmJiAhcHJvcHMuZm9yUHJpbnQsIGNvbGxhcHNpYmxlV2lkdGg6IHByb3BzLmZvclByaW50LCBjb2xzOiBbeyB3aWR0aDogJ3NocmluaycgfV0sIHNlY3Rpb25zOiBzZWN0aW9ucyB9KSkpO1xuICAgIH1cbiAgICByZW5kZXJIU2Nyb2xsTGF5b3V0KGhlYWRlclJvd0NvbnRlbnQsIGFsbERheUNvbnRlbnQsIHRpbWVDb250ZW50LCBjb2xDbnQsIGRheU1pbldpZHRoLCBzbGF0TWV0YXMsIHNsYXRDb29yZHMpIHtcbiAgICAgICAgbGV0IFNjcm9sbEdyaWQgPSB0aGlzLmNvbnRleHQucGx1Z2luSG9va3Muc2Nyb2xsR3JpZEltcGw7XG4gICAgICAgIGlmICghU2Nyb2xsR3JpZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBTY3JvbGxHcmlkIGltcGxlbWVudGF0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgY29udGV4dCwgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBzdGlja3lIZWFkZXJEYXRlcyA9ICFwcm9wcy5mb3JQcmludCAmJiBnZXRTdGlja3lIZWFkZXJEYXRlcyhjb250ZXh0Lm9wdGlvbnMpO1xuICAgICAgICBsZXQgc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyID0gIXByb3BzLmZvclByaW50ICYmIGdldFN0aWNreUZvb3RlclNjcm9sbGJhcihjb250ZXh0Lm9wdGlvbnMpO1xuICAgICAgICBsZXQgc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgaWYgKGhlYWRlclJvd0NvbnRlbnQpIHtcbiAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdoZWFkZXInLFxuICAgICAgICAgICAgICAgIGtleTogJ2hlYWRlcicsXG4gICAgICAgICAgICAgICAgaXNTdGlja3k6IHN0aWNreUhlYWRlckRhdGVzLFxuICAgICAgICAgICAgICAgIHN5bmNSb3dIZWlnaHRzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNodW5rczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdheGlzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0NvbnRlbnQ6IChhcmcpID0+IChjcmVhdGVFbGVtZW50KFwidHJcIiwgeyByb2xlOiBcInByZXNlbnRhdGlvblwiIH0sIHRoaXMucmVuZGVySGVhZEF4aXMoJ2RheScsIGFyZy5yb3dTeW5jSGVpZ2h0c1swXSkpKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAnY29scycsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbFJlZjogdGhpcy5oZWFkZXJFbFJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlQ2xhc3NOYW1lOiAnZmMtY29sLWhlYWRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dDb250ZW50OiBoZWFkZXJSb3dDb250ZW50LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxsRGF5Q29udGVudCkge1xuICAgICAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2JvZHknLFxuICAgICAgICAgICAgICAgIGtleTogJ2FsbC1kYXknLFxuICAgICAgICAgICAgICAgIHN5bmNSb3dIZWlnaHRzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNodW5rczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdheGlzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0NvbnRlbnQ6IChjb250ZW50QXJnKSA9PiAoY3JlYXRlRWxlbWVudChcInRyXCIsIHsgcm9sZTogXCJwcmVzZW50YXRpb25cIiB9LCB0aGlzLnJlbmRlclRhYmxlUm93QXhpcyhjb250ZW50QXJnLnJvd1N5bmNIZWlnaHRzWzBdKSkpLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdjb2xzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGFsbERheUNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAga2V5OiAnYWxsLWRheS1kaXZpZGVyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYm9keScsXG4gICAgICAgICAgICAgICAgb3V0ZXJDb250ZW50OiAoIC8vIFRPRE86IHJlbmFtZSB0byBjZWxsQ29udGVudCBzbyBkb24ndCBuZWVkIHRvIGRlZmluZSA8dHI+P1xuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IHJvbGU6IFwicHJlc2VudGF0aW9uXCIsIGNsYXNzTmFtZTogXCJmYy1zY3JvbGxncmlkLXNlY3Rpb25cIiB9LFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwidGRcIiwgeyBjb2xTcGFuOiAyLCBjbGFzc05hbWU6ICdmYy10aW1lZ3JpZC1kaXZpZGVyICcgKyBjb250ZXh0LnRoZW1lLmdldENsYXNzKCd0YWJsZUNlbGxTaGFkZWQnKSB9KSkpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlzTm93SW5kaWNhdG9yID0gY29udGV4dC5vcHRpb25zLm5vd0luZGljYXRvcjtcbiAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnYm9keScsXG4gICAgICAgICAgICBrZXk6ICdib2R5JyxcbiAgICAgICAgICAgIGxpcXVpZDogdHJ1ZSxcbiAgICAgICAgICAgIGV4cGFuZFJvd3M6IEJvb2xlYW4oY29udGV4dC5vcHRpb25zLmV4cGFuZFJvd3MpLFxuICAgICAgICAgICAgY2h1bmtzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBrZXk6ICdheGlzJyxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogKGFyZykgPT4gKFxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBtYWtlIHRoaXMgbm93LWluZGljYXRvciBhcnJvdyBtb3JlIERSWSB3aXRoIFRpbWVDb2xzQ29udGVudFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWF4aXMtY2h1bmtcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRhYmxlXCIsIHsgXCJhcmlhLWhpZGRlblwiOiB0cnVlLCBzdHlsZTogeyBoZWlnaHQ6IGFyZy5leHBhbmRSb3dzID8gYXJnLmNsaWVudEhlaWdodCA6ICcnIH0gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcudGFibGVDb2xHcm91cE5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRib2R5XCIsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoVGltZUJvZHlBeGlzLCB7IHNsYXRNZXRhczogc2xhdE1ldGFzIH0pKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItY29udGFpbmVyXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KE5vd1RpbWVyLCB7IHVuaXQ6IGlzTm93SW5kaWNhdG9yID8gJ21pbnV0ZScgOiAnZGF5JyAvKiBoYWNreSAqLyB9LCAobm93RGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm93SW5kaWNhdG9yVG9wID0gaXNOb3dJbmRpY2F0b3IgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsYXRDb29yZHMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsYXRDb29yZHMuc2FmZUNvbXB1dGVUb3Aobm93RGF0ZSk7IC8vIG1pZ2h0IHJldHVybiB2b2lkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygbm93SW5kaWNhdG9yVG9wID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KE5vd0luZGljYXRvckNvbnRhaW5lciwgeyBlbENsYXNzZXM6IFsnZmMtdGltZWdyaWQtbm93LWluZGljYXRvci1hcnJvdyddLCBlbFN0eWxlOiB7IHRvcDogbm93SW5kaWNhdG9yVG9wIH0sIGlzQXhpczogdHJ1ZSwgZGF0ZTogbm93RGF0ZSB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpKSksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogJ2NvbHMnLFxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxlckVsUmVmOiB0aGlzLnNjcm9sbGVyRWxSZWYsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRpbWVDb250ZW50LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHN0aWNreUZvb3RlclNjcm9sbGJhcikge1xuICAgICAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAga2V5OiAnZm9vdGVyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnZm9vdGVyJyxcbiAgICAgICAgICAgICAgICBpc1N0aWNreTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjaHVua3M6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAnYXhpcycsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiByZW5kZXJTY3JvbGxTaGltLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdjb2xzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHJlbmRlclNjcm9sbFNoaW0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChWaWV3Q29udGFpbmVyLCB7IGVsUmVmOiB0aGlzLnJvb3RFbFJlZiwgZWxDbGFzc2VzOiBbJ2ZjLXRpbWVncmlkJ10sIHZpZXdTcGVjOiBjb250ZXh0LnZpZXdTcGVjIH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFNjcm9sbEdyaWQsIHsgbGlxdWlkOiAhcHJvcHMuaXNIZWlnaHRBdXRvICYmICFwcm9wcy5mb3JQcmludCwgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50LCBjb2xsYXBzaWJsZVdpZHRoOiBmYWxzZSwgY29sR3JvdXBzOiBbXG4gICAgICAgICAgICAgICAgICAgIHsgd2lkdGg6ICdzaHJpbmsnLCBjb2xzOiBbeyB3aWR0aDogJ3NocmluaycgfV0gfSxcbiAgICAgICAgICAgICAgICAgICAgeyBjb2xzOiBbeyBzcGFuOiBjb2xDbnQsIG1pbldpZHRoOiBkYXlNaW5XaWR0aCB9XSB9LFxuICAgICAgICAgICAgICAgIF0sIHNlY3Rpb25zOiBzZWN0aW9ucyB9KSkpO1xuICAgIH1cbiAgICAvKiBEaW1lbnNpb25zXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgICBnZXRBbGxEYXlNYXhFdmVudFByb3BzKCkge1xuICAgICAgICBsZXQgeyBkYXlNYXhFdmVudHMsIGRheU1heEV2ZW50Um93cyB9ID0gdGhpcy5jb250ZXh0Lm9wdGlvbnM7XG4gICAgICAgIGlmIChkYXlNYXhFdmVudHMgPT09IHRydWUgfHwgZGF5TWF4RXZlbnRSb3dzID09PSB0cnVlKSB7IC8vIGlzIGF1dG8/XG4gICAgICAgICAgICBkYXlNYXhFdmVudHMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBkYXlNYXhFdmVudFJvd3MgPSBBVVRPX0FMTF9EQVlfTUFYX0VWRU5UX1JPV1M7IC8vIG1ha2Ugc3VyZSBcImF1dG9cIiBnb2VzIHRvIGEgcmVhbCBudW1iZXJcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkYXlNYXhFdmVudHMsIGRheU1heEV2ZW50Um93cyB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbmRlckFsbERheUlubmVyKHJlbmRlclByb3BzKSB7XG4gICAgcmV0dXJuIHJlbmRlclByb3BzLnRleHQ7XG59XG5cbmNsYXNzIFRpbWVDb2xzU2xhdHNDb29yZHMge1xuICAgIGNvbnN0cnVjdG9yKHBvc2l0aW9ucywgZGF0ZVByb2ZpbGUsIHNsb3REdXJhdGlvbikge1xuICAgICAgICB0aGlzLnBvc2l0aW9ucyA9IHBvc2l0aW9ucztcbiAgICAgICAgdGhpcy5kYXRlUHJvZmlsZSA9IGRhdGVQcm9maWxlO1xuICAgICAgICB0aGlzLnNsb3REdXJhdGlvbiA9IHNsb3REdXJhdGlvbjtcbiAgICB9XG4gICAgc2FmZUNvbXB1dGVUb3AoZGF0ZSkge1xuICAgICAgICBsZXQgeyBkYXRlUHJvZmlsZSB9ID0gdGhpcztcbiAgICAgICAgaWYgKHJhbmdlQ29udGFpbnNNYXJrZXIoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLCBkYXRlKSkge1xuICAgICAgICAgICAgbGV0IHN0YXJ0T2ZEYXlEYXRlID0gc3RhcnRPZkRheShkYXRlKTtcbiAgICAgICAgICAgIGxldCB0aW1lTXMgPSBkYXRlLnZhbHVlT2YoKSAtIHN0YXJ0T2ZEYXlEYXRlLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIGlmICh0aW1lTXMgPj0gYXNSb3VnaE1zKGRhdGVQcm9maWxlLnNsb3RNaW5UaW1lKSAmJlxuICAgICAgICAgICAgICAgIHRpbWVNcyA8IGFzUm91Z2hNcyhkYXRlUHJvZmlsZS5zbG90TWF4VGltZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlVGltZVRvcChjcmVhdGVEdXJhdGlvbih0aW1lTXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gQ29tcHV0ZXMgdGhlIHRvcCBjb29yZGluYXRlLCByZWxhdGl2ZSB0byB0aGUgYm91bmRzIG9mIHRoZSBncmlkLCBvZiB0aGUgZ2l2ZW4gZGF0ZS5cbiAgICAvLyBBIGBzdGFydE9mRGF5RGF0ZWAgbXVzdCBiZSBnaXZlbiBmb3IgYXZvaWRpbmcgYW1iaWd1aXR5IG92ZXIgaG93IHRvIHRyZWF0IG1pZG5pZ2h0LlxuICAgIGNvbXB1dGVEYXRlVG9wKHdoZW4sIHN0YXJ0T2ZEYXlEYXRlKSB7XG4gICAgICAgIGlmICghc3RhcnRPZkRheURhdGUpIHtcbiAgICAgICAgICAgIHN0YXJ0T2ZEYXlEYXRlID0gc3RhcnRPZkRheSh3aGVuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlVGltZVRvcChjcmVhdGVEdXJhdGlvbih3aGVuLnZhbHVlT2YoKSAtIHN0YXJ0T2ZEYXlEYXRlLnZhbHVlT2YoKSkpO1xuICAgIH1cbiAgICAvLyBDb21wdXRlcyB0aGUgdG9wIGNvb3JkaW5hdGUsIHJlbGF0aXZlIHRvIHRoZSBib3VuZHMgb2YgdGhlIGdyaWQsIG9mIHRoZSBnaXZlbiB0aW1lIChhIER1cmF0aW9uKS5cbiAgICAvLyBUaGlzIGlzIGEgbWFrZXNoaWZ5IHdheSB0byBjb21wdXRlIHRoZSB0aW1lLXRvcC4gQXNzdW1lcyBhbGwgc2xhdE1ldGFzIGRhdGVzIGFyZSB1bmlmb3JtLlxuICAgIC8vIEV2ZW50dWFsbHkgYWxsb3cgY29tcHV0YXRpb24gd2l0aCBhcmJpcmFyeSBzbGF0IGRhdGVzLlxuICAgIGNvbXB1dGVUaW1lVG9wKGR1cmF0aW9uKSB7XG4gICAgICAgIGxldCB7IHBvc2l0aW9ucywgZGF0ZVByb2ZpbGUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBsZW4gPSBwb3NpdGlvbnMuZWxzLmxlbmd0aDtcbiAgICAgICAgLy8gZmxvYXRpbmctcG9pbnQgdmFsdWUgb2YgIyBvZiBzbG90cyBjb3ZlcmVkXG4gICAgICAgIGxldCBzbGF0Q292ZXJhZ2UgPSAoZHVyYXRpb24ubWlsbGlzZWNvbmRzIC0gYXNSb3VnaE1zKGRhdGVQcm9maWxlLnNsb3RNaW5UaW1lKSkgLyBhc1JvdWdoTXModGhpcy5zbG90RHVyYXRpb24pO1xuICAgICAgICBsZXQgc2xhdEluZGV4O1xuICAgICAgICBsZXQgc2xhdFJlbWFpbmRlcjtcbiAgICAgICAgLy8gY29tcHV0ZSBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBmb3IgaG93IG1hbnkgc2xhdHMgc2hvdWxkIGJlIHByb2dyZXNzZWQgdGhyb3VnaC5cbiAgICAgICAgLy8gZnJvbSAwIHRvIG51bWJlciBvZiBzbGF0cyAoaW5jbHVzaXZlKVxuICAgICAgICAvLyBjb25zdHJhaW5lZCBiZWNhdXNlIHNsb3RNaW5UaW1lL3Nsb3RNYXhUaW1lIG1pZ2h0IGJlIGN1c3RvbWl6ZWQuXG4gICAgICAgIHNsYXRDb3ZlcmFnZSA9IE1hdGgubWF4KDAsIHNsYXRDb3ZlcmFnZSk7XG4gICAgICAgIHNsYXRDb3ZlcmFnZSA9IE1hdGgubWluKGxlbiwgc2xhdENvdmVyYWdlKTtcbiAgICAgICAgLy8gYW4gaW50ZWdlciBpbmRleCBvZiB0aGUgZnVydGhlc3Qgd2hvbGUgc2xhdFxuICAgICAgICAvLyBmcm9tIDAgdG8gbnVtYmVyIHNsYXRzICgqZXhjbHVzaXZlKiwgc28gbGVuLTEpXG4gICAgICAgIHNsYXRJbmRleCA9IE1hdGguZmxvb3Ioc2xhdENvdmVyYWdlKTtcbiAgICAgICAgc2xhdEluZGV4ID0gTWF0aC5taW4oc2xhdEluZGV4LCBsZW4gLSAxKTtcbiAgICAgICAgLy8gaG93IG11Y2ggZnVydGhlciB0aHJvdWdoIHRoZSBzbGF0SW5kZXggc2xhdCAoZnJvbSAwLjAtMS4wKSBtdXN0IGJlIGNvdmVyZWQgaW4gYWRkaXRpb24uXG4gICAgICAgIC8vIGNvdWxkIGJlIDEuMCBpZiBzbGF0Q292ZXJhZ2UgaXMgY292ZXJpbmcgKmFsbCogdGhlIHNsb3RzXG4gICAgICAgIHNsYXRSZW1haW5kZXIgPSBzbGF0Q292ZXJhZ2UgLSBzbGF0SW5kZXg7XG4gICAgICAgIHJldHVybiBwb3NpdGlvbnMudG9wc1tzbGF0SW5kZXhdICtcbiAgICAgICAgICAgIHBvc2l0aW9ucy5nZXRIZWlnaHQoc2xhdEluZGV4KSAqIHNsYXRSZW1haW5kZXI7XG4gICAgfVxufVxuXG5jbGFzcyBUaW1lQ29sc1NsYXRzQm9keSBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgICAgIGxldCB7IHNsYXRFbFJlZnMgfSA9IHByb3BzO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJ0Ym9keVwiLCBudWxsLCBwcm9wcy5zbGF0TWV0YXMubWFwKChzbGF0TWV0YSwgaSkgPT4ge1xuICAgICAgICAgICAgbGV0IHJlbmRlclByb3BzID0ge1xuICAgICAgICAgICAgICAgIHRpbWU6IHNsYXRNZXRhLnRpbWUsXG4gICAgICAgICAgICAgICAgZGF0ZTogY29udGV4dC5kYXRlRW52LnRvRGF0ZShzbGF0TWV0YS5kYXRlKSxcbiAgICAgICAgICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwidHJcIiwgeyBrZXk6IHNsYXRNZXRhLmtleSwgcmVmOiBzbGF0RWxSZWZzLmNyZWF0ZVJlZihzbGF0TWV0YS5rZXkpIH0sXG4gICAgICAgICAgICAgICAgcHJvcHMuYXhpcyAmJiAoY3JlYXRlRWxlbWVudChUaW1lQ29sc0F4aXNDZWxsLCBPYmplY3QuYXNzaWduKHt9LCBzbGF0TWV0YSkpKSxcbiAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KENvbnRlbnRDb250YWluZXIsIHsgZWxUYWc6IFwidGRcIiwgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmMtdGltZWdyaWQtc2xvdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmMtdGltZWdyaWQtc2xvdC1sYW5lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICFzbGF0TWV0YS5pc0xhYmVsZWQgJiYgJ2ZjLXRpbWVncmlkLXNsb3QtbWlub3InLFxuICAgICAgICAgICAgICAgICAgICBdLCBlbEF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS10aW1lJzogc2xhdE1ldGEuaXNvVGltZVN0cixcbiAgICAgICAgICAgICAgICAgICAgfSwgcmVuZGVyUHJvcHM6IHJlbmRlclByb3BzLCBnZW5lcmF0b3JOYW1lOiBcInNsb3RMYW5lQ29udGVudFwiLCBjdXN0b21HZW5lcmF0b3I6IG9wdGlvbnMuc2xvdExhbmVDb250ZW50LCBjbGFzc05hbWVHZW5lcmF0b3I6IG9wdGlvbnMuc2xvdExhbmVDbGFzc05hbWVzLCBkaWRNb3VudDogb3B0aW9ucy5zbG90TGFuZURpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy5zbG90TGFuZVdpbGxVbm1vdW50IH0pKSk7XG4gICAgICAgIH0pKSk7XG4gICAgfVxufVxuXG4vKlxuZm9yIHRoZSBob3Jpem9udGFsIFwic2xhdHNcIiB0aGF0IHJ1biB3aWR0aC13aXNlLiBIYXMgYSB0aW1lIGF4aXMgb24gYSBzaWRlLiBEZXBlbmRzIG9uIFJUTC5cbiovXG5jbGFzcyBUaW1lQ29sc1NsYXRzIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMucm9vdEVsUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIHRoaXMuc2xhdEVsUmVmcyA9IG5ldyBSZWZNYXAoKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiB0aGlzLnJvb3RFbFJlZiwgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLXNsb3RzXCIgfSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJ0YWJsZVwiLCB7IFwiYXJpYS1oaWRkZW5cIjogdHJ1ZSwgY2xhc3NOYW1lOiBjb250ZXh0LnRoZW1lLmdldENsYXNzKCd0YWJsZScpLCBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICBtaW5XaWR0aDogcHJvcHMudGFibGVNaW5XaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHByb3BzLm1pbkhlaWdodCxcbiAgICAgICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICAgICAgcHJvcHMudGFibGVDb2xHcm91cE5vZGUgLyogcmVsaWVzIG9uIHRoZXJlIG9ubHkgYmVpbmcgYSBzaW5nbGUgPGNvbD4gZm9yIHRoZSBheGlzICovLFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoVGltZUNvbHNTbGF0c0JvZHksIHsgc2xhdEVsUmVmczogdGhpcy5zbGF0RWxSZWZzLCBheGlzOiBwcm9wcy5heGlzLCBzbGF0TWV0YXM6IHByb3BzLnNsYXRNZXRhcyB9KSkpKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU2l6aW5nKCk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVTaXppbmcoKTtcbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLm9uQ29vcmRzKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uQ29vcmRzKG51bGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZVNpemluZygpIHtcbiAgICAgICAgbGV0IHsgY29udGV4dCwgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGlmIChwcm9wcy5vbkNvb3JkcyAmJlxuICAgICAgICAgICAgcHJvcHMuY2xpZW50V2lkdGggIT09IG51bGwgLy8gbWVhbnMgc2l6aW5nIGhhcyBzdGFiaWxpemVkXG4gICAgICAgICkge1xuICAgICAgICAgICAgbGV0IHJvb3RFbCA9IHRoaXMucm9vdEVsUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICBpZiAocm9vdEVsLm9mZnNldEhlaWdodCkgeyAvLyBub3QgaGlkZGVuIGJ5IGNzc1xuICAgICAgICAgICAgICAgIHByb3BzLm9uQ29vcmRzKG5ldyBUaW1lQ29sc1NsYXRzQ29vcmRzKG5ldyBQb3NpdGlvbkNhY2hlKHRoaXMucm9vdEVsUmVmLmN1cnJlbnQsIGNvbGxlY3RTbGF0RWxzKHRoaXMuc2xhdEVsUmVmcy5jdXJyZW50TWFwLCBwcm9wcy5zbGF0TWV0YXMpLCBmYWxzZSwgdHJ1ZSksIHRoaXMucHJvcHMuZGF0ZVByb2ZpbGUsIGNvbnRleHQub3B0aW9ucy5zbG90RHVyYXRpb24pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbGxlY3RTbGF0RWxzKGVsTWFwLCBzbGF0TWV0YXMpIHtcbiAgICByZXR1cm4gc2xhdE1ldGFzLm1hcCgoc2xhdE1ldGEpID0+IGVsTWFwW3NsYXRNZXRhLmtleV0pO1xufVxuXG5mdW5jdGlvbiBzcGxpdFNlZ3NCeUNvbChzZWdzLCBjb2xDbnQpIHtcbiAgICBsZXQgc2Vnc0J5Q29sID0gW107XG4gICAgbGV0IGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGNvbENudDsgaSArPSAxKSB7XG4gICAgICAgIHNlZ3NCeUNvbC5wdXNoKFtdKTtcbiAgICB9XG4gICAgaWYgKHNlZ3MpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHNlZ3NCeUNvbFtzZWdzW2ldLmNvbF0ucHVzaChzZWdzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2Vnc0J5Q29sO1xufVxuZnVuY3Rpb24gc3BsaXRJbnRlcmFjdGlvbkJ5Q29sKHVpLCBjb2xDbnQpIHtcbiAgICBsZXQgYnlSb3cgPSBbXTtcbiAgICBpZiAoIXVpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sQ250OyBpICs9IDEpIHtcbiAgICAgICAgICAgIGJ5Um93W2ldID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xDbnQ7IGkgKz0gMSkge1xuICAgICAgICAgICAgYnlSb3dbaV0gPSB7XG4gICAgICAgICAgICAgICAgYWZmZWN0ZWRJbnN0YW5jZXM6IHVpLmFmZmVjdGVkSW5zdGFuY2VzLFxuICAgICAgICAgICAgICAgIGlzRXZlbnQ6IHVpLmlzRXZlbnQsXG4gICAgICAgICAgICAgICAgc2VnczogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHNlZyBvZiB1aS5zZWdzKSB7XG4gICAgICAgICAgICBieVJvd1tzZWcuY29sXS5zZWdzLnB1c2goc2VnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYnlSb3c7XG59XG5cbmNsYXNzIFRpbWVDb2xNb3JlTGluayBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChNb3JlTGlua0NvbnRhaW5lciwgeyBlbENsYXNzZXM6IFsnZmMtdGltZWdyaWQtbW9yZS1saW5rJ10sIGVsU3R5bGU6IHtcbiAgICAgICAgICAgICAgICB0b3A6IHByb3BzLnRvcCxcbiAgICAgICAgICAgICAgICBib3R0b206IHByb3BzLmJvdHRvbSxcbiAgICAgICAgICAgIH0sIGFsbERheURhdGU6IG51bGwsIG1vcmVDbnQ6IHByb3BzLmhpZGRlblNlZ3MubGVuZ3RoLCBhbGxTZWdzOiBwcm9wcy5oaWRkZW5TZWdzLCBoaWRkZW5TZWdzOiBwcm9wcy5oaWRkZW5TZWdzLCBleHRyYURhdGVTcGFuOiBwcm9wcy5leHRyYURhdGVTcGFuLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsIHBvcG92ZXJDb250ZW50OiAoKSA9PiByZW5kZXJQbGFpbkZnU2Vncyhwcm9wcy5oaWRkZW5TZWdzLCBwcm9wcyksIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlck1vcmVMaW5rSW5uZXIsIGZvcmNlVGltZWQ6IHRydWUgfSwgKElubmVyQ29udGVudCkgPT4gKGNyZWF0ZUVsZW1lbnQoSW5uZXJDb250ZW50LCB7IGVsVGFnOiBcImRpdlwiLCBlbENsYXNzZXM6IFsnZmMtdGltZWdyaWQtbW9yZS1saW5rLWlubmVyJywgJ2ZjLXN0aWNreSddIH0pKSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbmRlck1vcmVMaW5rSW5uZXIocHJvcHMpIHtcbiAgICByZXR1cm4gcHJvcHMuc2hvcnRUZXh0O1xufVxuXG4vLyBzZWdJbnB1dHMgYXNzdW1lZCBzb3J0ZWRcbmZ1bmN0aW9uIGJ1aWxkUG9zaXRpb25pbmcoc2VnSW5wdXRzLCBzdHJpY3RPcmRlciwgbWF4U3RhY2tDbnQpIHtcbiAgICBsZXQgaGllcmFyY2h5ID0gbmV3IFNlZ0hpZXJhcmNoeSgpO1xuICAgIGlmIChzdHJpY3RPcmRlciAhPSBudWxsKSB7XG4gICAgICAgIGhpZXJhcmNoeS5zdHJpY3RPcmRlciA9IHN0cmljdE9yZGVyO1xuICAgIH1cbiAgICBpZiAobWF4U3RhY2tDbnQgIT0gbnVsbCkge1xuICAgICAgICBoaWVyYXJjaHkubWF4U3RhY2tDbnQgPSBtYXhTdGFja0NudDtcbiAgICB9XG4gICAgbGV0IGhpZGRlbkVudHJpZXMgPSBoaWVyYXJjaHkuYWRkU2VncyhzZWdJbnB1dHMpO1xuICAgIGxldCBoaWRkZW5Hcm91cHMgPSBncm91cEludGVyc2VjdGluZ0VudHJpZXMoaGlkZGVuRW50cmllcyk7XG4gICAgbGV0IHdlYiA9IGJ1aWxkV2ViKGhpZXJhcmNoeSk7XG4gICAgd2ViID0gc3RyZXRjaFdlYih3ZWIsIDEpOyAvLyBhbGwgbGV2ZWxDb29yZHMvdGhpY2tuZXNzIHdpbGwgaGF2ZSAwLjAtMS4wXG4gICAgbGV0IHNlZ1JlY3RzID0gd2ViVG9SZWN0cyh3ZWIpO1xuICAgIHJldHVybiB7IHNlZ1JlY3RzLCBoaWRkZW5Hcm91cHMgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkV2ViKGhpZXJhcmNoeSkge1xuICAgIGNvbnN0IHsgZW50cmllc0J5TGV2ZWwgfSA9IGhpZXJhcmNoeTtcbiAgICBjb25zdCBidWlsZE5vZGUgPSBjYWNoZWFibGUoKGxldmVsLCBsYXRlcmFsKSA9PiBsZXZlbCArICc6JyArIGxhdGVyYWwsIChsZXZlbCwgbGF0ZXJhbCkgPT4ge1xuICAgICAgICBsZXQgc2libGluZ1JhbmdlID0gZmluZE5leHRMZXZlbFNlZ3MoaGllcmFyY2h5LCBsZXZlbCwgbGF0ZXJhbCk7XG4gICAgICAgIGxldCBuZXh0TGV2ZWxSZXMgPSBidWlsZE5vZGVzKHNpYmxpbmdSYW5nZSwgYnVpbGROb2RlKTtcbiAgICAgICAgbGV0IGVudHJ5ID0gZW50cmllc0J5TGV2ZWxbbGV2ZWxdW2xhdGVyYWxdO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBlbnRyeSksIHsgbmV4dExldmVsTm9kZXM6IG5leHRMZXZlbFJlc1swXSB9KSxcbiAgICAgICAgICAgIGVudHJ5LnRoaWNrbmVzcyArIG5leHRMZXZlbFJlc1sxXSwgLy8gdGhlIHByZXNzdXJlIGJ1aWxkc1xuICAgICAgICBdO1xuICAgIH0pO1xuICAgIHJldHVybiBidWlsZE5vZGVzKGVudHJpZXNCeUxldmVsLmxlbmd0aFxuICAgICAgICA/IHsgbGV2ZWw6IDAsIGxhdGVyYWxTdGFydDogMCwgbGF0ZXJhbEVuZDogZW50cmllc0J5TGV2ZWxbMF0ubGVuZ3RoIH1cbiAgICAgICAgOiBudWxsLCBidWlsZE5vZGUpWzBdO1xufVxuZnVuY3Rpb24gYnVpbGROb2RlcyhzaWJsaW5nUmFuZ2UsIGJ1aWxkTm9kZSkge1xuICAgIGlmICghc2libGluZ1JhbmdlKSB7XG4gICAgICAgIHJldHVybiBbW10sIDBdO1xuICAgIH1cbiAgICBsZXQgeyBsZXZlbCwgbGF0ZXJhbFN0YXJ0LCBsYXRlcmFsRW5kIH0gPSBzaWJsaW5nUmFuZ2U7XG4gICAgbGV0IGxhdGVyYWwgPSBsYXRlcmFsU3RhcnQ7XG4gICAgbGV0IHBhaXJzID0gW107XG4gICAgd2hpbGUgKGxhdGVyYWwgPCBsYXRlcmFsRW5kKSB7XG4gICAgICAgIHBhaXJzLnB1c2goYnVpbGROb2RlKGxldmVsLCBsYXRlcmFsKSk7XG4gICAgICAgIGxhdGVyYWwgKz0gMTtcbiAgICB9XG4gICAgcGFpcnMuc29ydChjbXBEZXNjUHJlc3N1cmVzKTtcbiAgICByZXR1cm4gW1xuICAgICAgICBwYWlycy5tYXAoZXh0cmFjdE5vZGUpLFxuICAgICAgICBwYWlyc1swXVsxXSwgLy8gZmlyc3QgaXRlbSdzIHByZXNzdXJlXG4gICAgXTtcbn1cbmZ1bmN0aW9uIGNtcERlc2NQcmVzc3VyZXMoYSwgYikge1xuICAgIHJldHVybiBiWzFdIC0gYVsxXTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3ROb2RlKGEpIHtcbiAgICByZXR1cm4gYVswXTtcbn1cbmZ1bmN0aW9uIGZpbmROZXh0TGV2ZWxTZWdzKGhpZXJhcmNoeSwgc3ViamVjdExldmVsLCBzdWJqZWN0TGF0ZXJhbCkge1xuICAgIGxldCB7IGxldmVsQ29vcmRzLCBlbnRyaWVzQnlMZXZlbCB9ID0gaGllcmFyY2h5O1xuICAgIGxldCBzdWJqZWN0RW50cnkgPSBlbnRyaWVzQnlMZXZlbFtzdWJqZWN0TGV2ZWxdW3N1YmplY3RMYXRlcmFsXTtcbiAgICBsZXQgYWZ0ZXJTdWJqZWN0ID0gbGV2ZWxDb29yZHNbc3ViamVjdExldmVsXSArIHN1YmplY3RFbnRyeS50aGlja25lc3M7XG4gICAgbGV0IGxldmVsQ250ID0gbGV2ZWxDb29yZHMubGVuZ3RoO1xuICAgIGxldCBsZXZlbCA9IHN1YmplY3RMZXZlbDtcbiAgICAvLyBza2lwIHBhc3QgbGV2ZWxzIHRoYXQgYXJlIHRvbyBoaWdoIHVwXG4gICAgZm9yICg7IGxldmVsIDwgbGV2ZWxDbnQgJiYgbGV2ZWxDb29yZHNbbGV2ZWxdIDwgYWZ0ZXJTdWJqZWN0OyBsZXZlbCArPSAxKVxuICAgICAgICA7IC8vIGRvIG5vdGhpbmdcbiAgICBmb3IgKDsgbGV2ZWwgPCBsZXZlbENudDsgbGV2ZWwgKz0gMSkge1xuICAgICAgICBsZXQgZW50cmllcyA9IGVudHJpZXNCeUxldmVsW2xldmVsXTtcbiAgICAgICAgbGV0IGVudHJ5O1xuICAgICAgICBsZXQgc2VhcmNoSW5kZXggPSBiaW5hcnlTZWFyY2goZW50cmllcywgc3ViamVjdEVudHJ5LnNwYW4uc3RhcnQsIGdldEVudHJ5U3BhbkVuZCk7XG4gICAgICAgIGxldCBsYXRlcmFsU3RhcnQgPSBzZWFyY2hJbmRleFswXSArIHNlYXJjaEluZGV4WzFdOyAvLyBpZiBleGFjdCBtYXRjaCAod2hpY2ggZG9lc24ndCBjb2xsaWRlKSwgZ28gdG8gbmV4dCBvbmVcbiAgICAgICAgbGV0IGxhdGVyYWxFbmQgPSBsYXRlcmFsU3RhcnQ7XG4gICAgICAgIHdoaWxlICggLy8gbG9vcCB0aHJvdWdoIGVudHJpZXMgdGhhdCBob3Jpem9udGFsbHkgaW50ZXJzZWN0XG4gICAgICAgIChlbnRyeSA9IGVudHJpZXNbbGF0ZXJhbEVuZF0pICYmIC8vIGJ1dCBub3QgcGFzdCB0aGUgd2hvbGUgc2VnIGxpc3RcbiAgICAgICAgICAgIGVudHJ5LnNwYW4uc3RhcnQgPCBzdWJqZWN0RW50cnkuc3Bhbi5lbmQpIHtcbiAgICAgICAgICAgIGxhdGVyYWxFbmQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGF0ZXJhbFN0YXJ0IDwgbGF0ZXJhbEVuZCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbGV2ZWwsIGxhdGVyYWxTdGFydCwgbGF0ZXJhbEVuZCB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gc3RyZXRjaFdlYih0b3BMZXZlbE5vZGVzLCB0b3RhbFRoaWNrbmVzcykge1xuICAgIGNvbnN0IHN0cmV0Y2hOb2RlID0gY2FjaGVhYmxlKChub2RlLCBzdGFydENvb3JkLCBwcmV2VGhpY2tuZXNzKSA9PiBidWlsZEVudHJ5S2V5KG5vZGUpLCAobm9kZSwgc3RhcnRDb29yZCwgcHJldlRoaWNrbmVzcykgPT4ge1xuICAgICAgICBsZXQgeyBuZXh0TGV2ZWxOb2RlcywgdGhpY2tuZXNzIH0gPSBub2RlO1xuICAgICAgICBsZXQgYWxsVGhpY2tuZXNzID0gdGhpY2tuZXNzICsgcHJldlRoaWNrbmVzcztcbiAgICAgICAgbGV0IHRoaWNrbmVzc0ZyYWN0aW9uID0gdGhpY2tuZXNzIC8gYWxsVGhpY2tuZXNzO1xuICAgICAgICBsZXQgZW5kQ29vcmQ7XG4gICAgICAgIGxldCBuZXdDaGlsZHJlbiA9IFtdO1xuICAgICAgICBpZiAoIW5leHRMZXZlbE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgZW5kQ29vcmQgPSB0b3RhbFRoaWNrbmVzcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNoaWxkTm9kZSBvZiBuZXh0TGV2ZWxOb2Rlcykge1xuICAgICAgICAgICAgICAgIGlmIChlbmRDb29yZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXMgPSBzdHJldGNoTm9kZShjaGlsZE5vZGUsIHN0YXJ0Q29vcmQsIGFsbFRoaWNrbmVzcyk7XG4gICAgICAgICAgICAgICAgICAgIGVuZENvb3JkID0gcmVzWzBdO1xuICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbi5wdXNoKHJlc1sxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzID0gc3RyZXRjaE5vZGUoY2hpbGROb2RlLCBlbmRDb29yZCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuLnB1c2gocmVzWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld1RoaWNrbmVzcyA9IChlbmRDb29yZCAtIHN0YXJ0Q29vcmQpICogdGhpY2tuZXNzRnJhY3Rpb247XG4gICAgICAgIHJldHVybiBbZW5kQ29vcmQgLSBuZXdUaGlja25lc3MsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbm9kZSksIHsgdGhpY2tuZXNzOiBuZXdUaGlja25lc3MsIG5leHRMZXZlbE5vZGVzOiBuZXdDaGlsZHJlbiB9KV07XG4gICAgfSk7XG4gICAgcmV0dXJuIHRvcExldmVsTm9kZXMubWFwKChub2RlKSA9PiBzdHJldGNoTm9kZShub2RlLCAwLCAwKVsxXSk7XG59XG4vLyBub3Qgc29ydGVkIGluIGFueSBwYXJ0aWN1bGFyIG9yZGVyXG5mdW5jdGlvbiB3ZWJUb1JlY3RzKHRvcExldmVsTm9kZXMpIHtcbiAgICBsZXQgcmVjdHMgPSBbXTtcbiAgICBjb25zdCBwcm9jZXNzTm9kZSA9IGNhY2hlYWJsZSgobm9kZSwgbGV2ZWxDb29yZCwgc3RhY2tEZXB0aCkgPT4gYnVpbGRFbnRyeUtleShub2RlKSwgKG5vZGUsIGxldmVsQ29vcmQsIHN0YWNrRGVwdGgpID0+IHtcbiAgICAgICAgbGV0IHJlY3QgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG5vZGUpLCB7IGxldmVsQ29vcmQsXG4gICAgICAgICAgICBzdGFja0RlcHRoLCBzdGFja0ZvcndhcmQ6IDAgfSk7XG4gICAgICAgIHJlY3RzLnB1c2gocmVjdCk7XG4gICAgICAgIHJldHVybiAocmVjdC5zdGFja0ZvcndhcmQgPSBwcm9jZXNzTm9kZXMobm9kZS5uZXh0TGV2ZWxOb2RlcywgbGV2ZWxDb29yZCArIG5vZGUudGhpY2tuZXNzLCBzdGFja0RlcHRoICsgMSkgKyAxKTtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBwcm9jZXNzTm9kZXMobm9kZXMsIGxldmVsQ29vcmQsIHN0YWNrRGVwdGgpIHtcbiAgICAgICAgbGV0IHN0YWNrRm9yd2FyZCA9IDA7XG4gICAgICAgIGZvciAobGV0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgICAgICAgIHN0YWNrRm9yd2FyZCA9IE1hdGgubWF4KHByb2Nlc3NOb2RlKG5vZGUsIGxldmVsQ29vcmQsIHN0YWNrRGVwdGgpLCBzdGFja0ZvcndhcmQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGFja0ZvcndhcmQ7XG4gICAgfVxuICAgIHByb2Nlc3NOb2Rlcyh0b3BMZXZlbE5vZGVzLCAwLCAwKTtcbiAgICByZXR1cm4gcmVjdHM7IC8vIFRPRE86IHNvcnQgcmVjdHMgYnkgbGV2ZWxDb29yZCB0byBiZSBjb25zaXN0ZW50IHdpdGggdG9SZWN0cz9cbn1cbi8vIFRPRE86IG1vdmUgdG8gZ2VuZXJhbCB1dGlsXG5mdW5jdGlvbiBjYWNoZWFibGUoa2V5RnVuYywgd29ya0Z1bmMpIHtcbiAgICBjb25zdCBjYWNoZSA9IHt9O1xuICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICBsZXQga2V5ID0ga2V5RnVuYyguLi5hcmdzKTtcbiAgICAgICAgcmV0dXJuIChrZXkgaW4gY2FjaGUpXG4gICAgICAgICAgICA/IGNhY2hlW2tleV1cbiAgICAgICAgICAgIDogKGNhY2hlW2tleV0gPSB3b3JrRnVuYyguLi5hcmdzKSk7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZVNlZ1ZDb29yZHMoc2VncywgY29sRGF0ZSwgc2xhdENvb3JkcyA9IG51bGwsIGV2ZW50TWluSGVpZ2h0ID0gMCkge1xuICAgIGxldCB2Y29vcmRzID0gW107XG4gICAgaWYgKHNsYXRDb29yZHMpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBsZXQgc2VnID0gc2Vnc1tpXTtcbiAgICAgICAgICAgIGxldCBzcGFuU3RhcnQgPSBzbGF0Q29vcmRzLmNvbXB1dGVEYXRlVG9wKHNlZy5zdGFydCwgY29sRGF0ZSk7XG4gICAgICAgICAgICBsZXQgc3BhbkVuZCA9IE1hdGgubWF4KHNwYW5TdGFydCArIChldmVudE1pbkhlaWdodCB8fCAwKSwgLy8gOihcbiAgICAgICAgICAgIHNsYXRDb29yZHMuY29tcHV0ZURhdGVUb3Aoc2VnLmVuZCwgY29sRGF0ZSkpO1xuICAgICAgICAgICAgdmNvb3Jkcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBzdGFydDogTWF0aC5yb3VuZChzcGFuU3RhcnQpLFxuICAgICAgICAgICAgICAgIGVuZDogTWF0aC5yb3VuZChzcGFuRW5kKSwgLy9cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2Y29vcmRzO1xufVxuZnVuY3Rpb24gY29tcHV0ZUZnU2VnUGxhY2VtZW50cyhzZWdzLCBzZWdWQ29vcmRzLCAvLyBtaWdodCBub3QgaGF2ZSBmb3IgZXZlcnkgc2VnXG5ldmVudE9yZGVyU3RyaWN0LCBldmVudE1heFN0YWNrKSB7XG4gICAgbGV0IHNlZ0lucHV0cyA9IFtdO1xuICAgIGxldCBkdW1iU2VncyA9IFtdOyAvLyBzZWdzIHdpdGhvdXQgY29vcmRzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGxldCB2Y29vcmRzID0gc2VnVkNvb3Jkc1tpXTtcbiAgICAgICAgaWYgKHZjb29yZHMpIHtcbiAgICAgICAgICAgIHNlZ0lucHV0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICB0aGlja25lc3M6IDEsXG4gICAgICAgICAgICAgICAgc3BhbjogdmNvb3JkcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZHVtYlNlZ3MucHVzaChzZWdzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgeyBzZWdSZWN0cywgaGlkZGVuR3JvdXBzIH0gPSBidWlsZFBvc2l0aW9uaW5nKHNlZ0lucHV0cywgZXZlbnRPcmRlclN0cmljdCwgZXZlbnRNYXhTdGFjayk7XG4gICAgbGV0IHNlZ1BsYWNlbWVudHMgPSBbXTtcbiAgICBmb3IgKGxldCBzZWdSZWN0IG9mIHNlZ1JlY3RzKSB7XG4gICAgICAgIHNlZ1BsYWNlbWVudHMucHVzaCh7XG4gICAgICAgICAgICBzZWc6IHNlZ3Nbc2VnUmVjdC5pbmRleF0sXG4gICAgICAgICAgICByZWN0OiBzZWdSZWN0LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZm9yIChsZXQgZHVtYlNlZyBvZiBkdW1iU2Vncykge1xuICAgICAgICBzZWdQbGFjZW1lbnRzLnB1c2goeyBzZWc6IGR1bWJTZWcsIHJlY3Q6IG51bGwgfSk7XG4gICAgfVxuICAgIHJldHVybiB7IHNlZ1BsYWNlbWVudHMsIGhpZGRlbkdyb3VwcyB9O1xufVxuXG5jb25zdCBERUZBVUxUX1RJTUVfRk9STUFUID0gY3JlYXRlRm9ybWF0dGVyKHtcbiAgICBob3VyOiAnbnVtZXJpYycsXG4gICAgbWludXRlOiAnMi1kaWdpdCcsXG4gICAgbWVyaWRpZW06IGZhbHNlLFxufSk7XG5jbGFzcyBUaW1lQ29sRXZlbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChTdGFuZGFyZEV2ZW50LCBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb3BzLCB7IGVsQ2xhc3NlczogW1xuICAgICAgICAgICAgICAgICdmYy10aW1lZ3JpZC1ldmVudCcsXG4gICAgICAgICAgICAgICAgJ2ZjLXYtZXZlbnQnLFxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuaXNTaG9ydCAmJiAnZmMtdGltZWdyaWQtZXZlbnQtc2hvcnQnLFxuICAgICAgICAgICAgXSwgZGVmYXVsdFRpbWVGb3JtYXQ6IERFRkFVTFRfVElNRV9GT1JNQVQgfSkpKTtcbiAgICB9XG59XG5cbmNsYXNzIFRpbWVDb2wgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5zb3J0RXZlbnRTZWdzID0gbWVtb2l6ZShzb3J0RXZlbnRTZWdzKTtcbiAgICB9XG4gICAgLy8gVE9ETzogbWVtb2l6ZSBldmVudC1wbGFjZW1lbnQ/XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgb3B0aW9ucyB9ID0gY29udGV4dDtcbiAgICAgICAgbGV0IGlzU2VsZWN0TWlycm9yID0gb3B0aW9ucy5zZWxlY3RNaXJyb3I7XG4gICAgICAgIGxldCBtaXJyb3JTZWdzID0gLy8geXVja1xuICAgICAgICAgKHByb3BzLmV2ZW50RHJhZyAmJiBwcm9wcy5ldmVudERyYWcuc2VncykgfHxcbiAgICAgICAgICAgIChwcm9wcy5ldmVudFJlc2l6ZSAmJiBwcm9wcy5ldmVudFJlc2l6ZS5zZWdzKSB8fFxuICAgICAgICAgICAgKGlzU2VsZWN0TWlycm9yICYmIHByb3BzLmRhdGVTZWxlY3Rpb25TZWdzKSB8fFxuICAgICAgICAgICAgW107XG4gICAgICAgIGxldCBpbnRlcmFjdGlvbkFmZmVjdGVkSW5zdGFuY2VzID0gLy8gVE9ETzogbWVzc3kgd2F5IHRvIGNvbXB1dGUgdGhpc1xuICAgICAgICAgKHByb3BzLmV2ZW50RHJhZyAmJiBwcm9wcy5ldmVudERyYWcuYWZmZWN0ZWRJbnN0YW5jZXMpIHx8XG4gICAgICAgICAgICAocHJvcHMuZXZlbnRSZXNpemUgJiYgcHJvcHMuZXZlbnRSZXNpemUuYWZmZWN0ZWRJbnN0YW5jZXMpIHx8XG4gICAgICAgICAgICB7fTtcbiAgICAgICAgbGV0IHNvcnRlZEZnU2VncyA9IHRoaXMuc29ydEV2ZW50U2Vncyhwcm9wcy5mZ0V2ZW50U2Vncywgb3B0aW9ucy5ldmVudE9yZGVyKTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KERheUNlbGxDb250YWluZXIsIHsgZWxUYWc6IFwidGRcIiwgZWxSZWY6IHByb3BzLmVsUmVmLCBlbENsYXNzZXM6IFtcbiAgICAgICAgICAgICAgICAnZmMtdGltZWdyaWQtY29sJyxcbiAgICAgICAgICAgICAgICAuLi4ocHJvcHMuZXh0cmFDbGFzc05hbWVzIHx8IFtdKSxcbiAgICAgICAgICAgIF0sIGVsQXR0cnM6IE9iamVjdC5hc3NpZ24oeyByb2xlOiAnZ3JpZGNlbGwnIH0sIHByb3BzLmV4dHJhRGF0YUF0dHJzKSwgZGF0ZTogcHJvcHMuZGF0ZSwgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlLCBleHRyYVJlbmRlclByb3BzOiBwcm9wcy5leHRyYVJlbmRlclByb3BzIH0sIChJbm5lckNvbnRlbnQpID0+IChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWNvbC1mcmFtZVwiIH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWNvbC1iZ1wiIH0sXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJGaWxsU2Vncyhwcm9wcy5idXNpbmVzc0hvdXJTZWdzLCAnbm9uLWJ1c2luZXNzJyksXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJGaWxsU2Vncyhwcm9wcy5iZ0V2ZW50U2VncywgJ2JnLWV2ZW50JyksXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJGaWxsU2Vncyhwcm9wcy5kYXRlU2VsZWN0aW9uU2VncywgJ2hpZ2hsaWdodCcpKSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtY29sLWV2ZW50c1wiIH0sIHRoaXMucmVuZGVyRmdTZWdzKHNvcnRlZEZnU2VncywgaW50ZXJhY3Rpb25BZmZlY3RlZEluc3RhbmNlcywgZmFsc2UsIGZhbHNlLCBmYWxzZSkpLFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1jb2wtZXZlbnRzXCIgfSwgdGhpcy5yZW5kZXJGZ1NlZ3MobWlycm9yU2Vncywge30sIEJvb2xlYW4ocHJvcHMuZXZlbnREcmFnKSwgQm9vbGVhbihwcm9wcy5ldmVudFJlc2l6ZSksIEJvb2xlYW4oaXNTZWxlY3RNaXJyb3IpLCAnbWlycm9yJykpLFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1ub3ctaW5kaWNhdG9yLWNvbnRhaW5lclwiIH0sIHRoaXMucmVuZGVyTm93SW5kaWNhdG9yKHByb3BzLm5vd0luZGljYXRvclNlZ3MpKSxcbiAgICAgICAgICAgIGhhc0N1c3RvbURheUNlbGxDb250ZW50KG9wdGlvbnMpICYmIChjcmVhdGVFbGVtZW50KElubmVyQ29udGVudCwgeyBlbFRhZzogXCJkaXZcIiwgZWxDbGFzc2VzOiBbJ2ZjLXRpbWVncmlkLWNvbC1taXNjJ10gfSkpKSkpKTtcbiAgICB9XG4gICAgcmVuZGVyRmdTZWdzKHNvcnRlZEZnU2Vncywgc2VnSXNJbnZpc2libGUsIGlzRHJhZ2dpbmcsIGlzUmVzaXppbmcsIGlzRGF0ZVNlbGVjdGluZywgZm9yY2VkS2V5KSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBpZiAocHJvcHMuZm9yUHJpbnQpIHtcbiAgICAgICAgICAgIHJldHVybiByZW5kZXJQbGFpbkZnU2Vncyhzb3J0ZWRGZ1NlZ3MsIHByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJQb3NpdGlvbmVkRmdTZWdzKHNvcnRlZEZnU2Vncywgc2VnSXNJbnZpc2libGUsIGlzRHJhZ2dpbmcsIGlzUmVzaXppbmcsIGlzRGF0ZVNlbGVjdGluZywgZm9yY2VkS2V5KTtcbiAgICB9XG4gICAgcmVuZGVyUG9zaXRpb25lZEZnU2VncyhzZWdzLCAvLyBpZiBub3QgbWlycm9yLCBuZWVkcyB0byBiZSBzb3J0ZWRcbiAgICBzZWdJc0ludmlzaWJsZSwgaXNEcmFnZ2luZywgaXNSZXNpemluZywgaXNEYXRlU2VsZWN0aW5nLCBmb3JjZWRLZXkpIHtcbiAgICAgICAgbGV0IHsgZXZlbnRNYXhTdGFjaywgZXZlbnRTaG9ydEhlaWdodCwgZXZlbnRPcmRlclN0cmljdCwgZXZlbnRNaW5IZWlnaHQgfSA9IHRoaXMuY29udGV4dC5vcHRpb25zO1xuICAgICAgICBsZXQgeyBkYXRlLCBzbGF0Q29vcmRzLCBldmVudFNlbGVjdGlvbiwgdG9kYXlSYW5nZSwgbm93RGF0ZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IGlzTWlycm9yID0gaXNEcmFnZ2luZyB8fCBpc1Jlc2l6aW5nIHx8IGlzRGF0ZVNlbGVjdGluZztcbiAgICAgICAgbGV0IHNlZ1ZDb29yZHMgPSBjb21wdXRlU2VnVkNvb3JkcyhzZWdzLCBkYXRlLCBzbGF0Q29vcmRzLCBldmVudE1pbkhlaWdodCk7XG4gICAgICAgIGxldCB7IHNlZ1BsYWNlbWVudHMsIGhpZGRlbkdyb3VwcyB9ID0gY29tcHV0ZUZnU2VnUGxhY2VtZW50cyhzZWdzLCBzZWdWQ29vcmRzLCBldmVudE9yZGVyU3RyaWN0LCBldmVudE1heFN0YWNrKTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJIaWRkZW5Hcm91cHMoaGlkZGVuR3JvdXBzLCBzZWdzKSxcbiAgICAgICAgICAgIHNlZ1BsYWNlbWVudHMubWFwKChzZWdQbGFjZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgeyBzZWcsIHJlY3QgfSA9IHNlZ1BsYWNlbWVudDtcbiAgICAgICAgICAgICAgICBsZXQgaW5zdGFuY2VJZCA9IHNlZy5ldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWQ7XG4gICAgICAgICAgICAgICAgbGV0IGlzVmlzaWJsZSA9IGlzTWlycm9yIHx8IEJvb2xlYW4oIXNlZ0lzSW52aXNpYmxlW2luc3RhbmNlSWRdICYmIHJlY3QpO1xuICAgICAgICAgICAgICAgIGxldCB2U3R5bGUgPSBjb21wdXRlU2VnVlN0eWxlKHJlY3QgJiYgcmVjdC5zcGFuKTtcbiAgICAgICAgICAgICAgICBsZXQgaFN0eWxlID0gKCFpc01pcnJvciAmJiByZWN0KSA/IHRoaXMuY29tcHV0ZVNlZ0hTdHlsZShyZWN0KSA6IHsgbGVmdDogMCwgcmlnaHQ6IDAgfTtcbiAgICAgICAgICAgICAgICBsZXQgaXNJbnNldCA9IEJvb2xlYW4ocmVjdCkgJiYgcmVjdC5zdGFja0ZvcndhcmQgPiAwO1xuICAgICAgICAgICAgICAgIGxldCBpc1Nob3J0ID0gQm9vbGVhbihyZWN0KSAmJiAocmVjdC5zcGFuLmVuZCAtIHJlY3Quc3Bhbi5zdGFydCkgPCBldmVudFNob3J0SGVpZ2h0OyAvLyBsb29rIGF0IG90aGVyIHBsYWNlcyBmb3IgdGhpcyBwcm9ibGVtXG4gICAgICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiAnZmMtdGltZWdyaWQtZXZlbnQtaGFybmVzcycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKGlzSW5zZXQgPyAnIGZjLXRpbWVncmlkLWV2ZW50LWhhcm5lc3MtaW5zZXQnIDogJycpLCBrZXk6IGZvcmNlZEtleSB8fCBpbnN0YW5jZUlkLCBzdHlsZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgdmlzaWJpbGl0eTogaXNWaXNpYmxlID8gJycgOiAnaGlkZGVuJyB9LCB2U3R5bGUpLCBoU3R5bGUpIH0sXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoVGltZUNvbEV2ZW50LCBPYmplY3QuYXNzaWduKHsgc2VnOiBzZWcsIGlzRHJhZ2dpbmc6IGlzRHJhZ2dpbmcsIGlzUmVzaXppbmc6IGlzUmVzaXppbmcsIGlzRGF0ZVNlbGVjdGluZzogaXNEYXRlU2VsZWN0aW5nLCBpc1NlbGVjdGVkOiBpbnN0YW5jZUlkID09PSBldmVudFNlbGVjdGlvbiwgaXNTaG9ydDogaXNTaG9ydCB9LCBnZXRTZWdNZXRhKHNlZywgdG9kYXlSYW5nZSwgbm93RGF0ZSkpKSkpO1xuICAgICAgICAgICAgfSkpKTtcbiAgICB9XG4gICAgLy8gd2lsbCBhbHJlYWR5IGhhdmUgZXZlbnRNaW5IZWlnaHQgYXBwbGllZCBiZWNhdXNlIHNlZ0lucHV0cyBhbHJlYWR5IGhhZCBpdFxuICAgIHJlbmRlckhpZGRlbkdyb3VwcyhoaWRkZW5Hcm91cHMsIHNlZ3MpIHtcbiAgICAgICAgbGV0IHsgZXh0cmFEYXRlU3BhbiwgZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2UsIG5vd0RhdGUsIGV2ZW50U2VsZWN0aW9uLCBldmVudERyYWcsIGV2ZW50UmVzaXplIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIGhpZGRlbkdyb3Vwcy5tYXAoKGhpZGRlbkdyb3VwKSA9PiB7XG4gICAgICAgICAgICBsZXQgcG9zaXRpb25Dc3MgPSBjb21wdXRlU2VnVlN0eWxlKGhpZGRlbkdyb3VwLnNwYW4pO1xuICAgICAgICAgICAgbGV0IGhpZGRlblNlZ3MgPSBjb21waWxlU2Vnc0Zyb21FbnRyaWVzKGhpZGRlbkdyb3VwLmVudHJpZXMsIHNlZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFRpbWVDb2xNb3JlTGluaywgeyBrZXk6IGJ1aWxkSXNvU3RyaW5nKGNvbXB1dGVFYXJsaWVzdFNlZ1N0YXJ0KGhpZGRlblNlZ3MpKSwgaGlkZGVuU2VnczogaGlkZGVuU2VncywgdG9wOiBwb3NpdGlvbkNzcy50b3AsIGJvdHRvbTogcG9zaXRpb25Dc3MuYm90dG9tLCBleHRyYURhdGVTcGFuOiBleHRyYURhdGVTcGFuLCBkYXRlUHJvZmlsZTogZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2U6IHRvZGF5UmFuZ2UsIG5vd0RhdGU6IG5vd0RhdGUsIGV2ZW50U2VsZWN0aW9uOiBldmVudFNlbGVjdGlvbiwgZXZlbnREcmFnOiBldmVudERyYWcsIGV2ZW50UmVzaXplOiBldmVudFJlc2l6ZSB9KSk7XG4gICAgICAgIH0pKSk7XG4gICAgfVxuICAgIHJlbmRlckZpbGxTZWdzKHNlZ3MsIGZpbGxUeXBlKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBsZXQgc2VnVkNvb3JkcyA9IGNvbXB1dGVTZWdWQ29vcmRzKHNlZ3MsIHByb3BzLmRhdGUsIHByb3BzLnNsYXRDb29yZHMsIGNvbnRleHQub3B0aW9ucy5ldmVudE1pbkhlaWdodCk7IC8vIGRvbid0IGFzc3VtZSBhbGwgcG9wdWxhdGVkXG4gICAgICAgIGxldCBjaGlsZHJlbiA9IHNlZ1ZDb29yZHMubWFwKCh2Y29vcmRzLCBpKSA9PiB7XG4gICAgICAgICAgICBsZXQgc2VnID0gc2Vnc1tpXTtcbiAgICAgICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGtleTogYnVpbGRFdmVudFJhbmdlS2V5KHNlZy5ldmVudFJhbmdlKSwgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWJnLWhhcm5lc3NcIiwgc3R5bGU6IGNvbXB1dGVTZWdWU3R5bGUodmNvb3JkcykgfSwgZmlsbFR5cGUgPT09ICdiZy1ldmVudCcgP1xuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoQmdFdmVudCwgT2JqZWN0LmFzc2lnbih7IHNlZzogc2VnIH0sIGdldFNlZ01ldGEoc2VnLCBwcm9wcy50b2RheVJhbmdlLCBwcm9wcy5ub3dEYXRlKSkpIDpcbiAgICAgICAgICAgICAgICByZW5kZXJGaWxsKGZpbGxUeXBlKSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuKTtcbiAgICB9XG4gICAgcmVuZGVyTm93SW5kaWNhdG9yKHNlZ3MpIHtcbiAgICAgICAgbGV0IHsgc2xhdENvb3JkcywgZGF0ZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgaWYgKCFzbGF0Q29vcmRzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2Vncy5tYXAoKHNlZywgaSkgPT4gKGNyZWF0ZUVsZW1lbnQoTm93SW5kaWNhdG9yQ29udGFpbmVyXG4gICAgICAgIC8vIGtleSBkb2Vzbid0IG1hdHRlci4gd2lsbCBvbmx5IGV2ZXIgYmUgb25lXG4gICAgICAgICwgeyBcbiAgICAgICAgICAgIC8vIGtleSBkb2Vzbid0IG1hdHRlci4gd2lsbCBvbmx5IGV2ZXIgYmUgb25lXG4gICAgICAgICAgICBrZXk6IGksIGVsQ2xhc3NlczogWydmYy10aW1lZ3JpZC1ub3ctaW5kaWNhdG9yLWxpbmUnXSwgZWxTdHlsZToge1xuICAgICAgICAgICAgICAgIHRvcDogc2xhdENvb3Jkcy5jb21wdXRlRGF0ZVRvcChzZWcuc3RhcnQsIGRhdGUpLFxuICAgICAgICAgICAgfSwgaXNBeGlzOiBmYWxzZSwgZGF0ZTogZGF0ZSB9KSkpO1xuICAgIH1cbiAgICBjb21wdXRlU2VnSFN0eWxlKHNlZ0hDb29yZHMpIHtcbiAgICAgICAgbGV0IHsgaXNSdGwsIG9wdGlvbnMgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHNob3VsZE92ZXJsYXAgPSBvcHRpb25zLnNsb3RFdmVudE92ZXJsYXA7XG4gICAgICAgIGxldCBuZWFyQ29vcmQgPSBzZWdIQ29vcmRzLmxldmVsQ29vcmQ7IC8vIHRoZSBsZWZ0IHNpZGUgaWYgTFRSLiB0aGUgcmlnaHQgc2lkZSBpZiBSVEwuIGZsb2F0aW5nLXBvaW50XG4gICAgICAgIGxldCBmYXJDb29yZCA9IHNlZ0hDb29yZHMubGV2ZWxDb29yZCArIHNlZ0hDb29yZHMudGhpY2tuZXNzOyAvLyB0aGUgcmlnaHQgc2lkZSBpZiBMVFIuIHRoZSBsZWZ0IHNpZGUgaWYgUlRMLiBmbG9hdGluZy1wb2ludFxuICAgICAgICBsZXQgbGVmdDsgLy8gYW1vdW50IG9mIHNwYWNlIGZyb20gbGVmdCBlZGdlLCBhIGZyYWN0aW9uIG9mIHRoZSB0b3RhbCB3aWR0aFxuICAgICAgICBsZXQgcmlnaHQ7IC8vIGFtb3VudCBvZiBzcGFjZSBmcm9tIHJpZ2h0IGVkZ2UsIGEgZnJhY3Rpb24gb2YgdGhlIHRvdGFsIHdpZHRoXG4gICAgICAgIGlmIChzaG91bGRPdmVybGFwKSB7XG4gICAgICAgICAgICAvLyBkb3VibGUgdGhlIHdpZHRoLCBidXQgZG9uJ3QgZ28gYmV5b25kIHRoZSBtYXhpbXVtIGZvcndhcmQgY29vcmRpbmF0ZSAoMS4wKVxuICAgICAgICAgICAgZmFyQ29vcmQgPSBNYXRoLm1pbigxLCBuZWFyQ29vcmQgKyAoZmFyQ29vcmQgLSBuZWFyQ29vcmQpICogMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUnRsKSB7XG4gICAgICAgICAgICBsZWZ0ID0gMSAtIGZhckNvb3JkO1xuICAgICAgICAgICAgcmlnaHQgPSBuZWFyQ29vcmQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZWZ0ID0gbmVhckNvb3JkO1xuICAgICAgICAgICAgcmlnaHQgPSAxIC0gZmFyQ29vcmQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByb3BzID0ge1xuICAgICAgICAgICAgekluZGV4OiBzZWdIQ29vcmRzLnN0YWNrRGVwdGggKyAxLFxuICAgICAgICAgICAgbGVmdDogbGVmdCAqIDEwMCArICclJyxcbiAgICAgICAgICAgIHJpZ2h0OiByaWdodCAqIDEwMCArICclJyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHNob3VsZE92ZXJsYXAgJiYgIXNlZ0hDb29yZHMuc3RhY2tGb3J3YXJkKSB7XG4gICAgICAgICAgICAvLyBhZGQgcGFkZGluZyB0byB0aGUgZWRnZSBzbyB0aGF0IGZvcndhcmQgc3RhY2tlZCBldmVudHMgZG9uJ3QgY292ZXIgdGhlIHJlc2l6ZXIncyBpY29uXG4gICAgICAgICAgICBwcm9wc1tpc1J0bCA/ICdtYXJnaW5MZWZ0JyA6ICdtYXJnaW5SaWdodCddID0gMTAgKiAyOyAvLyAxMCBpcyBhIGd1ZXNzdGltYXRlIG9mIHRoZSBpY29uJ3Mgd2lkdGhcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvcHM7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVuZGVyUGxhaW5GZ1NlZ3Moc29ydGVkRmdTZWdzLCB7IHRvZGF5UmFuZ2UsIG5vd0RhdGUsIGV2ZW50U2VsZWN0aW9uLCBldmVudERyYWcsIGV2ZW50UmVzaXplIH0pIHtcbiAgICBsZXQgaGlkZGVuSW5zdGFuY2VzID0gKGV2ZW50RHJhZyA/IGV2ZW50RHJhZy5hZmZlY3RlZEluc3RhbmNlcyA6IG51bGwpIHx8XG4gICAgICAgIChldmVudFJlc2l6ZSA/IGV2ZW50UmVzaXplLmFmZmVjdGVkSW5zdGFuY2VzIDogbnVsbCkgfHxcbiAgICAgICAge307XG4gICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBzb3J0ZWRGZ1NlZ3MubWFwKChzZWcpID0+IHtcbiAgICAgICAgbGV0IGluc3RhbmNlSWQgPSBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBrZXk6IGluc3RhbmNlSWQsIHN0eWxlOiB7IHZpc2liaWxpdHk6IGhpZGRlbkluc3RhbmNlc1tpbnN0YW5jZUlkXSA/ICdoaWRkZW4nIDogJycgfSB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChUaW1lQ29sRXZlbnQsIE9iamVjdC5hc3NpZ24oeyBzZWc6IHNlZywgaXNEcmFnZ2luZzogZmFsc2UsIGlzUmVzaXppbmc6IGZhbHNlLCBpc0RhdGVTZWxlY3Rpbmc6IGZhbHNlLCBpc1NlbGVjdGVkOiBpbnN0YW5jZUlkID09PSBldmVudFNlbGVjdGlvbiwgaXNTaG9ydDogZmFsc2UgfSwgZ2V0U2VnTWV0YShzZWcsIHRvZGF5UmFuZ2UsIG5vd0RhdGUpKSkpKTtcbiAgICB9KSkpO1xufVxuZnVuY3Rpb24gY29tcHV0ZVNlZ1ZTdHlsZShzZWdWQ29vcmRzKSB7XG4gICAgaWYgKCFzZWdWQ29vcmRzKSB7XG4gICAgICAgIHJldHVybiB7IHRvcDogJycsIGJvdHRvbTogJycgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiBzZWdWQ29vcmRzLnN0YXJ0LFxuICAgICAgICBib3R0b206IC1zZWdWQ29vcmRzLmVuZCxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcGlsZVNlZ3NGcm9tRW50cmllcyhzZWdFbnRyaWVzLCBhbGxTZWdzKSB7XG4gICAgcmV0dXJuIHNlZ0VudHJpZXMubWFwKChzZWdFbnRyeSkgPT4gYWxsU2Vnc1tzZWdFbnRyeS5pbmRleF0pO1xufVxuXG5jbGFzcyBUaW1lQ29sc0NvbnRlbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5zcGxpdEZnRXZlbnRTZWdzID0gbWVtb2l6ZShzcGxpdFNlZ3NCeUNvbCk7XG4gICAgICAgIHRoaXMuc3BsaXRCZ0V2ZW50U2VncyA9IG1lbW9pemUoc3BsaXRTZWdzQnlDb2wpO1xuICAgICAgICB0aGlzLnNwbGl0QnVzaW5lc3NIb3VyU2VncyA9IG1lbW9pemUoc3BsaXRTZWdzQnlDb2wpO1xuICAgICAgICB0aGlzLnNwbGl0Tm93SW5kaWNhdG9yU2VncyA9IG1lbW9pemUoc3BsaXRTZWdzQnlDb2wpO1xuICAgICAgICB0aGlzLnNwbGl0RGF0ZVNlbGVjdGlvblNlZ3MgPSBtZW1vaXplKHNwbGl0U2Vnc0J5Q29sKTtcbiAgICAgICAgdGhpcy5zcGxpdEV2ZW50RHJhZyA9IG1lbW9pemUoc3BsaXRJbnRlcmFjdGlvbkJ5Q29sKTtcbiAgICAgICAgdGhpcy5zcGxpdEV2ZW50UmVzaXplID0gbWVtb2l6ZShzcGxpdEludGVyYWN0aW9uQnlDb2wpO1xuICAgICAgICB0aGlzLnJvb3RFbFJlZiA9IGNyZWF0ZVJlZigpO1xuICAgICAgICB0aGlzLmNlbGxFbFJlZnMgPSBuZXcgUmVmTWFwKCk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCBub3dJbmRpY2F0b3JUb3AgPSBjb250ZXh0Lm9wdGlvbnMubm93SW5kaWNhdG9yICYmXG4gICAgICAgICAgICBwcm9wcy5zbGF0Q29vcmRzICYmXG4gICAgICAgICAgICBwcm9wcy5zbGF0Q29vcmRzLnNhZmVDb21wdXRlVG9wKHByb3BzLm5vd0RhdGUpOyAvLyBtaWdodCByZXR1cm4gdm9pZFxuICAgICAgICBsZXQgY29sQ250ID0gcHJvcHMuY2VsbHMubGVuZ3RoO1xuICAgICAgICBsZXQgZmdFdmVudFNlZ3NCeVJvdyA9IHRoaXMuc3BsaXRGZ0V2ZW50U2Vncyhwcm9wcy5mZ0V2ZW50U2VncywgY29sQ250KTtcbiAgICAgICAgbGV0IGJnRXZlbnRTZWdzQnlSb3cgPSB0aGlzLnNwbGl0QmdFdmVudFNlZ3MocHJvcHMuYmdFdmVudFNlZ3MsIGNvbENudCk7XG4gICAgICAgIGxldCBidXNpbmVzc0hvdXJTZWdzQnlSb3cgPSB0aGlzLnNwbGl0QnVzaW5lc3NIb3VyU2Vncyhwcm9wcy5idXNpbmVzc0hvdXJTZWdzLCBjb2xDbnQpO1xuICAgICAgICBsZXQgbm93SW5kaWNhdG9yU2Vnc0J5Um93ID0gdGhpcy5zcGxpdE5vd0luZGljYXRvclNlZ3MocHJvcHMubm93SW5kaWNhdG9yU2VncywgY29sQ250KTtcbiAgICAgICAgbGV0IGRhdGVTZWxlY3Rpb25TZWdzQnlSb3cgPSB0aGlzLnNwbGl0RGF0ZVNlbGVjdGlvblNlZ3MocHJvcHMuZGF0ZVNlbGVjdGlvblNlZ3MsIGNvbENudCk7XG4gICAgICAgIGxldCBldmVudERyYWdCeVJvdyA9IHRoaXMuc3BsaXRFdmVudERyYWcocHJvcHMuZXZlbnREcmFnLCBjb2xDbnQpO1xuICAgICAgICBsZXQgZXZlbnRSZXNpemVCeVJvdyA9IHRoaXMuc3BsaXRFdmVudFJlc2l6ZShwcm9wcy5ldmVudFJlc2l6ZSwgY29sQ250KTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWNvbHNcIiwgcmVmOiB0aGlzLnJvb3RFbFJlZiB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRhYmxlXCIsIHsgcm9sZTogXCJwcmVzZW50YXRpb25cIiwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgbWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICAgICAgcHJvcHMudGFibGVDb2xHcm91cE5vZGUsXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRib2R5XCIsIHsgcm9sZTogXCJwcmVzZW50YXRpb25cIiB9LFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwidHJcIiwgeyByb2xlOiBcInJvd1wiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5heGlzICYmIChjcmVhdGVFbGVtZW50KFwidGRcIiwgeyBcImFyaWEtaGlkZGVuXCI6IHRydWUsIGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1jb2wgZmMtdGltZWdyaWQtYXhpc1wiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1jb2wtZnJhbWVcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItY29udGFpbmVyXCIgfSwgdHlwZW9mIG5vd0luZGljYXRvclRvcCA9PT0gJ251bWJlcicgJiYgKGNyZWF0ZUVsZW1lbnQoTm93SW5kaWNhdG9yQ29udGFpbmVyLCB7IGVsQ2xhc3NlczogWydmYy10aW1lZ3JpZC1ub3ctaW5kaWNhdG9yLWFycm93J10sIGVsU3R5bGU6IHsgdG9wOiBub3dJbmRpY2F0b3JUb3AgfSwgaXNBeGlzOiB0cnVlLCBkYXRlOiBwcm9wcy5ub3dEYXRlIH0pKSkpKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5jZWxscy5tYXAoKGNlbGwsIGkpID0+IChjcmVhdGVFbGVtZW50KFRpbWVDb2wsIHsga2V5OiBjZWxsLmtleSwgZWxSZWY6IHRoaXMuY2VsbEVsUmVmcy5jcmVhdGVSZWYoY2VsbC5rZXkpLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIGRhdGU6IGNlbGwuZGF0ZSwgbm93RGF0ZTogcHJvcHMubm93RGF0ZSwgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSwgZXh0cmFSZW5kZXJQcm9wczogY2VsbC5leHRyYVJlbmRlclByb3BzLCBleHRyYURhdGFBdHRyczogY2VsbC5leHRyYURhdGFBdHRycywgZXh0cmFDbGFzc05hbWVzOiBjZWxsLmV4dHJhQ2xhc3NOYW1lcywgZXh0cmFEYXRlU3BhbjogY2VsbC5leHRyYURhdGVTcGFuLCBmZ0V2ZW50U2VnczogZmdFdmVudFNlZ3NCeVJvd1tpXSwgYmdFdmVudFNlZ3M6IGJnRXZlbnRTZWdzQnlSb3dbaV0sIGJ1c2luZXNzSG91clNlZ3M6IGJ1c2luZXNzSG91clNlZ3NCeVJvd1tpXSwgbm93SW5kaWNhdG9yU2Vnczogbm93SW5kaWNhdG9yU2Vnc0J5Um93W2ldLCBkYXRlU2VsZWN0aW9uU2VnczogZGF0ZVNlbGVjdGlvblNlZ3NCeVJvd1tpXSwgZXZlbnREcmFnOiBldmVudERyYWdCeVJvd1tpXSwgZXZlbnRSZXNpemU6IGV2ZW50UmVzaXplQnlSb3dbaV0sIHNsYXRDb29yZHM6IHByb3BzLnNsYXRDb29yZHMsIGV2ZW50U2VsZWN0aW9uOiBwcm9wcy5ldmVudFNlbGVjdGlvbiwgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50IH0pKSkpKSkpKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQ29vcmRzKCk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVDb29yZHMoKTtcbiAgICB9XG4gICAgdXBkYXRlQ29vcmRzKCkge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgaWYgKHByb3BzLm9uQ29sQ29vcmRzICYmXG4gICAgICAgICAgICBwcm9wcy5jbGllbnRXaWR0aCAhPT0gbnVsbCAvLyBtZWFucyBzaXppbmcgaGFzIHN0YWJpbGl6ZWRcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBwcm9wcy5vbkNvbENvb3JkcyhuZXcgUG9zaXRpb25DYWNoZSh0aGlzLnJvb3RFbFJlZi5jdXJyZW50LCBjb2xsZWN0Q2VsbEVscyh0aGlzLmNlbGxFbFJlZnMuY3VycmVudE1hcCwgcHJvcHMuY2VsbHMpLCB0cnVlLCAvLyBob3Jpem9udGFsXG4gICAgICAgICAgICBmYWxzZSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY29sbGVjdENlbGxFbHMoZWxNYXAsIGNlbGxzKSB7XG4gICAgcmV0dXJuIGNlbGxzLm1hcCgoY2VsbCkgPT4gZWxNYXBbY2VsbC5rZXldKTtcbn1cblxuLyogQSBjb21wb25lbnQgdGhhdCByZW5kZXJzIG9uZSBvciBtb3JlIGNvbHVtbnMgb2YgdmVydGljYWwgdGltZSBzbG90c1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5jbGFzcyBUaW1lQ29scyBleHRlbmRzIERhdGVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnByb2Nlc3NTbG90T3B0aW9ucyA9IG1lbW9pemUocHJvY2Vzc1Nsb3RPcHRpb25zKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHNsYXRDb29yZHM6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUm9vdEVsID0gKGVsKSA9PiB7XG4gICAgICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCh0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgICAgICBpc0hpdENvbWJvQWxsb3dlZDogdGhpcy5wcm9wcy5pc0hpdENvbWJvQWxsb3dlZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC51bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlU2Nyb2xsUmVxdWVzdCA9IChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBvblNjcm9sbFRvcFJlcXVlc3QgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBsZXQgeyBzbGF0Q29vcmRzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgaWYgKG9uU2Nyb2xsVG9wUmVxdWVzdCAmJiBzbGF0Q29vcmRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QudGltZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdG9wID0gc2xhdENvb3Jkcy5jb21wdXRlVGltZVRvcChyZXF1ZXN0LnRpbWUpO1xuICAgICAgICAgICAgICAgICAgICB0b3AgPSBNYXRoLmNlaWwodG9wKTsgLy8gem9vbSBjYW4gZ2l2ZSB3ZWlyZCBmbG9hdGluZy1wb2ludCB2YWx1ZXMuIHJhdGhlciBzY3JvbGwgYSBsaXR0bGUgYml0IGZ1cnRoZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wICs9IDE7IC8vIHRvIG92ZXJjb21lIHRvcCBib3JkZXIgdGhhdCBzbG90cyBiZXlvbmQgdGhlIGZpcnN0IGhhdmUuIGxvb2tzIGJldHRlclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9uU2Nyb2xsVG9wUmVxdWVzdCh0b3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVDb2xDb29yZHMgPSAoY29sQ29vcmRzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvbENvb3JkcyA9IGNvbENvb3JkcztcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVTbGF0Q29vcmRzID0gKHNsYXRDb29yZHMpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBzbGF0Q29vcmRzIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25TbGF0Q29vcmRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vblNsYXRDb29yZHMoc2xhdENvb3Jkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIHN0YXRlIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtYm9keVwiLCByZWY6IHRoaXMuaGFuZGxlUm9vdEVsLCBzdHlsZToge1xuICAgICAgICAgICAgICAgIC8vIHRoZXNlIHByb3BzIGFyZSBpbXBvcnRhbnQgdG8gZ2l2ZSB0aGlzIHdyYXBwZXIgY29ycmVjdCBkaW1lbnNpb25zIGZvciBpbnRlcmFjdGlvbnNcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBpZiB3ZSBzZXQgaXQgaGVyZSwgY2FuIHdlIGF2b2lkIGdpdmluZyB0byBpbm5lciB0YWJsZXM/XG4gICAgICAgICAgICAgICAgd2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICAgIG1pbldpZHRoOiBwcm9wcy50YWJsZU1pbldpZHRoLFxuICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChUaW1lQ29sc1NsYXRzLCB7IGF4aXM6IHByb3BzLmF4aXMsIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgc2xhdE1ldGFzOiBwcm9wcy5zbGF0TWV0YXMsIGNsaWVudFdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCwgbWluSGVpZ2h0OiBwcm9wcy5leHBhbmRSb3dzID8gcHJvcHMuY2xpZW50SGVpZ2h0IDogJycsIHRhYmxlTWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsIHRhYmxlQ29sR3JvdXBOb2RlOiBwcm9wcy5heGlzID8gcHJvcHMudGFibGVDb2xHcm91cE5vZGUgOiBudWxsIC8qIGF4aXMgZGVwZW5kcyBvbiB0aGUgY29sZ3JvdXAncyBzaHJpbmtpbmcgKi8sIG9uQ29vcmRzOiB0aGlzLmhhbmRsZVNsYXRDb29yZHMgfSksXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFRpbWVDb2xzQ29udGVudCwgeyBjZWxsczogcHJvcHMuY2VsbHMsIGF4aXM6IHByb3BzLmF4aXMsIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgYnVzaW5lc3NIb3VyU2VnczogcHJvcHMuYnVzaW5lc3NIb3VyU2VncywgYmdFdmVudFNlZ3M6IHByb3BzLmJnRXZlbnRTZWdzLCBmZ0V2ZW50U2VnczogcHJvcHMuZmdFdmVudFNlZ3MsIGRhdGVTZWxlY3Rpb25TZWdzOiBwcm9wcy5kYXRlU2VsZWN0aW9uU2VncywgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBldmVudERyYWc6IHByb3BzLmV2ZW50RHJhZywgZXZlbnRSZXNpemU6IHByb3BzLmV2ZW50UmVzaXplLCB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlLCBub3dEYXRlOiBwcm9wcy5ub3dEYXRlLCBub3dJbmRpY2F0b3JTZWdzOiBwcm9wcy5ub3dJbmRpY2F0b3JTZWdzLCBjbGllbnRXaWR0aDogcHJvcHMuY2xpZW50V2lkdGgsIHRhYmxlTWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsIHRhYmxlQ29sR3JvdXBOb2RlOiBwcm9wcy50YWJsZUNvbEdyb3VwTm9kZSwgc2xhdENvb3Jkczogc3RhdGUuc2xhdENvb3Jkcywgb25Db2xDb29yZHM6IHRoaXMuaGFuZGxlQ29sQ29vcmRzLCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQgfSkpKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsUmVzcG9uZGVyID0gdGhpcy5jb250ZXh0LmNyZWF0ZVNjcm9sbFJlc3BvbmRlcih0aGlzLmhhbmRsZVNjcm9sbFJlcXVlc3QpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsUmVzcG9uZGVyLnVwZGF0ZShwcmV2UHJvcHMuZGF0ZVByb2ZpbGUgIT09IHRoaXMucHJvcHMuZGF0ZVByb2ZpbGUpO1xuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxSZXNwb25kZXIuZGV0YWNoKCk7XG4gICAgfVxuICAgIHF1ZXJ5SGl0KHBvc2l0aW9uTGVmdCwgcG9zaXRpb25Ub3ApIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiwgb3B0aW9ucyB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgeyBjb2xDb29yZHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IGRhdGVQcm9maWxlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBsZXQgeyBzbGF0Q29vcmRzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBsZXQgeyBzbmFwRHVyYXRpb24sIHNuYXBzUGVyU2xvdCB9ID0gdGhpcy5wcm9jZXNzU2xvdE9wdGlvbnModGhpcy5wcm9wcy5zbG90RHVyYXRpb24sIG9wdGlvbnMuc25hcER1cmF0aW9uKTtcbiAgICAgICAgbGV0IGNvbEluZGV4ID0gY29sQ29vcmRzLmxlZnRUb0luZGV4KHBvc2l0aW9uTGVmdCk7XG4gICAgICAgIGxldCBzbGF0SW5kZXggPSBzbGF0Q29vcmRzLnBvc2l0aW9ucy50b3BUb0luZGV4KHBvc2l0aW9uVG9wKTtcbiAgICAgICAgaWYgKGNvbEluZGV4ICE9IG51bGwgJiYgc2xhdEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBjZWxsID0gdGhpcy5wcm9wcy5jZWxsc1tjb2xJbmRleF07XG4gICAgICAgICAgICBsZXQgc2xhdFRvcCA9IHNsYXRDb29yZHMucG9zaXRpb25zLnRvcHNbc2xhdEluZGV4XTtcbiAgICAgICAgICAgIGxldCBzbGF0SGVpZ2h0ID0gc2xhdENvb3Jkcy5wb3NpdGlvbnMuZ2V0SGVpZ2h0KHNsYXRJbmRleCk7XG4gICAgICAgICAgICBsZXQgcGFydGlhbCA9IChwb3NpdGlvblRvcCAtIHNsYXRUb3ApIC8gc2xhdEhlaWdodDsgLy8gZmxvYXRpbmcgcG9pbnQgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAgICAgICAgbGV0IGxvY2FsU25hcEluZGV4ID0gTWF0aC5mbG9vcihwYXJ0aWFsICogc25hcHNQZXJTbG90KTsgLy8gdGhlIHNuYXAgIyByZWxhdGl2ZSB0byBzdGFydCBvZiBzbGF0XG4gICAgICAgICAgICBsZXQgc25hcEluZGV4ID0gc2xhdEluZGV4ICogc25hcHNQZXJTbG90ICsgbG9jYWxTbmFwSW5kZXg7XG4gICAgICAgICAgICBsZXQgZGF5RGF0ZSA9IHRoaXMucHJvcHMuY2VsbHNbY29sSW5kZXhdLmRhdGU7XG4gICAgICAgICAgICBsZXQgdGltZSA9IGFkZER1cmF0aW9ucyhkYXRlUHJvZmlsZS5zbG90TWluVGltZSwgbXVsdGlwbHlEdXJhdGlvbihzbmFwRHVyYXRpb24sIHNuYXBJbmRleCkpO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gZGF0ZUVudi5hZGQoZGF5RGF0ZSwgdGltZSk7XG4gICAgICAgICAgICBsZXQgZW5kID0gZGF0ZUVudi5hZGQoc3RhcnQsIHNuYXBEdXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGVQcm9maWxlLFxuICAgICAgICAgICAgICAgIGRhdGVTcGFuOiBPYmplY3QuYXNzaWduKHsgcmFuZ2U6IHsgc3RhcnQsIGVuZCB9LCBhbGxEYXk6IGZhbHNlIH0sIGNlbGwuZXh0cmFEYXRlU3BhbiksXG4gICAgICAgICAgICAgICAgZGF5RWw6IGNvbENvb3Jkcy5lbHNbY29sSW5kZXhdLFxuICAgICAgICAgICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogY29sQ29vcmRzLmxlZnRzW2NvbEluZGV4XSxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGNvbENvb3Jkcy5yaWdodHNbY29sSW5kZXhdLFxuICAgICAgICAgICAgICAgICAgICB0b3A6IHNsYXRUb3AsXG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbTogc2xhdFRvcCArIHNsYXRIZWlnaHQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBsYXllcjogMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gcHJvY2Vzc1Nsb3RPcHRpb25zKHNsb3REdXJhdGlvbiwgc25hcER1cmF0aW9uT3ZlcnJpZGUpIHtcbiAgICBsZXQgc25hcER1cmF0aW9uID0gc25hcER1cmF0aW9uT3ZlcnJpZGUgfHwgc2xvdER1cmF0aW9uO1xuICAgIGxldCBzbmFwc1BlclNsb3QgPSB3aG9sZURpdmlkZUR1cmF0aW9ucyhzbG90RHVyYXRpb24sIHNuYXBEdXJhdGlvbik7XG4gICAgaWYgKHNuYXBzUGVyU2xvdCA9PT0gbnVsbCkge1xuICAgICAgICBzbmFwRHVyYXRpb24gPSBzbG90RHVyYXRpb247XG4gICAgICAgIHNuYXBzUGVyU2xvdCA9IDE7XG4gICAgICAgIC8vIFRPRE86IHNheSB3YXJuaW5nP1xuICAgIH1cbiAgICByZXR1cm4geyBzbmFwRHVyYXRpb24sIHNuYXBzUGVyU2xvdCB9O1xufVxuXG5jbGFzcyBEYXlUaW1lQ29sc1NsaWNlciBleHRlbmRzIFNsaWNlciB7XG4gICAgc2xpY2VSYW5nZShyYW5nZSwgZGF5UmFuZ2VzKSB7XG4gICAgICAgIGxldCBzZWdzID0gW107XG4gICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGRheVJhbmdlcy5sZW5ndGg7IGNvbCArPSAxKSB7XG4gICAgICAgICAgICBsZXQgc2VnUmFuZ2UgPSBpbnRlcnNlY3RSYW5nZXMocmFuZ2UsIGRheVJhbmdlc1tjb2xdKTtcbiAgICAgICAgICAgIGlmIChzZWdSYW5nZSkge1xuICAgICAgICAgICAgICAgIHNlZ3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzZWdSYW5nZS5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBzZWdSYW5nZS5lbmQsXG4gICAgICAgICAgICAgICAgICAgIGlzU3RhcnQ6IHNlZ1JhbmdlLnN0YXJ0LnZhbHVlT2YoKSA9PT0gcmFuZ2Uuc3RhcnQudmFsdWVPZigpLFxuICAgICAgICAgICAgICAgICAgICBpc0VuZDogc2VnUmFuZ2UuZW5kLnZhbHVlT2YoKSA9PT0gcmFuZ2UuZW5kLnZhbHVlT2YoKSxcbiAgICAgICAgICAgICAgICAgICAgY29sLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWdzO1xuICAgIH1cbn1cblxuY2xhc3MgRGF5VGltZUNvbHMgZXh0ZW5kcyBEYXRlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5idWlsZERheVJhbmdlcyA9IG1lbW9pemUoYnVpbGREYXlSYW5nZXMpO1xuICAgICAgICB0aGlzLnNsaWNlciA9IG5ldyBEYXlUaW1lQ29sc1NsaWNlcigpO1xuICAgICAgICB0aGlzLnRpbWVDb2xzUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IGRhdGVQcm9maWxlLCBkYXlUYWJsZU1vZGVsIH0gPSBwcm9wcztcbiAgICAgICAgbGV0IHsgbm93SW5kaWNhdG9yLCBuZXh0RGF5VGhyZXNob2xkIH0gPSBjb250ZXh0Lm9wdGlvbnM7XG4gICAgICAgIGxldCBkYXlSYW5nZXMgPSB0aGlzLmJ1aWxkRGF5UmFuZ2VzKGRheVRhYmxlTW9kZWwsIGRhdGVQcm9maWxlLCBjb250ZXh0LmRhdGVFbnYpO1xuICAgICAgICAvLyBnaXZlIGl0IHRoZSBmaXJzdCByb3cgb2YgY2VsbHNcbiAgICAgICAgLy8gVE9ETzogd291bGQgbW92ZSB0aGlzIGZ1cnRoZXIgZG93biBoaWVyYXJjaHksIGJ1dCBzbGljZU5vd0RhdGUgbmVlZHMgaXRcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KE5vd1RpbWVyLCB7IHVuaXQ6IG5vd0luZGljYXRvciA/ICdtaW51dGUnIDogJ2RheScgfSwgKG5vd0RhdGUsIHRvZGF5UmFuZ2UpID0+IChjcmVhdGVFbGVtZW50KFRpbWVDb2xzLCBPYmplY3QuYXNzaWduKHsgcmVmOiB0aGlzLnRpbWVDb2xzUmVmIH0sIHRoaXMuc2xpY2VyLnNsaWNlUHJvcHMocHJvcHMsIGRhdGVQcm9maWxlLCBudWxsLCBjb250ZXh0LCBkYXlSYW5nZXMpLCB7IGZvclByaW50OiBwcm9wcy5mb3JQcmludCwgYXhpczogcHJvcHMuYXhpcywgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLCBzbGF0TWV0YXM6IHByb3BzLnNsYXRNZXRhcywgc2xvdER1cmF0aW9uOiBwcm9wcy5zbG90RHVyYXRpb24sIGNlbGxzOiBkYXlUYWJsZU1vZGVsLmNlbGxzWzBdLCB0YWJsZUNvbEdyb3VwTm9kZTogcHJvcHMudGFibGVDb2xHcm91cE5vZGUsIHRhYmxlTWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsIGNsaWVudFdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0OiBwcm9wcy5jbGllbnRIZWlnaHQsIGV4cGFuZFJvd3M6IHByb3BzLmV4cGFuZFJvd3MsIG5vd0RhdGU6IG5vd0RhdGUsIG5vd0luZGljYXRvclNlZ3M6IG5vd0luZGljYXRvciAmJiB0aGlzLnNsaWNlci5zbGljZU5vd0RhdGUobm93RGF0ZSwgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIGNvbnRleHQsIGRheVJhbmdlcyksIHRvZGF5UmFuZ2U6IHRvZGF5UmFuZ2UsIG9uU2Nyb2xsVG9wUmVxdWVzdDogcHJvcHMub25TY3JvbGxUb3BSZXF1ZXN0LCBvblNsYXRDb29yZHM6IHByb3BzLm9uU2xhdENvb3JkcyB9KSkpKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gYnVpbGREYXlSYW5nZXMoZGF5VGFibGVNb2RlbCwgZGF0ZVByb2ZpbGUsIGRhdGVFbnYpIHtcbiAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgZm9yIChsZXQgZGF0ZSBvZiBkYXlUYWJsZU1vZGVsLmhlYWRlckRhdGVzKSB7XG4gICAgICAgIHJhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgIHN0YXJ0OiBkYXRlRW52LmFkZChkYXRlLCBkYXRlUHJvZmlsZS5zbG90TWluVGltZSksXG4gICAgICAgICAgICBlbmQ6IGRhdGVFbnYuYWRkKGRhdGUsIGRhdGVQcm9maWxlLnNsb3RNYXhUaW1lKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByYW5nZXM7XG59XG5cbi8vIHBvdGVudGlhbCBuaWNlIHZhbHVlcyBmb3IgdGhlIHNsb3QtZHVyYXRpb24gYW5kIGludGVydmFsLWR1cmF0aW9uXG4vLyBmcm9tIGxhcmdlc3QgdG8gc21hbGxlc3RcbmNvbnN0IFNUT0NLX1NVQl9EVVJBVElPTlMgPSBbXG4gICAgeyBob3VyczogMSB9LFxuICAgIHsgbWludXRlczogMzAgfSxcbiAgICB7IG1pbnV0ZXM6IDE1IH0sXG4gICAgeyBzZWNvbmRzOiAzMCB9LFxuICAgIHsgc2Vjb25kczogMTUgfSxcbl07XG5mdW5jdGlvbiBidWlsZFNsYXRNZXRhcyhzbG90TWluVGltZSwgc2xvdE1heFRpbWUsIGV4cGxpY2l0TGFiZWxJbnRlcnZhbCwgc2xvdER1cmF0aW9uLCBkYXRlRW52KSB7XG4gICAgbGV0IGRheVN0YXJ0ID0gbmV3IERhdGUoMCk7XG4gICAgbGV0IHNsYXRUaW1lID0gc2xvdE1pblRpbWU7XG4gICAgbGV0IHNsYXRJdGVyYXRvciA9IGNyZWF0ZUR1cmF0aW9uKDApO1xuICAgIGxldCBsYWJlbEludGVydmFsID0gZXhwbGljaXRMYWJlbEludGVydmFsIHx8IGNvbXB1dGVMYWJlbEludGVydmFsKHNsb3REdXJhdGlvbik7XG4gICAgbGV0IG1ldGFzID0gW107XG4gICAgd2hpbGUgKGFzUm91Z2hNcyhzbGF0VGltZSkgPCBhc1JvdWdoTXMoc2xvdE1heFRpbWUpKSB7XG4gICAgICAgIGxldCBkYXRlID0gZGF0ZUVudi5hZGQoZGF5U3RhcnQsIHNsYXRUaW1lKTtcbiAgICAgICAgbGV0IGlzTGFiZWxlZCA9IHdob2xlRGl2aWRlRHVyYXRpb25zKHNsYXRJdGVyYXRvciwgbGFiZWxJbnRlcnZhbCkgIT09IG51bGw7XG4gICAgICAgIG1ldGFzLnB1c2goe1xuICAgICAgICAgICAgZGF0ZSxcbiAgICAgICAgICAgIHRpbWU6IHNsYXRUaW1lLFxuICAgICAgICAgICAga2V5OiBkYXRlLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICBpc29UaW1lU3RyOiBmb3JtYXRJc29UaW1lU3RyaW5nKGRhdGUpLFxuICAgICAgICAgICAgaXNMYWJlbGVkLFxuICAgICAgICB9KTtcbiAgICAgICAgc2xhdFRpbWUgPSBhZGREdXJhdGlvbnMoc2xhdFRpbWUsIHNsb3REdXJhdGlvbik7XG4gICAgICAgIHNsYXRJdGVyYXRvciA9IGFkZER1cmF0aW9ucyhzbGF0SXRlcmF0b3IsIHNsb3REdXJhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBtZXRhcztcbn1cbi8vIENvbXB1dGVzIGFuIGF1dG9tYXRpYyB2YWx1ZSBmb3Igc2xvdExhYmVsSW50ZXJ2YWxcbmZ1bmN0aW9uIGNvbXB1dGVMYWJlbEludGVydmFsKHNsb3REdXJhdGlvbikge1xuICAgIGxldCBpO1xuICAgIGxldCBsYWJlbEludGVydmFsO1xuICAgIGxldCBzbG90c1BlckxhYmVsO1xuICAgIC8vIGZpbmQgdGhlIHNtYWxsZXN0IHN0b2NrIGxhYmVsIGludGVydmFsIHRoYXQgcmVzdWx0cyBpbiBtb3JlIHRoYW4gb25lIHNsb3RzLXBlci1sYWJlbFxuICAgIGZvciAoaSA9IFNUT0NLX1NVQl9EVVJBVElPTlMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgbGFiZWxJbnRlcnZhbCA9IGNyZWF0ZUR1cmF0aW9uKFNUT0NLX1NVQl9EVVJBVElPTlNbaV0pO1xuICAgICAgICBzbG90c1BlckxhYmVsID0gd2hvbGVEaXZpZGVEdXJhdGlvbnMobGFiZWxJbnRlcnZhbCwgc2xvdER1cmF0aW9uKTtcbiAgICAgICAgaWYgKHNsb3RzUGVyTGFiZWwgIT09IG51bGwgJiYgc2xvdHNQZXJMYWJlbCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBsYWJlbEludGVydmFsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzbG90RHVyYXRpb247IC8vIGZhbGwgYmFja1xufVxuXG5jbGFzcyBEYXlUaW1lQ29sc1ZpZXcgZXh0ZW5kcyBUaW1lQ29sc1ZpZXcge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmJ1aWxkVGltZUNvbHNNb2RlbCA9IG1lbW9pemUoYnVpbGRUaW1lQ29sc01vZGVsKTtcbiAgICAgICAgdGhpcy5idWlsZFNsYXRNZXRhcyA9IG1lbW9pemUoYnVpbGRTbGF0TWV0YXMpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IG9wdGlvbnMsIGRhdGVFbnYsIGRhdGVQcm9maWxlR2VuZXJhdG9yIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBkYXRlUHJvZmlsZSB9ID0gcHJvcHM7XG4gICAgICAgIGxldCBkYXlUYWJsZU1vZGVsID0gdGhpcy5idWlsZFRpbWVDb2xzTW9kZWwoZGF0ZVByb2ZpbGUsIGRhdGVQcm9maWxlR2VuZXJhdG9yKTtcbiAgICAgICAgbGV0IHNwbGl0UHJvcHMgPSB0aGlzLmFsbERheVNwbGl0dGVyLnNwbGl0UHJvcHMocHJvcHMpO1xuICAgICAgICBsZXQgc2xhdE1ldGFzID0gdGhpcy5idWlsZFNsYXRNZXRhcyhkYXRlUHJvZmlsZS5zbG90TWluVGltZSwgZGF0ZVByb2ZpbGUuc2xvdE1heFRpbWUsIG9wdGlvbnMuc2xvdExhYmVsSW50ZXJ2YWwsIG9wdGlvbnMuc2xvdER1cmF0aW9uLCBkYXRlRW52KTtcbiAgICAgICAgbGV0IHsgZGF5TWluV2lkdGggfSA9IG9wdGlvbnM7XG4gICAgICAgIGxldCBoYXNBdHRhY2hlZEF4aXMgPSAhZGF5TWluV2lkdGg7XG4gICAgICAgIGxldCBoYXNEZXRhY2hlZEF4aXMgPSBkYXlNaW5XaWR0aDtcbiAgICAgICAgbGV0IGhlYWRlckNvbnRlbnQgPSBvcHRpb25zLmRheUhlYWRlcnMgJiYgKGNyZWF0ZUVsZW1lbnQoRGF5SGVhZGVyLCB7IGRhdGVzOiBkYXlUYWJsZU1vZGVsLmhlYWRlckRhdGVzLCBkYXRlUHJvZmlsZTogZGF0ZVByb2ZpbGUsIGRhdGVzUmVwRGlzdGluY3REYXlzOiB0cnVlLCByZW5kZXJJbnRybzogaGFzQXR0YWNoZWRBeGlzID8gdGhpcy5yZW5kZXJIZWFkQXhpcyA6IG51bGwgfSkpO1xuICAgICAgICBsZXQgYWxsRGF5Q29udGVudCA9IChvcHRpb25zLmFsbERheVNsb3QgIT09IGZhbHNlKSAmJiAoKGNvbnRlbnRBcmcpID0+IChjcmVhdGVFbGVtZW50KERheVRhYmxlLCBPYmplY3QuYXNzaWduKHt9LCBzcGxpdFByb3BzLmFsbERheSwgeyBkYXRlUHJvZmlsZTogZGF0ZVByb2ZpbGUsIGRheVRhYmxlTW9kZWw6IGRheVRhYmxlTW9kZWwsIG5leHREYXlUaHJlc2hvbGQ6IG9wdGlvbnMubmV4dERheVRocmVzaG9sZCwgdGFibGVNaW5XaWR0aDogY29udGVudEFyZy50YWJsZU1pbldpZHRoLCBjb2xHcm91cE5vZGU6IGNvbnRlbnRBcmcudGFibGVDb2xHcm91cE5vZGUsIHJlbmRlclJvd0ludHJvOiBoYXNBdHRhY2hlZEF4aXMgPyB0aGlzLnJlbmRlclRhYmxlUm93QXhpcyA6IG51bGwsIHNob3dXZWVrTnVtYmVyczogZmFsc2UsIGV4cGFuZFJvd3M6IGZhbHNlLCBoZWFkZXJBbGlnbkVsUmVmOiB0aGlzLmhlYWRlckVsUmVmLCBjbGllbnRXaWR0aDogY29udGVudEFyZy5jbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0OiBjb250ZW50QXJnLmNsaWVudEhlaWdodCwgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50IH0sIHRoaXMuZ2V0QWxsRGF5TWF4RXZlbnRQcm9wcygpKSkpKTtcbiAgICAgICAgbGV0IHRpbWVHcmlkQ29udGVudCA9IChjb250ZW50QXJnKSA9PiAoY3JlYXRlRWxlbWVudChEYXlUaW1lQ29scywgT2JqZWN0LmFzc2lnbih7fSwgc3BsaXRQcm9wcy50aW1lZCwgeyBkYXlUYWJsZU1vZGVsOiBkYXlUYWJsZU1vZGVsLCBkYXRlUHJvZmlsZTogZGF0ZVByb2ZpbGUsIGF4aXM6IGhhc0F0dGFjaGVkQXhpcywgc2xvdER1cmF0aW9uOiBvcHRpb25zLnNsb3REdXJhdGlvbiwgc2xhdE1ldGFzOiBzbGF0TWV0YXMsIGZvclByaW50OiBwcm9wcy5mb3JQcmludCwgdGFibGVDb2xHcm91cE5vZGU6IGNvbnRlbnRBcmcudGFibGVDb2xHcm91cE5vZGUsIHRhYmxlTWluV2lkdGg6IGNvbnRlbnRBcmcudGFibGVNaW5XaWR0aCwgY2xpZW50V2lkdGg6IGNvbnRlbnRBcmcuY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodDogY29udGVudEFyZy5jbGllbnRIZWlnaHQsIG9uU2xhdENvb3JkczogdGhpcy5oYW5kbGVTbGF0Q29vcmRzLCBleHBhbmRSb3dzOiBjb250ZW50QXJnLmV4cGFuZFJvd3MsIG9uU2Nyb2xsVG9wUmVxdWVzdDogdGhpcy5oYW5kbGVTY3JvbGxUb3BSZXF1ZXN0IH0pKSk7XG4gICAgICAgIHJldHVybiBoYXNEZXRhY2hlZEF4aXNcbiAgICAgICAgICAgID8gdGhpcy5yZW5kZXJIU2Nyb2xsTGF5b3V0KGhlYWRlckNvbnRlbnQsIGFsbERheUNvbnRlbnQsIHRpbWVHcmlkQ29udGVudCwgZGF5VGFibGVNb2RlbC5jb2xDbnQsIGRheU1pbldpZHRoLCBzbGF0TWV0YXMsIHRoaXMuc3RhdGUuc2xhdENvb3JkcylcbiAgICAgICAgICAgIDogdGhpcy5yZW5kZXJTaW1wbGVMYXlvdXQoaGVhZGVyQ29udGVudCwgYWxsRGF5Q29udGVudCwgdGltZUdyaWRDb250ZW50KTtcbiAgICB9XG59XG5mdW5jdGlvbiBidWlsZFRpbWVDb2xzTW9kZWwoZGF0ZVByb2ZpbGUsIGRhdGVQcm9maWxlR2VuZXJhdG9yKSB7XG4gICAgbGV0IGRheVNlcmllcyA9IG5ldyBEYXlTZXJpZXNNb2RlbChkYXRlUHJvZmlsZS5yZW5kZXJSYW5nZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IpO1xuICAgIHJldHVybiBuZXcgRGF5VGFibGVNb2RlbChkYXlTZXJpZXMsIGZhbHNlKTtcbn1cblxudmFyIGNzc18yNDh6ID0gXCIuZmMtdi1ldmVudHtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWZjLWV2ZW50LWJnLWNvbG9yKTtib3JkZXI6MXB4IHNvbGlkIHZhcigtLWZjLWV2ZW50LWJvcmRlci1jb2xvcik7ZGlzcGxheTpibG9ja30uZmMtdi1ldmVudCAuZmMtZXZlbnQtbWFpbntjb2xvcjp2YXIoLS1mYy1ldmVudC10ZXh0LWNvbG9yKTtoZWlnaHQ6MTAwJX0uZmMtdi1ldmVudCAuZmMtZXZlbnQtbWFpbi1mcmFtZXtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1uO2hlaWdodDoxMDAlfS5mYy12LWV2ZW50IC5mYy1ldmVudC10aW1le2ZsZXgtZ3JvdzowO2ZsZXgtc2hyaW5rOjA7bWF4LWhlaWdodDoxMDAlO292ZXJmbG93OmhpZGRlbn0uZmMtdi1ldmVudCAuZmMtZXZlbnQtdGl0bGUtY29udGFpbmVye2ZsZXgtZ3JvdzoxO2ZsZXgtc2hyaW5rOjE7bWluLWhlaWdodDowfS5mYy12LWV2ZW50IC5mYy1ldmVudC10aXRsZXtib3R0b206MDttYXgtaGVpZ2h0OjEwMCU7b3ZlcmZsb3c6aGlkZGVuO3RvcDowfS5mYy12LWV2ZW50Om5vdCguZmMtZXZlbnQtc3RhcnQpe2JvcmRlci10b3AtbGVmdC1yYWRpdXM6MDtib3JkZXItdG9wLXJpZ2h0LXJhZGl1czowO2JvcmRlci10b3Atd2lkdGg6MH0uZmMtdi1ldmVudDpub3QoLmZjLWV2ZW50LWVuZCl7Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czowO2JvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOjA7Ym9yZGVyLWJvdHRvbS13aWR0aDowfS5mYy12LWV2ZW50LmZjLWV2ZW50LXNlbGVjdGVkOmJlZm9yZXtsZWZ0Oi0xMHB4O3JpZ2h0Oi0xMHB4fS5mYy12LWV2ZW50IC5mYy1ldmVudC1yZXNpemVyLXN0YXJ0e2N1cnNvcjpuLXJlc2l6ZX0uZmMtdi1ldmVudCAuZmMtZXZlbnQtcmVzaXplci1lbmR7Y3Vyc29yOnMtcmVzaXplfS5mYy12LWV2ZW50Om5vdCguZmMtZXZlbnQtc2VsZWN0ZWQpIC5mYy1ldmVudC1yZXNpemVye2hlaWdodDp2YXIoLS1mYy1ldmVudC1yZXNpemVyLXRoaWNrbmVzcyk7bGVmdDowO3JpZ2h0OjB9LmZjLXYtZXZlbnQ6bm90KC5mYy1ldmVudC1zZWxlY3RlZCkgLmZjLWV2ZW50LXJlc2l6ZXItc3RhcnR7dG9wOmNhbGModmFyKC0tZmMtZXZlbnQtcmVzaXplci10aGlja25lc3MpLy0yKX0uZmMtdi1ldmVudDpub3QoLmZjLWV2ZW50LXNlbGVjdGVkKSAuZmMtZXZlbnQtcmVzaXplci1lbmR7Ym90dG9tOmNhbGModmFyKC0tZmMtZXZlbnQtcmVzaXplci10aGlja25lc3MpLy0yKX0uZmMtdi1ldmVudC5mYy1ldmVudC1zZWxlY3RlZCAuZmMtZXZlbnQtcmVzaXplcntsZWZ0OjUwJTttYXJnaW4tbGVmdDpjYWxjKHZhcigtLWZjLWV2ZW50LXJlc2l6ZXItZG90LXRvdGFsLXdpZHRoKS8tMil9LmZjLXYtZXZlbnQuZmMtZXZlbnQtc2VsZWN0ZWQgLmZjLWV2ZW50LXJlc2l6ZXItc3RhcnR7dG9wOmNhbGModmFyKC0tZmMtZXZlbnQtcmVzaXplci1kb3QtdG90YWwtd2lkdGgpLy0yKX0uZmMtdi1ldmVudC5mYy1ldmVudC1zZWxlY3RlZCAuZmMtZXZlbnQtcmVzaXplci1lbmR7Ym90dG9tOmNhbGModmFyKC0tZmMtZXZlbnQtcmVzaXplci1kb3QtdG90YWwtd2lkdGgpLy0yKX0uZmMgLmZjLXRpbWVncmlkIC5mYy1kYXlncmlkLWJvZHl7ei1pbmRleDoyfS5mYyAuZmMtdGltZWdyaWQtZGl2aWRlcntwYWRkaW5nOjAgMCAycHh9LmZjIC5mYy10aW1lZ3JpZC1ib2R5e21pbi1oZWlnaHQ6MTAwJTtwb3NpdGlvbjpyZWxhdGl2ZTt6LWluZGV4OjF9LmZjIC5mYy10aW1lZ3JpZC1heGlzLWNodW5re3Bvc2l0aW9uOnJlbGF0aXZlfS5mYyAuZmMtdGltZWdyaWQtYXhpcy1jaHVuaz50YWJsZSwuZmMgLmZjLXRpbWVncmlkLXNsb3Rze3Bvc2l0aW9uOnJlbGF0aXZlO3otaW5kZXg6MX0uZmMgLmZjLXRpbWVncmlkLXNsb3R7Ym9yZGVyLWJvdHRvbTowO2hlaWdodDoxLjVlbX0uZmMgLmZjLXRpbWVncmlkLXNsb3Q6ZW1wdHk6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFwwMGEwXFxcIn0uZmMgLmZjLXRpbWVncmlkLXNsb3QtbWlub3J7Ym9yZGVyLXRvcC1zdHlsZTpkb3R0ZWR9LmZjIC5mYy10aW1lZ3JpZC1zbG90LWxhYmVsLWN1c2hpb257ZGlzcGxheTppbmxpbmUtYmxvY2s7d2hpdGUtc3BhY2U6bm93cmFwfS5mYyAuZmMtdGltZWdyaWQtc2xvdC1sYWJlbHt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9LmZjIC5mYy10aW1lZ3JpZC1heGlzLWN1c2hpb24sLmZjIC5mYy10aW1lZ3JpZC1zbG90LWxhYmVsLWN1c2hpb257cGFkZGluZzowIDRweH0uZmMgLmZjLXRpbWVncmlkLWF4aXMtZnJhbWUtbGlxdWlke2hlaWdodDoxMDAlfS5mYyAuZmMtdGltZWdyaWQtYXhpcy1mcmFtZXthbGlnbi1pdGVtczpjZW50ZXI7ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpmbGV4LWVuZDtvdmVyZmxvdzpoaWRkZW59LmZjIC5mYy10aW1lZ3JpZC1heGlzLWN1c2hpb257ZmxleC1zaHJpbms6MDttYXgtd2lkdGg6NjBweH0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtdGltZWdyaWQtc2xvdC1sYWJlbC1mcmFtZXt0ZXh0LWFsaWduOnJpZ2h0fS5mYy1kaXJlY3Rpb24tcnRsIC5mYy10aW1lZ3JpZC1zbG90LWxhYmVsLWZyYW1le3RleHQtYWxpZ246bGVmdH0uZmMtbGlxdWlkLWhhY2sgLmZjLXRpbWVncmlkLWF4aXMtZnJhbWUtbGlxdWlke2JvdHRvbTowO2hlaWdodDphdXRvO2xlZnQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO3RvcDowfS5mYyAuZmMtdGltZWdyaWQtY29sLmZjLWRheS10b2RheXtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWZjLXRvZGF5LWJnLWNvbG9yKX0uZmMgLmZjLXRpbWVncmlkLWNvbC1mcmFtZXttaW4taGVpZ2h0OjEwMCU7cG9zaXRpb246cmVsYXRpdmV9LmZjLW1lZGlhLXNjcmVlbi5mYy1saXF1aWQtaGFjayAuZmMtdGltZWdyaWQtY29sLWZyYW1le2JvdHRvbTowO2hlaWdodDphdXRvO2xlZnQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO3RvcDowfS5mYy1tZWRpYS1zY3JlZW4gLmZjLXRpbWVncmlkLWNvbHN7Ym90dG9tOjA7bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7dG9wOjB9LmZjLW1lZGlhLXNjcmVlbiAuZmMtdGltZWdyaWQtY29scz50YWJsZXtoZWlnaHQ6MTAwJX0uZmMtbWVkaWEtc2NyZWVuIC5mYy10aW1lZ3JpZC1jb2wtYmcsLmZjLW1lZGlhLXNjcmVlbiAuZmMtdGltZWdyaWQtY29sLWV2ZW50cywuZmMtbWVkaWEtc2NyZWVuIC5mYy10aW1lZ3JpZC1ub3ctaW5kaWNhdG9yLWNvbnRhaW5lcntsZWZ0OjA7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MDt0b3A6MH0uZmMgLmZjLXRpbWVncmlkLWNvbC1iZ3t6LWluZGV4OjJ9LmZjIC5mYy10aW1lZ3JpZC1jb2wtYmcgLmZjLW5vbi1idXNpbmVzc3t6LWluZGV4OjF9LmZjIC5mYy10aW1lZ3JpZC1jb2wtYmcgLmZjLWJnLWV2ZW50e3otaW5kZXg6Mn0uZmMgLmZjLXRpbWVncmlkLWNvbC1iZyAuZmMtaGlnaGxpZ2h0e3otaW5kZXg6M30uZmMgLmZjLXRpbWVncmlkLWJnLWhhcm5lc3N7bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjB9LmZjIC5mYy10aW1lZ3JpZC1jb2wtZXZlbnRze3otaW5kZXg6M30uZmMgLmZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItY29udGFpbmVye2JvdHRvbTowO292ZXJmbG93OmhpZGRlbn0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtdGltZWdyaWQtY29sLWV2ZW50c3ttYXJnaW46MCAyLjUlIDAgMnB4fS5mYy1kaXJlY3Rpb24tcnRsIC5mYy10aW1lZ3JpZC1jb2wtZXZlbnRze21hcmdpbjowIDJweCAwIDIuNSV9LmZjLXRpbWVncmlkLWV2ZW50LWhhcm5lc3N7cG9zaXRpb246YWJzb2x1dGV9LmZjLXRpbWVncmlkLWV2ZW50LWhhcm5lc3M+LmZjLXRpbWVncmlkLWV2ZW50e2JvdHRvbTowO2xlZnQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO3RvcDowfS5mYy10aW1lZ3JpZC1ldmVudC1oYXJuZXNzLWluc2V0IC5mYy10aW1lZ3JpZC1ldmVudCwuZmMtdGltZWdyaWQtZXZlbnQuZmMtZXZlbnQtbWlycm9yLC5mYy10aW1lZ3JpZC1tb3JlLWxpbmt7Ym94LXNoYWRvdzowIDAgMCAxcHggdmFyKC0tZmMtcGFnZS1iZy1jb2xvcil9LmZjLXRpbWVncmlkLWV2ZW50LC5mYy10aW1lZ3JpZC1tb3JlLWxpbmt7Ym9yZGVyLXJhZGl1czozcHg7Zm9udC1zaXplOnZhcigtLWZjLXNtYWxsLWZvbnQtc2l6ZSl9LmZjLXRpbWVncmlkLWV2ZW50e21hcmdpbi1ib3R0b206MXB4fS5mYy10aW1lZ3JpZC1ldmVudCAuZmMtZXZlbnQtbWFpbntwYWRkaW5nOjFweCAxcHggMH0uZmMtdGltZWdyaWQtZXZlbnQgLmZjLWV2ZW50LXRpbWV7Zm9udC1zaXplOnZhcigtLWZjLXNtYWxsLWZvbnQtc2l6ZSk7bWFyZ2luLWJvdHRvbToxcHg7d2hpdGUtc3BhY2U6bm93cmFwfS5mYy10aW1lZ3JpZC1ldmVudC1zaG9ydCAuZmMtZXZlbnQtbWFpbi1mcmFtZXtmbGV4LWRpcmVjdGlvbjpyb3c7b3ZlcmZsb3c6aGlkZGVufS5mYy10aW1lZ3JpZC1ldmVudC1zaG9ydCAuZmMtZXZlbnQtdGltZTphZnRlcntjb250ZW50OlxcXCJcXFxcMDBhMC1cXFxcMDBhMFxcXCJ9LmZjLXRpbWVncmlkLWV2ZW50LXNob3J0IC5mYy1ldmVudC10aXRsZXtmb250LXNpemU6dmFyKC0tZmMtc21hbGwtZm9udC1zaXplKX0uZmMtdGltZWdyaWQtbW9yZS1saW5re2JhY2tncm91bmQ6dmFyKC0tZmMtbW9yZS1saW5rLWJnLWNvbG9yKTtjb2xvcjp2YXIoLS1mYy1tb3JlLWxpbmstdGV4dC1jb2xvcik7Y3Vyc29yOnBvaW50ZXI7bWFyZ2luLWJvdHRvbToxcHg7cG9zaXRpb246YWJzb2x1dGU7ei1pbmRleDo5OTk5fS5mYy10aW1lZ3JpZC1tb3JlLWxpbmstaW5uZXJ7cGFkZGluZzozcHggMnB4O3RvcDowfS5mYy1kaXJlY3Rpb24tbHRyIC5mYy10aW1lZ3JpZC1tb3JlLWxpbmt7cmlnaHQ6MH0uZmMtZGlyZWN0aW9uLXJ0bCAuZmMtdGltZWdyaWQtbW9yZS1saW5re2xlZnQ6MH0uZmMgLmZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItYXJyb3csLmZjIC5mYy10aW1lZ3JpZC1ub3ctaW5kaWNhdG9yLWxpbmV7cG9pbnRlci1ldmVudHM6bm9uZX0uZmMgLmZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItbGluZXtib3JkZXItY29sb3I6dmFyKC0tZmMtbm93LWluZGljYXRvci1jb2xvcik7Ym9yZGVyLXN0eWxlOnNvbGlkO2JvcmRlci13aWR0aDoxcHggMCAwO2xlZnQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO3otaW5kZXg6NH0uZmMgLmZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItYXJyb3d7Ym9yZGVyLWNvbG9yOnZhcigtLWZjLW5vdy1pbmRpY2F0b3ItY29sb3IpO2JvcmRlci1zdHlsZTpzb2xpZDttYXJnaW4tdG9wOi01cHg7cG9zaXRpb246YWJzb2x1dGU7ei1pbmRleDo0fS5mYy1kaXJlY3Rpb24tbHRyIC5mYy10aW1lZ3JpZC1ub3ctaW5kaWNhdG9yLWFycm93e2JvcmRlci1ib3R0b20tY29sb3I6dHJhbnNwYXJlbnQ7Ym9yZGVyLXRvcC1jb2xvcjp0cmFuc3BhcmVudDtib3JkZXItd2lkdGg6NXB4IDAgNXB4IDZweDtsZWZ0OjB9LmZjLWRpcmVjdGlvbi1ydGwgLmZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItYXJyb3d7Ym9yZGVyLWJvdHRvbS1jb2xvcjp0cmFuc3BhcmVudDtib3JkZXItdG9wLWNvbG9yOnRyYW5zcGFyZW50O2JvcmRlci13aWR0aDo1cHggNnB4IDVweCAwO3JpZ2h0OjB9XCI7XG5pbmplY3RTdHlsZXMoY3NzXzI0OHopO1xuXG5leHBvcnQgeyBEYXlUaW1lQ29scywgRGF5VGltZUNvbHNTbGljZXIsIERheVRpbWVDb2xzVmlldywgVGltZUNvbHMsIFRpbWVDb2xzU2xhdHNDb29yZHMsIFRpbWVDb2xzVmlldywgYnVpbGREYXlSYW5nZXMsIGJ1aWxkU2xhdE1ldGFzLCBidWlsZFRpbWVDb2xzTW9kZWwgfTtcbiIsICJpbXBvcnQgeyBjcmVhdGVQbHVnaW4gfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvcmUvaW5kZXguanMnO1xuaW1wb3J0IHsgRGF5VGltZUNvbHNWaWV3IH0gZnJvbSAnLi9pbnRlcm5hbC5qcyc7XG5pbXBvcnQgJ0BmdWxsY2FsZW5kYXIvY29yZS9pbnRlcm5hbC5qcyc7XG5pbXBvcnQgJ0BmdWxsY2FsZW5kYXIvY29yZS9wcmVhY3QuanMnO1xuaW1wb3J0ICdAZnVsbGNhbGVuZGFyL2RheWdyaWQvaW50ZXJuYWwuanMnO1xuXG5jb25zdCBPUFRJT05fUkVGSU5FUlMgPSB7XG4gICAgYWxsRGF5U2xvdDogQm9vbGVhbixcbn07XG5cbnZhciBpbmRleCA9IGNyZWF0ZVBsdWdpbih7XG4gICAgbmFtZTogJ0BmdWxsY2FsZW5kYXIvdGltZWdyaWQnLFxuICAgIGluaXRpYWxWaWV3OiAndGltZUdyaWRXZWVrJyxcbiAgICBvcHRpb25SZWZpbmVyczogT1BUSU9OX1JFRklORVJTLFxuICAgIHZpZXdzOiB7XG4gICAgICAgIHRpbWVHcmlkOiB7XG4gICAgICAgICAgICBjb21wb25lbnQ6IERheVRpbWVDb2xzVmlldyxcbiAgICAgICAgICAgIHVzZXNNaW5NYXhUaW1lOiB0cnVlLFxuICAgICAgICAgICAgYWxsRGF5U2xvdDogdHJ1ZSxcbiAgICAgICAgICAgIHNsb3REdXJhdGlvbjogJzAwOjMwOjAwJyxcbiAgICAgICAgICAgIHNsb3RFdmVudE92ZXJsYXA6IHRydWUsIC8vIGEgYmFkIG5hbWUuIGNvbmZ1c2VkIHdpdGggb3ZlcmxhcC9jb25zdHJhaW50IHN5c3RlbVxuICAgICAgICB9LFxuICAgICAgICB0aW1lR3JpZERheToge1xuICAgICAgICAgICAgdHlwZTogJ3RpbWVHcmlkJyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB7IGRheXM6IDEgfSxcbiAgICAgICAgfSxcbiAgICAgICAgdGltZUdyaWRXZWVrOiB7XG4gICAgICAgICAgICB0eXBlOiAndGltZUdyaWQnLFxuICAgICAgICAgICAgZHVyYXRpb246IHsgd2Vla3M6IDEgfSxcbiAgICAgICAgfSxcbiAgICB9LFxufSk7XG5cbmV4cG9ydCB7IGluZGV4IGFzIGRlZmF1bHQgfTtcbiIsIG51bGwsIG51bGwsIG51bGwsIG51bGwsICIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19jcmVhdGVCaW5kaW5nID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcclxuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XHJcbiAgICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XHJcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59KTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgbykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwKSkgX19jcmVhdGVCaW5kaW5nKG8sIG0sIHApO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xyXG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgcmV0dXJuIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XHJcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcclxuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcclxuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XHJcbn0pIDogZnVuY3Rpb24obywgdikge1xyXG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XHJcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4oc3RhdGUsIHJlY2VpdmVyKSB7XHJcbiAgICBpZiAocmVjZWl2ZXIgPT09IG51bGwgfHwgKHR5cGVvZiByZWNlaXZlciAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcmVjZWl2ZXIgIT09IFwiZnVuY3Rpb25cIikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgdXNlICdpbicgb3BlcmF0b3Igb24gbm9uLW9iamVjdFwiKTtcclxuICAgIHJldHVybiB0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyID09PSBzdGF0ZSA6IHN0YXRlLmhhcyhyZWNlaXZlcik7XHJcbn1cclxuIiwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgImltcG9ydCB7IGNyZWF0ZVBsdWdpbiB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29yZS9pbmRleC5qcyc7XG5pbXBvcnQgKiBhcyBycnVsZUxpYiBmcm9tICdycnVsZSc7XG5pbXBvcnQgeyBwYXJzZU1hcmtlciwgaWRlbnRpdHksIGNyZWF0ZUR1cmF0aW9uIH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb3JlL2ludGVybmFsLmpzJztcblxuY29uc3QgcmVjdXJyaW5nVHlwZSA9IHtcbiAgICBwYXJzZShldmVudFByb3BzLCBkYXRlRW52KSB7XG4gICAgICAgIGlmIChldmVudFByb3BzLnJydWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBldmVudFJSdWxlRGF0YSA9IHBhcnNlRXZlbnRSUnVsZShldmVudFByb3BzLCBkYXRlRW52KTtcbiAgICAgICAgICAgIGlmIChldmVudFJSdWxlRGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVEYXRhOiB7IHJydWxlU2V0OiBldmVudFJSdWxlRGF0YS5ycnVsZVNldCwgaXNUaW1lWm9uZVNwZWNpZmllZDogZXZlbnRSUnVsZURhdGEuaXNUaW1lWm9uZVNwZWNpZmllZCB9LFxuICAgICAgICAgICAgICAgICAgICBhbGxEYXlHdWVzczogIWV2ZW50UlJ1bGVEYXRhLmlzVGltZVNwZWNpZmllZCxcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IGV2ZW50UHJvcHMuZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGV4cGFuZChldmVudFJSdWxlRGF0YSwgZnJhbWluZ1JhbmdlLCBkYXRlRW52KSB7XG4gICAgICAgIGxldCBkYXRlcztcbiAgICAgICAgaWYgKGV2ZW50UlJ1bGVEYXRhLmlzVGltZVpvbmVTcGVjaWZpZWQpIHtcbiAgICAgICAgICAgIGRhdGVzID0gZXZlbnRSUnVsZURhdGEucnJ1bGVTZXQuYmV0d2VlbihkYXRlRW52LnRvRGF0ZShmcmFtaW5nUmFuZ2Uuc3RhcnQpLCAvLyBycnVsZSBsaWIgd2lsbCB0cmVhdCBhcyBVVEMtem9uZWRcbiAgICAgICAgICAgIGRhdGVFbnYudG9EYXRlKGZyYW1pbmdSYW5nZS5lbmQpLCAvLyAoc2FtZSlcbiAgICAgICAgICAgIHRydWUpLm1hcCgoZGF0ZSkgPT4gZGF0ZUVudi5jcmVhdGVNYXJrZXIoZGF0ZSkpOyAvLyBjb252ZXJ0IFVUQy16b25lZC1kYXRlIHRvIGxvY2FsZSBkYXRlbWFya2VyXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB3aGVuIG5vIHRpbWV6b25lIGluIGdpdmVuIHN0YXJ0L2VuZCwgdGhlIHJydWxlIGxpYiB3aWxsIGFzc3VtZSBVVEMsXG4gICAgICAgICAgICAvLyB3aGljaCBpcyBzYW1lIGFzIG91ciBEYXRlTWFya2Vycy4gbm8gbmVlZCB0byBtYW5pcHVsYXRlXG4gICAgICAgICAgICBkYXRlcyA9IGV2ZW50UlJ1bGVEYXRhLnJydWxlU2V0LmJldHdlZW4oZnJhbWluZ1JhbmdlLnN0YXJ0LCBmcmFtaW5nUmFuZ2UuZW5kLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZXM7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBwYXJzZUV2ZW50UlJ1bGUoZXZlbnRQcm9wcywgZGF0ZUVudikge1xuICAgIGxldCBycnVsZVNldDtcbiAgICBsZXQgaXNUaW1lU3BlY2lmaWVkID0gZmFsc2U7XG4gICAgbGV0IGlzVGltZVpvbmVTcGVjaWZpZWQgPSBmYWxzZTtcbiAgICBpZiAodHlwZW9mIGV2ZW50UHJvcHMucnJ1bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGxldCByZXMgPSBwYXJzZVJSdWxlU3RyaW5nKGV2ZW50UHJvcHMucnJ1bGUpO1xuICAgICAgICBycnVsZVNldCA9IHJlcy5ycnVsZVNldDtcbiAgICAgICAgaXNUaW1lU3BlY2lmaWVkID0gcmVzLmlzVGltZVNwZWNpZmllZDtcbiAgICAgICAgaXNUaW1lWm9uZVNwZWNpZmllZCA9IHJlcy5pc1RpbWVab25lU3BlY2lmaWVkO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGV2ZW50UHJvcHMucnJ1bGUgPT09ICdvYmplY3QnICYmIGV2ZW50UHJvcHMucnJ1bGUpIHsgLy8gbm9uLW51bGwgb2JqZWN0XG4gICAgICAgIGxldCByZXMgPSBwYXJzZVJSdWxlT2JqZWN0KGV2ZW50UHJvcHMucnJ1bGUsIGRhdGVFbnYpO1xuICAgICAgICBycnVsZVNldCA9IG5ldyBycnVsZUxpYi5SUnVsZVNldCgpO1xuICAgICAgICBycnVsZVNldC5ycnVsZShyZXMucnJ1bGUpO1xuICAgICAgICBpc1RpbWVTcGVjaWZpZWQgPSByZXMuaXNUaW1lU3BlY2lmaWVkO1xuICAgICAgICBpc1RpbWVab25lU3BlY2lmaWVkID0gcmVzLmlzVGltZVpvbmVTcGVjaWZpZWQ7XG4gICAgfVxuICAgIC8vIGNvbnZlcnkgdG8gYXJyYXlzLiBUT0RPOiBnZW5lcmFsIHV0aWw/XG4gICAgbGV0IGV4ZGF0ZUlucHV0cyA9IFtdLmNvbmNhdChldmVudFByb3BzLmV4ZGF0ZSB8fCBbXSk7XG4gICAgbGV0IGV4cnVsZUlucHV0cyA9IFtdLmNvbmNhdChldmVudFByb3BzLmV4cnVsZSB8fCBbXSk7XG4gICAgZm9yIChsZXQgZXhkYXRlSW5wdXQgb2YgZXhkYXRlSW5wdXRzKSB7XG4gICAgICAgIGxldCByZXMgPSBwYXJzZU1hcmtlcihleGRhdGVJbnB1dCk7XG4gICAgICAgIGlzVGltZVNwZWNpZmllZCA9IGlzVGltZVNwZWNpZmllZCB8fCAhcmVzLmlzVGltZVVuc3BlY2lmaWVkO1xuICAgICAgICBpc1RpbWVab25lU3BlY2lmaWVkID0gaXNUaW1lWm9uZVNwZWNpZmllZCB8fCByZXMudGltZVpvbmVPZmZzZXQgIT09IG51bGw7XG4gICAgICAgIHJydWxlU2V0LmV4ZGF0ZShuZXcgRGF0ZShyZXMubWFya2VyLnZhbHVlT2YoKSAtIChyZXMudGltZVpvbmVPZmZzZXQgfHwgMCkgKiA2MCAqIDEwMDApKTtcbiAgICB9XG4gICAgLy8gVE9ETzogZXhydWxlIGlzIGRlcHJlY2F0ZWQuIHdoYXQgdG8gZG8/IChodHRwczovL2ljYWxlbmRhci5vcmcvaUNhbGVuZGFyLVJGQy01NTQ1L2EtMy1kZXByZWNhdGVkLWZlYXR1cmVzLmh0bWwpXG4gICAgZm9yIChsZXQgZXhydWxlSW5wdXQgb2YgZXhydWxlSW5wdXRzKSB7XG4gICAgICAgIGxldCByZXMgPSBwYXJzZVJSdWxlT2JqZWN0KGV4cnVsZUlucHV0LCBkYXRlRW52KTtcbiAgICAgICAgaXNUaW1lU3BlY2lmaWVkID0gaXNUaW1lU3BlY2lmaWVkIHx8IHJlcy5pc1RpbWVTcGVjaWZpZWQ7XG4gICAgICAgIGlzVGltZVpvbmVTcGVjaWZpZWQgPSBpc1RpbWVab25lU3BlY2lmaWVkIHx8IHJlcy5pc1RpbWVab25lU3BlY2lmaWVkO1xuICAgICAgICBycnVsZVNldC5leHJ1bGUocmVzLnJydWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgcnJ1bGVTZXQsIGlzVGltZVNwZWNpZmllZCwgaXNUaW1lWm9uZVNwZWNpZmllZCB9O1xufVxuZnVuY3Rpb24gcGFyc2VSUnVsZU9iamVjdChycnVsZUlucHV0LCBkYXRlRW52KSB7XG4gICAgbGV0IGlzVGltZVNwZWNpZmllZCA9IGZhbHNlO1xuICAgIGxldCBpc1RpbWVab25lU3BlY2lmaWVkID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gcHJvY2Vzc0RhdGVJbnB1dChkYXRlSW5wdXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRlSW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBsZXQgbWFya2VyRGF0YSA9IHBhcnNlTWFya2VyKGRhdGVJbnB1dCk7XG4gICAgICAgICAgICBpZiAobWFya2VyRGF0YSkge1xuICAgICAgICAgICAgICAgIGlzVGltZVNwZWNpZmllZCA9IGlzVGltZVNwZWNpZmllZCB8fCAhbWFya2VyRGF0YS5pc1RpbWVVbnNwZWNpZmllZDtcbiAgICAgICAgICAgICAgICBpc1RpbWVab25lU3BlY2lmaWVkID0gaXNUaW1lWm9uZVNwZWNpZmllZCB8fCBtYXJrZXJEYXRhLnRpbWVab25lT2Zmc2V0ICE9PSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShtYXJrZXJEYXRhLm1hcmtlci52YWx1ZU9mKCkgLSAobWFya2VyRGF0YS50aW1lWm9uZU9mZnNldCB8fCAwKSAqIDYwICogMTAwMCk7IC8vIE5PVCBEUllcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlSW5wdXQ7IC8vIFRPRE86IHdoYXQgYWJvdXQgbnVtYmVyIHRpbWVzdGFtcHM/XG4gICAgfVxuICAgIGxldCBycnVsZU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJydWxlSW5wdXQpLCB7IGR0c3RhcnQ6IHByb2Nlc3NEYXRlSW5wdXQocnJ1bGVJbnB1dC5kdHN0YXJ0KSwgdW50aWw6IHByb2Nlc3NEYXRlSW5wdXQocnJ1bGVJbnB1dC51bnRpbCksIGZyZXE6IGNvbnZlcnRDb25zdGFudChycnVsZUlucHV0LmZyZXEpLCB3a3N0OiBycnVsZUlucHV0Lndrc3QgPT0gbnVsbFxuICAgICAgICAgICAgPyAoZGF0ZUVudi53ZWVrRG93IC0gMSArIDcpICUgNyAvLyBjb252ZXJ0IFN1bmRheS1maXJzdCB0byBNb25kYXktZmlyc3RcbiAgICAgICAgICAgIDogY29udmVydENvbnN0YW50KHJydWxlSW5wdXQud2tzdCksIGJ5d2Vla2RheTogY29udmVydENvbnN0YW50cyhycnVsZUlucHV0LmJ5d2Vla2RheSkgfSk7XG4gICAgcmV0dXJuIHsgcnJ1bGU6IG5ldyBycnVsZUxpYi5SUnVsZShycnVsZU9wdGlvbnMpLCBpc1RpbWVTcGVjaWZpZWQsIGlzVGltZVpvbmVTcGVjaWZpZWQgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlUlJ1bGVTdHJpbmcoc3RyKSB7XG4gICAgbGV0IHJydWxlU2V0ID0gcnJ1bGVMaWIucnJ1bGVzdHIoc3RyLCB7IGZvcmNlc2V0OiB0cnVlIH0pO1xuICAgIGxldCBhbmFseXNpcyA9IGFuYWx5emVSUnVsZVN0cmluZyhzdHIpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgcnJ1bGVTZXQgfSwgYW5hbHlzaXMpO1xufVxuZnVuY3Rpb24gYW5hbHl6ZVJSdWxlU3RyaW5nKHN0cikge1xuICAgIGxldCBpc1RpbWVTcGVjaWZpZWQgPSBmYWxzZTtcbiAgICBsZXQgaXNUaW1lWm9uZVNwZWNpZmllZCA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIHByb2Nlc3NNYXRjaCh3aG9sZSwgaW50cm9QYXJ0LCBkYXRlUGFydCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gcGFyc2VNYXJrZXIoZGF0ZVBhcnQpO1xuICAgICAgICBpc1RpbWVTcGVjaWZpZWQgPSBpc1RpbWVTcGVjaWZpZWQgfHwgIXJlc3VsdC5pc1RpbWVVbnNwZWNpZmllZDtcbiAgICAgICAgaXNUaW1lWm9uZVNwZWNpZmllZCA9IGlzVGltZVpvbmVTcGVjaWZpZWQgfHwgcmVzdWx0LnRpbWVab25lT2Zmc2V0ICE9PSBudWxsO1xuICAgIH1cbiAgICBzdHIucmVwbGFjZSgvXFxiKERUU1RBUlQ6KShbXlxcbl0qKS8sIHByb2Nlc3NNYXRjaCk7XG4gICAgc3RyLnJlcGxhY2UoL1xcYihFWERBVEU6KShbXlxcbl0qKS8sIHByb2Nlc3NNYXRjaCk7XG4gICAgc3RyLnJlcGxhY2UoL1xcYihVTlRJTD0pKFteO1xcbl0qKS8sIHByb2Nlc3NNYXRjaCk7XG4gICAgcmV0dXJuIHsgaXNUaW1lU3BlY2lmaWVkLCBpc1RpbWVab25lU3BlY2lmaWVkIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0Q29uc3RhbnRzKGlucHV0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBpbnB1dC5tYXAoY29udmVydENvbnN0YW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnZlcnRDb25zdGFudChpbnB1dCk7XG59XG5mdW5jdGlvbiBjb252ZXJ0Q29uc3RhbnQoaW5wdXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gcnJ1bGVMaWIuUlJ1bGVbaW5wdXQudG9VcHBlckNhc2UoKV07XG4gICAgfVxuICAgIHJldHVybiBpbnB1dDtcbn1cblxuY29uc3QgUlJVTEVfRVZFTlRfUkVGSU5FUlMgPSB7XG4gICAgcnJ1bGU6IGlkZW50aXR5LFxuICAgIGV4cnVsZTogaWRlbnRpdHksXG4gICAgZXhkYXRlOiBpZGVudGl0eSxcbiAgICBkdXJhdGlvbjogY3JlYXRlRHVyYXRpb24sXG59O1xuXG52YXIgaW5kZXggPSBjcmVhdGVQbHVnaW4oe1xuICAgIG5hbWU6ICdAZnVsbGNhbGVuZGFyL3JydWxlJyxcbiAgICByZWN1cnJpbmdUeXBlczogW3JlY3VycmluZ1R5cGVdLFxuICAgIGV2ZW50UmVmaW5lcnM6IFJSVUxFX0VWRU5UX1JFRklORVJTLFxufSk7XG5cbmV4cG9ydCB7IGluZGV4IGFzIGRlZmF1bHQgfTtcbiIsICJpbXBvcnQgeyBCYXNlQ29tcG9uZW50LCBnZXRVbmlxdWVEb21JZCwgZ2V0RGF0ZU1ldGEsIGJ1aWxkTmF2TGlua0F0dHJzLCBDb250ZW50Q29udGFpbmVyLCBnZXREYXlDbGFzc05hbWVzLCBmb3JtYXREYXlTdHJpbmcsIGNyZWF0ZUZvcm1hdHRlciwgRXZlbnRDb250YWluZXIsIGdldFNlZ0FuY2hvckF0dHJzLCBpc011bHRpRGF5UmFuZ2UsIGJ1aWxkU2VnVGltZVRleHQsIERhdGVDb21wb25lbnQsIG1lbW9pemUsIFZpZXdDb250YWluZXIsIFNjcm9sbGVyLCBOb3dUaW1lciwgc29ydEV2ZW50U2VncywgZ2V0U2VnTWV0YSwgc2xpY2VFdmVudFN0b3JlLCBpbnRlcnNlY3RSYW5nZXMsIHN0YXJ0T2ZEYXksIGFkZERheXMsIGluamVjdFN0eWxlcyB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29yZS9pbnRlcm5hbC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVFbGVtZW50LCBGcmFnbWVudCB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29yZS9wcmVhY3QuanMnO1xuXG5jbGFzcyBMaXN0Vmlld0hlYWRlclJvdyBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgdGV4dElkOiBnZXRVbmlxdWVEb21JZCgpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHRoZW1lLCBkYXRlRW52LCBvcHRpb25zLCB2aWV3QXBpIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCB7IGNlbGxJZCwgZGF5RGF0ZSwgdG9kYXlSYW5nZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IHsgdGV4dElkIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBsZXQgZGF5TWV0YSA9IGdldERhdGVNZXRhKGRheURhdGUsIHRvZGF5UmFuZ2UpO1xuICAgICAgICAvLyB3aWxsIGV2ZXIgYmUgZmFsc3k/XG4gICAgICAgIGxldCB0ZXh0ID0gb3B0aW9ucy5saXN0RGF5Rm9ybWF0ID8gZGF0ZUVudi5mb3JtYXQoZGF5RGF0ZSwgb3B0aW9ucy5saXN0RGF5Rm9ybWF0KSA6ICcnO1xuICAgICAgICAvLyB3aWxsIGV2ZXIgYmUgZmFsc3k/IGFsc28sIEJBRCBOQU1FIFwiYWx0XCJcbiAgICAgICAgbGV0IHNpZGVUZXh0ID0gb3B0aW9ucy5saXN0RGF5U2lkZUZvcm1hdCA/IGRhdGVFbnYuZm9ybWF0KGRheURhdGUsIG9wdGlvbnMubGlzdERheVNpZGVGb3JtYXQpIDogJyc7XG4gICAgICAgIGxldCByZW5kZXJQcm9wcyA9IE9iamVjdC5hc3NpZ24oeyBkYXRlOiBkYXRlRW52LnRvRGF0ZShkYXlEYXRlKSwgdmlldzogdmlld0FwaSwgdGV4dElkLFxuICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgIHNpZGVUZXh0LCBuYXZMaW5rQXR0cnM6IGJ1aWxkTmF2TGlua0F0dHJzKHRoaXMuY29udGV4dCwgZGF5RGF0ZSksIHNpZGVOYXZMaW5rQXR0cnM6IGJ1aWxkTmF2TGlua0F0dHJzKHRoaXMuY29udGV4dCwgZGF5RGF0ZSwgJ2RheScsIGZhbHNlKSB9LCBkYXlNZXRhKTtcbiAgICAgICAgLy8gVE9ETzogbWFrZSBhIHJldXNhYmxlIEhPQyBmb3IgZGF5SGVhZGVyICh1c2VkIGluIGRheWdyaWQvdGltZWdyaWQgdG9vKVxuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoQ29udGVudENvbnRhaW5lciwgeyBlbFRhZzogXCJ0clwiLCBlbENsYXNzZXM6IFtcbiAgICAgICAgICAgICAgICAnZmMtbGlzdC1kYXknLFxuICAgICAgICAgICAgICAgIC4uLmdldERheUNsYXNzTmFtZXMoZGF5TWV0YSwgdGhlbWUpLFxuICAgICAgICAgICAgXSwgZWxBdHRyczoge1xuICAgICAgICAgICAgICAgICdkYXRhLWRhdGUnOiBmb3JtYXREYXlTdHJpbmcoZGF5RGF0ZSksXG4gICAgICAgICAgICB9LCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGdlbmVyYXRvck5hbWU6IFwiZGF5SGVhZGVyQ29udGVudFwiLCBjdXN0b21HZW5lcmF0b3I6IG9wdGlvbnMuZGF5SGVhZGVyQ29udGVudCwgZGVmYXVsdEdlbmVyYXRvcjogcmVuZGVySW5uZXJDb250ZW50LCBjbGFzc05hbWVHZW5lcmF0b3I6IG9wdGlvbnMuZGF5SGVhZGVyQ2xhc3NOYW1lcywgZGlkTW91bnQ6IG9wdGlvbnMuZGF5SGVhZGVyRGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLmRheUhlYWRlcldpbGxVbm1vdW50IH0sIChJbm5lckNvbnRlbnQpID0+ICggLy8gVE9ETzogZm9yY2UtaGlkZSB0b3AgYm9yZGVyIGJhc2VkIG9uIDpmaXJzdC1jaGlsZFxuICAgICAgICBjcmVhdGVFbGVtZW50KFwidGhcIiwgeyBzY29wZTogXCJjb2xncm91cFwiLCBjb2xTcGFuOiAzLCBpZDogY2VsbElkLCBcImFyaWEtbGFiZWxsZWRieVwiOiB0ZXh0SWQgfSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoSW5uZXJDb250ZW50LCB7IGVsVGFnOiBcImRpdlwiLCBlbENsYXNzZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2ZjLWxpc3QtZGF5LWN1c2hpb24nLFxuICAgICAgICAgICAgICAgICAgICB0aGVtZS5nZXRDbGFzcygndGFibGVDZWxsU2hhZGVkJyksXG4gICAgICAgICAgICAgICAgXSB9KSkpKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVuZGVySW5uZXJDb250ZW50KHByb3BzKSB7XG4gICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLFxuICAgICAgICBwcm9wcy50ZXh0ICYmIChjcmVhdGVFbGVtZW50KFwiYVwiLCBPYmplY3QuYXNzaWduKHsgaWQ6IHByb3BzLnRleHRJZCwgY2xhc3NOYW1lOiBcImZjLWxpc3QtZGF5LXRleHRcIiB9LCBwcm9wcy5uYXZMaW5rQXR0cnMpLCBwcm9wcy50ZXh0KSksXG4gICAgICAgIHByb3BzLnNpZGVUZXh0ICYmICggLyogbm90IGtleWJvYXJkIHRhYmJhYmxlICovY3JlYXRlRWxlbWVudChcImFcIiwgT2JqZWN0LmFzc2lnbih7IFwiYXJpYS1oaWRkZW5cIjogdHJ1ZSwgY2xhc3NOYW1lOiBcImZjLWxpc3QtZGF5LXNpZGUtdGV4dFwiIH0sIHByb3BzLnNpZGVOYXZMaW5rQXR0cnMpLCBwcm9wcy5zaWRlVGV4dCkpKSk7XG59XG5cbmNvbnN0IERFRkFVTFRfVElNRV9GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoe1xuICAgIGhvdXI6ICdudW1lcmljJyxcbiAgICBtaW51dGU6ICcyLWRpZ2l0JyxcbiAgICBtZXJpZGllbTogJ3Nob3J0Jyxcbn0pO1xuY2xhc3MgTGlzdFZpZXdFdmVudFJvdyBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgICAgIGxldCB7IHNlZywgdGltZUhlYWRlcklkLCBldmVudEhlYWRlcklkLCBkYXRlSGVhZGVySWQgfSA9IHByb3BzO1xuICAgICAgICBsZXQgdGltZUZvcm1hdCA9IG9wdGlvbnMuZXZlbnRUaW1lRm9ybWF0IHx8IERFRkFVTFRfVElNRV9GT1JNQVQ7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChFdmVudENvbnRhaW5lciwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMsIHsgZWxUYWc6IFwidHJcIiwgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgJ2ZjLWxpc3QtZXZlbnQnLFxuICAgICAgICAgICAgICAgIHNlZy5ldmVudFJhbmdlLmRlZi51cmwgJiYgJ2ZjLWV2ZW50LWZvcmNlZC11cmwnLFxuICAgICAgICAgICAgXSwgZGVmYXVsdEdlbmVyYXRvcjogKCkgPT4gcmVuZGVyRXZlbnRJbm5lckNvbnRlbnQoc2VnLCBjb250ZXh0KSAvKiB3ZWlyZCAqLywgc2VnOiBzZWcsIHRpbWVUZXh0OiBcIlwiLCBkaXNhYmxlRHJhZ2dpbmc6IHRydWUsIGRpc2FibGVSZXNpemluZzogdHJ1ZSB9KSwgKElubmVyQ29udGVudCwgZXZlbnRDb250ZW50QXJnKSA9PiAoY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCxcbiAgICAgICAgICAgIGJ1aWxkVGltZUNvbnRlbnQoc2VnLCB0aW1lRm9ybWF0LCBjb250ZXh0LCB0aW1lSGVhZGVySWQsIGRhdGVIZWFkZXJJZCksXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwidGRcIiwgeyBcImFyaWEtaGlkZGVuXCI6IHRydWUsIGNsYXNzTmFtZTogXCJmYy1saXN0LWV2ZW50LWdyYXBoaWNcIiB9LFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcImZjLWxpc3QtZXZlbnQtZG90XCIsIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogZXZlbnRDb250ZW50QXJnLmJvcmRlckNvbG9yIHx8IGV2ZW50Q29udGVudEFyZy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIH0gfSkpLFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChJbm5lckNvbnRlbnQsIHsgZWxUYWc6IFwidGRcIiwgZWxDbGFzc2VzOiBbJ2ZjLWxpc3QtZXZlbnQtdGl0bGUnXSwgZWxBdHRyczogeyBoZWFkZXJzOiBgJHtldmVudEhlYWRlcklkfSAke2RhdGVIZWFkZXJJZH1gIH0gfSkpKSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbmRlckV2ZW50SW5uZXJDb250ZW50KHNlZywgY29udGV4dCkge1xuICAgIGxldCBpbnRlcmFjdGl2ZUF0dHJzID0gZ2V0U2VnQW5jaG9yQXR0cnMoc2VnLCBjb250ZXh0KTtcbiAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJhXCIsIE9iamVjdC5hc3NpZ24oe30sIGludGVyYWN0aXZlQXR0cnMpLCBzZWcuZXZlbnRSYW5nZS5kZWYudGl0bGUpKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkVGltZUNvbnRlbnQoc2VnLCB0aW1lRm9ybWF0LCBjb250ZXh0LCB0aW1lSGVhZGVySWQsIGRhdGVIZWFkZXJJZCkge1xuICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgaWYgKG9wdGlvbnMuZGlzcGxheUV2ZW50VGltZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGV2ZW50RGVmID0gc2VnLmV2ZW50UmFuZ2UuZGVmO1xuICAgICAgICBsZXQgZXZlbnRJbnN0YW5jZSA9IHNlZy5ldmVudFJhbmdlLmluc3RhbmNlO1xuICAgICAgICBsZXQgZG9BbGxEYXkgPSBmYWxzZTtcbiAgICAgICAgbGV0IHRpbWVUZXh0O1xuICAgICAgICBpZiAoZXZlbnREZWYuYWxsRGF5KSB7XG4gICAgICAgICAgICBkb0FsbERheSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNNdWx0aURheVJhbmdlKHNlZy5ldmVudFJhbmdlLnJhbmdlKSkgeyAvLyBUT0RPOiB1c2UgKCFpc1N0YXJ0IHx8ICFpc0VuZCkgaW5zdGVhZD9cbiAgICAgICAgICAgIGlmIChzZWcuaXNTdGFydCkge1xuICAgICAgICAgICAgICAgIHRpbWVUZXh0ID0gYnVpbGRTZWdUaW1lVGV4dChzZWcsIHRpbWVGb3JtYXQsIGNvbnRleHQsIG51bGwsIG51bGwsIGV2ZW50SW5zdGFuY2UucmFuZ2Uuc3RhcnQsIHNlZy5lbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2VnLmlzRW5kKSB7XG4gICAgICAgICAgICAgICAgdGltZVRleHQgPSBidWlsZFNlZ1RpbWVUZXh0KHNlZywgdGltZUZvcm1hdCwgY29udGV4dCwgbnVsbCwgbnVsbCwgc2VnLnN0YXJ0LCBldmVudEluc3RhbmNlLnJhbmdlLmVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkb0FsbERheSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aW1lVGV4dCA9IGJ1aWxkU2VnVGltZVRleHQoc2VnLCB0aW1lRm9ybWF0LCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZG9BbGxEYXkpIHtcbiAgICAgICAgICAgIGxldCByZW5kZXJQcm9wcyA9IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBjb250ZXh0Lm9wdGlvbnMuYWxsRGF5VGV4dCxcbiAgICAgICAgICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KENvbnRlbnRDb250YWluZXIsIHsgZWxUYWc6IFwidGRcIiwgZWxDbGFzc2VzOiBbJ2ZjLWxpc3QtZXZlbnQtdGltZSddLCBlbEF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGAke3RpbWVIZWFkZXJJZH0gJHtkYXRlSGVhZGVySWR9YCxcbiAgICAgICAgICAgICAgICB9LCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGdlbmVyYXRvck5hbWU6IFwiYWxsRGF5Q29udGVudFwiLCBjdXN0b21HZW5lcmF0b3I6IG9wdGlvbnMuYWxsRGF5Q29udGVudCwgZGVmYXVsdEdlbmVyYXRvcjogcmVuZGVyQWxsRGF5SW5uZXIsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy5hbGxEYXlDbGFzc05hbWVzLCBkaWRNb3VudDogb3B0aW9ucy5hbGxEYXlEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMuYWxsRGF5V2lsbFVubW91bnQgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcInRkXCIsIHsgY2xhc3NOYW1lOiBcImZjLWxpc3QtZXZlbnQtdGltZVwiIH0sIHRpbWVUZXh0KSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcmVuZGVyQWxsRGF5SW5uZXIocmVuZGVyUHJvcHMpIHtcbiAgICByZXR1cm4gcmVuZGVyUHJvcHMudGV4dDtcbn1cblxuLypcblJlc3BvbnNpYmxlIGZvciB0aGUgc2Nyb2xsZXIsIGFuZCBmb3J3YXJkaW5nIGV2ZW50LXJlbGF0ZWQgYWN0aW9ucyBpbnRvIHRoZSBcImdyaWRcIi5cbiovXG5jbGFzcyBMaXN0VmlldyBleHRlbmRzIERhdGVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmNvbXB1dGVEYXRlVmFycyA9IG1lbW9pemUoY29tcHV0ZURhdGVWYXJzKTtcbiAgICAgICAgdGhpcy5ldmVudFN0b3JlVG9TZWdzID0gbWVtb2l6ZSh0aGlzLl9ldmVudFN0b3JlVG9TZWdzKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHRpbWVIZWFkZXJJZDogZ2V0VW5pcXVlRG9tSWQoKSxcbiAgICAgICAgICAgIGV2ZW50SGVhZGVySWQ6IGdldFVuaXF1ZURvbUlkKCksXG4gICAgICAgICAgICBkYXRlSGVhZGVySWRSb290OiBnZXRVbmlxdWVEb21JZCgpLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldFJvb3RFbCA9IChyb290RWwpID0+IHtcbiAgICAgICAgICAgIGlmIChyb290RWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCh0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgIGVsOiByb290RWwsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQudW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBkYXlEYXRlcywgZGF5UmFuZ2VzIH0gPSB0aGlzLmNvbXB1dGVEYXRlVmFycyhwcm9wcy5kYXRlUHJvZmlsZSk7XG4gICAgICAgIGxldCBldmVudFNlZ3MgPSB0aGlzLmV2ZW50U3RvcmVUb1NlZ3MocHJvcHMuZXZlbnRTdG9yZSwgcHJvcHMuZXZlbnRVaUJhc2VzLCBkYXlSYW5nZXMpO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVmlld0NvbnRhaW5lciwgeyBlbFJlZjogdGhpcy5zZXRSb290RWwsIGVsQ2xhc3NlczogW1xuICAgICAgICAgICAgICAgICdmYy1saXN0JyxcbiAgICAgICAgICAgICAgICBjb250ZXh0LnRoZW1lLmdldENsYXNzKCd0YWJsZScpLFxuICAgICAgICAgICAgICAgIGNvbnRleHQub3B0aW9ucy5zdGlja3lIZWFkZXJEYXRlcyAhPT0gZmFsc2UgP1xuICAgICAgICAgICAgICAgICAgICAnZmMtbGlzdC1zdGlja3knIDpcbiAgICAgICAgICAgICAgICAgICAgJycsXG4gICAgICAgICAgICBdLCB2aWV3U3BlYzogY29udGV4dC52aWV3U3BlYyB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChTY3JvbGxlciwgeyBsaXF1aWQ6ICFwcm9wcy5pc0hlaWdodEF1dG8sIG92ZXJmbG93WDogcHJvcHMuaXNIZWlnaHRBdXRvID8gJ3Zpc2libGUnIDogJ2hpZGRlbicsIG92ZXJmbG93WTogcHJvcHMuaXNIZWlnaHRBdXRvID8gJ3Zpc2libGUnIDogJ2F1dG8nIH0sIGV2ZW50U2Vncy5sZW5ndGggPiAwID9cbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclNlZ0xpc3QoZXZlbnRTZWdzLCBkYXlEYXRlcykgOlxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRW1wdHlNZXNzYWdlKCkpKSk7XG4gICAgfVxuICAgIHJlbmRlckVtcHR5TWVzc2FnZSgpIHtcbiAgICAgICAgbGV0IHsgb3B0aW9ucywgdmlld0FwaSB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgcmVuZGVyUHJvcHMgPSB7XG4gICAgICAgICAgICB0ZXh0OiBvcHRpb25zLm5vRXZlbnRzVGV4dCxcbiAgICAgICAgICAgIHZpZXc6IHZpZXdBcGksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChDb250ZW50Q29udGFpbmVyLCB7IGVsVGFnOiBcImRpdlwiLCBlbENsYXNzZXM6IFsnZmMtbGlzdC1lbXB0eSddLCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGdlbmVyYXRvck5hbWU6IFwibm9FdmVudHNDb250ZW50XCIsIGN1c3RvbUdlbmVyYXRvcjogb3B0aW9ucy5ub0V2ZW50c0NvbnRlbnQsIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlck5vRXZlbnRzSW5uZXIsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy5ub0V2ZW50c0NsYXNzTmFtZXMsIGRpZE1vdW50OiBvcHRpb25zLm5vRXZlbnRzRGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLm5vRXZlbnRzV2lsbFVubW91bnQgfSwgKElubmVyQ29udGVudCkgPT4gKGNyZWF0ZUVsZW1lbnQoSW5uZXJDb250ZW50LCB7IGVsVGFnOiBcImRpdlwiLCBlbENsYXNzZXM6IFsnZmMtbGlzdC1lbXB0eS1jdXNoaW9uJ10gfSkpKSk7XG4gICAgfVxuICAgIHJlbmRlclNlZ0xpc3QoYWxsU2VncywgZGF5RGF0ZXMpIHtcbiAgICAgICAgbGV0IHsgdGhlbWUsIG9wdGlvbnMgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHsgdGltZUhlYWRlcklkLCBldmVudEhlYWRlcklkLCBkYXRlSGVhZGVySWRSb290IH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBsZXQgc2Vnc0J5RGF5ID0gZ3JvdXBTZWdzQnlEYXkoYWxsU2Vncyk7IC8vIHNwYXJzZSBhcnJheVxuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoTm93VGltZXIsIHsgdW5pdDogXCJkYXlcIiB9LCAobm93RGF0ZSwgdG9kYXlSYW5nZSkgPT4ge1xuICAgICAgICAgICAgbGV0IGlubmVyTm9kZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGRheUluZGV4ID0gMDsgZGF5SW5kZXggPCBzZWdzQnlEYXkubGVuZ3RoOyBkYXlJbmRleCArPSAxKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRheVNlZ3MgPSBzZWdzQnlEYXlbZGF5SW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChkYXlTZWdzKSB7IC8vIHNwYXJzZSBhcnJheSwgc28gbWlnaHQgYmUgdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIGxldCBkYXlTdHIgPSBmb3JtYXREYXlTdHJpbmcoZGF5RGF0ZXNbZGF5SW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGVIZWFkZXJJZCA9IGRhdGVIZWFkZXJJZFJvb3QgKyAnLScgKyBkYXlTdHI7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFwcGVuZCBhIGRheSBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJOb2Rlcy5wdXNoKGNyZWF0ZUVsZW1lbnQoTGlzdFZpZXdIZWFkZXJSb3csIHsga2V5OiBkYXlTdHIsIGNlbGxJZDogZGF0ZUhlYWRlcklkLCBkYXlEYXRlOiBkYXlEYXRlc1tkYXlJbmRleF0sIHRvZGF5UmFuZ2U6IHRvZGF5UmFuZ2UgfSkpO1xuICAgICAgICAgICAgICAgICAgICBkYXlTZWdzID0gc29ydEV2ZW50U2VncyhkYXlTZWdzLCBvcHRpb25zLmV2ZW50T3JkZXIpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBzZWcgb2YgZGF5U2Vncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJOb2Rlcy5wdXNoKGNyZWF0ZUVsZW1lbnQoTGlzdFZpZXdFdmVudFJvdywgT2JqZWN0LmFzc2lnbih7IGtleTogZGF5U3RyICsgJzonICsgc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZCAvKiBhcmUgbXVsdGlwbGUgc2VncyBmb3IgYW4gaW5zdGFuY2VJZCAqLywgc2VnOiBzZWcsIGlzRHJhZ2dpbmc6IGZhbHNlLCBpc1Jlc2l6aW5nOiBmYWxzZSwgaXNEYXRlU2VsZWN0aW5nOiBmYWxzZSwgaXNTZWxlY3RlZDogZmFsc2UsIHRpbWVIZWFkZXJJZDogdGltZUhlYWRlcklkLCBldmVudEhlYWRlcklkOiBldmVudEhlYWRlcklkLCBkYXRlSGVhZGVySWQ6IGRhdGVIZWFkZXJJZCB9LCBnZXRTZWdNZXRhKHNlZywgdG9kYXlSYW5nZSwgbm93RGF0ZSkpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJ0YWJsZVwiLCB7IGNsYXNzTmFtZTogJ2ZjLWxpc3QtdGFibGUgJyArIHRoZW1lLmdldENsYXNzKCd0YWJsZScpIH0sXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRoZWFkXCIsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJ0clwiLCBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRoXCIsIHsgc2NvcGU6IFwiY29sXCIsIGlkOiB0aW1lSGVhZGVySWQgfSwgb3B0aW9ucy50aW1lSGludCksXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwidGhcIiwgeyBzY29wZTogXCJjb2xcIiwgXCJhcmlhLWhpZGRlblwiOiB0cnVlIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRoXCIsIHsgc2NvcGU6IFwiY29sXCIsIGlkOiBldmVudEhlYWRlcklkIH0sIG9wdGlvbnMuZXZlbnRIaW50KSkpLFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJ0Ym9keVwiLCBudWxsLCBpbm5lck5vZGVzKSkpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIF9ldmVudFN0b3JlVG9TZWdzKGV2ZW50U3RvcmUsIGV2ZW50VWlCYXNlcywgZGF5UmFuZ2VzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50UmFuZ2VzVG9TZWdzKHNsaWNlRXZlbnRTdG9yZShldmVudFN0b3JlLCBldmVudFVpQmFzZXMsIHRoaXMucHJvcHMuZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UsIHRoaXMuY29udGV4dC5vcHRpb25zLm5leHREYXlUaHJlc2hvbGQpLmZnLCBkYXlSYW5nZXMpO1xuICAgIH1cbiAgICBldmVudFJhbmdlc1RvU2VncyhldmVudFJhbmdlcywgZGF5UmFuZ2VzKSB7XG4gICAgICAgIGxldCBzZWdzID0gW107XG4gICAgICAgIGZvciAobGV0IGV2ZW50UmFuZ2Ugb2YgZXZlbnRSYW5nZXMpIHtcbiAgICAgICAgICAgIHNlZ3MucHVzaCguLi50aGlzLmV2ZW50UmFuZ2VUb1NlZ3MoZXZlbnRSYW5nZSwgZGF5UmFuZ2VzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlZ3M7XG4gICAgfVxuICAgIGV2ZW50UmFuZ2VUb1NlZ3MoZXZlbnRSYW5nZSwgZGF5UmFuZ2VzKSB7XG4gICAgICAgIGxldCB7IGRhdGVFbnYgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHsgbmV4dERheVRocmVzaG9sZCB9ID0gdGhpcy5jb250ZXh0Lm9wdGlvbnM7XG4gICAgICAgIGxldCByYW5nZSA9IGV2ZW50UmFuZ2UucmFuZ2U7XG4gICAgICAgIGxldCBhbGxEYXkgPSBldmVudFJhbmdlLmRlZi5hbGxEYXk7XG4gICAgICAgIGxldCBkYXlJbmRleDtcbiAgICAgICAgbGV0IHNlZ1JhbmdlO1xuICAgICAgICBsZXQgc2VnO1xuICAgICAgICBsZXQgc2VncyA9IFtdO1xuICAgICAgICBmb3IgKGRheUluZGV4ID0gMDsgZGF5SW5kZXggPCBkYXlSYW5nZXMubGVuZ3RoOyBkYXlJbmRleCArPSAxKSB7XG4gICAgICAgICAgICBzZWdSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhyYW5nZSwgZGF5UmFuZ2VzW2RheUluZGV4XSk7XG4gICAgICAgICAgICBpZiAoc2VnUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBzZWcgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudDogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRSYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHNlZ1JhbmdlLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IHNlZ1JhbmdlLmVuZCxcbiAgICAgICAgICAgICAgICAgICAgaXNTdGFydDogZXZlbnRSYW5nZS5pc1N0YXJ0ICYmIHNlZ1JhbmdlLnN0YXJ0LnZhbHVlT2YoKSA9PT0gcmFuZ2Uuc3RhcnQudmFsdWVPZigpLFxuICAgICAgICAgICAgICAgICAgICBpc0VuZDogZXZlbnRSYW5nZS5pc0VuZCAmJiBzZWdSYW5nZS5lbmQudmFsdWVPZigpID09PSByYW5nZS5lbmQudmFsdWVPZigpLFxuICAgICAgICAgICAgICAgICAgICBkYXlJbmRleCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHNlZ3MucHVzaChzZWcpO1xuICAgICAgICAgICAgICAgIC8vIGRldGVjdCB3aGVuIHJhbmdlIHdvbid0IGdvIGZ1bGx5IGludG8gdGhlIG5leHQgZGF5LFxuICAgICAgICAgICAgICAgIC8vIGFuZCBtdXRhdGUgdGhlIGxhdGVzdCBzZWcgdG8gdGhlIGJlIHRoZSBlbmQuXG4gICAgICAgICAgICAgICAgaWYgKCFzZWcuaXNFbmQgJiYgIWFsbERheSAmJlxuICAgICAgICAgICAgICAgICAgICBkYXlJbmRleCArIDEgPCBkYXlSYW5nZXMubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLmVuZCA8XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlRW52LmFkZChkYXlSYW5nZXNbZGF5SW5kZXggKyAxXS5zdGFydCwgbmV4dERheVRocmVzaG9sZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VnLmVuZCA9IHJhbmdlLmVuZDtcbiAgICAgICAgICAgICAgICAgICAgc2VnLmlzRW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWdzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbmRlck5vRXZlbnRzSW5uZXIocmVuZGVyUHJvcHMpIHtcbiAgICByZXR1cm4gcmVuZGVyUHJvcHMudGV4dDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVEYXRlVmFycyhkYXRlUHJvZmlsZSkge1xuICAgIGxldCBkYXlTdGFydCA9IHN0YXJ0T2ZEYXkoZGF0ZVByb2ZpbGUucmVuZGVyUmFuZ2Uuc3RhcnQpO1xuICAgIGxldCB2aWV3RW5kID0gZGF0ZVByb2ZpbGUucmVuZGVyUmFuZ2UuZW5kO1xuICAgIGxldCBkYXlEYXRlcyA9IFtdO1xuICAgIGxldCBkYXlSYW5nZXMgPSBbXTtcbiAgICB3aGlsZSAoZGF5U3RhcnQgPCB2aWV3RW5kKSB7XG4gICAgICAgIGRheURhdGVzLnB1c2goZGF5U3RhcnQpO1xuICAgICAgICBkYXlSYW5nZXMucHVzaCh7XG4gICAgICAgICAgICBzdGFydDogZGF5U3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGFkZERheXMoZGF5U3RhcnQsIDEpLFxuICAgICAgICB9KTtcbiAgICAgICAgZGF5U3RhcnQgPSBhZGREYXlzKGRheVN0YXJ0LCAxKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZGF5RGF0ZXMsIGRheVJhbmdlcyB9O1xufVxuLy8gUmV0dXJucyBhIHNwYXJzZSBhcnJheSBvZiBhcnJheXMsIHNlZ3MgZ3JvdXBlZCBieSB0aGVpciBkYXlJbmRleFxuZnVuY3Rpb24gZ3JvdXBTZWdzQnlEYXkoc2Vncykge1xuICAgIGxldCBzZWdzQnlEYXkgPSBbXTsgLy8gc3BhcnNlIGFycmF5XG4gICAgbGV0IGk7XG4gICAgbGV0IHNlZztcbiAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBzZWcgPSBzZWdzW2ldO1xuICAgICAgICAoc2Vnc0J5RGF5W3NlZy5kYXlJbmRleF0gfHwgKHNlZ3NCeURheVtzZWcuZGF5SW5kZXhdID0gW10pKVxuICAgICAgICAgICAgLnB1c2goc2VnKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlZ3NCeURheTtcbn1cblxudmFyIGNzc18yNDh6ID0gXCI6cm9vdHstLWZjLWxpc3QtZXZlbnQtZG90LXdpZHRoOjEwcHg7LS1mYy1saXN0LWV2ZW50LWhvdmVyLWJnLWNvbG9yOiNmNWY1ZjV9LmZjLXRoZW1lLXN0YW5kYXJkIC5mYy1saXN0e2JvcmRlcjoxcHggc29saWQgdmFyKC0tZmMtYm9yZGVyLWNvbG9yKX0uZmMgLmZjLWxpc3QtZW1wdHl7YWxpZ24taXRlbXM6Y2VudGVyO2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmMtbmV1dHJhbC1iZy1jb2xvcik7ZGlzcGxheTpmbGV4O2hlaWdodDoxMDAlO2p1c3RpZnktY29udGVudDpjZW50ZXJ9LmZjIC5mYy1saXN0LWVtcHR5LWN1c2hpb257bWFyZ2luOjVlbSAwfS5mYyAuZmMtbGlzdC10YWJsZXtib3JkZXItc3R5bGU6aGlkZGVuO3dpZHRoOjEwMCV9LmZjIC5mYy1saXN0LXRhYmxlIHRyPip7Ym9yZGVyLWxlZnQ6MDtib3JkZXItcmlnaHQ6MH0uZmMgLmZjLWxpc3Qtc3RpY2t5IC5mYy1saXN0LWRheT4qe2JhY2tncm91bmQ6dmFyKC0tZmMtcGFnZS1iZy1jb2xvcik7cG9zaXRpb246c3RpY2t5O3RvcDowfS5mYyAuZmMtbGlzdC10YWJsZSB0aGVhZHtsZWZ0Oi0xMDAwMHB4O3Bvc2l0aW9uOmFic29sdXRlfS5mYyAuZmMtbGlzdC10YWJsZSB0Ym9keT50cjpmaXJzdC1jaGlsZCB0aHtib3JkZXItdG9wOjB9LmZjIC5mYy1saXN0LXRhYmxlIHRoe3BhZGRpbmc6MH0uZmMgLmZjLWxpc3QtZGF5LWN1c2hpb24sLmZjIC5mYy1saXN0LXRhYmxlIHRke3BhZGRpbmc6OHB4IDE0cHh9LmZjIC5mYy1saXN0LWRheS1jdXNoaW9uOmFmdGVye2NsZWFyOmJvdGg7Y29udGVudDpcXFwiXFxcIjtkaXNwbGF5OnRhYmxlfS5mYy10aGVtZS1zdGFuZGFyZCAuZmMtbGlzdC1kYXktY3VzaGlvbntiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWZjLW5ldXRyYWwtYmctY29sb3IpfS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1saXN0LWRheS10ZXh0LC5mYy1kaXJlY3Rpb24tcnRsIC5mYy1saXN0LWRheS1zaWRlLXRleHR7ZmxvYXQ6bGVmdH0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtbGlzdC1kYXktc2lkZS10ZXh0LC5mYy1kaXJlY3Rpb24tcnRsIC5mYy1saXN0LWRheS10ZXh0e2Zsb2F0OnJpZ2h0fS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1saXN0LXRhYmxlIC5mYy1saXN0LWV2ZW50LWdyYXBoaWN7cGFkZGluZy1yaWdodDowfS5mYy1kaXJlY3Rpb24tcnRsIC5mYy1saXN0LXRhYmxlIC5mYy1saXN0LWV2ZW50LWdyYXBoaWN7cGFkZGluZy1sZWZ0OjB9LmZjIC5mYy1saXN0LWV2ZW50LmZjLWV2ZW50LWZvcmNlZC11cmx7Y3Vyc29yOnBvaW50ZXJ9LmZjIC5mYy1saXN0LWV2ZW50OmhvdmVyIHRke2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmMtbGlzdC1ldmVudC1ob3Zlci1iZy1jb2xvcil9LmZjIC5mYy1saXN0LWV2ZW50LWdyYXBoaWMsLmZjIC5mYy1saXN0LWV2ZW50LXRpbWV7d2hpdGUtc3BhY2U6bm93cmFwO3dpZHRoOjFweH0uZmMgLmZjLWxpc3QtZXZlbnQtZG90e2JvcmRlcjpjYWxjKHZhcigtLWZjLWxpc3QtZXZlbnQtZG90LXdpZHRoKS8yKSBzb2xpZCB2YXIoLS1mYy1ldmVudC1ib3JkZXItY29sb3IpO2JvcmRlci1yYWRpdXM6Y2FsYyh2YXIoLS1mYy1saXN0LWV2ZW50LWRvdC13aWR0aCkvMik7Ym94LXNpemluZzpjb250ZW50LWJveDtkaXNwbGF5OmlubGluZS1ibG9jaztoZWlnaHQ6MDt3aWR0aDowfS5mYyAuZmMtbGlzdC1ldmVudC10aXRsZSBhe2NvbG9yOmluaGVyaXQ7dGV4dC1kZWNvcmF0aW9uOm5vbmV9LmZjIC5mYy1saXN0LWV2ZW50LmZjLWV2ZW50LWZvcmNlZC11cmw6aG92ZXIgYXt0ZXh0LWRlY29yYXRpb246dW5kZXJsaW5lfVwiO1xuaW5qZWN0U3R5bGVzKGNzc18yNDh6KTtcblxuZXhwb3J0IHsgTGlzdFZpZXcgfTtcbiIsICJpbXBvcnQgeyBjcmVhdGVQbHVnaW4gfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvcmUvaW5kZXguanMnO1xuaW1wb3J0IHsgTGlzdFZpZXcgfSBmcm9tICcuL2ludGVybmFsLmpzJztcbmltcG9ydCB7IGlkZW50aXR5LCBjcmVhdGVGb3JtYXR0ZXIgfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvcmUvaW50ZXJuYWwuanMnO1xuaW1wb3J0ICdAZnVsbGNhbGVuZGFyL2NvcmUvcHJlYWN0LmpzJztcblxuY29uc3QgT1BUSU9OX1JFRklORVJTID0ge1xuICAgIGxpc3REYXlGb3JtYXQ6IGNyZWF0ZUZhbHNhYmxlRm9ybWF0dGVyLFxuICAgIGxpc3REYXlTaWRlRm9ybWF0OiBjcmVhdGVGYWxzYWJsZUZvcm1hdHRlcixcbiAgICBub0V2ZW50c0NsYXNzTmFtZXM6IGlkZW50aXR5LFxuICAgIG5vRXZlbnRzQ29udGVudDogaWRlbnRpdHksXG4gICAgbm9FdmVudHNEaWRNb3VudDogaWRlbnRpdHksXG4gICAgbm9FdmVudHNXaWxsVW5tb3VudDogaWRlbnRpdHksXG4gICAgLy8gbm9FdmVudHNUZXh0IGlzIGRlZmluZWQgaW4gYmFzZSBvcHRpb25zXG59O1xuZnVuY3Rpb24gY3JlYXRlRmFsc2FibGVGb3JtYXR0ZXIoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQgPT09IGZhbHNlID8gbnVsbCA6IGNyZWF0ZUZvcm1hdHRlcihpbnB1dCk7XG59XG5cbnZhciBpbmRleCA9IGNyZWF0ZVBsdWdpbih7XG4gICAgbmFtZTogJ0BmdWxsY2FsZW5kYXIvbGlzdCcsXG4gICAgb3B0aW9uUmVmaW5lcnM6IE9QVElPTl9SRUZJTkVSUyxcbiAgICB2aWV3czoge1xuICAgICAgICBsaXN0OiB7XG4gICAgICAgICAgICBjb21wb25lbnQ6IExpc3RWaWV3LFxuICAgICAgICAgICAgYnV0dG9uVGV4dEtleTogJ2xpc3QnLFxuICAgICAgICAgICAgbGlzdERheUZvcm1hdDogeyBtb250aDogJ2xvbmcnLCBkYXk6ICdudW1lcmljJywgeWVhcjogJ251bWVyaWMnIH0sIC8vIGxpa2UgXCJKYW51YXJ5IDEsIDIwMTZcIlxuICAgICAgICB9LFxuICAgICAgICBsaXN0RGF5OiB7XG4gICAgICAgICAgICB0eXBlOiAnbGlzdCcsXG4gICAgICAgICAgICBkdXJhdGlvbjogeyBkYXlzOiAxIH0sXG4gICAgICAgICAgICBsaXN0RGF5Rm9ybWF0OiB7IHdlZWtkYXk6ICdsb25nJyB9LCAvLyBkYXktb2Ytd2VlayBpcyBhbGwgd2UgbmVlZC4gZnVsbCBkYXRlIGlzIHByb2JhYmx5IGluIGhlYWRlclRvb2xiYXJcbiAgICAgICAgfSxcbiAgICAgICAgbGlzdFdlZWs6IHtcbiAgICAgICAgICAgIHR5cGU6ICdsaXN0JyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB7IHdlZWtzOiAxIH0sXG4gICAgICAgICAgICBsaXN0RGF5Rm9ybWF0OiB7IHdlZWtkYXk6ICdsb25nJyB9LFxuICAgICAgICAgICAgbGlzdERheVNpZGVGb3JtYXQ6IHsgbW9udGg6ICdsb25nJywgZGF5OiAnbnVtZXJpYycsIHllYXI6ICdudW1lcmljJyB9LFxuICAgICAgICB9LFxuICAgICAgICBsaXN0TW9udGg6IHtcbiAgICAgICAgICAgIHR5cGU6ICdsaXN0JyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB7IG1vbnRoOiAxIH0sXG4gICAgICAgICAgICBsaXN0RGF5U2lkZUZvcm1hdDogeyB3ZWVrZGF5OiAnbG9uZycgfSwgLy8gZGF5LW9mLXdlZWsgaXMgbmljZS10by1oYXZlXG4gICAgICAgIH0sXG4gICAgICAgIGxpc3RZZWFyOiB7XG4gICAgICAgICAgICB0eXBlOiAnbGlzdCcsXG4gICAgICAgICAgICBkdXJhdGlvbjogeyB5ZWFyOiAxIH0sXG4gICAgICAgICAgICBsaXN0RGF5U2lkZUZvcm1hdDogeyB3ZWVrZGF5OiAnbG9uZycgfSwgLy8gZGF5LW9mLXdlZWsgaXMgbmljZS10by1oYXZlXG4gICAgICAgIH0sXG4gICAgfSxcbn0pO1xuXG5leHBvcnQgeyBpbmRleCBhcyBkZWZhdWx0IH07XG4iLCAiaW1wb3J0IHsgY3JlYXRlUGx1Z2luIH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb3JlL2luZGV4LmpzJztcbmltcG9ydCB7IGNvbmZpZywgRW1pdHRlciwgZWxlbWVudENsb3Nlc3QsIGFwcGx5U3R5bGUsIHdoZW5UcmFuc2l0aW9uRG9uZSwgcmVtb3ZlRWxlbWVudCwgU2Nyb2xsQ29udHJvbGxlciwgRWxlbWVudFNjcm9sbENvbnRyb2xsZXIsIGNvbXB1dGVJbm5lclJlY3QsIFdpbmRvd1Njcm9sbENvbnRyb2xsZXIsIEVsZW1lbnREcmFnZ2luZywgcHJldmVudFNlbGVjdGlvbiwgcHJldmVudENvbnRleHRNZW51LCBhbGxvd1NlbGVjdGlvbiwgYWxsb3dDb250ZXh0TWVudSwgY29tcHV0ZVJlY3QsIGdldENsaXBwaW5nUGFyZW50cywgcG9pbnRJbnNpZGVSZWN0LCBjb25zdHJhaW5Qb2ludCwgaW50ZXJzZWN0UmVjdHMsIGdldFJlY3RDZW50ZXIsIGRpZmZQb2ludHMsIG1hcEhhc2gsIHJhbmdlQ29udGFpbnNSYW5nZSwgaXNEYXRlU3BhbnNFcXVhbCwgSW50ZXJhY3Rpb24sIGludGVyYWN0aW9uU2V0dGluZ3NUb1N0b3JlLCBpc0RhdGVTZWxlY3Rpb25WYWxpZCwgZW5hYmxlQ3Vyc29yLCBkaXNhYmxlQ3Vyc29yLCB0cmlnZ2VyRGF0ZVNlbGVjdCwgY29tcGFyZU51bWJlcnMsIGdldEVsU2VnLCBnZXRSZWxldmFudEV2ZW50cywgRXZlbnRJbXBsLCBjcmVhdGVFbXB0eUV2ZW50U3RvcmUsIGFwcGx5TXV0YXRpb25Ub0V2ZW50U3RvcmUsIGlzSW50ZXJhY3Rpb25WYWxpZCwgYnVpbGRFdmVudEFwaXMsIGludGVyYWN0aW9uU2V0dGluZ3NTdG9yZSwgc3RhcnRPZkRheSwgZGlmZkRhdGVzLCBjcmVhdGVEdXJhdGlvbiwgZ2V0RXZlbnRUYXJnZXRWaWFSb290LCBpZGVudGl0eSwgZXZlbnRUdXBsZVRvU3RvcmUsIHBhcnNlRHJhZ01ldGEsIGVsZW1lbnRNYXRjaGVzLCByZWZpbmVFdmVudERlZiwgcGFyc2VFdmVudERlZiwgZ2V0RGVmYXVsdEV2ZW50RW5kLCBjcmVhdGVFdmVudEluc3RhbmNlLCBCQVNFX09QVElPTl9ERUZBVUxUUyB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29yZS9pbnRlcm5hbC5qcyc7XG5cbmNvbmZpZy50b3VjaE1vdXNlSWdub3JlV2FpdCA9IDUwMDtcbmxldCBpZ25vcmVNb3VzZURlcHRoID0gMDtcbmxldCBsaXN0ZW5lckNudCA9IDA7XG5sZXQgaXNXaW5kb3dUb3VjaE1vdmVDYW5jZWxsZWQgPSBmYWxzZTtcbi8qXG5Vc2VzIGEgXCJwb2ludGVyXCIgYWJzdHJhY3Rpb24sIHdoaWNoIG1vbml0b3JzIFVJIGV2ZW50cyBmb3IgYm90aCBtb3VzZSBhbmQgdG91Y2guXG5UcmFja3Mgd2hlbiB0aGUgcG9pbnRlciBcImRyYWdzXCIgb24gYSBjZXJ0YWluIGVsZW1lbnQsIG1lYW5pbmcgZG93bittb3ZlK3VwLlxuXG5BbHNvLCB0cmFja3MgaWYgdGhlcmUgd2FzIHRvdWNoLXNjcm9sbGluZy5cbkFsc28sIGNhbiBwcmV2ZW50IHRvdWNoLXNjcm9sbGluZyBmcm9tIGhhcHBlbmluZy5cbkFsc28sIGNhbiBmaXJlIHBvaW50ZXJtb3ZlIGV2ZW50cyB3aGVuIHNjcm9sbGluZyBoYXBwZW5zIHVuZGVybmVhdGgsIGV2ZW4gd2hlbiBubyByZWFsIHBvaW50ZXIgbW92ZW1lbnQuXG5cbmVtaXRzOlxuLSBwb2ludGVyZG93blxuLSBwb2ludGVybW92ZVxuLSBwb2ludGVydXBcbiovXG5jbGFzcyBQb2ludGVyRHJhZ2dpbmcge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lckVsKSB7XG4gICAgICAgIHRoaXMuc3ViamVjdEVsID0gbnVsbDtcbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IGNhbiBiZSBkaXJlY3RseSBhc3NpZ25lZCBieSBjYWxsZXJcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9ICcnOyAvLyB3aWxsIGNhdXNlIHN1YmplY3RFbCBpbiBhbGwgZW1pdHRlZCBldmVudHMgdG8gYmUgdGhpcyBlbGVtZW50XG4gICAgICAgIHRoaXMuaGFuZGxlU2VsZWN0b3IgPSAnJztcbiAgICAgICAgdGhpcy5zaG91bGRJZ25vcmVNb3ZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2hvdWxkV2F0Y2hTY3JvbGwgPSB0cnVlOyAvLyBmb3Igc2ltdWxhdGluZyBwb2ludGVybW92ZSBvbiBzY3JvbGxcbiAgICAgICAgLy8gaW50ZXJuYWwgc3RhdGVzXG4gICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzVG91Y2hEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLndhc1RvdWNoU2Nyb2xsID0gZmFsc2U7XG4gICAgICAgIC8vIE1vdXNlXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgdGhpcy5oYW5kbGVNb3VzZURvd24gPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zaG91bGRJZ25vcmVNb3VzZSgpICYmXG4gICAgICAgICAgICAgICAgaXNQcmltYXJ5TW91c2VCdXR0b24oZXYpICYmXG4gICAgICAgICAgICAgICAgdGhpcy50cnlTdGFydChldikpIHtcbiAgICAgICAgICAgICAgICBsZXQgcGV2ID0gdGhpcy5jcmVhdGVFdmVudEZyb21Nb3VzZShldiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJkb3duJywgcGV2KTtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRTY3JvbGxXYXRjaChwZXYpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zaG91bGRJZ25vcmVNb3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuaGFuZGxlTW91c2VNb3ZlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuaGFuZGxlTW91c2VVcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlTW91c2VNb3ZlID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBsZXQgcGV2ID0gdGhpcy5jcmVhdGVFdmVudEZyb21Nb3VzZShldik7XG4gICAgICAgICAgICB0aGlzLnJlY29yZENvb3JkcyhwZXYpO1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJtb3ZlJywgcGV2KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVNb3VzZVVwID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLmhhbmRsZU1vdXNlTW92ZSk7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVydXAnLCB0aGlzLmNyZWF0ZUV2ZW50RnJvbU1vdXNlKGV2KSk7XG4gICAgICAgICAgICB0aGlzLmNsZWFudXAoKTsgLy8gY2FsbCBsYXN0IHNvIHRoYXQgcG9pbnRlcnVwIGhhcyBhY2Nlc3MgdG8gcHJvcHNcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVG91Y2hcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICB0aGlzLmhhbmRsZVRvdWNoU3RhcnQgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRyeVN0YXJ0KGV2KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNUb3VjaERyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBsZXQgcGV2ID0gdGhpcy5jcmVhdGVFdmVudEZyb21Ub3VjaChldiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJkb3duJywgcGV2KTtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRTY3JvbGxXYXRjaChwZXYpO1xuICAgICAgICAgICAgICAgIC8vIHVubGlrZSBtb3VzZSwgbmVlZCB0byBhdHRhY2ggdG8gdGFyZ2V0LCBub3QgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDU3NjAwMTRcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0RWwgPSBldi50YXJnZXQ7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNob3VsZElnbm9yZU1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5oYW5kbGVUb3VjaE1vdmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0YXJnZXRFbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuaGFuZGxlVG91Y2hFbmQpO1xuICAgICAgICAgICAgICAgIHRhcmdldEVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpcy5oYW5kbGVUb3VjaEVuZCk7IC8vIHRyZWF0IGl0IGFzIGEgdG91Y2ggZW5kXG4gICAgICAgICAgICAgICAgLy8gYXR0YWNoIGEgaGFuZGxlciB0byBnZXQgY2FsbGVkIHdoZW4gQU5ZIHNjcm9sbCBhY3Rpb24gaGFwcGVucyBvbiB0aGUgcGFnZS5cbiAgICAgICAgICAgICAgICAvLyB0aGlzIHdhcyBpbXBvc3NpYmxlIHRvIGRvIHdpdGggbm9ybWFsIG9uL29mZiBiZWNhdXNlICdzY3JvbGwnIGRvZXNuJ3QgYnViYmxlLlxuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzMyOTU0NTY1Lzk2MzQyXG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuaGFuZGxlVG91Y2hTY3JvbGwsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVRvdWNoTW92ZSA9IChldikgPT4ge1xuICAgICAgICAgICAgbGV0IHBldiA9IHRoaXMuY3JlYXRlRXZlbnRGcm9tVG91Y2goZXYpO1xuICAgICAgICAgICAgdGhpcy5yZWNvcmRDb29yZHMocGV2KTtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVybW92ZScsIHBldik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlVG91Y2hFbmQgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcpIHsgLy8gZG9uZSB0byBndWFyZCBhZ2FpbnN0IHRvdWNoZW5kIGZvbGxvd2VkIGJ5IHRvdWNoY2FuY2VsXG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldEVsID0gZXYudGFyZ2V0O1xuICAgICAgICAgICAgICAgIHRhcmdldEVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuaGFuZGxlVG91Y2hNb3ZlKTtcbiAgICAgICAgICAgICAgICB0YXJnZXRFbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuaGFuZGxlVG91Y2hFbmQpO1xuICAgICAgICAgICAgICAgIHRhcmdldEVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpcy5oYW5kbGVUb3VjaEVuZCk7XG4gICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuaGFuZGxlVG91Y2hTY3JvbGwsIHRydWUpOyAvLyB1c2VDYXB0dXJlZD10cnVlXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJ1cCcsIHRoaXMuY3JlYXRlRXZlbnRGcm9tVG91Y2goZXYpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFudXAoKTsgLy8gY2FsbCBsYXN0IHNvIHRoYXQgcG9pbnRlcnVwIGhhcyBhY2Nlc3MgdG8gcHJvcHNcbiAgICAgICAgICAgICAgICB0aGlzLmlzVG91Y2hEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHN0YXJ0SWdub3JpbmdNb3VzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVRvdWNoU2Nyb2xsID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy53YXNUb3VjaFNjcm9sbCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlU2Nyb2xsID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2hvdWxkSWdub3JlTW92ZSkge1xuICAgICAgICAgICAgICAgIGxldCBwYWdlWCA9ICh3aW5kb3cuc2Nyb2xsWCAtIHRoaXMucHJldlNjcm9sbFgpICsgdGhpcy5wcmV2UGFnZVg7XG4gICAgICAgICAgICAgICAgbGV0IHBhZ2VZID0gKHdpbmRvdy5zY3JvbGxZIC0gdGhpcy5wcmV2U2Nyb2xsWSkgKyB0aGlzLnByZXZQYWdlWTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcm1vdmUnLCB7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdFdmVudDogZXYsXG4gICAgICAgICAgICAgICAgICAgIGlzVG91Y2g6IHRoaXMuaXNUb3VjaERyYWdnaW5nLFxuICAgICAgICAgICAgICAgICAgICBzdWJqZWN0RWw6IHRoaXMuc3ViamVjdEVsLFxuICAgICAgICAgICAgICAgICAgICBwYWdlWCxcbiAgICAgICAgICAgICAgICAgICAgcGFnZVksXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhWDogcGFnZVggLSB0aGlzLm9yaWdQYWdlWCxcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFZOiBwYWdlWSAtIHRoaXMub3JpZ1BhZ2VZLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNvbnRhaW5lckVsID0gY29udGFpbmVyRWw7XG4gICAgICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XG4gICAgICAgIGNvbnRhaW5lckVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlTW91c2VEb3duKTtcbiAgICAgICAgY29udGFpbmVyRWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuaGFuZGxlVG91Y2hTdGFydCwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICBsaXN0ZW5lckNyZWF0ZWQoKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXJFbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZU1vdXNlRG93bik7XG4gICAgICAgIHRoaXMuY29udGFpbmVyRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuaGFuZGxlVG91Y2hTdGFydCwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICBsaXN0ZW5lckRlc3Ryb3llZCgpO1xuICAgIH1cbiAgICB0cnlTdGFydChldikge1xuICAgICAgICBsZXQgc3ViamVjdEVsID0gdGhpcy5xdWVyeVN1YmplY3RFbChldik7XG4gICAgICAgIGxldCBkb3duRWwgPSBldi50YXJnZXQ7XG4gICAgICAgIGlmIChzdWJqZWN0RWwgJiZcbiAgICAgICAgICAgICghdGhpcy5oYW5kbGVTZWxlY3RvciB8fCBlbGVtZW50Q2xvc2VzdChkb3duRWwsIHRoaXMuaGFuZGxlU2VsZWN0b3IpKSkge1xuICAgICAgICAgICAgdGhpcy5zdWJqZWN0RWwgPSBzdWJqZWN0RWw7XG4gICAgICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSB0cnVlOyAvLyBkbyB0aGlzIGZpcnN0IHNvIGNhbmNlbFRvdWNoU2Nyb2xsIHdpbGwgd29ya1xuICAgICAgICAgICAgdGhpcy53YXNUb3VjaFNjcm9sbCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjbGVhbnVwKCkge1xuICAgICAgICBpc1dpbmRvd1RvdWNoTW92ZUNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdWJqZWN0RWwgPSBudWxsO1xuICAgICAgICAvLyBrZWVwIHdhc1RvdWNoU2Nyb2xsIGFyb3VuZCBmb3IgbGF0ZXIgYWNjZXNzXG4gICAgICAgIHRoaXMuZGVzdHJveVNjcm9sbFdhdGNoKCk7XG4gICAgfVxuICAgIHF1ZXJ5U3ViamVjdEVsKGV2KSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudENsb3Nlc3QoZXYudGFyZ2V0LCB0aGlzLnNlbGVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXJFbDtcbiAgICB9XG4gICAgc2hvdWxkSWdub3JlTW91c2UoKSB7XG4gICAgICAgIHJldHVybiBpZ25vcmVNb3VzZURlcHRoIHx8IHRoaXMuaXNUb3VjaERyYWdnaW5nO1xuICAgIH1cbiAgICAvLyBjYW4gYmUgY2FsbGVkIGJ5IHVzZXIgb2YgdGhpcyBjbGFzcywgdG8gY2FuY2VsIHRvdWNoLWJhc2VkIHNjcm9sbGluZyBmb3IgdGhlIGN1cnJlbnQgZHJhZ1xuICAgIGNhbmNlbFRvdWNoU2Nyb2xsKCkge1xuICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICBpc1dpbmRvd1RvdWNoTW92ZUNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gU2Nyb2xsaW5nIHRoYXQgc2ltdWxhdGVzIHBvaW50ZXJtb3Zlc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBpbml0U2Nyb2xsV2F0Y2goZXYpIHtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkV2F0Y2hTY3JvbGwpIHtcbiAgICAgICAgICAgIHRoaXMucmVjb3JkQ29vcmRzKGV2KTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLmhhbmRsZVNjcm9sbCwgdHJ1ZSk7IC8vIHVzZUNhcHR1cmU9dHJ1ZVxuICAgICAgICB9XG4gICAgfVxuICAgIHJlY29yZENvb3Jkcyhldikge1xuICAgICAgICBpZiAodGhpcy5zaG91bGRXYXRjaFNjcm9sbCkge1xuICAgICAgICAgICAgdGhpcy5wcmV2UGFnZVggPSBldi5wYWdlWDtcbiAgICAgICAgICAgIHRoaXMucHJldlBhZ2VZID0gZXYucGFnZVk7XG4gICAgICAgICAgICB0aGlzLnByZXZTY3JvbGxYID0gd2luZG93LnNjcm9sbFg7XG4gICAgICAgICAgICB0aGlzLnByZXZTY3JvbGxZID0gd2luZG93LnNjcm9sbFk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveVNjcm9sbFdhdGNoKCkge1xuICAgICAgICBpZiAodGhpcy5zaG91bGRXYXRjaFNjcm9sbCkge1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuaGFuZGxlU2Nyb2xsLCB0cnVlKTsgLy8gdXNlQ2FwdHVyZWQ9dHJ1ZVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEV2ZW50IE5vcm1hbGl6YXRpb25cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgY3JlYXRlRXZlbnRGcm9tTW91c2UoZXYsIGlzRmlyc3QpIHtcbiAgICAgICAgbGV0IGRlbHRhWCA9IDA7XG4gICAgICAgIGxldCBkZWx0YVkgPSAwO1xuICAgICAgICAvLyBUT0RPOiByZXBlYXQgY29kZVxuICAgICAgICBpZiAoaXNGaXJzdCkge1xuICAgICAgICAgICAgdGhpcy5vcmlnUGFnZVggPSBldi5wYWdlWDtcbiAgICAgICAgICAgIHRoaXMub3JpZ1BhZ2VZID0gZXYucGFnZVk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWx0YVggPSBldi5wYWdlWCAtIHRoaXMub3JpZ1BhZ2VYO1xuICAgICAgICAgICAgZGVsdGFZID0gZXYucGFnZVkgLSB0aGlzLm9yaWdQYWdlWTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3JpZ0V2ZW50OiBldixcbiAgICAgICAgICAgIGlzVG91Y2g6IGZhbHNlLFxuICAgICAgICAgICAgc3ViamVjdEVsOiB0aGlzLnN1YmplY3RFbCxcbiAgICAgICAgICAgIHBhZ2VYOiBldi5wYWdlWCxcbiAgICAgICAgICAgIHBhZ2VZOiBldi5wYWdlWSxcbiAgICAgICAgICAgIGRlbHRhWCxcbiAgICAgICAgICAgIGRlbHRhWSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY3JlYXRlRXZlbnRGcm9tVG91Y2goZXYsIGlzRmlyc3QpIHtcbiAgICAgICAgbGV0IHRvdWNoZXMgPSBldi50b3VjaGVzO1xuICAgICAgICBsZXQgcGFnZVg7XG4gICAgICAgIGxldCBwYWdlWTtcbiAgICAgICAgbGV0IGRlbHRhWCA9IDA7XG4gICAgICAgIGxldCBkZWx0YVkgPSAwO1xuICAgICAgICAvLyBpZiB0b3VjaCBjb29yZHMgYXZhaWxhYmxlLCBwcmVmZXIsXG4gICAgICAgIC8vIGJlY2F1c2UgRkYgd291bGQgZ2l2ZSBiYWQgZXYucGFnZVggZXYucGFnZVlcbiAgICAgICAgaWYgKHRvdWNoZXMgJiYgdG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHBhZ2VYID0gdG91Y2hlc1swXS5wYWdlWDtcbiAgICAgICAgICAgIHBhZ2VZID0gdG91Y2hlc1swXS5wYWdlWTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhZ2VYID0gZXYucGFnZVg7XG4gICAgICAgICAgICBwYWdlWSA9IGV2LnBhZ2VZO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IHJlcGVhdCBjb2RlXG4gICAgICAgIGlmIChpc0ZpcnN0KSB7XG4gICAgICAgICAgICB0aGlzLm9yaWdQYWdlWCA9IHBhZ2VYO1xuICAgICAgICAgICAgdGhpcy5vcmlnUGFnZVkgPSBwYWdlWTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbHRhWCA9IHBhZ2VYIC0gdGhpcy5vcmlnUGFnZVg7XG4gICAgICAgICAgICBkZWx0YVkgPSBwYWdlWSAtIHRoaXMub3JpZ1BhZ2VZO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvcmlnRXZlbnQ6IGV2LFxuICAgICAgICAgICAgaXNUb3VjaDogdHJ1ZSxcbiAgICAgICAgICAgIHN1YmplY3RFbDogdGhpcy5zdWJqZWN0RWwsXG4gICAgICAgICAgICBwYWdlWCxcbiAgICAgICAgICAgIHBhZ2VZLFxuICAgICAgICAgICAgZGVsdGFYLFxuICAgICAgICAgICAgZGVsdGFZLFxuICAgICAgICB9O1xuICAgIH1cbn1cbi8vIFJldHVybnMgYSBib29sZWFuIHdoZXRoZXIgdGhpcyB3YXMgYSBsZWZ0IG1vdXNlIGNsaWNrIGFuZCBubyBjdHJsIGtleSAod2hpY2ggbWVhbnMgcmlnaHQgY2xpY2sgb24gTWFjKVxuZnVuY3Rpb24gaXNQcmltYXJ5TW91c2VCdXR0b24oZXYpIHtcbiAgICByZXR1cm4gZXYuYnV0dG9uID09PSAwICYmICFldi5jdHJsS2V5O1xufVxuLy8gSWdub3JpbmcgZmFrZSBtb3VzZSBldmVudHMgZ2VuZXJhdGVkIGJ5IHRvdWNoXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBzdGFydElnbm9yaW5nTW91c2UoKSB7XG4gICAgaWdub3JlTW91c2VEZXB0aCArPSAxO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZ25vcmVNb3VzZURlcHRoIC09IDE7XG4gICAgfSwgY29uZmlnLnRvdWNoTW91c2VJZ25vcmVXYWl0KTtcbn1cbi8vIFdlIHdhbnQgdG8gYXR0YWNoIHRvdWNobW92ZSBhcyBlYXJseSBhcyBwb3NzaWJsZSBmb3IgU2FmYXJpXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBsaXN0ZW5lckNyZWF0ZWQoKSB7XG4gICAgbGlzdGVuZXJDbnQgKz0gMTtcbiAgICBpZiAobGlzdGVuZXJDbnQgPT09IDEpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uV2luZG93VG91Y2hNb3ZlLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxpc3RlbmVyRGVzdHJveWVkKCkge1xuICAgIGxpc3RlbmVyQ250IC09IDE7XG4gICAgaWYgKCFsaXN0ZW5lckNudCkge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25XaW5kb3dUb3VjaE1vdmUsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gb25XaW5kb3dUb3VjaE1vdmUoZXYpIHtcbiAgICBpZiAoaXNXaW5kb3dUb3VjaE1vdmVDYW5jZWxsZWQpIHtcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG59XG5cbi8qXG5BbiBlZmZlY3QgaW4gd2hpY2ggYW4gZWxlbWVudCBmb2xsb3dzIHRoZSBtb3ZlbWVudCBvZiBhIHBvaW50ZXIgYWNyb3NzIHRoZSBzY3JlZW4uXG5UaGUgbW92aW5nIGVsZW1lbnQgaXMgYSBjbG9uZSBvZiBzb21lIG90aGVyIGVsZW1lbnQuXG5NdXN0IGNhbGwgc3RhcnQgKyBoYW5kbGVNb3ZlICsgc3RvcC5cbiovXG5jbGFzcyBFbGVtZW50TWlycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5pc1Zpc2libGUgPSBmYWxzZTsgLy8gbXVzdCBiZSBleHBsaWNpdGx5IGVuYWJsZWRcbiAgICAgICAgdGhpcy5zb3VyY2VFbCA9IG51bGw7XG4gICAgICAgIHRoaXMubWlycm9yRWwgPSBudWxsO1xuICAgICAgICB0aGlzLnNvdXJjZUVsUmVjdCA9IG51bGw7IC8vIHNjcmVlbiBjb29yZHMgcmVsYXRpdmUgdG8gdmlld3BvcnRcbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IGNhbiBiZSBzZXQgZGlyZWN0bHkgYnkgY2FsbGVyXG4gICAgICAgIHRoaXMucGFyZW50Tm9kZSA9IGRvY3VtZW50LmJvZHk7IC8vIEhJR0hMWSBTVUdHRVNURUQgdG8gc2V0IHRoaXMgdG8gc2lkZXN0ZXAgU2hhZG93RE9NIGlzc3Vlc1xuICAgICAgICB0aGlzLnpJbmRleCA9IDk5OTk7XG4gICAgICAgIHRoaXMucmV2ZXJ0RHVyYXRpb24gPSAwO1xuICAgIH1cbiAgICBzdGFydChzb3VyY2VFbCwgcGFnZVgsIHBhZ2VZKSB7XG4gICAgICAgIHRoaXMuc291cmNlRWwgPSBzb3VyY2VFbDtcbiAgICAgICAgdGhpcy5zb3VyY2VFbFJlY3QgPSB0aGlzLnNvdXJjZUVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0aGlzLm9yaWdTY3JlZW5YID0gcGFnZVggLSB3aW5kb3cuc2Nyb2xsWDtcbiAgICAgICAgdGhpcy5vcmlnU2NyZWVuWSA9IHBhZ2VZIC0gd2luZG93LnNjcm9sbFk7XG4gICAgICAgIHRoaXMuZGVsdGFYID0gMDtcbiAgICAgICAgdGhpcy5kZWx0YVkgPSAwO1xuICAgICAgICB0aGlzLnVwZGF0ZUVsUG9zaXRpb24oKTtcbiAgICB9XG4gICAgaGFuZGxlTW92ZShwYWdlWCwgcGFnZVkpIHtcbiAgICAgICAgdGhpcy5kZWx0YVggPSAocGFnZVggLSB3aW5kb3cuc2Nyb2xsWCkgLSB0aGlzLm9yaWdTY3JlZW5YO1xuICAgICAgICB0aGlzLmRlbHRhWSA9IChwYWdlWSAtIHdpbmRvdy5zY3JvbGxZKSAtIHRoaXMub3JpZ1NjcmVlblk7XG4gICAgICAgIHRoaXMudXBkYXRlRWxQb3NpdGlvbigpO1xuICAgIH1cbiAgICAvLyBjYW4gYmUgY2FsbGVkIGJlZm9yZSBzdGFydFxuICAgIHNldElzVmlzaWJsZShib29sKSB7XG4gICAgICAgIGlmIChib29sKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWlycm9yRWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5taXJyb3JFbC5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuaXNWaXNpYmxlID0gYm9vbDsgLy8gbmVlZHMgdG8gaGFwcGVuIGJlZm9yZSB1cGRhdGVFbFBvc2l0aW9uXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVFbFBvc2l0aW9uKCk7IC8vIGJlY2F1c2Ugd2FzIG5vdCB1cGRhdGluZyB0aGUgcG9zaXRpb24gd2hpbGUgaW52aXNpYmxlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pc1Zpc2libGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1pcnJvckVsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5taXJyb3JFbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pc1Zpc2libGUgPSBib29sO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGFsd2F5cyBhc3luY1xuICAgIHN0b3AobmVlZHNSZXZlcnRBbmltYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgICAgIGxldCBkb25lID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAobmVlZHNSZXZlcnRBbmltYXRpb24gJiZcbiAgICAgICAgICAgIHRoaXMubWlycm9yRWwgJiZcbiAgICAgICAgICAgIHRoaXMuaXNWaXNpYmxlICYmXG4gICAgICAgICAgICB0aGlzLnJldmVydER1cmF0aW9uICYmIC8vIGlmIDAsIHRyYW5zaXRpb24gd29uJ3Qgd29ya1xuICAgICAgICAgICAgKHRoaXMuZGVsdGFYIHx8IHRoaXMuZGVsdGFZKSAvLyBpZiBzYW1lIGNvb3JkcywgdHJhbnNpdGlvbiB3b24ndCB3b3JrXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5kb1JldmVydEFuaW1hdGlvbihkb25lLCB0aGlzLnJldmVydER1cmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZG9uZSwgMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZG9SZXZlcnRBbmltYXRpb24oY2FsbGJhY2ssIHJldmVydER1cmF0aW9uKSB7XG4gICAgICAgIGxldCBtaXJyb3JFbCA9IHRoaXMubWlycm9yRWw7XG4gICAgICAgIGxldCBmaW5hbFNvdXJjZUVsUmVjdCA9IHRoaXMuc291cmNlRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IC8vIGJlY2F1c2UgYXV0b3Njcm9sbGluZyBtaWdodCBoYXZlIGhhcHBlbmVkXG4gICAgICAgIG1pcnJvckVsLnN0eWxlLnRyYW5zaXRpb24gPVxuICAgICAgICAgICAgJ3RvcCAnICsgcmV2ZXJ0RHVyYXRpb24gKyAnbXMsJyArXG4gICAgICAgICAgICAgICAgJ2xlZnQgJyArIHJldmVydER1cmF0aW9uICsgJ21zJztcbiAgICAgICAgYXBwbHlTdHlsZShtaXJyb3JFbCwge1xuICAgICAgICAgICAgbGVmdDogZmluYWxTb3VyY2VFbFJlY3QubGVmdCxcbiAgICAgICAgICAgIHRvcDogZmluYWxTb3VyY2VFbFJlY3QudG9wLFxuICAgICAgICB9KTtcbiAgICAgICAgd2hlblRyYW5zaXRpb25Eb25lKG1pcnJvckVsLCAoKSA9PiB7XG4gICAgICAgICAgICBtaXJyb3JFbC5zdHlsZS50cmFuc2l0aW9uID0gJyc7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2xlYW51cCgpIHtcbiAgICAgICAgaWYgKHRoaXMubWlycm9yRWwpIHtcbiAgICAgICAgICAgIHJlbW92ZUVsZW1lbnQodGhpcy5taXJyb3JFbCk7XG4gICAgICAgICAgICB0aGlzLm1pcnJvckVsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNvdXJjZUVsID0gbnVsbDtcbiAgICB9XG4gICAgdXBkYXRlRWxQb3NpdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuc291cmNlRWwgJiYgdGhpcy5pc1Zpc2libGUpIHtcbiAgICAgICAgICAgIGFwcGx5U3R5bGUodGhpcy5nZXRNaXJyb3JFbCgpLCB7XG4gICAgICAgICAgICAgICAgbGVmdDogdGhpcy5zb3VyY2VFbFJlY3QubGVmdCArIHRoaXMuZGVsdGFYLFxuICAgICAgICAgICAgICAgIHRvcDogdGhpcy5zb3VyY2VFbFJlY3QudG9wICsgdGhpcy5kZWx0YVksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRNaXJyb3JFbCgpIHtcbiAgICAgICAgbGV0IHNvdXJjZUVsUmVjdCA9IHRoaXMuc291cmNlRWxSZWN0O1xuICAgICAgICBsZXQgbWlycm9yRWwgPSB0aGlzLm1pcnJvckVsO1xuICAgICAgICBpZiAoIW1pcnJvckVsKSB7XG4gICAgICAgICAgICBtaXJyb3JFbCA9IHRoaXMubWlycm9yRWwgPSB0aGlzLnNvdXJjZUVsLmNsb25lTm9kZSh0cnVlKTsgLy8gY2xvbmVDaGlsZHJlbj10cnVlXG4gICAgICAgICAgICAvLyB3ZSBkb24ndCB3YW50IGxvbmcgdGFwcyBvciBhbnkgbW91c2UgaW50ZXJhY3Rpb24gY2F1c2luZyBzZWxlY3Rpb24vbWVudXMuXG4gICAgICAgICAgICAvLyB3b3VsZCB1c2UgcHJldmVudFNlbGVjdGlvbigpLCBidXQgdGhhdCBwcmV2ZW50cyBzZWxlY3RzdGFydCwgY2F1c2luZyBwcm9ibGVtcy5cbiAgICAgICAgICAgIG1pcnJvckVsLnN0eWxlLnVzZXJTZWxlY3QgPSAnbm9uZSc7XG4gICAgICAgICAgICBtaXJyb3JFbC5zdHlsZS53ZWJraXRVc2VyU2VsZWN0ID0gJ25vbmUnO1xuICAgICAgICAgICAgbWlycm9yRWwuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgICAgICAgIG1pcnJvckVsLmNsYXNzTGlzdC5hZGQoJ2ZjLWV2ZW50LWRyYWdnaW5nJyk7XG4gICAgICAgICAgICBhcHBseVN0eWxlKG1pcnJvckVsLCB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICAgICAgICAgICAgekluZGV4OiB0aGlzLnpJbmRleCxcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiAnJyxcbiAgICAgICAgICAgICAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICAgICAgICAgICAgICB3aWR0aDogc291cmNlRWxSZWN0LnJpZ2h0IC0gc291cmNlRWxSZWN0LmxlZnQsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBzb3VyY2VFbFJlY3QuYm90dG9tIC0gc291cmNlRWxSZWN0LnRvcCxcbiAgICAgICAgICAgICAgICByaWdodDogJ2F1dG8nLFxuICAgICAgICAgICAgICAgIGJvdHRvbTogJ2F1dG8nLFxuICAgICAgICAgICAgICAgIG1hcmdpbjogMCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnROb2RlLmFwcGVuZENoaWxkKG1pcnJvckVsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWlycm9yRWw7XG4gICAgfVxufVxuXG4vKlxuSXMgYSBjYWNoZSBmb3IgYSBnaXZlbiBlbGVtZW50J3Mgc2Nyb2xsIGluZm9ybWF0aW9uIChhbGwgdGhlIGluZm8gdGhhdCBTY3JvbGxDb250cm9sbGVyIHN0b3JlcylcbmluIGFkZGl0aW9uIHRoZSBcImNsaWVudCByZWN0YW5nbGVcIiBvZiB0aGUgZWxlbWVudC4uIHRoZSBhcmVhIHdpdGhpbiB0aGUgc2Nyb2xsYmFycy5cblxuVGhlIGNhY2hlIGNhbiBiZSBpbiBvbmUgb2YgdHdvIG1vZGVzOlxuLSBkb2VzTGlzdGVuaW5nOmZhbHNlIC0gaWdub3JlcyB3aGVuIHRoZSBjb250YWluZXIgaXMgc2Nyb2xsZWQgYnkgc29tZW9uZSBlbHNlXG4tIGRvZXNMaXN0ZW5pbmc6dHJ1ZSAtIHdhdGNoIGZvciBzY3JvbGxpbmcgYW5kIHVwZGF0ZSB0aGUgY2FjaGVcbiovXG5jbGFzcyBTY3JvbGxHZW9tQ2FjaGUgZXh0ZW5kcyBTY3JvbGxDb250cm9sbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihzY3JvbGxDb250cm9sbGVyLCBkb2VzTGlzdGVuaW5nKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaGFuZGxlU2Nyb2xsID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxUb3AgPSB0aGlzLnNjcm9sbENvbnRyb2xsZXIuZ2V0U2Nyb2xsVG9wKCk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbExlZnQgPSB0aGlzLnNjcm9sbENvbnRyb2xsZXIuZ2V0U2Nyb2xsTGVmdCgpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGxDaGFuZ2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zY3JvbGxDb250cm9sbGVyID0gc2Nyb2xsQ29udHJvbGxlcjtcbiAgICAgICAgdGhpcy5kb2VzTGlzdGVuaW5nID0gZG9lc0xpc3RlbmluZztcbiAgICAgICAgdGhpcy5zY3JvbGxUb3AgPSB0aGlzLm9yaWdTY3JvbGxUb3AgPSBzY3JvbGxDb250cm9sbGVyLmdldFNjcm9sbFRvcCgpO1xuICAgICAgICB0aGlzLnNjcm9sbExlZnQgPSB0aGlzLm9yaWdTY3JvbGxMZWZ0ID0gc2Nyb2xsQ29udHJvbGxlci5nZXRTY3JvbGxMZWZ0KCk7XG4gICAgICAgIHRoaXMuc2Nyb2xsV2lkdGggPSBzY3JvbGxDb250cm9sbGVyLmdldFNjcm9sbFdpZHRoKCk7XG4gICAgICAgIHRoaXMuc2Nyb2xsSGVpZ2h0ID0gc2Nyb2xsQ29udHJvbGxlci5nZXRTY3JvbGxIZWlnaHQoKTtcbiAgICAgICAgdGhpcy5jbGllbnRXaWR0aCA9IHNjcm9sbENvbnRyb2xsZXIuZ2V0Q2xpZW50V2lkdGgoKTtcbiAgICAgICAgdGhpcy5jbGllbnRIZWlnaHQgPSBzY3JvbGxDb250cm9sbGVyLmdldENsaWVudEhlaWdodCgpO1xuICAgICAgICB0aGlzLmNsaWVudFJlY3QgPSB0aGlzLmNvbXB1dGVDbGllbnRSZWN0KCk7IC8vIGRvIGxhc3QgaW4gY2FzZSBpdCBuZWVkcyBjYWNoZWQgdmFsdWVzXG4gICAgICAgIGlmICh0aGlzLmRvZXNMaXN0ZW5pbmcpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0RXZlbnRUYXJnZXQoKS5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLmhhbmRsZVNjcm9sbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZG9lc0xpc3RlbmluZykge1xuICAgICAgICAgICAgdGhpcy5nZXRFdmVudFRhcmdldCgpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuaGFuZGxlU2Nyb2xsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRTY3JvbGxUb3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbFRvcDtcbiAgICB9XG4gICAgZ2V0U2Nyb2xsTGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsTGVmdDtcbiAgICB9XG4gICAgc2V0U2Nyb2xsVG9wKHRvcCkge1xuICAgICAgICB0aGlzLnNjcm9sbENvbnRyb2xsZXIuc2V0U2Nyb2xsVG9wKHRvcCk7XG4gICAgICAgIGlmICghdGhpcy5kb2VzTGlzdGVuaW5nKSB7XG4gICAgICAgICAgICAvLyB3ZSBhcmUgbm90IHJlbHlpbmcgb24gdGhlIGVsZW1lbnQgdG8gbm9ybWFsaXplIG91dC1vZi1ib3VuZHMgc2Nyb2xsIHZhbHVlc1xuICAgICAgICAgICAgLy8gc28gd2UgbmVlZCB0byBzYW5pdGl6ZSBvdXJzZWx2ZXNcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9wID0gTWF0aC5tYXgoTWF0aC5taW4odG9wLCB0aGlzLmdldE1heFNjcm9sbFRvcCgpKSwgMCk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVNjcm9sbENoYW5nZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldFNjcm9sbExlZnQodG9wKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsQ29udHJvbGxlci5zZXRTY3JvbGxMZWZ0KHRvcCk7XG4gICAgICAgIGlmICghdGhpcy5kb2VzTGlzdGVuaW5nKSB7XG4gICAgICAgICAgICAvLyB3ZSBhcmUgbm90IHJlbHlpbmcgb24gdGhlIGVsZW1lbnQgdG8gbm9ybWFsaXplIG91dC1vZi1ib3VuZHMgc2Nyb2xsIHZhbHVlc1xuICAgICAgICAgICAgLy8gc28gd2UgbmVlZCB0byBzYW5pdGl6ZSBvdXJzZWx2ZXNcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsTGVmdCA9IE1hdGgubWF4KE1hdGgubWluKHRvcCwgdGhpcy5nZXRNYXhTY3JvbGxMZWZ0KCkpLCAwKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU2Nyb2xsQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0Q2xpZW50V2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudFdpZHRoO1xuICAgIH1cbiAgICBnZXRDbGllbnRIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudEhlaWdodDtcbiAgICB9XG4gICAgZ2V0U2Nyb2xsV2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbFdpZHRoO1xuICAgIH1cbiAgICBnZXRTY3JvbGxIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbEhlaWdodDtcbiAgICB9XG4gICAgaGFuZGxlU2Nyb2xsQ2hhbmdlKCkge1xuICAgIH1cbn1cblxuY2xhc3MgRWxlbWVudFNjcm9sbEdlb21DYWNoZSBleHRlbmRzIFNjcm9sbEdlb21DYWNoZSB7XG4gICAgY29uc3RydWN0b3IoZWwsIGRvZXNMaXN0ZW5pbmcpIHtcbiAgICAgICAgc3VwZXIobmV3IEVsZW1lbnRTY3JvbGxDb250cm9sbGVyKGVsKSwgZG9lc0xpc3RlbmluZyk7XG4gICAgfVxuICAgIGdldEV2ZW50VGFyZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxDb250cm9sbGVyLmVsO1xuICAgIH1cbiAgICBjb21wdXRlQ2xpZW50UmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIGNvbXB1dGVJbm5lclJlY3QodGhpcy5zY3JvbGxDb250cm9sbGVyLmVsKTtcbiAgICB9XG59XG5cbmNsYXNzIFdpbmRvd1Njcm9sbEdlb21DYWNoZSBleHRlbmRzIFNjcm9sbEdlb21DYWNoZSB7XG4gICAgY29uc3RydWN0b3IoZG9lc0xpc3RlbmluZykge1xuICAgICAgICBzdXBlcihuZXcgV2luZG93U2Nyb2xsQ29udHJvbGxlcigpLCBkb2VzTGlzdGVuaW5nKTtcbiAgICB9XG4gICAgZ2V0RXZlbnRUYXJnZXQoKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgfVxuICAgIGNvbXB1dGVDbGllbnRSZWN0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogdGhpcy5zY3JvbGxMZWZ0LFxuICAgICAgICAgICAgcmlnaHQ6IHRoaXMuc2Nyb2xsTGVmdCArIHRoaXMuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICB0b3A6IHRoaXMuc2Nyb2xsVG9wLFxuICAgICAgICAgICAgYm90dG9tOiB0aGlzLnNjcm9sbFRvcCArIHRoaXMuY2xpZW50SGVpZ2h0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyB0aGUgd2luZG93IGlzIHRoZSBvbmx5IHNjcm9sbCBvYmplY3QgdGhhdCBjaGFuZ2VzIGl0J3MgcmVjdGFuZ2xlIHJlbGF0aXZlXG4gICAgLy8gdG8gdGhlIGRvY3VtZW50J3MgdG9wbGVmdCBhcyBpdCBzY3JvbGxzXG4gICAgaGFuZGxlU2Nyb2xsQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLmNsaWVudFJlY3QgPSB0aGlzLmNvbXB1dGVDbGllbnRSZWN0KCk7XG4gICAgfVxufVxuXG4vLyBJZiBhdmFpbGFibGUgd2UgYXJlIHVzaW5nIG5hdGl2ZSBcInBlcmZvcm1hbmNlXCIgQVBJIGluc3RlYWQgb2YgXCJEYXRlXCJcbi8vIFJlYWQgbW9yZSBhYm91dCBpdCBvbiBNRE46XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUGVyZm9ybWFuY2VcbmNvbnN0IGdldFRpbWUgPSB0eXBlb2YgcGVyZm9ybWFuY2UgPT09ICdmdW5jdGlvbicgPyBwZXJmb3JtYW5jZS5ub3cgOiBEYXRlLm5vdztcbi8qXG5Gb3IgYSBwb2ludGVyIGludGVyYWN0aW9uLCBhdXRvbWF0aWNhbGx5IHNjcm9sbHMgY2VydGFpbiBzY3JvbGwgY29udGFpbmVycyB3aGVuIHRoZSBwb2ludGVyXG5hcHByb2FjaGVzIHRoZSBlZGdlLlxuXG5UaGUgY2FsbGVyIG11c3QgY2FsbCBzdGFydCArIGhhbmRsZU1vdmUgKyBzdG9wLlxuKi9cbmNsYXNzIEF1dG9TY3JvbGxlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCBjYW4gYmUgc2V0IGJ5IGNhbGxlclxuICAgICAgICB0aGlzLmlzRW5hYmxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc2Nyb2xsUXVlcnkgPSBbd2luZG93LCAnLmZjLXNjcm9sbGVyJ107XG4gICAgICAgIHRoaXMuZWRnZVRocmVzaG9sZCA9IDUwOyAvLyBwaXhlbHNcbiAgICAgICAgdGhpcy5tYXhWZWxvY2l0eSA9IDMwMDsgLy8gcGl4ZWxzIHBlciBzZWNvbmRcbiAgICAgICAgLy8gaW50ZXJuYWwgc3RhdGVcbiAgICAgICAgdGhpcy5wb2ludGVyU2NyZWVuWCA9IG51bGw7XG4gICAgICAgIHRoaXMucG9pbnRlclNjcmVlblkgPSBudWxsO1xuICAgICAgICB0aGlzLmlzQW5pbWF0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2Nyb2xsQ2FjaGVzID0gbnVsbDtcbiAgICAgICAgLy8gcHJvdGVjdCBhZ2FpbnN0IHRoZSBpbml0aWFsIHBvaW50ZXJkb3duIGJlaW5nIHRvbyBjbG9zZSB0byBhbiBlZGdlIGFuZCBzdGFydGluZyB0aGUgc2Nyb2xsXG4gICAgICAgIHRoaXMuZXZlck1vdmVkVXAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ldmVyTW92ZWREb3duID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXZlck1vdmVkTGVmdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmV2ZXJNb3ZlZFJpZ2h0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYW5pbWF0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQW5pbWF0aW5nKSB7IC8vIHdhc24ndCBjYW5jZWxsZWQgYmV0d2VlbiBhbmltYXRpb24gY2FsbHNcbiAgICAgICAgICAgICAgICBsZXQgZWRnZSA9IHRoaXMuY29tcHV0ZUJlc3RFZGdlKHRoaXMucG9pbnRlclNjcmVlblggKyB3aW5kb3cuc2Nyb2xsWCwgdGhpcy5wb2ludGVyU2NyZWVuWSArIHdpbmRvdy5zY3JvbGxZKTtcbiAgICAgICAgICAgICAgICBpZiAoZWRnZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbm93ID0gZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVNpZGUoZWRnZSwgKG5vdyAtIHRoaXMubXNTaW5jZVJlcXVlc3QpIC8gMTAwMCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbihub3cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0FuaW1hdGluZyA9IGZhbHNlOyAvLyB3aWxsIHN0b3AgYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGFydChwYWdlWCwgcGFnZVksIHNjcm9sbFN0YXJ0RWwpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbENhY2hlcyA9IHRoaXMuYnVpbGRDYWNoZXMoc2Nyb2xsU3RhcnRFbCk7XG4gICAgICAgICAgICB0aGlzLnBvaW50ZXJTY3JlZW5YID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucG9pbnRlclNjcmVlblkgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5ldmVyTW92ZWRVcCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5ldmVyTW92ZWREb3duID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmV2ZXJNb3ZlZExlZnQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZXZlck1vdmVkUmlnaHQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTW92ZShwYWdlWCwgcGFnZVkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZU1vdmUocGFnZVgsIHBhZ2VZKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRW5hYmxlZCkge1xuICAgICAgICAgICAgbGV0IHBvaW50ZXJTY3JlZW5YID0gcGFnZVggLSB3aW5kb3cuc2Nyb2xsWDtcbiAgICAgICAgICAgIGxldCBwb2ludGVyU2NyZWVuWSA9IHBhZ2VZIC0gd2luZG93LnNjcm9sbFk7XG4gICAgICAgICAgICBsZXQgeURlbHRhID0gdGhpcy5wb2ludGVyU2NyZWVuWSA9PT0gbnVsbCA/IDAgOiBwb2ludGVyU2NyZWVuWSAtIHRoaXMucG9pbnRlclNjcmVlblk7XG4gICAgICAgICAgICBsZXQgeERlbHRhID0gdGhpcy5wb2ludGVyU2NyZWVuWCA9PT0gbnVsbCA/IDAgOiBwb2ludGVyU2NyZWVuWCAtIHRoaXMucG9pbnRlclNjcmVlblg7XG4gICAgICAgICAgICBpZiAoeURlbHRhIDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlck1vdmVkVXAgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoeURlbHRhID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlck1vdmVkRG93biA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeERlbHRhIDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlck1vdmVkTGVmdCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh4RGVsdGEgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVyTW92ZWRSaWdodCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBvaW50ZXJTY3JlZW5YID0gcG9pbnRlclNjcmVlblg7XG4gICAgICAgICAgICB0aGlzLnBvaW50ZXJTY3JlZW5ZID0gcG9pbnRlclNjcmVlblk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNBbmltYXRpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzQW5pbWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RBbmltYXRpb24oZ2V0VGltZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAodGhpcy5pc0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNBbmltYXRpbmcgPSBmYWxzZTsgLy8gd2lsbCBzdG9wIGFuaW1hdGlvblxuICAgICAgICAgICAgZm9yIChsZXQgc2Nyb2xsQ2FjaGUgb2YgdGhpcy5zY3JvbGxDYWNoZXMpIHtcbiAgICAgICAgICAgICAgICBzY3JvbGxDYWNoZS5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNjcm9sbENhY2hlcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVxdWVzdEFuaW1hdGlvbihub3cpIHtcbiAgICAgICAgdGhpcy5tc1NpbmNlUmVxdWVzdCA9IG5vdztcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0ZSk7XG4gICAgfVxuICAgIGhhbmRsZVNpZGUoZWRnZSwgc2Vjb25kcykge1xuICAgICAgICBsZXQgeyBzY3JvbGxDYWNoZSB9ID0gZWRnZTtcbiAgICAgICAgbGV0IHsgZWRnZVRocmVzaG9sZCB9ID0gdGhpcztcbiAgICAgICAgbGV0IGludkRpc3RhbmNlID0gZWRnZVRocmVzaG9sZCAtIGVkZ2UuZGlzdGFuY2U7XG4gICAgICAgIGxldCB2ZWxvY2l0eSA9IC8vIHRoZSBjbG9zZXIgdG8gdGhlIGVkZ2UsIHRoZSBmYXN0ZXIgd2Ugc2Nyb2xsXG4gICAgICAgICAoKGludkRpc3RhbmNlICogaW52RGlzdGFuY2UpIC8gKGVkZ2VUaHJlc2hvbGQgKiBlZGdlVGhyZXNob2xkKSkgKiAvLyBxdWFkcmF0aWNcbiAgICAgICAgICAgIHRoaXMubWF4VmVsb2NpdHkgKiBzZWNvbmRzO1xuICAgICAgICBsZXQgc2lnbiA9IDE7XG4gICAgICAgIHN3aXRjaCAoZWRnZS5uYW1lKSB7XG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICBzaWduID0gLTE7XG4gICAgICAgICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgc2Nyb2xsQ2FjaGUuc2V0U2Nyb2xsTGVmdChzY3JvbGxDYWNoZS5nZXRTY3JvbGxMZWZ0KCkgKyB2ZWxvY2l0eSAqIHNpZ24pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgICAgICBzaWduID0gLTE7XG4gICAgICAgICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgIHNjcm9sbENhY2hlLnNldFNjcm9sbFRvcChzY3JvbGxDYWNoZS5nZXRTY3JvbGxUb3AoKSArIHZlbG9jaXR5ICogc2lnbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gbGVmdC90b3AgYXJlIHJlbGF0aXZlIHRvIGRvY3VtZW50IHRvcGxlZnRcbiAgICBjb21wdXRlQmVzdEVkZ2UobGVmdCwgdG9wKSB7XG4gICAgICAgIGxldCB7IGVkZ2VUaHJlc2hvbGQgfSA9IHRoaXM7XG4gICAgICAgIGxldCBiZXN0U2lkZSA9IG51bGw7XG4gICAgICAgIGxldCBzY3JvbGxDYWNoZXMgPSB0aGlzLnNjcm9sbENhY2hlcyB8fCBbXTtcbiAgICAgICAgZm9yIChsZXQgc2Nyb2xsQ2FjaGUgb2Ygc2Nyb2xsQ2FjaGVzKSB7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IHNjcm9sbENhY2hlLmNsaWVudFJlY3Q7XG4gICAgICAgICAgICBsZXQgbGVmdERpc3QgPSBsZWZ0IC0gcmVjdC5sZWZ0O1xuICAgICAgICAgICAgbGV0IHJpZ2h0RGlzdCA9IHJlY3QucmlnaHQgLSBsZWZ0O1xuICAgICAgICAgICAgbGV0IHRvcERpc3QgPSB0b3AgLSByZWN0LnRvcDtcbiAgICAgICAgICAgIGxldCBib3R0b21EaXN0ID0gcmVjdC5ib3R0b20gLSB0b3A7XG4gICAgICAgICAgICAvLyBjb21wbGV0ZWx5IHdpdGhpbiB0aGUgcmVjdD9cbiAgICAgICAgICAgIGlmIChsZWZ0RGlzdCA+PSAwICYmIHJpZ2h0RGlzdCA+PSAwICYmIHRvcERpc3QgPj0gMCAmJiBib3R0b21EaXN0ID49IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodG9wRGlzdCA8PSBlZGdlVGhyZXNob2xkICYmIHRoaXMuZXZlck1vdmVkVXAgJiYgc2Nyb2xsQ2FjaGUuY2FuU2Nyb2xsVXAoKSAmJlxuICAgICAgICAgICAgICAgICAgICAoIWJlc3RTaWRlIHx8IGJlc3RTaWRlLmRpc3RhbmNlID4gdG9wRGlzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVzdFNpZGUgPSB7IHNjcm9sbENhY2hlLCBuYW1lOiAndG9wJywgZGlzdGFuY2U6IHRvcERpc3QgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJvdHRvbURpc3QgPD0gZWRnZVRocmVzaG9sZCAmJiB0aGlzLmV2ZXJNb3ZlZERvd24gJiYgc2Nyb2xsQ2FjaGUuY2FuU2Nyb2xsRG93bigpICYmXG4gICAgICAgICAgICAgICAgICAgICghYmVzdFNpZGUgfHwgYmVzdFNpZGUuZGlzdGFuY2UgPiBib3R0b21EaXN0KSkge1xuICAgICAgICAgICAgICAgICAgICBiZXN0U2lkZSA9IHsgc2Nyb2xsQ2FjaGUsIG5hbWU6ICdib3R0b20nLCBkaXN0YW5jZTogYm90dG9tRGlzdCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgIFRPRE86IGZpeCBicm9rZW4gUlRMIHNjcm9sbGluZy4gY2FuU2Nyb2xsTGVmdCBhbHdheXMgcmV0dXJuaW5nIGZhbHNlXG4gICAgICAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2Z1bGxjYWxlbmRhci9mdWxsY2FsZW5kYXIvaXNzdWVzLzQ4MzdcbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmIChsZWZ0RGlzdCA8PSBlZGdlVGhyZXNob2xkICYmIHRoaXMuZXZlck1vdmVkTGVmdCAmJiBzY3JvbGxDYWNoZS5jYW5TY3JvbGxMZWZ0KCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFiZXN0U2lkZSB8fCBiZXN0U2lkZS5kaXN0YW5jZSA+IGxlZnREaXN0KSkge1xuICAgICAgICAgICAgICAgICAgICBiZXN0U2lkZSA9IHsgc2Nyb2xsQ2FjaGUsIG5hbWU6ICdsZWZ0JywgZGlzdGFuY2U6IGxlZnREaXN0IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyaWdodERpc3QgPD0gZWRnZVRocmVzaG9sZCAmJiB0aGlzLmV2ZXJNb3ZlZFJpZ2h0ICYmIHNjcm9sbENhY2hlLmNhblNjcm9sbFJpZ2h0KCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFiZXN0U2lkZSB8fCBiZXN0U2lkZS5kaXN0YW5jZSA+IHJpZ2h0RGlzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVzdFNpZGUgPSB7IHNjcm9sbENhY2hlLCBuYW1lOiAncmlnaHQnLCBkaXN0YW5jZTogcmlnaHREaXN0IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiZXN0U2lkZTtcbiAgICB9XG4gICAgYnVpbGRDYWNoZXMoc2Nyb2xsU3RhcnRFbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWVyeVNjcm9sbEVscyhzY3JvbGxTdGFydEVsKS5tYXAoKGVsKSA9PiB7XG4gICAgICAgICAgICBpZiAoZWwgPT09IHdpbmRvdykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgV2luZG93U2Nyb2xsR2VvbUNhY2hlKGZhbHNlKTsgLy8gZmFsc2UgPSBkb24ndCBsaXN0ZW4gdG8gdXNlci1nZW5lcmF0ZWQgc2Nyb2xsc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50U2Nyb2xsR2VvbUNhY2hlKGVsLCBmYWxzZSk7IC8vIGZhbHNlID0gZG9uJ3QgbGlzdGVuIHRvIHVzZXItZ2VuZXJhdGVkIHNjcm9sbHNcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHF1ZXJ5U2Nyb2xsRWxzKHNjcm9sbFN0YXJ0RWwpIHtcbiAgICAgICAgbGV0IGVscyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBxdWVyeSBvZiB0aGlzLnNjcm9sbFF1ZXJ5KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGVscy5wdXNoKHF1ZXJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgVE9ETzogaW4gdGhlIGZ1dHVyZSwgYWx3YXlzIGhhdmUgYXV0by1zY3JvbGwgaGFwcGVuIG9uIGVsZW1lbnQgd2hlcmUgY3VycmVudCBIaXQgY2FtZSBmcm9tXG4gICAgICAgICAgICAgICAgVGlja2V0OiBodHRwczovL2dpdGh1Yi5jb20vZnVsbGNhbGVuZGFyL2Z1bGxjYWxlbmRhci9pc3N1ZXMvNDU5M1xuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZWxzLnB1c2goLi4uQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoc2Nyb2xsU3RhcnRFbC5nZXRSb290Tm9kZSgpLnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVscztcbiAgICB9XG59XG5cbi8qXG5Nb25pdG9ycyBkcmFnZ2luZyBvbiBhbiBlbGVtZW50LiBIYXMgYSBudW1iZXIgb2YgaGlnaC1sZXZlbCBmZWF0dXJlczpcbi0gbWluaW11bSBkaXN0YW5jZSByZXF1aXJlZCBiZWZvcmUgZHJhZ2dpbmdcbi0gbWluaW11bSB3YWl0IHRpbWUgKFwiZGVsYXlcIikgYmVmb3JlIGRyYWdnaW5nXG4tIGEgbWlycm9yIGVsZW1lbnQgdGhhdCBmb2xsb3dzIHRoZSBwb2ludGVyXG4qL1xuY2xhc3MgRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZyBleHRlbmRzIEVsZW1lbnREcmFnZ2luZyB7XG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyRWwsIHNlbGVjdG9yKSB7XG4gICAgICAgIHN1cGVyKGNvbnRhaW5lckVsKTtcbiAgICAgICAgdGhpcy5jb250YWluZXJFbCA9IGNvbnRhaW5lckVsO1xuICAgICAgICAvLyBvcHRpb25zIHRoYXQgY2FuIGJlIGRpcmVjdGx5IHNldCBieSBjYWxsZXJcbiAgICAgICAgLy8gdGhlIGNhbGxlciBjYW4gYWxzbyBzZXQgdGhlIFBvaW50ZXJEcmFnZ2luZydzIG9wdGlvbnMgYXMgd2VsbFxuICAgICAgICB0aGlzLmRlbGF5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5taW5EaXN0YW5jZSA9IDA7XG4gICAgICAgIHRoaXMudG91Y2hTY3JvbGxBbGxvd2VkID0gdHJ1ZTsgLy8gcHJldmVudHMgZHJhZyBmcm9tIHN0YXJ0aW5nIGFuZCBibG9ja3Mgc2Nyb2xsaW5nIGR1cmluZyBkcmFnXG4gICAgICAgIHRoaXMubWlycm9yTmVlZHNSZXZlcnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0ludGVyYWN0aW5nID0gZmFsc2U7IC8vIGlzIHRoZSB1c2VyIHZhbGlkbHkgbW92aW5nIHRoZSBwb2ludGVyPyBsYXN0cyB1bnRpbCBwb2ludGVydXBcbiAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7IC8vIGlzIGl0IElOVEVOVEZVTExZIGRyYWdnaW5nPyBsYXN0cyB1bnRpbCBhZnRlciByZXZlcnQgYW5pbWF0aW9uXG4gICAgICAgIHRoaXMuaXNEZWxheUVuZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNEaXN0YW5jZVN1cnBhc3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlbGF5VGltZW91dElkID0gbnVsbDtcbiAgICAgICAgdGhpcy5vblBvaW50ZXJEb3duID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNEcmFnZ2luZykgeyAvLyBzbyBuZXcgZHJhZyBkb2Vzbid0IGhhcHBlbiB3aGlsZSByZXZlcnQgYW5pbWF0aW9uIGlzIGdvaW5nXG4gICAgICAgICAgICAgICAgdGhpcy5pc0ludGVyYWN0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmlzRGVsYXlFbmRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNEaXN0YW5jZVN1cnBhc3NlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHByZXZlbnRTZWxlY3Rpb24oZG9jdW1lbnQuYm9keSk7XG4gICAgICAgICAgICAgICAgcHJldmVudENvbnRleHRNZW51KGRvY3VtZW50LmJvZHkpO1xuICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgbGlua3MgZnJvbSBiZWluZyB2aXNpdGVkIGlmIHRoZXJlJ3MgYW4gZXZlbnR1YWwgZHJhZy5cbiAgICAgICAgICAgICAgICAvLyBhbHNvIHByZXZlbnRzIHNlbGVjdGlvbiBpbiBvbGRlciBicm93c2VycyAobWF5YmU/KS5cbiAgICAgICAgICAgICAgICAvLyBub3QgbmVjZXNzYXJ5IGZvciB0b3VjaCwgYmVzaWRlcywgYnJvd3NlciB3b3VsZCBjb21wbGFpbiBhYm91dCBwYXNzaXZlbmVzcy5cbiAgICAgICAgICAgICAgICBpZiAoIWV2LmlzVG91Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgZXYub3JpZ0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVyZG93bicsIGV2KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0ludGVyYWN0aW5nICYmIC8vIG5vdCBkZXN0cm95ZWQgdmlhIHBvaW50ZXJkb3duIGhhbmRsZXJcbiAgICAgICAgICAgICAgICAgICAgIXRoaXMucG9pbnRlci5zaG91bGRJZ25vcmVNb3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFjdGlvbnMgcmVsYXRlZCB0byBpbml0aWF0aW5nIGRyYWdzdGFydCtkcmFnbW92ZStkcmFnZW5kLi4uXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWlycm9yLnNldElzVmlzaWJsZShmYWxzZSk7IC8vIHJlc2V0LiBjYWxsZXIgbXVzdCBzZXQtdmlzaWJsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1pcnJvci5zdGFydChldi5zdWJqZWN0RWwsIGV2LnBhZ2VYLCBldi5wYWdlWSk7IC8vIG11c3QgaGFwcGVuIG9uIGZpcnN0IHBvaW50ZXIgZG93blxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0RGVsYXkoZXYpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWluRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzdGFuY2VTdXJwYXNzZWQoZXYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uUG9pbnRlck1vdmUgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSW50ZXJhY3RpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcm1vdmUnLCBldik7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzRGlzdGFuY2VTdXJwYXNzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1pbkRpc3RhbmNlID0gdGhpcy5taW5EaXN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRpc3RhbmNlU3E7IC8vIGN1cnJlbnQgZGlzdGFuY2UgZnJvbSB0aGUgb3JpZ2luLCBzcXVhcmVkXG4gICAgICAgICAgICAgICAgICAgIGxldCB7IGRlbHRhWCwgZGVsdGFZIH0gPSBldjtcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2VTcSA9IGRlbHRhWCAqIGRlbHRhWCArIGRlbHRhWSAqIGRlbHRhWTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlU3EgPj0gbWluRGlzdGFuY2UgKiBtaW5EaXN0YW5jZSkgeyAvLyB1c2UgcHl0aGFnb3JlYW4gdGhlb3JlbVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXN0YW5jZVN1cnBhc3NlZChldik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZykge1xuICAgICAgICAgICAgICAgICAgICAvLyBhIHJlYWwgcG9pbnRlciBtb3ZlPyAobm90IG9uZSBzaW11bGF0ZWQgYnkgc2Nyb2xsaW5nKVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXYub3JpZ0V2ZW50LnR5cGUgIT09ICdzY3JvbGwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1pcnJvci5oYW5kbGVNb3ZlKGV2LnBhZ2VYLCBldi5wYWdlWSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF1dG9TY3JvbGxlci5oYW5kbGVNb3ZlKGV2LnBhZ2VYLCBldi5wYWdlWSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2RyYWdtb3ZlJywgZXYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vblBvaW50ZXJVcCA9IChldikgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNJbnRlcmFjdGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNJbnRlcmFjdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGFsbG93U2VsZWN0aW9uKGRvY3VtZW50LmJvZHkpO1xuICAgICAgICAgICAgICAgIGFsbG93Q29udGV4dE1lbnUoZG9jdW1lbnQuYm9keSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJ1cCcsIGV2KTsgLy8gY2FuIHBvdGVudGlhbGx5IHNldCBtaXJyb3JOZWVkc1JldmVydFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdXRvU2Nyb2xsZXIuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyeVN0b3BEcmFnKGV2KTsgLy8gd2hpY2ggd2lsbCBzdG9wIHRoZSBtaXJyb3JcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVsYXlUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZGVsYXlUaW1lb3V0SWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGF5VGltZW91dElkID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGxldCBwb2ludGVyID0gdGhpcy5wb2ludGVyID0gbmV3IFBvaW50ZXJEcmFnZ2luZyhjb250YWluZXJFbCk7XG4gICAgICAgIHBvaW50ZXIuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCB0aGlzLm9uUG9pbnRlckRvd24pO1xuICAgICAgICBwb2ludGVyLmVtaXR0ZXIub24oJ3BvaW50ZXJtb3ZlJywgdGhpcy5vblBvaW50ZXJNb3ZlKTtcbiAgICAgICAgcG9pbnRlci5lbWl0dGVyLm9uKCdwb2ludGVydXAnLCB0aGlzLm9uUG9pbnRlclVwKTtcbiAgICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICBwb2ludGVyLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5taXJyb3IgPSBuZXcgRWxlbWVudE1pcnJvcigpO1xuICAgICAgICB0aGlzLmF1dG9TY3JvbGxlciA9IG5ldyBBdXRvU2Nyb2xsZXIoKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5wb2ludGVyLmRlc3Ryb3koKTtcbiAgICAgICAgLy8gSEFDSzogc2ltdWxhdGUgYSBwb2ludGVyLXVwIHRvIGVuZCB0aGUgY3VycmVudCBkcmFnXG4gICAgICAgIC8vIFRPRE86IGZpcmUgJ2RyYWdlbmQnIGRpcmVjdGx5IGFuZCBzdG9wIGludGVyYWN0aW9uLiBkaXNjb3VyYWdlIHVzZSBvZiBwb2ludGVydXAgZXZlbnQgKGIvYyBtaWdodCBub3QgZmlyZSlcbiAgICAgICAgdGhpcy5vblBvaW50ZXJVcCh7fSk7XG4gICAgfVxuICAgIHN0YXJ0RGVsYXkoZXYpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmRlbGF5ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5kZWxheVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVsYXlUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRGVsYXlFbmQoZXYpO1xuICAgICAgICAgICAgfSwgdGhpcy5kZWxheSk7IC8vIG5vdCBhc3NpZ25hYmxlIHRvIG51bWJlciFcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRGVsYXlFbmQoZXYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZURlbGF5RW5kKGV2KSB7XG4gICAgICAgIHRoaXMuaXNEZWxheUVuZGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50cnlTdGFydERyYWcoZXYpO1xuICAgIH1cbiAgICBoYW5kbGVEaXN0YW5jZVN1cnBhc3NlZChldikge1xuICAgICAgICB0aGlzLmlzRGlzdGFuY2VTdXJwYXNzZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnRyeVN0YXJ0RHJhZyhldik7XG4gICAgfVxuICAgIHRyeVN0YXJ0RHJhZyhldikge1xuICAgICAgICBpZiAodGhpcy5pc0RlbGF5RW5kZWQgJiYgdGhpcy5pc0Rpc3RhbmNlU3VycGFzc2VkKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucG9pbnRlci53YXNUb3VjaFNjcm9sbCB8fCB0aGlzLnRvdWNoU2Nyb2xsQWxsb3dlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5taXJyb3JOZWVkc1JldmVydCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuYXV0b1Njcm9sbGVyLnN0YXJ0KGV2LnBhZ2VYLCBldi5wYWdlWSwgdGhpcy5jb250YWluZXJFbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2RyYWdzdGFydCcsIGV2KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50b3VjaFNjcm9sbEFsbG93ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9pbnRlci5jYW5jZWxUb3VjaFNjcm9sbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0cnlTdG9wRHJhZyhldikge1xuICAgICAgICAvLyAuc3RvcCgpIGlzIEFMV0FZUyBhc3luY2hyb25vdXMsIHdoaWNoIHdlIE5FRUQgYmVjYXVzZSB3ZSB3YW50IGFsbCBwb2ludGVydXAgZXZlbnRzXG4gICAgICAgIC8vIHRoYXQgY29tZSBmcm9tIHRoZSBkb2N1bWVudCB0byBmaXJlIGJlZm9yZWhhbmQuIG11Y2ggbW9yZSBjb252ZW5pZW50IHRoaXMgd2F5LlxuICAgICAgICB0aGlzLm1pcnJvci5zdG9wKHRoaXMubWlycm9yTmVlZHNSZXZlcnQsIHRoaXMuc3RvcERyYWcuYmluZCh0aGlzLCBldikpO1xuICAgIH1cbiAgICBzdG9wRHJhZyhldikge1xuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2RyYWdlbmQnLCBldik7XG4gICAgfVxuICAgIC8vIGZpbGwgaW4gdGhlIGltcGxlbWVudGF0aW9ucy4uLlxuICAgIHNldElnbm9yZU1vdmUoYm9vbCkge1xuICAgICAgICB0aGlzLnBvaW50ZXIuc2hvdWxkSWdub3JlTW92ZSA9IGJvb2w7XG4gICAgfVxuICAgIHNldE1pcnJvcklzVmlzaWJsZShib29sKSB7XG4gICAgICAgIHRoaXMubWlycm9yLnNldElzVmlzaWJsZShib29sKTtcbiAgICB9XG4gICAgc2V0TWlycm9yTmVlZHNSZXZlcnQoYm9vbCkge1xuICAgICAgICB0aGlzLm1pcnJvck5lZWRzUmV2ZXJ0ID0gYm9vbDtcbiAgICB9XG4gICAgc2V0QXV0b1Njcm9sbEVuYWJsZWQoYm9vbCkge1xuICAgICAgICB0aGlzLmF1dG9TY3JvbGxlci5pc0VuYWJsZWQgPSBib29sO1xuICAgIH1cbn1cblxuLypcbldoZW4gdGhpcyBjbGFzcyBpcyBpbnN0YW50aWF0ZWQsIGl0IHJlY29yZHMgdGhlIG9mZnNldCBvZiBhbiBlbGVtZW50IChyZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnQgdG9wbGVmdCksXG5hbmQgY29udGludWVzIHRvIG1vbml0b3Igc2Nyb2xsaW5nLCB1cGRhdGluZyB0aGUgY2FjaGVkIGNvb3JkaW5hdGVzIGlmIGl0IG5lZWRzIHRvLlxuRG9lcyBub3QgYWNjZXNzIHRoZSBET00gYWZ0ZXIgaW5zdGFudGlhdGlvbiwgc28gaGlnaGx5IHBlcmZvcm1hbnQuXG5cbkFsc28ga2VlcHMgdHJhY2sgb2YgYWxsIHNjcm9sbGluZy9vdmVyZmxvdzpoaWRkZW4gY29udGFpbmVycyB0aGF0IGFyZSBwYXJlbnRzIG9mIHRoZSBnaXZlbiBlbGVtZW50XG5hbmQgYW4gZGV0ZXJtaW5lIGlmIGEgZ2l2ZW4gcG9pbnQgaXMgaW5zaWRlIHRoZSBjb21iaW5lZCBjbGlwcGluZyByZWN0YW5nbGUuXG4qL1xuY2xhc3MgT2Zmc2V0VHJhY2tlciB7XG4gICAgY29uc3RydWN0b3IoZWwpIHtcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICB0aGlzLm9yaWdSZWN0ID0gY29tcHV0ZVJlY3QoZWwpO1xuICAgICAgICAvLyB3aWxsIHdvcmsgZmluZSBmb3IgZGl2cyB0aGF0IGhhdmUgb3ZlcmZsb3c6aGlkZGVuXG4gICAgICAgIHRoaXMuc2Nyb2xsQ2FjaGVzID0gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsKS5tYXAoKHNjcm9sbEVsKSA9PiBuZXcgRWxlbWVudFNjcm9sbEdlb21DYWNoZShzY3JvbGxFbCwgdHJ1ZSkpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBmb3IgKGxldCBzY3JvbGxDYWNoZSBvZiB0aGlzLnNjcm9sbENhY2hlcykge1xuICAgICAgICAgICAgc2Nyb2xsQ2FjaGUuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXB1dGVMZWZ0KCkge1xuICAgICAgICBsZXQgbGVmdCA9IHRoaXMub3JpZ1JlY3QubGVmdDtcbiAgICAgICAgZm9yIChsZXQgc2Nyb2xsQ2FjaGUgb2YgdGhpcy5zY3JvbGxDYWNoZXMpIHtcbiAgICAgICAgICAgIGxlZnQgKz0gc2Nyb2xsQ2FjaGUub3JpZ1Njcm9sbExlZnQgLSBzY3JvbGxDYWNoZS5nZXRTY3JvbGxMZWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgfVxuICAgIGNvbXB1dGVUb3AoKSB7XG4gICAgICAgIGxldCB0b3AgPSB0aGlzLm9yaWdSZWN0LnRvcDtcbiAgICAgICAgZm9yIChsZXQgc2Nyb2xsQ2FjaGUgb2YgdGhpcy5zY3JvbGxDYWNoZXMpIHtcbiAgICAgICAgICAgIHRvcCArPSBzY3JvbGxDYWNoZS5vcmlnU2Nyb2xsVG9wIC0gc2Nyb2xsQ2FjaGUuZ2V0U2Nyb2xsVG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvcDtcbiAgICB9XG4gICAgaXNXaXRoaW5DbGlwcGluZyhwYWdlWCwgcGFnZVkpIHtcbiAgICAgICAgbGV0IHBvaW50ID0geyBsZWZ0OiBwYWdlWCwgdG9wOiBwYWdlWSB9O1xuICAgICAgICBmb3IgKGxldCBzY3JvbGxDYWNoZSBvZiB0aGlzLnNjcm9sbENhY2hlcykge1xuICAgICAgICAgICAgaWYgKCFpc0lnbm9yZWRDbGlwcGluZyhzY3JvbGxDYWNoZS5nZXRFdmVudFRhcmdldCgpKSAmJlxuICAgICAgICAgICAgICAgICFwb2ludEluc2lkZVJlY3QocG9pbnQsIHNjcm9sbENhY2hlLmNsaWVudFJlY3QpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbi8vIGNlcnRhaW4gY2xpcHBpbmcgY29udGFpbmVycyBzaG91bGQgbmV2ZXIgY29uc3RyYWluIGludGVyYWN0aW9ucywgbGlrZSA8aHRtbD4gYW5kIDxib2R5PlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Z1bGxjYWxlbmRhci9mdWxsY2FsZW5kYXIvaXNzdWVzLzM2MTVcbmZ1bmN0aW9uIGlzSWdub3JlZENsaXBwaW5nKG5vZGUpIHtcbiAgICBsZXQgdGFnTmFtZSA9IG5vZGUudGFnTmFtZTtcbiAgICByZXR1cm4gdGFnTmFtZSA9PT0gJ0hUTUwnIHx8IHRhZ05hbWUgPT09ICdCT0RZJztcbn1cblxuLypcblRyYWNrcyBtb3ZlbWVudCBvdmVyIG11bHRpcGxlIGRyb3BwYWJsZSBhcmVhcyAoYWthIFwiaGl0c1wiKVxudGhhdCBleGlzdCBpbiBvbmUgb3IgbW9yZSBEYXRlQ29tcG9uZW50cy5cblJlbGllcyBvbiBhbiBleGlzdGluZyBkcmFnZ2FibGUuXG5cbmVtaXRzOlxuLSBwb2ludGVyZG93blxuLSBkcmFnc3RhcnRcbi0gaGl0Y2hhbmdlIC0gZmlyZXMgaW5pdGlhbGx5LCBldmVuIGlmIG5vdCBvdmVyIGEgaGl0XG4tIHBvaW50ZXJ1cFxuLSAoaGl0Y2hhbmdlIC0gYWdhaW4sIHRvIG51bGwsIGlmIGVuZGVkIG92ZXIgYSBoaXQpXG4tIGRyYWdlbmRcbiovXG5jbGFzcyBIaXREcmFnZ2luZyB7XG4gICAgY29uc3RydWN0b3IoZHJhZ2dpbmcsIGRyb3BwYWJsZVN0b3JlKSB7XG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCBjYW4gYmUgc2V0IGJ5IGNhbGxlclxuICAgICAgICB0aGlzLnVzZVN1YmplY3RDZW50ZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZXF1aXJlSW5pdGlhbCA9IHRydWU7IC8vIGlmIGRvZXNuJ3Qgc3RhcnQgb3V0IG9uIGEgaGl0LCB3b24ndCBlbWl0IGFueSBldmVudHNcbiAgICAgICAgdGhpcy5kaXNhYmxlUG9pbnRDaGVjayA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluaXRpYWxIaXQgPSBudWxsO1xuICAgICAgICB0aGlzLm1vdmluZ0hpdCA9IG51bGw7XG4gICAgICAgIHRoaXMuZmluYWxIaXQgPSBudWxsOyAvLyB3b24ndCBldmVyIGJlIHBvcHVsYXRlZCBpZiBzaG91bGRJZ25vcmVNb3ZlXG4gICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlckRvd24gPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGxldCB7IGRyYWdnaW5nIH0gPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsSGl0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubW92aW5nSGl0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZmluYWxIaXQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5wcmVwYXJlSGl0cygpO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzRmlyc3RDb29yZChldik7XG4gICAgICAgICAgICBpZiAodGhpcy5pbml0aWFsSGl0IHx8ICF0aGlzLnJlcXVpcmVJbml0aWFsKSB7XG4gICAgICAgICAgICAgICAgZHJhZ2dpbmcuc2V0SWdub3JlTW92ZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogZmlyZSB0aGlzIGJlZm9yZSBjb21wdXRpbmcgcHJvY2Vzc0ZpcnN0Q29vcmQsIHNvIGxpc3RlbmVycyBjYW4gY2FuY2VsLiB0aGlzIGdldHMgZmlyZWQgYnkgYWxtb3N0IGV2ZXJ5IGhhbmRsZXIgOihcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcmRvd24nLCBldik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkcmFnZ2luZy5zZXRJZ25vcmVNb3ZlKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZURyYWdTdGFydCA9IChldikgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2RyYWdzdGFydCcsIGV2KTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTW92ZShldiwgdHJ1ZSk7IC8vIGZvcmNlID0gZmlyZSBldmVuIGlmIGluaXRpYWxseSBudWxsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlRHJhZ01vdmUgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdkcmFnbW92ZScsIGV2KTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTW92ZShldik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlclVwID0gKGV2KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlbGVhc2VIaXRzKCk7XG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcnVwJywgZXYpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZURyYWdFbmQgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1vdmluZ0hpdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdoaXR1cGRhdGUnLCBudWxsLCB0cnVlLCBldik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZpbmFsSGl0ID0gdGhpcy5tb3ZpbmdIaXQ7XG4gICAgICAgICAgICB0aGlzLm1vdmluZ0hpdCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcignZHJhZ2VuZCcsIGV2KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kcm9wcGFibGVTdG9yZSA9IGRyb3BwYWJsZVN0b3JlO1xuICAgICAgICBkcmFnZ2luZy5lbWl0dGVyLm9uKCdwb2ludGVyZG93bicsIHRoaXMuaGFuZGxlUG9pbnRlckRvd24pO1xuICAgICAgICBkcmFnZ2luZy5lbWl0dGVyLm9uKCdkcmFnc3RhcnQnLCB0aGlzLmhhbmRsZURyYWdTdGFydCk7XG4gICAgICAgIGRyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdtb3ZlJywgdGhpcy5oYW5kbGVEcmFnTW92ZSk7XG4gICAgICAgIGRyYWdnaW5nLmVtaXR0ZXIub24oJ3BvaW50ZXJ1cCcsIHRoaXMuaGFuZGxlUG9pbnRlclVwKTtcbiAgICAgICAgZHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ2VuZCcsIHRoaXMuaGFuZGxlRHJhZ0VuZCk7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBkcmFnZ2luZztcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgLy8gc2V0cyBpbml0aWFsSGl0XG4gICAgLy8gc2V0cyBjb29yZEFkanVzdFxuICAgIHByb2Nlc3NGaXJzdENvb3JkKGV2KSB7XG4gICAgICAgIGxldCBvcmlnUG9pbnQgPSB7IGxlZnQ6IGV2LnBhZ2VYLCB0b3A6IGV2LnBhZ2VZIH07XG4gICAgICAgIGxldCBhZGp1c3RlZFBvaW50ID0gb3JpZ1BvaW50O1xuICAgICAgICBsZXQgc3ViamVjdEVsID0gZXYuc3ViamVjdEVsO1xuICAgICAgICBsZXQgc3ViamVjdFJlY3Q7XG4gICAgICAgIGlmIChzdWJqZWN0RWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkgeyAvLyBpLmUuIG5vdCBhIERvY3VtZW50L1NoYWRvd1Jvb3RcbiAgICAgICAgICAgIHN1YmplY3RSZWN0ID0gY29tcHV0ZVJlY3Qoc3ViamVjdEVsKTtcbiAgICAgICAgICAgIGFkanVzdGVkUG9pbnQgPSBjb25zdHJhaW5Qb2ludChhZGp1c3RlZFBvaW50LCBzdWJqZWN0UmVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGluaXRpYWxIaXQgPSB0aGlzLmluaXRpYWxIaXQgPSB0aGlzLnF1ZXJ5SGl0Rm9yT2Zmc2V0KGFkanVzdGVkUG9pbnQubGVmdCwgYWRqdXN0ZWRQb2ludC50b3ApO1xuICAgICAgICBpZiAoaW5pdGlhbEhpdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudXNlU3ViamVjdENlbnRlciAmJiBzdWJqZWN0UmVjdCkge1xuICAgICAgICAgICAgICAgIGxldCBzbGljZWRTdWJqZWN0UmVjdCA9IGludGVyc2VjdFJlY3RzKHN1YmplY3RSZWN0LCBpbml0aWFsSGl0LnJlY3QpO1xuICAgICAgICAgICAgICAgIGlmIChzbGljZWRTdWJqZWN0UmVjdCkge1xuICAgICAgICAgICAgICAgICAgICBhZGp1c3RlZFBvaW50ID0gZ2V0UmVjdENlbnRlcihzbGljZWRTdWJqZWN0UmVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb29yZEFkanVzdCA9IGRpZmZQb2ludHMoYWRqdXN0ZWRQb2ludCwgb3JpZ1BvaW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29vcmRBZGp1c3QgPSB7IGxlZnQ6IDAsIHRvcDogMCB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZU1vdmUoZXYsIGZvcmNlSGFuZGxlKSB7XG4gICAgICAgIGxldCBoaXQgPSB0aGlzLnF1ZXJ5SGl0Rm9yT2Zmc2V0KGV2LnBhZ2VYICsgdGhpcy5jb29yZEFkanVzdC5sZWZ0LCBldi5wYWdlWSArIHRoaXMuY29vcmRBZGp1c3QudG9wKTtcbiAgICAgICAgaWYgKGZvcmNlSGFuZGxlIHx8ICFpc0hpdHNFcXVhbCh0aGlzLm1vdmluZ0hpdCwgaGl0KSkge1xuICAgICAgICAgICAgdGhpcy5tb3ZpbmdIaXQgPSBoaXQ7XG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcignaGl0dXBkYXRlJywgaGl0LCBmYWxzZSwgZXYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByZXBhcmVIaXRzKCkge1xuICAgICAgICB0aGlzLm9mZnNldFRyYWNrZXJzID0gbWFwSGFzaCh0aGlzLmRyb3BwYWJsZVN0b3JlLCAoaW50ZXJhY3Rpb25TZXR0aW5ncykgPT4ge1xuICAgICAgICAgICAgaW50ZXJhY3Rpb25TZXR0aW5ncy5jb21wb25lbnQucHJlcGFyZUhpdHMoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgT2Zmc2V0VHJhY2tlcihpbnRlcmFjdGlvblNldHRpbmdzLmVsKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbGVhc2VIaXRzKCkge1xuICAgICAgICBsZXQgeyBvZmZzZXRUcmFja2VycyB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgaWQgaW4gb2Zmc2V0VHJhY2tlcnMpIHtcbiAgICAgICAgICAgIG9mZnNldFRyYWNrZXJzW2lkXS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vZmZzZXRUcmFja2VycyA9IHt9O1xuICAgIH1cbiAgICBxdWVyeUhpdEZvck9mZnNldChvZmZzZXRMZWZ0LCBvZmZzZXRUb3ApIHtcbiAgICAgICAgbGV0IHsgZHJvcHBhYmxlU3RvcmUsIG9mZnNldFRyYWNrZXJzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgYmVzdEhpdCA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGlkIGluIGRyb3BwYWJsZVN0b3JlKSB7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50ID0gZHJvcHBhYmxlU3RvcmVbaWRdLmNvbXBvbmVudDtcbiAgICAgICAgICAgIGxldCBvZmZzZXRUcmFja2VyID0gb2Zmc2V0VHJhY2tlcnNbaWRdO1xuICAgICAgICAgICAgaWYgKG9mZnNldFRyYWNrZXIgJiYgLy8gd2Fzbid0IGRlc3Ryb3llZCBtaWQtZHJhZ1xuICAgICAgICAgICAgICAgIG9mZnNldFRyYWNrZXIuaXNXaXRoaW5DbGlwcGluZyhvZmZzZXRMZWZ0LCBvZmZzZXRUb3ApKSB7XG4gICAgICAgICAgICAgICAgbGV0IG9yaWdpbkxlZnQgPSBvZmZzZXRUcmFja2VyLmNvbXB1dGVMZWZ0KCk7XG4gICAgICAgICAgICAgICAgbGV0IG9yaWdpblRvcCA9IG9mZnNldFRyYWNrZXIuY29tcHV0ZVRvcCgpO1xuICAgICAgICAgICAgICAgIGxldCBwb3NpdGlvbkxlZnQgPSBvZmZzZXRMZWZ0IC0gb3JpZ2luTGVmdDtcbiAgICAgICAgICAgICAgICBsZXQgcG9zaXRpb25Ub3AgPSBvZmZzZXRUb3AgLSBvcmlnaW5Ub3A7XG4gICAgICAgICAgICAgICAgbGV0IHsgb3JpZ1JlY3QgfSA9IG9mZnNldFRyYWNrZXI7XG4gICAgICAgICAgICAgICAgbGV0IHdpZHRoID0gb3JpZ1JlY3QucmlnaHQgLSBvcmlnUmVjdC5sZWZ0O1xuICAgICAgICAgICAgICAgIGxldCBoZWlnaHQgPSBvcmlnUmVjdC5ib3R0b20gLSBvcmlnUmVjdC50b3A7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIC8vIG11c3QgYmUgd2l0aGluIHRoZSBlbGVtZW50J3MgYm91bmRzXG4gICAgICAgICAgICAgICAgcG9zaXRpb25MZWZ0ID49IDAgJiYgcG9zaXRpb25MZWZ0IDwgd2lkdGggJiZcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25Ub3AgPj0gMCAmJiBwb3NpdGlvblRvcCA8IGhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaGl0ID0gY29tcG9uZW50LnF1ZXJ5SGl0KHBvc2l0aW9uTGVmdCwgcG9zaXRpb25Ub3AsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGl0ICYmIChcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBoaXQgaXMgd2l0aGluIGFjdGl2ZVJhbmdlLCBtZWFuaW5nIGl0J3Mgbm90IGEgZGVhZCBjZWxsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlQ29udGFpbnNSYW5nZShoaXQuZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UsIGhpdC5kYXRlU3Bhbi5yYW5nZSkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhlIGNvbXBvbmVudCB3ZSBhcmUgcXVlcnlpbmcgZm9yIHRoZSBoaXQgaXMgYWNjZXNzaWJseSBteSB0aGUgcG9pbnRlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudHMgb2JzY3VyZWQgY2FsZW5kYXJzIChleDogdW5kZXIgYSBtb2RhbCBkaWFsb2cpIGZyb20gYWNjZXB0aW5nIGhpdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Z1bGxjYWxlbmRhci9mdWxsY2FsZW5kYXIvaXNzdWVzLzUwMjZcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLmRpc2FibGVQb2ludENoZWNrIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0VHJhY2tlci5lbC5jb250YWlucyhvZmZzZXRUcmFja2VyLmVsLmdldFJvb3ROb2RlKCkuZWxlbWVudEZyb21Qb2ludChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQtYmFjayBvcmlnaW5zIHRvIGdldCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRvcC1sZWZ0IG9mIHdpbmRvdyB2aWV3cG9ydFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uTGVmdCArIG9yaWdpbkxlZnQgLSB3aW5kb3cuc2Nyb2xsWCwgcG9zaXRpb25Ub3AgKyBvcmlnaW5Ub3AgLSB3aW5kb3cuc2Nyb2xsWSkpKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCFiZXN0SGl0IHx8IGhpdC5sYXllciA+IGJlc3RIaXQubGF5ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaXQuY29tcG9uZW50SWQgPSBpZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdC5jb250ZXh0ID0gY29tcG9uZW50LmNvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBiZXR0ZXIgd2F5IHRvIHJlLW9yaWVudCByZWN0YW5nbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdC5yZWN0LmxlZnQgKz0gb3JpZ2luTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdC5yZWN0LnJpZ2h0ICs9IG9yaWdpbkxlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaXQucmVjdC50b3AgKz0gb3JpZ2luVG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGl0LnJlY3QuYm90dG9tICs9IG9yaWdpblRvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RIaXQgPSBoaXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJlc3RIaXQ7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNIaXRzRXF1YWwoaGl0MCwgaGl0MSkge1xuICAgIGlmICghaGl0MCAmJiAhaGl0MSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKEJvb2xlYW4oaGl0MCkgIT09IEJvb2xlYW4oaGl0MSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gaXNEYXRlU3BhbnNFcXVhbChoaXQwLmRhdGVTcGFuLCBoaXQxLmRhdGVTcGFuKTtcbn1cblxuZnVuY3Rpb24gYnVpbGREYXRlUG9pbnRBcGlXaXRoQ29udGV4dChkYXRlU3BhbiwgY29udGV4dCkge1xuICAgIGxldCBwcm9wcyA9IHt9O1xuICAgIGZvciAobGV0IHRyYW5zZm9ybSBvZiBjb250ZXh0LnBsdWdpbkhvb2tzLmRhdGVQb2ludFRyYW5zZm9ybXMpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihwcm9wcywgdHJhbnNmb3JtKGRhdGVTcGFuLCBjb250ZXh0KSk7XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24ocHJvcHMsIGJ1aWxkRGF0ZVBvaW50QXBpKGRhdGVTcGFuLCBjb250ZXh0LmRhdGVFbnYpKTtcbiAgICByZXR1cm4gcHJvcHM7XG59XG5mdW5jdGlvbiBidWlsZERhdGVQb2ludEFwaShzcGFuLCBkYXRlRW52KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGF0ZTogZGF0ZUVudi50b0RhdGUoc3Bhbi5yYW5nZS5zdGFydCksXG4gICAgICAgIGRhdGVTdHI6IGRhdGVFbnYuZm9ybWF0SXNvKHNwYW4ucmFuZ2Uuc3RhcnQsIHsgb21pdFRpbWU6IHNwYW4uYWxsRGF5IH0pLFxuICAgICAgICBhbGxEYXk6IHNwYW4uYWxsRGF5LFxuICAgIH07XG59XG5cbi8qXG5Nb25pdG9ycyB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiBhIHNwZWNpZmljIGRhdGUvdGltZSBvZiBhIGNvbXBvbmVudC5cbkEgcG9pbnRlcmRvd24rcG9pbnRlcnVwIG9uIHRoZSBzYW1lIFwiaGl0XCIgY29uc3RpdHV0ZXMgYSBjbGljay5cbiovXG5jbGFzcyBEYXRlQ2xpY2tpbmcgZXh0ZW5kcyBJbnRlcmFjdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICAgICAgc3VwZXIoc2V0dGluZ3MpO1xuICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJEb3duID0gKHBldikgPT4ge1xuICAgICAgICAgICAgbGV0IHsgZHJhZ2dpbmcgfSA9IHRoaXM7XG4gICAgICAgICAgICBsZXQgZG93bkVsID0gcGV2Lm9yaWdFdmVudC50YXJnZXQ7XG4gICAgICAgICAgICAvLyBkbyB0aGlzIGluIHBvaW50ZXJkb3duIChub3QgZHJhZ2VuZCkgYmVjYXVzZSBET00gbWlnaHQgYmUgbXV0YXRlZCBieSB0aGUgdGltZSBkcmFnZW5kIGlzIGZpcmVkXG4gICAgICAgICAgICBkcmFnZ2luZy5zZXRJZ25vcmVNb3ZlKCF0aGlzLmNvbXBvbmVudC5pc1ZhbGlkRGF0ZURvd25FbChkb3duRWwpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gd29uJ3QgZXZlbiBmaXJlIGlmIG1vdmluZyB3YXMgaWdub3JlZFxuICAgICAgICB0aGlzLmhhbmRsZURyYWdFbmQgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGxldCB7IGNvbXBvbmVudCB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCB7IHBvaW50ZXIgfSA9IHRoaXMuZHJhZ2dpbmc7XG4gICAgICAgICAgICBpZiAoIXBvaW50ZXIud2FzVG91Y2hTY3JvbGwpIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBpbml0aWFsSGl0LCBmaW5hbEhpdCB9ID0gdGhpcy5oaXREcmFnZ2luZztcbiAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbEhpdCAmJiBmaW5hbEhpdCAmJiBpc0hpdHNFcXVhbChpbml0aWFsSGl0LCBmaW5hbEhpdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgY29udGV4dCB9ID0gY29tcG9uZW50O1xuICAgICAgICAgICAgICAgICAgICBsZXQgYXJnID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBidWlsZERhdGVQb2ludEFwaVdpdGhDb250ZXh0KGluaXRpYWxIaXQuZGF0ZVNwYW4sIGNvbnRleHQpKSwgeyBkYXlFbDogaW5pdGlhbEhpdC5kYXlFbCwganNFdmVudDogZXYub3JpZ0V2ZW50LCB2aWV3OiBjb250ZXh0LnZpZXdBcGkgfHwgY29udGV4dC5jYWxlbmRhckFwaS52aWV3IH0pO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZGF0ZUNsaWNrJywgYXJnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIHdlIERPIHdhbnQgdG8gd2F0Y2ggcG9pbnRlciBtb3ZlcyBiZWNhdXNlIG90aGVyd2lzZSBmaW5hbEhpdCB3b24ndCBnZXQgcG9wdWxhdGVkXG4gICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBuZXcgRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZyhzZXR0aW5ncy5lbCk7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcuYXV0b1Njcm9sbGVyLmlzRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgaGl0RHJhZ2dpbmcgPSB0aGlzLmhpdERyYWdnaW5nID0gbmV3IEhpdERyYWdnaW5nKHRoaXMuZHJhZ2dpbmcsIGludGVyYWN0aW9uU2V0dGluZ3NUb1N0b3JlKHNldHRpbmdzKSk7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ3BvaW50ZXJkb3duJywgdGhpcy5oYW5kbGVQb2ludGVyRG93bik7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdlbmQnLCB0aGlzLmhhbmRsZURyYWdFbmQpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRyYWdnaW5nLmRlc3Ryb3koKTtcbiAgICB9XG59XG5cbi8qXG5UcmFja3Mgd2hlbiB0aGUgdXNlciBzZWxlY3RzIGEgcG9ydGlvbiBvZiB0aW1lIG9mIGEgY29tcG9uZW50LFxuY29uc3RpdHV0ZWQgYnkgYSBkcmFnIG92ZXIgZGF0ZSBjZWxscywgd2l0aCBhIHBvc3NpYmxlIGRlbGF5IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRyYWcuXG4qL1xuY2xhc3MgRGF0ZVNlbGVjdGluZyBleHRlbmRzIEludGVyYWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgICAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgICAgIHRoaXMuZHJhZ1NlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlckRvd24gPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGxldCB7IGNvbXBvbmVudCwgZHJhZ2dpbmcgfSA9IHRoaXM7XG4gICAgICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSBjb21wb25lbnQuY29udGV4dDtcbiAgICAgICAgICAgIGxldCBjYW5TZWxlY3QgPSBvcHRpb25zLnNlbGVjdGFibGUgJiZcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuaXNWYWxpZERhdGVEb3duRWwoZXYub3JpZ0V2ZW50LnRhcmdldCk7XG4gICAgICAgICAgICAvLyBkb24ndCBib3RoZXIgdG8gd2F0Y2ggZXhwZW5zaXZlIG1vdmVzIGlmIGNvbXBvbmVudCB3b24ndCBkbyBzZWxlY3Rpb25cbiAgICAgICAgICAgIGRyYWdnaW5nLnNldElnbm9yZU1vdmUoIWNhblNlbGVjdCk7XG4gICAgICAgICAgICAvLyBpZiB0b3VjaCwgcmVxdWlyZSB1c2VyIHRvIGhvbGQgZG93blxuICAgICAgICAgICAgZHJhZ2dpbmcuZGVsYXkgPSBldi5pc1RvdWNoID8gZ2V0Q29tcG9uZW50VG91Y2hEZWxheSQxKGNvbXBvbmVudCkgOiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZURyYWdTdGFydCA9IChldikgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQuY29udGV4dC5jYWxlbmRhckFwaS51bnNlbGVjdChldik7IC8vIHVuc2VsZWN0IHByZXZpb3VzIHNlbGVjdGlvbnNcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVIaXRVcGRhdGUgPSAoaGl0LCBpc0ZpbmFsKSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBjb250ZXh0IH0gPSB0aGlzLmNvbXBvbmVudDtcbiAgICAgICAgICAgIGxldCBkcmFnU2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBpc0ludmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChoaXQpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5pdGlhbEhpdCA9IHRoaXMuaGl0RHJhZ2dpbmcuaW5pdGlhbEhpdDtcbiAgICAgICAgICAgICAgICBsZXQgZGlzYWxsb3dlZCA9IGhpdC5jb21wb25lbnRJZCA9PT0gaW5pdGlhbEhpdC5jb21wb25lbnRJZFxuICAgICAgICAgICAgICAgICAgICAmJiB0aGlzLmlzSGl0Q29tYm9BbGxvd2VkXG4gICAgICAgICAgICAgICAgICAgICYmICF0aGlzLmlzSGl0Q29tYm9BbGxvd2VkKGluaXRpYWxIaXQsIGhpdCk7XG4gICAgICAgICAgICAgICAgaWYgKCFkaXNhbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdTZWxlY3Rpb24gPSBqb2luSGl0c0ludG9TZWxlY3Rpb24oaW5pdGlhbEhpdCwgaGl0LCBjb250ZXh0LnBsdWdpbkhvb2tzLmRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWRyYWdTZWxlY3Rpb24gfHwgIWlzRGF0ZVNlbGVjdGlvblZhbGlkKGRyYWdTZWxlY3Rpb24sIGhpdC5kYXRlUHJvZmlsZSwgY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNJbnZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ1NlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRyYWdTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1NFTEVDVF9EQVRFUycsIHNlbGVjdGlvbjogZHJhZ1NlbGVjdGlvbiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc0ZpbmFsKSB7IC8vIG9ubHkgdW5zZWxlY3QgaWYgbW92ZWQgYXdheSB3aGlsZSBkcmFnZ2luZ1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRUxFQ1RfREFURVMnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0ludmFsaWQpIHtcbiAgICAgICAgICAgICAgICBlbmFibGVDdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpc2FibGVDdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNGaW5hbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ1NlbGVjdGlvbiA9IGRyYWdTZWxlY3Rpb247IC8vIG9ubHkgY2xlYXIgaWYgbW92ZWQgYXdheSBmcm9tIGFsbCBoaXRzIHdoaWxlIGRyYWdnaW5nXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlclVwID0gKHBldikgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuZHJhZ1NlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIHNlbGVjdGlvbiBpcyBhbHJlYWR5IHJlbmRlcmVkLCBzbyBqdXN0IG5lZWQgdG8gcmVwb3J0IHNlbGVjdGlvblxuICAgICAgICAgICAgICAgIHRyaWdnZXJEYXRlU2VsZWN0KHRoaXMuZHJhZ1NlbGVjdGlvbiwgcGV2LCB0aGlzLmNvbXBvbmVudC5jb250ZXh0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsZXQgeyBjb21wb25lbnQgfSA9IHNldHRpbmdzO1xuICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSBjb21wb25lbnQuY29udGV4dDtcbiAgICAgICAgbGV0IGRyYWdnaW5nID0gdGhpcy5kcmFnZ2luZyA9IG5ldyBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nKHNldHRpbmdzLmVsKTtcbiAgICAgICAgZHJhZ2dpbmcudG91Y2hTY3JvbGxBbGxvd2VkID0gZmFsc2U7XG4gICAgICAgIGRyYWdnaW5nLm1pbkRpc3RhbmNlID0gb3B0aW9ucy5zZWxlY3RNaW5EaXN0YW5jZSB8fCAwO1xuICAgICAgICBkcmFnZ2luZy5hdXRvU2Nyb2xsZXIuaXNFbmFibGVkID0gb3B0aW9ucy5kcmFnU2Nyb2xsO1xuICAgICAgICBsZXQgaGl0RHJhZ2dpbmcgPSB0aGlzLmhpdERyYWdnaW5nID0gbmV3IEhpdERyYWdnaW5nKHRoaXMuZHJhZ2dpbmcsIGludGVyYWN0aW9uU2V0dGluZ3NUb1N0b3JlKHNldHRpbmdzKSk7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ3BvaW50ZXJkb3duJywgdGhpcy5oYW5kbGVQb2ludGVyRG93bik7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdzdGFydCcsIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0KTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignaGl0dXBkYXRlJywgdGhpcy5oYW5kbGVIaXRVcGRhdGUpO1xuICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdwb2ludGVydXAnLCB0aGlzLmhhbmRsZVBvaW50ZXJVcCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcuZGVzdHJveSgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldENvbXBvbmVudFRvdWNoRGVsYXkkMShjb21wb25lbnQpIHtcbiAgICBsZXQgeyBvcHRpb25zIH0gPSBjb21wb25lbnQuY29udGV4dDtcbiAgICBsZXQgZGVsYXkgPSBvcHRpb25zLnNlbGVjdExvbmdQcmVzc0RlbGF5O1xuICAgIGlmIChkZWxheSA9PSBudWxsKSB7XG4gICAgICAgIGRlbGF5ID0gb3B0aW9ucy5sb25nUHJlc3NEZWxheTtcbiAgICB9XG4gICAgcmV0dXJuIGRlbGF5O1xufVxuZnVuY3Rpb24gam9pbkhpdHNJbnRvU2VsZWN0aW9uKGhpdDAsIGhpdDEsIGRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnMpIHtcbiAgICBsZXQgZGF0ZVNwYW4wID0gaGl0MC5kYXRlU3BhbjtcbiAgICBsZXQgZGF0ZVNwYW4xID0gaGl0MS5kYXRlU3BhbjtcbiAgICBsZXQgbXMgPSBbXG4gICAgICAgIGRhdGVTcGFuMC5yYW5nZS5zdGFydCxcbiAgICAgICAgZGF0ZVNwYW4wLnJhbmdlLmVuZCxcbiAgICAgICAgZGF0ZVNwYW4xLnJhbmdlLnN0YXJ0LFxuICAgICAgICBkYXRlU3BhbjEucmFuZ2UuZW5kLFxuICAgIF07XG4gICAgbXMuc29ydChjb21wYXJlTnVtYmVycyk7XG4gICAgbGV0IHByb3BzID0ge307XG4gICAgZm9yIChsZXQgdHJhbnNmb3JtZXIgb2YgZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVycykge1xuICAgICAgICBsZXQgcmVzID0gdHJhbnNmb3JtZXIoaGl0MCwgaGl0MSk7XG4gICAgICAgIGlmIChyZXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHByb3BzLCByZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb3BzLnJhbmdlID0geyBzdGFydDogbXNbMF0sIGVuZDogbXNbM10gfTtcbiAgICBwcm9wcy5hbGxEYXkgPSBkYXRlU3BhbjAuYWxsRGF5O1xuICAgIHJldHVybiBwcm9wcztcbn1cblxuY2xhc3MgRXZlbnREcmFnZ2luZyBleHRlbmRzIEludGVyYWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgICAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgICAgIC8vIGludGVybmFsIHN0YXRlXG4gICAgICAgIHRoaXMuc3ViamVjdEVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdWJqZWN0U2VnID0gbnVsbDsgLy8gdGhlIHNlZyBiZWluZyBzZWxlY3RlZC9kcmFnZ2VkXG4gICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmV2ZW50UmFuZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLnJlbGV2YW50RXZlbnRzID0gbnVsbDsgLy8gdGhlIGV2ZW50cyBiZWluZyBkcmFnZ2VkXG4gICAgICAgIHRoaXMucmVjZWl2aW5nQ29udGV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMudmFsaWRNdXRhdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMubXV0YXRlZFJlbGV2YW50RXZlbnRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyRG93biA9IChldikgPT4ge1xuICAgICAgICAgICAgbGV0IG9yaWdUYXJnZXQgPSBldi5vcmlnRXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgbGV0IHsgY29tcG9uZW50LCBkcmFnZ2luZyB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCB7IG1pcnJvciB9ID0gZHJhZ2dpbmc7XG4gICAgICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSBjb21wb25lbnQuY29udGV4dDtcbiAgICAgICAgICAgIGxldCBpbml0aWFsQ29udGV4dCA9IGNvbXBvbmVudC5jb250ZXh0O1xuICAgICAgICAgICAgdGhpcy5zdWJqZWN0RWwgPSBldi5zdWJqZWN0RWw7XG4gICAgICAgICAgICBsZXQgc3ViamVjdFNlZyA9IHRoaXMuc3ViamVjdFNlZyA9IGdldEVsU2VnKGV2LnN1YmplY3RFbCk7XG4gICAgICAgICAgICBsZXQgZXZlbnRSYW5nZSA9IHRoaXMuZXZlbnRSYW5nZSA9IHN1YmplY3RTZWcuZXZlbnRSYW5nZTtcbiAgICAgICAgICAgIGxldCBldmVudEluc3RhbmNlSWQgPSBldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWQ7XG4gICAgICAgICAgICB0aGlzLnJlbGV2YW50RXZlbnRzID0gZ2V0UmVsZXZhbnRFdmVudHMoaW5pdGlhbENvbnRleHQuZ2V0Q3VycmVudERhdGEoKS5ldmVudFN0b3JlLCBldmVudEluc3RhbmNlSWQpO1xuICAgICAgICAgICAgZHJhZ2dpbmcubWluRGlzdGFuY2UgPSBldi5pc1RvdWNoID8gMCA6IG9wdGlvbnMuZXZlbnREcmFnTWluRGlzdGFuY2U7XG4gICAgICAgICAgICBkcmFnZ2luZy5kZWxheSA9XG4gICAgICAgICAgICAgICAgLy8gb25seSBkbyBhIHRvdWNoIGRlbGF5IGlmIHRvdWNoIGFuZCB0aGlzIGV2ZW50IGhhc24ndCBiZWVuIHNlbGVjdGVkIHlldFxuICAgICAgICAgICAgICAgIChldi5pc1RvdWNoICYmIGV2ZW50SW5zdGFuY2VJZCAhPT0gY29tcG9uZW50LnByb3BzLmV2ZW50U2VsZWN0aW9uKSA/XG4gICAgICAgICAgICAgICAgICAgIGdldENvbXBvbmVudFRvdWNoRGVsYXkoY29tcG9uZW50KSA6XG4gICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5maXhlZE1pcnJvclBhcmVudCkge1xuICAgICAgICAgICAgICAgIG1pcnJvci5wYXJlbnROb2RlID0gb3B0aW9ucy5maXhlZE1pcnJvclBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1pcnJvci5wYXJlbnROb2RlID0gZWxlbWVudENsb3Nlc3Qob3JpZ1RhcmdldCwgJy5mYycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWlycm9yLnJldmVydER1cmF0aW9uID0gb3B0aW9ucy5kcmFnUmV2ZXJ0RHVyYXRpb247XG4gICAgICAgICAgICBsZXQgaXNWYWxpZCA9IGNvbXBvbmVudC5pc1ZhbGlkU2VnRG93bkVsKG9yaWdUYXJnZXQpICYmXG4gICAgICAgICAgICAgICAgIWVsZW1lbnRDbG9zZXN0KG9yaWdUYXJnZXQsICcuZmMtZXZlbnQtcmVzaXplcicpOyAvLyBOT1Qgb24gYSByZXNpemVyXG4gICAgICAgICAgICBkcmFnZ2luZy5zZXRJZ25vcmVNb3ZlKCFpc1ZhbGlkKTtcbiAgICAgICAgICAgIC8vIGRpc2FibGUgZHJhZ2dpbmcgZm9yIGVsZW1lbnRzIHRoYXQgYXJlIHJlc2l6YWJsZSAoaWUsIHNlbGVjdGFibGUpXG4gICAgICAgICAgICAvLyBidXQgYXJlIG5vdCBkcmFnZ2FibGVcbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGlzVmFsaWQgJiZcbiAgICAgICAgICAgICAgICBldi5zdWJqZWN0RWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdmYy1ldmVudC1kcmFnZ2FibGUnKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVEcmFnU3RhcnQgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGxldCBpbml0aWFsQ29udGV4dCA9IHRoaXMuY29tcG9uZW50LmNvbnRleHQ7XG4gICAgICAgICAgICBsZXQgZXZlbnRSYW5nZSA9IHRoaXMuZXZlbnRSYW5nZTtcbiAgICAgICAgICAgIGxldCBldmVudEluc3RhbmNlSWQgPSBldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWQ7XG4gICAgICAgICAgICBpZiAoZXYuaXNUb3VjaCkge1xuICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gc2VsZWN0IGEgZGlmZmVyZW50IGV2ZW50P1xuICAgICAgICAgICAgICAgIGlmIChldmVudEluc3RhbmNlSWQgIT09IHRoaXMuY29tcG9uZW50LnByb3BzLmV2ZW50U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1NFTEVDVF9FVkVOVCcsIGV2ZW50SW5zdGFuY2VJZCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBub3cgdXNpbmcgbW91c2UsIGJ1dCB3YXMgcHJldmlvdXMgdG91Y2ggaW50ZXJhY3Rpb24sIGNsZWFyIHNlbGVjdGVkIGV2ZW50XG4gICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRUxFQ1RfRVZFTlQnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZykge1xuICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0LmNhbGVuZGFyQXBpLnVuc2VsZWN0KGV2KTsgLy8gdW5zZWxlY3QgKmRhdGUqIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnREcmFnU3RhcnQnLCB7XG4gICAgICAgICAgICAgICAgICAgIGVsOiB0aGlzLnN1YmplY3RFbCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IG5ldyBFdmVudEltcGwoaW5pdGlhbENvbnRleHQsIGV2ZW50UmFuZ2UuZGVmLCBldmVudFJhbmdlLmluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICAgICAganNFdmVudDogZXYub3JpZ0V2ZW50LFxuICAgICAgICAgICAgICAgICAgICB2aWV3OiBpbml0aWFsQ29udGV4dC52aWV3QXBpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUhpdFVwZGF0ZSA9IChoaXQsIGlzRmluYWwpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlbGV2YW50RXZlbnRzID0gdGhpcy5yZWxldmFudEV2ZW50cztcbiAgICAgICAgICAgIGxldCBpbml0aWFsSGl0ID0gdGhpcy5oaXREcmFnZ2luZy5pbml0aWFsSGl0O1xuICAgICAgICAgICAgbGV0IGluaXRpYWxDb250ZXh0ID0gdGhpcy5jb21wb25lbnQuY29udGV4dDtcbiAgICAgICAgICAgIC8vIHN0YXRlcyBiYXNlZCBvbiBuZXcgaGl0XG4gICAgICAgICAgICBsZXQgcmVjZWl2aW5nQ29udGV4dCA9IG51bGw7XG4gICAgICAgICAgICBsZXQgbXV0YXRpb24gPSBudWxsO1xuICAgICAgICAgICAgbGV0IG11dGF0ZWRSZWxldmFudEV2ZW50cyA9IG51bGw7XG4gICAgICAgICAgICBsZXQgaXNJbnZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgaW50ZXJhY3Rpb24gPSB7XG4gICAgICAgICAgICAgICAgYWZmZWN0ZWRFdmVudHM6IHJlbGV2YW50RXZlbnRzLFxuICAgICAgICAgICAgICAgIG11dGF0ZWRFdmVudHM6IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpLFxuICAgICAgICAgICAgICAgIGlzRXZlbnQ6IHRydWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGhpdCkge1xuICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQgPSBoaXQuY29udGV4dDtcbiAgICAgICAgICAgICAgICBsZXQgcmVjZWl2aW5nT3B0aW9ucyA9IHJlY2VpdmluZ0NvbnRleHQub3B0aW9ucztcbiAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbENvbnRleHQgPT09IHJlY2VpdmluZ0NvbnRleHQgfHxcbiAgICAgICAgICAgICAgICAgICAgKHJlY2VpdmluZ09wdGlvbnMuZWRpdGFibGUgJiYgcmVjZWl2aW5nT3B0aW9ucy5kcm9wcGFibGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG11dGF0aW9uID0gY29tcHV0ZUV2ZW50TXV0YXRpb24oaW5pdGlhbEhpdCwgaGl0LCB0aGlzLmV2ZW50UmFuZ2UuaW5zdGFuY2UucmFuZ2Uuc3RhcnQsIHJlY2VpdmluZ0NvbnRleHQuZ2V0Q3VycmVudERhdGEoKS5wbHVnaW5Ib29rcy5ldmVudERyYWdNdXRhdGlvbk1hc3NhZ2Vycyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtdXRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRlZFJlbGV2YW50RXZlbnRzID0gYXBwbHlNdXRhdGlvblRvRXZlbnRTdG9yZShyZWxldmFudEV2ZW50cywgcmVjZWl2aW5nQ29udGV4dC5nZXRDdXJyZW50RGF0YSgpLmV2ZW50VWlCYXNlcywgbXV0YXRpb24sIHJlY2VpdmluZ0NvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cyA9IG11dGF0ZWRSZWxldmFudEV2ZW50cztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNJbnRlcmFjdGlvblZhbGlkKGludGVyYWN0aW9uLCBoaXQuZGF0ZVByb2ZpbGUsIHJlY2VpdmluZ0NvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNJbnZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRlZFJlbGV2YW50RXZlbnRzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGlzcGxheURyYWcocmVjZWl2aW5nQ29udGV4dCwgaW50ZXJhY3Rpb24pO1xuICAgICAgICAgICAgaWYgKCFpc0ludmFsaWQpIHtcbiAgICAgICAgICAgICAgICBlbmFibGVDdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpc2FibGVDdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNGaW5hbCkge1xuICAgICAgICAgICAgICAgIGlmIChpbml0aWFsQ29udGV4dCA9PT0gcmVjZWl2aW5nQ29udGV4dCAmJiAvLyBUT0RPOiB3cml0ZSB0ZXN0IGZvciB0aGlzXG4gICAgICAgICAgICAgICAgICAgIGlzSGl0c0VxdWFsKGluaXRpYWxIaXQsIGhpdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbXV0YXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdnaW5nLnNldE1pcnJvck5lZWRzUmV2ZXJ0KCFtdXRhdGlvbik7XG4gICAgICAgICAgICAgICAgLy8gcmVuZGVyIHRoZSBtaXJyb3IgaWYgbm8gYWxyZWFkeS1yZW5kZXJlZCBtaXJyb3JcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiB3aXNoIHdlIGNvdWxkIHNvbWVob3cgd2FpdCBmb3IgZGlzcGF0Y2ggdG8gZ3VhcmFudGVlIHJlbmRlclxuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcuc2V0TWlycm9ySXNWaXNpYmxlKCFoaXQgfHwgIXRoaXMuc3ViamVjdEVsLmdldFJvb3ROb2RlKCkucXVlcnlTZWxlY3RvcignLmZjLWV2ZW50LW1pcnJvcicpKTtcbiAgICAgICAgICAgICAgICAvLyBhc3NpZ24gc3RhdGVzIGJhc2VkIG9uIG5ldyBoaXRcbiAgICAgICAgICAgICAgICB0aGlzLnJlY2VpdmluZ0NvbnRleHQgPSByZWNlaXZpbmdDb250ZXh0O1xuICAgICAgICAgICAgICAgIHRoaXMudmFsaWRNdXRhdGlvbiA9IG11dGF0aW9uO1xuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlZFJlbGV2YW50RXZlbnRzID0gbXV0YXRlZFJlbGV2YW50RXZlbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJVcCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhbnVwKCk7IC8vIGJlY2F1c2UgaGFuZGxlRHJhZ0VuZCB3b24ndCBmaXJlXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlRHJhZ0VuZCA9IChldikgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZykge1xuICAgICAgICAgICAgICAgIGxldCBpbml0aWFsQ29udGV4dCA9IHRoaXMuY29tcG9uZW50LmNvbnRleHQ7XG4gICAgICAgICAgICAgICAgbGV0IGluaXRpYWxWaWV3ID0gaW5pdGlhbENvbnRleHQudmlld0FwaTtcbiAgICAgICAgICAgICAgICBsZXQgeyByZWNlaXZpbmdDb250ZXh0LCB2YWxpZE11dGF0aW9uIH0gPSB0aGlzO1xuICAgICAgICAgICAgICAgIGxldCBldmVudERlZiA9IHRoaXMuZXZlbnRSYW5nZS5kZWY7XG4gICAgICAgICAgICAgICAgbGV0IGV2ZW50SW5zdGFuY2UgPSB0aGlzLmV2ZW50UmFuZ2UuaW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgbGV0IGV2ZW50QXBpID0gbmV3IEV2ZW50SW1wbChpbml0aWFsQ29udGV4dCwgZXZlbnREZWYsIGV2ZW50SW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIGxldCByZWxldmFudEV2ZW50cyA9IHRoaXMucmVsZXZhbnRFdmVudHM7XG4gICAgICAgICAgICAgICAgbGV0IG11dGF0ZWRSZWxldmFudEV2ZW50cyA9IHRoaXMubXV0YXRlZFJlbGV2YW50RXZlbnRzO1xuICAgICAgICAgICAgICAgIGxldCB7IGZpbmFsSGl0IH0gPSB0aGlzLmhpdERyYWdnaW5nO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJEcmFnKCk7IC8vIG11c3QgaGFwcGVuIGFmdGVyIHJldmVydCBhbmltYXRpb25cbiAgICAgICAgICAgICAgICBpbml0aWFsQ29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50RHJhZ1N0b3AnLCB7XG4gICAgICAgICAgICAgICAgICAgIGVsOiB0aGlzLnN1YmplY3RFbCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50QXBpLFxuICAgICAgICAgICAgICAgICAgICBqc0V2ZW50OiBldi5vcmlnRXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIHZpZXc6IGluaXRpYWxWaWV3LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh2YWxpZE11dGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRyb3BwZWQgd2l0aGluIHNhbWUgY2FsZW5kYXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY2VpdmluZ0NvbnRleHQgPT09IGluaXRpYWxDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdXBkYXRlZEV2ZW50QXBpID0gbmV3IEV2ZW50SW1wbChpbml0aWFsQ29udGV4dCwgbXV0YXRlZFJlbGV2YW50RXZlbnRzLmRlZnNbZXZlbnREZWYuZGVmSWRdLCBldmVudEluc3RhbmNlID8gbXV0YXRlZFJlbGV2YW50RXZlbnRzLmluc3RhbmNlc1tldmVudEluc3RhbmNlLmluc3RhbmNlSWRdIDogbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsQ29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ01FUkdFX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogbXV0YXRlZFJlbGV2YW50RXZlbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZXZlbnRDaGFuZ2VBcmcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkRXZlbnQ6IGV2ZW50QXBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiB1cGRhdGVkRXZlbnRBcGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRlZEV2ZW50czogYnVpbGRFdmVudEFwaXMobXV0YXRlZFJlbGV2YW50RXZlbnRzLCBpbml0aWFsQ29udGV4dCwgZXZlbnRJbnN0YW5jZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJ0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsQ29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTUVSR0VfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IHJlbGV2YW50RXZlbnRzLCAvLyB0aGUgcHJlLWNoYW5nZSBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRyYW5zZm9ybWVkID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB0cmFuc2Zvcm1lciBvZiBpbml0aWFsQ29udGV4dC5nZXRDdXJyZW50RGF0YSgpLnBsdWdpbkhvb2tzLmV2ZW50RHJvcFRyYW5zZm9ybWVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHJhbnNmb3JtZWQsIHRyYW5zZm9ybWVyKHZhbGlkTXV0YXRpb24sIGluaXRpYWxDb250ZXh0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsQ29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50RHJvcCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBldmVudENoYW5nZUFyZyksIHRyYW5zZm9ybWVkKSwgeyBlbDogZXYuc3ViamVjdEVsLCBkZWx0YTogdmFsaWRNdXRhdGlvbi5kYXRlc0RlbHRhLCBqc0V2ZW50OiBldi5vcmlnRXZlbnQsIHZpZXc6IGluaXRpYWxWaWV3IH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRDaGFuZ2UnLCBldmVudENoYW5nZUFyZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkcm9wcGVkIGluIGRpZmZlcmVudCBjYWxlbmRhclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlY2VpdmluZ0NvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBldmVudFJlbW92ZUFyZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDogZXZlbnRBcGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRlZEV2ZW50czogYnVpbGRFdmVudEFwaXMocmVsZXZhbnRFdmVudHMsIGluaXRpYWxDb250ZXh0LCBldmVudEluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdNRVJHRV9FVkVOVFMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogcmVsZXZhbnRFdmVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudExlYXZlJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBldmVudFJlbW92ZUFyZyksIHsgZHJhZ2dlZEVsOiBldi5zdWJqZWN0RWwsIHZpZXc6IGluaXRpYWxWaWV3IH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnUkVNT1ZFX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogcmVsZXZhbnRFdmVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRSZW1vdmUnLCBldmVudFJlbW92ZUFyZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYWRkZWRFdmVudERlZiA9IG11dGF0ZWRSZWxldmFudEV2ZW50cy5kZWZzW2V2ZW50RGVmLmRlZklkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhZGRlZEV2ZW50SW5zdGFuY2UgPSBtdXRhdGVkUmVsZXZhbnRFdmVudHMuaW5zdGFuY2VzW2V2ZW50SW5zdGFuY2UuaW5zdGFuY2VJZF07XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYWRkZWRFdmVudEFwaSA9IG5ldyBFdmVudEltcGwocmVjZWl2aW5nQ29udGV4dCwgYWRkZWRFdmVudERlZiwgYWRkZWRFdmVudEluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdNRVJHRV9FVkVOVFMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IG11dGF0ZWRSZWxldmFudEV2ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGV2ZW50QWRkQXJnID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBhZGRlZEV2ZW50QXBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0ZWRFdmVudHM6IGJ1aWxkRXZlbnRBcGlzKG11dGF0ZWRSZWxldmFudEV2ZW50cywgcmVjZWl2aW5nQ29udGV4dCwgYWRkZWRFdmVudEluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1JFTU9WRV9FVkVOVFMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogbXV0YXRlZFJlbGV2YW50RXZlbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudEFkZCcsIGV2ZW50QWRkQXJnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldi5pc1RvdWNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdTRUxFQ1RfRVZFTlQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudEluc3RhbmNlSWQ6IGV2ZW50SW5zdGFuY2UuaW5zdGFuY2VJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdkcm9wJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBidWlsZERhdGVQb2ludEFwaVdpdGhDb250ZXh0KGZpbmFsSGl0LmRhdGVTcGFuLCByZWNlaXZpbmdDb250ZXh0KSksIHsgZHJhZ2dlZEVsOiBldi5zdWJqZWN0RWwsIGpzRXZlbnQ6IGV2Lm9yaWdFdmVudCwgdmlldzogZmluYWxIaXQuY29udGV4dC52aWV3QXBpIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudFJlY2VpdmUnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV2ZW50QWRkQXJnKSwgeyBkcmFnZ2VkRWw6IGV2LnN1YmplY3RFbCwgdmlldzogZmluYWxIaXQuY29udGV4dC52aWV3QXBpIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdfbm9FdmVudERyb3AnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHsgY29tcG9uZW50IH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSBjb21wb25lbnQuY29udGV4dDtcbiAgICAgICAgbGV0IGRyYWdnaW5nID0gdGhpcy5kcmFnZ2luZyA9IG5ldyBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nKHNldHRpbmdzLmVsKTtcbiAgICAgICAgZHJhZ2dpbmcucG9pbnRlci5zZWxlY3RvciA9IEV2ZW50RHJhZ2dpbmcuU0VMRUNUT1I7XG4gICAgICAgIGRyYWdnaW5nLnRvdWNoU2Nyb2xsQWxsb3dlZCA9IGZhbHNlO1xuICAgICAgICBkcmFnZ2luZy5hdXRvU2Nyb2xsZXIuaXNFbmFibGVkID0gb3B0aW9ucy5kcmFnU2Nyb2xsO1xuICAgICAgICBsZXQgaGl0RHJhZ2dpbmcgPSB0aGlzLmhpdERyYWdnaW5nID0gbmV3IEhpdERyYWdnaW5nKHRoaXMuZHJhZ2dpbmcsIGludGVyYWN0aW9uU2V0dGluZ3NTdG9yZSk7XG4gICAgICAgIGhpdERyYWdnaW5nLnVzZVN1YmplY3RDZW50ZXIgPSBzZXR0aW5ncy51c2VFdmVudENlbnRlcjtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCB0aGlzLmhhbmRsZVBvaW50ZXJEb3duKTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ3N0YXJ0JywgdGhpcy5oYW5kbGVEcmFnU3RhcnQpO1xuICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdoaXR1cGRhdGUnLCB0aGlzLmhhbmRsZUhpdFVwZGF0ZSk7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ3BvaW50ZXJ1cCcsIHRoaXMuaGFuZGxlUG9pbnRlclVwKTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ2VuZCcsIHRoaXMuaGFuZGxlRHJhZ0VuZCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcuZGVzdHJveSgpO1xuICAgIH1cbiAgICAvLyByZW5kZXIgYSBkcmFnIHN0YXRlIG9uIHRoZSBuZXh0IHJlY2VpdmluZ0NhbGVuZGFyXG4gICAgZGlzcGxheURyYWcobmV4dENvbnRleHQsIHN0YXRlKSB7XG4gICAgICAgIGxldCBpbml0aWFsQ29udGV4dCA9IHRoaXMuY29tcG9uZW50LmNvbnRleHQ7XG4gICAgICAgIGxldCBwcmV2Q29udGV4dCA9IHRoaXMucmVjZWl2aW5nQ29udGV4dDtcbiAgICAgICAgLy8gZG9lcyB0aGUgcHJldmlvdXMgY2FsZW5kYXIgbmVlZCB0byBiZSBjbGVhcmVkP1xuICAgICAgICBpZiAocHJldkNvbnRleHQgJiYgcHJldkNvbnRleHQgIT09IG5leHRDb250ZXh0KSB7XG4gICAgICAgICAgICAvLyBkb2VzIHRoZSBpbml0aWFsIGNhbGVuZGFyIG5lZWQgdG8gYmUgY2xlYXJlZD9cbiAgICAgICAgICAgIC8vIGlmIHNvLCBkb24ndCBjbGVhciBhbGwgdGhlIHdheS4gd2Ugc3RpbGwgbmVlZCB0byB0byBoaWRlIHRoZSBhZmZlY3RlZEV2ZW50c1xuICAgICAgICAgICAgaWYgKHByZXZDb250ZXh0ID09PSBpbml0aWFsQ29udGV4dCkge1xuICAgICAgICAgICAgICAgIHByZXZDb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1NFVF9FVkVOVF9EUkFHJyxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmZmVjdGVkRXZlbnRzOiBzdGF0ZS5hZmZlY3RlZEV2ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0ZWRFdmVudHM6IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNFdmVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBjb21wbGV0ZWx5IGNsZWFyIHRoZSBvbGQgY2FsZW5kYXIgaWYgaXQgd2Fzbid0IHRoZSBpbml0aWFsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmV2Q29udGV4dC5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFVF9FVkVOVF9EUkFHJyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dENvbnRleHQpIHtcbiAgICAgICAgICAgIG5leHRDb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1NFVF9FVkVOVF9EUkFHJywgc3RhdGUgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xlYXJEcmFnKCkge1xuICAgICAgICBsZXQgaW5pdGlhbENhbGVuZGFyID0gdGhpcy5jb21wb25lbnQuY29udGV4dDtcbiAgICAgICAgbGV0IHsgcmVjZWl2aW5nQ29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgaWYgKHJlY2VpdmluZ0NvbnRleHQpIHtcbiAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRVRfRVZFTlRfRFJBRycgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlIGluaXRpYWwgY2FsZW5kYXIgbWlnaHQgaGF2ZSBhbiBkdW1teSBkcmFnIHN0YXRlIGZyb20gZGlzcGxheURyYWdcbiAgICAgICAgaWYgKGluaXRpYWxDYWxlbmRhciAhPT0gcmVjZWl2aW5nQ29udGV4dCkge1xuICAgICAgICAgICAgaW5pdGlhbENhbGVuZGFyLmRpc3BhdGNoKHsgdHlwZTogJ1VOU0VUX0VWRU5UX0RSQUcnIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsZWFudXAoKSB7XG4gICAgICAgIHRoaXMuc3ViamVjdFNlZyA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmV2ZW50UmFuZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLnJlbGV2YW50RXZlbnRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWNlaXZpbmdDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy52YWxpZE11dGF0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5tdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBudWxsO1xuICAgIH1cbn1cbi8vIFRPRE86IHRlc3QgdGhpcyBpbiBJRTExXG4vLyBRVUVTVElPTjogd2h5IGRvIHdlIG5lZWQgaXQgb24gdGhlIHJlc2l6YWJsZT8/P1xuRXZlbnREcmFnZ2luZy5TRUxFQ1RPUiA9ICcuZmMtZXZlbnQtZHJhZ2dhYmxlLCAuZmMtZXZlbnQtcmVzaXphYmxlJztcbmZ1bmN0aW9uIGNvbXB1dGVFdmVudE11dGF0aW9uKGhpdDAsIGhpdDEsIGV2ZW50SW5zdGFuY2VTdGFydCwgbWFzc2FnZXJzKSB7XG4gICAgbGV0IGRhdGVTcGFuMCA9IGhpdDAuZGF0ZVNwYW47XG4gICAgbGV0IGRhdGVTcGFuMSA9IGhpdDEuZGF0ZVNwYW47XG4gICAgbGV0IGRhdGUwID0gZGF0ZVNwYW4wLnJhbmdlLnN0YXJ0O1xuICAgIGxldCBkYXRlMSA9IGRhdGVTcGFuMS5yYW5nZS5zdGFydDtcbiAgICBsZXQgc3RhbmRhcmRQcm9wcyA9IHt9O1xuICAgIGlmIChkYXRlU3BhbjAuYWxsRGF5ICE9PSBkYXRlU3BhbjEuYWxsRGF5KSB7XG4gICAgICAgIHN0YW5kYXJkUHJvcHMuYWxsRGF5ID0gZGF0ZVNwYW4xLmFsbERheTtcbiAgICAgICAgc3RhbmRhcmRQcm9wcy5oYXNFbmQgPSBoaXQxLmNvbnRleHQub3B0aW9ucy5hbGxEYXlNYWludGFpbkR1cmF0aW9uO1xuICAgICAgICBpZiAoZGF0ZVNwYW4xLmFsbERheSkge1xuICAgICAgICAgICAgLy8gbWVhbnMgZGF0ZTEgaXMgYWxyZWFkeSBzdGFydC1vZi1kYXksXG4gICAgICAgICAgICAvLyBidXQgZGF0ZTAgbmVlZHMgdG8gYmUgY29udmVydGVkXG4gICAgICAgICAgICBkYXRlMCA9IHN0YXJ0T2ZEYXkoZXZlbnRJbnN0YW5jZVN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE1vdmluZyBmcm9tIGFsbERhdGUtPnRpbWVkXG4gICAgICAgICAgICAvLyBEb2Vzbid0IG1hdHRlciB3aGVyZSBvbiB0aGUgZXZlbnQgdGhlIGRyYWcgYmVnYW4sIG11dGF0ZSB0aGUgZXZlbnQncyBzdGFydC1kYXRlIHRvIGRhdGUxXG4gICAgICAgICAgICBkYXRlMCA9IGV2ZW50SW5zdGFuY2VTdGFydDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgZGVsdGEgPSBkaWZmRGF0ZXMoZGF0ZTAsIGRhdGUxLCBoaXQwLmNvbnRleHQuZGF0ZUVudiwgaGl0MC5jb21wb25lbnRJZCA9PT0gaGl0MS5jb21wb25lbnRJZCA/XG4gICAgICAgIGhpdDAubGFyZ2VVbml0IDpcbiAgICAgICAgbnVsbCk7XG4gICAgaWYgKGRlbHRhLm1pbGxpc2Vjb25kcykgeyAvLyBoYXMgaG91cnMvbWludXRlcy9zZWNvbmRzXG4gICAgICAgIHN0YW5kYXJkUHJvcHMuYWxsRGF5ID0gZmFsc2U7XG4gICAgfVxuICAgIGxldCBtdXRhdGlvbiA9IHtcbiAgICAgICAgZGF0ZXNEZWx0YTogZGVsdGEsXG4gICAgICAgIHN0YW5kYXJkUHJvcHMsXG4gICAgfTtcbiAgICBmb3IgKGxldCBtYXNzYWdlciBvZiBtYXNzYWdlcnMpIHtcbiAgICAgICAgbWFzc2FnZXIobXV0YXRpb24sIGhpdDAsIGhpdDEpO1xuICAgIH1cbiAgICByZXR1cm4gbXV0YXRpb247XG59XG5mdW5jdGlvbiBnZXRDb21wb25lbnRUb3VjaERlbGF5KGNvbXBvbmVudCkge1xuICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbXBvbmVudC5jb250ZXh0O1xuICAgIGxldCBkZWxheSA9IG9wdGlvbnMuZXZlbnRMb25nUHJlc3NEZWxheTtcbiAgICBpZiAoZGVsYXkgPT0gbnVsbCkge1xuICAgICAgICBkZWxheSA9IG9wdGlvbnMubG9uZ1ByZXNzRGVsYXk7XG4gICAgfVxuICAgIHJldHVybiBkZWxheTtcbn1cblxuY2xhc3MgRXZlbnRSZXNpemluZyBleHRlbmRzIEludGVyYWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgICAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgICAgIC8vIGludGVybmFsIHN0YXRlXG4gICAgICAgIHRoaXMuZHJhZ2dpbmdTZWdFbCA9IG51bGw7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmdTZWcgPSBudWxsOyAvLyBUT0RPOiByZW5hbWUgdG8gcmVzaXppbmdTZWc/IHN1YmplY3RTZWc/XG4gICAgICAgIHRoaXMuZXZlbnRSYW5nZSA9IG51bGw7XG4gICAgICAgIHRoaXMucmVsZXZhbnRFdmVudHMgPSBudWxsO1xuICAgICAgICB0aGlzLnZhbGlkTXV0YXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLm11dGF0ZWRSZWxldmFudEV2ZW50cyA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlckRvd24gPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGxldCB7IGNvbXBvbmVudCB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCBzZWdFbCA9IHRoaXMucXVlcnlTZWdFbChldik7XG4gICAgICAgICAgICBsZXQgc2VnID0gZ2V0RWxTZWcoc2VnRWwpO1xuICAgICAgICAgICAgbGV0IGV2ZW50UmFuZ2UgPSB0aGlzLmV2ZW50UmFuZ2UgPSBzZWcuZXZlbnRSYW5nZTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcubWluRGlzdGFuY2UgPSBjb21wb25lbnQuY29udGV4dC5vcHRpb25zLmV2ZW50RHJhZ01pbkRpc3RhbmNlO1xuICAgICAgICAgICAgLy8gaWYgdG91Y2gsIG5lZWQgdG8gYmUgd29ya2luZyB3aXRoIGEgc2VsZWN0ZWQgZXZlbnRcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcuc2V0SWdub3JlTW92ZSghdGhpcy5jb21wb25lbnQuaXNWYWxpZFNlZ0Rvd25FbChldi5vcmlnRXZlbnQudGFyZ2V0KSB8fFxuICAgICAgICAgICAgICAgIChldi5pc1RvdWNoICYmIHRoaXMuY29tcG9uZW50LnByb3BzLmV2ZW50U2VsZWN0aW9uICE9PSBldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWQpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVEcmFnU3RhcnQgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGxldCB7IGNvbnRleHQgfSA9IHRoaXMuY29tcG9uZW50O1xuICAgICAgICAgICAgbGV0IGV2ZW50UmFuZ2UgPSB0aGlzLmV2ZW50UmFuZ2U7XG4gICAgICAgICAgICB0aGlzLnJlbGV2YW50RXZlbnRzID0gZ2V0UmVsZXZhbnRFdmVudHMoY29udGV4dC5nZXRDdXJyZW50RGF0YSgpLmV2ZW50U3RvcmUsIHRoaXMuZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkKTtcbiAgICAgICAgICAgIGxldCBzZWdFbCA9IHRoaXMucXVlcnlTZWdFbChldik7XG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nU2VnRWwgPSBzZWdFbDtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdTZWcgPSBnZXRFbFNlZyhzZWdFbCk7XG4gICAgICAgICAgICBjb250ZXh0LmNhbGVuZGFyQXBpLnVuc2VsZWN0KCk7XG4gICAgICAgICAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRSZXNpemVTdGFydCcsIHtcbiAgICAgICAgICAgICAgICBlbDogc2VnRWwsXG4gICAgICAgICAgICAgICAgZXZlbnQ6IG5ldyBFdmVudEltcGwoY29udGV4dCwgZXZlbnRSYW5nZS5kZWYsIGV2ZW50UmFuZ2UuaW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgIGpzRXZlbnQ6IGV2Lm9yaWdFdmVudCxcbiAgICAgICAgICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVIaXRVcGRhdGUgPSAoaGl0LCBpc0ZpbmFsLCBldikgPT4ge1xuICAgICAgICAgICAgbGV0IHsgY29udGV4dCB9ID0gdGhpcy5jb21wb25lbnQ7XG4gICAgICAgICAgICBsZXQgcmVsZXZhbnRFdmVudHMgPSB0aGlzLnJlbGV2YW50RXZlbnRzO1xuICAgICAgICAgICAgbGV0IGluaXRpYWxIaXQgPSB0aGlzLmhpdERyYWdnaW5nLmluaXRpYWxIaXQ7XG4gICAgICAgICAgICBsZXQgZXZlbnRJbnN0YW5jZSA9IHRoaXMuZXZlbnRSYW5nZS5pbnN0YW5jZTtcbiAgICAgICAgICAgIGxldCBtdXRhdGlvbiA9IG51bGw7XG4gICAgICAgICAgICBsZXQgbXV0YXRlZFJlbGV2YW50RXZlbnRzID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBpc0ludmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBpbnRlcmFjdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBhZmZlY3RlZEV2ZW50czogcmVsZXZhbnRFdmVudHMsXG4gICAgICAgICAgICAgICAgbXV0YXRlZEV2ZW50czogY3JlYXRlRW1wdHlFdmVudFN0b3JlKCksXG4gICAgICAgICAgICAgICAgaXNFdmVudDogdHJ1ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoaGl0KSB7XG4gICAgICAgICAgICAgICAgbGV0IGRpc2FsbG93ZWQgPSBoaXQuY29tcG9uZW50SWQgPT09IGluaXRpYWxIaXQuY29tcG9uZW50SWRcbiAgICAgICAgICAgICAgICAgICAgJiYgdGhpcy5pc0hpdENvbWJvQWxsb3dlZFxuICAgICAgICAgICAgICAgICAgICAmJiAhdGhpcy5pc0hpdENvbWJvQWxsb3dlZChpbml0aWFsSGl0LCBoaXQpO1xuICAgICAgICAgICAgICAgIGlmICghZGlzYWxsb3dlZCkge1xuICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbiA9IGNvbXB1dGVNdXRhdGlvbihpbml0aWFsSGl0LCBoaXQsIGV2LnN1YmplY3RFbC5jbGFzc0xpc3QuY29udGFpbnMoJ2ZjLWV2ZW50LXJlc2l6ZXItc3RhcnQnKSwgZXZlbnRJbnN0YW5jZS5yYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG11dGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgbXV0YXRlZFJlbGV2YW50RXZlbnRzID0gYXBwbHlNdXRhdGlvblRvRXZlbnRTdG9yZShyZWxldmFudEV2ZW50cywgY29udGV4dC5nZXRDdXJyZW50RGF0YSgpLmV2ZW50VWlCYXNlcywgbXV0YXRpb24sIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMgPSBtdXRhdGVkUmVsZXZhbnRFdmVudHM7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0ludGVyYWN0aW9uVmFsaWQoaW50ZXJhY3Rpb24sIGhpdC5kYXRlUHJvZmlsZSwgY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNJbnZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbXV0YXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBtdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobXV0YXRlZFJlbGV2YW50RXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdTRVRfRVZFTlRfUkVTSVpFJyxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IGludGVyYWN0aW9uLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFVF9FVkVOVF9SRVNJWkUnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0ludmFsaWQpIHtcbiAgICAgICAgICAgICAgICBlbmFibGVDdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpc2FibGVDdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNGaW5hbCkge1xuICAgICAgICAgICAgICAgIGlmIChtdXRhdGlvbiAmJiBpc0hpdHNFcXVhbChpbml0aWFsSGl0LCBoaXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG11dGF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy52YWxpZE11dGF0aW9uID0gbXV0YXRpb247XG4gICAgICAgICAgICAgICAgdGhpcy5tdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBtdXRhdGVkUmVsZXZhbnRFdmVudHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlRHJhZ0VuZCA9IChldikgPT4ge1xuICAgICAgICAgICAgbGV0IHsgY29udGV4dCB9ID0gdGhpcy5jb21wb25lbnQ7XG4gICAgICAgICAgICBsZXQgZXZlbnREZWYgPSB0aGlzLmV2ZW50UmFuZ2UuZGVmO1xuICAgICAgICAgICAgbGV0IGV2ZW50SW5zdGFuY2UgPSB0aGlzLmV2ZW50UmFuZ2UuaW5zdGFuY2U7XG4gICAgICAgICAgICBsZXQgZXZlbnRBcGkgPSBuZXcgRXZlbnRJbXBsKGNvbnRleHQsIGV2ZW50RGVmLCBldmVudEluc3RhbmNlKTtcbiAgICAgICAgICAgIGxldCByZWxldmFudEV2ZW50cyA9IHRoaXMucmVsZXZhbnRFdmVudHM7XG4gICAgICAgICAgICBsZXQgbXV0YXRlZFJlbGV2YW50RXZlbnRzID0gdGhpcy5tdXRhdGVkUmVsZXZhbnRFdmVudHM7XG4gICAgICAgICAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRSZXNpemVTdG9wJywge1xuICAgICAgICAgICAgICAgIGVsOiB0aGlzLmRyYWdnaW5nU2VnRWwsXG4gICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50QXBpLFxuICAgICAgICAgICAgICAgIGpzRXZlbnQ6IGV2Lm9yaWdFdmVudCxcbiAgICAgICAgICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbGlkTXV0YXRpb24pIHtcbiAgICAgICAgICAgICAgICBsZXQgdXBkYXRlZEV2ZW50QXBpID0gbmV3IEV2ZW50SW1wbChjb250ZXh0LCBtdXRhdGVkUmVsZXZhbnRFdmVudHMuZGVmc1tldmVudERlZi5kZWZJZF0sIGV2ZW50SW5zdGFuY2UgPyBtdXRhdGVkUmVsZXZhbnRFdmVudHMuaW5zdGFuY2VzW2V2ZW50SW5zdGFuY2UuaW5zdGFuY2VJZF0gOiBudWxsKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ01FUkdFX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IG11dGF0ZWRSZWxldmFudEV2ZW50cyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsZXQgZXZlbnRDaGFuZ2VBcmcgPSB7XG4gICAgICAgICAgICAgICAgICAgIG9sZEV2ZW50OiBldmVudEFwaSxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IHVwZGF0ZWRFdmVudEFwaSxcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRlZEV2ZW50czogYnVpbGRFdmVudEFwaXMobXV0YXRlZFJlbGV2YW50RXZlbnRzLCBjb250ZXh0LCBldmVudEluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJ0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ01FUkdFX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogcmVsZXZhbnRFdmVudHMsIC8vIHRoZSBwcmUtY2hhbmdlIGV2ZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRSZXNpemUnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV2ZW50Q2hhbmdlQXJnKSwgeyBlbDogdGhpcy5kcmFnZ2luZ1NlZ0VsLCBzdGFydERlbHRhOiB0aGlzLnZhbGlkTXV0YXRpb24uc3RhcnREZWx0YSB8fCBjcmVhdGVEdXJhdGlvbigwKSwgZW5kRGVsdGE6IHRoaXMudmFsaWRNdXRhdGlvbi5lbmREZWx0YSB8fCBjcmVhdGVEdXJhdGlvbigwKSwganNFdmVudDogZXYub3JpZ0V2ZW50LCB2aWV3OiBjb250ZXh0LnZpZXdBcGkgfSkpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudENoYW5nZScsIGV2ZW50Q2hhbmdlQXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdfbm9FdmVudFJlc2l6ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmVzZXQgYWxsIGludGVybmFsIHN0YXRlXG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nU2VnID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucmVsZXZhbnRFdmVudHMgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy52YWxpZE11dGF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIC8vIG9rYXkgdG8ga2VlcCBldmVudEluc3RhbmNlIGFyb3VuZC4gdXNlZnVsIHRvIHNldCBpdCBpbiBoYW5kbGVQb2ludGVyRG93blxuICAgICAgICB9O1xuICAgICAgICBsZXQgeyBjb21wb25lbnQgfSA9IHNldHRpbmdzO1xuICAgICAgICBsZXQgZHJhZ2dpbmcgPSB0aGlzLmRyYWdnaW5nID0gbmV3IEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcoc2V0dGluZ3MuZWwpO1xuICAgICAgICBkcmFnZ2luZy5wb2ludGVyLnNlbGVjdG9yID0gJy5mYy1ldmVudC1yZXNpemVyJztcbiAgICAgICAgZHJhZ2dpbmcudG91Y2hTY3JvbGxBbGxvd2VkID0gZmFsc2U7XG4gICAgICAgIGRyYWdnaW5nLmF1dG9TY3JvbGxlci5pc0VuYWJsZWQgPSBjb21wb25lbnQuY29udGV4dC5vcHRpb25zLmRyYWdTY3JvbGw7XG4gICAgICAgIGxldCBoaXREcmFnZ2luZyA9IHRoaXMuaGl0RHJhZ2dpbmcgPSBuZXcgSGl0RHJhZ2dpbmcodGhpcy5kcmFnZ2luZywgaW50ZXJhY3Rpb25TZXR0aW5nc1RvU3RvcmUoc2V0dGluZ3MpKTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCB0aGlzLmhhbmRsZVBvaW50ZXJEb3duKTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ3N0YXJ0JywgdGhpcy5oYW5kbGVEcmFnU3RhcnQpO1xuICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdoaXR1cGRhdGUnLCB0aGlzLmhhbmRsZUhpdFVwZGF0ZSk7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdlbmQnLCB0aGlzLmhhbmRsZURyYWdFbmQpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRyYWdnaW5nLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgcXVlcnlTZWdFbChldikge1xuICAgICAgICByZXR1cm4gZWxlbWVudENsb3Nlc3QoZXYuc3ViamVjdEVsLCAnLmZjLWV2ZW50Jyk7XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcHV0ZU11dGF0aW9uKGhpdDAsIGhpdDEsIGlzRnJvbVN0YXJ0LCBpbnN0YW5jZVJhbmdlKSB7XG4gICAgbGV0IGRhdGVFbnYgPSBoaXQwLmNvbnRleHQuZGF0ZUVudjtcbiAgICBsZXQgZGF0ZTAgPSBoaXQwLmRhdGVTcGFuLnJhbmdlLnN0YXJ0O1xuICAgIGxldCBkYXRlMSA9IGhpdDEuZGF0ZVNwYW4ucmFuZ2Uuc3RhcnQ7XG4gICAgbGV0IGRlbHRhID0gZGlmZkRhdGVzKGRhdGUwLCBkYXRlMSwgZGF0ZUVudiwgaGl0MC5sYXJnZVVuaXQpO1xuICAgIGlmIChpc0Zyb21TdGFydCkge1xuICAgICAgICBpZiAoZGF0ZUVudi5hZGQoaW5zdGFuY2VSYW5nZS5zdGFydCwgZGVsdGEpIDwgaW5zdGFuY2VSYW5nZS5lbmQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0RGVsdGE6IGRlbHRhIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0ZUVudi5hZGQoaW5zdGFuY2VSYW5nZS5lbmQsIGRlbHRhKSA+IGluc3RhbmNlUmFuZ2Uuc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIHsgZW5kRGVsdGE6IGRlbHRhIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5jbGFzcyBVbnNlbGVjdEF1dG8ge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5pc1JlY2VudFBvaW50ZXJEYXRlU2VsZWN0ID0gZmFsc2U7IC8vIHdpc2ggd2UgY291bGQgdXNlIGEgc2VsZWN0b3IgdG8gZGV0ZWN0IGRhdGUgc2VsZWN0aW9uLCBidXQgdXNlcyBoaXQgc3lzdGVtXG4gICAgICAgIHRoaXMubWF0Y2hlc0NhbmNlbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1hdGNoZXNFdmVudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9uU2VsZWN0ID0gKHNlbGVjdEluZm8pID0+IHtcbiAgICAgICAgICAgIGlmIChzZWxlY3RJbmZvLmpzRXZlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzUmVjZW50UG9pbnRlckRhdGVTZWxlY3QgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uRG9jdW1lbnRQb2ludGVyRG93biA9IChwZXYpID0+IHtcbiAgICAgICAgICAgIGxldCB1bnNlbGVjdENhbmNlbCA9IHRoaXMuY29udGV4dC5vcHRpb25zLnVuc2VsZWN0Q2FuY2VsO1xuICAgICAgICAgICAgbGV0IGRvd25FbCA9IGdldEV2ZW50VGFyZ2V0VmlhUm9vdChwZXYub3JpZ0V2ZW50KTtcbiAgICAgICAgICAgIHRoaXMubWF0Y2hlc0NhbmNlbCA9ICEhZWxlbWVudENsb3Nlc3QoZG93bkVsLCB1bnNlbGVjdENhbmNlbCk7XG4gICAgICAgICAgICB0aGlzLm1hdGNoZXNFdmVudCA9ICEhZWxlbWVudENsb3Nlc3QoZG93bkVsLCBFdmVudERyYWdnaW5nLlNFTEVDVE9SKTsgLy8gaW50ZXJhY3Rpb24gc3RhcnRlZCBvbiBhbiBldmVudD9cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbkRvY3VtZW50UG9pbnRlclVwID0gKHBldikgPT4ge1xuICAgICAgICAgICAgbGV0IHsgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCB7IGRvY3VtZW50UG9pbnRlciB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCBjYWxlbmRhclN0YXRlID0gY29udGV4dC5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICAgICAgLy8gdG91Y2gtc2Nyb2xsaW5nIHNob3VsZCBuZXZlciB1bmZvY3VzIGFueSB0eXBlIG9mIHNlbGVjdGlvblxuICAgICAgICAgICAgaWYgKCFkb2N1bWVudFBvaW50ZXIud2FzVG91Y2hTY3JvbGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FsZW5kYXJTdGF0ZS5kYXRlU2VsZWN0aW9uICYmIC8vIGFuIGV4aXN0aW5nIGRhdGUgc2VsZWN0aW9uP1xuICAgICAgICAgICAgICAgICAgICAhdGhpcy5pc1JlY2VudFBvaW50ZXJEYXRlU2VsZWN0IC8vIGEgbmV3IHBvaW50ZXItaW5pdGlhdGVkIGRhdGUgc2VsZWN0aW9uIHNpbmNlIGxhc3Qgb25Eb2N1bWVudFBvaW50ZXJVcD9cbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHVuc2VsZWN0QXV0byA9IGNvbnRleHQub3B0aW9ucy51bnNlbGVjdEF1dG87XG4gICAgICAgICAgICAgICAgICAgIGlmICh1bnNlbGVjdEF1dG8gJiYgKCF1bnNlbGVjdEF1dG8gfHwgIXRoaXMubWF0Y2hlc0NhbmNlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuY2FsZW5kYXJBcGkudW5zZWxlY3QocGV2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2FsZW5kYXJTdGF0ZS5ldmVudFNlbGVjdGlvbiAmJiAvLyBhbiBleGlzdGluZyBldmVudCBzZWxlY3RlZD9cbiAgICAgICAgICAgICAgICAgICAgIXRoaXMubWF0Y2hlc0V2ZW50IC8vIGludGVyYWN0aW9uIERJRE4nVCBzdGFydCBvbiBhbiBldmVudFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1VOU0VMRUNUX0VWRU5UJyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmlzUmVjZW50UG9pbnRlckRhdGVTZWxlY3QgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGRvY3VtZW50UG9pbnRlciA9IHRoaXMuZG9jdW1lbnRQb2ludGVyID0gbmV3IFBvaW50ZXJEcmFnZ2luZyhkb2N1bWVudCk7XG4gICAgICAgIGRvY3VtZW50UG9pbnRlci5zaG91bGRJZ25vcmVNb3ZlID0gdHJ1ZTtcbiAgICAgICAgZG9jdW1lbnRQb2ludGVyLnNob3VsZFdhdGNoU2Nyb2xsID0gZmFsc2U7XG4gICAgICAgIGRvY3VtZW50UG9pbnRlci5lbWl0dGVyLm9uKCdwb2ludGVyZG93bicsIHRoaXMub25Eb2N1bWVudFBvaW50ZXJEb3duKTtcbiAgICAgICAgZG9jdW1lbnRQb2ludGVyLmVtaXR0ZXIub24oJ3BvaW50ZXJ1cCcsIHRoaXMub25Eb2N1bWVudFBvaW50ZXJVcCk7XG4gICAgICAgIC8qXG4gICAgICAgIFRPRE86IGJldHRlciB3YXkgdG8ga25vdyBhYm91dCB3aGV0aGVyIHRoZXJlIHdhcyBhIHNlbGVjdGlvbiB3aXRoIHRoZSBwb2ludGVyXG4gICAgICAgICovXG4gICAgICAgIGNvbnRleHQuZW1pdHRlci5vbignc2VsZWN0JywgdGhpcy5vblNlbGVjdCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5lbWl0dGVyLm9mZignc2VsZWN0JywgdGhpcy5vblNlbGVjdCk7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRQb2ludGVyLmRlc3Ryb3koKTtcbiAgICB9XG59XG5cbmNvbnN0IE9QVElPTl9SRUZJTkVSUyA9IHtcbiAgICBmaXhlZE1pcnJvclBhcmVudDogaWRlbnRpdHksXG59O1xuY29uc3QgTElTVEVORVJfUkVGSU5FUlMgPSB7XG4gICAgZGF0ZUNsaWNrOiBpZGVudGl0eSxcbiAgICBldmVudERyYWdTdGFydDogaWRlbnRpdHksXG4gICAgZXZlbnREcmFnU3RvcDogaWRlbnRpdHksXG4gICAgZXZlbnREcm9wOiBpZGVudGl0eSxcbiAgICBldmVudFJlc2l6ZVN0YXJ0OiBpZGVudGl0eSxcbiAgICBldmVudFJlc2l6ZVN0b3A6IGlkZW50aXR5LFxuICAgIGV2ZW50UmVzaXplOiBpZGVudGl0eSxcbiAgICBkcm9wOiBpZGVudGl0eSxcbiAgICBldmVudFJlY2VpdmU6IGlkZW50aXR5LFxuICAgIGV2ZW50TGVhdmU6IGlkZW50aXR5LFxufTtcblxuLypcbkdpdmVuIGFuIGFscmVhZHkgaW5zdGFudGlhdGVkIGRyYWdnYWJsZSBvYmplY3QgZm9yIG9uZS1vci1tb3JlIGVsZW1lbnRzLFxuSW50ZXJwcmV0cyBhbnkgZHJhZ2dpbmcgYXMgYW4gYXR0ZW1wdCB0byBkcmFnIGFuIGV2ZW50cyB0aGF0IGxpdmVzIG91dHNpZGVcbm9mIGEgY2FsZW5kYXIgb250byBhIGNhbGVuZGFyLlxuKi9cbmNsYXNzIEV4dGVybmFsRWxlbWVudERyYWdnaW5nIHtcbiAgICBjb25zdHJ1Y3RvcihkcmFnZ2luZywgc3VwcGxpZWREcmFnTWV0YSkge1xuICAgICAgICB0aGlzLnJlY2VpdmluZ0NvbnRleHQgPSBudWxsO1xuICAgICAgICB0aGlzLmRyb3BwYWJsZUV2ZW50ID0gbnVsbDsgLy8gd2lsbCBleGlzdCBmb3IgYWxsIGRyYWdzLCBldmVuIGlmIGNyZWF0ZTpmYWxzZVxuICAgICAgICB0aGlzLnN1cHBsaWVkRHJhZ01ldGEgPSBudWxsO1xuICAgICAgICB0aGlzLmRyYWdNZXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYW5kbGVEcmFnU3RhcnQgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ01ldGEgPSB0aGlzLmJ1aWxkRHJhZ01ldGEoZXYuc3ViamVjdEVsKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVIaXRVcGRhdGUgPSAoaGl0LCBpc0ZpbmFsLCBldikgPT4ge1xuICAgICAgICAgICAgbGV0IHsgZHJhZ2dpbmcgfSA9IHRoaXMuaGl0RHJhZ2dpbmc7XG4gICAgICAgICAgICBsZXQgcmVjZWl2aW5nQ29udGV4dCA9IG51bGw7XG4gICAgICAgICAgICBsZXQgZHJvcHBhYmxlRXZlbnQgPSBudWxsO1xuICAgICAgICAgICAgbGV0IGlzSW52YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGludGVyYWN0aW9uID0ge1xuICAgICAgICAgICAgICAgIGFmZmVjdGVkRXZlbnRzOiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSxcbiAgICAgICAgICAgICAgICBtdXRhdGVkRXZlbnRzOiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSxcbiAgICAgICAgICAgICAgICBpc0V2ZW50OiB0aGlzLmRyYWdNZXRhLmNyZWF0ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoaGl0KSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dCA9IGhpdC5jb250ZXh0O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhbkRyb3BFbE9uQ2FsZW5kYXIoZXYuc3ViamVjdEVsLCByZWNlaXZpbmdDb250ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICBkcm9wcGFibGVFdmVudCA9IGNvbXB1dGVFdmVudEZvckRhdGVTcGFuKGhpdC5kYXRlU3BhbiwgdGhpcy5kcmFnTWV0YSwgcmVjZWl2aW5nQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMgPSBldmVudFR1cGxlVG9TdG9yZShkcm9wcGFibGVFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlzSW52YWxpZCA9ICFpc0ludGVyYWN0aW9uVmFsaWQoaW50ZXJhY3Rpb24sIGhpdC5kYXRlUHJvZmlsZSwgcmVjZWl2aW5nQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0ludmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMgPSBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyb3BwYWJsZUV2ZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGlzcGxheURyYWcocmVjZWl2aW5nQ29udGV4dCwgaW50ZXJhY3Rpb24pO1xuICAgICAgICAgICAgLy8gc2hvdyBtaXJyb3IgaWYgbm8gYWxyZWFkeS1yZW5kZXJlZCBtaXJyb3IgZWxlbWVudCBPUiBpZiB3ZSBhcmUgc2h1dHRpbmcgZG93biB0aGUgbWlycm9yICg/KVxuICAgICAgICAgICAgLy8gVE9ETzogd2lzaCB3ZSBjb3VsZCBzb21laG93IHdhaXQgZm9yIGRpc3BhdGNoIHRvIGd1YXJhbnRlZSByZW5kZXJcbiAgICAgICAgICAgIGRyYWdnaW5nLnNldE1pcnJvcklzVmlzaWJsZShpc0ZpbmFsIHx8ICFkcm9wcGFibGVFdmVudCB8fCAhZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmZjLWV2ZW50LW1pcnJvcicpKTtcbiAgICAgICAgICAgIGlmICghaXNJbnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgZW5hYmxlQ3Vyc29yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaXNhYmxlQ3Vyc29yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzRmluYWwpIHtcbiAgICAgICAgICAgICAgICBkcmFnZ2luZy5zZXRNaXJyb3JOZWVkc1JldmVydCghZHJvcHBhYmxlRXZlbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVjZWl2aW5nQ29udGV4dCA9IHJlY2VpdmluZ0NvbnRleHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5kcm9wcGFibGVFdmVudCA9IGRyb3BwYWJsZUV2ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZURyYWdFbmQgPSAocGV2KSA9PiB7XG4gICAgICAgICAgICBsZXQgeyByZWNlaXZpbmdDb250ZXh0LCBkcm9wcGFibGVFdmVudCB9ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuY2xlYXJEcmFnKCk7XG4gICAgICAgICAgICBpZiAocmVjZWl2aW5nQ29udGV4dCAmJiBkcm9wcGFibGVFdmVudCkge1xuICAgICAgICAgICAgICAgIGxldCBmaW5hbEhpdCA9IHRoaXMuaGl0RHJhZ2dpbmcuZmluYWxIaXQ7XG4gICAgICAgICAgICAgICAgbGV0IGZpbmFsVmlldyA9IGZpbmFsSGl0LmNvbnRleHQudmlld0FwaTtcbiAgICAgICAgICAgICAgICBsZXQgZHJhZ01ldGEgPSB0aGlzLmRyYWdNZXRhO1xuICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdkcm9wJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBidWlsZERhdGVQb2ludEFwaVdpdGhDb250ZXh0KGZpbmFsSGl0LmRhdGVTcGFuLCByZWNlaXZpbmdDb250ZXh0KSksIHsgZHJhZ2dlZEVsOiBwZXYuc3ViamVjdEVsLCBqc0V2ZW50OiBwZXYub3JpZ0V2ZW50LCB2aWV3OiBmaW5hbFZpZXcgfSkpO1xuICAgICAgICAgICAgICAgIGlmIChkcmFnTWV0YS5jcmVhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFkZGluZ0V2ZW50cyA9IGV2ZW50VHVwbGVUb1N0b3JlKGRyb3BwYWJsZUV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTUVSR0VfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IGFkZGluZ0V2ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwZXYuaXNUb3VjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1NFTEVDVF9FVkVOVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRJbnN0YW5jZUlkOiBkcm9wcGFibGVFdmVudC5pbnN0YW5jZS5pbnN0YW5jZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gc2lnbmFsIHRoYXQgYW4gZXh0ZXJuYWwgZXZlbnQgbGFuZGVkXG4gICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudFJlY2VpdmUnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudDogbmV3IEV2ZW50SW1wbChyZWNlaXZpbmdDb250ZXh0LCBkcm9wcGFibGVFdmVudC5kZWYsIGRyb3BwYWJsZUV2ZW50Lmluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0ZWRFdmVudHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJ0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnUkVNT1ZFX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IGFkZGluZ0V2ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnZ2VkRWw6IHBldi5zdWJqZWN0RWwsXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3OiBmaW5hbFZpZXcsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVjZWl2aW5nQ29udGV4dCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmRyb3BwYWJsZUV2ZW50ID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGhpdERyYWdnaW5nID0gdGhpcy5oaXREcmFnZ2luZyA9IG5ldyBIaXREcmFnZ2luZyhkcmFnZ2luZywgaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlKTtcbiAgICAgICAgaGl0RHJhZ2dpbmcucmVxdWlyZUluaXRpYWwgPSBmYWxzZTsgLy8gd2lsbCBzdGFydCBvdXRzaWRlIG9mIGEgY29tcG9uZW50XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdzdGFydCcsIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0KTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignaGl0dXBkYXRlJywgdGhpcy5oYW5kbGVIaXRVcGRhdGUpO1xuICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdkcmFnZW5kJywgdGhpcy5oYW5kbGVEcmFnRW5kKTtcbiAgICAgICAgdGhpcy5zdXBwbGllZERyYWdNZXRhID0gc3VwcGxpZWREcmFnTWV0YTtcbiAgICB9XG4gICAgYnVpbGREcmFnTWV0YShzdWJqZWN0RWwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnN1cHBsaWVkRHJhZ01ldGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VEcmFnTWV0YSh0aGlzLnN1cHBsaWVkRHJhZ01ldGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5zdXBwbGllZERyYWdNZXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VEcmFnTWV0YSh0aGlzLnN1cHBsaWVkRHJhZ01ldGEoc3ViamVjdEVsKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldERyYWdNZXRhRnJvbUVsKHN1YmplY3RFbCk7XG4gICAgfVxuICAgIGRpc3BsYXlEcmFnKG5leHRDb250ZXh0LCBzdGF0ZSkge1xuICAgICAgICBsZXQgcHJldkNvbnRleHQgPSB0aGlzLnJlY2VpdmluZ0NvbnRleHQ7XG4gICAgICAgIGlmIChwcmV2Q29udGV4dCAmJiBwcmV2Q29udGV4dCAhPT0gbmV4dENvbnRleHQpIHtcbiAgICAgICAgICAgIHByZXZDb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1VOU0VUX0VWRU5UX0RSQUcnIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0Q29udGV4dCkge1xuICAgICAgICAgICAgbmV4dENvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnU0VUX0VWRU5UX0RSQUcnLCBzdGF0ZSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGVhckRyYWcoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlY2VpdmluZ0NvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMucmVjZWl2aW5nQ29udGV4dC5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFVF9FVkVOVF9EUkFHJyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYW5Ecm9wRWxPbkNhbGVuZGFyKGVsLCByZWNlaXZpbmdDb250ZXh0KSB7XG4gICAgICAgIGxldCBkcm9wQWNjZXB0ID0gcmVjZWl2aW5nQ29udGV4dC5vcHRpb25zLmRyb3BBY2NlcHQ7XG4gICAgICAgIGlmICh0eXBlb2YgZHJvcEFjY2VwdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIGRyb3BBY2NlcHQuY2FsbChyZWNlaXZpbmdDb250ZXh0LmNhbGVuZGFyQXBpLCBlbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkcm9wQWNjZXB0ID09PSAnc3RyaW5nJyAmJiBkcm9wQWNjZXB0KSB7XG4gICAgICAgICAgICByZXR1cm4gQm9vbGVhbihlbGVtZW50TWF0Y2hlcyhlbCwgZHJvcEFjY2VwdCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbi8vIFV0aWxzIGZvciBjb21wdXRpbmcgZXZlbnQgc3RvcmUgZnJvbSB0aGUgRHJhZ01ldGFcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGNvbXB1dGVFdmVudEZvckRhdGVTcGFuKGRhdGVTcGFuLCBkcmFnTWV0YSwgY29udGV4dCkge1xuICAgIGxldCBkZWZQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIGRyYWdNZXRhLmxlZnRvdmVyUHJvcHMpO1xuICAgIGZvciAobGV0IHRyYW5zZm9ybSBvZiBjb250ZXh0LnBsdWdpbkhvb2tzLmV4dGVybmFsRGVmVHJhbnNmb3Jtcykge1xuICAgICAgICBPYmplY3QuYXNzaWduKGRlZlByb3BzLCB0cmFuc2Zvcm0oZGF0ZVNwYW4sIGRyYWdNZXRhKSk7XG4gICAgfVxuICAgIGxldCB7IHJlZmluZWQsIGV4dHJhIH0gPSByZWZpbmVFdmVudERlZihkZWZQcm9wcywgY29udGV4dCk7XG4gICAgbGV0IGRlZiA9IHBhcnNlRXZlbnREZWYocmVmaW5lZCwgZXh0cmEsIGRyYWdNZXRhLnNvdXJjZUlkLCBkYXRlU3Bhbi5hbGxEYXksIGNvbnRleHQub3B0aW9ucy5mb3JjZUV2ZW50RHVyYXRpb24gfHwgQm9vbGVhbihkcmFnTWV0YS5kdXJhdGlvbiksIC8vIGhhc0VuZFxuICAgIGNvbnRleHQpO1xuICAgIGxldCBzdGFydCA9IGRhdGVTcGFuLnJhbmdlLnN0YXJ0O1xuICAgIC8vIG9ubHkgcmVseSBvbiB0aW1lIGluZm8gaWYgZHJvcCB6b25lIGlzIGFsbC1kYXksXG4gICAgLy8gb3RoZXJ3aXNlLCB3ZSBhbHJlYWR5IGtub3cgdGhlIHRpbWVcbiAgICBpZiAoZGF0ZVNwYW4uYWxsRGF5ICYmIGRyYWdNZXRhLnN0YXJ0VGltZSkge1xuICAgICAgICBzdGFydCA9IGNvbnRleHQuZGF0ZUVudi5hZGQoc3RhcnQsIGRyYWdNZXRhLnN0YXJ0VGltZSk7XG4gICAgfVxuICAgIGxldCBlbmQgPSBkcmFnTWV0YS5kdXJhdGlvbiA/XG4gICAgICAgIGNvbnRleHQuZGF0ZUVudi5hZGQoc3RhcnQsIGRyYWdNZXRhLmR1cmF0aW9uKSA6XG4gICAgICAgIGdldERlZmF1bHRFdmVudEVuZChkYXRlU3Bhbi5hbGxEYXksIHN0YXJ0LCBjb250ZXh0KTtcbiAgICBsZXQgaW5zdGFuY2UgPSBjcmVhdGVFdmVudEluc3RhbmNlKGRlZi5kZWZJZCwgeyBzdGFydCwgZW5kIH0pO1xuICAgIHJldHVybiB7IGRlZiwgaW5zdGFuY2UgfTtcbn1cbi8vIFV0aWxzIGZvciBleHRyYWN0aW5nIGRhdGEgZnJvbSBlbGVtZW50XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBnZXREcmFnTWV0YUZyb21FbChlbCkge1xuICAgIGxldCBzdHIgPSBnZXRFbWJlZGRlZEVsRGF0YShlbCwgJ2V2ZW50Jyk7XG4gICAgbGV0IG9iaiA9IHN0ciA/XG4gICAgICAgIEpTT04ucGFyc2Uoc3RyKSA6XG4gICAgICAgIHsgY3JlYXRlOiBmYWxzZSB9OyAvLyBpZiBubyBlbWJlZGRlZCBkYXRhLCBhc3N1bWUgbm8gZXZlbnQgY3JlYXRpb25cbiAgICByZXR1cm4gcGFyc2VEcmFnTWV0YShvYmopO1xufVxuY29uZmlnLmRhdGFBdHRyUHJlZml4ID0gJyc7XG5mdW5jdGlvbiBnZXRFbWJlZGRlZEVsRGF0YShlbCwgbmFtZSkge1xuICAgIGxldCBwcmVmaXggPSBjb25maWcuZGF0YUF0dHJQcmVmaXg7XG4gICAgbGV0IHByZWZpeGVkTmFtZSA9IChwcmVmaXggPyBwcmVmaXggKyAnLScgOiAnJykgKyBuYW1lO1xuICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtJyArIHByZWZpeGVkTmFtZSkgfHwgJyc7XG59XG5cbi8qXG5NYWtlcyBhbiBlbGVtZW50ICh0aGF0IGlzICpleHRlcm5hbCogdG8gYW55IGNhbGVuZGFyKSBkcmFnZ2FibGUuXG5DYW4gcGFzcyBpbiBkYXRhIHRoYXQgZGV0ZXJtaW5lcyBob3cgYW4gZXZlbnQgd2lsbCBiZSBjcmVhdGVkIHdoZW4gZHJvcHBlZCBvbnRvIGEgY2FsZW5kYXIuXG5MZXZlcmFnZXMgRnVsbENhbGVuZGFyJ3MgaW50ZXJuYWwgZHJhZy1uLWRyb3AgZnVuY3Rpb25hbGl0eSBXSVRIT1VUIGEgdGhpcmQtcGFydHkgZHJhZyBzeXN0ZW0uXG4qL1xuY2xhc3MgRXh0ZXJuYWxEcmFnZ2FibGUge1xuICAgIGNvbnN0cnVjdG9yKGVsLCBzZXR0aW5ncyA9IHt9KSB7XG4gICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlckRvd24gPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGxldCB7IGRyYWdnaW5nIH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IHsgbWluRGlzdGFuY2UsIGxvbmdQcmVzc0RlbGF5IH0gPSB0aGlzLnNldHRpbmdzO1xuICAgICAgICAgICAgZHJhZ2dpbmcubWluRGlzdGFuY2UgPVxuICAgICAgICAgICAgICAgIG1pbkRpc3RhbmNlICE9IG51bGwgP1xuICAgICAgICAgICAgICAgICAgICBtaW5EaXN0YW5jZSA6XG4gICAgICAgICAgICAgICAgICAgIChldi5pc1RvdWNoID8gMCA6IEJBU0VfT1BUSU9OX0RFRkFVTFRTLmV2ZW50RHJhZ01pbkRpc3RhbmNlKTtcbiAgICAgICAgICAgIGRyYWdnaW5nLmRlbGF5ID1cbiAgICAgICAgICAgICAgICBldi5pc1RvdWNoID8gLy8gVE9ETzogZXZlbnR1YWxseSByZWFkIGV2ZW50TG9uZ1ByZXNzRGVsYXkgaW5zdGVhZCB2dnZcbiAgICAgICAgICAgICAgICAgICAgKGxvbmdQcmVzc0RlbGF5ICE9IG51bGwgPyBsb25nUHJlc3NEZWxheSA6IEJBU0VfT1BUSU9OX0RFRkFVTFRTLmxvbmdQcmVzc0RlbGF5KSA6XG4gICAgICAgICAgICAgICAgICAgIDA7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0ID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXYuaXNUb3VjaCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcuZGVsYXkgJiZcbiAgICAgICAgICAgICAgICBldi5zdWJqZWN0RWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdmYy1ldmVudCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZy5taXJyb3IuZ2V0TWlycm9yRWwoKS5jbGFzc0xpc3QuYWRkKCdmYy1ldmVudC1zZWxlY3RlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgICAgIGxldCBkcmFnZ2luZyA9IHRoaXMuZHJhZ2dpbmcgPSBuZXcgRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZyhlbCk7XG4gICAgICAgIGRyYWdnaW5nLnRvdWNoU2Nyb2xsQWxsb3dlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoc2V0dGluZ3MuaXRlbVNlbGVjdG9yICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRyYWdnaW5nLnBvaW50ZXIuc2VsZWN0b3IgPSBzZXR0aW5ncy5pdGVtU2VsZWN0b3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldHRpbmdzLmFwcGVuZFRvICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRyYWdnaW5nLm1pcnJvci5wYXJlbnROb2RlID0gc2V0dGluZ3MuYXBwZW5kVG87IC8vIFRPRE86IHdyaXRlIHRlc3RzXG4gICAgICAgIH1cbiAgICAgICAgZHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCB0aGlzLmhhbmRsZVBvaW50ZXJEb3duKTtcbiAgICAgICAgZHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ3N0YXJ0JywgdGhpcy5oYW5kbGVEcmFnU3RhcnQpO1xuICAgICAgICBuZXcgRXh0ZXJuYWxFbGVtZW50RHJhZ2dpbmcoZHJhZ2dpbmcsIHNldHRpbmdzLmV2ZW50RGF0YSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcuZGVzdHJveSgpO1xuICAgIH1cbn1cblxuLypcbkRldGVjdHMgd2hlbiBhICpUSElSRC1QQVJUWSogZHJhZy1uLWRyb3Agc3lzdGVtIGludGVyYWN0cyB3aXRoIGVsZW1lbnRzLlxuVGhlIHRoaXJkLXBhcnR5IHN5c3RlbSBpcyByZXNwb25zaWJsZSBmb3IgZHJhd2luZyB0aGUgdmlzdWFscyBlZmZlY3RzIG9mIHRoZSBkcmFnLlxuVGhpcyBjbGFzcyBzaW1wbHkgbW9uaXRvcnMgZm9yIHBvaW50ZXIgbW92ZW1lbnRzIGFuZCBmaXJlcyBldmVudHMuXG5JdCBhbHNvIGhhcyB0aGUgYWJpbGl0eSB0byBoaWRlIHRoZSBtb3ZpbmcgZWxlbWVudCAodGhlIFwibWlycm9yXCIpIGR1cmluZyB0aGUgZHJhZy5cbiovXG5jbGFzcyBJbmZlcnJlZEVsZW1lbnREcmFnZ2luZyBleHRlbmRzIEVsZW1lbnREcmFnZ2luZyB7XG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyRWwpIHtcbiAgICAgICAgc3VwZXIoY29udGFpbmVyRWwpO1xuICAgICAgICB0aGlzLnNob3VsZElnbm9yZU1vdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5taXJyb3JTZWxlY3RvciA9ICcnO1xuICAgICAgICB0aGlzLmN1cnJlbnRNaXJyb3JFbCA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlckRvd24gPSAoZXYpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVyZG93bicsIGV2KTtcbiAgICAgICAgICAgIGlmICghdGhpcy5zaG91bGRJZ25vcmVNb3ZlKSB7XG4gICAgICAgICAgICAgICAgLy8gZmlyZSBkcmFnc3RhcnQgcmlnaHQgYXdheS4gZG9lcyBub3Qgc3VwcG9ydCBkZWxheSBvciBtaW4tZGlzdGFuY2VcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcignZHJhZ3N0YXJ0JywgZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJNb3ZlID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2hvdWxkSWdub3JlTW92ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdkcmFnbW92ZScsIGV2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyVXAgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVydXAnLCBldik7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2hvdWxkSWdub3JlTW92ZSkge1xuICAgICAgICAgICAgICAgIC8vIGZpcmUgZHJhZ2VuZCByaWdodCBhd2F5LiBkb2VzIG5vdCBzdXBwb3J0IGEgcmV2ZXJ0IGFuaW1hdGlvblxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdkcmFnZW5kJywgZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsZXQgcG9pbnRlciA9IHRoaXMucG9pbnRlciA9IG5ldyBQb2ludGVyRHJhZ2dpbmcoY29udGFpbmVyRWwpO1xuICAgICAgICBwb2ludGVyLmVtaXR0ZXIub24oJ3BvaW50ZXJkb3duJywgdGhpcy5oYW5kbGVQb2ludGVyRG93bik7XG4gICAgICAgIHBvaW50ZXIuZW1pdHRlci5vbigncG9pbnRlcm1vdmUnLCB0aGlzLmhhbmRsZVBvaW50ZXJNb3ZlKTtcbiAgICAgICAgcG9pbnRlci5lbWl0dGVyLm9uKCdwb2ludGVydXAnLCB0aGlzLmhhbmRsZVBvaW50ZXJVcCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMucG9pbnRlci5kZXN0cm95KCk7XG4gICAgfVxuICAgIHNldElnbm9yZU1vdmUoYm9vbCkge1xuICAgICAgICB0aGlzLnNob3VsZElnbm9yZU1vdmUgPSBib29sO1xuICAgIH1cbiAgICBzZXRNaXJyb3JJc1Zpc2libGUoYm9vbCkge1xuICAgICAgICBpZiAoYm9vbCkge1xuICAgICAgICAgICAgLy8gcmVzdG9yZSBhIHByZXZpb3VzbHkgaGlkZGVuIGVsZW1lbnQuXG4gICAgICAgICAgICAvLyB1c2UgdGhlIHJlZmVyZW5jZSBpbiBjYXNlIHRoZSBzZWxlY3RvciBjbGFzcyBoYXMgYWxyZWFkeSBiZWVuIHJlbW92ZWQuXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50TWlycm9yRWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRNaXJyb3JFbC5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50TWlycm9yRWwgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG1pcnJvckVsID0gdGhpcy5taXJyb3JTZWxlY3RvclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IHNvbWVob3cgcXVlcnkgRnVsbENhbGVuZGFycyBXSVRISU4gc2hhZG93LXJvb3RzXG4gICAgICAgICAgICAgICAgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRoaXMubWlycm9yU2VsZWN0b3IpXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgaWYgKG1pcnJvckVsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50TWlycm9yRWwgPSBtaXJyb3JFbDtcbiAgICAgICAgICAgICAgICBtaXJyb3JFbC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qXG5CcmlkZ2VzIHRoaXJkLXBhcnR5IGRyYWctbi1kcm9wIHN5c3RlbXMgd2l0aCBGdWxsQ2FsZW5kYXIuXG5NdXN0IGJlIGluc3RhbnRpYXRlZCBhbmQgZGVzdHJveWVkIGJ5IGNhbGxlci5cbiovXG5jbGFzcyBUaGlyZFBhcnR5RHJhZ2dhYmxlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXJPclNldHRpbmdzLCBzZXR0aW5ncykge1xuICAgICAgICBsZXQgY29udGFpbmVyRWwgPSBkb2N1bWVudDtcbiAgICAgICAgaWYgKFxuICAgICAgICAvLyB3aXNoIHdlIGNvdWxkIGp1c3QgdGVzdCBpbnN0YW5jZW9mIEV2ZW50VGFyZ2V0LCBidXQgZG9lc24ndCB3b3JrIGluIElFMTFcbiAgICAgICAgY29udGFpbmVyT3JTZXR0aW5ncyA9PT0gZG9jdW1lbnQgfHxcbiAgICAgICAgICAgIGNvbnRhaW5lck9yU2V0dGluZ3MgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgICAgICBjb250YWluZXJFbCA9IGNvbnRhaW5lck9yU2V0dGluZ3M7XG4gICAgICAgICAgICBzZXR0aW5ncyA9IHNldHRpbmdzIHx8IHt9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0dGluZ3MgPSAoY29udGFpbmVyT3JTZXR0aW5ncyB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRyYWdnaW5nID0gdGhpcy5kcmFnZ2luZyA9IG5ldyBJbmZlcnJlZEVsZW1lbnREcmFnZ2luZyhjb250YWluZXJFbCk7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MuaXRlbVNlbGVjdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZHJhZ2dpbmcucG9pbnRlci5zZWxlY3RvciA9IHNldHRpbmdzLml0ZW1TZWxlY3RvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250YWluZXJFbCA9PT0gZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIGRyYWdnaW5nLnBvaW50ZXIuc2VsZWN0b3IgPSAnW2RhdGEtZXZlbnRdJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLm1pcnJvclNlbGVjdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZHJhZ2dpbmcubWlycm9yU2VsZWN0b3IgPSBzZXR0aW5ncy5taXJyb3JTZWxlY3RvcjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZXh0ZXJuYWxEcmFnZ2luZyA9IG5ldyBFeHRlcm5hbEVsZW1lbnREcmFnZ2luZyhkcmFnZ2luZywgc2V0dGluZ3MuZXZlbnREYXRhKTtcbiAgICAgICAgLy8gVGhlIGhpdC1kZXRlY3Rpb24gc3lzdGVtIHJlcXVpcmVzIHRoYXQgdGhlIGRuZC1taXJyb3ItZWxlbWVudCBiZSBwb2ludGVyLWV2ZW50czpub25lLFxuICAgICAgICAvLyBidXQgdGhpcyBjYW4ndCBiZSBndWFyYW50ZWVkIGZvciB0aGlyZC1wYXJ0eSBkcmFnZ2FibGVzLCBzbyBkaXNhYmxlXG4gICAgICAgIGV4dGVybmFsRHJhZ2dpbmcuaGl0RHJhZ2dpbmcuZGlzYWJsZVBvaW50Q2hlY2sgPSB0cnVlO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRyYWdnaW5nLmRlc3Ryb3koKTtcbiAgICB9XG59XG5cbnZhciBpbmRleCA9IGNyZWF0ZVBsdWdpbih7XG4gICAgbmFtZTogJ0BmdWxsY2FsZW5kYXIvaW50ZXJhY3Rpb24nLFxuICAgIGNvbXBvbmVudEludGVyYWN0aW9uczogW0RhdGVDbGlja2luZywgRGF0ZVNlbGVjdGluZywgRXZlbnREcmFnZ2luZywgRXZlbnRSZXNpemluZ10sXG4gICAgY2FsZW5kYXJJbnRlcmFjdGlvbnM6IFtVbnNlbGVjdEF1dG9dLFxuICAgIGVsZW1lbnREcmFnZ2luZ0ltcGw6IEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcsXG4gICAgb3B0aW9uUmVmaW5lcnM6IE9QVElPTl9SRUZJTkVSUyxcbiAgICBsaXN0ZW5lclJlZmluZXJzOiBMSVNURU5FUl9SRUZJTkVSUyxcbn0pO1xuXG5leHBvcnQgeyBFeHRlcm5hbERyYWdnYWJsZSBhcyBEcmFnZ2FibGUsIFRoaXJkUGFydHlEcmFnZ2FibGUsIGluZGV4IGFzIGRlZmF1bHQgfTtcbiIsICJpbXBvcnQgeyBKc29uUmVxdWVzdEVycm9yLCBjcmVhdGVQbHVnaW4gfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvcmUvaW5kZXguanMnO1xuaW1wb3J0IHsgcmVxdWVzdEpzb24sIGFkZERheXMsIGlkZW50aXR5IH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb3JlL2ludGVybmFsLmpzJztcblxuLy8gVE9ETzogZXhwb3NlIHNvbWVob3dcbmNvbnN0IEFQSV9CQVNFID0gJ2h0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2NhbGVuZGFyL3YzL2NhbGVuZGFycyc7XG5jb25zdCBldmVudFNvdXJjZURlZiA9IHtcbiAgICBwYXJzZU1ldGEocmVmaW5lZCkge1xuICAgICAgICBsZXQgeyBnb29nbGVDYWxlbmRhcklkIH0gPSByZWZpbmVkO1xuICAgICAgICBpZiAoIWdvb2dsZUNhbGVuZGFySWQgJiYgcmVmaW5lZC51cmwpIHtcbiAgICAgICAgICAgIGdvb2dsZUNhbGVuZGFySWQgPSBwYXJzZUdvb2dsZUNhbGVuZGFySWQocmVmaW5lZC51cmwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnb29nbGVDYWxlbmRhcklkKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGdvb2dsZUNhbGVuZGFySWQsXG4gICAgICAgICAgICAgICAgZ29vZ2xlQ2FsZW5kYXJBcGlLZXk6IHJlZmluZWQuZ29vZ2xlQ2FsZW5kYXJBcGlLZXksXG4gICAgICAgICAgICAgICAgZ29vZ2xlQ2FsZW5kYXJBcGlCYXNlOiByZWZpbmVkLmdvb2dsZUNhbGVuZGFyQXBpQmFzZSxcbiAgICAgICAgICAgICAgICBleHRyYVBhcmFtczogcmVmaW5lZC5leHRyYVBhcmFtcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBmZXRjaChhcmcsIHN1Y2Nlc3NDYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xuICAgICAgICBsZXQgeyBkYXRlRW52LCBvcHRpb25zIH0gPSBhcmcuY29udGV4dDtcbiAgICAgICAgbGV0IG1ldGEgPSBhcmcuZXZlbnRTb3VyY2UubWV0YTtcbiAgICAgICAgbGV0IGFwaUtleSA9IG1ldGEuZ29vZ2xlQ2FsZW5kYXJBcGlLZXkgfHwgb3B0aW9ucy5nb29nbGVDYWxlbmRhckFwaUtleTtcbiAgICAgICAgaWYgKCFhcGlLZXkpIHtcbiAgICAgICAgICAgIGVycm9yQ2FsbGJhY2sobmV3IEVycm9yKCdTcGVjaWZ5IGEgZ29vZ2xlQ2FsZW5kYXJBcGlLZXkuIFNlZSBodHRwczovL2Z1bGxjYWxlbmRhci5pby9kb2NzL2dvb2dsZS1jYWxlbmRhcicpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCB1cmwgPSBidWlsZFVybChtZXRhKTtcbiAgICAgICAgICAgIC8vIFRPRE86IG1ha2UgRFJZIHdpdGgganNvbi1mZWVkLWV2ZW50LXNvdXJjZVxuICAgICAgICAgICAgbGV0IHsgZXh0cmFQYXJhbXMgfSA9IG1ldGE7XG4gICAgICAgICAgICBsZXQgZXh0cmFQYXJhbXNPYmogPSB0eXBlb2YgZXh0cmFQYXJhbXMgPT09ICdmdW5jdGlvbicgPyBleHRyYVBhcmFtcygpIDogZXh0cmFQYXJhbXM7XG4gICAgICAgICAgICBsZXQgcmVxdWVzdFBhcmFtcyA9IGJ1aWxkUmVxdWVzdFBhcmFtcyhhcmcucmFuZ2UsIGFwaUtleSwgZXh0cmFQYXJhbXNPYmosIGRhdGVFbnYpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RKc29uKCdHRVQnLCB1cmwsIHJlcXVlc3RQYXJhbXMpLnRoZW4oKFtib2R5LCByZXNwb25zZV0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYm9keS5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBlcnJvckNhbGxiYWNrKG5ldyBKc29uUmVxdWVzdEVycm9yKCdHb29nbGUgQ2FsZW5kYXIgQVBJOiAnICsgYm9keS5lcnJvci5tZXNzYWdlLCByZXNwb25zZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc0NhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhd0V2ZW50czogZ2NhbEl0ZW1zVG9SYXdFdmVudERlZnMoYm9keS5pdGVtcywgcmVxdWVzdFBhcmFtcy50aW1lWm9uZSksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZXJyb3JDYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmZ1bmN0aW9uIHBhcnNlR29vZ2xlQ2FsZW5kYXJJZCh1cmwpIHtcbiAgICBsZXQgbWF0Y2g7XG4gICAgLy8gZGV0ZWN0IGlmIHRoZSBJRCB3YXMgc3BlY2lmaWVkIGFzIGEgc2luZ2xlIHN0cmluZy5cbiAgICAvLyB3aWxsIG1hdGNoIGNhbGVuZGFycyBsaWtlIFwiYXNkZjEyMzRAY2FsZW5kYXIuZ29vZ2xlLmNvbVwiIGluIGFkZGl0aW9uIHRvIHBlcnNvbiBlbWFpbCBjYWxlbmRhcnMuXG4gICAgaWYgKC9eW14vXStAKFteLy5dK1xcLikqKGdvb2dsZXxnb29nbGVtYWlsfGdtYWlsKVxcLmNvbSQvLnRlc3QodXJsKSkge1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cbiAgICBpZiAoKG1hdGNoID0gL15odHRwczpcXC9cXC93d3cuZ29vZ2xlYXBpcy5jb21cXC9jYWxlbmRhclxcL3YzXFwvY2FsZW5kYXJzXFwvKFteL10qKS8uZXhlYyh1cmwpKSB8fFxuICAgICAgICAobWF0Y2ggPSAvXmh0dHBzPzpcXC9cXC93d3cuZ29vZ2xlLmNvbVxcL2NhbGVuZGFyXFwvZmVlZHNcXC8oW14vXSopLy5leGVjKHVybCkpKSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQobWF0Y2hbMV0pO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGJ1aWxkVXJsKG1ldGEpIHtcbiAgICBsZXQgYXBpQmFzZSA9IG1ldGEuZ29vZ2xlQ2FsZW5kYXJBcGlCYXNlO1xuICAgIGlmICghYXBpQmFzZSkge1xuICAgICAgICBhcGlCYXNlID0gQVBJX0JBU0U7XG4gICAgfVxuICAgIHJldHVybiBhcGlCYXNlICsgJy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KG1ldGEuZ29vZ2xlQ2FsZW5kYXJJZCkgKyAnL2V2ZW50cyc7XG59XG5mdW5jdGlvbiBidWlsZFJlcXVlc3RQYXJhbXMocmFuZ2UsIGFwaUtleSwgZXh0cmFQYXJhbXMsIGRhdGVFbnYpIHtcbiAgICBsZXQgcGFyYW1zO1xuICAgIGxldCBzdGFydFN0cjtcbiAgICBsZXQgZW5kU3RyO1xuICAgIGlmIChkYXRlRW52LmNhbkNvbXB1dGVPZmZzZXQpIHtcbiAgICAgICAgLy8gc3RyaW5ncyB3aWxsIG5hdHVyYWxseSBoYXZlIG9mZnNldHMsIHdoaWNoIEdDYWwgbmVlZHNcbiAgICAgICAgc3RhcnRTdHIgPSBkYXRlRW52LmZvcm1hdElzbyhyYW5nZS5zdGFydCk7XG4gICAgICAgIGVuZFN0ciA9IGRhdGVFbnYuZm9ybWF0SXNvKHJhbmdlLmVuZCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyB3aGVuIHRpbWV6b25lIGlzbid0IGtub3duLCB3ZSBkb24ndCBrbm93IHdoYXQgdGhlIFVUQyBvZmZzZXQgc2hvdWxkIGJlLCBzbyBhc2sgZm9yICsvLSAxIGRheVxuICAgICAgICAvLyBmcm9tIHRoZSBVVEMgZGF5LXN0YXJ0IHRvIGd1YXJhbnRlZSB3ZSdyZSBnZXR0aW5nIGFsbCB0aGUgZXZlbnRzXG4gICAgICAgIC8vIChzdGFydC9lbmQgd2lsbCBiZSBVVEMtY29lcmNlZCBkYXRlcywgc28gdG9JU09TdHJpbmcgaXMgb2theSlcbiAgICAgICAgc3RhcnRTdHIgPSBhZGREYXlzKHJhbmdlLnN0YXJ0LCAtMSkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgZW5kU3RyID0gYWRkRGF5cyhyYW5nZS5lbmQsIDEpLnRvSVNPU3RyaW5nKCk7XG4gICAgfVxuICAgIHBhcmFtcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKGV4dHJhUGFyYW1zIHx8IHt9KSksIHsga2V5OiBhcGlLZXksIHRpbWVNaW46IHN0YXJ0U3RyLCB0aW1lTWF4OiBlbmRTdHIsIHNpbmdsZUV2ZW50czogdHJ1ZSwgbWF4UmVzdWx0czogOTk5OSB9KTtcbiAgICBpZiAoZGF0ZUVudi50aW1lWm9uZSAhPT0gJ2xvY2FsJykge1xuICAgICAgICBwYXJhbXMudGltZVpvbmUgPSBkYXRlRW52LnRpbWVab25lO1xuICAgIH1cbiAgICByZXR1cm4gcGFyYW1zO1xufVxuZnVuY3Rpb24gZ2NhbEl0ZW1zVG9SYXdFdmVudERlZnMoaXRlbXMsIGdjYWxUaW1lem9uZSkge1xuICAgIHJldHVybiBpdGVtcy5tYXAoKGl0ZW0pID0+IGdjYWxJdGVtVG9SYXdFdmVudERlZihpdGVtLCBnY2FsVGltZXpvbmUpKTtcbn1cbmZ1bmN0aW9uIGdjYWxJdGVtVG9SYXdFdmVudERlZihpdGVtLCBnY2FsVGltZXpvbmUpIHtcbiAgICBsZXQgdXJsID0gaXRlbS5odG1sTGluayB8fCBudWxsO1xuICAgIC8vIG1ha2UgdGhlIFVSTHMgZm9yIGVhY2ggZXZlbnQgc2hvdyB0aW1lcyBpbiB0aGUgY29ycmVjdCB0aW1lem9uZVxuICAgIGlmICh1cmwgJiYgZ2NhbFRpbWV6b25lKSB7XG4gICAgICAgIHVybCA9IGluamVjdFFzQ29tcG9uZW50KHVybCwgJ2N0ej0nICsgZ2NhbFRpbWV6b25lKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IGl0ZW0uaWQsXG4gICAgICAgIHRpdGxlOiBpdGVtLnN1bW1hcnksXG4gICAgICAgIHN0YXJ0OiBpdGVtLnN0YXJ0LmRhdGVUaW1lIHx8IGl0ZW0uc3RhcnQuZGF0ZSxcbiAgICAgICAgZW5kOiBpdGVtLmVuZC5kYXRlVGltZSB8fCBpdGVtLmVuZC5kYXRlLFxuICAgICAgICB1cmwsXG4gICAgICAgIGxvY2F0aW9uOiBpdGVtLmxvY2F0aW9uLFxuICAgICAgICBkZXNjcmlwdGlvbjogaXRlbS5kZXNjcmlwdGlvbixcbiAgICAgICAgYXR0YWNobWVudHM6IGl0ZW0uYXR0YWNobWVudHMgfHwgW10sXG4gICAgICAgIGV4dGVuZGVkUHJvcHM6IChpdGVtLmV4dGVuZGVkUHJvcGVydGllcyB8fCB7fSkuc2hhcmVkIHx8IHt9LFxuICAgIH07XG59XG4vLyBJbmplY3RzIGEgc3RyaW5nIGxpa2UgXCJhcmc9dmFsdWVcIiBpbnRvIHRoZSBxdWVyeXN0cmluZyBvZiBhIFVSTFxuLy8gVE9ETzogbW92ZSB0byBhIGdlbmVyYWwgdXRpbCBmaWxlP1xuZnVuY3Rpb24gaW5qZWN0UXNDb21wb25lbnQodXJsLCBjb21wb25lbnQpIHtcbiAgICAvLyBpbmplY3QgaXQgYWZ0ZXIgdGhlIHF1ZXJ5c3RyaW5nIGJ1dCBiZWZvcmUgdGhlIGZyYWdtZW50XG4gICAgcmV0dXJuIHVybC5yZXBsYWNlKC8oXFw/Lio/KT8oI3wkKS8sICh3aG9sZSwgcXMsIGhhc2gpID0+IChxcyA/IHFzICsgJyYnIDogJz8nKSArIGNvbXBvbmVudCArIGhhc2gpO1xufVxuXG5jb25zdCBPUFRJT05fUkVGSU5FUlMgPSB7XG4gICAgZ29vZ2xlQ2FsZW5kYXJBcGlLZXk6IFN0cmluZyxcbn07XG5cbmNvbnN0IEVWRU5UX1NPVVJDRV9SRUZJTkVSUyA9IHtcbiAgICBnb29nbGVDYWxlbmRhckFwaUtleTogU3RyaW5nLFxuICAgIGdvb2dsZUNhbGVuZGFySWQ6IFN0cmluZyxcbiAgICBnb29nbGVDYWxlbmRhckFwaUJhc2U6IFN0cmluZyxcbiAgICBleHRyYVBhcmFtczogaWRlbnRpdHksXG59O1xuXG52YXIgaW5kZXggPSBjcmVhdGVQbHVnaW4oe1xuICAgIG5hbWU6ICdAZnVsbGNhbGVuZGFyL2dvb2dsZS1jYWxlbmRhcicsXG4gICAgZXZlbnRTb3VyY2VEZWZzOiBbZXZlbnRTb3VyY2VEZWZdLFxuICAgIG9wdGlvblJlZmluZXJzOiBPUFRJT05fUkVGSU5FUlMsXG4gICAgZXZlbnRTb3VyY2VSZWZpbmVyczogRVZFTlRfU09VUkNFX1JFRklORVJTLFxufSk7XG5cbmV4cG9ydCB7IGluZGV4IGFzIGRlZmF1bHQgfTtcbiIsICJpbXBvcnQgeyBjcmVhdGVQbHVnaW4gfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvcmUvaW5kZXguanMnO1xuaW1wb3J0IHsgYWRkRGF5cyB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29yZS9pbnRlcm5hbC5qcyc7XG5pbXBvcnQgKiBhcyBJQ0FMIGZyb20gJ2ljYWwuanMnO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuY2xhc3MgSWNhbEV4cGFuZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHRoaXMubWF4SXRlcmF0aW9ucyA9IG9wdHMubWF4SXRlcmF0aW9ucyAhPSBudWxsID8gb3B0cy5tYXhJdGVyYXRpb25zIDogMTAwMDtcbiAgICAgICAgdGhpcy5za2lwSW52YWxpZERhdGVzID0gb3B0cy5za2lwSW52YWxpZERhdGVzICE9IG51bGwgPyBvcHRzLnNraXBJbnZhbGlkRGF0ZXMgOiBmYWxzZTtcbiAgICAgICAgdGhpcy5qQ2FsRGF0YSA9IElDQUwucGFyc2Uob3B0cy5pY3MpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IG5ldyBJQ0FMLkNvbXBvbmVudCh0aGlzLmpDYWxEYXRhKTtcbiAgICAgICAgdGhpcy5ldmVudHMgPSB0aGlzLmNvbXBvbmVudC5nZXRBbGxTdWJjb21wb25lbnRzKCd2ZXZlbnQnKS5tYXAodmV2ZW50ID0+IG5ldyBJQ0FMLkV2ZW50KHZldmVudCkpO1xuICAgICAgICBpZiAodGhpcy5za2lwSW52YWxpZERhdGVzKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50cyA9IHRoaXMuZXZlbnRzLmZpbHRlcigoZXZ0KSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZXZ0LnN0YXJ0RGF0ZS50b0pTRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBldnQuZW5kRGF0ZS50b0pTRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAvLyBza2lwcGluZyBldmVudHMgd2l0aCBpbnZhbGlkIHRpbWVcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJldHdlZW4oYWZ0ZXIsIGJlZm9yZSkge1xuICAgICAgICBmdW5jdGlvbiBpc0V2ZW50V2l0aGluUmFuZ2Uoc3RhcnRUaW1lLCBlbmRUaW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gKCFhZnRlciB8fCBlbmRUaW1lID49IGFmdGVyLmdldFRpbWUoKSkgJiZcbiAgICAgICAgICAgICAgICAoIWJlZm9yZSB8fCBzdGFydFRpbWUgPD0gYmVmb3JlLmdldFRpbWUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0VGltZXMoZXZlbnRPck9jY3VycmVuY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IGV2ZW50T3JPY2N1cnJlbmNlLnN0YXJ0RGF0ZS50b0pTRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIGxldCBlbmRUaW1lID0gZXZlbnRPck9jY3VycmVuY2UuZW5kRGF0ZS50b0pTRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIC8vIElmIGl0IGlzIGFuIGFsbCBkYXkgZXZlbnQsIHRoZSBlbmQgZGF0ZSBpcyBzZXQgdG8gMDA6MDAgb2YgdGhlIG5leHQgZGF5XG4gICAgICAgICAgICAvLyBTbyB3ZSBuZWVkIHRvIG1ha2UgaXQgYmUgMjM6NTk6NTkgdG8gY29tcGFyZSBjb3JyZWN0bHkgd2l0aCB0aGUgZ2l2ZW4gcmFuZ2VcbiAgICAgICAgICAgIGlmIChldmVudE9yT2NjdXJyZW5jZS5lbmREYXRlLmlzRGF0ZSAmJiAoZW5kVGltZSA+IHN0YXJ0VGltZSkpIHtcbiAgICAgICAgICAgICAgICBlbmRUaW1lIC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBzdGFydFRpbWUsIGVuZFRpbWUgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleGNlcHRpb25zID0gW107XG4gICAgICAgIHRoaXMuZXZlbnRzLmZvckVhY2goKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuaXNSZWN1cnJlbmNlRXhjZXB0aW9uKCkpXG4gICAgICAgICAgICAgICAgZXhjZXB0aW9ucy5wdXNoKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJldCA9IHtcbiAgICAgICAgICAgIGV2ZW50czogW10sXG4gICAgICAgICAgICBvY2N1cnJlbmNlczogW10sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZXZlbnRzLmZpbHRlcihlID0+ICFlLmlzUmVjdXJyZW5jZUV4Y2VwdGlvbigpKS5mb3JFYWNoKChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXhkYXRlcyA9IFtdO1xuICAgICAgICAgICAgZXZlbnQuY29tcG9uZW50LmdldEFsbFByb3BlcnRpZXMoJ2V4ZGF0ZScpLmZvckVhY2goKGV4ZGF0ZVByb3ApID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBleGRhdGUgPSBleGRhdGVQcm9wLmdldEZpcnN0VmFsdWUoKTtcbiAgICAgICAgICAgICAgICBleGRhdGVzLnB1c2goZXhkYXRlLnRvSlNEYXRlKCkuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gUmVjdXJyaW5nIGV2ZW50IGlzIGhhbmRsZWQgZGlmZmVyZW50bHlcbiAgICAgICAgICAgIGlmIChldmVudC5pc1JlY3VycmluZygpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlcmF0b3IgPSBldmVudC5pdGVyYXRvcigpO1xuICAgICAgICAgICAgICAgIGxldCBuZXh0O1xuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9jY3VycmVuY2UgPSBldmVudC5nZXRPY2N1cnJlbmNlRGV0YWlscyhuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc3RhcnRUaW1lLCBlbmRUaW1lIH0gPSBnZXRUaW1lcyhvY2N1cnJlbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzT2NjdXJyZW5jZUV4Y2x1ZGVkID0gZXhkYXRlcy5pbmRleE9mKHN0YXJ0VGltZSkgIT09IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBjaGVjayB0aGF0IHdpdGhpbiBzYW1lIGRheT9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4Y2VwdGlvbiA9IGV4Y2VwdGlvbnMuZmluZChleCA9PiBleC51aWQgPT09IGV2ZW50LnVpZCAmJiBleC5yZWN1cnJlbmNlSWQudG9KU0RhdGUoKS5nZXRUaW1lKCkgPT09IG9jY3VycmVuY2Uuc3RhcnREYXRlLnRvSlNEYXRlKCkuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgcGFzc2VkIHRoZSBtYXggZGF0ZSwgc3RvcFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJlZm9yZSAmJiBzdGFydFRpbWUgPiBiZWZvcmUuZ2V0VGltZSgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB3ZSBhcmUgd2l0aGluIG91ciByYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRXZlbnRXaXRoaW5SYW5nZShzdGFydFRpbWUsIGVuZFRpbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQuZXZlbnRzLnB1c2goZXhjZXB0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzT2NjdXJyZW5jZUV4Y2x1ZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldC5vY2N1cnJlbmNlcy5wdXNoKG9jY3VycmVuY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKG5leHQgJiYgKCF0aGlzLm1heEl0ZXJhdGlvbnMgfHwgaSA8IHRoaXMubWF4SXRlcmF0aW9ucykpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vbi1yZWN1cnJpbmcgZXZlbnQ6XG4gICAgICAgICAgICBjb25zdCB7IHN0YXJ0VGltZSwgZW5kVGltZSB9ID0gZ2V0VGltZXMoZXZlbnQpO1xuICAgICAgICAgICAgaWYgKGlzRXZlbnRXaXRoaW5SYW5nZShzdGFydFRpbWUsIGVuZFRpbWUpKVxuICAgICAgICAgICAgICAgIHJldC5ldmVudHMucHVzaChldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBiZWZvcmUoYmVmb3JlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJldHdlZW4odW5kZWZpbmVkLCBiZWZvcmUpO1xuICAgIH1cbiAgICBhZnRlcihhZnRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5iZXR3ZWVuKGFmdGVyKTtcbiAgICB9XG4gICAgYWxsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZXR3ZWVuKCk7XG4gICAgfVxufVxuXG5jb25zdCBldmVudFNvdXJjZURlZiA9IHtcbiAgICBwYXJzZU1ldGEocmVmaW5lZCkge1xuICAgICAgICBpZiAocmVmaW5lZC51cmwgJiYgcmVmaW5lZC5mb3JtYXQgPT09ICdpY3MnKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogcmVmaW5lZC51cmwsXG4gICAgICAgICAgICAgICAgZm9ybWF0OiAnaWNzJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBmZXRjaChhcmcsIHN1Y2Nlc3NDYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xuICAgICAgICBsZXQgbWV0YSA9IGFyZy5ldmVudFNvdXJjZS5tZXRhO1xuICAgICAgICBsZXQgeyBpbnRlcm5hbFN0YXRlIH0gPSBtZXRhO1xuICAgICAgICAvKlxuICAgICAgICBOT1RFOiBpc1JlZmV0Y2ggaXMgYSBIQUNLLiB3ZSB3b3VsZCBkbyB0aGUgcmVjdXJyaW5nLWV4cGFuZGluZyBpbiBhIHNlcGFyYXRlIHBsdWdpbiBob29rLFxuICAgICAgICBidXQgd2UgY291bGRuJ3QgbGV2ZXJhZ2UgYnVpbHQtaW4gYWxsRGF5LWd1ZXNzaW5nLCBhbW9uZyBvdGhlciB0aGluZ3MuXG4gICAgICAgICovXG4gICAgICAgIGlmICghaW50ZXJuYWxTdGF0ZSB8fCBhcmcuaXNSZWZldGNoKSB7XG4gICAgICAgICAgICBpbnRlcm5hbFN0YXRlID0gbWV0YS5pbnRlcm5hbFN0YXRlID0ge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlOiBudWxsLFxuICAgICAgICAgICAgICAgIGlDYWxFeHBhbmRlclByb21pc2U6IGZldGNoKG1ldGEudXJsLCB7IG1ldGhvZDogJ0dFVCcgfSkudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKS50aGVuKChpY3NUZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFN0YXRlLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEljYWxFeHBhbmRlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNzOiBpY3NUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNraXBJbnZhbGlkRGF0ZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGludGVybmFsU3RhdGUuaUNhbEV4cGFuZGVyUHJvbWlzZS50aGVuKChpQ2FsRXhwYW5kZXIpID0+IHtcbiAgICAgICAgICAgIHN1Y2Nlc3NDYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgcmF3RXZlbnRzOiBleHBhbmRJQ2FsRXZlbnRzKGlDYWxFeHBhbmRlciwgYXJnLnJhbmdlKSxcbiAgICAgICAgICAgICAgICByZXNwb25zZTogaW50ZXJuYWxTdGF0ZS5yZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBlcnJvckNhbGxiYWNrKTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGV4cGFuZElDYWxFdmVudHMoaUNhbEV4cGFuZGVyLCByYW5nZSkge1xuICAgIC8vIGV4cGFuZCB0aGUgcmFuZ2UuIGJlY2F1c2Ugb3VyIGByYW5nZWAgaXMgdGltZVpvbmUtYWdub3N0aWMgVVRDXG4gICAgLy8gb3IgbWF5YmUgYmVjYXVzZSBpY2FsLmpzIGFsd2F5cyBwcm9kdWNlcyBkYXRlcyBpbiBsb2NhbCB0aW1lPyBpIGZvcmdldFxuICAgIGxldCByYW5nZVN0YXJ0ID0gYWRkRGF5cyhyYW5nZS5zdGFydCwgLTEpO1xuICAgIGxldCByYW5nZUVuZCA9IGFkZERheXMocmFuZ2UuZW5kLCAxKTtcbiAgICBsZXQgaUNhbFJlcyA9IGlDYWxFeHBhbmRlci5iZXR3ZWVuKHJhbmdlU3RhcnQsIHJhbmdlRW5kKTsgLy8gZW5kIGluY2x1c2l2ZS4gd2lsbCBnaXZlIGV4dHJhIHJlc3VsdHNcbiAgICBsZXQgZXhwYW5kZWQgPSBbXTtcbiAgICAvLyBUT0RPOiBpbnN0ZWFkIG9mIHVzaW5nIHN0YXJ0RGF0ZS9lbmREYXRlLnRvU3RyaW5nIHRvIGNvbW11bmljYXRlIGFsbERheSxcbiAgICAvLyB3ZSBjYW4gcXVlcnkgc3RhcnREYXRlL2VuZERhdGUuaXNEYXRlLiBNb3JlIGVmZmljaWVudCB0byBhdm9pZCBmb3JtYXR0aW5nL3JlcGFyc2luZy5cbiAgICAvLyBzaW5nbGUgZXZlbnRzXG4gICAgZm9yIChsZXQgaUNhbEV2ZW50IG9mIGlDYWxSZXMuZXZlbnRzKSB7XG4gICAgICAgIGV4cGFuZGVkLnB1c2goT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBidWlsZE5vbkRhdGVQcm9wcyhpQ2FsRXZlbnQpKSwgeyBzdGFydDogaUNhbEV2ZW50LnN0YXJ0RGF0ZS50b1N0cmluZygpLCBlbmQ6IChzcGVjaWZpZXNFbmQoaUNhbEV2ZW50KSAmJiBpQ2FsRXZlbnQuZW5kRGF0ZSlcbiAgICAgICAgICAgICAgICA/IGlDYWxFdmVudC5lbmREYXRlLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICA6IG51bGwgfSkpO1xuICAgIH1cbiAgICAvLyByZWN1cnJpbmcgZXZlbnQgaW5zdGFuY2VzXG4gICAgZm9yIChsZXQgaUNhbE9jY3VyZW5jZSBvZiBpQ2FsUmVzLm9jY3VycmVuY2VzKSB7XG4gICAgICAgIGxldCBpQ2FsRXZlbnQgPSBpQ2FsT2NjdXJlbmNlLml0ZW07XG4gICAgICAgIGV4cGFuZGVkLnB1c2goT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBidWlsZE5vbkRhdGVQcm9wcyhpQ2FsRXZlbnQpKSwgeyBzdGFydDogaUNhbE9jY3VyZW5jZS5zdGFydERhdGUudG9TdHJpbmcoKSwgZW5kOiAoc3BlY2lmaWVzRW5kKGlDYWxFdmVudCkgJiYgaUNhbE9jY3VyZW5jZS5lbmREYXRlKVxuICAgICAgICAgICAgICAgID8gaUNhbE9jY3VyZW5jZS5lbmREYXRlLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICA6IG51bGwgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gZXhwYW5kZWQ7XG59XG5mdW5jdGlvbiBidWlsZE5vbkRhdGVQcm9wcyhpQ2FsRXZlbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0aXRsZTogaUNhbEV2ZW50LnN1bW1hcnksXG4gICAgICAgIHVybDogZXh0cmFjdEV2ZW50VXJsKGlDYWxFdmVudCksXG4gICAgICAgIGV4dGVuZGVkUHJvcHM6IHtcbiAgICAgICAgICAgIGxvY2F0aW9uOiBpQ2FsRXZlbnQubG9jYXRpb24sXG4gICAgICAgICAgICBvcmdhbml6ZXI6IGlDYWxFdmVudC5vcmdhbml6ZXIsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogaUNhbEV2ZW50LmRlc2NyaXB0aW9uLFxuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBleHRyYWN0RXZlbnRVcmwoaUNhbEV2ZW50KSB7XG4gICAgbGV0IHVybFByb3AgPSBpQ2FsRXZlbnQuY29tcG9uZW50LmdldEZpcnN0UHJvcGVydHkoJ3VybCcpO1xuICAgIHJldHVybiB1cmxQcm9wID8gdXJsUHJvcC5nZXRGaXJzdFZhbHVlKCkgOiAnJztcbn1cbmZ1bmN0aW9uIHNwZWNpZmllc0VuZChpQ2FsRXZlbnQpIHtcbiAgICByZXR1cm4gQm9vbGVhbihpQ2FsRXZlbnQuY29tcG9uZW50LmdldEZpcnN0UHJvcGVydHkoJ2R0ZW5kJykpIHx8XG4gICAgICAgIEJvb2xlYW4oaUNhbEV2ZW50LmNvbXBvbmVudC5nZXRGaXJzdFByb3BlcnR5KCdkdXJhdGlvbicpKTtcbn1cblxudmFyIGluZGV4ID0gY3JlYXRlUGx1Z2luKHtcbiAgICBuYW1lOiAnQGZ1bGxjYWxlbmRhci9pY2FsZW5kYXInLFxuICAgIGV2ZW50U291cmNlRGVmczogW2V2ZW50U291cmNlRGVmXSxcbn0pO1xuXG5leHBvcnQgeyBpbmRleCBhcyBkZWZhdWx0IH07XG4iLCAiLyoqXG4gKiBIYW5kbGVzIHJlbmRlcmluZyB0aGUgY2FsZW5kYXIgZ2l2ZW4gYSBjb250YWluZXIgZWxlbWVudCwgZXZlbnRTb3VyY2VzLCBhbmQgaW50ZXJhY3Rpb24gY2FsbGJhY2tzLlxuICovXG5pbXBvcnQge1xuICAgIENhbGVuZGFyLFxuICAgIEV2ZW50QXBpLFxuICAgIEV2ZW50Q2xpY2tBcmcsXG4gICAgRXZlbnRIb3ZlcmluZ0FyZyxcbiAgICBFdmVudFNvdXJjZUlucHV0LFxufSBmcm9tIFwiQGZ1bGxjYWxlbmRhci9jb3JlXCI7XG5pbXBvcnQgZGF5R3JpZFBsdWdpbiBmcm9tIFwiQGZ1bGxjYWxlbmRhci9kYXlncmlkXCI7XG4vLyBpbXBvcnQgbXVsdGlNb250aFBsdWdpbiBmcm9tICdAZnVsbGNhbGVuZGFyL211bHRpbW9udGgnXG5pbXBvcnQgdGltZUdyaWRQbHVnaW4gZnJvbSBcIkBmdWxsY2FsZW5kYXIvdGltZWdyaWRcIjtcbmltcG9ydCBycnVsZVBsdWdpbiBmcm9tIFwiQGZ1bGxjYWxlbmRhci9ycnVsZVwiO1xuaW1wb3J0IGxpc3RQbHVnaW4gZnJvbSBcIkBmdWxsY2FsZW5kYXIvbGlzdFwiO1xuaW1wb3J0IGludGVyYWN0aW9uUGx1Z2luIGZyb20gXCJAZnVsbGNhbGVuZGFyL2ludGVyYWN0aW9uXCI7XG5pbXBvcnQgZ29vZ2xlQ2FsZW5kYXJQbHVnaW4gZnJvbSBcIkBmdWxsY2FsZW5kYXIvZ29vZ2xlLWNhbGVuZGFyXCI7XG5pbXBvcnQgaUNhbGVuZGFyUGx1Z2luIGZyb20gXCJAZnVsbGNhbGVuZGFyL2ljYWxlbmRhclwiO1xuXG4vLyBUaGVyZSBpcyBhbiBpc3N1ZSB3aXRoIEZ1bGxDYWxlbmRhciBSUnVsZSBzdXBwb3J0IGFyb3VuZCBEU1QgYm91bmRhcmllcyB3aGljaCBpcyBmaXhlZCBieSB0aGlzIG1vbmtleXBhdGNoOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Z1bGxjYWxlbmRhci9mdWxsY2FsZW5kYXIvaXNzdWVzLzUyNzMjaXNzdWVjb21tZW50LTEzNjA0NTkzNDJcbnJydWxlUGx1Z2luLnJlY3VycmluZ1R5cGVzWzBdLmV4cGFuZCA9IGZ1bmN0aW9uIChlcnJkLCBmciwgZGUpIHtcbiAgICBjb25zdCBob3VycyA9IGVycmQucnJ1bGVTZXQuX2R0c3RhcnQuZ2V0SG91cnMoKTtcbiAgICByZXR1cm4gZXJyZC5ycnVsZVNldFxuICAgICAgICAuYmV0d2VlbihkZS50b0RhdGUoZnIuc3RhcnQpLCBkZS50b0RhdGUoZnIuZW5kKSwgdHJ1ZSlcbiAgICAgICAgLm1hcCgoZDogRGF0ZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKFxuICAgICAgICAgICAgICAgIERhdGUuVVRDKFxuICAgICAgICAgICAgICAgICAgICBkLmdldEZ1bGxZZWFyKCksXG4gICAgICAgICAgICAgICAgICAgIGQuZ2V0TW9udGgoKSxcbiAgICAgICAgICAgICAgICAgICAgZC5nZXREYXRlKCksXG4gICAgICAgICAgICAgICAgICAgIGhvdXJzLFxuICAgICAgICAgICAgICAgICAgICBkLmdldE1pbnV0ZXMoKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xufTtcblxuaW50ZXJmYWNlIEV4dHJhUmVuZGVyUHJvcHMge1xuICAgIGV2ZW50Q2xpY2s/OiAoaW5mbzogRXZlbnRDbGlja0FyZykgPT4gdm9pZDtcbiAgICBzZWxlY3Q/OiAoXG4gICAgICAgIHN0YXJ0RGF0ZTogRGF0ZSxcbiAgICAgICAgZW5kRGF0ZTogRGF0ZSxcbiAgICAgICAgYWxsRGF5OiBib29sZWFuLFxuICAgICAgICB2aWV3VHlwZTogc3RyaW5nXG4gICAgKSA9PiBQcm9taXNlPHZvaWQ+O1xuICAgIG1vZGlmeUV2ZW50PzogKGV2ZW50OiBFdmVudEFwaSwgb2xkRXZlbnQ6IEV2ZW50QXBpKSA9PiBQcm9taXNlPGJvb2xlYW4+O1xuICAgIGV2ZW50TW91c2VFbnRlcj86IChpbmZvOiBFdmVudEhvdmVyaW5nQXJnKSA9PiB2b2lkO1xuICAgIGZpcnN0RGF5PzogbnVtYmVyO1xuICAgIGluaXRpYWxWaWV3PzogeyBkZXNrdG9wOiBzdHJpbmc7IG1vYmlsZTogc3RyaW5nIH07XG4gICAgdGltZUZvcm1hdDI0aD86IGJvb2xlYW47XG4gICAgb3BlbkNvbnRleHRNZW51Rm9yRXZlbnQ/OiAoXG4gICAgICAgIGV2ZW50OiBFdmVudEFwaSxcbiAgICAgICAgbW91c2VFdmVudDogTW91c2VFdmVudFxuICAgICkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgICB0b2dnbGVUYXNrPzogKGV2ZW50OiBFdmVudEFwaSwgaXNDb21wbGV0ZTogYm9vbGVhbikgPT4gUHJvbWlzZTxib29sZWFuPjtcbiAgICBmb3JjZU5hcnJvdz86IGJvb2xlYW47XG4gICAgc2xvdER1cmF0aW9uOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJDYWxlbmRhcihcbiAgICBjb250YWluZXJFbDogSFRNTEVsZW1lbnQsXG4gICAgZXZlbnRTb3VyY2VzOiBFdmVudFNvdXJjZUlucHV0W10sXG4gICAgc2V0dGluZ3M/OiBFeHRyYVJlbmRlclByb3BzXG4pOiBDYWxlbmRhciB7XG4gICAgY29uc3QgaXNNb2JpbGUgPSB3aW5kb3cuaW5uZXJXaWR0aCA8IDUwMDtcbiAgICBjb25zdCBpc05hcnJvdyA9IHNldHRpbmdzPy5mb3JjZU5hcnJvdyB8fCBpc01vYmlsZTtcbiAgICBjb25zdCB7XG4gICAgICAgIGV2ZW50Q2xpY2ssXG4gICAgICAgIHNlbGVjdCxcbiAgICAgICAgbW9kaWZ5RXZlbnQsXG4gICAgICAgIGV2ZW50TW91c2VFbnRlcixcbiAgICAgICAgb3BlbkNvbnRleHRNZW51Rm9yRXZlbnQsXG4gICAgICAgIHRvZ2dsZVRhc2ssXG4gICAgfSA9IHNldHRpbmdzIHx8IHt9O1xuICAgIGNvbnN0IG1vZGlmeUV2ZW50Q2FsbGJhY2sgPVxuICAgICAgICBtb2RpZnlFdmVudCAmJlxuICAgICAgICAoYXN5bmMgKHtcbiAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgb2xkRXZlbnQsXG4gICAgICAgICAgICByZXZlcnQsXG4gICAgICAgIH06IHtcbiAgICAgICAgICAgIGV2ZW50OiBFdmVudEFwaTtcbiAgICAgICAgICAgIG9sZEV2ZW50OiBFdmVudEFwaTtcbiAgICAgICAgICAgIHJldmVydDogKCkgPT4gdm9pZDtcbiAgICAgICAgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3VjY2VzcyA9IGF3YWl0IG1vZGlmeUV2ZW50KGV2ZW50LCBvbGRFdmVudCk7XG4gICAgICAgICAgICBpZiAoIXN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICByZXZlcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICBjb25zdCBjYWwgPSBuZXcgQ2FsZW5kYXIoY29udGFpbmVyRWwsIHtcbiAgICAgICAgcGx1Z2luczogW1xuICAgICAgICAgICAgLy8gVmlldyBwbHVnaW5zXG4gICAgICAgICAgICBkYXlHcmlkUGx1Z2luLFxuICAgICAgICAgICAgdGltZUdyaWRQbHVnaW4sXG4gICAgICAgICAgICBsaXN0UGx1Z2luLFxuICAgICAgICAgICAgLy8gbXVsdGlNb250aFBsdWdpbixcbiAgICAgICAgICAgIC8vIERyYWcgKyBkcm9wIGFuZCBlZGl0aW5nXG4gICAgICAgICAgICBpbnRlcmFjdGlvblBsdWdpbixcbiAgICAgICAgICAgIC8vIFJlbW90ZSBzb3VyY2VzXG4gICAgICAgICAgICBnb29nbGVDYWxlbmRhclBsdWdpbixcbiAgICAgICAgICAgIGlDYWxlbmRhclBsdWdpbixcbiAgICAgICAgICAgIHJydWxlUGx1Z2luLFxuICAgICAgICBdLFxuICAgICAgICBnb29nbGVDYWxlbmRhckFwaUtleTogXCJBSXphU3lESWlrbEZ3SlhhTFd1VF80eTZJOVpSVlZzUHVmNHhHcmtcIixcbiAgICAgICAgaW5pdGlhbFZpZXc6XG4gICAgICAgICAgICBzZXR0aW5ncz8uaW5pdGlhbFZpZXc/Lltpc05hcnJvdyA/IFwibW9iaWxlXCIgOiBcImRlc2t0b3BcIl0gfHxcbiAgICAgICAgICAgIChpc05hcnJvdyA/IFwidGltZUdyaWQzRGF5c1wiIDogXCJ0aW1lR3JpZFdlZWtcIiksXG4gICAgICAgIG5vd0luZGljYXRvcjogdHJ1ZSxcbiAgICAgICAgc2Nyb2xsVGltZVJlc2V0OiBmYWxzZSxcbiAgICAgICAgZGF5TWF4RXZlbnRzOiB0cnVlLFxuICAgICAgICBleHBhbmRSb3dzOnRydWUsXG4gICAgICAgIHNsb3REdXJhdGlvbjogc2V0dGluZ3M/LnNsb3REdXJhdGlvbiB8fCBcIjAwOjMwOjAwXCIsXG4gICAgICAgIC8vIG11bHRpTW9udGhNYXhDb2x1bW5zOiAxLFxuXG4gICAgICAgIGhlYWRlclRvb2xiYXI6ICFpc05hcnJvd1xuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICBsZWZ0OiBcInByZXYsbmV4dCB0b2RheVwiLFxuICAgICAgICAgICAgICAgICAgY2VudGVyOiBcInRpdGxlXCIsXG4gICAgICAgICAgICAgICAgICByaWdodDogXCJ0aW1lR3JpZDVEYXlzLHRpbWVHcmlkV2VlayxsaXN0V2VlayxkYXlHcmlkTW9udGgsZGF5R3JpZFllYXJcIixcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiAhaXNNb2JpbGVcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgcmlnaHQ6IFwidG9kYXkscHJldixuZXh0XCIsXG4gICAgICAgICAgICAgICAgICBsZWZ0OiBcImRheUdyaWRNb250aCx0aW1lR3JpZDNEYXlzLGxpc3RXZWVrLGRheUdyaWRZZWFyXCIsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgIGZvb3RlclRvb2xiYXI6IGlzTW9iaWxlXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgIHJpZ2h0OiBcInRvZGF5LHByZXYsbmV4dFwiLFxuICAgICAgICAgICAgICAgICAgbGVmdDogXCJ0aW1lR3JpZDNEYXlzLGRheUdyaWRNb250aCxkYXlHcmlkWWVhcix0aW1lR3JpZFdlZWssbGlzdFdlZWtcIixcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBmYWxzZSxcblxuICAgICAgICB2aWV3czoge1xuICAgICAgICAgICAgdGltZUdyaWQzRGF5czoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidGltZUdyaWRcIixcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogeyBkYXlzOiAzIH0sXG4gICAgICAgICAgICAgICAgYnV0dG9uVGV4dDogXCIzXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGltZUdyaWQ1RGF5czoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidGltZUdyaWRcIixcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogeyBkYXlzOiA1IH0sXG4gICAgICAgICAgICAgICAgYnV0dG9uVGV4dDogXCI1XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkYXlHcmlkTW9udGg6IHtcbiAgICAgICAgICAgICAgZGF5TWF4RXZlbnRzOiBmYWxzZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkYXlHcmlkWWVhcjoge1xuICAgICAgICAgICAgICBkYXlNYXhFdmVudHM6IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgZmlyc3REYXk6IHNldHRpbmdzPy5maXJzdERheSxcbiAgICAgICAgLi4uKHNldHRpbmdzPy50aW1lRm9ybWF0MjRoICYmIHtcbiAgICAgICAgICAgIGV2ZW50VGltZUZvcm1hdDoge1xuICAgICAgICAgICAgICAgIGhvdXI6IFwibnVtZXJpY1wiLFxuICAgICAgICAgICAgICAgIG1pbnV0ZTogXCIyLWRpZ2l0XCIsXG4gICAgICAgICAgICAgICAgaG91cjEyOiBmYWxzZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzbG90TGFiZWxGb3JtYXQ6IHtcbiAgICAgICAgICAgICAgICBob3VyOiBcIm51bWVyaWNcIixcbiAgICAgICAgICAgICAgICBtaW51dGU6IFwiMi1kaWdpdFwiLFxuICAgICAgICAgICAgICAgIGhvdXIxMjogZmFsc2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KSxcbiAgICAgICAgZXZlbnRTb3VyY2VzLFxuICAgICAgICBldmVudENsaWNrLFxuXG4gICAgICAgIHNlbGVjdGFibGU6IHNlbGVjdCAmJiB0cnVlLFxuICAgICAgICBzZWxlY3RNaXJyb3I6IHNlbGVjdCAmJiB0cnVlLFxuICAgICAgICBzZWxlY3Q6XG4gICAgICAgICAgICBzZWxlY3QgJiZcbiAgICAgICAgICAgIChhc3luYyAoaW5mbykgPT4ge1xuICAgICAgICAgICAgICAgIGF3YWl0IHNlbGVjdChpbmZvLnN0YXJ0LCBpbmZvLmVuZCwgaW5mby5hbGxEYXksIGluZm8udmlldy50eXBlKTtcbiAgICAgICAgICAgICAgICBpbmZvLnZpZXcuY2FsZW5kYXIudW5zZWxlY3QoKTtcbiAgICAgICAgICAgIH0pLFxuXG4gICAgICAgIGVkaXRhYmxlOiBtb2RpZnlFdmVudCAmJiB0cnVlLFxuICAgICAgICBldmVudERyb3A6IG1vZGlmeUV2ZW50Q2FsbGJhY2ssXG4gICAgICAgIGV2ZW50UmVzaXplOiBtb2RpZnlFdmVudENhbGxiYWNrLFxuXG4gICAgICAgIGV2ZW50TW91c2VFbnRlcixcblxuICAgICAgICBldmVudERpZE1vdW50OiAoeyBldmVudCwgZWwsIHRleHRDb2xvciB9KSA9PiB7XG4gICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgKGUpID0+IHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgb3BlbkNvbnRleHRNZW51Rm9yRXZlbnQgJiYgb3BlbkNvbnRleHRNZW51Rm9yRXZlbnQoZXZlbnQsIGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodG9nZ2xlVGFzaykge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5leHRlbmRlZFByb3BzLmlzVGFzaykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGVja2JveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tib3gudHlwZSA9IFwiY2hlY2tib3hcIjtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tib3guY2hlY2tlZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5leHRlbmRlZFByb3BzLnRhc2tDb21wbGV0ZWQgIT09IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjaGVja2JveC5vbmNsaWNrID0gYXN5bmMgKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmV0ID0gYXdhaXQgdG9nZ2xlVGFzayhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlLnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50KS5jaGVja2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZS50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudCkuY2hlY2tlZCA9ICEoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkuY2hlY2tlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2UgdGhlIGNoZWNrYm94IG1vcmUgdmlzaWJsZSBhZ2FpbnN0IGRpZmZlcmVudCBjb2xvciBldmVudHMuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0Q29sb3IgPT0gXCJibGFja1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja2JveC5hZGRDbGFzcyhcIm9mYy1jaGVja2JveC1ibGFja1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrYm94LmFkZENsYXNzKFwib2ZjLWNoZWNrYm94LXdoaXRlXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrYm94LmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLmFkZENsYXNzKFwib2ZjLXRhc2stY29tcGxldGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRGVwZW5kaW5nIG9uIHRoZSB2aWV3LCB3ZSBzaG91bGQgcHV0IHRoZSBjaGVja2JveCBpbiBhIGRpZmZlcmVudCBzcG90LlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250YWluZXIgPVxuICAgICAgICAgICAgICAgICAgICAgICAgZWwucXVlcnlTZWxlY3RvcihcIi5mYy1ldmVudC10aW1lXCIpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5xdWVyeVNlbGVjdG9yKFwiLmZjLWV2ZW50LXRpdGxlXCIpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5xdWVyeVNlbGVjdG9yKFwiLmZjLWxpc3QtZXZlbnQtdGl0bGVcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyPy5hZGRDbGFzcyhcIm9mYy1oYXMtY2hlY2tib3hcIik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcj8ucHJlcGVuZChjaGVja2JveCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGxvbmdQcmVzc0RlbGF5OiAyNTAsXG4gICAgfSk7XG4gICAgY2FsLnJlbmRlcigpO1xuICAgIHJldHVybiBjYWw7XG59XG4iLCAiaW1wb3J0IE15UGx1Z2luIGZyb20gXCIuL21haW5cIlxuaW1wb3J0IHsgTm90aWNlLCBUQWJzdHJhY3RGaWxlLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiXG5pbXBvcnQgeyBJUGFnZSwgSVN1YnNjcmliZXIsIFNyYyB9IGZyb20gXCIuL3R5cGVzXCJcbmltcG9ydCB7IGlzRXF1YWxPYmogfSBmcm9tIFwiLi91dGlsXCJcbmltcG9ydCBGaWxlTWFuYWdlciBmcm9tIFwiLi9maWxlTWFuYWdlclwiXG5pbXBvcnQgeyBNU0dfUExHX05BTUUgfSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG50eXBlIElQYXRoU3Vic2NyaWJlciA9IHtcbiAgcGF0aHM6IFNyY1tdLFxuICBzdWJzY3JpYmVyOiBJU3Vic2NyaWJlclxufVxuXG50eXBlIFN1YnNjcmliZURhdGEgPSB7XG4gIHNyYzogU3JjLFxuICBwYWdlczogSVBhZ2VbXVxufVxuXG5leHBvcnQgY2xhc3MgQ2FjaGUge1xuICBwcml2YXRlIHBhcnJlbnRQb2ludGVyOiBNeVBsdWdpblxuXG4gIHByaXZhdGUgc3RvcmFnZSA9IG5ldyBNYXA8c3RyaW5nLCBJUGFnZT4oKVxuICBwcml2YXRlIHN1YnNjcmliZXJzID0gbmV3IE1hcDxOdW1iZXIsIElQYXRoU3Vic2NyaWJlcj4oKVxuXG4gIHByaXZhdGUgaW5pdFN5bmM6IFByb21pc2U8dm9pZD4gPSBuZXcgUHJvbWlzZShcbiAgICByZXNvbHZlID0+IHRoaXMuaW5pdFN5bmNSZXNvbHZlID0gcmVzb2x2ZVxuICApXG4gIHByaXZhdGUgaW5pdFN5bmNSZXNvbHZlOiAodmFsdWU6IHZvaWQgfCBQcm9taXNlTGlrZTx2b2lkPikgPT4gdm9pZFxuICBwcml2YXRlIGlzSW5pdGVkID0gZmFsc2VcblxuICBjb25zdHJ1Y3RvcihwYXJyZW50UG9pbnRlcjogTXlQbHVnaW4sIGZpbGVNYW5hZ2VyOiBGaWxlTWFuYWdlcikge1xuICAgIHRoaXMucGFycmVudFBvaW50ZXIgPSBwYXJyZW50UG9pbnRlclxuXG4gICAgdGhpcy5wYXJyZW50UG9pbnRlci5hcHAud29ya3NwYWNlLm9uTGF5b3V0UmVhZHkoKCkgPT4gdGhpcy5pbml0U3RvcmFnZSgpKVxuICB9XG5cbiAgcHVibGljIGdldFBhZ2UocGF0aDogc3RyaW5nKTogSVBhZ2V8dW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlLmdldChwYXRoKVxuICB9XG5cbiAgcHVibGljIGxvZygpIHtcbiAgICBjb25zb2xlLmxvZyhcInN0b3JhZ2VcIiwgdGhpcy5zdG9yYWdlKVxuICAgIGNvbnNvbGUubG9nKFwic3Vic2NyaWJlcnNcIiwgdGhpcy5zdWJzY3JpYmVycylcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBzdWJzY3JpYmUoaWQ6IE51bWJlciwgcGF0aHM6IFNyY1tdLCBzdWJzY3JpYmVyOiBJU3Vic2NyaWJlcik6IFByb21pc2U8U3Vic2NyaWJlRGF0YVtdPiB7XG4gICAgdGhpcy5zdWJzY3JpYmVycy5zZXQoXG4gICAgICBpZCxcbiAgICAgIHtcbiAgICAgICAgcGF0aHMsXG4gICAgICAgIHN1YnNjcmliZXJcbiAgICAgIH1cbiAgICApXG5cbiAgICBpZiAoIXRoaXMuaXNJbml0ZWQpXG4gICAgICBhd2FpdCB0aGlzLmluaXRTeW5jXG5cbiAgICBjb25zdCByZXN1bHQ6IFN1YnNjcmliZURhdGFbXSA9IFtdXG5cbiAgICAvLyBcdTA0MTRcdTA0M0JcdTA0NEYgXHUwNDNBXHUwNDMwXHUwNDM2XHUwNDM0XHUwNDNFXHUwNDMzXHUwNDNFIFx1MDQzN1x1MDQzMFx1MDQzRlx1MDQ0MFx1MDQzRVx1MDQ0OFx1MDQzNVx1MDQzRFx1MDQzRFx1MDQzRVx1MDQzM1x1MDQzRSBcdTA0M0ZcdTA0NDNcdTA0NDJcdTA0MzggXHUwNDQxXHUwNDNFXHUwNDM3XHUwNDM0XHUwNDMwXHUwNDM1XHUwNDNDIFx1MDQzRVx1MDQzMVx1MDQ0QVx1MDQzNVx1MDQzQVx1MDQ0MiBTdWJzY3JpYmVEYXRhXG4gICAgZm9yIChsZXQgcGF0aCBvZiBwYXRocykge1xuICAgICAgY29uc3QgcGFnZXM6IElQYWdlW10gPSBbXVxuXG4gICAgICAvLyBcdTA0MURcdTA0MzBcdTA0NDVcdTA0M0VcdTA0MzRcdTA0MzhcdTA0M0MgXHUwNDMyXHUwNDQxXHUwNDM1IFx1MDQ0MVx1MDQ0Mlx1MDQ0MFx1MDQzMFx1MDQzRFx1MDQzOFx1MDQ0Nlx1MDQ0QiwgXHUwNDNBXHUwNDNFXHUwNDQyXHUwNDNFXHUwNDQwXHUwNDRCXHUwNDM1IFx1MDQzRFx1MDQzMFx1MDQ0N1x1MDQzOFx1MDQzRFx1MDQzMFx1MDQ0RVx1MDQ0Mlx1MDQ0MVx1MDQ0RiBcdTA0NDEgXHUwNDREXHUwNDQyXHUwNDNFXHUwNDMzXHUwNDNFIFx1MDQzRlx1MDQ0M1x1MDQ0Mlx1MDQzOFxuICAgICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIHRoaXMuc3RvcmFnZSkge1xuICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgocGF0aC5wYXRoKSkge1xuICAgICAgICAgIHBhZ2VzLnB1c2godmFsdWUpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICBzcmM6IHBhdGgsXG4gICAgICAgIHBhZ2VzOiBwYWdlc1xuICAgICAgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBwdWJsaWMgdW5zdWJzY3JpYmUoaWQ6IE51bWJlcikge1xuICAgIHRoaXMuc3Vic2NyaWJlcnMuZGVsZXRlKGlkKVxuICB9XG5cbiAgcHVibGljIHJlbmFtZUZpbGUoZmlsZTogVEZpbGUsIG9sZFBhdGg6IHN0cmluZykge1xuICAgIGlmICghdGhpcy5pc0luaXRlZClcbiAgICAgIHJldHVyblxuXG4gICAgY29uc3Qgb2xkUGFnZSA9IHRoaXMuc3RvcmFnZS5nZXQob2xkUGF0aCkgYXMgSVBhZ2VcblxuICAgIC8vIE5PVEUgXHUwNDQyXHUwNDM4XHUwNDNGXHUwNDMwIFx1MDQ0RFx1MDQ0Mlx1MDQzRSBcdTA0NDFcdTA0NDFcdTA0NEJcdTA0M0JcdTA0M0VcdTA0NDdcdTA0M0RcdTA0NEJcdTA0MzUgXHUwNDNFXHUwNDMxXHUwNDRBXHUwNDM1XHUwNDNBXHUwNDQyXHUwNDRCXG4gICAgY29uc3QgcGFnZSA9IHsuLi5vbGRQYWdlfVxuICAgIHBhZ2UuZmlsZSA9IHsuLi5vbGRQYWdlLmZpbGV9XG4gICAgcGFnZS5maWxlLnBhdGggPSBmaWxlLnBhdGhcbiAgICBwYWdlLmZpbGUubmFtZSA9IGZpbGUuYmFzZW5hbWVcblxuICAgIHRoaXMuc3RvcmFnZS5kZWxldGUob2xkUGF0aClcbiAgICB0aGlzLnN0b3JhZ2Uuc2V0KGZpbGUucGF0aCwgcGFnZSlcblxuICAgIGZvciAobGV0IFtfLCB7cGF0aHMsIHN1YnNjcmliZXJ9XSBvZiB0aGlzLnN1YnNjcmliZXJzKSB7XG4gICAgICBmb3IgKGxldCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgICAgIGlmIChmaWxlLnBhdGguc3RhcnRzV2l0aChwYXRoLnBhdGgpICYmIG9sZFBhdGguc3RhcnRzV2l0aChwYXRoLnBhdGgpKVxuICAgICAgICAgIHN1YnNjcmliZXIucmVuYW1lRmlsZShwYWdlLCBvbGRQYWdlKVxuICAgICAgICBlbHNlIGlmIChvbGRQYXRoLnN0YXJ0c1dpdGgocGF0aC5wYXRoKSlcbiAgICAgICAgICBzdWJzY3JpYmVyLmRlbGV0ZUZpbGUob2xkUGFnZSlcbiAgICAgICAgZWxzZSBpZiAoZmlsZS5wYXRoLnN0YXJ0c1dpdGgocGF0aC5wYXRoKSlcbiAgICAgICAgICBzdWJzY3JpYmVyLmFkZEZpbGUocGFnZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgYWRkRmlsZShmaWxlOiBURmlsZSkge1xuICAgIGlmICghdGhpcy5pc0luaXRlZClcbiAgICAgIHJldHVyblxuXG4gICAgY29uc3QgcGFnZSA9IGF3YWl0IHRoaXMucGFycmVudFBvaW50ZXIuZmlsZU1hbmFnZXIuZ2V0UGFnZShmaWxlKVxuICAgIHRoaXMuc3RvcmFnZS5zZXQoZmlsZS5wYXRoLCBwYWdlKVxuXG4gICAgZm9yIChsZXQgW18sIHtwYXRocywgc3Vic2NyaWJlcn1dIG9mIHRoaXMuc3Vic2NyaWJlcnMpIHtcbiAgICAgIGZvciAobGV0IHBhdGggb2YgcGF0aHMpIHtcbiAgICAgICAgaWYgKCFmaWxlLnBhdGguc3RhcnRzV2l0aChwYXRoLnBhdGgpKVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgc3Vic2NyaWJlci5hZGRGaWxlKHBhZ2UpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGNoYW5nZUZpbGUoZmlsZTogVEZpbGUpIHtcbiAgICBpZiAoIXRoaXMuaXNJbml0ZWQpXG4gICAgICByZXR1cm5cblxuICAgIGNvbnN0IHBhZ2UgPSBhd2FpdCB0aGlzLnBhcnJlbnRQb2ludGVyLmZpbGVNYW5hZ2VyLmdldFBhZ2UoZmlsZSlcbiAgICBjb25zdCBvbGRQYWdlID0gdGhpcy5zdG9yYWdlLmdldChmaWxlLnBhdGgpIGFzIElQYWdlXG4gICAgaWYgKGlzRXF1YWxPYmoocGFnZSwgb2xkUGFnZSkpXG4gICAgICByZXR1cm5cblxuICAgIHRoaXMuc3RvcmFnZS5zZXQoZmlsZS5wYXRoLCBwYWdlKVxuXG4gICAgZm9yIChsZXQgW18sIHtwYXRocywgc3Vic2NyaWJlcn1dIG9mIHRoaXMuc3Vic2NyaWJlcnMpIHtcbiAgICAgIGZvciAobGV0IHBhdGggb2YgcGF0aHMpIHtcbiAgICAgICAgaWYgKCFmaWxlLnBhdGguc3RhcnRzV2l0aChwYXRoLnBhdGgpKVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgc3Vic2NyaWJlci5jaGFuZ2VGaWxlKHBhZ2UsIG9sZFBhZ2UpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGRlbGV0ZUZpbGUoZmlsZTogVEFic3RyYWN0RmlsZSkge1xuICAgIGlmICghdGhpcy5pc0luaXRlZClcbiAgICAgIHJldHVyblxuXG4gICAgY29uc3QgcGFnZSA9IHRoaXMuc3RvcmFnZS5nZXQoZmlsZS5wYXRoKSBhcyBJUGFnZVxuXG4gICAgdGhpcy5zdG9yYWdlLmRlbGV0ZShmaWxlLnBhdGgpXG4gICAgZm9yIChsZXQgW18sIHtwYXRocywgc3Vic2NyaWJlcn1dIG9mIHRoaXMuc3Vic2NyaWJlcnMpIHtcbiAgICAgIGZvciAobGV0IHBhdGggb2YgcGF0aHMpIHtcbiAgICAgICAgaWYgKCFmaWxlLnBhdGguc3RhcnRzV2l0aChwYXRoLnBhdGgpKVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgc3Vic2NyaWJlci5kZWxldGVGaWxlKHBhZ2UpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIHJlc2V0KCkge1xuICAgIHRoaXMuaXNJbml0ZWQgPSBmYWxzZVxuXG4gICAgdGhpcy5zdG9yYWdlLmNsZWFyKClcblxuICAgIGNvbnN0IHRtcCA9IHRoaXMuc3Vic2NyaWJlcnNcbiAgICB0aGlzLnN1YnNjcmliZXJzID0gbmV3IE1hcCgpXG4gICAgYXdhaXQgdGhpcy5pbml0U3RvcmFnZSgpXG5cbiAgICBmb3IgKGxldCBbXywge3N1YnNjcmliZXJ9XSBvZiB0bXApXG4gICAgICBzdWJzY3JpYmVyLnJlc2V0KClcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaW5pdFN0b3JhZ2UoKSB7XG4gICAgY29uc3QgdEZpbGVzID0gdGhpcy5wYXJyZW50UG9pbnRlci5hcHAudmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpXG5cbiAgICBjb25zdCBub3RpY2UgPSBuZXcgTm90aWNlKFxuICAgICAgYCR7TVNHX1BMR19OQU1FfTogdGhlcmUgYXJlICR7dEZpbGVzLmxlbmd0aH0gbm90ZXNgLFxuICAgICAgMTAwMCAqIDYwIC8vIDYwIHNlY29uZHNcbiAgICApXG5cbiAgICBmb3IgKGxldCBpIGluIHRGaWxlcykge1xuICAgICAgY29uc3QgdEZpbGUgPSB0RmlsZXNbaV1cblxuICAgICAgbm90aWNlLnNldE1lc3NhZ2UoYCR7TVNHX1BMR19OQU1FfTogKCR7aX0vJHt0RmlsZXMubGVuZ3RofSkgYWRkZWQgJHt0RmlsZS5wYXRofWApXG5cbiAgICAgIHRoaXMuc3RvcmFnZS5zZXQoXG4gICAgICAgIHRGaWxlLnBhdGgsXG4gICAgICAgIGF3YWl0IHRoaXMucGFycmVudFBvaW50ZXIuZmlsZU1hbmFnZXIuZ2V0UGFnZSh0RmlsZSlcbiAgICAgIClcbiAgICB9XG5cbiAgICBub3RpY2UuaGlkZSgpXG4gICAgbmV3IE5vdGljZShgJHtNU0dfUExHX05BTUV9OiBjYWNoZSBoYXMgYmVlbiBpbml0ZWRgKVxuXG4gICAgdGhpcy5pbml0U3luY1Jlc29sdmUoKVxuICAgIHRoaXMuaXNJbml0ZWQgPSB0cnVlXG4gIH1cbn1cbiIsICJpbXBvcnQgeyBBcHAsIE5vdGljZSwgUGx1Z2luU2V0dGluZ1RhYiwgU2V0dGluZyB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IE15UGx1Z2luIGZyb20gXCIuL21haW5cIjtcbmltcG9ydCB7IENPTE9VUl9SRVNULCBDT0xPVVJfU0xFRVAsIERFRkFVTFRfU0VUVElOR1MsIE1TR19QTEdfTkFNRSB9IGZyb20gXCIuL2NvbnN0YW50c1wiO1xuXG5leHBvcnQgY2xhc3MgTXlTZXR0aW5nVGFiIGV4dGVuZHMgUGx1Z2luU2V0dGluZ1RhYiB7XG4gIHBsdWdpbjogTXlQbHVnaW47XG5cbiAgY29uc3RydWN0b3IoYXBwOiBBcHAsIHBsdWdpbjogTXlQbHVnaW4pIHtcbiAgICBzdXBlcihhcHAsIHBsdWdpbik7XG4gICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XG4gIH1cblxuICBkaXNwbGF5KCkge1xuICAgIGxldCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xuICAgIGNvbnRhaW5lckVsLmVtcHR5KCk7XG5cbiAgICBjb25zdCBzZXR0aW5ncyA9IHRoaXMucGx1Z2luLmdldFNldHRpbmdzKClcblxuICAgIC8vIFRPRE8gXHUwNDNGXHUwNDQwXHUwNDM4IFx1MDQ0MVx1MDQzQ1x1MDQzNVx1MDQzRFx1MDQzNSBcdTA0MzJcdTA0NEJcdTA0M0FcdTA0M0JcdTA0NEVcdTA0NDdcdTA0MzBcdTA0NDJcdTA0NEMgXHUwNDMyIFx1MDQ0Mlx1MDQzNVx1MDQzQVx1MDQ0M1x1MDQ0OVx1MDQzNVx1MDQzOSBcdTA0NDFcdTA0MzVcdTA0NDFcdTA0NDFcdTA0MzhcdTA0MzggXHUwNDM4XHUwNDNEXHUwNDQxXHUwNDQyXHUwNDQwXHUwNDQzXHUwNDNDXHUwNDM1XHUwNDNEXHUwNDQyLCBcdTA0MzAgXHUwNDNEXHUwNDM1IFx1MDQzRlx1MDQ0MFx1MDQzOCBcdTA0M0ZcdTA0MzVcdTA0NDBcdTA0MzVcdTA0MzdcdTA0MzBcdTA0MzNcdTA0NDBcdTA0NDNcdTA0MzdcdTA0M0FcdTA0MzVcbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbCkuc2V0SGVhZGluZygpLnNldE5hbWUoXCJJdCdzIHJlY29tbWVuZGVkIHRvIHJlbG9hZCBPYnNpZGlhbkFwcCBhZnRlciBjaGFuZ2luZyB0aGUgc2V0dGluZ3NcIilcbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbCkuYWRkQnV0dG9uKFxuICAgICAgYnRuID0+IHtcbiAgICAgICAgYnRuLnNldEJ1dHRvblRleHQoXCJTZXQgRGVmYXVsdCBWYWx1ZXNcIilcbiAgICAgICAgLm9uQ2xpY2soXG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKERFRkFVTFRfU0VUVElOR1MpXG4gICAgICAgICAgICBuZXcgTm90aWNlKE1TR19QTEdfTkFNRSArIFwiVGhlIGRlZmF1bHQgc2V0dGluZ3MgaGFzIGJlZW4gYXBwbGllZFwiKVxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgfVxuICAgIClcblxuICAgIC8vIENhbGVuZGFyXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpLnNldEhlYWRpbmcoKVxuXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpLnNldE5hbWUoXCJDYWxlbmRhclwiKS5zZXRIZWFkaW5nKClcblxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKS5zZXROYW1lKFwiU2xvdCBkdXJhdGlvblwiKVxuICAgIC5zZXREZXNjKGBEZWZhdWx0OiAke0RFRkFVTFRfU0VUVElOR1MuY2FsZW5kYXIuc2xvdER1cmF0aW9ufWApXG4gICAgLmFkZFRleHQoXG4gICAgICBjb21wb25lbnQgPT4ge1xuICAgICAgICBjb21wb25lbnQuc2V0UGxhY2Vob2xkZXIoXCJoaDptbTpzc1wiKVxuICAgICAgICAuc2V0VmFsdWUoc2V0dGluZ3MuY2FsZW5kYXIuc2xvdER1cmF0aW9uKVxuICAgICAgICAub25DaGFuZ2UoXG4gICAgICAgICAgdmFsdWUgPT4ge1xuICAgICAgICAgICAgLy8gQ29tbWVudGV0IGNhdXNlIEl0IGNyZWF0ZSBhIGxvdCBvZiBOb3RpY2VcbiAgICAgICAgICAgIC8vIGNvbnN0IHJlZ0V4cCA9IC9eXFxkezJ9OlxcZHsyfTpcXGR7Mn0kL1xuXG4gICAgICAgICAgICAvLyAvLyBOT1RFIFx1MDQzRlx1MDQ0MFx1MDQzRVx1MDQzMlx1MDQzNVx1MDQ0MFx1MDQ0Rlx1MDQzNVx1MDQzQyBcdTA0NDFcdTA0M0VcdTA0M0VcdTA0NDJcdTA0MzJcdTA0MzVcdTA0NDJcdTA0NDFcdTA0NDJcdTA0MzJcdTA0MzhcdTA0MzUgXHUwNDQ0XHUwNDNFXHUwNDQwXHUwNDNDXHUwNDMwXHUwNDQyXHUwNDQzXG4gICAgICAgICAgICAvLyBpZiAoIXJlZ0V4cC50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgLy8gICB2YWx1ZSA9IERFRkFVTFRfU0VUVElOR1MuY2FsZW5kYXIuc2xvdER1cmF0aW9uXG4gICAgICAgICAgICAvLyAgIG5ldyBOb3RpY2UoTVNHX1BMR19OQU1FICsgXCJpbnZhbGlkIFNsb3REdXJhdGlvbiBmb3JtYXRcIilcbiAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgc2V0dGluZ3MuY2FsZW5kYXIuc2xvdER1cmF0aW9uID0gdmFsdWVcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncyhzZXR0aW5ncylcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIH1cbiAgICApXG5cbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbCkuc2V0TmFtZShcIkNvbG91cnNcIikuc2V0SGVhZGluZygpXG4gICAgZm9yIChsZXQga2V5IG9mIE9iamVjdC5rZXlzKHNldHRpbmdzLmNhbGVuZGFyLmNvbG91cnMpIGFzIChrZXlvZiB0eXBlb2Ygc2V0dGluZ3MuY2FsZW5kYXIuY29sb3VycylbXSApIHtcbiAgICAgIHRoaXMuYWRkQ29sb3VyU2V0dGluZyhcbiAgICAgICAgY29udGFpbmVyRWwsIGtleSxcbiAgICAgICAgREVGQVVMVF9TRVRUSU5HUy5jYWxlbmRhci5jb2xvdXJzW2tleV0sXG4gICAgICAgIHNldHRpbmdzLmNhbGVuZGFyLmNvbG91cnNba2V5XSxcbiAgICAgICAgKHZhbDpzdHJpbmcpID0+IHtcbiAgICAgICAgICBzZXR0aW5ncy5jYWxlbmRhci5jb2xvdXJzW2tleV0gPSB2YWxcbiAgICAgICAgICB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3Moc2V0dGluZ3MpXG4gICAgICAgIH1cbiAgICAgIClcbiAgICB9XG5cbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbCkuc2V0TmFtZShcIlJlc3RUaW1lXCIpLnNldEhlYWRpbmcoKVxuICAgIGZvciAobGV0IGluZGV4IGluIHNldHRpbmdzLmNhbGVuZGFyLnJlc3RUaW1lKSB7XG5cbiAgICAgIGNvbnN0IGVsID0gc2V0dGluZ3MuY2FsZW5kYXIucmVzdFRpbWVbaW5kZXhdXG5cbiAgICAgIGxldCBuYW1lID0gXCJcIlxuICAgICAgaWYgKGVsLmNvbG9yID09PSBDT0xPVVJfUkVTVCkge1xuICAgICAgICBuYW1lID0gXCJSZXN0IHRpbWVcIlxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZWwuY29sb3IgPT09IENPTE9VUl9TTEVFUCkge1xuICAgICAgICBuYW1lID0gXCJTbGVlcCB0aW1lXCJcbiAgICAgIH1cbiAgICAgIGVsc2VcbiAgICAgICAgY29udGludWVcblxuICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpLnNldE5hbWUoYFN0YXJ0IG9mICR7bmFtZX0gKCR7aW5kZXh9KWApLmFkZFRleHQoXG4gICAgICAgIHRleHQgPT4ge1xuICAgICAgICAgIHRleHQuc2V0VmFsdWUoZWwuc3RhcnRUaW1lKS5zZXRQbGFjZWhvbGRlcihcImhoOm1tOnNzXCIpXG4gICAgICAgICAgLm9uQ2hhbmdlKFxuICAgICAgICAgICAgdmFsID0+IHtcbiAgICAgICAgICAgICAgc2V0dGluZ3MuY2FsZW5kYXIucmVzdFRpbWVbaW5kZXhdLnN0YXJ0VGltZSA9IHZhbFxuICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3Moc2V0dGluZ3MpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICApXG4gICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbCkuc2V0TmFtZShgRW5kIG9mICR7bmFtZX0gKCR7aW5kZXh9KWApLmFkZFRleHQoXG4gICAgICAgIHRleHQgPT4ge1xuICAgICAgICAgIHRleHQuc2V0VmFsdWUoZWwuZW5kVGltZSkuc2V0UGxhY2Vob2xkZXIoXCJoaDptbTpzc1wiKVxuICAgICAgICAgIC5vbkNoYW5nZShcbiAgICAgICAgICAgIHZhbCA9PiB7XG4gICAgICAgICAgICAgIHNldHRpbmdzLmNhbGVuZGFyLnJlc3RUaW1lW2luZGV4XS5lbmRUaW1lID0gdmFsXG4gICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncyhzZXR0aW5ncylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIClcblxuICAgIH1cblxuXG4gICAgLy8gU3RhdHVzIENvcnJlY3RvclxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKS5zZXRIZWFkaW5nKClcbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbCkuc2V0TmFtZShcIlN0YXR1c0NvcnJlY3RvclwiKS5zZXRIZWFkaW5nKClcbiAgICAvLyAuc2V0RGVzYyhcIlRoaXMgaXMgRGVzY3JpcHRpb25cIilcblxuICAgIGNvbnN0IHN0YXR1c0NvcnJlY3RvciA9IHNldHRpbmdzLnN0YXR1c0NvcnJlY3Rvci5pc09uXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAuc2V0TmFtZShcIkVuYWJsZSB0b29sXCIpXG4gICAgICAuYWRkVG9nZ2xlKFxuICAgICAgICB0b2dnbGUgPT5cbiAgICAgICAgICB0b2dnbGVcbiAgICAgICAgICAgIC5zZXRWYWx1ZShzdGF0dXNDb3JyZWN0b3IpXG4gICAgICAgICAgICAub25DaGFuZ2UoXG4gICAgICAgICAgICAgIHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5zdGF0dXNDb3JyZWN0b3IuaXNPbiA9IHZhbHVlXG4gICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKHNldHRpbmdzKVxuXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5KClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgICAgKVxuICAgIGlmIChzdGF0dXNDb3JyZWN0b3IpIHtcbiAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAuc2V0TmFtZShcIlN0YXJ0IG9uIFN0YXJ0IFVwXCIpXG4gICAgICAgIC5hZGRUb2dnbGUoXG4gICAgICAgICAgdG9nZ2xlID0+IHRvZ2dsZS5zZXRWYWx1ZShzZXR0aW5ncy5zdGF0dXNDb3JyZWN0b3Iuc3RhcnRPblN0YXJ0VXApXG4gICAgICAgICAgICAub25DaGFuZ2UoXG4gICAgICAgICAgICAgIHZhbCA9PiB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3Muc3RhdHVzQ29ycmVjdG9yLnN0YXJ0T25TdGFydFVwID0gdmFsXG4gICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKHNldHRpbmdzKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgIClcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFkZENvbG91clNldHRpbmcoY29udGFpbmVyRWw6IEhUTUxFbGVtZW50LCBuYW1lOiBzdHJpbmcsIGRlZmF1bHRWYWx1ZTogc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFZhbHVlOiBzdHJpbmcsIGNhbGxiYWNrOiBGdW5jdGlvbikge1xuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKS5zZXROYW1lKG5hbWUpLnNldERlc2MoYERlZmF1bHQ6ICR7ZGVmYXVsdFZhbHVlfWApXG4gICAgLmFkZFRleHQoXG4gICAgICBjb21wb25lbnQgPT4ge1xuICAgICAgICBjb21wb25lbnQuc2V0UGxhY2Vob2xkZXIoXCIjMGYwZjBmXCIpXG4gICAgICAgIC5zZXRWYWx1ZShjdXJyZW50VmFsdWUpLm9uQ2hhbmdlKHZhbCA9PiBjYWxsYmFjayh2YWwpKVxuICAgICAgfVxuICAgIClcbiAgfVxufVxuIiwgImltcG9ydCB7IEFwcCwgTm90aWNlLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IE15UGx1Z2luIGZyb20gXCIuL21haW5cIjtcbmltcG9ydCB7IElFdmVudCwgSVBhZ2UsIElUYXNrcywgSURhdGUgfSBmcm9tIFwiLi90eXBlc1wiO1xuaW1wb3J0IHsgQ2FsZW5kYXJFdmVudFRvSURhdGUsIGR2LCBnZXRUaWNrc0Zyb21UZXh0IH0gZnJvbSBcIi4vdXRpbFwiO1xuaW1wb3J0IHsgTVNHX1BMR19OQU1FIH0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpbGVNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IocGxnOiBNeVBsdWdpbikge1xuICAgIC8vIFRPRE8gXHUwNDNGXHUwNDM1XHUwNDQwXHUwNDM1XHUwNDM0XHUwNDMwXHUwNDMyXHUwNDMwXHUwNDQyXHUwNDRDIFx1MDQzRFx1MDQzNSBcdTA0MzJcdTA0MzVcdTA0NDFcdTA0NEMgYXBwLCBcdTA0MzAgXHUwNDQyXHUwNDNFXHUwNDNCXHUwNDRDXHUwNDNBXHUwNDNFIFx1MDQzRFx1MDQ0M1x1MDQzNlx1MDQzRFx1MDQ0Qlx1MDQzNSBcdTA0MzVcdTA0M0NcdTA0NDMgXHUwNDNGXHUwNDNFXHUwNDNCXHUwNDRGXG4gICAgdGhpcy5hcHAgPSBwbGcuYXBwXG4gIH1cblxuICBwdWJsaWMgYXN5bmMgY3JlYXRlRmlsZShwYXRoOiBzdHJpbmcpIHtcbiAgICBhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGUocGF0aCwgJycpXG4gICAgbmV3IE5vdGljZShNU0dfUExHX05BTUUgKyBcImNyZWF0ZWQgXCIgKyBwYXRoKVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGNoYW5nZVByb3BlcnR5RmlsZShwYXRoOiBzdHJpbmcsIGV2ZW50OiBJRGF0ZSkge1xuICAgIC8vIE5PVEUgXHUwNDREXHUwNDQyXHUwNDNFIFx1MDQzRVx1MDQ0Mlx1MDQzRlx1MDQ0MFx1MDQzMFx1MDQzMlx1MDQzOFx1MDQ0MiBcdTA0NDFcdTA0MzhcdTA0MzNcdTA0M0RcdTA0MzBcdTA0M0IgY2FjaGVcbiAgICBjb25zdCB0RmlsZSA9IHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0Rmlyc3RMaW5rcGF0aERlc3QocGF0aCwgJycpIGFzIFRGaWxlXG4gICAgYXdhaXQgdGhpcy5hcHAuZmlsZU1hbmFnZXIucHJvY2Vzc0Zyb250TWF0dGVyKFxuICAgICAgdEZpbGUsXG4gICAgICBwcm9wZXJ0eSA9PiB7XG4gICAgICAgIHByb3BlcnR5WydmZl9kYXRlJ10gICAgICA9IGV2ZW50WydmZl9kYXRlJ10udG9JU09TdHJpbmcoKS5zbGljZSgwLC0xNClcbiAgICAgICAgcHJvcGVydHlbJ2ZmX3RpbWVTdGFydCddID0gZXZlbnRbJ2ZmX3RpbWVTdGFydCddXG4gICAgICAgIHByb3BlcnR5WydmZl9kdXJhdGlvbiddICA9IGV2ZW50WydmZl9kdXJhdGlvbiddXG4gICAgICB9XG4gICAgKVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGNoYW5nZVN0YXR1c0ZpbGUocGF0aDogc3RyaW5nLCBzdGF0dXM6IHN0cmluZykge1xuICAgIC8vIE5PVEUgXHUwNDREXHUwNDQyXHUwNDNFIFx1MDQzRVx1MDQ0Mlx1MDQzRlx1MDQ0MFx1MDQzMFx1MDQzMlx1MDQzOFx1MDQ0MiBcdTA0NDFcdTA0MzhcdTA0MzNcdTA0M0RcdTA0MzBcdTA0M0IgY2FjaGVcbiAgICBjb25zdCB0RmlsZSA9IHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0Rmlyc3RMaW5rcGF0aERlc3QocGF0aCwgJycpIGFzIFRGaWxlXG4gICAgYXdhaXQgdGhpcy5hcHAuZmlsZU1hbmFnZXIucHJvY2Vzc0Zyb250TWF0dGVyKFxuICAgICAgdEZpbGUsXG4gICAgICBwcm9wZXJ0eSA9PiB7XG4gICAgICAgIHByb3BlcnR5WydmZl9zdGF0dXMnXSA9IHN0YXR1c1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBjaGFuZ2VUaWNrRmlsZShwYXRoOiBzdHJpbmcsIHRpY2tuYW1lOnN0cmluZywgZXZlbnQ6IElEYXRlKSB7XG4gICAgLy8gTk9URSBcdTA0NERcdTA0NDJcdTA0M0UgXHUwNDNFXHUwNDQyXHUwNDNGXHUwNDQwXHUwNDMwXHUwNDMyXHUwNDM4XHUwNDQyIFx1MDQ0MVx1MDQzOFx1MDQzM1x1MDQzRFx1MDQzMFx1MDQzQiBjYWNoZVxuICAgIGNvbnN0IHRGaWxlID0gdGhpcy5hcHAubWV0YWRhdGFDYWNoZS5nZXRGaXJzdExpbmtwYXRoRGVzdChwYXRoLCAnJykgYXMgVEZpbGVcblxuICAgIC8vICEgXHUwNDNDXHUwNDMxLCBcdTA0M0ZcdTA0M0VcdTA0M0NcdTA0MzVcdTA0M0RcdTA0NEZcdTA0NDJcdTA0NEMgXHUwNDQxIFx1MDQzOFx1MDQ0MVx1MDQzRlx1MDQzRVx1MDQzQlx1MDQ0Q1x1MDQzN1x1MDQzRVx1MDQzMlx1MDQzMFx1MDQzRFx1MDQzOFx1MDQzNVx1MDQzQyBcdTA0MzRcdTA0NDBcdTA0NDNcdTA0MzNcdTA0M0VcdTA0MzkgXHUwNDNCXHUwNDM4XHUwNDMxXHUwNDRCIChcdTA0NDFcdTA0M0MuIFx1MDQzRlx1MDQzQlx1MDQzMFx1MDQzM1x1MDQzOFx1MDQzRCBcdTA0MzRcdTA0NDBcdTA0NDNcdTA0MzNcdTA0M0VcdTA0MzkgXHUwNDQxIFx1MDQzMlx1MDQzOFx1MDQzNFx1MDQzRVx1MDQ0MVx1MDQzMCBZb3VUdWJlKVxuICAgIGNvbnN0IHRleHQgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkKHRGaWxlKVxuICAgIGNvbnN0IHJlZ0V4cCA9IG5ldyBSZWdFeHAoYFxcXFxbdDo6XFxcXHMqJHt0aWNrbmFtZX0oLFteXFxcXF1dKnwpXFxcXF1gLCBcImdtXCIpXG5cbiAgICBjb25zdCBkYXRlID0gZXZlbnRbXCJmZl9kYXRlXCJdLnRvSVNPU3RyaW5nKCkuc2xpY2UoMCwtMTQpXG4gICAgY29uc3QgbmV3U3RyaW5nID0gYFt0Ojoke3RpY2tuYW1lfSwke2RhdGV9LCR7ZXZlbnRbXCJmZl90aW1lU3RhcnRcIl19LCR7ZXZlbnRbJ2ZmX2R1cmF0aW9uJ119XWBcblxuICAgIGF3YWl0IHRoaXMuYXBwLnZhdWx0Lm1vZGlmeShcbiAgICAgIHRGaWxlLFxuICAgICAgdGV4dC5yZXBsYWNlKHJlZ0V4cCwgbmV3U3RyaW5nKVxuICAgIClcbiAgfVxuXG4gIHB1YmxpYyBvcGVuTm90ZShldmVudDogSUV2ZW50KSB7XG4gICAgLy8gTk9URSBcdTA0NDFcdTA0M0RcdTA0MzBcdTA0NDdcdTA0MzBcdTA0M0JcdTA0MzAgXHUwNDNGXHUwNDQwXHUwNDNFXHUwNDMyXHUwNDM1XHUwNDQwXHUwNDRGXHUwNDM1XHUwNDQyIFx1MDQ0Mlx1MDQzOFx1MDQzQSBcdTA0M0JcdTA0MzggXHUwNDREXHUwNDQyXHUwNDNFLCBcdTA0MzAgXHUwNDNGXHUwNDNFXHUwNDQyXHUwNDNFXHUwNDNDIFx1MDQzRlx1MDQzNVx1MDQ0MFx1MDQzNVx1MDQ0NVx1MDQzRVx1MDQzNFx1MDQzOFx1MDQ0MiBcdTA0M0EgaWRcbiAgICBjb25zdCB0RmlsZSA9IHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0Rmlyc3RMaW5rcGF0aERlc3QoXG4gICAgICBldmVudD8uZXh0ZW5kZWRQcm9wcz8ubm90ZVBhdGggfHwgZXZlbnQuaWQsICcnXG4gICAgKVxuXG4gICAgLy8gZmFsc2UgPSBvcGVuIGluIHRoZSBjdXJyZW50IHRhYlxuICAgIGNvbnN0IGxlYWYgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0TGVhZih0cnVlKVxuICAgIHRGaWxlICYmIGxlYWYub3BlbkZpbGUodEZpbGUpXG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZ2V0UGFnZShmaWxlOiBURmlsZSk6IFByb21pc2U8SVBhZ2U+IHtcbiAgICBjb25zdCByZXN1bHQ6IElQYWdlID0ge1xuICAgICAgZmlsZToge1xuICAgICAgICBwYXRoOiBmaWxlLnBhdGgsXG4gICAgICAgIG5hbWU6IGZpbGUuYmFzZW5hbWVcbiAgICAgIH0sXG4gICAgICB0aWNrczogZ2V0VGlja3NGcm9tVGV4dChhd2FpdCB0aGlzLmFwcC52YXVsdC5jYWNoZWRSZWFkKGZpbGUpKSxcbiAgICAgIGZmX2R1cmF0aW9uOiBcIlwiLFxuICAgICAgZmZfdGltZVN0YXJ0OiBcIlwiLFxuXG4gICAgICAvLyBUT0RPIFx1MDQzOFx1MDQzNy1cdTA0MzdcdTA0MzAgXHUwNDQyXHUwNDNFXHUwNDMzXHUwNDNFLCBcdTA0NDdcdTA0NDJcdTA0M0UgXHUwNDNEXHUwNDM1IFx1MDQzMlx1MDQ0MVx1MDQzNSBcdTA0MzdcdTA0MzBcdTA0M0NcdTA0MzVcdTA0NDJcdTA0M0FcdTA0MzggXHUwNDM4XHUwNDNDXHUwNDM1XHUwNDRFXHUwNDQyIGZmX2RhdGUsIFx1MDQzRVx1MDQzRCBcdTA0MzRcdTA0M0VcdTA0M0JcdTA0MzZcdTA0MzVcdTA0M0QgXHUwNDMyXHUwNDNFXHUwNDM3XHUwNDMyXHUwNDQwXHUwNDMwXHUwNDQ5XHUwNDMwXHUwNDQyXHUwNDRDIG51bGwsIFx1MDQzRFx1MDQzRSBcdTA0NERcdTA0NDJcdTA0M0UgYmFkIHByYWN0aWNlXG4gICAgICAvL0B0cy1pZ25vcmVcbiAgICAgIGZmX2RhdGU6IG51bGwsXG4gICAgfVxuXG4gICAgY29uc3QgcHJvcGVydHkgPSB0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKT8uZnJvbnRtYXR0ZXJcbiAgICBpZiAoIXByb3BlcnR5KSB7XG4gICAgICAvLyBiYWQgd2F5LCBjYXVzZSBpdCBtYXkgaGF2ZW4ndCBleHBlY3RlZCBmaWVsZHNcbiAgICAgIC8vIFRPRE8gdGhyb3cgRXJyb3IoXCJ1bnJlYWNoYWJsZVwiKVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cblxuICAgIGNvbnN0IGFkZGVkID0ge1xuICAgICAgZmZfZHVyYXRpb246IGR2LmR1cmF0aW9uKHByb3BlcnR5LmZmX2R1cmF0aW9uKSxcbiAgICAgIGZmX3RpbWVTdGFydDogZHYuZHVyYXRpb24ocHJvcGVydHkuZmZfdGltZVN0YXJ0KSxcbiAgICAgIGZmX2RhdGU6IGR2LmRhdGUocHJvcGVydHkuZmZfZGF0ZSksXG4gICAgICBmZl9zdGF0dXM6IHByb3BlcnR5LmZmX3N0YXR1c1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXN1bHQsXG4gICAgICAuLi5hZGRlZFxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXRUYXNrQ291bnQocGFnZTogSVBhZ2UpOiBJVGFza3Mge1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIGRvbmU6IDAsXG4gICAgICBhbGw6IDBcbiAgICB9XG5cbiAgICBjb25zdCB0RmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEZpbGVCeVBhdGgocGFnZS5maWxlLnBhdGgpXG5cbiAgICBpZiAoIXRGaWxlKVxuICAgICAgcmV0dXJuIHJlc3VsdFxuXG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZSh0RmlsZSk/Lmxpc3RJdGVtc1xuXG4gICAgaWYgKGl0ZW1zKSBmb3IgKGxldCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICBpZiAoaXRlbS50YXNrID09IHVuZGVmaW5lZClcbiAgICAgICAgY29udGludWVcblxuICAgICAgaWYgKGl0ZW0udGFzayA9PSAneCcpIHtcbiAgICAgICAgKytyZXN1bHQuZG9uZVxuICAgICAgfVxuICAgICAgKytyZXN1bHQuYWxsXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgcHVibGljIGFzeW5jIGdldFRleHQocGF0aDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBjb25zdCB0RmlsZSA9IHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0Rmlyc3RMaW5rcGF0aERlc3QocGF0aCwgJycpIGFzIFRGaWxlXG4gICAgY29uc3QgdGV4dCA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQodEZpbGUpXG5cbiAgICByZXR1cm4gdGV4dFxuICB9XG5cbiAgcHVibGljIGFzeW5jIHNldFRleHQocGF0aDogc3RyaW5nLCB0ZXh0OiBzdHJpbmcpIHtcbiAgICBjb25zdCB0RmlsZSA9IHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0Rmlyc3RMaW5rcGF0aERlc3QocGF0aCwgJycpIGFzIFRGaWxlXG5cbiAgICBhd2FpdCB0aGlzLmFwcC52YXVsdC5tb2RpZnkodEZpbGUsIHRleHQpXG4gIH1cblxuICBwcml2YXRlIGFwcDogQXBwXG59XG4iLCAiaW1wb3J0IHsgQXBwLCBOb3RpY2UgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCBNeVBsdWdpbiBmcm9tIFwiLi4vbWFpblwiO1xuaW1wb3J0IHsgSVBhZ2UsIElTdWJzY3JpYmVyLCBTcmMgfSBmcm9tIFwiLi4vdHlwZXNcIlxuaW1wb3J0IHsgTVNHX1BMR19OQU1FIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgc2FmZVBhcnNlSW50IH0gZnJvbSBcIi4uL3V0aWxcIjtcblxuZXhwb3J0IGNsYXNzIFRpY2tDaGVja2VyIGltcGxlbWVudHMgSVN1YnNjcmliZXIge1xuICBwcml2YXRlIHBhcmVudDogTXlQbHVnaW5cblxuICBwcml2YXRlIGlkRm9yQ2FjaGU6IG51bWJlclxuXG5cbiAgY29uc3RydWN0b3IoaWRGb3JDYWNoZTogbnVtYmVyLCBldmVudF9zcmM6IFNyY1tdLCBwdHI6IE15UGx1Z2luKSB7XG4gICAgdGhpcy5wYXJlbnQgPSBwdHJcbiAgICB0aGlzLmlkRm9yQ2FjaGUgPSBpZEZvckNhY2hlXG5cbiAgICB0aGlzLnBhcmVudC5jYWNoZS5zdWJzY3JpYmUoaWRGb3JDYWNoZSwgZXZlbnRfc3JjLCB0aGlzKVxuICAgICAgLnRoZW4oZGF0YSA9PiB0aGlzLnByb2Nlc3MoZGF0YSkpXG4gIH1cblxuXG4gIHByaXZhdGUgYXN5bmMgcHJvY2VzcyhwYWdlczogSVBhZ2VbXSkge1xuICAgIGZvciAobGV0IHBhZ2Ugb2YgcGFnZXMpIHtcbiAgICAgIGZvciAobGV0IHRpY2sgb2YgcGFnZS50aWNrcykge1xuICAgICAgICBpZiAoIGlzTmFOKHNhZmVQYXJzZUludCh0aWNrLm5hbWUpKSApXG4gICAgICAgICAgY29udGludWVcblxuXG4gICAgICAgIGxldCB0ZXh0ID0gYXdhaXQgdGhpcy5wYXJlbnQuZmlsZU1hbmFnZXIuZ2V0VGV4dChwYWdlLmZpbGUucGF0aClcbiAgICAgICAgY29uc3QgcmVnRXhwID0gbmV3IFJlZ0V4cChgXFxcXFt0OjpcXFxccyoke3RpY2submFtZX0oLFteXFxcXF1dKnwpXFxcXF1gLCBcImdtXCIpXG5cbiAgICAgICAgYXdhaXQgdGhpcy5wYXJlbnQuZmlsZU1hbmFnZXIuc2V0VGV4dChcbiAgICAgICAgICBwYWdlLmZpbGUucGF0aCxcbiAgICAgICAgICB0ZXh0LnJlcGxhY2UocmVnRXhwLCBgW3Q6OiR7dGljay5uYW1lfV8kMV1gKVxuICAgICAgICApXG5cbiAgICAgICAgbmV3IE5vdGljZShNU0dfUExHX05BTUUgKyBgY2hhbmdlIHRpY2tuYW1lIGluICR7cGFnZS5maWxlLm5hbWV9OiAke3RpY2submFtZX1gKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucGFyZW50LmNhY2hlLnVuc3Vic2NyaWJlKHRoaXMuaWRGb3JDYWNoZSlcbiAgfVxuXG4gIHJlbmFtZUZpbGUobmV3UGFnZTogSVBhZ2UsIG9sZFBhZ2U6IElQYWdlKTogdm9pZCB7fVxuICBkZWxldGVGaWxlKHBhZ2U6IElQYWdlKTogdm9pZCB7fVxuICBhZGRGaWxlKHBhZ2U6IElQYWdlKTogdm9pZCB7fVxuICBjaGFuZ2VGaWxlKG5ld1BhZ2U6IElQYWdlLCBvbGRQYWdlOiBJUGFnZSk6IHZvaWQge31cbiAgcmVzZXQoKTogdm9pZCB7fVxuXG59XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUtBLFFBQU0sYUFBTixjQUF5QixNQUFNO0lBQUE7QUFLeEIsUUFBTSx1QkFBTixjQUFtQyxXQUFXO01BQ25ELFlBQVks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RUEsTUFBYSxhQUFhLFVBQTBCO0FBQ2xELFNBQUssV0FBVztBQUNoQixVQUFNLEtBQUssU0FBUyxLQUFLLFFBQVE7QUFBQSxFQUNuQztBQUFBLEVBSUEsTUFBYyxlQUFlO0FBQzNCLFNBQUssV0FBVyxPQUFPLE9BQU8sQ0FBQyxHQUFHLGtCQUFrQixNQUFNLEtBQUssU0FBUyxDQUFDO0FBRXpFLFNBQUssY0FBYyxJQUFJLGFBQWEsS0FBSyxLQUFLLElBQUksQ0FBQztBQUFBLEVBQ3JEO0FBQ0Y7IiwKICAibmFtZXMiOiBbIm4iLCAicyIsICJsIiwgInNpbmdsZXRvbiIsICJpIiwgImUiLCAiZiIsICJEYXRlVGltZSIsICJwYWRTdGFydCIsICJ6IiwgIkVuZ2xpc2guZm9ybWF0UmVsYXRpdmVUaW1lIiwgIkVuZ2xpc2gubW9udGhzIiwgIkVuZ2xpc2gud2Vla2RheXMiLCAiRW5nbGlzaC5tZXJpZGllbXMiLCAiRW5nbGlzaC5lcmFzIiwgIm0iLCAib2Zmc2V0IiwgInIiLCAiZGVmYXVsdFpvbmUiLCAiaXNOdW1iZXIiLCAidCIsICJvIiwgImlzRGF0ZSIsICJhIiwgImsiLCAiaGFzT3duUHJvcGVydHkiLCAieCIsICJpc0xlYXBZZWFyIiwgImQiLCAicDIiLCAidSIsICJ2IiwgIkZvcm1hdHMuREFURV9TSE9SVCIsICJGb3JtYXRzLkRBVEVfTUVEIiwgIkZvcm1hdHMuREFURV9GVUxMIiwgIkZvcm1hdHMuREFURV9IVUdFIiwgIkZvcm1hdHMuVElNRV9TSU1QTEUiLCAiRm9ybWF0cy5USU1FX1dJVEhfU0VDT05EUyIsICJGb3JtYXRzLlRJTUVfV0lUSF9TSE9SVF9PRkZTRVQiLCAiRm9ybWF0cy5USU1FX1dJVEhfTE9OR19PRkZTRVQiLCAiRm9ybWF0cy5USU1FXzI0X1NJTVBMRSIsICJGb3JtYXRzLlRJTUVfMjRfV0lUSF9TRUNPTkRTIiwgIkZvcm1hdHMuVElNRV8yNF9XSVRIX1NIT1JUX09GRlNFVCIsICJGb3JtYXRzLlRJTUVfMjRfV0lUSF9MT05HX09GRlNFVCIsICJGb3JtYXRzLkRBVEVUSU1FX1NIT1JUIiwgIkZvcm1hdHMuREFURVRJTUVfTUVEIiwgIkZvcm1hdHMuREFURVRJTUVfRlVMTCIsICJGb3JtYXRzLkRBVEVUSU1FX0hVR0UiLCAiRm9ybWF0cy5EQVRFVElNRV9TSE9SVF9XSVRIX1NFQ09ORFMiLCAiRm9ybWF0cy5EQVRFVElNRV9NRURfV0lUSF9TRUNPTkRTIiwgIkZvcm1hdHMuREFURVRJTUVfRlVMTF9XSVRIX1NFQ09ORFMiLCAiRm9ybWF0cy5EQVRFVElNRV9IVUdFX1dJVEhfU0VDT05EUyIsICJjIiwgInAiLCAiZm9ybWF0T2Zmc2V0IiwgIkVuZ2xpc2gubWVyaWRpZW1Gb3JEYXRlVGltZSIsICJFbmdsaXNoLm1vbnRoRm9yRGF0ZVRpbWUiLCAiRW5nbGlzaC53ZWVrZGF5Rm9yRGF0ZVRpbWUiLCAiRW5nbGlzaC5lcmFGb3JEYXRlVGltZSIsICJwYXJzZSIsICJtYXRjaCIsICJFbmdsaXNoLm1vbnRoc1Nob3J0IiwgIkVuZ2xpc2gud2Vla2RheXNMb25nIiwgIkVuZ2xpc2gud2Vla2RheXNTaG9ydCIsICJJTlZBTElEIiwgIm9yZGVyZWRVbml0cyIsICJjbG9uZSIsICJjb25maWciLCAidjIiLCAiYiIsICJoIiwgIm8yIiwgImMyIiwgInEiLCAiRm9ybWF0cy5EQVRFX01FRF9XSVRIX1dFRUtEQVkiLCAiRm9ybWF0cy5EQVRFVElNRV9NRURfV0lUSF9XRUVLREFZIiwgIlJlc3VsdCIsICJtb2R1bGUiLCAidGhpcyIsICJnIiwgInkiLCAiRSIsICJ3IiwgIkIiLCAiaiIsICJTIiwgIl8iLCAiTCIsICJPIiwgIlAiLCAiQSIsICJJIiwgIkYiLCAiTSIsICJVIiwgIlciLCAiRCIsICJOIiwgIkciLCAiQyIsICJKIiwgIlQiLCAiViIsICJIIiwgIlgiLCAiSyIsICJRIiwgIloiLCAiJCIsICJubiIsICJ0biIsICJlbiIsICJQLmFsdCIsICJQLnJlZ2V4IiwgIlAud2hpdGVzcGFjZSIsICJQLmFueSIsICJWYWx1ZXMiLCAiaXNTdHJpbmciLCAiaXNBcnJheSIsICJpc09iamVjdCIsICJmMiIsICJpbmRleCIsICJrMiIsICJpc1RydXRoeSIsICJHcm91cGluZ3MiLCAiZGlzcGxheSIsICJzcGxpdCIsICJXaWRnZXRzIiwgIkZpZWxkcyIsICJmdW5jIiwgIlNvdXJjZXMiLCAidGFnIiwgImVtcHR5IiwgImNvbWJpbmUiLCAiUC5zZXFNYXAiLCAiUC5zZXEiLCAiUC5vcHRXaGl0ZXNwYWNlIiwgIlAuY3VzdG9tIiwgIlAuY3JlYXRlTGFuZ3VhZ2UiLCAiUC5yZWdleHAiLCAiUC5zdHJpbmciLCAiUC5ub25lT2YiLCAiUC5zdWNjZWVkIiwgIl8yIiwgIlAuZmFpbCIsICJfMyIsICJRdWVyeUZpZWxkcyIsICJQLmVvZiIsICJQLlBhcnNlciIsICJQLm1ha2VGYWlsdXJlIiwgIlAubWFrZVN1Y2Nlc3MiLCAiUC5zZXBCeSIsICJzb3J0IiwgImdldEFQSSIsICJtb2R1bGUiLCAiSUNBTCIsICJpIiwgIkYiLCAiayIsICJ4IiwgImUiLCAic3BsaXQiLCAiQ29tcG9uZW50IiwgImluZGV4IiwgInAiLCAiYSIsICJiIiwgImgyIiwgInIiLCAiYVByb3AiLCAiY2xvbmUiLCAicSIsICJtIiwgImgiLCAiZGF5c0JldHdlZW4iLCAiaXNEYXRlIiwgImlzTGVhcFllYXIiLCAidCIsICJwMiIsICJ5IiwgImQiLCAicyIsICJ2IiwgIm8iLCAiaXRlciIsICJrZXkiLCAic2VsZiIsICJ0MiIsICJ0MyIsICJqIiwgInByb3AiLCAiRXZlbnQiLCAicmFuZ2UiLCAiaW1wb3J0X29ic2lkaWFuIiwgImkiLCAiXyIsICJpbmRleCIsICJzbGljZSIsICJvcHRpb25zIiwgInZub2RlSWQiLCAiaXNWYWxpZEVsZW1lbnQiLCAiaW5FdmVudCIsICJyZXJlbmRlclF1ZXVlIiwgInByZXZEZWJvdW5jZSIsICJtaWNyb1RpY2siLCAiaSIsICJFTVBUWV9PQkoiLCAiRU1QVFlfQVJSIiwgIklTX05PTl9ESU1FTlNJT05BTCIsICJhc3NpZ24iLCAib2JqIiwgInByb3BzIiwgInJlbW92ZU5vZGUiLCAibm9kZSIsICJwYXJlbnROb2RlIiwgInJlbW92ZUNoaWxkIiwgImNyZWF0ZUVsZW1lbnQiLCAidHlwZSIsICJjaGlsZHJlbiIsICJrZXkiLCAicmVmIiwgIm5vcm1hbGl6ZWRQcm9wcyIsICJhcmd1bWVudHMiLCAibGVuZ3RoIiwgImNhbGwiLCAiZGVmYXVsdFByb3BzIiwgImNyZWF0ZVZOb2RlIiwgIm9yaWdpbmFsIiwgInZub2RlIiwgIl9fayIsICJfXyIsICJfX2IiLCAiX19lIiwgIl9fZCIsICJfX2MiLCAiX19oIiwgImNvbnN0cnVjdG9yIiwgIl9fdiIsICJjcmVhdGVSZWYiLCAiY3VycmVudCIsICJGcmFnbWVudCIsICJkaWZmUHJvcHMiLCAiZG9tIiwgIm5ld1Byb3BzIiwgIm9sZFByb3BzIiwgImlzU3ZnIiwgImh5ZHJhdGUiLCAic2V0UHJvcGVydHkiLCAic2V0U3R5bGUiLCAic3R5bGUiLCAidmFsdWUiLCAidGVzdCIsICJuYW1lIiwgIm9sZFZhbHVlIiwgInVzZUNhcHR1cmUiLCAibyIsICJjc3NUZXh0IiwgInJlcGxhY2UiLCAidG9Mb3dlckNhc2UiLCAibCIsICJhZGRFdmVudExpc3RlbmVyIiwgImV2ZW50UHJveHlDYXB0dXJlIiwgImV2ZW50UHJveHkiLCAicmVtb3ZlRXZlbnRMaXN0ZW5lciIsICJlIiwgImluZGV4T2YiLCAicmVtb3ZlQXR0cmlidXRlIiwgInNldEF0dHJpYnV0ZSIsICJ0aGlzIiwgImV2ZW50IiwgIkNvbXBvbmVudCIsICJjb250ZXh0IiwgImdldERvbVNpYmxpbmciLCAiY2hpbGRJbmRleCIsICJzaWJsaW5nIiwgInVwZGF0ZVBhcmVudERvbVBvaW50ZXJzIiwgImNoaWxkIiwgImJhc2UiLCAiZGVmZXIiLCAiY2IiLCAic2V0VGltZW91dCIsICJlbnF1ZXVlUmVuZGVyIiwgImMiLCAicHVzaCIsICJwcm9jZXNzIiwgIl9fciIsICJkZWJvdW5jZVJlbmRlcmluZyIsICJyZW5kZXJRdWV1ZUxlbmd0aCIsICJjb21wb25lbnQiLCAiY29tbWl0UXVldWUiLCAib2xkVk5vZGUiLCAib2xkRG9tIiwgInBhcmVudERvbSIsICJzb3J0IiwgImEiLCAiYiIsICJzaGlmdCIsICJfX1AiLCAiZGlmZiIsICJvd25lclNWR0VsZW1lbnQiLCAiY29tbWl0Um9vdCIsICJkaWZmQ2hpbGRyZW4iLCAicmVuZGVyUmVzdWx0IiwgIm5ld1BhcmVudFZOb2RlIiwgIm9sZFBhcmVudFZOb2RlIiwgImdsb2JhbENvbnRleHQiLCAiZXhjZXNzRG9tQ2hpbGRyZW4iLCAiaXNIeWRyYXRpbmciLCAiaiIsICJjaGlsZFZOb2RlIiwgIm5ld0RvbSIsICJmaXJzdENoaWxkRG9tIiwgInJlZnMiLCAib2xkQ2hpbGRyZW4iLCAib2xkQ2hpbGRyZW5MZW5ndGgiLCAiQXJyYXkiLCAiaXNBcnJheSIsICJyZW9yZGVyQ2hpbGRyZW4iLCAicGxhY2VDaGlsZCIsICJnZXRMYXN0RG9tIiwgIm5leHRTaWJsaW5nIiwgInVubW91bnQiLCAiYXBwbHlSZWYiLCAidG1wIiwgInRvQ2hpbGRBcnJheSIsICJvdXQiLCAic29tZSIsICJuZXh0RG9tIiwgInNpYkRvbSIsICJvdXRlciIsICJhcHBlbmRDaGlsZCIsICJpbnNlcnRCZWZvcmUiLCAibGFzdERvbSIsICJuZXdWTm9kZSIsICJpc05ldyIsICJvbGRTdGF0ZSIsICJzbmFwc2hvdCIsICJjbGVhclByb2Nlc3NpbmdFeGNlcHRpb24iLCAicHJvdmlkZXIiLCAiY29tcG9uZW50Q29udGV4dCIsICJyZW5kZXJIb29rIiwgImNvdW50IiwgIm5ld1R5cGUiLCAiY29udGV4dFR5cGUiLCAiX19FIiwgInByb3RvdHlwZSIsICJyZW5kZXIiLCAiZG9SZW5kZXIiLCAic3ViIiwgInN0YXRlIiwgIl9zYiIsICJfX3MiLCAiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwgImNvbXBvbmVudFdpbGxNb3VudCIsICJjb21wb25lbnREaWRNb3VudCIsICJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwgInNob3VsZENvbXBvbmVudFVwZGF0ZSIsICJmb3JFYWNoIiwgImNvbXBvbmVudFdpbGxVcGRhdGUiLCAiY29tcG9uZW50RGlkVXBkYXRlIiwgImdldENoaWxkQ29udGV4dCIsICJnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSIsICJkaWZmRWxlbWVudE5vZGVzIiwgImRpZmZlZCIsICJyb290IiwgIm9sZEh0bWwiLCAibmV3SHRtbCIsICJub2RlVHlwZSIsICJsb2NhbE5hbWUiLCAiZG9jdW1lbnQiLCAiY3JlYXRlVGV4dE5vZGUiLCAiY3JlYXRlRWxlbWVudE5TIiwgImlzIiwgImRhdGEiLCAiY2hpbGROb2RlcyIsICJkYW5nZXJvdXNseVNldElubmVySFRNTCIsICJhdHRyaWJ1dGVzIiwgIl9faHRtbCIsICJpbm5lckhUTUwiLCAiY2hlY2tlZCIsICJwYXJlbnRWTm9kZSIsICJza2lwUmVtb3ZlIiwgInIiLCAiY29tcG9uZW50V2lsbFVubW91bnQiLCAicmVwbGFjZU5vZGUiLCAiZmlyc3RDaGlsZCIsICJjcmVhdGVDb250ZXh0IiwgImRlZmF1bHRWYWx1ZSIsICJjb250ZXh0SWQiLCAiY29udGV4dCIsICJfX2MiLCAiaSIsICJfXyIsICJDb25zdW1lciIsICJwcm9wcyIsICJjb250ZXh0VmFsdWUiLCAiY2hpbGRyZW4iLCAiUHJvdmlkZXIiLCAic3VicyIsICJjdHgiLCAidGhpcyIsICJnZXRDaGlsZENvbnRleHQiLCAic2hvdWxkQ29tcG9uZW50VXBkYXRlIiwgIl9wcm9wcyIsICJ2YWx1ZSIsICJzb21lIiwgImMiLCAiX19lIiwgImVucXVldWVSZW5kZXIiLCAic3ViIiwgInB1c2giLCAib2xkIiwgImNvbXBvbmVudFdpbGxVbm1vdW50IiwgInNwbGljZSIsICJpbmRleE9mIiwgImNhbGwiLCAiY29udGV4dFR5cGUiLCAic2xpY2UiLCAiRU1QVFlfQVJSIiwgIm9wdGlvbnMiLCAiZXJyb3IiLCAidm5vZGUiLCAib2xkVk5vZGUiLCAiZXJyb3JJbmZvIiwgImNvbXBvbmVudCIsICJjdG9yIiwgImhhbmRsZWQiLCAiY29uc3RydWN0b3IiLCAiZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIiwgInNldFN0YXRlIiwgIl9fZCIsICJjb21wb25lbnREaWRDYXRjaCIsICJfX0UiLCAiZSIsICJ2bm9kZUlkIiwgImlzVmFsaWRFbGVtZW50IiwgImluRXZlbnQiLCAiQ29tcG9uZW50IiwgInByb3RvdHlwZSIsICJ1cGRhdGUiLCAiY2FsbGJhY2siLCAicyIsICJfX3MiLCAic3RhdGUiLCAiYXNzaWduIiwgIl9fdiIsICJfc2IiLCAiZm9yY2VVcGRhdGUiLCAiX19oIiwgInJlbmRlciIsICJGcmFnbWVudCIsICJyZXJlbmRlclF1ZXVlIiwgIm1pY3JvVGljayIsICJQcm9taXNlIiwgInRoZW4iLCAiYmluZCIsICJyZXNvbHZlIiwgInNldFRpbWVvdXQiLCAicHJvY2VzcyIsICJfX3IiLCAiY3VycmVudEluZGV4IiwgImN1cnJlbnRDb21wb25lbnQiLCAicHJldmlvdXNDb21wb25lbnQiLCAicHJldlJhZiIsICJhZnRlclBhaW50RWZmZWN0cyIsICJFTVBUWSIsICJvbGRCZWZvcmVEaWZmIiwgIm9wdGlvbnMiLCAib2xkQmVmb3JlUmVuZGVyIiwgIm9sZEFmdGVyRGlmZiIsICJkaWZmZWQiLCAib2xkQ29tbWl0IiwgIl9fYyIsICJvbGRCZWZvcmVVbm1vdW50IiwgInVubW91bnQiLCAiZmx1c2hBZnRlclBhaW50RWZmZWN0cyIsICJjb21wb25lbnQiLCAiYWZ0ZXJQYWludEVmZmVjdHMiLCAic2hpZnQiLCAiX19IIiwgImZvckVhY2giLCAiaW52b2tlQ2xlYW51cCIsICJpbnZva2VFZmZlY3QiLCAiX19oIiwgImUiLCAib3B0aW9ucyIsICJfX2UiLCAiX19iIiwgInZub2RlIiwgImN1cnJlbnRDb21wb25lbnQiLCAib2xkQmVmb3JlRGlmZiIsICJvbGRCZWZvcmVSZW5kZXIiLCAiY3VycmVudEluZGV4IiwgImhvb2tzIiwgIl9fYyIsICJwcmV2aW91c0NvbXBvbmVudCIsICJfXyIsICJob29rSXRlbSIsICJfX04iLCAiRU1QVFkiLCAiX3BlbmRpbmdBcmdzIiwgImRpZmZlZCIsICJvbGRBZnRlckRpZmYiLCAiYyIsICJsZW5ndGgiLCAicHVzaCIsICJwcmV2UmFmIiwgInJlcXVlc3RBbmltYXRpb25GcmFtZSIsICJhZnRlck5leHRGcmFtZSIsICJfX1YiLCAiY29tbWl0UXVldWUiLCAic29tZSIsICJmaWx0ZXIiLCAiY2IiLCAiX192IiwgIm9sZENvbW1pdCIsICJ1bm1vdW50IiwgIm9sZEJlZm9yZVVubW91bnQiLCAiaGFzRXJyb3JlZCIsICJzIiwgIkhBU19SQUYiLCAiY2FsbGJhY2siLCAicmFmIiwgImRvbmUiLCAiY2xlYXJUaW1lb3V0IiwgInRpbWVvdXQiLCAiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCAic2V0VGltZW91dCIsICJob29rIiwgImNvbXAiLCAiY2xlYW51cCIsICJhc3NpZ24iLCAib2JqIiwgInByb3BzIiwgImkiLCAic2hhbGxvd0RpZmZlcnMiLCAiYSIsICJiIiwgIlB1cmVDb21wb25lbnQiLCAicCIsICJ0aGlzIiwgInByb3BzIiwgIlB1cmVDb21wb25lbnQiLCAicHJvdG90eXBlIiwgIkNvbXBvbmVudCIsICJpc1B1cmVSZWFjdENvbXBvbmVudCIsICJzaG91bGRDb21wb25lbnRVcGRhdGUiLCAicHJvcHMiLCAic3RhdGUiLCAic2hhbGxvd0RpZmZlcnMiLCAidGhpcyIsICJvbGREaWZmSG9vayIsICJvcHRpb25zIiwgIl9fYiIsICJ2bm9kZSIsICJ0eXBlIiwgIl9fZiIsICJyZWYiLCAiUkVBQ1RfRk9SV0FSRF9TWU1CT0wiLCAiU3ltYm9sIiwgImZvciIsICJvbGRDYXRjaEVycm9yIiwgIm9wdGlvbnMiLCAiX19lIiwgImVycm9yIiwgIm5ld1ZOb2RlIiwgIm9sZFZOb2RlIiwgImVycm9ySW5mbyIsICJ0aGVuIiwgImNvbXBvbmVudCIsICJ2bm9kZSIsICJfX2MiLCAiX19rIiwgIm9sZFVubW91bnQiLCAidW5tb3VudCIsICJkZXRhY2hlZENsb25lIiwgImRldGFjaGVkUGFyZW50IiwgInBhcmVudERvbSIsICJmb3JFYWNoIiwgImVmZmVjdCIsICJfX0giLCAiYXNzaWduIiwgIl9fUCIsICJtYXAiLCAiY2hpbGQiLCAicmVtb3ZlT3JpZ2luYWwiLCAib3JpZ2luYWxQYXJlbnQiLCAiX192IiwgImluc2VydEJlZm9yZSIsICJfX2QiLCAiU3VzcGVuc2UiLCAidGhpcyIsICJfX3UiLCAiX3N1c3BlbmRlcnMiLCAic3VzcGVuZGVkIiwgIl9fIiwgIl9fYSIsICJTdXNwZW5zZUxpc3QiLCAidGhpcyIsICJfbmV4dCIsICJfbWFwIiwgIm9wdGlvbnMiLCAidW5tb3VudCIsICJ2bm9kZSIsICJjb21wb25lbnQiLCAiX19jIiwgIl9fUiIsICJfX2giLCAidHlwZSIsICJvbGRVbm1vdW50IiwgIlN1c3BlbnNlIiwgInByb3RvdHlwZSIsICJDb21wb25lbnQiLCAicHJvbWlzZSIsICJzdXNwZW5kaW5nVk5vZGUiLCAic3VzcGVuZGluZ0NvbXBvbmVudCIsICJjIiwgIl9zdXNwZW5kZXJzIiwgInB1c2giLCAicmVzb2x2ZSIsICJzdXNwZW5kZWQiLCAiX192IiwgInJlc29sdmVkIiwgIm9uUmVzb2x2ZWQiLCAib25TdXNwZW5zaW9uQ29tcGxldGUiLCAiX191IiwgInN0YXRlIiwgIl9fYSIsICJzdXNwZW5kZWRWTm9kZSIsICJfX2siLCAicmVtb3ZlT3JpZ2luYWwiLCAic2V0U3RhdGUiLCAiX19iIiwgInBvcCIsICJmb3JjZVVwZGF0ZSIsICJ3YXNIeWRyYXRpbmciLCAidGhlbiIsICJjb21wb25lbnRXaWxsVW5tb3VudCIsICJyZW5kZXIiLCAicHJvcHMiLCAiZGV0YWNoZWRQYXJlbnQiLCAiZG9jdW1lbnQiLCAiY3JlYXRlRWxlbWVudCIsICJkZXRhY2hlZENvbXBvbmVudCIsICJkZXRhY2hlZENsb25lIiwgIl9fTyIsICJfX1AiLCAiZmFsbGJhY2siLCAiRnJhZ21lbnQiLCAiY2hpbGRyZW4iLCAibGlzdCIsICJjaGlsZCIsICJub2RlIiwgImRlbGV0ZSIsICJyZXZlYWxPcmRlciIsICJzaXplIiwgImxlbmd0aCIsICJDb250ZXh0UHJvdmlkZXIiLCAiZ2V0Q2hpbGRDb250ZXh0IiwgImNvbnRleHQiLCAiUG9ydGFsIiwgIl90aGlzIiwgImNvbnRhaW5lciIsICJfY29udGFpbmVyIiwgIl90ZW1wIiwgIm5vZGVUeXBlIiwgInBhcmVudE5vZGUiLCAiY2hpbGROb2RlcyIsICJhcHBlbmRDaGlsZCIsICJpbnNlcnRCZWZvcmUiLCAiYmVmb3JlIiwgInJlbW92ZUNoaWxkIiwgInNwbGljZSIsICJpbmRleE9mIiwgImNyZWF0ZVBvcnRhbCIsICJlbCIsICJjb250YWluZXJJbmZvIiwgImRlbGVnYXRlZCIsICJnZXQiLCAidW5zdXNwZW5kIiwgIndyYXBwZWRVbnN1c3BlbmQiLCAiTWFwIiwgInRvQ2hpbGRBcnJheSIsICJyZXZlcnNlIiwgImkiLCAic2V0IiwgImNvbXBvbmVudERpZFVwZGF0ZSIsICJjb21wb25lbnREaWRNb3VudCIsICJmb3JFYWNoIiwgIlJFQUNUX0VMRU1FTlRfVFlQRSIsICJTeW1ib2wiLCAiZm9yIiwgIkNBTUVMX1BST1BTIiwgIklTX0RPTSIsICJvbkNoYW5nZUlucHV0VHlwZSIsICJ0ZXN0IiwgIkNvbXBvbmVudCIsICJwcm90b3R5cGUiLCAiaXNSZWFjdENvbXBvbmVudCIsICJmb3JFYWNoIiwgImtleSIsICJPYmplY3QiLCAiZGVmaW5lUHJvcGVydHkiLCAiY29uZmlndXJhYmxlIiwgImdldCIsICJ0aGlzIiwgInNldCIsICJ2IiwgIndyaXRhYmxlIiwgInZhbHVlIiwgIm9sZEV2ZW50SG9vayIsICJvcHRpb25zIiwgImV2ZW50IiwgImVtcHR5IiwgImlzUHJvcGFnYXRpb25TdG9wcGVkIiwgImNhbmNlbEJ1YmJsZSIsICJpc0RlZmF1bHRQcmV2ZW50ZWQiLCAiZGVmYXVsdFByZXZlbnRlZCIsICJlIiwgInBlcnNpc3QiLCAibmF0aXZlRXZlbnQiLCAiY3VycmVudENvbXBvbmVudCIsICJjbGFzc05hbWVEZXNjcmlwdG9yIiwgImNsYXNzIiwgIm9sZFZOb2RlSG9vayIsICJ2bm9kZSIsICJ0eXBlIiwgInByb3BzIiwgIm5vcm1hbGl6ZWRQcm9wcyIsICJub25DdXN0b21FbGVtZW50IiwgImluZGV4T2YiLCAiaSIsICJJU19ET00iLCAidGVzdCIsICJvbkNoYW5nZUlucHV0VHlwZSIsICJ0b0xvd2VyQ2FzZSIsICJDQU1FTF9QUk9QUyIsICJyZXBsYWNlIiwgIm11bHRpcGxlIiwgIkFycmF5IiwgImlzQXJyYXkiLCAidG9DaGlsZEFycmF5IiwgImNoaWxkcmVuIiwgImNoaWxkIiwgInNlbGVjdGVkIiwgImRlZmF1bHRWYWx1ZSIsICJjbGFzc05hbWUiLCAiZW51bWVyYWJsZSIsICIkJHR5cGVvZiIsICJSRUFDVF9FTEVNRU5UX1RZUEUiLCAib2xkQmVmb3JlUmVuZGVyIiwgIl9fciIsICJfX2MiLCAiaSIsICJqIiwgImkiLCAiYSIsICJiIiwgInMiLCAiaW5kZXgiLCAibiIsICJtIiwgImQiLCAibiIsICJpIiwgImkiLCAibSIsICJuIiwgImEiLCAiZCIsICJ5IiwgInciLCAicyIsICJzIiwgImRpc3BsYXkiLCAiYSIsICJiIiwgImkiLCAiZCIsICJtIiwgIm4iLCAiYyIsICJpc09iamVjdCIsICJyYW5nZSIsICJyZXMiLCAiaSIsICJhIiwgImIiLCAibiIsICJpbmRleCIsICJhIiwgInJhbmdlIiwgImluZGV4IiwgImkiLCAiYSIsICJqIiwgImkiLCAiaiIsICJyYW5nZSIsICJkYXlzT2ZXZWVrIiwgImkiLCAiZGlzcGxheSIsICJyZW5kZXJJbm5lckNvbnRlbnQiLCAiY3NzXzI0OHoiLCAicmVuZGVySW5uZXJDb250ZW50IiwgIkRFRkFVTFRfV0VFS19OVU1fRk9STUFUIiwgInJhbmdlIiwgImkiLCAicmVuZGVyTW9yZUxpbmtJbm5lciIsICJhIiwgImIiLCAiY3NzXzI0OHoiLCAiaW5kZXgiLCAiV2Vla2RheSIsICJuIiwgInMiLCAiaSIsICJpIiwgInBhZFN0YXJ0IiwgImEiLCAiYiIsICJyIiwgInkiLCAibSIsICJkIiwgImgiLCAiaSIsICJzIiwgImlzVmFsaWREYXRlIiwgImkiLCAiYSIsICJiIiwgInBhZFN0YXJ0IiwgIkl0ZXJSZXN1bHQiLCAiZCIsICJiIiwgInAiLCAiX19hc3NpZ24iLCAidCIsICJzIiwgImkiLCAibiIsICJpIiwgImwiLCAiQ2FsbGJhY2tJdGVyUmVzdWx0IiwgIlRvVGV4dCIsICJhIiwgImIiLCAibiIsICJtIiwgInMiLCAiaSIsICJvIiwgIlBhcnNlciIsICJ2IiwgIlMiLCAibiIsICJGIiwgIm0iLCAiRnJlcXVlbmN5IiwgIlRpbWUiLCAiRGF0ZVRpbWUiLCAiaXNWYWxpZERhdGUiLCAiaSIsICJ2IiwgInBhcnNlU3RyaW5nIiwgIngiLCAibiIsICJEYXRlV2l0aFpvbmUiLCAiZGVmYXVsdEtleXMiLCAiaSIsICJqIiwgImtleSIsICJ2YWx1ZSIsICJ4IiwgImkiLCAiQ2FjaGUiLCAiaXRlbSIsICJpIiwgImoiLCAibiIsICJpIiwgImsiLCAiaiIsICJrIiwgImkiLCAibiIsICJ5IiwgImEiLCAiYiIsICJjIiwgImQiLCAiZSIsICJmIiwgImciLCAiaCIsICJpIiwgImsiLCAibCIsICJtIiwgIkl0ZXJpbmZvIiwgIl8iLCAiaSIsICJqIiwgImoiLCAiayIsICJpIiwgImoiLCAiayIsICJSUnVsZSIsICJpc1ZhbGlkRGF0ZSIsICJwYXJzZVN0cmluZyIsICJ6b25lZERhdGUiLCAiaSIsICJERUZBVUxUX09QVElPTlMiLCAicyIsICJwYXJzZVN0cmluZyIsICJ2YWwiLCAiaW5pdGlhbGl6ZU9wdGlvbnMiLCAiZGVmYXVsdEtleXMiLCAiaSIsICJpIiwgIlJSdWxlU2V0IiwgImUiLCAiaW5kZXgiLCAicmVuZGVySW5uZXJDb250ZW50IiwgIkRFRkFVTFRfVElNRV9GT1JNQVQiLCAicmVuZGVyQWxsRGF5SW5uZXIiLCAicmFuZ2UiLCAiaSIsICJjc3NfMjQ4eiIsICJPUFRJT05fUkVGSU5FUlMiLCAiaW5kZXgiLCAiZHJhZ2dpbmciLCAiY29tcG9uZW50IiwgIm9wdGlvbnMiLCAiY29udGV4dCIsICJkb2N1bWVudFBvaW50ZXIiLCAiT1BUSU9OX1JFRklORVJTIiwgImluZGV4IiwgIk9QVElPTl9SRUZJTkVSUyIsICJldmVudFNvdXJjZURlZiIsICJidWlsZFJlcXVlc3RQYXJhbXMiLCAicmFuZ2UiLCAiT1BUSU9OX1JFRklORVJTIiwgIkVWRU5UX1NPVVJDRV9SRUZJTkVSUyIsICJpbmRleCIsICJlIiwgImkiLCAic3RhcnRUaW1lIiwgImVuZFRpbWUiLCAiZXZlbnRTb3VyY2VEZWYiLCAicmFuZ2UiLCAiaW5kZXgiLCAiaW5kZXgiLCAiZCIsICJlIiwgIl8iLCAiZSIsICJpbXBvcnRfb2JzaWRpYW4iLCAiQ2FjaGUiLCAiXyIsICJpIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbmRleCIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgIkNhY2hlIl0KfQo=
