/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// node_modules/obsidian-dataview/lib/index.js
var require_lib = __commonJS({
  "node_modules/obsidian-dataview/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    require("obsidian");
    var LuxonError = class extends Error {
    };
    var InvalidDateTimeError = class extends LuxonError {
      constructor(reason) {
        super(`Invalid DateTime: ${reason.toMessage()}`);
      }
    };
    var InvalidIntervalError = class extends LuxonError {
      constructor(reason) {
        super(`Invalid Interval: ${reason.toMessage()}`);
      }
    };
    var InvalidDurationError = class extends LuxonError {
      constructor(reason) {
        super(`Invalid Duration: ${reason.toMessage()}`);
      }
    };
    var ConflictingSpecificationError = class extends LuxonError {
    };
    var InvalidUnitError = class extends LuxonError {
      constructor(unit) {
        super(`Invalid unit ${unit}`);
      }
    };
    var InvalidArgumentError = class extends LuxonError {
    };
    var ZoneIsAbstractError = class extends LuxonError {
      constructor() {
        super("Zone is an abstract class");
      }
    };
    var n2 = "numeric";
    var s3 = "short";
    var l3 = "long";
    var DATE_SHORT = {
      year: n2,
      month: n2,
      day: n2
    };
    var DATE_MED = {
      year: n2,
      month: s3,
      day: n2
    };
    var DATE_MED_WITH_WEEKDAY = {
      year: n2,
      month: s3,
      day: n2,
      weekday: s3
    };
    var DATE_FULL = {
      year: n2,
      month: l3,
      day: n2
    };
    var DATE_HUGE = {
      year: n2,
      month: l3,
      day: n2,
      weekday: l3
    };
    var TIME_SIMPLE = {
      hour: n2,
      minute: n2
    };
    var TIME_WITH_SECONDS = {
      hour: n2,
      minute: n2,
      second: n2
    };
    var TIME_WITH_SHORT_OFFSET = {
      hour: n2,
      minute: n2,
      second: n2,
      timeZoneName: s3
    };
    var TIME_WITH_LONG_OFFSET = {
      hour: n2,
      minute: n2,
      second: n2,
      timeZoneName: l3
    };
    var TIME_24_SIMPLE = {
      hour: n2,
      minute: n2,
      hourCycle: "h23"
    };
    var TIME_24_WITH_SECONDS = {
      hour: n2,
      minute: n2,
      second: n2,
      hourCycle: "h23"
    };
    var TIME_24_WITH_SHORT_OFFSET = {
      hour: n2,
      minute: n2,
      second: n2,
      hourCycle: "h23",
      timeZoneName: s3
    };
    var TIME_24_WITH_LONG_OFFSET = {
      hour: n2,
      minute: n2,
      second: n2,
      hourCycle: "h23",
      timeZoneName: l3
    };
    var DATETIME_SHORT = {
      year: n2,
      month: n2,
      day: n2,
      hour: n2,
      minute: n2
    };
    var DATETIME_SHORT_WITH_SECONDS = {
      year: n2,
      month: n2,
      day: n2,
      hour: n2,
      minute: n2,
      second: n2
    };
    var DATETIME_MED = {
      year: n2,
      month: s3,
      day: n2,
      hour: n2,
      minute: n2
    };
    var DATETIME_MED_WITH_SECONDS = {
      year: n2,
      month: s3,
      day: n2,
      hour: n2,
      minute: n2,
      second: n2
    };
    var DATETIME_MED_WITH_WEEKDAY = {
      year: n2,
      month: s3,
      day: n2,
      weekday: s3,
      hour: n2,
      minute: n2
    };
    var DATETIME_FULL = {
      year: n2,
      month: l3,
      day: n2,
      hour: n2,
      minute: n2,
      timeZoneName: s3
    };
    var DATETIME_FULL_WITH_SECONDS = {
      year: n2,
      month: l3,
      day: n2,
      hour: n2,
      minute: n2,
      second: n2,
      timeZoneName: s3
    };
    var DATETIME_HUGE = {
      year: n2,
      month: l3,
      day: n2,
      weekday: l3,
      hour: n2,
      minute: n2,
      timeZoneName: l3
    };
    var DATETIME_HUGE_WITH_SECONDS = {
      year: n2,
      month: l3,
      day: n2,
      weekday: l3,
      hour: n2,
      minute: n2,
      second: n2,
      timeZoneName: l3
    };
    var Zone = class {
      /**
       * The type of zone
       * @abstract
       * @type {string}
       */
      get type() {
        throw new ZoneIsAbstractError();
      }
      /**
       * The name of this zone.
       * @abstract
       * @type {string}
       */
      get name() {
        throw new ZoneIsAbstractError();
      }
      get ianaName() {
        return this.name;
      }
      /**
       * Returns whether the offset is known to be fixed for the whole year.
       * @abstract
       * @type {boolean}
       */
      get isUniversal() {
        throw new ZoneIsAbstractError();
      }
      /**
       * Returns the offset's common name (such as EST) at the specified timestamp
       * @abstract
       * @param {number} ts - Epoch milliseconds for which to get the name
       * @param {Object} opts - Options to affect the format
       * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
       * @param {string} opts.locale - What locale to return the offset name in.
       * @return {string}
       */
      offsetName(ts, opts) {
        throw new ZoneIsAbstractError();
      }
      /**
       * Returns the offset's value as a string
       * @abstract
       * @param {number} ts - Epoch milliseconds for which to get the offset
       * @param {string} format - What style of offset to return.
       *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
       * @return {string}
       */
      formatOffset(ts, format) {
        throw new ZoneIsAbstractError();
      }
      /**
       * Return the offset in minutes for this zone at the specified timestamp.
       * @abstract
       * @param {number} ts - Epoch milliseconds for which to compute the offset
       * @return {number}
       */
      offset(ts) {
        throw new ZoneIsAbstractError();
      }
      /**
       * Return whether this Zone is equal to another zone
       * @abstract
       * @param {Zone} otherZone - the zone to compare
       * @return {boolean}
       */
      equals(otherZone) {
        throw new ZoneIsAbstractError();
      }
      /**
       * Return whether this Zone is valid.
       * @abstract
       * @type {boolean}
       */
      get isValid() {
        throw new ZoneIsAbstractError();
      }
    };
    var singleton$1 = null;
    var SystemZone = class extends Zone {
      /**
       * Get a singleton instance of the local zone
       * @return {SystemZone}
       */
      static get instance() {
        if (singleton$1 === null) {
          singleton$1 = new SystemZone();
        }
        return singleton$1;
      }
      /** @override **/
      get type() {
        return "system";
      }
      /** @override **/
      get name() {
        return new Intl.DateTimeFormat().resolvedOptions().timeZone;
      }
      /** @override **/
      get isUniversal() {
        return false;
      }
      /** @override **/
      offsetName(ts, { format, locale }) {
        return parseZoneInfo(ts, format, locale);
      }
      /** @override **/
      formatOffset(ts, format) {
        return formatOffset(this.offset(ts), format);
      }
      /** @override **/
      offset(ts) {
        return -new Date(ts).getTimezoneOffset();
      }
      /** @override **/
      equals(otherZone) {
        return otherZone.type === "system";
      }
      /** @override **/
      get isValid() {
        return true;
      }
    };
    var dtfCache = {};
    function makeDTF(zone) {
      if (!dtfCache[zone]) {
        dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
          hour12: false,
          timeZone: zone,
          year: "numeric",
          month: "2-digit",
          day: "2-digit",
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit",
          era: "short"
        });
      }
      return dtfCache[zone];
    }
    var typeToPos = {
      year: 0,
      month: 1,
      day: 2,
      era: 3,
      hour: 4,
      minute: 5,
      second: 6
    };
    function hackyOffset(dtf, date) {
      const formatted = dtf.format(date).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted), [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
      return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
    }
    function partsOffset(dtf, date) {
      const formatted = dtf.formatToParts(date);
      const filled = [];
      for (let i3 = 0; i3 < formatted.length; i3++) {
        const { type, value } = formatted[i3];
        const pos = typeToPos[type];
        if (type === "era") {
          filled[pos] = value;
        } else if (!isUndefined(pos)) {
          filled[pos] = parseInt(value, 10);
        }
      }
      return filled;
    }
    var ianaZoneCache = {};
    var IANAZone = class extends Zone {
      /**
       * @param {string} name - Zone name
       * @return {IANAZone}
       */
      static create(name) {
        if (!ianaZoneCache[name]) {
          ianaZoneCache[name] = new IANAZone(name);
        }
        return ianaZoneCache[name];
      }
      /**
       * Reset local caches. Should only be necessary in testing scenarios.
       * @return {void}
       */
      static resetCache() {
        ianaZoneCache = {};
        dtfCache = {};
      }
      /**
       * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
       * @param {string} s - The string to check validity on
       * @example IANAZone.isValidSpecifier("America/New_York") //=> true
       * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
       * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.
       * @return {boolean}
       */
      static isValidSpecifier(s4) {
        return this.isValidZone(s4);
      }
      /**
       * Returns whether the provided string identifies a real zone
       * @param {string} zone - The string to check
       * @example IANAZone.isValidZone("America/New_York") //=> true
       * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
       * @example IANAZone.isValidZone("Sport~~blorp") //=> false
       * @return {boolean}
       */
      static isValidZone(zone) {
        if (!zone) {
          return false;
        }
        try {
          new Intl.DateTimeFormat("en-US", { timeZone: zone }).format();
          return true;
        } catch (e3) {
          return false;
        }
      }
      constructor(name) {
        super();
        this.zoneName = name;
        this.valid = IANAZone.isValidZone(name);
      }
      /** @override **/
      get type() {
        return "iana";
      }
      /** @override **/
      get name() {
        return this.zoneName;
      }
      /** @override **/
      get isUniversal() {
        return false;
      }
      /** @override **/
      offsetName(ts, { format, locale }) {
        return parseZoneInfo(ts, format, locale, this.name);
      }
      /** @override **/
      formatOffset(ts, format) {
        return formatOffset(this.offset(ts), format);
      }
      /** @override **/
      offset(ts) {
        const date = new Date(ts);
        if (isNaN(date))
          return NaN;
        const dtf = makeDTF(this.name);
        let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date);
        if (adOrBc === "BC") {
          year = -Math.abs(year) + 1;
        }
        const adjustedHour = hour === 24 ? 0 : hour;
        const asUTC = objToLocalTS({
          year,
          month,
          day,
          hour: adjustedHour,
          minute,
          second,
          millisecond: 0
        });
        let asTS = +date;
        const over = asTS % 1e3;
        asTS -= over >= 0 ? over : 1e3 + over;
        return (asUTC - asTS) / (60 * 1e3);
      }
      /** @override **/
      equals(otherZone) {
        return otherZone.type === "iana" && otherZone.name === this.name;
      }
      /** @override **/
      get isValid() {
        return this.valid;
      }
    };
    var intlLFCache = {};
    function getCachedLF(locString, opts = {}) {
      const key = JSON.stringify([locString, opts]);
      let dtf = intlLFCache[key];
      if (!dtf) {
        dtf = new Intl.ListFormat(locString, opts);
        intlLFCache[key] = dtf;
      }
      return dtf;
    }
    var intlDTCache = {};
    function getCachedDTF(locString, opts = {}) {
      const key = JSON.stringify([locString, opts]);
      let dtf = intlDTCache[key];
      if (!dtf) {
        dtf = new Intl.DateTimeFormat(locString, opts);
        intlDTCache[key] = dtf;
      }
      return dtf;
    }
    var intlNumCache = {};
    function getCachedINF(locString, opts = {}) {
      const key = JSON.stringify([locString, opts]);
      let inf = intlNumCache[key];
      if (!inf) {
        inf = new Intl.NumberFormat(locString, opts);
        intlNumCache[key] = inf;
      }
      return inf;
    }
    var intlRelCache = {};
    function getCachedRTF(locString, opts = {}) {
      const { base, ...cacheKeyOpts } = opts;
      const key = JSON.stringify([locString, cacheKeyOpts]);
      let inf = intlRelCache[key];
      if (!inf) {
        inf = new Intl.RelativeTimeFormat(locString, opts);
        intlRelCache[key] = inf;
      }
      return inf;
    }
    var sysLocaleCache = null;
    function systemLocale() {
      if (sysLocaleCache) {
        return sysLocaleCache;
      } else {
        sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
        return sysLocaleCache;
      }
    }
    function parseLocaleString(localeStr) {
      const xIndex = localeStr.indexOf("-x-");
      if (xIndex !== -1) {
        localeStr = localeStr.substring(0, xIndex);
      }
      const uIndex = localeStr.indexOf("-u-");
      if (uIndex === -1) {
        return [localeStr];
      } else {
        let options;
        let selectedStr;
        try {
          options = getCachedDTF(localeStr).resolvedOptions();
          selectedStr = localeStr;
        } catch (e3) {
          const smaller = localeStr.substring(0, uIndex);
          options = getCachedDTF(smaller).resolvedOptions();
          selectedStr = smaller;
        }
        const { numberingSystem, calendar } = options;
        return [selectedStr, numberingSystem, calendar];
      }
    }
    function intlConfigString(localeStr, numberingSystem, outputCalendar) {
      if (outputCalendar || numberingSystem) {
        if (!localeStr.includes("-u-")) {
          localeStr += "-u";
        }
        if (outputCalendar) {
          localeStr += `-ca-${outputCalendar}`;
        }
        if (numberingSystem) {
          localeStr += `-nu-${numberingSystem}`;
        }
        return localeStr;
      } else {
        return localeStr;
      }
    }
    function mapMonths(f3) {
      const ms = [];
      for (let i3 = 1; i3 <= 12; i3++) {
        const dt = DateTime2.utc(2009, i3, 1);
        ms.push(f3(dt));
      }
      return ms;
    }
    function mapWeekdays(f3) {
      const ms = [];
      for (let i3 = 1; i3 <= 7; i3++) {
        const dt = DateTime2.utc(2016, 11, 13 + i3);
        ms.push(f3(dt));
      }
      return ms;
    }
    function listStuff(loc, length, englishFn, intlFn) {
      const mode = loc.listingMode();
      if (mode === "error") {
        return null;
      } else if (mode === "en") {
        return englishFn(length);
      } else {
        return intlFn(length);
      }
    }
    function supportsFastNumbers(loc) {
      if (loc.numberingSystem && loc.numberingSystem !== "latn") {
        return false;
      } else {
        return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
      }
    }
    var PolyNumberFormatter = class {
      constructor(intl, forceSimple, opts) {
        this.padTo = opts.padTo || 0;
        this.floor = opts.floor || false;
        const { padTo, floor, ...otherOpts } = opts;
        if (!forceSimple || Object.keys(otherOpts).length > 0) {
          const intlOpts = { useGrouping: false, ...opts };
          if (opts.padTo > 0)
            intlOpts.minimumIntegerDigits = opts.padTo;
          this.inf = getCachedINF(intl, intlOpts);
        }
      }
      format(i3) {
        if (this.inf) {
          const fixed = this.floor ? Math.floor(i3) : i3;
          return this.inf.format(fixed);
        } else {
          const fixed = this.floor ? Math.floor(i3) : roundTo(i3, 3);
          return padStart3(fixed, this.padTo);
        }
      }
    };
    var PolyDateFormatter = class {
      constructor(dt, intl, opts) {
        this.opts = opts;
        this.originalZone = void 0;
        let z3 = void 0;
        if (this.opts.timeZone) {
          this.dt = dt;
        } else if (dt.zone.type === "fixed") {
          const gmtOffset = -1 * (dt.offset / 60);
          const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
          if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
            z3 = offsetZ;
            this.dt = dt;
          } else {
            z3 = "UTC";
            this.dt = dt.offset === 0 ? dt : dt.setZone("UTC").plus({ minutes: dt.offset });
            this.originalZone = dt.zone;
          }
        } else if (dt.zone.type === "system") {
          this.dt = dt;
        } else if (dt.zone.type === "iana") {
          this.dt = dt;
          z3 = dt.zone.name;
        } else {
          z3 = "UTC";
          this.dt = dt.setZone("UTC").plus({ minutes: dt.offset });
          this.originalZone = dt.zone;
        }
        const intlOpts = { ...this.opts };
        intlOpts.timeZone = intlOpts.timeZone || z3;
        this.dtf = getCachedDTF(intl, intlOpts);
      }
      format() {
        if (this.originalZone) {
          return this.formatToParts().map(({ value }) => value).join("");
        }
        return this.dtf.format(this.dt.toJSDate());
      }
      formatToParts() {
        const parts = this.dtf.formatToParts(this.dt.toJSDate());
        if (this.originalZone) {
          return parts.map((part) => {
            if (part.type === "timeZoneName") {
              const offsetName = this.originalZone.offsetName(this.dt.ts, {
                locale: this.dt.locale,
                format: this.opts.timeZoneName
              });
              return {
                ...part,
                value: offsetName
              };
            } else {
              return part;
            }
          });
        }
        return parts;
      }
      resolvedOptions() {
        return this.dtf.resolvedOptions();
      }
    };
    var PolyRelFormatter = class {
      constructor(intl, isEnglish, opts) {
        this.opts = { style: "long", ...opts };
        if (!isEnglish && hasRelative()) {
          this.rtf = getCachedRTF(intl, opts);
        }
      }
      format(count, unit) {
        if (this.rtf) {
          return this.rtf.format(count, unit);
        } else {
          return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
        }
      }
      formatToParts(count, unit) {
        if (this.rtf) {
          return this.rtf.formatToParts(count, unit);
        } else {
          return [];
        }
      }
    };
    var Locale = class {
      static fromOpts(opts) {
        return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);
      }
      static create(locale, numberingSystem, outputCalendar, defaultToEN = false) {
        const specifiedLocale = locale || Settings.defaultLocale;
        const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
        const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
        const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
        return new Locale(localeR, numberingSystemR, outputCalendarR, specifiedLocale);
      }
      static resetCache() {
        sysLocaleCache = null;
        intlDTCache = {};
        intlNumCache = {};
        intlRelCache = {};
      }
      static fromObject({ locale, numberingSystem, outputCalendar } = {}) {
        return Locale.create(locale, numberingSystem, outputCalendar);
      }
      constructor(locale, numbering, outputCalendar, specifiedLocale) {
        const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);
        this.locale = parsedLocale;
        this.numberingSystem = numbering || parsedNumberingSystem || null;
        this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
        this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
        this.weekdaysCache = { format: {}, standalone: {} };
        this.monthsCache = { format: {}, standalone: {} };
        this.meridiemCache = null;
        this.eraCache = {};
        this.specifiedLocale = specifiedLocale;
        this.fastNumbersCached = null;
      }
      get fastNumbers() {
        if (this.fastNumbersCached == null) {
          this.fastNumbersCached = supportsFastNumbers(this);
        }
        return this.fastNumbersCached;
      }
      listingMode() {
        const isActuallyEn = this.isEnglish();
        const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
        return isActuallyEn && hasNoWeirdness ? "en" : "intl";
      }
      clone(alts) {
        if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
          return this;
        } else {
          return Locale.create(
            alts.locale || this.specifiedLocale,
            alts.numberingSystem || this.numberingSystem,
            alts.outputCalendar || this.outputCalendar,
            alts.defaultToEN || false
          );
        }
      }
      redefaultToEN(alts = {}) {
        return this.clone({ ...alts, defaultToEN: true });
      }
      redefaultToSystem(alts = {}) {
        return this.clone({ ...alts, defaultToEN: false });
      }
      months(length, format = false) {
        return listStuff(this, length, months, () => {
          const intl = format ? { month: length, day: "numeric" } : { month: length }, formatStr = format ? "format" : "standalone";
          if (!this.monthsCache[formatStr][length]) {
            this.monthsCache[formatStr][length] = mapMonths((dt) => this.extract(dt, intl, "month"));
          }
          return this.monthsCache[formatStr][length];
        });
      }
      weekdays(length, format = false) {
        return listStuff(this, length, weekdays, () => {
          const intl = format ? { weekday: length, year: "numeric", month: "long", day: "numeric" } : { weekday: length }, formatStr = format ? "format" : "standalone";
          if (!this.weekdaysCache[formatStr][length]) {
            this.weekdaysCache[formatStr][length] = mapWeekdays(
              (dt) => this.extract(dt, intl, "weekday")
            );
          }
          return this.weekdaysCache[formatStr][length];
        });
      }
      meridiems() {
        return listStuff(
          this,
          void 0,
          () => meridiems,
          () => {
            if (!this.meridiemCache) {
              const intl = { hour: "numeric", hourCycle: "h12" };
              this.meridiemCache = [DateTime2.utc(2016, 11, 13, 9), DateTime2.utc(2016, 11, 13, 19)].map(
                (dt) => this.extract(dt, intl, "dayperiod")
              );
            }
            return this.meridiemCache;
          }
        );
      }
      eras(length) {
        return listStuff(this, length, eras, () => {
          const intl = { era: length };
          if (!this.eraCache[length]) {
            this.eraCache[length] = [DateTime2.utc(-40, 1, 1), DateTime2.utc(2017, 1, 1)].map(
              (dt) => this.extract(dt, intl, "era")
            );
          }
          return this.eraCache[length];
        });
      }
      extract(dt, intlOpts, field) {
        const df = this.dtFormatter(dt, intlOpts), results = df.formatToParts(), matching = results.find((m3) => m3.type.toLowerCase() === field);
        return matching ? matching.value : null;
      }
      numberFormatter(opts = {}) {
        return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
      }
      dtFormatter(dt, intlOpts = {}) {
        return new PolyDateFormatter(dt, this.intl, intlOpts);
      }
      relFormatter(opts = {}) {
        return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
      }
      listFormatter(opts = {}) {
        return getCachedLF(this.intl, opts);
      }
      isEnglish() {
        return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
      }
      equals(other) {
        return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
      }
    };
    var singleton = null;
    var FixedOffsetZone = class extends Zone {
      /**
       * Get a singleton instance of UTC
       * @return {FixedOffsetZone}
       */
      static get utcInstance() {
        if (singleton === null) {
          singleton = new FixedOffsetZone(0);
        }
        return singleton;
      }
      /**
       * Get an instance with a specified offset
       * @param {number} offset - The offset in minutes
       * @return {FixedOffsetZone}
       */
      static instance(offset2) {
        return offset2 === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset2);
      }
      /**
       * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
       * @param {string} s - The offset string to parse
       * @example FixedOffsetZone.parseSpecifier("UTC+6")
       * @example FixedOffsetZone.parseSpecifier("UTC+06")
       * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
       * @return {FixedOffsetZone}
       */
      static parseSpecifier(s4) {
        if (s4) {
          const r3 = s4.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
          if (r3) {
            return new FixedOffsetZone(signedOffset(r3[1], r3[2]));
          }
        }
        return null;
      }
      constructor(offset2) {
        super();
        this.fixed = offset2;
      }
      /** @override **/
      get type() {
        return "fixed";
      }
      /** @override **/
      get name() {
        return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`;
      }
      get ianaName() {
        if (this.fixed === 0) {
          return "Etc/UTC";
        } else {
          return `Etc/GMT${formatOffset(-this.fixed, "narrow")}`;
        }
      }
      /** @override **/
      offsetName() {
        return this.name;
      }
      /** @override **/
      formatOffset(ts, format) {
        return formatOffset(this.fixed, format);
      }
      /** @override **/
      get isUniversal() {
        return true;
      }
      /** @override **/
      offset() {
        return this.fixed;
      }
      /** @override **/
      equals(otherZone) {
        return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
      }
      /** @override **/
      get isValid() {
        return true;
      }
    };
    var InvalidZone = class extends Zone {
      constructor(zoneName) {
        super();
        this.zoneName = zoneName;
      }
      /** @override **/
      get type() {
        return "invalid";
      }
      /** @override **/
      get name() {
        return this.zoneName;
      }
      /** @override **/
      get isUniversal() {
        return false;
      }
      /** @override **/
      offsetName() {
        return null;
      }
      /** @override **/
      formatOffset() {
        return "";
      }
      /** @override **/
      offset() {
        return NaN;
      }
      /** @override **/
      equals() {
        return false;
      }
      /** @override **/
      get isValid() {
        return false;
      }
    };
    function normalizeZone(input, defaultZone2) {
      if (isUndefined(input) || input === null) {
        return defaultZone2;
      } else if (input instanceof Zone) {
        return input;
      } else if (isString(input)) {
        const lowered = input.toLowerCase();
        if (lowered === "default")
          return defaultZone2;
        else if (lowered === "local" || lowered === "system")
          return SystemZone.instance;
        else if (lowered === "utc" || lowered === "gmt")
          return FixedOffsetZone.utcInstance;
        else
          return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input);
      } else if (isNumber2(input)) {
        return FixedOffsetZone.instance(input);
      } else if (typeof input === "object" && "offset" in input && typeof input.offset === "function") {
        return input;
      } else {
        return new InvalidZone(input);
      }
    }
    var now = () => Date.now();
    var defaultZone = "system";
    var defaultLocale = null;
    var defaultNumberingSystem = null;
    var defaultOutputCalendar = null;
    var twoDigitCutoffYear = 60;
    var throwOnInvalid;
    var Settings = class {
      /**
       * Get the callback for returning the current timestamp.
       * @type {function}
       */
      static get now() {
        return now;
      }
      /**
       * Set the callback for returning the current timestamp.
       * The function should return a number, which will be interpreted as an Epoch millisecond count
       * @type {function}
       * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
       * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
       */
      static set now(n3) {
        now = n3;
      }
      /**
       * Set the default time zone to create DateTimes in. Does not affect existing instances.
       * Use the value "system" to reset this value to the system's time zone.
       * @type {string}
       */
      static set defaultZone(zone) {
        defaultZone = zone;
      }
      /**
       * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
       * The default value is the system's time zone (the one set on the machine that runs this code).
       * @type {Zone}
       */
      static get defaultZone() {
        return normalizeZone(defaultZone, SystemZone.instance);
      }
      /**
       * Get the default locale to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static get defaultLocale() {
        return defaultLocale;
      }
      /**
       * Set the default locale to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static set defaultLocale(locale) {
        defaultLocale = locale;
      }
      /**
       * Get the default numbering system to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static get defaultNumberingSystem() {
        return defaultNumberingSystem;
      }
      /**
       * Set the default numbering system to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static set defaultNumberingSystem(numberingSystem) {
        defaultNumberingSystem = numberingSystem;
      }
      /**
       * Get the default output calendar to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static get defaultOutputCalendar() {
        return defaultOutputCalendar;
      }
      /**
       * Set the default output calendar to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static set defaultOutputCalendar(outputCalendar) {
        defaultOutputCalendar = outputCalendar;
      }
      /**
       * Get the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
       * @type {number}
       */
      static get twoDigitCutoffYear() {
        return twoDigitCutoffYear;
      }
      /**
       * Set the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
       * @type {number}
       * @example Settings.twoDigitCutoffYear = 0 // cut-off year is 0, so all 'yy' are interpreted as current century
       * @example Settings.twoDigitCutoffYear = 50 // '49' -> 1949; '50' -> 2050
       * @example Settings.twoDigitCutoffYear = 1950 // interpreted as 50
       * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpreted as 50
       */
      static set twoDigitCutoffYear(cutoffYear) {
        twoDigitCutoffYear = cutoffYear % 100;
      }
      /**
       * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
       * @type {boolean}
       */
      static get throwOnInvalid() {
        return throwOnInvalid;
      }
      /**
       * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
       * @type {boolean}
       */
      static set throwOnInvalid(t3) {
        throwOnInvalid = t3;
      }
      /**
       * Reset Luxon's global caches. Should only be necessary in testing scenarios.
       * @return {void}
       */
      static resetCaches() {
        Locale.resetCache();
        IANAZone.resetCache();
      }
    };
    function isUndefined(o2) {
      return typeof o2 === "undefined";
    }
    function isNumber2(o2) {
      return typeof o2 === "number";
    }
    function isInteger(o2) {
      return typeof o2 === "number" && o2 % 1 === 0;
    }
    function isString(o2) {
      return typeof o2 === "string";
    }
    function isDate2(o2) {
      return Object.prototype.toString.call(o2) === "[object Date]";
    }
    function hasRelative() {
      try {
        return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
      } catch (e3) {
        return false;
      }
    }
    function maybeArray(thing) {
      return Array.isArray(thing) ? thing : [thing];
    }
    function bestBy(arr, by, compare) {
      if (arr.length === 0) {
        return void 0;
      }
      return arr.reduce((best, next) => {
        const pair = [by(next), next];
        if (!best) {
          return pair;
        } else if (compare(best[0], pair[0]) === best[0]) {
          return best;
        } else {
          return pair;
        }
      }, null)[1];
    }
    function pick(obj, keys) {
      return keys.reduce((a3, k3) => {
        a3[k3] = obj[k3];
        return a3;
      }, {});
    }
    function hasOwnProperty2(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    function integerBetween(thing, bottom, top) {
      return isInteger(thing) && thing >= bottom && thing <= top;
    }
    function floorMod(x4, n3) {
      return x4 - n3 * Math.floor(x4 / n3);
    }
    function padStart3(input, n3 = 2) {
      const isNeg = input < 0;
      let padded;
      if (isNeg) {
        padded = "-" + ("" + -input).padStart(n3, "0");
      } else {
        padded = ("" + input).padStart(n3, "0");
      }
      return padded;
    }
    function parseInteger(string) {
      if (isUndefined(string) || string === null || string === "") {
        return void 0;
      } else {
        return parseInt(string, 10);
      }
    }
    function parseFloating(string) {
      if (isUndefined(string) || string === null || string === "") {
        return void 0;
      } else {
        return parseFloat(string);
      }
    }
    function parseMillis(fraction) {
      if (isUndefined(fraction) || fraction === null || fraction === "") {
        return void 0;
      } else {
        const f3 = parseFloat("0." + fraction) * 1e3;
        return Math.floor(f3);
      }
    }
    function roundTo(number, digits, towardZero = false) {
      const factor = 10 ** digits, rounder = towardZero ? Math.trunc : Math.round;
      return rounder(number * factor) / factor;
    }
    function isLeapYear2(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    function daysInYear(year) {
      return isLeapYear2(year) ? 366 : 365;
    }
    function daysInMonth(year, month) {
      const modMonth = floorMod(month - 1, 12) + 1, modYear = year + (month - modMonth) / 12;
      if (modMonth === 2) {
        return isLeapYear2(modYear) ? 29 : 28;
      } else {
        return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
      }
    }
    function objToLocalTS(obj) {
      let d2 = Date.UTC(
        obj.year,
        obj.month - 1,
        obj.day,
        obj.hour,
        obj.minute,
        obj.second,
        obj.millisecond
      );
      if (obj.year < 100 && obj.year >= 0) {
        d2 = new Date(d2);
        d2.setUTCFullYear(obj.year, obj.month - 1, obj.day);
      }
      return +d2;
    }
    function weeksInWeekYear(weekYear) {
      const p1 = (weekYear + Math.floor(weekYear / 4) - Math.floor(weekYear / 100) + Math.floor(weekYear / 400)) % 7, last = weekYear - 1, p22 = (last + Math.floor(last / 4) - Math.floor(last / 100) + Math.floor(last / 400)) % 7;
      return p1 === 4 || p22 === 3 ? 53 : 52;
    }
    function untruncateYear(year) {
      if (year > 99) {
        return year;
      } else
        return year > Settings.twoDigitCutoffYear ? 1900 + year : 2e3 + year;
    }
    function parseZoneInfo(ts, offsetFormat, locale, timeZone = null) {
      const date = new Date(ts), intlOpts = {
        hourCycle: "h23",
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit"
      };
      if (timeZone) {
        intlOpts.timeZone = timeZone;
      }
      const modified = { timeZoneName: offsetFormat, ...intlOpts };
      const parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date).find((m3) => m3.type.toLowerCase() === "timezonename");
      return parsed ? parsed.value : null;
    }
    function signedOffset(offHourStr, offMinuteStr) {
      let offHour = parseInt(offHourStr, 10);
      if (Number.isNaN(offHour)) {
        offHour = 0;
      }
      const offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
      return offHour * 60 + offMinSigned;
    }
    function asNumber(value) {
      const numericValue = Number(value);
      if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue))
        throw new InvalidArgumentError(`Invalid unit value ${value}`);
      return numericValue;
    }
    function normalizeObject(obj, normalizer) {
      const normalized = {};
      for (const u3 in obj) {
        if (hasOwnProperty2(obj, u3)) {
          const v3 = obj[u3];
          if (v3 === void 0 || v3 === null)
            continue;
          normalized[normalizer(u3)] = asNumber(v3);
        }
      }
      return normalized;
    }
    function formatOffset(offset2, format) {
      const hours = Math.trunc(Math.abs(offset2 / 60)), minutes = Math.trunc(Math.abs(offset2 % 60)), sign = offset2 >= 0 ? "+" : "-";
      switch (format) {
        case "short":
          return `${sign}${padStart3(hours, 2)}:${padStart3(minutes, 2)}`;
        case "narrow":
          return `${sign}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
        case "techie":
          return `${sign}${padStart3(hours, 2)}${padStart3(minutes, 2)}`;
        default:
          throw new RangeError(`Value format ${format} is out of range for property format`);
      }
    }
    function timeObject(obj) {
      return pick(obj, ["hour", "minute", "second", "millisecond"]);
    }
    var monthsLong = [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ];
    var monthsShort = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    var monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
    function months(length) {
      switch (length) {
        case "narrow":
          return [...monthsNarrow];
        case "short":
          return [...monthsShort];
        case "long":
          return [...monthsLong];
        case "numeric":
          return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
        case "2-digit":
          return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
        default:
          return null;
      }
    }
    var weekdaysLong = [
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday",
      "Sunday"
    ];
    var weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
    var weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
    function weekdays(length) {
      switch (length) {
        case "narrow":
          return [...weekdaysNarrow];
        case "short":
          return [...weekdaysShort];
        case "long":
          return [...weekdaysLong];
        case "numeric":
          return ["1", "2", "3", "4", "5", "6", "7"];
        default:
          return null;
      }
    }
    var meridiems = ["AM", "PM"];
    var erasLong = ["Before Christ", "Anno Domini"];
    var erasShort = ["BC", "AD"];
    var erasNarrow = ["B", "A"];
    function eras(length) {
      switch (length) {
        case "narrow":
          return [...erasNarrow];
        case "short":
          return [...erasShort];
        case "long":
          return [...erasLong];
        default:
          return null;
      }
    }
    function meridiemForDateTime(dt) {
      return meridiems[dt.hour < 12 ? 0 : 1];
    }
    function weekdayForDateTime(dt, length) {
      return weekdays(length)[dt.weekday - 1];
    }
    function monthForDateTime(dt, length) {
      return months(length)[dt.month - 1];
    }
    function eraForDateTime(dt, length) {
      return eras(length)[dt.year < 0 ? 0 : 1];
    }
    function formatRelativeTime(unit, count, numeric = "always", narrow = false) {
      const units = {
        years: ["year", "yr."],
        quarters: ["quarter", "qtr."],
        months: ["month", "mo."],
        weeks: ["week", "wk."],
        days: ["day", "day", "days"],
        hours: ["hour", "hr."],
        minutes: ["minute", "min."],
        seconds: ["second", "sec."]
      };
      const lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;
      if (numeric === "auto" && lastable) {
        const isDay = unit === "days";
        switch (count) {
          case 1:
            return isDay ? "tomorrow" : `next ${units[unit][0]}`;
          case -1:
            return isDay ? "yesterday" : `last ${units[unit][0]}`;
          case 0:
            return isDay ? "today" : `this ${units[unit][0]}`;
        }
      }
      const isInPast = Object.is(count, -0) || count < 0, fmtValue = Math.abs(count), singular = fmtValue === 1, lilUnits = units[unit], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
      return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
    }
    function stringifyTokens(splits, tokenToString) {
      let s4 = "";
      for (const token of splits) {
        if (token.literal) {
          s4 += token.val;
        } else {
          s4 += tokenToString(token.val);
        }
      }
      return s4;
    }
    var macroTokenToFormatOpts = {
      D: DATE_SHORT,
      DD: DATE_MED,
      DDD: DATE_FULL,
      DDDD: DATE_HUGE,
      t: TIME_SIMPLE,
      tt: TIME_WITH_SECONDS,
      ttt: TIME_WITH_SHORT_OFFSET,
      tttt: TIME_WITH_LONG_OFFSET,
      T: TIME_24_SIMPLE,
      TT: TIME_24_WITH_SECONDS,
      TTT: TIME_24_WITH_SHORT_OFFSET,
      TTTT: TIME_24_WITH_LONG_OFFSET,
      f: DATETIME_SHORT,
      ff: DATETIME_MED,
      fff: DATETIME_FULL,
      ffff: DATETIME_HUGE,
      F: DATETIME_SHORT_WITH_SECONDS,
      FF: DATETIME_MED_WITH_SECONDS,
      FFF: DATETIME_FULL_WITH_SECONDS,
      FFFF: DATETIME_HUGE_WITH_SECONDS
    };
    var Formatter = class {
      static create(locale, opts = {}) {
        return new Formatter(locale, opts);
      }
      static parseFormat(fmt) {
        let current = null, currentFull = "", bracketed = false;
        const splits = [];
        for (let i3 = 0; i3 < fmt.length; i3++) {
          const c3 = fmt.charAt(i3);
          if (c3 === "'") {
            if (currentFull.length > 0) {
              splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
            }
            current = null;
            currentFull = "";
            bracketed = !bracketed;
          } else if (bracketed) {
            currentFull += c3;
          } else if (c3 === current) {
            currentFull += c3;
          } else {
            if (currentFull.length > 0) {
              splits.push({ literal: /^\s+$/.test(currentFull), val: currentFull });
            }
            currentFull = c3;
            current = c3;
          }
        }
        if (currentFull.length > 0) {
          splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
        }
        return splits;
      }
      static macroTokenToFormatOpts(token) {
        return macroTokenToFormatOpts[token];
      }
      constructor(locale, formatOpts) {
        this.opts = formatOpts;
        this.loc = locale;
        this.systemLoc = null;
      }
      formatWithSystemDefault(dt, opts) {
        if (this.systemLoc === null) {
          this.systemLoc = this.loc.redefaultToSystem();
        }
        const df = this.systemLoc.dtFormatter(dt, { ...this.opts, ...opts });
        return df.format();
      }
      dtFormatter(dt, opts = {}) {
        return this.loc.dtFormatter(dt, { ...this.opts, ...opts });
      }
      formatDateTime(dt, opts) {
        return this.dtFormatter(dt, opts).format();
      }
      formatDateTimeParts(dt, opts) {
        return this.dtFormatter(dt, opts).formatToParts();
      }
      formatInterval(interval, opts) {
        const df = this.dtFormatter(interval.start, opts);
        return df.dtf.formatRange(interval.start.toJSDate(), interval.end.toJSDate());
      }
      resolvedOptions(dt, opts) {
        return this.dtFormatter(dt, opts).resolvedOptions();
      }
      num(n3, p3 = 0) {
        if (this.opts.forceSimple) {
          return padStart3(n3, p3);
        }
        const opts = { ...this.opts };
        if (p3 > 0) {
          opts.padTo = p3;
        }
        return this.loc.numberFormatter(opts).format(n3);
      }
      formatDateTimeFromString(dt, fmt) {
        const knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", string = (opts, extract) => this.loc.extract(dt, opts, extract), formatOffset2 = (opts) => {
          if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
            return "Z";
          }
          return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
        }, meridiem = () => knownEnglish ? meridiemForDateTime(dt) : string({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), month = (length, standalone) => knownEnglish ? monthForDateTime(dt, length) : string(standalone ? { month: length } : { month: length, day: "numeric" }, "month"), weekday = (length, standalone) => knownEnglish ? weekdayForDateTime(dt, length) : string(
          standalone ? { weekday: length } : { weekday: length, month: "long", day: "numeric" },
          "weekday"
        ), maybeMacro = (token) => {
          const formatOpts = Formatter.macroTokenToFormatOpts(token);
          if (formatOpts) {
            return this.formatWithSystemDefault(dt, formatOpts);
          } else {
            return token;
          }
        }, era = (length) => knownEnglish ? eraForDateTime(dt, length) : string({ era: length }, "era"), tokenToString = (token) => {
          switch (token) {
            case "S":
              return this.num(dt.millisecond);
            case "u":
            case "SSS":
              return this.num(dt.millisecond, 3);
            case "s":
              return this.num(dt.second);
            case "ss":
              return this.num(dt.second, 2);
            case "uu":
              return this.num(Math.floor(dt.millisecond / 10), 2);
            case "uuu":
              return this.num(Math.floor(dt.millisecond / 100));
            case "m":
              return this.num(dt.minute);
            case "mm":
              return this.num(dt.minute, 2);
            case "h":
              return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
            case "hh":
              return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
            case "H":
              return this.num(dt.hour);
            case "HH":
              return this.num(dt.hour, 2);
            case "Z":
              return formatOffset2({ format: "narrow", allowZ: this.opts.allowZ });
            case "ZZ":
              return formatOffset2({ format: "short", allowZ: this.opts.allowZ });
            case "ZZZ":
              return formatOffset2({ format: "techie", allowZ: this.opts.allowZ });
            case "ZZZZ":
              return dt.zone.offsetName(dt.ts, { format: "short", locale: this.loc.locale });
            case "ZZZZZ":
              return dt.zone.offsetName(dt.ts, { format: "long", locale: this.loc.locale });
            case "z":
              return dt.zoneName;
            case "a":
              return meridiem();
            case "d":
              return useDateTimeFormatter ? string({ day: "numeric" }, "day") : this.num(dt.day);
            case "dd":
              return useDateTimeFormatter ? string({ day: "2-digit" }, "day") : this.num(dt.day, 2);
            case "c":
              return this.num(dt.weekday);
            case "ccc":
              return weekday("short", true);
            case "cccc":
              return weekday("long", true);
            case "ccccc":
              return weekday("narrow", true);
            case "E":
              return this.num(dt.weekday);
            case "EEE":
              return weekday("short", false);
            case "EEEE":
              return weekday("long", false);
            case "EEEEE":
              return weekday("narrow", false);
            case "L":
              return useDateTimeFormatter ? string({ month: "numeric", day: "numeric" }, "month") : this.num(dt.month);
            case "LL":
              return useDateTimeFormatter ? string({ month: "2-digit", day: "numeric" }, "month") : this.num(dt.month, 2);
            case "LLL":
              return month("short", true);
            case "LLLL":
              return month("long", true);
            case "LLLLL":
              return month("narrow", true);
            case "M":
              return useDateTimeFormatter ? string({ month: "numeric" }, "month") : this.num(dt.month);
            case "MM":
              return useDateTimeFormatter ? string({ month: "2-digit" }, "month") : this.num(dt.month, 2);
            case "MMM":
              return month("short", false);
            case "MMMM":
              return month("long", false);
            case "MMMMM":
              return month("narrow", false);
            case "y":
              return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year);
            case "yy":
              return useDateTimeFormatter ? string({ year: "2-digit" }, "year") : this.num(dt.year.toString().slice(-2), 2);
            case "yyyy":
              return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 4);
            case "yyyyyy":
              return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 6);
            case "G":
              return era("short");
            case "GG":
              return era("long");
            case "GGGGG":
              return era("narrow");
            case "kk":
              return this.num(dt.weekYear.toString().slice(-2), 2);
            case "kkkk":
              return this.num(dt.weekYear, 4);
            case "W":
              return this.num(dt.weekNumber);
            case "WW":
              return this.num(dt.weekNumber, 2);
            case "o":
              return this.num(dt.ordinal);
            case "ooo":
              return this.num(dt.ordinal, 3);
            case "q":
              return this.num(dt.quarter);
            case "qq":
              return this.num(dt.quarter, 2);
            case "X":
              return this.num(Math.floor(dt.ts / 1e3));
            case "x":
              return this.num(dt.ts);
            default:
              return maybeMacro(token);
          }
        };
        return stringifyTokens(Formatter.parseFormat(fmt), tokenToString);
      }
      formatDurationFromString(dur, fmt) {
        const tokenToField = (token) => {
          switch (token[0]) {
            case "S":
              return "millisecond";
            case "s":
              return "second";
            case "m":
              return "minute";
            case "h":
              return "hour";
            case "d":
              return "day";
            case "w":
              return "week";
            case "M":
              return "month";
            case "y":
              return "year";
            default:
              return null;
          }
        }, tokenToString = (lildur) => (token) => {
          const mapped = tokenToField(token);
          if (mapped) {
            return this.num(lildur.get(mapped), token.length);
          } else {
            return token;
          }
        }, tokens = Formatter.parseFormat(fmt), realTokens = tokens.reduce(
          (found, { literal, val }) => literal ? found : found.concat(val),
          []
        ), collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t3) => t3));
        return stringifyTokens(tokens, tokenToString(collapsed));
      }
    };
    var Invalid = class {
      constructor(reason, explanation) {
        this.reason = reason;
        this.explanation = explanation;
      }
      toMessage() {
        if (this.explanation) {
          return `${this.reason}: ${this.explanation}`;
        } else {
          return this.reason;
        }
      }
    };
    var ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
    function combineRegexes(...regexes) {
      const full = regexes.reduce((f3, r3) => f3 + r3.source, "");
      return RegExp(`^${full}$`);
    }
    function combineExtractors(...extractors) {
      return (m3) => extractors.reduce(
        ([mergedVals, mergedZone, cursor], ex) => {
          const [val, zone, next] = ex(m3, cursor);
          return [{ ...mergedVals, ...val }, zone || mergedZone, next];
        },
        [{}, null, 1]
      ).slice(0, 2);
    }
    function parse3(s4, ...patterns) {
      if (s4 == null) {
        return [null, null];
      }
      for (const [regex, extractor] of patterns) {
        const m3 = regex.exec(s4);
        if (m3) {
          return extractor(m3);
        }
      }
      return [null, null];
    }
    function simpleParse(...keys) {
      return (match2, cursor) => {
        const ret = {};
        let i3;
        for (i3 = 0; i3 < keys.length; i3++) {
          ret[keys[i3]] = parseInteger(match2[cursor + i3]);
        }
        return [ret, null, cursor + i3];
      };
    }
    var offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
    var isoExtendedZone = `(?:${offsetRegex.source}?(?:\\[(${ianaRegex.source})\\])?)?`;
    var isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
    var isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);
    var isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`);
    var isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
    var isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
    var isoOrdinalRegex = /(\d{4})-?(\d{3})/;
    var extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
    var extractISOOrdinalData = simpleParse("year", "ordinal");
    var sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/;
    var sqlTimeRegex = RegExp(
      `${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`
    );
    var sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);
    function int(match2, pos, fallback) {
      const m3 = match2[pos];
      return isUndefined(m3) ? fallback : parseInteger(m3);
    }
    function extractISOYmd(match2, cursor) {
      const item = {
        year: int(match2, cursor),
        month: int(match2, cursor + 1, 1),
        day: int(match2, cursor + 2, 1)
      };
      return [item, null, cursor + 3];
    }
    function extractISOTime(match2, cursor) {
      const item = {
        hours: int(match2, cursor, 0),
        minutes: int(match2, cursor + 1, 0),
        seconds: int(match2, cursor + 2, 0),
        milliseconds: parseMillis(match2[cursor + 3])
      };
      return [item, null, cursor + 4];
    }
    function extractISOOffset(match2, cursor) {
      const local = !match2[cursor] && !match2[cursor + 1], fullOffset = signedOffset(match2[cursor + 1], match2[cursor + 2]), zone = local ? null : FixedOffsetZone.instance(fullOffset);
      return [{}, zone, cursor + 3];
    }
    function extractIANAZone(match2, cursor) {
      const zone = match2[cursor] ? IANAZone.create(match2[cursor]) : null;
      return [{}, zone, cursor + 1];
    }
    var isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);
    var isoDuration = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
    function extractISODuration(match2) {
      const [s4, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] = match2;
      const hasNegativePrefix = s4[0] === "-";
      const negativeSeconds = secondStr && secondStr[0] === "-";
      const maybeNegate = (num, force = false) => num !== void 0 && (force || num && hasNegativePrefix) ? -num : num;
      return [
        {
          years: maybeNegate(parseFloating(yearStr)),
          months: maybeNegate(parseFloating(monthStr)),
          weeks: maybeNegate(parseFloating(weekStr)),
          days: maybeNegate(parseFloating(dayStr)),
          hours: maybeNegate(parseFloating(hourStr)),
          minutes: maybeNegate(parseFloating(minuteStr)),
          seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
          milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
        }
      ];
    }
    var obsOffsets = {
      GMT: 0,
      EDT: -4 * 60,
      EST: -5 * 60,
      CDT: -5 * 60,
      CST: -6 * 60,
      MDT: -6 * 60,
      MST: -7 * 60,
      PDT: -7 * 60,
      PST: -8 * 60
    };
    function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
      const result = {
        year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
        month: monthsShort.indexOf(monthStr) + 1,
        day: parseInteger(dayStr),
        hour: parseInteger(hourStr),
        minute: parseInteger(minuteStr)
      };
      if (secondStr)
        result.second = parseInteger(secondStr);
      if (weekdayStr) {
        result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
      }
      return result;
    }
    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
    function extractRFC2822(match2) {
      const [
        ,
        weekdayStr,
        dayStr,
        monthStr,
        yearStr,
        hourStr,
        minuteStr,
        secondStr,
        obsOffset,
        milOffset,
        offHourStr,
        offMinuteStr
      ] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      let offset2;
      if (obsOffset) {
        offset2 = obsOffsets[obsOffset];
      } else if (milOffset) {
        offset2 = 0;
      } else {
        offset2 = signedOffset(offHourStr, offMinuteStr);
      }
      return [result, new FixedOffsetZone(offset2)];
    }
    function preprocessRFC2822(s4) {
      return s4.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
    }
    var rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/;
    var rfc850 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/;
    var ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
    function extractRFC1123Or850(match2) {
      const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      return [result, FixedOffsetZone.utcInstance];
    }
    function extractASCII(match2) {
      const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      return [result, FixedOffsetZone.utcInstance];
    }
    var isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
    var isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
    var isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
    var isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
    var extractISOYmdTimeAndOffset = combineExtractors(
      extractISOYmd,
      extractISOTime,
      extractISOOffset,
      extractIANAZone
    );
    var extractISOWeekTimeAndOffset = combineExtractors(
      extractISOWeekData,
      extractISOTime,
      extractISOOffset,
      extractIANAZone
    );
    var extractISOOrdinalDateAndTime = combineExtractors(
      extractISOOrdinalData,
      extractISOTime,
      extractISOOffset,
      extractIANAZone
    );
    var extractISOTimeAndOffset = combineExtractors(
      extractISOTime,
      extractISOOffset,
      extractIANAZone
    );
    function parseISODate(s4) {
      return parse3(
        s4,
        [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
        [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset],
        [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime],
        [isoTimeCombinedRegex, extractISOTimeAndOffset]
      );
    }
    function parseRFC2822Date(s4) {
      return parse3(preprocessRFC2822(s4), [rfc2822, extractRFC2822]);
    }
    function parseHTTPDate(s4) {
      return parse3(
        s4,
        [rfc1123, extractRFC1123Or850],
        [rfc850, extractRFC1123Or850],
        [ascii, extractASCII]
      );
    }
    function parseISODuration(s4) {
      return parse3(s4, [isoDuration, extractISODuration]);
    }
    var extractISOTimeOnly = combineExtractors(extractISOTime);
    function parseISOTimeOnly(s4) {
      return parse3(s4, [isoTimeOnly, extractISOTimeOnly]);
    }
    var sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
    var sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
    var extractISOTimeOffsetAndIANAZone = combineExtractors(
      extractISOTime,
      extractISOOffset,
      extractIANAZone
    );
    function parseSQL(s4) {
      return parse3(
        s4,
        [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
        [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]
      );
    }
    var INVALID$2 = "Invalid Duration";
    var lowOrderMatrix = {
      weeks: {
        days: 7,
        hours: 7 * 24,
        minutes: 7 * 24 * 60,
        seconds: 7 * 24 * 60 * 60,
        milliseconds: 7 * 24 * 60 * 60 * 1e3
      },
      days: {
        hours: 24,
        minutes: 24 * 60,
        seconds: 24 * 60 * 60,
        milliseconds: 24 * 60 * 60 * 1e3
      },
      hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
      minutes: { seconds: 60, milliseconds: 60 * 1e3 },
      seconds: { milliseconds: 1e3 }
    };
    var casualMatrix = {
      years: {
        quarters: 4,
        months: 12,
        weeks: 52,
        days: 365,
        hours: 365 * 24,
        minutes: 365 * 24 * 60,
        seconds: 365 * 24 * 60 * 60,
        milliseconds: 365 * 24 * 60 * 60 * 1e3
      },
      quarters: {
        months: 3,
        weeks: 13,
        days: 91,
        hours: 91 * 24,
        minutes: 91 * 24 * 60,
        seconds: 91 * 24 * 60 * 60,
        milliseconds: 91 * 24 * 60 * 60 * 1e3
      },
      months: {
        weeks: 4,
        days: 30,
        hours: 30 * 24,
        minutes: 30 * 24 * 60,
        seconds: 30 * 24 * 60 * 60,
        milliseconds: 30 * 24 * 60 * 60 * 1e3
      },
      ...lowOrderMatrix
    };
    var daysInYearAccurate = 146097 / 400;
    var daysInMonthAccurate = 146097 / 4800;
    var accurateMatrix = {
      years: {
        quarters: 4,
        months: 12,
        weeks: daysInYearAccurate / 7,
        days: daysInYearAccurate,
        hours: daysInYearAccurate * 24,
        minutes: daysInYearAccurate * 24 * 60,
        seconds: daysInYearAccurate * 24 * 60 * 60,
        milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3
      },
      quarters: {
        months: 3,
        weeks: daysInYearAccurate / 28,
        days: daysInYearAccurate / 4,
        hours: daysInYearAccurate * 24 / 4,
        minutes: daysInYearAccurate * 24 * 60 / 4,
        seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
        milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3 / 4
      },
      months: {
        weeks: daysInMonthAccurate / 7,
        days: daysInMonthAccurate,
        hours: daysInMonthAccurate * 24,
        minutes: daysInMonthAccurate * 24 * 60,
        seconds: daysInMonthAccurate * 24 * 60 * 60,
        milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1e3
      },
      ...lowOrderMatrix
    };
    var orderedUnits$1 = [
      "years",
      "quarters",
      "months",
      "weeks",
      "days",
      "hours",
      "minutes",
      "seconds",
      "milliseconds"
    ];
    var reverseUnits = orderedUnits$1.slice(0).reverse();
    function clone$1(dur, alts, clear = false) {
      const conf = {
        values: clear ? alts.values : { ...dur.values, ...alts.values || {} },
        loc: dur.loc.clone(alts.loc),
        conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
        matrix: alts.matrix || dur.matrix
      };
      return new Duration(conf);
    }
    function durationToMillis(matrix, vals) {
      var _a;
      let sum = (_a = vals.milliseconds) != null ? _a : 0;
      for (const unit of reverseUnits.slice(1)) {
        if (vals[unit]) {
          sum += vals[unit] * matrix[unit]["milliseconds"];
        }
      }
      return sum;
    }
    function normalizeValues(matrix, vals) {
      const factor = durationToMillis(matrix, vals) < 0 ? -1 : 1;
      orderedUnits$1.reduceRight((previous, current) => {
        if (!isUndefined(vals[current])) {
          if (previous) {
            const previousVal = vals[previous] * factor;
            const conv = matrix[current][previous];
            const rollUp = Math.floor(previousVal / conv);
            vals[current] += rollUp * factor;
            vals[previous] -= rollUp * conv * factor;
          }
          return current;
        } else {
          return previous;
        }
      }, null);
      orderedUnits$1.reduce((previous, current) => {
        if (!isUndefined(vals[current])) {
          if (previous) {
            const fraction = vals[previous] % 1;
            vals[previous] -= fraction;
            vals[current] += fraction * matrix[previous][current];
          }
          return current;
        } else {
          return previous;
        }
      }, null);
    }
    function removeZeroes(vals) {
      const newVals = {};
      for (const [key, value] of Object.entries(vals)) {
        if (value !== 0) {
          newVals[key] = value;
        }
      }
      return newVals;
    }
    var Duration = class {
      /**
       * @private
       */
      constructor(config2) {
        const accurate = config2.conversionAccuracy === "longterm" || false;
        let matrix = accurate ? accurateMatrix : casualMatrix;
        if (config2.matrix) {
          matrix = config2.matrix;
        }
        this.values = config2.values;
        this.loc = config2.loc || Locale.create();
        this.conversionAccuracy = accurate ? "longterm" : "casual";
        this.invalid = config2.invalid || null;
        this.matrix = matrix;
        this.isLuxonDuration = true;
      }
      /**
       * Create Duration from a number of milliseconds.
       * @param {number} count of milliseconds
       * @param {Object} opts - options for parsing
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @return {Duration}
       */
      static fromMillis(count, opts) {
        return Duration.fromObject({ milliseconds: count }, opts);
      }
      /**
       * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
       * If this object is empty then a zero milliseconds duration is returned.
       * @param {Object} obj - the object to create the DateTime from
       * @param {number} obj.years
       * @param {number} obj.quarters
       * @param {number} obj.months
       * @param {number} obj.weeks
       * @param {number} obj.days
       * @param {number} obj.hours
       * @param {number} obj.minutes
       * @param {number} obj.seconds
       * @param {number} obj.milliseconds
       * @param {Object} [opts=[]] - options for creating this Duration
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
       * @param {string} [opts.matrix=Object] - the custom conversion system to use
       * @return {Duration}
       */
      static fromObject(obj, opts = {}) {
        if (obj == null || typeof obj !== "object") {
          throw new InvalidArgumentError(
            `Duration.fromObject: argument expected to be an object, got ${obj === null ? "null" : typeof obj}`
          );
        }
        return new Duration({
          values: normalizeObject(obj, Duration.normalizeUnit),
          loc: Locale.fromObject(opts),
          conversionAccuracy: opts.conversionAccuracy,
          matrix: opts.matrix
        });
      }
      /**
       * Create a Duration from DurationLike.
       *
       * @param {Object | number | Duration} durationLike
       * One of:
       * - object with keys like 'years' and 'hours'.
       * - number representing milliseconds
       * - Duration instance
       * @return {Duration}
       */
      static fromDurationLike(durationLike) {
        if (isNumber2(durationLike)) {
          return Duration.fromMillis(durationLike);
        } else if (Duration.isDuration(durationLike)) {
          return durationLike;
        } else if (typeof durationLike === "object") {
          return Duration.fromObject(durationLike);
        } else {
          throw new InvalidArgumentError(
            `Unknown duration argument ${durationLike} of type ${typeof durationLike}`
          );
        }
      }
      /**
       * Create a Duration from an ISO 8601 duration string.
       * @param {string} text - text to parse
       * @param {Object} opts - options for parsing
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
       * @param {string} [opts.matrix=Object] - the preset conversion system to use
       * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
       * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
       * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
       * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
       * @return {Duration}
       */
      static fromISO(text, opts) {
        const [parsed] = parseISODuration(text);
        if (parsed) {
          return Duration.fromObject(parsed, opts);
        } else {
          return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
        }
      }
      /**
       * Create a Duration from an ISO 8601 time string.
       * @param {string} text - text to parse
       * @param {Object} opts - options for parsing
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
       * @param {string} [opts.matrix=Object] - the conversion system to use
       * @see https://en.wikipedia.org/wiki/ISO_8601#Times
       * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
       * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @return {Duration}
       */
      static fromISOTime(text, opts) {
        const [parsed] = parseISOTimeOnly(text);
        if (parsed) {
          return Duration.fromObject(parsed, opts);
        } else {
          return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
        }
      }
      /**
       * Create an invalid Duration.
       * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
       * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
       * @return {Duration}
       */
      static invalid(reason, explanation = null) {
        if (!reason) {
          throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
        }
        const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
        if (Settings.throwOnInvalid) {
          throw new InvalidDurationError(invalid);
        } else {
          return new Duration({ invalid });
        }
      }
      /**
       * @private
       */
      static normalizeUnit(unit) {
        const normalized = {
          year: "years",
          years: "years",
          quarter: "quarters",
          quarters: "quarters",
          month: "months",
          months: "months",
          week: "weeks",
          weeks: "weeks",
          day: "days",
          days: "days",
          hour: "hours",
          hours: "hours",
          minute: "minutes",
          minutes: "minutes",
          second: "seconds",
          seconds: "seconds",
          millisecond: "milliseconds",
          milliseconds: "milliseconds"
        }[unit ? unit.toLowerCase() : unit];
        if (!normalized)
          throw new InvalidUnitError(unit);
        return normalized;
      }
      /**
       * Check if an object is a Duration. Works across context boundaries
       * @param {object} o
       * @return {boolean}
       */
      static isDuration(o2) {
        return o2 && o2.isLuxonDuration || false;
      }
      /**
       * Get  the locale of a Duration, such 'en-GB'
       * @type {string}
       */
      get locale() {
        return this.isValid ? this.loc.locale : null;
      }
      /**
       * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
       *
       * @type {string}
       */
      get numberingSystem() {
        return this.isValid ? this.loc.numberingSystem : null;
      }
      /**
       * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
       * * `S` for milliseconds
       * * `s` for seconds
       * * `m` for minutes
       * * `h` for hours
       * * `d` for days
       * * `w` for weeks
       * * `M` for months
       * * `y` for years
       * Notes:
       * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
       * * Tokens can be escaped by wrapping with single quotes.
       * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
       * @param {string} fmt - the format string
       * @param {Object} opts - options
       * @param {boolean} [opts.floor=true] - floor numerical values
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
       * @return {string}
       */
      toFormat(fmt, opts = {}) {
        const fmtOpts = {
          ...opts,
          floor: opts.round !== false && opts.floor !== false
        };
        return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID$2;
      }
      /**
       * Returns a string representation of a Duration with all units included.
       * To modify its behavior use the `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat
       * @param opts - On option object to override the formatting. Accepts the same keys as the options parameter of the native `Int.NumberFormat` constructor, as well as `listStyle`.
       * @example
       * ```js
       * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
       * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
       * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
       * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
       * ```
       */
      toHuman(opts = {}) {
        if (!this.isValid)
          return INVALID$2;
        const l4 = orderedUnits$1.map((unit) => {
          const val = this.values[unit];
          if (isUndefined(val)) {
            return null;
          }
          return this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...opts, unit: unit.slice(0, -1) }).format(val);
        }).filter((n3) => n3);
        return this.loc.listFormatter({ type: "conjunction", style: opts.listStyle || "narrow", ...opts }).format(l4);
      }
      /**
       * Returns a JavaScript object with this Duration's values.
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
       * @return {Object}
       */
      toObject() {
        if (!this.isValid)
          return {};
        return { ...this.values };
      }
      /**
       * Returns an ISO 8601-compliant string representation of this Duration.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
       * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
       * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
       * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
       * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
       * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
       * @return {string}
       */
      toISO() {
        if (!this.isValid)
          return null;
        let s4 = "P";
        if (this.years !== 0)
          s4 += this.years + "Y";
        if (this.months !== 0 || this.quarters !== 0)
          s4 += this.months + this.quarters * 3 + "M";
        if (this.weeks !== 0)
          s4 += this.weeks + "W";
        if (this.days !== 0)
          s4 += this.days + "D";
        if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
          s4 += "T";
        if (this.hours !== 0)
          s4 += this.hours + "H";
        if (this.minutes !== 0)
          s4 += this.minutes + "M";
        if (this.seconds !== 0 || this.milliseconds !== 0)
          s4 += roundTo(this.seconds + this.milliseconds / 1e3, 3) + "S";
        if (s4 === "P")
          s4 += "T0S";
        return s4;
      }
      /**
       * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
       * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Times
       * @param {Object} opts - options
       * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
       * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
       * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
       * @return {string}
       */
      toISOTime(opts = {}) {
        if (!this.isValid)
          return null;
        const millis = this.toMillis();
        if (millis < 0 || millis >= 864e5)
          return null;
        opts = {
          suppressMilliseconds: false,
          suppressSeconds: false,
          includePrefix: false,
          format: "extended",
          ...opts,
          includeOffset: false
        };
        const dateTime = DateTime2.fromMillis(millis, { zone: "UTC" });
        return dateTime.toISOTime(opts);
      }
      /**
       * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
       * @return {string}
       */
      toJSON() {
        return this.toISO();
      }
      /**
       * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
       * @return {string}
       */
      toString() {
        return this.toISO();
      }
      /**
       * Returns an milliseconds value of this Duration.
       * @return {number}
       */
      toMillis() {
        if (!this.isValid)
          return NaN;
        return durationToMillis(this.matrix, this.values);
      }
      /**
       * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
       * @return {number}
       */
      valueOf() {
        return this.toMillis();
      }
      /**
       * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
       * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       * @return {Duration}
       */
      plus(duration) {
        if (!this.isValid)
          return this;
        const dur = Duration.fromDurationLike(duration), result = {};
        for (const k3 of orderedUnits$1) {
          if (hasOwnProperty2(dur.values, k3) || hasOwnProperty2(this.values, k3)) {
            result[k3] = dur.get(k3) + this.get(k3);
          }
        }
        return clone$1(this, { values: result }, true);
      }
      /**
       * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
       * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       * @return {Duration}
       */
      minus(duration) {
        if (!this.isValid)
          return this;
        const dur = Duration.fromDurationLike(duration);
        return this.plus(dur.negate());
      }
      /**
       * Scale this Duration by the specified amount. Return a newly-constructed Duration.
       * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
       * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
       * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hours" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
       * @return {Duration}
       */
      mapUnits(fn) {
        if (!this.isValid)
          return this;
        const result = {};
        for (const k3 of Object.keys(this.values)) {
          result[k3] = asNumber(fn(this.values[k3], k3));
        }
        return clone$1(this, { values: result }, true);
      }
      /**
       * Get the value of unit.
       * @param {string} unit - a unit such as 'minute' or 'day'
       * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
       * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
       * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
       * @return {number}
       */
      get(unit) {
        return this[Duration.normalizeUnit(unit)];
      }
      /**
       * "Set" the values of specified units. Return a newly-constructed Duration.
       * @param {Object} values - a mapping of units to numbers
       * @example dur.set({ years: 2017 })
       * @example dur.set({ hours: 8, minutes: 30 })
       * @return {Duration}
       */
      set(values) {
        if (!this.isValid)
          return this;
        const mixed = { ...this.values, ...normalizeObject(values, Duration.normalizeUnit) };
        return clone$1(this, { values: mixed });
      }
      /**
       * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
       * @example dur.reconfigure({ locale: 'en-GB' })
       * @return {Duration}
       */
      reconfigure({ locale, numberingSystem, conversionAccuracy, matrix } = {}) {
        const loc = this.loc.clone({ locale, numberingSystem });
        const opts = { loc, matrix, conversionAccuracy };
        return clone$1(this, opts);
      }
      /**
       * Return the length of the duration in the specified unit.
       * @param {string} unit - a unit such as 'minutes' or 'days'
       * @example Duration.fromObject({years: 1}).as('days') //=> 365
       * @example Duration.fromObject({years: 1}).as('months') //=> 12
       * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
       * @return {number}
       */
      as(unit) {
        return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
      }
      /**
       * Reduce this Duration to its canonical representation in its current units.
       * Assuming the overall value of the Duration is positive, this means:
       * - excessive values for lower-order units are converted to higher-order units (if possible, see first and second example)
       * - negative lower-order units are converted to higher order units (there must be such a higher order unit, otherwise
       *   the overall value would be negative, see second example)
       * - fractional values for higher-order units are converted to lower-order units (if possible, see fourth example)
       *
       * If the overall value is negative, the result of this method is equivalent to `this.negate().normalize().negate()`.
       * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
       * @example Duration.fromObject({ days: 5000 }).normalize().toObject() //=> { days: 5000 }
       * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
       * @example Duration.fromObject({ years: 2.5, days: 0, hours: 0 }).normalize().toObject() //=> { years: 2, days: 182, hours: 12 }
       * @return {Duration}
       */
      normalize() {
        if (!this.isValid)
          return this;
        const vals = this.toObject();
        normalizeValues(this.matrix, vals);
        return clone$1(this, { values: vals }, true);
      }
      /**
       * Rescale units to its largest representation
       * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }
       * @return {Duration}
       */
      rescale() {
        if (!this.isValid)
          return this;
        const vals = removeZeroes(this.normalize().shiftToAll().toObject());
        return clone$1(this, { values: vals }, true);
      }
      /**
       * Convert this Duration into its representation in a different set of units.
       * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
       * @return {Duration}
       */
      shiftTo(...units) {
        if (!this.isValid)
          return this;
        if (units.length === 0) {
          return this;
        }
        units = units.map((u3) => Duration.normalizeUnit(u3));
        const built = {}, accumulated = {}, vals = this.toObject();
        let lastUnit;
        for (const k3 of orderedUnits$1) {
          if (units.indexOf(k3) >= 0) {
            lastUnit = k3;
            let own = 0;
            for (const ak in accumulated) {
              own += this.matrix[ak][k3] * accumulated[ak];
              accumulated[ak] = 0;
            }
            if (isNumber2(vals[k3])) {
              own += vals[k3];
            }
            const i3 = Math.trunc(own);
            built[k3] = i3;
            accumulated[k3] = (own * 1e3 - i3 * 1e3) / 1e3;
          } else if (isNumber2(vals[k3])) {
            accumulated[k3] = vals[k3];
          }
        }
        for (const key in accumulated) {
          if (accumulated[key] !== 0) {
            built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
          }
        }
        normalizeValues(this.matrix, built);
        return clone$1(this, { values: built }, true);
      }
      /**
       * Shift this Duration to all available units.
       * Same as shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds")
       * @return {Duration}
       */
      shiftToAll() {
        if (!this.isValid)
          return this;
        return this.shiftTo(
          "years",
          "months",
          "weeks",
          "days",
          "hours",
          "minutes",
          "seconds",
          "milliseconds"
        );
      }
      /**
       * Return the negative of this Duration.
       * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
       * @return {Duration}
       */
      negate() {
        if (!this.isValid)
          return this;
        const negated = {};
        for (const k3 of Object.keys(this.values)) {
          negated[k3] = this.values[k3] === 0 ? 0 : -this.values[k3];
        }
        return clone$1(this, { values: negated }, true);
      }
      /**
       * Get the years.
       * @type {number}
       */
      get years() {
        return this.isValid ? this.values.years || 0 : NaN;
      }
      /**
       * Get the quarters.
       * @type {number}
       */
      get quarters() {
        return this.isValid ? this.values.quarters || 0 : NaN;
      }
      /**
       * Get the months.
       * @type {number}
       */
      get months() {
        return this.isValid ? this.values.months || 0 : NaN;
      }
      /**
       * Get the weeks
       * @type {number}
       */
      get weeks() {
        return this.isValid ? this.values.weeks || 0 : NaN;
      }
      /**
       * Get the days.
       * @type {number}
       */
      get days() {
        return this.isValid ? this.values.days || 0 : NaN;
      }
      /**
       * Get the hours.
       * @type {number}
       */
      get hours() {
        return this.isValid ? this.values.hours || 0 : NaN;
      }
      /**
       * Get the minutes.
       * @type {number}
       */
      get minutes() {
        return this.isValid ? this.values.minutes || 0 : NaN;
      }
      /**
       * Get the seconds.
       * @return {number}
       */
      get seconds() {
        return this.isValid ? this.values.seconds || 0 : NaN;
      }
      /**
       * Get the milliseconds.
       * @return {number}
       */
      get milliseconds() {
        return this.isValid ? this.values.milliseconds || 0 : NaN;
      }
      /**
       * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
       * on invalid DateTimes or Intervals.
       * @return {boolean}
       */
      get isValid() {
        return this.invalid === null;
      }
      /**
       * Returns an error code if this Duration became invalid, or null if the Duration is valid
       * @return {string}
       */
      get invalidReason() {
        return this.invalid ? this.invalid.reason : null;
      }
      /**
       * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
       * @type {string}
       */
      get invalidExplanation() {
        return this.invalid ? this.invalid.explanation : null;
      }
      /**
       * Equality check
       * Two Durations are equal iff they have the same units and the same values for each unit.
       * @param {Duration} other
       * @return {boolean}
       */
      equals(other) {
        if (!this.isValid || !other.isValid) {
          return false;
        }
        if (!this.loc.equals(other.loc)) {
          return false;
        }
        function eq(v1, v22) {
          if (v1 === void 0 || v1 === 0)
            return v22 === void 0 || v22 === 0;
          return v1 === v22;
        }
        for (const u3 of orderedUnits$1) {
          if (!eq(this.values[u3], other.values[u3])) {
            return false;
          }
        }
        return true;
      }
    };
    var INVALID$1 = "Invalid Interval";
    function validateStartEnd(start, end) {
      if (!start || !start.isValid) {
        return Interval.invalid("missing or invalid start");
      } else if (!end || !end.isValid) {
        return Interval.invalid("missing or invalid end");
      } else if (end < start) {
        return Interval.invalid(
          "end before start",
          `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`
        );
      } else {
        return null;
      }
    }
    var Interval = class {
      /**
       * @private
       */
      constructor(config2) {
        this.s = config2.start;
        this.e = config2.end;
        this.invalid = config2.invalid || null;
        this.isLuxonInterval = true;
      }
      /**
       * Create an invalid Interval.
       * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
       * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
       * @return {Interval}
       */
      static invalid(reason, explanation = null) {
        if (!reason) {
          throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
        }
        const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
        if (Settings.throwOnInvalid) {
          throw new InvalidIntervalError(invalid);
        } else {
          return new Interval({ invalid });
        }
      }
      /**
       * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
       * @param {DateTime|Date|Object} start
       * @param {DateTime|Date|Object} end
       * @return {Interval}
       */
      static fromDateTimes(start, end) {
        const builtStart = friendlyDateTime(start), builtEnd = friendlyDateTime(end);
        const validateError = validateStartEnd(builtStart, builtEnd);
        if (validateError == null) {
          return new Interval({
            start: builtStart,
            end: builtEnd
          });
        } else {
          return validateError;
        }
      }
      /**
       * Create an Interval from a start DateTime and a Duration to extend to.
       * @param {DateTime|Date|Object} start
       * @param {Duration|Object|number} duration - the length of the Interval.
       * @return {Interval}
       */
      static after(start, duration) {
        const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(start);
        return Interval.fromDateTimes(dt, dt.plus(dur));
      }
      /**
       * Create an Interval from an end DateTime and a Duration to extend backwards to.
       * @param {DateTime|Date|Object} end
       * @param {Duration|Object|number} duration - the length of the Interval.
       * @return {Interval}
       */
      static before(end, duration) {
        const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(end);
        return Interval.fromDateTimes(dt.minus(dur), dt);
      }
      /**
       * Create an Interval from an ISO 8601 string.
       * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
       * @param {string} text - the ISO string to parse
       * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @return {Interval}
       */
      static fromISO(text, opts) {
        const [s4, e3] = (text || "").split("/", 2);
        if (s4 && e3) {
          let start, startIsValid;
          try {
            start = DateTime2.fromISO(s4, opts);
            startIsValid = start.isValid;
          } catch (e4) {
            startIsValid = false;
          }
          let end, endIsValid;
          try {
            end = DateTime2.fromISO(e3, opts);
            endIsValid = end.isValid;
          } catch (e4) {
            endIsValid = false;
          }
          if (startIsValid && endIsValid) {
            return Interval.fromDateTimes(start, end);
          }
          if (startIsValid) {
            const dur = Duration.fromISO(e3, opts);
            if (dur.isValid) {
              return Interval.after(start, dur);
            }
          } else if (endIsValid) {
            const dur = Duration.fromISO(s4, opts);
            if (dur.isValid) {
              return Interval.before(end, dur);
            }
          }
        }
        return Interval.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
      }
      /**
       * Check if an object is an Interval. Works across context boundaries
       * @param {object} o
       * @return {boolean}
       */
      static isInterval(o2) {
        return o2 && o2.isLuxonInterval || false;
      }
      /**
       * Returns the start of the Interval
       * @type {DateTime}
       */
      get start() {
        return this.isValid ? this.s : null;
      }
      /**
       * Returns the end of the Interval
       * @type {DateTime}
       */
      get end() {
        return this.isValid ? this.e : null;
      }
      /**
       * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
       * @type {boolean}
       */
      get isValid() {
        return this.invalidReason === null;
      }
      /**
       * Returns an error code if this Interval is invalid, or null if the Interval is valid
       * @type {string}
       */
      get invalidReason() {
        return this.invalid ? this.invalid.reason : null;
      }
      /**
       * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
       * @type {string}
       */
      get invalidExplanation() {
        return this.invalid ? this.invalid.explanation : null;
      }
      /**
       * Returns the length of the Interval in the specified unit.
       * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
       * @return {number}
       */
      length(unit = "milliseconds") {
        return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;
      }
      /**
       * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
       * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
       * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
       * @param {string} [unit='milliseconds'] - the unit of time to count.
       * @return {number}
       */
      count(unit = "milliseconds") {
        if (!this.isValid)
          return NaN;
        const start = this.start.startOf(unit), end = this.end.startOf(unit);
        return Math.floor(end.diff(start, unit).get(unit)) + (end.valueOf() !== this.end.valueOf());
      }
      /**
       * Returns whether this Interval's start and end are both in the same unit of time
       * @param {string} unit - the unit of time to check sameness on
       * @return {boolean}
       */
      hasSame(unit) {
        return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
      }
      /**
       * Return whether this Interval has the same start and end DateTimes.
       * @return {boolean}
       */
      isEmpty() {
        return this.s.valueOf() === this.e.valueOf();
      }
      /**
       * Return whether this Interval's start is after the specified DateTime.
       * @param {DateTime} dateTime
       * @return {boolean}
       */
      isAfter(dateTime) {
        if (!this.isValid)
          return false;
        return this.s > dateTime;
      }
      /**
       * Return whether this Interval's end is before the specified DateTime.
       * @param {DateTime} dateTime
       * @return {boolean}
       */
      isBefore(dateTime) {
        if (!this.isValid)
          return false;
        return this.e <= dateTime;
      }
      /**
       * Return whether this Interval contains the specified DateTime.
       * @param {DateTime} dateTime
       * @return {boolean}
       */
      contains(dateTime) {
        if (!this.isValid)
          return false;
        return this.s <= dateTime && this.e > dateTime;
      }
      /**
       * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
       * @param {Object} values - the values to set
       * @param {DateTime} values.start - the starting DateTime
       * @param {DateTime} values.end - the ending DateTime
       * @return {Interval}
       */
      set({ start, end } = {}) {
        if (!this.isValid)
          return this;
        return Interval.fromDateTimes(start || this.s, end || this.e);
      }
      /**
       * Split this Interval at each of the specified DateTimes
       * @param {...DateTime} dateTimes - the unit of time to count.
       * @return {Array}
       */
      splitAt(...dateTimes) {
        if (!this.isValid)
          return [];
        const sorted = dateTimes.map(friendlyDateTime).filter((d2) => this.contains(d2)).sort(), results = [];
        let { s: s4 } = this, i3 = 0;
        while (s4 < this.e) {
          const added = sorted[i3] || this.e, next = +added > +this.e ? this.e : added;
          results.push(Interval.fromDateTimes(s4, next));
          s4 = next;
          i3 += 1;
        }
        return results;
      }
      /**
       * Split this Interval into smaller Intervals, each of the specified length.
       * Left over time is grouped into a smaller interval
       * @param {Duration|Object|number} duration - The length of each resulting interval.
       * @return {Array}
       */
      splitBy(duration) {
        const dur = Duration.fromDurationLike(duration);
        if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
          return [];
        }
        let { s: s4 } = this, idx = 1, next;
        const results = [];
        while (s4 < this.e) {
          const added = this.start.plus(dur.mapUnits((x4) => x4 * idx));
          next = +added > +this.e ? this.e : added;
          results.push(Interval.fromDateTimes(s4, next));
          s4 = next;
          idx += 1;
        }
        return results;
      }
      /**
       * Split this Interval into the specified number of smaller intervals.
       * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
       * @return {Array}
       */
      divideEqually(numberOfParts) {
        if (!this.isValid)
          return [];
        return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
      }
      /**
       * Return whether this Interval overlaps with the specified Interval
       * @param {Interval} other
       * @return {boolean}
       */
      overlaps(other) {
        return this.e > other.s && this.s < other.e;
      }
      /**
       * Return whether this Interval's end is adjacent to the specified Interval's start.
       * @param {Interval} other
       * @return {boolean}
       */
      abutsStart(other) {
        if (!this.isValid)
          return false;
        return +this.e === +other.s;
      }
      /**
       * Return whether this Interval's start is adjacent to the specified Interval's end.
       * @param {Interval} other
       * @return {boolean}
       */
      abutsEnd(other) {
        if (!this.isValid)
          return false;
        return +other.e === +this.s;
      }
      /**
       * Return whether this Interval engulfs the start and end of the specified Interval.
       * @param {Interval} other
       * @return {boolean}
       */
      engulfs(other) {
        if (!this.isValid)
          return false;
        return this.s <= other.s && this.e >= other.e;
      }
      /**
       * Return whether this Interval has the same start and end as the specified Interval.
       * @param {Interval} other
       * @return {boolean}
       */
      equals(other) {
        if (!this.isValid || !other.isValid) {
          return false;
        }
        return this.s.equals(other.s) && this.e.equals(other.e);
      }
      /**
       * Return an Interval representing the intersection of this Interval and the specified Interval.
       * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
       * Returns null if the intersection is empty, meaning, the intervals don't intersect.
       * @param {Interval} other
       * @return {Interval}
       */
      intersection(other) {
        if (!this.isValid)
          return this;
        const s4 = this.s > other.s ? this.s : other.s, e3 = this.e < other.e ? this.e : other.e;
        if (s4 >= e3) {
          return null;
        } else {
          return Interval.fromDateTimes(s4, e3);
        }
      }
      /**
       * Return an Interval representing the union of this Interval and the specified Interval.
       * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
       * @param {Interval} other
       * @return {Interval}
       */
      union(other) {
        if (!this.isValid)
          return this;
        const s4 = this.s < other.s ? this.s : other.s, e3 = this.e > other.e ? this.e : other.e;
        return Interval.fromDateTimes(s4, e3);
      }
      /**
       * Merge an array of Intervals into a equivalent minimal set of Intervals.
       * Combines overlapping and adjacent Intervals.
       * @param {Array} intervals
       * @return {Array}
       */
      static merge(intervals) {
        const [found, final] = intervals.sort((a3, b3) => a3.s - b3.s).reduce(
          ([sofar, current], item) => {
            if (!current) {
              return [sofar, item];
            } else if (current.overlaps(item) || current.abutsStart(item)) {
              return [sofar, current.union(item)];
            } else {
              return [sofar.concat([current]), item];
            }
          },
          [[], null]
        );
        if (final) {
          found.push(final);
        }
        return found;
      }
      /**
       * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
       * @param {Array} intervals
       * @return {Array}
       */
      static xor(intervals) {
        let start = null, currentCount = 0;
        const results = [], ends = intervals.map((i3) => [
          { time: i3.s, type: "s" },
          { time: i3.e, type: "e" }
        ]), flattened = Array.prototype.concat(...ends), arr = flattened.sort((a3, b3) => a3.time - b3.time);
        for (const i3 of arr) {
          currentCount += i3.type === "s" ? 1 : -1;
          if (currentCount === 1) {
            start = i3.time;
          } else {
            if (start && +start !== +i3.time) {
              results.push(Interval.fromDateTimes(start, i3.time));
            }
            start = null;
          }
        }
        return Interval.merge(results);
      }
      /**
       * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
       * @param {...Interval} intervals
       * @return {Array}
       */
      difference(...intervals) {
        return Interval.xor([this].concat(intervals)).map((i3) => this.intersection(i3)).filter((i3) => i3 && !i3.isEmpty());
      }
      /**
       * Returns a string representation of this Interval appropriate for debugging.
       * @return {string}
       */
      toString() {
        if (!this.isValid)
          return INVALID$1;
        return `[${this.s.toISO()} \u2013 ${this.e.toISO()})`;
      }
      /**
       * Returns a localized string representing this Interval. Accepts the same options as the
       * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as
       * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method
       * is browser-specific, but in general it will return an appropriate representation of the
       * Interval in the assigned locale. Defaults to the system's locale if no locale has been
       * specified.
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or
       * Intl.DateTimeFormat constructor options.
       * @param {Object} opts - Options to override the configuration of the start DateTime.
       * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022  11/8/2022
       * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7  8, 2022
       * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 78 novembre 2022
       * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00  8:00 PM
       * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00  8:00 p
       * @return {string}
       */
      toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
        return this.isValid ? Formatter.create(this.s.loc.clone(opts), formatOpts).formatInterval(this) : INVALID$1;
      }
      /**
       * Returns an ISO 8601-compliant string representation of this Interval.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @param {Object} opts - The same options as {@link DateTime#toISO}
       * @return {string}
       */
      toISO(opts) {
        if (!this.isValid)
          return INVALID$1;
        return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
      }
      /**
       * Returns an ISO 8601-compliant string representation of date of this Interval.
       * The time components are ignored.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @return {string}
       */
      toISODate() {
        if (!this.isValid)
          return INVALID$1;
        return `${this.s.toISODate()}/${this.e.toISODate()}`;
      }
      /**
       * Returns an ISO 8601-compliant string representation of time of this Interval.
       * The date components are ignored.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @param {Object} opts - The same options as {@link DateTime#toISO}
       * @return {string}
       */
      toISOTime(opts) {
        if (!this.isValid)
          return INVALID$1;
        return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
      }
      /**
       * Returns a string representation of this Interval formatted according to the specified format
       * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible
       * formatting tool.
       * @param {string} dateFormat - The format string. This string formats the start and end time.
       * See {@link DateTime#toFormat} for details.
       * @param {Object} opts - Options.
       * @param {string} [opts.separator =  '  '] - A separator to place between the start and end
       * representations.
       * @return {string}
       */
      toFormat(dateFormat, { separator = " \u2013 " } = {}) {
        if (!this.isValid)
          return INVALID$1;
        return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
      }
      /**
       * Return a Duration representing the time spanned by this interval.
       * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
       * @param {Object} opts - options that affect the creation of the Duration
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
       * @return {Duration}
       */
      toDuration(unit, opts) {
        if (!this.isValid) {
          return Duration.invalid(this.invalidReason);
        }
        return this.e.diff(this.s, unit, opts);
      }
      /**
       * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
       * @param {function} mapFn
       * @return {Interval}
       * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
       * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
       */
      mapEndpoints(mapFn) {
        return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
      }
    };
    var Info = class {
      /**
       * Return whether the specified zone contains a DST.
       * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
       * @return {boolean}
       */
      static hasDST(zone = Settings.defaultZone) {
        const proto = DateTime2.now().setZone(zone).set({ month: 12 });
        return !zone.isUniversal && proto.offset !== proto.set({ month: 6 }).offset;
      }
      /**
       * Return whether the specified zone is a valid IANA specifier.
       * @param {string} zone - Zone to check
       * @return {boolean}
       */
      static isValidIANAZone(zone) {
        return IANAZone.isValidZone(zone);
      }
      /**
       * Converts the input into a {@link Zone} instance.
       *
       * * If `input` is already a Zone instance, it is returned unchanged.
       * * If `input` is a string containing a valid time zone name, a Zone instance
       *   with that name is returned.
       * * If `input` is a string that doesn't refer to a known time zone, a Zone
       *   instance with {@link Zone#isValid} == false is returned.
       * * If `input is a number, a Zone instance with the specified fixed offset
       *   in minutes is returned.
       * * If `input` is `null` or `undefined`, the default zone is returned.
       * @param {string|Zone|number} [input] - the value to be converted
       * @return {Zone}
       */
      static normalizeZone(input) {
        return normalizeZone(input, Settings.defaultZone);
      }
      /**
       * Return an array of standalone month names.
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @param {string} [opts.outputCalendar='gregory'] - the calendar
       * @example Info.months()[0] //=> 'January'
       * @example Info.months('short')[0] //=> 'Jan'
       * @example Info.months('numeric')[0] //=> '1'
       * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
       * @example Info.months('numeric', { locale: 'ar' })[0] //=> ''
       * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabi I'
       * @return {Array}
       */
      static months(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
        return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length);
      }
      /**
       * Return an array of format month names.
       * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
       * changes the string.
       * See {@link Info#months}
       * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @param {string} [opts.outputCalendar='gregory'] - the calendar
       * @return {Array}
       */
      static monthsFormat(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
        return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length, true);
      }
      /**
       * Return an array of standalone week names.
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @example Info.weekdays()[0] //=> 'Monday'
       * @example Info.weekdays('short')[0] //=> 'Mon'
       * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
       * @example Info.weekdays('short', { locale: 'ar' })[0] //=> ''
       * @return {Array}
       */
      static weekdays(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
        return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length);
      }
      /**
       * Return an array of format week names.
       * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
       * changes the string.
       * See {@link Info#weekdays}
       * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
       * @param {Object} opts - options
       * @param {string} [opts.locale=null] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @return {Array}
       */
      static weekdaysFormat(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
        return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length, true);
      }
      /**
       * Return an array of meridiems.
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @example Info.meridiems() //=> [ 'AM', 'PM' ]
       * @example Info.meridiems({ locale: 'my' }) //=> [ '', '' ]
       * @return {Array}
       */
      static meridiems({ locale = null } = {}) {
        return Locale.create(locale).meridiems();
      }
      /**
       * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
       * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @example Info.eras() //=> [ 'BC', 'AD' ]
       * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
       * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jsus-Christ', 'aprs Jsus-Christ' ]
       * @return {Array}
       */
      static eras(length = "short", { locale = null } = {}) {
        return Locale.create(locale, null, "gregory").eras(length);
      }
      /**
       * Return the set of available features in this environment.
       * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
       * Keys:
       * * `relative`: whether this environment supports relative time formatting
       * @example Info.features() //=> { relative: false }
       * @return {Object}
       */
      static features() {
        return { relative: hasRelative() };
      }
    };
    function dayDiff(earlier, later) {
      const utcDayStart = (dt) => dt.toUTC(0, { keepLocalTime: true }).startOf("day").valueOf(), ms = utcDayStart(later) - utcDayStart(earlier);
      return Math.floor(Duration.fromMillis(ms).as("days"));
    }
    function highOrderDiffs(cursor, later, units) {
      const differs = [
        ["years", (a3, b3) => b3.year - a3.year],
        ["quarters", (a3, b3) => b3.quarter - a3.quarter + (b3.year - a3.year) * 4],
        ["months", (a3, b3) => b3.month - a3.month + (b3.year - a3.year) * 12],
        [
          "weeks",
          (a3, b3) => {
            const days = dayDiff(a3, b3);
            return (days - days % 7) / 7;
          }
        ],
        ["days", dayDiff]
      ];
      const results = {};
      const earlier = cursor;
      let lowestOrder, highWater;
      for (const [unit, differ] of differs) {
        if (units.indexOf(unit) >= 0) {
          lowestOrder = unit;
          results[unit] = differ(cursor, later);
          highWater = earlier.plus(results);
          if (highWater > later) {
            results[unit]--;
            cursor = earlier.plus(results);
            if (cursor > later) {
              highWater = cursor;
              results[unit]--;
              cursor = earlier.plus(results);
            }
          } else {
            cursor = highWater;
          }
        }
      }
      return [cursor, results, highWater, lowestOrder];
    }
    function diff(earlier, later, units, opts) {
      let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);
      const remainingMillis = later - cursor;
      const lowerOrderUnits = units.filter(
        (u3) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u3) >= 0
      );
      if (lowerOrderUnits.length === 0) {
        if (highWater < later) {
          highWater = cursor.plus({ [lowestOrder]: 1 });
        }
        if (highWater !== cursor) {
          results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
        }
      }
      const duration = Duration.fromObject(results, opts);
      if (lowerOrderUnits.length > 0) {
        return Duration.fromMillis(remainingMillis, opts).shiftTo(...lowerOrderUnits).plus(duration);
      } else {
        return duration;
      }
    }
    var numberingSystems = {
      arab: "[\u0660-\u0669]",
      arabext: "[\u06F0-\u06F9]",
      bali: "[\u1B50-\u1B59]",
      beng: "[\u09E6-\u09EF]",
      deva: "[\u0966-\u096F]",
      fullwide: "[\uFF10-\uFF19]",
      gujr: "[\u0AE6-\u0AEF]",
      hanidec: "[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]",
      khmr: "[\u17E0-\u17E9]",
      knda: "[\u0CE6-\u0CEF]",
      laoo: "[\u0ED0-\u0ED9]",
      limb: "[\u1946-\u194F]",
      mlym: "[\u0D66-\u0D6F]",
      mong: "[\u1810-\u1819]",
      mymr: "[\u1040-\u1049]",
      orya: "[\u0B66-\u0B6F]",
      tamldec: "[\u0BE6-\u0BEF]",
      telu: "[\u0C66-\u0C6F]",
      thai: "[\u0E50-\u0E59]",
      tibt: "[\u0F20-\u0F29]",
      latn: "\\d"
    };
    var numberingSystemsUTF16 = {
      arab: [1632, 1641],
      arabext: [1776, 1785],
      bali: [6992, 7001],
      beng: [2534, 2543],
      deva: [2406, 2415],
      fullwide: [65296, 65303],
      gujr: [2790, 2799],
      khmr: [6112, 6121],
      knda: [3302, 3311],
      laoo: [3792, 3801],
      limb: [6470, 6479],
      mlym: [3430, 3439],
      mong: [6160, 6169],
      mymr: [4160, 4169],
      orya: [2918, 2927],
      tamldec: [3046, 3055],
      telu: [3174, 3183],
      thai: [3664, 3673],
      tibt: [3872, 3881]
    };
    var hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
    function parseDigits(str) {
      let value = parseInt(str, 10);
      if (isNaN(value)) {
        value = "";
        for (let i3 = 0; i3 < str.length; i3++) {
          const code = str.charCodeAt(i3);
          if (str[i3].search(numberingSystems.hanidec) !== -1) {
            value += hanidecChars.indexOf(str[i3]);
          } else {
            for (const key in numberingSystemsUTF16) {
              const [min, max] = numberingSystemsUTF16[key];
              if (code >= min && code <= max) {
                value += code - min;
              }
            }
          }
        }
        return parseInt(value, 10);
      } else {
        return value;
      }
    }
    function digitRegex({ numberingSystem }, append = "") {
      return new RegExp(`${numberingSystems[numberingSystem || "latn"]}${append}`);
    }
    var MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
    function intUnit(regex, post = (i3) => i3) {
      return { regex, deser: ([s4]) => post(parseDigits(s4)) };
    }
    var NBSP = String.fromCharCode(160);
    var spaceOrNBSP = `[ ${NBSP}]`;
    var spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
    function fixListRegex(s4) {
      return s4.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
    }
    function stripInsensitivities(s4) {
      return s4.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
    }
    function oneOf(strings, startIndex) {
      if (strings === null) {
        return null;
      } else {
        return {
          regex: RegExp(strings.map(fixListRegex).join("|")),
          deser: ([s4]) => strings.findIndex((i3) => stripInsensitivities(s4) === stripInsensitivities(i3)) + startIndex
        };
      }
    }
    function offset(regex, groups) {
      return { regex, deser: ([, h3, m3]) => signedOffset(h3, m3), groups };
    }
    function simple(regex) {
      return { regex, deser: ([s4]) => s4 };
    }
    function escapeToken(value) {
      return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
    }
    function unitForToken(token, loc) {
      const one = digitRegex(loc), two = digitRegex(loc, "{2}"), three = digitRegex(loc, "{3}"), four = digitRegex(loc, "{4}"), six = digitRegex(loc, "{6}"), oneOrTwo = digitRegex(loc, "{1,2}"), oneToThree = digitRegex(loc, "{1,3}"), oneToSix = digitRegex(loc, "{1,6}"), oneToNine = digitRegex(loc, "{1,9}"), twoToFour = digitRegex(loc, "{2,4}"), fourToSix = digitRegex(loc, "{4,6}"), literal = (t3) => ({ regex: RegExp(escapeToken(t3.val)), deser: ([s4]) => s4, literal: true }), unitate = (t3) => {
        if (token.literal) {
          return literal(t3);
        }
        switch (t3.val) {
          case "G":
            return oneOf(loc.eras("short"), 0);
          case "GG":
            return oneOf(loc.eras("long"), 0);
          case "y":
            return intUnit(oneToSix);
          case "yy":
            return intUnit(twoToFour, untruncateYear);
          case "yyyy":
            return intUnit(four);
          case "yyyyy":
            return intUnit(fourToSix);
          case "yyyyyy":
            return intUnit(six);
          case "M":
            return intUnit(oneOrTwo);
          case "MM":
            return intUnit(two);
          case "MMM":
            return oneOf(loc.months("short", true), 1);
          case "MMMM":
            return oneOf(loc.months("long", true), 1);
          case "L":
            return intUnit(oneOrTwo);
          case "LL":
            return intUnit(two);
          case "LLL":
            return oneOf(loc.months("short", false), 1);
          case "LLLL":
            return oneOf(loc.months("long", false), 1);
          case "d":
            return intUnit(oneOrTwo);
          case "dd":
            return intUnit(two);
          case "o":
            return intUnit(oneToThree);
          case "ooo":
            return intUnit(three);
          case "HH":
            return intUnit(two);
          case "H":
            return intUnit(oneOrTwo);
          case "hh":
            return intUnit(two);
          case "h":
            return intUnit(oneOrTwo);
          case "mm":
            return intUnit(two);
          case "m":
            return intUnit(oneOrTwo);
          case "q":
            return intUnit(oneOrTwo);
          case "qq":
            return intUnit(two);
          case "s":
            return intUnit(oneOrTwo);
          case "ss":
            return intUnit(two);
          case "S":
            return intUnit(oneToThree);
          case "SSS":
            return intUnit(three);
          case "u":
            return simple(oneToNine);
          case "uu":
            return simple(oneOrTwo);
          case "uuu":
            return intUnit(one);
          case "a":
            return oneOf(loc.meridiems(), 0);
          case "kkkk":
            return intUnit(four);
          case "kk":
            return intUnit(twoToFour, untruncateYear);
          case "W":
            return intUnit(oneOrTwo);
          case "WW":
            return intUnit(two);
          case "E":
          case "c":
            return intUnit(one);
          case "EEE":
            return oneOf(loc.weekdays("short", false), 1);
          case "EEEE":
            return oneOf(loc.weekdays("long", false), 1);
          case "ccc":
            return oneOf(loc.weekdays("short", true), 1);
          case "cccc":
            return oneOf(loc.weekdays("long", true), 1);
          case "Z":
          case "ZZ":
            return offset(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
          case "ZZZ":
            return offset(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
          case "z":
            return simple(/[a-z_+-/]{1,256}?/i);
          case " ":
            return simple(/[^\S\n\r]/);
          default:
            return literal(t3);
        }
      };
      const unit = unitate(token) || {
        invalidReason: MISSING_FTP
      };
      unit.token = token;
      return unit;
    }
    var partTypeStyleToTokenVal = {
      year: {
        "2-digit": "yy",
        numeric: "yyyyy"
      },
      month: {
        numeric: "M",
        "2-digit": "MM",
        short: "MMM",
        long: "MMMM"
      },
      day: {
        numeric: "d",
        "2-digit": "dd"
      },
      weekday: {
        short: "EEE",
        long: "EEEE"
      },
      dayperiod: "a",
      dayPeriod: "a",
      hour12: {
        numeric: "h",
        "2-digit": "hh"
      },
      hour24: {
        numeric: "H",
        "2-digit": "HH"
      },
      minute: {
        numeric: "m",
        "2-digit": "mm"
      },
      second: {
        numeric: "s",
        "2-digit": "ss"
      },
      timeZoneName: {
        long: "ZZZZZ",
        short: "ZZZ"
      }
    };
    function tokenForPart(part, formatOpts, resolvedOpts) {
      const { type, value } = part;
      if (type === "literal") {
        const isSpace = /^\s+$/.test(value);
        return {
          literal: !isSpace,
          val: isSpace ? " " : value
        };
      }
      const style = formatOpts[type];
      let actualType = type;
      if (type === "hour") {
        if (formatOpts.hour12 != null) {
          actualType = formatOpts.hour12 ? "hour12" : "hour24";
        } else if (formatOpts.hourCycle != null) {
          if (formatOpts.hourCycle === "h11" || formatOpts.hourCycle === "h12") {
            actualType = "hour12";
          } else {
            actualType = "hour24";
          }
        } else {
          actualType = resolvedOpts.hour12 ? "hour12" : "hour24";
        }
      }
      let val = partTypeStyleToTokenVal[actualType];
      if (typeof val === "object") {
        val = val[style];
      }
      if (val) {
        return {
          literal: false,
          val
        };
      }
      return void 0;
    }
    function buildRegex(units) {
      const re = units.map((u3) => u3.regex).reduce((f3, r3) => `${f3}(${r3.source})`, "");
      return [`^${re}$`, units];
    }
    function match(input, regex, handlers) {
      const matches = input.match(regex);
      if (matches) {
        const all = {};
        let matchIndex = 1;
        for (const i3 in handlers) {
          if (hasOwnProperty2(handlers, i3)) {
            const h3 = handlers[i3], groups = h3.groups ? h3.groups + 1 : 1;
            if (!h3.literal && h3.token) {
              all[h3.token.val[0]] = h3.deser(matches.slice(matchIndex, matchIndex + groups));
            }
            matchIndex += groups;
          }
        }
        return [matches, all];
      } else {
        return [matches, {}];
      }
    }
    function dateTimeFromMatches(matches) {
      const toField = (token) => {
        switch (token) {
          case "S":
            return "millisecond";
          case "s":
            return "second";
          case "m":
            return "minute";
          case "h":
          case "H":
            return "hour";
          case "d":
            return "day";
          case "o":
            return "ordinal";
          case "L":
          case "M":
            return "month";
          case "y":
            return "year";
          case "E":
          case "c":
            return "weekday";
          case "W":
            return "weekNumber";
          case "k":
            return "weekYear";
          case "q":
            return "quarter";
          default:
            return null;
        }
      };
      let zone = null;
      let specificOffset;
      if (!isUndefined(matches.z)) {
        zone = IANAZone.create(matches.z);
      }
      if (!isUndefined(matches.Z)) {
        if (!zone) {
          zone = new FixedOffsetZone(matches.Z);
        }
        specificOffset = matches.Z;
      }
      if (!isUndefined(matches.q)) {
        matches.M = (matches.q - 1) * 3 + 1;
      }
      if (!isUndefined(matches.h)) {
        if (matches.h < 12 && matches.a === 1) {
          matches.h += 12;
        } else if (matches.h === 12 && matches.a === 0) {
          matches.h = 0;
        }
      }
      if (matches.G === 0 && matches.y) {
        matches.y = -matches.y;
      }
      if (!isUndefined(matches.u)) {
        matches.S = parseMillis(matches.u);
      }
      const vals = Object.keys(matches).reduce((r3, k3) => {
        const f3 = toField(k3);
        if (f3) {
          r3[f3] = matches[k3];
        }
        return r3;
      }, {});
      return [vals, zone, specificOffset];
    }
    var dummyDateTimeCache = null;
    function getDummyDateTime() {
      if (!dummyDateTimeCache) {
        dummyDateTimeCache = DateTime2.fromMillis(1555555555555);
      }
      return dummyDateTimeCache;
    }
    function maybeExpandMacroToken(token, locale) {
      if (token.literal) {
        return token;
      }
      const formatOpts = Formatter.macroTokenToFormatOpts(token.val);
      const tokens = formatOptsToTokens(formatOpts, locale);
      if (tokens == null || tokens.includes(void 0)) {
        return token;
      }
      return tokens;
    }
    function expandMacroTokens(tokens, locale) {
      return Array.prototype.concat(...tokens.map((t3) => maybeExpandMacroToken(t3, locale)));
    }
    function explainFromTokens(locale, input, format) {
      const tokens = expandMacroTokens(Formatter.parseFormat(format), locale), units = tokens.map((t3) => unitForToken(t3, locale)), disqualifyingUnit = units.find((t3) => t3.invalidReason);
      if (disqualifyingUnit) {
        return { input, tokens, invalidReason: disqualifyingUnit.invalidReason };
      } else {
        const [regexString, handlers] = buildRegex(units), regex = RegExp(regexString, "i"), [rawMatches, matches] = match(input, regex, handlers), [result, zone, specificOffset] = matches ? dateTimeFromMatches(matches) : [null, null, void 0];
        if (hasOwnProperty2(matches, "a") && hasOwnProperty2(matches, "H")) {
          throw new ConflictingSpecificationError(
            "Can't include meridiem when specifying 24-hour format"
          );
        }
        return { input, tokens, regex, rawMatches, matches, result, zone, specificOffset };
      }
    }
    function parseFromTokens(locale, input, format) {
      const { result, zone, specificOffset, invalidReason } = explainFromTokens(locale, input, format);
      return [result, zone, specificOffset, invalidReason];
    }
    function formatOptsToTokens(formatOpts, locale) {
      if (!formatOpts) {
        return null;
      }
      const formatter = Formatter.create(locale, formatOpts);
      const df = formatter.dtFormatter(getDummyDateTime());
      const parts = df.formatToParts();
      const resolvedOpts = df.resolvedOptions();
      return parts.map((p3) => tokenForPart(p3, formatOpts, resolvedOpts));
    }
    var nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
    var leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
    function unitOutOfRange(unit, value) {
      return new Invalid(
        "unit out of range",
        `you specified ${value} (of type ${typeof value}) as a ${unit}, which is invalid`
      );
    }
    function dayOfWeek(year, month, day) {
      const d2 = new Date(Date.UTC(year, month - 1, day));
      if (year < 100 && year >= 0) {
        d2.setUTCFullYear(d2.getUTCFullYear() - 1900);
      }
      const js = d2.getUTCDay();
      return js === 0 ? 7 : js;
    }
    function computeOrdinal(year, month, day) {
      return day + (isLeapYear2(year) ? leapLadder : nonLeapLadder)[month - 1];
    }
    function uncomputeOrdinal(year, ordinal) {
      const table = isLeapYear2(year) ? leapLadder : nonLeapLadder, month0 = table.findIndex((i3) => i3 < ordinal), day = ordinal - table[month0];
      return { month: month0 + 1, day };
    }
    function gregorianToWeek(gregObj) {
      const { year, month, day } = gregObj, ordinal = computeOrdinal(year, month, day), weekday = dayOfWeek(year, month, day);
      let weekNumber = Math.floor((ordinal - weekday + 10) / 7), weekYear;
      if (weekNumber < 1) {
        weekYear = year - 1;
        weekNumber = weeksInWeekYear(weekYear);
      } else if (weekNumber > weeksInWeekYear(year)) {
        weekYear = year + 1;
        weekNumber = 1;
      } else {
        weekYear = year;
      }
      return { weekYear, weekNumber, weekday, ...timeObject(gregObj) };
    }
    function weekToGregorian(weekData) {
      const { weekYear, weekNumber, weekday } = weekData, weekdayOfJan4 = dayOfWeek(weekYear, 1, 4), yearInDays = daysInYear(weekYear);
      let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 3, year;
      if (ordinal < 1) {
        year = weekYear - 1;
        ordinal += daysInYear(year);
      } else if (ordinal > yearInDays) {
        year = weekYear + 1;
        ordinal -= daysInYear(weekYear);
      } else {
        year = weekYear;
      }
      const { month, day } = uncomputeOrdinal(year, ordinal);
      return { year, month, day, ...timeObject(weekData) };
    }
    function gregorianToOrdinal(gregData) {
      const { year, month, day } = gregData;
      const ordinal = computeOrdinal(year, month, day);
      return { year, ordinal, ...timeObject(gregData) };
    }
    function ordinalToGregorian(ordinalData) {
      const { year, ordinal } = ordinalData;
      const { month, day } = uncomputeOrdinal(year, ordinal);
      return { year, month, day, ...timeObject(ordinalData) };
    }
    function hasInvalidWeekData(obj) {
      const validYear = isInteger(obj.weekYear), validWeek = integerBetween(obj.weekNumber, 1, weeksInWeekYear(obj.weekYear)), validWeekday = integerBetween(obj.weekday, 1, 7);
      if (!validYear) {
        return unitOutOfRange("weekYear", obj.weekYear);
      } else if (!validWeek) {
        return unitOutOfRange("week", obj.week);
      } else if (!validWeekday) {
        return unitOutOfRange("weekday", obj.weekday);
      } else
        return false;
    }
    function hasInvalidOrdinalData(obj) {
      const validYear = isInteger(obj.year), validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
      if (!validYear) {
        return unitOutOfRange("year", obj.year);
      } else if (!validOrdinal) {
        return unitOutOfRange("ordinal", obj.ordinal);
      } else
        return false;
    }
    function hasInvalidGregorianData(obj) {
      const validYear = isInteger(obj.year), validMonth = integerBetween(obj.month, 1, 12), validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
      if (!validYear) {
        return unitOutOfRange("year", obj.year);
      } else if (!validMonth) {
        return unitOutOfRange("month", obj.month);
      } else if (!validDay) {
        return unitOutOfRange("day", obj.day);
      } else
        return false;
    }
    function hasInvalidTimeData(obj) {
      const { hour, minute, second, millisecond } = obj;
      const validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0, validMinute = integerBetween(minute, 0, 59), validSecond = integerBetween(second, 0, 59), validMillisecond = integerBetween(millisecond, 0, 999);
      if (!validHour) {
        return unitOutOfRange("hour", hour);
      } else if (!validMinute) {
        return unitOutOfRange("minute", minute);
      } else if (!validSecond) {
        return unitOutOfRange("second", second);
      } else if (!validMillisecond) {
        return unitOutOfRange("millisecond", millisecond);
      } else
        return false;
    }
    var INVALID = "Invalid DateTime";
    var MAX_DATE = 864e13;
    function unsupportedZone(zone) {
      return new Invalid("unsupported zone", `the zone "${zone.name}" is not supported`);
    }
    function possiblyCachedWeekData(dt) {
      if (dt.weekData === null) {
        dt.weekData = gregorianToWeek(dt.c);
      }
      return dt.weekData;
    }
    function clone2(inst, alts) {
      const current = {
        ts: inst.ts,
        zone: inst.zone,
        c: inst.c,
        o: inst.o,
        loc: inst.loc,
        invalid: inst.invalid
      };
      return new DateTime2({ ...current, ...alts, old: current });
    }
    function fixOffset(localTS, o2, tz) {
      let utcGuess = localTS - o2 * 60 * 1e3;
      const o22 = tz.offset(utcGuess);
      if (o2 === o22) {
        return [utcGuess, o2];
      }
      utcGuess -= (o22 - o2) * 60 * 1e3;
      const o3 = tz.offset(utcGuess);
      if (o22 === o3) {
        return [utcGuess, o22];
      }
      return [localTS - Math.min(o22, o3) * 60 * 1e3, Math.max(o22, o3)];
    }
    function tsToObj(ts, offset2) {
      ts += offset2 * 60 * 1e3;
      const d2 = new Date(ts);
      return {
        year: d2.getUTCFullYear(),
        month: d2.getUTCMonth() + 1,
        day: d2.getUTCDate(),
        hour: d2.getUTCHours(),
        minute: d2.getUTCMinutes(),
        second: d2.getUTCSeconds(),
        millisecond: d2.getUTCMilliseconds()
      };
    }
    function objToTS(obj, offset2, zone) {
      return fixOffset(objToLocalTS(obj), offset2, zone);
    }
    function adjustTime(inst, dur) {
      const oPre = inst.o, year = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c3 = {
        ...inst.c,
        year,
        month,
        day: Math.min(inst.c.day, daysInMonth(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
      }, millisToAdd = Duration.fromObject({
        years: dur.years - Math.trunc(dur.years),
        quarters: dur.quarters - Math.trunc(dur.quarters),
        months: dur.months - Math.trunc(dur.months),
        weeks: dur.weeks - Math.trunc(dur.weeks),
        days: dur.days - Math.trunc(dur.days),
        hours: dur.hours,
        minutes: dur.minutes,
        seconds: dur.seconds,
        milliseconds: dur.milliseconds
      }).as("milliseconds"), localTS = objToLocalTS(c3);
      let [ts, o2] = fixOffset(localTS, oPre, inst.zone);
      if (millisToAdd !== 0) {
        ts += millisToAdd;
        o2 = inst.zone.offset(ts);
      }
      return { ts, o: o2 };
    }
    function parseDataToDateTime(parsed, parsedZone, opts, format, text, specificOffset) {
      const { setZone, zone } = opts;
      if (parsed && Object.keys(parsed).length !== 0 || parsedZone) {
        const interpretationZone = parsedZone || zone, inst = DateTime2.fromObject(parsed, {
          ...opts,
          zone: interpretationZone,
          specificOffset
        });
        return setZone ? inst : inst.setZone(zone);
      } else {
        return DateTime2.invalid(
          new Invalid("unparsable", `the input "${text}" can't be parsed as ${format}`)
        );
      }
    }
    function toTechFormat(dt, format, allowZ = true) {
      return dt.isValid ? Formatter.create(Locale.create("en-US"), {
        allowZ,
        forceSimple: true
      }).formatDateTimeFromString(dt, format) : null;
    }
    function toISODate(o2, extended) {
      const longFormat = o2.c.year > 9999 || o2.c.year < 0;
      let c3 = "";
      if (longFormat && o2.c.year >= 0)
        c3 += "+";
      c3 += padStart3(o2.c.year, longFormat ? 6 : 4);
      if (extended) {
        c3 += "-";
        c3 += padStart3(o2.c.month);
        c3 += "-";
        c3 += padStart3(o2.c.day);
      } else {
        c3 += padStart3(o2.c.month);
        c3 += padStart3(o2.c.day);
      }
      return c3;
    }
    function toISOTime(o2, extended, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone) {
      let c3 = padStart3(o2.c.hour);
      if (extended) {
        c3 += ":";
        c3 += padStart3(o2.c.minute);
        if (o2.c.millisecond !== 0 || o2.c.second !== 0 || !suppressSeconds) {
          c3 += ":";
        }
      } else {
        c3 += padStart3(o2.c.minute);
      }
      if (o2.c.millisecond !== 0 || o2.c.second !== 0 || !suppressSeconds) {
        c3 += padStart3(o2.c.second);
        if (o2.c.millisecond !== 0 || !suppressMilliseconds) {
          c3 += ".";
          c3 += padStart3(o2.c.millisecond, 3);
        }
      }
      if (includeOffset) {
        if (o2.isOffsetFixed && o2.offset === 0 && !extendedZone) {
          c3 += "Z";
        } else if (o2.o < 0) {
          c3 += "-";
          c3 += padStart3(Math.trunc(-o2.o / 60));
          c3 += ":";
          c3 += padStart3(Math.trunc(-o2.o % 60));
        } else {
          c3 += "+";
          c3 += padStart3(Math.trunc(o2.o / 60));
          c3 += ":";
          c3 += padStart3(Math.trunc(o2.o % 60));
        }
      }
      if (extendedZone) {
        c3 += "[" + o2.zone.ianaName + "]";
      }
      return c3;
    }
    var defaultUnitValues = {
      month: 1,
      day: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    };
    var defaultWeekUnitValues = {
      weekNumber: 1,
      weekday: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    };
    var defaultOrdinalUnitValues = {
      ordinal: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    };
    var orderedUnits = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
    var orderedWeekUnits = [
      "weekYear",
      "weekNumber",
      "weekday",
      "hour",
      "minute",
      "second",
      "millisecond"
    ];
    var orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
    function normalizeUnit(unit) {
      const normalized = {
        year: "year",
        years: "year",
        month: "month",
        months: "month",
        day: "day",
        days: "day",
        hour: "hour",
        hours: "hour",
        minute: "minute",
        minutes: "minute",
        quarter: "quarter",
        quarters: "quarter",
        second: "second",
        seconds: "second",
        millisecond: "millisecond",
        milliseconds: "millisecond",
        weekday: "weekday",
        weekdays: "weekday",
        weeknumber: "weekNumber",
        weeksnumber: "weekNumber",
        weeknumbers: "weekNumber",
        weekyear: "weekYear",
        weekyears: "weekYear",
        ordinal: "ordinal"
      }[unit.toLowerCase()];
      if (!normalized)
        throw new InvalidUnitError(unit);
      return normalized;
    }
    function quickDT(obj, opts) {
      const zone = normalizeZone(opts.zone, Settings.defaultZone), loc = Locale.fromObject(opts), tsNow = Settings.now();
      let ts, o2;
      if (!isUndefined(obj.year)) {
        for (const u3 of orderedUnits) {
          if (isUndefined(obj[u3])) {
            obj[u3] = defaultUnitValues[u3];
          }
        }
        const invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
        if (invalid) {
          return DateTime2.invalid(invalid);
        }
        const offsetProvis = zone.offset(tsNow);
        [ts, o2] = objToTS(obj, offsetProvis, zone);
      } else {
        ts = tsNow;
      }
      return new DateTime2({ ts, zone, loc, o: o2 });
    }
    function diffRelative(start, end, opts) {
      const round = isUndefined(opts.round) ? true : opts.round, format = (c3, unit) => {
        c3 = roundTo(c3, round || opts.calendary ? 0 : 2, true);
        const formatter = end.loc.clone(opts).relFormatter(opts);
        return formatter.format(c3, unit);
      }, differ = (unit) => {
        if (opts.calendary) {
          if (!end.hasSame(start, unit)) {
            return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);
          } else
            return 0;
        } else {
          return end.diff(start, unit).get(unit);
        }
      };
      if (opts.unit) {
        return format(differ(opts.unit), opts.unit);
      }
      for (const unit of opts.units) {
        const count = differ(unit);
        if (Math.abs(count) >= 1) {
          return format(count, unit);
        }
      }
      return format(start > end ? -0 : 0, opts.units[opts.units.length - 1]);
    }
    function lastOpts(argList) {
      let opts = {}, args;
      if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
        opts = argList[argList.length - 1];
        args = Array.from(argList).slice(0, argList.length - 1);
      } else {
        args = Array.from(argList);
      }
      return [opts, args];
    }
    var DateTime2 = class {
      /**
       * @access private
       */
      constructor(config2) {
        const zone = config2.zone || Settings.defaultZone;
        let invalid = config2.invalid || (Number.isNaN(config2.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
        this.ts = isUndefined(config2.ts) ? Settings.now() : config2.ts;
        let c3 = null, o2 = null;
        if (!invalid) {
          const unchanged = config2.old && config2.old.ts === this.ts && config2.old.zone.equals(zone);
          if (unchanged) {
            [c3, o2] = [config2.old.c, config2.old.o];
          } else {
            const ot = zone.offset(this.ts);
            c3 = tsToObj(this.ts, ot);
            invalid = Number.isNaN(c3.year) ? new Invalid("invalid input") : null;
            c3 = invalid ? null : c3;
            o2 = invalid ? null : ot;
          }
        }
        this._zone = zone;
        this.loc = config2.loc || Locale.create();
        this.invalid = invalid;
        this.weekData = null;
        this.c = c3;
        this.o = o2;
        this.isLuxonDateTime = true;
      }
      // CONSTRUCT
      /**
       * Create a DateTime for the current instant, in the system's time zone.
       *
       * Use Settings to override these default values if needed.
       * @example DateTime.now().toISO() //~> now in the ISO format
       * @return {DateTime}
       */
      static now() {
        return new DateTime2({});
      }
      /**
       * Create a local DateTime
       * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
       * @param {number} [month=1] - The month, 1-indexed
       * @param {number} [day=1] - The day of the month, 1-indexed
       * @param {number} [hour=0] - The hour of the day, in 24-hour time
       * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
       * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
       * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
       * @example DateTime.local()                                  //~> now
       * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
       * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
       * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
       * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
       * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
       * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
       * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
       * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
       * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
       * @return {DateTime}
       */
      static local() {
        const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
        return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
      }
      /**
       * Create a DateTime in UTC
       * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
       * @param {number} [month=1] - The month, 1-indexed
       * @param {number} [day=1] - The day of the month
       * @param {number} [hour=0] - The hour of the day, in 24-hour time
       * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
       * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
       * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
       * @param {Object} options - configuration options for the DateTime
       * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
       * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
       * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
       * @example DateTime.utc()                                              //~> now
       * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
       * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
       * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
       * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
       * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
       * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
       * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
       * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
       * @return {DateTime}
       */
      static utc() {
        const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
        opts.zone = FixedOffsetZone.utcInstance;
        return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
      }
      /**
       * Create a DateTime from a JavaScript Date object. Uses the default zone.
       * @param {Date} date - a JavaScript Date object
       * @param {Object} options - configuration options for the DateTime
       * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
       * @return {DateTime}
       */
      static fromJSDate(date, options = {}) {
        const ts = isDate2(date) ? date.valueOf() : NaN;
        if (Number.isNaN(ts)) {
          return DateTime2.invalid("invalid input");
        }
        const zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
        if (!zoneToUse.isValid) {
          return DateTime2.invalid(unsupportedZone(zoneToUse));
        }
        return new DateTime2({
          ts,
          zone: zoneToUse,
          loc: Locale.fromObject(options)
        });
      }
      /**
       * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
       * @param {number} milliseconds - a number of milliseconds since 1970 UTC
       * @param {Object} options - configuration options for the DateTime
       * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
       * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
       * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @return {DateTime}
       */
      static fromMillis(milliseconds, options = {}) {
        if (!isNumber2(milliseconds)) {
          throw new InvalidArgumentError(
            `fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`
          );
        } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
          return DateTime2.invalid("Timestamp out of range");
        } else {
          return new DateTime2({
            ts: milliseconds,
            zone: normalizeZone(options.zone, Settings.defaultZone),
            loc: Locale.fromObject(options)
          });
        }
      }
      /**
       * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
       * @param {number} seconds - a number of seconds since 1970 UTC
       * @param {Object} options - configuration options for the DateTime
       * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
       * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
       * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @return {DateTime}
       */
      static fromSeconds(seconds, options = {}) {
        if (!isNumber2(seconds)) {
          throw new InvalidArgumentError("fromSeconds requires a numerical input");
        } else {
          return new DateTime2({
            ts: seconds * 1e3,
            zone: normalizeZone(options.zone, Settings.defaultZone),
            loc: Locale.fromObject(options)
          });
        }
      }
      /**
       * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
       * @param {Object} obj - the object to create the DateTime from
       * @param {number} obj.year - a year, such as 1987
       * @param {number} obj.month - a month, 1-12
       * @param {number} obj.day - a day of the month, 1-31, depending on the month
       * @param {number} obj.ordinal - day of the year, 1-365 or 366
       * @param {number} obj.weekYear - an ISO week year
       * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
       * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
       * @param {number} obj.hour - hour of the day, 0-23
       * @param {number} obj.minute - minute of the hour, 0-59
       * @param {number} obj.second - second of the minute, 0-59
       * @param {number} obj.millisecond - millisecond of the second, 0-999
       * @param {Object} opts - options for creating this DateTime
       * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
       * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
       * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
       * @return {DateTime}
       */
      static fromObject(obj, opts = {}) {
        obj = obj || {};
        const zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
        if (!zoneToUse.isValid) {
          return DateTime2.invalid(unsupportedZone(zoneToUse));
        }
        const tsNow = Settings.now(), offsetProvis = !isUndefined(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow), normalized = normalizeObject(obj, normalizeUnit), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber, loc = Locale.fromObject(opts);
        if ((containsGregor || containsOrdinal) && definiteWeekDef) {
          throw new ConflictingSpecificationError(
            "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
          );
        }
        if (containsGregorMD && containsOrdinal) {
          throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
        }
        const useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
        let units, defaultValues, objNow = tsToObj(tsNow, offsetProvis);
        if (useWeekData) {
          units = orderedWeekUnits;
          defaultValues = defaultWeekUnitValues;
          objNow = gregorianToWeek(objNow);
        } else if (containsOrdinal) {
          units = orderedOrdinalUnits;
          defaultValues = defaultOrdinalUnitValues;
          objNow = gregorianToOrdinal(objNow);
        } else {
          units = orderedUnits;
          defaultValues = defaultUnitValues;
        }
        let foundFirst = false;
        for (const u3 of units) {
          const v3 = normalized[u3];
          if (!isUndefined(v3)) {
            foundFirst = true;
          } else if (foundFirst) {
            normalized[u3] = defaultValues[u3];
          } else {
            normalized[u3] = objNow[u3];
          }
        }
        const higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized), invalid = higherOrderInvalid || hasInvalidTimeData(normalized);
        if (invalid) {
          return DateTime2.invalid(invalid);
        }
        const gregorian = useWeekData ? weekToGregorian(normalized) : containsOrdinal ? ordinalToGregorian(normalized) : normalized, [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse), inst = new DateTime2({
          ts: tsFinal,
          zone: zoneToUse,
          o: offsetFinal,
          loc
        });
        if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
          return DateTime2.invalid(
            "mismatched weekday",
            `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`
          );
        }
        return inst;
      }
      /**
       * Create a DateTime from an ISO 8601 string
       * @param {string} text - the ISO string
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
       * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
       * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
       * @example DateTime.fromISO('2016-05-25T09:08:34.123')
       * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
       * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
       * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
       * @example DateTime.fromISO('2016-W05-4')
       * @return {DateTime}
       */
      static fromISO(text, opts = {}) {
        const [vals, parsedZone] = parseISODate(text);
        return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text);
      }
      /**
       * Create a DateTime from an RFC 2822 string
       * @param {string} text - the RFC 2822 string
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
       * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
       * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
       * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
       * @return {DateTime}
       */
      static fromRFC2822(text, opts = {}) {
        const [vals, parsedZone] = parseRFC2822Date(text);
        return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text);
      }
      /**
       * Create a DateTime from an HTTP header date
       * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
       * @param {string} text - the HTTP header date
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
       * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
       * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
       * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
       * @return {DateTime}
       */
      static fromHTTP(text, opts = {}) {
        const [vals, parsedZone] = parseHTTPDate(text);
        return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
      }
      /**
       * Create a DateTime from an input string and format string.
       * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
       * @param {string} text - the string to parse
       * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
       * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
       * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @return {DateTime}
       */
      static fromFormat(text, fmt, opts = {}) {
        if (isUndefined(text) || isUndefined(fmt)) {
          throw new InvalidArgumentError("fromFormat requires an input string and a format");
        }
        const { locale = null, numberingSystem = null } = opts, localeToUse = Locale.fromOpts({
          locale,
          numberingSystem,
          defaultToEN: true
        }), [vals, parsedZone, specificOffset, invalid] = parseFromTokens(localeToUse, text, fmt);
        if (invalid) {
          return DateTime2.invalid(invalid);
        } else {
          return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text, specificOffset);
        }
      }
      /**
       * @deprecated use fromFormat instead
       */
      static fromString(text, fmt, opts = {}) {
        return DateTime2.fromFormat(text, fmt, opts);
      }
      /**
       * Create a DateTime from a SQL date, time, or datetime
       * Defaults to en-US if no locale has been specified, regardless of the system's locale
       * @param {string} text - the string to parse
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
       * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
       * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @example DateTime.fromSQL('2017-05-15')
       * @example DateTime.fromSQL('2017-05-15 09:12:34')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
       * @example DateTime.fromSQL('09:12:34.342')
       * @return {DateTime}
       */
      static fromSQL(text, opts = {}) {
        const [vals, parsedZone] = parseSQL(text);
        return parseDataToDateTime(vals, parsedZone, opts, "SQL", text);
      }
      /**
       * Create an invalid DateTime.
       * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent.
       * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
       * @return {DateTime}
       */
      static invalid(reason, explanation = null) {
        if (!reason) {
          throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
        }
        const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
        if (Settings.throwOnInvalid) {
          throw new InvalidDateTimeError(invalid);
        } else {
          return new DateTime2({ invalid });
        }
      }
      /**
       * Check if an object is an instance of DateTime. Works across context boundaries
       * @param {object} o
       * @return {boolean}
       */
      static isDateTime(o2) {
        return o2 && o2.isLuxonDateTime || false;
      }
      /**
       * Produce the format string for a set of options
       * @param formatOpts
       * @param localeOpts
       * @returns {string}
       */
      static parseFormatForOpts(formatOpts, localeOpts = {}) {
        const tokenList = formatOptsToTokens(formatOpts, Locale.fromObject(localeOpts));
        return !tokenList ? null : tokenList.map((t3) => t3 ? t3.val : null).join("");
      }
      /**
       * Produce the the fully expanded format token for the locale
       * Does NOT quote characters, so quoted tokens will not round trip correctly
       * @param fmt
       * @param localeOpts
       * @returns {string}
       */
      static expandFormat(fmt, localeOpts = {}) {
        const expanded = expandMacroTokens(Formatter.parseFormat(fmt), Locale.fromObject(localeOpts));
        return expanded.map((t3) => t3.val).join("");
      }
      // INFO
      /**
       * Get the value of unit.
       * @param {string} unit - a unit such as 'minute' or 'day'
       * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
       * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
       * @return {number}
       */
      get(unit) {
        return this[unit];
      }
      /**
       * Returns whether the DateTime is valid. Invalid DateTimes occur when:
       * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
       * * The DateTime was created by an operation on another invalid date
       * @type {boolean}
       */
      get isValid() {
        return this.invalid === null;
      }
      /**
       * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
       * @type {string}
       */
      get invalidReason() {
        return this.invalid ? this.invalid.reason : null;
      }
      /**
       * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
       * @type {string}
       */
      get invalidExplanation() {
        return this.invalid ? this.invalid.explanation : null;
      }
      /**
       * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
       *
       * @type {string}
       */
      get locale() {
        return this.isValid ? this.loc.locale : null;
      }
      /**
       * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
       *
       * @type {string}
       */
      get numberingSystem() {
        return this.isValid ? this.loc.numberingSystem : null;
      }
      /**
       * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
       *
       * @type {string}
       */
      get outputCalendar() {
        return this.isValid ? this.loc.outputCalendar : null;
      }
      /**
       * Get the time zone associated with this DateTime.
       * @type {Zone}
       */
      get zone() {
        return this._zone;
      }
      /**
       * Get the name of the time zone.
       * @type {string}
       */
      get zoneName() {
        return this.isValid ? this.zone.name : null;
      }
      /**
       * Get the year
       * @example DateTime.local(2017, 5, 25).year //=> 2017
       * @type {number}
       */
      get year() {
        return this.isValid ? this.c.year : NaN;
      }
      /**
       * Get the quarter
       * @example DateTime.local(2017, 5, 25).quarter //=> 2
       * @type {number}
       */
      get quarter() {
        return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
      }
      /**
       * Get the month (1-12).
       * @example DateTime.local(2017, 5, 25).month //=> 5
       * @type {number}
       */
      get month() {
        return this.isValid ? this.c.month : NaN;
      }
      /**
       * Get the day of the month (1-30ish).
       * @example DateTime.local(2017, 5, 25).day //=> 25
       * @type {number}
       */
      get day() {
        return this.isValid ? this.c.day : NaN;
      }
      /**
       * Get the hour of the day (0-23).
       * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
       * @type {number}
       */
      get hour() {
        return this.isValid ? this.c.hour : NaN;
      }
      /**
       * Get the minute of the hour (0-59).
       * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
       * @type {number}
       */
      get minute() {
        return this.isValid ? this.c.minute : NaN;
      }
      /**
       * Get the second of the minute (0-59).
       * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
       * @type {number}
       */
      get second() {
        return this.isValid ? this.c.second : NaN;
      }
      /**
       * Get the millisecond of the second (0-999).
       * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
       * @type {number}
       */
      get millisecond() {
        return this.isValid ? this.c.millisecond : NaN;
      }
      /**
       * Get the week year
       * @see https://en.wikipedia.org/wiki/ISO_week_date
       * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
       * @type {number}
       */
      get weekYear() {
        return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
      }
      /**
       * Get the week number of the week year (1-52ish).
       * @see https://en.wikipedia.org/wiki/ISO_week_date
       * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
       * @type {number}
       */
      get weekNumber() {
        return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
      }
      /**
       * Get the day of the week.
       * 1 is Monday and 7 is Sunday
       * @see https://en.wikipedia.org/wiki/ISO_week_date
       * @example DateTime.local(2014, 11, 31).weekday //=> 4
       * @type {number}
       */
      get weekday() {
        return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
      }
      /**
       * Get the ordinal (meaning the day of the year)
       * @example DateTime.local(2017, 5, 25).ordinal //=> 145
       * @type {number|DateTime}
       */
      get ordinal() {
        return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
      }
      /**
       * Get the human readable short month name, such as 'Oct'.
       * Defaults to the system's locale if no locale has been specified
       * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
       * @type {string}
       */
      get monthShort() {
        return this.isValid ? Info.months("short", { locObj: this.loc })[this.month - 1] : null;
      }
      /**
       * Get the human readable long month name, such as 'October'.
       * Defaults to the system's locale if no locale has been specified
       * @example DateTime.local(2017, 10, 30).monthLong //=> October
       * @type {string}
       */
      get monthLong() {
        return this.isValid ? Info.months("long", { locObj: this.loc })[this.month - 1] : null;
      }
      /**
       * Get the human readable short weekday, such as 'Mon'.
       * Defaults to the system's locale if no locale has been specified
       * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
       * @type {string}
       */
      get weekdayShort() {
        return this.isValid ? Info.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
      }
      /**
       * Get the human readable long weekday, such as 'Monday'.
       * Defaults to the system's locale if no locale has been specified
       * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
       * @type {string}
       */
      get weekdayLong() {
        return this.isValid ? Info.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
      }
      /**
       * Get the UTC offset of this DateTime in minutes
       * @example DateTime.now().offset //=> -240
       * @example DateTime.utc().offset //=> 0
       * @type {number}
       */
      get offset() {
        return this.isValid ? +this.o : NaN;
      }
      /**
       * Get the short human name for the zone's current offset, for example "EST" or "EDT".
       * Defaults to the system's locale if no locale has been specified
       * @type {string}
       */
      get offsetNameShort() {
        if (this.isValid) {
          return this.zone.offsetName(this.ts, {
            format: "short",
            locale: this.locale
          });
        } else {
          return null;
        }
      }
      /**
       * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
       * Defaults to the system's locale if no locale has been specified
       * @type {string}
       */
      get offsetNameLong() {
        if (this.isValid) {
          return this.zone.offsetName(this.ts, {
            format: "long",
            locale: this.locale
          });
        } else {
          return null;
        }
      }
      /**
       * Get whether this zone's offset ever changes, as in a DST.
       * @type {boolean}
       */
      get isOffsetFixed() {
        return this.isValid ? this.zone.isUniversal : null;
      }
      /**
       * Get whether the DateTime is in a DST.
       * @type {boolean}
       */
      get isInDST() {
        if (this.isOffsetFixed) {
          return false;
        } else {
          return this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
        }
      }
      /**
       * Get those DateTimes which have the same local time as this DateTime, but a different offset from UTC
       * in this DateTime's zone. During DST changes local time can be ambiguous, for example
       * `2023-10-29T02:30:00` in `Europe/Berlin` can have offset `+01:00` or `+02:00`.
       * This method will return both possible DateTimes if this DateTime's local time is ambiguous.
       * @returns {DateTime[]}
       */
      getPossibleOffsets() {
        if (!this.isValid || this.isOffsetFixed) {
          return [this];
        }
        const dayMs = 864e5;
        const minuteMs = 6e4;
        const localTS = objToLocalTS(this.c);
        const oEarlier = this.zone.offset(localTS - dayMs);
        const oLater = this.zone.offset(localTS + dayMs);
        const o1 = this.zone.offset(localTS - oEarlier * minuteMs);
        const o2 = this.zone.offset(localTS - oLater * minuteMs);
        if (o1 === o2) {
          return [this];
        }
        const ts1 = localTS - o1 * minuteMs;
        const ts2 = localTS - o2 * minuteMs;
        const c1 = tsToObj(ts1, o1);
        const c22 = tsToObj(ts2, o2);
        if (c1.hour === c22.hour && c1.minute === c22.minute && c1.second === c22.second && c1.millisecond === c22.millisecond) {
          return [clone2(this, { ts: ts1 }), clone2(this, { ts: ts2 })];
        }
        return [this];
      }
      /**
       * Returns true if this DateTime is in a leap year, false otherwise
       * @example DateTime.local(2016).isInLeapYear //=> true
       * @example DateTime.local(2013).isInLeapYear //=> false
       * @type {boolean}
       */
      get isInLeapYear() {
        return isLeapYear2(this.year);
      }
      /**
       * Returns the number of days in this DateTime's month
       * @example DateTime.local(2016, 2).daysInMonth //=> 29
       * @example DateTime.local(2016, 3).daysInMonth //=> 31
       * @type {number}
       */
      get daysInMonth() {
        return daysInMonth(this.year, this.month);
      }
      /**
       * Returns the number of days in this DateTime's year
       * @example DateTime.local(2016).daysInYear //=> 366
       * @example DateTime.local(2013).daysInYear //=> 365
       * @type {number}
       */
      get daysInYear() {
        return this.isValid ? daysInYear(this.year) : NaN;
      }
      /**
       * Returns the number of weeks in this DateTime's year
       * @see https://en.wikipedia.org/wiki/ISO_week_date
       * @example DateTime.local(2004).weeksInWeekYear //=> 53
       * @example DateTime.local(2013).weeksInWeekYear //=> 52
       * @type {number}
       */
      get weeksInWeekYear() {
        return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
      }
      /**
       * Returns the resolved Intl options for this DateTime.
       * This is useful in understanding the behavior of formatting methods
       * @param {Object} opts - the same options as toLocaleString
       * @return {Object}
       */
      resolvedLocaleOptions(opts = {}) {
        const { locale, numberingSystem, calendar } = Formatter.create(
          this.loc.clone(opts),
          opts
        ).resolvedOptions(this);
        return { locale, numberingSystem, outputCalendar: calendar };
      }
      // TRANSFORM
      /**
       * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
       *
       * Equivalent to {@link DateTime#setZone}('utc')
       * @param {number} [offset=0] - optionally, an offset from UTC in minutes
       * @param {Object} [opts={}] - options to pass to `setZone()`
       * @return {DateTime}
       */
      toUTC(offset2 = 0, opts = {}) {
        return this.setZone(FixedOffsetZone.instance(offset2), opts);
      }
      /**
       * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
       *
       * Equivalent to `setZone('local')`
       * @return {DateTime}
       */
      toLocal() {
        return this.setZone(Settings.defaultZone);
      }
      /**
       * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
       *
       * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
       * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
       * @param {Object} opts - options
       * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
       * @return {DateTime}
       */
      setZone(zone, { keepLocalTime = false, keepCalendarTime = false } = {}) {
        zone = normalizeZone(zone, Settings.defaultZone);
        if (zone.equals(this.zone)) {
          return this;
        } else if (!zone.isValid) {
          return DateTime2.invalid(unsupportedZone(zone));
        } else {
          let newTS = this.ts;
          if (keepLocalTime || keepCalendarTime) {
            const offsetGuess = zone.offset(this.ts);
            const asObj = this.toObject();
            [newTS] = objToTS(asObj, offsetGuess, zone);
          }
          return clone2(this, { ts: newTS, zone });
        }
      }
      /**
       * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
       * @param {Object} properties - the properties to set
       * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
       * @return {DateTime}
       */
      reconfigure({ locale, numberingSystem, outputCalendar } = {}) {
        const loc = this.loc.clone({ locale, numberingSystem, outputCalendar });
        return clone2(this, { loc });
      }
      /**
       * "Set" the locale. Returns a newly-constructed DateTime.
       * Just a convenient alias for reconfigure({ locale })
       * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
       * @return {DateTime}
       */
      setLocale(locale) {
        return this.reconfigure({ locale });
      }
      /**
       * "Set" the values of specified units. Returns a newly-constructed DateTime.
       * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
       * @param {Object} values - a mapping of units to numbers
       * @example dt.set({ year: 2017 })
       * @example dt.set({ hour: 8, minute: 30 })
       * @example dt.set({ weekday: 5 })
       * @example dt.set({ year: 2005, ordinal: 234 })
       * @return {DateTime}
       */
      set(values) {
        if (!this.isValid)
          return this;
        const normalized = normalizeObject(values, normalizeUnit), settingWeekStuff = !isUndefined(normalized.weekYear) || !isUndefined(normalized.weekNumber) || !isUndefined(normalized.weekday), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
        if ((containsGregor || containsOrdinal) && definiteWeekDef) {
          throw new ConflictingSpecificationError(
            "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
          );
        }
        if (containsGregorMD && containsOrdinal) {
          throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
        }
        let mixed;
        if (settingWeekStuff) {
          mixed = weekToGregorian({ ...gregorianToWeek(this.c), ...normalized });
        } else if (!isUndefined(normalized.ordinal)) {
          mixed = ordinalToGregorian({ ...gregorianToOrdinal(this.c), ...normalized });
        } else {
          mixed = { ...this.toObject(), ...normalized };
          if (isUndefined(normalized.day)) {
            mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
          }
        }
        const [ts, o2] = objToTS(mixed, this.o, this.zone);
        return clone2(this, { ts, o: o2 });
      }
      /**
       * Add a period of time to this DateTime and return the resulting DateTime
       *
       * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
       * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       * @example DateTime.now().plus(123) //~> in 123 milliseconds
       * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
       * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
       * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
       * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
       * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
       * @return {DateTime}
       */
      plus(duration) {
        if (!this.isValid)
          return this;
        const dur = Duration.fromDurationLike(duration);
        return clone2(this, adjustTime(this, dur));
      }
      /**
       * Subtract a period of time to this DateTime and return the resulting DateTime
       * See {@link DateTime#plus}
       * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       @return {DateTime}
       */
      minus(duration) {
        if (!this.isValid)
          return this;
        const dur = Duration.fromDurationLike(duration).negate();
        return clone2(this, adjustTime(this, dur));
      }
      /**
       * "Set" this DateTime to the beginning of a unit of time.
       * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
       * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
       * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
       * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
       * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
       * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
       * @return {DateTime}
       */
      startOf(unit) {
        if (!this.isValid)
          return this;
        const o2 = {}, normalizedUnit = Duration.normalizeUnit(unit);
        switch (normalizedUnit) {
          case "years":
            o2.month = 1;
          case "quarters":
          case "months":
            o2.day = 1;
          case "weeks":
          case "days":
            o2.hour = 0;
          case "hours":
            o2.minute = 0;
          case "minutes":
            o2.second = 0;
          case "seconds":
            o2.millisecond = 0;
            break;
        }
        if (normalizedUnit === "weeks") {
          o2.weekday = 1;
        }
        if (normalizedUnit === "quarters") {
          const q3 = Math.ceil(this.month / 3);
          o2.month = (q3 - 1) * 3 + 1;
        }
        return this.set(o2);
      }
      /**
       * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
       * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
       * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
       * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
       * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
       * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
       * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
       * @return {DateTime}
       */
      endOf(unit) {
        return this.isValid ? this.plus({ [unit]: 1 }).startOf(unit).minus(1) : this;
      }
      // OUTPUT
      /**
       * Returns a string representation of this DateTime formatted according to the specified format string.
       * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
       * Defaults to en-US if no locale has been specified, regardless of the system's locale.
       * @param {string} fmt - the format string
       * @param {Object} opts - opts to override the configuration options on this DateTime
       * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
       * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
       * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
       * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
       * @return {string}
       */
      toFormat(fmt, opts = {}) {
        return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID;
      }
      /**
       * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
       * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
       * of the DateTime in the assigned locale.
       * Defaults to the system's locale if no locale has been specified
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
       * @param {Object} opts - opts to override the configuration options on this DateTime
       * @example DateTime.now().toLocaleString(); //=> 4/20/2017
       * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
       * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
       * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 aot 2022'
       * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
       * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
       * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
       * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
       * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
       * @return {string}
       */
      toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
        return this.isValid ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID;
      }
      /**
       * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
       * Defaults to the system's locale if no locale has been specified
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
       * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
       * @example DateTime.now().toLocaleParts(); //=> [
       *                                   //=>   { type: 'day', value: '25' },
       *                                   //=>   { type: 'literal', value: '/' },
       *                                   //=>   { type: 'month', value: '05' },
       *                                   //=>   { type: 'literal', value: '/' },
       *                                   //=>   { type: 'year', value: '1982' }
       *                                   //=> ]
       */
      toLocaleParts(opts = {}) {
        return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime
       * @param {Object} opts - options
       * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
       * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @param {boolean} [opts.extendedZone=false] - add the time zone format extension
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
       * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
       * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
       * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
       * @return {string}
       */
      toISO({
        format = "extended",
        suppressSeconds = false,
        suppressMilliseconds = false,
        includeOffset = true,
        extendedZone = false
      } = {}) {
        if (!this.isValid) {
          return null;
        }
        const ext = format === "extended";
        let c3 = toISODate(this, ext);
        c3 += "T";
        c3 += toISOTime(this, ext, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
        return c3;
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime's date component
       * @param {Object} opts - options
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
       * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
       * @return {string}
       */
      toISODate({ format = "extended" } = {}) {
        if (!this.isValid) {
          return null;
        }
        return toISODate(this, format === "extended");
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime's week date
       * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
       * @return {string}
       */
      toISOWeekDate() {
        return toTechFormat(this, "kkkk-'W'WW-c");
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime's time component
       * @param {Object} opts - options
       * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
       * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
       * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
       * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
       * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
       * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
       * @return {string}
       */
      toISOTime({
        suppressMilliseconds = false,
        suppressSeconds = false,
        includeOffset = true,
        includePrefix = false,
        extendedZone = false,
        format = "extended"
      } = {}) {
        if (!this.isValid) {
          return null;
        }
        let c3 = includePrefix ? "T" : "";
        return c3 + toISOTime(
          this,
          format === "extended",
          suppressSeconds,
          suppressMilliseconds,
          includeOffset,
          extendedZone
        );
      }
      /**
       * Returns an RFC 2822-compatible string representation of this DateTime
       * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
       * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
       * @return {string}
       */
      toRFC2822() {
        return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
       * Specifically, the string conforms to RFC 1123.
       * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
       * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
       * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
       * @return {string}
       */
      toHTTP() {
        return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in SQL Date
       * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
       * @return {string}
       */
      toSQLDate() {
        if (!this.isValid) {
          return null;
        }
        return toISODate(this, true);
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in SQL Time
       * @param {Object} opts - options
       * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
       * @example DateTime.utc().toSQL() //=> '05:15:16.345'
       * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
       * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
       * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
       * @return {string}
       */
      toSQLTime({ includeOffset = true, includeZone = false, includeOffsetSpace = true } = {}) {
        let fmt = "HH:mm:ss.SSS";
        if (includeZone || includeOffset) {
          if (includeOffsetSpace) {
            fmt += " ";
          }
          if (includeZone) {
            fmt += "z";
          } else if (includeOffset) {
            fmt += "ZZ";
          }
        }
        return toTechFormat(this, fmt, true);
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in SQL DateTime
       * @param {Object} opts - options
       * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
       * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
       * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
       * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
       * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
       * @return {string}
       */
      toSQL(opts = {}) {
        if (!this.isValid) {
          return null;
        }
        return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
      }
      /**
       * Returns a string representation of this DateTime appropriate for debugging
       * @return {string}
       */
      toString() {
        return this.isValid ? this.toISO() : INVALID;
      }
      /**
       * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
       * @return {number}
       */
      valueOf() {
        return this.toMillis();
      }
      /**
       * Returns the epoch milliseconds of this DateTime.
       * @return {number}
       */
      toMillis() {
        return this.isValid ? this.ts : NaN;
      }
      /**
       * Returns the epoch seconds of this DateTime.
       * @return {number}
       */
      toSeconds() {
        return this.isValid ? this.ts / 1e3 : NaN;
      }
      /**
       * Returns the epoch seconds (as a whole number) of this DateTime.
       * @return {number}
       */
      toUnixInteger() {
        return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
      }
      /**
       * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
       * @return {string}
       */
      toJSON() {
        return this.toISO();
      }
      /**
       * Returns a BSON serializable equivalent to this DateTime.
       * @return {Date}
       */
      toBSON() {
        return this.toJSDate();
      }
      /**
       * Returns a JavaScript object with this DateTime's year, month, day, and so on.
       * @param opts - options for generating the object
       * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
       * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
       * @return {Object}
       */
      toObject(opts = {}) {
        if (!this.isValid)
          return {};
        const base = { ...this.c };
        if (opts.includeConfig) {
          base.outputCalendar = this.outputCalendar;
          base.numberingSystem = this.loc.numberingSystem;
          base.locale = this.loc.locale;
        }
        return base;
      }
      /**
       * Returns a JavaScript Date equivalent to this DateTime.
       * @return {Date}
       */
      toJSDate() {
        return new Date(this.isValid ? this.ts : NaN);
      }
      // COMPARE
      /**
       * Return the difference between two DateTimes as a Duration.
       * @param {DateTime} otherDateTime - the DateTime to compare this one to
       * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
       * @param {Object} opts - options that affect the creation of the Duration
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @example
       * var i1 = DateTime.fromISO('1982-05-25T09:45'),
       *     i2 = DateTime.fromISO('1983-10-14T10:30');
       * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
       * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
       * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
       * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
       * @return {Duration}
       */
      diff(otherDateTime, unit = "milliseconds", opts = {}) {
        if (!this.isValid || !otherDateTime.isValid) {
          return Duration.invalid("created by diffing an invalid DateTime");
        }
        const durOpts = { locale: this.locale, numberingSystem: this.numberingSystem, ...opts };
        const units = maybeArray(unit).map(Duration.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = diff(earlier, later, units, durOpts);
        return otherIsLater ? diffed.negate() : diffed;
      }
      /**
       * Return the difference between this DateTime and right now.
       * See {@link DateTime#diff}
       * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
       * @param {Object} opts - options that affect the creation of the Duration
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @return {Duration}
       */
      diffNow(unit = "milliseconds", opts = {}) {
        return this.diff(DateTime2.now(), unit, opts);
      }
      /**
       * Return an Interval spanning between this DateTime and another DateTime
       * @param {DateTime} otherDateTime - the other end point of the Interval
       * @return {Interval}
       */
      until(otherDateTime) {
        return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
      }
      /**
       * Return whether this DateTime is in the same unit of time as another DateTime.
       * Higher-order units must also be identical for this function to return `true`.
       * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
       * @param {DateTime} otherDateTime - the other DateTime
       * @param {string} unit - the unit of time to check sameness on
       * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
       * @return {boolean}
       */
      hasSame(otherDateTime, unit) {
        if (!this.isValid)
          return false;
        const inputMs = otherDateTime.valueOf();
        const adjustedToZone = this.setZone(otherDateTime.zone, { keepLocalTime: true });
        return adjustedToZone.startOf(unit) <= inputMs && inputMs <= adjustedToZone.endOf(unit);
      }
      /**
       * Equality check
       * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.
       * To compare just the millisecond values, use `+dt1 === +dt2`.
       * @param {DateTime} other - the other DateTime
       * @return {boolean}
       */
      equals(other) {
        return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
      }
      /**
       * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
       * platform supports Intl.RelativeTimeFormat. Rounds down by default.
       * @param {Object} options - options that affect the output
       * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
       * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
       * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
       * @param {boolean} [options.round=true] - whether to round the numbers in the output.
       * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
       * @param {string} options.locale - override the locale of this DateTime
       * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
       * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
       * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 da"
       * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
       * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
       * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
       * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
       */
      toRelative(options = {}) {
        if (!this.isValid)
          return null;
        const base = options.base || DateTime2.fromObject({}, { zone: this.zone }), padding = options.padding ? this < base ? -options.padding : options.padding : 0;
        let units = ["years", "months", "days", "hours", "minutes", "seconds"];
        let unit = options.unit;
        if (Array.isArray(options.unit)) {
          units = options.unit;
          unit = void 0;
        }
        return diffRelative(base, this.plus(padding), {
          ...options,
          numeric: "always",
          units,
          unit
        });
      }
      /**
       * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
       * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
       * @param {Object} options - options that affect the output
       * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
       * @param {string} options.locale - override the locale of this DateTime
       * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
       * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
       * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
       * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""maana"
       * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
       * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
       */
      toRelativeCalendar(options = {}) {
        if (!this.isValid)
          return null;
        return diffRelative(options.base || DateTime2.fromObject({}, { zone: this.zone }), this, {
          ...options,
          numeric: "auto",
          units: ["years", "months", "days"],
          calendary: true
        });
      }
      /**
       * Return the min of several date times
       * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
       * @return {DateTime} the min DateTime, or undefined if called with no argument
       */
      static min(...dateTimes) {
        if (!dateTimes.every(DateTime2.isDateTime)) {
          throw new InvalidArgumentError("min requires all arguments be DateTimes");
        }
        return bestBy(dateTimes, (i3) => i3.valueOf(), Math.min);
      }
      /**
       * Return the max of several date times
       * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
       * @return {DateTime} the max DateTime, or undefined if called with no argument
       */
      static max(...dateTimes) {
        if (!dateTimes.every(DateTime2.isDateTime)) {
          throw new InvalidArgumentError("max requires all arguments be DateTimes");
        }
        return bestBy(dateTimes, (i3) => i3.valueOf(), Math.max);
      }
      // MISC
      /**
       * Explain how a string would be parsed by fromFormat()
       * @param {string} text - the string to parse
       * @param {string} fmt - the format the string is expected to be in (see description)
       * @param {Object} options - options taken by fromFormat()
       * @return {Object}
       */
      static fromFormatExplain(text, fmt, options = {}) {
        const { locale = null, numberingSystem = null } = options, localeToUse = Locale.fromOpts({
          locale,
          numberingSystem,
          defaultToEN: true
        });
        return explainFromTokens(localeToUse, text, fmt);
      }
      /**
       * @deprecated use fromFormatExplain instead
       */
      static fromStringExplain(text, fmt, options = {}) {
        return DateTime2.fromFormatExplain(text, fmt, options);
      }
      // FORMAT PRESETS
      /**
       * {@link DateTime#toLocaleString} format like 10/14/1983
       * @type {Object}
       */
      static get DATE_SHORT() {
        return DATE_SHORT;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
       * @type {Object}
       */
      static get DATE_MED() {
        return DATE_MED;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
       * @type {Object}
       */
      static get DATE_MED_WITH_WEEKDAY() {
        return DATE_MED_WITH_WEEKDAY;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'October 14, 1983'
       * @type {Object}
       */
      static get DATE_FULL() {
        return DATE_FULL;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
       * @type {Object}
       */
      static get DATE_HUGE() {
        return DATE_HUGE;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get TIME_SIMPLE() {
        return TIME_SIMPLE;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get TIME_WITH_SECONDS() {
        return TIME_WITH_SECONDS;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get TIME_WITH_SHORT_OFFSET() {
        return TIME_WITH_SHORT_OFFSET;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get TIME_WITH_LONG_OFFSET() {
        return TIME_WITH_LONG_OFFSET;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
       * @type {Object}
       */
      static get TIME_24_SIMPLE() {
        return TIME_24_SIMPLE;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
       * @type {Object}
       */
      static get TIME_24_WITH_SECONDS() {
        return TIME_24_WITH_SECONDS;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
       * @type {Object}
       */
      static get TIME_24_WITH_SHORT_OFFSET() {
        return TIME_24_WITH_SHORT_OFFSET;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
       * @type {Object}
       */
      static get TIME_24_WITH_LONG_OFFSET() {
        return TIME_24_WITH_LONG_OFFSET;
      }
      /**
       * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_SHORT() {
        return DATETIME_SHORT;
      }
      /**
       * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_SHORT_WITH_SECONDS() {
        return DATETIME_SHORT_WITH_SECONDS;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_MED() {
        return DATETIME_MED;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_MED_WITH_SECONDS() {
        return DATETIME_MED_WITH_SECONDS;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_MED_WITH_WEEKDAY() {
        return DATETIME_MED_WITH_WEEKDAY;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_FULL() {
        return DATETIME_FULL;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_FULL_WITH_SECONDS() {
        return DATETIME_FULL_WITH_SECONDS;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_HUGE() {
        return DATETIME_HUGE;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_HUGE_WITH_SECONDS() {
        return DATETIME_HUGE_WITH_SECONDS;
      }
    };
    function friendlyDateTime(dateTimeish) {
      if (DateTime2.isDateTime(dateTimeish)) {
        return dateTimeish;
      } else if (dateTimeish && dateTimeish.valueOf && isNumber2(dateTimeish.valueOf())) {
        return DateTime2.fromJSDate(dateTimeish);
      } else if (dateTimeish && typeof dateTimeish === "object") {
        return DateTime2.fromObject(dateTimeish);
      } else {
        throw new InvalidArgumentError(
          `Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`
        );
      }
    }
    var DEFAULT_QUERY_SETTINGS = {
      renderNullAs: "\\-",
      taskCompletionTracking: false,
      taskCompletionUseEmojiShorthand: false,
      taskCompletionText: "completion",
      taskCompletionDateFormat: "yyyy-MM-dd",
      recursiveSubTaskCompletion: false,
      warnOnEmptyResult: true,
      refreshEnabled: true,
      refreshInterval: 2500,
      defaultDateFormat: "MMMM dd, yyyy",
      defaultDateTimeFormat: "h:mm a - MMMM dd, yyyy",
      maxRecursiveRenderDepth: 4,
      tableIdColumnName: "File",
      tableGroupColumnName: "Group",
      showResultCount: true
    };
    var DEFAULT_EXPORT_SETTINGS = {
      allowHtml: true
    };
    ({
      ...DEFAULT_QUERY_SETTINGS,
      ...DEFAULT_EXPORT_SETTINGS,
      ...{
        inlineQueryPrefix: "=",
        inlineJsQueryPrefix: "$=",
        inlineQueriesInCodeblocks: true,
        enableInlineDataview: true,
        enableDataviewJs: false,
        enableInlineDataviewJs: false,
        prettyRenderInlineFields: true,
        prettyRenderInlineFieldsInLivePreview: true,
        dataviewJsKeyword: "dataviewjs"
      }
    });
    var Success = class {
      constructor(value) {
        __publicField(this, "value");
        __publicField(this, "successful");
        this.value = value;
        this.successful = true;
      }
      map(f3) {
        return new Success(f3(this.value));
      }
      flatMap(f3) {
        return f3(this.value);
      }
      mapErr(f3) {
        return this;
      }
      bimap(succ, _fail) {
        return this.map(succ);
      }
      orElse(_value) {
        return this.value;
      }
      cast() {
        return this;
      }
      orElseThrow(_message) {
        return this.value;
      }
    };
    var Failure = class {
      constructor(error) {
        __publicField(this, "error");
        __publicField(this, "successful");
        this.error = error;
        this.successful = false;
      }
      map(_f) {
        return this;
      }
      flatMap(_f) {
        return this;
      }
      mapErr(f3) {
        return new Failure(f3(this.error));
      }
      bimap(_succ, fail) {
        return this.mapErr(fail);
      }
      orElse(value) {
        return value;
      }
      cast() {
        return this;
      }
      orElseThrow(message) {
        if (message)
          throw new Error(message(this.error));
        else
          throw new Error("" + this.error);
      }
    };
    var Result;
    (function(Result2) {
      function success(value) {
        return new Success(value);
      }
      Result2.success = success;
      function failure(error) {
        return new Failure(error);
      }
      Result2.failure = failure;
      function flatMap2(first, second, f3) {
        if (first.successful) {
          if (second.successful)
            return f3(first.value, second.value);
          else
            return failure(second.error);
        } else {
          return failure(first.error);
        }
      }
      Result2.flatMap2 = flatMap2;
      function map2(first, second, f3) {
        return flatMap2(first, second, (a3, b3) => success(f3(a3, b3)));
      }
      Result2.map2 = map2;
    })(Result || (Result = {}));
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    var parsimmon_umd_min = { exports: {} };
    parsimmon_umd_min.exports;
    (function(module3, exports2) {
      !function(n3, t3) {
        module3.exports = t3();
      }("undefined" != typeof self ? self : commonjsGlobal, function() {
        return function(n3) {
          var t3 = {};
          function r3(e3) {
            if (t3[e3])
              return t3[e3].exports;
            var u3 = t3[e3] = { i: e3, l: false, exports: {} };
            return n3[e3].call(u3.exports, u3, u3.exports, r3), u3.l = true, u3.exports;
          }
          return r3.m = n3, r3.c = t3, r3.d = function(n4, t4, e3) {
            r3.o(n4, t4) || Object.defineProperty(n4, t4, { configurable: false, enumerable: true, get: e3 });
          }, r3.r = function(n4) {
            Object.defineProperty(n4, "__esModule", { value: true });
          }, r3.n = function(n4) {
            var t4 = n4 && n4.__esModule ? function() {
              return n4.default;
            } : function() {
              return n4;
            };
            return r3.d(t4, "a", t4), t4;
          }, r3.o = function(n4, t4) {
            return Object.prototype.hasOwnProperty.call(n4, t4);
          }, r3.p = "", r3(r3.s = 0);
        }([function(n3, t3, r3) {
          function e3(n4) {
            if (!(this instanceof e3))
              return new e3(n4);
            this._ = n4;
          }
          var u3 = e3.prototype;
          function o2(n4, t4) {
            for (var r4 = 0; r4 < n4; r4++)
              t4(r4);
          }
          function i3(n4, t4, r4) {
            return function(n5, t5) {
              o2(t5.length, function(r5) {
                n5(t5[r5], r5, t5);
              });
            }(function(r5, e4, u4) {
              t4 = n4(t4, r5, e4, u4);
            }, r4), t4;
          }
          function a3(n4, t4) {
            return i3(function(t5, r4, e4, u4) {
              return t5.concat([n4(r4, e4, u4)]);
            }, [], t4);
          }
          function f3(n4, t4) {
            var r4 = { v: 0, buf: t4 };
            return o2(n4, function() {
              var n5;
              r4 = { v: r4.v << 1 | (n5 = r4.buf, n5[0] >> 7), buf: function(n6) {
                var t5 = i3(function(n7, t6, r5, e4) {
                  return n7.concat(r5 === e4.length - 1 ? Buffer.from([t6, 0]).readUInt16BE(0) : e4.readUInt16BE(r5));
                }, [], n6);
                return Buffer.from(a3(function(n7) {
                  return (n7 << 1 & 65535) >> 8;
                }, t5));
              }(r4.buf) };
            }), r4;
          }
          function c3() {
            return "undefined" != typeof Buffer;
          }
          function s4() {
            if (!c3())
              throw new Error("Buffer global does not exist; please use webpack if you need to parse Buffers in the browser.");
          }
          function l4(n4) {
            s4();
            var t4 = i3(function(n5, t5) {
              return n5 + t5;
            }, 0, n4);
            if (t4 % 8 != 0)
              throw new Error("The bits [" + n4.join(", ") + "] add up to " + t4 + " which is not an even number of bytes; the total should be divisible by 8");
            var r4, u4 = t4 / 8, o3 = (r4 = function(n5) {
              return n5 > 48;
            }, i3(function(n5, t5) {
              return n5 || (r4(t5) ? t5 : n5);
            }, null, n4));
            if (o3)
              throw new Error(o3 + " bit range requested exceeds 48 bit (6 byte) Number max.");
            return new e3(function(t5, r5) {
              var e4 = u4 + r5;
              return e4 > t5.length ? x4(r5, u4.toString() + " bytes") : b3(e4, i3(function(n5, t6) {
                var r6 = f3(t6, n5.buf);
                return { coll: n5.coll.concat(r6.v), buf: r6.buf };
              }, { coll: [], buf: t5.slice(r5, e4) }, n4).coll);
            });
          }
          function h3(n4, t4) {
            return new e3(function(r4, e4) {
              return s4(), e4 + t4 > r4.length ? x4(e4, t4 + " bytes for " + n4) : b3(e4 + t4, r4.slice(e4, e4 + t4));
            });
          }
          function p3(n4, t4) {
            if ("number" != typeof (r4 = t4) || Math.floor(r4) !== r4 || t4 < 0 || t4 > 6)
              throw new Error(n4 + " requires integer length in range [0, 6].");
            var r4;
          }
          function d2(n4) {
            return p3("uintBE", n4), h3("uintBE(" + n4 + ")", n4).map(function(t4) {
              return t4.readUIntBE(0, n4);
            });
          }
          function v3(n4) {
            return p3("uintLE", n4), h3("uintLE(" + n4 + ")", n4).map(function(t4) {
              return t4.readUIntLE(0, n4);
            });
          }
          function g4(n4) {
            return p3("intBE", n4), h3("intBE(" + n4 + ")", n4).map(function(t4) {
              return t4.readIntBE(0, n4);
            });
          }
          function m3(n4) {
            return p3("intLE", n4), h3("intLE(" + n4 + ")", n4).map(function(t4) {
              return t4.readIntLE(0, n4);
            });
          }
          function y3(n4) {
            return n4 instanceof e3;
          }
          function E2(n4) {
            return "[object Array]" === {}.toString.call(n4);
          }
          function w4(n4) {
            return c3() && Buffer.isBuffer(n4);
          }
          function b3(n4, t4) {
            return { status: true, index: n4, value: t4, furthest: -1, expected: [] };
          }
          function x4(n4, t4) {
            return E2(t4) || (t4 = [t4]), { status: false, index: -1, value: null, furthest: n4, expected: t4 };
          }
          function B3(n4, t4) {
            if (!t4)
              return n4;
            if (n4.furthest > t4.furthest)
              return n4;
            var r4 = n4.furthest === t4.furthest ? function(n5, t5) {
              if (function() {
                if (void 0 !== e3._supportsSet)
                  return e3._supportsSet;
                var n6 = "undefined" != typeof Set;
                return e3._supportsSet = n6, n6;
              }() && Array.from) {
                for (var r5 = new Set(n5), u4 = 0; u4 < t5.length; u4++)
                  r5.add(t5[u4]);
                var o3 = Array.from(r5);
                return o3.sort(), o3;
              }
              for (var i4 = {}, a4 = 0; a4 < n5.length; a4++)
                i4[n5[a4]] = true;
              for (var f4 = 0; f4 < t5.length; f4++)
                i4[t5[f4]] = true;
              var c4 = [];
              for (var s5 in i4)
                ({}).hasOwnProperty.call(i4, s5) && c4.push(s5);
              return c4.sort(), c4;
            }(n4.expected, t4.expected) : t4.expected;
            return { status: n4.status, index: n4.index, value: n4.value, furthest: t4.furthest, expected: r4 };
          }
          var j4 = {};
          function S2(n4, t4) {
            if (w4(n4))
              return { offset: t4, line: -1, column: -1 };
            n4 in j4 || (j4[n4] = {});
            for (var r4 = j4[n4], e4 = 0, u4 = 0, o3 = 0, i4 = t4; i4 >= 0; ) {
              if (i4 in r4) {
                e4 = r4[i4].line, 0 === o3 && (o3 = r4[i4].lineStart);
                break;
              }
              ("\n" === n4.charAt(i4) || "\r" === n4.charAt(i4) && "\n" !== n4.charAt(i4 + 1)) && (u4++, 0 === o3 && (o3 = i4 + 1)), i4--;
            }
            var a4 = e4 + u4, f4 = t4 - o3;
            return r4[t4] = { line: a4, lineStart: o3 }, { offset: t4, line: a4 + 1, column: f4 + 1 };
          }
          function _3(n4) {
            if (!y3(n4))
              throw new Error("not a parser: " + n4);
          }
          function L3(n4, t4) {
            return "string" == typeof n4 ? n4.charAt(t4) : n4[t4];
          }
          function O2(n4) {
            if ("number" != typeof n4)
              throw new Error("not a number: " + n4);
          }
          function k3(n4) {
            if ("function" != typeof n4)
              throw new Error("not a function: " + n4);
          }
          function P3(n4) {
            if ("string" != typeof n4)
              throw new Error("not a string: " + n4);
          }
          var q3 = 2, A3 = 3, I3 = 8, F4 = 5 * I3, M2 = 4 * I3, z3 = "  ";
          function R(n4, t4) {
            return new Array(t4 + 1).join(n4);
          }
          function U2(n4, t4, r4) {
            var e4 = t4 - n4.length;
            return e4 <= 0 ? n4 : R(r4, e4) + n4;
          }
          function W2(n4, t4, r4, e4) {
            return { from: n4 - t4 > 0 ? n4 - t4 : 0, to: n4 + r4 > e4 ? e4 : n4 + r4 };
          }
          function D3(n4, t4) {
            var r4, e4, u4, o3, f4, c4 = t4.index, s5 = c4.offset, l5 = 1;
            if (s5 === n4.length)
              return "Got the end of the input";
            if (w4(n4)) {
              var h4 = s5 - s5 % I3, p4 = s5 - h4, d3 = W2(h4, F4, M2 + I3, n4.length), v4 = a3(function(n5) {
                return a3(function(n6) {
                  return U2(n6.toString(16), 2, "0");
                }, n5);
              }, function(n5, t5) {
                var r5 = n5.length, e5 = [], u5 = 0;
                if (r5 <= t5)
                  return [n5.slice()];
                for (var o4 = 0; o4 < r5; o4++)
                  e5[u5] || e5.push([]), e5[u5].push(n5[o4]), (o4 + 1) % t5 == 0 && u5++;
                return e5;
              }(n4.slice(d3.from, d3.to).toJSON().data, I3));
              o3 = function(n5) {
                return 0 === n5.from && 1 === n5.to ? { from: n5.from, to: n5.to } : { from: n5.from / I3, to: Math.floor(n5.to / I3) };
              }(d3), e4 = h4 / I3, r4 = 3 * p4, p4 >= 4 && (r4 += 1), l5 = 2, u4 = a3(function(n5) {
                return n5.length <= 4 ? n5.join(" ") : n5.slice(0, 4).join(" ") + "  " + n5.slice(4).join(" ");
              }, v4), (f4 = (8 * (o3.to > 0 ? o3.to - 1 : o3.to)).toString(16).length) < 2 && (f4 = 2);
            } else {
              var g5 = n4.split(/\r\n|[\n\r\u2028\u2029]/);
              r4 = c4.column - 1, e4 = c4.line - 1, o3 = W2(e4, q3, A3, g5.length), u4 = g5.slice(o3.from, o3.to), f4 = o3.to.toString().length;
            }
            var m4 = e4 - o3.from;
            return w4(n4) && (f4 = (8 * (o3.to > 0 ? o3.to - 1 : o3.to)).toString(16).length) < 2 && (f4 = 2), i3(function(t5, e5, u5) {
              var i4, a4 = u5 === m4, c5 = a4 ? "> " : z3;
              return i4 = w4(n4) ? U2((8 * (o3.from + u5)).toString(16), f4, "0") : U2((o3.from + u5 + 1).toString(), f4, " "), [].concat(t5, [c5 + i4 + " | " + e5], a4 ? [z3 + R(" ", f4) + " | " + U2("", r4, " ") + R("^", l5)] : []);
            }, [], u4).join("\n");
          }
          function N3(n4, t4) {
            return ["\n", "-- PARSING FAILED " + R("-", 50), "\n\n", D3(n4, t4), "\n\n", (r4 = t4.expected, 1 === r4.length ? "Expected:\n\n" + r4[0] : "Expected one of the following: \n\n" + r4.join(", ")), "\n"].join("");
            var r4;
          }
          function G3(n4) {
            return void 0 !== n4.flags ? n4.flags : [n4.global ? "g" : "", n4.ignoreCase ? "i" : "", n4.multiline ? "m" : "", n4.unicode ? "u" : "", n4.sticky ? "y" : ""].join("");
          }
          function C3() {
            for (var n4 = [].slice.call(arguments), t4 = n4.length, r4 = 0; r4 < t4; r4 += 1)
              _3(n4[r4]);
            return e3(function(r5, e4) {
              for (var u4, o3 = new Array(t4), i4 = 0; i4 < t4; i4 += 1) {
                if (!(u4 = B3(n4[i4]._(r5, e4), u4)).status)
                  return u4;
                o3[i4] = u4.value, e4 = u4.index;
              }
              return B3(b3(e4, o3), u4);
            });
          }
          function J2() {
            var n4 = [].slice.call(arguments);
            if (0 === n4.length)
              throw new Error("seqMap needs at least one argument");
            var t4 = n4.pop();
            return k3(t4), C3.apply(null, n4).map(function(n5) {
              return t4.apply(null, n5);
            });
          }
          function T4() {
            var n4 = [].slice.call(arguments), t4 = n4.length;
            if (0 === t4)
              return Y("zero alternates");
            for (var r4 = 0; r4 < t4; r4 += 1)
              _3(n4[r4]);
            return e3(function(t5, r5) {
              for (var e4, u4 = 0; u4 < n4.length; u4 += 1)
                if ((e4 = B3(n4[u4]._(t5, r5), e4)).status)
                  return e4;
              return e4;
            });
          }
          function V3(n4, t4) {
            return H3(n4, t4).or(X2([]));
          }
          function H3(n4, t4) {
            return _3(n4), _3(t4), J2(n4, t4.then(n4).many(), function(n5, t5) {
              return [n5].concat(t5);
            });
          }
          function K2(n4) {
            P3(n4);
            var t4 = "'" + n4 + "'";
            return e3(function(r4, e4) {
              var u4 = e4 + n4.length, o3 = r4.slice(e4, u4);
              return o3 === n4 ? b3(u4, o3) : x4(e4, t4);
            });
          }
          function Q2(n4, t4) {
            !function(n5) {
              if (!(n5 instanceof RegExp))
                throw new Error("not a regexp: " + n5);
              for (var t5 = G3(n5), r5 = 0; r5 < t5.length; r5++) {
                var e4 = t5.charAt(r5);
                if ("i" !== e4 && "m" !== e4 && "u" !== e4 && "s" !== e4)
                  throw new Error('unsupported regexp flag "' + e4 + '": ' + n5);
              }
            }(n4), arguments.length >= 2 ? O2(t4) : t4 = 0;
            var r4 = function(n5) {
              return RegExp("^(?:" + n5.source + ")", G3(n5));
            }(n4), u4 = "" + n4;
            return e3(function(n5, e4) {
              var o3 = r4.exec(n5.slice(e4));
              if (o3) {
                if (0 <= t4 && t4 <= o3.length) {
                  var i4 = o3[0], a4 = o3[t4];
                  return b3(e4 + i4.length, a4);
                }
                return x4(e4, "valid match group (0 to " + o3.length + ") in " + u4);
              }
              return x4(e4, u4);
            });
          }
          function X2(n4) {
            return e3(function(t4, r4) {
              return b3(r4, n4);
            });
          }
          function Y(n4) {
            return e3(function(t4, r4) {
              return x4(r4, n4);
            });
          }
          function Z2(n4) {
            if (y3(n4))
              return e3(function(t4, r4) {
                var e4 = n4._(t4, r4);
                return e4.index = r4, e4.value = "", e4;
              });
            if ("string" == typeof n4)
              return Z2(K2(n4));
            if (n4 instanceof RegExp)
              return Z2(Q2(n4));
            throw new Error("not a string, regexp, or parser: " + n4);
          }
          function $3(n4) {
            return _3(n4), e3(function(t4, r4) {
              var e4 = n4._(t4, r4), u4 = t4.slice(r4, e4.index);
              return e4.status ? x4(r4, 'not "' + u4 + '"') : b3(r4, null);
            });
          }
          function nn2(n4) {
            return k3(n4), e3(function(t4, r4) {
              var e4 = L3(t4, r4);
              return r4 < t4.length && n4(e4) ? b3(r4 + 1, e4) : x4(r4, "a character/byte matching " + n4);
            });
          }
          function tn2(n4, t4) {
            arguments.length < 2 && (t4 = n4, n4 = void 0);
            var r4 = e3(function(n5, e4) {
              return r4._ = t4()._, r4._(n5, e4);
            });
            return n4 ? r4.desc(n4) : r4;
          }
          function rn() {
            return Y("fantasy-land/empty");
          }
          u3.parse = function(n4) {
            if ("string" != typeof n4 && !w4(n4))
              throw new Error(".parse must be called with a string or Buffer as its argument");
            var t4, r4 = this.skip(an)._(n4, 0);
            return t4 = r4.status ? { status: true, value: r4.value } : { status: false, index: S2(n4, r4.furthest), expected: r4.expected }, delete j4[n4], t4;
          }, u3.tryParse = function(n4) {
            var t4 = this.parse(n4);
            if (t4.status)
              return t4.value;
            var r4 = N3(n4, t4), e4 = new Error(r4);
            throw e4.type = "ParsimmonError", e4.result = t4, e4;
          }, u3.assert = function(n4, t4) {
            return this.chain(function(r4) {
              return n4(r4) ? X2(r4) : Y(t4);
            });
          }, u3.or = function(n4) {
            return T4(this, n4);
          }, u3.trim = function(n4) {
            return this.wrap(n4, n4);
          }, u3.wrap = function(n4, t4) {
            return J2(n4, this, t4, function(n5, t5) {
              return t5;
            });
          }, u3.thru = function(n4) {
            return n4(this);
          }, u3.then = function(n4) {
            return _3(n4), C3(this, n4).map(function(n5) {
              return n5[1];
            });
          }, u3.many = function() {
            var n4 = this;
            return e3(function(t4, r4) {
              for (var e4 = [], u4 = void 0; ; ) {
                if (!(u4 = B3(n4._(t4, r4), u4)).status)
                  return B3(b3(r4, e4), u4);
                if (r4 === u4.index)
                  throw new Error("infinite loop detected in .many() parser --- calling .many() on a parser which can accept zero characters is usually the cause");
                r4 = u4.index, e4.push(u4.value);
              }
            });
          }, u3.tieWith = function(n4) {
            return P3(n4), this.map(function(t4) {
              if (function(n5) {
                if (!E2(n5))
                  throw new Error("not an array: " + n5);
              }(t4), t4.length) {
                P3(t4[0]);
                for (var r4 = t4[0], e4 = 1; e4 < t4.length; e4++)
                  P3(t4[e4]), r4 += n4 + t4[e4];
                return r4;
              }
              return "";
            });
          }, u3.tie = function() {
            return this.tieWith("");
          }, u3.times = function(n4, t4) {
            var r4 = this;
            return arguments.length < 2 && (t4 = n4), O2(n4), O2(t4), e3(function(e4, u4) {
              for (var o3 = [], i4 = void 0, a4 = void 0, f4 = 0; f4 < n4; f4 += 1) {
                if (a4 = B3(i4 = r4._(e4, u4), a4), !i4.status)
                  return a4;
                u4 = i4.index, o3.push(i4.value);
              }
              for (; f4 < t4 && (a4 = B3(i4 = r4._(e4, u4), a4), i4.status); f4 += 1)
                u4 = i4.index, o3.push(i4.value);
              return B3(b3(u4, o3), a4);
            });
          }, u3.result = function(n4) {
            return this.map(function() {
              return n4;
            });
          }, u3.atMost = function(n4) {
            return this.times(0, n4);
          }, u3.atLeast = function(n4) {
            return J2(this.times(n4), this.many(), function(n5, t4) {
              return n5.concat(t4);
            });
          }, u3.map = function(n4) {
            k3(n4);
            var t4 = this;
            return e3(function(r4, e4) {
              var u4 = t4._(r4, e4);
              return u4.status ? B3(b3(u4.index, n4(u4.value)), u4) : u4;
            });
          }, u3.contramap = function(n4) {
            k3(n4);
            var t4 = this;
            return e3(function(r4, e4) {
              var u4 = t4.parse(n4(r4.slice(e4)));
              return u4.status ? b3(e4 + r4.length, u4.value) : u4;
            });
          }, u3.promap = function(n4, t4) {
            return k3(n4), k3(t4), this.contramap(n4).map(t4);
          }, u3.skip = function(n4) {
            return C3(this, n4).map(function(n5) {
              return n5[0];
            });
          }, u3.mark = function() {
            return J2(en2, this, en2, function(n4, t4, r4) {
              return { start: n4, value: t4, end: r4 };
            });
          }, u3.node = function(n4) {
            return J2(en2, this, en2, function(t4, r4, e4) {
              return { name: n4, value: r4, start: t4, end: e4 };
            });
          }, u3.sepBy = function(n4) {
            return V3(this, n4);
          }, u3.sepBy1 = function(n4) {
            return H3(this, n4);
          }, u3.lookahead = function(n4) {
            return this.skip(Z2(n4));
          }, u3.notFollowedBy = function(n4) {
            return this.skip($3(n4));
          }, u3.desc = function(n4) {
            E2(n4) || (n4 = [n4]);
            var t4 = this;
            return e3(function(r4, e4) {
              var u4 = t4._(r4, e4);
              return u4.status || (u4.expected = n4), u4;
            });
          }, u3.fallback = function(n4) {
            return this.or(X2(n4));
          }, u3.ap = function(n4) {
            return J2(n4, this, function(n5, t4) {
              return n5(t4);
            });
          }, u3.chain = function(n4) {
            var t4 = this;
            return e3(function(r4, e4) {
              var u4 = t4._(r4, e4);
              return u4.status ? B3(n4(u4.value)._(r4, u4.index), u4) : u4;
            });
          }, u3.concat = u3.or, u3.empty = rn, u3.of = X2, u3["fantasy-land/ap"] = u3.ap, u3["fantasy-land/chain"] = u3.chain, u3["fantasy-land/concat"] = u3.concat, u3["fantasy-land/empty"] = u3.empty, u3["fantasy-land/of"] = u3.of, u3["fantasy-land/map"] = u3.map;
          var en2 = e3(function(n4, t4) {
            return b3(t4, S2(n4, t4));
          }), un = e3(function(n4, t4) {
            return t4 >= n4.length ? x4(t4, "any character/byte") : b3(t4 + 1, L3(n4, t4));
          }), on = e3(function(n4, t4) {
            return b3(n4.length, n4.slice(t4));
          }), an = e3(function(n4, t4) {
            return t4 < n4.length ? x4(t4, "EOF") : b3(t4, null);
          }), fn = Q2(/[0-9]/).desc("a digit"), cn = Q2(/[0-9]*/).desc("optional digits"), sn = Q2(/[a-z]/i).desc("a letter"), ln = Q2(/[a-z]*/i).desc("optional letters"), hn = Q2(/\s*/).desc("optional whitespace"), pn = Q2(/\s+/).desc("whitespace"), dn = K2("\r"), vn = K2("\n"), gn = K2("\r\n"), mn = T4(gn, vn, dn).desc("newline"), yn = T4(mn, an);
          e3.all = on, e3.alt = T4, e3.any = un, e3.cr = dn, e3.createLanguage = function(n4) {
            var t4 = {};
            for (var r4 in n4)
              ({}).hasOwnProperty.call(n4, r4) && function(r5) {
                t4[r5] = tn2(function() {
                  return n4[r5](t4);
                });
              }(r4);
            return t4;
          }, e3.crlf = gn, e3.custom = function(n4) {
            return e3(n4(b3, x4));
          }, e3.digit = fn, e3.digits = cn, e3.empty = rn, e3.end = yn, e3.eof = an, e3.fail = Y, e3.formatError = N3, e3.index = en2, e3.isParser = y3, e3.lazy = tn2, e3.letter = sn, e3.letters = ln, e3.lf = vn, e3.lookahead = Z2, e3.makeFailure = x4, e3.makeSuccess = b3, e3.newline = mn, e3.noneOf = function(n4) {
            return nn2(function(t4) {
              return n4.indexOf(t4) < 0;
            }).desc("none of '" + n4 + "'");
          }, e3.notFollowedBy = $3, e3.of = X2, e3.oneOf = function(n4) {
            for (var t4 = n4.split(""), r4 = 0; r4 < t4.length; r4++)
              t4[r4] = "'" + t4[r4] + "'";
            return nn2(function(t5) {
              return n4.indexOf(t5) >= 0;
            }).desc(t4);
          }, e3.optWhitespace = hn, e3.Parser = e3, e3.range = function(n4, t4) {
            return nn2(function(r4) {
              return n4 <= r4 && r4 <= t4;
            }).desc(n4 + "-" + t4);
          }, e3.regex = Q2, e3.regexp = Q2, e3.sepBy = V3, e3.sepBy1 = H3, e3.seq = C3, e3.seqMap = J2, e3.seqObj = function() {
            for (var n4, t4 = {}, r4 = 0, u4 = (n4 = arguments, Array.prototype.slice.call(n4)), o3 = u4.length, i4 = 0; i4 < o3; i4 += 1) {
              var a4 = u4[i4];
              if (!y3(a4)) {
                if (E2(a4) && 2 === a4.length && "string" == typeof a4[0] && y3(a4[1])) {
                  var f4 = a4[0];
                  if (Object.prototype.hasOwnProperty.call(t4, f4))
                    throw new Error("seqObj: duplicate key " + f4);
                  t4[f4] = true, r4++;
                  continue;
                }
                throw new Error("seqObj arguments must be parsers or [string, parser] array pairs.");
              }
            }
            if (0 === r4)
              throw new Error("seqObj expects at least one named parser, found zero");
            return e3(function(n5, t5) {
              for (var r5, e4 = {}, i5 = 0; i5 < o3; i5 += 1) {
                var a5, f5;
                if (E2(u4[i5]) ? (a5 = u4[i5][0], f5 = u4[i5][1]) : (a5 = null, f5 = u4[i5]), !(r5 = B3(f5._(n5, t5), r5)).status)
                  return r5;
                a5 && (e4[a5] = r5.value), t5 = r5.index;
              }
              return B3(b3(t5, e4), r5);
            });
          }, e3.string = K2, e3.succeed = X2, e3.takeWhile = function(n4) {
            return k3(n4), e3(function(t4, r4) {
              for (var e4 = r4; e4 < t4.length && n4(L3(t4, e4)); )
                e4++;
              return b3(e4, t4.slice(r4, e4));
            });
          }, e3.test = nn2, e3.whitespace = pn, e3["fantasy-land/empty"] = rn, e3["fantasy-land/of"] = X2, e3.Binary = { bitSeq: l4, bitSeqObj: function(n4) {
            s4();
            var t4 = {}, r4 = 0, e4 = a3(function(n5) {
              if (E2(n5)) {
                var e5 = n5;
                if (2 !== e5.length)
                  throw new Error("[" + e5.join(", ") + "] should be length 2, got length " + e5.length);
                if (P3(e5[0]), O2(e5[1]), Object.prototype.hasOwnProperty.call(t4, e5[0]))
                  throw new Error("duplicate key in bitSeqObj: " + e5[0]);
                return t4[e5[0]] = true, r4++, e5;
              }
              return O2(n5), [null, n5];
            }, n4);
            if (r4 < 1)
              throw new Error("bitSeqObj expects at least one named pair, got [" + n4.join(", ") + "]");
            var u4 = a3(function(n5) {
              return n5[0];
            }, e4);
            return l4(a3(function(n5) {
              return n5[1];
            }, e4)).map(function(n5) {
              return i3(function(n6, t5) {
                return null !== t5[0] && (n6[t5[0]] = t5[1]), n6;
              }, {}, a3(function(t5, r5) {
                return [t5, n5[r5]];
              }, u4));
            });
          }, byte: function(n4) {
            if (s4(), O2(n4), n4 > 255)
              throw new Error("Value specified to byte constructor (" + n4 + "=0x" + n4.toString(16) + ") is larger in value than a single byte.");
            var t4 = (n4 > 15 ? "0x" : "0x0") + n4.toString(16);
            return e3(function(r4, e4) {
              var u4 = L3(r4, e4);
              return u4 === n4 ? b3(e4 + 1, u4) : x4(e4, t4);
            });
          }, buffer: function(n4) {
            return h3("buffer", n4).map(function(n5) {
              return Buffer.from(n5);
            });
          }, encodedString: function(n4, t4) {
            return h3("string", t4).map(function(t5) {
              return t5.toString(n4);
            });
          }, uintBE: d2, uint8BE: d2(1), uint16BE: d2(2), uint32BE: d2(4), uintLE: v3, uint8LE: v3(1), uint16LE: v3(2), uint32LE: v3(4), intBE: g4, int8BE: g4(1), int16BE: g4(2), int32BE: g4(4), intLE: m3, int8LE: m3(1), int16LE: m3(2), int32LE: m3(4), floatBE: h3("floatBE", 4).map(function(n4) {
            return n4.readFloatBE(0);
          }), floatLE: h3("floatLE", 4).map(function(n4) {
            return n4.readFloatLE(0);
          }), doubleBE: h3("doubleBE", 8).map(function(n4) {
            return n4.readDoubleBE(0);
          }), doubleLE: h3("doubleLE", 8).map(function(n4) {
            return n4.readDoubleLE(0);
          }) }, n3.exports = e3;
        }]);
      });
    })(parsimmon_umd_min, parsimmon_umd_min.exports);
    var parsimmon_umd_minExports = parsimmon_umd_min.exports;
    var emojiRegex = () => {
      return /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC3\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC08\uDC26](?:\u200D\u2B1B)?|[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
    };
    function normalizeDuration(dur) {
      if (dur === void 0 || dur === null)
        return dur;
      return dur.shiftToAll().normalize();
    }
    function getFileTitle(path) {
      if (path.includes("/"))
        path = path.substring(path.lastIndexOf("/") + 1);
      if (path.endsWith(".md"))
        path = path.substring(0, path.length - 3);
      return path;
    }
    parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regex(new RegExp(emojiRegex(), "")), parsimmon_umd_minExports.regex(/[0-9\p{Letter}_-]+/u).map((str) => str.toLocaleLowerCase()), parsimmon_umd_minExports.whitespace.map((_3) => "-"), parsimmon_umd_minExports.any.map((_3) => "")).many().map((result) => result.join(""));
    var HEADER_CANONICALIZER = parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regex(new RegExp(emojiRegex(), "")), parsimmon_umd_minExports.regex(/[0-9\p{Letter}_-]+/u), parsimmon_umd_minExports.whitespace.map((_3) => " "), parsimmon_umd_minExports.any.map((_3) => " ")).many().map((result) => {
      return result.join("").split(/\s+/).join(" ").trim();
    });
    function normalizeHeaderForLink(header) {
      return HEADER_CANONICALIZER.tryParse(header);
    }
    function renderMinimalDuration(dur) {
      dur = normalizeDuration(dur);
      dur = Duration.fromObject(Object.fromEntries(Object.entries(dur.toObject()).filter(([, quantity]) => quantity != 0)));
      return dur.toHuman();
    }
    var Values;
    (function(Values2) {
      function toString(field, setting = DEFAULT_QUERY_SETTINGS, recursive = false) {
        let wrapped = wrapValue(field);
        if (!wrapped)
          return setting.renderNullAs;
        switch (wrapped.type) {
          case "null":
            return setting.renderNullAs;
          case "string":
            return wrapped.value;
          case "number":
          case "boolean":
            return "" + wrapped.value;
          case "html":
            return wrapped.value.outerHTML;
          case "widget":
            return wrapped.value.markdown();
          case "link":
            return wrapped.value.markdown();
          case "function":
            return "<function>";
          case "array":
            let result = "";
            if (recursive)
              result += "[";
            result += wrapped.value.map((f3) => toString(f3, setting, true)).join(", ");
            if (recursive)
              result += "]";
            return result;
          case "object":
            return "{ " + Object.entries(wrapped.value).map((e3) => e3[0] + ": " + toString(e3[1], setting, true)).join(", ") + " }";
          case "date":
            if (wrapped.value.second == 0 && wrapped.value.hour == 0 && wrapped.value.minute == 0) {
              return wrapped.value.toFormat(setting.defaultDateFormat);
            }
            return wrapped.value.toFormat(setting.defaultDateTimeFormat);
          case "duration":
            return renderMinimalDuration(wrapped.value);
        }
      }
      Values2.toString = toString;
      function wrapValue(val) {
        if (isNull(val))
          return { type: "null", value: val };
        else if (isNumber3(val))
          return { type: "number", value: val };
        else if (isString2(val))
          return { type: "string", value: val };
        else if (isBoolean(val))
          return { type: "boolean", value: val };
        else if (isDuration(val))
          return { type: "duration", value: val };
        else if (isDate3(val))
          return { type: "date", value: val };
        else if (isWidget(val))
          return { type: "widget", value: val };
        else if (isArray2(val))
          return { type: "array", value: val };
        else if (isLink(val))
          return { type: "link", value: val };
        else if (isFunction(val))
          return { type: "function", value: val };
        else if (isHtml(val))
          return { type: "html", value: val };
        else if (isObject2(val))
          return { type: "object", value: val };
        else
          return void 0;
      }
      Values2.wrapValue = wrapValue;
      function mapLeaves(val, func) {
        if (isObject2(val)) {
          let result = {};
          for (let [key, value] of Object.entries(val))
            result[key] = mapLeaves(value, func);
          return result;
        } else if (isArray2(val)) {
          let result = [];
          for (let value of val)
            result.push(mapLeaves(value, func));
          return result;
        } else {
          return func(val);
        }
      }
      Values2.mapLeaves = mapLeaves;
      function compareValue(val1, val2, linkNormalizer) {
        var _a, _b;
        if (val1 === void 0)
          val1 = null;
        if (val2 === void 0)
          val2 = null;
        if (val1 === null && val2 === null)
          return 0;
        else if (val1 === null)
          return -1;
        else if (val2 === null)
          return 1;
        let wrap1 = wrapValue(val1);
        let wrap2 = wrapValue(val2);
        if (wrap1 === void 0 && wrap2 === void 0)
          return 0;
        else if (wrap1 === void 0)
          return -1;
        else if (wrap2 === void 0)
          return 1;
        if (wrap1.type != wrap2.type)
          return wrap1.type.localeCompare(wrap2.type);
        if (wrap1.value === wrap2.value)
          return 0;
        switch (wrap1.type) {
          case "string":
            return wrap1.value.localeCompare(wrap2.value);
          case "number":
            if (wrap1.value < wrap2.value)
              return -1;
            else if (wrap1.value == wrap2.value)
              return 0;
            return 1;
          case "null":
            return 0;
          case "boolean":
            if (wrap1.value == wrap2.value)
              return 0;
            else
              return wrap1.value ? 1 : -1;
          case "link":
            let link1 = wrap1.value;
            let link2 = wrap2.value;
            let normalize = linkNormalizer != null ? linkNormalizer : (x4) => x4;
            let pathCompare = normalize(link1.path).localeCompare(normalize(link2.path));
            if (pathCompare != 0)
              return pathCompare;
            let typeCompare = link1.type.localeCompare(link2.type);
            if (typeCompare != 0)
              return typeCompare;
            if (link1.subpath && !link2.subpath)
              return 1;
            if (!link1.subpath && link2.subpath)
              return -1;
            if (!link1.subpath && !link2.subpath)
              return 0;
            return ((_a = link1.subpath) != null ? _a : "").localeCompare((_b = link2.subpath) != null ? _b : "");
          case "date":
            return wrap1.value < wrap2.value ? -1 : wrap1.value.equals(wrap2.value) ? 0 : 1;
          case "duration":
            return wrap1.value < wrap2.value ? -1 : wrap1.value.equals(wrap2.value) ? 0 : 1;
          case "array":
            let f1 = wrap1.value;
            let f22 = wrap2.value;
            for (let index8 = 0; index8 < Math.min(f1.length, f22.length); index8++) {
              let comp = compareValue(f1[index8], f22[index8]);
              if (comp != 0)
                return comp;
            }
            return f1.length - f22.length;
          case "object":
            let o1 = wrap1.value;
            let o2 = wrap2.value;
            let k1 = Array.from(Object.keys(o1));
            let k22 = Array.from(Object.keys(o2));
            k1.sort();
            k22.sort();
            let keyCompare = compareValue(k1, k22);
            if (keyCompare != 0)
              return keyCompare;
            for (let key of k1) {
              let comp = compareValue(o1[key], o2[key]);
              if (comp != 0)
                return comp;
            }
            return 0;
          case "widget":
          case "html":
          case "function":
            return 0;
        }
      }
      Values2.compareValue = compareValue;
      function typeOf(val) {
        var _a;
        return (_a = wrapValue(val)) == null ? void 0 : _a.type;
      }
      Values2.typeOf = typeOf;
      function isTruthy2(field) {
        let wrapped = wrapValue(field);
        if (!wrapped)
          return false;
        switch (wrapped.type) {
          case "number":
            return wrapped.value != 0;
          case "string":
            return wrapped.value.length > 0;
          case "boolean":
            return wrapped.value;
          case "link":
            return !!wrapped.value.path;
          case "date":
            return wrapped.value.toMillis() != 0;
          case "duration":
            return wrapped.value.as("seconds") != 0;
          case "object":
            return Object.keys(wrapped.value).length > 0;
          case "array":
            return wrapped.value.length > 0;
          case "null":
            return false;
          case "html":
          case "widget":
          case "function":
            return true;
        }
      }
      Values2.isTruthy = isTruthy2;
      function deepCopy(field) {
        if (field === null || field === void 0)
          return field;
        if (Values2.isArray(field)) {
          return [].concat(field.map((v3) => deepCopy(v3)));
        } else if (Values2.isObject(field)) {
          let result = {};
          for (let [key, value] of Object.entries(field))
            result[key] = deepCopy(value);
          return result;
        } else {
          return field;
        }
      }
      Values2.deepCopy = deepCopy;
      function isString2(val) {
        return typeof val == "string";
      }
      Values2.isString = isString2;
      function isNumber3(val) {
        return typeof val == "number";
      }
      Values2.isNumber = isNumber3;
      function isDate3(val) {
        return val instanceof DateTime2;
      }
      Values2.isDate = isDate3;
      function isDuration(val) {
        return val instanceof Duration;
      }
      Values2.isDuration = isDuration;
      function isNull(val) {
        return val === null || val === void 0;
      }
      Values2.isNull = isNull;
      function isArray2(val) {
        return Array.isArray(val);
      }
      Values2.isArray = isArray2;
      function isBoolean(val) {
        return typeof val === "boolean";
      }
      Values2.isBoolean = isBoolean;
      function isLink(val) {
        return val instanceof Link;
      }
      Values2.isLink = isLink;
      function isWidget(val) {
        return val instanceof Widget;
      }
      Values2.isWidget = isWidget;
      function isHtml(val) {
        if (typeof HTMLElement !== "undefined") {
          return val instanceof HTMLElement;
        } else {
          return false;
        }
      }
      Values2.isHtml = isHtml;
      function isObject2(val) {
        return typeof val == "object" && !isHtml(val) && !isWidget(val) && !isArray2(val) && !isDuration(val) && !isDate3(val) && !isLink(val) && val !== void 0 && !isNull(val);
      }
      Values2.isObject = isObject2;
      function isFunction(val) {
        return typeof val == "function";
      }
      Values2.isFunction = isFunction;
    })(Values || (Values = {}));
    var Groupings;
    (function(Groupings2) {
      function isElementGroup(entry) {
        return Values.isObject(entry) && Object.keys(entry).length == 2 && "key" in entry && "rows" in entry;
      }
      Groupings2.isElementGroup = isElementGroup;
      function isGrouping(entry) {
        for (let element of entry)
          if (!isElementGroup(element))
            return false;
        return true;
      }
      Groupings2.isGrouping = isGrouping;
      function count(elements) {
        if (isGrouping(elements)) {
          let result = 0;
          for (let subgroup of elements)
            result += count(subgroup.rows);
          return result;
        } else {
          return elements.length;
        }
      }
      Groupings2.count = count;
    })(Groupings || (Groupings = {}));
    var Link = class {
      constructor(fields) {
        /** The file path this link points to. */
        __publicField(this, "path");
        /** The display name associated with the link. */
        __publicField(this, "display");
        /** The block ID or header this link points to within a file, if relevant. */
        __publicField(this, "subpath");
        /** Is this link an embedded link (!)? */
        __publicField(this, "embed");
        /** The type of this link, which determines what 'subpath' refers to, if anything. */
        __publicField(this, "type");
        Object.assign(this, fields);
      }
      /** Create a link to a specific file. */
      static file(path, embed = false, display2) {
        return new Link({
          path,
          embed,
          display: display2,
          subpath: void 0,
          type: "file"
        });
      }
      static infer(linkpath, embed = false, display2) {
        if (linkpath.includes("#^")) {
          let split2 = linkpath.split("#^");
          return Link.block(split2[0], split2[1], embed, display2);
        } else if (linkpath.includes("#")) {
          let split2 = linkpath.split("#");
          return Link.header(split2[0], split2[1], embed, display2);
        } else
          return Link.file(linkpath, embed, display2);
      }
      /** Create a link to a specific file and header in that file. */
      static header(path, header, embed, display2) {
        return new Link({
          path,
          embed,
          display: display2,
          subpath: normalizeHeaderForLink(header),
          type: "header"
        });
      }
      /** Create a link to a specific file and block in that file. */
      static block(path, blockId, embed, display2) {
        return new Link({
          path,
          embed,
          display: display2,
          subpath: blockId,
          type: "block"
        });
      }
      static fromObject(object) {
        return new Link(object);
      }
      /** Checks for link equality (i.e., that the links are pointing to the same exact location). */
      equals(other) {
        if (other == void 0 || other == null)
          return false;
        return this.path == other.path && this.type == other.type && this.subpath == other.subpath;
      }
      /** Convert this link to it's markdown representation. */
      toString() {
        return this.markdown();
      }
      /** Convert this link to a raw object which is serialization-friendly. */
      toObject() {
        return { path: this.path, type: this.type, subpath: this.subpath, display: this.display, embed: this.embed };
      }
      /** Update this link with a new path. */
      //@ts-ignore; error appeared after updating Obsidian to 0.15.4; it also updated other packages but didn't say which
      withPath(path) {
        return new Link(Object.assign({}, this, { path }));
      }
      /** Return a new link which points to the same location but with a new display value. */
      withDisplay(display2) {
        return new Link(Object.assign({}, this, { display: display2 }));
      }
      /** Convert a file link into a link to a specific header. */
      withHeader(header) {
        return Link.header(this.path, header, this.embed, this.display);
      }
      /** Convert any link into a link to its file. */
      toFile() {
        return Link.file(this.path, this.embed, this.display);
      }
      /** Convert this link into an embedded link. */
      toEmbed() {
        if (this.embed) {
          return this;
        } else {
          let link = new Link(this);
          link.embed = true;
          return link;
        }
      }
      /** Convert this link into a non-embedded link. */
      fromEmbed() {
        if (!this.embed) {
          return this;
        } else {
          let link = new Link(this);
          link.embed = false;
          return link;
        }
      }
      /** Convert this link to markdown so it can be rendered. */
      markdown() {
        let result = (this.embed ? "!" : "") + "[[" + this.obsidianLink();
        if (this.display) {
          result += "|" + this.display;
        } else {
          result += "|" + getFileTitle(this.path);
          if (this.type == "header" || this.type == "block")
            result += " > " + this.subpath;
        }
        result += "]]";
        return result;
      }
      /** Convert the inner part of the link to something that Obsidian can open / understand. */
      obsidianLink() {
        var _a, _b;
        const escaped = this.path.replaceAll("|", "\\|");
        if (this.type == "header")
          return escaped + "#" + ((_a = this.subpath) == null ? void 0 : _a.replaceAll("|", "\\|"));
        if (this.type == "block")
          return escaped + "#^" + ((_b = this.subpath) == null ? void 0 : _b.replaceAll("|", "\\|"));
        else
          return escaped;
      }
      /** The stripped name of the file this link points to. */
      fileName() {
        return getFileTitle(this.path).replace(".md", "");
      }
    };
    var Widget = class {
      constructor($widget) {
        __publicField(this, "$widget");
        this.$widget = $widget;
      }
    };
    var ListPairWidget = class extends Widget {
      constructor(key, value) {
        super("dataview:list-pair");
        __publicField(this, "key");
        __publicField(this, "value");
        this.key = key;
        this.value = value;
      }
      markdown() {
        return `${Values.toString(this.key)}: ${Values.toString(this.value)}`;
      }
    };
    var ExternalLinkWidget = class extends Widget {
      constructor(url, display2) {
        super("dataview:external-link");
        __publicField(this, "url");
        __publicField(this, "display");
        this.url = url;
        this.display = display2;
      }
      markdown() {
        var _a;
        return `[${(_a = this.display) != null ? _a : this.url}](${this.url})`;
      }
    };
    var Widgets;
    (function(Widgets2) {
      function listPair(key, value) {
        return new ListPairWidget(key, value);
      }
      Widgets2.listPair = listPair;
      function externalLink(url, display2) {
        return new ExternalLinkWidget(url, display2);
      }
      Widgets2.externalLink = externalLink;
      function isListPair(widget) {
        return widget.$widget === "dataview:list-pair";
      }
      Widgets2.isListPair = isListPair;
      function isExternalLink(widget) {
        return widget.$widget === "dataview:external-link";
      }
      Widgets2.isExternalLink = isExternalLink;
      function isBuiltin(widget) {
        return isListPair(widget) || isExternalLink(widget);
      }
      Widgets2.isBuiltin = isBuiltin;
    })(Widgets || (Widgets = {}));
    var Fields;
    (function(Fields2) {
      function variable(name) {
        return { type: "variable", name };
      }
      Fields2.variable = variable;
      function literal(value) {
        return { type: "literal", value };
      }
      Fields2.literal = literal;
      function binaryOp(left, op, right) {
        return { type: "binaryop", left, op, right };
      }
      Fields2.binaryOp = binaryOp;
      function index8(obj, index9) {
        return { type: "index", object: obj, index: index9 };
      }
      Fields2.index = index8;
      function indexVariable(name) {
        let parts = name.split(".");
        let result = Fields2.variable(parts[0]);
        for (let index9 = 1; index9 < parts.length; index9++) {
          result = Fields2.index(result, Fields2.literal(parts[index9]));
        }
        return result;
      }
      Fields2.indexVariable = indexVariable;
      function lambda(args, value) {
        return { type: "lambda", arguments: args, value };
      }
      Fields2.lambda = lambda;
      function func(func2, args) {
        return { type: "function", func: func2, arguments: args };
      }
      Fields2.func = func;
      function list(values) {
        return { type: "list", values };
      }
      Fields2.list = list;
      function object(values) {
        return { type: "object", values };
      }
      Fields2.object = object;
      function negate(child) {
        return { type: "negated", child };
      }
      Fields2.negate = negate;
      function isCompareOp(op) {
        return op == "<=" || op == "<" || op == ">" || op == ">=" || op == "!=" || op == "=";
      }
      Fields2.isCompareOp = isCompareOp;
      Fields2.NULL = Fields2.literal(null);
    })(Fields || (Fields = {}));
    var Sources;
    (function(Sources2) {
      function tag(tag2) {
        return { type: "tag", tag: tag2 };
      }
      Sources2.tag = tag;
      function csv(path) {
        return { type: "csv", path };
      }
      Sources2.csv = csv;
      function folder(prefix) {
        return { type: "folder", folder: prefix };
      }
      Sources2.folder = folder;
      function link(file, incoming) {
        return { type: "link", file, direction: incoming ? "incoming" : "outgoing" };
      }
      Sources2.link = link;
      function binaryOp(left, op, right) {
        return { type: "binaryop", left, op, right };
      }
      Sources2.binaryOp = binaryOp;
      function and(left, right) {
        return { type: "binaryop", left, op: "&", right };
      }
      Sources2.and = and;
      function or(left, right) {
        return { type: "binaryop", left, op: "|", right };
      }
      Sources2.or = or;
      function negate(child) {
        return { type: "negate", child };
      }
      Sources2.negate = negate;
      function empty2() {
        return { type: "empty" };
      }
      Sources2.empty = empty2;
    })(Sources || (Sources = {}));
    var EMOJI_REGEX = new RegExp(emojiRegex(), "");
    var DURATION_TYPES = {
      year: Duration.fromObject({ years: 1 }),
      years: Duration.fromObject({ years: 1 }),
      yr: Duration.fromObject({ years: 1 }),
      yrs: Duration.fromObject({ years: 1 }),
      month: Duration.fromObject({ months: 1 }),
      months: Duration.fromObject({ months: 1 }),
      mo: Duration.fromObject({ months: 1 }),
      mos: Duration.fromObject({ months: 1 }),
      week: Duration.fromObject({ weeks: 1 }),
      weeks: Duration.fromObject({ weeks: 1 }),
      wk: Duration.fromObject({ weeks: 1 }),
      wks: Duration.fromObject({ weeks: 1 }),
      w: Duration.fromObject({ weeks: 1 }),
      day: Duration.fromObject({ days: 1 }),
      days: Duration.fromObject({ days: 1 }),
      d: Duration.fromObject({ days: 1 }),
      hour: Duration.fromObject({ hours: 1 }),
      hours: Duration.fromObject({ hours: 1 }),
      hr: Duration.fromObject({ hours: 1 }),
      hrs: Duration.fromObject({ hours: 1 }),
      h: Duration.fromObject({ hours: 1 }),
      minute: Duration.fromObject({ minutes: 1 }),
      minutes: Duration.fromObject({ minutes: 1 }),
      min: Duration.fromObject({ minutes: 1 }),
      mins: Duration.fromObject({ minutes: 1 }),
      m: Duration.fromObject({ minutes: 1 }),
      second: Duration.fromObject({ seconds: 1 }),
      seconds: Duration.fromObject({ seconds: 1 }),
      sec: Duration.fromObject({ seconds: 1 }),
      secs: Duration.fromObject({ seconds: 1 }),
      s: Duration.fromObject({ seconds: 1 })
    };
    var DATE_SHORTHANDS = {
      now: () => DateTime2.local(),
      today: () => DateTime2.local().startOf("day"),
      yesterday: () => DateTime2.local().startOf("day").minus(Duration.fromObject({ days: 1 })),
      tomorrow: () => DateTime2.local().startOf("day").plus(Duration.fromObject({ days: 1 })),
      sow: () => DateTime2.local().startOf("week"),
      "start-of-week": () => DateTime2.local().startOf("week"),
      eow: () => DateTime2.local().endOf("week"),
      "end-of-week": () => DateTime2.local().endOf("week"),
      soy: () => DateTime2.local().startOf("year"),
      "start-of-year": () => DateTime2.local().startOf("year"),
      eoy: () => DateTime2.local().endOf("year"),
      "end-of-year": () => DateTime2.local().endOf("year"),
      som: () => DateTime2.local().startOf("month"),
      "start-of-month": () => DateTime2.local().startOf("month"),
      eom: () => DateTime2.local().endOf("month"),
      "end-of-month": () => DateTime2.local().endOf("month")
    };
    var KEYWORDS = ["FROM", "WHERE", "LIMIT", "GROUP", "FLATTEN"];
    function splitOnUnescapedPipe(link) {
      let pipe = -1;
      while ((pipe = link.indexOf("|", pipe + 1)) >= 0) {
        if (pipe > 0 && link[pipe - 1] == "\\")
          continue;
        return [link.substring(0, pipe).replace(/\\\|/g, "|"), link.substring(pipe + 1)];
      }
      return [link.replace(/\\\|/g, "|"), void 0];
    }
    function parseInnerLink(rawlink) {
      let [link, display2] = splitOnUnescapedPipe(rawlink);
      return Link.infer(link, false, display2);
    }
    function createBinaryParser(child, sep, combine2) {
      return parsimmon_umd_minExports.seqMap(child, parsimmon_umd_minExports.seq(parsimmon_umd_minExports.optWhitespace, sep, parsimmon_umd_minExports.optWhitespace, child).many(), (first, rest) => {
        if (rest.length == 0)
          return first;
        let node = combine2(first, rest[0][1], rest[0][3]);
        for (let index8 = 1; index8 < rest.length; index8++) {
          node = combine2(node, rest[index8][1], rest[index8][3]);
        }
        return node;
      });
    }
    function chainOpt(base, ...funcs) {
      return parsimmon_umd_minExports.custom((success, failure) => {
        return (input, i3) => {
          let result = base._(input, i3);
          if (!result.status)
            return result;
          for (let func of funcs) {
            let next = func(result.value)._(input, result.index);
            if (!next.status)
              return result;
            result = next;
          }
          return result;
        };
      });
    }
    var EXPRESSION = parsimmon_umd_minExports.createLanguage({
      // A floating point number; the decimal point is optional.
      number: (q3) => parsimmon_umd_minExports.regexp(/-?[0-9]+(\.[0-9]+)?/).map((str) => Number.parseFloat(str)).desc("number"),
      // A quote-surrounded string which supports escape characters ('\').
      string: (q3) => parsimmon_umd_minExports.string('"').then(parsimmon_umd_minExports.alt(q3.escapeCharacter, parsimmon_umd_minExports.noneOf('"\\')).atLeast(0).map((chars) => chars.join(""))).skip(parsimmon_umd_minExports.string('"')).desc("string"),
      escapeCharacter: (_3) => parsimmon_umd_minExports.string("\\").then(parsimmon_umd_minExports.any).map((escaped) => {
        if (escaped === '"')
          return '"';
        if (escaped === "\\")
          return "\\";
        else
          return "\\" + escaped;
      }),
      // A boolean true/false value.
      bool: (_3) => parsimmon_umd_minExports.regexp(/true|false|True|False/).map((str) => str.toLowerCase() == "true").desc("boolean ('true' or 'false')"),
      // A tag of the form '#stuff/hello-there'.
      tag: (_3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("#"), parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regexp(/[^\u2000-\u206F\u2E00-\u2E7F'!"#$%&()*+,.:;<=>?@^`{|}~\[\]\\\s]/).desc("text")).many(), (start, rest) => start + rest.join("")).desc("tag ('#hello/stuff')"),
      // A variable identifier, which is alphanumeric and must start with a letter or... emoji.
      identifier: (_3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regexp(/\p{Letter}/u), parsimmon_umd_minExports.regexp(EMOJI_REGEX).desc("text")), parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regexp(/[0-9\p{Letter}_-]/u), parsimmon_umd_minExports.regexp(EMOJI_REGEX).desc("text")).many(), (first, rest) => first + rest.join("")).desc("variable identifier"),
      // An Obsidian link of the form [[<link>]].
      link: (_3) => parsimmon_umd_minExports.regexp(/\[\[([^\[\]]*?)\]\]/u, 1).map((linkInner) => parseInnerLink(linkInner)).desc("file link"),
      // An embeddable link which can start with '!'. This overlaps with the normal negation operator, so it is only
      // provided for metadata parsing.
      embedLink: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("!").atMost(1), q3.link, (p3, l4) => {
        if (p3.length > 0)
          l4.embed = true;
        return l4;
      }).desc("file link"),
      // Binary plus or minus operator.
      binaryPlusMinus: (_3) => parsimmon_umd_minExports.regexp(/\+|-/).map((str) => str).desc("'+' or '-'"),
      // Binary times or divide operator.
      binaryMulDiv: (_3) => parsimmon_umd_minExports.regexp(/\*|\/|%/).map((str) => str).desc("'*' or '/' or '%'"),
      // Binary comparison operator.
      binaryCompareOp: (_3) => parsimmon_umd_minExports.regexp(/>=|<=|!=|>|<|=/).map((str) => str).desc("'>=' or '<=' or '!=' or '=' or '>' or '<'"),
      // Binary boolean combination operator.
      binaryBooleanOp: (_3) => parsimmon_umd_minExports.regexp(/and|or|&|\|/i).map((str) => {
        if (str.toLowerCase() == "and")
          return "&";
        else if (str.toLowerCase() == "or")
          return "|";
        else
          return str;
      }).desc("'and' or 'or'"),
      // A date which can be YYYY-MM[-DDTHH:mm:ss].
      rootDate: (_3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/\d{4}/), parsimmon_umd_minExports.string("-"), parsimmon_umd_minExports.regexp(/\d{2}/), (year, _4, month) => {
        return DateTime2.fromObject({ year: Number.parseInt(year), month: Number.parseInt(month) });
      }).desc("date in format YYYY-MM[-DDTHH-MM-SS.MS]"),
      dateShorthand: (_3) => parsimmon_umd_minExports.alt(...Object.keys(DATE_SHORTHANDS).sort((a3, b3) => b3.length - a3.length).map(parsimmon_umd_minExports.string)),
      date: (q3) => chainOpt(q3.rootDate, (ym) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("-"), parsimmon_umd_minExports.regexp(/\d{2}/), (_3, day) => ym.set({ day: Number.parseInt(day) })), (ymd) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("T"), parsimmon_umd_minExports.regexp(/\d{2}/), (_3, hour) => ymd.set({ hour: Number.parseInt(hour) })), (ymdh) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string(":"), parsimmon_umd_minExports.regexp(/\d{2}/), (_3, minute) => ymdh.set({ minute: Number.parseInt(minute) })), (ymdhm) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string(":"), parsimmon_umd_minExports.regexp(/\d{2}/), (_3, second) => ymdhm.set({ second: Number.parseInt(second) })), (ymdhms) => parsimmon_umd_minExports.alt(
        parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("."), parsimmon_umd_minExports.regexp(/\d{3}/), (_3, millisecond) => ymdhms.set({ millisecond: Number.parseInt(millisecond) })),
        parsimmon_umd_minExports.succeed(ymdhms)
        // pass
      ), (dt) => parsimmon_umd_minExports.alt(parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("+").or(parsimmon_umd_minExports.string("-")), parsimmon_umd_minExports.regexp(/\d{1,2}(:\d{2})?/), (pm, hr) => dt.setZone("UTC" + pm + hr, { keepLocalTime: true })), parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("Z"), () => dt.setZone("utc", { keepLocalTime: true })), parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("["), parsimmon_umd_minExports.regexp(/[0-9A-Za-z+-\/]+/u), parsimmon_umd_minExports.string("]"), (_a, zone, _b) => dt.setZone(zone, { keepLocalTime: true })))).assert((dt) => dt.isValid, "valid date").desc("date in format YYYY-MM[-DDTHH-MM-SS.MS]"),
      // A date, plus various shorthand times of day it could be.
      datePlus: (q3) => parsimmon_umd_minExports.alt(q3.dateShorthand.map((d2) => DATE_SHORTHANDS[d2]()), q3.date).desc("date in format YYYY-MM[-DDTHH-MM-SS.MS] or in shorthand"),
      // A duration of time.
      durationType: (_3) => parsimmon_umd_minExports.alt(...Object.keys(DURATION_TYPES).sort((a3, b3) => b3.length - a3.length).map(parsimmon_umd_minExports.string)),
      duration: (q3) => parsimmon_umd_minExports.seqMap(q3.number, parsimmon_umd_minExports.optWhitespace, q3.durationType, (count, _3, t3) => DURATION_TYPES[t3].mapUnits((x4) => x4 * count)).sepBy1(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace).or(parsimmon_umd_minExports.optWhitespace)).map((durations) => durations.reduce((p3, c3) => p3.plus(c3))).desc("duration like 4hr2min"),
      // A raw null value.
      rawNull: (_3) => parsimmon_umd_minExports.string("null"),
      // Source parsing.
      tagSource: (q3) => q3.tag.map((tag) => Sources.tag(tag)),
      csvSource: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("csv(").skip(parsimmon_umd_minExports.optWhitespace), q3.string, parsimmon_umd_minExports.string(")"), (_1, path, _22) => Sources.csv(path)),
      linkIncomingSource: (q3) => q3.link.map((link) => Sources.link(link.path, true)),
      linkOutgoingSource: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("outgoing(").skip(parsimmon_umd_minExports.optWhitespace), q3.link, parsimmon_umd_minExports.string(")"), (_1, link, _22) => Sources.link(link.path, false)),
      folderSource: (q3) => q3.string.map((str) => Sources.folder(str)),
      parensSource: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("("), parsimmon_umd_minExports.optWhitespace, q3.source, parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string(")"), (_1, _22, field, _3, _4) => field),
      negateSource: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.alt(parsimmon_umd_minExports.string("-"), parsimmon_umd_minExports.string("!")), q3.atomSource, (_3, source) => Sources.negate(source)),
      atomSource: (q3) => parsimmon_umd_minExports.alt(q3.parensSource, q3.negateSource, q3.linkOutgoingSource, q3.linkIncomingSource, q3.folderSource, q3.tagSource, q3.csvSource),
      binaryOpSource: (q3) => createBinaryParser(q3.atomSource, q3.binaryBooleanOp.map((s4) => s4), Sources.binaryOp),
      source: (q3) => q3.binaryOpSource,
      // Field parsing.
      variableField: (q3) => q3.identifier.chain((r3) => {
        if (KEYWORDS.includes(r3.toUpperCase())) {
          return parsimmon_umd_minExports.fail("Variable fields cannot be a keyword (" + KEYWORDS.join(" or ") + ")");
        } else {
          return parsimmon_umd_minExports.succeed(Fields.variable(r3));
        }
      }).desc("variable"),
      numberField: (q3) => q3.number.map((val) => Fields.literal(val)).desc("number"),
      stringField: (q3) => q3.string.map((val) => Fields.literal(val)).desc("string"),
      boolField: (q3) => q3.bool.map((val) => Fields.literal(val)).desc("boolean"),
      dateField: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("date("), parsimmon_umd_minExports.optWhitespace, q3.datePlus, parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string(")"), (prefix, _1, date, _22, postfix) => Fields.literal(date)).desc("date"),
      durationField: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("dur("), parsimmon_umd_minExports.optWhitespace, q3.duration, parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string(")"), (prefix, _1, dur, _22, postfix) => Fields.literal(dur)).desc("duration"),
      nullField: (q3) => q3.rawNull.map((_3) => Fields.NULL),
      linkField: (q3) => q3.link.map((f3) => Fields.literal(f3)),
      listField: (q3) => q3.field.sepBy(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)).wrap(parsimmon_umd_minExports.string("[").skip(parsimmon_umd_minExports.optWhitespace), parsimmon_umd_minExports.optWhitespace.then(parsimmon_umd_minExports.string("]"))).map((l4) => Fields.list(l4)).desc("list ('[1, 2, 3]')"),
      objectField: (q3) => parsimmon_umd_minExports.seqMap(q3.identifier.or(q3.string), parsimmon_umd_minExports.string(":").trim(parsimmon_umd_minExports.optWhitespace), q3.field, (name, _sep, value) => {
        return { name, value };
      }).sepBy(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)).wrap(parsimmon_umd_minExports.string("{").skip(parsimmon_umd_minExports.optWhitespace), parsimmon_umd_minExports.optWhitespace.then(parsimmon_umd_minExports.string("}"))).map((vals) => {
        let res = {};
        for (let entry of vals)
          res[entry.name] = entry.value;
        return Fields.object(res);
      }).desc("object ('{ a: 1, b: 2 }')"),
      atomInlineField: (q3) => parsimmon_umd_minExports.alt(q3.date, q3.duration.map((d2) => normalizeDuration(d2)), q3.string, q3.tag, q3.embedLink, q3.bool, q3.number, q3.rawNull),
      inlineFieldList: (q3) => q3.atomInlineField.sepBy(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace).lookahead(q3.atomInlineField)),
      inlineField: (q3) => parsimmon_umd_minExports.alt(parsimmon_umd_minExports.seqMap(q3.atomInlineField, parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace), q3.inlineFieldList, (f3, _s, l4) => [f3].concat(l4)), q3.atomInlineField),
      atomField: (q3) => parsimmon_umd_minExports.alt(
        // Place embed links above negated fields as they are the special parser case '![[thing]]' and are generally unambigious.
        q3.embedLink.map((l4) => Fields.literal(l4)),
        q3.negatedField,
        q3.linkField,
        q3.listField,
        q3.objectField,
        q3.lambdaField,
        q3.parensField,
        q3.boolField,
        q3.numberField,
        q3.stringField,
        q3.dateField,
        q3.durationField,
        q3.nullField,
        q3.variableField
      ),
      indexField: (q3) => parsimmon_umd_minExports.seqMap(q3.atomField, parsimmon_umd_minExports.alt(q3.dotPostfix, q3.indexPostfix, q3.functionPostfix).many(), (obj, postfixes) => {
        let result = obj;
        for (let post of postfixes) {
          switch (post.type) {
            case "dot":
              result = Fields.index(result, Fields.literal(post.field));
              break;
            case "index":
              result = Fields.index(result, post.field);
              break;
            case "function":
              result = Fields.func(result, post.fields);
              break;
          }
        }
        return result;
      }),
      negatedField: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("!"), q3.indexField, (_3, field) => Fields.negate(field)).desc("negated field"),
      parensField: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("("), parsimmon_umd_minExports.optWhitespace, q3.field, parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string(")"), (_1, _22, field, _3, _4) => field),
      lambdaField: (q3) => parsimmon_umd_minExports.seqMap(q3.identifier.sepBy(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)).wrap(parsimmon_umd_minExports.string("(").trim(parsimmon_umd_minExports.optWhitespace), parsimmon_umd_minExports.string(")").trim(parsimmon_umd_minExports.optWhitespace)), parsimmon_umd_minExports.string("=>").trim(parsimmon_umd_minExports.optWhitespace), q3.field, (ident, _ignore, value) => {
        return { type: "lambda", arguments: ident, value };
      }),
      dotPostfix: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("."), q3.identifier, (_3, field) => {
        return { type: "dot", field };
      }),
      indexPostfix: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("["), parsimmon_umd_minExports.optWhitespace, q3.field, parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string("]"), (_3, _22, field, _32, _4) => {
        return { type: "index", field };
      }),
      functionPostfix: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("("), parsimmon_umd_minExports.optWhitespace, q3.field.sepBy(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)), parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string(")"), (_3, _1, fields, _22, _32) => {
        return { type: "function", fields };
      }),
      // The precedence hierarchy of operators - multiply/divide, add/subtract, compare, and then boolean operations.
      binaryMulDivField: (q3) => createBinaryParser(q3.indexField, q3.binaryMulDiv, Fields.binaryOp),
      binaryPlusMinusField: (q3) => createBinaryParser(q3.binaryMulDivField, q3.binaryPlusMinus, Fields.binaryOp),
      binaryCompareField: (q3) => createBinaryParser(q3.binaryPlusMinusField, q3.binaryCompareOp, Fields.binaryOp),
      binaryBooleanField: (q3) => createBinaryParser(q3.binaryCompareField, q3.binaryBooleanOp, Fields.binaryOp),
      binaryOpField: (q3) => q3.binaryBooleanField,
      field: (q3) => q3.binaryOpField
    });
    function parseField(text) {
      try {
        return Result.success(EXPRESSION.field.tryParse(text));
      } catch (error) {
        return Result.failure("" + error);
      }
    }
    var QueryFields;
    (function(QueryFields2) {
      function named(name, field) {
        return { name, field };
      }
      QueryFields2.named = named;
      function sortBy(field, dir) {
        return { field, direction: dir };
      }
      QueryFields2.sortBy = sortBy;
    })(QueryFields || (QueryFields = {}));
    function captureRaw(base) {
      return parsimmon_umd_minExports.custom((success, failure) => {
        return (input, i3) => {
          let result = base._(input, i3);
          if (!result.status)
            return result;
          return Object.assign({}, result, { value: [result.value, input.substring(i3, result.index)] });
        };
      });
    }
    function stripNewlines(text) {
      return text.split(/[\r\n]+/).map((t3) => t3.trim()).join("");
    }
    function precededByWhitespaceIfNotEof(if_eof, parser) {
      return parsimmon_umd_minExports.eof.map(if_eof).or(parsimmon_umd_minExports.whitespace.then(parser));
    }
    var QUERY_LANGUAGE = parsimmon_umd_minExports.createLanguage({
      // Simple atom parsing, like words, identifiers, numbers.
      queryType: (q3) => parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regexp(/TABLE|LIST|TASK|CALENDAR/i)).map((str) => str.toLowerCase()).desc("query type ('TABLE', 'LIST', 'TASK', or 'CALENDAR')"),
      explicitNamedField: (q3) => parsimmon_umd_minExports.seqMap(EXPRESSION.field.skip(parsimmon_umd_minExports.whitespace), parsimmon_umd_minExports.regexp(/AS/i).skip(parsimmon_umd_minExports.whitespace), EXPRESSION.identifier.or(EXPRESSION.string), (field, _as, ident) => QueryFields.named(ident, field)),
      comment: () => parsimmon_umd_minExports.Parser((input, i3) => {
        let line = input.substring(i3);
        if (!line.startsWith("//"))
          return parsimmon_umd_minExports.makeFailure(i3, "Not a comment");
        line = line.split("\n")[0];
        let comment = line.substring(2).trim();
        return parsimmon_umd_minExports.makeSuccess(i3 + line.length, comment);
      }),
      namedField: (q3) => parsimmon_umd_minExports.alt(q3.explicitNamedField, captureRaw(EXPRESSION.field).map(([value, text]) => QueryFields.named(stripNewlines(text), value))),
      sortField: (q3) => parsimmon_umd_minExports.seqMap(EXPRESSION.field.skip(parsimmon_umd_minExports.optWhitespace), parsimmon_umd_minExports.regexp(/ASCENDING|DESCENDING|ASC|DESC/i).atMost(1), (field, dir) => {
        let direction = dir.length == 0 ? "ascending" : dir[0].toLowerCase();
        if (direction == "desc")
          direction = "descending";
        if (direction == "asc")
          direction = "ascending";
        return {
          field,
          direction
        };
      }),
      headerClause: (q3) => q3.queryType.chain((type) => {
        switch (type) {
          case "table": {
            return precededByWhitespaceIfNotEof(() => ({ type, fields: [], showId: true }), parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/WITHOUT\s+ID/i).skip(parsimmon_umd_minExports.optWhitespace).atMost(1), parsimmon_umd_minExports.sepBy(q3.namedField, parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)), (withoutId, fields) => {
              return { type, fields, showId: withoutId.length == 0 };
            }));
          }
          case "list":
            return precededByWhitespaceIfNotEof(() => ({ type, format: void 0, showId: true }), parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/WITHOUT\s+ID/i).skip(parsimmon_umd_minExports.optWhitespace).atMost(1), EXPRESSION.field.atMost(1), (withoutId, format) => {
              return {
                type,
                format: format.length == 1 ? format[0] : void 0,
                showId: withoutId.length == 0
              };
            }));
          case "task":
            return parsimmon_umd_minExports.succeed({ type });
          case "calendar":
            return parsimmon_umd_minExports.whitespace.then(parsimmon_umd_minExports.seqMap(q3.namedField, (field) => {
              return {
                type,
                showId: true,
                field
              };
            }));
          default:
            return parsimmon_umd_minExports.fail(`Unrecognized query type '${type}'`);
        }
      }).desc("TABLE or LIST or TASK or CALENDAR"),
      fromClause: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/FROM/i), parsimmon_umd_minExports.whitespace, EXPRESSION.source, (_1, _22, source) => source),
      whereClause: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/WHERE/i), parsimmon_umd_minExports.whitespace, EXPRESSION.field, (where, _3, field) => {
        return { type: "where", clause: field };
      }).desc("WHERE <expression>"),
      sortByClause: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/SORT/i), parsimmon_umd_minExports.whitespace, q3.sortField.sepBy1(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)), (sort2, _1, fields) => {
        return { type: "sort", fields };
      }).desc("SORT field [ASC/DESC]"),
      limitClause: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/LIMIT/i), parsimmon_umd_minExports.whitespace, EXPRESSION.field, (limit, _1, field) => {
        return { type: "limit", amount: field };
      }).desc("LIMIT <value>"),
      flattenClause: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/FLATTEN/i).skip(parsimmon_umd_minExports.whitespace), q3.namedField, (_3, field) => {
        return { type: "flatten", field };
      }).desc("FLATTEN <value> [AS <name>]"),
      groupByClause: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/GROUP BY/i).skip(parsimmon_umd_minExports.whitespace), q3.namedField, (_3, field) => {
        return { type: "group", field };
      }).desc("GROUP BY <value> [AS <name>]"),
      // Full query parsing.
      clause: (q3) => parsimmon_umd_minExports.alt(q3.fromClause, q3.whereClause, q3.sortByClause, q3.limitClause, q3.groupByClause, q3.flattenClause),
      query: (q3) => parsimmon_umd_minExports.seqMap(q3.headerClause.trim(optionalWhitespaceOrComment), q3.fromClause.trim(optionalWhitespaceOrComment).atMost(1), q3.clause.trim(optionalWhitespaceOrComment).many(), (header, from, clauses) => {
        return {
          header,
          source: from.length == 0 ? Sources.folder("") : from[0],
          operations: clauses,
          settings: DEFAULT_QUERY_SETTINGS
        };
      })
    });
    var optionalWhitespaceOrComment = parsimmon_umd_minExports.alt(parsimmon_umd_minExports.whitespace, QUERY_LANGUAGE.comment).many().map((arr) => arr.join(""));
    var getAPI2 = (app) => {
      var _a;
      if (app)
        return (_a = app.plugins.plugins.dataview) == null ? void 0 : _a.api;
      else
        return window.DataviewAPI;
    };
    var isPluginEnabled = (app) => app.plugins.enabledPlugins.has("dataview");
    exports.DATE_SHORTHANDS = DATE_SHORTHANDS;
    exports.DURATION_TYPES = DURATION_TYPES;
    exports.EXPRESSION = EXPRESSION;
    exports.KEYWORDS = KEYWORDS;
    exports.QUERY_LANGUAGE = QUERY_LANGUAGE;
    exports.getAPI = getAPI2;
    exports.isPluginEnabled = isPluginEnabled;
    exports.parseField = parseField;
  }
});

// node_modules/ical.js/build/ical.js
var require_ical = __commonJS({
  "node_modules/ical.js/build/ical.js"(exports, module2) {
    var ICAL2;
    (function() {
      if (typeof module2 === "object") {
        ICAL2 = module2.exports;
      } else if (typeof HTMLScriptElement !== "undefined" && "noModule" in HTMLScriptElement.prototype) {
        window.ICAL = ICAL2 = {};
      } else if (typeof ICAL2 !== "object") {
        ICAL2 = {};
      }
    })();
    ICAL2.foldLength = 75;
    ICAL2.newLineChar = "\r\n";
    ICAL2.helpers = {
      /**
       * Compiles a list of all referenced TZIDs in all subcomponents and
       * removes any extra VTIMEZONE subcomponents. In addition, if any TZIDs
       * are referenced by a component, but a VTIMEZONE does not exist,
       * an attempt will be made to generate a VTIMEZONE using ICAL.TimezoneService.
       *
       * @param {ICAL.Component} vcal     The top-level VCALENDAR component.
       * @return {ICAL.Component}         The ICAL.Component that was passed in.
       */
      updateTimezones: function(vcal) {
        var allsubs, properties, vtimezones, reqTzid, i3, tzid;
        if (!vcal || vcal.name !== "vcalendar") {
          return vcal;
        }
        allsubs = vcal.getAllSubcomponents();
        properties = [];
        vtimezones = {};
        for (i3 = 0; i3 < allsubs.length; i3++) {
          if (allsubs[i3].name === "vtimezone") {
            tzid = allsubs[i3].getFirstProperty("tzid").getFirstValue();
            vtimezones[tzid] = allsubs[i3];
          } else {
            properties = properties.concat(allsubs[i3].getAllProperties());
          }
        }
        reqTzid = {};
        for (i3 = 0; i3 < properties.length; i3++) {
          if (tzid = properties[i3].getParameter("tzid")) {
            reqTzid[tzid] = true;
          }
        }
        for (i3 in vtimezones) {
          if (vtimezones.hasOwnProperty(i3) && !reqTzid[i3]) {
            vcal.removeSubcomponent(vtimezones[i3]);
          }
        }
        for (i3 in reqTzid) {
          if (reqTzid.hasOwnProperty(i3) && !vtimezones[i3] && ICAL2.TimezoneService.has(i3)) {
            vcal.addSubcomponent(ICAL2.TimezoneService.get(i3).component);
          }
        }
        return vcal;
      },
      /**
       * Checks if the given type is of the number type and also NaN.
       *
       * @param {Number} number     The number to check
       * @return {Boolean}          True, if the number is strictly NaN
       */
      isStrictlyNaN: function(number) {
        return typeof number === "number" && isNaN(number);
      },
      /**
       * Parses a string value that is expected to be an integer, when the valid is
       * not an integer throws a decoration error.
       *
       * @param {String} string     Raw string input
       * @return {Number}           Parsed integer
       */
      strictParseInt: function(string) {
        var result = parseInt(string, 10);
        if (ICAL2.helpers.isStrictlyNaN(result)) {
          throw new Error(
            'Could not extract integer from "' + string + '"'
          );
        }
        return result;
      },
      /**
       * Creates or returns a class instance of a given type with the initialization
       * data if the data is not already an instance of the given type.
       *
       * @example
       * var time = new ICAL.Time(...);
       * var result = ICAL.helpers.formatClassType(time, ICAL.Time);
       *
       * (result instanceof ICAL.Time)
       * // => true
       *
       * result = ICAL.helpers.formatClassType({}, ICAL.Time);
       * (result isntanceof ICAL.Time)
       * // => true
       *
       *
       * @param {Object} data       object initialization data
       * @param {Object} type       object type (like ICAL.Time)
       * @return {?}                An instance of the found type.
       */
      formatClassType: function formatClassType(data, type) {
        if (typeof data === "undefined") {
          return void 0;
        }
        if (data instanceof type) {
          return data;
        }
        return new type(data);
      },
      /**
       * Identical to indexOf but will only match values when they are not preceded
       * by a backslash character.
       *
       * @param {String} buffer         String to search
       * @param {String} search         Value to look for
       * @param {Number} pos            Start position
       * @return {Number}               The position, or -1 if not found
       */
      unescapedIndexOf: function(buffer, search, pos) {
        while ((pos = buffer.indexOf(search, pos)) !== -1) {
          if (pos > 0 && buffer[pos - 1] === "\\") {
            pos += 1;
          } else {
            return pos;
          }
        }
        return -1;
      },
      /**
       * Find the index for insertion using binary search.
       *
       * @param {Array} list            The list to search
       * @param {?} seekVal             The value to insert
       * @param {function(?,?)} cmpfunc The comparison func, that can
       *                                  compare two seekVals
       * @return {Number}               The insert position
       */
      binsearchInsert: function(list, seekVal, cmpfunc) {
        if (!list.length)
          return 0;
        var low = 0, high = list.length - 1, mid, cmpval;
        while (low <= high) {
          mid = low + Math.floor((high - low) / 2);
          cmpval = cmpfunc(seekVal, list[mid]);
          if (cmpval < 0)
            high = mid - 1;
          else if (cmpval > 0)
            low = mid + 1;
          else
            break;
        }
        if (cmpval < 0)
          return mid;
        else if (cmpval > 0)
          return mid + 1;
        else
          return mid;
      },
      /**
       * Convenience function for debug output
       * @private
       */
      dumpn: (
        /* istanbul ignore next */
        function() {
          if (!ICAL2.debug) {
            return;
          }
          if (typeof console !== "undefined" && "log" in console) {
            ICAL2.helpers.dumpn = function consoleDumpn(input) {
              console.log(input);
            };
          } else {
            ICAL2.helpers.dumpn = function geckoDumpn(input) {
              dump(input + "\n");
            };
          }
          ICAL2.helpers.dumpn(arguments[0]);
        }
      ),
      /**
       * Clone the passed object or primitive. By default a shallow clone will be
       * executed.
       *
       * @param {*} aSrc            The thing to clone
       * @param {Boolean=} aDeep    If true, a deep clone will be performed
       * @return {*}                The copy of the thing
       */
      clone: function(aSrc, aDeep) {
        if (!aSrc || typeof aSrc != "object") {
          return aSrc;
        } else if (aSrc instanceof Date) {
          return new Date(aSrc.getTime());
        } else if ("clone" in aSrc) {
          return aSrc.clone();
        } else if (Array.isArray(aSrc)) {
          var arr = [];
          for (var i3 = 0; i3 < aSrc.length; i3++) {
            arr.push(aDeep ? ICAL2.helpers.clone(aSrc[i3], true) : aSrc[i3]);
          }
          return arr;
        } else {
          var obj = {};
          for (var name in aSrc) {
            if (Object.prototype.hasOwnProperty.call(aSrc, name)) {
              if (aDeep) {
                obj[name] = ICAL2.helpers.clone(aSrc[name], true);
              } else {
                obj[name] = aSrc[name];
              }
            }
          }
          return obj;
        }
      },
      /**
       * Performs iCalendar line folding. A line ending character is inserted and
       * the next line begins with a whitespace.
       *
       * @example
       * SUMMARY:This line will be fold
       *  ed right in the middle of a word.
       *
       * @param {String} aLine      The line to fold
       * @return {String}           The folded line
       */
      foldline: function foldline(aLine) {
        var result = "";
        var line = aLine || "", pos = 0, line_length = 0;
        while (line.length) {
          var cp = line.codePointAt(pos);
          if (cp < 128)
            ++line_length;
          else if (cp < 2048)
            line_length += 2;
          else if (cp < 65536)
            line_length += 3;
          else
            line_length += 4;
          if (line_length < ICAL2.foldLength + 1)
            pos += cp > 65535 ? 2 : 1;
          else {
            result += ICAL2.newLineChar + " " + line.substring(0, pos);
            line = line.substring(pos);
            pos = line_length = 0;
          }
        }
        return result.substr(ICAL2.newLineChar.length + 1);
      },
      /**
       * Pads the given string or number with zeros so it will have at least two
       * characters.
       *
       * @param {String|Number} data    The string or number to pad
       * @return {String}               The number padded as a string
       */
      pad2: function pad(data) {
        if (typeof data !== "string") {
          if (typeof data === "number") {
            data = parseInt(data);
          }
          data = String(data);
        }
        var len = data.length;
        switch (len) {
          case 0:
            return "00";
          case 1:
            return "0" + data;
          default:
            return data;
        }
      },
      /**
       * Truncates the given number, correctly handling negative numbers.
       *
       * @param {Number} number     The number to truncate
       * @return {Number}           The truncated number
       */
      trunc: function trunc(number) {
        return number < 0 ? Math.ceil(number) : Math.floor(number);
      },
      /**
       * Poor-man's cross-browser inheritance for JavaScript. Doesn't support all
       * the features, but enough for our usage.
       *
       * @param {Function} base     The base class constructor function.
       * @param {Function} child    The child class constructor function.
       * @param {Object} extra      Extends the prototype with extra properties
       *                              and methods
       */
      inherits: function(base, child, extra) {
        function F4() {
        }
        F4.prototype = base.prototype;
        child.prototype = new F4();
        if (extra) {
          ICAL2.helpers.extend(extra, child.prototype);
        }
      },
      /**
       * Poor-man's cross-browser object extension. Doesn't support all the
       * features, but enough for our usage. Note that the target's properties are
       * not overwritten with the source properties.
       *
       * @example
       * var child = ICAL.helpers.extend(parent, {
       *   "bar": 123
       * });
       *
       * @param {Object} source     The object to extend
       * @param {Object} target     The object to extend with
       * @return {Object}           Returns the target.
       */
      extend: function(source, target) {
        for (var key in source) {
          var descr = Object.getOwnPropertyDescriptor(source, key);
          if (descr && !Object.getOwnPropertyDescriptor(target, key)) {
            Object.defineProperty(target, key, descr);
          }
        }
        return target;
      }
    };
    ICAL2.design = function() {
      "use strict";
      var FROM_ICAL_NEWLINE = /\\\\|\\;|\\,|\\[Nn]/g;
      var TO_ICAL_NEWLINE = /\\|;|,|\n/g;
      var FROM_VCARD_NEWLINE = /\\\\|\\,|\\[Nn]/g;
      var TO_VCARD_NEWLINE = /\\|,|\n/g;
      function createTextType(fromNewline, toNewline) {
        var result = {
          matches: /.*/,
          fromICAL: function(aValue, structuredEscape) {
            return replaceNewline(aValue, fromNewline, structuredEscape);
          },
          toICAL: function(aValue, structuredEscape) {
            var regEx = toNewline;
            if (structuredEscape)
              regEx = new RegExp(regEx.source + "|" + structuredEscape);
            return aValue.replace(regEx, function(str) {
              switch (str) {
                case "\\":
                  return "\\\\";
                case ";":
                  return "\\;";
                case ",":
                  return "\\,";
                case "\n":
                  return "\\n";
                default:
                  return str;
              }
            });
          }
        };
        return result;
      }
      var DEFAULT_TYPE_TEXT = { defaultType: "text" };
      var DEFAULT_TYPE_TEXT_MULTI = { defaultType: "text", multiValue: "," };
      var DEFAULT_TYPE_TEXT_STRUCTURED = { defaultType: "text", structuredValue: ";" };
      var DEFAULT_TYPE_INTEGER = { defaultType: "integer" };
      var DEFAULT_TYPE_DATETIME_DATE = { defaultType: "date-time", allowedTypes: ["date-time", "date"] };
      var DEFAULT_TYPE_DATETIME = { defaultType: "date-time" };
      var DEFAULT_TYPE_URI = { defaultType: "uri" };
      var DEFAULT_TYPE_UTCOFFSET = { defaultType: "utc-offset" };
      var DEFAULT_TYPE_RECUR = { defaultType: "recur" };
      var DEFAULT_TYPE_DATE_ANDOR_TIME = { defaultType: "date-and-or-time", allowedTypes: ["date-time", "date", "text"] };
      function replaceNewlineReplace(string) {
        switch (string) {
          case "\\\\":
            return "\\";
          case "\\;":
            return ";";
          case "\\,":
            return ",";
          case "\\n":
          case "\\N":
            return "\n";
          default:
            return string;
        }
      }
      function replaceNewline(value, newline, structuredEscape) {
        if (value.indexOf("\\") === -1) {
          return value;
        }
        if (structuredEscape)
          newline = new RegExp(newline.source + "|\\\\" + structuredEscape);
        return value.replace(newline, replaceNewlineReplace);
      }
      var commonProperties = {
        "categories": DEFAULT_TYPE_TEXT_MULTI,
        "url": DEFAULT_TYPE_URI,
        "version": DEFAULT_TYPE_TEXT,
        "uid": DEFAULT_TYPE_TEXT
      };
      var commonValues = {
        "boolean": {
          values: ["TRUE", "FALSE"],
          fromICAL: function(aValue) {
            switch (aValue) {
              case "TRUE":
                return true;
              case "FALSE":
                return false;
              default:
                return false;
            }
          },
          toICAL: function(aValue) {
            if (aValue) {
              return "TRUE";
            }
            return "FALSE";
          }
        },
        float: {
          matches: /^[+-]?\d+\.\d+$/,
          fromICAL: function(aValue) {
            var parsed = parseFloat(aValue);
            if (ICAL2.helpers.isStrictlyNaN(parsed)) {
              return 0;
            }
            return parsed;
          },
          toICAL: function(aValue) {
            return String(aValue);
          }
        },
        integer: {
          fromICAL: function(aValue) {
            var parsed = parseInt(aValue);
            if (ICAL2.helpers.isStrictlyNaN(parsed)) {
              return 0;
            }
            return parsed;
          },
          toICAL: function(aValue) {
            return String(aValue);
          }
        },
        "utc-offset": {
          toICAL: function(aValue) {
            if (aValue.length < 7) {
              return aValue.substr(0, 3) + aValue.substr(4, 2);
            } else {
              return aValue.substr(0, 3) + aValue.substr(4, 2) + aValue.substr(7, 2);
            }
          },
          fromICAL: function(aValue) {
            if (aValue.length < 6) {
              return aValue.substr(0, 3) + ":" + aValue.substr(3, 2);
            } else {
              return aValue.substr(0, 3) + ":" + aValue.substr(3, 2) + ":" + aValue.substr(5, 2);
            }
          },
          decorate: function(aValue) {
            return ICAL2.UtcOffset.fromString(aValue);
          },
          undecorate: function(aValue) {
            return aValue.toString();
          }
        }
      };
      var icalParams = {
        // Although the syntax is DQUOTE uri DQUOTE, I don't think we should
        // enfoce anything aside from it being a valid content line.
        //
        // At least some params require - if multi values are used - DQUOTEs
        // for each of its values - e.g. delegated-from="uri1","uri2"
        // To indicate this, I introduced the new k/v pair
        // multiValueSeparateDQuote: true
        //
        // "ALTREP": { ... },
        // CN just wants a param-value
        // "CN": { ... }
        "cutype": {
          values: ["INDIVIDUAL", "GROUP", "RESOURCE", "ROOM", "UNKNOWN"],
          allowXName: true,
          allowIanaToken: true
        },
        "delegated-from": {
          valueType: "cal-address",
          multiValue: ",",
          multiValueSeparateDQuote: true
        },
        "delegated-to": {
          valueType: "cal-address",
          multiValue: ",",
          multiValueSeparateDQuote: true
        },
        // "DIR": { ... }, // See ALTREP
        "encoding": {
          values: ["8BIT", "BASE64"]
        },
        // "FMTTYPE": { ... }, // See ALTREP
        "fbtype": {
          values: ["FREE", "BUSY", "BUSY-UNAVAILABLE", "BUSY-TENTATIVE"],
          allowXName: true,
          allowIanaToken: true
        },
        // "LANGUAGE": { ... }, // See ALTREP
        "member": {
          valueType: "cal-address",
          multiValue: ",",
          multiValueSeparateDQuote: true
        },
        "partstat": {
          // TODO These values are actually different per-component
          values: [
            "NEEDS-ACTION",
            "ACCEPTED",
            "DECLINED",
            "TENTATIVE",
            "DELEGATED",
            "COMPLETED",
            "IN-PROCESS"
          ],
          allowXName: true,
          allowIanaToken: true
        },
        "range": {
          values: ["THISANDFUTURE"]
        },
        "related": {
          values: ["START", "END"]
        },
        "reltype": {
          values: ["PARENT", "CHILD", "SIBLING"],
          allowXName: true,
          allowIanaToken: true
        },
        "role": {
          values: [
            "REQ-PARTICIPANT",
            "CHAIR",
            "OPT-PARTICIPANT",
            "NON-PARTICIPANT"
          ],
          allowXName: true,
          allowIanaToken: true
        },
        "rsvp": {
          values: ["TRUE", "FALSE"]
        },
        "sent-by": {
          valueType: "cal-address"
        },
        "tzid": {
          matches: /^\//
        },
        "value": {
          // since the value here is a 'type' lowercase is used.
          values: [
            "binary",
            "boolean",
            "cal-address",
            "date",
            "date-time",
            "duration",
            "float",
            "integer",
            "period",
            "recur",
            "text",
            "time",
            "uri",
            "utc-offset"
          ],
          allowXName: true,
          allowIanaToken: true
        }
      };
      var icalValues = ICAL2.helpers.extend(commonValues, {
        text: createTextType(FROM_ICAL_NEWLINE, TO_ICAL_NEWLINE),
        uri: {
          // TODO
          /* ... */
        },
        "binary": {
          decorate: function(aString) {
            return ICAL2.Binary.fromString(aString);
          },
          undecorate: function(aBinary) {
            return aBinary.toString();
          }
        },
        "cal-address": {
          // needs to be an uri
        },
        "date": {
          decorate: function(aValue, aProp) {
            if (design.strict) {
              return ICAL2.Time.fromDateString(aValue, aProp);
            } else {
              return ICAL2.Time.fromString(aValue, aProp);
            }
          },
          /**
           * undecorates a time object.
           */
          undecorate: function(aValue) {
            return aValue.toString();
          },
          fromICAL: function(aValue) {
            if (!design.strict && aValue.length >= 15) {
              return icalValues["date-time"].fromICAL(aValue);
            } else {
              return aValue.substr(0, 4) + "-" + aValue.substr(4, 2) + "-" + aValue.substr(6, 2);
            }
          },
          toICAL: function(aValue) {
            var len = aValue.length;
            if (len == 10) {
              return aValue.substr(0, 4) + aValue.substr(5, 2) + aValue.substr(8, 2);
            } else if (len >= 19) {
              return icalValues["date-time"].toICAL(aValue);
            } else {
              return aValue;
            }
          }
        },
        "date-time": {
          fromICAL: function(aValue) {
            if (!design.strict && aValue.length == 8) {
              return icalValues.date.fromICAL(aValue);
            } else {
              var result = aValue.substr(0, 4) + "-" + aValue.substr(4, 2) + "-" + aValue.substr(6, 2) + "T" + aValue.substr(9, 2) + ":" + aValue.substr(11, 2) + ":" + aValue.substr(13, 2);
              if (aValue[15] && aValue[15] === "Z") {
                result += "Z";
              }
              return result;
            }
          },
          toICAL: function(aValue) {
            var len = aValue.length;
            if (len == 10 && !design.strict) {
              return icalValues.date.toICAL(aValue);
            } else if (len >= 19) {
              var result = aValue.substr(0, 4) + aValue.substr(5, 2) + // grab the (DDTHH) segment
              aValue.substr(8, 5) + // MM
              aValue.substr(14, 2) + // SS
              aValue.substr(17, 2);
              if (aValue[19] && aValue[19] === "Z") {
                result += "Z";
              }
              return result;
            } else {
              return aValue;
            }
          },
          decorate: function(aValue, aProp) {
            if (design.strict) {
              return ICAL2.Time.fromDateTimeString(aValue, aProp);
            } else {
              return ICAL2.Time.fromString(aValue, aProp);
            }
          },
          undecorate: function(aValue) {
            return aValue.toString();
          }
        },
        duration: {
          decorate: function(aValue) {
            return ICAL2.Duration.fromString(aValue);
          },
          undecorate: function(aValue) {
            return aValue.toString();
          }
        },
        period: {
          fromICAL: function(string) {
            var parts = string.split("/");
            parts[0] = icalValues["date-time"].fromICAL(parts[0]);
            if (!ICAL2.Duration.isValueString(parts[1])) {
              parts[1] = icalValues["date-time"].fromICAL(parts[1]);
            }
            return parts;
          },
          toICAL: function(parts) {
            if (!design.strict && parts[0].length == 10) {
              parts[0] = icalValues.date.toICAL(parts[0]);
            } else {
              parts[0] = icalValues["date-time"].toICAL(parts[0]);
            }
            if (!ICAL2.Duration.isValueString(parts[1])) {
              if (!design.strict && parts[1].length == 10) {
                parts[1] = icalValues.date.toICAL(parts[1]);
              } else {
                parts[1] = icalValues["date-time"].toICAL(parts[1]);
              }
            }
            return parts.join("/");
          },
          decorate: function(aValue, aProp) {
            return ICAL2.Period.fromJSON(aValue, aProp, !design.strict);
          },
          undecorate: function(aValue) {
            return aValue.toJSON();
          }
        },
        recur: {
          fromICAL: function(string) {
            return ICAL2.Recur._stringToData(string, true);
          },
          toICAL: function(data) {
            var str = "";
            for (var k3 in data) {
              if (!Object.prototype.hasOwnProperty.call(data, k3)) {
                continue;
              }
              var val = data[k3];
              if (k3 == "until") {
                if (val.length > 10) {
                  val = icalValues["date-time"].toICAL(val);
                } else {
                  val = icalValues.date.toICAL(val);
                }
              } else if (k3 == "wkst") {
                if (typeof val === "number") {
                  val = ICAL2.Recur.numericDayToIcalDay(val);
                }
              } else if (Array.isArray(val)) {
                val = val.join(",");
              }
              str += k3.toUpperCase() + "=" + val + ";";
            }
            return str.substr(0, str.length - 1);
          },
          decorate: function decorate(aValue) {
            return ICAL2.Recur.fromData(aValue);
          },
          undecorate: function(aRecur) {
            return aRecur.toJSON();
          }
        },
        time: {
          fromICAL: function(aValue) {
            if (aValue.length < 6) {
              return aValue;
            }
            var result = aValue.substr(0, 2) + ":" + aValue.substr(2, 2) + ":" + aValue.substr(4, 2);
            if (aValue[6] === "Z") {
              result += "Z";
            }
            return result;
          },
          toICAL: function(aValue) {
            if (aValue.length < 8) {
              return aValue;
            }
            var result = aValue.substr(0, 2) + aValue.substr(3, 2) + aValue.substr(6, 2);
            if (aValue[8] === "Z") {
              result += "Z";
            }
            return result;
          }
        }
      });
      var icalProperties = ICAL2.helpers.extend(commonProperties, {
        "action": DEFAULT_TYPE_TEXT,
        "attach": { defaultType: "uri" },
        "attendee": { defaultType: "cal-address" },
        "calscale": DEFAULT_TYPE_TEXT,
        "class": DEFAULT_TYPE_TEXT,
        "comment": DEFAULT_TYPE_TEXT,
        "completed": DEFAULT_TYPE_DATETIME,
        "contact": DEFAULT_TYPE_TEXT,
        "created": DEFAULT_TYPE_DATETIME,
        "description": DEFAULT_TYPE_TEXT,
        "dtend": DEFAULT_TYPE_DATETIME_DATE,
        "dtstamp": DEFAULT_TYPE_DATETIME,
        "dtstart": DEFAULT_TYPE_DATETIME_DATE,
        "due": DEFAULT_TYPE_DATETIME_DATE,
        "duration": { defaultType: "duration" },
        "exdate": {
          defaultType: "date-time",
          allowedTypes: ["date-time", "date"],
          multiValue: ","
        },
        "exrule": DEFAULT_TYPE_RECUR,
        "freebusy": { defaultType: "period", multiValue: "," },
        "geo": { defaultType: "float", structuredValue: ";" },
        "last-modified": DEFAULT_TYPE_DATETIME,
        "location": DEFAULT_TYPE_TEXT,
        "method": DEFAULT_TYPE_TEXT,
        "organizer": { defaultType: "cal-address" },
        "percent-complete": DEFAULT_TYPE_INTEGER,
        "priority": DEFAULT_TYPE_INTEGER,
        "prodid": DEFAULT_TYPE_TEXT,
        "related-to": DEFAULT_TYPE_TEXT,
        "repeat": DEFAULT_TYPE_INTEGER,
        "rdate": {
          defaultType: "date-time",
          allowedTypes: ["date-time", "date", "period"],
          multiValue: ",",
          detectType: function(string) {
            if (string.indexOf("/") !== -1) {
              return "period";
            }
            return string.indexOf("T") === -1 ? "date" : "date-time";
          }
        },
        "recurrence-id": DEFAULT_TYPE_DATETIME_DATE,
        "resources": DEFAULT_TYPE_TEXT_MULTI,
        "request-status": DEFAULT_TYPE_TEXT_STRUCTURED,
        "rrule": DEFAULT_TYPE_RECUR,
        "sequence": DEFAULT_TYPE_INTEGER,
        "status": DEFAULT_TYPE_TEXT,
        "summary": DEFAULT_TYPE_TEXT,
        "transp": DEFAULT_TYPE_TEXT,
        "trigger": { defaultType: "duration", allowedTypes: ["duration", "date-time"] },
        "tzoffsetfrom": DEFAULT_TYPE_UTCOFFSET,
        "tzoffsetto": DEFAULT_TYPE_UTCOFFSET,
        "tzurl": DEFAULT_TYPE_URI,
        "tzid": DEFAULT_TYPE_TEXT,
        "tzname": DEFAULT_TYPE_TEXT
      });
      var vcardValues = ICAL2.helpers.extend(commonValues, {
        text: createTextType(FROM_VCARD_NEWLINE, TO_VCARD_NEWLINE),
        uri: createTextType(FROM_VCARD_NEWLINE, TO_VCARD_NEWLINE),
        date: {
          decorate: function(aValue) {
            return ICAL2.VCardTime.fromDateAndOrTimeString(aValue, "date");
          },
          undecorate: function(aValue) {
            return aValue.toString();
          },
          fromICAL: function(aValue) {
            if (aValue.length == 8) {
              return icalValues.date.fromICAL(aValue);
            } else if (aValue[0] == "-" && aValue.length == 6) {
              return aValue.substr(0, 4) + "-" + aValue.substr(4);
            } else {
              return aValue;
            }
          },
          toICAL: function(aValue) {
            if (aValue.length == 10) {
              return icalValues.date.toICAL(aValue);
            } else if (aValue[0] == "-" && aValue.length == 7) {
              return aValue.substr(0, 4) + aValue.substr(5);
            } else {
              return aValue;
            }
          }
        },
        time: {
          decorate: function(aValue) {
            return ICAL2.VCardTime.fromDateAndOrTimeString("T" + aValue, "time");
          },
          undecorate: function(aValue) {
            return aValue.toString();
          },
          fromICAL: function(aValue) {
            var splitzone = vcardValues.time._splitZone(aValue, true);
            var zone = splitzone[0], value = splitzone[1];
            if (value.length == 6) {
              value = value.substr(0, 2) + ":" + value.substr(2, 2) + ":" + value.substr(4, 2);
            } else if (value.length == 4 && value[0] != "-") {
              value = value.substr(0, 2) + ":" + value.substr(2, 2);
            } else if (value.length == 5) {
              value = value.substr(0, 3) + ":" + value.substr(3, 2);
            }
            if (zone.length == 5 && (zone[0] == "-" || zone[0] == "+")) {
              zone = zone.substr(0, 3) + ":" + zone.substr(3);
            }
            return value + zone;
          },
          toICAL: function(aValue) {
            var splitzone = vcardValues.time._splitZone(aValue);
            var zone = splitzone[0], value = splitzone[1];
            if (value.length == 8) {
              value = value.substr(0, 2) + value.substr(3, 2) + value.substr(6, 2);
            } else if (value.length == 5 && value[0] != "-") {
              value = value.substr(0, 2) + value.substr(3, 2);
            } else if (value.length == 6) {
              value = value.substr(0, 3) + value.substr(4, 2);
            }
            if (zone.length == 6 && (zone[0] == "-" || zone[0] == "+")) {
              zone = zone.substr(0, 3) + zone.substr(4);
            }
            return value + zone;
          },
          _splitZone: function(aValue, isFromIcal) {
            var lastChar = aValue.length - 1;
            var signChar = aValue.length - (isFromIcal ? 5 : 6);
            var sign = aValue[signChar];
            var zone, value;
            if (aValue[lastChar] == "Z") {
              zone = aValue[lastChar];
              value = aValue.substr(0, lastChar);
            } else if (aValue.length > 6 && (sign == "-" || sign == "+")) {
              zone = aValue.substr(signChar);
              value = aValue.substr(0, signChar);
            } else {
              zone = "";
              value = aValue;
            }
            return [zone, value];
          }
        },
        "date-time": {
          decorate: function(aValue) {
            return ICAL2.VCardTime.fromDateAndOrTimeString(aValue, "date-time");
          },
          undecorate: function(aValue) {
            return aValue.toString();
          },
          fromICAL: function(aValue) {
            return vcardValues["date-and-or-time"].fromICAL(aValue);
          },
          toICAL: function(aValue) {
            return vcardValues["date-and-or-time"].toICAL(aValue);
          }
        },
        "date-and-or-time": {
          decorate: function(aValue) {
            return ICAL2.VCardTime.fromDateAndOrTimeString(aValue, "date-and-or-time");
          },
          undecorate: function(aValue) {
            return aValue.toString();
          },
          fromICAL: function(aValue) {
            var parts = aValue.split("T");
            return (parts[0] ? vcardValues.date.fromICAL(parts[0]) : "") + (parts[1] ? "T" + vcardValues.time.fromICAL(parts[1]) : "");
          },
          toICAL: function(aValue) {
            var parts = aValue.split("T");
            return vcardValues.date.toICAL(parts[0]) + (parts[1] ? "T" + vcardValues.time.toICAL(parts[1]) : "");
          }
        },
        timestamp: icalValues["date-time"],
        "language-tag": {
          matches: /^[a-zA-Z0-9-]+$/
          // Could go with a more strict regex here
        }
      });
      var vcardParams = {
        "type": {
          valueType: "text",
          multiValue: ","
        },
        "value": {
          // since the value here is a 'type' lowercase is used.
          values: [
            "text",
            "uri",
            "date",
            "time",
            "date-time",
            "date-and-or-time",
            "timestamp",
            "boolean",
            "integer",
            "float",
            "utc-offset",
            "language-tag"
          ],
          allowXName: true,
          allowIanaToken: true
        }
      };
      var vcardProperties = ICAL2.helpers.extend(commonProperties, {
        "adr": { defaultType: "text", structuredValue: ";", multiValue: "," },
        "anniversary": DEFAULT_TYPE_DATE_ANDOR_TIME,
        "bday": DEFAULT_TYPE_DATE_ANDOR_TIME,
        "caladruri": DEFAULT_TYPE_URI,
        "caluri": DEFAULT_TYPE_URI,
        "clientpidmap": DEFAULT_TYPE_TEXT_STRUCTURED,
        "email": DEFAULT_TYPE_TEXT,
        "fburl": DEFAULT_TYPE_URI,
        "fn": DEFAULT_TYPE_TEXT,
        "gender": DEFAULT_TYPE_TEXT_STRUCTURED,
        "geo": DEFAULT_TYPE_URI,
        "impp": DEFAULT_TYPE_URI,
        "key": DEFAULT_TYPE_URI,
        "kind": DEFAULT_TYPE_TEXT,
        "lang": { defaultType: "language-tag" },
        "logo": DEFAULT_TYPE_URI,
        "member": DEFAULT_TYPE_URI,
        "n": { defaultType: "text", structuredValue: ";", multiValue: "," },
        "nickname": DEFAULT_TYPE_TEXT_MULTI,
        "note": DEFAULT_TYPE_TEXT,
        "org": { defaultType: "text", structuredValue: ";" },
        "photo": DEFAULT_TYPE_URI,
        "related": DEFAULT_TYPE_URI,
        "rev": { defaultType: "timestamp" },
        "role": DEFAULT_TYPE_TEXT,
        "sound": DEFAULT_TYPE_URI,
        "source": DEFAULT_TYPE_URI,
        "tel": { defaultType: "uri", allowedTypes: ["uri", "text"] },
        "title": DEFAULT_TYPE_TEXT,
        "tz": { defaultType: "text", allowedTypes: ["text", "utc-offset", "uri"] },
        "xml": DEFAULT_TYPE_TEXT
      });
      var vcard3Values = ICAL2.helpers.extend(commonValues, {
        binary: icalValues.binary,
        date: vcardValues.date,
        "date-time": vcardValues["date-time"],
        "phone-number": {
          // TODO
          /* ... */
        },
        uri: icalValues.uri,
        text: icalValues.text,
        time: icalValues.time,
        vcard: icalValues.text,
        "utc-offset": {
          toICAL: function(aValue) {
            return aValue.substr(0, 7);
          },
          fromICAL: function(aValue) {
            return aValue.substr(0, 7);
          },
          decorate: function(aValue) {
            return ICAL2.UtcOffset.fromString(aValue);
          },
          undecorate: function(aValue) {
            return aValue.toString();
          }
        }
      });
      var vcard3Params = {
        "type": {
          valueType: "text",
          multiValue: ","
        },
        "value": {
          // since the value here is a 'type' lowercase is used.
          values: [
            "text",
            "uri",
            "date",
            "date-time",
            "phone-number",
            "time",
            "boolean",
            "integer",
            "float",
            "utc-offset",
            "vcard",
            "binary"
          ],
          allowXName: true,
          allowIanaToken: true
        }
      };
      var vcard3Properties = ICAL2.helpers.extend(commonProperties, {
        fn: DEFAULT_TYPE_TEXT,
        n: { defaultType: "text", structuredValue: ";", multiValue: "," },
        nickname: DEFAULT_TYPE_TEXT_MULTI,
        photo: { defaultType: "binary", allowedTypes: ["binary", "uri"] },
        bday: {
          defaultType: "date-time",
          allowedTypes: ["date-time", "date"],
          detectType: function(string) {
            return string.indexOf("T") === -1 ? "date" : "date-time";
          }
        },
        adr: { defaultType: "text", structuredValue: ";", multiValue: "," },
        label: DEFAULT_TYPE_TEXT,
        tel: { defaultType: "phone-number" },
        email: DEFAULT_TYPE_TEXT,
        mailer: DEFAULT_TYPE_TEXT,
        tz: { defaultType: "utc-offset", allowedTypes: ["utc-offset", "text"] },
        geo: { defaultType: "float", structuredValue: ";" },
        title: DEFAULT_TYPE_TEXT,
        role: DEFAULT_TYPE_TEXT,
        logo: { defaultType: "binary", allowedTypes: ["binary", "uri"] },
        agent: { defaultType: "vcard", allowedTypes: ["vcard", "text", "uri"] },
        org: DEFAULT_TYPE_TEXT_STRUCTURED,
        note: DEFAULT_TYPE_TEXT_MULTI,
        prodid: DEFAULT_TYPE_TEXT,
        rev: {
          defaultType: "date-time",
          allowedTypes: ["date-time", "date"],
          detectType: function(string) {
            return string.indexOf("T") === -1 ? "date" : "date-time";
          }
        },
        "sort-string": DEFAULT_TYPE_TEXT,
        sound: { defaultType: "binary", allowedTypes: ["binary", "uri"] },
        class: DEFAULT_TYPE_TEXT,
        key: { defaultType: "binary", allowedTypes: ["binary", "text"] }
      });
      var icalSet = {
        value: icalValues,
        param: icalParams,
        property: icalProperties
      };
      var vcardSet = {
        value: vcardValues,
        param: vcardParams,
        property: vcardProperties
      };
      var vcard3Set = {
        value: vcard3Values,
        param: vcard3Params,
        property: vcard3Properties
      };
      var design = {
        /**
         * A designSet describes value, parameter and property data. It is used by
         * ther parser and stringifier in components and properties to determine they
         * should be represented.
         *
         * @typedef {Object} designSet
         * @memberOf ICAL.design
         * @property {Object} value       Definitions for value types, keys are type names
         * @property {Object} param       Definitions for params, keys are param names
         * @property {Object} property    Defintions for properties, keys are property names
         */
        /**
         * Can be set to false to make the parser more lenient.
         */
        strict: true,
        /**
         * The default set for new properties and components if none is specified.
         * @type {ICAL.design.designSet}
         */
        defaultSet: icalSet,
        /**
         * The default type for unknown properties
         * @type {String}
         */
        defaultType: "unknown",
        /**
         * Holds the design set for known top-level components
         *
         * @type {Object}
         * @property {ICAL.design.designSet} vcard       vCard VCARD
         * @property {ICAL.design.designSet} vevent      iCalendar VEVENT
         * @property {ICAL.design.designSet} vtodo       iCalendar VTODO
         * @property {ICAL.design.designSet} vjournal    iCalendar VJOURNAL
         * @property {ICAL.design.designSet} valarm      iCalendar VALARM
         * @property {ICAL.design.designSet} vtimezone   iCalendar VTIMEZONE
         * @property {ICAL.design.designSet} daylight    iCalendar DAYLIGHT
         * @property {ICAL.design.designSet} standard    iCalendar STANDARD
         *
         * @example
         * var propertyName = 'fn';
         * var componentDesign = ICAL.design.components.vcard;
         * var propertyDetails = componentDesign.property[propertyName];
         * if (propertyDetails.defaultType == 'text') {
         *   // Yep, sure is...
         * }
         */
        components: {
          vcard: vcardSet,
          vcard3: vcard3Set,
          vevent: icalSet,
          vtodo: icalSet,
          vjournal: icalSet,
          valarm: icalSet,
          vtimezone: icalSet,
          daylight: icalSet,
          standard: icalSet
        },
        /**
         * The design set for iCalendar (rfc5545/rfc7265) components.
         * @type {ICAL.design.designSet}
         */
        icalendar: icalSet,
        /**
         * The design set for vCard (rfc6350/rfc7095) components.
         * @type {ICAL.design.designSet}
         */
        vcard: vcardSet,
        /**
         * The design set for vCard (rfc2425/rfc2426/rfc7095) components.
         * @type {ICAL.design.designSet}
         */
        vcard3: vcard3Set,
        /**
         * Gets the design set for the given component name.
         *
         * @param {String} componentName        The name of the component
         * @return {ICAL.design.designSet}      The design set for the component
         */
        getDesignSet: function(componentName) {
          var isInDesign = componentName && componentName in design.components;
          return isInDesign ? design.components[componentName] : design.defaultSet;
        }
      };
      return design;
    }();
    ICAL2.stringify = function() {
      "use strict";
      var LINE_ENDING = "\r\n";
      var DEFAULT_VALUE_TYPE = "unknown";
      var design = ICAL2.design;
      var helpers = ICAL2.helpers;
      function stringify(jCal) {
        if (typeof jCal[0] == "string") {
          jCal = [jCal];
        }
        var i3 = 0;
        var len = jCal.length;
        var result = "";
        for (; i3 < len; i3++) {
          result += stringify.component(jCal[i3]) + LINE_ENDING;
        }
        return result;
      }
      stringify.component = function(component, designSet) {
        var name = component[0].toUpperCase();
        var result = "BEGIN:" + name + LINE_ENDING;
        var props = component[1];
        var propIdx = 0;
        var propLen = props.length;
        var designSetName = component[0];
        if (designSetName === "vcard" && component[1].length > 0 && !(component[1][0][0] === "version" && component[1][0][3] === "4.0")) {
          designSetName = "vcard3";
        }
        designSet = designSet || design.getDesignSet(designSetName);
        for (; propIdx < propLen; propIdx++) {
          result += stringify.property(props[propIdx], designSet) + LINE_ENDING;
        }
        var comps = component[2] || [];
        var compIdx = 0;
        var compLen = comps.length;
        for (; compIdx < compLen; compIdx++) {
          result += stringify.component(comps[compIdx], designSet) + LINE_ENDING;
        }
        result += "END:" + name;
        return result;
      };
      stringify.property = function(property, designSet, noFold) {
        var name = property[0].toUpperCase();
        var jsName = property[0];
        var params = property[1];
        var line = name;
        var paramName;
        for (paramName in params) {
          var value = params[paramName];
          if (params.hasOwnProperty(paramName)) {
            var multiValue = paramName in designSet.param && designSet.param[paramName].multiValue;
            if (multiValue && Array.isArray(value)) {
              if (designSet.param[paramName].multiValueSeparateDQuote) {
                multiValue = '"' + multiValue + '"';
              }
              value = value.map(stringify._rfc6868Unescape);
              value = stringify.multiValue(value, multiValue, "unknown", null, designSet);
            } else {
              value = stringify._rfc6868Unescape(value);
            }
            line += ";" + paramName.toUpperCase();
            line += "=" + stringify.propertyValue(value);
          }
        }
        if (property.length === 3) {
          return line + ":";
        }
        var valueType = property[2];
        if (!designSet) {
          designSet = design.defaultSet;
        }
        var propDetails;
        var multiValue = false;
        var structuredValue = false;
        var isDefault = false;
        if (jsName in designSet.property) {
          propDetails = designSet.property[jsName];
          if ("multiValue" in propDetails) {
            multiValue = propDetails.multiValue;
          }
          if ("structuredValue" in propDetails && Array.isArray(property[3])) {
            structuredValue = propDetails.structuredValue;
          }
          if ("defaultType" in propDetails) {
            if (valueType === propDetails.defaultType) {
              isDefault = true;
            }
          } else {
            if (valueType === DEFAULT_VALUE_TYPE) {
              isDefault = true;
            }
          }
        } else {
          if (valueType === DEFAULT_VALUE_TYPE) {
            isDefault = true;
          }
        }
        if (!isDefault) {
          line += ";VALUE=" + valueType.toUpperCase();
        }
        line += ":";
        if (multiValue && structuredValue) {
          line += stringify.multiValue(
            property[3],
            structuredValue,
            valueType,
            multiValue,
            designSet,
            structuredValue
          );
        } else if (multiValue) {
          line += stringify.multiValue(
            property.slice(3),
            multiValue,
            valueType,
            null,
            designSet,
            false
          );
        } else if (structuredValue) {
          line += stringify.multiValue(
            property[3],
            structuredValue,
            valueType,
            null,
            designSet,
            structuredValue
          );
        } else {
          line += stringify.value(property[3], valueType, designSet, false);
        }
        return noFold ? line : ICAL2.helpers.foldline(line);
      };
      stringify.propertyValue = function(value) {
        if (helpers.unescapedIndexOf(value, ",") === -1 && helpers.unescapedIndexOf(value, ":") === -1 && helpers.unescapedIndexOf(value, ";") === -1) {
          return value;
        }
        return '"' + value + '"';
      };
      stringify.multiValue = function(values, delim, type, innerMulti, designSet, structuredValue) {
        var result = "";
        var len = values.length;
        var i3 = 0;
        for (; i3 < len; i3++) {
          if (innerMulti && Array.isArray(values[i3])) {
            result += stringify.multiValue(values[i3], innerMulti, type, null, designSet, structuredValue);
          } else {
            result += stringify.value(values[i3], type, designSet, structuredValue);
          }
          if (i3 !== len - 1) {
            result += delim;
          }
        }
        return result;
      };
      stringify.value = function(value, type, designSet, structuredValue) {
        if (type in designSet.value && "toICAL" in designSet.value[type]) {
          return designSet.value[type].toICAL(value, structuredValue);
        }
        return value;
      };
      stringify._rfc6868Unescape = function(val) {
        return val.replace(/[\n^"]/g, function(x4) {
          return RFC6868_REPLACE_MAP[x4];
        });
      };
      var RFC6868_REPLACE_MAP = { '"': "^'", "\n": "^n", "^": "^^" };
      return stringify;
    }();
    ICAL2.parse = function() {
      "use strict";
      var CHAR = /[^ \t]/;
      var MULTIVALUE_DELIMITER = ",";
      var VALUE_DELIMITER = ":";
      var PARAM_DELIMITER = ";";
      var PARAM_NAME_DELIMITER = "=";
      var DEFAULT_VALUE_TYPE = "unknown";
      var DEFAULT_PARAM_TYPE = "text";
      var design = ICAL2.design;
      var helpers = ICAL2.helpers;
      function ParserError(message) {
        this.message = message;
        this.name = "ParserError";
        try {
          throw new Error();
        } catch (e3) {
          if (e3.stack) {
            var split2 = e3.stack.split("\n");
            split2.shift();
            this.stack = split2.join("\n");
          }
        }
      }
      ParserError.prototype = Error.prototype;
      function parser(input) {
        var state = {};
        var root = state.component = [];
        state.stack = [root];
        parser._eachLine(input, function(err, line) {
          parser._handleContentLine(line, state);
        });
        if (state.stack.length > 1) {
          throw new ParserError(
            "invalid ical body. component began but did not end"
          );
        }
        state = null;
        return root.length == 1 ? root[0] : root;
      }
      parser.property = function(str, designSet) {
        var state = {
          component: [[], []],
          designSet: designSet || design.defaultSet
        };
        parser._handleContentLine(str, state);
        return state.component[1][0];
      };
      parser.component = function(str) {
        return parser(str);
      };
      parser.ParserError = ParserError;
      parser._handleContentLine = function(line, state) {
        var valuePos = line.indexOf(VALUE_DELIMITER);
        var paramPos = line.indexOf(PARAM_DELIMITER);
        var lastParamIndex;
        var lastValuePos;
        var name;
        var value;
        var params = {};
        if (paramPos !== -1 && valuePos !== -1) {
          if (paramPos > valuePos) {
            paramPos = -1;
          }
        }
        var parsedParams;
        if (paramPos !== -1) {
          name = line.substring(0, paramPos).toLowerCase();
          parsedParams = parser._parseParameters(line.substring(paramPos), 0, state.designSet);
          if (parsedParams[2] == -1) {
            throw new ParserError("Invalid parameters in '" + line + "'");
          }
          params = parsedParams[0];
          lastParamIndex = parsedParams[1].length + parsedParams[2] + paramPos;
          if ((lastValuePos = line.substring(lastParamIndex).indexOf(VALUE_DELIMITER)) !== -1) {
            value = line.substring(lastParamIndex + lastValuePos + 1);
          } else {
            throw new ParserError("Missing parameter value in '" + line + "'");
          }
        } else if (valuePos !== -1) {
          name = line.substring(0, valuePos).toLowerCase();
          value = line.substring(valuePos + 1);
          if (name === "begin") {
            var newComponent = [value.toLowerCase(), [], []];
            if (state.stack.length === 1) {
              state.component.push(newComponent);
            } else {
              state.component[2].push(newComponent);
            }
            state.stack.push(state.component);
            state.component = newComponent;
            if (!state.designSet) {
              state.designSet = design.getDesignSet(state.component[0]);
            }
            return;
          } else if (name === "end") {
            state.component = state.stack.pop();
            return;
          }
        } else {
          throw new ParserError(
            'invalid line (no token ";" or ":") "' + line + '"'
          );
        }
        var valueType;
        var multiValue = false;
        var structuredValue = false;
        var propertyDetails;
        if (name in state.designSet.property) {
          propertyDetails = state.designSet.property[name];
          if ("multiValue" in propertyDetails) {
            multiValue = propertyDetails.multiValue;
          }
          if ("structuredValue" in propertyDetails) {
            structuredValue = propertyDetails.structuredValue;
          }
          if (value && "detectType" in propertyDetails) {
            valueType = propertyDetails.detectType(value);
          }
        }
        if (!valueType) {
          if (!("value" in params)) {
            if (propertyDetails) {
              valueType = propertyDetails.defaultType;
            } else {
              valueType = DEFAULT_VALUE_TYPE;
            }
          } else {
            valueType = params.value.toLowerCase();
          }
        }
        delete params.value;
        var result;
        if (multiValue && structuredValue) {
          value = parser._parseMultiValue(value, structuredValue, valueType, [], multiValue, state.designSet, structuredValue);
          result = [name, params, valueType, value];
        } else if (multiValue) {
          result = [name, params, valueType];
          parser._parseMultiValue(value, multiValue, valueType, result, null, state.designSet, false);
        } else if (structuredValue) {
          value = parser._parseMultiValue(value, structuredValue, valueType, [], null, state.designSet, structuredValue);
          result = [name, params, valueType, value];
        } else {
          value = parser._parseValue(value, valueType, state.designSet, false);
          result = [name, params, valueType, value];
        }
        if (state.component[0] === "vcard" && state.component[1].length === 0 && !(name === "version" && value === "4.0")) {
          state.designSet = design.getDesignSet("vcard3");
        }
        state.component[1].push(result);
      };
      parser._parseValue = function(value, type, designSet, structuredValue) {
        if (type in designSet.value && "fromICAL" in designSet.value[type]) {
          return designSet.value[type].fromICAL(value, structuredValue);
        }
        return value;
      };
      parser._parseParameters = function(line, start, designSet) {
        var lastParam = start;
        var pos = 0;
        var delim = PARAM_NAME_DELIMITER;
        var result = {};
        var name, lcname;
        var value, valuePos = -1;
        var type, multiValue, mvdelim;
        while (pos !== false && (pos = helpers.unescapedIndexOf(line, delim, pos + 1)) !== -1) {
          name = line.substr(lastParam + 1, pos - lastParam - 1);
          if (name.length == 0) {
            throw new ParserError("Empty parameter name in '" + line + "'");
          }
          lcname = name.toLowerCase();
          mvdelim = false;
          multiValue = false;
          if (lcname in designSet.param && designSet.param[lcname].valueType) {
            type = designSet.param[lcname].valueType;
          } else {
            type = DEFAULT_PARAM_TYPE;
          }
          if (lcname in designSet.param) {
            multiValue = designSet.param[lcname].multiValue;
            if (designSet.param[lcname].multiValueSeparateDQuote) {
              mvdelim = parser._rfc6868Escape('"' + multiValue + '"');
            }
          }
          var nextChar = line[pos + 1];
          if (nextChar === '"') {
            valuePos = pos + 2;
            pos = helpers.unescapedIndexOf(line, '"', valuePos);
            if (multiValue && pos != -1) {
              var extendedValue = true;
              while (extendedValue) {
                if (line[pos + 1] == multiValue && line[pos + 2] == '"') {
                  pos = helpers.unescapedIndexOf(line, '"', pos + 3);
                } else {
                  extendedValue = false;
                }
              }
            }
            if (pos === -1) {
              throw new ParserError(
                'invalid line (no matching double quote) "' + line + '"'
              );
            }
            value = line.substr(valuePos, pos - valuePos);
            lastParam = helpers.unescapedIndexOf(line, PARAM_DELIMITER, pos);
            if (lastParam === -1) {
              pos = false;
            }
          } else {
            valuePos = pos + 1;
            var nextPos = helpers.unescapedIndexOf(line, PARAM_DELIMITER, valuePos);
            var propValuePos = helpers.unescapedIndexOf(line, VALUE_DELIMITER, valuePos);
            if (propValuePos !== -1 && nextPos > propValuePos) {
              nextPos = propValuePos;
              pos = false;
            } else if (nextPos === -1) {
              if (propValuePos === -1) {
                nextPos = line.length;
              } else {
                nextPos = propValuePos;
              }
              pos = false;
            } else {
              lastParam = nextPos;
              pos = nextPos;
            }
            value = line.substr(valuePos, nextPos - valuePos);
          }
          value = parser._rfc6868Escape(value);
          if (multiValue) {
            var delimiter = mvdelim || multiValue;
            value = parser._parseMultiValue(value, delimiter, type, [], null, designSet);
          } else {
            value = parser._parseValue(value, type, designSet);
          }
          if (multiValue && lcname in result) {
            if (Array.isArray(result[lcname])) {
              result[lcname].push(value);
            } else {
              result[lcname] = [
                result[lcname],
                value
              ];
            }
          } else {
            result[lcname] = value;
          }
        }
        return [result, value, valuePos];
      };
      parser._rfc6868Escape = function(val) {
        return val.replace(/\^['n^]/g, function(x4) {
          return RFC6868_REPLACE_MAP[x4];
        });
      };
      var RFC6868_REPLACE_MAP = { "^'": '"', "^n": "\n", "^^": "^" };
      parser._parseMultiValue = function(buffer, delim, type, result, innerMulti, designSet, structuredValue) {
        var pos = 0;
        var lastPos = 0;
        var value;
        if (delim.length === 0) {
          return buffer;
        }
        while ((pos = helpers.unescapedIndexOf(buffer, delim, lastPos)) !== -1) {
          value = buffer.substr(lastPos, pos - lastPos);
          if (innerMulti) {
            value = parser._parseMultiValue(value, innerMulti, type, [], null, designSet, structuredValue);
          } else {
            value = parser._parseValue(value, type, designSet, structuredValue);
          }
          result.push(value);
          lastPos = pos + delim.length;
        }
        value = buffer.substr(lastPos);
        if (innerMulti) {
          value = parser._parseMultiValue(value, innerMulti, type, [], null, designSet, structuredValue);
        } else {
          value = parser._parseValue(value, type, designSet, structuredValue);
        }
        result.push(value);
        return result.length == 1 ? result[0] : result;
      };
      parser._eachLine = function(buffer, callback) {
        var len = buffer.length;
        var lastPos = buffer.search(CHAR);
        var pos = lastPos;
        var line;
        var firstChar;
        var newlineOffset;
        do {
          pos = buffer.indexOf("\n", lastPos) + 1;
          if (pos > 1 && buffer[pos - 2] === "\r") {
            newlineOffset = 2;
          } else {
            newlineOffset = 1;
          }
          if (pos === 0) {
            pos = len;
            newlineOffset = 0;
          }
          firstChar = buffer[lastPos];
          if (firstChar === " " || firstChar === "	") {
            line += buffer.substr(
              lastPos + 1,
              pos - lastPos - (newlineOffset + 1)
            );
          } else {
            if (line)
              callback(null, line);
            line = buffer.substr(
              lastPos,
              pos - lastPos - newlineOffset
            );
          }
          lastPos = pos;
        } while (pos !== len);
        line = line.trim();
        if (line.length)
          callback(null, line);
      };
      return parser;
    }();
    ICAL2.Component = function() {
      "use strict";
      var PROPERTY_INDEX = 1;
      var COMPONENT_INDEX = 2;
      var NAME_INDEX = 0;
      function Component3(jCal, parent) {
        if (typeof jCal === "string") {
          jCal = [jCal, [], []];
        }
        this.jCal = jCal;
        this.parent = parent || null;
      }
      Component3.prototype = {
        /**
         * Hydrated properties are inserted into the _properties array at the same
         * position as in the jCal array, so it is possible that the array contains
         * undefined values for unhydrdated properties. To avoid iterating the
         * array when checking if all properties have been hydrated, we save the
         * count here.
         *
         * @type {Number}
         * @private
         */
        _hydratedPropertyCount: 0,
        /**
         * The same count as for _hydratedPropertyCount, but for subcomponents
         *
         * @type {Number}
         * @private
         */
        _hydratedComponentCount: 0,
        /**
         * The name of this component
         * @readonly
         */
        get name() {
          return this.jCal[NAME_INDEX];
        },
        /**
         * The design set for this component, e.g. icalendar vs vcard
         *
         * @type {ICAL.design.designSet}
         * @private
         */
        get _designSet() {
          var parentDesign = this.parent && this.parent._designSet;
          return parentDesign || ICAL2.design.getDesignSet(this.name);
        },
        _hydrateComponent: function(index8) {
          if (!this._components) {
            this._components = [];
            this._hydratedComponentCount = 0;
          }
          if (this._components[index8]) {
            return this._components[index8];
          }
          var comp = new Component3(
            this.jCal[COMPONENT_INDEX][index8],
            this
          );
          this._hydratedComponentCount++;
          return this._components[index8] = comp;
        },
        _hydrateProperty: function(index8) {
          if (!this._properties) {
            this._properties = [];
            this._hydratedPropertyCount = 0;
          }
          if (this._properties[index8]) {
            return this._properties[index8];
          }
          var prop = new ICAL2.Property(
            this.jCal[PROPERTY_INDEX][index8],
            this
          );
          this._hydratedPropertyCount++;
          return this._properties[index8] = prop;
        },
        /**
         * Finds first sub component, optionally filtered by name.
         *
         * @param {String=} name        Optional name to filter by
         * @return {?ICAL.Component}     The found subcomponent
         */
        getFirstSubcomponent: function(name) {
          if (name) {
            var i3 = 0;
            var comps = this.jCal[COMPONENT_INDEX];
            var len = comps.length;
            for (; i3 < len; i3++) {
              if (comps[i3][NAME_INDEX] === name) {
                var result = this._hydrateComponent(i3);
                return result;
              }
            }
          } else {
            if (this.jCal[COMPONENT_INDEX].length) {
              return this._hydrateComponent(0);
            }
          }
          return null;
        },
        /**
         * Finds all sub components, optionally filtering by name.
         *
         * @param {String=} name            Optional name to filter by
         * @return {ICAL.Component[]}       The found sub components
         */
        getAllSubcomponents: function(name) {
          var jCalLen = this.jCal[COMPONENT_INDEX].length;
          var i3 = 0;
          if (name) {
            var comps = this.jCal[COMPONENT_INDEX];
            var result = [];
            for (; i3 < jCalLen; i3++) {
              if (name === comps[i3][NAME_INDEX]) {
                result.push(
                  this._hydrateComponent(i3)
                );
              }
            }
            return result;
          } else {
            if (!this._components || this._hydratedComponentCount !== jCalLen) {
              for (; i3 < jCalLen; i3++) {
                this._hydrateComponent(i3);
              }
            }
            return this._components || [];
          }
        },
        /**
         * Returns true when a named property exists.
         *
         * @param {String} name     The property name
         * @return {Boolean}        True, when property is found
         */
        hasProperty: function(name) {
          var props = this.jCal[PROPERTY_INDEX];
          var len = props.length;
          var i3 = 0;
          for (; i3 < len; i3++) {
            if (props[i3][NAME_INDEX] === name) {
              return true;
            }
          }
          return false;
        },
        /**
         * Finds the first property, optionally with the given name.
         *
         * @param {String=} name        Lowercase property name
         * @return {?ICAL.Property}     The found property
         */
        getFirstProperty: function(name) {
          if (name) {
            var i3 = 0;
            var props = this.jCal[PROPERTY_INDEX];
            var len = props.length;
            for (; i3 < len; i3++) {
              if (props[i3][NAME_INDEX] === name) {
                var result = this._hydrateProperty(i3);
                return result;
              }
            }
          } else {
            if (this.jCal[PROPERTY_INDEX].length) {
              return this._hydrateProperty(0);
            }
          }
          return null;
        },
        /**
         * Returns first property's value, if available.
         *
         * @param {String=} name    Lowercase property name
         * @return {?String}        The found property value.
         */
        getFirstPropertyValue: function(name) {
          var prop = this.getFirstProperty(name);
          if (prop) {
            return prop.getFirstValue();
          }
          return null;
        },
        /**
         * Get all properties in the component, optionally filtered by name.
         *
         * @param {String=} name        Lowercase property name
         * @return {ICAL.Property[]}    List of properties
         */
        getAllProperties: function(name) {
          var jCalLen = this.jCal[PROPERTY_INDEX].length;
          var i3 = 0;
          if (name) {
            var props = this.jCal[PROPERTY_INDEX];
            var result = [];
            for (; i3 < jCalLen; i3++) {
              if (name === props[i3][NAME_INDEX]) {
                result.push(
                  this._hydrateProperty(i3)
                );
              }
            }
            return result;
          } else {
            if (!this._properties || this._hydratedPropertyCount !== jCalLen) {
              for (; i3 < jCalLen; i3++) {
                this._hydrateProperty(i3);
              }
            }
            return this._properties || [];
          }
        },
        _removeObjectByIndex: function(jCalIndex, cache, index8) {
          cache = cache || [];
          if (cache[index8]) {
            var obj = cache[index8];
            if ("parent" in obj) {
              obj.parent = null;
            }
          }
          cache.splice(index8, 1);
          this.jCal[jCalIndex].splice(index8, 1);
        },
        _removeObject: function(jCalIndex, cache, nameOrObject) {
          var i3 = 0;
          var objects = this.jCal[jCalIndex];
          var len = objects.length;
          var cached = this[cache];
          if (typeof nameOrObject === "string") {
            for (; i3 < len; i3++) {
              if (objects[i3][NAME_INDEX] === nameOrObject) {
                this._removeObjectByIndex(jCalIndex, cached, i3);
                return true;
              }
            }
          } else if (cached) {
            for (; i3 < len; i3++) {
              if (cached[i3] && cached[i3] === nameOrObject) {
                this._removeObjectByIndex(jCalIndex, cached, i3);
                return true;
              }
            }
          }
          return false;
        },
        _removeAllObjects: function(jCalIndex, cache, name) {
          var cached = this[cache];
          var objects = this.jCal[jCalIndex];
          var i3 = objects.length - 1;
          for (; i3 >= 0; i3--) {
            if (!name || objects[i3][NAME_INDEX] === name) {
              this._removeObjectByIndex(jCalIndex, cached, i3);
            }
          }
        },
        /**
         * Adds a single sub component.
         *
         * @param {ICAL.Component} component        The component to add
         * @return {ICAL.Component}                 The passed in component
         */
        addSubcomponent: function(component) {
          if (!this._components) {
            this._components = [];
            this._hydratedComponentCount = 0;
          }
          if (component.parent) {
            component.parent.removeSubcomponent(component);
          }
          var idx = this.jCal[COMPONENT_INDEX].push(component.jCal);
          this._components[idx - 1] = component;
          this._hydratedComponentCount++;
          component.parent = this;
          return component;
        },
        /**
         * Removes a single component by name or the instance of a specific
         * component.
         *
         * @param {ICAL.Component|String} nameOrComp    Name of component, or component
         * @return {Boolean}                            True when comp is removed
         */
        removeSubcomponent: function(nameOrComp) {
          var removed = this._removeObject(COMPONENT_INDEX, "_components", nameOrComp);
          if (removed) {
            this._hydratedComponentCount--;
          }
          return removed;
        },
        /**
         * Removes all components or (if given) all components by a particular
         * name.
         *
         * @param {String=} name            Lowercase component name
         */
        removeAllSubcomponents: function(name) {
          var removed = this._removeAllObjects(COMPONENT_INDEX, "_components", name);
          this._hydratedComponentCount = 0;
          return removed;
        },
        /**
         * Adds an {@link ICAL.Property} to the component.
         *
         * @param {ICAL.Property} property      The property to add
         * @return {ICAL.Property}              The passed in property
         */
        addProperty: function(property) {
          if (!(property instanceof ICAL2.Property)) {
            throw new TypeError("must instance of ICAL.Property");
          }
          if (!this._properties) {
            this._properties = [];
            this._hydratedPropertyCount = 0;
          }
          if (property.parent) {
            property.parent.removeProperty(property);
          }
          var idx = this.jCal[PROPERTY_INDEX].push(property.jCal);
          this._properties[idx - 1] = property;
          this._hydratedPropertyCount++;
          property.parent = this;
          return property;
        },
        /**
         * Helper method to add a property with a value to the component.
         *
         * @param {String}               name         Property name to add
         * @param {String|Number|Object} value        Property value
         * @return {ICAL.Property}                    The created property
         */
        addPropertyWithValue: function(name, value) {
          var prop = new ICAL2.Property(name);
          prop.setValue(value);
          this.addProperty(prop);
          return prop;
        },
        /**
         * Helper method that will update or create a property of the given name
         * and sets its value. If multiple properties with the given name exist,
         * only the first is updated.
         *
         * @param {String}               name         Property name to update
         * @param {String|Number|Object} value        Property value
         * @return {ICAL.Property}                    The created property
         */
        updatePropertyWithValue: function(name, value) {
          var prop = this.getFirstProperty(name);
          if (prop) {
            prop.setValue(value);
          } else {
            prop = this.addPropertyWithValue(name, value);
          }
          return prop;
        },
        /**
         * Removes a single property by name or the instance of the specific
         * property.
         *
         * @param {String|ICAL.Property} nameOrProp     Property name or instance to remove
         * @return {Boolean}                            True, when deleted
         */
        removeProperty: function(nameOrProp) {
          var removed = this._removeObject(PROPERTY_INDEX, "_properties", nameOrProp);
          if (removed) {
            this._hydratedPropertyCount--;
          }
          return removed;
        },
        /**
         * Removes all properties associated with this component, optionally
         * filtered by name.
         *
         * @param {String=} name        Lowercase property name
         * @return {Boolean}            True, when deleted
         */
        removeAllProperties: function(name) {
          var removed = this._removeAllObjects(PROPERTY_INDEX, "_properties", name);
          this._hydratedPropertyCount = 0;
          return removed;
        },
        /**
         * Returns the Object representation of this component. The returned object
         * is a live jCal object and should be cloned if modified.
         * @return {Object}
         */
        toJSON: function() {
          return this.jCal;
        },
        /**
         * The string representation of this component.
         * @return {String}
         */
        toString: function() {
          return ICAL2.stringify.component(
            this.jCal,
            this._designSet
          );
        }
      };
      Component3.fromString = function(str) {
        return new Component3(ICAL2.parse.component(str));
      };
      return Component3;
    }();
    ICAL2.Property = function() {
      "use strict";
      var NAME_INDEX = 0;
      var PROP_INDEX = 1;
      var TYPE_INDEX = 2;
      var VALUE_INDEX = 3;
      var design = ICAL2.design;
      function Property(jCal, parent) {
        this._parent = parent || null;
        if (typeof jCal === "string") {
          this.jCal = [jCal, {}, design.defaultType];
          this.jCal[TYPE_INDEX] = this.getDefaultType();
        } else {
          this.jCal = jCal;
        }
        this._updateType();
      }
      Property.prototype = {
        /**
         * The value type for this property
         * @readonly
         * @type {String}
         */
        get type() {
          return this.jCal[TYPE_INDEX];
        },
        /**
         * The name of this property, in lowercase.
         * @readonly
         * @type {String}
         */
        get name() {
          return this.jCal[NAME_INDEX];
        },
        /**
         * The parent component for this property.
         * @type {ICAL.Component}
         */
        get parent() {
          return this._parent;
        },
        set parent(p3) {
          var designSetChanged = !this._parent || p3 && p3._designSet != this._parent._designSet;
          this._parent = p3;
          if (this.type == design.defaultType && designSetChanged) {
            this.jCal[TYPE_INDEX] = this.getDefaultType();
            this._updateType();
          }
          return p3;
        },
        /**
         * The design set for this property, e.g. icalendar vs vcard
         *
         * @type {ICAL.design.designSet}
         * @private
         */
        get _designSet() {
          return this.parent ? this.parent._designSet : design.defaultSet;
        },
        /**
         * Updates the type metadata from the current jCal type and design set.
         *
         * @private
         */
        _updateType: function() {
          var designSet = this._designSet;
          if (this.type in designSet.value) {
            var designType = designSet.value[this.type];
            if ("decorate" in designSet.value[this.type]) {
              this.isDecorated = true;
            } else {
              this.isDecorated = false;
            }
            if (this.name in designSet.property) {
              this.isMultiValue = "multiValue" in designSet.property[this.name];
              this.isStructuredValue = "structuredValue" in designSet.property[this.name];
            }
          }
        },
        /**
         * Hydrate a single value. The act of hydrating means turning the raw jCal
         * value into a potentially wrapped object, for example {@link ICAL.Time}.
         *
         * @private
         * @param {Number} index        The index of the value to hydrate
         * @return {Object}             The decorated value.
         */
        _hydrateValue: function(index8) {
          if (this._values && this._values[index8]) {
            return this._values[index8];
          }
          if (this.jCal.length <= VALUE_INDEX + index8) {
            return null;
          }
          if (this.isDecorated) {
            if (!this._values) {
              this._values = [];
            }
            return this._values[index8] = this._decorate(
              this.jCal[VALUE_INDEX + index8]
            );
          } else {
            return this.jCal[VALUE_INDEX + index8];
          }
        },
        /**
         * Decorate a single value, returning its wrapped object. This is used by
         * the hydrate function to actually wrap the value.
         *
         * @private
         * @param {?} value         The value to decorate
         * @return {Object}         The decorated value
         */
        _decorate: function(value) {
          return this._designSet.value[this.type].decorate(value, this);
        },
        /**
         * Undecorate a single value, returning its raw jCal data.
         *
         * @private
         * @param {Object} value         The value to undecorate
         * @return {?}                   The undecorated value
         */
        _undecorate: function(value) {
          return this._designSet.value[this.type].undecorate(value, this);
        },
        /**
         * Sets the value at the given index while also hydrating it. The passed
         * value can either be a decorated or undecorated value.
         *
         * @private
         * @param {?} value             The value to set
         * @param {Number} index        The index to set it at
         */
        _setDecoratedValue: function(value, index8) {
          if (!this._values) {
            this._values = [];
          }
          if (typeof value === "object" && "icaltype" in value) {
            this.jCal[VALUE_INDEX + index8] = this._undecorate(value);
            this._values[index8] = value;
          } else {
            this.jCal[VALUE_INDEX + index8] = value;
            this._values[index8] = this._decorate(value);
          }
        },
        /**
         * Gets a parameter on the property.
         *
         * @param {String}        name   Parameter name (lowercase)
         * @return {Array|String}        Parameter value
         */
        getParameter: function(name) {
          if (name in this.jCal[PROP_INDEX]) {
            return this.jCal[PROP_INDEX][name];
          } else {
            return void 0;
          }
        },
        /**
         * Gets first parameter on the property.
         *
         * @param {String}        name   Parameter name (lowercase)
         * @return {String}        Parameter value
         */
        getFirstParameter: function(name) {
          var parameters = this.getParameter(name);
          if (Array.isArray(parameters)) {
            return parameters[0];
          }
          return parameters;
        },
        /**
         * Sets a parameter on the property.
         *
         * @param {String}       name     The parameter name
         * @param {Array|String} value    The parameter value
         */
        setParameter: function(name, value) {
          var lcname = name.toLowerCase();
          if (typeof value === "string" && lcname in this._designSet.param && "multiValue" in this._designSet.param[lcname]) {
            value = [value];
          }
          this.jCal[PROP_INDEX][name] = value;
        },
        /**
         * Removes a parameter
         *
         * @param {String} name     The parameter name
         */
        removeParameter: function(name) {
          delete this.jCal[PROP_INDEX][name];
        },
        /**
         * Get the default type based on this property's name.
         *
         * @return {String}     The default type for this property
         */
        getDefaultType: function() {
          var name = this.jCal[NAME_INDEX];
          var designSet = this._designSet;
          if (name in designSet.property) {
            var details = designSet.property[name];
            if ("defaultType" in details) {
              return details.defaultType;
            }
          }
          return design.defaultType;
        },
        /**
         * Sets type of property and clears out any existing values of the current
         * type.
         *
         * @param {String} type     New iCAL type (see design.*.values)
         */
        resetType: function(type) {
          this.removeAllValues();
          this.jCal[TYPE_INDEX] = type;
          this._updateType();
        },
        /**
         * Finds the first property value.
         *
         * @return {String}         First property value
         */
        getFirstValue: function() {
          return this._hydrateValue(0);
        },
        /**
         * Gets all values on the property.
         *
         * NOTE: this creates an array during each call.
         *
         * @return {Array}          List of values
         */
        getValues: function() {
          var len = this.jCal.length - VALUE_INDEX;
          if (len < 1) {
            return [];
          }
          var i3 = 0;
          var result = [];
          for (; i3 < len; i3++) {
            result[i3] = this._hydrateValue(i3);
          }
          return result;
        },
        /**
         * Removes all values from this property
         */
        removeAllValues: function() {
          if (this._values) {
            this._values.length = 0;
          }
          this.jCal.length = 3;
        },
        /**
         * Sets the values of the property.  Will overwrite the existing values.
         * This can only be used for multi-value properties.
         *
         * @param {Array} values    An array of values
         */
        setValues: function(values) {
          if (!this.isMultiValue) {
            throw new Error(
              this.name + ": does not not support mulitValue.\noverride isMultiValue"
            );
          }
          var len = values.length;
          var i3 = 0;
          this.removeAllValues();
          if (len > 0 && typeof values[0] === "object" && "icaltype" in values[0]) {
            this.resetType(values[0].icaltype);
          }
          if (this.isDecorated) {
            for (; i3 < len; i3++) {
              this._setDecoratedValue(values[i3], i3);
            }
          } else {
            for (; i3 < len; i3++) {
              this.jCal[VALUE_INDEX + i3] = values[i3];
            }
          }
        },
        /**
         * Sets the current value of the property. If this is a multi-value
         * property, all other values will be removed.
         *
         * @param {String|Object} value     New property value.
         */
        setValue: function(value) {
          this.removeAllValues();
          if (typeof value === "object" && "icaltype" in value) {
            this.resetType(value.icaltype);
          }
          if (this.isDecorated) {
            this._setDecoratedValue(value, 0);
          } else {
            this.jCal[VALUE_INDEX] = value;
          }
        },
        /**
         * Returns the Object representation of this component. The returned object
         * is a live jCal object and should be cloned if modified.
         * @return {Object}
         */
        toJSON: function() {
          return this.jCal;
        },
        /**
         * The string representation of this component.
         * @return {String}
         */
        toICALString: function() {
          return ICAL2.stringify.property(
            this.jCal,
            this._designSet,
            true
          );
        }
      };
      Property.fromString = function(str, designSet) {
        return new Property(ICAL2.parse.property(str, designSet));
      };
      return Property;
    }();
    ICAL2.UtcOffset = function() {
      function UtcOffset(aData) {
        this.fromData(aData);
      }
      UtcOffset.prototype = {
        /**
         * The hours in the utc-offset
         * @type {Number}
         */
        hours: 0,
        /**
         * The minutes in the utc-offset
         * @type {Number}
         */
        minutes: 0,
        /**
         * The sign of the utc offset, 1 for positive offset, -1 for negative
         * offsets.
         * @type {Number}
         */
        factor: 1,
        /**
         * The type name, to be used in the jCal object.
         * @constant
         * @type {String}
         * @default "utc-offset"
         */
        icaltype: "utc-offset",
        /**
         * Returns a clone of the utc offset object.
         *
         * @return {ICAL.UtcOffset}     The cloned object
         */
        clone: function() {
          return ICAL2.UtcOffset.fromSeconds(this.toSeconds());
        },
        /**
         * Sets up the current instance using members from the passed data object.
         *
         * @param {Object} aData          An object with members of the utc offset
         * @param {Number=} aData.hours   The hours for the utc offset
         * @param {Number=} aData.minutes The minutes in the utc offset
         * @param {Number=} aData.factor  The factor for the utc-offset, either -1 or 1
         */
        fromData: function(aData) {
          if (aData) {
            for (var key in aData) {
              if (aData.hasOwnProperty(key)) {
                this[key] = aData[key];
              }
            }
          }
          this._normalize();
        },
        /**
         * Sets up the current instance from the given seconds value. The seconds
         * value is truncated to the minute. Offsets are wrapped when the world
         * ends, the hour after UTC+14:00 is UTC-12:00.
         *
         * @param {Number} aSeconds         The seconds to convert into an offset
         */
        fromSeconds: function(aSeconds) {
          var secs = Math.abs(aSeconds);
          this.factor = aSeconds < 0 ? -1 : 1;
          this.hours = ICAL2.helpers.trunc(secs / 3600);
          secs -= this.hours * 3600;
          this.minutes = ICAL2.helpers.trunc(secs / 60);
          return this;
        },
        /**
         * Convert the current offset to a value in seconds
         *
         * @return {Number}                 The offset in seconds
         */
        toSeconds: function() {
          return this.factor * (60 * this.minutes + 3600 * this.hours);
        },
        /**
         * Compare this utc offset with another one.
         *
         * @param {ICAL.UtcOffset} other        The other offset to compare with
         * @return {Number}                     -1, 0 or 1 for less/equal/greater
         */
        compare: function icaltime_compare(other) {
          var a3 = this.toSeconds();
          var b3 = other.toSeconds();
          return (a3 > b3) - (b3 > a3);
        },
        _normalize: function() {
          var secs = this.toSeconds();
          var factor = this.factor;
          while (secs < -43200) {
            secs += 97200;
          }
          while (secs > 50400) {
            secs -= 97200;
          }
          this.fromSeconds(secs);
          if (secs == 0) {
            this.factor = factor;
          }
        },
        /**
         * The iCalendar string representation of this utc-offset.
         * @return {String}
         */
        toICALString: function() {
          return ICAL2.design.icalendar.value["utc-offset"].toICAL(this.toString());
        },
        /**
         * The string representation of this utc-offset.
         * @return {String}
         */
        toString: function toString() {
          return (this.factor == 1 ? "+" : "-") + ICAL2.helpers.pad2(this.hours) + ":" + ICAL2.helpers.pad2(this.minutes);
        }
      };
      UtcOffset.fromString = function(aString) {
        var options = {};
        options.factor = aString[0] === "+" ? 1 : -1;
        options.hours = ICAL2.helpers.strictParseInt(aString.substr(1, 2));
        options.minutes = ICAL2.helpers.strictParseInt(aString.substr(4, 2));
        return new ICAL2.UtcOffset(options);
      };
      UtcOffset.fromSeconds = function(aSeconds) {
        var instance = new UtcOffset();
        instance.fromSeconds(aSeconds);
        return instance;
      };
      return UtcOffset;
    }();
    ICAL2.Binary = function() {
      function Binary(aValue) {
        this.value = aValue;
      }
      Binary.prototype = {
        /**
         * The type name, to be used in the jCal object.
         * @default "binary"
         * @constant
         */
        icaltype: "binary",
        /**
         * Base64 decode the current value
         *
         * @return {String}         The base64-decoded value
         */
        decodeValue: function decodeValue() {
          return this._b64_decode(this.value);
        },
        /**
         * Encodes the passed parameter with base64 and sets the internal
         * value to the result.
         *
         * @param {String} aValue      The raw binary value to encode
         */
        setEncodedValue: function setEncodedValue(aValue) {
          this.value = this._b64_encode(aValue);
        },
        _b64_encode: function base64_encode(data) {
          var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
          var o1, o2, o3, h1, h22, h3, h4, bits, i3 = 0, ac = 0, enc = "", tmp_arr = [];
          if (!data) {
            return data;
          }
          do {
            o1 = data.charCodeAt(i3++);
            o2 = data.charCodeAt(i3++);
            o3 = data.charCodeAt(i3++);
            bits = o1 << 16 | o2 << 8 | o3;
            h1 = bits >> 18 & 63;
            h22 = bits >> 12 & 63;
            h3 = bits >> 6 & 63;
            h4 = bits & 63;
            tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h22) + b64.charAt(h3) + b64.charAt(h4);
          } while (i3 < data.length);
          enc = tmp_arr.join("");
          var r3 = data.length % 3;
          return (r3 ? enc.slice(0, r3 - 3) : enc) + "===".slice(r3 || 3);
        },
        _b64_decode: function base64_decode(data) {
          var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
          var o1, o2, o3, h1, h22, h3, h4, bits, i3 = 0, ac = 0, dec = "", tmp_arr = [];
          if (!data) {
            return data;
          }
          data += "";
          do {
            h1 = b64.indexOf(data.charAt(i3++));
            h22 = b64.indexOf(data.charAt(i3++));
            h3 = b64.indexOf(data.charAt(i3++));
            h4 = b64.indexOf(data.charAt(i3++));
            bits = h1 << 18 | h22 << 12 | h3 << 6 | h4;
            o1 = bits >> 16 & 255;
            o2 = bits >> 8 & 255;
            o3 = bits & 255;
            if (h3 == 64) {
              tmp_arr[ac++] = String.fromCharCode(o1);
            } else if (h4 == 64) {
              tmp_arr[ac++] = String.fromCharCode(o1, o2);
            } else {
              tmp_arr[ac++] = String.fromCharCode(o1, o2, o3);
            }
          } while (i3 < data.length);
          dec = tmp_arr.join("");
          return dec;
        },
        /**
         * The string representation of this value
         * @return {String}
         */
        toString: function() {
          return this.value;
        }
      };
      Binary.fromString = function(aString) {
        return new Binary(aString);
      };
      return Binary;
    }();
    (function() {
      ICAL2.Period = function icalperiod(aData) {
        this.wrappedJSObject = this;
        if (aData && "start" in aData) {
          if (aData.start && !(aData.start instanceof ICAL2.Time)) {
            throw new TypeError(".start must be an instance of ICAL.Time");
          }
          this.start = aData.start;
        }
        if (aData && aData.end && aData.duration) {
          throw new Error("cannot accept both end and duration");
        }
        if (aData && "end" in aData) {
          if (aData.end && !(aData.end instanceof ICAL2.Time)) {
            throw new TypeError(".end must be an instance of ICAL.Time");
          }
          this.end = aData.end;
        }
        if (aData && "duration" in aData) {
          if (aData.duration && !(aData.duration instanceof ICAL2.Duration)) {
            throw new TypeError(".duration must be an instance of ICAL.Duration");
          }
          this.duration = aData.duration;
        }
      };
      ICAL2.Period.prototype = {
        /**
         * The start of the period
         * @type {ICAL.Time}
         */
        start: null,
        /**
         * The end of the period
         * @type {ICAL.Time}
         */
        end: null,
        /**
         * The duration of the period
         * @type {ICAL.Duration}
         */
        duration: null,
        /**
         * The class identifier.
         * @constant
         * @type {String}
         * @default "icalperiod"
         */
        icalclass: "icalperiod",
        /**
         * The type name, to be used in the jCal object.
         * @constant
         * @type {String}
         * @default "period"
         */
        icaltype: "period",
        /**
         * Returns a clone of the duration object.
         *
         * @return {ICAL.Period}      The cloned object
         */
        clone: function() {
          return ICAL2.Period.fromData({
            start: this.start ? this.start.clone() : null,
            end: this.end ? this.end.clone() : null,
            duration: this.duration ? this.duration.clone() : null
          });
        },
        /**
         * Calculates the duration of the period, either directly or by subtracting
         * start from end date.
         *
         * @return {ICAL.Duration}      The calculated duration
         */
        getDuration: function duration() {
          if (this.duration) {
            return this.duration;
          } else {
            return this.end.subtractDate(this.start);
          }
        },
        /**
         * Calculates the end date of the period, either directly or by adding
         * duration to start date.
         *
         * @return {ICAL.Time}          The calculated end date
         */
        getEnd: function() {
          if (this.end) {
            return this.end;
          } else {
            var end = this.start.clone();
            end.addDuration(this.duration);
            return end;
          }
        },
        /**
         * The string representation of this period.
         * @return {String}
         */
        toString: function toString() {
          return this.start + "/" + (this.end || this.duration);
        },
        /**
         * The jCal representation of this period type.
         * @return {Object}
         */
        toJSON: function() {
          return [this.start.toString(), (this.end || this.duration).toString()];
        },
        /**
         * The iCalendar string representation of this period.
         * @return {String}
         */
        toICALString: function() {
          return this.start.toICALString() + "/" + (this.end || this.duration).toICALString();
        }
      };
      ICAL2.Period.fromString = function fromString(str, prop) {
        var parts = str.split("/");
        if (parts.length !== 2) {
          throw new Error(
            'Invalid string value: "' + str + '" must contain a "/" char.'
          );
        }
        var options = {
          start: ICAL2.Time.fromDateTimeString(parts[0], prop)
        };
        var end = parts[1];
        if (ICAL2.Duration.isValueString(end)) {
          options.duration = ICAL2.Duration.fromString(end);
        } else {
          options.end = ICAL2.Time.fromDateTimeString(end, prop);
        }
        return new ICAL2.Period(options);
      };
      ICAL2.Period.fromData = function fromData(aData) {
        return new ICAL2.Period(aData);
      };
      ICAL2.Period.fromJSON = function(aData, aProp, aLenient) {
        function fromDateOrDateTimeString(aValue, aProp2) {
          if (aLenient) {
            return ICAL2.Time.fromString(aValue, aProp2);
          } else {
            return ICAL2.Time.fromDateTimeString(aValue, aProp2);
          }
        }
        if (ICAL2.Duration.isValueString(aData[1])) {
          return ICAL2.Period.fromData({
            start: fromDateOrDateTimeString(aData[0], aProp),
            duration: ICAL2.Duration.fromString(aData[1])
          });
        } else {
          return ICAL2.Period.fromData({
            start: fromDateOrDateTimeString(aData[0], aProp),
            end: fromDateOrDateTimeString(aData[1], aProp)
          });
        }
      };
    })();
    (function() {
      var DURATION_LETTERS = /([PDWHMTS]{1,1})/;
      ICAL2.Duration = function icalduration(data) {
        this.wrappedJSObject = this;
        this.fromData(data);
      };
      ICAL2.Duration.prototype = {
        /**
         * The weeks in this duration
         * @type {Number}
         * @default 0
         */
        weeks: 0,
        /**
         * The days in this duration
         * @type {Number}
         * @default 0
         */
        days: 0,
        /**
         * The days in this duration
         * @type {Number}
         * @default 0
         */
        hours: 0,
        /**
         * The minutes in this duration
         * @type {Number}
         * @default 0
         */
        minutes: 0,
        /**
         * The seconds in this duration
         * @type {Number}
         * @default 0
         */
        seconds: 0,
        /**
         * The seconds in this duration
         * @type {Boolean}
         * @default false
         */
        isNegative: false,
        /**
         * The class identifier.
         * @constant
         * @type {String}
         * @default "icalduration"
         */
        icalclass: "icalduration",
        /**
         * The type name, to be used in the jCal object.
         * @constant
         * @type {String}
         * @default "duration"
         */
        icaltype: "duration",
        /**
         * Returns a clone of the duration object.
         *
         * @return {ICAL.Duration}      The cloned object
         */
        clone: function clone2() {
          return ICAL2.Duration.fromData(this);
        },
        /**
         * The duration value expressed as a number of seconds.
         *
         * @return {Number}             The duration value in seconds
         */
        toSeconds: function toSeconds() {
          var seconds = this.seconds + 60 * this.minutes + 3600 * this.hours + 86400 * this.days + 7 * 86400 * this.weeks;
          return this.isNegative ? -seconds : seconds;
        },
        /**
         * Reads the passed seconds value into this duration object. Afterwards,
         * members like {@link ICAL.Duration#days days} and {@link ICAL.Duration#weeks weeks} will be set up
         * accordingly.
         *
         * @param {Number} aSeconds     The duration value in seconds
         * @return {ICAL.Duration}      Returns this instance
         */
        fromSeconds: function fromSeconds(aSeconds) {
          var secs = Math.abs(aSeconds);
          this.isNegative = aSeconds < 0;
          this.days = ICAL2.helpers.trunc(secs / 86400);
          if (this.days % 7 == 0) {
            this.weeks = this.days / 7;
            this.days = 0;
          } else {
            this.weeks = 0;
          }
          secs -= (this.days + 7 * this.weeks) * 86400;
          this.hours = ICAL2.helpers.trunc(secs / 3600);
          secs -= this.hours * 3600;
          this.minutes = ICAL2.helpers.trunc(secs / 60);
          secs -= this.minutes * 60;
          this.seconds = secs;
          return this;
        },
        /**
         * Sets up the current instance using members from the passed data object.
         *
         * @param {Object} aData               An object with members of the duration
         * @param {Number} aData.weeks         Duration in weeks
         * @param {Number} aData.days          Duration in days
         * @param {Number} aData.hours         Duration in hours
         * @param {Number} aData.minutes       Duration in minutes
         * @param {Number} aData.seconds       Duration in seconds
         * @param {Boolean} aData.isNegative   If true, the duration is negative
         */
        fromData: function fromData(aData) {
          var propsToCopy = [
            "weeks",
            "days",
            "hours",
            "minutes",
            "seconds",
            "isNegative"
          ];
          for (var key in propsToCopy) {
            if (!propsToCopy.hasOwnProperty(key)) {
              continue;
            }
            var prop = propsToCopy[key];
            if (aData && prop in aData) {
              this[prop] = aData[prop];
            } else {
              this[prop] = 0;
            }
          }
        },
        /**
         * Resets the duration instance to the default values, i.e. PT0S
         */
        reset: function reset() {
          this.isNegative = false;
          this.weeks = 0;
          this.days = 0;
          this.hours = 0;
          this.minutes = 0;
          this.seconds = 0;
        },
        /**
         * Compares the duration instance with another one.
         *
         * @param {ICAL.Duration} aOther        The instance to compare with
         * @return {Number}                     -1, 0 or 1 for less/equal/greater
         */
        compare: function compare(aOther) {
          var thisSeconds = this.toSeconds();
          var otherSeconds = aOther.toSeconds();
          return (thisSeconds > otherSeconds) - (thisSeconds < otherSeconds);
        },
        /**
         * Normalizes the duration instance. For example, a duration with a value
         * of 61 seconds will be normalized to 1 minute and 1 second.
         */
        normalize: function normalize() {
          this.fromSeconds(this.toSeconds());
        },
        /**
         * The string representation of this duration.
         * @return {String}
         */
        toString: function toString() {
          if (this.toSeconds() == 0) {
            return "PT0S";
          } else {
            var str = "";
            if (this.isNegative)
              str += "-";
            str += "P";
            if (this.weeks)
              str += this.weeks + "W";
            if (this.days)
              str += this.days + "D";
            if (this.hours || this.minutes || this.seconds) {
              str += "T";
              if (this.hours)
                str += this.hours + "H";
              if (this.minutes)
                str += this.minutes + "M";
              if (this.seconds)
                str += this.seconds + "S";
            }
            return str;
          }
        },
        /**
         * The iCalendar string representation of this duration.
         * @return {String}
         */
        toICALString: function() {
          return this.toString();
        }
      };
      ICAL2.Duration.fromSeconds = function icalduration_from_seconds(aSeconds) {
        return new ICAL2.Duration().fromSeconds(aSeconds);
      };
      function parseDurationChunk(letter, number, object) {
        var type;
        switch (letter) {
          case "P":
            if (number && number === "-") {
              object.isNegative = true;
            } else {
              object.isNegative = false;
            }
            break;
          case "D":
            type = "days";
            break;
          case "W":
            type = "weeks";
            break;
          case "H":
            type = "hours";
            break;
          case "M":
            type = "minutes";
            break;
          case "S":
            type = "seconds";
            break;
          default:
            return 0;
        }
        if (type) {
          if (!number && number !== 0) {
            throw new Error(
              'invalid duration value: Missing number before "' + letter + '"'
            );
          }
          var num = parseInt(number, 10);
          if (ICAL2.helpers.isStrictlyNaN(num)) {
            throw new Error(
              'invalid duration value: Invalid number "' + number + '" before "' + letter + '"'
            );
          }
          object[type] = num;
        }
        return 1;
      }
      ICAL2.Duration.isValueString = function(string) {
        return string[0] === "P" || string[1] === "P";
      };
      ICAL2.Duration.fromString = function icalduration_from_string(aStr) {
        var pos = 0;
        var dict = /* @__PURE__ */ Object.create(null);
        var chunks = 0;
        while ((pos = aStr.search(DURATION_LETTERS)) !== -1) {
          var type = aStr[pos];
          var numeric = aStr.substr(0, pos);
          aStr = aStr.substr(pos + 1);
          chunks += parseDurationChunk(type, numeric, dict);
        }
        if (chunks < 2) {
          throw new Error(
            'invalid duration value: Not enough duration components in "' + aStr + '"'
          );
        }
        return new ICAL2.Duration(dict);
      };
      ICAL2.Duration.fromData = function icalduration_from_data(aData) {
        return new ICAL2.Duration(aData);
      };
    })();
    (function() {
      var OPTIONS = [
        "tzid",
        "location",
        "tznames",
        "latitude",
        "longitude"
      ];
      ICAL2.Timezone = function icaltimezone(data) {
        this.wrappedJSObject = this;
        this.fromData(data);
      };
      ICAL2.Timezone.prototype = {
        /**
         * Timezone identifier
         * @type {String}
         */
        tzid: "",
        /**
         * Timezone location
         * @type {String}
         */
        location: "",
        /**
         * Alternative timezone name, for the string representation
         * @type {String}
         */
        tznames: "",
        /**
         * The primary latitude for the timezone.
         * @type {Number}
         */
        latitude: 0,
        /**
         * The primary longitude for the timezone.
         * @type {Number}
         */
        longitude: 0,
        /**
         * The vtimezone component for this timezone.
         * @type {ICAL.Component}
         */
        component: null,
        /**
         * The year this timezone has been expanded to. All timezone transition
         * dates until this year are known and can be used for calculation
         *
         * @private
         * @type {Number}
         */
        expandedUntilYear: 0,
        /**
         * The class identifier.
         * @constant
         * @type {String}
         * @default "icaltimezone"
         */
        icalclass: "icaltimezone",
        /**
         * Sets up the current instance using members from the passed data object.
         *
         * @param {ICAL.Component|Object} aData options for class
         * @param {String|ICAL.Component} aData.component
         *        If aData is a simple object, then this member can be set to either a
         *        string containing the component data, or an already parsed
         *        ICAL.Component
         * @param {String} aData.tzid      The timezone identifier
         * @param {String} aData.location  The timezone locationw
         * @param {String} aData.tznames   An alternative string representation of the
         *                                  timezone
         * @param {Number} aData.latitude  The latitude of the timezone
         * @param {Number} aData.longitude The longitude of the timezone
         */
        fromData: function fromData(aData) {
          this.expandedUntilYear = 0;
          this.changes = [];
          if (aData instanceof ICAL2.Component) {
            this.component = aData;
          } else {
            if (aData && "component" in aData) {
              if (typeof aData.component == "string") {
                var jCal = ICAL2.parse(aData.component);
                this.component = new ICAL2.Component(jCal);
              } else if (aData.component instanceof ICAL2.Component) {
                this.component = aData.component;
              } else {
                this.component = null;
              }
            }
            for (var key in OPTIONS) {
              if (OPTIONS.hasOwnProperty(key)) {
                var prop = OPTIONS[key];
                if (aData && prop in aData) {
                  this[prop] = aData[prop];
                }
              }
            }
          }
          if (this.component instanceof ICAL2.Component && !this.tzid) {
            this.tzid = this.component.getFirstPropertyValue("tzid");
          }
          return this;
        },
        /**
         * Finds the utcOffset the given time would occur in this timezone.
         *
         * @param {ICAL.Time} tt        The time to check for
         * @return {Number} utc offset in seconds
         */
        utcOffset: function utcOffset(tt) {
          if (this == ICAL2.Timezone.utcTimezone || this == ICAL2.Timezone.localTimezone) {
            return 0;
          }
          this._ensureCoverage(tt.year);
          if (!this.changes.length) {
            return 0;
          }
          var tt_change = {
            year: tt.year,
            month: tt.month,
            day: tt.day,
            hour: tt.hour,
            minute: tt.minute,
            second: tt.second
          };
          var change_num = this._findNearbyChange(tt_change);
          var change_num_to_use = -1;
          var step = 1;
          for (; ; ) {
            var change = ICAL2.helpers.clone(this.changes[change_num], true);
            if (change.utcOffset < change.prevUtcOffset) {
              ICAL2.Timezone.adjust_change(change, 0, 0, 0, change.utcOffset);
            } else {
              ICAL2.Timezone.adjust_change(
                change,
                0,
                0,
                0,
                change.prevUtcOffset
              );
            }
            var cmp = ICAL2.Timezone._compare_change_fn(tt_change, change);
            if (cmp >= 0) {
              change_num_to_use = change_num;
            } else {
              step = -1;
            }
            if (step == -1 && change_num_to_use != -1) {
              break;
            }
            change_num += step;
            if (change_num < 0) {
              return 0;
            }
            if (change_num >= this.changes.length) {
              break;
            }
          }
          var zone_change = this.changes[change_num_to_use];
          var utcOffset_change = zone_change.utcOffset - zone_change.prevUtcOffset;
          if (utcOffset_change < 0 && change_num_to_use > 0) {
            var tmp_change = ICAL2.helpers.clone(zone_change, true);
            ICAL2.Timezone.adjust_change(
              tmp_change,
              0,
              0,
              0,
              tmp_change.prevUtcOffset
            );
            if (ICAL2.Timezone._compare_change_fn(tt_change, tmp_change) < 0) {
              var prev_zone_change = this.changes[change_num_to_use - 1];
              var want_daylight = false;
              if (zone_change.is_daylight != want_daylight && prev_zone_change.is_daylight == want_daylight) {
                zone_change = prev_zone_change;
              }
            }
          }
          return zone_change.utcOffset;
        },
        _findNearbyChange: function icaltimezone_find_nearby_change(change) {
          var idx = ICAL2.helpers.binsearchInsert(
            this.changes,
            change,
            ICAL2.Timezone._compare_change_fn
          );
          if (idx >= this.changes.length) {
            return this.changes.length - 1;
          }
          return idx;
        },
        _ensureCoverage: function(aYear) {
          if (ICAL2.Timezone._minimumExpansionYear == -1) {
            var today = ICAL2.Time.now();
            ICAL2.Timezone._minimumExpansionYear = today.year;
          }
          var changesEndYear = aYear;
          if (changesEndYear < ICAL2.Timezone._minimumExpansionYear) {
            changesEndYear = ICAL2.Timezone._minimumExpansionYear;
          }
          changesEndYear += ICAL2.Timezone.EXTRA_COVERAGE;
          if (changesEndYear > ICAL2.Timezone.MAX_YEAR) {
            changesEndYear = ICAL2.Timezone.MAX_YEAR;
          }
          if (!this.changes.length || this.expandedUntilYear < aYear) {
            var subcomps = this.component.getAllSubcomponents();
            var compLen = subcomps.length;
            var compIdx = 0;
            for (; compIdx < compLen; compIdx++) {
              this._expandComponent(
                subcomps[compIdx],
                changesEndYear,
                this.changes
              );
            }
            this.changes.sort(ICAL2.Timezone._compare_change_fn);
            this.expandedUntilYear = changesEndYear;
          }
        },
        _expandComponent: function(aComponent, aYear, changes) {
          if (!aComponent.hasProperty("dtstart") || !aComponent.hasProperty("tzoffsetto") || !aComponent.hasProperty("tzoffsetfrom")) {
            return null;
          }
          var dtstart = aComponent.getFirstProperty("dtstart").getFirstValue();
          var change;
          function convert_tzoffset(offset) {
            return offset.factor * (offset.hours * 3600 + offset.minutes * 60);
          }
          function init_changes() {
            var changebase = {};
            changebase.is_daylight = aComponent.name == "daylight";
            changebase.utcOffset = convert_tzoffset(
              aComponent.getFirstProperty("tzoffsetto").getFirstValue()
            );
            changebase.prevUtcOffset = convert_tzoffset(
              aComponent.getFirstProperty("tzoffsetfrom").getFirstValue()
            );
            return changebase;
          }
          if (!aComponent.hasProperty("rrule") && !aComponent.hasProperty("rdate")) {
            change = init_changes();
            change.year = dtstart.year;
            change.month = dtstart.month;
            change.day = dtstart.day;
            change.hour = dtstart.hour;
            change.minute = dtstart.minute;
            change.second = dtstart.second;
            ICAL2.Timezone.adjust_change(
              change,
              0,
              0,
              0,
              -change.prevUtcOffset
            );
            changes.push(change);
          } else {
            var props = aComponent.getAllProperties("rdate");
            for (var rdatekey in props) {
              if (!props.hasOwnProperty(rdatekey)) {
                continue;
              }
              var rdate = props[rdatekey];
              var time = rdate.getFirstValue();
              change = init_changes();
              change.year = time.year;
              change.month = time.month;
              change.day = time.day;
              if (time.isDate) {
                change.hour = dtstart.hour;
                change.minute = dtstart.minute;
                change.second = dtstart.second;
                if (dtstart.zone != ICAL2.Timezone.utcTimezone) {
                  ICAL2.Timezone.adjust_change(
                    change,
                    0,
                    0,
                    0,
                    -change.prevUtcOffset
                  );
                }
              } else {
                change.hour = time.hour;
                change.minute = time.minute;
                change.second = time.second;
                if (time.zone != ICAL2.Timezone.utcTimezone) {
                  ICAL2.Timezone.adjust_change(
                    change,
                    0,
                    0,
                    0,
                    -change.prevUtcOffset
                  );
                }
              }
              changes.push(change);
            }
            var rrule = aComponent.getFirstProperty("rrule");
            if (rrule) {
              rrule = rrule.getFirstValue();
              change = init_changes();
              if (rrule.until && rrule.until.zone == ICAL2.Timezone.utcTimezone) {
                rrule.until.adjust(0, 0, 0, change.prevUtcOffset);
                rrule.until.zone = ICAL2.Timezone.localTimezone;
              }
              var iterator = rrule.iterator(dtstart);
              var occ;
              while (occ = iterator.next()) {
                change = init_changes();
                if (occ.year > aYear || !occ) {
                  break;
                }
                change.year = occ.year;
                change.month = occ.month;
                change.day = occ.day;
                change.hour = occ.hour;
                change.minute = occ.minute;
                change.second = occ.second;
                change.isDate = occ.isDate;
                ICAL2.Timezone.adjust_change(
                  change,
                  0,
                  0,
                  0,
                  -change.prevUtcOffset
                );
                changes.push(change);
              }
            }
          }
          return changes;
        },
        /**
         * The string representation of this timezone.
         * @return {String}
         */
        toString: function toString() {
          return this.tznames ? this.tznames : this.tzid;
        }
      };
      ICAL2.Timezone._compare_change_fn = function icaltimezone_compare_change_fn(a3, b3) {
        if (a3.year < b3.year)
          return -1;
        else if (a3.year > b3.year)
          return 1;
        if (a3.month < b3.month)
          return -1;
        else if (a3.month > b3.month)
          return 1;
        if (a3.day < b3.day)
          return -1;
        else if (a3.day > b3.day)
          return 1;
        if (a3.hour < b3.hour)
          return -1;
        else if (a3.hour > b3.hour)
          return 1;
        if (a3.minute < b3.minute)
          return -1;
        else if (a3.minute > b3.minute)
          return 1;
        if (a3.second < b3.second)
          return -1;
        else if (a3.second > b3.second)
          return 1;
        return 0;
      };
      ICAL2.Timezone.convert_time = function icaltimezone_convert_time(tt, from_zone, to_zone) {
        if (tt.isDate || from_zone.tzid == to_zone.tzid || from_zone == ICAL2.Timezone.localTimezone || to_zone == ICAL2.Timezone.localTimezone) {
          tt.zone = to_zone;
          return tt;
        }
        var utcOffset = from_zone.utcOffset(tt);
        tt.adjust(0, 0, 0, -utcOffset);
        utcOffset = to_zone.utcOffset(tt);
        tt.adjust(0, 0, 0, utcOffset);
        return null;
      };
      ICAL2.Timezone.fromData = function icaltimezone_fromData(aData) {
        var tt = new ICAL2.Timezone();
        return tt.fromData(aData);
      };
      ICAL2.Timezone.utcTimezone = ICAL2.Timezone.fromData({
        tzid: "UTC"
      });
      ICAL2.Timezone.localTimezone = ICAL2.Timezone.fromData({
        tzid: "floating"
      });
      ICAL2.Timezone.adjust_change = function icaltimezone_adjust_change(change, days, hours, minutes, seconds) {
        return ICAL2.Time.prototype.adjust.call(
          change,
          days,
          hours,
          minutes,
          seconds,
          change
        );
      };
      ICAL2.Timezone._minimumExpansionYear = -1;
      ICAL2.Timezone.MAX_YEAR = 2035;
      ICAL2.Timezone.EXTRA_COVERAGE = 5;
    })();
    ICAL2.TimezoneService = function() {
      var zones;
      var TimezoneService = {
        get count() {
          return Object.keys(zones).length;
        },
        reset: function() {
          zones = /* @__PURE__ */ Object.create(null);
          var utc = ICAL2.Timezone.utcTimezone;
          zones.Z = utc;
          zones.UTC = utc;
          zones.GMT = utc;
        },
        /**
         * Checks if timezone id has been registered.
         *
         * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)
         * @return {Boolean}        False, when not present
         */
        has: function(tzid) {
          return !!zones[tzid];
        },
        /**
         * Returns a timezone by its tzid if present.
         *
         * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)
         * @return {?ICAL.Timezone} The timezone, or null if not found
         */
        get: function(tzid) {
          return zones[tzid];
        },
        /**
         * Registers a timezone object or component.
         *
         * @param {String=} name
         *        The name of the timezone. Defaults to the component's TZID if not
         *        passed.
         * @param {ICAL.Component|ICAL.Timezone} zone
         *        The initialized zone or vtimezone.
         */
        register: function(name, timezone) {
          if (name instanceof ICAL2.Component) {
            if (name.name === "vtimezone") {
              timezone = new ICAL2.Timezone(name);
              name = timezone.tzid;
            }
          }
          if (timezone instanceof ICAL2.Timezone) {
            zones[name] = timezone;
          } else {
            throw new TypeError("timezone must be ICAL.Timezone or ICAL.Component");
          }
        },
        /**
         * Removes a timezone by its tzid from the list.
         *
         * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)
         * @return {?ICAL.Timezone} The removed timezone, or null if not registered
         */
        remove: function(tzid) {
          return delete zones[tzid];
        }
      };
      TimezoneService.reset();
      return TimezoneService;
    }();
    (function() {
      ICAL2.Time = function icaltime(data, zone) {
        this.wrappedJSObject = this;
        var time = this._time = /* @__PURE__ */ Object.create(null);
        time.year = 0;
        time.month = 1;
        time.day = 1;
        time.hour = 0;
        time.minute = 0;
        time.second = 0;
        time.isDate = false;
        this.fromData(data, zone);
      };
      ICAL2.Time._dowCache = {};
      ICAL2.Time._wnCache = {};
      ICAL2.Time.prototype = {
        /**
         * The class identifier.
         * @constant
         * @type {String}
         * @default "icaltime"
         */
        icalclass: "icaltime",
        _cachedUnixTime: null,
        /**
         * The type name, to be used in the jCal object. This value may change and
         * is strictly defined by the {@link ICAL.Time#isDate isDate} member.
         * @readonly
         * @type {String}
         * @default "date-time"
         */
        get icaltype() {
          return this.isDate ? "date" : "date-time";
        },
        /**
         * The timezone for this time.
         * @type {ICAL.Timezone}
         */
        zone: null,
        /**
         * Internal uses to indicate that a change has been made and the next read
         * operation must attempt to normalize the value (for example changing the
         * day to 33).
         *
         * @type {Boolean}
         * @private
         */
        _pendingNormalization: false,
        /**
         * Returns a clone of the time object.
         *
         * @return {ICAL.Time}              The cloned object
         */
        clone: function() {
          return new ICAL2.Time(this._time, this.zone);
        },
        /**
         * Reset the time instance to epoch time
         */
        reset: function icaltime_reset() {
          this.fromData(ICAL2.Time.epochTime);
          this.zone = ICAL2.Timezone.utcTimezone;
        },
        /**
         * Reset the time instance to the given date/time values.
         *
         * @param {Number} year             The year to set
         * @param {Number} month            The month to set
         * @param {Number} day              The day to set
         * @param {Number} hour             The hour to set
         * @param {Number} minute           The minute to set
         * @param {Number} second           The second to set
         * @param {ICAL.Timezone} timezone  The timezone to set
         */
        resetTo: function icaltime_resetTo(year, month, day, hour, minute, second, timezone) {
          this.fromData({
            year,
            month,
            day,
            hour,
            minute,
            second,
            zone: timezone
          });
        },
        /**
         * Set up the current instance from the Javascript date value.
         *
         * @param {?Date} aDate     The Javascript Date to read, or null to reset
         * @param {Boolean} useUTC  If true, the UTC values of the date will be used
         */
        fromJSDate: function icaltime_fromJSDate(aDate, useUTC) {
          if (!aDate) {
            this.reset();
          } else {
            if (useUTC) {
              this.zone = ICAL2.Timezone.utcTimezone;
              this.year = aDate.getUTCFullYear();
              this.month = aDate.getUTCMonth() + 1;
              this.day = aDate.getUTCDate();
              this.hour = aDate.getUTCHours();
              this.minute = aDate.getUTCMinutes();
              this.second = aDate.getUTCSeconds();
            } else {
              this.zone = ICAL2.Timezone.localTimezone;
              this.year = aDate.getFullYear();
              this.month = aDate.getMonth() + 1;
              this.day = aDate.getDate();
              this.hour = aDate.getHours();
              this.minute = aDate.getMinutes();
              this.second = aDate.getSeconds();
            }
          }
          this._cachedUnixTime = null;
          return this;
        },
        /**
         * Sets up the current instance using members from the passed data object.
         *
         * @param {Object} aData            Time initialization
         * @param {Number=} aData.year      The year for this date
         * @param {Number=} aData.month     The month for this date
         * @param {Number=} aData.day       The day for this date
         * @param {Number=} aData.hour      The hour for this date
         * @param {Number=} aData.minute    The minute for this date
         * @param {Number=} aData.second    The second for this date
         * @param {Boolean=} aData.isDate   If true, the instance represents a date
         *                                    (as opposed to a date-time)
         * @param {ICAL.Timezone=} aZone    Timezone this position occurs in
         */
        fromData: function fromData(aData, aZone) {
          if (aData) {
            for (var key in aData) {
              if (Object.prototype.hasOwnProperty.call(aData, key)) {
                if (key === "icaltype")
                  continue;
                this[key] = aData[key];
              }
            }
          }
          if (aZone) {
            this.zone = aZone;
          }
          if (aData && !("isDate" in aData)) {
            this.isDate = !("hour" in aData);
          } else if (aData && "isDate" in aData) {
            this.isDate = aData.isDate;
          }
          if (aData && "timezone" in aData) {
            var zone = ICAL2.TimezoneService.get(
              aData.timezone
            );
            this.zone = zone || ICAL2.Timezone.localTimezone;
          }
          if (aData && "zone" in aData) {
            this.zone = aData.zone;
          }
          if (!this.zone) {
            this.zone = ICAL2.Timezone.localTimezone;
          }
          this._cachedUnixTime = null;
          return this;
        },
        /**
         * Calculate the day of week.
         * @param {ICAL.Time.weekDay=} aWeekStart
         *        The week start weekday, defaults to SUNDAY
         * @return {ICAL.Time.weekDay}
         */
        dayOfWeek: function icaltime_dayOfWeek(aWeekStart) {
          var firstDow = aWeekStart || ICAL2.Time.SUNDAY;
          var dowCacheKey = (this.year << 12) + (this.month << 8) + (this.day << 3) + firstDow;
          if (dowCacheKey in ICAL2.Time._dowCache) {
            return ICAL2.Time._dowCache[dowCacheKey];
          }
          var q3 = this.day;
          var m3 = this.month + (this.month < 3 ? 12 : 0);
          var Y = this.year - (this.month < 3 ? 1 : 0);
          var h3 = q3 + Y + ICAL2.helpers.trunc((m3 + 1) * 26 / 10) + ICAL2.helpers.trunc(Y / 4);
          if (true) {
            h3 += ICAL2.helpers.trunc(Y / 100) * 6 + ICAL2.helpers.trunc(Y / 400);
          } else {
            h3 += 5;
          }
          h3 = (h3 + 7 - firstDow) % 7 + 1;
          ICAL2.Time._dowCache[dowCacheKey] = h3;
          return h3;
        },
        /**
         * Calculate the day of year.
         * @return {Number}
         */
        dayOfYear: function dayOfYear() {
          var is_leap = ICAL2.Time.isLeapYear(this.year) ? 1 : 0;
          var diypm = ICAL2.Time.daysInYearPassedMonth;
          return diypm[is_leap][this.month - 1] + this.day;
        },
        /**
         * Returns a copy of the current date/time, rewound to the start of the
         * week. The resulting ICAL.Time instance is of icaltype date, even if this
         * is a date-time.
         *
         * @param {ICAL.Time.weekDay=} aWeekStart
         *        The week start weekday, defaults to SUNDAY
         * @return {ICAL.Time}      The start of the week (cloned)
         */
        startOfWeek: function startOfWeek(aWeekStart) {
          var firstDow = aWeekStart || ICAL2.Time.SUNDAY;
          var result = this.clone();
          result.day -= (this.dayOfWeek() + 7 - firstDow) % 7;
          result.isDate = true;
          result.hour = 0;
          result.minute = 0;
          result.second = 0;
          return result;
        },
        /**
         * Returns a copy of the current date/time, shifted to the end of the week.
         * The resulting ICAL.Time instance is of icaltype date, even if this is a
         * date-time.
         *
         * @param {ICAL.Time.weekDay=} aWeekStart
         *        The week start weekday, defaults to SUNDAY
         * @return {ICAL.Time}      The end of the week (cloned)
         */
        endOfWeek: function endOfWeek(aWeekStart) {
          var firstDow = aWeekStart || ICAL2.Time.SUNDAY;
          var result = this.clone();
          result.day += (7 - this.dayOfWeek() + firstDow - ICAL2.Time.SUNDAY) % 7;
          result.isDate = true;
          result.hour = 0;
          result.minute = 0;
          result.second = 0;
          return result;
        },
        /**
         * Returns a copy of the current date/time, rewound to the start of the
         * month. The resulting ICAL.Time instance is of icaltype date, even if
         * this is a date-time.
         *
         * @return {ICAL.Time}      The start of the month (cloned)
         */
        startOfMonth: function startOfMonth() {
          var result = this.clone();
          result.day = 1;
          result.isDate = true;
          result.hour = 0;
          result.minute = 0;
          result.second = 0;
          return result;
        },
        /**
         * Returns a copy of the current date/time, shifted to the end of the
         * month.  The resulting ICAL.Time instance is of icaltype date, even if
         * this is a date-time.
         *
         * @return {ICAL.Time}      The end of the month (cloned)
         */
        endOfMonth: function endOfMonth() {
          var result = this.clone();
          result.day = ICAL2.Time.daysInMonth(result.month, result.year);
          result.isDate = true;
          result.hour = 0;
          result.minute = 0;
          result.second = 0;
          return result;
        },
        /**
         * Returns a copy of the current date/time, rewound to the start of the
         * year. The resulting ICAL.Time instance is of icaltype date, even if
         * this is a date-time.
         *
         * @return {ICAL.Time}      The start of the year (cloned)
         */
        startOfYear: function startOfYear() {
          var result = this.clone();
          result.day = 1;
          result.month = 1;
          result.isDate = true;
          result.hour = 0;
          result.minute = 0;
          result.second = 0;
          return result;
        },
        /**
         * Returns a copy of the current date/time, shifted to the end of the
         * year.  The resulting ICAL.Time instance is of icaltype date, even if
         * this is a date-time.
         *
         * @return {ICAL.Time}      The end of the year (cloned)
         */
        endOfYear: function endOfYear() {
          var result = this.clone();
          result.day = 31;
          result.month = 12;
          result.isDate = true;
          result.hour = 0;
          result.minute = 0;
          result.second = 0;
          return result;
        },
        /**
         * First calculates the start of the week, then returns the day of year for
         * this date. If the day falls into the previous year, the day is zero or negative.
         *
         * @param {ICAL.Time.weekDay=} aFirstDayOfWeek
         *        The week start weekday, defaults to SUNDAY
         * @return {Number}     The calculated day of year
         */
        startDoyWeek: function startDoyWeek(aFirstDayOfWeek) {
          var firstDow = aFirstDayOfWeek || ICAL2.Time.SUNDAY;
          var delta = this.dayOfWeek() - firstDow;
          if (delta < 0)
            delta += 7;
          return this.dayOfYear() - delta;
        },
        /**
         * Get the dominical letter for the current year. Letters range from A - G
         * for common years, and AG to GF for leap years.
         *
         * @param {Number} yr           The year to retrieve the letter for
         * @return {String}             The dominical letter.
         */
        getDominicalLetter: function() {
          return ICAL2.Time.getDominicalLetter(this.year);
        },
        /**
         * Finds the nthWeekDay relative to the current month (not day).  The
         * returned value is a day relative the month that this month belongs to so
         * 1 would indicate the first of the month and 40 would indicate a day in
         * the following month.
         *
         * @param {Number} aDayOfWeek   Day of the week see the day name constants
         * @param {Number} aPos         Nth occurrence of a given week day values
         *        of 1 and 0 both indicate the first weekday of that type. aPos may
         *        be either positive or negative
         *
         * @return {Number} numeric value indicating a day relative
         *                   to the current month of this time object
         */
        nthWeekDay: function icaltime_nthWeekDay(aDayOfWeek, aPos) {
          var daysInMonth = ICAL2.Time.daysInMonth(this.month, this.year);
          var weekday;
          var pos = aPos;
          var start = 0;
          var otherDay = this.clone();
          if (pos >= 0) {
            otherDay.day = 1;
            if (pos != 0) {
              pos--;
            }
            start = otherDay.day;
            var startDow = otherDay.dayOfWeek();
            var offset = aDayOfWeek - startDow;
            if (offset < 0)
              offset += 7;
            start += offset;
            start -= aDayOfWeek;
            weekday = aDayOfWeek;
          } else {
            otherDay.day = daysInMonth;
            var endDow = otherDay.dayOfWeek();
            pos++;
            weekday = endDow - aDayOfWeek;
            if (weekday < 0) {
              weekday += 7;
            }
            weekday = daysInMonth - weekday;
          }
          weekday += pos * 7;
          return start + weekday;
        },
        /**
         * Checks if current time is the nth weekday, relative to the current
         * month.  Will always return false when rule resolves outside of current
         * month.
         *
         * @param {ICAL.Time.weekDay} aDayOfWeek       Day of week to check
         * @param {Number} aPos                        Relative position
         * @return {Boolean}                           True, if it is the nth weekday
         */
        isNthWeekDay: function(aDayOfWeek, aPos) {
          var dow = this.dayOfWeek();
          if (aPos === 0 && dow === aDayOfWeek) {
            return true;
          }
          var day = this.nthWeekDay(aDayOfWeek, aPos);
          if (day === this.day) {
            return true;
          }
          return false;
        },
        /**
         * Calculates the ISO 8601 week number. The first week of a year is the
         * week that contains the first Thursday. The year can have 53 weeks, if
         * January 1st is a Friday.
         *
         * Note there are regions where the first week of the year is the one that
         * starts on January 1st, which may offset the week number. Also, if a
         * different week start is specified, this will also affect the week
         * number.
         *
         * @see ICAL.Time.weekOneStarts
         * @param {ICAL.Time.weekDay} aWeekStart        The weekday the week starts with
         * @return {Number}                             The ISO week number
         */
        weekNumber: function weekNumber(aWeekStart) {
          var wnCacheKey = (this.year << 12) + (this.month << 8) + (this.day << 3) + aWeekStart;
          if (wnCacheKey in ICAL2.Time._wnCache) {
            return ICAL2.Time._wnCache[wnCacheKey];
          }
          var week1;
          var dt = this.clone();
          dt.isDate = true;
          var isoyear = this.year;
          if (dt.month == 12 && dt.day > 25) {
            week1 = ICAL2.Time.weekOneStarts(isoyear + 1, aWeekStart);
            if (dt.compare(week1) < 0) {
              week1 = ICAL2.Time.weekOneStarts(isoyear, aWeekStart);
            } else {
              isoyear++;
            }
          } else {
            week1 = ICAL2.Time.weekOneStarts(isoyear, aWeekStart);
            if (dt.compare(week1) < 0) {
              week1 = ICAL2.Time.weekOneStarts(--isoyear, aWeekStart);
            }
          }
          var daysBetween2 = dt.subtractDate(week1).toSeconds() / 86400;
          var answer = ICAL2.helpers.trunc(daysBetween2 / 7) + 1;
          ICAL2.Time._wnCache[wnCacheKey] = answer;
          return answer;
        },
        /**
         * Adds the duration to the current time. The instance is modified in
         * place.
         *
         * @param {ICAL.Duration} aDuration         The duration to add
         */
        addDuration: function icaltime_add(aDuration) {
          var mult = aDuration.isNegative ? -1 : 1;
          var second = this.second;
          var minute = this.minute;
          var hour = this.hour;
          var day = this.day;
          second += mult * aDuration.seconds;
          minute += mult * aDuration.minutes;
          hour += mult * aDuration.hours;
          day += mult * aDuration.days;
          day += mult * 7 * aDuration.weeks;
          this.second = second;
          this.minute = minute;
          this.hour = hour;
          this.day = day;
          this._cachedUnixTime = null;
        },
        /**
         * Subtract the date details (_excluding_ timezone).  Useful for finding
         * the relative difference between two time objects excluding their
         * timezone differences.
         *
         * @param {ICAL.Time} aDate     The date to substract
         * @return {ICAL.Duration}      The difference as a duration
         */
        subtractDate: function icaltime_subtract(aDate) {
          var unixTime = this.toUnixTime() + this.utcOffset();
          var other = aDate.toUnixTime() + aDate.utcOffset();
          return ICAL2.Duration.fromSeconds(unixTime - other);
        },
        /**
         * Subtract the date details, taking timezones into account.
         *
         * @param {ICAL.Time} aDate  The date to subtract
         * @return {ICAL.Duration}  The difference in duration
         */
        subtractDateTz: function icaltime_subtract_abs(aDate) {
          var unixTime = this.toUnixTime();
          var other = aDate.toUnixTime();
          return ICAL2.Duration.fromSeconds(unixTime - other);
        },
        /**
         * Compares the ICAL.Time instance with another one.
         *
         * @param {ICAL.Duration} aOther        The instance to compare with
         * @return {Number}                     -1, 0 or 1 for less/equal/greater
         */
        compare: function icaltime_compare(other) {
          var a3 = this.toUnixTime();
          var b3 = other.toUnixTime();
          if (a3 > b3)
            return 1;
          if (b3 > a3)
            return -1;
          return 0;
        },
        /**
         * Compares only the date part of this instance with another one.
         *
         * @param {ICAL.Duration} other         The instance to compare with
         * @param {ICAL.Timezone} tz            The timezone to compare in
         * @return {Number}                     -1, 0 or 1 for less/equal/greater
         */
        compareDateOnlyTz: function icaltime_compareDateOnlyTz(other, tz) {
          function cmp(attr) {
            return ICAL2.Time._cmp_attr(a3, b3, attr);
          }
          var a3 = this.convertToZone(tz);
          var b3 = other.convertToZone(tz);
          var rc = 0;
          if ((rc = cmp("year")) != 0)
            return rc;
          if ((rc = cmp("month")) != 0)
            return rc;
          if ((rc = cmp("day")) != 0)
            return rc;
          return rc;
        },
        /**
         * Convert the instance into another timezone. The returned ICAL.Time
         * instance is always a copy.
         *
         * @param {ICAL.Timezone} zone      The zone to convert to
         * @return {ICAL.Time}              The copy, converted to the zone
         */
        convertToZone: function convertToZone(zone) {
          var copy = this.clone();
          var zone_equals = this.zone.tzid == zone.tzid;
          if (!this.isDate && !zone_equals) {
            ICAL2.Timezone.convert_time(copy, this.zone, zone);
          }
          copy.zone = zone;
          return copy;
        },
        /**
         * Calculates the UTC offset of the current date/time in the timezone it is
         * in.
         *
         * @return {Number}     UTC offset in seconds
         */
        utcOffset: function utc_offset() {
          if (this.zone == ICAL2.Timezone.localTimezone || this.zone == ICAL2.Timezone.utcTimezone) {
            return 0;
          } else {
            return this.zone.utcOffset(this);
          }
        },
        /**
         * Returns an RFC 5545 compliant ical representation of this object.
         *
         * @return {String} ical date/date-time
         */
        toICALString: function() {
          var string = this.toString();
          if (string.length > 10) {
            return ICAL2.design.icalendar.value["date-time"].toICAL(string);
          } else {
            return ICAL2.design.icalendar.value.date.toICAL(string);
          }
        },
        /**
         * The string representation of this date/time, in jCal form
         * (including : and - separators).
         * @return {String}
         */
        toString: function toString() {
          var result = this.year + "-" + ICAL2.helpers.pad2(this.month) + "-" + ICAL2.helpers.pad2(this.day);
          if (!this.isDate) {
            result += "T" + ICAL2.helpers.pad2(this.hour) + ":" + ICAL2.helpers.pad2(this.minute) + ":" + ICAL2.helpers.pad2(this.second);
            if (this.zone === ICAL2.Timezone.utcTimezone) {
              result += "Z";
            }
          }
          return result;
        },
        /**
         * Converts the current instance to a Javascript date
         * @return {Date}
         */
        toJSDate: function toJSDate() {
          if (this.zone == ICAL2.Timezone.localTimezone) {
            if (this.isDate) {
              return new Date(this.year, this.month - 1, this.day);
            } else {
              return new Date(
                this.year,
                this.month - 1,
                this.day,
                this.hour,
                this.minute,
                this.second,
                0
              );
            }
          } else {
            return new Date(this.toUnixTime() * 1e3);
          }
        },
        _normalize: function icaltime_normalize() {
          var isDate2 = this._time.isDate;
          if (this._time.isDate) {
            this._time.hour = 0;
            this._time.minute = 0;
            this._time.second = 0;
          }
          this.adjust(0, 0, 0, 0);
          return this;
        },
        /**
         * Adjust the date/time by the given offset
         *
         * @param {Number} aExtraDays       The extra amount of days
         * @param {Number} aExtraHours      The extra amount of hours
         * @param {Number} aExtraMinutes    The extra amount of minutes
         * @param {Number} aExtraSeconds    The extra amount of seconds
         * @param {Number=} aTime           The time to adjust, defaults to the
         *                                    current instance.
         */
        adjust: function icaltime_adjust(aExtraDays, aExtraHours, aExtraMinutes, aExtraSeconds, aTime) {
          var minutesOverflow, hoursOverflow, daysOverflow = 0, yearsOverflow = 0;
          var second, minute, hour, day;
          var daysInMonth;
          var time = aTime || this._time;
          if (!time.isDate) {
            second = time.second + aExtraSeconds;
            time.second = second % 60;
            minutesOverflow = ICAL2.helpers.trunc(second / 60);
            if (time.second < 0) {
              time.second += 60;
              minutesOverflow--;
            }
            minute = time.minute + aExtraMinutes + minutesOverflow;
            time.minute = minute % 60;
            hoursOverflow = ICAL2.helpers.trunc(minute / 60);
            if (time.minute < 0) {
              time.minute += 60;
              hoursOverflow--;
            }
            hour = time.hour + aExtraHours + hoursOverflow;
            time.hour = hour % 24;
            daysOverflow = ICAL2.helpers.trunc(hour / 24);
            if (time.hour < 0) {
              time.hour += 24;
              daysOverflow--;
            }
          }
          if (time.month > 12) {
            yearsOverflow = ICAL2.helpers.trunc((time.month - 1) / 12);
          } else if (time.month < 1) {
            yearsOverflow = ICAL2.helpers.trunc(time.month / 12) - 1;
          }
          time.year += yearsOverflow;
          time.month -= 12 * yearsOverflow;
          day = time.day + aExtraDays + daysOverflow;
          if (day > 0) {
            for (; ; ) {
              daysInMonth = ICAL2.Time.daysInMonth(time.month, time.year);
              if (day <= daysInMonth) {
                break;
              }
              time.month++;
              if (time.month > 12) {
                time.year++;
                time.month = 1;
              }
              day -= daysInMonth;
            }
          } else {
            while (day <= 0) {
              if (time.month == 1) {
                time.year--;
                time.month = 12;
              } else {
                time.month--;
              }
              day += ICAL2.Time.daysInMonth(time.month, time.year);
            }
          }
          time.day = day;
          this._cachedUnixTime = null;
          return this;
        },
        /**
         * Sets up the current instance from unix time, the number of seconds since
         * January 1st, 1970.
         *
         * @param {Number} seconds      The seconds to set up with
         */
        fromUnixTime: function fromUnixTime(seconds) {
          this.zone = ICAL2.Timezone.utcTimezone;
          var epoch = ICAL2.Time.epochTime.clone();
          epoch.adjust(0, 0, 0, seconds);
          this.year = epoch.year;
          this.month = epoch.month;
          this.day = epoch.day;
          this.hour = epoch.hour;
          this.minute = epoch.minute;
          this.second = Math.floor(epoch.second);
          this._cachedUnixTime = null;
        },
        /**
         * Converts the current instance to seconds since January 1st 1970.
         *
         * @return {Number}         Seconds since 1970
         */
        toUnixTime: function toUnixTime() {
          if (this._cachedUnixTime !== null) {
            return this._cachedUnixTime;
          }
          var offset = this.utcOffset();
          var ms = Date.UTC(
            this.year,
            this.month - 1,
            this.day,
            this.hour,
            this.minute,
            this.second - offset
          );
          this._cachedUnixTime = ms / 1e3;
          return this._cachedUnixTime;
        },
        /**
         * Converts time to into Object which can be serialized then re-created
         * using the constructor.
         *
         * @example
         * // toJSON will automatically be called
         * var json = JSON.stringify(mytime);
         *
         * var deserialized = JSON.parse(json);
         *
         * var time = new ICAL.Time(deserialized);
         *
         * @return {Object}
         */
        toJSON: function() {
          var copy = [
            "year",
            "month",
            "day",
            "hour",
            "minute",
            "second",
            "isDate"
          ];
          var result = /* @__PURE__ */ Object.create(null);
          var i3 = 0;
          var len = copy.length;
          var prop;
          for (; i3 < len; i3++) {
            prop = copy[i3];
            result[prop] = this[prop];
          }
          if (this.zone) {
            result.timezone = this.zone.tzid;
          }
          return result;
        }
      };
      (function setupNormalizeAttributes() {
        function defineAttr(attr) {
          Object.defineProperty(ICAL2.Time.prototype, attr, {
            get: function getTimeAttr() {
              if (this._pendingNormalization) {
                this._normalize();
                this._pendingNormalization = false;
              }
              return this._time[attr];
            },
            set: function setTimeAttr(val) {
              if (attr === "isDate" && val && !this._time.isDate) {
                this.adjust(0, 0, 0, 0);
              }
              this._cachedUnixTime = null;
              this._pendingNormalization = true;
              this._time[attr] = val;
              return val;
            }
          });
        }
        if ("defineProperty" in Object) {
          defineAttr("year");
          defineAttr("month");
          defineAttr("day");
          defineAttr("hour");
          defineAttr("minute");
          defineAttr("second");
          defineAttr("isDate");
        }
      })();
      ICAL2.Time.daysInMonth = function icaltime_daysInMonth(month, year) {
        var _daysInMonth = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        var days = 30;
        if (month < 1 || month > 12)
          return days;
        days = _daysInMonth[month];
        if (month == 2) {
          days += ICAL2.Time.isLeapYear(year);
        }
        return days;
      };
      ICAL2.Time.isLeapYear = function isLeapYear2(year) {
        if (year <= 1752) {
          return year % 4 == 0;
        } else {
          return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
        }
      };
      ICAL2.Time.fromDayOfYear = function icaltime_fromDayOfYear(aDayOfYear, aYear) {
        var year = aYear;
        var doy = aDayOfYear;
        var tt = new ICAL2.Time();
        tt.auto_normalize = false;
        var is_leap = ICAL2.Time.isLeapYear(year) ? 1 : 0;
        if (doy < 1) {
          year--;
          is_leap = ICAL2.Time.isLeapYear(year) ? 1 : 0;
          doy += ICAL2.Time.daysInYearPassedMonth[is_leap][12];
          return ICAL2.Time.fromDayOfYear(doy, year);
        } else if (doy > ICAL2.Time.daysInYearPassedMonth[is_leap][12]) {
          is_leap = ICAL2.Time.isLeapYear(year) ? 1 : 0;
          doy -= ICAL2.Time.daysInYearPassedMonth[is_leap][12];
          year++;
          return ICAL2.Time.fromDayOfYear(doy, year);
        }
        tt.year = year;
        tt.isDate = true;
        for (var month = 11; month >= 0; month--) {
          if (doy > ICAL2.Time.daysInYearPassedMonth[is_leap][month]) {
            tt.month = month + 1;
            tt.day = doy - ICAL2.Time.daysInYearPassedMonth[is_leap][month];
            break;
          }
        }
        tt.auto_normalize = true;
        return tt;
      };
      ICAL2.Time.fromStringv2 = function fromString(str) {
        return new ICAL2.Time({
          year: parseInt(str.substr(0, 4), 10),
          month: parseInt(str.substr(5, 2), 10),
          day: parseInt(str.substr(8, 2), 10),
          isDate: true
        });
      };
      ICAL2.Time.fromDateString = function(aValue) {
        return new ICAL2.Time({
          year: ICAL2.helpers.strictParseInt(aValue.substr(0, 4)),
          month: ICAL2.helpers.strictParseInt(aValue.substr(5, 2)),
          day: ICAL2.helpers.strictParseInt(aValue.substr(8, 2)),
          isDate: true
        });
      };
      ICAL2.Time.fromDateTimeString = function(aValue, prop) {
        if (aValue.length < 19) {
          throw new Error(
            'invalid date-time value: "' + aValue + '"'
          );
        }
        var zone;
        if (aValue[19] && aValue[19] === "Z") {
          zone = "Z";
        } else if (prop) {
          zone = prop.getParameter("tzid");
        }
        var time = new ICAL2.Time({
          year: ICAL2.helpers.strictParseInt(aValue.substr(0, 4)),
          month: ICAL2.helpers.strictParseInt(aValue.substr(5, 2)),
          day: ICAL2.helpers.strictParseInt(aValue.substr(8, 2)),
          hour: ICAL2.helpers.strictParseInt(aValue.substr(11, 2)),
          minute: ICAL2.helpers.strictParseInt(aValue.substr(14, 2)),
          second: ICAL2.helpers.strictParseInt(aValue.substr(17, 2)),
          timezone: zone
        });
        return time;
      };
      ICAL2.Time.fromString = function fromString(aValue, aProperty) {
        if (aValue.length > 10) {
          return ICAL2.Time.fromDateTimeString(aValue, aProperty);
        } else {
          return ICAL2.Time.fromDateString(aValue);
        }
      };
      ICAL2.Time.fromJSDate = function fromJSDate(aDate, useUTC) {
        var tt = new ICAL2.Time();
        return tt.fromJSDate(aDate, useUTC);
      };
      ICAL2.Time.fromData = function fromData(aData, aZone) {
        var t3 = new ICAL2.Time();
        return t3.fromData(aData, aZone);
      };
      ICAL2.Time.now = function icaltime_now() {
        return ICAL2.Time.fromJSDate(new Date(), false);
      };
      ICAL2.Time.weekOneStarts = function weekOneStarts(aYear, aWeekStart) {
        var t3 = ICAL2.Time.fromData({
          year: aYear,
          month: 1,
          day: 1,
          isDate: true
        });
        var dow = t3.dayOfWeek();
        var wkst = aWeekStart || ICAL2.Time.DEFAULT_WEEK_START;
        if (dow > ICAL2.Time.THURSDAY) {
          t3.day += 7;
        }
        if (wkst > ICAL2.Time.THURSDAY) {
          t3.day -= 7;
        }
        t3.day -= dow - wkst;
        return t3;
      };
      ICAL2.Time.getDominicalLetter = function(yr) {
        var LTRS = "GFEDCBA";
        var dom = (yr + (yr / 4 | 0) + (yr / 400 | 0) - (yr / 100 | 0) - 1) % 7;
        var isLeap = ICAL2.Time.isLeapYear(yr);
        if (isLeap) {
          return LTRS[(dom + 6) % 7] + LTRS[dom];
        } else {
          return LTRS[dom];
        }
      };
      ICAL2.Time.epochTime = ICAL2.Time.fromData({
        year: 1970,
        month: 1,
        day: 1,
        hour: 0,
        minute: 0,
        second: 0,
        isDate: false,
        timezone: "Z"
      });
      ICAL2.Time._cmp_attr = function _cmp_attr(a3, b3, attr) {
        if (a3[attr] > b3[attr])
          return 1;
        if (a3[attr] < b3[attr])
          return -1;
        return 0;
      };
      ICAL2.Time.daysInYearPassedMonth = [
        [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365],
        [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366]
      ];
      ICAL2.Time.SUNDAY = 1;
      ICAL2.Time.MONDAY = 2;
      ICAL2.Time.TUESDAY = 3;
      ICAL2.Time.WEDNESDAY = 4;
      ICAL2.Time.THURSDAY = 5;
      ICAL2.Time.FRIDAY = 6;
      ICAL2.Time.SATURDAY = 7;
      ICAL2.Time.DEFAULT_WEEK_START = ICAL2.Time.MONDAY;
    })();
    (function() {
      ICAL2.VCardTime = function(data, zone, icaltype) {
        this.wrappedJSObject = this;
        var time = this._time = /* @__PURE__ */ Object.create(null);
        time.year = null;
        time.month = null;
        time.day = null;
        time.hour = null;
        time.minute = null;
        time.second = null;
        this.icaltype = icaltype || "date-and-or-time";
        this.fromData(data, zone);
      };
      ICAL2.helpers.inherits(
        ICAL2.Time,
        ICAL2.VCardTime,
        /** @lends ICAL.VCardTime */
        {
          /**
           * The class identifier.
           * @constant
           * @type {String}
           * @default "vcardtime"
           */
          icalclass: "vcardtime",
          /**
           * The type name, to be used in the jCal object.
           * @type {String}
           * @default "date-and-or-time"
           */
          icaltype: "date-and-or-time",
          /**
           * The timezone. This can either be floating, UTC, or an instance of
           * ICAL.UtcOffset.
           * @type {ICAL.Timezone|ICAL.UtcOFfset}
           */
          zone: null,
          /**
           * Returns a clone of the vcard date/time object.
           *
           * @return {ICAL.VCardTime}     The cloned object
           */
          clone: function() {
            return new ICAL2.VCardTime(this._time, this.zone, this.icaltype);
          },
          _normalize: function() {
            return this;
          },
          /**
           * @inheritdoc
           */
          utcOffset: function() {
            if (this.zone instanceof ICAL2.UtcOffset) {
              return this.zone.toSeconds();
            } else {
              return ICAL2.Time.prototype.utcOffset.apply(this, arguments);
            }
          },
          /**
           * Returns an RFC 6350 compliant representation of this object.
           *
           * @return {String}         vcard date/time string
           */
          toICALString: function() {
            return ICAL2.design.vcard.value[this.icaltype].toICAL(this.toString());
          },
          /**
           * The string representation of this date/time, in jCard form
           * (including : and - separators).
           * @return {String}
           */
          toString: function toString() {
            var p22 = ICAL2.helpers.pad2;
            var y3 = this.year, m3 = this.month, d2 = this.day;
            var h3 = this.hour, mm = this.minute, s3 = this.second;
            var hasYear = y3 !== null, hasMonth = m3 !== null, hasDay = d2 !== null;
            var hasHour = h3 !== null, hasMinute = mm !== null, hasSecond = s3 !== null;
            var datepart = (hasYear ? p22(y3) + (hasMonth || hasDay ? "-" : "") : hasMonth || hasDay ? "--" : "") + (hasMonth ? p22(m3) : "") + (hasDay ? "-" + p22(d2) : "");
            var timepart = (hasHour ? p22(h3) : "-") + (hasHour && hasMinute ? ":" : "") + (hasMinute ? p22(mm) : "") + (!hasHour && !hasMinute ? "-" : "") + (hasMinute && hasSecond ? ":" : "") + (hasSecond ? p22(s3) : "");
            var zone;
            if (this.zone === ICAL2.Timezone.utcTimezone) {
              zone = "Z";
            } else if (this.zone instanceof ICAL2.UtcOffset) {
              zone = this.zone.toString();
            } else if (this.zone === ICAL2.Timezone.localTimezone) {
              zone = "";
            } else if (this.zone instanceof ICAL2.Timezone) {
              var offset = ICAL2.UtcOffset.fromSeconds(this.zone.utcOffset(this));
              zone = offset.toString();
            } else {
              zone = "";
            }
            switch (this.icaltype) {
              case "time":
                return timepart + zone;
              case "date-and-or-time":
              case "date-time":
                return datepart + (timepart == "--" ? "" : "T" + timepart + zone);
              case "date":
                return datepart;
            }
            return null;
          }
        }
      );
      ICAL2.VCardTime.fromDateAndOrTimeString = function(aValue, aIcalType) {
        function part(v3, s3, e3) {
          return v3 ? ICAL2.helpers.strictParseInt(v3.substr(s3, e3)) : null;
        }
        var parts = aValue.split("T");
        var dt = parts[0], tmz = parts[1];
        var splitzone = tmz ? ICAL2.design.vcard.value.time._splitZone(tmz) : [];
        var zone = splitzone[0], tm = splitzone[1];
        var stoi = ICAL2.helpers.strictParseInt;
        var dtlen = dt ? dt.length : 0;
        var tmlen = tm ? tm.length : 0;
        var hasDashDate = dt && dt[0] == "-" && dt[1] == "-";
        var hasDashTime = tm && tm[0] == "-";
        var o2 = {
          year: hasDashDate ? null : part(dt, 0, 4),
          month: hasDashDate && (dtlen == 4 || dtlen == 7) ? part(dt, 2, 2) : dtlen == 7 ? part(dt, 5, 2) : dtlen == 10 ? part(dt, 5, 2) : null,
          day: dtlen == 5 ? part(dt, 3, 2) : dtlen == 7 && hasDashDate ? part(dt, 5, 2) : dtlen == 10 ? part(dt, 8, 2) : null,
          hour: hasDashTime ? null : part(tm, 0, 2),
          minute: hasDashTime && tmlen == 3 ? part(tm, 1, 2) : tmlen > 4 ? hasDashTime ? part(tm, 1, 2) : part(tm, 3, 2) : null,
          second: tmlen == 4 ? part(tm, 2, 2) : tmlen == 6 ? part(tm, 4, 2) : tmlen == 8 ? part(tm, 6, 2) : null
        };
        if (zone == "Z") {
          zone = ICAL2.Timezone.utcTimezone;
        } else if (zone && zone[3] == ":") {
          zone = ICAL2.UtcOffset.fromString(zone);
        } else {
          zone = null;
        }
        return new ICAL2.VCardTime(o2, zone, aIcalType);
      };
    })();
    (function() {
      var DOW_MAP = {
        SU: ICAL2.Time.SUNDAY,
        MO: ICAL2.Time.MONDAY,
        TU: ICAL2.Time.TUESDAY,
        WE: ICAL2.Time.WEDNESDAY,
        TH: ICAL2.Time.THURSDAY,
        FR: ICAL2.Time.FRIDAY,
        SA: ICAL2.Time.SATURDAY
      };
      var REVERSE_DOW_MAP = {};
      for (var key in DOW_MAP) {
        if (DOW_MAP.hasOwnProperty(key)) {
          REVERSE_DOW_MAP[DOW_MAP[key]] = key;
        }
      }
      var COPY_PARTS = [
        "BYSECOND",
        "BYMINUTE",
        "BYHOUR",
        "BYDAY",
        "BYMONTHDAY",
        "BYYEARDAY",
        "BYWEEKNO",
        "BYMONTH",
        "BYSETPOS"
      ];
      ICAL2.Recur = function icalrecur(data) {
        this.wrappedJSObject = this;
        this.parts = {};
        if (data && typeof data === "object") {
          this.fromData(data);
        }
      };
      ICAL2.Recur.prototype = {
        /**
         * An object holding the BY-parts of the recurrence rule
         * @type {Object}
         */
        parts: null,
        /**
         * The interval value for the recurrence rule.
         * @type {Number}
         */
        interval: 1,
        /**
         * The week start day
         *
         * @type {ICAL.Time.weekDay}
         * @default ICAL.Time.MONDAY
         */
        wkst: ICAL2.Time.MONDAY,
        /**
         * The end of the recurrence
         * @type {?ICAL.Time}
         */
        until: null,
        /**
         * The maximum number of occurrences
         * @type {?Number}
         */
        count: null,
        /**
         * The frequency value.
         * @type {ICAL.Recur.frequencyValues}
         */
        freq: null,
        /**
         * The class identifier.
         * @constant
         * @type {String}
         * @default "icalrecur"
         */
        icalclass: "icalrecur",
        /**
         * The type name, to be used in the jCal object.
         * @constant
         * @type {String}
         * @default "recur"
         */
        icaltype: "recur",
        /**
         * Create a new iterator for this recurrence rule. The passed start date
         * must be the start date of the event, not the start of the range to
         * search in.
         *
         * @example
         * var recur = comp.getFirstPropertyValue('rrule');
         * var dtstart = comp.getFirstPropertyValue('dtstart');
         * var iter = recur.iterator(dtstart);
         * for (var next = iter.next(); next; next = iter.next()) {
         *   if (next.compare(rangeStart) < 0) {
         *     continue;
         *   }
         *   console.log(next.toString());
         * }
         *
         * @param {ICAL.Time} aStart        The item's start date
         * @return {ICAL.RecurIterator}     The recurrence iterator
         */
        iterator: function(aStart) {
          return new ICAL2.RecurIterator({
            rule: this,
            dtstart: aStart
          });
        },
        /**
         * Returns a clone of the recurrence object.
         *
         * @return {ICAL.Recur}      The cloned object
         */
        clone: function clone2() {
          return new ICAL2.Recur(this.toJSON());
        },
        /**
         * Checks if the current rule is finite, i.e. has a count or until part.
         *
         * @return {Boolean}        True, if the rule is finite
         */
        isFinite: function isfinite() {
          return !!(this.count || this.until);
        },
        /**
         * Checks if the current rule has a count part, and not limited by an until
         * part.
         *
         * @return {Boolean}        True, if the rule is by count
         */
        isByCount: function isbycount() {
          return !!(this.count && !this.until);
        },
        /**
         * Adds a component (part) to the recurrence rule. This is not a component
         * in the sense of {@link ICAL.Component}, but a part of the recurrence
         * rule, i.e. BYMONTH.
         *
         * @param {String} aType            The name of the component part
         * @param {Array|String} aValue     The component value
         */
        addComponent: function addPart(aType, aValue) {
          var ucname = aType.toUpperCase();
          if (ucname in this.parts) {
            this.parts[ucname].push(aValue);
          } else {
            this.parts[ucname] = [aValue];
          }
        },
        /**
         * Sets the component value for the given by-part.
         *
         * @param {String} aType        The component part name
         * @param {Array} aValues       The component values
         */
        setComponent: function setComponent(aType, aValues) {
          this.parts[aType.toUpperCase()] = aValues.slice();
        },
        /**
         * Gets (a copy) of the requested component value.
         *
         * @param {String} aType        The component part name
         * @return {Array}              The component part value
         */
        getComponent: function getComponent(aType) {
          var ucname = aType.toUpperCase();
          return ucname in this.parts ? this.parts[ucname].slice() : [];
        },
        /**
         * Retrieves the next occurrence after the given recurrence id. See the
         * guide on {@tutorial terminology} for more details.
         *
         * NOTE: Currently, this method iterates all occurrences from the start
         * date. It should not be called in a loop for performance reasons. If you
         * would like to get more than one occurrence, you can iterate the
         * occurrences manually, see the example on the
         * {@link ICAL.Recur#iterator iterator} method.
         *
         * @param {ICAL.Time} aStartTime        The start of the event series
         * @param {ICAL.Time} aRecurrenceId     The date of the last occurrence
         * @return {ICAL.Time}                  The next occurrence after
         */
        getNextOccurrence: function getNextOccurrence(aStartTime, aRecurrenceId) {
          var iter2 = this.iterator(aStartTime);
          var next, cdt;
          do {
            next = iter2.next();
          } while (next && next.compare(aRecurrenceId) <= 0);
          if (next && aRecurrenceId.zone) {
            next.zone = aRecurrenceId.zone;
          }
          return next;
        },
        /**
         * Sets up the current instance using members from the passed data object.
         *
         * @param {Object} data                               An object with members of the recurrence
         * @param {ICAL.Recur.frequencyValues=} data.freq     The frequency value
         * @param {Number=} data.interval                     The INTERVAL value
         * @param {ICAL.Time.weekDay=} data.wkst              The week start value
         * @param {ICAL.Time=} data.until                     The end of the recurrence set
         * @param {Number=} data.count                        The number of occurrences
         * @param {Array.<Number>=} data.bysecond             The seconds for the BYSECOND part
         * @param {Array.<Number>=} data.byminute             The minutes for the BYMINUTE part
         * @param {Array.<Number>=} data.byhour               The hours for the BYHOUR part
         * @param {Array.<String>=} data.byday                The BYDAY values
         * @param {Array.<Number>=} data.bymonthday           The days for the BYMONTHDAY part
         * @param {Array.<Number>=} data.byyearday            The days for the BYYEARDAY part
         * @param {Array.<Number>=} data.byweekno             The weeks for the BYWEEKNO part
         * @param {Array.<Number>=} data.bymonth              The month for the BYMONTH part
         * @param {Array.<Number>=} data.bysetpos             The positionals for the BYSETPOS part
         */
        fromData: function(data) {
          for (var key2 in data) {
            var uckey = key2.toUpperCase();
            if (uckey in partDesign) {
              if (Array.isArray(data[key2])) {
                this.parts[uckey] = data[key2];
              } else {
                this.parts[uckey] = [data[key2]];
              }
            } else {
              this[key2] = data[key2];
            }
          }
          if (this.interval && typeof this.interval != "number") {
            optionDesign.INTERVAL(this.interval, this);
          }
          if (this.wkst && typeof this.wkst != "number") {
            this.wkst = ICAL2.Recur.icalDayToNumericDay(this.wkst);
          }
          if (this.until && !(this.until instanceof ICAL2.Time)) {
            this.until = ICAL2.Time.fromString(this.until);
          }
        },
        /**
         * The jCal representation of this recurrence type.
         * @return {Object}
         */
        toJSON: function() {
          var res = /* @__PURE__ */ Object.create(null);
          res.freq = this.freq;
          if (this.count) {
            res.count = this.count;
          }
          if (this.interval > 1) {
            res.interval = this.interval;
          }
          for (var k3 in this.parts) {
            if (!this.parts.hasOwnProperty(k3)) {
              continue;
            }
            var kparts = this.parts[k3];
            if (Array.isArray(kparts) && kparts.length == 1) {
              res[k3.toLowerCase()] = kparts[0];
            } else {
              res[k3.toLowerCase()] = ICAL2.helpers.clone(this.parts[k3]);
            }
          }
          if (this.until) {
            res.until = this.until.toString();
          }
          if ("wkst" in this && this.wkst !== ICAL2.Time.DEFAULT_WEEK_START) {
            res.wkst = ICAL2.Recur.numericDayToIcalDay(this.wkst);
          }
          return res;
        },
        /**
         * The string representation of this recurrence rule.
         * @return {String}
         */
        toString: function icalrecur_toString() {
          var str = "FREQ=" + this.freq;
          if (this.count) {
            str += ";COUNT=" + this.count;
          }
          if (this.interval > 1) {
            str += ";INTERVAL=" + this.interval;
          }
          for (var k3 in this.parts) {
            if (this.parts.hasOwnProperty(k3)) {
              str += ";" + k3 + "=" + this.parts[k3];
            }
          }
          if (this.until) {
            str += ";UNTIL=" + this.until.toICALString();
          }
          if ("wkst" in this && this.wkst !== ICAL2.Time.DEFAULT_WEEK_START) {
            str += ";WKST=" + ICAL2.Recur.numericDayToIcalDay(this.wkst);
          }
          return str;
        }
      };
      function parseNumericValue(type, min, max, value) {
        var result = value;
        if (value[0] === "+") {
          result = value.substr(1);
        }
        result = ICAL2.helpers.strictParseInt(result);
        if (min !== void 0 && value < min) {
          throw new Error(
            type + ': invalid value "' + value + '" must be > ' + min
          );
        }
        if (max !== void 0 && value > max) {
          throw new Error(
            type + ': invalid value "' + value + '" must be < ' + min
          );
        }
        return result;
      }
      ICAL2.Recur.icalDayToNumericDay = function toNumericDay(string, aWeekStart) {
        var firstDow = aWeekStart || ICAL2.Time.SUNDAY;
        return (DOW_MAP[string] - firstDow + 7) % 7 + 1;
      };
      ICAL2.Recur.numericDayToIcalDay = function toIcalDay(num, aWeekStart) {
        var firstDow = aWeekStart || ICAL2.Time.SUNDAY;
        var dow = num + firstDow - ICAL2.Time.SUNDAY;
        if (dow > 7) {
          dow -= 7;
        }
        return REVERSE_DOW_MAP[dow];
      };
      var VALID_DAY_NAMES = /^(SU|MO|TU|WE|TH|FR|SA)$/;
      var VALID_BYDAY_PART = /^([+-])?(5[0-3]|[1-4][0-9]|[1-9])?(SU|MO|TU|WE|TH|FR|SA)$/;
      var ALLOWED_FREQ = [
        "SECONDLY",
        "MINUTELY",
        "HOURLY",
        "DAILY",
        "WEEKLY",
        "MONTHLY",
        "YEARLY"
      ];
      var optionDesign = {
        FREQ: function(value, dict, fmtIcal) {
          if (ALLOWED_FREQ.indexOf(value) !== -1) {
            dict.freq = value;
          } else {
            throw new Error(
              'invalid frequency "' + value + '" expected: "' + ALLOWED_FREQ.join(", ") + '"'
            );
          }
        },
        COUNT: function(value, dict, fmtIcal) {
          dict.count = ICAL2.helpers.strictParseInt(value);
        },
        INTERVAL: function(value, dict, fmtIcal) {
          dict.interval = ICAL2.helpers.strictParseInt(value);
          if (dict.interval < 1) {
            dict.interval = 1;
          }
        },
        UNTIL: function(value, dict, fmtIcal) {
          if (value.length > 10) {
            dict.until = ICAL2.design.icalendar.value["date-time"].fromICAL(value);
          } else {
            dict.until = ICAL2.design.icalendar.value.date.fromICAL(value);
          }
          if (!fmtIcal) {
            dict.until = ICAL2.Time.fromString(dict.until);
          }
        },
        WKST: function(value, dict, fmtIcal) {
          if (VALID_DAY_NAMES.test(value)) {
            dict.wkst = ICAL2.Recur.icalDayToNumericDay(value);
          } else {
            throw new Error('invalid WKST value "' + value + '"');
          }
        }
      };
      var partDesign = {
        BYSECOND: parseNumericValue.bind(this, "BYSECOND", 0, 60),
        BYMINUTE: parseNumericValue.bind(this, "BYMINUTE", 0, 59),
        BYHOUR: parseNumericValue.bind(this, "BYHOUR", 0, 23),
        BYDAY: function(value) {
          if (VALID_BYDAY_PART.test(value)) {
            return value;
          } else {
            throw new Error('invalid BYDAY value "' + value + '"');
          }
        },
        BYMONTHDAY: parseNumericValue.bind(this, "BYMONTHDAY", -31, 31),
        BYYEARDAY: parseNumericValue.bind(this, "BYYEARDAY", -366, 366),
        BYWEEKNO: parseNumericValue.bind(this, "BYWEEKNO", -53, 53),
        BYMONTH: parseNumericValue.bind(this, "BYMONTH", 1, 12),
        BYSETPOS: parseNumericValue.bind(this, "BYSETPOS", -366, 366)
      };
      ICAL2.Recur.fromString = function(string) {
        var data = ICAL2.Recur._stringToData(string, false);
        return new ICAL2.Recur(data);
      };
      ICAL2.Recur.fromData = function(aData) {
        return new ICAL2.Recur(aData);
      };
      ICAL2.Recur._stringToData = function(string, fmtIcal) {
        var dict = /* @__PURE__ */ Object.create(null);
        var values = string.split(";");
        var len = values.length;
        for (var i3 = 0; i3 < len; i3++) {
          var parts = values[i3].split("=");
          var ucname = parts[0].toUpperCase();
          var lcname = parts[0].toLowerCase();
          var name = fmtIcal ? lcname : ucname;
          var value = parts[1];
          if (ucname in partDesign) {
            var partArr = value.split(",");
            var partArrIdx = 0;
            var partArrLen = partArr.length;
            for (; partArrIdx < partArrLen; partArrIdx++) {
              partArr[partArrIdx] = partDesign[ucname](partArr[partArrIdx]);
            }
            dict[name] = partArr.length == 1 ? partArr[0] : partArr;
          } else if (ucname in optionDesign) {
            optionDesign[ucname](value, dict, fmtIcal);
          } else {
            dict[lcname] = value;
          }
        }
        return dict;
      };
    })();
    ICAL2.RecurIterator = function() {
      function icalrecur_iterator(options) {
        this.fromData(options);
      }
      icalrecur_iterator.prototype = {
        /**
         * True when iteration is finished.
         * @type {Boolean}
         */
        completed: false,
        /**
         * The rule that is being iterated
         * @type {ICAL.Recur}
         */
        rule: null,
        /**
         * The start date of the event being iterated.
         * @type {ICAL.Time}
         */
        dtstart: null,
        /**
         * The last occurrence that was returned from the
         * {@link ICAL.RecurIterator#next} method.
         * @type {ICAL.Time}
         */
        last: null,
        /**
         * The sequence number from the occurrence
         * @type {Number}
         */
        occurrence_number: 0,
        /**
         * The indices used for the {@link ICAL.RecurIterator#by_data} object.
         * @type {Object}
         * @private
         */
        by_indices: null,
        /**
         * If true, the iterator has already been initialized
         * @type {Boolean}
         * @private
         */
        initialized: false,
        /**
         * The initializd by-data.
         * @type {Object}
         * @private
         */
        by_data: null,
        /**
         * The expanded yeardays
         * @type {Array}
         * @private
         */
        days: null,
        /**
         * The index in the {@link ICAL.RecurIterator#days} array.
         * @type {Number}
         * @private
         */
        days_index: 0,
        /**
         * Initialize the recurrence iterator from the passed data object. This
         * method is usually not called directly, you can initialize the iterator
         * through the constructor.
         *
         * @param {Object} options                The iterator options
         * @param {ICAL.Recur} options.rule       The rule to iterate.
         * @param {ICAL.Time} options.dtstart     The start date of the event.
         * @param {Boolean=} options.initialized  When true, assume that options are
         *        from a previously constructed iterator. Initialization will not be
         *        repeated.
         */
        fromData: function(options) {
          this.rule = ICAL2.helpers.formatClassType(options.rule, ICAL2.Recur);
          if (!this.rule) {
            throw new Error("iterator requires a (ICAL.Recur) rule");
          }
          this.dtstart = ICAL2.helpers.formatClassType(options.dtstart, ICAL2.Time);
          if (!this.dtstart) {
            throw new Error("iterator requires a (ICAL.Time) dtstart");
          }
          if (options.by_data) {
            this.by_data = options.by_data;
          } else {
            this.by_data = ICAL2.helpers.clone(this.rule.parts, true);
          }
          if (options.occurrence_number)
            this.occurrence_number = options.occurrence_number;
          this.days = options.days || [];
          if (options.last) {
            this.last = ICAL2.helpers.formatClassType(options.last, ICAL2.Time);
          }
          this.by_indices = options.by_indices;
          if (!this.by_indices) {
            this.by_indices = {
              "BYSECOND": 0,
              "BYMINUTE": 0,
              "BYHOUR": 0,
              "BYDAY": 0,
              "BYMONTH": 0,
              "BYWEEKNO": 0,
              "BYMONTHDAY": 0
            };
          }
          this.initialized = options.initialized || false;
          if (!this.initialized) {
            this.init();
          }
        },
        /**
         * Intialize the iterator
         * @private
         */
        init: function icalrecur_iterator_init() {
          this.initialized = true;
          this.last = this.dtstart.clone();
          var parts = this.by_data;
          if ("BYDAY" in parts) {
            this.sort_byday_rules(parts.BYDAY);
          }
          if ("BYYEARDAY" in parts) {
            if ("BYMONTH" in parts || "BYWEEKNO" in parts || "BYMONTHDAY" in parts || "BYDAY" in parts) {
              throw new Error("Invalid BYYEARDAY rule");
            }
          }
          if ("BYWEEKNO" in parts && "BYMONTHDAY" in parts) {
            throw new Error("BYWEEKNO does not fit to BYMONTHDAY");
          }
          if (this.rule.freq == "MONTHLY" && ("BYYEARDAY" in parts || "BYWEEKNO" in parts)) {
            throw new Error("For MONTHLY recurrences neither BYYEARDAY nor BYWEEKNO may appear");
          }
          if (this.rule.freq == "WEEKLY" && ("BYYEARDAY" in parts || "BYMONTHDAY" in parts)) {
            throw new Error("For WEEKLY recurrences neither BYMONTHDAY nor BYYEARDAY may appear");
          }
          if (this.rule.freq != "YEARLY" && "BYYEARDAY" in parts) {
            throw new Error("BYYEARDAY may only appear in YEARLY rules");
          }
          this.last.second = this.setup_defaults("BYSECOND", "SECONDLY", this.dtstart.second);
          this.last.minute = this.setup_defaults("BYMINUTE", "MINUTELY", this.dtstart.minute);
          this.last.hour = this.setup_defaults("BYHOUR", "HOURLY", this.dtstart.hour);
          this.last.day = this.setup_defaults("BYMONTHDAY", "DAILY", this.dtstart.day);
          this.last.month = this.setup_defaults("BYMONTH", "MONTHLY", this.dtstart.month);
          if (this.rule.freq == "WEEKLY") {
            if ("BYDAY" in parts) {
              var bydayParts = this.ruleDayOfWeek(parts.BYDAY[0], this.rule.wkst);
              var pos = bydayParts[0];
              var dow = bydayParts[1];
              var wkdy = dow - this.last.dayOfWeek(this.rule.wkst);
              if (this.last.dayOfWeek(this.rule.wkst) < dow && wkdy >= 0 || wkdy < 0) {
                this.last.day += wkdy;
              }
            } else {
              var dayName = ICAL2.Recur.numericDayToIcalDay(this.dtstart.dayOfWeek());
              parts.BYDAY = [dayName];
            }
          }
          if (this.rule.freq == "YEARLY") {
            for (; ; ) {
              this.expand_year_days(this.last.year);
              if (this.days.length > 0) {
                break;
              }
              this.increment_year(this.rule.interval);
            }
            this._nextByYearDay();
          }
          if (this.rule.freq == "MONTHLY" && this.has_by_data("BYDAY")) {
            var tempLast = null;
            var initLast = this.last.clone();
            var daysInMonth = ICAL2.Time.daysInMonth(this.last.month, this.last.year);
            for (var i3 in this.by_data.BYDAY) {
              if (!this.by_data.BYDAY.hasOwnProperty(i3)) {
                continue;
              }
              this.last = initLast.clone();
              var bydayParts = this.ruleDayOfWeek(this.by_data.BYDAY[i3]);
              var pos = bydayParts[0];
              var dow = bydayParts[1];
              var dayOfMonth = this.last.nthWeekDay(dow, pos);
              if (pos >= 6 || pos <= -6) {
                throw new Error("Malformed values in BYDAY part");
              }
              if (dayOfMonth > daysInMonth || dayOfMonth <= 0) {
                if (tempLast && tempLast.month == initLast.month) {
                  continue;
                }
                while (dayOfMonth > daysInMonth || dayOfMonth <= 0) {
                  this.increment_month();
                  daysInMonth = ICAL2.Time.daysInMonth(this.last.month, this.last.year);
                  dayOfMonth = this.last.nthWeekDay(dow, pos);
                }
              }
              this.last.day = dayOfMonth;
              if (!tempLast || this.last.compare(tempLast) < 0) {
                tempLast = this.last.clone();
              }
            }
            this.last = tempLast.clone();
            if (this.has_by_data("BYMONTHDAY")) {
              this._byDayAndMonthDay(true);
            }
            if (this.last.day > daysInMonth || this.last.day == 0) {
              throw new Error("Malformed values in BYDAY part");
            }
          } else if (this.has_by_data("BYMONTHDAY")) {
            if (this.last.day < 0) {
              var daysInMonth = ICAL2.Time.daysInMonth(this.last.month, this.last.year);
              this.last.day = daysInMonth + this.last.day + 1;
            }
          }
        },
        /**
         * Retrieve the next occurrence from the iterator.
         * @return {ICAL.Time}
         */
        next: function icalrecur_iterator_next() {
          var before = this.last ? this.last.clone() : null;
          if (this.rule.count && this.occurrence_number >= this.rule.count || this.rule.until && this.last.compare(this.rule.until) > 0) {
            this.completed = true;
            return null;
          }
          if (this.occurrence_number == 0 && this.last.compare(this.dtstart) >= 0) {
            this.occurrence_number++;
            return this.last;
          }
          var valid;
          do {
            valid = 1;
            switch (this.rule.freq) {
              case "SECONDLY":
                this.next_second();
                break;
              case "MINUTELY":
                this.next_minute();
                break;
              case "HOURLY":
                this.next_hour();
                break;
              case "DAILY":
                this.next_day();
                break;
              case "WEEKLY":
                this.next_week();
                break;
              case "MONTHLY":
                valid = this.next_month();
                break;
              case "YEARLY":
                this.next_year();
                break;
              default:
                return null;
            }
          } while (!this.check_contracting_rules() || this.last.compare(this.dtstart) < 0 || !valid);
          if (this.last.compare(before) == 0) {
            throw new Error("Same occurrence found twice, protecting you from death by recursion");
          }
          if (this.rule.until && this.last.compare(this.rule.until) > 0) {
            this.completed = true;
            return null;
          } else {
            this.occurrence_number++;
            return this.last;
          }
        },
        next_second: function next_second() {
          return this.next_generic("BYSECOND", "SECONDLY", "second", "minute");
        },
        increment_second: function increment_second(inc) {
          return this.increment_generic(inc, "second", 60, "minute");
        },
        next_minute: function next_minute() {
          return this.next_generic(
            "BYMINUTE",
            "MINUTELY",
            "minute",
            "hour",
            "next_second"
          );
        },
        increment_minute: function increment_minute(inc) {
          return this.increment_generic(inc, "minute", 60, "hour");
        },
        next_hour: function next_hour() {
          return this.next_generic(
            "BYHOUR",
            "HOURLY",
            "hour",
            "monthday",
            "next_minute"
          );
        },
        increment_hour: function increment_hour(inc) {
          this.increment_generic(inc, "hour", 24, "monthday");
        },
        next_day: function next_day() {
          var has_by_day = "BYDAY" in this.by_data;
          var this_freq = this.rule.freq == "DAILY";
          if (this.next_hour() == 0) {
            return 0;
          }
          if (this_freq) {
            this.increment_monthday(this.rule.interval);
          } else {
            this.increment_monthday(1);
          }
          return 0;
        },
        next_week: function next_week() {
          var end_of_data = 0;
          if (this.next_weekday_by_week() == 0) {
            return end_of_data;
          }
          if (this.has_by_data("BYWEEKNO")) {
            var idx = ++this.by_indices.BYWEEKNO;
            if (this.by_indices.BYWEEKNO == this.by_data.BYWEEKNO.length) {
              this.by_indices.BYWEEKNO = 0;
              end_of_data = 1;
            }
            this.last.month = 1;
            this.last.day = 1;
            var week_no = this.by_data.BYWEEKNO[this.by_indices.BYWEEKNO];
            this.last.day += 7 * week_no;
            if (end_of_data) {
              this.increment_year(1);
            }
          } else {
            this.increment_monthday(7 * this.rule.interval);
          }
          return end_of_data;
        },
        /**
         * Normalize each by day rule for a given year/month.
         * Takes into account ordering and negative rules
         *
         * @private
         * @param {Number} year         Current year.
         * @param {Number} month        Current month.
         * @param {Array}  rules        Array of rules.
         *
         * @return {Array} sorted and normalized rules.
         *                 Negative rules will be expanded to their
         *                 correct positive values for easier processing.
         */
        normalizeByMonthDayRules: function(year, month, rules) {
          var daysInMonth = ICAL2.Time.daysInMonth(month, year);
          var newRules = [];
          var ruleIdx = 0;
          var len = rules.length;
          var rule;
          for (; ruleIdx < len; ruleIdx++) {
            rule = rules[ruleIdx];
            if (Math.abs(rule) > daysInMonth) {
              continue;
            }
            if (rule < 0) {
              rule = daysInMonth + (rule + 1);
            } else if (rule === 0) {
              continue;
            }
            if (newRules.indexOf(rule) === -1) {
              newRules.push(rule);
            }
          }
          return newRules.sort(function(a3, b3) {
            return a3 - b3;
          });
        },
        /**
         * NOTES:
         * We are given a list of dates in the month (BYMONTHDAY) (23, etc..)
         * Also we are given a list of days (BYDAY) (MO, 2SU, etc..) when
         * both conditions match a given date (this.last.day) iteration stops.
         *
         * @private
         * @param {Boolean=} isInit     When given true will not increment the
         *                                current day (this.last).
         */
        _byDayAndMonthDay: function(isInit) {
          var byMonthDay;
          var byDay = this.by_data.BYDAY;
          var date;
          var dateIdx = 0;
          var dateLen;
          var dayLen = byDay.length;
          var dataIsValid = 0;
          var daysInMonth;
          var self2 = this;
          var lastDay = this.last.day;
          function initMonth() {
            daysInMonth = ICAL2.Time.daysInMonth(
              self2.last.month,
              self2.last.year
            );
            byMonthDay = self2.normalizeByMonthDayRules(
              self2.last.year,
              self2.last.month,
              self2.by_data.BYMONTHDAY
            );
            dateLen = byMonthDay.length;
            while (byMonthDay[dateIdx] <= lastDay && !(isInit && byMonthDay[dateIdx] == lastDay) && dateIdx < dateLen - 1) {
              dateIdx++;
            }
          }
          function nextMonth() {
            lastDay = 0;
            self2.increment_month();
            dateIdx = 0;
            initMonth();
          }
          initMonth();
          if (isInit) {
            lastDay -= 1;
          }
          var monthsCounter = 48;
          while (!dataIsValid && monthsCounter) {
            monthsCounter--;
            date = lastDay + 1;
            if (date > daysInMonth) {
              nextMonth();
              continue;
            }
            var next = byMonthDay[dateIdx++];
            if (next >= date) {
              lastDay = next;
            } else {
              nextMonth();
              continue;
            }
            for (var dayIdx = 0; dayIdx < dayLen; dayIdx++) {
              var parts = this.ruleDayOfWeek(byDay[dayIdx]);
              var pos = parts[0];
              var dow = parts[1];
              this.last.day = lastDay;
              if (this.last.isNthWeekDay(dow, pos)) {
                dataIsValid = 1;
                break;
              }
            }
            if (!dataIsValid && dateIdx === dateLen) {
              nextMonth();
              continue;
            }
          }
          if (monthsCounter <= 0) {
            throw new Error("Malformed values in BYDAY combined with BYMONTHDAY parts");
          }
          return dataIsValid;
        },
        next_month: function next_month() {
          var this_freq = this.rule.freq == "MONTHLY";
          var data_valid = 1;
          if (this.next_hour() == 0) {
            return data_valid;
          }
          if (this.has_by_data("BYDAY") && this.has_by_data("BYMONTHDAY")) {
            data_valid = this._byDayAndMonthDay();
          } else if (this.has_by_data("BYDAY")) {
            var daysInMonth = ICAL2.Time.daysInMonth(this.last.month, this.last.year);
            var setpos = 0;
            var setpos_total = 0;
            if (this.has_by_data("BYSETPOS")) {
              var last_day = this.last.day;
              for (var day = 1; day <= daysInMonth; day++) {
                this.last.day = day;
                if (this.is_day_in_byday(this.last)) {
                  setpos_total++;
                  if (day <= last_day) {
                    setpos++;
                  }
                }
              }
              this.last.day = last_day;
            }
            data_valid = 0;
            for (var day = this.last.day + 1; day <= daysInMonth; day++) {
              this.last.day = day;
              if (this.is_day_in_byday(this.last)) {
                if (!this.has_by_data("BYSETPOS") || this.check_set_position(++setpos) || this.check_set_position(setpos - setpos_total - 1)) {
                  data_valid = 1;
                  break;
                }
              }
            }
            if (day > daysInMonth) {
              this.last.day = 1;
              this.increment_month();
              if (this.is_day_in_byday(this.last)) {
                if (!this.has_by_data("BYSETPOS") || this.check_set_position(1)) {
                  data_valid = 1;
                }
              } else {
                data_valid = 0;
              }
            }
          } else if (this.has_by_data("BYMONTHDAY")) {
            this.by_indices.BYMONTHDAY++;
            if (this.by_indices.BYMONTHDAY >= this.by_data.BYMONTHDAY.length) {
              this.by_indices.BYMONTHDAY = 0;
              this.increment_month();
            }
            var daysInMonth = ICAL2.Time.daysInMonth(this.last.month, this.last.year);
            var day = this.by_data.BYMONTHDAY[this.by_indices.BYMONTHDAY];
            if (day < 0) {
              day = daysInMonth + day + 1;
            }
            if (day > daysInMonth) {
              this.last.day = 1;
              data_valid = this.is_day_in_byday(this.last);
            } else {
              this.last.day = day;
            }
          } else {
            this.increment_month();
            var daysInMonth = ICAL2.Time.daysInMonth(this.last.month, this.last.year);
            if (this.by_data.BYMONTHDAY[0] > daysInMonth) {
              data_valid = 0;
            } else {
              this.last.day = this.by_data.BYMONTHDAY[0];
            }
          }
          return data_valid;
        },
        next_weekday_by_week: function next_weekday_by_week() {
          var end_of_data = 0;
          if (this.next_hour() == 0) {
            return end_of_data;
          }
          if (!this.has_by_data("BYDAY")) {
            return 1;
          }
          for (; ; ) {
            var tt = new ICAL2.Time();
            this.by_indices.BYDAY++;
            if (this.by_indices.BYDAY == Object.keys(this.by_data.BYDAY).length) {
              this.by_indices.BYDAY = 0;
              end_of_data = 1;
            }
            var coded_day = this.by_data.BYDAY[this.by_indices.BYDAY];
            var parts = this.ruleDayOfWeek(coded_day);
            var dow = parts[1];
            dow -= this.rule.wkst;
            if (dow < 0) {
              dow += 7;
            }
            tt.year = this.last.year;
            tt.month = this.last.month;
            tt.day = this.last.day;
            var startOfWeek = tt.startDoyWeek(this.rule.wkst);
            if (dow + startOfWeek < 1) {
              if (!end_of_data) {
                continue;
              }
            }
            var next = ICAL2.Time.fromDayOfYear(
              startOfWeek + dow,
              this.last.year
            );
            this.last.year = next.year;
            this.last.month = next.month;
            this.last.day = next.day;
            return end_of_data;
          }
        },
        next_year: function next_year() {
          if (this.next_hour() == 0) {
            return 0;
          }
          if (++this.days_index == this.days.length) {
            this.days_index = 0;
            do {
              this.increment_year(this.rule.interval);
              this.expand_year_days(this.last.year);
            } while (this.days.length == 0);
          }
          this._nextByYearDay();
          return 1;
        },
        _nextByYearDay: function _nextByYearDay() {
          var doy = this.days[this.days_index];
          var year = this.last.year;
          if (doy < 1) {
            doy += 1;
            year += 1;
          }
          var next = ICAL2.Time.fromDayOfYear(doy, year);
          this.last.day = next.day;
          this.last.month = next.month;
        },
        /**
         * @param dow (eg: '1TU', '-1MO')
         * @param {ICAL.Time.weekDay=} aWeekStart The week start weekday
         * @return [pos, numericDow] (eg: [1, 3]) numericDow is relative to aWeekStart
         */
        ruleDayOfWeek: function ruleDayOfWeek(dow, aWeekStart) {
          var matches = dow.match(/([+-]?[0-9])?(MO|TU|WE|TH|FR|SA|SU)/);
          if (matches) {
            var pos = parseInt(matches[1] || 0, 10);
            dow = ICAL2.Recur.icalDayToNumericDay(matches[2], aWeekStart);
            return [pos, dow];
          } else {
            return [0, 0];
          }
        },
        next_generic: function next_generic(aRuleType, aInterval, aDateAttr, aFollowingAttr, aPreviousIncr) {
          var has_by_rule = aRuleType in this.by_data;
          var this_freq = this.rule.freq == aInterval;
          var end_of_data = 0;
          if (aPreviousIncr && this[aPreviousIncr]() == 0) {
            return end_of_data;
          }
          if (has_by_rule) {
            this.by_indices[aRuleType]++;
            var idx = this.by_indices[aRuleType];
            var dta = this.by_data[aRuleType];
            if (this.by_indices[aRuleType] == dta.length) {
              this.by_indices[aRuleType] = 0;
              end_of_data = 1;
            }
            this.last[aDateAttr] = dta[this.by_indices[aRuleType]];
          } else if (this_freq) {
            this["increment_" + aDateAttr](this.rule.interval);
          }
          if (has_by_rule && end_of_data && this_freq) {
            this["increment_" + aFollowingAttr](1);
          }
          return end_of_data;
        },
        increment_monthday: function increment_monthday(inc) {
          for (var i3 = 0; i3 < inc; i3++) {
            var daysInMonth = ICAL2.Time.daysInMonth(this.last.month, this.last.year);
            this.last.day++;
            if (this.last.day > daysInMonth) {
              this.last.day -= daysInMonth;
              this.increment_month();
            }
          }
        },
        increment_month: function increment_month() {
          this.last.day = 1;
          if (this.has_by_data("BYMONTH")) {
            this.by_indices.BYMONTH++;
            if (this.by_indices.BYMONTH == this.by_data.BYMONTH.length) {
              this.by_indices.BYMONTH = 0;
              this.increment_year(1);
            }
            this.last.month = this.by_data.BYMONTH[this.by_indices.BYMONTH];
          } else {
            if (this.rule.freq == "MONTHLY") {
              this.last.month += this.rule.interval;
            } else {
              this.last.month++;
            }
            this.last.month--;
            var years = ICAL2.helpers.trunc(this.last.month / 12);
            this.last.month %= 12;
            this.last.month++;
            if (years != 0) {
              this.increment_year(years);
            }
          }
        },
        increment_year: function increment_year(inc) {
          this.last.year += inc;
        },
        increment_generic: function increment_generic(inc, aDateAttr, aFactor, aNextIncrement) {
          this.last[aDateAttr] += inc;
          var nextunit = ICAL2.helpers.trunc(this.last[aDateAttr] / aFactor);
          this.last[aDateAttr] %= aFactor;
          if (nextunit != 0) {
            this["increment_" + aNextIncrement](nextunit);
          }
        },
        has_by_data: function has_by_data(aRuleType) {
          return aRuleType in this.rule.parts;
        },
        expand_year_days: function expand_year_days(aYear) {
          var t3 = new ICAL2.Time();
          this.days = [];
          var parts = {};
          var rules = ["BYDAY", "BYWEEKNO", "BYMONTHDAY", "BYMONTH", "BYYEARDAY"];
          for (var p3 in rules) {
            if (rules.hasOwnProperty(p3)) {
              var part = rules[p3];
              if (part in this.rule.parts) {
                parts[part] = this.rule.parts[part];
              }
            }
          }
          if ("BYMONTH" in parts && "BYWEEKNO" in parts) {
            var valid = 1;
            var validWeeks = {};
            t3.year = aYear;
            t3.isDate = true;
            for (var monthIdx = 0; monthIdx < this.by_data.BYMONTH.length; monthIdx++) {
              var month = this.by_data.BYMONTH[monthIdx];
              t3.month = month;
              t3.day = 1;
              var first_week = t3.weekNumber(this.rule.wkst);
              t3.day = ICAL2.Time.daysInMonth(month, aYear);
              var last_week = t3.weekNumber(this.rule.wkst);
              for (monthIdx = first_week; monthIdx < last_week; monthIdx++) {
                validWeeks[monthIdx] = 1;
              }
            }
            for (var weekIdx = 0; weekIdx < this.by_data.BYWEEKNO.length && valid; weekIdx++) {
              var weekno = this.by_data.BYWEEKNO[weekIdx];
              if (weekno < 52) {
                valid &= validWeeks[weekIdx];
              } else {
                valid = 0;
              }
            }
            if (valid) {
              delete parts.BYMONTH;
            } else {
              delete parts.BYWEEKNO;
            }
          }
          var partCount = Object.keys(parts).length;
          if (partCount == 0) {
            var t1 = this.dtstart.clone();
            t1.year = this.last.year;
            this.days.push(t1.dayOfYear());
          } else if (partCount == 1 && "BYMONTH" in parts) {
            for (var monthkey in this.by_data.BYMONTH) {
              if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {
                continue;
              }
              var t22 = this.dtstart.clone();
              t22.year = aYear;
              t22.month = this.by_data.BYMONTH[monthkey];
              t22.isDate = true;
              this.days.push(t22.dayOfYear());
            }
          } else if (partCount == 1 && "BYMONTHDAY" in parts) {
            for (var monthdaykey in this.by_data.BYMONTHDAY) {
              if (!this.by_data.BYMONTHDAY.hasOwnProperty(monthdaykey)) {
                continue;
              }
              var t32 = this.dtstart.clone();
              var day_ = this.by_data.BYMONTHDAY[monthdaykey];
              if (day_ < 0) {
                var daysInMonth = ICAL2.Time.daysInMonth(t32.month, aYear);
                day_ = day_ + daysInMonth + 1;
              }
              t32.day = day_;
              t32.year = aYear;
              t32.isDate = true;
              this.days.push(t32.dayOfYear());
            }
          } else if (partCount == 2 && "BYMONTHDAY" in parts && "BYMONTH" in parts) {
            for (var monthkey in this.by_data.BYMONTH) {
              if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {
                continue;
              }
              var month_ = this.by_data.BYMONTH[monthkey];
              var daysInMonth = ICAL2.Time.daysInMonth(month_, aYear);
              for (var monthdaykey in this.by_data.BYMONTHDAY) {
                if (!this.by_data.BYMONTHDAY.hasOwnProperty(monthdaykey)) {
                  continue;
                }
                var day_ = this.by_data.BYMONTHDAY[monthdaykey];
                if (day_ < 0) {
                  day_ = day_ + daysInMonth + 1;
                }
                t3.day = day_;
                t3.month = month_;
                t3.year = aYear;
                t3.isDate = true;
                this.days.push(t3.dayOfYear());
              }
            }
          } else if (partCount == 1 && "BYWEEKNO" in parts) {
          } else if (partCount == 2 && "BYWEEKNO" in parts && "BYMONTHDAY" in parts) {
          } else if (partCount == 1 && "BYDAY" in parts) {
            this.days = this.days.concat(this.expand_by_day(aYear));
          } else if (partCount == 2 && "BYDAY" in parts && "BYMONTH" in parts) {
            for (var monthkey in this.by_data.BYMONTH) {
              if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {
                continue;
              }
              var month = this.by_data.BYMONTH[monthkey];
              var daysInMonth = ICAL2.Time.daysInMonth(month, aYear);
              t3.year = aYear;
              t3.month = this.by_data.BYMONTH[monthkey];
              t3.day = 1;
              t3.isDate = true;
              var first_dow = t3.dayOfWeek();
              var doy_offset = t3.dayOfYear() - 1;
              t3.day = daysInMonth;
              var last_dow = t3.dayOfWeek();
              if (this.has_by_data("BYSETPOS")) {
                var set_pos_counter = 0;
                var by_month_day = [];
                for (var day = 1; day <= daysInMonth; day++) {
                  t3.day = day;
                  if (this.is_day_in_byday(t3)) {
                    by_month_day.push(day);
                  }
                }
                for (var spIndex = 0; spIndex < by_month_day.length; spIndex++) {
                  if (this.check_set_position(spIndex + 1) || this.check_set_position(spIndex - by_month_day.length)) {
                    this.days.push(doy_offset + by_month_day[spIndex]);
                  }
                }
              } else {
                for (var daycodedkey in this.by_data.BYDAY) {
                  if (!this.by_data.BYDAY.hasOwnProperty(daycodedkey)) {
                    continue;
                  }
                  var coded_day = this.by_data.BYDAY[daycodedkey];
                  var bydayParts = this.ruleDayOfWeek(coded_day);
                  var pos = bydayParts[0];
                  var dow = bydayParts[1];
                  var month_day;
                  var first_matching_day = (dow + 7 - first_dow) % 7 + 1;
                  var last_matching_day = daysInMonth - (last_dow + 7 - dow) % 7;
                  if (pos == 0) {
                    for (var day = first_matching_day; day <= daysInMonth; day += 7) {
                      this.days.push(doy_offset + day);
                    }
                  } else if (pos > 0) {
                    month_day = first_matching_day + (pos - 1) * 7;
                    if (month_day <= daysInMonth) {
                      this.days.push(doy_offset + month_day);
                    }
                  } else {
                    month_day = last_matching_day + (pos + 1) * 7;
                    if (month_day > 0) {
                      this.days.push(doy_offset + month_day);
                    }
                  }
                }
              }
            }
            this.days.sort(function(a3, b3) {
              return a3 - b3;
            });
          } else if (partCount == 2 && "BYDAY" in parts && "BYMONTHDAY" in parts) {
            var expandedDays = this.expand_by_day(aYear);
            for (var daykey in expandedDays) {
              if (!expandedDays.hasOwnProperty(daykey)) {
                continue;
              }
              var day = expandedDays[daykey];
              var tt = ICAL2.Time.fromDayOfYear(day, aYear);
              if (this.by_data.BYMONTHDAY.indexOf(tt.day) >= 0) {
                this.days.push(day);
              }
            }
          } else if (partCount == 3 && "BYDAY" in parts && "BYMONTHDAY" in parts && "BYMONTH" in parts) {
            var expandedDays = this.expand_by_day(aYear);
            for (var daykey in expandedDays) {
              if (!expandedDays.hasOwnProperty(daykey)) {
                continue;
              }
              var day = expandedDays[daykey];
              var tt = ICAL2.Time.fromDayOfYear(day, aYear);
              if (this.by_data.BYMONTH.indexOf(tt.month) >= 0 && this.by_data.BYMONTHDAY.indexOf(tt.day) >= 0) {
                this.days.push(day);
              }
            }
          } else if (partCount == 2 && "BYDAY" in parts && "BYWEEKNO" in parts) {
            var expandedDays = this.expand_by_day(aYear);
            for (var daykey in expandedDays) {
              if (!expandedDays.hasOwnProperty(daykey)) {
                continue;
              }
              var day = expandedDays[daykey];
              var tt = ICAL2.Time.fromDayOfYear(day, aYear);
              var weekno = tt.weekNumber(this.rule.wkst);
              if (this.by_data.BYWEEKNO.indexOf(weekno)) {
                this.days.push(day);
              }
            }
          } else if (partCount == 3 && "BYDAY" in parts && "BYWEEKNO" in parts && "BYMONTHDAY" in parts) {
          } else if (partCount == 1 && "BYYEARDAY" in parts) {
            this.days = this.days.concat(this.by_data.BYYEARDAY);
          } else {
            this.days = [];
          }
          return 0;
        },
        expand_by_day: function expand_by_day(aYear) {
          var days_list = [];
          var tmp = this.last.clone();
          tmp.year = aYear;
          tmp.month = 1;
          tmp.day = 1;
          tmp.isDate = true;
          var start_dow = tmp.dayOfWeek();
          tmp.month = 12;
          tmp.day = 31;
          tmp.isDate = true;
          var end_dow = tmp.dayOfWeek();
          var end_year_day = tmp.dayOfYear();
          for (var daykey in this.by_data.BYDAY) {
            if (!this.by_data.BYDAY.hasOwnProperty(daykey)) {
              continue;
            }
            var day = this.by_data.BYDAY[daykey];
            var parts = this.ruleDayOfWeek(day);
            var pos = parts[0];
            var dow = parts[1];
            if (pos == 0) {
              var tmp_start_doy = (dow + 7 - start_dow) % 7 + 1;
              for (var doy = tmp_start_doy; doy <= end_year_day; doy += 7) {
                days_list.push(doy);
              }
            } else if (pos > 0) {
              var first;
              if (dow >= start_dow) {
                first = dow - start_dow + 1;
              } else {
                first = dow - start_dow + 8;
              }
              days_list.push(first + (pos - 1) * 7);
            } else {
              var last;
              pos = -pos;
              if (dow <= end_dow) {
                last = end_year_day - end_dow + dow;
              } else {
                last = end_year_day - end_dow + dow - 7;
              }
              days_list.push(last - (pos - 1) * 7);
            }
          }
          return days_list;
        },
        is_day_in_byday: function is_day_in_byday(tt) {
          for (var daykey in this.by_data.BYDAY) {
            if (!this.by_data.BYDAY.hasOwnProperty(daykey)) {
              continue;
            }
            var day = this.by_data.BYDAY[daykey];
            var parts = this.ruleDayOfWeek(day);
            var pos = parts[0];
            var dow = parts[1];
            var this_dow = tt.dayOfWeek();
            if (pos == 0 && dow == this_dow || tt.nthWeekDay(dow, pos) == tt.day) {
              return 1;
            }
          }
          return 0;
        },
        /**
         * Checks if given value is in BYSETPOS.
         *
         * @private
         * @param {Numeric} aPos position to check for.
         * @return {Boolean} false unless BYSETPOS rules exist
         *                   and the given value is present in rules.
         */
        check_set_position: function check_set_position(aPos) {
          if (this.has_by_data("BYSETPOS")) {
            var idx = this.by_data.BYSETPOS.indexOf(aPos);
            return idx !== -1;
          }
          return false;
        },
        sort_byday_rules: function icalrecur_sort_byday_rules(aRules) {
          for (var i3 = 0; i3 < aRules.length; i3++) {
            for (var j4 = 0; j4 < i3; j4++) {
              var one = this.ruleDayOfWeek(aRules[j4], this.rule.wkst)[1];
              var two = this.ruleDayOfWeek(aRules[i3], this.rule.wkst)[1];
              if (one > two) {
                var tmp = aRules[i3];
                aRules[i3] = aRules[j4];
                aRules[j4] = tmp;
              }
            }
          }
        },
        check_contract_restriction: function check_contract_restriction(aRuleType, v3) {
          var indexMapValue = icalrecur_iterator._indexMap[aRuleType];
          var ruleMapValue = icalrecur_iterator._expandMap[this.rule.freq][indexMapValue];
          var pass = false;
          if (aRuleType in this.by_data && ruleMapValue == icalrecur_iterator.CONTRACT) {
            var ruleType = this.by_data[aRuleType];
            for (var bydatakey in ruleType) {
              if (ruleType.hasOwnProperty(bydatakey)) {
                if (ruleType[bydatakey] == v3) {
                  pass = true;
                  break;
                }
              }
            }
          } else {
            pass = true;
          }
          return pass;
        },
        check_contracting_rules: function check_contracting_rules() {
          var dow = this.last.dayOfWeek();
          var weekNo = this.last.weekNumber(this.rule.wkst);
          var doy = this.last.dayOfYear();
          return this.check_contract_restriction("BYSECOND", this.last.second) && this.check_contract_restriction("BYMINUTE", this.last.minute) && this.check_contract_restriction("BYHOUR", this.last.hour) && this.check_contract_restriction("BYDAY", ICAL2.Recur.numericDayToIcalDay(dow)) && this.check_contract_restriction("BYWEEKNO", weekNo) && this.check_contract_restriction("BYMONTHDAY", this.last.day) && this.check_contract_restriction("BYMONTH", this.last.month) && this.check_contract_restriction("BYYEARDAY", doy);
        },
        setup_defaults: function setup_defaults(aRuleType, req, deftime) {
          var indexMapValue = icalrecur_iterator._indexMap[aRuleType];
          var ruleMapValue = icalrecur_iterator._expandMap[this.rule.freq][indexMapValue];
          if (ruleMapValue != icalrecur_iterator.CONTRACT) {
            if (!(aRuleType in this.by_data)) {
              this.by_data[aRuleType] = [deftime];
            }
            if (this.rule.freq != req) {
              return this.by_data[aRuleType][0];
            }
          }
          return deftime;
        },
        /**
         * Convert iterator into a serialize-able object.  Will preserve current
         * iteration sequence to ensure the seamless continuation of the recurrence
         * rule.
         * @return {Object}
         */
        toJSON: function() {
          var result = /* @__PURE__ */ Object.create(null);
          result.initialized = this.initialized;
          result.rule = this.rule.toJSON();
          result.dtstart = this.dtstart.toJSON();
          result.by_data = this.by_data;
          result.days = this.days;
          result.last = this.last.toJSON();
          result.by_indices = this.by_indices;
          result.occurrence_number = this.occurrence_number;
          return result;
        }
      };
      icalrecur_iterator._indexMap = {
        "BYSECOND": 0,
        "BYMINUTE": 1,
        "BYHOUR": 2,
        "BYDAY": 3,
        "BYMONTHDAY": 4,
        "BYYEARDAY": 5,
        "BYWEEKNO": 6,
        "BYMONTH": 7,
        "BYSETPOS": 8
      };
      icalrecur_iterator._expandMap = {
        "SECONDLY": [1, 1, 1, 1, 1, 1, 1, 1],
        "MINUTELY": [2, 1, 1, 1, 1, 1, 1, 1],
        "HOURLY": [2, 2, 1, 1, 1, 1, 1, 1],
        "DAILY": [2, 2, 2, 1, 1, 1, 1, 1],
        "WEEKLY": [2, 2, 2, 2, 3, 3, 1, 1],
        "MONTHLY": [2, 2, 2, 2, 2, 3, 3, 1],
        "YEARLY": [2, 2, 2, 2, 2, 2, 2, 2]
      };
      icalrecur_iterator.UNKNOWN = 0;
      icalrecur_iterator.CONTRACT = 1;
      icalrecur_iterator.EXPAND = 2;
      icalrecur_iterator.ILLEGAL = 3;
      return icalrecur_iterator;
    }();
    ICAL2.RecurExpansion = function() {
      function formatTime(item) {
        return ICAL2.helpers.formatClassType(item, ICAL2.Time);
      }
      function compareTime(a3, b3) {
        return a3.compare(b3);
      }
      function isRecurringComponent(comp) {
        return comp.hasProperty("rdate") || comp.hasProperty("rrule") || comp.hasProperty("recurrence-id");
      }
      function RecurExpansion(options) {
        this.ruleDates = [];
        this.exDates = [];
        this.fromData(options);
      }
      RecurExpansion.prototype = {
        /**
         * True when iteration is fully completed.
         * @type {Boolean}
         */
        complete: false,
        /**
         * Array of rrule iterators.
         *
         * @type {ICAL.RecurIterator[]}
         * @private
         */
        ruleIterators: null,
        /**
         * Array of rdate instances.
         *
         * @type {ICAL.Time[]}
         * @private
         */
        ruleDates: null,
        /**
         * Array of exdate instances.
         *
         * @type {ICAL.Time[]}
         * @private
         */
        exDates: null,
        /**
         * Current position in ruleDates array.
         * @type {Number}
         * @private
         */
        ruleDateInc: 0,
        /**
         * Current position in exDates array
         * @type {Number}
         * @private
         */
        exDateInc: 0,
        /**
         * Current negative date.
         *
         * @type {ICAL.Time}
         * @private
         */
        exDate: null,
        /**
         * Current additional date.
         *
         * @type {ICAL.Time}
         * @private
         */
        ruleDate: null,
        /**
         * Start date of recurring rules.
         *
         * @type {ICAL.Time}
         */
        dtstart: null,
        /**
         * Last expanded time
         *
         * @type {ICAL.Time}
         */
        last: null,
        /**
         * Initialize the recurrence expansion from the data object. The options
         * object may also contain additional members, see the
         * {@link ICAL.RecurExpansion constructor} for more details.
         *
         * @param {Object} options
         *        Recurrence expansion options
         * @param {ICAL.Time} options.dtstart
         *        Start time of the event
         * @param {ICAL.Component=} options.component
         *        Component for expansion, required if not resuming.
         */
        fromData: function(options) {
          var start = ICAL2.helpers.formatClassType(options.dtstart, ICAL2.Time);
          if (!start) {
            throw new Error(".dtstart (ICAL.Time) must be given");
          } else {
            this.dtstart = start;
          }
          if (options.component) {
            this._init(options.component);
          } else {
            this.last = formatTime(options.last) || start.clone();
            if (!options.ruleIterators) {
              throw new Error(".ruleIterators or .component must be given");
            }
            this.ruleIterators = options.ruleIterators.map(function(item) {
              return ICAL2.helpers.formatClassType(item, ICAL2.RecurIterator);
            });
            this.ruleDateInc = options.ruleDateInc;
            this.exDateInc = options.exDateInc;
            if (options.ruleDates) {
              this.ruleDates = options.ruleDates.map(formatTime);
              this.ruleDate = this.ruleDates[this.ruleDateInc];
            }
            if (options.exDates) {
              this.exDates = options.exDates.map(formatTime);
              this.exDate = this.exDates[this.exDateInc];
            }
            if (typeof options.complete !== "undefined") {
              this.complete = options.complete;
            }
          }
        },
        /**
         * Retrieve the next occurrence in the series.
         * @return {ICAL.Time}
         */
        next: function() {
          var iter2;
          var ruleOfDay;
          var next;
          var compare;
          var maxTries = 500;
          var currentTry = 0;
          while (true) {
            if (currentTry++ > maxTries) {
              throw new Error(
                "max tries have occured, rule may be impossible to forfill."
              );
            }
            next = this.ruleDate;
            iter2 = this._nextRecurrenceIter(this.last);
            if (!next && !iter2) {
              this.complete = true;
              break;
            }
            if (!next || iter2 && next.compare(iter2.last) > 0) {
              next = iter2.last.clone();
              iter2.next();
            }
            if (this.ruleDate === next) {
              this._nextRuleDay();
            }
            this.last = next;
            if (this.exDate) {
              compare = this.exDate.compare(this.last);
              if (compare < 0) {
                this._nextExDay();
              }
              if (compare === 0) {
                this._nextExDay();
                continue;
              }
            }
            return this.last;
          }
        },
        /**
         * Converts object into a serialize-able format. This format can be passed
         * back into the expansion to resume iteration.
         * @return {Object}
         */
        toJSON: function() {
          function toJSON(item) {
            return item.toJSON();
          }
          var result = /* @__PURE__ */ Object.create(null);
          result.ruleIterators = this.ruleIterators.map(toJSON);
          if (this.ruleDates) {
            result.ruleDates = this.ruleDates.map(toJSON);
          }
          if (this.exDates) {
            result.exDates = this.exDates.map(toJSON);
          }
          result.ruleDateInc = this.ruleDateInc;
          result.exDateInc = this.exDateInc;
          result.last = this.last.toJSON();
          result.dtstart = this.dtstart.toJSON();
          result.complete = this.complete;
          return result;
        },
        /**
         * Extract all dates from the properties in the given component. The
         * properties will be filtered by the property name.
         *
         * @private
         * @param {ICAL.Component} component        The component to search in
         * @param {String} propertyName             The property name to search for
         * @return {ICAL.Time[]}                    The extracted dates.
         */
        _extractDates: function(component, propertyName) {
          function handleProp(prop2) {
            idx = ICAL2.helpers.binsearchInsert(
              result,
              prop2,
              compareTime
            );
            result.splice(idx, 0, prop2);
          }
          var result = [];
          var props = component.getAllProperties(propertyName);
          var len = props.length;
          var i3 = 0;
          var prop;
          var idx;
          for (; i3 < len; i3++) {
            props[i3].getValues().forEach(handleProp);
          }
          return result;
        },
        /**
         * Initialize the recurrence expansion.
         *
         * @private
         * @param {ICAL.Component} component    The component to initialize from.
         */
        _init: function(component) {
          this.ruleIterators = [];
          this.last = this.dtstart.clone();
          if (!isRecurringComponent(component)) {
            this.ruleDate = this.last.clone();
            this.complete = true;
            return;
          }
          if (component.hasProperty("rdate")) {
            this.ruleDates = this._extractDates(component, "rdate");
            if (this.ruleDates[0] && this.ruleDates[0].compare(this.dtstart) < 0) {
              this.ruleDateInc = 0;
              this.last = this.ruleDates[0].clone();
            } else {
              this.ruleDateInc = ICAL2.helpers.binsearchInsert(
                this.ruleDates,
                this.last,
                compareTime
              );
            }
            this.ruleDate = this.ruleDates[this.ruleDateInc];
          }
          if (component.hasProperty("rrule")) {
            var rules = component.getAllProperties("rrule");
            var i3 = 0;
            var len = rules.length;
            var rule;
            var iter2;
            for (; i3 < len; i3++) {
              rule = rules[i3].getFirstValue();
              iter2 = rule.iterator(this.dtstart);
              this.ruleIterators.push(iter2);
              iter2.next();
            }
          }
          if (component.hasProperty("exdate")) {
            this.exDates = this._extractDates(component, "exdate");
            this.exDateInc = ICAL2.helpers.binsearchInsert(
              this.exDates,
              this.last,
              compareTime
            );
            this.exDate = this.exDates[this.exDateInc];
          }
        },
        /**
         * Advance to the next exdate
         * @private
         */
        _nextExDay: function() {
          this.exDate = this.exDates[++this.exDateInc];
        },
        /**
         * Advance to the next rule date
         * @private
         */
        _nextRuleDay: function() {
          this.ruleDate = this.ruleDates[++this.ruleDateInc];
        },
        /**
         * Find and return the recurrence rule with the most recent event and
         * return it.
         *
         * @private
         * @return {?ICAL.RecurIterator}    Found iterator.
         */
        _nextRecurrenceIter: function() {
          var iters = this.ruleIterators;
          if (iters.length === 0) {
            return null;
          }
          var len = iters.length;
          var iter2;
          var iterTime;
          var iterIdx = 0;
          var chosenIter;
          for (; iterIdx < len; iterIdx++) {
            iter2 = iters[iterIdx];
            iterTime = iter2.last;
            if (iter2.completed) {
              len--;
              if (iterIdx !== 0) {
                iterIdx--;
              }
              iters.splice(iterIdx, 1);
              continue;
            }
            if (!chosenIter || chosenIter.last.compare(iterTime) > 0) {
              chosenIter = iter2;
            }
          }
          return chosenIter;
        }
      };
      return RecurExpansion;
    }();
    ICAL2.Event = function() {
      function Event2(component, options) {
        if (!(component instanceof ICAL2.Component)) {
          options = component;
          component = null;
        }
        if (component) {
          this.component = component;
        } else {
          this.component = new ICAL2.Component("vevent");
        }
        this._rangeExceptionCache = /* @__PURE__ */ Object.create(null);
        this.exceptions = /* @__PURE__ */ Object.create(null);
        this.rangeExceptions = [];
        if (options && options.strictExceptions) {
          this.strictExceptions = options.strictExceptions;
        }
        if (options && options.exceptions) {
          options.exceptions.forEach(this.relateException, this);
        } else if (this.component.parent && !this.isRecurrenceException()) {
          this.component.parent.getAllSubcomponents("vevent").forEach(function(event) {
            if (event.hasProperty("recurrence-id")) {
              this.relateException(event);
            }
          }, this);
        }
      }
      Event2.prototype = {
        THISANDFUTURE: "THISANDFUTURE",
        /**
         * List of related event exceptions.
         *
         * @type {ICAL.Event[]}
         */
        exceptions: null,
        /**
         * When true, will verify exceptions are related by their UUID.
         *
         * @type {Boolean}
         */
        strictExceptions: false,
        /**
         * Relates a given event exception to this object.  If the given component
         * does not share the UID of this event it cannot be related and will throw
         * an exception.
         *
         * If this component is an exception it cannot have other exceptions
         * related to it.
         *
         * @param {ICAL.Component|ICAL.Event} obj       Component or event
         */
        relateException: function(obj) {
          if (this.isRecurrenceException()) {
            throw new Error("cannot relate exception to exceptions");
          }
          if (obj instanceof ICAL2.Component) {
            obj = new ICAL2.Event(obj);
          }
          if (this.strictExceptions && obj.uid !== this.uid) {
            throw new Error("attempted to relate unrelated exception");
          }
          var id = obj.recurrenceId.toString();
          this.exceptions[id] = obj;
          if (obj.modifiesFuture()) {
            var item = [
              obj.recurrenceId.toUnixTime(),
              id
            ];
            var idx = ICAL2.helpers.binsearchInsert(
              this.rangeExceptions,
              item,
              compareRangeException
            );
            this.rangeExceptions.splice(idx, 0, item);
          }
        },
        /**
         * Checks if this record is an exception and has the RANGE=THISANDFUTURE
         * value.
         *
         * @return {Boolean}        True, when exception is within range
         */
        modifiesFuture: function() {
          if (!this.component.hasProperty("recurrence-id")) {
            return false;
          }
          var range2 = this.component.getFirstProperty("recurrence-id").getParameter("range");
          return range2 === this.THISANDFUTURE;
        },
        /**
         * Finds the range exception nearest to the given date.
         *
         * @param {ICAL.Time} time usually an occurrence time of an event
         * @return {?ICAL.Event} the related event/exception or null
         */
        findRangeException: function(time) {
          if (!this.rangeExceptions.length) {
            return null;
          }
          var utc = time.toUnixTime();
          var idx = ICAL2.helpers.binsearchInsert(
            this.rangeExceptions,
            [utc],
            compareRangeException
          );
          idx -= 1;
          if (idx < 0) {
            return null;
          }
          var rangeItem = this.rangeExceptions[idx];
          if (utc < rangeItem[0]) {
            return null;
          }
          return rangeItem[1];
        },
        /**
         * This object is returned by {@link ICAL.Event#getOccurrenceDetails getOccurrenceDetails}
         *
         * @typedef {Object} occurrenceDetails
         * @memberof ICAL.Event
         * @property {ICAL.Time} recurrenceId       The passed in recurrence id
         * @property {ICAL.Event} item              The occurrence
         * @property {ICAL.Time} startDate          The start of the occurrence
         * @property {ICAL.Time} endDate            The end of the occurrence
         */
        /**
         * Returns the occurrence details based on its start time.  If the
         * occurrence has an exception will return the details for that exception.
         *
         * NOTE: this method is intend to be used in conjunction
         *       with the {@link ICAL.Event#iterator iterator} method.
         *
         * @param {ICAL.Time} occurrence time occurrence
         * @return {ICAL.Event.occurrenceDetails} Information about the occurrence
         */
        getOccurrenceDetails: function(occurrence) {
          var id = occurrence.toString();
          var utcId = occurrence.convertToZone(ICAL2.Timezone.utcTimezone).toString();
          var item;
          var result = {
            //XXX: Clone?
            recurrenceId: occurrence
          };
          if (id in this.exceptions) {
            item = result.item = this.exceptions[id];
            result.startDate = item.startDate;
            result.endDate = item.endDate;
            result.item = item;
          } else if (utcId in this.exceptions) {
            item = this.exceptions[utcId];
            result.startDate = item.startDate;
            result.endDate = item.endDate;
            result.item = item;
          } else {
            var rangeExceptionId = this.findRangeException(
              occurrence
            );
            var end;
            if (rangeExceptionId) {
              var exception = this.exceptions[rangeExceptionId];
              result.item = exception;
              var startDiff = this._rangeExceptionCache[rangeExceptionId];
              if (!startDiff) {
                var original = exception.recurrenceId.clone();
                var newStart = exception.startDate.clone();
                original.zone = newStart.zone;
                startDiff = newStart.subtractDate(original);
                this._rangeExceptionCache[rangeExceptionId] = startDiff;
              }
              var start = occurrence.clone();
              start.zone = exception.startDate.zone;
              start.addDuration(startDiff);
              end = start.clone();
              end.addDuration(exception.duration);
              result.startDate = start;
              result.endDate = end;
            } else {
              end = occurrence.clone();
              end.addDuration(this.duration);
              result.endDate = end;
              result.startDate = occurrence;
              result.item = this;
            }
          }
          return result;
        },
        /**
         * Builds a recur expansion instance for a specific point in time (defaults
         * to startDate).
         *
         * @param {ICAL.Time} startTime     Starting point for expansion
         * @return {ICAL.RecurExpansion}    Expansion object
         */
        iterator: function(startTime) {
          return new ICAL2.RecurExpansion({
            component: this.component,
            dtstart: startTime || this.startDate
          });
        },
        /**
         * Checks if the event is recurring
         *
         * @return {Boolean}        True, if event is recurring
         */
        isRecurring: function() {
          var comp = this.component;
          return comp.hasProperty("rrule") || comp.hasProperty("rdate");
        },
        /**
         * Checks if the event describes a recurrence exception. See
         * {@tutorial terminology} for details.
         *
         * @return {Boolean}    True, if the event describes a recurrence exception
         */
        isRecurrenceException: function() {
          return this.component.hasProperty("recurrence-id");
        },
        /**
         * Returns the types of recurrences this event may have.
         *
         * Returned as an object with the following possible keys:
         *
         *    - YEARLY
         *    - MONTHLY
         *    - WEEKLY
         *    - DAILY
         *    - MINUTELY
         *    - SECONDLY
         *
         * @return {Object.<ICAL.Recur.frequencyValues, Boolean>}
         *          Object of recurrence flags
         */
        getRecurrenceTypes: function() {
          var rules = this.component.getAllProperties("rrule");
          var i3 = 0;
          var len = rules.length;
          var result = /* @__PURE__ */ Object.create(null);
          for (; i3 < len; i3++) {
            var value = rules[i3].getFirstValue();
            result[value.freq] = true;
          }
          return result;
        },
        /**
         * The uid of this event
         * @type {String}
         */
        get uid() {
          return this._firstProp("uid");
        },
        set uid(value) {
          this._setProp("uid", value);
        },
        /**
         * The start date
         * @type {ICAL.Time}
         */
        get startDate() {
          return this._firstProp("dtstart");
        },
        set startDate(value) {
          this._setTime("dtstart", value);
        },
        /**
         * The end date. This can be the result directly from the property, or the
         * end date calculated from start date and duration. Setting the property
         * will remove any duration properties.
         * @type {ICAL.Time}
         */
        get endDate() {
          var endDate = this._firstProp("dtend");
          if (!endDate) {
            var duration = this._firstProp("duration");
            endDate = this.startDate.clone();
            if (duration) {
              endDate.addDuration(duration);
            } else if (endDate.isDate) {
              endDate.day += 1;
            }
          }
          return endDate;
        },
        set endDate(value) {
          if (this.component.hasProperty("duration")) {
            this.component.removeProperty("duration");
          }
          this._setTime("dtend", value);
        },
        /**
         * The duration. This can be the result directly from the property, or the
         * duration calculated from start date and end date. Setting the property
         * will remove any `dtend` properties.
         * @type {ICAL.Duration}
         */
        get duration() {
          var duration = this._firstProp("duration");
          if (!duration) {
            return this.endDate.subtractDateTz(this.startDate);
          }
          return duration;
        },
        set duration(value) {
          if (this.component.hasProperty("dtend")) {
            this.component.removeProperty("dtend");
          }
          this._setProp("duration", value);
        },
        /**
         * The location of the event.
         * @type {String}
         */
        get location() {
          return this._firstProp("location");
        },
        set location(value) {
          return this._setProp("location", value);
        },
        /**
         * The attendees in the event
         * @type {ICAL.Property[]}
         * @readonly
         */
        get attendees() {
          return this.component.getAllProperties("attendee");
        },
        /**
         * The event summary
         * @type {String}
         */
        get summary() {
          return this._firstProp("summary");
        },
        set summary(value) {
          this._setProp("summary", value);
        },
        /**
         * The event description.
         * @type {String}
         */
        get description() {
          return this._firstProp("description");
        },
        set description(value) {
          this._setProp("description", value);
        },
        /**
         * The event color from [rfc7986](https://datatracker.ietf.org/doc/html/rfc7986)
         * @type {String}
         */
        get color() {
          return this._firstProp("color");
        },
        set color(value) {
          this._setProp("color", value);
        },
        /**
         * The organizer value as an uri. In most cases this is a mailto: uri, but
         * it can also be something else, like urn:uuid:...
         * @type {String}
         */
        get organizer() {
          return this._firstProp("organizer");
        },
        set organizer(value) {
          this._setProp("organizer", value);
        },
        /**
         * The sequence value for this event. Used for scheduling
         * see {@tutorial terminology}.
         * @type {Number}
         */
        get sequence() {
          return this._firstProp("sequence");
        },
        set sequence(value) {
          this._setProp("sequence", value);
        },
        /**
         * The recurrence id for this event. See {@tutorial terminology} for details.
         * @type {ICAL.Time}
         */
        get recurrenceId() {
          return this._firstProp("recurrence-id");
        },
        set recurrenceId(value) {
          this._setTime("recurrence-id", value);
        },
        /**
         * Set/update a time property's value.
         * This will also update the TZID of the property.
         *
         * TODO: this method handles the case where we are switching
         * from a known timezone to an implied timezone (one without TZID).
         * This does _not_ handle the case of moving between a known
         *  (by TimezoneService) timezone to an unknown timezone...
         *
         * We will not add/remove/update the VTIMEZONE subcomponents
         *  leading to invalid ICAL data...
         * @private
         * @param {String} propName     The property name
         * @param {ICAL.Time} time      The time to set
         */
        _setTime: function(propName, time) {
          var prop = this.component.getFirstProperty(propName);
          if (!prop) {
            prop = new ICAL2.Property(propName);
            this.component.addProperty(prop);
          }
          if (time.zone === ICAL2.Timezone.localTimezone || time.zone === ICAL2.Timezone.utcTimezone) {
            prop.removeParameter("tzid");
          } else {
            prop.setParameter("tzid", time.zone.tzid);
          }
          prop.setValue(time);
        },
        _setProp: function(name, value) {
          this.component.updatePropertyWithValue(name, value);
        },
        _firstProp: function(name) {
          return this.component.getFirstPropertyValue(name);
        },
        /**
         * The string representation of this event.
         * @return {String}
         */
        toString: function() {
          return this.component.toString();
        }
      };
      function compareRangeException(a3, b3) {
        if (a3[0] > b3[0])
          return 1;
        if (b3[0] > a3[0])
          return -1;
        return 0;
      }
      return Event2;
    }();
    ICAL2.ComponentParser = function() {
      function ComponentParser(options) {
        if (typeof options === "undefined") {
          options = {};
        }
        var key;
        for (key in options) {
          if (options.hasOwnProperty(key)) {
            this[key] = options[key];
          }
        }
      }
      ComponentParser.prototype = {
        /**
         * When true, parse events
         *
         * @type {Boolean}
         */
        parseEvent: true,
        /**
         * When true, parse timezones
         *
         * @type {Boolean}
         */
        parseTimezone: true,
        /* SAX like events here for reference */
        /**
         * Fired when parsing is complete
         * @callback
         */
        oncomplete: (
          /* istanbul ignore next */
          function() {
          }
        ),
        /**
         * Fired if an error occurs during parsing.
         *
         * @callback
         * @param {Error} err details of error
         */
        onerror: (
          /* istanbul ignore next */
          function(err) {
          }
        ),
        /**
         * Fired when a top level component (VTIMEZONE) is found
         *
         * @callback
         * @param {ICAL.Timezone} component     Timezone object
         */
        ontimezone: (
          /* istanbul ignore next */
          function(component) {
          }
        ),
        /**
         * Fired when a top level component (VEVENT) is found.
         *
         * @callback
         * @param {ICAL.Event} component    Top level component
         */
        onevent: (
          /* istanbul ignore next */
          function(component) {
          }
        ),
        /**
         * Process a string or parse ical object.  This function itself will return
         * nothing but will start the parsing process.
         *
         * Events must be registered prior to calling this method.
         *
         * @param {ICAL.Component|String|Object} ical      The component to process,
         *        either in its final form, as a jCal Object, or string representation
         */
        process: function(ical) {
          if (typeof ical === "string") {
            ical = ICAL2.parse(ical);
          }
          if (!(ical instanceof ICAL2.Component)) {
            ical = new ICAL2.Component(ical);
          }
          var components = ical.getAllSubcomponents();
          var i3 = 0;
          var len = components.length;
          var component;
          for (; i3 < len; i3++) {
            component = components[i3];
            switch (component.name) {
              case "vtimezone":
                if (this.parseTimezone) {
                  var tzid = component.getFirstPropertyValue("tzid");
                  if (tzid) {
                    this.ontimezone(new ICAL2.Timezone({
                      tzid,
                      component
                    }));
                  }
                }
                break;
              case "vevent":
                if (this.parseEvent) {
                  this.onevent(new ICAL2.Event(component));
                }
                break;
              default:
                continue;
            }
          }
          this.oncomplete();
        }
      };
      return ComponentParser;
    }();
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MyPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// src/views/CalendarView.ts
var import_obsidian = require("obsidian");

// src/types.ts
var Src = class {
  constructor(path) {
    this._path = path;
    this._excludes = [];
  }
  addExcludes(excludes) {
    const isOk = excludes.every(
      (exclude) => {
        if (!exclude.startsWith(this._path))
          return false;
        if (exclude !== this._path)
          return false;
        return true;
      }
    );
    if (!isOk)
      return false;
    this._excludes.push(...excludes);
    this._excludes = this._excludes.unique();
    return true;
  }
  includes(path) {
    if (!path.startsWith(this._path)) {
      return false;
    }
    if (!this._excludes.length)
      return true;
    return this._excludes.some(
      (exclude) => {
        path.startsWith(exclude);
      }
    );
  }
  get path() {
    return this._path;
  }
  get excludes() {
    return structuredClone(this._excludes);
  }
};

// src/constants.ts
var MSG_PLG_NAME = "MyCalendar";
var EVENT_SRC = "databases";
var PLACE_FOR_CREATING_NOTE = "databases";
var daysOfWeek = ["1", "2", "3", "4", "5", "6", "0"];
var display = "background";
var COLOUR_REST = "#305B60";
var COLOUR_SLEEP = "#cc0000";
var DEFAULT_SETTINGS = {
  statusCorrector: {
    isOn: true,
    startOnStartUp: true
  },
  calendar: {
    slotDuration: "00:30:00",
    colours: {
      frequency: "#8A1717",
      done: "#008E04",
      tick: "#457E7E",
      default: "#5e3fa8"
    },
    restTime: [
      {
        daysOfWeek,
        display,
        startTime: "0:00:00",
        endTime: "8:00:00",
        color: COLOUR_SLEEP
      },
      {
        daysOfWeek,
        display,
        startTime: "24:00:00",
        endTime: "24:00:00",
        color: COLOUR_SLEEP
      },
      {
        daysOfWeek,
        display,
        startTime: "0:00:00",
        endTime: "8:30:00",
        color: COLOUR_REST
      },
      {
        daysOfWeek,
        display,
        startTime: "23:00:00",
        endTime: "24:00:00",
        color: COLOUR_REST
      }
    ]
  },
  source: {
    noteSources: [new Src(EVENT_SRC)],
    // NOTE default path where note will be created
    defaultCreatePath: PLACE_FOR_CREATING_NOTE
  }
};
var VIEW_TYPE = "my-obsidian-calendar-plugin";
var TEXT_DONE = "\u{1F7E2}done";
var TEXT_IN_PROGRESS = "\u{1F535}in progress";
var TEXT_SOON = "\u{1F7E3}soon";
var TEXT_CHILD_IN_PROGRESS = "\u{1F7E1}\u{1F7E6}child in progress";
var TEXT_BLOCKED = "\u{1F7E1}blocked";
var FORMAT_DAY = "d";
var FORMAT_HOUR = "h";
var FORMAT_MINUTE = "m";
var BACKGROUND_COLOUR = {
  hue: {
    shift: 0,
    min: 0,
    max: 360
  },
  saturation: {
    shift: 0,
    min: 70,
    max: 90
  },
  lightness: {
    shift: 0,
    min: 30,
    max: 50
  }
};
var MillisecsInSecond = 1e3;
var SecsInMinute = 60;
var MinutesInHour = 60;
var HoursInDay = 24;
var MillisecsInMinute = MillisecsInSecond * SecsInMinute;
var MillisecsInHour = MillisecsInMinute * MinutesInHour;
var MillisecsInDay = MillisecsInHour * HoursInDay;

// src/util.ts
var import_obsidian_dataview = __toESM(require_lib());
var SLEEP_TIME = 1e3;
var dv = (0, import_obsidian_dataview.getAPI)();
function pathToFileWithoutFileName(path) {
  const path_separator = path.lastIndexOf("/");
  if (path_separator !== -1)
    return path.slice(0, path_separator);
  return "";
}
function IDateToCalendarEvent(args) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
  const structure = {
    start: new Date(args.ff_date),
    allDay: false
  };
  if (args.ff_duration) {
    structure.start.setHours(((_b = (_a = args.ff_timeStart) == null ? void 0 : _a.values) == null ? void 0 : _b.hours) || 0);
    structure.start.setMinutes(((_d = (_c = args.ff_timeStart) == null ? void 0 : _c.values) == null ? void 0 : _d.minutes) || 0);
    let tmpTime = new Date(structure.start);
    if (((_f = (_e = args.ff_duration) == null ? void 0 : _e.values) == null ? void 0 : _f.minutes) || ((_h = (_g = args.ff_duration) == null ? void 0 : _g.values) == null ? void 0 : _h.hours) || ((_j = (_i = args.ff_duration) == null ? void 0 : _i.values) == null ? void 0 : _j.days)) {
      const duration = args.ff_duration.values;
      tmpTime.setMinutes(
        tmpTime.getMinutes() + (duration.minutes || 0)
      );
      tmpTime.setHours(
        tmpTime.getHours() + (duration.hours || 0)
      );
      tmpTime.setDate(
        tmpTime.getDate() + (duration.days || 0)
      );
    } else {
      structure.allDay = true;
    }
    if (!((_k = args.ff_timeStart) == null ? void 0 : _k.values))
      structure.allDay = true;
    structure.end = tmpTime;
  } else if (args.ff_duration) {
    structure.allDay = true;
  } else
    structure.allDay = true;
  return structure;
}
function CalendarEventToIDate(event) {
  const { start, end, allDay } = event;
  start.setMinutes(
    start.getMinutes() - start.getTimezoneOffset()
  );
  const result = {
    ff_duration: "",
    ff_timeStart: "",
    ff_date: new Date(start)
  };
  start.setMinutes(
    start.getMinutes() + start.getTimezoneOffset()
  );
  let srcMillisec = end ? end - start : MillisecsInHour;
  if (allDay) {
    result["ff_timeStart"] = "";
    if (srcMillisec <= MillisecsInDay)
      srcMillisec = 0;
  } else
    result["ff_timeStart"] = start.getHours() + "h" + start.getMinutes() + "m";
  result["ff_duration"] = millisecToString(srcMillisec);
  return result;
}
function getTicksFromText(text) {
  var _a, _b, _c, _d, _e;
  const result = [];
  const regExpTicks = /\[t::.+\]/gm;
  const matches = text.match(regExpTicks);
  if (matches)
    for (let match of matches) {
      const args = match.slice(1, -1).split("::")[1].split(",");
      if (!args)
        continue;
      const name = (_a = args[0]) == null ? void 0 : _a.trim();
      const ff_date = dv.date((_b = args[1]) == null ? void 0 : _b.trim());
      const ff_timeStart = dv.duration((_c = args[2]) == null ? void 0 : _c.trim());
      const tempDuration = (_d = args[3]) == null ? void 0 : _d.trim();
      const ff_duration = tempDuration == "x" ? "x" : dv.duration((_e = args[3]) == null ? void 0 : _e.trim());
      if (name == "")
        continue;
      result.push(
        { name, ff_date, ff_timeStart, ff_duration }
      );
    }
  return result;
}
function millisecToString(millisec) {
  const days = Math.floor(
    millisec / MillisecsInDay
  );
  millisec -= days * MillisecsInDay;
  const hours = Math.floor(
    millisec / MillisecsInHour
  );
  millisec -= hours * MillisecsInHour;
  const minutes = Math.floor(
    millisec / MillisecsInMinute
  );
  millisec -= minutes * MillisecsInMinute;
  let resString = "";
  if (days)
    resString += days.toString() + FORMAT_DAY;
  if (hours)
    resString += hours.toString() + FORMAT_HOUR;
  if (minutes)
    resString += minutes.toString() + FORMAT_MINUTE;
  return resString;
}
function isEqualObj(object1, object2) {
  const keys1 = Object.keys(object1);
  const keys2 = Object.keys(object2);
  if (keys1.length !== keys2.length) {
    return false;
  }
  for (const key of keys1) {
    const val1 = object1[key];
    const val2 = object2[key];
    const areObjects = isObject(val1) && isObject(val2);
    if (areObjects && !isEqualObj(val1, val2) || !areObjects && val1 !== val2) {
      return false;
    }
  }
  return true;
}
function isObject(object) {
  return object != null && typeof object === "object";
}
function templateIDTick(path, tickName) {
  return path + tickName;
}
function templateNameTick(fileName, tickName) {
  return "(" + fileName + ")" + tickName;
}
function hashString(str) {
  let hash = 0;
  for (let i3 = 0; i3 < str.length; i3++) {
    hash = (hash << 5) - hash + str.charCodeAt(i3);
    hash |= 0;
  }
  return hash;
}
function toRange(src, min, max) {
  max -= min;
  src %= max + 1;
  return src + min;
}
function getColourFromPath(path) {
  const str = pathToFileWithoutFileName(path);
  const str1 = hashString([...str].filter((_3, index8) => (index8 + 1) % 3 !== 0).join(""));
  const str2 = hashString([...str].filter((_3, index8) => (index8 + 2) % 3 !== 0).join(""));
  const str3 = hashString([...str].filter((_3, index8) => (index8 + 3) % 3 !== 0).join(""));
  const hue = toRange(
    str1 + BACKGROUND_COLOUR.hue.shift,
    BACKGROUND_COLOUR.hue.min,
    BACKGROUND_COLOUR.hue.max
  );
  const saturation = toRange(
    str2 + BACKGROUND_COLOUR.saturation.shift,
    BACKGROUND_COLOUR.saturation.min,
    BACKGROUND_COLOUR.saturation.max
  );
  const lightness = toRange(
    str3 + BACKGROUND_COLOUR.lightness.shift,
    BACKGROUND_COLOUR.lightness.min,
    BACKGROUND_COLOUR.lightness.max
  );
  return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
}
async function waitDvInit() {
  while (!dv.index.initialized)
    await sleep(SLEEP_TIME);
}
async function getNotesWithoutParent(src) {
  await waitDvInit();
  const child = dv.pages(`"${src}"`).where(
    (page) => !page.ff_parent
  ).array();
  return child;
}
async function getProgress(cache, noteManager, page) {
  const result = { done: 0, all: 0 };
  await waitDvInit();
  const pages = /* @__PURE__ */ new Set();
  const stack = [page.file.path];
  while (stack.length > 0) {
    const path = stack.pop();
    const page2 = cache.getPage(path);
    const meta = dv.page(path);
    if (!page2 || !meta)
      continue;
    const tasks = noteManager.getTaskCount(page2);
    result.all += tasks.all;
    result.done += tasks.done;
    const inlinks = meta.file.inlinks.array();
    if (page2.ff_status) {
      ++result.all;
      if (page2.ff_status == TEXT_DONE)
        ++result.done;
    }
    for (let inlink of inlinks) {
      if (pages.has(inlink.path))
        continue;
      pages.add(inlink.path);
      stack.push(inlink.path);
    }
  }
  return result;
}
async function getChildNotePaths(path) {
  await waitDvInit();
  const meta = dv.page(path);
  const inlinks = meta == null ? void 0 : meta.file.inlinks.array();
  const result = [];
  for (let inlink of inlinks) {
    result.push(inlink.path);
  }
  return result;
}
async function getParentNote(page) {
  await waitDvInit();
  const meta = dv.page(page.file.path);
  const outlinks = meta == null ? void 0 : meta.file.outlinks.array();
  const result = [];
  for (let outlink of outlinks) {
    result.push(dv.page(outlink.path));
  }
  return result;
}
function safeParseInt(str) {
  const num = Number(str);
  return Number.isInteger(num) ? num : NaN;
}
function timeAdd(start, duration) {
  const dur = duration.as("minutes");
  const result = new Date(start);
  result.setMinutes(result.getMinutes() + dur);
  return result;
}

// node_modules/@fullcalendar/core/node_modules/preact/dist/preact.module.js
var n;
var l;
var u;
var i;
var t;
var r;
var o;
var f;
var e;
var c = {};
var s = [];
var a = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
function h(n2, l3) {
  for (var u3 in l3)
    n2[u3] = l3[u3];
  return n2;
}
function v(n2) {
  var l3 = n2.parentNode;
  l3 && l3.removeChild(n2);
}
function y(l3, u3, i3) {
  var t3, r3, o2, f3 = {};
  for (o2 in u3)
    "key" == o2 ? t3 = u3[o2] : "ref" == o2 ? r3 = u3[o2] : f3[o2] = u3[o2];
  if (arguments.length > 2 && (f3.children = arguments.length > 3 ? n.call(arguments, 2) : i3), "function" == typeof l3 && null != l3.defaultProps)
    for (o2 in l3.defaultProps)
      void 0 === f3[o2] && (f3[o2] = l3.defaultProps[o2]);
  return p(l3, f3, t3, r3, null);
}
function p(n2, i3, t3, r3, o2) {
  var f3 = { type: n2, props: i3, key: t3, ref: r3, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: null == o2 ? ++u : o2 };
  return null == o2 && null != l.vnode && l.vnode(f3), f3;
}
function d() {
  return { current: null };
}
function _(n2) {
  return n2.children;
}
function k(n2, l3, u3, i3, t3) {
  var r3;
  for (r3 in u3)
    "children" === r3 || "key" === r3 || r3 in l3 || g(n2, r3, null, u3[r3], i3);
  for (r3 in l3)
    t3 && "function" != typeof l3[r3] || "children" === r3 || "key" === r3 || "value" === r3 || "checked" === r3 || u3[r3] === l3[r3] || g(n2, r3, l3[r3], u3[r3], i3);
}
function b(n2, l3, u3) {
  "-" === l3[0] ? n2.setProperty(l3, null == u3 ? "" : u3) : n2[l3] = null == u3 ? "" : "number" != typeof u3 || a.test(l3) ? u3 : u3 + "px";
}
function g(n2, l3, u3, i3, t3) {
  var r3;
  n:
    if ("style" === l3)
      if ("string" == typeof u3)
        n2.style.cssText = u3;
      else {
        if ("string" == typeof i3 && (n2.style.cssText = i3 = ""), i3)
          for (l3 in i3)
            u3 && l3 in u3 || b(n2.style, l3, "");
        if (u3)
          for (l3 in u3)
            i3 && u3[l3] === i3[l3] || b(n2.style, l3, u3[l3]);
      }
    else if ("o" === l3[0] && "n" === l3[1])
      r3 = l3 !== (l3 = l3.replace(/Capture$/, "")), l3 = l3.toLowerCase() in n2 ? l3.toLowerCase().slice(2) : l3.slice(2), n2.l || (n2.l = {}), n2.l[l3 + r3] = u3, u3 ? i3 || n2.addEventListener(l3, r3 ? w : m, r3) : n2.removeEventListener(l3, r3 ? w : m, r3);
    else if ("dangerouslySetInnerHTML" !== l3) {
      if (t3)
        l3 = l3.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
      else if ("width" !== l3 && "height" !== l3 && "href" !== l3 && "list" !== l3 && "form" !== l3 && "tabIndex" !== l3 && "download" !== l3 && l3 in n2)
        try {
          n2[l3] = null == u3 ? "" : u3;
          break n;
        } catch (n3) {
        }
      "function" == typeof u3 || (null == u3 || false === u3 && -1 == l3.indexOf("-") ? n2.removeAttribute(l3) : n2.setAttribute(l3, u3));
    }
}
function m(n2) {
  t = true;
  try {
    return this.l[n2.type + false](l.event ? l.event(n2) : n2);
  } finally {
    t = false;
  }
}
function w(n2) {
  t = true;
  try {
    return this.l[n2.type + true](l.event ? l.event(n2) : n2);
  } finally {
    t = false;
  }
}
function x(n2, l3) {
  this.props = n2, this.context = l3;
}
function A(n2, l3) {
  if (null == l3)
    return n2.__ ? A(n2.__, n2.__.__k.indexOf(n2) + 1) : null;
  for (var u3; l3 < n2.__k.length; l3++)
    if (null != (u3 = n2.__k[l3]) && null != u3.__e)
      return u3.__e;
  return "function" == typeof n2.type ? A(n2) : null;
}
function P(n2) {
  var l3, u3;
  if (null != (n2 = n2.__) && null != n2.__c) {
    for (n2.__e = n2.__c.base = null, l3 = 0; l3 < n2.__k.length; l3++)
      if (null != (u3 = n2.__k[l3]) && null != u3.__e) {
        n2.__e = n2.__c.base = u3.__e;
        break;
      }
    return P(n2);
  }
}
function C(n2) {
  t ? setTimeout(n2) : f(n2);
}
function T(n2) {
  (!n2.__d && (n2.__d = true) && r.push(n2) && !$.__r++ || o !== l.debounceRendering) && ((o = l.debounceRendering) || C)($);
}
function $() {
  var n2, l3, u3, i3, t3, o2, f3, e3;
  for (r.sort(function(n3, l4) {
    return n3.__v.__b - l4.__v.__b;
  }); n2 = r.shift(); )
    n2.__d && (l3 = r.length, i3 = void 0, t3 = void 0, f3 = (o2 = (u3 = n2).__v).__e, (e3 = u3.__P) && (i3 = [], (t3 = h({}, o2)).__v = o2.__v + 1, M(e3, o2, t3, u3.__n, void 0 !== e3.ownerSVGElement, null != o2.__h ? [f3] : null, i3, null == f3 ? A(o2) : f3, o2.__h), N(i3, o2), o2.__e != f3 && P(o2)), r.length > l3 && r.sort(function(n3, l4) {
      return n3.__v.__b - l4.__v.__b;
    }));
  $.__r = 0;
}
function H(n2, l3, u3, i3, t3, r3, o2, f3, e3, a3) {
  var h3, v3, y3, d2, k3, b3, g4, m3 = i3 && i3.__k || s, w4 = m3.length;
  for (u3.__k = [], h3 = 0; h3 < l3.length; h3++)
    if (null != (d2 = u3.__k[h3] = null == (d2 = l3[h3]) || "boolean" == typeof d2 ? null : "string" == typeof d2 || "number" == typeof d2 || "bigint" == typeof d2 ? p(null, d2, null, null, d2) : Array.isArray(d2) ? p(_, { children: d2 }, null, null, null) : d2.__b > 0 ? p(d2.type, d2.props, d2.key, d2.ref ? d2.ref : null, d2.__v) : d2)) {
      if (d2.__ = u3, d2.__b = u3.__b + 1, null === (y3 = m3[h3]) || y3 && d2.key == y3.key && d2.type === y3.type)
        m3[h3] = void 0;
      else
        for (v3 = 0; v3 < w4; v3++) {
          if ((y3 = m3[v3]) && d2.key == y3.key && d2.type === y3.type) {
            m3[v3] = void 0;
            break;
          }
          y3 = null;
        }
      M(n2, d2, y3 = y3 || c, t3, r3, o2, f3, e3, a3), k3 = d2.__e, (v3 = d2.ref) && y3.ref != v3 && (g4 || (g4 = []), y3.ref && g4.push(y3.ref, null, d2), g4.push(v3, d2.__c || k3, d2)), null != k3 ? (null == b3 && (b3 = k3), "function" == typeof d2.type && d2.__k === y3.__k ? d2.__d = e3 = I(d2, e3, n2) : e3 = z(n2, d2, y3, m3, k3, e3), "function" == typeof u3.type && (u3.__d = e3)) : e3 && y3.__e == e3 && e3.parentNode != n2 && (e3 = A(y3));
    }
  for (u3.__e = b3, h3 = w4; h3--; )
    null != m3[h3] && ("function" == typeof u3.type && null != m3[h3].__e && m3[h3].__e == u3.__d && (u3.__d = L(i3).nextSibling), q(m3[h3], m3[h3]));
  if (g4)
    for (h3 = 0; h3 < g4.length; h3++)
      S(g4[h3], g4[++h3], g4[++h3]);
}
function I(n2, l3, u3) {
  for (var i3, t3 = n2.__k, r3 = 0; t3 && r3 < t3.length; r3++)
    (i3 = t3[r3]) && (i3.__ = n2, l3 = "function" == typeof i3.type ? I(i3, l3, u3) : z(u3, i3, i3, t3, i3.__e, l3));
  return l3;
}
function j(n2, l3) {
  return l3 = l3 || [], null == n2 || "boolean" == typeof n2 || (Array.isArray(n2) ? n2.some(function(n3) {
    j(n3, l3);
  }) : l3.push(n2)), l3;
}
function z(n2, l3, u3, i3, t3, r3) {
  var o2, f3, e3;
  if (void 0 !== l3.__d)
    o2 = l3.__d, l3.__d = void 0;
  else if (null == u3 || t3 != r3 || null == t3.parentNode)
    n:
      if (null == r3 || r3.parentNode !== n2)
        n2.appendChild(t3), o2 = null;
      else {
        for (f3 = r3, e3 = 0; (f3 = f3.nextSibling) && e3 < i3.length; e3 += 1)
          if (f3 == t3)
            break n;
        n2.insertBefore(t3, r3), o2 = r3;
      }
  return void 0 !== o2 ? o2 : t3.nextSibling;
}
function L(n2) {
  var l3, u3, i3;
  if (null == n2.type || "string" == typeof n2.type)
    return n2.__e;
  if (n2.__k) {
    for (l3 = n2.__k.length - 1; l3 >= 0; l3--)
      if ((u3 = n2.__k[l3]) && (i3 = L(u3)))
        return i3;
  }
  return null;
}
function M(n2, u3, i3, t3, r3, o2, f3, e3, c3) {
  var s3, a3, v3, y3, p3, d2, k3, b3, g4, m3, w4, A3, P3, C3, T4, $3 = u3.type;
  if (void 0 !== u3.constructor)
    return null;
  null != i3.__h && (c3 = i3.__h, e3 = u3.__e = i3.__e, u3.__h = null, o2 = [e3]), (s3 = l.__b) && s3(u3);
  try {
    n:
      if ("function" == typeof $3) {
        if (b3 = u3.props, g4 = (s3 = $3.contextType) && t3[s3.__c], m3 = s3 ? g4 ? g4.props.value : s3.__ : t3, i3.__c ? k3 = (a3 = u3.__c = i3.__c).__ = a3.__E : ("prototype" in $3 && $3.prototype.render ? u3.__c = a3 = new $3(b3, m3) : (u3.__c = a3 = new x(b3, m3), a3.constructor = $3, a3.render = B), g4 && g4.sub(a3), a3.props = b3, a3.state || (a3.state = {}), a3.context = m3, a3.__n = t3, v3 = a3.__d = true, a3.__h = [], a3._sb = []), null == a3.__s && (a3.__s = a3.state), null != $3.getDerivedStateFromProps && (a3.__s == a3.state && (a3.__s = h({}, a3.__s)), h(a3.__s, $3.getDerivedStateFromProps(b3, a3.__s))), y3 = a3.props, p3 = a3.state, a3.__v = u3, v3)
          null == $3.getDerivedStateFromProps && null != a3.componentWillMount && a3.componentWillMount(), null != a3.componentDidMount && a3.__h.push(a3.componentDidMount);
        else {
          if (null == $3.getDerivedStateFromProps && b3 !== y3 && null != a3.componentWillReceiveProps && a3.componentWillReceiveProps(b3, m3), !a3.__e && null != a3.shouldComponentUpdate && false === a3.shouldComponentUpdate(b3, a3.__s, m3) || u3.__v === i3.__v) {
            for (u3.__v !== i3.__v && (a3.props = b3, a3.state = a3.__s, a3.__d = false), u3.__e = i3.__e, u3.__k = i3.__k, u3.__k.forEach(function(n3) {
              n3 && (n3.__ = u3);
            }), w4 = 0; w4 < a3._sb.length; w4++)
              a3.__h.push(a3._sb[w4]);
            a3._sb = [], a3.__h.length && f3.push(a3);
            break n;
          }
          null != a3.componentWillUpdate && a3.componentWillUpdate(b3, a3.__s, m3), null != a3.componentDidUpdate && a3.__h.push(function() {
            a3.componentDidUpdate(y3, p3, d2);
          });
        }
        if (a3.context = m3, a3.props = b3, a3.__P = n2, A3 = l.__r, P3 = 0, "prototype" in $3 && $3.prototype.render) {
          for (a3.state = a3.__s, a3.__d = false, A3 && A3(u3), s3 = a3.render(a3.props, a3.state, a3.context), C3 = 0; C3 < a3._sb.length; C3++)
            a3.__h.push(a3._sb[C3]);
          a3._sb = [];
        } else
          do {
            a3.__d = false, A3 && A3(u3), s3 = a3.render(a3.props, a3.state, a3.context), a3.state = a3.__s;
          } while (a3.__d && ++P3 < 25);
        a3.state = a3.__s, null != a3.getChildContext && (t3 = h(h({}, t3), a3.getChildContext())), v3 || null == a3.getSnapshotBeforeUpdate || (d2 = a3.getSnapshotBeforeUpdate(y3, p3)), T4 = null != s3 && s3.type === _ && null == s3.key ? s3.props.children : s3, H(n2, Array.isArray(T4) ? T4 : [T4], u3, i3, t3, r3, o2, f3, e3, c3), a3.base = u3.__e, u3.__h = null, a3.__h.length && f3.push(a3), k3 && (a3.__E = a3.__ = null), a3.__e = false;
      } else
        null == o2 && u3.__v === i3.__v ? (u3.__k = i3.__k, u3.__e = i3.__e) : u3.__e = O(i3.__e, u3, i3, t3, r3, o2, f3, c3);
    (s3 = l.diffed) && s3(u3);
  } catch (n3) {
    u3.__v = null, (c3 || null != o2) && (u3.__e = e3, u3.__h = !!c3, o2[o2.indexOf(e3)] = null), l.__e(n3, u3, i3);
  }
}
function N(n2, u3) {
  l.__c && l.__c(u3, n2), n2.some(function(u4) {
    try {
      n2 = u4.__h, u4.__h = [], n2.some(function(n3) {
        n3.call(u4);
      });
    } catch (n3) {
      l.__e(n3, u4.__v);
    }
  });
}
function O(l3, u3, i3, t3, r3, o2, f3, e3) {
  var s3, a3, h3, y3 = i3.props, p3 = u3.props, d2 = u3.type, _3 = 0;
  if ("svg" === d2 && (r3 = true), null != o2) {
    for (; _3 < o2.length; _3++)
      if ((s3 = o2[_3]) && "setAttribute" in s3 == !!d2 && (d2 ? s3.localName === d2 : 3 === s3.nodeType)) {
        l3 = s3, o2[_3] = null;
        break;
      }
  }
  if (null == l3) {
    if (null === d2)
      return document.createTextNode(p3);
    l3 = r3 ? document.createElementNS("http://www.w3.org/2000/svg", d2) : document.createElement(d2, p3.is && p3), o2 = null, e3 = false;
  }
  if (null === d2)
    y3 === p3 || e3 && l3.data === p3 || (l3.data = p3);
  else {
    if (o2 = o2 && n.call(l3.childNodes), a3 = (y3 = i3.props || c).dangerouslySetInnerHTML, h3 = p3.dangerouslySetInnerHTML, !e3) {
      if (null != o2)
        for (y3 = {}, _3 = 0; _3 < l3.attributes.length; _3++)
          y3[l3.attributes[_3].name] = l3.attributes[_3].value;
      (h3 || a3) && (h3 && (a3 && h3.__html == a3.__html || h3.__html === l3.innerHTML) || (l3.innerHTML = h3 && h3.__html || ""));
    }
    if (k(l3, p3, y3, r3, e3), h3)
      u3.__k = [];
    else if (_3 = u3.props.children, H(l3, Array.isArray(_3) ? _3 : [_3], u3, i3, t3, r3 && "foreignObject" !== d2, o2, f3, o2 ? o2[0] : i3.__k && A(i3, 0), e3), null != o2)
      for (_3 = o2.length; _3--; )
        null != o2[_3] && v(o2[_3]);
    e3 || ("value" in p3 && void 0 !== (_3 = p3.value) && (_3 !== l3.value || "progress" === d2 && !_3 || "option" === d2 && _3 !== y3.value) && g(l3, "value", _3, y3.value, false), "checked" in p3 && void 0 !== (_3 = p3.checked) && _3 !== l3.checked && g(l3, "checked", _3, y3.checked, false));
  }
  return l3;
}
function S(n2, u3, i3) {
  try {
    "function" == typeof n2 ? n2(u3) : n2.current = u3;
  } catch (n3) {
    l.__e(n3, i3);
  }
}
function q(n2, u3, i3) {
  var t3, r3;
  if (l.unmount && l.unmount(n2), (t3 = n2.ref) && (t3.current && t3.current !== n2.__e || S(t3, null, u3)), null != (t3 = n2.__c)) {
    if (t3.componentWillUnmount)
      try {
        t3.componentWillUnmount();
      } catch (n3) {
        l.__e(n3, u3);
      }
    t3.base = t3.__P = null, n2.__c = void 0;
  }
  if (t3 = n2.__k)
    for (r3 = 0; r3 < t3.length; r3++)
      t3[r3] && q(t3[r3], u3, i3 || "function" != typeof n2.type);
  i3 || null == n2.__e || v(n2.__e), n2.__ = n2.__e = n2.__d = void 0;
}
function B(n2, l3, u3) {
  return this.constructor(n2, u3);
}
function D(u3, i3, t3) {
  var r3, o2, f3;
  l.__ && l.__(u3, i3), o2 = (r3 = "function" == typeof t3) ? null : t3 && t3.__k || i3.__k, f3 = [], M(i3, u3 = (!r3 && t3 || i3).__k = y(_, null, [u3]), o2 || c, c, void 0 !== i3.ownerSVGElement, !r3 && t3 ? [t3] : o2 ? null : i3.firstChild ? n.call(i3.childNodes) : null, f3, !r3 && t3 ? t3 : o2 ? o2.__e : i3.firstChild, r3), N(f3, u3);
}
function G(n2, l3) {
  var u3 = { __c: l3 = "__cC" + e++, __: n2, Consumer: function(n3, l4) {
    return n3.children(l4);
  }, Provider: function(n3) {
    var u4, i3;
    return this.getChildContext || (u4 = [], (i3 = {})[l3] = this, this.getChildContext = function() {
      return i3;
    }, this.shouldComponentUpdate = function(n4) {
      this.props.value !== n4.value && u4.some(function(n5) {
        n5.__e = true, T(n5);
      });
    }, this.sub = function(n4) {
      u4.push(n4);
      var l4 = n4.componentWillUnmount;
      n4.componentWillUnmount = function() {
        u4.splice(u4.indexOf(n4), 1), l4 && l4.call(n4);
      };
    }), n3.children;
  } };
  return u3.Provider.__ = u3.Consumer.contextType = u3;
}
n = s.slice, l = { __e: function(n2, l3, u3, i3) {
  for (var t3, r3, o2; l3 = l3.__; )
    if ((t3 = l3.__c) && !t3.__)
      try {
        if ((r3 = t3.constructor) && null != r3.getDerivedStateFromError && (t3.setState(r3.getDerivedStateFromError(n2)), o2 = t3.__d), null != t3.componentDidCatch && (t3.componentDidCatch(n2, i3 || {}), o2 = t3.__d), o2)
          return t3.__E = t3;
      } catch (l4) {
        n2 = l4;
      }
  throw n2;
} }, u = 0, i = function(n2) {
  return null != n2 && void 0 === n2.constructor;
}, t = false, x.prototype.setState = function(n2, l3) {
  var u3;
  u3 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = h({}, this.state), "function" == typeof n2 && (n2 = n2(h({}, u3), this.props)), n2 && h(u3, n2), null != n2 && this.__v && (l3 && this._sb.push(l3), T(this));
}, x.prototype.forceUpdate = function(n2) {
  this.__v && (this.__e = true, n2 && this.__h.push(n2), T(this));
}, x.prototype.render = _, r = [], f = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, $.__r = 0, e = 0;

// node_modules/@fullcalendar/core/node_modules/preact/hooks/dist/hooks.module.js
var t2;
var r2;
var u2;
var i2;
var f2 = [];
var c2 = [];
var e2 = l.__b;
var a2 = l.__r;
var v2 = l.diffed;
var l2 = l.__c;
var m2 = l.unmount;
function b2() {
  for (var t3; t3 = f2.shift(); )
    if (t3.__P && t3.__H)
      try {
        t3.__H.__h.forEach(k2), t3.__H.__h.forEach(w2), t3.__H.__h = [];
      } catch (r3) {
        t3.__H.__h = [], l.__e(r3, t3.__v);
      }
}
l.__b = function(n2) {
  r2 = null, e2 && e2(n2);
}, l.__r = function(n2) {
  a2 && a2(n2), t2 = 0;
  var i3 = (r2 = n2.__c).__H;
  i3 && (u2 === r2 ? (i3.__h = [], r2.__h = [], i3.__.forEach(function(n3) {
    n3.__N && (n3.__ = n3.__N), n3.__V = c2, n3.__N = n3.i = void 0;
  })) : (i3.__h.forEach(k2), i3.__h.forEach(w2), i3.__h = [])), u2 = r2;
}, l.diffed = function(t3) {
  v2 && v2(t3);
  var o2 = t3.__c;
  o2 && o2.__H && (o2.__H.__h.length && (1 !== f2.push(o2) && i2 === l.requestAnimationFrame || ((i2 = l.requestAnimationFrame) || j2)(b2)), o2.__H.__.forEach(function(n2) {
    n2.i && (n2.__H = n2.i), n2.__V !== c2 && (n2.__ = n2.__V), n2.i = void 0, n2.__V = c2;
  })), u2 = r2 = null;
}, l.__c = function(t3, r3) {
  r3.some(function(t4) {
    try {
      t4.__h.forEach(k2), t4.__h = t4.__h.filter(function(n2) {
        return !n2.__ || w2(n2);
      });
    } catch (u3) {
      r3.some(function(n2) {
        n2.__h && (n2.__h = []);
      }), r3 = [], l.__e(u3, t4.__v);
    }
  }), l2 && l2(t3, r3);
}, l.unmount = function(t3) {
  m2 && m2(t3);
  var r3, u3 = t3.__c;
  u3 && u3.__H && (u3.__H.__.forEach(function(n2) {
    try {
      k2(n2);
    } catch (n3) {
      r3 = n3;
    }
  }), u3.__H = void 0, r3 && l.__e(r3, u3.__v));
};
var g2 = "function" == typeof requestAnimationFrame;
function j2(n2) {
  var t3, r3 = function() {
    clearTimeout(u3), g2 && cancelAnimationFrame(t3), setTimeout(n2);
  }, u3 = setTimeout(r3, 100);
  g2 && (t3 = requestAnimationFrame(r3));
}
function k2(n2) {
  var t3 = r2, u3 = n2.__c;
  "function" == typeof u3 && (n2.__c = void 0, u3()), r2 = t3;
}
function w2(n2) {
  var t3 = r2;
  n2.__c = n2.__(), r2 = t3;
}

// node_modules/@fullcalendar/core/node_modules/preact/compat/dist/compat.module.js
function g3(n2, t3) {
  for (var e3 in t3)
    n2[e3] = t3[e3];
  return n2;
}
function C2(n2, t3) {
  for (var e3 in n2)
    if ("__source" !== e3 && !(e3 in t3))
      return true;
  for (var r3 in t3)
    if ("__source" !== r3 && n2[r3] !== t3[r3])
      return true;
  return false;
}
function w3(n2) {
  this.props = n2;
}
(w3.prototype = new x()).isPureReactComponent = true, w3.prototype.shouldComponentUpdate = function(n2, t3) {
  return C2(this.props, n2) || C2(this.state, t3);
};
var x3 = l.__b;
l.__b = function(n2) {
  n2.type && n2.type.__f && n2.ref && (n2.props.ref = n2.ref, n2.ref = null), x3 && x3(n2);
};
var N2 = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.forward_ref") || 3911;
var T3 = l.__e;
l.__e = function(n2, t3, e3, r3) {
  if (n2.then) {
    for (var u3, o2 = t3; o2 = o2.__; )
      if ((u3 = o2.__c) && u3.__c)
        return null == t3.__e && (t3.__e = e3.__e, t3.__k = e3.__k), u3.__c(n2, t3);
  }
  T3(n2, t3, e3, r3);
};
var I2 = l.unmount;
function L2(n2, t3, e3) {
  return n2 && (n2.__c && n2.__c.__H && (n2.__c.__H.__.forEach(function(n3) {
    "function" == typeof n3.__c && n3.__c();
  }), n2.__c.__H = null), null != (n2 = g3({}, n2)).__c && (n2.__c.__P === e3 && (n2.__c.__P = t3), n2.__c = null), n2.__k = n2.__k && n2.__k.map(function(n3) {
    return L2(n3, t3, e3);
  })), n2;
}
function U(n2, t3, e3) {
  return n2 && (n2.__v = null, n2.__k = n2.__k && n2.__k.map(function(n3) {
    return U(n3, t3, e3);
  }), n2.__c && n2.__c.__P === t3 && (n2.__e && e3.insertBefore(n2.__e, n2.__d), n2.__c.__e = true, n2.__c.__P = e3)), n2;
}
function D2() {
  this.__u = 0, this.t = null, this.__b = null;
}
function F3(n2) {
  var t3 = n2.__.__c;
  return t3 && t3.__a && t3.__a(n2);
}
function V2() {
  this.u = null, this.o = null;
}
l.unmount = function(n2) {
  var t3 = n2.__c;
  t3 && t3.__R && t3.__R(), t3 && true === n2.__h && (n2.type = null), I2 && I2(n2);
}, (D2.prototype = new x()).__c = function(n2, t3) {
  var e3 = t3.__c, r3 = this;
  null == r3.t && (r3.t = []), r3.t.push(e3);
  var u3 = F3(r3.__v), o2 = false, i3 = function() {
    o2 || (o2 = true, e3.__R = null, u3 ? u3(l3) : l3());
  };
  e3.__R = i3;
  var l3 = function() {
    if (!--r3.__u) {
      if (r3.state.__a) {
        var n3 = r3.state.__a;
        r3.__v.__k[0] = U(n3, n3.__c.__P, n3.__c.__O);
      }
      var t4;
      for (r3.setState({ __a: r3.__b = null }); t4 = r3.t.pop(); )
        t4.forceUpdate();
    }
  }, c3 = true === t3.__h;
  r3.__u++ || c3 || r3.setState({ __a: r3.__b = r3.__v.__k[0] }), n2.then(i3, i3);
}, D2.prototype.componentWillUnmount = function() {
  this.t = [];
}, D2.prototype.render = function(n2, e3) {
  if (this.__b) {
    if (this.__v.__k) {
      var r3 = document.createElement("div"), o2 = this.__v.__k[0].__c;
      this.__v.__k[0] = L2(this.__b, r3, o2.__O = o2.__P);
    }
    this.__b = null;
  }
  var i3 = e3.__a && y(_, null, n2.fallback);
  return i3 && (i3.__h = null), [y(_, null, e3.__a ? null : n2.children), i3];
};
var W = function(n2, t3, e3) {
  if (++e3[1] === e3[0] && n2.o.delete(t3), n2.props.revealOrder && ("t" !== n2.props.revealOrder[0] || !n2.o.size))
    for (e3 = n2.u; e3; ) {
      for (; e3.length > 3; )
        e3.pop()();
      if (e3[1] < e3[0])
        break;
      n2.u = e3 = e3[2];
    }
};
function P2(n2) {
  return this.getChildContext = function() {
    return n2.context;
  }, n2.children;
}
function $2(n2) {
  var e3 = this, r3 = n2.i;
  e3.componentWillUnmount = function() {
    D(null, e3.l), e3.l = null, e3.i = null;
  }, e3.i && e3.i !== r3 && e3.componentWillUnmount(), n2.__v ? (e3.l || (e3.i = r3, e3.l = { nodeType: 1, parentNode: r3, childNodes: [], appendChild: function(n3) {
    this.childNodes.push(n3), e3.i.appendChild(n3);
  }, insertBefore: function(n3, t3) {
    this.childNodes.push(n3), e3.i.appendChild(n3);
  }, removeChild: function(n3) {
    this.childNodes.splice(this.childNodes.indexOf(n3) >>> 1, 1), e3.i.removeChild(n3);
  } }), D(y(P2, { context: e3.context }, n2.__v), e3.l)) : e3.l && e3.componentWillUnmount();
}
function j3(n2, e3) {
  var r3 = y($2, { __v: n2, i: e3 });
  return r3.containerInfo = e3, r3;
}
(V2.prototype = new x()).__a = function(n2) {
  var t3 = this, e3 = F3(t3.__v), r3 = t3.o.get(n2);
  return r3[0]++, function(u3) {
    var o2 = function() {
      t3.props.revealOrder ? (r3.push(u3), W(t3, n2, r3)) : u3();
    };
    e3 ? e3(o2) : o2();
  };
}, V2.prototype.render = function(n2) {
  this.u = null, this.o = /* @__PURE__ */ new Map();
  var t3 = j(n2.children);
  n2.revealOrder && "b" === n2.revealOrder[0] && t3.reverse();
  for (var e3 = t3.length; e3--; )
    this.o.set(t3[e3], this.u = [1, 0, this.u]);
  return n2.children;
}, V2.prototype.componentDidUpdate = V2.prototype.componentDidMount = function() {
  var n2 = this;
  this.o.forEach(function(t3, e3) {
    W(n2, e3, t3);
  });
};
var z2 = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103;
var B2 = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;
var H2 = "undefined" != typeof document;
var Z = function(n2) {
  return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/i : /fil|che|ra/i).test(n2);
};
x.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function(t3) {
  Object.defineProperty(x.prototype, t3, { configurable: true, get: function() {
    return this["UNSAFE_" + t3];
  }, set: function(n2) {
    Object.defineProperty(this, t3, { configurable: true, writable: true, value: n2 });
  } });
});
var G2 = l.event;
function J() {
}
function K() {
  return this.cancelBubble;
}
function Q() {
  return this.defaultPrevented;
}
l.event = function(n2) {
  return G2 && (n2 = G2(n2)), n2.persist = J, n2.isPropagationStopped = K, n2.isDefaultPrevented = Q, n2.nativeEvent = n2;
};
var X;
var nn = { configurable: true, get: function() {
  return this.class;
} };
var tn = l.vnode;
l.vnode = function(n2) {
  var t3 = n2.type, e3 = n2.props, u3 = e3;
  if ("string" == typeof t3) {
    var o2 = -1 === t3.indexOf("-");
    for (var i3 in u3 = {}, e3) {
      var l3 = e3[i3];
      H2 && "children" === i3 && "noscript" === t3 || "value" === i3 && "defaultValue" in e3 && null == l3 || ("defaultValue" === i3 && "value" in e3 && null == e3.value ? i3 = "value" : "download" === i3 && true === l3 ? l3 = "" : /ondoubleclick/i.test(i3) ? i3 = "ondblclick" : /^onchange(textarea|input)/i.test(i3 + t3) && !Z(e3.type) ? i3 = "oninput" : /^onfocus$/i.test(i3) ? i3 = "onfocusin" : /^onblur$/i.test(i3) ? i3 = "onfocusout" : /^on(Ani|Tra|Tou|BeforeInp|Compo)/.test(i3) ? i3 = i3.toLowerCase() : o2 && B2.test(i3) ? i3 = i3.replace(/[A-Z0-9]/g, "-$&").toLowerCase() : null === l3 && (l3 = void 0), /^oninput$/i.test(i3) && (i3 = i3.toLowerCase(), u3[i3] && (i3 = "oninputCapture")), u3[i3] = l3);
    }
    "select" == t3 && u3.multiple && Array.isArray(u3.value) && (u3.value = j(e3.children).forEach(function(n3) {
      n3.props.selected = -1 != u3.value.indexOf(n3.props.value);
    })), "select" == t3 && null != u3.defaultValue && (u3.value = j(e3.children).forEach(function(n3) {
      n3.props.selected = u3.multiple ? -1 != u3.defaultValue.indexOf(n3.props.value) : u3.defaultValue == n3.props.value;
    })), n2.props = u3, e3.class != e3.className && (nn.enumerable = "className" in e3, null != e3.className && (u3.class = e3.className), Object.defineProperty(u3, "className", nn));
  }
  n2.$$typeof = z2, tn && tn(n2);
};
var en = l.__r;
l.__r = function(n2) {
  en && en(n2), X = n2.__c;
};

// node_modules/@fullcalendar/core/internal-common.js
var styleTexts = [];
var styleEls = /* @__PURE__ */ new Map();
function injectStyles(styleText) {
  styleTexts.push(styleText);
  styleEls.forEach((styleEl) => {
    appendStylesTo(styleEl, styleText);
  });
}
function ensureElHasStyles(el) {
  if (el.isConnected && // sometimes true if SSR system simulates DOM
  el.getRootNode) {
    registerStylesRoot(el.getRootNode());
  }
}
function registerStylesRoot(rootNode) {
  let styleEl = styleEls.get(rootNode);
  if (!styleEl || !styleEl.isConnected) {
    styleEl = rootNode.querySelector("style[data-fullcalendar]");
    if (!styleEl) {
      styleEl = document.createElement("style");
      styleEl.setAttribute("data-fullcalendar", "");
      const nonce = getNonceValue();
      if (nonce) {
        styleEl.nonce = nonce;
      }
      const parentEl = rootNode === document ? document.head : rootNode;
      const insertBefore = rootNode === document ? parentEl.querySelector("script,link[rel=stylesheet],link[as=style],style") : parentEl.firstChild;
      parentEl.insertBefore(styleEl, insertBefore);
    }
    styleEls.set(rootNode, styleEl);
    hydrateStylesRoot(styleEl);
  }
}
function hydrateStylesRoot(styleEl) {
  for (const styleText of styleTexts) {
    appendStylesTo(styleEl, styleText);
  }
}
function appendStylesTo(styleEl, styleText) {
  const { sheet } = styleEl;
  const ruleCnt = sheet.cssRules.length;
  styleText.split("}").forEach((styleStr, i3) => {
    styleStr = styleStr.trim();
    if (styleStr) {
      sheet.insertRule(styleStr + "}", ruleCnt + i3);
    }
  });
}
var queriedNonceValue;
function getNonceValue() {
  if (queriedNonceValue === void 0) {
    queriedNonceValue = queryNonceValue();
  }
  return queriedNonceValue;
}
function queryNonceValue() {
  const metaWithNonce = document.querySelector('meta[name="csp-nonce"]');
  if (metaWithNonce && metaWithNonce.hasAttribute("content")) {
    return metaWithNonce.getAttribute("content");
  }
  const elWithNonce = document.querySelector("script[nonce]");
  if (elWithNonce) {
    return elWithNonce.nonce || "";
  }
  return "";
}
if (typeof document !== "undefined") {
  registerStylesRoot(document);
}
var css_248z = ':root{--fc-small-font-size:.85em;--fc-page-bg-color:#fff;--fc-neutral-bg-color:hsla(0,0%,82%,.3);--fc-neutral-text-color:grey;--fc-border-color:#ddd;--fc-button-text-color:#fff;--fc-button-bg-color:#2c3e50;--fc-button-border-color:#2c3e50;--fc-button-hover-bg-color:#1e2b37;--fc-button-hover-border-color:#1a252f;--fc-button-active-bg-color:#1a252f;--fc-button-active-border-color:#151e27;--fc-event-bg-color:#3788d8;--fc-event-border-color:#3788d8;--fc-event-text-color:#fff;--fc-event-selected-overlay-color:rgba(0,0,0,.25);--fc-more-link-bg-color:#d0d0d0;--fc-more-link-text-color:inherit;--fc-event-resizer-thickness:8px;--fc-event-resizer-dot-total-width:8px;--fc-event-resizer-dot-border-width:1px;--fc-non-business-color:hsla(0,0%,84%,.3);--fc-bg-event-color:#8fdf82;--fc-bg-event-opacity:0.3;--fc-highlight-color:rgba(188,232,241,.3);--fc-today-bg-color:rgba(255,220,40,.15);--fc-now-indicator-color:red}.fc-not-allowed,.fc-not-allowed .fc-event{cursor:not-allowed}.fc{display:flex;flex-direction:column;font-size:1em}.fc,.fc *,.fc :after,.fc :before{box-sizing:border-box}.fc table{border-collapse:collapse;border-spacing:0;font-size:1em}.fc th{text-align:center}.fc td,.fc th{padding:0;vertical-align:top}.fc a[data-navlink]{cursor:pointer}.fc a[data-navlink]:hover{text-decoration:underline}.fc-direction-ltr{direction:ltr;text-align:left}.fc-direction-rtl{direction:rtl;text-align:right}.fc-theme-standard td,.fc-theme-standard th{border:1px solid var(--fc-border-color)}.fc-liquid-hack td,.fc-liquid-hack th{position:relative}@font-face{font-family:fcicons;font-style:normal;font-weight:400;src:url("data:application/x-font-ttf;charset=utf-8;base64,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") format("truetype")}.fc-icon{speak:none;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;display:inline-block;font-family:fcicons!important;font-style:normal;font-variant:normal;font-weight:400;height:1em;line-height:1;text-align:center;text-transform:none;-moz-user-select:none;user-select:none;width:1em}.fc-icon-chevron-left:before{content:"\\e900"}.fc-icon-chevron-right:before{content:"\\e901"}.fc-icon-chevrons-left:before{content:"\\e902"}.fc-icon-chevrons-right:before{content:"\\e903"}.fc-icon-minus-square:before{content:"\\e904"}.fc-icon-plus-square:before{content:"\\e905"}.fc-icon-x:before{content:"\\e906"}.fc .fc-button{border-radius:0;font-family:inherit;font-size:inherit;line-height:inherit;margin:0;overflow:visible;text-transform:none}.fc .fc-button:focus{outline:1px dotted;outline:5px auto -webkit-focus-ring-color}.fc .fc-button{-webkit-appearance:button}.fc .fc-button:not(:disabled){cursor:pointer}.fc .fc-button{background-color:transparent;border:1px solid transparent;border-radius:.25em;display:inline-block;font-size:1em;font-weight:400;line-height:1.5;padding:.4em .65em;text-align:center;-moz-user-select:none;user-select:none;vertical-align:middle}.fc .fc-button:hover{text-decoration:none}.fc .fc-button:focus{box-shadow:0 0 0 .2rem rgba(44,62,80,.25);outline:0}.fc .fc-button:disabled{opacity:.65}.fc .fc-button-primary{background-color:var(--fc-button-bg-color);border-color:var(--fc-button-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:hover{background-color:var(--fc-button-hover-bg-color);border-color:var(--fc-button-hover-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:disabled{background-color:var(--fc-button-bg-color);border-color:var(--fc-button-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:focus{box-shadow:0 0 0 .2rem rgba(76,91,106,.5)}.fc .fc-button-primary:not(:disabled).fc-button-active,.fc .fc-button-primary:not(:disabled):active{background-color:var(--fc-button-active-bg-color);border-color:var(--fc-button-active-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:not(:disabled).fc-button-active:focus,.fc .fc-button-primary:not(:disabled):active:focus{box-shadow:0 0 0 .2rem rgba(76,91,106,.5)}.fc .fc-button .fc-icon{font-size:1.5em;vertical-align:middle}.fc .fc-button-group{display:inline-flex;position:relative;vertical-align:middle}.fc .fc-button-group>.fc-button{flex:1 1 auto;position:relative}.fc .fc-button-group>.fc-button.fc-button-active,.fc .fc-button-group>.fc-button:active,.fc .fc-button-group>.fc-button:focus,.fc .fc-button-group>.fc-button:hover{z-index:1}.fc-direction-ltr .fc-button-group>.fc-button:not(:first-child){border-bottom-left-radius:0;border-top-left-radius:0;margin-left:-1px}.fc-direction-ltr .fc-button-group>.fc-button:not(:last-child){border-bottom-right-radius:0;border-top-right-radius:0}.fc-direction-rtl .fc-button-group>.fc-button:not(:first-child){border-bottom-right-radius:0;border-top-right-radius:0;margin-right:-1px}.fc-direction-rtl .fc-button-group>.fc-button:not(:last-child){border-bottom-left-radius:0;border-top-left-radius:0}.fc .fc-toolbar{align-items:center;display:flex;justify-content:space-between}.fc .fc-toolbar.fc-header-toolbar{margin-bottom:1.5em}.fc .fc-toolbar.fc-footer-toolbar{margin-top:1.5em}.fc .fc-toolbar-title{font-size:1.75em;margin:0}.fc-direction-ltr .fc-toolbar>*>:not(:first-child){margin-left:.75em}.fc-direction-rtl .fc-toolbar>*>:not(:first-child){margin-right:.75em}.fc-direction-rtl .fc-toolbar-ltr{flex-direction:row-reverse}.fc .fc-scroller{-webkit-overflow-scrolling:touch;position:relative}.fc .fc-scroller-liquid{height:100%}.fc .fc-scroller-liquid-absolute{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-scroller-harness{direction:ltr;overflow:hidden;position:relative}.fc .fc-scroller-harness-liquid{height:100%}.fc-direction-rtl .fc-scroller-harness>.fc-scroller{direction:rtl}.fc-theme-standard .fc-scrollgrid{border:1px solid var(--fc-border-color)}.fc .fc-scrollgrid,.fc .fc-scrollgrid table{table-layout:fixed;width:100%}.fc .fc-scrollgrid table{border-left-style:hidden;border-right-style:hidden;border-top-style:hidden}.fc .fc-scrollgrid{border-bottom-width:0;border-collapse:separate;border-right-width:0}.fc .fc-scrollgrid-liquid{height:100%}.fc .fc-scrollgrid-section,.fc .fc-scrollgrid-section table,.fc .fc-scrollgrid-section>td{height:1px}.fc .fc-scrollgrid-section-liquid>td{height:100%}.fc .fc-scrollgrid-section>*{border-left-width:0;border-top-width:0}.fc .fc-scrollgrid-section-footer>*,.fc .fc-scrollgrid-section-header>*{border-bottom-width:0}.fc .fc-scrollgrid-section-body table,.fc .fc-scrollgrid-section-footer table{border-bottom-style:hidden}.fc .fc-scrollgrid-section-sticky>*{background:var(--fc-page-bg-color);position:sticky;z-index:3}.fc .fc-scrollgrid-section-header.fc-scrollgrid-section-sticky>*{top:0}.fc .fc-scrollgrid-section-footer.fc-scrollgrid-section-sticky>*{bottom:0}.fc .fc-scrollgrid-sticky-shim{height:1px;margin-bottom:-1px}.fc-sticky{position:sticky}.fc .fc-view-harness{flex-grow:1;position:relative}.fc .fc-view-harness-active>.fc-view{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-col-header-cell-cushion{display:inline-block;padding:2px 4px}.fc .fc-bg-event,.fc .fc-highlight,.fc .fc-non-business{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-non-business{background:var(--fc-non-business-color)}.fc .fc-bg-event{background:var(--fc-bg-event-color);opacity:var(--fc-bg-event-opacity)}.fc .fc-bg-event .fc-event-title{font-size:var(--fc-small-font-size);font-style:italic;margin:.5em}.fc .fc-highlight{background:var(--fc-highlight-color)}.fc .fc-cell-shaded,.fc .fc-day-disabled{background:var(--fc-neutral-bg-color)}a.fc-event,a.fc-event:hover{text-decoration:none}.fc-event.fc-event-draggable,.fc-event[href]{cursor:pointer}.fc-event .fc-event-main{position:relative;z-index:2}.fc-event-dragging:not(.fc-event-selected){opacity:.75}.fc-event-dragging.fc-event-selected{box-shadow:0 2px 7px rgba(0,0,0,.3)}.fc-event .fc-event-resizer{display:none;position:absolute;z-index:4}.fc-event-selected .fc-event-resizer,.fc-event:hover .fc-event-resizer{display:block}.fc-event-selected .fc-event-resizer{background:var(--fc-page-bg-color);border-color:inherit;border-radius:calc(var(--fc-event-resizer-dot-total-width)/2);border-style:solid;border-width:var(--fc-event-resizer-dot-border-width);height:var(--fc-event-resizer-dot-total-width);width:var(--fc-event-resizer-dot-total-width)}.fc-event-selected .fc-event-resizer:before{bottom:-20px;content:"";left:-20px;position:absolute;right:-20px;top:-20px}.fc-event-selected,.fc-event:focus{box-shadow:0 2px 5px rgba(0,0,0,.2)}.fc-event-selected:before,.fc-event:focus:before{bottom:0;content:"";left:0;position:absolute;right:0;top:0;z-index:3}.fc-event-selected:after,.fc-event:focus:after{background:var(--fc-event-selected-overlay-color);bottom:-1px;content:"";left:-1px;position:absolute;right:-1px;top:-1px;z-index:1}.fc-h-event{background-color:var(--fc-event-bg-color);border:1px solid var(--fc-event-border-color);display:block}.fc-h-event .fc-event-main{color:var(--fc-event-text-color)}.fc-h-event .fc-event-main-frame{display:flex}.fc-h-event .fc-event-time{max-width:100%;overflow:hidden}.fc-h-event .fc-event-title-container{flex-grow:1;flex-shrink:1;min-width:0}.fc-h-event .fc-event-title{display:inline-block;left:0;max-width:100%;overflow:hidden;right:0;vertical-align:top}.fc-h-event.fc-event-selected:before{bottom:-10px;top:-10px}.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-start),.fc-direction-rtl .fc-daygrid-block-event:not(.fc-event-end){border-bottom-left-radius:0;border-left-width:0;border-top-left-radius:0}.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-end),.fc-direction-rtl .fc-daygrid-block-event:not(.fc-event-start){border-bottom-right-radius:0;border-right-width:0;border-top-right-radius:0}.fc-h-event:not(.fc-event-selected) .fc-event-resizer{bottom:0;top:0;width:var(--fc-event-resizer-thickness)}.fc-direction-ltr .fc-h-event:not(.fc-event-selected) .fc-event-resizer-start,.fc-direction-rtl .fc-h-event:not(.fc-event-selected) .fc-event-resizer-end{cursor:w-resize;left:calc(var(--fc-event-resizer-thickness)*-.5)}.fc-direction-ltr .fc-h-event:not(.fc-event-selected) .fc-event-resizer-end,.fc-direction-rtl .fc-h-event:not(.fc-event-selected) .fc-event-resizer-start{cursor:e-resize;right:calc(var(--fc-event-resizer-thickness)*-.5)}.fc-h-event.fc-event-selected .fc-event-resizer{margin-top:calc(var(--fc-event-resizer-dot-total-width)*-.5);top:50%}.fc-direction-ltr .fc-h-event.fc-event-selected .fc-event-resizer-start,.fc-direction-rtl .fc-h-event.fc-event-selected .fc-event-resizer-end{left:calc(var(--fc-event-resizer-dot-total-width)*-.5)}.fc-direction-ltr .fc-h-event.fc-event-selected .fc-event-resizer-end,.fc-direction-rtl .fc-h-event.fc-event-selected .fc-event-resizer-start{right:calc(var(--fc-event-resizer-dot-total-width)*-.5)}.fc .fc-popover{box-shadow:0 2px 6px rgba(0,0,0,.15);position:absolute;z-index:9999}.fc .fc-popover-header{align-items:center;display:flex;flex-direction:row;justify-content:space-between;padding:3px 4px}.fc .fc-popover-title{margin:0 2px}.fc .fc-popover-close{cursor:pointer;font-size:1.1em;opacity:.65}.fc-theme-standard .fc-popover{background:var(--fc-page-bg-color);border:1px solid var(--fc-border-color)}.fc-theme-standard .fc-popover-header{background:var(--fc-neutral-bg-color)}';
injectStyles(css_248z);
var DelayedRunner = class {
  constructor(drainedOption) {
    this.drainedOption = drainedOption;
    this.isRunning = false;
    this.isDirty = false;
    this.pauseDepths = {};
    this.timeoutId = 0;
  }
  request(delay) {
    this.isDirty = true;
    if (!this.isPaused()) {
      this.clearTimeout();
      if (delay == null) {
        this.tryDrain();
      } else {
        this.timeoutId = setTimeout(
          // NOT OPTIMAL! TODO: look at debounce
          this.tryDrain.bind(this),
          delay
        );
      }
    }
  }
  pause(scope = "") {
    let { pauseDepths } = this;
    pauseDepths[scope] = (pauseDepths[scope] || 0) + 1;
    this.clearTimeout();
  }
  resume(scope = "", force) {
    let { pauseDepths } = this;
    if (scope in pauseDepths) {
      if (force) {
        delete pauseDepths[scope];
      } else {
        pauseDepths[scope] -= 1;
        let depth = pauseDepths[scope];
        if (depth <= 0) {
          delete pauseDepths[scope];
        }
      }
      this.tryDrain();
    }
  }
  isPaused() {
    return Object.keys(this.pauseDepths).length;
  }
  tryDrain() {
    if (!this.isRunning && !this.isPaused()) {
      this.isRunning = true;
      while (this.isDirty) {
        this.isDirty = false;
        this.drained();
      }
      this.isRunning = false;
    }
  }
  clear() {
    this.clearTimeout();
    this.isDirty = false;
    this.pauseDepths = {};
  }
  clearTimeout() {
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
      this.timeoutId = 0;
    }
  }
  drained() {
    if (this.drainedOption) {
      this.drainedOption();
    }
  }
};
function removeElement(el) {
  if (el.parentNode) {
    el.parentNode.removeChild(el);
  }
}
function elementClosest(el, selector) {
  if (el.closest) {
    return el.closest(selector);
  }
  if (!document.documentElement.contains(el)) {
    return null;
  }
  do {
    if (elementMatches(el, selector)) {
      return el;
    }
    el = el.parentElement || el.parentNode;
  } while (el !== null && el.nodeType === 1);
  return null;
}
function elementMatches(el, selector) {
  let method = el.matches || el.matchesSelector || el.msMatchesSelector;
  return method.call(el, selector);
}
function findElements(container, selector) {
  let containers = container instanceof HTMLElement ? [container] : container;
  let allMatches = [];
  for (let i3 = 0; i3 < containers.length; i3 += 1) {
    let matches = containers[i3].querySelectorAll(selector);
    for (let j4 = 0; j4 < matches.length; j4 += 1) {
      allMatches.push(matches[j4]);
    }
  }
  return allMatches;
}
var PIXEL_PROP_RE = /(top|left|right|bottom|width|height)$/i;
function applyStyle(el, props) {
  for (let propName in props) {
    applyStyleProp(el, propName, props[propName]);
  }
}
function applyStyleProp(el, name, val) {
  if (val == null) {
    el.style[name] = "";
  } else if (typeof val === "number" && PIXEL_PROP_RE.test(name)) {
    el.style[name] = `${val}px`;
  } else {
    el.style[name] = val;
  }
}
function getEventTargetViaRoot(ev) {
  var _a, _b;
  return (_b = (_a = ev.composedPath) === null || _a === void 0 ? void 0 : _a.call(ev)[0]) !== null && _b !== void 0 ? _b : ev.target;
}
var guid$1 = 0;
function getUniqueDomId() {
  guid$1 += 1;
  return "fc-dom-" + guid$1;
}
function preventDefault(ev) {
  ev.preventDefault();
}
function buildDelegationHandler(selector, handler) {
  return (ev) => {
    let matchedChild = elementClosest(ev.target, selector);
    if (matchedChild) {
      handler.call(matchedChild, ev, matchedChild);
    }
  };
}
function listenBySelector(container, eventType, selector, handler) {
  let attachedHandler = buildDelegationHandler(selector, handler);
  container.addEventListener(eventType, attachedHandler);
  return () => {
    container.removeEventListener(eventType, attachedHandler);
  };
}
function listenToHoverBySelector(container, selector, onMouseEnter, onMouseLeave) {
  let currentMatchedChild;
  return listenBySelector(container, "mouseover", selector, (mouseOverEv, matchedChild) => {
    if (matchedChild !== currentMatchedChild) {
      currentMatchedChild = matchedChild;
      onMouseEnter(mouseOverEv, matchedChild);
      let realOnMouseLeave = (mouseLeaveEv) => {
        currentMatchedChild = null;
        onMouseLeave(mouseLeaveEv, matchedChild);
        matchedChild.removeEventListener("mouseleave", realOnMouseLeave);
      };
      matchedChild.addEventListener("mouseleave", realOnMouseLeave);
    }
  });
}
var transitionEventNames = [
  "webkitTransitionEnd",
  "otransitionend",
  "oTransitionEnd",
  "msTransitionEnd",
  "transitionend"
];
function whenTransitionDone(el, callback) {
  let realCallback = (ev) => {
    callback(ev);
    transitionEventNames.forEach((eventName) => {
      el.removeEventListener(eventName, realCallback);
    });
  };
  transitionEventNames.forEach((eventName) => {
    el.addEventListener(eventName, realCallback);
  });
}
function createAriaClickAttrs(handler) {
  return Object.assign({ onClick: handler }, createAriaKeyboardAttrs(handler));
}
function createAriaKeyboardAttrs(handler) {
  return {
    tabIndex: 0,
    onKeyDown(ev) {
      if (ev.key === "Enter" || ev.key === " ") {
        handler(ev);
        ev.preventDefault();
      }
    }
  };
}
var guidNumber = 0;
function guid() {
  guidNumber += 1;
  return String(guidNumber);
}
function disableCursor() {
  document.body.classList.add("fc-not-allowed");
}
function enableCursor() {
  document.body.classList.remove("fc-not-allowed");
}
function preventSelection(el) {
  el.style.userSelect = "none";
  el.style.webkitUserSelect = "none";
  el.addEventListener("selectstart", preventDefault);
}
function allowSelection(el) {
  el.style.userSelect = "";
  el.style.webkitUserSelect = "";
  el.removeEventListener("selectstart", preventDefault);
}
function preventContextMenu(el) {
  el.addEventListener("contextmenu", preventDefault);
}
function allowContextMenu(el) {
  el.removeEventListener("contextmenu", preventDefault);
}
function parseFieldSpecs(input) {
  let specs = [];
  let tokens = [];
  let i3;
  let token;
  if (typeof input === "string") {
    tokens = input.split(/\s*,\s*/);
  } else if (typeof input === "function") {
    tokens = [input];
  } else if (Array.isArray(input)) {
    tokens = input;
  }
  for (i3 = 0; i3 < tokens.length; i3 += 1) {
    token = tokens[i3];
    if (typeof token === "string") {
      specs.push(token.charAt(0) === "-" ? { field: token.substring(1), order: -1 } : { field: token, order: 1 });
    } else if (typeof token === "function") {
      specs.push({ func: token });
    }
  }
  return specs;
}
function compareByFieldSpecs(obj0, obj1, fieldSpecs) {
  let i3;
  let cmp;
  for (i3 = 0; i3 < fieldSpecs.length; i3 += 1) {
    cmp = compareByFieldSpec(obj0, obj1, fieldSpecs[i3]);
    if (cmp) {
      return cmp;
    }
  }
  return 0;
}
function compareByFieldSpec(obj0, obj1, fieldSpec) {
  if (fieldSpec.func) {
    return fieldSpec.func(obj0, obj1);
  }
  return flexibleCompare(obj0[fieldSpec.field], obj1[fieldSpec.field]) * (fieldSpec.order || 1);
}
function flexibleCompare(a3, b3) {
  if (!a3 && !b3) {
    return 0;
  }
  if (b3 == null) {
    return -1;
  }
  if (a3 == null) {
    return 1;
  }
  if (typeof a3 === "string" || typeof b3 === "string") {
    return String(a3).localeCompare(String(b3));
  }
  return a3 - b3;
}
function padStart(val, len) {
  let s3 = String(val);
  return "000".substr(0, len - s3.length) + s3;
}
function formatWithOrdinals(formatter, args, fallbackText) {
  if (typeof formatter === "function") {
    return formatter(...args);
  }
  if (typeof formatter === "string") {
    return args.reduce((str, arg, index8) => str.replace("$" + index8, arg || ""), formatter);
  }
  return fallbackText;
}
function compareNumbers(a3, b3) {
  return a3 - b3;
}
function isInt(n2) {
  return n2 % 1 === 0;
}
function computeSmallestCellWidth(cellEl) {
  let allWidthEl = cellEl.querySelector(".fc-scrollgrid-shrink-frame");
  let contentWidthEl = cellEl.querySelector(".fc-scrollgrid-shrink-cushion");
  if (!allWidthEl) {
    throw new Error("needs fc-scrollgrid-shrink-frame className");
  }
  if (!contentWidthEl) {
    throw new Error("needs fc-scrollgrid-shrink-cushion className");
  }
  return cellEl.getBoundingClientRect().width - allWidthEl.getBoundingClientRect().width + // the cell padding+border
  contentWidthEl.getBoundingClientRect().width;
}
var INTERNAL_UNITS = ["years", "months", "days", "milliseconds"];
var PARSE_RE = /^(-?)(?:(\d+)\.)?(\d+):(\d\d)(?::(\d\d)(?:\.(\d\d\d))?)?/;
function createDuration(input, unit) {
  if (typeof input === "string") {
    return parseString(input);
  }
  if (typeof input === "object" && input) {
    return parseObject(input);
  }
  if (typeof input === "number") {
    return parseObject({ [unit || "milliseconds"]: input });
  }
  return null;
}
function parseString(s3) {
  let m3 = PARSE_RE.exec(s3);
  if (m3) {
    let sign = m3[1] ? -1 : 1;
    return {
      years: 0,
      months: 0,
      days: sign * (m3[2] ? parseInt(m3[2], 10) : 0),
      milliseconds: sign * ((m3[3] ? parseInt(m3[3], 10) : 0) * 60 * 60 * 1e3 + // hours
      (m3[4] ? parseInt(m3[4], 10) : 0) * 60 * 1e3 + // minutes
      (m3[5] ? parseInt(m3[5], 10) : 0) * 1e3 + // seconds
      (m3[6] ? parseInt(m3[6], 10) : 0))
    };
  }
  return null;
}
function parseObject(obj) {
  let duration = {
    years: obj.years || obj.year || 0,
    months: obj.months || obj.month || 0,
    days: obj.days || obj.day || 0,
    milliseconds: (obj.hours || obj.hour || 0) * 60 * 60 * 1e3 + // hours
    (obj.minutes || obj.minute || 0) * 60 * 1e3 + // minutes
    (obj.seconds || obj.second || 0) * 1e3 + // seconds
    (obj.milliseconds || obj.millisecond || obj.ms || 0)
    // ms
  };
  let weeks = obj.weeks || obj.week;
  if (weeks) {
    duration.days += weeks * 7;
    duration.specifiedWeeks = true;
  }
  return duration;
}
function durationsEqual(d0, d1) {
  return d0.years === d1.years && d0.months === d1.months && d0.days === d1.days && d0.milliseconds === d1.milliseconds;
}
function addDurations(d0, d1) {
  return {
    years: d0.years + d1.years,
    months: d0.months + d1.months,
    days: d0.days + d1.days,
    milliseconds: d0.milliseconds + d1.milliseconds
  };
}
function subtractDurations(d1, d0) {
  return {
    years: d1.years - d0.years,
    months: d1.months - d0.months,
    days: d1.days - d0.days,
    milliseconds: d1.milliseconds - d0.milliseconds
  };
}
function multiplyDuration(d2, n2) {
  return {
    years: d2.years * n2,
    months: d2.months * n2,
    days: d2.days * n2,
    milliseconds: d2.milliseconds * n2
  };
}
function asRoughYears(dur) {
  return asRoughDays(dur) / 365;
}
function asRoughMonths(dur) {
  return asRoughDays(dur) / 30;
}
function asRoughDays(dur) {
  return asRoughMs(dur) / 864e5;
}
function asRoughMs(dur) {
  return dur.years * (365 * 864e5) + dur.months * (30 * 864e5) + dur.days * 864e5 + dur.milliseconds;
}
function wholeDivideDurations(numerator, denominator) {
  let res = null;
  for (let i3 = 0; i3 < INTERNAL_UNITS.length; i3 += 1) {
    let unit = INTERNAL_UNITS[i3];
    if (denominator[unit]) {
      let localRes = numerator[unit] / denominator[unit];
      if (!isInt(localRes) || res !== null && res !== localRes) {
        return null;
      }
      res = localRes;
    } else if (numerator[unit]) {
      return null;
    }
  }
  return res;
}
function greatestDurationDenominator(dur) {
  let ms = dur.milliseconds;
  if (ms) {
    if (ms % 1e3 !== 0) {
      return { unit: "millisecond", value: ms };
    }
    if (ms % (1e3 * 60) !== 0) {
      return { unit: "second", value: ms / 1e3 };
    }
    if (ms % (1e3 * 60 * 60) !== 0) {
      return { unit: "minute", value: ms / (1e3 * 60) };
    }
    if (ms) {
      return { unit: "hour", value: ms / (1e3 * 60 * 60) };
    }
  }
  if (dur.days) {
    if (dur.specifiedWeeks && dur.days % 7 === 0) {
      return { unit: "week", value: dur.days / 7 };
    }
    return { unit: "day", value: dur.days };
  }
  if (dur.months) {
    return { unit: "month", value: dur.months };
  }
  if (dur.years) {
    return { unit: "year", value: dur.years };
  }
  return { unit: "millisecond", value: 0 };
}
function isArraysEqual(a0, a1, equalityFunc) {
  if (a0 === a1) {
    return true;
  }
  let len = a0.length;
  let i3;
  if (len !== a1.length) {
    return false;
  }
  for (i3 = 0; i3 < len; i3 += 1) {
    if (!(equalityFunc ? equalityFunc(a0[i3], a1[i3]) : a0[i3] === a1[i3])) {
      return false;
    }
  }
  return true;
}
var DAY_IDS = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];
function addWeeks(m3, n2) {
  let a3 = dateToUtcArray(m3);
  a3[2] += n2 * 7;
  return arrayToUtcDate(a3);
}
function addDays(m3, n2) {
  let a3 = dateToUtcArray(m3);
  a3[2] += n2;
  return arrayToUtcDate(a3);
}
function addMs(m3, n2) {
  let a3 = dateToUtcArray(m3);
  a3[6] += n2;
  return arrayToUtcDate(a3);
}
function diffWeeks(m0, m1) {
  return diffDays(m0, m1) / 7;
}
function diffDays(m0, m1) {
  return (m1.valueOf() - m0.valueOf()) / (1e3 * 60 * 60 * 24);
}
function diffHours(m0, m1) {
  return (m1.valueOf() - m0.valueOf()) / (1e3 * 60 * 60);
}
function diffMinutes(m0, m1) {
  return (m1.valueOf() - m0.valueOf()) / (1e3 * 60);
}
function diffSeconds(m0, m1) {
  return (m1.valueOf() - m0.valueOf()) / 1e3;
}
function diffDayAndTime(m0, m1) {
  let m0day = startOfDay(m0);
  let m1day = startOfDay(m1);
  return {
    years: 0,
    months: 0,
    days: Math.round(diffDays(m0day, m1day)),
    milliseconds: m1.valueOf() - m1day.valueOf() - (m0.valueOf() - m0day.valueOf())
  };
}
function diffWholeWeeks(m0, m1) {
  let d2 = diffWholeDays(m0, m1);
  if (d2 !== null && d2 % 7 === 0) {
    return d2 / 7;
  }
  return null;
}
function diffWholeDays(m0, m1) {
  if (timeAsMs(m0) === timeAsMs(m1)) {
    return Math.round(diffDays(m0, m1));
  }
  return null;
}
function startOfDay(m3) {
  return arrayToUtcDate([
    m3.getUTCFullYear(),
    m3.getUTCMonth(),
    m3.getUTCDate()
  ]);
}
function startOfHour(m3) {
  return arrayToUtcDate([
    m3.getUTCFullYear(),
    m3.getUTCMonth(),
    m3.getUTCDate(),
    m3.getUTCHours()
  ]);
}
function startOfMinute(m3) {
  return arrayToUtcDate([
    m3.getUTCFullYear(),
    m3.getUTCMonth(),
    m3.getUTCDate(),
    m3.getUTCHours(),
    m3.getUTCMinutes()
  ]);
}
function startOfSecond(m3) {
  return arrayToUtcDate([
    m3.getUTCFullYear(),
    m3.getUTCMonth(),
    m3.getUTCDate(),
    m3.getUTCHours(),
    m3.getUTCMinutes(),
    m3.getUTCSeconds()
  ]);
}
function weekOfYear(marker, dow, doy) {
  let y3 = marker.getUTCFullYear();
  let w4 = weekOfGivenYear(marker, y3, dow, doy);
  if (w4 < 1) {
    return weekOfGivenYear(marker, y3 - 1, dow, doy);
  }
  let nextW = weekOfGivenYear(marker, y3 + 1, dow, doy);
  if (nextW >= 1) {
    return Math.min(w4, nextW);
  }
  return w4;
}
function weekOfGivenYear(marker, year, dow, doy) {
  let firstWeekStart = arrayToUtcDate([year, 0, 1 + firstWeekOffset(year, dow, doy)]);
  let dayStart = startOfDay(marker);
  let days = Math.round(diffDays(firstWeekStart, dayStart));
  return Math.floor(days / 7) + 1;
}
function firstWeekOffset(year, dow, doy) {
  let fwd = 7 + dow - doy;
  let fwdlw = (7 + arrayToUtcDate([year, 0, fwd]).getUTCDay() - dow) % 7;
  return -fwdlw + fwd - 1;
}
function dateToLocalArray(date) {
  return [
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    date.getHours(),
    date.getMinutes(),
    date.getSeconds(),
    date.getMilliseconds()
  ];
}
function arrayToLocalDate(a3) {
  return new Date(
    a3[0],
    a3[1] || 0,
    a3[2] == null ? 1 : a3[2],
    // day of month
    a3[3] || 0,
    a3[4] || 0,
    a3[5] || 0
  );
}
function dateToUtcArray(date) {
  return [
    date.getUTCFullYear(),
    date.getUTCMonth(),
    date.getUTCDate(),
    date.getUTCHours(),
    date.getUTCMinutes(),
    date.getUTCSeconds(),
    date.getUTCMilliseconds()
  ];
}
function arrayToUtcDate(a3) {
  if (a3.length === 1) {
    a3 = a3.concat([0]);
  }
  return new Date(Date.UTC(...a3));
}
function isValidDate(m3) {
  return !isNaN(m3.valueOf());
}
function timeAsMs(m3) {
  return m3.getUTCHours() * 1e3 * 60 * 60 + m3.getUTCMinutes() * 1e3 * 60 + m3.getUTCSeconds() * 1e3 + m3.getUTCMilliseconds();
}
function buildIsoString(marker, timeZoneOffset, stripZeroTime = false) {
  let s3 = marker.toISOString();
  s3 = s3.replace(".000", "");
  if (stripZeroTime) {
    s3 = s3.replace("T00:00:00Z", "");
  }
  if (s3.length > 10) {
    if (timeZoneOffset == null) {
      s3 = s3.replace("Z", "");
    } else if (timeZoneOffset !== 0) {
      s3 = s3.replace("Z", formatTimeZoneOffset(timeZoneOffset, true));
    }
  }
  return s3;
}
function formatDayString(marker) {
  return marker.toISOString().replace(/T.*$/, "");
}
function formatIsoMonthStr(marker) {
  return marker.toISOString().match(/^\d{4}-\d{2}/)[0];
}
function formatIsoTimeString(marker) {
  return padStart(marker.getUTCHours(), 2) + ":" + padStart(marker.getUTCMinutes(), 2) + ":" + padStart(marker.getUTCSeconds(), 2);
}
function formatTimeZoneOffset(minutes, doIso = false) {
  let sign = minutes < 0 ? "-" : "+";
  let abs = Math.abs(minutes);
  let hours = Math.floor(abs / 60);
  let mins = Math.round(abs % 60);
  if (doIso) {
    return `${sign + padStart(hours, 2)}:${padStart(mins, 2)}`;
  }
  return `GMT${sign}${hours}${mins ? `:${padStart(mins, 2)}` : ""}`;
}
function memoize(workerFunc, resEquality, teardownFunc) {
  let currentArgs;
  let currentRes;
  return function(...newArgs) {
    if (!currentArgs) {
      currentRes = workerFunc.apply(this, newArgs);
    } else if (!isArraysEqual(currentArgs, newArgs)) {
      if (teardownFunc) {
        teardownFunc(currentRes);
      }
      let res = workerFunc.apply(this, newArgs);
      if (!resEquality || !resEquality(res, currentRes)) {
        currentRes = res;
      }
    }
    currentArgs = newArgs;
    return currentRes;
  };
}
function memoizeObjArg(workerFunc, resEquality, teardownFunc) {
  let currentArg;
  let currentRes;
  return (newArg) => {
    if (!currentArg) {
      currentRes = workerFunc.call(this, newArg);
    } else if (!isPropsEqual(currentArg, newArg)) {
      if (teardownFunc) {
        teardownFunc(currentRes);
      }
      let res = workerFunc.call(this, newArg);
      if (!resEquality || !resEquality(res, currentRes)) {
        currentRes = res;
      }
    }
    currentArg = newArg;
    return currentRes;
  };
}
var EXTENDED_SETTINGS_AND_SEVERITIES = {
  week: 3,
  separator: 0,
  omitZeroMinute: 0,
  meridiem: 0,
  omitCommas: 0
};
var STANDARD_DATE_PROP_SEVERITIES = {
  timeZoneName: 7,
  era: 6,
  year: 5,
  month: 4,
  day: 2,
  weekday: 2,
  hour: 1,
  minute: 1,
  second: 1
};
var MERIDIEM_RE = /\s*([ap])\.?m\.?/i;
var COMMA_RE = /,/g;
var MULTI_SPACE_RE = /\s+/g;
var LTR_RE = /\u200e/g;
var UTC_RE = /UTC|GMT/;
var NativeFormatter = class {
  constructor(formatSettings) {
    let standardDateProps = {};
    let extendedSettings = {};
    let severity = 0;
    for (let name in formatSettings) {
      if (name in EXTENDED_SETTINGS_AND_SEVERITIES) {
        extendedSettings[name] = formatSettings[name];
        severity = Math.max(EXTENDED_SETTINGS_AND_SEVERITIES[name], severity);
      } else {
        standardDateProps[name] = formatSettings[name];
        if (name in STANDARD_DATE_PROP_SEVERITIES) {
          severity = Math.max(STANDARD_DATE_PROP_SEVERITIES[name], severity);
        }
      }
    }
    this.standardDateProps = standardDateProps;
    this.extendedSettings = extendedSettings;
    this.severity = severity;
    this.buildFormattingFunc = memoize(buildFormattingFunc);
  }
  format(date, context) {
    return this.buildFormattingFunc(this.standardDateProps, this.extendedSettings, context)(date);
  }
  formatRange(start, end, context, betterDefaultSeparator) {
    let { standardDateProps, extendedSettings } = this;
    let diffSeverity = computeMarkerDiffSeverity(start.marker, end.marker, context.calendarSystem);
    if (!diffSeverity) {
      return this.format(start, context);
    }
    let biggestUnitForPartial = diffSeverity;
    if (biggestUnitForPartial > 1 && // the two dates are different in a way that's larger scale than time
    (standardDateProps.year === "numeric" || standardDateProps.year === "2-digit") && (standardDateProps.month === "numeric" || standardDateProps.month === "2-digit") && (standardDateProps.day === "numeric" || standardDateProps.day === "2-digit")) {
      biggestUnitForPartial = 1;
    }
    let full0 = this.format(start, context);
    let full1 = this.format(end, context);
    if (full0 === full1) {
      return full0;
    }
    let partialDateProps = computePartialFormattingOptions(standardDateProps, biggestUnitForPartial);
    let partialFormattingFunc = buildFormattingFunc(partialDateProps, extendedSettings, context);
    let partial0 = partialFormattingFunc(start);
    let partial1 = partialFormattingFunc(end);
    let insertion = findCommonInsertion(full0, partial0, full1, partial1);
    let separator = extendedSettings.separator || betterDefaultSeparator || context.defaultSeparator || "";
    if (insertion) {
      return insertion.before + partial0 + separator + partial1 + insertion.after;
    }
    return full0 + separator + full1;
  }
  getLargestUnit() {
    switch (this.severity) {
      case 7:
      case 6:
      case 5:
        return "year";
      case 4:
        return "month";
      case 3:
        return "week";
      case 2:
        return "day";
      default:
        return "time";
    }
  }
};
function buildFormattingFunc(standardDateProps, extendedSettings, context) {
  let standardDatePropCnt = Object.keys(standardDateProps).length;
  if (standardDatePropCnt === 1 && standardDateProps.timeZoneName === "short") {
    return (date) => formatTimeZoneOffset(date.timeZoneOffset);
  }
  if (standardDatePropCnt === 0 && extendedSettings.week) {
    return (date) => formatWeekNumber(context.computeWeekNumber(date.marker), context.weekText, context.weekTextLong, context.locale, extendedSettings.week);
  }
  return buildNativeFormattingFunc(standardDateProps, extendedSettings, context);
}
function buildNativeFormattingFunc(standardDateProps, extendedSettings, context) {
  standardDateProps = Object.assign({}, standardDateProps);
  extendedSettings = Object.assign({}, extendedSettings);
  sanitizeSettings(standardDateProps, extendedSettings);
  standardDateProps.timeZone = "UTC";
  let normalFormat = new Intl.DateTimeFormat(context.locale.codes, standardDateProps);
  let zeroFormat;
  if (extendedSettings.omitZeroMinute) {
    let zeroProps = Object.assign({}, standardDateProps);
    delete zeroProps.minute;
    zeroFormat = new Intl.DateTimeFormat(context.locale.codes, zeroProps);
  }
  return (date) => {
    let { marker } = date;
    let format;
    if (zeroFormat && !marker.getUTCMinutes()) {
      format = zeroFormat;
    } else {
      format = normalFormat;
    }
    let s3 = format.format(marker);
    return postProcess(s3, date, standardDateProps, extendedSettings, context);
  };
}
function sanitizeSettings(standardDateProps, extendedSettings) {
  if (standardDateProps.timeZoneName) {
    if (!standardDateProps.hour) {
      standardDateProps.hour = "2-digit";
    }
    if (!standardDateProps.minute) {
      standardDateProps.minute = "2-digit";
    }
  }
  if (standardDateProps.timeZoneName === "long") {
    standardDateProps.timeZoneName = "short";
  }
  if (extendedSettings.omitZeroMinute && (standardDateProps.second || standardDateProps.millisecond)) {
    delete extendedSettings.omitZeroMinute;
  }
}
function postProcess(s3, date, standardDateProps, extendedSettings, context) {
  s3 = s3.replace(LTR_RE, "");
  if (standardDateProps.timeZoneName === "short") {
    s3 = injectTzoStr(s3, context.timeZone === "UTC" || date.timeZoneOffset == null ? "UTC" : (
      // important to normalize for IE, which does "GMT"
      formatTimeZoneOffset(date.timeZoneOffset)
    ));
  }
  if (extendedSettings.omitCommas) {
    s3 = s3.replace(COMMA_RE, "").trim();
  }
  if (extendedSettings.omitZeroMinute) {
    s3 = s3.replace(":00", "");
  }
  if (extendedSettings.meridiem === false) {
    s3 = s3.replace(MERIDIEM_RE, "").trim();
  } else if (extendedSettings.meridiem === "narrow") {
    s3 = s3.replace(MERIDIEM_RE, (m0, m1) => m1.toLocaleLowerCase());
  } else if (extendedSettings.meridiem === "short") {
    s3 = s3.replace(MERIDIEM_RE, (m0, m1) => `${m1.toLocaleLowerCase()}m`);
  } else if (extendedSettings.meridiem === "lowercase") {
    s3 = s3.replace(MERIDIEM_RE, (m0) => m0.toLocaleLowerCase());
  }
  s3 = s3.replace(MULTI_SPACE_RE, " ");
  s3 = s3.trim();
  return s3;
}
function injectTzoStr(s3, tzoStr) {
  let replaced = false;
  s3 = s3.replace(UTC_RE, () => {
    replaced = true;
    return tzoStr;
  });
  if (!replaced) {
    s3 += ` ${tzoStr}`;
  }
  return s3;
}
function formatWeekNumber(num, weekText, weekTextLong, locale, display2) {
  let parts = [];
  if (display2 === "long") {
    parts.push(weekTextLong);
  } else if (display2 === "short" || display2 === "narrow") {
    parts.push(weekText);
  }
  if (display2 === "long" || display2 === "short") {
    parts.push(" ");
  }
  parts.push(locale.simpleNumberFormat.format(num));
  if (locale.options.direction === "rtl") {
    parts.reverse();
  }
  return parts.join("");
}
function computeMarkerDiffSeverity(d0, d1, ca) {
  if (ca.getMarkerYear(d0) !== ca.getMarkerYear(d1)) {
    return 5;
  }
  if (ca.getMarkerMonth(d0) !== ca.getMarkerMonth(d1)) {
    return 4;
  }
  if (ca.getMarkerDay(d0) !== ca.getMarkerDay(d1)) {
    return 2;
  }
  if (timeAsMs(d0) !== timeAsMs(d1)) {
    return 1;
  }
  return 0;
}
function computePartialFormattingOptions(options, biggestUnit) {
  let partialOptions = {};
  for (let name in options) {
    if (!(name in STANDARD_DATE_PROP_SEVERITIES) || // not a date part prop (like timeZone)
    STANDARD_DATE_PROP_SEVERITIES[name] <= biggestUnit) {
      partialOptions[name] = options[name];
    }
  }
  return partialOptions;
}
function findCommonInsertion(full0, partial0, full1, partial1) {
  let i0 = 0;
  while (i0 < full0.length) {
    let found0 = full0.indexOf(partial0, i0);
    if (found0 === -1) {
      break;
    }
    let before0 = full0.substr(0, found0);
    i0 = found0 + partial0.length;
    let after0 = full0.substr(i0);
    let i1 = 0;
    while (i1 < full1.length) {
      let found1 = full1.indexOf(partial1, i1);
      if (found1 === -1) {
        break;
      }
      let before1 = full1.substr(0, found1);
      i1 = found1 + partial1.length;
      let after1 = full1.substr(i1);
      if (before0 === before1 && after0 === after1) {
        return {
          before: before0,
          after: after0
        };
      }
    }
  }
  return null;
}
function expandZonedMarker(dateInfo, calendarSystem) {
  let a3 = calendarSystem.markerToArray(dateInfo.marker);
  return {
    marker: dateInfo.marker,
    timeZoneOffset: dateInfo.timeZoneOffset,
    array: a3,
    year: a3[0],
    month: a3[1],
    day: a3[2],
    hour: a3[3],
    minute: a3[4],
    second: a3[5],
    millisecond: a3[6]
  };
}
function createVerboseFormattingArg(start, end, context, betterDefaultSeparator) {
  let startInfo = expandZonedMarker(start, context.calendarSystem);
  let endInfo = end ? expandZonedMarker(end, context.calendarSystem) : null;
  return {
    date: startInfo,
    start: startInfo,
    end: endInfo,
    timeZone: context.timeZone,
    localeCodes: context.locale.codes,
    defaultSeparator: betterDefaultSeparator || context.defaultSeparator
  };
}
var CmdFormatter = class {
  constructor(cmdStr) {
    this.cmdStr = cmdStr;
  }
  format(date, context, betterDefaultSeparator) {
    return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(date, null, context, betterDefaultSeparator));
  }
  formatRange(start, end, context, betterDefaultSeparator) {
    return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(start, end, context, betterDefaultSeparator));
  }
};
var FuncFormatter = class {
  constructor(func) {
    this.func = func;
  }
  format(date, context, betterDefaultSeparator) {
    return this.func(createVerboseFormattingArg(date, null, context, betterDefaultSeparator));
  }
  formatRange(start, end, context, betterDefaultSeparator) {
    return this.func(createVerboseFormattingArg(start, end, context, betterDefaultSeparator));
  }
};
function createFormatter(input) {
  if (typeof input === "object" && input) {
    return new NativeFormatter(input);
  }
  if (typeof input === "string") {
    return new CmdFormatter(input);
  }
  if (typeof input === "function") {
    return new FuncFormatter(input);
  }
  return null;
}
var BASE_OPTION_REFINERS = {
  navLinkDayClick: identity,
  navLinkWeekClick: identity,
  duration: createDuration,
  bootstrapFontAwesome: identity,
  buttonIcons: identity,
  customButtons: identity,
  defaultAllDayEventDuration: createDuration,
  defaultTimedEventDuration: createDuration,
  nextDayThreshold: createDuration,
  scrollTime: createDuration,
  scrollTimeReset: Boolean,
  slotMinTime: createDuration,
  slotMaxTime: createDuration,
  dayPopoverFormat: createFormatter,
  slotDuration: createDuration,
  snapDuration: createDuration,
  headerToolbar: identity,
  footerToolbar: identity,
  defaultRangeSeparator: String,
  titleRangeSeparator: String,
  forceEventDuration: Boolean,
  dayHeaders: Boolean,
  dayHeaderFormat: createFormatter,
  dayHeaderClassNames: identity,
  dayHeaderContent: identity,
  dayHeaderDidMount: identity,
  dayHeaderWillUnmount: identity,
  dayCellClassNames: identity,
  dayCellContent: identity,
  dayCellDidMount: identity,
  dayCellWillUnmount: identity,
  initialView: String,
  aspectRatio: Number,
  weekends: Boolean,
  weekNumberCalculation: identity,
  weekNumbers: Boolean,
  weekNumberClassNames: identity,
  weekNumberContent: identity,
  weekNumberDidMount: identity,
  weekNumberWillUnmount: identity,
  editable: Boolean,
  viewClassNames: identity,
  viewDidMount: identity,
  viewWillUnmount: identity,
  nowIndicator: Boolean,
  nowIndicatorClassNames: identity,
  nowIndicatorContent: identity,
  nowIndicatorDidMount: identity,
  nowIndicatorWillUnmount: identity,
  showNonCurrentDates: Boolean,
  lazyFetching: Boolean,
  startParam: String,
  endParam: String,
  timeZoneParam: String,
  timeZone: String,
  locales: identity,
  locale: identity,
  themeSystem: String,
  dragRevertDuration: Number,
  dragScroll: Boolean,
  allDayMaintainDuration: Boolean,
  unselectAuto: Boolean,
  dropAccept: identity,
  eventOrder: parseFieldSpecs,
  eventOrderStrict: Boolean,
  handleWindowResize: Boolean,
  windowResizeDelay: Number,
  longPressDelay: Number,
  eventDragMinDistance: Number,
  expandRows: Boolean,
  height: identity,
  contentHeight: identity,
  direction: String,
  weekNumberFormat: createFormatter,
  eventResizableFromStart: Boolean,
  displayEventTime: Boolean,
  displayEventEnd: Boolean,
  weekText: String,
  weekTextLong: String,
  progressiveEventRendering: Boolean,
  businessHours: identity,
  initialDate: identity,
  now: identity,
  eventDataTransform: identity,
  stickyHeaderDates: identity,
  stickyFooterScrollbar: identity,
  viewHeight: identity,
  defaultAllDay: Boolean,
  eventSourceFailure: identity,
  eventSourceSuccess: identity,
  eventDisplay: String,
  eventStartEditable: Boolean,
  eventDurationEditable: Boolean,
  eventOverlap: identity,
  eventConstraint: identity,
  eventAllow: identity,
  eventBackgroundColor: String,
  eventBorderColor: String,
  eventTextColor: String,
  eventColor: String,
  eventClassNames: identity,
  eventContent: identity,
  eventDidMount: identity,
  eventWillUnmount: identity,
  selectConstraint: identity,
  selectOverlap: identity,
  selectAllow: identity,
  droppable: Boolean,
  unselectCancel: String,
  slotLabelFormat: identity,
  slotLaneClassNames: identity,
  slotLaneContent: identity,
  slotLaneDidMount: identity,
  slotLaneWillUnmount: identity,
  slotLabelClassNames: identity,
  slotLabelContent: identity,
  slotLabelDidMount: identity,
  slotLabelWillUnmount: identity,
  dayMaxEvents: identity,
  dayMaxEventRows: identity,
  dayMinWidth: Number,
  slotLabelInterval: createDuration,
  allDayText: String,
  allDayClassNames: identity,
  allDayContent: identity,
  allDayDidMount: identity,
  allDayWillUnmount: identity,
  slotMinWidth: Number,
  navLinks: Boolean,
  eventTimeFormat: createFormatter,
  rerenderDelay: Number,
  moreLinkText: identity,
  moreLinkHint: identity,
  selectMinDistance: Number,
  selectable: Boolean,
  selectLongPressDelay: Number,
  eventLongPressDelay: Number,
  selectMirror: Boolean,
  eventMaxStack: Number,
  eventMinHeight: Number,
  eventMinWidth: Number,
  eventShortHeight: Number,
  slotEventOverlap: Boolean,
  plugins: identity,
  firstDay: Number,
  dayCount: Number,
  dateAlignment: String,
  dateIncrement: createDuration,
  hiddenDays: identity,
  fixedWeekCount: Boolean,
  validRange: identity,
  visibleRange: identity,
  titleFormat: identity,
  eventInteractive: Boolean,
  // only used by list-view, but languages define the value, so we need it in base options
  noEventsText: String,
  viewHint: identity,
  navLinkHint: identity,
  closeHint: String,
  timeHint: String,
  eventHint: String,
  moreLinkClick: identity,
  moreLinkClassNames: identity,
  moreLinkContent: identity,
  moreLinkDidMount: identity,
  moreLinkWillUnmount: identity,
  monthStartFormat: createFormatter,
  // for connectors
  // (can't be part of plugin system b/c must be provided at runtime)
  handleCustomRendering: identity,
  customRenderingMetaMap: identity,
  customRenderingReplaces: Boolean
};
var BASE_OPTION_DEFAULTS = {
  eventDisplay: "auto",
  defaultRangeSeparator: " - ",
  titleRangeSeparator: " \u2013 ",
  defaultTimedEventDuration: "01:00:00",
  defaultAllDayEventDuration: { day: 1 },
  forceEventDuration: false,
  nextDayThreshold: "00:00:00",
  dayHeaders: true,
  initialView: "",
  aspectRatio: 1.35,
  headerToolbar: {
    start: "title",
    center: "",
    end: "today prev,next"
  },
  weekends: true,
  weekNumbers: false,
  weekNumberCalculation: "local",
  editable: false,
  nowIndicator: false,
  scrollTime: "06:00:00",
  scrollTimeReset: true,
  slotMinTime: "00:00:00",
  slotMaxTime: "24:00:00",
  showNonCurrentDates: true,
  lazyFetching: true,
  startParam: "start",
  endParam: "end",
  timeZoneParam: "timeZone",
  timeZone: "local",
  locales: [],
  locale: "",
  themeSystem: "standard",
  dragRevertDuration: 500,
  dragScroll: true,
  allDayMaintainDuration: false,
  unselectAuto: true,
  dropAccept: "*",
  eventOrder: "start,-duration,allDay,title",
  dayPopoverFormat: { month: "long", day: "numeric", year: "numeric" },
  handleWindowResize: true,
  windowResizeDelay: 100,
  longPressDelay: 1e3,
  eventDragMinDistance: 5,
  expandRows: false,
  navLinks: false,
  selectable: false,
  eventMinHeight: 15,
  eventMinWidth: 30,
  eventShortHeight: 30,
  monthStartFormat: { month: "long", day: "numeric" }
};
var CALENDAR_LISTENER_REFINERS = {
  datesSet: identity,
  eventsSet: identity,
  eventAdd: identity,
  eventChange: identity,
  eventRemove: identity,
  windowResize: identity,
  eventClick: identity,
  eventMouseEnter: identity,
  eventMouseLeave: identity,
  select: identity,
  unselect: identity,
  loading: identity,
  // internal
  _unmount: identity,
  _beforeprint: identity,
  _afterprint: identity,
  _noEventDrop: identity,
  _noEventResize: identity,
  _resize: identity,
  _scrollRequest: identity
};
var CALENDAR_OPTION_REFINERS = {
  buttonText: identity,
  buttonHints: identity,
  views: identity,
  plugins: identity,
  initialEvents: identity,
  events: identity,
  eventSources: identity
};
var COMPLEX_OPTION_COMPARATORS = {
  headerToolbar: isMaybeObjectsEqual,
  footerToolbar: isMaybeObjectsEqual,
  buttonText: isMaybeObjectsEqual,
  buttonHints: isMaybeObjectsEqual,
  buttonIcons: isMaybeObjectsEqual,
  dateIncrement: isMaybeObjectsEqual,
  plugins: isMaybeArraysEqual,
  events: isMaybeArraysEqual,
  eventSources: isMaybeArraysEqual,
  ["resources"]: isMaybeArraysEqual
};
function isMaybeObjectsEqual(a3, b3) {
  if (typeof a3 === "object" && typeof b3 === "object" && a3 && b3) {
    return isPropsEqual(a3, b3);
  }
  return a3 === b3;
}
function isMaybeArraysEqual(a3, b3) {
  if (Array.isArray(a3) && Array.isArray(b3)) {
    return isArraysEqual(a3, b3);
  }
  return a3 === b3;
}
var VIEW_OPTION_REFINERS = {
  type: String,
  component: identity,
  buttonText: String,
  buttonTextKey: String,
  dateProfileGeneratorClass: identity,
  usesMinMaxTime: Boolean,
  classNames: identity,
  content: identity,
  didMount: identity,
  willUnmount: identity
};
function mergeRawOptions(optionSets) {
  return mergeProps(optionSets, COMPLEX_OPTION_COMPARATORS);
}
function refineProps(input, refiners) {
  let refined = {};
  let extra = {};
  for (let propName in refiners) {
    if (propName in input) {
      refined[propName] = refiners[propName](input[propName]);
    }
  }
  for (let propName in input) {
    if (!(propName in refiners)) {
      extra[propName] = input[propName];
    }
  }
  return { refined, extra };
}
function identity(raw) {
  return raw;
}
var { hasOwnProperty } = Object.prototype;
function mergeProps(propObjs, complexPropsMap) {
  let dest = {};
  if (complexPropsMap) {
    for (let name in complexPropsMap) {
      if (complexPropsMap[name] === isMaybeObjectsEqual) {
        let complexObjs = [];
        for (let i3 = propObjs.length - 1; i3 >= 0; i3 -= 1) {
          let val = propObjs[i3][name];
          if (typeof val === "object" && val) {
            complexObjs.unshift(val);
          } else if (val !== void 0) {
            dest[name] = val;
            break;
          }
        }
        if (complexObjs.length) {
          dest[name] = mergeProps(complexObjs);
        }
      }
    }
  }
  for (let i3 = propObjs.length - 1; i3 >= 0; i3 -= 1) {
    let props = propObjs[i3];
    for (let name in props) {
      if (!(name in dest)) {
        dest[name] = props[name];
      }
    }
  }
  return dest;
}
function filterHash(hash, func) {
  let filtered = {};
  for (let key in hash) {
    if (func(hash[key], key)) {
      filtered[key] = hash[key];
    }
  }
  return filtered;
}
function mapHash(hash, func) {
  let newHash = {};
  for (let key in hash) {
    newHash[key] = func(hash[key], key);
  }
  return newHash;
}
function arrayToHash(a3) {
  let hash = {};
  for (let item of a3) {
    hash[item] = true;
  }
  return hash;
}
function hashValuesToArray(obj) {
  let a3 = [];
  for (let key in obj) {
    a3.push(obj[key]);
  }
  return a3;
}
function isPropsEqual(obj0, obj1) {
  if (obj0 === obj1) {
    return true;
  }
  for (let key in obj0) {
    if (hasOwnProperty.call(obj0, key)) {
      if (!(key in obj1)) {
        return false;
      }
    }
  }
  for (let key in obj1) {
    if (hasOwnProperty.call(obj1, key)) {
      if (obj0[key] !== obj1[key]) {
        return false;
      }
    }
  }
  return true;
}
var HANDLER_RE = /^on[A-Z]/;
function isNonHandlerPropsEqual(obj0, obj1) {
  const keys = getUnequalProps(obj0, obj1);
  for (let key of keys) {
    if (!HANDLER_RE.test(key)) {
      return false;
    }
  }
  return true;
}
function getUnequalProps(obj0, obj1) {
  let keys = [];
  for (let key in obj0) {
    if (hasOwnProperty.call(obj0, key)) {
      if (!(key in obj1)) {
        keys.push(key);
      }
    }
  }
  for (let key in obj1) {
    if (hasOwnProperty.call(obj1, key)) {
      if (obj0[key] !== obj1[key]) {
        keys.push(key);
      }
    }
  }
  return keys;
}
function compareObjs(oldProps, newProps, equalityFuncs = {}) {
  if (oldProps === newProps) {
    return true;
  }
  for (let key in newProps) {
    if (key in oldProps && isObjValsEqual(oldProps[key], newProps[key], equalityFuncs[key]))
      ;
    else {
      return false;
    }
  }
  for (let key in oldProps) {
    if (!(key in newProps)) {
      return false;
    }
  }
  return true;
}
function isObjValsEqual(val0, val1, comparator) {
  if (val0 === val1 || comparator === true) {
    return true;
  }
  if (comparator) {
    return comparator(val0, val1);
  }
  return false;
}
function collectFromHash(hash, startIndex = 0, endIndex, step = 1) {
  let res = [];
  if (endIndex == null) {
    endIndex = Object.keys(hash).length;
  }
  for (let i3 = startIndex; i3 < endIndex; i3 += step) {
    let val = hash[i3];
    if (val !== void 0) {
      res.push(val);
    }
  }
  return res;
}
var calendarSystemClassMap = {};
function registerCalendarSystem(name, theClass) {
  calendarSystemClassMap[name] = theClass;
}
function createCalendarSystem(name) {
  return new calendarSystemClassMap[name]();
}
var GregorianCalendarSystem = class {
  getMarkerYear(d2) {
    return d2.getUTCFullYear();
  }
  getMarkerMonth(d2) {
    return d2.getUTCMonth();
  }
  getMarkerDay(d2) {
    return d2.getUTCDate();
  }
  arrayToMarker(arr) {
    return arrayToUtcDate(arr);
  }
  markerToArray(marker) {
    return dateToUtcArray(marker);
  }
};
registerCalendarSystem("gregory", GregorianCalendarSystem);
var ISO_RE = /^\s*(\d{4})(-?(\d{2})(-?(\d{2})([T ](\d{2}):?(\d{2})(:?(\d{2})(\.(\d+))?)?(Z|(([-+])(\d{2})(:?(\d{2}))?))?)?)?)?$/;
function parse(str) {
  let m3 = ISO_RE.exec(str);
  if (m3) {
    let marker = new Date(Date.UTC(Number(m3[1]), m3[3] ? Number(m3[3]) - 1 : 0, Number(m3[5] || 1), Number(m3[7] || 0), Number(m3[8] || 0), Number(m3[10] || 0), m3[12] ? Number(`0.${m3[12]}`) * 1e3 : 0));
    if (isValidDate(marker)) {
      let timeZoneOffset = null;
      if (m3[13]) {
        timeZoneOffset = (m3[15] === "-" ? -1 : 1) * (Number(m3[16] || 0) * 60 + Number(m3[18] || 0));
      }
      return {
        marker,
        isTimeUnspecified: !m3[6],
        timeZoneOffset
      };
    }
  }
  return null;
}
var DateEnv = class {
  constructor(settings) {
    let timeZone = this.timeZone = settings.timeZone;
    let isNamedTimeZone = timeZone !== "local" && timeZone !== "UTC";
    if (settings.namedTimeZoneImpl && isNamedTimeZone) {
      this.namedTimeZoneImpl = new settings.namedTimeZoneImpl(timeZone);
    }
    this.canComputeOffset = Boolean(!isNamedTimeZone || this.namedTimeZoneImpl);
    this.calendarSystem = createCalendarSystem(settings.calendarSystem);
    this.locale = settings.locale;
    this.weekDow = settings.locale.week.dow;
    this.weekDoy = settings.locale.week.doy;
    if (settings.weekNumberCalculation === "ISO") {
      this.weekDow = 1;
      this.weekDoy = 4;
    }
    if (typeof settings.firstDay === "number") {
      this.weekDow = settings.firstDay;
    }
    if (typeof settings.weekNumberCalculation === "function") {
      this.weekNumberFunc = settings.weekNumberCalculation;
    }
    this.weekText = settings.weekText != null ? settings.weekText : settings.locale.options.weekText;
    this.weekTextLong = (settings.weekTextLong != null ? settings.weekTextLong : settings.locale.options.weekTextLong) || this.weekText;
    this.cmdFormatter = settings.cmdFormatter;
    this.defaultSeparator = settings.defaultSeparator;
  }
  // Creating / Parsing
  createMarker(input) {
    let meta = this.createMarkerMeta(input);
    if (meta === null) {
      return null;
    }
    return meta.marker;
  }
  createNowMarker() {
    if (this.canComputeOffset) {
      return this.timestampToMarker(new Date().valueOf());
    }
    return arrayToUtcDate(dateToLocalArray(new Date()));
  }
  createMarkerMeta(input) {
    if (typeof input === "string") {
      return this.parse(input);
    }
    let marker = null;
    if (typeof input === "number") {
      marker = this.timestampToMarker(input);
    } else if (input instanceof Date) {
      input = input.valueOf();
      if (!isNaN(input)) {
        marker = this.timestampToMarker(input);
      }
    } else if (Array.isArray(input)) {
      marker = arrayToUtcDate(input);
    }
    if (marker === null || !isValidDate(marker)) {
      return null;
    }
    return { marker, isTimeUnspecified: false, forcedTzo: null };
  }
  parse(s3) {
    let parts = parse(s3);
    if (parts === null) {
      return null;
    }
    let { marker } = parts;
    let forcedTzo = null;
    if (parts.timeZoneOffset !== null) {
      if (this.canComputeOffset) {
        marker = this.timestampToMarker(marker.valueOf() - parts.timeZoneOffset * 60 * 1e3);
      } else {
        forcedTzo = parts.timeZoneOffset;
      }
    }
    return { marker, isTimeUnspecified: parts.isTimeUnspecified, forcedTzo };
  }
  // Accessors
  getYear(marker) {
    return this.calendarSystem.getMarkerYear(marker);
  }
  getMonth(marker) {
    return this.calendarSystem.getMarkerMonth(marker);
  }
  getDay(marker) {
    return this.calendarSystem.getMarkerDay(marker);
  }
  // Adding / Subtracting
  add(marker, dur) {
    let a3 = this.calendarSystem.markerToArray(marker);
    a3[0] += dur.years;
    a3[1] += dur.months;
    a3[2] += dur.days;
    a3[6] += dur.milliseconds;
    return this.calendarSystem.arrayToMarker(a3);
  }
  subtract(marker, dur) {
    let a3 = this.calendarSystem.markerToArray(marker);
    a3[0] -= dur.years;
    a3[1] -= dur.months;
    a3[2] -= dur.days;
    a3[6] -= dur.milliseconds;
    return this.calendarSystem.arrayToMarker(a3);
  }
  addYears(marker, n2) {
    let a3 = this.calendarSystem.markerToArray(marker);
    a3[0] += n2;
    return this.calendarSystem.arrayToMarker(a3);
  }
  addMonths(marker, n2) {
    let a3 = this.calendarSystem.markerToArray(marker);
    a3[1] += n2;
    return this.calendarSystem.arrayToMarker(a3);
  }
  // Diffing Whole Units
  diffWholeYears(m0, m1) {
    let { calendarSystem } = this;
    if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1) && calendarSystem.getMarkerMonth(m0) === calendarSystem.getMarkerMonth(m1)) {
      return calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0);
    }
    return null;
  }
  diffWholeMonths(m0, m1) {
    let { calendarSystem } = this;
    if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1)) {
      return calendarSystem.getMarkerMonth(m1) - calendarSystem.getMarkerMonth(m0) + (calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0)) * 12;
    }
    return null;
  }
  // Range / Duration
  greatestWholeUnit(m0, m1) {
    let n2 = this.diffWholeYears(m0, m1);
    if (n2 !== null) {
      return { unit: "year", value: n2 };
    }
    n2 = this.diffWholeMonths(m0, m1);
    if (n2 !== null) {
      return { unit: "month", value: n2 };
    }
    n2 = diffWholeWeeks(m0, m1);
    if (n2 !== null) {
      return { unit: "week", value: n2 };
    }
    n2 = diffWholeDays(m0, m1);
    if (n2 !== null) {
      return { unit: "day", value: n2 };
    }
    n2 = diffHours(m0, m1);
    if (isInt(n2)) {
      return { unit: "hour", value: n2 };
    }
    n2 = diffMinutes(m0, m1);
    if (isInt(n2)) {
      return { unit: "minute", value: n2 };
    }
    n2 = diffSeconds(m0, m1);
    if (isInt(n2)) {
      return { unit: "second", value: n2 };
    }
    return { unit: "millisecond", value: m1.valueOf() - m0.valueOf() };
  }
  countDurationsBetween(m0, m1, d2) {
    let diff;
    if (d2.years) {
      diff = this.diffWholeYears(m0, m1);
      if (diff !== null) {
        return diff / asRoughYears(d2);
      }
    }
    if (d2.months) {
      diff = this.diffWholeMonths(m0, m1);
      if (diff !== null) {
        return diff / asRoughMonths(d2);
      }
    }
    if (d2.days) {
      diff = diffWholeDays(m0, m1);
      if (diff !== null) {
        return diff / asRoughDays(d2);
      }
    }
    return (m1.valueOf() - m0.valueOf()) / asRoughMs(d2);
  }
  // Start-Of
  // these DON'T return zoned-dates. only UTC start-of dates
  startOf(m3, unit) {
    if (unit === "year") {
      return this.startOfYear(m3);
    }
    if (unit === "month") {
      return this.startOfMonth(m3);
    }
    if (unit === "week") {
      return this.startOfWeek(m3);
    }
    if (unit === "day") {
      return startOfDay(m3);
    }
    if (unit === "hour") {
      return startOfHour(m3);
    }
    if (unit === "minute") {
      return startOfMinute(m3);
    }
    if (unit === "second") {
      return startOfSecond(m3);
    }
    return null;
  }
  startOfYear(m3) {
    return this.calendarSystem.arrayToMarker([
      this.calendarSystem.getMarkerYear(m3)
    ]);
  }
  startOfMonth(m3) {
    return this.calendarSystem.arrayToMarker([
      this.calendarSystem.getMarkerYear(m3),
      this.calendarSystem.getMarkerMonth(m3)
    ]);
  }
  startOfWeek(m3) {
    return this.calendarSystem.arrayToMarker([
      this.calendarSystem.getMarkerYear(m3),
      this.calendarSystem.getMarkerMonth(m3),
      m3.getUTCDate() - (m3.getUTCDay() - this.weekDow + 7) % 7
    ]);
  }
  // Week Number
  computeWeekNumber(marker) {
    if (this.weekNumberFunc) {
      return this.weekNumberFunc(this.toDate(marker));
    }
    return weekOfYear(marker, this.weekDow, this.weekDoy);
  }
  // TODO: choke on timeZoneName: long
  format(marker, formatter, dateOptions = {}) {
    return formatter.format({
      marker,
      timeZoneOffset: dateOptions.forcedTzo != null ? dateOptions.forcedTzo : this.offsetForMarker(marker)
    }, this);
  }
  formatRange(start, end, formatter, dateOptions = {}) {
    if (dateOptions.isEndExclusive) {
      end = addMs(end, -1);
    }
    return formatter.formatRange({
      marker: start,
      timeZoneOffset: dateOptions.forcedStartTzo != null ? dateOptions.forcedStartTzo : this.offsetForMarker(start)
    }, {
      marker: end,
      timeZoneOffset: dateOptions.forcedEndTzo != null ? dateOptions.forcedEndTzo : this.offsetForMarker(end)
    }, this, dateOptions.defaultSeparator);
  }
  /*
  DUMB: the omitTime arg is dumb. if we omit the time, we want to omit the timezone offset. and if we do that,
  might as well use buildIsoString or some other util directly
  */
  formatIso(marker, extraOptions = {}) {
    let timeZoneOffset = null;
    if (!extraOptions.omitTimeZoneOffset) {
      if (extraOptions.forcedTzo != null) {
        timeZoneOffset = extraOptions.forcedTzo;
      } else {
        timeZoneOffset = this.offsetForMarker(marker);
      }
    }
    return buildIsoString(marker, timeZoneOffset, extraOptions.omitTime);
  }
  // TimeZone
  timestampToMarker(ms) {
    if (this.timeZone === "local") {
      return arrayToUtcDate(dateToLocalArray(new Date(ms)));
    }
    if (this.timeZone === "UTC" || !this.namedTimeZoneImpl) {
      return new Date(ms);
    }
    return arrayToUtcDate(this.namedTimeZoneImpl.timestampToArray(ms));
  }
  offsetForMarker(m3) {
    if (this.timeZone === "local") {
      return -arrayToLocalDate(dateToUtcArray(m3)).getTimezoneOffset();
    }
    if (this.timeZone === "UTC") {
      return 0;
    }
    if (this.namedTimeZoneImpl) {
      return this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m3));
    }
    return null;
  }
  // Conversion
  toDate(m3, forcedTzo) {
    if (this.timeZone === "local") {
      return arrayToLocalDate(dateToUtcArray(m3));
    }
    if (this.timeZone === "UTC") {
      return new Date(m3.valueOf());
    }
    if (!this.namedTimeZoneImpl) {
      return new Date(m3.valueOf() - (forcedTzo || 0));
    }
    return new Date(m3.valueOf() - this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m3)) * 1e3 * 60);
  }
};
var Theme = class {
  constructor(calendarOptions) {
    if (this.iconOverrideOption) {
      this.setIconOverride(calendarOptions[this.iconOverrideOption]);
    }
  }
  setIconOverride(iconOverrideHash) {
    let iconClassesCopy;
    let buttonName;
    if (typeof iconOverrideHash === "object" && iconOverrideHash) {
      iconClassesCopy = Object.assign({}, this.iconClasses);
      for (buttonName in iconOverrideHash) {
        iconClassesCopy[buttonName] = this.applyIconOverridePrefix(iconOverrideHash[buttonName]);
      }
      this.iconClasses = iconClassesCopy;
    } else if (iconOverrideHash === false) {
      this.iconClasses = {};
    }
  }
  applyIconOverridePrefix(className) {
    let prefix = this.iconOverridePrefix;
    if (prefix && className.indexOf(prefix) !== 0) {
      className = prefix + className;
    }
    return className;
  }
  getClass(key) {
    return this.classes[key] || "";
  }
  getIconClass(buttonName, isRtl) {
    let className;
    if (isRtl && this.rtlIconClasses) {
      className = this.rtlIconClasses[buttonName] || this.iconClasses[buttonName];
    } else {
      className = this.iconClasses[buttonName];
    }
    if (className) {
      return `${this.baseIconClass} ${className}`;
    }
    return "";
  }
  getCustomButtonIconClass(customButtonProps) {
    let className;
    if (this.iconOverrideCustomButtonOption) {
      className = customButtonProps[this.iconOverrideCustomButtonOption];
      if (className) {
        return `${this.baseIconClass} ${this.applyIconOverridePrefix(className)}`;
      }
    }
    return "";
  }
};
Theme.prototype.classes = {};
Theme.prototype.iconClasses = {};
Theme.prototype.baseIconClass = "";
Theme.prototype.iconOverridePrefix = "";
function flushSync(runBeforeFlush) {
  runBeforeFlush();
  let oldDebounceRendering = l.debounceRendering;
  let callbackQ = [];
  function execCallbackSync(callback) {
    callbackQ.push(callback);
  }
  l.debounceRendering = execCallbackSync;
  D(y(FakeComponent, {}), document.createElement("div"));
  while (callbackQ.length) {
    callbackQ.shift()();
  }
  l.debounceRendering = oldDebounceRendering;
}
var FakeComponent = class extends x {
  render() {
    return y("div", {});
  }
  componentDidMount() {
    this.setState({});
  }
};
function createContext(defaultValue) {
  let ContextType = G(defaultValue);
  let origProvider = ContextType.Provider;
  ContextType.Provider = function() {
    let isNew = !this.getChildContext;
    let children = origProvider.apply(this, arguments);
    if (isNew) {
      let subs = [];
      this.shouldComponentUpdate = (_props) => {
        if (this.props.value !== _props.value) {
          subs.forEach((c3) => {
            c3.context = _props.value;
            c3.forceUpdate();
          });
        }
      };
      this.sub = (c3) => {
        subs.push(c3);
        let old = c3.componentWillUnmount;
        c3.componentWillUnmount = () => {
          subs.splice(subs.indexOf(c3), 1);
          old && old.call(c3);
        };
      };
    }
    return children;
  };
  return ContextType;
}
var ScrollResponder = class {
  constructor(execFunc, emitter, scrollTime, scrollTimeReset) {
    this.execFunc = execFunc;
    this.emitter = emitter;
    this.scrollTime = scrollTime;
    this.scrollTimeReset = scrollTimeReset;
    this.handleScrollRequest = (request) => {
      this.queuedRequest = Object.assign({}, this.queuedRequest || {}, request);
      this.drain();
    };
    emitter.on("_scrollRequest", this.handleScrollRequest);
    this.fireInitialScroll();
  }
  detach() {
    this.emitter.off("_scrollRequest", this.handleScrollRequest);
  }
  update(isDatesNew) {
    if (isDatesNew && this.scrollTimeReset) {
      this.fireInitialScroll();
    } else {
      this.drain();
    }
  }
  fireInitialScroll() {
    this.handleScrollRequest({
      time: this.scrollTime
    });
  }
  drain() {
    if (this.queuedRequest && this.execFunc(this.queuedRequest)) {
      this.queuedRequest = null;
    }
  }
};
var ViewContextType = createContext({});
function buildViewContext(viewSpec, viewApi, viewOptions, dateProfileGenerator, dateEnv, theme, pluginHooks, dispatch, getCurrentData, emitter, calendarApi, registerInteractiveComponent, unregisterInteractiveComponent) {
  return {
    dateEnv,
    options: viewOptions,
    pluginHooks,
    emitter,
    dispatch,
    getCurrentData,
    calendarApi,
    viewSpec,
    viewApi,
    dateProfileGenerator,
    theme,
    isRtl: viewOptions.direction === "rtl",
    addResizeHandler(handler) {
      emitter.on("_resize", handler);
    },
    removeResizeHandler(handler) {
      emitter.off("_resize", handler);
    },
    createScrollResponder(execFunc) {
      return new ScrollResponder(execFunc, emitter, createDuration(viewOptions.scrollTime), viewOptions.scrollTimeReset);
    },
    registerInteractiveComponent,
    unregisterInteractiveComponent
  };
}
var PureComponent = class extends x {
  shouldComponentUpdate(nextProps, nextState) {
    if (this.debug) {
      console.log(getUnequalProps(nextProps, this.props), getUnequalProps(nextState, this.state));
    }
    return !compareObjs(this.props, nextProps, this.propEquality) || !compareObjs(this.state, nextState, this.stateEquality);
  }
  // HACK for freakin' React StrictMode
  safeSetState(newState) {
    if (!compareObjs(this.state, Object.assign(Object.assign({}, this.state), newState), this.stateEquality)) {
      this.setState(newState);
    }
  }
};
PureComponent.addPropsEquality = addPropsEquality;
PureComponent.addStateEquality = addStateEquality;
PureComponent.contextType = ViewContextType;
PureComponent.prototype.propEquality = {};
PureComponent.prototype.stateEquality = {};
var BaseComponent = class extends PureComponent {
};
BaseComponent.contextType = ViewContextType;
function addPropsEquality(propEquality) {
  let hash = Object.create(this.prototype.propEquality);
  Object.assign(hash, propEquality);
  this.prototype.propEquality = hash;
}
function addStateEquality(stateEquality) {
  let hash = Object.create(this.prototype.stateEquality);
  Object.assign(hash, stateEquality);
  this.prototype.stateEquality = hash;
}
function setRef(ref, current) {
  if (typeof ref === "function") {
    ref(current);
  } else if (ref) {
    ref.current = current;
  }
}
var ContentInjector = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.id = guid();
    this.queuedDomNodes = [];
    this.currentDomNodes = [];
    this.handleEl = (el) => {
      const { options } = this.context;
      const { generatorName } = this.props;
      if (!options.customRenderingReplaces || !hasCustomRenderingHandler(generatorName, options)) {
        this.updateElRef(el);
      }
    };
    this.updateElRef = (el) => {
      if (this.props.elRef) {
        setRef(this.props.elRef, el);
      }
    };
  }
  render() {
    const { props, context } = this;
    const { options } = context;
    const { customGenerator, defaultGenerator, renderProps } = props;
    const attrs = buildElAttrs(props, [], this.handleEl);
    let useDefault = false;
    let innerContent;
    let queuedDomNodes = [];
    let currentGeneratorMeta;
    if (customGenerator != null) {
      const customGeneratorRes = typeof customGenerator === "function" ? customGenerator(renderProps, y) : customGenerator;
      if (customGeneratorRes === true) {
        useDefault = true;
      } else {
        const isObject2 = customGeneratorRes && typeof customGeneratorRes === "object";
        if (isObject2 && "html" in customGeneratorRes) {
          attrs.dangerouslySetInnerHTML = { __html: customGeneratorRes.html };
        } else if (isObject2 && "domNodes" in customGeneratorRes) {
          queuedDomNodes = Array.prototype.slice.call(customGeneratorRes.domNodes);
        } else if (isObject2 ? i(customGeneratorRes) : typeof customGeneratorRes !== "function") {
          innerContent = customGeneratorRes;
        } else {
          currentGeneratorMeta = customGeneratorRes;
        }
      }
    } else {
      useDefault = !hasCustomRenderingHandler(props.generatorName, options);
    }
    if (useDefault && defaultGenerator) {
      innerContent = defaultGenerator(renderProps);
    }
    this.queuedDomNodes = queuedDomNodes;
    this.currentGeneratorMeta = currentGeneratorMeta;
    return y(props.elTag, attrs, innerContent);
  }
  componentDidMount() {
    this.applyQueueudDomNodes();
    this.triggerCustomRendering(true);
  }
  componentDidUpdate() {
    this.applyQueueudDomNodes();
    this.triggerCustomRendering(true);
  }
  componentWillUnmount() {
    this.triggerCustomRendering(false);
  }
  triggerCustomRendering(isActive) {
    var _a;
    const { props, context } = this;
    const { handleCustomRendering, customRenderingMetaMap } = context.options;
    if (handleCustomRendering) {
      const generatorMeta = (_a = this.currentGeneratorMeta) !== null && _a !== void 0 ? _a : customRenderingMetaMap === null || customRenderingMetaMap === void 0 ? void 0 : customRenderingMetaMap[props.generatorName];
      if (generatorMeta) {
        handleCustomRendering(Object.assign(Object.assign({
          id: this.id,
          isActive,
          containerEl: this.base,
          reportNewContainerEl: this.updateElRef,
          // front-end framework tells us about new container els
          generatorMeta
        }, props), { elClasses: (props.elClasses || []).filter(isTruthy) }));
      }
    }
  }
  applyQueueudDomNodes() {
    const { queuedDomNodes, currentDomNodes } = this;
    const el = this.base;
    if (!isArraysEqual(queuedDomNodes, currentDomNodes)) {
      currentDomNodes.forEach(removeElement);
      for (let newNode of queuedDomNodes) {
        el.appendChild(newNode);
      }
      this.currentDomNodes = queuedDomNodes;
    }
  }
};
ContentInjector.addPropsEquality({
  elClasses: isArraysEqual,
  elStyle: isPropsEqual,
  elAttrs: isNonHandlerPropsEqual,
  renderProps: isPropsEqual
});
function hasCustomRenderingHandler(generatorName, options) {
  var _a;
  return Boolean(options.handleCustomRendering && generatorName && ((_a = options.customRenderingMetaMap) === null || _a === void 0 ? void 0 : _a[generatorName]));
}
function buildElAttrs(props, extraClassNames, elRef) {
  const attrs = Object.assign(Object.assign({}, props.elAttrs), { ref: elRef });
  if (props.elClasses || extraClassNames) {
    attrs.className = (props.elClasses || []).concat(extraClassNames || []).concat(attrs.className || []).filter(Boolean).join(" ");
  }
  if (props.elStyle) {
    attrs.style = props.elStyle;
  }
  return attrs;
}
function isTruthy(val) {
  return Boolean(val);
}
var RenderId = createContext(0);
var ContentContainer = class extends x {
  constructor() {
    super(...arguments);
    this.InnerContent = InnerContentInjector.bind(void 0, this);
    this.handleEl = (el) => {
      this.el = el;
      if (this.props.elRef) {
        setRef(this.props.elRef, el);
        if (el && this.didMountMisfire) {
          this.componentDidMount();
        }
      }
    };
  }
  render() {
    const { props } = this;
    const generatedClassNames = generateClassNames(props.classNameGenerator, props.renderProps);
    if (props.children) {
      const elAttrs = buildElAttrs(props, generatedClassNames, this.handleEl);
      const children = props.children(this.InnerContent, props.renderProps, elAttrs);
      if (props.elTag) {
        return y(props.elTag, elAttrs, children);
      } else {
        return children;
      }
    } else {
      return y(ContentInjector, Object.assign(Object.assign({}, props), { elRef: this.handleEl, elTag: props.elTag || "div", elClasses: (props.elClasses || []).concat(generatedClassNames), renderId: this.context }));
    }
  }
  componentDidMount() {
    var _a, _b;
    if (this.el) {
      (_b = (_a = this.props).didMount) === null || _b === void 0 ? void 0 : _b.call(_a, Object.assign(Object.assign({}, this.props.renderProps), { el: this.el }));
    } else {
      this.didMountMisfire = true;
    }
  }
  componentWillUnmount() {
    var _a, _b;
    (_b = (_a = this.props).willUnmount) === null || _b === void 0 ? void 0 : _b.call(_a, Object.assign(Object.assign({}, this.props.renderProps), { el: this.el }));
  }
};
ContentContainer.contextType = RenderId;
function InnerContentInjector(containerComponent, props) {
  const parentProps = containerComponent.props;
  return y(ContentInjector, Object.assign({ renderProps: parentProps.renderProps, generatorName: parentProps.generatorName, customGenerator: parentProps.customGenerator, defaultGenerator: parentProps.defaultGenerator, renderId: containerComponent.context }, props));
}
function generateClassNames(classNameGenerator, renderProps) {
  const classNames = typeof classNameGenerator === "function" ? classNameGenerator(renderProps) : classNameGenerator || [];
  return typeof classNames === "string" ? [classNames] : classNames;
}
var ViewContainer = class extends BaseComponent {
  render() {
    let { props, context } = this;
    let { options } = context;
    let renderProps = { view: context.viewApi };
    return y(ContentContainer, Object.assign({}, props, { elTag: props.elTag || "div", elClasses: [
      ...buildViewClassNames(props.viewSpec),
      ...props.elClasses || []
    ], renderProps, classNameGenerator: options.viewClassNames, generatorName: void 0, didMount: options.viewDidMount, willUnmount: options.viewWillUnmount }), () => props.children);
  }
};
function buildViewClassNames(viewSpec) {
  return [
    `fc-${viewSpec.type}-view`,
    "fc-view"
  ];
}
function parseRange(input, dateEnv) {
  let start = null;
  let end = null;
  if (input.start) {
    start = dateEnv.createMarker(input.start);
  }
  if (input.end) {
    end = dateEnv.createMarker(input.end);
  }
  if (!start && !end) {
    return null;
  }
  if (start && end && end < start) {
    return null;
  }
  return { start, end };
}
function invertRanges(ranges, constraintRange) {
  let invertedRanges = [];
  let { start } = constraintRange;
  let i3;
  let dateRange;
  ranges.sort(compareRanges);
  for (i3 = 0; i3 < ranges.length; i3 += 1) {
    dateRange = ranges[i3];
    if (dateRange.start > start) {
      invertedRanges.push({ start, end: dateRange.start });
    }
    if (dateRange.end > start) {
      start = dateRange.end;
    }
  }
  if (start < constraintRange.end) {
    invertedRanges.push({ start, end: constraintRange.end });
  }
  return invertedRanges;
}
function compareRanges(range0, range1) {
  return range0.start.valueOf() - range1.start.valueOf();
}
function intersectRanges(range0, range1) {
  let { start, end } = range0;
  let newRange = null;
  if (range1.start !== null) {
    if (start === null) {
      start = range1.start;
    } else {
      start = new Date(Math.max(start.valueOf(), range1.start.valueOf()));
    }
  }
  if (range1.end != null) {
    if (end === null) {
      end = range1.end;
    } else {
      end = new Date(Math.min(end.valueOf(), range1.end.valueOf()));
    }
  }
  if (start === null || end === null || start < end) {
    newRange = { start, end };
  }
  return newRange;
}
function rangesEqual(range0, range1) {
  return (range0.start === null ? null : range0.start.valueOf()) === (range1.start === null ? null : range1.start.valueOf()) && (range0.end === null ? null : range0.end.valueOf()) === (range1.end === null ? null : range1.end.valueOf());
}
function rangesIntersect(range0, range1) {
  return (range0.end === null || range1.start === null || range0.end > range1.start) && (range0.start === null || range1.end === null || range0.start < range1.end);
}
function rangeContainsRange(outerRange, innerRange) {
  return (outerRange.start === null || innerRange.start !== null && innerRange.start >= outerRange.start) && (outerRange.end === null || innerRange.end !== null && innerRange.end <= outerRange.end);
}
function rangeContainsMarker(range2, date) {
  return (range2.start === null || date >= range2.start) && (range2.end === null || date < range2.end);
}
function constrainMarkerToRange(date, range2) {
  if (range2.start != null && date < range2.start) {
    return range2.start;
  }
  if (range2.end != null && date >= range2.end) {
    return new Date(range2.end.valueOf() - 1);
  }
  return date;
}
function computeAlignedDayRange(timedRange) {
  let dayCnt = Math.floor(diffDays(timedRange.start, timedRange.end)) || 1;
  let start = startOfDay(timedRange.start);
  let end = addDays(start, dayCnt);
  return { start, end };
}
function computeVisibleDayRange(timedRange, nextDayThreshold = createDuration(0)) {
  let startDay = null;
  let endDay = null;
  if (timedRange.end) {
    endDay = startOfDay(timedRange.end);
    let endTimeMS = timedRange.end.valueOf() - endDay.valueOf();
    if (endTimeMS && endTimeMS >= asRoughMs(nextDayThreshold)) {
      endDay = addDays(endDay, 1);
    }
  }
  if (timedRange.start) {
    startDay = startOfDay(timedRange.start);
    if (endDay && endDay <= startDay) {
      endDay = addDays(startDay, 1);
    }
  }
  return { start: startDay, end: endDay };
}
function isMultiDayRange(range2) {
  let visibleRange = computeVisibleDayRange(range2);
  return diffDays(visibleRange.start, visibleRange.end) > 1;
}
function diffDates(date0, date1, dateEnv, largeUnit) {
  if (largeUnit === "year") {
    return createDuration(dateEnv.diffWholeYears(date0, date1), "year");
  }
  if (largeUnit === "month") {
    return createDuration(dateEnv.diffWholeMonths(date0, date1), "month");
  }
  return diffDayAndTime(date0, date1);
}
function reduceCurrentDate(currentDate, action) {
  switch (action.type) {
    case "CHANGE_DATE":
      return action.dateMarker;
    default:
      return currentDate;
  }
}
function getInitialDate(options, dateEnv) {
  let initialDateInput = options.initialDate;
  if (initialDateInput != null) {
    return dateEnv.createMarker(initialDateInput);
  }
  return getNow(options.now, dateEnv);
}
function getNow(nowInput, dateEnv) {
  if (typeof nowInput === "function") {
    nowInput = nowInput();
  }
  if (nowInput == null) {
    return dateEnv.createNowMarker();
  }
  return dateEnv.createMarker(nowInput);
}
var DateProfileGenerator = class {
  constructor(props) {
    this.props = props;
    this.nowDate = getNow(props.nowInput, props.dateEnv);
    this.initHiddenDays();
  }
  /* Date Range Computation
  ------------------------------------------------------------------------------------------------------------------*/
  // Builds a structure with info about what the dates/ranges will be for the "prev" view.
  buildPrev(currentDateProfile, currentDate, forceToValid) {
    let { dateEnv } = this.props;
    let prevDate = dateEnv.subtract(
      dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit),
      // important for start-of-month
      currentDateProfile.dateIncrement
    );
    return this.build(prevDate, -1, forceToValid);
  }
  // Builds a structure with info about what the dates/ranges will be for the "next" view.
  buildNext(currentDateProfile, currentDate, forceToValid) {
    let { dateEnv } = this.props;
    let nextDate = dateEnv.add(
      dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit),
      // important for start-of-month
      currentDateProfile.dateIncrement
    );
    return this.build(nextDate, 1, forceToValid);
  }
  // Builds a structure holding dates/ranges for rendering around the given date.
  // Optional direction param indicates whether the date is being incremented/decremented
  // from its previous value. decremented = -1, incremented = 1 (default).
  build(currentDate, direction, forceToValid = true) {
    let { props } = this;
    let validRange;
    let currentInfo;
    let isRangeAllDay;
    let renderRange;
    let activeRange;
    let isValid;
    validRange = this.buildValidRange();
    validRange = this.trimHiddenDays(validRange);
    if (forceToValid) {
      currentDate = constrainMarkerToRange(currentDate, validRange);
    }
    currentInfo = this.buildCurrentRangeInfo(currentDate, direction);
    isRangeAllDay = /^(year|month|week|day)$/.test(currentInfo.unit);
    renderRange = this.buildRenderRange(this.trimHiddenDays(currentInfo.range), currentInfo.unit, isRangeAllDay);
    renderRange = this.trimHiddenDays(renderRange);
    activeRange = renderRange;
    if (!props.showNonCurrentDates) {
      activeRange = intersectRanges(activeRange, currentInfo.range);
    }
    activeRange = this.adjustActiveRange(activeRange);
    activeRange = intersectRanges(activeRange, validRange);
    isValid = rangesIntersect(currentInfo.range, validRange);
    if (!rangeContainsMarker(renderRange, currentDate)) {
      currentDate = renderRange.start;
    }
    return {
      currentDate,
      // constraint for where prev/next operations can go and where events can be dragged/resized to.
      // an object with optional start and end properties.
      validRange,
      // range the view is formally responsible for.
      // for example, a month view might have 1st-31st, excluding padded dates
      currentRange: currentInfo.range,
      // name of largest unit being displayed, like "month" or "week"
      currentRangeUnit: currentInfo.unit,
      isRangeAllDay,
      // dates that display events and accept drag-n-drop
      // will be `null` if no dates accept events
      activeRange,
      // date range with a rendered skeleton
      // includes not-active days that need some sort of DOM
      renderRange,
      // Duration object that denotes the first visible time of any given day
      slotMinTime: props.slotMinTime,
      // Duration object that denotes the exclusive visible end time of any given day
      slotMaxTime: props.slotMaxTime,
      isValid,
      // how far the current date will move for a prev/next operation
      dateIncrement: this.buildDateIncrement(currentInfo.duration)
      // pass a fallback (might be null) ^
    };
  }
  // Builds an object with optional start/end properties.
  // Indicates the minimum/maximum dates to display.
  // not responsible for trimming hidden days.
  buildValidRange() {
    let input = this.props.validRangeInput;
    let simpleInput = typeof input === "function" ? input.call(this.props.calendarApi, this.nowDate) : input;
    return this.refineRange(simpleInput) || { start: null, end: null };
  }
  // Builds a structure with info about the "current" range, the range that is
  // highlighted as being the current month for example.
  // See build() for a description of `direction`.
  // Guaranteed to have `range` and `unit` properties. `duration` is optional.
  buildCurrentRangeInfo(date, direction) {
    let { props } = this;
    let duration = null;
    let unit = null;
    let range2 = null;
    let dayCount;
    if (props.duration) {
      duration = props.duration;
      unit = props.durationUnit;
      range2 = this.buildRangeFromDuration(date, direction, duration, unit);
    } else if (dayCount = this.props.dayCount) {
      unit = "day";
      range2 = this.buildRangeFromDayCount(date, direction, dayCount);
    } else if (range2 = this.buildCustomVisibleRange(date)) {
      unit = props.dateEnv.greatestWholeUnit(range2.start, range2.end).unit;
    } else {
      duration = this.getFallbackDuration();
      unit = greatestDurationDenominator(duration).unit;
      range2 = this.buildRangeFromDuration(date, direction, duration, unit);
    }
    return { duration, unit, range: range2 };
  }
  getFallbackDuration() {
    return createDuration({ day: 1 });
  }
  // Returns a new activeRange to have time values (un-ambiguate)
  // slotMinTime or slotMaxTime causes the range to expand.
  adjustActiveRange(range2) {
    let { dateEnv, usesMinMaxTime, slotMinTime, slotMaxTime } = this.props;
    let { start, end } = range2;
    if (usesMinMaxTime) {
      if (asRoughDays(slotMinTime) < 0) {
        start = startOfDay(start);
        start = dateEnv.add(start, slotMinTime);
      }
      if (asRoughDays(slotMaxTime) > 1) {
        end = startOfDay(end);
        end = addDays(end, -1);
        end = dateEnv.add(end, slotMaxTime);
      }
    }
    return { start, end };
  }
  // Builds the "current" range when it is specified as an explicit duration.
  // `unit` is the already-computed greatestDurationDenominator unit of duration.
  buildRangeFromDuration(date, direction, duration, unit) {
    let { dateEnv, dateAlignment } = this.props;
    let start;
    let end;
    let res;
    if (!dateAlignment) {
      let { dateIncrement } = this.props;
      if (dateIncrement) {
        if (asRoughMs(dateIncrement) < asRoughMs(duration)) {
          dateAlignment = greatestDurationDenominator(dateIncrement).unit;
        } else {
          dateAlignment = unit;
        }
      } else {
        dateAlignment = unit;
      }
    }
    if (asRoughDays(duration) <= 1) {
      if (this.isHiddenDay(start)) {
        start = this.skipHiddenDays(start, direction);
        start = startOfDay(start);
      }
    }
    function computeRes() {
      start = dateEnv.startOf(date, dateAlignment);
      end = dateEnv.add(start, duration);
      res = { start, end };
    }
    computeRes();
    if (!this.trimHiddenDays(res)) {
      date = this.skipHiddenDays(date, direction);
      computeRes();
    }
    return res;
  }
  // Builds the "current" range when a dayCount is specified.
  buildRangeFromDayCount(date, direction, dayCount) {
    let { dateEnv, dateAlignment } = this.props;
    let runningCount = 0;
    let start = date;
    let end;
    if (dateAlignment) {
      start = dateEnv.startOf(start, dateAlignment);
    }
    start = startOfDay(start);
    start = this.skipHiddenDays(start, direction);
    end = start;
    do {
      end = addDays(end, 1);
      if (!this.isHiddenDay(end)) {
        runningCount += 1;
      }
    } while (runningCount < dayCount);
    return { start, end };
  }
  // Builds a normalized range object for the "visible" range,
  // which is a way to define the currentRange and activeRange at the same time.
  buildCustomVisibleRange(date) {
    let { props } = this;
    let input = props.visibleRangeInput;
    let simpleInput = typeof input === "function" ? input.call(props.calendarApi, props.dateEnv.toDate(date)) : input;
    let range2 = this.refineRange(simpleInput);
    if (range2 && (range2.start == null || range2.end == null)) {
      return null;
    }
    return range2;
  }
  // Computes the range that will represent the element/cells for *rendering*,
  // but which may have voided days/times.
  // not responsible for trimming hidden days.
  buildRenderRange(currentRange, currentRangeUnit, isRangeAllDay) {
    return currentRange;
  }
  // Compute the duration value that should be added/substracted to the current date
  // when a prev/next operation happens.
  buildDateIncrement(fallback) {
    let { dateIncrement } = this.props;
    let customAlignment;
    if (dateIncrement) {
      return dateIncrement;
    }
    if (customAlignment = this.props.dateAlignment) {
      return createDuration(1, customAlignment);
    }
    if (fallback) {
      return fallback;
    }
    return createDuration({ days: 1 });
  }
  refineRange(rangeInput) {
    if (rangeInput) {
      let range2 = parseRange(rangeInput, this.props.dateEnv);
      if (range2) {
        range2 = computeVisibleDayRange(range2);
      }
      return range2;
    }
    return null;
  }
  /* Hidden Days
  ------------------------------------------------------------------------------------------------------------------*/
  // Initializes internal variables related to calculating hidden days-of-week
  initHiddenDays() {
    let hiddenDays = this.props.hiddenDays || [];
    let isHiddenDayHash = [];
    let dayCnt = 0;
    let i3;
    if (this.props.weekends === false) {
      hiddenDays.push(0, 6);
    }
    for (i3 = 0; i3 < 7; i3 += 1) {
      if (!(isHiddenDayHash[i3] = hiddenDays.indexOf(i3) !== -1)) {
        dayCnt += 1;
      }
    }
    if (!dayCnt) {
      throw new Error("invalid hiddenDays");
    }
    this.isHiddenDayHash = isHiddenDayHash;
  }
  // Remove days from the beginning and end of the range that are computed as hidden.
  // If the whole range is trimmed off, returns null
  trimHiddenDays(range2) {
    let { start, end } = range2;
    if (start) {
      start = this.skipHiddenDays(start);
    }
    if (end) {
      end = this.skipHiddenDays(end, -1, true);
    }
    if (start == null || end == null || start < end) {
      return { start, end };
    }
    return null;
  }
  // Is the current day hidden?
  // `day` is a day-of-week index (0-6), or a Date (used for UTC)
  isHiddenDay(day) {
    if (day instanceof Date) {
      day = day.getUTCDay();
    }
    return this.isHiddenDayHash[day];
  }
  // Incrementing the current day until it is no longer a hidden day, returning a copy.
  // DOES NOT CONSIDER validRange!
  // If the initial value of `date` is not a hidden day, don't do anything.
  // Pass `isExclusive` as `true` if you are dealing with an end date.
  // `inc` defaults to `1` (increment one day forward each time)
  skipHiddenDays(date, inc = 1, isExclusive = false) {
    while (this.isHiddenDayHash[(date.getUTCDay() + (isExclusive ? inc : 0) + 7) % 7]) {
      date = addDays(date, inc);
    }
    return date;
  }
};
function createEventInstance(defId, range2, forcedStartTzo, forcedEndTzo) {
  return {
    instanceId: guid(),
    defId,
    range: range2,
    forcedStartTzo: forcedStartTzo == null ? null : forcedStartTzo,
    forcedEndTzo: forcedEndTzo == null ? null : forcedEndTzo
  };
}
function parseRecurring(refined, defaultAllDay, dateEnv, recurringTypes) {
  for (let i3 = 0; i3 < recurringTypes.length; i3 += 1) {
    let parsed = recurringTypes[i3].parse(refined, dateEnv);
    if (parsed) {
      let { allDay } = refined;
      if (allDay == null) {
        allDay = defaultAllDay;
        if (allDay == null) {
          allDay = parsed.allDayGuess;
          if (allDay == null) {
            allDay = false;
          }
        }
      }
      return {
        allDay,
        duration: parsed.duration,
        typeData: parsed.typeData,
        typeId: i3
      };
    }
  }
  return null;
}
function expandRecurring(eventStore, framingRange, context) {
  let { dateEnv, pluginHooks, options } = context;
  let { defs, instances } = eventStore;
  instances = filterHash(instances, (instance) => !defs[instance.defId].recurringDef);
  for (let defId in defs) {
    let def = defs[defId];
    if (def.recurringDef) {
      let { duration } = def.recurringDef;
      if (!duration) {
        duration = def.allDay ? options.defaultAllDayEventDuration : options.defaultTimedEventDuration;
      }
      let starts = expandRecurringRanges(def, duration, framingRange, dateEnv, pluginHooks.recurringTypes);
      for (let start of starts) {
        let instance = createEventInstance(defId, {
          start,
          end: dateEnv.add(start, duration)
        });
        instances[instance.instanceId] = instance;
      }
    }
  }
  return { defs, instances };
}
function expandRecurringRanges(eventDef, duration, framingRange, dateEnv, recurringTypes) {
  let typeDef = recurringTypes[eventDef.recurringDef.typeId];
  let markers = typeDef.expand(eventDef.recurringDef.typeData, {
    start: dateEnv.subtract(framingRange.start, duration),
    end: framingRange.end
  }, dateEnv);
  if (eventDef.allDay) {
    markers = markers.map(startOfDay);
  }
  return markers;
}
var EVENT_NON_DATE_REFINERS = {
  id: String,
  groupId: String,
  title: String,
  url: String,
  interactive: Boolean
};
var EVENT_DATE_REFINERS = {
  start: identity,
  end: identity,
  date: identity,
  allDay: Boolean
};
var EVENT_REFINERS = Object.assign(Object.assign(Object.assign({}, EVENT_NON_DATE_REFINERS), EVENT_DATE_REFINERS), { extendedProps: identity });
function parseEvent(raw, eventSource, context, allowOpenRange, refiners = buildEventRefiners(context), defIdMap, instanceIdMap) {
  let { refined, extra } = refineEventDef(raw, context, refiners);
  let defaultAllDay = computeIsDefaultAllDay(eventSource, context);
  let recurringRes = parseRecurring(refined, defaultAllDay, context.dateEnv, context.pluginHooks.recurringTypes);
  if (recurringRes) {
    let def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : "", recurringRes.allDay, Boolean(recurringRes.duration), context, defIdMap);
    def.recurringDef = {
      typeId: recurringRes.typeId,
      typeData: recurringRes.typeData,
      duration: recurringRes.duration
    };
    return { def, instance: null };
  }
  let singleRes = parseSingle(refined, defaultAllDay, context, allowOpenRange);
  if (singleRes) {
    let def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : "", singleRes.allDay, singleRes.hasEnd, context, defIdMap);
    let instance = createEventInstance(def.defId, singleRes.range, singleRes.forcedStartTzo, singleRes.forcedEndTzo);
    if (instanceIdMap && def.publicId && instanceIdMap[def.publicId]) {
      instance.instanceId = instanceIdMap[def.publicId];
    }
    return { def, instance };
  }
  return null;
}
function refineEventDef(raw, context, refiners = buildEventRefiners(context)) {
  return refineProps(raw, refiners);
}
function buildEventRefiners(context) {
  return Object.assign(Object.assign(Object.assign({}, EVENT_UI_REFINERS), EVENT_REFINERS), context.pluginHooks.eventRefiners);
}
function parseEventDef(refined, extra, sourceId, allDay, hasEnd, context, defIdMap) {
  let def = {
    title: refined.title || "",
    groupId: refined.groupId || "",
    publicId: refined.id || "",
    url: refined.url || "",
    recurringDef: null,
    defId: (defIdMap && refined.id ? defIdMap[refined.id] : "") || guid(),
    sourceId,
    allDay,
    hasEnd,
    interactive: refined.interactive,
    ui: createEventUi(refined, context),
    extendedProps: Object.assign(Object.assign({}, refined.extendedProps || {}), extra)
  };
  for (let memberAdder of context.pluginHooks.eventDefMemberAdders) {
    Object.assign(def, memberAdder(refined));
  }
  Object.freeze(def.ui.classNames);
  Object.freeze(def.extendedProps);
  return def;
}
function parseSingle(refined, defaultAllDay, context, allowOpenRange) {
  let { allDay } = refined;
  let startMeta;
  let startMarker = null;
  let hasEnd = false;
  let endMeta;
  let endMarker = null;
  let startInput = refined.start != null ? refined.start : refined.date;
  startMeta = context.dateEnv.createMarkerMeta(startInput);
  if (startMeta) {
    startMarker = startMeta.marker;
  } else if (!allowOpenRange) {
    return null;
  }
  if (refined.end != null) {
    endMeta = context.dateEnv.createMarkerMeta(refined.end);
  }
  if (allDay == null) {
    if (defaultAllDay != null) {
      allDay = defaultAllDay;
    } else {
      allDay = (!startMeta || startMeta.isTimeUnspecified) && (!endMeta || endMeta.isTimeUnspecified);
    }
  }
  if (allDay && startMarker) {
    startMarker = startOfDay(startMarker);
  }
  if (endMeta) {
    endMarker = endMeta.marker;
    if (allDay) {
      endMarker = startOfDay(endMarker);
    }
    if (startMarker && endMarker <= startMarker) {
      endMarker = null;
    }
  }
  if (endMarker) {
    hasEnd = true;
  } else if (!allowOpenRange) {
    hasEnd = context.options.forceEventDuration || false;
    endMarker = context.dateEnv.add(startMarker, allDay ? context.options.defaultAllDayEventDuration : context.options.defaultTimedEventDuration);
  }
  return {
    allDay,
    hasEnd,
    range: { start: startMarker, end: endMarker },
    forcedStartTzo: startMeta ? startMeta.forcedTzo : null,
    forcedEndTzo: endMeta ? endMeta.forcedTzo : null
  };
}
function computeIsDefaultAllDay(eventSource, context) {
  let res = null;
  if (eventSource) {
    res = eventSource.defaultAllDay;
  }
  if (res == null) {
    res = context.options.defaultAllDay;
  }
  return res;
}
function parseEvents(rawEvents, eventSource, context, allowOpenRange, defIdMap, instanceIdMap) {
  let eventStore = createEmptyEventStore();
  let eventRefiners = buildEventRefiners(context);
  for (let rawEvent of rawEvents) {
    let tuple = parseEvent(rawEvent, eventSource, context, allowOpenRange, eventRefiners, defIdMap, instanceIdMap);
    if (tuple) {
      eventTupleToStore(tuple, eventStore);
    }
  }
  return eventStore;
}
function eventTupleToStore(tuple, eventStore = createEmptyEventStore()) {
  eventStore.defs[tuple.def.defId] = tuple.def;
  if (tuple.instance) {
    eventStore.instances[tuple.instance.instanceId] = tuple.instance;
  }
  return eventStore;
}
function getRelevantEvents(eventStore, instanceId) {
  let instance = eventStore.instances[instanceId];
  if (instance) {
    let def = eventStore.defs[instance.defId];
    let newStore = filterEventStoreDefs(eventStore, (lookDef) => isEventDefsGrouped(def, lookDef));
    newStore.defs[def.defId] = def;
    newStore.instances[instance.instanceId] = instance;
    return newStore;
  }
  return createEmptyEventStore();
}
function isEventDefsGrouped(def0, def1) {
  return Boolean(def0.groupId && def0.groupId === def1.groupId);
}
function createEmptyEventStore() {
  return { defs: {}, instances: {} };
}
function mergeEventStores(store0, store1) {
  return {
    defs: Object.assign(Object.assign({}, store0.defs), store1.defs),
    instances: Object.assign(Object.assign({}, store0.instances), store1.instances)
  };
}
function filterEventStoreDefs(eventStore, filterFunc) {
  let defs = filterHash(eventStore.defs, filterFunc);
  let instances = filterHash(eventStore.instances, (instance) => defs[instance.defId]);
  return { defs, instances };
}
function excludeSubEventStore(master, sub) {
  let { defs, instances } = master;
  let filteredDefs = {};
  let filteredInstances = {};
  for (let defId in defs) {
    if (!sub.defs[defId]) {
      filteredDefs[defId] = defs[defId];
    }
  }
  for (let instanceId in instances) {
    if (!sub.instances[instanceId] && // not explicitly excluded
    filteredDefs[instances[instanceId].defId]) {
      filteredInstances[instanceId] = instances[instanceId];
    }
  }
  return {
    defs: filteredDefs,
    instances: filteredInstances
  };
}
function normalizeConstraint(input, context) {
  if (Array.isArray(input)) {
    return parseEvents(input, null, context, true);
  }
  if (typeof input === "object" && input) {
    return parseEvents([input], null, context, true);
  }
  if (input != null) {
    return String(input);
  }
  return null;
}
function parseClassNames(raw) {
  if (Array.isArray(raw)) {
    return raw;
  }
  if (typeof raw === "string") {
    return raw.split(/\s+/);
  }
  return [];
}
var EVENT_UI_REFINERS = {
  display: String,
  editable: Boolean,
  startEditable: Boolean,
  durationEditable: Boolean,
  constraint: identity,
  overlap: identity,
  allow: identity,
  className: parseClassNames,
  classNames: parseClassNames,
  color: String,
  backgroundColor: String,
  borderColor: String,
  textColor: String
};
var EMPTY_EVENT_UI = {
  display: null,
  startEditable: null,
  durationEditable: null,
  constraints: [],
  overlap: null,
  allows: [],
  backgroundColor: "",
  borderColor: "",
  textColor: "",
  classNames: []
};
function createEventUi(refined, context) {
  let constraint = normalizeConstraint(refined.constraint, context);
  return {
    display: refined.display || null,
    startEditable: refined.startEditable != null ? refined.startEditable : refined.editable,
    durationEditable: refined.durationEditable != null ? refined.durationEditable : refined.editable,
    constraints: constraint != null ? [constraint] : [],
    overlap: refined.overlap != null ? refined.overlap : null,
    allows: refined.allow != null ? [refined.allow] : [],
    backgroundColor: refined.backgroundColor || refined.color || "",
    borderColor: refined.borderColor || refined.color || "",
    textColor: refined.textColor || "",
    classNames: (refined.className || []).concat(refined.classNames || [])
    // join singular and plural
  };
}
function combineEventUis(uis) {
  return uis.reduce(combineTwoEventUis, EMPTY_EVENT_UI);
}
function combineTwoEventUis(item0, item1) {
  return {
    display: item1.display != null ? item1.display : item0.display,
    startEditable: item1.startEditable != null ? item1.startEditable : item0.startEditable,
    durationEditable: item1.durationEditable != null ? item1.durationEditable : item0.durationEditable,
    constraints: item0.constraints.concat(item1.constraints),
    overlap: typeof item1.overlap === "boolean" ? item1.overlap : item0.overlap,
    allows: item0.allows.concat(item1.allows),
    backgroundColor: item1.backgroundColor || item0.backgroundColor,
    borderColor: item1.borderColor || item0.borderColor,
    textColor: item1.textColor || item0.textColor,
    classNames: item0.classNames.concat(item1.classNames)
  };
}
var EVENT_SOURCE_REFINERS = {
  id: String,
  defaultAllDay: Boolean,
  url: String,
  format: String,
  events: identity,
  eventDataTransform: identity,
  // for any network-related sources
  success: identity,
  failure: identity
};
function parseEventSource(raw, context, refiners = buildEventSourceRefiners(context)) {
  let rawObj;
  if (typeof raw === "string") {
    rawObj = { url: raw };
  } else if (typeof raw === "function" || Array.isArray(raw)) {
    rawObj = { events: raw };
  } else if (typeof raw === "object" && raw) {
    rawObj = raw;
  }
  if (rawObj) {
    let { refined, extra } = refineProps(rawObj, refiners);
    let metaRes = buildEventSourceMeta(refined, context);
    if (metaRes) {
      return {
        _raw: raw,
        isFetching: false,
        latestFetchId: "",
        fetchRange: null,
        defaultAllDay: refined.defaultAllDay,
        eventDataTransform: refined.eventDataTransform,
        success: refined.success,
        failure: refined.failure,
        publicId: refined.id || "",
        sourceId: guid(),
        sourceDefId: metaRes.sourceDefId,
        meta: metaRes.meta,
        ui: createEventUi(refined, context),
        extendedProps: extra
      };
    }
  }
  return null;
}
function buildEventSourceRefiners(context) {
  return Object.assign(Object.assign(Object.assign({}, EVENT_UI_REFINERS), EVENT_SOURCE_REFINERS), context.pluginHooks.eventSourceRefiners);
}
function buildEventSourceMeta(raw, context) {
  let defs = context.pluginHooks.eventSourceDefs;
  for (let i3 = defs.length - 1; i3 >= 0; i3 -= 1) {
    let def = defs[i3];
    let meta = def.parseMeta(raw);
    if (meta) {
      return { sourceDefId: i3, meta };
    }
  }
  return null;
}
function reduceEventStore(eventStore, action, eventSources, dateProfile, context) {
  switch (action.type) {
    case "RECEIVE_EVENTS":
      return receiveRawEvents(eventStore, eventSources[action.sourceId], action.fetchId, action.fetchRange, action.rawEvents, context);
    case "RESET_RAW_EVENTS":
      return resetRawEvents(eventStore, eventSources[action.sourceId], action.rawEvents, dateProfile.activeRange, context);
    case "ADD_EVENTS":
      return addEvent(
        eventStore,
        action.eventStore,
        // new ones
        dateProfile ? dateProfile.activeRange : null,
        context
      );
    case "RESET_EVENTS":
      return action.eventStore;
    case "MERGE_EVENTS":
      return mergeEventStores(eventStore, action.eventStore);
    case "PREV":
    case "NEXT":
    case "CHANGE_DATE":
    case "CHANGE_VIEW_TYPE":
      if (dateProfile) {
        return expandRecurring(eventStore, dateProfile.activeRange, context);
      }
      return eventStore;
    case "REMOVE_EVENTS":
      return excludeSubEventStore(eventStore, action.eventStore);
    case "REMOVE_EVENT_SOURCE":
      return excludeEventsBySourceId(eventStore, action.sourceId);
    case "REMOVE_ALL_EVENT_SOURCES":
      return filterEventStoreDefs(eventStore, (eventDef) => !eventDef.sourceId);
    case "REMOVE_ALL_EVENTS":
      return createEmptyEventStore();
    default:
      return eventStore;
  }
}
function receiveRawEvents(eventStore, eventSource, fetchId, fetchRange, rawEvents, context) {
  if (eventSource && // not already removed
  fetchId === eventSource.latestFetchId) {
    let subset = parseEvents(transformRawEvents(rawEvents, eventSource, context), eventSource, context);
    if (fetchRange) {
      subset = expandRecurring(subset, fetchRange, context);
    }
    return mergeEventStores(excludeEventsBySourceId(eventStore, eventSource.sourceId), subset);
  }
  return eventStore;
}
function resetRawEvents(existingEventStore, eventSource, rawEvents, activeRange, context) {
  const { defIdMap, instanceIdMap } = buildPublicIdMaps(existingEventStore);
  let newEventStore = parseEvents(transformRawEvents(rawEvents, eventSource, context), eventSource, context, false, defIdMap, instanceIdMap);
  return expandRecurring(newEventStore, activeRange, context);
}
function transformRawEvents(rawEvents, eventSource, context) {
  let calEachTransform = context.options.eventDataTransform;
  let sourceEachTransform = eventSource ? eventSource.eventDataTransform : null;
  if (sourceEachTransform) {
    rawEvents = transformEachRawEvent(rawEvents, sourceEachTransform);
  }
  if (calEachTransform) {
    rawEvents = transformEachRawEvent(rawEvents, calEachTransform);
  }
  return rawEvents;
}
function transformEachRawEvent(rawEvents, func) {
  let refinedEvents;
  if (!func) {
    refinedEvents = rawEvents;
  } else {
    refinedEvents = [];
    for (let rawEvent of rawEvents) {
      let refinedEvent = func(rawEvent);
      if (refinedEvent) {
        refinedEvents.push(refinedEvent);
      } else if (refinedEvent == null) {
        refinedEvents.push(rawEvent);
      }
    }
  }
  return refinedEvents;
}
function addEvent(eventStore, subset, expandRange, context) {
  if (expandRange) {
    subset = expandRecurring(subset, expandRange, context);
  }
  return mergeEventStores(eventStore, subset);
}
function rezoneEventStoreDates(eventStore, oldDateEnv, newDateEnv) {
  let { defs } = eventStore;
  let instances = mapHash(eventStore.instances, (instance) => {
    let def = defs[instance.defId];
    if (def.allDay) {
      return instance;
    }
    return Object.assign(Object.assign({}, instance), { range: {
      start: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.start, instance.forcedStartTzo)),
      end: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.end, instance.forcedEndTzo))
    }, forcedStartTzo: newDateEnv.canComputeOffset ? null : instance.forcedStartTzo, forcedEndTzo: newDateEnv.canComputeOffset ? null : instance.forcedEndTzo });
  });
  return { defs, instances };
}
function excludeEventsBySourceId(eventStore, sourceId) {
  return filterEventStoreDefs(eventStore, (eventDef) => eventDef.sourceId !== sourceId);
}
function excludeInstances(eventStore, removals) {
  return {
    defs: eventStore.defs,
    instances: filterHash(eventStore.instances, (instance) => !removals[instance.instanceId])
  };
}
function buildPublicIdMaps(eventStore) {
  const { defs, instances } = eventStore;
  const defIdMap = {};
  const instanceIdMap = {};
  for (let defId in defs) {
    const def = defs[defId];
    const { publicId } = def;
    if (publicId) {
      defIdMap[publicId] = defId;
    }
  }
  for (let instanceId in instances) {
    const instance = instances[instanceId];
    const def = defs[instance.defId];
    const { publicId } = def;
    if (publicId) {
      instanceIdMap[publicId] = instanceId;
    }
  }
  return { defIdMap, instanceIdMap };
}
var Emitter = class {
  constructor() {
    this.handlers = {};
    this.thisContext = null;
  }
  setThisContext(thisContext) {
    this.thisContext = thisContext;
  }
  setOptions(options) {
    this.options = options;
  }
  on(type, handler) {
    addToHash(this.handlers, type, handler);
  }
  off(type, handler) {
    removeFromHash(this.handlers, type, handler);
  }
  trigger(type, ...args) {
    let attachedHandlers = this.handlers[type] || [];
    let optionHandler = this.options && this.options[type];
    let handlers = [].concat(optionHandler || [], attachedHandlers);
    for (let handler of handlers) {
      handler.apply(this.thisContext, args);
    }
  }
  hasHandlers(type) {
    return Boolean(this.handlers[type] && this.handlers[type].length || this.options && this.options[type]);
  }
};
function addToHash(hash, type, handler) {
  (hash[type] || (hash[type] = [])).push(handler);
}
function removeFromHash(hash, type, handler) {
  if (handler) {
    if (hash[type]) {
      hash[type] = hash[type].filter((func) => func !== handler);
    }
  } else {
    delete hash[type];
  }
}
var DEF_DEFAULTS = {
  startTime: "09:00",
  endTime: "17:00",
  daysOfWeek: [1, 2, 3, 4, 5],
  display: "inverse-background",
  classNames: "fc-non-business",
  groupId: "_businessHours"
  // so multiple defs get grouped
};
function parseBusinessHours(input, context) {
  return parseEvents(refineInputs(input), null, context);
}
function refineInputs(input) {
  let rawDefs;
  if (input === true) {
    rawDefs = [{}];
  } else if (Array.isArray(input)) {
    rawDefs = input.filter((rawDef) => rawDef.daysOfWeek);
  } else if (typeof input === "object" && input) {
    rawDefs = [input];
  } else {
    rawDefs = [];
  }
  rawDefs = rawDefs.map((rawDef) => Object.assign(Object.assign({}, DEF_DEFAULTS), rawDef));
  return rawDefs;
}
function triggerDateSelect(selection, pev, context) {
  context.emitter.trigger("select", Object.assign(Object.assign({}, buildDateSpanApiWithContext(selection, context)), { jsEvent: pev ? pev.origEvent : null, view: context.viewApi || context.calendarApi.view }));
}
function triggerDateUnselect(pev, context) {
  context.emitter.trigger("unselect", {
    jsEvent: pev ? pev.origEvent : null,
    view: context.viewApi || context.calendarApi.view
  });
}
function buildDateSpanApiWithContext(dateSpan, context) {
  let props = {};
  for (let transform of context.pluginHooks.dateSpanTransforms) {
    Object.assign(props, transform(dateSpan, context));
  }
  Object.assign(props, buildDateSpanApi(dateSpan, context.dateEnv));
  return props;
}
function getDefaultEventEnd(allDay, marker, context) {
  let { dateEnv, options } = context;
  let end = marker;
  if (allDay) {
    end = startOfDay(end);
    end = dateEnv.add(end, options.defaultAllDayEventDuration);
  } else {
    end = dateEnv.add(end, options.defaultTimedEventDuration);
  }
  return end;
}
function applyMutationToEventStore(eventStore, eventConfigBase, mutation, context) {
  let eventConfigs = compileEventUis(eventStore.defs, eventConfigBase);
  let dest = createEmptyEventStore();
  for (let defId in eventStore.defs) {
    let def = eventStore.defs[defId];
    dest.defs[defId] = applyMutationToEventDef(def, eventConfigs[defId], mutation, context);
  }
  for (let instanceId in eventStore.instances) {
    let instance = eventStore.instances[instanceId];
    let def = dest.defs[instance.defId];
    dest.instances[instanceId] = applyMutationToEventInstance(instance, def, eventConfigs[instance.defId], mutation, context);
  }
  return dest;
}
function applyMutationToEventDef(eventDef, eventConfig, mutation, context) {
  let standardProps = mutation.standardProps || {};
  if (standardProps.hasEnd == null && eventConfig.durationEditable && (mutation.startDelta || mutation.endDelta)) {
    standardProps.hasEnd = true;
  }
  let copy = Object.assign(Object.assign(Object.assign({}, eventDef), standardProps), { ui: Object.assign(Object.assign({}, eventDef.ui), standardProps.ui) });
  if (mutation.extendedProps) {
    copy.extendedProps = Object.assign(Object.assign({}, copy.extendedProps), mutation.extendedProps);
  }
  for (let applier of context.pluginHooks.eventDefMutationAppliers) {
    applier(copy, mutation, context);
  }
  if (!copy.hasEnd && context.options.forceEventDuration) {
    copy.hasEnd = true;
  }
  return copy;
}
function applyMutationToEventInstance(eventInstance, eventDef, eventConfig, mutation, context) {
  let { dateEnv } = context;
  let forceAllDay = mutation.standardProps && mutation.standardProps.allDay === true;
  let clearEnd = mutation.standardProps && mutation.standardProps.hasEnd === false;
  let copy = Object.assign({}, eventInstance);
  if (forceAllDay) {
    copy.range = computeAlignedDayRange(copy.range);
  }
  if (mutation.datesDelta && eventConfig.startEditable) {
    copy.range = {
      start: dateEnv.add(copy.range.start, mutation.datesDelta),
      end: dateEnv.add(copy.range.end, mutation.datesDelta)
    };
  }
  if (mutation.startDelta && eventConfig.durationEditable) {
    copy.range = {
      start: dateEnv.add(copy.range.start, mutation.startDelta),
      end: copy.range.end
    };
  }
  if (mutation.endDelta && eventConfig.durationEditable) {
    copy.range = {
      start: copy.range.start,
      end: dateEnv.add(copy.range.end, mutation.endDelta)
    };
  }
  if (clearEnd) {
    copy.range = {
      start: copy.range.start,
      end: getDefaultEventEnd(eventDef.allDay, copy.range.start, context)
    };
  }
  if (eventDef.allDay) {
    copy.range = {
      start: startOfDay(copy.range.start),
      end: startOfDay(copy.range.end)
    };
  }
  if (copy.range.end < copy.range.start) {
    copy.range.end = getDefaultEventEnd(eventDef.allDay, copy.range.start, context);
  }
  return copy;
}
var EventSourceImpl = class {
  constructor(context, internalEventSource) {
    this.context = context;
    this.internalEventSource = internalEventSource;
  }
  remove() {
    this.context.dispatch({
      type: "REMOVE_EVENT_SOURCE",
      sourceId: this.internalEventSource.sourceId
    });
  }
  refetch() {
    this.context.dispatch({
      type: "FETCH_EVENT_SOURCES",
      sourceIds: [this.internalEventSource.sourceId],
      isRefetch: true
    });
  }
  get id() {
    return this.internalEventSource.publicId;
  }
  get url() {
    return this.internalEventSource.meta.url;
  }
  get format() {
    return this.internalEventSource.meta.format;
  }
};
var EventImpl = class {
  // instance will be null if expressing a recurring event that has no current instances,
  // OR if trying to validate an incoming external event that has no dates assigned
  constructor(context, def, instance) {
    this._context = context;
    this._def = def;
    this._instance = instance || null;
  }
  /*
  TODO: make event struct more responsible for this
  */
  setProp(name, val) {
    if (name in EVENT_DATE_REFINERS) {
      console.warn("Could not set date-related prop 'name'. Use one of the date-related methods instead.");
    } else if (name === "id") {
      val = EVENT_NON_DATE_REFINERS[name](val);
      this.mutate({
        standardProps: { publicId: val }
        // hardcoded internal name
      });
    } else if (name in EVENT_NON_DATE_REFINERS) {
      val = EVENT_NON_DATE_REFINERS[name](val);
      this.mutate({
        standardProps: { [name]: val }
      });
    } else if (name in EVENT_UI_REFINERS) {
      let ui = EVENT_UI_REFINERS[name](val);
      if (name === "color") {
        ui = { backgroundColor: val, borderColor: val };
      } else if (name === "editable") {
        ui = { startEditable: val, durationEditable: val };
      } else {
        ui = { [name]: val };
      }
      this.mutate({
        standardProps: { ui }
      });
    } else {
      console.warn(`Could not set prop '${name}'. Use setExtendedProp instead.`);
    }
  }
  setExtendedProp(name, val) {
    this.mutate({
      extendedProps: { [name]: val }
    });
  }
  setStart(startInput, options = {}) {
    let { dateEnv } = this._context;
    let start = dateEnv.createMarker(startInput);
    if (start && this._instance) {
      let instanceRange = this._instance.range;
      let startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity);
      if (options.maintainDuration) {
        this.mutate({ datesDelta: startDelta });
      } else {
        this.mutate({ startDelta });
      }
    }
  }
  setEnd(endInput, options = {}) {
    let { dateEnv } = this._context;
    let end;
    if (endInput != null) {
      end = dateEnv.createMarker(endInput);
      if (!end) {
        return;
      }
    }
    if (this._instance) {
      if (end) {
        let endDelta = diffDates(this._instance.range.end, end, dateEnv, options.granularity);
        this.mutate({ endDelta });
      } else {
        this.mutate({ standardProps: { hasEnd: false } });
      }
    }
  }
  setDates(startInput, endInput, options = {}) {
    let { dateEnv } = this._context;
    let standardProps = { allDay: options.allDay };
    let start = dateEnv.createMarker(startInput);
    let end;
    if (!start) {
      return;
    }
    if (endInput != null) {
      end = dateEnv.createMarker(endInput);
      if (!end) {
        return;
      }
    }
    if (this._instance) {
      let instanceRange = this._instance.range;
      if (options.allDay === true) {
        instanceRange = computeAlignedDayRange(instanceRange);
      }
      let startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity);
      if (end) {
        let endDelta = diffDates(instanceRange.end, end, dateEnv, options.granularity);
        if (durationsEqual(startDelta, endDelta)) {
          this.mutate({ datesDelta: startDelta, standardProps });
        } else {
          this.mutate({ startDelta, endDelta, standardProps });
        }
      } else {
        standardProps.hasEnd = false;
        this.mutate({ datesDelta: startDelta, standardProps });
      }
    }
  }
  moveStart(deltaInput) {
    let delta = createDuration(deltaInput);
    if (delta) {
      this.mutate({ startDelta: delta });
    }
  }
  moveEnd(deltaInput) {
    let delta = createDuration(deltaInput);
    if (delta) {
      this.mutate({ endDelta: delta });
    }
  }
  moveDates(deltaInput) {
    let delta = createDuration(deltaInput);
    if (delta) {
      this.mutate({ datesDelta: delta });
    }
  }
  setAllDay(allDay, options = {}) {
    let standardProps = { allDay };
    let { maintainDuration } = options;
    if (maintainDuration == null) {
      maintainDuration = this._context.options.allDayMaintainDuration;
    }
    if (this._def.allDay !== allDay) {
      standardProps.hasEnd = maintainDuration;
    }
    this.mutate({ standardProps });
  }
  formatRange(formatInput) {
    let { dateEnv } = this._context;
    let instance = this._instance;
    let formatter = createFormatter(formatInput);
    if (this._def.hasEnd) {
      return dateEnv.formatRange(instance.range.start, instance.range.end, formatter, {
        forcedStartTzo: instance.forcedStartTzo,
        forcedEndTzo: instance.forcedEndTzo
      });
    }
    return dateEnv.format(instance.range.start, formatter, {
      forcedTzo: instance.forcedStartTzo
    });
  }
  mutate(mutation) {
    let instance = this._instance;
    if (instance) {
      let def = this._def;
      let context = this._context;
      let { eventStore } = context.getCurrentData();
      let relevantEvents = getRelevantEvents(eventStore, instance.instanceId);
      let eventConfigBase = {
        "": {
          display: "",
          startEditable: true,
          durationEditable: true,
          constraints: [],
          overlap: null,
          allows: [],
          backgroundColor: "",
          borderColor: "",
          textColor: "",
          classNames: []
        }
      };
      relevantEvents = applyMutationToEventStore(relevantEvents, eventConfigBase, mutation, context);
      let oldEvent = new EventImpl(context, def, instance);
      this._def = relevantEvents.defs[def.defId];
      this._instance = relevantEvents.instances[instance.instanceId];
      context.dispatch({
        type: "MERGE_EVENTS",
        eventStore: relevantEvents
      });
      context.emitter.trigger("eventChange", {
        oldEvent,
        event: this,
        relatedEvents: buildEventApis(relevantEvents, context, instance),
        revert() {
          context.dispatch({
            type: "RESET_EVENTS",
            eventStore
            // the ORIGINAL store
          });
        }
      });
    }
  }
  remove() {
    let context = this._context;
    let asStore = eventApiToStore(this);
    context.dispatch({
      type: "REMOVE_EVENTS",
      eventStore: asStore
    });
    context.emitter.trigger("eventRemove", {
      event: this,
      relatedEvents: [],
      revert() {
        context.dispatch({
          type: "MERGE_EVENTS",
          eventStore: asStore
        });
      }
    });
  }
  get source() {
    let { sourceId } = this._def;
    if (sourceId) {
      return new EventSourceImpl(this._context, this._context.getCurrentData().eventSources[sourceId]);
    }
    return null;
  }
  get start() {
    return this._instance ? this._context.dateEnv.toDate(this._instance.range.start) : null;
  }
  get end() {
    return this._instance && this._def.hasEnd ? this._context.dateEnv.toDate(this._instance.range.end) : null;
  }
  get startStr() {
    let instance = this._instance;
    if (instance) {
      return this._context.dateEnv.formatIso(instance.range.start, {
        omitTime: this._def.allDay,
        forcedTzo: instance.forcedStartTzo
      });
    }
    return "";
  }
  get endStr() {
    let instance = this._instance;
    if (instance && this._def.hasEnd) {
      return this._context.dateEnv.formatIso(instance.range.end, {
        omitTime: this._def.allDay,
        forcedTzo: instance.forcedEndTzo
      });
    }
    return "";
  }
  // computable props that all access the def
  // TODO: find a TypeScript-compatible way to do this at scale
  get id() {
    return this._def.publicId;
  }
  get groupId() {
    return this._def.groupId;
  }
  get allDay() {
    return this._def.allDay;
  }
  get title() {
    return this._def.title;
  }
  get url() {
    return this._def.url;
  }
  get display() {
    return this._def.ui.display || "auto";
  }
  // bad. just normalize the type earlier
  get startEditable() {
    return this._def.ui.startEditable;
  }
  get durationEditable() {
    return this._def.ui.durationEditable;
  }
  get constraint() {
    return this._def.ui.constraints[0] || null;
  }
  get overlap() {
    return this._def.ui.overlap;
  }
  get allow() {
    return this._def.ui.allows[0] || null;
  }
  get backgroundColor() {
    return this._def.ui.backgroundColor;
  }
  get borderColor() {
    return this._def.ui.borderColor;
  }
  get textColor() {
    return this._def.ui.textColor;
  }
  // NOTE: user can't modify these because Object.freeze was called in event-def parsing
  get classNames() {
    return this._def.ui.classNames;
  }
  get extendedProps() {
    return this._def.extendedProps;
  }
  toPlainObject(settings = {}) {
    let def = this._def;
    let { ui } = def;
    let { startStr, endStr } = this;
    let res = {
      allDay: def.allDay
    };
    if (def.title) {
      res.title = def.title;
    }
    if (startStr) {
      res.start = startStr;
    }
    if (endStr) {
      res.end = endStr;
    }
    if (def.publicId) {
      res.id = def.publicId;
    }
    if (def.groupId) {
      res.groupId = def.groupId;
    }
    if (def.url) {
      res.url = def.url;
    }
    if (ui.display && ui.display !== "auto") {
      res.display = ui.display;
    }
    if (settings.collapseColor && ui.backgroundColor && ui.backgroundColor === ui.borderColor) {
      res.color = ui.backgroundColor;
    } else {
      if (ui.backgroundColor) {
        res.backgroundColor = ui.backgroundColor;
      }
      if (ui.borderColor) {
        res.borderColor = ui.borderColor;
      }
    }
    if (ui.textColor) {
      res.textColor = ui.textColor;
    }
    if (ui.classNames.length) {
      res.classNames = ui.classNames;
    }
    if (Object.keys(def.extendedProps).length) {
      if (settings.collapseExtendedProps) {
        Object.assign(res, def.extendedProps);
      } else {
        res.extendedProps = def.extendedProps;
      }
    }
    return res;
  }
  toJSON() {
    return this.toPlainObject();
  }
};
function eventApiToStore(eventApi) {
  let def = eventApi._def;
  let instance = eventApi._instance;
  return {
    defs: { [def.defId]: def },
    instances: instance ? { [instance.instanceId]: instance } : {}
  };
}
function buildEventApis(eventStore, context, excludeInstance) {
  let { defs, instances } = eventStore;
  let eventApis = [];
  let excludeInstanceId = excludeInstance ? excludeInstance.instanceId : "";
  for (let id in instances) {
    let instance = instances[id];
    let def = defs[instance.defId];
    if (instance.instanceId !== excludeInstanceId) {
      eventApis.push(new EventImpl(context, def, instance));
    }
  }
  return eventApis;
}
function sliceEventStore(eventStore, eventUiBases, framingRange, nextDayThreshold) {
  let inverseBgByGroupId = {};
  let inverseBgByDefId = {};
  let defByGroupId = {};
  let bgRanges = [];
  let fgRanges = [];
  let eventUis = compileEventUis(eventStore.defs, eventUiBases);
  for (let defId in eventStore.defs) {
    let def = eventStore.defs[defId];
    let ui = eventUis[def.defId];
    if (ui.display === "inverse-background") {
      if (def.groupId) {
        inverseBgByGroupId[def.groupId] = [];
        if (!defByGroupId[def.groupId]) {
          defByGroupId[def.groupId] = def;
        }
      } else {
        inverseBgByDefId[defId] = [];
      }
    }
  }
  for (let instanceId in eventStore.instances) {
    let instance = eventStore.instances[instanceId];
    let def = eventStore.defs[instance.defId];
    let ui = eventUis[def.defId];
    let origRange = instance.range;
    let normalRange = !def.allDay && nextDayThreshold ? computeVisibleDayRange(origRange, nextDayThreshold) : origRange;
    let slicedRange = intersectRanges(normalRange, framingRange);
    if (slicedRange) {
      if (ui.display === "inverse-background") {
        if (def.groupId) {
          inverseBgByGroupId[def.groupId].push(slicedRange);
        } else {
          inverseBgByDefId[instance.defId].push(slicedRange);
        }
      } else if (ui.display !== "none") {
        (ui.display === "background" ? bgRanges : fgRanges).push({
          def,
          ui,
          instance,
          range: slicedRange,
          isStart: normalRange.start && normalRange.start.valueOf() === slicedRange.start.valueOf(),
          isEnd: normalRange.end && normalRange.end.valueOf() === slicedRange.end.valueOf()
        });
      }
    }
  }
  for (let groupId in inverseBgByGroupId) {
    let ranges = inverseBgByGroupId[groupId];
    let invertedRanges = invertRanges(ranges, framingRange);
    for (let invertedRange of invertedRanges) {
      let def = defByGroupId[groupId];
      let ui = eventUis[def.defId];
      bgRanges.push({
        def,
        ui,
        instance: null,
        range: invertedRange,
        isStart: false,
        isEnd: false
      });
    }
  }
  for (let defId in inverseBgByDefId) {
    let ranges = inverseBgByDefId[defId];
    let invertedRanges = invertRanges(ranges, framingRange);
    for (let invertedRange of invertedRanges) {
      bgRanges.push({
        def: eventStore.defs[defId],
        ui: eventUis[defId],
        instance: null,
        range: invertedRange,
        isStart: false,
        isEnd: false
      });
    }
  }
  return { bg: bgRanges, fg: fgRanges };
}
function hasBgRendering(def) {
  return def.ui.display === "background" || def.ui.display === "inverse-background";
}
function setElSeg(el, seg) {
  el.fcSeg = seg;
}
function getElSeg(el) {
  return el.fcSeg || el.parentNode.fcSeg || // for the harness
  null;
}
function compileEventUis(eventDefs, eventUiBases) {
  return mapHash(eventDefs, (eventDef) => compileEventUi(eventDef, eventUiBases));
}
function compileEventUi(eventDef, eventUiBases) {
  let uis = [];
  if (eventUiBases[""]) {
    uis.push(eventUiBases[""]);
  }
  if (eventUiBases[eventDef.defId]) {
    uis.push(eventUiBases[eventDef.defId]);
  }
  uis.push(eventDef.ui);
  return combineEventUis(uis);
}
function sortEventSegs(segs, eventOrderSpecs) {
  let objs = segs.map(buildSegCompareObj);
  objs.sort((obj0, obj1) => compareByFieldSpecs(obj0, obj1, eventOrderSpecs));
  return objs.map((c3) => c3._seg);
}
function buildSegCompareObj(seg) {
  let { eventRange } = seg;
  let eventDef = eventRange.def;
  let range2 = eventRange.instance ? eventRange.instance.range : eventRange.range;
  let start = range2.start ? range2.start.valueOf() : 0;
  let end = range2.end ? range2.end.valueOf() : 0;
  return Object.assign(Object.assign(Object.assign({}, eventDef.extendedProps), eventDef), {
    id: eventDef.publicId,
    start,
    end,
    duration: end - start,
    allDay: Number(eventDef.allDay),
    _seg: seg
  });
}
function computeSegDraggable(seg, context) {
  let { pluginHooks } = context;
  let transformers = pluginHooks.isDraggableTransformers;
  let { def, ui } = seg.eventRange;
  let val = ui.startEditable;
  for (let transformer of transformers) {
    val = transformer(val, def, ui, context);
  }
  return val;
}
function computeSegStartResizable(seg, context) {
  return seg.isStart && seg.eventRange.ui.durationEditable && context.options.eventResizableFromStart;
}
function computeSegEndResizable(seg, context) {
  return seg.isEnd && seg.eventRange.ui.durationEditable;
}
function buildSegTimeText(seg, timeFormat, context, defaultDisplayEventTime, defaultDisplayEventEnd, startOverride, endOverride) {
  let { dateEnv, options } = context;
  let { displayEventTime, displayEventEnd } = options;
  let eventDef = seg.eventRange.def;
  let eventInstance = seg.eventRange.instance;
  if (displayEventTime == null) {
    displayEventTime = defaultDisplayEventTime !== false;
  }
  if (displayEventEnd == null) {
    displayEventEnd = defaultDisplayEventEnd !== false;
  }
  let wholeEventStart = eventInstance.range.start;
  let wholeEventEnd = eventInstance.range.end;
  let segStart = startOverride || seg.start || seg.eventRange.range.start;
  let segEnd = endOverride || seg.end || seg.eventRange.range.end;
  let isStartDay = startOfDay(wholeEventStart).valueOf() === startOfDay(segStart).valueOf();
  let isEndDay = startOfDay(addMs(wholeEventEnd, -1)).valueOf() === startOfDay(addMs(segEnd, -1)).valueOf();
  if (displayEventTime && !eventDef.allDay && (isStartDay || isEndDay)) {
    segStart = isStartDay ? wholeEventStart : segStart;
    segEnd = isEndDay ? wholeEventEnd : segEnd;
    if (displayEventEnd && eventDef.hasEnd) {
      return dateEnv.formatRange(segStart, segEnd, timeFormat, {
        forcedStartTzo: startOverride ? null : eventInstance.forcedStartTzo,
        forcedEndTzo: endOverride ? null : eventInstance.forcedEndTzo
      });
    }
    return dateEnv.format(segStart, timeFormat, {
      forcedTzo: startOverride ? null : eventInstance.forcedStartTzo
      // nooooo, same
    });
  }
  return "";
}
function getSegMeta(seg, todayRange, nowDate) {
  let segRange = seg.eventRange.range;
  return {
    isPast: segRange.end <= (nowDate || todayRange.start),
    isFuture: segRange.start >= (nowDate || todayRange.end),
    isToday: todayRange && rangeContainsMarker(todayRange, segRange.start)
  };
}
function getEventClassNames(props) {
  let classNames = ["fc-event"];
  if (props.isMirror) {
    classNames.push("fc-event-mirror");
  }
  if (props.isDraggable) {
    classNames.push("fc-event-draggable");
  }
  if (props.isStartResizable || props.isEndResizable) {
    classNames.push("fc-event-resizable");
  }
  if (props.isDragging) {
    classNames.push("fc-event-dragging");
  }
  if (props.isResizing) {
    classNames.push("fc-event-resizing");
  }
  if (props.isSelected) {
    classNames.push("fc-event-selected");
  }
  if (props.isStart) {
    classNames.push("fc-event-start");
  }
  if (props.isEnd) {
    classNames.push("fc-event-end");
  }
  if (props.isPast) {
    classNames.push("fc-event-past");
  }
  if (props.isToday) {
    classNames.push("fc-event-today");
  }
  if (props.isFuture) {
    classNames.push("fc-event-future");
  }
  return classNames;
}
function buildEventRangeKey(eventRange) {
  return eventRange.instance ? eventRange.instance.instanceId : `${eventRange.def.defId}:${eventRange.range.start.toISOString()}`;
}
function getSegAnchorAttrs(seg, context) {
  let { def, instance } = seg.eventRange;
  let { url } = def;
  if (url) {
    return { href: url };
  }
  let { emitter, options } = context;
  let { eventInteractive } = options;
  if (eventInteractive == null) {
    eventInteractive = def.interactive;
    if (eventInteractive == null) {
      eventInteractive = Boolean(emitter.hasHandlers("eventClick"));
    }
  }
  if (eventInteractive) {
    return createAriaKeyboardAttrs((ev) => {
      emitter.trigger("eventClick", {
        el: ev.target,
        event: new EventImpl(context, def, instance),
        jsEvent: ev,
        view: context.viewApi
      });
    });
  }
  return {};
}
var STANDARD_PROPS = {
  start: identity,
  end: identity,
  allDay: Boolean
};
function parseDateSpan(raw, dateEnv, defaultDuration) {
  let span = parseOpenDateSpan(raw, dateEnv);
  let { range: range2 } = span;
  if (!range2.start) {
    return null;
  }
  if (!range2.end) {
    if (defaultDuration == null) {
      return null;
    }
    range2.end = dateEnv.add(range2.start, defaultDuration);
  }
  return span;
}
function parseOpenDateSpan(raw, dateEnv) {
  let { refined: standardProps, extra } = refineProps(raw, STANDARD_PROPS);
  let startMeta = standardProps.start ? dateEnv.createMarkerMeta(standardProps.start) : null;
  let endMeta = standardProps.end ? dateEnv.createMarkerMeta(standardProps.end) : null;
  let { allDay } = standardProps;
  if (allDay == null) {
    allDay = startMeta && startMeta.isTimeUnspecified && (!endMeta || endMeta.isTimeUnspecified);
  }
  return Object.assign({ range: {
    start: startMeta ? startMeta.marker : null,
    end: endMeta ? endMeta.marker : null
  }, allDay }, extra);
}
function isDateSpansEqual(span0, span1) {
  return rangesEqual(span0.range, span1.range) && span0.allDay === span1.allDay && isSpanPropsEqual(span0, span1);
}
function isSpanPropsEqual(span0, span1) {
  for (let propName in span1) {
    if (propName !== "range" && propName !== "allDay") {
      if (span0[propName] !== span1[propName]) {
        return false;
      }
    }
  }
  for (let propName in span0) {
    if (!(propName in span1)) {
      return false;
    }
  }
  return true;
}
function buildDateSpanApi(span, dateEnv) {
  return Object.assign(Object.assign({}, buildRangeApi(span.range, dateEnv, span.allDay)), { allDay: span.allDay });
}
function buildRangeApiWithTimeZone(range2, dateEnv, omitTime) {
  return Object.assign(Object.assign({}, buildRangeApi(range2, dateEnv, omitTime)), { timeZone: dateEnv.timeZone });
}
function buildRangeApi(range2, dateEnv, omitTime) {
  return {
    start: dateEnv.toDate(range2.start),
    end: dateEnv.toDate(range2.end),
    startStr: dateEnv.formatIso(range2.start, { omitTime }),
    endStr: dateEnv.formatIso(range2.end, { omitTime })
  };
}
function fabricateEventRange(dateSpan, eventUiBases, context) {
  let res = refineEventDef({ editable: false }, context);
  let def = parseEventDef(
    res.refined,
    res.extra,
    "",
    // sourceId
    dateSpan.allDay,
    true,
    // hasEnd
    context
  );
  return {
    def,
    ui: compileEventUi(def, eventUiBases),
    instance: createEventInstance(def.defId, dateSpan.range),
    range: dateSpan.range,
    isStart: true,
    isEnd: true
  };
}
function unpromisify(func, normalizedSuccessCallback, normalizedFailureCallback) {
  let isResolved = false;
  let wrappedSuccess = function(res2) {
    if (!isResolved) {
      isResolved = true;
      normalizedSuccessCallback(res2);
    }
  };
  let wrappedFailure = function(error) {
    if (!isResolved) {
      isResolved = true;
      normalizedFailureCallback(error);
    }
  };
  let res = func(wrappedSuccess, wrappedFailure);
  if (res && typeof res.then === "function") {
    res.then(wrappedSuccess, wrappedFailure);
  }
}
var JsonRequestError = class extends Error {
  constructor(message, response) {
    super(message);
    this.response = response;
  }
};
function requestJson(method, url, params) {
  method = method.toUpperCase();
  const fetchOptions = {
    method
  };
  if (method === "GET") {
    url += (url.indexOf("?") === -1 ? "?" : "&") + new URLSearchParams(params);
  } else {
    fetchOptions.body = new URLSearchParams(params);
    fetchOptions.headers = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
  }
  return fetch(url, fetchOptions).then((fetchRes) => {
    if (fetchRes.ok) {
      return fetchRes.json().then((parsedResponse) => {
        return [parsedResponse, fetchRes];
      }, () => {
        throw new JsonRequestError("Failure parsing JSON", fetchRes);
      });
    } else {
      throw new JsonRequestError("Request failed", fetchRes);
    }
  });
}
var canVGrowWithinCell;
function getCanVGrowWithinCell() {
  if (canVGrowWithinCell == null) {
    canVGrowWithinCell = computeCanVGrowWithinCell();
  }
  return canVGrowWithinCell;
}
function computeCanVGrowWithinCell() {
  if (typeof document === "undefined") {
    return true;
  }
  let el = document.createElement("div");
  el.style.position = "absolute";
  el.style.top = "0px";
  el.style.left = "0px";
  el.innerHTML = "<table><tr><td><div></div></td></tr></table>";
  el.querySelector("table").style.height = "100px";
  el.querySelector("div").style.height = "100%";
  document.body.appendChild(el);
  let div = el.querySelector("div");
  let possible = div.offsetHeight > 0;
  document.body.removeChild(el);
  return possible;
}
var CalendarRoot = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.state = {
      forPrint: false
    };
    this.handleBeforePrint = () => {
      flushSync(() => {
        this.setState({ forPrint: true });
      });
    };
    this.handleAfterPrint = () => {
      flushSync(() => {
        this.setState({ forPrint: false });
      });
    };
  }
  render() {
    let { props } = this;
    let { options } = props;
    let { forPrint } = this.state;
    let isHeightAuto = forPrint || options.height === "auto" || options.contentHeight === "auto";
    let height = !isHeightAuto && options.height != null ? options.height : "";
    let classNames = [
      "fc",
      forPrint ? "fc-media-print" : "fc-media-screen",
      `fc-direction-${options.direction}`,
      props.theme.getClass("root")
    ];
    if (!getCanVGrowWithinCell()) {
      classNames.push("fc-liquid-hack");
    }
    return props.children(classNames, height, isHeightAuto, forPrint);
  }
  componentDidMount() {
    let { emitter } = this.props;
    emitter.on("_beforeprint", this.handleBeforePrint);
    emitter.on("_afterprint", this.handleAfterPrint);
  }
  componentWillUnmount() {
    let { emitter } = this.props;
    emitter.off("_beforeprint", this.handleBeforePrint);
    emitter.off("_afterprint", this.handleAfterPrint);
  }
};
var Interaction = class {
  constructor(settings) {
    this.component = settings.component;
    this.isHitComboAllowed = settings.isHitComboAllowed || null;
  }
  destroy() {
  }
};
function parseInteractionSettings(component, input) {
  return {
    component,
    el: input.el,
    useEventCenter: input.useEventCenter != null ? input.useEventCenter : true,
    isHitComboAllowed: input.isHitComboAllowed || null
  };
}
function interactionSettingsToStore(settings) {
  return {
    [settings.component.uid]: settings
  };
}
var interactionSettingsStore = {};
var CalendarImpl = class {
  getCurrentData() {
    return this.currentDataManager.getCurrentData();
  }
  dispatch(action) {
    this.currentDataManager.dispatch(action);
  }
  get view() {
    return this.getCurrentData().viewApi;
  }
  batchRendering(callback) {
    callback();
  }
  updateSize() {
    this.trigger("_resize", true);
  }
  // Options
  // -----------------------------------------------------------------------------------------------------------------
  setOption(name, val) {
    this.dispatch({
      type: "SET_OPTION",
      optionName: name,
      rawOptionValue: val
    });
  }
  getOption(name) {
    return this.currentDataManager.currentCalendarOptionsInput[name];
  }
  getAvailableLocaleCodes() {
    return Object.keys(this.getCurrentData().availableRawLocales);
  }
  // Trigger
  // -----------------------------------------------------------------------------------------------------------------
  on(handlerName, handler) {
    let { currentDataManager } = this;
    if (currentDataManager.currentCalendarOptionsRefiners[handlerName]) {
      currentDataManager.emitter.on(handlerName, handler);
    } else {
      console.warn(`Unknown listener name '${handlerName}'`);
    }
  }
  off(handlerName, handler) {
    this.currentDataManager.emitter.off(handlerName, handler);
  }
  // not meant for public use
  trigger(handlerName, ...args) {
    this.currentDataManager.emitter.trigger(handlerName, ...args);
  }
  // View
  // -----------------------------------------------------------------------------------------------------------------
  changeView(viewType, dateOrRange) {
    this.batchRendering(() => {
      this.unselect();
      if (dateOrRange) {
        if (dateOrRange.start && dateOrRange.end) {
          this.dispatch({
            type: "CHANGE_VIEW_TYPE",
            viewType
          });
          this.dispatch({
            type: "SET_OPTION",
            optionName: "visibleRange",
            rawOptionValue: dateOrRange
          });
        } else {
          let { dateEnv } = this.getCurrentData();
          this.dispatch({
            type: "CHANGE_VIEW_TYPE",
            viewType,
            dateMarker: dateEnv.createMarker(dateOrRange)
          });
        }
      } else {
        this.dispatch({
          type: "CHANGE_VIEW_TYPE",
          viewType
        });
      }
    });
  }
  // Forces navigation to a view for the given date.
  // `viewType` can be a specific view name or a generic one like "week" or "day".
  // needs to change
  zoomTo(dateMarker, viewType) {
    let state = this.getCurrentData();
    let spec;
    viewType = viewType || "day";
    spec = state.viewSpecs[viewType] || this.getUnitViewSpec(viewType);
    this.unselect();
    if (spec) {
      this.dispatch({
        type: "CHANGE_VIEW_TYPE",
        viewType: spec.type,
        dateMarker
      });
    } else {
      this.dispatch({
        type: "CHANGE_DATE",
        dateMarker
      });
    }
  }
  // Given a duration singular unit, like "week" or "day", finds a matching view spec.
  // Preference is given to views that have corresponding buttons.
  getUnitViewSpec(unit) {
    let { viewSpecs, toolbarConfig } = this.getCurrentData();
    let viewTypes = [].concat(toolbarConfig.header ? toolbarConfig.header.viewsWithButtons : [], toolbarConfig.footer ? toolbarConfig.footer.viewsWithButtons : []);
    let i3;
    let spec;
    for (let viewType in viewSpecs) {
      viewTypes.push(viewType);
    }
    for (i3 = 0; i3 < viewTypes.length; i3 += 1) {
      spec = viewSpecs[viewTypes[i3]];
      if (spec) {
        if (spec.singleUnit === unit) {
          return spec;
        }
      }
    }
    return null;
  }
  // Current Date
  // -----------------------------------------------------------------------------------------------------------------
  prev() {
    this.unselect();
    this.dispatch({ type: "PREV" });
  }
  next() {
    this.unselect();
    this.dispatch({ type: "NEXT" });
  }
  prevYear() {
    let state = this.getCurrentData();
    this.unselect();
    this.dispatch({
      type: "CHANGE_DATE",
      dateMarker: state.dateEnv.addYears(state.currentDate, -1)
    });
  }
  nextYear() {
    let state = this.getCurrentData();
    this.unselect();
    this.dispatch({
      type: "CHANGE_DATE",
      dateMarker: state.dateEnv.addYears(state.currentDate, 1)
    });
  }
  today() {
    let state = this.getCurrentData();
    this.unselect();
    this.dispatch({
      type: "CHANGE_DATE",
      dateMarker: getNow(state.calendarOptions.now, state.dateEnv)
    });
  }
  gotoDate(zonedDateInput) {
    let state = this.getCurrentData();
    this.unselect();
    this.dispatch({
      type: "CHANGE_DATE",
      dateMarker: state.dateEnv.createMarker(zonedDateInput)
    });
  }
  incrementDate(deltaInput) {
    let state = this.getCurrentData();
    let delta = createDuration(deltaInput);
    if (delta) {
      this.unselect();
      this.dispatch({
        type: "CHANGE_DATE",
        dateMarker: state.dateEnv.add(state.currentDate, delta)
      });
    }
  }
  getDate() {
    let state = this.getCurrentData();
    return state.dateEnv.toDate(state.currentDate);
  }
  // Date Formatting Utils
  // -----------------------------------------------------------------------------------------------------------------
  formatDate(d2, formatter) {
    let { dateEnv } = this.getCurrentData();
    return dateEnv.format(dateEnv.createMarker(d2), createFormatter(formatter));
  }
  // `settings` is for formatter AND isEndExclusive
  formatRange(d0, d1, settings) {
    let { dateEnv } = this.getCurrentData();
    return dateEnv.formatRange(dateEnv.createMarker(d0), dateEnv.createMarker(d1), createFormatter(settings), settings);
  }
  formatIso(d2, omitTime) {
    let { dateEnv } = this.getCurrentData();
    return dateEnv.formatIso(dateEnv.createMarker(d2), { omitTime });
  }
  // Date Selection / Event Selection / DayClick
  // -----------------------------------------------------------------------------------------------------------------
  select(dateOrObj, endDate) {
    let selectionInput;
    if (endDate == null) {
      if (dateOrObj.start != null) {
        selectionInput = dateOrObj;
      } else {
        selectionInput = {
          start: dateOrObj,
          end: null
        };
      }
    } else {
      selectionInput = {
        start: dateOrObj,
        end: endDate
      };
    }
    let state = this.getCurrentData();
    let selection = parseDateSpan(selectionInput, state.dateEnv, createDuration({ days: 1 }));
    if (selection) {
      this.dispatch({ type: "SELECT_DATES", selection });
      triggerDateSelect(selection, null, state);
    }
  }
  unselect(pev) {
    let state = this.getCurrentData();
    if (state.dateSelection) {
      this.dispatch({ type: "UNSELECT_DATES" });
      triggerDateUnselect(pev, state);
    }
  }
  // Public Events API
  // -----------------------------------------------------------------------------------------------------------------
  addEvent(eventInput, sourceInput) {
    if (eventInput instanceof EventImpl) {
      let def = eventInput._def;
      let instance = eventInput._instance;
      let currentData = this.getCurrentData();
      if (!currentData.eventStore.defs[def.defId]) {
        this.dispatch({
          type: "ADD_EVENTS",
          eventStore: eventTupleToStore({ def, instance })
          // TODO: better util for two args?
        });
        this.triggerEventAdd(eventInput);
      }
      return eventInput;
    }
    let state = this.getCurrentData();
    let eventSource;
    if (sourceInput instanceof EventSourceImpl) {
      eventSource = sourceInput.internalEventSource;
    } else if (typeof sourceInput === "boolean") {
      if (sourceInput) {
        [eventSource] = hashValuesToArray(state.eventSources);
      }
    } else if (sourceInput != null) {
      let sourceApi = this.getEventSourceById(sourceInput);
      if (!sourceApi) {
        console.warn(`Could not find an event source with ID "${sourceInput}"`);
        return null;
      }
      eventSource = sourceApi.internalEventSource;
    }
    let tuple = parseEvent(eventInput, eventSource, state, false);
    if (tuple) {
      let newEventApi = new EventImpl(state, tuple.def, tuple.def.recurringDef ? null : tuple.instance);
      this.dispatch({
        type: "ADD_EVENTS",
        eventStore: eventTupleToStore(tuple)
      });
      this.triggerEventAdd(newEventApi);
      return newEventApi;
    }
    return null;
  }
  triggerEventAdd(eventApi) {
    let { emitter } = this.getCurrentData();
    emitter.trigger("eventAdd", {
      event: eventApi,
      relatedEvents: [],
      revert: () => {
        this.dispatch({
          type: "REMOVE_EVENTS",
          eventStore: eventApiToStore(eventApi)
        });
      }
    });
  }
  // TODO: optimize
  getEventById(id) {
    let state = this.getCurrentData();
    let { defs, instances } = state.eventStore;
    id = String(id);
    for (let defId in defs) {
      let def = defs[defId];
      if (def.publicId === id) {
        if (def.recurringDef) {
          return new EventImpl(state, def, null);
        }
        for (let instanceId in instances) {
          let instance = instances[instanceId];
          if (instance.defId === def.defId) {
            return new EventImpl(state, def, instance);
          }
        }
      }
    }
    return null;
  }
  getEvents() {
    let currentData = this.getCurrentData();
    return buildEventApis(currentData.eventStore, currentData);
  }
  removeAllEvents() {
    this.dispatch({ type: "REMOVE_ALL_EVENTS" });
  }
  // Public Event Sources API
  // -----------------------------------------------------------------------------------------------------------------
  getEventSources() {
    let state = this.getCurrentData();
    let sourceHash = state.eventSources;
    let sourceApis = [];
    for (let internalId in sourceHash) {
      sourceApis.push(new EventSourceImpl(state, sourceHash[internalId]));
    }
    return sourceApis;
  }
  getEventSourceById(id) {
    let state = this.getCurrentData();
    let sourceHash = state.eventSources;
    id = String(id);
    for (let sourceId in sourceHash) {
      if (sourceHash[sourceId].publicId === id) {
        return new EventSourceImpl(state, sourceHash[sourceId]);
      }
    }
    return null;
  }
  addEventSource(sourceInput) {
    let state = this.getCurrentData();
    if (sourceInput instanceof EventSourceImpl) {
      if (!state.eventSources[sourceInput.internalEventSource.sourceId]) {
        this.dispatch({
          type: "ADD_EVENT_SOURCES",
          sources: [sourceInput.internalEventSource]
        });
      }
      return sourceInput;
    }
    let eventSource = parseEventSource(sourceInput, state);
    if (eventSource) {
      this.dispatch({ type: "ADD_EVENT_SOURCES", sources: [eventSource] });
      return new EventSourceImpl(state, eventSource);
    }
    return null;
  }
  removeAllEventSources() {
    this.dispatch({ type: "REMOVE_ALL_EVENT_SOURCES" });
  }
  refetchEvents() {
    this.dispatch({ type: "FETCH_EVENT_SOURCES", isRefetch: true });
  }
  // Scroll
  // -----------------------------------------------------------------------------------------------------------------
  scrollToTime(timeInput) {
    let time = createDuration(timeInput);
    if (time) {
      this.trigger("_scrollRequest", { time });
    }
  }
};
function pointInsideRect(point, rect) {
  return point.left >= rect.left && point.left < rect.right && point.top >= rect.top && point.top < rect.bottom;
}
function intersectRects(rect1, rect2) {
  let res = {
    left: Math.max(rect1.left, rect2.left),
    right: Math.min(rect1.right, rect2.right),
    top: Math.max(rect1.top, rect2.top),
    bottom: Math.min(rect1.bottom, rect2.bottom)
  };
  if (res.left < res.right && res.top < res.bottom) {
    return res;
  }
  return false;
}
function constrainPoint(point, rect) {
  return {
    left: Math.min(Math.max(point.left, rect.left), rect.right),
    top: Math.min(Math.max(point.top, rect.top), rect.bottom)
  };
}
function getRectCenter(rect) {
  return {
    left: (rect.left + rect.right) / 2,
    top: (rect.top + rect.bottom) / 2
  };
}
function diffPoints(point1, point2) {
  return {
    left: point1.left - point2.left,
    top: point1.top - point2.top
  };
}
var EMPTY_EVENT_STORE = createEmptyEventStore();
var Splitter = class {
  constructor() {
    this.getKeysForEventDefs = memoize(this._getKeysForEventDefs);
    this.splitDateSelection = memoize(this._splitDateSpan);
    this.splitEventStore = memoize(this._splitEventStore);
    this.splitIndividualUi = memoize(this._splitIndividualUi);
    this.splitEventDrag = memoize(this._splitInteraction);
    this.splitEventResize = memoize(this._splitInteraction);
    this.eventUiBuilders = {};
  }
  splitProps(props) {
    let keyInfos = this.getKeyInfo(props);
    let defKeys = this.getKeysForEventDefs(props.eventStore);
    let dateSelections = this.splitDateSelection(props.dateSelection);
    let individualUi = this.splitIndividualUi(props.eventUiBases, defKeys);
    let eventStores = this.splitEventStore(props.eventStore, defKeys);
    let eventDrags = this.splitEventDrag(props.eventDrag);
    let eventResizes = this.splitEventResize(props.eventResize);
    let splitProps = {};
    this.eventUiBuilders = mapHash(keyInfos, (info, key) => this.eventUiBuilders[key] || memoize(buildEventUiForKey));
    for (let key in keyInfos) {
      let keyInfo = keyInfos[key];
      let eventStore = eventStores[key] || EMPTY_EVENT_STORE;
      let buildEventUi = this.eventUiBuilders[key];
      splitProps[key] = {
        businessHours: keyInfo.businessHours || props.businessHours,
        dateSelection: dateSelections[key] || null,
        eventStore,
        eventUiBases: buildEventUi(props.eventUiBases[""], keyInfo.ui, individualUi[key]),
        eventSelection: eventStore.instances[props.eventSelection] ? props.eventSelection : "",
        eventDrag: eventDrags[key] || null,
        eventResize: eventResizes[key] || null
      };
    }
    return splitProps;
  }
  _splitDateSpan(dateSpan) {
    let dateSpans = {};
    if (dateSpan) {
      let keys = this.getKeysForDateSpan(dateSpan);
      for (let key of keys) {
        dateSpans[key] = dateSpan;
      }
    }
    return dateSpans;
  }
  _getKeysForEventDefs(eventStore) {
    return mapHash(eventStore.defs, (eventDef) => this.getKeysForEventDef(eventDef));
  }
  _splitEventStore(eventStore, defKeys) {
    let { defs, instances } = eventStore;
    let splitStores = {};
    for (let defId in defs) {
      for (let key of defKeys[defId]) {
        if (!splitStores[key]) {
          splitStores[key] = createEmptyEventStore();
        }
        splitStores[key].defs[defId] = defs[defId];
      }
    }
    for (let instanceId in instances) {
      let instance = instances[instanceId];
      for (let key of defKeys[instance.defId]) {
        if (splitStores[key]) {
          splitStores[key].instances[instanceId] = instance;
        }
      }
    }
    return splitStores;
  }
  _splitIndividualUi(eventUiBases, defKeys) {
    let splitHashes = {};
    for (let defId in eventUiBases) {
      if (defId) {
        for (let key of defKeys[defId]) {
          if (!splitHashes[key]) {
            splitHashes[key] = {};
          }
          splitHashes[key][defId] = eventUiBases[defId];
        }
      }
    }
    return splitHashes;
  }
  _splitInteraction(interaction) {
    let splitStates = {};
    if (interaction) {
      let affectedStores = this._splitEventStore(interaction.affectedEvents, this._getKeysForEventDefs(interaction.affectedEvents));
      let mutatedKeysByDefId = this._getKeysForEventDefs(interaction.mutatedEvents);
      let mutatedStores = this._splitEventStore(interaction.mutatedEvents, mutatedKeysByDefId);
      let populate = (key) => {
        if (!splitStates[key]) {
          splitStates[key] = {
            affectedEvents: affectedStores[key] || EMPTY_EVENT_STORE,
            mutatedEvents: mutatedStores[key] || EMPTY_EVENT_STORE,
            isEvent: interaction.isEvent
          };
        }
      };
      for (let key in affectedStores) {
        populate(key);
      }
      for (let key in mutatedStores) {
        populate(key);
      }
    }
    return splitStates;
  }
};
function buildEventUiForKey(allUi, eventUiForKey, individualUi) {
  let baseParts = [];
  if (allUi) {
    baseParts.push(allUi);
  }
  if (eventUiForKey) {
    baseParts.push(eventUiForKey);
  }
  let stuff = {
    "": combineEventUis(baseParts)
  };
  if (individualUi) {
    Object.assign(stuff, individualUi);
  }
  return stuff;
}
function getDateMeta(date, todayRange, nowDate, dateProfile) {
  return {
    dow: date.getUTCDay(),
    isDisabled: Boolean(dateProfile && !rangeContainsMarker(dateProfile.activeRange, date)),
    isOther: Boolean(dateProfile && !rangeContainsMarker(dateProfile.currentRange, date)),
    isToday: Boolean(todayRange && rangeContainsMarker(todayRange, date)),
    isPast: Boolean(nowDate ? date < nowDate : todayRange ? date < todayRange.start : false),
    isFuture: Boolean(nowDate ? date > nowDate : todayRange ? date >= todayRange.end : false)
  };
}
function getDayClassNames(meta, theme) {
  let classNames = [
    "fc-day",
    `fc-day-${DAY_IDS[meta.dow]}`
  ];
  if (meta.isDisabled) {
    classNames.push("fc-day-disabled");
  } else {
    if (meta.isToday) {
      classNames.push("fc-day-today");
      classNames.push(theme.getClass("today"));
    }
    if (meta.isPast) {
      classNames.push("fc-day-past");
    }
    if (meta.isFuture) {
      classNames.push("fc-day-future");
    }
    if (meta.isOther) {
      classNames.push("fc-day-other");
    }
  }
  return classNames;
}
var DAY_FORMAT = createFormatter({ year: "numeric", month: "long", day: "numeric" });
var WEEK_FORMAT = createFormatter({ week: "long" });
function buildNavLinkAttrs(context, dateMarker, viewType = "day", isTabbable = true) {
  const { dateEnv, options, calendarApi } = context;
  let dateStr = dateEnv.format(dateMarker, viewType === "week" ? WEEK_FORMAT : DAY_FORMAT);
  if (options.navLinks) {
    let zonedDate = dateEnv.toDate(dateMarker);
    const handleInteraction = (ev) => {
      let customAction = viewType === "day" ? options.navLinkDayClick : viewType === "week" ? options.navLinkWeekClick : null;
      if (typeof customAction === "function") {
        customAction.call(calendarApi, dateEnv.toDate(dateMarker), ev);
      } else {
        if (typeof customAction === "string") {
          viewType = customAction;
        }
        calendarApi.zoomTo(dateMarker, viewType);
      }
    };
    return Object.assign({ title: formatWithOrdinals(options.navLinkHint, [dateStr, zonedDate], dateStr), "data-navlink": "" }, isTabbable ? createAriaClickAttrs(handleInteraction) : { onClick: handleInteraction });
  }
  return { "aria-label": dateStr };
}
var _isRtlScrollbarOnLeft = null;
function getIsRtlScrollbarOnLeft() {
  if (_isRtlScrollbarOnLeft === null) {
    _isRtlScrollbarOnLeft = computeIsRtlScrollbarOnLeft();
  }
  return _isRtlScrollbarOnLeft;
}
function computeIsRtlScrollbarOnLeft() {
  let outerEl = document.createElement("div");
  applyStyle(outerEl, {
    position: "absolute",
    top: -1e3,
    left: 0,
    border: 0,
    padding: 0,
    overflow: "scroll",
    direction: "rtl"
  });
  outerEl.innerHTML = "<div></div>";
  document.body.appendChild(outerEl);
  let innerEl = outerEl.firstChild;
  let res = innerEl.getBoundingClientRect().left > outerEl.getBoundingClientRect().left;
  removeElement(outerEl);
  return res;
}
var _scrollbarWidths;
function getScrollbarWidths() {
  if (!_scrollbarWidths) {
    _scrollbarWidths = computeScrollbarWidths();
  }
  return _scrollbarWidths;
}
function computeScrollbarWidths() {
  let el = document.createElement("div");
  el.style.overflow = "scroll";
  el.style.position = "absolute";
  el.style.top = "-9999px";
  el.style.left = "-9999px";
  document.body.appendChild(el);
  let res = computeScrollbarWidthsForEl(el);
  document.body.removeChild(el);
  return res;
}
function computeScrollbarWidthsForEl(el) {
  return {
    x: el.offsetHeight - el.clientHeight,
    y: el.offsetWidth - el.clientWidth
  };
}
function computeEdges(el, getPadding = false) {
  let computedStyle = window.getComputedStyle(el);
  let borderLeft = parseInt(computedStyle.borderLeftWidth, 10) || 0;
  let borderRight = parseInt(computedStyle.borderRightWidth, 10) || 0;
  let borderTop = parseInt(computedStyle.borderTopWidth, 10) || 0;
  let borderBottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;
  let badScrollbarWidths = computeScrollbarWidthsForEl(el);
  let scrollbarLeftRight = badScrollbarWidths.y - borderLeft - borderRight;
  let scrollbarBottom = badScrollbarWidths.x - borderTop - borderBottom;
  let res = {
    borderLeft,
    borderRight,
    borderTop,
    borderBottom,
    scrollbarBottom,
    scrollbarLeft: 0,
    scrollbarRight: 0
  };
  if (getIsRtlScrollbarOnLeft() && computedStyle.direction === "rtl") {
    res.scrollbarLeft = scrollbarLeftRight;
  } else {
    res.scrollbarRight = scrollbarLeftRight;
  }
  if (getPadding) {
    res.paddingLeft = parseInt(computedStyle.paddingLeft, 10) || 0;
    res.paddingRight = parseInt(computedStyle.paddingRight, 10) || 0;
    res.paddingTop = parseInt(computedStyle.paddingTop, 10) || 0;
    res.paddingBottom = parseInt(computedStyle.paddingBottom, 10) || 0;
  }
  return res;
}
function computeInnerRect(el, goWithinPadding = false, doFromWindowViewport) {
  let outerRect = doFromWindowViewport ? el.getBoundingClientRect() : computeRect(el);
  let edges = computeEdges(el, goWithinPadding);
  let res = {
    left: outerRect.left + edges.borderLeft + edges.scrollbarLeft,
    right: outerRect.right - edges.borderRight - edges.scrollbarRight,
    top: outerRect.top + edges.borderTop,
    bottom: outerRect.bottom - edges.borderBottom - edges.scrollbarBottom
  };
  if (goWithinPadding) {
    res.left += edges.paddingLeft;
    res.right -= edges.paddingRight;
    res.top += edges.paddingTop;
    res.bottom -= edges.paddingBottom;
  }
  return res;
}
function computeRect(el) {
  let rect = el.getBoundingClientRect();
  return {
    left: rect.left + window.scrollX,
    top: rect.top + window.scrollY,
    right: rect.right + window.scrollX,
    bottom: rect.bottom + window.scrollY
  };
}
function computeClippedClientRect(el) {
  let clippingParents = getClippingParents(el);
  let rect = el.getBoundingClientRect();
  for (let clippingParent of clippingParents) {
    let intersection = intersectRects(rect, clippingParent.getBoundingClientRect());
    if (intersection) {
      rect = intersection;
    } else {
      return null;
    }
  }
  return rect;
}
function getClippingParents(el) {
  let parents = [];
  while (el instanceof HTMLElement) {
    let computedStyle = window.getComputedStyle(el);
    if (computedStyle.position === "fixed") {
      break;
    }
    if (/(auto|scroll)/.test(computedStyle.overflow + computedStyle.overflowY + computedStyle.overflowX)) {
      parents.push(el);
    }
    el = el.parentNode;
  }
  return parents;
}
var PositionCache = class {
  constructor(originEl, els, isHorizontal, isVertical) {
    this.els = els;
    let originClientRect = this.originClientRect = originEl.getBoundingClientRect();
    if (isHorizontal) {
      this.buildElHorizontals(originClientRect.left);
    }
    if (isVertical) {
      this.buildElVerticals(originClientRect.top);
    }
  }
  // Populates the left/right internal coordinate arrays
  buildElHorizontals(originClientLeft) {
    let lefts = [];
    let rights = [];
    for (let el of this.els) {
      let rect = el.getBoundingClientRect();
      lefts.push(rect.left - originClientLeft);
      rights.push(rect.right - originClientLeft);
    }
    this.lefts = lefts;
    this.rights = rights;
  }
  // Populates the top/bottom internal coordinate arrays
  buildElVerticals(originClientTop) {
    let tops = [];
    let bottoms = [];
    for (let el of this.els) {
      let rect = el.getBoundingClientRect();
      tops.push(rect.top - originClientTop);
      bottoms.push(rect.bottom - originClientTop);
    }
    this.tops = tops;
    this.bottoms = bottoms;
  }
  // Given a left offset (from document left), returns the index of the el that it horizontally intersects.
  // If no intersection is made, returns undefined.
  leftToIndex(leftPosition) {
    let { lefts, rights } = this;
    let len = lefts.length;
    let i3;
    for (i3 = 0; i3 < len; i3 += 1) {
      if (leftPosition >= lefts[i3] && leftPosition < rights[i3]) {
        return i3;
      }
    }
    return void 0;
  }
  // Given a top offset (from document top), returns the index of the el that it vertically intersects.
  // If no intersection is made, returns undefined.
  topToIndex(topPosition) {
    let { tops, bottoms } = this;
    let len = tops.length;
    let i3;
    for (i3 = 0; i3 < len; i3 += 1) {
      if (topPosition >= tops[i3] && topPosition < bottoms[i3]) {
        return i3;
      }
    }
    return void 0;
  }
  // Gets the width of the element at the given index
  getWidth(leftIndex) {
    return this.rights[leftIndex] - this.lefts[leftIndex];
  }
  // Gets the height of the element at the given index
  getHeight(topIndex) {
    return this.bottoms[topIndex] - this.tops[topIndex];
  }
  similarTo(otherCache) {
    return similarNumArrays(this.tops || [], otherCache.tops || []) && similarNumArrays(this.bottoms || [], otherCache.bottoms || []) && similarNumArrays(this.lefts || [], otherCache.lefts || []) && similarNumArrays(this.rights || [], otherCache.rights || []);
  }
};
function similarNumArrays(a3, b3) {
  const len = a3.length;
  if (len !== b3.length) {
    return false;
  }
  for (let i3 = 0; i3 < len; i3++) {
    if (Math.round(a3[i3]) !== Math.round(b3[i3])) {
      return false;
    }
  }
  return true;
}
var ScrollController = class {
  getMaxScrollTop() {
    return this.getScrollHeight() - this.getClientHeight();
  }
  getMaxScrollLeft() {
    return this.getScrollWidth() - this.getClientWidth();
  }
  canScrollVertically() {
    return this.getMaxScrollTop() > 0;
  }
  canScrollHorizontally() {
    return this.getMaxScrollLeft() > 0;
  }
  canScrollUp() {
    return this.getScrollTop() > 0;
  }
  canScrollDown() {
    return this.getScrollTop() < this.getMaxScrollTop();
  }
  canScrollLeft() {
    return this.getScrollLeft() > 0;
  }
  canScrollRight() {
    return this.getScrollLeft() < this.getMaxScrollLeft();
  }
};
var ElementScrollController = class extends ScrollController {
  constructor(el) {
    super();
    this.el = el;
  }
  getScrollTop() {
    return this.el.scrollTop;
  }
  getScrollLeft() {
    return this.el.scrollLeft;
  }
  setScrollTop(top) {
    this.el.scrollTop = top;
  }
  setScrollLeft(left) {
    this.el.scrollLeft = left;
  }
  getScrollWidth() {
    return this.el.scrollWidth;
  }
  getScrollHeight() {
    return this.el.scrollHeight;
  }
  getClientHeight() {
    return this.el.clientHeight;
  }
  getClientWidth() {
    return this.el.clientWidth;
  }
};
var WindowScrollController = class extends ScrollController {
  getScrollTop() {
    return window.scrollY;
  }
  getScrollLeft() {
    return window.scrollX;
  }
  setScrollTop(n2) {
    window.scroll(window.scrollX, n2);
  }
  setScrollLeft(n2) {
    window.scroll(n2, window.scrollY);
  }
  getScrollWidth() {
    return document.documentElement.scrollWidth;
  }
  getScrollHeight() {
    return document.documentElement.scrollHeight;
  }
  getClientHeight() {
    return document.documentElement.clientHeight;
  }
  getClientWidth() {
    return document.documentElement.clientWidth;
  }
};
var DateComponent = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.uid = guid();
  }
  // Hit System
  // -----------------------------------------------------------------------------------------------------------------
  prepareHits() {
  }
  queryHit(positionLeft, positionTop, elWidth, elHeight) {
    return null;
  }
  // Pointer Interaction Utils
  // -----------------------------------------------------------------------------------------------------------------
  isValidSegDownEl(el) {
    return !this.props.eventDrag && // HACK
    !this.props.eventResize && // HACK
    !elementClosest(el, ".fc-event-mirror");
  }
  isValidDateDownEl(el) {
    return !elementClosest(el, ".fc-event:not(.fc-bg-event)") && !elementClosest(el, ".fc-more-link") && // a "more.." link
    !elementClosest(el, "a[data-navlink]") && // a clickable nav link
    !elementClosest(el, ".fc-popover");
  }
};
var SegHierarchy = class {
  constructor(getEntryThickness = (entry) => {
    return entry.thickness || 1;
  }) {
    this.getEntryThickness = getEntryThickness;
    this.strictOrder = false;
    this.allowReslicing = false;
    this.maxCoord = -1;
    this.maxStackCnt = -1;
    this.levelCoords = [];
    this.entriesByLevel = [];
    this.stackCnts = {};
  }
  addSegs(inputs) {
    let hiddenEntries = [];
    for (let input of inputs) {
      this.insertEntry(input, hiddenEntries);
    }
    return hiddenEntries;
  }
  insertEntry(entry, hiddenEntries) {
    let insertion = this.findInsertion(entry);
    if (this.isInsertionValid(insertion, entry)) {
      this.insertEntryAt(entry, insertion);
    } else {
      this.handleInvalidInsertion(insertion, entry, hiddenEntries);
    }
  }
  isInsertionValid(insertion, entry) {
    return (this.maxCoord === -1 || insertion.levelCoord + this.getEntryThickness(entry) <= this.maxCoord) && (this.maxStackCnt === -1 || insertion.stackCnt < this.maxStackCnt);
  }
  handleInvalidInsertion(insertion, entry, hiddenEntries) {
    if (this.allowReslicing && insertion.touchingEntry) {
      const hiddenEntry = Object.assign(Object.assign({}, entry), { span: intersectSpans(entry.span, insertion.touchingEntry.span) });
      hiddenEntries.push(hiddenEntry);
      this.splitEntry(entry, insertion.touchingEntry, hiddenEntries);
    } else {
      hiddenEntries.push(entry);
    }
  }
  /*
  Does NOT add what hit the `barrier` into hiddenEntries. Should already be done.
  */
  splitEntry(entry, barrier, hiddenEntries) {
    let entrySpan = entry.span;
    let barrierSpan = barrier.span;
    if (entrySpan.start < barrierSpan.start) {
      this.insertEntry({
        index: entry.index,
        thickness: entry.thickness,
        span: { start: entrySpan.start, end: barrierSpan.start }
      }, hiddenEntries);
    }
    if (entrySpan.end > barrierSpan.end) {
      this.insertEntry({
        index: entry.index,
        thickness: entry.thickness,
        span: { start: barrierSpan.end, end: entrySpan.end }
      }, hiddenEntries);
    }
  }
  insertEntryAt(entry, insertion) {
    let { entriesByLevel, levelCoords } = this;
    if (insertion.lateral === -1) {
      insertAt(levelCoords, insertion.level, insertion.levelCoord);
      insertAt(entriesByLevel, insertion.level, [entry]);
    } else {
      insertAt(entriesByLevel[insertion.level], insertion.lateral, entry);
    }
    this.stackCnts[buildEntryKey(entry)] = insertion.stackCnt;
  }
  /*
  does not care about limits
  */
  findInsertion(newEntry) {
    let { levelCoords, entriesByLevel, strictOrder, stackCnts } = this;
    let levelCnt = levelCoords.length;
    let candidateCoord = 0;
    let touchingLevel = -1;
    let touchingLateral = -1;
    let touchingEntry = null;
    let stackCnt = 0;
    for (let trackingLevel = 0; trackingLevel < levelCnt; trackingLevel += 1) {
      const trackingCoord = levelCoords[trackingLevel];
      if (!strictOrder && trackingCoord >= candidateCoord + this.getEntryThickness(newEntry)) {
        break;
      }
      let trackingEntries = entriesByLevel[trackingLevel];
      let trackingEntry;
      let searchRes = binarySearch(trackingEntries, newEntry.span.start, getEntrySpanEnd);
      let lateralIndex = searchRes[0] + searchRes[1];
      while (
        // loop through entries that horizontally intersect
        (trackingEntry = trackingEntries[lateralIndex]) && // but not past the whole entry list
        trackingEntry.span.start < newEntry.span.end
      ) {
        let trackingEntryBottom = trackingCoord + this.getEntryThickness(trackingEntry);
        if (trackingEntryBottom > candidateCoord) {
          candidateCoord = trackingEntryBottom;
          touchingEntry = trackingEntry;
          touchingLevel = trackingLevel;
          touchingLateral = lateralIndex;
        }
        if (trackingEntryBottom === candidateCoord) {
          stackCnt = Math.max(stackCnt, stackCnts[buildEntryKey(trackingEntry)] + 1);
        }
        lateralIndex += 1;
      }
    }
    let destLevel = 0;
    if (touchingEntry) {
      destLevel = touchingLevel + 1;
      while (destLevel < levelCnt && levelCoords[destLevel] < candidateCoord) {
        destLevel += 1;
      }
    }
    let destLateral = -1;
    if (destLevel < levelCnt && levelCoords[destLevel] === candidateCoord) {
      destLateral = binarySearch(entriesByLevel[destLevel], newEntry.span.end, getEntrySpanEnd)[0];
    }
    return {
      touchingLevel,
      touchingLateral,
      touchingEntry,
      stackCnt,
      levelCoord: candidateCoord,
      level: destLevel,
      lateral: destLateral
    };
  }
  // sorted by levelCoord (lowest to highest)
  toRects() {
    let { entriesByLevel, levelCoords } = this;
    let levelCnt = entriesByLevel.length;
    let rects = [];
    for (let level = 0; level < levelCnt; level += 1) {
      let entries = entriesByLevel[level];
      let levelCoord = levelCoords[level];
      for (let entry of entries) {
        rects.push(Object.assign(Object.assign({}, entry), { thickness: this.getEntryThickness(entry), levelCoord }));
      }
    }
    return rects;
  }
};
function getEntrySpanEnd(entry) {
  return entry.span.end;
}
function buildEntryKey(entry) {
  return entry.index + ":" + entry.span.start;
}
function groupIntersectingEntries(entries) {
  let merges = [];
  for (let entry of entries) {
    let filteredMerges = [];
    let hungryMerge = {
      span: entry.span,
      entries: [entry]
    };
    for (let merge of merges) {
      if (intersectSpans(merge.span, hungryMerge.span)) {
        hungryMerge = {
          entries: merge.entries.concat(hungryMerge.entries),
          span: joinSpans(merge.span, hungryMerge.span)
        };
      } else {
        filteredMerges.push(merge);
      }
    }
    filteredMerges.push(hungryMerge);
    merges = filteredMerges;
  }
  return merges;
}
function joinSpans(span0, span1) {
  return {
    start: Math.min(span0.start, span1.start),
    end: Math.max(span0.end, span1.end)
  };
}
function intersectSpans(span0, span1) {
  let start = Math.max(span0.start, span1.start);
  let end = Math.min(span0.end, span1.end);
  if (start < end) {
    return { start, end };
  }
  return null;
}
function insertAt(arr, index8, item) {
  arr.splice(index8, 0, item);
}
function binarySearch(a3, searchVal, getItemVal) {
  let startIndex = 0;
  let endIndex = a3.length;
  if (!endIndex || searchVal < getItemVal(a3[startIndex])) {
    return [0, 0];
  }
  if (searchVal > getItemVal(a3[endIndex - 1])) {
    return [endIndex, 0];
  }
  while (startIndex < endIndex) {
    let middleIndex = Math.floor(startIndex + (endIndex - startIndex) / 2);
    let middleVal = getItemVal(a3[middleIndex]);
    if (searchVal < middleVal) {
      endIndex = middleIndex;
    } else if (searchVal > middleVal) {
      startIndex = middleIndex + 1;
    } else {
      return [middleIndex, 1];
    }
  }
  return [startIndex, 0];
}
var ElementDragging = class {
  constructor(el, selector) {
    this.emitter = new Emitter();
  }
  destroy() {
  }
  setMirrorIsVisible(bool) {
  }
  setMirrorNeedsRevert(bool) {
  }
  setAutoScrollEnabled(bool) {
  }
};
var config = {};
function computeFallbackHeaderFormat(datesRepDistinctDays, dayCnt) {
  if (!datesRepDistinctDays || dayCnt > 10) {
    return createFormatter({ weekday: "short" });
  }
  if (dayCnt > 1) {
    return createFormatter({ weekday: "short", month: "numeric", day: "numeric", omitCommas: true });
  }
  return createFormatter({ weekday: "long" });
}
var CLASS_NAME = "fc-col-header-cell";
function renderInner$1(renderProps) {
  return renderProps.text;
}
var TableDateCell = class extends BaseComponent {
  render() {
    let { dateEnv, options, theme, viewApi } = this.context;
    let { props } = this;
    let { date, dateProfile } = props;
    let dayMeta = getDateMeta(date, props.todayRange, null, dateProfile);
    let classNames = [CLASS_NAME].concat(getDayClassNames(dayMeta, theme));
    let text = dateEnv.format(date, props.dayHeaderFormat);
    let navLinkAttrs = !dayMeta.isDisabled && props.colCnt > 1 ? buildNavLinkAttrs(this.context, date) : {};
    let renderProps = Object.assign(Object.assign(Object.assign({ date: dateEnv.toDate(date), view: viewApi }, props.extraRenderProps), { text }), dayMeta);
    return y(ContentContainer, { elTag: "th", elClasses: classNames, elAttrs: Object.assign({ role: "columnheader", colSpan: props.colSpan, "data-date": !dayMeta.isDisabled ? formatDayString(date) : void 0 }, props.extraDataAttrs), renderProps, generatorName: "dayHeaderContent", customGenerator: options.dayHeaderContent, defaultGenerator: renderInner$1, classNameGenerator: options.dayHeaderClassNames, didMount: options.dayHeaderDidMount, willUnmount: options.dayHeaderWillUnmount }, (InnerContainer) => y("div", { className: "fc-scrollgrid-sync-inner" }, !dayMeta.isDisabled && y(InnerContainer, { elTag: "a", elAttrs: navLinkAttrs, elClasses: [
      "fc-col-header-cell-cushion",
      props.isSticky && "fc-sticky"
    ] })));
  }
};
var WEEKDAY_FORMAT = createFormatter({ weekday: "long" });
var TableDowCell = class extends BaseComponent {
  render() {
    let { props } = this;
    let { dateEnv, theme, viewApi, options } = this.context;
    let date = addDays(new Date(2592e5), props.dow);
    let dateMeta = {
      dow: props.dow,
      isDisabled: false,
      isFuture: false,
      isPast: false,
      isToday: false,
      isOther: false
    };
    let text = dateEnv.format(date, props.dayHeaderFormat);
    let renderProps = Object.assign(Object.assign(Object.assign(Object.assign({
      // TODO: make this public?
      date
    }, dateMeta), { view: viewApi }), props.extraRenderProps), { text });
    return y(ContentContainer, { elTag: "th", elClasses: [
      CLASS_NAME,
      ...getDayClassNames(dateMeta, theme),
      ...props.extraClassNames || []
    ], elAttrs: Object.assign({ role: "columnheader", colSpan: props.colSpan }, props.extraDataAttrs), renderProps, generatorName: "dayHeaderContent", customGenerator: options.dayHeaderContent, defaultGenerator: renderInner$1, classNameGenerator: options.dayHeaderClassNames, didMount: options.dayHeaderDidMount, willUnmount: options.dayHeaderWillUnmount }, (InnerContent) => y(
      "div",
      { className: "fc-scrollgrid-sync-inner" },
      y(InnerContent, { elTag: "a", elClasses: [
        "fc-col-header-cell-cushion",
        props.isSticky && "fc-sticky"
      ], elAttrs: {
        "aria-label": dateEnv.format(date, WEEKDAY_FORMAT)
      } })
    ));
  }
};
var NowTimer = class extends x {
  constructor(props, context) {
    super(props, context);
    this.initialNowDate = getNow(context.options.now, context.dateEnv);
    this.initialNowQueriedMs = new Date().valueOf();
    this.state = this.computeTiming().currentState;
  }
  render() {
    let { props, state } = this;
    return props.children(state.nowDate, state.todayRange);
  }
  componentDidMount() {
    this.setTimeout();
  }
  componentDidUpdate(prevProps) {
    if (prevProps.unit !== this.props.unit) {
      this.clearTimeout();
      this.setTimeout();
    }
  }
  componentWillUnmount() {
    this.clearTimeout();
  }
  computeTiming() {
    let { props, context } = this;
    let unroundedNow = addMs(this.initialNowDate, new Date().valueOf() - this.initialNowQueriedMs);
    let currentUnitStart = context.dateEnv.startOf(unroundedNow, props.unit);
    let nextUnitStart = context.dateEnv.add(currentUnitStart, createDuration(1, props.unit));
    let waitMs = nextUnitStart.valueOf() - unroundedNow.valueOf();
    waitMs = Math.min(1e3 * 60 * 60 * 24, waitMs);
    return {
      currentState: { nowDate: currentUnitStart, todayRange: buildDayRange(currentUnitStart) },
      nextState: { nowDate: nextUnitStart, todayRange: buildDayRange(nextUnitStart) },
      waitMs
    };
  }
  setTimeout() {
    let { nextState, waitMs } = this.computeTiming();
    this.timeoutId = setTimeout(() => {
      this.setState(nextState, () => {
        this.setTimeout();
      });
    }, waitMs);
  }
  clearTimeout() {
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
    }
  }
};
NowTimer.contextType = ViewContextType;
function buildDayRange(date) {
  let start = startOfDay(date);
  let end = addDays(start, 1);
  return { start, end };
}
var DayHeader = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.createDayHeaderFormatter = memoize(createDayHeaderFormatter);
  }
  render() {
    let { context } = this;
    let { dates, dateProfile, datesRepDistinctDays, renderIntro } = this.props;
    let dayHeaderFormat = this.createDayHeaderFormatter(context.options.dayHeaderFormat, datesRepDistinctDays, dates.length);
    return y(NowTimer, { unit: "day" }, (nowDate, todayRange) => y(
      "tr",
      { role: "row" },
      renderIntro && renderIntro("day"),
      dates.map((date) => datesRepDistinctDays ? y(TableDateCell, { key: date.toISOString(), date, dateProfile, todayRange, colCnt: dates.length, dayHeaderFormat }) : y(TableDowCell, { key: date.getUTCDay(), dow: date.getUTCDay(), dayHeaderFormat }))
    ));
  }
};
function createDayHeaderFormatter(explicitFormat, datesRepDistinctDays, dateCnt) {
  return explicitFormat || computeFallbackHeaderFormat(datesRepDistinctDays, dateCnt);
}
var DaySeriesModel = class {
  constructor(range2, dateProfileGenerator) {
    let date = range2.start;
    let { end } = range2;
    let indices = [];
    let dates = [];
    let dayIndex = -1;
    while (date < end) {
      if (dateProfileGenerator.isHiddenDay(date)) {
        indices.push(dayIndex + 0.5);
      } else {
        dayIndex += 1;
        indices.push(dayIndex);
        dates.push(date);
      }
      date = addDays(date, 1);
    }
    this.dates = dates;
    this.indices = indices;
    this.cnt = dates.length;
  }
  sliceRange(range2) {
    let firstIndex = this.getDateDayIndex(range2.start);
    let lastIndex = this.getDateDayIndex(addDays(range2.end, -1));
    let clippedFirstIndex = Math.max(0, firstIndex);
    let clippedLastIndex = Math.min(this.cnt - 1, lastIndex);
    clippedFirstIndex = Math.ceil(clippedFirstIndex);
    clippedLastIndex = Math.floor(clippedLastIndex);
    if (clippedFirstIndex <= clippedLastIndex) {
      return {
        firstIndex: clippedFirstIndex,
        lastIndex: clippedLastIndex,
        isStart: firstIndex === clippedFirstIndex,
        isEnd: lastIndex === clippedLastIndex
      };
    }
    return null;
  }
  // Given a date, returns its chronolocial cell-index from the first cell of the grid.
  // If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.
  // If before the first offset, returns a negative number.
  // If after the last offset, returns an offset past the last cell offset.
  // Only works for *start* dates of cells. Will not work for exclusive end dates for cells.
  getDateDayIndex(date) {
    let { indices } = this;
    let dayOffset = Math.floor(diffDays(this.dates[0], date));
    if (dayOffset < 0) {
      return indices[0] - 1;
    }
    if (dayOffset >= indices.length) {
      return indices[indices.length - 1] + 1;
    }
    return indices[dayOffset];
  }
};
var DayTableModel = class {
  constructor(daySeries, breakOnWeeks) {
    let { dates } = daySeries;
    let daysPerRow;
    let firstDay;
    let rowCnt;
    if (breakOnWeeks) {
      firstDay = dates[0].getUTCDay();
      for (daysPerRow = 1; daysPerRow < dates.length; daysPerRow += 1) {
        if (dates[daysPerRow].getUTCDay() === firstDay) {
          break;
        }
      }
      rowCnt = Math.ceil(dates.length / daysPerRow);
    } else {
      rowCnt = 1;
      daysPerRow = dates.length;
    }
    this.rowCnt = rowCnt;
    this.colCnt = daysPerRow;
    this.daySeries = daySeries;
    this.cells = this.buildCells();
    this.headerDates = this.buildHeaderDates();
  }
  buildCells() {
    let rows = [];
    for (let row = 0; row < this.rowCnt; row += 1) {
      let cells = [];
      for (let col = 0; col < this.colCnt; col += 1) {
        cells.push(this.buildCell(row, col));
      }
      rows.push(cells);
    }
    return rows;
  }
  buildCell(row, col) {
    let date = this.daySeries.dates[row * this.colCnt + col];
    return {
      key: date.toISOString(),
      date
    };
  }
  buildHeaderDates() {
    let dates = [];
    for (let col = 0; col < this.colCnt; col += 1) {
      dates.push(this.cells[0][col].date);
    }
    return dates;
  }
  sliceRange(range2) {
    let { colCnt } = this;
    let seriesSeg = this.daySeries.sliceRange(range2);
    let segs = [];
    if (seriesSeg) {
      let { firstIndex, lastIndex } = seriesSeg;
      let index8 = firstIndex;
      while (index8 <= lastIndex) {
        let row = Math.floor(index8 / colCnt);
        let nextIndex = Math.min((row + 1) * colCnt, lastIndex + 1);
        segs.push({
          row,
          firstCol: index8 % colCnt,
          lastCol: (nextIndex - 1) % colCnt,
          isStart: seriesSeg.isStart && index8 === firstIndex,
          isEnd: seriesSeg.isEnd && nextIndex - 1 === lastIndex
        });
        index8 = nextIndex;
      }
    }
    return segs;
  }
};
var Slicer = class {
  constructor() {
    this.sliceBusinessHours = memoize(this._sliceBusinessHours);
    this.sliceDateSelection = memoize(this._sliceDateSpan);
    this.sliceEventStore = memoize(this._sliceEventStore);
    this.sliceEventDrag = memoize(this._sliceInteraction);
    this.sliceEventResize = memoize(this._sliceInteraction);
    this.forceDayIfListItem = false;
  }
  sliceProps(props, dateProfile, nextDayThreshold, context, ...extraArgs) {
    let { eventUiBases } = props;
    let eventSegs = this.sliceEventStore(props.eventStore, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs);
    return {
      dateSelectionSegs: this.sliceDateSelection(props.dateSelection, dateProfile, nextDayThreshold, eventUiBases, context, ...extraArgs),
      businessHourSegs: this.sliceBusinessHours(props.businessHours, dateProfile, nextDayThreshold, context, ...extraArgs),
      fgEventSegs: eventSegs.fg,
      bgEventSegs: eventSegs.bg,
      eventDrag: this.sliceEventDrag(props.eventDrag, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs),
      eventResize: this.sliceEventResize(props.eventResize, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs),
      eventSelection: props.eventSelection
    };
  }
  sliceNowDate(date, dateProfile, nextDayThreshold, context, ...extraArgs) {
    return this._sliceDateSpan(
      { range: { start: date, end: addMs(date, 1) }, allDay: false },
      // add 1 ms, protect against null range
      dateProfile,
      nextDayThreshold,
      {},
      context,
      ...extraArgs
    );
  }
  _sliceBusinessHours(businessHours, dateProfile, nextDayThreshold, context, ...extraArgs) {
    if (!businessHours) {
      return [];
    }
    return this._sliceEventStore(expandRecurring(businessHours, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), context), {}, dateProfile, nextDayThreshold, ...extraArgs).bg;
  }
  _sliceEventStore(eventStore, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs) {
    if (eventStore) {
      let rangeRes = sliceEventStore(eventStore, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);
      return {
        bg: this.sliceEventRanges(rangeRes.bg, extraArgs),
        fg: this.sliceEventRanges(rangeRes.fg, extraArgs)
      };
    }
    return { bg: [], fg: [] };
  }
  _sliceInteraction(interaction, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs) {
    if (!interaction) {
      return null;
    }
    let rangeRes = sliceEventStore(interaction.mutatedEvents, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);
    return {
      segs: this.sliceEventRanges(rangeRes.fg, extraArgs),
      affectedInstances: interaction.affectedEvents.instances,
      isEvent: interaction.isEvent
    };
  }
  _sliceDateSpan(dateSpan, dateProfile, nextDayThreshold, eventUiBases, context, ...extraArgs) {
    if (!dateSpan) {
      return [];
    }
    let activeRange = computeActiveRange(dateProfile, Boolean(nextDayThreshold));
    let activeDateSpanRange = intersectRanges(dateSpan.range, activeRange);
    if (activeDateSpanRange) {
      dateSpan = Object.assign(Object.assign({}, dateSpan), { range: activeDateSpanRange });
      let eventRange = fabricateEventRange(dateSpan, eventUiBases, context);
      let segs = this.sliceRange(dateSpan.range, ...extraArgs);
      for (let seg of segs) {
        seg.eventRange = eventRange;
      }
      return segs;
    }
    return [];
  }
  /*
  "complete" seg means it has component and eventRange
  */
  sliceEventRanges(eventRanges, extraArgs) {
    let segs = [];
    for (let eventRange of eventRanges) {
      segs.push(...this.sliceEventRange(eventRange, extraArgs));
    }
    return segs;
  }
  /*
  "complete" seg means it has component and eventRange
  */
  sliceEventRange(eventRange, extraArgs) {
    let dateRange = eventRange.range;
    if (this.forceDayIfListItem && eventRange.ui.display === "list-item") {
      dateRange = {
        start: dateRange.start,
        end: addDays(dateRange.start, 1)
      };
    }
    let segs = this.sliceRange(dateRange, ...extraArgs);
    for (let seg of segs) {
      seg.eventRange = eventRange;
      seg.isStart = eventRange.isStart && seg.isStart;
      seg.isEnd = eventRange.isEnd && seg.isEnd;
    }
    return segs;
  }
};
function computeActiveRange(dateProfile, isComponentAllDay) {
  let range2 = dateProfile.activeRange;
  if (isComponentAllDay) {
    return range2;
  }
  return {
    start: addMs(range2.start, dateProfile.slotMinTime.milliseconds),
    end: addMs(range2.end, dateProfile.slotMaxTime.milliseconds - 864e5)
    // 864e5 = ms in a day
  };
}
function isInteractionValid(interaction, dateProfile, context) {
  let { instances } = interaction.mutatedEvents;
  for (let instanceId in instances) {
    if (!rangeContainsRange(dateProfile.validRange, instances[instanceId].range)) {
      return false;
    }
  }
  return isNewPropsValid({ eventDrag: interaction }, context);
}
function isDateSelectionValid(dateSelection, dateProfile, context) {
  if (!rangeContainsRange(dateProfile.validRange, dateSelection.range)) {
    return false;
  }
  return isNewPropsValid({ dateSelection }, context);
}
function isNewPropsValid(newProps, context) {
  let calendarState = context.getCurrentData();
  let props = Object.assign({ businessHours: calendarState.businessHours, dateSelection: "", eventStore: calendarState.eventStore, eventUiBases: calendarState.eventUiBases, eventSelection: "", eventDrag: null, eventResize: null }, newProps);
  return (context.pluginHooks.isPropsValid || isPropsValid)(props, context);
}
function isPropsValid(state, context, dateSpanMeta = {}, filterConfig) {
  if (state.eventDrag && !isInteractionPropsValid(state, context, dateSpanMeta, filterConfig)) {
    return false;
  }
  if (state.dateSelection && !isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig)) {
    return false;
  }
  return true;
}
function isInteractionPropsValid(state, context, dateSpanMeta, filterConfig) {
  let currentState = context.getCurrentData();
  let interaction = state.eventDrag;
  let subjectEventStore = interaction.mutatedEvents;
  let subjectDefs = subjectEventStore.defs;
  let subjectInstances = subjectEventStore.instances;
  let subjectConfigs = compileEventUis(subjectDefs, interaction.isEvent ? state.eventUiBases : { "": currentState.selectionConfig });
  if (filterConfig) {
    subjectConfigs = mapHash(subjectConfigs, filterConfig);
  }
  let otherEventStore = excludeInstances(state.eventStore, interaction.affectedEvents.instances);
  let otherDefs = otherEventStore.defs;
  let otherInstances = otherEventStore.instances;
  let otherConfigs = compileEventUis(otherDefs, state.eventUiBases);
  for (let subjectInstanceId in subjectInstances) {
    let subjectInstance = subjectInstances[subjectInstanceId];
    let subjectRange = subjectInstance.range;
    let subjectConfig = subjectConfigs[subjectInstance.defId];
    let subjectDef = subjectDefs[subjectInstance.defId];
    if (!allConstraintsPass(subjectConfig.constraints, subjectRange, otherEventStore, state.businessHours, context)) {
      return false;
    }
    let { eventOverlap } = context.options;
    let eventOverlapFunc = typeof eventOverlap === "function" ? eventOverlap : null;
    for (let otherInstanceId in otherInstances) {
      let otherInstance = otherInstances[otherInstanceId];
      if (rangesIntersect(subjectRange, otherInstance.range)) {
        let otherOverlap = otherConfigs[otherInstance.defId].overlap;
        if (otherOverlap === false && interaction.isEvent) {
          return false;
        }
        if (subjectConfig.overlap === false) {
          return false;
        }
        if (eventOverlapFunc && !eventOverlapFunc(
          new EventImpl(context, otherDefs[otherInstance.defId], otherInstance),
          // still event
          new EventImpl(context, subjectDef, subjectInstance)
        )) {
          return false;
        }
      }
    }
    let calendarEventStore = currentState.eventStore;
    for (let subjectAllow of subjectConfig.allows) {
      let subjectDateSpan = Object.assign(Object.assign({}, dateSpanMeta), { range: subjectInstance.range, allDay: subjectDef.allDay });
      let origDef = calendarEventStore.defs[subjectDef.defId];
      let origInstance = calendarEventStore.instances[subjectInstanceId];
      let eventApi;
      if (origDef) {
        eventApi = new EventImpl(context, origDef, origInstance);
      } else {
        eventApi = new EventImpl(context, subjectDef);
      }
      if (!subjectAllow(buildDateSpanApiWithContext(subjectDateSpan, context), eventApi)) {
        return false;
      }
    }
  }
  return true;
}
function isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig) {
  let relevantEventStore = state.eventStore;
  let relevantDefs = relevantEventStore.defs;
  let relevantInstances = relevantEventStore.instances;
  let selection = state.dateSelection;
  let selectionRange = selection.range;
  let { selectionConfig } = context.getCurrentData();
  if (filterConfig) {
    selectionConfig = filterConfig(selectionConfig);
  }
  if (!allConstraintsPass(selectionConfig.constraints, selectionRange, relevantEventStore, state.businessHours, context)) {
    return false;
  }
  let { selectOverlap } = context.options;
  let selectOverlapFunc = typeof selectOverlap === "function" ? selectOverlap : null;
  for (let relevantInstanceId in relevantInstances) {
    let relevantInstance = relevantInstances[relevantInstanceId];
    if (rangesIntersect(selectionRange, relevantInstance.range)) {
      if (selectionConfig.overlap === false) {
        return false;
      }
      if (selectOverlapFunc && !selectOverlapFunc(new EventImpl(context, relevantDefs[relevantInstance.defId], relevantInstance), null)) {
        return false;
      }
    }
  }
  for (let selectionAllow of selectionConfig.allows) {
    let fullDateSpan = Object.assign(Object.assign({}, dateSpanMeta), selection);
    if (!selectionAllow(buildDateSpanApiWithContext(fullDateSpan, context), null)) {
      return false;
    }
  }
  return true;
}
function allConstraintsPass(constraints, subjectRange, otherEventStore, businessHoursUnexpanded, context) {
  for (let constraint of constraints) {
    if (!anyRangesContainRange(constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, context), subjectRange)) {
      return false;
    }
  }
  return true;
}
function constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, context) {
  if (constraint === "businessHours") {
    return eventStoreToRanges(expandRecurring(businessHoursUnexpanded, subjectRange, context));
  }
  if (typeof constraint === "string") {
    return eventStoreToRanges(filterEventStoreDefs(otherEventStore, (eventDef) => eventDef.groupId === constraint));
  }
  if (typeof constraint === "object" && constraint) {
    return eventStoreToRanges(expandRecurring(constraint, subjectRange, context));
  }
  return [];
}
function eventStoreToRanges(eventStore) {
  let { instances } = eventStore;
  let ranges = [];
  for (let instanceId in instances) {
    ranges.push(instances[instanceId].range);
  }
  return ranges;
}
function anyRangesContainRange(outerRanges, innerRange) {
  for (let outerRange of outerRanges) {
    if (rangeContainsRange(outerRange, innerRange)) {
      return true;
    }
  }
  return false;
}
var VISIBLE_HIDDEN_RE = /^(visible|hidden)$/;
var Scroller = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.handleEl = (el) => {
      this.el = el;
      setRef(this.props.elRef, el);
    };
  }
  render() {
    let { props } = this;
    let { liquid, liquidIsAbsolute } = props;
    let isAbsolute = liquid && liquidIsAbsolute;
    let className = ["fc-scroller"];
    if (liquid) {
      if (liquidIsAbsolute) {
        className.push("fc-scroller-liquid-absolute");
      } else {
        className.push("fc-scroller-liquid");
      }
    }
    return y("div", { ref: this.handleEl, className: className.join(" "), style: {
      overflowX: props.overflowX,
      overflowY: props.overflowY,
      left: isAbsolute && -(props.overcomeLeft || 0) || "",
      right: isAbsolute && -(props.overcomeRight || 0) || "",
      bottom: isAbsolute && -(props.overcomeBottom || 0) || "",
      marginLeft: !isAbsolute && -(props.overcomeLeft || 0) || "",
      marginRight: !isAbsolute && -(props.overcomeRight || 0) || "",
      marginBottom: !isAbsolute && -(props.overcomeBottom || 0) || "",
      maxHeight: props.maxHeight || ""
    } }, props.children);
  }
  needsXScrolling() {
    if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {
      return false;
    }
    let { el } = this;
    let realClientWidth = this.el.getBoundingClientRect().width - this.getYScrollbarWidth();
    let { children } = el;
    for (let i3 = 0; i3 < children.length; i3 += 1) {
      let childEl = children[i3];
      if (childEl.getBoundingClientRect().width > realClientWidth) {
        return true;
      }
    }
    return false;
  }
  needsYScrolling() {
    if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {
      return false;
    }
    let { el } = this;
    let realClientHeight = this.el.getBoundingClientRect().height - this.getXScrollbarWidth();
    let { children } = el;
    for (let i3 = 0; i3 < children.length; i3 += 1) {
      let childEl = children[i3];
      if (childEl.getBoundingClientRect().height > realClientHeight) {
        return true;
      }
    }
    return false;
  }
  getXScrollbarWidth() {
    if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {
      return 0;
    }
    return this.el.offsetHeight - this.el.clientHeight;
  }
  getYScrollbarWidth() {
    if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {
      return 0;
    }
    return this.el.offsetWidth - this.el.clientWidth;
  }
};
var RefMap = class {
  constructor(masterCallback) {
    this.masterCallback = masterCallback;
    this.currentMap = {};
    this.depths = {};
    this.callbackMap = {};
    this.handleValue = (val, key) => {
      let { depths, currentMap } = this;
      let removed = false;
      let added = false;
      if (val !== null) {
        removed = key in currentMap;
        currentMap[key] = val;
        depths[key] = (depths[key] || 0) + 1;
        added = true;
      } else {
        depths[key] -= 1;
        if (!depths[key]) {
          delete currentMap[key];
          delete this.callbackMap[key];
          removed = true;
        }
      }
      if (this.masterCallback) {
        if (removed) {
          this.masterCallback(null, String(key));
        }
        if (added) {
          this.masterCallback(val, String(key));
        }
      }
    };
  }
  createRef(key) {
    let refCallback = this.callbackMap[key];
    if (!refCallback) {
      refCallback = this.callbackMap[key] = (val) => {
        this.handleValue(val, String(key));
      };
    }
    return refCallback;
  }
  // TODO: check callers that don't care about order. should use getAll instead
  // NOTE: this method has become less valuable now that we are encouraged to map order by some other index
  // TODO: provide ONE array-export function, buildArray, which fails on non-numeric indexes. caller can manipulate and "collect"
  collect(startIndex, endIndex, step) {
    return collectFromHash(this.currentMap, startIndex, endIndex, step);
  }
  getAll() {
    return hashValuesToArray(this.currentMap);
  }
};
function computeShrinkWidth(chunkEls) {
  let shrinkCells = findElements(chunkEls, ".fc-scrollgrid-shrink");
  let largestWidth = 0;
  for (let shrinkCell of shrinkCells) {
    largestWidth = Math.max(largestWidth, computeSmallestCellWidth(shrinkCell));
  }
  return Math.ceil(largestWidth);
}
function getSectionHasLiquidHeight(props, sectionConfig) {
  return props.liquid && sectionConfig.liquid;
}
function getAllowYScrolling(props, sectionConfig) {
  return sectionConfig.maxHeight != null || // if its possible for the height to max out, we might need scrollbars
  getSectionHasLiquidHeight(props, sectionConfig);
}
function renderChunkContent(sectionConfig, chunkConfig, arg, isHeader) {
  let { expandRows } = arg;
  let content = typeof chunkConfig.content === "function" ? chunkConfig.content(arg) : y("table", {
    role: "presentation",
    className: [
      chunkConfig.tableClassName,
      sectionConfig.syncRowHeights ? "fc-scrollgrid-sync-table" : ""
    ].join(" "),
    style: {
      minWidth: arg.tableMinWidth,
      width: arg.clientWidth,
      height: expandRows ? arg.clientHeight : ""
      // css `height` on a <table> serves as a min-height
    }
  }, arg.tableColGroupNode, y(isHeader ? "thead" : "tbody", {
    role: "presentation"
  }, typeof chunkConfig.rowContent === "function" ? chunkConfig.rowContent(arg) : chunkConfig.rowContent));
  return content;
}
function isColPropsEqual(cols0, cols1) {
  return isArraysEqual(cols0, cols1, isPropsEqual);
}
function renderMicroColGroup(cols, shrinkWidth) {
  let colNodes = [];
  for (let colProps of cols) {
    let span = colProps.span || 1;
    for (let i3 = 0; i3 < span; i3 += 1) {
      colNodes.push(y("col", { style: {
        width: colProps.width === "shrink" ? sanitizeShrinkWidth(shrinkWidth) : colProps.width || "",
        minWidth: colProps.minWidth || ""
      } }));
    }
  }
  return y("colgroup", {}, ...colNodes);
}
function sanitizeShrinkWidth(shrinkWidth) {
  return shrinkWidth == null ? 4 : shrinkWidth;
}
function hasShrinkWidth(cols) {
  for (let col of cols) {
    if (col.width === "shrink") {
      return true;
    }
  }
  return false;
}
function getScrollGridClassNames(liquid, context) {
  let classNames = [
    "fc-scrollgrid",
    context.theme.getClass("table")
  ];
  if (liquid) {
    classNames.push("fc-scrollgrid-liquid");
  }
  return classNames;
}
function getSectionClassNames(sectionConfig, wholeTableVGrow) {
  let classNames = [
    "fc-scrollgrid-section",
    `fc-scrollgrid-section-${sectionConfig.type}`,
    sectionConfig.className
    // used?
  ];
  if (wholeTableVGrow && sectionConfig.liquid && sectionConfig.maxHeight == null) {
    classNames.push("fc-scrollgrid-section-liquid");
  }
  if (sectionConfig.isSticky) {
    classNames.push("fc-scrollgrid-section-sticky");
  }
  return classNames;
}
function renderScrollShim(arg) {
  return y("div", { className: "fc-scrollgrid-sticky-shim", style: {
    width: arg.clientWidth,
    minWidth: arg.tableMinWidth
  } });
}
function getStickyHeaderDates(options) {
  let { stickyHeaderDates } = options;
  if (stickyHeaderDates == null || stickyHeaderDates === "auto") {
    stickyHeaderDates = options.height === "auto" || options.viewHeight === "auto";
  }
  return stickyHeaderDates;
}
function getStickyFooterScrollbar(options) {
  let { stickyFooterScrollbar } = options;
  if (stickyFooterScrollbar == null || stickyFooterScrollbar === "auto") {
    stickyFooterScrollbar = options.height === "auto" || options.viewHeight === "auto";
  }
  return stickyFooterScrollbar;
}
var SimpleScrollGrid = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.processCols = memoize((a3) => a3, isColPropsEqual);
    this.renderMicroColGroup = memoize(renderMicroColGroup);
    this.scrollerRefs = new RefMap();
    this.scrollerElRefs = new RefMap(this._handleScrollerEl.bind(this));
    this.state = {
      shrinkWidth: null,
      forceYScrollbars: false,
      scrollerClientWidths: {},
      scrollerClientHeights: {}
    };
    this.handleSizing = () => {
      this.safeSetState(Object.assign({ shrinkWidth: this.computeShrinkWidth() }, this.computeScrollerDims()));
    };
  }
  render() {
    let { props, state, context } = this;
    let sectionConfigs = props.sections || [];
    let cols = this.processCols(props.cols);
    let microColGroupNode = this.renderMicroColGroup(cols, state.shrinkWidth);
    let classNames = getScrollGridClassNames(props.liquid, context);
    if (props.collapsibleWidth) {
      classNames.push("fc-scrollgrid-collapsible");
    }
    let configCnt = sectionConfigs.length;
    let configI = 0;
    let currentConfig;
    let headSectionNodes = [];
    let bodySectionNodes = [];
    let footSectionNodes = [];
    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === "header") {
      headSectionNodes.push(this.renderSection(currentConfig, microColGroupNode, true));
      configI += 1;
    }
    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === "body") {
      bodySectionNodes.push(this.renderSection(currentConfig, microColGroupNode, false));
      configI += 1;
    }
    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === "footer") {
      footSectionNodes.push(this.renderSection(currentConfig, microColGroupNode, true));
      configI += 1;
    }
    let isBuggy = !getCanVGrowWithinCell();
    const roleAttrs = { role: "rowgroup" };
    return y("table", {
      role: "grid",
      className: classNames.join(" "),
      style: { height: props.height }
    }, Boolean(!isBuggy && headSectionNodes.length) && y("thead", roleAttrs, ...headSectionNodes), Boolean(!isBuggy && bodySectionNodes.length) && y("tbody", roleAttrs, ...bodySectionNodes), Boolean(!isBuggy && footSectionNodes.length) && y("tfoot", roleAttrs, ...footSectionNodes), isBuggy && y("tbody", roleAttrs, ...headSectionNodes, ...bodySectionNodes, ...footSectionNodes));
  }
  renderSection(sectionConfig, microColGroupNode, isHeader) {
    if ("outerContent" in sectionConfig) {
      return y(_, { key: sectionConfig.key }, sectionConfig.outerContent);
    }
    return y("tr", { key: sectionConfig.key, role: "presentation", className: getSectionClassNames(sectionConfig, this.props.liquid).join(" ") }, this.renderChunkTd(sectionConfig, microColGroupNode, sectionConfig.chunk, isHeader));
  }
  renderChunkTd(sectionConfig, microColGroupNode, chunkConfig, isHeader) {
    if ("outerContent" in chunkConfig) {
      return chunkConfig.outerContent;
    }
    let { props } = this;
    let { forceYScrollbars, scrollerClientWidths, scrollerClientHeights } = this.state;
    let needsYScrolling = getAllowYScrolling(props, sectionConfig);
    let isLiquid = getSectionHasLiquidHeight(props, sectionConfig);
    let overflowY = !props.liquid ? "visible" : forceYScrollbars ? "scroll" : !needsYScrolling ? "hidden" : "auto";
    let sectionKey = sectionConfig.key;
    let content = renderChunkContent(sectionConfig, chunkConfig, {
      tableColGroupNode: microColGroupNode,
      tableMinWidth: "",
      clientWidth: !props.collapsibleWidth && scrollerClientWidths[sectionKey] !== void 0 ? scrollerClientWidths[sectionKey] : null,
      clientHeight: scrollerClientHeights[sectionKey] !== void 0 ? scrollerClientHeights[sectionKey] : null,
      expandRows: sectionConfig.expandRows,
      syncRowHeights: false,
      rowSyncHeights: [],
      reportRowHeightChange: () => {
      }
    }, isHeader);
    return y(isHeader ? "th" : "td", {
      ref: chunkConfig.elRef,
      role: "presentation"
    }, y(
      "div",
      { className: `fc-scroller-harness${isLiquid ? " fc-scroller-harness-liquid" : ""}` },
      y(Scroller, { ref: this.scrollerRefs.createRef(sectionKey), elRef: this.scrollerElRefs.createRef(sectionKey), overflowY, overflowX: !props.liquid ? "visible" : "hidden", maxHeight: sectionConfig.maxHeight, liquid: isLiquid, liquidIsAbsolute: true }, content)
    ));
  }
  _handleScrollerEl(scrollerEl, key) {
    let section = getSectionByKey(this.props.sections, key);
    if (section) {
      setRef(section.chunk.scrollerElRef, scrollerEl);
    }
  }
  componentDidMount() {
    this.handleSizing();
    this.context.addResizeHandler(this.handleSizing);
  }
  componentDidUpdate() {
    this.handleSizing();
  }
  componentWillUnmount() {
    this.context.removeResizeHandler(this.handleSizing);
  }
  computeShrinkWidth() {
    return hasShrinkWidth(this.props.cols) ? computeShrinkWidth(this.scrollerElRefs.getAll()) : 0;
  }
  computeScrollerDims() {
    let scrollbarWidth = getScrollbarWidths();
    let { scrollerRefs, scrollerElRefs } = this;
    let forceYScrollbars = false;
    let scrollerClientWidths = {};
    let scrollerClientHeights = {};
    for (let sectionKey in scrollerRefs.currentMap) {
      let scroller = scrollerRefs.currentMap[sectionKey];
      if (scroller && scroller.needsYScrolling()) {
        forceYScrollbars = true;
        break;
      }
    }
    for (let section of this.props.sections) {
      let sectionKey = section.key;
      let scrollerEl = scrollerElRefs.currentMap[sectionKey];
      if (scrollerEl) {
        let harnessEl = scrollerEl.parentNode;
        scrollerClientWidths[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().width - (forceYScrollbars ? scrollbarWidth.y : 0));
        scrollerClientHeights[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().height);
      }
    }
    return { forceYScrollbars, scrollerClientWidths, scrollerClientHeights };
  }
};
SimpleScrollGrid.addStateEquality({
  scrollerClientWidths: isPropsEqual,
  scrollerClientHeights: isPropsEqual
});
function getSectionByKey(sections, key) {
  for (let section of sections) {
    if (section.key === key) {
      return section;
    }
  }
  return null;
}
var EventContainer = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.handleEl = (el) => {
      this.el = el;
      if (el) {
        setElSeg(el, this.props.seg);
      }
    };
  }
  render() {
    const { props, context } = this;
    const { options } = context;
    const { seg } = props;
    const { eventRange } = seg;
    const { ui } = eventRange;
    const renderProps = {
      event: new EventImpl(context, eventRange.def, eventRange.instance),
      view: context.viewApi,
      timeText: props.timeText,
      textColor: ui.textColor,
      backgroundColor: ui.backgroundColor,
      borderColor: ui.borderColor,
      isDraggable: !props.disableDragging && computeSegDraggable(seg, context),
      isStartResizable: !props.disableResizing && computeSegStartResizable(seg, context),
      isEndResizable: !props.disableResizing && computeSegEndResizable(seg),
      isMirror: Boolean(props.isDragging || props.isResizing || props.isDateSelecting),
      isStart: Boolean(seg.isStart),
      isEnd: Boolean(seg.isEnd),
      isPast: Boolean(props.isPast),
      isFuture: Boolean(props.isFuture),
      isToday: Boolean(props.isToday),
      isSelected: Boolean(props.isSelected),
      isDragging: Boolean(props.isDragging),
      isResizing: Boolean(props.isResizing)
    };
    return y(ContentContainer, Object.assign({}, props, { elRef: this.handleEl, elClasses: [
      ...getEventClassNames(renderProps),
      ...seg.eventRange.ui.classNames,
      ...props.elClasses || []
    ], renderProps, generatorName: "eventContent", customGenerator: options.eventContent, defaultGenerator: props.defaultGenerator, classNameGenerator: options.eventClassNames, didMount: options.eventDidMount, willUnmount: options.eventWillUnmount }));
  }
  componentDidUpdate(prevProps) {
    if (this.el && this.props.seg !== prevProps.seg) {
      setElSeg(this.el, this.props.seg);
    }
  }
};
var StandardEvent = class extends BaseComponent {
  render() {
    let { props, context } = this;
    let { options } = context;
    let { seg } = props;
    let { ui } = seg.eventRange;
    let timeFormat = options.eventTimeFormat || props.defaultTimeFormat;
    let timeText = buildSegTimeText(seg, timeFormat, context, props.defaultDisplayEventTime, props.defaultDisplayEventEnd);
    return y(EventContainer, Object.assign({}, props, { elTag: "a", elStyle: {
      borderColor: ui.borderColor,
      backgroundColor: ui.backgroundColor
    }, elAttrs: getSegAnchorAttrs(seg, context), defaultGenerator: renderInnerContent$1, timeText }), (InnerContent, eventContentArg) => y(
      _,
      null,
      y(InnerContent, { elTag: "div", elClasses: ["fc-event-main"], elStyle: { color: eventContentArg.textColor } }),
      Boolean(eventContentArg.isStartResizable) && y("div", { className: "fc-event-resizer fc-event-resizer-start" }),
      Boolean(eventContentArg.isEndResizable) && y("div", { className: "fc-event-resizer fc-event-resizer-end" })
    ));
  }
};
function renderInnerContent$1(innerProps) {
  return y(
    "div",
    { className: "fc-event-main-frame" },
    innerProps.timeText && y("div", { className: "fc-event-time" }, innerProps.timeText),
    y(
      "div",
      { className: "fc-event-title-container" },
      y("div", { className: "fc-event-title fc-sticky" }, innerProps.event.title || y(_, null, "\xA0"))
    )
  );
}
var NowIndicatorContainer = (props) => y(ViewContextType.Consumer, null, (context) => {
  let { options } = context;
  let renderProps = {
    isAxis: props.isAxis,
    date: context.dateEnv.toDate(props.date),
    view: context.viewApi
  };
  return y(ContentContainer, Object.assign({}, props, { elTag: props.elTag || "div", renderProps, generatorName: "nowIndicatorContent", customGenerator: options.nowIndicatorContent, classNameGenerator: options.nowIndicatorClassNames, didMount: options.nowIndicatorDidMount, willUnmount: options.nowIndicatorWillUnmount }));
});
var DAY_NUM_FORMAT = createFormatter({ day: "numeric" });
var DayCellContainer = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.refineRenderProps = memoizeObjArg(refineRenderProps);
  }
  render() {
    let { props, context } = this;
    let { options } = context;
    let renderProps = this.refineRenderProps({
      date: props.date,
      dateProfile: props.dateProfile,
      todayRange: props.todayRange,
      isMonthStart: props.isMonthStart || false,
      showDayNumber: props.showDayNumber,
      extraRenderProps: props.extraRenderProps,
      viewApi: context.viewApi,
      dateEnv: context.dateEnv,
      monthStartFormat: options.monthStartFormat
    });
    return y(ContentContainer, Object.assign({}, props, { elClasses: [
      ...getDayClassNames(renderProps, context.theme),
      ...props.elClasses || []
    ], elAttrs: Object.assign(Object.assign({}, props.elAttrs), renderProps.isDisabled ? {} : { "data-date": formatDayString(props.date) }), renderProps, generatorName: "dayCellContent", customGenerator: options.dayCellContent, defaultGenerator: props.defaultGenerator, classNameGenerator: (
      // don't use custom classNames if disabled
      renderProps.isDisabled ? void 0 : options.dayCellClassNames
    ), didMount: options.dayCellDidMount, willUnmount: options.dayCellWillUnmount }));
  }
};
function hasCustomDayCellContent(options) {
  return Boolean(options.dayCellContent || hasCustomRenderingHandler("dayCellContent", options));
}
function refineRenderProps(raw) {
  let { date, dateEnv, dateProfile, isMonthStart } = raw;
  let dayMeta = getDateMeta(date, raw.todayRange, null, dateProfile);
  let dayNumberText = raw.showDayNumber ? dateEnv.format(date, isMonthStart ? raw.monthStartFormat : DAY_NUM_FORMAT) : "";
  return Object.assign(Object.assign(Object.assign({ date: dateEnv.toDate(date), view: raw.viewApi }, dayMeta), {
    isMonthStart,
    dayNumberText
  }), raw.extraRenderProps);
}
var BgEvent = class extends BaseComponent {
  render() {
    let { props } = this;
    let { seg } = props;
    return y(EventContainer, { elTag: "div", elClasses: ["fc-bg-event"], elStyle: { backgroundColor: seg.eventRange.ui.backgroundColor }, defaultGenerator: renderInnerContent, seg, timeText: "", isDragging: false, isResizing: false, isDateSelecting: false, isSelected: false, isPast: props.isPast, isFuture: props.isFuture, isToday: props.isToday, disableDragging: true, disableResizing: true });
  }
};
function renderInnerContent(props) {
  let { title } = props.event;
  return title && y("div", { className: "fc-event-title" }, props.event.title);
}
function renderFill(fillType) {
  return y("div", { className: `fc-${fillType}` });
}
var WeekNumberContainer = (props) => y(ViewContextType.Consumer, null, (context) => {
  let { dateEnv, options } = context;
  let { date } = props;
  let format = options.weekNumberFormat || props.defaultFormat;
  let num = dateEnv.computeWeekNumber(date);
  let text = dateEnv.format(date, format);
  let renderProps = { num, text, date };
  return y(
    ContentContainer,
    Object.assign({}, props, { renderProps, generatorName: "weekNumberContent", customGenerator: options.weekNumberContent, defaultGenerator: renderInner, classNameGenerator: options.weekNumberClassNames, didMount: options.weekNumberDidMount, willUnmount: options.weekNumberWillUnmount })
  );
});
function renderInner(innerProps) {
  return innerProps.text;
}
var PADDING_FROM_VIEWPORT = 10;
var Popover = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.state = {
      titleId: getUniqueDomId()
    };
    this.handleRootEl = (el) => {
      this.rootEl = el;
      if (this.props.elRef) {
        setRef(this.props.elRef, el);
      }
    };
    this.handleDocumentMouseDown = (ev) => {
      const target = getEventTargetViaRoot(ev);
      if (!this.rootEl.contains(target)) {
        this.handleCloseClick();
      }
    };
    this.handleDocumentKeyDown = (ev) => {
      if (ev.key === "Escape") {
        this.handleCloseClick();
      }
    };
    this.handleCloseClick = () => {
      let { onClose } = this.props;
      if (onClose) {
        onClose();
      }
    };
  }
  render() {
    let { theme, options } = this.context;
    let { props, state } = this;
    let classNames = [
      "fc-popover",
      theme.getClass("popover")
    ].concat(props.extraClassNames || []);
    return j3(y(
      "div",
      Object.assign({}, props.extraAttrs, { id: props.id, className: classNames.join(" "), "aria-labelledby": state.titleId, ref: this.handleRootEl }),
      y(
        "div",
        { className: "fc-popover-header " + theme.getClass("popoverHeader") },
        y("span", { className: "fc-popover-title", id: state.titleId }, props.title),
        y("span", { className: "fc-popover-close " + theme.getIconClass("close"), title: options.closeHint, onClick: this.handleCloseClick })
      ),
      y("div", { className: "fc-popover-body " + theme.getClass("popoverContent") }, props.children)
    ), props.parentEl);
  }
  componentDidMount() {
    document.addEventListener("mousedown", this.handleDocumentMouseDown);
    document.addEventListener("keydown", this.handleDocumentKeyDown);
    this.updateSize();
  }
  componentWillUnmount() {
    document.removeEventListener("mousedown", this.handleDocumentMouseDown);
    document.removeEventListener("keydown", this.handleDocumentKeyDown);
  }
  updateSize() {
    let { isRtl } = this.context;
    let { alignmentEl, alignGridTop } = this.props;
    let { rootEl } = this;
    let alignmentRect = computeClippedClientRect(alignmentEl);
    if (alignmentRect) {
      let popoverDims = rootEl.getBoundingClientRect();
      let popoverTop = alignGridTop ? elementClosest(alignmentEl, ".fc-scrollgrid").getBoundingClientRect().top : alignmentRect.top;
      let popoverLeft = isRtl ? alignmentRect.right - popoverDims.width : alignmentRect.left;
      popoverTop = Math.max(popoverTop, PADDING_FROM_VIEWPORT);
      popoverLeft = Math.min(popoverLeft, document.documentElement.clientWidth - PADDING_FROM_VIEWPORT - popoverDims.width);
      popoverLeft = Math.max(popoverLeft, PADDING_FROM_VIEWPORT);
      let origin = rootEl.offsetParent.getBoundingClientRect();
      applyStyle(rootEl, {
        top: popoverTop - origin.top,
        left: popoverLeft - origin.left
      });
    }
  }
};
var MorePopover = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.handleRootEl = (rootEl) => {
      this.rootEl = rootEl;
      if (rootEl) {
        this.context.registerInteractiveComponent(this, {
          el: rootEl,
          useEventCenter: false
        });
      } else {
        this.context.unregisterInteractiveComponent(this);
      }
    };
  }
  render() {
    let { options, dateEnv } = this.context;
    let { props } = this;
    let { startDate, todayRange, dateProfile } = props;
    let title = dateEnv.format(startDate, options.dayPopoverFormat);
    return y(DayCellContainer, { elRef: this.handleRootEl, date: startDate, dateProfile, todayRange }, (InnerContent, renderProps, elAttrs) => y(
      Popover,
      { elRef: elAttrs.ref, id: props.id, title, extraClassNames: ["fc-more-popover"].concat(elAttrs.className || []), extraAttrs: elAttrs, parentEl: props.parentEl, alignmentEl: props.alignmentEl, alignGridTop: props.alignGridTop, onClose: props.onClose },
      hasCustomDayCellContent(options) && y(InnerContent, { elTag: "div", elClasses: ["fc-more-popover-misc"] }),
      props.children
    ));
  }
  queryHit(positionLeft, positionTop, elWidth, elHeight) {
    let { rootEl, props } = this;
    if (positionLeft >= 0 && positionLeft < elWidth && positionTop >= 0 && positionTop < elHeight) {
      return {
        dateProfile: props.dateProfile,
        dateSpan: Object.assign({ allDay: !props.forceTimed, range: {
          start: props.startDate,
          end: props.endDate
        } }, props.extraDateSpan),
        dayEl: rootEl,
        rect: {
          left: 0,
          top: 0,
          right: elWidth,
          bottom: elHeight
        },
        layer: 1
        // important when comparing with hits from other components
      };
    }
    return null;
  }
};
var MoreLinkContainer = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.state = {
      isPopoverOpen: false,
      popoverId: getUniqueDomId()
    };
    this.handleLinkEl = (linkEl) => {
      this.linkEl = linkEl;
      if (this.props.elRef) {
        setRef(this.props.elRef, linkEl);
      }
    };
    this.handleClick = (ev) => {
      let { props, context } = this;
      let { moreLinkClick } = context.options;
      let date = computeRange(props).start;
      function buildPublicSeg(seg) {
        let { def, instance, range: range2 } = seg.eventRange;
        return {
          event: new EventImpl(context, def, instance),
          start: context.dateEnv.toDate(range2.start),
          end: context.dateEnv.toDate(range2.end),
          isStart: seg.isStart,
          isEnd: seg.isEnd
        };
      }
      if (typeof moreLinkClick === "function") {
        moreLinkClick = moreLinkClick({
          date,
          allDay: Boolean(props.allDayDate),
          allSegs: props.allSegs.map(buildPublicSeg),
          hiddenSegs: props.hiddenSegs.map(buildPublicSeg),
          jsEvent: ev,
          view: context.viewApi
        });
      }
      if (!moreLinkClick || moreLinkClick === "popover") {
        this.setState({ isPopoverOpen: true });
      } else if (typeof moreLinkClick === "string") {
        context.calendarApi.zoomTo(date, moreLinkClick);
      }
    };
    this.handlePopoverClose = () => {
      this.setState({ isPopoverOpen: false });
    };
  }
  render() {
    let { props, state } = this;
    return y(ViewContextType.Consumer, null, (context) => {
      let { viewApi, options, calendarApi } = context;
      let { moreLinkText } = options;
      let { moreCnt } = props;
      let range2 = computeRange(props);
      let text = typeof moreLinkText === "function" ? moreLinkText.call(calendarApi, moreCnt) : `+${moreCnt} ${moreLinkText}`;
      let hint = formatWithOrdinals(options.moreLinkHint, [moreCnt], text);
      let renderProps = {
        num: moreCnt,
        shortText: `+${moreCnt}`,
        text,
        view: viewApi
      };
      return y(
        _,
        null,
        Boolean(props.moreCnt) && y(ContentContainer, { elTag: props.elTag || "a", elRef: this.handleLinkEl, elClasses: [
          ...props.elClasses || [],
          "fc-more-link"
        ], elStyle: props.elStyle, elAttrs: Object.assign(Object.assign(Object.assign({}, props.elAttrs), createAriaClickAttrs(this.handleClick)), { title: hint, "aria-expanded": state.isPopoverOpen, "aria-controls": state.isPopoverOpen ? state.popoverId : "" }), renderProps, generatorName: "moreLinkContent", customGenerator: options.moreLinkContent, defaultGenerator: props.defaultGenerator || renderMoreLinkInner, classNameGenerator: options.moreLinkClassNames, didMount: options.moreLinkDidMount, willUnmount: options.moreLinkWillUnmount }, props.children),
        state.isPopoverOpen && y(MorePopover, { id: state.popoverId, startDate: range2.start, endDate: range2.end, dateProfile: props.dateProfile, todayRange: props.todayRange, extraDateSpan: props.extraDateSpan, parentEl: this.parentEl, alignmentEl: props.alignmentElRef ? props.alignmentElRef.current : this.linkEl, alignGridTop: props.alignGridTop, forceTimed: props.forceTimed, onClose: this.handlePopoverClose }, props.popoverContent())
      );
    });
  }
  componentDidMount() {
    this.updateParentEl();
  }
  componentDidUpdate() {
    this.updateParentEl();
  }
  updateParentEl() {
    if (this.linkEl) {
      this.parentEl = elementClosest(this.linkEl, ".fc-view-harness");
    }
  }
};
function renderMoreLinkInner(props) {
  return props.text;
}
function computeRange(props) {
  if (props.allDayDate) {
    return {
      start: props.allDayDate,
      end: addDays(props.allDayDate, 1)
    };
  }
  let { hiddenSegs } = props;
  return {
    start: computeEarliestSegStart(hiddenSegs),
    end: computeLatestSegEnd(hiddenSegs)
  };
}
function computeEarliestSegStart(segs) {
  return segs.reduce(pickEarliestStart).eventRange.range.start;
}
function pickEarliestStart(seg0, seg1) {
  return seg0.eventRange.range.start < seg1.eventRange.range.start ? seg0 : seg1;
}
function computeLatestSegEnd(segs) {
  return segs.reduce(pickLatestEnd).eventRange.range.end;
}
function pickLatestEnd(seg0, seg1) {
  return seg0.eventRange.range.end > seg1.eventRange.range.end ? seg0 : seg1;
}

// node_modules/@fullcalendar/core/index.js
var globalLocales = [];
var MINIMAL_RAW_EN_LOCALE = {
  code: "en",
  week: {
    dow: 0,
    doy: 4
    // 4 days need to be within the year to be considered the first week
  },
  direction: "ltr",
  buttonText: {
    prev: "prev",
    next: "next",
    prevYear: "prev year",
    nextYear: "next year",
    year: "year",
    today: "today",
    month: "month",
    week: "week",
    day: "day",
    list: "list"
  },
  weekText: "W",
  weekTextLong: "Week",
  closeHint: "Close",
  timeHint: "Time",
  eventHint: "Event",
  allDayText: "all-day",
  moreLinkText: "more",
  noEventsText: "No events to display"
};
var RAW_EN_LOCALE = Object.assign(Object.assign({}, MINIMAL_RAW_EN_LOCALE), {
  // Includes things we don't want other locales to inherit,
  // things that derive from other translatable strings.
  buttonHints: {
    prev: "Previous $0",
    next: "Next $0",
    today(buttonText, unit) {
      return unit === "day" ? "Today" : `This ${buttonText}`;
    }
  },
  viewHint: "$0 view",
  navLinkHint: "Go to $0",
  moreLinkHint(eventCnt) {
    return `Show ${eventCnt} more event${eventCnt === 1 ? "" : "s"}`;
  }
});
function organizeRawLocales(explicitRawLocales) {
  let defaultCode = explicitRawLocales.length > 0 ? explicitRawLocales[0].code : "en";
  let allRawLocales = globalLocales.concat(explicitRawLocales);
  let rawLocaleMap = {
    en: RAW_EN_LOCALE
  };
  for (let rawLocale of allRawLocales) {
    rawLocaleMap[rawLocale.code] = rawLocale;
  }
  return {
    map: rawLocaleMap,
    defaultCode
  };
}
function buildLocale(inputSingular, available) {
  if (typeof inputSingular === "object" && !Array.isArray(inputSingular)) {
    return parseLocale(inputSingular.code, [inputSingular.code], inputSingular);
  }
  return queryLocale(inputSingular, available);
}
function queryLocale(codeArg, available) {
  let codes = [].concat(codeArg || []);
  let raw = queryRawLocale(codes, available) || RAW_EN_LOCALE;
  return parseLocale(codeArg, codes, raw);
}
function queryRawLocale(codes, available) {
  for (let i3 = 0; i3 < codes.length; i3 += 1) {
    let parts = codes[i3].toLocaleLowerCase().split("-");
    for (let j4 = parts.length; j4 > 0; j4 -= 1) {
      let simpleId = parts.slice(0, j4).join("-");
      if (available[simpleId]) {
        return available[simpleId];
      }
    }
  }
  return null;
}
function parseLocale(codeArg, codes, raw) {
  let merged = mergeProps([MINIMAL_RAW_EN_LOCALE, raw], ["buttonText"]);
  delete merged.code;
  let { week } = merged;
  delete merged.week;
  return {
    codeArg,
    codes,
    week,
    simpleNumberFormat: new Intl.NumberFormat(codeArg),
    options: merged
  };
}
function createPlugin(input) {
  return {
    id: guid(),
    name: input.name,
    premiumReleaseDate: input.premiumReleaseDate ? new Date(input.premiumReleaseDate) : void 0,
    deps: input.deps || [],
    reducers: input.reducers || [],
    isLoadingFuncs: input.isLoadingFuncs || [],
    contextInit: [].concat(input.contextInit || []),
    eventRefiners: input.eventRefiners || {},
    eventDefMemberAdders: input.eventDefMemberAdders || [],
    eventSourceRefiners: input.eventSourceRefiners || {},
    isDraggableTransformers: input.isDraggableTransformers || [],
    eventDragMutationMassagers: input.eventDragMutationMassagers || [],
    eventDefMutationAppliers: input.eventDefMutationAppliers || [],
    dateSelectionTransformers: input.dateSelectionTransformers || [],
    datePointTransforms: input.datePointTransforms || [],
    dateSpanTransforms: input.dateSpanTransforms || [],
    views: input.views || {},
    viewPropsTransformers: input.viewPropsTransformers || [],
    isPropsValid: input.isPropsValid || null,
    externalDefTransforms: input.externalDefTransforms || [],
    viewContainerAppends: input.viewContainerAppends || [],
    eventDropTransformers: input.eventDropTransformers || [],
    componentInteractions: input.componentInteractions || [],
    calendarInteractions: input.calendarInteractions || [],
    themeClasses: input.themeClasses || {},
    eventSourceDefs: input.eventSourceDefs || [],
    cmdFormatter: input.cmdFormatter,
    recurringTypes: input.recurringTypes || [],
    namedTimeZonedImpl: input.namedTimeZonedImpl,
    initialView: input.initialView || "",
    elementDraggingImpl: input.elementDraggingImpl,
    optionChangeHandlers: input.optionChangeHandlers || {},
    scrollGridImpl: input.scrollGridImpl || null,
    listenerRefiners: input.listenerRefiners || {},
    optionRefiners: input.optionRefiners || {},
    propSetHandlers: input.propSetHandlers || {}
  };
}
function buildPluginHooks(pluginDefs, globalDefs) {
  let currentPluginIds = {};
  let hooks = {
    premiumReleaseDate: void 0,
    reducers: [],
    isLoadingFuncs: [],
    contextInit: [],
    eventRefiners: {},
    eventDefMemberAdders: [],
    eventSourceRefiners: {},
    isDraggableTransformers: [],
    eventDragMutationMassagers: [],
    eventDefMutationAppliers: [],
    dateSelectionTransformers: [],
    datePointTransforms: [],
    dateSpanTransforms: [],
    views: {},
    viewPropsTransformers: [],
    isPropsValid: null,
    externalDefTransforms: [],
    viewContainerAppends: [],
    eventDropTransformers: [],
    componentInteractions: [],
    calendarInteractions: [],
    themeClasses: {},
    eventSourceDefs: [],
    cmdFormatter: null,
    recurringTypes: [],
    namedTimeZonedImpl: null,
    initialView: "",
    elementDraggingImpl: null,
    optionChangeHandlers: {},
    scrollGridImpl: null,
    listenerRefiners: {},
    optionRefiners: {},
    propSetHandlers: {}
  };
  function addDefs(defs) {
    for (let def of defs) {
      const pluginName = def.name;
      const currentId = currentPluginIds[pluginName];
      if (currentId === void 0) {
        currentPluginIds[pluginName] = def.id;
        addDefs(def.deps);
        hooks = combineHooks(hooks, def);
      } else if (currentId !== def.id) {
        console.warn(`Duplicate plugin '${pluginName}'`);
      }
    }
  }
  if (pluginDefs) {
    addDefs(pluginDefs);
  }
  addDefs(globalDefs);
  return hooks;
}
function buildBuildPluginHooks() {
  let currentOverrideDefs = [];
  let currentGlobalDefs = [];
  let currentHooks;
  return (overrideDefs, globalDefs) => {
    if (!currentHooks || !isArraysEqual(overrideDefs, currentOverrideDefs) || !isArraysEqual(globalDefs, currentGlobalDefs)) {
      currentHooks = buildPluginHooks(overrideDefs, globalDefs);
    }
    currentOverrideDefs = overrideDefs;
    currentGlobalDefs = globalDefs;
    return currentHooks;
  };
}
function combineHooks(hooks0, hooks1) {
  return {
    premiumReleaseDate: compareOptionalDates(hooks0.premiumReleaseDate, hooks1.premiumReleaseDate),
    reducers: hooks0.reducers.concat(hooks1.reducers),
    isLoadingFuncs: hooks0.isLoadingFuncs.concat(hooks1.isLoadingFuncs),
    contextInit: hooks0.contextInit.concat(hooks1.contextInit),
    eventRefiners: Object.assign(Object.assign({}, hooks0.eventRefiners), hooks1.eventRefiners),
    eventDefMemberAdders: hooks0.eventDefMemberAdders.concat(hooks1.eventDefMemberAdders),
    eventSourceRefiners: Object.assign(Object.assign({}, hooks0.eventSourceRefiners), hooks1.eventSourceRefiners),
    isDraggableTransformers: hooks0.isDraggableTransformers.concat(hooks1.isDraggableTransformers),
    eventDragMutationMassagers: hooks0.eventDragMutationMassagers.concat(hooks1.eventDragMutationMassagers),
    eventDefMutationAppliers: hooks0.eventDefMutationAppliers.concat(hooks1.eventDefMutationAppliers),
    dateSelectionTransformers: hooks0.dateSelectionTransformers.concat(hooks1.dateSelectionTransformers),
    datePointTransforms: hooks0.datePointTransforms.concat(hooks1.datePointTransforms),
    dateSpanTransforms: hooks0.dateSpanTransforms.concat(hooks1.dateSpanTransforms),
    views: Object.assign(Object.assign({}, hooks0.views), hooks1.views),
    viewPropsTransformers: hooks0.viewPropsTransformers.concat(hooks1.viewPropsTransformers),
    isPropsValid: hooks1.isPropsValid || hooks0.isPropsValid,
    externalDefTransforms: hooks0.externalDefTransforms.concat(hooks1.externalDefTransforms),
    viewContainerAppends: hooks0.viewContainerAppends.concat(hooks1.viewContainerAppends),
    eventDropTransformers: hooks0.eventDropTransformers.concat(hooks1.eventDropTransformers),
    calendarInteractions: hooks0.calendarInteractions.concat(hooks1.calendarInteractions),
    componentInteractions: hooks0.componentInteractions.concat(hooks1.componentInteractions),
    themeClasses: Object.assign(Object.assign({}, hooks0.themeClasses), hooks1.themeClasses),
    eventSourceDefs: hooks0.eventSourceDefs.concat(hooks1.eventSourceDefs),
    cmdFormatter: hooks1.cmdFormatter || hooks0.cmdFormatter,
    recurringTypes: hooks0.recurringTypes.concat(hooks1.recurringTypes),
    namedTimeZonedImpl: hooks1.namedTimeZonedImpl || hooks0.namedTimeZonedImpl,
    initialView: hooks0.initialView || hooks1.initialView,
    elementDraggingImpl: hooks0.elementDraggingImpl || hooks1.elementDraggingImpl,
    optionChangeHandlers: Object.assign(Object.assign({}, hooks0.optionChangeHandlers), hooks1.optionChangeHandlers),
    scrollGridImpl: hooks1.scrollGridImpl || hooks0.scrollGridImpl,
    listenerRefiners: Object.assign(Object.assign({}, hooks0.listenerRefiners), hooks1.listenerRefiners),
    optionRefiners: Object.assign(Object.assign({}, hooks0.optionRefiners), hooks1.optionRefiners),
    propSetHandlers: Object.assign(Object.assign({}, hooks0.propSetHandlers), hooks1.propSetHandlers)
  };
}
function compareOptionalDates(date0, date1) {
  if (date0 === void 0) {
    return date1;
  }
  if (date1 === void 0) {
    return date0;
  }
  return new Date(Math.max(date0.valueOf(), date1.valueOf()));
}
var StandardTheme = class extends Theme {
};
StandardTheme.prototype.classes = {
  root: "fc-theme-standard",
  tableCellShaded: "fc-cell-shaded",
  buttonGroup: "fc-button-group",
  button: "fc-button fc-button-primary",
  buttonActive: "fc-button-active"
};
StandardTheme.prototype.baseIconClass = "fc-icon";
StandardTheme.prototype.iconClasses = {
  close: "fc-icon-x",
  prev: "fc-icon-chevron-left",
  next: "fc-icon-chevron-right",
  prevYear: "fc-icon-chevrons-left",
  nextYear: "fc-icon-chevrons-right"
};
StandardTheme.prototype.rtlIconClasses = {
  prev: "fc-icon-chevron-right",
  next: "fc-icon-chevron-left",
  prevYear: "fc-icon-chevrons-right",
  nextYear: "fc-icon-chevrons-left"
};
StandardTheme.prototype.iconOverrideOption = "buttonIcons";
StandardTheme.prototype.iconOverrideCustomButtonOption = "icon";
StandardTheme.prototype.iconOverridePrefix = "fc-icon-";
function compileViewDefs(defaultConfigs, overrideConfigs) {
  let hash = {};
  let viewType;
  for (viewType in defaultConfigs) {
    ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);
  }
  for (viewType in overrideConfigs) {
    ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);
  }
  return hash;
}
function ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs) {
  if (hash[viewType]) {
    return hash[viewType];
  }
  let viewDef = buildViewDef(viewType, hash, defaultConfigs, overrideConfigs);
  if (viewDef) {
    hash[viewType] = viewDef;
  }
  return viewDef;
}
function buildViewDef(viewType, hash, defaultConfigs, overrideConfigs) {
  let defaultConfig = defaultConfigs[viewType];
  let overrideConfig = overrideConfigs[viewType];
  let queryProp = (name) => defaultConfig && defaultConfig[name] !== null ? defaultConfig[name] : overrideConfig && overrideConfig[name] !== null ? overrideConfig[name] : null;
  let theComponent = queryProp("component");
  let superType = queryProp("superType");
  let superDef = null;
  if (superType) {
    if (superType === viewType) {
      throw new Error("Can't have a custom view type that references itself");
    }
    superDef = ensureViewDef(superType, hash, defaultConfigs, overrideConfigs);
  }
  if (!theComponent && superDef) {
    theComponent = superDef.component;
  }
  if (!theComponent) {
    return null;
  }
  return {
    type: viewType,
    component: theComponent,
    defaults: Object.assign(Object.assign({}, superDef ? superDef.defaults : {}), defaultConfig ? defaultConfig.rawOptions : {}),
    overrides: Object.assign(Object.assign({}, superDef ? superDef.overrides : {}), overrideConfig ? overrideConfig.rawOptions : {})
  };
}
function parseViewConfigs(inputs) {
  return mapHash(inputs, parseViewConfig);
}
function parseViewConfig(input) {
  let rawOptions = typeof input === "function" ? { component: input } : input;
  let { component } = rawOptions;
  if (rawOptions.content) {
    component = createViewHookComponent(rawOptions);
  } else if (component && !(component.prototype instanceof BaseComponent)) {
    component = createViewHookComponent(Object.assign(Object.assign({}, rawOptions), { content: component }));
  }
  return {
    superType: rawOptions.type,
    component,
    rawOptions
    // includes type and component too :(
  };
}
function createViewHookComponent(options) {
  return (viewProps) => y(ViewContextType.Consumer, null, (context) => y(ContentContainer, { elTag: "div", elClasses: buildViewClassNames(context.viewSpec), renderProps: Object.assign(Object.assign({}, viewProps), { nextDayThreshold: context.options.nextDayThreshold }), generatorName: void 0, customGenerator: options.content, classNameGenerator: options.classNames, didMount: options.didMount, willUnmount: options.willUnmount }));
}
function buildViewSpecs(defaultInputs, optionOverrides, dynamicOptionOverrides, localeDefaults) {
  let defaultConfigs = parseViewConfigs(defaultInputs);
  let overrideConfigs = parseViewConfigs(optionOverrides.views);
  let viewDefs = compileViewDefs(defaultConfigs, overrideConfigs);
  return mapHash(viewDefs, (viewDef) => buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults));
}
function buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults) {
  let durationInput = viewDef.overrides.duration || viewDef.defaults.duration || dynamicOptionOverrides.duration || optionOverrides.duration;
  let duration = null;
  let durationUnit = "";
  let singleUnit = "";
  let singleUnitOverrides = {};
  if (durationInput) {
    duration = createDurationCached(durationInput);
    if (duration) {
      let denom = greatestDurationDenominator(duration);
      durationUnit = denom.unit;
      if (denom.value === 1) {
        singleUnit = durationUnit;
        singleUnitOverrides = overrideConfigs[durationUnit] ? overrideConfigs[durationUnit].rawOptions : {};
      }
    }
  }
  let queryButtonText = (optionsSubset) => {
    let buttonTextMap = optionsSubset.buttonText || {};
    let buttonTextKey = viewDef.defaults.buttonTextKey;
    if (buttonTextKey != null && buttonTextMap[buttonTextKey] != null) {
      return buttonTextMap[buttonTextKey];
    }
    if (buttonTextMap[viewDef.type] != null) {
      return buttonTextMap[viewDef.type];
    }
    if (buttonTextMap[singleUnit] != null) {
      return buttonTextMap[singleUnit];
    }
    return null;
  };
  let queryButtonTitle = (optionsSubset) => {
    let buttonHints = optionsSubset.buttonHints || {};
    let buttonKey = viewDef.defaults.buttonTextKey;
    if (buttonKey != null && buttonHints[buttonKey] != null) {
      return buttonHints[buttonKey];
    }
    if (buttonHints[viewDef.type] != null) {
      return buttonHints[viewDef.type];
    }
    if (buttonHints[singleUnit] != null) {
      return buttonHints[singleUnit];
    }
    return null;
  };
  return {
    type: viewDef.type,
    component: viewDef.component,
    duration,
    durationUnit,
    singleUnit,
    optionDefaults: viewDef.defaults,
    optionOverrides: Object.assign(Object.assign({}, singleUnitOverrides), viewDef.overrides),
    buttonTextOverride: queryButtonText(dynamicOptionOverrides) || queryButtonText(optionOverrides) || // constructor-specified buttonText lookup hash takes precedence
    viewDef.overrides.buttonText,
    buttonTextDefault: queryButtonText(localeDefaults) || viewDef.defaults.buttonText || queryButtonText(BASE_OPTION_DEFAULTS) || viewDef.type,
    // not DRY
    buttonTitleOverride: queryButtonTitle(dynamicOptionOverrides) || queryButtonTitle(optionOverrides) || viewDef.overrides.buttonHint,
    buttonTitleDefault: queryButtonTitle(localeDefaults) || viewDef.defaults.buttonHint || queryButtonTitle(BASE_OPTION_DEFAULTS)
    // will eventually fall back to buttonText
  };
}
var durationInputMap = {};
function createDurationCached(durationInput) {
  let json = JSON.stringify(durationInput);
  let res = durationInputMap[json];
  if (res === void 0) {
    res = createDuration(durationInput);
    durationInputMap[json] = res;
  }
  return res;
}
function reduceViewType(viewType, action) {
  switch (action.type) {
    case "CHANGE_VIEW_TYPE":
      viewType = action.viewType;
  }
  return viewType;
}
function reduceDynamicOptionOverrides(dynamicOptionOverrides, action) {
  switch (action.type) {
    case "SET_OPTION":
      return Object.assign(Object.assign({}, dynamicOptionOverrides), { [action.optionName]: action.rawOptionValue });
    default:
      return dynamicOptionOverrides;
  }
}
function reduceDateProfile(currentDateProfile, action, currentDate, dateProfileGenerator) {
  let dp;
  switch (action.type) {
    case "CHANGE_VIEW_TYPE":
      return dateProfileGenerator.build(action.dateMarker || currentDate);
    case "CHANGE_DATE":
      return dateProfileGenerator.build(action.dateMarker);
    case "PREV":
      dp = dateProfileGenerator.buildPrev(currentDateProfile, currentDate);
      if (dp.isValid) {
        return dp;
      }
      break;
    case "NEXT":
      dp = dateProfileGenerator.buildNext(currentDateProfile, currentDate);
      if (dp.isValid) {
        return dp;
      }
      break;
  }
  return currentDateProfile;
}
function initEventSources(calendarOptions, dateProfile, context) {
  let activeRange = dateProfile ? dateProfile.activeRange : null;
  return addSources({}, parseInitialSources(calendarOptions, context), activeRange, context);
}
function reduceEventSources(eventSources, action, dateProfile, context) {
  let activeRange = dateProfile ? dateProfile.activeRange : null;
  switch (action.type) {
    case "ADD_EVENT_SOURCES":
      return addSources(eventSources, action.sources, activeRange, context);
    case "REMOVE_EVENT_SOURCE":
      return removeSource(eventSources, action.sourceId);
    case "PREV":
    case "NEXT":
    case "CHANGE_DATE":
    case "CHANGE_VIEW_TYPE":
      if (dateProfile) {
        return fetchDirtySources(eventSources, activeRange, context);
      }
      return eventSources;
    case "FETCH_EVENT_SOURCES":
      return fetchSourcesByIds(eventSources, action.sourceIds ? (
        // why no type?
        arrayToHash(action.sourceIds)
      ) : excludeStaticSources(eventSources, context), activeRange, action.isRefetch || false, context);
    case "RECEIVE_EVENTS":
    case "RECEIVE_EVENT_ERROR":
      return receiveResponse(eventSources, action.sourceId, action.fetchId, action.fetchRange);
    case "REMOVE_ALL_EVENT_SOURCES":
      return {};
    default:
      return eventSources;
  }
}
function reduceEventSourcesNewTimeZone(eventSources, dateProfile, context) {
  let activeRange = dateProfile ? dateProfile.activeRange : null;
  return fetchSourcesByIds(eventSources, excludeStaticSources(eventSources, context), activeRange, true, context);
}
function computeEventSourcesLoading(eventSources) {
  for (let sourceId in eventSources) {
    if (eventSources[sourceId].isFetching) {
      return true;
    }
  }
  return false;
}
function addSources(eventSourceHash, sources, fetchRange, context) {
  let hash = {};
  for (let source of sources) {
    hash[source.sourceId] = source;
  }
  if (fetchRange) {
    hash = fetchDirtySources(hash, fetchRange, context);
  }
  return Object.assign(Object.assign({}, eventSourceHash), hash);
}
function removeSource(eventSourceHash, sourceId) {
  return filterHash(eventSourceHash, (eventSource) => eventSource.sourceId !== sourceId);
}
function fetchDirtySources(sourceHash, fetchRange, context) {
  return fetchSourcesByIds(sourceHash, filterHash(sourceHash, (eventSource) => isSourceDirty(eventSource, fetchRange, context)), fetchRange, false, context);
}
function isSourceDirty(eventSource, fetchRange, context) {
  if (!doesSourceNeedRange(eventSource, context)) {
    return !eventSource.latestFetchId;
  }
  return !context.options.lazyFetching || !eventSource.fetchRange || eventSource.isFetching || // always cancel outdated in-progress fetches
  fetchRange.start < eventSource.fetchRange.start || fetchRange.end > eventSource.fetchRange.end;
}
function fetchSourcesByIds(prevSources, sourceIdHash, fetchRange, isRefetch, context) {
  let nextSources = {};
  for (let sourceId in prevSources) {
    let source = prevSources[sourceId];
    if (sourceIdHash[sourceId]) {
      nextSources[sourceId] = fetchSource(source, fetchRange, isRefetch, context);
    } else {
      nextSources[sourceId] = source;
    }
  }
  return nextSources;
}
function fetchSource(eventSource, fetchRange, isRefetch, context) {
  let { options, calendarApi } = context;
  let sourceDef = context.pluginHooks.eventSourceDefs[eventSource.sourceDefId];
  let fetchId = guid();
  sourceDef.fetch({
    eventSource,
    range: fetchRange,
    isRefetch,
    context
  }, (res) => {
    let { rawEvents } = res;
    if (options.eventSourceSuccess) {
      rawEvents = options.eventSourceSuccess.call(calendarApi, rawEvents, res.response) || rawEvents;
    }
    if (eventSource.success) {
      rawEvents = eventSource.success.call(calendarApi, rawEvents, res.response) || rawEvents;
    }
    context.dispatch({
      type: "RECEIVE_EVENTS",
      sourceId: eventSource.sourceId,
      fetchId,
      fetchRange,
      rawEvents
    });
  }, (error) => {
    let errorHandled = false;
    if (options.eventSourceFailure) {
      options.eventSourceFailure.call(calendarApi, error);
      errorHandled = true;
    }
    if (eventSource.failure) {
      eventSource.failure(error);
      errorHandled = true;
    }
    if (!errorHandled) {
      console.warn(error.message, error);
    }
    context.dispatch({
      type: "RECEIVE_EVENT_ERROR",
      sourceId: eventSource.sourceId,
      fetchId,
      fetchRange,
      error
    });
  });
  return Object.assign(Object.assign({}, eventSource), { isFetching: true, latestFetchId: fetchId });
}
function receiveResponse(sourceHash, sourceId, fetchId, fetchRange) {
  let eventSource = sourceHash[sourceId];
  if (eventSource && // not already removed
  fetchId === eventSource.latestFetchId) {
    return Object.assign(Object.assign({}, sourceHash), { [sourceId]: Object.assign(Object.assign({}, eventSource), { isFetching: false, fetchRange }) });
  }
  return sourceHash;
}
function excludeStaticSources(eventSources, context) {
  return filterHash(eventSources, (eventSource) => doesSourceNeedRange(eventSource, context));
}
function parseInitialSources(rawOptions, context) {
  let refiners = buildEventSourceRefiners(context);
  let rawSources = [].concat(rawOptions.eventSources || []);
  let sources = [];
  if (rawOptions.initialEvents) {
    rawSources.unshift(rawOptions.initialEvents);
  }
  if (rawOptions.events) {
    rawSources.unshift(rawOptions.events);
  }
  for (let rawSource of rawSources) {
    let source = parseEventSource(rawSource, context, refiners);
    if (source) {
      sources.push(source);
    }
  }
  return sources;
}
function doesSourceNeedRange(eventSource, context) {
  let defs = context.pluginHooks.eventSourceDefs;
  return !defs[eventSource.sourceDefId].ignoreRange;
}
function reduceDateSelection(currentSelection, action) {
  switch (action.type) {
    case "UNSELECT_DATES":
      return null;
    case "SELECT_DATES":
      return action.selection;
    default:
      return currentSelection;
  }
}
function reduceSelectedEvent(currentInstanceId, action) {
  switch (action.type) {
    case "UNSELECT_EVENT":
      return "";
    case "SELECT_EVENT":
      return action.eventInstanceId;
    default:
      return currentInstanceId;
  }
}
function reduceEventDrag(currentDrag, action) {
  let newDrag;
  switch (action.type) {
    case "UNSET_EVENT_DRAG":
      return null;
    case "SET_EVENT_DRAG":
      newDrag = action.state;
      return {
        affectedEvents: newDrag.affectedEvents,
        mutatedEvents: newDrag.mutatedEvents,
        isEvent: newDrag.isEvent
      };
    default:
      return currentDrag;
  }
}
function reduceEventResize(currentResize, action) {
  let newResize;
  switch (action.type) {
    case "UNSET_EVENT_RESIZE":
      return null;
    case "SET_EVENT_RESIZE":
      newResize = action.state;
      return {
        affectedEvents: newResize.affectedEvents,
        mutatedEvents: newResize.mutatedEvents,
        isEvent: newResize.isEvent
      };
    default:
      return currentResize;
  }
}
function parseToolbars(calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {
  let header = calendarOptions.headerToolbar ? parseToolbar(calendarOptions.headerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) : null;
  let footer = calendarOptions.footerToolbar ? parseToolbar(calendarOptions.footerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) : null;
  return { header, footer };
}
function parseToolbar(sectionStrHash, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {
  let sectionWidgets = {};
  let viewsWithButtons = [];
  let hasTitle = false;
  for (let sectionName in sectionStrHash) {
    let sectionStr = sectionStrHash[sectionName];
    let sectionRes = parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi);
    sectionWidgets[sectionName] = sectionRes.widgets;
    viewsWithButtons.push(...sectionRes.viewsWithButtons);
    hasTitle = hasTitle || sectionRes.hasTitle;
  }
  return { sectionWidgets, viewsWithButtons, hasTitle };
}
function parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {
  let isRtl = calendarOptions.direction === "rtl";
  let calendarCustomButtons = calendarOptions.customButtons || {};
  let calendarButtonTextOverrides = calendarOptionOverrides.buttonText || {};
  let calendarButtonText = calendarOptions.buttonText || {};
  let calendarButtonHintOverrides = calendarOptionOverrides.buttonHints || {};
  let calendarButtonHints = calendarOptions.buttonHints || {};
  let sectionSubstrs = sectionStr ? sectionStr.split(" ") : [];
  let viewsWithButtons = [];
  let hasTitle = false;
  let widgets = sectionSubstrs.map((buttonGroupStr) => buttonGroupStr.split(",").map((buttonName) => {
    if (buttonName === "title") {
      hasTitle = true;
      return { buttonName };
    }
    let customButtonProps;
    let viewSpec;
    let buttonClick;
    let buttonIcon;
    let buttonText;
    let buttonHint;
    if (customButtonProps = calendarCustomButtons[buttonName]) {
      buttonClick = (ev) => {
        if (customButtonProps.click) {
          customButtonProps.click.call(ev.target, ev, ev.target);
        }
      };
      (buttonIcon = theme.getCustomButtonIconClass(customButtonProps)) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = customButtonProps.text);
      buttonHint = customButtonProps.hint || customButtonProps.text;
    } else if (viewSpec = viewSpecs[buttonName]) {
      viewsWithButtons.push(buttonName);
      buttonClick = () => {
        calendarApi.changeView(buttonName);
      };
      (buttonText = viewSpec.buttonTextOverride) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = viewSpec.buttonTextDefault);
      let textFallback = viewSpec.buttonTextOverride || viewSpec.buttonTextDefault;
      buttonHint = formatWithOrdinals(
        viewSpec.buttonTitleOverride || viewSpec.buttonTitleDefault || calendarOptions.viewHint,
        [textFallback, buttonName],
        // view-name = buttonName
        textFallback
      );
    } else if (calendarApi[buttonName]) {
      buttonClick = () => {
        calendarApi[buttonName]();
      };
      (buttonText = calendarButtonTextOverrides[buttonName]) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = calendarButtonText[buttonName]);
      if (buttonName === "prevYear" || buttonName === "nextYear") {
        let prevOrNext = buttonName === "prevYear" ? "prev" : "next";
        buttonHint = formatWithOrdinals(calendarButtonHintOverrides[prevOrNext] || calendarButtonHints[prevOrNext], [
          calendarButtonText.year || "year",
          "year"
        ], calendarButtonText[buttonName]);
      } else {
        buttonHint = (navUnit) => formatWithOrdinals(calendarButtonHintOverrides[buttonName] || calendarButtonHints[buttonName], [
          calendarButtonText[navUnit] || navUnit,
          navUnit
        ], calendarButtonText[buttonName]);
      }
    }
    return { buttonName, buttonClick, buttonIcon, buttonText, buttonHint };
  }));
  return { widgets, viewsWithButtons, hasTitle };
}
var ViewImpl = class {
  constructor(type, getCurrentData, dateEnv) {
    this.type = type;
    this.getCurrentData = getCurrentData;
    this.dateEnv = dateEnv;
  }
  get calendar() {
    return this.getCurrentData().calendarApi;
  }
  get title() {
    return this.getCurrentData().viewTitle;
  }
  get activeStart() {
    return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.start);
  }
  get activeEnd() {
    return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.end);
  }
  get currentStart() {
    return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.start);
  }
  get currentEnd() {
    return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.end);
  }
  getOption(name) {
    return this.getCurrentData().options[name];
  }
};
var eventSourceDef$2 = {
  ignoreRange: true,
  parseMeta(refined) {
    if (Array.isArray(refined.events)) {
      return refined.events;
    }
    return null;
  },
  fetch(arg, successCallback) {
    successCallback({
      rawEvents: arg.eventSource.meta
    });
  }
};
var arrayEventSourcePlugin = createPlugin({
  name: "array-event-source",
  eventSourceDefs: [eventSourceDef$2]
});
var eventSourceDef$1 = {
  parseMeta(refined) {
    if (typeof refined.events === "function") {
      return refined.events;
    }
    return null;
  },
  fetch(arg, successCallback, errorCallback) {
    const { dateEnv } = arg.context;
    const func = arg.eventSource.meta;
    unpromisify(func.bind(null, buildRangeApiWithTimeZone(arg.range, dateEnv)), (rawEvents) => successCallback({ rawEvents }), errorCallback);
  }
};
var funcEventSourcePlugin = createPlugin({
  name: "func-event-source",
  eventSourceDefs: [eventSourceDef$1]
});
var JSON_FEED_EVENT_SOURCE_REFINERS = {
  method: String,
  extraParams: identity,
  startParam: String,
  endParam: String,
  timeZoneParam: String
};
var eventSourceDef = {
  parseMeta(refined) {
    if (refined.url && (refined.format === "json" || !refined.format)) {
      return {
        url: refined.url,
        format: "json",
        method: (refined.method || "GET").toUpperCase(),
        extraParams: refined.extraParams,
        startParam: refined.startParam,
        endParam: refined.endParam,
        timeZoneParam: refined.timeZoneParam
      };
    }
    return null;
  },
  fetch(arg, successCallback, errorCallback) {
    const { meta } = arg.eventSource;
    const requestParams = buildRequestParams(meta, arg.range, arg.context);
    requestJson(meta.method, meta.url, requestParams).then(([rawEvents, response]) => {
      successCallback({ rawEvents, response });
    }, errorCallback);
  }
};
var jsonFeedEventSourcePlugin = createPlugin({
  name: "json-event-source",
  eventSourceRefiners: JSON_FEED_EVENT_SOURCE_REFINERS,
  eventSourceDefs: [eventSourceDef]
});
function buildRequestParams(meta, range2, context) {
  let { dateEnv, options } = context;
  let startParam;
  let endParam;
  let timeZoneParam;
  let customRequestParams;
  let params = {};
  startParam = meta.startParam;
  if (startParam == null) {
    startParam = options.startParam;
  }
  endParam = meta.endParam;
  if (endParam == null) {
    endParam = options.endParam;
  }
  timeZoneParam = meta.timeZoneParam;
  if (timeZoneParam == null) {
    timeZoneParam = options.timeZoneParam;
  }
  if (typeof meta.extraParams === "function") {
    customRequestParams = meta.extraParams();
  } else {
    customRequestParams = meta.extraParams || {};
  }
  Object.assign(params, customRequestParams);
  params[startParam] = dateEnv.formatIso(range2.start);
  params[endParam] = dateEnv.formatIso(range2.end);
  if (dateEnv.timeZone !== "local") {
    params[timeZoneParam] = dateEnv.timeZone;
  }
  return params;
}
var SIMPLE_RECURRING_REFINERS = {
  daysOfWeek: identity,
  startTime: createDuration,
  endTime: createDuration,
  duration: createDuration,
  startRecur: identity,
  endRecur: identity
};
var recurring = {
  parse(refined, dateEnv) {
    if (refined.daysOfWeek || refined.startTime || refined.endTime || refined.startRecur || refined.endRecur) {
      let recurringData = {
        daysOfWeek: refined.daysOfWeek || null,
        startTime: refined.startTime || null,
        endTime: refined.endTime || null,
        startRecur: refined.startRecur ? dateEnv.createMarker(refined.startRecur) : null,
        endRecur: refined.endRecur ? dateEnv.createMarker(refined.endRecur) : null
      };
      let duration;
      if (refined.duration) {
        duration = refined.duration;
      }
      if (!duration && refined.startTime && refined.endTime) {
        duration = subtractDurations(refined.endTime, refined.startTime);
      }
      return {
        allDayGuess: Boolean(!refined.startTime && !refined.endTime),
        duration,
        typeData: recurringData
        // doesn't need endTime anymore but oh well
      };
    }
    return null;
  },
  expand(typeData, framingRange, dateEnv) {
    let clippedFramingRange = intersectRanges(framingRange, { start: typeData.startRecur, end: typeData.endRecur });
    if (clippedFramingRange) {
      return expandRanges(typeData.daysOfWeek, typeData.startTime, clippedFramingRange, dateEnv);
    }
    return [];
  }
};
var simpleRecurringEventsPlugin = createPlugin({
  name: "simple-recurring-event",
  recurringTypes: [recurring],
  eventRefiners: SIMPLE_RECURRING_REFINERS
});
function expandRanges(daysOfWeek2, startTime, framingRange, dateEnv) {
  let dowHash = daysOfWeek2 ? arrayToHash(daysOfWeek2) : null;
  let dayMarker = startOfDay(framingRange.start);
  let endMarker = framingRange.end;
  let instanceStarts = [];
  while (dayMarker < endMarker) {
    let instanceStart;
    if (!dowHash || dowHash[dayMarker.getUTCDay()]) {
      if (startTime) {
        instanceStart = dateEnv.add(dayMarker, startTime);
      } else {
        instanceStart = dayMarker;
      }
      instanceStarts.push(instanceStart);
    }
    dayMarker = addDays(dayMarker, 1);
  }
  return instanceStarts;
}
var changeHandlerPlugin = createPlugin({
  name: "change-handler",
  optionChangeHandlers: {
    events(events, context) {
      handleEventSources([events], context);
    },
    eventSources: handleEventSources
  }
});
function handleEventSources(inputs, context) {
  let unfoundSources = hashValuesToArray(context.getCurrentData().eventSources);
  if (unfoundSources.length === 1 && inputs.length === 1 && Array.isArray(unfoundSources[0]._raw) && Array.isArray(inputs[0])) {
    context.dispatch({
      type: "RESET_RAW_EVENTS",
      sourceId: unfoundSources[0].sourceId,
      rawEvents: inputs[0]
    });
    return;
  }
  let newInputs = [];
  for (let input of inputs) {
    let inputFound = false;
    for (let i3 = 0; i3 < unfoundSources.length; i3 += 1) {
      if (unfoundSources[i3]._raw === input) {
        unfoundSources.splice(i3, 1);
        inputFound = true;
        break;
      }
    }
    if (!inputFound) {
      newInputs.push(input);
    }
  }
  for (let unfoundSource of unfoundSources) {
    context.dispatch({
      type: "REMOVE_EVENT_SOURCE",
      sourceId: unfoundSource.sourceId
    });
  }
  for (let newInput of newInputs) {
    context.calendarApi.addEventSource(newInput);
  }
}
function handleDateProfile(dateProfile, context) {
  context.emitter.trigger("datesSet", Object.assign(Object.assign({}, buildRangeApiWithTimeZone(dateProfile.activeRange, context.dateEnv)), { view: context.viewApi }));
}
function handleEventStore(eventStore, context) {
  let { emitter } = context;
  if (emitter.hasHandlers("eventsSet")) {
    emitter.trigger("eventsSet", buildEventApis(eventStore, context));
  }
}
var globalPlugins = [
  arrayEventSourcePlugin,
  funcEventSourcePlugin,
  jsonFeedEventSourcePlugin,
  simpleRecurringEventsPlugin,
  changeHandlerPlugin,
  createPlugin({
    name: "misc",
    isLoadingFuncs: [
      (state) => computeEventSourcesLoading(state.eventSources)
    ],
    propSetHandlers: {
      dateProfile: handleDateProfile,
      eventStore: handleEventStore
    }
  })
];
var TaskRunner = class {
  constructor(runTaskOption, drainedOption) {
    this.runTaskOption = runTaskOption;
    this.drainedOption = drainedOption;
    this.queue = [];
    this.delayedRunner = new DelayedRunner(this.drain.bind(this));
  }
  request(task, delay) {
    this.queue.push(task);
    this.delayedRunner.request(delay);
  }
  pause(scope) {
    this.delayedRunner.pause(scope);
  }
  resume(scope, force) {
    this.delayedRunner.resume(scope, force);
  }
  drain() {
    let { queue } = this;
    while (queue.length) {
      let completedTasks = [];
      let task;
      while (task = queue.shift()) {
        this.runTask(task);
        completedTasks.push(task);
      }
      this.drained(completedTasks);
    }
  }
  runTask(task) {
    if (this.runTaskOption) {
      this.runTaskOption(task);
    }
  }
  drained(completedTasks) {
    if (this.drainedOption) {
      this.drainedOption(completedTasks);
    }
  }
};
function buildTitle(dateProfile, viewOptions, dateEnv) {
  let range2;
  if (/^(year|month)$/.test(dateProfile.currentRangeUnit)) {
    range2 = dateProfile.currentRange;
  } else {
    range2 = dateProfile.activeRange;
  }
  return dateEnv.formatRange(range2.start, range2.end, createFormatter(viewOptions.titleFormat || buildTitleFormat(dateProfile)), {
    isEndExclusive: dateProfile.isRangeAllDay,
    defaultSeparator: viewOptions.titleRangeSeparator
  });
}
function buildTitleFormat(dateProfile) {
  let { currentRangeUnit } = dateProfile;
  if (currentRangeUnit === "year") {
    return { year: "numeric" };
  }
  if (currentRangeUnit === "month") {
    return { year: "numeric", month: "long" };
  }
  let days = diffWholeDays(dateProfile.currentRange.start, dateProfile.currentRange.end);
  if (days !== null && days > 1) {
    return { year: "numeric", month: "short", day: "numeric" };
  }
  return { year: "numeric", month: "long", day: "numeric" };
}
var CalendarDataManager = class {
  constructor(props) {
    this.computeCurrentViewData = memoize(this._computeCurrentViewData);
    this.organizeRawLocales = memoize(organizeRawLocales);
    this.buildLocale = memoize(buildLocale);
    this.buildPluginHooks = buildBuildPluginHooks();
    this.buildDateEnv = memoize(buildDateEnv$1);
    this.buildTheme = memoize(buildTheme);
    this.parseToolbars = memoize(parseToolbars);
    this.buildViewSpecs = memoize(buildViewSpecs);
    this.buildDateProfileGenerator = memoizeObjArg(buildDateProfileGenerator);
    this.buildViewApi = memoize(buildViewApi);
    this.buildViewUiProps = memoizeObjArg(buildViewUiProps);
    this.buildEventUiBySource = memoize(buildEventUiBySource, isPropsEqual);
    this.buildEventUiBases = memoize(buildEventUiBases);
    this.parseContextBusinessHours = memoizeObjArg(parseContextBusinessHours);
    this.buildTitle = memoize(buildTitle);
    this.emitter = new Emitter();
    this.actionRunner = new TaskRunner(this._handleAction.bind(this), this.updateData.bind(this));
    this.currentCalendarOptionsInput = {};
    this.currentCalendarOptionsRefined = {};
    this.currentViewOptionsInput = {};
    this.currentViewOptionsRefined = {};
    this.currentCalendarOptionsRefiners = {};
    this.optionsForRefining = [];
    this.optionsForHandling = [];
    this.getCurrentData = () => this.data;
    this.dispatch = (action) => {
      this.actionRunner.request(action);
    };
    this.props = props;
    this.actionRunner.pause();
    let dynamicOptionOverrides = {};
    let optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);
    let currentViewType = optionsData.calendarOptions.initialView || optionsData.pluginHooks.initialView;
    let currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides);
    props.calendarApi.currentDataManager = this;
    this.emitter.setThisContext(props.calendarApi);
    this.emitter.setOptions(currentViewData.options);
    let currentDate = getInitialDate(optionsData.calendarOptions, optionsData.dateEnv);
    let dateProfile = currentViewData.dateProfileGenerator.build(currentDate);
    if (!rangeContainsMarker(dateProfile.activeRange, currentDate)) {
      currentDate = dateProfile.currentRange.start;
    }
    let calendarContext = {
      dateEnv: optionsData.dateEnv,
      options: optionsData.calendarOptions,
      pluginHooks: optionsData.pluginHooks,
      calendarApi: props.calendarApi,
      dispatch: this.dispatch,
      emitter: this.emitter,
      getCurrentData: this.getCurrentData
    };
    for (let callback of optionsData.pluginHooks.contextInit) {
      callback(calendarContext);
    }
    let eventSources = initEventSources(optionsData.calendarOptions, dateProfile, calendarContext);
    let initialState = {
      dynamicOptionOverrides,
      currentViewType,
      currentDate,
      dateProfile,
      businessHours: this.parseContextBusinessHours(calendarContext),
      eventSources,
      eventUiBases: {},
      eventStore: createEmptyEventStore(),
      renderableEventStore: createEmptyEventStore(),
      dateSelection: null,
      eventSelection: "",
      eventDrag: null,
      eventResize: null,
      selectionConfig: this.buildViewUiProps(calendarContext).selectionConfig
    };
    let contextAndState = Object.assign(Object.assign({}, calendarContext), initialState);
    for (let reducer of optionsData.pluginHooks.reducers) {
      Object.assign(initialState, reducer(null, null, contextAndState));
    }
    if (computeIsLoading(initialState, calendarContext)) {
      this.emitter.trigger("loading", true);
    }
    this.state = initialState;
    this.updateData();
    this.actionRunner.resume();
  }
  resetOptions(optionOverrides, changedOptionNames) {
    let { props } = this;
    if (changedOptionNames === void 0) {
      props.optionOverrides = optionOverrides;
    } else {
      props.optionOverrides = Object.assign(Object.assign({}, props.optionOverrides || {}), optionOverrides);
      this.optionsForRefining.push(...changedOptionNames);
    }
    if (changedOptionNames === void 0 || changedOptionNames.length) {
      this.actionRunner.request({
        type: "NOTHING"
      });
    }
  }
  _handleAction(action) {
    let { props, state, emitter } = this;
    let dynamicOptionOverrides = reduceDynamicOptionOverrides(state.dynamicOptionOverrides, action);
    let optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);
    let currentViewType = reduceViewType(state.currentViewType, action);
    let currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides);
    props.calendarApi.currentDataManager = this;
    emitter.setThisContext(props.calendarApi);
    emitter.setOptions(currentViewData.options);
    let calendarContext = {
      dateEnv: optionsData.dateEnv,
      options: optionsData.calendarOptions,
      pluginHooks: optionsData.pluginHooks,
      calendarApi: props.calendarApi,
      dispatch: this.dispatch,
      emitter,
      getCurrentData: this.getCurrentData
    };
    let { currentDate, dateProfile } = state;
    if (this.data && this.data.dateProfileGenerator !== currentViewData.dateProfileGenerator) {
      dateProfile = currentViewData.dateProfileGenerator.build(currentDate);
    }
    currentDate = reduceCurrentDate(currentDate, action);
    dateProfile = reduceDateProfile(dateProfile, action, currentDate, currentViewData.dateProfileGenerator);
    if (action.type === "PREV" || // TODO: move this logic into DateProfileGenerator
    action.type === "NEXT" || // "
    !rangeContainsMarker(dateProfile.currentRange, currentDate)) {
      currentDate = dateProfile.currentRange.start;
    }
    let eventSources = reduceEventSources(state.eventSources, action, dateProfile, calendarContext);
    let eventStore = reduceEventStore(state.eventStore, action, eventSources, dateProfile, calendarContext);
    let isEventsLoading = computeEventSourcesLoading(eventSources);
    let renderableEventStore = isEventsLoading && !currentViewData.options.progressiveEventRendering ? state.renderableEventStore || eventStore : (
      // try from previous state
      eventStore
    );
    let { eventUiSingleBase, selectionConfig } = this.buildViewUiProps(calendarContext);
    let eventUiBySource = this.buildEventUiBySource(eventSources);
    let eventUiBases = this.buildEventUiBases(renderableEventStore.defs, eventUiSingleBase, eventUiBySource);
    let newState = {
      dynamicOptionOverrides,
      currentViewType,
      currentDate,
      dateProfile,
      eventSources,
      eventStore,
      renderableEventStore,
      selectionConfig,
      eventUiBases,
      businessHours: this.parseContextBusinessHours(calendarContext),
      dateSelection: reduceDateSelection(state.dateSelection, action),
      eventSelection: reduceSelectedEvent(state.eventSelection, action),
      eventDrag: reduceEventDrag(state.eventDrag, action),
      eventResize: reduceEventResize(state.eventResize, action)
    };
    let contextAndState = Object.assign(Object.assign({}, calendarContext), newState);
    for (let reducer of optionsData.pluginHooks.reducers) {
      Object.assign(newState, reducer(state, action, contextAndState));
    }
    let wasLoading = computeIsLoading(state, calendarContext);
    let isLoading = computeIsLoading(newState, calendarContext);
    if (!wasLoading && isLoading) {
      emitter.trigger("loading", true);
    } else if (wasLoading && !isLoading) {
      emitter.trigger("loading", false);
    }
    this.state = newState;
    if (props.onAction) {
      props.onAction(action);
    }
  }
  updateData() {
    let { props, state } = this;
    let oldData = this.data;
    let optionsData = this.computeOptionsData(props.optionOverrides, state.dynamicOptionOverrides, props.calendarApi);
    let currentViewData = this.computeCurrentViewData(state.currentViewType, optionsData, props.optionOverrides, state.dynamicOptionOverrides);
    let data = this.data = Object.assign(Object.assign(Object.assign({ viewTitle: this.buildTitle(state.dateProfile, currentViewData.options, optionsData.dateEnv), calendarApi: props.calendarApi, dispatch: this.dispatch, emitter: this.emitter, getCurrentData: this.getCurrentData }, optionsData), currentViewData), state);
    let changeHandlers = optionsData.pluginHooks.optionChangeHandlers;
    let oldCalendarOptions = oldData && oldData.calendarOptions;
    let newCalendarOptions = optionsData.calendarOptions;
    if (oldCalendarOptions && oldCalendarOptions !== newCalendarOptions) {
      if (oldCalendarOptions.timeZone !== newCalendarOptions.timeZone) {
        state.eventSources = data.eventSources = reduceEventSourcesNewTimeZone(data.eventSources, state.dateProfile, data);
        state.eventStore = data.eventStore = rezoneEventStoreDates(data.eventStore, oldData.dateEnv, data.dateEnv);
        state.renderableEventStore = data.renderableEventStore = rezoneEventStoreDates(data.renderableEventStore, oldData.dateEnv, data.dateEnv);
      }
      for (let optionName in changeHandlers) {
        if (this.optionsForHandling.indexOf(optionName) !== -1 || oldCalendarOptions[optionName] !== newCalendarOptions[optionName]) {
          changeHandlers[optionName](newCalendarOptions[optionName], data);
        }
      }
    }
    this.optionsForHandling = [];
    if (props.onData) {
      props.onData(data);
    }
  }
  computeOptionsData(optionOverrides, dynamicOptionOverrides, calendarApi) {
    if (!this.optionsForRefining.length && optionOverrides === this.stableOptionOverrides && dynamicOptionOverrides === this.stableDynamicOptionOverrides) {
      return this.stableCalendarOptionsData;
    }
    let { refinedOptions, pluginHooks, localeDefaults, availableLocaleData, extra } = this.processRawCalendarOptions(optionOverrides, dynamicOptionOverrides);
    warnUnknownOptions(extra);
    let dateEnv = this.buildDateEnv(refinedOptions.timeZone, refinedOptions.locale, refinedOptions.weekNumberCalculation, refinedOptions.firstDay, refinedOptions.weekText, pluginHooks, availableLocaleData, refinedOptions.defaultRangeSeparator);
    let viewSpecs = this.buildViewSpecs(pluginHooks.views, this.stableOptionOverrides, this.stableDynamicOptionOverrides, localeDefaults);
    let theme = this.buildTheme(refinedOptions, pluginHooks);
    let toolbarConfig = this.parseToolbars(refinedOptions, this.stableOptionOverrides, theme, viewSpecs, calendarApi);
    return this.stableCalendarOptionsData = {
      calendarOptions: refinedOptions,
      pluginHooks,
      dateEnv,
      viewSpecs,
      theme,
      toolbarConfig,
      localeDefaults,
      availableRawLocales: availableLocaleData.map
    };
  }
  // always called from behind a memoizer
  processRawCalendarOptions(optionOverrides, dynamicOptionOverrides) {
    let { locales, locale } = mergeRawOptions([
      BASE_OPTION_DEFAULTS,
      optionOverrides,
      dynamicOptionOverrides
    ]);
    let availableLocaleData = this.organizeRawLocales(locales);
    let availableRawLocales = availableLocaleData.map;
    let localeDefaults = this.buildLocale(locale || availableLocaleData.defaultCode, availableRawLocales).options;
    let pluginHooks = this.buildPluginHooks(optionOverrides.plugins || [], globalPlugins);
    let refiners = this.currentCalendarOptionsRefiners = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);
    let extra = {};
    let raw = mergeRawOptions([
      BASE_OPTION_DEFAULTS,
      localeDefaults,
      optionOverrides,
      dynamicOptionOverrides
    ]);
    let refined = {};
    let currentRaw = this.currentCalendarOptionsInput;
    let currentRefined = this.currentCalendarOptionsRefined;
    let anyChanges = false;
    for (let optionName in raw) {
      if (this.optionsForRefining.indexOf(optionName) === -1 && (raw[optionName] === currentRaw[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && optionName in currentRaw && COMPLEX_OPTION_COMPARATORS[optionName](currentRaw[optionName], raw[optionName]))) {
        refined[optionName] = currentRefined[optionName];
      } else if (refiners[optionName]) {
        refined[optionName] = refiners[optionName](raw[optionName]);
        anyChanges = true;
      } else {
        extra[optionName] = currentRaw[optionName];
      }
    }
    if (anyChanges) {
      this.currentCalendarOptionsInput = raw;
      this.currentCalendarOptionsRefined = refined;
      this.stableOptionOverrides = optionOverrides;
      this.stableDynamicOptionOverrides = dynamicOptionOverrides;
    }
    this.optionsForHandling.push(...this.optionsForRefining);
    this.optionsForRefining = [];
    return {
      rawOptions: this.currentCalendarOptionsInput,
      refinedOptions: this.currentCalendarOptionsRefined,
      pluginHooks,
      availableLocaleData,
      localeDefaults,
      extra
    };
  }
  _computeCurrentViewData(viewType, optionsData, optionOverrides, dynamicOptionOverrides) {
    let viewSpec = optionsData.viewSpecs[viewType];
    if (!viewSpec) {
      throw new Error(`viewType "${viewType}" is not available. Please make sure you've loaded all neccessary plugins`);
    }
    let { refinedOptions, extra } = this.processRawViewOptions(viewSpec, optionsData.pluginHooks, optionsData.localeDefaults, optionOverrides, dynamicOptionOverrides);
    warnUnknownOptions(extra);
    let dateProfileGenerator = this.buildDateProfileGenerator({
      dateProfileGeneratorClass: viewSpec.optionDefaults.dateProfileGeneratorClass,
      duration: viewSpec.duration,
      durationUnit: viewSpec.durationUnit,
      usesMinMaxTime: viewSpec.optionDefaults.usesMinMaxTime,
      dateEnv: optionsData.dateEnv,
      calendarApi: this.props.calendarApi,
      slotMinTime: refinedOptions.slotMinTime,
      slotMaxTime: refinedOptions.slotMaxTime,
      showNonCurrentDates: refinedOptions.showNonCurrentDates,
      dayCount: refinedOptions.dayCount,
      dateAlignment: refinedOptions.dateAlignment,
      dateIncrement: refinedOptions.dateIncrement,
      hiddenDays: refinedOptions.hiddenDays,
      weekends: refinedOptions.weekends,
      nowInput: refinedOptions.now,
      validRangeInput: refinedOptions.validRange,
      visibleRangeInput: refinedOptions.visibleRange,
      fixedWeekCount: refinedOptions.fixedWeekCount
    });
    let viewApi = this.buildViewApi(viewType, this.getCurrentData, optionsData.dateEnv);
    return { viewSpec, options: refinedOptions, dateProfileGenerator, viewApi };
  }
  processRawViewOptions(viewSpec, pluginHooks, localeDefaults, optionOverrides, dynamicOptionOverrides) {
    let raw = mergeRawOptions([
      BASE_OPTION_DEFAULTS,
      viewSpec.optionDefaults,
      localeDefaults,
      optionOverrides,
      viewSpec.optionOverrides,
      dynamicOptionOverrides
    ]);
    let refiners = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), VIEW_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);
    let refined = {};
    let currentRaw = this.currentViewOptionsInput;
    let currentRefined = this.currentViewOptionsRefined;
    let anyChanges = false;
    let extra = {};
    for (let optionName in raw) {
      if (raw[optionName] === currentRaw[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && COMPLEX_OPTION_COMPARATORS[optionName](raw[optionName], currentRaw[optionName])) {
        refined[optionName] = currentRefined[optionName];
      } else {
        if (raw[optionName] === this.currentCalendarOptionsInput[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && COMPLEX_OPTION_COMPARATORS[optionName](raw[optionName], this.currentCalendarOptionsInput[optionName])) {
          if (optionName in this.currentCalendarOptionsRefined) {
            refined[optionName] = this.currentCalendarOptionsRefined[optionName];
          }
        } else if (refiners[optionName]) {
          refined[optionName] = refiners[optionName](raw[optionName]);
        } else {
          extra[optionName] = raw[optionName];
        }
        anyChanges = true;
      }
    }
    if (anyChanges) {
      this.currentViewOptionsInput = raw;
      this.currentViewOptionsRefined = refined;
    }
    return {
      rawOptions: this.currentViewOptionsInput,
      refinedOptions: this.currentViewOptionsRefined,
      extra
    };
  }
};
function buildDateEnv$1(timeZone, explicitLocale, weekNumberCalculation, firstDay, weekText, pluginHooks, availableLocaleData, defaultSeparator) {
  let locale = buildLocale(explicitLocale || availableLocaleData.defaultCode, availableLocaleData.map);
  return new DateEnv({
    calendarSystem: "gregory",
    timeZone,
    namedTimeZoneImpl: pluginHooks.namedTimeZonedImpl,
    locale,
    weekNumberCalculation,
    firstDay,
    weekText,
    cmdFormatter: pluginHooks.cmdFormatter,
    defaultSeparator
  });
}
function buildTheme(options, pluginHooks) {
  let ThemeClass = pluginHooks.themeClasses[options.themeSystem] || StandardTheme;
  return new ThemeClass(options);
}
function buildDateProfileGenerator(props) {
  let DateProfileGeneratorClass = props.dateProfileGeneratorClass || DateProfileGenerator;
  return new DateProfileGeneratorClass(props);
}
function buildViewApi(type, getCurrentData, dateEnv) {
  return new ViewImpl(type, getCurrentData, dateEnv);
}
function buildEventUiBySource(eventSources) {
  return mapHash(eventSources, (eventSource) => eventSource.ui);
}
function buildEventUiBases(eventDefs, eventUiSingleBase, eventUiBySource) {
  let eventUiBases = { "": eventUiSingleBase };
  for (let defId in eventDefs) {
    let def = eventDefs[defId];
    if (def.sourceId && eventUiBySource[def.sourceId]) {
      eventUiBases[defId] = eventUiBySource[def.sourceId];
    }
  }
  return eventUiBases;
}
function buildViewUiProps(calendarContext) {
  let { options } = calendarContext;
  return {
    eventUiSingleBase: createEventUi({
      display: options.eventDisplay,
      editable: options.editable,
      startEditable: options.eventStartEditable,
      durationEditable: options.eventDurationEditable,
      constraint: options.eventConstraint,
      overlap: typeof options.eventOverlap === "boolean" ? options.eventOverlap : void 0,
      allow: options.eventAllow,
      backgroundColor: options.eventBackgroundColor,
      borderColor: options.eventBorderColor,
      textColor: options.eventTextColor,
      color: options.eventColor
      // classNames: options.eventClassNames // render hook will handle this
    }, calendarContext),
    selectionConfig: createEventUi({
      constraint: options.selectConstraint,
      overlap: typeof options.selectOverlap === "boolean" ? options.selectOverlap : void 0,
      allow: options.selectAllow
    }, calendarContext)
  };
}
function computeIsLoading(state, context) {
  for (let isLoadingFunc of context.pluginHooks.isLoadingFuncs) {
    if (isLoadingFunc(state)) {
      return true;
    }
  }
  return false;
}
function parseContextBusinessHours(calendarContext) {
  return parseBusinessHours(calendarContext.options.businessHours, calendarContext);
}
function warnUnknownOptions(options, viewName) {
  for (let optionName in options) {
    console.warn(`Unknown option '${optionName}'` + (viewName ? ` for view '${viewName}'` : ""));
  }
}
var ToolbarSection = class extends BaseComponent {
  render() {
    let children = this.props.widgetGroups.map((widgetGroup) => this.renderWidgetGroup(widgetGroup));
    return y("div", { className: "fc-toolbar-chunk" }, ...children);
  }
  renderWidgetGroup(widgetGroup) {
    let { props } = this;
    let { theme } = this.context;
    let children = [];
    let isOnlyButtons = true;
    for (let widget of widgetGroup) {
      let { buttonName, buttonClick, buttonText, buttonIcon, buttonHint } = widget;
      if (buttonName === "title") {
        isOnlyButtons = false;
        children.push(y("h2", { className: "fc-toolbar-title", id: props.titleId }, props.title));
      } else {
        let isPressed = buttonName === props.activeButton;
        let isDisabled = !props.isTodayEnabled && buttonName === "today" || !props.isPrevEnabled && buttonName === "prev" || !props.isNextEnabled && buttonName === "next";
        let buttonClasses = [`fc-${buttonName}-button`, theme.getClass("button")];
        if (isPressed) {
          buttonClasses.push(theme.getClass("buttonActive"));
        }
        children.push(y("button", { type: "button", title: typeof buttonHint === "function" ? buttonHint(props.navUnit) : buttonHint, disabled: isDisabled, "aria-pressed": isPressed, className: buttonClasses.join(" "), onClick: buttonClick }, buttonText || (buttonIcon ? y("span", { className: buttonIcon, role: "img" }) : "")));
      }
    }
    if (children.length > 1) {
      let groupClassName = isOnlyButtons && theme.getClass("buttonGroup") || "";
      return y("div", { className: groupClassName }, ...children);
    }
    return children[0];
  }
};
var Toolbar = class extends BaseComponent {
  render() {
    let { model, extraClassName } = this.props;
    let forceLtr = false;
    let startContent;
    let endContent;
    let sectionWidgets = model.sectionWidgets;
    let centerContent = sectionWidgets.center;
    if (sectionWidgets.left) {
      forceLtr = true;
      startContent = sectionWidgets.left;
    } else {
      startContent = sectionWidgets.start;
    }
    if (sectionWidgets.right) {
      forceLtr = true;
      endContent = sectionWidgets.right;
    } else {
      endContent = sectionWidgets.end;
    }
    let classNames = [
      extraClassName || "",
      "fc-toolbar",
      forceLtr ? "fc-toolbar-ltr" : ""
    ];
    return y(
      "div",
      { className: classNames.join(" ") },
      this.renderSection("start", startContent || []),
      this.renderSection("center", centerContent || []),
      this.renderSection("end", endContent || [])
    );
  }
  renderSection(key, widgetGroups) {
    let { props } = this;
    return y(ToolbarSection, { key, widgetGroups, title: props.title, navUnit: props.navUnit, activeButton: props.activeButton, isTodayEnabled: props.isTodayEnabled, isPrevEnabled: props.isPrevEnabled, isNextEnabled: props.isNextEnabled, titleId: props.titleId });
  }
};
var ViewHarness = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.state = {
      availableWidth: null
    };
    this.handleEl = (el) => {
      this.el = el;
      setRef(this.props.elRef, el);
      this.updateAvailableWidth();
    };
    this.handleResize = () => {
      this.updateAvailableWidth();
    };
  }
  render() {
    let { props, state } = this;
    let { aspectRatio } = props;
    let classNames = [
      "fc-view-harness",
      aspectRatio || props.liquid || props.height ? "fc-view-harness-active" : "fc-view-harness-passive"
      // let the view do the height
    ];
    let height = "";
    let paddingBottom = "";
    if (aspectRatio) {
      if (state.availableWidth !== null) {
        height = state.availableWidth / aspectRatio;
      } else {
        paddingBottom = `${1 / aspectRatio * 100}%`;
      }
    } else {
      height = props.height || "";
    }
    return y("div", { "aria-labelledby": props.labeledById, ref: this.handleEl, className: classNames.join(" "), style: { height, paddingBottom } }, props.children);
  }
  componentDidMount() {
    this.context.addResizeHandler(this.handleResize);
  }
  componentWillUnmount() {
    this.context.removeResizeHandler(this.handleResize);
  }
  updateAvailableWidth() {
    if (this.el && // needed. but why?
    this.props.aspectRatio) {
      this.setState({ availableWidth: this.el.offsetWidth });
    }
  }
};
var EventClicking = class extends Interaction {
  constructor(settings) {
    super(settings);
    this.handleSegClick = (ev, segEl) => {
      let { component } = this;
      let { context } = component;
      let seg = getElSeg(segEl);
      if (seg && // might be the <div> surrounding the more link
      component.isValidSegDownEl(ev.target)) {
        let hasUrlContainer = elementClosest(ev.target, ".fc-event-forced-url");
        let url = hasUrlContainer ? hasUrlContainer.querySelector("a[href]").href : "";
        context.emitter.trigger("eventClick", {
          el: segEl,
          event: new EventImpl(component.context, seg.eventRange.def, seg.eventRange.instance),
          jsEvent: ev,
          view: context.viewApi
        });
        if (url && !ev.defaultPrevented) {
          window.location.href = url;
        }
      }
    };
    this.destroy = listenBySelector(
      settings.el,
      "click",
      ".fc-event",
      // on both fg and bg events
      this.handleSegClick
    );
  }
};
var EventHovering = class extends Interaction {
  constructor(settings) {
    super(settings);
    this.handleEventElRemove = (el) => {
      if (el === this.currentSegEl) {
        this.handleSegLeave(null, this.currentSegEl);
      }
    };
    this.handleSegEnter = (ev, segEl) => {
      if (getElSeg(segEl)) {
        this.currentSegEl = segEl;
        this.triggerEvent("eventMouseEnter", ev, segEl);
      }
    };
    this.handleSegLeave = (ev, segEl) => {
      if (this.currentSegEl) {
        this.currentSegEl = null;
        this.triggerEvent("eventMouseLeave", ev, segEl);
      }
    };
    this.removeHoverListeners = listenToHoverBySelector(
      settings.el,
      ".fc-event",
      // on both fg and bg events
      this.handleSegEnter,
      this.handleSegLeave
    );
  }
  destroy() {
    this.removeHoverListeners();
  }
  triggerEvent(publicEvName, ev, segEl) {
    let { component } = this;
    let { context } = component;
    let seg = getElSeg(segEl);
    if (!ev || component.isValidSegDownEl(ev.target)) {
      context.emitter.trigger(publicEvName, {
        el: segEl,
        event: new EventImpl(context, seg.eventRange.def, seg.eventRange.instance),
        jsEvent: ev,
        view: context.viewApi
      });
    }
  }
};
var CalendarContent = class extends PureComponent {
  constructor() {
    super(...arguments);
    this.buildViewContext = memoize(buildViewContext);
    this.buildViewPropTransformers = memoize(buildViewPropTransformers);
    this.buildToolbarProps = memoize(buildToolbarProps);
    this.headerRef = d();
    this.footerRef = d();
    this.interactionsStore = {};
    this.state = {
      viewLabelId: getUniqueDomId()
    };
    this.registerInteractiveComponent = (component, settingsInput) => {
      let settings = parseInteractionSettings(component, settingsInput);
      let DEFAULT_INTERACTIONS = [
        EventClicking,
        EventHovering
      ];
      let interactionClasses = DEFAULT_INTERACTIONS.concat(this.props.pluginHooks.componentInteractions);
      let interactions = interactionClasses.map((TheInteractionClass) => new TheInteractionClass(settings));
      this.interactionsStore[component.uid] = interactions;
      interactionSettingsStore[component.uid] = settings;
    };
    this.unregisterInteractiveComponent = (component) => {
      let listeners = this.interactionsStore[component.uid];
      if (listeners) {
        for (let listener of listeners) {
          listener.destroy();
        }
        delete this.interactionsStore[component.uid];
      }
      delete interactionSettingsStore[component.uid];
    };
    this.resizeRunner = new DelayedRunner(() => {
      this.props.emitter.trigger("_resize", true);
      this.props.emitter.trigger("windowResize", { view: this.props.viewApi });
    });
    this.handleWindowResize = (ev) => {
      let { options } = this.props;
      if (options.handleWindowResize && ev.target === window) {
        this.resizeRunner.request(options.windowResizeDelay);
      }
    };
  }
  /*
  renders INSIDE of an outer div
  */
  render() {
    let { props } = this;
    let { toolbarConfig, options } = props;
    let toolbarProps = this.buildToolbarProps(
      props.viewSpec,
      props.dateProfile,
      props.dateProfileGenerator,
      props.currentDate,
      getNow(props.options.now, props.dateEnv),
      // TODO: use NowTimer????
      props.viewTitle
    );
    let viewVGrow = false;
    let viewHeight = "";
    let viewAspectRatio;
    if (props.isHeightAuto || props.forPrint) {
      viewHeight = "";
    } else if (options.height != null) {
      viewVGrow = true;
    } else if (options.contentHeight != null) {
      viewHeight = options.contentHeight;
    } else {
      viewAspectRatio = Math.max(options.aspectRatio, 0.5);
    }
    let viewContext = this.buildViewContext(props.viewSpec, props.viewApi, props.options, props.dateProfileGenerator, props.dateEnv, props.theme, props.pluginHooks, props.dispatch, props.getCurrentData, props.emitter, props.calendarApi, this.registerInteractiveComponent, this.unregisterInteractiveComponent);
    let viewLabelId = toolbarConfig.header && toolbarConfig.header.hasTitle ? this.state.viewLabelId : void 0;
    return y(
      ViewContextType.Provider,
      { value: viewContext },
      toolbarConfig.header && y(Toolbar, Object.assign({ ref: this.headerRef, extraClassName: "fc-header-toolbar", model: toolbarConfig.header, titleId: viewLabelId }, toolbarProps)),
      y(
        ViewHarness,
        { liquid: viewVGrow, height: viewHeight, aspectRatio: viewAspectRatio, labeledById: viewLabelId },
        this.renderView(props),
        this.buildAppendContent()
      ),
      toolbarConfig.footer && y(Toolbar, Object.assign({ ref: this.footerRef, extraClassName: "fc-footer-toolbar", model: toolbarConfig.footer, titleId: "" }, toolbarProps))
    );
  }
  componentDidMount() {
    let { props } = this;
    this.calendarInteractions = props.pluginHooks.calendarInteractions.map((CalendarInteractionClass) => new CalendarInteractionClass(props));
    window.addEventListener("resize", this.handleWindowResize);
    let { propSetHandlers } = props.pluginHooks;
    for (let propName in propSetHandlers) {
      propSetHandlers[propName](props[propName], props);
    }
  }
  componentDidUpdate(prevProps) {
    let { props } = this;
    let { propSetHandlers } = props.pluginHooks;
    for (let propName in propSetHandlers) {
      if (props[propName] !== prevProps[propName]) {
        propSetHandlers[propName](props[propName], props);
      }
    }
  }
  componentWillUnmount() {
    window.removeEventListener("resize", this.handleWindowResize);
    this.resizeRunner.clear();
    for (let interaction of this.calendarInteractions) {
      interaction.destroy();
    }
    this.props.emitter.trigger("_unmount");
  }
  buildAppendContent() {
    let { props } = this;
    let children = props.pluginHooks.viewContainerAppends.map((buildAppendContent) => buildAppendContent(props));
    return y(_, {}, ...children);
  }
  renderView(props) {
    let { pluginHooks } = props;
    let { viewSpec } = props;
    let viewProps = {
      dateProfile: props.dateProfile,
      businessHours: props.businessHours,
      eventStore: props.renderableEventStore,
      eventUiBases: props.eventUiBases,
      dateSelection: props.dateSelection,
      eventSelection: props.eventSelection,
      eventDrag: props.eventDrag,
      eventResize: props.eventResize,
      isHeightAuto: props.isHeightAuto,
      forPrint: props.forPrint
    };
    let transformers = this.buildViewPropTransformers(pluginHooks.viewPropsTransformers);
    for (let transformer of transformers) {
      Object.assign(viewProps, transformer.transform(viewProps, props));
    }
    let ViewComponent = viewSpec.component;
    return y(ViewComponent, Object.assign({}, viewProps));
  }
};
function buildToolbarProps(viewSpec, dateProfile, dateProfileGenerator, currentDate, now, title) {
  let todayInfo = dateProfileGenerator.build(now, void 0, false);
  let prevInfo = dateProfileGenerator.buildPrev(dateProfile, currentDate, false);
  let nextInfo = dateProfileGenerator.buildNext(dateProfile, currentDate, false);
  return {
    title,
    activeButton: viewSpec.type,
    navUnit: viewSpec.singleUnit,
    isTodayEnabled: todayInfo.isValid && !rangeContainsMarker(dateProfile.currentRange, now),
    isPrevEnabled: prevInfo.isValid,
    isNextEnabled: nextInfo.isValid
  };
}
function buildViewPropTransformers(theClasses) {
  return theClasses.map((TheClass) => new TheClass());
}
var Calendar = class extends CalendarImpl {
  constructor(el, optionOverrides = {}) {
    super();
    this.isRendering = false;
    this.isRendered = false;
    this.currentClassNames = [];
    this.customContentRenderId = 0;
    this.handleAction = (action) => {
      switch (action.type) {
        case "SET_EVENT_DRAG":
        case "SET_EVENT_RESIZE":
          this.renderRunner.tryDrain();
      }
    };
    this.handleData = (data) => {
      this.currentData = data;
      this.renderRunner.request(data.calendarOptions.rerenderDelay);
    };
    this.handleRenderRequest = () => {
      if (this.isRendering) {
        this.isRendered = true;
        let { currentData } = this;
        flushSync(() => {
          D(y(CalendarRoot, { options: currentData.calendarOptions, theme: currentData.theme, emitter: currentData.emitter }, (classNames, height, isHeightAuto, forPrint) => {
            this.setClassNames(classNames);
            this.setHeight(height);
            return y(
              RenderId.Provider,
              { value: this.customContentRenderId },
              y(CalendarContent, Object.assign({ isHeightAuto, forPrint }, currentData))
            );
          }), this.el);
        });
      } else if (this.isRendered) {
        this.isRendered = false;
        D(null, this.el);
        this.setClassNames([]);
        this.setHeight("");
      }
    };
    ensureElHasStyles(el);
    this.el = el;
    this.renderRunner = new DelayedRunner(this.handleRenderRequest);
    new CalendarDataManager({
      optionOverrides,
      calendarApi: this,
      onAction: this.handleAction,
      onData: this.handleData
    });
  }
  render() {
    let wasRendering = this.isRendering;
    if (!wasRendering) {
      this.isRendering = true;
    } else {
      this.customContentRenderId += 1;
    }
    this.renderRunner.request();
    if (wasRendering) {
      this.updateSize();
    }
  }
  destroy() {
    if (this.isRendering) {
      this.isRendering = false;
      this.renderRunner.request();
    }
  }
  updateSize() {
    flushSync(() => {
      super.updateSize();
    });
  }
  batchRendering(func) {
    this.renderRunner.pause("batchRendering");
    func();
    this.renderRunner.resume("batchRendering");
  }
  pauseRendering() {
    this.renderRunner.pause("pauseRendering");
  }
  resumeRendering() {
    this.renderRunner.resume("pauseRendering", true);
  }
  resetOptions(optionOverrides, changedOptionNames) {
    this.currentDataManager.resetOptions(optionOverrides, changedOptionNames);
  }
  setClassNames(classNames) {
    if (!isArraysEqual(classNames, this.currentClassNames)) {
      let { classList } = this.el;
      for (let className of this.currentClassNames) {
        classList.remove(className);
      }
      for (let className of classNames) {
        classList.add(className);
      }
      this.currentClassNames = classNames;
    }
  }
  setHeight(height) {
    applyStyleProp(this.el, "height", height);
  }
};

// node_modules/@fullcalendar/daygrid/internal.js
var TableView = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.headerElRef = d();
  }
  renderSimpleLayout(headerRowContent, bodyContent) {
    let { props, context } = this;
    let sections = [];
    let stickyHeaderDates = getStickyHeaderDates(context.options);
    if (headerRowContent) {
      sections.push({
        type: "header",
        key: "header",
        isSticky: stickyHeaderDates,
        chunk: {
          elRef: this.headerElRef,
          tableClassName: "fc-col-header",
          rowContent: headerRowContent
        }
      });
    }
    sections.push({
      type: "body",
      key: "body",
      liquid: true,
      chunk: { content: bodyContent }
    });
    return y(
      ViewContainer,
      { elClasses: ["fc-daygrid"], viewSpec: context.viewSpec },
      y(SimpleScrollGrid, { liquid: !props.isHeightAuto && !props.forPrint, collapsibleWidth: props.forPrint, cols: [], sections })
    );
  }
  renderHScrollLayout(headerRowContent, bodyContent, colCnt, dayMinWidth) {
    let ScrollGrid = this.context.pluginHooks.scrollGridImpl;
    if (!ScrollGrid) {
      throw new Error("No ScrollGrid implementation");
    }
    let { props, context } = this;
    let stickyHeaderDates = !props.forPrint && getStickyHeaderDates(context.options);
    let stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(context.options);
    let sections = [];
    if (headerRowContent) {
      sections.push({
        type: "header",
        key: "header",
        isSticky: stickyHeaderDates,
        chunks: [{
          key: "main",
          elRef: this.headerElRef,
          tableClassName: "fc-col-header",
          rowContent: headerRowContent
        }]
      });
    }
    sections.push({
      type: "body",
      key: "body",
      liquid: true,
      chunks: [{
        key: "main",
        content: bodyContent
      }]
    });
    if (stickyFooterScrollbar) {
      sections.push({
        type: "footer",
        key: "footer",
        isSticky: true,
        chunks: [{
          key: "main",
          content: renderScrollShim
        }]
      });
    }
    return y(
      ViewContainer,
      { elClasses: ["fc-daygrid"], viewSpec: context.viewSpec },
      y(ScrollGrid, { liquid: !props.isHeightAuto && !props.forPrint, forPrint: props.forPrint, collapsibleWidth: props.forPrint, colGroups: [{ cols: [{ span: colCnt, minWidth: dayMinWidth }] }], sections })
    );
  }
};
function splitSegsByRow(segs, rowCnt) {
  let byRow = [];
  for (let i3 = 0; i3 < rowCnt; i3 += 1) {
    byRow[i3] = [];
  }
  for (let seg of segs) {
    byRow[seg.row].push(seg);
  }
  return byRow;
}
function splitSegsByFirstCol(segs, colCnt) {
  let byCol = [];
  for (let i3 = 0; i3 < colCnt; i3 += 1) {
    byCol[i3] = [];
  }
  for (let seg of segs) {
    byCol[seg.firstCol].push(seg);
  }
  return byCol;
}
function splitInteractionByRow(ui, rowCnt) {
  let byRow = [];
  if (!ui) {
    for (let i3 = 0; i3 < rowCnt; i3 += 1) {
      byRow[i3] = null;
    }
  } else {
    for (let i3 = 0; i3 < rowCnt; i3 += 1) {
      byRow[i3] = {
        affectedInstances: ui.affectedInstances,
        isEvent: ui.isEvent,
        segs: []
      };
    }
    for (let seg of ui.segs) {
      byRow[seg.row].segs.push(seg);
    }
  }
  return byRow;
}
var DEFAULT_TABLE_EVENT_TIME_FORMAT = createFormatter({
  hour: "numeric",
  minute: "2-digit",
  omitZeroMinute: true,
  meridiem: "narrow"
});
function hasListItemDisplay(seg) {
  let { display: display2 } = seg.eventRange.ui;
  return display2 === "list-item" || display2 === "auto" && !seg.eventRange.def.allDay && seg.firstCol === seg.lastCol && // can't be multi-day
  seg.isStart && // "
  seg.isEnd;
}
var TableBlockEvent = class extends BaseComponent {
  render() {
    let { props } = this;
    return y(StandardEvent, Object.assign({}, props, { elClasses: ["fc-daygrid-event", "fc-daygrid-block-event", "fc-h-event"], defaultTimeFormat: DEFAULT_TABLE_EVENT_TIME_FORMAT, defaultDisplayEventEnd: props.defaultDisplayEventEnd, disableResizing: !props.seg.eventRange.def.allDay }));
  }
};
var TableListItemEvent = class extends BaseComponent {
  render() {
    let { props, context } = this;
    let { options } = context;
    let { seg } = props;
    let timeFormat = options.eventTimeFormat || DEFAULT_TABLE_EVENT_TIME_FORMAT;
    let timeText = buildSegTimeText(seg, timeFormat, context, true, props.defaultDisplayEventEnd);
    return y(EventContainer, Object.assign({}, props, { elTag: "a", elClasses: ["fc-daygrid-event", "fc-daygrid-dot-event"], elAttrs: getSegAnchorAttrs(props.seg, context), defaultGenerator: renderInnerContent2, timeText, isResizing: false, isDateSelecting: false }));
  }
};
function renderInnerContent2(renderProps) {
  return y(
    _,
    null,
    y("div", { className: "fc-daygrid-event-dot", style: { borderColor: renderProps.borderColor || renderProps.backgroundColor } }),
    renderProps.timeText && y("div", { className: "fc-event-time" }, renderProps.timeText),
    y("div", { className: "fc-event-title" }, renderProps.event.title || y(_, null, "\xA0"))
  );
}
var TableCellMoreLink = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.compileSegs = memoize(compileSegs);
  }
  render() {
    let { props } = this;
    let { allSegs, invisibleSegs } = this.compileSegs(props.singlePlacements);
    return y(MoreLinkContainer, { elClasses: ["fc-daygrid-more-link"], dateProfile: props.dateProfile, todayRange: props.todayRange, allDayDate: props.allDayDate, moreCnt: props.moreCnt, allSegs, hiddenSegs: invisibleSegs, alignmentElRef: props.alignmentElRef, alignGridTop: props.alignGridTop, extraDateSpan: props.extraDateSpan, popoverContent: () => {
      let isForcedInvisible = (props.eventDrag ? props.eventDrag.affectedInstances : null) || (props.eventResize ? props.eventResize.affectedInstances : null) || {};
      return y(_, null, allSegs.map((seg) => {
        let instanceId = seg.eventRange.instance.instanceId;
        return y("div", { className: "fc-daygrid-event-harness", key: instanceId, style: {
          visibility: isForcedInvisible[instanceId] ? "hidden" : ""
        } }, hasListItemDisplay(seg) ? y(TableListItemEvent, Object.assign({ seg, isDragging: false, isSelected: instanceId === props.eventSelection, defaultDisplayEventEnd: false }, getSegMeta(seg, props.todayRange))) : y(TableBlockEvent, Object.assign({ seg, isDragging: false, isResizing: false, isDateSelecting: false, isSelected: instanceId === props.eventSelection, defaultDisplayEventEnd: false }, getSegMeta(seg, props.todayRange))));
      }));
    } });
  }
};
function compileSegs(singlePlacements) {
  let allSegs = [];
  let invisibleSegs = [];
  for (let placement of singlePlacements) {
    allSegs.push(placement.seg);
    if (!placement.isVisible) {
      invisibleSegs.push(placement.seg);
    }
  }
  return { allSegs, invisibleSegs };
}
var DEFAULT_WEEK_NUM_FORMAT = createFormatter({ week: "narrow" });
var TableCell = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.rootElRef = d();
    this.state = {
      dayNumberId: getUniqueDomId()
    };
    this.handleRootEl = (el) => {
      setRef(this.rootElRef, el);
      setRef(this.props.elRef, el);
    };
  }
  render() {
    let { context, props, state, rootElRef } = this;
    let { options, dateEnv } = context;
    let { date, dateProfile } = props;
    const isMonthStart = props.showDayNumber && shouldDisplayMonthStart(date, dateProfile.currentRange, dateEnv);
    return y(DayCellContainer, { elTag: "td", elRef: this.handleRootEl, elClasses: [
      "fc-daygrid-day",
      ...props.extraClassNames || []
    ], elAttrs: Object.assign(Object.assign(Object.assign({}, props.extraDataAttrs), props.showDayNumber ? { "aria-labelledby": state.dayNumberId } : {}), { role: "gridcell" }), defaultGenerator: renderTopInner, date, dateProfile, todayRange: props.todayRange, showDayNumber: props.showDayNumber, isMonthStart, extraRenderProps: props.extraRenderProps }, (InnerContent, renderProps) => y(
      "div",
      { ref: props.innerElRef, className: "fc-daygrid-day-frame fc-scrollgrid-sync-inner", style: { minHeight: props.minHeight } },
      props.showWeekNumber && y(WeekNumberContainer, { elTag: "a", elClasses: ["fc-daygrid-week-number"], elAttrs: buildNavLinkAttrs(context, date, "week"), date, defaultFormat: DEFAULT_WEEK_NUM_FORMAT }),
      !renderProps.isDisabled && (props.showDayNumber || hasCustomDayCellContent(options) || props.forceDayTop) ? y(
        "div",
        { className: "fc-daygrid-day-top" },
        y(InnerContent, { elTag: "a", elClasses: [
          "fc-daygrid-day-number",
          isMonthStart && "fc-daygrid-month-start"
        ], elAttrs: Object.assign(Object.assign({}, buildNavLinkAttrs(context, date)), { id: state.dayNumberId }) })
      ) : props.showDayNumber ? (
        // for creating correct amount of space (see issue #7162)
        y(
          "div",
          { className: "fc-daygrid-day-top", style: { visibility: "hidden" } },
          y("a", { className: "fc-daygrid-day-number" }, "\xA0")
        )
      ) : void 0,
      y(
        "div",
        { className: "fc-daygrid-day-events", ref: props.fgContentElRef },
        props.fgContent,
        y(
          "div",
          { className: "fc-daygrid-day-bottom", style: { marginTop: props.moreMarginTop } },
          y(TableCellMoreLink, { allDayDate: date, singlePlacements: props.singlePlacements, moreCnt: props.moreCnt, alignmentElRef: rootElRef, alignGridTop: !props.showDayNumber, extraDateSpan: props.extraDateSpan, dateProfile: props.dateProfile, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, todayRange: props.todayRange })
        )
      ),
      y("div", { className: "fc-daygrid-day-bg" }, props.bgContent)
    ));
  }
};
function renderTopInner(props) {
  return props.dayNumberText || y(_, null, "\xA0");
}
function shouldDisplayMonthStart(date, currentRange, dateEnv) {
  const { start: currentStart, end: currentEnd } = currentRange;
  const currentEndIncl = addMs(currentEnd, -1);
  const currentFirstYear = dateEnv.getYear(currentStart);
  const currentFirstMonth = dateEnv.getMonth(currentStart);
  const currentLastYear = dateEnv.getYear(currentEndIncl);
  const currentLastMonth = dateEnv.getMonth(currentEndIncl);
  return !(currentFirstYear === currentLastYear && currentFirstMonth === currentLastMonth) && Boolean(
    // first date in current view?
    date.valueOf() === currentStart.valueOf() || // a month-start that's within the current range?
    dateEnv.getDay(date) === 1 && date.valueOf() < currentEnd.valueOf()
  );
}
function generateSegKey(seg) {
  return seg.eventRange.instance.instanceId + ":" + seg.firstCol;
}
function generateSegUid(seg) {
  return generateSegKey(seg) + ":" + seg.lastCol;
}
function computeFgSegPlacement(segs, dayMaxEvents, dayMaxEventRows, strictOrder, segHeights, maxContentHeight, cells) {
  let hierarchy = new DayGridSegHierarchy((segEntry) => {
    let segUid = segs[segEntry.index].eventRange.instance.instanceId + ":" + segEntry.span.start + ":" + (segEntry.span.end - 1);
    return segHeights[segUid] || 1;
  });
  hierarchy.allowReslicing = true;
  hierarchy.strictOrder = strictOrder;
  if (dayMaxEvents === true || dayMaxEventRows === true) {
    hierarchy.maxCoord = maxContentHeight;
    hierarchy.hiddenConsumes = true;
  } else if (typeof dayMaxEvents === "number") {
    hierarchy.maxStackCnt = dayMaxEvents;
  } else if (typeof dayMaxEventRows === "number") {
    hierarchy.maxStackCnt = dayMaxEventRows;
    hierarchy.hiddenConsumes = true;
  }
  let segInputs = [];
  let unknownHeightSegs = [];
  for (let i3 = 0; i3 < segs.length; i3 += 1) {
    let seg = segs[i3];
    let segUid = generateSegUid(seg);
    let eventHeight = segHeights[segUid];
    if (eventHeight != null) {
      segInputs.push({
        index: i3,
        span: {
          start: seg.firstCol,
          end: seg.lastCol + 1
        }
      });
    } else {
      unknownHeightSegs.push(seg);
    }
  }
  let hiddenEntries = hierarchy.addSegs(segInputs);
  let segRects = hierarchy.toRects();
  let { singleColPlacements, multiColPlacements, leftoverMargins } = placeRects(segRects, segs, cells);
  let moreCnts = [];
  let moreMarginTops = [];
  for (let seg of unknownHeightSegs) {
    multiColPlacements[seg.firstCol].push({
      seg,
      isVisible: false,
      isAbsolute: true,
      absoluteTop: 0,
      marginTop: 0
    });
    for (let col = seg.firstCol; col <= seg.lastCol; col += 1) {
      singleColPlacements[col].push({
        seg: resliceSeg(seg, col, col + 1, cells),
        isVisible: false,
        isAbsolute: false,
        absoluteTop: 0,
        marginTop: 0
      });
    }
  }
  for (let col = 0; col < cells.length; col += 1) {
    moreCnts.push(0);
  }
  for (let hiddenEntry of hiddenEntries) {
    let seg = segs[hiddenEntry.index];
    let hiddenSpan = hiddenEntry.span;
    multiColPlacements[hiddenSpan.start].push({
      seg: resliceSeg(seg, hiddenSpan.start, hiddenSpan.end, cells),
      isVisible: false,
      isAbsolute: true,
      absoluteTop: 0,
      marginTop: 0
    });
    for (let col = hiddenSpan.start; col < hiddenSpan.end; col += 1) {
      moreCnts[col] += 1;
      singleColPlacements[col].push({
        seg: resliceSeg(seg, col, col + 1, cells),
        isVisible: false,
        isAbsolute: false,
        absoluteTop: 0,
        marginTop: 0
      });
    }
  }
  for (let col = 0; col < cells.length; col += 1) {
    moreMarginTops.push(leftoverMargins[col]);
  }
  return { singleColPlacements, multiColPlacements, moreCnts, moreMarginTops };
}
function placeRects(allRects, segs, cells) {
  let rectsByEachCol = groupRectsByEachCol(allRects, cells.length);
  let singleColPlacements = [];
  let multiColPlacements = [];
  let leftoverMargins = [];
  for (let col = 0; col < cells.length; col += 1) {
    let rects = rectsByEachCol[col];
    let singlePlacements = [];
    let currentHeight = 0;
    let currentMarginTop = 0;
    for (let rect of rects) {
      let seg = segs[rect.index];
      singlePlacements.push({
        seg: resliceSeg(seg, col, col + 1, cells),
        isVisible: true,
        isAbsolute: false,
        absoluteTop: rect.levelCoord,
        marginTop: rect.levelCoord - currentHeight
      });
      currentHeight = rect.levelCoord + rect.thickness;
    }
    let multiPlacements = [];
    currentHeight = 0;
    currentMarginTop = 0;
    for (let rect of rects) {
      let seg = segs[rect.index];
      let isAbsolute = rect.span.end - rect.span.start > 1;
      let isFirstCol = rect.span.start === col;
      currentMarginTop += rect.levelCoord - currentHeight;
      currentHeight = rect.levelCoord + rect.thickness;
      if (isAbsolute) {
        currentMarginTop += rect.thickness;
        if (isFirstCol) {
          multiPlacements.push({
            seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),
            isVisible: true,
            isAbsolute: true,
            absoluteTop: rect.levelCoord,
            marginTop: 0
          });
        }
      } else if (isFirstCol) {
        multiPlacements.push({
          seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),
          isVisible: true,
          isAbsolute: false,
          absoluteTop: rect.levelCoord,
          marginTop: currentMarginTop
          // claim the margin
        });
        currentMarginTop = 0;
      }
    }
    singleColPlacements.push(singlePlacements);
    multiColPlacements.push(multiPlacements);
    leftoverMargins.push(currentMarginTop);
  }
  return { singleColPlacements, multiColPlacements, leftoverMargins };
}
function groupRectsByEachCol(rects, colCnt) {
  let rectsByEachCol = [];
  for (let col = 0; col < colCnt; col += 1) {
    rectsByEachCol.push([]);
  }
  for (let rect of rects) {
    for (let col = rect.span.start; col < rect.span.end; col += 1) {
      rectsByEachCol[col].push(rect);
    }
  }
  return rectsByEachCol;
}
function resliceSeg(seg, spanStart, spanEnd, cells) {
  if (seg.firstCol === spanStart && seg.lastCol === spanEnd - 1) {
    return seg;
  }
  let eventRange = seg.eventRange;
  let origRange = eventRange.range;
  let slicedRange = intersectRanges(origRange, {
    start: cells[spanStart].date,
    end: addDays(cells[spanEnd - 1].date, 1)
  });
  return Object.assign(Object.assign({}, seg), { firstCol: spanStart, lastCol: spanEnd - 1, eventRange: {
    def: eventRange.def,
    ui: Object.assign(Object.assign({}, eventRange.ui), { durationEditable: false }),
    instance: eventRange.instance,
    range: slicedRange
  }, isStart: seg.isStart && slicedRange.start.valueOf() === origRange.start.valueOf(), isEnd: seg.isEnd && slicedRange.end.valueOf() === origRange.end.valueOf() });
}
var DayGridSegHierarchy = class extends SegHierarchy {
  constructor() {
    super(...arguments);
    this.hiddenConsumes = false;
    this.forceHidden = {};
  }
  addSegs(segInputs) {
    const hiddenSegs = super.addSegs(segInputs);
    const { entriesByLevel } = this;
    const excludeHidden = (entry) => !this.forceHidden[buildEntryKey(entry)];
    for (let level = 0; level < entriesByLevel.length; level += 1) {
      entriesByLevel[level] = entriesByLevel[level].filter(excludeHidden);
    }
    return hiddenSegs;
  }
  handleInvalidInsertion(insertion, entry, hiddenEntries) {
    const { entriesByLevel, forceHidden } = this;
    const { touchingEntry, touchingLevel, touchingLateral } = insertion;
    if (this.hiddenConsumes && touchingEntry) {
      const touchingEntryId = buildEntryKey(touchingEntry);
      if (!forceHidden[touchingEntryId]) {
        if (this.allowReslicing) {
          const hiddenEntry = Object.assign(Object.assign({}, touchingEntry), { span: intersectSpans(touchingEntry.span, entry.span) });
          const hiddenEntryId = buildEntryKey(hiddenEntry);
          forceHidden[hiddenEntryId] = true;
          entriesByLevel[touchingLevel][touchingLateral] = hiddenEntry;
          hiddenEntries.push(hiddenEntry);
          this.splitEntry(touchingEntry, entry, hiddenEntries);
        } else {
          forceHidden[touchingEntryId] = true;
          hiddenEntries.push(touchingEntry);
        }
      }
    }
    super.handleInvalidInsertion(insertion, entry, hiddenEntries);
  }
};
var TableRow = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.cellElRefs = new RefMap();
    this.frameElRefs = new RefMap();
    this.fgElRefs = new RefMap();
    this.segHarnessRefs = new RefMap();
    this.rootElRef = d();
    this.state = {
      framePositions: null,
      maxContentHeight: null,
      segHeights: {}
    };
    this.handleResize = (isForced) => {
      if (isForced) {
        this.updateSizing(true);
      }
    };
  }
  render() {
    let { props, state, context } = this;
    let { options } = context;
    let colCnt = props.cells.length;
    let businessHoursByCol = splitSegsByFirstCol(props.businessHourSegs, colCnt);
    let bgEventSegsByCol = splitSegsByFirstCol(props.bgEventSegs, colCnt);
    let highlightSegsByCol = splitSegsByFirstCol(this.getHighlightSegs(), colCnt);
    let mirrorSegsByCol = splitSegsByFirstCol(this.getMirrorSegs(), colCnt);
    let { singleColPlacements, multiColPlacements, moreCnts, moreMarginTops } = computeFgSegPlacement(sortEventSegs(props.fgEventSegs, options.eventOrder), props.dayMaxEvents, props.dayMaxEventRows, options.eventOrderStrict, state.segHeights, state.maxContentHeight, props.cells);
    let isForcedInvisible = (
      // TODO: messy way to compute this
      props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {}
    );
    return y(
      "tr",
      { ref: this.rootElRef, role: "row" },
      props.renderIntro && props.renderIntro(),
      props.cells.map((cell, col) => {
        let normalFgNodes = this.renderFgSegs(col, props.forPrint ? singleColPlacements[col] : multiColPlacements[col], props.todayRange, isForcedInvisible);
        let mirrorFgNodes = this.renderFgSegs(col, buildMirrorPlacements(mirrorSegsByCol[col], multiColPlacements), props.todayRange, {}, Boolean(props.eventDrag), Boolean(props.eventResize), false);
        return y(TableCell, { key: cell.key, elRef: this.cellElRefs.createRef(cell.key), innerElRef: this.frameElRefs.createRef(cell.key), dateProfile: props.dateProfile, date: cell.date, showDayNumber: props.showDayNumbers, showWeekNumber: props.showWeekNumbers && col === 0, forceDayTop: props.showWeekNumbers, todayRange: props.todayRange, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, extraRenderProps: cell.extraRenderProps, extraDataAttrs: cell.extraDataAttrs, extraClassNames: cell.extraClassNames, extraDateSpan: cell.extraDateSpan, moreCnt: moreCnts[col], moreMarginTop: moreMarginTops[col], singlePlacements: singleColPlacements[col], fgContentElRef: this.fgElRefs.createRef(cell.key), fgContent: (
          // Fragment scopes the keys
          y(
            _,
            null,
            y(_, null, normalFgNodes),
            y(_, null, mirrorFgNodes)
          )
        ), bgContent: (
          // Fragment scopes the keys
          y(
            _,
            null,
            this.renderFillSegs(highlightSegsByCol[col], "highlight"),
            this.renderFillSegs(businessHoursByCol[col], "non-business"),
            this.renderFillSegs(bgEventSegsByCol[col], "bg-event")
          )
        ), minHeight: props.cellMinHeight });
      })
    );
  }
  componentDidMount() {
    this.updateSizing(true);
    this.context.addResizeHandler(this.handleResize);
  }
  componentDidUpdate(prevProps, prevState) {
    let currentProps = this.props;
    this.updateSizing(!isPropsEqual(prevProps, currentProps));
  }
  componentWillUnmount() {
    this.context.removeResizeHandler(this.handleResize);
  }
  getHighlightSegs() {
    let { props } = this;
    if (props.eventDrag && props.eventDrag.segs.length) {
      return props.eventDrag.segs;
    }
    if (props.eventResize && props.eventResize.segs.length) {
      return props.eventResize.segs;
    }
    return props.dateSelectionSegs;
  }
  getMirrorSegs() {
    let { props } = this;
    if (props.eventResize && props.eventResize.segs.length) {
      return props.eventResize.segs;
    }
    return [];
  }
  renderFgSegs(col, segPlacements, todayRange, isForcedInvisible, isDragging, isResizing, isDateSelecting) {
    let { context } = this;
    let { eventSelection } = this.props;
    let { framePositions } = this.state;
    let defaultDisplayEventEnd = this.props.cells.length === 1;
    let isMirror = isDragging || isResizing || isDateSelecting;
    let nodes = [];
    if (framePositions) {
      for (let placement of segPlacements) {
        let { seg } = placement;
        let { instanceId } = seg.eventRange.instance;
        let isVisible = placement.isVisible && !isForcedInvisible[instanceId];
        let isAbsolute = placement.isAbsolute;
        let left = "";
        let right = "";
        if (isAbsolute) {
          if (context.isRtl) {
            right = 0;
            left = framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol];
          } else {
            left = 0;
            right = framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol];
          }
        }
        nodes.push(y("div", { className: "fc-daygrid-event-harness" + (isAbsolute ? " fc-daygrid-event-harness-abs" : ""), key: generateSegKey(seg), ref: isMirror ? null : this.segHarnessRefs.createRef(generateSegUid(seg)), style: {
          visibility: isVisible ? "" : "hidden",
          marginTop: isAbsolute ? "" : placement.marginTop,
          top: isAbsolute ? placement.absoluteTop : "",
          left,
          right
        } }, hasListItemDisplay(seg) ? y(TableListItemEvent, Object.assign({ seg, isDragging, isSelected: instanceId === eventSelection, defaultDisplayEventEnd }, getSegMeta(seg, todayRange))) : y(TableBlockEvent, Object.assign({ seg, isDragging, isResizing, isDateSelecting, isSelected: instanceId === eventSelection, defaultDisplayEventEnd }, getSegMeta(seg, todayRange)))));
      }
    }
    return nodes;
  }
  renderFillSegs(segs, fillType) {
    let { isRtl } = this.context;
    let { todayRange } = this.props;
    let { framePositions } = this.state;
    let nodes = [];
    if (framePositions) {
      for (let seg of segs) {
        let leftRightCss = isRtl ? {
          right: 0,
          left: framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol]
        } : {
          left: 0,
          right: framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol]
        };
        nodes.push(y("div", { key: buildEventRangeKey(seg.eventRange), className: "fc-daygrid-bg-harness", style: leftRightCss }, fillType === "bg-event" ? y(BgEvent, Object.assign({ seg }, getSegMeta(seg, todayRange))) : renderFill(fillType)));
      }
    }
    return y(_, {}, ...nodes);
  }
  updateSizing(isExternalSizingChange) {
    let { props, state, frameElRefs } = this;
    if (!props.forPrint && props.clientWidth !== null) {
      if (isExternalSizingChange) {
        let frameEls = props.cells.map((cell) => frameElRefs.currentMap[cell.key]);
        if (frameEls.length) {
          let originEl = this.rootElRef.current;
          let newPositionCache = new PositionCache(
            originEl,
            frameEls,
            true,
            // isHorizontal
            false
          );
          if (!state.framePositions || !state.framePositions.similarTo(newPositionCache)) {
            this.setState({
              framePositions: new PositionCache(
                originEl,
                frameEls,
                true,
                // isHorizontal
                false
              )
            });
          }
        }
      }
      const oldSegHeights = this.state.segHeights;
      const newSegHeights = this.querySegHeights();
      const limitByContentHeight = props.dayMaxEvents === true || props.dayMaxEventRows === true;
      this.safeSetState({
        // HACK to prevent oscillations of events being shown/hidden from max-event-rows
        // Essentially, once you compute an element's height, never null-out.
        // TODO: always display all events, as visibility:hidden?
        segHeights: Object.assign(Object.assign({}, oldSegHeights), newSegHeights),
        maxContentHeight: limitByContentHeight ? this.computeMaxContentHeight() : null
      });
    }
  }
  querySegHeights() {
    let segElMap = this.segHarnessRefs.currentMap;
    let segHeights = {};
    for (let segUid in segElMap) {
      let height = Math.round(segElMap[segUid].getBoundingClientRect().height);
      segHeights[segUid] = Math.max(segHeights[segUid] || 0, height);
    }
    return segHeights;
  }
  computeMaxContentHeight() {
    let firstKey = this.props.cells[0].key;
    let cellEl = this.cellElRefs.currentMap[firstKey];
    let fcContainerEl = this.fgElRefs.currentMap[firstKey];
    return cellEl.getBoundingClientRect().bottom - fcContainerEl.getBoundingClientRect().top;
  }
  getCellEls() {
    let elMap = this.cellElRefs.currentMap;
    return this.props.cells.map((cell) => elMap[cell.key]);
  }
};
TableRow.addStateEquality({
  segHeights: isPropsEqual
});
function buildMirrorPlacements(mirrorSegs, colPlacements) {
  if (!mirrorSegs.length) {
    return [];
  }
  let topsByInstanceId = buildAbsoluteTopHash(colPlacements);
  return mirrorSegs.map((seg) => ({
    seg,
    isVisible: true,
    isAbsolute: true,
    absoluteTop: topsByInstanceId[seg.eventRange.instance.instanceId],
    marginTop: 0
  }));
}
function buildAbsoluteTopHash(colPlacements) {
  let topsByInstanceId = {};
  for (let placements of colPlacements) {
    for (let placement of placements) {
      topsByInstanceId[placement.seg.eventRange.instance.instanceId] = placement.absoluteTop;
    }
  }
  return topsByInstanceId;
}
var TableRows = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.splitBusinessHourSegs = memoize(splitSegsByRow);
    this.splitBgEventSegs = memoize(splitSegsByRow);
    this.splitFgEventSegs = memoize(splitSegsByRow);
    this.splitDateSelectionSegs = memoize(splitSegsByRow);
    this.splitEventDrag = memoize(splitInteractionByRow);
    this.splitEventResize = memoize(splitInteractionByRow);
    this.rowRefs = new RefMap();
  }
  render() {
    let { props, context } = this;
    let rowCnt = props.cells.length;
    let businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, rowCnt);
    let bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, rowCnt);
    let fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, rowCnt);
    let dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, rowCnt);
    let eventDragByRow = this.splitEventDrag(props.eventDrag, rowCnt);
    let eventResizeByRow = this.splitEventResize(props.eventResize, rowCnt);
    let cellMinHeight = rowCnt >= 7 && props.clientWidth ? props.clientWidth / context.options.aspectRatio / 6 : null;
    return y(NowTimer, { unit: "day" }, (nowDate, todayRange) => y(_, null, props.cells.map((cells, row) => y(TableRow, {
      ref: this.rowRefs.createRef(row),
      key: cells.length ? cells[0].date.toISOString() : row,
      showDayNumbers: rowCnt > 1,
      showWeekNumbers: props.showWeekNumbers,
      todayRange,
      dateProfile: props.dateProfile,
      cells,
      renderIntro: props.renderRowIntro,
      businessHourSegs: businessHourSegsByRow[row],
      eventSelection: props.eventSelection,
      bgEventSegs: bgEventSegsByRow[row].filter(isSegAllDay),
      fgEventSegs: fgEventSegsByRow[row],
      dateSelectionSegs: dateSelectionSegsByRow[row],
      eventDrag: eventDragByRow[row],
      eventResize: eventResizeByRow[row],
      dayMaxEvents: props.dayMaxEvents,
      dayMaxEventRows: props.dayMaxEventRows,
      clientWidth: props.clientWidth,
      clientHeight: props.clientHeight,
      cellMinHeight,
      forPrint: props.forPrint
    }))));
  }
  componentDidMount() {
    this.registerInteractiveComponent();
  }
  componentDidUpdate() {
    this.registerInteractiveComponent();
  }
  registerInteractiveComponent() {
    if (!this.rootEl) {
      const firstCellEl = this.rowRefs.currentMap[0].getCellEls()[0];
      const rootEl = firstCellEl ? firstCellEl.closest(".fc-daygrid-body") : null;
      if (rootEl) {
        this.rootEl = rootEl;
        this.context.registerInteractiveComponent(this, {
          el: rootEl,
          isHitComboAllowed: this.props.isHitComboAllowed
        });
      }
    }
  }
  componentWillUnmount() {
    if (this.rootEl) {
      this.context.unregisterInteractiveComponent(this);
      this.rootEl = null;
    }
  }
  // Hit System
  // ----------------------------------------------------------------------------------------------------
  prepareHits() {
    this.rowPositions = new PositionCache(
      this.rootEl,
      this.rowRefs.collect().map((rowObj) => rowObj.getCellEls()[0]),
      // first cell el in each row. TODO: not optimal
      false,
      true
    );
    this.colPositions = new PositionCache(
      this.rootEl,
      this.rowRefs.currentMap[0].getCellEls(),
      // cell els in first row
      true,
      // horizontal
      false
    );
  }
  queryHit(positionLeft, positionTop) {
    let { colPositions, rowPositions } = this;
    let col = colPositions.leftToIndex(positionLeft);
    let row = rowPositions.topToIndex(positionTop);
    if (row != null && col != null) {
      let cell = this.props.cells[row][col];
      return {
        dateProfile: this.props.dateProfile,
        dateSpan: Object.assign({ range: this.getCellRange(row, col), allDay: true }, cell.extraDateSpan),
        dayEl: this.getCellEl(row, col),
        rect: {
          left: colPositions.lefts[col],
          right: colPositions.rights[col],
          top: rowPositions.tops[row],
          bottom: rowPositions.bottoms[row]
        },
        layer: 0
      };
    }
    return null;
  }
  getCellEl(row, col) {
    return this.rowRefs.currentMap[row].getCellEls()[col];
  }
  getCellRange(row, col) {
    let start = this.props.cells[row][col].date;
    let end = addDays(start, 1);
    return { start, end };
  }
};
function isSegAllDay(seg) {
  return seg.eventRange.def.allDay;
}
var Table = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.elRef = d();
    this.needsScrollReset = false;
  }
  render() {
    let { props } = this;
    let { dayMaxEventRows, dayMaxEvents, expandRows } = props;
    let limitViaBalanced = dayMaxEvents === true || dayMaxEventRows === true;
    if (limitViaBalanced && !expandRows) {
      limitViaBalanced = false;
      dayMaxEventRows = null;
      dayMaxEvents = null;
    }
    let classNames = [
      "fc-daygrid-body",
      limitViaBalanced ? "fc-daygrid-body-balanced" : "fc-daygrid-body-unbalanced",
      expandRows ? "" : "fc-daygrid-body-natural"
      // will height of one row depend on the others?
    ];
    return y(
      "div",
      { ref: this.elRef, className: classNames.join(" "), style: {
        // these props are important to give this wrapper correct dimensions for interactions
        // TODO: if we set it here, can we avoid giving to inner tables?
        width: props.clientWidth,
        minWidth: props.tableMinWidth
      } },
      y(
        "table",
        { role: "presentation", className: "fc-scrollgrid-sync-table", style: {
          width: props.clientWidth,
          minWidth: props.tableMinWidth,
          height: expandRows ? props.clientHeight : ""
        } },
        props.colGroupNode,
        y(
          "tbody",
          { role: "presentation" },
          y(TableRows, { dateProfile: props.dateProfile, cells: props.cells, renderRowIntro: props.renderRowIntro, showWeekNumbers: props.showWeekNumbers, clientWidth: props.clientWidth, clientHeight: props.clientHeight, businessHourSegs: props.businessHourSegs, bgEventSegs: props.bgEventSegs, fgEventSegs: props.fgEventSegs, dateSelectionSegs: props.dateSelectionSegs, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, dayMaxEvents, dayMaxEventRows, forPrint: props.forPrint, isHitComboAllowed: props.isHitComboAllowed })
        )
      )
    );
  }
  componentDidMount() {
    this.requestScrollReset();
  }
  componentDidUpdate(prevProps) {
    if (prevProps.dateProfile !== this.props.dateProfile) {
      this.requestScrollReset();
    } else {
      this.flushScrollReset();
    }
  }
  requestScrollReset() {
    this.needsScrollReset = true;
    this.flushScrollReset();
  }
  flushScrollReset() {
    if (this.needsScrollReset && this.props.clientWidth) {
      const subjectEl = getScrollSubjectEl(this.elRef.current, this.props.dateProfile);
      if (subjectEl) {
        const originEl = subjectEl.closest(".fc-daygrid-body");
        const scrollEl = originEl.closest(".fc-scroller");
        const scrollTop = subjectEl.getBoundingClientRect().top - originEl.getBoundingClientRect().top;
        scrollEl.scrollTop = scrollTop ? scrollTop + 1 : 0;
      }
      this.needsScrollReset = false;
    }
  }
};
function getScrollSubjectEl(containerEl, dateProfile) {
  let el;
  if (dateProfile.currentRangeUnit.match(/year|month/)) {
    el = containerEl.querySelector(`[data-date="${formatIsoMonthStr(dateProfile.currentDate)}-01"]`);
  }
  if (!el) {
    el = containerEl.querySelector(`[data-date="${formatDayString(dateProfile.currentDate)}"]`);
  }
  return el;
}
var DayTableSlicer = class extends Slicer {
  constructor() {
    super(...arguments);
    this.forceDayIfListItem = true;
  }
  sliceRange(dateRange, dayTableModel) {
    return dayTableModel.sliceRange(dateRange);
  }
};
var DayTable = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.slicer = new DayTableSlicer();
    this.tableRef = d();
  }
  render() {
    let { props, context } = this;
    return y(Table, Object.assign({ ref: this.tableRef }, this.slicer.sliceProps(props, props.dateProfile, props.nextDayThreshold, context, props.dayTableModel), { dateProfile: props.dateProfile, cells: props.dayTableModel.cells, colGroupNode: props.colGroupNode, tableMinWidth: props.tableMinWidth, renderRowIntro: props.renderRowIntro, dayMaxEvents: props.dayMaxEvents, dayMaxEventRows: props.dayMaxEventRows, showWeekNumbers: props.showWeekNumbers, expandRows: props.expandRows, headerAlignElRef: props.headerAlignElRef, clientWidth: props.clientWidth, clientHeight: props.clientHeight, forPrint: props.forPrint }));
  }
};
var DayTableView = class extends TableView {
  constructor() {
    super(...arguments);
    this.buildDayTableModel = memoize(buildDayTableModel);
    this.headerRef = d();
    this.tableRef = d();
  }
  render() {
    let { options, dateProfileGenerator } = this.context;
    let { props } = this;
    let dayTableModel = this.buildDayTableModel(props.dateProfile, dateProfileGenerator);
    let headerContent = options.dayHeaders && y(DayHeader, { ref: this.headerRef, dateProfile: props.dateProfile, dates: dayTableModel.headerDates, datesRepDistinctDays: dayTableModel.rowCnt === 1 });
    let bodyContent = (contentArg) => y(DayTable, { ref: this.tableRef, dateProfile: props.dateProfile, dayTableModel, businessHours: props.businessHours, dateSelection: props.dateSelection, eventStore: props.eventStore, eventUiBases: props.eventUiBases, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, nextDayThreshold: options.nextDayThreshold, colGroupNode: contentArg.tableColGroupNode, tableMinWidth: contentArg.tableMinWidth, dayMaxEvents: options.dayMaxEvents, dayMaxEventRows: options.dayMaxEventRows, showWeekNumbers: options.weekNumbers, expandRows: !props.isHeightAuto, headerAlignElRef: this.headerElRef, clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, forPrint: props.forPrint });
    return options.dayMinWidth ? this.renderHScrollLayout(headerContent, bodyContent, dayTableModel.colCnt, options.dayMinWidth) : this.renderSimpleLayout(headerContent, bodyContent);
  }
};
function buildDayTableModel(dateProfile, dateProfileGenerator) {
  let daySeries = new DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);
  return new DayTableModel(daySeries, /year|month|week/.test(dateProfile.currentRangeUnit));
}
var TableDateProfileGenerator = class extends DateProfileGenerator {
  // Computes the date range that will be rendered
  buildRenderRange(currentRange, currentRangeUnit, isRangeAllDay) {
    let renderRange = super.buildRenderRange(currentRange, currentRangeUnit, isRangeAllDay);
    let { props } = this;
    return buildDayTableRenderRange({
      currentRange: renderRange,
      snapToWeek: /^(year|month)$/.test(currentRangeUnit),
      fixedWeekCount: props.fixedWeekCount,
      dateEnv: props.dateEnv
    });
  }
};
function buildDayTableRenderRange(props) {
  let { dateEnv, currentRange } = props;
  let { start, end } = currentRange;
  let endOfWeek;
  if (props.snapToWeek) {
    start = dateEnv.startOfWeek(start);
    endOfWeek = dateEnv.startOfWeek(end);
    if (endOfWeek.valueOf() !== end.valueOf()) {
      end = addWeeks(endOfWeek, 1);
    }
  }
  if (props.fixedWeekCount) {
    let lastMonthRenderStart = dateEnv.startOfWeek(dateEnv.startOfMonth(addDays(currentRange.end, -1)));
    let rowCnt = Math.ceil(
      // could be partial weeks due to hiddenDays
      diffWeeks(lastMonthRenderStart, end)
    );
    end = addWeeks(end, 6 - rowCnt);
  }
  return { start, end };
}
var css_248z2 = ':root{--fc-daygrid-event-dot-width:8px}.fc-daygrid-day-events:after,.fc-daygrid-day-events:before,.fc-daygrid-day-frame:after,.fc-daygrid-day-frame:before,.fc-daygrid-event-harness:after,.fc-daygrid-event-harness:before{clear:both;content:"";display:table}.fc .fc-daygrid-body{position:relative;z-index:1}.fc .fc-daygrid-day.fc-day-today{background-color:var(--fc-today-bg-color)}.fc .fc-daygrid-day-frame{min-height:100%;position:relative}.fc .fc-daygrid-day-top{display:flex;flex-direction:row-reverse}.fc .fc-day-other .fc-daygrid-day-top{opacity:.3}.fc .fc-daygrid-day-number{padding:4px;position:relative;z-index:4}.fc .fc-daygrid-month-start{font-size:1.1em;font-weight:700}.fc .fc-daygrid-day-events{margin-top:1px}.fc .fc-daygrid-body-balanced .fc-daygrid-day-events{left:0;position:absolute;right:0}.fc .fc-daygrid-body-unbalanced .fc-daygrid-day-events{min-height:2em;position:relative}.fc .fc-daygrid-body-natural .fc-daygrid-day-events{margin-bottom:1em}.fc .fc-daygrid-event-harness{position:relative}.fc .fc-daygrid-event-harness-abs{left:0;position:absolute;right:0;top:0}.fc .fc-daygrid-bg-harness{bottom:0;position:absolute;top:0}.fc .fc-daygrid-day-bg .fc-non-business{z-index:1}.fc .fc-daygrid-day-bg .fc-bg-event{z-index:2}.fc .fc-daygrid-day-bg .fc-highlight{z-index:3}.fc .fc-daygrid-event{margin-top:1px;z-index:6}.fc .fc-daygrid-event.fc-event-mirror{z-index:7}.fc .fc-daygrid-day-bottom{font-size:.85em;margin:0 2px}.fc .fc-daygrid-day-bottom:after,.fc .fc-daygrid-day-bottom:before{clear:both;content:"";display:table}.fc .fc-daygrid-more-link{border-radius:3px;cursor:pointer;line-height:1;margin-top:1px;max-width:100%;overflow:hidden;padding:2px;position:relative;white-space:nowrap;z-index:4}.fc .fc-daygrid-more-link:hover{background-color:rgba(0,0,0,.1)}.fc .fc-daygrid-week-number{background-color:var(--fc-neutral-bg-color);color:var(--fc-neutral-text-color);min-width:1.5em;padding:2px;position:absolute;text-align:center;top:0;z-index:5}.fc .fc-more-popover .fc-popover-body{min-width:220px;padding:10px}.fc-direction-ltr .fc-daygrid-event.fc-event-start,.fc-direction-rtl .fc-daygrid-event.fc-event-end{margin-left:2px}.fc-direction-ltr .fc-daygrid-event.fc-event-end,.fc-direction-rtl .fc-daygrid-event.fc-event-start{margin-right:2px}.fc-direction-ltr .fc-daygrid-more-link{float:left}.fc-direction-ltr .fc-daygrid-week-number{border-radius:0 0 3px 0;left:0}.fc-direction-rtl .fc-daygrid-more-link{float:right}.fc-direction-rtl .fc-daygrid-week-number{border-radius:0 0 0 3px;right:0}.fc-liquid-hack .fc-daygrid-day-frame{position:static}.fc-daygrid-event{border-radius:3px;font-size:var(--fc-small-font-size);position:relative;white-space:nowrap}.fc-daygrid-block-event .fc-event-time{font-weight:700}.fc-daygrid-block-event .fc-event-time,.fc-daygrid-block-event .fc-event-title{padding:1px}.fc-daygrid-dot-event{align-items:center;display:flex;padding:2px 0}.fc-daygrid-dot-event .fc-event-title{flex-grow:1;flex-shrink:1;font-weight:700;min-width:0;overflow:hidden}.fc-daygrid-dot-event.fc-event-mirror,.fc-daygrid-dot-event:hover{background:rgba(0,0,0,.1)}.fc-daygrid-dot-event.fc-event-selected:before{bottom:-10px;top:-10px}.fc-daygrid-event-dot{border:calc(var(--fc-daygrid-event-dot-width)/2) solid var(--fc-event-border-color);border-radius:calc(var(--fc-daygrid-event-dot-width)/2);box-sizing:content-box;height:0;margin:0 4px;width:0}.fc-direction-ltr .fc-daygrid-event .fc-event-time{margin-right:3px}.fc-direction-rtl .fc-daygrid-event .fc-event-time{margin-left:3px}';
injectStyles(css_248z2);

// node_modules/@fullcalendar/daygrid/index.js
var index = createPlugin({
  name: "@fullcalendar/daygrid",
  initialView: "dayGridMonth",
  views: {
    dayGrid: {
      component: DayTableView,
      dateProfileGeneratorClass: TableDateProfileGenerator
    },
    dayGridDay: {
      type: "dayGrid",
      duration: { days: 1 }
    },
    dayGridWeek: {
      type: "dayGrid",
      duration: { weeks: 1 }
    },
    dayGridMonth: {
      type: "dayGrid",
      duration: { months: 1 },
      fixedWeekCount: true
    },
    dayGridYear: {
      type: "dayGrid",
      duration: { years: 1 }
    }
  }
});

// node_modules/@fullcalendar/timegrid/internal.js
var AllDaySplitter = class extends Splitter {
  getKeyInfo() {
    return {
      allDay: {},
      timed: {}
    };
  }
  getKeysForDateSpan(dateSpan) {
    if (dateSpan.allDay) {
      return ["allDay"];
    }
    return ["timed"];
  }
  getKeysForEventDef(eventDef) {
    if (!eventDef.allDay) {
      return ["timed"];
    }
    if (hasBgRendering(eventDef)) {
      return ["timed", "allDay"];
    }
    return ["allDay"];
  }
};
var DEFAULT_SLAT_LABEL_FORMAT = createFormatter({
  hour: "numeric",
  minute: "2-digit",
  omitZeroMinute: true,
  meridiem: "short"
});
function TimeColsAxisCell(props) {
  let classNames = [
    "fc-timegrid-slot",
    "fc-timegrid-slot-label",
    props.isLabeled ? "fc-scrollgrid-shrink" : "fc-timegrid-slot-minor"
  ];
  return y(ViewContextType.Consumer, null, (context) => {
    if (!props.isLabeled) {
      return y("td", { className: classNames.join(" "), "data-time": props.isoTimeStr });
    }
    let { dateEnv, options, viewApi } = context;
    let labelFormat = (
      // TODO: fully pre-parse
      options.slotLabelFormat == null ? DEFAULT_SLAT_LABEL_FORMAT : Array.isArray(options.slotLabelFormat) ? createFormatter(options.slotLabelFormat[0]) : createFormatter(options.slotLabelFormat)
    );
    let renderProps = {
      level: 0,
      time: props.time,
      date: dateEnv.toDate(props.date),
      view: viewApi,
      text: dateEnv.format(props.date, labelFormat)
    };
    return y(ContentContainer, { elTag: "td", elClasses: classNames, elAttrs: {
      "data-time": props.isoTimeStr
    }, renderProps, generatorName: "slotLabelContent", customGenerator: options.slotLabelContent, defaultGenerator: renderInnerContent3, classNameGenerator: options.slotLabelClassNames, didMount: options.slotLabelDidMount, willUnmount: options.slotLabelWillUnmount }, (InnerContent) => y(
      "div",
      { className: "fc-timegrid-slot-label-frame fc-scrollgrid-shrink-frame" },
      y(InnerContent, { elTag: "div", elClasses: [
        "fc-timegrid-slot-label-cushion",
        "fc-scrollgrid-shrink-cushion"
      ] })
    ));
  });
}
function renderInnerContent3(props) {
  return props.text;
}
var TimeBodyAxis = class extends BaseComponent {
  render() {
    return this.props.slatMetas.map((slatMeta) => y(
      "tr",
      { key: slatMeta.key },
      y(TimeColsAxisCell, Object.assign({}, slatMeta))
    ));
  }
};
var DEFAULT_WEEK_NUM_FORMAT2 = createFormatter({ week: "short" });
var AUTO_ALL_DAY_MAX_EVENT_ROWS = 5;
var TimeColsView = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.allDaySplitter = new AllDaySplitter();
    this.headerElRef = d();
    this.rootElRef = d();
    this.scrollerElRef = d();
    this.state = {
      slatCoords: null
    };
    this.handleScrollTopRequest = (scrollTop) => {
      let scrollerEl = this.scrollerElRef.current;
      if (scrollerEl) {
        scrollerEl.scrollTop = scrollTop;
      }
    };
    this.renderHeadAxis = (rowKey, frameHeight = "") => {
      let { options } = this.context;
      let { dateProfile } = this.props;
      let range2 = dateProfile.renderRange;
      let dayCnt = diffDays(range2.start, range2.end);
      let navLinkAttrs = dayCnt === 1 ? buildNavLinkAttrs(this.context, range2.start, "week") : {};
      if (options.weekNumbers && rowKey === "day") {
        return y(WeekNumberContainer, { elTag: "th", elClasses: [
          "fc-timegrid-axis",
          "fc-scrollgrid-shrink"
        ], elAttrs: {
          "aria-hidden": true
        }, date: range2.start, defaultFormat: DEFAULT_WEEK_NUM_FORMAT2 }, (InnerContent) => y(
          "div",
          { className: [
            "fc-timegrid-axis-frame",
            "fc-scrollgrid-shrink-frame",
            "fc-timegrid-axis-frame-liquid"
          ].join(" "), style: { height: frameHeight } },
          y(InnerContent, { elTag: "a", elClasses: [
            "fc-timegrid-axis-cushion",
            "fc-scrollgrid-shrink-cushion",
            "fc-scrollgrid-sync-inner"
          ], elAttrs: navLinkAttrs })
        ));
      }
      return y(
        "th",
        { "aria-hidden": true, className: "fc-timegrid-axis" },
        y("div", { className: "fc-timegrid-axis-frame", style: { height: frameHeight } })
      );
    };
    this.renderTableRowAxis = (rowHeight) => {
      let { options, viewApi } = this.context;
      let renderProps = {
        text: options.allDayText,
        view: viewApi
      };
      return (
        // TODO: make reusable hook. used in list view too
        y(ContentContainer, { elTag: "td", elClasses: [
          "fc-timegrid-axis",
          "fc-scrollgrid-shrink"
        ], elAttrs: {
          "aria-hidden": true
        }, renderProps, generatorName: "allDayContent", customGenerator: options.allDayContent, defaultGenerator: renderAllDayInner, classNameGenerator: options.allDayClassNames, didMount: options.allDayDidMount, willUnmount: options.allDayWillUnmount }, (InnerContent) => y(
          "div",
          { className: [
            "fc-timegrid-axis-frame",
            "fc-scrollgrid-shrink-frame",
            rowHeight == null ? " fc-timegrid-axis-frame-liquid" : ""
          ].join(" "), style: { height: rowHeight } },
          y(InnerContent, { elTag: "span", elClasses: [
            "fc-timegrid-axis-cushion",
            "fc-scrollgrid-shrink-cushion",
            "fc-scrollgrid-sync-inner"
          ] })
        ))
      );
    };
    this.handleSlatCoords = (slatCoords) => {
      this.setState({ slatCoords });
    };
  }
  // rendering
  // ----------------------------------------------------------------------------------------------------
  renderSimpleLayout(headerRowContent, allDayContent, timeContent) {
    let { context, props } = this;
    let sections = [];
    let stickyHeaderDates = getStickyHeaderDates(context.options);
    if (headerRowContent) {
      sections.push({
        type: "header",
        key: "header",
        isSticky: stickyHeaderDates,
        chunk: {
          elRef: this.headerElRef,
          tableClassName: "fc-col-header",
          rowContent: headerRowContent
        }
      });
    }
    if (allDayContent) {
      sections.push({
        type: "body",
        key: "all-day",
        chunk: { content: allDayContent }
      });
      sections.push({
        type: "body",
        key: "all-day-divider",
        outerContent: (
          // TODO: rename to cellContent so don't need to define <tr>?
          y(
            "tr",
            { role: "presentation", className: "fc-scrollgrid-section" },
            y("td", { className: "fc-timegrid-divider " + context.theme.getClass("tableCellShaded") })
          )
        )
      });
    }
    sections.push({
      type: "body",
      key: "body",
      liquid: true,
      expandRows: Boolean(context.options.expandRows),
      chunk: {
        scrollerElRef: this.scrollerElRef,
        content: timeContent
      }
    });
    return y(
      ViewContainer,
      { elRef: this.rootElRef, elClasses: ["fc-timegrid"], viewSpec: context.viewSpec },
      y(SimpleScrollGrid, { liquid: !props.isHeightAuto && !props.forPrint, collapsibleWidth: props.forPrint, cols: [{ width: "shrink" }], sections })
    );
  }
  renderHScrollLayout(headerRowContent, allDayContent, timeContent, colCnt, dayMinWidth, slatMetas, slatCoords) {
    let ScrollGrid = this.context.pluginHooks.scrollGridImpl;
    if (!ScrollGrid) {
      throw new Error("No ScrollGrid implementation");
    }
    let { context, props } = this;
    let stickyHeaderDates = !props.forPrint && getStickyHeaderDates(context.options);
    let stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(context.options);
    let sections = [];
    if (headerRowContent) {
      sections.push({
        type: "header",
        key: "header",
        isSticky: stickyHeaderDates,
        syncRowHeights: true,
        chunks: [
          {
            key: "axis",
            rowContent: (arg) => y("tr", { role: "presentation" }, this.renderHeadAxis("day", arg.rowSyncHeights[0]))
          },
          {
            key: "cols",
            elRef: this.headerElRef,
            tableClassName: "fc-col-header",
            rowContent: headerRowContent
          }
        ]
      });
    }
    if (allDayContent) {
      sections.push({
        type: "body",
        key: "all-day",
        syncRowHeights: true,
        chunks: [
          {
            key: "axis",
            rowContent: (contentArg) => y("tr", { role: "presentation" }, this.renderTableRowAxis(contentArg.rowSyncHeights[0]))
          },
          {
            key: "cols",
            content: allDayContent
          }
        ]
      });
      sections.push({
        key: "all-day-divider",
        type: "body",
        outerContent: (
          // TODO: rename to cellContent so don't need to define <tr>?
          y(
            "tr",
            { role: "presentation", className: "fc-scrollgrid-section" },
            y("td", { colSpan: 2, className: "fc-timegrid-divider " + context.theme.getClass("tableCellShaded") })
          )
        )
      });
    }
    let isNowIndicator = context.options.nowIndicator;
    sections.push({
      type: "body",
      key: "body",
      liquid: true,
      expandRows: Boolean(context.options.expandRows),
      chunks: [
        {
          key: "axis",
          content: (arg) => (
            // TODO: make this now-indicator arrow more DRY with TimeColsContent
            y(
              "div",
              { className: "fc-timegrid-axis-chunk" },
              y(
                "table",
                { "aria-hidden": true, style: { height: arg.expandRows ? arg.clientHeight : "" } },
                arg.tableColGroupNode,
                y(
                  "tbody",
                  null,
                  y(TimeBodyAxis, { slatMetas })
                )
              ),
              y(
                "div",
                { className: "fc-timegrid-now-indicator-container" },
                y(NowTimer, {
                  unit: isNowIndicator ? "minute" : "day"
                  /* hacky */
                }, (nowDate) => {
                  let nowIndicatorTop = isNowIndicator && slatCoords && slatCoords.safeComputeTop(nowDate);
                  if (typeof nowIndicatorTop === "number") {
                    return y(NowIndicatorContainer, { elClasses: ["fc-timegrid-now-indicator-arrow"], elStyle: { top: nowIndicatorTop }, isAxis: true, date: nowDate });
                  }
                  return null;
                })
              )
            )
          )
        },
        {
          key: "cols",
          scrollerElRef: this.scrollerElRef,
          content: timeContent
        }
      ]
    });
    if (stickyFooterScrollbar) {
      sections.push({
        key: "footer",
        type: "footer",
        isSticky: true,
        chunks: [
          {
            key: "axis",
            content: renderScrollShim
          },
          {
            key: "cols",
            content: renderScrollShim
          }
        ]
      });
    }
    return y(
      ViewContainer,
      { elRef: this.rootElRef, elClasses: ["fc-timegrid"], viewSpec: context.viewSpec },
      y(ScrollGrid, { liquid: !props.isHeightAuto && !props.forPrint, forPrint: props.forPrint, collapsibleWidth: false, colGroups: [
        { width: "shrink", cols: [{ width: "shrink" }] },
        { cols: [{ span: colCnt, minWidth: dayMinWidth }] }
      ], sections })
    );
  }
  /* Dimensions
  ------------------------------------------------------------------------------------------------------------------*/
  getAllDayMaxEventProps() {
    let { dayMaxEvents, dayMaxEventRows } = this.context.options;
    if (dayMaxEvents === true || dayMaxEventRows === true) {
      dayMaxEvents = void 0;
      dayMaxEventRows = AUTO_ALL_DAY_MAX_EVENT_ROWS;
    }
    return { dayMaxEvents, dayMaxEventRows };
  }
};
function renderAllDayInner(renderProps) {
  return renderProps.text;
}
var TimeColsSlatsCoords = class {
  constructor(positions, dateProfile, slotDuration) {
    this.positions = positions;
    this.dateProfile = dateProfile;
    this.slotDuration = slotDuration;
  }
  safeComputeTop(date) {
    let { dateProfile } = this;
    if (rangeContainsMarker(dateProfile.currentRange, date)) {
      let startOfDayDate = startOfDay(date);
      let timeMs = date.valueOf() - startOfDayDate.valueOf();
      if (timeMs >= asRoughMs(dateProfile.slotMinTime) && timeMs < asRoughMs(dateProfile.slotMaxTime)) {
        return this.computeTimeTop(createDuration(timeMs));
      }
    }
    return null;
  }
  // Computes the top coordinate, relative to the bounds of the grid, of the given date.
  // A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.
  computeDateTop(when, startOfDayDate) {
    if (!startOfDayDate) {
      startOfDayDate = startOfDay(when);
    }
    return this.computeTimeTop(createDuration(when.valueOf() - startOfDayDate.valueOf()));
  }
  // Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).
  // This is a makeshify way to compute the time-top. Assumes all slatMetas dates are uniform.
  // Eventually allow computation with arbirary slat dates.
  computeTimeTop(duration) {
    let { positions, dateProfile } = this;
    let len = positions.els.length;
    let slatCoverage = (duration.milliseconds - asRoughMs(dateProfile.slotMinTime)) / asRoughMs(this.slotDuration);
    let slatIndex;
    let slatRemainder;
    slatCoverage = Math.max(0, slatCoverage);
    slatCoverage = Math.min(len, slatCoverage);
    slatIndex = Math.floor(slatCoverage);
    slatIndex = Math.min(slatIndex, len - 1);
    slatRemainder = slatCoverage - slatIndex;
    return positions.tops[slatIndex] + positions.getHeight(slatIndex) * slatRemainder;
  }
};
var TimeColsSlatsBody = class extends BaseComponent {
  render() {
    let { props, context } = this;
    let { options } = context;
    let { slatElRefs } = props;
    return y("tbody", null, props.slatMetas.map((slatMeta, i3) => {
      let renderProps = {
        time: slatMeta.time,
        date: context.dateEnv.toDate(slatMeta.date),
        view: context.viewApi
      };
      return y(
        "tr",
        { key: slatMeta.key, ref: slatElRefs.createRef(slatMeta.key) },
        props.axis && y(TimeColsAxisCell, Object.assign({}, slatMeta)),
        y(ContentContainer, { elTag: "td", elClasses: [
          "fc-timegrid-slot",
          "fc-timegrid-slot-lane",
          !slatMeta.isLabeled && "fc-timegrid-slot-minor"
        ], elAttrs: {
          "data-time": slatMeta.isoTimeStr
        }, renderProps, generatorName: "slotLaneContent", customGenerator: options.slotLaneContent, classNameGenerator: options.slotLaneClassNames, didMount: options.slotLaneDidMount, willUnmount: options.slotLaneWillUnmount })
      );
    }));
  }
};
var TimeColsSlats = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.rootElRef = d();
    this.slatElRefs = new RefMap();
  }
  render() {
    let { props, context } = this;
    return y(
      "div",
      { ref: this.rootElRef, className: "fc-timegrid-slots" },
      y(
        "table",
        { "aria-hidden": true, className: context.theme.getClass("table"), style: {
          minWidth: props.tableMinWidth,
          width: props.clientWidth,
          height: props.minHeight
        } },
        props.tableColGroupNode,
        y(TimeColsSlatsBody, { slatElRefs: this.slatElRefs, axis: props.axis, slatMetas: props.slatMetas })
      )
    );
  }
  componentDidMount() {
    this.updateSizing();
  }
  componentDidUpdate() {
    this.updateSizing();
  }
  componentWillUnmount() {
    if (this.props.onCoords) {
      this.props.onCoords(null);
    }
  }
  updateSizing() {
    let { context, props } = this;
    if (props.onCoords && props.clientWidth !== null) {
      let rootEl = this.rootElRef.current;
      if (rootEl.offsetHeight) {
        props.onCoords(new TimeColsSlatsCoords(new PositionCache(this.rootElRef.current, collectSlatEls(this.slatElRefs.currentMap, props.slatMetas), false, true), this.props.dateProfile, context.options.slotDuration));
      }
    }
  }
};
function collectSlatEls(elMap, slatMetas) {
  return slatMetas.map((slatMeta) => elMap[slatMeta.key]);
}
function splitSegsByCol(segs, colCnt) {
  let segsByCol = [];
  let i3;
  for (i3 = 0; i3 < colCnt; i3 += 1) {
    segsByCol.push([]);
  }
  if (segs) {
    for (i3 = 0; i3 < segs.length; i3 += 1) {
      segsByCol[segs[i3].col].push(segs[i3]);
    }
  }
  return segsByCol;
}
function splitInteractionByCol(ui, colCnt) {
  let byRow = [];
  if (!ui) {
    for (let i3 = 0; i3 < colCnt; i3 += 1) {
      byRow[i3] = null;
    }
  } else {
    for (let i3 = 0; i3 < colCnt; i3 += 1) {
      byRow[i3] = {
        affectedInstances: ui.affectedInstances,
        isEvent: ui.isEvent,
        segs: []
      };
    }
    for (let seg of ui.segs) {
      byRow[seg.col].segs.push(seg);
    }
  }
  return byRow;
}
var TimeColMoreLink = class extends BaseComponent {
  render() {
    let { props } = this;
    return y(MoreLinkContainer, { elClasses: ["fc-timegrid-more-link"], elStyle: {
      top: props.top,
      bottom: props.bottom
    }, allDayDate: null, moreCnt: props.hiddenSegs.length, allSegs: props.hiddenSegs, hiddenSegs: props.hiddenSegs, extraDateSpan: props.extraDateSpan, dateProfile: props.dateProfile, todayRange: props.todayRange, popoverContent: () => renderPlainFgSegs(props.hiddenSegs, props), defaultGenerator: renderMoreLinkInner2, forceTimed: true }, (InnerContent) => y(InnerContent, { elTag: "div", elClasses: ["fc-timegrid-more-link-inner", "fc-sticky"] }));
  }
};
function renderMoreLinkInner2(props) {
  return props.shortText;
}
function buildPositioning(segInputs, strictOrder, maxStackCnt) {
  let hierarchy = new SegHierarchy();
  if (strictOrder != null) {
    hierarchy.strictOrder = strictOrder;
  }
  if (maxStackCnt != null) {
    hierarchy.maxStackCnt = maxStackCnt;
  }
  let hiddenEntries = hierarchy.addSegs(segInputs);
  let hiddenGroups = groupIntersectingEntries(hiddenEntries);
  let web = buildWeb(hierarchy);
  web = stretchWeb(web, 1);
  let segRects = webToRects(web);
  return { segRects, hiddenGroups };
}
function buildWeb(hierarchy) {
  const { entriesByLevel } = hierarchy;
  const buildNode = cacheable((level, lateral) => level + ":" + lateral, (level, lateral) => {
    let siblingRange = findNextLevelSegs(hierarchy, level, lateral);
    let nextLevelRes = buildNodes(siblingRange, buildNode);
    let entry = entriesByLevel[level][lateral];
    return [
      Object.assign(Object.assign({}, entry), { nextLevelNodes: nextLevelRes[0] }),
      entry.thickness + nextLevelRes[1]
      // the pressure builds
    ];
  });
  return buildNodes(entriesByLevel.length ? { level: 0, lateralStart: 0, lateralEnd: entriesByLevel[0].length } : null, buildNode)[0];
}
function buildNodes(siblingRange, buildNode) {
  if (!siblingRange) {
    return [[], 0];
  }
  let { level, lateralStart, lateralEnd } = siblingRange;
  let lateral = lateralStart;
  let pairs = [];
  while (lateral < lateralEnd) {
    pairs.push(buildNode(level, lateral));
    lateral += 1;
  }
  pairs.sort(cmpDescPressures);
  return [
    pairs.map(extractNode),
    pairs[0][1]
    // first item's pressure
  ];
}
function cmpDescPressures(a3, b3) {
  return b3[1] - a3[1];
}
function extractNode(a3) {
  return a3[0];
}
function findNextLevelSegs(hierarchy, subjectLevel, subjectLateral) {
  let { levelCoords, entriesByLevel } = hierarchy;
  let subjectEntry = entriesByLevel[subjectLevel][subjectLateral];
  let afterSubject = levelCoords[subjectLevel] + subjectEntry.thickness;
  let levelCnt = levelCoords.length;
  let level = subjectLevel;
  for (; level < levelCnt && levelCoords[level] < afterSubject; level += 1)
    ;
  for (; level < levelCnt; level += 1) {
    let entries = entriesByLevel[level];
    let entry;
    let searchIndex = binarySearch(entries, subjectEntry.span.start, getEntrySpanEnd);
    let lateralStart = searchIndex[0] + searchIndex[1];
    let lateralEnd = lateralStart;
    while (
      // loop through entries that horizontally intersect
      (entry = entries[lateralEnd]) && // but not past the whole seg list
      entry.span.start < subjectEntry.span.end
    ) {
      lateralEnd += 1;
    }
    if (lateralStart < lateralEnd) {
      return { level, lateralStart, lateralEnd };
    }
  }
  return null;
}
function stretchWeb(topLevelNodes, totalThickness) {
  const stretchNode = cacheable((node, startCoord, prevThickness) => buildEntryKey(node), (node, startCoord, prevThickness) => {
    let { nextLevelNodes, thickness } = node;
    let allThickness = thickness + prevThickness;
    let thicknessFraction = thickness / allThickness;
    let endCoord;
    let newChildren = [];
    if (!nextLevelNodes.length) {
      endCoord = totalThickness;
    } else {
      for (let childNode of nextLevelNodes) {
        if (endCoord === void 0) {
          let res = stretchNode(childNode, startCoord, allThickness);
          endCoord = res[0];
          newChildren.push(res[1]);
        } else {
          let res = stretchNode(childNode, endCoord, 0);
          newChildren.push(res[1]);
        }
      }
    }
    let newThickness = (endCoord - startCoord) * thicknessFraction;
    return [endCoord - newThickness, Object.assign(Object.assign({}, node), { thickness: newThickness, nextLevelNodes: newChildren })];
  });
  return topLevelNodes.map((node) => stretchNode(node, 0, 0)[1]);
}
function webToRects(topLevelNodes) {
  let rects = [];
  const processNode = cacheable((node, levelCoord, stackDepth) => buildEntryKey(node), (node, levelCoord, stackDepth) => {
    let rect = Object.assign(Object.assign({}, node), {
      levelCoord,
      stackDepth,
      stackForward: 0
    });
    rects.push(rect);
    return rect.stackForward = processNodes(node.nextLevelNodes, levelCoord + node.thickness, stackDepth + 1) + 1;
  });
  function processNodes(nodes, levelCoord, stackDepth) {
    let stackForward = 0;
    for (let node of nodes) {
      stackForward = Math.max(processNode(node, levelCoord, stackDepth), stackForward);
    }
    return stackForward;
  }
  processNodes(topLevelNodes, 0, 0);
  return rects;
}
function cacheable(keyFunc, workFunc) {
  const cache = {};
  return (...args) => {
    let key = keyFunc(...args);
    return key in cache ? cache[key] : cache[key] = workFunc(...args);
  };
}
function computeSegVCoords(segs, colDate, slatCoords = null, eventMinHeight = 0) {
  let vcoords = [];
  if (slatCoords) {
    for (let i3 = 0; i3 < segs.length; i3 += 1) {
      let seg = segs[i3];
      let spanStart = slatCoords.computeDateTop(seg.start, colDate);
      let spanEnd = Math.max(
        spanStart + (eventMinHeight || 0),
        // :(
        slatCoords.computeDateTop(seg.end, colDate)
      );
      vcoords.push({
        start: Math.round(spanStart),
        end: Math.round(spanEnd)
        //
      });
    }
  }
  return vcoords;
}
function computeFgSegPlacements(segs, segVCoords, eventOrderStrict, eventMaxStack) {
  let segInputs = [];
  let dumbSegs = [];
  for (let i3 = 0; i3 < segs.length; i3 += 1) {
    let vcoords = segVCoords[i3];
    if (vcoords) {
      segInputs.push({
        index: i3,
        thickness: 1,
        span: vcoords
      });
    } else {
      dumbSegs.push(segs[i3]);
    }
  }
  let { segRects, hiddenGroups } = buildPositioning(segInputs, eventOrderStrict, eventMaxStack);
  let segPlacements = [];
  for (let segRect of segRects) {
    segPlacements.push({
      seg: segs[segRect.index],
      rect: segRect
    });
  }
  for (let dumbSeg of dumbSegs) {
    segPlacements.push({ seg: dumbSeg, rect: null });
  }
  return { segPlacements, hiddenGroups };
}
var DEFAULT_TIME_FORMAT = createFormatter({
  hour: "numeric",
  minute: "2-digit",
  meridiem: false
});
var TimeColEvent = class extends BaseComponent {
  render() {
    return y(StandardEvent, Object.assign({}, this.props, { elClasses: [
      "fc-timegrid-event",
      "fc-v-event",
      this.props.isShort && "fc-timegrid-event-short"
    ], defaultTimeFormat: DEFAULT_TIME_FORMAT }));
  }
};
var TimeCol = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.sortEventSegs = memoize(sortEventSegs);
  }
  // TODO: memoize event-placement?
  render() {
    let { props, context } = this;
    let { options } = context;
    let isSelectMirror = options.selectMirror;
    let mirrorSegs = (
      // yuck
      props.eventDrag && props.eventDrag.segs || props.eventResize && props.eventResize.segs || isSelectMirror && props.dateSelectionSegs || []
    );
    let interactionAffectedInstances = (
      // TODO: messy way to compute this
      props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {}
    );
    let sortedFgSegs = this.sortEventSegs(props.fgEventSegs, options.eventOrder);
    return y(DayCellContainer, { elTag: "td", elRef: props.elRef, elClasses: [
      "fc-timegrid-col",
      ...props.extraClassNames || []
    ], elAttrs: Object.assign({ role: "gridcell" }, props.extraDataAttrs), date: props.date, dateProfile: props.dateProfile, todayRange: props.todayRange, extraRenderProps: props.extraRenderProps }, (InnerContent) => y(
      "div",
      { className: "fc-timegrid-col-frame" },
      y(
        "div",
        { className: "fc-timegrid-col-bg" },
        this.renderFillSegs(props.businessHourSegs, "non-business"),
        this.renderFillSegs(props.bgEventSegs, "bg-event"),
        this.renderFillSegs(props.dateSelectionSegs, "highlight")
      ),
      y("div", { className: "fc-timegrid-col-events" }, this.renderFgSegs(sortedFgSegs, interactionAffectedInstances, false, false, false)),
      y("div", { className: "fc-timegrid-col-events" }, this.renderFgSegs(mirrorSegs, {}, Boolean(props.eventDrag), Boolean(props.eventResize), Boolean(isSelectMirror), "mirror")),
      y("div", { className: "fc-timegrid-now-indicator-container" }, this.renderNowIndicator(props.nowIndicatorSegs)),
      hasCustomDayCellContent(options) && y(InnerContent, { elTag: "div", elClasses: ["fc-timegrid-col-misc"] })
    ));
  }
  renderFgSegs(sortedFgSegs, segIsInvisible, isDragging, isResizing, isDateSelecting, forcedKey) {
    let { props } = this;
    if (props.forPrint) {
      return renderPlainFgSegs(sortedFgSegs, props);
    }
    return this.renderPositionedFgSegs(sortedFgSegs, segIsInvisible, isDragging, isResizing, isDateSelecting, forcedKey);
  }
  renderPositionedFgSegs(segs, segIsInvisible, isDragging, isResizing, isDateSelecting, forcedKey) {
    let { eventMaxStack, eventShortHeight, eventOrderStrict, eventMinHeight } = this.context.options;
    let { date, slatCoords, eventSelection, todayRange, nowDate } = this.props;
    let isMirror = isDragging || isResizing || isDateSelecting;
    let segVCoords = computeSegVCoords(segs, date, slatCoords, eventMinHeight);
    let { segPlacements, hiddenGroups } = computeFgSegPlacements(segs, segVCoords, eventOrderStrict, eventMaxStack);
    return y(
      _,
      null,
      this.renderHiddenGroups(hiddenGroups, segs),
      segPlacements.map((segPlacement) => {
        let { seg, rect } = segPlacement;
        let instanceId = seg.eventRange.instance.instanceId;
        let isVisible = isMirror || Boolean(!segIsInvisible[instanceId] && rect);
        let vStyle = computeSegVStyle(rect && rect.span);
        let hStyle = !isMirror && rect ? this.computeSegHStyle(rect) : { left: 0, right: 0 };
        let isInset = Boolean(rect) && rect.stackForward > 0;
        let isShort = Boolean(rect) && rect.span.end - rect.span.start < eventShortHeight;
        return y(
          "div",
          { className: "fc-timegrid-event-harness" + (isInset ? " fc-timegrid-event-harness-inset" : ""), key: forcedKey || instanceId, style: Object.assign(Object.assign({ visibility: isVisible ? "" : "hidden" }, vStyle), hStyle) },
          y(TimeColEvent, Object.assign({ seg, isDragging, isResizing, isDateSelecting, isSelected: instanceId === eventSelection, isShort }, getSegMeta(seg, todayRange, nowDate)))
        );
      })
    );
  }
  // will already have eventMinHeight applied because segInputs already had it
  renderHiddenGroups(hiddenGroups, segs) {
    let { extraDateSpan, dateProfile, todayRange, nowDate, eventSelection, eventDrag, eventResize } = this.props;
    return y(_, null, hiddenGroups.map((hiddenGroup) => {
      let positionCss = computeSegVStyle(hiddenGroup.span);
      let hiddenSegs = compileSegsFromEntries(hiddenGroup.entries, segs);
      return y(TimeColMoreLink, { key: buildIsoString(computeEarliestSegStart(hiddenSegs)), hiddenSegs, top: positionCss.top, bottom: positionCss.bottom, extraDateSpan, dateProfile, todayRange, nowDate, eventSelection, eventDrag, eventResize });
    }));
  }
  renderFillSegs(segs, fillType) {
    let { props, context } = this;
    let segVCoords = computeSegVCoords(segs, props.date, props.slatCoords, context.options.eventMinHeight);
    let children = segVCoords.map((vcoords, i3) => {
      let seg = segs[i3];
      return y("div", { key: buildEventRangeKey(seg.eventRange), className: "fc-timegrid-bg-harness", style: computeSegVStyle(vcoords) }, fillType === "bg-event" ? y(BgEvent, Object.assign({ seg }, getSegMeta(seg, props.todayRange, props.nowDate))) : renderFill(fillType));
    });
    return y(_, null, children);
  }
  renderNowIndicator(segs) {
    let { slatCoords, date } = this.props;
    if (!slatCoords) {
      return null;
    }
    return segs.map((seg, i3) => y(
      NowIndicatorContainer,
      {
        // key doesn't matter. will only ever be one
        key: i3,
        elClasses: ["fc-timegrid-now-indicator-line"],
        elStyle: {
          top: slatCoords.computeDateTop(seg.start, date)
        },
        isAxis: false,
        date
      }
    ));
  }
  computeSegHStyle(segHCoords) {
    let { isRtl, options } = this.context;
    let shouldOverlap = options.slotEventOverlap;
    let nearCoord = segHCoords.levelCoord;
    let farCoord = segHCoords.levelCoord + segHCoords.thickness;
    let left;
    let right;
    if (shouldOverlap) {
      farCoord = Math.min(1, nearCoord + (farCoord - nearCoord) * 2);
    }
    if (isRtl) {
      left = 1 - farCoord;
      right = nearCoord;
    } else {
      left = nearCoord;
      right = 1 - farCoord;
    }
    let props = {
      zIndex: segHCoords.stackDepth + 1,
      left: left * 100 + "%",
      right: right * 100 + "%"
    };
    if (shouldOverlap && !segHCoords.stackForward) {
      props[isRtl ? "marginLeft" : "marginRight"] = 10 * 2;
    }
    return props;
  }
};
function renderPlainFgSegs(sortedFgSegs, { todayRange, nowDate, eventSelection, eventDrag, eventResize }) {
  let hiddenInstances = (eventDrag ? eventDrag.affectedInstances : null) || (eventResize ? eventResize.affectedInstances : null) || {};
  return y(_, null, sortedFgSegs.map((seg) => {
    let instanceId = seg.eventRange.instance.instanceId;
    return y(
      "div",
      { key: instanceId, style: { visibility: hiddenInstances[instanceId] ? "hidden" : "" } },
      y(TimeColEvent, Object.assign({ seg, isDragging: false, isResizing: false, isDateSelecting: false, isSelected: instanceId === eventSelection, isShort: false }, getSegMeta(seg, todayRange, nowDate)))
    );
  }));
}
function computeSegVStyle(segVCoords) {
  if (!segVCoords) {
    return { top: "", bottom: "" };
  }
  return {
    top: segVCoords.start,
    bottom: -segVCoords.end
  };
}
function compileSegsFromEntries(segEntries, allSegs) {
  return segEntries.map((segEntry) => allSegs[segEntry.index]);
}
var TimeColsContent = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.splitFgEventSegs = memoize(splitSegsByCol);
    this.splitBgEventSegs = memoize(splitSegsByCol);
    this.splitBusinessHourSegs = memoize(splitSegsByCol);
    this.splitNowIndicatorSegs = memoize(splitSegsByCol);
    this.splitDateSelectionSegs = memoize(splitSegsByCol);
    this.splitEventDrag = memoize(splitInteractionByCol);
    this.splitEventResize = memoize(splitInteractionByCol);
    this.rootElRef = d();
    this.cellElRefs = new RefMap();
  }
  render() {
    let { props, context } = this;
    let nowIndicatorTop = context.options.nowIndicator && props.slatCoords && props.slatCoords.safeComputeTop(props.nowDate);
    let colCnt = props.cells.length;
    let fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, colCnt);
    let bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, colCnt);
    let businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, colCnt);
    let nowIndicatorSegsByRow = this.splitNowIndicatorSegs(props.nowIndicatorSegs, colCnt);
    let dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, colCnt);
    let eventDragByRow = this.splitEventDrag(props.eventDrag, colCnt);
    let eventResizeByRow = this.splitEventResize(props.eventResize, colCnt);
    return y(
      "div",
      { className: "fc-timegrid-cols", ref: this.rootElRef },
      y(
        "table",
        { role: "presentation", style: {
          minWidth: props.tableMinWidth,
          width: props.clientWidth
        } },
        props.tableColGroupNode,
        y(
          "tbody",
          { role: "presentation" },
          y(
            "tr",
            { role: "row" },
            props.axis && y(
              "td",
              { "aria-hidden": true, className: "fc-timegrid-col fc-timegrid-axis" },
              y(
                "div",
                { className: "fc-timegrid-col-frame" },
                y("div", { className: "fc-timegrid-now-indicator-container" }, typeof nowIndicatorTop === "number" && y(NowIndicatorContainer, { elClasses: ["fc-timegrid-now-indicator-arrow"], elStyle: { top: nowIndicatorTop }, isAxis: true, date: props.nowDate }))
              )
            ),
            props.cells.map((cell, i3) => y(TimeCol, { key: cell.key, elRef: this.cellElRefs.createRef(cell.key), dateProfile: props.dateProfile, date: cell.date, nowDate: props.nowDate, todayRange: props.todayRange, extraRenderProps: cell.extraRenderProps, extraDataAttrs: cell.extraDataAttrs, extraClassNames: cell.extraClassNames, extraDateSpan: cell.extraDateSpan, fgEventSegs: fgEventSegsByRow[i3], bgEventSegs: bgEventSegsByRow[i3], businessHourSegs: businessHourSegsByRow[i3], nowIndicatorSegs: nowIndicatorSegsByRow[i3], dateSelectionSegs: dateSelectionSegsByRow[i3], eventDrag: eventDragByRow[i3], eventResize: eventResizeByRow[i3], slatCoords: props.slatCoords, eventSelection: props.eventSelection, forPrint: props.forPrint }))
          )
        )
      )
    );
  }
  componentDidMount() {
    this.updateCoords();
  }
  componentDidUpdate() {
    this.updateCoords();
  }
  updateCoords() {
    let { props } = this;
    if (props.onColCoords && props.clientWidth !== null) {
      props.onColCoords(new PositionCache(
        this.rootElRef.current,
        collectCellEls(this.cellElRefs.currentMap, props.cells),
        true,
        // horizontal
        false
      ));
    }
  }
};
function collectCellEls(elMap, cells) {
  return cells.map((cell) => elMap[cell.key]);
}
var TimeCols = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.processSlotOptions = memoize(processSlotOptions);
    this.state = {
      slatCoords: null
    };
    this.handleRootEl = (el) => {
      if (el) {
        this.context.registerInteractiveComponent(this, {
          el,
          isHitComboAllowed: this.props.isHitComboAllowed
        });
      } else {
        this.context.unregisterInteractiveComponent(this);
      }
    };
    this.handleScrollRequest = (request) => {
      let { onScrollTopRequest } = this.props;
      let { slatCoords } = this.state;
      if (onScrollTopRequest && slatCoords) {
        if (request.time) {
          let top = slatCoords.computeTimeTop(request.time);
          top = Math.ceil(top);
          if (top) {
            top += 1;
          }
          onScrollTopRequest(top);
        }
        return true;
      }
      return false;
    };
    this.handleColCoords = (colCoords) => {
      this.colCoords = colCoords;
    };
    this.handleSlatCoords = (slatCoords) => {
      this.setState({ slatCoords });
      if (this.props.onSlatCoords) {
        this.props.onSlatCoords(slatCoords);
      }
    };
  }
  render() {
    let { props, state } = this;
    return y(
      "div",
      { className: "fc-timegrid-body", ref: this.handleRootEl, style: {
        // these props are important to give this wrapper correct dimensions for interactions
        // TODO: if we set it here, can we avoid giving to inner tables?
        width: props.clientWidth,
        minWidth: props.tableMinWidth
      } },
      y(TimeColsSlats, { axis: props.axis, dateProfile: props.dateProfile, slatMetas: props.slatMetas, clientWidth: props.clientWidth, minHeight: props.expandRows ? props.clientHeight : "", tableMinWidth: props.tableMinWidth, tableColGroupNode: props.axis ? props.tableColGroupNode : null, onCoords: this.handleSlatCoords }),
      y(TimeColsContent, { cells: props.cells, axis: props.axis, dateProfile: props.dateProfile, businessHourSegs: props.businessHourSegs, bgEventSegs: props.bgEventSegs, fgEventSegs: props.fgEventSegs, dateSelectionSegs: props.dateSelectionSegs, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, todayRange: props.todayRange, nowDate: props.nowDate, nowIndicatorSegs: props.nowIndicatorSegs, clientWidth: props.clientWidth, tableMinWidth: props.tableMinWidth, tableColGroupNode: props.tableColGroupNode, slatCoords: state.slatCoords, onColCoords: this.handleColCoords, forPrint: props.forPrint })
    );
  }
  componentDidMount() {
    this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest);
  }
  componentDidUpdate(prevProps) {
    this.scrollResponder.update(prevProps.dateProfile !== this.props.dateProfile);
  }
  componentWillUnmount() {
    this.scrollResponder.detach();
  }
  queryHit(positionLeft, positionTop) {
    let { dateEnv, options } = this.context;
    let { colCoords } = this;
    let { dateProfile } = this.props;
    let { slatCoords } = this.state;
    let { snapDuration, snapsPerSlot } = this.processSlotOptions(this.props.slotDuration, options.snapDuration);
    let colIndex = colCoords.leftToIndex(positionLeft);
    let slatIndex = slatCoords.positions.topToIndex(positionTop);
    if (colIndex != null && slatIndex != null) {
      let cell = this.props.cells[colIndex];
      let slatTop = slatCoords.positions.tops[slatIndex];
      let slatHeight = slatCoords.positions.getHeight(slatIndex);
      let partial = (positionTop - slatTop) / slatHeight;
      let localSnapIndex = Math.floor(partial * snapsPerSlot);
      let snapIndex = slatIndex * snapsPerSlot + localSnapIndex;
      let dayDate = this.props.cells[colIndex].date;
      let time = addDurations(dateProfile.slotMinTime, multiplyDuration(snapDuration, snapIndex));
      let start = dateEnv.add(dayDate, time);
      let end = dateEnv.add(start, snapDuration);
      return {
        dateProfile,
        dateSpan: Object.assign({ range: { start, end }, allDay: false }, cell.extraDateSpan),
        dayEl: colCoords.els[colIndex],
        rect: {
          left: colCoords.lefts[colIndex],
          right: colCoords.rights[colIndex],
          top: slatTop,
          bottom: slatTop + slatHeight
        },
        layer: 0
      };
    }
    return null;
  }
};
function processSlotOptions(slotDuration, snapDurationOverride) {
  let snapDuration = snapDurationOverride || slotDuration;
  let snapsPerSlot = wholeDivideDurations(slotDuration, snapDuration);
  if (snapsPerSlot === null) {
    snapDuration = slotDuration;
    snapsPerSlot = 1;
  }
  return { snapDuration, snapsPerSlot };
}
var DayTimeColsSlicer = class extends Slicer {
  sliceRange(range2, dayRanges) {
    let segs = [];
    for (let col = 0; col < dayRanges.length; col += 1) {
      let segRange = intersectRanges(range2, dayRanges[col]);
      if (segRange) {
        segs.push({
          start: segRange.start,
          end: segRange.end,
          isStart: segRange.start.valueOf() === range2.start.valueOf(),
          isEnd: segRange.end.valueOf() === range2.end.valueOf(),
          col
        });
      }
    }
    return segs;
  }
};
var DayTimeCols = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.buildDayRanges = memoize(buildDayRanges);
    this.slicer = new DayTimeColsSlicer();
    this.timeColsRef = d();
  }
  render() {
    let { props, context } = this;
    let { dateProfile, dayTableModel } = props;
    let { nowIndicator, nextDayThreshold } = context.options;
    let dayRanges = this.buildDayRanges(dayTableModel, dateProfile, context.dateEnv);
    return y(NowTimer, { unit: nowIndicator ? "minute" : "day" }, (nowDate, todayRange) => y(TimeCols, Object.assign({ ref: this.timeColsRef }, this.slicer.sliceProps(props, dateProfile, null, context, dayRanges), { forPrint: props.forPrint, axis: props.axis, dateProfile, slatMetas: props.slatMetas, slotDuration: props.slotDuration, cells: dayTableModel.cells[0], tableColGroupNode: props.tableColGroupNode, tableMinWidth: props.tableMinWidth, clientWidth: props.clientWidth, clientHeight: props.clientHeight, expandRows: props.expandRows, nowDate, nowIndicatorSegs: nowIndicator && this.slicer.sliceNowDate(nowDate, dateProfile, nextDayThreshold, context, dayRanges), todayRange, onScrollTopRequest: props.onScrollTopRequest, onSlatCoords: props.onSlatCoords })));
  }
};
function buildDayRanges(dayTableModel, dateProfile, dateEnv) {
  let ranges = [];
  for (let date of dayTableModel.headerDates) {
    ranges.push({
      start: dateEnv.add(date, dateProfile.slotMinTime),
      end: dateEnv.add(date, dateProfile.slotMaxTime)
    });
  }
  return ranges;
}
var STOCK_SUB_DURATIONS = [
  { hours: 1 },
  { minutes: 30 },
  { minutes: 15 },
  { seconds: 30 },
  { seconds: 15 }
];
function buildSlatMetas(slotMinTime, slotMaxTime, explicitLabelInterval, slotDuration, dateEnv) {
  let dayStart = new Date(0);
  let slatTime = slotMinTime;
  let slatIterator = createDuration(0);
  let labelInterval = explicitLabelInterval || computeLabelInterval(slotDuration);
  let metas = [];
  while (asRoughMs(slatTime) < asRoughMs(slotMaxTime)) {
    let date = dateEnv.add(dayStart, slatTime);
    let isLabeled = wholeDivideDurations(slatIterator, labelInterval) !== null;
    metas.push({
      date,
      time: slatTime,
      key: date.toISOString(),
      isoTimeStr: formatIsoTimeString(date),
      isLabeled
    });
    slatTime = addDurations(slatTime, slotDuration);
    slatIterator = addDurations(slatIterator, slotDuration);
  }
  return metas;
}
function computeLabelInterval(slotDuration) {
  let i3;
  let labelInterval;
  let slotsPerLabel;
  for (i3 = STOCK_SUB_DURATIONS.length - 1; i3 >= 0; i3 -= 1) {
    labelInterval = createDuration(STOCK_SUB_DURATIONS[i3]);
    slotsPerLabel = wholeDivideDurations(labelInterval, slotDuration);
    if (slotsPerLabel !== null && slotsPerLabel > 1) {
      return labelInterval;
    }
  }
  return slotDuration;
}
var DayTimeColsView = class extends TimeColsView {
  constructor() {
    super(...arguments);
    this.buildTimeColsModel = memoize(buildTimeColsModel);
    this.buildSlatMetas = memoize(buildSlatMetas);
  }
  render() {
    let { options, dateEnv, dateProfileGenerator } = this.context;
    let { props } = this;
    let { dateProfile } = props;
    let dayTableModel = this.buildTimeColsModel(dateProfile, dateProfileGenerator);
    let splitProps = this.allDaySplitter.splitProps(props);
    let slatMetas = this.buildSlatMetas(dateProfile.slotMinTime, dateProfile.slotMaxTime, options.slotLabelInterval, options.slotDuration, dateEnv);
    let { dayMinWidth } = options;
    let hasAttachedAxis = !dayMinWidth;
    let hasDetachedAxis = dayMinWidth;
    let headerContent = options.dayHeaders && y(DayHeader, { dates: dayTableModel.headerDates, dateProfile, datesRepDistinctDays: true, renderIntro: hasAttachedAxis ? this.renderHeadAxis : null });
    let allDayContent = options.allDaySlot !== false && ((contentArg) => y(DayTable, Object.assign({}, splitProps.allDay, { dateProfile, dayTableModel, nextDayThreshold: options.nextDayThreshold, tableMinWidth: contentArg.tableMinWidth, colGroupNode: contentArg.tableColGroupNode, renderRowIntro: hasAttachedAxis ? this.renderTableRowAxis : null, showWeekNumbers: false, expandRows: false, headerAlignElRef: this.headerElRef, clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, forPrint: props.forPrint }, this.getAllDayMaxEventProps())));
    let timeGridContent = (contentArg) => y(DayTimeCols, Object.assign({}, splitProps.timed, { dayTableModel, dateProfile, axis: hasAttachedAxis, slotDuration: options.slotDuration, slatMetas, forPrint: props.forPrint, tableColGroupNode: contentArg.tableColGroupNode, tableMinWidth: contentArg.tableMinWidth, clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, onSlatCoords: this.handleSlatCoords, expandRows: contentArg.expandRows, onScrollTopRequest: this.handleScrollTopRequest }));
    return hasDetachedAxis ? this.renderHScrollLayout(headerContent, allDayContent, timeGridContent, dayTableModel.colCnt, dayMinWidth, slatMetas, this.state.slatCoords) : this.renderSimpleLayout(headerContent, allDayContent, timeGridContent);
  }
};
function buildTimeColsModel(dateProfile, dateProfileGenerator) {
  let daySeries = new DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);
  return new DayTableModel(daySeries, false);
}
var css_248z3 = '.fc-v-event{background-color:var(--fc-event-bg-color);border:1px solid var(--fc-event-border-color);display:block}.fc-v-event .fc-event-main{color:var(--fc-event-text-color);height:100%}.fc-v-event .fc-event-main-frame{display:flex;flex-direction:column;height:100%}.fc-v-event .fc-event-time{flex-grow:0;flex-shrink:0;max-height:100%;overflow:hidden}.fc-v-event .fc-event-title-container{flex-grow:1;flex-shrink:1;min-height:0}.fc-v-event .fc-event-title{bottom:0;max-height:100%;overflow:hidden;top:0}.fc-v-event:not(.fc-event-start){border-top-left-radius:0;border-top-right-radius:0;border-top-width:0}.fc-v-event:not(.fc-event-end){border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom-width:0}.fc-v-event.fc-event-selected:before{left:-10px;right:-10px}.fc-v-event .fc-event-resizer-start{cursor:n-resize}.fc-v-event .fc-event-resizer-end{cursor:s-resize}.fc-v-event:not(.fc-event-selected) .fc-event-resizer{height:var(--fc-event-resizer-thickness);left:0;right:0}.fc-v-event:not(.fc-event-selected) .fc-event-resizer-start{top:calc(var(--fc-event-resizer-thickness)/-2)}.fc-v-event:not(.fc-event-selected) .fc-event-resizer-end{bottom:calc(var(--fc-event-resizer-thickness)/-2)}.fc-v-event.fc-event-selected .fc-event-resizer{left:50%;margin-left:calc(var(--fc-event-resizer-dot-total-width)/-2)}.fc-v-event.fc-event-selected .fc-event-resizer-start{top:calc(var(--fc-event-resizer-dot-total-width)/-2)}.fc-v-event.fc-event-selected .fc-event-resizer-end{bottom:calc(var(--fc-event-resizer-dot-total-width)/-2)}.fc .fc-timegrid .fc-daygrid-body{z-index:2}.fc .fc-timegrid-divider{padding:0 0 2px}.fc .fc-timegrid-body{min-height:100%;position:relative;z-index:1}.fc .fc-timegrid-axis-chunk{position:relative}.fc .fc-timegrid-axis-chunk>table,.fc .fc-timegrid-slots{position:relative;z-index:1}.fc .fc-timegrid-slot{border-bottom:0;height:1.5em}.fc .fc-timegrid-slot:empty:before{content:"\\00a0"}.fc .fc-timegrid-slot-minor{border-top-style:dotted}.fc .fc-timegrid-slot-label-cushion{display:inline-block;white-space:nowrap}.fc .fc-timegrid-slot-label{vertical-align:middle}.fc .fc-timegrid-axis-cushion,.fc .fc-timegrid-slot-label-cushion{padding:0 4px}.fc .fc-timegrid-axis-frame-liquid{height:100%}.fc .fc-timegrid-axis-frame{align-items:center;display:flex;justify-content:flex-end;overflow:hidden}.fc .fc-timegrid-axis-cushion{flex-shrink:0;max-width:60px}.fc-direction-ltr .fc-timegrid-slot-label-frame{text-align:right}.fc-direction-rtl .fc-timegrid-slot-label-frame{text-align:left}.fc-liquid-hack .fc-timegrid-axis-frame-liquid{bottom:0;height:auto;left:0;position:absolute;right:0;top:0}.fc .fc-timegrid-col.fc-day-today{background-color:var(--fc-today-bg-color)}.fc .fc-timegrid-col-frame{min-height:100%;position:relative}.fc-media-screen.fc-liquid-hack .fc-timegrid-col-frame{bottom:0;height:auto;left:0;position:absolute;right:0;top:0}.fc-media-screen .fc-timegrid-cols{bottom:0;left:0;position:absolute;right:0;top:0}.fc-media-screen .fc-timegrid-cols>table{height:100%}.fc-media-screen .fc-timegrid-col-bg,.fc-media-screen .fc-timegrid-col-events,.fc-media-screen .fc-timegrid-now-indicator-container{left:0;position:absolute;right:0;top:0}.fc .fc-timegrid-col-bg{z-index:2}.fc .fc-timegrid-col-bg .fc-non-business{z-index:1}.fc .fc-timegrid-col-bg .fc-bg-event{z-index:2}.fc .fc-timegrid-col-bg .fc-highlight{z-index:3}.fc .fc-timegrid-bg-harness{left:0;position:absolute;right:0}.fc .fc-timegrid-col-events{z-index:3}.fc .fc-timegrid-now-indicator-container{bottom:0;overflow:hidden}.fc-direction-ltr .fc-timegrid-col-events{margin:0 2.5% 0 2px}.fc-direction-rtl .fc-timegrid-col-events{margin:0 2px 0 2.5%}.fc-timegrid-event-harness{position:absolute}.fc-timegrid-event-harness>.fc-timegrid-event{bottom:0;left:0;position:absolute;right:0;top:0}.fc-timegrid-event-harness-inset .fc-timegrid-event,.fc-timegrid-event.fc-event-mirror,.fc-timegrid-more-link{box-shadow:0 0 0 1px var(--fc-page-bg-color)}.fc-timegrid-event,.fc-timegrid-more-link{border-radius:3px;font-size:var(--fc-small-font-size)}.fc-timegrid-event{margin-bottom:1px}.fc-timegrid-event .fc-event-main{padding:1px 1px 0}.fc-timegrid-event .fc-event-time{font-size:var(--fc-small-font-size);margin-bottom:1px;white-space:nowrap}.fc-timegrid-event-short .fc-event-main-frame{flex-direction:row;overflow:hidden}.fc-timegrid-event-short .fc-event-time:after{content:"\\00a0-\\00a0"}.fc-timegrid-event-short .fc-event-title{font-size:var(--fc-small-font-size)}.fc-timegrid-more-link{background:var(--fc-more-link-bg-color);color:var(--fc-more-link-text-color);cursor:pointer;margin-bottom:1px;position:absolute;z-index:9999}.fc-timegrid-more-link-inner{padding:3px 2px;top:0}.fc-direction-ltr .fc-timegrid-more-link{right:0}.fc-direction-rtl .fc-timegrid-more-link{left:0}.fc .fc-timegrid-now-indicator-arrow,.fc .fc-timegrid-now-indicator-line{pointer-events:none}.fc .fc-timegrid-now-indicator-line{border-color:var(--fc-now-indicator-color);border-style:solid;border-width:1px 0 0;left:0;position:absolute;right:0;z-index:4}.fc .fc-timegrid-now-indicator-arrow{border-color:var(--fc-now-indicator-color);border-style:solid;margin-top:-5px;position:absolute;z-index:4}.fc-direction-ltr .fc-timegrid-now-indicator-arrow{border-bottom-color:transparent;border-top-color:transparent;border-width:5px 0 5px 6px;left:0}.fc-direction-rtl .fc-timegrid-now-indicator-arrow{border-bottom-color:transparent;border-top-color:transparent;border-width:5px 6px 5px 0;right:0}';
injectStyles(css_248z3);

// node_modules/@fullcalendar/timegrid/index.js
var OPTION_REFINERS = {
  allDaySlot: Boolean
};
var index2 = createPlugin({
  name: "@fullcalendar/timegrid",
  initialView: "timeGridWeek",
  optionRefiners: OPTION_REFINERS,
  views: {
    timeGrid: {
      component: DayTimeColsView,
      usesMinMaxTime: true,
      allDaySlot: true,
      slotDuration: "00:30:00",
      slotEventOverlap: true
      // a bad name. confused with overlap/constraint system
    },
    timeGridDay: {
      type: "timeGrid",
      duration: { days: 1 }
    },
    timeGridWeek: {
      type: "timeGrid",
      duration: { weeks: 1 }
    }
  }
});

// node_modules/rrule/dist/esm/weekday.js
var ALL_WEEKDAYS = [
  "MO",
  "TU",
  "WE",
  "TH",
  "FR",
  "SA",
  "SU"
];
var Weekday = (
  /** @class */
  function() {
    function Weekday2(weekday, n2) {
      if (n2 === 0)
        throw new Error("Can't create weekday with n == 0");
      this.weekday = weekday;
      this.n = n2;
    }
    Weekday2.fromStr = function(str) {
      return new Weekday2(ALL_WEEKDAYS.indexOf(str));
    };
    Weekday2.prototype.nth = function(n2) {
      return this.n === n2 ? this : new Weekday2(this.weekday, n2);
    };
    Weekday2.prototype.equals = function(other) {
      return this.weekday === other.weekday && this.n === other.n;
    };
    Weekday2.prototype.toString = function() {
      var s3 = ALL_WEEKDAYS[this.weekday];
      if (this.n)
        s3 = (this.n > 0 ? "+" : "") + String(this.n) + s3;
      return s3;
    };
    Weekday2.prototype.getJsWeekday = function() {
      return this.weekday === 6 ? 0 : this.weekday + 1;
    };
    return Weekday2;
  }()
);

// node_modules/rrule/dist/esm/helpers.js
var isPresent = function(value) {
  return value !== null && value !== void 0;
};
var isNumber = function(value) {
  return typeof value === "number";
};
var isWeekdayStr = function(value) {
  return typeof value === "string" && ALL_WEEKDAYS.includes(value);
};
var isArray = Array.isArray;
var range = function(start, end) {
  if (end === void 0) {
    end = start;
  }
  if (arguments.length === 1) {
    end = start;
    start = 0;
  }
  var rang = [];
  for (var i3 = start; i3 < end; i3++)
    rang.push(i3);
  return rang;
};
var repeat = function(value, times) {
  var i3 = 0;
  var array = [];
  if (isArray(value)) {
    for (; i3 < times; i3++)
      array[i3] = [].concat(value);
  } else {
    for (; i3 < times; i3++)
      array[i3] = value;
  }
  return array;
};
var toArray = function(item) {
  if (isArray(item)) {
    return item;
  }
  return [item];
};
function padStart2(item, targetLength, padString) {
  if (padString === void 0) {
    padString = " ";
  }
  var str = String(item);
  targetLength = targetLength >> 0;
  if (str.length > targetLength) {
    return String(str);
  }
  targetLength = targetLength - str.length;
  if (targetLength > padString.length) {
    padString += repeat(padString, targetLength / padString.length);
  }
  return padString.slice(0, targetLength) + String(str);
}
var split = function(str, sep, num) {
  var splits = str.split(sep);
  return num ? splits.slice(0, num).concat([splits.slice(num).join(sep)]) : splits;
};
var pymod = function(a3, b3) {
  var r3 = a3 % b3;
  return r3 * b3 < 0 ? r3 + b3 : r3;
};
var divmod = function(a3, b3) {
  return { div: Math.floor(a3 / b3), mod: pymod(a3, b3) };
};
var empty = function(obj) {
  return !isPresent(obj) || obj.length === 0;
};
var notEmpty = function(obj) {
  return !empty(obj);
};
var includes = function(arr, val) {
  return notEmpty(arr) && arr.indexOf(val) !== -1;
};

// node_modules/rrule/dist/esm/dateutil.js
var datetime = function(y3, m3, d2, h3, i3, s3) {
  if (h3 === void 0) {
    h3 = 0;
  }
  if (i3 === void 0) {
    i3 = 0;
  }
  if (s3 === void 0) {
    s3 = 0;
  }
  return new Date(Date.UTC(y3, m3 - 1, d2, h3, i3, s3));
};
var MONTH_DAYS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var ONE_DAY = 1e3 * 60 * 60 * 24;
var MAXYEAR = 9999;
var ORDINAL_BASE = datetime(1970, 1, 1);
var PY_WEEKDAYS = [6, 0, 1, 2, 3, 4, 5];
var isLeapYear = function(year) {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
};
var isDate = function(value) {
  return value instanceof Date;
};
var isValidDate2 = function(value) {
  return isDate(value) && !isNaN(value.getTime());
};
var daysBetween = function(date1, date2) {
  var date1ms = date1.getTime();
  var date2ms = date2.getTime();
  var differencems = date1ms - date2ms;
  return Math.round(differencems / ONE_DAY);
};
var toOrdinal = function(date) {
  return daysBetween(date, ORDINAL_BASE);
};
var fromOrdinal = function(ordinal) {
  return new Date(ORDINAL_BASE.getTime() + ordinal * ONE_DAY);
};
var getMonthDays = function(date) {
  var month = date.getUTCMonth();
  return month === 1 && isLeapYear(date.getUTCFullYear()) ? 29 : MONTH_DAYS[month];
};
var getWeekday = function(date) {
  return PY_WEEKDAYS[date.getUTCDay()];
};
var monthRange = function(year, month) {
  var date = datetime(year, month + 1, 1);
  return [getWeekday(date), getMonthDays(date)];
};
var combine = function(date, time) {
  time = time || date;
  return new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds()));
};
var clone = function(date) {
  var dolly = new Date(date.getTime());
  return dolly;
};
var cloneDates = function(dates) {
  var clones = [];
  for (var i3 = 0; i3 < dates.length; i3++) {
    clones.push(clone(dates[i3]));
  }
  return clones;
};
var sort = function(dates) {
  dates.sort(function(a3, b3) {
    return a3.getTime() - b3.getTime();
  });
};
var timeToUntilString = function(time, utc) {
  if (utc === void 0) {
    utc = true;
  }
  var date = new Date(time);
  return [
    padStart2(date.getUTCFullYear().toString(), 4, "0"),
    padStart2(date.getUTCMonth() + 1, 2, "0"),
    padStart2(date.getUTCDate(), 2, "0"),
    "T",
    padStart2(date.getUTCHours(), 2, "0"),
    padStart2(date.getUTCMinutes(), 2, "0"),
    padStart2(date.getUTCSeconds(), 2, "0"),
    utc ? "Z" : ""
  ].join("");
};
var untilStringToDate = function(until) {
  var re = /^(\d{4})(\d{2})(\d{2})(T(\d{2})(\d{2})(\d{2})Z?)?$/;
  var bits = re.exec(until);
  if (!bits)
    throw new Error("Invalid UNTIL value: ".concat(until));
  return new Date(Date.UTC(parseInt(bits[1], 10), parseInt(bits[2], 10) - 1, parseInt(bits[3], 10), parseInt(bits[5], 10) || 0, parseInt(bits[6], 10) || 0, parseInt(bits[7], 10) || 0));
};
var dateTZtoISO8601 = function(date, timeZone) {
  var dateStr = date.toLocaleString("sv-SE", { timeZone });
  return dateStr.replace(" ", "T") + "Z";
};
var dateInTimeZone = function(date, timeZone) {
  var localTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
  var dateInLocalTZ = new Date(dateTZtoISO8601(date, localTimeZone));
  var dateInTargetTZ = new Date(dateTZtoISO8601(date, timeZone !== null && timeZone !== void 0 ? timeZone : "UTC"));
  var tzOffset = dateInTargetTZ.getTime() - dateInLocalTZ.getTime();
  return new Date(date.getTime() - tzOffset);
};

// node_modules/rrule/dist/esm/iterresult.js
var IterResult = (
  /** @class */
  function() {
    function IterResult2(method, args) {
      this.minDate = null;
      this.maxDate = null;
      this._result = [];
      this.total = 0;
      this.method = method;
      this.args = args;
      if (method === "between") {
        this.maxDate = args.inc ? args.before : new Date(args.before.getTime() - 1);
        this.minDate = args.inc ? args.after : new Date(args.after.getTime() + 1);
      } else if (method === "before") {
        this.maxDate = args.inc ? args.dt : new Date(args.dt.getTime() - 1);
      } else if (method === "after") {
        this.minDate = args.inc ? args.dt : new Date(args.dt.getTime() + 1);
      }
    }
    IterResult2.prototype.accept = function(date) {
      ++this.total;
      var tooEarly = this.minDate && date < this.minDate;
      var tooLate = this.maxDate && date > this.maxDate;
      if (this.method === "between") {
        if (tooEarly)
          return true;
        if (tooLate)
          return false;
      } else if (this.method === "before") {
        if (tooLate)
          return false;
      } else if (this.method === "after") {
        if (tooEarly)
          return true;
        this.add(date);
        return false;
      }
      return this.add(date);
    };
    IterResult2.prototype.add = function(date) {
      this._result.push(date);
      return true;
    };
    IterResult2.prototype.getValue = function() {
      var res = this._result;
      switch (this.method) {
        case "all":
        case "between":
          return res;
        case "before":
        case "after":
        default:
          return res.length ? res[res.length - 1] : null;
      }
    };
    IterResult2.prototype.clone = function() {
      return new IterResult2(this.method, this.args);
    };
    return IterResult2;
  }()
);
var iterresult_default = IterResult;

// node_modules/tslib/tslib.es6.js
var extendStatics = function(d2, b3) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b4) {
    d3.__proto__ = b4;
  } || function(d3, b4) {
    for (var p3 in b4)
      if (Object.prototype.hasOwnProperty.call(b4, p3))
        d3[p3] = b4[p3];
  };
  return extendStatics(d2, b3);
};
function __extends(d2, b3) {
  if (typeof b3 !== "function" && b3 !== null)
    throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
  extendStatics(d2, b3);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t3) {
    for (var s3, i3 = 1, n2 = arguments.length; i3 < n2; i3++) {
      s3 = arguments[i3];
      for (var p3 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p3))
          t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign.apply(this, arguments);
};
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i3 = 0, l3 = from.length, ar; i3 < l3; i3++) {
      if (ar || !(i3 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i3);
        ar[i3] = from[i3];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}

// node_modules/rrule/dist/esm/callbackiterresult.js
var CallbackIterResult = (
  /** @class */
  function(_super) {
    __extends(CallbackIterResult2, _super);
    function CallbackIterResult2(method, args, iterator) {
      var _this = _super.call(this, method, args) || this;
      _this.iterator = iterator;
      return _this;
    }
    CallbackIterResult2.prototype.add = function(date) {
      if (this.iterator(date, this._result.length)) {
        this._result.push(date);
        return true;
      }
      return false;
    };
    return CallbackIterResult2;
  }(iterresult_default)
);
var callbackiterresult_default = CallbackIterResult;

// node_modules/rrule/dist/esm/nlp/i18n.js
var ENGLISH = {
  dayNames: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ],
  monthNames: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ],
  tokens: {
    SKIP: /^[ \r\n\t]+|^\.$/,
    number: /^[1-9][0-9]*/,
    numberAsText: /^(one|two|three)/i,
    every: /^every/i,
    "day(s)": /^days?/i,
    "weekday(s)": /^weekdays?/i,
    "week(s)": /^weeks?/i,
    "hour(s)": /^hours?/i,
    "minute(s)": /^minutes?/i,
    "month(s)": /^months?/i,
    "year(s)": /^years?/i,
    on: /^(on|in)/i,
    at: /^(at)/i,
    the: /^the/i,
    first: /^first/i,
    second: /^second/i,
    third: /^third/i,
    nth: /^([1-9][0-9]*)(\.|th|nd|rd|st)/i,
    last: /^last/i,
    for: /^for/i,
    "time(s)": /^times?/i,
    until: /^(un)?til/i,
    monday: /^mo(n(day)?)?/i,
    tuesday: /^tu(e(s(day)?)?)?/i,
    wednesday: /^we(d(n(esday)?)?)?/i,
    thursday: /^th(u(r(sday)?)?)?/i,
    friday: /^fr(i(day)?)?/i,
    saturday: /^sa(t(urday)?)?/i,
    sunday: /^su(n(day)?)?/i,
    january: /^jan(uary)?/i,
    february: /^feb(ruary)?/i,
    march: /^mar(ch)?/i,
    april: /^apr(il)?/i,
    may: /^may/i,
    june: /^june?/i,
    july: /^july?/i,
    august: /^aug(ust)?/i,
    september: /^sep(t(ember)?)?/i,
    october: /^oct(ober)?/i,
    november: /^nov(ember)?/i,
    december: /^dec(ember)?/i,
    comma: /^(,\s*|(and|or)\s*)+/i
  }
};
var i18n_default = ENGLISH;

// node_modules/rrule/dist/esm/nlp/totext.js
var contains = function(arr, val) {
  return arr.indexOf(val) !== -1;
};
var defaultGetText = function(id) {
  return id.toString();
};
var defaultDateFormatter = function(year, month, day) {
  return "".concat(month, " ").concat(day, ", ").concat(year);
};
var ToText = (
  /** @class */
  function() {
    function ToText2(rrule, gettext, language, dateFormatter) {
      if (gettext === void 0) {
        gettext = defaultGetText;
      }
      if (language === void 0) {
        language = i18n_default;
      }
      if (dateFormatter === void 0) {
        dateFormatter = defaultDateFormatter;
      }
      this.text = [];
      this.language = language || i18n_default;
      this.gettext = gettext;
      this.dateFormatter = dateFormatter;
      this.rrule = rrule;
      this.options = rrule.options;
      this.origOptions = rrule.origOptions;
      if (this.origOptions.bymonthday) {
        var bymonthday = [].concat(this.options.bymonthday);
        var bynmonthday = [].concat(this.options.bynmonthday);
        bymonthday.sort(function(a3, b3) {
          return a3 - b3;
        });
        bynmonthday.sort(function(a3, b3) {
          return b3 - a3;
        });
        this.bymonthday = bymonthday.concat(bynmonthday);
        if (!this.bymonthday.length)
          this.bymonthday = null;
      }
      if (isPresent(this.origOptions.byweekday)) {
        var byweekday = !isArray(this.origOptions.byweekday) ? [this.origOptions.byweekday] : this.origOptions.byweekday;
        var days = String(byweekday);
        this.byweekday = {
          allWeeks: byweekday.filter(function(weekday) {
            return !weekday.n;
          }),
          someWeeks: byweekday.filter(function(weekday) {
            return Boolean(weekday.n);
          }),
          isWeekdays: days.indexOf("MO") !== -1 && days.indexOf("TU") !== -1 && days.indexOf("WE") !== -1 && days.indexOf("TH") !== -1 && days.indexOf("FR") !== -1 && days.indexOf("SA") === -1 && days.indexOf("SU") === -1,
          isEveryDay: days.indexOf("MO") !== -1 && days.indexOf("TU") !== -1 && days.indexOf("WE") !== -1 && days.indexOf("TH") !== -1 && days.indexOf("FR") !== -1 && days.indexOf("SA") !== -1 && days.indexOf("SU") !== -1
        };
        var sortWeekDays = function(a3, b3) {
          return a3.weekday - b3.weekday;
        };
        this.byweekday.allWeeks.sort(sortWeekDays);
        this.byweekday.someWeeks.sort(sortWeekDays);
        if (!this.byweekday.allWeeks.length)
          this.byweekday.allWeeks = null;
        if (!this.byweekday.someWeeks.length)
          this.byweekday.someWeeks = null;
      } else {
        this.byweekday = null;
      }
    }
    ToText2.isFullyConvertible = function(rrule) {
      var canConvert = true;
      if (!(rrule.options.freq in ToText2.IMPLEMENTED))
        return false;
      if (rrule.origOptions.until && rrule.origOptions.count)
        return false;
      for (var key in rrule.origOptions) {
        if (contains(["dtstart", "tzid", "wkst", "freq"], key))
          return true;
        if (!contains(ToText2.IMPLEMENTED[rrule.options.freq], key))
          return false;
      }
      return canConvert;
    };
    ToText2.prototype.isFullyConvertible = function() {
      return ToText2.isFullyConvertible(this.rrule);
    };
    ToText2.prototype.toString = function() {
      var gettext = this.gettext;
      if (!(this.options.freq in ToText2.IMPLEMENTED)) {
        return gettext("RRule error: Unable to fully convert this rrule to text");
      }
      this.text = [gettext("every")];
      this[RRule.FREQUENCIES[this.options.freq]]();
      if (this.options.until) {
        this.add(gettext("until"));
        var until = this.options.until;
        this.add(this.dateFormatter(until.getUTCFullYear(), this.language.monthNames[until.getUTCMonth()], until.getUTCDate()));
      } else if (this.options.count) {
        this.add(gettext("for")).add(this.options.count.toString()).add(this.plural(this.options.count) ? gettext("times") : gettext("time"));
      }
      if (!this.isFullyConvertible())
        this.add(gettext("(~ approximate)"));
      return this.text.join("");
    };
    ToText2.prototype.HOURLY = function() {
      var gettext = this.gettext;
      if (this.options.interval !== 1)
        this.add(this.options.interval.toString());
      this.add(this.plural(this.options.interval) ? gettext("hours") : gettext("hour"));
    };
    ToText2.prototype.MINUTELY = function() {
      var gettext = this.gettext;
      if (this.options.interval !== 1)
        this.add(this.options.interval.toString());
      this.add(this.plural(this.options.interval) ? gettext("minutes") : gettext("minute"));
    };
    ToText2.prototype.DAILY = function() {
      var gettext = this.gettext;
      if (this.options.interval !== 1)
        this.add(this.options.interval.toString());
      if (this.byweekday && this.byweekday.isWeekdays) {
        this.add(this.plural(this.options.interval) ? gettext("weekdays") : gettext("weekday"));
      } else {
        this.add(this.plural(this.options.interval) ? gettext("days") : gettext("day"));
      }
      if (this.origOptions.bymonth) {
        this.add(gettext("in"));
        this._bymonth();
      }
      if (this.bymonthday) {
        this._bymonthday();
      } else if (this.byweekday) {
        this._byweekday();
      } else if (this.origOptions.byhour) {
        this._byhour();
      }
    };
    ToText2.prototype.WEEKLY = function() {
      var gettext = this.gettext;
      if (this.options.interval !== 1) {
        this.add(this.options.interval.toString()).add(this.plural(this.options.interval) ? gettext("weeks") : gettext("week"));
      }
      if (this.byweekday && this.byweekday.isWeekdays) {
        if (this.options.interval === 1) {
          this.add(this.plural(this.options.interval) ? gettext("weekdays") : gettext("weekday"));
        } else {
          this.add(gettext("on")).add(gettext("weekdays"));
        }
      } else if (this.byweekday && this.byweekday.isEveryDay) {
        this.add(this.plural(this.options.interval) ? gettext("days") : gettext("day"));
      } else {
        if (this.options.interval === 1)
          this.add(gettext("week"));
        if (this.origOptions.bymonth) {
          this.add(gettext("in"));
          this._bymonth();
        }
        if (this.bymonthday) {
          this._bymonthday();
        } else if (this.byweekday) {
          this._byweekday();
        }
        if (this.origOptions.byhour) {
          this._byhour();
        }
      }
    };
    ToText2.prototype.MONTHLY = function() {
      var gettext = this.gettext;
      if (this.origOptions.bymonth) {
        if (this.options.interval !== 1) {
          this.add(this.options.interval.toString()).add(gettext("months"));
          if (this.plural(this.options.interval))
            this.add(gettext("in"));
        } else {
        }
        this._bymonth();
      } else {
        if (this.options.interval !== 1) {
          this.add(this.options.interval.toString());
        }
        this.add(this.plural(this.options.interval) ? gettext("months") : gettext("month"));
      }
      if (this.bymonthday) {
        this._bymonthday();
      } else if (this.byweekday && this.byweekday.isWeekdays) {
        this.add(gettext("on")).add(gettext("weekdays"));
      } else if (this.byweekday) {
        this._byweekday();
      }
    };
    ToText2.prototype.YEARLY = function() {
      var gettext = this.gettext;
      if (this.origOptions.bymonth) {
        if (this.options.interval !== 1) {
          this.add(this.options.interval.toString());
          this.add(gettext("years"));
        } else {
        }
        this._bymonth();
      } else {
        if (this.options.interval !== 1) {
          this.add(this.options.interval.toString());
        }
        this.add(this.plural(this.options.interval) ? gettext("years") : gettext("year"));
      }
      if (this.bymonthday) {
        this._bymonthday();
      } else if (this.byweekday) {
        this._byweekday();
      }
      if (this.options.byyearday) {
        this.add(gettext("on the")).add(this.list(this.options.byyearday, this.nth, gettext("and"))).add(gettext("day"));
      }
      if (this.options.byweekno) {
        this.add(gettext("in")).add(this.plural(this.options.byweekno.length) ? gettext("weeks") : gettext("week")).add(this.list(this.options.byweekno, void 0, gettext("and")));
      }
    };
    ToText2.prototype._bymonthday = function() {
      var gettext = this.gettext;
      if (this.byweekday && this.byweekday.allWeeks) {
        this.add(gettext("on")).add(this.list(this.byweekday.allWeeks, this.weekdaytext, gettext("or"))).add(gettext("the")).add(this.list(this.bymonthday, this.nth, gettext("or")));
      } else {
        this.add(gettext("on the")).add(this.list(this.bymonthday, this.nth, gettext("and")));
      }
    };
    ToText2.prototype._byweekday = function() {
      var gettext = this.gettext;
      if (this.byweekday.allWeeks && !this.byweekday.isWeekdays) {
        this.add(gettext("on")).add(this.list(this.byweekday.allWeeks, this.weekdaytext));
      }
      if (this.byweekday.someWeeks) {
        if (this.byweekday.allWeeks)
          this.add(gettext("and"));
        this.add(gettext("on the")).add(this.list(this.byweekday.someWeeks, this.weekdaytext, gettext("and")));
      }
    };
    ToText2.prototype._byhour = function() {
      var gettext = this.gettext;
      this.add(gettext("at")).add(this.list(this.origOptions.byhour, void 0, gettext("and")));
    };
    ToText2.prototype._bymonth = function() {
      this.add(this.list(this.options.bymonth, this.monthtext, this.gettext("and")));
    };
    ToText2.prototype.nth = function(n2) {
      n2 = parseInt(n2.toString(), 10);
      var nth;
      var gettext = this.gettext;
      if (n2 === -1)
        return gettext("last");
      var npos = Math.abs(n2);
      switch (npos) {
        case 1:
        case 21:
        case 31:
          nth = npos + gettext("st");
          break;
        case 2:
        case 22:
          nth = npos + gettext("nd");
          break;
        case 3:
        case 23:
          nth = npos + gettext("rd");
          break;
        default:
          nth = npos + gettext("th");
      }
      return n2 < 0 ? nth + " " + gettext("last") : nth;
    };
    ToText2.prototype.monthtext = function(m3) {
      return this.language.monthNames[m3 - 1];
    };
    ToText2.prototype.weekdaytext = function(wday) {
      var weekday = isNumber(wday) ? (wday + 1) % 7 : wday.getJsWeekday();
      return (wday.n ? this.nth(wday.n) + " " : "") + this.language.dayNames[weekday];
    };
    ToText2.prototype.plural = function(n2) {
      return n2 % 100 !== 1;
    };
    ToText2.prototype.add = function(s3) {
      this.text.push(" ");
      this.text.push(s3);
      return this;
    };
    ToText2.prototype.list = function(arr, callback, finalDelim, delim) {
      var _this = this;
      if (delim === void 0) {
        delim = ",";
      }
      if (!isArray(arr)) {
        arr = [arr];
      }
      var delimJoin = function(array, delimiter, finalDelimiter) {
        var list = "";
        for (var i3 = 0; i3 < array.length; i3++) {
          if (i3 !== 0) {
            if (i3 === array.length - 1) {
              list += " " + finalDelimiter + " ";
            } else {
              list += delimiter + " ";
            }
          }
          list += array[i3];
        }
        return list;
      };
      callback = callback || function(o2) {
        return o2.toString();
      };
      var realCallback = function(arg) {
        return callback && callback.call(_this, arg);
      };
      if (finalDelim) {
        return delimJoin(arr.map(realCallback), delim, finalDelim);
      } else {
        return arr.map(realCallback).join(delim + " ");
      }
    };
    return ToText2;
  }()
);
var totext_default = ToText;

// node_modules/rrule/dist/esm/nlp/parsetext.js
var Parser = (
  /** @class */
  function() {
    function Parser2(rules) {
      this.done = true;
      this.rules = rules;
    }
    Parser2.prototype.start = function(text) {
      this.text = text;
      this.done = false;
      return this.nextSymbol();
    };
    Parser2.prototype.isDone = function() {
      return this.done && this.symbol === null;
    };
    Parser2.prototype.nextSymbol = function() {
      var best;
      var bestSymbol;
      this.symbol = null;
      this.value = null;
      do {
        if (this.done)
          return false;
        var rule = void 0;
        best = null;
        for (var name_1 in this.rules) {
          rule = this.rules[name_1];
          var match = rule.exec(this.text);
          if (match) {
            if (best === null || match[0].length > best[0].length) {
              best = match;
              bestSymbol = name_1;
            }
          }
        }
        if (best != null) {
          this.text = this.text.substr(best[0].length);
          if (this.text === "")
            this.done = true;
        }
        if (best == null) {
          this.done = true;
          this.symbol = null;
          this.value = null;
          return;
        }
      } while (bestSymbol === "SKIP");
      this.symbol = bestSymbol;
      this.value = best;
      return true;
    };
    Parser2.prototype.accept = function(name) {
      if (this.symbol === name) {
        if (this.value) {
          var v3 = this.value;
          this.nextSymbol();
          return v3;
        }
        this.nextSymbol();
        return true;
      }
      return false;
    };
    Parser2.prototype.acceptNumber = function() {
      return this.accept("number");
    };
    Parser2.prototype.expect = function(name) {
      if (this.accept(name))
        return true;
      throw new Error("expected " + name + " but found " + this.symbol);
    };
    return Parser2;
  }()
);
function parseText(text, language) {
  if (language === void 0) {
    language = i18n_default;
  }
  var options = {};
  var ttr = new Parser(language.tokens);
  if (!ttr.start(text))
    return null;
  S2();
  return options;
  function S2() {
    ttr.expect("every");
    var n2 = ttr.acceptNumber();
    if (n2)
      options.interval = parseInt(n2[0], 10);
    if (ttr.isDone())
      throw new Error("Unexpected end");
    switch (ttr.symbol) {
      case "day(s)":
        options.freq = RRule.DAILY;
        if (ttr.nextSymbol()) {
          AT();
          F4();
        }
        break;
      case "weekday(s)":
        options.freq = RRule.WEEKLY;
        options.byweekday = [RRule.MO, RRule.TU, RRule.WE, RRule.TH, RRule.FR];
        ttr.nextSymbol();
        AT();
        F4();
        break;
      case "week(s)":
        options.freq = RRule.WEEKLY;
        if (ttr.nextSymbol()) {
          ON();
          AT();
          F4();
        }
        break;
      case "hour(s)":
        options.freq = RRule.HOURLY;
        if (ttr.nextSymbol()) {
          ON();
          F4();
        }
        break;
      case "minute(s)":
        options.freq = RRule.MINUTELY;
        if (ttr.nextSymbol()) {
          ON();
          F4();
        }
        break;
      case "month(s)":
        options.freq = RRule.MONTHLY;
        if (ttr.nextSymbol()) {
          ON();
          F4();
        }
        break;
      case "year(s)":
        options.freq = RRule.YEARLY;
        if (ttr.nextSymbol()) {
          ON();
          F4();
        }
        break;
      case "monday":
      case "tuesday":
      case "wednesday":
      case "thursday":
      case "friday":
      case "saturday":
      case "sunday":
        options.freq = RRule.WEEKLY;
        var key = ttr.symbol.substr(0, 2).toUpperCase();
        options.byweekday = [RRule[key]];
        if (!ttr.nextSymbol())
          return;
        while (ttr.accept("comma")) {
          if (ttr.isDone())
            throw new Error("Unexpected end");
          var wkd = decodeWKD();
          if (!wkd) {
            throw new Error("Unexpected symbol " + ttr.symbol + ", expected weekday");
          }
          options.byweekday.push(RRule[wkd]);
          ttr.nextSymbol();
        }
        AT();
        MDAYs();
        F4();
        break;
      case "january":
      case "february":
      case "march":
      case "april":
      case "may":
      case "june":
      case "july":
      case "august":
      case "september":
      case "october":
      case "november":
      case "december":
        options.freq = RRule.YEARLY;
        options.bymonth = [decodeM()];
        if (!ttr.nextSymbol())
          return;
        while (ttr.accept("comma")) {
          if (ttr.isDone())
            throw new Error("Unexpected end");
          var m3 = decodeM();
          if (!m3) {
            throw new Error("Unexpected symbol " + ttr.symbol + ", expected month");
          }
          options.bymonth.push(m3);
          ttr.nextSymbol();
        }
        ON();
        F4();
        break;
      default:
        throw new Error("Unknown symbol");
    }
  }
  function ON() {
    var on = ttr.accept("on");
    var the = ttr.accept("the");
    if (!(on || the))
      return;
    do {
      var nth = decodeNTH();
      var wkd = decodeWKD();
      var m3 = decodeM();
      if (nth) {
        if (wkd) {
          ttr.nextSymbol();
          if (!options.byweekday)
            options.byweekday = [];
          options.byweekday.push(RRule[wkd].nth(nth));
        } else {
          if (!options.bymonthday)
            options.bymonthday = [];
          options.bymonthday.push(nth);
          ttr.accept("day(s)");
        }
      } else if (wkd) {
        ttr.nextSymbol();
        if (!options.byweekday)
          options.byweekday = [];
        options.byweekday.push(RRule[wkd]);
      } else if (ttr.symbol === "weekday(s)") {
        ttr.nextSymbol();
        if (!options.byweekday) {
          options.byweekday = [RRule.MO, RRule.TU, RRule.WE, RRule.TH, RRule.FR];
        }
      } else if (ttr.symbol === "week(s)") {
        ttr.nextSymbol();
        var n2 = ttr.acceptNumber();
        if (!n2) {
          throw new Error("Unexpected symbol " + ttr.symbol + ", expected week number");
        }
        options.byweekno = [parseInt(n2[0], 10)];
        while (ttr.accept("comma")) {
          n2 = ttr.acceptNumber();
          if (!n2) {
            throw new Error("Unexpected symbol " + ttr.symbol + "; expected monthday");
          }
          options.byweekno.push(parseInt(n2[0], 10));
        }
      } else if (m3) {
        ttr.nextSymbol();
        if (!options.bymonth)
          options.bymonth = [];
        options.bymonth.push(m3);
      } else {
        return;
      }
    } while (ttr.accept("comma") || ttr.accept("the") || ttr.accept("on"));
  }
  function AT() {
    var at = ttr.accept("at");
    if (!at)
      return;
    do {
      var n2 = ttr.acceptNumber();
      if (!n2) {
        throw new Error("Unexpected symbol " + ttr.symbol + ", expected hour");
      }
      options.byhour = [parseInt(n2[0], 10)];
      while (ttr.accept("comma")) {
        n2 = ttr.acceptNumber();
        if (!n2) {
          throw new Error("Unexpected symbol " + ttr.symbol + "; expected hour");
        }
        options.byhour.push(parseInt(n2[0], 10));
      }
    } while (ttr.accept("comma") || ttr.accept("at"));
  }
  function decodeM() {
    switch (ttr.symbol) {
      case "january":
        return 1;
      case "february":
        return 2;
      case "march":
        return 3;
      case "april":
        return 4;
      case "may":
        return 5;
      case "june":
        return 6;
      case "july":
        return 7;
      case "august":
        return 8;
      case "september":
        return 9;
      case "october":
        return 10;
      case "november":
        return 11;
      case "december":
        return 12;
      default:
        return false;
    }
  }
  function decodeWKD() {
    switch (ttr.symbol) {
      case "monday":
      case "tuesday":
      case "wednesday":
      case "thursday":
      case "friday":
      case "saturday":
      case "sunday":
        return ttr.symbol.substr(0, 2).toUpperCase();
      default:
        return false;
    }
  }
  function decodeNTH() {
    switch (ttr.symbol) {
      case "last":
        ttr.nextSymbol();
        return -1;
      case "first":
        ttr.nextSymbol();
        return 1;
      case "second":
        ttr.nextSymbol();
        return ttr.accept("last") ? -2 : 2;
      case "third":
        ttr.nextSymbol();
        return ttr.accept("last") ? -3 : 3;
      case "nth":
        var v3 = parseInt(ttr.value[1], 10);
        if (v3 < -366 || v3 > 366)
          throw new Error("Nth out of range: " + v3);
        ttr.nextSymbol();
        return ttr.accept("last") ? -v3 : v3;
      default:
        return false;
    }
  }
  function MDAYs() {
    ttr.accept("on");
    ttr.accept("the");
    var nth = decodeNTH();
    if (!nth)
      return;
    options.bymonthday = [nth];
    ttr.nextSymbol();
    while (ttr.accept("comma")) {
      nth = decodeNTH();
      if (!nth) {
        throw new Error("Unexpected symbol " + ttr.symbol + "; expected monthday");
      }
      options.bymonthday.push(nth);
      ttr.nextSymbol();
    }
  }
  function F4() {
    if (ttr.symbol === "until") {
      var date = Date.parse(ttr.text);
      if (!date)
        throw new Error("Cannot parse until date:" + ttr.text);
      options.until = new Date(date);
    } else if (ttr.accept("for")) {
      options.count = parseInt(ttr.value[0], 10);
      ttr.expect("number");
    }
  }
}

// node_modules/rrule/dist/esm/types.js
var Frequency;
(function(Frequency2) {
  Frequency2[Frequency2["YEARLY"] = 0] = "YEARLY";
  Frequency2[Frequency2["MONTHLY"] = 1] = "MONTHLY";
  Frequency2[Frequency2["WEEKLY"] = 2] = "WEEKLY";
  Frequency2[Frequency2["DAILY"] = 3] = "DAILY";
  Frequency2[Frequency2["HOURLY"] = 4] = "HOURLY";
  Frequency2[Frequency2["MINUTELY"] = 5] = "MINUTELY";
  Frequency2[Frequency2["SECONDLY"] = 6] = "SECONDLY";
})(Frequency || (Frequency = {}));
function freqIsDailyOrGreater(freq) {
  return freq < Frequency.HOURLY;
}

// node_modules/rrule/dist/esm/nlp/index.js
var fromText = function(text, language) {
  if (language === void 0) {
    language = i18n_default;
  }
  return new RRule(parseText(text, language) || void 0);
};
var common = [
  "count",
  "until",
  "interval",
  "byweekday",
  "bymonthday",
  "bymonth"
];
totext_default.IMPLEMENTED = [];
totext_default.IMPLEMENTED[Frequency.HOURLY] = common;
totext_default.IMPLEMENTED[Frequency.MINUTELY] = common;
totext_default.IMPLEMENTED[Frequency.DAILY] = ["byhour"].concat(common);
totext_default.IMPLEMENTED[Frequency.WEEKLY] = common;
totext_default.IMPLEMENTED[Frequency.MONTHLY] = common;
totext_default.IMPLEMENTED[Frequency.YEARLY] = ["byweekno", "byyearday"].concat(common);
var toText = function(rrule, gettext, language, dateFormatter) {
  return new totext_default(rrule, gettext, language, dateFormatter).toString();
};
var isFullyConvertible = totext_default.isFullyConvertible;

// node_modules/rrule/dist/esm/datetime.js
var Time = (
  /** @class */
  function() {
    function Time2(hour, minute, second, millisecond) {
      this.hour = hour;
      this.minute = minute;
      this.second = second;
      this.millisecond = millisecond || 0;
    }
    Time2.prototype.getHours = function() {
      return this.hour;
    };
    Time2.prototype.getMinutes = function() {
      return this.minute;
    };
    Time2.prototype.getSeconds = function() {
      return this.second;
    };
    Time2.prototype.getMilliseconds = function() {
      return this.millisecond;
    };
    Time2.prototype.getTime = function() {
      return (this.hour * 60 * 60 + this.minute * 60 + this.second) * 1e3 + this.millisecond;
    };
    return Time2;
  }()
);
var DateTime = (
  /** @class */
  function(_super) {
    __extends(DateTime2, _super);
    function DateTime2(year, month, day, hour, minute, second, millisecond) {
      var _this = _super.call(this, hour, minute, second, millisecond) || this;
      _this.year = year;
      _this.month = month;
      _this.day = day;
      return _this;
    }
    DateTime2.fromDate = function(date) {
      return new this(date.getUTCFullYear(), date.getUTCMonth() + 1, date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.valueOf() % 1e3);
    };
    DateTime2.prototype.getWeekday = function() {
      return getWeekday(new Date(this.getTime()));
    };
    DateTime2.prototype.getTime = function() {
      return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond)).getTime();
    };
    DateTime2.prototype.getDay = function() {
      return this.day;
    };
    DateTime2.prototype.getMonth = function() {
      return this.month;
    };
    DateTime2.prototype.getYear = function() {
      return this.year;
    };
    DateTime2.prototype.addYears = function(years) {
      this.year += years;
    };
    DateTime2.prototype.addMonths = function(months) {
      this.month += months;
      if (this.month > 12) {
        var yearDiv = Math.floor(this.month / 12);
        var monthMod = pymod(this.month, 12);
        this.month = monthMod;
        this.year += yearDiv;
        if (this.month === 0) {
          this.month = 12;
          --this.year;
        }
      }
    };
    DateTime2.prototype.addWeekly = function(days, wkst) {
      if (wkst > this.getWeekday()) {
        this.day += -(this.getWeekday() + 1 + (6 - wkst)) + days * 7;
      } else {
        this.day += -(this.getWeekday() - wkst) + days * 7;
      }
      this.fixDay();
    };
    DateTime2.prototype.addDaily = function(days) {
      this.day += days;
      this.fixDay();
    };
    DateTime2.prototype.addHours = function(hours, filtered, byhour) {
      if (filtered) {
        this.hour += Math.floor((23 - this.hour) / hours) * hours;
      }
      for (; ; ) {
        this.hour += hours;
        var _a = divmod(this.hour, 24), dayDiv = _a.div, hourMod = _a.mod;
        if (dayDiv) {
          this.hour = hourMod;
          this.addDaily(dayDiv);
        }
        if (empty(byhour) || includes(byhour, this.hour))
          break;
      }
    };
    DateTime2.prototype.addMinutes = function(minutes, filtered, byhour, byminute) {
      if (filtered) {
        this.minute += Math.floor((1439 - (this.hour * 60 + this.minute)) / minutes) * minutes;
      }
      for (; ; ) {
        this.minute += minutes;
        var _a = divmod(this.minute, 60), hourDiv = _a.div, minuteMod = _a.mod;
        if (hourDiv) {
          this.minute = minuteMod;
          this.addHours(hourDiv, false, byhour);
        }
        if ((empty(byhour) || includes(byhour, this.hour)) && (empty(byminute) || includes(byminute, this.minute))) {
          break;
        }
      }
    };
    DateTime2.prototype.addSeconds = function(seconds, filtered, byhour, byminute, bysecond) {
      if (filtered) {
        this.second += Math.floor((86399 - (this.hour * 3600 + this.minute * 60 + this.second)) / seconds) * seconds;
      }
      for (; ; ) {
        this.second += seconds;
        var _a = divmod(this.second, 60), minuteDiv = _a.div, secondMod = _a.mod;
        if (minuteDiv) {
          this.second = secondMod;
          this.addMinutes(minuteDiv, false, byhour, byminute);
        }
        if ((empty(byhour) || includes(byhour, this.hour)) && (empty(byminute) || includes(byminute, this.minute)) && (empty(bysecond) || includes(bysecond, this.second))) {
          break;
        }
      }
    };
    DateTime2.prototype.fixDay = function() {
      if (this.day <= 28) {
        return;
      }
      var daysinmonth = monthRange(this.year, this.month - 1)[1];
      if (this.day <= daysinmonth) {
        return;
      }
      while (this.day > daysinmonth) {
        this.day -= daysinmonth;
        ++this.month;
        if (this.month === 13) {
          this.month = 1;
          ++this.year;
          if (this.year > MAXYEAR) {
            return;
          }
        }
        daysinmonth = monthRange(this.year, this.month - 1)[1];
      }
    };
    DateTime2.prototype.add = function(options, filtered) {
      var freq = options.freq, interval = options.interval, wkst = options.wkst, byhour = options.byhour, byminute = options.byminute, bysecond = options.bysecond;
      switch (freq) {
        case Frequency.YEARLY:
          return this.addYears(interval);
        case Frequency.MONTHLY:
          return this.addMonths(interval);
        case Frequency.WEEKLY:
          return this.addWeekly(interval, wkst);
        case Frequency.DAILY:
          return this.addDaily(interval);
        case Frequency.HOURLY:
          return this.addHours(interval, filtered, byhour);
        case Frequency.MINUTELY:
          return this.addMinutes(interval, filtered, byhour, byminute);
        case Frequency.SECONDLY:
          return this.addSeconds(interval, filtered, byhour, byminute, bysecond);
      }
    };
    return DateTime2;
  }(Time)
);

// node_modules/rrule/dist/esm/parseoptions.js
function initializeOptions(options) {
  var invalid = [];
  var keys = Object.keys(options);
  for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
    var key = keys_1[_i];
    if (!includes(defaultKeys, key))
      invalid.push(key);
    if (isDate(options[key]) && !isValidDate2(options[key])) {
      invalid.push(key);
    }
  }
  if (invalid.length) {
    throw new Error("Invalid options: " + invalid.join(", "));
  }
  return __assign({}, options);
}
function parseOptions(options) {
  var opts = __assign(__assign({}, DEFAULT_OPTIONS), initializeOptions(options));
  if (isPresent(opts.byeaster))
    opts.freq = RRule.YEARLY;
  if (!(isPresent(opts.freq) && RRule.FREQUENCIES[opts.freq])) {
    throw new Error("Invalid frequency: ".concat(opts.freq, " ").concat(options.freq));
  }
  if (!opts.dtstart)
    opts.dtstart = new Date(new Date().setMilliseconds(0));
  if (!isPresent(opts.wkst)) {
    opts.wkst = RRule.MO.weekday;
  } else if (isNumber(opts.wkst)) {
  } else {
    opts.wkst = opts.wkst.weekday;
  }
  if (isPresent(opts.bysetpos)) {
    if (isNumber(opts.bysetpos))
      opts.bysetpos = [opts.bysetpos];
    for (var i3 = 0; i3 < opts.bysetpos.length; i3++) {
      var v3 = opts.bysetpos[i3];
      if (v3 === 0 || !(v3 >= -366 && v3 <= 366)) {
        throw new Error("bysetpos must be between 1 and 366, or between -366 and -1");
      }
    }
  }
  if (!(Boolean(opts.byweekno) || notEmpty(opts.byweekno) || notEmpty(opts.byyearday) || Boolean(opts.bymonthday) || notEmpty(opts.bymonthday) || isPresent(opts.byweekday) || isPresent(opts.byeaster))) {
    switch (opts.freq) {
      case RRule.YEARLY:
        if (!opts.bymonth)
          opts.bymonth = opts.dtstart.getUTCMonth() + 1;
        opts.bymonthday = opts.dtstart.getUTCDate();
        break;
      case RRule.MONTHLY:
        opts.bymonthday = opts.dtstart.getUTCDate();
        break;
      case RRule.WEEKLY:
        opts.byweekday = [getWeekday(opts.dtstart)];
        break;
    }
  }
  if (isPresent(opts.bymonth) && !isArray(opts.bymonth)) {
    opts.bymonth = [opts.bymonth];
  }
  if (isPresent(opts.byyearday) && !isArray(opts.byyearday) && isNumber(opts.byyearday)) {
    opts.byyearday = [opts.byyearday];
  }
  if (!isPresent(opts.bymonthday)) {
    opts.bymonthday = [];
    opts.bynmonthday = [];
  } else if (isArray(opts.bymonthday)) {
    var bymonthday = [];
    var bynmonthday = [];
    for (var i3 = 0; i3 < opts.bymonthday.length; i3++) {
      var v3 = opts.bymonthday[i3];
      if (v3 > 0) {
        bymonthday.push(v3);
      } else if (v3 < 0) {
        bynmonthday.push(v3);
      }
    }
    opts.bymonthday = bymonthday;
    opts.bynmonthday = bynmonthday;
  } else if (opts.bymonthday < 0) {
    opts.bynmonthday = [opts.bymonthday];
    opts.bymonthday = [];
  } else {
    opts.bynmonthday = [];
    opts.bymonthday = [opts.bymonthday];
  }
  if (isPresent(opts.byweekno) && !isArray(opts.byweekno)) {
    opts.byweekno = [opts.byweekno];
  }
  if (!isPresent(opts.byweekday)) {
    opts.bynweekday = null;
  } else if (isNumber(opts.byweekday)) {
    opts.byweekday = [opts.byweekday];
    opts.bynweekday = null;
  } else if (isWeekdayStr(opts.byweekday)) {
    opts.byweekday = [Weekday.fromStr(opts.byweekday).weekday];
    opts.bynweekday = null;
  } else if (opts.byweekday instanceof Weekday) {
    if (!opts.byweekday.n || opts.freq > RRule.MONTHLY) {
      opts.byweekday = [opts.byweekday.weekday];
      opts.bynweekday = null;
    } else {
      opts.bynweekday = [[opts.byweekday.weekday, opts.byweekday.n]];
      opts.byweekday = null;
    }
  } else {
    var byweekday = [];
    var bynweekday = [];
    for (var i3 = 0; i3 < opts.byweekday.length; i3++) {
      var wday = opts.byweekday[i3];
      if (isNumber(wday)) {
        byweekday.push(wday);
        continue;
      } else if (isWeekdayStr(wday)) {
        byweekday.push(Weekday.fromStr(wday).weekday);
        continue;
      }
      if (!wday.n || opts.freq > RRule.MONTHLY) {
        byweekday.push(wday.weekday);
      } else {
        bynweekday.push([wday.weekday, wday.n]);
      }
    }
    opts.byweekday = notEmpty(byweekday) ? byweekday : null;
    opts.bynweekday = notEmpty(bynweekday) ? bynweekday : null;
  }
  if (!isPresent(opts.byhour)) {
    opts.byhour = opts.freq < RRule.HOURLY ? [opts.dtstart.getUTCHours()] : null;
  } else if (isNumber(opts.byhour)) {
    opts.byhour = [opts.byhour];
  }
  if (!isPresent(opts.byminute)) {
    opts.byminute = opts.freq < RRule.MINUTELY ? [opts.dtstart.getUTCMinutes()] : null;
  } else if (isNumber(opts.byminute)) {
    opts.byminute = [opts.byminute];
  }
  if (!isPresent(opts.bysecond)) {
    opts.bysecond = opts.freq < RRule.SECONDLY ? [opts.dtstart.getUTCSeconds()] : null;
  } else if (isNumber(opts.bysecond)) {
    opts.bysecond = [opts.bysecond];
  }
  return { parsedOptions: opts };
}
function buildTimeset(opts) {
  var millisecondModulo = opts.dtstart.getTime() % 1e3;
  if (!freqIsDailyOrGreater(opts.freq)) {
    return [];
  }
  var timeset = [];
  opts.byhour.forEach(function(hour) {
    opts.byminute.forEach(function(minute) {
      opts.bysecond.forEach(function(second) {
        timeset.push(new Time(hour, minute, second, millisecondModulo));
      });
    });
  });
  return timeset;
}

// node_modules/rrule/dist/esm/parsestring.js
function parseString2(rfcString) {
  var options = rfcString.split("\n").map(parseLine).filter(function(x4) {
    return x4 !== null;
  });
  return __assign(__assign({}, options[0]), options[1]);
}
function parseDtstart(line) {
  var options = {};
  var dtstartWithZone = /DTSTART(?:;TZID=([^:=]+?))?(?::|=)([^;\s]+)/i.exec(line);
  if (!dtstartWithZone) {
    return options;
  }
  var tzid = dtstartWithZone[1], dtstart = dtstartWithZone[2];
  if (tzid) {
    options.tzid = tzid;
  }
  options.dtstart = untilStringToDate(dtstart);
  return options;
}
function parseLine(rfcString) {
  rfcString = rfcString.replace(/^\s+|\s+$/, "");
  if (!rfcString.length)
    return null;
  var header = /^([A-Z]+?)[:;]/.exec(rfcString.toUpperCase());
  if (!header) {
    return parseRrule(rfcString);
  }
  var key = header[1];
  switch (key.toUpperCase()) {
    case "RRULE":
    case "EXRULE":
      return parseRrule(rfcString);
    case "DTSTART":
      return parseDtstart(rfcString);
    default:
      throw new Error("Unsupported RFC prop ".concat(key, " in ").concat(rfcString));
  }
}
function parseRrule(line) {
  var strippedLine = line.replace(/^RRULE:/i, "");
  var options = parseDtstart(strippedLine);
  var attrs = line.replace(/^(?:RRULE|EXRULE):/i, "").split(";");
  attrs.forEach(function(attr) {
    var _a = attr.split("="), key = _a[0], value = _a[1];
    switch (key.toUpperCase()) {
      case "FREQ":
        options.freq = Frequency[value.toUpperCase()];
        break;
      case "WKST":
        options.wkst = Days[value.toUpperCase()];
        break;
      case "COUNT":
      case "INTERVAL":
      case "BYSETPOS":
      case "BYMONTH":
      case "BYMONTHDAY":
      case "BYYEARDAY":
      case "BYWEEKNO":
      case "BYHOUR":
      case "BYMINUTE":
      case "BYSECOND":
        var num = parseNumber(value);
        var optionKey = key.toLowerCase();
        options[optionKey] = num;
        break;
      case "BYWEEKDAY":
      case "BYDAY":
        options.byweekday = parseWeekday(value);
        break;
      case "DTSTART":
      case "TZID":
        var dtstart = parseDtstart(line);
        options.tzid = dtstart.tzid;
        options.dtstart = dtstart.dtstart;
        break;
      case "UNTIL":
        options.until = untilStringToDate(value);
        break;
      case "BYEASTER":
        options.byeaster = Number(value);
        break;
      default:
        throw new Error("Unknown RRULE property '" + key + "'");
    }
  });
  return options;
}
function parseNumber(value) {
  if (value.indexOf(",") !== -1) {
    var values = value.split(",");
    return values.map(parseIndividualNumber);
  }
  return parseIndividualNumber(value);
}
function parseIndividualNumber(value) {
  if (/^[+-]?\d+$/.test(value)) {
    return Number(value);
  }
  return value;
}
function parseWeekday(value) {
  var days = value.split(",");
  return days.map(function(day) {
    if (day.length === 2) {
      return Days[day];
    }
    var parts = day.match(/^([+-]?\d{1,2})([A-Z]{2})$/);
    if (!parts || parts.length < 3) {
      throw new SyntaxError("Invalid weekday string: ".concat(day));
    }
    var n2 = Number(parts[1]);
    var wdaypart = parts[2];
    var wday = Days[wdaypart].weekday;
    return new Weekday(wday, n2);
  });
}

// node_modules/rrule/dist/esm/datewithzone.js
var DateWithZone = (
  /** @class */
  function() {
    function DateWithZone2(date, tzid) {
      if (isNaN(date.getTime())) {
        throw new RangeError("Invalid date passed to DateWithZone");
      }
      this.date = date;
      this.tzid = tzid;
    }
    Object.defineProperty(DateWithZone2.prototype, "isUTC", {
      get: function() {
        return !this.tzid || this.tzid.toUpperCase() === "UTC";
      },
      enumerable: false,
      configurable: true
    });
    DateWithZone2.prototype.toString = function() {
      var datestr = timeToUntilString(this.date.getTime(), this.isUTC);
      if (!this.isUTC) {
        return ";TZID=".concat(this.tzid, ":").concat(datestr);
      }
      return ":".concat(datestr);
    };
    DateWithZone2.prototype.getTime = function() {
      return this.date.getTime();
    };
    DateWithZone2.prototype.rezonedDate = function() {
      if (this.isUTC) {
        return this.date;
      }
      return dateInTimeZone(this.date, this.tzid);
    };
    return DateWithZone2;
  }()
);

// node_modules/rrule/dist/esm/optionstostring.js
function optionsToString(options) {
  var rrule = [];
  var dtstart = "";
  var keys = Object.keys(options);
  var defaultKeys2 = Object.keys(DEFAULT_OPTIONS);
  for (var i3 = 0; i3 < keys.length; i3++) {
    if (keys[i3] === "tzid")
      continue;
    if (!includes(defaultKeys2, keys[i3]))
      continue;
    var key = keys[i3].toUpperCase();
    var value = options[keys[i3]];
    var outValue = "";
    if (!isPresent(value) || isArray(value) && !value.length)
      continue;
    switch (key) {
      case "FREQ":
        outValue = RRule.FREQUENCIES[options.freq];
        break;
      case "WKST":
        if (isNumber(value)) {
          outValue = new Weekday(value).toString();
        } else {
          outValue = value.toString();
        }
        break;
      case "BYWEEKDAY":
        key = "BYDAY";
        outValue = toArray(value).map(function(wday) {
          if (wday instanceof Weekday) {
            return wday;
          }
          if (isArray(wday)) {
            return new Weekday(wday[0], wday[1]);
          }
          return new Weekday(wday);
        }).toString();
        break;
      case "DTSTART":
        dtstart = buildDtstart(value, options.tzid);
        break;
      case "UNTIL":
        outValue = timeToUntilString(value, !options.tzid);
        break;
      default:
        if (isArray(value)) {
          var strValues = [];
          for (var j4 = 0; j4 < value.length; j4++) {
            strValues[j4] = String(value[j4]);
          }
          outValue = strValues.toString();
        } else {
          outValue = String(value);
        }
    }
    if (outValue) {
      rrule.push([key, outValue]);
    }
  }
  var rules = rrule.map(function(_a) {
    var key2 = _a[0], value2 = _a[1];
    return "".concat(key2, "=").concat(value2.toString());
  }).join(";");
  var ruleString = "";
  if (rules !== "") {
    ruleString = "RRULE:".concat(rules);
  }
  return [dtstart, ruleString].filter(function(x4) {
    return !!x4;
  }).join("\n");
}
function buildDtstart(dtstart, tzid) {
  if (!dtstart) {
    return "";
  }
  return "DTSTART" + new DateWithZone(new Date(dtstart), tzid).toString();
}

// node_modules/rrule/dist/esm/cache.js
function argsMatch(left, right) {
  if (Array.isArray(left)) {
    if (!Array.isArray(right))
      return false;
    if (left.length !== right.length)
      return false;
    return left.every(function(date, i3) {
      return date.getTime() === right[i3].getTime();
    });
  }
  if (left instanceof Date) {
    return right instanceof Date && left.getTime() === right.getTime();
  }
  return left === right;
}
var Cache = (
  /** @class */
  function() {
    function Cache3() {
      this.all = false;
      this.before = [];
      this.after = [];
      this.between = [];
    }
    Cache3.prototype._cacheAdd = function(what, value, args) {
      if (value) {
        value = value instanceof Date ? clone(value) : cloneDates(value);
      }
      if (what === "all") {
        this.all = value;
      } else {
        args._value = value;
        this[what].push(args);
      }
    };
    Cache3.prototype._cacheGet = function(what, args) {
      var cached = false;
      var argsKeys = args ? Object.keys(args) : [];
      var findCacheDiff = function(item2) {
        for (var i4 = 0; i4 < argsKeys.length; i4++) {
          var key = argsKeys[i4];
          if (!argsMatch(args[key], item2[key])) {
            return true;
          }
        }
        return false;
      };
      var cachedObject = this[what];
      if (what === "all") {
        cached = this.all;
      } else if (isArray(cachedObject)) {
        for (var i3 = 0; i3 < cachedObject.length; i3++) {
          var item = cachedObject[i3];
          if (argsKeys.length && findCacheDiff(item))
            continue;
          cached = item._value;
          break;
        }
      }
      if (!cached && this.all) {
        var iterResult = new iterresult_default(what, args);
        for (var i3 = 0; i3 < this.all.length; i3++) {
          if (!iterResult.accept(this.all[i3]))
            break;
        }
        cached = iterResult.getValue();
        this._cacheAdd(what, cached, args);
      }
      return isArray(cached) ? cloneDates(cached) : cached instanceof Date ? clone(cached) : cached;
    };
    return Cache3;
  }()
);

// node_modules/rrule/dist/esm/masks.js
var M365MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], repeat(1, 31), true), repeat(2, 28), true), repeat(3, 31), true), repeat(4, 30), true), repeat(5, 31), true), repeat(6, 30), true), repeat(7, 31), true), repeat(8, 31), true), repeat(9, 30), true), repeat(10, 31), true), repeat(11, 30), true), repeat(12, 31), true), repeat(1, 7), true);
var M366MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], repeat(1, 31), true), repeat(2, 29), true), repeat(3, 31), true), repeat(4, 30), true), repeat(5, 31), true), repeat(6, 30), true), repeat(7, 31), true), repeat(8, 31), true), repeat(9, 30), true), repeat(10, 31), true), repeat(11, 30), true), repeat(12, 31), true), repeat(1, 7), true);
var M28 = range(1, 29);
var M29 = range(1, 30);
var M30 = range(1, 31);
var M31 = range(1, 32);
var MDAY366MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], M31, true), M29, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31.slice(0, 7), true);
var MDAY365MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], M31, true), M28, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31.slice(0, 7), true);
var NM28 = range(-28, 0);
var NM29 = range(-29, 0);
var NM30 = range(-30, 0);
var NM31 = range(-31, 0);
var NMDAY366MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], NM31, true), NM29, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31.slice(0, 7), true);
var NMDAY365MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], NM31, true), NM28, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31.slice(0, 7), true);
var M366RANGE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366];
var M365RANGE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365];
var WDAYMASK = function() {
  var wdaymask = [];
  for (var i3 = 0; i3 < 55; i3++)
    wdaymask = wdaymask.concat(range(7));
  return wdaymask;
}();

// node_modules/rrule/dist/esm/iterinfo/yearinfo.js
function rebuildYear(year, options) {
  var firstyday = datetime(year, 1, 1);
  var yearlen = isLeapYear(year) ? 366 : 365;
  var nextyearlen = isLeapYear(year + 1) ? 366 : 365;
  var yearordinal = toOrdinal(firstyday);
  var yearweekday = getWeekday(firstyday);
  var result = __assign(__assign({ yearlen, nextyearlen, yearordinal, yearweekday }, baseYearMasks(year)), { wnomask: null });
  if (empty(options.byweekno)) {
    return result;
  }
  result.wnomask = repeat(0, yearlen + 7);
  var firstwkst;
  var wyearlen;
  var no1wkst = firstwkst = pymod(7 - yearweekday + options.wkst, 7);
  if (no1wkst >= 4) {
    no1wkst = 0;
    wyearlen = result.yearlen + pymod(yearweekday - options.wkst, 7);
  } else {
    wyearlen = yearlen - no1wkst;
  }
  var div = Math.floor(wyearlen / 7);
  var mod = pymod(wyearlen, 7);
  var numweeks = Math.floor(div + mod / 4);
  for (var j4 = 0; j4 < options.byweekno.length; j4++) {
    var n2 = options.byweekno[j4];
    if (n2 < 0) {
      n2 += numweeks + 1;
    }
    if (!(n2 > 0 && n2 <= numweeks)) {
      continue;
    }
    var i3 = void 0;
    if (n2 > 1) {
      i3 = no1wkst + (n2 - 1) * 7;
      if (no1wkst !== firstwkst) {
        i3 -= 7 - firstwkst;
      }
    } else {
      i3 = no1wkst;
    }
    for (var k3 = 0; k3 < 7; k3++) {
      result.wnomask[i3] = 1;
      i3++;
      if (result.wdaymask[i3] === options.wkst)
        break;
    }
  }
  if (includes(options.byweekno, 1)) {
    var i3 = no1wkst + numweeks * 7;
    if (no1wkst !== firstwkst)
      i3 -= 7 - firstwkst;
    if (i3 < yearlen) {
      for (var j4 = 0; j4 < 7; j4++) {
        result.wnomask[i3] = 1;
        i3 += 1;
        if (result.wdaymask[i3] === options.wkst)
          break;
      }
    }
  }
  if (no1wkst) {
    var lnumweeks = void 0;
    if (!includes(options.byweekno, -1)) {
      var lyearweekday = getWeekday(datetime(year - 1, 1, 1));
      var lno1wkst = pymod(7 - lyearweekday.valueOf() + options.wkst, 7);
      var lyearlen = isLeapYear(year - 1) ? 366 : 365;
      var weekst = void 0;
      if (lno1wkst >= 4) {
        lno1wkst = 0;
        weekst = lyearlen + pymod(lyearweekday - options.wkst, 7);
      } else {
        weekst = yearlen - no1wkst;
      }
      lnumweeks = Math.floor(52 + pymod(weekst, 7) / 4);
    } else {
      lnumweeks = -1;
    }
    if (includes(options.byweekno, lnumweeks)) {
      for (var i3 = 0; i3 < no1wkst; i3++)
        result.wnomask[i3] = 1;
    }
  }
  return result;
}
function baseYearMasks(year) {
  var yearlen = isLeapYear(year) ? 366 : 365;
  var firstyday = datetime(year, 1, 1);
  var wday = getWeekday(firstyday);
  if (yearlen === 365) {
    return {
      mmask: M365MASK,
      mdaymask: MDAY365MASK,
      nmdaymask: NMDAY365MASK,
      wdaymask: WDAYMASK.slice(wday),
      mrange: M365RANGE
    };
  }
  return {
    mmask: M366MASK,
    mdaymask: MDAY366MASK,
    nmdaymask: NMDAY366MASK,
    wdaymask: WDAYMASK.slice(wday),
    mrange: M366RANGE
  };
}

// node_modules/rrule/dist/esm/iterinfo/monthinfo.js
function rebuildMonth(year, month, yearlen, mrange, wdaymask, options) {
  var result = {
    lastyear: year,
    lastmonth: month,
    nwdaymask: []
  };
  var ranges = [];
  if (options.freq === RRule.YEARLY) {
    if (empty(options.bymonth)) {
      ranges = [[0, yearlen]];
    } else {
      for (var j4 = 0; j4 < options.bymonth.length; j4++) {
        month = options.bymonth[j4];
        ranges.push(mrange.slice(month - 1, month + 1));
      }
    }
  } else if (options.freq === RRule.MONTHLY) {
    ranges = [mrange.slice(month - 1, month + 1)];
  }
  if (empty(ranges)) {
    return result;
  }
  result.nwdaymask = repeat(0, yearlen);
  for (var j4 = 0; j4 < ranges.length; j4++) {
    var rang = ranges[j4];
    var first = rang[0];
    var last = rang[1] - 1;
    for (var k3 = 0; k3 < options.bynweekday.length; k3++) {
      var i3 = void 0;
      var _a = options.bynweekday[k3], wday = _a[0], n2 = _a[1];
      if (n2 < 0) {
        i3 = last + (n2 + 1) * 7;
        i3 -= pymod(wdaymask[i3] - wday, 7);
      } else {
        i3 = first + (n2 - 1) * 7;
        i3 += pymod(7 - wdaymask[i3] + wday, 7);
      }
      if (first <= i3 && i3 <= last)
        result.nwdaymask[i3] = 1;
    }
  }
  return result;
}

// node_modules/rrule/dist/esm/iterinfo/easter.js
function easter(y3, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var a3 = y3 % 19;
  var b3 = Math.floor(y3 / 100);
  var c3 = y3 % 100;
  var d2 = Math.floor(b3 / 4);
  var e3 = b3 % 4;
  var f3 = Math.floor((b3 + 8) / 25);
  var g4 = Math.floor((b3 - f3 + 1) / 3);
  var h3 = Math.floor(19 * a3 + b3 - d2 - g4 + 15) % 30;
  var i3 = Math.floor(c3 / 4);
  var k3 = c3 % 4;
  var l3 = Math.floor(32 + 2 * e3 + 2 * i3 - h3 - k3) % 7;
  var m3 = Math.floor((a3 + 11 * h3 + 22 * l3) / 451);
  var month = Math.floor((h3 + l3 - 7 * m3 + 114) / 31);
  var day = (h3 + l3 - 7 * m3 + 114) % 31 + 1;
  var date = Date.UTC(y3, month - 1, day + offset);
  var yearStart = Date.UTC(y3, 0, 1);
  return [Math.ceil((date - yearStart) / (1e3 * 60 * 60 * 24))];
}

// node_modules/rrule/dist/esm/iterinfo/index.js
var Iterinfo = (
  /** @class */
  function() {
    function Iterinfo2(options) {
      this.options = options;
    }
    Iterinfo2.prototype.rebuild = function(year, month) {
      var options = this.options;
      if (year !== this.lastyear) {
        this.yearinfo = rebuildYear(year, options);
      }
      if (notEmpty(options.bynweekday) && (month !== this.lastmonth || year !== this.lastyear)) {
        var _a = this.yearinfo, yearlen = _a.yearlen, mrange = _a.mrange, wdaymask = _a.wdaymask;
        this.monthinfo = rebuildMonth(year, month, yearlen, mrange, wdaymask, options);
      }
      if (isPresent(options.byeaster)) {
        this.eastermask = easter(year, options.byeaster);
      }
    };
    Object.defineProperty(Iterinfo2.prototype, "lastyear", {
      get: function() {
        return this.monthinfo ? this.monthinfo.lastyear : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "lastmonth", {
      get: function() {
        return this.monthinfo ? this.monthinfo.lastmonth : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "yearlen", {
      get: function() {
        return this.yearinfo.yearlen;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "yearordinal", {
      get: function() {
        return this.yearinfo.yearordinal;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "mrange", {
      get: function() {
        return this.yearinfo.mrange;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "wdaymask", {
      get: function() {
        return this.yearinfo.wdaymask;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "mmask", {
      get: function() {
        return this.yearinfo.mmask;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "wnomask", {
      get: function() {
        return this.yearinfo.wnomask;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "nwdaymask", {
      get: function() {
        return this.monthinfo ? this.monthinfo.nwdaymask : [];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "nextyearlen", {
      get: function() {
        return this.yearinfo.nextyearlen;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "mdaymask", {
      get: function() {
        return this.yearinfo.mdaymask;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "nmdaymask", {
      get: function() {
        return this.yearinfo.nmdaymask;
      },
      enumerable: false,
      configurable: true
    });
    Iterinfo2.prototype.ydayset = function() {
      return [range(this.yearlen), 0, this.yearlen];
    };
    Iterinfo2.prototype.mdayset = function(_3, month) {
      var start = this.mrange[month - 1];
      var end = this.mrange[month];
      var set = repeat(null, this.yearlen);
      for (var i3 = start; i3 < end; i3++)
        set[i3] = i3;
      return [set, start, end];
    };
    Iterinfo2.prototype.wdayset = function(year, month, day) {
      var set = repeat(null, this.yearlen + 7);
      var i3 = toOrdinal(datetime(year, month, day)) - this.yearordinal;
      var start = i3;
      for (var j4 = 0; j4 < 7; j4++) {
        set[i3] = i3;
        ++i3;
        if (this.wdaymask[i3] === this.options.wkst)
          break;
      }
      return [set, start, i3];
    };
    Iterinfo2.prototype.ddayset = function(year, month, day) {
      var set = repeat(null, this.yearlen);
      var i3 = toOrdinal(datetime(year, month, day)) - this.yearordinal;
      set[i3] = i3;
      return [set, i3, i3 + 1];
    };
    Iterinfo2.prototype.htimeset = function(hour, _3, second, millisecond) {
      var _this = this;
      var set = [];
      this.options.byminute.forEach(function(minute) {
        set = set.concat(_this.mtimeset(hour, minute, second, millisecond));
      });
      sort(set);
      return set;
    };
    Iterinfo2.prototype.mtimeset = function(hour, minute, _3, millisecond) {
      var set = this.options.bysecond.map(function(second) {
        return new Time(hour, minute, second, millisecond);
      });
      sort(set);
      return set;
    };
    Iterinfo2.prototype.stimeset = function(hour, minute, second, millisecond) {
      return [new Time(hour, minute, second, millisecond)];
    };
    Iterinfo2.prototype.getdayset = function(freq) {
      switch (freq) {
        case Frequency.YEARLY:
          return this.ydayset.bind(this);
        case Frequency.MONTHLY:
          return this.mdayset.bind(this);
        case Frequency.WEEKLY:
          return this.wdayset.bind(this);
        case Frequency.DAILY:
          return this.ddayset.bind(this);
        default:
          return this.ddayset.bind(this);
      }
    };
    Iterinfo2.prototype.gettimeset = function(freq) {
      switch (freq) {
        case Frequency.HOURLY:
          return this.htimeset.bind(this);
        case Frequency.MINUTELY:
          return this.mtimeset.bind(this);
        case Frequency.SECONDLY:
          return this.stimeset.bind(this);
      }
    };
    return Iterinfo2;
  }()
);
var iterinfo_default = Iterinfo;

// node_modules/rrule/dist/esm/iter/poslist.js
function buildPoslist(bysetpos, timeset, start, end, ii, dayset) {
  var poslist = [];
  for (var j4 = 0; j4 < bysetpos.length; j4++) {
    var daypos = void 0;
    var timepos = void 0;
    var pos = bysetpos[j4];
    if (pos < 0) {
      daypos = Math.floor(pos / timeset.length);
      timepos = pymod(pos, timeset.length);
    } else {
      daypos = Math.floor((pos - 1) / timeset.length);
      timepos = pymod(pos - 1, timeset.length);
    }
    var tmp = [];
    for (var k3 = start; k3 < end; k3++) {
      var val = dayset[k3];
      if (!isPresent(val))
        continue;
      tmp.push(val);
    }
    var i3 = void 0;
    if (daypos < 0) {
      i3 = tmp.slice(daypos)[0];
    } else {
      i3 = tmp[daypos];
    }
    var time = timeset[timepos];
    var date = fromOrdinal(ii.yearordinal + i3);
    var res = combine(date, time);
    if (!includes(poslist, res))
      poslist.push(res);
  }
  sort(poslist);
  return poslist;
}

// node_modules/rrule/dist/esm/iter/index.js
function iter(iterResult, options) {
  var dtstart = options.dtstart, freq = options.freq, interval = options.interval, until = options.until, bysetpos = options.bysetpos;
  var count = options.count;
  if (count === 0 || interval === 0) {
    return emitResult(iterResult);
  }
  var counterDate = DateTime.fromDate(dtstart);
  var ii = new iterinfo_default(options);
  ii.rebuild(counterDate.year, counterDate.month);
  var timeset = makeTimeset(ii, counterDate, options);
  for (; ; ) {
    var _a = ii.getdayset(freq)(counterDate.year, counterDate.month, counterDate.day), dayset = _a[0], start = _a[1], end = _a[2];
    var filtered = removeFilteredDays(dayset, start, end, ii, options);
    if (notEmpty(bysetpos)) {
      var poslist = buildPoslist(bysetpos, timeset, start, end, ii, dayset);
      for (var j4 = 0; j4 < poslist.length; j4++) {
        var res = poslist[j4];
        if (until && res > until) {
          return emitResult(iterResult);
        }
        if (res >= dtstart) {
          var rezonedDate = rezoneIfNeeded(res, options);
          if (!iterResult.accept(rezonedDate)) {
            return emitResult(iterResult);
          }
          if (count) {
            --count;
            if (!count) {
              return emitResult(iterResult);
            }
          }
        }
      }
    } else {
      for (var j4 = start; j4 < end; j4++) {
        var currentDay = dayset[j4];
        if (!isPresent(currentDay)) {
          continue;
        }
        var date = fromOrdinal(ii.yearordinal + currentDay);
        for (var k3 = 0; k3 < timeset.length; k3++) {
          var time = timeset[k3];
          var res = combine(date, time);
          if (until && res > until) {
            return emitResult(iterResult);
          }
          if (res >= dtstart) {
            var rezonedDate = rezoneIfNeeded(res, options);
            if (!iterResult.accept(rezonedDate)) {
              return emitResult(iterResult);
            }
            if (count) {
              --count;
              if (!count) {
                return emitResult(iterResult);
              }
            }
          }
        }
      }
    }
    if (options.interval === 0) {
      return emitResult(iterResult);
    }
    counterDate.add(options, filtered);
    if (counterDate.year > MAXYEAR) {
      return emitResult(iterResult);
    }
    if (!freqIsDailyOrGreater(freq)) {
      timeset = ii.gettimeset(freq)(counterDate.hour, counterDate.minute, counterDate.second, 0);
    }
    ii.rebuild(counterDate.year, counterDate.month);
  }
}
function isFiltered(ii, currentDay, options) {
  var bymonth = options.bymonth, byweekno = options.byweekno, byweekday = options.byweekday, byeaster = options.byeaster, bymonthday = options.bymonthday, bynmonthday = options.bynmonthday, byyearday = options.byyearday;
  return notEmpty(bymonth) && !includes(bymonth, ii.mmask[currentDay]) || notEmpty(byweekno) && !ii.wnomask[currentDay] || notEmpty(byweekday) && !includes(byweekday, ii.wdaymask[currentDay]) || notEmpty(ii.nwdaymask) && !ii.nwdaymask[currentDay] || byeaster !== null && !includes(ii.eastermask, currentDay) || (notEmpty(bymonthday) || notEmpty(bynmonthday)) && !includes(bymonthday, ii.mdaymask[currentDay]) && !includes(bynmonthday, ii.nmdaymask[currentDay]) || notEmpty(byyearday) && (currentDay < ii.yearlen && !includes(byyearday, currentDay + 1) && !includes(byyearday, -ii.yearlen + currentDay) || currentDay >= ii.yearlen && !includes(byyearday, currentDay + 1 - ii.yearlen) && !includes(byyearday, -ii.nextyearlen + currentDay - ii.yearlen));
}
function rezoneIfNeeded(date, options) {
  return new DateWithZone(date, options.tzid).rezonedDate();
}
function emitResult(iterResult) {
  return iterResult.getValue();
}
function removeFilteredDays(dayset, start, end, ii, options) {
  var filtered = false;
  for (var dayCounter = start; dayCounter < end; dayCounter++) {
    var currentDay = dayset[dayCounter];
    filtered = isFiltered(ii, currentDay, options);
    if (filtered)
      dayset[currentDay] = null;
  }
  return filtered;
}
function makeTimeset(ii, counterDate, options) {
  var freq = options.freq, byhour = options.byhour, byminute = options.byminute, bysecond = options.bysecond;
  if (freqIsDailyOrGreater(freq)) {
    return buildTimeset(options);
  }
  if (freq >= RRule.HOURLY && notEmpty(byhour) && !includes(byhour, counterDate.hour) || freq >= RRule.MINUTELY && notEmpty(byminute) && !includes(byminute, counterDate.minute) || freq >= RRule.SECONDLY && notEmpty(bysecond) && !includes(bysecond, counterDate.second)) {
    return [];
  }
  return ii.gettimeset(freq)(counterDate.hour, counterDate.minute, counterDate.second, counterDate.millisecond);
}

// node_modules/rrule/dist/esm/rrule.js
var Days = {
  MO: new Weekday(0),
  TU: new Weekday(1),
  WE: new Weekday(2),
  TH: new Weekday(3),
  FR: new Weekday(4),
  SA: new Weekday(5),
  SU: new Weekday(6)
};
var DEFAULT_OPTIONS = {
  freq: Frequency.YEARLY,
  dtstart: null,
  interval: 1,
  wkst: Days.MO,
  count: null,
  until: null,
  tzid: null,
  bysetpos: null,
  bymonth: null,
  bymonthday: null,
  bynmonthday: null,
  byyearday: null,
  byweekno: null,
  byweekday: null,
  bynweekday: null,
  byhour: null,
  byminute: null,
  bysecond: null,
  byeaster: null
};
var defaultKeys = Object.keys(DEFAULT_OPTIONS);
var RRule = (
  /** @class */
  function() {
    function RRule2(options, noCache) {
      if (options === void 0) {
        options = {};
      }
      if (noCache === void 0) {
        noCache = false;
      }
      this._cache = noCache ? null : new Cache();
      this.origOptions = initializeOptions(options);
      var parsedOptions = parseOptions(options).parsedOptions;
      this.options = parsedOptions;
    }
    RRule2.parseText = function(text, language) {
      return parseText(text, language);
    };
    RRule2.fromText = function(text, language) {
      return fromText(text, language);
    };
    RRule2.fromString = function(str) {
      return new RRule2(RRule2.parseString(str) || void 0);
    };
    RRule2.prototype._iter = function(iterResult) {
      return iter(iterResult, this.options);
    };
    RRule2.prototype._cacheGet = function(what, args) {
      if (!this._cache)
        return false;
      return this._cache._cacheGet(what, args);
    };
    RRule2.prototype._cacheAdd = function(what, value, args) {
      if (!this._cache)
        return;
      return this._cache._cacheAdd(what, value, args);
    };
    RRule2.prototype.all = function(iterator) {
      if (iterator) {
        return this._iter(new callbackiterresult_default("all", {}, iterator));
      }
      var result = this._cacheGet("all");
      if (result === false) {
        result = this._iter(new iterresult_default("all", {}));
        this._cacheAdd("all", result);
      }
      return result;
    };
    RRule2.prototype.between = function(after, before, inc, iterator) {
      if (inc === void 0) {
        inc = false;
      }
      if (!isValidDate2(after) || !isValidDate2(before)) {
        throw new Error("Invalid date passed in to RRule.between");
      }
      var args = {
        before,
        after,
        inc
      };
      if (iterator) {
        return this._iter(new callbackiterresult_default("between", args, iterator));
      }
      var result = this._cacheGet("between", args);
      if (result === false) {
        result = this._iter(new iterresult_default("between", args));
        this._cacheAdd("between", result, args);
      }
      return result;
    };
    RRule2.prototype.before = function(dt, inc) {
      if (inc === void 0) {
        inc = false;
      }
      if (!isValidDate2(dt)) {
        throw new Error("Invalid date passed in to RRule.before");
      }
      var args = { dt, inc };
      var result = this._cacheGet("before", args);
      if (result === false) {
        result = this._iter(new iterresult_default("before", args));
        this._cacheAdd("before", result, args);
      }
      return result;
    };
    RRule2.prototype.after = function(dt, inc) {
      if (inc === void 0) {
        inc = false;
      }
      if (!isValidDate2(dt)) {
        throw new Error("Invalid date passed in to RRule.after");
      }
      var args = { dt, inc };
      var result = this._cacheGet("after", args);
      if (result === false) {
        result = this._iter(new iterresult_default("after", args));
        this._cacheAdd("after", result, args);
      }
      return result;
    };
    RRule2.prototype.count = function() {
      return this.all().length;
    };
    RRule2.prototype.toString = function() {
      return optionsToString(this.origOptions);
    };
    RRule2.prototype.toText = function(gettext, language, dateFormatter) {
      return toText(this, gettext, language, dateFormatter);
    };
    RRule2.prototype.isFullyConvertibleToText = function() {
      return isFullyConvertible(this);
    };
    RRule2.prototype.clone = function() {
      return new RRule2(this.origOptions);
    };
    RRule2.FREQUENCIES = [
      "YEARLY",
      "MONTHLY",
      "WEEKLY",
      "DAILY",
      "HOURLY",
      "MINUTELY",
      "SECONDLY"
    ];
    RRule2.YEARLY = Frequency.YEARLY;
    RRule2.MONTHLY = Frequency.MONTHLY;
    RRule2.WEEKLY = Frequency.WEEKLY;
    RRule2.DAILY = Frequency.DAILY;
    RRule2.HOURLY = Frequency.HOURLY;
    RRule2.MINUTELY = Frequency.MINUTELY;
    RRule2.SECONDLY = Frequency.SECONDLY;
    RRule2.MO = Days.MO;
    RRule2.TU = Days.TU;
    RRule2.WE = Days.WE;
    RRule2.TH = Days.TH;
    RRule2.FR = Days.FR;
    RRule2.SA = Days.SA;
    RRule2.SU = Days.SU;
    RRule2.parseString = parseString2;
    RRule2.optionsToString = optionsToString;
    return RRule2;
  }()
);

// node_modules/rrule/dist/esm/iterset.js
function iterSet(iterResult, _rrule, _exrule, _rdate, _exdate, tzid) {
  var _exdateHash = {};
  var _accept = iterResult.accept;
  function evalExdate(after, before) {
    _exrule.forEach(function(rrule) {
      rrule.between(after, before, true).forEach(function(date) {
        _exdateHash[Number(date)] = true;
      });
    });
  }
  _exdate.forEach(function(date) {
    var zonedDate2 = new DateWithZone(date, tzid).rezonedDate();
    _exdateHash[Number(zonedDate2)] = true;
  });
  iterResult.accept = function(date) {
    var dt = Number(date);
    if (isNaN(dt))
      return _accept.call(this, date);
    if (!_exdateHash[dt]) {
      evalExdate(new Date(dt - 1), new Date(dt + 1));
      if (!_exdateHash[dt]) {
        _exdateHash[dt] = true;
        return _accept.call(this, date);
      }
    }
    return true;
  };
  if (iterResult.method === "between") {
    evalExdate(iterResult.args.after, iterResult.args.before);
    iterResult.accept = function(date) {
      var dt = Number(date);
      if (!_exdateHash[dt]) {
        _exdateHash[dt] = true;
        return _accept.call(this, date);
      }
      return true;
    };
  }
  for (var i3 = 0; i3 < _rdate.length; i3++) {
    var zonedDate = new DateWithZone(_rdate[i3], tzid).rezonedDate();
    if (!iterResult.accept(new Date(zonedDate.getTime())))
      break;
  }
  _rrule.forEach(function(rrule) {
    iter(iterResult, rrule.options);
  });
  var res = iterResult._result;
  sort(res);
  switch (iterResult.method) {
    case "all":
    case "between":
      return res;
    case "before":
      return res.length && res[res.length - 1] || null;
    case "after":
    default:
      return res.length && res[0] || null;
  }
}

// node_modules/rrule/dist/esm/rrulestr.js
var DEFAULT_OPTIONS2 = {
  dtstart: null,
  cache: false,
  unfold: false,
  forceset: false,
  compatible: false,
  tzid: null
};
function parseInput(s3, options) {
  var rrulevals = [];
  var rdatevals = [];
  var exrulevals = [];
  var exdatevals = [];
  var parsedDtstart = parseDtstart(s3);
  var dtstart = parsedDtstart.dtstart;
  var tzid = parsedDtstart.tzid;
  var lines = splitIntoLines(s3, options.unfold);
  lines.forEach(function(line) {
    var _a;
    if (!line)
      return;
    var _b = breakDownLine(line), name = _b.name, parms = _b.parms, value = _b.value;
    switch (name.toUpperCase()) {
      case "RRULE":
        if (parms.length) {
          throw new Error("unsupported RRULE parm: ".concat(parms.join(",")));
        }
        rrulevals.push(parseString2(line));
        break;
      case "RDATE":
        var _c = (_a = /RDATE(?:;TZID=([^:=]+))?/i.exec(line)) !== null && _a !== void 0 ? _a : [], rdateTzid = _c[1];
        if (rdateTzid && !tzid) {
          tzid = rdateTzid;
        }
        rdatevals = rdatevals.concat(parseRDate(value, parms));
        break;
      case "EXRULE":
        if (parms.length) {
          throw new Error("unsupported EXRULE parm: ".concat(parms.join(",")));
        }
        exrulevals.push(parseString2(value));
        break;
      case "EXDATE":
        exdatevals = exdatevals.concat(parseRDate(value, parms));
        break;
      case "DTSTART":
        break;
      default:
        throw new Error("unsupported property: " + name);
    }
  });
  return {
    dtstart,
    tzid,
    rrulevals,
    rdatevals,
    exrulevals,
    exdatevals
  };
}
function buildRule(s3, options) {
  var _a = parseInput(s3, options), rrulevals = _a.rrulevals, rdatevals = _a.rdatevals, exrulevals = _a.exrulevals, exdatevals = _a.exdatevals, dtstart = _a.dtstart, tzid = _a.tzid;
  var noCache = options.cache === false;
  if (options.compatible) {
    options.forceset = true;
    options.unfold = true;
  }
  if (options.forceset || rrulevals.length > 1 || rdatevals.length || exrulevals.length || exdatevals.length) {
    var rset_1 = new RRuleSet(noCache);
    rset_1.dtstart(dtstart);
    rset_1.tzid(tzid || void 0);
    rrulevals.forEach(function(val2) {
      rset_1.rrule(new RRule(groomRruleOptions(val2, dtstart, tzid), noCache));
    });
    rdatevals.forEach(function(date) {
      rset_1.rdate(date);
    });
    exrulevals.forEach(function(val2) {
      rset_1.exrule(new RRule(groomRruleOptions(val2, dtstart, tzid), noCache));
    });
    exdatevals.forEach(function(date) {
      rset_1.exdate(date);
    });
    if (options.compatible && options.dtstart)
      rset_1.rdate(dtstart);
    return rset_1;
  }
  var val = rrulevals[0] || {};
  return new RRule(groomRruleOptions(val, val.dtstart || options.dtstart || dtstart, val.tzid || options.tzid || tzid), noCache);
}
function rrulestr(s3, options) {
  if (options === void 0) {
    options = {};
  }
  return buildRule(s3, initializeOptions2(options));
}
function groomRruleOptions(val, dtstart, tzid) {
  return __assign(__assign({}, val), { dtstart, tzid });
}
function initializeOptions2(options) {
  var invalid = [];
  var keys = Object.keys(options);
  var defaultKeys2 = Object.keys(DEFAULT_OPTIONS2);
  keys.forEach(function(key) {
    if (!includes(defaultKeys2, key))
      invalid.push(key);
  });
  if (invalid.length) {
    throw new Error("Invalid options: " + invalid.join(", "));
  }
  return __assign(__assign({}, DEFAULT_OPTIONS2), options);
}
function extractName(line) {
  if (line.indexOf(":") === -1) {
    return {
      name: "RRULE",
      value: line
    };
  }
  var _a = split(line, ":", 1), name = _a[0], value = _a[1];
  return {
    name,
    value
  };
}
function breakDownLine(line) {
  var _a = extractName(line), name = _a.name, value = _a.value;
  var parms = name.split(";");
  if (!parms)
    throw new Error("empty property name");
  return {
    name: parms[0].toUpperCase(),
    parms: parms.slice(1),
    value
  };
}
function splitIntoLines(s3, unfold) {
  if (unfold === void 0) {
    unfold = false;
  }
  s3 = s3 && s3.trim();
  if (!s3)
    throw new Error("Invalid empty string");
  if (!unfold) {
    return s3.split(/\s/);
  }
  var lines = s3.split("\n");
  var i3 = 0;
  while (i3 < lines.length) {
    var line = lines[i3] = lines[i3].replace(/\s+$/g, "");
    if (!line) {
      lines.splice(i3, 1);
    } else if (i3 > 0 && line[0] === " ") {
      lines[i3 - 1] += line.slice(1);
      lines.splice(i3, 1);
    } else {
      i3 += 1;
    }
  }
  return lines;
}
function validateDateParm(parms) {
  parms.forEach(function(parm) {
    if (!/(VALUE=DATE(-TIME)?)|(TZID=)/.test(parm)) {
      throw new Error("unsupported RDATE/EXDATE parm: " + parm);
    }
  });
}
function parseRDate(rdateval, parms) {
  validateDateParm(parms);
  return rdateval.split(",").map(function(datestr) {
    return untilStringToDate(datestr);
  });
}

// node_modules/rrule/dist/esm/rruleset.js
function createGetterSetter(fieldName) {
  var _this = this;
  return function(field) {
    if (field !== void 0) {
      _this["_".concat(fieldName)] = field;
    }
    if (_this["_".concat(fieldName)] !== void 0) {
      return _this["_".concat(fieldName)];
    }
    for (var i3 = 0; i3 < _this._rrule.length; i3++) {
      var field_1 = _this._rrule[i3].origOptions[fieldName];
      if (field_1) {
        return field_1;
      }
    }
  };
}
var RRuleSet = (
  /** @class */
  function(_super) {
    __extends(RRuleSet2, _super);
    function RRuleSet2(noCache) {
      if (noCache === void 0) {
        noCache = false;
      }
      var _this = _super.call(this, {}, noCache) || this;
      _this.dtstart = createGetterSetter.apply(_this, ["dtstart"]);
      _this.tzid = createGetterSetter.apply(_this, ["tzid"]);
      _this._rrule = [];
      _this._rdate = [];
      _this._exrule = [];
      _this._exdate = [];
      return _this;
    }
    RRuleSet2.prototype._iter = function(iterResult) {
      return iterSet(iterResult, this._rrule, this._exrule, this._rdate, this._exdate, this.tzid());
    };
    RRuleSet2.prototype.rrule = function(rrule) {
      _addRule(rrule, this._rrule);
    };
    RRuleSet2.prototype.exrule = function(rrule) {
      _addRule(rrule, this._exrule);
    };
    RRuleSet2.prototype.rdate = function(date) {
      _addDate(date, this._rdate);
    };
    RRuleSet2.prototype.exdate = function(date) {
      _addDate(date, this._exdate);
    };
    RRuleSet2.prototype.rrules = function() {
      return this._rrule.map(function(e3) {
        return rrulestr(e3.toString());
      });
    };
    RRuleSet2.prototype.exrules = function() {
      return this._exrule.map(function(e3) {
        return rrulestr(e3.toString());
      });
    };
    RRuleSet2.prototype.rdates = function() {
      return this._rdate.map(function(e3) {
        return new Date(e3.getTime());
      });
    };
    RRuleSet2.prototype.exdates = function() {
      return this._exdate.map(function(e3) {
        return new Date(e3.getTime());
      });
    };
    RRuleSet2.prototype.valueOf = function() {
      var result = [];
      if (!this._rrule.length && this._dtstart) {
        result = result.concat(optionsToString({ dtstart: this._dtstart }));
      }
      this._rrule.forEach(function(rrule) {
        result = result.concat(rrule.toString().split("\n"));
      });
      this._exrule.forEach(function(exrule) {
        result = result.concat(exrule.toString().split("\n").map(function(line) {
          return line.replace(/^RRULE:/, "EXRULE:");
        }).filter(function(line) {
          return !/^DTSTART/.test(line);
        }));
      });
      if (this._rdate.length) {
        result.push(rdatesToString("RDATE", this._rdate, this.tzid()));
      }
      if (this._exdate.length) {
        result.push(rdatesToString("EXDATE", this._exdate, this.tzid()));
      }
      return result;
    };
    RRuleSet2.prototype.toString = function() {
      return this.valueOf().join("\n");
    };
    RRuleSet2.prototype.clone = function() {
      var rrs = new RRuleSet2(!!this._cache);
      this._rrule.forEach(function(rule) {
        return rrs.rrule(rule.clone());
      });
      this._exrule.forEach(function(rule) {
        return rrs.exrule(rule.clone());
      });
      this._rdate.forEach(function(date) {
        return rrs.rdate(new Date(date.getTime()));
      });
      this._exdate.forEach(function(date) {
        return rrs.exdate(new Date(date.getTime()));
      });
      return rrs;
    };
    return RRuleSet2;
  }(RRule)
);
function _addRule(rrule, collection) {
  if (!(rrule instanceof RRule)) {
    throw new TypeError(String(rrule) + " is not RRule instance");
  }
  if (!includes(collection.map(String), String(rrule))) {
    collection.push(rrule);
  }
}
function _addDate(date, collection) {
  if (!(date instanceof Date)) {
    throw new TypeError(String(date) + " is not Date instance");
  }
  if (!includes(collection.map(Number), Number(date))) {
    collection.push(date);
    sort(collection);
  }
}
function rdatesToString(param, rdates, tzid) {
  var isUTC = !tzid || tzid.toUpperCase() === "UTC";
  var header = isUTC ? "".concat(param, ":") : "".concat(param, ";TZID=").concat(tzid, ":");
  var dateString = rdates.map(function(rdate) {
    return timeToUntilString(rdate.valueOf(), isUTC);
  }).join(",");
  return "".concat(header).concat(dateString);
}

// node_modules/@fullcalendar/rrule/index.js
var recurringType = {
  parse(eventProps, dateEnv) {
    if (eventProps.rrule != null) {
      let eventRRuleData = parseEventRRule(eventProps, dateEnv);
      if (eventRRuleData) {
        return {
          typeData: { rruleSet: eventRRuleData.rruleSet, isTimeZoneSpecified: eventRRuleData.isTimeZoneSpecified },
          allDayGuess: !eventRRuleData.isTimeSpecified,
          duration: eventProps.duration
        };
      }
    }
    return null;
  },
  expand(eventRRuleData, framingRange, dateEnv) {
    let dates;
    if (eventRRuleData.isTimeZoneSpecified) {
      dates = eventRRuleData.rruleSet.between(
        dateEnv.toDate(framingRange.start),
        // rrule lib will treat as UTC-zoned
        dateEnv.toDate(framingRange.end),
        // (same)
        true
      ).map((date) => dateEnv.createMarker(date));
    } else {
      dates = eventRRuleData.rruleSet.between(framingRange.start, framingRange.end, true);
    }
    return dates;
  }
};
function parseEventRRule(eventProps, dateEnv) {
  let rruleSet;
  let isTimeSpecified = false;
  let isTimeZoneSpecified = false;
  if (typeof eventProps.rrule === "string") {
    let res = parseRRuleString(eventProps.rrule);
    rruleSet = res.rruleSet;
    isTimeSpecified = res.isTimeSpecified;
    isTimeZoneSpecified = res.isTimeZoneSpecified;
  }
  if (typeof eventProps.rrule === "object" && eventProps.rrule) {
    let res = parseRRuleObject(eventProps.rrule, dateEnv);
    rruleSet = new RRuleSet();
    rruleSet.rrule(res.rrule);
    isTimeSpecified = res.isTimeSpecified;
    isTimeZoneSpecified = res.isTimeZoneSpecified;
  }
  let exdateInputs = [].concat(eventProps.exdate || []);
  let exruleInputs = [].concat(eventProps.exrule || []);
  for (let exdateInput of exdateInputs) {
    let res = parse(exdateInput);
    isTimeSpecified = isTimeSpecified || !res.isTimeUnspecified;
    isTimeZoneSpecified = isTimeZoneSpecified || res.timeZoneOffset !== null;
    rruleSet.exdate(new Date(res.marker.valueOf() - (res.timeZoneOffset || 0) * 60 * 1e3));
  }
  for (let exruleInput of exruleInputs) {
    let res = parseRRuleObject(exruleInput, dateEnv);
    isTimeSpecified = isTimeSpecified || res.isTimeSpecified;
    isTimeZoneSpecified = isTimeZoneSpecified || res.isTimeZoneSpecified;
    rruleSet.exrule(res.rrule);
  }
  return { rruleSet, isTimeSpecified, isTimeZoneSpecified };
}
function parseRRuleObject(rruleInput, dateEnv) {
  let isTimeSpecified = false;
  let isTimeZoneSpecified = false;
  function processDateInput(dateInput) {
    if (typeof dateInput === "string") {
      let markerData = parse(dateInput);
      if (markerData) {
        isTimeSpecified = isTimeSpecified || !markerData.isTimeUnspecified;
        isTimeZoneSpecified = isTimeZoneSpecified || markerData.timeZoneOffset !== null;
        return new Date(markerData.marker.valueOf() - (markerData.timeZoneOffset || 0) * 60 * 1e3);
      }
      return null;
    }
    return dateInput;
  }
  let rruleOptions = Object.assign(Object.assign({}, rruleInput), { dtstart: processDateInput(rruleInput.dtstart), until: processDateInput(rruleInput.until), freq: convertConstant(rruleInput.freq), wkst: rruleInput.wkst == null ? (dateEnv.weekDow - 1 + 7) % 7 : convertConstant(rruleInput.wkst), byweekday: convertConstants(rruleInput.byweekday) });
  return { rrule: new RRule(rruleOptions), isTimeSpecified, isTimeZoneSpecified };
}
function parseRRuleString(str) {
  let rruleSet = rrulestr(str, { forceset: true });
  let analysis = analyzeRRuleString(str);
  return Object.assign({ rruleSet }, analysis);
}
function analyzeRRuleString(str) {
  let isTimeSpecified = false;
  let isTimeZoneSpecified = false;
  function processMatch(whole, introPart, datePart) {
    let result = parse(datePart);
    isTimeSpecified = isTimeSpecified || !result.isTimeUnspecified;
    isTimeZoneSpecified = isTimeZoneSpecified || result.timeZoneOffset !== null;
  }
  str.replace(/\b(DTSTART:)([^\n]*)/, processMatch);
  str.replace(/\b(EXDATE:)([^\n]*)/, processMatch);
  str.replace(/\b(UNTIL=)([^;\n]*)/, processMatch);
  return { isTimeSpecified, isTimeZoneSpecified };
}
function convertConstants(input) {
  if (Array.isArray(input)) {
    return input.map(convertConstant);
  }
  return convertConstant(input);
}
function convertConstant(input) {
  if (typeof input === "string") {
    return RRule[input.toUpperCase()];
  }
  return input;
}
var RRULE_EVENT_REFINERS = {
  rrule: identity,
  exrule: identity,
  exdate: identity,
  duration: createDuration
};
var index3 = createPlugin({
  name: "@fullcalendar/rrule",
  recurringTypes: [recurringType],
  eventRefiners: RRULE_EVENT_REFINERS
});

// node_modules/@fullcalendar/list/internal.js
var ListViewHeaderRow = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.state = {
      textId: getUniqueDomId()
    };
  }
  render() {
    let { theme, dateEnv, options, viewApi } = this.context;
    let { cellId, dayDate, todayRange } = this.props;
    let { textId } = this.state;
    let dayMeta = getDateMeta(dayDate, todayRange);
    let text = options.listDayFormat ? dateEnv.format(dayDate, options.listDayFormat) : "";
    let sideText = options.listDaySideFormat ? dateEnv.format(dayDate, options.listDaySideFormat) : "";
    let renderProps = Object.assign({
      date: dateEnv.toDate(dayDate),
      view: viewApi,
      textId,
      text,
      sideText,
      navLinkAttrs: buildNavLinkAttrs(this.context, dayDate),
      sideNavLinkAttrs: buildNavLinkAttrs(this.context, dayDate, "day", false)
    }, dayMeta);
    return y(ContentContainer, { elTag: "tr", elClasses: [
      "fc-list-day",
      ...getDayClassNames(dayMeta, theme)
    ], elAttrs: {
      "data-date": formatDayString(dayDate)
    }, renderProps, generatorName: "dayHeaderContent", customGenerator: options.dayHeaderContent, defaultGenerator: renderInnerContent4, classNameGenerator: options.dayHeaderClassNames, didMount: options.dayHeaderDidMount, willUnmount: options.dayHeaderWillUnmount }, (InnerContent) => (
      // TODO: force-hide top border based on :first-child
      y(
        "th",
        { scope: "colgroup", colSpan: 3, id: cellId, "aria-labelledby": textId },
        y(InnerContent, { elTag: "div", elClasses: [
          "fc-list-day-cushion",
          theme.getClass("tableCellShaded")
        ] })
      )
    ));
  }
};
function renderInnerContent4(props) {
  return y(
    _,
    null,
    props.text && y("a", Object.assign({ id: props.textId, className: "fc-list-day-text" }, props.navLinkAttrs), props.text),
    props.sideText && /* not keyboard tabbable */
    y("a", Object.assign({ "aria-hidden": true, className: "fc-list-day-side-text" }, props.sideNavLinkAttrs), props.sideText)
  );
}
var DEFAULT_TIME_FORMAT2 = createFormatter({
  hour: "numeric",
  minute: "2-digit",
  meridiem: "short"
});
var ListViewEventRow = class extends BaseComponent {
  render() {
    let { props, context } = this;
    let { options } = context;
    let { seg, timeHeaderId, eventHeaderId, dateHeaderId } = props;
    let timeFormat = options.eventTimeFormat || DEFAULT_TIME_FORMAT2;
    return y(EventContainer, Object.assign({}, props, { elTag: "tr", elClasses: [
      "fc-list-event",
      seg.eventRange.def.url && "fc-event-forced-url"
    ], defaultGenerator: () => renderEventInnerContent(seg, context), seg, timeText: "", disableDragging: true, disableResizing: true }), (InnerContent, eventContentArg) => y(
      _,
      null,
      buildTimeContent(seg, timeFormat, context, timeHeaderId, dateHeaderId),
      y(
        "td",
        { "aria-hidden": true, className: "fc-list-event-graphic" },
        y("span", { className: "fc-list-event-dot", style: {
          borderColor: eventContentArg.borderColor || eventContentArg.backgroundColor
        } })
      ),
      y(InnerContent, { elTag: "td", elClasses: ["fc-list-event-title"], elAttrs: { headers: `${eventHeaderId} ${dateHeaderId}` } })
    ));
  }
};
function renderEventInnerContent(seg, context) {
  let interactiveAttrs = getSegAnchorAttrs(seg, context);
  return y("a", Object.assign({}, interactiveAttrs), seg.eventRange.def.title);
}
function buildTimeContent(seg, timeFormat, context, timeHeaderId, dateHeaderId) {
  let { options } = context;
  if (options.displayEventTime !== false) {
    let eventDef = seg.eventRange.def;
    let eventInstance = seg.eventRange.instance;
    let doAllDay = false;
    let timeText;
    if (eventDef.allDay) {
      doAllDay = true;
    } else if (isMultiDayRange(seg.eventRange.range)) {
      if (seg.isStart) {
        timeText = buildSegTimeText(seg, timeFormat, context, null, null, eventInstance.range.start, seg.end);
      } else if (seg.isEnd) {
        timeText = buildSegTimeText(seg, timeFormat, context, null, null, seg.start, eventInstance.range.end);
      } else {
        doAllDay = true;
      }
    } else {
      timeText = buildSegTimeText(seg, timeFormat, context);
    }
    if (doAllDay) {
      let renderProps = {
        text: context.options.allDayText,
        view: context.viewApi
      };
      return y(ContentContainer, { elTag: "td", elClasses: ["fc-list-event-time"], elAttrs: {
        headers: `${timeHeaderId} ${dateHeaderId}`
      }, renderProps, generatorName: "allDayContent", customGenerator: options.allDayContent, defaultGenerator: renderAllDayInner2, classNameGenerator: options.allDayClassNames, didMount: options.allDayDidMount, willUnmount: options.allDayWillUnmount });
    }
    return y("td", { className: "fc-list-event-time" }, timeText);
  }
  return null;
}
function renderAllDayInner2(renderProps) {
  return renderProps.text;
}
var ListView = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.computeDateVars = memoize(computeDateVars);
    this.eventStoreToSegs = memoize(this._eventStoreToSegs);
    this.state = {
      timeHeaderId: getUniqueDomId(),
      eventHeaderId: getUniqueDomId(),
      dateHeaderIdRoot: getUniqueDomId()
    };
    this.setRootEl = (rootEl) => {
      if (rootEl) {
        this.context.registerInteractiveComponent(this, {
          el: rootEl
        });
      } else {
        this.context.unregisterInteractiveComponent(this);
      }
    };
  }
  render() {
    let { props, context } = this;
    let { dayDates, dayRanges } = this.computeDateVars(props.dateProfile);
    let eventSegs = this.eventStoreToSegs(props.eventStore, props.eventUiBases, dayRanges);
    return y(
      ViewContainer,
      { elRef: this.setRootEl, elClasses: [
        "fc-list",
        context.theme.getClass("table"),
        context.options.stickyHeaderDates !== false ? "fc-list-sticky" : ""
      ], viewSpec: context.viewSpec },
      y(Scroller, { liquid: !props.isHeightAuto, overflowX: props.isHeightAuto ? "visible" : "hidden", overflowY: props.isHeightAuto ? "visible" : "auto" }, eventSegs.length > 0 ? this.renderSegList(eventSegs, dayDates) : this.renderEmptyMessage())
    );
  }
  renderEmptyMessage() {
    let { options, viewApi } = this.context;
    let renderProps = {
      text: options.noEventsText,
      view: viewApi
    };
    return y(ContentContainer, { elTag: "div", elClasses: ["fc-list-empty"], renderProps, generatorName: "noEventsContent", customGenerator: options.noEventsContent, defaultGenerator: renderNoEventsInner, classNameGenerator: options.noEventsClassNames, didMount: options.noEventsDidMount, willUnmount: options.noEventsWillUnmount }, (InnerContent) => y(InnerContent, { elTag: "div", elClasses: ["fc-list-empty-cushion"] }));
  }
  renderSegList(allSegs, dayDates) {
    let { theme, options } = this.context;
    let { timeHeaderId, eventHeaderId, dateHeaderIdRoot } = this.state;
    let segsByDay = groupSegsByDay(allSegs);
    return y(NowTimer, { unit: "day" }, (nowDate, todayRange) => {
      let innerNodes = [];
      for (let dayIndex = 0; dayIndex < segsByDay.length; dayIndex += 1) {
        let daySegs = segsByDay[dayIndex];
        if (daySegs) {
          let dayStr = formatDayString(dayDates[dayIndex]);
          let dateHeaderId = dateHeaderIdRoot + "-" + dayStr;
          innerNodes.push(y(ListViewHeaderRow, { key: dayStr, cellId: dateHeaderId, dayDate: dayDates[dayIndex], todayRange }));
          daySegs = sortEventSegs(daySegs, options.eventOrder);
          for (let seg of daySegs) {
            innerNodes.push(y(ListViewEventRow, Object.assign({ key: dayStr + ":" + seg.eventRange.instance.instanceId, seg, isDragging: false, isResizing: false, isDateSelecting: false, isSelected: false, timeHeaderId, eventHeaderId, dateHeaderId }, getSegMeta(seg, todayRange, nowDate))));
          }
        }
      }
      return y(
        "table",
        { className: "fc-list-table " + theme.getClass("table") },
        y(
          "thead",
          null,
          y(
            "tr",
            null,
            y("th", { scope: "col", id: timeHeaderId }, options.timeHint),
            y("th", { scope: "col", "aria-hidden": true }),
            y("th", { scope: "col", id: eventHeaderId }, options.eventHint)
          )
        ),
        y("tbody", null, innerNodes)
      );
    });
  }
  _eventStoreToSegs(eventStore, eventUiBases, dayRanges) {
    return this.eventRangesToSegs(sliceEventStore(eventStore, eventUiBases, this.props.dateProfile.activeRange, this.context.options.nextDayThreshold).fg, dayRanges);
  }
  eventRangesToSegs(eventRanges, dayRanges) {
    let segs = [];
    for (let eventRange of eventRanges) {
      segs.push(...this.eventRangeToSegs(eventRange, dayRanges));
    }
    return segs;
  }
  eventRangeToSegs(eventRange, dayRanges) {
    let { dateEnv } = this.context;
    let { nextDayThreshold } = this.context.options;
    let range2 = eventRange.range;
    let allDay = eventRange.def.allDay;
    let dayIndex;
    let segRange;
    let seg;
    let segs = [];
    for (dayIndex = 0; dayIndex < dayRanges.length; dayIndex += 1) {
      segRange = intersectRanges(range2, dayRanges[dayIndex]);
      if (segRange) {
        seg = {
          component: this,
          eventRange,
          start: segRange.start,
          end: segRange.end,
          isStart: eventRange.isStart && segRange.start.valueOf() === range2.start.valueOf(),
          isEnd: eventRange.isEnd && segRange.end.valueOf() === range2.end.valueOf(),
          dayIndex
        };
        segs.push(seg);
        if (!seg.isEnd && !allDay && dayIndex + 1 < dayRanges.length && range2.end < dateEnv.add(dayRanges[dayIndex + 1].start, nextDayThreshold)) {
          seg.end = range2.end;
          seg.isEnd = true;
          break;
        }
      }
    }
    return segs;
  }
};
function renderNoEventsInner(renderProps) {
  return renderProps.text;
}
function computeDateVars(dateProfile) {
  let dayStart = startOfDay(dateProfile.renderRange.start);
  let viewEnd = dateProfile.renderRange.end;
  let dayDates = [];
  let dayRanges = [];
  while (dayStart < viewEnd) {
    dayDates.push(dayStart);
    dayRanges.push({
      start: dayStart,
      end: addDays(dayStart, 1)
    });
    dayStart = addDays(dayStart, 1);
  }
  return { dayDates, dayRanges };
}
function groupSegsByDay(segs) {
  let segsByDay = [];
  let i3;
  let seg;
  for (i3 = 0; i3 < segs.length; i3 += 1) {
    seg = segs[i3];
    (segsByDay[seg.dayIndex] || (segsByDay[seg.dayIndex] = [])).push(seg);
  }
  return segsByDay;
}
var css_248z4 = ':root{--fc-list-event-dot-width:10px;--fc-list-event-hover-bg-color:#f5f5f5}.fc-theme-standard .fc-list{border:1px solid var(--fc-border-color)}.fc .fc-list-empty{align-items:center;background-color:var(--fc-neutral-bg-color);display:flex;height:100%;justify-content:center}.fc .fc-list-empty-cushion{margin:5em 0}.fc .fc-list-table{border-style:hidden;width:100%}.fc .fc-list-table tr>*{border-left:0;border-right:0}.fc .fc-list-sticky .fc-list-day>*{background:var(--fc-page-bg-color);position:sticky;top:0}.fc .fc-list-table thead{left:-10000px;position:absolute}.fc .fc-list-table tbody>tr:first-child th{border-top:0}.fc .fc-list-table th{padding:0}.fc .fc-list-day-cushion,.fc .fc-list-table td{padding:8px 14px}.fc .fc-list-day-cushion:after{clear:both;content:"";display:table}.fc-theme-standard .fc-list-day-cushion{background-color:var(--fc-neutral-bg-color)}.fc-direction-ltr .fc-list-day-text,.fc-direction-rtl .fc-list-day-side-text{float:left}.fc-direction-ltr .fc-list-day-side-text,.fc-direction-rtl .fc-list-day-text{float:right}.fc-direction-ltr .fc-list-table .fc-list-event-graphic{padding-right:0}.fc-direction-rtl .fc-list-table .fc-list-event-graphic{padding-left:0}.fc .fc-list-event.fc-event-forced-url{cursor:pointer}.fc .fc-list-event:hover td{background-color:var(--fc-list-event-hover-bg-color)}.fc .fc-list-event-graphic,.fc .fc-list-event-time{white-space:nowrap;width:1px}.fc .fc-list-event-dot{border:calc(var(--fc-list-event-dot-width)/2) solid var(--fc-event-border-color);border-radius:calc(var(--fc-list-event-dot-width)/2);box-sizing:content-box;display:inline-block;height:0;width:0}.fc .fc-list-event-title a{color:inherit;text-decoration:none}.fc .fc-list-event.fc-event-forced-url:hover a{text-decoration:underline}';
injectStyles(css_248z4);

// node_modules/@fullcalendar/list/index.js
var OPTION_REFINERS2 = {
  listDayFormat: createFalsableFormatter,
  listDaySideFormat: createFalsableFormatter,
  noEventsClassNames: identity,
  noEventsContent: identity,
  noEventsDidMount: identity,
  noEventsWillUnmount: identity
  // noEventsText is defined in base options
};
function createFalsableFormatter(input) {
  return input === false ? null : createFormatter(input);
}
var index4 = createPlugin({
  name: "@fullcalendar/list",
  optionRefiners: OPTION_REFINERS2,
  views: {
    list: {
      component: ListView,
      buttonTextKey: "list",
      listDayFormat: { month: "long", day: "numeric", year: "numeric" }
      // like "January 1, 2016"
    },
    listDay: {
      type: "list",
      duration: { days: 1 },
      listDayFormat: { weekday: "long" }
      // day-of-week is all we need. full date is probably in headerToolbar
    },
    listWeek: {
      type: "list",
      duration: { weeks: 1 },
      listDayFormat: { weekday: "long" },
      listDaySideFormat: { month: "long", day: "numeric", year: "numeric" }
    },
    listMonth: {
      type: "list",
      duration: { month: 1 },
      listDaySideFormat: { weekday: "long" }
      // day-of-week is nice-to-have
    },
    listYear: {
      type: "list",
      duration: { year: 1 },
      listDaySideFormat: { weekday: "long" }
      // day-of-week is nice-to-have
    }
  }
});

// node_modules/@fullcalendar/interaction/index.js
config.touchMouseIgnoreWait = 500;
var ignoreMouseDepth = 0;
var listenerCnt = 0;
var isWindowTouchMoveCancelled = false;
var PointerDragging = class {
  constructor(containerEl) {
    this.subjectEl = null;
    this.selector = "";
    this.handleSelector = "";
    this.shouldIgnoreMove = false;
    this.shouldWatchScroll = true;
    this.isDragging = false;
    this.isTouchDragging = false;
    this.wasTouchScroll = false;
    this.handleMouseDown = (ev) => {
      if (!this.shouldIgnoreMouse() && isPrimaryMouseButton(ev) && this.tryStart(ev)) {
        let pev = this.createEventFromMouse(ev, true);
        this.emitter.trigger("pointerdown", pev);
        this.initScrollWatch(pev);
        if (!this.shouldIgnoreMove) {
          document.addEventListener("mousemove", this.handleMouseMove);
        }
        document.addEventListener("mouseup", this.handleMouseUp);
      }
    };
    this.handleMouseMove = (ev) => {
      let pev = this.createEventFromMouse(ev);
      this.recordCoords(pev);
      this.emitter.trigger("pointermove", pev);
    };
    this.handleMouseUp = (ev) => {
      document.removeEventListener("mousemove", this.handleMouseMove);
      document.removeEventListener("mouseup", this.handleMouseUp);
      this.emitter.trigger("pointerup", this.createEventFromMouse(ev));
      this.cleanup();
    };
    this.handleTouchStart = (ev) => {
      if (this.tryStart(ev)) {
        this.isTouchDragging = true;
        let pev = this.createEventFromTouch(ev, true);
        this.emitter.trigger("pointerdown", pev);
        this.initScrollWatch(pev);
        let targetEl = ev.target;
        if (!this.shouldIgnoreMove) {
          targetEl.addEventListener("touchmove", this.handleTouchMove);
        }
        targetEl.addEventListener("touchend", this.handleTouchEnd);
        targetEl.addEventListener("touchcancel", this.handleTouchEnd);
        window.addEventListener("scroll", this.handleTouchScroll, true);
      }
    };
    this.handleTouchMove = (ev) => {
      let pev = this.createEventFromTouch(ev);
      this.recordCoords(pev);
      this.emitter.trigger("pointermove", pev);
    };
    this.handleTouchEnd = (ev) => {
      if (this.isDragging) {
        let targetEl = ev.target;
        targetEl.removeEventListener("touchmove", this.handleTouchMove);
        targetEl.removeEventListener("touchend", this.handleTouchEnd);
        targetEl.removeEventListener("touchcancel", this.handleTouchEnd);
        window.removeEventListener("scroll", this.handleTouchScroll, true);
        this.emitter.trigger("pointerup", this.createEventFromTouch(ev));
        this.cleanup();
        this.isTouchDragging = false;
        startIgnoringMouse();
      }
    };
    this.handleTouchScroll = () => {
      this.wasTouchScroll = true;
    };
    this.handleScroll = (ev) => {
      if (!this.shouldIgnoreMove) {
        let pageX = window.scrollX - this.prevScrollX + this.prevPageX;
        let pageY = window.scrollY - this.prevScrollY + this.prevPageY;
        this.emitter.trigger("pointermove", {
          origEvent: ev,
          isTouch: this.isTouchDragging,
          subjectEl: this.subjectEl,
          pageX,
          pageY,
          deltaX: pageX - this.origPageX,
          deltaY: pageY - this.origPageY
        });
      }
    };
    this.containerEl = containerEl;
    this.emitter = new Emitter();
    containerEl.addEventListener("mousedown", this.handleMouseDown);
    containerEl.addEventListener("touchstart", this.handleTouchStart, { passive: true });
    listenerCreated();
  }
  destroy() {
    this.containerEl.removeEventListener("mousedown", this.handleMouseDown);
    this.containerEl.removeEventListener("touchstart", this.handleTouchStart, { passive: true });
    listenerDestroyed();
  }
  tryStart(ev) {
    let subjectEl = this.querySubjectEl(ev);
    let downEl = ev.target;
    if (subjectEl && (!this.handleSelector || elementClosest(downEl, this.handleSelector))) {
      this.subjectEl = subjectEl;
      this.isDragging = true;
      this.wasTouchScroll = false;
      return true;
    }
    return false;
  }
  cleanup() {
    isWindowTouchMoveCancelled = false;
    this.isDragging = false;
    this.subjectEl = null;
    this.destroyScrollWatch();
  }
  querySubjectEl(ev) {
    if (this.selector) {
      return elementClosest(ev.target, this.selector);
    }
    return this.containerEl;
  }
  shouldIgnoreMouse() {
    return ignoreMouseDepth || this.isTouchDragging;
  }
  // can be called by user of this class, to cancel touch-based scrolling for the current drag
  cancelTouchScroll() {
    if (this.isDragging) {
      isWindowTouchMoveCancelled = true;
    }
  }
  // Scrolling that simulates pointermoves
  // ----------------------------------------------------------------------------------------------------
  initScrollWatch(ev) {
    if (this.shouldWatchScroll) {
      this.recordCoords(ev);
      window.addEventListener("scroll", this.handleScroll, true);
    }
  }
  recordCoords(ev) {
    if (this.shouldWatchScroll) {
      this.prevPageX = ev.pageX;
      this.prevPageY = ev.pageY;
      this.prevScrollX = window.scrollX;
      this.prevScrollY = window.scrollY;
    }
  }
  destroyScrollWatch() {
    if (this.shouldWatchScroll) {
      window.removeEventListener("scroll", this.handleScroll, true);
    }
  }
  // Event Normalization
  // ----------------------------------------------------------------------------------------------------
  createEventFromMouse(ev, isFirst) {
    let deltaX = 0;
    let deltaY = 0;
    if (isFirst) {
      this.origPageX = ev.pageX;
      this.origPageY = ev.pageY;
    } else {
      deltaX = ev.pageX - this.origPageX;
      deltaY = ev.pageY - this.origPageY;
    }
    return {
      origEvent: ev,
      isTouch: false,
      subjectEl: this.subjectEl,
      pageX: ev.pageX,
      pageY: ev.pageY,
      deltaX,
      deltaY
    };
  }
  createEventFromTouch(ev, isFirst) {
    let touches = ev.touches;
    let pageX;
    let pageY;
    let deltaX = 0;
    let deltaY = 0;
    if (touches && touches.length) {
      pageX = touches[0].pageX;
      pageY = touches[0].pageY;
    } else {
      pageX = ev.pageX;
      pageY = ev.pageY;
    }
    if (isFirst) {
      this.origPageX = pageX;
      this.origPageY = pageY;
    } else {
      deltaX = pageX - this.origPageX;
      deltaY = pageY - this.origPageY;
    }
    return {
      origEvent: ev,
      isTouch: true,
      subjectEl: this.subjectEl,
      pageX,
      pageY,
      deltaX,
      deltaY
    };
  }
};
function isPrimaryMouseButton(ev) {
  return ev.button === 0 && !ev.ctrlKey;
}
function startIgnoringMouse() {
  ignoreMouseDepth += 1;
  setTimeout(() => {
    ignoreMouseDepth -= 1;
  }, config.touchMouseIgnoreWait);
}
function listenerCreated() {
  listenerCnt += 1;
  if (listenerCnt === 1) {
    window.addEventListener("touchmove", onWindowTouchMove, { passive: false });
  }
}
function listenerDestroyed() {
  listenerCnt -= 1;
  if (!listenerCnt) {
    window.removeEventListener("touchmove", onWindowTouchMove, { passive: false });
  }
}
function onWindowTouchMove(ev) {
  if (isWindowTouchMoveCancelled) {
    ev.preventDefault();
  }
}
var ElementMirror = class {
  constructor() {
    this.isVisible = false;
    this.sourceEl = null;
    this.mirrorEl = null;
    this.sourceElRect = null;
    this.parentNode = document.body;
    this.zIndex = 9999;
    this.revertDuration = 0;
  }
  start(sourceEl, pageX, pageY) {
    this.sourceEl = sourceEl;
    this.sourceElRect = this.sourceEl.getBoundingClientRect();
    this.origScreenX = pageX - window.scrollX;
    this.origScreenY = pageY - window.scrollY;
    this.deltaX = 0;
    this.deltaY = 0;
    this.updateElPosition();
  }
  handleMove(pageX, pageY) {
    this.deltaX = pageX - window.scrollX - this.origScreenX;
    this.deltaY = pageY - window.scrollY - this.origScreenY;
    this.updateElPosition();
  }
  // can be called before start
  setIsVisible(bool) {
    if (bool) {
      if (!this.isVisible) {
        if (this.mirrorEl) {
          this.mirrorEl.style.display = "";
        }
        this.isVisible = bool;
        this.updateElPosition();
      }
    } else if (this.isVisible) {
      if (this.mirrorEl) {
        this.mirrorEl.style.display = "none";
      }
      this.isVisible = bool;
    }
  }
  // always async
  stop(needsRevertAnimation, callback) {
    let done = () => {
      this.cleanup();
      callback();
    };
    if (needsRevertAnimation && this.mirrorEl && this.isVisible && this.revertDuration && // if 0, transition won't work
    (this.deltaX || this.deltaY)) {
      this.doRevertAnimation(done, this.revertDuration);
    } else {
      setTimeout(done, 0);
    }
  }
  doRevertAnimation(callback, revertDuration) {
    let mirrorEl = this.mirrorEl;
    let finalSourceElRect = this.sourceEl.getBoundingClientRect();
    mirrorEl.style.transition = "top " + revertDuration + "ms,left " + revertDuration + "ms";
    applyStyle(mirrorEl, {
      left: finalSourceElRect.left,
      top: finalSourceElRect.top
    });
    whenTransitionDone(mirrorEl, () => {
      mirrorEl.style.transition = "";
      callback();
    });
  }
  cleanup() {
    if (this.mirrorEl) {
      removeElement(this.mirrorEl);
      this.mirrorEl = null;
    }
    this.sourceEl = null;
  }
  updateElPosition() {
    if (this.sourceEl && this.isVisible) {
      applyStyle(this.getMirrorEl(), {
        left: this.sourceElRect.left + this.deltaX,
        top: this.sourceElRect.top + this.deltaY
      });
    }
  }
  getMirrorEl() {
    let sourceElRect = this.sourceElRect;
    let mirrorEl = this.mirrorEl;
    if (!mirrorEl) {
      mirrorEl = this.mirrorEl = this.sourceEl.cloneNode(true);
      mirrorEl.style.userSelect = "none";
      mirrorEl.style.webkitUserSelect = "none";
      mirrorEl.style.pointerEvents = "none";
      mirrorEl.classList.add("fc-event-dragging");
      applyStyle(mirrorEl, {
        position: "fixed",
        zIndex: this.zIndex,
        visibility: "",
        boxSizing: "border-box",
        width: sourceElRect.right - sourceElRect.left,
        height: sourceElRect.bottom - sourceElRect.top,
        right: "auto",
        bottom: "auto",
        margin: 0
      });
      this.parentNode.appendChild(mirrorEl);
    }
    return mirrorEl;
  }
};
var ScrollGeomCache = class extends ScrollController {
  constructor(scrollController, doesListening) {
    super();
    this.handleScroll = () => {
      this.scrollTop = this.scrollController.getScrollTop();
      this.scrollLeft = this.scrollController.getScrollLeft();
      this.handleScrollChange();
    };
    this.scrollController = scrollController;
    this.doesListening = doesListening;
    this.scrollTop = this.origScrollTop = scrollController.getScrollTop();
    this.scrollLeft = this.origScrollLeft = scrollController.getScrollLeft();
    this.scrollWidth = scrollController.getScrollWidth();
    this.scrollHeight = scrollController.getScrollHeight();
    this.clientWidth = scrollController.getClientWidth();
    this.clientHeight = scrollController.getClientHeight();
    this.clientRect = this.computeClientRect();
    if (this.doesListening) {
      this.getEventTarget().addEventListener("scroll", this.handleScroll);
    }
  }
  destroy() {
    if (this.doesListening) {
      this.getEventTarget().removeEventListener("scroll", this.handleScroll);
    }
  }
  getScrollTop() {
    return this.scrollTop;
  }
  getScrollLeft() {
    return this.scrollLeft;
  }
  setScrollTop(top) {
    this.scrollController.setScrollTop(top);
    if (!this.doesListening) {
      this.scrollTop = Math.max(Math.min(top, this.getMaxScrollTop()), 0);
      this.handleScrollChange();
    }
  }
  setScrollLeft(top) {
    this.scrollController.setScrollLeft(top);
    if (!this.doesListening) {
      this.scrollLeft = Math.max(Math.min(top, this.getMaxScrollLeft()), 0);
      this.handleScrollChange();
    }
  }
  getClientWidth() {
    return this.clientWidth;
  }
  getClientHeight() {
    return this.clientHeight;
  }
  getScrollWidth() {
    return this.scrollWidth;
  }
  getScrollHeight() {
    return this.scrollHeight;
  }
  handleScrollChange() {
  }
};
var ElementScrollGeomCache = class extends ScrollGeomCache {
  constructor(el, doesListening) {
    super(new ElementScrollController(el), doesListening);
  }
  getEventTarget() {
    return this.scrollController.el;
  }
  computeClientRect() {
    return computeInnerRect(this.scrollController.el);
  }
};
var WindowScrollGeomCache = class extends ScrollGeomCache {
  constructor(doesListening) {
    super(new WindowScrollController(), doesListening);
  }
  getEventTarget() {
    return window;
  }
  computeClientRect() {
    return {
      left: this.scrollLeft,
      right: this.scrollLeft + this.clientWidth,
      top: this.scrollTop,
      bottom: this.scrollTop + this.clientHeight
    };
  }
  // the window is the only scroll object that changes it's rectangle relative
  // to the document's topleft as it scrolls
  handleScrollChange() {
    this.clientRect = this.computeClientRect();
  }
};
var getTime = typeof performance === "function" ? performance.now : Date.now;
var AutoScroller = class {
  constructor() {
    this.isEnabled = true;
    this.scrollQuery = [window, ".fc-scroller"];
    this.edgeThreshold = 50;
    this.maxVelocity = 300;
    this.pointerScreenX = null;
    this.pointerScreenY = null;
    this.isAnimating = false;
    this.scrollCaches = null;
    this.everMovedUp = false;
    this.everMovedDown = false;
    this.everMovedLeft = false;
    this.everMovedRight = false;
    this.animate = () => {
      if (this.isAnimating) {
        let edge = this.computeBestEdge(this.pointerScreenX + window.scrollX, this.pointerScreenY + window.scrollY);
        if (edge) {
          let now = getTime();
          this.handleSide(edge, (now - this.msSinceRequest) / 1e3);
          this.requestAnimation(now);
        } else {
          this.isAnimating = false;
        }
      }
    };
  }
  start(pageX, pageY, scrollStartEl) {
    if (this.isEnabled) {
      this.scrollCaches = this.buildCaches(scrollStartEl);
      this.pointerScreenX = null;
      this.pointerScreenY = null;
      this.everMovedUp = false;
      this.everMovedDown = false;
      this.everMovedLeft = false;
      this.everMovedRight = false;
      this.handleMove(pageX, pageY);
    }
  }
  handleMove(pageX, pageY) {
    if (this.isEnabled) {
      let pointerScreenX = pageX - window.scrollX;
      let pointerScreenY = pageY - window.scrollY;
      let yDelta = this.pointerScreenY === null ? 0 : pointerScreenY - this.pointerScreenY;
      let xDelta = this.pointerScreenX === null ? 0 : pointerScreenX - this.pointerScreenX;
      if (yDelta < 0) {
        this.everMovedUp = true;
      } else if (yDelta > 0) {
        this.everMovedDown = true;
      }
      if (xDelta < 0) {
        this.everMovedLeft = true;
      } else if (xDelta > 0) {
        this.everMovedRight = true;
      }
      this.pointerScreenX = pointerScreenX;
      this.pointerScreenY = pointerScreenY;
      if (!this.isAnimating) {
        this.isAnimating = true;
        this.requestAnimation(getTime());
      }
    }
  }
  stop() {
    if (this.isEnabled) {
      this.isAnimating = false;
      for (let scrollCache of this.scrollCaches) {
        scrollCache.destroy();
      }
      this.scrollCaches = null;
    }
  }
  requestAnimation(now) {
    this.msSinceRequest = now;
    requestAnimationFrame(this.animate);
  }
  handleSide(edge, seconds) {
    let { scrollCache } = edge;
    let { edgeThreshold } = this;
    let invDistance = edgeThreshold - edge.distance;
    let velocity = (
      // the closer to the edge, the faster we scroll
      invDistance * invDistance / (edgeThreshold * edgeThreshold) * // quadratic
      this.maxVelocity * seconds
    );
    let sign = 1;
    switch (edge.name) {
      case "left":
        sign = -1;
      case "right":
        scrollCache.setScrollLeft(scrollCache.getScrollLeft() + velocity * sign);
        break;
      case "top":
        sign = -1;
      case "bottom":
        scrollCache.setScrollTop(scrollCache.getScrollTop() + velocity * sign);
        break;
    }
  }
  // left/top are relative to document topleft
  computeBestEdge(left, top) {
    let { edgeThreshold } = this;
    let bestSide = null;
    let scrollCaches = this.scrollCaches || [];
    for (let scrollCache of scrollCaches) {
      let rect = scrollCache.clientRect;
      let leftDist = left - rect.left;
      let rightDist = rect.right - left;
      let topDist = top - rect.top;
      let bottomDist = rect.bottom - top;
      if (leftDist >= 0 && rightDist >= 0 && topDist >= 0 && bottomDist >= 0) {
        if (topDist <= edgeThreshold && this.everMovedUp && scrollCache.canScrollUp() && (!bestSide || bestSide.distance > topDist)) {
          bestSide = { scrollCache, name: "top", distance: topDist };
        }
        if (bottomDist <= edgeThreshold && this.everMovedDown && scrollCache.canScrollDown() && (!bestSide || bestSide.distance > bottomDist)) {
          bestSide = { scrollCache, name: "bottom", distance: bottomDist };
        }
        if (leftDist <= edgeThreshold && this.everMovedLeft && scrollCache.canScrollLeft() && (!bestSide || bestSide.distance > leftDist)) {
          bestSide = { scrollCache, name: "left", distance: leftDist };
        }
        if (rightDist <= edgeThreshold && this.everMovedRight && scrollCache.canScrollRight() && (!bestSide || bestSide.distance > rightDist)) {
          bestSide = { scrollCache, name: "right", distance: rightDist };
        }
      }
    }
    return bestSide;
  }
  buildCaches(scrollStartEl) {
    return this.queryScrollEls(scrollStartEl).map((el) => {
      if (el === window) {
        return new WindowScrollGeomCache(false);
      }
      return new ElementScrollGeomCache(el, false);
    });
  }
  queryScrollEls(scrollStartEl) {
    let els = [];
    for (let query of this.scrollQuery) {
      if (typeof query === "object") {
        els.push(query);
      } else {
        els.push(...Array.prototype.slice.call(scrollStartEl.getRootNode().querySelectorAll(query)));
      }
    }
    return els;
  }
};
var FeaturefulElementDragging = class extends ElementDragging {
  constructor(containerEl, selector) {
    super(containerEl);
    this.containerEl = containerEl;
    this.delay = null;
    this.minDistance = 0;
    this.touchScrollAllowed = true;
    this.mirrorNeedsRevert = false;
    this.isInteracting = false;
    this.isDragging = false;
    this.isDelayEnded = false;
    this.isDistanceSurpassed = false;
    this.delayTimeoutId = null;
    this.onPointerDown = (ev) => {
      if (!this.isDragging) {
        this.isInteracting = true;
        this.isDelayEnded = false;
        this.isDistanceSurpassed = false;
        preventSelection(document.body);
        preventContextMenu(document.body);
        if (!ev.isTouch) {
          ev.origEvent.preventDefault();
        }
        this.emitter.trigger("pointerdown", ev);
        if (this.isInteracting && // not destroyed via pointerdown handler
        !this.pointer.shouldIgnoreMove) {
          this.mirror.setIsVisible(false);
          this.mirror.start(ev.subjectEl, ev.pageX, ev.pageY);
          this.startDelay(ev);
          if (!this.minDistance) {
            this.handleDistanceSurpassed(ev);
          }
        }
      }
    };
    this.onPointerMove = (ev) => {
      if (this.isInteracting) {
        this.emitter.trigger("pointermove", ev);
        if (!this.isDistanceSurpassed) {
          let minDistance = this.minDistance;
          let distanceSq;
          let { deltaX, deltaY } = ev;
          distanceSq = deltaX * deltaX + deltaY * deltaY;
          if (distanceSq >= minDistance * minDistance) {
            this.handleDistanceSurpassed(ev);
          }
        }
        if (this.isDragging) {
          if (ev.origEvent.type !== "scroll") {
            this.mirror.handleMove(ev.pageX, ev.pageY);
            this.autoScroller.handleMove(ev.pageX, ev.pageY);
          }
          this.emitter.trigger("dragmove", ev);
        }
      }
    };
    this.onPointerUp = (ev) => {
      if (this.isInteracting) {
        this.isInteracting = false;
        allowSelection(document.body);
        allowContextMenu(document.body);
        this.emitter.trigger("pointerup", ev);
        if (this.isDragging) {
          this.autoScroller.stop();
          this.tryStopDrag(ev);
        }
        if (this.delayTimeoutId) {
          clearTimeout(this.delayTimeoutId);
          this.delayTimeoutId = null;
        }
      }
    };
    let pointer = this.pointer = new PointerDragging(containerEl);
    pointer.emitter.on("pointerdown", this.onPointerDown);
    pointer.emitter.on("pointermove", this.onPointerMove);
    pointer.emitter.on("pointerup", this.onPointerUp);
    if (selector) {
      pointer.selector = selector;
    }
    this.mirror = new ElementMirror();
    this.autoScroller = new AutoScroller();
  }
  destroy() {
    this.pointer.destroy();
    this.onPointerUp({});
  }
  startDelay(ev) {
    if (typeof this.delay === "number") {
      this.delayTimeoutId = setTimeout(() => {
        this.delayTimeoutId = null;
        this.handleDelayEnd(ev);
      }, this.delay);
    } else {
      this.handleDelayEnd(ev);
    }
  }
  handleDelayEnd(ev) {
    this.isDelayEnded = true;
    this.tryStartDrag(ev);
  }
  handleDistanceSurpassed(ev) {
    this.isDistanceSurpassed = true;
    this.tryStartDrag(ev);
  }
  tryStartDrag(ev) {
    if (this.isDelayEnded && this.isDistanceSurpassed) {
      if (!this.pointer.wasTouchScroll || this.touchScrollAllowed) {
        this.isDragging = true;
        this.mirrorNeedsRevert = false;
        this.autoScroller.start(ev.pageX, ev.pageY, this.containerEl);
        this.emitter.trigger("dragstart", ev);
        if (this.touchScrollAllowed === false) {
          this.pointer.cancelTouchScroll();
        }
      }
    }
  }
  tryStopDrag(ev) {
    this.mirror.stop(this.mirrorNeedsRevert, this.stopDrag.bind(this, ev));
  }
  stopDrag(ev) {
    this.isDragging = false;
    this.emitter.trigger("dragend", ev);
  }
  // fill in the implementations...
  setIgnoreMove(bool) {
    this.pointer.shouldIgnoreMove = bool;
  }
  setMirrorIsVisible(bool) {
    this.mirror.setIsVisible(bool);
  }
  setMirrorNeedsRevert(bool) {
    this.mirrorNeedsRevert = bool;
  }
  setAutoScrollEnabled(bool) {
    this.autoScroller.isEnabled = bool;
  }
};
var OffsetTracker = class {
  constructor(el) {
    this.el = el;
    this.origRect = computeRect(el);
    this.scrollCaches = getClippingParents(el).map((scrollEl) => new ElementScrollGeomCache(scrollEl, true));
  }
  destroy() {
    for (let scrollCache of this.scrollCaches) {
      scrollCache.destroy();
    }
  }
  computeLeft() {
    let left = this.origRect.left;
    for (let scrollCache of this.scrollCaches) {
      left += scrollCache.origScrollLeft - scrollCache.getScrollLeft();
    }
    return left;
  }
  computeTop() {
    let top = this.origRect.top;
    for (let scrollCache of this.scrollCaches) {
      top += scrollCache.origScrollTop - scrollCache.getScrollTop();
    }
    return top;
  }
  isWithinClipping(pageX, pageY) {
    let point = { left: pageX, top: pageY };
    for (let scrollCache of this.scrollCaches) {
      if (!isIgnoredClipping(scrollCache.getEventTarget()) && !pointInsideRect(point, scrollCache.clientRect)) {
        return false;
      }
    }
    return true;
  }
};
function isIgnoredClipping(node) {
  let tagName = node.tagName;
  return tagName === "HTML" || tagName === "BODY";
}
var HitDragging = class {
  constructor(dragging, droppableStore) {
    this.useSubjectCenter = false;
    this.requireInitial = true;
    this.disablePointCheck = false;
    this.initialHit = null;
    this.movingHit = null;
    this.finalHit = null;
    this.handlePointerDown = (ev) => {
      let { dragging: dragging2 } = this;
      this.initialHit = null;
      this.movingHit = null;
      this.finalHit = null;
      this.prepareHits();
      this.processFirstCoord(ev);
      if (this.initialHit || !this.requireInitial) {
        dragging2.setIgnoreMove(false);
        this.emitter.trigger("pointerdown", ev);
      } else {
        dragging2.setIgnoreMove(true);
      }
    };
    this.handleDragStart = (ev) => {
      this.emitter.trigger("dragstart", ev);
      this.handleMove(ev, true);
    };
    this.handleDragMove = (ev) => {
      this.emitter.trigger("dragmove", ev);
      this.handleMove(ev);
    };
    this.handlePointerUp = (ev) => {
      this.releaseHits();
      this.emitter.trigger("pointerup", ev);
    };
    this.handleDragEnd = (ev) => {
      if (this.movingHit) {
        this.emitter.trigger("hitupdate", null, true, ev);
      }
      this.finalHit = this.movingHit;
      this.movingHit = null;
      this.emitter.trigger("dragend", ev);
    };
    this.droppableStore = droppableStore;
    dragging.emitter.on("pointerdown", this.handlePointerDown);
    dragging.emitter.on("dragstart", this.handleDragStart);
    dragging.emitter.on("dragmove", this.handleDragMove);
    dragging.emitter.on("pointerup", this.handlePointerUp);
    dragging.emitter.on("dragend", this.handleDragEnd);
    this.dragging = dragging;
    this.emitter = new Emitter();
  }
  // sets initialHit
  // sets coordAdjust
  processFirstCoord(ev) {
    let origPoint = { left: ev.pageX, top: ev.pageY };
    let adjustedPoint = origPoint;
    let subjectEl = ev.subjectEl;
    let subjectRect;
    if (subjectEl instanceof HTMLElement) {
      subjectRect = computeRect(subjectEl);
      adjustedPoint = constrainPoint(adjustedPoint, subjectRect);
    }
    let initialHit = this.initialHit = this.queryHitForOffset(adjustedPoint.left, adjustedPoint.top);
    if (initialHit) {
      if (this.useSubjectCenter && subjectRect) {
        let slicedSubjectRect = intersectRects(subjectRect, initialHit.rect);
        if (slicedSubjectRect) {
          adjustedPoint = getRectCenter(slicedSubjectRect);
        }
      }
      this.coordAdjust = diffPoints(adjustedPoint, origPoint);
    } else {
      this.coordAdjust = { left: 0, top: 0 };
    }
  }
  handleMove(ev, forceHandle) {
    let hit = this.queryHitForOffset(ev.pageX + this.coordAdjust.left, ev.pageY + this.coordAdjust.top);
    if (forceHandle || !isHitsEqual(this.movingHit, hit)) {
      this.movingHit = hit;
      this.emitter.trigger("hitupdate", hit, false, ev);
    }
  }
  prepareHits() {
    this.offsetTrackers = mapHash(this.droppableStore, (interactionSettings) => {
      interactionSettings.component.prepareHits();
      return new OffsetTracker(interactionSettings.el);
    });
  }
  releaseHits() {
    let { offsetTrackers } = this;
    for (let id in offsetTrackers) {
      offsetTrackers[id].destroy();
    }
    this.offsetTrackers = {};
  }
  queryHitForOffset(offsetLeft, offsetTop) {
    let { droppableStore, offsetTrackers } = this;
    let bestHit = null;
    for (let id in droppableStore) {
      let component = droppableStore[id].component;
      let offsetTracker = offsetTrackers[id];
      if (offsetTracker && // wasn't destroyed mid-drag
      offsetTracker.isWithinClipping(offsetLeft, offsetTop)) {
        let originLeft = offsetTracker.computeLeft();
        let originTop = offsetTracker.computeTop();
        let positionLeft = offsetLeft - originLeft;
        let positionTop = offsetTop - originTop;
        let { origRect } = offsetTracker;
        let width = origRect.right - origRect.left;
        let height = origRect.bottom - origRect.top;
        if (
          // must be within the element's bounds
          positionLeft >= 0 && positionLeft < width && positionTop >= 0 && positionTop < height
        ) {
          let hit = component.queryHit(positionLeft, positionTop, width, height);
          if (hit && // make sure the hit is within activeRange, meaning it's not a dead cell
          rangeContainsRange(hit.dateProfile.activeRange, hit.dateSpan.range) && // Ensure the component we are querying for the hit is accessibly my the pointer
          // Prevents obscured calendars (ex: under a modal dialog) from accepting hit
          // https://github.com/fullcalendar/fullcalendar/issues/5026
          (this.disablePointCheck || offsetTracker.el.contains(offsetTracker.el.getRootNode().elementFromPoint(
            // add-back origins to get coordinate relative to top-left of window viewport
            positionLeft + originLeft - window.scrollX,
            positionTop + originTop - window.scrollY
          ))) && (!bestHit || hit.layer > bestHit.layer)) {
            hit.componentId = id;
            hit.context = component.context;
            hit.rect.left += originLeft;
            hit.rect.right += originLeft;
            hit.rect.top += originTop;
            hit.rect.bottom += originTop;
            bestHit = hit;
          }
        }
      }
    }
    return bestHit;
  }
};
function isHitsEqual(hit0, hit1) {
  if (!hit0 && !hit1) {
    return true;
  }
  if (Boolean(hit0) !== Boolean(hit1)) {
    return false;
  }
  return isDateSpansEqual(hit0.dateSpan, hit1.dateSpan);
}
function buildDatePointApiWithContext(dateSpan, context) {
  let props = {};
  for (let transform of context.pluginHooks.datePointTransforms) {
    Object.assign(props, transform(dateSpan, context));
  }
  Object.assign(props, buildDatePointApi(dateSpan, context.dateEnv));
  return props;
}
function buildDatePointApi(span, dateEnv) {
  return {
    date: dateEnv.toDate(span.range.start),
    dateStr: dateEnv.formatIso(span.range.start, { omitTime: span.allDay }),
    allDay: span.allDay
  };
}
var DateClicking = class extends Interaction {
  constructor(settings) {
    super(settings);
    this.handlePointerDown = (pev) => {
      let { dragging } = this;
      let downEl = pev.origEvent.target;
      dragging.setIgnoreMove(!this.component.isValidDateDownEl(downEl));
    };
    this.handleDragEnd = (ev) => {
      let { component } = this;
      let { pointer } = this.dragging;
      if (!pointer.wasTouchScroll) {
        let { initialHit, finalHit } = this.hitDragging;
        if (initialHit && finalHit && isHitsEqual(initialHit, finalHit)) {
          let { context } = component;
          let arg = Object.assign(Object.assign({}, buildDatePointApiWithContext(initialHit.dateSpan, context)), { dayEl: initialHit.dayEl, jsEvent: ev.origEvent, view: context.viewApi || context.calendarApi.view });
          context.emitter.trigger("dateClick", arg);
        }
      }
    };
    this.dragging = new FeaturefulElementDragging(settings.el);
    this.dragging.autoScroller.isEnabled = false;
    let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsToStore(settings));
    hitDragging.emitter.on("pointerdown", this.handlePointerDown);
    hitDragging.emitter.on("dragend", this.handleDragEnd);
  }
  destroy() {
    this.dragging.destroy();
  }
};
var DateSelecting = class extends Interaction {
  constructor(settings) {
    super(settings);
    this.dragSelection = null;
    this.handlePointerDown = (ev) => {
      let { component: component2, dragging: dragging2 } = this;
      let { options: options2 } = component2.context;
      let canSelect = options2.selectable && component2.isValidDateDownEl(ev.origEvent.target);
      dragging2.setIgnoreMove(!canSelect);
      dragging2.delay = ev.isTouch ? getComponentTouchDelay$1(component2) : null;
    };
    this.handleDragStart = (ev) => {
      this.component.context.calendarApi.unselect(ev);
    };
    this.handleHitUpdate = (hit, isFinal) => {
      let { context } = this.component;
      let dragSelection = null;
      let isInvalid = false;
      if (hit) {
        let initialHit = this.hitDragging.initialHit;
        let disallowed = hit.componentId === initialHit.componentId && this.isHitComboAllowed && !this.isHitComboAllowed(initialHit, hit);
        if (!disallowed) {
          dragSelection = joinHitsIntoSelection(initialHit, hit, context.pluginHooks.dateSelectionTransformers);
        }
        if (!dragSelection || !isDateSelectionValid(dragSelection, hit.dateProfile, context)) {
          isInvalid = true;
          dragSelection = null;
        }
      }
      if (dragSelection) {
        context.dispatch({ type: "SELECT_DATES", selection: dragSelection });
      } else if (!isFinal) {
        context.dispatch({ type: "UNSELECT_DATES" });
      }
      if (!isInvalid) {
        enableCursor();
      } else {
        disableCursor();
      }
      if (!isFinal) {
        this.dragSelection = dragSelection;
      }
    };
    this.handlePointerUp = (pev) => {
      if (this.dragSelection) {
        triggerDateSelect(this.dragSelection, pev, this.component.context);
        this.dragSelection = null;
      }
    };
    let { component } = settings;
    let { options } = component.context;
    let dragging = this.dragging = new FeaturefulElementDragging(settings.el);
    dragging.touchScrollAllowed = false;
    dragging.minDistance = options.selectMinDistance || 0;
    dragging.autoScroller.isEnabled = options.dragScroll;
    let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsToStore(settings));
    hitDragging.emitter.on("pointerdown", this.handlePointerDown);
    hitDragging.emitter.on("dragstart", this.handleDragStart);
    hitDragging.emitter.on("hitupdate", this.handleHitUpdate);
    hitDragging.emitter.on("pointerup", this.handlePointerUp);
  }
  destroy() {
    this.dragging.destroy();
  }
};
function getComponentTouchDelay$1(component) {
  let { options } = component.context;
  let delay = options.selectLongPressDelay;
  if (delay == null) {
    delay = options.longPressDelay;
  }
  return delay;
}
function joinHitsIntoSelection(hit0, hit1, dateSelectionTransformers) {
  let dateSpan0 = hit0.dateSpan;
  let dateSpan1 = hit1.dateSpan;
  let ms = [
    dateSpan0.range.start,
    dateSpan0.range.end,
    dateSpan1.range.start,
    dateSpan1.range.end
  ];
  ms.sort(compareNumbers);
  let props = {};
  for (let transformer of dateSelectionTransformers) {
    let res = transformer(hit0, hit1);
    if (res === false) {
      return null;
    }
    if (res) {
      Object.assign(props, res);
    }
  }
  props.range = { start: ms[0], end: ms[3] };
  props.allDay = dateSpan0.allDay;
  return props;
}
var EventDragging = class extends Interaction {
  constructor(settings) {
    super(settings);
    this.subjectEl = null;
    this.subjectSeg = null;
    this.isDragging = false;
    this.eventRange = null;
    this.relevantEvents = null;
    this.receivingContext = null;
    this.validMutation = null;
    this.mutatedRelevantEvents = null;
    this.handlePointerDown = (ev) => {
      let origTarget = ev.origEvent.target;
      let { component: component2, dragging: dragging2 } = this;
      let { mirror } = dragging2;
      let { options: options2 } = component2.context;
      let initialContext = component2.context;
      this.subjectEl = ev.subjectEl;
      let subjectSeg = this.subjectSeg = getElSeg(ev.subjectEl);
      let eventRange = this.eventRange = subjectSeg.eventRange;
      let eventInstanceId = eventRange.instance.instanceId;
      this.relevantEvents = getRelevantEvents(initialContext.getCurrentData().eventStore, eventInstanceId);
      dragging2.minDistance = ev.isTouch ? 0 : options2.eventDragMinDistance;
      dragging2.delay = // only do a touch delay if touch and this event hasn't been selected yet
      ev.isTouch && eventInstanceId !== component2.props.eventSelection ? getComponentTouchDelay(component2) : null;
      if (options2.fixedMirrorParent) {
        mirror.parentNode = options2.fixedMirrorParent;
      } else {
        mirror.parentNode = elementClosest(origTarget, ".fc");
      }
      mirror.revertDuration = options2.dragRevertDuration;
      let isValid = component2.isValidSegDownEl(origTarget) && !elementClosest(origTarget, ".fc-event-resizer");
      dragging2.setIgnoreMove(!isValid);
      this.isDragging = isValid && ev.subjectEl.classList.contains("fc-event-draggable");
    };
    this.handleDragStart = (ev) => {
      let initialContext = this.component.context;
      let eventRange = this.eventRange;
      let eventInstanceId = eventRange.instance.instanceId;
      if (ev.isTouch) {
        if (eventInstanceId !== this.component.props.eventSelection) {
          initialContext.dispatch({ type: "SELECT_EVENT", eventInstanceId });
        }
      } else {
        initialContext.dispatch({ type: "UNSELECT_EVENT" });
      }
      if (this.isDragging) {
        initialContext.calendarApi.unselect(ev);
        initialContext.emitter.trigger("eventDragStart", {
          el: this.subjectEl,
          event: new EventImpl(initialContext, eventRange.def, eventRange.instance),
          jsEvent: ev.origEvent,
          view: initialContext.viewApi
        });
      }
    };
    this.handleHitUpdate = (hit, isFinal) => {
      if (!this.isDragging) {
        return;
      }
      let relevantEvents = this.relevantEvents;
      let initialHit = this.hitDragging.initialHit;
      let initialContext = this.component.context;
      let receivingContext = null;
      let mutation = null;
      let mutatedRelevantEvents = null;
      let isInvalid = false;
      let interaction = {
        affectedEvents: relevantEvents,
        mutatedEvents: createEmptyEventStore(),
        isEvent: true
      };
      if (hit) {
        receivingContext = hit.context;
        let receivingOptions = receivingContext.options;
        if (initialContext === receivingContext || receivingOptions.editable && receivingOptions.droppable) {
          mutation = computeEventMutation(initialHit, hit, this.eventRange.instance.range.start, receivingContext.getCurrentData().pluginHooks.eventDragMutationMassagers);
          if (mutation) {
            mutatedRelevantEvents = applyMutationToEventStore(relevantEvents, receivingContext.getCurrentData().eventUiBases, mutation, receivingContext);
            interaction.mutatedEvents = mutatedRelevantEvents;
            if (!isInteractionValid(interaction, hit.dateProfile, receivingContext)) {
              isInvalid = true;
              mutation = null;
              mutatedRelevantEvents = null;
              interaction.mutatedEvents = createEmptyEventStore();
            }
          }
        } else {
          receivingContext = null;
        }
      }
      this.displayDrag(receivingContext, interaction);
      if (!isInvalid) {
        enableCursor();
      } else {
        disableCursor();
      }
      if (!isFinal) {
        if (initialContext === receivingContext && // TODO: write test for this
        isHitsEqual(initialHit, hit)) {
          mutation = null;
        }
        this.dragging.setMirrorNeedsRevert(!mutation);
        this.dragging.setMirrorIsVisible(!hit || !this.subjectEl.getRootNode().querySelector(".fc-event-mirror"));
        this.receivingContext = receivingContext;
        this.validMutation = mutation;
        this.mutatedRelevantEvents = mutatedRelevantEvents;
      }
    };
    this.handlePointerUp = () => {
      if (!this.isDragging) {
        this.cleanup();
      }
    };
    this.handleDragEnd = (ev) => {
      if (this.isDragging) {
        let initialContext = this.component.context;
        let initialView = initialContext.viewApi;
        let { receivingContext, validMutation } = this;
        let eventDef = this.eventRange.def;
        let eventInstance = this.eventRange.instance;
        let eventApi = new EventImpl(initialContext, eventDef, eventInstance);
        let relevantEvents = this.relevantEvents;
        let mutatedRelevantEvents = this.mutatedRelevantEvents;
        let { finalHit } = this.hitDragging;
        this.clearDrag();
        initialContext.emitter.trigger("eventDragStop", {
          el: this.subjectEl,
          event: eventApi,
          jsEvent: ev.origEvent,
          view: initialView
        });
        if (validMutation) {
          if (receivingContext === initialContext) {
            let updatedEventApi = new EventImpl(initialContext, mutatedRelevantEvents.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents.instances[eventInstance.instanceId] : null);
            initialContext.dispatch({
              type: "MERGE_EVENTS",
              eventStore: mutatedRelevantEvents
            });
            let eventChangeArg = {
              oldEvent: eventApi,
              event: updatedEventApi,
              relatedEvents: buildEventApis(mutatedRelevantEvents, initialContext, eventInstance),
              revert() {
                initialContext.dispatch({
                  type: "MERGE_EVENTS",
                  eventStore: relevantEvents
                  // the pre-change data
                });
              }
            };
            let transformed = {};
            for (let transformer of initialContext.getCurrentData().pluginHooks.eventDropTransformers) {
              Object.assign(transformed, transformer(validMutation, initialContext));
            }
            initialContext.emitter.trigger("eventDrop", Object.assign(Object.assign(Object.assign({}, eventChangeArg), transformed), { el: ev.subjectEl, delta: validMutation.datesDelta, jsEvent: ev.origEvent, view: initialView }));
            initialContext.emitter.trigger("eventChange", eventChangeArg);
          } else if (receivingContext) {
            let eventRemoveArg = {
              event: eventApi,
              relatedEvents: buildEventApis(relevantEvents, initialContext, eventInstance),
              revert() {
                initialContext.dispatch({
                  type: "MERGE_EVENTS",
                  eventStore: relevantEvents
                });
              }
            };
            initialContext.emitter.trigger("eventLeave", Object.assign(Object.assign({}, eventRemoveArg), { draggedEl: ev.subjectEl, view: initialView }));
            initialContext.dispatch({
              type: "REMOVE_EVENTS",
              eventStore: relevantEvents
            });
            initialContext.emitter.trigger("eventRemove", eventRemoveArg);
            let addedEventDef = mutatedRelevantEvents.defs[eventDef.defId];
            let addedEventInstance = mutatedRelevantEvents.instances[eventInstance.instanceId];
            let addedEventApi = new EventImpl(receivingContext, addedEventDef, addedEventInstance);
            receivingContext.dispatch({
              type: "MERGE_EVENTS",
              eventStore: mutatedRelevantEvents
            });
            let eventAddArg = {
              event: addedEventApi,
              relatedEvents: buildEventApis(mutatedRelevantEvents, receivingContext, addedEventInstance),
              revert() {
                receivingContext.dispatch({
                  type: "REMOVE_EVENTS",
                  eventStore: mutatedRelevantEvents
                });
              }
            };
            receivingContext.emitter.trigger("eventAdd", eventAddArg);
            if (ev.isTouch) {
              receivingContext.dispatch({
                type: "SELECT_EVENT",
                eventInstanceId: eventInstance.instanceId
              });
            }
            receivingContext.emitter.trigger("drop", Object.assign(Object.assign({}, buildDatePointApiWithContext(finalHit.dateSpan, receivingContext)), { draggedEl: ev.subjectEl, jsEvent: ev.origEvent, view: finalHit.context.viewApi }));
            receivingContext.emitter.trigger("eventReceive", Object.assign(Object.assign({}, eventAddArg), { draggedEl: ev.subjectEl, view: finalHit.context.viewApi }));
          }
        } else {
          initialContext.emitter.trigger("_noEventDrop");
        }
      }
      this.cleanup();
    };
    let { component } = this;
    let { options } = component.context;
    let dragging = this.dragging = new FeaturefulElementDragging(settings.el);
    dragging.pointer.selector = EventDragging.SELECTOR;
    dragging.touchScrollAllowed = false;
    dragging.autoScroller.isEnabled = options.dragScroll;
    let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsStore);
    hitDragging.useSubjectCenter = settings.useEventCenter;
    hitDragging.emitter.on("pointerdown", this.handlePointerDown);
    hitDragging.emitter.on("dragstart", this.handleDragStart);
    hitDragging.emitter.on("hitupdate", this.handleHitUpdate);
    hitDragging.emitter.on("pointerup", this.handlePointerUp);
    hitDragging.emitter.on("dragend", this.handleDragEnd);
  }
  destroy() {
    this.dragging.destroy();
  }
  // render a drag state on the next receivingCalendar
  displayDrag(nextContext, state) {
    let initialContext = this.component.context;
    let prevContext = this.receivingContext;
    if (prevContext && prevContext !== nextContext) {
      if (prevContext === initialContext) {
        prevContext.dispatch({
          type: "SET_EVENT_DRAG",
          state: {
            affectedEvents: state.affectedEvents,
            mutatedEvents: createEmptyEventStore(),
            isEvent: true
          }
        });
      } else {
        prevContext.dispatch({ type: "UNSET_EVENT_DRAG" });
      }
    }
    if (nextContext) {
      nextContext.dispatch({ type: "SET_EVENT_DRAG", state });
    }
  }
  clearDrag() {
    let initialCalendar = this.component.context;
    let { receivingContext } = this;
    if (receivingContext) {
      receivingContext.dispatch({ type: "UNSET_EVENT_DRAG" });
    }
    if (initialCalendar !== receivingContext) {
      initialCalendar.dispatch({ type: "UNSET_EVENT_DRAG" });
    }
  }
  cleanup() {
    this.subjectSeg = null;
    this.isDragging = false;
    this.eventRange = null;
    this.relevantEvents = null;
    this.receivingContext = null;
    this.validMutation = null;
    this.mutatedRelevantEvents = null;
  }
};
EventDragging.SELECTOR = ".fc-event-draggable, .fc-event-resizable";
function computeEventMutation(hit0, hit1, eventInstanceStart, massagers) {
  let dateSpan0 = hit0.dateSpan;
  let dateSpan1 = hit1.dateSpan;
  let date0 = dateSpan0.range.start;
  let date1 = dateSpan1.range.start;
  let standardProps = {};
  if (dateSpan0.allDay !== dateSpan1.allDay) {
    standardProps.allDay = dateSpan1.allDay;
    standardProps.hasEnd = hit1.context.options.allDayMaintainDuration;
    if (dateSpan1.allDay) {
      date0 = startOfDay(eventInstanceStart);
    } else {
      date0 = eventInstanceStart;
    }
  }
  let delta = diffDates(date0, date1, hit0.context.dateEnv, hit0.componentId === hit1.componentId ? hit0.largeUnit : null);
  if (delta.milliseconds) {
    standardProps.allDay = false;
  }
  let mutation = {
    datesDelta: delta,
    standardProps
  };
  for (let massager of massagers) {
    massager(mutation, hit0, hit1);
  }
  return mutation;
}
function getComponentTouchDelay(component) {
  let { options } = component.context;
  let delay = options.eventLongPressDelay;
  if (delay == null) {
    delay = options.longPressDelay;
  }
  return delay;
}
var EventResizing = class extends Interaction {
  constructor(settings) {
    super(settings);
    this.draggingSegEl = null;
    this.draggingSeg = null;
    this.eventRange = null;
    this.relevantEvents = null;
    this.validMutation = null;
    this.mutatedRelevantEvents = null;
    this.handlePointerDown = (ev) => {
      let { component: component2 } = this;
      let segEl = this.querySegEl(ev);
      let seg = getElSeg(segEl);
      let eventRange = this.eventRange = seg.eventRange;
      this.dragging.minDistance = component2.context.options.eventDragMinDistance;
      this.dragging.setIgnoreMove(!this.component.isValidSegDownEl(ev.origEvent.target) || ev.isTouch && this.component.props.eventSelection !== eventRange.instance.instanceId);
    };
    this.handleDragStart = (ev) => {
      let { context } = this.component;
      let eventRange = this.eventRange;
      this.relevantEvents = getRelevantEvents(context.getCurrentData().eventStore, this.eventRange.instance.instanceId);
      let segEl = this.querySegEl(ev);
      this.draggingSegEl = segEl;
      this.draggingSeg = getElSeg(segEl);
      context.calendarApi.unselect();
      context.emitter.trigger("eventResizeStart", {
        el: segEl,
        event: new EventImpl(context, eventRange.def, eventRange.instance),
        jsEvent: ev.origEvent,
        view: context.viewApi
      });
    };
    this.handleHitUpdate = (hit, isFinal, ev) => {
      let { context } = this.component;
      let relevantEvents = this.relevantEvents;
      let initialHit = this.hitDragging.initialHit;
      let eventInstance = this.eventRange.instance;
      let mutation = null;
      let mutatedRelevantEvents = null;
      let isInvalid = false;
      let interaction = {
        affectedEvents: relevantEvents,
        mutatedEvents: createEmptyEventStore(),
        isEvent: true
      };
      if (hit) {
        let disallowed = hit.componentId === initialHit.componentId && this.isHitComboAllowed && !this.isHitComboAllowed(initialHit, hit);
        if (!disallowed) {
          mutation = computeMutation(initialHit, hit, ev.subjectEl.classList.contains("fc-event-resizer-start"), eventInstance.range);
        }
      }
      if (mutation) {
        mutatedRelevantEvents = applyMutationToEventStore(relevantEvents, context.getCurrentData().eventUiBases, mutation, context);
        interaction.mutatedEvents = mutatedRelevantEvents;
        if (!isInteractionValid(interaction, hit.dateProfile, context)) {
          isInvalid = true;
          mutation = null;
          mutatedRelevantEvents = null;
          interaction.mutatedEvents = null;
        }
      }
      if (mutatedRelevantEvents) {
        context.dispatch({
          type: "SET_EVENT_RESIZE",
          state: interaction
        });
      } else {
        context.dispatch({ type: "UNSET_EVENT_RESIZE" });
      }
      if (!isInvalid) {
        enableCursor();
      } else {
        disableCursor();
      }
      if (!isFinal) {
        if (mutation && isHitsEqual(initialHit, hit)) {
          mutation = null;
        }
        this.validMutation = mutation;
        this.mutatedRelevantEvents = mutatedRelevantEvents;
      }
    };
    this.handleDragEnd = (ev) => {
      let { context } = this.component;
      let eventDef = this.eventRange.def;
      let eventInstance = this.eventRange.instance;
      let eventApi = new EventImpl(context, eventDef, eventInstance);
      let relevantEvents = this.relevantEvents;
      let mutatedRelevantEvents = this.mutatedRelevantEvents;
      context.emitter.trigger("eventResizeStop", {
        el: this.draggingSegEl,
        event: eventApi,
        jsEvent: ev.origEvent,
        view: context.viewApi
      });
      if (this.validMutation) {
        let updatedEventApi = new EventImpl(context, mutatedRelevantEvents.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents.instances[eventInstance.instanceId] : null);
        context.dispatch({
          type: "MERGE_EVENTS",
          eventStore: mutatedRelevantEvents
        });
        let eventChangeArg = {
          oldEvent: eventApi,
          event: updatedEventApi,
          relatedEvents: buildEventApis(mutatedRelevantEvents, context, eventInstance),
          revert() {
            context.dispatch({
              type: "MERGE_EVENTS",
              eventStore: relevantEvents
              // the pre-change events
            });
          }
        };
        context.emitter.trigger("eventResize", Object.assign(Object.assign({}, eventChangeArg), { el: this.draggingSegEl, startDelta: this.validMutation.startDelta || createDuration(0), endDelta: this.validMutation.endDelta || createDuration(0), jsEvent: ev.origEvent, view: context.viewApi }));
        context.emitter.trigger("eventChange", eventChangeArg);
      } else {
        context.emitter.trigger("_noEventResize");
      }
      this.draggingSeg = null;
      this.relevantEvents = null;
      this.validMutation = null;
    };
    let { component } = settings;
    let dragging = this.dragging = new FeaturefulElementDragging(settings.el);
    dragging.pointer.selector = ".fc-event-resizer";
    dragging.touchScrollAllowed = false;
    dragging.autoScroller.isEnabled = component.context.options.dragScroll;
    let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsToStore(settings));
    hitDragging.emitter.on("pointerdown", this.handlePointerDown);
    hitDragging.emitter.on("dragstart", this.handleDragStart);
    hitDragging.emitter.on("hitupdate", this.handleHitUpdate);
    hitDragging.emitter.on("dragend", this.handleDragEnd);
  }
  destroy() {
    this.dragging.destroy();
  }
  querySegEl(ev) {
    return elementClosest(ev.subjectEl, ".fc-event");
  }
};
function computeMutation(hit0, hit1, isFromStart, instanceRange) {
  let dateEnv = hit0.context.dateEnv;
  let date0 = hit0.dateSpan.range.start;
  let date1 = hit1.dateSpan.range.start;
  let delta = diffDates(date0, date1, dateEnv, hit0.largeUnit);
  if (isFromStart) {
    if (dateEnv.add(instanceRange.start, delta) < instanceRange.end) {
      return { startDelta: delta };
    }
  } else if (dateEnv.add(instanceRange.end, delta) > instanceRange.start) {
    return { endDelta: delta };
  }
  return null;
}
var UnselectAuto = class {
  constructor(context) {
    this.context = context;
    this.isRecentPointerDateSelect = false;
    this.matchesCancel = false;
    this.matchesEvent = false;
    this.onSelect = (selectInfo) => {
      if (selectInfo.jsEvent) {
        this.isRecentPointerDateSelect = true;
      }
    };
    this.onDocumentPointerDown = (pev) => {
      let unselectCancel = this.context.options.unselectCancel;
      let downEl = getEventTargetViaRoot(pev.origEvent);
      this.matchesCancel = !!elementClosest(downEl, unselectCancel);
      this.matchesEvent = !!elementClosest(downEl, EventDragging.SELECTOR);
    };
    this.onDocumentPointerUp = (pev) => {
      let { context: context2 } = this;
      let { documentPointer: documentPointer2 } = this;
      let calendarState = context2.getCurrentData();
      if (!documentPointer2.wasTouchScroll) {
        if (calendarState.dateSelection && // an existing date selection?
        !this.isRecentPointerDateSelect) {
          let unselectAuto = context2.options.unselectAuto;
          if (unselectAuto && (!unselectAuto || !this.matchesCancel)) {
            context2.calendarApi.unselect(pev);
          }
        }
        if (calendarState.eventSelection && // an existing event selected?
        !this.matchesEvent) {
          context2.dispatch({ type: "UNSELECT_EVENT" });
        }
      }
      this.isRecentPointerDateSelect = false;
    };
    let documentPointer = this.documentPointer = new PointerDragging(document);
    documentPointer.shouldIgnoreMove = true;
    documentPointer.shouldWatchScroll = false;
    documentPointer.emitter.on("pointerdown", this.onDocumentPointerDown);
    documentPointer.emitter.on("pointerup", this.onDocumentPointerUp);
    context.emitter.on("select", this.onSelect);
  }
  destroy() {
    this.context.emitter.off("select", this.onSelect);
    this.documentPointer.destroy();
  }
};
var OPTION_REFINERS3 = {
  fixedMirrorParent: identity
};
var LISTENER_REFINERS = {
  dateClick: identity,
  eventDragStart: identity,
  eventDragStop: identity,
  eventDrop: identity,
  eventResizeStart: identity,
  eventResizeStop: identity,
  eventResize: identity,
  drop: identity,
  eventReceive: identity,
  eventLeave: identity
};
config.dataAttrPrefix = "";
var index5 = createPlugin({
  name: "@fullcalendar/interaction",
  componentInteractions: [DateClicking, DateSelecting, EventDragging, EventResizing],
  calendarInteractions: [UnselectAuto],
  elementDraggingImpl: FeaturefulElementDragging,
  optionRefiners: OPTION_REFINERS3,
  listenerRefiners: LISTENER_REFINERS
});

// node_modules/@fullcalendar/google-calendar/index.js
var API_BASE = "https://www.googleapis.com/calendar/v3/calendars";
var eventSourceDef2 = {
  parseMeta(refined) {
    let { googleCalendarId } = refined;
    if (!googleCalendarId && refined.url) {
      googleCalendarId = parseGoogleCalendarId(refined.url);
    }
    if (googleCalendarId) {
      return {
        googleCalendarId,
        googleCalendarApiKey: refined.googleCalendarApiKey,
        googleCalendarApiBase: refined.googleCalendarApiBase,
        extraParams: refined.extraParams
      };
    }
    return null;
  },
  fetch(arg, successCallback, errorCallback) {
    let { dateEnv, options } = arg.context;
    let meta = arg.eventSource.meta;
    let apiKey = meta.googleCalendarApiKey || options.googleCalendarApiKey;
    if (!apiKey) {
      errorCallback(new Error("Specify a googleCalendarApiKey. See https://fullcalendar.io/docs/google-calendar"));
    } else {
      let url = buildUrl(meta);
      let { extraParams } = meta;
      let extraParamsObj = typeof extraParams === "function" ? extraParams() : extraParams;
      let requestParams = buildRequestParams2(arg.range, apiKey, extraParamsObj, dateEnv);
      return requestJson("GET", url, requestParams).then(([body, response]) => {
        if (body.error) {
          errorCallback(new JsonRequestError("Google Calendar API: " + body.error.message, response));
        } else {
          successCallback({
            rawEvents: gcalItemsToRawEventDefs(body.items, requestParams.timeZone),
            response
          });
        }
      }, errorCallback);
    }
  }
};
function parseGoogleCalendarId(url) {
  let match;
  if (/^[^/]+@([^/.]+\.)*(google|googlemail|gmail)\.com$/.test(url)) {
    return url;
  }
  if ((match = /^https:\/\/www.googleapis.com\/calendar\/v3\/calendars\/([^/]*)/.exec(url)) || (match = /^https?:\/\/www.google.com\/calendar\/feeds\/([^/]*)/.exec(url))) {
    return decodeURIComponent(match[1]);
  }
  return null;
}
function buildUrl(meta) {
  let apiBase = meta.googleCalendarApiBase;
  if (!apiBase) {
    apiBase = API_BASE;
  }
  return apiBase + "/" + encodeURIComponent(meta.googleCalendarId) + "/events";
}
function buildRequestParams2(range2, apiKey, extraParams, dateEnv) {
  let params;
  let startStr;
  let endStr;
  if (dateEnv.canComputeOffset) {
    startStr = dateEnv.formatIso(range2.start);
    endStr = dateEnv.formatIso(range2.end);
  } else {
    startStr = addDays(range2.start, -1).toISOString();
    endStr = addDays(range2.end, 1).toISOString();
  }
  params = Object.assign(Object.assign({}, extraParams || {}), { key: apiKey, timeMin: startStr, timeMax: endStr, singleEvents: true, maxResults: 9999 });
  if (dateEnv.timeZone !== "local") {
    params.timeZone = dateEnv.timeZone;
  }
  return params;
}
function gcalItemsToRawEventDefs(items, gcalTimezone) {
  return items.map((item) => gcalItemToRawEventDef(item, gcalTimezone));
}
function gcalItemToRawEventDef(item, gcalTimezone) {
  let url = item.htmlLink || null;
  if (url && gcalTimezone) {
    url = injectQsComponent(url, "ctz=" + gcalTimezone);
  }
  return {
    id: item.id,
    title: item.summary,
    start: item.start.dateTime || item.start.date,
    end: item.end.dateTime || item.end.date,
    url,
    location: item.location,
    description: item.description,
    attachments: item.attachments || [],
    extendedProps: (item.extendedProperties || {}).shared || {}
  };
}
function injectQsComponent(url, component) {
  return url.replace(/(\?.*?)?(#|$)/, (whole, qs, hash) => (qs ? qs + "&" : "?") + component + hash);
}
var OPTION_REFINERS4 = {
  googleCalendarApiKey: String
};
var EVENT_SOURCE_REFINERS2 = {
  googleCalendarApiKey: String,
  googleCalendarId: String,
  googleCalendarApiBase: String,
  extraParams: identity
};
var index6 = createPlugin({
  name: "@fullcalendar/google-calendar",
  eventSourceDefs: [eventSourceDef2],
  optionRefiners: OPTION_REFINERS4,
  eventSourceRefiners: EVENT_SOURCE_REFINERS2
});

// node_modules/@fullcalendar/icalendar/index.js
var ICAL = __toESM(require_ical(), 1);
var IcalExpander = class {
  constructor(opts) {
    this.maxIterations = opts.maxIterations != null ? opts.maxIterations : 1e3;
    this.skipInvalidDates = opts.skipInvalidDates != null ? opts.skipInvalidDates : false;
    this.jCalData = ICAL.parse(opts.ics);
    this.component = new ICAL.Component(this.jCalData);
    this.events = this.component.getAllSubcomponents("vevent").map((vevent) => new ICAL.Event(vevent));
    if (this.skipInvalidDates) {
      this.events = this.events.filter((evt) => {
        try {
          evt.startDate.toJSDate();
          evt.endDate.toJSDate();
          return true;
        } catch (err) {
          return false;
        }
      });
    }
  }
  between(after, before) {
    function isEventWithinRange(startTime, endTime) {
      return (!after || endTime >= after.getTime()) && (!before || startTime <= before.getTime());
    }
    function getTimes(eventOrOccurrence) {
      const startTime = eventOrOccurrence.startDate.toJSDate().getTime();
      let endTime = eventOrOccurrence.endDate.toJSDate().getTime();
      if (eventOrOccurrence.endDate.isDate && endTime > startTime) {
        endTime -= 1;
      }
      return { startTime, endTime };
    }
    const exceptions = [];
    this.events.forEach((event) => {
      if (event.isRecurrenceException())
        exceptions.push(event);
    });
    const ret = {
      events: [],
      occurrences: []
    };
    this.events.filter((e3) => !e3.isRecurrenceException()).forEach((event) => {
      const exdates = [];
      event.component.getAllProperties("exdate").forEach((exdateProp) => {
        const exdate = exdateProp.getFirstValue();
        exdates.push(exdate.toJSDate().getTime());
      });
      if (event.isRecurring()) {
        const iterator = event.iterator();
        let next;
        let i3 = 0;
        do {
          i3 += 1;
          next = iterator.next();
          if (next) {
            const occurrence = event.getOccurrenceDetails(next);
            const { startTime: startTime2, endTime: endTime2 } = getTimes(occurrence);
            const isOccurrenceExcluded = exdates.indexOf(startTime2) !== -1;
            const exception = exceptions.find((ex) => ex.uid === event.uid && ex.recurrenceId.toJSDate().getTime() === occurrence.startDate.toJSDate().getTime());
            if (before && startTime2 > before.getTime())
              break;
            if (isEventWithinRange(startTime2, endTime2)) {
              if (exception) {
                ret.events.push(exception);
              } else if (!isOccurrenceExcluded) {
                ret.occurrences.push(occurrence);
              }
            }
          }
        } while (next && (!this.maxIterations || i3 < this.maxIterations));
        return;
      }
      const { startTime, endTime } = getTimes(event);
      if (isEventWithinRange(startTime, endTime))
        ret.events.push(event);
    });
    return ret;
  }
  before(before) {
    return this.between(void 0, before);
  }
  after(after) {
    return this.between(after);
  }
  all() {
    return this.between();
  }
};
var eventSourceDef3 = {
  parseMeta(refined) {
    if (refined.url && refined.format === "ics") {
      return {
        url: refined.url,
        format: "ics"
      };
    }
    return null;
  },
  fetch(arg, successCallback, errorCallback) {
    let meta = arg.eventSource.meta;
    let { internalState } = meta;
    if (!internalState || arg.isRefetch) {
      internalState = meta.internalState = {
        response: null,
        iCalExpanderPromise: fetch(meta.url, { method: "GET" }).then((response) => {
          return response.text().then((icsText) => {
            internalState.response = response;
            return new IcalExpander({
              ics: icsText,
              skipInvalidDates: true
            });
          });
        })
      };
    }
    internalState.iCalExpanderPromise.then((iCalExpander) => {
      successCallback({
        rawEvents: expandICalEvents(iCalExpander, arg.range),
        response: internalState.response
      });
    }, errorCallback);
  }
};
function expandICalEvents(iCalExpander, range2) {
  let rangeStart = addDays(range2.start, -1);
  let rangeEnd = addDays(range2.end, 1);
  let iCalRes = iCalExpander.between(rangeStart, rangeEnd);
  let expanded = [];
  for (let iCalEvent of iCalRes.events) {
    expanded.push(Object.assign(Object.assign({}, buildNonDateProps(iCalEvent)), { start: iCalEvent.startDate.toString(), end: specifiesEnd(iCalEvent) && iCalEvent.endDate ? iCalEvent.endDate.toString() : null }));
  }
  for (let iCalOccurence of iCalRes.occurrences) {
    let iCalEvent = iCalOccurence.item;
    expanded.push(Object.assign(Object.assign({}, buildNonDateProps(iCalEvent)), { start: iCalOccurence.startDate.toString(), end: specifiesEnd(iCalEvent) && iCalOccurence.endDate ? iCalOccurence.endDate.toString() : null }));
  }
  return expanded;
}
function buildNonDateProps(iCalEvent) {
  return {
    title: iCalEvent.summary,
    url: extractEventUrl(iCalEvent),
    extendedProps: {
      location: iCalEvent.location,
      organizer: iCalEvent.organizer,
      description: iCalEvent.description
    }
  };
}
function extractEventUrl(iCalEvent) {
  let urlProp = iCalEvent.component.getFirstProperty("url");
  return urlProp ? urlProp.getFirstValue() : "";
}
function specifiesEnd(iCalEvent) {
  return Boolean(iCalEvent.component.getFirstProperty("dtend")) || Boolean(iCalEvent.component.getFirstProperty("duration"));
}
var index7 = createPlugin({
  name: "@fullcalendar/icalendar",
  eventSourceDefs: [eventSourceDef3]
});

// lib/obsidian-full-calendar/calendar.ts
index3.recurringTypes[0].expand = function(errd, fr, de) {
  const hours = errd.rruleSet._dtstart.getHours();
  return errd.rruleSet.between(de.toDate(fr.start), de.toDate(fr.end), true).map((d2) => {
    return new Date(
      Date.UTC(
        d2.getFullYear(),
        d2.getMonth(),
        d2.getDate(),
        hours,
        d2.getMinutes()
      )
    );
  });
};
function renderCalendar(containerEl, eventSources, settings) {
  var _a;
  const isMobile = window.innerWidth < 500;
  const isNarrow = (settings == null ? void 0 : settings.forceNarrow) || isMobile;
  const {
    eventClick,
    select,
    modifyEvent,
    eventMouseEnter,
    openContextMenuForEvent,
    toggleTask
  } = settings || {};
  const modifyEventCallback = modifyEvent && (async ({
    event,
    oldEvent,
    revert
  }) => {
    const success = await modifyEvent(event, oldEvent);
    if (!success) {
      revert();
    }
  });
  const cal = new Calendar(containerEl, {
    plugins: [
      // View plugins
      index,
      index2,
      index4,
      // multiMonthPlugin,
      // Drag + drop and editing
      index5,
      // Remote sources
      index6,
      index7,
      index3
    ],
    googleCalendarApiKey: "AIzaSyDIiklFwJXaLWuT_4y6I9ZRVVsPuf4xGrk",
    initialView: ((_a = settings == null ? void 0 : settings.initialView) == null ? void 0 : _a[isNarrow ? "mobile" : "desktop"]) || (isNarrow ? "timeGrid3Days" : "timeGridWeek"),
    nowIndicator: true,
    scrollTimeReset: false,
    dayMaxEvents: true,
    expandRows: true,
    slotDuration: (settings == null ? void 0 : settings.slotDuration) || "00:30:00",
    // multiMonthMaxColumns: 1,
    headerToolbar: !isNarrow ? {
      left: "prev,next today",
      center: "title",
      right: "timeGrid5Days,timeGridWeek,listWeek,dayGridMonth,dayGridYear"
    } : !isMobile ? {
      right: "today,prev,next",
      left: "dayGridMonth,timeGrid3Days,listWeek,dayGridYear"
    } : false,
    footerToolbar: isMobile ? {
      right: "today,prev,next",
      left: "timeGrid3Days,dayGridMonth,dayGridYear,timeGridWeek,listWeek"
    } : false,
    views: {
      timeGrid3Days: {
        type: "timeGrid",
        duration: { days: 3 },
        buttonText: "3"
      },
      timeGrid5Days: {
        type: "timeGrid",
        duration: { days: 5 },
        buttonText: "5"
      },
      dayGridMonth: {
        dayMaxEvents: false
      },
      dayGridYear: {
        dayMaxEvents: false
      }
    },
    firstDay: settings == null ? void 0 : settings.firstDay,
    ...(settings == null ? void 0 : settings.timeFormat24h) && {
      eventTimeFormat: {
        hour: "numeric",
        minute: "2-digit",
        hour12: false
      },
      slotLabelFormat: {
        hour: "numeric",
        minute: "2-digit",
        hour12: false
      }
    },
    eventSources,
    eventClick,
    selectable: select && true,
    selectMirror: select && true,
    select: select && (async (info) => {
      await select(info.start, info.end, info.allDay, info.view.type);
      info.view.calendar.unselect();
    }),
    editable: modifyEvent && true,
    eventDrop: modifyEventCallback,
    eventResize: modifyEventCallback,
    eventMouseEnter,
    eventDidMount: ({ event, el, textColor }) => {
      el.addEventListener("contextmenu", (e3) => {
        e3.preventDefault();
        openContextMenuForEvent && openContextMenuForEvent(event, e3);
      });
      if (toggleTask) {
        if (event.extendedProps.isTask) {
          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.checked = event.extendedProps.taskCompleted !== false;
          checkbox.onclick = async (e3) => {
            e3.stopPropagation();
            if (e3.target) {
              let ret = await toggleTask(
                event,
                e3.target.checked
              );
              if (!ret) {
                e3.target.checked = !e3.target.checked;
              }
            }
          };
          if (textColor == "black") {
            checkbox.addClass("ofc-checkbox-black");
          } else {
            checkbox.addClass("ofc-checkbox-white");
          }
          if (checkbox.checked) {
            el.addClass("ofc-task-completed");
          }
          const container = el.querySelector(".fc-event-time") || el.querySelector(".fc-event-title") || el.querySelector(".fc-list-event-title");
          container == null ? void 0 : container.addClass("ofc-has-checkbox");
          container == null ? void 0 : container.prepend(checkbox);
        }
      }
    },
    longPressDelay: 250
  });
  cal.render();
  return cal;
}

// src/views/CalendarView.ts
var CalendarView = class extends import_obsidian.ItemView {
  constructor(leaf, idForCache, eventSrc, calendarSettings, cache, noteManager, placeForCreatingNote) {
    super(leaf);
    this.calendar = null;
    this.selectedSrcPaths = /* @__PURE__ */ new Set();
    this.cache = cache;
    this.idForCache = idForCache;
    this.eventSrc = eventSrc;
    this.noteManager = noteManager;
    this.calendarSettings = calendarSettings;
    this.placeForCreatingNote = placeForCreatingNote;
    for (let src of eventSrc) {
      this.selectedSrcPaths.add(src.path);
    }
  }
  getViewType() {
    return VIEW_TYPE;
  }
  getDisplayText() {
    return "Calendar";
  }
  async onOpen() {
    if (import_obsidian.Platform.isMobile)
      this.containerEl.style.height = "95vh";
    const { containerEl } = this;
    const container = containerEl.children[1];
    container.empty();
    const calendarContainer = container.createDiv(
      /*{cls: 'class'}*/
    );
    const checkBoxContainer = container.createDiv({ cls: "calendar-src-checkboxes" });
    this.render(calendarContainer).then(
      () => this.renderSrcCheckboxes(checkBoxContainer)
    );
  }
  onResize() {
    var _a;
    (_a = this.calendar) == null ? void 0 : _a.render();
  }
  addFile(data) {
    var _a;
    this.localStorage.push(data);
    if (!this.isPathInActiveSrc(data.file.path)) {
      return;
    }
    const events = this.pageToEvents(data);
    for (let event of events)
      (_a = this.calendar) == null ? void 0 : _a.addEvent(event);
  }
  changeFile(newPage, oldPage) {
    var _a, _b;
    (_a = this.calendar) == null ? void 0 : _a.pauseRendering();
    this.deleteFile(oldPage);
    this.addFile(newPage);
    (_b = this.calendar) == null ? void 0 : _b.resumeRendering();
  }
  renameFile(newPage, oldPage) {
    this.changeFile(newPage, oldPage);
  }
  deleteFile(page) {
    var _a, _b;
    const el = this.localStorage.find(
      (value) => page.file.path == value.file.path
    );
    if (el)
      this.localStorage.remove(el);
    if (!this.calendar)
      return;
    if (!this.isPathInActiveSrc(page.file.path))
      return;
    (_a = this.calendar.getEventById(page.file.path)) == null ? void 0 : _a.remove();
    for (let tick of page.ticks) {
      (_b = this.calendar.getEventById(
        templateIDTick(page.file.path, tick.name)
      )) == null ? void 0 : _b.remove();
    }
  }
  reset() {
    this.onunload();
    this.onOpen();
  }
  onunload() {
    if (!this.calendar)
      return;
    this.calendar.destroy();
    this.calendar = null;
    this.cache.unsubscribe(this.idForCache);
  }
  pageToEvents(page) {
    const result = [];
    const colours = this.calendarSettings.colours;
    const structureTemplate = {
      id: "",
      title: "",
      borderColor: colours.default,
      color: getColourFromPath(page.file.path),
      editable: true
    };
    if (page.ff_date) {
      const structure = {
        ...structureTemplate,
        id: page.file.path,
        title: page.file.name,
        ...IDateToCalendarEvent(page)
      };
      if (page.ff_frequency)
        structure.borderColor = colours.frequency;
      if (page.ff_status == TEXT_DONE)
        structure.borderColor = colours.done;
      result.push(structure);
    }
    for (let tick of page.ticks) {
      const structure = {
        ...structureTemplate,
        id: templateIDTick(page.file.path, tick.name),
        title: templateNameTick(page.file.name, tick.name),
        borderColor: colours.tick,
        extendedProps: {
          tickName: tick.name,
          notePath: page.file.path
        },
        ...IDateToCalendarEvent(tick)
      };
      result.push(structure);
    }
    return result;
  }
  renderSrcCheckboxes(srcCheckboxContainer) {
    srcCheckboxContainer.empty();
    srcCheckboxContainer.addClass("calendar-src-checkboxes");
    for (let src of this.eventSrc) {
      const checkboxContainer = srcCheckboxContainer.createDiv({ cls: "src-checkbox-item" });
      const checkbox = checkboxContainer.createEl("input", {
        type: "checkbox",
        attr: {
          id: `src-checkbox-${src.path}`,
          checked: this.selectedSrcPaths.has(src.path) ? "checked" : null
        }
      });
      checkbox.addEventListener("change", () => {
        if (checkbox.checked) {
          this.selectedSrcPaths.add(src.path);
        } else {
          this.selectedSrcPaths.delete(src.path);
        }
        this.refreshCalendar();
      });
      checkboxContainer.createEl("label", {
        text: src.path,
        attr: { for: `src-checkbox-${src.path}` }
      });
    }
  }
  isPathInActiveSrc(pagePath) {
    return this.eventSrc.some(
      (src) => src.includes(pagePath)
    );
  }
  refreshCalendar() {
    if (!this.calendar)
      return;
    this.calendar.removeAllEvents();
    const events = [];
    for (let page of this.localStorage) {
      if (!this.isPathInActiveSrc(page.file.path))
        continue;
      events.push(...this.pageToEvents(page));
    }
    for (let event of events) {
      this.calendar.addEvent(event);
    }
  }
  async render(container) {
    const subscribedData = await this.cache.subscribe(this.idForCache, this.eventSrc, this);
    this.localStorage = subscribedData;
    const events = [];
    for (const page of subscribedData) {
      if (!this.selectedSrcPaths.has(page.file.path))
        continue;
      events.push(...this.pageToEvents(page));
    }
    this.calendar = renderCalendar(
      container,
      {
        //@ts-ignore // TODO remove
        events: [
          ...this.calendarSettings.restTime,
          ...events
        ]
      },
      // as EventSource,
      this.getSettingsCalendar()
    );
    this.calendar.setOption("weekNumbers", true);
    window.setTimeout(
      (_3) => {
        var _a, _b;
        if (import_obsidian.Platform.isMobile)
          (_a = this.calendar) == null ? void 0 : _a.changeView("timeGrid3Days");
        else
          (_b = this.calendar) == null ? void 0 : _b.changeView("timeGridWeek");
      },
      1
    );
    this.calendar.render();
  }
  getSettingsCalendar() {
    const result = {
      firstDay: 1,
      weekNumbers: true,
      timeFormat24h: true,
      // TODO remove any
      eventClick: (arg) => {
        const { event, jsEvent } = arg;
        this.noteManager.openNote(event);
      },
      // TODO remove any
      modifyEvent: async (newPos, oldPos) => {
        var _a, _b;
        const props = newPos.extendedProps;
        const event = {
          start: newPos.start,
          end: newPos.end,
          allDay: newPos.allDay
        };
        if (props.notePath) {
          const page = this.cache.getPage(props.notePath);
          if (!page) {
            console.warn(`${MSG_PLG_NAME}: can't find page by Event. eventID: ${props.notePath}`);
            return false;
          }
          const tick = page.ticks.find(
            (el) => el.name == props.tickName
          );
          if (!tick) {
            console.warn(`${MSG_PLG_NAME}: can't find tick by page. Page - tickName: ${props.notePath} - ${props.tickName}`);
            return false;
          }
          if (tick.ff_duration && oldPos.allDay && !newPos.allDay) {
            event.end = timeAdd(newPos.start, tick.ff_duration);
            newPos.setEnd(event.end);
          }
          const newProp = CalendarEventToIDate(event);
          if (newPos.allDay) {
            newProp["ff_duration"] = millisecToString(
              (_a = tick.ff_duration) == null ? void 0 : _a.as("milliseconds")
            );
          }
          this.noteManager.changeTickFile(props.notePath, props.tickName, newProp);
        } else {
          const page = this.cache.getPage(newPos.id);
          if (!page) {
            console.warn(`${MSG_PLG_NAME}: can't find page by Event. eventID: ${newPos.id}`);
            return false;
          }
          if (page.ff_duration && oldPos.allDay && !newPos.allDay) {
            event.end = timeAdd(newPos.start, page.ff_duration);
            newPos.setEnd(event.end);
          }
          const newProp = CalendarEventToIDate(event);
          if (newPos.allDay) {
            newProp["ff_duration"] = millisecToString(
              (_b = page.ff_duration) == null ? void 0 : _b.as("milliseconds")
            );
          }
          this.noteManager.changePropertyFile(newPos.id, newProp);
        }
        return true;
      },
      select: (start, end, allDay, __viewMode) => {
        new nameModal(
          this.app,
          async (nameOfFile) => {
            try {
              if (!nameOfFile)
                throw 1;
              const pathOfFile = this.placeForCreatingNote + `/${nameOfFile}.md`;
              await this.noteManager.createFile(pathOfFile);
              setTimeout(
                () => this.noteManager.changePropertyFile(
                  pathOfFile,
                  CalendarEventToIDate({ start, end, allDay })
                ),
                1500
              );
            } catch (e3) {
              console.error(e3);
              new import_obsidian.Notice("Hm... error...");
            }
          }
        ).open();
      },
      openContextMenuForEvent: (e3, mouseEvent) => {
        this.contextMenuForEvent(e3, mouseEvent);
      },
      slotDuration: this.calendarSettings.slotDuration
    };
    if (import_obsidian.Platform.isMobile) {
      result.eventClick = (arg) => {
        const { event, jsEvent } = arg;
        this.contextMenuForEvent(event, jsEvent);
      };
      result.openContextMenuForEvent = (_3, __) => {
      };
    }
    return result;
  }
  contextMenuForEvent(event, mouseEvent) {
    const menu = new import_obsidian.Menu();
    menu.addItem(
      (item) => item.setTitle(event.id).onClick(async () => this.noteManager.openNote(event))
    );
    menu.showAtMouseEvent(mouseEvent);
  }
};
var nameModal = class extends import_obsidian.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h1", { text: "Name of task" });
    new import_obsidian.Setting(contentEl).setName("Name").addText(
      (text) => text.onChange((value) => this.result = value)
    );
    new import_obsidian.Setting(contentEl).addButton(
      (btn) => btn.setButtonText("Submit").setCta().onClick(() => {
        this.close();
        this.onSubmit(this.result);
      })
    );
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/cache.ts
var import_obsidian2 = require("obsidian");
var Cache2 = class {
  constructor(noteManager, vault) {
    this.storage = /* @__PURE__ */ new Map();
    this.subscribers = /* @__PURE__ */ new Map();
    this.initSync = new Promise(
      (resolve) => this.initSyncResolve = resolve
    );
    this.isInited = false;
    this.noteManager = noteManager;
    this.vault = vault;
  }
  async init() {
    this.isInited = false;
    await this.initStorage();
    this.initSyncResolve();
    this.isInited = true;
    this.initSync = new Promise(
      (resolve) => this.initSyncResolve = resolve
    );
  }
  getPage(path) {
    return this.storage.get(path);
  }
  log() {
    console.log("storage", this.storage);
    console.log("subscribers", this.subscribers);
  }
  async subscribe(id, paths, subscriber) {
    this.subscribers.set(
      id,
      {
        paths,
        subscriber
      }
    );
    if (!this.isInited)
      await this.initSync;
    const result = [];
    for (let [key, value] of this.storage) {
      const isOk = paths.some(
        (el) => el.includes(key)
      );
      if (isOk) {
        result.push(value);
      }
    }
    return result;
  }
  unsubscribe(id) {
    this.subscribers.delete(id);
  }
  async renameFile(file, oldPath) {
    if (!this.isInited)
      await this.initSync;
    const oldPage = this.storage.get(oldPath);
    const page = { ...oldPage };
    page.file = { ...oldPage.file };
    page.file.path = file.path;
    page.file.name = file.basename;
    this.storage.delete(oldPath);
    this.storage.set(file.path, page);
    for (let [_3, { paths, subscriber }] of this.subscribers) {
      const isOk1 = paths.some((el) => el.includes(file.path));
      const isOk2 = paths.some((el) => el.includes(oldPath));
      for (let path of paths) {
        if (isOk1 && isOk2)
          subscriber.renameFile(page, oldPage);
        else if (isOk2)
          subscriber.deleteFile(oldPage);
        else if (isOk1)
          subscriber.addFile(page);
      }
    }
  }
  async addFile(file) {
    if (!this.isInited)
      await this.initSync;
    const page = await this.noteManager.getPage(file);
    this.storage.set(file.path, page);
    for (let [_3, { paths, subscriber }] of this.subscribers) {
      const isOk = paths.some((el) => el.includes(file.path));
      if (isOk)
        subscriber.addFile(page);
    }
  }
  async changeFile(file) {
    if (!this.isInited)
      await this.initSync;
    const page = await this.noteManager.getPage(file);
    const oldPage = this.storage.get(file.path);
    if (isEqualObj(page, oldPage))
      return;
    this.storage.set(file.path, page);
    for (let [_3, { paths, subscriber }] of this.subscribers) {
      const isOk = paths.some((el) => el.includes(file.path));
      if (isOk)
        subscriber.changeFile(page, oldPage);
    }
  }
  async deleteFile(file) {
    if (!this.isInited)
      await this.initSync;
    const page = this.storage.get(file.path);
    this.storage.delete(file.path);
    for (let [_3, { paths, subscriber }] of this.subscribers) {
      const isOk = paths.some((el) => el.includes(file.path));
      if (isOk)
        subscriber.deleteFile(page);
    }
  }
  async reset() {
    this.isInited = false;
    this.storage.clear();
    const tmp = this.subscribers;
    this.subscribers = /* @__PURE__ */ new Map();
    await this.init();
    for (let [_3, { subscriber }] of tmp)
      subscriber.reset();
  }
  async initStorage() {
    const tFiles = this.vault.getMarkdownFiles();
    const notice = new import_obsidian2.Notice(
      `${MSG_PLG_NAME}: there are ${tFiles.length} notes`,
      1e3 * 60
      // 60 seconds
    );
    for (let i3 in tFiles) {
      const tFile = tFiles[i3];
      notice.setMessage(`${MSG_PLG_NAME}: (${i3}/${tFiles.length}) added ${tFile.path}`);
      this.storage.set(
        tFile.path,
        await this.noteManager.getPage(tFile)
      );
    }
    notice.hide();
    new import_obsidian2.Notice(`${MSG_PLG_NAME}: cache has been inited`);
  }
};

// src/setting.ts
var import_obsidian3 = require("obsidian");
var MySettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    let { containerEl } = this;
    containerEl.empty();
    const settings = this.plugin.getSettings();
    new import_obsidian3.Setting(containerEl).setHeading().setName("It's recommended to reload ObsidianApp after changing the settings");
    new import_obsidian3.Setting(containerEl).addButton(
      (btn) => {
        btn.setButtonText("Set Default Values").onClick(
          () => {
            this.plugin.saveSettings(DEFAULT_SETTINGS);
            new import_obsidian3.Notice(MSG_PLG_NAME + "The default settings has been applied");
          }
        );
      }
    );
    new import_obsidian3.Setting(containerEl).setHeading();
    new import_obsidian3.Setting(containerEl).setName("Calendar").setHeading();
    new import_obsidian3.Setting(containerEl).setName("Slot duration").setDesc(`Default: ${DEFAULT_SETTINGS.calendar.slotDuration}`).addText(
      (component) => {
        component.setPlaceholder("hh:mm:ss").setValue(settings.calendar.slotDuration).onChange(
          (value) => {
            settings.calendar.slotDuration = value;
            this.plugin.saveSettings(settings);
          }
        );
      }
    );
    new import_obsidian3.Setting(containerEl).setName("Colours").setHeading();
    for (let key of Object.keys(settings.calendar.colours)) {
      this.addColourSetting(
        containerEl,
        key,
        DEFAULT_SETTINGS.calendar.colours[key],
        settings.calendar.colours[key],
        (val) => {
          settings.calendar.colours[key] = val;
          this.plugin.saveSettings(settings);
        }
      );
    }
    new import_obsidian3.Setting(containerEl).setName("RestTime").setHeading();
    for (let index8 in settings.calendar.restTime) {
      const el = settings.calendar.restTime[index8];
      let name = "";
      if (el.color === COLOUR_REST) {
        name = "Rest time";
      } else if (el.color === COLOUR_SLEEP) {
        name = "Sleep time";
      } else
        continue;
      new import_obsidian3.Setting(containerEl).setName(`Start of ${name} (${index8})`).addText(
        (text) => {
          text.setValue(el.startTime).setPlaceholder("hh:mm:ss").onChange(
            (val) => {
              settings.calendar.restTime[index8].startTime = val;
              this.plugin.saveSettings(settings);
            }
          );
        }
      );
      new import_obsidian3.Setting(containerEl).setName(`End of ${name} (${index8})`).addText(
        (text) => {
          text.setValue(el.endTime).setPlaceholder("hh:mm:ss").onChange(
            (val) => {
              settings.calendar.restTime[index8].endTime = val;
              this.plugin.saveSettings(settings);
            }
          );
        }
      );
    }
    new import_obsidian3.Setting(containerEl).setHeading();
    new import_obsidian3.Setting(containerEl).setName("StatusCorrector").setHeading();
    const statusCorrector = settings.statusCorrector.isOn;
    new import_obsidian3.Setting(containerEl).setName("Enable tool").addToggle(
      (toggle) => toggle.setValue(statusCorrector).onChange(
        (value) => {
          settings.statusCorrector.isOn = value;
          this.plugin.saveSettings(settings);
          this.display();
        }
      )
    );
    if (statusCorrector) {
      new import_obsidian3.Setting(containerEl).setName("Start on Start Up").addToggle(
        (toggle) => toggle.setValue(settings.statusCorrector.startOnStartUp).onChange(
          (val) => {
            settings.statusCorrector.startOnStartUp = val;
            this.plugin.saveSettings(settings);
          }
        )
      );
    }
  }
  addColourSetting(containerEl, name, defaultValue, currentValue, callback) {
    new import_obsidian3.Setting(containerEl).setName(name).setDesc(`Default: ${defaultValue}`).addText(
      (component) => {
        component.setPlaceholder("#0f0f0f").setValue(currentValue).onChange((val) => callback(val));
      }
    );
  }
};

// src/views/statusCorrector.ts
var import_obsidian4 = require("obsidian");
var StatusCorrector = class {
  constructor(idForCache, eventSrc, cache, noteManager) {
    this.subscribed = false;
    this.whileSubscribing = new Promise(
      (resolve) => this.resolveSubscribing = resolve
    );
    this.cache = cache;
    this.idForCache = idForCache;
    this.eventSrc = eventSrc;
    this.noteManager = noteManager;
  }
  async init() {
    await this.cache.subscribe(this.idForCache, this.eventSrc, this);
    this.subscribed = true;
    this.resolveSubscribing();
  }
  async correctNote(page) {
    let status = page.ff_status;
    if (!status)
      return false;
    checkProgress: {
      const tasks = await getProgress(this.cache, this.noteManager, page);
      if (status == TEXT_DONE && tasks.all != tasks.done) {
        status = TEXT_IN_PROGRESS;
      } else if (status == TEXT_SOON && tasks.done != 0) {
        status = TEXT_BLOCKED;
      } else if (status != TEXT_IN_PROGRESS && tasks.done == 0 && tasks.all != 0) {
        status = TEXT_SOON;
      }
    }
    checkDate: {
      const checks = [TEXT_SOON, TEXT_BLOCKED, TEXT_CHILD_IN_PROGRESS];
      if (page.ff_date && checks.indexOf(status) != -1) {
        status = TEXT_IN_PROGRESS;
      }
    }
    checkStatus: {
      const child_ = await getChildNotePaths(page.file.path);
      const statuses = new Array();
      for (let children_ of child_) {
        const children = this.cache.getPage(children_);
        if (!(children == null ? void 0 : children.ff_status))
          continue;
        statuses.push(children.ff_status);
      }
      switch (status) {
        case TEXT_SOON: {
          if (statuses.indexOf(TEXT_IN_PROGRESS) != -1)
            status = TEXT_CHILD_IN_PROGRESS;
          else if (statuses.indexOf(TEXT_CHILD_IN_PROGRESS) != -1)
            status = TEXT_CHILD_IN_PROGRESS;
          else if (statuses.indexOf(TEXT_BLOCKED) != -1)
            status = TEXT_BLOCKED;
          else if (statuses.indexOf(TEXT_DONE) != -1)
            status = TEXT_BLOCKED;
          break;
        }
        case TEXT_BLOCKED: {
          if (statuses.indexOf(TEXT_IN_PROGRESS) != -1)
            status = TEXT_CHILD_IN_PROGRESS;
          else if (statuses.indexOf(TEXT_CHILD_IN_PROGRESS) != -1)
            status = TEXT_CHILD_IN_PROGRESS;
          break;
        }
        case TEXT_CHILD_IN_PROGRESS: {
          status = TEXT_BLOCKED;
          if (statuses.indexOf(TEXT_IN_PROGRESS) != -1)
            status = TEXT_CHILD_IN_PROGRESS;
          else if (statuses.indexOf(TEXT_CHILD_IN_PROGRESS) != -1)
            status = TEXT_CHILD_IN_PROGRESS;
          else if (statuses.indexOf(TEXT_DONE) != -1)
            status = TEXT_IN_PROGRESS;
          break;
        }
        case TEXT_DONE: {
          if (statuses.indexOf(TEXT_SOON) != -1)
            status = TEXT_BLOCKED;
          else if (statuses.indexOf(TEXT_BLOCKED) != -1)
            status = TEXT_BLOCKED;
          else if (statuses.indexOf(TEXT_IN_PROGRESS) != -1)
            status = TEXT_CHILD_IN_PROGRESS;
          else if (statuses.indexOf(TEXT_CHILD_IN_PROGRESS) != -1)
            status = TEXT_CHILD_IN_PROGRESS;
          break;
        }
      }
    }
    if (status == page.ff_status)
      return false;
    page.ff_status = status;
    await this.noteManager.changeStatusFile(page.file.path, status);
    return true;
  }
  async correctAllNotes() {
    const notice = new import_obsidian4.Notice(
      MSG_PLG_NAME + ": Start checking status of notes",
      1e3 * 60
      // 60 seconds
    );
    if (!this.subscribed) {
      await this.whileSubscribing;
    }
    const queuePaths = [];
    const set = /* @__PURE__ */ new Set();
    const computes = [];
    for (let el of this.eventSrc) {
      computes.push(
        getNotesWithoutParent(el.path)
      );
    }
    let parents_ = await Promise.all(computes);
    let parents = [];
    for (let el of parents_) {
      parents.push(...el);
    }
    parents = parents.unique().filter(
      (el) => this.eventSrc.some((src) => src.includes(el.file.path))
    );
    for (let parent of parents) {
      queuePaths.push(parent.file.path);
      set.add(parent.file.path);
    }
    for (let leftPointer = 0; leftPointer < queuePaths.length; ++leftPointer) {
      let path = queuePaths[leftPointer];
      const child = await getChildNotePaths(path);
      for (let children of child) {
        if (set.has(children))
          continue;
        set.add(children);
        queuePaths.push(children);
      }
    }
    for (let pointer = queuePaths.length - 1; pointer > 0; --pointer) {
      let i3 = queuePaths.length - pointer - 1;
      notice.setMessage(`${MSG_PLG_NAME}(status) ${i3}/${queuePaths.length}`);
      await this.correctNote(
        this.cache.getPage(
          queuePaths[pointer]
        )
      );
    }
    notice.setMessage(MSG_PLG_NAME + ": Status of Notes has been checked");
    setTimeout(
      () => notice.hide(),
      3e3
    );
    new import_obsidian4.Notice(`${MSG_PLG_NAME}: Notes has been checked`);
  }
  destroy() {
    this.cache.unsubscribe(this.idForCache);
  }
  renameFile(newPage, oldPage) {
  }
  deleteFile(page) {
  }
  reset() {
  }
  async addFile(page) {
    await this.changeFile(page, page);
  }
  async changeFile(page, oldPage) {
    const queuePaths = [];
    const set = /* @__PURE__ */ new Set();
    queuePaths.push(page.file.path);
    set.add(page.file.path);
    for (let leftPointer = 0; leftPointer < queuePaths.length; ++leftPointer) {
      const path = queuePaths[leftPointer];
      const page2 = this.cache.getPage(path);
      const oldStatus = page2.ff_status;
      const isChanged = await this.correctNote(page2);
      if (!isChanged && page2.ff_status == oldPage.ff_status)
        continue;
      new import_obsidian4.Notice(
        `${page2.file.name} - change status: ${oldStatus} => ${page2.ff_status}`
      );
      const child = await getParentNote(page2);
      for (let children of child) {
        if (!children)
          continue;
        const newPath = children.file.path;
        if (set.has(newPath))
          continue;
        set.add(newPath);
        queuePaths.push(newPath);
      }
    }
  }
};

// src/views/TickCheker.ts
var import_obsidian5 = require("obsidian");
var TickChecker = class {
  constructor(idForCache, eventSrc, cache, noteManager) {
    this.cache = cache;
    this.idForCache = idForCache;
    this.eventSrc = eventSrc;
    this.noteManager = noteManager;
  }
  async init() {
    const data = await this.cache.subscribe(this.idForCache, this.eventSrc, this);
    const calcs = data.map(
      (el) => this.process(el)
    );
    await Promise.all(calcs);
    this.cache.unsubscribe(this.idForCache);
  }
  async process(page) {
    for (let tick of page.ticks) {
      if (isNaN(safeParseInt(tick.name)))
        continue;
      let text = await this.noteManager.getText(page.file.path);
      const regExp = new RegExp(`\\[t::\\s*${tick.name}(,[^\\]]*|)\\]`, "gm");
      await this.noteManager.setText(
        page.file.path,
        text.replace(regExp, `[t::${tick.name}_$1]`)
      );
      new import_obsidian5.Notice(`${MSG_PLG_NAME}: change tickname in ${page.file.name}: ${tick.name}`);
    }
  }
  renameFile(newPage, oldPage) {
  }
  deleteFile(page) {
  }
  addFile(page) {
  }
  changeFile(newPage, oldPage) {
  }
  reset() {
  }
};

// src/NoteManager.ts
var import_obsidian6 = require("obsidian");
var NoteManager = class {
  constructor(vault, metadataCache, fileManager, workspace) {
    this.vault = vault;
    this.metadataCache = metadataCache;
    this.fileManager = fileManager;
    this.workspace = workspace;
  }
  async createFile(path) {
    await this.vault.create(path, "");
    new import_obsidian6.Notice(MSG_PLG_NAME + "created " + path);
  }
  async changePropertyFile(path, event) {
    const tFile = this.metadataCache.getFirstLinkpathDest(path, "");
    await this.fileManager.processFrontMatter(
      tFile,
      (property) => {
        property["ff_date"] = event["ff_date"].toISOString().slice(0, -14);
        property["ff_timeStart"] = event["ff_timeStart"];
        property["ff_duration"] = event["ff_duration"];
      }
    );
  }
  async changeStatusFile(path, status) {
    const tFile = this.metadataCache.getFirstLinkpathDest(path, "");
    await this.fileManager.processFrontMatter(
      tFile,
      (property) => {
        property["ff_status"] = status;
      }
    );
  }
  async changeTickFile(path, tickname, event) {
    const tFile = this.metadataCache.getFirstLinkpathDest(path, "");
    const text = await this.vault.read(tFile);
    const regExp = new RegExp(`\\[t::\\s*${tickname}(,[^\\]]*|)\\]`, "gm");
    const date = event["ff_date"].toISOString().slice(0, -14);
    const newString = `[t::${tickname},${date},${event["ff_timeStart"]},${event["ff_duration"]}]`;
    await this.vault.modify(
      tFile,
      text.replace(regExp, newString)
    );
  }
  openNote(event) {
    var _a;
    const tFile = this.metadataCache.getFirstLinkpathDest(
      ((_a = event == null ? void 0 : event.extendedProps) == null ? void 0 : _a.notePath) || event.id,
      ""
    );
    const leaf = this.workspace.getLeaf(true);
    tFile && leaf.openFile(tFile);
  }
  async getPage(file) {
    var _a;
    const result = {
      file: {
        path: file.path,
        name: file.basename
      },
      ticks: getTicksFromText(await this.vault.cachedRead(file)),
      ff_duration: "",
      ff_timeStart: "",
      // TODO - ,      ff_date,    null,   bad practice
      //@ts-ignore
      ff_date: null
    };
    const property = (_a = this.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
    if (!property) {
      return result;
    }
    const added = {
      ff_duration: dv.duration(property.ff_duration),
      ff_timeStart: dv.duration(property.ff_timeStart),
      ff_date: dv.date(property.ff_date),
      ff_status: property.ff_status
    };
    return {
      ...result,
      ...added
    };
  }
  getTaskCount(page) {
    var _a;
    const result = {
      done: 0,
      all: 0
    };
    const tFile = this.vault.getFileByPath(page.file.path);
    if (!tFile)
      return result;
    const items = (_a = this.metadataCache.getFileCache(tFile)) == null ? void 0 : _a.listItems;
    if (items)
      for (let item of items) {
        if (item.task == void 0)
          continue;
        if (item.task == "x") {
          ++result.done;
        }
        ++result.all;
      }
    return result;
  }
  async getText(path) {
    const tFile = this.metadataCache.getFirstLinkpathDest(path, "");
    const text = await this.vault.read(tFile);
    return text;
  }
  async setText(path, text) {
    const tFile = this.metadataCache.getFirstLinkpathDest(path, "");
    await this.vault.modify(tFile, text);
  }
};

// src/main.ts
var MyPlugin = class extends import_obsidian7.Plugin {
  constructor(app, manifest) {
    super(app, manifest);
    const noteManager = new NoteManager(
      this.app.vault,
      this.app.metadataCache,
      this.app.fileManager,
      this.app.workspace
    );
    this.noteManager = noteManager;
    this.cache = new Cache2(this.noteManager, this.app.vault);
  }
  async onload() {
    await this.loadSettings();
    this.initRegister();
    this.tickChecker = new TickChecker(
      3 /* TICK_CHECKER */,
      this.settings.source.noteSources,
      this.cache,
      this.noteManager
    );
    if (this.settings.statusCorrector.isOn) {
      this.statusCorrector = new StatusCorrector(
        2 /* STATUS_CORRECTOR */,
        this.settings.source.noteSources,
        this.cache,
        this.noteManager
      );
      if (this.settings.statusCorrector.startOnStartUp)
        this.statusCorrector.correctAllNotes();
      this.addCommand({
        id: "fullStatusCorrect",
        name: MSG_PLG_NAME + "Full StatusCorrector",
        callback: () => {
          this.statusCorrector.correctAllNotes();
        }
      });
    }
    this.app.workspace.onLayoutReady(() => this.init());
    this.registerView(
      VIEW_TYPE,
      (leaf) => {
        this.calendar = new CalendarView(
          leaf,
          1 /* CALENDAR */,
          this.settings.source.noteSources,
          this.settings.calendar,
          this.cache,
          this.noteManager,
          this.settings.source.defaultCreatePath
        );
        return this.calendar;
      }
    );
    this.addRibbonIcon("info", MSG_PLG_NAME + "Open Calendar", () => this.activateView());
    this.addCommand({
      id: "reset-cache",
      name: MSG_PLG_NAME + "Reset Cache",
      callback: () => {
        this.cache.reset();
      }
    });
    this.addCommand({
      id: "log-cache",
      name: MSG_PLG_NAME + "Log Cache",
      callback: () => {
        this.cache.log();
      }
    });
  }
  onunload() {
    var _a;
    (_a = this.statusCorrector) == null ? void 0 : _a.destroy();
  }
  async init() {
    var _a, _b;
    await this.cache.init();
    (_a = this.tickChecker) == null ? void 0 : _a.init();
    (_b = this.statusCorrector) == null ? void 0 : _b.init();
  }
  initRegister() {
    this.registerEvent(
      this.app.metadataCache.on("changed", (file) => {
        this.cache.changeFile(file);
      })
    );
    this.registerEvent(
      this.app.vault.on(
        "rename",
        (file, oldPath) => {
          if (!file.basename)
            return;
          this.cache.renameFile(file, oldPath);
        }
      )
    );
    this.registerEvent(
      this.app.vault.on(
        "delete",
        (file) => this.cache.deleteFile(file)
      )
    );
    this.registerEvent(
      this.app.vault.on(
        "create",
        (file) => {
          if (!file.basename)
            return;
          this.cache.addFile(file);
        }
      )
    );
  }
  async activateView() {
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE);
    if (leaves.length === 0) {
      const leaf = this.app.workspace.getLeaf(false);
      await leaf.setViewState({
        type: VIEW_TYPE,
        active: true
      });
    } else if (leaves.length === 1) {
      leaves[0].view.onOpen();
      this.app.workspace.setActiveLeaf(leaves[0]);
    } else
      for (let leaf of leaves)
        leaf.detach();
  }
  // Settings
  getSettings() {
    return JSON.parse(
      JSON.stringify(this.settings)
    );
  }
  async saveSettings(settings) {
    this.settings = settings;
    await this.saveData(this.settings);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    this.addSettingTab(new MySettingTab(this.app, this));
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvZXJyb3JzLmpzIiwgIm5vZGVfbW9kdWxlcy9vYnNpZGlhbi1kYXRhdmlldy9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvZm9ybWF0cy5qcyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy96b25lLmpzIiwgIm5vZGVfbW9kdWxlcy9vYnNpZGlhbi1kYXRhdmlldy9ub2RlX21vZHVsZXMvbHV4b24vc3JjL3pvbmVzL3N5c3RlbVpvbmUuanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvem9uZXMvSUFOQVpvbmUuanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9sb2NhbGUuanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvem9uZXMvZml4ZWRPZmZzZXRab25lLmpzIiwgIm5vZGVfbW9kdWxlcy9vYnNpZGlhbi1kYXRhdmlldy9ub2RlX21vZHVsZXMvbHV4b24vc3JjL3pvbmVzL2ludmFsaWRab25lLmpzIiwgIm5vZGVfbW9kdWxlcy9vYnNpZGlhbi1kYXRhdmlldy9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvem9uZVV0aWwuanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvc2V0dGluZ3MuanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC91dGlsLmpzIiwgIm5vZGVfbW9kdWxlcy9vYnNpZGlhbi1kYXRhdmlldy9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvZW5nbGlzaC5qcyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2Zvcm1hdHRlci5qcyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2ludmFsaWQuanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9yZWdleFBhcnNlci5qcyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9kdXJhdGlvbi5qcyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbnRlcnZhbC5qcyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbmZvLmpzIiwgIm5vZGVfbW9kdWxlcy9vYnNpZGlhbi1kYXRhdmlldy9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvZGlmZi5qcyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2RpZ2l0cy5qcyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL3Rva2VuUGFyc2VyLmpzIiwgIm5vZGVfbW9kdWxlcy9vYnNpZGlhbi1kYXRhdmlldy9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvY29udmVyc2lvbnMuanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvZGF0ZXRpbWUuanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L3NyYy9zZXR0aW5ncy50cyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvc3JjL2FwaS9yZXN1bHQudHMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9wYXJzaW1tb24vYnVpbGQvcGFyc2ltbW9uLnVtZC5taW4uanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9lbW9qaS1yZWdleC9pbmRleC5tanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L3NyYy91dGlsL25vcm1hbGl6ZS50cyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvc3JjL2RhdGEtbW9kZWwvdmFsdWUudHMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L3NyYy9leHByZXNzaW9uL2ZpZWxkLnRzIiwgIm5vZGVfbW9kdWxlcy9vYnNpZGlhbi1kYXRhdmlldy9zcmMvZGF0YS1pbmRleC9zb3VyY2UudHMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L3NyYy9leHByZXNzaW9uL3BhcnNlLnRzIiwgIm5vZGVfbW9kdWxlcy9vYnNpZGlhbi1kYXRhdmlldy9zcmMvcXVlcnkvcXVlcnkudHMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L3NyYy9xdWVyeS9wYXJzZS50cyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvc3JjL2luZGV4LnRzIiwgIm5vZGVfbW9kdWxlcy9pY2FsLmpzL2J1aWxkL2ljYWwuanMiLCAic3JjL21haW4udHMiLCAic3JjL3ZpZXdzL0NhbGVuZGFyVmlldy50cyIsICJzcmMvdHlwZXMudHMiLCAic3JjL2NvbnN0YW50cy50cyIsICJzcmMvdXRpbC50cyIsICJub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL25vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL3V0aWwuanMiLCAibm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvY29yZS9ub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9vcHRpb25zLmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvbm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvY3JlYXRlLWVsZW1lbnQuanMiLCAibm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvY29yZS9ub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9kaWZmL3Byb3BzLmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvbm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvY29tcG9uZW50LmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvbm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvY3JlYXRlLWNvbnRleHQuanMiLCAibm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvY29yZS9ub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9jb25zdGFudHMuanMiLCAibm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvY29yZS9ub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9kaWZmL2NoaWxkcmVuLmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvbm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvZGlmZi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL25vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL3JlbmRlci5qcyIsICJub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL25vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL2Nsb25lLWVsZW1lbnQuanMiLCAibm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvY29yZS9ub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9kaWZmL2NhdGNoLWVycm9yLmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvbm9kZV9tb2R1bGVzL3ByZWFjdC9ob29rcy9zcmMvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvY29yZS9ub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvdXRpbC5qcyIsICJub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL25vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy9QdXJlQ29tcG9uZW50LmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvbm9kZV9tb2R1bGVzL3ByZWFjdC9jb21wYXQvc3JjL21lbW8uanMiLCAibm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvY29yZS9ub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvZm9yd2FyZFJlZi5qcyIsICJub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL25vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy9DaGlsZHJlbi5qcyIsICJub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL25vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy9zdXNwZW5zZS5qcyIsICJub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL25vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy9zdXNwZW5zZS1saXN0LmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvbm9kZV9tb2R1bGVzL3ByZWFjdC9jb21wYXQvc3JjL3BvcnRhbHMuanMiLCAibm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvY29yZS9ub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvcmVuZGVyLmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvbm9kZV9tb2R1bGVzL3ByZWFjdC9jb21wYXQvc3JjL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvaW50ZXJuYWwtY29tbW9uLmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvZGF5Z3JpZC9pbnRlcm5hbC5qcyIsICJub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9kYXlncmlkL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL3RpbWVncmlkL2ludGVybmFsLmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL3RpbWVncmlkL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvd2Vla2RheS50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2hlbHBlcnMudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9kYXRldXRpbC50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2l0ZXJyZXN1bHQudHMiLCAibm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2NhbGxiYWNraXRlcnJlc3VsdC50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL25scC9pMThuLnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvbmxwL3RvdGV4dC50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL25scC9wYXJzZXRleHQudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy90eXBlcy50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL25scC9pbmRleC50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2RhdGV0aW1lLnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvcGFyc2VvcHRpb25zLnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvcGFyc2VzdHJpbmcudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9kYXRld2l0aHpvbmUudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9vcHRpb25zdG9zdHJpbmcudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9jYWNoZS50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL21hc2tzLnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvaXRlcmluZm8veWVhcmluZm8udHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9pdGVyaW5mby9tb250aGluZm8udHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9pdGVyaW5mby9lYXN0ZXIudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9pdGVyaW5mby9pbmRleC50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2l0ZXIvcG9zbGlzdC50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2l0ZXIvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9ycnVsZS50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2l0ZXJzZXQudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9ycnVsZXN0ci50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL3JydWxlc2V0LnRzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL3JydWxlL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2xpc3QvaW50ZXJuYWwuanMiLCAibm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvbGlzdC9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9pbnRlcmFjdGlvbi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9nb29nbGUtY2FsZW5kYXIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvaWNhbGVuZGFyL2luZGV4LmpzIiwgImxpYi9vYnNpZGlhbi1mdWxsLWNhbGVuZGFyL2NhbGVuZGFyLnRzIiwgInNyYy9jYWNoZS50cyIsICJzcmMvc2V0dGluZy50cyIsICJzcmMvdmlld3Mvc3RhdHVzQ29ycmVjdG9yLnRzIiwgInNyYy92aWV3cy9UaWNrQ2hla2VyLnRzIiwgInNyYy9Ob3RlTWFuYWdlci50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiLy8gdGhlc2UgYXJlbid0IHJlYWxseSBwcml2YXRlLCBidXQgbm9yIGFyZSB0aGV5IHJlYWxseSB1c2VmdWwgdG8gZG9jdW1lbnRcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBMdXhvbkVycm9yIGV4dGVuZHMgRXJyb3Ige31cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZERhdGVUaW1lRXJyb3IgZXh0ZW5kcyBMdXhvbkVycm9yIHtcbiAgY29uc3RydWN0b3IocmVhc29uKSB7XG4gICAgc3VwZXIoYEludmFsaWQgRGF0ZVRpbWU6ICR7cmVhc29uLnRvTWVzc2FnZSgpfWApO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRJbnRlcnZhbEVycm9yIGV4dGVuZHMgTHV4b25FcnJvciB7XG4gIGNvbnN0cnVjdG9yKHJlYXNvbikge1xuICAgIHN1cGVyKGBJbnZhbGlkIEludGVydmFsOiAke3JlYXNvbi50b01lc3NhZ2UoKX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkRHVyYXRpb25FcnJvciBleHRlbmRzIEx1eG9uRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihyZWFzb24pIHtcbiAgICBzdXBlcihgSW52YWxpZCBEdXJhdGlvbjogJHtyZWFzb24udG9NZXNzYWdlKCl9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IgZXh0ZW5kcyBMdXhvbkVycm9yIHt9XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRVbml0RXJyb3IgZXh0ZW5kcyBMdXhvbkVycm9yIHtcbiAgY29uc3RydWN0b3IodW5pdCkge1xuICAgIHN1cGVyKGBJbnZhbGlkIHVuaXQgJHt1bml0fWApO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRBcmd1bWVudEVycm9yIGV4dGVuZHMgTHV4b25FcnJvciB7fVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBab25lSXNBYnN0cmFjdEVycm9yIGV4dGVuZHMgTHV4b25FcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiWm9uZSBpcyBhbiBhYnN0cmFjdCBjbGFzc1wiKTtcbiAgfVxufVxuIiwgIi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5jb25zdCBuID0gXCJudW1lcmljXCIsXG4gIHMgPSBcInNob3J0XCIsXG4gIGwgPSBcImxvbmdcIjtcblxuZXhwb3J0IGNvbnN0IERBVEVfU0hPUlQgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBuLFxuICBkYXk6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgREFURV9NRUQgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBzLFxuICBkYXk6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgREFURV9NRURfV0lUSF9XRUVLREFZID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogcyxcbiAgZGF5OiBuLFxuICB3ZWVrZGF5OiBzLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVfRlVMTCA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IGwsXG4gIGRheTogbixcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFX0hVR0UgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBsLFxuICBkYXk6IG4sXG4gIHdlZWtkYXk6IGwsXG59O1xuXG5leHBvcnQgY29uc3QgVElNRV9TSU1QTEUgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbn07XG5cbmV4cG9ydCBjb25zdCBUSU1FX1dJVEhfU0VDT05EUyA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgVElNRV9XSVRIX1NIT1JUX09GRlNFVCA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG4gIHRpbWVab25lTmFtZTogcyxcbn07XG5cbmV4cG9ydCBjb25zdCBUSU1FX1dJVEhfTE9OR19PRkZTRVQgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxuICB0aW1lWm9uZU5hbWU6IGwsXG59O1xuXG5leHBvcnQgY29uc3QgVElNRV8yNF9TSU1QTEUgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgaG91ckN5Y2xlOiBcImgyM1wiLFxufTtcblxuZXhwb3J0IGNvbnN0IFRJTUVfMjRfV0lUSF9TRUNPTkRTID0ge1xuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbiAgaG91ckN5Y2xlOiBcImgyM1wiLFxufTtcblxuZXhwb3J0IGNvbnN0IFRJTUVfMjRfV0lUSF9TSE9SVF9PRkZTRVQgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxuICBob3VyQ3ljbGU6IFwiaDIzXCIsXG4gIHRpbWVab25lTmFtZTogcyxcbn07XG5cbmV4cG9ydCBjb25zdCBUSU1FXzI0X1dJVEhfTE9OR19PRkZTRVQgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxuICBob3VyQ3ljbGU6IFwiaDIzXCIsXG4gIHRpbWVab25lTmFtZTogbCxcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFVElNRV9TSE9SVCA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IG4sXG4gIGRheTogbixcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX1NIT1JUX1dJVEhfU0VDT05EUyA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IG4sXG4gIGRheTogbixcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfTUVEID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogcyxcbiAgZGF5OiBuLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfTUVEX1dJVEhfU0VDT05EUyA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IHMsXG4gIGRheTogbixcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfTUVEX1dJVEhfV0VFS0RBWSA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IHMsXG4gIGRheTogbixcbiAgd2Vla2RheTogcyxcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX0ZVTEwgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBsLFxuICBkYXk6IG4sXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgdGltZVpvbmVOYW1lOiBzLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX0ZVTExfV0lUSF9TRUNPTkRTID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbCxcbiAgZGF5OiBuLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbiAgdGltZVpvbmVOYW1lOiBzLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX0hVR0UgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBsLFxuICBkYXk6IG4sXG4gIHdlZWtkYXk6IGwsXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgdGltZVpvbmVOYW1lOiBsLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX0hVR0VfV0lUSF9TRUNPTkRTID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbCxcbiAgZGF5OiBuLFxuICB3ZWVrZGF5OiBsLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbiAgdGltZVpvbmVOYW1lOiBsLFxufTtcbiIsICJpbXBvcnQgeyBab25lSXNBYnN0cmFjdEVycm9yIH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5cbi8qKlxuICogQGludGVyZmFjZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBab25lIHtcbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHpvbmVcbiAgICogQGFic3RyYWN0XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgdHlwZSgpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoaXMgem9uZS5cbiAgICogQGFic3RyYWN0XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgbmFtZSgpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG5cbiAgZ2V0IGlhbmFOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBvZmZzZXQgaXMga25vd24gdG8gYmUgZml4ZWQgZm9yIHRoZSB3aG9sZSB5ZWFyLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNVbml2ZXJzYWwoKSB7XG4gICAgdGhyb3cgbmV3IFpvbmVJc0Fic3RyYWN0RXJyb3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvZmZzZXQncyBjb21tb24gbmFtZSAoc3VjaCBhcyBFU1QpIGF0IHRoZSBzcGVjaWZpZWQgdGltZXN0YW1wXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge251bWJlcn0gdHMgLSBFcG9jaCBtaWxsaXNlY29uZHMgZm9yIHdoaWNoIHRvIGdldCB0aGUgbmFtZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIE9wdGlvbnMgdG8gYWZmZWN0IHRoZSBmb3JtYXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMuZm9ybWF0IC0gV2hhdCBzdHlsZSBvZiBvZmZzZXQgdG8gcmV0dXJuLiBBY2NlcHRzICdsb25nJyBvciAnc2hvcnQnLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5sb2NhbGUgLSBXaGF0IGxvY2FsZSB0byByZXR1cm4gdGhlIG9mZnNldCBuYW1lIGluLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBvZmZzZXROYW1lKHRzLCBvcHRzKSB7XG4gICAgdGhyb3cgbmV3IFpvbmVJc0Fic3RyYWN0RXJyb3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvZmZzZXQncyB2YWx1ZSBhcyBhIHN0cmluZ1xuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRzIC0gRXBvY2ggbWlsbGlzZWNvbmRzIGZvciB3aGljaCB0byBnZXQgdGhlIG9mZnNldFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0IC0gV2hhdCBzdHlsZSBvZiBvZmZzZXQgdG8gcmV0dXJuLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgQWNjZXB0cyAnbmFycm93JywgJ3Nob3J0Jywgb3IgJ3RlY2hpZScuIFJldHVybmluZyAnKzYnLCAnKzA2OjAwJywgb3IgJyswNjAwJyByZXNwZWN0aXZlbHlcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZm9ybWF0T2Zmc2V0KHRzLCBmb3JtYXQpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgb2Zmc2V0IGluIG1pbnV0ZXMgZm9yIHRoaXMgem9uZSBhdCB0aGUgc3BlY2lmaWVkIHRpbWVzdGFtcC5cbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0cyAtIEVwb2NoIG1pbGxpc2Vjb25kcyBmb3Igd2hpY2ggdG8gY29tcHV0ZSB0aGUgb2Zmc2V0XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIG9mZnNldCh0cykge1xuICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBab25lIGlzIGVxdWFsIHRvIGFub3RoZXIgem9uZVxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtab25lfSBvdGhlclpvbmUgLSB0aGUgem9uZSB0byBjb21wYXJlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBlcXVhbHMob3RoZXJab25lKSB7XG4gICAgdGhyb3cgbmV3IFpvbmVJc0Fic3RyYWN0RXJyb3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIFpvbmUgaXMgdmFsaWQuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBmb3JtYXRPZmZzZXQsIHBhcnNlWm9uZUluZm8gfSBmcm9tIFwiLi4vaW1wbC91dGlsLmpzXCI7XG5pbXBvcnQgWm9uZSBmcm9tIFwiLi4vem9uZS5qc1wiO1xuXG5sZXQgc2luZ2xldG9uID0gbnVsbDtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBsb2NhbCB6b25lIGZvciB0aGlzIEphdmFTY3JpcHQgZW52aXJvbm1lbnQuXG4gKiBAaW1wbGVtZW50cyB7Wm9uZX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3lzdGVtWm9uZSBleHRlbmRzIFpvbmUge1xuICAvKipcbiAgICogR2V0IGEgc2luZ2xldG9uIGluc3RhbmNlIG9mIHRoZSBsb2NhbCB6b25lXG4gICAqIEByZXR1cm4ge1N5c3RlbVpvbmV9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGluc3RhbmNlKCkge1xuICAgIGlmIChzaW5nbGV0b24gPT09IG51bGwpIHtcbiAgICAgIHNpbmdsZXRvbiA9IG5ldyBTeXN0ZW1ab25lKCk7XG4gICAgfVxuICAgIHJldHVybiBzaW5nbGV0b247XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gXCJzeXN0ZW1cIjtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCgpLnJlc29sdmVkT3B0aW9ucygpLnRpbWVab25lO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IGlzVW5pdmVyc2FsKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIG9mZnNldE5hbWUodHMsIHsgZm9ybWF0LCBsb2NhbGUgfSkge1xuICAgIHJldHVybiBwYXJzZVpvbmVJbmZvKHRzLCBmb3JtYXQsIGxvY2FsZSk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBmb3JtYXRPZmZzZXQodHMsIGZvcm1hdCkge1xuICAgIHJldHVybiBmb3JtYXRPZmZzZXQodGhpcy5vZmZzZXQodHMpLCBmb3JtYXQpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgb2Zmc2V0KHRzKSB7XG4gICAgcmV0dXJuIC1uZXcgRGF0ZSh0cykuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGVxdWFscyhvdGhlclpvbmUpIHtcbiAgICByZXR1cm4gb3RoZXJab25lLnR5cGUgPT09IFwic3lzdGVtXCI7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuIiwgImltcG9ydCB7IGZvcm1hdE9mZnNldCwgcGFyc2Vab25lSW5mbywgaXNVbmRlZmluZWQsIG9ialRvTG9jYWxUUyB9IGZyb20gXCIuLi9pbXBsL3V0aWwuanNcIjtcbmltcG9ydCBab25lIGZyb20gXCIuLi96b25lLmpzXCI7XG5cbmxldCBkdGZDYWNoZSA9IHt9O1xuZnVuY3Rpb24gbWFrZURURih6b25lKSB7XG4gIGlmICghZHRmQ2FjaGVbem9uZV0pIHtcbiAgICBkdGZDYWNoZVt6b25lXSA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KFwiZW4tVVNcIiwge1xuICAgICAgaG91cjEyOiBmYWxzZSxcbiAgICAgIHRpbWVab25lOiB6b25lLFxuICAgICAgeWVhcjogXCJudW1lcmljXCIsXG4gICAgICBtb250aDogXCIyLWRpZ2l0XCIsXG4gICAgICBkYXk6IFwiMi1kaWdpdFwiLFxuICAgICAgaG91cjogXCIyLWRpZ2l0XCIsXG4gICAgICBtaW51dGU6IFwiMi1kaWdpdFwiLFxuICAgICAgc2Vjb25kOiBcIjItZGlnaXRcIixcbiAgICAgIGVyYTogXCJzaG9ydFwiLFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBkdGZDYWNoZVt6b25lXTtcbn1cblxuY29uc3QgdHlwZVRvUG9zID0ge1xuICB5ZWFyOiAwLFxuICBtb250aDogMSxcbiAgZGF5OiAyLFxuICBlcmE6IDMsXG4gIGhvdXI6IDQsXG4gIG1pbnV0ZTogNSxcbiAgc2Vjb25kOiA2LFxufTtcblxuZnVuY3Rpb24gaGFja3lPZmZzZXQoZHRmLCBkYXRlKSB7XG4gIGNvbnN0IGZvcm1hdHRlZCA9IGR0Zi5mb3JtYXQoZGF0ZSkucmVwbGFjZSgvXFx1MjAwRS9nLCBcIlwiKSxcbiAgICBwYXJzZWQgPSAvKFxcZCspXFwvKFxcZCspXFwvKFxcZCspIChBRHxCQyksPyAoXFxkKyk6KFxcZCspOihcXGQrKS8uZXhlYyhmb3JtYXR0ZWQpLFxuICAgIFssIGZNb250aCwgZkRheSwgZlllYXIsIGZhZE9yQmMsIGZIb3VyLCBmTWludXRlLCBmU2Vjb25kXSA9IHBhcnNlZDtcbiAgcmV0dXJuIFtmWWVhciwgZk1vbnRoLCBmRGF5LCBmYWRPckJjLCBmSG91ciwgZk1pbnV0ZSwgZlNlY29uZF07XG59XG5cbmZ1bmN0aW9uIHBhcnRzT2Zmc2V0KGR0ZiwgZGF0ZSkge1xuICBjb25zdCBmb3JtYXR0ZWQgPSBkdGYuZm9ybWF0VG9QYXJ0cyhkYXRlKTtcbiAgY29uc3QgZmlsbGVkID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZm9ybWF0dGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgeyB0eXBlLCB2YWx1ZSB9ID0gZm9ybWF0dGVkW2ldO1xuICAgIGNvbnN0IHBvcyA9IHR5cGVUb1Bvc1t0eXBlXTtcblxuICAgIGlmICh0eXBlID09PSBcImVyYVwiKSB7XG4gICAgICBmaWxsZWRbcG9zXSA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAoIWlzVW5kZWZpbmVkKHBvcykpIHtcbiAgICAgIGZpbGxlZFtwb3NdID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZpbGxlZDtcbn1cblxubGV0IGlhbmFab25lQ2FjaGUgPSB7fTtcbi8qKlxuICogQSB6b25lIGlkZW50aWZpZWQgYnkgYW4gSUFOQSBpZGVudGlmaWVyLCBsaWtlIEFtZXJpY2EvTmV3X1lvcmtcbiAqIEBpbXBsZW1lbnRzIHtab25lfVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJQU5BWm9uZSBleHRlbmRzIFpvbmUge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBab25lIG5hbWVcbiAgICogQHJldHVybiB7SUFOQVpvbmV9XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlKG5hbWUpIHtcbiAgICBpZiAoIWlhbmFab25lQ2FjaGVbbmFtZV0pIHtcbiAgICAgIGlhbmFab25lQ2FjaGVbbmFtZV0gPSBuZXcgSUFOQVpvbmUobmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBpYW5hWm9uZUNhY2hlW25hbWVdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IGxvY2FsIGNhY2hlcy4gU2hvdWxkIG9ubHkgYmUgbmVjZXNzYXJ5IGluIHRlc3Rpbmcgc2NlbmFyaW9zLlxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgc3RhdGljIHJlc2V0Q2FjaGUoKSB7XG4gICAgaWFuYVpvbmVDYWNoZSA9IHt9O1xuICAgIGR0ZkNhY2hlID0ge307XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBwcm92aWRlZCBzdHJpbmcgaXMgYSB2YWxpZCBzcGVjaWZpZXIuIFRoaXMgb25seSBjaGVja3MgdGhlIHN0cmluZydzIGZvcm1hdCwgbm90IHRoYXQgdGhlIHNwZWNpZmllciBpZGVudGlmaWVzIGEga25vd24gem9uZTsgc2VlIGlzVmFsaWRab25lIGZvciB0aGF0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcyAtIFRoZSBzdHJpbmcgdG8gY2hlY2sgdmFsaWRpdHkgb25cbiAgICogQGV4YW1wbGUgSUFOQVpvbmUuaXNWYWxpZFNwZWNpZmllcihcIkFtZXJpY2EvTmV3X1lvcmtcIikgLy89PiB0cnVlXG4gICAqIEBleGFtcGxlIElBTkFab25lLmlzVmFsaWRTcGVjaWZpZXIoXCJTcG9ydH5+YmxvcnBcIikgLy89PiBmYWxzZVxuICAgKiBAZGVwcmVjYXRlZCBUaGlzIG1ldGhvZCByZXR1cm5zIGZhbHNlIGZvciBzb21lIHZhbGlkIElBTkEgbmFtZXMuIFVzZSBpc1ZhbGlkWm9uZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzVmFsaWRTcGVjaWZpZXIocykge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWRab25lKHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZWQgc3RyaW5nIGlkZW50aWZpZXMgYSByZWFsIHpvbmVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHpvbmUgLSBUaGUgc3RyaW5nIHRvIGNoZWNrXG4gICAqIEBleGFtcGxlIElBTkFab25lLmlzVmFsaWRab25lKFwiQW1lcmljYS9OZXdfWW9ya1wiKSAvLz0+IHRydWVcbiAgICogQGV4YW1wbGUgSUFOQVpvbmUuaXNWYWxpZFpvbmUoXCJGYW50YXNpYS9DYXN0bGVcIikgLy89PiBmYWxzZVxuICAgKiBAZXhhbXBsZSBJQU5BWm9uZS5pc1ZhbGlkWm9uZShcIlNwb3J0fn5ibG9ycFwiKSAvLz0+IGZhbHNlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNWYWxpZFpvbmUoem9uZSkge1xuICAgIGlmICghem9uZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoXCJlbi1VU1wiLCB7IHRpbWVab25lOiB6b25lIH0pLmZvcm1hdCgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKiBAcHJpdmF0ZSAqKi9cbiAgICB0aGlzLnpvbmVOYW1lID0gbmFtZTtcbiAgICAvKiogQHByaXZhdGUgKiovXG4gICAgdGhpcy52YWxpZCA9IElBTkFab25lLmlzVmFsaWRab25lKG5hbWUpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIFwiaWFuYVwiO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuem9uZU5hbWU7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgaXNVbml2ZXJzYWwoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgb2Zmc2V0TmFtZSh0cywgeyBmb3JtYXQsIGxvY2FsZSB9KSB7XG4gICAgcmV0dXJuIHBhcnNlWm9uZUluZm8odHMsIGZvcm1hdCwgbG9jYWxlLCB0aGlzLm5hbWUpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZm9ybWF0T2Zmc2V0KHRzLCBmb3JtYXQpIHtcbiAgICByZXR1cm4gZm9ybWF0T2Zmc2V0KHRoaXMub2Zmc2V0KHRzKSwgZm9ybWF0KTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIG9mZnNldCh0cykge1xuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh0cyk7XG5cbiAgICBpZiAoaXNOYU4oZGF0ZSkpIHJldHVybiBOYU47XG5cbiAgICBjb25zdCBkdGYgPSBtYWtlRFRGKHRoaXMubmFtZSk7XG4gICAgbGV0IFt5ZWFyLCBtb250aCwgZGF5LCBhZE9yQmMsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kXSA9IGR0Zi5mb3JtYXRUb1BhcnRzXG4gICAgICA/IHBhcnRzT2Zmc2V0KGR0ZiwgZGF0ZSlcbiAgICAgIDogaGFja3lPZmZzZXQoZHRmLCBkYXRlKTtcblxuICAgIGlmIChhZE9yQmMgPT09IFwiQkNcIikge1xuICAgICAgeWVhciA9IC1NYXRoLmFicyh5ZWFyKSArIDE7XG4gICAgfVxuXG4gICAgLy8gYmVjYXVzZSB3ZSdyZSB1c2luZyBob3VyMTIgYW5kIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTEwMjU1NjQmY2FuPTImcT0lMjIyNCUzQTAwJTIyJTIwZGF0ZXRpbWVmb3JtYXRcbiAgICBjb25zdCBhZGp1c3RlZEhvdXIgPSBob3VyID09PSAyNCA/IDAgOiBob3VyO1xuXG4gICAgY29uc3QgYXNVVEMgPSBvYmpUb0xvY2FsVFMoe1xuICAgICAgeWVhcixcbiAgICAgIG1vbnRoLFxuICAgICAgZGF5LFxuICAgICAgaG91cjogYWRqdXN0ZWRIb3VyLFxuICAgICAgbWludXRlLFxuICAgICAgc2Vjb25kLFxuICAgICAgbWlsbGlzZWNvbmQ6IDAsXG4gICAgfSk7XG5cbiAgICBsZXQgYXNUUyA9ICtkYXRlO1xuICAgIGNvbnN0IG92ZXIgPSBhc1RTICUgMTAwMDtcbiAgICBhc1RTIC09IG92ZXIgPj0gMCA/IG92ZXIgOiAxMDAwICsgb3ZlcjtcbiAgICByZXR1cm4gKGFzVVRDIC0gYXNUUykgLyAoNjAgKiAxMDAwKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGVxdWFscyhvdGhlclpvbmUpIHtcbiAgICByZXR1cm4gb3RoZXJab25lLnR5cGUgPT09IFwiaWFuYVwiICYmIG90aGVyWm9uZS5uYW1lID09PSB0aGlzLm5hbWU7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy52YWxpZDtcbiAgfVxufVxuIiwgImltcG9ydCB7IHBhZFN0YXJ0LCByb3VuZFRvLCBoYXNSZWxhdGl2ZSwgZm9ybWF0T2Zmc2V0IH0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuaW1wb3J0ICogYXMgRW5nbGlzaCBmcm9tIFwiLi9lbmdsaXNoLmpzXCI7XG5pbXBvcnQgU2V0dGluZ3MgZnJvbSBcIi4uL3NldHRpbmdzLmpzXCI7XG5pbXBvcnQgRGF0ZVRpbWUgZnJvbSBcIi4uL2RhdGV0aW1lLmpzXCI7XG5pbXBvcnQgSUFOQVpvbmUgZnJvbSBcIi4uL3pvbmVzL0lBTkFab25lLmpzXCI7XG5cbi8vIHRvZG8gLSByZW1hcCBjYWNoaW5nXG5cbmxldCBpbnRsTEZDYWNoZSA9IHt9O1xuZnVuY3Rpb24gZ2V0Q2FjaGVkTEYobG9jU3RyaW5nLCBvcHRzID0ge30pIHtcbiAgY29uc3Qga2V5ID0gSlNPTi5zdHJpbmdpZnkoW2xvY1N0cmluZywgb3B0c10pO1xuICBsZXQgZHRmID0gaW50bExGQ2FjaGVba2V5XTtcbiAgaWYgKCFkdGYpIHtcbiAgICBkdGYgPSBuZXcgSW50bC5MaXN0Rm9ybWF0KGxvY1N0cmluZywgb3B0cyk7XG4gICAgaW50bExGQ2FjaGVba2V5XSA9IGR0ZjtcbiAgfVxuICByZXR1cm4gZHRmO1xufVxuXG5sZXQgaW50bERUQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGdldENhY2hlZERURihsb2NTdHJpbmcsIG9wdHMgPSB7fSkge1xuICBjb25zdCBrZXkgPSBKU09OLnN0cmluZ2lmeShbbG9jU3RyaW5nLCBvcHRzXSk7XG4gIGxldCBkdGYgPSBpbnRsRFRDYWNoZVtrZXldO1xuICBpZiAoIWR0Zikge1xuICAgIGR0ZiA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY1N0cmluZywgb3B0cyk7XG4gICAgaW50bERUQ2FjaGVba2V5XSA9IGR0ZjtcbiAgfVxuICByZXR1cm4gZHRmO1xufVxuXG5sZXQgaW50bE51bUNhY2hlID0ge307XG5mdW5jdGlvbiBnZXRDYWNoZWRJTkYobG9jU3RyaW5nLCBvcHRzID0ge30pIHtcbiAgY29uc3Qga2V5ID0gSlNPTi5zdHJpbmdpZnkoW2xvY1N0cmluZywgb3B0c10pO1xuICBsZXQgaW5mID0gaW50bE51bUNhY2hlW2tleV07XG4gIGlmICghaW5mKSB7XG4gICAgaW5mID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KGxvY1N0cmluZywgb3B0cyk7XG4gICAgaW50bE51bUNhY2hlW2tleV0gPSBpbmY7XG4gIH1cbiAgcmV0dXJuIGluZjtcbn1cblxubGV0IGludGxSZWxDYWNoZSA9IHt9O1xuZnVuY3Rpb24gZ2V0Q2FjaGVkUlRGKGxvY1N0cmluZywgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHsgYmFzZSwgLi4uY2FjaGVLZXlPcHRzIH0gPSBvcHRzOyAvLyBleGNsdWRlIGBiYXNlYCBmcm9tIHRoZSBvcHRpb25zXG4gIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KFtsb2NTdHJpbmcsIGNhY2hlS2V5T3B0c10pO1xuICBsZXQgaW5mID0gaW50bFJlbENhY2hlW2tleV07XG4gIGlmICghaW5mKSB7XG4gICAgaW5mID0gbmV3IEludGwuUmVsYXRpdmVUaW1lRm9ybWF0KGxvY1N0cmluZywgb3B0cyk7XG4gICAgaW50bFJlbENhY2hlW2tleV0gPSBpbmY7XG4gIH1cbiAgcmV0dXJuIGluZjtcbn1cblxubGV0IHN5c0xvY2FsZUNhY2hlID0gbnVsbDtcbmZ1bmN0aW9uIHN5c3RlbUxvY2FsZSgpIHtcbiAgaWYgKHN5c0xvY2FsZUNhY2hlKSB7XG4gICAgcmV0dXJuIHN5c0xvY2FsZUNhY2hlO1xuICB9IGVsc2Uge1xuICAgIHN5c0xvY2FsZUNhY2hlID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoKS5yZXNvbHZlZE9wdGlvbnMoKS5sb2NhbGU7XG4gICAgcmV0dXJuIHN5c0xvY2FsZUNhY2hlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlTG9jYWxlU3RyaW5nKGxvY2FsZVN0cikge1xuICAvLyBJIHJlYWxseSB3YW50IHRvIGF2b2lkIHdyaXRpbmcgYSBCQ1AgNDcgcGFyc2VyXG4gIC8vIHNlZSwgZS5nLiBodHRwczovL2dpdGh1Yi5jb20vd29vb3JtL2JjcC00N1xuICAvLyBJbnN0ZWFkLCB3ZSdsbCBkbyB0aGlzOlxuXG4gIC8vIGEpIGlmIHRoZSBzdHJpbmcgaGFzIG5vIC11IGV4dGVuc2lvbnMsIGp1c3QgbGVhdmUgaXQgYWxvbmVcbiAgLy8gYikgaWYgaXQgZG9lcywgdXNlIEludGwgdG8gcmVzb2x2ZSBldmVyeXRoaW5nXG4gIC8vIGMpIGlmIEludGwgZmFpbHMsIHRyeSBhZ2FpbiB3aXRob3V0IHRoZSAtdVxuXG4gIC8vIHByaXZhdGUgc3VidGFncyBhbmQgdW5pY29kZSBzdWJ0YWdzIGhhdmUgb3JkZXJpbmcgcmVxdWlyZW1lbnRzLFxuICAvLyBhbmQgd2UncmUgbm90IHByb3Blcmx5IHBhcnNpbmcgdGhpcywgc28ganVzdCBzdHJpcCBvdXQgdGhlXG4gIC8vIHByaXZhdGUgb25lcyBpZiB0aGV5IGV4aXN0LlxuICBjb25zdCB4SW5kZXggPSBsb2NhbGVTdHIuaW5kZXhPZihcIi14LVwiKTtcbiAgaWYgKHhJbmRleCAhPT0gLTEpIHtcbiAgICBsb2NhbGVTdHIgPSBsb2NhbGVTdHIuc3Vic3RyaW5nKDAsIHhJbmRleCk7XG4gIH1cblxuICBjb25zdCB1SW5kZXggPSBsb2NhbGVTdHIuaW5kZXhPZihcIi11LVwiKTtcbiAgaWYgKHVJbmRleCA9PT0gLTEpIHtcbiAgICByZXR1cm4gW2xvY2FsZVN0cl07XG4gIH0gZWxzZSB7XG4gICAgbGV0IG9wdGlvbnM7XG4gICAgbGV0IHNlbGVjdGVkU3RyO1xuICAgIHRyeSB7XG4gICAgICBvcHRpb25zID0gZ2V0Q2FjaGVkRFRGKGxvY2FsZVN0cikucmVzb2x2ZWRPcHRpb25zKCk7XG4gICAgICBzZWxlY3RlZFN0ciA9IGxvY2FsZVN0cjtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zdCBzbWFsbGVyID0gbG9jYWxlU3RyLnN1YnN0cmluZygwLCB1SW5kZXgpO1xuICAgICAgb3B0aW9ucyA9IGdldENhY2hlZERURihzbWFsbGVyKS5yZXNvbHZlZE9wdGlvbnMoKTtcbiAgICAgIHNlbGVjdGVkU3RyID0gc21hbGxlcjtcbiAgICB9XG5cbiAgICBjb25zdCB7IG51bWJlcmluZ1N5c3RlbSwgY2FsZW5kYXIgfSA9IG9wdGlvbnM7XG4gICAgcmV0dXJuIFtzZWxlY3RlZFN0ciwgbnVtYmVyaW5nU3lzdGVtLCBjYWxlbmRhcl07XG4gIH1cbn1cblxuZnVuY3Rpb24gaW50bENvbmZpZ1N0cmluZyhsb2NhbGVTdHIsIG51bWJlcmluZ1N5c3RlbSwgb3V0cHV0Q2FsZW5kYXIpIHtcbiAgaWYgKG91dHB1dENhbGVuZGFyIHx8IG51bWJlcmluZ1N5c3RlbSkge1xuICAgIGlmICghbG9jYWxlU3RyLmluY2x1ZGVzKFwiLXUtXCIpKSB7XG4gICAgICBsb2NhbGVTdHIgKz0gXCItdVwiO1xuICAgIH1cblxuICAgIGlmIChvdXRwdXRDYWxlbmRhcikge1xuICAgICAgbG9jYWxlU3RyICs9IGAtY2EtJHtvdXRwdXRDYWxlbmRhcn1gO1xuICAgIH1cblxuICAgIGlmIChudW1iZXJpbmdTeXN0ZW0pIHtcbiAgICAgIGxvY2FsZVN0ciArPSBgLW51LSR7bnVtYmVyaW5nU3lzdGVtfWA7XG4gICAgfVxuICAgIHJldHVybiBsb2NhbGVTdHI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxvY2FsZVN0cjtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXBNb250aHMoZikge1xuICBjb25zdCBtcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMTsgaSA8PSAxMjsgaSsrKSB7XG4gICAgY29uc3QgZHQgPSBEYXRlVGltZS51dGMoMjAwOSwgaSwgMSk7XG4gICAgbXMucHVzaChmKGR0KSk7XG4gIH1cbiAgcmV0dXJuIG1zO1xufVxuXG5mdW5jdGlvbiBtYXBXZWVrZGF5cyhmKSB7XG4gIGNvbnN0IG1zID0gW107XG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IDc7IGkrKykge1xuICAgIGNvbnN0IGR0ID0gRGF0ZVRpbWUudXRjKDIwMTYsIDExLCAxMyArIGkpO1xuICAgIG1zLnB1c2goZihkdCkpO1xuICB9XG4gIHJldHVybiBtcztcbn1cblxuZnVuY3Rpb24gbGlzdFN0dWZmKGxvYywgbGVuZ3RoLCBlbmdsaXNoRm4sIGludGxGbikge1xuICBjb25zdCBtb2RlID0gbG9jLmxpc3RpbmdNb2RlKCk7XG5cbiAgaWYgKG1vZGUgPT09IFwiZXJyb3JcIikge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2UgaWYgKG1vZGUgPT09IFwiZW5cIikge1xuICAgIHJldHVybiBlbmdsaXNoRm4obGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaW50bEZuKGxlbmd0aCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3VwcG9ydHNGYXN0TnVtYmVycyhsb2MpIHtcbiAgaWYgKGxvYy5udW1iZXJpbmdTeXN0ZW0gJiYgbG9jLm51bWJlcmluZ1N5c3RlbSAhPT0gXCJsYXRuXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGxvYy5udW1iZXJpbmdTeXN0ZW0gPT09IFwibGF0blwiIHx8XG4gICAgICAhbG9jLmxvY2FsZSB8fFxuICAgICAgbG9jLmxvY2FsZS5zdGFydHNXaXRoKFwiZW5cIikgfHxcbiAgICAgIG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvYy5pbnRsKS5yZXNvbHZlZE9wdGlvbnMoKS5udW1iZXJpbmdTeXN0ZW0gPT09IFwibGF0blwiXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuY2xhc3MgUG9seU51bWJlckZvcm1hdHRlciB7XG4gIGNvbnN0cnVjdG9yKGludGwsIGZvcmNlU2ltcGxlLCBvcHRzKSB7XG4gICAgdGhpcy5wYWRUbyA9IG9wdHMucGFkVG8gfHwgMDtcbiAgICB0aGlzLmZsb29yID0gb3B0cy5mbG9vciB8fCBmYWxzZTtcblxuICAgIGNvbnN0IHsgcGFkVG8sIGZsb29yLCAuLi5vdGhlck9wdHMgfSA9IG9wdHM7XG5cbiAgICBpZiAoIWZvcmNlU2ltcGxlIHx8IE9iamVjdC5rZXlzKG90aGVyT3B0cykubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgaW50bE9wdHMgPSB7IHVzZUdyb3VwaW5nOiBmYWxzZSwgLi4ub3B0cyB9O1xuICAgICAgaWYgKG9wdHMucGFkVG8gPiAwKSBpbnRsT3B0cy5taW5pbXVtSW50ZWdlckRpZ2l0cyA9IG9wdHMucGFkVG87XG4gICAgICB0aGlzLmluZiA9IGdldENhY2hlZElORihpbnRsLCBpbnRsT3B0cyk7XG4gICAgfVxuICB9XG5cbiAgZm9ybWF0KGkpIHtcbiAgICBpZiAodGhpcy5pbmYpIHtcbiAgICAgIGNvbnN0IGZpeGVkID0gdGhpcy5mbG9vciA/IE1hdGguZmxvb3IoaSkgOiBpO1xuICAgICAgcmV0dXJuIHRoaXMuaW5mLmZvcm1hdChmaXhlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRvIG1hdGNoIHRoZSBicm93c2VyJ3MgbnVtYmVyZm9ybWF0dGVyIGRlZmF1bHRzXG4gICAgICBjb25zdCBmaXhlZCA9IHRoaXMuZmxvb3IgPyBNYXRoLmZsb29yKGkpIDogcm91bmRUbyhpLCAzKTtcbiAgICAgIHJldHVybiBwYWRTdGFydChmaXhlZCwgdGhpcy5wYWRUbyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5jbGFzcyBQb2x5RGF0ZUZvcm1hdHRlciB7XG4gIGNvbnN0cnVjdG9yKGR0LCBpbnRsLCBvcHRzKSB7XG4gICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICB0aGlzLm9yaWdpbmFsWm9uZSA9IHVuZGVmaW5lZDtcblxuICAgIGxldCB6ID0gdW5kZWZpbmVkO1xuICAgIGlmICh0aGlzLm9wdHMudGltZVpvbmUpIHtcbiAgICAgIC8vIERvbid0IGFwcGx5IGFueSB3b3JrYXJvdW5kcyBpZiBhIHRpbWVab25lIGlzIGV4cGxpY2l0bHkgcHJvdmlkZWQgaW4gb3B0c1xuICAgICAgdGhpcy5kdCA9IGR0O1xuICAgIH0gZWxzZSBpZiAoZHQuem9uZS50eXBlID09PSBcImZpeGVkXCIpIHtcbiAgICAgIC8vIFVUQy04IG9yIEV0Yy9VVEMtOCBhcmUgbm90IHBhcnQgb2YgdHpkYXRhLCBvbmx5IEV0Yy9HTVQrOCBhbmQgdGhlIGxpa2UuXG4gICAgICAvLyBUaGF0IGlzIHdoeSBmaXhlZC1vZmZzZXQgVFogaXMgc2V0IHRvIHRoYXQgdW5sZXNzIGl0IGlzOlxuICAgICAgLy8gMS4gUmVwcmVzZW50aW5nIG9mZnNldCAwIHdoZW4gVVRDIGlzIHVzZWQgdG8gbWFpbnRhaW4gcHJldmlvdXMgYmVoYXZpb3IgYW5kIGRvZXMgbm90IGJlY29tZSBHTVQuXG4gICAgICAvLyAyLiBVbnN1cHBvcnRlZCBieSB0aGUgYnJvd3NlcjpcbiAgICAgIC8vICAgIC0gc29tZSBkbyBub3Qgc3VwcG9ydCBFdGMvXG4gICAgICAvLyAgICAtIDwgRXRjL0dNVC0xNCwgPiBFdGMvR01UKzEyLCBhbmQgMzAtbWludXRlIG9yIDQ1LW1pbnV0ZSBvZmZzZXRzIGFyZSBub3QgcGFydCBvZiB0emRhdGFcbiAgICAgIGNvbnN0IGdtdE9mZnNldCA9IC0xICogKGR0Lm9mZnNldCAvIDYwKTtcbiAgICAgIGNvbnN0IG9mZnNldFogPSBnbXRPZmZzZXQgPj0gMCA/IGBFdGMvR01UKyR7Z210T2Zmc2V0fWAgOiBgRXRjL0dNVCR7Z210T2Zmc2V0fWA7XG4gICAgICBpZiAoZHQub2Zmc2V0ICE9PSAwICYmIElBTkFab25lLmNyZWF0ZShvZmZzZXRaKS52YWxpZCkge1xuICAgICAgICB6ID0gb2Zmc2V0WjtcbiAgICAgICAgdGhpcy5kdCA9IGR0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm90IGFsbCBmaXhlZC1vZmZzZXQgem9uZXMgbGlrZSBFdGMvKzQ6MzAgYXJlIHByZXNlbnQgaW4gdHpkYXRhIHNvXG4gICAgICAgIC8vIHdlIG1hbnVhbGx5IGFwcGx5IHRoZSBvZmZzZXQgYW5kIHN1YnN0aXR1dGUgdGhlIHpvbmUgYXMgbmVlZGVkLlxuICAgICAgICB6ID0gXCJVVENcIjtcbiAgICAgICAgdGhpcy5kdCA9IGR0Lm9mZnNldCA9PT0gMCA/IGR0IDogZHQuc2V0Wm9uZShcIlVUQ1wiKS5wbHVzKHsgbWludXRlczogZHQub2Zmc2V0IH0pO1xuICAgICAgICB0aGlzLm9yaWdpbmFsWm9uZSA9IGR0LnpvbmU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkdC56b25lLnR5cGUgPT09IFwic3lzdGVtXCIpIHtcbiAgICAgIHRoaXMuZHQgPSBkdDtcbiAgICB9IGVsc2UgaWYgKGR0LnpvbmUudHlwZSA9PT0gXCJpYW5hXCIpIHtcbiAgICAgIHRoaXMuZHQgPSBkdDtcbiAgICAgIHogPSBkdC56b25lLm5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEN1c3RvbSB6b25lcyBjYW4gaGF2ZSBhbnkgb2Zmc2V0IC8gb2Zmc2V0TmFtZSBzbyB3ZSBqdXN0IG1hbnVhbGx5XG4gICAgICAvLyBhcHBseSB0aGUgb2Zmc2V0IGFuZCBzdWJzdGl0dXRlIHRoZSB6b25lIGFzIG5lZWRlZC5cbiAgICAgIHogPSBcIlVUQ1wiO1xuICAgICAgdGhpcy5kdCA9IGR0LnNldFpvbmUoXCJVVENcIikucGx1cyh7IG1pbnV0ZXM6IGR0Lm9mZnNldCB9KTtcbiAgICAgIHRoaXMub3JpZ2luYWxab25lID0gZHQuem9uZTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnRsT3B0cyA9IHsgLi4udGhpcy5vcHRzIH07XG4gICAgaW50bE9wdHMudGltZVpvbmUgPSBpbnRsT3B0cy50aW1lWm9uZSB8fCB6O1xuICAgIHRoaXMuZHRmID0gZ2V0Q2FjaGVkRFRGKGludGwsIGludGxPcHRzKTtcbiAgfVxuXG4gIGZvcm1hdCgpIHtcbiAgICBpZiAodGhpcy5vcmlnaW5hbFpvbmUpIHtcbiAgICAgIC8vIElmIHdlIGhhdmUgdG8gc3Vic3RpdHV0ZSBpbiB0aGUgYWN0dWFsIHpvbmUgbmFtZSwgd2UgaGF2ZSB0byB1c2VcbiAgICAgIC8vIGZvcm1hdFRvUGFydHMgc28gdGhhdCB0aGUgdGltZXpvbmUgY2FuIGJlIHJlcGxhY2VkLlxuICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0VG9QYXJ0cygpXG4gICAgICAgIC5tYXAoKHsgdmFsdWUgfSkgPT4gdmFsdWUpXG4gICAgICAgIC5qb2luKFwiXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kdGYuZm9ybWF0KHRoaXMuZHQudG9KU0RhdGUoKSk7XG4gIH1cblxuICBmb3JtYXRUb1BhcnRzKCkge1xuICAgIGNvbnN0IHBhcnRzID0gdGhpcy5kdGYuZm9ybWF0VG9QYXJ0cyh0aGlzLmR0LnRvSlNEYXRlKCkpO1xuICAgIGlmICh0aGlzLm9yaWdpbmFsWm9uZSkge1xuICAgICAgcmV0dXJuIHBhcnRzLm1hcCgocGFydCkgPT4ge1xuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInRpbWVab25lTmFtZVwiKSB7XG4gICAgICAgICAgY29uc3Qgb2Zmc2V0TmFtZSA9IHRoaXMub3JpZ2luYWxab25lLm9mZnNldE5hbWUodGhpcy5kdC50cywge1xuICAgICAgICAgICAgbG9jYWxlOiB0aGlzLmR0LmxvY2FsZSxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5vcHRzLnRpbWVab25lTmFtZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ucGFydCxcbiAgICAgICAgICAgIHZhbHVlOiBvZmZzZXROYW1lLFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcGFydHM7XG4gIH1cblxuICByZXNvbHZlZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZHRmLnJlc29sdmVkT3B0aW9ucygpO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgUG9seVJlbEZvcm1hdHRlciB7XG4gIGNvbnN0cnVjdG9yKGludGwsIGlzRW5nbGlzaCwgb3B0cykge1xuICAgIHRoaXMub3B0cyA9IHsgc3R5bGU6IFwibG9uZ1wiLCAuLi5vcHRzIH07XG4gICAgaWYgKCFpc0VuZ2xpc2ggJiYgaGFzUmVsYXRpdmUoKSkge1xuICAgICAgdGhpcy5ydGYgPSBnZXRDYWNoZWRSVEYoaW50bCwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgZm9ybWF0KGNvdW50LCB1bml0KSB7XG4gICAgaWYgKHRoaXMucnRmKSB7XG4gICAgICByZXR1cm4gdGhpcy5ydGYuZm9ybWF0KGNvdW50LCB1bml0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIEVuZ2xpc2guZm9ybWF0UmVsYXRpdmVUaW1lKHVuaXQsIGNvdW50LCB0aGlzLm9wdHMubnVtZXJpYywgdGhpcy5vcHRzLnN0eWxlICE9PSBcImxvbmdcIik7XG4gICAgfVxuICB9XG5cbiAgZm9ybWF0VG9QYXJ0cyhjb3VudCwgdW5pdCkge1xuICAgIGlmICh0aGlzLnJ0Zikge1xuICAgICAgcmV0dXJuIHRoaXMucnRmLmZvcm1hdFRvUGFydHMoY291bnQsIHVuaXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMb2NhbGUge1xuICBzdGF0aWMgZnJvbU9wdHMob3B0cykge1xuICAgIHJldHVybiBMb2NhbGUuY3JlYXRlKG9wdHMubG9jYWxlLCBvcHRzLm51bWJlcmluZ1N5c3RlbSwgb3B0cy5vdXRwdXRDYWxlbmRhciwgb3B0cy5kZWZhdWx0VG9FTik7XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhciwgZGVmYXVsdFRvRU4gPSBmYWxzZSkge1xuICAgIGNvbnN0IHNwZWNpZmllZExvY2FsZSA9IGxvY2FsZSB8fCBTZXR0aW5ncy5kZWZhdWx0TG9jYWxlO1xuICAgIC8vIHRoZSBzeXN0ZW0gbG9jYWxlIGlzIHVzZWZ1bCBmb3IgaHVtYW4gcmVhZGFibGUgc3RyaW5ncyBidXQgYW5ub3lpbmcgZm9yIHBhcnNpbmcvZm9ybWF0dGluZyBrbm93biBmb3JtYXRzXG4gICAgY29uc3QgbG9jYWxlUiA9IHNwZWNpZmllZExvY2FsZSB8fCAoZGVmYXVsdFRvRU4gPyBcImVuLVVTXCIgOiBzeXN0ZW1Mb2NhbGUoKSk7XG4gICAgY29uc3QgbnVtYmVyaW5nU3lzdGVtUiA9IG51bWJlcmluZ1N5c3RlbSB8fCBTZXR0aW5ncy5kZWZhdWx0TnVtYmVyaW5nU3lzdGVtO1xuICAgIGNvbnN0IG91dHB1dENhbGVuZGFyUiA9IG91dHB1dENhbGVuZGFyIHx8IFNldHRpbmdzLmRlZmF1bHRPdXRwdXRDYWxlbmRhcjtcbiAgICByZXR1cm4gbmV3IExvY2FsZShsb2NhbGVSLCBudW1iZXJpbmdTeXN0ZW1SLCBvdXRwdXRDYWxlbmRhclIsIHNwZWNpZmllZExvY2FsZSk7XG4gIH1cblxuICBzdGF0aWMgcmVzZXRDYWNoZSgpIHtcbiAgICBzeXNMb2NhbGVDYWNoZSA9IG51bGw7XG4gICAgaW50bERUQ2FjaGUgPSB7fTtcbiAgICBpbnRsTnVtQ2FjaGUgPSB7fTtcbiAgICBpbnRsUmVsQ2FjaGUgPSB7fTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tT2JqZWN0KHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyIH0gPSB7fSkge1xuICAgIHJldHVybiBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhcik7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihsb2NhbGUsIG51bWJlcmluZywgb3V0cHV0Q2FsZW5kYXIsIHNwZWNpZmllZExvY2FsZSkge1xuICAgIGNvbnN0IFtwYXJzZWRMb2NhbGUsIHBhcnNlZE51bWJlcmluZ1N5c3RlbSwgcGFyc2VkT3V0cHV0Q2FsZW5kYXJdID0gcGFyc2VMb2NhbGVTdHJpbmcobG9jYWxlKTtcblxuICAgIHRoaXMubG9jYWxlID0gcGFyc2VkTG9jYWxlO1xuICAgIHRoaXMubnVtYmVyaW5nU3lzdGVtID0gbnVtYmVyaW5nIHx8IHBhcnNlZE51bWJlcmluZ1N5c3RlbSB8fCBudWxsO1xuICAgIHRoaXMub3V0cHV0Q2FsZW5kYXIgPSBvdXRwdXRDYWxlbmRhciB8fCBwYXJzZWRPdXRwdXRDYWxlbmRhciB8fCBudWxsO1xuICAgIHRoaXMuaW50bCA9IGludGxDb25maWdTdHJpbmcodGhpcy5sb2NhbGUsIHRoaXMubnVtYmVyaW5nU3lzdGVtLCB0aGlzLm91dHB1dENhbGVuZGFyKTtcblxuICAgIHRoaXMud2Vla2RheXNDYWNoZSA9IHsgZm9ybWF0OiB7fSwgc3RhbmRhbG9uZToge30gfTtcbiAgICB0aGlzLm1vbnRoc0NhY2hlID0geyBmb3JtYXQ6IHt9LCBzdGFuZGFsb25lOiB7fSB9O1xuICAgIHRoaXMubWVyaWRpZW1DYWNoZSA9IG51bGw7XG4gICAgdGhpcy5lcmFDYWNoZSA9IHt9O1xuXG4gICAgdGhpcy5zcGVjaWZpZWRMb2NhbGUgPSBzcGVjaWZpZWRMb2NhbGU7XG4gICAgdGhpcy5mYXN0TnVtYmVyc0NhY2hlZCA9IG51bGw7XG4gIH1cblxuICBnZXQgZmFzdE51bWJlcnMoKSB7XG4gICAgaWYgKHRoaXMuZmFzdE51bWJlcnNDYWNoZWQgPT0gbnVsbCkge1xuICAgICAgdGhpcy5mYXN0TnVtYmVyc0NhY2hlZCA9IHN1cHBvcnRzRmFzdE51bWJlcnModGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZmFzdE51bWJlcnNDYWNoZWQ7XG4gIH1cblxuICBsaXN0aW5nTW9kZSgpIHtcbiAgICBjb25zdCBpc0FjdHVhbGx5RW4gPSB0aGlzLmlzRW5nbGlzaCgpO1xuICAgIGNvbnN0IGhhc05vV2VpcmRuZXNzID1cbiAgICAgICh0aGlzLm51bWJlcmluZ1N5c3RlbSA9PT0gbnVsbCB8fCB0aGlzLm51bWJlcmluZ1N5c3RlbSA9PT0gXCJsYXRuXCIpICYmXG4gICAgICAodGhpcy5vdXRwdXRDYWxlbmRhciA9PT0gbnVsbCB8fCB0aGlzLm91dHB1dENhbGVuZGFyID09PSBcImdyZWdvcnlcIik7XG4gICAgcmV0dXJuIGlzQWN0dWFsbHlFbiAmJiBoYXNOb1dlaXJkbmVzcyA/IFwiZW5cIiA6IFwiaW50bFwiO1xuICB9XG5cbiAgY2xvbmUoYWx0cykge1xuICAgIGlmICghYWx0cyB8fCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhbHRzKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTG9jYWxlLmNyZWF0ZShcbiAgICAgICAgYWx0cy5sb2NhbGUgfHwgdGhpcy5zcGVjaWZpZWRMb2NhbGUsXG4gICAgICAgIGFsdHMubnVtYmVyaW5nU3lzdGVtIHx8IHRoaXMubnVtYmVyaW5nU3lzdGVtLFxuICAgICAgICBhbHRzLm91dHB1dENhbGVuZGFyIHx8IHRoaXMub3V0cHV0Q2FsZW5kYXIsXG4gICAgICAgIGFsdHMuZGVmYXVsdFRvRU4gfHwgZmFsc2VcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcmVkZWZhdWx0VG9FTihhbHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSh7IC4uLmFsdHMsIGRlZmF1bHRUb0VOOiB0cnVlIH0pO1xuICB9XG5cbiAgcmVkZWZhdWx0VG9TeXN0ZW0oYWx0cyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoeyAuLi5hbHRzLCBkZWZhdWx0VG9FTjogZmFsc2UgfSk7XG4gIH1cblxuICBtb250aHMobGVuZ3RoLCBmb3JtYXQgPSBmYWxzZSkge1xuICAgIHJldHVybiBsaXN0U3R1ZmYodGhpcywgbGVuZ3RoLCBFbmdsaXNoLm1vbnRocywgKCkgPT4ge1xuICAgICAgY29uc3QgaW50bCA9IGZvcm1hdCA/IHsgbW9udGg6IGxlbmd0aCwgZGF5OiBcIm51bWVyaWNcIiB9IDogeyBtb250aDogbGVuZ3RoIH0sXG4gICAgICAgIGZvcm1hdFN0ciA9IGZvcm1hdCA/IFwiZm9ybWF0XCIgOiBcInN0YW5kYWxvbmVcIjtcbiAgICAgIGlmICghdGhpcy5tb250aHNDYWNoZVtmb3JtYXRTdHJdW2xlbmd0aF0pIHtcbiAgICAgICAgdGhpcy5tb250aHNDYWNoZVtmb3JtYXRTdHJdW2xlbmd0aF0gPSBtYXBNb250aHMoKGR0KSA9PiB0aGlzLmV4dHJhY3QoZHQsIGludGwsIFwibW9udGhcIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMubW9udGhzQ2FjaGVbZm9ybWF0U3RyXVtsZW5ndGhdO1xuICAgIH0pO1xuICB9XG5cbiAgd2Vla2RheXMobGVuZ3RoLCBmb3JtYXQgPSBmYWxzZSkge1xuICAgIHJldHVybiBsaXN0U3R1ZmYodGhpcywgbGVuZ3RoLCBFbmdsaXNoLndlZWtkYXlzLCAoKSA9PiB7XG4gICAgICBjb25zdCBpbnRsID0gZm9ybWF0XG4gICAgICAgICAgPyB7IHdlZWtkYXk6IGxlbmd0aCwgeWVhcjogXCJudW1lcmljXCIsIG1vbnRoOiBcImxvbmdcIiwgZGF5OiBcIm51bWVyaWNcIiB9XG4gICAgICAgICAgOiB7IHdlZWtkYXk6IGxlbmd0aCB9LFxuICAgICAgICBmb3JtYXRTdHIgPSBmb3JtYXQgPyBcImZvcm1hdFwiIDogXCJzdGFuZGFsb25lXCI7XG4gICAgICBpZiAoIXRoaXMud2Vla2RheXNDYWNoZVtmb3JtYXRTdHJdW2xlbmd0aF0pIHtcbiAgICAgICAgdGhpcy53ZWVrZGF5c0NhY2hlW2Zvcm1hdFN0cl1bbGVuZ3RoXSA9IG1hcFdlZWtkYXlzKChkdCkgPT5cbiAgICAgICAgICB0aGlzLmV4dHJhY3QoZHQsIGludGwsIFwid2Vla2RheVwiKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud2Vla2RheXNDYWNoZVtmb3JtYXRTdHJdW2xlbmd0aF07XG4gICAgfSk7XG4gIH1cblxuICBtZXJpZGllbXMoKSB7XG4gICAgcmV0dXJuIGxpc3RTdHVmZihcbiAgICAgIHRoaXMsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICAoKSA9PiBFbmdsaXNoLm1lcmlkaWVtcyxcbiAgICAgICgpID0+IHtcbiAgICAgICAgLy8gSW4gdGhlb3J5IHRoZXJlIGNvdWxkIGJlIGFyaWJpdHJhcnkgZGF5IHBlcmlvZHMuIFdlJ3JlIGdvbm5hIGFzc3VtZSB0aGVyZSBhcmUgZXhhY3RseSB0d29cbiAgICAgICAgLy8gZm9yIEFNIGFuZCBQTS4gVGhpcyBpcyBwcm9iYWJseSB3cm9uZywgYnV0IGl0J3MgbWFrZXMgcGFyc2luZyB3YXkgZWFzaWVyLlxuICAgICAgICBpZiAoIXRoaXMubWVyaWRpZW1DYWNoZSkge1xuICAgICAgICAgIGNvbnN0IGludGwgPSB7IGhvdXI6IFwibnVtZXJpY1wiLCBob3VyQ3ljbGU6IFwiaDEyXCIgfTtcbiAgICAgICAgICB0aGlzLm1lcmlkaWVtQ2FjaGUgPSBbRGF0ZVRpbWUudXRjKDIwMTYsIDExLCAxMywgOSksIERhdGVUaW1lLnV0YygyMDE2LCAxMSwgMTMsIDE5KV0ubWFwKFxuICAgICAgICAgICAgKGR0KSA9PiB0aGlzLmV4dHJhY3QoZHQsIGludGwsIFwiZGF5cGVyaW9kXCIpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLm1lcmlkaWVtQ2FjaGU7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIGVyYXMobGVuZ3RoKSB7XG4gICAgcmV0dXJuIGxpc3RTdHVmZih0aGlzLCBsZW5ndGgsIEVuZ2xpc2guZXJhcywgKCkgPT4ge1xuICAgICAgY29uc3QgaW50bCA9IHsgZXJhOiBsZW5ndGggfTtcblxuICAgICAgLy8gVGhpcyBpcyBwcm9ibGVtYXRpYy4gRGlmZmVyZW50IGNhbGVuZGFycyBhcmUgZ29pbmcgdG8gZGVmaW5lIGVyYXMgdG90YWxseSBkaWZmZXJlbnRseS4gV2hhdCBJIG5lZWQgaXMgdGhlIG1pbmltdW0gc2V0IG9mIGRhdGVzXG4gICAgICAvLyB0byBkZWZpbml0ZWx5IGVudW1lcmF0ZSB0aGVtLlxuICAgICAgaWYgKCF0aGlzLmVyYUNhY2hlW2xlbmd0aF0pIHtcbiAgICAgICAgdGhpcy5lcmFDYWNoZVtsZW5ndGhdID0gW0RhdGVUaW1lLnV0YygtNDAsIDEsIDEpLCBEYXRlVGltZS51dGMoMjAxNywgMSwgMSldLm1hcCgoZHQpID0+XG4gICAgICAgICAgdGhpcy5leHRyYWN0KGR0LCBpbnRsLCBcImVyYVwiKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5lcmFDYWNoZVtsZW5ndGhdO1xuICAgIH0pO1xuICB9XG5cbiAgZXh0cmFjdChkdCwgaW50bE9wdHMsIGZpZWxkKSB7XG4gICAgY29uc3QgZGYgPSB0aGlzLmR0Rm9ybWF0dGVyKGR0LCBpbnRsT3B0cyksXG4gICAgICByZXN1bHRzID0gZGYuZm9ybWF0VG9QYXJ0cygpLFxuICAgICAgbWF0Y2hpbmcgPSByZXN1bHRzLmZpbmQoKG0pID0+IG0udHlwZS50b0xvd2VyQ2FzZSgpID09PSBmaWVsZCk7XG4gICAgcmV0dXJuIG1hdGNoaW5nID8gbWF0Y2hpbmcudmFsdWUgOiBudWxsO1xuICB9XG5cbiAgbnVtYmVyRm9ybWF0dGVyKG9wdHMgPSB7fSkge1xuICAgIC8vIHRoaXMgZm9yY2VzaW1wbGUgb3B0aW9uIGlzIG5ldmVyIHVzZWQgKHRoZSBvbmx5IGNhbGxlciBzaG9ydC1jaXJjdWl0cyBvbiBpdCwgYnV0IGl0IHNlZW1zIHNhZmVyIHRvIGxlYXZlKVxuICAgIC8vIChpbiBjb250cmFzdCwgdGhlIHJlc3Qgb2YgdGhlIGNvbmRpdGlvbiBpcyB1c2VkIGhlYXZpbHkpXG4gICAgcmV0dXJuIG5ldyBQb2x5TnVtYmVyRm9ybWF0dGVyKHRoaXMuaW50bCwgb3B0cy5mb3JjZVNpbXBsZSB8fCB0aGlzLmZhc3ROdW1iZXJzLCBvcHRzKTtcbiAgfVxuXG4gIGR0Rm9ybWF0dGVyKGR0LCBpbnRsT3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBQb2x5RGF0ZUZvcm1hdHRlcihkdCwgdGhpcy5pbnRsLCBpbnRsT3B0cyk7XG4gIH1cblxuICByZWxGb3JtYXR0ZXIob3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBQb2x5UmVsRm9ybWF0dGVyKHRoaXMuaW50bCwgdGhpcy5pc0VuZ2xpc2goKSwgb3B0cyk7XG4gIH1cblxuICBsaXN0Rm9ybWF0dGVyKG9wdHMgPSB7fSkge1xuICAgIHJldHVybiBnZXRDYWNoZWRMRih0aGlzLmludGwsIG9wdHMpO1xuICB9XG5cbiAgaXNFbmdsaXNoKCkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmxvY2FsZSA9PT0gXCJlblwiIHx8XG4gICAgICB0aGlzLmxvY2FsZS50b0xvd2VyQ2FzZSgpID09PSBcImVuLXVzXCIgfHxcbiAgICAgIG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KHRoaXMuaW50bCkucmVzb2x2ZWRPcHRpb25zKCkubG9jYWxlLnN0YXJ0c1dpdGgoXCJlbi11c1wiKVxuICAgICk7XG4gIH1cblxuICBlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5sb2NhbGUgPT09IG90aGVyLmxvY2FsZSAmJlxuICAgICAgdGhpcy5udW1iZXJpbmdTeXN0ZW0gPT09IG90aGVyLm51bWJlcmluZ1N5c3RlbSAmJlxuICAgICAgdGhpcy5vdXRwdXRDYWxlbmRhciA9PT0gb3RoZXIub3V0cHV0Q2FsZW5kYXJcbiAgICApO1xuICB9XG59XG4iLCAiaW1wb3J0IHsgZm9ybWF0T2Zmc2V0LCBzaWduZWRPZmZzZXQgfSBmcm9tIFwiLi4vaW1wbC91dGlsLmpzXCI7XG5pbXBvcnQgWm9uZSBmcm9tIFwiLi4vem9uZS5qc1wiO1xuXG5sZXQgc2luZ2xldG9uID0gbnVsbDtcblxuLyoqXG4gKiBBIHpvbmUgd2l0aCBhIGZpeGVkIG9mZnNldCAobWVhbmluZyBubyBEU1QpXG4gKiBAaW1wbGVtZW50cyB7Wm9uZX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRml4ZWRPZmZzZXRab25lIGV4dGVuZHMgWm9uZSB7XG4gIC8qKlxuICAgKiBHZXQgYSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgVVRDXG4gICAqIEByZXR1cm4ge0ZpeGVkT2Zmc2V0Wm9uZX1cbiAgICovXG4gIHN0YXRpYyBnZXQgdXRjSW5zdGFuY2UoKSB7XG4gICAgaWYgKHNpbmdsZXRvbiA9PT0gbnVsbCkge1xuICAgICAgc2luZ2xldG9uID0gbmV3IEZpeGVkT2Zmc2V0Wm9uZSgwKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpbmdsZXRvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gaW5zdGFuY2Ugd2l0aCBhIHNwZWNpZmllZCBvZmZzZXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtIFRoZSBvZmZzZXQgaW4gbWludXRlc1xuICAgKiBAcmV0dXJuIHtGaXhlZE9mZnNldFpvbmV9XG4gICAqL1xuICBzdGF0aWMgaW5zdGFuY2Uob2Zmc2V0KSB7XG4gICAgcmV0dXJuIG9mZnNldCA9PT0gMCA/IEZpeGVkT2Zmc2V0Wm9uZS51dGNJbnN0YW5jZSA6IG5ldyBGaXhlZE9mZnNldFpvbmUob2Zmc2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gaW5zdGFuY2Ugb2YgRml4ZWRPZmZzZXRab25lIGZyb20gYSBVVEMgb2Zmc2V0IHN0cmluZywgbGlrZSBcIlVUQys2XCJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHMgLSBUaGUgb2Zmc2V0IHN0cmluZyB0byBwYXJzZVxuICAgKiBAZXhhbXBsZSBGaXhlZE9mZnNldFpvbmUucGFyc2VTcGVjaWZpZXIoXCJVVEMrNlwiKVxuICAgKiBAZXhhbXBsZSBGaXhlZE9mZnNldFpvbmUucGFyc2VTcGVjaWZpZXIoXCJVVEMrMDZcIilcbiAgICogQGV4YW1wbGUgRml4ZWRPZmZzZXRab25lLnBhcnNlU3BlY2lmaWVyKFwiVVRDLTY6MDBcIilcbiAgICogQHJldHVybiB7Rml4ZWRPZmZzZXRab25lfVxuICAgKi9cbiAgc3RhdGljIHBhcnNlU3BlY2lmaWVyKHMpIHtcbiAgICBpZiAocykge1xuICAgICAgY29uc3QgciA9IHMubWF0Y2goL151dGMoPzooWystXVxcZHsxLDJ9KSg/OjooXFxkezJ9KSk/KT8kL2kpO1xuICAgICAgaWYgKHIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGaXhlZE9mZnNldFpvbmUoc2lnbmVkT2Zmc2V0KHJbMV0sIHJbMl0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihvZmZzZXQpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKiBAcHJpdmF0ZSAqKi9cbiAgICB0aGlzLmZpeGVkID0gb2Zmc2V0O1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIFwiZml4ZWRcIjtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmZpeGVkID09PSAwID8gXCJVVENcIiA6IGBVVEMke2Zvcm1hdE9mZnNldCh0aGlzLmZpeGVkLCBcIm5hcnJvd1wiKX1gO1xuICB9XG5cbiAgZ2V0IGlhbmFOYW1lKCkge1xuICAgIGlmICh0aGlzLmZpeGVkID09PSAwKSB7XG4gICAgICByZXR1cm4gXCJFdGMvVVRDXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBgRXRjL0dNVCR7Zm9ybWF0T2Zmc2V0KC10aGlzLmZpeGVkLCBcIm5hcnJvd1wiKX1gO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIG9mZnNldE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGZvcm1hdE9mZnNldCh0cywgZm9ybWF0KSB7XG4gICAgcmV0dXJuIGZvcm1hdE9mZnNldCh0aGlzLmZpeGVkLCBmb3JtYXQpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IGlzVW5pdmVyc2FsKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgb2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLmZpeGVkO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZXF1YWxzKG90aGVyWm9uZSkge1xuICAgIHJldHVybiBvdGhlclpvbmUudHlwZSA9PT0gXCJmaXhlZFwiICYmIG90aGVyWm9uZS5maXhlZCA9PT0gdGhpcy5maXhlZDtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG4iLCAiaW1wb3J0IFpvbmUgZnJvbSBcIi4uL3pvbmUuanNcIjtcblxuLyoqXG4gKiBBIHpvbmUgdGhhdCBmYWlsZWQgdG8gcGFyc2UuIFlvdSBzaG91bGQgbmV2ZXIgbmVlZCB0byBpbnN0YW50aWF0ZSB0aGlzLlxuICogQGltcGxlbWVudHMge1pvbmV9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEludmFsaWRab25lIGV4dGVuZHMgWm9uZSB7XG4gIGNvbnN0cnVjdG9yKHpvbmVOYW1lKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKiogIEBwcml2YXRlICovXG4gICAgdGhpcy56b25lTmFtZSA9IHpvbmVOYW1lO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIFwiaW52YWxpZFwiO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuem9uZU5hbWU7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgaXNVbml2ZXJzYWwoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgb2Zmc2V0TmFtZSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGZvcm1hdE9mZnNldCgpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIG9mZnNldCgpIHtcbiAgICByZXR1cm4gTmFOO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZXF1YWxzKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuIiwgIi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5pbXBvcnQgWm9uZSBmcm9tIFwiLi4vem9uZS5qc1wiO1xuaW1wb3J0IElBTkFab25lIGZyb20gXCIuLi96b25lcy9JQU5BWm9uZS5qc1wiO1xuaW1wb3J0IEZpeGVkT2Zmc2V0Wm9uZSBmcm9tIFwiLi4vem9uZXMvZml4ZWRPZmZzZXRab25lLmpzXCI7XG5pbXBvcnQgSW52YWxpZFpvbmUgZnJvbSBcIi4uL3pvbmVzL2ludmFsaWRab25lLmpzXCI7XG5cbmltcG9ydCB7IGlzVW5kZWZpbmVkLCBpc1N0cmluZywgaXNOdW1iZXIgfSBmcm9tIFwiLi91dGlsLmpzXCI7XG5pbXBvcnQgU3lzdGVtWm9uZSBmcm9tIFwiLi4vem9uZXMvc3lzdGVtWm9uZS5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplWm9uZShpbnB1dCwgZGVmYXVsdFpvbmUpIHtcbiAgbGV0IG9mZnNldDtcbiAgaWYgKGlzVW5kZWZpbmVkKGlucHV0KSB8fCBpbnB1dCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBkZWZhdWx0Wm9uZTtcbiAgfSBlbHNlIGlmIChpbnB1dCBpbnN0YW5jZW9mIFpvbmUpIHtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH0gZWxzZSBpZiAoaXNTdHJpbmcoaW5wdXQpKSB7XG4gICAgY29uc3QgbG93ZXJlZCA9IGlucHV0LnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGxvd2VyZWQgPT09IFwiZGVmYXVsdFwiKSByZXR1cm4gZGVmYXVsdFpvbmU7XG4gICAgZWxzZSBpZiAobG93ZXJlZCA9PT0gXCJsb2NhbFwiIHx8IGxvd2VyZWQgPT09IFwic3lzdGVtXCIpIHJldHVybiBTeXN0ZW1ab25lLmluc3RhbmNlO1xuICAgIGVsc2UgaWYgKGxvd2VyZWQgPT09IFwidXRjXCIgfHwgbG93ZXJlZCA9PT0gXCJnbXRcIikgcmV0dXJuIEZpeGVkT2Zmc2V0Wm9uZS51dGNJbnN0YW5jZTtcbiAgICBlbHNlIHJldHVybiBGaXhlZE9mZnNldFpvbmUucGFyc2VTcGVjaWZpZXIobG93ZXJlZCkgfHwgSUFOQVpvbmUuY3JlYXRlKGlucHV0KTtcbiAgfSBlbHNlIGlmIChpc051bWJlcihpbnB1dCkpIHtcbiAgICByZXR1cm4gRml4ZWRPZmZzZXRab25lLmluc3RhbmNlKGlucHV0KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09IFwib2JqZWN0XCIgJiYgXCJvZmZzZXRcIiBpbiBpbnB1dCAmJiB0eXBlb2YgaW5wdXQub2Zmc2V0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAvLyBUaGlzIGlzIGR1bWIsIGJ1dCB0aGUgaW5zdGFuY2VvZiBjaGVjayBhYm92ZSBkb2Vzbid0IHNlZW0gdG8gcmVhbGx5IHdvcmtcbiAgICAvLyBzbyB3ZSdyZSBkdWNrIGNoZWNraW5nIGl0XG4gICAgcmV0dXJuIGlucHV0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgSW52YWxpZFpvbmUoaW5wdXQpO1xuICB9XG59XG4iLCAiaW1wb3J0IFN5c3RlbVpvbmUgZnJvbSBcIi4vem9uZXMvc3lzdGVtWm9uZS5qc1wiO1xuaW1wb3J0IElBTkFab25lIGZyb20gXCIuL3pvbmVzL0lBTkFab25lLmpzXCI7XG5pbXBvcnQgTG9jYWxlIGZyb20gXCIuL2ltcGwvbG9jYWxlLmpzXCI7XG5cbmltcG9ydCB7IG5vcm1hbGl6ZVpvbmUgfSBmcm9tIFwiLi9pbXBsL3pvbmVVdGlsLmpzXCI7XG5cbmxldCBub3cgPSAoKSA9PiBEYXRlLm5vdygpLFxuICBkZWZhdWx0Wm9uZSA9IFwic3lzdGVtXCIsXG4gIGRlZmF1bHRMb2NhbGUgPSBudWxsLFxuICBkZWZhdWx0TnVtYmVyaW5nU3lzdGVtID0gbnVsbCxcbiAgZGVmYXVsdE91dHB1dENhbGVuZGFyID0gbnVsbCxcbiAgdHdvRGlnaXRDdXRvZmZZZWFyID0gNjAsXG4gIHRocm93T25JbnZhbGlkO1xuXG4vKipcbiAqIFNldHRpbmdzIGNvbnRhaW5zIHN0YXRpYyBnZXR0ZXJzIGFuZCBzZXR0ZXJzIHRoYXQgY29udHJvbCBMdXhvbidzIG92ZXJhbGwgYmVoYXZpb3IuIEx1eG9uIGlzIGEgc2ltcGxlIGxpYnJhcnkgd2l0aCBmZXcgb3B0aW9ucywgYnV0IHRoZSBvbmVzIGl0IGRvZXMgaGF2ZSBsaXZlIGhlcmUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNldHRpbmdzIHtcbiAgLyoqXG4gICAqIEdldCB0aGUgY2FsbGJhY2sgZm9yIHJldHVybmluZyB0aGUgY3VycmVudCB0aW1lc3RhbXAuXG4gICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICovXG4gIHN0YXRpYyBnZXQgbm93KCkge1xuICAgIHJldHVybiBub3c7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBjYWxsYmFjayBmb3IgcmV0dXJuaW5nIHRoZSBjdXJyZW50IHRpbWVzdGFtcC5cbiAgICogVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBudW1iZXIsIHdoaWNoIHdpbGwgYmUgaW50ZXJwcmV0ZWQgYXMgYW4gRXBvY2ggbWlsbGlzZWNvbmQgY291bnRcbiAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgKiBAZXhhbXBsZSBTZXR0aW5ncy5ub3cgPSAoKSA9PiBEYXRlLm5vdygpICsgMzAwMCAvLyBwcmV0ZW5kIGl0IGlzIDMgc2Vjb25kcyBpbiB0aGUgZnV0dXJlXG4gICAqIEBleGFtcGxlIFNldHRpbmdzLm5vdyA9ICgpID0+IDAgLy8gYWx3YXlzIHByZXRlbmQgaXQncyBKYW4gMSwgMTk3MCBhdCBtaWRuaWdodCBpbiBVVEMgdGltZVxuICAgKi9cbiAgc3RhdGljIHNldCBub3cobikge1xuICAgIG5vdyA9IG47XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBkZWZhdWx0IHRpbWUgem9uZSB0byBjcmVhdGUgRGF0ZVRpbWVzIGluLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgKiBVc2UgdGhlIHZhbHVlIFwic3lzdGVtXCIgdG8gcmVzZXQgdGhpcyB2YWx1ZSB0byB0aGUgc3lzdGVtJ3MgdGltZSB6b25lLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIHNldCBkZWZhdWx0Wm9uZSh6b25lKSB7XG4gICAgZGVmYXVsdFpvbmUgPSB6b25lO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGVmYXVsdCB0aW1lIHpvbmUgb2JqZWN0IGN1cnJlbnRseSB1c2VkIHRvIGNyZWF0ZSBEYXRlVGltZXMuIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRoZSBzeXN0ZW0ncyB0aW1lIHpvbmUgKHRoZSBvbmUgc2V0IG9uIHRoZSBtYWNoaW5lIHRoYXQgcnVucyB0aGlzIGNvZGUpLlxuICAgKiBAdHlwZSB7Wm9uZX1cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdFpvbmUoKSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZVpvbmUoZGVmYXVsdFpvbmUsIFN5c3RlbVpvbmUuaW5zdGFuY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGVmYXVsdCBsb2NhbGUgdG8gY3JlYXRlIERhdGVUaW1lcyB3aXRoLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0TG9jYWxlKCkge1xuICAgIHJldHVybiBkZWZhdWx0TG9jYWxlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZGVmYXVsdCBsb2NhbGUgdG8gY3JlYXRlIERhdGVUaW1lcyB3aXRoLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIHNldCBkZWZhdWx0TG9jYWxlKGxvY2FsZSkge1xuICAgIGRlZmF1bHRMb2NhbGUgPSBsb2NhbGU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkZWZhdWx0IG51bWJlcmluZyBzeXN0ZW0gdG8gY3JlYXRlIERhdGVUaW1lcyB3aXRoLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0TnVtYmVyaW5nU3lzdGVtKCkge1xuICAgIHJldHVybiBkZWZhdWx0TnVtYmVyaW5nU3lzdGVtO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZGVmYXVsdCBudW1iZXJpbmcgc3lzdGVtIHRvIGNyZWF0ZSBEYXRlVGltZXMgd2l0aC4gRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBzZXQgZGVmYXVsdE51bWJlcmluZ1N5c3RlbShudW1iZXJpbmdTeXN0ZW0pIHtcbiAgICBkZWZhdWx0TnVtYmVyaW5nU3lzdGVtID0gbnVtYmVyaW5nU3lzdGVtO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGVmYXVsdCBvdXRwdXQgY2FsZW5kYXIgdG8gY3JlYXRlIERhdGVUaW1lcyB3aXRoLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0T3V0cHV0Q2FsZW5kYXIoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRPdXRwdXRDYWxlbmRhcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGRlZmF1bHQgb3V0cHV0IGNhbGVuZGFyIHRvIGNyZWF0ZSBEYXRlVGltZXMgd2l0aC4gRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBzZXQgZGVmYXVsdE91dHB1dENhbGVuZGFyKG91dHB1dENhbGVuZGFyKSB7XG4gICAgZGVmYXVsdE91dHB1dENhbGVuZGFyID0gb3V0cHV0Q2FsZW5kYXI7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXRvZmYgeWVhciBhZnRlciB3aGljaCBhIHN0cmluZyBlbmNvZGluZyBhIHllYXIgYXMgdHdvIGRpZ2l0cyBpcyBpbnRlcnByZXRlZCB0byBvY2N1ciBpbiB0aGUgY3VycmVudCBjZW50dXJ5LlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgc3RhdGljIGdldCB0d29EaWdpdEN1dG9mZlllYXIoKSB7XG4gICAgcmV0dXJuIHR3b0RpZ2l0Q3V0b2ZmWWVhcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGN1dG9mZiB5ZWFyIGFmdGVyIHdoaWNoIGEgc3RyaW5nIGVuY29kaW5nIGEgeWVhciBhcyB0d28gZGlnaXRzIGlzIGludGVycHJldGVkIHRvIG9jY3VyIGluIHRoZSBjdXJyZW50IGNlbnR1cnkuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBleGFtcGxlIFNldHRpbmdzLnR3b0RpZ2l0Q3V0b2ZmWWVhciA9IDAgLy8gY3V0LW9mZiB5ZWFyIGlzIDAsIHNvIGFsbCAneXknIGFyZSBpbnRlcnByZXRlZCBhcyBjdXJyZW50IGNlbnR1cnlcbiAgICogQGV4YW1wbGUgU2V0dGluZ3MudHdvRGlnaXRDdXRvZmZZZWFyID0gNTAgLy8gJzQ5JyAtPiAxOTQ5OyAnNTAnIC0+IDIwNTBcbiAgICogQGV4YW1wbGUgU2V0dGluZ3MudHdvRGlnaXRDdXRvZmZZZWFyID0gMTk1MCAvLyBpbnRlcnByZXRlZCBhcyA1MFxuICAgKiBAZXhhbXBsZSBTZXR0aW5ncy50d29EaWdpdEN1dG9mZlllYXIgPSAyMDUwIC8vIEFMU08gaW50ZXJwcmV0ZWQgYXMgNTBcbiAgICovXG4gIHN0YXRpYyBzZXQgdHdvRGlnaXRDdXRvZmZZZWFyKGN1dG9mZlllYXIpIHtcbiAgICB0d29EaWdpdEN1dG9mZlllYXIgPSBjdXRvZmZZZWFyICUgMTAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB3aGV0aGVyIEx1eG9uIHdpbGwgdGhyb3cgd2hlbiBpdCBlbmNvdW50ZXJzIGludmFsaWQgRGF0ZVRpbWVzLCBEdXJhdGlvbnMsIG9yIEludGVydmFsc1xuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBnZXQgdGhyb3dPbkludmFsaWQoKSB7XG4gICAgcmV0dXJuIHRocm93T25JbnZhbGlkO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB3aGV0aGVyIEx1eG9uIHdpbGwgdGhyb3cgd2hlbiBpdCBlbmNvdW50ZXJzIGludmFsaWQgRGF0ZVRpbWVzLCBEdXJhdGlvbnMsIG9yIEludGVydmFsc1xuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBzZXQgdGhyb3dPbkludmFsaWQodCkge1xuICAgIHRocm93T25JbnZhbGlkID0gdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCBMdXhvbidzIGdsb2JhbCBjYWNoZXMuIFNob3VsZCBvbmx5IGJlIG5lY2Vzc2FyeSBpbiB0ZXN0aW5nIHNjZW5hcmlvcy5cbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIHN0YXRpYyByZXNldENhY2hlcygpIHtcbiAgICBMb2NhbGUucmVzZXRDYWNoZSgpO1xuICAgIElBTkFab25lLnJlc2V0Q2FjaGUoKTtcbiAgfVxufVxuIiwgIi8qXG4gIFRoaXMgaXMganVzdCBhIGp1bmsgZHJhd2VyLCBjb250YWluaW5nIGFueXRoaW5nIHVzZWQgYWNyb3NzIG11bHRpcGxlIGNsYXNzZXMuXG4gIEJlY2F1c2UgTHV4b24gaXMgc21hbGwoaXNoKSwgdGhpcyBzaG91bGQgc3RheSBzbWFsbCBhbmQgd2Ugd29uJ3Qgd29ycnkgYWJvdXQgc3BsaXR0aW5nXG4gIGl0IHVwIGludG8sIHNheSwgcGFyc2luZ1V0aWwuanMgYW5kIGJhc2ljVXRpbC5qcyBhbmQgc28gb24uIEJ1dCB0aGV5IGFyZSBkaXZpZGVkIHVwIGJ5IGZlYXR1cmUgYXJlYS5cbiovXG5cbmltcG9ydCB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gZnJvbSBcIi4uL2Vycm9ycy5qc1wiO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gXCIuLi9zZXR0aW5ncy5qc1wiO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuLy8gVFlQRVNcblxuZXhwb3J0IGZ1bmN0aW9uIGlzVW5kZWZpbmVkKG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSBcInVuZGVmaW5lZFwiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNOdW1iZXIobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09IFwibnVtYmVyXCI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0ludGVnZXIobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09IFwibnVtYmVyXCIgJiYgbyAlIDEgPT09IDA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZyhvKSB7XG4gIHJldHVybiB0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRGF0ZShvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykgPT09IFwiW29iamVjdCBEYXRlXVwiO1xufVxuXG4vLyBDQVBBQklMSVRJRVNcblxuZXhwb3J0IGZ1bmN0aW9uIGhhc1JlbGF0aXZlKCkge1xuICB0cnkge1xuICAgIHJldHVybiB0eXBlb2YgSW50bCAhPT0gXCJ1bmRlZmluZWRcIiAmJiAhIUludGwuUmVsYXRpdmVUaW1lRm9ybWF0O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8vIE9CSkVDVFMgQU5EIEFSUkFZU1xuXG5leHBvcnQgZnVuY3Rpb24gbWF5YmVBcnJheSh0aGluZykge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh0aGluZykgPyB0aGluZyA6IFt0aGluZ107XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiZXN0QnkoYXJyLCBieSwgY29tcGFyZSkge1xuICBpZiAoYXJyLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIGFyci5yZWR1Y2UoKGJlc3QsIG5leHQpID0+IHtcbiAgICBjb25zdCBwYWlyID0gW2J5KG5leHQpLCBuZXh0XTtcbiAgICBpZiAoIWJlc3QpIHtcbiAgICAgIHJldHVybiBwYWlyO1xuICAgIH0gZWxzZSBpZiAoY29tcGFyZShiZXN0WzBdLCBwYWlyWzBdKSA9PT0gYmVzdFswXSkge1xuICAgICAgcmV0dXJuIGJlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwYWlyO1xuICAgIH1cbiAgfSwgbnVsbClbMV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwaWNrKG9iaiwga2V5cykge1xuICByZXR1cm4ga2V5cy5yZWR1Y2UoKGEsIGspID0+IHtcbiAgICBhW2tdID0gb2JqW2tdO1xuICAgIHJldHVybiBhO1xuICB9LCB7fSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG4vLyBOVU1CRVJTIEFORCBTVFJJTkdTXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnRlZ2VyQmV0d2Vlbih0aGluZywgYm90dG9tLCB0b3ApIHtcbiAgcmV0dXJuIGlzSW50ZWdlcih0aGluZykgJiYgdGhpbmcgPj0gYm90dG9tICYmIHRoaW5nIDw9IHRvcDtcbn1cblxuLy8geCAlIG4gYnV0IHRha2VzIHRoZSBzaWduIG9mIG4gaW5zdGVhZCBvZiB4XG5leHBvcnQgZnVuY3Rpb24gZmxvb3JNb2QoeCwgbikge1xuICByZXR1cm4geCAtIG4gKiBNYXRoLmZsb29yKHggLyBuKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhZFN0YXJ0KGlucHV0LCBuID0gMikge1xuICBjb25zdCBpc05lZyA9IGlucHV0IDwgMDtcbiAgbGV0IHBhZGRlZDtcbiAgaWYgKGlzTmVnKSB7XG4gICAgcGFkZGVkID0gXCItXCIgKyAoXCJcIiArIC1pbnB1dCkucGFkU3RhcnQobiwgXCIwXCIpO1xuICB9IGVsc2Uge1xuICAgIHBhZGRlZCA9IChcIlwiICsgaW5wdXQpLnBhZFN0YXJ0KG4sIFwiMFwiKTtcbiAgfVxuICByZXR1cm4gcGFkZGVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VJbnRlZ2VyKHN0cmluZykge1xuICBpZiAoaXNVbmRlZmluZWQoc3RyaW5nKSB8fCBzdHJpbmcgPT09IG51bGwgfHwgc3RyaW5nID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcGFyc2VJbnQoc3RyaW5nLCAxMCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRmxvYXRpbmcoc3RyaW5nKSB7XG4gIGlmIChpc1VuZGVmaW5lZChzdHJpbmcpIHx8IHN0cmluZyA9PT0gbnVsbCB8fCBzdHJpbmcgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHN0cmluZyk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlTWlsbGlzKGZyYWN0aW9uKSB7XG4gIC8vIFJldHVybiB1bmRlZmluZWQgKGluc3RlYWQgb2YgMCkgaW4gdGhlc2UgY2FzZXMsIHdoZXJlIGZyYWN0aW9uIGlzIG5vdCBzZXRcbiAgaWYgKGlzVW5kZWZpbmVkKGZyYWN0aW9uKSB8fCBmcmFjdGlvbiA9PT0gbnVsbCB8fCBmcmFjdGlvbiA9PT0gXCJcIikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZiA9IHBhcnNlRmxvYXQoXCIwLlwiICsgZnJhY3Rpb24pICogMTAwMDtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihmKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcm91bmRUbyhudW1iZXIsIGRpZ2l0cywgdG93YXJkWmVybyA9IGZhbHNlKSB7XG4gIGNvbnN0IGZhY3RvciA9IDEwICoqIGRpZ2l0cyxcbiAgICByb3VuZGVyID0gdG93YXJkWmVybyA/IE1hdGgudHJ1bmMgOiBNYXRoLnJvdW5kO1xuICByZXR1cm4gcm91bmRlcihudW1iZXIgKiBmYWN0b3IpIC8gZmFjdG9yO1xufVxuXG4vLyBEQVRFIEJBU0lDU1xuXG5leHBvcnQgZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gIHJldHVybiB5ZWFyICUgNCA9PT0gMCAmJiAoeWVhciAlIDEwMCAhPT0gMCB8fCB5ZWFyICUgNDAwID09PSAwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRheXNJblllYXIoeWVhcikge1xuICByZXR1cm4gaXNMZWFwWWVhcih5ZWFyKSA/IDM2NiA6IDM2NTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRheXNJbk1vbnRoKHllYXIsIG1vbnRoKSB7XG4gIGNvbnN0IG1vZE1vbnRoID0gZmxvb3JNb2QobW9udGggLSAxLCAxMikgKyAxLFxuICAgIG1vZFllYXIgPSB5ZWFyICsgKG1vbnRoIC0gbW9kTW9udGgpIC8gMTI7XG5cbiAgaWYgKG1vZE1vbnRoID09PSAyKSB7XG4gICAgcmV0dXJuIGlzTGVhcFllYXIobW9kWWVhcikgPyAyOSA6IDI4O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbMzEsIG51bGwsIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXVttb2RNb250aCAtIDFdO1xuICB9XG59XG5cbi8vIGNvbnZlcnQgYSBjYWxlbmRhciBvYmplY3QgdG8gYSBsb2NhbCB0aW1lc3RhbXAgKGVwb2NoLCBidXQgd2l0aCB0aGUgb2Zmc2V0IGJha2VkIGluKVxuZXhwb3J0IGZ1bmN0aW9uIG9ialRvTG9jYWxUUyhvYmopIHtcbiAgbGV0IGQgPSBEYXRlLlVUQyhcbiAgICBvYmoueWVhcixcbiAgICBvYmoubW9udGggLSAxLFxuICAgIG9iai5kYXksXG4gICAgb2JqLmhvdXIsXG4gICAgb2JqLm1pbnV0ZSxcbiAgICBvYmouc2Vjb25kLFxuICAgIG9iai5taWxsaXNlY29uZFxuICApO1xuXG4gIC8vIGZvciBsZWdhY3kgcmVhc29ucywgeWVhcnMgYmV0d2VlbiAwIGFuZCA5OSBhcmUgaW50ZXJwcmV0ZWQgYXMgMTlYWDsgcmV2ZXJ0IHRoYXRcbiAgaWYgKG9iai55ZWFyIDwgMTAwICYmIG9iai55ZWFyID49IDApIHtcbiAgICBkID0gbmV3IERhdGUoZCk7XG4gICAgLy8gc2V0IHRoZSBtb250aCBhbmQgZGF5IGFnYWluLCB0aGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHllYXIgMjAwMCBpcyBhIGxlYXAgeWVhciwgYnV0IHllYXIgMTAwIGlzIG5vdFxuICAgIC8vIHNvIGlmIG9iai55ZWFyIGlzIGluIDk5LCBidXQgb2JqLmRheSBtYWtlcyBpdCByb2xsIG92ZXIgaW50byB5ZWFyIDEwMCxcbiAgICAvLyB0aGUgY2FsY3VsYXRpb25zIGRvbmUgYnkgRGF0ZS5VVEMgYXJlIHVzaW5nIHllYXIgMjAwMCAtIHdoaWNoIGlzIGluY29ycmVjdFxuICAgIGQuc2V0VVRDRnVsbFllYXIob2JqLnllYXIsIG9iai5tb250aCAtIDEsIG9iai5kYXkpO1xuICB9XG4gIHJldHVybiArZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdlZWtzSW5XZWVrWWVhcih3ZWVrWWVhcikge1xuICBjb25zdCBwMSA9XG4gICAgICAod2Vla1llYXIgK1xuICAgICAgICBNYXRoLmZsb29yKHdlZWtZZWFyIC8gNCkgLVxuICAgICAgICBNYXRoLmZsb29yKHdlZWtZZWFyIC8gMTAwKSArXG4gICAgICAgIE1hdGguZmxvb3Iod2Vla1llYXIgLyA0MDApKSAlXG4gICAgICA3LFxuICAgIGxhc3QgPSB3ZWVrWWVhciAtIDEsXG4gICAgcDIgPSAobGFzdCArIE1hdGguZmxvb3IobGFzdCAvIDQpIC0gTWF0aC5mbG9vcihsYXN0IC8gMTAwKSArIE1hdGguZmxvb3IobGFzdCAvIDQwMCkpICUgNztcbiAgcmV0dXJuIHAxID09PSA0IHx8IHAyID09PSAzID8gNTMgOiA1Mjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVudHJ1bmNhdGVZZWFyKHllYXIpIHtcbiAgaWYgKHllYXIgPiA5OSkge1xuICAgIHJldHVybiB5ZWFyO1xuICB9IGVsc2UgcmV0dXJuIHllYXIgPiBTZXR0aW5ncy50d29EaWdpdEN1dG9mZlllYXIgPyAxOTAwICsgeWVhciA6IDIwMDAgKyB5ZWFyO1xufVxuXG4vLyBQQVJTSU5HXG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVpvbmVJbmZvKHRzLCBvZmZzZXRGb3JtYXQsIGxvY2FsZSwgdGltZVpvbmUgPSBudWxsKSB7XG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh0cyksXG4gICAgaW50bE9wdHMgPSB7XG4gICAgICBob3VyQ3ljbGU6IFwiaDIzXCIsXG4gICAgICB5ZWFyOiBcIm51bWVyaWNcIixcbiAgICAgIG1vbnRoOiBcIjItZGlnaXRcIixcbiAgICAgIGRheTogXCIyLWRpZ2l0XCIsXG4gICAgICBob3VyOiBcIjItZGlnaXRcIixcbiAgICAgIG1pbnV0ZTogXCIyLWRpZ2l0XCIsXG4gICAgfTtcblxuICBpZiAodGltZVpvbmUpIHtcbiAgICBpbnRsT3B0cy50aW1lWm9uZSA9IHRpbWVab25lO1xuICB9XG5cbiAgY29uc3QgbW9kaWZpZWQgPSB7IHRpbWVab25lTmFtZTogb2Zmc2V0Rm9ybWF0LCAuLi5pbnRsT3B0cyB9O1xuXG4gIGNvbnN0IHBhcnNlZCA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSwgbW9kaWZpZWQpXG4gICAgLmZvcm1hdFRvUGFydHMoZGF0ZSlcbiAgICAuZmluZCgobSkgPT4gbS50eXBlLnRvTG93ZXJDYXNlKCkgPT09IFwidGltZXpvbmVuYW1lXCIpO1xuICByZXR1cm4gcGFyc2VkID8gcGFyc2VkLnZhbHVlIDogbnVsbDtcbn1cblxuLy8gc2lnbmVkT2Zmc2V0KCctNScsICczMCcpIC0+IC0zMzBcbmV4cG9ydCBmdW5jdGlvbiBzaWduZWRPZmZzZXQob2ZmSG91clN0ciwgb2ZmTWludXRlU3RyKSB7XG4gIGxldCBvZmZIb3VyID0gcGFyc2VJbnQob2ZmSG91clN0ciwgMTApO1xuXG4gIC8vIGRvbid0IHx8IHRoaXMgYmVjYXVzZSB3ZSB3YW50IHRvIHByZXNlcnZlIC0wXG4gIGlmIChOdW1iZXIuaXNOYU4ob2ZmSG91cikpIHtcbiAgICBvZmZIb3VyID0gMDtcbiAgfVxuXG4gIGNvbnN0IG9mZk1pbiA9IHBhcnNlSW50KG9mZk1pbnV0ZVN0ciwgMTApIHx8IDAsXG4gICAgb2ZmTWluU2lnbmVkID0gb2ZmSG91ciA8IDAgfHwgT2JqZWN0LmlzKG9mZkhvdXIsIC0wKSA/IC1vZmZNaW4gOiBvZmZNaW47XG4gIHJldHVybiBvZmZIb3VyICogNjAgKyBvZmZNaW5TaWduZWQ7XG59XG5cbi8vIENPRVJDSU9OXG5cbmV4cG9ydCBmdW5jdGlvbiBhc051bWJlcih2YWx1ZSkge1xuICBjb25zdCBudW1lcmljVmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIiB8fCB2YWx1ZSA9PT0gXCJcIiB8fCBOdW1iZXIuaXNOYU4obnVtZXJpY1ZhbHVlKSlcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoYEludmFsaWQgdW5pdCB2YWx1ZSAke3ZhbHVlfWApO1xuICByZXR1cm4gbnVtZXJpY1ZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplT2JqZWN0KG9iaiwgbm9ybWFsaXplcikge1xuICBjb25zdCBub3JtYWxpemVkID0ge307XG4gIGZvciAoY29uc3QgdSBpbiBvYmopIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkob2JqLCB1KSkge1xuICAgICAgY29uc3QgdiA9IG9ialt1XTtcbiAgICAgIGlmICh2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gbnVsbCkgY29udGludWU7XG4gICAgICBub3JtYWxpemVkW25vcm1hbGl6ZXIodSldID0gYXNOdW1iZXIodik7XG4gICAgfVxuICB9XG4gIHJldHVybiBub3JtYWxpemVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0T2Zmc2V0KG9mZnNldCwgZm9ybWF0KSB7XG4gIGNvbnN0IGhvdXJzID0gTWF0aC50cnVuYyhNYXRoLmFicyhvZmZzZXQgLyA2MCkpLFxuICAgIG1pbnV0ZXMgPSBNYXRoLnRydW5jKE1hdGguYWJzKG9mZnNldCAlIDYwKSksXG4gICAgc2lnbiA9IG9mZnNldCA+PSAwID8gXCIrXCIgOiBcIi1cIjtcblxuICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgIGNhc2UgXCJzaG9ydFwiOlxuICAgICAgcmV0dXJuIGAke3NpZ259JHtwYWRTdGFydChob3VycywgMil9OiR7cGFkU3RhcnQobWludXRlcywgMil9YDtcbiAgICBjYXNlIFwibmFycm93XCI6XG4gICAgICByZXR1cm4gYCR7c2lnbn0ke2hvdXJzfSR7bWludXRlcyA+IDAgPyBgOiR7bWludXRlc31gIDogXCJcIn1gO1xuICAgIGNhc2UgXCJ0ZWNoaWVcIjpcbiAgICAgIHJldHVybiBgJHtzaWdufSR7cGFkU3RhcnQoaG91cnMsIDIpfSR7cGFkU3RhcnQobWludXRlcywgMil9YDtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFZhbHVlIGZvcm1hdCAke2Zvcm1hdH0gaXMgb3V0IG9mIHJhbmdlIGZvciBwcm9wZXJ0eSBmb3JtYXRgKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdGltZU9iamVjdChvYmopIHtcbiAgcmV0dXJuIHBpY2sob2JqLCBbXCJob3VyXCIsIFwibWludXRlXCIsIFwic2Vjb25kXCIsIFwibWlsbGlzZWNvbmRcIl0pO1xufVxuIiwgImltcG9ydCAqIGFzIEZvcm1hdHMgZnJvbSBcIi4vZm9ybWF0cy5qc1wiO1xuaW1wb3J0IHsgcGljayB9IGZyb20gXCIuL3V0aWwuanNcIjtcblxuZnVuY3Rpb24gc3RyaW5naWZ5KG9iaikge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqLCBPYmplY3Qua2V5cyhvYmopLnNvcnQoKSk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5leHBvcnQgY29uc3QgbW9udGhzTG9uZyA9IFtcbiAgXCJKYW51YXJ5XCIsXG4gIFwiRmVicnVhcnlcIixcbiAgXCJNYXJjaFwiLFxuICBcIkFwcmlsXCIsXG4gIFwiTWF5XCIsXG4gIFwiSnVuZVwiLFxuICBcIkp1bHlcIixcbiAgXCJBdWd1c3RcIixcbiAgXCJTZXB0ZW1iZXJcIixcbiAgXCJPY3RvYmVyXCIsXG4gIFwiTm92ZW1iZXJcIixcbiAgXCJEZWNlbWJlclwiLFxuXTtcblxuZXhwb3J0IGNvbnN0IG1vbnRoc1Nob3J0ID0gW1xuICBcIkphblwiLFxuICBcIkZlYlwiLFxuICBcIk1hclwiLFxuICBcIkFwclwiLFxuICBcIk1heVwiLFxuICBcIkp1blwiLFxuICBcIkp1bFwiLFxuICBcIkF1Z1wiLFxuICBcIlNlcFwiLFxuICBcIk9jdFwiLFxuICBcIk5vdlwiLFxuICBcIkRlY1wiLFxuXTtcblxuZXhwb3J0IGNvbnN0IG1vbnRoc05hcnJvdyA9IFtcIkpcIiwgXCJGXCIsIFwiTVwiLCBcIkFcIiwgXCJNXCIsIFwiSlwiLCBcIkpcIiwgXCJBXCIsIFwiU1wiLCBcIk9cIiwgXCJOXCIsIFwiRFwiXTtcblxuZXhwb3J0IGZ1bmN0aW9uIG1vbnRocyhsZW5ndGgpIHtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIFwibmFycm93XCI6XG4gICAgICByZXR1cm4gWy4uLm1vbnRoc05hcnJvd107XG4gICAgY2FzZSBcInNob3J0XCI6XG4gICAgICByZXR1cm4gWy4uLm1vbnRoc1Nob3J0XTtcbiAgICBjYXNlIFwibG9uZ1wiOlxuICAgICAgcmV0dXJuIFsuLi5tb250aHNMb25nXTtcbiAgICBjYXNlIFwibnVtZXJpY1wiOlxuICAgICAgcmV0dXJuIFtcIjFcIiwgXCIyXCIsIFwiM1wiLCBcIjRcIiwgXCI1XCIsIFwiNlwiLCBcIjdcIiwgXCI4XCIsIFwiOVwiLCBcIjEwXCIsIFwiMTFcIiwgXCIxMlwiXTtcbiAgICBjYXNlIFwiMi1kaWdpdFwiOlxuICAgICAgcmV0dXJuIFtcIjAxXCIsIFwiMDJcIiwgXCIwM1wiLCBcIjA0XCIsIFwiMDVcIiwgXCIwNlwiLCBcIjA3XCIsIFwiMDhcIiwgXCIwOVwiLCBcIjEwXCIsIFwiMTFcIiwgXCIxMlwiXTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHdlZWtkYXlzTG9uZyA9IFtcbiAgXCJNb25kYXlcIixcbiAgXCJUdWVzZGF5XCIsXG4gIFwiV2VkbmVzZGF5XCIsXG4gIFwiVGh1cnNkYXlcIixcbiAgXCJGcmlkYXlcIixcbiAgXCJTYXR1cmRheVwiLFxuICBcIlN1bmRheVwiLFxuXTtcblxuZXhwb3J0IGNvbnN0IHdlZWtkYXlzU2hvcnQgPSBbXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIiwgXCJTdW5cIl07XG5cbmV4cG9ydCBjb25zdCB3ZWVrZGF5c05hcnJvdyA9IFtcIk1cIiwgXCJUXCIsIFwiV1wiLCBcIlRcIiwgXCJGXCIsIFwiU1wiLCBcIlNcIl07XG5cbmV4cG9ydCBmdW5jdGlvbiB3ZWVrZGF5cyhsZW5ndGgpIHtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIFwibmFycm93XCI6XG4gICAgICByZXR1cm4gWy4uLndlZWtkYXlzTmFycm93XTtcbiAgICBjYXNlIFwic2hvcnRcIjpcbiAgICAgIHJldHVybiBbLi4ud2Vla2RheXNTaG9ydF07XG4gICAgY2FzZSBcImxvbmdcIjpcbiAgICAgIHJldHVybiBbLi4ud2Vla2RheXNMb25nXTtcbiAgICBjYXNlIFwibnVtZXJpY1wiOlxuICAgICAgcmV0dXJuIFtcIjFcIiwgXCIyXCIsIFwiM1wiLCBcIjRcIiwgXCI1XCIsIFwiNlwiLCBcIjdcIl07XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBtZXJpZGllbXMgPSBbXCJBTVwiLCBcIlBNXCJdO1xuXG5leHBvcnQgY29uc3QgZXJhc0xvbmcgPSBbXCJCZWZvcmUgQ2hyaXN0XCIsIFwiQW5ubyBEb21pbmlcIl07XG5cbmV4cG9ydCBjb25zdCBlcmFzU2hvcnQgPSBbXCJCQ1wiLCBcIkFEXCJdO1xuXG5leHBvcnQgY29uc3QgZXJhc05hcnJvdyA9IFtcIkJcIiwgXCJBXCJdO1xuXG5leHBvcnQgZnVuY3Rpb24gZXJhcyhsZW5ndGgpIHtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIFwibmFycm93XCI6XG4gICAgICByZXR1cm4gWy4uLmVyYXNOYXJyb3ddO1xuICAgIGNhc2UgXCJzaG9ydFwiOlxuICAgICAgcmV0dXJuIFsuLi5lcmFzU2hvcnRdO1xuICAgIGNhc2UgXCJsb25nXCI6XG4gICAgICByZXR1cm4gWy4uLmVyYXNMb25nXTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmlkaWVtRm9yRGF0ZVRpbWUoZHQpIHtcbiAgcmV0dXJuIG1lcmlkaWVtc1tkdC5ob3VyIDwgMTIgPyAwIDogMV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3ZWVrZGF5Rm9yRGF0ZVRpbWUoZHQsIGxlbmd0aCkge1xuICByZXR1cm4gd2Vla2RheXMobGVuZ3RoKVtkdC53ZWVrZGF5IC0gMV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtb250aEZvckRhdGVUaW1lKGR0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIG1vbnRocyhsZW5ndGgpW2R0Lm1vbnRoIC0gMV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlcmFGb3JEYXRlVGltZShkdCwgbGVuZ3RoKSB7XG4gIHJldHVybiBlcmFzKGxlbmd0aClbZHQueWVhciA8IDAgPyAwIDogMV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRSZWxhdGl2ZVRpbWUodW5pdCwgY291bnQsIG51bWVyaWMgPSBcImFsd2F5c1wiLCBuYXJyb3cgPSBmYWxzZSkge1xuICBjb25zdCB1bml0cyA9IHtcbiAgICB5ZWFyczogW1wieWVhclwiLCBcInlyLlwiXSxcbiAgICBxdWFydGVyczogW1wicXVhcnRlclwiLCBcInF0ci5cIl0sXG4gICAgbW9udGhzOiBbXCJtb250aFwiLCBcIm1vLlwiXSxcbiAgICB3ZWVrczogW1wid2Vla1wiLCBcIndrLlwiXSxcbiAgICBkYXlzOiBbXCJkYXlcIiwgXCJkYXlcIiwgXCJkYXlzXCJdLFxuICAgIGhvdXJzOiBbXCJob3VyXCIsIFwiaHIuXCJdLFxuICAgIG1pbnV0ZXM6IFtcIm1pbnV0ZVwiLCBcIm1pbi5cIl0sXG4gICAgc2Vjb25kczogW1wic2Vjb25kXCIsIFwic2VjLlwiXSxcbiAgfTtcblxuICBjb25zdCBsYXN0YWJsZSA9IFtcImhvdXJzXCIsIFwibWludXRlc1wiLCBcInNlY29uZHNcIl0uaW5kZXhPZih1bml0KSA9PT0gLTE7XG5cbiAgaWYgKG51bWVyaWMgPT09IFwiYXV0b1wiICYmIGxhc3RhYmxlKSB7XG4gICAgY29uc3QgaXNEYXkgPSB1bml0ID09PSBcImRheXNcIjtcbiAgICBzd2l0Y2ggKGNvdW50KSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBpc0RheSA/IFwidG9tb3Jyb3dcIiA6IGBuZXh0ICR7dW5pdHNbdW5pdF1bMF19YDtcbiAgICAgIGNhc2UgLTE6XG4gICAgICAgIHJldHVybiBpc0RheSA/IFwieWVzdGVyZGF5XCIgOiBgbGFzdCAke3VuaXRzW3VuaXRdWzBdfWA7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiBpc0RheSA/IFwidG9kYXlcIiA6IGB0aGlzICR7dW5pdHNbdW5pdF1bMF19YDtcbiAgICAgIGRlZmF1bHQ6IC8vIGZhbGwgdGhyb3VnaFxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGlzSW5QYXN0ID0gT2JqZWN0LmlzKGNvdW50LCAtMCkgfHwgY291bnQgPCAwLFxuICAgIGZtdFZhbHVlID0gTWF0aC5hYnMoY291bnQpLFxuICAgIHNpbmd1bGFyID0gZm10VmFsdWUgPT09IDEsXG4gICAgbGlsVW5pdHMgPSB1bml0c1t1bml0XSxcbiAgICBmbXRVbml0ID0gbmFycm93XG4gICAgICA/IHNpbmd1bGFyXG4gICAgICAgID8gbGlsVW5pdHNbMV1cbiAgICAgICAgOiBsaWxVbml0c1syXSB8fCBsaWxVbml0c1sxXVxuICAgICAgOiBzaW5ndWxhclxuICAgICAgPyB1bml0c1t1bml0XVswXVxuICAgICAgOiB1bml0O1xuICByZXR1cm4gaXNJblBhc3QgPyBgJHtmbXRWYWx1ZX0gJHtmbXRVbml0fSBhZ29gIDogYGluICR7Zm10VmFsdWV9ICR7Zm10VW5pdH1gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0U3RyaW5nKGtub3duRm9ybWF0KSB7XG4gIC8vIHRoZXNlIGFsbCBoYXZlIHRoZSBvZmZzZXRzIHJlbW92ZWQgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIGFjY2VzcyB0byB0aGVtXG4gIC8vIHdpdGhvdXQgYWxsIHRoZSBpbnRsIHN0dWZmIHRoaXMgaXMgYmFja2ZpbGxpbmdcbiAgY29uc3QgZmlsdGVyZWQgPSBwaWNrKGtub3duRm9ybWF0LCBbXG4gICAgICBcIndlZWtkYXlcIixcbiAgICAgIFwiZXJhXCIsXG4gICAgICBcInllYXJcIixcbiAgICAgIFwibW9udGhcIixcbiAgICAgIFwiZGF5XCIsXG4gICAgICBcImhvdXJcIixcbiAgICAgIFwibWludXRlXCIsXG4gICAgICBcInNlY29uZFwiLFxuICAgICAgXCJ0aW1lWm9uZU5hbWVcIixcbiAgICAgIFwiaG91ckN5Y2xlXCIsXG4gICAgXSksXG4gICAga2V5ID0gc3RyaW5naWZ5KGZpbHRlcmVkKSxcbiAgICBkYXRlVGltZUh1Z2UgPSBcIkVFRUUsIExMTEwgZCwgeXl5eSwgaDptbSBhXCI7XG4gIHN3aXRjaCAoa2V5KSB7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFX1NIT1JUKTpcbiAgICAgIHJldHVybiBcIk0vZC95eXl5XCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFX01FRCk6XG4gICAgICByZXR1cm4gXCJMTEwgZCwgeXl5eVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURV9NRURfV0lUSF9XRUVLREFZKTpcbiAgICAgIHJldHVybiBcIkVFRSwgTExMIGQsIHl5eXlcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVfRlVMTCk6XG4gICAgICByZXR1cm4gXCJMTExMIGQsIHl5eXlcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVfSFVHRSk6XG4gICAgICByZXR1cm4gXCJFRUVFLCBMTExMIGQsIHl5eXlcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLlRJTUVfU0lNUExFKTpcbiAgICAgIHJldHVybiBcImg6bW0gYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuVElNRV9XSVRIX1NFQ09ORFMpOlxuICAgICAgcmV0dXJuIFwiaDptbTpzcyBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5USU1FX1dJVEhfU0hPUlRfT0ZGU0VUKTpcbiAgICAgIHJldHVybiBcImg6bW0gYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuVElNRV9XSVRIX0xPTkdfT0ZGU0VUKTpcbiAgICAgIHJldHVybiBcImg6bW0gYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuVElNRV8yNF9TSU1QTEUpOlxuICAgICAgcmV0dXJuIFwiSEg6bW1cIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLlRJTUVfMjRfV0lUSF9TRUNPTkRTKTpcbiAgICAgIHJldHVybiBcIkhIOm1tOnNzXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5USU1FXzI0X1dJVEhfU0hPUlRfT0ZGU0VUKTpcbiAgICAgIHJldHVybiBcIkhIOm1tXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5USU1FXzI0X1dJVEhfTE9OR19PRkZTRVQpOlxuICAgICAgcmV0dXJuIFwiSEg6bW1cIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX1NIT1JUKTpcbiAgICAgIHJldHVybiBcIk0vZC95eXl5LCBoOm1tIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX01FRCk6XG4gICAgICByZXR1cm4gXCJMTEwgZCwgeXl5eSwgaDptbSBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9GVUxMKTpcbiAgICAgIHJldHVybiBcIkxMTEwgZCwgeXl5eSwgaDptbSBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9IVUdFKTpcbiAgICAgIHJldHVybiBkYXRlVGltZUh1Z2U7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9TSE9SVF9XSVRIX1NFQ09ORFMpOlxuICAgICAgcmV0dXJuIFwiTS9kL3l5eXksIGg6bW06c3MgYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfTUVEX1dJVEhfU0VDT05EUyk6XG4gICAgICByZXR1cm4gXCJMTEwgZCwgeXl5eSwgaDptbTpzcyBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9NRURfV0lUSF9XRUVLREFZKTpcbiAgICAgIHJldHVybiBcIkVFRSwgZCBMTEwgeXl5eSwgaDptbSBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9GVUxMX1dJVEhfU0VDT05EUyk6XG4gICAgICByZXR1cm4gXCJMTExMIGQsIHl5eXksIGg6bW06c3MgYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfSFVHRV9XSVRIX1NFQ09ORFMpOlxuICAgICAgcmV0dXJuIFwiRUVFRSwgTExMTCBkLCB5eXl5LCBoOm1tOnNzIGFcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGRhdGVUaW1lSHVnZTtcbiAgfVxufVxuIiwgImltcG9ydCAqIGFzIEVuZ2xpc2ggZnJvbSBcIi4vZW5nbGlzaC5qc1wiO1xuaW1wb3J0ICogYXMgRm9ybWF0cyBmcm9tIFwiLi9mb3JtYXRzLmpzXCI7XG5pbXBvcnQgeyBwYWRTdGFydCB9IGZyb20gXCIuL3V0aWwuanNcIjtcblxuZnVuY3Rpb24gc3RyaW5naWZ5VG9rZW5zKHNwbGl0cywgdG9rZW5Ub1N0cmluZykge1xuICBsZXQgcyA9IFwiXCI7XG4gIGZvciAoY29uc3QgdG9rZW4gb2Ygc3BsaXRzKSB7XG4gICAgaWYgKHRva2VuLmxpdGVyYWwpIHtcbiAgICAgIHMgKz0gdG9rZW4udmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzICs9IHRva2VuVG9TdHJpbmcodG9rZW4udmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHM7XG59XG5cbmNvbnN0IG1hY3JvVG9rZW5Ub0Zvcm1hdE9wdHMgPSB7XG4gIEQ6IEZvcm1hdHMuREFURV9TSE9SVCxcbiAgREQ6IEZvcm1hdHMuREFURV9NRUQsXG4gIERERDogRm9ybWF0cy5EQVRFX0ZVTEwsXG4gIEREREQ6IEZvcm1hdHMuREFURV9IVUdFLFxuICB0OiBGb3JtYXRzLlRJTUVfU0lNUExFLFxuICB0dDogRm9ybWF0cy5USU1FX1dJVEhfU0VDT05EUyxcbiAgdHR0OiBGb3JtYXRzLlRJTUVfV0lUSF9TSE9SVF9PRkZTRVQsXG4gIHR0dHQ6IEZvcm1hdHMuVElNRV9XSVRIX0xPTkdfT0ZGU0VULFxuICBUOiBGb3JtYXRzLlRJTUVfMjRfU0lNUExFLFxuICBUVDogRm9ybWF0cy5USU1FXzI0X1dJVEhfU0VDT05EUyxcbiAgVFRUOiBGb3JtYXRzLlRJTUVfMjRfV0lUSF9TSE9SVF9PRkZTRVQsXG4gIFRUVFQ6IEZvcm1hdHMuVElNRV8yNF9XSVRIX0xPTkdfT0ZGU0VULFxuICBmOiBGb3JtYXRzLkRBVEVUSU1FX1NIT1JULFxuICBmZjogRm9ybWF0cy5EQVRFVElNRV9NRUQsXG4gIGZmZjogRm9ybWF0cy5EQVRFVElNRV9GVUxMLFxuICBmZmZmOiBGb3JtYXRzLkRBVEVUSU1FX0hVR0UsXG4gIEY6IEZvcm1hdHMuREFURVRJTUVfU0hPUlRfV0lUSF9TRUNPTkRTLFxuICBGRjogRm9ybWF0cy5EQVRFVElNRV9NRURfV0lUSF9TRUNPTkRTLFxuICBGRkY6IEZvcm1hdHMuREFURVRJTUVfRlVMTF9XSVRIX1NFQ09ORFMsXG4gIEZGRkY6IEZvcm1hdHMuREFURVRJTUVfSFVHRV9XSVRIX1NFQ09ORFMsXG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRm9ybWF0dGVyIHtcbiAgc3RhdGljIGNyZWF0ZShsb2NhbGUsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgRm9ybWF0dGVyKGxvY2FsZSwgb3B0cyk7XG4gIH1cblxuICBzdGF0aWMgcGFyc2VGb3JtYXQoZm10KSB7XG4gICAgLy8gd2hpdGUtc3BhY2UgaXMgYWx3YXlzIGNvbnNpZGVyZWQgYSBsaXRlcmFsIGluIHVzZXItcHJvdmlkZWQgZm9ybWF0c1xuICAgIC8vIHRoZSBcIiBcIiB0b2tlbiBoYXMgYSBzcGVjaWFsIG1lYW5pbmcgKHNlZSB1bml0Rm9yVG9rZW4pXG5cbiAgICBsZXQgY3VycmVudCA9IG51bGwsXG4gICAgICBjdXJyZW50RnVsbCA9IFwiXCIsXG4gICAgICBicmFja2V0ZWQgPSBmYWxzZTtcbiAgICBjb25zdCBzcGxpdHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZtdC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYyA9IGZtdC5jaGFyQXQoaSk7XG4gICAgICBpZiAoYyA9PT0gXCInXCIpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRGdWxsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzcGxpdHMucHVzaCh7IGxpdGVyYWw6IGJyYWNrZXRlZCB8fCAvXlxccyskLy50ZXN0KGN1cnJlbnRGdWxsKSwgdmFsOiBjdXJyZW50RnVsbCB9KTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gbnVsbDtcbiAgICAgICAgY3VycmVudEZ1bGwgPSBcIlwiO1xuICAgICAgICBicmFja2V0ZWQgPSAhYnJhY2tldGVkO1xuICAgICAgfSBlbHNlIGlmIChicmFja2V0ZWQpIHtcbiAgICAgICAgY3VycmVudEZ1bGwgKz0gYztcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gY3VycmVudCkge1xuICAgICAgICBjdXJyZW50RnVsbCArPSBjO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGN1cnJlbnRGdWxsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzcGxpdHMucHVzaCh7IGxpdGVyYWw6IC9eXFxzKyQvLnRlc3QoY3VycmVudEZ1bGwpLCB2YWw6IGN1cnJlbnRGdWxsIH0pO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRGdWxsID0gYztcbiAgICAgICAgY3VycmVudCA9IGM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRGdWxsLmxlbmd0aCA+IDApIHtcbiAgICAgIHNwbGl0cy5wdXNoKHsgbGl0ZXJhbDogYnJhY2tldGVkIHx8IC9eXFxzKyQvLnRlc3QoY3VycmVudEZ1bGwpLCB2YWw6IGN1cnJlbnRGdWxsIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBzcGxpdHM7XG4gIH1cblxuICBzdGF0aWMgbWFjcm9Ub2tlblRvRm9ybWF0T3B0cyh0b2tlbikge1xuICAgIHJldHVybiBtYWNyb1Rva2VuVG9Gb3JtYXRPcHRzW3Rva2VuXTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGxvY2FsZSwgZm9ybWF0T3B0cykge1xuICAgIHRoaXMub3B0cyA9IGZvcm1hdE9wdHM7XG4gICAgdGhpcy5sb2MgPSBsb2NhbGU7XG4gICAgdGhpcy5zeXN0ZW1Mb2MgPSBudWxsO1xuICB9XG5cbiAgZm9ybWF0V2l0aFN5c3RlbURlZmF1bHQoZHQsIG9wdHMpIHtcbiAgICBpZiAodGhpcy5zeXN0ZW1Mb2MgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuc3lzdGVtTG9jID0gdGhpcy5sb2MucmVkZWZhdWx0VG9TeXN0ZW0oKTtcbiAgICB9XG4gICAgY29uc3QgZGYgPSB0aGlzLnN5c3RlbUxvYy5kdEZvcm1hdHRlcihkdCwgeyAuLi50aGlzLm9wdHMsIC4uLm9wdHMgfSk7XG4gICAgcmV0dXJuIGRmLmZvcm1hdCgpO1xuICB9XG5cbiAgZHRGb3JtYXR0ZXIoZHQsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmxvYy5kdEZvcm1hdHRlcihkdCwgeyAuLi50aGlzLm9wdHMsIC4uLm9wdHMgfSk7XG4gIH1cblxuICBmb3JtYXREYXRlVGltZShkdCwgb3B0cykge1xuICAgIHJldHVybiB0aGlzLmR0Rm9ybWF0dGVyKGR0LCBvcHRzKS5mb3JtYXQoKTtcbiAgfVxuXG4gIGZvcm1hdERhdGVUaW1lUGFydHMoZHQsIG9wdHMpIHtcbiAgICByZXR1cm4gdGhpcy5kdEZvcm1hdHRlcihkdCwgb3B0cykuZm9ybWF0VG9QYXJ0cygpO1xuICB9XG5cbiAgZm9ybWF0SW50ZXJ2YWwoaW50ZXJ2YWwsIG9wdHMpIHtcbiAgICBjb25zdCBkZiA9IHRoaXMuZHRGb3JtYXR0ZXIoaW50ZXJ2YWwuc3RhcnQsIG9wdHMpO1xuICAgIHJldHVybiBkZi5kdGYuZm9ybWF0UmFuZ2UoaW50ZXJ2YWwuc3RhcnQudG9KU0RhdGUoKSwgaW50ZXJ2YWwuZW5kLnRvSlNEYXRlKCkpO1xuICB9XG5cbiAgcmVzb2x2ZWRPcHRpb25zKGR0LCBvcHRzKSB7XG4gICAgcmV0dXJuIHRoaXMuZHRGb3JtYXR0ZXIoZHQsIG9wdHMpLnJlc29sdmVkT3B0aW9ucygpO1xuICB9XG5cbiAgbnVtKG4sIHAgPSAwKSB7XG4gICAgLy8gd2UgZ2V0IHNvbWUgcGVyZiBvdXQgb2YgZG9pbmcgdGhpcyBoZXJlLCBhbm5veWluZ2x5XG4gICAgaWYgKHRoaXMub3B0cy5mb3JjZVNpbXBsZSkge1xuICAgICAgcmV0dXJuIHBhZFN0YXJ0KG4sIHApO1xuICAgIH1cblxuICAgIGNvbnN0IG9wdHMgPSB7IC4uLnRoaXMub3B0cyB9O1xuXG4gICAgaWYgKHAgPiAwKSB7XG4gICAgICBvcHRzLnBhZFRvID0gcDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5sb2MubnVtYmVyRm9ybWF0dGVyKG9wdHMpLmZvcm1hdChuKTtcbiAgfVxuXG4gIGZvcm1hdERhdGVUaW1lRnJvbVN0cmluZyhkdCwgZm10KSB7XG4gICAgY29uc3Qga25vd25FbmdsaXNoID0gdGhpcy5sb2MubGlzdGluZ01vZGUoKSA9PT0gXCJlblwiLFxuICAgICAgdXNlRGF0ZVRpbWVGb3JtYXR0ZXIgPSB0aGlzLmxvYy5vdXRwdXRDYWxlbmRhciAmJiB0aGlzLmxvYy5vdXRwdXRDYWxlbmRhciAhPT0gXCJncmVnb3J5XCIsXG4gICAgICBzdHJpbmcgPSAob3B0cywgZXh0cmFjdCkgPT4gdGhpcy5sb2MuZXh0cmFjdChkdCwgb3B0cywgZXh0cmFjdCksXG4gICAgICBmb3JtYXRPZmZzZXQgPSAob3B0cykgPT4ge1xuICAgICAgICBpZiAoZHQuaXNPZmZzZXRGaXhlZCAmJiBkdC5vZmZzZXQgPT09IDAgJiYgb3B0cy5hbGxvd1opIHtcbiAgICAgICAgICByZXR1cm4gXCJaXCI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZHQuaXNWYWxpZCA/IGR0LnpvbmUuZm9ybWF0T2Zmc2V0KGR0LnRzLCBvcHRzLmZvcm1hdCkgOiBcIlwiO1xuICAgICAgfSxcbiAgICAgIG1lcmlkaWVtID0gKCkgPT5cbiAgICAgICAga25vd25FbmdsaXNoXG4gICAgICAgICAgPyBFbmdsaXNoLm1lcmlkaWVtRm9yRGF0ZVRpbWUoZHQpXG4gICAgICAgICAgOiBzdHJpbmcoeyBob3VyOiBcIm51bWVyaWNcIiwgaG91ckN5Y2xlOiBcImgxMlwiIH0sIFwiZGF5cGVyaW9kXCIpLFxuICAgICAgbW9udGggPSAobGVuZ3RoLCBzdGFuZGFsb25lKSA9PlxuICAgICAgICBrbm93bkVuZ2xpc2hcbiAgICAgICAgICA/IEVuZ2xpc2gubW9udGhGb3JEYXRlVGltZShkdCwgbGVuZ3RoKVxuICAgICAgICAgIDogc3RyaW5nKHN0YW5kYWxvbmUgPyB7IG1vbnRoOiBsZW5ndGggfSA6IHsgbW9udGg6IGxlbmd0aCwgZGF5OiBcIm51bWVyaWNcIiB9LCBcIm1vbnRoXCIpLFxuICAgICAgd2Vla2RheSA9IChsZW5ndGgsIHN0YW5kYWxvbmUpID0+XG4gICAgICAgIGtub3duRW5nbGlzaFxuICAgICAgICAgID8gRW5nbGlzaC53ZWVrZGF5Rm9yRGF0ZVRpbWUoZHQsIGxlbmd0aClcbiAgICAgICAgICA6IHN0cmluZyhcbiAgICAgICAgICAgICAgc3RhbmRhbG9uZSA/IHsgd2Vla2RheTogbGVuZ3RoIH0gOiB7IHdlZWtkYXk6IGxlbmd0aCwgbW9udGg6IFwibG9uZ1wiLCBkYXk6IFwibnVtZXJpY1wiIH0sXG4gICAgICAgICAgICAgIFwid2Vla2RheVwiXG4gICAgICAgICAgICApLFxuICAgICAgbWF5YmVNYWNybyA9ICh0b2tlbikgPT4ge1xuICAgICAgICBjb25zdCBmb3JtYXRPcHRzID0gRm9ybWF0dGVyLm1hY3JvVG9rZW5Ub0Zvcm1hdE9wdHModG9rZW4pO1xuICAgICAgICBpZiAoZm9ybWF0T3B0cykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdFdpdGhTeXN0ZW1EZWZhdWx0KGR0LCBmb3JtYXRPcHRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBlcmEgPSAobGVuZ3RoKSA9PlxuICAgICAgICBrbm93bkVuZ2xpc2ggPyBFbmdsaXNoLmVyYUZvckRhdGVUaW1lKGR0LCBsZW5ndGgpIDogc3RyaW5nKHsgZXJhOiBsZW5ndGggfSwgXCJlcmFcIiksXG4gICAgICB0b2tlblRvU3RyaW5nID0gKHRva2VuKSA9PiB7XG4gICAgICAgIC8vIFdoZXJlIHBvc3NpYmxlOiBodHRwczovL2NsZHIudW5pY29kZS5vcmcvdHJhbnNsYXRpb24vZGF0ZS10aW1lL2RhdGUtdGltZS1zeW1ib2xzXG4gICAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgICAvLyBtc1xuICAgICAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQubWlsbGlzZWNvbmQpO1xuICAgICAgICAgIGNhc2UgXCJ1XCI6XG4gICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICAgIGNhc2UgXCJTU1NcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5taWxsaXNlY29uZCwgMyk7XG4gICAgICAgICAgLy8gc2Vjb25kc1xuICAgICAgICAgIGNhc2UgXCJzXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQuc2Vjb25kKTtcbiAgICAgICAgICBjYXNlIFwic3NcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5zZWNvbmQsIDIpO1xuICAgICAgICAgIC8vIGZyYWN0aW9uYWwgc2Vjb25kc1xuICAgICAgICAgIGNhc2UgXCJ1dVwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKE1hdGguZmxvb3IoZHQubWlsbGlzZWNvbmQgLyAxMCksIDIpO1xuICAgICAgICAgIGNhc2UgXCJ1dXVcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShNYXRoLmZsb29yKGR0Lm1pbGxpc2Vjb25kIC8gMTAwKSk7XG4gICAgICAgICAgLy8gbWludXRlc1xuICAgICAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQubWludXRlKTtcbiAgICAgICAgICBjYXNlIFwibW1cIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5taW51dGUsIDIpO1xuICAgICAgICAgIC8vIGhvdXJzXG4gICAgICAgICAgY2FzZSBcImhcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5ob3VyICUgMTIgPT09IDAgPyAxMiA6IGR0LmhvdXIgJSAxMik7XG4gICAgICAgICAgY2FzZSBcImhoXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQuaG91ciAlIDEyID09PSAwID8gMTIgOiBkdC5ob3VyICUgMTIsIDIpO1xuICAgICAgICAgIGNhc2UgXCJIXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQuaG91cik7XG4gICAgICAgICAgY2FzZSBcIkhIXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQuaG91ciwgMik7XG4gICAgICAgICAgLy8gb2Zmc2V0XG4gICAgICAgICAgY2FzZSBcIlpcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgKzZcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRPZmZzZXQoeyBmb3JtYXQ6IFwibmFycm93XCIsIGFsbG93WjogdGhpcy5vcHRzLmFsbG93WiB9KTtcbiAgICAgICAgICBjYXNlIFwiWlpcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgKzA2OjAwXG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0T2Zmc2V0KHsgZm9ybWF0OiBcInNob3J0XCIsIGFsbG93WjogdGhpcy5vcHRzLmFsbG93WiB9KTtcbiAgICAgICAgICBjYXNlIFwiWlpaXCI6XG4gICAgICAgICAgICAvLyBsaWtlICswNjAwXG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0T2Zmc2V0KHsgZm9ybWF0OiBcInRlY2hpZVwiLCBhbGxvd1o6IHRoaXMub3B0cy5hbGxvd1ogfSk7XG4gICAgICAgICAgY2FzZSBcIlpaWlpcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgRVNUXG4gICAgICAgICAgICByZXR1cm4gZHQuem9uZS5vZmZzZXROYW1lKGR0LnRzLCB7IGZvcm1hdDogXCJzaG9ydFwiLCBsb2NhbGU6IHRoaXMubG9jLmxvY2FsZSB9KTtcbiAgICAgICAgICBjYXNlIFwiWlpaWlpcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgRWFzdGVybiBTdGFuZGFyZCBUaW1lXG4gICAgICAgICAgICByZXR1cm4gZHQuem9uZS5vZmZzZXROYW1lKGR0LnRzLCB7IGZvcm1hdDogXCJsb25nXCIsIGxvY2FsZTogdGhpcy5sb2MubG9jYWxlIH0pO1xuICAgICAgICAgIC8vIHpvbmVcbiAgICAgICAgICBjYXNlIFwielwiOlxuICAgICAgICAgICAgLy8gbGlrZSBBbWVyaWNhL05ld19Zb3JrXG4gICAgICAgICAgICByZXR1cm4gZHQuem9uZU5hbWU7XG4gICAgICAgICAgLy8gbWVyaWRpZW1zXG4gICAgICAgICAgY2FzZSBcImFcIjpcbiAgICAgICAgICAgIHJldHVybiBtZXJpZGllbSgpO1xuICAgICAgICAgIC8vIGRhdGVzXG4gICAgICAgICAgY2FzZSBcImRcIjpcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlciA/IHN0cmluZyh7IGRheTogXCJudW1lcmljXCIgfSwgXCJkYXlcIikgOiB0aGlzLm51bShkdC5kYXkpO1xuICAgICAgICAgIGNhc2UgXCJkZFwiOlxuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyID8gc3RyaW5nKHsgZGF5OiBcIjItZGlnaXRcIiB9LCBcImRheVwiKSA6IHRoaXMubnVtKGR0LmRheSwgMik7XG4gICAgICAgICAgLy8gd2Vla2RheXMgLSBzdGFuZGFsb25lXG4gICAgICAgICAgY2FzZSBcImNcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LndlZWtkYXkpO1xuICAgICAgICAgIGNhc2UgXCJjY2NcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgJ1R1ZXMnXG4gICAgICAgICAgICByZXR1cm4gd2Vla2RheShcInNob3J0XCIsIHRydWUpO1xuICAgICAgICAgIGNhc2UgXCJjY2NjXCI6XG4gICAgICAgICAgICAvLyBsaWtlICdUdWVzZGF5J1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtkYXkoXCJsb25nXCIsIHRydWUpO1xuICAgICAgICAgIGNhc2UgXCJjY2NjY1wiOlxuICAgICAgICAgICAgLy8gbGlrZSAnVCdcbiAgICAgICAgICAgIHJldHVybiB3ZWVrZGF5KFwibmFycm93XCIsIHRydWUpO1xuICAgICAgICAgIC8vIHdlZWtkYXlzIC0gZm9ybWF0XG4gICAgICAgICAgY2FzZSBcIkVcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LndlZWtkYXkpO1xuICAgICAgICAgIGNhc2UgXCJFRUVcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgJ1R1ZXMnXG4gICAgICAgICAgICByZXR1cm4gd2Vla2RheShcInNob3J0XCIsIGZhbHNlKTtcbiAgICAgICAgICBjYXNlIFwiRUVFRVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAnVHVlc2RheSdcbiAgICAgICAgICAgIHJldHVybiB3ZWVrZGF5KFwibG9uZ1wiLCBmYWxzZSk7XG4gICAgICAgICAgY2FzZSBcIkVFRUVFXCI6XG4gICAgICAgICAgICAvLyBsaWtlICdUJ1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtkYXkoXCJuYXJyb3dcIiwgZmFsc2UpO1xuICAgICAgICAgIC8vIG1vbnRocyAtIHN0YW5kYWxvbmVcbiAgICAgICAgICBjYXNlIFwiTFwiOlxuICAgICAgICAgICAgLy8gbGlrZSAxXG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXJcbiAgICAgICAgICAgICAgPyBzdHJpbmcoeyBtb250aDogXCJudW1lcmljXCIsIGRheTogXCJudW1lcmljXCIgfSwgXCJtb250aFwiKVxuICAgICAgICAgICAgICA6IHRoaXMubnVtKGR0Lm1vbnRoKTtcbiAgICAgICAgICBjYXNlIFwiTExcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMDEsIGRvZXNuJ3Qgc2VlbSB0byB3b3JrXG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXJcbiAgICAgICAgICAgICAgPyBzdHJpbmcoeyBtb250aDogXCIyLWRpZ2l0XCIsIGRheTogXCJudW1lcmljXCIgfSwgXCJtb250aFwiKVxuICAgICAgICAgICAgICA6IHRoaXMubnVtKGR0Lm1vbnRoLCAyKTtcbiAgICAgICAgICBjYXNlIFwiTExMXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEphblxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoKFwic2hvcnRcIiwgdHJ1ZSk7XG4gICAgICAgICAgY2FzZSBcIkxMTExcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgSmFudWFyeVxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoKFwibG9uZ1wiLCB0cnVlKTtcbiAgICAgICAgICBjYXNlIFwiTExMTExcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgSlxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoKFwibmFycm93XCIsIHRydWUpO1xuICAgICAgICAgIC8vIG1vbnRocyAtIGZvcm1hdFxuICAgICAgICAgIGNhc2UgXCJNXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDFcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlclxuICAgICAgICAgICAgICA/IHN0cmluZyh7IG1vbnRoOiBcIm51bWVyaWNcIiB9LCBcIm1vbnRoXCIpXG4gICAgICAgICAgICAgIDogdGhpcy5udW0oZHQubW9udGgpO1xuICAgICAgICAgIGNhc2UgXCJNTVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAwMVxuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyXG4gICAgICAgICAgICAgID8gc3RyaW5nKHsgbW9udGg6IFwiMi1kaWdpdFwiIH0sIFwibW9udGhcIilcbiAgICAgICAgICAgICAgOiB0aGlzLm51bShkdC5tb250aCwgMik7XG4gICAgICAgICAgY2FzZSBcIk1NTVwiOlxuICAgICAgICAgICAgLy8gbGlrZSBKYW5cbiAgICAgICAgICAgIHJldHVybiBtb250aChcInNob3J0XCIsIGZhbHNlKTtcbiAgICAgICAgICBjYXNlIFwiTU1NTVwiOlxuICAgICAgICAgICAgLy8gbGlrZSBKYW51YXJ5XG4gICAgICAgICAgICByZXR1cm4gbW9udGgoXCJsb25nXCIsIGZhbHNlKTtcbiAgICAgICAgICBjYXNlIFwiTU1NTU1cIjpcbiAgICAgICAgICAgIC8vIGxpa2UgSlxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoKFwibmFycm93XCIsIGZhbHNlKTtcbiAgICAgICAgICAvLyB5ZWFyc1xuICAgICAgICAgIGNhc2UgXCJ5XCI6XG4gICAgICAgICAgICAvLyBsaWtlIDIwMTRcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlciA/IHN0cmluZyh7IHllYXI6IFwibnVtZXJpY1wiIH0sIFwieWVhclwiKSA6IHRoaXMubnVtKGR0LnllYXIpO1xuICAgICAgICAgIGNhc2UgXCJ5eVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAxNFxuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyXG4gICAgICAgICAgICAgID8gc3RyaW5nKHsgeWVhcjogXCIyLWRpZ2l0XCIgfSwgXCJ5ZWFyXCIpXG4gICAgICAgICAgICAgIDogdGhpcy5udW0oZHQueWVhci50b1N0cmluZygpLnNsaWNlKC0yKSwgMik7XG4gICAgICAgICAgY2FzZSBcInl5eXlcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMDAxMlxuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyXG4gICAgICAgICAgICAgID8gc3RyaW5nKHsgeWVhcjogXCJudW1lcmljXCIgfSwgXCJ5ZWFyXCIpXG4gICAgICAgICAgICAgIDogdGhpcy5udW0oZHQueWVhciwgNCk7XG4gICAgICAgICAgY2FzZSBcInl5eXl5eVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAwMDAwMTJcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlclxuICAgICAgICAgICAgICA/IHN0cmluZyh7IHllYXI6IFwibnVtZXJpY1wiIH0sIFwieWVhclwiKVxuICAgICAgICAgICAgICA6IHRoaXMubnVtKGR0LnllYXIsIDYpO1xuICAgICAgICAgIC8vIGVyYXNcbiAgICAgICAgICBjYXNlIFwiR1wiOlxuICAgICAgICAgICAgLy8gbGlrZSBBRFxuICAgICAgICAgICAgcmV0dXJuIGVyYShcInNob3J0XCIpO1xuICAgICAgICAgIGNhc2UgXCJHR1wiOlxuICAgICAgICAgICAgLy8gbGlrZSBBbm5vIERvbWluaVxuICAgICAgICAgICAgcmV0dXJuIGVyYShcImxvbmdcIik7XG4gICAgICAgICAgY2FzZSBcIkdHR0dHXCI6XG4gICAgICAgICAgICByZXR1cm4gZXJhKFwibmFycm93XCIpO1xuICAgICAgICAgIGNhc2UgXCJra1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LndlZWtZZWFyLnRvU3RyaW5nKCkuc2xpY2UoLTIpLCAyKTtcbiAgICAgICAgICBjYXNlIFwia2tra1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LndlZWtZZWFyLCA0KTtcbiAgICAgICAgICBjYXNlIFwiV1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LndlZWtOdW1iZXIpO1xuICAgICAgICAgIGNhc2UgXCJXV1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LndlZWtOdW1iZXIsIDIpO1xuICAgICAgICAgIGNhc2UgXCJvXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQub3JkaW5hbCk7XG4gICAgICAgICAgY2FzZSBcIm9vb1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0Lm9yZGluYWwsIDMpO1xuICAgICAgICAgIGNhc2UgXCJxXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDFcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5xdWFydGVyKTtcbiAgICAgICAgICBjYXNlIFwicXFcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMDFcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5xdWFydGVyLCAyKTtcbiAgICAgICAgICBjYXNlIFwiWFwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKE1hdGguZmxvb3IoZHQudHMgLyAxMDAwKSk7XG4gICAgICAgICAgY2FzZSBcInhcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC50cyk7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBtYXliZU1hY3JvKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgIHJldHVybiBzdHJpbmdpZnlUb2tlbnMoRm9ybWF0dGVyLnBhcnNlRm9ybWF0KGZtdCksIHRva2VuVG9TdHJpbmcpO1xuICB9XG5cbiAgZm9ybWF0RHVyYXRpb25Gcm9tU3RyaW5nKGR1ciwgZm10KSB7XG4gICAgY29uc3QgdG9rZW5Ub0ZpZWxkID0gKHRva2VuKSA9PiB7XG4gICAgICAgIHN3aXRjaCAodG9rZW5bMF0pIHtcbiAgICAgICAgICBjYXNlIFwiU1wiOlxuICAgICAgICAgICAgcmV0dXJuIFwibWlsbGlzZWNvbmRcIjtcbiAgICAgICAgICBjYXNlIFwic1wiOlxuICAgICAgICAgICAgcmV0dXJuIFwic2Vjb25kXCI7XG4gICAgICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgICAgIHJldHVybiBcIm1pbnV0ZVwiO1xuICAgICAgICAgIGNhc2UgXCJoXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJob3VyXCI7XG4gICAgICAgICAgY2FzZSBcImRcIjpcbiAgICAgICAgICAgIHJldHVybiBcImRheVwiO1xuICAgICAgICAgIGNhc2UgXCJ3XCI6XG4gICAgICAgICAgICByZXR1cm4gXCJ3ZWVrXCI7XG4gICAgICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgICAgIHJldHVybiBcIm1vbnRoXCI7XG4gICAgICAgICAgY2FzZSBcInlcIjpcbiAgICAgICAgICAgIHJldHVybiBcInllYXJcIjtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0b2tlblRvU3RyaW5nID0gKGxpbGR1cikgPT4gKHRva2VuKSA9PiB7XG4gICAgICAgIGNvbnN0IG1hcHBlZCA9IHRva2VuVG9GaWVsZCh0b2tlbik7XG4gICAgICAgIGlmIChtYXBwZWQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5udW0obGlsZHVyLmdldChtYXBwZWQpLCB0b2tlbi5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRva2VucyA9IEZvcm1hdHRlci5wYXJzZUZvcm1hdChmbXQpLFxuICAgICAgcmVhbFRva2VucyA9IHRva2Vucy5yZWR1Y2UoXG4gICAgICAgIChmb3VuZCwgeyBsaXRlcmFsLCB2YWwgfSkgPT4gKGxpdGVyYWwgPyBmb3VuZCA6IGZvdW5kLmNvbmNhdCh2YWwpKSxcbiAgICAgICAgW11cbiAgICAgICksXG4gICAgICBjb2xsYXBzZWQgPSBkdXIuc2hpZnRUbyguLi5yZWFsVG9rZW5zLm1hcCh0b2tlblRvRmllbGQpLmZpbHRlcigodCkgPT4gdCkpO1xuICAgIHJldHVybiBzdHJpbmdpZnlUb2tlbnModG9rZW5zLCB0b2tlblRvU3RyaW5nKGNvbGxhcHNlZCkpO1xuICB9XG59XG4iLCAiZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW52YWxpZCB7XG4gIGNvbnN0cnVjdG9yKHJlYXNvbiwgZXhwbGFuYXRpb24pIHtcbiAgICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgICB0aGlzLmV4cGxhbmF0aW9uID0gZXhwbGFuYXRpb247XG4gIH1cblxuICB0b01lc3NhZ2UoKSB7XG4gICAgaWYgKHRoaXMuZXhwbGFuYXRpb24pIHtcbiAgICAgIHJldHVybiBgJHt0aGlzLnJlYXNvbn06ICR7dGhpcy5leHBsYW5hdGlvbn1gO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWFzb247XG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgdW50cnVuY2F0ZVllYXIsXG4gIHNpZ25lZE9mZnNldCxcbiAgcGFyc2VJbnRlZ2VyLFxuICBwYXJzZU1pbGxpcyxcbiAgaXNVbmRlZmluZWQsXG4gIHBhcnNlRmxvYXRpbmcsXG59IGZyb20gXCIuL3V0aWwuanNcIjtcbmltcG9ydCAqIGFzIEVuZ2xpc2ggZnJvbSBcIi4vZW5nbGlzaC5qc1wiO1xuaW1wb3J0IEZpeGVkT2Zmc2V0Wm9uZSBmcm9tIFwiLi4vem9uZXMvZml4ZWRPZmZzZXRab25lLmpzXCI7XG5pbXBvcnQgSUFOQVpvbmUgZnJvbSBcIi4uL3pvbmVzL0lBTkFab25lLmpzXCI7XG5cbi8qXG4gKiBUaGlzIGZpbGUgaGFuZGxlcyBwYXJzaW5nIGZvciB3ZWxsLXNwZWNpZmllZCBmb3JtYXRzLiBIZXJlJ3MgaG93IGl0IHdvcmtzOlxuICogVHdvIHRoaW5ncyBnbyBpbnRvIHBhcnNpbmc6IGEgcmVnZXggdG8gbWF0Y2ggd2l0aCBhbmQgYW4gZXh0cmFjdG9yIHRvIHRha2UgYXBhcnQgdGhlIGdyb3VwcyBpbiB0aGUgbWF0Y2guXG4gKiBBbiBleHRyYWN0b3IgaXMganVzdCBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSByZWdleCBtYXRjaCBhcnJheSBhbmQgcmV0dXJucyBhIHsgeWVhcjogLi4uLCBtb250aDogLi4uIH0gb2JqZWN0XG4gKiBwYXJzZSgpIGRvZXMgdGhlIHdvcmsgb2YgZXhlY3V0aW5nIHRoZSByZWdleCBhbmQgYXBwbHlpbmcgdGhlIGV4dHJhY3Rvci4gSXQgdGFrZXMgbXVsdGlwbGUgcmVnZXgvZXh0cmFjdG9yIHBhaXJzIHRvIHRyeSBpbiBzZXF1ZW5jZS5cbiAqIEV4dHJhY3RvcnMgY2FuIHRha2UgYSBcImN1cnNvclwiIHJlcHJlc2VudGluZyB0aGUgb2Zmc2V0IGluIHRoZSBtYXRjaCB0byBsb29rIGF0LiBUaGlzIG1ha2VzIGl0IGVhc3kgdG8gY29tYmluZSBleHRyYWN0b3JzLlxuICogY29tYmluZUV4dHJhY3RvcnMoKSBkb2VzIHRoZSB3b3JrIG9mIGNvbWJpbmluZyB0aGVtLCBrZWVwaW5nIHRyYWNrIG9mIHRoZSBjdXJzb3IgdGhyb3VnaCBtdWx0aXBsZSBleHRyYWN0aW9ucy5cbiAqIFNvbWUgZXh0cmFjdGlvbnMgYXJlIHN1cGVyIGR1bWIgYW5kIHNpbXBsZVBhcnNlIGFuZCBmcm9tU3RyaW5ncyBoZWxwIERSWSB0aGVtLlxuICovXG5cbmNvbnN0IGlhbmFSZWdleCA9IC9bQS1aYS16XystXXsxLDI1Nn0oPzo6P1xcL1tBLVphLXowLTlfKy1dezEsMjU2fSg/OlxcL1tBLVphLXowLTlfKy1dezEsMjU2fSk/KT8vO1xuXG5mdW5jdGlvbiBjb21iaW5lUmVnZXhlcyguLi5yZWdleGVzKSB7XG4gIGNvbnN0IGZ1bGwgPSByZWdleGVzLnJlZHVjZSgoZiwgcikgPT4gZiArIHIuc291cmNlLCBcIlwiKTtcbiAgcmV0dXJuIFJlZ0V4cChgXiR7ZnVsbH0kYCk7XG59XG5cbmZ1bmN0aW9uIGNvbWJpbmVFeHRyYWN0b3JzKC4uLmV4dHJhY3RvcnMpIHtcbiAgcmV0dXJuIChtKSA9PlxuICAgIGV4dHJhY3RvcnNcbiAgICAgIC5yZWR1Y2UoXG4gICAgICAgIChbbWVyZ2VkVmFscywgbWVyZ2VkWm9uZSwgY3Vyc29yXSwgZXgpID0+IHtcbiAgICAgICAgICBjb25zdCBbdmFsLCB6b25lLCBuZXh0XSA9IGV4KG0sIGN1cnNvcik7XG4gICAgICAgICAgcmV0dXJuIFt7IC4uLm1lcmdlZFZhbHMsIC4uLnZhbCB9LCB6b25lIHx8IG1lcmdlZFpvbmUsIG5leHRdO1xuICAgICAgICB9LFxuICAgICAgICBbe30sIG51bGwsIDFdXG4gICAgICApXG4gICAgICAuc2xpY2UoMCwgMik7XG59XG5cbmZ1bmN0aW9uIHBhcnNlKHMsIC4uLnBhdHRlcm5zKSB7XG4gIGlmIChzID09IG51bGwpIHtcbiAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICB9XG5cbiAgZm9yIChjb25zdCBbcmVnZXgsIGV4dHJhY3Rvcl0gb2YgcGF0dGVybnMpIHtcbiAgICBjb25zdCBtID0gcmVnZXguZXhlYyhzKTtcbiAgICBpZiAobSkge1xuICAgICAgcmV0dXJuIGV4dHJhY3RvcihtKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtudWxsLCBudWxsXTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlUGFyc2UoLi4ua2V5cykge1xuICByZXR1cm4gKG1hdGNoLCBjdXJzb3IpID0+IHtcbiAgICBjb25zdCByZXQgPSB7fTtcbiAgICBsZXQgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXRba2V5c1tpXV0gPSBwYXJzZUludGVnZXIobWF0Y2hbY3Vyc29yICsgaV0pO1xuICAgIH1cbiAgICByZXR1cm4gW3JldCwgbnVsbCwgY3Vyc29yICsgaV07XG4gIH07XG59XG5cbi8vIElTTyBhbmQgU1FMIHBhcnNpbmdcbmNvbnN0IG9mZnNldFJlZ2V4ID0gLyg/OihaKXwoWystXVxcZFxcZCkoPzo6PyhcXGRcXGQpKT8pLztcbmNvbnN0IGlzb0V4dGVuZGVkWm9uZSA9IGAoPzoke29mZnNldFJlZ2V4LnNvdXJjZX0/KD86XFxcXFsoJHtpYW5hUmVnZXguc291cmNlfSlcXFxcXSk/KT9gO1xuY29uc3QgaXNvVGltZUJhc2VSZWdleCA9IC8oXFxkXFxkKSg/Ojo/KFxcZFxcZCkoPzo6PyhcXGRcXGQpKD86Wy4sXShcXGR7MSwzMH0pKT8pPyk/LztcbmNvbnN0IGlzb1RpbWVSZWdleCA9IFJlZ0V4cChgJHtpc29UaW1lQmFzZVJlZ2V4LnNvdXJjZX0ke2lzb0V4dGVuZGVkWm9uZX1gKTtcbmNvbnN0IGlzb1RpbWVFeHRlbnNpb25SZWdleCA9IFJlZ0V4cChgKD86VCR7aXNvVGltZVJlZ2V4LnNvdXJjZX0pP2ApO1xuY29uc3QgaXNvWW1kUmVnZXggPSAvKFsrLV1cXGR7Nn18XFxkezR9KSg/Oi0/KFxcZFxcZCkoPzotPyhcXGRcXGQpKT8pPy87XG5jb25zdCBpc29XZWVrUmVnZXggPSAvKFxcZHs0fSktP1coXFxkXFxkKSg/Oi0/KFxcZCkpPy87XG5jb25zdCBpc29PcmRpbmFsUmVnZXggPSAvKFxcZHs0fSktPyhcXGR7M30pLztcbmNvbnN0IGV4dHJhY3RJU09XZWVrRGF0YSA9IHNpbXBsZVBhcnNlKFwid2Vla1llYXJcIiwgXCJ3ZWVrTnVtYmVyXCIsIFwid2Vla0RheVwiKTtcbmNvbnN0IGV4dHJhY3RJU09PcmRpbmFsRGF0YSA9IHNpbXBsZVBhcnNlKFwieWVhclwiLCBcIm9yZGluYWxcIik7XG5jb25zdCBzcWxZbWRSZWdleCA9IC8oXFxkezR9KS0oXFxkXFxkKS0oXFxkXFxkKS87IC8vIGR1bWJlZC1kb3duIHZlcnNpb24gb2YgdGhlIElTTyBvbmVcbmNvbnN0IHNxbFRpbWVSZWdleCA9IFJlZ0V4cChcbiAgYCR7aXNvVGltZUJhc2VSZWdleC5zb3VyY2V9ID8oPzoke29mZnNldFJlZ2V4LnNvdXJjZX18KCR7aWFuYVJlZ2V4LnNvdXJjZX0pKT9gXG4pO1xuY29uc3Qgc3FsVGltZUV4dGVuc2lvblJlZ2V4ID0gUmVnRXhwKGAoPzogJHtzcWxUaW1lUmVnZXguc291cmNlfSk/YCk7XG5cbmZ1bmN0aW9uIGludChtYXRjaCwgcG9zLCBmYWxsYmFjaykge1xuICBjb25zdCBtID0gbWF0Y2hbcG9zXTtcbiAgcmV0dXJuIGlzVW5kZWZpbmVkKG0pID8gZmFsbGJhY2sgOiBwYXJzZUludGVnZXIobSk7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RJU09ZbWQobWF0Y2gsIGN1cnNvcikge1xuICBjb25zdCBpdGVtID0ge1xuICAgIHllYXI6IGludChtYXRjaCwgY3Vyc29yKSxcbiAgICBtb250aDogaW50KG1hdGNoLCBjdXJzb3IgKyAxLCAxKSxcbiAgICBkYXk6IGludChtYXRjaCwgY3Vyc29yICsgMiwgMSksXG4gIH07XG5cbiAgcmV0dXJuIFtpdGVtLCBudWxsLCBjdXJzb3IgKyAzXTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdElTT1RpbWUobWF0Y2gsIGN1cnNvcikge1xuICBjb25zdCBpdGVtID0ge1xuICAgIGhvdXJzOiBpbnQobWF0Y2gsIGN1cnNvciwgMCksXG4gICAgbWludXRlczogaW50KG1hdGNoLCBjdXJzb3IgKyAxLCAwKSxcbiAgICBzZWNvbmRzOiBpbnQobWF0Y2gsIGN1cnNvciArIDIsIDApLFxuICAgIG1pbGxpc2Vjb25kczogcGFyc2VNaWxsaXMobWF0Y2hbY3Vyc29yICsgM10pLFxuICB9O1xuXG4gIHJldHVybiBbaXRlbSwgbnVsbCwgY3Vyc29yICsgNF07XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RJU09PZmZzZXQobWF0Y2gsIGN1cnNvcikge1xuICBjb25zdCBsb2NhbCA9ICFtYXRjaFtjdXJzb3JdICYmICFtYXRjaFtjdXJzb3IgKyAxXSxcbiAgICBmdWxsT2Zmc2V0ID0gc2lnbmVkT2Zmc2V0KG1hdGNoW2N1cnNvciArIDFdLCBtYXRjaFtjdXJzb3IgKyAyXSksXG4gICAgem9uZSA9IGxvY2FsID8gbnVsbCA6IEZpeGVkT2Zmc2V0Wm9uZS5pbnN0YW5jZShmdWxsT2Zmc2V0KTtcbiAgcmV0dXJuIFt7fSwgem9uZSwgY3Vyc29yICsgM107XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RJQU5BWm9uZShtYXRjaCwgY3Vyc29yKSB7XG4gIGNvbnN0IHpvbmUgPSBtYXRjaFtjdXJzb3JdID8gSUFOQVpvbmUuY3JlYXRlKG1hdGNoW2N1cnNvcl0pIDogbnVsbDtcbiAgcmV0dXJuIFt7fSwgem9uZSwgY3Vyc29yICsgMV07XG59XG5cbi8vIElTTyB0aW1lIHBhcnNpbmdcblxuY29uc3QgaXNvVGltZU9ubHkgPSBSZWdFeHAoYF5UPyR7aXNvVGltZUJhc2VSZWdleC5zb3VyY2V9JGApO1xuXG4vLyBJU08gZHVyYXRpb24gcGFyc2luZ1xuXG5jb25zdCBpc29EdXJhdGlvbiA9XG4gIC9eLT9QKD86KD86KC0/XFxkezEsMjB9KD86XFwuXFxkezEsMjB9KT8pWSk/KD86KC0/XFxkezEsMjB9KD86XFwuXFxkezEsMjB9KT8pTSk/KD86KC0/XFxkezEsMjB9KD86XFwuXFxkezEsMjB9KT8pVyk/KD86KC0/XFxkezEsMjB9KD86XFwuXFxkezEsMjB9KT8pRCk/KD86VCg/OigtP1xcZHsxLDIwfSg/OlxcLlxcZHsxLDIwfSk/KUgpPyg/OigtP1xcZHsxLDIwfSg/OlxcLlxcZHsxLDIwfSk/KU0pPyg/OigtP1xcZHsxLDIwfSkoPzpbLixdKC0/XFxkezEsMjB9KSk/Uyk/KT8pJC87XG5cbmZ1bmN0aW9uIGV4dHJhY3RJU09EdXJhdGlvbihtYXRjaCkge1xuICBjb25zdCBbcywgeWVhclN0ciwgbW9udGhTdHIsIHdlZWtTdHIsIGRheVN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHIsIG1pbGxpc2Vjb25kc1N0cl0gPVxuICAgIG1hdGNoO1xuXG4gIGNvbnN0IGhhc05lZ2F0aXZlUHJlZml4ID0gc1swXSA9PT0gXCItXCI7XG4gIGNvbnN0IG5lZ2F0aXZlU2Vjb25kcyA9IHNlY29uZFN0ciAmJiBzZWNvbmRTdHJbMF0gPT09IFwiLVwiO1xuXG4gIGNvbnN0IG1heWJlTmVnYXRlID0gKG51bSwgZm9yY2UgPSBmYWxzZSkgPT5cbiAgICBudW0gIT09IHVuZGVmaW5lZCAmJiAoZm9yY2UgfHwgKG51bSAmJiBoYXNOZWdhdGl2ZVByZWZpeCkpID8gLW51bSA6IG51bTtcblxuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIHllYXJzOiBtYXliZU5lZ2F0ZShwYXJzZUZsb2F0aW5nKHllYXJTdHIpKSxcbiAgICAgIG1vbnRoczogbWF5YmVOZWdhdGUocGFyc2VGbG9hdGluZyhtb250aFN0cikpLFxuICAgICAgd2Vla3M6IG1heWJlTmVnYXRlKHBhcnNlRmxvYXRpbmcod2Vla1N0cikpLFxuICAgICAgZGF5czogbWF5YmVOZWdhdGUocGFyc2VGbG9hdGluZyhkYXlTdHIpKSxcbiAgICAgIGhvdXJzOiBtYXliZU5lZ2F0ZShwYXJzZUZsb2F0aW5nKGhvdXJTdHIpKSxcbiAgICAgIG1pbnV0ZXM6IG1heWJlTmVnYXRlKHBhcnNlRmxvYXRpbmcobWludXRlU3RyKSksXG4gICAgICBzZWNvbmRzOiBtYXliZU5lZ2F0ZShwYXJzZUZsb2F0aW5nKHNlY29uZFN0ciksIHNlY29uZFN0ciA9PT0gXCItMFwiKSxcbiAgICAgIG1pbGxpc2Vjb25kczogbWF5YmVOZWdhdGUocGFyc2VNaWxsaXMobWlsbGlzZWNvbmRzU3RyKSwgbmVnYXRpdmVTZWNvbmRzKSxcbiAgICB9LFxuICBdO1xufVxuXG4vLyBUaGVzZSBhcmUgYSBsaXR0bGUgYnJhaW5kZWFkLiBFRFQgKnNob3VsZCogdGVsbCB1cyB0aGF0IHdlJ3JlIGluLCBzYXksIEFtZXJpY2EvTmV3X1lvcmtcbi8vIGFuZCBub3QganVzdCB0aGF0IHdlJ3JlIGluIC0yNDAgKnJpZ2h0IG5vdyouIEJ1dCBzaW5jZSBJIGRvbid0IHRoaW5rIHRoZXNlIGFyZSB1c2VkIHRoYXQgb2Z0ZW5cbi8vIEknbSBqdXN0IGdvaW5nIHRvIGlnbm9yZSB0aGF0XG5jb25zdCBvYnNPZmZzZXRzID0ge1xuICBHTVQ6IDAsXG4gIEVEVDogLTQgKiA2MCxcbiAgRVNUOiAtNSAqIDYwLFxuICBDRFQ6IC01ICogNjAsXG4gIENTVDogLTYgKiA2MCxcbiAgTURUOiAtNiAqIDYwLFxuICBNU1Q6IC03ICogNjAsXG4gIFBEVDogLTcgKiA2MCxcbiAgUFNUOiAtOCAqIDYwLFxufTtcblxuZnVuY3Rpb24gZnJvbVN0cmluZ3Mod2Vla2RheVN0ciwgeWVhclN0ciwgbW9udGhTdHIsIGRheVN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHIpIHtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIHllYXI6IHllYXJTdHIubGVuZ3RoID09PSAyID8gdW50cnVuY2F0ZVllYXIocGFyc2VJbnRlZ2VyKHllYXJTdHIpKSA6IHBhcnNlSW50ZWdlcih5ZWFyU3RyKSxcbiAgICBtb250aDogRW5nbGlzaC5tb250aHNTaG9ydC5pbmRleE9mKG1vbnRoU3RyKSArIDEsXG4gICAgZGF5OiBwYXJzZUludGVnZXIoZGF5U3RyKSxcbiAgICBob3VyOiBwYXJzZUludGVnZXIoaG91clN0ciksXG4gICAgbWludXRlOiBwYXJzZUludGVnZXIobWludXRlU3RyKSxcbiAgfTtcblxuICBpZiAoc2Vjb25kU3RyKSByZXN1bHQuc2Vjb25kID0gcGFyc2VJbnRlZ2VyKHNlY29uZFN0cik7XG4gIGlmICh3ZWVrZGF5U3RyKSB7XG4gICAgcmVzdWx0LndlZWtkYXkgPVxuICAgICAgd2Vla2RheVN0ci5sZW5ndGggPiAzXG4gICAgICAgID8gRW5nbGlzaC53ZWVrZGF5c0xvbmcuaW5kZXhPZih3ZWVrZGF5U3RyKSArIDFcbiAgICAgICAgOiBFbmdsaXNoLndlZWtkYXlzU2hvcnQuaW5kZXhPZih3ZWVrZGF5U3RyKSArIDE7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBSRkMgMjgyMi81MzIyXG5jb25zdCByZmMyODIyID1cbiAgL14oPzooTW9ufFR1ZXxXZWR8VGh1fEZyaXxTYXR8U3VuKSxcXHMpPyhcXGR7MSwyfSlcXHMoSmFufEZlYnxNYXJ8QXByfE1heXxKdW58SnVsfEF1Z3xTZXB8T2N0fE5vdnxEZWMpXFxzKFxcZHsyLDR9KVxccyhcXGRcXGQpOihcXGRcXGQpKD86OihcXGRcXGQpKT9cXHMoPzooVVR8R01UfFtFQ01QXVtTRF1UKXwoW1p6XSl8KD86KFsrLV1cXGRcXGQpKFxcZFxcZCkpKSQvO1xuXG5mdW5jdGlvbiBleHRyYWN0UkZDMjgyMihtYXRjaCkge1xuICBjb25zdCBbXG4gICAgICAsXG4gICAgICB3ZWVrZGF5U3RyLFxuICAgICAgZGF5U3RyLFxuICAgICAgbW9udGhTdHIsXG4gICAgICB5ZWFyU3RyLFxuICAgICAgaG91clN0cixcbiAgICAgIG1pbnV0ZVN0cixcbiAgICAgIHNlY29uZFN0cixcbiAgICAgIG9ic09mZnNldCxcbiAgICAgIG1pbE9mZnNldCxcbiAgICAgIG9mZkhvdXJTdHIsXG4gICAgICBvZmZNaW51dGVTdHIsXG4gICAgXSA9IG1hdGNoLFxuICAgIHJlc3VsdCA9IGZyb21TdHJpbmdzKHdlZWtkYXlTdHIsIHllYXJTdHIsIG1vbnRoU3RyLCBkYXlTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyKTtcblxuICBsZXQgb2Zmc2V0O1xuICBpZiAob2JzT2Zmc2V0KSB7XG4gICAgb2Zmc2V0ID0gb2JzT2Zmc2V0c1tvYnNPZmZzZXRdO1xuICB9IGVsc2UgaWYgKG1pbE9mZnNldCkge1xuICAgIG9mZnNldCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgb2Zmc2V0ID0gc2lnbmVkT2Zmc2V0KG9mZkhvdXJTdHIsIG9mZk1pbnV0ZVN0cik7XG4gIH1cblxuICByZXR1cm4gW3Jlc3VsdCwgbmV3IEZpeGVkT2Zmc2V0Wm9uZShvZmZzZXQpXTtcbn1cblxuZnVuY3Rpb24gcHJlcHJvY2Vzc1JGQzI4MjIocykge1xuICAvLyBSZW1vdmUgY29tbWVudHMgYW5kIGZvbGRpbmcgd2hpdGVzcGFjZSBhbmQgcmVwbGFjZSBtdWx0aXBsZS1zcGFjZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuICByZXR1cm4gc1xuICAgIC5yZXBsYWNlKC9cXChbXigpXSpcXCl8W1xcblxcdF0vZywgXCIgXCIpXG4gICAgLnJlcGxhY2UoLyhcXHNcXHMrKS9nLCBcIiBcIilcbiAgICAudHJpbSgpO1xufVxuXG4vLyBodHRwIGRhdGVcblxuY29uc3QgcmZjMTEyMyA9XG4gICAgL14oTW9ufFR1ZXxXZWR8VGh1fEZyaXxTYXR8U3VuKSwgKFxcZFxcZCkgKEphbnxGZWJ8TWFyfEFwcnxNYXl8SnVufEp1bHxBdWd8U2VwfE9jdHxOb3Z8RGVjKSAoXFxkezR9KSAoXFxkXFxkKTooXFxkXFxkKTooXFxkXFxkKSBHTVQkLyxcbiAgcmZjODUwID1cbiAgICAvXihNb25kYXl8VHVlc2RheXxXZWRuZXNkYXl8VGh1cnNkYXl8RnJpZGF5fFNhdHVyZGF5fFN1bmRheSksIChcXGRcXGQpLShKYW58RmVifE1hcnxBcHJ8TWF5fEp1bnxKdWx8QXVnfFNlcHxPY3R8Tm92fERlYyktKFxcZFxcZCkgKFxcZFxcZCk6KFxcZFxcZCk6KFxcZFxcZCkgR01UJC8sXG4gIGFzY2lpID1cbiAgICAvXihNb258VHVlfFdlZHxUaHV8RnJpfFNhdHxTdW4pIChKYW58RmVifE1hcnxBcHJ8TWF5fEp1bnxKdWx8QXVnfFNlcHxPY3R8Tm92fERlYykgKCBcXGR8XFxkXFxkKSAoXFxkXFxkKTooXFxkXFxkKTooXFxkXFxkKSAoXFxkezR9KSQvO1xuXG5mdW5jdGlvbiBleHRyYWN0UkZDMTEyM09yODUwKG1hdGNoKSB7XG4gIGNvbnN0IFssIHdlZWtkYXlTdHIsIGRheVN0ciwgbW9udGhTdHIsIHllYXJTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyXSA9IG1hdGNoLFxuICAgIHJlc3VsdCA9IGZyb21TdHJpbmdzKHdlZWtkYXlTdHIsIHllYXJTdHIsIG1vbnRoU3RyLCBkYXlTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyKTtcbiAgcmV0dXJuIFtyZXN1bHQsIEZpeGVkT2Zmc2V0Wm9uZS51dGNJbnN0YW5jZV07XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RBU0NJSShtYXRjaCkge1xuICBjb25zdCBbLCB3ZWVrZGF5U3RyLCBtb250aFN0ciwgZGF5U3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0ciwgeWVhclN0cl0gPSBtYXRjaCxcbiAgICByZXN1bHQgPSBmcm9tU3RyaW5ncyh3ZWVrZGF5U3RyLCB5ZWFyU3RyLCBtb250aFN0ciwgZGF5U3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0cik7XG4gIHJldHVybiBbcmVzdWx0LCBGaXhlZE9mZnNldFpvbmUudXRjSW5zdGFuY2VdO1xufVxuXG5jb25zdCBpc29ZbWRXaXRoVGltZUV4dGVuc2lvblJlZ2V4ID0gY29tYmluZVJlZ2V4ZXMoaXNvWW1kUmVnZXgsIGlzb1RpbWVFeHRlbnNpb25SZWdleCk7XG5jb25zdCBpc29XZWVrV2l0aFRpbWVFeHRlbnNpb25SZWdleCA9IGNvbWJpbmVSZWdleGVzKGlzb1dlZWtSZWdleCwgaXNvVGltZUV4dGVuc2lvblJlZ2V4KTtcbmNvbnN0IGlzb09yZGluYWxXaXRoVGltZUV4dGVuc2lvblJlZ2V4ID0gY29tYmluZVJlZ2V4ZXMoaXNvT3JkaW5hbFJlZ2V4LCBpc29UaW1lRXh0ZW5zaW9uUmVnZXgpO1xuY29uc3QgaXNvVGltZUNvbWJpbmVkUmVnZXggPSBjb21iaW5lUmVnZXhlcyhpc29UaW1lUmVnZXgpO1xuXG5jb25zdCBleHRyYWN0SVNPWW1kVGltZUFuZE9mZnNldCA9IGNvbWJpbmVFeHRyYWN0b3JzKFxuICBleHRyYWN0SVNPWW1kLFxuICBleHRyYWN0SVNPVGltZSxcbiAgZXh0cmFjdElTT09mZnNldCxcbiAgZXh0cmFjdElBTkFab25lXG4pO1xuY29uc3QgZXh0cmFjdElTT1dlZWtUaW1lQW5kT2Zmc2V0ID0gY29tYmluZUV4dHJhY3RvcnMoXG4gIGV4dHJhY3RJU09XZWVrRGF0YSxcbiAgZXh0cmFjdElTT1RpbWUsXG4gIGV4dHJhY3RJU09PZmZzZXQsXG4gIGV4dHJhY3RJQU5BWm9uZVxuKTtcbmNvbnN0IGV4dHJhY3RJU09PcmRpbmFsRGF0ZUFuZFRpbWUgPSBjb21iaW5lRXh0cmFjdG9ycyhcbiAgZXh0cmFjdElTT09yZGluYWxEYXRhLFxuICBleHRyYWN0SVNPVGltZSxcbiAgZXh0cmFjdElTT09mZnNldCxcbiAgZXh0cmFjdElBTkFab25lXG4pO1xuY29uc3QgZXh0cmFjdElTT1RpbWVBbmRPZmZzZXQgPSBjb21iaW5lRXh0cmFjdG9ycyhcbiAgZXh0cmFjdElTT1RpbWUsXG4gIGV4dHJhY3RJU09PZmZzZXQsXG4gIGV4dHJhY3RJQU5BWm9uZVxuKTtcblxuLypcbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSVNPRGF0ZShzKSB7XG4gIHJldHVybiBwYXJzZShcbiAgICBzLFxuICAgIFtpc29ZbWRXaXRoVGltZUV4dGVuc2lvblJlZ2V4LCBleHRyYWN0SVNPWW1kVGltZUFuZE9mZnNldF0sXG4gICAgW2lzb1dlZWtXaXRoVGltZUV4dGVuc2lvblJlZ2V4LCBleHRyYWN0SVNPV2Vla1RpbWVBbmRPZmZzZXRdLFxuICAgIFtpc29PcmRpbmFsV2l0aFRpbWVFeHRlbnNpb25SZWdleCwgZXh0cmFjdElTT09yZGluYWxEYXRlQW5kVGltZV0sXG4gICAgW2lzb1RpbWVDb21iaW5lZFJlZ2V4LCBleHRyYWN0SVNPVGltZUFuZE9mZnNldF1cbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUkZDMjgyMkRhdGUocykge1xuICByZXR1cm4gcGFyc2UocHJlcHJvY2Vzc1JGQzI4MjIocyksIFtyZmMyODIyLCBleHRyYWN0UkZDMjgyMl0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VIVFRQRGF0ZShzKSB7XG4gIHJldHVybiBwYXJzZShcbiAgICBzLFxuICAgIFtyZmMxMTIzLCBleHRyYWN0UkZDMTEyM09yODUwXSxcbiAgICBbcmZjODUwLCBleHRyYWN0UkZDMTEyM09yODUwXSxcbiAgICBbYXNjaWksIGV4dHJhY3RBU0NJSV1cbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSVNPRHVyYXRpb24ocykge1xuICByZXR1cm4gcGFyc2UocywgW2lzb0R1cmF0aW9uLCBleHRyYWN0SVNPRHVyYXRpb25dKTtcbn1cblxuY29uc3QgZXh0cmFjdElTT1RpbWVPbmx5ID0gY29tYmluZUV4dHJhY3RvcnMoZXh0cmFjdElTT1RpbWUpO1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VJU09UaW1lT25seShzKSB7XG4gIHJldHVybiBwYXJzZShzLCBbaXNvVGltZU9ubHksIGV4dHJhY3RJU09UaW1lT25seV0pO1xufVxuXG5jb25zdCBzcWxZbWRXaXRoVGltZUV4dGVuc2lvblJlZ2V4ID0gY29tYmluZVJlZ2V4ZXMoc3FsWW1kUmVnZXgsIHNxbFRpbWVFeHRlbnNpb25SZWdleCk7XG5jb25zdCBzcWxUaW1lQ29tYmluZWRSZWdleCA9IGNvbWJpbmVSZWdleGVzKHNxbFRpbWVSZWdleCk7XG5cbmNvbnN0IGV4dHJhY3RJU09UaW1lT2Zmc2V0QW5kSUFOQVpvbmUgPSBjb21iaW5lRXh0cmFjdG9ycyhcbiAgZXh0cmFjdElTT1RpbWUsXG4gIGV4dHJhY3RJU09PZmZzZXQsXG4gIGV4dHJhY3RJQU5BWm9uZVxuKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU1FMKHMpIHtcbiAgcmV0dXJuIHBhcnNlKFxuICAgIHMsXG4gICAgW3NxbFltZFdpdGhUaW1lRXh0ZW5zaW9uUmVnZXgsIGV4dHJhY3RJU09ZbWRUaW1lQW5kT2Zmc2V0XSxcbiAgICBbc3FsVGltZUNvbWJpbmVkUmVnZXgsIGV4dHJhY3RJU09UaW1lT2Zmc2V0QW5kSUFOQVpvbmVdXG4gICk7XG59XG4iLCAiaW1wb3J0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IsIEludmFsaWREdXJhdGlvbkVycm9yLCBJbnZhbGlkVW5pdEVycm9yIH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgRm9ybWF0dGVyIGZyb20gXCIuL2ltcGwvZm9ybWF0dGVyLmpzXCI7XG5pbXBvcnQgSW52YWxpZCBmcm9tIFwiLi9pbXBsL2ludmFsaWQuanNcIjtcbmltcG9ydCBMb2NhbGUgZnJvbSBcIi4vaW1wbC9sb2NhbGUuanNcIjtcbmltcG9ydCB7IHBhcnNlSVNPRHVyYXRpb24sIHBhcnNlSVNPVGltZU9ubHkgfSBmcm9tIFwiLi9pbXBsL3JlZ2V4UGFyc2VyLmpzXCI7XG5pbXBvcnQge1xuICBhc051bWJlcixcbiAgaGFzT3duUHJvcGVydHksXG4gIGlzTnVtYmVyLFxuICBpc1VuZGVmaW5lZCxcbiAgbm9ybWFsaXplT2JqZWN0LFxuICByb3VuZFRvLFxufSBmcm9tIFwiLi9pbXBsL3V0aWwuanNcIjtcbmltcG9ydCBTZXR0aW5ncyBmcm9tIFwiLi9zZXR0aW5ncy5qc1wiO1xuaW1wb3J0IERhdGVUaW1lIGZyb20gXCIuL2RhdGV0aW1lLmpzXCI7XG5cbmNvbnN0IElOVkFMSUQgPSBcIkludmFsaWQgRHVyYXRpb25cIjtcblxuLy8gdW5pdCBjb252ZXJzaW9uIGNvbnN0YW50c1xuZXhwb3J0IGNvbnN0IGxvd09yZGVyTWF0cml4ID0ge1xuICAgIHdlZWtzOiB7XG4gICAgICBkYXlzOiA3LFxuICAgICAgaG91cnM6IDcgKiAyNCxcbiAgICAgIG1pbnV0ZXM6IDcgKiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogNyAqIDI0ICogNjAgKiA2MCxcbiAgICAgIG1pbGxpc2Vjb25kczogNyAqIDI0ICogNjAgKiA2MCAqIDEwMDAsXG4gICAgfSxcbiAgICBkYXlzOiB7XG4gICAgICBob3VyczogMjQsXG4gICAgICBtaW51dGVzOiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogMjQgKiA2MCAqIDYwLFxuICAgICAgbWlsbGlzZWNvbmRzOiAyNCAqIDYwICogNjAgKiAxMDAwLFxuICAgIH0sXG4gICAgaG91cnM6IHsgbWludXRlczogNjAsIHNlY29uZHM6IDYwICogNjAsIG1pbGxpc2Vjb25kczogNjAgKiA2MCAqIDEwMDAgfSxcbiAgICBtaW51dGVzOiB7IHNlY29uZHM6IDYwLCBtaWxsaXNlY29uZHM6IDYwICogMTAwMCB9LFxuICAgIHNlY29uZHM6IHsgbWlsbGlzZWNvbmRzOiAxMDAwIH0sXG4gIH0sXG4gIGNhc3VhbE1hdHJpeCA9IHtcbiAgICB5ZWFyczoge1xuICAgICAgcXVhcnRlcnM6IDQsXG4gICAgICBtb250aHM6IDEyLFxuICAgICAgd2Vla3M6IDUyLFxuICAgICAgZGF5czogMzY1LFxuICAgICAgaG91cnM6IDM2NSAqIDI0LFxuICAgICAgbWludXRlczogMzY1ICogMjQgKiA2MCxcbiAgICAgIHNlY29uZHM6IDM2NSAqIDI0ICogNjAgKiA2MCxcbiAgICAgIG1pbGxpc2Vjb25kczogMzY1ICogMjQgKiA2MCAqIDYwICogMTAwMCxcbiAgICB9LFxuICAgIHF1YXJ0ZXJzOiB7XG4gICAgICBtb250aHM6IDMsXG4gICAgICB3ZWVrczogMTMsXG4gICAgICBkYXlzOiA5MSxcbiAgICAgIGhvdXJzOiA5MSAqIDI0LFxuICAgICAgbWludXRlczogOTEgKiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogOTEgKiAyNCAqIDYwICogNjAsXG4gICAgICBtaWxsaXNlY29uZHM6IDkxICogMjQgKiA2MCAqIDYwICogMTAwMCxcbiAgICB9LFxuICAgIG1vbnRoczoge1xuICAgICAgd2Vla3M6IDQsXG4gICAgICBkYXlzOiAzMCxcbiAgICAgIGhvdXJzOiAzMCAqIDI0LFxuICAgICAgbWludXRlczogMzAgKiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogMzAgKiAyNCAqIDYwICogNjAsXG4gICAgICBtaWxsaXNlY29uZHM6IDMwICogMjQgKiA2MCAqIDYwICogMTAwMCxcbiAgICB9LFxuXG4gICAgLi4ubG93T3JkZXJNYXRyaXgsXG4gIH0sXG4gIGRheXNJblllYXJBY2N1cmF0ZSA9IDE0NjA5Ny4wIC8gNDAwLFxuICBkYXlzSW5Nb250aEFjY3VyYXRlID0gMTQ2MDk3LjAgLyA0ODAwLFxuICBhY2N1cmF0ZU1hdHJpeCA9IHtcbiAgICB5ZWFyczoge1xuICAgICAgcXVhcnRlcnM6IDQsXG4gICAgICBtb250aHM6IDEyLFxuICAgICAgd2Vla3M6IGRheXNJblllYXJBY2N1cmF0ZSAvIDcsXG4gICAgICBkYXlzOiBkYXlzSW5ZZWFyQWNjdXJhdGUsXG4gICAgICBob3VyczogZGF5c0luWWVhckFjY3VyYXRlICogMjQsXG4gICAgICBtaW51dGVzOiBkYXlzSW5ZZWFyQWNjdXJhdGUgKiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogZGF5c0luWWVhckFjY3VyYXRlICogMjQgKiA2MCAqIDYwLFxuICAgICAgbWlsbGlzZWNvbmRzOiBkYXlzSW5ZZWFyQWNjdXJhdGUgKiAyNCAqIDYwICogNjAgKiAxMDAwLFxuICAgIH0sXG4gICAgcXVhcnRlcnM6IHtcbiAgICAgIG1vbnRoczogMyxcbiAgICAgIHdlZWtzOiBkYXlzSW5ZZWFyQWNjdXJhdGUgLyAyOCxcbiAgICAgIGRheXM6IGRheXNJblllYXJBY2N1cmF0ZSAvIDQsXG4gICAgICBob3VyczogKGRheXNJblllYXJBY2N1cmF0ZSAqIDI0KSAvIDQsXG4gICAgICBtaW51dGVzOiAoZGF5c0luWWVhckFjY3VyYXRlICogMjQgKiA2MCkgLyA0LFxuICAgICAgc2Vjb25kczogKGRheXNJblllYXJBY2N1cmF0ZSAqIDI0ICogNjAgKiA2MCkgLyA0LFxuICAgICAgbWlsbGlzZWNvbmRzOiAoZGF5c0luWWVhckFjY3VyYXRlICogMjQgKiA2MCAqIDYwICogMTAwMCkgLyA0LFxuICAgIH0sXG4gICAgbW9udGhzOiB7XG4gICAgICB3ZWVrczogZGF5c0luTW9udGhBY2N1cmF0ZSAvIDcsXG4gICAgICBkYXlzOiBkYXlzSW5Nb250aEFjY3VyYXRlLFxuICAgICAgaG91cnM6IGRheXNJbk1vbnRoQWNjdXJhdGUgKiAyNCxcbiAgICAgIG1pbnV0ZXM6IGRheXNJbk1vbnRoQWNjdXJhdGUgKiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogZGF5c0luTW9udGhBY2N1cmF0ZSAqIDI0ICogNjAgKiA2MCxcbiAgICAgIG1pbGxpc2Vjb25kczogZGF5c0luTW9udGhBY2N1cmF0ZSAqIDI0ICogNjAgKiA2MCAqIDEwMDAsXG4gICAgfSxcbiAgICAuLi5sb3dPcmRlck1hdHJpeCxcbiAgfTtcblxuLy8gdW5pdHMgb3JkZXJlZCBieSBzaXplXG5jb25zdCBvcmRlcmVkVW5pdHMgPSBbXG4gIFwieWVhcnNcIixcbiAgXCJxdWFydGVyc1wiLFxuICBcIm1vbnRoc1wiLFxuICBcIndlZWtzXCIsXG4gIFwiZGF5c1wiLFxuICBcImhvdXJzXCIsXG4gIFwibWludXRlc1wiLFxuICBcInNlY29uZHNcIixcbiAgXCJtaWxsaXNlY29uZHNcIixcbl07XG5cbmNvbnN0IHJldmVyc2VVbml0cyA9IG9yZGVyZWRVbml0cy5zbGljZSgwKS5yZXZlcnNlKCk7XG5cbi8vIGNsb25lIHJlYWxseSBtZWFucyBcImNyZWF0ZSBhbm90aGVyIGluc3RhbmNlIGp1c3QgbGlrZSB0aGlzIG9uZSwgYnV0IHdpdGggdGhlc2UgY2hhbmdlc1wiXG5mdW5jdGlvbiBjbG9uZShkdXIsIGFsdHMsIGNsZWFyID0gZmFsc2UpIHtcbiAgLy8gZGVlcCBtZXJnZSBmb3IgdmFsc1xuICBjb25zdCBjb25mID0ge1xuICAgIHZhbHVlczogY2xlYXIgPyBhbHRzLnZhbHVlcyA6IHsgLi4uZHVyLnZhbHVlcywgLi4uKGFsdHMudmFsdWVzIHx8IHt9KSB9LFxuICAgIGxvYzogZHVyLmxvYy5jbG9uZShhbHRzLmxvYyksXG4gICAgY29udmVyc2lvbkFjY3VyYWN5OiBhbHRzLmNvbnZlcnNpb25BY2N1cmFjeSB8fCBkdXIuY29udmVyc2lvbkFjY3VyYWN5LFxuICAgIG1hdHJpeDogYWx0cy5tYXRyaXggfHwgZHVyLm1hdHJpeCxcbiAgfTtcbiAgcmV0dXJuIG5ldyBEdXJhdGlvbihjb25mKTtcbn1cblxuZnVuY3Rpb24gZHVyYXRpb25Ub01pbGxpcyhtYXRyaXgsIHZhbHMpIHtcbiAgbGV0IHN1bSA9IHZhbHMubWlsbGlzZWNvbmRzID8/IDA7XG4gIGZvciAoY29uc3QgdW5pdCBvZiByZXZlcnNlVW5pdHMuc2xpY2UoMSkpIHtcbiAgICBpZiAodmFsc1t1bml0XSkge1xuICAgICAgc3VtICs9IHZhbHNbdW5pdF0gKiBtYXRyaXhbdW5pdF1bXCJtaWxsaXNlY29uZHNcIl07XG4gICAgfVxuICB9XG4gIHJldHVybiBzdW07XG59XG5cbi8vIE5COiBtdXRhdGVzIHBhcmFtZXRlcnNcbmZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlcyhtYXRyaXgsIHZhbHMpIHtcbiAgLy8gdGhlIGxvZ2ljIGJlbG93IGFzc3VtZXMgdGhlIG92ZXJhbGwgdmFsdWUgb2YgdGhlIGR1cmF0aW9uIGlzIHBvc2l0aXZlXG4gIC8vIGlmIHRoaXMgaXMgbm90IHRoZSBjYXNlLCBmYWN0b3IgaXMgdXNlZCB0byBtYWtlIGl0IHNvXG4gIGNvbnN0IGZhY3RvciA9IGR1cmF0aW9uVG9NaWxsaXMobWF0cml4LCB2YWxzKSA8IDAgPyAtMSA6IDE7XG5cbiAgb3JkZXJlZFVuaXRzLnJlZHVjZVJpZ2h0KChwcmV2aW91cywgY3VycmVudCkgPT4ge1xuICAgIGlmICghaXNVbmRlZmluZWQodmFsc1tjdXJyZW50XSkpIHtcbiAgICAgIGlmIChwcmV2aW91cykge1xuICAgICAgICBjb25zdCBwcmV2aW91c1ZhbCA9IHZhbHNbcHJldmlvdXNdICogZmFjdG9yO1xuICAgICAgICBjb25zdCBjb252ID0gbWF0cml4W2N1cnJlbnRdW3ByZXZpb3VzXTtcblxuICAgICAgICAvLyBpZiAocHJldmlvdXNWYWwgPCAwKTpcbiAgICAgICAgLy8gbG93ZXIgb3JkZXIgdW5pdCBpcyBuZWdhdGl2ZSAoZS5nLiB7IHllYXJzOiAyLCBkYXlzOiAtMiB9KVxuICAgICAgICAvLyBub3JtYWxpemUgdGhpcyBieSByZWR1Y2luZyB0aGUgaGlnaGVyIG9yZGVyIHVuaXQgYnkgdGhlIGFwcHJvcHJpYXRlIGFtb3VudFxuICAgICAgICAvLyBhbmQgaW5jcmVhc2luZyB0aGUgbG93ZXIgb3JkZXIgdW5pdFxuICAgICAgICAvLyB0aGlzIGNhbiBuZXZlciBtYWtlIHRoZSBoaWdoZXIgb3JkZXIgdW5pdCBuZWdhdGl2ZSwgYmVjYXVzZSB0aGlzIGZ1bmN0aW9uIG9ubHkgb3BlcmF0ZXNcbiAgICAgICAgLy8gb24gcG9zaXRpdmUgZHVyYXRpb25zLCBzbyB0aGUgYW1vdW50IG9mIHRpbWUgcmVwcmVzZW50ZWQgYnkgdGhlIGxvd2VyIG9yZGVyIHVuaXQgY2Fubm90XG4gICAgICAgIC8vIGJlIGxhcmdlciB0aGFuIHRoZSBoaWdoZXIgb3JkZXIgdW5pdFxuICAgICAgICAvLyBlbHNlOlxuICAgICAgICAvLyBsb3dlciBvcmRlciB1bml0IGlzIHBvc2l0aXZlIChlLmcuIHsgeWVhcnM6IDIsIGRheXM6IDQ1MCB9IG9yIHsgeWVhcnM6IC0yLCBkYXlzOiA0NTAgfSlcbiAgICAgICAgLy8gaW4gdGhpcyBjYXNlIHdlIGF0dGVtcHQgdG8gY29udmVydCBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIGxvd2VyIG9yZGVyIHVuaXQgaW50b1xuICAgICAgICAvLyB0aGUgaGlnaGVyIG9yZGVyIG9uZVxuICAgICAgICAvL1xuICAgICAgICAvLyBNYXRoLmZsb29yIHRha2VzIGNhcmUgb2YgYm90aCBvZiB0aGVzZSBjYXNlcywgcm91bmRpbmcgYXdheSBmcm9tIDBcbiAgICAgICAgLy8gaWYgcHJldmlvdXNWYWwgPCAwIGl0IG1ha2VzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBsYXJnZXJcbiAgICAgICAgLy8gaWYgcHJldmlvdXNWYWwgPj0gaXQgbWFrZXMgdGhlIGFic29sdXRlIHZhbHVlIHNtYWxsZXJcbiAgICAgICAgY29uc3Qgcm9sbFVwID0gTWF0aC5mbG9vcihwcmV2aW91c1ZhbCAvIGNvbnYpO1xuICAgICAgICB2YWxzW2N1cnJlbnRdICs9IHJvbGxVcCAqIGZhY3RvcjtcbiAgICAgICAgdmFsc1twcmV2aW91c10gLT0gcm9sbFVwICogY29udiAqIGZhY3RvcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcHJldmlvdXM7XG4gICAgfVxuICB9LCBudWxsKTtcblxuICAvLyB0cnkgdG8gY29udmVydCBhbnkgZGVjaW1hbHMgaW50byBzbWFsbGVyIHVuaXRzIGlmIHBvc3NpYmxlXG4gIC8vIGZvciBleGFtcGxlIGZvciB7IHllYXJzOiAyLjUsIGRheXM6IDAsIHNlY29uZHM6IDAgfSB3ZSB3YW50IHRvIGdldCB7IHllYXJzOiAyLCBkYXlzOiAxODIsIGhvdXJzOiAxMiB9XG4gIG9yZGVyZWRVbml0cy5yZWR1Y2UoKHByZXZpb3VzLCBjdXJyZW50KSA9PiB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh2YWxzW2N1cnJlbnRdKSkge1xuICAgICAgaWYgKHByZXZpb3VzKSB7XG4gICAgICAgIGNvbnN0IGZyYWN0aW9uID0gdmFsc1twcmV2aW91c10gJSAxO1xuICAgICAgICB2YWxzW3ByZXZpb3VzXSAtPSBmcmFjdGlvbjtcbiAgICAgICAgdmFsc1tjdXJyZW50XSArPSBmcmFjdGlvbiAqIG1hdHJpeFtwcmV2aW91c11bY3VycmVudF07XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHByZXZpb3VzO1xuICAgIH1cbiAgfSwgbnVsbCk7XG59XG5cbi8vIFJlbW92ZSBhbGwgcHJvcGVydGllcyB3aXRoIGEgdmFsdWUgb2YgMCBmcm9tIGFuIG9iamVjdFxuZnVuY3Rpb24gcmVtb3ZlWmVyb2VzKHZhbHMpIHtcbiAgY29uc3QgbmV3VmFscyA9IHt9O1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh2YWxzKSkge1xuICAgIGlmICh2YWx1ZSAhPT0gMCkge1xuICAgICAgbmV3VmFsc1trZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXdWYWxzO1xufVxuXG4vKipcbiAqIEEgRHVyYXRpb24gb2JqZWN0IHJlcHJlc2VudHMgYSBwZXJpb2Qgb2YgdGltZSwgbGlrZSBcIjIgbW9udGhzXCIgb3IgXCIxIGRheSwgMSBob3VyXCIuIENvbmNlcHR1YWxseSwgaXQncyBqdXN0IGEgbWFwIG9mIHVuaXRzIHRvIHRoZWlyIHF1YW50aXRpZXMsIGFjY29tcGFuaWVkIGJ5IHNvbWUgYWRkaXRpb25hbCBjb25maWd1cmF0aW9uIGFuZCBtZXRob2RzIGZvciBjcmVhdGluZywgcGFyc2luZywgaW50ZXJyb2dhdGluZywgdHJhbnNmb3JtaW5nLCBhbmQgZm9ybWF0dGluZyB0aGVtLiBUaGV5IGNhbiBiZSB1c2VkIG9uIHRoZWlyIG93biBvciBpbiBjb25qdW5jdGlvbiB3aXRoIG90aGVyIEx1eG9uIHR5cGVzOyBmb3IgZXhhbXBsZSwgeW91IGNhbiB1c2Uge0BsaW5rIERhdGVUaW1lI3BsdXN9IHRvIGFkZCBhIER1cmF0aW9uIG9iamVjdCB0byBhIERhdGVUaW1lLCBwcm9kdWNpbmcgYW5vdGhlciBEYXRlVGltZS5cbiAqXG4gKiBIZXJlIGlzIGEgYnJpZWYgb3ZlcnZpZXcgb2YgY29tbW9ubHkgdXNlZCBtZXRob2RzIGFuZCBnZXR0ZXJzIGluIER1cmF0aW9uOlxuICpcbiAqICogKipDcmVhdGlvbioqIFRvIGNyZWF0ZSBhIER1cmF0aW9uLCB1c2Uge0BsaW5rIER1cmF0aW9uLmZyb21NaWxsaXN9LCB7QGxpbmsgRHVyYXRpb24uZnJvbU9iamVjdH0sIG9yIHtAbGluayBEdXJhdGlvbi5mcm9tSVNPfS5cbiAqICogKipVbml0IHZhbHVlcyoqIFNlZSB0aGUge0BsaW5rIER1cmF0aW9uI3llYXJzfSwge0BsaW5rIER1cmF0aW9uI21vbnRoc30sIHtAbGluayBEdXJhdGlvbiN3ZWVrc30sIHtAbGluayBEdXJhdGlvbiNkYXlzfSwge0BsaW5rIER1cmF0aW9uI2hvdXJzfSwge0BsaW5rIER1cmF0aW9uI21pbnV0ZXN9LCB7QGxpbmsgRHVyYXRpb24jc2Vjb25kc30sIHtAbGluayBEdXJhdGlvbiNtaWxsaXNlY29uZHN9IGFjY2Vzc29ycy5cbiAqICogKipDb25maWd1cmF0aW9uKiogU2VlICB7QGxpbmsgRHVyYXRpb24jbG9jYWxlfSBhbmQge0BsaW5rIER1cmF0aW9uI251bWJlcmluZ1N5c3RlbX0gYWNjZXNzb3JzLlxuICogKiAqKlRyYW5zZm9ybWF0aW9uKiogVG8gY3JlYXRlIG5ldyBEdXJhdGlvbnMgb3V0IG9mIG9sZCBvbmVzIHVzZSB7QGxpbmsgRHVyYXRpb24jcGx1c30sIHtAbGluayBEdXJhdGlvbiNtaW51c30sIHtAbGluayBEdXJhdGlvbiNub3JtYWxpemV9LCB7QGxpbmsgRHVyYXRpb24jc2V0fSwge0BsaW5rIER1cmF0aW9uI3JlY29uZmlndXJlfSwge0BsaW5rIER1cmF0aW9uI3NoaWZ0VG99LCBhbmQge0BsaW5rIER1cmF0aW9uI25lZ2F0ZX0uXG4gKiAqICoqT3V0cHV0KiogVG8gY29udmVydCB0aGUgRHVyYXRpb24gaW50byBvdGhlciByZXByZXNlbnRhdGlvbnMsIHNlZSB7QGxpbmsgRHVyYXRpb24jYXN9LCB7QGxpbmsgRHVyYXRpb24jdG9JU099LCB7QGxpbmsgRHVyYXRpb24jdG9Gb3JtYXR9LCBhbmQge0BsaW5rIER1cmF0aW9uI3RvSlNPTn1cbiAqXG4gKiBUaGVyZSdzIGFyZSBtb3JlIG1ldGhvZHMgZG9jdW1lbnRlZCBiZWxvdy4gSW4gYWRkaXRpb24sIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHN1YnRsZXIgdG9waWNzIGxpa2UgaW50ZXJuYXRpb25hbGl6YXRpb24gYW5kIHZhbGlkaXR5LCBzZWUgdGhlIGV4dGVybmFsIGRvY3VtZW50YXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIER1cmF0aW9uIHtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBjb25zdCBhY2N1cmF0ZSA9IGNvbmZpZy5jb252ZXJzaW9uQWNjdXJhY3kgPT09IFwibG9uZ3Rlcm1cIiB8fCBmYWxzZTtcbiAgICBsZXQgbWF0cml4ID0gYWNjdXJhdGUgPyBhY2N1cmF0ZU1hdHJpeCA6IGNhc3VhbE1hdHJpeDtcblxuICAgIGlmIChjb25maWcubWF0cml4KSB7XG4gICAgICBtYXRyaXggPSBjb25maWcubWF0cml4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudmFsdWVzID0gY29uZmlnLnZhbHVlcztcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmxvYyA9IGNvbmZpZy5sb2MgfHwgTG9jYWxlLmNyZWF0ZSgpO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuY29udmVyc2lvbkFjY3VyYWN5ID0gYWNjdXJhdGUgPyBcImxvbmd0ZXJtXCIgOiBcImNhc3VhbFwiO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaW52YWxpZCA9IGNvbmZpZy5pbnZhbGlkIHx8IG51bGw7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5tYXRyaXggPSBtYXRyaXg7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5pc0x1eG9uRHVyYXRpb24gPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBEdXJhdGlvbiBmcm9tIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IG9mIG1pbGxpc2Vjb25kc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgZm9yIHBhcnNpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nZW4tVVMnXSAtIHRoZSBsb2NhbGUgdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29udmVyc2lvbkFjY3VyYWN5PSdjYXN1YWwnXSAtIHRoZSBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzdGF0aWMgZnJvbU1pbGxpcyhjb3VudCwgb3B0cykge1xuICAgIHJldHVybiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbWlsbGlzZWNvbmRzOiBjb3VudCB9LCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEdXJhdGlvbiBmcm9tIGEgSmF2YVNjcmlwdCBvYmplY3Qgd2l0aCBrZXlzIGxpa2UgJ3llYXJzJyBhbmQgJ2hvdXJzJy5cbiAgICogSWYgdGhpcyBvYmplY3QgaXMgZW1wdHkgdGhlbiBhIHplcm8gbWlsbGlzZWNvbmRzIGR1cmF0aW9uIGlzIHJldHVybmVkLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gdGhlIG9iamVjdCB0byBjcmVhdGUgdGhlIERhdGVUaW1lIGZyb21cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai55ZWFyc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLnF1YXJ0ZXJzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoubW9udGhzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoud2Vla3NcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5kYXlzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmouaG91cnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5taW51dGVzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmouc2Vjb25kc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLm1pbGxpc2Vjb25kc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHM9W11dIC0gb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGhpcyBEdXJhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdlbi1VUyddIC0gdGhlIGxvY2FsZSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5jb252ZXJzaW9uQWNjdXJhY3k9J2Nhc3VhbCddIC0gdGhlIHByZXNldCBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm1hdHJpeD1PYmplY3RdIC0gdGhlIGN1c3RvbSBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzdGF0aWMgZnJvbU9iamVjdChvYmosIG9wdHMgPSB7fSkge1xuICAgIGlmIChvYmogPT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXG4gICAgICAgIGBEdXJhdGlvbi5mcm9tT2JqZWN0OiBhcmd1bWVudCBleHBlY3RlZCB0byBiZSBhbiBvYmplY3QsIGdvdCAke1xuICAgICAgICAgIG9iaiA9PT0gbnVsbCA/IFwibnVsbFwiIDogdHlwZW9mIG9ialxuICAgICAgICB9YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IER1cmF0aW9uKHtcbiAgICAgIHZhbHVlczogbm9ybWFsaXplT2JqZWN0KG9iaiwgRHVyYXRpb24ubm9ybWFsaXplVW5pdCksXG4gICAgICBsb2M6IExvY2FsZS5mcm9tT2JqZWN0KG9wdHMpLFxuICAgICAgY29udmVyc2lvbkFjY3VyYWN5OiBvcHRzLmNvbnZlcnNpb25BY2N1cmFjeSxcbiAgICAgIG1hdHJpeDogb3B0cy5tYXRyaXgsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRHVyYXRpb24gZnJvbSBEdXJhdGlvbkxpa2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0IHwgbnVtYmVyIHwgRHVyYXRpb259IGR1cmF0aW9uTGlrZVxuICAgKiBPbmUgb2Y6XG4gICAqIC0gb2JqZWN0IHdpdGgga2V5cyBsaWtlICd5ZWFycycgYW5kICdob3VycycuXG4gICAqIC0gbnVtYmVyIHJlcHJlc2VudGluZyBtaWxsaXNlY29uZHNcbiAgICogLSBEdXJhdGlvbiBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHN0YXRpYyBmcm9tRHVyYXRpb25MaWtlKGR1cmF0aW9uTGlrZSkge1xuICAgIGlmIChpc051bWJlcihkdXJhdGlvbkxpa2UpKSB7XG4gICAgICByZXR1cm4gRHVyYXRpb24uZnJvbU1pbGxpcyhkdXJhdGlvbkxpa2UpO1xuICAgIH0gZWxzZSBpZiAoRHVyYXRpb24uaXNEdXJhdGlvbihkdXJhdGlvbkxpa2UpKSB7XG4gICAgICByZXR1cm4gZHVyYXRpb25MaWtlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGR1cmF0aW9uTGlrZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmZyb21PYmplY3QoZHVyYXRpb25MaWtlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFxuICAgICAgICBgVW5rbm93biBkdXJhdGlvbiBhcmd1bWVudCAke2R1cmF0aW9uTGlrZX0gb2YgdHlwZSAke3R5cGVvZiBkdXJhdGlvbkxpa2V9YFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRHVyYXRpb24gZnJvbSBhbiBJU08gODYwMSBkdXJhdGlvbiBzdHJpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGV4dCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgZm9yIHBhcnNpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nZW4tVVMnXSAtIHRoZSBsb2NhbGUgdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29udmVyc2lvbkFjY3VyYWN5PSdjYXN1YWwnXSAtIHRoZSBwcmVzZXQgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5tYXRyaXg9T2JqZWN0XSAtIHRoZSBwcmVzZXQgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjRHVyYXRpb25zXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU08oJ1AzWTZNMVc0RFQxMkgzME01UycpLnRvT2JqZWN0KCkgLy89PiB7IHllYXJzOiAzLCBtb250aHM6IDYsIHdlZWtzOiAxLCBkYXlzOiA0LCBob3VyczogMTIsIG1pbnV0ZXM6IDMwLCBzZWNvbmRzOiA1IH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTTygnUFQyM0gnKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMjMgfVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tSVNPKCdQNVkzTScpLnRvT2JqZWN0KCkgLy89PiB7IHllYXJzOiA1LCBtb250aHM6IDMgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHN0YXRpYyBmcm9tSVNPKHRleHQsIG9wdHMpIHtcbiAgICBjb25zdCBbcGFyc2VkXSA9IHBhcnNlSVNPRHVyYXRpb24odGV4dCk7XG4gICAgaWYgKHBhcnNlZCkge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmZyb21PYmplY3QocGFyc2VkLCBvcHRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmludmFsaWQoXCJ1bnBhcnNhYmxlXCIsIGB0aGUgaW5wdXQgXCIke3RleHR9XCIgY2FuJ3QgYmUgcGFyc2VkIGFzIElTTyA4NjAxYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIER1cmF0aW9uIGZyb20gYW4gSVNPIDg2MDEgdGltZSBzdHJpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGV4dCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgZm9yIHBhcnNpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nZW4tVVMnXSAtIHRoZSBsb2NhbGUgdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29udmVyc2lvbkFjY3VyYWN5PSdjYXN1YWwnXSAtIHRoZSBwcmVzZXQgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5tYXRyaXg9T2JqZWN0XSAtIHRoZSBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSNUaW1lc1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tSVNPVGltZSgnMTE6MjI6MzMuNDQ0JykudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDExLCBtaW51dGVzOiAyMiwgc2Vjb25kczogMzMsIG1pbGxpc2Vjb25kczogNDQ0IH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTT1RpbWUoJzExOjAwJykudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDExLCBtaW51dGVzOiAwLCBzZWNvbmRzOiAwIH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTT1RpbWUoJ1QxMTowMCcpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMSwgbWludXRlczogMCwgc2Vjb25kczogMCB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU09UaW1lKCcxMTAwJykudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDExLCBtaW51dGVzOiAwLCBzZWNvbmRzOiAwIH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTT1RpbWUoJ1QxMTAwJykudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDExLCBtaW51dGVzOiAwLCBzZWNvbmRzOiAwIH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzdGF0aWMgZnJvbUlTT1RpbWUodGV4dCwgb3B0cykge1xuICAgIGNvbnN0IFtwYXJzZWRdID0gcGFyc2VJU09UaW1lT25seSh0ZXh0KTtcbiAgICBpZiAocGFyc2VkKSB7XG4gICAgICByZXR1cm4gRHVyYXRpb24uZnJvbU9iamVjdChwYXJzZWQsIG9wdHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gRHVyYXRpb24uaW52YWxpZChcInVucGFyc2FibGVcIiwgYHRoZSBpbnB1dCBcIiR7dGV4dH1cIiBjYW4ndCBiZSBwYXJzZWQgYXMgSVNPIDg2MDFgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGludmFsaWQgRHVyYXRpb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb24gLSBzaW1wbGUgc3RyaW5nIG9mIHdoeSB0aGlzIGRhdGV0aW1lIGlzIGludmFsaWQuIFNob3VsZCBub3QgY29udGFpbiBwYXJhbWV0ZXJzIG9yIGFueXRoaW5nIGVsc2UgZGF0YS1kZXBlbmRlbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtleHBsYW5hdGlvbj1udWxsXSAtIGxvbmdlciBleHBsYW5hdGlvbiwgbWF5IGluY2x1ZGUgcGFyYW1ldGVycyBhbmQgb3RoZXIgdXNlZnVsIGRlYnVnZ2luZyBpbmZvcm1hdGlvblxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHN0YXRpYyBpbnZhbGlkKHJlYXNvbiwgZXhwbGFuYXRpb24gPSBudWxsKSB7XG4gICAgaWYgKCFyZWFzb24pIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIm5lZWQgdG8gc3BlY2lmeSBhIHJlYXNvbiB0aGUgRHVyYXRpb24gaXMgaW52YWxpZFwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnZhbGlkID0gcmVhc29uIGluc3RhbmNlb2YgSW52YWxpZCA/IHJlYXNvbiA6IG5ldyBJbnZhbGlkKHJlYXNvbiwgZXhwbGFuYXRpb24pO1xuXG4gICAgaWYgKFNldHRpbmdzLnRocm93T25JbnZhbGlkKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZER1cmF0aW9uRXJyb3IoaW52YWxpZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgRHVyYXRpb24oeyBpbnZhbGlkIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhdGljIG5vcm1hbGl6ZVVuaXQodW5pdCkge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSB7XG4gICAgICB5ZWFyOiBcInllYXJzXCIsXG4gICAgICB5ZWFyczogXCJ5ZWFyc1wiLFxuICAgICAgcXVhcnRlcjogXCJxdWFydGVyc1wiLFxuICAgICAgcXVhcnRlcnM6IFwicXVhcnRlcnNcIixcbiAgICAgIG1vbnRoOiBcIm1vbnRoc1wiLFxuICAgICAgbW9udGhzOiBcIm1vbnRoc1wiLFxuICAgICAgd2VlazogXCJ3ZWVrc1wiLFxuICAgICAgd2Vla3M6IFwid2Vla3NcIixcbiAgICAgIGRheTogXCJkYXlzXCIsXG4gICAgICBkYXlzOiBcImRheXNcIixcbiAgICAgIGhvdXI6IFwiaG91cnNcIixcbiAgICAgIGhvdXJzOiBcImhvdXJzXCIsXG4gICAgICBtaW51dGU6IFwibWludXRlc1wiLFxuICAgICAgbWludXRlczogXCJtaW51dGVzXCIsXG4gICAgICBzZWNvbmQ6IFwic2Vjb25kc1wiLFxuICAgICAgc2Vjb25kczogXCJzZWNvbmRzXCIsXG4gICAgICBtaWxsaXNlY29uZDogXCJtaWxsaXNlY29uZHNcIixcbiAgICAgIG1pbGxpc2Vjb25kczogXCJtaWxsaXNlY29uZHNcIixcbiAgICB9W3VuaXQgPyB1bml0LnRvTG93ZXJDYXNlKCkgOiB1bml0XTtcblxuICAgIGlmICghbm9ybWFsaXplZCkgdGhyb3cgbmV3IEludmFsaWRVbml0RXJyb3IodW5pdCk7XG5cbiAgICByZXR1cm4gbm9ybWFsaXplZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBvYmplY3QgaXMgYSBEdXJhdGlvbi4gV29ya3MgYWNyb3NzIGNvbnRleHQgYm91bmRhcmllc1xuICAgKiBAcGFyYW0ge29iamVjdH0gb1xuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzRHVyYXRpb24obykge1xuICAgIHJldHVybiAobyAmJiBvLmlzTHV4b25EdXJhdGlvbikgfHwgZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0ICB0aGUgbG9jYWxlIG9mIGEgRHVyYXRpb24sIHN1Y2ggJ2VuLUdCJ1xuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGxvY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5sb2MubG9jYWxlIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG51bWJlcmluZyBzeXN0ZW0gb2YgYSBEdXJhdGlvbiwgc3VjaCAnYmVuZycuIFRoZSBudW1iZXJpbmcgc3lzdGVtIGlzIHVzZWQgd2hlbiBmb3JtYXR0aW5nIHRoZSBEdXJhdGlvblxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG51bWJlcmluZ1N5c3RlbSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5sb2MubnVtYmVyaW5nU3lzdGVtIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRHVyYXRpb24gZm9ybWF0dGVkIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIGZvcm1hdCBzdHJpbmcuIFlvdSBtYXkgdXNlIHRoZXNlIHRva2VuczpcbiAgICogKiBgU2AgZm9yIG1pbGxpc2Vjb25kc1xuICAgKiAqIGBzYCBmb3Igc2Vjb25kc1xuICAgKiAqIGBtYCBmb3IgbWludXRlc1xuICAgKiAqIGBoYCBmb3IgaG91cnNcbiAgICogKiBgZGAgZm9yIGRheXNcbiAgICogKiBgd2AgZm9yIHdlZWtzXG4gICAqICogYE1gIGZvciBtb250aHNcbiAgICogKiBgeWAgZm9yIHllYXJzXG4gICAqIE5vdGVzOlxuICAgKiAqIEFkZCBwYWRkaW5nIGJ5IHJlcGVhdGluZyB0aGUgdG9rZW4sIGUuZy4gXCJ5eVwiIHBhZHMgdGhlIHllYXJzIHRvIHR3byBkaWdpdHMsIFwiaGhoaFwiIHBhZHMgdGhlIGhvdXJzIG91dCB0byBmb3VyIGRpZ2l0c1xuICAgKiAqIFRva2VucyBjYW4gYmUgZXNjYXBlZCBieSB3cmFwcGluZyB3aXRoIHNpbmdsZSBxdW90ZXMuXG4gICAqICogVGhlIGR1cmF0aW9uIHdpbGwgYmUgY29udmVydGVkIHRvIHRoZSBzZXQgb2YgdW5pdHMgaW4gdGhlIGZvcm1hdCBzdHJpbmcgdXNpbmcge0BsaW5rIER1cmF0aW9uI3NoaWZ0VG99IGFuZCB0aGUgRHVyYXRpb25zJ3MgY29udmVyc2lvbiBhY2N1cmFjeSBzZXR0aW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm10IC0gdGhlIGZvcm1hdCBzdHJpbmdcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuZmxvb3I9dHJ1ZV0gLSBmbG9vciBudW1lcmljYWwgdmFsdWVzXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMSwgZGF5czogNiwgc2Vjb25kczogMiB9KS50b0Zvcm1hdChcInkgZCBzXCIpIC8vPT4gXCIxIDYgMlwiXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMSwgZGF5czogNiwgc2Vjb25kczogMiB9KS50b0Zvcm1hdChcInl5IGRkIHNzc1wiKSAvLz0+IFwiMDEgMDYgMDAyXCJcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IHllYXJzOiAxLCBkYXlzOiA2LCBzZWNvbmRzOiAyIH0pLnRvRm9ybWF0KFwiTSBTXCIpIC8vPT4gXCIxMiA1MTg0MDIwMDBcIlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0Zvcm1hdChmbXQsIG9wdHMgPSB7fSkge1xuICAgIC8vIHJldmVyc2UtY29tcGF0IHNpbmNlIDEuMjsgd2UgYWx3YXlzIHJvdW5kIGRvd24gbm93LCBuZXZlciB1cCwgYW5kIHdlIGRvIGl0IGJ5IGRlZmF1bHRcbiAgICBjb25zdCBmbXRPcHRzID0ge1xuICAgICAgLi4ub3B0cyxcbiAgICAgIGZsb29yOiBvcHRzLnJvdW5kICE9PSBmYWxzZSAmJiBvcHRzLmZsb29yICE9PSBmYWxzZSxcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWRcbiAgICAgID8gRm9ybWF0dGVyLmNyZWF0ZSh0aGlzLmxvYywgZm10T3B0cykuZm9ybWF0RHVyYXRpb25Gcm9tU3RyaW5nKHRoaXMsIGZtdClcbiAgICAgIDogSU5WQUxJRDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgRHVyYXRpb24gd2l0aCBhbGwgdW5pdHMgaW5jbHVkZWQuXG4gICAqIFRvIG1vZGlmeSBpdHMgYmVoYXZpb3IgdXNlIHRoZSBgbGlzdFN0eWxlYCBhbmQgYW55IEludGwuTnVtYmVyRm9ybWF0IG9wdGlvbiwgdGhvdWdoIGB1bml0RGlzcGxheWAgaXMgZXNwZWNpYWxseSByZWxldmFudC5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9JbnRsL051bWJlckZvcm1hdFxuICAgKiBAcGFyYW0gb3B0cyAtIE9uIG9wdGlvbiBvYmplY3QgdG8gb3ZlcnJpZGUgdGhlIGZvcm1hdHRpbmcuIEFjY2VwdHMgdGhlIHNhbWUga2V5cyBhcyB0aGUgb3B0aW9ucyBwYXJhbWV0ZXIgb2YgdGhlIG5hdGl2ZSBgSW50Lk51bWJlckZvcm1hdGAgY29uc3RydWN0b3IsIGFzIHdlbGwgYXMgYGxpc3RTdHlsZWAuXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIHZhciBkdXIgPSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgZGF5czogMSwgaG91cnM6IDUsIG1pbnV0ZXM6IDYgfSlcbiAgICogZHVyLnRvSHVtYW4oKSAvLz0+ICcxIGRheSwgNSBob3VycywgNiBtaW51dGVzJ1xuICAgKiBkdXIudG9IdW1hbih7IGxpc3RTdHlsZTogXCJsb25nXCIgfSkgLy89PiAnMSBkYXksIDUgaG91cnMsIGFuZCA2IG1pbnV0ZXMnXG4gICAqIGR1ci50b0h1bWFuKHsgdW5pdERpc3BsYXk6IFwic2hvcnRcIiB9KSAvLz0+ICcxIGRheSwgNSBociwgNiBtaW4nXG4gICAqIGBgYFxuICAgKi9cbiAgdG9IdW1hbihvcHRzID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIElOVkFMSUQ7XG5cbiAgICBjb25zdCBsID0gb3JkZXJlZFVuaXRzXG4gICAgICAubWFwKCh1bml0KSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbCA9IHRoaXMudmFsdWVzW3VuaXRdO1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxvY1xuICAgICAgICAgIC5udW1iZXJGb3JtYXR0ZXIoeyBzdHlsZTogXCJ1bml0XCIsIHVuaXREaXNwbGF5OiBcImxvbmdcIiwgLi4ub3B0cywgdW5pdDogdW5pdC5zbGljZSgwLCAtMSkgfSlcbiAgICAgICAgICAuZm9ybWF0KHZhbCk7XG4gICAgICB9KVxuICAgICAgLmZpbHRlcigobikgPT4gbik7XG5cbiAgICByZXR1cm4gdGhpcy5sb2NcbiAgICAgIC5saXN0Rm9ybWF0dGVyKHsgdHlwZTogXCJjb25qdW5jdGlvblwiLCBzdHlsZTogb3B0cy5saXN0U3R5bGUgfHwgXCJuYXJyb3dcIiwgLi4ub3B0cyB9KVxuICAgICAgLmZvcm1hdChsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgSmF2YVNjcmlwdCBvYmplY3Qgd2l0aCB0aGlzIER1cmF0aW9uJ3MgdmFsdWVzLlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgeWVhcnM6IDEsIGRheXM6IDYsIHNlY29uZHM6IDIgfSkudG9PYmplY3QoKSAvLz0+IHsgeWVhcnM6IDEsIGRheXM6IDYsIHNlY29uZHM6IDIgfVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICB0b09iamVjdCgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHt9O1xuICAgIHJldHVybiB7IC4uLnRoaXMudmFsdWVzIH07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRHVyYXRpb24uXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjRHVyYXRpb25zXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMywgc2Vjb25kczogNDUgfSkudG9JU08oKSAvLz0+ICdQM1lUNDVTJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbW9udGhzOiA0LCBzZWNvbmRzOiA0NSB9KS50b0lTTygpIC8vPT4gJ1A0TVQ0NVMnXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBtb250aHM6IDUgfSkudG9JU08oKSAvLz0+ICdQNU0nXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBtaW51dGVzOiA1IH0pLnRvSVNPKCkgLy89PiAnUFQ1TSdcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IG1pbGxpc2Vjb25kczogNiB9KS50b0lTTygpIC8vPT4gJ1BUMC4wMDZTJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0lTTygpIHtcbiAgICAvLyB3ZSBjb3VsZCB1c2UgdGhlIGZvcm1hdHRlciwgYnV0IHRoaXMgaXMgYW4gZWFzaWVyIHdheSB0byBnZXQgdGhlIG1pbmltdW0gc3RyaW5nXG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBudWxsO1xuXG4gICAgbGV0IHMgPSBcIlBcIjtcbiAgICBpZiAodGhpcy55ZWFycyAhPT0gMCkgcyArPSB0aGlzLnllYXJzICsgXCJZXCI7XG4gICAgaWYgKHRoaXMubW9udGhzICE9PSAwIHx8IHRoaXMucXVhcnRlcnMgIT09IDApIHMgKz0gdGhpcy5tb250aHMgKyB0aGlzLnF1YXJ0ZXJzICogMyArIFwiTVwiO1xuICAgIGlmICh0aGlzLndlZWtzICE9PSAwKSBzICs9IHRoaXMud2Vla3MgKyBcIldcIjtcbiAgICBpZiAodGhpcy5kYXlzICE9PSAwKSBzICs9IHRoaXMuZGF5cyArIFwiRFwiO1xuICAgIGlmICh0aGlzLmhvdXJzICE9PSAwIHx8IHRoaXMubWludXRlcyAhPT0gMCB8fCB0aGlzLnNlY29uZHMgIT09IDAgfHwgdGhpcy5taWxsaXNlY29uZHMgIT09IDApXG4gICAgICBzICs9IFwiVFwiO1xuICAgIGlmICh0aGlzLmhvdXJzICE9PSAwKSBzICs9IHRoaXMuaG91cnMgKyBcIkhcIjtcbiAgICBpZiAodGhpcy5taW51dGVzICE9PSAwKSBzICs9IHRoaXMubWludXRlcyArIFwiTVwiO1xuICAgIGlmICh0aGlzLnNlY29uZHMgIT09IDAgfHwgdGhpcy5taWxsaXNlY29uZHMgIT09IDApXG4gICAgICAvLyB0aGlzIHdpbGwgaGFuZGxlIFwiZmxvYXRpbmcgcG9pbnQgbWFkbmVzc1wiIGJ5IHJlbW92aW5nIGV4dHJhIGRlY2ltYWwgcGxhY2VzXG4gICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81ODgwMDQvaXMtZmxvYXRpbmctcG9pbnQtbWF0aC1icm9rZW5cbiAgICAgIHMgKz0gcm91bmRUbyh0aGlzLnNlY29uZHMgKyB0aGlzLm1pbGxpc2Vjb25kcyAvIDEwMDAsIDMpICsgXCJTXCI7XG4gICAgaWYgKHMgPT09IFwiUFwiKSBzICs9IFwiVDBTXCI7XG4gICAgcmV0dXJuIHM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRHVyYXRpb24sIGZvcm1hdHRlZCBhcyBhIHRpbWUgb2YgZGF5LlxuICAgKiBOb3RlIHRoYXQgdGhpcyB3aWxsIHJldHVybiBudWxsIGlmIHRoZSBkdXJhdGlvbiBpcyBpbnZhbGlkLCBuZWdhdGl2ZSwgb3IgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIDI0IGhvdXJzLlxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI1RpbWVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnN1cHByZXNzTWlsbGlzZWNvbmRzPWZhbHNlXSAtIGV4Y2x1ZGUgbWlsbGlzZWNvbmRzIGZyb20gdGhlIGZvcm1hdCBpZiB0aGV5J3JlIDBcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zdXBwcmVzc1NlY29uZHM9ZmFsc2VdIC0gZXhjbHVkZSBzZWNvbmRzIGZyb20gdGhlIGZvcm1hdCBpZiB0aGV5J3JlIDBcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlUHJlZml4PWZhbHNlXSAtIGluY2x1ZGUgdGhlIGBUYCBwcmVmaXhcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmZvcm1hdD0nZXh0ZW5kZWQnXSAtIGNob29zZSBiZXR3ZWVuIHRoZSBiYXNpYyBhbmQgZXh0ZW5kZWQgZm9ybWF0XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMTEgfSkudG9JU09UaW1lKCkgLy89PiAnMTE6MDA6MDAuMDAwJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDExIH0pLnRvSVNPVGltZSh7IHN1cHByZXNzTWlsbGlzZWNvbmRzOiB0cnVlIH0pIC8vPT4gJzExOjAwOjAwJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDExIH0pLnRvSVNPVGltZSh7IHN1cHByZXNzU2Vjb25kczogdHJ1ZSB9KSAvLz0+ICcxMTowMCdcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxMSB9KS50b0lTT1RpbWUoeyBpbmNsdWRlUHJlZml4OiB0cnVlIH0pIC8vPT4gJ1QxMTowMDowMC4wMDAnXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMTEgfSkudG9JU09UaW1lKHsgZm9ybWF0OiAnYmFzaWMnIH0pIC8vPT4gJzExMDAwMC4wMDAnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSVNPVGltZShvcHRzID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIG51bGw7XG5cbiAgICBjb25zdCBtaWxsaXMgPSB0aGlzLnRvTWlsbGlzKCk7XG4gICAgaWYgKG1pbGxpcyA8IDAgfHwgbWlsbGlzID49IDg2NDAwMDAwKSByZXR1cm4gbnVsbDtcblxuICAgIG9wdHMgPSB7XG4gICAgICBzdXBwcmVzc01pbGxpc2Vjb25kczogZmFsc2UsXG4gICAgICBzdXBwcmVzc1NlY29uZHM6IGZhbHNlLFxuICAgICAgaW5jbHVkZVByZWZpeDogZmFsc2UsXG4gICAgICBmb3JtYXQ6IFwiZXh0ZW5kZWRcIixcbiAgICAgIC4uLm9wdHMsXG4gICAgICBpbmNsdWRlT2Zmc2V0OiBmYWxzZSxcbiAgICB9O1xuXG4gICAgY29uc3QgZGF0ZVRpbWUgPSBEYXRlVGltZS5mcm9tTWlsbGlzKG1pbGxpcywgeyB6b25lOiBcIlVUQ1wiIH0pO1xuICAgIHJldHVybiBkYXRlVGltZS50b0lTT1RpbWUob3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIER1cmF0aW9uIGFwcHJvcHJpYXRlIGZvciB1c2UgaW4gSlNPTi5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvSVNPKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIER1cmF0aW9uIGFwcHJvcHJpYXRlIGZvciB1c2UgaW4gZGVidWdnaW5nLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy50b0lTTygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gbWlsbGlzZWNvbmRzIHZhbHVlIG9mIHRoaXMgRHVyYXRpb24uXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHRvTWlsbGlzKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gTmFOO1xuXG4gICAgcmV0dXJuIGR1cmF0aW9uVG9NaWxsaXModGhpcy5tYXRyaXgsIHRoaXMudmFsdWVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG1pbGxpc2Vjb25kcyB2YWx1ZSBvZiB0aGlzIER1cmF0aW9uLiBBbGlhcyBvZiB7QGxpbmsgdG9NaWxsaXN9XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHZhbHVlT2YoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9NaWxsaXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIHRoaXMgRHVyYXRpb24gbG9uZ2VyIGJ5IHRoZSBzcGVjaWZpZWQgYW1vdW50LiBSZXR1cm4gYSBuZXdseS1jb25zdHJ1Y3RlZCBEdXJhdGlvbi5cbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSBhbW91bnQgdG8gYWRkLiBFaXRoZXIgYSBMdXhvbiBEdXJhdGlvbiwgYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCB0aGUgb2JqZWN0IGFyZ3VtZW50IHRvIER1cmF0aW9uLmZyb21PYmplY3QoKVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHBsdXMoZHVyYXRpb24pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG5cbiAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tRHVyYXRpb25MaWtlKGR1cmF0aW9uKSxcbiAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgZm9yIChjb25zdCBrIG9mIG9yZGVyZWRVbml0cykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5KGR1ci52YWx1ZXMsIGspIHx8IGhhc093blByb3BlcnR5KHRoaXMudmFsdWVzLCBrKSkge1xuICAgICAgICByZXN1bHRba10gPSBkdXIuZ2V0KGspICsgdGhpcy5nZXQoayk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIHsgdmFsdWVzOiByZXN1bHQgfSwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogTWFrZSB0aGlzIER1cmF0aW9uIHNob3J0ZXIgYnkgdGhlIHNwZWNpZmllZCBhbW91bnQuIFJldHVybiBhIG5ld2x5LWNvbnN0cnVjdGVkIER1cmF0aW9uLlxuICAgKiBAcGFyYW0ge0R1cmF0aW9ufE9iamVjdHxudW1iZXJ9IGR1cmF0aW9uIC0gVGhlIGFtb3VudCB0byBzdWJ0cmFjdC4gRWl0aGVyIGEgTHV4b24gRHVyYXRpb24sIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgdGhlIG9iamVjdCBhcmd1bWVudCB0byBEdXJhdGlvbi5mcm9tT2JqZWN0KClcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBtaW51cyhkdXJhdGlvbikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcblxuICAgIGNvbnN0IGR1ciA9IER1cmF0aW9uLmZyb21EdXJhdGlvbkxpa2UoZHVyYXRpb24pO1xuICAgIHJldHVybiB0aGlzLnBsdXMoZHVyLm5lZ2F0ZSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTY2FsZSB0aGlzIER1cmF0aW9uIGJ5IHRoZSBzcGVjaWZpZWQgYW1vdW50LiBSZXR1cm4gYSBuZXdseS1jb25zdHJ1Y3RlZCBEdXJhdGlvbi5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gLSBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCB1bml0LiBBcml0eSBpcyAxIG9yIDI6IHRoZSB2YWx1ZSBvZiB0aGUgdW5pdCBhbmQsIG9wdGlvbmFsbHksIHRoZSB1bml0IG5hbWUuIE11c3QgcmV0dXJuIGEgbnVtYmVyLlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDEsIG1pbnV0ZXM6IDMwIH0pLm1hcFVuaXRzKHggPT4geCAqIDIpIC8vPT4geyBob3VyczogMiwgbWludXRlczogNjAgfVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDEsIG1pbnV0ZXM6IDMwIH0pLm1hcFVuaXRzKCh4LCB1KSA9PiB1ID09PSBcImhvdXJzXCIgPyB4ICogMiA6IHgpIC8vPT4geyBob3VyczogMiwgbWludXRlczogMzAgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIG1hcFVuaXRzKGZuKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyh0aGlzLnZhbHVlcykpIHtcbiAgICAgIHJlc3VsdFtrXSA9IGFzTnVtYmVyKGZuKHRoaXMudmFsdWVzW2tdLCBrKSk7XG4gICAgfVxuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHZhbHVlczogcmVzdWx0IH0sIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgb2YgdW5pdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSBhIHVuaXQgc3VjaCBhcyAnbWludXRlJyBvciAnZGF5J1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHt5ZWFyczogMiwgZGF5czogM30pLmdldCgneWVhcnMnKSAvLz0+IDJcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7eWVhcnM6IDIsIGRheXM6IDN9KS5nZXQoJ21vbnRocycpIC8vPT4gMFxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHt5ZWFyczogMiwgZGF5czogM30pLmdldCgnZGF5cycpIC8vPT4gM1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXQodW5pdCkge1xuICAgIHJldHVybiB0aGlzW0R1cmF0aW9uLm5vcm1hbGl6ZVVuaXQodW5pdCldO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhlIHZhbHVlcyBvZiBzcGVjaWZpZWQgdW5pdHMuIFJldHVybiBhIG5ld2x5LWNvbnN0cnVjdGVkIER1cmF0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzIC0gYSBtYXBwaW5nIG9mIHVuaXRzIHRvIG51bWJlcnNcbiAgICogQGV4YW1wbGUgZHVyLnNldCh7IHllYXJzOiAyMDE3IH0pXG4gICAqIEBleGFtcGxlIGR1ci5zZXQoeyBob3VyczogOCwgbWludXRlczogMzAgfSlcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzZXQodmFsdWVzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuXG4gICAgY29uc3QgbWl4ZWQgPSB7IC4uLnRoaXMudmFsdWVzLCAuLi5ub3JtYWxpemVPYmplY3QodmFsdWVzLCBEdXJhdGlvbi5ub3JtYWxpemVVbml0KSB9O1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHZhbHVlczogbWl4ZWQgfSk7XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGUgbG9jYWxlIGFuZC9vciBudW1iZXJpbmdTeXN0ZW0uICBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRHVyYXRpb24uXG4gICAqIEBleGFtcGxlIGR1ci5yZWNvbmZpZ3VyZSh7IGxvY2FsZTogJ2VuLUdCJyB9KVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHJlY29uZmlndXJlKHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIGNvbnZlcnNpb25BY2N1cmFjeSwgbWF0cml4IH0gPSB7fSkge1xuICAgIGNvbnN0IGxvYyA9IHRoaXMubG9jLmNsb25lKHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0gfSk7XG4gICAgY29uc3Qgb3B0cyA9IHsgbG9jLCBtYXRyaXgsIGNvbnZlcnNpb25BY2N1cmFjeSB9O1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgZHVyYXRpb24gaW4gdGhlIHNwZWNpZmllZCB1bml0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIGEgdW5pdCBzdWNoIGFzICdtaW51dGVzJyBvciAnZGF5cydcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7eWVhcnM6IDF9KS5hcygnZGF5cycpIC8vPT4gMzY1XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3Qoe3llYXJzOiAxfSkuYXMoJ21vbnRocycpIC8vPT4gMTJcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7aG91cnM6IDYwfSkuYXMoJ2RheXMnKSAvLz0+IDIuNVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBhcyh1bml0KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuc2hpZnRUbyh1bml0KS5nZXQodW5pdCkgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmVkdWNlIHRoaXMgRHVyYXRpb24gdG8gaXRzIGNhbm9uaWNhbCByZXByZXNlbnRhdGlvbiBpbiBpdHMgY3VycmVudCB1bml0cy5cbiAgICogQXNzdW1pbmcgdGhlIG92ZXJhbGwgdmFsdWUgb2YgdGhlIER1cmF0aW9uIGlzIHBvc2l0aXZlLCB0aGlzIG1lYW5zOlxuICAgKiAtIGV4Y2Vzc2l2ZSB2YWx1ZXMgZm9yIGxvd2VyLW9yZGVyIHVuaXRzIGFyZSBjb252ZXJ0ZWQgdG8gaGlnaGVyLW9yZGVyIHVuaXRzIChpZiBwb3NzaWJsZSwgc2VlIGZpcnN0IGFuZCBzZWNvbmQgZXhhbXBsZSlcbiAgICogLSBuZWdhdGl2ZSBsb3dlci1vcmRlciB1bml0cyBhcmUgY29udmVydGVkIHRvIGhpZ2hlciBvcmRlciB1bml0cyAodGhlcmUgbXVzdCBiZSBzdWNoIGEgaGlnaGVyIG9yZGVyIHVuaXQsIG90aGVyd2lzZVxuICAgKiAgIHRoZSBvdmVyYWxsIHZhbHVlIHdvdWxkIGJlIG5lZ2F0aXZlLCBzZWUgc2Vjb25kIGV4YW1wbGUpXG4gICAqIC0gZnJhY3Rpb25hbCB2YWx1ZXMgZm9yIGhpZ2hlci1vcmRlciB1bml0cyBhcmUgY29udmVydGVkIHRvIGxvd2VyLW9yZGVyIHVuaXRzIChpZiBwb3NzaWJsZSwgc2VlIGZvdXJ0aCBleGFtcGxlKVxuICAgKlxuICAgKiBJZiB0aGUgb3ZlcmFsbCB2YWx1ZSBpcyBuZWdhdGl2ZSwgdGhlIHJlc3VsdCBvZiB0aGlzIG1ldGhvZCBpcyBlcXVpdmFsZW50IHRvIGB0aGlzLm5lZ2F0ZSgpLm5vcm1hbGl6ZSgpLm5lZ2F0ZSgpYC5cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IHllYXJzOiAyLCBkYXlzOiA1MDAwIH0pLm5vcm1hbGl6ZSgpLnRvT2JqZWN0KCkgLy89PiB7IHllYXJzOiAxNSwgZGF5czogMjU1IH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGRheXM6IDUwMDAgfSkubm9ybWFsaXplKCkudG9PYmplY3QoKSAvLz0+IHsgZGF5czogNTAwMCB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMTIsIG1pbnV0ZXM6IC00NSB9KS5ub3JtYWxpemUoKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMTEsIG1pbnV0ZXM6IDE1IH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IHllYXJzOiAyLjUsIGRheXM6IDAsIGhvdXJzOiAwIH0pLm5vcm1hbGl6ZSgpLnRvT2JqZWN0KCkgLy89PiB7IHllYXJzOiAyLCBkYXlzOiAxODIsIGhvdXJzOiAxMiB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgbm9ybWFsaXplKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCB2YWxzID0gdGhpcy50b09iamVjdCgpO1xuICAgIG5vcm1hbGl6ZVZhbHVlcyh0aGlzLm1hdHJpeCwgdmFscyk7XG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIHsgdmFsdWVzOiB2YWxzIH0sIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2NhbGUgdW5pdHMgdG8gaXRzIGxhcmdlc3QgcmVwcmVzZW50YXRpb25cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IG1pbGxpc2Vjb25kczogOTAwMDAgfSkucmVzY2FsZSgpLnRvT2JqZWN0KCkgLy89PiB7IG1pbnV0ZXM6IDEsIHNlY29uZHM6IDMwIH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICByZXNjYWxlKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCB2YWxzID0gcmVtb3ZlWmVyb2VzKHRoaXMubm9ybWFsaXplKCkuc2hpZnRUb0FsbCgpLnRvT2JqZWN0KCkpO1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHZhbHVlczogdmFscyB9LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHRoaXMgRHVyYXRpb24gaW50byBpdHMgcmVwcmVzZW50YXRpb24gaW4gYSBkaWZmZXJlbnQgc2V0IG9mIHVuaXRzLlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDEsIHNlY29uZHM6IDMwIH0pLnNoaWZ0VG8oJ21pbnV0ZXMnLCAnbWlsbGlzZWNvbmRzJykudG9PYmplY3QoKSAvLz0+IHsgbWludXRlczogNjAsIG1pbGxpc2Vjb25kczogMzAwMDAgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHNoaWZ0VG8oLi4udW5pdHMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAodW5pdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB1bml0cyA9IHVuaXRzLm1hcCgodSkgPT4gRHVyYXRpb24ubm9ybWFsaXplVW5pdCh1KSk7XG5cbiAgICBjb25zdCBidWlsdCA9IHt9LFxuICAgICAgYWNjdW11bGF0ZWQgPSB7fSxcbiAgICAgIHZhbHMgPSB0aGlzLnRvT2JqZWN0KCk7XG4gICAgbGV0IGxhc3RVbml0O1xuXG4gICAgZm9yIChjb25zdCBrIG9mIG9yZGVyZWRVbml0cykge1xuICAgICAgaWYgKHVuaXRzLmluZGV4T2YoaykgPj0gMCkge1xuICAgICAgICBsYXN0VW5pdCA9IGs7XG5cbiAgICAgICAgbGV0IG93biA9IDA7XG5cbiAgICAgICAgLy8gYW55dGhpbmcgd2UgaGF2ZW4ndCBib2lsZWQgZG93biB5ZXQgc2hvdWxkIGdldCBib2lsZWQgdG8gdGhpcyB1bml0XG4gICAgICAgIGZvciAoY29uc3QgYWsgaW4gYWNjdW11bGF0ZWQpIHtcbiAgICAgICAgICBvd24gKz0gdGhpcy5tYXRyaXhbYWtdW2tdICogYWNjdW11bGF0ZWRbYWtdO1xuICAgICAgICAgIGFjY3VtdWxhdGVkW2FrXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwbHVzIGFueXRoaW5nIHRoYXQncyBhbHJlYWR5IGluIHRoaXMgdW5pdFxuICAgICAgICBpZiAoaXNOdW1iZXIodmFsc1trXSkpIHtcbiAgICAgICAgICBvd24gKz0gdmFsc1trXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG9ubHkga2VlcCB0aGUgaW50ZWdlciBwYXJ0IGZvciBub3cgaW4gdGhlIGhvcGVzIG9mIHB1dHRpbmcgYW55IGRlY2ltYWwgcGFydFxuICAgICAgICAvLyBpbnRvIGEgc21hbGxlciB1bml0IGxhdGVyXG4gICAgICAgIGNvbnN0IGkgPSBNYXRoLnRydW5jKG93bik7XG4gICAgICAgIGJ1aWx0W2tdID0gaTtcbiAgICAgICAgYWNjdW11bGF0ZWRba10gPSAob3duICogMTAwMCAtIGkgKiAxMDAwKSAvIDEwMDA7XG5cbiAgICAgICAgLy8gb3RoZXJ3aXNlLCBrZWVwIGl0IGluIHRoZSB3aW5ncyB0byBib2lsIGl0IGxhdGVyXG4gICAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKHZhbHNba10pKSB7XG4gICAgICAgIGFjY3VtdWxhdGVkW2tdID0gdmFsc1trXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhbnl0aGluZyBsZWZ0b3ZlciBiZWNvbWVzIHRoZSBkZWNpbWFsIGZvciB0aGUgbGFzdCB1bml0XG4gICAgLy8gbGFzdFVuaXQgbXVzdCBiZSBkZWZpbmVkIHNpbmNlIHVuaXRzIGlzIG5vdCBlbXB0eVxuICAgIGZvciAoY29uc3Qga2V5IGluIGFjY3VtdWxhdGVkKSB7XG4gICAgICBpZiAoYWNjdW11bGF0ZWRba2V5XSAhPT0gMCkge1xuICAgICAgICBidWlsdFtsYXN0VW5pdF0gKz1cbiAgICAgICAgICBrZXkgPT09IGxhc3RVbml0ID8gYWNjdW11bGF0ZWRba2V5XSA6IGFjY3VtdWxhdGVkW2tleV0gLyB0aGlzLm1hdHJpeFtsYXN0VW5pdF1ba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBub3JtYWxpemVWYWx1ZXModGhpcy5tYXRyaXgsIGJ1aWx0KTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyB2YWx1ZXM6IGJ1aWx0IH0sIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNoaWZ0IHRoaXMgRHVyYXRpb24gdG8gYWxsIGF2YWlsYWJsZSB1bml0cy5cbiAgICogU2FtZSBhcyBzaGlmdFRvKFwieWVhcnNcIiwgXCJtb250aHNcIiwgXCJ3ZWVrc1wiLCBcImRheXNcIiwgXCJob3Vyc1wiLCBcIm1pbnV0ZXNcIiwgXCJzZWNvbmRzXCIsIFwibWlsbGlzZWNvbmRzXCIpXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgc2hpZnRUb0FsbCgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgcmV0dXJuIHRoaXMuc2hpZnRUbyhcbiAgICAgIFwieWVhcnNcIixcbiAgICAgIFwibW9udGhzXCIsXG4gICAgICBcIndlZWtzXCIsXG4gICAgICBcImRheXNcIixcbiAgICAgIFwiaG91cnNcIixcbiAgICAgIFwibWludXRlc1wiLFxuICAgICAgXCJzZWNvbmRzXCIsXG4gICAgICBcIm1pbGxpc2Vjb25kc1wiXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG5lZ2F0aXZlIG9mIHRoaXMgRHVyYXRpb24uXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMSwgc2Vjb25kczogMzAgfSkubmVnYXRlKCkudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IC0xLCBzZWNvbmRzOiAtMzAgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIG5lZ2F0ZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgbmVnYXRlZCA9IHt9O1xuICAgIGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyh0aGlzLnZhbHVlcykpIHtcbiAgICAgIG5lZ2F0ZWRba10gPSB0aGlzLnZhbHVlc1trXSA9PT0gMCA/IDAgOiAtdGhpcy52YWx1ZXNba107XG4gICAgfVxuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHZhbHVlczogbmVnYXRlZCB9LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHllYXJzLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHllYXJzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy55ZWFycyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcXVhcnRlcnMuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgcXVhcnRlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLnF1YXJ0ZXJzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtb250aHMuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbW9udGhzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy5tb250aHMgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHdlZWtzXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgd2Vla3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLndlZWtzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkYXlzLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGRheXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLmRheXMgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGhvdXJzLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGhvdXJzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy5ob3VycyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWludXRlcy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBtaW51dGVzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy5taW51dGVzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzZWNvbmRzLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgc2Vjb25kcygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMuc2Vjb25kcyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWlsbGlzZWNvbmRzLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbWlsbGlzZWNvbmRzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy5taWxsaXNlY29uZHMgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIER1cmF0aW9uIGlzIGludmFsaWQuIEludmFsaWQgZHVyYXRpb25zIGFyZSByZXR1cm5lZCBieSBkaWZmIG9wZXJhdGlvbnNcbiAgICogb24gaW52YWxpZCBEYXRlVGltZXMgb3IgSW50ZXJ2YWxzLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZCA9PT0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGVycm9yIGNvZGUgaWYgdGhpcyBEdXJhdGlvbiBiZWNhbWUgaW52YWxpZCwgb3IgbnVsbCBpZiB0aGUgRHVyYXRpb24gaXMgdmFsaWRcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGludmFsaWRSZWFzb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZCA/IHRoaXMuaW52YWxpZC5yZWFzb24gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZXhwbGFuYXRpb24gb2Ygd2h5IHRoaXMgRHVyYXRpb24gYmVjYW1lIGludmFsaWQsIG9yIG51bGwgaWYgdGhlIER1cmF0aW9uIGlzIHZhbGlkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgaW52YWxpZEV4cGxhbmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmludmFsaWQgPyB0aGlzLmludmFsaWQuZXhwbGFuYXRpb24gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEVxdWFsaXR5IGNoZWNrXG4gICAqIFR3byBEdXJhdGlvbnMgYXJlIGVxdWFsIGlmZiB0aGV5IGhhdmUgdGhlIHNhbWUgdW5pdHMgYW5kIHRoZSBzYW1lIHZhbHVlcyBmb3IgZWFjaCB1bml0LlxuICAgKiBAcGFyYW0ge0R1cmF0aW9ufSBvdGhlclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQgfHwgIW90aGVyLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMubG9jLmVxdWFscyhvdGhlci5sb2MpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXEodjEsIHYyKSB7XG4gICAgICAvLyBDb25zaWRlciAwIGFuZCB1bmRlZmluZWQgYXMgZXF1YWxcbiAgICAgIGlmICh2MSA9PT0gdW5kZWZpbmVkIHx8IHYxID09PSAwKSByZXR1cm4gdjIgPT09IHVuZGVmaW5lZCB8fCB2MiA9PT0gMDtcbiAgICAgIHJldHVybiB2MSA9PT0gdjI7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCB1IG9mIG9yZGVyZWRVbml0cykge1xuICAgICAgaWYgKCFlcSh0aGlzLnZhbHVlc1t1XSwgb3RoZXIudmFsdWVzW3VdKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG4iLCAiaW1wb3J0IERhdGVUaW1lLCB7IGZyaWVuZGx5RGF0ZVRpbWUgfSBmcm9tIFwiLi9kYXRldGltZS5qc1wiO1xuaW1wb3J0IER1cmF0aW9uIGZyb20gXCIuL2R1cmF0aW9uLmpzXCI7XG5pbXBvcnQgU2V0dGluZ3MgZnJvbSBcIi4vc2V0dGluZ3MuanNcIjtcbmltcG9ydCB7IEludmFsaWRBcmd1bWVudEVycm9yLCBJbnZhbGlkSW50ZXJ2YWxFcnJvciB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IEludmFsaWQgZnJvbSBcIi4vaW1wbC9pbnZhbGlkLmpzXCI7XG5pbXBvcnQgRm9ybWF0dGVyIGZyb20gXCIuL2ltcGwvZm9ybWF0dGVyLmpzXCI7XG5pbXBvcnQgKiBhcyBGb3JtYXRzIGZyb20gXCIuL2ltcGwvZm9ybWF0cy5qc1wiO1xuXG5jb25zdCBJTlZBTElEID0gXCJJbnZhbGlkIEludGVydmFsXCI7XG5cbi8vIGNoZWNrcyBpZiB0aGUgc3RhcnQgaXMgZXF1YWwgdG8gb3IgYmVmb3JlIHRoZSBlbmRcbmZ1bmN0aW9uIHZhbGlkYXRlU3RhcnRFbmQoc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0IHx8ICFzdGFydC5pc1ZhbGlkKSB7XG4gICAgcmV0dXJuIEludGVydmFsLmludmFsaWQoXCJtaXNzaW5nIG9yIGludmFsaWQgc3RhcnRcIik7XG4gIH0gZWxzZSBpZiAoIWVuZCB8fCAhZW5kLmlzVmFsaWQpIHtcbiAgICByZXR1cm4gSW50ZXJ2YWwuaW52YWxpZChcIm1pc3Npbmcgb3IgaW52YWxpZCBlbmRcIik7XG4gIH0gZWxzZSBpZiAoZW5kIDwgc3RhcnQpIHtcbiAgICByZXR1cm4gSW50ZXJ2YWwuaW52YWxpZChcbiAgICAgIFwiZW5kIGJlZm9yZSBzdGFydFwiLFxuICAgICAgYFRoZSBlbmQgb2YgYW4gaW50ZXJ2YWwgbXVzdCBiZSBhZnRlciBpdHMgc3RhcnQsIGJ1dCB5b3UgaGFkIHN0YXJ0PSR7c3RhcnQudG9JU08oKX0gYW5kIGVuZD0ke2VuZC50b0lTTygpfWBcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogQW4gSW50ZXJ2YWwgb2JqZWN0IHJlcHJlc2VudHMgYSBoYWxmLW9wZW4gaW50ZXJ2YWwgb2YgdGltZSwgd2hlcmUgZWFjaCBlbmRwb2ludCBpcyBhIHtAbGluayBEYXRlVGltZX0uIENvbmNlcHR1YWxseSwgaXQncyBhIGNvbnRhaW5lciBmb3IgdGhvc2UgdHdvIGVuZHBvaW50cywgYWNjb21wYW5pZWQgYnkgbWV0aG9kcyBmb3IgY3JlYXRpbmcsIHBhcnNpbmcsIGludGVycm9nYXRpbmcsIGNvbXBhcmluZywgdHJhbnNmb3JtaW5nLCBhbmQgZm9ybWF0dGluZyB0aGVtLlxuICpcbiAqIEhlcmUgaXMgYSBicmllZiBvdmVydmlldyBvZiB0aGUgbW9zdCBjb21tb25seSB1c2VkIG1ldGhvZHMgYW5kIGdldHRlcnMgaW4gSW50ZXJ2YWw6XG4gKlxuICogKiAqKkNyZWF0aW9uKiogVG8gY3JlYXRlIGFuIEludGVydmFsLCB1c2Uge0BsaW5rIEludGVydmFsLmZyb21EYXRlVGltZXN9LCB7QGxpbmsgSW50ZXJ2YWwuYWZ0ZXJ9LCB7QGxpbmsgSW50ZXJ2YWwuYmVmb3JlfSwgb3Ige0BsaW5rIEludGVydmFsLmZyb21JU099LlxuICogKiAqKkFjY2Vzc29ycyoqIFVzZSB7QGxpbmsgSW50ZXJ2YWwjc3RhcnR9IGFuZCB7QGxpbmsgSW50ZXJ2YWwjZW5kfSB0byBnZXQgdGhlIHN0YXJ0IGFuZCBlbmQuXG4gKiAqICoqSW50ZXJyb2dhdGlvbioqIFRvIGFuYWx5emUgdGhlIEludGVydmFsLCB1c2Uge0BsaW5rIEludGVydmFsI2NvdW50fSwge0BsaW5rIEludGVydmFsI2xlbmd0aH0sIHtAbGluayBJbnRlcnZhbCNoYXNTYW1lfSwge0BsaW5rIEludGVydmFsI2NvbnRhaW5zfSwge0BsaW5rIEludGVydmFsI2lzQWZ0ZXJ9LCBvciB7QGxpbmsgSW50ZXJ2YWwjaXNCZWZvcmV9LlxuICogKiAqKlRyYW5zZm9ybWF0aW9uKiogVG8gY3JlYXRlIG90aGVyIEludGVydmFscyBvdXQgb2YgdGhpcyBvbmUsIHVzZSB7QGxpbmsgSW50ZXJ2YWwjc2V0fSwge0BsaW5rIEludGVydmFsI3NwbGl0QXR9LCB7QGxpbmsgSW50ZXJ2YWwjc3BsaXRCeX0sIHtAbGluayBJbnRlcnZhbCNkaXZpZGVFcXVhbGx5fSwge0BsaW5rIEludGVydmFsLm1lcmdlfSwge0BsaW5rIEludGVydmFsLnhvcn0sIHtAbGluayBJbnRlcnZhbCN1bmlvbn0sIHtAbGluayBJbnRlcnZhbCNpbnRlcnNlY3Rpb259LCBvciB7QGxpbmsgSW50ZXJ2YWwjZGlmZmVyZW5jZX0uXG4gKiAqICoqQ29tcGFyaXNvbioqIFRvIGNvbXBhcmUgdGhpcyBJbnRlcnZhbCB0byBhbm90aGVyIG9uZSwgdXNlIHtAbGluayBJbnRlcnZhbCNlcXVhbHN9LCB7QGxpbmsgSW50ZXJ2YWwjb3ZlcmxhcHN9LCB7QGxpbmsgSW50ZXJ2YWwjYWJ1dHNTdGFydH0sIHtAbGluayBJbnRlcnZhbCNhYnV0c0VuZH0sIHtAbGluayBJbnRlcnZhbCNlbmd1bGZzfVxuICogKiAqKk91dHB1dCoqIFRvIGNvbnZlcnQgdGhlIEludGVydmFsIGludG8gb3RoZXIgcmVwcmVzZW50YXRpb25zLCBzZWUge0BsaW5rIEludGVydmFsI3RvU3RyaW5nfSwge0BsaW5rIEludGVydmFsI3RvTG9jYWxlU3RyaW5nfSwge0BsaW5rIEludGVydmFsI3RvSVNPfSwge0BsaW5rIEludGVydmFsI3RvSVNPRGF0ZX0sIHtAbGluayBJbnRlcnZhbCN0b0lTT1RpbWV9LCB7QGxpbmsgSW50ZXJ2YWwjdG9Gb3JtYXR9LCBhbmQge0BsaW5rIEludGVydmFsI3RvRHVyYXRpb259LlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbnRlcnZhbCB7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5zID0gY29uZmlnLnN0YXJ0O1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZSA9IGNvbmZpZy5lbmQ7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5pbnZhbGlkID0gY29uZmlnLmludmFsaWQgfHwgbnVsbDtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmlzTHV4b25JbnRlcnZhbCA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGludmFsaWQgSW50ZXJ2YWwuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb24gLSBzaW1wbGUgc3RyaW5nIG9mIHdoeSB0aGlzIEludGVydmFsIGlzIGludmFsaWQuIFNob3VsZCBub3QgY29udGFpbiBwYXJhbWV0ZXJzIG9yIGFueXRoaW5nIGVsc2UgZGF0YS1kZXBlbmRlbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtleHBsYW5hdGlvbj1udWxsXSAtIGxvbmdlciBleHBsYW5hdGlvbiwgbWF5IGluY2x1ZGUgcGFyYW1ldGVycyBhbmQgb3RoZXIgdXNlZnVsIGRlYnVnZ2luZyBpbmZvcm1hdGlvblxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIHN0YXRpYyBpbnZhbGlkKHJlYXNvbiwgZXhwbGFuYXRpb24gPSBudWxsKSB7XG4gICAgaWYgKCFyZWFzb24pIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIm5lZWQgdG8gc3BlY2lmeSBhIHJlYXNvbiB0aGUgSW50ZXJ2YWwgaXMgaW52YWxpZFwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnZhbGlkID0gcmVhc29uIGluc3RhbmNlb2YgSW52YWxpZCA/IHJlYXNvbiA6IG5ldyBJbnZhbGlkKHJlYXNvbiwgZXhwbGFuYXRpb24pO1xuXG4gICAgaWYgKFNldHRpbmdzLnRocm93T25JbnZhbGlkKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEludGVydmFsRXJyb3IoaW52YWxpZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgSW50ZXJ2YWwoeyBpbnZhbGlkIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gSW50ZXJ2YWwgZnJvbSBhIHN0YXJ0IERhdGVUaW1lIGFuZCBhbiBlbmQgRGF0ZVRpbWUuIEluY2x1c2l2ZSBvZiB0aGUgc3RhcnQgYnV0IG5vdCB0aGUgZW5kLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfERhdGV8T2JqZWN0fSBzdGFydFxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfERhdGV8T2JqZWN0fSBlbmRcbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICBzdGF0aWMgZnJvbURhdGVUaW1lcyhzdGFydCwgZW5kKSB7XG4gICAgY29uc3QgYnVpbHRTdGFydCA9IGZyaWVuZGx5RGF0ZVRpbWUoc3RhcnQpLFxuICAgICAgYnVpbHRFbmQgPSBmcmllbmRseURhdGVUaW1lKGVuZCk7XG5cbiAgICBjb25zdCB2YWxpZGF0ZUVycm9yID0gdmFsaWRhdGVTdGFydEVuZChidWlsdFN0YXJ0LCBidWlsdEVuZCk7XG5cbiAgICBpZiAodmFsaWRhdGVFcnJvciA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbmV3IEludGVydmFsKHtcbiAgICAgICAgc3RhcnQ6IGJ1aWx0U3RhcnQsXG4gICAgICAgIGVuZDogYnVpbHRFbmQsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZhbGlkYXRlRXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBJbnRlcnZhbCBmcm9tIGEgc3RhcnQgRGF0ZVRpbWUgYW5kIGEgRHVyYXRpb24gdG8gZXh0ZW5kIHRvLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfERhdGV8T2JqZWN0fSBzdGFydFxuICAgKiBAcGFyYW0ge0R1cmF0aW9ufE9iamVjdHxudW1iZXJ9IGR1cmF0aW9uIC0gdGhlIGxlbmd0aCBvZiB0aGUgSW50ZXJ2YWwuXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgc3RhdGljIGFmdGVyKHN0YXJ0LCBkdXJhdGlvbikge1xuICAgIGNvbnN0IGR1ciA9IER1cmF0aW9uLmZyb21EdXJhdGlvbkxpa2UoZHVyYXRpb24pLFxuICAgICAgZHQgPSBmcmllbmRseURhdGVUaW1lKHN0YXJ0KTtcbiAgICByZXR1cm4gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdCwgZHQucGx1cyhkdXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gSW50ZXJ2YWwgZnJvbSBhbiBlbmQgRGF0ZVRpbWUgYW5kIGEgRHVyYXRpb24gdG8gZXh0ZW5kIGJhY2t3YXJkcyB0by5cbiAgICogQHBhcmFtIHtEYXRlVGltZXxEYXRlfE9iamVjdH0gZW5kXG4gICAqIEBwYXJhbSB7RHVyYXRpb258T2JqZWN0fG51bWJlcn0gZHVyYXRpb24gLSB0aGUgbGVuZ3RoIG9mIHRoZSBJbnRlcnZhbC5cbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICBzdGF0aWMgYmVmb3JlKGVuZCwgZHVyYXRpb24pIHtcbiAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tRHVyYXRpb25MaWtlKGR1cmF0aW9uKSxcbiAgICAgIGR0ID0gZnJpZW5kbHlEYXRlVGltZShlbmQpO1xuICAgIHJldHVybiBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0Lm1pbnVzKGR1ciksIGR0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gSW50ZXJ2YWwgZnJvbSBhbiBJU08gODYwMSBzdHJpbmcuXG4gICAqIEFjY2VwdHMgYDxzdGFydD4vPGVuZD5gLCBgPHN0YXJ0Pi88ZHVyYXRpb24+YCwgYW5kIGA8ZHVyYXRpb24+LzxlbmQ+YCBmb3JtYXRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSBJU08gc3RyaW5nIHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gLSBvcHRpb25zIHRvIHBhc3Mge0BsaW5rIERhdGVUaW1lI2Zyb21JU099IGFuZCBvcHRpb25hbGx5IHtAbGluayBEdXJhdGlvbiNmcm9tSVNPfVxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI1RpbWVfaW50ZXJ2YWxzXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgc3RhdGljIGZyb21JU08odGV4dCwgb3B0cykge1xuICAgIGNvbnN0IFtzLCBlXSA9ICh0ZXh0IHx8IFwiXCIpLnNwbGl0KFwiL1wiLCAyKTtcbiAgICBpZiAocyAmJiBlKSB7XG4gICAgICBsZXQgc3RhcnQsIHN0YXJ0SXNWYWxpZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0YXJ0ID0gRGF0ZVRpbWUuZnJvbUlTTyhzLCBvcHRzKTtcbiAgICAgICAgc3RhcnRJc1ZhbGlkID0gc3RhcnQuaXNWYWxpZDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc3RhcnRJc1ZhbGlkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGxldCBlbmQsIGVuZElzVmFsaWQ7XG4gICAgICB0cnkge1xuICAgICAgICBlbmQgPSBEYXRlVGltZS5mcm9tSVNPKGUsIG9wdHMpO1xuICAgICAgICBlbmRJc1ZhbGlkID0gZW5kLmlzVmFsaWQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVuZElzVmFsaWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXJ0SXNWYWxpZCAmJiBlbmRJc1ZhbGlkKSB7XG4gICAgICAgIHJldHVybiBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhcnRJc1ZhbGlkKSB7XG4gICAgICAgIGNvbnN0IGR1ciA9IER1cmF0aW9uLmZyb21JU08oZSwgb3B0cyk7XG4gICAgICAgIGlmIChkdXIuaXNWYWxpZCkge1xuICAgICAgICAgIHJldHVybiBJbnRlcnZhbC5hZnRlcihzdGFydCwgZHVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlbmRJc1ZhbGlkKSB7XG4gICAgICAgIGNvbnN0IGR1ciA9IER1cmF0aW9uLmZyb21JU08ocywgb3B0cyk7XG4gICAgICAgIGlmIChkdXIuaXNWYWxpZCkge1xuICAgICAgICAgIHJldHVybiBJbnRlcnZhbC5iZWZvcmUoZW5kLCBkdXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBJbnRlcnZhbC5pbnZhbGlkKFwidW5wYXJzYWJsZVwiLCBgdGhlIGlucHV0IFwiJHt0ZXh0fVwiIGNhbid0IGJlIHBhcnNlZCBhcyBJU08gODYwMWApO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIG9iamVjdCBpcyBhbiBJbnRlcnZhbC4gV29ya3MgYWNyb3NzIGNvbnRleHQgYm91bmRhcmllc1xuICAgKiBAcGFyYW0ge29iamVjdH0gb1xuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzSW50ZXJ2YWwobykge1xuICAgIHJldHVybiAobyAmJiBvLmlzTHV4b25JbnRlcnZhbCkgfHwgZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RhcnQgb2YgdGhlIEludGVydmFsXG4gICAqIEB0eXBlIHtEYXRlVGltZX1cbiAgICovXG4gIGdldCBzdGFydCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5zIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlbmQgb2YgdGhlIEludGVydmFsXG4gICAqIEB0eXBlIHtEYXRlVGltZX1cbiAgICovXG4gIGdldCBlbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuZSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwncyBlbmQgaXMgYXQgbGVhc3QgaXRzIHN0YXJ0LCBtZWFuaW5nIHRoYXQgdGhlIEludGVydmFsIGlzbid0ICdiYWNrd2FyZHMnLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiB0aGlzLmludmFsaWRSZWFzb24gPT09IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBlcnJvciBjb2RlIGlmIHRoaXMgSW50ZXJ2YWwgaXMgaW52YWxpZCwgb3IgbnVsbCBpZiB0aGUgSW50ZXJ2YWwgaXMgdmFsaWRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBpbnZhbGlkUmVhc29uKCkge1xuICAgIHJldHVybiB0aGlzLmludmFsaWQgPyB0aGlzLmludmFsaWQucmVhc29uIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGV4cGxhbmF0aW9uIG9mIHdoeSB0aGlzIEludGVydmFsIGJlY2FtZSBpbnZhbGlkLCBvciBudWxsIGlmIHRoZSBJbnRlcnZhbCBpcyB2YWxpZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGludmFsaWRFeHBsYW5hdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZhbGlkID8gdGhpcy5pbnZhbGlkLmV4cGxhbmF0aW9uIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIEludGVydmFsIGluIHRoZSBzcGVjaWZpZWQgdW5pdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSB0aGUgdW5pdCAoc3VjaCBhcyAnaG91cnMnIG9yICdkYXlzJykgdG8gcmV0dXJuIHRoZSBsZW5ndGggaW4uXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGxlbmd0aCh1bml0ID0gXCJtaWxsaXNlY29uZHNcIikge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnRvRHVyYXRpb24oLi4uW3VuaXRdKS5nZXQodW5pdCkgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY291bnQgb2YgbWludXRlcywgaG91cnMsIGRheXMsIG1vbnRocywgb3IgeWVhcnMgaW5jbHVkZWQgaW4gdGhlIEludGVydmFsLCBldmVuIGluIHBhcnQuXG4gICAqIFVubGlrZSB7QGxpbmsgSW50ZXJ2YWwjbGVuZ3RofSB0aGlzIGNvdW50cyBzZWN0aW9ucyBvZiB0aGUgY2FsZW5kYXIsIG5vdCBwZXJpb2RzIG9mIHRpbWUsIGUuZy4gc3BlY2lmeWluZyAnZGF5J1xuICAgKiBhc2tzICd3aGF0IGRhdGVzIGFyZSBpbmNsdWRlZCBpbiB0aGlzIGludGVydmFsPycsIG5vdCAnaG93IG1hbnkgZGF5cyBsb25nIGlzIHRoaXMgaW50ZXJ2YWw/J1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW3VuaXQ9J21pbGxpc2Vjb25kcyddIC0gdGhlIHVuaXQgb2YgdGltZSB0byBjb3VudC5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgY291bnQodW5pdCA9IFwibWlsbGlzZWNvbmRzXCIpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIE5hTjtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuc3RhcnQuc3RhcnRPZih1bml0KSxcbiAgICAgIGVuZCA9IHRoaXMuZW5kLnN0YXJ0T2YodW5pdCk7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoZW5kLmRpZmYoc3RhcnQsIHVuaXQpLmdldCh1bml0KSkgKyAoZW5kLnZhbHVlT2YoKSAhPT0gdGhpcy5lbmQudmFsdWVPZigpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIHN0YXJ0IGFuZCBlbmQgYXJlIGJvdGggaW4gdGhlIHNhbWUgdW5pdCBvZiB0aW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1bml0IC0gdGhlIHVuaXQgb2YgdGltZSB0byBjaGVjayBzYW1lbmVzcyBvblxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzU2FtZSh1bml0KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuaXNFbXB0eSgpIHx8IHRoaXMuZS5taW51cygxKS5oYXNTYW1lKHRoaXMucywgdW5pdCkgOiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIEludGVydmFsIGhhcyB0aGUgc2FtZSBzdGFydCBhbmQgZW5kIERhdGVUaW1lcy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMucy52YWx1ZU9mKCkgPT09IHRoaXMuZS52YWx1ZU9mKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIHN0YXJ0IGlzIGFmdGVyIHRoZSBzcGVjaWZpZWQgRGF0ZVRpbWUuXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IGRhdGVUaW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0FmdGVyKGRhdGVUaW1lKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5zID4gZGF0ZVRpbWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIGVuZCBpcyBiZWZvcmUgdGhlIHNwZWNpZmllZCBEYXRlVGltZS5cbiAgICogQHBhcmFtIHtEYXRlVGltZX0gZGF0ZVRpbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQmVmb3JlKGRhdGVUaW1lKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5lIDw9IGRhdGVUaW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwgY29udGFpbnMgdGhlIHNwZWNpZmllZCBEYXRlVGltZS5cbiAgICogQHBhcmFtIHtEYXRlVGltZX0gZGF0ZVRpbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGNvbnRhaW5zKGRhdGVUaW1lKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5zIDw9IGRhdGVUaW1lICYmIHRoaXMuZSA+IGRhdGVUaW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0c1wiIHRoZSBzdGFydCBhbmQvb3IgZW5kIGRhdGVzLiBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgSW50ZXJ2YWwuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXMgLSB0aGUgdmFsdWVzIHRvIHNldFxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSB2YWx1ZXMuc3RhcnQgLSB0aGUgc3RhcnRpbmcgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtEYXRlVGltZX0gdmFsdWVzLmVuZCAtIHRoZSBlbmRpbmcgRGF0ZVRpbWVcbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICBzZXQoeyBzdGFydCwgZW5kIH0gPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICByZXR1cm4gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhzdGFydCB8fCB0aGlzLnMsIGVuZCB8fCB0aGlzLmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0IHRoaXMgSW50ZXJ2YWwgYXQgZWFjaCBvZiB0aGUgc3BlY2lmaWVkIERhdGVUaW1lc1xuICAgKiBAcGFyYW0gey4uLkRhdGVUaW1lfSBkYXRlVGltZXMgLSB0aGUgdW5pdCBvZiB0aW1lIHRvIGNvdW50LlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHNwbGl0QXQoLi4uZGF0ZVRpbWVzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBbXTtcbiAgICBjb25zdCBzb3J0ZWQgPSBkYXRlVGltZXNcbiAgICAgICAgLm1hcChmcmllbmRseURhdGVUaW1lKVxuICAgICAgICAuZmlsdGVyKChkKSA9PiB0aGlzLmNvbnRhaW5zKGQpKVxuICAgICAgICAuc29ydCgpLFxuICAgICAgcmVzdWx0cyA9IFtdO1xuICAgIGxldCB7IHMgfSA9IHRoaXMsXG4gICAgICBpID0gMDtcblxuICAgIHdoaWxlIChzIDwgdGhpcy5lKSB7XG4gICAgICBjb25zdCBhZGRlZCA9IHNvcnRlZFtpXSB8fCB0aGlzLmUsXG4gICAgICAgIG5leHQgPSArYWRkZWQgPiArdGhpcy5lID8gdGhpcy5lIDogYWRkZWQ7XG4gICAgICByZXN1bHRzLnB1c2goSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhzLCBuZXh0KSk7XG4gICAgICBzID0gbmV4dDtcbiAgICAgIGkgKz0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdCB0aGlzIEludGVydmFsIGludG8gc21hbGxlciBJbnRlcnZhbHMsIGVhY2ggb2YgdGhlIHNwZWNpZmllZCBsZW5ndGguXG4gICAqIExlZnQgb3ZlciB0aW1lIGlzIGdyb3VwZWQgaW50byBhIHNtYWxsZXIgaW50ZXJ2YWxcbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSBsZW5ndGggb2YgZWFjaCByZXN1bHRpbmcgaW50ZXJ2YWwuXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3BsaXRCeShkdXJhdGlvbikge1xuICAgIGNvbnN0IGR1ciA9IER1cmF0aW9uLmZyb21EdXJhdGlvbkxpa2UoZHVyYXRpb24pO1xuXG4gICAgaWYgKCF0aGlzLmlzVmFsaWQgfHwgIWR1ci5pc1ZhbGlkIHx8IGR1ci5hcyhcIm1pbGxpc2Vjb25kc1wiKSA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGxldCB7IHMgfSA9IHRoaXMsXG4gICAgICBpZHggPSAxLFxuICAgICAgbmV4dDtcblxuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICB3aGlsZSAocyA8IHRoaXMuZSkge1xuICAgICAgY29uc3QgYWRkZWQgPSB0aGlzLnN0YXJ0LnBsdXMoZHVyLm1hcFVuaXRzKCh4KSA9PiB4ICogaWR4KSk7XG4gICAgICBuZXh0ID0gK2FkZGVkID4gK3RoaXMuZSA/IHRoaXMuZSA6IGFkZGVkO1xuICAgICAgcmVzdWx0cy5wdXNoKEludGVydmFsLmZyb21EYXRlVGltZXMocywgbmV4dCkpO1xuICAgICAgcyA9IG5leHQ7XG4gICAgICBpZHggKz0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdCB0aGlzIEludGVydmFsIGludG8gdGhlIHNwZWNpZmllZCBudW1iZXIgb2Ygc21hbGxlciBpbnRlcnZhbHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJPZlBhcnRzIC0gVGhlIG51bWJlciBvZiBJbnRlcnZhbHMgdG8gZGl2aWRlIHRoZSBJbnRlcnZhbCBpbnRvLlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIGRpdmlkZUVxdWFsbHkobnVtYmVyT2ZQYXJ0cykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gW107XG4gICAgcmV0dXJuIHRoaXMuc3BsaXRCeSh0aGlzLmxlbmd0aCgpIC8gbnVtYmVyT2ZQYXJ0cykuc2xpY2UoMCwgbnVtYmVyT2ZQYXJ0cyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCBvdmVybGFwcyB3aXRoIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWxcbiAgICogQHBhcmFtIHtJbnRlcnZhbH0gb3RoZXJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIG92ZXJsYXBzKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZSA+IG90aGVyLnMgJiYgdGhpcy5zIDwgb3RoZXIuZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIEludGVydmFsJ3MgZW5kIGlzIGFkamFjZW50IHRvIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWwncyBzdGFydC5cbiAgICogQHBhcmFtIHtJbnRlcnZhbH0gb3RoZXJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGFidXRzU3RhcnQob3RoZXIpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiArdGhpcy5lID09PSArb3RoZXIucztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIEludGVydmFsJ3Mgc3RhcnQgaXMgYWRqYWNlbnQgdG8gdGhlIHNwZWNpZmllZCBJbnRlcnZhbCdzIGVuZC5cbiAgICogQHBhcmFtIHtJbnRlcnZhbH0gb3RoZXJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGFidXRzRW5kKG90aGVyKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gK290aGVyLmUgPT09ICt0aGlzLnM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCBlbmd1bGZzIHRoZSBzdGFydCBhbmQgZW5kIG9mIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWwuXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBlbmd1bGZzKG90aGVyKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5zIDw9IG90aGVyLnMgJiYgdGhpcy5lID49IG90aGVyLmU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCBoYXMgdGhlIHNhbWUgc3RhcnQgYW5kIGVuZCBhcyB0aGUgc3BlY2lmaWVkIEludGVydmFsLlxuICAgKiBAcGFyYW0ge0ludGVydmFsfSBvdGhlclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQgfHwgIW90aGVyLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zLmVxdWFscyhvdGhlci5zKSAmJiB0aGlzLmUuZXF1YWxzKG90aGVyLmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBJbnRlcnZhbCByZXByZXNlbnRpbmcgdGhlIGludGVyc2VjdGlvbiBvZiB0aGlzIEludGVydmFsIGFuZCB0aGUgc3BlY2lmaWVkIEludGVydmFsLlxuICAgKiBTcGVjaWZpY2FsbHksIHRoZSByZXN1bHRpbmcgSW50ZXJ2YWwgaGFzIHRoZSBtYXhpbXVtIHN0YXJ0IHRpbWUgYW5kIHRoZSBtaW5pbXVtIGVuZCB0aW1lIG9mIHRoZSB0d28gSW50ZXJ2YWxzLlxuICAgKiBSZXR1cm5zIG51bGwgaWYgdGhlIGludGVyc2VjdGlvbiBpcyBlbXB0eSwgbWVhbmluZywgdGhlIGludGVydmFscyBkb24ndCBpbnRlcnNlY3QuXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgaW50ZXJzZWN0aW9uKG90aGVyKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IHMgPSB0aGlzLnMgPiBvdGhlci5zID8gdGhpcy5zIDogb3RoZXIucyxcbiAgICAgIGUgPSB0aGlzLmUgPCBvdGhlci5lID8gdGhpcy5lIDogb3RoZXIuZTtcblxuICAgIGlmIChzID49IGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhzLCBlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIEludGVydmFsIHJlcHJlc2VudGluZyB0aGUgdW5pb24gb2YgdGhpcyBJbnRlcnZhbCBhbmQgdGhlIHNwZWNpZmllZCBJbnRlcnZhbC5cbiAgICogU3BlY2lmaWNhbGx5LCB0aGUgcmVzdWx0aW5nIEludGVydmFsIGhhcyB0aGUgbWluaW11bSBzdGFydCB0aW1lIGFuZCB0aGUgbWF4aW11bSBlbmQgdGltZSBvZiB0aGUgdHdvIEludGVydmFscy5cbiAgICogQHBhcmFtIHtJbnRlcnZhbH0gb3RoZXJcbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICB1bmlvbihvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCBzID0gdGhpcy5zIDwgb3RoZXIucyA/IHRoaXMucyA6IG90aGVyLnMsXG4gICAgICBlID0gdGhpcy5lID4gb3RoZXIuZSA/IHRoaXMuZSA6IG90aGVyLmU7XG4gICAgcmV0dXJuIEludGVydmFsLmZyb21EYXRlVGltZXMocywgZSk7XG4gIH1cblxuICAvKipcbiAgICogTWVyZ2UgYW4gYXJyYXkgb2YgSW50ZXJ2YWxzIGludG8gYSBlcXVpdmFsZW50IG1pbmltYWwgc2V0IG9mIEludGVydmFscy5cbiAgICogQ29tYmluZXMgb3ZlcmxhcHBpbmcgYW5kIGFkamFjZW50IEludGVydmFscy5cbiAgICogQHBhcmFtIHtBcnJheX0gaW50ZXJ2YWxzXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3RhdGljIG1lcmdlKGludGVydmFscykge1xuICAgIGNvbnN0IFtmb3VuZCwgZmluYWxdID0gaW50ZXJ2YWxzXG4gICAgICAuc29ydCgoYSwgYikgPT4gYS5zIC0gYi5zKVxuICAgICAgLnJlZHVjZShcbiAgICAgICAgKFtzb2ZhciwgY3VycmVudF0sIGl0ZW0pID0+IHtcbiAgICAgICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBbc29mYXIsIGl0ZW1dO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudC5vdmVybGFwcyhpdGVtKSB8fCBjdXJyZW50LmFidXRzU3RhcnQoaXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbc29mYXIsIGN1cnJlbnQudW5pb24oaXRlbSldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW3NvZmFyLmNvbmNhdChbY3VycmVudF0pLCBpdGVtXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFtbXSwgbnVsbF1cbiAgICAgICk7XG4gICAgaWYgKGZpbmFsKSB7XG4gICAgICBmb3VuZC5wdXNoKGZpbmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIGZvdW5kO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBhcnJheSBvZiBJbnRlcnZhbHMgcmVwcmVzZW50aW5nIHRoZSBzcGFucyBvZiB0aW1lIHRoYXQgb25seSBhcHBlYXIgaW4gb25lIG9mIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWxzLlxuICAgKiBAcGFyYW0ge0FycmF5fSBpbnRlcnZhbHNcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzdGF0aWMgeG9yKGludGVydmFscykge1xuICAgIGxldCBzdGFydCA9IG51bGwsXG4gICAgICBjdXJyZW50Q291bnQgPSAwO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXSxcbiAgICAgIGVuZHMgPSBpbnRlcnZhbHMubWFwKChpKSA9PiBbXG4gICAgICAgIHsgdGltZTogaS5zLCB0eXBlOiBcInNcIiB9LFxuICAgICAgICB7IHRpbWU6IGkuZSwgdHlwZTogXCJlXCIgfSxcbiAgICAgIF0pLFxuICAgICAgZmxhdHRlbmVkID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdCguLi5lbmRzKSxcbiAgICAgIGFyciA9IGZsYXR0ZW5lZC5zb3J0KChhLCBiKSA9PiBhLnRpbWUgLSBiLnRpbWUpO1xuXG4gICAgZm9yIChjb25zdCBpIG9mIGFycikge1xuICAgICAgY3VycmVudENvdW50ICs9IGkudHlwZSA9PT0gXCJzXCIgPyAxIDogLTE7XG5cbiAgICAgIGlmIChjdXJyZW50Q291bnQgPT09IDEpIHtcbiAgICAgICAgc3RhcnQgPSBpLnRpbWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc3RhcnQgJiYgK3N0YXJ0ICE9PSAraS50aW1lKSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKEludGVydmFsLmZyb21EYXRlVGltZXMoc3RhcnQsIGkudGltZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBJbnRlcnZhbC5tZXJnZShyZXN1bHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gSW50ZXJ2YWwgcmVwcmVzZW50aW5nIHRoZSBzcGFuIG9mIHRpbWUgaW4gdGhpcyBJbnRlcnZhbCB0aGF0IGRvZXNuJ3Qgb3ZlcmxhcCB3aXRoIGFueSBvZiB0aGUgc3BlY2lmaWVkIEludGVydmFscy5cbiAgICogQHBhcmFtIHsuLi5JbnRlcnZhbH0gaW50ZXJ2YWxzXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgZGlmZmVyZW5jZSguLi5pbnRlcnZhbHMpIHtcbiAgICByZXR1cm4gSW50ZXJ2YWwueG9yKFt0aGlzXS5jb25jYXQoaW50ZXJ2YWxzKSlcbiAgICAgIC5tYXAoKGkpID0+IHRoaXMuaW50ZXJzZWN0aW9uKGkpKVxuICAgICAgLmZpbHRlcigoaSkgPT4gaSAmJiAhaS5pc0VtcHR5KCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBJbnRlcnZhbCBhcHByb3ByaWF0ZSBmb3IgZGVidWdnaW5nLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIElOVkFMSUQ7XG4gICAgcmV0dXJuIGBbJHt0aGlzLnMudG9JU08oKX0g4oCTICR7dGhpcy5lLnRvSVNPKCl9KWA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxvY2FsaXplZCBzdHJpbmcgcmVwcmVzZW50aW5nIHRoaXMgSW50ZXJ2YWwuIEFjY2VwdHMgdGhlIHNhbWUgb3B0aW9ucyBhcyB0aGVcbiAgICogSW50bC5EYXRlVGltZUZvcm1hdCBjb25zdHJ1Y3RvciBhbmQgYW55IHByZXNldHMgZGVmaW5lZCBieSBMdXhvbiwgc3VjaCBhc1xuICAgKiB7QGxpbmsgRGF0ZVRpbWUuREFURV9GVUxMfSBvciB7QGxpbmsgRGF0ZVRpbWUuVElNRV9TSU1QTEV9LiBUaGUgZXhhY3QgYmVoYXZpb3Igb2YgdGhpcyBtZXRob2RcbiAgICogaXMgYnJvd3Nlci1zcGVjaWZpYywgYnV0IGluIGdlbmVyYWwgaXQgd2lsbCByZXR1cm4gYW4gYXBwcm9wcmlhdGUgcmVwcmVzZW50YXRpb24gb2YgdGhlXG4gICAqIEludGVydmFsIGluIHRoZSBhc3NpZ25lZCBsb2NhbGUuIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuXG4gICAqIHNwZWNpZmllZC5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlVGltZUZvcm1hdFxuICAgKiBAcGFyYW0ge09iamVjdH0gW2Zvcm1hdE9wdHM9RGF0ZVRpbWUuREFURV9TSE9SVF0gLSBFaXRoZXIgYSBEYXRlVGltZSBwcmVzZXQgb3JcbiAgICogSW50bC5EYXRlVGltZUZvcm1hdCBjb25zdHJ1Y3RvciBvcHRpb25zLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIE9wdGlvbnMgdG8gb3ZlcnJpZGUgdGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIHN0YXJ0IERhdGVUaW1lLlxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tSVNPKCcyMDIyLTExLTA3VDA5OjAwWi8yMDIyLTExLTA4VDA5OjAwWicpLnRvTG9jYWxlU3RyaW5nKCk7IC8vPT4gMTEvNy8yMDIyIOKAkyAxMS84LzIwMjJcbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbUlTTygnMjAyMi0xMS0wN1QwOTowMFovMjAyMi0xMS0wOFQwOTowMFonKS50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5EQVRFX0ZVTEwpOyAvLz0+IE5vdmVtYmVyIDcg4oCTIDgsIDIwMjJcbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbUlTTygnMjAyMi0xMS0wN1QwOTowMFovMjAyMi0xMS0wOFQwOTowMFonKS50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5EQVRFX0ZVTEwsIHsgbG9jYWxlOiAnZnItRlInIH0pOyAvLz0+IDfigJM4IG5vdmVtYnJlIDIwMjJcbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbUlTTygnMjAyMi0xMS0wN1QxNzowMFovMjAyMi0xMS0wN1QxOTowMFonKS50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5USU1FX1NJTVBMRSk7IC8vPT4gNjowMCDigJMgODowMCBQTVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tSVNPKCcyMDIyLTExLTA3VDE3OjAwWi8yMDIyLTExLTA3VDE5OjAwWicpLnRvTG9jYWxlU3RyaW5nKHsgd2Vla2RheTogJ3Nob3J0JywgbW9udGg6ICdzaG9ydCcsIGRheTogJzItZGlnaXQnLCBob3VyOiAnMi1kaWdpdCcsIG1pbnV0ZTogJzItZGlnaXQnIH0pOyAvLz0+IE1vbiwgTm92IDA3LCA2OjAwIOKAkyA4OjAwIHBcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9Mb2NhbGVTdHJpbmcoZm9ybWF0T3B0cyA9IEZvcm1hdHMuREFURV9TSE9SVCwgb3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZFxuICAgICAgPyBGb3JtYXR0ZXIuY3JlYXRlKHRoaXMucy5sb2MuY2xvbmUob3B0cyksIGZvcm1hdE9wdHMpLmZvcm1hdEludGVydmFsKHRoaXMpXG4gICAgICA6IElOVkFMSUQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgSW50ZXJ2YWwuXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjVGltZV9pbnRlcnZhbHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBUaGUgc2FtZSBvcHRpb25zIGFzIHtAbGluayBEYXRlVGltZSN0b0lTT31cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9JU08ob3B0cykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gSU5WQUxJRDtcbiAgICByZXR1cm4gYCR7dGhpcy5zLnRvSVNPKG9wdHMpfS8ke3RoaXMuZS50b0lTTyhvcHRzKX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBkYXRlIG9mIHRoaXMgSW50ZXJ2YWwuXG4gICAqIFRoZSB0aW1lIGNvbXBvbmVudHMgYXJlIGlnbm9yZWQuXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjVGltZV9pbnRlcnZhbHNcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9JU09EYXRlKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gSU5WQUxJRDtcbiAgICByZXR1cm4gYCR7dGhpcy5zLnRvSVNPRGF0ZSgpfS8ke3RoaXMuZS50b0lTT0RhdGUoKX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aW1lIG9mIHRoaXMgSW50ZXJ2YWwuXG4gICAqIFRoZSBkYXRlIGNvbXBvbmVudHMgYXJlIGlnbm9yZWQuXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjVGltZV9pbnRlcnZhbHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBUaGUgc2FtZSBvcHRpb25zIGFzIHtAbGluayBEYXRlVGltZSN0b0lTT31cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9JU09UaW1lKG9wdHMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIElOVkFMSUQ7XG4gICAgcmV0dXJuIGAke3RoaXMucy50b0lTT1RpbWUob3B0cyl9LyR7dGhpcy5lLnRvSVNPVGltZShvcHRzKX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBJbnRlcnZhbCBmb3JtYXR0ZWQgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgZm9ybWF0XG4gICAqIHN0cmluZy4gKipZb3UgbWF5IG5vdCB3YW50IHRoaXMuKiogU2VlIHtAbGluayBJbnRlcnZhbCN0b0xvY2FsZVN0cmluZ30gZm9yIGEgbW9yZSBmbGV4aWJsZVxuICAgKiBmb3JtYXR0aW5nIHRvb2wuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRlRm9ybWF0IC0gVGhlIGZvcm1hdCBzdHJpbmcuIFRoaXMgc3RyaW5nIGZvcm1hdHMgdGhlIHN0YXJ0IGFuZCBlbmQgdGltZS5cbiAgICogU2VlIHtAbGluayBEYXRlVGltZSN0b0Zvcm1hdH0gZm9yIGRldGFpbHMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gT3B0aW9ucy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnNlcGFyYXRvciA9ICAnIOKAkyAnXSAtIEEgc2VwYXJhdG9yIHRvIHBsYWNlIGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBlbmRcbiAgICogcmVwcmVzZW50YXRpb25zLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0Zvcm1hdChkYXRlRm9ybWF0LCB7IHNlcGFyYXRvciA9IFwiIOKAkyBcIiB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIElOVkFMSUQ7XG4gICAgcmV0dXJuIGAke3RoaXMucy50b0Zvcm1hdChkYXRlRm9ybWF0KX0ke3NlcGFyYXRvcn0ke3RoaXMuZS50b0Zvcm1hdChkYXRlRm9ybWF0KX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIER1cmF0aW9uIHJlcHJlc2VudGluZyB0aGUgdGltZSBzcGFubmVkIGJ5IHRoaXMgaW50ZXJ2YWwuXG4gICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBbdW5pdD1bJ21pbGxpc2Vjb25kcyddXSAtIHRoZSB1bml0IG9yIHVuaXRzIChzdWNoIGFzICdob3Vycycgb3IgJ2RheXMnKSB0byBpbmNsdWRlIGluIHRoZSBkdXJhdGlvbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRoYXQgYWZmZWN0IHRoZSBjcmVhdGlvbiBvZiB0aGUgRHVyYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmNvbnZlcnNpb25BY2N1cmFjeT0nY2FzdWFsJ10gLSB0aGUgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQxLCBkdDIpLnRvRHVyYXRpb24oKS50b09iamVjdCgpIC8vPT4geyBtaWxsaXNlY29uZHM6IDg4NDg5MjU3IH1cbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdDEsIGR0MikudG9EdXJhdGlvbignZGF5cycpLnRvT2JqZWN0KCkgLy89PiB7IGRheXM6IDEuMDI0MTgxMjE1Mjc3Nzc3OCB9XG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQxLCBkdDIpLnRvRHVyYXRpb24oWydob3VycycsICdtaW51dGVzJ10pLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAyNCwgbWludXRlczogMzQuODIwOTUgfVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0MSwgZHQyKS50b0R1cmF0aW9uKFsnaG91cnMnLCAnbWludXRlcycsICdzZWNvbmRzJ10pLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAyNCwgbWludXRlczogMzQsIHNlY29uZHM6IDQ5LjI1NyB9XG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQxLCBkdDIpLnRvRHVyYXRpb24oJ3NlY29uZHMnKS50b09iamVjdCgpIC8vPT4geyBzZWNvbmRzOiA4ODQ4OS4yNTcgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHRvRHVyYXRpb24odW5pdCwgb3B0cykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gRHVyYXRpb24uaW52YWxpZCh0aGlzLmludmFsaWRSZWFzb24pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lLmRpZmYodGhpcy5zLCB1bml0LCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW4gbWFwRm4gb24gdGhlIGludGVydmFsIHN0YXJ0IGFuZCBlbmQsIHJldHVybmluZyBhIG5ldyBJbnRlcnZhbCBmcm9tIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWVzXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG1hcEZuXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0MSwgZHQyKS5tYXBFbmRwb2ludHMoZW5kcG9pbnQgPT4gZW5kcG9pbnQudG9VVEMoKSlcbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdDEsIGR0MikubWFwRW5kcG9pbnRzKGVuZHBvaW50ID0+IGVuZHBvaW50LnBsdXMoeyBob3VyczogMiB9KSlcbiAgICovXG4gIG1hcEVuZHBvaW50cyhtYXBGbikge1xuICAgIHJldHVybiBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKG1hcEZuKHRoaXMucyksIG1hcEZuKHRoaXMuZSkpO1xuICB9XG59XG4iLCAiaW1wb3J0IERhdGVUaW1lIGZyb20gXCIuL2RhdGV0aW1lLmpzXCI7XG5pbXBvcnQgU2V0dGluZ3MgZnJvbSBcIi4vc2V0dGluZ3MuanNcIjtcbmltcG9ydCBMb2NhbGUgZnJvbSBcIi4vaW1wbC9sb2NhbGUuanNcIjtcbmltcG9ydCBJQU5BWm9uZSBmcm9tIFwiLi96b25lcy9JQU5BWm9uZS5qc1wiO1xuaW1wb3J0IHsgbm9ybWFsaXplWm9uZSB9IGZyb20gXCIuL2ltcGwvem9uZVV0aWwuanNcIjtcblxuaW1wb3J0IHsgaGFzUmVsYXRpdmUgfSBmcm9tIFwiLi9pbXBsL3V0aWwuanNcIjtcblxuLyoqXG4gKiBUaGUgSW5mbyBjbGFzcyBjb250YWlucyBzdGF0aWMgbWV0aG9kcyBmb3IgcmV0cmlldmluZyBnZW5lcmFsIHRpbWUgYW5kIGRhdGUgcmVsYXRlZCBkYXRhLiBGb3IgZXhhbXBsZSwgaXQgaGFzIG1ldGhvZHMgZm9yIGZpbmRpbmcgb3V0IGlmIGEgdGltZSB6b25lIGhhcyBhIERTVCwgZm9yIGxpc3RpbmcgdGhlIG1vbnRocyBpbiBhbnkgc3VwcG9ydGVkIGxvY2FsZSwgYW5kIGZvciBkaXNjb3ZlcmluZyB3aGljaCBvZiBMdXhvbiBmZWF0dXJlcyBhcmUgYXZhaWxhYmxlIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50LlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbmZvIHtcbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgem9uZSBjb250YWlucyBhIERTVC5cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW3pvbmU9J2xvY2FsJ10gLSBab25lIHRvIGNoZWNrLiBEZWZhdWx0cyB0byB0aGUgZW52aXJvbm1lbnQncyBsb2NhbCB6b25lLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGhhc0RTVCh6b25lID0gU2V0dGluZ3MuZGVmYXVsdFpvbmUpIHtcbiAgICBjb25zdCBwcm90byA9IERhdGVUaW1lLm5vdygpLnNldFpvbmUoem9uZSkuc2V0KHsgbW9udGg6IDEyIH0pO1xuXG4gICAgcmV0dXJuICF6b25lLmlzVW5pdmVyc2FsICYmIHByb3RvLm9mZnNldCAhPT0gcHJvdG8uc2V0KHsgbW9udGg6IDYgfSkub2Zmc2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgem9uZSBpcyBhIHZhbGlkIElBTkEgc3BlY2lmaWVyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gem9uZSAtIFpvbmUgdG8gY2hlY2tcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc1ZhbGlkSUFOQVpvbmUoem9uZSkge1xuICAgIHJldHVybiBJQU5BWm9uZS5pc1ZhbGlkWm9uZSh6b25lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgaW5wdXQgaW50byBhIHtAbGluayBab25lfSBpbnN0YW5jZS5cbiAgICpcbiAgICogKiBJZiBgaW5wdXRgIGlzIGFscmVhZHkgYSBab25lIGluc3RhbmNlLCBpdCBpcyByZXR1cm5lZCB1bmNoYW5nZWQuXG4gICAqICogSWYgYGlucHV0YCBpcyBhIHN0cmluZyBjb250YWluaW5nIGEgdmFsaWQgdGltZSB6b25lIG5hbWUsIGEgWm9uZSBpbnN0YW5jZVxuICAgKiAgIHdpdGggdGhhdCBuYW1lIGlzIHJldHVybmVkLlxuICAgKiAqIElmIGBpbnB1dGAgaXMgYSBzdHJpbmcgdGhhdCBkb2Vzbid0IHJlZmVyIHRvIGEga25vd24gdGltZSB6b25lLCBhIFpvbmVcbiAgICogICBpbnN0YW5jZSB3aXRoIHtAbGluayBab25lI2lzVmFsaWR9ID09IGZhbHNlIGlzIHJldHVybmVkLlxuICAgKiAqIElmIGBpbnB1dCBpcyBhIG51bWJlciwgYSBab25lIGluc3RhbmNlIHdpdGggdGhlIHNwZWNpZmllZCBmaXhlZCBvZmZzZXRcbiAgICogICBpbiBtaW51dGVzIGlzIHJldHVybmVkLlxuICAgKiAqIElmIGBpbnB1dGAgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgLCB0aGUgZGVmYXVsdCB6b25lIGlzIHJldHVybmVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfG51bWJlcn0gW2lucHV0XSAtIHRoZSB2YWx1ZSB0byBiZSBjb252ZXJ0ZWRcbiAgICogQHJldHVybiB7Wm9uZX1cbiAgICovXG4gIHN0YXRpYyBub3JtYWxpemVab25lKGlucHV0KSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZVpvbmUoaW5wdXQsIFNldHRpbmdzLmRlZmF1bHRab25lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2Ygc3RhbmRhbG9uZSBtb250aCBuYW1lcy5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlVGltZUZvcm1hdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xlbmd0aD0nbG9uZyddIC0gdGhlIGxlbmd0aCBvZiB0aGUgbW9udGggcmVwcmVzZW50YXRpb24sIHN1Y2ggYXMgXCJudW1lcmljXCIsIFwiMi1kaWdpdFwiLCBcIm5hcnJvd1wiLCBcInNob3J0XCIsIFwibG9uZ1wiXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlXSAtIHRoZSBsb2NhbGUgY29kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubnVtYmVyaW5nU3lzdGVtPW51bGxdIC0gdGhlIG51bWJlcmluZyBzeXN0ZW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY09iaj1udWxsXSAtIGFuIGV4aXN0aW5nIGxvY2FsZSBvYmplY3QgdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5vdXRwdXRDYWxlbmRhcj0nZ3JlZ29yeSddIC0gdGhlIGNhbGVuZGFyXG4gICAqIEBleGFtcGxlIEluZm8ubW9udGhzKClbMF0gLy89PiAnSmFudWFyeSdcbiAgICogQGV4YW1wbGUgSW5mby5tb250aHMoJ3Nob3J0JylbMF0gLy89PiAnSmFuJ1xuICAgKiBAZXhhbXBsZSBJbmZvLm1vbnRocygnbnVtZXJpYycpWzBdIC8vPT4gJzEnXG4gICAqIEBleGFtcGxlIEluZm8ubW9udGhzKCdzaG9ydCcsIHsgbG9jYWxlOiAnZnItQ0EnIH0gKVswXSAvLz0+ICdqYW52LidcbiAgICogQGV4YW1wbGUgSW5mby5tb250aHMoJ251bWVyaWMnLCB7IGxvY2FsZTogJ2FyJyB9KVswXSAvLz0+ICfZoSdcbiAgICogQGV4YW1wbGUgSW5mby5tb250aHMoJ2xvbmcnLCB7IG91dHB1dENhbGVuZGFyOiAnaXNsYW1pYycgfSlbMF0gLy89PiAnUmFiacq7IEknXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3RhdGljIG1vbnRocyhcbiAgICBsZW5ndGggPSBcImxvbmdcIixcbiAgICB7IGxvY2FsZSA9IG51bGwsIG51bWJlcmluZ1N5c3RlbSA9IG51bGwsIGxvY09iaiA9IG51bGwsIG91dHB1dENhbGVuZGFyID0gXCJncmVnb3J5XCIgfSA9IHt9XG4gICkge1xuICAgIHJldHVybiAobG9jT2JqIHx8IExvY2FsZS5jcmVhdGUobG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyKSkubW9udGhzKGxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGFycmF5IG9mIGZvcm1hdCBtb250aCBuYW1lcy5cbiAgICogRm9ybWF0IG1vbnRocyBkaWZmZXIgZnJvbSBzdGFuZGFsb25lIG1vbnRocyBpbiB0aGF0IHRoZXkncmUgbWVhbnQgdG8gYXBwZWFyIG5leHQgdG8gdGhlIGRheSBvZiB0aGUgbW9udGguIEluIHNvbWUgbGFuZ3VhZ2VzLCB0aGF0XG4gICAqIGNoYW5nZXMgdGhlIHN0cmluZy5cbiAgICogU2VlIHtAbGluayBJbmZvI21vbnRoc31cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsZW5ndGg9J2xvbmcnXSAtIHRoZSBsZW5ndGggb2YgdGhlIG1vbnRoIHJlcHJlc2VudGF0aW9uLCBzdWNoIGFzIFwibnVtZXJpY1wiLCBcIjItZGlnaXRcIiwgXCJuYXJyb3dcIiwgXCJzaG9ydFwiLCBcImxvbmdcIlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZV0gLSB0aGUgbG9jYWxlIGNvZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm51bWJlcmluZ1N5c3RlbT1udWxsXSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NPYmo9bnVsbF0gLSBhbiBleGlzdGluZyBsb2NhbGUgb2JqZWN0IHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMub3V0cHV0Q2FsZW5kYXI9J2dyZWdvcnknXSAtIHRoZSBjYWxlbmRhclxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyBtb250aHNGb3JtYXQoXG4gICAgbGVuZ3RoID0gXCJsb25nXCIsXG4gICAgeyBsb2NhbGUgPSBudWxsLCBudW1iZXJpbmdTeXN0ZW0gPSBudWxsLCBsb2NPYmogPSBudWxsLCBvdXRwdXRDYWxlbmRhciA9IFwiZ3JlZ29yeVwiIH0gPSB7fVxuICApIHtcbiAgICByZXR1cm4gKGxvY09iaiB8fCBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhcikpLm1vbnRocyhsZW5ndGgsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBhcnJheSBvZiBzdGFuZGFsb25lIHdlZWsgbmFtZXMuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZVRpbWVGb3JtYXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsZW5ndGg9J2xvbmcnXSAtIHRoZSBsZW5ndGggb2YgdGhlIHdlZWtkYXkgcmVwcmVzZW50YXRpb24sIHN1Y2ggYXMgXCJuYXJyb3dcIiwgXCJzaG9ydFwiLCBcImxvbmdcIi5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGVdIC0gdGhlIGxvY2FsZSBjb2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5udW1iZXJpbmdTeXN0ZW09bnVsbF0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jT2JqPW51bGxdIC0gYW4gZXhpc3RpbmcgbG9jYWxlIG9iamVjdCB0byB1c2VcbiAgICogQGV4YW1wbGUgSW5mby53ZWVrZGF5cygpWzBdIC8vPT4gJ01vbmRheSdcbiAgICogQGV4YW1wbGUgSW5mby53ZWVrZGF5cygnc2hvcnQnKVswXSAvLz0+ICdNb24nXG4gICAqIEBleGFtcGxlIEluZm8ud2Vla2RheXMoJ3Nob3J0JywgeyBsb2NhbGU6ICdmci1DQScgfSlbMF0gLy89PiAnbHVuLidcbiAgICogQGV4YW1wbGUgSW5mby53ZWVrZGF5cygnc2hvcnQnLCB7IGxvY2FsZTogJ2FyJyB9KVswXSAvLz0+ICfYp9mE2KfYq9mG2YrZhidcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzdGF0aWMgd2Vla2RheXMobGVuZ3RoID0gXCJsb25nXCIsIHsgbG9jYWxlID0gbnVsbCwgbnVtYmVyaW5nU3lzdGVtID0gbnVsbCwgbG9jT2JqID0gbnVsbCB9ID0ge30pIHtcbiAgICByZXR1cm4gKGxvY09iaiB8fCBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBudWxsKSkud2Vla2RheXMobGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgZm9ybWF0IHdlZWsgbmFtZXMuXG4gICAqIEZvcm1hdCB3ZWVrZGF5cyBkaWZmZXIgZnJvbSBzdGFuZGFsb25lIHdlZWtkYXlzIGluIHRoYXQgdGhleSdyZSBtZWFudCB0byBhcHBlYXIgbmV4dCB0byBtb3JlIGRhdGUgaW5mb3JtYXRpb24uIEluIHNvbWUgbGFuZ3VhZ2VzLCB0aGF0XG4gICAqIGNoYW5nZXMgdGhlIHN0cmluZy5cbiAgICogU2VlIHtAbGluayBJbmZvI3dlZWtkYXlzfVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xlbmd0aD0nbG9uZyddIC0gdGhlIGxlbmd0aCBvZiB0aGUgbW9udGggcmVwcmVzZW50YXRpb24sIHN1Y2ggYXMgXCJuYXJyb3dcIiwgXCJzaG9ydFwiLCBcImxvbmdcIi5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9bnVsbF0gLSB0aGUgbG9jYWxlIGNvZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm51bWJlcmluZ1N5c3RlbT1udWxsXSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NPYmo9bnVsbF0gLSBhbiBleGlzdGluZyBsb2NhbGUgb2JqZWN0IHRvIHVzZVxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyB3ZWVrZGF5c0Zvcm1hdChcbiAgICBsZW5ndGggPSBcImxvbmdcIixcbiAgICB7IGxvY2FsZSA9IG51bGwsIG51bWJlcmluZ1N5c3RlbSA9IG51bGwsIGxvY09iaiA9IG51bGwgfSA9IHt9XG4gICkge1xuICAgIHJldHVybiAobG9jT2JqIHx8IExvY2FsZS5jcmVhdGUobG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG51bGwpKS53ZWVrZGF5cyhsZW5ndGgsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBhcnJheSBvZiBtZXJpZGllbXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlXSAtIHRoZSBsb2NhbGUgY29kZVxuICAgKiBAZXhhbXBsZSBJbmZvLm1lcmlkaWVtcygpIC8vPT4gWyAnQU0nLCAnUE0nIF1cbiAgICogQGV4YW1wbGUgSW5mby5tZXJpZGllbXMoeyBsb2NhbGU6ICdteScgfSkgLy89PiBbICfhgJThgLbhgJThgIDhgLonLCAn4YCK4YCU4YCxJyBdXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3RhdGljIG1lcmlkaWVtcyh7IGxvY2FsZSA9IG51bGwgfSA9IHt9KSB7XG4gICAgcmV0dXJuIExvY2FsZS5jcmVhdGUobG9jYWxlKS5tZXJpZGllbXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgZXJhcywgc3VjaCBhcyBbJ0JDJywgJ0FEJ10uIFRoZSBsb2NhbGUgY2FuIGJlIHNwZWNpZmllZCwgYnV0IHRoZSBjYWxlbmRhciBzeXN0ZW0gaXMgYWx3YXlzIEdyZWdvcmlhbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsZW5ndGg9J3Nob3J0J10gLSB0aGUgbGVuZ3RoIG9mIHRoZSBlcmEgcmVwcmVzZW50YXRpb24sIHN1Y2ggYXMgXCJzaG9ydFwiIG9yIFwibG9uZ1wiLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZV0gLSB0aGUgbG9jYWxlIGNvZGVcbiAgICogQGV4YW1wbGUgSW5mby5lcmFzKCkgLy89PiBbICdCQycsICdBRCcgXVxuICAgKiBAZXhhbXBsZSBJbmZvLmVyYXMoJ2xvbmcnKSAvLz0+IFsgJ0JlZm9yZSBDaHJpc3QnLCAnQW5ubyBEb21pbmknIF1cbiAgICogQGV4YW1wbGUgSW5mby5lcmFzKCdsb25nJywgeyBsb2NhbGU6ICdmcicgfSkgLy89PiBbICdhdmFudCBKw6lzdXMtQ2hyaXN0JywgJ2FwcsOocyBKw6lzdXMtQ2hyaXN0JyBdXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3RhdGljIGVyYXMobGVuZ3RoID0gXCJzaG9ydFwiLCB7IGxvY2FsZSA9IG51bGwgfSA9IHt9KSB7XG4gICAgcmV0dXJuIExvY2FsZS5jcmVhdGUobG9jYWxlLCBudWxsLCBcImdyZWdvcnlcIikuZXJhcyhsZW5ndGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgc2V0IG9mIGF2YWlsYWJsZSBmZWF0dXJlcyBpbiB0aGlzIGVudmlyb25tZW50LlxuICAgKiBTb21lIGZlYXR1cmVzIG9mIEx1eG9uIGFyZSBub3QgYXZhaWxhYmxlIGluIGFsbCBlbnZpcm9ubWVudHMuIEZvciBleGFtcGxlLCBvbiBvbGRlciBicm93c2VycywgcmVsYXRpdmUgdGltZSBmb3JtYXR0aW5nIHN1cHBvcnQgaXMgbm90IGF2YWlsYWJsZS4gVXNlIHRoaXMgZnVuY3Rpb24gdG8gZmlndXJlIG91dCBpZiB0aGF0J3MgdGhlIGNhc2UuXG4gICAqIEtleXM6XG4gICAqICogYHJlbGF0aXZlYDogd2hldGhlciB0aGlzIGVudmlyb25tZW50IHN1cHBvcnRzIHJlbGF0aXZlIHRpbWUgZm9ybWF0dGluZ1xuICAgKiBAZXhhbXBsZSBJbmZvLmZlYXR1cmVzKCkgLy89PiB7IHJlbGF0aXZlOiBmYWxzZSB9XG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBmZWF0dXJlcygpIHtcbiAgICByZXR1cm4geyByZWxhdGl2ZTogaGFzUmVsYXRpdmUoKSB9O1xuICB9XG59XG4iLCAiaW1wb3J0IER1cmF0aW9uIGZyb20gXCIuLi9kdXJhdGlvbi5qc1wiO1xuXG5mdW5jdGlvbiBkYXlEaWZmKGVhcmxpZXIsIGxhdGVyKSB7XG4gIGNvbnN0IHV0Y0RheVN0YXJ0ID0gKGR0KSA9PiBkdC50b1VUQygwLCB7IGtlZXBMb2NhbFRpbWU6IHRydWUgfSkuc3RhcnRPZihcImRheVwiKS52YWx1ZU9mKCksXG4gICAgbXMgPSB1dGNEYXlTdGFydChsYXRlcikgLSB1dGNEYXlTdGFydChlYXJsaWVyKTtcbiAgcmV0dXJuIE1hdGguZmxvb3IoRHVyYXRpb24uZnJvbU1pbGxpcyhtcykuYXMoXCJkYXlzXCIpKTtcbn1cblxuZnVuY3Rpb24gaGlnaE9yZGVyRGlmZnMoY3Vyc29yLCBsYXRlciwgdW5pdHMpIHtcbiAgY29uc3QgZGlmZmVycyA9IFtcbiAgICBbXCJ5ZWFyc1wiLCAoYSwgYikgPT4gYi55ZWFyIC0gYS55ZWFyXSxcbiAgICBbXCJxdWFydGVyc1wiLCAoYSwgYikgPT4gYi5xdWFydGVyIC0gYS5xdWFydGVyICsgKGIueWVhciAtIGEueWVhcikgKiA0XSxcbiAgICBbXCJtb250aHNcIiwgKGEsIGIpID0+IGIubW9udGggLSBhLm1vbnRoICsgKGIueWVhciAtIGEueWVhcikgKiAxMl0sXG4gICAgW1xuICAgICAgXCJ3ZWVrc1wiLFxuICAgICAgKGEsIGIpID0+IHtcbiAgICAgICAgY29uc3QgZGF5cyA9IGRheURpZmYoYSwgYik7XG4gICAgICAgIHJldHVybiAoZGF5cyAtIChkYXlzICUgNykpIC8gNztcbiAgICAgIH0sXG4gICAgXSxcbiAgICBbXCJkYXlzXCIsIGRheURpZmZdLFxuICBdO1xuXG4gIGNvbnN0IHJlc3VsdHMgPSB7fTtcbiAgY29uc3QgZWFybGllciA9IGN1cnNvcjtcbiAgbGV0IGxvd2VzdE9yZGVyLCBoaWdoV2F0ZXI7XG5cbiAgLyogVGhpcyBsb29wIHRyaWVzIHRvIGRpZmYgdXNpbmcgbGFyZ2VyIHVuaXRzIGZpcnN0LlxuICAgICBJZiB3ZSBvdmVyc2hvb3QsIHdlIGJhY2t0cmFjayBhbmQgdHJ5IHRoZSBuZXh0IHNtYWxsZXIgdW5pdC5cbiAgICAgXCJjdXJzb3JcIiBzdGFydHMgb3V0IGF0IHRoZSBlYXJsaWVyIHRpbWVzdGFtcCBhbmQgbW92ZXMgY2xvc2VyIGFuZCBjbG9zZXIgdG8gXCJsYXRlclwiXG4gICAgIGFzIHdlIHVzZSBzbWFsbGVyIGFuZCBzbWFsbGVyIHVuaXRzLlxuICAgICBoaWdoV2F0ZXIga2VlcHMgdHJhY2sgb2Ygd2hlcmUgd2Ugd291bGQgYmUgaWYgd2UgYWRkZWQgb25lIG1vcmUgb2YgdGhlIHNtYWxsZXN0IHVuaXQsXG4gICAgIHRoaXMgaXMgdXNlZCBsYXRlciB0byBwb3RlbnRpYWxseSBjb252ZXJ0IGFueSBkaWZmZXJlbmNlIHNtYWxsZXIgdGhhbiB0aGUgc21hbGxlc3QgaGlnaGVyIG9yZGVyIHVuaXRcbiAgICAgaW50byBhIGZyYWN0aW9uIG9mIHRoYXQgc21hbGxlc3QgaGlnaGVyIG9yZGVyIHVuaXRcbiAgKi9cbiAgZm9yIChjb25zdCBbdW5pdCwgZGlmZmVyXSBvZiBkaWZmZXJzKSB7XG4gICAgaWYgKHVuaXRzLmluZGV4T2YodW5pdCkgPj0gMCkge1xuICAgICAgbG93ZXN0T3JkZXIgPSB1bml0O1xuXG4gICAgICByZXN1bHRzW3VuaXRdID0gZGlmZmVyKGN1cnNvciwgbGF0ZXIpO1xuICAgICAgaGlnaFdhdGVyID0gZWFybGllci5wbHVzKHJlc3VsdHMpO1xuXG4gICAgICBpZiAoaGlnaFdhdGVyID4gbGF0ZXIpIHtcbiAgICAgICAgLy8gd2Ugb3ZlcnNob3QgdGhlIGVuZCBwb2ludCwgYmFja3RyYWNrIGN1cnNvciBieSAxXG4gICAgICAgIHJlc3VsdHNbdW5pdF0tLTtcbiAgICAgICAgY3Vyc29yID0gZWFybGllci5wbHVzKHJlc3VsdHMpO1xuXG4gICAgICAgIC8vIGlmIHdlIGFyZSBzdGlsbCBvdmVyc2hvb3Rpbmcgbm93LCB3ZSBuZWVkIHRvIGJhY2t0cmFjayBhZ2FpblxuICAgICAgICAvLyB0aGlzIGhhcHBlbnMgaW4gY2VydGFpbiBzaXR1YXRpb25zIHdoZW4gZGlmZmluZyB0aW1lcyBpbiBkaWZmZXJlbnQgem9uZXMsXG4gICAgICAgIC8vIGJlY2F1c2UgdGhpcyBjYWxjdWxhdGlvbiBpZ25vcmVzIHRpbWUgem9uZXNcbiAgICAgICAgaWYgKGN1cnNvciA+IGxhdGVyKSB7XG4gICAgICAgICAgLy8ga2VlcCB0aGUgXCJvdmVyc2hvdCBieSAxXCIgYXJvdW5kIGFzIGhpZ2hXYXRlclxuICAgICAgICAgIGhpZ2hXYXRlciA9IGN1cnNvcjtcbiAgICAgICAgICAvLyBiYWNrdHJhY2sgY3Vyc29yIGJ5IDFcbiAgICAgICAgICByZXN1bHRzW3VuaXRdLS07XG4gICAgICAgICAgY3Vyc29yID0gZWFybGllci5wbHVzKHJlc3VsdHMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJzb3IgPSBoaWdoV2F0ZXI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFtjdXJzb3IsIHJlc3VsdHMsIGhpZ2hXYXRlciwgbG93ZXN0T3JkZXJdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoZWFybGllciwgbGF0ZXIsIHVuaXRzLCBvcHRzKSB7XG4gIGxldCBbY3Vyc29yLCByZXN1bHRzLCBoaWdoV2F0ZXIsIGxvd2VzdE9yZGVyXSA9IGhpZ2hPcmRlckRpZmZzKGVhcmxpZXIsIGxhdGVyLCB1bml0cyk7XG5cbiAgY29uc3QgcmVtYWluaW5nTWlsbGlzID0gbGF0ZXIgLSBjdXJzb3I7XG5cbiAgY29uc3QgbG93ZXJPcmRlclVuaXRzID0gdW5pdHMuZmlsdGVyKFxuICAgICh1KSA9PiBbXCJob3Vyc1wiLCBcIm1pbnV0ZXNcIiwgXCJzZWNvbmRzXCIsIFwibWlsbGlzZWNvbmRzXCJdLmluZGV4T2YodSkgPj0gMFxuICApO1xuXG4gIGlmIChsb3dlck9yZGVyVW5pdHMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGhpZ2hXYXRlciA8IGxhdGVyKSB7XG4gICAgICBoaWdoV2F0ZXIgPSBjdXJzb3IucGx1cyh7IFtsb3dlc3RPcmRlcl06IDEgfSk7XG4gICAgfVxuXG4gICAgaWYgKGhpZ2hXYXRlciAhPT0gY3Vyc29yKSB7XG4gICAgICByZXN1bHRzW2xvd2VzdE9yZGVyXSA9IChyZXN1bHRzW2xvd2VzdE9yZGVyXSB8fCAwKSArIHJlbWFpbmluZ01pbGxpcyAvIChoaWdoV2F0ZXIgLSBjdXJzb3IpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGR1cmF0aW9uID0gRHVyYXRpb24uZnJvbU9iamVjdChyZXN1bHRzLCBvcHRzKTtcblxuICBpZiAobG93ZXJPcmRlclVuaXRzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gRHVyYXRpb24uZnJvbU1pbGxpcyhyZW1haW5pbmdNaWxsaXMsIG9wdHMpXG4gICAgICAuc2hpZnRUbyguLi5sb3dlck9yZGVyVW5pdHMpXG4gICAgICAucGx1cyhkdXJhdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGR1cmF0aW9uO1xuICB9XG59XG4iLCAiY29uc3QgbnVtYmVyaW5nU3lzdGVtcyA9IHtcbiAgYXJhYjogXCJbXFx1MDY2MC1cXHUwNjY5XVwiLFxuICBhcmFiZXh0OiBcIltcXHUwNkYwLVxcdTA2RjldXCIsXG4gIGJhbGk6IFwiW1xcdTFCNTAtXFx1MUI1OV1cIixcbiAgYmVuZzogXCJbXFx1MDlFNi1cXHUwOUVGXVwiLFxuICBkZXZhOiBcIltcXHUwOTY2LVxcdTA5NkZdXCIsXG4gIGZ1bGx3aWRlOiBcIltcXHVGRjEwLVxcdUZGMTldXCIsXG4gIGd1anI6IFwiW1xcdTBBRTYtXFx1MEFFRl1cIixcbiAgaGFuaWRlYzogXCJb44CHfOS4gHzkuox85LiJfOWbm3zkupR85YWtfOS4g3zlhat85LmdXVwiLFxuICBraG1yOiBcIltcXHUxN0UwLVxcdTE3RTldXCIsXG4gIGtuZGE6IFwiW1xcdTBDRTYtXFx1MENFRl1cIixcbiAgbGFvbzogXCJbXFx1MEVEMC1cXHUwRUQ5XVwiLFxuICBsaW1iOiBcIltcXHUxOTQ2LVxcdTE5NEZdXCIsXG4gIG1seW06IFwiW1xcdTBENjYtXFx1MEQ2Rl1cIixcbiAgbW9uZzogXCJbXFx1MTgxMC1cXHUxODE5XVwiLFxuICBteW1yOiBcIltcXHUxMDQwLVxcdTEwNDldXCIsXG4gIG9yeWE6IFwiW1xcdTBCNjYtXFx1MEI2Rl1cIixcbiAgdGFtbGRlYzogXCJbXFx1MEJFNi1cXHUwQkVGXVwiLFxuICB0ZWx1OiBcIltcXHUwQzY2LVxcdTBDNkZdXCIsXG4gIHRoYWk6IFwiW1xcdTBFNTAtXFx1MEU1OV1cIixcbiAgdGlidDogXCJbXFx1MEYyMC1cXHUwRjI5XVwiLFxuICBsYXRuOiBcIlxcXFxkXCIsXG59O1xuXG5jb25zdCBudW1iZXJpbmdTeXN0ZW1zVVRGMTYgPSB7XG4gIGFyYWI6IFsxNjMyLCAxNjQxXSxcbiAgYXJhYmV4dDogWzE3NzYsIDE3ODVdLFxuICBiYWxpOiBbNjk5MiwgNzAwMV0sXG4gIGJlbmc6IFsyNTM0LCAyNTQzXSxcbiAgZGV2YTogWzI0MDYsIDI0MTVdLFxuICBmdWxsd2lkZTogWzY1Mjk2LCA2NTMwM10sXG4gIGd1anI6IFsyNzkwLCAyNzk5XSxcbiAga2htcjogWzYxMTIsIDYxMjFdLFxuICBrbmRhOiBbMzMwMiwgMzMxMV0sXG4gIGxhb286IFszNzkyLCAzODAxXSxcbiAgbGltYjogWzY0NzAsIDY0NzldLFxuICBtbHltOiBbMzQzMCwgMzQzOV0sXG4gIG1vbmc6IFs2MTYwLCA2MTY5XSxcbiAgbXltcjogWzQxNjAsIDQxNjldLFxuICBvcnlhOiBbMjkxOCwgMjkyN10sXG4gIHRhbWxkZWM6IFszMDQ2LCAzMDU1XSxcbiAgdGVsdTogWzMxNzQsIDMxODNdLFxuICB0aGFpOiBbMzY2NCwgMzY3M10sXG4gIHRpYnQ6IFszODcyLCAzODgxXSxcbn07XG5cbmNvbnN0IGhhbmlkZWNDaGFycyA9IG51bWJlcmluZ1N5c3RlbXMuaGFuaWRlYy5yZXBsYWNlKC9bXFxbfFxcXV0vZywgXCJcIikuc3BsaXQoXCJcIik7XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZURpZ2l0cyhzdHIpIHtcbiAgbGV0IHZhbHVlID0gcGFyc2VJbnQoc3RyLCAxMCk7XG4gIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcblxuICAgICAgaWYgKHN0cltpXS5zZWFyY2gobnVtYmVyaW5nU3lzdGVtcy5oYW5pZGVjKSAhPT0gLTEpIHtcbiAgICAgICAgdmFsdWUgKz0gaGFuaWRlY0NoYXJzLmluZGV4T2Yoc3RyW2ldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG51bWJlcmluZ1N5c3RlbXNVVEYxNikge1xuICAgICAgICAgIGNvbnN0IFttaW4sIG1heF0gPSBudW1iZXJpbmdTeXN0ZW1zVVRGMTZba2V5XTtcbiAgICAgICAgICBpZiAoY29kZSA+PSBtaW4gJiYgY29kZSA8PSBtYXgpIHtcbiAgICAgICAgICAgIHZhbHVlICs9IGNvZGUgLSBtaW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlnaXRSZWdleCh7IG51bWJlcmluZ1N5c3RlbSB9LCBhcHBlbmQgPSBcIlwiKSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKGAke251bWJlcmluZ1N5c3RlbXNbbnVtYmVyaW5nU3lzdGVtIHx8IFwibGF0blwiXX0ke2FwcGVuZH1gKTtcbn1cbiIsICJpbXBvcnQgeyBwYXJzZU1pbGxpcywgaXNVbmRlZmluZWQsIHVudHJ1bmNhdGVZZWFyLCBzaWduZWRPZmZzZXQsIGhhc093blByb3BlcnR5IH0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuaW1wb3J0IEZvcm1hdHRlciBmcm9tIFwiLi9mb3JtYXR0ZXIuanNcIjtcbmltcG9ydCBGaXhlZE9mZnNldFpvbmUgZnJvbSBcIi4uL3pvbmVzL2ZpeGVkT2Zmc2V0Wm9uZS5qc1wiO1xuaW1wb3J0IElBTkFab25lIGZyb20gXCIuLi96b25lcy9JQU5BWm9uZS5qc1wiO1xuaW1wb3J0IERhdGVUaW1lIGZyb20gXCIuLi9kYXRldGltZS5qc1wiO1xuaW1wb3J0IHsgZGlnaXRSZWdleCwgcGFyc2VEaWdpdHMgfSBmcm9tIFwiLi9kaWdpdHMuanNcIjtcbmltcG9ydCB7IENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yIH0gZnJvbSBcIi4uL2Vycm9ycy5qc1wiO1xuXG5jb25zdCBNSVNTSU5HX0ZUUCA9IFwibWlzc2luZyBJbnRsLkRhdGVUaW1lRm9ybWF0LmZvcm1hdFRvUGFydHMgc3VwcG9ydFwiO1xuXG5mdW5jdGlvbiBpbnRVbml0KHJlZ2V4LCBwb3N0ID0gKGkpID0+IGkpIHtcbiAgcmV0dXJuIHsgcmVnZXgsIGRlc2VyOiAoW3NdKSA9PiBwb3N0KHBhcnNlRGlnaXRzKHMpKSB9O1xufVxuXG5jb25zdCBOQlNQID0gU3RyaW5nLmZyb21DaGFyQ29kZSgxNjApO1xuY29uc3Qgc3BhY2VPck5CU1AgPSBgWyAke05CU1B9XWA7XG5jb25zdCBzcGFjZU9yTkJTUFJlZ0V4cCA9IG5ldyBSZWdFeHAoc3BhY2VPck5CU1AsIFwiZ1wiKTtcblxuZnVuY3Rpb24gZml4TGlzdFJlZ2V4KHMpIHtcbiAgLy8gbWFrZSBkb3RzIG9wdGlvbmFsIGFuZCBhbHNvIG1ha2UgdGhlbSBsaXRlcmFsXG4gIC8vIG1ha2Ugc3BhY2UgYW5kIG5vbiBicmVha2FibGUgc3BhY2UgY2hhcmFjdGVycyBpbnRlcmNoYW5nZWFibGVcbiAgcmV0dXJuIHMucmVwbGFjZSgvXFwuL2csIFwiXFxcXC4/XCIpLnJlcGxhY2Uoc3BhY2VPck5CU1BSZWdFeHAsIHNwYWNlT3JOQlNQKTtcbn1cblxuZnVuY3Rpb24gc3RyaXBJbnNlbnNpdGl2aXRpZXMocykge1xuICByZXR1cm4gc1xuICAgIC5yZXBsYWNlKC9cXC4vZywgXCJcIikgLy8gaWdub3JlIGRvdHMgdGhhdCB3ZXJlIG1hZGUgb3B0aW9uYWxcbiAgICAucmVwbGFjZShzcGFjZU9yTkJTUFJlZ0V4cCwgXCIgXCIpIC8vIGludGVyY2hhbmdlIHNwYWNlIGFuZCBuYnNwXG4gICAgLnRvTG93ZXJDYXNlKCk7XG59XG5cbmZ1bmN0aW9uIG9uZU9mKHN0cmluZ3MsIHN0YXJ0SW5kZXgpIHtcbiAgaWYgKHN0cmluZ3MgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVnZXg6IFJlZ0V4cChzdHJpbmdzLm1hcChmaXhMaXN0UmVnZXgpLmpvaW4oXCJ8XCIpKSxcbiAgICAgIGRlc2VyOiAoW3NdKSA9PlxuICAgICAgICBzdHJpbmdzLmZpbmRJbmRleCgoaSkgPT4gc3RyaXBJbnNlbnNpdGl2aXRpZXMocykgPT09IHN0cmlwSW5zZW5zaXRpdml0aWVzKGkpKSArIHN0YXJ0SW5kZXgsXG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvZmZzZXQocmVnZXgsIGdyb3Vwcykge1xuICByZXR1cm4geyByZWdleCwgZGVzZXI6IChbLCBoLCBtXSkgPT4gc2lnbmVkT2Zmc2V0KGgsIG0pLCBncm91cHMgfTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlKHJlZ2V4KSB7XG4gIHJldHVybiB7IHJlZ2V4LCBkZXNlcjogKFtzXSkgPT4gcyB9O1xufVxuXG5mdW5jdGlvbiBlc2NhcGVUb2tlbih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUucmVwbGFjZSgvW1xcLVxcW1xcXXt9KCkqKz8uLFxcXFxcXF4kfCNcXHNdL2csIFwiXFxcXCQmXCIpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB0b2tlblxuICogQHBhcmFtIHtMb2NhbGV9IGxvY1xuICovXG5mdW5jdGlvbiB1bml0Rm9yVG9rZW4odG9rZW4sIGxvYykge1xuICBjb25zdCBvbmUgPSBkaWdpdFJlZ2V4KGxvYyksXG4gICAgdHdvID0gZGlnaXRSZWdleChsb2MsIFwiezJ9XCIpLFxuICAgIHRocmVlID0gZGlnaXRSZWdleChsb2MsIFwiezN9XCIpLFxuICAgIGZvdXIgPSBkaWdpdFJlZ2V4KGxvYywgXCJ7NH1cIiksXG4gICAgc2l4ID0gZGlnaXRSZWdleChsb2MsIFwiezZ9XCIpLFxuICAgIG9uZU9yVHdvID0gZGlnaXRSZWdleChsb2MsIFwiezEsMn1cIiksXG4gICAgb25lVG9UaHJlZSA9IGRpZ2l0UmVnZXgobG9jLCBcInsxLDN9XCIpLFxuICAgIG9uZVRvU2l4ID0gZGlnaXRSZWdleChsb2MsIFwiezEsNn1cIiksXG4gICAgb25lVG9OaW5lID0gZGlnaXRSZWdleChsb2MsIFwiezEsOX1cIiksXG4gICAgdHdvVG9Gb3VyID0gZGlnaXRSZWdleChsb2MsIFwiezIsNH1cIiksXG4gICAgZm91clRvU2l4ID0gZGlnaXRSZWdleChsb2MsIFwiezQsNn1cIiksXG4gICAgbGl0ZXJhbCA9ICh0KSA9PiAoeyByZWdleDogUmVnRXhwKGVzY2FwZVRva2VuKHQudmFsKSksIGRlc2VyOiAoW3NdKSA9PiBzLCBsaXRlcmFsOiB0cnVlIH0pLFxuICAgIHVuaXRhdGUgPSAodCkgPT4ge1xuICAgICAgaWYgKHRva2VuLmxpdGVyYWwpIHtcbiAgICAgICAgcmV0dXJuIGxpdGVyYWwodCk7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHQudmFsKSB7XG4gICAgICAgIC8vIGVyYVxuICAgICAgICBjYXNlIFwiR1wiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2MuZXJhcyhcInNob3J0XCIpLCAwKTtcbiAgICAgICAgY2FzZSBcIkdHXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy5lcmFzKFwibG9uZ1wiKSwgMCk7XG4gICAgICAgIC8vIHllYXJzXG4gICAgICAgIGNhc2UgXCJ5XCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lVG9TaXgpO1xuICAgICAgICBjYXNlIFwieXlcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d29Ub0ZvdXIsIHVudHJ1bmNhdGVZZWFyKTtcbiAgICAgICAgY2FzZSBcInl5eXlcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChmb3VyKTtcbiAgICAgICAgY2FzZSBcInl5eXl5XCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQoZm91clRvU2l4KTtcbiAgICAgICAgY2FzZSBcInl5eXl5eVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHNpeCk7XG4gICAgICAgIC8vIG1vbnRoc1xuICAgICAgICBjYXNlIFwiTVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcIk1NXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgICAgY2FzZSBcIk1NTVwiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2MubW9udGhzKFwic2hvcnRcIiwgdHJ1ZSksIDEpO1xuICAgICAgICBjYXNlIFwiTU1NTVwiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2MubW9udGhzKFwibG9uZ1wiLCB0cnVlKSwgMSk7XG4gICAgICAgIGNhc2UgXCJMXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwiTExcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICBjYXNlIFwiTExMXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy5tb250aHMoXCJzaG9ydFwiLCBmYWxzZSksIDEpO1xuICAgICAgICBjYXNlIFwiTExMTFwiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2MubW9udGhzKFwibG9uZ1wiLCBmYWxzZSksIDEpO1xuICAgICAgICAvLyBkYXRlc1xuICAgICAgICBjYXNlIFwiZFwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcImRkXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgICAgLy8gb3JkaW5hbHNcbiAgICAgICAgY2FzZSBcIm9cIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVUb1RocmVlKTtcbiAgICAgICAgY2FzZSBcIm9vb1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHRocmVlKTtcbiAgICAgICAgLy8gdGltZVxuICAgICAgICBjYXNlIFwiSEhcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICBjYXNlIFwiSFwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcImhoXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgICAgY2FzZSBcImhcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJtbVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwicVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcInFxXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgICAgY2FzZSBcInNcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJzc1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lVG9UaHJlZSk7XG4gICAgICAgIGNhc2UgXCJTU1NcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0aHJlZSk7XG4gICAgICAgIGNhc2UgXCJ1XCI6XG4gICAgICAgICAgcmV0dXJuIHNpbXBsZShvbmVUb05pbmUpO1xuICAgICAgICBjYXNlIFwidXVcIjpcbiAgICAgICAgICByZXR1cm4gc2ltcGxlKG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcInV1dVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZSk7XG4gICAgICAgIC8vIG1lcmlkaWVtXG4gICAgICAgIGNhc2UgXCJhXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy5tZXJpZGllbXMoKSwgMCk7XG4gICAgICAgIC8vIHdlZWtZZWFyIChrKVxuICAgICAgICBjYXNlIFwia2tra1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KGZvdXIpO1xuICAgICAgICBjYXNlIFwia2tcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d29Ub0ZvdXIsIHVudHJ1bmNhdGVZZWFyKTtcbiAgICAgICAgLy8gd2Vla051bWJlciAoVylcbiAgICAgICAgY2FzZSBcIldcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJXV1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIC8vIHdlZWtkYXlzXG4gICAgICAgIGNhc2UgXCJFXCI6XG4gICAgICAgIGNhc2UgXCJjXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lKTtcbiAgICAgICAgY2FzZSBcIkVFRVwiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2Mud2Vla2RheXMoXCJzaG9ydFwiLCBmYWxzZSksIDEpO1xuICAgICAgICBjYXNlIFwiRUVFRVwiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2Mud2Vla2RheXMoXCJsb25nXCIsIGZhbHNlKSwgMSk7XG4gICAgICAgIGNhc2UgXCJjY2NcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLndlZWtkYXlzKFwic2hvcnRcIiwgdHJ1ZSksIDEpO1xuICAgICAgICBjYXNlIFwiY2NjY1wiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2Mud2Vla2RheXMoXCJsb25nXCIsIHRydWUpLCAxKTtcbiAgICAgICAgLy8gb2Zmc2V0L3pvbmVcbiAgICAgICAgY2FzZSBcIlpcIjpcbiAgICAgICAgY2FzZSBcIlpaXCI6XG4gICAgICAgICAgcmV0dXJuIG9mZnNldChuZXcgUmVnRXhwKGAoWystXSR7b25lT3JUd28uc291cmNlfSkoPzo6KCR7dHdvLnNvdXJjZX0pKT9gKSwgMik7XG4gICAgICAgIGNhc2UgXCJaWlpcIjpcbiAgICAgICAgICByZXR1cm4gb2Zmc2V0KG5ldyBSZWdFeHAoYChbKy1dJHtvbmVPclR3by5zb3VyY2V9KSgke3R3by5zb3VyY2V9KT9gKSwgMik7XG4gICAgICAgIC8vIHdlIGRvbid0IHN1cHBvcnQgWlpaWiAoUFNUKSBvciBaWlpaWiAoUGFjaWZpYyBTdGFuZGFyZCBUaW1lKSBpbiBwYXJzaW5nXG4gICAgICAgIC8vIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBhbnkgd2F5IHRvIGZpZ3VyZSBvdXQgd2hhdCB0aGV5IGFyZVxuICAgICAgICBjYXNlIFwielwiOlxuICAgICAgICAgIHJldHVybiBzaW1wbGUoL1thLXpfKy0vXXsxLDI1Nn0/L2kpO1xuICAgICAgICAvLyB0aGlzIHNwZWNpYWwtY2FzZSBcInRva2VuXCIgcmVwcmVzZW50cyBhIHBsYWNlIHdoZXJlIGEgbWFjcm8tdG9rZW4gZXhwYW5kZWQgaW50byBhIHdoaXRlLXNwYWNlIGxpdGVyYWxcbiAgICAgICAgLy8gaW4gdGhpcyBjYXNlIHdlIGFjY2VwdCBhbnkgbm9uLW5ld2xpbmUgd2hpdGUtc3BhY2VcbiAgICAgICAgY2FzZSBcIiBcIjpcbiAgICAgICAgICByZXR1cm4gc2ltcGxlKC9bXlxcU1xcblxccl0vKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbGl0ZXJhbCh0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIGNvbnN0IHVuaXQgPSB1bml0YXRlKHRva2VuKSB8fCB7XG4gICAgaW52YWxpZFJlYXNvbjogTUlTU0lOR19GVFAsXG4gIH07XG5cbiAgdW5pdC50b2tlbiA9IHRva2VuO1xuXG4gIHJldHVybiB1bml0O1xufVxuXG5jb25zdCBwYXJ0VHlwZVN0eWxlVG9Ub2tlblZhbCA9IHtcbiAgeWVhcjoge1xuICAgIFwiMi1kaWdpdFwiOiBcInl5XCIsXG4gICAgbnVtZXJpYzogXCJ5eXl5eVwiLFxuICB9LFxuICBtb250aDoge1xuICAgIG51bWVyaWM6IFwiTVwiLFxuICAgIFwiMi1kaWdpdFwiOiBcIk1NXCIsXG4gICAgc2hvcnQ6IFwiTU1NXCIsXG4gICAgbG9uZzogXCJNTU1NXCIsXG4gIH0sXG4gIGRheToge1xuICAgIG51bWVyaWM6IFwiZFwiLFxuICAgIFwiMi1kaWdpdFwiOiBcImRkXCIsXG4gIH0sXG4gIHdlZWtkYXk6IHtcbiAgICBzaG9ydDogXCJFRUVcIixcbiAgICBsb25nOiBcIkVFRUVcIixcbiAgfSxcbiAgZGF5cGVyaW9kOiBcImFcIixcbiAgZGF5UGVyaW9kOiBcImFcIixcbiAgaG91cjEyOiB7XG4gICAgbnVtZXJpYzogXCJoXCIsXG4gICAgXCIyLWRpZ2l0XCI6IFwiaGhcIixcbiAgfSxcbiAgaG91cjI0OiB7XG4gICAgbnVtZXJpYzogXCJIXCIsXG4gICAgXCIyLWRpZ2l0XCI6IFwiSEhcIixcbiAgfSxcbiAgbWludXRlOiB7XG4gICAgbnVtZXJpYzogXCJtXCIsXG4gICAgXCIyLWRpZ2l0XCI6IFwibW1cIixcbiAgfSxcbiAgc2Vjb25kOiB7XG4gICAgbnVtZXJpYzogXCJzXCIsXG4gICAgXCIyLWRpZ2l0XCI6IFwic3NcIixcbiAgfSxcbiAgdGltZVpvbmVOYW1lOiB7XG4gICAgbG9uZzogXCJaWlpaWlwiLFxuICAgIHNob3J0OiBcIlpaWlwiLFxuICB9LFxufTtcblxuZnVuY3Rpb24gdG9rZW5Gb3JQYXJ0KHBhcnQsIGZvcm1hdE9wdHMsIHJlc29sdmVkT3B0cykge1xuICBjb25zdCB7IHR5cGUsIHZhbHVlIH0gPSBwYXJ0O1xuXG4gIGlmICh0eXBlID09PSBcImxpdGVyYWxcIikge1xuICAgIGNvbnN0IGlzU3BhY2UgPSAvXlxccyskLy50ZXN0KHZhbHVlKTtcbiAgICByZXR1cm4ge1xuICAgICAgbGl0ZXJhbDogIWlzU3BhY2UsXG4gICAgICB2YWw6IGlzU3BhY2UgPyBcIiBcIiA6IHZhbHVlLFxuICAgIH07XG4gIH1cblxuICBjb25zdCBzdHlsZSA9IGZvcm1hdE9wdHNbdHlwZV07XG5cbiAgLy8gVGhlIHVzZXIgbWlnaHQgaGF2ZSBleHBsaWNpdGx5IHNwZWNpZmllZCBob3VyMTIgb3IgaG91ckN5Y2xlXG4gIC8vIGlmIHNvLCByZXNwZWN0IHRoZWlyIGRlY2lzaW9uXG4gIC8vIGlmIG5vdCwgcmVmZXIgYmFjayB0byB0aGUgcmVzb2x2ZWRPcHRzLCB3aGljaCBhcmUgYmFzZWQgb24gdGhlIGxvY2FsZVxuICBsZXQgYWN0dWFsVHlwZSA9IHR5cGU7XG4gIGlmICh0eXBlID09PSBcImhvdXJcIikge1xuICAgIGlmIChmb3JtYXRPcHRzLmhvdXIxMiAhPSBudWxsKSB7XG4gICAgICBhY3R1YWxUeXBlID0gZm9ybWF0T3B0cy5ob3VyMTIgPyBcImhvdXIxMlwiIDogXCJob3VyMjRcIjtcbiAgICB9IGVsc2UgaWYgKGZvcm1hdE9wdHMuaG91ckN5Y2xlICE9IG51bGwpIHtcbiAgICAgIGlmIChmb3JtYXRPcHRzLmhvdXJDeWNsZSA9PT0gXCJoMTFcIiB8fCBmb3JtYXRPcHRzLmhvdXJDeWNsZSA9PT0gXCJoMTJcIikge1xuICAgICAgICBhY3R1YWxUeXBlID0gXCJob3VyMTJcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdHVhbFR5cGUgPSBcImhvdXIyNFwiO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0b2tlbnMgb25seSBkaWZmZXJlbnRpYXRlIGJldHdlZW4gMjQgaG91cnMgb3Igbm90LFxuICAgICAgLy8gc28gd2UgZG8gbm90IG5lZWQgdG8gY2hlY2sgaG91ckN5Y2xlIGhlcmUsIHdoaWNoIGlzIGxlc3Mgc3VwcG9ydGVkIGFueXdheXNcbiAgICAgIGFjdHVhbFR5cGUgPSByZXNvbHZlZE9wdHMuaG91cjEyID8gXCJob3VyMTJcIiA6IFwiaG91cjI0XCI7XG4gICAgfVxuICB9XG4gIGxldCB2YWwgPSBwYXJ0VHlwZVN0eWxlVG9Ub2tlblZhbFthY3R1YWxUeXBlXTtcbiAgaWYgKHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIpIHtcbiAgICB2YWwgPSB2YWxbc3R5bGVdO1xuICB9XG5cbiAgaWYgKHZhbCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaXRlcmFsOiBmYWxzZSxcbiAgICAgIHZhbCxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gYnVpbGRSZWdleCh1bml0cykge1xuICBjb25zdCByZSA9IHVuaXRzLm1hcCgodSkgPT4gdS5yZWdleCkucmVkdWNlKChmLCByKSA9PiBgJHtmfSgke3Iuc291cmNlfSlgLCBcIlwiKTtcbiAgcmV0dXJuIFtgXiR7cmV9JGAsIHVuaXRzXTtcbn1cblxuZnVuY3Rpb24gbWF0Y2goaW5wdXQsIHJlZ2V4LCBoYW5kbGVycykge1xuICBjb25zdCBtYXRjaGVzID0gaW5wdXQubWF0Y2gocmVnZXgpO1xuXG4gIGlmIChtYXRjaGVzKSB7XG4gICAgY29uc3QgYWxsID0ge307XG4gICAgbGV0IG1hdGNoSW5kZXggPSAxO1xuICAgIGZvciAoY29uc3QgaSBpbiBoYW5kbGVycykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5KGhhbmRsZXJzLCBpKSkge1xuICAgICAgICBjb25zdCBoID0gaGFuZGxlcnNbaV0sXG4gICAgICAgICAgZ3JvdXBzID0gaC5ncm91cHMgPyBoLmdyb3VwcyArIDEgOiAxO1xuICAgICAgICBpZiAoIWgubGl0ZXJhbCAmJiBoLnRva2VuKSB7XG4gICAgICAgICAgYWxsW2gudG9rZW4udmFsWzBdXSA9IGguZGVzZXIobWF0Y2hlcy5zbGljZShtYXRjaEluZGV4LCBtYXRjaEluZGV4ICsgZ3JvdXBzKSk7XG4gICAgICAgIH1cbiAgICAgICAgbWF0Y2hJbmRleCArPSBncm91cHM7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbbWF0Y2hlcywgYWxsXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW21hdGNoZXMsIHt9XTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkYXRlVGltZUZyb21NYXRjaGVzKG1hdGNoZXMpIHtcbiAgY29uc3QgdG9GaWVsZCA9ICh0b2tlbikgPT4ge1xuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgIHJldHVybiBcIm1pbGxpc2Vjb25kXCI7XG4gICAgICBjYXNlIFwic1wiOlxuICAgICAgICByZXR1cm4gXCJzZWNvbmRcIjtcbiAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgIHJldHVybiBcIm1pbnV0ZVwiO1xuICAgICAgY2FzZSBcImhcIjpcbiAgICAgIGNhc2UgXCJIXCI6XG4gICAgICAgIHJldHVybiBcImhvdXJcIjtcbiAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgIHJldHVybiBcImRheVwiO1xuICAgICAgY2FzZSBcIm9cIjpcbiAgICAgICAgcmV0dXJuIFwib3JkaW5hbFwiO1xuICAgICAgY2FzZSBcIkxcIjpcbiAgICAgIGNhc2UgXCJNXCI6XG4gICAgICAgIHJldHVybiBcIm1vbnRoXCI7XG4gICAgICBjYXNlIFwieVwiOlxuICAgICAgICByZXR1cm4gXCJ5ZWFyXCI7XG4gICAgICBjYXNlIFwiRVwiOlxuICAgICAgY2FzZSBcImNcIjpcbiAgICAgICAgcmV0dXJuIFwid2Vla2RheVwiO1xuICAgICAgY2FzZSBcIldcIjpcbiAgICAgICAgcmV0dXJuIFwid2Vla051bWJlclwiO1xuICAgICAgY2FzZSBcImtcIjpcbiAgICAgICAgcmV0dXJuIFwid2Vla1llYXJcIjtcbiAgICAgIGNhc2UgXCJxXCI6XG4gICAgICAgIHJldHVybiBcInF1YXJ0ZXJcIjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcblxuICBsZXQgem9uZSA9IG51bGw7XG4gIGxldCBzcGVjaWZpY09mZnNldDtcbiAgaWYgKCFpc1VuZGVmaW5lZChtYXRjaGVzLnopKSB7XG4gICAgem9uZSA9IElBTkFab25lLmNyZWF0ZShtYXRjaGVzLnopO1xuICB9XG5cbiAgaWYgKCFpc1VuZGVmaW5lZChtYXRjaGVzLlopKSB7XG4gICAgaWYgKCF6b25lKSB7XG4gICAgICB6b25lID0gbmV3IEZpeGVkT2Zmc2V0Wm9uZShtYXRjaGVzLlopO1xuICAgIH1cbiAgICBzcGVjaWZpY09mZnNldCA9IG1hdGNoZXMuWjtcbiAgfVxuXG4gIGlmICghaXNVbmRlZmluZWQobWF0Y2hlcy5xKSkge1xuICAgIG1hdGNoZXMuTSA9IChtYXRjaGVzLnEgLSAxKSAqIDMgKyAxO1xuICB9XG5cbiAgaWYgKCFpc1VuZGVmaW5lZChtYXRjaGVzLmgpKSB7XG4gICAgaWYgKG1hdGNoZXMuaCA8IDEyICYmIG1hdGNoZXMuYSA9PT0gMSkge1xuICAgICAgbWF0Y2hlcy5oICs9IDEyO1xuICAgIH0gZWxzZSBpZiAobWF0Y2hlcy5oID09PSAxMiAmJiBtYXRjaGVzLmEgPT09IDApIHtcbiAgICAgIG1hdGNoZXMuaCA9IDA7XG4gICAgfVxuICB9XG5cbiAgaWYgKG1hdGNoZXMuRyA9PT0gMCAmJiBtYXRjaGVzLnkpIHtcbiAgICBtYXRjaGVzLnkgPSAtbWF0Y2hlcy55O1xuICB9XG5cbiAgaWYgKCFpc1VuZGVmaW5lZChtYXRjaGVzLnUpKSB7XG4gICAgbWF0Y2hlcy5TID0gcGFyc2VNaWxsaXMobWF0Y2hlcy51KTtcbiAgfVxuXG4gIGNvbnN0IHZhbHMgPSBPYmplY3Qua2V5cyhtYXRjaGVzKS5yZWR1Y2UoKHIsIGspID0+IHtcbiAgICBjb25zdCBmID0gdG9GaWVsZChrKTtcbiAgICBpZiAoZikge1xuICAgICAgcltmXSA9IG1hdGNoZXNba107XG4gICAgfVxuXG4gICAgcmV0dXJuIHI7XG4gIH0sIHt9KTtcblxuICByZXR1cm4gW3ZhbHMsIHpvbmUsIHNwZWNpZmljT2Zmc2V0XTtcbn1cblxubGV0IGR1bW15RGF0ZVRpbWVDYWNoZSA9IG51bGw7XG5cbmZ1bmN0aW9uIGdldER1bW15RGF0ZVRpbWUoKSB7XG4gIGlmICghZHVtbXlEYXRlVGltZUNhY2hlKSB7XG4gICAgZHVtbXlEYXRlVGltZUNhY2hlID0gRGF0ZVRpbWUuZnJvbU1pbGxpcygxNTU1NTU1NTU1NTU1KTtcbiAgfVxuXG4gIHJldHVybiBkdW1teURhdGVUaW1lQ2FjaGU7XG59XG5cbmZ1bmN0aW9uIG1heWJlRXhwYW5kTWFjcm9Ub2tlbih0b2tlbiwgbG9jYWxlKSB7XG4gIGlmICh0b2tlbi5saXRlcmFsKSB7XG4gICAgcmV0dXJuIHRva2VuO1xuICB9XG5cbiAgY29uc3QgZm9ybWF0T3B0cyA9IEZvcm1hdHRlci5tYWNyb1Rva2VuVG9Gb3JtYXRPcHRzKHRva2VuLnZhbCk7XG4gIGNvbnN0IHRva2VucyA9IGZvcm1hdE9wdHNUb1Rva2Vucyhmb3JtYXRPcHRzLCBsb2NhbGUpO1xuXG4gIGlmICh0b2tlbnMgPT0gbnVsbCB8fCB0b2tlbnMuaW5jbHVkZXModW5kZWZpbmVkKSkge1xuICAgIHJldHVybiB0b2tlbjtcbiAgfVxuXG4gIHJldHVybiB0b2tlbnM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRNYWNyb1Rva2Vucyh0b2tlbnMsIGxvY2FsZSkge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdCguLi50b2tlbnMubWFwKCh0KSA9PiBtYXliZUV4cGFuZE1hY3JvVG9rZW4odCwgbG9jYWxlKSkpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGV4cGxhaW5Gcm9tVG9rZW5zKGxvY2FsZSwgaW5wdXQsIGZvcm1hdCkge1xuICBjb25zdCB0b2tlbnMgPSBleHBhbmRNYWNyb1Rva2VucyhGb3JtYXR0ZXIucGFyc2VGb3JtYXQoZm9ybWF0KSwgbG9jYWxlKSxcbiAgICB1bml0cyA9IHRva2Vucy5tYXAoKHQpID0+IHVuaXRGb3JUb2tlbih0LCBsb2NhbGUpKSxcbiAgICBkaXNxdWFsaWZ5aW5nVW5pdCA9IHVuaXRzLmZpbmQoKHQpID0+IHQuaW52YWxpZFJlYXNvbik7XG5cbiAgaWYgKGRpc3F1YWxpZnlpbmdVbml0KSB7XG4gICAgcmV0dXJuIHsgaW5wdXQsIHRva2VucywgaW52YWxpZFJlYXNvbjogZGlzcXVhbGlmeWluZ1VuaXQuaW52YWxpZFJlYXNvbiB9O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IFtyZWdleFN0cmluZywgaGFuZGxlcnNdID0gYnVpbGRSZWdleCh1bml0cyksXG4gICAgICByZWdleCA9IFJlZ0V4cChyZWdleFN0cmluZywgXCJpXCIpLFxuICAgICAgW3Jhd01hdGNoZXMsIG1hdGNoZXNdID0gbWF0Y2goaW5wdXQsIHJlZ2V4LCBoYW5kbGVycyksXG4gICAgICBbcmVzdWx0LCB6b25lLCBzcGVjaWZpY09mZnNldF0gPSBtYXRjaGVzXG4gICAgICAgID8gZGF0ZVRpbWVGcm9tTWF0Y2hlcyhtYXRjaGVzKVxuICAgICAgICA6IFtudWxsLCBudWxsLCB1bmRlZmluZWRdO1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eShtYXRjaGVzLCBcImFcIikgJiYgaGFzT3duUHJvcGVydHkobWF0Y2hlcywgXCJIXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IoXG4gICAgICAgIFwiQ2FuJ3QgaW5jbHVkZSBtZXJpZGllbSB3aGVuIHNwZWNpZnlpbmcgMjQtaG91ciBmb3JtYXRcIlxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgaW5wdXQsIHRva2VucywgcmVnZXgsIHJhd01hdGNoZXMsIG1hdGNoZXMsIHJlc3VsdCwgem9uZSwgc3BlY2lmaWNPZmZzZXQgfTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VGcm9tVG9rZW5zKGxvY2FsZSwgaW5wdXQsIGZvcm1hdCkge1xuICBjb25zdCB7IHJlc3VsdCwgem9uZSwgc3BlY2lmaWNPZmZzZXQsIGludmFsaWRSZWFzb24gfSA9IGV4cGxhaW5Gcm9tVG9rZW5zKGxvY2FsZSwgaW5wdXQsIGZvcm1hdCk7XG4gIHJldHVybiBbcmVzdWx0LCB6b25lLCBzcGVjaWZpY09mZnNldCwgaW52YWxpZFJlYXNvbl07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRPcHRzVG9Ub2tlbnMoZm9ybWF0T3B0cywgbG9jYWxlKSB7XG4gIGlmICghZm9ybWF0T3B0cykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgZm9ybWF0dGVyID0gRm9ybWF0dGVyLmNyZWF0ZShsb2NhbGUsIGZvcm1hdE9wdHMpO1xuICBjb25zdCBkZiA9IGZvcm1hdHRlci5kdEZvcm1hdHRlcihnZXREdW1teURhdGVUaW1lKCkpO1xuICBjb25zdCBwYXJ0cyA9IGRmLmZvcm1hdFRvUGFydHMoKTtcbiAgY29uc3QgcmVzb2x2ZWRPcHRzID0gZGYucmVzb2x2ZWRPcHRpb25zKCk7XG4gIHJldHVybiBwYXJ0cy5tYXAoKHApID0+IHRva2VuRm9yUGFydChwLCBmb3JtYXRPcHRzLCByZXNvbHZlZE9wdHMpKTtcbn1cbiIsICJpbXBvcnQge1xuICBpbnRlZ2VyQmV0d2VlbixcbiAgaXNMZWFwWWVhcixcbiAgdGltZU9iamVjdCxcbiAgZGF5c0luWWVhcixcbiAgZGF5c0luTW9udGgsXG4gIHdlZWtzSW5XZWVrWWVhcixcbiAgaXNJbnRlZ2VyLFxufSBmcm9tIFwiLi91dGlsLmpzXCI7XG5pbXBvcnQgSW52YWxpZCBmcm9tIFwiLi9pbnZhbGlkLmpzXCI7XG5cbmNvbnN0IG5vbkxlYXBMYWRkZXIgPSBbMCwgMzEsIDU5LCA5MCwgMTIwLCAxNTEsIDE4MSwgMjEyLCAyNDMsIDI3MywgMzA0LCAzMzRdLFxuICBsZWFwTGFkZGVyID0gWzAsIDMxLCA2MCwgOTEsIDEyMSwgMTUyLCAxODIsIDIxMywgMjQ0LCAyNzQsIDMwNSwgMzM1XTtcblxuZnVuY3Rpb24gdW5pdE91dE9mUmFuZ2UodW5pdCwgdmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBJbnZhbGlkKFxuICAgIFwidW5pdCBvdXQgb2YgcmFuZ2VcIixcbiAgICBgeW91IHNwZWNpZmllZCAke3ZhbHVlfSAob2YgdHlwZSAke3R5cGVvZiB2YWx1ZX0pIGFzIGEgJHt1bml0fSwgd2hpY2ggaXMgaW52YWxpZGBcbiAgKTtcbn1cblxuZnVuY3Rpb24gZGF5T2ZXZWVrKHllYXIsIG1vbnRoLCBkYXkpIHtcbiAgY29uc3QgZCA9IG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoIC0gMSwgZGF5KSk7XG5cbiAgaWYgKHllYXIgPCAxMDAgJiYgeWVhciA+PSAwKSB7XG4gICAgZC5zZXRVVENGdWxsWWVhcihkLmdldFVUQ0Z1bGxZZWFyKCkgLSAxOTAwKTtcbiAgfVxuXG4gIGNvbnN0IGpzID0gZC5nZXRVVENEYXkoKTtcblxuICByZXR1cm4ganMgPT09IDAgPyA3IDoganM7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVPcmRpbmFsKHllYXIsIG1vbnRoLCBkYXkpIHtcbiAgcmV0dXJuIGRheSArIChpc0xlYXBZZWFyKHllYXIpID8gbGVhcExhZGRlciA6IG5vbkxlYXBMYWRkZXIpW21vbnRoIC0gMV07XG59XG5cbmZ1bmN0aW9uIHVuY29tcHV0ZU9yZGluYWwoeWVhciwgb3JkaW5hbCkge1xuICBjb25zdCB0YWJsZSA9IGlzTGVhcFllYXIoeWVhcikgPyBsZWFwTGFkZGVyIDogbm9uTGVhcExhZGRlcixcbiAgICBtb250aDAgPSB0YWJsZS5maW5kSW5kZXgoKGkpID0+IGkgPCBvcmRpbmFsKSxcbiAgICBkYXkgPSBvcmRpbmFsIC0gdGFibGVbbW9udGgwXTtcbiAgcmV0dXJuIHsgbW9udGg6IG1vbnRoMCArIDEsIGRheSB9O1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGdyZWdvcmlhblRvV2VlayhncmVnT2JqKSB7XG4gIGNvbnN0IHsgeWVhciwgbW9udGgsIGRheSB9ID0gZ3JlZ09iaixcbiAgICBvcmRpbmFsID0gY29tcHV0ZU9yZGluYWwoeWVhciwgbW9udGgsIGRheSksXG4gICAgd2Vla2RheSA9IGRheU9mV2Vlayh5ZWFyLCBtb250aCwgZGF5KTtcblxuICBsZXQgd2Vla051bWJlciA9IE1hdGguZmxvb3IoKG9yZGluYWwgLSB3ZWVrZGF5ICsgMTApIC8gNyksXG4gICAgd2Vla1llYXI7XG5cbiAgaWYgKHdlZWtOdW1iZXIgPCAxKSB7XG4gICAgd2Vla1llYXIgPSB5ZWFyIC0gMTtcbiAgICB3ZWVrTnVtYmVyID0gd2Vla3NJbldlZWtZZWFyKHdlZWtZZWFyKTtcbiAgfSBlbHNlIGlmICh3ZWVrTnVtYmVyID4gd2Vla3NJbldlZWtZZWFyKHllYXIpKSB7XG4gICAgd2Vla1llYXIgPSB5ZWFyICsgMTtcbiAgICB3ZWVrTnVtYmVyID0gMTtcbiAgfSBlbHNlIHtcbiAgICB3ZWVrWWVhciA9IHllYXI7XG4gIH1cblxuICByZXR1cm4geyB3ZWVrWWVhciwgd2Vla051bWJlciwgd2Vla2RheSwgLi4udGltZU9iamVjdChncmVnT2JqKSB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2Vla1RvR3JlZ29yaWFuKHdlZWtEYXRhKSB7XG4gIGNvbnN0IHsgd2Vla1llYXIsIHdlZWtOdW1iZXIsIHdlZWtkYXkgfSA9IHdlZWtEYXRhLFxuICAgIHdlZWtkYXlPZkphbjQgPSBkYXlPZldlZWsod2Vla1llYXIsIDEsIDQpLFxuICAgIHllYXJJbkRheXMgPSBkYXlzSW5ZZWFyKHdlZWtZZWFyKTtcblxuICBsZXQgb3JkaW5hbCA9IHdlZWtOdW1iZXIgKiA3ICsgd2Vla2RheSAtIHdlZWtkYXlPZkphbjQgLSAzLFxuICAgIHllYXI7XG5cbiAgaWYgKG9yZGluYWwgPCAxKSB7XG4gICAgeWVhciA9IHdlZWtZZWFyIC0gMTtcbiAgICBvcmRpbmFsICs9IGRheXNJblllYXIoeWVhcik7XG4gIH0gZWxzZSBpZiAob3JkaW5hbCA+IHllYXJJbkRheXMpIHtcbiAgICB5ZWFyID0gd2Vla1llYXIgKyAxO1xuICAgIG9yZGluYWwgLT0gZGF5c0luWWVhcih3ZWVrWWVhcik7XG4gIH0gZWxzZSB7XG4gICAgeWVhciA9IHdlZWtZZWFyO1xuICB9XG5cbiAgY29uc3QgeyBtb250aCwgZGF5IH0gPSB1bmNvbXB1dGVPcmRpbmFsKHllYXIsIG9yZGluYWwpO1xuICByZXR1cm4geyB5ZWFyLCBtb250aCwgZGF5LCAuLi50aW1lT2JqZWN0KHdlZWtEYXRhKSB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ3JlZ29yaWFuVG9PcmRpbmFsKGdyZWdEYXRhKSB7XG4gIGNvbnN0IHsgeWVhciwgbW9udGgsIGRheSB9ID0gZ3JlZ0RhdGE7XG4gIGNvbnN0IG9yZGluYWwgPSBjb21wdXRlT3JkaW5hbCh5ZWFyLCBtb250aCwgZGF5KTtcbiAgcmV0dXJuIHsgeWVhciwgb3JkaW5hbCwgLi4udGltZU9iamVjdChncmVnRGF0YSkgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9yZGluYWxUb0dyZWdvcmlhbihvcmRpbmFsRGF0YSkge1xuICBjb25zdCB7IHllYXIsIG9yZGluYWwgfSA9IG9yZGluYWxEYXRhO1xuICBjb25zdCB7IG1vbnRoLCBkYXkgfSA9IHVuY29tcHV0ZU9yZGluYWwoeWVhciwgb3JkaW5hbCk7XG4gIHJldHVybiB7IHllYXIsIG1vbnRoLCBkYXksIC4uLnRpbWVPYmplY3Qob3JkaW5hbERhdGEpIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNJbnZhbGlkV2Vla0RhdGEob2JqKSB7XG4gIGNvbnN0IHZhbGlkWWVhciA9IGlzSW50ZWdlcihvYmoud2Vla1llYXIpLFxuICAgIHZhbGlkV2VlayA9IGludGVnZXJCZXR3ZWVuKG9iai53ZWVrTnVtYmVyLCAxLCB3ZWVrc0luV2Vla1llYXIob2JqLndlZWtZZWFyKSksXG4gICAgdmFsaWRXZWVrZGF5ID0gaW50ZWdlckJldHdlZW4ob2JqLndlZWtkYXksIDEsIDcpO1xuXG4gIGlmICghdmFsaWRZZWFyKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwid2Vla1llYXJcIiwgb2JqLndlZWtZZWFyKTtcbiAgfSBlbHNlIGlmICghdmFsaWRXZWVrKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwid2Vla1wiLCBvYmoud2Vlayk7XG4gIH0gZWxzZSBpZiAoIXZhbGlkV2Vla2RheSkge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcIndlZWtkYXlcIiwgb2JqLndlZWtkYXkpO1xuICB9IGVsc2UgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzSW52YWxpZE9yZGluYWxEYXRhKG9iaikge1xuICBjb25zdCB2YWxpZFllYXIgPSBpc0ludGVnZXIob2JqLnllYXIpLFxuICAgIHZhbGlkT3JkaW5hbCA9IGludGVnZXJCZXR3ZWVuKG9iai5vcmRpbmFsLCAxLCBkYXlzSW5ZZWFyKG9iai55ZWFyKSk7XG5cbiAgaWYgKCF2YWxpZFllYXIpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJ5ZWFyXCIsIG9iai55ZWFyKTtcbiAgfSBlbHNlIGlmICghdmFsaWRPcmRpbmFsKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwib3JkaW5hbFwiLCBvYmoub3JkaW5hbCk7XG4gIH0gZWxzZSByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNJbnZhbGlkR3JlZ29yaWFuRGF0YShvYmopIHtcbiAgY29uc3QgdmFsaWRZZWFyID0gaXNJbnRlZ2VyKG9iai55ZWFyKSxcbiAgICB2YWxpZE1vbnRoID0gaW50ZWdlckJldHdlZW4ob2JqLm1vbnRoLCAxLCAxMiksXG4gICAgdmFsaWREYXkgPSBpbnRlZ2VyQmV0d2VlbihvYmouZGF5LCAxLCBkYXlzSW5Nb250aChvYmoueWVhciwgb2JqLm1vbnRoKSk7XG5cbiAgaWYgKCF2YWxpZFllYXIpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJ5ZWFyXCIsIG9iai55ZWFyKTtcbiAgfSBlbHNlIGlmICghdmFsaWRNb250aCkge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcIm1vbnRoXCIsIG9iai5tb250aCk7XG4gIH0gZWxzZSBpZiAoIXZhbGlkRGF5KSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwiZGF5XCIsIG9iai5kYXkpO1xuICB9IGVsc2UgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzSW52YWxpZFRpbWVEYXRhKG9iaikge1xuICBjb25zdCB7IGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCB9ID0gb2JqO1xuICBjb25zdCB2YWxpZEhvdXIgPVxuICAgICAgaW50ZWdlckJldHdlZW4oaG91ciwgMCwgMjMpIHx8XG4gICAgICAoaG91ciA9PT0gMjQgJiYgbWludXRlID09PSAwICYmIHNlY29uZCA9PT0gMCAmJiBtaWxsaXNlY29uZCA9PT0gMCksXG4gICAgdmFsaWRNaW51dGUgPSBpbnRlZ2VyQmV0d2VlbihtaW51dGUsIDAsIDU5KSxcbiAgICB2YWxpZFNlY29uZCA9IGludGVnZXJCZXR3ZWVuKHNlY29uZCwgMCwgNTkpLFxuICAgIHZhbGlkTWlsbGlzZWNvbmQgPSBpbnRlZ2VyQmV0d2VlbihtaWxsaXNlY29uZCwgMCwgOTk5KTtcblxuICBpZiAoIXZhbGlkSG91cikge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcImhvdXJcIiwgaG91cik7XG4gIH0gZWxzZSBpZiAoIXZhbGlkTWludXRlKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwibWludXRlXCIsIG1pbnV0ZSk7XG4gIH0gZWxzZSBpZiAoIXZhbGlkU2Vjb25kKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwic2Vjb25kXCIsIHNlY29uZCk7XG4gIH0gZWxzZSBpZiAoIXZhbGlkTWlsbGlzZWNvbmQpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJtaWxsaXNlY29uZFwiLCBtaWxsaXNlY29uZCk7XG4gIH0gZWxzZSByZXR1cm4gZmFsc2U7XG59XG4iLCAiaW1wb3J0IER1cmF0aW9uIGZyb20gXCIuL2R1cmF0aW9uLmpzXCI7XG5pbXBvcnQgSW50ZXJ2YWwgZnJvbSBcIi4vaW50ZXJ2YWwuanNcIjtcbmltcG9ydCBTZXR0aW5ncyBmcm9tIFwiLi9zZXR0aW5ncy5qc1wiO1xuaW1wb3J0IEluZm8gZnJvbSBcIi4vaW5mby5qc1wiO1xuaW1wb3J0IEZvcm1hdHRlciBmcm9tIFwiLi9pbXBsL2Zvcm1hdHRlci5qc1wiO1xuaW1wb3J0IEZpeGVkT2Zmc2V0Wm9uZSBmcm9tIFwiLi96b25lcy9maXhlZE9mZnNldFpvbmUuanNcIjtcbmltcG9ydCBMb2NhbGUgZnJvbSBcIi4vaW1wbC9sb2NhbGUuanNcIjtcbmltcG9ydCB7XG4gIGlzVW5kZWZpbmVkLFxuICBtYXliZUFycmF5LFxuICBpc0RhdGUsXG4gIGlzTnVtYmVyLFxuICBiZXN0QnksXG4gIGRheXNJbk1vbnRoLFxuICBkYXlzSW5ZZWFyLFxuICBpc0xlYXBZZWFyLFxuICB3ZWVrc0luV2Vla1llYXIsXG4gIG5vcm1hbGl6ZU9iamVjdCxcbiAgcm91bmRUbyxcbiAgb2JqVG9Mb2NhbFRTLFxuICBwYWRTdGFydCxcbn0gZnJvbSBcIi4vaW1wbC91dGlsLmpzXCI7XG5pbXBvcnQgeyBub3JtYWxpemVab25lIH0gZnJvbSBcIi4vaW1wbC96b25lVXRpbC5qc1wiO1xuaW1wb3J0IGRpZmYgZnJvbSBcIi4vaW1wbC9kaWZmLmpzXCI7XG5pbXBvcnQgeyBwYXJzZVJGQzI4MjJEYXRlLCBwYXJzZUlTT0RhdGUsIHBhcnNlSFRUUERhdGUsIHBhcnNlU1FMIH0gZnJvbSBcIi4vaW1wbC9yZWdleFBhcnNlci5qc1wiO1xuaW1wb3J0IHtcbiAgcGFyc2VGcm9tVG9rZW5zLFxuICBleHBsYWluRnJvbVRva2VucyxcbiAgZm9ybWF0T3B0c1RvVG9rZW5zLFxuICBleHBhbmRNYWNyb1Rva2Vucyxcbn0gZnJvbSBcIi4vaW1wbC90b2tlblBhcnNlci5qc1wiO1xuaW1wb3J0IHtcbiAgZ3JlZ29yaWFuVG9XZWVrLFxuICB3ZWVrVG9HcmVnb3JpYW4sXG4gIGdyZWdvcmlhblRvT3JkaW5hbCxcbiAgb3JkaW5hbFRvR3JlZ29yaWFuLFxuICBoYXNJbnZhbGlkR3JlZ29yaWFuRGF0YSxcbiAgaGFzSW52YWxpZFdlZWtEYXRhLFxuICBoYXNJbnZhbGlkT3JkaW5hbERhdGEsXG4gIGhhc0ludmFsaWRUaW1lRGF0YSxcbn0gZnJvbSBcIi4vaW1wbC9jb252ZXJzaW9ucy5qc1wiO1xuaW1wb3J0ICogYXMgRm9ybWF0cyBmcm9tIFwiLi9pbXBsL2Zvcm1hdHMuanNcIjtcbmltcG9ydCB7XG4gIEludmFsaWRBcmd1bWVudEVycm9yLFxuICBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvcixcbiAgSW52YWxpZFVuaXRFcnJvcixcbiAgSW52YWxpZERhdGVUaW1lRXJyb3IsXG59IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IEludmFsaWQgZnJvbSBcIi4vaW1wbC9pbnZhbGlkLmpzXCI7XG5cbmNvbnN0IElOVkFMSUQgPSBcIkludmFsaWQgRGF0ZVRpbWVcIjtcbmNvbnN0IE1BWF9EQVRFID0gOC42NGUxNTtcblxuZnVuY3Rpb24gdW5zdXBwb3J0ZWRab25lKHpvbmUpIHtcbiAgcmV0dXJuIG5ldyBJbnZhbGlkKFwidW5zdXBwb3J0ZWQgem9uZVwiLCBgdGhlIHpvbmUgXCIke3pvbmUubmFtZX1cIiBpcyBub3Qgc3VwcG9ydGVkYCk7XG59XG5cbi8vIHdlIGNhY2hlIHdlZWsgZGF0YSBvbiB0aGUgRFQgb2JqZWN0IGFuZCB0aGlzIGludGVybWVkaWF0ZXMgdGhlIGNhY2hlXG5mdW5jdGlvbiBwb3NzaWJseUNhY2hlZFdlZWtEYXRhKGR0KSB7XG4gIGlmIChkdC53ZWVrRGF0YSA9PT0gbnVsbCkge1xuICAgIGR0LndlZWtEYXRhID0gZ3JlZ29yaWFuVG9XZWVrKGR0LmMpO1xuICB9XG4gIHJldHVybiBkdC53ZWVrRGF0YTtcbn1cblxuLy8gY2xvbmUgcmVhbGx5IG1lYW5zLCBcIm1ha2UgYSBuZXcgb2JqZWN0IHdpdGggdGhlc2UgbW9kaWZpY2F0aW9uc1wiLiBhbGwgXCJzZXR0ZXJzXCIgcmVhbGx5IHVzZSB0aGlzXG4vLyB0byBjcmVhdGUgYSBuZXcgb2JqZWN0IHdoaWxlIG9ubHkgY2hhbmdpbmcgc29tZSBvZiB0aGUgcHJvcGVydGllc1xuZnVuY3Rpb24gY2xvbmUoaW5zdCwgYWx0cykge1xuICBjb25zdCBjdXJyZW50ID0ge1xuICAgIHRzOiBpbnN0LnRzLFxuICAgIHpvbmU6IGluc3Quem9uZSxcbiAgICBjOiBpbnN0LmMsXG4gICAgbzogaW5zdC5vLFxuICAgIGxvYzogaW5zdC5sb2MsXG4gICAgaW52YWxpZDogaW5zdC5pbnZhbGlkLFxuICB9O1xuICByZXR1cm4gbmV3IERhdGVUaW1lKHsgLi4uY3VycmVudCwgLi4uYWx0cywgb2xkOiBjdXJyZW50IH0pO1xufVxuXG4vLyBmaW5kIHRoZSByaWdodCBvZmZzZXQgYSBnaXZlbiBsb2NhbCB0aW1lLiBUaGUgbyBpbnB1dCBpcyBvdXIgZ3Vlc3MsIHdoaWNoIGRldGVybWluZXMgd2hpY2hcbi8vIG9mZnNldCB3ZSdsbCBwaWNrIGluIGFtYmlndW91cyBjYXNlcyAoZS5nLiB0aGVyZSBhcmUgdHdvIDMgQU1zIGIvYyBGYWxsYmFjayBEU1QpXG5mdW5jdGlvbiBmaXhPZmZzZXQobG9jYWxUUywgbywgdHopIHtcbiAgLy8gT3VyIFVUQyB0aW1lIGlzIGp1c3QgYSBndWVzcyBiZWNhdXNlIG91ciBvZmZzZXQgaXMganVzdCBhIGd1ZXNzXG4gIGxldCB1dGNHdWVzcyA9IGxvY2FsVFMgLSBvICogNjAgKiAxMDAwO1xuXG4gIC8vIFRlc3Qgd2hldGhlciB0aGUgem9uZSBtYXRjaGVzIHRoZSBvZmZzZXQgZm9yIHRoaXMgdHNcbiAgY29uc3QgbzIgPSB0ei5vZmZzZXQodXRjR3Vlc3MpO1xuXG4gIC8vIElmIHNvLCBvZmZzZXQgZGlkbid0IGNoYW5nZSBhbmQgd2UncmUgZG9uZVxuICBpZiAobyA9PT0gbzIpIHtcbiAgICByZXR1cm4gW3V0Y0d1ZXNzLCBvXTtcbiAgfVxuXG4gIC8vIElmIG5vdCwgY2hhbmdlIHRoZSB0cyBieSB0aGUgZGlmZmVyZW5jZSBpbiB0aGUgb2Zmc2V0XG4gIHV0Y0d1ZXNzIC09IChvMiAtIG8pICogNjAgKiAxMDAwO1xuXG4gIC8vIElmIHRoYXQgZ2l2ZXMgdXMgdGhlIGxvY2FsIHRpbWUgd2Ugd2FudCwgd2UncmUgZG9uZVxuICBjb25zdCBvMyA9IHR6Lm9mZnNldCh1dGNHdWVzcyk7XG4gIGlmIChvMiA9PT0gbzMpIHtcbiAgICByZXR1cm4gW3V0Y0d1ZXNzLCBvMl07XG4gIH1cblxuICAvLyBJZiBpdCdzIGRpZmZlcmVudCwgd2UncmUgaW4gYSBob2xlIHRpbWUuIFRoZSBvZmZzZXQgaGFzIGNoYW5nZWQsIGJ1dCB0aGUgd2UgZG9uJ3QgYWRqdXN0IHRoZSB0aW1lXG4gIHJldHVybiBbbG9jYWxUUyAtIE1hdGgubWluKG8yLCBvMykgKiA2MCAqIDEwMDAsIE1hdGgubWF4KG8yLCBvMyldO1xufVxuXG4vLyBjb252ZXJ0IGFuIGVwb2NoIHRpbWVzdGFtcCBpbnRvIGEgY2FsZW5kYXIgb2JqZWN0IHdpdGggdGhlIGdpdmVuIG9mZnNldFxuZnVuY3Rpb24gdHNUb09iaih0cywgb2Zmc2V0KSB7XG4gIHRzICs9IG9mZnNldCAqIDYwICogMTAwMDtcblxuICBjb25zdCBkID0gbmV3IERhdGUodHMpO1xuXG4gIHJldHVybiB7XG4gICAgeWVhcjogZC5nZXRVVENGdWxsWWVhcigpLFxuICAgIG1vbnRoOiBkLmdldFVUQ01vbnRoKCkgKyAxLFxuICAgIGRheTogZC5nZXRVVENEYXRlKCksXG4gICAgaG91cjogZC5nZXRVVENIb3VycygpLFxuICAgIG1pbnV0ZTogZC5nZXRVVENNaW51dGVzKCksXG4gICAgc2Vjb25kOiBkLmdldFVUQ1NlY29uZHMoKSxcbiAgICBtaWxsaXNlY29uZDogZC5nZXRVVENNaWxsaXNlY29uZHMoKSxcbiAgfTtcbn1cblxuLy8gY29udmVydCBhIGNhbGVuZGFyIG9iamVjdCB0byBhIGVwb2NoIHRpbWVzdGFtcFxuZnVuY3Rpb24gb2JqVG9UUyhvYmosIG9mZnNldCwgem9uZSkge1xuICByZXR1cm4gZml4T2Zmc2V0KG9ialRvTG9jYWxUUyhvYmopLCBvZmZzZXQsIHpvbmUpO1xufVxuXG4vLyBjcmVhdGUgYSBuZXcgRFQgaW5zdGFuY2UgYnkgYWRkaW5nIGEgZHVyYXRpb24sIGFkanVzdGluZyBmb3IgRFNUc1xuZnVuY3Rpb24gYWRqdXN0VGltZShpbnN0LCBkdXIpIHtcbiAgY29uc3Qgb1ByZSA9IGluc3QubyxcbiAgICB5ZWFyID0gaW5zdC5jLnllYXIgKyBNYXRoLnRydW5jKGR1ci55ZWFycyksXG4gICAgbW9udGggPSBpbnN0LmMubW9udGggKyBNYXRoLnRydW5jKGR1ci5tb250aHMpICsgTWF0aC50cnVuYyhkdXIucXVhcnRlcnMpICogMyxcbiAgICBjID0ge1xuICAgICAgLi4uaW5zdC5jLFxuICAgICAgeWVhcixcbiAgICAgIG1vbnRoLFxuICAgICAgZGF5OlxuICAgICAgICBNYXRoLm1pbihpbnN0LmMuZGF5LCBkYXlzSW5Nb250aCh5ZWFyLCBtb250aCkpICtcbiAgICAgICAgTWF0aC50cnVuYyhkdXIuZGF5cykgK1xuICAgICAgICBNYXRoLnRydW5jKGR1ci53ZWVrcykgKiA3LFxuICAgIH0sXG4gICAgbWlsbGlzVG9BZGQgPSBEdXJhdGlvbi5mcm9tT2JqZWN0KHtcbiAgICAgIHllYXJzOiBkdXIueWVhcnMgLSBNYXRoLnRydW5jKGR1ci55ZWFycyksXG4gICAgICBxdWFydGVyczogZHVyLnF1YXJ0ZXJzIC0gTWF0aC50cnVuYyhkdXIucXVhcnRlcnMpLFxuICAgICAgbW9udGhzOiBkdXIubW9udGhzIC0gTWF0aC50cnVuYyhkdXIubW9udGhzKSxcbiAgICAgIHdlZWtzOiBkdXIud2Vla3MgLSBNYXRoLnRydW5jKGR1ci53ZWVrcyksXG4gICAgICBkYXlzOiBkdXIuZGF5cyAtIE1hdGgudHJ1bmMoZHVyLmRheXMpLFxuICAgICAgaG91cnM6IGR1ci5ob3VycyxcbiAgICAgIG1pbnV0ZXM6IGR1ci5taW51dGVzLFxuICAgICAgc2Vjb25kczogZHVyLnNlY29uZHMsXG4gICAgICBtaWxsaXNlY29uZHM6IGR1ci5taWxsaXNlY29uZHMsXG4gICAgfSkuYXMoXCJtaWxsaXNlY29uZHNcIiksXG4gICAgbG9jYWxUUyA9IG9ialRvTG9jYWxUUyhjKTtcblxuICBsZXQgW3RzLCBvXSA9IGZpeE9mZnNldChsb2NhbFRTLCBvUHJlLCBpbnN0LnpvbmUpO1xuXG4gIGlmIChtaWxsaXNUb0FkZCAhPT0gMCkge1xuICAgIHRzICs9IG1pbGxpc1RvQWRkO1xuICAgIC8vIHRoYXQgY291bGQgaGF2ZSBjaGFuZ2VkIHRoZSBvZmZzZXQgYnkgZ29pbmcgb3ZlciBhIERTVCwgYnV0IHdlIHdhbnQgdG8ga2VlcCB0aGUgdHMgdGhlIHNhbWVcbiAgICBvID0gaW5zdC56b25lLm9mZnNldCh0cyk7XG4gIH1cblxuICByZXR1cm4geyB0cywgbyB9O1xufVxuXG4vLyBoZWxwZXIgdXNlZnVsIGluIHR1cm5pbmcgdGhlIHJlc3VsdHMgb2YgcGFyc2luZyBpbnRvIHJlYWwgZGF0ZXNcbi8vIGJ5IGhhbmRsaW5nIHRoZSB6b25lIG9wdGlvbnNcbmZ1bmN0aW9uIHBhcnNlRGF0YVRvRGF0ZVRpbWUocGFyc2VkLCBwYXJzZWRab25lLCBvcHRzLCBmb3JtYXQsIHRleHQsIHNwZWNpZmljT2Zmc2V0KSB7XG4gIGNvbnN0IHsgc2V0Wm9uZSwgem9uZSB9ID0gb3B0cztcbiAgaWYgKChwYXJzZWQgJiYgT2JqZWN0LmtleXMocGFyc2VkKS5sZW5ndGggIT09IDApIHx8IHBhcnNlZFpvbmUpIHtcbiAgICBjb25zdCBpbnRlcnByZXRhdGlvblpvbmUgPSBwYXJzZWRab25lIHx8IHpvbmUsXG4gICAgICBpbnN0ID0gRGF0ZVRpbWUuZnJvbU9iamVjdChwYXJzZWQsIHtcbiAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgem9uZTogaW50ZXJwcmV0YXRpb25ab25lLFxuICAgICAgICBzcGVjaWZpY09mZnNldCxcbiAgICAgIH0pO1xuICAgIHJldHVybiBzZXRab25lID8gaW5zdCA6IGluc3Quc2V0Wm9uZSh6b25lKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChcbiAgICAgIG5ldyBJbnZhbGlkKFwidW5wYXJzYWJsZVwiLCBgdGhlIGlucHV0IFwiJHt0ZXh0fVwiIGNhbid0IGJlIHBhcnNlZCBhcyAke2Zvcm1hdH1gKVxuICAgICk7XG4gIH1cbn1cblxuLy8gaWYgeW91IHdhbnQgdG8gb3V0cHV0IGEgdGVjaG5pY2FsIGZvcm1hdCAoZS5nLiBSRkMgMjgyMiksIHRoaXMgaGVscGVyXG4vLyBoZWxwcyBoYW5kbGUgdGhlIGRldGFpbHNcbmZ1bmN0aW9uIHRvVGVjaEZvcm1hdChkdCwgZm9ybWF0LCBhbGxvd1ogPSB0cnVlKSB7XG4gIHJldHVybiBkdC5pc1ZhbGlkXG4gICAgPyBGb3JtYXR0ZXIuY3JlYXRlKExvY2FsZS5jcmVhdGUoXCJlbi1VU1wiKSwge1xuICAgICAgICBhbGxvd1osXG4gICAgICAgIGZvcmNlU2ltcGxlOiB0cnVlLFxuICAgICAgfSkuZm9ybWF0RGF0ZVRpbWVGcm9tU3RyaW5nKGR0LCBmb3JtYXQpXG4gICAgOiBudWxsO1xufVxuXG5mdW5jdGlvbiB0b0lTT0RhdGUobywgZXh0ZW5kZWQpIHtcbiAgY29uc3QgbG9uZ0Zvcm1hdCA9IG8uYy55ZWFyID4gOTk5OSB8fCBvLmMueWVhciA8IDA7XG4gIGxldCBjID0gXCJcIjtcbiAgaWYgKGxvbmdGb3JtYXQgJiYgby5jLnllYXIgPj0gMCkgYyArPSBcIitcIjtcbiAgYyArPSBwYWRTdGFydChvLmMueWVhciwgbG9uZ0Zvcm1hdCA/IDYgOiA0KTtcblxuICBpZiAoZXh0ZW5kZWQpIHtcbiAgICBjICs9IFwiLVwiO1xuICAgIGMgKz0gcGFkU3RhcnQoby5jLm1vbnRoKTtcbiAgICBjICs9IFwiLVwiO1xuICAgIGMgKz0gcGFkU3RhcnQoby5jLmRheSk7XG4gIH0gZWxzZSB7XG4gICAgYyArPSBwYWRTdGFydChvLmMubW9udGgpO1xuICAgIGMgKz0gcGFkU3RhcnQoby5jLmRheSk7XG4gIH1cbiAgcmV0dXJuIGM7XG59XG5cbmZ1bmN0aW9uIHRvSVNPVGltZShcbiAgbyxcbiAgZXh0ZW5kZWQsXG4gIHN1cHByZXNzU2Vjb25kcyxcbiAgc3VwcHJlc3NNaWxsaXNlY29uZHMsXG4gIGluY2x1ZGVPZmZzZXQsXG4gIGV4dGVuZGVkWm9uZVxuKSB7XG4gIGxldCBjID0gcGFkU3RhcnQoby5jLmhvdXIpO1xuICBpZiAoZXh0ZW5kZWQpIHtcbiAgICBjICs9IFwiOlwiO1xuICAgIGMgKz0gcGFkU3RhcnQoby5jLm1pbnV0ZSk7XG4gICAgaWYgKG8uYy5taWxsaXNlY29uZCAhPT0gMCB8fCBvLmMuc2Vjb25kICE9PSAwIHx8ICFzdXBwcmVzc1NlY29uZHMpIHtcbiAgICAgIGMgKz0gXCI6XCI7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGMgKz0gcGFkU3RhcnQoby5jLm1pbnV0ZSk7XG4gIH1cblxuICBpZiAoby5jLm1pbGxpc2Vjb25kICE9PSAwIHx8IG8uYy5zZWNvbmQgIT09IDAgfHwgIXN1cHByZXNzU2Vjb25kcykge1xuICAgIGMgKz0gcGFkU3RhcnQoby5jLnNlY29uZCk7XG5cbiAgICBpZiAoby5jLm1pbGxpc2Vjb25kICE9PSAwIHx8ICFzdXBwcmVzc01pbGxpc2Vjb25kcykge1xuICAgICAgYyArPSBcIi5cIjtcbiAgICAgIGMgKz0gcGFkU3RhcnQoby5jLm1pbGxpc2Vjb25kLCAzKTtcbiAgICB9XG4gIH1cblxuICBpZiAoaW5jbHVkZU9mZnNldCkge1xuICAgIGlmIChvLmlzT2Zmc2V0Rml4ZWQgJiYgby5vZmZzZXQgPT09IDAgJiYgIWV4dGVuZGVkWm9uZSkge1xuICAgICAgYyArPSBcIlpcIjtcbiAgICB9IGVsc2UgaWYgKG8ubyA8IDApIHtcbiAgICAgIGMgKz0gXCItXCI7XG4gICAgICBjICs9IHBhZFN0YXJ0KE1hdGgudHJ1bmMoLW8ubyAvIDYwKSk7XG4gICAgICBjICs9IFwiOlwiO1xuICAgICAgYyArPSBwYWRTdGFydChNYXRoLnRydW5jKC1vLm8gJSA2MCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjICs9IFwiK1wiO1xuICAgICAgYyArPSBwYWRTdGFydChNYXRoLnRydW5jKG8ubyAvIDYwKSk7XG4gICAgICBjICs9IFwiOlwiO1xuICAgICAgYyArPSBwYWRTdGFydChNYXRoLnRydW5jKG8ubyAlIDYwKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGV4dGVuZGVkWm9uZSkge1xuICAgIGMgKz0gXCJbXCIgKyBvLnpvbmUuaWFuYU5hbWUgKyBcIl1cIjtcbiAgfVxuICByZXR1cm4gYztcbn1cblxuLy8gZGVmYXVsdHMgZm9yIHVuc3BlY2lmaWVkIHVuaXRzIGluIHRoZSBzdXBwb3J0ZWQgY2FsZW5kYXJzXG5jb25zdCBkZWZhdWx0VW5pdFZhbHVlcyA9IHtcbiAgICBtb250aDogMSxcbiAgICBkYXk6IDEsXG4gICAgaG91cjogMCxcbiAgICBtaW51dGU6IDAsXG4gICAgc2Vjb25kOiAwLFxuICAgIG1pbGxpc2Vjb25kOiAwLFxuICB9LFxuICBkZWZhdWx0V2Vla1VuaXRWYWx1ZXMgPSB7XG4gICAgd2Vla051bWJlcjogMSxcbiAgICB3ZWVrZGF5OiAxLFxuICAgIGhvdXI6IDAsXG4gICAgbWludXRlOiAwLFxuICAgIHNlY29uZDogMCxcbiAgICBtaWxsaXNlY29uZDogMCxcbiAgfSxcbiAgZGVmYXVsdE9yZGluYWxVbml0VmFsdWVzID0ge1xuICAgIG9yZGluYWw6IDEsXG4gICAgaG91cjogMCxcbiAgICBtaW51dGU6IDAsXG4gICAgc2Vjb25kOiAwLFxuICAgIG1pbGxpc2Vjb25kOiAwLFxuICB9O1xuXG4vLyBVbml0cyBpbiB0aGUgc3VwcG9ydGVkIGNhbGVuZGFycywgc29ydGVkIGJ5IGJpZ25lc3NcbmNvbnN0IG9yZGVyZWRVbml0cyA9IFtcInllYXJcIiwgXCJtb250aFwiLCBcImRheVwiLCBcImhvdXJcIiwgXCJtaW51dGVcIiwgXCJzZWNvbmRcIiwgXCJtaWxsaXNlY29uZFwiXSxcbiAgb3JkZXJlZFdlZWtVbml0cyA9IFtcbiAgICBcIndlZWtZZWFyXCIsXG4gICAgXCJ3ZWVrTnVtYmVyXCIsXG4gICAgXCJ3ZWVrZGF5XCIsXG4gICAgXCJob3VyXCIsXG4gICAgXCJtaW51dGVcIixcbiAgICBcInNlY29uZFwiLFxuICAgIFwibWlsbGlzZWNvbmRcIixcbiAgXSxcbiAgb3JkZXJlZE9yZGluYWxVbml0cyA9IFtcInllYXJcIiwgXCJvcmRpbmFsXCIsIFwiaG91clwiLCBcIm1pbnV0ZVwiLCBcInNlY29uZFwiLCBcIm1pbGxpc2Vjb25kXCJdO1xuXG4vLyBzdGFuZGFyZGl6ZSBjYXNlIGFuZCBwbHVyYWxpdHkgaW4gdW5pdHNcbmZ1bmN0aW9uIG5vcm1hbGl6ZVVuaXQodW5pdCkge1xuICBjb25zdCBub3JtYWxpemVkID0ge1xuICAgIHllYXI6IFwieWVhclwiLFxuICAgIHllYXJzOiBcInllYXJcIixcbiAgICBtb250aDogXCJtb250aFwiLFxuICAgIG1vbnRoczogXCJtb250aFwiLFxuICAgIGRheTogXCJkYXlcIixcbiAgICBkYXlzOiBcImRheVwiLFxuICAgIGhvdXI6IFwiaG91clwiLFxuICAgIGhvdXJzOiBcImhvdXJcIixcbiAgICBtaW51dGU6IFwibWludXRlXCIsXG4gICAgbWludXRlczogXCJtaW51dGVcIixcbiAgICBxdWFydGVyOiBcInF1YXJ0ZXJcIixcbiAgICBxdWFydGVyczogXCJxdWFydGVyXCIsXG4gICAgc2Vjb25kOiBcInNlY29uZFwiLFxuICAgIHNlY29uZHM6IFwic2Vjb25kXCIsXG4gICAgbWlsbGlzZWNvbmQ6IFwibWlsbGlzZWNvbmRcIixcbiAgICBtaWxsaXNlY29uZHM6IFwibWlsbGlzZWNvbmRcIixcbiAgICB3ZWVrZGF5OiBcIndlZWtkYXlcIixcbiAgICB3ZWVrZGF5czogXCJ3ZWVrZGF5XCIsXG4gICAgd2Vla251bWJlcjogXCJ3ZWVrTnVtYmVyXCIsXG4gICAgd2Vla3NudW1iZXI6IFwid2Vla051bWJlclwiLFxuICAgIHdlZWtudW1iZXJzOiBcIndlZWtOdW1iZXJcIixcbiAgICB3ZWVreWVhcjogXCJ3ZWVrWWVhclwiLFxuICAgIHdlZWt5ZWFyczogXCJ3ZWVrWWVhclwiLFxuICAgIG9yZGluYWw6IFwib3JkaW5hbFwiLFxuICB9W3VuaXQudG9Mb3dlckNhc2UoKV07XG5cbiAgaWYgKCFub3JtYWxpemVkKSB0aHJvdyBuZXcgSW52YWxpZFVuaXRFcnJvcih1bml0KTtcblxuICByZXR1cm4gbm9ybWFsaXplZDtcbn1cblxuLy8gdGhpcyBpcyBhIGR1bWJlZCBkb3duIHZlcnNpb24gb2YgZnJvbU9iamVjdCgpIHRoYXQgcnVucyBhYm91dCA2MCUgZmFzdGVyXG4vLyBidXQgZG9lc24ndCBkbyBhbnkgdmFsaWRhdGlvbiwgbWFrZXMgYSBidW5jaCBvZiBhc3N1bXB0aW9ucyBhYm91dCB3aGF0IHVuaXRzXG4vLyBhcmUgcHJlc2VudCwgYW5kIHNvIG9uLlxuZnVuY3Rpb24gcXVpY2tEVChvYmosIG9wdHMpIHtcbiAgY29uc3Qgem9uZSA9IG5vcm1hbGl6ZVpvbmUob3B0cy56b25lLCBTZXR0aW5ncy5kZWZhdWx0Wm9uZSksXG4gICAgbG9jID0gTG9jYWxlLmZyb21PYmplY3Qob3B0cyksXG4gICAgdHNOb3cgPSBTZXR0aW5ncy5ub3coKTtcblxuICBsZXQgdHMsIG87XG5cbiAgLy8gYXNzdW1lIHdlIGhhdmUgdGhlIGhpZ2hlci1vcmRlciB1bml0c1xuICBpZiAoIWlzVW5kZWZpbmVkKG9iai55ZWFyKSkge1xuICAgIGZvciAoY29uc3QgdSBvZiBvcmRlcmVkVW5pdHMpIHtcbiAgICAgIGlmIChpc1VuZGVmaW5lZChvYmpbdV0pKSB7XG4gICAgICAgIG9ialt1XSA9IGRlZmF1bHRVbml0VmFsdWVzW3VdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGludmFsaWQgPSBoYXNJbnZhbGlkR3JlZ29yaWFuRGF0YShvYmopIHx8IGhhc0ludmFsaWRUaW1lRGF0YShvYmopO1xuICAgIGlmIChpbnZhbGlkKSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChpbnZhbGlkKTtcbiAgICB9XG5cbiAgICBjb25zdCBvZmZzZXRQcm92aXMgPSB6b25lLm9mZnNldCh0c05vdyk7XG4gICAgW3RzLCBvXSA9IG9ialRvVFMob2JqLCBvZmZzZXRQcm92aXMsIHpvbmUpO1xuICB9IGVsc2Uge1xuICAgIHRzID0gdHNOb3c7XG4gIH1cblxuICByZXR1cm4gbmV3IERhdGVUaW1lKHsgdHMsIHpvbmUsIGxvYywgbyB9KTtcbn1cblxuZnVuY3Rpb24gZGlmZlJlbGF0aXZlKHN0YXJ0LCBlbmQsIG9wdHMpIHtcbiAgY29uc3Qgcm91bmQgPSBpc1VuZGVmaW5lZChvcHRzLnJvdW5kKSA/IHRydWUgOiBvcHRzLnJvdW5kLFxuICAgIGZvcm1hdCA9IChjLCB1bml0KSA9PiB7XG4gICAgICBjID0gcm91bmRUbyhjLCByb3VuZCB8fCBvcHRzLmNhbGVuZGFyeSA/IDAgOiAyLCB0cnVlKTtcbiAgICAgIGNvbnN0IGZvcm1hdHRlciA9IGVuZC5sb2MuY2xvbmUob3B0cykucmVsRm9ybWF0dGVyKG9wdHMpO1xuICAgICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXQoYywgdW5pdCk7XG4gICAgfSxcbiAgICBkaWZmZXIgPSAodW5pdCkgPT4ge1xuICAgICAgaWYgKG9wdHMuY2FsZW5kYXJ5KSB7XG4gICAgICAgIGlmICghZW5kLmhhc1NhbWUoc3RhcnQsIHVuaXQpKSB7XG4gICAgICAgICAgcmV0dXJuIGVuZC5zdGFydE9mKHVuaXQpLmRpZmYoc3RhcnQuc3RhcnRPZih1bml0KSwgdW5pdCkuZ2V0KHVuaXQpO1xuICAgICAgICB9IGVsc2UgcmV0dXJuIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZW5kLmRpZmYoc3RhcnQsIHVuaXQpLmdldCh1bml0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIGlmIChvcHRzLnVuaXQpIHtcbiAgICByZXR1cm4gZm9ybWF0KGRpZmZlcihvcHRzLnVuaXQpLCBvcHRzLnVuaXQpO1xuICB9XG5cbiAgZm9yIChjb25zdCB1bml0IG9mIG9wdHMudW5pdHMpIHtcbiAgICBjb25zdCBjb3VudCA9IGRpZmZlcih1bml0KTtcbiAgICBpZiAoTWF0aC5hYnMoY291bnQpID49IDEpIHtcbiAgICAgIHJldHVybiBmb3JtYXQoY291bnQsIHVuaXQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZm9ybWF0KHN0YXJ0ID4gZW5kID8gLTAgOiAwLCBvcHRzLnVuaXRzW29wdHMudW5pdHMubGVuZ3RoIC0gMV0pO1xufVxuXG5mdW5jdGlvbiBsYXN0T3B0cyhhcmdMaXN0KSB7XG4gIGxldCBvcHRzID0ge30sXG4gICAgYXJncztcbiAgaWYgKGFyZ0xpc3QubGVuZ3RoID4gMCAmJiB0eXBlb2YgYXJnTGlzdFthcmdMaXN0Lmxlbmd0aCAtIDFdID09PSBcIm9iamVjdFwiKSB7XG4gICAgb3B0cyA9IGFyZ0xpc3RbYXJnTGlzdC5sZW5ndGggLSAxXTtcbiAgICBhcmdzID0gQXJyYXkuZnJvbShhcmdMaXN0KS5zbGljZSgwLCBhcmdMaXN0Lmxlbmd0aCAtIDEpO1xuICB9IGVsc2Uge1xuICAgIGFyZ3MgPSBBcnJheS5mcm9tKGFyZ0xpc3QpO1xuICB9XG4gIHJldHVybiBbb3B0cywgYXJnc107XG59XG5cbi8qKlxuICogQSBEYXRlVGltZSBpcyBhbiBpbW11dGFibGUgZGF0YSBzdHJ1Y3R1cmUgcmVwcmVzZW50aW5nIGEgc3BlY2lmaWMgZGF0ZSBhbmQgdGltZSBhbmQgYWNjb21wYW55aW5nIG1ldGhvZHMuIEl0IGNvbnRhaW5zIGNsYXNzIGFuZCBpbnN0YW5jZSBtZXRob2RzIGZvciBjcmVhdGluZywgcGFyc2luZywgaW50ZXJyb2dhdGluZywgdHJhbnNmb3JtaW5nLCBhbmQgZm9ybWF0dGluZyB0aGVtLlxuICpcbiAqIEEgRGF0ZVRpbWUgY29tcHJpc2VzIG9mOlxuICogKiBBIHRpbWVzdGFtcC4gRWFjaCBEYXRlVGltZSBpbnN0YW5jZSByZWZlcnMgdG8gYSBzcGVjaWZpYyBtaWxsaXNlY29uZCBvZiB0aGUgVW5peCBlcG9jaC5cbiAqICogQSB0aW1lIHpvbmUuIEVhY2ggaW5zdGFuY2UgaXMgY29uc2lkZXJlZCBpbiB0aGUgY29udGV4dCBvZiBhIHNwZWNpZmljIHpvbmUgKGJ5IGRlZmF1bHQgdGhlIGxvY2FsIHN5c3RlbSdzIHpvbmUpLlxuICogKiBDb25maWd1cmF0aW9uIHByb3BlcnRpZXMgdGhhdCBlZmZlY3QgaG93IG91dHB1dCBzdHJpbmdzIGFyZSBmb3JtYXR0ZWQsIHN1Y2ggYXMgYGxvY2FsZWAsIGBudW1iZXJpbmdTeXN0ZW1gLCBhbmQgYG91dHB1dENhbGVuZGFyYC5cbiAqXG4gKiBIZXJlIGlzIGEgYnJpZWYgb3ZlcnZpZXcgb2YgdGhlIG1vc3QgY29tbW9ubHkgdXNlZCBmdW5jdGlvbmFsaXR5IGl0IHByb3ZpZGVzOlxuICpcbiAqICogKipDcmVhdGlvbioqOiBUbyBjcmVhdGUgYSBEYXRlVGltZSBmcm9tIGl0cyBjb21wb25lbnRzLCB1c2Ugb25lIG9mIGl0cyBmYWN0b3J5IGNsYXNzIG1ldGhvZHM6IHtAbGluayBEYXRlVGltZS5sb2NhbH0sIHtAbGluayBEYXRlVGltZS51dGN9LCBhbmQgKG1vc3QgZmxleGlibHkpIHtAbGluayBEYXRlVGltZS5mcm9tT2JqZWN0fS4gVG8gY3JlYXRlIG9uZSBmcm9tIGEgc3RhbmRhcmQgc3RyaW5nIGZvcm1hdCwgdXNlIHtAbGluayBEYXRlVGltZS5mcm9tSVNPfSwge0BsaW5rIERhdGVUaW1lLmZyb21IVFRQfSwgYW5kIHtAbGluayBEYXRlVGltZS5mcm9tUkZDMjgyMn0uIFRvIGNyZWF0ZSBvbmUgZnJvbSBhIGN1c3RvbSBzdHJpbmcgZm9ybWF0LCB1c2Uge0BsaW5rIERhdGVUaW1lLmZyb21Gb3JtYXR9LiBUbyBjcmVhdGUgb25lIGZyb20gYSBuYXRpdmUgSlMgZGF0ZSwgdXNlIHtAbGluayBEYXRlVGltZS5mcm9tSlNEYXRlfS5cbiAqICogKipHcmVnb3JpYW4gY2FsZW5kYXIgYW5kIHRpbWUqKjogVG8gZXhhbWluZSB0aGUgR3JlZ29yaWFuIHByb3BlcnRpZXMgb2YgYSBEYXRlVGltZSBpbmRpdmlkdWFsbHkgKGkuZSBhcyBvcHBvc2VkIHRvIGNvbGxlY3RpdmVseSB0aHJvdWdoIHtAbGluayBEYXRlVGltZSN0b09iamVjdH0pLCB1c2UgdGhlIHtAbGluayBEYXRlVGltZSN5ZWFyfSwge0BsaW5rIERhdGVUaW1lI21vbnRofSxcbiAqIHtAbGluayBEYXRlVGltZSNkYXl9LCB7QGxpbmsgRGF0ZVRpbWUjaG91cn0sIHtAbGluayBEYXRlVGltZSNtaW51dGV9LCB7QGxpbmsgRGF0ZVRpbWUjc2Vjb25kfSwge0BsaW5rIERhdGVUaW1lI21pbGxpc2Vjb25kfSBhY2Nlc3NvcnMuXG4gKiAqICoqV2VlayBjYWxlbmRhcioqOiBGb3IgSVNPIHdlZWsgY2FsZW5kYXIgYXR0cmlidXRlcywgc2VlIHRoZSB7QGxpbmsgRGF0ZVRpbWUjd2Vla1llYXJ9LCB7QGxpbmsgRGF0ZVRpbWUjd2Vla051bWJlcn0sIGFuZCB7QGxpbmsgRGF0ZVRpbWUjd2Vla2RheX0gYWNjZXNzb3JzLlxuICogKiAqKkNvbmZpZ3VyYXRpb24qKiBTZWUgdGhlIHtAbGluayBEYXRlVGltZSNsb2NhbGV9IGFuZCB7QGxpbmsgRGF0ZVRpbWUjbnVtYmVyaW5nU3lzdGVtfSBhY2Nlc3NvcnMuXG4gKiAqICoqVHJhbnNmb3JtYXRpb24qKjogVG8gdHJhbnNmb3JtIHRoZSBEYXRlVGltZSBpbnRvIG90aGVyIERhdGVUaW1lcywgdXNlIHtAbGluayBEYXRlVGltZSNzZXR9LCB7QGxpbmsgRGF0ZVRpbWUjcmVjb25maWd1cmV9LCB7QGxpbmsgRGF0ZVRpbWUjc2V0Wm9uZX0sIHtAbGluayBEYXRlVGltZSNzZXRMb2NhbGV9LCB7QGxpbmsgRGF0ZVRpbWUucGx1c30sIHtAbGluayBEYXRlVGltZSNtaW51c30sIHtAbGluayBEYXRlVGltZSNlbmRPZn0sIHtAbGluayBEYXRlVGltZSNzdGFydE9mfSwge0BsaW5rIERhdGVUaW1lI3RvVVRDfSwgYW5kIHtAbGluayBEYXRlVGltZSN0b0xvY2FsfS5cbiAqICogKipPdXRwdXQqKjogVG8gY29udmVydCB0aGUgRGF0ZVRpbWUgdG8gb3RoZXIgcmVwcmVzZW50YXRpb25zLCB1c2UgdGhlIHtAbGluayBEYXRlVGltZSN0b1JlbGF0aXZlfSwge0BsaW5rIERhdGVUaW1lI3RvUmVsYXRpdmVDYWxlbmRhcn0sIHtAbGluayBEYXRlVGltZSN0b0pTT059LCB7QGxpbmsgRGF0ZVRpbWUjdG9JU099LCB7QGxpbmsgRGF0ZVRpbWUjdG9IVFRQfSwge0BsaW5rIERhdGVUaW1lI3RvT2JqZWN0fSwge0BsaW5rIERhdGVUaW1lI3RvUkZDMjgyMn0sIHtAbGluayBEYXRlVGltZSN0b1N0cmluZ30sIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30sIHtAbGluayBEYXRlVGltZSN0b0Zvcm1hdH0sIHtAbGluayBEYXRlVGltZSN0b01pbGxpc30gYW5kIHtAbGluayBEYXRlVGltZSN0b0pTRGF0ZX0uXG4gKlxuICogVGhlcmUncyBwbGVudHkgb3RoZXJzIGRvY3VtZW50ZWQgYmVsb3cuIEluIGFkZGl0aW9uLCBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBzdWJ0bGVyIHRvcGljcyBsaWtlIGludGVybmF0aW9uYWxpemF0aW9uLCB0aW1lIHpvbmVzLCBhbHRlcm5hdGl2ZSBjYWxlbmRhcnMsIHZhbGlkaXR5LCBhbmQgc28gb24sIHNlZSB0aGUgZXh0ZXJuYWwgZG9jdW1lbnRhdGlvbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGF0ZVRpbWUge1xuICAvKipcbiAgICogQGFjY2VzcyBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBjb25zdCB6b25lID0gY29uZmlnLnpvbmUgfHwgU2V0dGluZ3MuZGVmYXVsdFpvbmU7XG5cbiAgICBsZXQgaW52YWxpZCA9XG4gICAgICBjb25maWcuaW52YWxpZCB8fFxuICAgICAgKE51bWJlci5pc05hTihjb25maWcudHMpID8gbmV3IEludmFsaWQoXCJpbnZhbGlkIGlucHV0XCIpIDogbnVsbCkgfHxcbiAgICAgICghem9uZS5pc1ZhbGlkID8gdW5zdXBwb3J0ZWRab25lKHpvbmUpIDogbnVsbCk7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy50cyA9IGlzVW5kZWZpbmVkKGNvbmZpZy50cykgPyBTZXR0aW5ncy5ub3coKSA6IGNvbmZpZy50cztcblxuICAgIGxldCBjID0gbnVsbCxcbiAgICAgIG8gPSBudWxsO1xuICAgIGlmICghaW52YWxpZCkge1xuICAgICAgY29uc3QgdW5jaGFuZ2VkID0gY29uZmlnLm9sZCAmJiBjb25maWcub2xkLnRzID09PSB0aGlzLnRzICYmIGNvbmZpZy5vbGQuem9uZS5lcXVhbHMoem9uZSk7XG5cbiAgICAgIGlmICh1bmNoYW5nZWQpIHtcbiAgICAgICAgW2MsIG9dID0gW2NvbmZpZy5vbGQuYywgY29uZmlnLm9sZC5vXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG90ID0gem9uZS5vZmZzZXQodGhpcy50cyk7XG4gICAgICAgIGMgPSB0c1RvT2JqKHRoaXMudHMsIG90KTtcbiAgICAgICAgaW52YWxpZCA9IE51bWJlci5pc05hTihjLnllYXIpID8gbmV3IEludmFsaWQoXCJpbnZhbGlkIGlucHV0XCIpIDogbnVsbDtcbiAgICAgICAgYyA9IGludmFsaWQgPyBudWxsIDogYztcbiAgICAgICAgbyA9IGludmFsaWQgPyBudWxsIDogb3Q7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fem9uZSA9IHpvbmU7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5sb2MgPSBjb25maWcubG9jIHx8IExvY2FsZS5jcmVhdGUoKTtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmludmFsaWQgPSBpbnZhbGlkO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMud2Vla0RhdGEgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuYyA9IGM7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5vID0gbztcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmlzTHV4b25EYXRlVGltZSA9IHRydWU7XG4gIH1cblxuICAvLyBDT05TVFJVQ1RcblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZm9yIHRoZSBjdXJyZW50IGluc3RhbnQsIGluIHRoZSBzeXN0ZW0ncyB0aW1lIHpvbmUuXG4gICAqXG4gICAqIFVzZSBTZXR0aW5ncyB0byBvdmVycmlkZSB0aGVzZSBkZWZhdWx0IHZhbHVlcyBpZiBuZWVkZWQuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvSVNPKCkgLy9+PiBub3cgaW4gdGhlIElTTyBmb3JtYXRcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgbm93KCkge1xuICAgIHJldHVybiBuZXcgRGF0ZVRpbWUoe30pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGxvY2FsIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeWVhcl0gLSBUaGUgY2FsZW5kYXIgeWVhci4gSWYgb21pdHRlZCAoYXMgaW4sIGNhbGwgYGxvY2FsKClgIHdpdGggbm8gYXJndW1lbnRzKSwgdGhlIGN1cnJlbnQgdGltZSB3aWxsIGJlIHVzZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttb250aD0xXSAtIFRoZSBtb250aCwgMS1pbmRleGVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZGF5PTFdIC0gVGhlIGRheSBvZiB0aGUgbW9udGgsIDEtaW5kZXhlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2hvdXI9MF0gLSBUaGUgaG91ciBvZiB0aGUgZGF5LCBpbiAyNC1ob3VyIHRpbWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttaW51dGU9MF0gLSBUaGUgbWludXRlIG9mIHRoZSBob3VyLCBtZWFuaW5nIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgNTlcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzZWNvbmQ9MF0gLSBUaGUgc2Vjb25kIG9mIHRoZSBtaW51dGUsIG1lYW5pbmcgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCA1OVxuICAgKiBAcGFyYW0ge251bWJlcn0gW21pbGxpc2Vjb25kPTBdIC0gVGhlIG1pbGxpc2Vjb25kIG9mIHRoZSBzZWNvbmQsIG1lYW5pbmcgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCA5OTlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IG5vd1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCh7IHpvbmU6IFwiQW1lcmljYS9OZXdfWW9ya1wiIH0pICAgICAgLy9+PiBub3csIGluIFVTIGVhc3QgY29hc3QgdGltZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3KSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMS0wMVQwMDowMDowMFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAzKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0wMVQwMDowMDowMFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAzLCAxMiwgeyBsb2NhbGU6IFwiZnJcIiB9KSAgICAgLy9+PiAyMDE3LTAzLTEyVDAwOjAwOjAwLCB3aXRoIGEgRnJlbmNoIGxvY2FsZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAzLCAxMiwgNSkgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwNTowMDowMFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAzLCAxMiwgNSwgeyB6b25lOiBcInV0Y1wiIH0pICAgLy9+PiAyMDE3LTAzLTEyVDA1OjAwOjAwLCBpbiBVVENcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMywgMTIsIDUsIDQ1KSAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6NDU6MDBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMywgMTIsIDUsIDQ1LCAxMCkgICAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6NDU6MTBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMywgMTIsIDUsIDQ1LCAxMCwgNzY1KSAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6NDU6MTAuNzY1XG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGxvY2FsKCkge1xuICAgIGNvbnN0IFtvcHRzLCBhcmdzXSA9IGxhc3RPcHRzKGFyZ3VtZW50cyksXG4gICAgICBbeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kXSA9IGFyZ3M7XG4gICAgcmV0dXJuIHF1aWNrRFQoeyB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQgfSwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgaW4gVVRDXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeWVhcl0gLSBUaGUgY2FsZW5kYXIgeWVhci4gSWYgb21pdHRlZCAoYXMgaW4sIGNhbGwgYHV0YygpYCB3aXRoIG5vIGFyZ3VtZW50cyksIHRoZSBjdXJyZW50IHRpbWUgd2lsbCBiZSB1c2VkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbW9udGg9MV0gLSBUaGUgbW9udGgsIDEtaW5kZXhlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RheT0xXSAtIFRoZSBkYXkgb2YgdGhlIG1vbnRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbaG91cj0wXSAtIFRoZSBob3VyIG9mIHRoZSBkYXksIGluIDI0LWhvdXIgdGltZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW21pbnV0ZT0wXSAtIFRoZSBtaW51dGUgb2YgdGhlIGhvdXIsIG1lYW5pbmcgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCA1OVxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NlY29uZD0wXSAtIFRoZSBzZWNvbmQgb2YgdGhlIG1pbnV0ZSwgbWVhbmluZyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDU5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbWlsbGlzZWNvbmQ9MF0gLSBUaGUgbWlsbGlzZWNvbmQgb2YgdGhlIHNlY29uZCwgbWVhbmluZyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDk5OVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sb2NhbGVdIC0gYSBsb2NhbGUgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm91dHB1dENhbGVuZGFyXSAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm51bWJlcmluZ1N5c3RlbV0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IG5vd1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNykgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDEtMDFUMDA6MDA6MDBaXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3LCAzKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0wMVQwMDowMDowMFpcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTcsIDMsIDEyKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9+PiAyMDE3LTAzLTEyVDAwOjAwOjAwWlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNywgMywgMTIsIDUpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6MDA6MDBaXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3LCAzLCAxMiwgNSwgNDUpICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwNTo0NTowMFpcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTcsIDMsIDEyLCA1LCA0NSwgeyBsb2NhbGU6IFwiZnJcIiB9KSAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6NDU6MDBaIHdpdGggYSBGcmVuY2ggbG9jYWxlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3LCAzLCAxMiwgNSwgNDUsIDEwKSAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwNTo0NToxMFpcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTcsIDMsIDEyLCA1LCA0NSwgMTAsIDc2NSwgeyBsb2NhbGU6IFwiZnJcIiB9KSAvL34+IDIwMTctMDMtMTJUMDU6NDU6MTAuNzY1WiB3aXRoIGEgRnJlbmNoIGxvY2FsZVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyB1dGMoKSB7XG4gICAgY29uc3QgW29wdHMsIGFyZ3NdID0gbGFzdE9wdHMoYXJndW1lbnRzKSxcbiAgICAgIFt5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmRdID0gYXJncztcblxuICAgIG9wdHMuem9uZSA9IEZpeGVkT2Zmc2V0Wm9uZS51dGNJbnN0YW5jZTtcbiAgICByZXR1cm4gcXVpY2tEVCh7IHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCB9LCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGEgSmF2YVNjcmlwdCBEYXRlIG9iamVjdC4gVXNlcyB0aGUgZGVmYXVsdCB6b25lLlxuICAgKiBAcGFyYW0ge0RhdGV9IGRhdGUgLSBhIEphdmFTY3JpcHQgRGF0ZSBvYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBEYXRlVGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0aW9ucy56b25lPSdsb2NhbCddIC0gdGhlIHpvbmUgdG8gcGxhY2UgdGhlIERhdGVUaW1lIGludG9cbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbUpTRGF0ZShkYXRlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB0cyA9IGlzRGF0ZShkYXRlKSA/IGRhdGUudmFsdWVPZigpIDogTmFOO1xuICAgIGlmIChOdW1iZXIuaXNOYU4odHMpKSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChcImludmFsaWQgaW5wdXRcIik7XG4gICAgfVxuXG4gICAgY29uc3Qgem9uZVRvVXNlID0gbm9ybWFsaXplWm9uZShvcHRpb25zLnpvbmUsIFNldHRpbmdzLmRlZmF1bHRab25lKTtcbiAgICBpZiAoIXpvbmVUb1VzZS5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZCh1bnN1cHBvcnRlZFpvbmUoem9uZVRvVXNlKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBEYXRlVGltZSh7XG4gICAgICB0czogdHMsXG4gICAgICB6b25lOiB6b25lVG9Vc2UsXG4gICAgICBsb2M6IExvY2FsZS5mcm9tT2JqZWN0KG9wdGlvbnMpLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBlcG9jaCAobWVhbmluZyBzaW5jZSAxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLiBVc2VzIHRoZSBkZWZhdWx0IHpvbmUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaWxsaXNlY29uZHMgLSBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2UgMTk3MCBVVENcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBEYXRlVGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0aW9ucy56b25lPSdsb2NhbCddIC0gdGhlIHpvbmUgdG8gcGxhY2UgdGhlIERhdGVUaW1lIGludG9cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxvY2FsZV0gLSBhIGxvY2FsZSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5vdXRwdXRDYWxlbmRhciAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbU1pbGxpcyhtaWxsaXNlY29uZHMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghaXNOdW1iZXIobWlsbGlzZWNvbmRzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFxuICAgICAgICBgZnJvbU1pbGxpcyByZXF1aXJlcyBhIG51bWVyaWNhbCBpbnB1dCwgYnV0IHJlY2VpdmVkIGEgJHt0eXBlb2YgbWlsbGlzZWNvbmRzfSB3aXRoIHZhbHVlICR7bWlsbGlzZWNvbmRzfWBcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChtaWxsaXNlY29uZHMgPCAtTUFYX0RBVEUgfHwgbWlsbGlzZWNvbmRzID4gTUFYX0RBVEUpIHtcbiAgICAgIC8vIHRoaXMgaXNuJ3QgcGVyZmVjdCBiZWNhdXNlIGJlY2F1c2Ugd2UgY2FuIHN0aWxsIGVuZCB1cCBvdXQgb2YgcmFuZ2UgYmVjYXVzZSBvZiBhZGRpdGlvbmFsIHNoaWZ0aW5nLCBidXQgaXQncyBhIHN0YXJ0XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChcIlRpbWVzdGFtcCBvdXQgb2YgcmFuZ2VcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZVRpbWUoe1xuICAgICAgICB0czogbWlsbGlzZWNvbmRzLFxuICAgICAgICB6b25lOiBub3JtYWxpemVab25lKG9wdGlvbnMuem9uZSwgU2V0dGluZ3MuZGVmYXVsdFpvbmUpLFxuICAgICAgICBsb2M6IExvY2FsZS5mcm9tT2JqZWN0KG9wdGlvbnMpLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYSBudW1iZXIgb2Ygc2Vjb25kcyBzaW5jZSB0aGUgZXBvY2ggKG1lYW5pbmcgc2luY2UgMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS4gVXNlcyB0aGUgZGVmYXVsdCB6b25lLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Vjb25kcyAtIGEgbnVtYmVyIG9mIHNlY29uZHMgc2luY2UgMTk3MCBVVENcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBEYXRlVGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0aW9ucy56b25lPSdsb2NhbCddIC0gdGhlIHpvbmUgdG8gcGxhY2UgdGhlIERhdGVUaW1lIGludG9cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxvY2FsZV0gLSBhIGxvY2FsZSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5vdXRwdXRDYWxlbmRhciAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbVNlY29uZHMoc2Vjb25kcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFpc051bWJlcihzZWNvbmRzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiZnJvbVNlY29uZHMgcmVxdWlyZXMgYSBudW1lcmljYWwgaW5wdXRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZVRpbWUoe1xuICAgICAgICB0czogc2Vjb25kcyAqIDEwMDAsXG4gICAgICAgIHpvbmU6IG5vcm1hbGl6ZVpvbmUob3B0aW9ucy56b25lLCBTZXR0aW5ncy5kZWZhdWx0Wm9uZSksXG4gICAgICAgIGxvYzogTG9jYWxlLmZyb21PYmplY3Qob3B0aW9ucyksXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhIEphdmFTY3JpcHQgb2JqZWN0IHdpdGgga2V5cyBsaWtlICd5ZWFyJyBhbmQgJ2hvdXInIHdpdGggcmVhc29uYWJsZSBkZWZhdWx0cy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIHRoZSBvYmplY3QgdG8gY3JlYXRlIHRoZSBEYXRlVGltZSBmcm9tXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoueWVhciAtIGEgeWVhciwgc3VjaCBhcyAxOTg3XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoubW9udGggLSBhIG1vbnRoLCAxLTEyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmouZGF5IC0gYSBkYXkgb2YgdGhlIG1vbnRoLCAxLTMxLCBkZXBlbmRpbmcgb24gdGhlIG1vbnRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoub3JkaW5hbCAtIGRheSBvZiB0aGUgeWVhciwgMS0zNjUgb3IgMzY2XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoud2Vla1llYXIgLSBhbiBJU08gd2VlayB5ZWFyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoud2Vla051bWJlciAtIGFuIElTTyB3ZWVrIG51bWJlciwgYmV0d2VlbiAxIGFuZCA1MiBvciA1MywgZGVwZW5kaW5nIG9uIHRoZSB5ZWFyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoud2Vla2RheSAtIGFuIElTTyB3ZWVrZGF5LCAxLTcsIHdoZXJlIDEgaXMgTW9uZGF5IGFuZCA3IGlzIFN1bmRheVxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLmhvdXIgLSBob3VyIG9mIHRoZSBkYXksIDAtMjNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5taW51dGUgLSBtaW51dGUgb2YgdGhlIGhvdXIsIDAtNTlcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5zZWNvbmQgLSBzZWNvbmQgb2YgdGhlIG1pbnV0ZSwgMC01OVxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLm1pbGxpc2Vjb25kIC0gbWlsbGlzZWNvbmQgb2YgdGhlIHNlY29uZCwgMC05OTlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIGZvciBjcmVhdGluZyB0aGlzIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFtvcHRzLnpvbmU9J2xvY2FsJ10gLSBpbnRlcnByZXQgdGhlIG51bWJlcnMgaW4gdGhlIGNvbnRleHQgb2YgYSBwYXJ0aWN1bGFyIHpvbmUuIENhbiB0YWtlIGFueSB2YWx1ZSB0YWtlbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gc2V0Wm9uZSgpXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J3N5c3RlbSdzIGxvY2FsZSddIC0gYSBsb2NhbGUgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMub3V0cHV0Q2FsZW5kYXIgLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyB5ZWFyOiAxOTgyLCBtb250aDogNSwgZGF5OiAyNX0pLnRvSVNPRGF0ZSgpIC8vPT4gJzE5ODItMDUtMjUnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyB5ZWFyOiAxOTgyIH0pLnRvSVNPRGF0ZSgpIC8vPT4gJzE5ODItMDEtMDEnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyBob3VyOiAxMCwgbWludXRlOiAyNiwgc2Vjb25kOiA2IH0pIC8vfj4gdG9kYXkgYXQgMTA6MjY6MDZcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbU9iamVjdCh7IGhvdXI6IDEwLCBtaW51dGU6IDI2LCBzZWNvbmQ6IDYgfSwgeyB6b25lOiAndXRjJyB9KSxcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbU9iamVjdCh7IGhvdXI6IDEwLCBtaW51dGU6IDI2LCBzZWNvbmQ6IDYgfSwgeyB6b25lOiAnbG9jYWwnIH0pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyBob3VyOiAxMCwgbWludXRlOiAyNiwgc2Vjb25kOiA2IH0sIHsgem9uZTogJ0FtZXJpY2EvTmV3X1lvcmsnIH0pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyB3ZWVrWWVhcjogMjAxNiwgd2Vla051bWJlcjogMiwgd2Vla2RheTogMyB9KS50b0lTT0RhdGUoKSAvLz0+ICcyMDE2LTAxLTEzJ1xuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tT2JqZWN0KG9iaiwgb3B0cyA9IHt9KSB7XG4gICAgb2JqID0gb2JqIHx8IHt9O1xuICAgIGNvbnN0IHpvbmVUb1VzZSA9IG5vcm1hbGl6ZVpvbmUob3B0cy56b25lLCBTZXR0aW5ncy5kZWZhdWx0Wm9uZSk7XG4gICAgaWYgKCF6b25lVG9Vc2UuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQodW5zdXBwb3J0ZWRab25lKHpvbmVUb1VzZSkpO1xuICAgIH1cblxuICAgIGNvbnN0IHRzTm93ID0gU2V0dGluZ3Mubm93KCksXG4gICAgICBvZmZzZXRQcm92aXMgPSAhaXNVbmRlZmluZWQob3B0cy5zcGVjaWZpY09mZnNldClcbiAgICAgICAgPyBvcHRzLnNwZWNpZmljT2Zmc2V0XG4gICAgICAgIDogem9uZVRvVXNlLm9mZnNldCh0c05vdyksXG4gICAgICBub3JtYWxpemVkID0gbm9ybWFsaXplT2JqZWN0KG9iaiwgbm9ybWFsaXplVW5pdCksXG4gICAgICBjb250YWluc09yZGluYWwgPSAhaXNVbmRlZmluZWQobm9ybWFsaXplZC5vcmRpbmFsKSxcbiAgICAgIGNvbnRhaW5zR3JlZ29yWWVhciA9ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLnllYXIpLFxuICAgICAgY29udGFpbnNHcmVnb3JNRCA9ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLm1vbnRoKSB8fCAhaXNVbmRlZmluZWQobm9ybWFsaXplZC5kYXkpLFxuICAgICAgY29udGFpbnNHcmVnb3IgPSBjb250YWluc0dyZWdvclllYXIgfHwgY29udGFpbnNHcmVnb3JNRCxcbiAgICAgIGRlZmluaXRlV2Vla0RlZiA9IG5vcm1hbGl6ZWQud2Vla1llYXIgfHwgbm9ybWFsaXplZC53ZWVrTnVtYmVyLFxuICAgICAgbG9jID0gTG9jYWxlLmZyb21PYmplY3Qob3B0cyk7XG5cbiAgICAvLyBjYXNlczpcbiAgICAvLyBqdXN0IGEgd2Vla2RheSAtPiB0aGlzIHdlZWsncyBpbnN0YW5jZSBvZiB0aGF0IHdlZWtkYXksIG5vIHdvcnJpZXNcbiAgICAvLyAoZ3JlZ29yaWFuIGRhdGEgb3Igb3JkaW5hbCkgKyAod2Vla1llYXIgb3Igd2Vla051bWJlcikgLT4gZXJyb3JcbiAgICAvLyAoZ3JlZ29yaWFuIG1vbnRoIG9yIGRheSkgKyBvcmRpbmFsIC0+IGVycm9yXG4gICAgLy8gb3RoZXJ3aXNlIGp1c3QgdXNlIHdlZWtzIG9yIG9yZGluYWxzIG9yIGdyZWdvcmlhbiwgZGVwZW5kaW5nIG9uIHdoYXQncyBzcGVjaWZpZWRcblxuICAgIGlmICgoY29udGFpbnNHcmVnb3IgfHwgY29udGFpbnNPcmRpbmFsKSAmJiBkZWZpbml0ZVdlZWtEZWYpIHtcbiAgICAgIHRocm93IG5ldyBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvcihcbiAgICAgICAgXCJDYW4ndCBtaXggd2Vla1llYXIvd2Vla051bWJlciB1bml0cyB3aXRoIHllYXIvbW9udGgvZGF5IG9yIG9yZGluYWxzXCJcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRhaW5zR3JlZ29yTUQgJiYgY29udGFpbnNPcmRpbmFsKSB7XG4gICAgICB0aHJvdyBuZXcgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IoXCJDYW4ndCBtaXggb3JkaW5hbCBkYXRlcyB3aXRoIG1vbnRoL2RheVwiKTtcbiAgICB9XG5cbiAgICBjb25zdCB1c2VXZWVrRGF0YSA9IGRlZmluaXRlV2Vla0RlZiB8fCAobm9ybWFsaXplZC53ZWVrZGF5ICYmICFjb250YWluc0dyZWdvcik7XG5cbiAgICAvLyBjb25maWd1cmUgb3Vyc2VsdmVzIHRvIGRlYWwgd2l0aCBncmVnb3JpYW4gZGF0ZXMgb3Igd2VlayBzdHVmZlxuICAgIGxldCB1bml0cyxcbiAgICAgIGRlZmF1bHRWYWx1ZXMsXG4gICAgICBvYmpOb3cgPSB0c1RvT2JqKHRzTm93LCBvZmZzZXRQcm92aXMpO1xuICAgIGlmICh1c2VXZWVrRGF0YSkge1xuICAgICAgdW5pdHMgPSBvcmRlcmVkV2Vla1VuaXRzO1xuICAgICAgZGVmYXVsdFZhbHVlcyA9IGRlZmF1bHRXZWVrVW5pdFZhbHVlcztcbiAgICAgIG9iak5vdyA9IGdyZWdvcmlhblRvV2VlayhvYmpOb3cpO1xuICAgIH0gZWxzZSBpZiAoY29udGFpbnNPcmRpbmFsKSB7XG4gICAgICB1bml0cyA9IG9yZGVyZWRPcmRpbmFsVW5pdHM7XG4gICAgICBkZWZhdWx0VmFsdWVzID0gZGVmYXVsdE9yZGluYWxVbml0VmFsdWVzO1xuICAgICAgb2JqTm93ID0gZ3JlZ29yaWFuVG9PcmRpbmFsKG9iak5vdyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVuaXRzID0gb3JkZXJlZFVuaXRzO1xuICAgICAgZGVmYXVsdFZhbHVlcyA9IGRlZmF1bHRVbml0VmFsdWVzO1xuICAgIH1cblxuICAgIC8vIHNldCBkZWZhdWx0IHZhbHVlcyBmb3IgbWlzc2luZyBzdHVmZlxuICAgIGxldCBmb3VuZEZpcnN0ID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCB1IG9mIHVuaXRzKSB7XG4gICAgICBjb25zdCB2ID0gbm9ybWFsaXplZFt1XTtcbiAgICAgIGlmICghaXNVbmRlZmluZWQodikpIHtcbiAgICAgICAgZm91bmRGaXJzdCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGZvdW5kRmlyc3QpIHtcbiAgICAgICAgbm9ybWFsaXplZFt1XSA9IGRlZmF1bHRWYWx1ZXNbdV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub3JtYWxpemVkW3VdID0gb2JqTm93W3VdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG1ha2Ugc3VyZSB0aGUgdmFsdWVzIHdlIGhhdmUgYXJlIGluIHJhbmdlXG4gICAgY29uc3QgaGlnaGVyT3JkZXJJbnZhbGlkID0gdXNlV2Vla0RhdGFcbiAgICAgICAgPyBoYXNJbnZhbGlkV2Vla0RhdGEobm9ybWFsaXplZClcbiAgICAgICAgOiBjb250YWluc09yZGluYWxcbiAgICAgICAgPyBoYXNJbnZhbGlkT3JkaW5hbERhdGEobm9ybWFsaXplZClcbiAgICAgICAgOiBoYXNJbnZhbGlkR3JlZ29yaWFuRGF0YShub3JtYWxpemVkKSxcbiAgICAgIGludmFsaWQgPSBoaWdoZXJPcmRlckludmFsaWQgfHwgaGFzSW52YWxpZFRpbWVEYXRhKG5vcm1hbGl6ZWQpO1xuXG4gICAgaWYgKGludmFsaWQpIHtcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKGludmFsaWQpO1xuICAgIH1cblxuICAgIC8vIGNvbXB1dGUgdGhlIGFjdHVhbCB0aW1lXG4gICAgY29uc3QgZ3JlZ29yaWFuID0gdXNlV2Vla0RhdGFcbiAgICAgICAgPyB3ZWVrVG9HcmVnb3JpYW4obm9ybWFsaXplZClcbiAgICAgICAgOiBjb250YWluc09yZGluYWxcbiAgICAgICAgPyBvcmRpbmFsVG9HcmVnb3JpYW4obm9ybWFsaXplZClcbiAgICAgICAgOiBub3JtYWxpemVkLFxuICAgICAgW3RzRmluYWwsIG9mZnNldEZpbmFsXSA9IG9ialRvVFMoZ3JlZ29yaWFuLCBvZmZzZXRQcm92aXMsIHpvbmVUb1VzZSksXG4gICAgICBpbnN0ID0gbmV3IERhdGVUaW1lKHtcbiAgICAgICAgdHM6IHRzRmluYWwsXG4gICAgICAgIHpvbmU6IHpvbmVUb1VzZSxcbiAgICAgICAgbzogb2Zmc2V0RmluYWwsXG4gICAgICAgIGxvYyxcbiAgICAgIH0pO1xuXG4gICAgLy8gZ3JlZ29yaWFuIGRhdGEgKyB3ZWVrZGF5IHNlcnZlcyBvbmx5IHRvIHZhbGlkYXRlXG4gICAgaWYgKG5vcm1hbGl6ZWQud2Vla2RheSAmJiBjb250YWluc0dyZWdvciAmJiBvYmoud2Vla2RheSAhPT0gaW5zdC53ZWVrZGF5KSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChcbiAgICAgICAgXCJtaXNtYXRjaGVkIHdlZWtkYXlcIixcbiAgICAgICAgYHlvdSBjYW4ndCBzcGVjaWZ5IGJvdGggYSB3ZWVrZGF5IG9mICR7bm9ybWFsaXplZC53ZWVrZGF5fSBhbmQgYSBkYXRlIG9mICR7aW5zdC50b0lTTygpfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3Q7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhbiBJU08gODYwMSBzdHJpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0aGUgSVNPIHN0cmluZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdG8gYWZmZWN0IHRoZSBjcmVhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0cy56b25lPSdsb2NhbCddIC0gdXNlIHRoaXMgem9uZSBpZiBubyBvZmZzZXQgaXMgc3BlY2lmaWVkIGluIHRoZSBpbnB1dCBzdHJpbmcgaXRzZWxmLiBXaWxsIGFsc28gY29udmVydCB0aGUgdGltZSB0byB0aGlzIHpvbmVcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zZXRab25lPWZhbHNlXSAtIG92ZXJyaWRlIHRoZSB6b25lIHdpdGggYSBmaXhlZC1vZmZzZXQgem9uZSBzcGVjaWZpZWQgaW4gdGhlIHN0cmluZyBpdHNlbGYsIGlmIGl0IHNwZWNpZmllcyBvbmVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nc3lzdGVtJ3MgbG9jYWxlJ10gLSBhIGxvY2FsZSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMub3V0cHV0Q2FsZW5kYXJdIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubnVtYmVyaW5nU3lzdGVtXSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21JU08oJzIwMTYtMDUtMjVUMDk6MDg6MzQuMTIzJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUlTTygnMjAxNi0wNS0yNVQwOTowODozNC4xMjMrMDY6MDAnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSVNPKCcyMDE2LTA1LTI1VDA5OjA4OjM0LjEyMyswNjowMCcsIHtzZXRab25lOiB0cnVlfSlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUlTTygnMjAxNi0wNS0yNVQwOTowODozNC4xMjMnLCB7em9uZTogJ3V0Yyd9KVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSVNPKCcyMDE2LVcwNS00JylcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbUlTTyh0ZXh0LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBbdmFscywgcGFyc2VkWm9uZV0gPSBwYXJzZUlTT0RhdGUodGV4dCk7XG4gICAgcmV0dXJuIHBhcnNlRGF0YVRvRGF0ZVRpbWUodmFscywgcGFyc2VkWm9uZSwgb3B0cywgXCJJU08gODYwMVwiLCB0ZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGFuIFJGQyAyODIyIHN0cmluZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSBSRkMgMjgyMiBzdHJpbmdcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRvIGFmZmVjdCB0aGUgY3JlYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdHMuem9uZT0nbG9jYWwnXSAtIGNvbnZlcnQgdGhlIHRpbWUgdG8gdGhpcyB6b25lLiBTaW5jZSB0aGUgb2Zmc2V0IGlzIGFsd2F5cyBzcGVjaWZpZWQgaW4gdGhlIHN0cmluZyBpdHNlbGYsIHRoaXMgaGFzIG5vIGVmZmVjdCBvbiB0aGUgaW50ZXJwcmV0YXRpb24gb2Ygc3RyaW5nLCBtZXJlbHkgdGhlIHpvbmUgdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpcyBleHByZXNzZWQgaW4uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc2V0Wm9uZT1mYWxzZV0gLSBvdmVycmlkZSB0aGUgem9uZSB3aXRoIGEgZml4ZWQtb2Zmc2V0IHpvbmUgc3BlY2lmaWVkIGluIHRoZSBzdHJpbmcgaXRzZWxmLCBpZiBpdCBzcGVjaWZpZXMgb25lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J3N5c3RlbSdzIGxvY2FsZSddIC0gYSBsb2NhbGUgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMub3V0cHV0Q2FsZW5kYXIgLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21SRkMyODIyKCcyNSBOb3YgMjAxNiAxMzoyMzoxMiBHTVQnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tUkZDMjgyMignRnJpLCAyNSBOb3YgMjAxNiAxMzoyMzoxMiArMDYwMCcpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21SRkMyODIyKCcyNSBOb3YgMjAxNiAxMzoyMyBaJylcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbVJGQzI4MjIodGV4dCwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgW3ZhbHMsIHBhcnNlZFpvbmVdID0gcGFyc2VSRkMyODIyRGF0ZSh0ZXh0KTtcbiAgICByZXR1cm4gcGFyc2VEYXRhVG9EYXRlVGltZSh2YWxzLCBwYXJzZWRab25lLCBvcHRzLCBcIlJGQyAyODIyXCIsIHRleHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYW4gSFRUUCBoZWFkZXIgZGF0ZVxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9Qcm90b2NvbHMvcmZjMjYxNi9yZmMyNjE2LXNlYzMuaHRtbCNzZWMzLjMuMVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSBIVFRQIGhlYWRlciBkYXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0byBhZmZlY3QgdGhlIGNyZWF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFtvcHRzLnpvbmU9J2xvY2FsJ10gLSBjb252ZXJ0IHRoZSB0aW1lIHRvIHRoaXMgem9uZS4gU2luY2UgSFRUUCBkYXRlcyBhcmUgYWx3YXlzIGluIFVUQywgdGhpcyBoYXMgbm8gZWZmZWN0IG9uIHRoZSBpbnRlcnByZXRhdGlvbiBvZiBzdHJpbmcsIG1lcmVseSB0aGUgem9uZSB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGlzIGV4cHJlc3NlZCBpbi5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zZXRab25lPWZhbHNlXSAtIG92ZXJyaWRlIHRoZSB6b25lIHdpdGggdGhlIGZpeGVkLW9mZnNldCB6b25lIHNwZWNpZmllZCBpbiB0aGUgc3RyaW5nLiBGb3IgSFRUUCBkYXRlcywgdGhpcyBpcyBhbHdheXMgVVRDLCBzbyB0aGlzIG9wdGlvbiBpcyBlcXVpdmFsZW50IHRvIHNldHRpbmcgdGhlIGB6b25lYCBvcHRpb24gdG8gJ3V0YycsIGJ1dCB0aGlzIG9wdGlvbiBpcyBpbmNsdWRlZCBmb3IgY29uc2lzdGVuY3kgd2l0aCBzaW1pbGFyIG1ldGhvZHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J3N5c3RlbSdzIGxvY2FsZSddIC0gYSBsb2NhbGUgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMub3V0cHV0Q2FsZW5kYXIgLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21IVFRQKCdTdW4sIDA2IE5vdiAxOTk0IDA4OjQ5OjM3IEdNVCcpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21IVFRQKCdTdW5kYXksIDA2LU5vdi05NCAwODo0OTozNyBHTVQnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSFRUUCgnU3VuIE5vdiAgNiAwODo0OTozNyAxOTk0JylcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbUhUVFAodGV4dCwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgW3ZhbHMsIHBhcnNlZFpvbmVdID0gcGFyc2VIVFRQRGF0ZSh0ZXh0KTtcbiAgICByZXR1cm4gcGFyc2VEYXRhVG9EYXRlVGltZSh2YWxzLCBwYXJzZWRab25lLCBvcHRzLCBcIkhUVFBcIiwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhbiBpbnB1dCBzdHJpbmcgYW5kIGZvcm1hdCBzdHJpbmcuXG4gICAqIERlZmF1bHRzIHRvIGVuLVVTIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWQsIHJlZ2FyZGxlc3Mgb2YgdGhlIHN5c3RlbSdzIGxvY2FsZS4gRm9yIGEgdGFibGUgb2YgdG9rZW5zIGFuZCB0aGVpciBpbnRlcnByZXRhdGlvbnMsIHNlZSBbaGVyZV0oaHR0cHM6Ly9tb21lbnQuZ2l0aHViLmlvL2x1eG9uLyMvcGFyc2luZz9pZD10YWJsZS1vZi10b2tlbnMpLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZtdCAtIHRoZSBmb3JtYXQgdGhlIHN0cmluZyBpcyBleHBlY3RlZCB0byBiZSBpbiAoc2VlIHRoZSBsaW5rIGJlbG93IGZvciB0aGUgZm9ybWF0cylcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRvIGFmZmVjdCB0aGUgY3JlYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdHMuem9uZT0nbG9jYWwnXSAtIHVzZSB0aGlzIHpvbmUgaWYgbm8gb2Zmc2V0IGlzIHNwZWNpZmllZCBpbiB0aGUgaW5wdXQgc3RyaW5nIGl0c2VsZi4gV2lsbCBhbHNvIGNvbnZlcnQgdGhlIERhdGVUaW1lIHRvIHRoaXMgem9uZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnNldFpvbmU9ZmFsc2VdIC0gb3ZlcnJpZGUgdGhlIHpvbmUgd2l0aCBhIHpvbmUgc3BlY2lmaWVkIGluIHRoZSBzdHJpbmcgaXRzZWxmLCBpZiBpdCBzcGVjaWZpZXMgb25lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J2VuLVVTJ10gLSBhIGxvY2FsZSBzdHJpbmcgdG8gdXNlIHdoZW4gcGFyc2luZy4gV2lsbCBhbHNvIHNldCB0aGUgRGF0ZVRpbWUgdG8gdGhpcyBsb2NhbGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gdXNlIHdoZW4gcGFyc2luZy4gV2lsbCBhbHNvIHNldCB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIHRvIHRoaXMgbnVtYmVyaW5nIHN5c3RlbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5vdXRwdXRDYWxlbmRhciAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbUZvcm1hdCh0ZXh0LCBmbXQsIG9wdHMgPSB7fSkge1xuICAgIGlmIChpc1VuZGVmaW5lZCh0ZXh0KSB8fCBpc1VuZGVmaW5lZChmbXQpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJmcm9tRm9ybWF0IHJlcXVpcmVzIGFuIGlucHV0IHN0cmluZyBhbmQgYSBmb3JtYXRcIik7XG4gICAgfVxuXG4gICAgY29uc3QgeyBsb2NhbGUgPSBudWxsLCBudW1iZXJpbmdTeXN0ZW0gPSBudWxsIH0gPSBvcHRzLFxuICAgICAgbG9jYWxlVG9Vc2UgPSBMb2NhbGUuZnJvbU9wdHMoe1xuICAgICAgICBsb2NhbGUsXG4gICAgICAgIG51bWJlcmluZ1N5c3RlbSxcbiAgICAgICAgZGVmYXVsdFRvRU46IHRydWUsXG4gICAgICB9KSxcbiAgICAgIFt2YWxzLCBwYXJzZWRab25lLCBzcGVjaWZpY09mZnNldCwgaW52YWxpZF0gPSBwYXJzZUZyb21Ub2tlbnMobG9jYWxlVG9Vc2UsIHRleHQsIGZtdCk7XG4gICAgaWYgKGludmFsaWQpIHtcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKGludmFsaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcGFyc2VEYXRhVG9EYXRlVGltZSh2YWxzLCBwYXJzZWRab25lLCBvcHRzLCBgZm9ybWF0ICR7Zm10fWAsIHRleHQsIHNwZWNpZmljT2Zmc2V0KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGZyb21Gb3JtYXQgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGZyb21TdHJpbmcodGV4dCwgZm10LCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gRGF0ZVRpbWUuZnJvbUZvcm1hdCh0ZXh0LCBmbXQsIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYSBTUUwgZGF0ZSwgdGltZSwgb3IgZGF0ZXRpbWVcbiAgICogRGVmYXVsdHMgdG8gZW4tVVMgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZCwgcmVnYXJkbGVzcyBvZiB0aGUgc3lzdGVtJ3MgbG9jYWxlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGhlIHN0cmluZyB0byBwYXJzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdG8gYWZmZWN0IHRoZSBjcmVhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0cy56b25lPSdsb2NhbCddIC0gdXNlIHRoaXMgem9uZSBpZiBubyBvZmZzZXQgaXMgc3BlY2lmaWVkIGluIHRoZSBpbnB1dCBzdHJpbmcgaXRzZWxmLiBXaWxsIGFsc28gY29udmVydCB0aGUgRGF0ZVRpbWUgdG8gdGhpcyB6b25lXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc2V0Wm9uZT1mYWxzZV0gLSBvdmVycmlkZSB0aGUgem9uZSB3aXRoIGEgem9uZSBzcGVjaWZpZWQgaW4gdGhlIHN0cmluZyBpdHNlbGYsIGlmIGl0IHNwZWNpZmllcyBvbmVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nZW4tVVMnXSAtIGEgbG9jYWxlIHN0cmluZyB0byB1c2Ugd2hlbiBwYXJzaW5nLiBXaWxsIGFsc28gc2V0IHRoZSBEYXRlVGltZSB0byB0aGlzIGxvY2FsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byB1c2Ugd2hlbiBwYXJzaW5nLiBXaWxsIGFsc28gc2V0IHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgdG8gdGhpcyBudW1iZXJpbmcgc3lzdGVtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm91dHB1dENhbGVuZGFyIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcyMDE3LTA1LTE1JylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMjAxNy0wNS0xNSAwOToxMjozNCcpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzIwMTctMDUtMTUgMDk6MTI6MzQuMzQyJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMjAxNy0wNS0xNSAwOToxMjozNC4zNDIrMDY6MDAnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcyMDE3LTA1LTE1IDA5OjEyOjM0LjM0MiBBbWVyaWNhL0xvc19BbmdlbGVzJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMjAxNy0wNS0xNSAwOToxMjozNC4zNDIgQW1lcmljYS9Mb3NfQW5nZWxlcycsIHsgc2V0Wm9uZTogdHJ1ZSB9KVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcyMDE3LTA1LTE1IDA5OjEyOjM0LjM0MicsIHsgem9uZTogJ0FtZXJpY2EvTG9zX0FuZ2VsZXMnIH0pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzA5OjEyOjM0LjM0MicpXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21TUUwodGV4dCwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgW3ZhbHMsIHBhcnNlZFpvbmVdID0gcGFyc2VTUUwodGV4dCk7XG4gICAgcmV0dXJuIHBhcnNlRGF0YVRvRGF0ZVRpbWUodmFscywgcGFyc2VkWm9uZSwgb3B0cywgXCJTUUxcIiwgdGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGludmFsaWQgRGF0ZVRpbWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb24gLSBzaW1wbGUgc3RyaW5nIG9mIHdoeSB0aGlzIERhdGVUaW1lIGlzIGludmFsaWQuIFNob3VsZCBub3QgY29udGFpbiBwYXJhbWV0ZXJzIG9yIGFueXRoaW5nIGVsc2UgZGF0YS1kZXBlbmRlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZXhwbGFuYXRpb249bnVsbF0gLSBsb25nZXIgZXhwbGFuYXRpb24sIG1heSBpbmNsdWRlIHBhcmFtZXRlcnMgYW5kIG90aGVyIHVzZWZ1bCBkZWJ1Z2dpbmcgaW5mb3JtYXRpb25cbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgaW52YWxpZChyZWFzb24sIGV4cGxhbmF0aW9uID0gbnVsbCkge1xuICAgIGlmICghcmVhc29uKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJuZWVkIHRvIHNwZWNpZnkgYSByZWFzb24gdGhlIERhdGVUaW1lIGlzIGludmFsaWRcIik7XG4gICAgfVxuXG4gICAgY29uc3QgaW52YWxpZCA9IHJlYXNvbiBpbnN0YW5jZW9mIEludmFsaWQgPyByZWFzb24gOiBuZXcgSW52YWxpZChyZWFzb24sIGV4cGxhbmF0aW9uKTtcblxuICAgIGlmIChTZXR0aW5ncy50aHJvd09uSW52YWxpZCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWREYXRlVGltZUVycm9yKGludmFsaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IERhdGVUaW1lKHsgaW52YWxpZCB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gb2JqZWN0IGlzIGFuIGluc3RhbmNlIG9mIERhdGVUaW1lLiBXb3JrcyBhY3Jvc3MgY29udGV4dCBib3VuZGFyaWVzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNEYXRlVGltZShvKSB7XG4gICAgcmV0dXJuIChvICYmIG8uaXNMdXhvbkRhdGVUaW1lKSB8fCBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9kdWNlIHRoZSBmb3JtYXQgc3RyaW5nIGZvciBhIHNldCBvZiBvcHRpb25zXG4gICAqIEBwYXJhbSBmb3JtYXRPcHRzXG4gICAqIEBwYXJhbSBsb2NhbGVPcHRzXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgcGFyc2VGb3JtYXRGb3JPcHRzKGZvcm1hdE9wdHMsIGxvY2FsZU9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHRva2VuTGlzdCA9IGZvcm1hdE9wdHNUb1Rva2Vucyhmb3JtYXRPcHRzLCBMb2NhbGUuZnJvbU9iamVjdChsb2NhbGVPcHRzKSk7XG4gICAgcmV0dXJuICF0b2tlbkxpc3QgPyBudWxsIDogdG9rZW5MaXN0Lm1hcCgodCkgPT4gKHQgPyB0LnZhbCA6IG51bGwpKS5qb2luKFwiXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2R1Y2UgdGhlIHRoZSBmdWxseSBleHBhbmRlZCBmb3JtYXQgdG9rZW4gZm9yIHRoZSBsb2NhbGVcbiAgICogRG9lcyBOT1QgcXVvdGUgY2hhcmFjdGVycywgc28gcXVvdGVkIHRva2VucyB3aWxsIG5vdCByb3VuZCB0cmlwIGNvcnJlY3RseVxuICAgKiBAcGFyYW0gZm10XG4gICAqIEBwYXJhbSBsb2NhbGVPcHRzXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZXhwYW5kRm9ybWF0KGZtdCwgbG9jYWxlT3B0cyA9IHt9KSB7XG4gICAgY29uc3QgZXhwYW5kZWQgPSBleHBhbmRNYWNyb1Rva2VucyhGb3JtYXR0ZXIucGFyc2VGb3JtYXQoZm10KSwgTG9jYWxlLmZyb21PYmplY3QobG9jYWxlT3B0cykpO1xuICAgIHJldHVybiBleHBhbmRlZC5tYXAoKHQpID0+IHQudmFsKS5qb2luKFwiXCIpO1xuICB9XG5cbiAgLy8gSU5GT1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbHVlIG9mIHVuaXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1bml0IC0gYSB1bml0IHN1Y2ggYXMgJ21pbnV0ZScgb3IgJ2RheSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNywgNCkuZ2V0KCdtb250aCcpOyAvLz0+IDdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNywgNCkuZ2V0KCdkYXknKTsgLy89PiA0XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldCh1bml0KSB7XG4gICAgcmV0dXJuIHRoaXNbdW5pdF07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBEYXRlVGltZSBpcyB2YWxpZC4gSW52YWxpZCBEYXRlVGltZXMgb2NjdXIgd2hlbjpcbiAgICogKiBUaGUgRGF0ZVRpbWUgd2FzIGNyZWF0ZWQgZnJvbSBpbnZhbGlkIGNhbGVuZGFyIGluZm9ybWF0aW9uLCBzdWNoIGFzIHRoZSAxM3RoIG1vbnRoIG9yIEZlYnJ1YXJ5IDMwXG4gICAqICogVGhlIERhdGVUaW1lIHdhcyBjcmVhdGVkIGJ5IGFuIG9wZXJhdGlvbiBvbiBhbm90aGVyIGludmFsaWQgZGF0ZVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiB0aGlzLmludmFsaWQgPT09IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBlcnJvciBjb2RlIGlmIHRoaXMgRGF0ZVRpbWUgaXMgaW52YWxpZCwgb3IgbnVsbCBpZiB0aGUgRGF0ZVRpbWUgaXMgdmFsaWRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBpbnZhbGlkUmVhc29uKCkge1xuICAgIHJldHVybiB0aGlzLmludmFsaWQgPyB0aGlzLmludmFsaWQucmVhc29uIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGV4cGxhbmF0aW9uIG9mIHdoeSB0aGlzIERhdGVUaW1lIGJlY2FtZSBpbnZhbGlkLCBvciBudWxsIGlmIHRoZSBEYXRlVGltZSBpcyB2YWxpZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGludmFsaWRFeHBsYW5hdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZhbGlkID8gdGhpcy5pbnZhbGlkLmV4cGxhbmF0aW9uIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxvY2FsZSBvZiBhIERhdGVUaW1lLCBzdWNoICdlbi1HQicuIFRoZSBsb2NhbGUgaXMgdXNlZCB3aGVuIGZvcm1hdHRpbmcgdGhlIERhdGVUaW1lXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgbG9jYWxlKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmxvYy5sb2NhbGUgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbnVtYmVyaW5nIHN5c3RlbSBvZiBhIERhdGVUaW1lLCBzdWNoICdiZW5nJy4gVGhlIG51bWJlcmluZyBzeXN0ZW0gaXMgdXNlZCB3aGVuIGZvcm1hdHRpbmcgdGhlIERhdGVUaW1lXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgbnVtYmVyaW5nU3lzdGVtKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmxvYy5udW1iZXJpbmdTeXN0ZW0gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgb3V0cHV0IGNhbGVuZGFyIG9mIGEgRGF0ZVRpbWUsIHN1Y2ggJ2lzbGFtaWMnLiBUaGUgb3V0cHV0IGNhbGVuZGFyIGlzIHVzZWQgd2hlbiBmb3JtYXR0aW5nIHRoZSBEYXRlVGltZVxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG91dHB1dENhbGVuZGFyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmxvYy5vdXRwdXRDYWxlbmRhciA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0aW1lIHpvbmUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgRGF0ZVRpbWUuXG4gICAqIEB0eXBlIHtab25lfVxuICAgKi9cbiAgZ2V0IHpvbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3pvbmU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBuYW1lIG9mIHRoZSB0aW1lIHpvbmUuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgem9uZU5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuem9uZS5uYW1lIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHllYXJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLnllYXIgLy89PiAyMDE3XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgeWVhcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5jLnllYXIgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBxdWFydGVyXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS5xdWFydGVyIC8vPT4gMlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHF1YXJ0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IE1hdGguY2VpbCh0aGlzLmMubW9udGggLyAzKSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1vbnRoICgxLTEyKS5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLm1vbnRoIC8vPT4gNVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1vbnRoKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmMubW9udGggOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkYXkgb2YgdGhlIG1vbnRoICgxLTMwaXNoKS5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLmRheSAvLz0+IDI1XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgZGF5KCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmMuZGF5IDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaG91ciBvZiB0aGUgZGF5ICgwLTIzKS5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUsIDkpLmhvdXIgLy89PiA5XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgaG91cigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5jLmhvdXIgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtaW51dGUgb2YgdGhlIGhvdXIgKDAtNTkpLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSwgOSwgMzApLm1pbnV0ZSAvLz0+IDMwXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbWludXRlKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmMubWludXRlIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2Vjb25kIG9mIHRoZSBtaW51dGUgKDAtNTkpLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSwgOSwgMzAsIDUyKS5zZWNvbmQgLy89PiA1MlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHNlY29uZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5jLnNlY29uZCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1pbGxpc2Vjb25kIG9mIHRoZSBzZWNvbmQgKDAtOTk5KS5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUsIDksIDMwLCA1MiwgNjU0KS5taWxsaXNlY29uZCAvLz0+IDY1NFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1pbGxpc2Vjb25kKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmMubWlsbGlzZWNvbmQgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB3ZWVrIHllYXJcbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDEyLCAzMSkud2Vla1llYXIgLy89PiAyMDE1XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgd2Vla1llYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHBvc3NpYmx5Q2FjaGVkV2Vla0RhdGEodGhpcykud2Vla1llYXIgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB3ZWVrIG51bWJlciBvZiB0aGUgd2VlayB5ZWFyICgxLTUyaXNoKS5cbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS53ZWVrTnVtYmVyIC8vPT4gMjFcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB3ZWVrTnVtYmVyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBwb3NzaWJseUNhY2hlZFdlZWtEYXRhKHRoaXMpLndlZWtOdW1iZXIgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkYXkgb2YgdGhlIHdlZWsuXG4gICAqIDEgaXMgTW9uZGF5IGFuZCA3IGlzIFN1bmRheVxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMTEsIDMxKS53ZWVrZGF5IC8vPT4gNFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdlZWtkYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHBvc3NpYmx5Q2FjaGVkV2Vla0RhdGEodGhpcykud2Vla2RheSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG9yZGluYWwgKG1lYW5pbmcgdGhlIGRheSBvZiB0aGUgeWVhcilcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLm9yZGluYWwgLy89PiAxNDVcbiAgICogQHR5cGUge251bWJlcnxEYXRlVGltZX1cbiAgICovXG4gIGdldCBvcmRpbmFsKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBncmVnb3JpYW5Ub09yZGluYWwodGhpcy5jKS5vcmRpbmFsIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaHVtYW4gcmVhZGFibGUgc2hvcnQgbW9udGggbmFtZSwgc3VjaCBhcyAnT2N0Jy5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDEwLCAzMCkubW9udGhTaG9ydCAvLz0+IE9jdFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG1vbnRoU2hvcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IEluZm8ubW9udGhzKFwic2hvcnRcIiwgeyBsb2NPYmo6IHRoaXMubG9jIH0pW3RoaXMubW9udGggLSAxXSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBodW1hbiByZWFkYWJsZSBsb25nIG1vbnRoIG5hbWUsIHN1Y2ggYXMgJ09jdG9iZXInLlxuICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMTAsIDMwKS5tb250aExvbmcgLy89PiBPY3RvYmVyXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgbW9udGhMb25nKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBJbmZvLm1vbnRocyhcImxvbmdcIiwgeyBsb2NPYmo6IHRoaXMubG9jIH0pW3RoaXMubW9udGggLSAxXSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBodW1hbiByZWFkYWJsZSBzaG9ydCB3ZWVrZGF5LCBzdWNoIGFzICdNb24nLlxuICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMTAsIDMwKS53ZWVrZGF5U2hvcnQgLy89PiBNb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCB3ZWVrZGF5U2hvcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IEluZm8ud2Vla2RheXMoXCJzaG9ydFwiLCB7IGxvY09iajogdGhpcy5sb2MgfSlbdGhpcy53ZWVrZGF5IC0gMV0gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaHVtYW4gcmVhZGFibGUgbG9uZyB3ZWVrZGF5LCBzdWNoIGFzICdNb25kYXknLlxuICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMTAsIDMwKS53ZWVrZGF5TG9uZyAvLz0+IE1vbmRheVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IHdlZWtkYXlMb25nKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBJbmZvLndlZWtkYXlzKFwibG9uZ1wiLCB7IGxvY09iajogdGhpcy5sb2MgfSlbdGhpcy53ZWVrZGF5IC0gMV0gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgVVRDIG9mZnNldCBvZiB0aGlzIERhdGVUaW1lIGluIG1pbnV0ZXNcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkub2Zmc2V0IC8vPT4gLTI0MFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoKS5vZmZzZXQgLy89PiAwXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgb2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyArdGhpcy5vIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2hvcnQgaHVtYW4gbmFtZSBmb3IgdGhlIHpvbmUncyBjdXJyZW50IG9mZnNldCwgZm9yIGV4YW1wbGUgXCJFU1RcIiBvciBcIkVEVFwiLlxuICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBvZmZzZXROYW1lU2hvcnQoKSB7XG4gICAgaWYgKHRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIHRoaXMuem9uZS5vZmZzZXROYW1lKHRoaXMudHMsIHtcbiAgICAgICAgZm9ybWF0OiBcInNob3J0XCIsXG4gICAgICAgIGxvY2FsZTogdGhpcy5sb2NhbGUsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbG9uZyBodW1hbiBuYW1lIGZvciB0aGUgem9uZSdzIGN1cnJlbnQgb2Zmc2V0LCBmb3IgZXhhbXBsZSBcIkVhc3Rlcm4gU3RhbmRhcmQgVGltZVwiIG9yIFwiRWFzdGVybiBEYXlsaWdodCBUaW1lXCIuXG4gICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG9mZnNldE5hbWVMb25nKCkge1xuICAgIGlmICh0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnpvbmUub2Zmc2V0TmFtZSh0aGlzLnRzLCB7XG4gICAgICAgIGZvcm1hdDogXCJsb25nXCIsXG4gICAgICAgIGxvY2FsZTogdGhpcy5sb2NhbGUsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB3aGV0aGVyIHRoaXMgem9uZSdzIG9mZnNldCBldmVyIGNoYW5nZXMsIGFzIGluIGEgRFNULlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc09mZnNldEZpeGVkKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnpvbmUuaXNVbml2ZXJzYWwgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB3aGV0aGVyIHRoZSBEYXRlVGltZSBpcyBpbiBhIERTVC5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNJbkRTVCgpIHtcbiAgICBpZiAodGhpcy5pc09mZnNldEZpeGVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMub2Zmc2V0ID4gdGhpcy5zZXQoeyBtb250aDogMSwgZGF5OiAxIH0pLm9mZnNldCB8fFxuICAgICAgICB0aGlzLm9mZnNldCA+IHRoaXMuc2V0KHsgbW9udGg6IDUgfSkub2Zmc2V0XG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhvc2UgRGF0ZVRpbWVzIHdoaWNoIGhhdmUgdGhlIHNhbWUgbG9jYWwgdGltZSBhcyB0aGlzIERhdGVUaW1lLCBidXQgYSBkaWZmZXJlbnQgb2Zmc2V0IGZyb20gVVRDXG4gICAqIGluIHRoaXMgRGF0ZVRpbWUncyB6b25lLiBEdXJpbmcgRFNUIGNoYW5nZXMgbG9jYWwgdGltZSBjYW4gYmUgYW1iaWd1b3VzLCBmb3IgZXhhbXBsZVxuICAgKiBgMjAyMy0xMC0yOVQwMjozMDowMGAgaW4gYEV1cm9wZS9CZXJsaW5gIGNhbiBoYXZlIG9mZnNldCBgKzAxOjAwYCBvciBgKzAyOjAwYC5cbiAgICogVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gYm90aCBwb3NzaWJsZSBEYXRlVGltZXMgaWYgdGhpcyBEYXRlVGltZSdzIGxvY2FsIHRpbWUgaXMgYW1iaWd1b3VzLlxuICAgKiBAcmV0dXJucyB7RGF0ZVRpbWVbXX1cbiAgICovXG4gIGdldFBvc3NpYmxlT2Zmc2V0cygpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCB8fCB0aGlzLmlzT2Zmc2V0Rml4ZWQpIHtcbiAgICAgIHJldHVybiBbdGhpc107XG4gICAgfVxuICAgIGNvbnN0IGRheU1zID0gODY0MDAwMDA7XG4gICAgY29uc3QgbWludXRlTXMgPSA2MDAwMDtcbiAgICBjb25zdCBsb2NhbFRTID0gb2JqVG9Mb2NhbFRTKHRoaXMuYyk7XG4gICAgY29uc3Qgb0VhcmxpZXIgPSB0aGlzLnpvbmUub2Zmc2V0KGxvY2FsVFMgLSBkYXlNcyk7XG4gICAgY29uc3Qgb0xhdGVyID0gdGhpcy56b25lLm9mZnNldChsb2NhbFRTICsgZGF5TXMpO1xuXG4gICAgY29uc3QgbzEgPSB0aGlzLnpvbmUub2Zmc2V0KGxvY2FsVFMgLSBvRWFybGllciAqIG1pbnV0ZU1zKTtcbiAgICBjb25zdCBvMiA9IHRoaXMuem9uZS5vZmZzZXQobG9jYWxUUyAtIG9MYXRlciAqIG1pbnV0ZU1zKTtcbiAgICBpZiAobzEgPT09IG8yKSB7XG4gICAgICByZXR1cm4gW3RoaXNdO1xuICAgIH1cbiAgICBjb25zdCB0czEgPSBsb2NhbFRTIC0gbzEgKiBtaW51dGVNcztcbiAgICBjb25zdCB0czIgPSBsb2NhbFRTIC0gbzIgKiBtaW51dGVNcztcbiAgICBjb25zdCBjMSA9IHRzVG9PYmoodHMxLCBvMSk7XG4gICAgY29uc3QgYzIgPSB0c1RvT2JqKHRzMiwgbzIpO1xuICAgIGlmIChcbiAgICAgIGMxLmhvdXIgPT09IGMyLmhvdXIgJiZcbiAgICAgIGMxLm1pbnV0ZSA9PT0gYzIubWludXRlICYmXG4gICAgICBjMS5zZWNvbmQgPT09IGMyLnNlY29uZCAmJlxuICAgICAgYzEubWlsbGlzZWNvbmQgPT09IGMyLm1pbGxpc2Vjb25kXG4gICAgKSB7XG4gICAgICByZXR1cm4gW2Nsb25lKHRoaXMsIHsgdHM6IHRzMSB9KSwgY2xvbmUodGhpcywgeyB0czogdHMyIH0pXTtcbiAgICB9XG4gICAgcmV0dXJuIFt0aGlzXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBEYXRlVGltZSBpcyBpbiBhIGxlYXAgeWVhciwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTYpLmlzSW5MZWFwWWVhciAvLz0+IHRydWVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxMykuaXNJbkxlYXBZZWFyIC8vPT4gZmFsc2VcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNJbkxlYXBZZWFyKCkge1xuICAgIHJldHVybiBpc0xlYXBZZWFyKHRoaXMueWVhcik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGRheXMgaW4gdGhpcyBEYXRlVGltZSdzIG1vbnRoXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTYsIDIpLmRheXNJbk1vbnRoIC8vPT4gMjlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNiwgMykuZGF5c0luTW9udGggLy89PiAzMVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGRheXNJbk1vbnRoKCkge1xuICAgIHJldHVybiBkYXlzSW5Nb250aCh0aGlzLnllYXIsIHRoaXMubW9udGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBkYXlzIGluIHRoaXMgRGF0ZVRpbWUncyB5ZWFyXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTYpLmRheXNJblllYXIgLy89PiAzNjZcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxMykuZGF5c0luWWVhciAvLz0+IDM2NVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGRheXNJblllYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IGRheXNJblllYXIodGhpcy55ZWFyKSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygd2Vla3MgaW4gdGhpcyBEYXRlVGltZSdzIHllYXJcbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMDQpLndlZWtzSW5XZWVrWWVhciAvLz0+IDUzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTMpLndlZWtzSW5XZWVrWWVhciAvLz0+IDUyXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgd2Vla3NJbldlZWtZZWFyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB3ZWVrc0luV2Vla1llYXIodGhpcy53ZWVrWWVhcikgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVzb2x2ZWQgSW50bCBvcHRpb25zIGZvciB0aGlzIERhdGVUaW1lLlxuICAgKiBUaGlzIGlzIHVzZWZ1bCBpbiB1bmRlcnN0YW5kaW5nIHRoZSBiZWhhdmlvciBvZiBmb3JtYXR0aW5nIG1ldGhvZHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSB0aGUgc2FtZSBvcHRpb25zIGFzIHRvTG9jYWxlU3RyaW5nXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHJlc29sdmVkTG9jYWxlT3B0aW9ucyhvcHRzID0ge30pIHtcbiAgICBjb25zdCB7IGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBjYWxlbmRhciB9ID0gRm9ybWF0dGVyLmNyZWF0ZShcbiAgICAgIHRoaXMubG9jLmNsb25lKG9wdHMpLFxuICAgICAgb3B0c1xuICAgICkucmVzb2x2ZWRPcHRpb25zKHRoaXMpO1xuICAgIHJldHVybiB7IGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhcjogY2FsZW5kYXIgfTtcbiAgfVxuXG4gIC8vIFRSQU5TRk9STVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBEYXRlVGltZSdzIHpvbmUgdG8gVVRDLiBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRGF0ZVRpbWUuXG4gICAqXG4gICAqIEVxdWl2YWxlbnQgdG8ge0BsaW5rIERhdGVUaW1lI3NldFpvbmV9KCd1dGMnKVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29mZnNldD0wXSAtIG9wdGlvbmFsbHksIGFuIG9mZnNldCBmcm9tIFVUQyBpbiBtaW51dGVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cz17fV0gLSBvcHRpb25zIHRvIHBhc3MgdG8gYHNldFpvbmUoKWBcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICB0b1VUQyhvZmZzZXQgPSAwLCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5zZXRab25lKEZpeGVkT2Zmc2V0Wm9uZS5pbnN0YW5jZShvZmZzZXQpLCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBEYXRlVGltZSdzIHpvbmUgdG8gdGhlIGhvc3QncyBsb2NhbCB6b25lLiBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRGF0ZVRpbWUuXG4gICAqXG4gICAqIEVxdWl2YWxlbnQgdG8gYHNldFpvbmUoJ2xvY2FsJylgXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgdG9Mb2NhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRab25lKFNldHRpbmdzLmRlZmF1bHRab25lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBEYXRlVGltZSdzIHpvbmUgdG8gc3BlY2lmaWVkIHpvbmUuIFJldHVybnMgYSBuZXdseS1jb25zdHJ1Y3RlZCBEYXRlVGltZS5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdGhlIHNldHRlciBrZWVwcyB0aGUgdW5kZXJseWluZyB0aW1lIHRoZSBzYW1lIChhcyBpbiwgdGhlIHNhbWUgdGltZXN0YW1wKSwgYnV0IHRoZSBuZXcgaW5zdGFuY2Ugd2lsbCByZXBvcnQgZGlmZmVyZW50IGxvY2FsIHRpbWVzIGFuZCBjb25zaWRlciBEU1RzIHdoZW4gbWFraW5nIGNvbXB1dGF0aW9ucywgYXMgd2l0aCB7QGxpbmsgRGF0ZVRpbWUjcGx1c30uIFlvdSBtYXkgd2lzaCB0byB1c2Uge0BsaW5rIERhdGVUaW1lI3RvTG9jYWx9IGFuZCB7QGxpbmsgRGF0ZVRpbWUjdG9VVEN9IHdoaWNoIHByb3ZpZGUgc2ltcGxlIGNvbnZlbmllbmNlIHdyYXBwZXJzIGZvciBjb21tb25seSB1c2VkIHpvbmVzLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbem9uZT0nbG9jYWwnXSAtIGEgem9uZSBpZGVudGlmaWVyLiBBcyBhIHN0cmluZywgdGhhdCBjYW4gYmUgYW55IElBTkEgem9uZSBzdXBwb3J0ZWQgYnkgdGhlIGhvc3QgZW52aXJvbm1lbnQsIG9yIGEgZml4ZWQtb2Zmc2V0IG5hbWUgb2YgdGhlIGZvcm0gJ1VUQyszJywgb3IgdGhlIHN0cmluZ3MgJ2xvY2FsJyBvciAndXRjJy4gWW91IG1heSBhbHNvIHN1cHBseSBhbiBpbnN0YW5jZSBvZiBhIHtAbGluayBEYXRlVGltZSNab25lfSBjbGFzcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMua2VlcExvY2FsVGltZT1mYWxzZV0gLSBJZiB0cnVlLCBhZGp1c3QgdGhlIHVuZGVybHlpbmcgdGltZSBzbyB0aGF0IHRoZSBsb2NhbCB0aW1lIHN0YXlzIHRoZSBzYW1lLCBidXQgaW4gdGhlIHRhcmdldCB6b25lLiBZb3Ugc2hvdWxkIHJhcmVseSBuZWVkIHRoaXMuXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc2V0Wm9uZSh6b25lLCB7IGtlZXBMb2NhbFRpbWUgPSBmYWxzZSwga2VlcENhbGVuZGFyVGltZSA9IGZhbHNlIH0gPSB7fSkge1xuICAgIHpvbmUgPSBub3JtYWxpemVab25lKHpvbmUsIFNldHRpbmdzLmRlZmF1bHRab25lKTtcbiAgICBpZiAoem9uZS5lcXVhbHModGhpcy56b25lKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIGlmICghem9uZS5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZCh1bnN1cHBvcnRlZFpvbmUoem9uZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbmV3VFMgPSB0aGlzLnRzO1xuICAgICAgaWYgKGtlZXBMb2NhbFRpbWUgfHwga2VlcENhbGVuZGFyVGltZSkge1xuICAgICAgICBjb25zdCBvZmZzZXRHdWVzcyA9IHpvbmUub2Zmc2V0KHRoaXMudHMpO1xuICAgICAgICBjb25zdCBhc09iaiA9IHRoaXMudG9PYmplY3QoKTtcbiAgICAgICAgW25ld1RTXSA9IG9ialRvVFMoYXNPYmosIG9mZnNldEd1ZXNzLCB6b25lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHRzOiBuZXdUUywgem9uZSB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGUgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG9yIG91dHB1dENhbGVuZGFyLiBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRGF0ZVRpbWUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIC0gdGhlIHByb3BlcnRpZXMgdG8gc2V0XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS5yZWNvbmZpZ3VyZSh7IGxvY2FsZTogJ2VuLUdCJyB9KVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHJlY29uZmlndXJlKHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyIH0gPSB7fSkge1xuICAgIGNvbnN0IGxvYyA9IHRoaXMubG9jLmNsb25lKHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyIH0pO1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IGxvYyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBsb2NhbGUuIFJldHVybnMgYSBuZXdseS1jb25zdHJ1Y3RlZCBEYXRlVGltZS5cbiAgICogSnVzdCBhIGNvbnZlbmllbnQgYWxpYXMgZm9yIHJlY29uZmlndXJlKHsgbG9jYWxlIH0pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS5zZXRMb2NhbGUoJ2VuLUdCJylcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzZXRMb2NhbGUobG9jYWxlKSB7XG4gICAgcmV0dXJuIHRoaXMucmVjb25maWd1cmUoeyBsb2NhbGUgfSk7XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGUgdmFsdWVzIG9mIHNwZWNpZmllZCB1bml0cy4gUmV0dXJucyBhIG5ld2x5LWNvbnN0cnVjdGVkIERhdGVUaW1lLlxuICAgKiBZb3UgY2FuIG9ubHkgc2V0IHVuaXRzIHdpdGggdGhpcyBtZXRob2Q7IGZvciBcInNldHRpbmdcIiBtZXRhZGF0YSwgc2VlIHtAbGluayBEYXRlVGltZSNyZWNvbmZpZ3VyZX0gYW5kIHtAbGluayBEYXRlVGltZSNzZXRab25lfS5cbiAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlcyAtIGEgbWFwcGluZyBvZiB1bml0cyB0byBudW1iZXJzXG4gICAqIEBleGFtcGxlIGR0LnNldCh7IHllYXI6IDIwMTcgfSlcbiAgICogQGV4YW1wbGUgZHQuc2V0KHsgaG91cjogOCwgbWludXRlOiAzMCB9KVxuICAgKiBAZXhhbXBsZSBkdC5zZXQoeyB3ZWVrZGF5OiA1IH0pXG4gICAqIEBleGFtcGxlIGR0LnNldCh7IHllYXI6IDIwMDUsIG9yZGluYWw6IDIzNCB9KVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHNldCh2YWx1ZXMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG5cbiAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplT2JqZWN0KHZhbHVlcywgbm9ybWFsaXplVW5pdCksXG4gICAgICBzZXR0aW5nV2Vla1N0dWZmID1cbiAgICAgICAgIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQud2Vla1llYXIpIHx8XG4gICAgICAgICFpc1VuZGVmaW5lZChub3JtYWxpemVkLndlZWtOdW1iZXIpIHx8XG4gICAgICAgICFpc1VuZGVmaW5lZChub3JtYWxpemVkLndlZWtkYXkpLFxuICAgICAgY29udGFpbnNPcmRpbmFsID0gIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQub3JkaW5hbCksXG4gICAgICBjb250YWluc0dyZWdvclllYXIgPSAhaXNVbmRlZmluZWQobm9ybWFsaXplZC55ZWFyKSxcbiAgICAgIGNvbnRhaW5zR3JlZ29yTUQgPSAhaXNVbmRlZmluZWQobm9ybWFsaXplZC5tb250aCkgfHwgIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQuZGF5KSxcbiAgICAgIGNvbnRhaW5zR3JlZ29yID0gY29udGFpbnNHcmVnb3JZZWFyIHx8IGNvbnRhaW5zR3JlZ29yTUQsXG4gICAgICBkZWZpbml0ZVdlZWtEZWYgPSBub3JtYWxpemVkLndlZWtZZWFyIHx8IG5vcm1hbGl6ZWQud2Vla051bWJlcjtcblxuICAgIGlmICgoY29udGFpbnNHcmVnb3IgfHwgY29udGFpbnNPcmRpbmFsKSAmJiBkZWZpbml0ZVdlZWtEZWYpIHtcbiAgICAgIHRocm93IG5ldyBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvcihcbiAgICAgICAgXCJDYW4ndCBtaXggd2Vla1llYXIvd2Vla051bWJlciB1bml0cyB3aXRoIHllYXIvbW9udGgvZGF5IG9yIG9yZGluYWxzXCJcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRhaW5zR3JlZ29yTUQgJiYgY29udGFpbnNPcmRpbmFsKSB7XG4gICAgICB0aHJvdyBuZXcgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IoXCJDYW4ndCBtaXggb3JkaW5hbCBkYXRlcyB3aXRoIG1vbnRoL2RheVwiKTtcbiAgICB9XG5cbiAgICBsZXQgbWl4ZWQ7XG4gICAgaWYgKHNldHRpbmdXZWVrU3R1ZmYpIHtcbiAgICAgIG1peGVkID0gd2Vla1RvR3JlZ29yaWFuKHsgLi4uZ3JlZ29yaWFuVG9XZWVrKHRoaXMuYyksIC4uLm5vcm1hbGl6ZWQgfSk7XG4gICAgfSBlbHNlIGlmICghaXNVbmRlZmluZWQobm9ybWFsaXplZC5vcmRpbmFsKSkge1xuICAgICAgbWl4ZWQgPSBvcmRpbmFsVG9HcmVnb3JpYW4oeyAuLi5ncmVnb3JpYW5Ub09yZGluYWwodGhpcy5jKSwgLi4ubm9ybWFsaXplZCB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWl4ZWQgPSB7IC4uLnRoaXMudG9PYmplY3QoKSwgLi4ubm9ybWFsaXplZCB9O1xuXG4gICAgICAvLyBpZiB3ZSBkaWRuJ3Qgc2V0IHRoZSBkYXkgYnV0IHdlIGVuZGVkIHVwIG9uIGFuIG92ZXJmbG93IGRhdGUsXG4gICAgICAvLyB1c2UgdGhlIGxhc3QgZGF5IG9mIHRoZSByaWdodCBtb250aFxuICAgICAgaWYgKGlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQuZGF5KSkge1xuICAgICAgICBtaXhlZC5kYXkgPSBNYXRoLm1pbihkYXlzSW5Nb250aChtaXhlZC55ZWFyLCBtaXhlZC5tb250aCksIG1peGVkLmRheSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgW3RzLCBvXSA9IG9ialRvVFMobWl4ZWQsIHRoaXMubywgdGhpcy56b25lKTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyB0cywgbyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBwZXJpb2Qgb2YgdGltZSB0byB0aGlzIERhdGVUaW1lIGFuZCByZXR1cm4gdGhlIHJlc3VsdGluZyBEYXRlVGltZVxuICAgKlxuICAgKiBBZGRpbmcgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG9yIG1pbGxpc2Vjb25kcyBpbmNyZWFzZXMgdGhlIHRpbWVzdGFtcCBieSB0aGUgcmlnaHQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcy4gQWRkaW5nIGRheXMsIG1vbnRocywgb3IgeWVhcnMgc2hpZnRzIHRoZSBjYWxlbmRhciwgYWNjb3VudGluZyBmb3IgRFNUcyBhbmQgbGVhcCB5ZWFycyBhbG9uZyB0aGUgd2F5LiBUaHVzLCBgZHQucGx1cyh7IGhvdXJzOiAyNCB9KWAgbWF5IHJlc3VsdCBpbiBhIGRpZmZlcmVudCB0aW1lIHRoYW4gYGR0LnBsdXMoeyBkYXlzOiAxIH0pYCBpZiB0aGVyZSdzIGEgRFNUIHNoaWZ0IGluIGJldHdlZW4uXG4gICAqIEBwYXJhbSB7RHVyYXRpb258T2JqZWN0fG51bWJlcn0gZHVyYXRpb24gLSBUaGUgYW1vdW50IHRvIGFkZC4gRWl0aGVyIGEgTHV4b24gRHVyYXRpb24sIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgdGhlIG9iamVjdCBhcmd1bWVudCB0byBEdXJhdGlvbi5mcm9tT2JqZWN0KClcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cygxMjMpIC8vfj4gaW4gMTIzIG1pbGxpc2Vjb25kc1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKHsgbWludXRlczogMTUgfSkgLy9+PiBpbiAxNSBtaW51dGVzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBkYXlzOiAxIH0pIC8vfj4gdGhpcyB0aW1lIHRvbW9ycm93XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBkYXlzOiAtMSB9KSAvL34+IHRoaXMgdGltZSB5ZXN0ZXJkYXlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IGhvdXJzOiAzLCBtaW51dGVzOiAxMyB9KSAvL34+IGluIDMgaHIsIDEzIG1pblxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMywgbWludXRlczogMTMgfSkpIC8vfj4gaW4gMyBociwgMTMgbWluXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgcGx1cyhkdXJhdGlvbikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tRHVyYXRpb25MaWtlKGR1cmF0aW9uKTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgYWRqdXN0VGltZSh0aGlzLCBkdXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJ0cmFjdCBhIHBlcmlvZCBvZiB0aW1lIHRvIHRoaXMgRGF0ZVRpbWUgYW5kIHJldHVybiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lXG4gICAqIFNlZSB7QGxpbmsgRGF0ZVRpbWUjcGx1c31cbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSBhbW91bnQgdG8gc3VidHJhY3QuIEVpdGhlciBhIEx1eG9uIER1cmF0aW9uLCBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIHRoZSBvYmplY3QgYXJndW1lbnQgdG8gRHVyYXRpb24uZnJvbU9iamVjdCgpXG4gICBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIG1pbnVzKGR1cmF0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IGR1ciA9IER1cmF0aW9uLmZyb21EdXJhdGlvbkxpa2UoZHVyYXRpb24pLm5lZ2F0ZSgpO1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCBhZGp1c3RUaW1lKHRoaXMsIGR1cikpO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhpcyBEYXRlVGltZSB0byB0aGUgYmVnaW5uaW5nIG9mIGEgdW5pdCBvZiB0aW1lLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIFRoZSB1bml0IHRvIGdvIHRvIHRoZSBiZWdpbm5pbmcgb2YuIENhbiBiZSAneWVhcicsICdxdWFydGVyJywgJ21vbnRoJywgJ3dlZWsnLCAnZGF5JywgJ2hvdXInLCAnbWludXRlJywgJ3NlY29uZCcsIG9yICdtaWxsaXNlY29uZCcuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMpLnN0YXJ0T2YoJ21vbnRoJykudG9JU09EYXRlKCk7IC8vPT4gJzIwMTQtMDMtMDEnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMpLnN0YXJ0T2YoJ3llYXInKS50b0lTT0RhdGUoKTsgLy89PiAnMjAxNC0wMS0wMSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMykuc3RhcnRPZignd2VlaycpLnRvSVNPRGF0ZSgpOyAvLz0+ICcyMDE0LTAzLTAzJywgd2Vla3MgYWx3YXlzIHN0YXJ0IG9uIE1vbmRheXNcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMywgNSwgMzApLnN0YXJ0T2YoJ2RheScpLnRvSVNPVGltZSgpOyAvLz0+ICcwMDowMC4wMDAtMDU6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMsIDUsIDMwKS5zdGFydE9mKCdob3VyJykudG9JU09UaW1lKCk7IC8vPT4gJzA1OjAwOjAwLjAwMC0wNTowMCdcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGFydE9mKHVuaXQpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgbyA9IHt9LFxuICAgICAgbm9ybWFsaXplZFVuaXQgPSBEdXJhdGlvbi5ub3JtYWxpemVVbml0KHVuaXQpO1xuICAgIHN3aXRjaCAobm9ybWFsaXplZFVuaXQpIHtcbiAgICAgIGNhc2UgXCJ5ZWFyc1wiOlxuICAgICAgICBvLm1vbnRoID0gMTtcbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgXCJxdWFydGVyc1wiOlxuICAgICAgY2FzZSBcIm1vbnRoc1wiOlxuICAgICAgICBvLmRheSA9IDE7XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlIFwid2Vla3NcIjpcbiAgICAgIGNhc2UgXCJkYXlzXCI6XG4gICAgICAgIG8uaG91ciA9IDA7XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlIFwiaG91cnNcIjpcbiAgICAgICAgby5taW51dGUgPSAwO1xuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSBcIm1pbnV0ZXNcIjpcbiAgICAgICAgby5zZWNvbmQgPSAwO1xuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSBcInNlY29uZHNcIjpcbiAgICAgICAgby5taWxsaXNlY29uZCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1pbGxpc2Vjb25kc1wiOlxuICAgICAgICBicmVhaztcbiAgICAgIC8vIG5vIGRlZmF1bHQsIGludmFsaWQgdW5pdHMgdGhyb3cgaW4gbm9ybWFsaXplVW5pdCgpXG4gICAgfVxuXG4gICAgaWYgKG5vcm1hbGl6ZWRVbml0ID09PSBcIndlZWtzXCIpIHtcbiAgICAgIG8ud2Vla2RheSA9IDE7XG4gICAgfVxuXG4gICAgaWYgKG5vcm1hbGl6ZWRVbml0ID09PSBcInF1YXJ0ZXJzXCIpIHtcbiAgICAgIGNvbnN0IHEgPSBNYXRoLmNlaWwodGhpcy5tb250aCAvIDMpO1xuICAgICAgby5tb250aCA9IChxIC0gMSkgKiAzICsgMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zZXQobyk7XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGlzIERhdGVUaW1lIHRvIHRoZSBlbmQgKG1lYW5pbmcgdGhlIGxhc3QgbWlsbGlzZWNvbmQpIG9mIGEgdW5pdCBvZiB0aW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1bml0IC0gVGhlIHVuaXQgdG8gZ28gdG8gdGhlIGVuZCBvZi4gQ2FuIGJlICd5ZWFyJywgJ3F1YXJ0ZXInLCAnbW9udGgnLCAnd2VlaycsICdkYXknLCAnaG91cicsICdtaW51dGUnLCAnc2Vjb25kJywgb3IgJ21pbGxpc2Vjb25kJy5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMykuZW5kT2YoJ21vbnRoJykudG9JU08oKTsgLy89PiAnMjAxNC0wMy0zMVQyMzo1OTo1OS45OTktMDU6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMpLmVuZE9mKCd5ZWFyJykudG9JU08oKTsgLy89PiAnMjAxNC0xMi0zMVQyMzo1OTo1OS45OTktMDU6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMpLmVuZE9mKCd3ZWVrJykudG9JU08oKTsgLy8gPT4gJzIwMTQtMDMtMDlUMjM6NTk6NTkuOTk5LTA1OjAwJywgd2Vla3Mgc3RhcnQgb24gTW9uZGF5c1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzLCA1LCAzMCkuZW5kT2YoJ2RheScpLnRvSVNPKCk7IC8vPT4gJzIwMTQtMDMtMDNUMjM6NTk6NTkuOTk5LTA1OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzLCA1LCAzMCkuZW5kT2YoJ2hvdXInKS50b0lTTygpOyAvLz0+ICcyMDE0LTAzLTAzVDA1OjU5OjU5Ljk5OS0wNTowMCdcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBlbmRPZih1bml0KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZFxuICAgICAgPyB0aGlzLnBsdXMoeyBbdW5pdF06IDEgfSlcbiAgICAgICAgICAuc3RhcnRPZih1bml0KVxuICAgICAgICAgIC5taW51cygxKVxuICAgICAgOiB0aGlzO1xuICB9XG5cbiAgLy8gT1VUUFVUXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBmb3JtYXR0ZWQgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgZm9ybWF0IHN0cmluZy5cbiAgICogKipZb3UgbWF5IG5vdCB3YW50IHRoaXMuKiogU2VlIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9yIGEgbW9yZSBmbGV4aWJsZSBmb3JtYXR0aW5nIHRvb2wuIEZvciBhIHRhYmxlIG9mIHRva2VucyBhbmQgdGhlaXIgaW50ZXJwcmV0YXRpb25zLCBzZWUgW2hlcmVdKGh0dHBzOi8vbW9tZW50LmdpdGh1Yi5pby9sdXhvbi8jL2Zvcm1hdHRpbmc/aWQ9dGFibGUtb2YtdG9rZW5zKS5cbiAgICogRGVmYXVsdHMgdG8gZW4tVVMgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZCwgcmVnYXJkbGVzcyBvZiB0aGUgc3lzdGVtJ3MgbG9jYWxlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm10IC0gdGhlIGZvcm1hdCBzdHJpbmdcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRzIHRvIG92ZXJyaWRlIHRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgb24gdGhpcyBEYXRlVGltZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0Zvcm1hdCgneXl5eSBMTEwgZGQnKSAvLz0+ICcyMDE3IEFwciAyMidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkuc2V0TG9jYWxlKCdmcicpLnRvRm9ybWF0KCd5eXl5IExMTCBkZCcpIC8vPT4gJzIwMTcgYXZyLiAyMidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Gb3JtYXQoJ3l5eXkgTExMIGRkJywgeyBsb2NhbGU6IFwiZnJcIiB9KSAvLz0+ICcyMDE3IGF2ci4gMjInXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvRm9ybWF0KFwiSEggJ2hvdXJzIGFuZCcgbW0gJ21pbnV0ZXMnXCIpIC8vPT4gJzIwIGhvdXJzIGFuZCA1NSBtaW51dGVzJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0Zvcm1hdChmbXQsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWRcbiAgICAgID8gRm9ybWF0dGVyLmNyZWF0ZSh0aGlzLmxvYy5yZWRlZmF1bHRUb0VOKG9wdHMpKS5mb3JtYXREYXRlVGltZUZyb21TdHJpbmcodGhpcywgZm10KVxuICAgICAgOiBJTlZBTElEO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsb2NhbGl6ZWQgc3RyaW5nIHJlcHJlc2VudGluZyB0aGlzIGRhdGUuIEFjY2VwdHMgdGhlIHNhbWUgb3B0aW9ucyBhcyB0aGUgSW50bC5EYXRlVGltZUZvcm1hdCBjb25zdHJ1Y3RvciBhbmQgYW55IHByZXNldHMgZGVmaW5lZCBieSBMdXhvbiwgc3VjaCBhcyBgRGF0ZVRpbWUuREFURV9GVUxMYCBvciBgRGF0ZVRpbWUuVElNRV9TSU1QTEVgLlxuICAgKiBUaGUgZXhhY3QgYmVoYXZpb3Igb2YgdGhpcyBtZXRob2QgaXMgYnJvd3Nlci1zcGVjaWZpYywgYnV0IGluIGdlbmVyYWwgaXQgd2lsbCByZXR1cm4gYW4gYXBwcm9wcmlhdGUgcmVwcmVzZW50YXRpb25cbiAgICogb2YgdGhlIERhdGVUaW1lIGluIHRoZSBhc3NpZ25lZCBsb2NhbGUuXG4gICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGVUaW1lRm9ybWF0XG4gICAqIEBwYXJhbSBmb3JtYXRPcHRzIHtPYmplY3R9IC0gSW50bC5EYXRlVGltZUZvcm1hdCBjb25zdHJ1Y3RvciBvcHRpb25zIGFuZCBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRzIHRvIG92ZXJyaWRlIHRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgb24gdGhpcyBEYXRlVGltZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVN0cmluZygpOyAvLz0+IDQvMjAvMjAxN1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5zZXRMb2NhbGUoJ2VuLWdiJykudG9Mb2NhbGVTdHJpbmcoKTsgLy89PiAnMjAvMDQvMjAxNydcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVTdHJpbmcoRGF0ZVRpbWUuREFURV9GVUxMKTsgLy89PiAnQXByaWwgMjAsIDIwMTcnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKERhdGVUaW1lLkRBVEVfRlVMTCwgeyBsb2NhbGU6ICdmcicgfSk7IC8vPT4gJzI4IGFvw7t0IDIwMjInXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKERhdGVUaW1lLlRJTUVfU0lNUExFKTsgLy89PiAnMTE6MzIgQU0nXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKERhdGVUaW1lLkRBVEVUSU1FX1NIT1JUKTsgLy89PiAnNC8yMC8yMDE3LCAxMTozMiBBTSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVTdHJpbmcoeyB3ZWVrZGF5OiAnbG9uZycsIG1vbnRoOiAnbG9uZycsIGRheTogJzItZGlnaXQnIH0pOyAvLz0+ICdUaHVyc2RheSwgQXByaWwgMjAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKHsgd2Vla2RheTogJ3Nob3J0JywgbW9udGg6ICdzaG9ydCcsIGRheTogJzItZGlnaXQnLCBob3VyOiAnMi1kaWdpdCcsIG1pbnV0ZTogJzItZGlnaXQnIH0pOyAvLz0+ICdUaHUsIEFwciAyMCwgMTE6MjcgQU0nXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKHsgaG91cjogJzItZGlnaXQnLCBtaW51dGU6ICcyLWRpZ2l0JywgaG91ckN5Y2xlOiAnaDIzJyB9KTsgLy89PiAnMTE6MzInXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvTG9jYWxlU3RyaW5nKGZvcm1hdE9wdHMgPSBGb3JtYXRzLkRBVEVfU0hPUlQsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWRcbiAgICAgID8gRm9ybWF0dGVyLmNyZWF0ZSh0aGlzLmxvYy5jbG9uZShvcHRzKSwgZm9ybWF0T3B0cykuZm9ybWF0RGF0ZVRpbWUodGhpcylcbiAgICAgIDogSU5WQUxJRDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGZvcm1hdCBcInBhcnRzXCIsIG1lYW5pbmcgaW5kaXZpZHVhbCB0b2tlbnMgYWxvbmcgd2l0aCBtZXRhZGF0YS4gVGhpcyBpcyBhbGxvd3MgY2FsbGVycyB0byBwb3N0LXByb2Nlc3MgaW5kaXZpZHVhbCBzZWN0aW9ucyBvZiB0aGUgZm9ybWF0dGVkIG91dHB1dC5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZVRpbWVGb3JtYXQvZm9ybWF0VG9QYXJ0c1xuICAgKiBAcGFyYW0gb3B0cyB7T2JqZWN0fSAtIEludGwuRGF0ZVRpbWVGb3JtYXQgY29uc3RydWN0b3Igb3B0aW9ucywgc2FtZSBhcyBgdG9Mb2NhbGVTdHJpbmdgLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVBhcnRzKCk7IC8vPT4gW1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy89PiAgIHsgdHlwZTogJ2RheScsIHZhbHVlOiAnMjUnIH0sXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLz0+ICAgeyB0eXBlOiAnbGl0ZXJhbCcsIHZhbHVlOiAnLycgfSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vPT4gICB7IHR5cGU6ICdtb250aCcsIHZhbHVlOiAnMDUnIH0sXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLz0+ICAgeyB0eXBlOiAnbGl0ZXJhbCcsIHZhbHVlOiAnLycgfSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vPT4gICB7IHR5cGU6ICd5ZWFyJywgdmFsdWU6ICcxOTgyJyB9XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLz0+IF1cbiAgICovXG4gIHRvTG9jYWxlUGFydHMob3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZFxuICAgICAgPyBGb3JtYXR0ZXIuY3JlYXRlKHRoaXMubG9jLmNsb25lKG9wdHMpLCBvcHRzKS5mb3JtYXREYXRlVGltZVBhcnRzKHRoaXMpXG4gICAgICA6IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnN1cHByZXNzTWlsbGlzZWNvbmRzPWZhbHNlXSAtIGV4Y2x1ZGUgbWlsbGlzZWNvbmRzIGZyb20gdGhlIGZvcm1hdCBpZiB0aGV5J3JlIDBcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zdXBwcmVzc1NlY29uZHM9ZmFsc2VdIC0gZXhjbHVkZSBzZWNvbmRzIGZyb20gdGhlIGZvcm1hdCBpZiB0aGV5J3JlIDBcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlT2Zmc2V0PXRydWVdIC0gaW5jbHVkZSB0aGUgb2Zmc2V0LCBzdWNoIGFzICdaJyBvciAnLTA0OjAwJ1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmV4dGVuZGVkWm9uZT1mYWxzZV0gLSBhZGQgdGhlIHRpbWUgem9uZSBmb3JtYXQgZXh0ZW5zaW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5mb3JtYXQ9J2V4dGVuZGVkJ10gLSBjaG9vc2UgYmV0d2VlbiB0aGUgYmFzaWMgYW5kIGV4dGVuZGVkIGZvcm1hdFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMTk4MywgNSwgMjUpLnRvSVNPKCkgLy89PiAnMTk4Mi0wNS0yNVQwMDowMDowMC4wMDBaJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0lTTygpIC8vPT4gJzIwMTctMDQtMjJUMjA6NDc6MDUuMzM1LTA0OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0lTTyh7IGluY2x1ZGVPZmZzZXQ6IGZhbHNlIH0pIC8vPT4gJzIwMTctMDQtMjJUMjA6NDc6MDUuMzM1J1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0lTTyh7IGZvcm1hdDogJ2Jhc2ljJyB9KSAvLz0+ICcyMDE3MDQyMlQyMDQ3MDUuMzM1LTA0MDAnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSVNPKHtcbiAgICBmb3JtYXQgPSBcImV4dGVuZGVkXCIsXG4gICAgc3VwcHJlc3NTZWNvbmRzID0gZmFsc2UsXG4gICAgc3VwcHJlc3NNaWxsaXNlY29uZHMgPSBmYWxzZSxcbiAgICBpbmNsdWRlT2Zmc2V0ID0gdHJ1ZSxcbiAgICBleHRlbmRlZFpvbmUgPSBmYWxzZSxcbiAgfSA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGV4dCA9IGZvcm1hdCA9PT0gXCJleHRlbmRlZFwiO1xuXG4gICAgbGV0IGMgPSB0b0lTT0RhdGUodGhpcywgZXh0KTtcbiAgICBjICs9IFwiVFwiO1xuICAgIGMgKz0gdG9JU09UaW1lKHRoaXMsIGV4dCwgc3VwcHJlc3NTZWNvbmRzLCBzdXBwcmVzc01pbGxpc2Vjb25kcywgaW5jbHVkZU9mZnNldCwgZXh0ZW5kZWRab25lKTtcbiAgICByZXR1cm4gYztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSdzIGRhdGUgY29tcG9uZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuZm9ybWF0PSdleHRlbmRlZCddIC0gY2hvb3NlIGJldHdlZW4gdGhlIGJhc2ljIGFuZCBleHRlbmRlZCBmb3JtYXRcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDE5ODIsIDUsIDI1KS50b0lTT0RhdGUoKSAvLz0+ICcxOTgyLTA1LTI1J1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMTk4MiwgNSwgMjUpLnRvSVNPRGF0ZSh7IGZvcm1hdDogJ2Jhc2ljJyB9KSAvLz0+ICcxOTgyMDUyNSdcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9JU09EYXRlKHsgZm9ybWF0ID0gXCJleHRlbmRlZFwiIH0gPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdG9JU09EYXRlKHRoaXMsIGZvcm1hdCA9PT0gXCJleHRlbmRlZFwiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSdzIHdlZWsgZGF0ZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMTk4MiwgNSwgMjUpLnRvSVNPV2Vla0RhdGUoKSAvLz0+ICcxOTgyLVcyMS0yJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0lTT1dlZWtEYXRlKCkge1xuICAgIHJldHVybiB0b1RlY2hGb3JtYXQodGhpcywgXCJra2trLSdXJ1dXLWNcIik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUncyB0aW1lIGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zdXBwcmVzc01pbGxpc2Vjb25kcz1mYWxzZV0gLSBleGNsdWRlIG1pbGxpc2Vjb25kcyBmcm9tIHRoZSBmb3JtYXQgaWYgdGhleSdyZSAwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc3VwcHJlc3NTZWNvbmRzPWZhbHNlXSAtIGV4Y2x1ZGUgc2Vjb25kcyBmcm9tIHRoZSBmb3JtYXQgaWYgdGhleSdyZSAwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZU9mZnNldD10cnVlXSAtIGluY2x1ZGUgdGhlIG9mZnNldCwgc3VjaCBhcyAnWicgb3IgJy0wNDowMCdcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5leHRlbmRlZFpvbmU9dHJ1ZV0gLSBhZGQgdGhlIHRpbWUgem9uZSBmb3JtYXQgZXh0ZW5zaW9uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZVByZWZpeD1mYWxzZV0gLSBpbmNsdWRlIHRoZSBgVGAgcHJlZml4XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5mb3JtYXQ9J2V4dGVuZGVkJ10gLSBjaG9vc2UgYmV0d2VlbiB0aGUgYmFzaWMgYW5kIGV4dGVuZGVkIGZvcm1hdFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoKS5zZXQoeyBob3VyOiA3LCBtaW51dGU6IDM0IH0pLnRvSVNPVGltZSgpIC8vPT4gJzA3OjM0OjE5LjM2MVonXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygpLnNldCh7IGhvdXI6IDcsIG1pbnV0ZTogMzQsIHNlY29uZHM6IDAsIG1pbGxpc2Vjb25kczogMCB9KS50b0lTT1RpbWUoeyBzdXBwcmVzc1NlY29uZHM6IHRydWUgfSkgLy89PiAnMDc6MzRaJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoKS5zZXQoeyBob3VyOiA3LCBtaW51dGU6IDM0IH0pLnRvSVNPVGltZSh7IGZvcm1hdDogJ2Jhc2ljJyB9KSAvLz0+ICcwNzM0MTkuMzYxWidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKCkuc2V0KHsgaG91cjogNywgbWludXRlOiAzNCB9KS50b0lTT1RpbWUoeyBpbmNsdWRlUHJlZml4OiB0cnVlIH0pIC8vPT4gJ1QwNzozNDoxOS4zNjFaJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0lTT1RpbWUoe1xuICAgIHN1cHByZXNzTWlsbGlzZWNvbmRzID0gZmFsc2UsXG4gICAgc3VwcHJlc3NTZWNvbmRzID0gZmFsc2UsXG4gICAgaW5jbHVkZU9mZnNldCA9IHRydWUsXG4gICAgaW5jbHVkZVByZWZpeCA9IGZhbHNlLFxuICAgIGV4dGVuZGVkWm9uZSA9IGZhbHNlLFxuICAgIGZvcm1hdCA9IFwiZXh0ZW5kZWRcIixcbiAgfSA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGxldCBjID0gaW5jbHVkZVByZWZpeCA/IFwiVFwiIDogXCJcIjtcbiAgICByZXR1cm4gKFxuICAgICAgYyArXG4gICAgICB0b0lTT1RpbWUoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIGZvcm1hdCA9PT0gXCJleHRlbmRlZFwiLFxuICAgICAgICBzdXBwcmVzc1NlY29uZHMsXG4gICAgICAgIHN1cHByZXNzTWlsbGlzZWNvbmRzLFxuICAgICAgICBpbmNsdWRlT2Zmc2V0LFxuICAgICAgICBleHRlbmRlZFpvbmVcbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gUkZDIDI4MjItY29tcGF0aWJsZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNCwgNywgMTMpLnRvUkZDMjgyMigpIC8vPT4gJ1N1biwgMTMgSnVsIDIwMTQgMDA6MDA6MDAgKzAwMDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDcsIDEzKS50b1JGQzI4MjIoKSAvLz0+ICdTdW4sIDEzIEp1bCAyMDE0IDAwOjAwOjAwIC0wNDAwJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b1JGQzI4MjIoKSB7XG4gICAgcmV0dXJuIHRvVGVjaEZvcm1hdCh0aGlzLCBcIkVFRSwgZGQgTExMIHl5eXkgSEg6bW06c3MgWlpaXCIsIGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBIVFRQIGhlYWRlcnMuIFRoZSBvdXRwdXQgaXMgYWx3YXlzIGV4cHJlc3NlZCBpbiBHTVQuXG4gICAqIFNwZWNpZmljYWxseSwgdGhlIHN0cmluZyBjb25mb3JtcyB0byBSRkMgMTEyMy5cbiAgICogQHNlZSBodHRwczovL3d3dy53My5vcmcvUHJvdG9jb2xzL3JmYzI2MTYvcmZjMjYxNi1zZWMzLmh0bWwjc2VjMy4zLjFcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTQsIDcsIDEzKS50b0hUVFAoKSAvLz0+ICdTdW4sIDEzIEp1bCAyMDE0IDAwOjAwOjAwIEdNVCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTQsIDcsIDEzLCAxOSkudG9IVFRQKCkgLy89PiAnU3VuLCAxMyBKdWwgMjAxNCAxOTowMDowMCBHTVQnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSFRUUCgpIHtcbiAgICByZXR1cm4gdG9UZWNoRm9ybWF0KHRoaXMudG9VVEMoKSwgXCJFRUUsIGRkIExMTCB5eXl5IEhIOm1tOnNzICdHTVQnXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBhcHByb3ByaWF0ZSBmb3IgdXNlIGluIFNRTCBEYXRlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE0LCA3LCAxMykudG9TUUxEYXRlKCkgLy89PiAnMjAxNC0wNy0xMydcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9TUUxEYXRlKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRvSVNPRGF0ZSh0aGlzLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBTUUwgVGltZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlWm9uZT1mYWxzZV0gLSBpbmNsdWRlIHRoZSB6b25lLCBzdWNoIGFzICdBbWVyaWNhL05ld19Zb3JrJy4gT3ZlcnJpZGVzIGluY2x1ZGVPZmZzZXQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZU9mZnNldD10cnVlXSAtIGluY2x1ZGUgdGhlIG9mZnNldCwgc3VjaCBhcyAnWicgb3IgJy0wNDowMCdcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlT2Zmc2V0U3BhY2U9dHJ1ZV0gLSBpbmNsdWRlIHRoZSBzcGFjZSBiZXR3ZWVuIHRoZSB0aW1lIGFuZCB0aGUgb2Zmc2V0LCBzdWNoIGFzICcwNToxNToxNi4zNDUgLTA0OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoKS50b1NRTCgpIC8vPT4gJzA1OjE1OjE2LjM0NSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9TUUwoKSAvLz0+ICcwNToxNToxNi4zNDUgLTA0OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b1NRTCh7IGluY2x1ZGVPZmZzZXQ6IGZhbHNlIH0pIC8vPT4gJzA1OjE1OjE2LjM0NSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9TUUwoeyBpbmNsdWRlWm9uZTogZmFsc2UgfSkgLy89PiAnMDU6MTU6MTYuMzQ1IEFtZXJpY2EvTmV3X1lvcmsnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvU1FMVGltZSh7IGluY2x1ZGVPZmZzZXQgPSB0cnVlLCBpbmNsdWRlWm9uZSA9IGZhbHNlLCBpbmNsdWRlT2Zmc2V0U3BhY2UgPSB0cnVlIH0gPSB7fSkge1xuICAgIGxldCBmbXQgPSBcIkhIOm1tOnNzLlNTU1wiO1xuXG4gICAgaWYgKGluY2x1ZGVab25lIHx8IGluY2x1ZGVPZmZzZXQpIHtcbiAgICAgIGlmIChpbmNsdWRlT2Zmc2V0U3BhY2UpIHtcbiAgICAgICAgZm10ICs9IFwiIFwiO1xuICAgICAgfVxuICAgICAgaWYgKGluY2x1ZGVab25lKSB7XG4gICAgICAgIGZtdCArPSBcInpcIjtcbiAgICAgIH0gZWxzZSBpZiAoaW5jbHVkZU9mZnNldCkge1xuICAgICAgICBmbXQgKz0gXCJaWlwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0b1RlY2hGb3JtYXQodGhpcywgZm10LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBTUUwgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZVpvbmU9ZmFsc2VdIC0gaW5jbHVkZSB0aGUgem9uZSwgc3VjaCBhcyAnQW1lcmljYS9OZXdfWW9yaycuIE92ZXJyaWRlcyBpbmNsdWRlT2Zmc2V0LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVPZmZzZXQ9dHJ1ZV0gLSBpbmNsdWRlIHRoZSBvZmZzZXQsIHN1Y2ggYXMgJ1onIG9yICctMDQ6MDAnXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZU9mZnNldFNwYWNlPXRydWVdIC0gaW5jbHVkZSB0aGUgc3BhY2UgYmV0d2VlbiB0aGUgdGltZSBhbmQgdGhlIG9mZnNldCwgc3VjaCBhcyAnMDU6MTU6MTYuMzQ1IC0wNDowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTQsIDcsIDEzKS50b1NRTCgpIC8vPT4gJzIwMTQtMDctMTMgMDA6MDA6MDAuMDAwIFonXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDcsIDEzKS50b1NRTCgpIC8vPT4gJzIwMTQtMDctMTMgMDA6MDA6MDAuMDAwIC0wNDowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgNywgMTMpLnRvU1FMKHsgaW5jbHVkZU9mZnNldDogZmFsc2UgfSkgLy89PiAnMjAxNC0wNy0xMyAwMDowMDowMC4wMDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDcsIDEzKS50b1NRTCh7IGluY2x1ZGVab25lOiB0cnVlIH0pIC8vPT4gJzIwMTQtMDctMTMgMDA6MDA6MDAuMDAwIEFtZXJpY2EvTmV3X1lvcmsnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvU1FMKG9wdHMgPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gYCR7dGhpcy50b1NRTERhdGUoKX0gJHt0aGlzLnRvU1FMVGltZShvcHRzKX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBhcHByb3ByaWF0ZSBmb3IgZGVidWdnaW5nXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnRvSVNPKCkgOiBJTlZBTElEO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVwb2NoIG1pbGxpc2Vjb25kcyBvZiB0aGlzIERhdGVUaW1lLiBBbGlhcyBvZiB7QGxpbmsgRGF0ZVRpbWUjdG9NaWxsaXN9XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHZhbHVlT2YoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9NaWxsaXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlcG9jaCBtaWxsaXNlY29uZHMgb2YgdGhpcyBEYXRlVGltZS5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgdG9NaWxsaXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudHMgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZXBvY2ggc2Vjb25kcyBvZiB0aGlzIERhdGVUaW1lLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICB0b1NlY29uZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudHMgLyAxMDAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVwb2NoIHNlY29uZHMgKGFzIGEgd2hvbGUgbnVtYmVyKSBvZiB0aGlzIERhdGVUaW1lLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICB0b1VuaXhJbnRlZ2VyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBNYXRoLmZsb29yKHRoaXMudHMgLyAxMDAwKSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBKU09OLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9JU08oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgQlNPTiBzZXJpYWxpemFibGUgZXF1aXZhbGVudCB0byB0aGlzIERhdGVUaW1lLlxuICAgKiBAcmV0dXJuIHtEYXRlfVxuICAgKi9cbiAgdG9CU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvSlNEYXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIEphdmFTY3JpcHQgb2JqZWN0IHdpdGggdGhpcyBEYXRlVGltZSdzIHllYXIsIG1vbnRoLCBkYXksIGFuZCBzbyBvbi5cbiAgICogQHBhcmFtIG9wdHMgLSBvcHRpb25zIGZvciBnZW5lcmF0aW5nIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlQ29uZmlnPWZhbHNlXSAtIGluY2x1ZGUgY29uZmlndXJhdGlvbiBhdHRyaWJ1dGVzIGluIHRoZSBvdXRwdXRcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9PYmplY3QoKSAvLz0+IHsgeWVhcjogMjAxNywgbW9udGg6IDQsIGRheTogMjIsIGhvdXI6IDIwLCBtaW51dGU6IDQ5LCBzZWNvbmQ6IDQyLCBtaWxsaXNlY29uZDogMjY4IH1cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgdG9PYmplY3Qob3B0cyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB7fTtcblxuICAgIGNvbnN0IGJhc2UgPSB7IC4uLnRoaXMuYyB9O1xuXG4gICAgaWYgKG9wdHMuaW5jbHVkZUNvbmZpZykge1xuICAgICAgYmFzZS5vdXRwdXRDYWxlbmRhciA9IHRoaXMub3V0cHV0Q2FsZW5kYXI7XG4gICAgICBiYXNlLm51bWJlcmluZ1N5c3RlbSA9IHRoaXMubG9jLm51bWJlcmluZ1N5c3RlbTtcbiAgICAgIGJhc2UubG9jYWxlID0gdGhpcy5sb2MubG9jYWxlO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgSmF2YVNjcmlwdCBEYXRlIGVxdWl2YWxlbnQgdG8gdGhpcyBEYXRlVGltZS5cbiAgICogQHJldHVybiB7RGF0ZX1cbiAgICovXG4gIHRvSlNEYXRlKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLmlzVmFsaWQgPyB0aGlzLnRzIDogTmFOKTtcbiAgfVxuXG4gIC8vIENPTVBBUkVcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdHdvIERhdGVUaW1lcyBhcyBhIER1cmF0aW9uLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBvdGhlckRhdGVUaW1lIC0gdGhlIERhdGVUaW1lIHRvIGNvbXBhcmUgdGhpcyBvbmUgdG9cbiAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IFt1bml0PVsnbWlsbGlzZWNvbmRzJ11dIC0gdGhlIHVuaXQgb3IgYXJyYXkgb2YgdW5pdHMgKHN1Y2ggYXMgJ2hvdXJzJyBvciAnZGF5cycpIHRvIGluY2x1ZGUgaW4gdGhlIGR1cmF0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdGhhdCBhZmZlY3QgdGhlIGNyZWF0aW9uIG9mIHRoZSBEdXJhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29udmVyc2lvbkFjY3VyYWN5PSdjYXN1YWwnXSAtIHRoZSBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGkxID0gRGF0ZVRpbWUuZnJvbUlTTygnMTk4Mi0wNS0yNVQwOTo0NScpLFxuICAgKiAgICAgaTIgPSBEYXRlVGltZS5mcm9tSVNPKCcxOTgzLTEwLTE0VDEwOjMwJyk7XG4gICAqIGkyLmRpZmYoaTEpLnRvT2JqZWN0KCkgLy89PiB7IG1pbGxpc2Vjb25kczogNDM4MDc1MDAwMDAgfVxuICAgKiBpMi5kaWZmKGkxLCAnaG91cnMnKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMTIxNjguNzUgfVxuICAgKiBpMi5kaWZmKGkxLCBbJ21vbnRocycsICdkYXlzJ10pLnRvT2JqZWN0KCkgLy89PiB7IG1vbnRoczogMTYsIGRheXM6IDE5LjAzMTI1IH1cbiAgICogaTIuZGlmZihpMSwgWydtb250aHMnLCAnZGF5cycsICdob3VycyddKS50b09iamVjdCgpIC8vPT4geyBtb250aHM6IDE2LCBkYXlzOiAxOSwgaG91cnM6IDAuNzUgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIGRpZmYob3RoZXJEYXRlVGltZSwgdW5pdCA9IFwibWlsbGlzZWNvbmRzXCIsIG9wdHMgPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkIHx8ICFvdGhlckRhdGVUaW1lLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5pbnZhbGlkKFwiY3JlYXRlZCBieSBkaWZmaW5nIGFuIGludmFsaWQgRGF0ZVRpbWVcIik7XG4gICAgfVxuXG4gICAgY29uc3QgZHVyT3B0cyA9IHsgbG9jYWxlOiB0aGlzLmxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtOiB0aGlzLm51bWJlcmluZ1N5c3RlbSwgLi4ub3B0cyB9O1xuXG4gICAgY29uc3QgdW5pdHMgPSBtYXliZUFycmF5KHVuaXQpLm1hcChEdXJhdGlvbi5ub3JtYWxpemVVbml0KSxcbiAgICAgIG90aGVySXNMYXRlciA9IG90aGVyRGF0ZVRpbWUudmFsdWVPZigpID4gdGhpcy52YWx1ZU9mKCksXG4gICAgICBlYXJsaWVyID0gb3RoZXJJc0xhdGVyID8gdGhpcyA6IG90aGVyRGF0ZVRpbWUsXG4gICAgICBsYXRlciA9IG90aGVySXNMYXRlciA/IG90aGVyRGF0ZVRpbWUgOiB0aGlzLFxuICAgICAgZGlmZmVkID0gZGlmZihlYXJsaWVyLCBsYXRlciwgdW5pdHMsIGR1ck9wdHMpO1xuXG4gICAgcmV0dXJuIG90aGVySXNMYXRlciA/IGRpZmZlZC5uZWdhdGUoKSA6IGRpZmZlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGlzIERhdGVUaW1lIGFuZCByaWdodCBub3cuXG4gICAqIFNlZSB7QGxpbmsgRGF0ZVRpbWUjZGlmZn1cbiAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IFt1bml0PVsnbWlsbGlzZWNvbmRzJ11dIC0gdGhlIHVuaXQgb3IgdW5pdHMgdW5pdHMgKHN1Y2ggYXMgJ2hvdXJzJyBvciAnZGF5cycpIHRvIGluY2x1ZGUgaW4gdGhlIGR1cmF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0aGF0IGFmZmVjdCB0aGUgY3JlYXRpb24gb2YgdGhlIER1cmF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5jb252ZXJzaW9uQWNjdXJhY3k9J2Nhc3VhbCddIC0gdGhlIGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIGRpZmZOb3codW5pdCA9IFwibWlsbGlzZWNvbmRzXCIsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmRpZmYoRGF0ZVRpbWUubm93KCksIHVuaXQsIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBJbnRlcnZhbCBzcGFubmluZyBiZXR3ZWVuIHRoaXMgRGF0ZVRpbWUgYW5kIGFub3RoZXIgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtEYXRlVGltZX0gb3RoZXJEYXRlVGltZSAtIHRoZSBvdGhlciBlbmQgcG9pbnQgb2YgdGhlIEludGVydmFsXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgdW50aWwob3RoZXJEYXRlVGltZSkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHRoaXMsIG90aGVyRGF0ZVRpbWUpIDogdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIERhdGVUaW1lIGlzIGluIHRoZSBzYW1lIHVuaXQgb2YgdGltZSBhcyBhbm90aGVyIERhdGVUaW1lLlxuICAgKiBIaWdoZXItb3JkZXIgdW5pdHMgbXVzdCBhbHNvIGJlIGlkZW50aWNhbCBmb3IgdGhpcyBmdW5jdGlvbiB0byByZXR1cm4gYHRydWVgLlxuICAgKiBOb3RlIHRoYXQgdGltZSB6b25lcyBhcmUgKippZ25vcmVkKiogaW4gdGhpcyBjb21wYXJpc29uLCB3aGljaCBjb21wYXJlcyB0aGUgKipsb2NhbCoqIGNhbGVuZGFyIHRpbWUuIFVzZSB7QGxpbmsgRGF0ZVRpbWUjc2V0Wm9uZX0gdG8gY29udmVydCBvbmUgb2YgdGhlIGRhdGVzIGlmIG5lZWRlZC5cbiAgICogQHBhcmFtIHtEYXRlVGltZX0gb3RoZXJEYXRlVGltZSAtIHRoZSBvdGhlciBEYXRlVGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIHRoZSB1bml0IG9mIHRpbWUgdG8gY2hlY2sgc2FtZW5lc3Mgb25cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkuaGFzU2FtZShvdGhlckRULCAnZGF5Jyk7IC8vfj4gdHJ1ZSBpZiBvdGhlckRUIGlzIGluIHRoZSBzYW1lIGN1cnJlbnQgY2FsZW5kYXIgZGF5XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNTYW1lKG90aGVyRGF0ZVRpbWUsIHVuaXQpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgY29uc3QgaW5wdXRNcyA9IG90aGVyRGF0ZVRpbWUudmFsdWVPZigpO1xuICAgIGNvbnN0IGFkanVzdGVkVG9ab25lID0gdGhpcy5zZXRab25lKG90aGVyRGF0ZVRpbWUuem9uZSwgeyBrZWVwTG9jYWxUaW1lOiB0cnVlIH0pO1xuICAgIHJldHVybiBhZGp1c3RlZFRvWm9uZS5zdGFydE9mKHVuaXQpIDw9IGlucHV0TXMgJiYgaW5wdXRNcyA8PSBhZGp1c3RlZFRvWm9uZS5lbmRPZih1bml0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFcXVhbGl0eSBjaGVja1xuICAgKiBUd28gRGF0ZVRpbWVzIGFyZSBlcXVhbCBpZiBhbmQgb25seSBpZiB0aGV5IHJlcHJlc2VudCB0aGUgc2FtZSBtaWxsaXNlY29uZCwgaGF2ZSB0aGUgc2FtZSB6b25lIGFuZCBsb2NhdGlvbiwgYW5kIGFyZSBib3RoIHZhbGlkLlxuICAgKiBUbyBjb21wYXJlIGp1c3QgdGhlIG1pbGxpc2Vjb25kIHZhbHVlcywgdXNlIGArZHQxID09PSArZHQyYC5cbiAgICogQHBhcmFtIHtEYXRlVGltZX0gb3RoZXIgLSB0aGUgb3RoZXIgRGF0ZVRpbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmlzVmFsaWQgJiZcbiAgICAgIG90aGVyLmlzVmFsaWQgJiZcbiAgICAgIHRoaXMudmFsdWVPZigpID09PSBvdGhlci52YWx1ZU9mKCkgJiZcbiAgICAgIHRoaXMuem9uZS5lcXVhbHMob3RoZXIuem9uZSkgJiZcbiAgICAgIHRoaXMubG9jLmVxdWFscyhvdGhlci5sb2MpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdGhpcyB0aW1lIHJlbGF0aXZlIHRvIG5vdywgc3VjaCBhcyBcImluIHR3byBkYXlzXCIuIENhbiBvbmx5IGludGVybmF0aW9uYWxpemUgaWYgeW91clxuICAgKiBwbGF0Zm9ybSBzdXBwb3J0cyBJbnRsLlJlbGF0aXZlVGltZUZvcm1hdC4gUm91bmRzIGRvd24gYnkgZGVmYXVsdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIHRoYXQgYWZmZWN0IHRoZSBvdXRwdXRcbiAgICogQHBhcmFtIHtEYXRlVGltZX0gW29wdGlvbnMuYmFzZT1EYXRlVGltZS5ub3coKV0gLSB0aGUgRGF0ZVRpbWUgdG8gdXNlIGFzIHRoZSBiYXNpcyB0byB3aGljaCB0aGlzIHRpbWUgaXMgY29tcGFyZWQuIERlZmF1bHRzIHRvIG5vdy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnN0eWxlPVwibG9uZ1wiXSAtIHRoZSBzdHlsZSBvZiB1bml0cywgbXVzdCBiZSBcImxvbmdcIiwgXCJzaG9ydFwiLCBvciBcIm5hcnJvd1wiXG4gICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBvcHRpb25zLnVuaXQgLSB1c2UgYSBzcGVjaWZpYyB1bml0IG9yIGFycmF5IG9mIHVuaXRzOyBpZiBvbWl0dGVkLCBvciBhbiBhcnJheSwgdGhlIG1ldGhvZCB3aWxsIHBpY2sgdGhlIGJlc3QgdW5pdC4gVXNlIGFuIGFycmF5IG9yIG9uZSBvZiBcInllYXJzXCIsIFwicXVhcnRlcnNcIiwgXCJtb250aHNcIiwgXCJ3ZWVrc1wiLCBcImRheXNcIiwgXCJob3Vyc1wiLCBcIm1pbnV0ZXNcIiwgb3IgXCJzZWNvbmRzXCJcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yb3VuZD10cnVlXSAtIHdoZXRoZXIgdG8gcm91bmQgdGhlIG51bWJlcnMgaW4gdGhlIG91dHB1dC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnBhZGRpbmc9MF0gLSBwYWRkaW5nIGluIG1pbGxpc2Vjb25kcy4gVGhpcyBhbGxvd3MgeW91IHRvIHJvdW5kIHVwIHRoZSByZXN1bHQgaWYgaXQgZml0cyBpbnNpZGUgdGhlIHRocmVzaG9sZC4gRG9uJ3QgdXNlIGluIGNvbWJpbmF0aW9uIHdpdGgge3JvdW5kOiBmYWxzZX0gYmVjYXVzZSB0aGUgZGVjaW1hbCBvdXRwdXQgd2lsbCBpbmNsdWRlIHRoZSBwYWRkaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5sb2NhbGUgLSBvdmVycmlkZSB0aGUgbG9jYWxlIG9mIHRoaXMgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubnVtYmVyaW5nU3lzdGVtIC0gb3ZlcnJpZGUgdGhlIG51bWJlcmluZ1N5c3RlbSBvZiB0aGlzIERhdGVUaW1lLiBUaGUgSW50bCBzeXN0ZW0gbWF5IGNob29zZSBub3QgdG8gaG9ub3IgdGhpc1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKHsgZGF5czogMSB9KS50b1JlbGF0aXZlKCkgLy89PiBcImluIDEgZGF5XCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkuc2V0TG9jYWxlKFwiZXNcIikudG9SZWxhdGl2ZSh7IGRheXM6IDEgfSkgLy89PiBcImRlbnRybyBkZSAxIGTDrWFcIlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKHsgZGF5czogMSB9KS50b1JlbGF0aXZlKHsgbG9jYWxlOiBcImZyXCIgfSkgLy89PiBcImRhbnMgMjMgaGV1cmVzXCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkubWludXMoeyBkYXlzOiAyIH0pLnRvUmVsYXRpdmUoKSAvLz0+IFwiMiBkYXlzIGFnb1wiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLm1pbnVzKHsgZGF5czogMiB9KS50b1JlbGF0aXZlKHsgdW5pdDogXCJob3Vyc1wiIH0pIC8vPT4gXCI0OCBob3VycyBhZ29cIlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5taW51cyh7IGhvdXJzOiAzNiB9KS50b1JlbGF0aXZlKHsgcm91bmQ6IGZhbHNlIH0pIC8vPT4gXCIxLjUgZGF5cyBhZ29cIlxuICAgKi9cbiAgdG9SZWxhdGl2ZShvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgYmFzZSA9IG9wdGlvbnMuYmFzZSB8fCBEYXRlVGltZS5mcm9tT2JqZWN0KHt9LCB7IHpvbmU6IHRoaXMuem9uZSB9KSxcbiAgICAgIHBhZGRpbmcgPSBvcHRpb25zLnBhZGRpbmcgPyAodGhpcyA8IGJhc2UgPyAtb3B0aW9ucy5wYWRkaW5nIDogb3B0aW9ucy5wYWRkaW5nKSA6IDA7XG4gICAgbGV0IHVuaXRzID0gW1wieWVhcnNcIiwgXCJtb250aHNcIiwgXCJkYXlzXCIsIFwiaG91cnNcIiwgXCJtaW51dGVzXCIsIFwic2Vjb25kc1wiXTtcbiAgICBsZXQgdW5pdCA9IG9wdGlvbnMudW5pdDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLnVuaXQpKSB7XG4gICAgICB1bml0cyA9IG9wdGlvbnMudW5pdDtcbiAgICAgIHVuaXQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBkaWZmUmVsYXRpdmUoYmFzZSwgdGhpcy5wbHVzKHBhZGRpbmcpLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgbnVtZXJpYzogXCJhbHdheXNcIixcbiAgICAgIHVuaXRzLFxuICAgICAgdW5pdCxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZGF0ZSByZWxhdGl2ZSB0byB0b2RheSwgc3VjaCBhcyBcInllc3RlcmRheVwiIG9yIFwibmV4dCBtb250aFwiLlxuICAgKiBPbmx5IGludGVybmF0aW9uYWxpemVzIG9uIHBsYXRmb3JtcyB0aGF0IHN1cHBvcnRzIEludGwuUmVsYXRpdmVUaW1lRm9ybWF0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgdGhhdCBhZmZlY3QgdGhlIG91dHB1dFxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBbb3B0aW9ucy5iYXNlPURhdGVUaW1lLm5vdygpXSAtIHRoZSBEYXRlVGltZSB0byB1c2UgYXMgdGhlIGJhc2lzIHRvIHdoaWNoIHRoaXMgdGltZSBpcyBjb21wYXJlZC4gRGVmYXVsdHMgdG8gbm93LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5sb2NhbGUgLSBvdmVycmlkZSB0aGUgbG9jYWxlIG9mIHRoaXMgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudW5pdCAtIHVzZSBhIHNwZWNpZmljIHVuaXQ7IGlmIG9taXR0ZWQsIHRoZSBtZXRob2Qgd2lsbCBwaWNrIHRoZSB1bml0LiBVc2Ugb25lIG9mIFwieWVhcnNcIiwgXCJxdWFydGVyc1wiLCBcIm1vbnRoc1wiLCBcIndlZWtzXCIsIG9yIFwiZGF5c1wiXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm51bWJlcmluZ1N5c3RlbSAtIG92ZXJyaWRlIHRoZSBudW1iZXJpbmdTeXN0ZW0gb2YgdGhpcyBEYXRlVGltZS4gVGhlIEludGwgc3lzdGVtIG1heSBjaG9vc2Ugbm90IHRvIGhvbm9yIHRoaXNcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IGRheXM6IDEgfSkudG9SZWxhdGl2ZUNhbGVuZGFyKCkgLy89PiBcInRvbW9ycm93XCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkuc2V0TG9jYWxlKFwiZXNcIikucGx1cyh7IGRheXM6IDEgfSkudG9SZWxhdGl2ZSgpIC8vPT4gXCJcIm1hw7FhbmFcIlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKHsgZGF5czogMSB9KS50b1JlbGF0aXZlQ2FsZW5kYXIoeyBsb2NhbGU6IFwiZnJcIiB9KSAvLz0+IFwiZGVtYWluXCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkubWludXMoeyBkYXlzOiAyIH0pLnRvUmVsYXRpdmVDYWxlbmRhcigpIC8vPT4gXCIyIGRheXMgYWdvXCJcbiAgICovXG4gIHRvUmVsYXRpdmVDYWxlbmRhcihvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIG51bGw7XG5cbiAgICByZXR1cm4gZGlmZlJlbGF0aXZlKG9wdGlvbnMuYmFzZSB8fCBEYXRlVGltZS5mcm9tT2JqZWN0KHt9LCB7IHpvbmU6IHRoaXMuem9uZSB9KSwgdGhpcywge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIG51bWVyaWM6IFwiYXV0b1wiLFxuICAgICAgdW5pdHM6IFtcInllYXJzXCIsIFwibW9udGhzXCIsIFwiZGF5c1wiXSxcbiAgICAgIGNhbGVuZGFyeTogdHJ1ZSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG1pbiBvZiBzZXZlcmFsIGRhdGUgdGltZXNcbiAgICogQHBhcmFtIHsuLi5EYXRlVGltZX0gZGF0ZVRpbWVzIC0gdGhlIERhdGVUaW1lcyBmcm9tIHdoaWNoIHRvIGNob29zZSB0aGUgbWluaW11bVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX0gdGhlIG1pbiBEYXRlVGltZSwgb3IgdW5kZWZpbmVkIGlmIGNhbGxlZCB3aXRoIG5vIGFyZ3VtZW50XG4gICAqL1xuICBzdGF0aWMgbWluKC4uLmRhdGVUaW1lcykge1xuICAgIGlmICghZGF0ZVRpbWVzLmV2ZXJ5KERhdGVUaW1lLmlzRGF0ZVRpbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJtaW4gcmVxdWlyZXMgYWxsIGFyZ3VtZW50cyBiZSBEYXRlVGltZXNcIik7XG4gICAgfVxuICAgIHJldHVybiBiZXN0QnkoZGF0ZVRpbWVzLCAoaSkgPT4gaS52YWx1ZU9mKCksIE1hdGgubWluKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG1heCBvZiBzZXZlcmFsIGRhdGUgdGltZXNcbiAgICogQHBhcmFtIHsuLi5EYXRlVGltZX0gZGF0ZVRpbWVzIC0gdGhlIERhdGVUaW1lcyBmcm9tIHdoaWNoIHRvIGNob29zZSB0aGUgbWF4aW11bVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX0gdGhlIG1heCBEYXRlVGltZSwgb3IgdW5kZWZpbmVkIGlmIGNhbGxlZCB3aXRoIG5vIGFyZ3VtZW50XG4gICAqL1xuICBzdGF0aWMgbWF4KC4uLmRhdGVUaW1lcykge1xuICAgIGlmICghZGF0ZVRpbWVzLmV2ZXJ5KERhdGVUaW1lLmlzRGF0ZVRpbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJtYXggcmVxdWlyZXMgYWxsIGFyZ3VtZW50cyBiZSBEYXRlVGltZXNcIik7XG4gICAgfVxuICAgIHJldHVybiBiZXN0QnkoZGF0ZVRpbWVzLCAoaSkgPT4gaS52YWx1ZU9mKCksIE1hdGgubWF4KTtcbiAgfVxuXG4gIC8vIE1JU0NcblxuICAvKipcbiAgICogRXhwbGFpbiBob3cgYSBzdHJpbmcgd291bGQgYmUgcGFyc2VkIGJ5IGZyb21Gb3JtYXQoKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZtdCAtIHRoZSBmb3JtYXQgdGhlIHN0cmluZyBpcyBleHBlY3RlZCB0byBiZSBpbiAoc2VlIGRlc2NyaXB0aW9uKVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgdGFrZW4gYnkgZnJvbUZvcm1hdCgpXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBmcm9tRm9ybWF0RXhwbGFpbih0ZXh0LCBmbXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgbG9jYWxlID0gbnVsbCwgbnVtYmVyaW5nU3lzdGVtID0gbnVsbCB9ID0gb3B0aW9ucyxcbiAgICAgIGxvY2FsZVRvVXNlID0gTG9jYWxlLmZyb21PcHRzKHtcbiAgICAgICAgbG9jYWxlLFxuICAgICAgICBudW1iZXJpbmdTeXN0ZW0sXG4gICAgICAgIGRlZmF1bHRUb0VOOiB0cnVlLFxuICAgICAgfSk7XG4gICAgcmV0dXJuIGV4cGxhaW5Gcm9tVG9rZW5zKGxvY2FsZVRvVXNlLCB0ZXh0LCBmbXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBmcm9tRm9ybWF0RXhwbGFpbiBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgZnJvbVN0cmluZ0V4cGxhaW4odGV4dCwgZm10LCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gRGF0ZVRpbWUuZnJvbUZvcm1hdEV4cGxhaW4odGV4dCwgZm10LCBvcHRpb25zKTtcbiAgfVxuXG4gIC8vIEZPUk1BVCBQUkVTRVRTXG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgMTAvMTQvMTk4M1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFX1NIT1JUKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVfU0hPUlQ7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnT2N0IDE0LCAxOTgzJ1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFX01FRCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFX01FRDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdGcmksIE9jdCAxNCwgMTk4MydcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURV9NRURfV0lUSF9XRUVLREFZKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVfTUVEX1dJVEhfV0VFS0RBWTtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdPY3RvYmVyIDE0LCAxOTgzJ1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFX0ZVTEwoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURV9GVUxMO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ1R1ZXNkYXksIE9jdG9iZXIgMTQsIDE5ODMnXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVfSFVHRSgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFX0hVR0U7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMDk6MzAgQU0nLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgVElNRV9TSU1QTEUoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuVElNRV9TSU1QTEU7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMDk6MzA6MjMgQU0nLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgVElNRV9XSVRIX1NFQ09ORFMoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuVElNRV9XSVRIX1NFQ09ORFM7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMDk6MzA6MjMgQU0gRURUJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFRJTUVfV0lUSF9TSE9SVF9PRkZTRVQoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuVElNRV9XSVRIX1NIT1JUX09GRlNFVDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMDoyMyBBTSBFYXN0ZXJuIERheWxpZ2h0IFRpbWUnLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgVElNRV9XSVRIX0xPTkdfT0ZGU0VUKCkge1xuICAgIHJldHVybiBGb3JtYXRzLlRJTUVfV0lUSF9MT05HX09GRlNFVDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMCcsIGFsd2F5cyAyNC1ob3VyLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FXzI0X1NJTVBMRSgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FXzI0X1NJTVBMRTtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMDoyMycsIGFsd2F5cyAyNC1ob3VyLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FXzI0X1dJVEhfU0VDT05EUygpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FXzI0X1dJVEhfU0VDT05EUztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMDoyMyBFRFQnLCBhbHdheXMgMjQtaG91ci5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgVElNRV8yNF9XSVRIX1NIT1JUX09GRlNFVCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FXzI0X1dJVEhfU0hPUlRfT0ZGU0VUO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwOjIzIEVhc3Rlcm4gRGF5bGlnaHQgVGltZScsIGFsd2F5cyAyNC1ob3VyLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FXzI0X1dJVEhfTE9OR19PRkZTRVQoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuVElNRV8yNF9XSVRIX0xPTkdfT0ZGU0VUO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzEwLzE0LzE5ODMsIDk6MzAgQU0nLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURVRJTUVfU0hPUlQoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfU0hPUlQ7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMTAvMTQvMTk4MywgOTozMDozMyBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9TSE9SVF9XSVRIX1NFQ09ORFMoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfU0hPUlRfV0lUSF9TRUNPTkRTO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ09jdCAxNCwgMTk4MywgOTozMCBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9NRUQoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfTUVEO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ09jdCAxNCwgMTk4MywgOTozMDozMyBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9NRURfV0lUSF9TRUNPTkRTKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVUSU1FX01FRF9XSVRIX1NFQ09ORFM7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnRnJpLCAxNCBPY3QgMTk4MywgOTozMCBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9NRURfV0lUSF9XRUVLREFZKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVUSU1FX01FRF9XSVRIX1dFRUtEQVk7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnT2N0b2JlciAxNCwgMTk4MywgOTozMCBBTSBFRFQnLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURVRJTUVfRlVMTCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9GVUxMO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ09jdG9iZXIgMTQsIDE5ODMsIDk6MzA6MzMgQU0gRURUJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX0ZVTExfV0lUSF9TRUNPTkRTKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVUSU1FX0ZVTExfV0lUSF9TRUNPTkRTO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ0ZyaWRheSwgT2N0b2JlciAxNCwgMTk4MywgOTozMCBBTSBFYXN0ZXJuIERheWxpZ2h0IFRpbWUnLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURVRJTUVfSFVHRSgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9IVUdFO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ0ZyaWRheSwgT2N0b2JlciAxNCwgMTk4MywgOTozMDozMyBBTSBFYXN0ZXJuIERheWxpZ2h0IFRpbWUnLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURVRJTUVfSFVHRV9XSVRIX1NFQ09ORFMoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfSFVHRV9XSVRIX1NFQ09ORFM7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJpZW5kbHlEYXRlVGltZShkYXRlVGltZWlzaCkge1xuICBpZiAoRGF0ZVRpbWUuaXNEYXRlVGltZShkYXRlVGltZWlzaCkpIHtcbiAgICByZXR1cm4gZGF0ZVRpbWVpc2g7XG4gIH0gZWxzZSBpZiAoZGF0ZVRpbWVpc2ggJiYgZGF0ZVRpbWVpc2gudmFsdWVPZiAmJiBpc051bWJlcihkYXRlVGltZWlzaC52YWx1ZU9mKCkpKSB7XG4gICAgcmV0dXJuIERhdGVUaW1lLmZyb21KU0RhdGUoZGF0ZVRpbWVpc2gpO1xuICB9IGVsc2UgaWYgKGRhdGVUaW1laXNoICYmIHR5cGVvZiBkYXRlVGltZWlzaCA9PT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBEYXRlVGltZS5mcm9tT2JqZWN0KGRhdGVUaW1laXNoKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXG4gICAgICBgVW5rbm93biBkYXRldGltZSBhcmd1bWVudDogJHtkYXRlVGltZWlzaH0sIG9mIHR5cGUgJHt0eXBlb2YgZGF0ZVRpbWVpc2h9YFxuICAgICk7XG4gIH1cbn1cbiIsICIvLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gUXVlcnkgU2V0dGluZ3MgLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmV4cG9ydCBpbnRlcmZhY2UgUXVlcnlTZXR0aW5ncyB7XG4gICAgLyoqIFdoYXQgdG8gcmVuZGVyICdudWxsJyBhcyBpbiB0YWJsZXMuIERlZmF1bHRzIHRvICctJy4gKi9cbiAgICByZW5kZXJOdWxsQXM6IHN0cmluZztcbiAgICAvKiogSWYgZW5hYmxlZCwgdGFza3MgaW4gRGF0YXZpZXcgdmlld3Mgd2lsbCBhdXRvbWF0aWNhbGx5IGhhdmUgdGhlaXIgY29tcGxldGlvbiBkYXRlIGFwcGVuZGVkIHdoZW4gdGhleSBhcmUgY2hlY2tlZC4gKi9cbiAgICB0YXNrQ29tcGxldGlvblRyYWNraW5nOiBib29sZWFuO1xuICAgIC8qKiBJZiBlbmFibGVkLCBhdXRvbWF0aWMgY29tcGxldGlvbnMgd2lsbCB1c2UgZW1vamkgc2hvcnRoYW5kIOKchSBZWVlZLU1NLUREIGluc3RlYWQgb2YgW2NvbXBsZXRpb246OiBkYXRlXS4gKi9cbiAgICB0YXNrQ29tcGxldGlvblVzZUVtb2ppU2hvcnRoYW5kOiBib29sZWFuO1xuICAgIC8qKiBUaGUgbmFtZSBvZiB0aGUgaW5saW5lIGZpZWxkIHRvIGJlIGFkZGVkIGFzIGEgdGFzaydzIGNvbXBsZXRpb24gd2hlbiBjaGVja2VkLiBPbmx5IHVzZWQgaWYgY29tcGxldGlvblRyYWNraW5nIGlzIGVuYWJsZWQgYW5kIGVtb2ppU2hvcnRoYW5kIGlzIG5vdC4gKi9cbiAgICB0YXNrQ29tcGxldGlvblRleHQ6IHN0cmluZztcbiAgICAvKiogRGF0ZSBmb3JtYXQgb2YgdGhlIHRhc2sncyBjb21wbGV0aW9uIHRpbWVzdGFtcC4gT25seSB1c2VkIGlmIGNvbXBsZXRpb25UcmFja2luZyBpcyBlbmFibGVkIGFuZCBlbW9qaVNob3J0aGFuZCBpcyBub3QuICovXG4gICAgdGFza0NvbXBsZXRpb25EYXRlRm9ybWF0OiBzdHJpbmc7XG4gICAgLyoqIFdoZXRoZXIgb3Igbm90IHN1YnRhc2tzIHNob3VsZCBiZSByZWN1cnNpdmVseSBjb21wbGV0ZWQgaW4gYWRkaXRpb24gdG8gdGhlaXIgcGFyZW50IHRhc2suICovXG4gICAgcmVjdXJzaXZlU3ViVGFza0NvbXBsZXRpb246IGJvb2xlYW47XG4gICAgLyoqIElmIHRydWUsIHJlbmRlciBhIG1vZGFsIHdoaWNoIHNob3dzIG5vIHJlc3VsdHMgd2VyZSByZXR1cm5lZC4gKi9cbiAgICB3YXJuT25FbXB0eVJlc3VsdDogYm9vbGVhbjtcbiAgICAvKiogV2hldGhlciBvciBub3QgYXV0b21hdGljIHZpZXcgcmVmcmVzaGluZyBpcyBlbmFibGVkLiAqL1xuICAgIHJlZnJlc2hFbmFibGVkOiBib29sZWFuO1xuICAgIC8qKiBUaGUgaW50ZXJ2YWwgdGhhdCB2aWV3cyBhcmUgcmVmcmVzaGVkLCBieSBkZWZhdWx0LiAqL1xuICAgIHJlZnJlc2hJbnRlcnZhbDogbnVtYmVyO1xuICAgIC8qKiBUaGUgZGVmYXVsdCBmb3JtYXQgdGhhdCBkYXRlcyBhcmUgcmVuZGVyZWQgaW4gKHVzaW5nIGx1eG9uJ3MgbW9tZW50LWxpa2UgZm9ybWF0dGluZykuICovXG4gICAgZGVmYXVsdERhdGVGb3JtYXQ6IHN0cmluZztcbiAgICAvKiogVGhlIGRlZmF1bHQgZm9ybWF0IHRoYXQgZGF0ZS10aW1lcyBhcmUgcmVuZGVyZWQgaW4gKHVzaW5nIGx1eG9ucyBtb21lbnQtbGlrZSBmb3JtYXR0aW5nKS4gKi9cbiAgICBkZWZhdWx0RGF0ZVRpbWVGb3JtYXQ6IHN0cmluZztcbiAgICAvKiogTWF4aW11bSBkZXB0aCB0aGF0IG9iamVjdHMgd2lsbCBiZSBleHBhbmRlZCB3aGVuIGJlaW5nIHJlbmRlcmVkIHJlY3Vyc2l2ZWx5LiAqL1xuICAgIG1heFJlY3Vyc2l2ZVJlbmRlckRlcHRoOiBudW1iZXI7XG4gICAgLyoqIFRoZSBuYW1lIG9mIHRoZSBkZWZhdWx0IElEIGZpZWxkICgnRmlsZScpLiAqL1xuICAgIHRhYmxlSWRDb2x1bW5OYW1lOiBzdHJpbmc7XG4gICAgLyoqIFRoZSBuYW1lIG9mIGRlZmF1bHQgSUQgZmllbGRzIG9uIGdyb3VwZWQgZGF0YSAoJ0dyb3VwJykuICovXG4gICAgdGFibGVHcm91cENvbHVtbk5hbWU6IHN0cmluZztcbiAgICAvKiogSW5jbHVkZSB0aGUgcmVzdWx0IGNvdW50IGFzIHBhcnQgb2YgdGhlIG91dHB1dC4gKi9cbiAgICBzaG93UmVzdWx0Q291bnQ6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX1FVRVJZX1NFVFRJTkdTOiBRdWVyeVNldHRpbmdzID0ge1xuICAgIHJlbmRlck51bGxBczogXCJcXFxcLVwiLFxuICAgIHRhc2tDb21wbGV0aW9uVHJhY2tpbmc6IGZhbHNlLFxuICAgIHRhc2tDb21wbGV0aW9uVXNlRW1vamlTaG9ydGhhbmQ6IGZhbHNlLFxuICAgIHRhc2tDb21wbGV0aW9uVGV4dDogXCJjb21wbGV0aW9uXCIsXG4gICAgdGFza0NvbXBsZXRpb25EYXRlRm9ybWF0OiBcInl5eXktTU0tZGRcIixcbiAgICByZWN1cnNpdmVTdWJUYXNrQ29tcGxldGlvbjogZmFsc2UsXG4gICAgd2Fybk9uRW1wdHlSZXN1bHQ6IHRydWUsXG4gICAgcmVmcmVzaEVuYWJsZWQ6IHRydWUsXG4gICAgcmVmcmVzaEludGVydmFsOiAyNTAwLFxuICAgIGRlZmF1bHREYXRlRm9ybWF0OiBcIk1NTU0gZGQsIHl5eXlcIixcbiAgICBkZWZhdWx0RGF0ZVRpbWVGb3JtYXQ6IFwiaDptbSBhIC0gTU1NTSBkZCwgeXl5eVwiLFxuICAgIG1heFJlY3Vyc2l2ZVJlbmRlckRlcHRoOiA0LFxuXG4gICAgdGFibGVJZENvbHVtbk5hbWU6IFwiRmlsZVwiLFxuICAgIHRhYmxlR3JvdXBDb2x1bW5OYW1lOiBcIkdyb3VwXCIsXG4gICAgc2hvd1Jlc3VsdENvdW50OiB0cnVlLFxufTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBFeHBvcnQgU2V0dGluZ3MgLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5leHBvcnQgaW50ZXJmYWNlIEV4cG9ydFNldHRpbmdzIHtcbiAgICAvKiogV2hldGhlciBvciBub3QgSFRNTCBzaG91bGQgYmUgdXNlZCBmb3IgZm9ybWF0dGluZyBpbiBleHBvcnRzLiAqL1xuICAgIGFsbG93SHRtbDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfRVhQT1JUX1NFVFRJTkdTOiBFeHBvcnRTZXR0aW5ncyA9IHtcbiAgICBhbGxvd0h0bWw6IHRydWUsXG59O1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBHZW5lcmFsIERhdGF2aWV3IFNldHRpbmdzIC8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0YXZpZXdTZXR0aW5ncyBleHRlbmRzIFF1ZXJ5U2V0dGluZ3MsIEV4cG9ydFNldHRpbmdzIHtcbiAgICAvKiogVGhlIHByZWZpeCBmb3IgaW5saW5lIHF1ZXJpZXMgYnkgZGVmYXVsdC4gKi9cbiAgICBpbmxpbmVRdWVyeVByZWZpeDogc3RyaW5nO1xuICAgIC8qKiBUaGUgcHJlZml4IGZvciBpbmxpbmUgSlMgcXVlcmllcyBieSBkZWZhdWx0LiAqL1xuICAgIGlubGluZUpzUXVlcnlQcmVmaXg6IHN0cmluZztcbiAgICAvKiogSWYgdHJ1ZSwgaW5saW5lIHF1ZXJpZXMgYXJlIGFsc28gZXZhbHVhdGVkIGluIGZ1bGwgY29kZWJsb2Nrcy4gKi9cbiAgICBpbmxpbmVRdWVyaWVzSW5Db2RlYmxvY2tzOiBib29sZWFuO1xuICAgIC8qKiBFbmFibGUgb3IgZGlzYWJsZSBleGVjdXRpbmcgRGF0YXZpZXdKUyBxdWVyaWVzLiAqL1xuICAgIGVuYWJsZURhdGF2aWV3SnM6IGJvb2xlYW47XG4gICAgLyoqIEVuYWJsZSBvciBkaXNhYmxlIHJlZ3VsYXIgaW5saW5lIHF1ZXJpZXMuICovXG4gICAgZW5hYmxlSW5saW5lRGF0YXZpZXc6IGJvb2xlYW47XG4gICAgLyoqIEVuYWJsZSBvciBkaXNhYmxlIGV4ZWN1dGluZyBpbmxpbmUgRGF0YXZpZXdKUyBxdWVyaWVzLiAqL1xuICAgIGVuYWJsZUlubGluZURhdGF2aWV3SnM6IGJvb2xlYW47XG4gICAgLyoqIEVuYWJsZSBvciBkaXNhYmxlIHJlbmRlcmluZyBpbmxpbmUgZmllbGRzIHByZXR0aWx5IGluIFJlYWRpbmcgVmlldy4gKi9cbiAgICBwcmV0dHlSZW5kZXJJbmxpbmVGaWVsZHM6IGJvb2xlYW47XG4gICAgLyoqIEVuYWJsZSBvciBkaXNhYmxlIHJlbmRlcmluZyBpbmxpbmUgZmllbGRzIHByZXR0aWx5IGluIExpdmUgUHJldmlldy4gKi9cbiAgICBwcmV0dHlSZW5kZXJJbmxpbmVGaWVsZHNJbkxpdmVQcmV2aWV3OiBib29sZWFuO1xuICAgIC8qKiBUaGUga2V5d29yZCBmb3IgRGF0YXZpZXdKUyBibG9ja3MuICovXG4gICAgZGF0YXZpZXdKc0tleXdvcmQ6IHN0cmluZztcbn1cblxuLyoqIERlZmF1bHQgc2V0dGluZ3MgZm9yIGRhdGF2aWV3IG9uIGluc3RhbGwuICovXG5leHBvcnQgY29uc3QgREVGQVVMVF9TRVRUSU5HUzogRGF0YXZpZXdTZXR0aW5ncyA9IHtcbiAgICAuLi5ERUZBVUxUX1FVRVJZX1NFVFRJTkdTLFxuICAgIC4uLkRFRkFVTFRfRVhQT1JUX1NFVFRJTkdTLFxuICAgIC4uLntcbiAgICAgICAgaW5saW5lUXVlcnlQcmVmaXg6IFwiPVwiLFxuICAgICAgICBpbmxpbmVKc1F1ZXJ5UHJlZml4OiBcIiQ9XCIsXG4gICAgICAgIGlubGluZVF1ZXJpZXNJbkNvZGVibG9ja3M6IHRydWUsXG4gICAgICAgIGVuYWJsZUlubGluZURhdGF2aWV3OiB0cnVlLFxuICAgICAgICBlbmFibGVEYXRhdmlld0pzOiBmYWxzZSxcbiAgICAgICAgZW5hYmxlSW5saW5lRGF0YXZpZXdKczogZmFsc2UsXG4gICAgICAgIHByZXR0eVJlbmRlcklubGluZUZpZWxkczogdHJ1ZSxcbiAgICAgICAgcHJldHR5UmVuZGVySW5saW5lRmllbGRzSW5MaXZlUHJldmlldzogdHJ1ZSxcbiAgICAgICAgZGF0YXZpZXdKc0tleXdvcmQ6IFwiZGF0YXZpZXdqc1wiLFxuICAgIH0sXG59O1xuIiwgIi8qKiBGdW5jdGlvbmFsIHJldHVybiB0eXBlIGZvciBlcnJvciBoYW5kbGluZy4gKi9cbmV4cG9ydCBjbGFzcyBTdWNjZXNzPFQsIEU+IHtcbiAgICBwdWJsaWMgc3VjY2Vzc2Z1bDogdHJ1ZTtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihwdWJsaWMgdmFsdWU6IFQpIHtcbiAgICAgICAgdGhpcy5zdWNjZXNzZnVsID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgbWFwPFU+KGY6IChhOiBUKSA9PiBVKTogUmVzdWx0PFUsIEU+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdWNjZXNzKGYodGhpcy52YWx1ZSkpO1xuICAgIH1cblxuICAgIHB1YmxpYyBmbGF0TWFwPFU+KGY6IChhOiBUKSA9PiBSZXN1bHQ8VSwgRT4pOiBSZXN1bHQ8VSwgRT4ge1xuICAgICAgICByZXR1cm4gZih0aGlzLnZhbHVlKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgbWFwRXJyPFU+KGY6IChlOiBFKSA9PiBVKTogUmVzdWx0PFQsIFU+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMgYXMgYW55IGFzIFJlc3VsdDxULCBVPjtcbiAgICB9XG5cbiAgICBwdWJsaWMgYmltYXA8VDIsIEUyPihzdWNjOiAoYTogVCkgPT4gVDIsIF9mYWlsOiAoYjogRSkgPT4gRTIpOiBSZXN1bHQ8VDIsIEUyPiB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcChzdWNjKSBhcyBhbnk7XG4gICAgfVxuXG4gICAgcHVibGljIG9yRWxzZShfdmFsdWU6IFQpOiBUIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuXG4gICAgcHVibGljIGNhc3Q8VT4oKTogUmVzdWx0PFUsIEU+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMgYXMgYW55O1xuICAgIH1cblxuICAgIHB1YmxpYyBvckVsc2VUaHJvdyhfbWVzc2FnZT86IChlOiBFKSA9PiBzdHJpbmcpOiBUIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxufVxuXG4vKiogRnVuY3Rpb25hbCByZXR1cm4gdHlwZSBmb3IgZXJyb3IgaGFuZGxpbmcuICovXG5leHBvcnQgY2xhc3MgRmFpbHVyZTxULCBFPiB7XG4gICAgcHVibGljIHN1Y2Nlc3NmdWw6IGZhbHNlO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKHB1YmxpYyBlcnJvcjogRSkge1xuICAgICAgICB0aGlzLnN1Y2Nlc3NmdWwgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgbWFwPFU+KF9mOiAoYTogVCkgPT4gVSk6IFJlc3VsdDxVLCBFPiB7XG4gICAgICAgIHJldHVybiB0aGlzIGFzIGFueSBhcyBGYWlsdXJlPFUsIEU+O1xuICAgIH1cblxuICAgIHB1YmxpYyBmbGF0TWFwPFU+KF9mOiAoYTogVCkgPT4gUmVzdWx0PFUsIEU+KTogUmVzdWx0PFUsIEU+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMgYXMgYW55IGFzIEZhaWx1cmU8VSwgRT47XG4gICAgfVxuXG4gICAgcHVibGljIG1hcEVycjxVPihmOiAoZTogRSkgPT4gVSk6IFJlc3VsdDxULCBVPiB7XG4gICAgICAgIHJldHVybiBuZXcgRmFpbHVyZShmKHRoaXMuZXJyb3IpKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYmltYXA8VDIsIEUyPihfc3VjYzogKGE6IFQpID0+IFQyLCBmYWlsOiAoYjogRSkgPT4gRTIpOiBSZXN1bHQ8VDIsIEUyPiB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcEVycihmYWlsKSBhcyBhbnk7XG4gICAgfVxuXG4gICAgcHVibGljIG9yRWxzZSh2YWx1ZTogVCk6IFQge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgcHVibGljIGNhc3Q8VT4oKTogUmVzdWx0PFUsIEU+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMgYXMgYW55O1xuICAgIH1cblxuICAgIHB1YmxpYyBvckVsc2VUaHJvdyhtZXNzYWdlPzogKGU6IEUpID0+IHN0cmluZyk6IFQge1xuICAgICAgICBpZiAobWVzc2FnZSkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UodGhpcy5lcnJvcikpO1xuICAgICAgICBlbHNlIHRocm93IG5ldyBFcnJvcihcIlwiICsgdGhpcy5lcnJvcik7XG4gICAgfVxufVxuXG5leHBvcnQgdHlwZSBSZXN1bHQ8VCwgRT4gPSBTdWNjZXNzPFQsIEU+IHwgRmFpbHVyZTxULCBFPjtcblxuLyoqIE1vbmFkaWMgJ1Jlc3VsdCcgdHlwZSB3aGljaCBlbmNhcHN1bGF0ZXMgd2hldGhlciBhIHByb2NlZHVyZSBzdWNjZWVkZWQgb3IgZmFpbGVkLCBhcyB3ZWxsIGFzIGl0J3MgcmV0dXJuIHZhbHVlLiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBSZXN1bHQge1xuICAgIC8qKiBDb25zdHJ1Y3QgYSBuZXcgc3VjY2VzcyByZXN1bHQgd3JhcHBpbmcgdGhlIGdpdmVuIHZhbHVlLiAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiBzdWNjZXNzPFQsIEU+KHZhbHVlOiBUKTogUmVzdWx0PFQsIEU+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdWNjZXNzKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKiogQ29uc3RydWN0IGEgbmV3IGZhaWx1cmUgdmFsdWUgd3JhcHBpbmcgdGhlIGdpdmVuIGVycm9yLiAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiBmYWlsdXJlPFQsIEU+KGVycm9yOiBFKTogUmVzdWx0PFQsIEU+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBGYWlsdXJlKGVycm9yKTtcbiAgICB9XG5cbiAgICAvKiogSm9pbiB0d28gcmVzdWx0cyB3aXRoIGEgYmktZnVuY3Rpb24gYW5kIHJldHVybiBhIG5ldyByZXN1bHQuICovXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGZsYXRNYXAyPFQxLCBUMiwgTywgRT4oXG4gICAgICAgIGZpcnN0OiBSZXN1bHQ8VDEsIEU+LFxuICAgICAgICBzZWNvbmQ6IFJlc3VsdDxUMiwgRT4sXG4gICAgICAgIGY6IChhOiBUMSwgYjogVDIpID0+IFJlc3VsdDxPLCBFPlxuICAgICk6IFJlc3VsdDxPLCBFPiB7XG4gICAgICAgIGlmIChmaXJzdC5zdWNjZXNzZnVsKSB7XG4gICAgICAgICAgICBpZiAoc2Vjb25kLnN1Y2Nlc3NmdWwpIHJldHVybiBmKGZpcnN0LnZhbHVlLCBzZWNvbmQudmFsdWUpO1xuICAgICAgICAgICAgZWxzZSByZXR1cm4gZmFpbHVyZShzZWNvbmQuZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhaWx1cmUoZmlyc3QuZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEpvaW4gdHdvIHJlc3VsdHMgd2l0aCBhIGJpLWZ1bmN0aW9uIGFuZCByZXR1cm4gYSBuZXcgcmVzdWx0LiAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiBtYXAyPFQxLCBUMiwgTywgRT4oXG4gICAgICAgIGZpcnN0OiBSZXN1bHQ8VDEsIEU+LFxuICAgICAgICBzZWNvbmQ6IFJlc3VsdDxUMiwgRT4sXG4gICAgICAgIGY6IChhOiBUMSwgYjogVDIpID0+IE9cbiAgICApOiBSZXN1bHQ8TywgRT4ge1xuICAgICAgICByZXR1cm4gZmxhdE1hcDIoZmlyc3QsIHNlY29uZCwgKGEsIGIpID0+IHN1Y2Nlc3MoZihhLCBiKSkpO1xuICAgIH1cbn1cbiIsICIhZnVuY3Rpb24obix0KXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz10KCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXSx0KTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzLlBhcnNpbW1vbj10KCk6bi5QYXJzaW1tb249dCgpfShcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZj9zZWxmOnRoaXMsZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24obil7dmFyIHQ9e307ZnVuY3Rpb24gcihlKXtpZih0W2VdKXJldHVybiB0W2VdLmV4cG9ydHM7dmFyIHU9dFtlXT17aTplLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIG5bZV0uY2FsbCh1LmV4cG9ydHMsdSx1LmV4cG9ydHMsciksdS5sPSEwLHUuZXhwb3J0c31yZXR1cm4gci5tPW4sci5jPXQsci5kPWZ1bmN0aW9uKG4sdCxlKXtyLm8obix0KXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sdCx7Y29uZmlndXJhYmxlOiExLGVudW1lcmFibGU6ITAsZ2V0OmV9KX0sci5yPWZ1bmN0aW9uKG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfSxyLm49ZnVuY3Rpb24obil7dmFyIHQ9biYmbi5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIG4uZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gbn07cmV0dXJuIHIuZCh0LFwiYVwiLHQpLHR9LHIubz1mdW5jdGlvbihuLHQpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobix0KX0sci5wPVwiXCIscihyLnM9MCl9KFtmdW5jdGlvbihuLHQscil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gZShuKXtpZighKHRoaXMgaW5zdGFuY2VvZiBlKSlyZXR1cm4gbmV3IGUobik7dGhpcy5fPW59dmFyIHU9ZS5wcm90b3R5cGU7ZnVuY3Rpb24gbyhuLHQpe2Zvcih2YXIgcj0wO3I8bjtyKyspdChyKX1mdW5jdGlvbiBpKG4sdCxyKXtyZXR1cm4gZnVuY3Rpb24obix0KXtvKHQubGVuZ3RoLGZ1bmN0aW9uKHIpe24odFtyXSxyLHQpfSl9KGZ1bmN0aW9uKHIsZSx1KXt0PW4odCxyLGUsdSl9LHIpLHR9ZnVuY3Rpb24gYShuLHQpe3JldHVybiBpKGZ1bmN0aW9uKHQscixlLHUpe3JldHVybiB0LmNvbmNhdChbbihyLGUsdSldKX0sW10sdCl9ZnVuY3Rpb24gZihuLHQpe3ZhciByPXt2OjAsYnVmOnR9O3JldHVybiBvKG4sZnVuY3Rpb24oKXt2YXIgbjtyPXt2OnIudjw8MXwobj1yLmJ1ZixuWzBdPj43KSxidWY6ZnVuY3Rpb24obil7dmFyIHQ9aShmdW5jdGlvbihuLHQscixlKXtyZXR1cm4gbi5jb25jYXQocj09PWUubGVuZ3RoLTE/QnVmZmVyLmZyb20oW3QsMF0pLnJlYWRVSW50MTZCRSgwKTplLnJlYWRVSW50MTZCRShyKSl9LFtdLG4pO3JldHVybiBCdWZmZXIuZnJvbShhKGZ1bmN0aW9uKG4pe3JldHVybihuPDwxJjY1NTM1KT4+OH0sdCkpfShyLmJ1Zil9fSkscn1mdW5jdGlvbiBjKCl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIEJ1ZmZlcn1mdW5jdGlvbiBzKCl7aWYoIWMoKSl0aHJvdyBuZXcgRXJyb3IoXCJCdWZmZXIgZ2xvYmFsIGRvZXMgbm90IGV4aXN0OyBwbGVhc2UgdXNlIHdlYnBhY2sgaWYgeW91IG5lZWQgdG8gcGFyc2UgQnVmZmVycyBpbiB0aGUgYnJvd3Nlci5cIil9ZnVuY3Rpb24gbChuKXtzKCk7dmFyIHQ9aShmdW5jdGlvbihuLHQpe3JldHVybiBuK3R9LDAsbik7aWYodCU4IT0wKXRocm93IG5ldyBFcnJvcihcIlRoZSBiaXRzIFtcIituLmpvaW4oXCIsIFwiKStcIl0gYWRkIHVwIHRvIFwiK3QrXCIgd2hpY2ggaXMgbm90IGFuIGV2ZW4gbnVtYmVyIG9mIGJ5dGVzOyB0aGUgdG90YWwgc2hvdWxkIGJlIGRpdmlzaWJsZSBieSA4XCIpO3ZhciByLHU9dC84LG89KHI9ZnVuY3Rpb24obil7cmV0dXJuIG4+NDh9LGkoZnVuY3Rpb24obix0KXtyZXR1cm4gbnx8KHIodCk/dDpuKX0sbnVsbCxuKSk7aWYobyl0aHJvdyBuZXcgRXJyb3IobytcIiBiaXQgcmFuZ2UgcmVxdWVzdGVkIGV4Y2VlZHMgNDggYml0ICg2IGJ5dGUpIE51bWJlciBtYXguXCIpO3JldHVybiBuZXcgZShmdW5jdGlvbih0LHIpe3ZhciBlPXUrcjtyZXR1cm4gZT50Lmxlbmd0aD94KHIsdS50b1N0cmluZygpK1wiIGJ5dGVzXCIpOmIoZSxpKGZ1bmN0aW9uKG4sdCl7dmFyIHI9Zih0LG4uYnVmKTtyZXR1cm57Y29sbDpuLmNvbGwuY29uY2F0KHIudiksYnVmOnIuYnVmfX0se2NvbGw6W10sYnVmOnQuc2xpY2UocixlKX0sbikuY29sbCl9KX1mdW5jdGlvbiBoKG4sdCl7cmV0dXJuIG5ldyBlKGZ1bmN0aW9uKHIsZSl7cmV0dXJuIHMoKSxlK3Q+ci5sZW5ndGg/eChlLHQrXCIgYnl0ZXMgZm9yIFwiK24pOmIoZSt0LHIuc2xpY2UoZSxlK3QpKX0pfWZ1bmN0aW9uIHAobix0KXtpZihcIm51bWJlclwiIT10eXBlb2Yocj10KXx8TWF0aC5mbG9vcihyKSE9PXJ8fHQ8MHx8dD42KXRocm93IG5ldyBFcnJvcihuK1wiIHJlcXVpcmVzIGludGVnZXIgbGVuZ3RoIGluIHJhbmdlIFswLCA2XS5cIik7dmFyIHJ9ZnVuY3Rpb24gZChuKXtyZXR1cm4gcChcInVpbnRCRVwiLG4pLGgoXCJ1aW50QkUoXCIrbitcIilcIixuKS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQucmVhZFVJbnRCRSgwLG4pfSl9ZnVuY3Rpb24gdihuKXtyZXR1cm4gcChcInVpbnRMRVwiLG4pLGgoXCJ1aW50TEUoXCIrbitcIilcIixuKS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQucmVhZFVJbnRMRSgwLG4pfSl9ZnVuY3Rpb24gZyhuKXtyZXR1cm4gcChcImludEJFXCIsbiksaChcImludEJFKFwiK24rXCIpXCIsbikubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnJlYWRJbnRCRSgwLG4pfSl9ZnVuY3Rpb24gbShuKXtyZXR1cm4gcChcImludExFXCIsbiksaChcImludExFKFwiK24rXCIpXCIsbikubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnJlYWRJbnRMRSgwLG4pfSl9ZnVuY3Rpb24geShuKXtyZXR1cm4gbiBpbnN0YW5jZW9mIGV9ZnVuY3Rpb24gRShuKXtyZXR1cm5cIltvYmplY3QgQXJyYXldXCI9PT17fS50b1N0cmluZy5jYWxsKG4pfWZ1bmN0aW9uIHcobil7cmV0dXJuIGMoKSYmQnVmZmVyLmlzQnVmZmVyKG4pfWZ1bmN0aW9uIGIobix0KXtyZXR1cm57c3RhdHVzOiEwLGluZGV4Om4sdmFsdWU6dCxmdXJ0aGVzdDotMSxleHBlY3RlZDpbXX19ZnVuY3Rpb24geChuLHQpe3JldHVybiBFKHQpfHwodD1bdF0pLHtzdGF0dXM6ITEsaW5kZXg6LTEsdmFsdWU6bnVsbCxmdXJ0aGVzdDpuLGV4cGVjdGVkOnR9fWZ1bmN0aW9uIEIobix0KXtpZighdClyZXR1cm4gbjtpZihuLmZ1cnRoZXN0PnQuZnVydGhlc3QpcmV0dXJuIG47dmFyIHI9bi5mdXJ0aGVzdD09PXQuZnVydGhlc3Q/ZnVuY3Rpb24obix0KXtpZihmdW5jdGlvbigpe2lmKHZvaWQgMCE9PWUuX3N1cHBvcnRzU2V0KXJldHVybiBlLl9zdXBwb3J0c1NldDt2YXIgbj1cInVuZGVmaW5lZFwiIT10eXBlb2YgU2V0O3JldHVybiBlLl9zdXBwb3J0c1NldD1uLG59KCkmJkFycmF5LmZyb20pe2Zvcih2YXIgcj1uZXcgU2V0KG4pLHU9MDt1PHQubGVuZ3RoO3UrKylyLmFkZCh0W3VdKTt2YXIgbz1BcnJheS5mcm9tKHIpO3JldHVybiBvLnNvcnQoKSxvfWZvcih2YXIgaT17fSxhPTA7YTxuLmxlbmd0aDthKyspaVtuW2FdXT0hMDtmb3IodmFyIGY9MDtmPHQubGVuZ3RoO2YrKylpW3RbZl1dPSEwO3ZhciBjPVtdO2Zvcih2YXIgcyBpbiBpKSh7fSkuaGFzT3duUHJvcGVydHkuY2FsbChpLHMpJiZjLnB1c2gocyk7cmV0dXJuIGMuc29ydCgpLGN9KG4uZXhwZWN0ZWQsdC5leHBlY3RlZCk6dC5leHBlY3RlZDtyZXR1cm57c3RhdHVzOm4uc3RhdHVzLGluZGV4Om4uaW5kZXgsdmFsdWU6bi52YWx1ZSxmdXJ0aGVzdDp0LmZ1cnRoZXN0LGV4cGVjdGVkOnJ9fXZhciBqPXt9O2Z1bmN0aW9uIFMobix0KXtpZih3KG4pKXJldHVybntvZmZzZXQ6dCxsaW5lOi0xLGNvbHVtbjotMX07biBpbiBqfHwoaltuXT17fSk7Zm9yKHZhciByPWpbbl0sZT0wLHU9MCxvPTAsaT10O2k+PTA7KXtpZihpIGluIHIpe2U9cltpXS5saW5lLDA9PT1vJiYobz1yW2ldLmxpbmVTdGFydCk7YnJlYWt9KFwiXFxuXCI9PT1uLmNoYXJBdChpKXx8XCJcXHJcIj09PW4uY2hhckF0KGkpJiZcIlxcblwiIT09bi5jaGFyQXQoaSsxKSkmJih1KyssMD09PW8mJihvPWkrMSkpLGktLX12YXIgYT1lK3UsZj10LW87cmV0dXJuIHJbdF09e2xpbmU6YSxsaW5lU3RhcnQ6b30se29mZnNldDp0LGxpbmU6YSsxLGNvbHVtbjpmKzF9fWZ1bmN0aW9uIF8obil7aWYoIXkobikpdGhyb3cgbmV3IEVycm9yKFwibm90IGEgcGFyc2VyOiBcIituKX1mdW5jdGlvbiBMKG4sdCl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIG4/bi5jaGFyQXQodCk6blt0XX1mdW5jdGlvbiBPKG4pe2lmKFwibnVtYmVyXCIhPXR5cGVvZiBuKXRocm93IG5ldyBFcnJvcihcIm5vdCBhIG51bWJlcjogXCIrbil9ZnVuY3Rpb24gayhuKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBuKXRocm93IG5ldyBFcnJvcihcIm5vdCBhIGZ1bmN0aW9uOiBcIituKX1mdW5jdGlvbiBQKG4pe2lmKFwic3RyaW5nXCIhPXR5cGVvZiBuKXRocm93IG5ldyBFcnJvcihcIm5vdCBhIHN0cmluZzogXCIrbil9dmFyIHE9MixBPTMsST04LEY9NSpJLE09NCpJLHo9XCIgIFwiO2Z1bmN0aW9uIFIobix0KXtyZXR1cm4gbmV3IEFycmF5KHQrMSkuam9pbihuKX1mdW5jdGlvbiBVKG4sdCxyKXt2YXIgZT10LW4ubGVuZ3RoO3JldHVybiBlPD0wP246UihyLGUpK259ZnVuY3Rpb24gVyhuLHQscixlKXtyZXR1cm57ZnJvbTpuLXQ+MD9uLXQ6MCx0bzpuK3I+ZT9lOm4rcn19ZnVuY3Rpb24gRChuLHQpe3ZhciByLGUsdSxvLGYsYz10LmluZGV4LHM9Yy5vZmZzZXQsbD0xO2lmKHM9PT1uLmxlbmd0aClyZXR1cm5cIkdvdCB0aGUgZW5kIG9mIHRoZSBpbnB1dFwiO2lmKHcobikpe3ZhciBoPXMtcyVJLHA9cy1oLGQ9VyhoLEYsTStJLG4ubGVuZ3RoKSx2PWEoZnVuY3Rpb24obil7cmV0dXJuIGEoZnVuY3Rpb24obil7cmV0dXJuIFUobi50b1N0cmluZygxNiksMixcIjBcIil9LG4pfSxmdW5jdGlvbihuLHQpe3ZhciByPW4ubGVuZ3RoLGU9W10sdT0wO2lmKHI8PXQpcmV0dXJuW24uc2xpY2UoKV07Zm9yKHZhciBvPTA7bzxyO28rKyllW3VdfHxlLnB1c2goW10pLGVbdV0ucHVzaChuW29dKSwobysxKSV0PT0wJiZ1Kys7cmV0dXJuIGV9KG4uc2xpY2UoZC5mcm9tLGQudG8pLnRvSlNPTigpLmRhdGEsSSkpO289ZnVuY3Rpb24obil7cmV0dXJuIDA9PT1uLmZyb20mJjE9PT1uLnRvP3tmcm9tOm4uZnJvbSx0bzpuLnRvfTp7ZnJvbTpuLmZyb20vSSx0bzpNYXRoLmZsb29yKG4udG8vSSl9fShkKSxlPWgvSSxyPTMqcCxwPj00JiYocis9MSksbD0yLHU9YShmdW5jdGlvbihuKXtyZXR1cm4gbi5sZW5ndGg8PTQ/bi5qb2luKFwiIFwiKTpuLnNsaWNlKDAsNCkuam9pbihcIiBcIikrXCIgIFwiK24uc2xpY2UoNCkuam9pbihcIiBcIil9LHYpLChmPSg4KihvLnRvPjA/by50by0xOm8udG8pKS50b1N0cmluZygxNikubGVuZ3RoKTwyJiYoZj0yKX1lbHNle3ZhciBnPW4uc3BsaXQoL1xcclxcbnxbXFxuXFxyXFx1MjAyOFxcdTIwMjldLyk7cj1jLmNvbHVtbi0xLGU9Yy5saW5lLTEsbz1XKGUscSxBLGcubGVuZ3RoKSx1PWcuc2xpY2Uoby5mcm9tLG8udG8pLGY9by50by50b1N0cmluZygpLmxlbmd0aH12YXIgbT1lLW8uZnJvbTtyZXR1cm4gdyhuKSYmKGY9KDgqKG8udG8+MD9vLnRvLTE6by50bykpLnRvU3RyaW5nKDE2KS5sZW5ndGgpPDImJihmPTIpLGkoZnVuY3Rpb24odCxlLHUpe3ZhciBpLGE9dT09PW0sYz1hP1wiPiBcIjp6O3JldHVybiBpPXcobik/VSgoOCooby5mcm9tK3UpKS50b1N0cmluZygxNiksZixcIjBcIik6VSgoby5mcm9tK3UrMSkudG9TdHJpbmcoKSxmLFwiIFwiKSxbXS5jb25jYXQodCxbYytpK1wiIHwgXCIrZV0sYT9beitSKFwiIFwiLGYpK1wiIHwgXCIrVShcIlwiLHIsXCIgXCIpK1IoXCJeXCIsbCldOltdKX0sW10sdSkuam9pbihcIlxcblwiKX1mdW5jdGlvbiBOKG4sdCl7cmV0dXJuW1wiXFxuXCIsXCItLSBQQVJTSU5HIEZBSUxFRCBcIitSKFwiLVwiLDUwKSxcIlxcblxcblwiLEQobix0KSxcIlxcblxcblwiLChyPXQuZXhwZWN0ZWQsMT09PXIubGVuZ3RoP1wiRXhwZWN0ZWQ6XFxuXFxuXCIrclswXTpcIkV4cGVjdGVkIG9uZSBvZiB0aGUgZm9sbG93aW5nOiBcXG5cXG5cIityLmpvaW4oXCIsIFwiKSksXCJcXG5cIl0uam9pbihcIlwiKTt2YXIgcn1mdW5jdGlvbiBHKG4pe3JldHVybiB2b2lkIDAhPT1uLmZsYWdzP24uZmxhZ3M6W24uZ2xvYmFsP1wiZ1wiOlwiXCIsbi5pZ25vcmVDYXNlP1wiaVwiOlwiXCIsbi5tdWx0aWxpbmU/XCJtXCI6XCJcIixuLnVuaWNvZGU/XCJ1XCI6XCJcIixuLnN0aWNreT9cInlcIjpcIlwiXS5qb2luKFwiXCIpfWZ1bmN0aW9uIEMoKXtmb3IodmFyIG49W10uc2xpY2UuY2FsbChhcmd1bWVudHMpLHQ9bi5sZW5ndGgscj0wO3I8dDtyKz0xKV8obltyXSk7cmV0dXJuIGUoZnVuY3Rpb24ocixlKXtmb3IodmFyIHUsbz1uZXcgQXJyYXkodCksaT0wO2k8dDtpKz0xKXtpZighKHU9QihuW2ldLl8ocixlKSx1KSkuc3RhdHVzKXJldHVybiB1O29baV09dS52YWx1ZSxlPXUuaW5kZXh9cmV0dXJuIEIoYihlLG8pLHUpfSl9ZnVuY3Rpb24gSigpe3ZhciBuPVtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtpZigwPT09bi5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic2VxTWFwIG5lZWRzIGF0IGxlYXN0IG9uZSBhcmd1bWVudFwiKTt2YXIgdD1uLnBvcCgpO3JldHVybiBrKHQpLEMuYXBwbHkobnVsbCxuKS5tYXAoZnVuY3Rpb24obil7cmV0dXJuIHQuYXBwbHkobnVsbCxuKX0pfWZ1bmN0aW9uIFQoKXt2YXIgbj1bXS5zbGljZS5jYWxsKGFyZ3VtZW50cyksdD1uLmxlbmd0aDtpZigwPT09dClyZXR1cm4gWShcInplcm8gYWx0ZXJuYXRlc1wiKTtmb3IodmFyIHI9MDtyPHQ7cis9MSlfKG5bcl0pO3JldHVybiBlKGZ1bmN0aW9uKHQscil7Zm9yKHZhciBlLHU9MDt1PG4ubGVuZ3RoO3UrPTEpaWYoKGU9QihuW3VdLl8odCxyKSxlKSkuc3RhdHVzKXJldHVybiBlO3JldHVybiBlfSl9ZnVuY3Rpb24gVihuLHQpe3JldHVybiBIKG4sdCkub3IoWChbXSkpfWZ1bmN0aW9uIEgobix0KXtyZXR1cm4gXyhuKSxfKHQpLEoobix0LnRoZW4obikubWFueSgpLGZ1bmN0aW9uKG4sdCl7cmV0dXJuW25dLmNvbmNhdCh0KX0pfWZ1bmN0aW9uIEsobil7UChuKTt2YXIgdD1cIidcIituK1wiJ1wiO3JldHVybiBlKGZ1bmN0aW9uKHIsZSl7dmFyIHU9ZStuLmxlbmd0aCxvPXIuc2xpY2UoZSx1KTtyZXR1cm4gbz09PW4/Yih1LG8pOngoZSx0KX0pfWZ1bmN0aW9uIFEobix0KXshZnVuY3Rpb24obil7aWYoIShuIGluc3RhbmNlb2YgUmVnRXhwKSl0aHJvdyBuZXcgRXJyb3IoXCJub3QgYSByZWdleHA6IFwiK24pO2Zvcih2YXIgdD1HKG4pLHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIGU9dC5jaGFyQXQocik7aWYoXCJpXCIhPT1lJiZcIm1cIiE9PWUmJlwidVwiIT09ZSYmXCJzXCIhPT1lKXRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgcmVnZXhwIGZsYWcgXCInK2UrJ1wiOiAnK24pfX0obiksYXJndW1lbnRzLmxlbmd0aD49Mj9PKHQpOnQ9MDt2YXIgcj1mdW5jdGlvbihuKXtyZXR1cm4gUmVnRXhwKFwiXig/OlwiK24uc291cmNlK1wiKVwiLEcobikpfShuKSx1PVwiXCIrbjtyZXR1cm4gZShmdW5jdGlvbihuLGUpe3ZhciBvPXIuZXhlYyhuLnNsaWNlKGUpKTtpZihvKXtpZigwPD10JiZ0PD1vLmxlbmd0aCl7dmFyIGk9b1swXSxhPW9bdF07cmV0dXJuIGIoZStpLmxlbmd0aCxhKX1yZXR1cm4geChlLFwidmFsaWQgbWF0Y2ggZ3JvdXAgKDAgdG8gXCIrby5sZW5ndGgrXCIpIGluIFwiK3UpfXJldHVybiB4KGUsdSl9KX1mdW5jdGlvbiBYKG4pe3JldHVybiBlKGZ1bmN0aW9uKHQscil7cmV0dXJuIGIocixuKX0pfWZ1bmN0aW9uIFkobil7cmV0dXJuIGUoZnVuY3Rpb24odCxyKXtyZXR1cm4geChyLG4pfSl9ZnVuY3Rpb24gWihuKXtpZih5KG4pKXJldHVybiBlKGZ1bmN0aW9uKHQscil7dmFyIGU9bi5fKHQscik7cmV0dXJuIGUuaW5kZXg9cixlLnZhbHVlPVwiXCIsZX0pO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBuKXJldHVybiBaKEsobikpO2lmKG4gaW5zdGFuY2VvZiBSZWdFeHApcmV0dXJuIFooUShuKSk7dGhyb3cgbmV3IEVycm9yKFwibm90IGEgc3RyaW5nLCByZWdleHAsIG9yIHBhcnNlcjogXCIrbil9ZnVuY3Rpb24gJChuKXtyZXR1cm4gXyhuKSxlKGZ1bmN0aW9uKHQscil7dmFyIGU9bi5fKHQsciksdT10LnNsaWNlKHIsZS5pbmRleCk7cmV0dXJuIGUuc3RhdHVzP3gociwnbm90IFwiJyt1KydcIicpOmIocixudWxsKX0pfWZ1bmN0aW9uIG5uKG4pe3JldHVybiBrKG4pLGUoZnVuY3Rpb24odCxyKXt2YXIgZT1MKHQscik7cmV0dXJuIHI8dC5sZW5ndGgmJm4oZSk/YihyKzEsZSk6eChyLFwiYSBjaGFyYWN0ZXIvYnl0ZSBtYXRjaGluZyBcIituKX0pfWZ1bmN0aW9uIHRuKG4sdCl7YXJndW1lbnRzLmxlbmd0aDwyJiYodD1uLG49dm9pZCAwKTt2YXIgcj1lKGZ1bmN0aW9uKG4sZSl7cmV0dXJuIHIuXz10KCkuXyxyLl8obixlKX0pO3JldHVybiBuP3IuZGVzYyhuKTpyfWZ1bmN0aW9uIHJuKCl7cmV0dXJuIFkoXCJmYW50YXN5LWxhbmQvZW1wdHlcIil9dS5wYXJzZT1mdW5jdGlvbihuKXtpZihcInN0cmluZ1wiIT10eXBlb2YgbiYmIXcobikpdGhyb3cgbmV3IEVycm9yKFwiLnBhcnNlIG11c3QgYmUgY2FsbGVkIHdpdGggYSBzdHJpbmcgb3IgQnVmZmVyIGFzIGl0cyBhcmd1bWVudFwiKTt2YXIgdCxyPXRoaXMuc2tpcChhbikuXyhuLDApO3JldHVybiB0PXIuc3RhdHVzP3tzdGF0dXM6ITAsdmFsdWU6ci52YWx1ZX06e3N0YXR1czohMSxpbmRleDpTKG4sci5mdXJ0aGVzdCksZXhwZWN0ZWQ6ci5leHBlY3RlZH0sZGVsZXRlIGpbbl0sdH0sdS50cnlQYXJzZT1mdW5jdGlvbihuKXt2YXIgdD10aGlzLnBhcnNlKG4pO2lmKHQuc3RhdHVzKXJldHVybiB0LnZhbHVlO3ZhciByPU4obix0KSxlPW5ldyBFcnJvcihyKTt0aHJvdyBlLnR5cGU9XCJQYXJzaW1tb25FcnJvclwiLGUucmVzdWx0PXQsZX0sdS5hc3NlcnQ9ZnVuY3Rpb24obix0KXtyZXR1cm4gdGhpcy5jaGFpbihmdW5jdGlvbihyKXtyZXR1cm4gbihyKT9YKHIpOlkodCl9KX0sdS5vcj1mdW5jdGlvbihuKXtyZXR1cm4gVCh0aGlzLG4pfSx1LnRyaW09ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMud3JhcChuLG4pfSx1LndyYXA9ZnVuY3Rpb24obix0KXtyZXR1cm4gSihuLHRoaXMsdCxmdW5jdGlvbihuLHQpe3JldHVybiB0fSl9LHUudGhydT1mdW5jdGlvbihuKXtyZXR1cm4gbih0aGlzKX0sdS50aGVuPWZ1bmN0aW9uKG4pe3JldHVybiBfKG4pLEModGhpcyxuKS5tYXAoZnVuY3Rpb24obil7cmV0dXJuIG5bMV19KX0sdS5tYW55PWZ1bmN0aW9uKCl7dmFyIG49dGhpcztyZXR1cm4gZShmdW5jdGlvbih0LHIpe2Zvcih2YXIgZT1bXSx1PXZvaWQgMDs7KXtpZighKHU9QihuLl8odCxyKSx1KSkuc3RhdHVzKXJldHVybiBCKGIocixlKSx1KTtpZihyPT09dS5pbmRleCl0aHJvdyBuZXcgRXJyb3IoXCJpbmZpbml0ZSBsb29wIGRldGVjdGVkIGluIC5tYW55KCkgcGFyc2VyIC0tLSBjYWxsaW5nIC5tYW55KCkgb24gYSBwYXJzZXIgd2hpY2ggY2FuIGFjY2VwdCB6ZXJvIGNoYXJhY3RlcnMgaXMgdXN1YWxseSB0aGUgY2F1c2VcIik7cj11LmluZGV4LGUucHVzaCh1LnZhbHVlKX19KX0sdS50aWVXaXRoPWZ1bmN0aW9uKG4pe3JldHVybiBQKG4pLHRoaXMubWFwKGZ1bmN0aW9uKHQpe2lmKGZ1bmN0aW9uKG4pe2lmKCFFKG4pKXRocm93IG5ldyBFcnJvcihcIm5vdCBhbiBhcnJheTogXCIrbil9KHQpLHQubGVuZ3RoKXtQKHRbMF0pO2Zvcih2YXIgcj10WzBdLGU9MTtlPHQubGVuZ3RoO2UrKylQKHRbZV0pLHIrPW4rdFtlXTtyZXR1cm4gcn1yZXR1cm5cIlwifSl9LHUudGllPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGllV2l0aChcIlwiKX0sdS50aW1lcz1mdW5jdGlvbihuLHQpe3ZhciByPXRoaXM7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg8MiYmKHQ9biksTyhuKSxPKHQpLGUoZnVuY3Rpb24oZSx1KXtmb3IodmFyIG89W10saT12b2lkIDAsYT12b2lkIDAsZj0wO2Y8bjtmKz0xKXtpZihhPUIoaT1yLl8oZSx1KSxhKSwhaS5zdGF0dXMpcmV0dXJuIGE7dT1pLmluZGV4LG8ucHVzaChpLnZhbHVlKX1mb3IoO2Y8dCYmKGE9QihpPXIuXyhlLHUpLGEpLGkuc3RhdHVzKTtmKz0xKXU9aS5pbmRleCxvLnB1c2goaS52YWx1ZSk7cmV0dXJuIEIoYih1LG8pLGEpfSl9LHUucmVzdWx0PWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLm1hcChmdW5jdGlvbigpe3JldHVybiBufSl9LHUuYXRNb3N0PWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLnRpbWVzKDAsbil9LHUuYXRMZWFzdD1mdW5jdGlvbihuKXtyZXR1cm4gSih0aGlzLnRpbWVzKG4pLHRoaXMubWFueSgpLGZ1bmN0aW9uKG4sdCl7cmV0dXJuIG4uY29uY2F0KHQpfSl9LHUubWFwPWZ1bmN0aW9uKG4pe2sobik7dmFyIHQ9dGhpcztyZXR1cm4gZShmdW5jdGlvbihyLGUpe3ZhciB1PXQuXyhyLGUpO3JldHVybiB1LnN0YXR1cz9CKGIodS5pbmRleCxuKHUudmFsdWUpKSx1KTp1fSl9LHUuY29udHJhbWFwPWZ1bmN0aW9uKG4pe2sobik7dmFyIHQ9dGhpcztyZXR1cm4gZShmdW5jdGlvbihyLGUpe3ZhciB1PXQucGFyc2UobihyLnNsaWNlKGUpKSk7cmV0dXJuIHUuc3RhdHVzP2IoZStyLmxlbmd0aCx1LnZhbHVlKTp1fSl9LHUucHJvbWFwPWZ1bmN0aW9uKG4sdCl7cmV0dXJuIGsobiksayh0KSx0aGlzLmNvbnRyYW1hcChuKS5tYXAodCl9LHUuc2tpcD1mdW5jdGlvbihuKXtyZXR1cm4gQyh0aGlzLG4pLm1hcChmdW5jdGlvbihuKXtyZXR1cm4gblswXX0pfSx1Lm1hcms9ZnVuY3Rpb24oKXtyZXR1cm4gSihlbix0aGlzLGVuLGZ1bmN0aW9uKG4sdCxyKXtyZXR1cm57c3RhcnQ6bix2YWx1ZTp0LGVuZDpyfX0pfSx1Lm5vZGU9ZnVuY3Rpb24obil7cmV0dXJuIEooZW4sdGhpcyxlbixmdW5jdGlvbih0LHIsZSl7cmV0dXJue25hbWU6bix2YWx1ZTpyLHN0YXJ0OnQsZW5kOmV9fSl9LHUuc2VwQnk9ZnVuY3Rpb24obil7cmV0dXJuIFYodGhpcyxuKX0sdS5zZXBCeTE9ZnVuY3Rpb24obil7cmV0dXJuIEgodGhpcyxuKX0sdS5sb29rYWhlYWQ9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuc2tpcChaKG4pKX0sdS5ub3RGb2xsb3dlZEJ5PWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLnNraXAoJChuKSl9LHUuZGVzYz1mdW5jdGlvbihuKXtFKG4pfHwobj1bbl0pO3ZhciB0PXRoaXM7cmV0dXJuIGUoZnVuY3Rpb24ocixlKXt2YXIgdT10Ll8ocixlKTtyZXR1cm4gdS5zdGF0dXN8fCh1LmV4cGVjdGVkPW4pLHV9KX0sdS5mYWxsYmFjaz1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5vcihYKG4pKX0sdS5hcD1mdW5jdGlvbihuKXtyZXR1cm4gSihuLHRoaXMsZnVuY3Rpb24obix0KXtyZXR1cm4gbih0KX0pfSx1LmNoYWluPWZ1bmN0aW9uKG4pe3ZhciB0PXRoaXM7cmV0dXJuIGUoZnVuY3Rpb24ocixlKXt2YXIgdT10Ll8ocixlKTtyZXR1cm4gdS5zdGF0dXM/QihuKHUudmFsdWUpLl8ocix1LmluZGV4KSx1KTp1fSl9LHUuY29uY2F0PXUub3IsdS5lbXB0eT1ybix1Lm9mPVgsdVtcImZhbnRhc3ktbGFuZC9hcFwiXT11LmFwLHVbXCJmYW50YXN5LWxhbmQvY2hhaW5cIl09dS5jaGFpbix1W1wiZmFudGFzeS1sYW5kL2NvbmNhdFwiXT11LmNvbmNhdCx1W1wiZmFudGFzeS1sYW5kL2VtcHR5XCJdPXUuZW1wdHksdVtcImZhbnRhc3ktbGFuZC9vZlwiXT11Lm9mLHVbXCJmYW50YXN5LWxhbmQvbWFwXCJdPXUubWFwO3ZhciBlbj1lKGZ1bmN0aW9uKG4sdCl7cmV0dXJuIGIodCxTKG4sdCkpfSksdW49ZShmdW5jdGlvbihuLHQpe3JldHVybiB0Pj1uLmxlbmd0aD94KHQsXCJhbnkgY2hhcmFjdGVyL2J5dGVcIik6Yih0KzEsTChuLHQpKX0pLG9uPWUoZnVuY3Rpb24obix0KXtyZXR1cm4gYihuLmxlbmd0aCxuLnNsaWNlKHQpKX0pLGFuPWUoZnVuY3Rpb24obix0KXtyZXR1cm4gdDxuLmxlbmd0aD94KHQsXCJFT0ZcIik6Yih0LG51bGwpfSksZm49USgvWzAtOV0vKS5kZXNjKFwiYSBkaWdpdFwiKSxjbj1RKC9bMC05XSovKS5kZXNjKFwib3B0aW9uYWwgZGlnaXRzXCIpLHNuPVEoL1thLXpdL2kpLmRlc2MoXCJhIGxldHRlclwiKSxsbj1RKC9bYS16XSovaSkuZGVzYyhcIm9wdGlvbmFsIGxldHRlcnNcIiksaG49USgvXFxzKi8pLmRlc2MoXCJvcHRpb25hbCB3aGl0ZXNwYWNlXCIpLHBuPVEoL1xccysvKS5kZXNjKFwid2hpdGVzcGFjZVwiKSxkbj1LKFwiXFxyXCIpLHZuPUsoXCJcXG5cIiksZ249SyhcIlxcclxcblwiKSxtbj1UKGduLHZuLGRuKS5kZXNjKFwibmV3bGluZVwiKSx5bj1UKG1uLGFuKTtlLmFsbD1vbixlLmFsdD1ULGUuYW55PXVuLGUuY3I9ZG4sZS5jcmVhdGVMYW5ndWFnZT1mdW5jdGlvbihuKXt2YXIgdD17fTtmb3IodmFyIHIgaW4gbikoe30pLmhhc093blByb3BlcnR5LmNhbGwobixyKSYmZnVuY3Rpb24ocil7dFtyXT10bihmdW5jdGlvbigpe3JldHVybiBuW3JdKHQpfSl9KHIpO3JldHVybiB0fSxlLmNybGY9Z24sZS5jdXN0b209ZnVuY3Rpb24obil7cmV0dXJuIGUobihiLHgpKX0sZS5kaWdpdD1mbixlLmRpZ2l0cz1jbixlLmVtcHR5PXJuLGUuZW5kPXluLGUuZW9mPWFuLGUuZmFpbD1ZLGUuZm9ybWF0RXJyb3I9TixlLmluZGV4PWVuLGUuaXNQYXJzZXI9eSxlLmxhenk9dG4sZS5sZXR0ZXI9c24sZS5sZXR0ZXJzPWxuLGUubGY9dm4sZS5sb29rYWhlYWQ9WixlLm1ha2VGYWlsdXJlPXgsZS5tYWtlU3VjY2Vzcz1iLGUubmV3bGluZT1tbixlLm5vbmVPZj1mdW5jdGlvbihuKXtyZXR1cm4gbm4oZnVuY3Rpb24odCl7cmV0dXJuIG4uaW5kZXhPZih0KTwwfSkuZGVzYyhcIm5vbmUgb2YgJ1wiK24rXCInXCIpfSxlLm5vdEZvbGxvd2VkQnk9JCxlLm9mPVgsZS5vbmVPZj1mdW5jdGlvbihuKXtmb3IodmFyIHQ9bi5zcGxpdChcIlwiKSxyPTA7cjx0Lmxlbmd0aDtyKyspdFtyXT1cIidcIit0W3JdK1wiJ1wiO3JldHVybiBubihmdW5jdGlvbih0KXtyZXR1cm4gbi5pbmRleE9mKHQpPj0wfSkuZGVzYyh0KX0sZS5vcHRXaGl0ZXNwYWNlPWhuLGUuUGFyc2VyPWUsZS5yYW5nZT1mdW5jdGlvbihuLHQpe3JldHVybiBubihmdW5jdGlvbihyKXtyZXR1cm4gbjw9ciYmcjw9dH0pLmRlc2MobitcIi1cIit0KX0sZS5yZWdleD1RLGUucmVnZXhwPVEsZS5zZXBCeT1WLGUuc2VwQnkxPUgsZS5zZXE9QyxlLnNlcU1hcD1KLGUuc2VxT2JqPWZ1bmN0aW9uKCl7Zm9yKHZhciBuLHQ9e30scj0wLHU9KG49YXJndW1lbnRzLEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG4pKSxvPXUubGVuZ3RoLGk9MDtpPG87aSs9MSl7dmFyIGE9dVtpXTtpZigheShhKSl7aWYoRShhKSYmMj09PWEubGVuZ3RoJiZcInN0cmluZ1wiPT10eXBlb2YgYVswXSYmeShhWzFdKSl7dmFyIGY9YVswXTtpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxmKSl0aHJvdyBuZXcgRXJyb3IoXCJzZXFPYmo6IGR1cGxpY2F0ZSBrZXkgXCIrZik7dFtmXT0hMCxyKys7Y29udGludWV9dGhyb3cgbmV3IEVycm9yKFwic2VxT2JqIGFyZ3VtZW50cyBtdXN0IGJlIHBhcnNlcnMgb3IgW3N0cmluZywgcGFyc2VyXSBhcnJheSBwYWlycy5cIil9fWlmKDA9PT1yKXRocm93IG5ldyBFcnJvcihcInNlcU9iaiBleHBlY3RzIGF0IGxlYXN0IG9uZSBuYW1lZCBwYXJzZXIsIGZvdW5kIHplcm9cIik7cmV0dXJuIGUoZnVuY3Rpb24obix0KXtmb3IodmFyIHIsZT17fSxpPTA7aTxvO2krPTEpe3ZhciBhLGY7aWYoRSh1W2ldKT8oYT11W2ldWzBdLGY9dVtpXVsxXSk6KGE9bnVsbCxmPXVbaV0pLCEocj1CKGYuXyhuLHQpLHIpKS5zdGF0dXMpcmV0dXJuIHI7YSYmKGVbYV09ci52YWx1ZSksdD1yLmluZGV4fXJldHVybiBCKGIodCxlKSxyKX0pfSxlLnN0cmluZz1LLGUuc3VjY2VlZD1YLGUudGFrZVdoaWxlPWZ1bmN0aW9uKG4pe3JldHVybiBrKG4pLGUoZnVuY3Rpb24odCxyKXtmb3IodmFyIGU9cjtlPHQubGVuZ3RoJiZuKEwodCxlKSk7KWUrKztyZXR1cm4gYihlLHQuc2xpY2UocixlKSl9KX0sZS50ZXN0PW5uLGUud2hpdGVzcGFjZT1wbixlW1wiZmFudGFzeS1sYW5kL2VtcHR5XCJdPXJuLGVbXCJmYW50YXN5LWxhbmQvb2ZcIl09WCxlLkJpbmFyeT17Yml0U2VxOmwsYml0U2VxT2JqOmZ1bmN0aW9uKG4pe3MoKTt2YXIgdD17fSxyPTAsZT1hKGZ1bmN0aW9uKG4pe2lmKEUobikpe3ZhciBlPW47aWYoMiE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIltcIitlLmpvaW4oXCIsIFwiKStcIl0gc2hvdWxkIGJlIGxlbmd0aCAyLCBnb3QgbGVuZ3RoIFwiK2UubGVuZ3RoKTtpZihQKGVbMF0pLE8oZVsxXSksT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsZVswXSkpdGhyb3cgbmV3IEVycm9yKFwiZHVwbGljYXRlIGtleSBpbiBiaXRTZXFPYmo6IFwiK2VbMF0pO3JldHVybiB0W2VbMF1dPSEwLHIrKyxlfXJldHVybiBPKG4pLFtudWxsLG5dfSxuKTtpZihyPDEpdGhyb3cgbmV3IEVycm9yKFwiYml0U2VxT2JqIGV4cGVjdHMgYXQgbGVhc3Qgb25lIG5hbWVkIHBhaXIsIGdvdCBbXCIrbi5qb2luKFwiLCBcIikrXCJdXCIpO3ZhciB1PWEoZnVuY3Rpb24obil7cmV0dXJuIG5bMF19LGUpO3JldHVybiBsKGEoZnVuY3Rpb24obil7cmV0dXJuIG5bMV19LGUpKS5tYXAoZnVuY3Rpb24obil7cmV0dXJuIGkoZnVuY3Rpb24obix0KXtyZXR1cm4gbnVsbCE9PXRbMF0mJihuW3RbMF1dPXRbMV0pLG59LHt9LGEoZnVuY3Rpb24odCxyKXtyZXR1cm5bdCxuW3JdXX0sdSkpfSl9LGJ5dGU6ZnVuY3Rpb24obil7aWYocygpLE8obiksbj4yNTUpdGhyb3cgbmV3IEVycm9yKFwiVmFsdWUgc3BlY2lmaWVkIHRvIGJ5dGUgY29uc3RydWN0b3IgKFwiK24rXCI9MHhcIituLnRvU3RyaW5nKDE2KStcIikgaXMgbGFyZ2VyIGluIHZhbHVlIHRoYW4gYSBzaW5nbGUgYnl0ZS5cIik7dmFyIHQ9KG4+MTU/XCIweFwiOlwiMHgwXCIpK24udG9TdHJpbmcoMTYpO3JldHVybiBlKGZ1bmN0aW9uKHIsZSl7dmFyIHU9TChyLGUpO3JldHVybiB1PT09bj9iKGUrMSx1KTp4KGUsdCl9KX0sYnVmZmVyOmZ1bmN0aW9uKG4pe3JldHVybiBoKFwiYnVmZmVyXCIsbikubWFwKGZ1bmN0aW9uKG4pe3JldHVybiBCdWZmZXIuZnJvbShuKX0pfSxlbmNvZGVkU3RyaW5nOmZ1bmN0aW9uKG4sdCl7cmV0dXJuIGgoXCJzdHJpbmdcIix0KS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQudG9TdHJpbmcobil9KX0sdWludEJFOmQsdWludDhCRTpkKDEpLHVpbnQxNkJFOmQoMiksdWludDMyQkU6ZCg0KSx1aW50TEU6dix1aW50OExFOnYoMSksdWludDE2TEU6digyKSx1aW50MzJMRTp2KDQpLGludEJFOmcsaW50OEJFOmcoMSksaW50MTZCRTpnKDIpLGludDMyQkU6Zyg0KSxpbnRMRTptLGludDhMRTptKDEpLGludDE2TEU6bSgyKSxpbnQzMkxFOm0oNCksZmxvYXRCRTpoKFwiZmxvYXRCRVwiLDQpLm1hcChmdW5jdGlvbihuKXtyZXR1cm4gbi5yZWFkRmxvYXRCRSgwKX0pLGZsb2F0TEU6aChcImZsb2F0TEVcIiw0KS5tYXAoZnVuY3Rpb24obil7cmV0dXJuIG4ucmVhZEZsb2F0TEUoMCl9KSxkb3VibGVCRTpoKFwiZG91YmxlQkVcIiw4KS5tYXAoZnVuY3Rpb24obil7cmV0dXJuIG4ucmVhZERvdWJsZUJFKDApfSksZG91YmxlTEU6aChcImRvdWJsZUxFXCIsOCkubWFwKGZ1bmN0aW9uKG4pe3JldHVybiBuLnJlYWREb3VibGVMRSgwKX0pfSxuLmV4cG9ydHM9ZX1dKX0pOyIsICJleHBvcnQgZGVmYXVsdCAoKSA9PiB7XG5cdC8vIGh0dHBzOi8vbXRocy5iZS9lbW9qaVxuXHRyZXR1cm4gL1sjKjAtOV1cXHVGRTBGP1xcdTIwRTN8W1xceEE5XFx4QUVcXHUyMDNDXFx1MjA0OVxcdTIxMjJcXHUyMTM5XFx1MjE5NC1cXHUyMTk5XFx1MjFBOVxcdTIxQUFcXHUyMzFBXFx1MjMxQlxcdTIzMjhcXHUyM0NGXFx1MjNFRC1cXHUyM0VGXFx1MjNGMVxcdTIzRjJcXHUyM0Y4LVxcdTIzRkFcXHUyNEMyXFx1MjVBQVxcdTI1QUJcXHUyNUI2XFx1MjVDMFxcdTI1RkJcXHUyNUZDXFx1MjVGRVxcdTI2MDAtXFx1MjYwNFxcdTI2MEVcXHUyNjExXFx1MjYxNFxcdTI2MTVcXHUyNjE4XFx1MjYyMFxcdTI2MjJcXHUyNjIzXFx1MjYyNlxcdTI2MkFcXHUyNjJFXFx1MjYyRlxcdTI2MzgtXFx1MjYzQVxcdTI2NDBcXHUyNjQyXFx1MjY0OC1cXHUyNjUzXFx1MjY1RlxcdTI2NjBcXHUyNjYzXFx1MjY2NVxcdTI2NjZcXHUyNjY4XFx1MjY3QlxcdTI2N0VcXHUyNjdGXFx1MjY5MlxcdTI2OTQtXFx1MjY5N1xcdTI2OTlcXHUyNjlCXFx1MjY5Q1xcdTI2QTBcXHUyNkE3XFx1MjZBQVxcdTI2QjBcXHUyNkIxXFx1MjZCRFxcdTI2QkVcXHUyNkM0XFx1MjZDOFxcdTI2Q0ZcXHUyNkQxXFx1MjZEM1xcdTI2RTlcXHUyNkYwLVxcdTI2RjVcXHUyNkY3XFx1MjZGOFxcdTI2RkFcXHUyNzAyXFx1MjcwOFxcdTI3MDlcXHUyNzBGXFx1MjcxMlxcdTI3MTRcXHUyNzE2XFx1MjcxRFxcdTI3MjFcXHUyNzMzXFx1MjczNFxcdTI3NDRcXHUyNzQ3XFx1Mjc1N1xcdTI3NjNcXHUyN0ExXFx1MjkzNFxcdTI5MzVcXHUyQjA1LVxcdTJCMDdcXHUyQjFCXFx1MkIxQ1xcdTJCNTVcXHUzMDMwXFx1MzAzRFxcdTMyOTdcXHUzMjk5XVxcdUZFMEY/fFtcXHUyNjFEXFx1MjcwQ1xcdTI3MERdKD86XFx1RkUwRnxcXHVEODNDW1xcdURGRkItXFx1REZGRl0pP3xbXFx1MjcwQVxcdTI3MEJdKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKT98W1xcdTIzRTktXFx1MjNFQ1xcdTIzRjBcXHUyM0YzXFx1MjVGRFxcdTI2OTNcXHUyNkExXFx1MjZBQlxcdTI2QzVcXHUyNkNFXFx1MjZENFxcdTI2RUFcXHUyNkZEXFx1MjcwNVxcdTI3MjhcXHUyNzRDXFx1Mjc0RVxcdTI3NTMtXFx1Mjc1NVxcdTI3OTUtXFx1Mjc5N1xcdTI3QjBcXHUyN0JGXFx1MkI1MF18XFx1MjZGOSg/OlxcdUZFMEZ8XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKT8oPzpcXHUyMDBEW1xcdTI2NDBcXHUyNjQyXVxcdUZFMEY/KT98XFx1Mjc2NFxcdUZFMEY/KD86XFx1MjAwRCg/OlxcdUQ4M0RcXHVERDI1fFxcdUQ4M0VcXHVERTc5KSk/fFxcdUQ4M0MoPzpbXFx1REMwNFxcdURENzBcXHVERDcxXFx1REQ3RVxcdUREN0ZcXHVERTAyXFx1REUzN1xcdURGMjFcXHVERjI0LVxcdURGMkNcXHVERjM2XFx1REY3RFxcdURGOTZcXHVERjk3XFx1REY5OS1cXHVERjlCXFx1REY5RVxcdURGOUZcXHVERkNEXFx1REZDRVxcdURGRDQtXFx1REZERlxcdURGRjVcXHVERkY3XVxcdUZFMEY/fFtcXHVERjg1XFx1REZDMlxcdURGQzddKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKT98W1xcdURGQzNcXHVERkM0XFx1REZDQV0oPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pPyg/OlxcdTIwMERbXFx1MjY0MFxcdTI2NDJdXFx1RkUwRj8pP3xbXFx1REZDQlxcdURGQ0NdKD86XFx1RkUwRnxcXHVEODNDW1xcdURGRkItXFx1REZGRl0pPyg/OlxcdTIwMERbXFx1MjY0MFxcdTI2NDJdXFx1RkUwRj8pP3xbXFx1RENDRlxcdUREOEVcXHVERDkxLVxcdUREOUFcXHVERTAxXFx1REUxQVxcdURFMkZcXHVERTMyLVxcdURFMzZcXHVERTM4LVxcdURFM0FcXHVERTUwXFx1REU1MVxcdURGMDAtXFx1REYyMFxcdURGMkQtXFx1REYzNVxcdURGMzctXFx1REY3Q1xcdURGN0UtXFx1REY4NFxcdURGODYtXFx1REY5M1xcdURGQTAtXFx1REZDMVxcdURGQzVcXHVERkM2XFx1REZDOFxcdURGQzlcXHVERkNGLVxcdURGRDNcXHVERkUwLVxcdURGRjBcXHVERkY4LVxcdURGRkZdfFxcdURERTZcXHVEODNDW1xcdURERTgtXFx1RERFQ1xcdURERUVcXHVEREYxXFx1RERGMlxcdURERjRcXHVEREY2LVxcdURERkFcXHVEREZDXFx1RERGRFxcdURERkZdfFxcdURERTdcXHVEODNDW1xcdURERTZcXHVEREU3XFx1RERFOS1cXHVEREVGXFx1RERGMS1cXHVEREY0XFx1RERGNi1cXHVEREY5XFx1RERGQlxcdURERkNcXHVEREZFXFx1RERGRl18XFx1RERFOFxcdUQ4M0NbXFx1RERFNlxcdURERThcXHVEREU5XFx1RERFQi1cXHVEREVFXFx1RERGMC1cXHVEREY1XFx1RERGN1xcdURERkEtXFx1RERGRl18XFx1RERFOVxcdUQ4M0NbXFx1RERFQVxcdURERUNcXHVEREVGXFx1RERGMFxcdURERjJcXHVEREY0XFx1RERGRl18XFx1RERFQVxcdUQ4M0NbXFx1RERFNlxcdURERThcXHVEREVBXFx1RERFQ1xcdURERURcXHVEREY3LVxcdURERkFdfFxcdURERUJcXHVEODNDW1xcdURERUUtXFx1RERGMFxcdURERjJcXHVEREY0XFx1RERGN118XFx1RERFQ1xcdUQ4M0NbXFx1RERFNlxcdURERTdcXHVEREU5LVxcdURERUVcXHVEREYxLVxcdURERjNcXHVEREY1LVxcdURERkFcXHVEREZDXFx1RERGRV18XFx1RERFRFxcdUQ4M0NbXFx1RERGMFxcdURERjJcXHVEREYzXFx1RERGN1xcdURERjlcXHVEREZBXXxcXHVEREVFXFx1RDgzQ1tcXHVEREU4LVxcdURERUFcXHVEREYxLVxcdURERjRcXHVEREY2LVxcdURERjldfFxcdURERUZcXHVEODNDW1xcdURERUFcXHVEREYyXFx1RERGNFxcdURERjVdfFxcdURERjBcXHVEODNDW1xcdURERUFcXHVEREVDLVxcdURERUVcXHVEREYyXFx1RERGM1xcdURERjVcXHVEREY3XFx1RERGQ1xcdURERkVcXHVEREZGXXxcXHVEREYxXFx1RDgzQ1tcXHVEREU2LVxcdURERThcXHVEREVFXFx1RERGMFxcdURERjctXFx1RERGQlxcdURERkVdfFxcdURERjJcXHVEODNDW1xcdURERTZcXHVEREU4LVxcdURERURcXHVEREYwLVxcdURERkZdfFxcdURERjNcXHVEODNDW1xcdURERTZcXHVEREU4XFx1RERFQS1cXHVEREVDXFx1RERFRVxcdURERjFcXHVEREY0XFx1RERGNVxcdURERjdcXHVEREZBXFx1RERGRl18XFx1RERGNFxcdUQ4M0NcXHVEREYyfFxcdURERjVcXHVEODNDW1xcdURERTZcXHVEREVBLVxcdURERURcXHVEREYwLVxcdURERjNcXHVEREY3LVxcdURERjlcXHVEREZDXFx1RERGRV18XFx1RERGNlxcdUQ4M0NcXHVEREU2fFxcdURERjdcXHVEODNDW1xcdURERUFcXHVEREY0XFx1RERGOFxcdURERkFcXHVEREZDXXxcXHVEREY4XFx1RDgzQ1tcXHVEREU2LVxcdURERUFcXHVEREVDLVxcdURERjRcXHVEREY3LVxcdURERjlcXHVEREZCXFx1RERGRC1cXHVEREZGXXxcXHVEREY5XFx1RDgzQ1tcXHVEREU2XFx1RERFOFxcdURERTlcXHVEREVCLVxcdURERURcXHVEREVGLVxcdURERjRcXHVEREY3XFx1RERGOVxcdURERkJcXHVEREZDXFx1RERGRl18XFx1RERGQVxcdUQ4M0NbXFx1RERFNlxcdURERUNcXHVEREYyXFx1RERGM1xcdURERjhcXHVEREZFXFx1RERGRl18XFx1RERGQlxcdUQ4M0NbXFx1RERFNlxcdURERThcXHVEREVBXFx1RERFQ1xcdURERUVcXHVEREYzXFx1RERGQV18XFx1RERGQ1xcdUQ4M0NbXFx1RERFQlxcdURERjhdfFxcdURERkRcXHVEODNDXFx1RERGMHxcXHVEREZFXFx1RDgzQ1tcXHVEREVBXFx1RERGOV18XFx1RERGRlxcdUQ4M0NbXFx1RERFNlxcdURERjJcXHVEREZDXXxcXHVERkYzXFx1RkUwRj8oPzpcXHUyMDBEKD86XFx1MjZBN1xcdUZFMEY/fFxcdUQ4M0NcXHVERjA4KSk/fFxcdURGRjQoPzpcXHUyMDBEXFx1MjYyMFxcdUZFMEY/fFxcdURCNDBcXHVEQzY3XFx1REI0MFxcdURDNjJcXHVEQjQwKD86XFx1REM2NVxcdURCNDBcXHVEQzZFXFx1REI0MFxcdURDNjd8XFx1REM3M1xcdURCNDBcXHVEQzYzXFx1REI0MFxcdURDNzR8XFx1REM3N1xcdURCNDBcXHVEQzZDXFx1REI0MFxcdURDNzMpXFx1REI0MFxcdURDN0YpPyl8XFx1RDgzRCg/OltcXHVEQzA4XFx1REMyNl0oPzpcXHUyMDBEXFx1MkIxQik/fFtcXHVEQzNGXFx1RENGRFxcdURENDlcXHVERDRBXFx1REQ2RlxcdURENzBcXHVERDczXFx1REQ3Ni1cXHVERDc5XFx1REQ4N1xcdUREOEEtXFx1REQ4RFxcdUREQTVcXHVEREE4XFx1RERCMVxcdUREQjJcXHVEREJDXFx1RERDMi1cXHVEREM0XFx1REREMS1cXHVEREQzXFx1REREQy1cXHVERERFXFx1RERFMVxcdURERTNcXHVEREU4XFx1RERFRlxcdURERjNcXHVEREZBXFx1REVDQlxcdURFQ0QtXFx1REVDRlxcdURFRTAtXFx1REVFNVxcdURFRTlcXHVERUYwXFx1REVGM11cXHVGRTBGP3xbXFx1REM0MlxcdURDNDNcXHVEQzQ2LVxcdURDNTBcXHVEQzY2XFx1REM2N1xcdURDNkItXFx1REM2RFxcdURDNzJcXHVEQzc0LVxcdURDNzZcXHVEQzc4XFx1REM3Q1xcdURDODNcXHVEQzg1XFx1REM4RlxcdURDOTFcXHVEQ0FBXFx1REQ3QVxcdUREOTVcXHVERDk2XFx1REU0Q1xcdURFNEZcXHVERUMwXFx1REVDQ10oPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pP3xbXFx1REM2RVxcdURDNzBcXHVEQzcxXFx1REM3M1xcdURDNzdcXHVEQzgxXFx1REM4MlxcdURDODZcXHVEQzg3XFx1REU0NS1cXHVERTQ3XFx1REU0QlxcdURFNERcXHVERTRFXFx1REVBM1xcdURFQjQtXFx1REVCNl0oPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pPyg/OlxcdTIwMERbXFx1MjY0MFxcdTI2NDJdXFx1RkUwRj8pP3xbXFx1REQ3NFxcdUREOTBdKD86XFx1RkUwRnxcXHVEODNDW1xcdURGRkItXFx1REZGRl0pP3xbXFx1REMwMC1cXHVEQzA3XFx1REMwOS1cXHVEQzE0XFx1REMxNi1cXHVEQzI1XFx1REMyNy1cXHVEQzNBXFx1REMzQy1cXHVEQzNFXFx1REM0MFxcdURDNDRcXHVEQzQ1XFx1REM1MS1cXHVEQzY1XFx1REM2QVxcdURDNzktXFx1REM3QlxcdURDN0QtXFx1REM4MFxcdURDODRcXHVEQzg4LVxcdURDOEVcXHVEQzkwXFx1REM5Mi1cXHVEQ0E5XFx1RENBQi1cXHVEQ0ZDXFx1RENGRi1cXHVERDNEXFx1REQ0Qi1cXHVERDRFXFx1REQ1MC1cXHVERDY3XFx1RERBNFxcdURERkItXFx1REUyRFxcdURFMkYtXFx1REUzNFxcdURFMzctXFx1REU0NFxcdURFNDgtXFx1REU0QVxcdURFODAtXFx1REVBMlxcdURFQTQtXFx1REVCM1xcdURFQjctXFx1REVCRlxcdURFQzEtXFx1REVDNVxcdURFRDAtXFx1REVEMlxcdURFRDUtXFx1REVEN1xcdURFREMtXFx1REVERlxcdURFRUJcXHVERUVDXFx1REVGNC1cXHVERUZDXFx1REZFMC1cXHVERkVCXFx1REZGMF18XFx1REMxNSg/OlxcdTIwMERcXHVEODNFXFx1RERCQSk/fFxcdURDM0IoPzpcXHUyMDBEXFx1Mjc0NFxcdUZFMEY/KT98XFx1REM0MVxcdUZFMEY/KD86XFx1MjAwRFxcdUQ4M0RcXHVEREU4XFx1RkUwRj8pP3xcXHVEQzY4KD86XFx1MjAwRCg/OltcXHUyNjk1XFx1MjY5NlxcdTI3MDhdXFx1RkUwRj98XFx1Mjc2NFxcdUZFMEY/XFx1MjAwRFxcdUQ4M0QoPzpcXHVEQzhCXFx1MjAwRFxcdUQ4M0QpP1xcdURDNjh8XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRCg/OltcXHVEQzY4XFx1REM2OV1cXHUyMDBEXFx1RDgzRCg/OlxcdURDNjYoPzpcXHUyMDBEXFx1RDgzRFxcdURDNjYpP3xcXHVEQzY3KD86XFx1MjAwRFxcdUQ4M0RbXFx1REM2NlxcdURDNjddKT8pfFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdURDNjYoPzpcXHUyMDBEXFx1RDgzRFxcdURDNjYpP3xcXHVEQzY3KD86XFx1MjAwRFxcdUQ4M0RbXFx1REM2NlxcdURDNjddKT8pfFxcdUQ4M0VbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdKXxcXHVEODNDKD86XFx1REZGQig/OlxcdTIwMEQoPzpbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XVxcdUZFMEY/fFxcdTI3NjRcXHVGRTBGP1xcdTIwMERcXHVEODNEKD86XFx1REM4QlxcdTIwMERcXHVEODNEKT9cXHVEQzY4XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFKD86W1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXXxcXHVERDFEXFx1MjAwRFxcdUQ4M0RcXHVEQzY4XFx1RDgzQ1tcXHVERkZDLVxcdURGRkZdKSkpP3xcXHVERkZDKD86XFx1MjAwRCg/OltcXHUyNjk1XFx1MjY5NlxcdTI3MDhdXFx1RkUwRj98XFx1Mjc2NFxcdUZFMEY/XFx1MjAwRFxcdUQ4M0QoPzpcXHVEQzhCXFx1MjAwRFxcdUQ4M0QpP1xcdURDNjhcXHVEODNDW1xcdURGRkItXFx1REZGRl18XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0UoPzpbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdfFxcdUREMURcXHUyMDBEXFx1RDgzRFxcdURDNjhcXHVEODNDW1xcdURGRkJcXHVERkZELVxcdURGRkZdKSkpP3xcXHVERkZEKD86XFx1MjAwRCg/OltcXHUyNjk1XFx1MjY5NlxcdTI3MDhdXFx1RkUwRj98XFx1Mjc2NFxcdUZFMEY/XFx1MjAwRFxcdUQ4M0QoPzpcXHVEQzhCXFx1MjAwRFxcdUQ4M0QpP1xcdURDNjhcXHVEODNDW1xcdURGRkItXFx1REZGRl18XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0UoPzpbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdfFxcdUREMURcXHUyMDBEXFx1RDgzRFxcdURDNjhcXHVEODNDW1xcdURGRkJcXHVERkZDXFx1REZGRVxcdURGRkZdKSkpP3xcXHVERkZFKD86XFx1MjAwRCg/OltcXHUyNjk1XFx1MjY5NlxcdTI3MDhdXFx1RkUwRj98XFx1Mjc2NFxcdUZFMEY/XFx1MjAwRFxcdUQ4M0QoPzpcXHVEQzhCXFx1MjAwRFxcdUQ4M0QpP1xcdURDNjhcXHVEODNDW1xcdURGRkItXFx1REZGRl18XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0UoPzpbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdfFxcdUREMURcXHUyMDBEXFx1RDgzRFxcdURDNjhcXHVEODNDW1xcdURGRkItXFx1REZGRFxcdURGRkZdKSkpP3xcXHVERkZGKD86XFx1MjAwRCg/OltcXHUyNjk1XFx1MjY5NlxcdTI3MDhdXFx1RkUwRj98XFx1Mjc2NFxcdUZFMEY/XFx1MjAwRFxcdUQ4M0QoPzpcXHVEQzhCXFx1MjAwRFxcdUQ4M0QpP1xcdURDNjhcXHVEODNDW1xcdURGRkItXFx1REZGRl18XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0UoPzpbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdfFxcdUREMURcXHUyMDBEXFx1RDgzRFxcdURDNjhcXHVEODNDW1xcdURGRkItXFx1REZGRV0pKSk/KSk/fFxcdURDNjkoPzpcXHUyMDBEKD86W1xcdTI2OTVcXHUyNjk2XFx1MjcwOF1cXHVGRTBGP3xcXHUyNzY0XFx1RkUwRj9cXHUyMDBEXFx1RDgzRCg/OlxcdURDOEJcXHUyMDBEXFx1RDgzRCk/W1xcdURDNjhcXHVEQzY5XXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEKD86W1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1REM2Nig/OlxcdTIwMERcXHVEODNEXFx1REM2Nik/fFxcdURDNjcoPzpcXHUyMDBEXFx1RDgzRFtcXHVEQzY2XFx1REM2N10pP3xcXHVEQzY5XFx1MjAwRFxcdUQ4M0QoPzpcXHVEQzY2KD86XFx1MjAwRFxcdUQ4M0RcXHVEQzY2KT98XFx1REM2Nyg/OlxcdTIwMERcXHVEODNEW1xcdURDNjZcXHVEQzY3XSk/KSl8XFx1RDgzRVtcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF0pfFxcdUQ4M0MoPzpcXHVERkZCKD86XFx1MjAwRCg/OltcXHUyNjk1XFx1MjY5NlxcdTI3MDhdXFx1RkUwRj98XFx1Mjc2NFxcdUZFMEY/XFx1MjAwRFxcdUQ4M0QoPzpbXFx1REM2OFxcdURDNjldfFxcdURDOEJcXHUyMDBEXFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pXFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFKD86W1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXXxcXHVERDFEXFx1MjAwRFxcdUQ4M0RbXFx1REM2OFxcdURDNjldXFx1RDgzQ1tcXHVERkZDLVxcdURGRkZdKSkpP3xcXHVERkZDKD86XFx1MjAwRCg/OltcXHUyNjk1XFx1MjY5NlxcdTI3MDhdXFx1RkUwRj98XFx1Mjc2NFxcdUZFMEY/XFx1MjAwRFxcdUQ4M0QoPzpbXFx1REM2OFxcdURDNjldfFxcdURDOEJcXHUyMDBEXFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pXFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFKD86W1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXXxcXHVERDFEXFx1MjAwRFxcdUQ4M0RbXFx1REM2OFxcdURDNjldXFx1RDgzQ1tcXHVERkZCXFx1REZGRC1cXHVERkZGXSkpKT98XFx1REZGRCg/OlxcdTIwMEQoPzpbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XVxcdUZFMEY/fFxcdTI3NjRcXHVGRTBGP1xcdTIwMERcXHVEODNEKD86W1xcdURDNjhcXHVEQzY5XXxcXHVEQzhCXFx1MjAwRFxcdUQ4M0RbXFx1REM2OFxcdURDNjldKVxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRSg/OltcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF18XFx1REQxRFxcdTIwMERcXHVEODNEW1xcdURDNjhcXHVEQzY5XVxcdUQ4M0NbXFx1REZGQlxcdURGRkNcXHVERkZFXFx1REZGRl0pKSk/fFxcdURGRkUoPzpcXHUyMDBEKD86W1xcdTI2OTVcXHUyNjk2XFx1MjcwOF1cXHVGRTBGP3xcXHUyNzY0XFx1RkUwRj9cXHUyMDBEXFx1RDgzRCg/OltcXHVEQzY4XFx1REM2OV18XFx1REM4QlxcdTIwMERcXHVEODNEW1xcdURDNjhcXHVEQzY5XSlcXHVEODNDW1xcdURGRkItXFx1REZGRl18XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0UoPzpbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdfFxcdUREMURcXHUyMDBEXFx1RDgzRFtcXHVEQzY4XFx1REM2OV1cXHVEODNDW1xcdURGRkItXFx1REZGRFxcdURGRkZdKSkpP3xcXHVERkZGKD86XFx1MjAwRCg/OltcXHUyNjk1XFx1MjY5NlxcdTI3MDhdXFx1RkUwRj98XFx1Mjc2NFxcdUZFMEY/XFx1MjAwRFxcdUQ4M0QoPzpbXFx1REM2OFxcdURDNjldfFxcdURDOEJcXHUyMDBEXFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pXFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFKD86W1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXXxcXHVERDFEXFx1MjAwRFxcdUQ4M0RbXFx1REM2OFxcdURDNjldXFx1RDgzQ1tcXHVERkZCLVxcdURGRkVdKSkpPykpP3xcXHVEQzZGKD86XFx1MjAwRFtcXHUyNjQwXFx1MjY0Ml1cXHVGRTBGPyk/fFxcdURENzUoPzpcXHVGRTBGfFxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSk/KD86XFx1MjAwRFtcXHUyNjQwXFx1MjY0Ml1cXHVGRTBGPyk/fFxcdURFMkUoPzpcXHUyMDBEXFx1RDgzRFxcdURDQTgpP3xcXHVERTM1KD86XFx1MjAwRFxcdUQ4M0RcXHVEQ0FCKT98XFx1REUzNig/OlxcdTIwMERcXHVEODNDXFx1REYyQlxcdUZFMEY/KT8pfFxcdUQ4M0UoPzpbXFx1REQwQ1xcdUREMEZcXHVERDE4LVxcdUREMUZcXHVERDMwLVxcdUREMzRcXHVERDM2XFx1REQ3N1xcdUREQjVcXHVEREI2XFx1RERCQlxcdURERDJcXHVEREQzXFx1RERENVxcdURFQzMtXFx1REVDNVxcdURFRjBcXHVERUYyLVxcdURFRjhdKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKT98W1xcdUREMjZcXHVERDM1XFx1REQzNy1cXHVERDM5XFx1REQzRFxcdUREM0VcXHVEREI4XFx1RERCOVxcdUREQ0QtXFx1RERDRlxcdURERDRcXHVEREQ2LVxcdURERERdKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKT8oPzpcXHUyMDBEW1xcdTI2NDBcXHUyNjQyXVxcdUZFMEY/KT98W1xcdUREREVcXHVERERGXSg/OlxcdTIwMERbXFx1MjY0MFxcdTI2NDJdXFx1RkUwRj8pP3xbXFx1REQwRFxcdUREMEVcXHVERDEwLVxcdUREMTdcXHVERDIwLVxcdUREMjVcXHVERDI3LVxcdUREMkZcXHVERDNBXFx1REQzRi1cXHVERDQ1XFx1REQ0Ny1cXHVERDc2XFx1REQ3OC1cXHVEREI0XFx1RERCN1xcdUREQkFcXHVEREJDLVxcdUREQ0NcXHVEREQwXFx1RERFMC1cXHVEREZGXFx1REU3MC1cXHVERTdDXFx1REU4MC1cXHVERTg4XFx1REU5MC1cXHVERUJEXFx1REVCRi1cXHVERUMyXFx1REVDRS1cXHVERURCXFx1REVFMC1cXHVERUU4XXxcXHVERDNDKD86XFx1MjAwRFtcXHUyNjQwXFx1MjY0Ml1cXHVGRTBGP3xcXHVEODNDW1xcdURGRkItXFx1REZGRl0pP3xcXHVEREQxKD86XFx1MjAwRCg/OltcXHUyNjk1XFx1MjY5NlxcdTI3MDhdXFx1RkUwRj98XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjg0XFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFKD86W1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXXxcXHVERDFEXFx1MjAwRFxcdUQ4M0VcXHVEREQxKSl8XFx1RDgzQyg/OlxcdURGRkIoPzpcXHUyMDBEKD86W1xcdTI2OTVcXHUyNjk2XFx1MjcwOF1cXHVGRTBGP3xcXHUyNzY0XFx1RkUwRj9cXHUyMDBEKD86XFx1RDgzRFxcdURDOEJcXHUyMDBEKT9cXHVEODNFXFx1REREMVxcdUQ4M0NbXFx1REZGQy1cXHVERkZGXXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGODRcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0UoPzpbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdfFxcdUREMURcXHUyMDBEXFx1RDgzRVxcdURERDFcXHVEODNDW1xcdURGRkItXFx1REZGRl0pKSk/fFxcdURGRkMoPzpcXHUyMDBEKD86W1xcdTI2OTVcXHUyNjk2XFx1MjcwOF1cXHVGRTBGP3xcXHUyNzY0XFx1RkUwRj9cXHUyMDBEKD86XFx1RDgzRFxcdURDOEJcXHUyMDBEKT9cXHVEODNFXFx1REREMVxcdUQ4M0NbXFx1REZGQlxcdURGRkQtXFx1REZGRl18XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjg0XFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFKD86W1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXXxcXHVERDFEXFx1MjAwRFxcdUQ4M0VcXHVEREQxXFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKSkpP3xcXHVERkZEKD86XFx1MjAwRCg/OltcXHUyNjk1XFx1MjY5NlxcdTI3MDhdXFx1RkUwRj98XFx1Mjc2NFxcdUZFMEY/XFx1MjAwRCg/OlxcdUQ4M0RcXHVEQzhCXFx1MjAwRCk/XFx1RDgzRVxcdURERDFcXHVEODNDW1xcdURGRkJcXHVERkZDXFx1REZGRVxcdURGRkZdfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY4NFxcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRSg/OltcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF18XFx1REQxRFxcdTIwMERcXHVEODNFXFx1REREMVxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSkpKT98XFx1REZGRSg/OlxcdTIwMEQoPzpbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XVxcdUZFMEY/fFxcdTI3NjRcXHVGRTBGP1xcdTIwMEQoPzpcXHVEODNEXFx1REM4QlxcdTIwMEQpP1xcdUQ4M0VcXHVEREQxXFx1RDgzQ1tcXHVERkZCLVxcdURGRkRcXHVERkZGXXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGODRcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0UoPzpbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdfFxcdUREMURcXHUyMDBEXFx1RDgzRVxcdURERDFcXHVEODNDW1xcdURGRkItXFx1REZGRl0pKSk/fFxcdURGRkYoPzpcXHUyMDBEKD86W1xcdTI2OTVcXHUyNjk2XFx1MjcwOF1cXHVGRTBGP3xcXHUyNzY0XFx1RkUwRj9cXHUyMDBEKD86XFx1RDgzRFxcdURDOEJcXHUyMDBEKT9cXHVEODNFXFx1REREMVxcdUQ4M0NbXFx1REZGQi1cXHVERkZFXXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGODRcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0UoPzpbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdfFxcdUREMURcXHUyMDBEXFx1RDgzRVxcdURERDFcXHVEODNDW1xcdURGRkItXFx1REZGRl0pKSk/KSk/fFxcdURFRjEoPzpcXHVEODNDKD86XFx1REZGQig/OlxcdTIwMERcXHVEODNFXFx1REVGMlxcdUQ4M0NbXFx1REZGQy1cXHVERkZGXSk/fFxcdURGRkMoPzpcXHUyMDBEXFx1RDgzRVxcdURFRjJcXHVEODNDW1xcdURGRkJcXHVERkZELVxcdURGRkZdKT98XFx1REZGRCg/OlxcdTIwMERcXHVEODNFXFx1REVGMlxcdUQ4M0NbXFx1REZGQlxcdURGRkNcXHVERkZFXFx1REZGRl0pP3xcXHVERkZFKD86XFx1MjAwRFxcdUQ4M0VcXHVERUYyXFx1RDgzQ1tcXHVERkZCLVxcdURGRkRcXHVERkZGXSk/fFxcdURGRkYoPzpcXHUyMDBEXFx1RDgzRVxcdURFRjJcXHVEODNDW1xcdURGRkItXFx1REZGRV0pPykpPykvZztcbn07XG4iLCAiaW1wb3J0IHsgRGF0ZVRpbWUsIER1cmF0aW9uIH0gZnJvbSBcImx1eG9uXCI7XG5pbXBvcnQgeyBSZXN1bHQgfSBmcm9tIFwiYXBpL3Jlc3VsdFwiO1xuaW1wb3J0ICogYXMgUCBmcm9tIFwicGFyc2ltbW9uXCI7XG5pbXBvcnQgZW1vamlSZWdleCBmcm9tIFwiZW1vamktcmVnZXhcIjtcbmltcG9ydCB7IFF1ZXJ5U2V0dGluZ3MgfSBmcm9tIFwic2V0dGluZ3NcIjtcblxuLyoqIE5vcm1hbGl6ZSBhIGR1cmF0aW9uIHRvIGFsbCBvZiB0aGUgcHJvcGVyIHVuaXRzLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZUR1cmF0aW9uKGR1cjogRHVyYXRpb24pIHtcbiAgICBpZiAoZHVyID09PSB1bmRlZmluZWQgfHwgZHVyID09PSBudWxsKSByZXR1cm4gZHVyO1xuXG4gICAgcmV0dXJuIGR1ci5zaGlmdFRvQWxsKCkubm9ybWFsaXplKCk7XG59XG5cbi8qKiBTdHJpcCB0aGUgdGltZSBjb21wb25lbnRzIG9mIGEgZGF0ZSB0aW1lIG9iamVjdC4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpcFRpbWUoZHQ6IERhdGVUaW1lKTogRGF0ZVRpbWUge1xuICAgIGlmIChkdCA9PT0gbnVsbCB8fCBkdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZHQ7XG5cbiAgICByZXR1cm4gRGF0ZVRpbWUuZnJvbU9iamVjdCh7XG4gICAgICAgIHllYXI6IGR0LnllYXIsXG4gICAgICAgIG1vbnRoOiBkdC5tb250aCxcbiAgICAgICAgZGF5OiBkdC5kYXksXG4gICAgfSk7XG59XG5cbi8qKiBUcnkgdG8gZXh0cmFjdCBhIFlZWVlNTUREIGRhdGUgZnJvbSBhIHN0cmluZy4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0RGF0ZShzdHI6IHN0cmluZyk6IERhdGVUaW1lIHwgdW5kZWZpbmVkIHtcbiAgICBsZXQgZGF0ZU1hdGNoID0gLyhcXGR7NH0pLShcXGR7Mn0pLShcXGR7Mn0pLy5leGVjKHN0cik7XG4gICAgaWYgKCFkYXRlTWF0Y2gpIGRhdGVNYXRjaCA9IC8oXFxkezR9KShcXGR7Mn0pKFxcZHsyfSkvLmV4ZWMoc3RyKTtcbiAgICBpZiAoZGF0ZU1hdGNoKSB7XG4gICAgICAgIGxldCB5ZWFyID0gTnVtYmVyLnBhcnNlSW50KGRhdGVNYXRjaFsxXSk7XG4gICAgICAgIGxldCBtb250aCA9IE51bWJlci5wYXJzZUludChkYXRlTWF0Y2hbMl0pO1xuICAgICAgICBsZXQgZGF5ID0gTnVtYmVyLnBhcnNlSW50KGRhdGVNYXRjaFszXSk7XG4gICAgICAgIHJldHVybiBEYXRlVGltZS5mcm9tT2JqZWN0KHsgeWVhciwgbW9udGgsIGRheSB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKiogR2V0IHRoZSBmb2xkZXIgY29udGFpbmluZyB0aGUgZ2l2ZW4gcGF0aCAoaS5lLiwgbGlrZSBjb21wdXRpbmcgJ3BhdGgvLi4nKS4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXJlbnRGb2xkZXIocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gcGF0aC5zcGxpdChcIi9cIikuc2xpY2UoMCwgLTEpLmpvaW4oXCIvXCIpO1xufVxuXG4vKiogR2V0IHRoZSBmaWxlIG5hbWUgZm9yIHRoZSBmaWxlIHJlZmVyZW5jZWQgaW4gdGhlIGdpdmVuIHBhdGgsIGJ5IHN0cmlwcGluZyB0aGUgcGFyZW50IGZvbGRlcnMuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmlsZU5hbWUocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gcGF0aC5pbmNsdWRlcyhcIi9cIikgPyBwYXRoLnN1YnN0cmluZyhwYXRoLmxhc3RJbmRleE9mKFwiL1wiKSArIDEpIDogcGF0aDtcbn1cblxuLyoqIEdldCB0aGUgXCJ0aXRsZVwiIGZvciBhIGZpbGUsIGJ5IHN0cmlwcGluZyBvdGhlciBwYXJ0cyBvZiB0aGUgcGF0aCBhcyB3ZWxsIGFzIHRoZSBleHRlbnNpb24uICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmlsZVRpdGxlKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgaWYgKHBhdGguaW5jbHVkZXMoXCIvXCIpKSBwYXRoID0gcGF0aC5zdWJzdHJpbmcocGF0aC5sYXN0SW5kZXhPZihcIi9cIikgKyAxKTtcbiAgICBpZiAocGF0aC5lbmRzV2l0aChcIi5tZFwiKSkgcGF0aCA9IHBhdGguc3Vic3RyaW5nKDAsIHBhdGgubGVuZ3RoIC0gMyk7XG4gICAgcmV0dXJuIHBhdGg7XG59XG5cbi8qKiBHZXQgdGhlIGV4dGVuc2lvbiBvZiBhIGZpbGUgZnJvbSB0aGUgZmlsZSBwYXRoLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEV4dGVuc2lvbihwYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmICghcGF0aC5pbmNsdWRlcyhcIi5cIikpIHJldHVybiBcIlwiO1xuICAgIHJldHVybiBwYXRoLnN1YnN0cmluZyhwYXRoLmxhc3RJbmRleE9mKFwiLlwiKSArIDEpO1xufVxuXG4vKiogUGFyc2UgYWxsIHN1YnRhZ3Mgb3V0IG9mIHRoZSBnaXZlbiB0YWcuIEkuZS4sICNoZWxsby9pL2FtIHdvdWxkIHlpZWxkIFsjaGVsbG8vaS9hbSwgI2hlbGxvL2ksICNoZWxsb10uICovXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFN1YnRhZ3ModGFnOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgbGV0IHJlc3VsdCA9IFt0YWddO1xuICAgIHdoaWxlICh0YWcuaW5jbHVkZXMoXCIvXCIpKSB7XG4gICAgICAgIHRhZyA9IHRhZy5zdWJzdHJpbmcoMCwgdGFnLmxhc3RJbmRleE9mKFwiL1wiKSk7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRhZyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqIFRyeSBjYWxsaW5nIHRoZSBnaXZlbiBmdW5jdGlvbjsgb24gZmFpbHVyZSwgcmV0dXJuIHRoZSBlcnJvciBtZXNzYWdlLiAgKi9cbmV4cG9ydCBmdW5jdGlvbiB0cnlPclByb3BvZ2F0ZTxUPihmdW5jOiAoKSA9PiBSZXN1bHQ8VCwgc3RyaW5nPik6IFJlc3VsdDxULCBzdHJpbmc+IHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZnVuYygpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBSZXN1bHQuZmFpbHVyZShcIlwiICsgZXJyb3IgKyBcIlxcblxcblwiICsgZXJyb3Iuc3RhY2spO1xuICAgIH1cbn1cblxuLyoqIFRyeSBhc3luY2hyb25vdXNseSBjYWxsaW5nIHRoZSBnaXZlbiBmdW5jdGlvbjsgb24gZmFpbHVyZSwgcmV0dXJuIHRoZSBlcnJvciBtZXNzYWdlLiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFzeW5jVHJ5T3JQcm9wb2dhdGU8VD4oZnVuYzogKCkgPT4gUHJvbWlzZTxSZXN1bHQ8VCwgc3RyaW5nPj4pOiBQcm9taXNlPFJlc3VsdDxULCBzdHJpbmc+PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGZ1bmMoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gUmVzdWx0LmZhaWx1cmUoXCJcIiArIGVycm9yICsgXCJcXG5cXG5cIiArIGVycm9yLnN0YWNrKTtcbiAgICB9XG59XG5cbi8qKlxuICogRXNjYXBlIHJlZ2V4IGNoYXJhY3RlcnMgaW4gYSBzdHJpbmcuXG4gKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9HdWlkZS9SZWd1bGFyX0V4cHJlc3Npb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlUmVnZXgoc3RyOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCBcIlxcXFwkJlwiKTtcbn1cblxuLyoqIEEgcGFyc2ltbW9uIHBhcnNlciB3aGljaCBjYW5vbmljYWxpemVzIHZhcmlhYmxlIG5hbWVzIHdoaWxlIHByb3Blcmx5IHJlc3BlY3RpbmcgZW1vamkuICovXG5jb25zdCBWQVJfTkFNRV9DQU5PTklDQUxJWkVSOiBQLlBhcnNlcjxzdHJpbmc+ID0gUC5hbHQoXG4gICAgUC5yZWdleChuZXcgUmVnRXhwKGVtb2ppUmVnZXgoKSwgXCJcIikpLFxuICAgIFAucmVnZXgoL1swLTlcXHB7TGV0dGVyfV8tXSsvdSkubWFwKHN0ciA9PiBzdHIudG9Mb2NhbGVMb3dlckNhc2UoKSksXG4gICAgUC53aGl0ZXNwYWNlLm1hcChfID0+IFwiLVwiKSxcbiAgICBQLmFueS5tYXAoXyA9PiBcIlwiKVxuKVxuICAgIC5tYW55KClcbiAgICAubWFwKHJlc3VsdCA9PiByZXN1bHQuam9pbihcIlwiKSk7XG5cbi8qKiBDb252ZXJ0IGFuIGFyYml0cmFyeSB2YXJpYWJsZSBuYW1lIGludG8gc29tZXRoaW5nIEpTL3F1ZXJ5IGZyaWVuZGx5LiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbm9uaWNhbGl6ZVZhck5hbWUobmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gVkFSX05BTUVfQ0FOT05JQ0FMSVpFUi50cnlQYXJzZShuYW1lKTtcbn1cblxuY29uc3QgSEVBREVSX0NBTk9OSUNBTElaRVI6IFAuUGFyc2VyPHN0cmluZz4gPSBQLmFsdChcbiAgICBQLnJlZ2V4KG5ldyBSZWdFeHAoZW1vamlSZWdleCgpLCBcIlwiKSksXG4gICAgUC5yZWdleCgvWzAtOVxccHtMZXR0ZXJ9Xy1dKy91KSxcbiAgICBQLndoaXRlc3BhY2UubWFwKF8gPT4gXCIgXCIpLFxuICAgIFAuYW55Lm1hcChfID0+IFwiIFwiKVxuKVxuICAgIC5tYW55KClcbiAgICAubWFwKHJlc3VsdCA9PiB7XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIlwiKS5zcGxpdCgvXFxzKy8pLmpvaW4oXCIgXCIpLnRyaW0oKTtcbiAgICB9KTtcblxuLyoqXG4gKiBOb3JtYWxpemVzIHRoZSB0ZXh0IGluIGEgaGVhZGVyIHRvIGJlIHNvbWV0aGluZyB0aGF0IGlzIGFjdHVhbGx5IGxpbmthYmxlIHRvLiBUaGlzIG1pbWljc1xuICogaG93IE9ic2lkaWFuIGRvZXMgaXQncyBub3JtYWxpemF0aW9uLCBjb2xsYXBzaW5nIHJlcGVhdGVkIHNwYWNlcyBhbmQgc3RyaXBwaW5nIG91dCBjb250cm9sIGNoYXJhY3RlcnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVIZWFkZXJGb3JMaW5rKGhlYWRlcjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gSEVBREVSX0NBTk9OSUNBTElaRVIudHJ5UGFyc2UoaGVhZGVyKTtcbn1cblxuLyoqIFJlbmRlciBhIERhdGVUaW1lIGluIGEgbWluaW1hbCBmb3JtYXQgdG8gc2F2ZSBzcGFjZS4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJNaW5pbWFsRGF0ZSh0aW1lOiBEYXRlVGltZSwgc2V0dGluZ3M6IFF1ZXJ5U2V0dGluZ3MsIGxvY2FsZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyByZWxldmFudCB0aW1lIHNwZWNpZmllZCwgZmFsbCBiYWNrIHRvIGp1c3QgcmVuZGVyaW5nIHRoZSBkYXRlLlxuICAgIGlmICh0aW1lLnNlY29uZCA9PSAwICYmIHRpbWUubWludXRlID09IDAgJiYgdGltZS5ob3VyID09IDApIHtcbiAgICAgICAgcmV0dXJuIHRpbWUudG9Mb2NhbCgpLnRvRm9ybWF0KHNldHRpbmdzLmRlZmF1bHREYXRlRm9ybWF0LCB7IGxvY2FsZSB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGltZS50b0xvY2FsKCkudG9Gb3JtYXQoc2V0dGluZ3MuZGVmYXVsdERhdGVUaW1lRm9ybWF0LCB7IGxvY2FsZSB9KTtcbn1cblxuLyoqIFJlbmRlciBhIGR1cmF0aW9uIGluIGEgbWluaW1hbCBmb3JtYXQgdG8gc2F2ZSBzcGFjZS4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJNaW5pbWFsRHVyYXRpb24oZHVyOiBEdXJhdGlvbik6IHN0cmluZyB7XG4gICAgZHVyID0gbm9ybWFsaXplRHVyYXRpb24oZHVyKTtcblxuICAgIC8vIHRvSHVtYW4gb3V0cHV0cyB6ZXJvIHF1YW50aXRpZXMgZS5nLiBcIjAgc2Vjb25kc1wiXG4gICAgZHVyID0gRHVyYXRpb24uZnJvbU9iamVjdChcbiAgICAgICAgT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGR1ci50b09iamVjdCgpKS5maWx0ZXIoKFssIHF1YW50aXR5XSkgPT4gcXVhbnRpdHkgIT0gMCkpXG4gICAgKTtcblxuICAgIHJldHVybiBkdXIudG9IdW1hbigpO1xufVxuXG4vKiogRGV0ZXJtaW5lIGlmIHR3byBzZXRzIGFyZSBlcXVhbCBpbiBjb250ZW50cy4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRzRXF1YWw8VD4oZmlyc3Q6IFNldDxUPiwgc2Vjb25kOiBTZXQ8VD4pOiBib29sZWFuIHtcbiAgICBpZiAoZmlyc3Quc2l6ZSAhPSBzZWNvbmQuc2l6ZSkgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGVsZW0gb2YgZmlyc3QpIGlmICghc2Vjb25kLmhhcyhlbGVtKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgcmV0dXJuIHRydWU7XG59XG4iLCAiaW1wb3J0IHsgRGF0ZVRpbWUsIER1cmF0aW9uIH0gZnJvbSBcImx1eG9uXCI7XG5pbXBvcnQgeyBERUZBVUxUX1FVRVJZX1NFVFRJTkdTLCBRdWVyeVNldHRpbmdzIH0gZnJvbSBcInNldHRpbmdzXCI7XG5pbXBvcnQgeyBnZXRGaWxlVGl0bGUsIG5vcm1hbGl6ZUhlYWRlckZvckxpbmssIHJlbmRlck1pbmltYWxEdXJhdGlvbiB9IGZyb20gXCJ1dGlsL25vcm1hbGl6ZVwiO1xuXG4vKiogU2hvcnRoYW5kIGZvciBhIG1hcHBpbmcgZnJvbSBrZXlzIHRvIHZhbHVlcy4gKi9cbmV4cG9ydCB0eXBlIERhdGFPYmplY3QgPSB7IFtrZXk6IHN0cmluZ106IExpdGVyYWwgfTtcbi8qKiBUaGUgbGl0ZXJhbCB0eXBlcyBzdXBwb3J0ZWQgYnkgdGhlIHF1ZXJ5IGVuZ2luZS4gKi9cbmV4cG9ydCB0eXBlIExpdGVyYWxUeXBlID1cbiAgICB8IFwiYm9vbGVhblwiXG4gICAgfCBcIm51bWJlclwiXG4gICAgfCBcInN0cmluZ1wiXG4gICAgfCBcImRhdGVcIlxuICAgIHwgXCJkdXJhdGlvblwiXG4gICAgfCBcImxpbmtcIlxuICAgIHwgXCJhcnJheVwiXG4gICAgfCBcIm9iamVjdFwiXG4gICAgfCBcImZ1bmN0aW9uXCJcbiAgICB8IFwibnVsbFwiXG4gICAgfCBcImh0bWxcIlxuICAgIHwgXCJ3aWRnZXRcIjtcbi8qKiBUaGUgcmF3IHZhbHVlcyB0aGF0IGEgbGl0ZXJhbCBjYW4gdGFrZSBvbi4gKi9cbmV4cG9ydCB0eXBlIExpdGVyYWwgPVxuICAgIHwgYm9vbGVhblxuICAgIHwgbnVtYmVyXG4gICAgfCBzdHJpbmdcbiAgICB8IERhdGVUaW1lXG4gICAgfCBEdXJhdGlvblxuICAgIHwgTGlua1xuICAgIHwgQXJyYXk8TGl0ZXJhbD5cbiAgICB8IERhdGFPYmplY3RcbiAgICB8IEZ1bmN0aW9uXG4gICAgfCBudWxsXG4gICAgfCBIVE1MRWxlbWVudFxuICAgIHwgV2lkZ2V0O1xuXG4vKiogQSBncm91cGluZyBvbiBhIHR5cGUgd2hpY2ggc3VwcG9ydHMgcmVjdXJzaXZlbHktbmVzdGVkIGdyb3Vwcy4gKi9cbmV4cG9ydCB0eXBlIEdyb3VwRWxlbWVudDxUPiA9IHsga2V5OiBMaXRlcmFsOyByb3dzOiBHcm91cGluZzxUPiB9O1xuZXhwb3J0IHR5cGUgR3JvdXBpbmc8VD4gPSBUW10gfCBHcm91cEVsZW1lbnQ8VD5bXTtcblxuLyoqIE1hcHMgdGhlIHN0cmluZyB0eXBlIHRvIGl0J3MgZXh0ZXJuYWwsIEFQSS1mYWNpbmcgcmVwcmVzZW50YXRpb24uICovXG5leHBvcnQgdHlwZSBMaXRlcmFsUmVwcjxUIGV4dGVuZHMgTGl0ZXJhbFR5cGU+ID0gVCBleHRlbmRzIFwiYm9vbGVhblwiXG4gICAgPyBib29sZWFuXG4gICAgOiBUIGV4dGVuZHMgXCJudW1iZXJcIlxuICAgID8gbnVtYmVyXG4gICAgOiBUIGV4dGVuZHMgXCJzdHJpbmdcIlxuICAgID8gc3RyaW5nXG4gICAgOiBUIGV4dGVuZHMgXCJkdXJhdGlvblwiXG4gICAgPyBEdXJhdGlvblxuICAgIDogVCBleHRlbmRzIFwiZGF0ZVwiXG4gICAgPyBEYXRlVGltZVxuICAgIDogVCBleHRlbmRzIFwibnVsbFwiXG4gICAgPyBudWxsXG4gICAgOiBUIGV4dGVuZHMgXCJsaW5rXCJcbiAgICA/IExpbmtcbiAgICA6IFQgZXh0ZW5kcyBcImFycmF5XCJcbiAgICA/IEFycmF5PExpdGVyYWw+XG4gICAgOiBUIGV4dGVuZHMgXCJvYmplY3RcIlxuICAgID8gUmVjb3JkPHN0cmluZywgTGl0ZXJhbD5cbiAgICA6IFQgZXh0ZW5kcyBcImZ1bmN0aW9uXCJcbiAgICA/IEZ1bmN0aW9uXG4gICAgOiBUIGV4dGVuZHMgXCJodG1sXCJcbiAgICA/IEhUTUxFbGVtZW50XG4gICAgOiBUIGV4dGVuZHMgXCJ3aWRnZXRcIlxuICAgID8gV2lkZ2V0XG4gICAgOiBhbnk7XG5cbi8qKiBBIHdyYXBwZWQgbGl0ZXJhbCB2YWx1ZSB3aGljaCBjYW4gYmUgc3dpdGNoZWQgb24uICovXG5leHBvcnQgdHlwZSBXcmFwcGVkTGl0ZXJhbCA9XG4gICAgfCBMaXRlcmFsV3JhcHBlcjxcInN0cmluZ1wiPlxuICAgIHwgTGl0ZXJhbFdyYXBwZXI8XCJudW1iZXJcIj5cbiAgICB8IExpdGVyYWxXcmFwcGVyPFwiYm9vbGVhblwiPlxuICAgIHwgTGl0ZXJhbFdyYXBwZXI8XCJkYXRlXCI+XG4gICAgfCBMaXRlcmFsV3JhcHBlcjxcImR1cmF0aW9uXCI+XG4gICAgfCBMaXRlcmFsV3JhcHBlcjxcImxpbmtcIj5cbiAgICB8IExpdGVyYWxXcmFwcGVyPFwiYXJyYXlcIj5cbiAgICB8IExpdGVyYWxXcmFwcGVyPFwib2JqZWN0XCI+XG4gICAgfCBMaXRlcmFsV3JhcHBlcjxcImh0bWxcIj5cbiAgICB8IExpdGVyYWxXcmFwcGVyPFwid2lkZ2V0XCI+XG4gICAgfCBMaXRlcmFsV3JhcHBlcjxcImZ1bmN0aW9uXCI+XG4gICAgfCBMaXRlcmFsV3JhcHBlcjxcIm51bGxcIj47XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGl0ZXJhbFdyYXBwZXI8VCBleHRlbmRzIExpdGVyYWxUeXBlPiB7XG4gICAgdHlwZTogVDtcbiAgICB2YWx1ZTogTGl0ZXJhbFJlcHI8VD47XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgVmFsdWVzIHtcbiAgICAvKiogQ29udmVydCBhbiBhcmJpdHJhcnkgdmFsdWUgaW50byBhIHJlYXNvbmFibGUsIE1hcmtkb3duLWZyaWVuZGx5IHN0cmluZyBpZiBwb3NzaWJsZS4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gdG9TdHJpbmcoXG4gICAgICAgIGZpZWxkOiBhbnksXG4gICAgICAgIHNldHRpbmc6IFF1ZXJ5U2V0dGluZ3MgPSBERUZBVUxUX1FVRVJZX1NFVFRJTkdTLFxuICAgICAgICByZWN1cnNpdmU6IGJvb2xlYW4gPSBmYWxzZVxuICAgICk6IHN0cmluZyB7XG4gICAgICAgIGxldCB3cmFwcGVkID0gd3JhcFZhbHVlKGZpZWxkKTtcbiAgICAgICAgaWYgKCF3cmFwcGVkKSByZXR1cm4gc2V0dGluZy5yZW5kZXJOdWxsQXM7XG5cbiAgICAgICAgc3dpdGNoICh3cmFwcGVkLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJudWxsXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldHRpbmcucmVuZGVyTnVsbEFzO1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkLnZhbHVlO1xuICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcIiArIHdyYXBwZWQudmFsdWU7XG4gICAgICAgICAgICBjYXNlIFwiaHRtbFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkLnZhbHVlLm91dGVySFRNTDtcbiAgICAgICAgICAgIGNhc2UgXCJ3aWRnZXRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZC52YWx1ZS5tYXJrZG93bigpO1xuICAgICAgICAgICAgY2FzZSBcImxpbmtcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZC52YWx1ZS5tYXJrZG93bigpO1xuICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiPGZ1bmN0aW9uPlwiO1xuICAgICAgICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgaWYgKHJlY3Vyc2l2ZSkgcmVzdWx0ICs9IFwiW1wiO1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB3cmFwcGVkLnZhbHVlLm1hcChmID0+IHRvU3RyaW5nKGYsIHNldHRpbmcsIHRydWUpKS5qb2luKFwiLCBcIik7XG4gICAgICAgICAgICAgICAgaWYgKHJlY3Vyc2l2ZSkgcmVzdWx0ICs9IFwiXVwiO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgXCJ7IFwiICtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMod3JhcHBlZC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZSA9PiBlWzBdICsgXCI6IFwiICsgdG9TdHJpbmcoZVsxXSwgc2V0dGluZywgdHJ1ZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuam9pbihcIiwgXCIpICtcbiAgICAgICAgICAgICAgICAgICAgXCIgfVwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNhc2UgXCJkYXRlXCI6XG4gICAgICAgICAgICAgICAgaWYgKHdyYXBwZWQudmFsdWUuc2Vjb25kID09IDAgJiYgd3JhcHBlZC52YWx1ZS5ob3VyID09IDAgJiYgd3JhcHBlZC52YWx1ZS5taW51dGUgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZC52YWx1ZS50b0Zvcm1hdChzZXR0aW5nLmRlZmF1bHREYXRlRm9ybWF0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZC52YWx1ZS50b0Zvcm1hdChzZXR0aW5nLmRlZmF1bHREYXRlVGltZUZvcm1hdCk7XG4gICAgICAgICAgICBjYXNlIFwiZHVyYXRpb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyTWluaW1hbER1cmF0aW9uKHdyYXBwZWQudmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIFdyYXAgYSBsaXRlcmFsIHZhbHVlIHNvIHlvdSBjYW4gc3dpdGNoIG9uIGl0IGVhc2lseS4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gd3JhcFZhbHVlKHZhbDogTGl0ZXJhbCk6IFdyYXBwZWRMaXRlcmFsIHwgdW5kZWZpbmVkIHtcbiAgICAgICAgaWYgKGlzTnVsbCh2YWwpKSByZXR1cm4geyB0eXBlOiBcIm51bGxcIiwgdmFsdWU6IHZhbCB9O1xuICAgICAgICBlbHNlIGlmIChpc051bWJlcih2YWwpKSByZXR1cm4geyB0eXBlOiBcIm51bWJlclwiLCB2YWx1ZTogdmFsIH07XG4gICAgICAgIGVsc2UgaWYgKGlzU3RyaW5nKHZhbCkpIHJldHVybiB7IHR5cGU6IFwic3RyaW5nXCIsIHZhbHVlOiB2YWwgfTtcbiAgICAgICAgZWxzZSBpZiAoaXNCb29sZWFuKHZhbCkpIHJldHVybiB7IHR5cGU6IFwiYm9vbGVhblwiLCB2YWx1ZTogdmFsIH07XG4gICAgICAgIGVsc2UgaWYgKGlzRHVyYXRpb24odmFsKSkgcmV0dXJuIHsgdHlwZTogXCJkdXJhdGlvblwiLCB2YWx1ZTogdmFsIH07XG4gICAgICAgIGVsc2UgaWYgKGlzRGF0ZSh2YWwpKSByZXR1cm4geyB0eXBlOiBcImRhdGVcIiwgdmFsdWU6IHZhbCB9O1xuICAgICAgICBlbHNlIGlmIChpc1dpZGdldCh2YWwpKSByZXR1cm4geyB0eXBlOiBcIndpZGdldFwiLCB2YWx1ZTogdmFsIH07XG4gICAgICAgIGVsc2UgaWYgKGlzQXJyYXkodmFsKSkgcmV0dXJuIHsgdHlwZTogXCJhcnJheVwiLCB2YWx1ZTogdmFsIH07XG4gICAgICAgIGVsc2UgaWYgKGlzTGluayh2YWwpKSByZXR1cm4geyB0eXBlOiBcImxpbmtcIiwgdmFsdWU6IHZhbCB9O1xuICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKHZhbCkpIHJldHVybiB7IHR5cGU6IFwiZnVuY3Rpb25cIiwgdmFsdWU6IHZhbCB9O1xuICAgICAgICBlbHNlIGlmIChpc0h0bWwodmFsKSkgcmV0dXJuIHsgdHlwZTogXCJodG1sXCIsIHZhbHVlOiB2YWwgfTtcbiAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QodmFsKSkgcmV0dXJuIHsgdHlwZTogXCJvYmplY3RcIiwgdmFsdWU6IHZhbCB9O1xuICAgICAgICBlbHNlIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqIFJlY3Vyc2l2ZWx5IG1hcCBjb21wbGV4IG9iamVjdHMgYXQgdGhlIGxlYXZlcy4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gbWFwTGVhdmVzKHZhbDogTGl0ZXJhbCwgZnVuYzogKHQ6IExpdGVyYWwpID0+IExpdGVyYWwpOiBMaXRlcmFsIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQ6IERhdGFPYmplY3QgPSB7fTtcbiAgICAgICAgICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh2YWwpKSByZXN1bHRba2V5XSA9IG1hcExlYXZlcyh2YWx1ZSwgZnVuYyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsKSkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdDogTGl0ZXJhbFtdID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWwpIHJlc3VsdC5wdXNoKG1hcExlYXZlcyh2YWx1ZSwgZnVuYykpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jKHZhbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQ29tcGFyZSB0d28gYXJiaXRyYXJ5IEphdmFTY3JpcHQgdmFsdWVzLiBQcm9kdWNlcyBhIHRvdGFsIG9yZGVyaW5nIG92ZXIgQU5ZIHBvc3NpYmxlIGRhdGF2aWV3IHZhbHVlLiAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiBjb21wYXJlVmFsdWUodmFsMTogTGl0ZXJhbCwgdmFsMjogTGl0ZXJhbCwgbGlua05vcm1hbGl6ZXI/OiAobGluazogc3RyaW5nKSA9PiBzdHJpbmcpOiBudW1iZXIge1xuICAgICAgICAvLyBIYW5kbGUgdW5kZWZpbmVkL251bGxzIGZpcnN0LlxuICAgICAgICBpZiAodmFsMSA9PT0gdW5kZWZpbmVkKSB2YWwxID0gbnVsbDtcbiAgICAgICAgaWYgKHZhbDIgPT09IHVuZGVmaW5lZCkgdmFsMiA9IG51bGw7XG4gICAgICAgIGlmICh2YWwxID09PSBudWxsICYmIHZhbDIgPT09IG51bGwpIHJldHVybiAwO1xuICAgICAgICBlbHNlIGlmICh2YWwxID09PSBudWxsKSByZXR1cm4gLTE7XG4gICAgICAgIGVsc2UgaWYgKHZhbDIgPT09IG51bGwpIHJldHVybiAxO1xuXG4gICAgICAgIC8vIEEgbm9uLW51bGwgdmFsdWUgbm93IHdoaWNoIHdlIGNhbiB3cmFwICYgY29tcGFyZSBvbi5cbiAgICAgICAgbGV0IHdyYXAxID0gd3JhcFZhbHVlKHZhbDEpO1xuICAgICAgICBsZXQgd3JhcDIgPSB3cmFwVmFsdWUodmFsMik7XG5cbiAgICAgICAgaWYgKHdyYXAxID09PSB1bmRlZmluZWQgJiYgd3JhcDIgPT09IHVuZGVmaW5lZCkgcmV0dXJuIDA7XG4gICAgICAgIGVsc2UgaWYgKHdyYXAxID09PSB1bmRlZmluZWQpIHJldHVybiAtMTtcbiAgICAgICAgZWxzZSBpZiAod3JhcDIgPT09IHVuZGVmaW5lZCkgcmV0dXJuIDE7XG5cbiAgICAgICAgLy8gU2hvcnQtY2lyY3VpdCBvbiBkaWZmZXJlbnQgdHlwZXMgb3Igb24gcmVmZXJlbmNlIGVxdWFsaXR5LlxuICAgICAgICBpZiAod3JhcDEudHlwZSAhPSB3cmFwMi50eXBlKSByZXR1cm4gd3JhcDEudHlwZS5sb2NhbGVDb21wYXJlKHdyYXAyLnR5cGUpO1xuICAgICAgICBpZiAod3JhcDEudmFsdWUgPT09IHdyYXAyLnZhbHVlKSByZXR1cm4gMDtcblxuICAgICAgICBzd2l0Y2ggKHdyYXAxLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcDEudmFsdWUubG9jYWxlQ29tcGFyZSh3cmFwMi52YWx1ZSBhcyBzdHJpbmcpO1xuICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgICAgIGlmICh3cmFwMS52YWx1ZSA8ICh3cmFwMi52YWx1ZSBhcyBudW1iZXIpKSByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAod3JhcDEudmFsdWUgPT0gKHdyYXAyLnZhbHVlIGFzIG51bWJlcikpIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgY2FzZSBcIm51bGxcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICAgICAgaWYgKHdyYXAxLnZhbHVlID09IHdyYXAyLnZhbHVlKSByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICBlbHNlIHJldHVybiB3cmFwMS52YWx1ZSA/IDEgOiAtMTtcbiAgICAgICAgICAgIGNhc2UgXCJsaW5rXCI6XG4gICAgICAgICAgICAgICAgbGV0IGxpbmsxID0gd3JhcDEudmFsdWU7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmsyID0gd3JhcDIudmFsdWUgYXMgTGluaztcbiAgICAgICAgICAgICAgICBsZXQgbm9ybWFsaXplID0gbGlua05vcm1hbGl6ZXIgPz8gKCh4OiBzdHJpbmcpID0+IHgpO1xuXG4gICAgICAgICAgICAgICAgLy8gV2UgY2FuJ3QgY29tcGFyZSBieSBmaWxlIG5hbWUgb3IgZGlzcGxheSwgc2luY2UgdGhhdCB3b3VsZCBicmVhayBsaW5rIGVxdWFsaXR5LiBDb21wYXJlIGJ5IHBhdGguXG4gICAgICAgICAgICAgICAgbGV0IHBhdGhDb21wYXJlID0gbm9ybWFsaXplKGxpbmsxLnBhdGgpLmxvY2FsZUNvbXBhcmUobm9ybWFsaXplKGxpbmsyLnBhdGgpKTtcbiAgICAgICAgICAgICAgICBpZiAocGF0aENvbXBhcmUgIT0gMCkgcmV0dXJuIHBhdGhDb21wYXJlO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhlbiBjb21wYXJlIGJ5IHR5cGUuXG4gICAgICAgICAgICAgICAgbGV0IHR5cGVDb21wYXJlID0gbGluazEudHlwZS5sb2NhbGVDb21wYXJlKGxpbmsyLnR5cGUpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlQ29tcGFyZSAhPSAwKSByZXR1cm4gdHlwZUNvbXBhcmU7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGVuIGNvbXBhcmUgYnkgc3VicGF0aCBleGlzdGVuY2UuXG4gICAgICAgICAgICAgICAgaWYgKGxpbmsxLnN1YnBhdGggJiYgIWxpbmsyLnN1YnBhdGgpIHJldHVybiAxO1xuICAgICAgICAgICAgICAgIGlmICghbGluazEuc3VicGF0aCAmJiBsaW5rMi5zdWJwYXRoKSByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgaWYgKCFsaW5rMS5zdWJwYXRoICYmICFsaW5rMi5zdWJwYXRoKSByZXR1cm4gMDtcblxuICAgICAgICAgICAgICAgIC8vIFNpbmNlIGJvdGggaGF2ZSBhIHN1YnBhdGgsIGNvbXBhcmUgYnkgc3VicGF0aC5cbiAgICAgICAgICAgICAgICByZXR1cm4gKGxpbmsxLnN1YnBhdGggPz8gXCJcIikubG9jYWxlQ29tcGFyZShsaW5rMi5zdWJwYXRoID8/IFwiXCIpO1xuICAgICAgICAgICAgY2FzZSBcImRhdGVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcDEudmFsdWUgPCAod3JhcDIudmFsdWUgYXMgRGF0ZVRpbWUpXG4gICAgICAgICAgICAgICAgICAgID8gLTFcbiAgICAgICAgICAgICAgICAgICAgOiB3cmFwMS52YWx1ZS5lcXVhbHMod3JhcDIudmFsdWUgYXMgRGF0ZVRpbWUpXG4gICAgICAgICAgICAgICAgICAgID8gMFxuICAgICAgICAgICAgICAgICAgICA6IDE7XG4gICAgICAgICAgICBjYXNlIFwiZHVyYXRpb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcDEudmFsdWUgPCAod3JhcDIudmFsdWUgYXMgRHVyYXRpb24pXG4gICAgICAgICAgICAgICAgICAgID8gLTFcbiAgICAgICAgICAgICAgICAgICAgOiB3cmFwMS52YWx1ZS5lcXVhbHMod3JhcDIudmFsdWUgYXMgRHVyYXRpb24pXG4gICAgICAgICAgICAgICAgICAgID8gMFxuICAgICAgICAgICAgICAgICAgICA6IDE7XG4gICAgICAgICAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgICAgICAgICBsZXQgZjEgPSB3cmFwMS52YWx1ZTtcbiAgICAgICAgICAgICAgICBsZXQgZjIgPSB3cmFwMi52YWx1ZSBhcyBhbnlbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgTWF0aC5taW4oZjEubGVuZ3RoLCBmMi5sZW5ndGgpOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb21wID0gY29tcGFyZVZhbHVlKGYxW2luZGV4XSwgZjJbaW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXAgIT0gMCkgcmV0dXJuIGNvbXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmMS5sZW5ndGggLSBmMi5sZW5ndGg7XG4gICAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICAgICAgbGV0IG8xID0gd3JhcDEudmFsdWU7XG4gICAgICAgICAgICAgICAgbGV0IG8yID0gd3JhcDIudmFsdWUgYXMgUmVjb3JkPHN0cmluZywgYW55PjtcbiAgICAgICAgICAgICAgICBsZXQgazEgPSBBcnJheS5mcm9tKE9iamVjdC5rZXlzKG8xKSk7XG4gICAgICAgICAgICAgICAgbGV0IGsyID0gQXJyYXkuZnJvbShPYmplY3Qua2V5cyhvMikpO1xuICAgICAgICAgICAgICAgIGsxLnNvcnQoKTtcbiAgICAgICAgICAgICAgICBrMi5zb3J0KCk7XG5cbiAgICAgICAgICAgICAgICBsZXQga2V5Q29tcGFyZSA9IGNvbXBhcmVWYWx1ZShrMSwgazIpO1xuICAgICAgICAgICAgICAgIGlmIChrZXlDb21wYXJlICE9IDApIHJldHVybiBrZXlDb21wYXJlO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQga2V5IG9mIGsxKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb21wID0gY29tcGFyZVZhbHVlKG8xW2tleV0sIG8yW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcCAhPSAwKSByZXR1cm4gY29tcDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIGNhc2UgXCJ3aWRnZXRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJodG1sXCI6XG4gICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBGaW5kIHRoZSBjb3JyZXNwb25kaW5nIERhdGF2ZWl3IHR5cGUgZm9yIGFuIGFyYml0cmFyeSB2YWx1ZS4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gdHlwZU9mKHZhbDogYW55KTogTGl0ZXJhbFR5cGUgfCB1bmRlZmluZWQge1xuICAgICAgICByZXR1cm4gd3JhcFZhbHVlKHZhbCk/LnR5cGU7XG4gICAgfVxuXG4gICAgLyoqIERldGVybWluZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgXCJ0cnV0aHlcIiAoaS5lLiwgaXMgbm9uLW51bGwgYW5kIGhhcyBkYXRhIGluIGl0KS4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gaXNUcnV0aHkoZmllbGQ6IExpdGVyYWwpOiBib29sZWFuIHtcbiAgICAgICAgbGV0IHdyYXBwZWQgPSB3cmFwVmFsdWUoZmllbGQpO1xuICAgICAgICBpZiAoIXdyYXBwZWQpIHJldHVybiBmYWxzZTtcblxuICAgICAgICBzd2l0Y2ggKHdyYXBwZWQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkLnZhbHVlICE9IDA7XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWQudmFsdWUubGVuZ3RoID4gMDtcbiAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWQudmFsdWU7XG4gICAgICAgICAgICBjYXNlIFwibGlua1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiAhIXdyYXBwZWQudmFsdWUucGF0aDtcbiAgICAgICAgICAgIGNhc2UgXCJkYXRlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWQudmFsdWUudG9NaWxsaXMoKSAhPSAwO1xuICAgICAgICAgICAgY2FzZSBcImR1cmF0aW9uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWQudmFsdWUuYXMoXCJzZWNvbmRzXCIpICE9IDA7XG4gICAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHdyYXBwZWQudmFsdWUpLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZC52YWx1ZS5sZW5ndGggPiAwO1xuICAgICAgICAgICAgY2FzZSBcIm51bGxcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYXNlIFwiaHRtbFwiOlxuICAgICAgICAgICAgY2FzZSBcIndpZGdldFwiOlxuICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogRGVlcCBjb3B5IGEgZmllbGQuICovXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGRlZXBDb3B5PFQgZXh0ZW5kcyBMaXRlcmFsPihmaWVsZDogVCk6IFQge1xuICAgICAgICBpZiAoZmllbGQgPT09IG51bGwgfHwgZmllbGQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZpZWxkO1xuXG4gICAgICAgIGlmIChWYWx1ZXMuaXNBcnJheShmaWVsZCkpIHtcbiAgICAgICAgICAgIHJldHVybiAoW10gYXMgTGl0ZXJhbFtdKS5jb25jYXQoZmllbGQubWFwKHYgPT4gZGVlcENvcHkodikpKSBhcyBUO1xuICAgICAgICB9IGVsc2UgaWYgKFZhbHVlcy5pc09iamVjdChmaWVsZCkpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQ6IFJlY29yZDxzdHJpbmcsIExpdGVyYWw+ID0ge307XG4gICAgICAgICAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZmllbGQpKSByZXN1bHRba2V5XSA9IGRlZXBDb3B5KHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgYXMgVDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmaWVsZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZyh2YWw6IGFueSk6IHZhbCBpcyBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbCA9PSBcInN0cmluZ1wiO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBpc051bWJlcih2YWw6IGFueSk6IHZhbCBpcyBudW1iZXIge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbCA9PSBcIm51bWJlclwiO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBpc0RhdGUodmFsOiBhbnkpOiB2YWwgaXMgRGF0ZVRpbWUge1xuICAgICAgICByZXR1cm4gdmFsIGluc3RhbmNlb2YgRGF0ZVRpbWU7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGlzRHVyYXRpb24odmFsOiBhbnkpOiB2YWwgaXMgRHVyYXRpb24ge1xuICAgICAgICByZXR1cm4gdmFsIGluc3RhbmNlb2YgRHVyYXRpb247XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGlzTnVsbCh2YWw6IGFueSk6IHZhbCBpcyBudWxsIHwgdW5kZWZpbmVkIHtcbiAgICAgICAgcmV0dXJuIHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gaXNBcnJheSh2YWw6IGFueSk6IHZhbCBpcyBhbnlbXSB7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbCk7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGlzQm9vbGVhbih2YWw6IGFueSk6IHZhbCBpcyBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09IFwiYm9vbGVhblwiO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBpc0xpbmsodmFsOiBhbnkpOiB2YWwgaXMgTGluayB7XG4gICAgICAgIHJldHVybiB2YWwgaW5zdGFuY2VvZiBMaW5rO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBpc1dpZGdldCh2YWw6IGFueSk6IHZhbCBpcyBXaWRnZXQge1xuICAgICAgICByZXR1cm4gdmFsIGluc3RhbmNlb2YgV2lkZ2V0O1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBpc0h0bWwodmFsOiBhbnkpOiB2YWwgaXMgSFRNTEVsZW1lbnQge1xuICAgICAgICBpZiAodHlwZW9mIEhUTUxFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQ2hlY2tzIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhbiBvYmplY3QgKGFuZCBub3QgYW55IG90aGVyIGRhdGF2aWV3LXJlY29nbml6ZWQgb2JqZWN0LWxpa2UgdHlwZSkuICovXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KHZhbDogYW55KTogdmFsIGlzIFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdHlwZW9mIHZhbCA9PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICAhaXNIdG1sKHZhbCkgJiZcbiAgICAgICAgICAgICFpc1dpZGdldCh2YWwpICYmXG4gICAgICAgICAgICAhaXNBcnJheSh2YWwpICYmXG4gICAgICAgICAgICAhaXNEdXJhdGlvbih2YWwpICYmXG4gICAgICAgICAgICAhaXNEYXRlKHZhbCkgJiZcbiAgICAgICAgICAgICFpc0xpbmsodmFsKSAmJlxuICAgICAgICAgICAgdmFsICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICFpc051bGwodmFsKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbDogYW55KTogdmFsIGlzIEZ1bmN0aW9uIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWwgPT0gXCJmdW5jdGlvblwiO1xuICAgIH1cbn1cblxuLy8vLy8vLy8vLy8vLy8vXG4vLyBHcm91cGluZ3MgLy9cbi8vLy8vLy8vLy8vLy8vL1xuXG5leHBvcnQgbmFtZXNwYWNlIEdyb3VwaW5ncyB7XG4gICAgLyoqIERldGVybWluZXMgaWYgdGhlIGdpdmVuIGdyb3VwIGVudHJ5IGlzIGEgc3RhbmRhbG9uZSB2YWx1ZSwgb3IgYSBncm91cGluZyBvZiBzdWItZW50cmllcy4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gaXNFbGVtZW50R3JvdXA8VD4oZW50cnk6IFQgfCBHcm91cEVsZW1lbnQ8VD4pOiBlbnRyeSBpcyBHcm91cEVsZW1lbnQ8VD4ge1xuICAgICAgICByZXR1cm4gVmFsdWVzLmlzT2JqZWN0KGVudHJ5KSAmJiBPYmplY3Qua2V5cyhlbnRyeSkubGVuZ3RoID09IDIgJiYgXCJrZXlcIiBpbiBlbnRyeSAmJiBcInJvd3NcIiBpbiBlbnRyeTtcbiAgICB9XG5cbiAgICAvKiogRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gYXJyYXkgaXMgYSBncm91cGluZyBhcnJheS4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gaXNHcm91cGluZzxUPihlbnRyeTogR3JvdXBpbmc8VD4pOiBlbnRyeSBpcyBHcm91cEVsZW1lbnQ8VD5bXSB7XG4gICAgICAgIGZvciAobGV0IGVsZW1lbnQgb2YgZW50cnkpIGlmICghaXNFbGVtZW50R3JvdXAoZWxlbWVudCkpIHJldHVybiBmYWxzZTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKiogQ291bnQgdGhlIHRvdGFsIG51bWJlciBvZiBlbGVtZW50cyBpbiBhIHJlY3Vyc2l2ZSBncm91cGluZy4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gY291bnQ8VD4oZWxlbWVudHM6IEdyb3VwaW5nPFQ+KTogbnVtYmVyIHtcbiAgICAgICAgaWYgKGlzR3JvdXBpbmcoZWxlbWVudHMpKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IHN1Ymdyb3VwIG9mIGVsZW1lbnRzKSByZXN1bHQgKz0gY291bnQoc3ViZ3JvdXAucm93cyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8vLy8vLy8vL1xuLy8gTElOSyAvL1xuLy8vLy8vLy8vL1xuXG4vKiogVGhlIE9ic2lkaWFuICdsaW5rJywgdXNlZCBmb3IgdW5pcXVlbHkgZGVzY3JpYmluZyBhIGZpbGUsIGhlYWRlciwgb3IgYmxvY2suICovXG5leHBvcnQgY2xhc3MgTGluayB7XG4gICAgLyoqIFRoZSBmaWxlIHBhdGggdGhpcyBsaW5rIHBvaW50cyB0by4gKi9cbiAgICBwdWJsaWMgcGF0aDogc3RyaW5nO1xuICAgIC8qKiBUaGUgZGlzcGxheSBuYW1lIGFzc29jaWF0ZWQgd2l0aCB0aGUgbGluay4gKi9cbiAgICBwdWJsaWMgZGlzcGxheT86IHN0cmluZztcbiAgICAvKiogVGhlIGJsb2NrIElEIG9yIGhlYWRlciB0aGlzIGxpbmsgcG9pbnRzIHRvIHdpdGhpbiBhIGZpbGUsIGlmIHJlbGV2YW50LiAqL1xuICAgIHB1YmxpYyBzdWJwYXRoPzogc3RyaW5nO1xuICAgIC8qKiBJcyB0aGlzIGxpbmsgYW4gZW1iZWRkZWQgbGluayAoISk/ICovXG4gICAgcHVibGljIGVtYmVkOiBib29sZWFuO1xuICAgIC8qKiBUaGUgdHlwZSBvZiB0aGlzIGxpbmssIHdoaWNoIGRldGVybWluZXMgd2hhdCAnc3VicGF0aCcgcmVmZXJzIHRvLCBpZiBhbnl0aGluZy4gKi9cbiAgICBwdWJsaWMgdHlwZTogXCJmaWxlXCIgfCBcImhlYWRlclwiIHwgXCJibG9ja1wiO1xuXG4gICAgLyoqIENyZWF0ZSBhIGxpbmsgdG8gYSBzcGVjaWZpYyBmaWxlLiAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZmlsZShwYXRoOiBzdHJpbmcsIGVtYmVkOiBib29sZWFuID0gZmFsc2UsIGRpc3BsYXk/OiBzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5rKHtcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBlbWJlZCxcbiAgICAgICAgICAgIGRpc3BsYXksXG4gICAgICAgICAgICBzdWJwYXRoOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBpbmZlcihsaW5rcGF0aDogc3RyaW5nLCBlbWJlZDogYm9vbGVhbiA9IGZhbHNlLCBkaXNwbGF5Pzogc3RyaW5nKSB7XG4gICAgICAgIGlmIChsaW5rcGF0aC5pbmNsdWRlcyhcIiNeXCIpKSB7XG4gICAgICAgICAgICBsZXQgc3BsaXQgPSBsaW5rcGF0aC5zcGxpdChcIiNeXCIpO1xuICAgICAgICAgICAgcmV0dXJuIExpbmsuYmxvY2soc3BsaXRbMF0sIHNwbGl0WzFdLCBlbWJlZCwgZGlzcGxheSk7XG4gICAgICAgIH0gZWxzZSBpZiAobGlua3BhdGguaW5jbHVkZXMoXCIjXCIpKSB7XG4gICAgICAgICAgICBsZXQgc3BsaXQgPSBsaW5rcGF0aC5zcGxpdChcIiNcIik7XG4gICAgICAgICAgICByZXR1cm4gTGluay5oZWFkZXIoc3BsaXRbMF0sIHNwbGl0WzFdLCBlbWJlZCwgZGlzcGxheSk7XG4gICAgICAgIH0gZWxzZSByZXR1cm4gTGluay5maWxlKGxpbmtwYXRoLCBlbWJlZCwgZGlzcGxheSk7XG4gICAgfVxuXG4gICAgLyoqIENyZWF0ZSBhIGxpbmsgdG8gYSBzcGVjaWZpYyBmaWxlIGFuZCBoZWFkZXIgaW4gdGhhdCBmaWxlLiAqL1xuICAgIHB1YmxpYyBzdGF0aWMgaGVhZGVyKHBhdGg6IHN0cmluZywgaGVhZGVyOiBzdHJpbmcsIGVtYmVkPzogYm9vbGVhbiwgZGlzcGxheT86IHN0cmluZykge1xuICAgICAgICAvLyBIZWFkZXJzIG5lZWQgdG8gYmUgbm9ybWFsaXplZCB0byBhbHBoYS1udW1lcmljICYgd2l0aCBleHRyYSBzcGFjaW5nIHJlbW92ZWQuXG4gICAgICAgIHJldHVybiBuZXcgTGluayh7XG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgZW1iZWQsXG4gICAgICAgICAgICBkaXNwbGF5LFxuICAgICAgICAgICAgc3VicGF0aDogbm9ybWFsaXplSGVhZGVyRm9yTGluayhoZWFkZXIpLFxuICAgICAgICAgICAgdHlwZTogXCJoZWFkZXJcIixcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqIENyZWF0ZSBhIGxpbmsgdG8gYSBzcGVjaWZpYyBmaWxlIGFuZCBibG9jayBpbiB0aGF0IGZpbGUuICovXG4gICAgcHVibGljIHN0YXRpYyBibG9jayhwYXRoOiBzdHJpbmcsIGJsb2NrSWQ6IHN0cmluZywgZW1iZWQ/OiBib29sZWFuLCBkaXNwbGF5Pzogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGluayh7XG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgZW1iZWQsXG4gICAgICAgICAgICBkaXNwbGF5LFxuICAgICAgICAgICAgc3VicGF0aDogYmxvY2tJZCxcbiAgICAgICAgICAgIHR5cGU6IFwiYmxvY2tcIixcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBmcm9tT2JqZWN0KG9iamVjdDogUmVjb3JkPHN0cmluZywgYW55Pikge1xuICAgICAgICByZXR1cm4gbmV3IExpbmsob2JqZWN0KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNvbnN0cnVjdG9yKGZpZWxkczogUGFydGlhbDxMaW5rPikge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGZpZWxkcyk7XG4gICAgfVxuXG4gICAgLyoqIENoZWNrcyBmb3IgbGluayBlcXVhbGl0eSAoaS5lLiwgdGhhdCB0aGUgbGlua3MgYXJlIHBvaW50aW5nIHRvIHRoZSBzYW1lIGV4YWN0IGxvY2F0aW9uKS4gKi9cbiAgICBwdWJsaWMgZXF1YWxzKG90aGVyOiBMaW5rKTogYm9vbGVhbiB7XG4gICAgICAgIGlmIChvdGhlciA9PSB1bmRlZmluZWQgfHwgb3RoZXIgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnBhdGggPT0gb3RoZXIucGF0aCAmJiB0aGlzLnR5cGUgPT0gb3RoZXIudHlwZSAmJiB0aGlzLnN1YnBhdGggPT0gb3RoZXIuc3VicGF0aDtcbiAgICB9XG5cbiAgICAvKiogQ29udmVydCB0aGlzIGxpbmsgdG8gaXQncyBtYXJrZG93biByZXByZXNlbnRhdGlvbi4gKi9cbiAgICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFya2Rvd24oKTtcbiAgICB9XG5cbiAgICAvKiogQ29udmVydCB0aGlzIGxpbmsgdG8gYSByYXcgb2JqZWN0IHdoaWNoIGlzIHNlcmlhbGl6YXRpb24tZnJpZW5kbHkuICovXG4gICAgcHVibGljIHRvT2JqZWN0KCk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICAgICAgICByZXR1cm4geyBwYXRoOiB0aGlzLnBhdGgsIHR5cGU6IHRoaXMudHlwZSwgc3VicGF0aDogdGhpcy5zdWJwYXRoLCBkaXNwbGF5OiB0aGlzLmRpc3BsYXksIGVtYmVkOiB0aGlzLmVtYmVkIH07XG4gICAgfVxuXG4gICAgLyoqIFVwZGF0ZSB0aGlzIGxpbmsgd2l0aCBhIG5ldyBwYXRoLiAqL1xuICAgIC8vQHRzLWlnbm9yZTsgZXJyb3IgYXBwZWFyZWQgYWZ0ZXIgdXBkYXRpbmcgT2JzaWRpYW4gdG8gMC4xNS40OyBpdCBhbHNvIHVwZGF0ZWQgb3RoZXIgcGFja2FnZXMgYnV0IGRpZG4ndCBzYXkgd2hpY2hcbiAgICBwdWJsaWMgd2l0aFBhdGgocGF0aDogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGluayhPYmplY3QuYXNzaWduKHt9LCB0aGlzLCB7IHBhdGggfSkpO1xuICAgIH1cblxuICAgIC8qKiBSZXR1cm4gYSBuZXcgbGluayB3aGljaCBwb2ludHMgdG8gdGhlIHNhbWUgbG9jYXRpb24gYnV0IHdpdGggYSBuZXcgZGlzcGxheSB2YWx1ZS4gKi9cbiAgICBwdWJsaWMgd2l0aERpc3BsYXkoZGlzcGxheT86IHN0cmluZykge1xuICAgICAgICByZXR1cm4gbmV3IExpbmsoT2JqZWN0LmFzc2lnbih7fSwgdGhpcywgeyBkaXNwbGF5IH0pKTtcbiAgICB9XG5cbiAgICAvKiogQ29udmVydCBhIGZpbGUgbGluayBpbnRvIGEgbGluayB0byBhIHNwZWNpZmljIGhlYWRlci4gKi9cbiAgICBwdWJsaWMgd2l0aEhlYWRlcihoZWFkZXI6IHN0cmluZykge1xuICAgICAgICByZXR1cm4gTGluay5oZWFkZXIodGhpcy5wYXRoLCBoZWFkZXIsIHRoaXMuZW1iZWQsIHRoaXMuZGlzcGxheSk7XG4gICAgfVxuXG4gICAgLyoqIENvbnZlcnQgYW55IGxpbmsgaW50byBhIGxpbmsgdG8gaXRzIGZpbGUuICovXG4gICAgcHVibGljIHRvRmlsZSgpIHtcbiAgICAgICAgcmV0dXJuIExpbmsuZmlsZSh0aGlzLnBhdGgsIHRoaXMuZW1iZWQsIHRoaXMuZGlzcGxheSk7XG4gICAgfVxuXG4gICAgLyoqIENvbnZlcnQgdGhpcyBsaW5rIGludG8gYW4gZW1iZWRkZWQgbGluay4gKi9cbiAgICBwdWJsaWMgdG9FbWJlZCgpOiBMaW5rIHtcbiAgICAgICAgaWYgKHRoaXMuZW1iZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGxpbmsgPSBuZXcgTGluayh0aGlzKTtcbiAgICAgICAgICAgIGxpbmsuZW1iZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGxpbms7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQ29udmVydCB0aGlzIGxpbmsgaW50byBhIG5vbi1lbWJlZGRlZCBsaW5rLiAqL1xuICAgIHB1YmxpYyBmcm9tRW1iZWQoKTogTGluayB7XG4gICAgICAgIGlmICghdGhpcy5lbWJlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgbGluayA9IG5ldyBMaW5rKHRoaXMpO1xuICAgICAgICAgICAgbGluay5lbWJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIGxpbms7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQ29udmVydCB0aGlzIGxpbmsgdG8gbWFya2Rvd24gc28gaXQgY2FuIGJlIHJlbmRlcmVkLiAqL1xuICAgIHB1YmxpYyBtYXJrZG93bigpOiBzdHJpbmcge1xuICAgICAgICBsZXQgcmVzdWx0ID0gKHRoaXMuZW1iZWQgPyBcIiFcIiA6IFwiXCIpICsgXCJbW1wiICsgdGhpcy5vYnNpZGlhbkxpbmsoKTtcblxuICAgICAgICBpZiAodGhpcy5kaXNwbGF5KSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCJ8XCIgKyB0aGlzLmRpc3BsYXk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCJ8XCIgKyBnZXRGaWxlVGl0bGUodGhpcy5wYXRoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT0gXCJoZWFkZXJcIiB8fCB0aGlzLnR5cGUgPT0gXCJibG9ja1wiKSByZXN1bHQgKz0gXCIgPiBcIiArIHRoaXMuc3VicGF0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCArPSBcIl1dXCI7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqIENvbnZlcnQgdGhlIGlubmVyIHBhcnQgb2YgdGhlIGxpbmsgdG8gc29tZXRoaW5nIHRoYXQgT2JzaWRpYW4gY2FuIG9wZW4gLyB1bmRlcnN0YW5kLiAqL1xuICAgIHB1YmxpYyBvYnNpZGlhbkxpbmsoKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgZXNjYXBlZCA9IHRoaXMucGF0aC5yZXBsYWNlQWxsKFwifFwiLCBcIlxcXFx8XCIpO1xuICAgICAgICBpZiAodGhpcy50eXBlID09IFwiaGVhZGVyXCIpIHJldHVybiBlc2NhcGVkICsgXCIjXCIgKyB0aGlzLnN1YnBhdGg/LnJlcGxhY2VBbGwoXCJ8XCIsIFwiXFxcXHxcIik7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT0gXCJibG9ja1wiKSByZXR1cm4gZXNjYXBlZCArIFwiI15cIiArIHRoaXMuc3VicGF0aD8ucmVwbGFjZUFsbChcInxcIiwgXCJcXFxcfFwiKTtcbiAgICAgICAgZWxzZSByZXR1cm4gZXNjYXBlZDtcbiAgICB9XG5cbiAgICAvKiogVGhlIHN0cmlwcGVkIG5hbWUgb2YgdGhlIGZpbGUgdGhpcyBsaW5rIHBvaW50cyB0by4gKi9cbiAgICBwdWJsaWMgZmlsZU5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIGdldEZpbGVUaXRsZSh0aGlzLnBhdGgpLnJlcGxhY2UoXCIubWRcIiwgXCJcIik7XG4gICAgfVxufVxuXG4vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0lER0VUIEJBU0UgLy9cbi8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQSB0cml2aWFsIGJhc2UgY2xhc3Mgd2hpY2gganVzdCBkZWZpbmVzIHRoZSAnJHdpZGdldCcgaWRlbnRpZmllciB0eXBlLiBTdWJ0eXBlcyBvZlxuICogd2lkZ2V0IGFyZSByZXNwb25zaWJsZSBmb3IgYWRkaW5nIHdoYXRldmVyIG1ldGFkYXRhIGlzIHJlbGV2YW50LiBJZiB5b3Ugd2FudCB5b3VyIHdpZGdldFxuICogdG8gaGF2ZSByZW5kZXJpbmcgZnVuY3Rpb25hbGl0eSAod2hpY2ggeW91IHByb2JhYmx5IGRvKSwgeW91IHNob3VsZCBleHRlbmQgYFJlbmRlcldpZGdldGAuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBXaWRnZXQge1xuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihwdWJsaWMgJHdpZGdldDogc3RyaW5nKSB7fVxuXG4gICAgLyoqXG4gICAgICogQXR0ZW1wdCB0byByZW5kZXIgdGhpcyB3aWRnZXQgaW4gbWFya2Rvd24sIGlmIHBvc3NpYmxlOyBpZiBtYXJrZG93biBpcyBub3QgcG9zc2libGUsXG4gICAgICogdGhlbiB0aGlzIHdpbGwgYXR0ZW1wdCB0byByZW5kZXIgYXMgSFRNTC4gTm90ZSB0aGF0IG1hbnkgd2lkZ2V0cyBoYXZlIGludGVyYWN0aXZlXG4gICAgICogY29tcG9uZW50cyBvciBkaWZmaWN1bHQgZnVuY3Rpb25hbCBjb21wb25lbnRzIGFuZCB0aGUgYG1hcmtkb3duYCBmdW5jdGlvbiBjYW4gc2ltcGx5XG4gICAgICogcmV0dXJuIGEgcGxhY2Vob2xkZXIgaW4gdGhpcyBjYXNlIChzdWNoIGFzIGA8ZnVuY3Rpb24+YCBvciBgPHRhc2stbGlzdD5gKS5cbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgbWFya2Rvd24oKTogc3RyaW5nO1xufVxuXG4vKiogQSB0cml2aWFsIHdpZGdldCB3aGljaCByZW5kZXJzIGEgKGtleSwgdmFsdWUpIHBhaXIsIGFuZCBhbGxvd3MgYWNjZXNzaW5nIHRoZSBrZXkgYW5kIHZhbHVlLiAqL1xuZXhwb3J0IGNsYXNzIExpc3RQYWlyV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0IHtcbiAgICBwdWJsaWMgY29uc3RydWN0b3IocHVibGljIGtleTogTGl0ZXJhbCwgcHVibGljIHZhbHVlOiBMaXRlcmFsKSB7XG4gICAgICAgIHN1cGVyKFwiZGF0YXZpZXc6bGlzdC1wYWlyXCIpO1xuICAgIH1cblxuICAgIHB1YmxpYyBvdmVycmlkZSBtYXJrZG93bigpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gYCR7VmFsdWVzLnRvU3RyaW5nKHRoaXMua2V5KX06ICR7VmFsdWVzLnRvU3RyaW5nKHRoaXMudmFsdWUpfWA7XG4gICAgfVxufVxuXG4vKiogQSBzaW1wbGUgd2lkZ2V0IHdoaWNoIHJlbmRlcnMgYW4gZXh0ZXJuYWwgbGluay4gKi9cbmV4cG9ydCBjbGFzcyBFeHRlcm5hbExpbmtXaWRnZXQgZXh0ZW5kcyBXaWRnZXQge1xuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihwdWJsaWMgdXJsOiBzdHJpbmcsIHB1YmxpYyBkaXNwbGF5Pzogc3RyaW5nKSB7XG4gICAgICAgIHN1cGVyKFwiZGF0YXZpZXc6ZXh0ZXJuYWwtbGlua1wiKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb3ZlcnJpZGUgbWFya2Rvd24oKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIGBbJHt0aGlzLmRpc3BsYXkgPz8gdGhpcy51cmx9XSgke3RoaXMudXJsfSlgO1xuICAgIH1cbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBXaWRnZXRzIHtcbiAgICAvKiogQ3JlYXRlIGEgbGlzdCBwYWlyIHdpZGdldCBtYXRjaGluZyB0aGUgZ2l2ZW4ga2V5IGFuZCB2YWx1ZS4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gbGlzdFBhaXIoa2V5OiBMaXRlcmFsLCB2YWx1ZTogTGl0ZXJhbCk6IExpc3RQYWlyV2lkZ2V0IHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaXN0UGFpcldpZGdldChrZXksIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKiogQ3JlYXRlIGFuIGV4dGVybmFsIGxpbmsgd2lkZ2V0IHdoaWNoIHJlbmRlcnMgYW4gZXh0ZXJuYWwgT2JzaWRpYW4gbGluay4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gZXh0ZXJuYWxMaW5rKHVybDogc3RyaW5nLCBkaXNwbGF5Pzogc3RyaW5nKTogRXh0ZXJuYWxMaW5rV2lkZ2V0IHtcbiAgICAgICAgcmV0dXJuIG5ldyBFeHRlcm5hbExpbmtXaWRnZXQodXJsLCBkaXNwbGF5KTtcbiAgICB9XG5cbiAgICAvKiogQ2hlY2tzIGlmIHRoZSBnaXZlbiB3aWRnZXQgaXMgYSBsaXN0IHBhaXIgd2lkZ2V0LiAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiBpc0xpc3RQYWlyKHdpZGdldDogV2lkZ2V0KTogd2lkZ2V0IGlzIExpc3RQYWlyV2lkZ2V0IHtcbiAgICAgICAgcmV0dXJuIHdpZGdldC4kd2lkZ2V0ID09PSBcImRhdGF2aWV3Omxpc3QtcGFpclwiO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBpc0V4dGVybmFsTGluayh3aWRnZXQ6IFdpZGdldCk6IHdpZGdldCBpcyBFeHRlcm5hbExpbmtXaWRnZXQge1xuICAgICAgICByZXR1cm4gd2lkZ2V0LiR3aWRnZXQgPT09IFwiZGF0YXZpZXc6ZXh0ZXJuYWwtbGlua1wiO1xuICAgIH1cblxuICAgIC8qKiBEZXRlcm1pbmVzIGlmIHRoZSBnaXZlbiB3aWRnZXQgaXMgYW55IGtpbmQgb2YgYnVpbHQtaW4gd2lkZ2V0IHdpdGggc3BlY2lhbCByZW5kZXJpbmcgaGFuZGxpbmcuICovXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGlzQnVpbHRpbih3aWRnZXQ6IFdpZGdldCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gaXNMaXN0UGFpcih3aWRnZXQpIHx8IGlzRXh0ZXJuYWxMaW5rKHdpZGdldCk7XG4gICAgfVxufVxuIiwgIi8qKiBEZWZpbmVzIHRoZSBBU1QgZm9yIGEgZmllbGQgd2hpY2ggY2FuIGJlIGV2YWx1YXRlZC4gKi9cbmltcG9ydCB7IExpdGVyYWwgfSBmcm9tIFwiZGF0YS1tb2RlbC92YWx1ZVwiO1xuXG4vKiogQ29tcGFyaXNvbiBvcGVyYXRvcnMgd2hpY2ggeWllbGQgdHJ1ZS9mYWxzZS4gKi9cbmV4cG9ydCB0eXBlIENvbXBhcmVPcCA9IFwiPlwiIHwgXCI+PVwiIHwgXCI8PVwiIHwgXCI8XCIgfCBcIj1cIiB8IFwiIT1cIjtcbi8qKiBBcml0aG1ldGljIG9wZXJhdG9ycyB3aGljaCB5aWVsZCBudW1iZXJzIGFuZCBvdGhlciB2YWx1ZXMuICovXG5leHBvcnQgdHlwZSBBcml0aG1ldGljT3AgPSBcIitcIiB8IFwiLVwiIHwgXCIqXCIgfCBcIi9cIiB8IFwiJVwiIHwgXCImXCIgfCBcInxcIjtcbi8qKiBBbGwgdmFsaWQgYmluYXJ5IG9wZXJhdG9ycy4gKi9cbmV4cG9ydCB0eXBlIEJpbmFyeU9wID0gQ29tcGFyZU9wIHwgQXJpdGhtZXRpY09wO1xuLyoqIEEgKHBvdGVudGlhbGx5IGNvbXB1dGVkKSBmaWVsZCB0byBzZWxlY3Qgb3IgY29tcGFyZSBhZ2FpbnN0LiAqL1xuZXhwb3J0IHR5cGUgRmllbGQgPVxuICAgIHwgQmluYXJ5T3BGaWVsZFxuICAgIHwgVmFyaWFibGVGaWVsZFxuICAgIHwgTGl0ZXJhbEZpZWxkXG4gICAgfCBGdW5jdGlvbkZpZWxkXG4gICAgfCBJbmRleEZpZWxkXG4gICAgfCBOZWdhdGVkRmllbGRcbiAgICB8IExhbWJkYUZpZWxkXG4gICAgfCBPYmplY3RGaWVsZFxuICAgIHwgTGlzdEZpZWxkO1xuXG4vKiogTGl0ZXJhbCByZXByZXNlbnRhdGlvbiBvZiBzb21lIGZpZWxkIHR5cGUuICovXG5leHBvcnQgaW50ZXJmYWNlIExpdGVyYWxGaWVsZCB7XG4gICAgdHlwZTogXCJsaXRlcmFsXCI7XG4gICAgdmFsdWU6IExpdGVyYWw7XG59XG5cbi8qKiBBIHZhcmlhYmxlIGZpZWxkIGZvciBhIHZhcmlhYmxlIHdpdGggYSBnaXZlbiBuYW1lLiAqL1xuZXhwb3J0IGludGVyZmFjZSBWYXJpYWJsZUZpZWxkIHtcbiAgICB0eXBlOiBcInZhcmlhYmxlXCI7XG4gICAgbmFtZTogc3RyaW5nO1xufVxuXG4vKiogQSBsaXN0LCB3aGljaCBpcyBhbiBvcmRlcmVkIGNvbGxlY3Rpb24gb2YgZmllbGRzLiAqL1xuZXhwb3J0IGludGVyZmFjZSBMaXN0RmllbGQge1xuICAgIHR5cGU6IFwibGlzdFwiO1xuICAgIHZhbHVlczogRmllbGRbXTtcbn1cblxuLyoqIEFuIG9iamVjdCwgd2hpY2ggaXMgYSBtYXBwaW5nIG9mIG5hbWUgdG8gZmllbGQuICovXG5leHBvcnQgaW50ZXJmYWNlIE9iamVjdEZpZWxkIHtcbiAgICB0eXBlOiBcIm9iamVjdFwiO1xuICAgIHZhbHVlczogUmVjb3JkPHN0cmluZywgRmllbGQ+O1xufVxuXG4vKiogQSBiaW5hcnkgb3BlcmF0b3IgZmllbGQgd2hpY2ggY29tYmluZXMgdHdvIHN1Ym5vZGVzIHNvbWVob3cuICovXG5leHBvcnQgaW50ZXJmYWNlIEJpbmFyeU9wRmllbGQge1xuICAgIHR5cGU6IFwiYmluYXJ5b3BcIjtcbiAgICBsZWZ0OiBGaWVsZDtcbiAgICByaWdodDogRmllbGQ7XG4gICAgb3A6IEJpbmFyeU9wO1xufVxuXG4vKiogQSBmdW5jdGlvbiBmaWVsZCB3aGljaCBjYWxscyBhIGZ1bmN0aW9uIG9uIDAgb3IgbW9yZSBhcmd1bWVudHMuICovXG5leHBvcnQgaW50ZXJmYWNlIEZ1bmN0aW9uRmllbGQge1xuICAgIHR5cGU6IFwiZnVuY3Rpb25cIjtcbiAgICAvKiogRWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiBiZWluZyBjYWxsZWQsIG9yIGEgRnVuY3Rpb24gb2JqZWN0LiAqL1xuICAgIGZ1bmM6IEZpZWxkO1xuICAgIC8qKiBUaGUgYXJndW1lbnRzIGJlaW5nIHBhc3NlZCB0byB0aGUgZnVuY3Rpb24uICovXG4gICAgYXJndW1lbnRzOiBGaWVsZFtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExhbWJkYUZpZWxkIHtcbiAgICB0eXBlOiBcImxhbWJkYVwiO1xuICAgIC8qKiBBbiBvcmRlcmVkIGxpc3Qgb2YgbmFtZWQgYXJndW1lbnRzLiAqL1xuICAgIGFyZ3VtZW50czogc3RyaW5nW107XG4gICAgLyoqIFRoZSBmaWVsZCB3aGljaCBzaG91bGQgYmUgZXZhbHVhdGVkIHdpdGggdGhlIGFyZ3VtZW50cyBpbiBjb250ZXh0LiAqL1xuICAgIHZhbHVlOiBGaWVsZDtcbn1cblxuLyoqIEEgZmllbGQgd2hpY2ggaW5kZXhlcyBhIHZhcmlhYmxlIGludG8gYW5vdGhlciB2YXJpYWJsZS4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW5kZXhGaWVsZCB7XG4gICAgdHlwZTogXCJpbmRleFwiO1xuICAgIC8qKiBUaGUgZmllbGQgdG8gaW5kZXggaW50by4gKi9cbiAgICBvYmplY3Q6IEZpZWxkO1xuICAgIC8qKiBUaGUgaW5kZXguICovXG4gICAgaW5kZXg6IEZpZWxkO1xufVxuXG4vKiogQSBmaWVsZCB3aGljaCBuZWdhdGVzIHRoZSB2YWx1ZSBvZiB0aGUgb3JpZ2luYWwgZmllbGQuICovXG5leHBvcnQgaW50ZXJmYWNlIE5lZ2F0ZWRGaWVsZCB7XG4gICAgdHlwZTogXCJuZWdhdGVkXCI7XG4gICAgLyoqIFRoZSBjaGlsZCBmaWVsZCB0byBuZWdhdGVkLiAqL1xuICAgIGNoaWxkOiBGaWVsZDtcbn1cblxuLyoqIFV0aWxpdHkgbWV0aG9kcyBmb3IgY3JlYXRpbmcgJiBjb21wYXJpbmcgZmllbGRzLiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBGaWVsZHMge1xuICAgIGV4cG9ydCBmdW5jdGlvbiB2YXJpYWJsZShuYW1lOiBzdHJpbmcpOiBWYXJpYWJsZUZpZWxkIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJ2YXJpYWJsZVwiLCBuYW1lIH07XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGxpdGVyYWwodmFsdWU6IExpdGVyYWwpOiBMaXRlcmFsRmllbGQge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWUgfTtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gYmluYXJ5T3AobGVmdDogRmllbGQsIG9wOiBCaW5hcnlPcCwgcmlnaHQ6IEZpZWxkKTogRmllbGQge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImJpbmFyeW9wXCIsIGxlZnQsIG9wLCByaWdodCB9IGFzIEJpbmFyeU9wRmllbGQ7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGluZGV4KG9iajogRmllbGQsIGluZGV4OiBGaWVsZCk6IEluZGV4RmllbGQge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImluZGV4XCIsIG9iamVjdDogb2JqLCBpbmRleCB9O1xuICAgIH1cblxuICAgIC8qKiBDb252ZXJ0cyBhIHN0cmluZyBpbiBkb3Qtbm90YXRpb24tZm9ybWF0IGludG8gYSB2YXJpYWJsZSB3aGljaCBpbmRleGVzLiAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiBpbmRleFZhcmlhYmxlKG5hbWU6IHN0cmluZyk6IEZpZWxkIHtcbiAgICAgICAgbGV0IHBhcnRzID0gbmFtZS5zcGxpdChcIi5cIik7XG4gICAgICAgIGxldCByZXN1bHQ6IEZpZWxkID0gRmllbGRzLnZhcmlhYmxlKHBhcnRzWzBdKTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAxOyBpbmRleCA8IHBhcnRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgcmVzdWx0ID0gRmllbGRzLmluZGV4KHJlc3VsdCwgRmllbGRzLmxpdGVyYWwocGFydHNbaW5kZXhdKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBsYW1iZGEoYXJnczogc3RyaW5nW10sIHZhbHVlOiBGaWVsZCk6IExhbWJkYUZpZWxkIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJsYW1iZGFcIiwgYXJndW1lbnRzOiBhcmdzLCB2YWx1ZSB9O1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBmdW5jKGZ1bmM6IEZpZWxkLCBhcmdzOiBGaWVsZFtdKTogRnVuY3Rpb25GaWVsZCB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiZnVuY3Rpb25cIiwgZnVuYywgYXJndW1lbnRzOiBhcmdzIH07XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGxpc3QodmFsdWVzOiBGaWVsZFtdKTogTGlzdEZpZWxkIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJsaXN0XCIsIHZhbHVlcyB9O1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBvYmplY3QodmFsdWVzOiBSZWNvcmQ8c3RyaW5nLCBGaWVsZD4pOiBPYmplY3RGaWVsZCB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwib2JqZWN0XCIsIHZhbHVlcyB9O1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBuZWdhdGUoY2hpbGQ6IEZpZWxkKTogTmVnYXRlZEZpZWxkIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJuZWdhdGVkXCIsIGNoaWxkIH07XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGlzQ29tcGFyZU9wKG9wOiBCaW5hcnlPcCk6IG9wIGlzIENvbXBhcmVPcCB7XG4gICAgICAgIHJldHVybiBvcCA9PSBcIjw9XCIgfHwgb3AgPT0gXCI8XCIgfHwgb3AgPT0gXCI+XCIgfHwgb3AgPT0gXCI+PVwiIHx8IG9wID09IFwiIT1cIiB8fCBvcCA9PSBcIj1cIjtcbiAgICB9XG5cbiAgICBleHBvcnQgY29uc3QgTlVMTCA9IEZpZWxkcy5saXRlcmFsKG51bGwpO1xufVxuIiwgIi8qKiBBU1QgaW1wbGVtZW50YXRpb24gZm9yIHF1ZXJpZXMgb3ZlciBkYXRhIHNvdXJjZXMuICovXG5cbi8qKiBUaGUgc291cmNlIG9mIGZpbGVzIGZvciBhIHF1ZXJ5LiAqL1xuZXhwb3J0IHR5cGUgU291cmNlID0gVGFnU291cmNlIHwgQ3N2U291cmNlIHwgRm9sZGVyU291cmNlIHwgTGlua1NvdXJjZSB8IEVtcHR5U291cmNlIHwgTmVnYXRlZFNvdXJjZSB8IEJpbmFyeU9wU291cmNlO1xuLyoqIFZhbGlkIG9wZXJhdGlvbnMgZm9yIGNvbWJpbmluZyBzb3VyY2VzLiAqL1xuZXhwb3J0IHR5cGUgU291cmNlT3AgPSBcIiZcIiB8IFwifFwiO1xuXG4vKiogQSB0YWcgYXMgYSBzb3VyY2Ugb2YgZGF0YS4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGFnU291cmNlIHtcbiAgICB0eXBlOiBcInRhZ1wiO1xuICAgIC8qKiBUaGUgdGFnIHRvIHNvdXJjZSBmcm9tLiAqL1xuICAgIHRhZzogc3RyaW5nO1xufVxuXG4vKiogQSBjc3YgYXMgYSBzb3VyY2Ugb2YgZGF0YS4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ3N2U291cmNlIHtcbiAgICB0eXBlOiBcImNzdlwiO1xuICAgIC8qKiBUaGUgcGF0aCB0byB0aGUgQ1NWIGZpbGUuICovXG4gICAgcGF0aDogc3RyaW5nO1xufVxuXG4vKiogQSBmb2xkZXIgcHJlZml4IGFzIGEgc291cmNlIG9mIGRhdGEuICovXG5leHBvcnQgaW50ZXJmYWNlIEZvbGRlclNvdXJjZSB7XG4gICAgdHlwZTogXCJmb2xkZXJcIjtcbiAgICAvKiogVGhlIGZvbGRlciBwcmVmaXggdG8gc291cmNlIGZyb20uICovXG4gICAgZm9sZGVyOiBzdHJpbmc7XG59XG5cbi8qKiBFaXRoZXIgaW5jb21pbmcgb3Igb3V0Z29pbmcgbGlua3MgdG8gYSBnaXZlbiBmaWxlLiAqL1xuZXhwb3J0IGludGVyZmFjZSBMaW5rU291cmNlIHtcbiAgICB0eXBlOiBcImxpbmtcIjtcbiAgICAvKiogVGhlIGZpbGUgdG8gbG9vayBmb3IgbGlua3MgdG8vZnJvbS4gICovXG4gICAgZmlsZTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRoZSBkaXJlY3Rpb24gdG8gbG9vayAtIGlmIGluY29taW5nLCB0aGVuIGFsbCBmaWxlcyBsaW5raW5nIHRvIHRoZSB0YXJnZXQgZmlsZS4gSWYgb3V0Z29pbmcsIHRoZW4gYWxsIGZpbGVzXG4gICAgICogd2hpY2ggdGhlIGZpbGUgbGlua3MgdG8uXG4gICAgICovXG4gICAgZGlyZWN0aW9uOiBcImluY29taW5nXCIgfCBcIm91dGdvaW5nXCI7XG59XG5cbi8qKiBBIHNvdXJjZSB3aGljaCBpcyBldmVyeXRoaW5nIEVYQ0VQVCB0aGUgZmlsZXMgcmV0dXJuZWQgYnkgdGhlIGdpdmVuIHNvdXJjZS4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmVnYXRlZFNvdXJjZSB7XG4gICAgdHlwZTogXCJuZWdhdGVcIjtcbiAgICAvKiogVGhlIHNvdXJjZSB0byBuZWdhdGUuICovXG4gICAgY2hpbGQ6IFNvdXJjZTtcbn1cblxuLyoqIEEgc291cmNlIHdoaWNoIHlpZWxkcyBub3RoaW5nLiAqL1xuZXhwb3J0IGludGVyZmFjZSBFbXB0eVNvdXJjZSB7XG4gICAgdHlwZTogXCJlbXB0eVwiO1xufVxuXG4vKiogQSBzb3VyY2UgbWFkZSBieSBjb21iaW5pbmcgc3Vic291cmNlcyB3aXRoIGEgbG9naWNhbCBvcGVyYXRvcnMuICovXG5leHBvcnQgaW50ZXJmYWNlIEJpbmFyeU9wU291cmNlIHtcbiAgICB0eXBlOiBcImJpbmFyeW9wXCI7XG4gICAgb3A6IFNvdXJjZU9wO1xuICAgIGxlZnQ6IFNvdXJjZTtcbiAgICByaWdodDogU291cmNlO1xufVxuXG4vKiogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIGNyZWF0aW5nIGFuZCBtYW5pcHVsYXRpbmcgc291cmNlcy4gKi9cbmV4cG9ydCBuYW1lc3BhY2UgU291cmNlcyB7XG4gICAgLyoqIENyZWF0ZSBhIHNvdXJjZSB3aGljaCBzZWFyY2hlcyBmcm9tIGEgdGFnLiAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiB0YWcodGFnOiBzdHJpbmcpOiBUYWdTb3VyY2Uge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcInRhZ1wiLCB0YWcgfTtcbiAgICB9XG5cbiAgICAvKiogQ3JlYXRlIGEgc291cmNlIHdoaWNoIGZldGNoZXMgZnJvbSBhIENTViBmaWxlLiAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiBjc3YocGF0aDogc3RyaW5nKTogQ3N2U291cmNlIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJjc3ZcIiwgcGF0aCB9O1xuICAgIH1cblxuICAgIC8qKiBDcmVhdGUgYSBzb3VyY2Ugd2hpY2ggc2VhcmNoZXMgZm9yIGZpbGVzIHVuZGVyIGEgZm9sZGVyIHByZWZpeC4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gZm9sZGVyKHByZWZpeDogc3RyaW5nKTogRm9sZGVyU291cmNlIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJmb2xkZXJcIiwgZm9sZGVyOiBwcmVmaXggfTtcbiAgICB9XG5cbiAgICAvKiogQ3JlYXRlIGEgc291cmNlIHdoaWNoIHNlYXJjaGVzIGZvciBmaWxlcyB3aGljaCBsaW5rIHRvL2Zyb20gYSBnaXZlbiBmaWxlLiAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiBsaW5rKGZpbGU6IHN0cmluZywgaW5jb21pbmc6IGJvb2xlYW4pOiBMaW5rU291cmNlIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJsaW5rXCIsIGZpbGUsIGRpcmVjdGlvbjogaW5jb21pbmcgPyBcImluY29taW5nXCIgOiBcIm91dGdvaW5nXCIgfTtcbiAgICB9XG5cbiAgICAvKiogQ3JlYXRlIGEgc291cmNlIHdoaWNoIGpvaW5zIHR3byBzb3VyY2VzIGJ5IGEgbG9naWNhbCBvcGVyYXRvciAoYW5kL29yKS4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gYmluYXJ5T3AobGVmdDogU291cmNlLCBvcDogU291cmNlT3AsIHJpZ2h0OiBTb3VyY2UpOiBTb3VyY2Uge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImJpbmFyeW9wXCIsIGxlZnQsIG9wLCByaWdodCB9O1xuICAgIH1cblxuICAgIC8qKiBDcmVhdGUgYSBzb3VyY2Ugd2hpY2ggdGFrZXMgdGhlIGludGVyc2VjdGlvbiBvZiB0d28gc291cmNlcy4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gYW5kKGxlZnQ6IFNvdXJjZSwgcmlnaHQ6IFNvdXJjZSk6IFNvdXJjZSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiYmluYXJ5b3BcIiwgbGVmdCwgb3A6IFwiJlwiLCByaWdodCB9O1xuICAgIH1cblxuICAgIC8qKiBDcmVhdGUgYSBzb3VyY2Ugd2hpY2ggdGFrZXMgdGhlIHVuaW9uIG9mIHR3byBzb3VyY2VzLiAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiBvcihsZWZ0OiBTb3VyY2UsIHJpZ2h0OiBTb3VyY2UpOiBTb3VyY2Uge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImJpbmFyeW9wXCIsIGxlZnQsIG9wOiBcInxcIiwgcmlnaHQgfTtcbiAgICB9XG5cbiAgICAvKiogQ3JlYXRlIGEgc291cmNlIHdoaWNoIG5lZ2F0ZXMgdGhlIHVuZGVybHlpbmcgc291cmNlLiAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiBuZWdhdGUoY2hpbGQ6IFNvdXJjZSk6IE5lZ2F0ZWRTb3VyY2Uge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcIm5lZ2F0ZVwiLCBjaGlsZCB9O1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBlbXB0eSgpOiBFbXB0eVNvdXJjZSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiZW1wdHlcIiB9O1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBEYXRlVGltZSwgRHVyYXRpb24gfSBmcm9tIFwibHV4b25cIjtcbmltcG9ydCB7IExpdGVyYWwsIExpbmsgfSBmcm9tIFwiZGF0YS1tb2RlbC92YWx1ZVwiO1xuaW1wb3J0ICogYXMgUCBmcm9tIFwicGFyc2ltbW9uXCI7XG5pbXBvcnQgeyBCaW5hcnlPcCwgRmllbGQsIEZpZWxkcywgTGFtYmRhRmllbGQsIExpc3RGaWVsZCwgTGl0ZXJhbEZpZWxkLCBPYmplY3RGaWVsZCwgVmFyaWFibGVGaWVsZCB9IGZyb20gXCIuL2ZpZWxkXCI7XG5pbXBvcnQgeyBGb2xkZXJTb3VyY2UsIE5lZ2F0ZWRTb3VyY2UsIFNvdXJjZSwgU291cmNlT3AsIFNvdXJjZXMsIFRhZ1NvdXJjZSwgQ3N2U291cmNlIH0gZnJvbSBcImRhdGEtaW5kZXgvc291cmNlXCI7XG5pbXBvcnQgeyBub3JtYWxpemVEdXJhdGlvbiB9IGZyb20gXCJ1dGlsL25vcm1hbGl6ZVwiO1xuaW1wb3J0IHsgUmVzdWx0IH0gZnJvbSBcImFwaS9yZXN1bHRcIjtcbmltcG9ydCBlbW9qaVJlZ2V4IGZyb20gXCJlbW9qaS1yZWdleFwiO1xuXG4vKiogRW1vamkgcmVnZXggd2l0aG91dCBhbnkgYWRkaXRpb25hbCBmbGFncy4gKi9cbmNvbnN0IEVNT0pJX1JFR0VYID0gbmV3IFJlZ0V4cChlbW9qaVJlZ2V4KCksIFwiXCIpO1xuXG4vKiogUHJvdmlkZXMgYSBsb29rdXAgdGFibGUgZm9yIHVuaXQgZHVyYXRpb25zIG9mIHRoZSBnaXZlbiB0eXBlLiAqL1xuZXhwb3J0IGNvbnN0IERVUkFUSU9OX1RZUEVTID0ge1xuICAgIHllYXI6IER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMSB9KSxcbiAgICB5ZWFyczogRHVyYXRpb24uZnJvbU9iamVjdCh7IHllYXJzOiAxIH0pLFxuICAgIHlyOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgeWVhcnM6IDEgfSksXG4gICAgeXJzOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgeWVhcnM6IDEgfSksXG5cbiAgICBtb250aDogRHVyYXRpb24uZnJvbU9iamVjdCh7IG1vbnRoczogMSB9KSxcbiAgICBtb250aHM6IER1cmF0aW9uLmZyb21PYmplY3QoeyBtb250aHM6IDEgfSksXG4gICAgbW86IER1cmF0aW9uLmZyb21PYmplY3QoeyBtb250aHM6IDEgfSksXG4gICAgbW9zOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbW9udGhzOiAxIH0pLFxuXG4gICAgd2VlazogRHVyYXRpb24uZnJvbU9iamVjdCh7IHdlZWtzOiAxIH0pLFxuICAgIHdlZWtzOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgd2Vla3M6IDEgfSksXG4gICAgd2s6IER1cmF0aW9uLmZyb21PYmplY3QoeyB3ZWVrczogMSB9KSxcbiAgICB3a3M6IER1cmF0aW9uLmZyb21PYmplY3QoeyB3ZWVrczogMSB9KSxcbiAgICB3OiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgd2Vla3M6IDEgfSksXG5cbiAgICBkYXk6IER1cmF0aW9uLmZyb21PYmplY3QoeyBkYXlzOiAxIH0pLFxuICAgIGRheXM6IER1cmF0aW9uLmZyb21PYmplY3QoeyBkYXlzOiAxIH0pLFxuICAgIGQ6IER1cmF0aW9uLmZyb21PYmplY3QoeyBkYXlzOiAxIH0pLFxuXG4gICAgaG91cjogRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxIH0pLFxuICAgIGhvdXJzOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDEgfSksXG4gICAgaHI6IER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMSB9KSxcbiAgICBocnM6IER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMSB9KSxcbiAgICBoOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDEgfSksXG5cbiAgICBtaW51dGU6IER1cmF0aW9uLmZyb21PYmplY3QoeyBtaW51dGVzOiAxIH0pLFxuICAgIG1pbnV0ZXM6IER1cmF0aW9uLmZyb21PYmplY3QoeyBtaW51dGVzOiAxIH0pLFxuICAgIG1pbjogRHVyYXRpb24uZnJvbU9iamVjdCh7IG1pbnV0ZXM6IDEgfSksXG4gICAgbWluczogRHVyYXRpb24uZnJvbU9iamVjdCh7IG1pbnV0ZXM6IDEgfSksXG4gICAgbTogRHVyYXRpb24uZnJvbU9iamVjdCh7IG1pbnV0ZXM6IDEgfSksXG5cbiAgICBzZWNvbmQ6IER1cmF0aW9uLmZyb21PYmplY3QoeyBzZWNvbmRzOiAxIH0pLFxuICAgIHNlY29uZHM6IER1cmF0aW9uLmZyb21PYmplY3QoeyBzZWNvbmRzOiAxIH0pLFxuICAgIHNlYzogRHVyYXRpb24uZnJvbU9iamVjdCh7IHNlY29uZHM6IDEgfSksXG4gICAgc2VjczogRHVyYXRpb24uZnJvbU9iamVjdCh7IHNlY29uZHM6IDEgfSksXG4gICAgczogRHVyYXRpb24uZnJvbU9iamVjdCh7IHNlY29uZHM6IDEgfSksXG59O1xuXG4vKiogU2hvcnRoYW5kIGZvciBjb21tb24gZGF0ZXMgKHJlbGF0aXZlIHRvIHJpZ2h0IG5vdykuICovXG5leHBvcnQgY29uc3QgREFURV9TSE9SVEhBTkRTID0ge1xuICAgIG5vdzogKCkgPT4gRGF0ZVRpbWUubG9jYWwoKSxcbiAgICB0b2RheTogKCkgPT4gRGF0ZVRpbWUubG9jYWwoKS5zdGFydE9mKFwiZGF5XCIpLFxuICAgIHllc3RlcmRheTogKCkgPT5cbiAgICAgICAgRGF0ZVRpbWUubG9jYWwoKVxuICAgICAgICAgICAgLnN0YXJ0T2YoXCJkYXlcIilcbiAgICAgICAgICAgIC5taW51cyhEdXJhdGlvbi5mcm9tT2JqZWN0KHsgZGF5czogMSB9KSksXG4gICAgdG9tb3Jyb3c6ICgpID0+XG4gICAgICAgIERhdGVUaW1lLmxvY2FsKClcbiAgICAgICAgICAgIC5zdGFydE9mKFwiZGF5XCIpXG4gICAgICAgICAgICAucGx1cyhEdXJhdGlvbi5mcm9tT2JqZWN0KHsgZGF5czogMSB9KSksXG4gICAgc293OiAoKSA9PiBEYXRlVGltZS5sb2NhbCgpLnN0YXJ0T2YoXCJ3ZWVrXCIpLFxuICAgIFwic3RhcnQtb2Ytd2Vla1wiOiAoKSA9PiBEYXRlVGltZS5sb2NhbCgpLnN0YXJ0T2YoXCJ3ZWVrXCIpLFxuICAgIGVvdzogKCkgPT4gRGF0ZVRpbWUubG9jYWwoKS5lbmRPZihcIndlZWtcIiksXG4gICAgXCJlbmQtb2Ytd2Vla1wiOiAoKSA9PiBEYXRlVGltZS5sb2NhbCgpLmVuZE9mKFwid2Vla1wiKSxcbiAgICBzb3k6ICgpID0+IERhdGVUaW1lLmxvY2FsKCkuc3RhcnRPZihcInllYXJcIiksXG4gICAgXCJzdGFydC1vZi15ZWFyXCI6ICgpID0+IERhdGVUaW1lLmxvY2FsKCkuc3RhcnRPZihcInllYXJcIiksXG4gICAgZW95OiAoKSA9PiBEYXRlVGltZS5sb2NhbCgpLmVuZE9mKFwieWVhclwiKSxcbiAgICBcImVuZC1vZi15ZWFyXCI6ICgpID0+IERhdGVUaW1lLmxvY2FsKCkuZW5kT2YoXCJ5ZWFyXCIpLFxuICAgIHNvbTogKCkgPT4gRGF0ZVRpbWUubG9jYWwoKS5zdGFydE9mKFwibW9udGhcIiksXG4gICAgXCJzdGFydC1vZi1tb250aFwiOiAoKSA9PiBEYXRlVGltZS5sb2NhbCgpLnN0YXJ0T2YoXCJtb250aFwiKSxcbiAgICBlb206ICgpID0+IERhdGVUaW1lLmxvY2FsKCkuZW5kT2YoXCJtb250aFwiKSxcbiAgICBcImVuZC1vZi1tb250aFwiOiAoKSA9PiBEYXRlVGltZS5sb2NhbCgpLmVuZE9mKFwibW9udGhcIiksXG59O1xuXG4vKipcbiAqIEtleXdvcmRzIHdoaWNoIGNhbm5vdCBiZSB1c2VkIGFzIHZhcmlhYmxlcyBkaXJlY3RseS4gVXNlIGByb3cuPHRoaW5nPmAgaWYgaXQgaXMgYSB2YXJpYWJsZSB5b3UgaGF2ZSBkZWZpbmVkIGFuZCB3YW50XG4gKiB0byBhY2Nlc3MuXG4gKi9cbmV4cG9ydCBjb25zdCBLRVlXT1JEUyA9IFtcIkZST01cIiwgXCJXSEVSRVwiLCBcIkxJTUlUXCIsIFwiR1JPVVBcIiwgXCJGTEFUVEVOXCJdO1xuXG4vLy8vLy8vLy8vLy8vLy9cbi8vIFV0aWxpdGllcyAvL1xuLy8vLy8vLy8vLy8vLy8vXG5cbi8qKiBTcGxpdCBvbiB1bmVzY2FwZWQgcGlwZXMgaW4gYW4gaW5uZXIgbGluay4gKi9cbmZ1bmN0aW9uIHNwbGl0T25VbmVzY2FwZWRQaXBlKGxpbms6IHN0cmluZyk6IFtzdHJpbmcsIHN0cmluZyB8IHVuZGVmaW5lZF0ge1xuICAgIGxldCBwaXBlID0gLTE7XG4gICAgd2hpbGUgKChwaXBlID0gbGluay5pbmRleE9mKFwifFwiLCBwaXBlICsgMSkpID49IDApIHtcbiAgICAgICAgaWYgKHBpcGUgPiAwICYmIGxpbmtbcGlwZSAtIDFdID09IFwiXFxcXFwiKSBjb250aW51ZTtcbiAgICAgICAgcmV0dXJuIFtsaW5rLnN1YnN0cmluZygwLCBwaXBlKS5yZXBsYWNlKC9cXFxcXFx8L2csIFwifFwiKSwgbGluay5zdWJzdHJpbmcocGlwZSArIDEpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gW2xpbmsucmVwbGFjZSgvXFxcXFxcfC9nLCBcInxcIiksIHVuZGVmaW5lZF07XG59XG5cbi8qKiBBdHRlbXB0IHRvIHBhcnNlIHRoZSBpbnNpZGUgb2YgYSBsaW5rIHRvIHB1bGwgb3V0IGRpc3BsYXkgbmFtZSwgc3VicGF0aCwgZXRjLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSW5uZXJMaW5rKHJhd2xpbms6IHN0cmluZyk6IExpbmsge1xuICAgIGxldCBbbGluaywgZGlzcGxheV0gPSBzcGxpdE9uVW5lc2NhcGVkUGlwZShyYXdsaW5rKTtcbiAgICByZXR1cm4gTGluay5pbmZlcihsaW5rLCBmYWxzZSwgZGlzcGxheSk7XG59XG5cbi8qKiBDcmVhdGUgYSBsZWZ0LWFzc29jaWF0aXZlIGJpbmFyeSBwYXJzZXIgd2hpY2ggcGFyc2VzIHRoZSBnaXZlbiBzdWItZWxlbWVudCBhbmQgc2VwYXJhdG9yLiBIYW5kbGVzIHdoaXRlc3BhY2UuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQmluYXJ5UGFyc2VyPFQsIFU+KFxuICAgIGNoaWxkOiBQLlBhcnNlcjxUPixcbiAgICBzZXA6IFAuUGFyc2VyPFU+LFxuICAgIGNvbWJpbmU6IChhOiBULCBiOiBVLCBjOiBUKSA9PiBUXG4pOiBQLlBhcnNlcjxUPiB7XG4gICAgcmV0dXJuIFAuc2VxTWFwKGNoaWxkLCBQLnNlcShQLm9wdFdoaXRlc3BhY2UsIHNlcCwgUC5vcHRXaGl0ZXNwYWNlLCBjaGlsZCkubWFueSgpLCAoZmlyc3QsIHJlc3QpID0+IHtcbiAgICAgICAgaWYgKHJlc3QubGVuZ3RoID09IDApIHJldHVybiBmaXJzdDtcblxuICAgICAgICBsZXQgbm9kZSA9IGNvbWJpbmUoZmlyc3QsIHJlc3RbMF1bMV0sIHJlc3RbMF1bM10pO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDE7IGluZGV4IDwgcmVzdC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIG5vZGUgPSBjb21iaW5lKG5vZGUsIHJlc3RbaW5kZXhdWzFdLCByZXN0W2luZGV4XVszXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGFpbk9wdDxUPihiYXNlOiBQLlBhcnNlcjxUPiwgLi4uZnVuY3M6ICgocjogVCkgPT4gUC5QYXJzZXI8VD4pW10pOiBQLlBhcnNlcjxUPiB7XG4gICAgcmV0dXJuIFAuY3VzdG9tKChzdWNjZXNzLCBmYWlsdXJlKSA9PiB7XG4gICAgICAgIHJldHVybiAoaW5wdXQsIGkpID0+IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSAoYmFzZSBhcyBhbnkpLl8oaW5wdXQsIGkpO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQuc3RhdHVzKSByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgICAgICBmb3IgKGxldCBmdW5jIG9mIGZ1bmNzKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSAoZnVuYyhyZXN1bHQudmFsdWUgYXMgVCkgYXMgYW55KS5fKGlucHV0LCByZXN1bHQuaW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmICghbmV4dC5zdGF0dXMpIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXh0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgIH0pO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEV4cHJlc3Npb24gUGFyc2luZyAvL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmV4cG9ydCB0eXBlIFBvc3RmaXhGcmFnbWVudCA9XG4gICAgfCB7IHR5cGU6IFwiZG90XCI7IGZpZWxkOiBzdHJpbmcgfVxuICAgIHwgeyB0eXBlOiBcImluZGV4XCI7IGZpZWxkOiBGaWVsZCB9XG4gICAgfCB7IHR5cGU6IFwiZnVuY3Rpb25cIjsgZmllbGRzOiBGaWVsZFtdIH07XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXhwcmVzc2lvbkxhbmd1YWdlIHtcbiAgICBudW1iZXI6IG51bWJlcjtcbiAgICBzdHJpbmc6IHN0cmluZztcbiAgICBlc2NhcGVDaGFyYWN0ZXI6IHN0cmluZztcbiAgICBib29sOiBib29sZWFuO1xuICAgIHRhZzogc3RyaW5nO1xuICAgIGlkZW50aWZpZXI6IHN0cmluZztcbiAgICBsaW5rOiBMaW5rO1xuICAgIGVtYmVkTGluazogTGluaztcbiAgICByb290RGF0ZTogRGF0ZVRpbWU7XG4gICAgZGF0ZVNob3J0aGFuZDoga2V5b2YgdHlwZW9mIERBVEVfU0hPUlRIQU5EUztcbiAgICBkYXRlOiBEYXRlVGltZTtcbiAgICBkYXRlUGx1czogRGF0ZVRpbWU7XG4gICAgZHVyYXRpb25UeXBlOiBrZXlvZiB0eXBlb2YgRFVSQVRJT05fVFlQRVM7XG4gICAgZHVyYXRpb246IER1cmF0aW9uO1xuICAgIHJhd051bGw6IHN0cmluZztcblxuICAgIGJpbmFyeVBsdXNNaW51czogQmluYXJ5T3A7XG4gICAgYmluYXJ5TXVsRGl2OiBCaW5hcnlPcDtcbiAgICBiaW5hcnlDb21wYXJlT3A6IEJpbmFyeU9wO1xuICAgIGJpbmFyeUJvb2xlYW5PcDogQmluYXJ5T3A7XG5cbiAgICAvLyBTb3VyY2UtcmVsYXRlZCBwYXJzZXJzLlxuICAgIHRhZ1NvdXJjZTogVGFnU291cmNlO1xuICAgIGNzdlNvdXJjZTogQ3N2U291cmNlO1xuICAgIGZvbGRlclNvdXJjZTogRm9sZGVyU291cmNlO1xuICAgIHBhcmVuc1NvdXJjZTogU291cmNlO1xuICAgIGF0b21Tb3VyY2U6IFNvdXJjZTtcbiAgICBsaW5rSW5jb21pbmdTb3VyY2U6IFNvdXJjZTtcbiAgICBsaW5rT3V0Z29pbmdTb3VyY2U6IFNvdXJjZTtcbiAgICBuZWdhdGVTb3VyY2U6IE5lZ2F0ZWRTb3VyY2U7XG4gICAgYmluYXJ5T3BTb3VyY2U6IFNvdXJjZTtcbiAgICBzb3VyY2U6IFNvdXJjZTtcblxuICAgIC8vIEZpZWxkLXJlbGF0ZWQgcGFyc2Vycy5cbiAgICB2YXJpYWJsZUZpZWxkOiBWYXJpYWJsZUZpZWxkO1xuICAgIG51bWJlckZpZWxkOiBMaXRlcmFsRmllbGQ7XG4gICAgYm9vbEZpZWxkOiBMaXRlcmFsRmllbGQ7XG4gICAgc3RyaW5nRmllbGQ6IExpdGVyYWxGaWVsZDtcbiAgICBkYXRlRmllbGQ6IExpdGVyYWxGaWVsZDtcbiAgICBkdXJhdGlvbkZpZWxkOiBMaXRlcmFsRmllbGQ7XG4gICAgbGlua0ZpZWxkOiBMaXRlcmFsRmllbGQ7XG4gICAgbnVsbEZpZWxkOiBMaXRlcmFsRmllbGQ7XG5cbiAgICBsaXN0RmllbGQ6IExpc3RGaWVsZDtcbiAgICBvYmplY3RGaWVsZDogT2JqZWN0RmllbGQ7XG5cbiAgICBhdG9tSW5saW5lRmllbGQ6IExpdGVyYWw7XG4gICAgaW5saW5lRmllbGRMaXN0OiBMaXRlcmFsW107XG4gICAgaW5saW5lRmllbGQ6IExpdGVyYWw7XG5cbiAgICBuZWdhdGVkRmllbGQ6IEZpZWxkO1xuICAgIGF0b21GaWVsZDogRmllbGQ7XG4gICAgaW5kZXhGaWVsZDogRmllbGQ7XG4gICAgbGFtYmRhRmllbGQ6IExhbWJkYUZpZWxkO1xuXG4gICAgLy8gUG9zdGZpeCBwYXJzZXJzIGZvciBmdW5jdGlvbiBjYWxscyAmIHRoZSBsaWtlLlxuICAgIGRvdFBvc3RmaXg6IFBvc3RmaXhGcmFnbWVudDtcbiAgICBpbmRleFBvc3RmaXg6IFBvc3RmaXhGcmFnbWVudDtcbiAgICBmdW5jdGlvblBvc3RmaXg6IFBvc3RmaXhGcmFnbWVudDtcblxuICAgIC8vIEJpbmFyeSBvcCBwYXJzZXJzLlxuICAgIGJpbmFyeU11bERpdkZpZWxkOiBGaWVsZDtcbiAgICBiaW5hcnlQbHVzTWludXNGaWVsZDogRmllbGQ7XG4gICAgYmluYXJ5Q29tcGFyZUZpZWxkOiBGaWVsZDtcbiAgICBiaW5hcnlCb29sZWFuRmllbGQ6IEZpZWxkO1xuICAgIGJpbmFyeU9wRmllbGQ6IEZpZWxkO1xuICAgIHBhcmVuc0ZpZWxkOiBGaWVsZDtcbiAgICBmaWVsZDogRmllbGQ7XG59XG5cbmV4cG9ydCBjb25zdCBFWFBSRVNTSU9OID0gUC5jcmVhdGVMYW5ndWFnZTxFeHByZXNzaW9uTGFuZ3VhZ2U+KHtcbiAgICAvLyBBIGZsb2F0aW5nIHBvaW50IG51bWJlcjsgdGhlIGRlY2ltYWwgcG9pbnQgaXMgb3B0aW9uYWwuXG4gICAgbnVtYmVyOiBxID0+XG4gICAgICAgIFAucmVnZXhwKC8tP1swLTldKyhcXC5bMC05XSspPy8pXG4gICAgICAgICAgICAubWFwKHN0ciA9PiBOdW1iZXIucGFyc2VGbG9hdChzdHIpKVxuICAgICAgICAgICAgLmRlc2MoXCJudW1iZXJcIiksXG5cbiAgICAvLyBBIHF1b3RlLXN1cnJvdW5kZWQgc3RyaW5nIHdoaWNoIHN1cHBvcnRzIGVzY2FwZSBjaGFyYWN0ZXJzICgnXFwnKS5cbiAgICBzdHJpbmc6IHEgPT5cbiAgICAgICAgUC5zdHJpbmcoJ1wiJylcbiAgICAgICAgICAgIC50aGVuKFxuICAgICAgICAgICAgICAgIFAuYWx0KHEuZXNjYXBlQ2hhcmFjdGVyLCBQLm5vbmVPZignXCJcXFxcJykpXG4gICAgICAgICAgICAgICAgICAgIC5hdExlYXN0KDApXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoY2hhcnMgPT4gY2hhcnMuam9pbihcIlwiKSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5za2lwKFAuc3RyaW5nKCdcIicpKVxuICAgICAgICAgICAgLmRlc2MoXCJzdHJpbmdcIiksXG5cbiAgICBlc2NhcGVDaGFyYWN0ZXI6IF8gPT5cbiAgICAgICAgUC5zdHJpbmcoXCJcXFxcXCIpXG4gICAgICAgICAgICAudGhlbihQLmFueSlcbiAgICAgICAgICAgIC5tYXAoZXNjYXBlZCA9PiB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgYXJlIGVzY2FwaW5nIGEgYmFja3NsYXNoIG9yIGEgcXVvdGUsIHBhc3MgaW4gb24gaW4gZXNjYXBlZCBmb3JtXG4gICAgICAgICAgICAgICAgaWYgKGVzY2FwZWQgPT09ICdcIicpIHJldHVybiAnXCInO1xuICAgICAgICAgICAgICAgIGlmIChlc2NhcGVkID09PSBcIlxcXFxcIikgcmV0dXJuIFwiXFxcXFwiO1xuICAgICAgICAgICAgICAgIGVsc2UgcmV0dXJuIFwiXFxcXFwiICsgZXNjYXBlZDtcbiAgICAgICAgICAgIH0pLFxuXG4gICAgLy8gQSBib29sZWFuIHRydWUvZmFsc2UgdmFsdWUuXG4gICAgYm9vbDogXyA9PlxuICAgICAgICBQLnJlZ2V4cCgvdHJ1ZXxmYWxzZXxUcnVlfEZhbHNlLylcbiAgICAgICAgICAgIC5tYXAoc3RyID0+IHN0ci50b0xvd2VyQ2FzZSgpID09IFwidHJ1ZVwiKVxuICAgICAgICAgICAgLmRlc2MoXCJib29sZWFuICgndHJ1ZScgb3IgJ2ZhbHNlJylcIiksXG5cbiAgICAvLyBBIHRhZyBvZiB0aGUgZm9ybSAnI3N0dWZmL2hlbGxvLXRoZXJlJy5cbiAgICB0YWc6IF8gPT5cbiAgICAgICAgUC5zZXFNYXAoXG4gICAgICAgICAgICBQLnN0cmluZyhcIiNcIiksXG4gICAgICAgICAgICBQLmFsdChQLnJlZ2V4cCgvW15cXHUyMDAwLVxcdTIwNkZcXHUyRTAwLVxcdTJFN0YnIVwiIyQlJigpKissLjo7PD0+P0BeYHt8fX5cXFtcXF1cXFxcXFxzXS8pLmRlc2MoXCJ0ZXh0XCIpKS5tYW55KCksXG4gICAgICAgICAgICAoc3RhcnQsIHJlc3QpID0+IHN0YXJ0ICsgcmVzdC5qb2luKFwiXCIpXG4gICAgICAgICkuZGVzYyhcInRhZyAoJyNoZWxsby9zdHVmZicpXCIpLFxuXG4gICAgLy8gQSB2YXJpYWJsZSBpZGVudGlmaWVyLCB3aGljaCBpcyBhbHBoYW51bWVyaWMgYW5kIG11c3Qgc3RhcnQgd2l0aCBhIGxldHRlciBvci4uLiBlbW9qaS5cbiAgICBpZGVudGlmaWVyOiBfID0+XG4gICAgICAgIFAuc2VxTWFwKFxuICAgICAgICAgICAgUC5hbHQoUC5yZWdleHAoL1xccHtMZXR0ZXJ9L3UpLCBQLnJlZ2V4cChFTU9KSV9SRUdFWCkuZGVzYyhcInRleHRcIikpLFxuICAgICAgICAgICAgUC5hbHQoUC5yZWdleHAoL1swLTlcXHB7TGV0dGVyfV8tXS91KSwgUC5yZWdleHAoRU1PSklfUkVHRVgpLmRlc2MoXCJ0ZXh0XCIpKS5tYW55KCksXG4gICAgICAgICAgICAoZmlyc3QsIHJlc3QpID0+IGZpcnN0ICsgcmVzdC5qb2luKFwiXCIpXG4gICAgICAgICkuZGVzYyhcInZhcmlhYmxlIGlkZW50aWZpZXJcIiksXG5cbiAgICAvLyBBbiBPYnNpZGlhbiBsaW5rIG9mIHRoZSBmb3JtIFtbPGxpbms+XV0uXG4gICAgbGluazogXyA9PlxuICAgICAgICBQLnJlZ2V4cCgvXFxbXFxbKFteXFxbXFxdXSo/KVxcXVxcXS91LCAxKVxuICAgICAgICAgICAgLm1hcChsaW5rSW5uZXIgPT4gcGFyc2VJbm5lckxpbmsobGlua0lubmVyKSlcbiAgICAgICAgICAgIC5kZXNjKFwiZmlsZSBsaW5rXCIpLFxuXG4gICAgLy8gQW4gZW1iZWRkYWJsZSBsaW5rIHdoaWNoIGNhbiBzdGFydCB3aXRoICchJy4gVGhpcyBvdmVybGFwcyB3aXRoIHRoZSBub3JtYWwgbmVnYXRpb24gb3BlcmF0b3IsIHNvIGl0IGlzIG9ubHlcbiAgICAvLyBwcm92aWRlZCBmb3IgbWV0YWRhdGEgcGFyc2luZy5cbiAgICBlbWJlZExpbms6IHEgPT5cbiAgICAgICAgUC5zZXFNYXAoUC5zdHJpbmcoXCIhXCIpLmF0TW9zdCgxKSwgcS5saW5rLCAocCwgbCkgPT4ge1xuICAgICAgICAgICAgaWYgKHAubGVuZ3RoID4gMCkgbC5lbWJlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gbDtcbiAgICAgICAgfSkuZGVzYyhcImZpbGUgbGlua1wiKSxcblxuICAgIC8vIEJpbmFyeSBwbHVzIG9yIG1pbnVzIG9wZXJhdG9yLlxuICAgIGJpbmFyeVBsdXNNaW51czogXyA9PlxuICAgICAgICBQLnJlZ2V4cCgvXFwrfC0vKVxuICAgICAgICAgICAgLm1hcChzdHIgPT4gc3RyIGFzIEJpbmFyeU9wKVxuICAgICAgICAgICAgLmRlc2MoXCInKycgb3IgJy0nXCIpLFxuXG4gICAgLy8gQmluYXJ5IHRpbWVzIG9yIGRpdmlkZSBvcGVyYXRvci5cbiAgICBiaW5hcnlNdWxEaXY6IF8gPT5cbiAgICAgICAgUC5yZWdleHAoL1xcKnxcXC98JS8pXG4gICAgICAgICAgICAubWFwKHN0ciA9PiBzdHIgYXMgQmluYXJ5T3ApXG4gICAgICAgICAgICAuZGVzYyhcIicqJyBvciAnLycgb3IgJyUnXCIpLFxuXG4gICAgLy8gQmluYXJ5IGNvbXBhcmlzb24gb3BlcmF0b3IuXG4gICAgYmluYXJ5Q29tcGFyZU9wOiBfID0+XG4gICAgICAgIFAucmVnZXhwKC8+PXw8PXwhPXw+fDx8PS8pXG4gICAgICAgICAgICAubWFwKHN0ciA9PiBzdHIgYXMgQmluYXJ5T3ApXG4gICAgICAgICAgICAuZGVzYyhcIic+PScgb3IgJzw9JyBvciAnIT0nIG9yICc9JyBvciAnPicgb3IgJzwnXCIpLFxuXG4gICAgLy8gQmluYXJ5IGJvb2xlYW4gY29tYmluYXRpb24gb3BlcmF0b3IuXG4gICAgYmluYXJ5Qm9vbGVhbk9wOiBfID0+XG4gICAgICAgIFAucmVnZXhwKC9hbmR8b3J8JnxcXHwvaSlcbiAgICAgICAgICAgIC5tYXAoc3RyID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc3RyLnRvTG93ZXJDYXNlKCkgPT0gXCJhbmRcIikgcmV0dXJuIFwiJlwiO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0ci50b0xvd2VyQ2FzZSgpID09IFwib3JcIikgcmV0dXJuIFwifFwiO1xuICAgICAgICAgICAgICAgIGVsc2UgcmV0dXJuIHN0ciBhcyBCaW5hcnlPcDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZGVzYyhcIidhbmQnIG9yICdvcidcIiksXG5cbiAgICAvLyBBIGRhdGUgd2hpY2ggY2FuIGJlIFlZWVktTU1bLUREVEhIOm1tOnNzXS5cbiAgICByb290RGF0ZTogXyA9PlxuICAgICAgICBQLnNlcU1hcChQLnJlZ2V4cCgvXFxkezR9LyksIFAuc3RyaW5nKFwiLVwiKSwgUC5yZWdleHAoL1xcZHsyfS8pLCAoeWVhciwgXywgbW9udGgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBEYXRlVGltZS5mcm9tT2JqZWN0KHsgeWVhcjogTnVtYmVyLnBhcnNlSW50KHllYXIpLCBtb250aDogTnVtYmVyLnBhcnNlSW50KG1vbnRoKSB9KTtcbiAgICAgICAgfSkuZGVzYyhcImRhdGUgaW4gZm9ybWF0IFlZWVktTU1bLUREVEhILU1NLVNTLk1TXVwiKSxcbiAgICBkYXRlU2hvcnRoYW5kOiBfID0+XG4gICAgICAgIFAuYWx0KFxuICAgICAgICAgICAgLi4uT2JqZWN0LmtleXMoREFURV9TSE9SVEhBTkRTKVxuICAgICAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBiLmxlbmd0aCAtIGEubGVuZ3RoKVxuICAgICAgICAgICAgICAgIC5tYXAoUC5zdHJpbmcpXG4gICAgICAgICkgYXMgUC5QYXJzZXI8a2V5b2YgdHlwZW9mIERBVEVfU0hPUlRIQU5EUz4sXG4gICAgZGF0ZTogcSA9PlxuICAgICAgICBjaGFpbk9wdDxEYXRlVGltZT4oXG4gICAgICAgICAgICBxLnJvb3REYXRlLFxuICAgICAgICAgICAgKHltOiBEYXRlVGltZSkgPT5cbiAgICAgICAgICAgICAgICBQLnNlcU1hcChQLnN0cmluZyhcIi1cIiksIFAucmVnZXhwKC9cXGR7Mn0vKSwgKF8sIGRheSkgPT4geW0uc2V0KHsgZGF5OiBOdW1iZXIucGFyc2VJbnQoZGF5KSB9KSksXG4gICAgICAgICAgICAoeW1kOiBEYXRlVGltZSkgPT5cbiAgICAgICAgICAgICAgICBQLnNlcU1hcChQLnN0cmluZyhcIlRcIiksIFAucmVnZXhwKC9cXGR7Mn0vKSwgKF8sIGhvdXIpID0+IHltZC5zZXQoeyBob3VyOiBOdW1iZXIucGFyc2VJbnQoaG91cikgfSkpLFxuICAgICAgICAgICAgKHltZGg6IERhdGVUaW1lKSA9PlxuICAgICAgICAgICAgICAgIFAuc2VxTWFwKFAuc3RyaW5nKFwiOlwiKSwgUC5yZWdleHAoL1xcZHsyfS8pLCAoXywgbWludXRlKSA9PlxuICAgICAgICAgICAgICAgICAgICB5bWRoLnNldCh7IG1pbnV0ZTogTnVtYmVyLnBhcnNlSW50KG1pbnV0ZSkgfSlcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKHltZGhtOiBEYXRlVGltZSkgPT5cbiAgICAgICAgICAgICAgICBQLnNlcU1hcChQLnN0cmluZyhcIjpcIiksIFAucmVnZXhwKC9cXGR7Mn0vKSwgKF8sIHNlY29uZCkgPT5cbiAgICAgICAgICAgICAgICAgICAgeW1kaG0uc2V0KHsgc2Vjb25kOiBOdW1iZXIucGFyc2VJbnQoc2Vjb25kKSB9KVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAoeW1kaG1zOiBEYXRlVGltZSkgPT5cbiAgICAgICAgICAgICAgICBQLmFsdChcbiAgICAgICAgICAgICAgICAgICAgUC5zZXFNYXAoUC5zdHJpbmcoXCIuXCIpLCBQLnJlZ2V4cCgvXFxkezN9LyksIChfLCBtaWxsaXNlY29uZCkgPT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHltZGhtcy5zZXQoeyBtaWxsaXNlY29uZDogTnVtYmVyLnBhcnNlSW50KG1pbGxpc2Vjb25kKSB9KVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBQLnN1Y2NlZWQoeW1kaG1zKSAvLyBwYXNzXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIChkdDogRGF0ZVRpbWUpID0+XG4gICAgICAgICAgICAgICAgUC5hbHQoXG4gICAgICAgICAgICAgICAgICAgIFAuc2VxTWFwKFAuc3RyaW5nKFwiK1wiKS5vcihQLnN0cmluZyhcIi1cIikpLCBQLnJlZ2V4cCgvXFxkezEsMn0oOlxcZHsyfSk/LyksIChwbSwgaHIpID0+XG4gICAgICAgICAgICAgICAgICAgICAgICBkdC5zZXRab25lKFwiVVRDXCIgKyBwbSArIGhyLCB7IGtlZXBMb2NhbFRpbWU6IHRydWUgfSlcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgUC5zZXFNYXAoUC5zdHJpbmcoXCJaXCIpLCAoKSA9PiBkdC5zZXRab25lKFwidXRjXCIsIHsga2VlcExvY2FsVGltZTogdHJ1ZSB9KSksXG4gICAgICAgICAgICAgICAgICAgIFAuc2VxTWFwKFAuc3RyaW5nKFwiW1wiKSwgUC5yZWdleHAoL1swLTlBLVphLXorLVxcL10rL3UpLCBQLnN0cmluZyhcIl1cIiksIChfYSwgem9uZSwgX2IpID0+XG4gICAgICAgICAgICAgICAgICAgICAgICBkdC5zZXRab25lKHpvbmUsIHsga2VlcExvY2FsVGltZTogdHJ1ZSB9KVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICApXG4gICAgICAgICAgICAuYXNzZXJ0KChkdDogRGF0ZVRpbWUpID0+IGR0LmlzVmFsaWQsIFwidmFsaWQgZGF0ZVwiKVxuICAgICAgICAgICAgLmRlc2MoXCJkYXRlIGluIGZvcm1hdCBZWVlZLU1NWy1ERFRISC1NTS1TUy5NU11cIiksXG5cbiAgICAvLyBBIGRhdGUsIHBsdXMgdmFyaW91cyBzaG9ydGhhbmQgdGltZXMgb2YgZGF5IGl0IGNvdWxkIGJlLlxuICAgIGRhdGVQbHVzOiBxID0+XG4gICAgICAgIFAuYWx0PERhdGVUaW1lPihcbiAgICAgICAgICAgIHEuZGF0ZVNob3J0aGFuZC5tYXAoZCA9PiBEQVRFX1NIT1JUSEFORFNbZF0oKSksXG4gICAgICAgICAgICBxLmRhdGVcbiAgICAgICAgKS5kZXNjKFwiZGF0ZSBpbiBmb3JtYXQgWVlZWS1NTVstRERUSEgtTU0tU1MuTVNdIG9yIGluIHNob3J0aGFuZFwiKSxcblxuICAgIC8vIEEgZHVyYXRpb24gb2YgdGltZS5cbiAgICBkdXJhdGlvblR5cGU6IF8gPT5cbiAgICAgICAgUC5hbHQoXG4gICAgICAgICAgICAuLi5PYmplY3Qua2V5cyhEVVJBVElPTl9UWVBFUylcbiAgICAgICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYi5sZW5ndGggLSBhLmxlbmd0aClcbiAgICAgICAgICAgICAgICAubWFwKFAuc3RyaW5nKVxuICAgICAgICApIGFzIFAuUGFyc2VyPGtleW9mIHR5cGVvZiBEVVJBVElPTl9UWVBFUz4sXG4gICAgZHVyYXRpb246IHEgPT5cbiAgICAgICAgUC5zZXFNYXAocS5udW1iZXIsIFAub3B0V2hpdGVzcGFjZSwgcS5kdXJhdGlvblR5cGUsIChjb3VudCwgXywgdCkgPT4gRFVSQVRJT05fVFlQRVNbdF0ubWFwVW5pdHMoeCA9PiB4ICogY291bnQpKVxuICAgICAgICAgICAgLnNlcEJ5MShQLnN0cmluZyhcIixcIikudHJpbShQLm9wdFdoaXRlc3BhY2UpLm9yKFAub3B0V2hpdGVzcGFjZSkpXG4gICAgICAgICAgICAubWFwKGR1cmF0aW9ucyA9PiBkdXJhdGlvbnMucmVkdWNlKChwLCBjKSA9PiBwLnBsdXMoYykpKVxuICAgICAgICAgICAgLmRlc2MoXCJkdXJhdGlvbiBsaWtlIDRocjJtaW5cIiksXG5cbiAgICAvLyBBIHJhdyBudWxsIHZhbHVlLlxuICAgIHJhd051bGw6IF8gPT4gUC5zdHJpbmcoXCJudWxsXCIpLFxuXG4gICAgLy8gU291cmNlIHBhcnNpbmcuXG4gICAgdGFnU291cmNlOiBxID0+IHEudGFnLm1hcCh0YWcgPT4gU291cmNlcy50YWcodGFnKSksXG4gICAgY3N2U291cmNlOiBxID0+XG4gICAgICAgIFAuc2VxTWFwKFAuc3RyaW5nKFwiY3N2KFwiKS5za2lwKFAub3B0V2hpdGVzcGFjZSksIHEuc3RyaW5nLCBQLnN0cmluZyhcIilcIiksIChfMSwgcGF0aCwgXzIpID0+IFNvdXJjZXMuY3N2KHBhdGgpKSxcbiAgICBsaW5rSW5jb21pbmdTb3VyY2U6IHEgPT4gcS5saW5rLm1hcChsaW5rID0+IFNvdXJjZXMubGluayhsaW5rLnBhdGgsIHRydWUpKSxcbiAgICBsaW5rT3V0Z29pbmdTb3VyY2U6IHEgPT5cbiAgICAgICAgUC5zZXFNYXAoUC5zdHJpbmcoXCJvdXRnb2luZyhcIikuc2tpcChQLm9wdFdoaXRlc3BhY2UpLCBxLmxpbmssIFAuc3RyaW5nKFwiKVwiKSwgKF8xLCBsaW5rLCBfMikgPT5cbiAgICAgICAgICAgIFNvdXJjZXMubGluayhsaW5rLnBhdGgsIGZhbHNlKVxuICAgICAgICApLFxuICAgIGZvbGRlclNvdXJjZTogcSA9PiBxLnN0cmluZy5tYXAoc3RyID0+IFNvdXJjZXMuZm9sZGVyKHN0cikpLFxuICAgIHBhcmVuc1NvdXJjZTogcSA9PlxuICAgICAgICBQLnNlcU1hcChcbiAgICAgICAgICAgIFAuc3RyaW5nKFwiKFwiKSxcbiAgICAgICAgICAgIFAub3B0V2hpdGVzcGFjZSxcbiAgICAgICAgICAgIHEuc291cmNlLFxuICAgICAgICAgICAgUC5vcHRXaGl0ZXNwYWNlLFxuICAgICAgICAgICAgUC5zdHJpbmcoXCIpXCIpLFxuICAgICAgICAgICAgKF8xLCBfMiwgZmllbGQsIF8zLCBfNCkgPT4gZmllbGRcbiAgICAgICAgKSxcbiAgICBuZWdhdGVTb3VyY2U6IHEgPT5cbiAgICAgICAgUC5zZXFNYXAoUC5hbHQoUC5zdHJpbmcoXCItXCIpLCBQLnN0cmluZyhcIiFcIikpLCBxLmF0b21Tb3VyY2UsIChfLCBzb3VyY2UpID0+IFNvdXJjZXMubmVnYXRlKHNvdXJjZSkpLFxuICAgIGF0b21Tb3VyY2U6IHEgPT5cbiAgICAgICAgUC5hbHQ8U291cmNlPihcbiAgICAgICAgICAgIHEucGFyZW5zU291cmNlLFxuICAgICAgICAgICAgcS5uZWdhdGVTb3VyY2UsXG4gICAgICAgICAgICBxLmxpbmtPdXRnb2luZ1NvdXJjZSxcbiAgICAgICAgICAgIHEubGlua0luY29taW5nU291cmNlLFxuICAgICAgICAgICAgcS5mb2xkZXJTb3VyY2UsXG4gICAgICAgICAgICBxLnRhZ1NvdXJjZSxcbiAgICAgICAgICAgIHEuY3N2U291cmNlXG4gICAgICAgICksXG4gICAgYmluYXJ5T3BTb3VyY2U6IHEgPT5cbiAgICAgICAgY3JlYXRlQmluYXJ5UGFyc2VyKFxuICAgICAgICAgICAgcS5hdG9tU291cmNlLFxuICAgICAgICAgICAgcS5iaW5hcnlCb29sZWFuT3AubWFwKHMgPT4gcyBhcyBTb3VyY2VPcCksXG4gICAgICAgICAgICBTb3VyY2VzLmJpbmFyeU9wXG4gICAgICAgICksXG4gICAgc291cmNlOiBxID0+IHEuYmluYXJ5T3BTb3VyY2UsXG5cbiAgICAvLyBGaWVsZCBwYXJzaW5nLlxuICAgIHZhcmlhYmxlRmllbGQ6IHEgPT5cbiAgICAgICAgcS5pZGVudGlmaWVyXG4gICAgICAgICAgICAuY2hhaW4ociA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKEtFWVdPUkRTLmluY2x1ZGVzKHIudG9VcHBlckNhc2UoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFAuZmFpbChcIlZhcmlhYmxlIGZpZWxkcyBjYW5ub3QgYmUgYSBrZXl3b3JkIChcIiArIEtFWVdPUkRTLmpvaW4oXCIgb3IgXCIpICsgXCIpXCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQLnN1Y2NlZWQoRmllbGRzLnZhcmlhYmxlKHIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmRlc2MoXCJ2YXJpYWJsZVwiKSxcbiAgICBudW1iZXJGaWVsZDogcSA9PiBxLm51bWJlci5tYXAodmFsID0+IEZpZWxkcy5saXRlcmFsKHZhbCkpLmRlc2MoXCJudW1iZXJcIiksXG4gICAgc3RyaW5nRmllbGQ6IHEgPT4gcS5zdHJpbmcubWFwKHZhbCA9PiBGaWVsZHMubGl0ZXJhbCh2YWwpKS5kZXNjKFwic3RyaW5nXCIpLFxuICAgIGJvb2xGaWVsZDogcSA9PiBxLmJvb2wubWFwKHZhbCA9PiBGaWVsZHMubGl0ZXJhbCh2YWwpKS5kZXNjKFwiYm9vbGVhblwiKSxcbiAgICBkYXRlRmllbGQ6IHEgPT5cbiAgICAgICAgUC5zZXFNYXAoXG4gICAgICAgICAgICBQLnN0cmluZyhcImRhdGUoXCIpLFxuICAgICAgICAgICAgUC5vcHRXaGl0ZXNwYWNlLFxuICAgICAgICAgICAgcS5kYXRlUGx1cyxcbiAgICAgICAgICAgIFAub3B0V2hpdGVzcGFjZSxcbiAgICAgICAgICAgIFAuc3RyaW5nKFwiKVwiKSxcbiAgICAgICAgICAgIChwcmVmaXgsIF8xLCBkYXRlLCBfMiwgcG9zdGZpeCkgPT4gRmllbGRzLmxpdGVyYWwoZGF0ZSlcbiAgICAgICAgKS5kZXNjKFwiZGF0ZVwiKSxcbiAgICBkdXJhdGlvbkZpZWxkOiBxID0+XG4gICAgICAgIFAuc2VxTWFwKFxuICAgICAgICAgICAgUC5zdHJpbmcoXCJkdXIoXCIpLFxuICAgICAgICAgICAgUC5vcHRXaGl0ZXNwYWNlLFxuICAgICAgICAgICAgcS5kdXJhdGlvbixcbiAgICAgICAgICAgIFAub3B0V2hpdGVzcGFjZSxcbiAgICAgICAgICAgIFAuc3RyaW5nKFwiKVwiKSxcbiAgICAgICAgICAgIChwcmVmaXgsIF8xLCBkdXIsIF8yLCBwb3N0Zml4KSA9PiBGaWVsZHMubGl0ZXJhbChkdXIpXG4gICAgICAgICkuZGVzYyhcImR1cmF0aW9uXCIpLFxuICAgIG51bGxGaWVsZDogcSA9PiBxLnJhd051bGwubWFwKF8gPT4gRmllbGRzLk5VTEwpLFxuICAgIGxpbmtGaWVsZDogcSA9PiBxLmxpbmsubWFwKGYgPT4gRmllbGRzLmxpdGVyYWwoZikpLFxuICAgIGxpc3RGaWVsZDogcSA9PlxuICAgICAgICBxLmZpZWxkXG4gICAgICAgICAgICAuc2VwQnkoUC5zdHJpbmcoXCIsXCIpLnRyaW0oUC5vcHRXaGl0ZXNwYWNlKSlcbiAgICAgICAgICAgIC53cmFwKFAuc3RyaW5nKFwiW1wiKS5za2lwKFAub3B0V2hpdGVzcGFjZSksIFAub3B0V2hpdGVzcGFjZS50aGVuKFAuc3RyaW5nKFwiXVwiKSkpXG4gICAgICAgICAgICAubWFwKGwgPT4gRmllbGRzLmxpc3QobCkpXG4gICAgICAgICAgICAuZGVzYyhcImxpc3QgKCdbMSwgMiwgM10nKVwiKSxcbiAgICBvYmplY3RGaWVsZDogcSA9PlxuICAgICAgICBQLnNlcU1hcChxLmlkZW50aWZpZXIub3IocS5zdHJpbmcpLCBQLnN0cmluZyhcIjpcIikudHJpbShQLm9wdFdoaXRlc3BhY2UpLCBxLmZpZWxkLCAobmFtZSwgX3NlcCwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWUsIHZhbHVlIH07XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuc2VwQnkoUC5zdHJpbmcoXCIsXCIpLnRyaW0oUC5vcHRXaGl0ZXNwYWNlKSlcbiAgICAgICAgICAgIC53cmFwKFAuc3RyaW5nKFwie1wiKS5za2lwKFAub3B0V2hpdGVzcGFjZSksIFAub3B0V2hpdGVzcGFjZS50aGVuKFAuc3RyaW5nKFwifVwiKSkpXG4gICAgICAgICAgICAubWFwKHZhbHMgPT4ge1xuICAgICAgICAgICAgICAgIGxldCByZXM6IFJlY29yZDxzdHJpbmcsIEZpZWxkPiA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGVudHJ5IG9mIHZhbHMpIHJlc1tlbnRyeS5uYW1lXSA9IGVudHJ5LnZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBGaWVsZHMub2JqZWN0KHJlcyk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmRlc2MoXCJvYmplY3QgKCd7IGE6IDEsIGI6IDIgfScpXCIpLFxuXG4gICAgYXRvbUlubGluZUZpZWxkOiBxID0+XG4gICAgICAgIFAuYWx0KFxuICAgICAgICAgICAgcS5kYXRlLFxuICAgICAgICAgICAgcS5kdXJhdGlvbi5tYXAoZCA9PiBub3JtYWxpemVEdXJhdGlvbihkKSksXG4gICAgICAgICAgICBxLnN0cmluZyxcbiAgICAgICAgICAgIHEudGFnLFxuICAgICAgICAgICAgcS5lbWJlZExpbmssXG4gICAgICAgICAgICBxLmJvb2wsXG4gICAgICAgICAgICBxLm51bWJlcixcbiAgICAgICAgICAgIHEucmF3TnVsbFxuICAgICAgICApLFxuICAgIGlubGluZUZpZWxkTGlzdDogcSA9PiBxLmF0b21JbmxpbmVGaWVsZC5zZXBCeShQLnN0cmluZyhcIixcIikudHJpbShQLm9wdFdoaXRlc3BhY2UpLmxvb2thaGVhZChxLmF0b21JbmxpbmVGaWVsZCkpLFxuICAgIGlubGluZUZpZWxkOiBxID0+XG4gICAgICAgIFAuYWx0KFxuICAgICAgICAgICAgUC5zZXFNYXAocS5hdG9tSW5saW5lRmllbGQsIFAuc3RyaW5nKFwiLFwiKS50cmltKFAub3B0V2hpdGVzcGFjZSksIHEuaW5saW5lRmllbGRMaXN0LCAoZiwgX3MsIGwpID0+XG4gICAgICAgICAgICAgICAgW2ZdLmNvbmNhdChsKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHEuYXRvbUlubGluZUZpZWxkXG4gICAgICAgICksXG5cbiAgICBhdG9tRmllbGQ6IHEgPT5cbiAgICAgICAgUC5hbHQoXG4gICAgICAgICAgICAvLyBQbGFjZSBlbWJlZCBsaW5rcyBhYm92ZSBuZWdhdGVkIGZpZWxkcyBhcyB0aGV5IGFyZSB0aGUgc3BlY2lhbCBwYXJzZXIgY2FzZSAnIVtbdGhpbmddXScgYW5kIGFyZSBnZW5lcmFsbHkgdW5hbWJpZ2lvdXMuXG4gICAgICAgICAgICBxLmVtYmVkTGluay5tYXAobCA9PiBGaWVsZHMubGl0ZXJhbChsKSksXG4gICAgICAgICAgICBxLm5lZ2F0ZWRGaWVsZCxcbiAgICAgICAgICAgIHEubGlua0ZpZWxkLFxuICAgICAgICAgICAgcS5saXN0RmllbGQsXG4gICAgICAgICAgICBxLm9iamVjdEZpZWxkLFxuICAgICAgICAgICAgcS5sYW1iZGFGaWVsZCxcbiAgICAgICAgICAgIHEucGFyZW5zRmllbGQsXG4gICAgICAgICAgICBxLmJvb2xGaWVsZCxcbiAgICAgICAgICAgIHEubnVtYmVyRmllbGQsXG4gICAgICAgICAgICBxLnN0cmluZ0ZpZWxkLFxuICAgICAgICAgICAgcS5kYXRlRmllbGQsXG4gICAgICAgICAgICBxLmR1cmF0aW9uRmllbGQsXG4gICAgICAgICAgICBxLm51bGxGaWVsZCxcbiAgICAgICAgICAgIHEudmFyaWFibGVGaWVsZFxuICAgICAgICApLFxuICAgIGluZGV4RmllbGQ6IHEgPT5cbiAgICAgICAgUC5zZXFNYXAocS5hdG9tRmllbGQsIFAuYWx0KHEuZG90UG9zdGZpeCwgcS5pbmRleFBvc3RmaXgsIHEuZnVuY3Rpb25Qb3N0Zml4KS5tYW55KCksIChvYmosIHBvc3RmaXhlcykgPT4ge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG9iajtcbiAgICAgICAgICAgIGZvciAobGV0IHBvc3Qgb2YgcG9zdGZpeGVzKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChwb3N0LnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImRvdFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gRmllbGRzLmluZGV4KHJlc3VsdCwgRmllbGRzLmxpdGVyYWwocG9zdC5maWVsZCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpbmRleFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gRmllbGRzLmluZGV4KHJlc3VsdCwgcG9zdC5maWVsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBGaWVsZHMuZnVuYyhyZXN1bHQsIHBvc3QuZmllbGRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSksXG4gICAgbmVnYXRlZEZpZWxkOiBxID0+IFAuc2VxTWFwKFAuc3RyaW5nKFwiIVwiKSwgcS5pbmRleEZpZWxkLCAoXywgZmllbGQpID0+IEZpZWxkcy5uZWdhdGUoZmllbGQpKS5kZXNjKFwibmVnYXRlZCBmaWVsZFwiKSxcbiAgICBwYXJlbnNGaWVsZDogcSA9PlxuICAgICAgICBQLnNlcU1hcChcbiAgICAgICAgICAgIFAuc3RyaW5nKFwiKFwiKSxcbiAgICAgICAgICAgIFAub3B0V2hpdGVzcGFjZSxcbiAgICAgICAgICAgIHEuZmllbGQsXG4gICAgICAgICAgICBQLm9wdFdoaXRlc3BhY2UsXG4gICAgICAgICAgICBQLnN0cmluZyhcIilcIiksXG4gICAgICAgICAgICAoXzEsIF8yLCBmaWVsZCwgXzMsIF80KSA9PiBmaWVsZFxuICAgICAgICApLFxuICAgIGxhbWJkYUZpZWxkOiBxID0+XG4gICAgICAgIFAuc2VxTWFwKFxuICAgICAgICAgICAgcS5pZGVudGlmaWVyXG4gICAgICAgICAgICAgICAgLnNlcEJ5KFAuc3RyaW5nKFwiLFwiKS50cmltKFAub3B0V2hpdGVzcGFjZSkpXG4gICAgICAgICAgICAgICAgLndyYXAoUC5zdHJpbmcoXCIoXCIpLnRyaW0oUC5vcHRXaGl0ZXNwYWNlKSwgUC5zdHJpbmcoXCIpXCIpLnRyaW0oUC5vcHRXaGl0ZXNwYWNlKSksXG4gICAgICAgICAgICBQLnN0cmluZyhcIj0+XCIpLnRyaW0oUC5vcHRXaGl0ZXNwYWNlKSxcbiAgICAgICAgICAgIHEuZmllbGQsXG4gICAgICAgICAgICAoaWRlbnQsIF9pZ25vcmUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJsYW1iZGFcIiwgYXJndW1lbnRzOiBpZGVudCwgdmFsdWUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKSxcblxuICAgIGRvdFBvc3RmaXg6IHEgPT5cbiAgICAgICAgUC5zZXFNYXAoUC5zdHJpbmcoXCIuXCIpLCBxLmlkZW50aWZpZXIsIChfLCBmaWVsZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJkb3RcIiwgZmllbGQ6IGZpZWxkIH07XG4gICAgICAgIH0pLFxuICAgIGluZGV4UG9zdGZpeDogcSA9PlxuICAgICAgICBQLnNlcU1hcChQLnN0cmluZyhcIltcIiksIFAub3B0V2hpdGVzcGFjZSwgcS5maWVsZCwgUC5vcHRXaGl0ZXNwYWNlLCBQLnN0cmluZyhcIl1cIiksIChfLCBfMiwgZmllbGQsIF8zLCBfNCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJpbmRleFwiLCBmaWVsZCB9O1xuICAgICAgICB9KSxcbiAgICBmdW5jdGlvblBvc3RmaXg6IHEgPT5cbiAgICAgICAgUC5zZXFNYXAoXG4gICAgICAgICAgICBQLnN0cmluZyhcIihcIiksXG4gICAgICAgICAgICBQLm9wdFdoaXRlc3BhY2UsXG4gICAgICAgICAgICBxLmZpZWxkLnNlcEJ5KFAuc3RyaW5nKFwiLFwiKS50cmltKFAub3B0V2hpdGVzcGFjZSkpLFxuICAgICAgICAgICAgUC5vcHRXaGl0ZXNwYWNlLFxuICAgICAgICAgICAgUC5zdHJpbmcoXCIpXCIpLFxuICAgICAgICAgICAgKF8sIF8xLCBmaWVsZHMsIF8yLCBfMykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiZnVuY3Rpb25cIiwgZmllbGRzIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICksXG5cbiAgICAvLyBUaGUgcHJlY2VkZW5jZSBoaWVyYXJjaHkgb2Ygb3BlcmF0b3JzIC0gbXVsdGlwbHkvZGl2aWRlLCBhZGQvc3VidHJhY3QsIGNvbXBhcmUsIGFuZCB0aGVuIGJvb2xlYW4gb3BlcmF0aW9ucy5cbiAgICBiaW5hcnlNdWxEaXZGaWVsZDogcSA9PiBjcmVhdGVCaW5hcnlQYXJzZXIocS5pbmRleEZpZWxkLCBxLmJpbmFyeU11bERpdiwgRmllbGRzLmJpbmFyeU9wKSxcbiAgICBiaW5hcnlQbHVzTWludXNGaWVsZDogcSA9PiBjcmVhdGVCaW5hcnlQYXJzZXIocS5iaW5hcnlNdWxEaXZGaWVsZCwgcS5iaW5hcnlQbHVzTWludXMsIEZpZWxkcy5iaW5hcnlPcCksXG4gICAgYmluYXJ5Q29tcGFyZUZpZWxkOiBxID0+IGNyZWF0ZUJpbmFyeVBhcnNlcihxLmJpbmFyeVBsdXNNaW51c0ZpZWxkLCBxLmJpbmFyeUNvbXBhcmVPcCwgRmllbGRzLmJpbmFyeU9wKSxcbiAgICBiaW5hcnlCb29sZWFuRmllbGQ6IHEgPT4gY3JlYXRlQmluYXJ5UGFyc2VyKHEuYmluYXJ5Q29tcGFyZUZpZWxkLCBxLmJpbmFyeUJvb2xlYW5PcCwgRmllbGRzLmJpbmFyeU9wKSxcbiAgICBiaW5hcnlPcEZpZWxkOiBxID0+IHEuYmluYXJ5Qm9vbGVhbkZpZWxkLFxuXG4gICAgZmllbGQ6IHEgPT4gcS5iaW5hcnlPcEZpZWxkLFxufSk7XG5cbi8qKlxuICogQXR0ZW1wdCB0byBwYXJzZSBhIGZpZWxkIGZyb20gdGhlIGdpdmVuIHRleHQsIHJldHVybmluZyBhIHN0cmluZyBlcnJvciBpZiB0aGVcbiAqIHBhcnNlIGZhaWxlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRmllbGQodGV4dDogc3RyaW5nKTogUmVzdWx0PEZpZWxkLCBzdHJpbmc+IHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gUmVzdWx0LnN1Y2Nlc3MoRVhQUkVTU0lPTi5maWVsZC50cnlQYXJzZSh0ZXh0KSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIFJlc3VsdC5mYWlsdXJlKFwiXCIgKyBlcnJvcik7XG4gICAgfVxufVxuIiwgIi8qKiBQcm92aWRlcyBhbiBBU1QgZm9yIGNvbXBsZXggcXVlcmllcy4gKi9cbmltcG9ydCB7IFNvdXJjZSB9IGZyb20gXCJkYXRhLWluZGV4L3NvdXJjZVwiO1xuaW1wb3J0IHsgRmllbGQgfSBmcm9tIFwiZXhwcmVzc2lvbi9maWVsZFwiO1xuXG4vKiogVGhlIHN1cHBvcnRlZCBxdWVyeSB0eXBlcyAoY29ycmVzcG9uZGluZyB0byB2aWV3IHR5cGVzKS4gKi9cbmV4cG9ydCB0eXBlIFF1ZXJ5VHlwZSA9IFwibGlzdFwiIHwgXCJ0YWJsZVwiIHwgXCJ0YXNrXCIgfCBcImNhbGVuZGFyXCI7XG5cbi8qKiBBIHNpbmdsZS1saW5lIGNvbW1lbnQuICovXG5leHBvcnQgdHlwZSBDb21tZW50ID0gc3RyaW5nO1xuXG4vKiogRmllbGRzIHVzZWQgaW4gdGhlIHF1ZXJ5IHBvcnRpb24uICovXG5leHBvcnQgaW50ZXJmYWNlIE5hbWVkRmllbGQge1xuICAgIC8qKiBUaGUgZWZmZWN0aXZlIG5hbWUgb2YgdGhpcyBmaWVsZC4gKi9cbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgLyoqIFRoZSB2YWx1ZSBvZiB0aGlzIGZpZWxkLiAqL1xuICAgIGZpZWxkOiBGaWVsZDtcbn1cblxuLyoqIEEgcXVlcnkgc29ydCBieSBmaWVsZCwgZm9yIGRldGVybWluaW5nIHNvcnQgb3JkZXIuICovXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXJ5U29ydEJ5IHtcbiAgICAvKiogVGhlIGZpZWxkIHRvIHNvcnQgb24uICovXG4gICAgZmllbGQ6IEZpZWxkO1xuICAgIC8qKiBUaGUgZGlyZWN0aW9uIHRvIHNvcnQgaW4uICovXG4gICAgZGlyZWN0aW9uOiBcImFzY2VuZGluZ1wiIHwgXCJkZXNjZW5kaW5nXCI7XG59XG5cbi8qKiBVdGlsaXR5IGZ1bmN0aW9ucyBmb3IgcXVpY2tseSBjcmVhdGluZyBmaWVsZHMuICovXG5leHBvcnQgbmFtZXNwYWNlIFF1ZXJ5RmllbGRzIHtcbiAgICBleHBvcnQgZnVuY3Rpb24gbmFtZWQobmFtZTogc3RyaW5nLCBmaWVsZDogRmllbGQpOiBOYW1lZEZpZWxkIHtcbiAgICAgICAgcmV0dXJuIHsgbmFtZSwgZmllbGQgfSBhcyBOYW1lZEZpZWxkO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBzb3J0QnkoZmllbGQ6IEZpZWxkLCBkaXI6IFwiYXNjZW5kaW5nXCIgfCBcImRlc2NlbmRpbmdcIik6IFF1ZXJ5U29ydEJ5IHtcbiAgICAgICAgcmV0dXJuIHsgZmllbGQsIGRpcmVjdGlvbjogZGlyIH07XG4gICAgfVxufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBRdWVyeSBEZWZpbml0aW9uIC8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKiBBIHF1ZXJ5IHdoaWNoIHNob3VsZCByZW5kZXIgYSBsaXN0IG9mIGVsZW1lbnRzLiAqL1xuZXhwb3J0IGludGVyZmFjZSBMaXN0UXVlcnkge1xuICAgIHR5cGU6IFwibGlzdFwiO1xuICAgIC8qKiBXaGF0IHNob3VsZCBiZSByZW5kZXJlZCBpbiB0aGUgbGlzdC4gKi9cbiAgICBmb3JtYXQ/OiBGaWVsZDtcbiAgICAvKiogSWYgdHJ1ZSwgc2hvdyB0aGUgZGVmYXVsdCBESSBmaWVsZDsgb3RoZXJ3aXNlLCBkb24ndC4gKi9cbiAgICBzaG93SWQ6IGJvb2xlYW47XG59XG5cbi8qKiBBIHF1ZXJ5IHdoaWNoIHJlbmRlcnMgYSB0YWJsZSBvZiBlbGVtZW50cy4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGFibGVRdWVyeSB7XG4gICAgdHlwZTogXCJ0YWJsZVwiO1xuICAgIC8qKiBUaGUgZmllbGRzIChjb21wdXRlZCBvciBvdGhlcndpc2UpIHRvIHNlbGVjdC4gKi9cbiAgICBmaWVsZHM6IE5hbWVkRmllbGRbXTtcbiAgICAvKiogSWYgdHJ1ZSwgc2hvdyB0aGUgZGVmYXVsdCBJRCBmaWVsZDsgb3RoZXJ3aXNlLCBkb24ndC4gKi9cbiAgICBzaG93SWQ6IGJvb2xlYW47XG59XG5cbi8qKiBBIHF1ZXJ5IHdoaWNoIHJlbmRlcnMgYSBjb2xsZWN0aW9uIG9mIHRhc2tzLiAqL1xuZXhwb3J0IGludGVyZmFjZSBUYXNrUXVlcnkge1xuICAgIHR5cGU6IFwidGFza1wiO1xufVxuXG4vKiogQSBxdWVyeSB3aGljaCByZW5kZXJzIGEgY29sbGVjdGlvbiBvZiBub3RlcyBpbiBhIGNhbGVuZGFyIHZpZXcuICovXG5leHBvcnQgaW50ZXJmYWNlIENhbGVuZGFyUXVlcnkge1xuICAgIHR5cGU6IFwiY2FsZW5kYXJcIjtcbiAgICAvKiogVGhlIGRhdGUgZmllbGQgdGhhdCB3ZSdsbCBiZSBncm91cGluZyBub3RlcyBieSBmb3IgdGhlIGNhbGVuZGFyIHZpZXcgKi9cbiAgICBmaWVsZDogTmFtZWRGaWVsZDtcbn1cblxuZXhwb3J0IHR5cGUgUXVlcnlIZWFkZXIgPSBMaXN0UXVlcnkgfCBUYWJsZVF1ZXJ5IHwgVGFza1F1ZXJ5IHwgQ2FsZW5kYXJRdWVyeTtcblxuLyoqIEEgc3RlcCB3aGljaCBvbmx5IHJldGFpbnMgcm93cyB3aG9zZSAnY2xhdXNlJyBmaWVsZCBpcyB0cnV0aHkuICovXG5leHBvcnQgaW50ZXJmYWNlIFdoZXJlU3RlcCB7XG4gICAgdHlwZTogXCJ3aGVyZVwiO1xuICAgIGNsYXVzZTogRmllbGQ7XG59XG5cbi8qKiBBIHN0ZXAgd2hpY2ggc29ydHMgYWxsIGN1cnJlbnQgcm93cyBieSB0aGUgZ2l2ZW4gbGlzdCBvZiBzb3J0cy4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU29ydEJ5U3RlcCB7XG4gICAgdHlwZTogXCJzb3J0XCI7XG4gICAgZmllbGRzOiBRdWVyeVNvcnRCeVtdO1xufVxuXG4vKiogQSBzdGVwIHdoaWNoIHRydW5jYXRlcyB0aGUgbnVtYmVyIG9mIHJvd3MgdG8gdGhlIGdpdmVuIGFtb3VudC4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTGltaXRTdGVwIHtcbiAgICB0eXBlOiBcImxpbWl0XCI7XG4gICAgYW1vdW50OiBGaWVsZDtcbn1cblxuLyoqIEEgc3RlcCB3aGljaCBmbGF0dGVucyByb3dzIGludG8gbXVsdGlwbGUgY2hpbGQgcm93cy4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRmxhdHRlblN0ZXAge1xuICAgIHR5cGU6IFwiZmxhdHRlblwiO1xuICAgIGZpZWxkOiBOYW1lZEZpZWxkO1xufVxuXG4vKiogQSBzdGVwIHdoaWNoIGdyb3VwcyByb3dzIGludG8gZ3JvdXBzIGJ5IHRoZSBnaXZlbiBmaWVsZC4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgR3JvdXBTdGVwIHtcbiAgICB0eXBlOiBcImdyb3VwXCI7XG4gICAgZmllbGQ6IE5hbWVkRmllbGQ7XG59XG5cbi8qKiBBIHZpcnR1YWwgc3RlcCB3aGljaCBleHRyYWN0cyBhbiBhcnJheSBvZiB2YWx1ZXMgZnJvbSBlYWNoIHJvdy4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRXh0cmFjdFN0ZXAge1xuICAgIHR5cGU6IFwiZXh0cmFjdFwiO1xuICAgIGZpZWxkczogUmVjb3JkPHN0cmluZywgRmllbGQ+O1xufVxuXG5leHBvcnQgdHlwZSBRdWVyeU9wZXJhdGlvbiA9IFdoZXJlU3RlcCB8IFNvcnRCeVN0ZXAgfCBMaW1pdFN0ZXAgfCBGbGF0dGVuU3RlcCB8IEdyb3VwU3RlcCB8IEV4dHJhY3RTdGVwO1xuXG4vKipcbiAqIEEgcXVlcnkgb3ZlciB0aGUgT2JzaWRpYW4gZGF0YWJhc2UuIFF1ZXJpZXMgaGF2ZSBhIHNwZWNpZmljIGFuZCBkZXRlcm1pbmlzdGljIGV4ZWN1dGlvbiBvcmRlcjpcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBRdWVyeSB7XG4gICAgLyoqIFRoZSB2aWV3IHR5cGUgdG8gcmVuZGVyIHRoaXMgcXVlcnkgaW4uICovXG4gICAgaGVhZGVyOiBRdWVyeUhlYWRlcjtcbiAgICAvKiogVGhlIHNvdXJjZSB0aGF0IGZpbGUgY2FuZGlkYXRlcyB3aWxsIGNvbWUgZnJvbS4gKi9cbiAgICBzb3VyY2U6IFNvdXJjZTtcbiAgICAvKiogVGhlIG9wZXJhdGlvbnMgdG8gYXBwbHkgdG8gdGhlIGRhdGEgdG8gcHJvZHVjZSB0aGUgZmluYWwgcmVzdWx0IHRoYXQgd2lsbCBiZSByZW5kZXJlZC4gKi9cbiAgICBvcGVyYXRpb25zOiBRdWVyeU9wZXJhdGlvbltdO1xufVxuIiwgImltcG9ydCB7IEVYUFJFU1NJT04gfSBmcm9tIFwiZXhwcmVzc2lvbi9wYXJzZVwiO1xuaW1wb3J0ICogYXMgUCBmcm9tIFwicGFyc2ltbW9uXCI7XG5pbXBvcnQge1xuICAgIEZsYXR0ZW5TdGVwLFxuICAgIEdyb3VwU3RlcCxcbiAgICBMaW1pdFN0ZXAsXG4gICAgTmFtZWRGaWVsZCxcbiAgICBRdWVyeSxcbiAgICBRdWVyeUZpZWxkcyxcbiAgICBRdWVyeUhlYWRlcixcbiAgICBRdWVyeU9wZXJhdGlvbixcbiAgICBRdWVyeVNvcnRCeSxcbiAgICBRdWVyeVR5cGUsXG4gICAgU29ydEJ5U3RlcCxcbiAgICBXaGVyZVN0ZXAsXG4gICAgQ29tbWVudCxcbn0gZnJvbSBcIi4vcXVlcnlcIjtcbmltcG9ydCB7IFNvdXJjZSwgU291cmNlcyB9IGZyb20gXCJkYXRhLWluZGV4L3NvdXJjZVwiO1xuaW1wb3J0IHsgREVGQVVMVF9RVUVSWV9TRVRUSU5HUyB9IGZyb20gXCJzZXR0aW5nc1wiO1xuaW1wb3J0IHsgUmVzdWx0IH0gZnJvbSBcImFwaS9yZXN1bHRcIjtcblxuLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gUXVlcnkgUGFyc2luZyAvL1xuLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKiogVHlwaW5ncyBmb3IgdGhlIG91dHB1dHMgb2YgYWxsIG9mIHRoZSBwYXJzZXIgY29tYmluYXRvcnMuICovXG5pbnRlcmZhY2UgUXVlcnlMYW5ndWFnZVR5cGVzIHtcbiAgICBxdWVyeVR5cGU6IFF1ZXJ5VHlwZTtcbiAgICBjb21tZW50OiBDb21tZW50O1xuXG4gICAgZXhwbGljaXROYW1lZEZpZWxkOiBOYW1lZEZpZWxkO1xuICAgIG5hbWVkRmllbGQ6IE5hbWVkRmllbGQ7XG4gICAgc29ydEZpZWxkOiBRdWVyeVNvcnRCeTtcblxuICAgIC8vIEVudGlyZSBjbGF1c2VzIGluIHF1ZXJpZXMuXG4gICAgaGVhZGVyQ2xhdXNlOiBRdWVyeUhlYWRlcjtcbiAgICBmcm9tQ2xhdXNlOiBTb3VyY2U7XG4gICAgd2hlcmVDbGF1c2U6IFdoZXJlU3RlcDtcbiAgICBzb3J0QnlDbGF1c2U6IFNvcnRCeVN0ZXA7XG4gICAgbGltaXRDbGF1c2U6IExpbWl0U3RlcDtcbiAgICBmbGF0dGVuQ2xhdXNlOiBGbGF0dGVuU3RlcDtcbiAgICBncm91cEJ5Q2xhdXNlOiBHcm91cFN0ZXA7XG4gICAgY2xhdXNlOiBRdWVyeU9wZXJhdGlvbjtcbiAgICBxdWVyeTogUXVlcnk7XG59XG5cbi8qKiBSZXR1cm4gYSBuZXcgcGFyc2VyIHdoaWNoIGV4ZWN1dGVzIHRoZSB1bmRlcmx5aW5nIHBhcnNlciBhbmQgcmV0dXJucyBpdCdzIHJhdyBzdHJpbmcgcmVwcmVzZW50YXRpb24uICovXG5leHBvcnQgZnVuY3Rpb24gY2FwdHVyZVJhdzxUPihiYXNlOiBQLlBhcnNlcjxUPik6IFAuUGFyc2VyPFtULCBzdHJpbmddPiB7XG4gICAgcmV0dXJuIFAuY3VzdG9tKChzdWNjZXNzLCBmYWlsdXJlKSA9PiB7XG4gICAgICAgIHJldHVybiAoaW5wdXQsIGkpID0+IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSAoYmFzZSBhcyBhbnkpLl8oaW5wdXQsIGkpO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQuc3RhdHVzKSByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcmVzdWx0LCB7IHZhbHVlOiBbcmVzdWx0LnZhbHVlLCBpbnB1dC5zdWJzdHJpbmcoaSwgcmVzdWx0LmluZGV4KV0gfSk7XG4gICAgICAgIH07XG4gICAgfSk7XG59XG5cbi8qKiBTdHJpcCBuZXdsaW5lcyBhbmQgZXhjZXNzIHdoaXRlc3BhY2Ugb3V0IG9mIHRleHQuICovXG5mdW5jdGlvbiBzdHJpcE5ld2xpbmVzKHRleHQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRleHRcbiAgICAgICAgLnNwbGl0KC9bXFxyXFxuXSsvKVxuICAgICAgICAubWFwKHQgPT4gdC50cmltKCkpXG4gICAgICAgIC5qb2luKFwiXCIpO1xufVxuXG4vKiogR2l2ZW4gYHBhcnNlcmAsIHJldHVybiB0aGUgcGFyc2VyIHRoYXQgcmV0dXJucyBgaWZfZW9mKClgIGlmIEVPRiBpcyBmb3VuZCxcbiAqIG90aGVyd2lzZSBgcGFyc2VyYCBwcmVjZWRlZCBieSAobm9uLW9wdGlvbmFsKSB3aGl0ZXNwYWNlICovXG5mdW5jdGlvbiBwcmVjZWRlZEJ5V2hpdGVzcGFjZUlmTm90RW9mPFQ+KGlmX2VvZjogKF86IHVuZGVmaW5lZCkgPT4gVCwgcGFyc2VyOiBQLlBhcnNlcjxUPik6IFAuUGFyc2VyPFQ+IHtcbiAgICByZXR1cm4gUC5lb2YubWFwKGlmX2VvZikub3IoUC53aGl0ZXNwYWNlLnRoZW4ocGFyc2VyKSk7XG59XG5cbi8qKiBBIHBhcnNpbW1vbi1wb3dlcmVkIHBhcnNlci1jb21iaW5hdG9yIGltcGxlbWVudGF0aW9uIG9mIHRoZSBxdWVyeSBsYW5ndWFnZS4gKi9cbmV4cG9ydCBjb25zdCBRVUVSWV9MQU5HVUFHRSA9IFAuY3JlYXRlTGFuZ3VhZ2U8UXVlcnlMYW5ndWFnZVR5cGVzPih7XG4gICAgLy8gU2ltcGxlIGF0b20gcGFyc2luZywgbGlrZSB3b3JkcywgaWRlbnRpZmllcnMsIG51bWJlcnMuXG4gICAgcXVlcnlUeXBlOiBxID0+XG4gICAgICAgIFAuYWx0PHN0cmluZz4oUC5yZWdleHAoL1RBQkxFfExJU1R8VEFTS3xDQUxFTkRBUi9pKSlcbiAgICAgICAgICAgIC5tYXAoc3RyID0+IHN0ci50b0xvd2VyQ2FzZSgpIGFzIFF1ZXJ5VHlwZSlcbiAgICAgICAgICAgIC5kZXNjKFwicXVlcnkgdHlwZSAoJ1RBQkxFJywgJ0xJU1QnLCAnVEFTSycsIG9yICdDQUxFTkRBUicpXCIpLFxuICAgIGV4cGxpY2l0TmFtZWRGaWVsZDogcSA9PlxuICAgICAgICBQLnNlcU1hcChcbiAgICAgICAgICAgIEVYUFJFU1NJT04uZmllbGQuc2tpcChQLndoaXRlc3BhY2UpLFxuICAgICAgICAgICAgUC5yZWdleHAoL0FTL2kpLnNraXAoUC53aGl0ZXNwYWNlKSxcbiAgICAgICAgICAgIEVYUFJFU1NJT04uaWRlbnRpZmllci5vcihFWFBSRVNTSU9OLnN0cmluZyksXG4gICAgICAgICAgICAoZmllbGQsIF9hcywgaWRlbnQpID0+IFF1ZXJ5RmllbGRzLm5hbWVkKGlkZW50LCBmaWVsZClcbiAgICAgICAgKSxcbiAgICBjb21tZW50OiAoKSA9PlxuICAgICAgICBQLlBhcnNlcigoaW5wdXQsIGkpID0+IHtcbiAgICAgICAgICAgIC8vIFBhcnNlIGEgY29tbWVudCwgd2hpY2ggaXMgYSBsaW5lIHN0YXJ0aW5nIHdpdGggLy8uXG4gICAgICAgICAgICBsZXQgbGluZSA9IGlucHV0LnN1YnN0cmluZyhpKTtcbiAgICAgICAgICAgIGlmICghbGluZS5zdGFydHNXaXRoKFwiLy9cIikpIHJldHVybiBQLm1ha2VGYWlsdXJlKGksIFwiTm90IGEgY29tbWVudFwiKTtcbiAgICAgICAgICAgIC8vIFRoZSBjb21tZW50IGVuZHMgYXQgdGhlIGVuZCBvZiB0aGUgbGluZS5cbiAgICAgICAgICAgIGxpbmUgPSBsaW5lLnNwbGl0KFwiXFxuXCIpWzBdO1xuICAgICAgICAgICAgbGV0IGNvbW1lbnQgPSBsaW5lLnN1YnN0cmluZygyKS50cmltKCk7XG4gICAgICAgICAgICByZXR1cm4gUC5tYWtlU3VjY2VzcyhpICsgbGluZS5sZW5ndGgsIGNvbW1lbnQpO1xuICAgICAgICB9KSxcbiAgICBuYW1lZEZpZWxkOiBxID0+XG4gICAgICAgIFAuYWx0PE5hbWVkRmllbGQ+KFxuICAgICAgICAgICAgcS5leHBsaWNpdE5hbWVkRmllbGQsXG4gICAgICAgICAgICBjYXB0dXJlUmF3KEVYUFJFU1NJT04uZmllbGQpLm1hcCgoW3ZhbHVlLCB0ZXh0XSkgPT4gUXVlcnlGaWVsZHMubmFtZWQoc3RyaXBOZXdsaW5lcyh0ZXh0KSwgdmFsdWUpKVxuICAgICAgICApLFxuICAgIHNvcnRGaWVsZDogcSA9PlxuICAgICAgICBQLnNlcU1hcChcbiAgICAgICAgICAgIEVYUFJFU1NJT04uZmllbGQuc2tpcChQLm9wdFdoaXRlc3BhY2UpLFxuICAgICAgICAgICAgUC5yZWdleHAoL0FTQ0VORElOR3xERVNDRU5ESU5HfEFTQ3xERVNDL2kpLmF0TW9zdCgxKSxcbiAgICAgICAgICAgIChmaWVsZCwgZGlyKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGRpcmVjdGlvbiA9IGRpci5sZW5ndGggPT0gMCA/IFwiYXNjZW5kaW5nXCIgOiBkaXJbMF0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09IFwiZGVzY1wiKSBkaXJlY3Rpb24gPSBcImRlc2NlbmRpbmdcIjtcbiAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09IFwiYXNjXCIpIGRpcmVjdGlvbiA9IFwiYXNjZW5kaW5nXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246IGRpcmVjdGlvbiBhcyBcImFzY2VuZGluZ1wiIHwgXCJkZXNjZW5kaW5nXCIsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKSxcblxuICAgIGhlYWRlckNsYXVzZTogcSA9PlxuICAgICAgICBxLnF1ZXJ5VHlwZVxuICAgICAgICAgICAgLmNoYWluKHR5cGUgPT4ge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidGFibGVcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZWNlZGVkQnlXaGl0ZXNwYWNlSWZOb3RFb2YoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCkgPT4gKHsgdHlwZSwgZmllbGRzOiBbXSwgc2hvd0lkOiB0cnVlIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFAuc2VxTWFwKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQLnJlZ2V4cCgvV0lUSE9VVFxccytJRC9pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNraXAoUC5vcHRXaGl0ZXNwYWNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0TW9zdCgxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUC5zZXBCeShxLm5hbWVkRmllbGQsIFAuc3RyaW5nKFwiLFwiKS50cmltKFAub3B0V2hpdGVzcGFjZSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAod2l0aG91dElkLCBmaWVsZHMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGUsIGZpZWxkcywgc2hvd0lkOiB3aXRob3V0SWQubGVuZ3RoID09IDAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImxpc3RcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmVjZWRlZEJ5V2hpdGVzcGFjZUlmTm90RW9mKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgpID0+ICh7IHR5cGUsIGZvcm1hdDogdW5kZWZpbmVkLCBzaG93SWQ6IHRydWUgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUC5zZXFNYXAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFAucmVnZXhwKC9XSVRIT1VUXFxzK0lEL2kpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2tpcChQLm9wdFdoaXRlc3BhY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXRNb3N0KDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFWFBSRVNTSU9OLmZpZWxkLmF0TW9zdCgxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHdpdGhvdXRJZCwgZm9ybWF0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiBmb3JtYXQubGVuZ3RoID09IDEgPyBmb3JtYXRbMF0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvd0lkOiB3aXRob3V0SWQubGVuZ3RoID09IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRhc2tcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQLnN1Y2NlZWQoeyB0eXBlIH0pO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY2FsZW5kYXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQLndoaXRlc3BhY2UudGhlbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQLnNlcU1hcChxLm5hbWVkRmllbGQsIGZpZWxkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG93SWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBhcyBRdWVyeUhlYWRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQLmZhaWwoYFVucmVjb2duaXplZCBxdWVyeSB0eXBlICcke3R5cGV9J2ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZGVzYyhcIlRBQkxFIG9yIExJU1Qgb3IgVEFTSyBvciBDQUxFTkRBUlwiKSxcbiAgICBmcm9tQ2xhdXNlOiBxID0+IFAuc2VxTWFwKFAucmVnZXhwKC9GUk9NL2kpLCBQLndoaXRlc3BhY2UsIEVYUFJFU1NJT04uc291cmNlLCAoXzEsIF8yLCBzb3VyY2UpID0+IHNvdXJjZSksXG4gICAgd2hlcmVDbGF1c2U6IHEgPT5cbiAgICAgICAgUC5zZXFNYXAoUC5yZWdleHAoL1dIRVJFL2kpLCBQLndoaXRlc3BhY2UsIEVYUFJFU1NJT04uZmllbGQsICh3aGVyZSwgXywgZmllbGQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwid2hlcmVcIiwgY2xhdXNlOiBmaWVsZCB9IGFzIFdoZXJlU3RlcDtcbiAgICAgICAgfSkuZGVzYyhcIldIRVJFIDxleHByZXNzaW9uPlwiKSxcbiAgICBzb3J0QnlDbGF1c2U6IHEgPT5cbiAgICAgICAgUC5zZXFNYXAoXG4gICAgICAgICAgICBQLnJlZ2V4cCgvU09SVC9pKSxcbiAgICAgICAgICAgIFAud2hpdGVzcGFjZSxcbiAgICAgICAgICAgIHEuc29ydEZpZWxkLnNlcEJ5MShQLnN0cmluZyhcIixcIikudHJpbShQLm9wdFdoaXRlc3BhY2UpKSxcbiAgICAgICAgICAgIChzb3J0LCBfMSwgZmllbGRzKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJzb3J0XCIsIGZpZWxkcyB9IGFzIFNvcnRCeVN0ZXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICkuZGVzYyhcIlNPUlQgZmllbGQgW0FTQy9ERVNDXVwiKSxcbiAgICBsaW1pdENsYXVzZTogcSA9PlxuICAgICAgICBQLnNlcU1hcChQLnJlZ2V4cCgvTElNSVQvaSksIFAud2hpdGVzcGFjZSwgRVhQUkVTU0lPTi5maWVsZCwgKGxpbWl0LCBfMSwgZmllbGQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwibGltaXRcIiwgYW1vdW50OiBmaWVsZCB9IGFzIExpbWl0U3RlcDtcbiAgICAgICAgfSkuZGVzYyhcIkxJTUlUIDx2YWx1ZT5cIiksXG4gICAgZmxhdHRlbkNsYXVzZTogcSA9PlxuICAgICAgICBQLnNlcU1hcChQLnJlZ2V4cCgvRkxBVFRFTi9pKS5za2lwKFAud2hpdGVzcGFjZSksIHEubmFtZWRGaWVsZCwgKF8sIGZpZWxkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImZsYXR0ZW5cIiwgZmllbGQgfSBhcyBGbGF0dGVuU3RlcDtcbiAgICAgICAgfSkuZGVzYyhcIkZMQVRURU4gPHZhbHVlPiBbQVMgPG5hbWU+XVwiKSxcbiAgICBncm91cEJ5Q2xhdXNlOiBxID0+XG4gICAgICAgIFAuc2VxTWFwKFAucmVnZXhwKC9HUk9VUCBCWS9pKS5za2lwKFAud2hpdGVzcGFjZSksIHEubmFtZWRGaWVsZCwgKF8sIGZpZWxkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImdyb3VwXCIsIGZpZWxkIH0gYXMgR3JvdXBTdGVwO1xuICAgICAgICB9KS5kZXNjKFwiR1JPVVAgQlkgPHZhbHVlPiBbQVMgPG5hbWU+XVwiKSxcbiAgICAvLyBGdWxsIHF1ZXJ5IHBhcnNpbmcuXG4gICAgY2xhdXNlOiBxID0+IFAuYWx0KHEuZnJvbUNsYXVzZSwgcS53aGVyZUNsYXVzZSwgcS5zb3J0QnlDbGF1c2UsIHEubGltaXRDbGF1c2UsIHEuZ3JvdXBCeUNsYXVzZSwgcS5mbGF0dGVuQ2xhdXNlKSxcbiAgICBxdWVyeTogcSA9PlxuICAgICAgICBQLnNlcU1hcChcbiAgICAgICAgICAgIHEuaGVhZGVyQ2xhdXNlLnRyaW0ob3B0aW9uYWxXaGl0ZXNwYWNlT3JDb21tZW50KSxcbiAgICAgICAgICAgIHEuZnJvbUNsYXVzZS50cmltKG9wdGlvbmFsV2hpdGVzcGFjZU9yQ29tbWVudCkuYXRNb3N0KDEpLFxuICAgICAgICAgICAgcS5jbGF1c2UudHJpbShvcHRpb25hbFdoaXRlc3BhY2VPckNvbW1lbnQpLm1hbnkoKSxcbiAgICAgICAgICAgIChoZWFkZXIsIGZyb20sIGNsYXVzZXMpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXIsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogZnJvbS5sZW5ndGggPT0gMCA/IFNvdXJjZXMuZm9sZGVyKFwiXCIpIDogZnJvbVswXSxcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uczogY2xhdXNlcyxcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3M6IERFRkFVTFRfUVVFUllfU0VUVElOR1MsXG4gICAgICAgICAgICAgICAgfSBhcyBRdWVyeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKSxcbn0pO1xuXG4vKipcbiAqIEEgcGFyc2VyIGZvciBvcHRpb25hbCB3aGl0ZXNwYWNlIG9yIGNvbW1lbnRzLiBUaGlzIGlzIHVzZWQgdG8gZXhjbHVkZSB3aGl0ZXNwYWNlIGFuZCBjb21tZW50cyBmcm9tIG90aGVyIHBhcnNlcnMuXG4gKi9cbmNvbnN0IG9wdGlvbmFsV2hpdGVzcGFjZU9yQ29tbWVudDogUC5QYXJzZXI8c3RyaW5nPiA9IFAuYWx0KFAud2hpdGVzcGFjZSwgUVVFUllfTEFOR1VBR0UuY29tbWVudClcbiAgICAubWFueSgpIC8vIFVzZSBtYW55KCkgc2luY2UgdGhlcmUgbWF5IGJlIHplcm8gd2hpdGVzcGFjZXMgb3IgY29tbWVudHMuXG4gICAgLy8gVHJhbnNmb3JtIHRoZSBtYW55IHRvIGEgc2luZ2xlIHJlc3VsdC5cbiAgICAubWFwKGFyciA9PiBhcnIuam9pbihcIlwiKSk7XG5cbi8qKlxuICogQXR0ZW1wdCB0byBwYXJzZSBhIHF1ZXJ5IGZyb20gdGhlIGdpdmVuIHF1ZXJ5IHRleHQsIHJldHVybmluZyBhIHN0cmluZyBlcnJvclxuICogaWYgdGhlIHBhcnNlIGZhaWxlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUXVlcnkodGV4dDogc3RyaW5nKTogUmVzdWx0PFF1ZXJ5LCBzdHJpbmc+IHtcbiAgICB0cnkge1xuICAgICAgICBsZXQgcXVlcnkgPSBRVUVSWV9MQU5HVUFHRS5xdWVyeS50cnlQYXJzZSh0ZXh0KTtcbiAgICAgICAgcmV0dXJuIFJlc3VsdC5zdWNjZXNzKHF1ZXJ5KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gUmVzdWx0LmZhaWx1cmUoXCJcIiArIGVycm9yKTtcbiAgICB9XG59XG4iLCAiLy8gQmFzaWMgQVBJIHR5cGUuXG5leHBvcnQgdHlwZSB7IERhdGF2aWV3QXBpIH0gZnJvbSBcImFwaS9wbHVnaW4tYXBpXCI7XG5cbi8vIENvcmUgRGF0YXZpZXcgdHlwZXMuXG5leHBvcnQgdHlwZSB7IERhdGVUaW1lLCBEdXJhdGlvbiB9IGZyb20gXCJsdXhvblwiO1xuZXhwb3J0IHR5cGUge1xuICAgIExpbmssXG4gICAgRGF0YU9iamVjdCxcbiAgICBMaXRlcmFsVHlwZSxcbiAgICBMaXRlcmFsLFxuICAgIExpdGVyYWxSZXByLFxuICAgIFdyYXBwZWRMaXRlcmFsLFxuICAgIExpdGVyYWxXcmFwcGVyLFxuICAgIFdpZGdldCxcbn0gZnJvbSBcImRhdGEtbW9kZWwvdmFsdWVcIjtcblxuZXhwb3J0IHR5cGUgeyBSZXN1bHQsIFN1Y2Nlc3MsIEZhaWx1cmUgfSBmcm9tIFwiYXBpL3Jlc3VsdFwiO1xuZXhwb3J0IHR5cGUgeyBEYXRhQXJyYXkgfSBmcm9tIFwiYXBpL2RhdGEtYXJyYXlcIjtcblxuLy8gRGF0YXZpZXcgSW5kZXguXG5leHBvcnQgdHlwZSB7IExpc3RJdGVtLCBQYWdlTWV0YWRhdGEgfSBmcm9tIFwiZGF0YS1tb2RlbC9tYXJrZG93blwiO1xuZXhwb3J0IHR5cGUgeyBGdWxsSW5kZXgsIFByZWZpeEluZGV4LCBJbmRleE1hcCB9IGZyb20gXCJkYXRhLWluZGV4L2luZGV4XCI7XG5cbi8vIFNlcmlhbGl6ZWQgdHlwZXMgd2hpY2ggZGVzY3JpYmUgYWxsIG91dHB1dHMgb2Ygc2VyaWFsaXphdGlvbi5cbmV4cG9ydCB0eXBlIHsgU01hcmtkb3duUGFnZSwgU0xpc3RFbnRyeSwgU1Rhc2sgfSBmcm9tIFwiZGF0YS1tb2RlbC9zZXJpYWxpemVkL21hcmtkb3duXCI7XG5cbi8vIFVzZWZ1bCB1dGlsaXRpZXMgZm9yIGRpcmVjdGx5IHVzaW5nIGRhdGF2aWV3IHBhcnNlcnMuXG5leHBvcnQge1xuICAgIERVUkFUSU9OX1RZUEVTLFxuICAgIERBVEVfU0hPUlRIQU5EUyxcbiAgICBLRVlXT1JEUyxcbiAgICBFeHByZXNzaW9uTGFuZ3VhZ2UsXG4gICAgRVhQUkVTU0lPTixcbiAgICBwYXJzZUZpZWxkLFxufSBmcm9tIFwiZXhwcmVzc2lvbi9wYXJzZVwiO1xuZXhwb3J0IHsgUVVFUllfTEFOR1VBR0UgfSBmcm9tIFwicXVlcnkvcGFyc2VcIjtcbmV4cG9ydCB7IFF1ZXJ5IH0gZnJvbSBcInF1ZXJ5L3F1ZXJ5XCI7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBJbXBsZW1lbnRhdGlvbiAvL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuaW1wb3J0IHR5cGUgeyBEYXRhdmlld0FwaSB9IGZyb20gXCJhcGkvcGx1Z2luLWFwaVwiO1xuXG5pbXBvcnQgXCJvYnNpZGlhblwiO1xuaW1wb3J0IHR5cGUgeyBBcHAgfSBmcm9tIFwib2JzaWRpYW5cIjtcblxuLy8gVXRpbGl0eSBmdW5jdGlvbnMuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBEYXRhdmlldyBBUEkgZnJvbSB0aGUgYXBwIGlmIHByb3ZpZGVkOyBpZiBub3QsIGl0IGlzIGluZmVycmVkIGZyb20gdGhlIGdsb2JhbCBBUEkgb2JqZWN0IGluc3RhbGxlZFxuICogb24gdGhlIHdpbmRvdy5cbiAqL1xuZXhwb3J0IGNvbnN0IGdldEFQSSA9IChhcHA/OiBBcHApOiBEYXRhdmlld0FwaSB8IHVuZGVmaW5lZCA9PiB7XG4gICAgaWYgKGFwcCkgcmV0dXJuIGFwcC5wbHVnaW5zLnBsdWdpbnMuZGF0YXZpZXc/LmFwaTtcbiAgICBlbHNlIHJldHVybiB3aW5kb3cuRGF0YXZpZXdBUEk7XG59O1xuXG4vKiogRGV0ZXJtaW5lIGlmIERhdGF2aWV3IGlzIGVuYWJsZWQgaW4gdGhlIGdpdmVuIGFwcGxpY2F0aW9uLiAqL1xuZXhwb3J0IGNvbnN0IGlzUGx1Z2luRW5hYmxlZCA9IChhcHA6IEFwcCkgPT4gYXBwLnBsdWdpbnMuZW5hYmxlZFBsdWdpbnMuaGFzKFwiZGF0YXZpZXdcIik7XG4iLCAiLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoLCAyMDIxICovXG5cbi8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbnZhciBJQ0FMO1xuKGZ1bmN0aW9uKCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpIHtcbiAgICAvLyBDb21tb25KUywgd2hlcmUgZXhwb3J0cyBtYXkgYmUgZGlmZmVyZW50IGVhY2ggdGltZS5cbiAgICBJQ0FMID0gbW9kdWxlLmV4cG9ydHM7XG4gIH0gZWxzZSBpZiAodHlwZW9mIEhUTUxTY3JpcHRFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiAnbm9Nb2R1bGUnIGluIEhUTUxTY3JpcHRFbGVtZW50LnByb3RvdHlwZSkge1xuICAgIC8vIFVudGlsIHdlIHVzZSBFUzYgZXhwb3J0cywgdXNpbmcgPHNjcmlwdCB0eXBlPVwibW9kdWxlXCI+IHdlIGRlZmluZSBJQ0FMIG9uIHRoZSB3aW5kb3cgZ2xvYmFsLlxuICAgIHdpbmRvdy5JQ0FMID0gSUNBTCA9IHt9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBJQ0FMICE9PSAnb2JqZWN0Jykge1xuICAgIElDQUwgPSB7fTtcbiAgfVxufSkoKTtcbi8qIGpzaGludCBpZ25vcmU6ZW5kICovXG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICogUG9ydGlvbnMgQ29weXJpZ2h0IChDKSBQaGlsaXBwIEtld2lzY2gsIDIwMTEtMjAxNSAqL1xuXG4vKipcbiAqIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBiZWZvcmUgaUNhbGVuZGFyIGxpbmUgZm9sZGluZyBzaG91bGQgb2NjdXJcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAZGVmYXVsdCA3NVxuICovXG5JQ0FMLmZvbGRMZW5ndGggPSA3NTtcblxuXG4vKipcbiAqIFRoZSBjaGFyYWN0ZXIocykgdG8gYmUgdXNlZCBmb3IgYSBuZXdsaW5lLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBwcm92aWRlZCBieVxuICogcmZjNTU0NS5cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVmYXVsdCBcIlxcclxcblwiXG4gKi9cbklDQUwubmV3TGluZUNoYXIgPSAnXFxyXFxuJztcblxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbnMgdXNlZCBpbiB2YXJpb3VzIHBsYWNlcyB3aXRoaW4gaWNhbC5qc1xuICogQG5hbWVzcGFjZVxuICovXG5JQ0FMLmhlbHBlcnMgPSB7XG4gIC8qKlxuICAgKiBDb21waWxlcyBhIGxpc3Qgb2YgYWxsIHJlZmVyZW5jZWQgVFpJRHMgaW4gYWxsIHN1YmNvbXBvbmVudHMgYW5kXG4gICAqIHJlbW92ZXMgYW55IGV4dHJhIFZUSU1FWk9ORSBzdWJjb21wb25lbnRzLiBJbiBhZGRpdGlvbiwgaWYgYW55IFRaSURzXG4gICAqIGFyZSByZWZlcmVuY2VkIGJ5IGEgY29tcG9uZW50LCBidXQgYSBWVElNRVpPTkUgZG9lcyBub3QgZXhpc3QsXG4gICAqIGFuIGF0dGVtcHQgd2lsbCBiZSBtYWRlIHRvIGdlbmVyYXRlIGEgVlRJTUVaT05FIHVzaW5nIElDQUwuVGltZXpvbmVTZXJ2aWNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0lDQUwuQ29tcG9uZW50fSB2Y2FsICAgICBUaGUgdG9wLWxldmVsIFZDQUxFTkRBUiBjb21wb25lbnQuXG4gICAqIEByZXR1cm4ge0lDQUwuQ29tcG9uZW50fSAgICAgICAgIFRoZSBJQ0FMLkNvbXBvbmVudCB0aGF0IHdhcyBwYXNzZWQgaW4uXG4gICAqL1xuICB1cGRhdGVUaW1lem9uZXM6IGZ1bmN0aW9uKHZjYWwpIHtcbiAgICB2YXIgYWxsc3VicywgcHJvcGVydGllcywgdnRpbWV6b25lcywgcmVxVHppZCwgaSwgdHppZDtcblxuICAgIGlmICghdmNhbCB8fCB2Y2FsLm5hbWUgIT09IFwidmNhbGVuZGFyXCIpIHtcbiAgICAgIC8vbm90IGEgdG9wLWxldmVsIHZjYWxlbmRhciBjb21wb25lbnRcbiAgICAgIHJldHVybiB2Y2FsO1xuICAgIH1cblxuICAgIC8vU3RvcmUgdnRpbWV6b25lIHN1YmNvbXBvbmVudHMgaW4gYW4gb2JqZWN0IHJlZmVyZW5jZSBieSB0emlkLlxuICAgIC8vU3RvcmUgcHJvcGVydGllcyBmcm9tIGV2ZXJ5dGhpbmcgZWxzZSBpbiBhbm90aGVyIGFycmF5XG4gICAgYWxsc3VicyA9IHZjYWwuZ2V0QWxsU3ViY29tcG9uZW50cygpO1xuICAgIHByb3BlcnRpZXMgPSBbXTtcbiAgICB2dGltZXpvbmVzID0ge307XG4gICAgZm9yIChpID0gMDsgaSA8IGFsbHN1YnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhbGxzdWJzW2ldLm5hbWUgPT09IFwidnRpbWV6b25lXCIpIHtcbiAgICAgICAgdHppZCA9IGFsbHN1YnNbaV0uZ2V0Rmlyc3RQcm9wZXJ0eShcInR6aWRcIikuZ2V0Rmlyc3RWYWx1ZSgpO1xuICAgICAgICB2dGltZXpvbmVzW3R6aWRdID0gYWxsc3Vic1tpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmNvbmNhdChhbGxzdWJzW2ldLmdldEFsbFByb3BlcnRpZXMoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9jcmVhdGUgYW4gb2JqZWN0IHdpdGggb25lIGVudHJ5IGZvciBlYWNoIHJlcXVpcmVkIHR6XG4gICAgcmVxVHppZCA9IHt9O1xuICAgIGZvciAoaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoKHR6aWQgPSBwcm9wZXJ0aWVzW2ldLmdldFBhcmFtZXRlcihcInR6aWRcIikpKSB7XG4gICAgICAgIHJlcVR6aWRbdHppZF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vZGVsZXRlIGFueSB2dGltZXpvbmVzIHRoYXQgYXJlIG5vdCBvbiB0aGUgcmVxVHppZCBsaXN0LlxuICAgIGZvciAoaSBpbiB2dGltZXpvbmVzKSB7XG4gICAgICBpZiAodnRpbWV6b25lcy5oYXNPd25Qcm9wZXJ0eShpKSAmJiAhcmVxVHppZFtpXSkge1xuICAgICAgICB2Y2FsLnJlbW92ZVN1YmNvbXBvbmVudCh2dGltZXpvbmVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL2NyZWF0ZSBhbnkgbWlzc2luZywgYnV0IHJlZ2lzdGVyZWQgdGltZXpvbmVzXG4gICAgZm9yIChpIGluIHJlcVR6aWQpIHtcbiAgICAgIGlmIChcbiAgICAgICAgcmVxVHppZC5oYXNPd25Qcm9wZXJ0eShpKSAmJlxuICAgICAgICAhdnRpbWV6b25lc1tpXSAmJlxuICAgICAgICBJQ0FMLlRpbWV6b25lU2VydmljZS5oYXMoaSlcbiAgICAgICkge1xuICAgICAgICB2Y2FsLmFkZFN1YmNvbXBvbmVudChJQ0FMLlRpbWV6b25lU2VydmljZS5nZXQoaSkuY29tcG9uZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmNhbDtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiB0eXBlIGlzIG9mIHRoZSBudW1iZXIgdHlwZSBhbmQgYWxzbyBOYU4uXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXIgICAgIFRoZSBudW1iZXIgdG8gY2hlY2tcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgVHJ1ZSwgaWYgdGhlIG51bWJlciBpcyBzdHJpY3RseSBOYU5cbiAgICovXG4gIGlzU3RyaWN0bHlOYU46IGZ1bmN0aW9uKG51bWJlcikge1xuICAgIHJldHVybiB0eXBlb2YobnVtYmVyKSA9PT0gJ251bWJlcicgJiYgaXNOYU4obnVtYmVyKTtcbiAgfSxcblxuICAvKipcbiAgICogUGFyc2VzIGEgc3RyaW5nIHZhbHVlIHRoYXQgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gaW50ZWdlciwgd2hlbiB0aGUgdmFsaWQgaXNcbiAgICogbm90IGFuIGludGVnZXIgdGhyb3dzIGEgZGVjb3JhdGlvbiBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyAgICAgUmF3IHN0cmluZyBpbnB1dFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICBQYXJzZWQgaW50ZWdlclxuICAgKi9cbiAgc3RyaWN0UGFyc2VJbnQ6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHZhciByZXN1bHQgPSBwYXJzZUludChzdHJpbmcsIDEwKTtcblxuICAgIGlmIChJQ0FMLmhlbHBlcnMuaXNTdHJpY3RseU5hTihyZXN1bHQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdDb3VsZCBub3QgZXh0cmFjdCBpbnRlZ2VyIGZyb20gXCInICsgc3RyaW5nICsgJ1wiJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIG9yIHJldHVybnMgYSBjbGFzcyBpbnN0YW5jZSBvZiBhIGdpdmVuIHR5cGUgd2l0aCB0aGUgaW5pdGlhbGl6YXRpb25cbiAgICogZGF0YSBpZiB0aGUgZGF0YSBpcyBub3QgYWxyZWFkeSBhbiBpbnN0YW5jZSBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogdmFyIHRpbWUgPSBuZXcgSUNBTC5UaW1lKC4uLik7XG4gICAqIHZhciByZXN1bHQgPSBJQ0FMLmhlbHBlcnMuZm9ybWF0Q2xhc3NUeXBlKHRpbWUsIElDQUwuVGltZSk7XG4gICAqXG4gICAqIChyZXN1bHQgaW5zdGFuY2VvZiBJQ0FMLlRpbWUpXG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogcmVzdWx0ID0gSUNBTC5oZWxwZXJzLmZvcm1hdENsYXNzVHlwZSh7fSwgSUNBTC5UaW1lKTtcbiAgICogKHJlc3VsdCBpc250YW5jZW9mIElDQUwuVGltZSlcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAgICAgICBvYmplY3QgaW5pdGlhbGl6YXRpb24gZGF0YVxuICAgKiBAcGFyYW0ge09iamVjdH0gdHlwZSAgICAgICBvYmplY3QgdHlwZSAobGlrZSBJQ0FMLlRpbWUpXG4gICAqIEByZXR1cm4gez99ICAgICAgICAgICAgICAgIEFuIGluc3RhbmNlIG9mIHRoZSBmb3VuZCB0eXBlLlxuICAgKi9cbiAgZm9ybWF0Q2xhc3NUeXBlOiBmdW5jdGlvbiBmb3JtYXRDbGFzc1R5cGUoZGF0YSwgdHlwZSkge1xuICAgIGlmICh0eXBlb2YoZGF0YSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgdHlwZSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIHJldHVybiBuZXcgdHlwZShkYXRhKTtcbiAgfSxcblxuICAvKipcbiAgICogSWRlbnRpY2FsIHRvIGluZGV4T2YgYnV0IHdpbGwgb25seSBtYXRjaCB2YWx1ZXMgd2hlbiB0aGV5IGFyZSBub3QgcHJlY2VkZWRcbiAgICogYnkgYSBiYWNrc2xhc2ggY2hhcmFjdGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYnVmZmVyICAgICAgICAgU3RyaW5nIHRvIHNlYXJjaFxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2VhcmNoICAgICAgICAgVmFsdWUgdG8gbG9vayBmb3JcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBvcyAgICAgICAgICAgIFN0YXJ0IHBvc2l0aW9uXG4gICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgICBUaGUgcG9zaXRpb24sIG9yIC0xIGlmIG5vdCBmb3VuZFxuICAgKi9cbiAgdW5lc2NhcGVkSW5kZXhPZjogZnVuY3Rpb24oYnVmZmVyLCBzZWFyY2gsIHBvcykge1xuICAgIHdoaWxlICgocG9zID0gYnVmZmVyLmluZGV4T2Yoc2VhcmNoLCBwb3MpKSAhPT0gLTEpIHtcbiAgICAgIGlmIChwb3MgPiAwICYmIGJ1ZmZlcltwb3MgLSAxXSA9PT0gJ1xcXFwnKSB7XG4gICAgICAgIHBvcyArPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGaW5kIHRoZSBpbmRleCBmb3IgaW5zZXJ0aW9uIHVzaW5nIGJpbmFyeSBzZWFyY2guXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgICAgICAgICAgICBUaGUgbGlzdCB0byBzZWFyY2hcbiAgICogQHBhcmFtIHs/fSBzZWVrVmFsICAgICAgICAgICAgIFRoZSB2YWx1ZSB0byBpbnNlcnRcbiAgICogQHBhcmFtIHtmdW5jdGlvbig/LD8pfSBjbXBmdW5jIFRoZSBjb21wYXJpc29uIGZ1bmMsIHRoYXQgY2FuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBhcmUgdHdvIHNlZWtWYWxzXG4gICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgICBUaGUgaW5zZXJ0IHBvc2l0aW9uXG4gICAqL1xuICBiaW5zZWFyY2hJbnNlcnQ6IGZ1bmN0aW9uKGxpc3QsIHNlZWtWYWwsIGNtcGZ1bmMpIHtcbiAgICBpZiAoIWxpc3QubGVuZ3RoKVxuICAgICAgcmV0dXJuIDA7XG5cbiAgICB2YXIgbG93ID0gMCwgaGlnaCA9IGxpc3QubGVuZ3RoIC0gMSxcbiAgICAgICAgbWlkLCBjbXB2YWw7XG5cbiAgICB3aGlsZSAobG93IDw9IGhpZ2gpIHtcbiAgICAgIG1pZCA9IGxvdyArIE1hdGguZmxvb3IoKGhpZ2ggLSBsb3cpIC8gMik7XG4gICAgICBjbXB2YWwgPSBjbXBmdW5jKHNlZWtWYWwsIGxpc3RbbWlkXSk7XG5cbiAgICAgIGlmIChjbXB2YWwgPCAwKVxuICAgICAgICBoaWdoID0gbWlkIC0gMTtcbiAgICAgIGVsc2UgaWYgKGNtcHZhbCA+IDApXG4gICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICBlbHNlXG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChjbXB2YWwgPCAwKVxuICAgICAgcmV0dXJuIG1pZDsgLy8gaW5zZXJ0aW9uIGlzIGRpc3BsYWNpbmcsIHNvIHVzZSBtaWQgb3V0cmlnaHQuXG4gICAgZWxzZSBpZiAoY21wdmFsID4gMClcbiAgICAgIHJldHVybiBtaWQgKyAxO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBtaWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlbmllbmNlIGZ1bmN0aW9uIGZvciBkZWJ1ZyBvdXRwdXRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGR1bXBuOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmdW5jdGlvbigpIHtcbiAgICBpZiAoIUlDQUwuZGVidWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIChjb25zb2xlKSAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2xvZycgaW4gY29uc29sZSkge1xuICAgICAgSUNBTC5oZWxwZXJzLmR1bXBuID0gZnVuY3Rpb24gY29uc29sZUR1bXBuKGlucHV0KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGlucHV0KTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIElDQUwuaGVscGVycy5kdW1wbiA9IGZ1bmN0aW9uIGdlY2tvRHVtcG4oaW5wdXQpIHtcbiAgICAgICAgZHVtcChpbnB1dCArICdcXG4nKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgSUNBTC5oZWxwZXJzLmR1bXBuKGFyZ3VtZW50c1swXSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENsb25lIHRoZSBwYXNzZWQgb2JqZWN0IG9yIHByaW1pdGl2ZS4gQnkgZGVmYXVsdCBhIHNoYWxsb3cgY2xvbmUgd2lsbCBiZVxuICAgKiBleGVjdXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBhU3JjICAgICAgICAgICAgVGhlIHRoaW5nIHRvIGNsb25lXG4gICAqIEBwYXJhbSB7Qm9vbGVhbj19IGFEZWVwICAgIElmIHRydWUsIGEgZGVlcCBjbG9uZSB3aWxsIGJlIHBlcmZvcm1lZFxuICAgKiBAcmV0dXJuIHsqfSAgICAgICAgICAgICAgICBUaGUgY29weSBvZiB0aGUgdGhpbmdcbiAgICovXG4gIGNsb25lOiBmdW5jdGlvbihhU3JjLCBhRGVlcCkge1xuICAgIGlmICghYVNyYyB8fCB0eXBlb2YgYVNyYyAhPSBcIm9iamVjdFwiKSB7XG4gICAgICByZXR1cm4gYVNyYztcbiAgICB9IGVsc2UgaWYgKGFTcmMgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoYVNyYy5nZXRUaW1lKCkpO1xuICAgIH0gZWxzZSBpZiAoXCJjbG9uZVwiIGluIGFTcmMpIHtcbiAgICAgIHJldHVybiBhU3JjLmNsb25lKCk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFTcmMpKSB7XG4gICAgICB2YXIgYXJyID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFTcmMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyLnB1c2goYURlZXAgPyBJQ0FMLmhlbHBlcnMuY2xvbmUoYVNyY1tpXSwgdHJ1ZSkgOiBhU3JjW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gYVNyYykge1xuICAgICAgICAvLyB1c2VzIHByb3RvdHlwZSBtZXRob2QgdG8gYWxsb3cgdXNlIG9mIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYVNyYywgbmFtZSkpIHtcbiAgICAgICAgICBpZiAoYURlZXApIHtcbiAgICAgICAgICAgIG9ialtuYW1lXSA9IElDQUwuaGVscGVycy5jbG9uZShhU3JjW25hbWVdLCB0cnVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2JqW25hbWVdID0gYVNyY1tuYW1lXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBQZXJmb3JtcyBpQ2FsZW5kYXIgbGluZSBmb2xkaW5nLiBBIGxpbmUgZW5kaW5nIGNoYXJhY3RlciBpcyBpbnNlcnRlZCBhbmRcbiAgICogdGhlIG5leHQgbGluZSBiZWdpbnMgd2l0aCBhIHdoaXRlc3BhY2UuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIFNVTU1BUlk6VGhpcyBsaW5lIHdpbGwgYmUgZm9sZFxuICAgKiAgZWQgcmlnaHQgaW4gdGhlIG1pZGRsZSBvZiBhIHdvcmQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhTGluZSAgICAgIFRoZSBsaW5lIHRvIGZvbGRcbiAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICAgVGhlIGZvbGRlZCBsaW5lXG4gICAqL1xuICBmb2xkbGluZTogZnVuY3Rpb24gZm9sZGxpbmUoYUxpbmUpIHtcbiAgICB2YXIgcmVzdWx0ID0gXCJcIjtcbiAgICB2YXIgbGluZSA9IGFMaW5lIHx8IFwiXCIsIHBvcyA9IDAsIGxpbmVfbGVuZ3RoID0gMDtcbiAgICAvL3BvcyBjb3VudHMgcG9zaXRpb24gaW4gbGluZSBmb3IgdGhlIFVURi0xNiBwcmVzZW50YXRpb25cbiAgICAvL2xpbmVfbGVuZ3RoIGNvdW50cyB0aGUgYnl0ZXMgZm9yIHRoZSBVVEYtOCBwcmVzZW50YXRpb25cbiAgICB3aGlsZSAobGluZS5sZW5ndGgpIHtcbiAgICAgIHZhciBjcCA9IGxpbmUuY29kZVBvaW50QXQocG9zKTtcbiAgICAgIGlmIChjcCA8IDEyOCkgKytsaW5lX2xlbmd0aDtcbiAgICAgIGVsc2UgaWYgKGNwIDwgMjA0OCkgbGluZV9sZW5ndGggKz0gMjsvL25lZWRzIDIgVVRGLTggYnl0ZXNcbiAgICAgIGVsc2UgaWYgKGNwIDwgNjU1MzYpIGxpbmVfbGVuZ3RoICs9IDM7XG4gICAgICBlbHNlIGxpbmVfbGVuZ3RoICs9IDQ7IC8vY3AgaXMgbGVzcyB0aGFuIDExMTQxMTJcbiAgICAgIGlmIChsaW5lX2xlbmd0aCA8IElDQUwuZm9sZExlbmd0aCArIDEpXG4gICAgICAgIHBvcyArPSBjcCA+IDY1NTM1ID8gMiA6IDE7XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ICs9IElDQUwubmV3TGluZUNoYXIgKyBcIiBcIiArIGxpbmUuc3Vic3RyaW5nKDAsIHBvcyk7XG4gICAgICAgIGxpbmUgPSBsaW5lLnN1YnN0cmluZyhwb3MpO1xuICAgICAgICBwb3MgPSBsaW5lX2xlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuc3Vic3RyKElDQUwubmV3TGluZUNoYXIubGVuZ3RoICsgMSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFBhZHMgdGhlIGdpdmVuIHN0cmluZyBvciBudW1iZXIgd2l0aCB6ZXJvcyBzbyBpdCB3aWxsIGhhdmUgYXQgbGVhc3QgdHdvXG4gICAqIGNoYXJhY3RlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gZGF0YSAgICBUaGUgc3RyaW5nIG9yIG51bWJlciB0byBwYWRcbiAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICAgICAgIFRoZSBudW1iZXIgcGFkZGVkIGFzIGEgc3RyaW5nXG4gICAqL1xuICBwYWQyOiBmdW5jdGlvbiBwYWQoZGF0YSkge1xuICAgIGlmICh0eXBlb2YoZGF0YSkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBoYW5kbGUgZnJhY3Rpb25zLlxuICAgICAgaWYgKHR5cGVvZihkYXRhKSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgZGF0YSA9IHBhcnNlSW50KGRhdGEpO1xuICAgICAgfVxuICAgICAgZGF0YSA9IFN0cmluZyhkYXRhKTtcbiAgICB9XG5cbiAgICB2YXIgbGVuID0gZGF0YS5sZW5ndGg7XG5cbiAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gJzAwJztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuICcwJyArIGRhdGE7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRydW5jYXRlcyB0aGUgZ2l2ZW4gbnVtYmVyLCBjb3JyZWN0bHkgaGFuZGxpbmcgbmVnYXRpdmUgbnVtYmVycy5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG51bWJlciAgICAgVGhlIG51bWJlciB0byB0cnVuY2F0ZVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICBUaGUgdHJ1bmNhdGVkIG51bWJlclxuICAgKi9cbiAgdHJ1bmM6IGZ1bmN0aW9uIHRydW5jKG51bWJlcikge1xuICAgIHJldHVybiAobnVtYmVyIDwgMCA/IE1hdGguY2VpbChudW1iZXIpIDogTWF0aC5mbG9vcihudW1iZXIpKTtcbiAgfSxcblxuICAvKipcbiAgICogUG9vci1tYW4ncyBjcm9zcy1icm93c2VyIGluaGVyaXRhbmNlIGZvciBKYXZhU2NyaXB0LiBEb2Vzbid0IHN1cHBvcnQgYWxsXG4gICAqIHRoZSBmZWF0dXJlcywgYnV0IGVub3VnaCBmb3Igb3VyIHVzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBiYXNlICAgICBUaGUgYmFzZSBjbGFzcyBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2hpbGQgICAgVGhlIGNoaWxkIGNsYXNzIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZXh0cmEgICAgICBFeHRlbmRzIHRoZSBwcm90b3R5cGUgd2l0aCBleHRyYSBwcm9wZXJ0aWVzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIG1ldGhvZHNcbiAgICovXG4gIGluaGVyaXRzOiBmdW5jdGlvbihiYXNlLCBjaGlsZCwgZXh0cmEpIHtcbiAgICBmdW5jdGlvbiBGKCkge31cbiAgICBGLnByb3RvdHlwZSA9IGJhc2UucHJvdG90eXBlO1xuICAgIGNoaWxkLnByb3RvdHlwZSA9IG5ldyBGKCk7XG5cbiAgICBpZiAoZXh0cmEpIHtcbiAgICAgIElDQUwuaGVscGVycy5leHRlbmQoZXh0cmEsIGNoaWxkLnByb3RvdHlwZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBQb29yLW1hbidzIGNyb3NzLWJyb3dzZXIgb2JqZWN0IGV4dGVuc2lvbi4gRG9lc24ndCBzdXBwb3J0IGFsbCB0aGVcbiAgICogZmVhdHVyZXMsIGJ1dCBlbm91Z2ggZm9yIG91ciB1c2FnZS4gTm90ZSB0aGF0IHRoZSB0YXJnZXQncyBwcm9wZXJ0aWVzIGFyZVxuICAgKiBub3Qgb3ZlcndyaXR0ZW4gd2l0aCB0aGUgc291cmNlIHByb3BlcnRpZXMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBjaGlsZCA9IElDQUwuaGVscGVycy5leHRlbmQocGFyZW50LCB7XG4gICAqICAgXCJiYXJcIjogMTIzXG4gICAqIH0pO1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlICAgICBUaGUgb2JqZWN0IHRvIGV4dGVuZFxuICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0ICAgICBUaGUgb2JqZWN0IHRvIGV4dGVuZCB3aXRoXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgIFJldHVybnMgdGhlIHRhcmdldC5cbiAgICovXG4gIGV4dGVuZDogZnVuY3Rpb24oc291cmNlLCB0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICB2YXIgZGVzY3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KTtcbiAgICAgIGlmIChkZXNjciAmJiAhT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbn07XG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICogUG9ydGlvbnMgQ29weXJpZ2h0IChDKSBQaGlsaXBwIEtld2lzY2gsIDIwMTEtMjAxNSAqL1xuXG4vKiogQG5hbWVzcGFjZSBJQ0FMICovXG5cblxuLyoqXG4gKiBUaGlzIHN5bWJvbCBpcyBmdXJ0aGVyIGRlc2NyaWJlZCBsYXRlciBvblxuICogQGlnbm9yZVxuICovXG5JQ0FMLmRlc2lnbiA9IChmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBGUk9NX0lDQUxfTkVXTElORSA9IC9cXFxcXFxcXHxcXFxcO3xcXFxcLHxcXFxcW05uXS9nO1xuICB2YXIgVE9fSUNBTF9ORVdMSU5FID0gL1xcXFx8O3wsfFxcbi9nO1xuICB2YXIgRlJPTV9WQ0FSRF9ORVdMSU5FID0gL1xcXFxcXFxcfFxcXFwsfFxcXFxbTm5dL2c7XG4gIHZhciBUT19WQ0FSRF9ORVdMSU5FID0gL1xcXFx8LHxcXG4vZztcblxuICBmdW5jdGlvbiBjcmVhdGVUZXh0VHlwZShmcm9tTmV3bGluZSwgdG9OZXdsaW5lKSB7XG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIG1hdGNoZXM6IC8uKi8sXG5cbiAgICAgIGZyb21JQ0FMOiBmdW5jdGlvbihhVmFsdWUsIHN0cnVjdHVyZWRFc2NhcGUpIHtcbiAgICAgICAgcmV0dXJuIHJlcGxhY2VOZXdsaW5lKGFWYWx1ZSwgZnJvbU5ld2xpbmUsIHN0cnVjdHVyZWRFc2NhcGUpO1xuICAgICAgfSxcblxuICAgICAgdG9JQ0FMOiBmdW5jdGlvbihhVmFsdWUsIHN0cnVjdHVyZWRFc2NhcGUpIHtcbiAgICAgICAgdmFyIHJlZ0V4ID0gdG9OZXdsaW5lO1xuICAgICAgICBpZiAoc3RydWN0dXJlZEVzY2FwZSlcbiAgICAgICAgICByZWdFeCA9IG5ldyBSZWdFeHAocmVnRXguc291cmNlICsgJ3wnICsgc3RydWN0dXJlZEVzY2FwZSk7XG4gICAgICAgIHJldHVybiBhVmFsdWUucmVwbGFjZShyZWdFeCwgZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgc3dpdGNoIChzdHIpIHtcbiAgICAgICAgICBjYXNlIFwiXFxcXFwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiXFxcXFxcXFxcIjtcbiAgICAgICAgICBjYXNlIFwiO1wiOlxuICAgICAgICAgICAgcmV0dXJuIFwiXFxcXDtcIjtcbiAgICAgICAgICBjYXNlIFwiLFwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiXFxcXCxcIjtcbiAgICAgICAgICBjYXNlIFwiXFxuXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJcXFxcblwiO1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBkZWZhdWx0IHR5cGVzIHVzZWQgbXVsdGlwbGUgdGltZXNcbiAgdmFyIERFRkFVTFRfVFlQRV9URVhUID0geyBkZWZhdWx0VHlwZTogXCJ0ZXh0XCIgfTtcbiAgdmFyIERFRkFVTFRfVFlQRV9URVhUX01VTFRJID0geyBkZWZhdWx0VHlwZTogXCJ0ZXh0XCIsIG11bHRpVmFsdWU6IFwiLFwiIH07XG4gIHZhciBERUZBVUxUX1RZUEVfVEVYVF9TVFJVQ1RVUkVEID0geyBkZWZhdWx0VHlwZTogXCJ0ZXh0XCIsIHN0cnVjdHVyZWRWYWx1ZTogXCI7XCIgfTtcbiAgdmFyIERFRkFVTFRfVFlQRV9JTlRFR0VSID0geyBkZWZhdWx0VHlwZTogXCJpbnRlZ2VyXCIgfTtcbiAgdmFyIERFRkFVTFRfVFlQRV9EQVRFVElNRV9EQVRFID0geyBkZWZhdWx0VHlwZTogXCJkYXRlLXRpbWVcIiwgYWxsb3dlZFR5cGVzOiBbXCJkYXRlLXRpbWVcIiwgXCJkYXRlXCJdIH07XG4gIHZhciBERUZBVUxUX1RZUEVfREFURVRJTUUgPSB7IGRlZmF1bHRUeXBlOiBcImRhdGUtdGltZVwiIH07XG4gIHZhciBERUZBVUxUX1RZUEVfVVJJID0geyBkZWZhdWx0VHlwZTogXCJ1cmlcIiB9O1xuICB2YXIgREVGQVVMVF9UWVBFX1VUQ09GRlNFVCA9IHsgZGVmYXVsdFR5cGU6IFwidXRjLW9mZnNldFwiIH07XG4gIHZhciBERUZBVUxUX1RZUEVfUkVDVVIgPSB7IGRlZmF1bHRUeXBlOiBcInJlY3VyXCIgfTtcbiAgdmFyIERFRkFVTFRfVFlQRV9EQVRFX0FORE9SX1RJTUUgPSB7IGRlZmF1bHRUeXBlOiBcImRhdGUtYW5kLW9yLXRpbWVcIiwgYWxsb3dlZFR5cGVzOiBbXCJkYXRlLXRpbWVcIiwgXCJkYXRlXCIsIFwidGV4dFwiXSB9O1xuXG4gIGZ1bmN0aW9uIHJlcGxhY2VOZXdsaW5lUmVwbGFjZShzdHJpbmcpIHtcbiAgICBzd2l0Y2ggKHN0cmluZykge1xuICAgICAgY2FzZSBcIlxcXFxcXFxcXCI6XG4gICAgICAgIHJldHVybiBcIlxcXFxcIjtcbiAgICAgIGNhc2UgXCJcXFxcO1wiOlxuICAgICAgICByZXR1cm4gXCI7XCI7XG4gICAgICBjYXNlIFwiXFxcXCxcIjpcbiAgICAgICAgcmV0dXJuIFwiLFwiO1xuICAgICAgY2FzZSBcIlxcXFxuXCI6XG4gICAgICBjYXNlIFwiXFxcXE5cIjpcbiAgICAgICAgcmV0dXJuIFwiXFxuXCI7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXBsYWNlTmV3bGluZSh2YWx1ZSwgbmV3bGluZSwgc3RydWN0dXJlZEVzY2FwZSkge1xuICAgIC8vIGF2b2lkIHJlZ2V4IHdoZW4gcG9zc2libGUuXG4gICAgaWYgKHZhbHVlLmluZGV4T2YoJ1xcXFwnKSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHN0cnVjdHVyZWRFc2NhcGUpXG4gICAgICBuZXdsaW5lID0gbmV3IFJlZ0V4cChuZXdsaW5lLnNvdXJjZSArICd8XFxcXFxcXFwnICsgc3RydWN0dXJlZEVzY2FwZSk7XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UobmV3bGluZSwgcmVwbGFjZU5ld2xpbmVSZXBsYWNlKTtcbiAgfVxuXG4gIHZhciBjb21tb25Qcm9wZXJ0aWVzID0ge1xuICAgIFwiY2F0ZWdvcmllc1wiOiBERUZBVUxUX1RZUEVfVEVYVF9NVUxUSSxcbiAgICBcInVybFwiOiBERUZBVUxUX1RZUEVfVVJJLFxuICAgIFwidmVyc2lvblwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBcInVpZFwiOiBERUZBVUxUX1RZUEVfVEVYVFxuICB9O1xuXG4gIHZhciBjb21tb25WYWx1ZXMgPSB7XG4gICAgXCJib29sZWFuXCI6IHtcbiAgICAgIHZhbHVlczogW1wiVFJVRVwiLCBcIkZBTFNFXCJdLFxuXG4gICAgICBmcm9tSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHN3aXRjaCAoYVZhbHVlKSB7XG4gICAgICAgICAgY2FzZSAnVFJVRSc6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICBjYXNlICdGQUxTRSc6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vVE9ETzogcGFyc2VyIHdhcm5pbmdcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgdG9JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgaWYgKGFWYWx1ZSkge1xuICAgICAgICAgIHJldHVybiAnVFJVRSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdGQUxTRSc7XG4gICAgICB9XG5cbiAgICB9LFxuICAgIGZsb2F0OiB7XG4gICAgICBtYXRjaGVzOiAvXlsrLV0/XFxkK1xcLlxcZCskLyxcblxuICAgICAgZnJvbUlDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICB2YXIgcGFyc2VkID0gcGFyc2VGbG9hdChhVmFsdWUpO1xuICAgICAgICBpZiAoSUNBTC5oZWxwZXJzLmlzU3RyaWN0bHlOYU4ocGFyc2VkKSkge1xuICAgICAgICAgIC8vIFRPRE86IHBhcnNlciB3YXJuaW5nXG4gICAgICAgICAgcmV0dXJuIDAuMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgfSxcblxuICAgICAgdG9JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhhVmFsdWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgaW50ZWdlcjoge1xuICAgICAgZnJvbUlDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoYVZhbHVlKTtcbiAgICAgICAgaWYgKElDQUwuaGVscGVycy5pc1N0cmljdGx5TmFOKHBhcnNlZCkpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgfSxcblxuICAgICAgdG9JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhhVmFsdWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgXCJ1dGMtb2Zmc2V0XCI6IHtcbiAgICAgIHRvSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIGlmIChhVmFsdWUubGVuZ3RoIDwgNykge1xuICAgICAgICAgIC8vIG5vIHNlY29uZHNcbiAgICAgICAgICAvLyAtMDUwMFxuICAgICAgICAgIHJldHVybiBhVmFsdWUuc3Vic3RyKDAsIDMpICtcbiAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cig0LCAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBzZWNvbmRzXG4gICAgICAgICAgLy8gLTA1MDAwMFxuICAgICAgICAgIHJldHVybiBhVmFsdWUuc3Vic3RyKDAsIDMpICtcbiAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cig0LCAyKSArXG4gICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoNywgMik7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGZyb21JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgaWYgKGFWYWx1ZS5sZW5ndGggPCA2KSB7XG4gICAgICAgICAgLy8gbm8gc2Vjb25kc1xuICAgICAgICAgIC8vIC0wNTowMFxuICAgICAgICAgIHJldHVybiBhVmFsdWUuc3Vic3RyKDAsIDMpICsgJzonICtcbiAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cigzLCAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBzZWNvbmRzXG4gICAgICAgICAgLy8gLTA1OjAwOjAwXG4gICAgICAgICAgcmV0dXJuIGFWYWx1ZS5zdWJzdHIoMCwgMykgKyAnOicgK1xuICAgICAgICAgICAgICAgICBhVmFsdWUuc3Vic3RyKDMsIDIpICsgJzonICtcbiAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cig1LCAyKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gSUNBTC5VdGNPZmZzZXQuZnJvbVN0cmluZyhhVmFsdWUpO1xuICAgICAgfSxcblxuICAgICAgdW5kZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhVmFsdWUudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIGljYWxQYXJhbXMgPSB7XG4gICAgLy8gQWx0aG91Z2ggdGhlIHN5bnRheCBpcyBEUVVPVEUgdXJpIERRVU9URSwgSSBkb24ndCB0aGluayB3ZSBzaG91bGRcbiAgICAvLyBlbmZvY2UgYW55dGhpbmcgYXNpZGUgZnJvbSBpdCBiZWluZyBhIHZhbGlkIGNvbnRlbnQgbGluZS5cbiAgICAvL1xuICAgIC8vIEF0IGxlYXN0IHNvbWUgcGFyYW1zIHJlcXVpcmUgLSBpZiBtdWx0aSB2YWx1ZXMgYXJlIHVzZWQgLSBEUVVPVEVzXG4gICAgLy8gZm9yIGVhY2ggb2YgaXRzIHZhbHVlcyAtIGUuZy4gZGVsZWdhdGVkLWZyb209XCJ1cmkxXCIsXCJ1cmkyXCJcbiAgICAvLyBUbyBpbmRpY2F0ZSB0aGlzLCBJIGludHJvZHVjZWQgdGhlIG5ldyBrL3YgcGFpclxuICAgIC8vIG11bHRpVmFsdWVTZXBhcmF0ZURRdW90ZTogdHJ1ZVxuICAgIC8vXG4gICAgLy8gXCJBTFRSRVBcIjogeyAuLi4gfSxcblxuICAgIC8vIENOIGp1c3Qgd2FudHMgYSBwYXJhbS12YWx1ZVxuICAgIC8vIFwiQ05cIjogeyAuLi4gfVxuXG4gICAgXCJjdXR5cGVcIjoge1xuICAgICAgdmFsdWVzOiBbXCJJTkRJVklEVUFMXCIsIFwiR1JPVVBcIiwgXCJSRVNPVVJDRVwiLCBcIlJPT01cIiwgXCJVTktOT1dOXCJdLFxuICAgICAgYWxsb3dYTmFtZTogdHJ1ZSxcbiAgICAgIGFsbG93SWFuYVRva2VuOiB0cnVlXG4gICAgfSxcblxuICAgIFwiZGVsZWdhdGVkLWZyb21cIjoge1xuICAgICAgdmFsdWVUeXBlOiBcImNhbC1hZGRyZXNzXCIsXG4gICAgICBtdWx0aVZhbHVlOiBcIixcIixcbiAgICAgIG11bHRpVmFsdWVTZXBhcmF0ZURRdW90ZTogdHJ1ZVxuICAgIH0sXG4gICAgXCJkZWxlZ2F0ZWQtdG9cIjoge1xuICAgICAgdmFsdWVUeXBlOiBcImNhbC1hZGRyZXNzXCIsXG4gICAgICBtdWx0aVZhbHVlOiBcIixcIixcbiAgICAgIG11bHRpVmFsdWVTZXBhcmF0ZURRdW90ZTogdHJ1ZVxuICAgIH0sXG4gICAgLy8gXCJESVJcIjogeyAuLi4gfSwgLy8gU2VlIEFMVFJFUFxuICAgIFwiZW5jb2RpbmdcIjoge1xuICAgICAgdmFsdWVzOiBbXCI4QklUXCIsIFwiQkFTRTY0XCJdXG4gICAgfSxcbiAgICAvLyBcIkZNVFRZUEVcIjogeyAuLi4gfSwgLy8gU2VlIEFMVFJFUFxuICAgIFwiZmJ0eXBlXCI6IHtcbiAgICAgIHZhbHVlczogW1wiRlJFRVwiLCBcIkJVU1lcIiwgXCJCVVNZLVVOQVZBSUxBQkxFXCIsIFwiQlVTWS1URU5UQVRJVkVcIl0sXG4gICAgICBhbGxvd1hOYW1lOiB0cnVlLFxuICAgICAgYWxsb3dJYW5hVG9rZW46IHRydWVcbiAgICB9LFxuICAgIC8vIFwiTEFOR1VBR0VcIjogeyAuLi4gfSwgLy8gU2VlIEFMVFJFUFxuICAgIFwibWVtYmVyXCI6IHtcbiAgICAgIHZhbHVlVHlwZTogXCJjYWwtYWRkcmVzc1wiLFxuICAgICAgbXVsdGlWYWx1ZTogXCIsXCIsXG4gICAgICBtdWx0aVZhbHVlU2VwYXJhdGVEUXVvdGU6IHRydWVcbiAgICB9LFxuICAgIFwicGFydHN0YXRcIjoge1xuICAgICAgLy8gVE9ETyBUaGVzZSB2YWx1ZXMgYXJlIGFjdHVhbGx5IGRpZmZlcmVudCBwZXItY29tcG9uZW50XG4gICAgICB2YWx1ZXM6IFtcIk5FRURTLUFDVElPTlwiLCBcIkFDQ0VQVEVEXCIsIFwiREVDTElORURcIiwgXCJURU5UQVRJVkVcIixcbiAgICAgICAgICAgICAgIFwiREVMRUdBVEVEXCIsIFwiQ09NUExFVEVEXCIsIFwiSU4tUFJPQ0VTU1wiXSxcbiAgICAgIGFsbG93WE5hbWU6IHRydWUsXG4gICAgICBhbGxvd0lhbmFUb2tlbjogdHJ1ZVxuICAgIH0sXG4gICAgXCJyYW5nZVwiOiB7XG4gICAgICB2YWx1ZXM6IFtcIlRISVNBTkRGVVRVUkVcIl1cbiAgICB9LFxuICAgIFwicmVsYXRlZFwiOiB7XG4gICAgICB2YWx1ZXM6IFtcIlNUQVJUXCIsIFwiRU5EXCJdXG4gICAgfSxcbiAgICBcInJlbHR5cGVcIjoge1xuICAgICAgdmFsdWVzOiBbXCJQQVJFTlRcIiwgXCJDSElMRFwiLCBcIlNJQkxJTkdcIl0sXG4gICAgICBhbGxvd1hOYW1lOiB0cnVlLFxuICAgICAgYWxsb3dJYW5hVG9rZW46IHRydWVcbiAgICB9LFxuICAgIFwicm9sZVwiOiB7XG4gICAgICB2YWx1ZXM6IFtcIlJFUS1QQVJUSUNJUEFOVFwiLCBcIkNIQUlSXCIsXG4gICAgICAgICAgICAgICBcIk9QVC1QQVJUSUNJUEFOVFwiLCBcIk5PTi1QQVJUSUNJUEFOVFwiXSxcbiAgICAgIGFsbG93WE5hbWU6IHRydWUsXG4gICAgICBhbGxvd0lhbmFUb2tlbjogdHJ1ZVxuICAgIH0sXG4gICAgXCJyc3ZwXCI6IHtcbiAgICAgIHZhbHVlczogW1wiVFJVRVwiLCBcIkZBTFNFXCJdXG4gICAgfSxcbiAgICBcInNlbnQtYnlcIjoge1xuICAgICAgdmFsdWVUeXBlOiBcImNhbC1hZGRyZXNzXCJcbiAgICB9LFxuICAgIFwidHppZFwiOiB7XG4gICAgICBtYXRjaGVzOiAvXlxcLy9cbiAgICB9LFxuICAgIFwidmFsdWVcIjoge1xuICAgICAgLy8gc2luY2UgdGhlIHZhbHVlIGhlcmUgaXMgYSAndHlwZScgbG93ZXJjYXNlIGlzIHVzZWQuXG4gICAgICB2YWx1ZXM6IFtcImJpbmFyeVwiLCBcImJvb2xlYW5cIiwgXCJjYWwtYWRkcmVzc1wiLCBcImRhdGVcIiwgXCJkYXRlLXRpbWVcIixcbiAgICAgICAgICAgICAgIFwiZHVyYXRpb25cIiwgXCJmbG9hdFwiLCBcImludGVnZXJcIiwgXCJwZXJpb2RcIiwgXCJyZWN1clwiLCBcInRleHRcIixcbiAgICAgICAgICAgICAgIFwidGltZVwiLCBcInVyaVwiLCBcInV0Yy1vZmZzZXRcIl0sXG4gICAgICBhbGxvd1hOYW1lOiB0cnVlLFxuICAgICAgYWxsb3dJYW5hVG9rZW46IHRydWVcbiAgICB9XG4gIH07XG5cbiAgLy8gV2hlbiBhZGRpbmcgYSB2YWx1ZSBoZXJlLCBiZSBzdXJlIHRvIGFkZCBpdCB0byB0aGUgcGFyYW1ldGVyIHR5cGVzIVxuICB2YXIgaWNhbFZhbHVlcyA9IElDQUwuaGVscGVycy5leHRlbmQoY29tbW9uVmFsdWVzLCB7XG4gICAgdGV4dDogY3JlYXRlVGV4dFR5cGUoRlJPTV9JQ0FMX05FV0xJTkUsIFRPX0lDQUxfTkVXTElORSksXG5cbiAgICB1cmk6IHtcbiAgICAgIC8vIFRPRE9cbiAgICAgIC8qIC4uLiAqL1xuICAgIH0sXG5cbiAgICBcImJpbmFyeVwiOiB7XG4gICAgICBkZWNvcmF0ZTogZnVuY3Rpb24oYVN0cmluZykge1xuICAgICAgICByZXR1cm4gSUNBTC5CaW5hcnkuZnJvbVN0cmluZyhhU3RyaW5nKTtcbiAgICAgIH0sXG5cbiAgICAgIHVuZGVjb3JhdGU6IGZ1bmN0aW9uKGFCaW5hcnkpIHtcbiAgICAgICAgcmV0dXJuIGFCaW5hcnkudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiY2FsLWFkZHJlc3NcIjoge1xuICAgICAgLy8gbmVlZHMgdG8gYmUgYW4gdXJpXG4gICAgfSxcbiAgICBcImRhdGVcIjoge1xuICAgICAgZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSwgYVByb3ApIHtcbiAgICAgICAgaWYgKGRlc2lnbi5zdHJpY3QpIHtcbiAgICAgICAgICByZXR1cm4gSUNBTC5UaW1lLmZyb21EYXRlU3RyaW5nKGFWYWx1ZSwgYVByb3ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBJQ0FMLlRpbWUuZnJvbVN0cmluZyhhVmFsdWUsIGFQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiB1bmRlY29yYXRlcyBhIHRpbWUgb2JqZWN0LlxuICAgICAgICovXG4gICAgICB1bmRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFWYWx1ZS50b1N0cmluZygpO1xuICAgICAgfSxcblxuICAgICAgZnJvbUlDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICAvLyBmcm9tOiAyMDEyMDkwMVxuICAgICAgICAvLyB0bzogMjAxMi0wOS0wMVxuICAgICAgICBpZiAoIWRlc2lnbi5zdHJpY3QgJiYgYVZhbHVlLmxlbmd0aCA+PSAxNSkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgcHJvYmFibHkgYSBkYXRlLXRpbWUsIGUuZy4gMjAxMjA5MDFUMTMwMDAwWlxuICAgICAgICAgIHJldHVybiBpY2FsVmFsdWVzW1wiZGF0ZS10aW1lXCJdLmZyb21JQ0FMKGFWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGFWYWx1ZS5zdWJzdHIoMCwgNCkgKyAnLScgK1xuICAgICAgICAgICAgICAgICBhVmFsdWUuc3Vic3RyKDQsIDIpICsgJy0nICtcbiAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cig2LCAyKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgdG9JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgLy8gZnJvbTogMjAxMi0wOS0wMVxuICAgICAgICAvLyB0bzogMjAxMjA5MDFcbiAgICAgICAgdmFyIGxlbiA9IGFWYWx1ZS5sZW5ndGg7XG5cbiAgICAgICAgaWYgKGxlbiA9PSAxMCkge1xuICAgICAgICAgIHJldHVybiBhVmFsdWUuc3Vic3RyKDAsIDQpICtcbiAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cig1LCAyKSArXG4gICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoOCwgMik7XG4gICAgICAgIH0gZWxzZSBpZiAobGVuID49IDE5KSB7XG4gICAgICAgICAgcmV0dXJuIGljYWxWYWx1ZXNbXCJkYXRlLXRpbWVcIl0udG9JQ0FMKGFWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9UT0RPOiBzZXJpYWxpemUgd2FybmluZz9cbiAgICAgICAgICByZXR1cm4gYVZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiZGF0ZS10aW1lXCI6IHtcbiAgICAgIGZyb21JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgLy8gZnJvbTogMjAxMjA5MDFUMTMwMDAwXG4gICAgICAgIC8vIHRvOiAyMDEyLTA5LTAxVDEzOjAwOjAwXG4gICAgICAgIGlmICghZGVzaWduLnN0cmljdCAmJiBhVmFsdWUubGVuZ3RoID09IDgpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGEgZGF0ZSwgZS5nLiAyMDEyMDkwMVxuICAgICAgICAgIHJldHVybiBpY2FsVmFsdWVzLmRhdGUuZnJvbUlDQUwoYVZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gYVZhbHVlLnN1YnN0cigwLCA0KSArICctJyArXG4gICAgICAgICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoNCwgMikgKyAnLScgK1xuICAgICAgICAgICAgICAgICAgICAgICBhVmFsdWUuc3Vic3RyKDYsIDIpICsgJ1QnICtcbiAgICAgICAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cig5LCAyKSArICc6JyArXG4gICAgICAgICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoMTEsIDIpICsgJzonICtcbiAgICAgICAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cigxMywgMik7XG5cbiAgICAgICAgICBpZiAoYVZhbHVlWzE1XSAmJiBhVmFsdWVbMTVdID09PSAnWicpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnWic7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgdG9JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgLy8gZnJvbTogMjAxMi0wOS0wMVQxMzowMDowMFxuICAgICAgICAvLyB0bzogMjAxMjA5MDFUMTMwMDAwXG4gICAgICAgIHZhciBsZW4gPSBhVmFsdWUubGVuZ3RoO1xuXG4gICAgICAgIGlmIChsZW4gPT0gMTAgJiYgIWRlc2lnbi5zdHJpY3QpIHtcbiAgICAgICAgICByZXR1cm4gaWNhbFZhbHVlcy5kYXRlLnRvSUNBTChhVmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGxlbiA+PSAxOSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBhVmFsdWUuc3Vic3RyKDAsIDQpICtcbiAgICAgICAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cig1LCAyKSArXG4gICAgICAgICAgICAgICAgICAgICAgIC8vIGdyYWIgdGhlIChERFRISCkgc2VnbWVudFxuICAgICAgICAgICAgICAgICAgICAgICBhVmFsdWUuc3Vic3RyKDgsIDUpICtcbiAgICAgICAgICAgICAgICAgICAgICAgLy8gTU1cbiAgICAgICAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cigxNCwgMikgK1xuICAgICAgICAgICAgICAgICAgICAgICAvLyBTU1xuICAgICAgICAgICAgICAgICAgICAgICBhVmFsdWUuc3Vic3RyKDE3LCAyKTtcblxuICAgICAgICAgIGlmIChhVmFsdWVbMTldICYmIGFWYWx1ZVsxOV0gPT09ICdaJykge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICdaJztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUT0RPOiBlcnJvclxuICAgICAgICAgIHJldHVybiBhVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUsIGFQcm9wKSB7XG4gICAgICAgIGlmIChkZXNpZ24uc3RyaWN0KSB7XG4gICAgICAgICAgcmV0dXJuIElDQUwuVGltZS5mcm9tRGF0ZVRpbWVTdHJpbmcoYVZhbHVlLCBhUHJvcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIElDQUwuVGltZS5mcm9tU3RyaW5nKGFWYWx1ZSwgYVByb3ApO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB1bmRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFWYWx1ZS50b1N0cmluZygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZHVyYXRpb246IHtcbiAgICAgIGRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIElDQUwuRHVyYXRpb24uZnJvbVN0cmluZyhhVmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHVuZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gYVZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBwZXJpb2Q6IHtcblxuICAgICAgZnJvbUlDQUw6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICB2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJy8nKTtcbiAgICAgICAgcGFydHNbMF0gPSBpY2FsVmFsdWVzWydkYXRlLXRpbWUnXS5mcm9tSUNBTChwYXJ0c1swXSk7XG5cbiAgICAgICAgaWYgKCFJQ0FMLkR1cmF0aW9uLmlzVmFsdWVTdHJpbmcocGFydHNbMV0pKSB7XG4gICAgICAgICAgcGFydHNbMV0gPSBpY2FsVmFsdWVzWydkYXRlLXRpbWUnXS5mcm9tSUNBTChwYXJ0c1sxXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFydHM7XG4gICAgICB9LFxuXG4gICAgICB0b0lDQUw6IGZ1bmN0aW9uKHBhcnRzKSB7XG4gICAgICAgIGlmICghZGVzaWduLnN0cmljdCAmJiBwYXJ0c1swXS5sZW5ndGggPT0gMTApIHtcbiAgICAgICAgICBwYXJ0c1swXSA9IGljYWxWYWx1ZXMuZGF0ZS50b0lDQUwocGFydHNbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcnRzWzBdID0gaWNhbFZhbHVlc1snZGF0ZS10aW1lJ10udG9JQ0FMKHBhcnRzWzBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghSUNBTC5EdXJhdGlvbi5pc1ZhbHVlU3RyaW5nKHBhcnRzWzFdKSkge1xuICAgICAgICAgIGlmICghZGVzaWduLnN0cmljdCAmJiBwYXJ0c1sxXS5sZW5ndGggPT0gMTApIHtcbiAgICAgICAgICAgIHBhcnRzWzFdID0gaWNhbFZhbHVlcy5kYXRlLnRvSUNBTChwYXJ0c1sxXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnRzWzFdID0gaWNhbFZhbHVlc1snZGF0ZS10aW1lJ10udG9JQ0FMKHBhcnRzWzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFydHMuam9pbihcIi9cIik7XG4gICAgICB9LFxuXG4gICAgICBkZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlLCBhUHJvcCkge1xuICAgICAgICByZXR1cm4gSUNBTC5QZXJpb2QuZnJvbUpTT04oYVZhbHVlLCBhUHJvcCwgIWRlc2lnbi5zdHJpY3QpO1xuICAgICAgfSxcblxuICAgICAgdW5kZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhVmFsdWUudG9KU09OKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICByZWN1cjoge1xuICAgICAgZnJvbUlDQUw6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICByZXR1cm4gSUNBTC5SZWN1ci5fc3RyaW5nVG9EYXRhKHN0cmluZywgdHJ1ZSk7XG4gICAgICB9LFxuXG4gICAgICB0b0lDQUw6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdmFyIHN0ciA9IFwiXCI7XG4gICAgICAgIGZvciAodmFyIGsgaW4gZGF0YSkge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGspKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHZhbCA9IGRhdGFba107XG4gICAgICAgICAgaWYgKGsgPT0gXCJ1bnRpbFwiKSB7XG4gICAgICAgICAgICBpZiAodmFsLmxlbmd0aCA+IDEwKSB7XG4gICAgICAgICAgICAgIHZhbCA9IGljYWxWYWx1ZXNbJ2RhdGUtdGltZSddLnRvSUNBTCh2YWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFsID0gaWNhbFZhbHVlcy5kYXRlLnRvSUNBTCh2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoayA9PSBcIndrc3RcIikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgIHZhbCA9IElDQUwuUmVjdXIubnVtZXJpY0RheVRvSWNhbERheSh2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgICAgICB2YWwgPSB2YWwuam9pbihcIixcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0ciArPSBrLnRvVXBwZXJDYXNlKCkgKyBcIj1cIiArIHZhbCArIFwiO1wiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHIuc3Vic3RyKDAsIHN0ci5sZW5ndGggLSAxKTtcbiAgICAgIH0sXG5cbiAgICAgIGRlY29yYXRlOiBmdW5jdGlvbiBkZWNvcmF0ZShhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIElDQUwuUmVjdXIuZnJvbURhdGEoYVZhbHVlKTtcbiAgICAgIH0sXG5cbiAgICAgIHVuZGVjb3JhdGU6IGZ1bmN0aW9uKGFSZWN1cikge1xuICAgICAgICByZXR1cm4gYVJlY3VyLnRvSlNPTigpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB0aW1lOiB7XG4gICAgICBmcm9tSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIC8vIGZyb206IE1NSEhTUyhaKT9cbiAgICAgICAgLy8gdG86IEhIOk1NOlNTKFopP1xuICAgICAgICBpZiAoYVZhbHVlLmxlbmd0aCA8IDYpIHtcbiAgICAgICAgICAvLyBUT0RPOiBwYXJzZXIgZXhjZXB0aW9uP1xuICAgICAgICAgIHJldHVybiBhVmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBISDo6TU06OlNTWj9cbiAgICAgICAgdmFyIHJlc3VsdCA9IGFWYWx1ZS5zdWJzdHIoMCwgMikgKyAnOicgK1xuICAgICAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cigyLCAyKSArICc6JyArXG4gICAgICAgICAgICAgICAgICAgICBhVmFsdWUuc3Vic3RyKDQsIDIpO1xuXG4gICAgICAgIGlmIChhVmFsdWVbNl0gPT09ICdaJykge1xuICAgICAgICAgIHJlc3VsdCArPSAnWic7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcblxuICAgICAgdG9JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgLy8gZnJvbTogSEg6TU06U1MoWik/XG4gICAgICAgIC8vIHRvOiBNTUhIU1MoWik/XG4gICAgICAgIGlmIChhVmFsdWUubGVuZ3RoIDwgOCkge1xuICAgICAgICAgIC8vVE9ETzogZXJyb3JcbiAgICAgICAgICByZXR1cm4gYVZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IGFWYWx1ZS5zdWJzdHIoMCwgMikgK1xuICAgICAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cigzLCAyKSArXG4gICAgICAgICAgICAgICAgICAgICBhVmFsdWUuc3Vic3RyKDYsIDIpO1xuXG4gICAgICAgIGlmIChhVmFsdWVbOF0gPT09ICdaJykge1xuICAgICAgICAgIHJlc3VsdCArPSAnWic7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGljYWxQcm9wZXJ0aWVzID0gSUNBTC5oZWxwZXJzLmV4dGVuZChjb21tb25Qcm9wZXJ0aWVzLCB7XG5cbiAgICBcImFjdGlvblwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBcImF0dGFjaFwiOiB7IGRlZmF1bHRUeXBlOiBcInVyaVwiIH0sXG4gICAgXCJhdHRlbmRlZVwiOiB7IGRlZmF1bHRUeXBlOiBcImNhbC1hZGRyZXNzXCIgfSxcbiAgICBcImNhbHNjYWxlXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIFwiY2xhc3NcIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgXCJjb21tZW50XCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIFwiY29tcGxldGVkXCI6IERFRkFVTFRfVFlQRV9EQVRFVElNRSxcbiAgICBcImNvbnRhY3RcIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgXCJjcmVhdGVkXCI6IERFRkFVTFRfVFlQRV9EQVRFVElNRSxcbiAgICBcImRlc2NyaXB0aW9uXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIFwiZHRlbmRcIjogREVGQVVMVF9UWVBFX0RBVEVUSU1FX0RBVEUsXG4gICAgXCJkdHN0YW1wXCI6IERFRkFVTFRfVFlQRV9EQVRFVElNRSxcbiAgICBcImR0c3RhcnRcIjogREVGQVVMVF9UWVBFX0RBVEVUSU1FX0RBVEUsXG4gICAgXCJkdWVcIjogREVGQVVMVF9UWVBFX0RBVEVUSU1FX0RBVEUsXG4gICAgXCJkdXJhdGlvblwiOiB7IGRlZmF1bHRUeXBlOiBcImR1cmF0aW9uXCIgfSxcbiAgICBcImV4ZGF0ZVwiOiB7XG4gICAgICBkZWZhdWx0VHlwZTogXCJkYXRlLXRpbWVcIixcbiAgICAgIGFsbG93ZWRUeXBlczogW1wiZGF0ZS10aW1lXCIsIFwiZGF0ZVwiXSxcbiAgICAgIG11bHRpVmFsdWU6ICcsJ1xuICAgIH0sXG4gICAgXCJleHJ1bGVcIjogREVGQVVMVF9UWVBFX1JFQ1VSLFxuICAgIFwiZnJlZWJ1c3lcIjogeyBkZWZhdWx0VHlwZTogXCJwZXJpb2RcIiwgbXVsdGlWYWx1ZTogXCIsXCIgfSxcbiAgICBcImdlb1wiOiB7IGRlZmF1bHRUeXBlOiBcImZsb2F0XCIsIHN0cnVjdHVyZWRWYWx1ZTogXCI7XCIgfSxcbiAgICBcImxhc3QtbW9kaWZpZWRcIjogREVGQVVMVF9UWVBFX0RBVEVUSU1FLFxuICAgIFwibG9jYXRpb25cIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgXCJtZXRob2RcIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgXCJvcmdhbml6ZXJcIjogeyBkZWZhdWx0VHlwZTogXCJjYWwtYWRkcmVzc1wiIH0sXG4gICAgXCJwZXJjZW50LWNvbXBsZXRlXCI6IERFRkFVTFRfVFlQRV9JTlRFR0VSLFxuICAgIFwicHJpb3JpdHlcIjogREVGQVVMVF9UWVBFX0lOVEVHRVIsXG4gICAgXCJwcm9kaWRcIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgXCJyZWxhdGVkLXRvXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIFwicmVwZWF0XCI6IERFRkFVTFRfVFlQRV9JTlRFR0VSLFxuICAgIFwicmRhdGVcIjoge1xuICAgICAgZGVmYXVsdFR5cGU6IFwiZGF0ZS10aW1lXCIsXG4gICAgICBhbGxvd2VkVHlwZXM6IFtcImRhdGUtdGltZVwiLCBcImRhdGVcIiwgXCJwZXJpb2RcIl0sXG4gICAgICBtdWx0aVZhbHVlOiAnLCcsXG4gICAgICBkZXRlY3RUeXBlOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgaWYgKHN0cmluZy5pbmRleE9mKCcvJykgIT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuICdwZXJpb2QnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoc3RyaW5nLmluZGV4T2YoJ1QnKSA9PT0gLTEpID8gJ2RhdGUnIDogJ2RhdGUtdGltZSc7XG4gICAgICB9XG4gICAgfSxcbiAgICBcInJlY3VycmVuY2UtaWRcIjogREVGQVVMVF9UWVBFX0RBVEVUSU1FX0RBVEUsXG4gICAgXCJyZXNvdXJjZXNcIjogREVGQVVMVF9UWVBFX1RFWFRfTVVMVEksXG4gICAgXCJyZXF1ZXN0LXN0YXR1c1wiOiBERUZBVUxUX1RZUEVfVEVYVF9TVFJVQ1RVUkVELFxuICAgIFwicnJ1bGVcIjogREVGQVVMVF9UWVBFX1JFQ1VSLFxuICAgIFwic2VxdWVuY2VcIjogREVGQVVMVF9UWVBFX0lOVEVHRVIsXG4gICAgXCJzdGF0dXNcIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgXCJzdW1tYXJ5XCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIFwidHJhbnNwXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIFwidHJpZ2dlclwiOiB7IGRlZmF1bHRUeXBlOiBcImR1cmF0aW9uXCIsIGFsbG93ZWRUeXBlczogW1wiZHVyYXRpb25cIiwgXCJkYXRlLXRpbWVcIl0gfSxcbiAgICBcInR6b2Zmc2V0ZnJvbVwiOiBERUZBVUxUX1RZUEVfVVRDT0ZGU0VULFxuICAgIFwidHpvZmZzZXR0b1wiOiBERUZBVUxUX1RZUEVfVVRDT0ZGU0VULFxuICAgIFwidHp1cmxcIjogREVGQVVMVF9UWVBFX1VSSSxcbiAgICBcInR6aWRcIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgXCJ0em5hbWVcIjogREVGQVVMVF9UWVBFX1RFWFRcbiAgfSk7XG5cbiAgLy8gV2hlbiBhZGRpbmcgYSB2YWx1ZSBoZXJlLCBiZSBzdXJlIHRvIGFkZCBpdCB0byB0aGUgcGFyYW1ldGVyIHR5cGVzIVxuICB2YXIgdmNhcmRWYWx1ZXMgPSBJQ0FMLmhlbHBlcnMuZXh0ZW5kKGNvbW1vblZhbHVlcywge1xuICAgIHRleHQ6IGNyZWF0ZVRleHRUeXBlKEZST01fVkNBUkRfTkVXTElORSwgVE9fVkNBUkRfTkVXTElORSksXG4gICAgdXJpOiBjcmVhdGVUZXh0VHlwZShGUk9NX1ZDQVJEX05FV0xJTkUsIFRPX1ZDQVJEX05FV0xJTkUpLFxuXG4gICAgZGF0ZToge1xuICAgICAgZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gSUNBTC5WQ2FyZFRpbWUuZnJvbURhdGVBbmRPclRpbWVTdHJpbmcoYVZhbHVlLCBcImRhdGVcIik7XG4gICAgICB9LFxuICAgICAgdW5kZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhVmFsdWUudG9TdHJpbmcoKTtcbiAgICAgIH0sXG4gICAgICBmcm9tSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIGlmIChhVmFsdWUubGVuZ3RoID09IDgpIHtcbiAgICAgICAgICByZXR1cm4gaWNhbFZhbHVlcy5kYXRlLmZyb21JQ0FMKGFWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYVZhbHVlWzBdID09ICctJyAmJiBhVmFsdWUubGVuZ3RoID09IDYpIHtcbiAgICAgICAgICByZXR1cm4gYVZhbHVlLnN1YnN0cigwLCA0KSArICctJyArIGFWYWx1ZS5zdWJzdHIoNCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGFWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRvSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIGlmIChhVmFsdWUubGVuZ3RoID09IDEwKSB7XG4gICAgICAgICAgcmV0dXJuIGljYWxWYWx1ZXMuZGF0ZS50b0lDQUwoYVZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChhVmFsdWVbMF0gPT0gJy0nICYmIGFWYWx1ZS5sZW5ndGggPT0gNykge1xuICAgICAgICAgIHJldHVybiBhVmFsdWUuc3Vic3RyKDAsIDQpICsgYVZhbHVlLnN1YnN0cig1KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYVZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHRpbWU6IHtcbiAgICAgIGRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIElDQUwuVkNhcmRUaW1lLmZyb21EYXRlQW5kT3JUaW1lU3RyaW5nKFwiVFwiICsgYVZhbHVlLCBcInRpbWVcIik7XG4gICAgICB9LFxuICAgICAgdW5kZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhVmFsdWUudG9TdHJpbmcoKTtcbiAgICAgIH0sXG4gICAgICBmcm9tSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHZhciBzcGxpdHpvbmUgPSB2Y2FyZFZhbHVlcy50aW1lLl9zcGxpdFpvbmUoYVZhbHVlLCB0cnVlKTtcbiAgICAgICAgdmFyIHpvbmUgPSBzcGxpdHpvbmVbMF0sIHZhbHVlID0gc3BsaXR6b25lWzFdO1xuXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJTUExJVDogXCIsc3BsaXR6b25lKTtcblxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09IDYpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cigwLCAyKSArICc6JyArXG4gICAgICAgICAgICAgICAgICB2YWx1ZS5zdWJzdHIoMiwgMikgKyAnOicgK1xuICAgICAgICAgICAgICAgICAgdmFsdWUuc3Vic3RyKDQsIDIpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlLmxlbmd0aCA9PSA0ICYmIHZhbHVlWzBdICE9ICctJykge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyKDAsIDIpICsgJzonICsgdmFsdWUuc3Vic3RyKDIsIDIpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlLmxlbmd0aCA9PSA1KSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHIoMCwgMykgKyAnOicgKyB2YWx1ZS5zdWJzdHIoMywgMik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoem9uZS5sZW5ndGggPT0gNSAmJiAoem9uZVswXSA9PSAnLScgfHwgem9uZVswXSA9PSAnKycpKSB7XG4gICAgICAgICAgem9uZSA9IHpvbmUuc3Vic3RyKDAsIDMpICsgJzonICsgem9uZS5zdWJzdHIoMyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWUgKyB6b25lO1xuICAgICAgfSxcblxuICAgICAgdG9JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgdmFyIHNwbGl0em9uZSA9IHZjYXJkVmFsdWVzLnRpbWUuX3NwbGl0Wm9uZShhVmFsdWUpO1xuICAgICAgICB2YXIgem9uZSA9IHNwbGl0em9uZVswXSwgdmFsdWUgPSBzcGxpdHpvbmVbMV07XG5cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PSA4KSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHIoMCwgMikgK1xuICAgICAgICAgICAgICAgICAgdmFsdWUuc3Vic3RyKDMsIDIpICtcbiAgICAgICAgICAgICAgICAgIHZhbHVlLnN1YnN0cig2LCAyKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZS5sZW5ndGggPT0gNSAmJiB2YWx1ZVswXSAhPSAnLScpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cigwLCAyKSArIHZhbHVlLnN1YnN0cigzLCAyKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZS5sZW5ndGggPT0gNikge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyKDAsIDMpICsgdmFsdWUuc3Vic3RyKDQsIDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHpvbmUubGVuZ3RoID09IDYgJiYgKHpvbmVbMF0gPT0gJy0nIHx8IHpvbmVbMF0gPT0gJysnKSkge1xuICAgICAgICAgIHpvbmUgPSB6b25lLnN1YnN0cigwLCAzKSArIHpvbmUuc3Vic3RyKDQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlICsgem9uZTtcbiAgICAgIH0sXG5cbiAgICAgIF9zcGxpdFpvbmU6IGZ1bmN0aW9uKGFWYWx1ZSwgaXNGcm9tSWNhbCkge1xuICAgICAgICB2YXIgbGFzdENoYXIgPSBhVmFsdWUubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIHNpZ25DaGFyID0gYVZhbHVlLmxlbmd0aCAtIChpc0Zyb21JY2FsID8gNSA6IDYpO1xuICAgICAgICB2YXIgc2lnbiA9IGFWYWx1ZVtzaWduQ2hhcl07XG4gICAgICAgIHZhciB6b25lLCB2YWx1ZTtcblxuICAgICAgICBpZiAoYVZhbHVlW2xhc3RDaGFyXSA9PSAnWicpIHtcbiAgICAgICAgICB6b25lID0gYVZhbHVlW2xhc3RDaGFyXTtcbiAgICAgICAgICB2YWx1ZSA9IGFWYWx1ZS5zdWJzdHIoMCwgbGFzdENoYXIpO1xuICAgICAgICB9IGVsc2UgaWYgKGFWYWx1ZS5sZW5ndGggPiA2ICYmIChzaWduID09ICctJyB8fCBzaWduID09ICcrJykpIHtcbiAgICAgICAgICB6b25lID0gYVZhbHVlLnN1YnN0cihzaWduQ2hhcik7XG4gICAgICAgICAgdmFsdWUgPSBhVmFsdWUuc3Vic3RyKDAsIHNpZ25DaGFyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB6b25lID0gXCJcIjtcbiAgICAgICAgICB2YWx1ZSA9IGFWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbem9uZSwgdmFsdWVdO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImRhdGUtdGltZVwiOiB7XG4gICAgICBkZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBJQ0FMLlZDYXJkVGltZS5mcm9tRGF0ZUFuZE9yVGltZVN0cmluZyhhVmFsdWUsIFwiZGF0ZS10aW1lXCIpO1xuICAgICAgfSxcblxuICAgICAgdW5kZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhVmFsdWUudG9TdHJpbmcoKTtcbiAgICAgIH0sXG5cbiAgICAgIGZyb21JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZjYXJkVmFsdWVzWydkYXRlLWFuZC1vci10aW1lJ10uZnJvbUlDQUwoYVZhbHVlKTtcbiAgICAgIH0sXG5cbiAgICAgIHRvSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2Y2FyZFZhbHVlc1snZGF0ZS1hbmQtb3ItdGltZSddLnRvSUNBTChhVmFsdWUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImRhdGUtYW5kLW9yLXRpbWVcIjoge1xuICAgICAgZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gSUNBTC5WQ2FyZFRpbWUuZnJvbURhdGVBbmRPclRpbWVTdHJpbmcoYVZhbHVlLCBcImRhdGUtYW5kLW9yLXRpbWVcIik7XG4gICAgICB9LFxuXG4gICAgICB1bmRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFWYWx1ZS50b1N0cmluZygpO1xuICAgICAgfSxcblxuICAgICAgZnJvbUlDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICB2YXIgcGFydHMgPSBhVmFsdWUuc3BsaXQoJ1QnKTtcbiAgICAgICAgcmV0dXJuIChwYXJ0c1swXSA/IHZjYXJkVmFsdWVzLmRhdGUuZnJvbUlDQUwocGFydHNbMF0pIDogJycpICtcbiAgICAgICAgICAgICAgIChwYXJ0c1sxXSA/ICdUJyArIHZjYXJkVmFsdWVzLnRpbWUuZnJvbUlDQUwocGFydHNbMV0pIDogJycpO1xuICAgICAgfSxcblxuICAgICAgdG9JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgdmFyIHBhcnRzID0gYVZhbHVlLnNwbGl0KCdUJyk7XG4gICAgICAgIHJldHVybiB2Y2FyZFZhbHVlcy5kYXRlLnRvSUNBTChwYXJ0c1swXSkgK1xuICAgICAgICAgICAgICAgKHBhcnRzWzFdID8gJ1QnICsgdmNhcmRWYWx1ZXMudGltZS50b0lDQUwocGFydHNbMV0pIDogJycpO1xuXG4gICAgICB9XG4gICAgfSxcbiAgICB0aW1lc3RhbXA6IGljYWxWYWx1ZXNbJ2RhdGUtdGltZSddLFxuICAgIFwibGFuZ3VhZ2UtdGFnXCI6IHtcbiAgICAgIG1hdGNoZXM6IC9eW2EtekEtWjAtOS1dKyQvIC8vIENvdWxkIGdvIHdpdGggYSBtb3JlIHN0cmljdCByZWdleCBoZXJlXG4gICAgfVxuICB9KTtcblxuICB2YXIgdmNhcmRQYXJhbXMgPSB7XG4gICAgXCJ0eXBlXCI6IHtcbiAgICAgIHZhbHVlVHlwZTogXCJ0ZXh0XCIsXG4gICAgICBtdWx0aVZhbHVlOiBcIixcIlxuICAgIH0sXG4gICAgXCJ2YWx1ZVwiOiB7XG4gICAgICAvLyBzaW5jZSB0aGUgdmFsdWUgaGVyZSBpcyBhICd0eXBlJyBsb3dlcmNhc2UgaXMgdXNlZC5cbiAgICAgIHZhbHVlczogW1widGV4dFwiLCBcInVyaVwiLCBcImRhdGVcIiwgXCJ0aW1lXCIsIFwiZGF0ZS10aW1lXCIsIFwiZGF0ZS1hbmQtb3ItdGltZVwiLFxuICAgICAgICAgICAgICAgXCJ0aW1lc3RhbXBcIiwgXCJib29sZWFuXCIsIFwiaW50ZWdlclwiLCBcImZsb2F0XCIsIFwidXRjLW9mZnNldFwiLFxuICAgICAgICAgICAgICAgXCJsYW5ndWFnZS10YWdcIl0sXG4gICAgICBhbGxvd1hOYW1lOiB0cnVlLFxuICAgICAgYWxsb3dJYW5hVG9rZW46IHRydWVcbiAgICB9XG4gIH07XG5cbiAgdmFyIHZjYXJkUHJvcGVydGllcyA9IElDQUwuaGVscGVycy5leHRlbmQoY29tbW9uUHJvcGVydGllcywge1xuICAgIFwiYWRyXCI6IHsgZGVmYXVsdFR5cGU6IFwidGV4dFwiLCBzdHJ1Y3R1cmVkVmFsdWU6IFwiO1wiLCBtdWx0aVZhbHVlOiBcIixcIiB9LFxuICAgIFwiYW5uaXZlcnNhcnlcIjogREVGQVVMVF9UWVBFX0RBVEVfQU5ET1JfVElNRSxcbiAgICBcImJkYXlcIjogREVGQVVMVF9UWVBFX0RBVEVfQU5ET1JfVElNRSxcbiAgICBcImNhbGFkcnVyaVwiOiBERUZBVUxUX1RZUEVfVVJJLFxuICAgIFwiY2FsdXJpXCI6IERFRkFVTFRfVFlQRV9VUkksXG4gICAgXCJjbGllbnRwaWRtYXBcIjogREVGQVVMVF9UWVBFX1RFWFRfU1RSVUNUVVJFRCxcbiAgICBcImVtYWlsXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIFwiZmJ1cmxcIjogREVGQVVMVF9UWVBFX1VSSSxcbiAgICBcImZuXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIFwiZ2VuZGVyXCI6IERFRkFVTFRfVFlQRV9URVhUX1NUUlVDVFVSRUQsXG4gICAgXCJnZW9cIjogREVGQVVMVF9UWVBFX1VSSSxcbiAgICBcImltcHBcIjogREVGQVVMVF9UWVBFX1VSSSxcbiAgICBcImtleVwiOiBERUZBVUxUX1RZUEVfVVJJLFxuICAgIFwia2luZFwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBcImxhbmdcIjogeyBkZWZhdWx0VHlwZTogXCJsYW5ndWFnZS10YWdcIiB9LFxuICAgIFwibG9nb1wiOiBERUZBVUxUX1RZUEVfVVJJLFxuICAgIFwibWVtYmVyXCI6IERFRkFVTFRfVFlQRV9VUkksXG4gICAgXCJuXCI6IHsgZGVmYXVsdFR5cGU6IFwidGV4dFwiLCBzdHJ1Y3R1cmVkVmFsdWU6IFwiO1wiLCBtdWx0aVZhbHVlOiBcIixcIiB9LFxuICAgIFwibmlja25hbWVcIjogREVGQVVMVF9UWVBFX1RFWFRfTVVMVEksXG4gICAgXCJub3RlXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIFwib3JnXCI6IHsgZGVmYXVsdFR5cGU6IFwidGV4dFwiLCBzdHJ1Y3R1cmVkVmFsdWU6IFwiO1wiIH0sXG4gICAgXCJwaG90b1wiOiBERUZBVUxUX1RZUEVfVVJJLFxuICAgIFwicmVsYXRlZFwiOiBERUZBVUxUX1RZUEVfVVJJLFxuICAgIFwicmV2XCI6IHsgZGVmYXVsdFR5cGU6IFwidGltZXN0YW1wXCIgfSxcbiAgICBcInJvbGVcIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgXCJzb3VuZFwiOiBERUZBVUxUX1RZUEVfVVJJLFxuICAgIFwic291cmNlXCI6IERFRkFVTFRfVFlQRV9VUkksXG4gICAgXCJ0ZWxcIjogeyBkZWZhdWx0VHlwZTogXCJ1cmlcIiwgYWxsb3dlZFR5cGVzOiBbXCJ1cmlcIiwgXCJ0ZXh0XCJdIH0sXG4gICAgXCJ0aXRsZVwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBcInR6XCI6IHsgZGVmYXVsdFR5cGU6IFwidGV4dFwiLCBhbGxvd2VkVHlwZXM6IFtcInRleHRcIiwgXCJ1dGMtb2Zmc2V0XCIsIFwidXJpXCJdIH0sXG4gICAgXCJ4bWxcIjogREVGQVVMVF9UWVBFX1RFWFRcbiAgfSk7XG5cbiAgdmFyIHZjYXJkM1ZhbHVlcyA9IElDQUwuaGVscGVycy5leHRlbmQoY29tbW9uVmFsdWVzLCB7XG4gICAgYmluYXJ5OiBpY2FsVmFsdWVzLmJpbmFyeSxcbiAgICBkYXRlOiB2Y2FyZFZhbHVlcy5kYXRlLFxuICAgIFwiZGF0ZS10aW1lXCI6IHZjYXJkVmFsdWVzW1wiZGF0ZS10aW1lXCJdLFxuICAgIFwicGhvbmUtbnVtYmVyXCI6IHtcbiAgICAgIC8vIFRPRE9cbiAgICAgIC8qIC4uLiAqL1xuICAgIH0sXG4gICAgdXJpOiBpY2FsVmFsdWVzLnVyaSxcbiAgICB0ZXh0OiBpY2FsVmFsdWVzLnRleHQsXG4gICAgdGltZTogaWNhbFZhbHVlcy50aW1lLFxuICAgIHZjYXJkOiBpY2FsVmFsdWVzLnRleHQsXG4gICAgXCJ1dGMtb2Zmc2V0XCI6IHtcbiAgICAgIHRvSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhVmFsdWUuc3Vic3RyKDAsIDcpO1xuICAgICAgfSxcblxuICAgICAgZnJvbUlDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gYVZhbHVlLnN1YnN0cigwLCA3KTtcbiAgICAgIH0sXG5cbiAgICAgIGRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIElDQUwuVXRjT2Zmc2V0LmZyb21TdHJpbmcoYVZhbHVlKTtcbiAgICAgIH0sXG5cbiAgICAgIHVuZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gYVZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICB2YXIgdmNhcmQzUGFyYW1zID0ge1xuICAgIFwidHlwZVwiOiB7XG4gICAgICB2YWx1ZVR5cGU6IFwidGV4dFwiLFxuICAgICAgbXVsdGlWYWx1ZTogXCIsXCJcbiAgICB9LFxuICAgIFwidmFsdWVcIjoge1xuICAgICAgLy8gc2luY2UgdGhlIHZhbHVlIGhlcmUgaXMgYSAndHlwZScgbG93ZXJjYXNlIGlzIHVzZWQuXG4gICAgICB2YWx1ZXM6IFtcInRleHRcIiwgXCJ1cmlcIiwgXCJkYXRlXCIsIFwiZGF0ZS10aW1lXCIsIFwicGhvbmUtbnVtYmVyXCIsIFwidGltZVwiLFxuICAgICAgICAgICAgICAgXCJib29sZWFuXCIsIFwiaW50ZWdlclwiLCBcImZsb2F0XCIsIFwidXRjLW9mZnNldFwiLCBcInZjYXJkXCIsIFwiYmluYXJ5XCJdLFxuICAgICAgYWxsb3dYTmFtZTogdHJ1ZSxcbiAgICAgIGFsbG93SWFuYVRva2VuOiB0cnVlXG4gICAgfVxuICB9O1xuXG4gIHZhciB2Y2FyZDNQcm9wZXJ0aWVzID0gSUNBTC5oZWxwZXJzLmV4dGVuZChjb21tb25Qcm9wZXJ0aWVzLCB7XG4gICAgZm46IERFRkFVTFRfVFlQRV9URVhULFxuICAgIG46IHsgZGVmYXVsdFR5cGU6IFwidGV4dFwiLCBzdHJ1Y3R1cmVkVmFsdWU6IFwiO1wiLCBtdWx0aVZhbHVlOiBcIixcIiB9LFxuICAgIG5pY2tuYW1lOiBERUZBVUxUX1RZUEVfVEVYVF9NVUxUSSxcbiAgICBwaG90bzogeyBkZWZhdWx0VHlwZTogXCJiaW5hcnlcIiwgYWxsb3dlZFR5cGVzOiBbXCJiaW5hcnlcIiwgXCJ1cmlcIl0gfSxcbiAgICBiZGF5OiB7XG4gICAgICBkZWZhdWx0VHlwZTogXCJkYXRlLXRpbWVcIixcbiAgICAgIGFsbG93ZWRUeXBlczogW1wiZGF0ZS10aW1lXCIsIFwiZGF0ZVwiXSxcbiAgICAgIGRldGVjdFR5cGU6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICByZXR1cm4gKHN0cmluZy5pbmRleE9mKCdUJykgPT09IC0xKSA/ICdkYXRlJyA6ICdkYXRlLXRpbWUnO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBhZHI6IHsgZGVmYXVsdFR5cGU6IFwidGV4dFwiLCBzdHJ1Y3R1cmVkVmFsdWU6IFwiO1wiLCBtdWx0aVZhbHVlOiBcIixcIiB9LFxuICAgIGxhYmVsOiBERUZBVUxUX1RZUEVfVEVYVCxcblxuICAgIHRlbDogeyBkZWZhdWx0VHlwZTogXCJwaG9uZS1udW1iZXJcIiB9LFxuICAgIGVtYWlsOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBtYWlsZXI6IERFRkFVTFRfVFlQRV9URVhULFxuXG4gICAgdHo6IHsgZGVmYXVsdFR5cGU6IFwidXRjLW9mZnNldFwiLCBhbGxvd2VkVHlwZXM6IFtcInV0Yy1vZmZzZXRcIiwgXCJ0ZXh0XCJdIH0sXG4gICAgZ2VvOiB7IGRlZmF1bHRUeXBlOiBcImZsb2F0XCIsIHN0cnVjdHVyZWRWYWx1ZTogXCI7XCIgfSxcblxuICAgIHRpdGxlOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICByb2xlOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBsb2dvOiB7IGRlZmF1bHRUeXBlOiBcImJpbmFyeVwiLCBhbGxvd2VkVHlwZXM6IFtcImJpbmFyeVwiLCBcInVyaVwiXSB9LFxuICAgIGFnZW50OiB7IGRlZmF1bHRUeXBlOiBcInZjYXJkXCIsIGFsbG93ZWRUeXBlczogW1widmNhcmRcIiwgXCJ0ZXh0XCIsIFwidXJpXCJdIH0sXG4gICAgb3JnOiBERUZBVUxUX1RZUEVfVEVYVF9TVFJVQ1RVUkVELFxuXG4gICAgbm90ZTogREVGQVVMVF9UWVBFX1RFWFRfTVVMVEksXG4gICAgcHJvZGlkOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICByZXY6IHtcbiAgICAgIGRlZmF1bHRUeXBlOiBcImRhdGUtdGltZVwiLFxuICAgICAgYWxsb3dlZFR5cGVzOiBbXCJkYXRlLXRpbWVcIiwgXCJkYXRlXCJdLFxuICAgICAgZGV0ZWN0VHlwZTogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiAoc3RyaW5nLmluZGV4T2YoJ1QnKSA9PT0gLTEpID8gJ2RhdGUnIDogJ2RhdGUtdGltZSc7XG4gICAgICB9XG4gICAgfSxcbiAgICBcInNvcnQtc3RyaW5nXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIHNvdW5kOiB7IGRlZmF1bHRUeXBlOiBcImJpbmFyeVwiLCBhbGxvd2VkVHlwZXM6IFtcImJpbmFyeVwiLCBcInVyaVwiXSB9LFxuXG4gICAgY2xhc3M6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIGtleTogeyBkZWZhdWx0VHlwZTogXCJiaW5hcnlcIiwgYWxsb3dlZFR5cGVzOiBbXCJiaW5hcnlcIiwgXCJ0ZXh0XCJdIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIGlDYWxlbmRhciBkZXNpZ24gc2V0XG4gICAqIEB0eXBlIHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9XG4gICAqL1xuICB2YXIgaWNhbFNldCA9IHtcbiAgICB2YWx1ZTogaWNhbFZhbHVlcyxcbiAgICBwYXJhbTogaWNhbFBhcmFtcyxcbiAgICBwcm9wZXJ0eTogaWNhbFByb3BlcnRpZXNcbiAgfTtcblxuICAvKipcbiAgICogdkNhcmQgNC4wIGRlc2lnbiBzZXRcbiAgICogQHR5cGUge0lDQUwuZGVzaWduLmRlc2lnblNldH1cbiAgICovXG4gIHZhciB2Y2FyZFNldCA9IHtcbiAgICB2YWx1ZTogdmNhcmRWYWx1ZXMsXG4gICAgcGFyYW06IHZjYXJkUGFyYW1zLFxuICAgIHByb3BlcnR5OiB2Y2FyZFByb3BlcnRpZXNcbiAgfTtcblxuICAvKipcbiAgICogdkNhcmQgMy4wIGRlc2lnbiBzZXRcbiAgICogQHR5cGUge0lDQUwuZGVzaWduLmRlc2lnblNldH1cbiAgICovXG4gIHZhciB2Y2FyZDNTZXQgPSB7XG4gICAgdmFsdWU6IHZjYXJkM1ZhbHVlcyxcbiAgICBwYXJhbTogdmNhcmQzUGFyYW1zLFxuICAgIHByb3BlcnR5OiB2Y2FyZDNQcm9wZXJ0aWVzXG4gIH07XG5cbiAgLyoqXG4gICAqIFRoZSBkZXNpZ24gZGF0YSwgdXNlZCBieSB0aGUgcGFyc2VyIHRvIGRldGVybWluZSB0eXBlcyBmb3IgcHJvcGVydGllcyBhbmRcbiAgICogb3RoZXIgbWV0YWRhdGEgbmVlZGVkIHRvIHByb2R1Y2UgY29ycmVjdCBqQ2FyZC9qQ2FsIGRhdGEuXG4gICAqXG4gICAqIEBhbGlhcyBJQ0FMLmRlc2lnblxuICAgKiBAbmFtZXNwYWNlXG4gICAqL1xuICB2YXIgZGVzaWduID0ge1xuICAgIC8qKlxuICAgICAqIEEgZGVzaWduU2V0IGRlc2NyaWJlcyB2YWx1ZSwgcGFyYW1ldGVyIGFuZCBwcm9wZXJ0eSBkYXRhLiBJdCBpcyB1c2VkIGJ5XG4gICAgICogdGhlciBwYXJzZXIgYW5kIHN0cmluZ2lmaWVyIGluIGNvbXBvbmVudHMgYW5kIHByb3BlcnRpZXMgdG8gZGV0ZXJtaW5lIHRoZXlcbiAgICAgKiBzaG91bGQgYmUgcmVwcmVzZW50ZWQuXG4gICAgICpcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBkZXNpZ25TZXRcbiAgICAgKiBAbWVtYmVyT2YgSUNBTC5kZXNpZ25cbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gdmFsdWUgICAgICAgRGVmaW5pdGlvbnMgZm9yIHZhbHVlIHR5cGVzLCBrZXlzIGFyZSB0eXBlIG5hbWVzXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IHBhcmFtICAgICAgIERlZmluaXRpb25zIGZvciBwYXJhbXMsIGtleXMgYXJlIHBhcmFtIG5hbWVzXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IHByb3BlcnR5ICAgIERlZmludGlvbnMgZm9yIHByb3BlcnRpZXMsIGtleXMgYXJlIHByb3BlcnR5IG5hbWVzXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBDYW4gYmUgc2V0IHRvIGZhbHNlIHRvIG1ha2UgdGhlIHBhcnNlciBtb3JlIGxlbmllbnQuXG4gICAgICovXG4gICAgc3RyaWN0OiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgc2V0IGZvciBuZXcgcHJvcGVydGllcyBhbmQgY29tcG9uZW50cyBpZiBub25lIGlzIHNwZWNpZmllZC5cbiAgICAgKiBAdHlwZSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fVxuICAgICAqL1xuICAgIGRlZmF1bHRTZXQ6IGljYWxTZXQsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCB0eXBlIGZvciB1bmtub3duIHByb3BlcnRpZXNcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIGRlZmF1bHRUeXBlOiAndW5rbm93bicsXG5cbiAgICAvKipcbiAgICAgKiBIb2xkcyB0aGUgZGVzaWduIHNldCBmb3Iga25vd24gdG9wLWxldmVsIGNvbXBvbmVudHNcbiAgICAgKlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9IHZjYXJkICAgICAgIHZDYXJkIFZDQVJEXG4gICAgICogQHByb3BlcnR5IHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9IHZldmVudCAgICAgIGlDYWxlbmRhciBWRVZFTlRcbiAgICAgKiBAcHJvcGVydHkge0lDQUwuZGVzaWduLmRlc2lnblNldH0gdnRvZG8gICAgICAgaUNhbGVuZGFyIFZUT0RPXG4gICAgICogQHByb3BlcnR5IHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9IHZqb3VybmFsICAgIGlDYWxlbmRhciBWSk9VUk5BTFxuICAgICAqIEBwcm9wZXJ0eSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fSB2YWxhcm0gICAgICBpQ2FsZW5kYXIgVkFMQVJNXG4gICAgICogQHByb3BlcnR5IHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9IHZ0aW1lem9uZSAgIGlDYWxlbmRhciBWVElNRVpPTkVcbiAgICAgKiBAcHJvcGVydHkge0lDQUwuZGVzaWduLmRlc2lnblNldH0gZGF5bGlnaHQgICAgaUNhbGVuZGFyIERBWUxJR0hUXG4gICAgICogQHByb3BlcnR5IHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9IHN0YW5kYXJkICAgIGlDYWxlbmRhciBTVEFOREFSRFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgcHJvcGVydHlOYW1lID0gJ2ZuJztcbiAgICAgKiB2YXIgY29tcG9uZW50RGVzaWduID0gSUNBTC5kZXNpZ24uY29tcG9uZW50cy52Y2FyZDtcbiAgICAgKiB2YXIgcHJvcGVydHlEZXRhaWxzID0gY29tcG9uZW50RGVzaWduLnByb3BlcnR5W3Byb3BlcnR5TmFtZV07XG4gICAgICogaWYgKHByb3BlcnR5RGV0YWlscy5kZWZhdWx0VHlwZSA9PSAndGV4dCcpIHtcbiAgICAgKiAgIC8vIFllcCwgc3VyZSBpcy4uLlxuICAgICAqIH1cbiAgICAgKi9cbiAgICBjb21wb25lbnRzOiB7XG4gICAgICB2Y2FyZDogdmNhcmRTZXQsXG4gICAgICB2Y2FyZDM6IHZjYXJkM1NldCxcbiAgICAgIHZldmVudDogaWNhbFNldCxcbiAgICAgIHZ0b2RvOiBpY2FsU2V0LFxuICAgICAgdmpvdXJuYWw6IGljYWxTZXQsXG4gICAgICB2YWxhcm06IGljYWxTZXQsXG4gICAgICB2dGltZXpvbmU6IGljYWxTZXQsXG4gICAgICBkYXlsaWdodDogaWNhbFNldCxcbiAgICAgIHN0YW5kYXJkOiBpY2FsU2V0XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogVGhlIGRlc2lnbiBzZXQgZm9yIGlDYWxlbmRhciAocmZjNTU0NS9yZmM3MjY1KSBjb21wb25lbnRzLlxuICAgICAqIEB0eXBlIHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9XG4gICAgICovXG4gICAgaWNhbGVuZGFyOiBpY2FsU2V0LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGRlc2lnbiBzZXQgZm9yIHZDYXJkIChyZmM2MzUwL3JmYzcwOTUpIGNvbXBvbmVudHMuXG4gICAgICogQHR5cGUge0lDQUwuZGVzaWduLmRlc2lnblNldH1cbiAgICAgKi9cbiAgICB2Y2FyZDogdmNhcmRTZXQsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVzaWduIHNldCBmb3IgdkNhcmQgKHJmYzI0MjUvcmZjMjQyNi9yZmM3MDk1KSBjb21wb25lbnRzLlxuICAgICAqIEB0eXBlIHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9XG4gICAgICovXG4gICAgdmNhcmQzOiB2Y2FyZDNTZXQsXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBkZXNpZ24gc2V0IGZvciB0aGUgZ2l2ZW4gY29tcG9uZW50IG5hbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29tcG9uZW50TmFtZSAgICAgICAgVGhlIG5hbWUgb2YgdGhlIGNvbXBvbmVudFxuICAgICAqIEByZXR1cm4ge0lDQUwuZGVzaWduLmRlc2lnblNldH0gICAgICBUaGUgZGVzaWduIHNldCBmb3IgdGhlIGNvbXBvbmVudFxuICAgICAqL1xuICAgIGdldERlc2lnblNldDogZnVuY3Rpb24oY29tcG9uZW50TmFtZSkge1xuICAgICAgdmFyIGlzSW5EZXNpZ24gPSBjb21wb25lbnROYW1lICYmIGNvbXBvbmVudE5hbWUgaW4gZGVzaWduLmNvbXBvbmVudHM7XG4gICAgICByZXR1cm4gaXNJbkRlc2lnbiA/IGRlc2lnbi5jb21wb25lbnRzW2NvbXBvbmVudE5hbWVdIDogZGVzaWduLmRlZmF1bHRTZXQ7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBkZXNpZ247XG59KCkpO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoLCAyMDExLTIwMTUgKi9cblxuXG4vKipcbiAqIENvbnRhaW5zIHZhcmlvdXMgZnVuY3Rpb25zIHRvIGNvbnZlcnQgakNhbCBhbmQgakNhcmQgZGF0YSBiYWNrIGludG9cbiAqIGlDYWxlbmRhciBhbmQgdkNhcmQuXG4gKiBAbmFtZXNwYWNlXG4gKi9cbklDQUwuc3RyaW5naWZ5ID0gKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIExJTkVfRU5ESU5HID0gJ1xcclxcbic7XG4gIHZhciBERUZBVUxUX1ZBTFVFX1RZUEUgPSAndW5rbm93bic7XG5cbiAgdmFyIGRlc2lnbiA9IElDQUwuZGVzaWduO1xuICB2YXIgaGVscGVycyA9IElDQUwuaGVscGVycztcblxuICAvKipcbiAgICogQ29udmVydCBhIGZ1bGwgakNhbC9qQ2FyZCBhcnJheSBpbnRvIGEgaUNhbGVuZGFyL3ZDYXJkIHN0cmluZy5cbiAgICpcbiAgICogQGZ1bmN0aW9uIElDQUwuc3RyaW5naWZ5XG4gICAqIEB2YXJpYXRpb24gZnVuY3Rpb25cbiAgICogQHBhcmFtIHtBcnJheX0gakNhbCAgICBUaGUgakNhbC9qQ2FyZCBkb2N1bWVudFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgIFRoZSBzdHJpbmdpZmllZCBpQ2FsZW5kYXIvdkNhcmQgZG9jdW1lbnRcbiAgICovXG4gIGZ1bmN0aW9uIHN0cmluZ2lmeShqQ2FsKSB7XG4gICAgaWYgKHR5cGVvZiBqQ2FsWzBdID09IFwic3RyaW5nXCIpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBzaW5nbGUgY29tcG9uZW50XG4gICAgICBqQ2FsID0gW2pDYWxdO1xuICAgIH1cblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gakNhbC5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgcmVzdWx0ICs9IHN0cmluZ2lmeS5jb21wb25lbnQoakNhbFtpXSkgKyBMSU5FX0VORElORztcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGFuIGpDYWwgY29tcG9uZW50IGFycmF5IGludG8gYSBJQ0FMIHN0cmluZy5cbiAgICogUmVjdXJzaXZlIHdpbGwgcmVzb2x2ZSBzdWItY29tcG9uZW50cy5cbiAgICpcbiAgICogRXhhY3QgY29tcG9uZW50L3Byb3BlcnR5IG9yZGVyIGlzIG5vdCBzYXZlZCBhbGxcbiAgICogcHJvcGVydGllcyB3aWxsIGNvbWUgYmVmb3JlIHN1YmNvbXBvbmVudHMuXG4gICAqXG4gICAqIEBmdW5jdGlvbiBJQ0FMLnN0cmluZ2lmeS5jb21wb25lbnRcbiAgICogQHBhcmFtIHtBcnJheX0gY29tcG9uZW50XG4gICAqICAgICAgICBqQ2FsL2pDYXJkIGZyYWdtZW50IG9mIGEgY29tcG9uZW50XG4gICAqIEBwYXJhbSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fSBkZXNpZ25TZXRcbiAgICogICAgICAgIFRoZSBkZXNpZ24gZGF0YSB0byB1c2UgZm9yIHRoaXMgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgVGhlIGlDYWxlbmRhci92Q2FyZCBzdHJpbmdcbiAgICovXG4gIHN0cmluZ2lmeS5jb21wb25lbnQgPSBmdW5jdGlvbihjb21wb25lbnQsIGRlc2lnblNldCkge1xuICAgIHZhciBuYW1lID0gY29tcG9uZW50WzBdLnRvVXBwZXJDYXNlKCk7XG4gICAgdmFyIHJlc3VsdCA9ICdCRUdJTjonICsgbmFtZSArIExJTkVfRU5ESU5HO1xuXG4gICAgdmFyIHByb3BzID0gY29tcG9uZW50WzFdO1xuICAgIHZhciBwcm9wSWR4ID0gMDtcbiAgICB2YXIgcHJvcExlbiA9IHByb3BzLmxlbmd0aDtcblxuICAgIHZhciBkZXNpZ25TZXROYW1lID0gY29tcG9uZW50WzBdO1xuICAgIC8vIHJmYzYzNTAgcmVxdWlyZXMgdGhhdCBpbiB2Q2FyZCA0LjAgdGhlIGZpcnN0IGNvbXBvbmVudCBpcyB0aGUgVkVSU0lPTlxuICAgIC8vIGNvbXBvbmVudCB3aXRoIGFzIHZhbHVlIDQuMCwgbm90ZSB0aGF0IDMuMCBkb2VzIG5vdCBoYXZlIHRoaXMgcmVxdWlyZW1lbnQuXG4gICAgaWYgKGRlc2lnblNldE5hbWUgPT09ICd2Y2FyZCcgJiYgY29tcG9uZW50WzFdLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICEoY29tcG9uZW50WzFdWzBdWzBdID09PSBcInZlcnNpb25cIiAmJiBjb21wb25lbnRbMV1bMF1bM10gPT09IFwiNC4wXCIpKSB7XG4gICAgICBkZXNpZ25TZXROYW1lID0gXCJ2Y2FyZDNcIjtcbiAgICB9XG4gICAgZGVzaWduU2V0ID0gZGVzaWduU2V0IHx8IGRlc2lnbi5nZXREZXNpZ25TZXQoZGVzaWduU2V0TmFtZSk7XG5cbiAgICBmb3IgKDsgcHJvcElkeCA8IHByb3BMZW47IHByb3BJZHgrKykge1xuICAgICAgcmVzdWx0ICs9IHN0cmluZ2lmeS5wcm9wZXJ0eShwcm9wc1twcm9wSWR4XSwgZGVzaWduU2V0KSArIExJTkVfRU5ESU5HO1xuICAgIH1cblxuICAgIC8vIElnbm9yZSBzdWJjb21wb25lbnRzIGlmIG5vbmUgZXhpc3QsIGUuZy4gaW4gdkNhcmQuXG4gICAgdmFyIGNvbXBzID0gY29tcG9uZW50WzJdIHx8IFtdO1xuICAgIHZhciBjb21wSWR4ID0gMDtcbiAgICB2YXIgY29tcExlbiA9IGNvbXBzLmxlbmd0aDtcblxuICAgIGZvciAoOyBjb21wSWR4IDwgY29tcExlbjsgY29tcElkeCsrKSB7XG4gICAgICByZXN1bHQgKz0gc3RyaW5naWZ5LmNvbXBvbmVudChjb21wc1tjb21wSWR4XSwgZGVzaWduU2V0KSArIExJTkVfRU5ESU5HO1xuICAgIH1cblxuICAgIHJlc3VsdCArPSAnRU5EOicgKyBuYW1lO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgc2luZ2xlIGpDYWwvakNhcmQgcHJvcGVydHkgdG8gYSBpQ2FsZW5kYXIvdkNhcmQgc3RyaW5nLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gSUNBTC5zdHJpbmdpZnkucHJvcGVydHlcbiAgICogQHBhcmFtIHtBcnJheX0gcHJvcGVydHlcbiAgICogICAgICAgIGpDYWwvakNhcmQgcHJvcGVydHkgYXJyYXlcbiAgICogQHBhcmFtIHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9IGRlc2lnblNldFxuICAgKiAgICAgICAgVGhlIGRlc2lnbiBkYXRhIHRvIHVzZSBmb3IgdGhpcyBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG5vRm9sZFxuICAgKiAgICAgICAgSWYgdHJ1ZSwgdGhlIGxpbmUgaXMgbm90IGZvbGRlZFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgIFRoZSBpQ2FsZW5kYXIvdkNhcmQgc3RyaW5nXG4gICAqL1xuICBzdHJpbmdpZnkucHJvcGVydHkgPSBmdW5jdGlvbihwcm9wZXJ0eSwgZGVzaWduU2V0LCBub0ZvbGQpIHtcbiAgICB2YXIgbmFtZSA9IHByb3BlcnR5WzBdLnRvVXBwZXJDYXNlKCk7XG4gICAgdmFyIGpzTmFtZSA9IHByb3BlcnR5WzBdO1xuICAgIHZhciBwYXJhbXMgPSBwcm9wZXJ0eVsxXTtcblxuICAgIHZhciBsaW5lID0gbmFtZTtcblxuICAgIHZhciBwYXJhbU5hbWU7XG4gICAgZm9yIChwYXJhbU5hbWUgaW4gcGFyYW1zKSB7XG4gICAgICB2YXIgdmFsdWUgPSBwYXJhbXNbcGFyYW1OYW1lXTtcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChwYXJhbXMuaGFzT3duUHJvcGVydHkocGFyYW1OYW1lKSkge1xuICAgICAgICB2YXIgbXVsdGlWYWx1ZSA9IChwYXJhbU5hbWUgaW4gZGVzaWduU2V0LnBhcmFtKSAmJiBkZXNpZ25TZXQucGFyYW1bcGFyYW1OYW1lXS5tdWx0aVZhbHVlO1xuICAgICAgICBpZiAobXVsdGlWYWx1ZSAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIGlmIChkZXNpZ25TZXQucGFyYW1bcGFyYW1OYW1lXS5tdWx0aVZhbHVlU2VwYXJhdGVEUXVvdGUpIHtcbiAgICAgICAgICAgIG11bHRpVmFsdWUgPSAnXCInICsgbXVsdGlWYWx1ZSArICdcIic7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbHVlID0gdmFsdWUubWFwKHN0cmluZ2lmeS5fcmZjNjg2OFVuZXNjYXBlKTtcbiAgICAgICAgICB2YWx1ZSA9IHN0cmluZ2lmeS5tdWx0aVZhbHVlKHZhbHVlLCBtdWx0aVZhbHVlLCBcInVua25vd25cIiwgbnVsbCwgZGVzaWduU2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IHN0cmluZ2lmeS5fcmZjNjg2OFVuZXNjYXBlKHZhbHVlKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgbGluZSArPSAnOycgKyBwYXJhbU5hbWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgbGluZSArPSAnPScgKyBzdHJpbmdpZnkucHJvcGVydHlWYWx1ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByb3BlcnR5Lmxlbmd0aCA9PT0gMykge1xuICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIHZhbHVlcywgd2UgbXVzdCBhc3N1bWUgYSBibGFuayB2YWx1ZVxuICAgICAgcmV0dXJuIGxpbmUgKyAnOic7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlVHlwZSA9IHByb3BlcnR5WzJdO1xuXG4gICAgaWYgKCFkZXNpZ25TZXQpIHtcbiAgICAgIGRlc2lnblNldCA9IGRlc2lnbi5kZWZhdWx0U2V0O1xuICAgIH1cblxuICAgIHZhciBwcm9wRGV0YWlscztcbiAgICB2YXIgbXVsdGlWYWx1ZSA9IGZhbHNlO1xuICAgIHZhciBzdHJ1Y3R1cmVkVmFsdWUgPSBmYWxzZTtcbiAgICB2YXIgaXNEZWZhdWx0ID0gZmFsc2U7XG5cbiAgICBpZiAoanNOYW1lIGluIGRlc2lnblNldC5wcm9wZXJ0eSkge1xuICAgICAgcHJvcERldGFpbHMgPSBkZXNpZ25TZXQucHJvcGVydHlbanNOYW1lXTtcblxuICAgICAgaWYgKCdtdWx0aVZhbHVlJyBpbiBwcm9wRGV0YWlscykge1xuICAgICAgICBtdWx0aVZhbHVlID0gcHJvcERldGFpbHMubXVsdGlWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCgnc3RydWN0dXJlZFZhbHVlJyBpbiBwcm9wRGV0YWlscykgJiYgQXJyYXkuaXNBcnJheShwcm9wZXJ0eVszXSkpIHtcbiAgICAgICAgc3RydWN0dXJlZFZhbHVlID0gcHJvcERldGFpbHMuc3RydWN0dXJlZFZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoJ2RlZmF1bHRUeXBlJyBpbiBwcm9wRGV0YWlscykge1xuICAgICAgICBpZiAodmFsdWVUeXBlID09PSBwcm9wRGV0YWlscy5kZWZhdWx0VHlwZSkge1xuICAgICAgICAgIGlzRGVmYXVsdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh2YWx1ZVR5cGUgPT09IERFRkFVTFRfVkFMVUVfVFlQRSkge1xuICAgICAgICAgIGlzRGVmYXVsdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHZhbHVlVHlwZSA9PT0gREVGQVVMVF9WQUxVRV9UWVBFKSB7XG4gICAgICAgIGlzRGVmYXVsdCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcHVzaCB0aGUgVkFMVUUgcHJvcGVydHkgaWYgdHlwZSBpcyBub3QgdGhlIGRlZmF1bHRcbiAgICAvLyBmb3IgdGhlIGN1cnJlbnQgcHJvcGVydHkuXG4gICAgaWYgKCFpc0RlZmF1bHQpIHtcbiAgICAgIC8vIHZhbHVlIHdpbGwgbmV2ZXIgY29udGFpbiA7LzovLCBzbyB3ZSBkb24ndCBlc2NhcGUgaXQgaGVyZS5cbiAgICAgIGxpbmUgKz0gJztWQUxVRT0nICsgdmFsdWVUeXBlLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgbGluZSArPSAnOic7XG5cbiAgICBpZiAobXVsdGlWYWx1ZSAmJiBzdHJ1Y3R1cmVkVmFsdWUpIHtcbiAgICAgIGxpbmUgKz0gc3RyaW5naWZ5Lm11bHRpVmFsdWUoXG4gICAgICAgIHByb3BlcnR5WzNdLCBzdHJ1Y3R1cmVkVmFsdWUsIHZhbHVlVHlwZSwgbXVsdGlWYWx1ZSwgZGVzaWduU2V0LCBzdHJ1Y3R1cmVkVmFsdWVcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChtdWx0aVZhbHVlKSB7XG4gICAgICBsaW5lICs9IHN0cmluZ2lmeS5tdWx0aVZhbHVlKFxuICAgICAgICBwcm9wZXJ0eS5zbGljZSgzKSwgbXVsdGlWYWx1ZSwgdmFsdWVUeXBlLCBudWxsLCBkZXNpZ25TZXQsIGZhbHNlXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoc3RydWN0dXJlZFZhbHVlKSB7XG4gICAgICBsaW5lICs9IHN0cmluZ2lmeS5tdWx0aVZhbHVlKFxuICAgICAgICBwcm9wZXJ0eVszXSwgc3RydWN0dXJlZFZhbHVlLCB2YWx1ZVR5cGUsIG51bGwsIGRlc2lnblNldCwgc3RydWN0dXJlZFZhbHVlXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lICs9IHN0cmluZ2lmeS52YWx1ZShwcm9wZXJ0eVszXSwgdmFsdWVUeXBlLCBkZXNpZ25TZXQsIGZhbHNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9Gb2xkID8gbGluZSA6IElDQUwuaGVscGVycy5mb2xkbGluZShsaW5lKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlcyBlc2NhcGluZyBvZiBwcm9wZXJ0eSB2YWx1ZXMgdGhhdCBtYXkgY29udGFpbjpcbiAgICpcbiAgICogICAgQ09MT04gKDopLCBTRU1JQ09MT04gKDspLCBvciBDT01NQSAoLClcbiAgICpcbiAgICogSWYgYW55IG9mIHRoZSBhYm92ZSBhcmUgcHJlc2VudCB0aGUgcmVzdWx0IGlzIHdyYXBwZWRcbiAgICogaW4gZG91YmxlIHF1b3Rlcy5cbiAgICpcbiAgICogQGZ1bmN0aW9uIElDQUwuc3RyaW5naWZ5LnByb3BlcnR5VmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlICAgICAgUmF3IHByb3BlcnR5IHZhbHVlXG4gICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgIEdpdmVuIG9yIGVzY2FwZWQgdmFsdWUgd2hlbiBuZWVkZWRcbiAgICovXG4gIHN0cmluZ2lmeS5wcm9wZXJ0eVZhbHVlID0gZnVuY3Rpb24odmFsdWUpIHtcblxuICAgIGlmICgoaGVscGVycy51bmVzY2FwZWRJbmRleE9mKHZhbHVlLCAnLCcpID09PSAtMSkgJiZcbiAgICAgICAgKGhlbHBlcnMudW5lc2NhcGVkSW5kZXhPZih2YWx1ZSwgJzonKSA9PT0gLTEpICYmXG4gICAgICAgIChoZWxwZXJzLnVuZXNjYXBlZEluZGV4T2YodmFsdWUsICc7JykgPT09IC0xKSkge1xuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuICdcIicgKyB2YWx1ZSArICdcIic7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGFuIGFycmF5IG9mIGljYWwgdmFsdWVzIGludG8gYSBzaW5nbGVcbiAgICogc3RyaW5nIGJhc2VkIG9uIGEgdHlwZSBhbmQgYSBkZWxpbWl0ZXIgdmFsdWUgKGxpa2UgXCIsXCIpLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gSUNBTC5zdHJpbmdpZnkubXVsdGlWYWx1ZVxuICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgICAgICBMaXN0IG9mIHZhbHVlcyB0byBjb252ZXJ0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkZWxpbSAgICAgIFVzZWQgdG8gam9pbiB0aGUgdmFsdWVzIChcIixcIiwgXCI7XCIsIFwiOlwiKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAgICAgICBMb3dlY2FzZSBpY2FsIHZhbHVlIHR5cGVcbiAgICogICAgICAgIChsaWtlIGJvb2xlYW4sIGRhdGUtdGltZSwgZXRjLi4pXG4gICAqIEBwYXJhbSB7P1N0cmluZ30gaW5uZXJNdWx0aSBJZiBzZXQsIGVhY2ggdmFsdWUgd2lsbCBhZ2FpbiBiZSBwcm9jZXNzZWRcbiAgICogICAgICAgIFVzZWQgZm9yIHN0cnVjdHVyZWQgdmFsdWVzXG4gICAqIEBwYXJhbSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fSBkZXNpZ25TZXRcbiAgICogICAgICAgIFRoZSBkZXNpZ24gZGF0YSB0byB1c2UgZm9yIHRoaXMgcHJvcGVydHlcbiAgICpcbiAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICAgaUNhbGVuZGFyL3ZDYXJkIHN0cmluZyBmb3IgdmFsdWVcbiAgICovXG4gIHN0cmluZ2lmeS5tdWx0aVZhbHVlID0gZnVuY3Rpb24odmFsdWVzLCBkZWxpbSwgdHlwZSwgaW5uZXJNdWx0aSwgZGVzaWduU2V0LCBzdHJ1Y3R1cmVkVmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGxlbiA9IHZhbHVlcy5sZW5ndGg7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGlubmVyTXVsdGkgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZXNbaV0pKSB7XG4gICAgICAgIHJlc3VsdCArPSBzdHJpbmdpZnkubXVsdGlWYWx1ZSh2YWx1ZXNbaV0sIGlubmVyTXVsdGksIHR5cGUsIG51bGwsIGRlc2lnblNldCwgc3RydWN0dXJlZFZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCArPSBzdHJpbmdpZnkudmFsdWUodmFsdWVzW2ldLCB0eXBlLCBkZXNpZ25TZXQsIHN0cnVjdHVyZWRWYWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpICE9PSAobGVuIC0gMSkpIHtcbiAgICAgICAgcmVzdWx0ICs9IGRlbGltO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb2Nlc3NlcyBhIHNpbmdsZSBpY2FsIHZhbHVlIHJ1bnMgdGhlIGFzc29jaWF0ZWQgXCJ0b0lDQUxcIiBtZXRob2QgZnJvbSB0aGVcbiAgICogZGVzaWduIHZhbHVlIHR5cGUgaWYgYXZhaWxhYmxlIHRvIGNvbnZlcnQgdGhlIHZhbHVlLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gSUNBTC5zdHJpbmdpZnkudmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWx1ZSAgICAgICBBIGZvcm1hdHRlZCB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAgICAgICAgICAgICAgIExvd2VyY2FzZSBpQ2FsZW5kYXIvdkNhcmQgdmFsdWUgdHlwZVxuICAgKiAgKGxpa2UgYm9vbGVhbiwgZGF0ZS10aW1lLCBldGMuLilcbiAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICAgICAgICAgICBpQ2FsZW5kYXIvdkNhcmQgdmFsdWUgZm9yIHNpbmdsZSB2YWx1ZVxuICAgKi9cbiAgc3RyaW5naWZ5LnZhbHVlID0gZnVuY3Rpb24odmFsdWUsIHR5cGUsIGRlc2lnblNldCwgc3RydWN0dXJlZFZhbHVlKSB7XG4gICAgaWYgKHR5cGUgaW4gZGVzaWduU2V0LnZhbHVlICYmICd0b0lDQUwnIGluIGRlc2lnblNldC52YWx1ZVt0eXBlXSkge1xuICAgICAgcmV0dXJuIGRlc2lnblNldC52YWx1ZVt0eXBlXS50b0lDQUwodmFsdWUsIHN0cnVjdHVyZWRWYWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICAvKipcbiAgICogSW50ZXJuYWwgaGVscGVyIGZvciByZmM2ODY4LiBFeHBvc2luZyB0aGlzIG9uIElDQUwuc3RyaW5naWZ5IHNvIHRoYXRcbiAgICogaGFja2VycyBjYW4gZGlzYWJsZSB0aGUgcmZjNjg2OCBwYXJzaW5nIGlmIHRoZSByZWFsbHkgbmVlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHZhbCAgICAgICAgVGhlIHZhbHVlIHRvIHVuZXNjYXBlXG4gICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgIFRoZSBlc2NhcGVkIHZhbHVlXG4gICAqL1xuICBzdHJpbmdpZnkuX3JmYzY4NjhVbmVzY2FwZSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgIHJldHVybiB2YWwucmVwbGFjZSgvW1xcbl5cIl0vZywgZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIFJGQzY4NjhfUkVQTEFDRV9NQVBbeF07XG4gICAgfSk7XG4gIH07XG4gIHZhciBSRkM2ODY4X1JFUExBQ0VfTUFQID0geyAnXCInOiBcIl4nXCIsIFwiXFxuXCI6IFwiXm5cIiwgXCJeXCI6IFwiXl5cIiB9O1xuXG4gIHJldHVybiBzdHJpbmdpZnk7XG59KCkpO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoLCAyMDExLTIwMTUgKi9cblxuXG4vKipcbiAqIENvbnRhaW5zIHZhcmlvdXMgZnVuY3Rpb25zIHRvIHBhcnNlIGlDYWxlbmRhciBhbmQgdkNhcmQgZGF0YS5cbiAqIEBuYW1lc3BhY2VcbiAqL1xuSUNBTC5wYXJzZSA9IChmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBDSEFSID0gL1teIFxcdF0vO1xuICB2YXIgTVVMVElWQUxVRV9ERUxJTUlURVIgPSAnLCc7XG4gIHZhciBWQUxVRV9ERUxJTUlURVIgPSAnOic7XG4gIHZhciBQQVJBTV9ERUxJTUlURVIgPSAnOyc7XG4gIHZhciBQQVJBTV9OQU1FX0RFTElNSVRFUiA9ICc9JztcbiAgdmFyIERFRkFVTFRfVkFMVUVfVFlQRSA9ICd1bmtub3duJztcbiAgdmFyIERFRkFVTFRfUEFSQU1fVFlQRSA9ICd0ZXh0JztcblxuICB2YXIgZGVzaWduID0gSUNBTC5kZXNpZ247XG4gIHZhciBoZWxwZXJzID0gSUNBTC5oZWxwZXJzO1xuXG4gIC8qKlxuICAgKiBBbiBlcnJvciB0aGF0IG9jY3VycmVkIGR1cmluZyBwYXJzaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSAgICAgICAgVGhlIGVycm9yIG1lc3NhZ2VcbiAgICogQG1lbWJlcm9mIElDQUwucGFyc2VcbiAgICogQGV4dGVuZHMge0Vycm9yfVxuICAgKiBAY2xhc3NcbiAgICovXG4gIGZ1bmN0aW9uIFBhcnNlckVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMubmFtZSA9ICdQYXJzZXJFcnJvcic7XG5cbiAgICB0cnkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUuc3RhY2spIHtcbiAgICAgICAgdmFyIHNwbGl0ID0gZS5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICAgIHNwbGl0LnNoaWZ0KCk7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBzcGxpdC5qb2luKCdcXG4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBQYXJzZXJFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBpQ2FsZW5kYXIgb3IgdkNhcmQgZGF0YSBpbnRvIGEgcmF3IGpDYWwgb2JqZWN0LiBDb25zdWx0XG4gICAqIGRvY3VtZW50YXRpb24gb24gdGhlIHtAdHV0b3JpYWwgbGF5ZXJzfGxheWVycyBvZiBwYXJzaW5nfSBmb3IgbW9yZVxuICAgKiBkZXRhaWxzLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gSUNBTC5wYXJzZVxuICAgKiBAdmFyaWF0aW9uIGZ1bmN0aW9uXG4gICAqIEB0b2RvIEZpeCB0aGUgQVBJIHRvIGJlIG1vcmUgY2xlYXIgb24gdGhlIHJldHVybiB0eXBlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCAgICAgIFRoZSBzdHJpbmcgZGF0YSB0byBwYXJzZVxuICAgKiBAcmV0dXJuIHtPYmplY3R8T2JqZWN0W119ICBBIHNpbmdsZSBqQ2FsIG9iamVjdCwgb3IgYW4gYXJyYXkgdGhlcmVvZlxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VyKGlucHV0KSB7XG4gICAgdmFyIHN0YXRlID0ge307XG4gICAgdmFyIHJvb3QgPSBzdGF0ZS5jb21wb25lbnQgPSBbXTtcblxuICAgIHN0YXRlLnN0YWNrID0gW3Jvb3RdO1xuXG4gICAgcGFyc2VyLl9lYWNoTGluZShpbnB1dCwgZnVuY3Rpb24oZXJyLCBsaW5lKSB7XG4gICAgICBwYXJzZXIuX2hhbmRsZUNvbnRlbnRMaW5lKGxpbmUsIHN0YXRlKTtcbiAgICB9KTtcblxuXG4gICAgLy8gd2hlbiB0aGVyZSBhcmUgc3RpbGwgaXRlbXMgb24gdGhlIHN0YWNrXG4gICAgLy8gdGhyb3cgYSBmYXRhbCBlcnJvciwgYSBjb21wb25lbnQgd2FzIG5vdCBjbG9zZWRcbiAgICAvLyBjb3JyZWN0bHkgaW4gdGhhdCBjYXNlLlxuICAgIGlmIChzdGF0ZS5zdGFjay5sZW5ndGggPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VyRXJyb3IoXG4gICAgICAgICdpbnZhbGlkIGljYWwgYm9keS4gY29tcG9uZW50IGJlZ2FuIGJ1dCBkaWQgbm90IGVuZCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgc3RhdGUgPSBudWxsO1xuXG4gICAgcmV0dXJuIChyb290Lmxlbmd0aCA9PSAxID8gcm9vdFswXSA6IHJvb3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGFuIGlDYWxlbmRhciBwcm9wZXJ0eSB2YWx1ZSBpbnRvIHRoZSBqQ2FsIGZvciBhIHNpbmdsZSBwcm9wZXJ0eVxuICAgKlxuICAgKiBAZnVuY3Rpb24gSUNBTC5wYXJzZS5wcm9wZXJ0eVxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gICAqICAgVGhlIGlDYWxlbmRhciBwcm9wZXJ0eSBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXQ9fSBkZXNpZ25TZXRcbiAgICogICBUaGUgZGVzaWduIGRhdGEgdG8gdXNlIGZvciB0aGlzIHByb3BlcnR5XG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogICBUaGUgakNhbCBPYmplY3QgY29udGFpbmluZyB0aGUgcHJvcGVydHlcbiAgICovXG4gIHBhcnNlci5wcm9wZXJ0eSA9IGZ1bmN0aW9uKHN0ciwgZGVzaWduU2V0KSB7XG4gICAgdmFyIHN0YXRlID0ge1xuICAgICAgY29tcG9uZW50OiBbW10sIFtdXSxcbiAgICAgIGRlc2lnblNldDogZGVzaWduU2V0IHx8IGRlc2lnbi5kZWZhdWx0U2V0XG4gICAgfTtcbiAgICBwYXJzZXIuX2hhbmRsZUNvbnRlbnRMaW5lKHN0ciwgc3RhdGUpO1xuICAgIHJldHVybiBzdGF0ZS5jb21wb25lbnRbMV1bMF07XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlbmllbmNlIG1ldGhvZCB0byBwYXJzZSBhIGNvbXBvbmVudC4gWW91IGNhbiB1c2UgSUNBTC5wYXJzZSgpIGRpcmVjdGx5XG4gICAqIGluc3RlYWQuXG4gICAqXG4gICAqIEBmdW5jdGlvbiBJQ0FMLnBhcnNlLmNvbXBvbmVudFxuICAgKiBAc2VlIElDQUwucGFyc2UoZnVuY3Rpb24pXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgICAgVGhlIGlDYWxlbmRhciBjb21wb25lbnQgc3RyaW5nIHRvIHBhcnNlXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgVGhlIGpDYWwgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNvbXBvbmVudFxuICAgKi9cbiAgcGFyc2VyLmNvbXBvbmVudCA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBwYXJzZXIoc3RyKTtcbiAgfTtcblxuICAvLyBjbGFzc2VzICYgY29uc3RhbnRzXG4gIHBhcnNlci5QYXJzZXJFcnJvciA9IFBhcnNlckVycm9yO1xuXG4gIC8qKlxuICAgKiBUaGUgc3RhdGUgZm9yIHBhcnNpbmcgY29udGVudCBsaW5lcyBmcm9tIGFuIGlDYWxlbmRhci92Q2FyZCBzdHJpbmcuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBtZW1iZXJvZiBJQ0FMLnBhcnNlXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IHBhcnNlclN0YXRlXG4gICAqIEBwcm9wZXJ0eSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fSBkZXNpZ25TZXQgICAgVGhlIGRlc2lnbiBzZXQgdG8gdXNlIGZvciBwYXJzaW5nXG4gICAqIEBwcm9wZXJ0eSB7SUNBTC5Db21wb25lbnRbXX0gc3RhY2sgICAgICAgICAgICAgVGhlIHN0YWNrIG9mIGNvbXBvbmVudHMgYmVpbmcgcHJvY2Vzc2VkXG4gICAqIEBwcm9wZXJ0eSB7SUNBTC5Db21wb25lbnR9IGNvbXBvbmVudCAgICAgICAgICAgVGhlIGN1cnJlbnRseSBhY3RpdmUgY29tcG9uZW50XG4gICAqL1xuXG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYSBzaW5nbGUgbGluZSBvZiBpQ2FsZW5kYXIvdkNhcmQsIHVwZGF0aW5nIHRoZSBzdGF0ZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGZ1bmN0aW9uIElDQUwucGFyc2UuX2hhbmRsZUNvbnRlbnRMaW5lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBsaW5lICAgICAgICAgICAgICAgVGhlIGNvbnRlbnQgbGluZSB0byBwcm9jZXNzXG4gICAqIEBwYXJhbSB7SUNBTC5wYXJzZS5wYXJzZXJTdGF0ZX0gICAgVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGxpbmUgcGFyc2luZ1xuICAgKi9cbiAgcGFyc2VyLl9oYW5kbGVDb250ZW50TGluZSA9IGZ1bmN0aW9uKGxpbmUsIHN0YXRlKSB7XG4gICAgLy8gYnJlYWsgdXAgdGhlIHBhcnRzIG9mIHRoZSBsaW5lXG4gICAgdmFyIHZhbHVlUG9zID0gbGluZS5pbmRleE9mKFZBTFVFX0RFTElNSVRFUik7XG4gICAgdmFyIHBhcmFtUG9zID0gbGluZS5pbmRleE9mKFBBUkFNX0RFTElNSVRFUik7XG5cbiAgICB2YXIgbGFzdFBhcmFtSW5kZXg7XG4gICAgdmFyIGxhc3RWYWx1ZVBvcztcblxuICAgIC8vIG5hbWUgb2YgcHJvcGVydHkgb3IgYmVnaW4vZW5kXG4gICAgdmFyIG5hbWU7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIHBhcmFtcyBpcyBvbmx5IG92ZXJyaWRkZW4gaWYgcGFyYW1Qb3MgIT09IC0xLlxuICAgIC8vIHdlIGNhbid0IGRvIHBhcmFtcyA9IHBhcmFtcyB8fCB7fSBsYXRlciBvblxuICAgIC8vIGJlY2F1c2UgaXQgc2FjcmlmaWNlcyBvcHMuXG4gICAgdmFyIHBhcmFtcyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogRGlmZmVyZW50IHByb3BlcnR5IGNhc2VzXG4gICAgICpcbiAgICAgKlxuICAgICAqIDEuIFJSVUxFOkZSRVE9Zm9vXG4gICAgICogICAgLy8gRlJFUT0gaXMgbm90IGEgcGFyYW0gYnV0IHRoZSB2YWx1ZVxuICAgICAqXG4gICAgICogMi4gQVRURU5ERUU7Uk9MRT1SRVEtUEFSVElDSVBBTlQ7XG4gICAgICogICAgLy8gUk9MRT0gaXMgYSBwYXJhbSBiZWNhdXNlIDogaGFzIG5vdCBoYXBwZW5lZCB5ZXRcbiAgICAgKi9cbiAgICAgIC8vIHdoZW4gdGhlIHBhcmFtZXRlciBkZWxpbWl0ZXIgaXMgYWZ0ZXIgdGhlXG4gICAgICAvLyB2YWx1ZSBkZWxpbWl0ZXIgdGhlbiBpdCBpcyBub3QgYSBwYXJhbWV0ZXIuXG5cbiAgICBpZiAoKHBhcmFtUG9zICE9PSAtMSAmJiB2YWx1ZVBvcyAhPT0gLTEpKSB7XG4gICAgICAvLyB3aGVuIHRoZSBwYXJhbWV0ZXIgZGVsaW1pdGVyIGlzIGFmdGVyIHRoZVxuICAgICAgLy8gdmFsdWUgZGVsaW1pdGVyIHRoZW4gaXQgaXMgbm90IGEgcGFyYW1ldGVyLlxuICAgICAgaWYgKHBhcmFtUG9zID4gdmFsdWVQb3MpIHtcbiAgICAgICAgcGFyYW1Qb3MgPSAtMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcGFyc2VkUGFyYW1zO1xuICAgIGlmIChwYXJhbVBvcyAhPT0gLTEpIHtcbiAgICAgIG5hbWUgPSBsaW5lLnN1YnN0cmluZygwLCBwYXJhbVBvcykudG9Mb3dlckNhc2UoKTtcbiAgICAgIHBhcnNlZFBhcmFtcyA9IHBhcnNlci5fcGFyc2VQYXJhbWV0ZXJzKGxpbmUuc3Vic3RyaW5nKHBhcmFtUG9zKSwgMCwgc3RhdGUuZGVzaWduU2V0KTtcbiAgICAgIGlmIChwYXJzZWRQYXJhbXNbMl0gPT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlckVycm9yKFwiSW52YWxpZCBwYXJhbWV0ZXJzIGluICdcIiArIGxpbmUgKyBcIidcIik7XG4gICAgICB9XG4gICAgICBwYXJhbXMgPSBwYXJzZWRQYXJhbXNbMF07XG4gICAgICBsYXN0UGFyYW1JbmRleCA9IHBhcnNlZFBhcmFtc1sxXS5sZW5ndGggKyBwYXJzZWRQYXJhbXNbMl0gKyBwYXJhbVBvcztcbiAgICAgIGlmICgobGFzdFZhbHVlUG9zID1cbiAgICAgICAgbGluZS5zdWJzdHJpbmcobGFzdFBhcmFtSW5kZXgpLmluZGV4T2YoVkFMVUVfREVMSU1JVEVSKSkgIT09IC0xKSB7XG4gICAgICAgIHZhbHVlID0gbGluZS5zdWJzdHJpbmcobGFzdFBhcmFtSW5kZXggKyBsYXN0VmFsdWVQb3MgKyAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZXJFcnJvcihcIk1pc3NpbmcgcGFyYW1ldGVyIHZhbHVlIGluICdcIiArIGxpbmUgKyBcIidcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh2YWx1ZVBvcyAhPT0gLTEpIHtcbiAgICAgIC8vIHdpdGhvdXQgcGFybWV0ZXJzIChCRUdJTjpWQ0FFTkRBUiwgQ0xBU1M6UFVCTElDKVxuICAgICAgbmFtZSA9IGxpbmUuc3Vic3RyaW5nKDAsIHZhbHVlUG9zKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFsdWUgPSBsaW5lLnN1YnN0cmluZyh2YWx1ZVBvcyArIDEpO1xuXG4gICAgICBpZiAobmFtZSA9PT0gJ2JlZ2luJykge1xuICAgICAgICB2YXIgbmV3Q29tcG9uZW50ID0gW3ZhbHVlLnRvTG93ZXJDYXNlKCksIFtdLCBbXV07XG4gICAgICAgIGlmIChzdGF0ZS5zdGFjay5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBzdGF0ZS5jb21wb25lbnQucHVzaChuZXdDb21wb25lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLmNvbXBvbmVudFsyXS5wdXNoKG5ld0NvbXBvbmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuc3RhY2sucHVzaChzdGF0ZS5jb21wb25lbnQpO1xuICAgICAgICBzdGF0ZS5jb21wb25lbnQgPSBuZXdDb21wb25lbnQ7XG4gICAgICAgIGlmICghc3RhdGUuZGVzaWduU2V0KSB7XG4gICAgICAgICAgc3RhdGUuZGVzaWduU2V0ID0gZGVzaWduLmdldERlc2lnblNldChzdGF0ZS5jb21wb25lbnRbMF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2VuZCcpIHtcbiAgICAgICAgc3RhdGUuY29tcG9uZW50ID0gc3RhdGUuc3RhY2sucG9wKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIElmIGl0IGlzIG5vdCBiZWdpbi9lbmQsIHRoZW4gdGhpcyBpcyBhIHByb3BlcnR5IHdpdGggYW4gZW1wdHkgdmFsdWUsXG4gICAgICAvLyB3aGljaCBzaG91bGQgYmUgY29uc2lkZXJlZCB2YWxpZC5cbiAgICB9IGVsc2Uge1xuICAgICAgLyoqXG4gICAgICAgKiBJbnZhbGlkIGxpbmUuXG4gICAgICAgKiBUaGUgcmF0aW9uYWwgdG8gdGhyb3cgYW4gZXJyb3IgaXMgd2Ugd2lsbFxuICAgICAgICogbmV2ZXIgYmUgY2VydGFpbiB0aGF0IHRoZSByZXN0IG9mIHRoZSBmaWxlXG4gICAgICAgKiBpcyBzYW5lIGFuZCBpdCBpcyB1bmxpa2VseSB0aGF0IHdlIGNhbiBzZXJpYWxpemVcbiAgICAgICAqIHRoZSByZXN1bHQgY29ycmVjdGx5IGVpdGhlci5cbiAgICAgICAqL1xuICAgICAgdGhyb3cgbmV3IFBhcnNlckVycm9yKFxuICAgICAgICAnaW52YWxpZCBsaW5lIChubyB0b2tlbiBcIjtcIiBvciBcIjpcIikgXCInICsgbGluZSArICdcIidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlVHlwZTtcbiAgICB2YXIgbXVsdGlWYWx1ZSA9IGZhbHNlO1xuICAgIHZhciBzdHJ1Y3R1cmVkVmFsdWUgPSBmYWxzZTtcbiAgICB2YXIgcHJvcGVydHlEZXRhaWxzO1xuXG4gICAgaWYgKG5hbWUgaW4gc3RhdGUuZGVzaWduU2V0LnByb3BlcnR5KSB7XG4gICAgICBwcm9wZXJ0eURldGFpbHMgPSBzdGF0ZS5kZXNpZ25TZXQucHJvcGVydHlbbmFtZV07XG5cbiAgICAgIGlmICgnbXVsdGlWYWx1ZScgaW4gcHJvcGVydHlEZXRhaWxzKSB7XG4gICAgICAgIG11bHRpVmFsdWUgPSBwcm9wZXJ0eURldGFpbHMubXVsdGlWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCdzdHJ1Y3R1cmVkVmFsdWUnIGluIHByb3BlcnR5RGV0YWlscykge1xuICAgICAgICBzdHJ1Y3R1cmVkVmFsdWUgPSBwcm9wZXJ0eURldGFpbHMuc3RydWN0dXJlZFZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUgJiYgJ2RldGVjdFR5cGUnIGluIHByb3BlcnR5RGV0YWlscykge1xuICAgICAgICB2YWx1ZVR5cGUgPSBwcm9wZXJ0eURldGFpbHMuZGV0ZWN0VHlwZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYXR0ZW1wdCB0byBkZXRlcm1pbmUgdmFsdWVcbiAgICBpZiAoIXZhbHVlVHlwZSkge1xuICAgICAgaWYgKCEoJ3ZhbHVlJyBpbiBwYXJhbXMpKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0eURldGFpbHMpIHtcbiAgICAgICAgICB2YWx1ZVR5cGUgPSBwcm9wZXJ0eURldGFpbHMuZGVmYXVsdFR5cGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWVUeXBlID0gREVGQVVMVF9WQUxVRV9UWVBFO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBwb3NzaWJsZSB0byBhdm9pZCB0aGlzP1xuICAgICAgICB2YWx1ZVR5cGUgPSBwYXJhbXMudmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkZWxldGUgcGFyYW1zLnZhbHVlO1xuXG4gICAgLyoqXG4gICAgICogTm90ZSBvbiBgdmFyIHJlc3VsdGAganVnZ2xpbmc6XG4gICAgICpcbiAgICAgKiBJIG9ic2VydmVkIHRoYXQgYnVpbGRpbmcgdGhlIGFycmF5IGluIHBpZWNlcyBoYXMgYWR2ZXJzZVxuICAgICAqIGVmZmVjdHMgb24gcGVyZm9ybWFuY2UsIHNvIHdoZXJlIHBvc3NpYmxlIHdlIGlubGluZSB0aGUgY3JlYXRpb24uXG4gICAgICogSXQgaXMgYSBsaXR0bGUgdWdseSBidXQgcmVzdWx0ZWQgaW4gfjIwMDAgYWRkaXRpb25hbCBvcHMvc2VjLlxuICAgICAqL1xuXG4gICAgdmFyIHJlc3VsdDtcbiAgICBpZiAobXVsdGlWYWx1ZSAmJiBzdHJ1Y3R1cmVkVmFsdWUpIHtcbiAgICAgIHZhbHVlID0gcGFyc2VyLl9wYXJzZU11bHRpVmFsdWUodmFsdWUsIHN0cnVjdHVyZWRWYWx1ZSwgdmFsdWVUeXBlLCBbXSwgbXVsdGlWYWx1ZSwgc3RhdGUuZGVzaWduU2V0LCBzdHJ1Y3R1cmVkVmFsdWUpO1xuICAgICAgcmVzdWx0ID0gW25hbWUsIHBhcmFtcywgdmFsdWVUeXBlLCB2YWx1ZV07XG4gICAgfSBlbHNlIGlmIChtdWx0aVZhbHVlKSB7XG4gICAgICByZXN1bHQgPSBbbmFtZSwgcGFyYW1zLCB2YWx1ZVR5cGVdO1xuICAgICAgcGFyc2VyLl9wYXJzZU11bHRpVmFsdWUodmFsdWUsIG11bHRpVmFsdWUsIHZhbHVlVHlwZSwgcmVzdWx0LCBudWxsLCBzdGF0ZS5kZXNpZ25TZXQsIGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKHN0cnVjdHVyZWRWYWx1ZSkge1xuICAgICAgdmFsdWUgPSBwYXJzZXIuX3BhcnNlTXVsdGlWYWx1ZSh2YWx1ZSwgc3RydWN0dXJlZFZhbHVlLCB2YWx1ZVR5cGUsIFtdLCBudWxsLCBzdGF0ZS5kZXNpZ25TZXQsIHN0cnVjdHVyZWRWYWx1ZSk7XG4gICAgICByZXN1bHQgPSBbbmFtZSwgcGFyYW1zLCB2YWx1ZVR5cGUsIHZhbHVlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSBwYXJzZXIuX3BhcnNlVmFsdWUodmFsdWUsIHZhbHVlVHlwZSwgc3RhdGUuZGVzaWduU2V0LCBmYWxzZSk7XG4gICAgICByZXN1bHQgPSBbbmFtZSwgcGFyYW1zLCB2YWx1ZVR5cGUsIHZhbHVlXTtcbiAgICB9XG4gICAgLy8gcmZjNjM1MCByZXF1aXJlcyB0aGF0IGluIHZDYXJkIDQuMCB0aGUgZmlyc3QgY29tcG9uZW50IGlzIHRoZSBWRVJTSU9OXG4gICAgLy8gY29tcG9uZW50IHdpdGggYXMgdmFsdWUgNC4wLCBub3RlIHRoYXQgMy4wIGRvZXMgbm90IGhhdmUgdGhpcyByZXF1aXJlbWVudC5cbiAgICBpZiAoc3RhdGUuY29tcG9uZW50WzBdID09PSAndmNhcmQnICYmIHN0YXRlLmNvbXBvbmVudFsxXS5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAgICEobmFtZSA9PT0gJ3ZlcnNpb24nICYmIHZhbHVlID09PSAnNC4wJykpIHtcbiAgICAgIHN0YXRlLmRlc2lnblNldCA9IGRlc2lnbi5nZXREZXNpZ25TZXQoXCJ2Y2FyZDNcIik7XG4gICAgfVxuICAgIHN0YXRlLmNvbXBvbmVudFsxXS5wdXNoKHJlc3VsdCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhcnNlIGEgdmFsdWUgZnJvbSB0aGUgcmF3IHZhbHVlIGludG8gdGhlIGpDYXJkL2pDYWwgdmFsdWUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBmdW5jdGlvbiBJQ0FMLnBhcnNlLl9wYXJzZVZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSAgICAgICAgICBPcmlnaW5hbCB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAgICAgICAgICAgVHlwZSBvZiB2YWx1ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZGVzaWduU2V0ICAgICAgVGhlIGRlc2lnbiBkYXRhIHRvIHVzZSBmb3IgdGhpcyB2YWx1ZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IHZhcmllcyBvbiB0eXBlXG4gICAqL1xuICBwYXJzZXIuX3BhcnNlVmFsdWUgPSBmdW5jdGlvbih2YWx1ZSwgdHlwZSwgZGVzaWduU2V0LCBzdHJ1Y3R1cmVkVmFsdWUpIHtcbiAgICBpZiAodHlwZSBpbiBkZXNpZ25TZXQudmFsdWUgJiYgJ2Zyb21JQ0FMJyBpbiBkZXNpZ25TZXQudmFsdWVbdHlwZV0pIHtcbiAgICAgIHJldHVybiBkZXNpZ25TZXQudmFsdWVbdHlwZV0uZnJvbUlDQUwodmFsdWUsIHN0cnVjdHVyZWRWYWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICAvKipcbiAgICogUGFyc2UgcGFyYW1ldGVycyBmcm9tIGEgc3RyaW5nIHRvIG9iamVjdC5cbiAgICpcbiAgICogQGZ1bmN0aW9uIElDQUwucGFyc2UuX3BhcnNlUGFyYW1ldGVyc1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbGluZSAgICAgICAgICAgQSBzaW5nbGUgdW5mb2xkZWQgbGluZVxuICAgKiBAcGFyYW0ge051bWVyaWN9IHN0YXJ0ICAgICAgICAgUG9zaXRpb24gdG8gc3RhcnQgbG9va2luZyBmb3IgcHJvcGVydGllc1xuICAgKiBAcGFyYW0ge09iamVjdH0gZGVzaWduU2V0ICAgICAgVGhlIGRlc2lnbiBkYXRhIHRvIHVzZSBmb3IgdGhpcyBwcm9wZXJ0eVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGtleS92YWx1ZSBwYWlyc1xuICAgKi9cbiAgcGFyc2VyLl9wYXJzZVBhcmFtZXRlcnMgPSBmdW5jdGlvbihsaW5lLCBzdGFydCwgZGVzaWduU2V0KSB7XG4gICAgdmFyIGxhc3RQYXJhbSA9IHN0YXJ0O1xuICAgIHZhciBwb3MgPSAwO1xuICAgIHZhciBkZWxpbSA9IFBBUkFNX05BTUVfREVMSU1JVEVSO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIgbmFtZSwgbGNuYW1lO1xuICAgIHZhciB2YWx1ZSwgdmFsdWVQb3MgPSAtMTtcbiAgICB2YXIgdHlwZSwgbXVsdGlWYWx1ZSwgbXZkZWxpbTtcblxuICAgIC8vIGZpbmQgdGhlIG5leHQgJz0nIHNpZ25cbiAgICAvLyB1c2UgbGFzdFBhcmFtIGFuZCBwb3MgdG8gZmluZCBuYW1lXG4gICAgLy8gY2hlY2sgaWYgXCIgaXMgdXNlZCBpZiBzbyBnZXQgdmFsdWUgZnJvbSBcIi0+XCJcbiAgICAvLyB0aGVuIGluY3JlbWVudCBwb3MgdG8gZmluZCBuZXh0IDtcblxuICAgIHdoaWxlICgocG9zICE9PSBmYWxzZSkgJiZcbiAgICAgICAgICAgKHBvcyA9IGhlbHBlcnMudW5lc2NhcGVkSW5kZXhPZihsaW5lLCBkZWxpbSwgcG9zICsgMSkpICE9PSAtMSkge1xuXG4gICAgICBuYW1lID0gbGluZS5zdWJzdHIobGFzdFBhcmFtICsgMSwgcG9zIC0gbGFzdFBhcmFtIC0gMSk7XG4gICAgICBpZiAobmFtZS5sZW5ndGggPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VyRXJyb3IoXCJFbXB0eSBwYXJhbWV0ZXIgbmFtZSBpbiAnXCIgKyBsaW5lICsgXCInXCIpO1xuICAgICAgfVxuICAgICAgbGNuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgbXZkZWxpbSA9IGZhbHNlO1xuICAgICAgbXVsdGlWYWx1ZSA9IGZhbHNlO1xuXG4gICAgICBpZiAobGNuYW1lIGluIGRlc2lnblNldC5wYXJhbSAmJiBkZXNpZ25TZXQucGFyYW1bbGNuYW1lXS52YWx1ZVR5cGUpIHtcbiAgICAgICAgdHlwZSA9IGRlc2lnblNldC5wYXJhbVtsY25hbWVdLnZhbHVlVHlwZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGUgPSBERUZBVUxUX1BBUkFNX1RZUEU7XG4gICAgICB9XG5cbiAgICAgIGlmIChsY25hbWUgaW4gZGVzaWduU2V0LnBhcmFtKSB7XG4gICAgICAgIG11bHRpVmFsdWUgPSBkZXNpZ25TZXQucGFyYW1bbGNuYW1lXS5tdWx0aVZhbHVlO1xuICAgICAgICBpZiAoZGVzaWduU2V0LnBhcmFtW2xjbmFtZV0ubXVsdGlWYWx1ZVNlcGFyYXRlRFF1b3RlKSB7XG4gICAgICAgICAgbXZkZWxpbSA9IHBhcnNlci5fcmZjNjg2OEVzY2FwZSgnXCInICsgbXVsdGlWYWx1ZSArICdcIicpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXh0Q2hhciA9IGxpbmVbcG9zICsgMV07XG4gICAgICBpZiAobmV4dENoYXIgPT09ICdcIicpIHtcbiAgICAgICAgdmFsdWVQb3MgPSBwb3MgKyAyO1xuICAgICAgICBwb3MgPSBoZWxwZXJzLnVuZXNjYXBlZEluZGV4T2YobGluZSwgJ1wiJywgdmFsdWVQb3MpO1xuICAgICAgICBpZiAobXVsdGlWYWx1ZSAmJiBwb3MgIT0gLTEpIHtcbiAgICAgICAgICAgIHZhciBleHRlbmRlZFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIHdoaWxlIChleHRlbmRlZFZhbHVlKSB7XG4gICAgICAgICAgICAgIGlmIChsaW5lW3BvcyArIDFdID09IG11bHRpVmFsdWUgJiYgbGluZVtwb3MgKyAyXSA9PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgcG9zID0gaGVscGVycy51bmVzY2FwZWRJbmRleE9mKGxpbmUsICdcIicsIHBvcyArIDMpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4dGVuZGVkVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyA9PT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VyRXJyb3IoXG4gICAgICAgICAgICAnaW52YWxpZCBsaW5lIChubyBtYXRjaGluZyBkb3VibGUgcXVvdGUpIFwiJyArIGxpbmUgKyAnXCInXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IGxpbmUuc3Vic3RyKHZhbHVlUG9zLCBwb3MgLSB2YWx1ZVBvcyk7XG4gICAgICAgIGxhc3RQYXJhbSA9IGhlbHBlcnMudW5lc2NhcGVkSW5kZXhPZihsaW5lLCBQQVJBTV9ERUxJTUlURVIsIHBvcyk7XG4gICAgICAgIGlmIChsYXN0UGFyYW0gPT09IC0xKSB7XG4gICAgICAgICAgcG9zID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlUG9zID0gcG9zICsgMTtcblxuICAgICAgICAvLyBtb3ZlIHRvIG5leHQgXCI7XCJcbiAgICAgICAgdmFyIG5leHRQb3MgPSBoZWxwZXJzLnVuZXNjYXBlZEluZGV4T2YobGluZSwgUEFSQU1fREVMSU1JVEVSLCB2YWx1ZVBvcyk7XG4gICAgICAgIHZhciBwcm9wVmFsdWVQb3MgPSBoZWxwZXJzLnVuZXNjYXBlZEluZGV4T2YobGluZSwgVkFMVUVfREVMSU1JVEVSLCB2YWx1ZVBvcyk7XG4gICAgICAgIGlmIChwcm9wVmFsdWVQb3MgIT09IC0xICYmIG5leHRQb3MgPiBwcm9wVmFsdWVQb3MpIHtcbiAgICAgICAgICAvLyB0aGlzIGlzIGEgZGVsaW1pdGVyIGluIHRoZSBwcm9wZXJ0eSB2YWx1ZSwgbGV0J3Mgc3RvcCBoZXJlXG4gICAgICAgICAgbmV4dFBvcyA9IHByb3BWYWx1ZVBvcztcbiAgICAgICAgICBwb3MgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChuZXh0UG9zID09PSAtMSkge1xuICAgICAgICAgIC8vIG5vIFwiO1wiXG4gICAgICAgICAgaWYgKHByb3BWYWx1ZVBvcyA9PT0gLTEpIHtcbiAgICAgICAgICAgIG5leHRQb3MgPSBsaW5lLmxlbmd0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV4dFBvcyA9IHByb3BWYWx1ZVBvcztcbiAgICAgICAgICB9XG4gICAgICAgICAgcG9zID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGFzdFBhcmFtID0gbmV4dFBvcztcbiAgICAgICAgICBwb3MgPSBuZXh0UG9zO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgPSBsaW5lLnN1YnN0cih2YWx1ZVBvcywgbmV4dFBvcyAtIHZhbHVlUG9zKTtcbiAgICAgIH1cblxuICAgICAgdmFsdWUgPSBwYXJzZXIuX3JmYzY4NjhFc2NhcGUodmFsdWUpO1xuICAgICAgaWYgKG11bHRpVmFsdWUpIHtcbiAgICAgICAgdmFyIGRlbGltaXRlciA9IG12ZGVsaW0gfHwgbXVsdGlWYWx1ZTtcbiAgICAgICAgdmFsdWUgPSBwYXJzZXIuX3BhcnNlTXVsdGlWYWx1ZSh2YWx1ZSwgZGVsaW1pdGVyLCB0eXBlLCBbXSwgbnVsbCwgZGVzaWduU2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gcGFyc2VyLl9wYXJzZVZhbHVlKHZhbHVlLCB0eXBlLCBkZXNpZ25TZXQpO1xuICAgICAgfVxuXG4gICAgICBpZiAobXVsdGlWYWx1ZSAmJiAobGNuYW1lIGluIHJlc3VsdCkpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0W2xjbmFtZV0pKSB7XG4gICAgICAgICAgcmVzdWx0W2xjbmFtZV0ucHVzaCh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0W2xjbmFtZV0gPSBbXG4gICAgICAgICAgICByZXN1bHRbbGNuYW1lXSxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W2xjbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtyZXN1bHQsIHZhbHVlLCB2YWx1ZVBvc107XG4gIH07XG5cbiAgLyoqXG4gICAqIEludGVybmFsIGhlbHBlciBmb3IgcmZjNjg2OC4gRXhwb3NpbmcgdGhpcyBvbiBJQ0FMLnBhcnNlIHNvIHRoYXRcbiAgICogaGFja2VycyBjYW4gZGlzYWJsZSB0aGUgcmZjNjg2OCBwYXJzaW5nIGlmIHRoZSByZWFsbHkgbmVlZCB0by5cbiAgICpcbiAgICogQGZ1bmN0aW9uIElDQUwucGFyc2UuX3JmYzY4NjhFc2NhcGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHZhbCAgICAgICAgVGhlIHZhbHVlIHRvIGVzY2FwZVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICBUaGUgZXNjYXBlZCB2YWx1ZVxuICAgKi9cbiAgcGFyc2VyLl9yZmM2ODY4RXNjYXBlID0gZnVuY3Rpb24odmFsKSB7XG4gICAgcmV0dXJuIHZhbC5yZXBsYWNlKC9cXF5bJ25eXS9nLCBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gUkZDNjg2OF9SRVBMQUNFX01BUFt4XTtcbiAgICB9KTtcbiAgfTtcbiAgdmFyIFJGQzY4NjhfUkVQTEFDRV9NQVAgPSB7IFwiXidcIjogJ1wiJywgXCJeblwiOiBcIlxcblwiLCBcIl5eXCI6IFwiXlwiIH07XG5cbiAgLyoqXG4gICAqIFBhcnNlIGEgbXVsdGkgdmFsdWUgc3RyaW5nLiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgZWl0aGVyIGZvciBwYXJzaW5nXG4gICAqIGFjdHVhbCBtdWx0aS12YWx1ZSBwcm9wZXJ0eSdzIHZhbHVlcywgb3IgZm9yIGhhbmRsaW5nIHBhcmFtZXRlciB2YWx1ZXMuIEl0XG4gICAqIGNhbiBiZSB1c2VkIGZvciBib3RoIG11bHRpLXZhbHVlIHByb3BlcnRpZXMgYW5kIHN0cnVjdHVyZWQgdmFsdWUgcHJvcGVydGllcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGZ1bmN0aW9uIElDQUwucGFyc2UuX3BhcnNlTXVsdGlWYWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gYnVmZmVyICAgICBUaGUgYnVmZmVyIGNvbnRhaW5pbmcgdGhlIGZ1bGwgdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRlbGltICAgICAgVGhlIG11bHRpLXZhbHVlIGRlbGltaXRlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAgICAgICBUaGUgdmFsdWUgdHlwZSB0byBiZSBwYXJzZWRcbiAgICogQHBhcmFtIHtBcnJheS48Pz59IHJlc3VsdCAgICAgICAgVGhlIGFycmF5IHRvIGFwcGVuZCByZXN1bHRzIHRvLCB2YXJpZXMgb24gdmFsdWUgdHlwZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5uZXJNdWx0aSBUaGUgaW5uZXIgZGVsaW1pdGVyIHRvIHNwbGl0IGVhY2ggdmFsdWUgd2l0aFxuICAgKiBAcGFyYW0ge0lDQUwuZGVzaWduLmRlc2lnblNldH0gZGVzaWduU2V0ICAgVGhlIGRlc2lnbiBkYXRhIGZvciB0aGlzIHZhbHVlXG4gICAqIEByZXR1cm4gez98QXJyYXkuPD8+fSAgICAgICAgICAgIEVpdGhlciBhbiBhcnJheSBvZiByZXN1bHRzLCBvciB0aGUgZmlyc3QgcmVzdWx0XG4gICAqL1xuICBwYXJzZXIuX3BhcnNlTXVsdGlWYWx1ZSA9IGZ1bmN0aW9uKGJ1ZmZlciwgZGVsaW0sIHR5cGUsIHJlc3VsdCwgaW5uZXJNdWx0aSwgZGVzaWduU2V0LCBzdHJ1Y3R1cmVkVmFsdWUpIHtcbiAgICB2YXIgcG9zID0gMDtcbiAgICB2YXIgbGFzdFBvcyA9IDA7XG4gICAgdmFyIHZhbHVlO1xuICAgIGlmIChkZWxpbS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfVxuXG4gICAgLy8gc3BsaXQgZWFjaCBwaWVjZVxuICAgIHdoaWxlICgocG9zID0gaGVscGVycy51bmVzY2FwZWRJbmRleE9mKGJ1ZmZlciwgZGVsaW0sIGxhc3RQb3MpKSAhPT0gLTEpIHtcbiAgICAgIHZhbHVlID0gYnVmZmVyLnN1YnN0cihsYXN0UG9zLCBwb3MgLSBsYXN0UG9zKTtcbiAgICAgIGlmIChpbm5lck11bHRpKSB7XG4gICAgICAgIHZhbHVlID0gcGFyc2VyLl9wYXJzZU11bHRpVmFsdWUodmFsdWUsIGlubmVyTXVsdGksIHR5cGUsIFtdLCBudWxsLCBkZXNpZ25TZXQsIHN0cnVjdHVyZWRWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IHBhcnNlci5fcGFyc2VWYWx1ZSh2YWx1ZSwgdHlwZSwgZGVzaWduU2V0LCBzdHJ1Y3R1cmVkVmFsdWUpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgbGFzdFBvcyA9IHBvcyArIGRlbGltLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBvbiB0aGUgbGFzdCBwaWVjZSB0YWtlIHRoZSByZXN0IG9mIHN0cmluZ1xuICAgIHZhbHVlID0gYnVmZmVyLnN1YnN0cihsYXN0UG9zKTtcbiAgICBpZiAoaW5uZXJNdWx0aSkge1xuICAgICAgdmFsdWUgPSBwYXJzZXIuX3BhcnNlTXVsdGlWYWx1ZSh2YWx1ZSwgaW5uZXJNdWx0aSwgdHlwZSwgW10sIG51bGwsIGRlc2lnblNldCwgc3RydWN0dXJlZFZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSBwYXJzZXIuX3BhcnNlVmFsdWUodmFsdWUsIHR5cGUsIGRlc2lnblNldCwgc3RydWN0dXJlZFZhbHVlKTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2godmFsdWUpO1xuXG4gICAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPT0gMSA/IHJlc3VsdFswXSA6IHJlc3VsdDtcbiAgfTtcblxuICAvKipcbiAgICogUHJvY2VzcyBhIGNvbXBsZXRlIGJ1ZmZlciBvZiBpQ2FsZW5kYXIvdkNhcmQgZGF0YSBsaW5lIGJ5IGxpbmUsIGNvcnJlY3RseVxuICAgKiB1bmZvbGRpbmcgY29udGVudC4gRWFjaCBsaW5lIHdpbGwgYmUgcHJvY2Vzc2VkIHdpdGggdGhlIGdpdmVuIGNhbGxiYWNrXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBmdW5jdGlvbiBJQ0FMLnBhcnNlLl9lYWNoTGluZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gYnVmZmVyICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBidWZmZXIgdG8gcHJvY2Vzc1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKD9TdHJpbmcsIFN0cmluZyl9IGNhbGxiYWNrICAgIFRoZSBjYWxsYmFjayBmb3IgZWFjaCBsaW5lXG4gICAqL1xuICBwYXJzZXIuX2VhY2hMaW5lID0gZnVuY3Rpb24oYnVmZmVyLCBjYWxsYmFjaykge1xuICAgIHZhciBsZW4gPSBidWZmZXIubGVuZ3RoO1xuICAgIHZhciBsYXN0UG9zID0gYnVmZmVyLnNlYXJjaChDSEFSKTtcbiAgICB2YXIgcG9zID0gbGFzdFBvcztcbiAgICB2YXIgbGluZTtcbiAgICB2YXIgZmlyc3RDaGFyO1xuXG4gICAgdmFyIG5ld2xpbmVPZmZzZXQ7XG5cbiAgICBkbyB7XG4gICAgICBwb3MgPSBidWZmZXIuaW5kZXhPZignXFxuJywgbGFzdFBvcykgKyAxO1xuXG4gICAgICBpZiAocG9zID4gMSAmJiBidWZmZXJbcG9zIC0gMl0gPT09ICdcXHInKSB7XG4gICAgICAgIG5ld2xpbmVPZmZzZXQgPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3bGluZU9mZnNldCA9IDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChwb3MgPT09IDApIHtcbiAgICAgICAgcG9zID0gbGVuO1xuICAgICAgICBuZXdsaW5lT2Zmc2V0ID0gMDtcbiAgICAgIH1cblxuICAgICAgZmlyc3RDaGFyID0gYnVmZmVyW2xhc3RQb3NdO1xuXG4gICAgICBpZiAoZmlyc3RDaGFyID09PSAnICcgfHwgZmlyc3RDaGFyID09PSAnXFx0Jykge1xuICAgICAgICAvLyBhZGQgdG8gbGluZVxuICAgICAgICBsaW5lICs9IGJ1ZmZlci5zdWJzdHIoXG4gICAgICAgICAgbGFzdFBvcyArIDEsXG4gICAgICAgICAgcG9zIC0gbGFzdFBvcyAtIChuZXdsaW5lT2Zmc2V0ICsgMSlcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChsaW5lKVxuICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGxpbmUpO1xuICAgICAgICAvLyBwdXNoIGxpbmVcbiAgICAgICAgbGluZSA9IGJ1ZmZlci5zdWJzdHIoXG4gICAgICAgICAgbGFzdFBvcyxcbiAgICAgICAgICBwb3MgLSBsYXN0UG9zIC0gbmV3bGluZU9mZnNldFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBsYXN0UG9zID0gcG9zO1xuICAgIH0gd2hpbGUgKHBvcyAhPT0gbGVuKTtcblxuICAgIC8vIGV4dHJhIGVuZGluZyBsaW5lXG4gICAgbGluZSA9IGxpbmUudHJpbSgpO1xuXG4gICAgaWYgKGxpbmUubGVuZ3RoKVxuICAgICAgY2FsbGJhY2sobnVsbCwgbGluZSk7XG4gIH07XG5cbiAgcmV0dXJuIHBhcnNlcjtcblxufSgpKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAxMS0yMDE1ICovXG5cblxuLyoqXG4gKiBUaGlzIHN5bWJvbCBpcyBmdXJ0aGVyIGRlc2NyaWJlZCBsYXRlciBvblxuICogQGlnbm9yZVxuICovXG5JQ0FMLkNvbXBvbmVudCA9IChmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBQUk9QRVJUWV9JTkRFWCA9IDE7XG4gIHZhciBDT01QT05FTlRfSU5ERVggPSAyO1xuICB2YXIgTkFNRV9JTkRFWCA9IDA7XG5cbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogV3JhcHMgYSBqQ2FsIGNvbXBvbmVudCwgYWRkaW5nIGNvbnZlbmllbmNlIG1ldGhvZHMgdG8gYWRkLCByZW1vdmUgYW5kXG4gICAqIHVwZGF0ZSBzdWJjb21wb25lbnRzIGFuZCBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQGFsaWFzIElDQUwuQ29tcG9uZW50XG4gICAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBqQ2FsICAgICAgICAgUmF3IGpDYWwgY29tcG9uZW50IGRhdGEgT1IgbmFtZSBvZiBuZXdcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge0lDQUwuQ29tcG9uZW50fSBwYXJlbnQgICAgIFBhcmVudCBjb21wb25lbnQgdG8gYXNzb2NpYXRlXG4gICAqL1xuICBmdW5jdGlvbiBDb21wb25lbnQoakNhbCwgcGFyZW50KSB7XG4gICAgaWYgKHR5cGVvZihqQ2FsKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIGpDYWwgc3BlYyAobmFtZSwgcHJvcGVydGllcywgY29tcG9uZW50cylcbiAgICAgIGpDYWwgPSBbakNhbCwgW10sIFtdXTtcbiAgICB9XG5cbiAgICAvLyBtb3N0bHkgZm9yIGxlZ2FjeSByZWFzb25zLlxuICAgIHRoaXMuakNhbCA9IGpDYWw7XG5cbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudCB8fCBudWxsO1xuICB9XG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBIeWRyYXRlZCBwcm9wZXJ0aWVzIGFyZSBpbnNlcnRlZCBpbnRvIHRoZSBfcHJvcGVydGllcyBhcnJheSBhdCB0aGUgc2FtZVxuICAgICAqIHBvc2l0aW9uIGFzIGluIHRoZSBqQ2FsIGFycmF5LCBzbyBpdCBpcyBwb3NzaWJsZSB0aGF0IHRoZSBhcnJheSBjb250YWluc1xuICAgICAqIHVuZGVmaW5lZCB2YWx1ZXMgZm9yIHVuaHlkcmRhdGVkIHByb3BlcnRpZXMuIFRvIGF2b2lkIGl0ZXJhdGluZyB0aGVcbiAgICAgKiBhcnJheSB3aGVuIGNoZWNraW5nIGlmIGFsbCBwcm9wZXJ0aWVzIGhhdmUgYmVlbiBoeWRyYXRlZCwgd2Ugc2F2ZSB0aGVcbiAgICAgKiBjb3VudCBoZXJlLlxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9oeWRyYXRlZFByb3BlcnR5Q291bnQ6IDAsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2FtZSBjb3VudCBhcyBmb3IgX2h5ZHJhdGVkUHJvcGVydHlDb3VudCwgYnV0IGZvciBzdWJjb21wb25lbnRzXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2h5ZHJhdGVkQ29tcG9uZW50Q291bnQ6IDAsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGlzIGNvbXBvbmVudFxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgcmV0dXJuIHRoaXMuakNhbFtOQU1FX0lOREVYXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGRlc2lnbiBzZXQgZm9yIHRoaXMgY29tcG9uZW50LCBlLmcuIGljYWxlbmRhciB2cyB2Y2FyZFxuICAgICAqXG4gICAgICogQHR5cGUge0lDQUwuZGVzaWduLmRlc2lnblNldH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldCBfZGVzaWduU2V0KCkge1xuICAgICAgdmFyIHBhcmVudERlc2lnbiA9IHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50Ll9kZXNpZ25TZXQ7XG4gICAgICByZXR1cm4gcGFyZW50RGVzaWduIHx8IElDQUwuZGVzaWduLmdldERlc2lnblNldCh0aGlzLm5hbWUpO1xuICAgIH0sXG5cbiAgICBfaHlkcmF0ZUNvbXBvbmVudDogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIGlmICghdGhpcy5fY29tcG9uZW50cykge1xuICAgICAgICB0aGlzLl9jb21wb25lbnRzID0gW107XG4gICAgICAgIHRoaXMuX2h5ZHJhdGVkQ29tcG9uZW50Q291bnQgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fY29tcG9uZW50c1tpbmRleF0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudHNbaW5kZXhdO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29tcCA9IG5ldyBDb21wb25lbnQoXG4gICAgICAgIHRoaXMuakNhbFtDT01QT05FTlRfSU5ERVhdW2luZGV4XSxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcblxuICAgICAgdGhpcy5faHlkcmF0ZWRDb21wb25lbnRDb3VudCsrO1xuICAgICAgcmV0dXJuICh0aGlzLl9jb21wb25lbnRzW2luZGV4XSA9IGNvbXApO1xuICAgIH0sXG5cbiAgICBfaHlkcmF0ZVByb3BlcnR5OiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgaWYgKCF0aGlzLl9wcm9wZXJ0aWVzKSB7XG4gICAgICAgIHRoaXMuX3Byb3BlcnRpZXMgPSBbXTtcbiAgICAgICAgdGhpcy5faHlkcmF0ZWRQcm9wZXJ0eUNvdW50ID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3Byb3BlcnRpZXNbaW5kZXhdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9wZXJ0aWVzW2luZGV4XTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByb3AgPSBuZXcgSUNBTC5Qcm9wZXJ0eShcbiAgICAgICAgdGhpcy5qQ2FsW1BST1BFUlRZX0lOREVYXVtpbmRleF0sXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG5cbiAgICAgIHRoaXMuX2h5ZHJhdGVkUHJvcGVydHlDb3VudCsrO1xuICAgICAgcmV0dXJuICh0aGlzLl9wcm9wZXJ0aWVzW2luZGV4XSA9IHByb3ApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyBmaXJzdCBzdWIgY29tcG9uZW50LCBvcHRpb25hbGx5IGZpbHRlcmVkIGJ5IG5hbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZz19IG5hbWUgICAgICAgIE9wdGlvbmFsIG5hbWUgdG8gZmlsdGVyIGJ5XG4gICAgICogQHJldHVybiB7P0lDQUwuQ29tcG9uZW50fSAgICAgVGhlIGZvdW5kIHN1YmNvbXBvbmVudFxuICAgICAqL1xuICAgIGdldEZpcnN0U3ViY29tcG9uZW50OiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBjb21wcyA9IHRoaXMuakNhbFtDT01QT05FTlRfSU5ERVhdO1xuICAgICAgICB2YXIgbGVuID0gY29tcHMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAoY29tcHNbaV1bTkFNRV9JTkRFWF0gPT09IG5hbWUpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9oeWRyYXRlQ29tcG9uZW50KGkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmpDYWxbQ09NUE9ORU5UX0lOREVYXS5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5faHlkcmF0ZUNvbXBvbmVudCgwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBlbnN1cmUgd2UgcmV0dXJuIGEgdmFsdWUgKHN0cmljdCBtb2RlKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIGFsbCBzdWIgY29tcG9uZW50cywgb3B0aW9uYWxseSBmaWx0ZXJpbmcgYnkgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nPX0gbmFtZSAgICAgICAgICAgIE9wdGlvbmFsIG5hbWUgdG8gZmlsdGVyIGJ5XG4gICAgICogQHJldHVybiB7SUNBTC5Db21wb25lbnRbXX0gICAgICAgVGhlIGZvdW5kIHN1YiBjb21wb25lbnRzXG4gICAgICovXG4gICAgZ2V0QWxsU3ViY29tcG9uZW50czogZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGpDYWxMZW4gPSB0aGlzLmpDYWxbQ09NUE9ORU5UX0lOREVYXS5sZW5ndGg7XG4gICAgICB2YXIgaSA9IDA7XG5cbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHZhciBjb21wcyA9IHRoaXMuakNhbFtDT01QT05FTlRfSU5ERVhdO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgZm9yICg7IGkgPCBqQ2FsTGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAobmFtZSA9PT0gY29tcHNbaV1bTkFNRV9JTkRFWF0pIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgICAgICB0aGlzLl9oeWRyYXRlQ29tcG9uZW50KGkpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jb21wb25lbnRzIHx8XG4gICAgICAgICAgICAodGhpcy5faHlkcmF0ZWRDb21wb25lbnRDb3VudCAhPT0gakNhbExlbikpIHtcbiAgICAgICAgICBmb3IgKDsgaSA8IGpDYWxMZW47IGkrKykge1xuICAgICAgICAgICAgdGhpcy5faHlkcmF0ZUNvbXBvbmVudChpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50cyB8fCBbXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIHdoZW4gYSBuYW1lZCBwcm9wZXJ0eSBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAgICAgVGhlIHByb3BlcnR5IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgVHJ1ZSwgd2hlbiBwcm9wZXJ0eSBpcyBmb3VuZFxuICAgICAqL1xuICAgIGhhc1Byb3BlcnR5OiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgcHJvcHMgPSB0aGlzLmpDYWxbUFJPUEVSVFlfSU5ERVhdO1xuICAgICAgdmFyIGxlbiA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgdmFyIGkgPSAwO1xuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAvLyAwIGlzIHByb3BlcnR5IG5hbWVcbiAgICAgICAgaWYgKHByb3BzW2ldW05BTUVfSU5ERVhdID09PSBuYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgZmlyc3QgcHJvcGVydHksIG9wdGlvbmFsbHkgd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nPX0gbmFtZSAgICAgICAgTG93ZXJjYXNlIHByb3BlcnR5IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/SUNBTC5Qcm9wZXJ0eX0gICAgIFRoZSBmb3VuZCBwcm9wZXJ0eVxuICAgICAqL1xuICAgIGdldEZpcnN0UHJvcGVydHk6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5qQ2FsW1BST1BFUlRZX0lOREVYXTtcbiAgICAgICAgdmFyIGxlbiA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWYgKHByb3BzW2ldW05BTUVfSU5ERVhdID09PSBuYW1lKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5faHlkcmF0ZVByb3BlcnR5KGkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmpDYWxbUFJPUEVSVFlfSU5ERVhdLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9oeWRyYXRlUHJvcGVydHkoMCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZmlyc3QgcHJvcGVydHkncyB2YWx1ZSwgaWYgYXZhaWxhYmxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmc9fSBuYW1lICAgIExvd2VyY2FzZSBwcm9wZXJ0eSBuYW1lXG4gICAgICogQHJldHVybiB7P1N0cmluZ30gICAgICAgIFRoZSBmb3VuZCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgKi9cbiAgICBnZXRGaXJzdFByb3BlcnR5VmFsdWU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciBwcm9wID0gdGhpcy5nZXRGaXJzdFByb3BlcnR5KG5hbWUpO1xuICAgICAgaWYgKHByb3ApIHtcbiAgICAgICAgcmV0dXJuIHByb3AuZ2V0Rmlyc3RWYWx1ZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBwcm9wZXJ0aWVzIGluIHRoZSBjb21wb25lbnQsIG9wdGlvbmFsbHkgZmlsdGVyZWQgYnkgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nPX0gbmFtZSAgICAgICAgTG93ZXJjYXNlIHByb3BlcnR5IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlByb3BlcnR5W119ICAgIExpc3Qgb2YgcHJvcGVydGllc1xuICAgICAqL1xuICAgIGdldEFsbFByb3BlcnRpZXM6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciBqQ2FsTGVuID0gdGhpcy5qQ2FsW1BST1BFUlRZX0lOREVYXS5sZW5ndGg7XG4gICAgICB2YXIgaSA9IDA7XG5cbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMuakNhbFtQUk9QRVJUWV9JTkRFWF07XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICBmb3IgKDsgaSA8IGpDYWxMZW47IGkrKykge1xuICAgICAgICAgIGlmIChuYW1lID09PSBwcm9wc1tpXVtOQU1FX0lOREVYXSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgICAgIHRoaXMuX2h5ZHJhdGVQcm9wZXJ0eShpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdGhpcy5fcHJvcGVydGllcyB8fFxuICAgICAgICAgICAgKHRoaXMuX2h5ZHJhdGVkUHJvcGVydHlDb3VudCAhPT0gakNhbExlbikpIHtcbiAgICAgICAgICBmb3IgKDsgaSA8IGpDYWxMZW47IGkrKykge1xuICAgICAgICAgICAgdGhpcy5faHlkcmF0ZVByb3BlcnR5KGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9wZXJ0aWVzIHx8IFtdO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfcmVtb3ZlT2JqZWN0QnlJbmRleDogZnVuY3Rpb24oakNhbEluZGV4LCBjYWNoZSwgaW5kZXgpIHtcbiAgICAgIGNhY2hlID0gY2FjaGUgfHwgW107XG4gICAgICAvLyByZW1vdmUgY2FjaGVkIHZlcnNpb25cbiAgICAgIGlmIChjYWNoZVtpbmRleF0pIHtcbiAgICAgICAgdmFyIG9iaiA9IGNhY2hlW2luZGV4XTtcbiAgICAgICAgaWYgKFwicGFyZW50XCIgaW4gb2JqKSB7XG4gICAgICAgICAgICBvYmoucGFyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjYWNoZS5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgICAvLyByZW1vdmUgaXQgZnJvbSB0aGUgakNhbFxuICAgICAgdGhpcy5qQ2FsW2pDYWxJbmRleF0uc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9LFxuXG4gICAgX3JlbW92ZU9iamVjdDogZnVuY3Rpb24oakNhbEluZGV4LCBjYWNoZSwgbmFtZU9yT2JqZWN0KSB7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgb2JqZWN0cyA9IHRoaXMuakNhbFtqQ2FsSW5kZXhdO1xuICAgICAgdmFyIGxlbiA9IG9iamVjdHMubGVuZ3RoO1xuICAgICAgdmFyIGNhY2hlZCA9IHRoaXNbY2FjaGVdO1xuXG4gICAgICBpZiAodHlwZW9mKG5hbWVPck9iamVjdCkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAob2JqZWN0c1tpXVtOQU1FX0lOREVYXSA9PT0gbmFtZU9yT2JqZWN0KSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVPYmplY3RCeUluZGV4KGpDYWxJbmRleCwgY2FjaGVkLCBpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjYWNoZWQpIHtcbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmIChjYWNoZWRbaV0gJiYgY2FjaGVkW2ldID09PSBuYW1lT3JPYmplY3QpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZU9iamVjdEJ5SW5kZXgoakNhbEluZGV4LCBjYWNoZWQsIGkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgX3JlbW92ZUFsbE9iamVjdHM6IGZ1bmN0aW9uKGpDYWxJbmRleCwgY2FjaGUsIG5hbWUpIHtcbiAgICAgIHZhciBjYWNoZWQgPSB0aGlzW2NhY2hlXTtcblxuICAgICAgLy8gVW5mb3J0dW5hdGVseSB3ZSBoYXZlIHRvIHJ1biB0aHJvdWdoIGFsbCBjaGlsZHJlbiB0byByZXNldCB0aGVpclxuICAgICAgLy8gcGFyZW50IHByb3BlcnR5LlxuICAgICAgdmFyIG9iamVjdHMgPSB0aGlzLmpDYWxbakNhbEluZGV4XTtcbiAgICAgIHZhciBpID0gb2JqZWN0cy5sZW5ndGggLSAxO1xuXG4gICAgICAvLyBkZXNjZW5kaW5nIHNlYXJjaCByZXF1aXJlZCBiZWNhdXNlIHNwbGljZVxuICAgICAgLy8gaXMgdXNlZCBhbmQgd2lsbCBlZmZlY3QgdGhlIGluZGljZXMuXG4gICAgICBmb3IgKDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKCFuYW1lIHx8IG9iamVjdHNbaV1bTkFNRV9JTkRFWF0gPT09IG5hbWUpIHtcbiAgICAgICAgICB0aGlzLl9yZW1vdmVPYmplY3RCeUluZGV4KGpDYWxJbmRleCwgY2FjaGVkLCBpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgc2luZ2xlIHN1YiBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuQ29tcG9uZW50fSBjb21wb25lbnQgICAgICAgIFRoZSBjb21wb25lbnQgdG8gYWRkXG4gICAgICogQHJldHVybiB7SUNBTC5Db21wb25lbnR9ICAgICAgICAgICAgICAgICBUaGUgcGFzc2VkIGluIGNvbXBvbmVudFxuICAgICAqL1xuICAgIGFkZFN1YmNvbXBvbmVudDogZnVuY3Rpb24oY29tcG9uZW50KSB7XG4gICAgICBpZiAoIXRoaXMuX2NvbXBvbmVudHMpIHtcbiAgICAgICAgdGhpcy5fY29tcG9uZW50cyA9IFtdO1xuICAgICAgICB0aGlzLl9oeWRyYXRlZENvbXBvbmVudENvdW50ID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbXBvbmVudC5wYXJlbnQpIHtcbiAgICAgICAgY29tcG9uZW50LnBhcmVudC5yZW1vdmVTdWJjb21wb25lbnQoY29tcG9uZW50KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlkeCA9IHRoaXMuakNhbFtDT01QT05FTlRfSU5ERVhdLnB1c2goY29tcG9uZW50LmpDYWwpO1xuICAgICAgdGhpcy5fY29tcG9uZW50c1tpZHggLSAxXSA9IGNvbXBvbmVudDtcbiAgICAgIHRoaXMuX2h5ZHJhdGVkQ29tcG9uZW50Q291bnQrKztcbiAgICAgIGNvbXBvbmVudC5wYXJlbnQgPSB0aGlzO1xuICAgICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHNpbmdsZSBjb21wb25lbnQgYnkgbmFtZSBvciB0aGUgaW5zdGFuY2Ugb2YgYSBzcGVjaWZpY1xuICAgICAqIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SUNBTC5Db21wb25lbnR8U3RyaW5nfSBuYW1lT3JDb21wICAgIE5hbWUgb2YgY29tcG9uZW50LCBvciBjb21wb25lbnRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICAgICAgICAgICAgICAgICAgICBUcnVlIHdoZW4gY29tcCBpcyByZW1vdmVkXG4gICAgICovXG4gICAgcmVtb3ZlU3ViY29tcG9uZW50OiBmdW5jdGlvbihuYW1lT3JDb21wKSB7XG4gICAgICB2YXIgcmVtb3ZlZCA9IHRoaXMuX3JlbW92ZU9iamVjdChDT01QT05FTlRfSU5ERVgsICdfY29tcG9uZW50cycsIG5hbWVPckNvbXApO1xuICAgICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgICAgdGhpcy5faHlkcmF0ZWRDb21wb25lbnRDb3VudC0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlbW92ZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGNvbXBvbmVudHMgb3IgKGlmIGdpdmVuKSBhbGwgY29tcG9uZW50cyBieSBhIHBhcnRpY3VsYXJcbiAgICAgKiBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmc9fSBuYW1lICAgICAgICAgICAgTG93ZXJjYXNlIGNvbXBvbmVudCBuYW1lXG4gICAgICovXG4gICAgcmVtb3ZlQWxsU3ViY29tcG9uZW50czogZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIHJlbW92ZWQgPSB0aGlzLl9yZW1vdmVBbGxPYmplY3RzKENPTVBPTkVOVF9JTkRFWCwgJ19jb21wb25lbnRzJywgbmFtZSk7XG4gICAgICB0aGlzLl9oeWRyYXRlZENvbXBvbmVudENvdW50ID0gMDtcbiAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIHtAbGluayBJQ0FMLlByb3BlcnR5fSB0byB0aGUgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLlByb3BlcnR5fSBwcm9wZXJ0eSAgICAgIFRoZSBwcm9wZXJ0eSB0byBhZGRcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlByb3BlcnR5fSAgICAgICAgICAgICAgVGhlIHBhc3NlZCBpbiBwcm9wZXJ0eVxuICAgICAqL1xuICAgIGFkZFByb3BlcnR5OiBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgICAgaWYgKCEocHJvcGVydHkgaW5zdGFuY2VvZiBJQ0FMLlByb3BlcnR5KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtdXN0IGluc3RhbmNlIG9mIElDQUwuUHJvcGVydHknKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9wcm9wZXJ0aWVzKSB7XG4gICAgICAgIHRoaXMuX3Byb3BlcnRpZXMgPSBbXTtcbiAgICAgICAgdGhpcy5faHlkcmF0ZWRQcm9wZXJ0eUNvdW50ID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3BlcnR5LnBhcmVudCkge1xuICAgICAgICBwcm9wZXJ0eS5wYXJlbnQucmVtb3ZlUHJvcGVydHkocHJvcGVydHkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaWR4ID0gdGhpcy5qQ2FsW1BST1BFUlRZX0lOREVYXS5wdXNoKHByb3BlcnR5LmpDYWwpO1xuICAgICAgdGhpcy5fcHJvcGVydGllc1tpZHggLSAxXSA9IHByb3BlcnR5O1xuICAgICAgdGhpcy5faHlkcmF0ZWRQcm9wZXJ0eUNvdW50Kys7XG4gICAgICBwcm9wZXJ0eS5wYXJlbnQgPSB0aGlzO1xuICAgICAgcmV0dXJuIHByb3BlcnR5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIGFkZCBhIHByb3BlcnR5IHdpdGggYSB2YWx1ZSB0byB0aGUgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgICAgICAgICAgICAgbmFtZSAgICAgICAgIFByb3BlcnR5IG5hbWUgdG8gYWRkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfE9iamVjdH0gdmFsdWUgICAgICAgIFByb3BlcnR5IHZhbHVlXG4gICAgICogQHJldHVybiB7SUNBTC5Qcm9wZXJ0eX0gICAgICAgICAgICAgICAgICAgIFRoZSBjcmVhdGVkIHByb3BlcnR5XG4gICAgICovXG4gICAgYWRkUHJvcGVydHlXaXRoVmFsdWU6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICB2YXIgcHJvcCA9IG5ldyBJQ0FMLlByb3BlcnR5KG5hbWUpO1xuICAgICAgcHJvcC5zZXRWYWx1ZSh2YWx1ZSk7XG5cbiAgICAgIHRoaXMuYWRkUHJvcGVydHkocHJvcCk7XG5cbiAgICAgIHJldHVybiBwcm9wO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRoYXQgd2lsbCB1cGRhdGUgb3IgY3JlYXRlIGEgcHJvcGVydHkgb2YgdGhlIGdpdmVuIG5hbWVcbiAgICAgKiBhbmQgc2V0cyBpdHMgdmFsdWUuIElmIG11bHRpcGxlIHByb3BlcnRpZXMgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBleGlzdCxcbiAgICAgKiBvbmx5IHRoZSBmaXJzdCBpcyB1cGRhdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgICAgICAgICAgICAgbmFtZSAgICAgICAgIFByb3BlcnR5IG5hbWUgdG8gdXBkYXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfE9iamVjdH0gdmFsdWUgICAgICAgIFByb3BlcnR5IHZhbHVlXG4gICAgICogQHJldHVybiB7SUNBTC5Qcm9wZXJ0eX0gICAgICAgICAgICAgICAgICAgIFRoZSBjcmVhdGVkIHByb3BlcnR5XG4gICAgICovXG4gICAgdXBkYXRlUHJvcGVydHlXaXRoVmFsdWU6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICB2YXIgcHJvcCA9IHRoaXMuZ2V0Rmlyc3RQcm9wZXJ0eShuYW1lKTtcblxuICAgICAgaWYgKHByb3ApIHtcbiAgICAgICAgcHJvcC5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wID0gdGhpcy5hZGRQcm9wZXJ0eVdpdGhWYWx1ZShuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcm9wO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgc2luZ2xlIHByb3BlcnR5IGJ5IG5hbWUgb3IgdGhlIGluc3RhbmNlIG9mIHRoZSBzcGVjaWZpY1xuICAgICAqIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8SUNBTC5Qcm9wZXJ0eX0gbmFtZU9yUHJvcCAgICAgUHJvcGVydHkgbmFtZSBvciBpbnN0YW5jZSB0byByZW1vdmVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICAgICAgICAgICAgICAgICAgICBUcnVlLCB3aGVuIGRlbGV0ZWRcbiAgICAgKi9cbiAgICByZW1vdmVQcm9wZXJ0eTogZnVuY3Rpb24obmFtZU9yUHJvcCkge1xuICAgICAgdmFyIHJlbW92ZWQgPSB0aGlzLl9yZW1vdmVPYmplY3QoUFJPUEVSVFlfSU5ERVgsICdfcHJvcGVydGllcycsIG5hbWVPclByb3ApO1xuICAgICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgICAgdGhpcy5faHlkcmF0ZWRQcm9wZXJ0eUNvdW50LS07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgcHJvcGVydGllcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBjb21wb25lbnQsIG9wdGlvbmFsbHlcbiAgICAgKiBmaWx0ZXJlZCBieSBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmc9fSBuYW1lICAgICAgICBMb3dlcmNhc2UgcHJvcGVydHkgbmFtZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgICAgVHJ1ZSwgd2hlbiBkZWxldGVkXG4gICAgICovXG4gICAgcmVtb3ZlQWxsUHJvcGVydGllczogZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIHJlbW92ZWQgPSB0aGlzLl9yZW1vdmVBbGxPYmplY3RzKFBST1BFUlRZX0lOREVYLCAnX3Byb3BlcnRpZXMnLCBuYW1lKTtcbiAgICAgIHRoaXMuX2h5ZHJhdGVkUHJvcGVydHlDb3VudCA9IDA7XG4gICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgY29tcG9uZW50LiBUaGUgcmV0dXJuZWQgb2JqZWN0XG4gICAgICogaXMgYSBsaXZlIGpDYWwgb2JqZWN0IGFuZCBzaG91bGQgYmUgY2xvbmVkIGlmIG1vZGlmaWVkLlxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT046IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuakNhbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbXBvbmVudC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIElDQUwuc3RyaW5naWZ5LmNvbXBvbmVudChcbiAgICAgICAgdGhpcy5qQ2FsLCB0aGlzLl9kZXNpZ25TZXRcbiAgICAgICk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4ge0BsaW5rIElDQUwuQ29tcG9uZW50fSBieSBwYXJzaW5nIHRoZSBwYXNzZWQgaUNhbGVuZGFyIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciAgICAgICAgVGhlIGlDYWxlbmRhciBzdHJpbmcgdG8gcGFyc2VcbiAgICovXG4gIENvbXBvbmVudC5mcm9tU3RyaW5nID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBDb21wb25lbnQoSUNBTC5wYXJzZS5jb21wb25lbnQoc3RyKSk7XG4gIH07XG5cbiAgcmV0dXJuIENvbXBvbmVudDtcbn0oKSk7XG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICogUG9ydGlvbnMgQ29weXJpZ2h0IChDKSBQaGlsaXBwIEtld2lzY2gsIDIwMTEtMjAxNSAqL1xuXG5cbi8qKlxuICogVGhpcyBzeW1ib2wgaXMgZnVydGhlciBkZXNjcmliZWQgbGF0ZXIgb25cbiAqIEBpZ25vcmVcbiAqL1xuSUNBTC5Qcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBOQU1FX0lOREVYID0gMDtcbiAgdmFyIFBST1BfSU5ERVggPSAxO1xuICB2YXIgVFlQRV9JTkRFWCA9IDI7XG4gIHZhciBWQUxVRV9JTkRFWCA9IDM7XG5cbiAgdmFyIGRlc2lnbiA9IElDQUwuZGVzaWduO1xuXG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIFByb3ZpZGVzIGEgbGF5ZXIgb24gdG9wIG9mIHRoZSByYXcgakNhbCBvYmplY3QgZm9yIG1hbmlwdWxhdGluZyBhIHNpbmdsZVxuICAgKiBwcm9wZXJ0eSwgd2l0aCBpdHMgcGFyYW1ldGVycyBhbmQgdmFsdWUuXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBJdCBpcyBpbXBvcnRhbnQgdG8gbm90ZSB0aGF0IG11dGF0aW9ucyBkb25lIGluIHRoZSB3cmFwcGVyXG4gICAqIGRpcmVjdGx5IG11dGF0ZSB0aGUgakNhbCBvYmplY3QgdXNlZCB0byBpbml0aWFsaXplLlxuICAgKlxuICAgKiBDYW4gYWxzbyBiZSB1c2VkIHRvIGNyZWF0ZSBuZXcgcHJvcGVydGllcyBieSBwYXNzaW5nXG4gICAqIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSAoYXMgYSBTdHJpbmcpLlxuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQGFsaWFzIElDQUwuUHJvcGVydHlcbiAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IGpDYWwgICAgICAgICBSYXcgakNhbCByZXByZXNlbnRhdGlvbiBPUlxuICAgKiAgdGhlIG5ldyBuYW1lIG9mIHRoZSBwcm9wZXJ0eVxuICAgKlxuICAgKiBAcGFyYW0ge0lDQUwuQ29tcG9uZW50PX0gcGFyZW50ICAgIFBhcmVudCBjb21wb25lbnRcbiAgICovXG4gIGZ1bmN0aW9uIFByb3BlcnR5KGpDYWwsIHBhcmVudCkge1xuICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudCB8fCBudWxsO1xuXG4gICAgaWYgKHR5cGVvZihqQ2FsKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFdlIGFyZSBjcmVhdGluZyB0aGUgcHJvcGVydHkgYnkgbmFtZSBhbmQgbmVlZCB0byBkZXRlY3QgdGhlIHR5cGVcbiAgICAgIHRoaXMuakNhbCA9IFtqQ2FsLCB7fSwgZGVzaWduLmRlZmF1bHRUeXBlXTtcbiAgICAgIHRoaXMuakNhbFtUWVBFX0lOREVYXSA9IHRoaXMuZ2V0RGVmYXVsdFR5cGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5qQ2FsID0gakNhbDtcbiAgICB9XG4gICAgdGhpcy5fdXBkYXRlVHlwZSgpO1xuICB9XG5cbiAgUHJvcGVydHkucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIHR5cGUgZm9yIHRoaXMgcHJvcGVydHlcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldCB0eXBlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuakNhbFtUWVBFX0lOREVYXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhpcyBwcm9wZXJ0eSwgaW4gbG93ZXJjYXNlLlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5qQ2FsW05BTUVfSU5ERVhdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgcGFyZW50IGNvbXBvbmVudCBmb3IgdGhpcyBwcm9wZXJ0eS5cbiAgICAgKiBAdHlwZSB7SUNBTC5Db21wb25lbnR9XG4gICAgICovXG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQ7XG4gICAgfSxcblxuICAgIHNldCBwYXJlbnQocCkge1xuICAgICAgLy8gQmVmb3JlIHNldHRpbmcgdGhlIHBhcmVudCwgY2hlY2sgaWYgdGhlIGRlc2lnbiBzZXQgaGFzIGNoYW5nZWQuIElmIGl0XG4gICAgICAvLyBoYXMsIHdlIGxhdGVyIG5lZWQgdG8gdXBkYXRlIHRoZSB0eXBlIGlmIGl0IHdhcyB1bmtub3duIGJlZm9yZS5cbiAgICAgIHZhciBkZXNpZ25TZXRDaGFuZ2VkID0gIXRoaXMuX3BhcmVudCB8fCAocCAmJiBwLl9kZXNpZ25TZXQgIT0gdGhpcy5fcGFyZW50Ll9kZXNpZ25TZXQpO1xuXG4gICAgICB0aGlzLl9wYXJlbnQgPSBwO1xuXG4gICAgICBpZiAodGhpcy50eXBlID09IGRlc2lnbi5kZWZhdWx0VHlwZSAmJiBkZXNpZ25TZXRDaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMuakNhbFtUWVBFX0lOREVYXSA9IHRoaXMuZ2V0RGVmYXVsdFR5cGUoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlVHlwZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGRlc2lnbiBzZXQgZm9yIHRoaXMgcHJvcGVydHksIGUuZy4gaWNhbGVuZGFyIHZzIHZjYXJkXG4gICAgICpcbiAgICAgKiBAdHlwZSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0IF9kZXNpZ25TZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5fZGVzaWduU2V0IDogZGVzaWduLmRlZmF1bHRTZXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHR5cGUgbWV0YWRhdGEgZnJvbSB0aGUgY3VycmVudCBqQ2FsIHR5cGUgYW5kIGRlc2lnbiBzZXQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVUeXBlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkZXNpZ25TZXQgPSB0aGlzLl9kZXNpZ25TZXQ7XG5cbiAgICAgIGlmICh0aGlzLnR5cGUgaW4gZGVzaWduU2V0LnZhbHVlKSB7XG4gICAgICAgIHZhciBkZXNpZ25UeXBlID0gZGVzaWduU2V0LnZhbHVlW3RoaXMudHlwZV07XG5cbiAgICAgICAgaWYgKCdkZWNvcmF0ZScgaW4gZGVzaWduU2V0LnZhbHVlW3RoaXMudHlwZV0pIHtcbiAgICAgICAgICB0aGlzLmlzRGVjb3JhdGVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmlzRGVjb3JhdGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5uYW1lIGluIGRlc2lnblNldC5wcm9wZXJ0eSkge1xuICAgICAgICAgIHRoaXMuaXNNdWx0aVZhbHVlID0gKCdtdWx0aVZhbHVlJyBpbiBkZXNpZ25TZXQucHJvcGVydHlbdGhpcy5uYW1lXSk7XG4gICAgICAgICAgdGhpcy5pc1N0cnVjdHVyZWRWYWx1ZSA9ICgnc3RydWN0dXJlZFZhbHVlJyBpbiBkZXNpZ25TZXQucHJvcGVydHlbdGhpcy5uYW1lXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSHlkcmF0ZSBhIHNpbmdsZSB2YWx1ZS4gVGhlIGFjdCBvZiBoeWRyYXRpbmcgbWVhbnMgdHVybmluZyB0aGUgcmF3IGpDYWxcbiAgICAgKiB2YWx1ZSBpbnRvIGEgcG90ZW50aWFsbHkgd3JhcHBlZCBvYmplY3QsIGZvciBleGFtcGxlIHtAbGluayBJQ0FMLlRpbWV9LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggICAgICAgIFRoZSBpbmRleCBvZiB0aGUgdmFsdWUgdG8gaHlkcmF0ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgVGhlIGRlY29yYXRlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBfaHlkcmF0ZVZhbHVlOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgaWYgKHRoaXMuX3ZhbHVlcyAmJiB0aGlzLl92YWx1ZXNbaW5kZXhdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZXNbaW5kZXhdO1xuICAgICAgfVxuXG4gICAgICAvLyBmb3IgdGhlIGNhc2Ugd2hlcmUgdGhlcmUgaXMgbm8gdmFsdWUuXG4gICAgICBpZiAodGhpcy5qQ2FsLmxlbmd0aCA8PSAoVkFMVUVfSU5ERVggKyBpbmRleCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmlzRGVjb3JhdGVkKSB7XG4gICAgICAgIGlmICghdGhpcy5fdmFsdWVzKSB7XG4gICAgICAgICAgdGhpcy5fdmFsdWVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0aGlzLl92YWx1ZXNbaW5kZXhdID0gdGhpcy5fZGVjb3JhdGUoXG4gICAgICAgICAgdGhpcy5qQ2FsW1ZBTFVFX0lOREVYICsgaW5kZXhdXG4gICAgICAgICkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuakNhbFtWQUxVRV9JTkRFWCArIGluZGV4XTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVjb3JhdGUgYSBzaW5nbGUgdmFsdWUsIHJldHVybmluZyBpdHMgd3JhcHBlZCBvYmplY3QuIFRoaXMgaXMgdXNlZCBieVxuICAgICAqIHRoZSBoeWRyYXRlIGZ1bmN0aW9uIHRvIGFjdHVhbGx5IHdyYXAgdGhlIHZhbHVlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlICAgICAgICAgVGhlIHZhbHVlIHRvIGRlY29yYXRlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgIFRoZSBkZWNvcmF0ZWQgdmFsdWVcbiAgICAgKi9cbiAgICBfZGVjb3JhdGU6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGVzaWduU2V0LnZhbHVlW3RoaXMudHlwZV0uZGVjb3JhdGUodmFsdWUsIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbmRlY29yYXRlIGEgc2luZ2xlIHZhbHVlLCByZXR1cm5pbmcgaXRzIHJhdyBqQ2FsIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSAgICAgICAgIFRoZSB2YWx1ZSB0byB1bmRlY29yYXRlXG4gICAgICogQHJldHVybiB7P30gICAgICAgICAgICAgICAgICAgVGhlIHVuZGVjb3JhdGVkIHZhbHVlXG4gICAgICovXG4gICAgX3VuZGVjb3JhdGU6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGVzaWduU2V0LnZhbHVlW3RoaXMudHlwZV0udW5kZWNvcmF0ZSh2YWx1ZSwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlIGF0IHRoZSBnaXZlbiBpbmRleCB3aGlsZSBhbHNvIGh5ZHJhdGluZyBpdC4gVGhlIHBhc3NlZFxuICAgICAqIHZhbHVlIGNhbiBlaXRoZXIgYmUgYSBkZWNvcmF0ZWQgb3IgdW5kZWNvcmF0ZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWUgICAgICAgICAgICAgVGhlIHZhbHVlIHRvIHNldFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAgICAgICAgVGhlIGluZGV4IHRvIHNldCBpdCBhdFxuICAgICAqL1xuICAgIF9zZXREZWNvcmF0ZWRWYWx1ZTogZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgICBpZiAoIXRoaXMuX3ZhbHVlcykge1xuICAgICAgICB0aGlzLl92YWx1ZXMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZih2YWx1ZSkgPT09ICdvYmplY3QnICYmICdpY2FsdHlwZScgaW4gdmFsdWUpIHtcbiAgICAgICAgLy8gZGVjb3JhdGVkIHZhbHVlXG4gICAgICAgIHRoaXMuakNhbFtWQUxVRV9JTkRFWCArIGluZGV4XSA9IHRoaXMuX3VuZGVjb3JhdGUodmFsdWUpO1xuICAgICAgICB0aGlzLl92YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1bmRlY29yYXRlZCB2YWx1ZVxuICAgICAgICB0aGlzLmpDYWxbVkFMVUVfSU5ERVggKyBpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fdmFsdWVzW2luZGV4XSA9IHRoaXMuX2RlY29yYXRlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIHBhcmFtZXRlciBvbiB0aGUgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICAgICAgIG5hbWUgICBQYXJhbWV0ZXIgbmFtZSAobG93ZXJjYXNlKVxuICAgICAqIEByZXR1cm4ge0FycmF5fFN0cmluZ30gICAgICAgIFBhcmFtZXRlciB2YWx1ZVxuICAgICAqL1xuICAgIGdldFBhcmFtZXRlcjogZnVuY3Rpb24obmFtZSkge1xuICAgICAgaWYgKG5hbWUgaW4gdGhpcy5qQ2FsW1BST1BfSU5ERVhdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmpDYWxbUFJPUF9JTkRFWF1bbmFtZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGZpcnN0IHBhcmFtZXRlciBvbiB0aGUgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICAgICAgIG5hbWUgICBQYXJhbWV0ZXIgbmFtZSAobG93ZXJjYXNlKVxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgIFBhcmFtZXRlciB2YWx1ZVxuICAgICAqL1xuICAgIGdldEZpcnN0UGFyYW1ldGVyOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgcGFyYW1ldGVycyA9IHRoaXMuZ2V0UGFyYW1ldGVyKG5hbWUpO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbWV0ZXJzKSkge1xuICAgICAgICByZXR1cm4gcGFyYW1ldGVyc1swXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcmFtZXRlcnM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgYSBwYXJhbWV0ZXIgb24gdGhlIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgICAgIG5hbWUgICAgIFRoZSBwYXJhbWV0ZXIgbmFtZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSB2YWx1ZSAgICBUaGUgcGFyYW1ldGVyIHZhbHVlXG4gICAgICovXG4gICAgc2V0UGFyYW1ldGVyOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIGxjbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICBsY25hbWUgaW4gdGhpcy5fZGVzaWduU2V0LnBhcmFtICYmXG4gICAgICAgICAgJ211bHRpVmFsdWUnIGluIHRoaXMuX2Rlc2lnblNldC5wYXJhbVtsY25hbWVdKSB7XG4gICAgICAgICAgdmFsdWUgPSBbdmFsdWVdO1xuICAgICAgfVxuICAgICAgdGhpcy5qQ2FsW1BST1BfSU5ERVhdW25hbWVdID0gdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBwYXJhbWV0ZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lICAgICBUaGUgcGFyYW1ldGVyIG5hbWVcbiAgICAgKi9cbiAgICByZW1vdmVQYXJhbWV0ZXI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmpDYWxbUFJPUF9JTkRFWF1bbmFtZV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZGVmYXVsdCB0eXBlIGJhc2VkIG9uIHRoaXMgcHJvcGVydHkncyBuYW1lLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgVGhlIGRlZmF1bHQgdHlwZSBmb3IgdGhpcyBwcm9wZXJ0eVxuICAgICAqL1xuICAgIGdldERlZmF1bHRUeXBlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBuYW1lID0gdGhpcy5qQ2FsW05BTUVfSU5ERVhdO1xuICAgICAgdmFyIGRlc2lnblNldCA9IHRoaXMuX2Rlc2lnblNldDtcblxuICAgICAgaWYgKG5hbWUgaW4gZGVzaWduU2V0LnByb3BlcnR5KSB7XG4gICAgICAgIHZhciBkZXRhaWxzID0gZGVzaWduU2V0LnByb3BlcnR5W25hbWVdO1xuICAgICAgICBpZiAoJ2RlZmF1bHRUeXBlJyBpbiBkZXRhaWxzKSB7XG4gICAgICAgICAgcmV0dXJuIGRldGFpbHMuZGVmYXVsdFR5cGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXNpZ24uZGVmYXVsdFR5cGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdHlwZSBvZiBwcm9wZXJ0eSBhbmQgY2xlYXJzIG91dCBhbnkgZXhpc3RpbmcgdmFsdWVzIG9mIHRoZSBjdXJyZW50XG4gICAgICogdHlwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlICAgICBOZXcgaUNBTCB0eXBlIChzZWUgZGVzaWduLioudmFsdWVzKVxuICAgICAqL1xuICAgIHJlc2V0VHlwZTogZnVuY3Rpb24odHlwZSkge1xuICAgICAgdGhpcy5yZW1vdmVBbGxWYWx1ZXMoKTtcbiAgICAgIHRoaXMuakNhbFtUWVBFX0lOREVYXSA9IHR5cGU7XG4gICAgICB0aGlzLl91cGRhdGVUeXBlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBmaXJzdCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICBGaXJzdCBwcm9wZXJ0eSB2YWx1ZVxuICAgICAqL1xuICAgIGdldEZpcnN0VmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2h5ZHJhdGVWYWx1ZSgwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgdmFsdWVzIG9uIHRoZSBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIE5PVEU6IHRoaXMgY3JlYXRlcyBhbiBhcnJheSBkdXJpbmcgZWFjaCBjYWxsLlxuICAgICAqXG4gICAgICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgIExpc3Qgb2YgdmFsdWVzXG4gICAgICovXG4gICAgZ2V0VmFsdWVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsZW4gPSB0aGlzLmpDYWwubGVuZ3RoIC0gVkFMVUVfSU5ERVg7XG5cbiAgICAgIGlmIChsZW4gPCAxKSB7XG4gICAgICAgIC8vIGl0IGlzIHBvc3NpYmxlIGZvciBhIHByb3BlcnR5IHRvIGhhdmUgbm8gdmFsdWUuXG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHJlc3VsdFtpXSA9IHRoaXMuX2h5ZHJhdGVWYWx1ZShpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgdmFsdWVzIGZyb20gdGhpcyBwcm9wZXJ0eVxuICAgICAqL1xuICAgIHJlbW92ZUFsbFZhbHVlczogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5fdmFsdWVzKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlcy5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgICAgdGhpcy5qQ2FsLmxlbmd0aCA9IDM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlcyBvZiB0aGUgcHJvcGVydHkuICBXaWxsIG92ZXJ3cml0ZSB0aGUgZXhpc3RpbmcgdmFsdWVzLlxuICAgICAqIFRoaXMgY2FuIG9ubHkgYmUgdXNlZCBmb3IgbXVsdGktdmFsdWUgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyAgICBBbiBhcnJheSBvZiB2YWx1ZXNcbiAgICAgKi9cbiAgICBzZXRWYWx1ZXM6IGZ1bmN0aW9uKHZhbHVlcykge1xuICAgICAgaWYgKCF0aGlzLmlzTXVsdGlWYWx1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgdGhpcy5uYW1lICsgJzogZG9lcyBub3Qgbm90IHN1cHBvcnQgbXVsaXRWYWx1ZS5cXG4nICtcbiAgICAgICAgICAnb3ZlcnJpZGUgaXNNdWx0aVZhbHVlJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuID0gdmFsdWVzLmxlbmd0aDtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHRoaXMucmVtb3ZlQWxsVmFsdWVzKCk7XG5cbiAgICAgIGlmIChsZW4gPiAwICYmXG4gICAgICAgICAgdHlwZW9mKHZhbHVlc1swXSkgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgJ2ljYWx0eXBlJyBpbiB2YWx1ZXNbMF0pIHtcbiAgICAgICAgdGhpcy5yZXNldFR5cGUodmFsdWVzWzBdLmljYWx0eXBlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNEZWNvcmF0ZWQpIHtcbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHRoaXMuX3NldERlY29yYXRlZFZhbHVlKHZhbHVlc1tpXSwgaSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICB0aGlzLmpDYWxbVkFMVUVfSU5ERVggKyBpXSA9IHZhbHVlc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBwcm9wZXJ0eS4gSWYgdGhpcyBpcyBhIG11bHRpLXZhbHVlXG4gICAgICogcHJvcGVydHksIGFsbCBvdGhlciB2YWx1ZXMgd2lsbCBiZSByZW1vdmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSB2YWx1ZSAgICAgTmV3IHByb3BlcnR5IHZhbHVlLlxuICAgICAqL1xuICAgIHNldFZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdGhpcy5yZW1vdmVBbGxWYWx1ZXMoKTtcbiAgICAgIGlmICh0eXBlb2YodmFsdWUpID09PSAnb2JqZWN0JyAmJiAnaWNhbHR5cGUnIGluIHZhbHVlKSB7XG4gICAgICAgIHRoaXMucmVzZXRUeXBlKHZhbHVlLmljYWx0eXBlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNEZWNvcmF0ZWQpIHtcbiAgICAgICAgdGhpcy5fc2V0RGVjb3JhdGVkVmFsdWUodmFsdWUsIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5qQ2FsW1ZBTFVFX0lOREVYXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBjb21wb25lbnQuIFRoZSByZXR1cm5lZCBvYmplY3RcbiAgICAgKiBpcyBhIGxpdmUgakNhbCBvYmplY3QgYW5kIHNob3VsZCBiZSBjbG9uZWQgaWYgbW9kaWZpZWQuXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5qQ2FsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgY29tcG9uZW50LlxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICB0b0lDQUxTdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIElDQUwuc3RyaW5naWZ5LnByb3BlcnR5KFxuICAgICAgICB0aGlzLmpDYWwsIHRoaXMuX2Rlc2lnblNldCwgdHJ1ZVxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiB7QGxpbmsgSUNBTC5Qcm9wZXJ0eX0gYnkgcGFyc2luZyB0aGUgcGFzc2VkIGlDYWxlbmRhciBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgICAgICAgICAgICAgICAgICAgICAgICBUaGUgaUNhbGVuZGFyIHN0cmluZyB0byBwYXJzZVxuICAgKiBAcGFyYW0ge0lDQUwuZGVzaWduLmRlc2lnblNldD19IGRlc2lnblNldCAgVGhlIGRlc2lnbiBkYXRhIHRvIHVzZSBmb3IgdGhpcyBwcm9wZXJ0eVxuICAgKiBAcmV0dXJuIHtJQ0FMLlByb3BlcnR5fSAgICAgICAgICAgICAgICAgICAgVGhlIGNyZWF0ZWQgaUNhbGVuZGFyIHByb3BlcnR5XG4gICAqL1xuICBQcm9wZXJ0eS5mcm9tU3RyaW5nID0gZnVuY3Rpb24oc3RyLCBkZXNpZ25TZXQpIHtcbiAgICByZXR1cm4gbmV3IFByb3BlcnR5KElDQUwucGFyc2UucHJvcGVydHkoc3RyLCBkZXNpZ25TZXQpKTtcbiAgfTtcblxuICByZXR1cm4gUHJvcGVydHk7XG59KCkpO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoLCAyMDExLTIwMTUgKi9cblxuXG4vKipcbiAqIFRoaXMgc3ltYm9sIGlzIGZ1cnRoZXIgZGVzY3JpYmVkIGxhdGVyIG9uXG4gKiBAaWdub3JlXG4gKi9cbklDQUwuVXRjT2Zmc2V0ID0gKGZ1bmN0aW9uKCkge1xuXG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIFRoaXMgY2xhc3MgcmVwcmVzZW50cyB0aGUgXCJkdXJhdGlvblwiIHZhbHVlIHR5cGUsIHdpdGggdmFyaW91cyBjYWxjdWxhdGlvblxuICAgKiBhbmQgbWFuaXB1bGF0aW9uIG1ldGhvZHMuXG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAYWxpYXMgSUNBTC5VdGNPZmZzZXRcbiAgICogQHBhcmFtIHtPYmplY3R9IGFEYXRhICAgICAgICAgIEFuIG9iamVjdCB3aXRoIG1lbWJlcnMgb2YgdGhlIHV0YyBvZmZzZXRcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5ob3VycyAgIFRoZSBob3VycyBmb3IgdGhlIHV0YyBvZmZzZXRcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5taW51dGVzIFRoZSBtaW51dGVzIGluIHRoZSB1dGMgb2Zmc2V0XG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEuZmFjdG9yICBUaGUgZmFjdG9yIGZvciB0aGUgdXRjLW9mZnNldCwgZWl0aGVyIC0xIG9yIDFcbiAgICovXG4gIGZ1bmN0aW9uIFV0Y09mZnNldChhRGF0YSkge1xuICAgIHRoaXMuZnJvbURhdGEoYURhdGEpO1xuICB9XG5cbiAgVXRjT2Zmc2V0LnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIFRoZSBob3VycyBpbiB0aGUgdXRjLW9mZnNldFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgaG91cnM6IDAsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWludXRlcyBpbiB0aGUgdXRjLW9mZnNldFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgbWludXRlczogMCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzaWduIG9mIHRoZSB1dGMgb2Zmc2V0LCAxIGZvciBwb3NpdGl2ZSBvZmZzZXQsIC0xIGZvciBuZWdhdGl2ZVxuICAgICAqIG9mZnNldHMuXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBmYWN0b3I6IDEsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBuYW1lLCB0byBiZSB1c2VkIGluIHRoZSBqQ2FsIG9iamVjdC5cbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IFwidXRjLW9mZnNldFwiXG4gICAgICovXG4gICAgaWNhbHR5cGU6IFwidXRjLW9mZnNldFwiLFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSB1dGMgb2Zmc2V0IG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0lDQUwuVXRjT2Zmc2V0fSAgICAgVGhlIGNsb25lZCBvYmplY3RcbiAgICAgKi9cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gSUNBTC5VdGNPZmZzZXQuZnJvbVNlY29uZHModGhpcy50b1NlY29uZHMoKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdXAgdGhlIGN1cnJlbnQgaW5zdGFuY2UgdXNpbmcgbWVtYmVycyBmcm9tIHRoZSBwYXNzZWQgZGF0YSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYURhdGEgICAgICAgICAgQW4gb2JqZWN0IHdpdGggbWVtYmVycyBvZiB0aGUgdXRjIG9mZnNldFxuICAgICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEuaG91cnMgICBUaGUgaG91cnMgZm9yIHRoZSB1dGMgb2Zmc2V0XG4gICAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5taW51dGVzIFRoZSBtaW51dGVzIGluIHRoZSB1dGMgb2Zmc2V0XG4gICAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5mYWN0b3IgIFRoZSBmYWN0b3IgZm9yIHRoZSB1dGMtb2Zmc2V0LCBlaXRoZXIgLTEgb3IgMVxuICAgICAqL1xuICAgIGZyb21EYXRhOiBmdW5jdGlvbihhRGF0YSkge1xuICAgICAgaWYgKGFEYXRhKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBhRGF0YSkge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgaWYgKGFEYXRhLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIHRoaXNba2V5XSA9IGFEYXRhW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9ub3JtYWxpemUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB1cCB0aGUgY3VycmVudCBpbnN0YW5jZSBmcm9tIHRoZSBnaXZlbiBzZWNvbmRzIHZhbHVlLiBUaGUgc2Vjb25kc1xuICAgICAqIHZhbHVlIGlzIHRydW5jYXRlZCB0byB0aGUgbWludXRlLiBPZmZzZXRzIGFyZSB3cmFwcGVkIHdoZW4gdGhlIHdvcmxkXG4gICAgICogZW5kcywgdGhlIGhvdXIgYWZ0ZXIgVVRDKzE0OjAwIGlzIFVUQy0xMjowMC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhU2Vjb25kcyAgICAgICAgIFRoZSBzZWNvbmRzIHRvIGNvbnZlcnQgaW50byBhbiBvZmZzZXRcbiAgICAgKi9cbiAgICBmcm9tU2Vjb25kczogZnVuY3Rpb24oYVNlY29uZHMpIHtcbiAgICAgIHZhciBzZWNzID0gTWF0aC5hYnMoYVNlY29uZHMpO1xuXG4gICAgICB0aGlzLmZhY3RvciA9IGFTZWNvbmRzIDwgMCA/IC0xIDogMTtcbiAgICAgIHRoaXMuaG91cnMgPSBJQ0FMLmhlbHBlcnMudHJ1bmMoc2VjcyAvIDM2MDApO1xuXG4gICAgICBzZWNzIC09ICh0aGlzLmhvdXJzICogMzYwMCk7XG4gICAgICB0aGlzLm1pbnV0ZXMgPSBJQ0FMLmhlbHBlcnMudHJ1bmMoc2VjcyAvIDYwKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBjdXJyZW50IG9mZnNldCB0byBhIHZhbHVlIGluIHNlY29uZHNcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgICAgIFRoZSBvZmZzZXQgaW4gc2Vjb25kc1xuICAgICAqL1xuICAgIHRvU2Vjb25kczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5mYWN0b3IgKiAoNjAgKiB0aGlzLm1pbnV0ZXMgKyAzNjAwICogdGhpcy5ob3Vycyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbXBhcmUgdGhpcyB1dGMgb2Zmc2V0IHdpdGggYW5vdGhlciBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuVXRjT2Zmc2V0fSBvdGhlciAgICAgICAgVGhlIG90aGVyIG9mZnNldCB0byBjb21wYXJlIHdpdGhcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgICAgICAgICAgLTEsIDAgb3IgMSBmb3IgbGVzcy9lcXVhbC9ncmVhdGVyXG4gICAgICovXG4gICAgY29tcGFyZTogZnVuY3Rpb24gaWNhbHRpbWVfY29tcGFyZShvdGhlcikge1xuICAgICAgdmFyIGEgPSB0aGlzLnRvU2Vjb25kcygpO1xuICAgICAgdmFyIGIgPSBvdGhlci50b1NlY29uZHMoKTtcbiAgICAgIHJldHVybiAoYSA+IGIpIC0gKGIgPiBhKTtcbiAgICB9LFxuXG4gICAgX25vcm1hbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBSYW5nZTogOTcyMDAgc2Vjb25kcyAod2l0aCAxIGhvdXIgaW5iZXR3ZWVuKVxuICAgICAgdmFyIHNlY3MgPSB0aGlzLnRvU2Vjb25kcygpO1xuICAgICAgdmFyIGZhY3RvciA9IHRoaXMuZmFjdG9yO1xuICAgICAgd2hpbGUgKHNlY3MgPCAtNDMyMDApIHsgLy8gPSBVVEMtMTI6MDBcbiAgICAgICAgc2VjcyArPSA5NzIwMDtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChzZWNzID4gNTA0MDApIHsgLy8gPSBVVEMrMTQ6MDBcbiAgICAgICAgc2VjcyAtPSA5NzIwMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5mcm9tU2Vjb25kcyhzZWNzKTtcblxuICAgICAgLy8gQXZvaWQgY2hhbmdpbmcgdGhlIGZhY3RvciB3aGVuIG9uIHplcm8gc2Vjb25kc1xuICAgICAgaWYgKHNlY3MgPT0gMCkge1xuICAgICAgICB0aGlzLmZhY3RvciA9IGZhY3RvcjtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGlDYWxlbmRhciBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB1dGMtb2Zmc2V0LlxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICB0b0lDQUxTdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIElDQUwuZGVzaWduLmljYWxlbmRhci52YWx1ZVsndXRjLW9mZnNldCddLnRvSUNBTCh0aGlzLnRvU3RyaW5nKCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdXRjLW9mZnNldC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICh0aGlzLmZhY3RvciA9PSAxID8gXCIrXCIgOiBcIi1cIikgK1xuICAgICAgICAgICAgICBJQ0FMLmhlbHBlcnMucGFkMih0aGlzLmhvdXJzKSArICc6JyArXG4gICAgICAgICAgICAgIElDQUwuaGVscGVycy5wYWQyKHRoaXMubWludXRlcyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBJQ0FMLlV0Y09mZnNldH0gaW5zdGFuY2UgZnJvbSB0aGUgcGFzc2VkIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFTdHJpbmcgICAgVGhlIHN0cmluZyB0byBwYXJzZVxuICAgKiBAcmV0dXJuIHtJQ0FMLkR1cmF0aW9ufSAgICBUaGUgY3JlYXRlZCB1dGMtb2Zmc2V0IGluc3RhbmNlXG4gICAqL1xuICBVdGNPZmZzZXQuZnJvbVN0cmluZyA9IGZ1bmN0aW9uKGFTdHJpbmcpIHtcbiAgICAvLyAtMDU6MDBcbiAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgIC8vVE9ETzogc3VwcG9ydCBzZWNvbmRzIHBlciByZmM1NTQ1ID9cbiAgICBvcHRpb25zLmZhY3RvciA9IChhU3RyaW5nWzBdID09PSAnKycpID8gMSA6IC0xO1xuICAgIG9wdGlvbnMuaG91cnMgPSBJQ0FMLmhlbHBlcnMuc3RyaWN0UGFyc2VJbnQoYVN0cmluZy5zdWJzdHIoMSwgMikpO1xuICAgIG9wdGlvbnMubWludXRlcyA9IElDQUwuaGVscGVycy5zdHJpY3RQYXJzZUludChhU3RyaW5nLnN1YnN0cig0LCAyKSk7XG5cbiAgICByZXR1cm4gbmV3IElDQUwuVXRjT2Zmc2V0KG9wdGlvbnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBJQ0FMLlV0Y09mZnNldH0gaW5zdGFuY2UgZnJvbSB0aGUgcGFzc2VkIHNlY29uZHNcbiAgICogdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhU2Vjb25kcyAgICAgICBUaGUgbnVtYmVyIG9mIHNlY29uZHMgdG8gY29udmVydFxuICAgKi9cbiAgVXRjT2Zmc2V0LmZyb21TZWNvbmRzID0gZnVuY3Rpb24oYVNlY29uZHMpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBuZXcgVXRjT2Zmc2V0KCk7XG4gICAgaW5zdGFuY2UuZnJvbVNlY29uZHMoYVNlY29uZHMpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcblxuICByZXR1cm4gVXRjT2Zmc2V0O1xufSgpKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAxMS0yMDE1ICovXG5cblxuLyoqXG4gKiBUaGlzIHN5bWJvbCBpcyBmdXJ0aGVyIGRlc2NyaWJlZCBsYXRlciBvblxuICogQGlnbm9yZVxuICovXG5JQ0FMLkJpbmFyeSA9IChmdW5jdGlvbigpIHtcblxuICAvKipcbiAgICogQGNsYXNzZGVzY1xuICAgKiBSZXByZXNlbnRzIHRoZSBCSU5BUlkgdmFsdWUgdHlwZSwgd2hpY2ggY29udGFpbnMgZXh0cmEgbWV0aG9kcyBmb3JcbiAgICogZW5jb2RpbmcgYW5kIGRlY29kaW5nLlxuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQGFsaWFzIElDQUwuQmluYXJ5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhVmFsdWUgICAgIFRoZSBiaW5hcnkgZGF0YSBmb3IgdGhpcyB2YWx1ZVxuICAgKi9cbiAgZnVuY3Rpb24gQmluYXJ5KGFWYWx1ZSkge1xuICAgIHRoaXMudmFsdWUgPSBhVmFsdWU7XG4gIH1cblxuICBCaW5hcnkucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG5hbWUsIHRvIGJlIHVzZWQgaW4gdGhlIGpDYWwgb2JqZWN0LlxuICAgICAqIEBkZWZhdWx0IFwiYmluYXJ5XCJcbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKi9cbiAgICBpY2FsdHlwZTogXCJiaW5hcnlcIixcblxuICAgIC8qKlxuICAgICAqIEJhc2U2NCBkZWNvZGUgdGhlIGN1cnJlbnQgdmFsdWVcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICBUaGUgYmFzZTY0LWRlY29kZWQgdmFsdWVcbiAgICAgKi9cbiAgICBkZWNvZGVWYWx1ZTogZnVuY3Rpb24gZGVjb2RlVmFsdWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYjY0X2RlY29kZSh0aGlzLnZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRW5jb2RlcyB0aGUgcGFzc2VkIHBhcmFtZXRlciB3aXRoIGJhc2U2NCBhbmQgc2V0cyB0aGUgaW50ZXJuYWxcbiAgICAgKiB2YWx1ZSB0byB0aGUgcmVzdWx0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFWYWx1ZSAgICAgIFRoZSByYXcgYmluYXJ5IHZhbHVlIHRvIGVuY29kZVxuICAgICAqL1xuICAgIHNldEVuY29kZWRWYWx1ZTogZnVuY3Rpb24gc2V0RW5jb2RlZFZhbHVlKGFWYWx1ZSkge1xuICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuX2I2NF9lbmNvZGUoYVZhbHVlKTtcbiAgICB9LFxuXG4gICAgX2I2NF9lbmNvZGU6IGZ1bmN0aW9uIGJhc2U2NF9lbmNvZGUoZGF0YSkge1xuICAgICAgLy8gaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXRcbiAgICAgIC8vICsgICBvcmlnaW5hbCBieTogVHlsZXIgQWtpbnMgKGh0dHA6Ly9ydW1raW4uY29tKVxuICAgICAgLy8gKyAgIGltcHJvdmVkIGJ5OiBCYXlyb24gR3VldmFyYVxuICAgICAgLy8gKyAgIGltcHJvdmVkIGJ5OiBUaHVuZGVyLm1cbiAgICAgIC8vICsgICBpbXByb3ZlZCBieTogS2V2aW4gdmFuIFpvbm5ldmVsZCAoaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXQpXG4gICAgICAvLyArICAgYnVnZml4ZWQgYnk6IFBlbGxlbnRlc3F1ZSBNYWxlc3VhZGFcbiAgICAgIC8vICsgICBpbXByb3ZlZCBieTogS2V2aW4gdmFuIFpvbm5ldmVsZCAoaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXQpXG4gICAgICAvLyArICAgaW1wcm92ZWQgYnk6IFJhZmFcdTAxNDIgS3VrYXdza2kgKGh0dHA6Ly9rdWthd3NraS5wbClcbiAgICAgIC8vICogICAgIGV4YW1wbGUgMTogYmFzZTY0X2VuY29kZSgnS2V2aW4gdmFuIFpvbm5ldmVsZCcpO1xuICAgICAgLy8gKiAgICAgcmV0dXJucyAxOiAnUzJWMmFXNGdkbUZ1SUZwdmJtNWxkbVZzWkE9PSdcbiAgICAgIC8vIG1vemlsbGEgaGFzIHRoaXMgbmF0aXZlXG4gICAgICAvLyAtIGJ1dCBicmVha3MgaW4gMi4wLjAuMTIhXG4gICAgICAvL2lmICh0eXBlb2YgdGhpcy53aW5kb3dbJ2F0b2InXSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyAgICByZXR1cm4gYXRvYihkYXRhKTtcbiAgICAgIC8vfVxuICAgICAgdmFyIGI2NCA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpcIiArXG4gICAgICAgICAgICAgICAgXCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cIjtcbiAgICAgIHZhciBvMSwgbzIsIG8zLCBoMSwgaDIsIGgzLCBoNCwgYml0cywgaSA9IDAsXG4gICAgICAgIGFjID0gMCxcbiAgICAgICAgZW5jID0gXCJcIixcbiAgICAgICAgdG1wX2FyciA9IFtdO1xuXG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9XG5cbiAgICAgIGRvIHsgLy8gcGFjayB0aHJlZSBvY3RldHMgaW50byBmb3VyIGhleGV0c1xuICAgICAgICBvMSA9IGRhdGEuY2hhckNvZGVBdChpKyspO1xuICAgICAgICBvMiA9IGRhdGEuY2hhckNvZGVBdChpKyspO1xuICAgICAgICBvMyA9IGRhdGEuY2hhckNvZGVBdChpKyspO1xuXG4gICAgICAgIGJpdHMgPSBvMSA8PCAxNiB8IG8yIDw8IDggfCBvMztcblxuICAgICAgICBoMSA9IGJpdHMgPj4gMTggJiAweDNmO1xuICAgICAgICBoMiA9IGJpdHMgPj4gMTIgJiAweDNmO1xuICAgICAgICBoMyA9IGJpdHMgPj4gNiAmIDB4M2Y7XG4gICAgICAgIGg0ID0gYml0cyAmIDB4M2Y7XG5cbiAgICAgICAgLy8gdXNlIGhleGV0cyB0byBpbmRleCBpbnRvIGI2NCwgYW5kIGFwcGVuZCByZXN1bHQgdG8gZW5jb2RlZCBzdHJpbmdcbiAgICAgICAgdG1wX2FyclthYysrXSA9IGI2NC5jaGFyQXQoaDEpICsgYjY0LmNoYXJBdChoMikgKyBiNjQuY2hhckF0KGgzKSArIGI2NC5jaGFyQXQoaDQpO1xuICAgICAgfSB3aGlsZSAoaSA8IGRhdGEubGVuZ3RoKTtcblxuICAgICAgZW5jID0gdG1wX2Fyci5qb2luKCcnKTtcblxuICAgICAgdmFyIHIgPSBkYXRhLmxlbmd0aCAlIDM7XG5cbiAgICAgIHJldHVybiAociA/IGVuYy5zbGljZSgwLCByIC0gMykgOiBlbmMpICsgJz09PScuc2xpY2UociB8fCAzKTtcblxuICAgIH0sXG5cbiAgICBfYjY0X2RlY29kZTogZnVuY3Rpb24gYmFzZTY0X2RlY29kZShkYXRhKSB7XG4gICAgICAvLyBodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldFxuICAgICAgLy8gKyAgIG9yaWdpbmFsIGJ5OiBUeWxlciBBa2lucyAoaHR0cDovL3J1bWtpbi5jb20pXG4gICAgICAvLyArICAgaW1wcm92ZWQgYnk6IFRodW5kZXIubVxuICAgICAgLy8gKyAgICAgIGlucHV0IGJ5OiBBbWFuIEd1cHRhXG4gICAgICAvLyArICAgaW1wcm92ZWQgYnk6IEtldmluIHZhbiBab25uZXZlbGQgKGh0dHA6Ly9rZXZpbi52YW56b25uZXZlbGQubmV0KVxuICAgICAgLy8gKyAgIGJ1Z2ZpeGVkIGJ5OiBPbm5vIE1hcnNtYW5cbiAgICAgIC8vICsgICBidWdmaXhlZCBieTogUGVsbGVudGVzcXVlIE1hbGVzdWFkYVxuICAgICAgLy8gKyAgIGltcHJvdmVkIGJ5OiBLZXZpbiB2YW4gWm9ubmV2ZWxkIChodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldClcbiAgICAgIC8vICsgICAgICBpbnB1dCBieTogQnJldHQgWmFtaXIgKGh0dHA6Ly9icmV0dC16YW1pci5tZSlcbiAgICAgIC8vICsgICBidWdmaXhlZCBieTogS2V2aW4gdmFuIFpvbm5ldmVsZCAoaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXQpXG4gICAgICAvLyAqICAgICBleGFtcGxlIDE6IGJhc2U2NF9kZWNvZGUoJ1MyVjJhVzRnZG1GdUlGcHZibTVsZG1Wc1pBPT0nKTtcbiAgICAgIC8vICogICAgIHJldHVybnMgMTogJ0tldmluIHZhbiBab25uZXZlbGQnXG4gICAgICAvLyBtb3ppbGxhIGhhcyB0aGlzIG5hdGl2ZVxuICAgICAgLy8gLSBidXQgYnJlYWtzIGluIDIuMC4wLjEyIVxuICAgICAgLy9pZiAodHlwZW9mIHRoaXMud2luZG93WydidG9hJ10gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gICAgcmV0dXJuIGJ0b2EoZGF0YSk7XG4gICAgICAvL31cbiAgICAgIHZhciBiNjQgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXCIgK1xuICAgICAgICAgICAgICAgIFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCI7XG4gICAgICB2YXIgbzEsIG8yLCBvMywgaDEsIGgyLCBoMywgaDQsIGJpdHMsIGkgPSAwLFxuICAgICAgICBhYyA9IDAsXG4gICAgICAgIGRlYyA9IFwiXCIsXG4gICAgICAgIHRtcF9hcnIgPSBbXTtcblxuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuXG4gICAgICBkYXRhICs9ICcnO1xuXG4gICAgICBkbyB7IC8vIHVucGFjayBmb3VyIGhleGV0cyBpbnRvIHRocmVlIG9jdGV0cyB1c2luZyBpbmRleCBwb2ludHMgaW4gYjY0XG4gICAgICAgIGgxID0gYjY0LmluZGV4T2YoZGF0YS5jaGFyQXQoaSsrKSk7XG4gICAgICAgIGgyID0gYjY0LmluZGV4T2YoZGF0YS5jaGFyQXQoaSsrKSk7XG4gICAgICAgIGgzID0gYjY0LmluZGV4T2YoZGF0YS5jaGFyQXQoaSsrKSk7XG4gICAgICAgIGg0ID0gYjY0LmluZGV4T2YoZGF0YS5jaGFyQXQoaSsrKSk7XG5cbiAgICAgICAgYml0cyA9IGgxIDw8IDE4IHwgaDIgPDwgMTIgfCBoMyA8PCA2IHwgaDQ7XG5cbiAgICAgICAgbzEgPSBiaXRzID4+IDE2ICYgMHhmZjtcbiAgICAgICAgbzIgPSBiaXRzID4+IDggJiAweGZmO1xuICAgICAgICBvMyA9IGJpdHMgJiAweGZmO1xuXG4gICAgICAgIGlmIChoMyA9PSA2NCkge1xuICAgICAgICAgIHRtcF9hcnJbYWMrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG8xKTtcbiAgICAgICAgfSBlbHNlIGlmIChoNCA9PSA2NCkge1xuICAgICAgICAgIHRtcF9hcnJbYWMrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG8xLCBvMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG1wX2FyclthYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUobzEsIG8yLCBvMyk7XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKGkgPCBkYXRhLmxlbmd0aCk7XG5cbiAgICAgIGRlYyA9IHRtcF9hcnIuam9pbignJyk7XG5cbiAgICAgIHJldHVybiBkZWM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB2YWx1ZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBiaW5hcnkgdmFsdWUgZnJvbSB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYVN0cmluZyAgICAgICAgVGhlIGJpbmFyeSB2YWx1ZSBzdHJpbmdcbiAgICogQHJldHVybiB7SUNBTC5CaW5hcnl9ICAgICAgICAgIFRoZSBiaW5hcnkgdmFsdWUgaW5zdGFuY2VcbiAgICovXG4gIEJpbmFyeS5mcm9tU3RyaW5nID0gZnVuY3Rpb24oYVN0cmluZykge1xuICAgIHJldHVybiBuZXcgQmluYXJ5KGFTdHJpbmcpO1xuICB9O1xuXG4gIHJldHVybiBCaW5hcnk7XG59KCkpO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoLCAyMDExLTIwMTUgKi9cblxuXG5cbihmdW5jdGlvbigpIHtcbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogVGhpcyBjbGFzcyByZXByZXNlbnRzIHRoZSBcInBlcmlvZFwiIHZhbHVlIHR5cGUsIHdpdGggdmFyaW91cyBjYWxjdWxhdGlvblxuICAgKiBhbmQgbWFuaXB1bGF0aW9uIG1ldGhvZHMuXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBUaGUgcGFzc2VkIGRhdGEgb2JqZWN0IGNhbm5vdCBjb250YWluIGJvdGggYW5kIGVuZCBkYXRlIGFuZCBhIGR1cmF0aW9uLlxuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHtPYmplY3R9IGFEYXRhICAgICAgICAgICAgICAgICAgQW4gb2JqZWN0IHdpdGggbWVtYmVycyBvZiB0aGUgcGVyaW9kXG4gICAqIEBwYXJhbSB7SUNBTC5UaW1lPX0gYURhdGEuc3RhcnQgICAgICAgIFRoZSBzdGFydCBvZiB0aGUgcGVyaW9kXG4gICAqIEBwYXJhbSB7SUNBTC5UaW1lPX0gYURhdGEuZW5kICAgICAgICAgIFRoZSBlbmQgb2YgdGhlIHBlcmlvZFxuICAgKiBAcGFyYW0ge0lDQUwuRHVyYXRpb249fSBhRGF0YS5kdXJhdGlvbiBUaGUgZHVyYXRpb24gb2YgdGhlIHBlcmlvZFxuICAgKi9cbiAgSUNBTC5QZXJpb2QgPSBmdW5jdGlvbiBpY2FscGVyaW9kKGFEYXRhKSB7XG4gICAgdGhpcy53cmFwcGVkSlNPYmplY3QgPSB0aGlzO1xuXG4gICAgaWYgKGFEYXRhICYmICdzdGFydCcgaW4gYURhdGEpIHtcbiAgICAgIGlmIChhRGF0YS5zdGFydCAmJiAhKGFEYXRhLnN0YXJ0IGluc3RhbmNlb2YgSUNBTC5UaW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcuc3RhcnQgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBJQ0FMLlRpbWUnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhcnQgPSBhRGF0YS5zdGFydDtcbiAgICB9XG5cbiAgICBpZiAoYURhdGEgJiYgYURhdGEuZW5kICYmIGFEYXRhLmR1cmF0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBhY2NlcHQgYm90aCBlbmQgYW5kIGR1cmF0aW9uJyk7XG4gICAgfVxuXG4gICAgaWYgKGFEYXRhICYmICdlbmQnIGluIGFEYXRhKSB7XG4gICAgICBpZiAoYURhdGEuZW5kICYmICEoYURhdGEuZW5kIGluc3RhbmNlb2YgSUNBTC5UaW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcuZW5kIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgSUNBTC5UaW1lJyk7XG4gICAgICB9XG4gICAgICB0aGlzLmVuZCA9IGFEYXRhLmVuZDtcbiAgICB9XG5cbiAgICBpZiAoYURhdGEgJiYgJ2R1cmF0aW9uJyBpbiBhRGF0YSkge1xuICAgICAgaWYgKGFEYXRhLmR1cmF0aW9uICYmICEoYURhdGEuZHVyYXRpb24gaW5zdGFuY2VvZiBJQ0FMLkR1cmF0aW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcuZHVyYXRpb24gbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBJQ0FMLkR1cmF0aW9uJyk7XG4gICAgICB9XG4gICAgICB0aGlzLmR1cmF0aW9uID0gYURhdGEuZHVyYXRpb247XG4gICAgfVxuICB9O1xuXG4gIElDQUwuUGVyaW9kLnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdGFydCBvZiB0aGUgcGVyaW9kXG4gICAgICogQHR5cGUge0lDQUwuVGltZX1cbiAgICAgKi9cbiAgICBzdGFydDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlbmQgb2YgdGhlIHBlcmlvZFxuICAgICAqIEB0eXBlIHtJQ0FMLlRpbWV9XG4gICAgICovXG4gICAgZW5kOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGR1cmF0aW9uIG9mIHRoZSBwZXJpb2RcbiAgICAgKiBAdHlwZSB7SUNBTC5EdXJhdGlvbn1cbiAgICAgKi9cbiAgICBkdXJhdGlvbjogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBjbGFzcyBpZGVudGlmaWVyLlxuICAgICAqIEBjb25zdGFudFxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgXCJpY2FscGVyaW9kXCJcbiAgICAgKi9cbiAgICBpY2FsY2xhc3M6IFwiaWNhbHBlcmlvZFwiLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgbmFtZSwgdG8gYmUgdXNlZCBpbiB0aGUgakNhbCBvYmplY3QuXG4gICAgICogQGNvbnN0YW50XG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBcInBlcmlvZFwiXG4gICAgICovXG4gICAgaWNhbHR5cGU6IFwicGVyaW9kXCIsXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIGR1cmF0aW9uIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0lDQUwuUGVyaW9kfSAgICAgIFRoZSBjbG9uZWQgb2JqZWN0XG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIElDQUwuUGVyaW9kLmZyb21EYXRhKHtcbiAgICAgICAgc3RhcnQ6IHRoaXMuc3RhcnQgPyB0aGlzLnN0YXJ0LmNsb25lKCkgOiBudWxsLFxuICAgICAgICBlbmQ6IHRoaXMuZW5kID8gdGhpcy5lbmQuY2xvbmUoKSA6IG51bGwsXG4gICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uID8gdGhpcy5kdXJhdGlvbi5jbG9uZSgpIDogbnVsbFxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGR1cmF0aW9uIG9mIHRoZSBwZXJpb2QsIGVpdGhlciBkaXJlY3RseSBvciBieSBzdWJ0cmFjdGluZ1xuICAgICAqIHN0YXJ0IGZyb20gZW5kIGRhdGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLkR1cmF0aW9ufSAgICAgIFRoZSBjYWxjdWxhdGVkIGR1cmF0aW9uXG4gICAgICovXG4gICAgZ2V0RHVyYXRpb246IGZ1bmN0aW9uIGR1cmF0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuZHVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHVyYXRpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmQuc3VidHJhY3REYXRlKHRoaXMuc3RhcnQpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBlbmQgZGF0ZSBvZiB0aGUgcGVyaW9kLCBlaXRoZXIgZGlyZWN0bHkgb3IgYnkgYWRkaW5nXG4gICAgICogZHVyYXRpb24gdG8gc3RhcnQgZGF0ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0lDQUwuVGltZX0gICAgICAgICAgVGhlIGNhbGN1bGF0ZWQgZW5kIGRhdGVcbiAgICAgKi9cbiAgICBnZXRFbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuZW5kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnN0YXJ0LmNsb25lKCk7XG4gICAgICAgIGVuZC5hZGREdXJhdGlvbih0aGlzLmR1cmF0aW9uKTtcbiAgICAgICAgcmV0dXJuIGVuZDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHBlcmlvZC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhcnQgKyBcIi9cIiArICh0aGlzLmVuZCB8fCB0aGlzLmR1cmF0aW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGpDYWwgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBwZXJpb2QgdHlwZS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBbdGhpcy5zdGFydC50b1N0cmluZygpLCAodGhpcy5lbmQgfHwgdGhpcy5kdXJhdGlvbikudG9TdHJpbmcoKV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBpQ2FsZW5kYXIgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgcGVyaW9kLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICB0b0lDQUxTdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhcnQudG9JQ0FMU3RyaW5nKCkgKyBcIi9cIiArXG4gICAgICAgICAgICAgKHRoaXMuZW5kIHx8IHRoaXMuZHVyYXRpb24pLnRvSUNBTFN0cmluZygpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgSUNBTC5QZXJpb2R9IGluc3RhbmNlIGZyb20gdGhlIHBhc3NlZCBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgICAgICAgICAgICBUaGUgc3RyaW5nIHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7SUNBTC5Qcm9wZXJ0eX0gcHJvcCAgICBUaGUgcHJvcGVydHkgdGhpcyBwZXJpb2Qgd2lsbCBiZSBvblxuICAgKiBAcmV0dXJuIHtJQ0FMLlBlcmlvZH0gICAgICAgICAgVGhlIGNyZWF0ZWQgcGVyaW9kIGluc3RhbmNlXG4gICAqL1xuICBJQ0FMLlBlcmlvZC5mcm9tU3RyaW5nID0gZnVuY3Rpb24gZnJvbVN0cmluZyhzdHIsIHByb3ApIHtcbiAgICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoJy8nKTtcblxuICAgIGlmIChwYXJ0cy5sZW5ndGggIT09IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0ludmFsaWQgc3RyaW5nIHZhbHVlOiBcIicgKyBzdHIgKyAnXCIgbXVzdCBjb250YWluIGEgXCIvXCIgY2hhci4nXG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgc3RhcnQ6IElDQUwuVGltZS5mcm9tRGF0ZVRpbWVTdHJpbmcocGFydHNbMF0sIHByb3ApXG4gICAgfTtcblxuICAgIHZhciBlbmQgPSBwYXJ0c1sxXTtcblxuICAgIGlmIChJQ0FMLkR1cmF0aW9uLmlzVmFsdWVTdHJpbmcoZW5kKSkge1xuICAgICAgb3B0aW9ucy5kdXJhdGlvbiA9IElDQUwuRHVyYXRpb24uZnJvbVN0cmluZyhlbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zLmVuZCA9IElDQUwuVGltZS5mcm9tRGF0ZVRpbWVTdHJpbmcoZW5kLCBwcm9wKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IElDQUwuUGVyaW9kKG9wdGlvbnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBJQ0FMLlBlcmlvZH0gaW5zdGFuY2UgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBvYmplY3QuXG4gICAqIFRoZSBwYXNzZWQgZGF0YSBvYmplY3QgY2Fubm90IGNvbnRhaW4gYm90aCBhbmQgZW5kIGRhdGUgYW5kIGEgZHVyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhRGF0YSAgICAgICAgICAgICAgICAgIEFuIG9iamVjdCB3aXRoIG1lbWJlcnMgb2YgdGhlIHBlcmlvZFxuICAgKiBAcGFyYW0ge0lDQUwuVGltZT19IGFEYXRhLnN0YXJ0ICAgICAgICBUaGUgc3RhcnQgb2YgdGhlIHBlcmlvZFxuICAgKiBAcGFyYW0ge0lDQUwuVGltZT19IGFEYXRhLmVuZCAgICAgICAgICBUaGUgZW5kIG9mIHRoZSBwZXJpb2RcbiAgICogQHBhcmFtIHtJQ0FMLkR1cmF0aW9uPX0gYURhdGEuZHVyYXRpb24gVGhlIGR1cmF0aW9uIG9mIHRoZSBwZXJpb2RcbiAgICogQHJldHVybiB7SUNBTC5QZXJpb2R9ICAgICAgICAgICAgICAgICAgVGhlIHBlcmlvZCBpbnN0YW5jZVxuICAgKi9cbiAgSUNBTC5QZXJpb2QuZnJvbURhdGEgPSBmdW5jdGlvbiBmcm9tRGF0YShhRGF0YSkge1xuICAgIHJldHVybiBuZXcgSUNBTC5QZXJpb2QoYURhdGEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IHBlcmlvZCBpbnN0YW5jZSBmcm9tIHRoZSBnaXZlbiBqQ2FsIGRhdGEgYXJyYXkuIFRoZSBmaXJzdFxuICAgKiBtZW1iZXIgaXMgYWx3YXlzIHRoZSBzdGFydCBkYXRlIHN0cmluZywgdGhlIHNlY29uZCBtZW1iZXIgaXMgZWl0aGVyIGFcbiAgICogZHVyYXRpb24gb3IgZW5kIGRhdGUgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PFN0cmluZyxTdHJpbmc+fSBhRGF0YSAgICBUaGUgakNhbCBkYXRhIGFycmF5XG4gICAqIEBwYXJhbSB7SUNBTC5Qcm9wZXJ0eX0gYVByb3AgICAgICAgICAgIFRoZSBwcm9wZXJ0eSB0aGlzIGpDYWwgZGF0YSBpcyBvblxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFMZW5pZW50ICAgICAgICAgICAgICBJZiB0cnVlLCBkYXRhIHZhbHVlIGNhbiBiZSBib3RoIGRhdGUgYW5kIGRhdGUtdGltZVxuICAgKiBAcmV0dXJuIHtJQ0FMLlBlcmlvZH0gICAgICAgICAgICAgICAgICBUaGUgcGVyaW9kIGluc3RhbmNlXG4gICAqL1xuICBJQ0FMLlBlcmlvZC5mcm9tSlNPTiA9IGZ1bmN0aW9uKGFEYXRhLCBhUHJvcCwgYUxlbmllbnQpIHtcbiAgICBmdW5jdGlvbiBmcm9tRGF0ZU9yRGF0ZVRpbWVTdHJpbmcoYVZhbHVlLCBhUHJvcCkge1xuICAgICAgaWYgKGFMZW5pZW50KSB7XG4gICAgICAgIHJldHVybiBJQ0FMLlRpbWUuZnJvbVN0cmluZyhhVmFsdWUsIGFQcm9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBJQ0FMLlRpbWUuZnJvbURhdGVUaW1lU3RyaW5nKGFWYWx1ZSwgYVByb3ApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChJQ0FMLkR1cmF0aW9uLmlzVmFsdWVTdHJpbmcoYURhdGFbMV0pKSB7XG4gICAgICByZXR1cm4gSUNBTC5QZXJpb2QuZnJvbURhdGEoe1xuICAgICAgICBzdGFydDogZnJvbURhdGVPckRhdGVUaW1lU3RyaW5nKGFEYXRhWzBdLCBhUHJvcCksXG4gICAgICAgIGR1cmF0aW9uOiBJQ0FMLkR1cmF0aW9uLmZyb21TdHJpbmcoYURhdGFbMV0pXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIElDQUwuUGVyaW9kLmZyb21EYXRhKHtcbiAgICAgICAgc3RhcnQ6IGZyb21EYXRlT3JEYXRlVGltZVN0cmluZyhhRGF0YVswXSwgYVByb3ApLFxuICAgICAgICBlbmQ6IGZyb21EYXRlT3JEYXRlVGltZVN0cmluZyhhRGF0YVsxXSwgYVByb3ApXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59KSgpO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoLCAyMDExLTIwMTUgKi9cblxuXG5cbihmdW5jdGlvbigpIHtcbiAgdmFyIERVUkFUSU9OX0xFVFRFUlMgPSAvKFtQRFdITVRTXXsxLDF9KS87XG5cbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogVGhpcyBjbGFzcyByZXByZXNlbnRzIHRoZSBcImR1cmF0aW9uXCIgdmFsdWUgdHlwZSwgd2l0aCB2YXJpb3VzIGNhbGN1bGF0aW9uXG4gICAqIGFuZCBtYW5pcHVsYXRpb24gbWV0aG9kcy5cbiAgICpcbiAgICogQGNsYXNzXG4gICAqIEBhbGlhcyBJQ0FMLkR1cmF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhICAgICAgICAgICAgICAgQW4gb2JqZWN0IHdpdGggbWVtYmVycyBvZiB0aGUgZHVyYXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEud2Vla3MgICAgICAgICBEdXJhdGlvbiBpbiB3ZWVrc1xuICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5kYXlzICAgICAgICAgIER1cmF0aW9uIGluIGRheXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEuaG91cnMgICAgICAgICBEdXJhdGlvbiBpbiBob3Vyc1xuICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5taW51dGVzICAgICAgIER1cmF0aW9uIGluIG1pbnV0ZXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEuc2Vjb25kcyAgICAgICBEdXJhdGlvbiBpbiBzZWNvbmRzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGF0YS5pc05lZ2F0aXZlICAgSWYgdHJ1ZSwgdGhlIGR1cmF0aW9uIGlzIG5lZ2F0aXZlXG4gICAqL1xuICBJQ0FMLkR1cmF0aW9uID0gZnVuY3Rpb24gaWNhbGR1cmF0aW9uKGRhdGEpIHtcbiAgICB0aGlzLndyYXBwZWRKU09iamVjdCA9IHRoaXM7XG4gICAgdGhpcy5mcm9tRGF0YShkYXRhKTtcbiAgfTtcblxuICBJQ0FMLkR1cmF0aW9uLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBUaGUgd2Vla3MgaW4gdGhpcyBkdXJhdGlvblxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHdlZWtzOiAwLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGRheXMgaW4gdGhpcyBkdXJhdGlvblxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIGRheXM6IDAsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGF5cyBpbiB0aGlzIGR1cmF0aW9uXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgaG91cnM6IDAsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWludXRlcyBpbiB0aGlzIGR1cmF0aW9uXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgbWludXRlczogMCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzZWNvbmRzIGluIHRoaXMgZHVyYXRpb25cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICBzZWNvbmRzOiAwLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHNlY29uZHMgaW4gdGhpcyBkdXJhdGlvblxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgaXNOZWdhdGl2ZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2xhc3MgaWRlbnRpZmllci5cbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IFwiaWNhbGR1cmF0aW9uXCJcbiAgICAgKi9cbiAgICBpY2FsY2xhc3M6IFwiaWNhbGR1cmF0aW9uXCIsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBuYW1lLCB0byBiZSB1c2VkIGluIHRoZSBqQ2FsIG9iamVjdC5cbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IFwiZHVyYXRpb25cIlxuICAgICAqL1xuICAgIGljYWx0eXBlOiBcImR1cmF0aW9uXCIsXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIGR1cmF0aW9uIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0lDQUwuRHVyYXRpb259ICAgICAgVGhlIGNsb25lZCBvYmplY3RcbiAgICAgKi9cbiAgICBjbG9uZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICByZXR1cm4gSUNBTC5EdXJhdGlvbi5mcm9tRGF0YSh0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGR1cmF0aW9uIHZhbHVlIGV4cHJlc3NlZCBhcyBhIG51bWJlciBvZiBzZWNvbmRzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgICBUaGUgZHVyYXRpb24gdmFsdWUgaW4gc2Vjb25kc1xuICAgICAqL1xuICAgIHRvU2Vjb25kczogZnVuY3Rpb24gdG9TZWNvbmRzKCkge1xuICAgICAgdmFyIHNlY29uZHMgPSB0aGlzLnNlY29uZHMgKyA2MCAqIHRoaXMubWludXRlcyArIDM2MDAgKiB0aGlzLmhvdXJzICtcbiAgICAgICAgICAgICAgICAgICAgODY0MDAgKiB0aGlzLmRheXMgKyA3ICogODY0MDAgKiB0aGlzLndlZWtzO1xuICAgICAgcmV0dXJuICh0aGlzLmlzTmVnYXRpdmUgPyAtc2Vjb25kcyA6IHNlY29uZHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWFkcyB0aGUgcGFzc2VkIHNlY29uZHMgdmFsdWUgaW50byB0aGlzIGR1cmF0aW9uIG9iamVjdC4gQWZ0ZXJ3YXJkcyxcbiAgICAgKiBtZW1iZXJzIGxpa2Uge0BsaW5rIElDQUwuRHVyYXRpb24jZGF5cyBkYXlzfSBhbmQge0BsaW5rIElDQUwuRHVyYXRpb24jd2Vla3Mgd2Vla3N9IHdpbGwgYmUgc2V0IHVwXG4gICAgICogYWNjb3JkaW5nbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYVNlY29uZHMgICAgIFRoZSBkdXJhdGlvbiB2YWx1ZSBpbiBzZWNvbmRzXG4gICAgICogQHJldHVybiB7SUNBTC5EdXJhdGlvbn0gICAgICBSZXR1cm5zIHRoaXMgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBmcm9tU2Vjb25kczogZnVuY3Rpb24gZnJvbVNlY29uZHMoYVNlY29uZHMpIHtcbiAgICAgIHZhciBzZWNzID0gTWF0aC5hYnMoYVNlY29uZHMpO1xuXG4gICAgICB0aGlzLmlzTmVnYXRpdmUgPSAoYVNlY29uZHMgPCAwKTtcbiAgICAgIHRoaXMuZGF5cyA9IElDQUwuaGVscGVycy50cnVuYyhzZWNzIC8gODY0MDApO1xuXG4gICAgICAvLyBJZiB3ZSBoYXZlIGEgZmxhdCBudW1iZXIgb2Ygd2Vla3MsIHVzZSB0aGVtLlxuICAgICAgaWYgKHRoaXMuZGF5cyAlIDcgPT0gMCkge1xuICAgICAgICB0aGlzLndlZWtzID0gdGhpcy5kYXlzIC8gNztcbiAgICAgICAgdGhpcy5kYXlzID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMud2Vla3MgPSAwO1xuICAgICAgfVxuXG4gICAgICBzZWNzIC09ICh0aGlzLmRheXMgKyA3ICogdGhpcy53ZWVrcykgKiA4NjQwMDtcblxuICAgICAgdGhpcy5ob3VycyA9IElDQUwuaGVscGVycy50cnVuYyhzZWNzIC8gMzYwMCk7XG4gICAgICBzZWNzIC09IHRoaXMuaG91cnMgKiAzNjAwO1xuXG4gICAgICB0aGlzLm1pbnV0ZXMgPSBJQ0FMLmhlbHBlcnMudHJ1bmMoc2VjcyAvIDYwKTtcbiAgICAgIHNlY3MgLT0gdGhpcy5taW51dGVzICogNjA7XG5cbiAgICAgIHRoaXMuc2Vjb25kcyA9IHNlY3M7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB1cCB0aGUgY3VycmVudCBpbnN0YW5jZSB1c2luZyBtZW1iZXJzIGZyb20gdGhlIHBhc3NlZCBkYXRhIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhRGF0YSAgICAgICAgICAgICAgIEFuIG9iamVjdCB3aXRoIG1lbWJlcnMgb2YgdGhlIGR1cmF0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXRhLndlZWtzICAgICAgICAgRHVyYXRpb24gaW4gd2Vla3NcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYURhdGEuZGF5cyAgICAgICAgICBEdXJhdGlvbiBpbiBkYXlzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXRhLmhvdXJzICAgICAgICAgRHVyYXRpb24gaW4gaG91cnNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYURhdGEubWludXRlcyAgICAgICBEdXJhdGlvbiBpbiBtaW51dGVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXRhLnNlY29uZHMgICAgICAgRHVyYXRpb24gaW4gc2Vjb25kc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gYURhdGEuaXNOZWdhdGl2ZSAgIElmIHRydWUsIHRoZSBkdXJhdGlvbiBpcyBuZWdhdGl2ZVxuICAgICAqL1xuICAgIGZyb21EYXRhOiBmdW5jdGlvbiBmcm9tRGF0YShhRGF0YSkge1xuICAgICAgdmFyIHByb3BzVG9Db3B5ID0gW1wid2Vla3NcIiwgXCJkYXlzXCIsIFwiaG91cnNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICBcIm1pbnV0ZXNcIiwgXCJzZWNvbmRzXCIsIFwiaXNOZWdhdGl2ZVwiXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wc1RvQ29weSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFwcm9wc1RvQ29weS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb3AgPSBwcm9wc1RvQ29weVtrZXldO1xuICAgICAgICBpZiAoYURhdGEgJiYgcHJvcCBpbiBhRGF0YSkge1xuICAgICAgICAgIHRoaXNbcHJvcF0gPSBhRGF0YVtwcm9wXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzW3Byb3BdID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIGR1cmF0aW9uIGluc3RhbmNlIHRvIHRoZSBkZWZhdWx0IHZhbHVlcywgaS5lLiBQVDBTXG4gICAgICovXG4gICAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgdGhpcy5pc05lZ2F0aXZlID0gZmFsc2U7XG4gICAgICB0aGlzLndlZWtzID0gMDtcbiAgICAgIHRoaXMuZGF5cyA9IDA7XG4gICAgICB0aGlzLmhvdXJzID0gMDtcbiAgICAgIHRoaXMubWludXRlcyA9IDA7XG4gICAgICB0aGlzLnNlY29uZHMgPSAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb21wYXJlcyB0aGUgZHVyYXRpb24gaW5zdGFuY2Ugd2l0aCBhbm90aGVyIG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SUNBTC5EdXJhdGlvbn0gYU90aGVyICAgICAgICBUaGUgaW5zdGFuY2UgdG8gY29tcGFyZSB3aXRoXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgICAgICAgICAgIC0xLCAwIG9yIDEgZm9yIGxlc3MvZXF1YWwvZ3JlYXRlclxuICAgICAqL1xuICAgIGNvbXBhcmU6IGZ1bmN0aW9uIGNvbXBhcmUoYU90aGVyKSB7XG4gICAgICB2YXIgdGhpc1NlY29uZHMgPSB0aGlzLnRvU2Vjb25kcygpO1xuICAgICAgdmFyIG90aGVyU2Vjb25kcyA9IGFPdGhlci50b1NlY29uZHMoKTtcbiAgICAgIHJldHVybiAodGhpc1NlY29uZHMgPiBvdGhlclNlY29uZHMpIC0gKHRoaXNTZWNvbmRzIDwgb3RoZXJTZWNvbmRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplcyB0aGUgZHVyYXRpb24gaW5zdGFuY2UuIEZvciBleGFtcGxlLCBhIGR1cmF0aW9uIHdpdGggYSB2YWx1ZVxuICAgICAqIG9mIDYxIHNlY29uZHMgd2lsbCBiZSBub3JtYWxpemVkIHRvIDEgbWludXRlIGFuZCAxIHNlY29uZC5cbiAgICAgKi9cbiAgICBub3JtYWxpemU6IGZ1bmN0aW9uIG5vcm1hbGl6ZSgpIHtcbiAgICAgIHRoaXMuZnJvbVNlY29uZHModGhpcy50b1NlY29uZHMoKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBkdXJhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgaWYgKHRoaXMudG9TZWNvbmRzKCkgPT0gMCkge1xuICAgICAgICByZXR1cm4gXCJQVDBTXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc3RyID0gXCJcIjtcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSkgc3RyICs9IFwiLVwiO1xuICAgICAgICBzdHIgKz0gXCJQXCI7XG4gICAgICAgIGlmICh0aGlzLndlZWtzKSBzdHIgKz0gdGhpcy53ZWVrcyArIFwiV1wiO1xuICAgICAgICBpZiAodGhpcy5kYXlzKSBzdHIgKz0gdGhpcy5kYXlzICsgXCJEXCI7XG5cbiAgICAgICAgaWYgKHRoaXMuaG91cnMgfHwgdGhpcy5taW51dGVzIHx8IHRoaXMuc2Vjb25kcykge1xuICAgICAgICAgIHN0ciArPSBcIlRcIjtcbiAgICAgICAgICBpZiAodGhpcy5ob3Vycykgc3RyICs9IHRoaXMuaG91cnMgKyBcIkhcIjtcbiAgICAgICAgICBpZiAodGhpcy5taW51dGVzKSBzdHIgKz0gdGhpcy5taW51dGVzICsgXCJNXCI7XG4gICAgICAgICAgaWYgKHRoaXMuc2Vjb25kcykgc3RyICs9IHRoaXMuc2Vjb25kcyArIFwiU1wiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBpQ2FsZW5kYXIgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZHVyYXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvSUNBTFN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBJQ0FMLkR1cmF0aW9uIGluc3RhbmNlIGZyb20gdGhlIHBhc3NlZCBzZWNvbmRzIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gYVNlY29uZHMgICAgICAgVGhlIHNlY29uZHMgdG8gY3JlYXRlIHRoZSBpbnN0YW5jZSBmcm9tXG4gICAqIEByZXR1cm4ge0lDQUwuRHVyYXRpb259ICAgICAgICBUaGUgbmV3bHkgY3JlYXRlZCBkdXJhdGlvbiBpbnN0YW5jZVxuICAgKi9cbiAgSUNBTC5EdXJhdGlvbi5mcm9tU2Vjb25kcyA9IGZ1bmN0aW9uIGljYWxkdXJhdGlvbl9mcm9tX3NlY29uZHMoYVNlY29uZHMpIHtcbiAgICByZXR1cm4gKG5ldyBJQ0FMLkR1cmF0aW9uKCkpLmZyb21TZWNvbmRzKGFTZWNvbmRzKTtcbiAgfTtcblxuICAvKipcbiAgICogSW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9uIHRvIGhhbmRsZSBhIGNodW5rIG9mIGEgZHVyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBsZXR0ZXIgdHlwZSBvZiBkdXJhdGlvbiBjaHVua1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbnVtYmVyIG51bWVyaWMgdmFsdWUgb3IgLS8rXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWN0IHRhcmdldCB0byBhc3NpZ24gdmFsdWVzIHRvXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZUR1cmF0aW9uQ2h1bmsobGV0dGVyLCBudW1iZXIsIG9iamVjdCkge1xuICAgIHZhciB0eXBlO1xuICAgIHN3aXRjaCAobGV0dGVyKSB7XG4gICAgICBjYXNlICdQJzpcbiAgICAgICAgaWYgKG51bWJlciAmJiBudW1iZXIgPT09ICctJykge1xuICAgICAgICAgIG9iamVjdC5pc05lZ2F0aXZlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvYmplY3QuaXNOZWdhdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBlcmlvZFxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0QnOlxuICAgICAgICB0eXBlID0gJ2RheXMnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1cnOlxuICAgICAgICB0eXBlID0gJ3dlZWtzJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdIJzpcbiAgICAgICAgdHlwZSA9ICdob3Vycyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTSc6XG4gICAgICAgIHR5cGUgPSAnbWludXRlcyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnUyc6XG4gICAgICAgIHR5cGUgPSAnc2Vjb25kcyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gTm90IGEgdmFsaWQgY2h1bmtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUpIHtcbiAgICAgIGlmICghbnVtYmVyICYmIG51bWJlciAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ2ludmFsaWQgZHVyYXRpb24gdmFsdWU6IE1pc3NpbmcgbnVtYmVyIGJlZm9yZSBcIicgKyBsZXR0ZXIgKyAnXCInXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB2YXIgbnVtID0gcGFyc2VJbnQobnVtYmVyLCAxMCk7XG4gICAgICBpZiAoSUNBTC5oZWxwZXJzLmlzU3RyaWN0bHlOYU4obnVtKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ2ludmFsaWQgZHVyYXRpb24gdmFsdWU6IEludmFsaWQgbnVtYmVyIFwiJyArIG51bWJlciArICdcIiBiZWZvcmUgXCInICsgbGV0dGVyICsgJ1wiJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgb2JqZWN0W3R5cGVdID0gbnVtO1xuICAgIH1cblxuICAgIHJldHVybiAxO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gc3RyaW5nIGlzIGFuIGlDYWxlbmRhciBkdXJhdGlvbiB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlICAgICAgVGhlIHJhdyBpY2FsIHZhbHVlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgIFRydWUsIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBvZiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiBpY2FsIHR5cGVcbiAgICovXG4gIElDQUwuRHVyYXRpb24uaXNWYWx1ZVN0cmluZyA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHJldHVybiAoc3RyaW5nWzBdID09PSAnUCcgfHwgc3RyaW5nWzFdID09PSAnUCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBJQ0FMLkR1cmF0aW9ufSBpbnN0YW5jZSBmcm9tIHRoZSBwYXNzZWQgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYVN0ciAgICAgICBUaGUgc3RyaW5nIHRvIHBhcnNlXG4gICAqIEByZXR1cm4ge0lDQUwuRHVyYXRpb259ICAgIFRoZSBjcmVhdGVkIGR1cmF0aW9uIGluc3RhbmNlXG4gICAqL1xuICBJQ0FMLkR1cmF0aW9uLmZyb21TdHJpbmcgPSBmdW5jdGlvbiBpY2FsZHVyYXRpb25fZnJvbV9zdHJpbmcoYVN0cikge1xuICAgIHZhciBwb3MgPSAwO1xuICAgIHZhciBkaWN0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgY2h1bmtzID0gMDtcblxuICAgIHdoaWxlICgocG9zID0gYVN0ci5zZWFyY2goRFVSQVRJT05fTEVUVEVSUykpICE9PSAtMSkge1xuICAgICAgdmFyIHR5cGUgPSBhU3RyW3Bvc107XG4gICAgICB2YXIgbnVtZXJpYyA9IGFTdHIuc3Vic3RyKDAsIHBvcyk7XG4gICAgICBhU3RyID0gYVN0ci5zdWJzdHIocG9zICsgMSk7XG5cbiAgICAgIGNodW5rcyArPSBwYXJzZUR1cmF0aW9uQ2h1bmsodHlwZSwgbnVtZXJpYywgZGljdCk7XG4gICAgfVxuXG4gICAgaWYgKGNodW5rcyA8IDIpIHtcbiAgICAgIC8vIFRoZXJlIG11c3QgYmUgYXQgbGVhc3QgYSBjaHVuayB3aXRoIFwiUFwiIGFuZCBzb21lIHVuaXQgY2h1bmtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2ludmFsaWQgZHVyYXRpb24gdmFsdWU6IE5vdCBlbm91Z2ggZHVyYXRpb24gY29tcG9uZW50cyBpbiBcIicgKyBhU3RyICsgJ1wiJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IElDQUwuRHVyYXRpb24oZGljdCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgSUNBTC5EdXJhdGlvbiBpbnN0YW5jZSBmcm9tIHRoZSBnaXZlbiBkYXRhIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFEYXRhICAgICAgICAgICAgICAgQW4gb2JqZWN0IHdpdGggbWVtYmVycyBvZiB0aGUgZHVyYXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXRhLndlZWtzICAgICAgICAgRHVyYXRpb24gaW4gd2Vla3NcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXRhLmRheXMgICAgICAgICAgRHVyYXRpb24gaW4gZGF5c1xuICAgKiBAcGFyYW0ge051bWJlcn0gYURhdGEuaG91cnMgICAgICAgICBEdXJhdGlvbiBpbiBob3Vyc1xuICAgKiBAcGFyYW0ge051bWJlcn0gYURhdGEubWludXRlcyAgICAgICBEdXJhdGlvbiBpbiBtaW51dGVzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhRGF0YS5zZWNvbmRzICAgICAgIER1cmF0aW9uIGluIHNlY29uZHNcbiAgICogQHBhcmFtIHtCb29sZWFufSBhRGF0YS5pc05lZ2F0aXZlICAgSWYgdHJ1ZSwgdGhlIGR1cmF0aW9uIGlzIG5lZ2F0aXZlXG4gICAqIEByZXR1cm4ge0lDQUwuRHVyYXRpb259ICAgICAgICAgICAgIFRoZSBjcmVhdGVhZCBkdXJhdGlvbiBpbnN0YW5jZVxuICAgKi9cbiAgSUNBTC5EdXJhdGlvbi5mcm9tRGF0YSA9IGZ1bmN0aW9uIGljYWxkdXJhdGlvbl9mcm9tX2RhdGEoYURhdGEpIHtcbiAgICByZXR1cm4gbmV3IElDQUwuRHVyYXRpb24oYURhdGEpO1xuICB9O1xufSkoKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAxMS0yMDEyICovXG5cblxuXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBPUFRJT05TID0gW1widHppZFwiLCBcImxvY2F0aW9uXCIsIFwidHpuYW1lc1wiLFxuICAgICAgICAgICAgICAgICBcImxhdGl0dWRlXCIsIFwibG9uZ2l0dWRlXCJdO1xuXG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIFRpbWV6b25lIHJlcHJlc2VudGF0aW9uLCBjcmVhdGVkIGJ5IHBhc3NpbmcgaW4gYSB0emlkIGFuZCBjb21wb25lbnQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciB2Y2FsZW5kYXI7XG4gICAqIHZhciB0aW1lem9uZUNvbXAgPSB2Y2FsZW5kYXIuZ2V0Rmlyc3RTdWJjb21wb25lbnQoJ3Z0aW1lem9uZScpO1xuICAgKiB2YXIgdHppZCA9IHRpbWV6b25lQ29tcC5nZXRGaXJzdFByb3BlcnR5VmFsdWUoJ3R6aWQnKTtcbiAgICpcbiAgICogdmFyIHRpbWV6b25lID0gbmV3IElDQUwuVGltZXpvbmUoe1xuICAgKiAgIGNvbXBvbmVudDogdGltZXpvbmVDb21wLFxuICAgKiAgIHR6aWRcbiAgICogfSk7XG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAcGFyYW0ge0lDQUwuQ29tcG9uZW50fE9iamVjdH0gZGF0YSBvcHRpb25zIGZvciBjbGFzc1xuICAgKiBAcGFyYW0ge1N0cmluZ3xJQ0FMLkNvbXBvbmVudH0gZGF0YS5jb21wb25lbnRcbiAgICogICAgICAgIElmIGRhdGEgaXMgYSBzaW1wbGUgb2JqZWN0LCB0aGVuIHRoaXMgbWVtYmVyIGNhbiBiZSBzZXQgdG8gZWl0aGVyIGFcbiAgICogICAgICAgIHN0cmluZyBjb250YWluaW5nIHRoZSBjb21wb25lbnQgZGF0YSwgb3IgYW4gYWxyZWFkeSBwYXJzZWRcbiAgICogICAgICAgIElDQUwuQ29tcG9uZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLnR6aWQgICAgICBUaGUgdGltZXpvbmUgaWRlbnRpZmllclxuICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5sb2NhdGlvbiAgVGhlIHRpbWV6b25lIGxvY2F0aW9ud1xuICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS50em5hbWVzICAgQW4gYWx0ZXJuYXRpdmUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lem9uZVxuICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5sYXRpdHVkZSAgVGhlIGxhdGl0dWRlIG9mIHRoZSB0aW1lem9uZVxuICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5sb25naXR1ZGUgVGhlIGxvbmdpdHVkZSBvZiB0aGUgdGltZXpvbmVcbiAgICovXG4gIElDQUwuVGltZXpvbmUgPSBmdW5jdGlvbiBpY2FsdGltZXpvbmUoZGF0YSkge1xuICAgIHRoaXMud3JhcHBlZEpTT2JqZWN0ID0gdGhpcztcbiAgICB0aGlzLmZyb21EYXRhKGRhdGEpO1xuICB9O1xuXG4gIElDQUwuVGltZXpvbmUucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogVGltZXpvbmUgaWRlbnRpZmllclxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgdHppZDogXCJcIixcblxuICAgIC8qKlxuICAgICAqIFRpbWV6b25lIGxvY2F0aW9uXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBsb2NhdGlvbjogXCJcIixcblxuICAgIC8qKlxuICAgICAqIEFsdGVybmF0aXZlIHRpbWV6b25lIG5hbWUsIGZvciB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICB0em5hbWVzOiBcIlwiLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHByaW1hcnkgbGF0aXR1ZGUgZm9yIHRoZSB0aW1lem9uZS5cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIGxhdGl0dWRlOiAwLjAsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgcHJpbWFyeSBsb25naXR1ZGUgZm9yIHRoZSB0aW1lem9uZS5cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIGxvbmdpdHVkZTogMC4wLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHZ0aW1lem9uZSBjb21wb25lbnQgZm9yIHRoaXMgdGltZXpvbmUuXG4gICAgICogQHR5cGUge0lDQUwuQ29tcG9uZW50fVxuICAgICAqL1xuICAgIGNvbXBvbmVudDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSB5ZWFyIHRoaXMgdGltZXpvbmUgaGFzIGJlZW4gZXhwYW5kZWQgdG8uIEFsbCB0aW1lem9uZSB0cmFuc2l0aW9uXG4gICAgICogZGF0ZXMgdW50aWwgdGhpcyB5ZWFyIGFyZSBrbm93biBhbmQgY2FuIGJlIHVzZWQgZm9yIGNhbGN1bGF0aW9uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZXhwYW5kZWRVbnRpbFllYXI6IDAsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2xhc3MgaWRlbnRpZmllci5cbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IFwiaWNhbHRpbWV6b25lXCJcbiAgICAgKi9cbiAgICBpY2FsY2xhc3M6IFwiaWNhbHRpbWV6b25lXCIsXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIHRoZSBjdXJyZW50IGluc3RhbmNlIHVzaW5nIG1lbWJlcnMgZnJvbSB0aGUgcGFzc2VkIGRhdGEgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLkNvbXBvbmVudHxPYmplY3R9IGFEYXRhIG9wdGlvbnMgZm9yIGNsYXNzXG4gICAgICogQHBhcmFtIHtTdHJpbmd8SUNBTC5Db21wb25lbnR9IGFEYXRhLmNvbXBvbmVudFxuICAgICAqICAgICAgICBJZiBhRGF0YSBpcyBhIHNpbXBsZSBvYmplY3QsIHRoZW4gdGhpcyBtZW1iZXIgY2FuIGJlIHNldCB0byBlaXRoZXIgYVxuICAgICAqICAgICAgICBzdHJpbmcgY29udGFpbmluZyB0aGUgY29tcG9uZW50IGRhdGEsIG9yIGFuIGFscmVhZHkgcGFyc2VkXG4gICAgICogICAgICAgIElDQUwuQ29tcG9uZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFEYXRhLnR6aWQgICAgICBUaGUgdGltZXpvbmUgaWRlbnRpZmllclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhRGF0YS5sb2NhdGlvbiAgVGhlIHRpbWV6b25lIGxvY2F0aW9ud1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhRGF0YS50em5hbWVzICAgQW4gYWx0ZXJuYXRpdmUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWV6b25lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXRhLmxhdGl0dWRlICBUaGUgbGF0aXR1ZGUgb2YgdGhlIHRpbWV6b25lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXRhLmxvbmdpdHVkZSBUaGUgbG9uZ2l0dWRlIG9mIHRoZSB0aW1lem9uZVxuICAgICAqL1xuICAgIGZyb21EYXRhOiBmdW5jdGlvbiBmcm9tRGF0YShhRGF0YSkge1xuICAgICAgdGhpcy5leHBhbmRlZFVudGlsWWVhciA9IDA7XG4gICAgICB0aGlzLmNoYW5nZXMgPSBbXTtcblxuICAgICAgaWYgKGFEYXRhIGluc3RhbmNlb2YgSUNBTC5Db21wb25lbnQpIHtcbiAgICAgICAgLy8gRWl0aGVyIGEgY29tcG9uZW50IGlzIHBhc3NlZCBkaXJlY3RseVxuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGFEYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlIHRoZSBjb21wb25lbnQgbWF5IGJlIGluIHRoZSBkYXRhIG9iamVjdFxuICAgICAgICBpZiAoYURhdGEgJiYgXCJjb21wb25lbnRcIiBpbiBhRGF0YSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgYURhdGEuY29tcG9uZW50ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIElmIGEgc3RyaW5nIHdhcyBwYXNzZWQsIHBhcnNlIGl0IGFzIGEgY29tcG9uZW50XG4gICAgICAgICAgICB2YXIgakNhbCA9IElDQUwucGFyc2UoYURhdGEuY29tcG9uZW50KTtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50ID0gbmV3IElDQUwuQ29tcG9uZW50KGpDYWwpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYURhdGEuY29tcG9uZW50IGluc3RhbmNlb2YgSUNBTC5Db21wb25lbnQpIHtcbiAgICAgICAgICAgIC8vIElmIGl0IHdhcyBhIGNvbXBvbmVudCBhbHJlYWR5LCB0aGVuIGp1c3Qgc2V0IGl0XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGFEYXRhLmNvbXBvbmVudDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGp1c3QgbnVsbCBvdXQgdGhlIGNvbXBvbmVudFxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvcHkgcmVtYWluaW5nIHBhc3NlZCBwcm9wZXJ0aWVzXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBPUFRJT05TKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICBpZiAoT1BUSU9OUy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICB2YXIgcHJvcCA9IE9QVElPTlNba2V5XTtcbiAgICAgICAgICAgIGlmIChhRGF0YSAmJiBwcm9wIGluIGFEYXRhKSB7XG4gICAgICAgICAgICAgIHRoaXNbcHJvcF0gPSBhRGF0YVtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgd2UgaGF2ZSBhIGNvbXBvbmVudCBidXQgbm8gVFpJRCwgYXR0ZW1wdCB0byBnZXQgaXQgZnJvbSB0aGVcbiAgICAgIC8vIGNvbXBvbmVudCdzIHByb3BlcnRpZXMuXG4gICAgICBpZiAodGhpcy5jb21wb25lbnQgaW5zdGFuY2VvZiBJQ0FMLkNvbXBvbmVudCAmJiAhdGhpcy50emlkKSB7XG4gICAgICAgIHRoaXMudHppZCA9IHRoaXMuY29tcG9uZW50LmdldEZpcnN0UHJvcGVydHlWYWx1ZSgndHppZCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIHV0Y09mZnNldCB0aGUgZ2l2ZW4gdGltZSB3b3VsZCBvY2N1ciBpbiB0aGlzIHRpbWV6b25lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWV9IHR0ICAgICAgICBUaGUgdGltZSB0byBjaGVjayBmb3JcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHV0YyBvZmZzZXQgaW4gc2Vjb25kc1xuICAgICAqL1xuICAgIHV0Y09mZnNldDogZnVuY3Rpb24gdXRjT2Zmc2V0KHR0KSB7XG4gICAgICBpZiAodGhpcyA9PSBJQ0FMLlRpbWV6b25lLnV0Y1RpbWV6b25lIHx8IHRoaXMgPT0gSUNBTC5UaW1lem9uZS5sb2NhbFRpbWV6b25lKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9lbnN1cmVDb3ZlcmFnZSh0dC55ZWFyKTtcblxuICAgICAgaWYgKCF0aGlzLmNoYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHRfY2hhbmdlID0ge1xuICAgICAgICB5ZWFyOiB0dC55ZWFyLFxuICAgICAgICBtb250aDogdHQubW9udGgsXG4gICAgICAgIGRheTogdHQuZGF5LFxuICAgICAgICBob3VyOiB0dC5ob3VyLFxuICAgICAgICBtaW51dGU6IHR0Lm1pbnV0ZSxcbiAgICAgICAgc2Vjb25kOiB0dC5zZWNvbmRcbiAgICAgIH07XG5cbiAgICAgIHZhciBjaGFuZ2VfbnVtID0gdGhpcy5fZmluZE5lYXJieUNoYW5nZSh0dF9jaGFuZ2UpO1xuICAgICAgdmFyIGNoYW5nZV9udW1fdG9fdXNlID0gLTE7XG4gICAgICB2YXIgc3RlcCA9IDE7XG5cbiAgICAgIC8vIFRPRE86IHJlcGxhY2Ugd2l0aCBiaW4gc2VhcmNoP1xuICAgICAgZm9yICg7Oykge1xuICAgICAgICB2YXIgY2hhbmdlID0gSUNBTC5oZWxwZXJzLmNsb25lKHRoaXMuY2hhbmdlc1tjaGFuZ2VfbnVtXSwgdHJ1ZSk7XG4gICAgICAgIGlmIChjaGFuZ2UudXRjT2Zmc2V0IDwgY2hhbmdlLnByZXZVdGNPZmZzZXQpIHtcbiAgICAgICAgICBJQ0FMLlRpbWV6b25lLmFkanVzdF9jaGFuZ2UoY2hhbmdlLCAwLCAwLCAwLCBjaGFuZ2UudXRjT2Zmc2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBJQ0FMLlRpbWV6b25lLmFkanVzdF9jaGFuZ2UoY2hhbmdlLCAwLCAwLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlLnByZXZVdGNPZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNtcCA9IElDQUwuVGltZXpvbmUuX2NvbXBhcmVfY2hhbmdlX2ZuKHR0X2NoYW5nZSwgY2hhbmdlKTtcblxuICAgICAgICBpZiAoY21wID49IDApIHtcbiAgICAgICAgICBjaGFuZ2VfbnVtX3RvX3VzZSA9IGNoYW5nZV9udW07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RlcCA9IC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0ZXAgPT0gLTEgJiYgY2hhbmdlX251bV90b191c2UgIT0gLTEpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGNoYW5nZV9udW0gKz0gc3RlcDtcblxuICAgICAgICBpZiAoY2hhbmdlX251bSA8IDApIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGFuZ2VfbnVtID49IHRoaXMuY2hhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgem9uZV9jaGFuZ2UgPSB0aGlzLmNoYW5nZXNbY2hhbmdlX251bV90b191c2VdO1xuICAgICAgdmFyIHV0Y09mZnNldF9jaGFuZ2UgPSB6b25lX2NoYW5nZS51dGNPZmZzZXQgLSB6b25lX2NoYW5nZS5wcmV2VXRjT2Zmc2V0O1xuXG4gICAgICBpZiAodXRjT2Zmc2V0X2NoYW5nZSA8IDAgJiYgY2hhbmdlX251bV90b191c2UgPiAwKSB7XG4gICAgICAgIHZhciB0bXBfY2hhbmdlID0gSUNBTC5oZWxwZXJzLmNsb25lKHpvbmVfY2hhbmdlLCB0cnVlKTtcbiAgICAgICAgSUNBTC5UaW1lem9uZS5hZGp1c3RfY2hhbmdlKHRtcF9jaGFuZ2UsIDAsIDAsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wX2NoYW5nZS5wcmV2VXRjT2Zmc2V0KTtcblxuICAgICAgICBpZiAoSUNBTC5UaW1lem9uZS5fY29tcGFyZV9jaGFuZ2VfZm4odHRfY2hhbmdlLCB0bXBfY2hhbmdlKSA8IDApIHtcbiAgICAgICAgICB2YXIgcHJldl96b25lX2NoYW5nZSA9IHRoaXMuY2hhbmdlc1tjaGFuZ2VfbnVtX3RvX3VzZSAtIDFdO1xuXG4gICAgICAgICAgdmFyIHdhbnRfZGF5bGlnaHQgPSBmYWxzZTsgLy8gVE9ET1xuXG4gICAgICAgICAgaWYgKHpvbmVfY2hhbmdlLmlzX2RheWxpZ2h0ICE9IHdhbnRfZGF5bGlnaHQgJiZcbiAgICAgICAgICAgICAgcHJldl96b25lX2NoYW5nZS5pc19kYXlsaWdodCA9PSB3YW50X2RheWxpZ2h0KSB7XG4gICAgICAgICAgICB6b25lX2NoYW5nZSA9IHByZXZfem9uZV9jaGFuZ2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRPRE8gcmV0dXJuIGlzX2RheWxpZ2h0P1xuICAgICAgcmV0dXJuIHpvbmVfY2hhbmdlLnV0Y09mZnNldDtcbiAgICB9LFxuXG4gICAgX2ZpbmROZWFyYnlDaGFuZ2U6IGZ1bmN0aW9uIGljYWx0aW1lem9uZV9maW5kX25lYXJieV9jaGFuZ2UoY2hhbmdlKSB7XG4gICAgICAvLyBmaW5kIHRoZSBjbG9zZXN0IG1hdGNoXG4gICAgICB2YXIgaWR4ID0gSUNBTC5oZWxwZXJzLmJpbnNlYXJjaEluc2VydChcbiAgICAgICAgdGhpcy5jaGFuZ2VzLFxuICAgICAgICBjaGFuZ2UsXG4gICAgICAgIElDQUwuVGltZXpvbmUuX2NvbXBhcmVfY2hhbmdlX2ZuXG4gICAgICApO1xuXG4gICAgICBpZiAoaWR4ID49IHRoaXMuY2hhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlcy5sZW5ndGggLSAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaWR4O1xuICAgIH0sXG5cbiAgICBfZW5zdXJlQ292ZXJhZ2U6IGZ1bmN0aW9uKGFZZWFyKSB7XG4gICAgICBpZiAoSUNBTC5UaW1lem9uZS5fbWluaW11bUV4cGFuc2lvblllYXIgPT0gLTEpIHtcbiAgICAgICAgdmFyIHRvZGF5ID0gSUNBTC5UaW1lLm5vdygpO1xuICAgICAgICBJQ0FMLlRpbWV6b25lLl9taW5pbXVtRXhwYW5zaW9uWWVhciA9IHRvZGF5LnllYXI7XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGFuZ2VzRW5kWWVhciA9IGFZZWFyO1xuICAgICAgaWYgKGNoYW5nZXNFbmRZZWFyIDwgSUNBTC5UaW1lem9uZS5fbWluaW11bUV4cGFuc2lvblllYXIpIHtcbiAgICAgICAgY2hhbmdlc0VuZFllYXIgPSBJQ0FMLlRpbWV6b25lLl9taW5pbXVtRXhwYW5zaW9uWWVhcjtcbiAgICAgIH1cblxuICAgICAgY2hhbmdlc0VuZFllYXIgKz0gSUNBTC5UaW1lem9uZS5FWFRSQV9DT1ZFUkFHRTtcblxuICAgICAgaWYgKGNoYW5nZXNFbmRZZWFyID4gSUNBTC5UaW1lem9uZS5NQVhfWUVBUikge1xuICAgICAgICBjaGFuZ2VzRW5kWWVhciA9IElDQUwuVGltZXpvbmUuTUFYX1lFQVI7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5jaGFuZ2VzLmxlbmd0aCB8fCB0aGlzLmV4cGFuZGVkVW50aWxZZWFyIDwgYVllYXIpIHtcbiAgICAgICAgdmFyIHN1YmNvbXBzID0gdGhpcy5jb21wb25lbnQuZ2V0QWxsU3ViY29tcG9uZW50cygpO1xuICAgICAgICB2YXIgY29tcExlbiA9IHN1YmNvbXBzLmxlbmd0aDtcbiAgICAgICAgdmFyIGNvbXBJZHggPSAwO1xuXG4gICAgICAgIGZvciAoOyBjb21wSWR4IDwgY29tcExlbjsgY29tcElkeCsrKSB7XG4gICAgICAgICAgdGhpcy5fZXhwYW5kQ29tcG9uZW50KFxuICAgICAgICAgICAgc3ViY29tcHNbY29tcElkeF0sIGNoYW5nZXNFbmRZZWFyLCB0aGlzLmNoYW5nZXNcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jaGFuZ2VzLnNvcnQoSUNBTC5UaW1lem9uZS5fY29tcGFyZV9jaGFuZ2VfZm4pO1xuICAgICAgICB0aGlzLmV4cGFuZGVkVW50aWxZZWFyID0gY2hhbmdlc0VuZFllYXI7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9leHBhbmRDb21wb25lbnQ6IGZ1bmN0aW9uKGFDb21wb25lbnQsIGFZZWFyLCBjaGFuZ2VzKSB7XG4gICAgICBpZiAoIWFDb21wb25lbnQuaGFzUHJvcGVydHkoXCJkdHN0YXJ0XCIpIHx8XG4gICAgICAgICAgIWFDb21wb25lbnQuaGFzUHJvcGVydHkoXCJ0em9mZnNldHRvXCIpIHx8XG4gICAgICAgICAgIWFDb21wb25lbnQuaGFzUHJvcGVydHkoXCJ0em9mZnNldGZyb21cIikpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBkdHN0YXJ0ID0gYUNvbXBvbmVudC5nZXRGaXJzdFByb3BlcnR5KFwiZHRzdGFydFwiKS5nZXRGaXJzdFZhbHVlKCk7XG4gICAgICB2YXIgY2hhbmdlO1xuXG4gICAgICBmdW5jdGlvbiBjb252ZXJ0X3R6b2Zmc2V0KG9mZnNldCkge1xuICAgICAgICByZXR1cm4gb2Zmc2V0LmZhY3RvciAqIChvZmZzZXQuaG91cnMgKiAzNjAwICsgb2Zmc2V0Lm1pbnV0ZXMgKiA2MCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGluaXRfY2hhbmdlcygpIHtcbiAgICAgICAgdmFyIGNoYW5nZWJhc2UgPSB7fTtcbiAgICAgICAgY2hhbmdlYmFzZS5pc19kYXlsaWdodCA9IChhQ29tcG9uZW50Lm5hbWUgPT0gXCJkYXlsaWdodFwiKTtcbiAgICAgICAgY2hhbmdlYmFzZS51dGNPZmZzZXQgPSBjb252ZXJ0X3R6b2Zmc2V0KFxuICAgICAgICAgIGFDb21wb25lbnQuZ2V0Rmlyc3RQcm9wZXJ0eShcInR6b2Zmc2V0dG9cIikuZ2V0Rmlyc3RWYWx1ZSgpXG4gICAgICAgICk7XG5cbiAgICAgICAgY2hhbmdlYmFzZS5wcmV2VXRjT2Zmc2V0ID0gY29udmVydF90em9mZnNldChcbiAgICAgICAgICBhQ29tcG9uZW50LmdldEZpcnN0UHJvcGVydHkoXCJ0em9mZnNldGZyb21cIikuZ2V0Rmlyc3RWYWx1ZSgpXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIGNoYW5nZWJhc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICghYUNvbXBvbmVudC5oYXNQcm9wZXJ0eShcInJydWxlXCIpICYmICFhQ29tcG9uZW50Lmhhc1Byb3BlcnR5KFwicmRhdGVcIikpIHtcbiAgICAgICAgY2hhbmdlID0gaW5pdF9jaGFuZ2VzKCk7XG4gICAgICAgIGNoYW5nZS55ZWFyID0gZHRzdGFydC55ZWFyO1xuICAgICAgICBjaGFuZ2UubW9udGggPSBkdHN0YXJ0Lm1vbnRoO1xuICAgICAgICBjaGFuZ2UuZGF5ID0gZHRzdGFydC5kYXk7XG4gICAgICAgIGNoYW5nZS5ob3VyID0gZHRzdGFydC5ob3VyO1xuICAgICAgICBjaGFuZ2UubWludXRlID0gZHRzdGFydC5taW51dGU7XG4gICAgICAgIGNoYW5nZS5zZWNvbmQgPSBkdHN0YXJ0LnNlY29uZDtcblxuICAgICAgICBJQ0FMLlRpbWV6b25lLmFkanVzdF9jaGFuZ2UoY2hhbmdlLCAwLCAwLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC1jaGFuZ2UucHJldlV0Y09mZnNldCk7XG4gICAgICAgIGNoYW5nZXMucHVzaChjaGFuZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHByb3BzID0gYUNvbXBvbmVudC5nZXRBbGxQcm9wZXJ0aWVzKFwicmRhdGVcIik7XG4gICAgICAgIGZvciAodmFyIHJkYXRla2V5IGluIHByb3BzKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eShyZGF0ZWtleSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmRhdGUgPSBwcm9wc1tyZGF0ZWtleV07XG4gICAgICAgICAgdmFyIHRpbWUgPSByZGF0ZS5nZXRGaXJzdFZhbHVlKCk7XG4gICAgICAgICAgY2hhbmdlID0gaW5pdF9jaGFuZ2VzKCk7XG5cbiAgICAgICAgICBjaGFuZ2UueWVhciA9IHRpbWUueWVhcjtcbiAgICAgICAgICBjaGFuZ2UubW9udGggPSB0aW1lLm1vbnRoO1xuICAgICAgICAgIGNoYW5nZS5kYXkgPSB0aW1lLmRheTtcblxuICAgICAgICAgIGlmICh0aW1lLmlzRGF0ZSkge1xuICAgICAgICAgICAgY2hhbmdlLmhvdXIgPSBkdHN0YXJ0LmhvdXI7XG4gICAgICAgICAgICBjaGFuZ2UubWludXRlID0gZHRzdGFydC5taW51dGU7XG4gICAgICAgICAgICBjaGFuZ2Uuc2Vjb25kID0gZHRzdGFydC5zZWNvbmQ7XG5cbiAgICAgICAgICAgIGlmIChkdHN0YXJ0LnpvbmUgIT0gSUNBTC5UaW1lem9uZS51dGNUaW1lem9uZSkge1xuICAgICAgICAgICAgICBJQ0FMLlRpbWV6b25lLmFkanVzdF9jaGFuZ2UoY2hhbmdlLCAwLCAwLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC1jaGFuZ2UucHJldlV0Y09mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoYW5nZS5ob3VyID0gdGltZS5ob3VyO1xuICAgICAgICAgICAgY2hhbmdlLm1pbnV0ZSA9IHRpbWUubWludXRlO1xuICAgICAgICAgICAgY2hhbmdlLnNlY29uZCA9IHRpbWUuc2Vjb25kO1xuXG4gICAgICAgICAgICBpZiAodGltZS56b25lICE9IElDQUwuVGltZXpvbmUudXRjVGltZXpvbmUpIHtcbiAgICAgICAgICAgICAgSUNBTC5UaW1lem9uZS5hZGp1c3RfY2hhbmdlKGNoYW5nZSwgMCwgMCwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtY2hhbmdlLnByZXZVdGNPZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNoYW5nZXMucHVzaChjaGFuZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJydWxlID0gYUNvbXBvbmVudC5nZXRGaXJzdFByb3BlcnR5KFwicnJ1bGVcIik7XG5cbiAgICAgICAgaWYgKHJydWxlKSB7XG4gICAgICAgICAgcnJ1bGUgPSBycnVsZS5nZXRGaXJzdFZhbHVlKCk7XG4gICAgICAgICAgY2hhbmdlID0gaW5pdF9jaGFuZ2VzKCk7XG5cbiAgICAgICAgICBpZiAocnJ1bGUudW50aWwgJiYgcnJ1bGUudW50aWwuem9uZSA9PSBJQ0FMLlRpbWV6b25lLnV0Y1RpbWV6b25lKSB7XG4gICAgICAgICAgICBycnVsZS51bnRpbC5hZGp1c3QoMCwgMCwgMCwgY2hhbmdlLnByZXZVdGNPZmZzZXQpO1xuICAgICAgICAgICAgcnJ1bGUudW50aWwuem9uZSA9IElDQUwuVGltZXpvbmUubG9jYWxUaW1lem9uZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBycnVsZS5pdGVyYXRvcihkdHN0YXJ0KTtcblxuICAgICAgICAgIHZhciBvY2M7XG4gICAgICAgICAgd2hpbGUgKChvY2MgPSBpdGVyYXRvci5uZXh0KCkpKSB7XG4gICAgICAgICAgICBjaGFuZ2UgPSBpbml0X2NoYW5nZXMoKTtcbiAgICAgICAgICAgIGlmIChvY2MueWVhciA+IGFZZWFyIHx8ICFvY2MpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoYW5nZS55ZWFyID0gb2NjLnllYXI7XG4gICAgICAgICAgICBjaGFuZ2UubW9udGggPSBvY2MubW9udGg7XG4gICAgICAgICAgICBjaGFuZ2UuZGF5ID0gb2NjLmRheTtcbiAgICAgICAgICAgIGNoYW5nZS5ob3VyID0gb2NjLmhvdXI7XG4gICAgICAgICAgICBjaGFuZ2UubWludXRlID0gb2NjLm1pbnV0ZTtcbiAgICAgICAgICAgIGNoYW5nZS5zZWNvbmQgPSBvY2Muc2Vjb25kO1xuICAgICAgICAgICAgY2hhbmdlLmlzRGF0ZSA9IG9jYy5pc0RhdGU7XG5cbiAgICAgICAgICAgIElDQUwuVGltZXpvbmUuYWRqdXN0X2NoYW5nZShjaGFuZ2UsIDAsIDAsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC1jaGFuZ2UucHJldlV0Y09mZnNldCk7XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goY2hhbmdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoYW5nZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB0aW1lem9uZS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICh0aGlzLnR6bmFtZXMgPyB0aGlzLnR6bmFtZXMgOiB0aGlzLnR6aWQpO1xuICAgIH1cbiAgfTtcblxuICBJQ0FMLlRpbWV6b25lLl9jb21wYXJlX2NoYW5nZV9mbiA9IGZ1bmN0aW9uIGljYWx0aW1lem9uZV9jb21wYXJlX2NoYW5nZV9mbihhLCBiKSB7XG4gICAgaWYgKGEueWVhciA8IGIueWVhcikgcmV0dXJuIC0xO1xuICAgIGVsc2UgaWYgKGEueWVhciA+IGIueWVhcikgcmV0dXJuIDE7XG5cbiAgICBpZiAoYS5tb250aCA8IGIubW9udGgpIHJldHVybiAtMTtcbiAgICBlbHNlIGlmIChhLm1vbnRoID4gYi5tb250aCkgcmV0dXJuIDE7XG5cbiAgICBpZiAoYS5kYXkgPCBiLmRheSkgcmV0dXJuIC0xO1xuICAgIGVsc2UgaWYgKGEuZGF5ID4gYi5kYXkpIHJldHVybiAxO1xuXG4gICAgaWYgKGEuaG91ciA8IGIuaG91cikgcmV0dXJuIC0xO1xuICAgIGVsc2UgaWYgKGEuaG91ciA+IGIuaG91cikgcmV0dXJuIDE7XG5cbiAgICBpZiAoYS5taW51dGUgPCBiLm1pbnV0ZSkgcmV0dXJuIC0xO1xuICAgIGVsc2UgaWYgKGEubWludXRlID4gYi5taW51dGUpIHJldHVybiAxO1xuXG4gICAgaWYgKGEuc2Vjb25kIDwgYi5zZWNvbmQpIHJldHVybiAtMTtcbiAgICBlbHNlIGlmIChhLnNlY29uZCA+IGIuc2Vjb25kKSByZXR1cm4gMTtcblxuICAgIHJldHVybiAwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHRoZSBkYXRlL3RpbWUgZnJvbSBvbmUgem9uZSB0byB0aGUgbmV4dC5cbiAgICpcbiAgICogQHBhcmFtIHtJQ0FMLlRpbWV9IHR0ICAgICAgICAgICAgICAgICAgVGhlIHRpbWUgdG8gY29udmVydFxuICAgKiBAcGFyYW0ge0lDQUwuVGltZXpvbmV9IGZyb21fem9uZSAgICAgICBUaGUgc291cmNlIHpvbmUgdG8gY29udmVydCBmcm9tXG4gICAqIEBwYXJhbSB7SUNBTC5UaW1lem9uZX0gdG9fem9uZSAgICAgICAgIFRoZSB0YXJnZXQgem9uZSB0byBjb252ZXJ0IHRvXG4gICAqIEByZXR1cm4ge0lDQUwuVGltZX0gICAgICAgICAgICAgICAgICAgIFRoZSBjb252ZXJ0ZWQgZGF0ZS90aW1lIG9iamVjdFxuICAgKi9cbiAgSUNBTC5UaW1lem9uZS5jb252ZXJ0X3RpbWUgPSBmdW5jdGlvbiBpY2FsdGltZXpvbmVfY29udmVydF90aW1lKHR0LCBmcm9tX3pvbmUsIHRvX3pvbmUpIHtcbiAgICBpZiAodHQuaXNEYXRlIHx8XG4gICAgICAgIGZyb21fem9uZS50emlkID09IHRvX3pvbmUudHppZCB8fFxuICAgICAgICBmcm9tX3pvbmUgPT0gSUNBTC5UaW1lem9uZS5sb2NhbFRpbWV6b25lIHx8XG4gICAgICAgIHRvX3pvbmUgPT0gSUNBTC5UaW1lem9uZS5sb2NhbFRpbWV6b25lKSB7XG4gICAgICB0dC56b25lID0gdG9fem9uZTtcbiAgICAgIHJldHVybiB0dDtcbiAgICB9XG5cbiAgICB2YXIgdXRjT2Zmc2V0ID0gZnJvbV96b25lLnV0Y09mZnNldCh0dCk7XG4gICAgdHQuYWRqdXN0KDAsIDAsIDAsIC0gdXRjT2Zmc2V0KTtcblxuICAgIHV0Y09mZnNldCA9IHRvX3pvbmUudXRjT2Zmc2V0KHR0KTtcbiAgICB0dC5hZGp1c3QoMCwgMCwgMCwgdXRjT2Zmc2V0KTtcblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IElDQUwuVGltZXpvbmUgaW5zdGFuY2UgZnJvbSB0aGUgcGFzc2VkIGRhdGEgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge0lDQUwuQ29tcG9uZW50fE9iamVjdH0gYURhdGEgb3B0aW9ucyBmb3IgY2xhc3NcbiAgICogQHBhcmFtIHtTdHJpbmd8SUNBTC5Db21wb25lbnR9IGFEYXRhLmNvbXBvbmVudFxuICAgKiAgICAgICAgSWYgYURhdGEgaXMgYSBzaW1wbGUgb2JqZWN0LCB0aGVuIHRoaXMgbWVtYmVyIGNhbiBiZSBzZXQgdG8gZWl0aGVyIGFcbiAgICogICAgICAgIHN0cmluZyBjb250YWluaW5nIHRoZSBjb21wb25lbnQgZGF0YSwgb3IgYW4gYWxyZWFkeSBwYXJzZWRcbiAgICogICAgICAgIElDQUwuQ29tcG9uZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhRGF0YS50emlkICAgICAgVGhlIHRpbWV6b25lIGlkZW50aWZpZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFEYXRhLmxvY2F0aW9uICBUaGUgdGltZXpvbmUgbG9jYXRpb253XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhRGF0YS50em5hbWVzICAgQW4gYWx0ZXJuYXRpdmUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lem9uZVxuICAgKiBAcGFyYW0ge051bWJlcn0gYURhdGEubGF0aXR1ZGUgIFRoZSBsYXRpdHVkZSBvZiB0aGUgdGltZXpvbmVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXRhLmxvbmdpdHVkZSBUaGUgbG9uZ2l0dWRlIG9mIHRoZSB0aW1lem9uZVxuICAgKi9cbiAgSUNBTC5UaW1lem9uZS5mcm9tRGF0YSA9IGZ1bmN0aW9uIGljYWx0aW1lem9uZV9mcm9tRGF0YShhRGF0YSkge1xuICAgIHZhciB0dCA9IG5ldyBJQ0FMLlRpbWV6b25lKCk7XG4gICAgcmV0dXJuIHR0LmZyb21EYXRhKGFEYXRhKTtcbiAgfTtcblxuICAvKipcbiAgICogVGhlIGluc3RhbmNlIGRlc2NyaWJpbmcgdGhlIFVUQyB0aW1lem9uZVxuICAgKiBAdHlwZSB7SUNBTC5UaW1lem9uZX1cbiAgICogQGNvbnN0YW50XG4gICAqIEBpbnN0YW5jZVxuICAgKi9cbiAgSUNBTC5UaW1lem9uZS51dGNUaW1lem9uZSA9IElDQUwuVGltZXpvbmUuZnJvbURhdGEoe1xuICAgIHR6aWQ6IFwiVVRDXCJcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFRoZSBpbnN0YW5jZSBkZXNjcmliaW5nIHRoZSBsb2NhbCB0aW1lem9uZVxuICAgKiBAdHlwZSB7SUNBTC5UaW1lem9uZX1cbiAgICogQGNvbnN0YW50XG4gICAqIEBpbnN0YW5jZVxuICAgKi9cbiAgSUNBTC5UaW1lem9uZS5sb2NhbFRpbWV6b25lID0gSUNBTC5UaW1lem9uZS5mcm9tRGF0YSh7XG4gICAgdHppZDogXCJmbG9hdGluZ1wiXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBBZGp1c3QgYSB0aW1lem9uZSBjaGFuZ2Ugb2JqZWN0LlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gY2hhbmdlICAgICBUaGUgdGltZXpvbmUgY2hhbmdlIG9iamVjdFxuICAgKiBAcGFyYW0ge051bWJlcn0gZGF5cyAgICAgICBUaGUgZXh0cmEgYW1vdW50IG9mIGRheXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhvdXJzICAgICAgVGhlIGV4dHJhIGFtb3VudCBvZiBob3Vyc1xuICAgKiBAcGFyYW0ge051bWJlcn0gbWludXRlcyAgICBUaGUgZXh0cmEgYW1vdW50IG9mIG1pbnV0ZXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNlY29uZHMgICAgVGhlIGV4dHJhIGFtb3VudCBvZiBzZWNvbmRzXG4gICAqL1xuICBJQ0FMLlRpbWV6b25lLmFkanVzdF9jaGFuZ2UgPSBmdW5jdGlvbiBpY2FsdGltZXpvbmVfYWRqdXN0X2NoYW5nZShjaGFuZ2UsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzKSB7XG4gICAgcmV0dXJuIElDQUwuVGltZS5wcm90b3R5cGUuYWRqdXN0LmNhbGwoXG4gICAgICBjaGFuZ2UsXG4gICAgICBkYXlzLFxuICAgICAgaG91cnMsXG4gICAgICBtaW51dGVzLFxuICAgICAgc2Vjb25kcyxcbiAgICAgIGNoYW5nZVxuICAgICk7XG4gIH07XG5cbiAgSUNBTC5UaW1lem9uZS5fbWluaW11bUV4cGFuc2lvblllYXIgPSAtMTtcbiAgSUNBTC5UaW1lem9uZS5NQVhfWUVBUiA9IDIwMzU7IC8vIFRPRE8gdGhpcyBpcyBiZWNhdXNlIG9mIHRpbWVfdCwgd2hpY2ggd2UgZG9uJ3QgbmVlZC4gU3RpbGwgdXNlZnVsbD9cbiAgSUNBTC5UaW1lem9uZS5FWFRSQV9DT1ZFUkFHRSA9IDU7XG59KSgpO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoLCAyMDExLTIwMTUgKi9cblxuXG4vKipcbiAqIFRoaXMgc3ltYm9sIGlzIGZ1cnRoZXIgZGVzY3JpYmVkIGxhdGVyIG9uXG4gKiBAaWdub3JlXG4gKi9cbklDQUwuVGltZXpvbmVTZXJ2aWNlID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgem9uZXM7XG5cbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogU2luZ2xldG9uIGNsYXNzIHRvIGNvbnRhaW4gdGltZXpvbmVzLiAgUmlnaHQgbm93IGl0IGlzIGFsbCBtYW51YWwgcmVnaXN0cnkgaW5cbiAgICogdGhlIGZ1dHVyZSB3ZSBtYXkgdXNlIHRoaXMgY2xhc3MgdG8gZG93bmxvYWQgdGltZXpvbmUgaW5mb3JtYXRpb24gb3IgaGFuZGxlXG4gICAqIGxvYWRpbmcgcHJlLWV4cGFuZGVkIHRpbWV6b25lcy5cbiAgICpcbiAgICogQG5hbWVzcGFjZVxuICAgKiBAYWxpYXMgSUNBTC5UaW1lem9uZVNlcnZpY2VcbiAgICovXG4gIHZhciBUaW1lem9uZVNlcnZpY2UgPSB7XG4gICAgZ2V0IGNvdW50KCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHpvbmVzKS5sZW5ndGg7XG4gICAgfSxcblxuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHpvbmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHZhciB1dGMgPSBJQ0FMLlRpbWV6b25lLnV0Y1RpbWV6b25lO1xuXG4gICAgICB6b25lcy5aID0gdXRjO1xuICAgICAgem9uZXMuVVRDID0gdXRjO1xuICAgICAgem9uZXMuR01UID0gdXRjO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGltZXpvbmUgaWQgaGFzIGJlZW4gcmVnaXN0ZXJlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0emlkICAgICBUaW1lem9uZSBpZGVudGlmaWVyIChlLmcuIEFtZXJpY2EvTG9zX0FuZ2VsZXMpXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgIEZhbHNlLCB3aGVuIG5vdCBwcmVzZW50XG4gICAgICovXG4gICAgaGFzOiBmdW5jdGlvbih0emlkKSB7XG4gICAgICByZXR1cm4gISF6b25lc1t0emlkXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHRpbWV6b25lIGJ5IGl0cyB0emlkIGlmIHByZXNlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHppZCAgICAgVGltZXpvbmUgaWRlbnRpZmllciAoZS5nLiBBbWVyaWNhL0xvc19BbmdlbGVzKVxuICAgICAqIEByZXR1cm4gez9JQ0FMLlRpbWV6b25lfSBUaGUgdGltZXpvbmUsIG9yIG51bGwgaWYgbm90IGZvdW5kXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbih0emlkKSB7XG4gICAgICByZXR1cm4gem9uZXNbdHppZF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIHRpbWV6b25lIG9iamVjdCBvciBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZz19IG5hbWVcbiAgICAgKiAgICAgICAgVGhlIG5hbWUgb2YgdGhlIHRpbWV6b25lLiBEZWZhdWx0cyB0byB0aGUgY29tcG9uZW50J3MgVFpJRCBpZiBub3RcbiAgICAgKiAgICAgICAgcGFzc2VkLlxuICAgICAqIEBwYXJhbSB7SUNBTC5Db21wb25lbnR8SUNBTC5UaW1lem9uZX0gem9uZVxuICAgICAqICAgICAgICBUaGUgaW5pdGlhbGl6ZWQgem9uZSBvciB2dGltZXpvbmUuXG4gICAgICovXG4gICAgcmVnaXN0ZXI6IGZ1bmN0aW9uKG5hbWUsIHRpbWV6b25lKSB7XG4gICAgICBpZiAobmFtZSBpbnN0YW5jZW9mIElDQUwuQ29tcG9uZW50KSB7XG4gICAgICAgIGlmIChuYW1lLm5hbWUgPT09ICd2dGltZXpvbmUnKSB7XG4gICAgICAgICAgdGltZXpvbmUgPSBuZXcgSUNBTC5UaW1lem9uZShuYW1lKTtcbiAgICAgICAgICBuYW1lID0gdGltZXpvbmUudHppZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGltZXpvbmUgaW5zdGFuY2VvZiBJQ0FMLlRpbWV6b25lKSB7XG4gICAgICAgIHpvbmVzW25hbWVdID0gdGltZXpvbmU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0aW1lem9uZSBtdXN0IGJlIElDQUwuVGltZXpvbmUgb3IgSUNBTC5Db21wb25lbnQnKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHRpbWV6b25lIGJ5IGl0cyB0emlkIGZyb20gdGhlIGxpc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHppZCAgICAgVGltZXpvbmUgaWRlbnRpZmllciAoZS5nLiBBbWVyaWNhL0xvc19BbmdlbGVzKVxuICAgICAqIEByZXR1cm4gez9JQ0FMLlRpbWV6b25lfSBUaGUgcmVtb3ZlZCB0aW1lem9uZSwgb3IgbnVsbCBpZiBub3QgcmVnaXN0ZXJlZFxuICAgICAqL1xuICAgIHJlbW92ZTogZnVuY3Rpb24odHppZCkge1xuICAgICAgcmV0dXJuIChkZWxldGUgem9uZXNbdHppZF0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBpbml0aWFsaXplIGRlZmF1bHRzXG4gIFRpbWV6b25lU2VydmljZS5yZXNldCgpO1xuXG4gIHJldHVybiBUaW1lem9uZVNlcnZpY2U7XG59KCkpO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoLCAyMDExLTIwMTUgKi9cblxuXG5cbihmdW5jdGlvbigpIHtcblxuICAvKipcbiAgICogQGNsYXNzZGVzY1xuICAgKiBpQ2FsZW5kYXIgVGltZSByZXByZXNlbnRhdGlvbiAoc2ltaWxhciB0byBKUyBEYXRlIG9iamVjdCkuICBGdWxseVxuICAgKiBpbmRlcGVuZGVudCBvZiBzeXN0ZW0gKE9TKSB0aW1lem9uZSAvIHRpbWUuICBVbmxpa2UgSlMgRGF0ZSwgdGhlIG1vbnRoXG4gICAqIEphbnVhcnkgaXMgMSwgbm90IHplcm8uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciB0aW1lID0gbmV3IElDQUwuVGltZSh7XG4gICAqICAgeWVhcjogMjAxMixcbiAgICogICBtb250aDogMTAsXG4gICAqICAgZGF5OiAxMVxuICAgKiAgIG1pbnV0ZTogMCxcbiAgICogICBzZWNvbmQ6IDAsXG4gICAqICAgaXNEYXRlOiBmYWxzZVxuICAgKiB9KTtcbiAgICpcbiAgICpcbiAgICogQGFsaWFzIElDQUwuVGltZVxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgICAgICAgICAgIFRpbWUgaW5pdGlhbGl6YXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLnllYXIgICAgIFRoZSB5ZWFyIGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLm1vbnRoICAgIFRoZSBtb250aCBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS5kYXkgICAgICBUaGUgZGF5IGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLmhvdXIgICAgIFRoZSBob3VyIGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLm1pbnV0ZSAgIFRoZSBtaW51dGUgZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcj19IGRhdGEuc2Vjb25kICAgVGhlIHNlY29uZCBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbj19IGRhdGEuaXNEYXRlICBJZiB0cnVlLCB0aGUgaW5zdGFuY2UgcmVwcmVzZW50cyBhIGRhdGUgKGFzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wcG9zZWQgdG8gYSBkYXRlLXRpbWUpXG4gICAqIEBwYXJhbSB7SUNBTC5UaW1lem9uZX0gem9uZSB0aW1lem9uZSB0aGlzIHBvc2l0aW9uIG9jY3VycyBpblxuICAgKi9cbiAgSUNBTC5UaW1lID0gZnVuY3Rpb24gaWNhbHRpbWUoZGF0YSwgem9uZSkge1xuICAgIHRoaXMud3JhcHBlZEpTT2JqZWN0ID0gdGhpcztcbiAgICB2YXIgdGltZSA9IHRoaXMuX3RpbWUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgLyogdGltZSBkZWZhdWx0cyAqL1xuICAgIHRpbWUueWVhciA9IDA7XG4gICAgdGltZS5tb250aCA9IDE7XG4gICAgdGltZS5kYXkgPSAxO1xuICAgIHRpbWUuaG91ciA9IDA7XG4gICAgdGltZS5taW51dGUgPSAwO1xuICAgIHRpbWUuc2Vjb25kID0gMDtcbiAgICB0aW1lLmlzRGF0ZSA9IGZhbHNlO1xuXG4gICAgdGhpcy5mcm9tRGF0YShkYXRhLCB6b25lKTtcbiAgfTtcblxuICBJQ0FMLlRpbWUuX2Rvd0NhY2hlID0ge307XG4gIElDQUwuVGltZS5fd25DYWNoZSA9IHt9O1xuXG4gIElDQUwuVGltZS5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2xhc3MgaWRlbnRpZmllci5cbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IFwiaWNhbHRpbWVcIlxuICAgICAqL1xuICAgIGljYWxjbGFzczogXCJpY2FsdGltZVwiLFxuICAgIF9jYWNoZWRVbml4VGltZTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG5hbWUsIHRvIGJlIHVzZWQgaW4gdGhlIGpDYWwgb2JqZWN0LiBUaGlzIHZhbHVlIG1heSBjaGFuZ2UgYW5kXG4gICAgICogaXMgc3RyaWN0bHkgZGVmaW5lZCBieSB0aGUge0BsaW5rIElDQUwuVGltZSNpc0RhdGUgaXNEYXRlfSBtZW1iZXIuXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBcImRhdGUtdGltZVwiXG4gICAgICovXG4gICAgZ2V0IGljYWx0eXBlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNEYXRlID8gJ2RhdGUnIDogJ2RhdGUtdGltZSc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB0aW1lem9uZSBmb3IgdGhpcyB0aW1lLlxuICAgICAqIEB0eXBlIHtJQ0FMLlRpbWV6b25lfVxuICAgICAqL1xuICAgIHpvbmU6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCB1c2VzIHRvIGluZGljYXRlIHRoYXQgYSBjaGFuZ2UgaGFzIGJlZW4gbWFkZSBhbmQgdGhlIG5leHQgcmVhZFxuICAgICAqIG9wZXJhdGlvbiBtdXN0IGF0dGVtcHQgdG8gbm9ybWFsaXplIHRoZSB2YWx1ZSAoZm9yIGV4YW1wbGUgY2hhbmdpbmcgdGhlXG4gICAgICogZGF5IHRvIDMzKS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3BlbmRpbmdOb3JtYWxpemF0aW9uOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgdGltZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlRpbWV9ICAgICAgICAgICAgICBUaGUgY2xvbmVkIG9iamVjdFxuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgSUNBTC5UaW1lKHRoaXMuX3RpbWUsIHRoaXMuem9uZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSB0aW1lIGluc3RhbmNlIHRvIGVwb2NoIHRpbWVcbiAgICAgKi9cbiAgICByZXNldDogZnVuY3Rpb24gaWNhbHRpbWVfcmVzZXQoKSB7XG4gICAgICB0aGlzLmZyb21EYXRhKElDQUwuVGltZS5lcG9jaFRpbWUpO1xuICAgICAgdGhpcy56b25lID0gSUNBTC5UaW1lem9uZS51dGNUaW1lem9uZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIHRpbWUgaW5zdGFuY2UgdG8gdGhlIGdpdmVuIGRhdGUvdGltZSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geWVhciAgICAgICAgICAgICBUaGUgeWVhciB0byBzZXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbW9udGggICAgICAgICAgICBUaGUgbW9udGggdG8gc2V0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRheSAgICAgICAgICAgICAgVGhlIGRheSB0byBzZXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaG91ciAgICAgICAgICAgICBUaGUgaG91ciB0byBzZXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbWludXRlICAgICAgICAgICBUaGUgbWludXRlIHRvIHNldFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzZWNvbmQgICAgICAgICAgIFRoZSBzZWNvbmQgdG8gc2V0XG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWV6b25lfSB0aW1lem9uZSAgVGhlIHRpbWV6b25lIHRvIHNldFxuICAgICAqL1xuICAgIHJlc2V0VG86IGZ1bmN0aW9uIGljYWx0aW1lX3Jlc2V0VG8oeWVhciwgbW9udGgsIGRheSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCB0aW1lem9uZSkge1xuICAgICAgdGhpcy5mcm9tRGF0YSh7XG4gICAgICAgIHllYXI6IHllYXIsXG4gICAgICAgIG1vbnRoOiBtb250aCxcbiAgICAgICAgZGF5OiBkYXksXG4gICAgICAgIGhvdXI6IGhvdXIsXG4gICAgICAgIG1pbnV0ZTogbWludXRlLFxuICAgICAgICBzZWNvbmQ6IHNlY29uZCxcbiAgICAgICAgem9uZTogdGltZXpvbmVcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdXAgdGhlIGN1cnJlbnQgaW5zdGFuY2UgZnJvbSB0aGUgSmF2YXNjcmlwdCBkYXRlIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/RGF0ZX0gYURhdGUgICAgIFRoZSBKYXZhc2NyaXB0IERhdGUgdG8gcmVhZCwgb3IgbnVsbCB0byByZXNldFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdXNlVVRDICBJZiB0cnVlLCB0aGUgVVRDIHZhbHVlcyBvZiB0aGUgZGF0ZSB3aWxsIGJlIHVzZWRcbiAgICAgKi9cbiAgICBmcm9tSlNEYXRlOiBmdW5jdGlvbiBpY2FsdGltZV9mcm9tSlNEYXRlKGFEYXRlLCB1c2VVVEMpIHtcbiAgICAgIGlmICghYURhdGUpIHtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHVzZVVUQykge1xuICAgICAgICAgIHRoaXMuem9uZSA9IElDQUwuVGltZXpvbmUudXRjVGltZXpvbmU7XG4gICAgICAgICAgdGhpcy55ZWFyID0gYURhdGUuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICAgICAgICB0aGlzLm1vbnRoID0gYURhdGUuZ2V0VVRDTW9udGgoKSArIDE7XG4gICAgICAgICAgdGhpcy5kYXkgPSBhRGF0ZS5nZXRVVENEYXRlKCk7XG4gICAgICAgICAgdGhpcy5ob3VyID0gYURhdGUuZ2V0VVRDSG91cnMoKTtcbiAgICAgICAgICB0aGlzLm1pbnV0ZSA9IGFEYXRlLmdldFVUQ01pbnV0ZXMoKTtcbiAgICAgICAgICB0aGlzLnNlY29uZCA9IGFEYXRlLmdldFVUQ1NlY29uZHMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnpvbmUgPSBJQ0FMLlRpbWV6b25lLmxvY2FsVGltZXpvbmU7XG4gICAgICAgICAgdGhpcy55ZWFyID0gYURhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgICB0aGlzLm1vbnRoID0gYURhdGUuZ2V0TW9udGgoKSArIDE7XG4gICAgICAgICAgdGhpcy5kYXkgPSBhRGF0ZS5nZXREYXRlKCk7XG4gICAgICAgICAgdGhpcy5ob3VyID0gYURhdGUuZ2V0SG91cnMoKTtcbiAgICAgICAgICB0aGlzLm1pbnV0ZSA9IGFEYXRlLmdldE1pbnV0ZXMoKTtcbiAgICAgICAgICB0aGlzLnNlY29uZCA9IGFEYXRlLmdldFNlY29uZHMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fY2FjaGVkVW5peFRpbWUgPSBudWxsO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdXAgdGhlIGN1cnJlbnQgaW5zdGFuY2UgdXNpbmcgbWVtYmVycyBmcm9tIHRoZSBwYXNzZWQgZGF0YSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYURhdGEgICAgICAgICAgICBUaW1lIGluaXRpYWxpemF0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS55ZWFyICAgICAgVGhlIHllYXIgZm9yIHRoaXMgZGF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEubW9udGggICAgIFRoZSBtb250aCBmb3IgdGhpcyBkYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5kYXkgICAgICAgVGhlIGRheSBmb3IgdGhpcyBkYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5ob3VyICAgICAgVGhlIGhvdXIgZm9yIHRoaXMgZGF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEubWludXRlICAgIFRoZSBtaW51dGUgZm9yIHRoaXMgZGF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEuc2Vjb25kICAgIFRoZSBzZWNvbmQgZm9yIHRoaXMgZGF0ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbj19IGFEYXRhLmlzRGF0ZSAgIElmIHRydWUsIHRoZSBpbnN0YW5jZSByZXByZXNlbnRzIGEgZGF0ZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGFzIG9wcG9zZWQgdG8gYSBkYXRlLXRpbWUpXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWV6b25lPX0gYVpvbmUgICAgVGltZXpvbmUgdGhpcyBwb3NpdGlvbiBvY2N1cnMgaW5cbiAgICAgKi9cbiAgICBmcm9tRGF0YTogZnVuY3Rpb24gZnJvbURhdGEoYURhdGEsIGFab25lKSB7XG4gICAgICBpZiAoYURhdGEpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGFEYXRhKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFEYXRhLCBrZXkpKSB7XG4gICAgICAgICAgICAvLyBpY2FsIHR5cGUgY2Fubm90IGJlIHNldFxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2ljYWx0eXBlJykgY29udGludWU7XG4gICAgICAgICAgICB0aGlzW2tleV0gPSBhRGF0YVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYVpvbmUpIHtcbiAgICAgICAgdGhpcy56b25lID0gYVpvbmU7XG4gICAgICB9XG5cbiAgICAgIGlmIChhRGF0YSAmJiAhKFwiaXNEYXRlXCIgaW4gYURhdGEpKSB7XG4gICAgICAgIHRoaXMuaXNEYXRlID0gIShcImhvdXJcIiBpbiBhRGF0YSk7XG4gICAgICB9IGVsc2UgaWYgKGFEYXRhICYmIChcImlzRGF0ZVwiIGluIGFEYXRhKSkge1xuICAgICAgICB0aGlzLmlzRGF0ZSA9IGFEYXRhLmlzRGF0ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFEYXRhICYmIFwidGltZXpvbmVcIiBpbiBhRGF0YSkge1xuICAgICAgICB2YXIgem9uZSA9IElDQUwuVGltZXpvbmVTZXJ2aWNlLmdldChcbiAgICAgICAgICBhRGF0YS50aW1lem9uZVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuem9uZSA9IHpvbmUgfHwgSUNBTC5UaW1lem9uZS5sb2NhbFRpbWV6b25lO1xuICAgICAgfVxuXG4gICAgICBpZiAoYURhdGEgJiYgXCJ6b25lXCIgaW4gYURhdGEpIHtcbiAgICAgICAgdGhpcy56b25lID0gYURhdGEuem9uZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLnpvbmUpIHtcbiAgICAgICAgdGhpcy56b25lID0gSUNBTC5UaW1lem9uZS5sb2NhbFRpbWV6b25lO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jYWNoZWRVbml4VGltZSA9IG51bGw7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBkYXkgb2Ygd2Vlay5cbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZS53ZWVrRGF5PX0gYVdlZWtTdGFydFxuICAgICAqICAgICAgICBUaGUgd2VlayBzdGFydCB3ZWVrZGF5LCBkZWZhdWx0cyB0byBTVU5EQVlcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlRpbWUud2Vla0RheX1cbiAgICAgKi9cbiAgICBkYXlPZldlZWs6IGZ1bmN0aW9uIGljYWx0aW1lX2RheU9mV2VlayhhV2Vla1N0YXJ0KSB7XG4gICAgICB2YXIgZmlyc3REb3cgPSBhV2Vla1N0YXJ0IHx8IElDQUwuVGltZS5TVU5EQVk7XG4gICAgICB2YXIgZG93Q2FjaGVLZXkgPSAodGhpcy55ZWFyIDw8IDEyKSArICh0aGlzLm1vbnRoIDw8IDgpICsgKHRoaXMuZGF5IDw8IDMpICsgZmlyc3REb3c7XG4gICAgICBpZiAoZG93Q2FjaGVLZXkgaW4gSUNBTC5UaW1lLl9kb3dDYWNoZSkge1xuICAgICAgICByZXR1cm4gSUNBTC5UaW1lLl9kb3dDYWNoZVtkb3dDYWNoZUtleV07XG4gICAgICB9XG5cbiAgICAgIC8vIFVzaW5nIFplbGxlcidzIGFsZ29yaXRobVxuICAgICAgdmFyIHEgPSB0aGlzLmRheTtcbiAgICAgIHZhciBtID0gdGhpcy5tb250aCArICh0aGlzLm1vbnRoIDwgMyA/IDEyIDogMCk7XG4gICAgICB2YXIgWSA9IHRoaXMueWVhciAtICh0aGlzLm1vbnRoIDwgMyA/IDEgOiAwKTtcblxuICAgICAgdmFyIGggPSAocSArIFkgKyBJQ0FMLmhlbHBlcnMudHJ1bmMoKChtICsgMSkgKiAyNikgLyAxMCkgKyBJQ0FMLmhlbHBlcnMudHJ1bmMoWSAvIDQpKTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAodHJ1ZSAvKiBncmVnb3JpYW4gKi8pIHtcbiAgICAgICAgaCArPSBJQ0FMLmhlbHBlcnMudHJ1bmMoWSAvIDEwMCkgKiA2ICsgSUNBTC5oZWxwZXJzLnRydW5jKFkgLyA0MDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaCArPSA1O1xuICAgICAgfVxuXG4gICAgICAvLyBOb3JtYWxpemUgdG8gMSA9IHdrc3RcbiAgICAgIGggPSAoKGggKyA3IC0gZmlyc3REb3cpICUgNykgKyAxO1xuICAgICAgSUNBTC5UaW1lLl9kb3dDYWNoZVtkb3dDYWNoZUtleV0gPSBoO1xuICAgICAgcmV0dXJuIGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgZGF5IG9mIHllYXIuXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGRheU9mWWVhcjogZnVuY3Rpb24gZGF5T2ZZZWFyKCkge1xuICAgICAgdmFyIGlzX2xlYXAgPSAoSUNBTC5UaW1lLmlzTGVhcFllYXIodGhpcy55ZWFyKSA/IDEgOiAwKTtcbiAgICAgIHZhciBkaXlwbSA9IElDQUwuVGltZS5kYXlzSW5ZZWFyUGFzc2VkTW9udGg7XG4gICAgICByZXR1cm4gZGl5cG1baXNfbGVhcF1bdGhpcy5tb250aCAtIDFdICsgdGhpcy5kYXk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IGRhdGUvdGltZSwgcmV3b3VuZCB0byB0aGUgc3RhcnQgb2YgdGhlXG4gICAgICogd2Vlay4gVGhlIHJlc3VsdGluZyBJQ0FMLlRpbWUgaW5zdGFuY2UgaXMgb2YgaWNhbHR5cGUgZGF0ZSwgZXZlbiBpZiB0aGlzXG4gICAgICogaXMgYSBkYXRlLXRpbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZS53ZWVrRGF5PX0gYVdlZWtTdGFydFxuICAgICAqICAgICAgICBUaGUgd2VlayBzdGFydCB3ZWVrZGF5LCBkZWZhdWx0cyB0byBTVU5EQVlcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlRpbWV9ICAgICAgVGhlIHN0YXJ0IG9mIHRoZSB3ZWVrIChjbG9uZWQpXG4gICAgICovXG4gICAgc3RhcnRPZldlZWs6IGZ1bmN0aW9uIHN0YXJ0T2ZXZWVrKGFXZWVrU3RhcnQpIHtcbiAgICAgIHZhciBmaXJzdERvdyA9IGFXZWVrU3RhcnQgfHwgSUNBTC5UaW1lLlNVTkRBWTtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNsb25lKCk7XG4gICAgICByZXN1bHQuZGF5IC09ICgodGhpcy5kYXlPZldlZWsoKSArIDcgLSBmaXJzdERvdykgJSA3KTtcbiAgICAgIHJlc3VsdC5pc0RhdGUgPSB0cnVlO1xuICAgICAgcmVzdWx0LmhvdXIgPSAwO1xuICAgICAgcmVzdWx0Lm1pbnV0ZSA9IDA7XG4gICAgICByZXN1bHQuc2Vjb25kID0gMDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IGRhdGUvdGltZSwgc2hpZnRlZCB0byB0aGUgZW5kIG9mIHRoZSB3ZWVrLlxuICAgICAqIFRoZSByZXN1bHRpbmcgSUNBTC5UaW1lIGluc3RhbmNlIGlzIG9mIGljYWx0eXBlIGRhdGUsIGV2ZW4gaWYgdGhpcyBpcyBhXG4gICAgICogZGF0ZS10aW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWUud2Vla0RheT19IGFXZWVrU3RhcnRcbiAgICAgKiAgICAgICAgVGhlIHdlZWsgc3RhcnQgd2Vla2RheSwgZGVmYXVsdHMgdG8gU1VOREFZXG4gICAgICogQHJldHVybiB7SUNBTC5UaW1lfSAgICAgIFRoZSBlbmQgb2YgdGhlIHdlZWsgKGNsb25lZClcbiAgICAgKi9cbiAgICBlbmRPZldlZWs6IGZ1bmN0aW9uIGVuZE9mV2VlayhhV2Vla1N0YXJ0KSB7XG4gICAgICB2YXIgZmlyc3REb3cgPSBhV2Vla1N0YXJ0IHx8IElDQUwuVGltZS5TVU5EQVk7XG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgcmVzdWx0LmRheSArPSAoNyAtIHRoaXMuZGF5T2ZXZWVrKCkgKyBmaXJzdERvdyAtIElDQUwuVGltZS5TVU5EQVkpICUgNztcbiAgICAgIHJlc3VsdC5pc0RhdGUgPSB0cnVlO1xuICAgICAgcmVzdWx0LmhvdXIgPSAwO1xuICAgICAgcmVzdWx0Lm1pbnV0ZSA9IDA7XG4gICAgICByZXN1bHQuc2Vjb25kID0gMDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IGRhdGUvdGltZSwgcmV3b3VuZCB0byB0aGUgc3RhcnQgb2YgdGhlXG4gICAgICogbW9udGguIFRoZSByZXN1bHRpbmcgSUNBTC5UaW1lIGluc3RhbmNlIGlzIG9mIGljYWx0eXBlIGRhdGUsIGV2ZW4gaWZcbiAgICAgKiB0aGlzIGlzIGEgZGF0ZS10aW1lLlxuICAgICAqXG4gICAgICogQHJldHVybiB7SUNBTC5UaW1lfSAgICAgIFRoZSBzdGFydCBvZiB0aGUgbW9udGggKGNsb25lZClcbiAgICAgKi9cbiAgICBzdGFydE9mTW9udGg6IGZ1bmN0aW9uIHN0YXJ0T2ZNb250aCgpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNsb25lKCk7XG4gICAgICByZXN1bHQuZGF5ID0gMTtcbiAgICAgIHJlc3VsdC5pc0RhdGUgPSB0cnVlO1xuICAgICAgcmVzdWx0LmhvdXIgPSAwO1xuICAgICAgcmVzdWx0Lm1pbnV0ZSA9IDA7XG4gICAgICByZXN1bHQuc2Vjb25kID0gMDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IGRhdGUvdGltZSwgc2hpZnRlZCB0byB0aGUgZW5kIG9mIHRoZVxuICAgICAqIG1vbnRoLiAgVGhlIHJlc3VsdGluZyBJQ0FMLlRpbWUgaW5zdGFuY2UgaXMgb2YgaWNhbHR5cGUgZGF0ZSwgZXZlbiBpZlxuICAgICAqIHRoaXMgaXMgYSBkYXRlLXRpbWUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlRpbWV9ICAgICAgVGhlIGVuZCBvZiB0aGUgbW9udGggKGNsb25lZClcbiAgICAgKi9cbiAgICBlbmRPZk1vbnRoOiBmdW5jdGlvbiBlbmRPZk1vbnRoKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgIHJlc3VsdC5kYXkgPSBJQ0FMLlRpbWUuZGF5c0luTW9udGgocmVzdWx0Lm1vbnRoLCByZXN1bHQueWVhcik7XG4gICAgICByZXN1bHQuaXNEYXRlID0gdHJ1ZTtcbiAgICAgIHJlc3VsdC5ob3VyID0gMDtcbiAgICAgIHJlc3VsdC5taW51dGUgPSAwO1xuICAgICAgcmVzdWx0LnNlY29uZCA9IDA7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBkYXRlL3RpbWUsIHJld291bmQgdG8gdGhlIHN0YXJ0IG9mIHRoZVxuICAgICAqIHllYXIuIFRoZSByZXN1bHRpbmcgSUNBTC5UaW1lIGluc3RhbmNlIGlzIG9mIGljYWx0eXBlIGRhdGUsIGV2ZW4gaWZcbiAgICAgKiB0aGlzIGlzIGEgZGF0ZS10aW1lLlxuICAgICAqXG4gICAgICogQHJldHVybiB7SUNBTC5UaW1lfSAgICAgIFRoZSBzdGFydCBvZiB0aGUgeWVhciAoY2xvbmVkKVxuICAgICAqL1xuICAgIHN0YXJ0T2ZZZWFyOiBmdW5jdGlvbiBzdGFydE9mWWVhcigpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNsb25lKCk7XG4gICAgICByZXN1bHQuZGF5ID0gMTtcbiAgICAgIHJlc3VsdC5tb250aCA9IDE7XG4gICAgICByZXN1bHQuaXNEYXRlID0gdHJ1ZTtcbiAgICAgIHJlc3VsdC5ob3VyID0gMDtcbiAgICAgIHJlc3VsdC5taW51dGUgPSAwO1xuICAgICAgcmVzdWx0LnNlY29uZCA9IDA7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBkYXRlL3RpbWUsIHNoaWZ0ZWQgdG8gdGhlIGVuZCBvZiB0aGVcbiAgICAgKiB5ZWFyLiAgVGhlIHJlc3VsdGluZyBJQ0FMLlRpbWUgaW5zdGFuY2UgaXMgb2YgaWNhbHR5cGUgZGF0ZSwgZXZlbiBpZlxuICAgICAqIHRoaXMgaXMgYSBkYXRlLXRpbWUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlRpbWV9ICAgICAgVGhlIGVuZCBvZiB0aGUgeWVhciAoY2xvbmVkKVxuICAgICAqL1xuICAgIGVuZE9mWWVhcjogZnVuY3Rpb24gZW5kT2ZZZWFyKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgIHJlc3VsdC5kYXkgPSAzMTtcbiAgICAgIHJlc3VsdC5tb250aCA9IDEyO1xuICAgICAgcmVzdWx0LmlzRGF0ZSA9IHRydWU7XG4gICAgICByZXN1bHQuaG91ciA9IDA7XG4gICAgICByZXN1bHQubWludXRlID0gMDtcbiAgICAgIHJlc3VsdC5zZWNvbmQgPSAwO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmlyc3QgY2FsY3VsYXRlcyB0aGUgc3RhcnQgb2YgdGhlIHdlZWssIHRoZW4gcmV0dXJucyB0aGUgZGF5IG9mIHllYXIgZm9yXG4gICAgICogdGhpcyBkYXRlLiBJZiB0aGUgZGF5IGZhbGxzIGludG8gdGhlIHByZXZpb3VzIHllYXIsIHRoZSBkYXkgaXMgemVybyBvciBuZWdhdGl2ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SUNBTC5UaW1lLndlZWtEYXk9fSBhRmlyc3REYXlPZldlZWtcbiAgICAgKiAgICAgICAgVGhlIHdlZWsgc3RhcnQgd2Vla2RheSwgZGVmYXVsdHMgdG8gU1VOREFZXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAgICAgVGhlIGNhbGN1bGF0ZWQgZGF5IG9mIHllYXJcbiAgICAgKi9cbiAgICBzdGFydERveVdlZWs6IGZ1bmN0aW9uIHN0YXJ0RG95V2VlayhhRmlyc3REYXlPZldlZWspIHtcbiAgICAgIHZhciBmaXJzdERvdyA9IGFGaXJzdERheU9mV2VlayB8fCBJQ0FMLlRpbWUuU1VOREFZO1xuICAgICAgdmFyIGRlbHRhID0gdGhpcy5kYXlPZldlZWsoKSAtIGZpcnN0RG93O1xuICAgICAgaWYgKGRlbHRhIDwgMCkgZGVsdGEgKz0gNztcbiAgICAgIHJldHVybiB0aGlzLmRheU9mWWVhcigpIC0gZGVsdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZG9taW5pY2FsIGxldHRlciBmb3IgdGhlIGN1cnJlbnQgeWVhci4gTGV0dGVycyByYW5nZSBmcm9tIEEgLSBHXG4gICAgICogZm9yIGNvbW1vbiB5ZWFycywgYW5kIEFHIHRvIEdGIGZvciBsZWFwIHllYXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlyICAgICAgICAgICBUaGUgeWVhciB0byByZXRyaWV2ZSB0aGUgbGV0dGVyIGZvclxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgICAgVGhlIGRvbWluaWNhbCBsZXR0ZXIuXG4gICAgICovXG4gICAgZ2V0RG9taW5pY2FsTGV0dGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBJQ0FMLlRpbWUuZ2V0RG9taW5pY2FsTGV0dGVyKHRoaXMueWVhcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBudGhXZWVrRGF5IHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IG1vbnRoIChub3QgZGF5KS4gIFRoZVxuICAgICAqIHJldHVybmVkIHZhbHVlIGlzIGEgZGF5IHJlbGF0aXZlIHRoZSBtb250aCB0aGF0IHRoaXMgbW9udGggYmVsb25ncyB0byBzb1xuICAgICAqIDEgd291bGQgaW5kaWNhdGUgdGhlIGZpcnN0IG9mIHRoZSBtb250aCBhbmQgNDAgd291bGQgaW5kaWNhdGUgYSBkYXkgaW5cbiAgICAgKiB0aGUgZm9sbG93aW5nIG1vbnRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXlPZldlZWsgICBEYXkgb2YgdGhlIHdlZWsgc2VlIHRoZSBkYXkgbmFtZSBjb25zdGFudHNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYVBvcyAgICAgICAgIE50aCBvY2N1cnJlbmNlIG9mIGEgZ2l2ZW4gd2VlayBkYXkgdmFsdWVzXG4gICAgICogICAgICAgIG9mIDEgYW5kIDAgYm90aCBpbmRpY2F0ZSB0aGUgZmlyc3Qgd2Vla2RheSBvZiB0aGF0IHR5cGUuIGFQb3MgbWF5XG4gICAgICogICAgICAgIGJlIGVpdGhlciBwb3NpdGl2ZSBvciBuZWdhdGl2ZVxuICAgICAqXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBudW1lcmljIHZhbHVlIGluZGljYXRpbmcgYSBkYXkgcmVsYXRpdmVcbiAgICAgKiAgICAgICAgICAgICAgICAgICB0byB0aGUgY3VycmVudCBtb250aCBvZiB0aGlzIHRpbWUgb2JqZWN0XG4gICAgICovXG4gICAgbnRoV2Vla0RheTogZnVuY3Rpb24gaWNhbHRpbWVfbnRoV2Vla0RheShhRGF5T2ZXZWVrLCBhUG9zKSB7XG4gICAgICB2YXIgZGF5c0luTW9udGggPSBJQ0FMLlRpbWUuZGF5c0luTW9udGgodGhpcy5tb250aCwgdGhpcy55ZWFyKTtcbiAgICAgIHZhciB3ZWVrZGF5O1xuICAgICAgdmFyIHBvcyA9IGFQb3M7XG5cbiAgICAgIHZhciBzdGFydCA9IDA7XG5cbiAgICAgIHZhciBvdGhlckRheSA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAgIG90aGVyRGF5LmRheSA9IDE7XG5cbiAgICAgICAgLy8gYmVjYXVzZSAwIG1lYW5zIG5vIHBvc2l0aW9uIGhhcyBiZWVuIGdpdmVuXG4gICAgICAgIC8vIDEgYW5kIDAgaW5kaWNhdGUgdGhlIHNhbWUgZGF5LlxuICAgICAgICBpZiAocG9zICE9IDApIHtcbiAgICAgICAgICAvLyByZW1vdmUgdGhlIGV4dHJhIG51bWVyaWMgdmFsdWVcbiAgICAgICAgICBwb3MtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCBjdXJyZW50IHN0YXJ0IG9mZnNldCB0byBjdXJyZW50IGRheS5cbiAgICAgICAgc3RhcnQgPSBvdGhlckRheS5kYXk7XG5cbiAgICAgICAgLy8gZmluZCB0aGUgY3VycmVudCBkYXkgb2Ygd2Vla1xuICAgICAgICB2YXIgc3RhcnREb3cgPSBvdGhlckRheS5kYXlPZldlZWsoKTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBjdXJyZW50XG4gICAgICAgIC8vIGRheSBvZiB0aGUgd2VlayBhbmQgZGVzaXJlZCBkYXkgb2YgdGhlIHdlZWtcbiAgICAgICAgdmFyIG9mZnNldCA9IGFEYXlPZldlZWsgLSBzdGFydERvdztcblxuXG4gICAgICAgIC8vIGlmIHRoZSBvZmZzZXQgZ29lcyBpbnRvIHRoZSBwYXN0XG4gICAgICAgIC8vIHdlZWsgd2UgYWRkIDcgc28gaXQgZ29lcyBpbnRvIHRoZSBuZXh0XG4gICAgICAgIC8vIHdlZWsuIFdlIG9ubHkgd2FudCB0byBnbyBmb3J3YXJkIGluIHRpbWUgaGVyZS5cbiAgICAgICAgaWYgKG9mZnNldCA8IDApXG4gICAgICAgICAgLy8gdGhpcyBpcyByZWFsbHkgaW1wb3J0YW50IG90aGVyd2lzZSB3ZSB3b3VsZFxuICAgICAgICAgIC8vIGVuZCB1cCB3aXRoIGRhdGVzIGZyb20gaW4gdGhlIHBhc3QuXG4gICAgICAgICAgb2Zmc2V0ICs9IDc7XG5cbiAgICAgICAgLy8gYWRkIG9mZnNldCB0byBzdGFydCBzbyBzdGFydCBpcyB0aGUgc2FtZVxuICAgICAgICAvLyBkYXkgb2YgdGhlIHdlZWsgYXMgdGhlIGRlc2lyZWQgZGF5IG9mIHdlZWsuXG4gICAgICAgIHN0YXJ0ICs9IG9mZnNldDtcblxuICAgICAgICAvLyBiZWNhdXNlIHdlIGFyZSBnb2luZyB0byBhZGQgKGFuZCBtdWx0aXBseSlcbiAgICAgICAgLy8gdGhlIG51bWVyaWMgdmFsdWUgb2YgdGhlIGRheSB3ZSBzdWJ0cmFjdCBpdFxuICAgICAgICAvLyBmcm9tIHRoZSBzdGFydCBwb3NpdGlvbiBzbyBub3QgdG8gYWRkIGl0IHR3aWNlLlxuICAgICAgICBzdGFydCAtPSBhRGF5T2ZXZWVrO1xuXG4gICAgICAgIC8vIHNldCB3ZWVrIGRheVxuICAgICAgICB3ZWVrZGF5ID0gYURheU9mV2VlaztcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gdGhlbiB3ZSBzZXQgaXQgdG8gdGhlIGxhc3QgZGF5IGluIHRoZSBjdXJyZW50IG1vbnRoXG4gICAgICAgIG90aGVyRGF5LmRheSA9IGRheXNJbk1vbnRoO1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIGVuZHMgd2Vla2RheVxuICAgICAgICB2YXIgZW5kRG93ID0gb3RoZXJEYXkuZGF5T2ZXZWVrKCk7XG5cbiAgICAgICAgcG9zKys7XG5cbiAgICAgICAgd2Vla2RheSA9IChlbmREb3cgLSBhRGF5T2ZXZWVrKTtcblxuICAgICAgICBpZiAod2Vla2RheSA8IDApIHtcbiAgICAgICAgICB3ZWVrZGF5ICs9IDc7XG4gICAgICAgIH1cblxuICAgICAgICB3ZWVrZGF5ID0gZGF5c0luTW9udGggLSB3ZWVrZGF5O1xuICAgICAgfVxuXG4gICAgICB3ZWVrZGF5ICs9IHBvcyAqIDc7XG5cbiAgICAgIHJldHVybiBzdGFydCArIHdlZWtkYXk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBjdXJyZW50IHRpbWUgaXMgdGhlIG50aCB3ZWVrZGF5LCByZWxhdGl2ZSB0byB0aGUgY3VycmVudFxuICAgICAqIG1vbnRoLiAgV2lsbCBhbHdheXMgcmV0dXJuIGZhbHNlIHdoZW4gcnVsZSByZXNvbHZlcyBvdXRzaWRlIG9mIGN1cnJlbnRcbiAgICAgKiBtb250aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SUNBTC5UaW1lLndlZWtEYXl9IGFEYXlPZldlZWsgICAgICAgRGF5IG9mIHdlZWsgdG8gY2hlY2tcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYVBvcyAgICAgICAgICAgICAgICAgICAgICAgIFJlbGF0aXZlIHBvc2l0aW9uXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgICAgICAgICAgICAgICAgICBUcnVlLCBpZiBpdCBpcyB0aGUgbnRoIHdlZWtkYXlcbiAgICAgKi9cbiAgICBpc050aFdlZWtEYXk6IGZ1bmN0aW9uKGFEYXlPZldlZWssIGFQb3MpIHtcbiAgICAgIHZhciBkb3cgPSB0aGlzLmRheU9mV2VlaygpO1xuXG4gICAgICBpZiAoYVBvcyA9PT0gMCAmJiBkb3cgPT09IGFEYXlPZldlZWspIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGdldCBwb3NcbiAgICAgIHZhciBkYXkgPSB0aGlzLm50aFdlZWtEYXkoYURheU9mV2VlaywgYVBvcyk7XG5cbiAgICAgIGlmIChkYXkgPT09IHRoaXMuZGF5KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIElTTyA4NjAxIHdlZWsgbnVtYmVyLiBUaGUgZmlyc3Qgd2VlayBvZiBhIHllYXIgaXMgdGhlXG4gICAgICogd2VlayB0aGF0IGNvbnRhaW5zIHRoZSBmaXJzdCBUaHVyc2RheS4gVGhlIHllYXIgY2FuIGhhdmUgNTMgd2Vla3MsIGlmXG4gICAgICogSmFudWFyeSAxc3QgaXMgYSBGcmlkYXkuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoZXJlIGFyZSByZWdpb25zIHdoZXJlIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyIGlzIHRoZSBvbmUgdGhhdFxuICAgICAqIHN0YXJ0cyBvbiBKYW51YXJ5IDFzdCwgd2hpY2ggbWF5IG9mZnNldCB0aGUgd2VlayBudW1iZXIuIEFsc28sIGlmIGFcbiAgICAgKiBkaWZmZXJlbnQgd2VlayBzdGFydCBpcyBzcGVjaWZpZWQsIHRoaXMgd2lsbCBhbHNvIGFmZmVjdCB0aGUgd2Vla1xuICAgICAqIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBzZWUgSUNBTC5UaW1lLndlZWtPbmVTdGFydHNcbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZS53ZWVrRGF5fSBhV2Vla1N0YXJ0ICAgICAgICBUaGUgd2Vla2RheSB0aGUgd2VlayBzdGFydHMgd2l0aFxuICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBJU08gd2VlayBudW1iZXJcbiAgICAgKi9cbiAgICB3ZWVrTnVtYmVyOiBmdW5jdGlvbiB3ZWVrTnVtYmVyKGFXZWVrU3RhcnQpIHtcbiAgICAgIHZhciB3bkNhY2hlS2V5ID0gKHRoaXMueWVhciA8PCAxMikgKyAodGhpcy5tb250aCA8PCA4KSArICh0aGlzLmRheSA8PCAzKSArIGFXZWVrU3RhcnQ7XG4gICAgICBpZiAod25DYWNoZUtleSBpbiBJQ0FMLlRpbWUuX3duQ2FjaGUpIHtcbiAgICAgICAgcmV0dXJuIElDQUwuVGltZS5fd25DYWNoZVt3bkNhY2hlS2V5XTtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgZnVuY3Rpb24gY291cnRlc3R5IG9mIEp1bGlhbiBCdWNrbmFsbCwgcHVibGlzaGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICAgICAgLy8gaHR0cDovL3d3dy5ib3lldC5jb20vYXJ0aWNsZXMvcHVibGlzaGVkYXJ0aWNsZXMvY2FsY3VsYXRpbmd0aGVpc293ZWVrbnVtYi5odG1sXG4gICAgICAvLyBwbHVzIHNvbWUgZml4ZXMgdG8gYmUgYWJsZSB0byB1c2UgZGlmZmVyZW50IHdlZWsgc3RhcnRzLlxuICAgICAgdmFyIHdlZWsxO1xuXG4gICAgICB2YXIgZHQgPSB0aGlzLmNsb25lKCk7XG4gICAgICBkdC5pc0RhdGUgPSB0cnVlO1xuICAgICAgdmFyIGlzb3llYXIgPSB0aGlzLnllYXI7XG5cbiAgICAgIGlmIChkdC5tb250aCA9PSAxMiAmJiBkdC5kYXkgPiAyNSkge1xuICAgICAgICB3ZWVrMSA9IElDQUwuVGltZS53ZWVrT25lU3RhcnRzKGlzb3llYXIgKyAxLCBhV2Vla1N0YXJ0KTtcbiAgICAgICAgaWYgKGR0LmNvbXBhcmUod2VlazEpIDwgMCkge1xuICAgICAgICAgIHdlZWsxID0gSUNBTC5UaW1lLndlZWtPbmVTdGFydHMoaXNveWVhciwgYVdlZWtTdGFydCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXNveWVhcisrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3ZWVrMSA9IElDQUwuVGltZS53ZWVrT25lU3RhcnRzKGlzb3llYXIsIGFXZWVrU3RhcnQpO1xuICAgICAgICBpZiAoZHQuY29tcGFyZSh3ZWVrMSkgPCAwKSB7XG4gICAgICAgICAgd2VlazEgPSBJQ0FMLlRpbWUud2Vla09uZVN0YXJ0cygtLWlzb3llYXIsIGFXZWVrU3RhcnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBkYXlzQmV0d2VlbiA9IChkdC5zdWJ0cmFjdERhdGUod2VlazEpLnRvU2Vjb25kcygpIC8gODY0MDApO1xuICAgICAgdmFyIGFuc3dlciA9IElDQUwuaGVscGVycy50cnVuYyhkYXlzQmV0d2VlbiAvIDcpICsgMTtcbiAgICAgIElDQUwuVGltZS5fd25DYWNoZVt3bkNhY2hlS2V5XSA9IGFuc3dlcjtcbiAgICAgIHJldHVybiBhbnN3ZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIGR1cmF0aW9uIHRvIHRoZSBjdXJyZW50IHRpbWUuIFRoZSBpbnN0YW5jZSBpcyBtb2RpZmllZCBpblxuICAgICAqIHBsYWNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLkR1cmF0aW9ufSBhRHVyYXRpb24gICAgICAgICBUaGUgZHVyYXRpb24gdG8gYWRkXG4gICAgICovXG4gICAgYWRkRHVyYXRpb246IGZ1bmN0aW9uIGljYWx0aW1lX2FkZChhRHVyYXRpb24pIHtcbiAgICAgIHZhciBtdWx0ID0gKGFEdXJhdGlvbi5pc05lZ2F0aXZlID8gLTEgOiAxKTtcblxuICAgICAgLy8gYmVjYXVzZSBvZiB0aGUgZHVyYXRpb24gb3B0aW1pemF0aW9ucyBpdCBpcyBtdWNoXG4gICAgICAvLyBtb3JlIGVmZmljaWVudCB0byBncmFiIGFsbCB0aGUgdmFsdWVzIHVwIGZyb250XG4gICAgICAvLyB0aGVuIHNldCB0aGVtIGRpcmVjdGx5ICh3aGljaCB3aWxsIGF2b2lkIGEgbm9ybWFsaXphdGlvbiBjYWxsKS5cbiAgICAgIC8vIFNvIHdlIGRvbid0IGFjdHVhbGx5IG5vcm1hbGl6ZSB1bnRpbCB3ZSBuZWVkIGl0LlxuICAgICAgdmFyIHNlY29uZCA9IHRoaXMuc2Vjb25kO1xuICAgICAgdmFyIG1pbnV0ZSA9IHRoaXMubWludXRlO1xuICAgICAgdmFyIGhvdXIgPSB0aGlzLmhvdXI7XG4gICAgICB2YXIgZGF5ID0gdGhpcy5kYXk7XG5cbiAgICAgIHNlY29uZCArPSBtdWx0ICogYUR1cmF0aW9uLnNlY29uZHM7XG4gICAgICBtaW51dGUgKz0gbXVsdCAqIGFEdXJhdGlvbi5taW51dGVzO1xuICAgICAgaG91ciArPSBtdWx0ICogYUR1cmF0aW9uLmhvdXJzO1xuICAgICAgZGF5ICs9IG11bHQgKiBhRHVyYXRpb24uZGF5cztcbiAgICAgIGRheSArPSBtdWx0ICogNyAqIGFEdXJhdGlvbi53ZWVrcztcblxuICAgICAgdGhpcy5zZWNvbmQgPSBzZWNvbmQ7XG4gICAgICB0aGlzLm1pbnV0ZSA9IG1pbnV0ZTtcbiAgICAgIHRoaXMuaG91ciA9IGhvdXI7XG4gICAgICB0aGlzLmRheSA9IGRheTtcblxuICAgICAgdGhpcy5fY2FjaGVkVW5peFRpbWUgPSBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdCB0aGUgZGF0ZSBkZXRhaWxzIChfZXhjbHVkaW5nXyB0aW1lem9uZSkuICBVc2VmdWwgZm9yIGZpbmRpbmdcbiAgICAgKiB0aGUgcmVsYXRpdmUgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byB0aW1lIG9iamVjdHMgZXhjbHVkaW5nIHRoZWlyXG4gICAgICogdGltZXpvbmUgZGlmZmVyZW5jZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZX0gYURhdGUgICAgIFRoZSBkYXRlIHRvIHN1YnN0cmFjdFxuICAgICAqIEByZXR1cm4ge0lDQUwuRHVyYXRpb259ICAgICAgVGhlIGRpZmZlcmVuY2UgYXMgYSBkdXJhdGlvblxuICAgICAqL1xuICAgIHN1YnRyYWN0RGF0ZTogZnVuY3Rpb24gaWNhbHRpbWVfc3VidHJhY3QoYURhdGUpIHtcbiAgICAgIHZhciB1bml4VGltZSA9IHRoaXMudG9Vbml4VGltZSgpICsgdGhpcy51dGNPZmZzZXQoKTtcbiAgICAgIHZhciBvdGhlciA9IGFEYXRlLnRvVW5peFRpbWUoKSArIGFEYXRlLnV0Y09mZnNldCgpO1xuICAgICAgcmV0dXJuIElDQUwuRHVyYXRpb24uZnJvbVNlY29uZHModW5peFRpbWUgLSBvdGhlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0IHRoZSBkYXRlIGRldGFpbHMsIHRha2luZyB0aW1lem9uZXMgaW50byBhY2NvdW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWV9IGFEYXRlICBUaGUgZGF0ZSB0byBzdWJ0cmFjdFxuICAgICAqIEByZXR1cm4ge0lDQUwuRHVyYXRpb259ICBUaGUgZGlmZmVyZW5jZSBpbiBkdXJhdGlvblxuICAgICAqL1xuICAgIHN1YnRyYWN0RGF0ZVR6OiBmdW5jdGlvbiBpY2FsdGltZV9zdWJ0cmFjdF9hYnMoYURhdGUpIHtcbiAgICAgIHZhciB1bml4VGltZSA9IHRoaXMudG9Vbml4VGltZSgpO1xuICAgICAgdmFyIG90aGVyID0gYURhdGUudG9Vbml4VGltZSgpO1xuICAgICAgcmV0dXJuIElDQUwuRHVyYXRpb24uZnJvbVNlY29uZHModW5peFRpbWUgLSBvdGhlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbXBhcmVzIHRoZSBJQ0FMLlRpbWUgaW5zdGFuY2Ugd2l0aCBhbm90aGVyIG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SUNBTC5EdXJhdGlvbn0gYU90aGVyICAgICAgICBUaGUgaW5zdGFuY2UgdG8gY29tcGFyZSB3aXRoXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgICAgICAgICAgIC0xLCAwIG9yIDEgZm9yIGxlc3MvZXF1YWwvZ3JlYXRlclxuICAgICAqL1xuICAgIGNvbXBhcmU6IGZ1bmN0aW9uIGljYWx0aW1lX2NvbXBhcmUob3RoZXIpIHtcbiAgICAgIHZhciBhID0gdGhpcy50b1VuaXhUaW1lKCk7XG4gICAgICB2YXIgYiA9IG90aGVyLnRvVW5peFRpbWUoKTtcblxuICAgICAgaWYgKGEgPiBiKSByZXR1cm4gMTtcbiAgICAgIGlmIChiID4gYSkgcmV0dXJuIC0xO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbXBhcmVzIG9ubHkgdGhlIGRhdGUgcGFydCBvZiB0aGlzIGluc3RhbmNlIHdpdGggYW5vdGhlciBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuRHVyYXRpb259IG90aGVyICAgICAgICAgVGhlIGluc3RhbmNlIHRvIGNvbXBhcmUgd2l0aFxuICAgICAqIEBwYXJhbSB7SUNBTC5UaW1lem9uZX0gdHogICAgICAgICAgICBUaGUgdGltZXpvbmUgdG8gY29tcGFyZSBpblxuICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgICAgICAgICAtMSwgMCBvciAxIGZvciBsZXNzL2VxdWFsL2dyZWF0ZXJcbiAgICAgKi9cbiAgICBjb21wYXJlRGF0ZU9ubHlUejogZnVuY3Rpb24gaWNhbHRpbWVfY29tcGFyZURhdGVPbmx5VHoob3RoZXIsIHR6KSB7XG4gICAgICBmdW5jdGlvbiBjbXAoYXR0cikge1xuICAgICAgICByZXR1cm4gSUNBTC5UaW1lLl9jbXBfYXR0cihhLCBiLCBhdHRyKTtcbiAgICAgIH1cbiAgICAgIHZhciBhID0gdGhpcy5jb252ZXJ0VG9ab25lKHR6KTtcbiAgICAgIHZhciBiID0gb3RoZXIuY29udmVydFRvWm9uZSh0eik7XG4gICAgICB2YXIgcmMgPSAwO1xuXG4gICAgICBpZiAoKHJjID0gY21wKFwieWVhclwiKSkgIT0gMCkgcmV0dXJuIHJjO1xuICAgICAgaWYgKChyYyA9IGNtcChcIm1vbnRoXCIpKSAhPSAwKSByZXR1cm4gcmM7XG4gICAgICBpZiAoKHJjID0gY21wKFwiZGF5XCIpKSAhPSAwKSByZXR1cm4gcmM7XG5cbiAgICAgIHJldHVybiByYztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCB0aGUgaW5zdGFuY2UgaW50byBhbm90aGVyIHRpbWV6b25lLiBUaGUgcmV0dXJuZWQgSUNBTC5UaW1lXG4gICAgICogaW5zdGFuY2UgaXMgYWx3YXlzIGEgY29weS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SUNBTC5UaW1lem9uZX0gem9uZSAgICAgIFRoZSB6b25lIHRvIGNvbnZlcnQgdG9cbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlRpbWV9ICAgICAgICAgICAgICBUaGUgY29weSwgY29udmVydGVkIHRvIHRoZSB6b25lXG4gICAgICovXG4gICAgY29udmVydFRvWm9uZTogZnVuY3Rpb24gY29udmVydFRvWm9uZSh6b25lKSB7XG4gICAgICB2YXIgY29weSA9IHRoaXMuY2xvbmUoKTtcbiAgICAgIHZhciB6b25lX2VxdWFscyA9ICh0aGlzLnpvbmUudHppZCA9PSB6b25lLnR6aWQpO1xuXG4gICAgICBpZiAoIXRoaXMuaXNEYXRlICYmICF6b25lX2VxdWFscykge1xuICAgICAgICBJQ0FMLlRpbWV6b25lLmNvbnZlcnRfdGltZShjb3B5LCB0aGlzLnpvbmUsIHpvbmUpO1xuICAgICAgfVxuXG4gICAgICBjb3B5LnpvbmUgPSB6b25lO1xuICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIFVUQyBvZmZzZXQgb2YgdGhlIGN1cnJlbnQgZGF0ZS90aW1lIGluIHRoZSB0aW1lem9uZSBpdCBpc1xuICAgICAqIGluLlxuICAgICAqXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAgICAgVVRDIG9mZnNldCBpbiBzZWNvbmRzXG4gICAgICovXG4gICAgdXRjT2Zmc2V0OiBmdW5jdGlvbiB1dGNfb2Zmc2V0KCkge1xuICAgICAgaWYgKHRoaXMuem9uZSA9PSBJQ0FMLlRpbWV6b25lLmxvY2FsVGltZXpvbmUgfHxcbiAgICAgICAgICB0aGlzLnpvbmUgPT0gSUNBTC5UaW1lem9uZS51dGNUaW1lem9uZSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnpvbmUudXRjT2Zmc2V0KHRoaXMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIFJGQyA1NTQ1IGNvbXBsaWFudCBpY2FsIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBpY2FsIGRhdGUvZGF0ZS10aW1lXG4gICAgICovXG4gICAgdG9JQ0FMU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzdHJpbmcgPSB0aGlzLnRvU3RyaW5nKCk7XG5cbiAgICAgIGlmIChzdHJpbmcubGVuZ3RoID4gMTApIHtcbiAgICAgICAgcmV0dXJuIElDQUwuZGVzaWduLmljYWxlbmRhci52YWx1ZVsnZGF0ZS10aW1lJ10udG9JQ0FMKHN0cmluZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gSUNBTC5kZXNpZ24uaWNhbGVuZGFyLnZhbHVlLmRhdGUudG9JQ0FMKHN0cmluZyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBkYXRlL3RpbWUsIGluIGpDYWwgZm9ybVxuICAgICAqIChpbmNsdWRpbmcgOiBhbmQgLSBzZXBhcmF0b3JzKS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMueWVhciArICctJyArXG4gICAgICAgICAgICAgICAgICAgSUNBTC5oZWxwZXJzLnBhZDIodGhpcy5tb250aCkgKyAnLScgK1xuICAgICAgICAgICAgICAgICAgIElDQUwuaGVscGVycy5wYWQyKHRoaXMuZGF5KTtcblxuICAgICAgaWYgKCF0aGlzLmlzRGF0ZSkge1xuICAgICAgICAgIHJlc3VsdCArPSAnVCcgKyBJQ0FMLmhlbHBlcnMucGFkMih0aGlzLmhvdXIpICsgJzonICtcbiAgICAgICAgICAgICAgICAgICAgSUNBTC5oZWxwZXJzLnBhZDIodGhpcy5taW51dGUpICsgJzonICtcbiAgICAgICAgICAgICAgICAgICAgSUNBTC5oZWxwZXJzLnBhZDIodGhpcy5zZWNvbmQpO1xuXG4gICAgICAgIGlmICh0aGlzLnpvbmUgPT09IElDQUwuVGltZXpvbmUudXRjVGltZXpvbmUpIHtcbiAgICAgICAgICByZXN1bHQgKz0gJ1onO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBjdXJyZW50IGluc3RhbmNlIHRvIGEgSmF2YXNjcmlwdCBkYXRlXG4gICAgICogQHJldHVybiB7RGF0ZX1cbiAgICAgKi9cbiAgICB0b0pTRGF0ZTogZnVuY3Rpb24gdG9KU0RhdGUoKSB7XG4gICAgICBpZiAodGhpcy56b25lID09IElDQUwuVGltZXpvbmUubG9jYWxUaW1lem9uZSkge1xuICAgICAgICBpZiAodGhpcy5pc0RhdGUpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy55ZWFyLCB0aGlzLm1vbnRoIC0gMSwgdGhpcy5kYXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnllYXIsIHRoaXMubW9udGggLSAxLCB0aGlzLmRheSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ob3VyLCB0aGlzLm1pbnV0ZSwgdGhpcy5zZWNvbmQsIDApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy50b1VuaXhUaW1lKCkgKiAxMDAwKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX25vcm1hbGl6ZTogZnVuY3Rpb24gaWNhbHRpbWVfbm9ybWFsaXplKCkge1xuICAgICAgdmFyIGlzRGF0ZSA9IHRoaXMuX3RpbWUuaXNEYXRlO1xuICAgICAgaWYgKHRoaXMuX3RpbWUuaXNEYXRlKSB7XG4gICAgICAgIHRoaXMuX3RpbWUuaG91ciA9IDA7XG4gICAgICAgIHRoaXMuX3RpbWUubWludXRlID0gMDtcbiAgICAgICAgdGhpcy5fdGltZS5zZWNvbmQgPSAwO1xuICAgICAgfVxuICAgICAgdGhpcy5hZGp1c3QoMCwgMCwgMCwgMCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGp1c3QgdGhlIGRhdGUvdGltZSBieSB0aGUgZ2l2ZW4gb2Zmc2V0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYUV4dHJhRGF5cyAgICAgICBUaGUgZXh0cmEgYW1vdW50IG9mIGRheXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYUV4dHJhSG91cnMgICAgICBUaGUgZXh0cmEgYW1vdW50IG9mIGhvdXJzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFFeHRyYU1pbnV0ZXMgICAgVGhlIGV4dHJhIGFtb3VudCBvZiBtaW51dGVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFFeHRyYVNlY29uZHMgICAgVGhlIGV4dHJhIGFtb3VudCBvZiBzZWNvbmRzXG4gICAgICogQHBhcmFtIHtOdW1iZXI9fSBhVGltZSAgICAgICAgICAgVGhlIHRpbWUgdG8gYWRqdXN0LCBkZWZhdWx0cyB0byB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgaW5zdGFuY2UuXG4gICAgICovXG4gICAgYWRqdXN0OiBmdW5jdGlvbiBpY2FsdGltZV9hZGp1c3QoYUV4dHJhRGF5cywgYUV4dHJhSG91cnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYUV4dHJhTWludXRlcywgYUV4dHJhU2Vjb25kcywgYVRpbWUpIHtcblxuICAgICAgdmFyIG1pbnV0ZXNPdmVyZmxvdywgaG91cnNPdmVyZmxvdyxcbiAgICAgICAgICBkYXlzT3ZlcmZsb3cgPSAwLCB5ZWFyc092ZXJmbG93ID0gMDtcblxuICAgICAgdmFyIHNlY29uZCwgbWludXRlLCBob3VyLCBkYXk7XG4gICAgICB2YXIgZGF5c0luTW9udGg7XG5cbiAgICAgIHZhciB0aW1lID0gYVRpbWUgfHwgdGhpcy5fdGltZTtcblxuICAgICAgaWYgKCF0aW1lLmlzRGF0ZSkge1xuICAgICAgICBzZWNvbmQgPSB0aW1lLnNlY29uZCArIGFFeHRyYVNlY29uZHM7XG4gICAgICAgIHRpbWUuc2Vjb25kID0gc2Vjb25kICUgNjA7XG4gICAgICAgIG1pbnV0ZXNPdmVyZmxvdyA9IElDQUwuaGVscGVycy50cnVuYyhzZWNvbmQgLyA2MCk7XG4gICAgICAgIGlmICh0aW1lLnNlY29uZCA8IDApIHtcbiAgICAgICAgICB0aW1lLnNlY29uZCArPSA2MDtcbiAgICAgICAgICBtaW51dGVzT3ZlcmZsb3ctLTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1pbnV0ZSA9IHRpbWUubWludXRlICsgYUV4dHJhTWludXRlcyArIG1pbnV0ZXNPdmVyZmxvdztcbiAgICAgICAgdGltZS5taW51dGUgPSBtaW51dGUgJSA2MDtcbiAgICAgICAgaG91cnNPdmVyZmxvdyA9IElDQUwuaGVscGVycy50cnVuYyhtaW51dGUgLyA2MCk7XG4gICAgICAgIGlmICh0aW1lLm1pbnV0ZSA8IDApIHtcbiAgICAgICAgICB0aW1lLm1pbnV0ZSArPSA2MDtcbiAgICAgICAgICBob3Vyc092ZXJmbG93LS07XG4gICAgICAgIH1cblxuICAgICAgICBob3VyID0gdGltZS5ob3VyICsgYUV4dHJhSG91cnMgKyBob3Vyc092ZXJmbG93O1xuXG4gICAgICAgIHRpbWUuaG91ciA9IGhvdXIgJSAyNDtcbiAgICAgICAgZGF5c092ZXJmbG93ID0gSUNBTC5oZWxwZXJzLnRydW5jKGhvdXIgLyAyNCk7XG4gICAgICAgIGlmICh0aW1lLmhvdXIgPCAwKSB7XG4gICAgICAgICAgdGltZS5ob3VyICs9IDI0O1xuICAgICAgICAgIGRheXNPdmVyZmxvdy0tO1xuICAgICAgICB9XG4gICAgICB9XG5cblxuICAgICAgLy8gQWRqdXN0IG1vbnRoIGFuZCB5ZWFyIGZpcnN0LCBiZWNhdXNlIHdlIG5lZWQgdG8ga25vdyB3aGF0IG1vbnRoIHRoZSBkYXlcbiAgICAgIC8vIGlzIGluIGJlZm9yZSBhZGp1c3RpbmcgaXQuXG4gICAgICBpZiAodGltZS5tb250aCA+IDEyKSB7XG4gICAgICAgIHllYXJzT3ZlcmZsb3cgPSBJQ0FMLmhlbHBlcnMudHJ1bmMoKHRpbWUubW9udGggLSAxKSAvIDEyKTtcbiAgICAgIH0gZWxzZSBpZiAodGltZS5tb250aCA8IDEpIHtcbiAgICAgICAgeWVhcnNPdmVyZmxvdyA9IElDQUwuaGVscGVycy50cnVuYyh0aW1lLm1vbnRoIC8gMTIpIC0gMTtcbiAgICAgIH1cblxuICAgICAgdGltZS55ZWFyICs9IHllYXJzT3ZlcmZsb3c7XG4gICAgICB0aW1lLm1vbnRoIC09IDEyICogeWVhcnNPdmVyZmxvdztcblxuICAgICAgLy8gTm93IHRha2UgY2FyZSBvZiB0aGUgZGF5cyAoYW5kIGFkanVzdCBtb250aCBpZiBuZWVkZWQpXG4gICAgICBkYXkgPSB0aW1lLmRheSArIGFFeHRyYURheXMgKyBkYXlzT3ZlcmZsb3c7XG5cbiAgICAgIGlmIChkYXkgPiAwKSB7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBkYXlzSW5Nb250aCA9IElDQUwuVGltZS5kYXlzSW5Nb250aCh0aW1lLm1vbnRoLCB0aW1lLnllYXIpO1xuICAgICAgICAgIGlmIChkYXkgPD0gZGF5c0luTW9udGgpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRpbWUubW9udGgrKztcbiAgICAgICAgICBpZiAodGltZS5tb250aCA+IDEyKSB7XG4gICAgICAgICAgICB0aW1lLnllYXIrKztcbiAgICAgICAgICAgIHRpbWUubW9udGggPSAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRheSAtPSBkYXlzSW5Nb250aDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2hpbGUgKGRheSA8PSAwKSB7XG4gICAgICAgICAgaWYgKHRpbWUubW9udGggPT0gMSkge1xuICAgICAgICAgICAgdGltZS55ZWFyLS07XG4gICAgICAgICAgICB0aW1lLm1vbnRoID0gMTI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpbWUubW9udGgtLTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkYXkgKz0gSUNBTC5UaW1lLmRheXNJbk1vbnRoKHRpbWUubW9udGgsIHRpbWUueWVhcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGltZS5kYXkgPSBkYXk7XG5cbiAgICAgIHRoaXMuX2NhY2hlZFVuaXhUaW1lID0gbnVsbDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIHRoZSBjdXJyZW50IGluc3RhbmNlIGZyb20gdW5peCB0aW1lLCB0aGUgbnVtYmVyIG9mIHNlY29uZHMgc2luY2VcbiAgICAgKiBKYW51YXJ5IDFzdCwgMTk3MC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzZWNvbmRzICAgICAgVGhlIHNlY29uZHMgdG8gc2V0IHVwIHdpdGhcbiAgICAgKi9cbiAgICBmcm9tVW5peFRpbWU6IGZ1bmN0aW9uIGZyb21Vbml4VGltZShzZWNvbmRzKSB7XG4gICAgICB0aGlzLnpvbmUgPSBJQ0FMLlRpbWV6b25lLnV0Y1RpbWV6b25lO1xuICAgICAgdmFyIGVwb2NoID0gSUNBTC5UaW1lLmVwb2NoVGltZS5jbG9uZSgpO1xuICAgICAgZXBvY2guYWRqdXN0KDAsIDAsIDAsIHNlY29uZHMpO1xuXG4gICAgICB0aGlzLnllYXIgPSBlcG9jaC55ZWFyO1xuICAgICAgdGhpcy5tb250aCA9IGVwb2NoLm1vbnRoO1xuICAgICAgdGhpcy5kYXkgPSBlcG9jaC5kYXk7XG4gICAgICB0aGlzLmhvdXIgPSBlcG9jaC5ob3VyO1xuICAgICAgdGhpcy5taW51dGUgPSBlcG9jaC5taW51dGU7XG4gICAgICB0aGlzLnNlY29uZCA9IE1hdGguZmxvb3IoZXBvY2guc2Vjb25kKTtcblxuICAgICAgdGhpcy5fY2FjaGVkVW5peFRpbWUgPSBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgY3VycmVudCBpbnN0YW5jZSB0byBzZWNvbmRzIHNpbmNlIEphbnVhcnkgMXN0IDE5NzAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgU2Vjb25kcyBzaW5jZSAxOTcwXG4gICAgICovXG4gICAgdG9Vbml4VGltZTogZnVuY3Rpb24gdG9Vbml4VGltZSgpIHtcbiAgICAgIGlmICh0aGlzLl9jYWNoZWRVbml4VGltZSAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkVW5peFRpbWU7XG4gICAgICB9XG4gICAgICB2YXIgb2Zmc2V0ID0gdGhpcy51dGNPZmZzZXQoKTtcblxuICAgICAgLy8gd2UgdXNlIHRoZSBvZmZzZXQgdHJpY2sgdG8gZW5zdXJlXG4gICAgICAvLyB0aGF0IHdlIGFyZSBnZXR0aW5nIHRoZSBhY3R1YWwgVVRDIHRpbWVcbiAgICAgIHZhciBtcyA9IERhdGUuVVRDKFxuICAgICAgICB0aGlzLnllYXIsXG4gICAgICAgIHRoaXMubW9udGggLSAxLFxuICAgICAgICB0aGlzLmRheSxcbiAgICAgICAgdGhpcy5ob3VyLFxuICAgICAgICB0aGlzLm1pbnV0ZSxcbiAgICAgICAgdGhpcy5zZWNvbmQgLSBvZmZzZXRcbiAgICAgICk7XG5cbiAgICAgIC8vIHNlY29uZHNcbiAgICAgIHRoaXMuX2NhY2hlZFVuaXhUaW1lID0gbXMgLyAxMDAwO1xuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZFVuaXhUaW1lO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aW1lIHRvIGludG8gT2JqZWN0IHdoaWNoIGNhbiBiZSBzZXJpYWxpemVkIHRoZW4gcmUtY3JlYXRlZFxuICAgICAqIHVzaW5nIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gdG9KU09OIHdpbGwgYXV0b21hdGljYWxseSBiZSBjYWxsZWRcbiAgICAgKiB2YXIganNvbiA9IEpTT04uc3RyaW5naWZ5KG15dGltZSk7XG4gICAgICpcbiAgICAgKiB2YXIgZGVzZXJpYWxpemVkID0gSlNPTi5wYXJzZShqc29uKTtcbiAgICAgKlxuICAgICAqIHZhciB0aW1lID0gbmV3IElDQUwuVGltZShkZXNlcmlhbGl6ZWQpO1xuICAgICAqXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29weSA9IFtcbiAgICAgICAgJ3llYXInLFxuICAgICAgICAnbW9udGgnLFxuICAgICAgICAnZGF5JyxcbiAgICAgICAgJ2hvdXInLFxuICAgICAgICAnbWludXRlJyxcbiAgICAgICAgJ3NlY29uZCcsXG4gICAgICAgICdpc0RhdGUnXG4gICAgICBdO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGxlbiA9IGNvcHkubGVuZ3RoO1xuICAgICAgdmFyIHByb3A7XG5cbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcHJvcCA9IGNvcHlbaV07XG4gICAgICAgIHJlc3VsdFtwcm9wXSA9IHRoaXNbcHJvcF07XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnpvbmUpIHtcbiAgICAgICAgcmVzdWx0LnRpbWV6b25lID0gdGhpcy56b25lLnR6aWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gIH07XG5cbiAgKGZ1bmN0aW9uIHNldHVwTm9ybWFsaXplQXR0cmlidXRlcygpIHtcbiAgICAvLyBUaGlzIG5lZWRzIHRvIHJ1biBiZWZvcmUgYW55IGluc3RhbmNlcyBhcmUgY3JlYXRlZCFcbiAgICBmdW5jdGlvbiBkZWZpbmVBdHRyKGF0dHIpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJQ0FMLlRpbWUucHJvdG90eXBlLCBhdHRyLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0VGltZUF0dHIoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdOb3JtYWxpemF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9ub3JtYWxpemUoKTtcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdOb3JtYWxpemF0aW9uID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWVbYXR0cl07XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0VGltZUF0dHIodmFsKSB7XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgaXNEYXRlIHdpbGwgYmUgc2V0IGFuZCBpZiB3YXMgbm90IHNldCB0byBub3JtYWxpemUgZGF0ZS5cbiAgICAgICAgICAvLyBUaGlzIGF2b2lkcyBsb3NpbmcgZGF5cyB3aGVuIHNlY29uZHMsIG1pbnV0ZXMgYW5kIGhvdXJzIGFyZSB6ZXJvZWRcbiAgICAgICAgICAvLyB3aGF0IG5vcm1hbGl6ZSB3aWxsIGRvIHdoZW4gdGltZSBpcyBhIGRhdGUuXG4gICAgICAgICAgaWYgKGF0dHIgPT09IFwiaXNEYXRlXCIgJiYgdmFsICYmICF0aGlzLl90aW1lLmlzRGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5hZGp1c3QoMCwgMCwgMCwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2NhY2hlZFVuaXhUaW1lID0gbnVsbDtcbiAgICAgICAgICB0aGlzLl9wZW5kaW5nTm9ybWFsaXphdGlvbiA9IHRydWU7XG4gICAgICAgICAgdGhpcy5fdGltZVthdHRyXSA9IHZhbDtcblxuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoXCJkZWZpbmVQcm9wZXJ0eVwiIGluIE9iamVjdCkge1xuICAgICAgZGVmaW5lQXR0cihcInllYXJcIik7XG4gICAgICBkZWZpbmVBdHRyKFwibW9udGhcIik7XG4gICAgICBkZWZpbmVBdHRyKFwiZGF5XCIpO1xuICAgICAgZGVmaW5lQXR0cihcImhvdXJcIik7XG4gICAgICBkZWZpbmVBdHRyKFwibWludXRlXCIpO1xuICAgICAgZGVmaW5lQXR0cihcInNlY29uZFwiKTtcbiAgICAgIGRlZmluZUF0dHIoXCJpc0RhdGVcIik7XG4gICAgfVxuICB9KSgpO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkYXlzIGluIHRoZSBnaXZlbiBtb250aFxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gbW9udGggICAgICBUaGUgbW9udGggdG8gY2hlY2tcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHllYXIgICAgICAgVGhlIHllYXIgdG8gY2hlY2tcbiAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgVGhlIG51bWJlciBvZiBkYXlzIGluIHRoZSBtb250aFxuICAgKi9cbiAgSUNBTC5UaW1lLmRheXNJbk1vbnRoID0gZnVuY3Rpb24gaWNhbHRpbWVfZGF5c0luTW9udGgobW9udGgsIHllYXIpIHtcbiAgICB2YXIgX2RheXNJbk1vbnRoID0gWzAsIDMxLCAyOCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdO1xuICAgIHZhciBkYXlzID0gMzA7XG5cbiAgICBpZiAobW9udGggPCAxIHx8IG1vbnRoID4gMTIpIHJldHVybiBkYXlzO1xuXG4gICAgZGF5cyA9IF9kYXlzSW5Nb250aFttb250aF07XG5cbiAgICBpZiAobW9udGggPT0gMikge1xuICAgICAgZGF5cyArPSBJQ0FMLlRpbWUuaXNMZWFwWWVhcih5ZWFyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF5cztcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSB5ZWFyIGlzIGEgbGVhcCB5ZWFyXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5ZWFyICAgICAgIFRoZSB5ZWFyIHRvIGNoZWNrXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgIFRydWUsIGlmIHRoZSB5ZWFyIGlzIGEgbGVhcCB5ZWFyXG4gICAqL1xuICBJQ0FMLlRpbWUuaXNMZWFwWWVhciA9IGZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcikge1xuICAgIGlmICh5ZWFyIDw9IDE3NTIpIHtcbiAgICAgIHJldHVybiAoKHllYXIgJSA0KSA9PSAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgoKHllYXIgJSA0ID09IDApICYmICh5ZWFyICUgMTAwICE9IDApKSB8fCAoeWVhciAlIDQwMCA9PSAwKSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgSUNBTC5UaW1lIGZyb20gdGhlIGRheSBvZiB5ZWFyIGFuZCB5ZWFyLiBUaGUgZGF0ZSBpcyByZXR1cm5lZFxuICAgKiBpbiBmbG9hdGluZyB0aW1lem9uZS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXlPZlllYXIgICAgIFRoZSBkYXkgb2YgeWVhclxuICAgKiBAcGFyYW0ge051bWJlcn0gYVllYXIgICAgICAgICAgVGhlIHllYXIgdG8gY3JlYXRlIHRoZSBpbnN0YW5jZSBpblxuICAgKiBAcmV0dXJuIHtJQ0FMLlRpbWV9ICAgICAgICAgICAgVGhlIGNyZWF0ZWQgaW5zdGFuY2Ugd2l0aCB0aGUgY2FsY3VsYXRlZCBkYXRlXG4gICAqL1xuICBJQ0FMLlRpbWUuZnJvbURheU9mWWVhciA9IGZ1bmN0aW9uIGljYWx0aW1lX2Zyb21EYXlPZlllYXIoYURheU9mWWVhciwgYVllYXIpIHtcbiAgICB2YXIgeWVhciA9IGFZZWFyO1xuICAgIHZhciBkb3kgPSBhRGF5T2ZZZWFyO1xuICAgIHZhciB0dCA9IG5ldyBJQ0FMLlRpbWUoKTtcbiAgICB0dC5hdXRvX25vcm1hbGl6ZSA9IGZhbHNlO1xuICAgIHZhciBpc19sZWFwID0gKElDQUwuVGltZS5pc0xlYXBZZWFyKHllYXIpID8gMSA6IDApO1xuXG4gICAgaWYgKGRveSA8IDEpIHtcbiAgICAgIHllYXItLTtcbiAgICAgIGlzX2xlYXAgPSAoSUNBTC5UaW1lLmlzTGVhcFllYXIoeWVhcikgPyAxIDogMCk7XG4gICAgICBkb3kgKz0gSUNBTC5UaW1lLmRheXNJblllYXJQYXNzZWRNb250aFtpc19sZWFwXVsxMl07XG4gICAgICByZXR1cm4gSUNBTC5UaW1lLmZyb21EYXlPZlllYXIoZG95LCB5ZWFyKTtcbiAgICB9IGVsc2UgaWYgKGRveSA+IElDQUwuVGltZS5kYXlzSW5ZZWFyUGFzc2VkTW9udGhbaXNfbGVhcF1bMTJdKSB7XG4gICAgICBpc19sZWFwID0gKElDQUwuVGltZS5pc0xlYXBZZWFyKHllYXIpID8gMSA6IDApO1xuICAgICAgZG95IC09IElDQUwuVGltZS5kYXlzSW5ZZWFyUGFzc2VkTW9udGhbaXNfbGVhcF1bMTJdO1xuICAgICAgeWVhcisrO1xuICAgICAgcmV0dXJuIElDQUwuVGltZS5mcm9tRGF5T2ZZZWFyKGRveSwgeWVhcik7XG4gICAgfVxuXG4gICAgdHQueWVhciA9IHllYXI7XG4gICAgdHQuaXNEYXRlID0gdHJ1ZTtcblxuICAgIGZvciAodmFyIG1vbnRoID0gMTE7IG1vbnRoID49IDA7IG1vbnRoLS0pIHtcbiAgICAgIGlmIChkb3kgPiBJQ0FMLlRpbWUuZGF5c0luWWVhclBhc3NlZE1vbnRoW2lzX2xlYXBdW21vbnRoXSkge1xuICAgICAgICB0dC5tb250aCA9IG1vbnRoICsgMTtcbiAgICAgICAgdHQuZGF5ID0gZG95IC0gSUNBTC5UaW1lLmRheXNJblllYXJQYXNzZWRNb250aFtpc19sZWFwXVttb250aF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHR0LmF1dG9fbm9ybWFsaXplID0gdHJ1ZTtcbiAgICByZXR1cm4gdHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgSUNBTC5UaW1lIGluc3RhbmNlIGZyb20gYSBkYXRlIHN0cmluZywgZS5nIDIwMTUtMDEtMDIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkICAgICAgICAgICAgICAgIFVzZSB7QGxpbmsgSUNBTC5UaW1lLmZyb21EYXRlU3RyaW5nfSBpbnN0ZWFkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgICAgICAgIFRoZSBzdHJpbmcgdG8gY3JlYXRlIGZyb21cbiAgICogQHJldHVybiB7SUNBTC5UaW1lfSAgICAgICAgVGhlIGRhdGUvdGltZSBpbnN0YW5jZVxuICAgKi9cbiAgSUNBTC5UaW1lLmZyb21TdHJpbmd2MiA9IGZ1bmN0aW9uIGZyb21TdHJpbmcoc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBJQ0FMLlRpbWUoe1xuICAgICAgeWVhcjogcGFyc2VJbnQoc3RyLnN1YnN0cigwLCA0KSwgMTApLFxuICAgICAgbW9udGg6IHBhcnNlSW50KHN0ci5zdWJzdHIoNSwgMiksIDEwKSxcbiAgICAgIGRheTogcGFyc2VJbnQoc3RyLnN1YnN0cig4LCAyKSwgMTApLFxuICAgICAgaXNEYXRlOiB0cnVlXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgSUNBTC5UaW1lIGluc3RhbmNlIGZyb20gYSBkYXRlIHN0cmluZywgZS5nIDIwMTUtMDEtMDIuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhVmFsdWUgICAgIFRoZSBzdHJpbmcgdG8gY3JlYXRlIGZyb21cbiAgICogQHJldHVybiB7SUNBTC5UaW1lfSAgICAgICAgVGhlIGRhdGUvdGltZSBpbnN0YW5jZVxuICAgKi9cbiAgSUNBTC5UaW1lLmZyb21EYXRlU3RyaW5nID0gZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgLy8gRGF0ZXMgc2hvdWxkIGhhdmUgbm8gdGltZXpvbmUuXG4gICAgLy8gR29vZ2xlIGxpa2VzIHRvIHNvbWV0aW1lcyBzcGVjaWZ5IFogb24gZGF0ZXNcbiAgICAvLyB3ZSBzcGVjaWZpY2FsbHkgaWdub3JlIHRoYXQgdG8gYXZvaWQgaXNzdWVzLlxuXG4gICAgLy8gWVlZWS1NTS1ERFxuICAgIC8vIDIwMTItMTAtMTBcbiAgICByZXR1cm4gbmV3IElDQUwuVGltZSh7XG4gICAgICB5ZWFyOiBJQ0FMLmhlbHBlcnMuc3RyaWN0UGFyc2VJbnQoYVZhbHVlLnN1YnN0cigwLCA0KSksXG4gICAgICBtb250aDogSUNBTC5oZWxwZXJzLnN0cmljdFBhcnNlSW50KGFWYWx1ZS5zdWJzdHIoNSwgMikpLFxuICAgICAgZGF5OiBJQ0FMLmhlbHBlcnMuc3RyaWN0UGFyc2VJbnQoYVZhbHVlLnN1YnN0cig4LCAyKSksXG4gICAgICBpc0RhdGU6IHRydWVcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBJQ0FMLlRpbWUgaW5zdGFuY2UgZnJvbSBhIGRhdGUtdGltZSBzdHJpbmcsIGUuZ1xuICAgKiAyMDE1LTAxLTAyVDAzOjA0OjA1LiBJZiBhIHByb3BlcnR5IGlzIHNwZWNpZmllZCwgdGhlIHRpbWV6b25lIGlzIHNldCB1cFxuICAgKiBmcm9tIHRoZSBwcm9wZXJ0eSdzIFRaSUQgcGFyYW1ldGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYVZhbHVlICAgICAgICAgVGhlIHN0cmluZyB0byBjcmVhdGUgZnJvbVxuICAgKiBAcGFyYW0ge0lDQUwuUHJvcGVydHk9fSBwcm9wICAgVGhlIHByb3BlcnR5IHRoZSBkYXRlIGJlbG9uZ3MgdG9cbiAgICogQHJldHVybiB7SUNBTC5UaW1lfSAgICAgICAgICAgIFRoZSBkYXRlL3RpbWUgaW5zdGFuY2VcbiAgICovXG4gIElDQUwuVGltZS5mcm9tRGF0ZVRpbWVTdHJpbmcgPSBmdW5jdGlvbihhVmFsdWUsIHByb3ApIHtcbiAgICBpZiAoYVZhbHVlLmxlbmd0aCA8IDE5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdpbnZhbGlkIGRhdGUtdGltZSB2YWx1ZTogXCInICsgYVZhbHVlICsgJ1wiJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgem9uZTtcblxuICAgIGlmIChhVmFsdWVbMTldICYmIGFWYWx1ZVsxOV0gPT09ICdaJykge1xuICAgICAgem9uZSA9ICdaJztcbiAgICB9IGVsc2UgaWYgKHByb3ApIHtcbiAgICAgIHpvbmUgPSBwcm9wLmdldFBhcmFtZXRlcigndHppZCcpO1xuICAgIH1cblxuICAgIC8vIDIwMTItMTAtMTBUMTA6MTA6MTAoWik/XG4gICAgdmFyIHRpbWUgPSBuZXcgSUNBTC5UaW1lKHtcbiAgICAgIHllYXI6IElDQUwuaGVscGVycy5zdHJpY3RQYXJzZUludChhVmFsdWUuc3Vic3RyKDAsIDQpKSxcbiAgICAgIG1vbnRoOiBJQ0FMLmhlbHBlcnMuc3RyaWN0UGFyc2VJbnQoYVZhbHVlLnN1YnN0cig1LCAyKSksXG4gICAgICBkYXk6IElDQUwuaGVscGVycy5zdHJpY3RQYXJzZUludChhVmFsdWUuc3Vic3RyKDgsIDIpKSxcbiAgICAgIGhvdXI6IElDQUwuaGVscGVycy5zdHJpY3RQYXJzZUludChhVmFsdWUuc3Vic3RyKDExLCAyKSksXG4gICAgICBtaW51dGU6IElDQUwuaGVscGVycy5zdHJpY3RQYXJzZUludChhVmFsdWUuc3Vic3RyKDE0LCAyKSksXG4gICAgICBzZWNvbmQ6IElDQUwuaGVscGVycy5zdHJpY3RQYXJzZUludChhVmFsdWUuc3Vic3RyKDE3LCAyKSksXG4gICAgICB0aW1lem9uZTogem9uZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRpbWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgSUNBTC5UaW1lIGluc3RhbmNlIGZyb20gYSBkYXRlIG9yIGRhdGUtdGltZSBzdHJpbmcsXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhVmFsdWUgICAgICAgICBUaGUgc3RyaW5nIHRvIGNyZWF0ZSBmcm9tXG4gICAqIEBwYXJhbSB7SUNBTC5Qcm9wZXJ0eT19IHByb3AgICBUaGUgcHJvcGVydHkgdGhlIGRhdGUgYmVsb25ncyB0b1xuICAgKiBAcmV0dXJuIHtJQ0FMLlRpbWV9ICAgICAgICAgICAgVGhlIGRhdGUvdGltZSBpbnN0YW5jZVxuICAgKi9cbiAgSUNBTC5UaW1lLmZyb21TdHJpbmcgPSBmdW5jdGlvbiBmcm9tU3RyaW5nKGFWYWx1ZSwgYVByb3BlcnR5KSB7XG4gICAgaWYgKGFWYWx1ZS5sZW5ndGggPiAxMCkge1xuICAgICAgcmV0dXJuIElDQUwuVGltZS5mcm9tRGF0ZVRpbWVTdHJpbmcoYVZhbHVlLCBhUHJvcGVydHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gSUNBTC5UaW1lLmZyb21EYXRlU3RyaW5nKGFWYWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IElDQUwuVGltZSBpbnN0YW5jZSBmcm9tIHRoZSBnaXZlbiBKYXZhc2NyaXB0IERhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7P0RhdGV9IGFEYXRlICAgICBUaGUgSmF2YXNjcmlwdCBEYXRlIHRvIHJlYWQsIG9yIG51bGwgdG8gcmVzZXRcbiAgICogQHBhcmFtIHtCb29sZWFufSB1c2VVVEMgIElmIHRydWUsIHRoZSBVVEMgdmFsdWVzIG9mIHRoZSBkYXRlIHdpbGwgYmUgdXNlZFxuICAgKi9cbiAgSUNBTC5UaW1lLmZyb21KU0RhdGUgPSBmdW5jdGlvbiBmcm9tSlNEYXRlKGFEYXRlLCB1c2VVVEMpIHtcbiAgICB2YXIgdHQgPSBuZXcgSUNBTC5UaW1lKCk7XG4gICAgcmV0dXJuIHR0LmZyb21KU0RhdGUoYURhdGUsIHVzZVVUQyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgSUNBTC5UaW1lIGluc3RhbmNlIGZyb20gdGhlIHRoZSBwYXNzZWQgZGF0YSBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhRGF0YSAgICAgICAgICAgIFRpbWUgaW5pdGlhbGl6YXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS55ZWFyICAgICAgVGhlIHllYXIgZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLm1vbnRoICAgICBUaGUgbW9udGggZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLmRheSAgICAgICBUaGUgZGF5IGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5ob3VyICAgICAgVGhlIGhvdXIgZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLm1pbnV0ZSAgICBUaGUgbWludXRlIGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5zZWNvbmQgICAgVGhlIHNlY29uZCBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbj19IGFEYXRhLmlzRGF0ZSAgIElmIHRydWUsIHRoZSBpbnN0YW5jZSByZXByZXNlbnRzIGEgZGF0ZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChhcyBvcHBvc2VkIHRvIGEgZGF0ZS10aW1lKVxuICAgKiBAcGFyYW0ge0lDQUwuVGltZXpvbmU9fSBhWm9uZSAgICBUaW1lem9uZSB0aGlzIHBvc2l0aW9uIG9jY3VycyBpblxuICAgKi9cbiAgSUNBTC5UaW1lLmZyb21EYXRhID0gZnVuY3Rpb24gZnJvbURhdGEoYURhdGEsIGFab25lKSB7XG4gICAgdmFyIHQgPSBuZXcgSUNBTC5UaW1lKCk7XG4gICAgcmV0dXJuIHQuZnJvbURhdGEoYURhdGEsIGFab25lKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBJQ0FMLlRpbWUgaW5zdGFuY2UgZnJvbSB0aGUgY3VycmVudCBtb21lbnQuXG4gICAqIFRoZSBpbnN0YW5jZSBpcyBcdTIwMUNmbG9hdGluZ1x1MjAxRCAtIGhhcyBubyB0aW1lem9uZSByZWxhdGlvbi5cbiAgICogVG8gY3JlYXRlIGFuIGluc3RhbmNlIGNvbnNpZGVyaW5nIHRoZSB0aW1lIHpvbmUsIGNhbGxcbiAgICogSUNBTC5UaW1lLmZyb21KU0RhdGUobmV3IERhdGUoKSwgdHJ1ZSlcbiAgICogQHJldHVybiB7SUNBTC5UaW1lfVxuICAgKi9cbiAgSUNBTC5UaW1lLm5vdyA9IGZ1bmN0aW9uIGljYWx0aW1lX25vdygpIHtcbiAgICByZXR1cm4gSUNBTC5UaW1lLmZyb21KU0RhdGUobmV3IERhdGUoKSwgZmFsc2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkYXRlIG9uIHdoaWNoIElTTyB3ZWVrIG51bWJlciAxIHN0YXJ0cy5cbiAgICpcbiAgICogQHNlZSBJQ0FMLlRpbWUjd2Vla051bWJlclxuICAgKiBAcGFyYW0ge051bWJlcn0gYVllYXIgICAgICAgICAgICAgICAgICBUaGUgeWVhciB0byBzZWFyY2ggaW5cbiAgICogQHBhcmFtIHtJQ0FMLlRpbWUud2Vla0RheT19IGFXZWVrU3RhcnQgVGhlIHdlZWsgc3RhcnQgd2Vla2RheSwgdXNlZCBmb3IgY2FsY3VsYXRpb24uXG4gICAqIEByZXR1cm4ge0lDQUwuVGltZX0gICAgICAgICAgICAgICAgICAgIFRoZSBkYXRlIG9uIHdoaWNoIHdlZWsgbnVtYmVyIDEgc3RhcnRzXG4gICAqL1xuICBJQ0FMLlRpbWUud2Vla09uZVN0YXJ0cyA9IGZ1bmN0aW9uIHdlZWtPbmVTdGFydHMoYVllYXIsIGFXZWVrU3RhcnQpIHtcbiAgICB2YXIgdCA9IElDQUwuVGltZS5mcm9tRGF0YSh7XG4gICAgICB5ZWFyOiBhWWVhcixcbiAgICAgIG1vbnRoOiAxLFxuICAgICAgZGF5OiAxLFxuICAgICAgaXNEYXRlOiB0cnVlXG4gICAgfSk7XG5cbiAgICB2YXIgZG93ID0gdC5kYXlPZldlZWsoKTtcbiAgICB2YXIgd2tzdCA9IGFXZWVrU3RhcnQgfHwgSUNBTC5UaW1lLkRFRkFVTFRfV0VFS19TVEFSVDtcbiAgICBpZiAoZG93ID4gSUNBTC5UaW1lLlRIVVJTREFZKSB7XG4gICAgICB0LmRheSArPSA3O1xuICAgIH1cbiAgICBpZiAod2tzdCA+IElDQUwuVGltZS5USFVSU0RBWSkge1xuICAgICAgdC5kYXkgLT0gNztcbiAgICB9XG5cbiAgICB0LmRheSAtPSBkb3cgLSB3a3N0O1xuXG4gICAgcmV0dXJuIHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZG9taW5pY2FsIGxldHRlciBmb3IgdGhlIGdpdmVuIHllYXIuIExldHRlcnMgcmFuZ2UgZnJvbSBBIC0gRyBmb3JcbiAgICogY29tbW9uIHllYXJzLCBhbmQgQUcgdG8gR0YgZm9yIGxlYXAgeWVhcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5ciAgICAgICAgICAgVGhlIHllYXIgdG8gcmV0cmlldmUgdGhlIGxldHRlciBmb3JcbiAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICAgICBUaGUgZG9taW5pY2FsIGxldHRlci5cbiAgICovXG4gIElDQUwuVGltZS5nZXREb21pbmljYWxMZXR0ZXIgPSBmdW5jdGlvbih5cikge1xuICAgIHZhciBMVFJTID0gXCJHRkVEQ0JBXCI7XG4gICAgdmFyIGRvbSA9ICh5ciArICh5ciAvIDQgfCAwKSArICh5ciAvIDQwMCB8IDApIC0gKHlyIC8gMTAwIHwgMCkgLSAxKSAlIDc7XG4gICAgdmFyIGlzTGVhcCA9IElDQUwuVGltZS5pc0xlYXBZZWFyKHlyKTtcbiAgICBpZiAoaXNMZWFwKSB7XG4gICAgICByZXR1cm4gTFRSU1soZG9tICsgNikgJSA3XSArIExUUlNbZG9tXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIExUUlNbZG9tXTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEphbnVhcnkgMXN0LCAxOTcwIGFzIGFuIElDQUwuVGltZS5cbiAgICogQHR5cGUge0lDQUwuVGltZX1cbiAgICogQGNvbnN0YW50XG4gICAqIEBpbnN0YW5jZVxuICAgKi9cbiAgSUNBTC5UaW1lLmVwb2NoVGltZSA9IElDQUwuVGltZS5mcm9tRGF0YSh7XG4gICAgeWVhcjogMTk3MCxcbiAgICBtb250aDogMSxcbiAgICBkYXk6IDEsXG4gICAgaG91cjogMCxcbiAgICBtaW51dGU6IDAsXG4gICAgc2Vjb25kOiAwLFxuICAgIGlzRGF0ZTogZmFsc2UsXG4gICAgdGltZXpvbmU6IFwiWlwiXG4gIH0pO1xuXG4gIElDQUwuVGltZS5fY21wX2F0dHIgPSBmdW5jdGlvbiBfY21wX2F0dHIoYSwgYiwgYXR0cikge1xuICAgIGlmIChhW2F0dHJdID4gYlthdHRyXSkgcmV0dXJuIDE7XG4gICAgaWYgKGFbYXR0cl0gPCBiW2F0dHJdKSByZXR1cm4gLTE7XG4gICAgcmV0dXJuIDA7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoZSBkYXlzIHRoYXQgaGF2ZSBwYXNzZWQgaW4gdGhlIHllYXIgYWZ0ZXIgYSBnaXZlbiBtb250aC4gVGhlIGFycmF5IGhhc1xuICAgKiB0d28gbWVtYmVycywgb25lIGJlaW5nIGFuIGFycmF5IG9mIHBhc3NlZCBkYXlzIGZvciBub24tbGVhcCB5ZWFycywgdGhlXG4gICAqIG90aGVyIGFuYWxvZyBmb3IgbGVhcCB5ZWFycy5cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGlzTGVhcFllYXIgPSBJQ0FMLlRpbWUuaXNMZWFwWWVhcih5ZWFyKTtcbiAgICogdmFyIHBhc3NlZERheXMgPSBJQ0FMLlRpbWUuZGF5c0luWWVhclBhc3NlZE1vbnRoW2lzTGVhcFllYXJdW21vbnRoXTtcbiAgICogQHR5cGUge0FycmF5LjxBcnJheS48TnVtYmVyPj59XG4gICAqL1xuICBJQ0FMLlRpbWUuZGF5c0luWWVhclBhc3NlZE1vbnRoID0gW1xuICAgIFswLCAzMSwgNTksIDkwLCAxMjAsIDE1MSwgMTgxLCAyMTIsIDI0MywgMjczLCAzMDQsIDMzNCwgMzY1XSxcbiAgICBbMCwgMzEsIDYwLCA5MSwgMTIxLCAxNTIsIDE4MiwgMjEzLCAyNDQsIDI3NCwgMzA1LCAzMzUsIDM2Nl1cbiAgXTtcblxuICAvKipcbiAgICogVGhlIHdlZWtkYXksIDEgPSBTVU5EQVksIDcgPSBTQVRVUkRBWS4gQWNjZXNzIHZpYVxuICAgKiBJQ0FMLlRpbWUuTU9OREFZLCBJQ0FMLlRpbWUuVFVFU0RBWSwgLi4uXG4gICAqXG4gICAqIEB0eXBlZGVmIHtOdW1iZXJ9IHdlZWtEYXlcbiAgICogQG1lbWJlcm9mIElDQUwuVGltZVxuICAgKi9cblxuICBJQ0FMLlRpbWUuU1VOREFZID0gMTtcbiAgSUNBTC5UaW1lLk1PTkRBWSA9IDI7XG4gIElDQUwuVGltZS5UVUVTREFZID0gMztcbiAgSUNBTC5UaW1lLldFRE5FU0RBWSA9IDQ7XG4gIElDQUwuVGltZS5USFVSU0RBWSA9IDU7XG4gIElDQUwuVGltZS5GUklEQVkgPSA2O1xuICBJQ0FMLlRpbWUuU0FUVVJEQVkgPSA3O1xuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCB3ZWVrZGF5IGZvciB0aGUgV0tTVCBwYXJ0LlxuICAgKiBAY29uc3RhbnRcbiAgICogQGRlZmF1bHQgSUNBTC5UaW1lLk1PTkRBWVxuICAgKi9cbiAgSUNBTC5UaW1lLkRFRkFVTFRfV0VFS19TVEFSVCA9IElDQUwuVGltZS5NT05EQVk7XG59KSgpO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoLCAyMDE1ICovXG5cblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgLyoqXG4gICAqIERlc2NyaWJlcyBhIHZDYXJkIHRpbWUsIHdoaWNoIGhhcyBzbGlnaHQgZGlmZmVyZW5jZXMgdG8gdGhlIElDQUwuVGltZS5cbiAgICogUHJvcGVydGllcyBjYW4gYmUgbnVsbCBpZiBub3Qgc3BlY2lmaWVkLCBmb3IgZXhhbXBsZSBmb3IgZGF0ZXMgd2l0aFxuICAgKiByZWR1Y2VkIGFjY3VyYWN5IG9yIHRydW5jYXRpb24uXG4gICAqXG4gICAqIE5vdGUgdGhhdCBjdXJyZW50bHkgbm90IGFsbCBtZXRob2RzIGFyZSBjb3JyZWN0bHkgcmUtaW1wbGVtZW50ZWQgZm9yXG4gICAqIFZDYXJkVGltZS4gRm9yIGV4YW1wbGUsIGNvbXBhcmlzb24gd2lsbCBoYXZlIHVuZGVmaW5lZCByZXN1bHRzIHdoZW4gc29tZVxuICAgKiBtZW1iZXJzIGFyZSBudWxsLlxuICAgKlxuICAgKiBBbHNvLCBub3JtYWxpemF0aW9uIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgZm9yIHRoaXMgY2xhc3MhXG4gICAqXG4gICAqIEBhbGlhcyBJQ0FMLlZDYXJkVGltZVxuICAgKiBAY2xhc3NcbiAgICogQGV4dGVuZHMge0lDQUwuVGltZX1cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgZGF0YSBmb3IgdGhlIHRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLnllYXIgICAgICAgICAgICAgICAgICAgICBUaGUgeWVhciBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS5tb250aCAgICAgICAgICAgICAgICAgICAgVGhlIG1vbnRoIGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLmRheSAgICAgICAgICAgICAgICAgICAgICBUaGUgZGF5IGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLmhvdXIgICAgICAgICAgICAgICAgICAgICBUaGUgaG91ciBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS5taW51dGUgICAgICAgICAgICAgICAgICAgVGhlIG1pbnV0ZSBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS5zZWNvbmQgICAgICAgICAgICAgICAgICAgVGhlIHNlY29uZCBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7SUNBTC5UaW1lem9uZXxJQ0FMLlV0Y09mZnNldH0gem9uZSAgICAgVGhlIHRpbWV6b25lIHRvIHVzZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gaWNhbHR5cGUgICAgICAgICAgICAgICAgICAgICAgIFRoZSB0eXBlIGZvciB0aGlzIGRhdGUvdGltZSBvYmplY3RcbiAgICovXG4gIElDQUwuVkNhcmRUaW1lID0gZnVuY3Rpb24oZGF0YSwgem9uZSwgaWNhbHR5cGUpIHtcbiAgICB0aGlzLndyYXBwZWRKU09iamVjdCA9IHRoaXM7XG4gICAgdmFyIHRpbWUgPSB0aGlzLl90aW1lID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIHRpbWUueWVhciA9IG51bGw7XG4gICAgdGltZS5tb250aCA9IG51bGw7XG4gICAgdGltZS5kYXkgPSBudWxsO1xuICAgIHRpbWUuaG91ciA9IG51bGw7XG4gICAgdGltZS5taW51dGUgPSBudWxsO1xuICAgIHRpbWUuc2Vjb25kID0gbnVsbDtcblxuICAgIHRoaXMuaWNhbHR5cGUgPSBpY2FsdHlwZSB8fCBcImRhdGUtYW5kLW9yLXRpbWVcIjtcblxuICAgIHRoaXMuZnJvbURhdGEoZGF0YSwgem9uZSk7XG4gIH07XG4gIElDQUwuaGVscGVycy5pbmhlcml0cyhJQ0FMLlRpbWUsIElDQUwuVkNhcmRUaW1lLCAvKiogQGxlbmRzIElDQUwuVkNhcmRUaW1lICovIHtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjbGFzcyBpZGVudGlmaWVyLlxuICAgICAqIEBjb25zdGFudFxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgXCJ2Y2FyZHRpbWVcIlxuICAgICAqL1xuICAgIGljYWxjbGFzczogXCJ2Y2FyZHRpbWVcIixcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG5hbWUsIHRvIGJlIHVzZWQgaW4gdGhlIGpDYWwgb2JqZWN0LlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgXCJkYXRlLWFuZC1vci10aW1lXCJcbiAgICAgKi9cbiAgICBpY2FsdHlwZTogXCJkYXRlLWFuZC1vci10aW1lXCIsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGltZXpvbmUuIFRoaXMgY2FuIGVpdGhlciBiZSBmbG9hdGluZywgVVRDLCBvciBhbiBpbnN0YW5jZSBvZlxuICAgICAqIElDQUwuVXRjT2Zmc2V0LlxuICAgICAqIEB0eXBlIHtJQ0FMLlRpbWV6b25lfElDQUwuVXRjT0Zmc2V0fVxuICAgICAqL1xuICAgIHpvbmU6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIHZjYXJkIGRhdGUvdGltZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlZDYXJkVGltZX0gICAgIFRoZSBjbG9uZWQgb2JqZWN0XG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBJQ0FMLlZDYXJkVGltZSh0aGlzLl90aW1lLCB0aGlzLnpvbmUsIHRoaXMuaWNhbHR5cGUpO1xuICAgIH0sXG5cbiAgICBfbm9ybWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdGRvY1xuICAgICAqL1xuICAgIHV0Y09mZnNldDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy56b25lIGluc3RhbmNlb2YgSUNBTC5VdGNPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuem9uZS50b1NlY29uZHMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBJQ0FMLlRpbWUucHJvdG90eXBlLnV0Y09mZnNldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIFJGQyA2MzUwIGNvbXBsaWFudCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICB2Y2FyZCBkYXRlL3RpbWUgc3RyaW5nXG4gICAgICovXG4gICAgdG9JQ0FMU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBJQ0FMLmRlc2lnbi52Y2FyZC52YWx1ZVt0aGlzLmljYWx0eXBlXS50b0lDQUwodGhpcy50b1N0cmluZygpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGRhdGUvdGltZSwgaW4gakNhcmQgZm9ybVxuICAgICAqIChpbmNsdWRpbmcgOiBhbmQgLSBzZXBhcmF0b3JzKS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgdmFyIHAyID0gSUNBTC5oZWxwZXJzLnBhZDI7XG4gICAgICB2YXIgeSA9IHRoaXMueWVhciwgbSA9IHRoaXMubW9udGgsIGQgPSB0aGlzLmRheTtcbiAgICAgIHZhciBoID0gdGhpcy5ob3VyLCBtbSA9IHRoaXMubWludXRlLCBzID0gdGhpcy5zZWNvbmQ7XG5cbiAgICAgIHZhciBoYXNZZWFyID0geSAhPT0gbnVsbCwgaGFzTW9udGggPSBtICE9PSBudWxsLCBoYXNEYXkgPSBkICE9PSBudWxsO1xuICAgICAgdmFyIGhhc0hvdXIgPSBoICE9PSBudWxsLCBoYXNNaW51dGUgPSBtbSAhPT0gbnVsbCwgaGFzU2Vjb25kID0gcyAhPT0gbnVsbDtcblxuICAgICAgdmFyIGRhdGVwYXJ0ID0gKGhhc1llYXIgPyBwMih5KSArIChoYXNNb250aCB8fCBoYXNEYXkgPyAnLScgOiAnJykgOiAoaGFzTW9udGggfHwgaGFzRGF5ID8gJy0tJyA6ICcnKSkgK1xuICAgICAgICAgICAgICAgICAgICAgKGhhc01vbnRoID8gcDIobSkgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAgKGhhc0RheSA/ICctJyArIHAyKGQpIDogJycpO1xuICAgICAgdmFyIHRpbWVwYXJ0ID0gKGhhc0hvdXIgPyBwMihoKSA6ICctJykgKyAoaGFzSG91ciAmJiBoYXNNaW51dGUgPyAnOicgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAgKGhhc01pbnV0ZSA/IHAyKG1tKSA6ICcnKSArICghaGFzSG91ciAmJiAhaGFzTWludXRlID8gJy0nIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgIChoYXNNaW51dGUgJiYgaGFzU2Vjb25kID8gJzonIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgIChoYXNTZWNvbmQgPyBwMihzKSA6ICcnKTtcblxuICAgICAgdmFyIHpvbmU7XG4gICAgICBpZiAodGhpcy56b25lID09PSBJQ0FMLlRpbWV6b25lLnV0Y1RpbWV6b25lKSB7XG4gICAgICAgIHpvbmUgPSAnWic7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuem9uZSBpbnN0YW5jZW9mIElDQUwuVXRjT2Zmc2V0KSB7XG4gICAgICAgIHpvbmUgPSB0aGlzLnpvbmUudG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy56b25lID09PSBJQ0FMLlRpbWV6b25lLmxvY2FsVGltZXpvbmUpIHtcbiAgICAgICAgem9uZSA9ICcnO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnpvbmUgaW5zdGFuY2VvZiBJQ0FMLlRpbWV6b25lKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSBJQ0FMLlV0Y09mZnNldC5mcm9tU2Vjb25kcyh0aGlzLnpvbmUudXRjT2Zmc2V0KHRoaXMpKTtcbiAgICAgICAgem9uZSA9IG9mZnNldC50b1N0cmluZygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgem9uZSA9ICcnO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHRoaXMuaWNhbHR5cGUpIHtcbiAgICAgICAgY2FzZSBcInRpbWVcIjpcbiAgICAgICAgICByZXR1cm4gdGltZXBhcnQgKyB6b25lO1xuICAgICAgICBjYXNlIFwiZGF0ZS1hbmQtb3ItdGltZVwiOlxuICAgICAgICBjYXNlIFwiZGF0ZS10aW1lXCI6XG4gICAgICAgICAgcmV0dXJuIGRhdGVwYXJ0ICsgKHRpbWVwYXJ0ID09ICctLScgPyAnJyA6ICdUJyArIHRpbWVwYXJ0ICsgem9uZSk7XG4gICAgICAgIGNhc2UgXCJkYXRlXCI6XG4gICAgICAgICAgcmV0dXJuIGRhdGVwYXJ0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBJQ0FMLlZDYXJkVGltZSBpbnN0YW5jZSBmcm9tIGEgZGF0ZSBhbmQvb3IgdGltZSBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhVmFsdWUgICAgIFRoZSBzdHJpbmcgdG8gY3JlYXRlIGZyb21cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFJY2FsVHlwZSAgVGhlIHR5cGUgZm9yIHRoaXMgaW5zdGFuY2UsIGUuZy4gZGF0ZS1hbmQtb3ItdGltZVxuICAgKiBAcmV0dXJuIHtJQ0FMLlZDYXJkVGltZX0gICBUaGUgZGF0ZS90aW1lIGluc3RhbmNlXG4gICAqL1xuICBJQ0FMLlZDYXJkVGltZS5mcm9tRGF0ZUFuZE9yVGltZVN0cmluZyA9IGZ1bmN0aW9uKGFWYWx1ZSwgYUljYWxUeXBlKSB7XG4gICAgZnVuY3Rpb24gcGFydCh2LCBzLCBlKSB7XG4gICAgICByZXR1cm4gdiA/IElDQUwuaGVscGVycy5zdHJpY3RQYXJzZUludCh2LnN1YnN0cihzLCBlKSkgOiBudWxsO1xuICAgIH1cbiAgICB2YXIgcGFydHMgPSBhVmFsdWUuc3BsaXQoJ1QnKTtcbiAgICB2YXIgZHQgPSBwYXJ0c1swXSwgdG16ID0gcGFydHNbMV07XG4gICAgdmFyIHNwbGl0em9uZSA9IHRteiA/IElDQUwuZGVzaWduLnZjYXJkLnZhbHVlLnRpbWUuX3NwbGl0Wm9uZSh0bXopIDogW107XG4gICAgdmFyIHpvbmUgPSBzcGxpdHpvbmVbMF0sIHRtID0gc3BsaXR6b25lWzFdO1xuXG4gICAgdmFyIHN0b2kgPSBJQ0FMLmhlbHBlcnMuc3RyaWN0UGFyc2VJbnQ7XG4gICAgdmFyIGR0bGVuID0gZHQgPyBkdC5sZW5ndGggOiAwO1xuICAgIHZhciB0bWxlbiA9IHRtID8gdG0ubGVuZ3RoIDogMDtcblxuICAgIHZhciBoYXNEYXNoRGF0ZSA9IGR0ICYmIGR0WzBdID09ICctJyAmJiBkdFsxXSA9PSAnLSc7XG4gICAgdmFyIGhhc0Rhc2hUaW1lID0gdG0gJiYgdG1bMF0gPT0gJy0nO1xuXG4gICAgdmFyIG8gPSB7XG4gICAgICB5ZWFyOiBoYXNEYXNoRGF0ZSA/IG51bGwgOiBwYXJ0KGR0LCAwLCA0KSxcbiAgICAgIG1vbnRoOiBoYXNEYXNoRGF0ZSAmJiAoZHRsZW4gPT0gNCB8fCBkdGxlbiA9PSA3KSA/IHBhcnQoZHQsIDIsIDIpIDogZHRsZW4gPT0gNyA/IHBhcnQoZHQsIDUsIDIpIDogZHRsZW4gPT0gMTAgPyBwYXJ0KGR0LCA1LCAyKSA6IG51bGwsXG4gICAgICBkYXk6IGR0bGVuID09IDUgPyBwYXJ0KGR0LCAzLCAyKSA6IGR0bGVuID09IDcgJiYgaGFzRGFzaERhdGUgPyBwYXJ0KGR0LCA1LCAyKSA6IGR0bGVuID09IDEwID8gcGFydChkdCwgOCwgMikgOiBudWxsLFxuXG4gICAgICBob3VyOiBoYXNEYXNoVGltZSA/IG51bGwgOiBwYXJ0KHRtLCAwLCAyKSxcbiAgICAgIG1pbnV0ZTogaGFzRGFzaFRpbWUgJiYgdG1sZW4gPT0gMyA/IHBhcnQodG0sIDEsIDIpIDogdG1sZW4gPiA0ID8gaGFzRGFzaFRpbWUgPyBwYXJ0KHRtLCAxLCAyKSA6IHBhcnQodG0sIDMsIDIpIDogbnVsbCxcbiAgICAgIHNlY29uZDogdG1sZW4gPT0gNCA/IHBhcnQodG0sIDIsIDIpIDogdG1sZW4gPT0gNiA/IHBhcnQodG0sIDQsIDIpIDogdG1sZW4gPT0gOCA/IHBhcnQodG0sIDYsIDIpIDogbnVsbFxuICAgIH07XG5cbiAgICBpZiAoem9uZSA9PSAnWicpIHtcbiAgICAgIHpvbmUgPSBJQ0FMLlRpbWV6b25lLnV0Y1RpbWV6b25lO1xuICAgIH0gZWxzZSBpZiAoem9uZSAmJiB6b25lWzNdID09ICc6Jykge1xuICAgICAgem9uZSA9IElDQUwuVXRjT2Zmc2V0LmZyb21TdHJpbmcoem9uZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHpvbmUgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgSUNBTC5WQ2FyZFRpbWUobywgem9uZSwgYUljYWxUeXBlKTtcbiAgfTtcbn0pKCk7XG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICogUG9ydGlvbnMgQ29weXJpZ2h0IChDKSBQaGlsaXBwIEtld2lzY2gsIDIwMTEtMjAxNSAqL1xuXG5cblxuKGZ1bmN0aW9uKCkge1xuICB2YXIgRE9XX01BUCA9IHtcbiAgICBTVTogSUNBTC5UaW1lLlNVTkRBWSxcbiAgICBNTzogSUNBTC5UaW1lLk1PTkRBWSxcbiAgICBUVTogSUNBTC5UaW1lLlRVRVNEQVksXG4gICAgV0U6IElDQUwuVGltZS5XRURORVNEQVksXG4gICAgVEg6IElDQUwuVGltZS5USFVSU0RBWSxcbiAgICBGUjogSUNBTC5UaW1lLkZSSURBWSxcbiAgICBTQTogSUNBTC5UaW1lLlNBVFVSREFZXG4gIH07XG5cbiAgdmFyIFJFVkVSU0VfRE9XX01BUCA9IHt9O1xuICBmb3IgKHZhciBrZXkgaW4gRE9XX01BUCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKERPV19NQVAuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgUkVWRVJTRV9ET1dfTUFQW0RPV19NQVBba2V5XV0gPSBrZXk7XG4gICAgfVxuICB9XG5cbiAgdmFyIENPUFlfUEFSVFMgPSBbXCJCWVNFQ09ORFwiLCBcIkJZTUlOVVRFXCIsIFwiQllIT1VSXCIsIFwiQllEQVlcIixcbiAgICAgICAgICAgICAgICAgICAgXCJCWU1PTlRIREFZXCIsIFwiQllZRUFSREFZXCIsIFwiQllXRUVLTk9cIixcbiAgICAgICAgICAgICAgICAgICAgXCJCWU1PTlRIXCIsIFwiQllTRVRQT1NcIl07XG5cbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogVGhpcyBjbGFzcyByZXByZXNlbnRzIHRoZSBcInJlY3VyXCIgdmFsdWUgdHlwZSwgd2l0aCB2YXJpb3VzIGNhbGN1bGF0aW9uXG4gICAqIGFuZCBtYW5pcHVsYXRpb24gbWV0aG9kcy5cbiAgICpcbiAgICogQGNsYXNzXG4gICAqIEBhbGlhcyBJQ0FMLlJlY3VyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFuIG9iamVjdCB3aXRoIG1lbWJlcnMgb2YgdGhlIHJlY3VycmVuY2VcbiAgICogQHBhcmFtIHtJQ0FMLlJlY3VyLmZyZXF1ZW5jeVZhbHVlcz19IGRhdGEuZnJlcSAgICAgVGhlIGZyZXF1ZW5jeSB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcj19IGRhdGEuaW50ZXJ2YWwgICAgICAgICAgICAgICAgICAgICBUaGUgSU5URVJWQUwgdmFsdWVcbiAgICogQHBhcmFtIHtJQ0FMLlRpbWUud2Vla0RheT19IGRhdGEud2tzdCAgICAgICAgICAgICAgVGhlIHdlZWsgc3RhcnQgdmFsdWVcbiAgICogQHBhcmFtIHtJQ0FMLlRpbWU9fSBkYXRhLnVudGlsICAgICAgICAgICAgICAgICAgICAgVGhlIGVuZCBvZiB0aGUgcmVjdXJyZW5jZSBzZXRcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLmNvdW50ICAgICAgICAgICAgICAgICAgICAgICAgVGhlIG51bWJlciBvZiBvY2N1cnJlbmNlc1xuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gZGF0YS5ieXNlY29uZCAgICAgICAgICAgICBUaGUgc2Vjb25kcyBmb3IgdGhlIEJZU0VDT05EIHBhcnRcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGRhdGEuYnltaW51dGUgICAgICAgICAgICAgVGhlIG1pbnV0ZXMgZm9yIHRoZSBCWU1JTlVURSBwYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBkYXRhLmJ5aG91ciAgICAgICAgICAgICAgIFRoZSBob3VycyBmb3IgdGhlIEJZSE9VUiBwYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz49fSBkYXRhLmJ5ZGF5ICAgICAgICAgICAgICAgIFRoZSBCWURBWSB2YWx1ZXNcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGRhdGEuYnltb250aGRheSAgICAgICAgICAgVGhlIGRheXMgZm9yIHRoZSBCWU1PTlRIREFZIHBhcnRcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGRhdGEuYnl5ZWFyZGF5ICAgICAgICAgICAgVGhlIGRheXMgZm9yIHRoZSBCWVlFQVJEQVkgcGFydFxuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gZGF0YS5ieXdlZWtubyAgICAgICAgICAgICBUaGUgd2Vla3MgZm9yIHRoZSBCWVdFRUtOTyBwYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBkYXRhLmJ5bW9udGggICAgICAgICAgICAgIFRoZSBtb250aCBmb3IgdGhlIEJZTU9OVEggcGFydFxuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gZGF0YS5ieXNldHBvcyAgICAgICAgICAgICBUaGUgcG9zaXRpb25hbHMgZm9yIHRoZSBCWVNFVFBPUyBwYXJ0XG4gICAqL1xuICBJQ0FMLlJlY3VyID0gZnVuY3Rpb24gaWNhbHJlY3VyKGRhdGEpIHtcbiAgICB0aGlzLndyYXBwZWRKU09iamVjdCA9IHRoaXM7XG4gICAgdGhpcy5wYXJ0cyA9IHt9O1xuXG4gICAgaWYgKGRhdGEgJiYgdHlwZW9mKGRhdGEpID09PSAnb2JqZWN0Jykge1xuICAgICAgdGhpcy5mcm9tRGF0YShkYXRhKTtcbiAgICB9XG4gIH07XG5cbiAgSUNBTC5SZWN1ci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IGhvbGRpbmcgdGhlIEJZLXBhcnRzIG9mIHRoZSByZWN1cnJlbmNlIHJ1bGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHBhcnRzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGludGVydmFsIHZhbHVlIGZvciB0aGUgcmVjdXJyZW5jZSBydWxlLlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgaW50ZXJ2YWw6IDEsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgd2VlayBzdGFydCBkYXlcbiAgICAgKlxuICAgICAqIEB0eXBlIHtJQ0FMLlRpbWUud2Vla0RheX1cbiAgICAgKiBAZGVmYXVsdCBJQ0FMLlRpbWUuTU9OREFZXG4gICAgICovXG4gICAgd2tzdDogSUNBTC5UaW1lLk1PTkRBWSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlbmQgb2YgdGhlIHJlY3VycmVuY2VcbiAgICAgKiBAdHlwZSB7P0lDQUwuVGltZX1cbiAgICAgKi9cbiAgICB1bnRpbDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBvY2N1cnJlbmNlc1xuICAgICAqIEB0eXBlIHs/TnVtYmVyfVxuICAgICAqL1xuICAgIGNvdW50OiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGZyZXF1ZW5jeSB2YWx1ZS5cbiAgICAgKiBAdHlwZSB7SUNBTC5SZWN1ci5mcmVxdWVuY3lWYWx1ZXN9XG4gICAgICovXG4gICAgZnJlcTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBjbGFzcyBpZGVudGlmaWVyLlxuICAgICAqIEBjb25zdGFudFxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgXCJpY2FscmVjdXJcIlxuICAgICAqL1xuICAgIGljYWxjbGFzczogXCJpY2FscmVjdXJcIixcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG5hbWUsIHRvIGJlIHVzZWQgaW4gdGhlIGpDYWwgb2JqZWN0LlxuICAgICAqIEBjb25zdGFudFxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgXCJyZWN1clwiXG4gICAgICovXG4gICAgaWNhbHR5cGU6IFwicmVjdXJcIixcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBpdGVyYXRvciBmb3IgdGhpcyByZWN1cnJlbmNlIHJ1bGUuIFRoZSBwYXNzZWQgc3RhcnQgZGF0ZVxuICAgICAqIG11c3QgYmUgdGhlIHN0YXJ0IGRhdGUgb2YgdGhlIGV2ZW50LCBub3QgdGhlIHN0YXJ0IG9mIHRoZSByYW5nZSB0b1xuICAgICAqIHNlYXJjaCBpbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIHJlY3VyID0gY29tcC5nZXRGaXJzdFByb3BlcnR5VmFsdWUoJ3JydWxlJyk7XG4gICAgICogdmFyIGR0c3RhcnQgPSBjb21wLmdldEZpcnN0UHJvcGVydHlWYWx1ZSgnZHRzdGFydCcpO1xuICAgICAqIHZhciBpdGVyID0gcmVjdXIuaXRlcmF0b3IoZHRzdGFydCk7XG4gICAgICogZm9yICh2YXIgbmV4dCA9IGl0ZXIubmV4dCgpOyBuZXh0OyBuZXh0ID0gaXRlci5uZXh0KCkpIHtcbiAgICAgKiAgIGlmIChuZXh0LmNvbXBhcmUocmFuZ2VTdGFydCkgPCAwKSB7XG4gICAgICogICAgIGNvbnRpbnVlO1xuICAgICAqICAgfVxuICAgICAqICAgY29uc29sZS5sb2cobmV4dC50b1N0cmluZygpKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZX0gYVN0YXJ0ICAgICAgICBUaGUgaXRlbSdzIHN0YXJ0IGRhdGVcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlJlY3VySXRlcmF0b3J9ICAgICBUaGUgcmVjdXJyZW5jZSBpdGVyYXRvclxuICAgICAqL1xuICAgIGl0ZXJhdG9yOiBmdW5jdGlvbihhU3RhcnQpIHtcbiAgICAgIHJldHVybiBuZXcgSUNBTC5SZWN1ckl0ZXJhdG9yKHtcbiAgICAgICAgcnVsZTogdGhpcyxcbiAgICAgICAgZHRzdGFydDogYVN0YXJ0XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSByZWN1cnJlbmNlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0lDQUwuUmVjdXJ9ICAgICAgVGhlIGNsb25lZCBvYmplY3RcbiAgICAgKi9cbiAgICBjbG9uZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICByZXR1cm4gbmV3IElDQUwuUmVjdXIodGhpcy50b0pTT04oKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgY3VycmVudCBydWxlIGlzIGZpbml0ZSwgaS5lLiBoYXMgYSBjb3VudCBvciB1bnRpbCBwYXJ0LlxuICAgICAqXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgIFRydWUsIGlmIHRoZSBydWxlIGlzIGZpbml0ZVxuICAgICAqL1xuICAgIGlzRmluaXRlOiBmdW5jdGlvbiBpc2Zpbml0ZSgpIHtcbiAgICAgIHJldHVybiAhISh0aGlzLmNvdW50IHx8IHRoaXMudW50aWwpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGN1cnJlbnQgcnVsZSBoYXMgYSBjb3VudCBwYXJ0LCBhbmQgbm90IGxpbWl0ZWQgYnkgYW4gdW50aWxcbiAgICAgKiBwYXJ0LlxuICAgICAqXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgIFRydWUsIGlmIHRoZSBydWxlIGlzIGJ5IGNvdW50XG4gICAgICovXG4gICAgaXNCeUNvdW50OiBmdW5jdGlvbiBpc2J5Y291bnQoKSB7XG4gICAgICByZXR1cm4gISEodGhpcy5jb3VudCAmJiAhdGhpcy51bnRpbCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBjb21wb25lbnQgKHBhcnQpIHRvIHRoZSByZWN1cnJlbmNlIHJ1bGUuIFRoaXMgaXMgbm90IGEgY29tcG9uZW50XG4gICAgICogaW4gdGhlIHNlbnNlIG9mIHtAbGluayBJQ0FMLkNvbXBvbmVudH0sIGJ1dCBhIHBhcnQgb2YgdGhlIHJlY3VycmVuY2VcbiAgICAgKiBydWxlLCBpLmUuIEJZTU9OVEguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYVR5cGUgICAgICAgICAgICBUaGUgbmFtZSBvZiB0aGUgY29tcG9uZW50IHBhcnRcbiAgICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gYVZhbHVlICAgICBUaGUgY29tcG9uZW50IHZhbHVlXG4gICAgICovXG4gICAgYWRkQ29tcG9uZW50OiBmdW5jdGlvbiBhZGRQYXJ0KGFUeXBlLCBhVmFsdWUpIHtcbiAgICAgIHZhciB1Y25hbWUgPSBhVHlwZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgaWYgKHVjbmFtZSBpbiB0aGlzLnBhcnRzKSB7XG4gICAgICAgIHRoaXMucGFydHNbdWNuYW1lXS5wdXNoKGFWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhcnRzW3VjbmFtZV0gPSBbYVZhbHVlXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY29tcG9uZW50IHZhbHVlIGZvciB0aGUgZ2l2ZW4gYnktcGFydC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhVHlwZSAgICAgICAgVGhlIGNvbXBvbmVudCBwYXJ0IG5hbWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhVmFsdWVzICAgICAgIFRoZSBjb21wb25lbnQgdmFsdWVzXG4gICAgICovXG4gICAgc2V0Q29tcG9uZW50OiBmdW5jdGlvbiBzZXRDb21wb25lbnQoYVR5cGUsIGFWYWx1ZXMpIHtcbiAgICAgIHRoaXMucGFydHNbYVR5cGUudG9VcHBlckNhc2UoKV0gPSBhVmFsdWVzLnNsaWNlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgKGEgY29weSkgb2YgdGhlIHJlcXVlc3RlZCBjb21wb25lbnQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYVR5cGUgICAgICAgIFRoZSBjb21wb25lbnQgcGFydCBuYW1lXG4gICAgICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgICAgICBUaGUgY29tcG9uZW50IHBhcnQgdmFsdWVcbiAgICAgKi9cbiAgICBnZXRDb21wb25lbnQ6IGZ1bmN0aW9uIGdldENvbXBvbmVudChhVHlwZSkge1xuICAgICAgdmFyIHVjbmFtZSA9IGFUeXBlLnRvVXBwZXJDYXNlKCk7XG4gICAgICByZXR1cm4gKHVjbmFtZSBpbiB0aGlzLnBhcnRzID8gdGhpcy5wYXJ0c1t1Y25hbWVdLnNsaWNlKCkgOiBbXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgbmV4dCBvY2N1cnJlbmNlIGFmdGVyIHRoZSBnaXZlbiByZWN1cnJlbmNlIGlkLiBTZWUgdGhlXG4gICAgICogZ3VpZGUgb24ge0B0dXRvcmlhbCB0ZXJtaW5vbG9neX0gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIE5PVEU6IEN1cnJlbnRseSwgdGhpcyBtZXRob2QgaXRlcmF0ZXMgYWxsIG9jY3VycmVuY2VzIGZyb20gdGhlIHN0YXJ0XG4gICAgICogZGF0ZS4gSXQgc2hvdWxkIG5vdCBiZSBjYWxsZWQgaW4gYSBsb29wIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiBJZiB5b3VcbiAgICAgKiB3b3VsZCBsaWtlIHRvIGdldCBtb3JlIHRoYW4gb25lIG9jY3VycmVuY2UsIHlvdSBjYW4gaXRlcmF0ZSB0aGVcbiAgICAgKiBvY2N1cnJlbmNlcyBtYW51YWxseSwgc2VlIHRoZSBleGFtcGxlIG9uIHRoZVxuICAgICAqIHtAbGluayBJQ0FMLlJlY3VyI2l0ZXJhdG9yIGl0ZXJhdG9yfSBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZX0gYVN0YXJ0VGltZSAgICAgICAgVGhlIHN0YXJ0IG9mIHRoZSBldmVudCBzZXJpZXNcbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZX0gYVJlY3VycmVuY2VJZCAgICAgVGhlIGRhdGUgb2YgdGhlIGxhc3Qgb2NjdXJyZW5jZVxuICAgICAqIEByZXR1cm4ge0lDQUwuVGltZX0gICAgICAgICAgICAgICAgICBUaGUgbmV4dCBvY2N1cnJlbmNlIGFmdGVyXG4gICAgICovXG4gICAgZ2V0TmV4dE9jY3VycmVuY2U6IGZ1bmN0aW9uIGdldE5leHRPY2N1cnJlbmNlKGFTdGFydFRpbWUsIGFSZWN1cnJlbmNlSWQpIHtcbiAgICAgIHZhciBpdGVyID0gdGhpcy5pdGVyYXRvcihhU3RhcnRUaW1lKTtcbiAgICAgIHZhciBuZXh0LCBjZHQ7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgbmV4dCA9IGl0ZXIubmV4dCgpO1xuICAgICAgfSB3aGlsZSAobmV4dCAmJiBuZXh0LmNvbXBhcmUoYVJlY3VycmVuY2VJZCkgPD0gMCk7XG5cbiAgICAgIGlmIChuZXh0ICYmIGFSZWN1cnJlbmNlSWQuem9uZSkge1xuICAgICAgICBuZXh0LnpvbmUgPSBhUmVjdXJyZW5jZUlkLnpvbmU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIHRoZSBjdXJyZW50IGluc3RhbmNlIHVzaW5nIG1lbWJlcnMgZnJvbSB0aGUgcGFzc2VkIGRhdGEgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQW4gb2JqZWN0IHdpdGggbWVtYmVycyBvZiB0aGUgcmVjdXJyZW5jZVxuICAgICAqIEBwYXJhbSB7SUNBTC5SZWN1ci5mcmVxdWVuY3lWYWx1ZXM9fSBkYXRhLmZyZXEgICAgIFRoZSBmcmVxdWVuY3kgdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcj19IGRhdGEuaW50ZXJ2YWwgICAgICAgICAgICAgICAgICAgICBUaGUgSU5URVJWQUwgdmFsdWVcbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZS53ZWVrRGF5PX0gZGF0YS53a3N0ICAgICAgICAgICAgICBUaGUgd2VlayBzdGFydCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7SUNBTC5UaW1lPX0gZGF0YS51bnRpbCAgICAgICAgICAgICAgICAgICAgIFRoZSBlbmQgb2YgdGhlIHJlY3VycmVuY2Ugc2V0XG4gICAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLmNvdW50ICAgICAgICAgICAgICAgICAgICAgICAgVGhlIG51bWJlciBvZiBvY2N1cnJlbmNlc1xuICAgICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBkYXRhLmJ5c2Vjb25kICAgICAgICAgICAgIFRoZSBzZWNvbmRzIGZvciB0aGUgQllTRUNPTkQgcGFydFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBkYXRhLmJ5bWludXRlICAgICAgICAgICAgIFRoZSBtaW51dGVzIGZvciB0aGUgQllNSU5VVEUgcGFydFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBkYXRhLmJ5aG91ciAgICAgICAgICAgICAgIFRoZSBob3VycyBmb3IgdGhlIEJZSE9VUiBwYXJ0XG4gICAgICogQHBhcmFtIHtBcnJheS48U3RyaW5nPj19IGRhdGEuYnlkYXkgICAgICAgICAgICAgICAgVGhlIEJZREFZIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBkYXRhLmJ5bW9udGhkYXkgICAgICAgICAgIFRoZSBkYXlzIGZvciB0aGUgQllNT05USERBWSBwYXJ0XG4gICAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGRhdGEuYnl5ZWFyZGF5ICAgICAgICAgICAgVGhlIGRheXMgZm9yIHRoZSBCWVlFQVJEQVkgcGFydFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBkYXRhLmJ5d2Vla25vICAgICAgICAgICAgIFRoZSB3ZWVrcyBmb3IgdGhlIEJZV0VFS05PIHBhcnRcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gZGF0YS5ieW1vbnRoICAgICAgICAgICAgICBUaGUgbW9udGggZm9yIHRoZSBCWU1PTlRIIHBhcnRcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gZGF0YS5ieXNldHBvcyAgICAgICAgICAgICBUaGUgcG9zaXRpb25hbHMgZm9yIHRoZSBCWVNFVFBPUyBwYXJ0XG4gICAgICovXG4gICAgZnJvbURhdGE6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgIHZhciB1Y2tleSA9IGtleS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgIGlmICh1Y2tleSBpbiBwYXJ0RGVzaWduKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YVtrZXldKSkge1xuICAgICAgICAgICAgdGhpcy5wYXJ0c1t1Y2tleV0gPSBkYXRhW2tleV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGFydHNbdWNrZXldID0gW2RhdGFba2V5XV07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXNba2V5XSA9IGRhdGFba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pbnRlcnZhbCAmJiB0eXBlb2YgdGhpcy5pbnRlcnZhbCAhPSBcIm51bWJlclwiKSB7XG4gICAgICAgIG9wdGlvbkRlc2lnbi5JTlRFUlZBTCh0aGlzLmludGVydmFsLCB0aGlzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMud2tzdCAmJiB0eXBlb2YgdGhpcy53a3N0ICE9IFwibnVtYmVyXCIpIHtcbiAgICAgICAgdGhpcy53a3N0ID0gSUNBTC5SZWN1ci5pY2FsRGF5VG9OdW1lcmljRGF5KHRoaXMud2tzdCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnVudGlsICYmICEodGhpcy51bnRpbCBpbnN0YW5jZW9mIElDQUwuVGltZSkpIHtcbiAgICAgICAgdGhpcy51bnRpbCA9IElDQUwuVGltZS5mcm9tU3RyaW5nKHRoaXMudW50aWwpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgakNhbCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHJlY3VycmVuY2UgdHlwZS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgcmVzLmZyZXEgPSB0aGlzLmZyZXE7XG5cbiAgICAgIGlmICh0aGlzLmNvdW50KSB7XG4gICAgICAgIHJlcy5jb3VudCA9IHRoaXMuY291bnQ7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmludGVydmFsID4gMSkge1xuICAgICAgICByZXMuaW50ZXJ2YWwgPSB0aGlzLmludGVydmFsO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBrIGluIHRoaXMucGFydHMpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghdGhpcy5wYXJ0cy5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrcGFydHMgPSB0aGlzLnBhcnRzW2tdO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShrcGFydHMpICYmIGtwYXJ0cy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgIHJlc1trLnRvTG93ZXJDYXNlKCldID0ga3BhcnRzWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc1trLnRvTG93ZXJDYXNlKCldID0gSUNBTC5oZWxwZXJzLmNsb25lKHRoaXMucGFydHNba10pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnVudGlsKSB7XG4gICAgICAgIHJlcy51bnRpbCA9IHRoaXMudW50aWwudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGlmICgnd2tzdCcgaW4gdGhpcyAmJiB0aGlzLndrc3QgIT09IElDQUwuVGltZS5ERUZBVUxUX1dFRUtfU1RBUlQpIHtcbiAgICAgICAgcmVzLndrc3QgPSBJQ0FMLlJlY3VyLm51bWVyaWNEYXlUb0ljYWxEYXkodGhpcy53a3N0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyByZWN1cnJlbmNlIHJ1bGUuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiBpY2FscmVjdXJfdG9TdHJpbmcoKSB7XG4gICAgICAvLyBUT0RPIHJldGFpbiBvcmRlclxuICAgICAgdmFyIHN0ciA9IFwiRlJFUT1cIiArIHRoaXMuZnJlcTtcbiAgICAgIGlmICh0aGlzLmNvdW50KSB7XG4gICAgICAgIHN0ciArPSBcIjtDT1VOVD1cIiArIHRoaXMuY291bnQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pbnRlcnZhbCA+IDEpIHtcbiAgICAgICAgc3RyICs9IFwiO0lOVEVSVkFMPVwiICsgdGhpcy5pbnRlcnZhbDtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGsgaW4gdGhpcy5wYXJ0cykge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAodGhpcy5wYXJ0cy5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgIHN0ciArPSBcIjtcIiArIGsgKyBcIj1cIiArIHRoaXMucGFydHNba107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnVudGlsKSB7XG4gICAgICAgIHN0ciArPSAnO1VOVElMPScgKyB0aGlzLnVudGlsLnRvSUNBTFN0cmluZygpO1xuICAgICAgfVxuICAgICAgaWYgKCd3a3N0JyBpbiB0aGlzICYmIHRoaXMud2tzdCAhPT0gSUNBTC5UaW1lLkRFRkFVTFRfV0VFS19TVEFSVCkge1xuICAgICAgICBzdHIgKz0gJztXS1NUPScgKyBJQ0FMLlJlY3VyLm51bWVyaWNEYXlUb0ljYWxEYXkodGhpcy53a3N0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIHBhcnNlTnVtZXJpY1ZhbHVlKHR5cGUsIG1pbiwgbWF4LCB2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSB2YWx1ZTtcblxuICAgIGlmICh2YWx1ZVswXSA9PT0gJysnKSB7XG4gICAgICByZXN1bHQgPSB2YWx1ZS5zdWJzdHIoMSk7XG4gICAgfVxuXG4gICAgcmVzdWx0ID0gSUNBTC5oZWxwZXJzLnN0cmljdFBhcnNlSW50KHJlc3VsdCk7XG5cbiAgICBpZiAobWluICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgPCBtaW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgdHlwZSArICc6IGludmFsaWQgdmFsdWUgXCInICsgdmFsdWUgKyAnXCIgbXVzdCBiZSA+ICcgKyBtaW5cbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKG1heCAhPT0gdW5kZWZpbmVkICYmIHZhbHVlID4gbWF4KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIHR5cGUgKyAnOiBpbnZhbGlkIHZhbHVlIFwiJyArIHZhbHVlICsgJ1wiIG11c3QgYmUgPCAnICsgbWluXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBhbiBpY2FsIHJlcHJlc2VudGF0aW9uIG9mIGEgZGF5IChTVSwgTU8sIGV0Yy4uKVxuICAgKiBpbnRvIGEgbnVtZXJpYyB2YWx1ZSBvZiB0aGF0IGRheS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyAgICAgVGhlIGlDYWxlbmRhciBkYXkgbmFtZVxuICAgKiBAcGFyYW0ge0lDQUwuVGltZS53ZWVrRGF5PX0gYVdlZWtTdGFydFxuICAgKiAgICAgICAgVGhlIHdlZWsgc3RhcnQgd2Vla2RheSwgZGVmYXVsdHMgdG8gU1VOREFZXG4gICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgIE51bWVyaWMgdmFsdWUgb2YgZ2l2ZW4gZGF5XG4gICAqL1xuICBJQ0FMLlJlY3VyLmljYWxEYXlUb051bWVyaWNEYXkgPSBmdW5jdGlvbiB0b051bWVyaWNEYXkoc3RyaW5nLCBhV2Vla1N0YXJ0KSB7XG4gICAgLy9YWFg6IHRoaXMgaXMgaGVyZSBzbyB3ZSBjYW4gZGVhbFxuICAgIC8vICAgICB3aXRoIHBvc3NpYmx5IGludmFsaWQgc3RyaW5nIHZhbHVlcy5cbiAgICB2YXIgZmlyc3REb3cgPSBhV2Vla1N0YXJ0IHx8IElDQUwuVGltZS5TVU5EQVk7XG4gICAgcmV0dXJuICgoRE9XX01BUFtzdHJpbmddIC0gZmlyc3REb3cgKyA3KSAlIDcpICsgMTtcbiAgfTtcblxuICAvKipcbiAgICogQ29udmVydCBhIG51bWVyaWMgZGF5IHZhbHVlIGludG8gaXRzIGljYWwgcmVwcmVzZW50YXRpb24gKFNVLCBNTywgZXRjLi4pXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBudW0gICAgICAgIE51bWVyaWMgdmFsdWUgb2YgZ2l2ZW4gZGF5XG4gICAqIEBwYXJhbSB7SUNBTC5UaW1lLndlZWtEYXk9fSBhV2Vla1N0YXJ0XG4gICAqICAgICAgICBUaGUgd2VlayBzdGFydCB3ZWVrZGF5LCBkZWZhdWx0cyB0byBTVU5EQVlcbiAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICAgVGhlIElDQUwgZGF5IHZhbHVlLCBlLmcgU1UsTU8sLi4uXG4gICAqL1xuICBJQ0FMLlJlY3VyLm51bWVyaWNEYXlUb0ljYWxEYXkgPSBmdW5jdGlvbiB0b0ljYWxEYXkobnVtLCBhV2Vla1N0YXJ0KSB7XG4gICAgLy9YWFg6IHRoaXMgaXMgaGVyZSBzbyB3ZSBjYW4gZGVhbCB3aXRoIHBvc3NpYmx5IGludmFsaWQgbnVtYmVyIHZhbHVlcy5cbiAgICAvLyAgICAgQWxzbywgdGhpcyBhbGxvd3MgY29uc2lzdGVudCBtYXBwaW5nIGJldHdlZW4gZGF5IG51bWJlcnMgYW5kIGRheVxuICAgIC8vICAgICBuYW1lcyBmb3IgZXh0ZXJuYWwgdXNlcnMuXG4gICAgdmFyIGZpcnN0RG93ID0gYVdlZWtTdGFydCB8fCBJQ0FMLlRpbWUuU1VOREFZO1xuICAgIHZhciBkb3cgPSAobnVtICsgZmlyc3REb3cgLSBJQ0FMLlRpbWUuU1VOREFZKTtcbiAgICBpZiAoZG93ID4gNykge1xuICAgICAgZG93IC09IDc7XG4gICAgfVxuICAgIHJldHVybiBSRVZFUlNFX0RPV19NQVBbZG93XTtcbiAgfTtcblxuICB2YXIgVkFMSURfREFZX05BTUVTID0gL14oU1V8TU98VFV8V0V8VEh8RlJ8U0EpJC87XG4gIHZhciBWQUxJRF9CWURBWV9QQVJUID0gL14oWystXSk/KDVbMC0zXXxbMS00XVswLTldfFsxLTldKT8oU1V8TU98VFV8V0V8VEh8RlJ8U0EpJC87XG5cbiAgLyoqXG4gICAqIFBvc3NpYmxlIGZyZXF1ZW5jeSB2YWx1ZXMgZm9yIHRoZSBGUkVRIHBhcnRcbiAgICogKFlFQVJMWSwgTU9OVEhMWSwgV0VFS0xZLCBEQUlMWSwgSE9VUkxZLCBNSU5VVEVMWSwgU0VDT05ETFkpXG4gICAqXG4gICAqIEB0eXBlZGVmIHtTdHJpbmd9IGZyZXF1ZW5jeVZhbHVlc1xuICAgKiBAbWVtYmVyb2YgSUNBTC5SZWN1clxuICAgKi9cblxuICB2YXIgQUxMT1dFRF9GUkVRID0gWydTRUNPTkRMWScsICdNSU5VVEVMWScsICdIT1VSTFknLFxuICAgICAgICAgICAgICAgICAgICAgICdEQUlMWScsICdXRUVLTFknLCAnTU9OVEhMWScsICdZRUFSTFknXTtcblxuICB2YXIgb3B0aW9uRGVzaWduID0ge1xuICAgIEZSRVE6IGZ1bmN0aW9uKHZhbHVlLCBkaWN0LCBmbXRJY2FsKSB7XG4gICAgICAvLyB5ZXMgdGhpcyBpcyBhY3R1YWxseSBlcXVhbCBvciBmYXN0ZXIgdGhlbiByZWdleC5cbiAgICAgIC8vIHVwc2lkZSBoZXJlIGlzIHdlIGNhbiBlbnVtZXJhdGUgdGhlIHZhbGlkIHZhbHVlcy5cbiAgICAgIGlmIChBTExPV0VEX0ZSRVEuaW5kZXhPZih2YWx1ZSkgIT09IC0xKSB7XG4gICAgICAgIGRpY3QuZnJlcSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdpbnZhbGlkIGZyZXF1ZW5jeSBcIicgKyB2YWx1ZSArICdcIiBleHBlY3RlZDogXCInICtcbiAgICAgICAgICBBTExPV0VEX0ZSRVEuam9pbignLCAnKSArICdcIidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgQ09VTlQ6IGZ1bmN0aW9uKHZhbHVlLCBkaWN0LCBmbXRJY2FsKSB7XG4gICAgICBkaWN0LmNvdW50ID0gSUNBTC5oZWxwZXJzLnN0cmljdFBhcnNlSW50KHZhbHVlKTtcbiAgICB9LFxuXG4gICAgSU5URVJWQUw6IGZ1bmN0aW9uKHZhbHVlLCBkaWN0LCBmbXRJY2FsKSB7XG4gICAgICBkaWN0LmludGVydmFsID0gSUNBTC5oZWxwZXJzLnN0cmljdFBhcnNlSW50KHZhbHVlKTtcbiAgICAgIGlmIChkaWN0LmludGVydmFsIDwgMSkge1xuICAgICAgICAvLyAwIG9yIG5lZ2F0aXZlIHZhbHVlcyBhcmUgbm90IGFsbG93ZWQsIHNvbWUgZW5naW5lcyBzZWVtIHRvIGdlbmVyYXRlXG4gICAgICAgIC8vIGl0IHRob3VnaC4gQXNzdW1lIDEgaW5zdGVhZC5cbiAgICAgICAgZGljdC5pbnRlcnZhbCA9IDE7XG4gICAgICB9XG4gICAgfSxcblxuICAgIFVOVElMOiBmdW5jdGlvbih2YWx1ZSwgZGljdCwgZm10SWNhbCkge1xuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDEwKSB7XG4gICAgICAgIGRpY3QudW50aWwgPSBJQ0FMLmRlc2lnbi5pY2FsZW5kYXIudmFsdWVbJ2RhdGUtdGltZSddLmZyb21JQ0FMKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpY3QudW50aWwgPSBJQ0FMLmRlc2lnbi5pY2FsZW5kYXIudmFsdWUuZGF0ZS5mcm9tSUNBTCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoIWZtdEljYWwpIHtcbiAgICAgICAgZGljdC51bnRpbCA9IElDQUwuVGltZS5mcm9tU3RyaW5nKGRpY3QudW50aWwpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBXS1NUOiBmdW5jdGlvbih2YWx1ZSwgZGljdCwgZm10SWNhbCkge1xuICAgICAgaWYgKFZBTElEX0RBWV9OQU1FUy50ZXN0KHZhbHVlKSkge1xuICAgICAgICBkaWN0Lndrc3QgPSBJQ0FMLlJlY3VyLmljYWxEYXlUb051bWVyaWNEYXkodmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFdLU1QgdmFsdWUgXCInICsgdmFsdWUgKyAnXCInKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIHBhcnREZXNpZ24gPSB7XG4gICAgQllTRUNPTkQ6IHBhcnNlTnVtZXJpY1ZhbHVlLmJpbmQodGhpcywgJ0JZU0VDT05EJywgMCwgNjApLFxuICAgIEJZTUlOVVRFOiBwYXJzZU51bWVyaWNWYWx1ZS5iaW5kKHRoaXMsICdCWU1JTlVURScsIDAsIDU5KSxcbiAgICBCWUhPVVI6IHBhcnNlTnVtZXJpY1ZhbHVlLmJpbmQodGhpcywgJ0JZSE9VUicsIDAsIDIzKSxcbiAgICBCWURBWTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmIChWQUxJRF9CWURBWV9QQVJULnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBCWURBWSB2YWx1ZSBcIicgKyB2YWx1ZSArICdcIicpO1xuICAgICAgfVxuICAgIH0sXG4gICAgQllNT05USERBWTogcGFyc2VOdW1lcmljVmFsdWUuYmluZCh0aGlzLCAnQllNT05USERBWScsIC0zMSwgMzEpLFxuICAgIEJZWUVBUkRBWTogcGFyc2VOdW1lcmljVmFsdWUuYmluZCh0aGlzLCAnQllZRUFSREFZJywgLTM2NiwgMzY2KSxcbiAgICBCWVdFRUtOTzogcGFyc2VOdW1lcmljVmFsdWUuYmluZCh0aGlzLCAnQllXRUVLTk8nLCAtNTMsIDUzKSxcbiAgICBCWU1PTlRIOiBwYXJzZU51bWVyaWNWYWx1ZS5iaW5kKHRoaXMsICdCWU1PTlRIJywgMSwgMTIpLFxuICAgIEJZU0VUUE9TOiBwYXJzZU51bWVyaWNWYWx1ZS5iaW5kKHRoaXMsICdCWVNFVFBPUycsIC0zNjYsIDM2NilcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBJQ0FMLlJlY3VyfSBpbnN0YW5jZSBmcm9tIHRoZSBwYXNzZWQgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nICAgICAgICAgVGhlIHN0cmluZyB0byBwYXJzZVxuICAgKiBAcmV0dXJuIHtJQ0FMLlJlY3VyfSAgICAgICAgICAgVGhlIGNyZWF0ZWQgcmVjdXJyZW5jZSBpbnN0YW5jZVxuICAgKi9cbiAgSUNBTC5SZWN1ci5mcm9tU3RyaW5nID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIGRhdGEgPSBJQ0FMLlJlY3VyLl9zdHJpbmdUb0RhdGEoc3RyaW5nLCBmYWxzZSk7XG4gICAgcmV0dXJuIG5ldyBJQ0FMLlJlY3VyKGRhdGEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBJQ0FMLlJlY3VyfSBpbnN0YW5jZSB1c2luZyBtZW1iZXJzIGZyb20gdGhlIHBhc3NlZFxuICAgKiBkYXRhIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFEYXRhICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQW4gb2JqZWN0IHdpdGggbWVtYmVycyBvZiB0aGUgcmVjdXJyZW5jZVxuICAgKiBAcGFyYW0ge0lDQUwuUmVjdXIuZnJlcXVlbmN5VmFsdWVzPX0gYURhdGEuZnJlcSAgICBUaGUgZnJlcXVlbmN5IHZhbHVlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEuaW50ZXJ2YWwgICAgICAgICAgICAgICAgICAgIFRoZSBJTlRFUlZBTCB2YWx1ZVxuICAgKiBAcGFyYW0ge0lDQUwuVGltZS53ZWVrRGF5PX0gYURhdGEud2tzdCAgICAgICAgICAgICBUaGUgd2VlayBzdGFydCB2YWx1ZVxuICAgKiBAcGFyYW0ge0lDQUwuVGltZT19IGFEYXRhLnVudGlsICAgICAgICAgICAgICAgICAgICBUaGUgZW5kIG9mIHRoZSByZWN1cnJlbmNlIHNldFxuICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLmNvdW50ICAgICAgICAgICAgICAgICAgICAgICBUaGUgbnVtYmVyIG9mIG9jY3VycmVuY2VzXG4gICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBhRGF0YS5ieXNlY29uZCAgICAgICAgICAgIFRoZSBzZWNvbmRzIGZvciB0aGUgQllTRUNPTkQgcGFydFxuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gYURhdGEuYnltaW51dGUgICAgICAgICAgICBUaGUgbWludXRlcyBmb3IgdGhlIEJZTUlOVVRFIHBhcnRcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGFEYXRhLmJ5aG91ciAgICAgICAgICAgICAgVGhlIGhvdXJzIGZvciB0aGUgQllIT1VSIHBhcnRcbiAgICogQHBhcmFtIHtBcnJheS48U3RyaW5nPj19IGFEYXRhLmJ5ZGF5ICAgICAgICAgICAgICAgVGhlIEJZREFZIHZhbHVlc1xuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gYURhdGEuYnltb250aGRheSAgICAgICAgICBUaGUgZGF5cyBmb3IgdGhlIEJZTU9OVEhEQVkgcGFydFxuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gYURhdGEuYnl5ZWFyZGF5ICAgICAgICAgICBUaGUgZGF5cyBmb3IgdGhlIEJZWUVBUkRBWSBwYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBhRGF0YS5ieXdlZWtubyAgICAgICAgICAgIFRoZSB3ZWVrcyBmb3IgdGhlIEJZV0VFS05PIHBhcnRcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGFEYXRhLmJ5bW9udGggICAgICAgICAgICAgVGhlIG1vbnRoIGZvciB0aGUgQllNT05USCBwYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBhRGF0YS5ieXNldHBvcyAgICAgICAgICAgIFRoZSBwb3NpdGlvbmFscyBmb3IgdGhlIEJZU0VUUE9TIHBhcnRcbiAgICovXG4gIElDQUwuUmVjdXIuZnJvbURhdGEgPSBmdW5jdGlvbihhRGF0YSkge1xuICAgIHJldHVybiBuZXcgSUNBTC5SZWN1cihhRGF0YSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgcmVjdXJyZW5jZSBzdHJpbmcgdG8gYSBkYXRhIG9iamVjdCwgc3VpdGFibGUgZm9yIHRoZSBmcm9tRGF0YVxuICAgKiBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgICAgIFRoZSBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtCb29sZWFufSBmbXRJY2FsICAgSWYgdHJ1ZSwgdGhlIHN0cmluZyBpcyBjb25zaWRlcmVkIHRvIGJlIGFuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaUNhbGVuZGFyIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtJQ0FMLlJlY3VyfSAgICAgICBUaGUgcmVjdXJyZW5jZSBpbnN0YW5jZVxuICAgKi9cbiAgSUNBTC5SZWN1ci5fc3RyaW5nVG9EYXRhID0gZnVuY3Rpb24oc3RyaW5nLCBmbXRJY2FsKSB7XG4gICAgdmFyIGRpY3QgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgLy8gc3BsaXQgaXMgc2xvd2VyIGluIEZGIGJ1dCBmYXN0IGVub3VnaC5cbiAgICAvLyB2OCBob3dldmVyIHRoaXMgaXMgZmFzdGVyIHRoZW4gbWFudWFsIHNwbGl0P1xuICAgIHZhciB2YWx1ZXMgPSBzdHJpbmcuc3BsaXQoJzsnKTtcbiAgICB2YXIgbGVuID0gdmFsdWVzLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBwYXJ0cyA9IHZhbHVlc1tpXS5zcGxpdCgnPScpO1xuICAgICAgdmFyIHVjbmFtZSA9IHBhcnRzWzBdLnRvVXBwZXJDYXNlKCk7XG4gICAgICB2YXIgbGNuYW1lID0gcGFydHNbMF0udG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBuYW1lID0gKGZtdEljYWwgPyBsY25hbWUgOiB1Y25hbWUpO1xuICAgICAgdmFyIHZhbHVlID0gcGFydHNbMV07XG5cbiAgICAgIGlmICh1Y25hbWUgaW4gcGFydERlc2lnbikge1xuICAgICAgICB2YXIgcGFydEFyciA9IHZhbHVlLnNwbGl0KCcsJyk7XG4gICAgICAgIHZhciBwYXJ0QXJySWR4ID0gMDtcbiAgICAgICAgdmFyIHBhcnRBcnJMZW4gPSBwYXJ0QXJyLmxlbmd0aDtcblxuICAgICAgICBmb3IgKDsgcGFydEFycklkeCA8IHBhcnRBcnJMZW47IHBhcnRBcnJJZHgrKykge1xuICAgICAgICAgIHBhcnRBcnJbcGFydEFycklkeF0gPSBwYXJ0RGVzaWduW3VjbmFtZV0ocGFydEFycltwYXJ0QXJySWR4XSk7XG4gICAgICAgIH1cbiAgICAgICAgZGljdFtuYW1lXSA9IChwYXJ0QXJyLmxlbmd0aCA9PSAxID8gcGFydEFyclswXSA6IHBhcnRBcnIpO1xuICAgICAgfSBlbHNlIGlmICh1Y25hbWUgaW4gb3B0aW9uRGVzaWduKSB7XG4gICAgICAgIG9wdGlvbkRlc2lnblt1Y25hbWVdKHZhbHVlLCBkaWN0LCBmbXRJY2FsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIERvbid0IHN3YWxsb3cgdW5rbm93biB2YWx1ZXMuIEp1c3Qgc2V0IHRoZW0gYXMgdGhleSBhcmUuXG4gICAgICAgIGRpY3RbbGNuYW1lXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkaWN0O1xuICB9O1xufSkoKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAxMS0yMDE1ICovXG5cblxuLyoqXG4gKiBUaGlzIHN5bWJvbCBpcyBmdXJ0aGVyIGRlc2NyaWJlZCBsYXRlciBvblxuICogQGlnbm9yZVxuICovXG5JQ0FMLlJlY3VySXRlcmF0b3IgPSAoZnVuY3Rpb24oKSB7XG5cbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogQW4gaXRlcmF0b3IgZm9yIGEgc2luZ2xlIHJlY3VycmVuY2UgcnVsZS4gVGhpcyBjbGFzcyB1c3VhbGx5IGRvZXNuJ3QgaGF2ZVxuICAgKiB0byBiZSBpbnN0YW5jaWF0ZWQgZGlyZWN0bHksIHRoZSBjb252ZW5pZW5jZSBtZXRob2RcbiAgICoge0BsaW5rIElDQUwuUmVjdXIjaXRlcmF0b3J9IGNhbiBiZSB1c2VkLlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogVGhlIG9wdGlvbnMgb2JqZWN0IG1heSBjb250YWluIGFkZGl0aW9uYWwgbWVtYmVycyB3aGVuIHJlc3VtaW5nIGl0ZXJhdGlvbiBmcm9tIGEgcHJldmlvdXMgcnVuXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBUaGUgb3B0aW9ucyBvYmplY3QgbWF5IGNvbnRhaW4gYWRkaXRpb25hbCBtZW1iZXJzIHdoZW4gcmVzdW1pbmcgaXRlcmF0aW9uXG4gICAqIGZyb20gYSBwcmV2aW91cyBydW4uXG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAYWxpYXMgSUNBTC5SZWN1ckl0ZXJhdG9yXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zICAgICAgICAgICAgICAgIFRoZSBpdGVyYXRvciBvcHRpb25zXG4gICAqIEBwYXJhbSB7SUNBTC5SZWN1cn0gb3B0aW9ucy5ydWxlICAgICAgIFRoZSBydWxlIHRvIGl0ZXJhdGUuXG4gICAqIEBwYXJhbSB7SUNBTC5UaW1lfSBvcHRpb25zLmR0c3RhcnQgICAgIFRoZSBzdGFydCBkYXRlIG9mIHRoZSBldmVudC5cbiAgICogQHBhcmFtIHtCb29sZWFuPX0gb3B0aW9ucy5pbml0aWFsaXplZCAgV2hlbiB0cnVlLCBhc3N1bWUgdGhhdCBvcHRpb25zIGFyZVxuICAgKiAgICAgICAgZnJvbSBhIHByZXZpb3VzbHkgY29uc3RydWN0ZWQgaXRlcmF0b3IuIEluaXRpYWxpemF0aW9uIHdpbGwgbm90IGJlXG4gICAqICAgICAgICByZXBlYXRlZC5cbiAgICovXG4gIGZ1bmN0aW9uIGljYWxyZWN1cl9pdGVyYXRvcihvcHRpb25zKSB7XG4gICAgdGhpcy5mcm9tRGF0YShvcHRpb25zKTtcbiAgfVxuXG4gIGljYWxyZWN1cl9pdGVyYXRvci5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBUcnVlIHdoZW4gaXRlcmF0aW9uIGlzIGZpbmlzaGVkLlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIGNvbXBsZXRlZDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgcnVsZSB0aGF0IGlzIGJlaW5nIGl0ZXJhdGVkXG4gICAgICogQHR5cGUge0lDQUwuUmVjdXJ9XG4gICAgICovXG4gICAgcnVsZTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdGFydCBkYXRlIG9mIHRoZSBldmVudCBiZWluZyBpdGVyYXRlZC5cbiAgICAgKiBAdHlwZSB7SUNBTC5UaW1lfVxuICAgICAqL1xuICAgIGR0c3RhcnQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGFzdCBvY2N1cnJlbmNlIHRoYXQgd2FzIHJldHVybmVkIGZyb20gdGhlXG4gICAgICoge0BsaW5rIElDQUwuUmVjdXJJdGVyYXRvciNuZXh0fSBtZXRob2QuXG4gICAgICogQHR5cGUge0lDQUwuVGltZX1cbiAgICAgKi9cbiAgICBsYXN0OiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHNlcXVlbmNlIG51bWJlciBmcm9tIHRoZSBvY2N1cnJlbmNlXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBvY2N1cnJlbmNlX251bWJlcjogMCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbmRpY2VzIHVzZWQgZm9yIHRoZSB7QGxpbmsgSUNBTC5SZWN1ckl0ZXJhdG9yI2J5X2RhdGF9IG9iamVjdC5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYnlfaW5kaWNlczogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHRoZSBpdGVyYXRvciBoYXMgYWxyZWFkeSBiZWVuIGluaXRpYWxpemVkXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBpbml0aWFsaXplZDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5pdGlhbGl6ZCBieS1kYXRhLlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBieV9kYXRhOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGV4cGFuZGVkIHllYXJkYXlzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZGF5czogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbmRleCBpbiB0aGUge0BsaW5rIElDQUwuUmVjdXJJdGVyYXRvciNkYXlzfSBhcnJheS5cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZGF5c19pbmRleDogMCxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGhlIHJlY3VycmVuY2UgaXRlcmF0b3IgZnJvbSB0aGUgcGFzc2VkIGRhdGEgb2JqZWN0LiBUaGlzXG4gICAgICogbWV0aG9kIGlzIHVzdWFsbHkgbm90IGNhbGxlZCBkaXJlY3RseSwgeW91IGNhbiBpbml0aWFsaXplIHRoZSBpdGVyYXRvclxuICAgICAqIHRocm91Z2ggdGhlIGNvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgICAgICAgICAgICAgICAgVGhlIGl0ZXJhdG9yIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0lDQUwuUmVjdXJ9IG9wdGlvbnMucnVsZSAgICAgICBUaGUgcnVsZSB0byBpdGVyYXRlLlxuICAgICAqIEBwYXJhbSB7SUNBTC5UaW1lfSBvcHRpb25zLmR0c3RhcnQgICAgIFRoZSBzdGFydCBkYXRlIG9mIHRoZSBldmVudC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW49fSBvcHRpb25zLmluaXRpYWxpemVkICBXaGVuIHRydWUsIGFzc3VtZSB0aGF0IG9wdGlvbnMgYXJlXG4gICAgICogICAgICAgIGZyb20gYSBwcmV2aW91c2x5IGNvbnN0cnVjdGVkIGl0ZXJhdG9yLiBJbml0aWFsaXphdGlvbiB3aWxsIG5vdCBiZVxuICAgICAqICAgICAgICByZXBlYXRlZC5cbiAgICAgKi9cbiAgICBmcm9tRGF0YTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdGhpcy5ydWxlID0gSUNBTC5oZWxwZXJzLmZvcm1hdENsYXNzVHlwZShvcHRpb25zLnJ1bGUsIElDQUwuUmVjdXIpO1xuXG4gICAgICBpZiAoIXRoaXMucnVsZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2l0ZXJhdG9yIHJlcXVpcmVzIGEgKElDQUwuUmVjdXIpIHJ1bGUnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kdHN0YXJ0ID0gSUNBTC5oZWxwZXJzLmZvcm1hdENsYXNzVHlwZShvcHRpb25zLmR0c3RhcnQsIElDQUwuVGltZSk7XG5cbiAgICAgIGlmICghdGhpcy5kdHN0YXJ0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaXRlcmF0b3IgcmVxdWlyZXMgYSAoSUNBTC5UaW1lKSBkdHN0YXJ0Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmJ5X2RhdGEpIHtcbiAgICAgICAgdGhpcy5ieV9kYXRhID0gb3B0aW9ucy5ieV9kYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ieV9kYXRhID0gSUNBTC5oZWxwZXJzLmNsb25lKHRoaXMucnVsZS5wYXJ0cywgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLm9jY3VycmVuY2VfbnVtYmVyKVxuICAgICAgICB0aGlzLm9jY3VycmVuY2VfbnVtYmVyID0gb3B0aW9ucy5vY2N1cnJlbmNlX251bWJlcjtcblxuICAgICAgdGhpcy5kYXlzID0gb3B0aW9ucy5kYXlzIHx8IFtdO1xuICAgICAgaWYgKG9wdGlvbnMubGFzdCkge1xuICAgICAgICB0aGlzLmxhc3QgPSBJQ0FMLmhlbHBlcnMuZm9ybWF0Q2xhc3NUeXBlKG9wdGlvbnMubGFzdCwgSUNBTC5UaW1lKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ieV9pbmRpY2VzID0gb3B0aW9ucy5ieV9pbmRpY2VzO1xuXG4gICAgICBpZiAoIXRoaXMuYnlfaW5kaWNlcykge1xuICAgICAgICB0aGlzLmJ5X2luZGljZXMgPSB7XG4gICAgICAgICAgXCJCWVNFQ09ORFwiOiAwLFxuICAgICAgICAgIFwiQllNSU5VVEVcIjogMCxcbiAgICAgICAgICBcIkJZSE9VUlwiOiAwLFxuICAgICAgICAgIFwiQllEQVlcIjogMCxcbiAgICAgICAgICBcIkJZTU9OVEhcIjogMCxcbiAgICAgICAgICBcIkJZV0VFS05PXCI6IDAsXG4gICAgICAgICAgXCJCWU1PTlRIREFZXCI6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pbml0aWFsaXplZCA9IG9wdGlvbnMuaW5pdGlhbGl6ZWQgfHwgZmFsc2U7XG5cbiAgICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW50aWFsaXplIHRoZSBpdGVyYXRvclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24gaWNhbHJlY3VyX2l0ZXJhdG9yX2luaXQoKSB7XG4gICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIHRoaXMubGFzdCA9IHRoaXMuZHRzdGFydC5jbG9uZSgpO1xuICAgICAgdmFyIHBhcnRzID0gdGhpcy5ieV9kYXRhO1xuXG4gICAgICBpZiAoXCJCWURBWVwiIGluIHBhcnRzKSB7XG4gICAgICAgIC8vIGxpYmljYWwgZG9lcyB0aGlzIGVhcmxpZXIgd2hlbiB0aGUgcnVsZSBpcyBsb2FkZWQsIGJ1dCB3ZSBwb3N0cG9uZSB0b1xuICAgICAgICAvLyBub3cgc28gd2UgY2FuIHByZXNlcnZlIHRoZSBvcmlnaW5hbCBvcmRlci5cbiAgICAgICAgdGhpcy5zb3J0X2J5ZGF5X3J1bGVzKHBhcnRzLkJZREFZKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIEJZWUVBUkRBWSBhcHBhcmVzLCBubyBvdGhlciBkYXRlIHJ1bGUgcGFydCBtYXkgYXBwZWFyXG4gICAgICBpZiAoXCJCWVlFQVJEQVlcIiBpbiBwYXJ0cykge1xuICAgICAgICBpZiAoXCJCWU1PTlRIXCIgaW4gcGFydHMgfHwgXCJCWVdFRUtOT1wiIGluIHBhcnRzIHx8XG4gICAgICAgICAgICBcIkJZTU9OVEhEQVlcIiBpbiBwYXJ0cyB8fCBcIkJZREFZXCIgaW4gcGFydHMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIEJZWUVBUkRBWSBydWxlXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEJZV0VFS05PIGFuZCBCWU1PTlRIREFZIHJ1bGUgcGFydHMgbWF5IG5vdCBib3RoIGFwcGVhclxuICAgICAgaWYgKFwiQllXRUVLTk9cIiBpbiBwYXJ0cyAmJiBcIkJZTU9OVEhEQVlcIiBpbiBwYXJ0cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCWVdFRUtOTyBkb2VzIG5vdCBmaXQgdG8gQllNT05USERBWVwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gRm9yIE1PTlRITFkgcmVjdXJyZW5jZXMgKEZSRVE9TU9OVEhMWSkgbmVpdGhlciBCWVlFQVJEQVkgbm9yXG4gICAgICAvLyBCWVdFRUtOTyBtYXkgYXBwZWFyLlxuICAgICAgaWYgKHRoaXMucnVsZS5mcmVxID09IFwiTU9OVEhMWVwiICYmXG4gICAgICAgICAgKFwiQllZRUFSREFZXCIgaW4gcGFydHMgfHwgXCJCWVdFRUtOT1wiIGluIHBhcnRzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGb3IgTU9OVEhMWSByZWN1cnJlbmNlcyBuZWl0aGVyIEJZWUVBUkRBWSBub3IgQllXRUVLTk8gbWF5IGFwcGVhclwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gRm9yIFdFRUtMWSByZWN1cnJlbmNlcyAoRlJFUT1XRUVLTFkpIG5laXRoZXIgQllNT05USERBWSBub3JcbiAgICAgIC8vIEJZWUVBUkRBWSBtYXkgYXBwZWFyLlxuICAgICAgaWYgKHRoaXMucnVsZS5mcmVxID09IFwiV0VFS0xZXCIgJiZcbiAgICAgICAgICAoXCJCWVlFQVJEQVlcIiBpbiBwYXJ0cyB8fCBcIkJZTU9OVEhEQVlcIiBpbiBwYXJ0cykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRm9yIFdFRUtMWSByZWN1cnJlbmNlcyBuZWl0aGVyIEJZTU9OVEhEQVkgbm9yIEJZWUVBUkRBWSBtYXkgYXBwZWFyXCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBCWVlFQVJEQVkgbWF5IG9ubHkgYXBwZWFyIGluIFlFQVJMWSBydWxlc1xuICAgICAgaWYgKHRoaXMucnVsZS5mcmVxICE9IFwiWUVBUkxZXCIgJiYgXCJCWVlFQVJEQVlcIiBpbiBwYXJ0cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCWVlFQVJEQVkgbWF5IG9ubHkgYXBwZWFyIGluIFlFQVJMWSBydWxlc1wiKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sYXN0LnNlY29uZCA9IHRoaXMuc2V0dXBfZGVmYXVsdHMoXCJCWVNFQ09ORFwiLCBcIlNFQ09ORExZXCIsIHRoaXMuZHRzdGFydC5zZWNvbmQpO1xuICAgICAgdGhpcy5sYXN0Lm1pbnV0ZSA9IHRoaXMuc2V0dXBfZGVmYXVsdHMoXCJCWU1JTlVURVwiLCBcIk1JTlVURUxZXCIsIHRoaXMuZHRzdGFydC5taW51dGUpO1xuICAgICAgdGhpcy5sYXN0LmhvdXIgPSB0aGlzLnNldHVwX2RlZmF1bHRzKFwiQllIT1VSXCIsIFwiSE9VUkxZXCIsIHRoaXMuZHRzdGFydC5ob3VyKTtcbiAgICAgIHRoaXMubGFzdC5kYXkgPSB0aGlzLnNldHVwX2RlZmF1bHRzKFwiQllNT05USERBWVwiLCBcIkRBSUxZXCIsIHRoaXMuZHRzdGFydC5kYXkpO1xuICAgICAgdGhpcy5sYXN0Lm1vbnRoID0gdGhpcy5zZXR1cF9kZWZhdWx0cyhcIkJZTU9OVEhcIiwgXCJNT05USExZXCIsIHRoaXMuZHRzdGFydC5tb250aCk7XG5cbiAgICAgIGlmICh0aGlzLnJ1bGUuZnJlcSA9PSBcIldFRUtMWVwiKSB7XG4gICAgICAgIGlmIChcIkJZREFZXCIgaW4gcGFydHMpIHtcbiAgICAgICAgICB2YXIgYnlkYXlQYXJ0cyA9IHRoaXMucnVsZURheU9mV2VlayhwYXJ0cy5CWURBWVswXSwgdGhpcy5ydWxlLndrc3QpO1xuICAgICAgICAgIHZhciBwb3MgPSBieWRheVBhcnRzWzBdO1xuICAgICAgICAgIHZhciBkb3cgPSBieWRheVBhcnRzWzFdO1xuICAgICAgICAgIHZhciB3a2R5ID0gZG93IC0gdGhpcy5sYXN0LmRheU9mV2Vlayh0aGlzLnJ1bGUud2tzdCk7XG4gICAgICAgICAgaWYgKCh0aGlzLmxhc3QuZGF5T2ZXZWVrKHRoaXMucnVsZS53a3N0KSA8IGRvdyAmJiB3a2R5ID49IDApIHx8IHdrZHkgPCAwKSB7XG4gICAgICAgICAgICAvLyBJbml0aWFsIHRpbWUgaXMgYWZ0ZXIgZmlyc3QgZGF5IG9mIEJZREFZIGRhdGFcbiAgICAgICAgICAgIHRoaXMubGFzdC5kYXkgKz0gd2tkeTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGRheU5hbWUgPSBJQ0FMLlJlY3VyLm51bWVyaWNEYXlUb0ljYWxEYXkodGhpcy5kdHN0YXJ0LmRheU9mV2VlaygpKTtcbiAgICAgICAgICBwYXJ0cy5CWURBWSA9IFtkYXlOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5ydWxlLmZyZXEgPT0gXCJZRUFSTFlcIikge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgdGhpcy5leHBhbmRfeWVhcl9kYXlzKHRoaXMubGFzdC55ZWFyKTtcbiAgICAgICAgICBpZiAodGhpcy5kYXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmluY3JlbWVudF95ZWFyKHRoaXMucnVsZS5pbnRlcnZhbCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9uZXh0QnlZZWFyRGF5KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnJ1bGUuZnJlcSA9PSBcIk1PTlRITFlcIiAmJiB0aGlzLmhhc19ieV9kYXRhKFwiQllEQVlcIikpIHtcbiAgICAgICAgdmFyIHRlbXBMYXN0ID0gbnVsbDtcbiAgICAgICAgdmFyIGluaXRMYXN0ID0gdGhpcy5sYXN0LmNsb25lKCk7XG4gICAgICAgIHZhciBkYXlzSW5Nb250aCA9IElDQUwuVGltZS5kYXlzSW5Nb250aCh0aGlzLmxhc3QubW9udGgsIHRoaXMubGFzdC55ZWFyKTtcblxuICAgICAgICAvLyBDaGVjayBldmVyeSB3ZWVrZGF5IGluIEJZREFZIHdpdGggcmVsYXRpdmUgZG93IGFuZCBwb3MuXG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5ieV9kYXRhLkJZREFZKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKCF0aGlzLmJ5X2RhdGEuQllEQVkuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmxhc3QgPSBpbml0TGFzdC5jbG9uZSgpO1xuICAgICAgICAgIHZhciBieWRheVBhcnRzID0gdGhpcy5ydWxlRGF5T2ZXZWVrKHRoaXMuYnlfZGF0YS5CWURBWVtpXSk7XG4gICAgICAgICAgdmFyIHBvcyA9IGJ5ZGF5UGFydHNbMF07XG4gICAgICAgICAgdmFyIGRvdyA9IGJ5ZGF5UGFydHNbMV07XG4gICAgICAgICAgdmFyIGRheU9mTW9udGggPSB0aGlzLmxhc3QubnRoV2Vla0RheShkb3csIHBvcyk7XG5cbiAgICAgICAgICAvLyBJZiB8cG9zfCA+PSA2LCB0aGUgYnlkYXkgaXMgaW52YWxpZCBmb3IgYSBtb250aGx5IHJ1bGUuXG4gICAgICAgICAgaWYgKHBvcyA+PSA2IHx8IHBvcyA8PSAtNikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWFsZm9ybWVkIHZhbHVlcyBpbiBCWURBWSBwYXJ0XCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIGEgQnlkYXkgd2l0aCBwb3M9Ky8tNSBpcyBub3QgaW4gdGhlIGN1cnJlbnQgbW9udGggaXRcbiAgICAgICAgICAvLyBtdXN0IGJlIHNlYXJjaGVkIGluIHRoZSBuZXh0IG1vbnRocy5cbiAgICAgICAgICBpZiAoZGF5T2ZNb250aCA+IGRheXNJbk1vbnRoIHx8IGRheU9mTW9udGggPD0gMCkge1xuICAgICAgICAgICAgLy8gU2tpcCBpZiB3ZSBoYXZlIGFscmVhZHkgZm91bmQgYSBcImxhc3RcIiBpbiB0aGlzIG1vbnRoLlxuICAgICAgICAgICAgaWYgKHRlbXBMYXN0ICYmIHRlbXBMYXN0Lm1vbnRoID09IGluaXRMYXN0Lm1vbnRoKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGRheU9mTW9udGggPiBkYXlzSW5Nb250aCB8fCBkYXlPZk1vbnRoIDw9IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5pbmNyZW1lbnRfbW9udGgoKTtcbiAgICAgICAgICAgICAgZGF5c0luTW9udGggPSBJQ0FMLlRpbWUuZGF5c0luTW9udGgodGhpcy5sYXN0Lm1vbnRoLCB0aGlzLmxhc3QueWVhcik7XG4gICAgICAgICAgICAgIGRheU9mTW9udGggPSB0aGlzLmxhc3QubnRoV2Vla0RheShkb3csIHBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5sYXN0LmRheSA9IGRheU9mTW9udGg7XG4gICAgICAgICAgaWYgKCF0ZW1wTGFzdCB8fCB0aGlzLmxhc3QuY29tcGFyZSh0ZW1wTGFzdCkgPCAwKSB7XG4gICAgICAgICAgICB0ZW1wTGFzdCA9IHRoaXMubGFzdC5jbG9uZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3QgPSB0ZW1wTGFzdC5jbG9uZSgpO1xuXG4gICAgICAgIC8vWFhYOiBUaGlzIGZlZWxzIGxpa2UgYSBoYWNrLCBidXQgd2UgbmVlZCB0byBpbml0aWFsaXplXG4gICAgICAgIC8vICAgICB0aGUgQllNT05USERBWSBjYXNlIGNvcnJlY3RseSBhbmQgYnlEYXlBbmRNb250aERheSBoYW5kbGVzXG4gICAgICAgIC8vICAgICB0aGlzIGNhc2UuIEl0IGFjY2VwdHMgYSBzcGVjaWFsIGZsYWcgd2hpY2ggd2lsbCBhdm9pZCBpbmNyZW1lbnRpbmdcbiAgICAgICAgLy8gICAgIHRoZSBpbml0aWFsIHZhbHVlIHdpdGhvdXQgdGhlIGZsYWcgZGF5cyB0aGF0IG1hdGNoIHRoZSBzdGFydCB0aW1lXG4gICAgICAgIC8vICAgICB3b3VsZCBiZSBtaXNzZWQuXG4gICAgICAgIGlmICh0aGlzLmhhc19ieV9kYXRhKCdCWU1PTlRIREFZJykpIHtcbiAgICAgICAgICB0aGlzLl9ieURheUFuZE1vbnRoRGF5KHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubGFzdC5kYXkgPiBkYXlzSW5Nb250aCB8fCB0aGlzLmxhc3QuZGF5ID09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWxmb3JtZWQgdmFsdWVzIGluIEJZREFZIHBhcnRcIik7XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIGlmICh0aGlzLmhhc19ieV9kYXRhKFwiQllNT05USERBWVwiKSkge1xuICAgICAgICBpZiAodGhpcy5sYXN0LmRheSA8IDApIHtcbiAgICAgICAgICB2YXIgZGF5c0luTW9udGggPSBJQ0FMLlRpbWUuZGF5c0luTW9udGgodGhpcy5sYXN0Lm1vbnRoLCB0aGlzLmxhc3QueWVhcik7XG4gICAgICAgICAgdGhpcy5sYXN0LmRheSA9IGRheXNJbk1vbnRoICsgdGhpcy5sYXN0LmRheSArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgbmV4dCBvY2N1cnJlbmNlIGZyb20gdGhlIGl0ZXJhdG9yLlxuICAgICAqIEByZXR1cm4ge0lDQUwuVGltZX1cbiAgICAgKi9cbiAgICBuZXh0OiBmdW5jdGlvbiBpY2FscmVjdXJfaXRlcmF0b3JfbmV4dCgpIHtcbiAgICAgIHZhciBiZWZvcmUgPSAodGhpcy5sYXN0ID8gdGhpcy5sYXN0LmNsb25lKCkgOiBudWxsKTtcblxuICAgICAgaWYgKCh0aGlzLnJ1bGUuY291bnQgJiYgdGhpcy5vY2N1cnJlbmNlX251bWJlciA+PSB0aGlzLnJ1bGUuY291bnQpIHx8XG4gICAgICAgICAgKHRoaXMucnVsZS51bnRpbCAmJiB0aGlzLmxhc3QuY29tcGFyZSh0aGlzLnJ1bGUudW50aWwpID4gMCkpIHtcblxuICAgICAgICAvL1hYWDogcmlnaHQgbm93IHRoaXMgaXMganVzdCBhIGZsYWcgYW5kIGhhcyBubyBpbXBhY3RcbiAgICAgICAgLy8gICAgIHdlIGNhbiBzaW1wbGlmeSB0aGUgYWJvdmUgY2FzZSB0byBjaGVjayBmb3IgY29tcGxldGVkIGxhdGVyLlxuICAgICAgICB0aGlzLmNvbXBsZXRlZCA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9jY3VycmVuY2VfbnVtYmVyID09IDAgJiYgdGhpcy5sYXN0LmNvbXBhcmUodGhpcy5kdHN0YXJ0KSA+PSAwKSB7XG4gICAgICAgIC8vIEZpcnN0IG9mIGFsbCwgZ2l2ZSB0aGUgaW5zdGFuY2UgdGhhdCB3YXMgaW5pdGlhbGl6ZWRcbiAgICAgICAgdGhpcy5vY2N1cnJlbmNlX251bWJlcisrO1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0O1xuICAgICAgfVxuXG5cbiAgICAgIHZhciB2YWxpZDtcbiAgICAgIGRvIHtcbiAgICAgICAgdmFsaWQgPSAxO1xuXG4gICAgICAgIHN3aXRjaCAodGhpcy5ydWxlLmZyZXEpIHtcbiAgICAgICAgY2FzZSBcIlNFQ09ORExZXCI6XG4gICAgICAgICAgdGhpcy5uZXh0X3NlY29uZCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTUlOVVRFTFlcIjpcbiAgICAgICAgICB0aGlzLm5leHRfbWludXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJIT1VSTFlcIjpcbiAgICAgICAgICB0aGlzLm5leHRfaG91cigpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiREFJTFlcIjpcbiAgICAgICAgICB0aGlzLm5leHRfZGF5KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJXRUVLTFlcIjpcbiAgICAgICAgICB0aGlzLm5leHRfd2VlaygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTU9OVEhMWVwiOlxuICAgICAgICAgIHZhbGlkID0gdGhpcy5uZXh0X21vbnRoKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJZRUFSTFlcIjpcbiAgICAgICAgICB0aGlzLm5leHRfeWVhcigpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKCF0aGlzLmNoZWNrX2NvbnRyYWN0aW5nX3J1bGVzKCkgfHxcbiAgICAgICAgICAgICAgIHRoaXMubGFzdC5jb21wYXJlKHRoaXMuZHRzdGFydCkgPCAwIHx8XG4gICAgICAgICAgICAgICAhdmFsaWQpO1xuXG4gICAgICAvLyBUT0RPIGlzIHRoaXMgdmFsaWQ/XG4gICAgICBpZiAodGhpcy5sYXN0LmNvbXBhcmUoYmVmb3JlKSA9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNhbWUgb2NjdXJyZW5jZSBmb3VuZCB0d2ljZSwgcHJvdGVjdGluZyBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBcInlvdSBmcm9tIGRlYXRoIGJ5IHJlY3Vyc2lvblwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucnVsZS51bnRpbCAmJiB0aGlzLmxhc3QuY29tcGFyZSh0aGlzLnJ1bGUudW50aWwpID4gMCkge1xuICAgICAgICB0aGlzLmNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vY2N1cnJlbmNlX251bWJlcisrO1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBuZXh0X3NlY29uZDogZnVuY3Rpb24gbmV4dF9zZWNvbmQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5uZXh0X2dlbmVyaWMoXCJCWVNFQ09ORFwiLCBcIlNFQ09ORExZXCIsIFwic2Vjb25kXCIsIFwibWludXRlXCIpO1xuICAgIH0sXG5cbiAgICBpbmNyZW1lbnRfc2Vjb25kOiBmdW5jdGlvbiBpbmNyZW1lbnRfc2Vjb25kKGluYykge1xuICAgICAgcmV0dXJuIHRoaXMuaW5jcmVtZW50X2dlbmVyaWMoaW5jLCBcInNlY29uZFwiLCA2MCwgXCJtaW51dGVcIik7XG4gICAgfSxcblxuICAgIG5leHRfbWludXRlOiBmdW5jdGlvbiBuZXh0X21pbnV0ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLm5leHRfZ2VuZXJpYyhcIkJZTUlOVVRFXCIsIFwiTUlOVVRFTFlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1pbnV0ZVwiLCBcImhvdXJcIiwgXCJuZXh0X3NlY29uZFwiKTtcbiAgICB9LFxuXG4gICAgaW5jcmVtZW50X21pbnV0ZTogZnVuY3Rpb24gaW5jcmVtZW50X21pbnV0ZShpbmMpIHtcbiAgICAgIHJldHVybiB0aGlzLmluY3JlbWVudF9nZW5lcmljKGluYywgXCJtaW51dGVcIiwgNjAsIFwiaG91clwiKTtcbiAgICB9LFxuXG4gICAgbmV4dF9ob3VyOiBmdW5jdGlvbiBuZXh0X2hvdXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5uZXh0X2dlbmVyaWMoXCJCWUhPVVJcIiwgXCJIT1VSTFlcIiwgXCJob3VyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtb250aGRheVwiLCBcIm5leHRfbWludXRlXCIpO1xuICAgIH0sXG5cbiAgICBpbmNyZW1lbnRfaG91cjogZnVuY3Rpb24gaW5jcmVtZW50X2hvdXIoaW5jKSB7XG4gICAgICB0aGlzLmluY3JlbWVudF9nZW5lcmljKGluYywgXCJob3VyXCIsIDI0LCBcIm1vbnRoZGF5XCIpO1xuICAgIH0sXG5cbiAgICBuZXh0X2RheTogZnVuY3Rpb24gbmV4dF9kYXkoKSB7XG4gICAgICB2YXIgaGFzX2J5X2RheSA9IChcIkJZREFZXCIgaW4gdGhpcy5ieV9kYXRhKTtcbiAgICAgIHZhciB0aGlzX2ZyZXEgPSAodGhpcy5ydWxlLmZyZXEgPT0gXCJEQUlMWVwiKTtcblxuICAgICAgaWYgKHRoaXMubmV4dF9ob3VyKCkgPT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXNfZnJlcSkge1xuICAgICAgICB0aGlzLmluY3JlbWVudF9tb250aGRheSh0aGlzLnJ1bGUuaW50ZXJ2YWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pbmNyZW1lbnRfbW9udGhkYXkoMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG5cbiAgICBuZXh0X3dlZWs6IGZ1bmN0aW9uIG5leHRfd2VlaygpIHtcbiAgICAgIHZhciBlbmRfb2ZfZGF0YSA9IDA7XG5cbiAgICAgIGlmICh0aGlzLm5leHRfd2Vla2RheV9ieV93ZWVrKCkgPT0gMCkge1xuICAgICAgICByZXR1cm4gZW5kX29mX2RhdGE7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmhhc19ieV9kYXRhKFwiQllXRUVLTk9cIikpIHtcbiAgICAgICAgdmFyIGlkeCA9ICsrdGhpcy5ieV9pbmRpY2VzLkJZV0VFS05PO1xuXG4gICAgICAgIGlmICh0aGlzLmJ5X2luZGljZXMuQllXRUVLTk8gPT0gdGhpcy5ieV9kYXRhLkJZV0VFS05PLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuYnlfaW5kaWNlcy5CWVdFRUtOTyA9IDA7XG4gICAgICAgICAgZW5kX29mX2RhdGEgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSEFDSyBzaG91bGQgYmUgZmlyc3QgbW9udGggb2YgdGhlIHllYXJcbiAgICAgICAgdGhpcy5sYXN0Lm1vbnRoID0gMTtcbiAgICAgICAgdGhpcy5sYXN0LmRheSA9IDE7XG5cbiAgICAgICAgdmFyIHdlZWtfbm8gPSB0aGlzLmJ5X2RhdGEuQllXRUVLTk9bdGhpcy5ieV9pbmRpY2VzLkJZV0VFS05PXTtcblxuICAgICAgICB0aGlzLmxhc3QuZGF5ICs9IDcgKiB3ZWVrX25vO1xuXG4gICAgICAgIGlmIChlbmRfb2ZfZGF0YSkge1xuICAgICAgICAgIHRoaXMuaW5jcmVtZW50X3llYXIoMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEp1bXAgdG8gdGhlIG5leHQgd2Vla1xuICAgICAgICB0aGlzLmluY3JlbWVudF9tb250aGRheSg3ICogdGhpcy5ydWxlLmludGVydmFsKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVuZF9vZl9kYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemUgZWFjaCBieSBkYXkgcnVsZSBmb3IgYSBnaXZlbiB5ZWFyL21vbnRoLlxuICAgICAqIFRha2VzIGludG8gYWNjb3VudCBvcmRlcmluZyBhbmQgbmVnYXRpdmUgcnVsZXNcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHllYXIgICAgICAgICBDdXJyZW50IHllYXIuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1vbnRoICAgICAgICBDdXJyZW50IG1vbnRoLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9ICBydWxlcyAgICAgICAgQXJyYXkgb2YgcnVsZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gc29ydGVkIGFuZCBub3JtYWxpemVkIHJ1bGVzLlxuICAgICAqICAgICAgICAgICAgICAgICBOZWdhdGl2ZSBydWxlcyB3aWxsIGJlIGV4cGFuZGVkIHRvIHRoZWlyXG4gICAgICogICAgICAgICAgICAgICAgIGNvcnJlY3QgcG9zaXRpdmUgdmFsdWVzIGZvciBlYXNpZXIgcHJvY2Vzc2luZy5cbiAgICAgKi9cbiAgICBub3JtYWxpemVCeU1vbnRoRGF5UnVsZXM6IGZ1bmN0aW9uKHllYXIsIG1vbnRoLCBydWxlcykge1xuICAgICAgdmFyIGRheXNJbk1vbnRoID0gSUNBTC5UaW1lLmRheXNJbk1vbnRoKG1vbnRoLCB5ZWFyKTtcblxuICAgICAgLy8gWFhYOiBUaGlzIGlzIHByb2JhYmx5IGJhZCBmb3IgcGVyZm9ybWFuY2UgdG8gYWxsb2NhdGVcbiAgICAgIC8vICAgICAgYSBuZXcgYXJyYXkgZm9yIGVhY2ggbW9udGggd2Ugc2NhbiwgaWYgcG9zc2libGVcbiAgICAgIC8vICAgICAgd2Ugc2hvdWxkIHRyeSB0byBvcHRpbWl6ZSB0aGlzLi4uXG4gICAgICB2YXIgbmV3UnVsZXMgPSBbXTtcblxuICAgICAgdmFyIHJ1bGVJZHggPSAwO1xuICAgICAgdmFyIGxlbiA9IHJ1bGVzLmxlbmd0aDtcbiAgICAgIHZhciBydWxlO1xuXG4gICAgICBmb3IgKDsgcnVsZUlkeCA8IGxlbjsgcnVsZUlkeCsrKSB7XG4gICAgICAgIHJ1bGUgPSBydWxlc1tydWxlSWR4XTtcblxuICAgICAgICAvLyBpZiB0aGlzIHJ1bGUgZmFsbHMgb3V0c2lkZSBvZiBnaXZlblxuICAgICAgICAvLyBtb250aCBkaXNjYXJkIGl0LlxuICAgICAgICBpZiAoTWF0aC5hYnMocnVsZSkgPiBkYXlzSW5Nb250aCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbmVnYXRpdmUgY2FzZVxuICAgICAgICBpZiAocnVsZSA8IDApIHtcbiAgICAgICAgICAvLyB3ZSBhZGQgKG5vdCBzdWJ0cmFjdCBpdCBpcyBhIG5lZ2F0aXZlIG51bWJlcilcbiAgICAgICAgICAvLyBvbmUgZnJvbSB0aGUgcnVsZSBiZWNhdXNlIDEgPT09IGxhc3QgZGF5IG9mIG1vbnRoXG4gICAgICAgICAgcnVsZSA9IGRheXNJbk1vbnRoICsgKHJ1bGUgKyAxKTtcbiAgICAgICAgfSBlbHNlIGlmIChydWxlID09PSAwKSB7XG4gICAgICAgICAgLy8gc2tpcCB6ZXJvOiBpdCBpcyBpbnZhbGlkLlxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb25seSBhZGQgdW5pcXVlIGl0ZW1zLi4uXG4gICAgICAgIGlmIChuZXdSdWxlcy5pbmRleE9mKHJ1bGUpID09PSAtMSkge1xuICAgICAgICAgIG5ld1J1bGVzLnB1c2gocnVsZSk7XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICAvLyB1bmlxdWUgYW5kIHNvcnRcbiAgICAgIHJldHVybiBuZXdSdWxlcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEgLSBiOyB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTk9URVM6XG4gICAgICogV2UgYXJlIGdpdmVuIGEgbGlzdCBvZiBkYXRlcyBpbiB0aGUgbW9udGggKEJZTU9OVEhEQVkpICgyMywgZXRjLi4pXG4gICAgICogQWxzbyB3ZSBhcmUgZ2l2ZW4gYSBsaXN0IG9mIGRheXMgKEJZREFZKSAoTU8sIDJTVSwgZXRjLi4pIHdoZW5cbiAgICAgKiBib3RoIGNvbmRpdGlvbnMgbWF0Y2ggYSBnaXZlbiBkYXRlICh0aGlzLmxhc3QuZGF5KSBpdGVyYXRpb24gc3RvcHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbj19IGlzSW5pdCAgICAgV2hlbiBnaXZlbiB0cnVlIHdpbGwgbm90IGluY3JlbWVudCB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCBkYXkgKHRoaXMubGFzdCkuXG4gICAgICovXG4gICAgX2J5RGF5QW5kTW9udGhEYXk6IGZ1bmN0aW9uKGlzSW5pdCkge1xuICAgICAgdmFyIGJ5TW9udGhEYXk7IC8vIHNldHVwIGluIGluaXRNb250aFxuICAgICAgdmFyIGJ5RGF5ID0gdGhpcy5ieV9kYXRhLkJZREFZO1xuXG4gICAgICB2YXIgZGF0ZTtcbiAgICAgIHZhciBkYXRlSWR4ID0gMDtcbiAgICAgIHZhciBkYXRlTGVuOyAvLyBzZXR1cCBpbiBpbml0TW9udGhcbiAgICAgIHZhciBkYXlMZW4gPSBieURheS5sZW5ndGg7XG5cbiAgICAgIC8vIHdlIGFyZSBub3QgdmFsaWQgYnkgZGVmYXVsdFxuICAgICAgdmFyIGRhdGFJc1ZhbGlkID0gMDtcblxuICAgICAgdmFyIGRheXNJbk1vbnRoO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgLy8gd2UgbmVlZCBhIGNvcHkgb2YgdGhpcywgYmVjYXVzZSBhIERhdGVUaW1lIGdldHMgbm9ybWFsaXplZFxuICAgICAgLy8gYXV0b21hdGljYWxseSBpZiB0aGUgZGF5IGlzIG91dCBvZiByYW5nZS4gQXQgc29tZSBwb2ludHMgd2VcbiAgICAgIC8vIHNldCB0aGUgbGFzdCBkYXkgdG8gMCB0byBzdGFydCBjb3VudGluZy5cbiAgICAgIHZhciBsYXN0RGF5ID0gdGhpcy5sYXN0LmRheTtcblxuICAgICAgZnVuY3Rpb24gaW5pdE1vbnRoKCkge1xuICAgICAgICBkYXlzSW5Nb250aCA9IElDQUwuVGltZS5kYXlzSW5Nb250aChcbiAgICAgICAgICBzZWxmLmxhc3QubW9udGgsIHNlbGYubGFzdC55ZWFyXG4gICAgICAgICk7XG5cbiAgICAgICAgYnlNb250aERheSA9IHNlbGYubm9ybWFsaXplQnlNb250aERheVJ1bGVzKFxuICAgICAgICAgIHNlbGYubGFzdC55ZWFyLFxuICAgICAgICAgIHNlbGYubGFzdC5tb250aCxcbiAgICAgICAgICBzZWxmLmJ5X2RhdGEuQllNT05USERBWVxuICAgICAgICApO1xuXG4gICAgICAgIGRhdGVMZW4gPSBieU1vbnRoRGF5Lmxlbmd0aDtcblxuICAgICAgICAvLyBGb3IgdGhlIGNhc2Ugb2YgbW9yZSB0aGFuIG9uZSBvY2N1cnJlbmNlIGluIG9uZSBtb250aFxuICAgICAgICAvLyB3ZSBoYXZlIHRvIGJlIHN1cmUgdG8gc3RhcnQgc2VhcmNoaW5nIGFmdGVyIHRoZSBsYXN0XG4gICAgICAgIC8vIGZvdW5kIGRhdGUgb3IgYXQgdGhlIGxhc3QgQllNT05USERBWSwgdW5sZXNzIHdlIGFyZVxuICAgICAgICAvLyBpbml0aWFsaXppbmcgdGhlIGl0ZXJhdG9yIGJlY2F1c2UgaW4gdGhpcyBjYXNlIHdlIGhhdmVcbiAgICAgICAgLy8gdG8gY29uc2lkZXIgdGhlIGxhc3QgZm91bmQgZGF0ZSB0b28uXG4gICAgICAgIHdoaWxlIChieU1vbnRoRGF5W2RhdGVJZHhdIDw9IGxhc3REYXkgJiZcbiAgICAgICAgICAgICAgICEoaXNJbml0ICYmIGJ5TW9udGhEYXlbZGF0ZUlkeF0gPT0gbGFzdERheSkgJiZcbiAgICAgICAgICAgICAgIGRhdGVJZHggPCBkYXRlTGVuIC0gMSkge1xuICAgICAgICAgIGRhdGVJZHgrKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBuZXh0TW9udGgoKSB7XG4gICAgICAgIC8vIHNpbmNlIHRoZSBkYXkgaXMgaW5jcmVtZW50ZWQgYXQgdGhlIHN0YXJ0XG4gICAgICAgIC8vIG9mIHRoZSBsb29wIGJlbG93LCB3ZSBuZWVkIHRvIHN0YXJ0IGF0IDBcbiAgICAgICAgbGFzdERheSA9IDA7XG4gICAgICAgIHNlbGYuaW5jcmVtZW50X21vbnRoKCk7XG4gICAgICAgIGRhdGVJZHggPSAwO1xuICAgICAgICBpbml0TW9udGgoKTtcbiAgICAgIH1cblxuICAgICAgaW5pdE1vbnRoKCk7XG5cbiAgICAgIC8vIHNob3VsZCBjb21lIGFmdGVyIGluaXRNb250aFxuICAgICAgaWYgKGlzSW5pdCkge1xuICAgICAgICBsYXN0RGF5IC09IDE7XG4gICAgICB9XG5cbiAgICAgIC8vIFVzZSBhIGNvdW50ZXIgdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcCB3aXRoIG1hbGZvcm1lZCBydWxlcy5cbiAgICAgIC8vIFN0b3AgY2hlY2tpbmcgYWZ0ZXIgNCB5ZWFycyBzbyB3ZSBjb25zaWRlciBhbHNvIGEgbGVhcCB5ZWFyLlxuICAgICAgdmFyIG1vbnRoc0NvdW50ZXIgPSA0ODtcblxuICAgICAgd2hpbGUgKCFkYXRhSXNWYWxpZCAmJiBtb250aHNDb3VudGVyKSB7XG4gICAgICAgIG1vbnRoc0NvdW50ZXItLTtcbiAgICAgICAgLy8gaW5jcmVtZW50IHRoZSBjdXJyZW50IGRhdGUuIFRoaXMgaXMgcmVhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCBvdGhlcndpc2Ugd2UgbWF5IGZhbGwgaW50byB0aGUgaW5maW5pdGVcbiAgICAgICAgLy8gbG9vcCB0cmFwLiBUaGUgaW5pdGlhbCBkYXRlIHRha2VzIGNhcmUgb2YgdGhlIGNhc2VcbiAgICAgICAgLy8gd2hlcmUgdGhlIGN1cnJlbnQgZGF0ZSBpcyB0aGUgZGF0ZSB3ZSBhcmUgbG9va2luZ1xuICAgICAgICAvLyBmb3IuXG4gICAgICAgIGRhdGUgPSBsYXN0RGF5ICsgMTtcblxuICAgICAgICBpZiAoZGF0ZSA+IGRheXNJbk1vbnRoKSB7XG4gICAgICAgICAgbmV4dE1vbnRoKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaW5kIG5leHQgZGF0ZVxuICAgICAgICB2YXIgbmV4dCA9IGJ5TW9udGhEYXlbZGF0ZUlkeCsrXTtcblxuICAgICAgICAvLyB0aGlzIGxvZ2ljIGlzIGRlcGVuZGFudCBvbiB0aGUgQllNT05USERBWVNcbiAgICAgICAgLy8gYmVpbmcgaW4gb3JkZXIgKHdoaWNoIGlzIGRvbmUgYnkgI25vcm1hbGl6ZUJ5TW9udGhEYXlSdWxlcylcbiAgICAgICAgaWYgKG5leHQgPj0gZGF0ZSkge1xuICAgICAgICAgIC8vIGlmIHRoZSBuZXh0IG1vbnRoIGRheSBpcyBpbiB0aGUgZnV0dXJlIGp1bXAgdG8gaXQuXG4gICAgICAgICAgbGFzdERheSA9IG5leHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaW4gdGhpcyBjYXNlIHRoZSAnbmV4dCcgbW9udGhkYXkgaGFzIHBhc3RcbiAgICAgICAgICAvLyB3ZSBtdXN0IG1vdmUgdG8gdGhlIG1vbnRoLlxuICAgICAgICAgIG5leHRNb250aCgpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm93IHdlIGNhbiBsb29wIHRocm91Z2ggdGhlIGRheSBydWxlcyB0byBzZWVcbiAgICAgICAgLy8gaWYgb25lIG1hdGNoZXMgdGhlIGN1cnJlbnQgbW9udGggZGF0ZS5cbiAgICAgICAgZm9yICh2YXIgZGF5SWR4ID0gMDsgZGF5SWR4IDwgZGF5TGVuOyBkYXlJZHgrKykge1xuICAgICAgICAgIHZhciBwYXJ0cyA9IHRoaXMucnVsZURheU9mV2VlayhieURheVtkYXlJZHhdKTtcbiAgICAgICAgICB2YXIgcG9zID0gcGFydHNbMF07XG4gICAgICAgICAgdmFyIGRvdyA9IHBhcnRzWzFdO1xuXG4gICAgICAgICAgdGhpcy5sYXN0LmRheSA9IGxhc3REYXk7XG4gICAgICAgICAgaWYgKHRoaXMubGFzdC5pc050aFdlZWtEYXkoZG93LCBwb3MpKSB7XG4gICAgICAgICAgICAvLyB3aGVuIHdlIGZpbmQgdGhlIHZhbGlkIG9uZSB3ZSBjYW4gbWFya1xuICAgICAgICAgICAgLy8gdGhlIGNvbmRpdGlvbnMgYXMgbWV0IGFuZCBicmVhayB0aGUgbG9vcC5cbiAgICAgICAgICAgIC8vIChCZWNhdXNlIHdlIGhhdmUgdGhpcyBjb25kaXRpb24gYWJvdmVcbiAgICAgICAgICAgIC8vICBpdCB3aWxsIGFsc28gYnJlYWsgdGhlIHBhcmVudCBsb29wKS5cbiAgICAgICAgICAgIGRhdGFJc1ZhbGlkID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEl0IGlzIGNvbXBsZXRlbHkgcG9zc2libGUgdGhhdCB0aGUgY29tYmluYXRpb25cbiAgICAgICAgLy8gY2Fubm90IGJlIG1hdGNoZWQgaW4gdGhlIGN1cnJlbnQgbW9udGguXG4gICAgICAgIC8vIFdoZW4gd2UgcmVhY2ggdGhlIGVuZCBvZiBwb3NzaWJsZSBjb21iaW5hdGlvbnNcbiAgICAgICAgLy8gaW4gdGhlIGN1cnJlbnQgbW9udGggd2UgaXRlcmF0ZSB0byB0aGUgbmV4dCBvbmUuXG4gICAgICAgIC8vIHNpbmNlIGRhdGVJZHggaXMgaW5jcmVtZW50ZWQgcmlnaHQgYWZ0ZXIgZ2V0dGluZ1xuICAgICAgICAvLyBcIm5leHRcIiwgd2UgZG9uJ3QgbmVlZCBkYXRlTGVuIC0xIGhlcmUuXG4gICAgICAgIGlmICghZGF0YUlzVmFsaWQgJiYgZGF0ZUlkeCA9PT0gZGF0ZUxlbikge1xuICAgICAgICAgIG5leHRNb250aCgpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtb250aHNDb3VudGVyIDw9IDApIHtcbiAgICAgICAgLy8gQ2hlY2tlZCA0IHllYXJzIHdpdGhvdXQgZmluZGluZyBhIEJ5ZGF5IHRoYXQgbWF0Y2hlc1xuICAgICAgICAvLyBhIEJ5bW9udGhkYXkuIE1heWJlIHRoZSBydWxlIGlzIG5vdCBjb3JyZWN0LlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWxmb3JtZWQgdmFsdWVzIGluIEJZREFZIGNvbWJpbmVkIHdpdGggQllNT05USERBWSBwYXJ0c1wiKTtcbiAgICAgIH1cblxuXG4gICAgICByZXR1cm4gZGF0YUlzVmFsaWQ7XG4gICAgfSxcblxuICAgIG5leHRfbW9udGg6IGZ1bmN0aW9uIG5leHRfbW9udGgoKSB7XG4gICAgICB2YXIgdGhpc19mcmVxID0gKHRoaXMucnVsZS5mcmVxID09IFwiTU9OVEhMWVwiKTtcbiAgICAgIHZhciBkYXRhX3ZhbGlkID0gMTtcblxuICAgICAgaWYgKHRoaXMubmV4dF9ob3VyKCkgPT0gMCkge1xuICAgICAgICByZXR1cm4gZGF0YV92YWxpZDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaGFzX2J5X2RhdGEoXCJCWURBWVwiKSAmJiB0aGlzLmhhc19ieV9kYXRhKFwiQllNT05USERBWVwiKSkge1xuICAgICAgICBkYXRhX3ZhbGlkID0gdGhpcy5fYnlEYXlBbmRNb250aERheSgpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmhhc19ieV9kYXRhKFwiQllEQVlcIikpIHtcbiAgICAgICAgdmFyIGRheXNJbk1vbnRoID0gSUNBTC5UaW1lLmRheXNJbk1vbnRoKHRoaXMubGFzdC5tb250aCwgdGhpcy5sYXN0LnllYXIpO1xuICAgICAgICB2YXIgc2V0cG9zID0gMDtcbiAgICAgICAgdmFyIHNldHBvc190b3RhbCA9IDA7XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzX2J5X2RhdGEoXCJCWVNFVFBPU1wiKSkge1xuICAgICAgICAgIHZhciBsYXN0X2RheSA9IHRoaXMubGFzdC5kYXk7XG4gICAgICAgICAgZm9yICh2YXIgZGF5ID0gMTsgZGF5IDw9IGRheXNJbk1vbnRoOyBkYXkrKykge1xuICAgICAgICAgICAgdGhpcy5sYXN0LmRheSA9IGRheTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzX2RheV9pbl9ieWRheSh0aGlzLmxhc3QpKSB7XG4gICAgICAgICAgICAgIHNldHBvc190b3RhbCsrO1xuICAgICAgICAgICAgICBpZiAoZGF5IDw9IGxhc3RfZGF5KSB7XG4gICAgICAgICAgICAgICAgc2V0cG9zKys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5sYXN0LmRheSA9IGxhc3RfZGF5O1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YV92YWxpZCA9IDA7XG4gICAgICAgIGZvciAodmFyIGRheSA9IHRoaXMubGFzdC5kYXkgKyAxOyBkYXkgPD0gZGF5c0luTW9udGg7IGRheSsrKSB7XG4gICAgICAgICAgdGhpcy5sYXN0LmRheSA9IGRheTtcblxuICAgICAgICAgIGlmICh0aGlzLmlzX2RheV9pbl9ieWRheSh0aGlzLmxhc3QpKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzX2J5X2RhdGEoXCJCWVNFVFBPU1wiKSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tfc2V0X3Bvc2l0aW9uKCsrc2V0cG9zKSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tfc2V0X3Bvc2l0aW9uKHNldHBvcyAtIHNldHBvc190b3RhbCAtIDEpKSB7XG5cbiAgICAgICAgICAgICAgZGF0YV92YWxpZCA9IDE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXkgPiBkYXlzSW5Nb250aCkge1xuICAgICAgICAgIHRoaXMubGFzdC5kYXkgPSAxO1xuICAgICAgICAgIHRoaXMuaW5jcmVtZW50X21vbnRoKCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5pc19kYXlfaW5fYnlkYXkodGhpcy5sYXN0KSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmhhc19ieV9kYXRhKFwiQllTRVRQT1NcIikgfHwgdGhpcy5jaGVja19zZXRfcG9zaXRpb24oMSkpIHtcbiAgICAgICAgICAgICAgZGF0YV92YWxpZCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGFfdmFsaWQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLmhhc19ieV9kYXRhKFwiQllNT05USERBWVwiKSkge1xuICAgICAgICB0aGlzLmJ5X2luZGljZXMuQllNT05USERBWSsrO1xuXG4gICAgICAgIGlmICh0aGlzLmJ5X2luZGljZXMuQllNT05USERBWSA+PSB0aGlzLmJ5X2RhdGEuQllNT05USERBWS5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmJ5X2luZGljZXMuQllNT05USERBWSA9IDA7XG4gICAgICAgICAgdGhpcy5pbmNyZW1lbnRfbW9udGgoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkYXlzSW5Nb250aCA9IElDQUwuVGltZS5kYXlzSW5Nb250aCh0aGlzLmxhc3QubW9udGgsIHRoaXMubGFzdC55ZWFyKTtcbiAgICAgICAgdmFyIGRheSA9IHRoaXMuYnlfZGF0YS5CWU1PTlRIREFZW3RoaXMuYnlfaW5kaWNlcy5CWU1PTlRIREFZXTtcblxuICAgICAgICBpZiAoZGF5IDwgMCkge1xuICAgICAgICAgIGRheSA9IGRheXNJbk1vbnRoICsgZGF5ICsgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXkgPiBkYXlzSW5Nb250aCkge1xuICAgICAgICAgIHRoaXMubGFzdC5kYXkgPSAxO1xuICAgICAgICAgIGRhdGFfdmFsaWQgPSB0aGlzLmlzX2RheV9pbl9ieWRheSh0aGlzLmxhc3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubGFzdC5kYXkgPSBkYXk7XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pbmNyZW1lbnRfbW9udGgoKTtcbiAgICAgICAgdmFyIGRheXNJbk1vbnRoID0gSUNBTC5UaW1lLmRheXNJbk1vbnRoKHRoaXMubGFzdC5tb250aCwgdGhpcy5sYXN0LnllYXIpO1xuICAgICAgICBpZiAodGhpcy5ieV9kYXRhLkJZTU9OVEhEQVlbMF0gPiBkYXlzSW5Nb250aCkge1xuICAgICAgICAgIGRhdGFfdmFsaWQgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubGFzdC5kYXkgPSB0aGlzLmJ5X2RhdGEuQllNT05USERBWVswXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YV92YWxpZDtcbiAgICB9LFxuXG4gICAgbmV4dF93ZWVrZGF5X2J5X3dlZWs6IGZ1bmN0aW9uIG5leHRfd2Vla2RheV9ieV93ZWVrKCkge1xuICAgICAgdmFyIGVuZF9vZl9kYXRhID0gMDtcblxuICAgICAgaWYgKHRoaXMubmV4dF9ob3VyKCkgPT0gMCkge1xuICAgICAgICByZXR1cm4gZW5kX29mX2RhdGE7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5oYXNfYnlfZGF0YShcIkJZREFZXCIpKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgIHZhciB0dCA9IG5ldyBJQ0FMLlRpbWUoKTtcbiAgICAgICAgdGhpcy5ieV9pbmRpY2VzLkJZREFZKys7XG5cbiAgICAgICAgaWYgKHRoaXMuYnlfaW5kaWNlcy5CWURBWSA9PSBPYmplY3Qua2V5cyh0aGlzLmJ5X2RhdGEuQllEQVkpLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuYnlfaW5kaWNlcy5CWURBWSA9IDA7XG4gICAgICAgICAgZW5kX29mX2RhdGEgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvZGVkX2RheSA9IHRoaXMuYnlfZGF0YS5CWURBWVt0aGlzLmJ5X2luZGljZXMuQllEQVldO1xuICAgICAgICB2YXIgcGFydHMgPSB0aGlzLnJ1bGVEYXlPZldlZWsoY29kZWRfZGF5KTtcbiAgICAgICAgdmFyIGRvdyA9IHBhcnRzWzFdO1xuXG4gICAgICAgIGRvdyAtPSB0aGlzLnJ1bGUud2tzdDtcblxuICAgICAgICBpZiAoZG93IDwgMCkge1xuICAgICAgICAgIGRvdyArPSA3O1xuICAgICAgICB9XG5cbiAgICAgICAgdHQueWVhciA9IHRoaXMubGFzdC55ZWFyO1xuICAgICAgICB0dC5tb250aCA9IHRoaXMubGFzdC5tb250aDtcbiAgICAgICAgdHQuZGF5ID0gdGhpcy5sYXN0LmRheTtcblxuICAgICAgICB2YXIgc3RhcnRPZldlZWsgPSB0dC5zdGFydERveVdlZWsodGhpcy5ydWxlLndrc3QpO1xuXG4gICAgICAgIGlmIChkb3cgKyBzdGFydE9mV2VlayA8IDEpIHtcbiAgICAgICAgICAvLyBUaGUgc2VsZWN0ZWQgZGF0ZSBpcyBpbiB0aGUgcHJldmlvdXMgeWVhclxuICAgICAgICAgIGlmICghZW5kX29mX2RhdGEpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXh0ID0gSUNBTC5UaW1lLmZyb21EYXlPZlllYXIoc3RhcnRPZldlZWsgKyBkb3csXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdC55ZWFyKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG5vcm1hbGl6YXRpb24gaG9ycm9ycyBiZWxvdyBhcmUgZHVlIHRvXG4gICAgICAgICAqIHRoZSBmYWN0IHRoYXQgd2hlbiB0aGUgeWVhci9tb250aC9kYXkgY2hhbmdlc1xuICAgICAgICAgKiBpdCBjYW4gZWZmZWN0IHRoZSBvdGhlciBvcGVyYXRpb25zIHRoYXQgY29tZSBhZnRlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGFzdC55ZWFyID0gbmV4dC55ZWFyO1xuICAgICAgICB0aGlzLmxhc3QubW9udGggPSBuZXh0Lm1vbnRoO1xuICAgICAgICB0aGlzLmxhc3QuZGF5ID0gbmV4dC5kYXk7XG5cbiAgICAgICAgcmV0dXJuIGVuZF9vZl9kYXRhO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBuZXh0X3llYXI6IGZ1bmN0aW9uIG5leHRfeWVhcigpIHtcblxuICAgICAgaWYgKHRoaXMubmV4dF9ob3VyKCkgPT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKCsrdGhpcy5kYXlzX2luZGV4ID09IHRoaXMuZGF5cy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5kYXlzX2luZGV4ID0gMDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIHRoaXMuaW5jcmVtZW50X3llYXIodGhpcy5ydWxlLmludGVydmFsKTtcbiAgICAgICAgICB0aGlzLmV4cGFuZF95ZWFyX2RheXModGhpcy5sYXN0LnllYXIpO1xuICAgICAgICB9IHdoaWxlICh0aGlzLmRheXMubGVuZ3RoID09IDApO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9uZXh0QnlZZWFyRGF5KCk7XG5cbiAgICAgIHJldHVybiAxO1xuICAgIH0sXG5cbiAgICBfbmV4dEJ5WWVhckRheTogZnVuY3Rpb24gX25leHRCeVllYXJEYXkoKSB7XG4gICAgICAgIHZhciBkb3kgPSB0aGlzLmRheXNbdGhpcy5kYXlzX2luZGV4XTtcbiAgICAgICAgdmFyIHllYXIgPSB0aGlzLmxhc3QueWVhcjtcbiAgICAgICAgaWYgKGRveSA8IDEpIHtcbiAgICAgICAgICAgIC8vIFRpbWUuZnJvbURheU9mWWVhcihkb3ksIHllYXIpIGluZGV4ZXMgcmVsYXRpdmUgdG8gdGhlXG4gICAgICAgICAgICAvLyBzdGFydCBvZiB0aGUgZ2l2ZW4geWVhci4gVGhhdCBpcyBkaWZmZXJlbnQgZnJvbSB0aGVcbiAgICAgICAgICAgIC8vIHNlbWFudGljcyBvZiBCWVlFQVJEQVkgd2hlcmUgbmVnYXRpdmUgaW5kZXhlcyBhcmUgYW5cbiAgICAgICAgICAgIC8vIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgdGhlIGdpdmVuIHllYXIuXG4gICAgICAgICAgICBkb3kgKz0gMTtcbiAgICAgICAgICAgIHllYXIgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV4dCA9IElDQUwuVGltZS5mcm9tRGF5T2ZZZWFyKGRveSwgeWVhcik7XG4gICAgICAgIHRoaXMubGFzdC5kYXkgPSBuZXh0LmRheTtcbiAgICAgICAgdGhpcy5sYXN0Lm1vbnRoID0gbmV4dC5tb250aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGRvdyAoZWc6ICcxVFUnLCAnLTFNTycpXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWUud2Vla0RheT19IGFXZWVrU3RhcnQgVGhlIHdlZWsgc3RhcnQgd2Vla2RheVxuICAgICAqIEByZXR1cm4gW3BvcywgbnVtZXJpY0Rvd10gKGVnOiBbMSwgM10pIG51bWVyaWNEb3cgaXMgcmVsYXRpdmUgdG8gYVdlZWtTdGFydFxuICAgICAqL1xuICAgIHJ1bGVEYXlPZldlZWs6IGZ1bmN0aW9uIHJ1bGVEYXlPZldlZWsoZG93LCBhV2Vla1N0YXJ0KSB7XG4gICAgICB2YXIgbWF0Y2hlcyA9IGRvdy5tYXRjaCgvKFsrLV0/WzAtOV0pPyhNT3xUVXxXRXxUSHxGUnxTQXxTVSkvKTtcbiAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgIHZhciBwb3MgPSBwYXJzZUludChtYXRjaGVzWzFdIHx8IDAsIDEwKTtcbiAgICAgICAgZG93ID0gSUNBTC5SZWN1ci5pY2FsRGF5VG9OdW1lcmljRGF5KG1hdGNoZXNbMl0sIGFXZWVrU3RhcnQpO1xuICAgICAgICByZXR1cm4gW3BvcywgZG93XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbMCwgMF07XG4gICAgICB9XG4gICAgfSxcblxuICAgIG5leHRfZ2VuZXJpYzogZnVuY3Rpb24gbmV4dF9nZW5lcmljKGFSdWxlVHlwZSwgYUludGVydmFsLCBhRGF0ZUF0dHIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYUZvbGxvd2luZ0F0dHIsIGFQcmV2aW91c0luY3IpIHtcbiAgICAgIHZhciBoYXNfYnlfcnVsZSA9IChhUnVsZVR5cGUgaW4gdGhpcy5ieV9kYXRhKTtcbiAgICAgIHZhciB0aGlzX2ZyZXEgPSAodGhpcy5ydWxlLmZyZXEgPT0gYUludGVydmFsKTtcbiAgICAgIHZhciBlbmRfb2ZfZGF0YSA9IDA7XG5cbiAgICAgIGlmIChhUHJldmlvdXNJbmNyICYmIHRoaXNbYVByZXZpb3VzSW5jcl0oKSA9PSAwKSB7XG4gICAgICAgIHJldHVybiBlbmRfb2ZfZGF0YTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhc19ieV9ydWxlKSB7XG4gICAgICAgIHRoaXMuYnlfaW5kaWNlc1thUnVsZVR5cGVdKys7XG4gICAgICAgIHZhciBpZHggPSB0aGlzLmJ5X2luZGljZXNbYVJ1bGVUeXBlXTtcbiAgICAgICAgdmFyIGR0YSA9IHRoaXMuYnlfZGF0YVthUnVsZVR5cGVdO1xuXG4gICAgICAgIGlmICh0aGlzLmJ5X2luZGljZXNbYVJ1bGVUeXBlXSA9PSBkdGEubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5ieV9pbmRpY2VzW2FSdWxlVHlwZV0gPSAwO1xuICAgICAgICAgIGVuZF9vZl9kYXRhID0gMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RbYURhdGVBdHRyXSA9IGR0YVt0aGlzLmJ5X2luZGljZXNbYVJ1bGVUeXBlXV07XG4gICAgICB9IGVsc2UgaWYgKHRoaXNfZnJlcSkge1xuICAgICAgICB0aGlzW1wiaW5jcmVtZW50X1wiICsgYURhdGVBdHRyXSh0aGlzLnJ1bGUuaW50ZXJ2YWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGFzX2J5X3J1bGUgJiYgZW5kX29mX2RhdGEgJiYgdGhpc19mcmVxKSB7XG4gICAgICAgIHRoaXNbXCJpbmNyZW1lbnRfXCIgKyBhRm9sbG93aW5nQXR0cl0oMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbmRfb2ZfZGF0YTtcbiAgICB9LFxuXG4gICAgaW5jcmVtZW50X21vbnRoZGF5OiBmdW5jdGlvbiBpbmNyZW1lbnRfbW9udGhkYXkoaW5jKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluYzsgaSsrKSB7XG4gICAgICAgIHZhciBkYXlzSW5Nb250aCA9IElDQUwuVGltZS5kYXlzSW5Nb250aCh0aGlzLmxhc3QubW9udGgsIHRoaXMubGFzdC55ZWFyKTtcbiAgICAgICAgdGhpcy5sYXN0LmRheSsrO1xuXG4gICAgICAgIGlmICh0aGlzLmxhc3QuZGF5ID4gZGF5c0luTW9udGgpIHtcbiAgICAgICAgICB0aGlzLmxhc3QuZGF5IC09IGRheXNJbk1vbnRoO1xuICAgICAgICAgIHRoaXMuaW5jcmVtZW50X21vbnRoKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaW5jcmVtZW50X21vbnRoOiBmdW5jdGlvbiBpbmNyZW1lbnRfbW9udGgoKSB7XG4gICAgICB0aGlzLmxhc3QuZGF5ID0gMTtcbiAgICAgIGlmICh0aGlzLmhhc19ieV9kYXRhKFwiQllNT05USFwiKSkge1xuICAgICAgICB0aGlzLmJ5X2luZGljZXMuQllNT05USCsrO1xuXG4gICAgICAgIGlmICh0aGlzLmJ5X2luZGljZXMuQllNT05USCA9PSB0aGlzLmJ5X2RhdGEuQllNT05USC5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmJ5X2luZGljZXMuQllNT05USCA9IDA7XG4gICAgICAgICAgdGhpcy5pbmNyZW1lbnRfeWVhcigxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubGFzdC5tb250aCA9IHRoaXMuYnlfZGF0YS5CWU1PTlRIW3RoaXMuYnlfaW5kaWNlcy5CWU1PTlRIXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLnJ1bGUuZnJlcSA9PSBcIk1PTlRITFlcIikge1xuICAgICAgICAgIHRoaXMubGFzdC5tb250aCArPSB0aGlzLnJ1bGUuaW50ZXJ2YWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5sYXN0Lm1vbnRoKys7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxhc3QubW9udGgtLTtcbiAgICAgICAgdmFyIHllYXJzID0gSUNBTC5oZWxwZXJzLnRydW5jKHRoaXMubGFzdC5tb250aCAvIDEyKTtcbiAgICAgICAgdGhpcy5sYXN0Lm1vbnRoICU9IDEyO1xuICAgICAgICB0aGlzLmxhc3QubW9udGgrKztcblxuICAgICAgICBpZiAoeWVhcnMgIT0gMCkge1xuICAgICAgICAgIHRoaXMuaW5jcmVtZW50X3llYXIoeWVhcnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGluY3JlbWVudF95ZWFyOiBmdW5jdGlvbiBpbmNyZW1lbnRfeWVhcihpbmMpIHtcbiAgICAgIHRoaXMubGFzdC55ZWFyICs9IGluYztcbiAgICB9LFxuXG4gICAgaW5jcmVtZW50X2dlbmVyaWM6IGZ1bmN0aW9uIGluY3JlbWVudF9nZW5lcmljKGluYywgYURhdGVBdHRyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhRmFjdG9yLCBhTmV4dEluY3JlbWVudCkge1xuICAgICAgdGhpcy5sYXN0W2FEYXRlQXR0cl0gKz0gaW5jO1xuICAgICAgdmFyIG5leHR1bml0ID0gSUNBTC5oZWxwZXJzLnRydW5jKHRoaXMubGFzdFthRGF0ZUF0dHJdIC8gYUZhY3Rvcik7XG4gICAgICB0aGlzLmxhc3RbYURhdGVBdHRyXSAlPSBhRmFjdG9yO1xuICAgICAgaWYgKG5leHR1bml0ICE9IDApIHtcbiAgICAgICAgdGhpc1tcImluY3JlbWVudF9cIiArIGFOZXh0SW5jcmVtZW50XShuZXh0dW5pdCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGhhc19ieV9kYXRhOiBmdW5jdGlvbiBoYXNfYnlfZGF0YShhUnVsZVR5cGUpIHtcbiAgICAgIHJldHVybiAoYVJ1bGVUeXBlIGluIHRoaXMucnVsZS5wYXJ0cyk7XG4gICAgfSxcblxuICAgIGV4cGFuZF95ZWFyX2RheXM6IGZ1bmN0aW9uIGV4cGFuZF95ZWFyX2RheXMoYVllYXIpIHtcbiAgICAgIHZhciB0ID0gbmV3IElDQUwuVGltZSgpO1xuICAgICAgdGhpcy5kYXlzID0gW107XG5cbiAgICAgIC8vIFdlIG5lZWQgb3VyIG93biBjb3B5IHdpdGggYSBmZXcga2V5cyBzZXRcbiAgICAgIHZhciBwYXJ0cyA9IHt9O1xuICAgICAgdmFyIHJ1bGVzID0gW1wiQllEQVlcIiwgXCJCWVdFRUtOT1wiLCBcIkJZTU9OVEhEQVlcIiwgXCJCWU1PTlRIXCIsIFwiQllZRUFSREFZXCJdO1xuICAgICAgZm9yICh2YXIgcCBpbiBydWxlcykge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAocnVsZXMuaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgICAgICB2YXIgcGFydCA9IHJ1bGVzW3BdO1xuICAgICAgICAgIGlmIChwYXJ0IGluIHRoaXMucnVsZS5wYXJ0cykge1xuICAgICAgICAgICAgcGFydHNbcGFydF0gPSB0aGlzLnJ1bGUucGFydHNbcGFydF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChcIkJZTU9OVEhcIiBpbiBwYXJ0cyAmJiBcIkJZV0VFS05PXCIgaW4gcGFydHMpIHtcbiAgICAgICAgdmFyIHZhbGlkID0gMTtcbiAgICAgICAgdmFyIHZhbGlkV2Vla3MgPSB7fTtcbiAgICAgICAgdC55ZWFyID0gYVllYXI7XG4gICAgICAgIHQuaXNEYXRlID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKHZhciBtb250aElkeCA9IDA7IG1vbnRoSWR4IDwgdGhpcy5ieV9kYXRhLkJZTU9OVEgubGVuZ3RoOyBtb250aElkeCsrKSB7XG4gICAgICAgICAgdmFyIG1vbnRoID0gdGhpcy5ieV9kYXRhLkJZTU9OVEhbbW9udGhJZHhdO1xuICAgICAgICAgIHQubW9udGggPSBtb250aDtcbiAgICAgICAgICB0LmRheSA9IDE7XG4gICAgICAgICAgdmFyIGZpcnN0X3dlZWsgPSB0LndlZWtOdW1iZXIodGhpcy5ydWxlLndrc3QpO1xuICAgICAgICAgIHQuZGF5ID0gSUNBTC5UaW1lLmRheXNJbk1vbnRoKG1vbnRoLCBhWWVhcik7XG4gICAgICAgICAgdmFyIGxhc3Rfd2VlayA9IHQud2Vla051bWJlcih0aGlzLnJ1bGUud2tzdCk7XG4gICAgICAgICAgZm9yIChtb250aElkeCA9IGZpcnN0X3dlZWs7IG1vbnRoSWR4IDwgbGFzdF93ZWVrOyBtb250aElkeCsrKSB7XG4gICAgICAgICAgICB2YWxpZFdlZWtzW21vbnRoSWR4XSA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgd2Vla0lkeCA9IDA7IHdlZWtJZHggPCB0aGlzLmJ5X2RhdGEuQllXRUVLTk8ubGVuZ3RoICYmIHZhbGlkOyB3ZWVrSWR4KyspIHtcbiAgICAgICAgICB2YXIgd2Vla25vID0gdGhpcy5ieV9kYXRhLkJZV0VFS05PW3dlZWtJZHhdO1xuICAgICAgICAgIGlmICh3ZWVrbm8gPCA1Mikge1xuICAgICAgICAgICAgdmFsaWQgJj0gdmFsaWRXZWVrc1t3ZWVrSWR4XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsaWQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWxpZCkge1xuICAgICAgICAgIGRlbGV0ZSBwYXJ0cy5CWU1PTlRIO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBwYXJ0cy5CWVdFRUtOTztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcGFydENvdW50ID0gT2JqZWN0LmtleXMocGFydHMpLmxlbmd0aDtcblxuICAgICAgaWYgKHBhcnRDb3VudCA9PSAwKSB7XG4gICAgICAgIHZhciB0MSA9IHRoaXMuZHRzdGFydC5jbG9uZSgpO1xuICAgICAgICB0MS55ZWFyID0gdGhpcy5sYXN0LnllYXI7XG4gICAgICAgIHRoaXMuZGF5cy5wdXNoKHQxLmRheU9mWWVhcigpKTtcbiAgICAgIH0gZWxzZSBpZiAocGFydENvdW50ID09IDEgJiYgXCJCWU1PTlRIXCIgaW4gcGFydHMpIHtcbiAgICAgICAgZm9yICh2YXIgbW9udGhrZXkgaW4gdGhpcy5ieV9kYXRhLkJZTU9OVEgpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAoIXRoaXMuYnlfZGF0YS5CWU1PTlRILmhhc093blByb3BlcnR5KG1vbnRoa2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB0MiA9IHRoaXMuZHRzdGFydC5jbG9uZSgpO1xuICAgICAgICAgIHQyLnllYXIgPSBhWWVhcjtcbiAgICAgICAgICB0Mi5tb250aCA9IHRoaXMuYnlfZGF0YS5CWU1PTlRIW21vbnRoa2V5XTtcbiAgICAgICAgICB0Mi5pc0RhdGUgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuZGF5cy5wdXNoKHQyLmRheU9mWWVhcigpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJ0Q291bnQgPT0gMSAmJiBcIkJZTU9OVEhEQVlcIiBpbiBwYXJ0cykge1xuICAgICAgICBmb3IgKHZhciBtb250aGRheWtleSBpbiB0aGlzLmJ5X2RhdGEuQllNT05USERBWSkge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmICghdGhpcy5ieV9kYXRhLkJZTU9OVEhEQVkuaGFzT3duUHJvcGVydHkobW9udGhkYXlrZXkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHQzID0gdGhpcy5kdHN0YXJ0LmNsb25lKCk7XG4gICAgICAgICAgdmFyIGRheV8gPSB0aGlzLmJ5X2RhdGEuQllNT05USERBWVttb250aGRheWtleV07XG4gICAgICAgICAgaWYgKGRheV8gPCAwKSB7XG4gICAgICAgICAgICB2YXIgZGF5c0luTW9udGggPSBJQ0FMLlRpbWUuZGF5c0luTW9udGgodDMubW9udGgsIGFZZWFyKTtcbiAgICAgICAgICAgIGRheV8gPSBkYXlfICsgZGF5c0luTW9udGggKyAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0My5kYXkgPSBkYXlfO1xuICAgICAgICAgIHQzLnllYXIgPSBhWWVhcjtcbiAgICAgICAgICB0My5pc0RhdGUgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuZGF5cy5wdXNoKHQzLmRheU9mWWVhcigpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJ0Q291bnQgPT0gMiAmJlxuICAgICAgICAgICAgICAgICBcIkJZTU9OVEhEQVlcIiBpbiBwYXJ0cyAmJlxuICAgICAgICAgICAgICAgICBcIkJZTU9OVEhcIiBpbiBwYXJ0cykge1xuICAgICAgICBmb3IgKHZhciBtb250aGtleSBpbiB0aGlzLmJ5X2RhdGEuQllNT05USCkge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmICghdGhpcy5ieV9kYXRhLkJZTU9OVEguaGFzT3duUHJvcGVydHkobW9udGhrZXkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG1vbnRoXyA9IHRoaXMuYnlfZGF0YS5CWU1PTlRIW21vbnRoa2V5XTtcbiAgICAgICAgICB2YXIgZGF5c0luTW9udGggPSBJQ0FMLlRpbWUuZGF5c0luTW9udGgobW9udGhfLCBhWWVhcik7XG4gICAgICAgICAgZm9yICh2YXIgbW9udGhkYXlrZXkgaW4gdGhpcy5ieV9kYXRhLkJZTU9OVEhEQVkpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKCF0aGlzLmJ5X2RhdGEuQllNT05USERBWS5oYXNPd25Qcm9wZXJ0eShtb250aGRheWtleSkpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGF5XyA9IHRoaXMuYnlfZGF0YS5CWU1PTlRIREFZW21vbnRoZGF5a2V5XTtcbiAgICAgICAgICAgIGlmIChkYXlfIDwgMCkge1xuICAgICAgICAgICAgICBkYXlfID0gZGF5XyArIGRheXNJbk1vbnRoICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHQuZGF5ID0gZGF5XztcbiAgICAgICAgICAgIHQubW9udGggPSBtb250aF87XG4gICAgICAgICAgICB0LnllYXIgPSBhWWVhcjtcbiAgICAgICAgICAgIHQuaXNEYXRlID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGhpcy5kYXlzLnB1c2godC5kYXlPZlllYXIoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcnRDb3VudCA9PSAxICYmIFwiQllXRUVLTk9cIiBpbiBwYXJ0cykge1xuICAgICAgICAvLyBUT0RPIHVuaW1wbGVtZW50ZWQgaW4gbGliaWNhbFxuICAgICAgfSBlbHNlIGlmIChwYXJ0Q291bnQgPT0gMiAmJlxuICAgICAgICAgICAgICAgICBcIkJZV0VFS05PXCIgaW4gcGFydHMgJiZcbiAgICAgICAgICAgICAgICAgXCJCWU1PTlRIREFZXCIgaW4gcGFydHMpIHtcbiAgICAgICAgLy8gVE9ETyB1bmltcGxlbWVudGVkIGluIGxpYmljYWxcbiAgICAgIH0gZWxzZSBpZiAocGFydENvdW50ID09IDEgJiYgXCJCWURBWVwiIGluIHBhcnRzKSB7XG4gICAgICAgIHRoaXMuZGF5cyA9IHRoaXMuZGF5cy5jb25jYXQodGhpcy5leHBhbmRfYnlfZGF5KGFZZWFyKSk7XG4gICAgICB9IGVsc2UgaWYgKHBhcnRDb3VudCA9PSAyICYmIFwiQllEQVlcIiBpbiBwYXJ0cyAmJiBcIkJZTU9OVEhcIiBpbiBwYXJ0cykge1xuICAgICAgICBmb3IgKHZhciBtb250aGtleSBpbiB0aGlzLmJ5X2RhdGEuQllNT05USCkge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmICghdGhpcy5ieV9kYXRhLkJZTU9OVEguaGFzT3duUHJvcGVydHkobW9udGhrZXkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG1vbnRoID0gdGhpcy5ieV9kYXRhLkJZTU9OVEhbbW9udGhrZXldO1xuICAgICAgICAgIHZhciBkYXlzSW5Nb250aCA9IElDQUwuVGltZS5kYXlzSW5Nb250aChtb250aCwgYVllYXIpO1xuXG4gICAgICAgICAgdC55ZWFyID0gYVllYXI7XG4gICAgICAgICAgdC5tb250aCA9IHRoaXMuYnlfZGF0YS5CWU1PTlRIW21vbnRoa2V5XTtcbiAgICAgICAgICB0LmRheSA9IDE7XG4gICAgICAgICAgdC5pc0RhdGUgPSB0cnVlO1xuXG4gICAgICAgICAgdmFyIGZpcnN0X2RvdyA9IHQuZGF5T2ZXZWVrKCk7XG4gICAgICAgICAgdmFyIGRveV9vZmZzZXQgPSB0LmRheU9mWWVhcigpIC0gMTtcblxuICAgICAgICAgIHQuZGF5ID0gZGF5c0luTW9udGg7XG4gICAgICAgICAgdmFyIGxhc3RfZG93ID0gdC5kYXlPZldlZWsoKTtcblxuICAgICAgICAgIGlmICh0aGlzLmhhc19ieV9kYXRhKFwiQllTRVRQT1NcIikpIHtcbiAgICAgICAgICAgIHZhciBzZXRfcG9zX2NvdW50ZXIgPSAwO1xuICAgICAgICAgICAgdmFyIGJ5X21vbnRoX2RheSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgZGF5ID0gMTsgZGF5IDw9IGRheXNJbk1vbnRoOyBkYXkrKykge1xuICAgICAgICAgICAgICB0LmRheSA9IGRheTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuaXNfZGF5X2luX2J5ZGF5KHQpKSB7XG4gICAgICAgICAgICAgICAgYnlfbW9udGhfZGF5LnB1c2goZGF5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBzcEluZGV4ID0gMDsgc3BJbmRleCA8IGJ5X21vbnRoX2RheS5sZW5ndGg7IHNwSW5kZXgrKykge1xuICAgICAgICAgICAgICBpZiAodGhpcy5jaGVja19zZXRfcG9zaXRpb24oc3BJbmRleCArIDEpIHx8XG4gICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrX3NldF9wb3NpdGlvbihzcEluZGV4IC0gYnlfbW9udGhfZGF5Lmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRheXMucHVzaChkb3lfb2Zmc2V0ICsgYnlfbW9udGhfZGF5W3NwSW5kZXhdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBkYXljb2RlZGtleSBpbiB0aGlzLmJ5X2RhdGEuQllEQVkpIHtcbiAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgIGlmICghdGhpcy5ieV9kYXRhLkJZREFZLmhhc093blByb3BlcnR5KGRheWNvZGVka2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBjb2RlZF9kYXkgPSB0aGlzLmJ5X2RhdGEuQllEQVlbZGF5Y29kZWRrZXldO1xuICAgICAgICAgICAgICB2YXIgYnlkYXlQYXJ0cyA9IHRoaXMucnVsZURheU9mV2Vlayhjb2RlZF9kYXkpO1xuICAgICAgICAgICAgICB2YXIgcG9zID0gYnlkYXlQYXJ0c1swXTtcbiAgICAgICAgICAgICAgdmFyIGRvdyA9IGJ5ZGF5UGFydHNbMV07XG4gICAgICAgICAgICAgIHZhciBtb250aF9kYXk7XG5cbiAgICAgICAgICAgICAgdmFyIGZpcnN0X21hdGNoaW5nX2RheSA9ICgoZG93ICsgNyAtIGZpcnN0X2RvdykgJSA3KSArIDE7XG4gICAgICAgICAgICAgIHZhciBsYXN0X21hdGNoaW5nX2RheSA9IGRheXNJbk1vbnRoIC0gKChsYXN0X2RvdyArIDcgLSBkb3cpICUgNyk7XG5cbiAgICAgICAgICAgICAgaWYgKHBvcyA9PSAwKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZGF5ID0gZmlyc3RfbWF0Y2hpbmdfZGF5OyBkYXkgPD0gZGF5c0luTW9udGg7IGRheSArPSA3KSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmRheXMucHVzaChkb3lfb2Zmc2V0ICsgZGF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocG9zID4gMCkge1xuICAgICAgICAgICAgICAgIG1vbnRoX2RheSA9IGZpcnN0X21hdGNoaW5nX2RheSArIChwb3MgLSAxKSAqIDc7XG5cbiAgICAgICAgICAgICAgICBpZiAobW9udGhfZGF5IDw9IGRheXNJbk1vbnRoKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmRheXMucHVzaChkb3lfb2Zmc2V0ICsgbW9udGhfZGF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbW9udGhfZGF5ID0gbGFzdF9tYXRjaGluZ19kYXkgKyAocG9zICsgMSkgKiA3O1xuXG4gICAgICAgICAgICAgICAgaWYgKG1vbnRoX2RheSA+IDApIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuZGF5cy5wdXNoKGRveV9vZmZzZXQgKyBtb250aF9kYXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gZGF0ZXMgaW4gb3JkZXIgb2Ygb2NjdXJyZW5jZSAoMSwyLDMsLi4uKSBpbnN0ZWFkXG4gICAgICAgIC8vIG9mIGJ5IGdyb3VwcyBvZiB3ZWVrZGF5cyAoMSw4LDE1LC4uLiwyLDksMTYsLi4uKS5cbiAgICAgICAgdGhpcy5kYXlzLnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYSAtIGI7IH0pOyAvLyBDb21wYXJhdG9yIGZ1bmN0aW9uIGFsbG93cyB0byBzb3J0IG51bWJlcnMuXG4gICAgICB9IGVsc2UgaWYgKHBhcnRDb3VudCA9PSAyICYmIFwiQllEQVlcIiBpbiBwYXJ0cyAmJiBcIkJZTU9OVEhEQVlcIiBpbiBwYXJ0cykge1xuICAgICAgICB2YXIgZXhwYW5kZWREYXlzID0gdGhpcy5leHBhbmRfYnlfZGF5KGFZZWFyKTtcblxuICAgICAgICBmb3IgKHZhciBkYXlrZXkgaW4gZXhwYW5kZWREYXlzKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKCFleHBhbmRlZERheXMuaGFzT3duUHJvcGVydHkoZGF5a2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBkYXkgPSBleHBhbmRlZERheXNbZGF5a2V5XTtcbiAgICAgICAgICB2YXIgdHQgPSBJQ0FMLlRpbWUuZnJvbURheU9mWWVhcihkYXksIGFZZWFyKTtcbiAgICAgICAgICBpZiAodGhpcy5ieV9kYXRhLkJZTU9OVEhEQVkuaW5kZXhPZih0dC5kYXkpID49IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGF5cy5wdXNoKGRheSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcnRDb3VudCA9PSAzICYmXG4gICAgICAgICAgICAgICAgIFwiQllEQVlcIiBpbiBwYXJ0cyAmJlxuICAgICAgICAgICAgICAgICBcIkJZTU9OVEhEQVlcIiBpbiBwYXJ0cyAmJlxuICAgICAgICAgICAgICAgICBcIkJZTU9OVEhcIiBpbiBwYXJ0cykge1xuICAgICAgICB2YXIgZXhwYW5kZWREYXlzID0gdGhpcy5leHBhbmRfYnlfZGF5KGFZZWFyKTtcblxuICAgICAgICBmb3IgKHZhciBkYXlrZXkgaW4gZXhwYW5kZWREYXlzKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKCFleHBhbmRlZERheXMuaGFzT3duUHJvcGVydHkoZGF5a2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBkYXkgPSBleHBhbmRlZERheXNbZGF5a2V5XTtcbiAgICAgICAgICB2YXIgdHQgPSBJQ0FMLlRpbWUuZnJvbURheU9mWWVhcihkYXksIGFZZWFyKTtcblxuICAgICAgICAgIGlmICh0aGlzLmJ5X2RhdGEuQllNT05USC5pbmRleE9mKHR0Lm1vbnRoKSA+PSAwICYmXG4gICAgICAgICAgICAgIHRoaXMuYnlfZGF0YS5CWU1PTlRIREFZLmluZGV4T2YodHQuZGF5KSA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRheXMucHVzaChkYXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJ0Q291bnQgPT0gMiAmJiBcIkJZREFZXCIgaW4gcGFydHMgJiYgXCJCWVdFRUtOT1wiIGluIHBhcnRzKSB7XG4gICAgICAgIHZhciBleHBhbmRlZERheXMgPSB0aGlzLmV4cGFuZF9ieV9kYXkoYVllYXIpO1xuXG4gICAgICAgIGZvciAodmFyIGRheWtleSBpbiBleHBhbmRlZERheXMpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAoIWV4cGFuZGVkRGF5cy5oYXNPd25Qcm9wZXJ0eShkYXlrZXkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGRheSA9IGV4cGFuZGVkRGF5c1tkYXlrZXldO1xuICAgICAgICAgIHZhciB0dCA9IElDQUwuVGltZS5mcm9tRGF5T2ZZZWFyKGRheSwgYVllYXIpO1xuICAgICAgICAgIHZhciB3ZWVrbm8gPSB0dC53ZWVrTnVtYmVyKHRoaXMucnVsZS53a3N0KTtcblxuICAgICAgICAgIGlmICh0aGlzLmJ5X2RhdGEuQllXRUVLTk8uaW5kZXhPZih3ZWVrbm8pKSB7XG4gICAgICAgICAgICB0aGlzLmRheXMucHVzaChkYXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJ0Q291bnQgPT0gMyAmJlxuICAgICAgICAgICAgICAgICBcIkJZREFZXCIgaW4gcGFydHMgJiZcbiAgICAgICAgICAgICAgICAgXCJCWVdFRUtOT1wiIGluIHBhcnRzICYmXG4gICAgICAgICAgICAgICAgIFwiQllNT05USERBWVwiIGluIHBhcnRzKSB7XG4gICAgICAgIC8vIFRPRE8gdW5pbXBsZW10ZWQgaW4gbGliaWNhbFxuICAgICAgfSBlbHNlIGlmIChwYXJ0Q291bnQgPT0gMSAmJiBcIkJZWUVBUkRBWVwiIGluIHBhcnRzKSB7XG4gICAgICAgIHRoaXMuZGF5cyA9IHRoaXMuZGF5cy5jb25jYXQodGhpcy5ieV9kYXRhLkJZWUVBUkRBWSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRheXMgPSBbXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG5cbiAgICBleHBhbmRfYnlfZGF5OiBmdW5jdGlvbiBleHBhbmRfYnlfZGF5KGFZZWFyKSB7XG5cbiAgICAgIHZhciBkYXlzX2xpc3QgPSBbXTtcbiAgICAgIHZhciB0bXAgPSB0aGlzLmxhc3QuY2xvbmUoKTtcblxuICAgICAgdG1wLnllYXIgPSBhWWVhcjtcbiAgICAgIHRtcC5tb250aCA9IDE7XG4gICAgICB0bXAuZGF5ID0gMTtcbiAgICAgIHRtcC5pc0RhdGUgPSB0cnVlO1xuXG4gICAgICB2YXIgc3RhcnRfZG93ID0gdG1wLmRheU9mV2VlaygpO1xuXG4gICAgICB0bXAubW9udGggPSAxMjtcbiAgICAgIHRtcC5kYXkgPSAzMTtcbiAgICAgIHRtcC5pc0RhdGUgPSB0cnVlO1xuXG4gICAgICB2YXIgZW5kX2RvdyA9IHRtcC5kYXlPZldlZWsoKTtcbiAgICAgIHZhciBlbmRfeWVhcl9kYXkgPSB0bXAuZGF5T2ZZZWFyKCk7XG5cbiAgICAgIGZvciAodmFyIGRheWtleSBpbiB0aGlzLmJ5X2RhdGEuQllEQVkpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghdGhpcy5ieV9kYXRhLkJZREFZLmhhc093blByb3BlcnR5KGRheWtleSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF5ID0gdGhpcy5ieV9kYXRhLkJZREFZW2RheWtleV07XG4gICAgICAgIHZhciBwYXJ0cyA9IHRoaXMucnVsZURheU9mV2VlayhkYXkpO1xuICAgICAgICB2YXIgcG9zID0gcGFydHNbMF07XG4gICAgICAgIHZhciBkb3cgPSBwYXJ0c1sxXTtcblxuICAgICAgICBpZiAocG9zID09IDApIHtcbiAgICAgICAgICB2YXIgdG1wX3N0YXJ0X2RveSA9ICgoZG93ICsgNyAtIHN0YXJ0X2RvdykgJSA3KSArIDE7XG5cbiAgICAgICAgICBmb3IgKHZhciBkb3kgPSB0bXBfc3RhcnRfZG95OyBkb3kgPD0gZW5kX3llYXJfZGF5OyBkb3kgKz0gNykge1xuICAgICAgICAgICAgZGF5c19saXN0LnB1c2goZG95KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChwb3MgPiAwKSB7XG4gICAgICAgICAgdmFyIGZpcnN0O1xuICAgICAgICAgIGlmIChkb3cgPj0gc3RhcnRfZG93KSB7XG4gICAgICAgICAgICBmaXJzdCA9IGRvdyAtIHN0YXJ0X2RvdyArIDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZpcnN0ID0gZG93IC0gc3RhcnRfZG93ICsgODtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkYXlzX2xpc3QucHVzaChmaXJzdCArIChwb3MgLSAxKSAqIDcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBsYXN0O1xuICAgICAgICAgIHBvcyA9IC1wb3M7XG5cbiAgICAgICAgICBpZiAoZG93IDw9IGVuZF9kb3cpIHtcbiAgICAgICAgICAgIGxhc3QgPSBlbmRfeWVhcl9kYXkgLSBlbmRfZG93ICsgZG93O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsYXN0ID0gZW5kX3llYXJfZGF5IC0gZW5kX2RvdyArIGRvdyAtIDc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGF5c19saXN0LnB1c2gobGFzdCAtIChwb3MgLSAxKSAqIDcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF5c19saXN0O1xuICAgIH0sXG5cbiAgICBpc19kYXlfaW5fYnlkYXk6IGZ1bmN0aW9uIGlzX2RheV9pbl9ieWRheSh0dCkge1xuICAgICAgZm9yICh2YXIgZGF5a2V5IGluIHRoaXMuYnlfZGF0YS5CWURBWSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCF0aGlzLmJ5X2RhdGEuQllEQVkuaGFzT3duUHJvcGVydHkoZGF5a2V5KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXkgPSB0aGlzLmJ5X2RhdGEuQllEQVlbZGF5a2V5XTtcbiAgICAgICAgdmFyIHBhcnRzID0gdGhpcy5ydWxlRGF5T2ZXZWVrKGRheSk7XG4gICAgICAgIHZhciBwb3MgPSBwYXJ0c1swXTtcbiAgICAgICAgdmFyIGRvdyA9IHBhcnRzWzFdO1xuICAgICAgICB2YXIgdGhpc19kb3cgPSB0dC5kYXlPZldlZWsoKTtcblxuICAgICAgICBpZiAoKHBvcyA9PSAwICYmIGRvdyA9PSB0aGlzX2RvdykgfHxcbiAgICAgICAgICAgICh0dC5udGhXZWVrRGF5KGRvdywgcG9zKSA9PSB0dC5kYXkpKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBnaXZlbiB2YWx1ZSBpcyBpbiBCWVNFVFBPUy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1lcmljfSBhUG9zIHBvc2l0aW9uIHRvIGNoZWNrIGZvci5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBmYWxzZSB1bmxlc3MgQllTRVRQT1MgcnVsZXMgZXhpc3RcbiAgICAgKiAgICAgICAgICAgICAgICAgICBhbmQgdGhlIGdpdmVuIHZhbHVlIGlzIHByZXNlbnQgaW4gcnVsZXMuXG4gICAgICovXG4gICAgY2hlY2tfc2V0X3Bvc2l0aW9uOiBmdW5jdGlvbiBjaGVja19zZXRfcG9zaXRpb24oYVBvcykge1xuICAgICAgaWYgKHRoaXMuaGFzX2J5X2RhdGEoJ0JZU0VUUE9TJykpIHtcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMuYnlfZGF0YS5CWVNFVFBPUy5pbmRleE9mKGFQb3MpO1xuICAgICAgICAvLyBuZWdhdGl2ZSBudW1iZXJzIGFyZSBub3QgZmFsc2UteVxuICAgICAgICByZXR1cm4gaWR4ICE9PSAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgc29ydF9ieWRheV9ydWxlczogZnVuY3Rpb24gaWNhbHJlY3VyX3NvcnRfYnlkYXlfcnVsZXMoYVJ1bGVzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFSdWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGk7IGorKykge1xuICAgICAgICAgIHZhciBvbmUgPSB0aGlzLnJ1bGVEYXlPZldlZWsoYVJ1bGVzW2pdLCB0aGlzLnJ1bGUud2tzdClbMV07XG4gICAgICAgICAgdmFyIHR3byA9IHRoaXMucnVsZURheU9mV2VlayhhUnVsZXNbaV0sIHRoaXMucnVsZS53a3N0KVsxXTtcblxuICAgICAgICAgIGlmIChvbmUgPiB0d28pIHtcbiAgICAgICAgICAgIHZhciB0bXAgPSBhUnVsZXNbaV07XG4gICAgICAgICAgICBhUnVsZXNbaV0gPSBhUnVsZXNbal07XG4gICAgICAgICAgICBhUnVsZXNbal0gPSB0bXA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGNoZWNrX2NvbnRyYWN0X3Jlc3RyaWN0aW9uOiBmdW5jdGlvbiBjaGVja19jb250cmFjdF9yZXN0cmljdGlvbihhUnVsZVR5cGUsIHYpIHtcbiAgICAgIHZhciBpbmRleE1hcFZhbHVlID0gaWNhbHJlY3VyX2l0ZXJhdG9yLl9pbmRleE1hcFthUnVsZVR5cGVdO1xuICAgICAgdmFyIHJ1bGVNYXBWYWx1ZSA9IGljYWxyZWN1cl9pdGVyYXRvci5fZXhwYW5kTWFwW3RoaXMucnVsZS5mcmVxXVtpbmRleE1hcFZhbHVlXTtcbiAgICAgIHZhciBwYXNzID0gZmFsc2U7XG5cbiAgICAgIGlmIChhUnVsZVR5cGUgaW4gdGhpcy5ieV9kYXRhICYmXG4gICAgICAgICAgcnVsZU1hcFZhbHVlID09IGljYWxyZWN1cl9pdGVyYXRvci5DT05UUkFDVCkge1xuXG4gICAgICAgIHZhciBydWxlVHlwZSA9IHRoaXMuYnlfZGF0YVthUnVsZVR5cGVdO1xuXG4gICAgICAgIGZvciAodmFyIGJ5ZGF0YWtleSBpbiBydWxlVHlwZSkge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgaWYgKHJ1bGVUeXBlLmhhc093blByb3BlcnR5KGJ5ZGF0YWtleSkpIHtcbiAgICAgICAgICAgIGlmIChydWxlVHlwZVtieWRhdGFrZXldID09IHYpIHtcbiAgICAgICAgICAgICAgcGFzcyA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm90IGEgY29udHJhY3RpbmcgYnlydWxlIG9yIGhhcyBubyBkYXRhLCB0ZXN0IHBhc3Nlc1xuICAgICAgICBwYXNzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXNzO1xuICAgIH0sXG5cbiAgICBjaGVja19jb250cmFjdGluZ19ydWxlczogZnVuY3Rpb24gY2hlY2tfY29udHJhY3RpbmdfcnVsZXMoKSB7XG4gICAgICB2YXIgZG93ID0gdGhpcy5sYXN0LmRheU9mV2VlaygpO1xuICAgICAgdmFyIHdlZWtObyA9IHRoaXMubGFzdC53ZWVrTnVtYmVyKHRoaXMucnVsZS53a3N0KTtcbiAgICAgIHZhciBkb3kgPSB0aGlzLmxhc3QuZGF5T2ZZZWFyKCk7XG5cbiAgICAgIHJldHVybiAodGhpcy5jaGVja19jb250cmFjdF9yZXN0cmljdGlvbihcIkJZU0VDT05EXCIsIHRoaXMubGFzdC5zZWNvbmQpICYmXG4gICAgICAgICAgICAgIHRoaXMuY2hlY2tfY29udHJhY3RfcmVzdHJpY3Rpb24oXCJCWU1JTlVURVwiLCB0aGlzLmxhc3QubWludXRlKSAmJlxuICAgICAgICAgICAgICB0aGlzLmNoZWNrX2NvbnRyYWN0X3Jlc3RyaWN0aW9uKFwiQllIT1VSXCIsIHRoaXMubGFzdC5ob3VyKSAmJlxuICAgICAgICAgICAgICB0aGlzLmNoZWNrX2NvbnRyYWN0X3Jlc3RyaWN0aW9uKFwiQllEQVlcIiwgSUNBTC5SZWN1ci5udW1lcmljRGF5VG9JY2FsRGF5KGRvdykpICYmXG4gICAgICAgICAgICAgIHRoaXMuY2hlY2tfY29udHJhY3RfcmVzdHJpY3Rpb24oXCJCWVdFRUtOT1wiLCB3ZWVrTm8pICYmXG4gICAgICAgICAgICAgIHRoaXMuY2hlY2tfY29udHJhY3RfcmVzdHJpY3Rpb24oXCJCWU1PTlRIREFZXCIsIHRoaXMubGFzdC5kYXkpICYmXG4gICAgICAgICAgICAgIHRoaXMuY2hlY2tfY29udHJhY3RfcmVzdHJpY3Rpb24oXCJCWU1PTlRIXCIsIHRoaXMubGFzdC5tb250aCkgJiZcbiAgICAgICAgICAgICAgdGhpcy5jaGVja19jb250cmFjdF9yZXN0cmljdGlvbihcIkJZWUVBUkRBWVwiLCBkb3kpKTtcbiAgICB9LFxuXG4gICAgc2V0dXBfZGVmYXVsdHM6IGZ1bmN0aW9uIHNldHVwX2RlZmF1bHRzKGFSdWxlVHlwZSwgcmVxLCBkZWZ0aW1lKSB7XG4gICAgICB2YXIgaW5kZXhNYXBWYWx1ZSA9IGljYWxyZWN1cl9pdGVyYXRvci5faW5kZXhNYXBbYVJ1bGVUeXBlXTtcbiAgICAgIHZhciBydWxlTWFwVmFsdWUgPSBpY2FscmVjdXJfaXRlcmF0b3IuX2V4cGFuZE1hcFt0aGlzLnJ1bGUuZnJlcV1baW5kZXhNYXBWYWx1ZV07XG5cbiAgICAgIGlmIChydWxlTWFwVmFsdWUgIT0gaWNhbHJlY3VyX2l0ZXJhdG9yLkNPTlRSQUNUKSB7XG4gICAgICAgIGlmICghKGFSdWxlVHlwZSBpbiB0aGlzLmJ5X2RhdGEpKSB7XG4gICAgICAgICAgdGhpcy5ieV9kYXRhW2FSdWxlVHlwZV0gPSBbZGVmdGltZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucnVsZS5mcmVxICE9IHJlcSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmJ5X2RhdGFbYVJ1bGVUeXBlXVswXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRlZnRpbWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgaXRlcmF0b3IgaW50byBhIHNlcmlhbGl6ZS1hYmxlIG9iamVjdC4gIFdpbGwgcHJlc2VydmUgY3VycmVudFxuICAgICAqIGl0ZXJhdGlvbiBzZXF1ZW5jZSB0byBlbnN1cmUgdGhlIHNlYW1sZXNzIGNvbnRpbnVhdGlvbiBvZiB0aGUgcmVjdXJyZW5jZVxuICAgICAqIHJ1bGUuXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgICAgcmVzdWx0LmluaXRpYWxpemVkID0gdGhpcy5pbml0aWFsaXplZDtcbiAgICAgIHJlc3VsdC5ydWxlID0gdGhpcy5ydWxlLnRvSlNPTigpO1xuICAgICAgcmVzdWx0LmR0c3RhcnQgPSB0aGlzLmR0c3RhcnQudG9KU09OKCk7XG4gICAgICByZXN1bHQuYnlfZGF0YSA9IHRoaXMuYnlfZGF0YTtcbiAgICAgIHJlc3VsdC5kYXlzID0gdGhpcy5kYXlzO1xuICAgICAgcmVzdWx0Lmxhc3QgPSB0aGlzLmxhc3QudG9KU09OKCk7XG4gICAgICByZXN1bHQuYnlfaW5kaWNlcyA9IHRoaXMuYnlfaW5kaWNlcztcbiAgICAgIHJlc3VsdC5vY2N1cnJlbmNlX251bWJlciA9IHRoaXMub2NjdXJyZW5jZV9udW1iZXI7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9O1xuXG4gIGljYWxyZWN1cl9pdGVyYXRvci5faW5kZXhNYXAgPSB7XG4gICAgXCJCWVNFQ09ORFwiOiAwLFxuICAgIFwiQllNSU5VVEVcIjogMSxcbiAgICBcIkJZSE9VUlwiOiAyLFxuICAgIFwiQllEQVlcIjogMyxcbiAgICBcIkJZTU9OVEhEQVlcIjogNCxcbiAgICBcIkJZWUVBUkRBWVwiOiA1LFxuICAgIFwiQllXRUVLTk9cIjogNixcbiAgICBcIkJZTU9OVEhcIjogNyxcbiAgICBcIkJZU0VUUE9TXCI6IDhcbiAgfTtcblxuICBpY2FscmVjdXJfaXRlcmF0b3IuX2V4cGFuZE1hcCA9IHtcbiAgICBcIlNFQ09ORExZXCI6IFsxLCAxLCAxLCAxLCAxLCAxLCAxLCAxXSxcbiAgICBcIk1JTlVURUxZXCI6IFsyLCAxLCAxLCAxLCAxLCAxLCAxLCAxXSxcbiAgICBcIkhPVVJMWVwiOiBbMiwgMiwgMSwgMSwgMSwgMSwgMSwgMV0sXG4gICAgXCJEQUlMWVwiOiBbMiwgMiwgMiwgMSwgMSwgMSwgMSwgMV0sXG4gICAgXCJXRUVLTFlcIjogWzIsIDIsIDIsIDIsIDMsIDMsIDEsIDFdLFxuICAgIFwiTU9OVEhMWVwiOiBbMiwgMiwgMiwgMiwgMiwgMywgMywgMV0sXG4gICAgXCJZRUFSTFlcIjogWzIsIDIsIDIsIDIsIDIsIDIsIDIsIDJdXG4gIH07XG4gIGljYWxyZWN1cl9pdGVyYXRvci5VTktOT1dOID0gMDtcbiAgaWNhbHJlY3VyX2l0ZXJhdG9yLkNPTlRSQUNUID0gMTtcbiAgaWNhbHJlY3VyX2l0ZXJhdG9yLkVYUEFORCA9IDI7XG4gIGljYWxyZWN1cl9pdGVyYXRvci5JTExFR0FMID0gMztcblxuICByZXR1cm4gaWNhbHJlY3VyX2l0ZXJhdG9yO1xuXG59KCkpO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoLCAyMDExLTIwMTUgKi9cblxuXG4vKipcbiAqIFRoaXMgc3ltYm9sIGlzIGZ1cnRoZXIgZGVzY3JpYmVkIGxhdGVyIG9uXG4gKiBAaWdub3JlXG4gKi9cbklDQUwuUmVjdXJFeHBhbnNpb24gPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIGZvcm1hdFRpbWUoaXRlbSkge1xuICAgIHJldHVybiBJQ0FMLmhlbHBlcnMuZm9ybWF0Q2xhc3NUeXBlKGl0ZW0sIElDQUwuVGltZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wYXJlVGltZShhLCBiKSB7XG4gICAgcmV0dXJuIGEuY29tcGFyZShiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUmVjdXJyaW5nQ29tcG9uZW50KGNvbXApIHtcbiAgICByZXR1cm4gY29tcC5oYXNQcm9wZXJ0eSgncmRhdGUnKSB8fFxuICAgICAgICAgICBjb21wLmhhc1Byb3BlcnR5KCdycnVsZScpIHx8XG4gICAgICAgICAgIGNvbXAuaGFzUHJvcGVydHkoJ3JlY3VycmVuY2UtaWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIFByaW1hcnkgY2xhc3MgZm9yIGV4cGFuZGluZyByZWN1cnJpbmcgcnVsZXMuICBDYW4gdGFrZSBtdWx0aXBsZSBycnVsZXMsXG4gICAqIHJkYXRlcywgZXhkYXRlKHMpIGFuZCBpdGVyYXRlIChpbiBvcmRlcikgb3ZlciBlYWNoIG5leHQgb2NjdXJyZW5jZS5cbiAgICpcbiAgICogT25jZSBpbml0aWFsaXplZCB0aGlzIGNsYXNzIGNhbiBhbHNvIGJlIHNlcmlhbGl6ZWQgc2F2ZWQgYW5kIGNvbnRpbnVlXG4gICAqIGl0ZXJhdGlvbiBmcm9tIHRoZSBsYXN0IHBvaW50LlxuICAgKlxuICAgKiBOT1RFOiBpdCBpcyBpbnRlbmRlZCB0aGF0IHRoaXMgY2xhc3MgaXMgdG8gYmUgdXNlZFxuICAgKiAgICAgICB3aXRoIElDQUwuRXZlbnQgd2hpY2ggaGFuZGxlcyByZWN1cnJlbmNlIGV4Y2VwdGlvbnMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGFzc3VtaW5nIGV2ZW50IGlzIGEgcGFyc2VkIGljYWwgY29tcG9uZW50XG4gICAqIHZhciBldmVudDtcbiAgICpcbiAgICogdmFyIGV4cGFuZCA9IG5ldyBJQ0FMLlJlY3VyRXhwYW5zaW9uKHtcbiAgICogICBjb21wb25lbnQ6IGV2ZW50LFxuICAgKiAgIGR0c3RhcnQ6IGV2ZW50LmdldEZpcnN0UHJvcGVydHlWYWx1ZSgnZHRzdGFydCcpXG4gICAqIH0pO1xuICAgKlxuICAgKiAvLyByZW1lbWJlciB0aGVyZSBhcmUgaW5maW5pdGUgcnVsZXNcbiAgICogLy8gc28gaXQgaXMgYSBnb29kIGlkZWEgdG8gbGltaXQgdGhlIHNjb3BlXG4gICAqIC8vIG9mIHRoZSBpdGVyYXRpb25zIHRoZW4gcmVzdW1lIGxhdGVyIG9uLlxuICAgKlxuICAgKiAvLyBuZXh0IGlzIGFsd2F5cyBhbiBJQ0FMLlRpbWUgb3IgbnVsbFxuICAgKiB2YXIgbmV4dDtcbiAgICpcbiAgICogd2hpbGUgKHNvbWVDb25kaXRpb24gJiYgKG5leHQgPSBleHBhbmQubmV4dCgpKSkge1xuICAgKiAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIG5leHRcbiAgICogfVxuICAgKlxuICAgKiAvLyBzYXZlIGluc3RhbmNlIGZvciBsYXRlclxuICAgKiB2YXIganNvbiA9IEpTT04uc3RyaW5naWZ5KGV4cGFuZCk7XG4gICAqXG4gICAqIC8vLi4uXG4gICAqXG4gICAqIC8vIE5PVEU6IGlmIHRoZSBjb21wb25lbnQncyBwcm9wZXJ0aWVzIGhhdmVcbiAgICogLy8gICAgICAgY2hhbmdlZCB5b3Ugd2lsbCBuZWVkIHRvIHJlYnVpbGQgdGhlXG4gICAqIC8vICAgICAgIGNsYXNzIGFuZCBzdGFydCBvdmVyLiBUaGlzIG9ubHkgd29ya3NcbiAgICogLy8gICAgICAgd2hlbiB0aGUgY29tcG9uZW50J3MgcmVjdXJyZW5jZSBpbmZvIGlzIHRoZSBzYW1lLlxuICAgKiB2YXIgZXhwYW5kID0gbmV3IElDQUwuUmVjdXJFeHBhbnNpb24oSlNPTi5wYXJzZShqc29uKSk7XG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBUaGUgb3B0aW9ucyBvYmplY3QgY2FuIGJlIGZpbGxlZCB3aXRoIHRoZSBzcGVjaWZpZWQgaW5pdGlhbCB2YWx1ZXMuIEl0IGNhblxuICAgKiBhbHNvIGNvbnRhaW4gYWRkaXRpb25hbCBtZW1iZXJzLCBhcyBhIHJlc3VsdCBvZiBzZXJpYWxpemluZyBhIHByZXZpb3VzXG4gICAqIGV4cGFuc2lvbiBzdGF0ZSwgYXMgc2hvd24gaW4gdGhlIGV4YW1wbGUuXG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAYWxpYXMgSUNBTC5SZWN1ckV4cGFuc2lvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiAgICAgICAgUmVjdXJyZW5jZSBleHBhbnNpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0lDQUwuVGltZX0gb3B0aW9ucy5kdHN0YXJ0XG4gICAqICAgICAgICBTdGFydCB0aW1lIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge0lDQUwuQ29tcG9uZW50PX0gb3B0aW9ucy5jb21wb25lbnRcbiAgICogICAgICAgIENvbXBvbmVudCBmb3IgZXhwYW5zaW9uLCByZXF1aXJlZCBpZiBub3QgcmVzdW1pbmcuXG4gICAqL1xuICBmdW5jdGlvbiBSZWN1ckV4cGFuc2lvbihvcHRpb25zKSB7XG4gICAgdGhpcy5ydWxlRGF0ZXMgPSBbXTtcbiAgICB0aGlzLmV4RGF0ZXMgPSBbXTtcbiAgICB0aGlzLmZyb21EYXRhKG9wdGlvbnMpO1xuICB9XG5cbiAgUmVjdXJFeHBhbnNpb24ucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIFRydWUgd2hlbiBpdGVyYXRpb24gaXMgZnVsbHkgY29tcGxldGVkLlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIGNvbXBsZXRlOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEFycmF5IG9mIHJydWxlIGl0ZXJhdG9ycy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtJQ0FMLlJlY3VySXRlcmF0b3JbXX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHJ1bGVJdGVyYXRvcnM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBvZiByZGF0ZSBpbnN0YW5jZXMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7SUNBTC5UaW1lW119XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBydWxlRGF0ZXM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBvZiBleGRhdGUgaW5zdGFuY2VzLlxuICAgICAqXG4gICAgICogQHR5cGUge0lDQUwuVGltZVtdfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZXhEYXRlczogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgcG9zaXRpb24gaW4gcnVsZURhdGVzIGFycmF5LlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBydWxlRGF0ZUluYzogMCxcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgcG9zaXRpb24gaW4gZXhEYXRlcyBhcnJheVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBleERhdGVJbmM6IDAsXG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IG5lZ2F0aXZlIGRhdGUuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7SUNBTC5UaW1lfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZXhEYXRlOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBhZGRpdGlvbmFsIGRhdGUuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7SUNBTC5UaW1lfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcnVsZURhdGU6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBTdGFydCBkYXRlIG9mIHJlY3VycmluZyBydWxlcy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtJQ0FMLlRpbWV9XG4gICAgICovXG4gICAgZHRzdGFydDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIExhc3QgZXhwYW5kZWQgdGltZVxuICAgICAqXG4gICAgICogQHR5cGUge0lDQUwuVGltZX1cbiAgICAgKi9cbiAgICBsYXN0OiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgcmVjdXJyZW5jZSBleHBhbnNpb24gZnJvbSB0aGUgZGF0YSBvYmplY3QuIFRoZSBvcHRpb25zXG4gICAgICogb2JqZWN0IG1heSBhbHNvIGNvbnRhaW4gYWRkaXRpb25hbCBtZW1iZXJzLCBzZWUgdGhlXG4gICAgICoge0BsaW5rIElDQUwuUmVjdXJFeHBhbnNpb24gY29uc3RydWN0b3J9IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqICAgICAgICBSZWN1cnJlbmNlIGV4cGFuc2lvbiBvcHRpb25zXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWV9IG9wdGlvbnMuZHRzdGFydFxuICAgICAqICAgICAgICBTdGFydCB0aW1lIG9mIHRoZSBldmVudFxuICAgICAqIEBwYXJhbSB7SUNBTC5Db21wb25lbnQ9fSBvcHRpb25zLmNvbXBvbmVudFxuICAgICAqICAgICAgICBDb21wb25lbnQgZm9yIGV4cGFuc2lvbiwgcmVxdWlyZWQgaWYgbm90IHJlc3VtaW5nLlxuICAgICAqL1xuICAgIGZyb21EYXRhOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgc3RhcnQgPSBJQ0FMLmhlbHBlcnMuZm9ybWF0Q2xhc3NUeXBlKG9wdGlvbnMuZHRzdGFydCwgSUNBTC5UaW1lKTtcblxuICAgICAgaWYgKCFzdGFydCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJy5kdHN0YXJ0IChJQ0FMLlRpbWUpIG11c3QgYmUgZ2l2ZW4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZHRzdGFydCA9IHN0YXJ0O1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5jb21wb25lbnQpIHtcbiAgICAgICAgdGhpcy5faW5pdChvcHRpb25zLmNvbXBvbmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxhc3QgPSBmb3JtYXRUaW1lKG9wdGlvbnMubGFzdCkgfHwgc3RhcnQuY2xvbmUoKTtcblxuICAgICAgICBpZiAoIW9wdGlvbnMucnVsZUl0ZXJhdG9ycykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignLnJ1bGVJdGVyYXRvcnMgb3IgLmNvbXBvbmVudCBtdXN0IGJlIGdpdmVuJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJ1bGVJdGVyYXRvcnMgPSBvcHRpb25zLnJ1bGVJdGVyYXRvcnMubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gSUNBTC5oZWxwZXJzLmZvcm1hdENsYXNzVHlwZShpdGVtLCBJQ0FMLlJlY3VySXRlcmF0b3IpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnJ1bGVEYXRlSW5jID0gb3B0aW9ucy5ydWxlRGF0ZUluYztcbiAgICAgICAgdGhpcy5leERhdGVJbmMgPSBvcHRpb25zLmV4RGF0ZUluYztcblxuICAgICAgICBpZiAob3B0aW9ucy5ydWxlRGF0ZXMpIHtcbiAgICAgICAgICB0aGlzLnJ1bGVEYXRlcyA9IG9wdGlvbnMucnVsZURhdGVzLm1hcChmb3JtYXRUaW1lKTtcbiAgICAgICAgICB0aGlzLnJ1bGVEYXRlID0gdGhpcy5ydWxlRGF0ZXNbdGhpcy5ydWxlRGF0ZUluY107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5leERhdGVzKSB7XG4gICAgICAgICAgdGhpcy5leERhdGVzID0gb3B0aW9ucy5leERhdGVzLm1hcChmb3JtYXRUaW1lKTtcbiAgICAgICAgICB0aGlzLmV4RGF0ZSA9IHRoaXMuZXhEYXRlc1t0aGlzLmV4RGF0ZUluY107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mKG9wdGlvbnMuY29tcGxldGUpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUgPSBvcHRpb25zLmNvbXBsZXRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBuZXh0IG9jY3VycmVuY2UgaW4gdGhlIHNlcmllcy5cbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlRpbWV9XG4gICAgICovXG4gICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaXRlcjtcbiAgICAgIHZhciBydWxlT2ZEYXk7XG4gICAgICB2YXIgbmV4dDtcbiAgICAgIHZhciBjb21wYXJlO1xuXG4gICAgICB2YXIgbWF4VHJpZXMgPSA1MDA7XG4gICAgICB2YXIgY3VycmVudFRyeSA9IDA7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmIChjdXJyZW50VHJ5KysgPiBtYXhUcmllcykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdtYXggdHJpZXMgaGF2ZSBvY2N1cmVkLCBydWxlIG1heSBiZSBpbXBvc3NpYmxlIHRvIGZvcmZpbGwuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0ID0gdGhpcy5ydWxlRGF0ZTtcbiAgICAgICAgaXRlciA9IHRoaXMuX25leHRSZWN1cnJlbmNlSXRlcih0aGlzLmxhc3QpO1xuXG4gICAgICAgIC8vIG5vIG1vcmUgbWF0Y2hlc1xuICAgICAgICAvLyBiZWNhdXNlIHdlIGluY3JlbWVudCB0aGUgcnVsZSBkYXkgb3IgcnVsZVxuICAgICAgICAvLyBfYWZ0ZXJfIHdlIGNob29zZSBhIHZhbHVlIHRoaXMgc2hvdWxkIGJlXG4gICAgICAgIC8vIHRoZSBvbmx5IHNwb3Qgd2hlcmUgd2UgbmVlZCB0byB3b3JyeSBhYm91dCB0aGVcbiAgICAgICAgLy8gZW5kIG9mIGV2ZW50cy5cbiAgICAgICAgaWYgKCFuZXh0ICYmICFpdGVyKSB7XG4gICAgICAgICAgLy8gdGhlcmUgYXJlIG5vIG1vcmUgaXRlcmF0b3JzIG9yIHJkYXRlc1xuICAgICAgICAgIHRoaXMuY29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm8gbmV4dCBydWxlIGRheSBvciByZWN1cnJlbmNlIHJ1bGUgaXMgZmlyc3QuXG4gICAgICAgIGlmICghbmV4dCB8fCAoaXRlciAmJiBuZXh0LmNvbXBhcmUoaXRlci5sYXN0KSA+IDApKSB7XG4gICAgICAgICAgLy8gbXVzdCBiZSBjbG9uZWQsIHJlY3VyIHdpbGwgcmV1c2UgdGhlIHRpbWUgZWxlbWVudC5cbiAgICAgICAgICBuZXh0ID0gaXRlci5sYXN0LmNsb25lKCk7XG4gICAgICAgICAgLy8gbW92ZSB0byBuZXh0IHNvIHdlIGNhbiBjb250aW51ZVxuICAgICAgICAgIGl0ZXIubmV4dCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlIHJ1bGVEYXRlIGlzIHN0aWxsIG5leHQgaW5jcmVtZW50IGl0LlxuICAgICAgICBpZiAodGhpcy5ydWxlRGF0ZSA9PT0gbmV4dCkge1xuICAgICAgICAgIHRoaXMuX25leHRSdWxlRGF5KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxhc3QgPSBuZXh0O1xuXG4gICAgICAgIC8vIGNoZWNrIHRoZSBuZWdhdGl2ZSBydWxlc1xuICAgICAgICBpZiAodGhpcy5leERhdGUpIHtcbiAgICAgICAgICBjb21wYXJlID0gdGhpcy5leERhdGUuY29tcGFyZSh0aGlzLmxhc3QpO1xuXG4gICAgICAgICAgaWYgKGNvbXBhcmUgPCAwKSB7XG4gICAgICAgICAgICB0aGlzLl9uZXh0RXhEYXkoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBpZiB0aGUgY3VycmVudCBydWxlIGlzIGV4Y2x1ZGVkIHNraXAgaXQuXG4gICAgICAgICAgaWYgKGNvbXBhcmUgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX25leHRFeERheSgpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9YWFg6IFRoZSBzcGVjIHN0YXRlcyB0aGF0IGFmdGVyIHdlIHJlc29sdmUgdGhlIGZpbmFsXG4gICAgICAgIC8vICAgICBsaXN0IG9mIGRhdGVzIHdlIGV4ZWN1dGUgZXhkYXRlIHRoaXMgc2VlbXMgc29tZXdoYXQgY291bnRlclxuICAgICAgICAvLyAgICAgaW50dWl0aXZlIHRvIHdoYXQgSSBoYXZlIHNlZW4gbW9zdCBzZXJ2ZXJzIGRvIHNvIGZvciBub3dcbiAgICAgICAgLy8gICAgIEkgZXhjbHVkZSBiYXNlZCBvbiB0aGUgb3JpZ2luYWwgZGF0ZSBub3QgdGhlIG9uZSB0aGF0IG1heVxuICAgICAgICAvLyAgICAgaGF2ZSBiZWVuIG1vZGlmaWVkIGJ5IHRoZSBleGNlcHRpb24uXG4gICAgICAgIHJldHVybiB0aGlzLmxhc3Q7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIG9iamVjdCBpbnRvIGEgc2VyaWFsaXplLWFibGUgZm9ybWF0LiBUaGlzIGZvcm1hdCBjYW4gYmUgcGFzc2VkXG4gICAgICogYmFjayBpbnRvIHRoZSBleHBhbnNpb24gdG8gcmVzdW1lIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmN0aW9uIHRvSlNPTihpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtLnRvSlNPTigpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHJlc3VsdC5ydWxlSXRlcmF0b3JzID0gdGhpcy5ydWxlSXRlcmF0b3JzLm1hcCh0b0pTT04pO1xuXG4gICAgICBpZiAodGhpcy5ydWxlRGF0ZXMpIHtcbiAgICAgICAgcmVzdWx0LnJ1bGVEYXRlcyA9IHRoaXMucnVsZURhdGVzLm1hcCh0b0pTT04pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5leERhdGVzKSB7XG4gICAgICAgIHJlc3VsdC5leERhdGVzID0gdGhpcy5leERhdGVzLm1hcCh0b0pTT04pO1xuICAgICAgfVxuXG4gICAgICByZXN1bHQucnVsZURhdGVJbmMgPSB0aGlzLnJ1bGVEYXRlSW5jO1xuICAgICAgcmVzdWx0LmV4RGF0ZUluYyA9IHRoaXMuZXhEYXRlSW5jO1xuICAgICAgcmVzdWx0Lmxhc3QgPSB0aGlzLmxhc3QudG9KU09OKCk7XG4gICAgICByZXN1bHQuZHRzdGFydCA9IHRoaXMuZHRzdGFydC50b0pTT04oKTtcbiAgICAgIHJlc3VsdC5jb21wbGV0ZSA9IHRoaXMuY29tcGxldGU7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3QgYWxsIGRhdGVzIGZyb20gdGhlIHByb3BlcnRpZXMgaW4gdGhlIGdpdmVuIGNvbXBvbmVudC4gVGhlXG4gICAgICogcHJvcGVydGllcyB3aWxsIGJlIGZpbHRlcmVkIGJ5IHRoZSBwcm9wZXJ0eSBuYW1lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0lDQUwuQ29tcG9uZW50fSBjb21wb25lbnQgICAgICAgIFRoZSBjb21wb25lbnQgdG8gc2VhcmNoIGluXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5TmFtZSAgICAgICAgICAgICBUaGUgcHJvcGVydHkgbmFtZSB0byBzZWFyY2ggZm9yXG4gICAgICogQHJldHVybiB7SUNBTC5UaW1lW119ICAgICAgICAgICAgICAgICAgICBUaGUgZXh0cmFjdGVkIGRhdGVzLlxuICAgICAqL1xuICAgIF9leHRyYWN0RGF0ZXM6IGZ1bmN0aW9uKGNvbXBvbmVudCwgcHJvcGVydHlOYW1lKSB7XG4gICAgICBmdW5jdGlvbiBoYW5kbGVQcm9wKHByb3ApIHtcbiAgICAgICAgaWR4ID0gSUNBTC5oZWxwZXJzLmJpbnNlYXJjaEluc2VydChcbiAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgcHJvcCxcbiAgICAgICAgICBjb21wYXJlVGltZVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIG9yZGVyZWQgaW5zZXJ0XG4gICAgICAgIHJlc3VsdC5zcGxpY2UoaWR4LCAwLCBwcm9wKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgdmFyIHByb3BzID0gY29tcG9uZW50LmdldEFsbFByb3BlcnRpZXMocHJvcGVydHlOYW1lKTtcbiAgICAgIHZhciBsZW4gPSBwcm9wcy5sZW5ndGg7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgcHJvcDtcblxuICAgICAgdmFyIGlkeDtcblxuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBwcm9wc1tpXS5nZXRWYWx1ZXMoKS5mb3JFYWNoKGhhbmRsZVByb3ApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHRoZSByZWN1cnJlbmNlIGV4cGFuc2lvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtJQ0FMLkNvbXBvbmVudH0gY29tcG9uZW50ICAgIFRoZSBjb21wb25lbnQgdG8gaW5pdGlhbGl6ZSBmcm9tLlxuICAgICAqL1xuICAgIF9pbml0OiBmdW5jdGlvbihjb21wb25lbnQpIHtcbiAgICAgIHRoaXMucnVsZUl0ZXJhdG9ycyA9IFtdO1xuXG4gICAgICB0aGlzLmxhc3QgPSB0aGlzLmR0c3RhcnQuY2xvbmUoKTtcblxuICAgICAgLy8gdG8gcHJvdmlkZSBhcGkgY29uc2lzdGVuY3kgbm9uLXJlY3VycmluZ1xuICAgICAgLy8gZXZlbnRzIGNhbiBhbHNvIHVzZSB0aGUgaXRlcmF0b3IgdGhvdWdoIGl0IHdpbGxcbiAgICAgIC8vIG9ubHkgcmV0dXJuIGEgc2luZ2xlIHRpbWUuXG4gICAgICBpZiAoIWlzUmVjdXJyaW5nQ29tcG9uZW50KGNvbXBvbmVudCkpIHtcbiAgICAgICAgdGhpcy5ydWxlRGF0ZSA9IHRoaXMubGFzdC5jbG9uZSgpO1xuICAgICAgICB0aGlzLmNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29tcG9uZW50Lmhhc1Byb3BlcnR5KCdyZGF0ZScpKSB7XG4gICAgICAgIHRoaXMucnVsZURhdGVzID0gdGhpcy5fZXh0cmFjdERhdGVzKGNvbXBvbmVudCwgJ3JkYXRlJyk7XG5cbiAgICAgICAgLy8gc3BlY2lhbCBoYWNrIGZvciBjYXNlcyB3aGVyZSBmaXJzdCByZGF0ZSBpcyBwcmlvclxuICAgICAgICAvLyB0byB0aGUgc3RhcnQgZGF0ZS4gV2Ugb25seSBjaGVjayBmb3IgdGhlIGZpcnN0IHJkYXRlLlxuICAgICAgICAvLyBUaGlzIGlzIG1vc3RseSBmb3IgZ29vZ2xlJ3MgY3JhenkgcmVjdXJyaW5nIGRhdGUgbG9naWNcbiAgICAgICAgLy8gKGNvbnRhY3RzIGJpcnRoZGF5cykuXG4gICAgICAgIGlmICgodGhpcy5ydWxlRGF0ZXNbMF0pICYmXG4gICAgICAgICAgICAodGhpcy5ydWxlRGF0ZXNbMF0uY29tcGFyZSh0aGlzLmR0c3RhcnQpIDwgMCkpIHtcblxuICAgICAgICAgIHRoaXMucnVsZURhdGVJbmMgPSAwO1xuICAgICAgICAgIHRoaXMubGFzdCA9IHRoaXMucnVsZURhdGVzWzBdLmNsb25lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5ydWxlRGF0ZUluYyA9IElDQUwuaGVscGVycy5iaW5zZWFyY2hJbnNlcnQoXG4gICAgICAgICAgICB0aGlzLnJ1bGVEYXRlcyxcbiAgICAgICAgICAgIHRoaXMubGFzdCxcbiAgICAgICAgICAgIGNvbXBhcmVUaW1lXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucnVsZURhdGUgPSB0aGlzLnJ1bGVEYXRlc1t0aGlzLnJ1bGVEYXRlSW5jXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbXBvbmVudC5oYXNQcm9wZXJ0eSgncnJ1bGUnKSkge1xuICAgICAgICB2YXIgcnVsZXMgPSBjb21wb25lbnQuZ2V0QWxsUHJvcGVydGllcygncnJ1bGUnKTtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGVuID0gcnVsZXMubGVuZ3RoO1xuXG4gICAgICAgIHZhciBydWxlO1xuICAgICAgICB2YXIgaXRlcjtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgcnVsZSA9IHJ1bGVzW2ldLmdldEZpcnN0VmFsdWUoKTtcbiAgICAgICAgICBpdGVyID0gcnVsZS5pdGVyYXRvcih0aGlzLmR0c3RhcnQpO1xuICAgICAgICAgIHRoaXMucnVsZUl0ZXJhdG9ycy5wdXNoKGl0ZXIpO1xuXG4gICAgICAgICAgLy8gaW5jcmVtZW50IHRvIHRoZSBuZXh0IG9jY3VycmVuY2Ugc28gZnV0dXJlXG4gICAgICAgICAgLy8gY2FsbHMgdG8gbmV4dCByZXR1cm4gdGltZXMgYmV5b25kIHRoZSBpbml0aWFsIGl0ZXJhdGlvbi5cbiAgICAgICAgICAvLyBYWFg6IEkgZmluZCB0aGlzIHN1c3BpY2lvdXMgbWlnaHQgYmUgYSBidWc/XG4gICAgICAgICAgaXRlci5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNvbXBvbmVudC5oYXNQcm9wZXJ0eSgnZXhkYXRlJykpIHtcbiAgICAgICAgdGhpcy5leERhdGVzID0gdGhpcy5fZXh0cmFjdERhdGVzKGNvbXBvbmVudCwgJ2V4ZGF0ZScpO1xuICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgLmxhc3QgZGF5IHdlIGluY3JlbWVudCB0aGUgaW5kZXggdG8gYmV5b25kIGl0LlxuICAgICAgICB0aGlzLmV4RGF0ZUluYyA9IElDQUwuaGVscGVycy5iaW5zZWFyY2hJbnNlcnQoXG4gICAgICAgICAgdGhpcy5leERhdGVzLFxuICAgICAgICAgIHRoaXMubGFzdCxcbiAgICAgICAgICBjb21wYXJlVGltZVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuZXhEYXRlID0gdGhpcy5leERhdGVzW3RoaXMuZXhEYXRlSW5jXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWR2YW5jZSB0byB0aGUgbmV4dCBleGRhdGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9uZXh0RXhEYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5leERhdGUgPSB0aGlzLmV4RGF0ZXNbKyt0aGlzLmV4RGF0ZUluY107XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkdmFuY2UgdG8gdGhlIG5leHQgcnVsZSBkYXRlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbmV4dFJ1bGVEYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5ydWxlRGF0ZSA9IHRoaXMucnVsZURhdGVzWysrdGhpcy5ydWxlRGF0ZUluY107XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgYW5kIHJldHVybiB0aGUgcmVjdXJyZW5jZSBydWxlIHdpdGggdGhlIG1vc3QgcmVjZW50IGV2ZW50IGFuZFxuICAgICAqIHJldHVybiBpdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7P0lDQUwuUmVjdXJJdGVyYXRvcn0gICAgRm91bmQgaXRlcmF0b3IuXG4gICAgICovXG4gICAgX25leHRSZWN1cnJlbmNlSXRlcjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaXRlcnMgPSB0aGlzLnJ1bGVJdGVyYXRvcnM7XG5cbiAgICAgIGlmIChpdGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZW4gPSBpdGVycy5sZW5ndGg7XG4gICAgICB2YXIgaXRlcjtcbiAgICAgIHZhciBpdGVyVGltZTtcbiAgICAgIHZhciBpdGVySWR4ID0gMDtcbiAgICAgIHZhciBjaG9zZW5JdGVyO1xuXG4gICAgICAvLyBsb29wIHRocm91Z2ggZWFjaCBpdGVyYXRvclxuICAgICAgZm9yICg7IGl0ZXJJZHggPCBsZW47IGl0ZXJJZHgrKykge1xuICAgICAgICBpdGVyID0gaXRlcnNbaXRlcklkeF07XG4gICAgICAgIGl0ZXJUaW1lID0gaXRlci5sYXN0O1xuXG4gICAgICAgIC8vIGlmIGl0ZXJhdGlvbiBpcyBjb21wbGV0ZVxuICAgICAgICAvLyB0aGVuIHdlIG11c3QgZXhjbHVkZSBpdCBmcm9tXG4gICAgICAgIC8vIHRoZSBzZWFyY2ggYW5kIHJlbW92ZSBpdC5cbiAgICAgICAgaWYgKGl0ZXIuY29tcGxldGVkKSB7XG4gICAgICAgICAgbGVuLS07XG4gICAgICAgICAgaWYgKGl0ZXJJZHggIT09IDApIHtcbiAgICAgICAgICAgIGl0ZXJJZHgtLTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaXRlcnMuc3BsaWNlKGl0ZXJJZHgsIDEpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluZCB0aGUgbW9zdCByZWNlbnQgcG9zc2libGUgY2hvaWNlXG4gICAgICAgIGlmICghY2hvc2VuSXRlciB8fCBjaG9zZW5JdGVyLmxhc3QuY29tcGFyZShpdGVyVGltZSkgPiAwKSB7XG4gICAgICAgICAgLy8gdGhhdCBpdGVyYXRvciBpcyBzYXZlZFxuICAgICAgICAgIGNob3Nlbkl0ZXIgPSBpdGVyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHRoZSBjaG9zZW4gaXRlcmF0b3IgaXMgcmV0dXJuZWQgYnV0IG5vdCBtdXRhdGVkXG4gICAgICAvLyB0aGlzIGl0ZXJhdG9yIGNvbnRhaW5zIHRoZSBtb3N0IHJlY2VudCBldmVudC5cbiAgICAgIHJldHVybiBjaG9zZW5JdGVyO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gUmVjdXJFeHBhbnNpb247XG59KCkpO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoLCAyMDExLTIwMTUgKi9cblxuXG4vKipcbiAqIFRoaXMgc3ltYm9sIGlzIGZ1cnRoZXIgZGVzY3JpYmVkIGxhdGVyIG9uXG4gKiBAaWdub3JlXG4gKi9cbklDQUwuRXZlbnQgPSAoZnVuY3Rpb24oKSB7XG5cbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogSUNBTC5qcyBpcyBvcmdhbml6ZWQgaW50byBtdWx0aXBsZSBsYXllcnMuIFRoZSBib3R0b20gbGF5ZXIgaXMgYSByYXcgakNhbFxuICAgKiBvYmplY3QsIGZvbGxvd2VkIGJ5IHRoZSBjb21wb25lbnQvcHJvcGVydHkgbGF5ZXIuIFRoZSBoaWdoZXN0IGxldmVsIGlzIHRoZVxuICAgKiBldmVudCByZXByZXNlbnRhdGlvbiwgd2hpY2ggdGhpcyBjbGFzcyBpcyBwYXJ0IG9mLiBTZWUgdGhlXG4gICAqIHtAdHV0b3JpYWwgbGF5ZXJzfSBndWlkZSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQGFsaWFzIElDQUwuRXZlbnRcbiAgICogQHBhcmFtIHtJQ0FMLkNvbXBvbmVudD19IGNvbXBvbmVudCAgICAgICAgIFRoZSBJQ0FMLkNvbXBvbmVudCB0byBiYXNlIHRoaXMgZXZlbnQgb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgICAgICAgICAgICAgICAgICAgIE9wdGlvbnMgZm9yIHRoaXMgZXZlbnRcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLnN0cmljdEV4Y2VwdGlvbnNcbiAgICogICAgICAgICAgV2hlbiB0cnVlLCB3aWxsIHZlcmlmeSBleGNlcHRpb25zIGFyZSByZWxhdGVkIGJ5IHRoZWlyIFVVSURcbiAgICogQHBhcmFtIHtBcnJheTxJQ0FMLkNvbXBvbmVudHxJQ0FMLkV2ZW50Pn0gb3B0aW9ucy5leGNlcHRpb25zXG4gICAqICAgICAgICAgIEV4Y2VwdGlvbnMgdG8gdGhpcyBldmVudCwgZWl0aGVyIGFzIGNvbXBvbmVudHMgb3IgZXZlbnRzLiBJZiBub3RcbiAgICogICAgICAgICAgICBzcGVjaWZpZWQgZXhjZXB0aW9ucyB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgc2V0IGluIHJlbGF0aW9uIG9mXG4gICAqICAgICAgICAgICAgY29tcG9uZW50J3MgcGFyZW50XG4gICAqL1xuICBmdW5jdGlvbiBFdmVudChjb21wb25lbnQsIG9wdGlvbnMpIHtcbiAgICBpZiAoIShjb21wb25lbnQgaW5zdGFuY2VvZiBJQ0FMLkNvbXBvbmVudCkpIHtcbiAgICAgIG9wdGlvbnMgPSBjb21wb25lbnQ7XG4gICAgICBjb21wb25lbnQgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbXBvbmVudCA9IG5ldyBJQ0FMLkNvbXBvbmVudCgndmV2ZW50Jyk7XG4gICAgfVxuXG4gICAgdGhpcy5fcmFuZ2VFeGNlcHRpb25DYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5leGNlcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLnJhbmdlRXhjZXB0aW9ucyA9IFtdO1xuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zdHJpY3RFeGNlcHRpb25zKSB7XG4gICAgICB0aGlzLnN0cmljdEV4Y2VwdGlvbnMgPSBvcHRpb25zLnN0cmljdEV4Y2VwdGlvbnM7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5leGNlcHRpb25zKSB7XG4gICAgICBvcHRpb25zLmV4Y2VwdGlvbnMuZm9yRWFjaCh0aGlzLnJlbGF0ZUV4Y2VwdGlvbiwgdGhpcyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmNvbXBvbmVudC5wYXJlbnQgJiYgIXRoaXMuaXNSZWN1cnJlbmNlRXhjZXB0aW9uKCkpIHtcbiAgICAgIHRoaXMuY29tcG9uZW50LnBhcmVudC5nZXRBbGxTdWJjb21wb25lbnRzKCd2ZXZlbnQnKS5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5oYXNQcm9wZXJ0eSgncmVjdXJyZW5jZS1pZCcpKSB7XG4gICAgICAgICAgdGhpcy5yZWxhdGVFeGNlcHRpb24oZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG4gIH1cblxuICBFdmVudC5wcm90b3R5cGUgPSB7XG5cbiAgICBUSElTQU5ERlVUVVJFOiAnVEhJU0FOREZVVFVSRScsXG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIHJlbGF0ZWQgZXZlbnQgZXhjZXB0aW9ucy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtJQ0FMLkV2ZW50W119XG4gICAgICovXG4gICAgZXhjZXB0aW9uczogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgd2lsbCB2ZXJpZnkgZXhjZXB0aW9ucyBhcmUgcmVsYXRlZCBieSB0aGVpciBVVUlELlxuICAgICAqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3RyaWN0RXhjZXB0aW9uczogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBSZWxhdGVzIGEgZ2l2ZW4gZXZlbnQgZXhjZXB0aW9uIHRvIHRoaXMgb2JqZWN0LiAgSWYgdGhlIGdpdmVuIGNvbXBvbmVudFxuICAgICAqIGRvZXMgbm90IHNoYXJlIHRoZSBVSUQgb2YgdGhpcyBldmVudCBpdCBjYW5ub3QgYmUgcmVsYXRlZCBhbmQgd2lsbCB0aHJvd1xuICAgICAqIGFuIGV4Y2VwdGlvbi5cbiAgICAgKlxuICAgICAqIElmIHRoaXMgY29tcG9uZW50IGlzIGFuIGV4Y2VwdGlvbiBpdCBjYW5ub3QgaGF2ZSBvdGhlciBleGNlcHRpb25zXG4gICAgICogcmVsYXRlZCB0byBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SUNBTC5Db21wb25lbnR8SUNBTC5FdmVudH0gb2JqICAgICAgIENvbXBvbmVudCBvciBldmVudFxuICAgICAqL1xuICAgIHJlbGF0ZUV4Y2VwdGlvbjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICBpZiAodGhpcy5pc1JlY3VycmVuY2VFeGNlcHRpb24oKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCByZWxhdGUgZXhjZXB0aW9uIHRvIGV4Y2VwdGlvbnMnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIElDQUwuQ29tcG9uZW50KSB7XG4gICAgICAgIG9iaiA9IG5ldyBJQ0FMLkV2ZW50KG9iaik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnN0cmljdEV4Y2VwdGlvbnMgJiYgb2JqLnVpZCAhPT0gdGhpcy51aWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhdHRlbXB0ZWQgdG8gcmVsYXRlIHVucmVsYXRlZCBleGNlcHRpb24nKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlkID0gb2JqLnJlY3VycmVuY2VJZC50b1N0cmluZygpO1xuXG4gICAgICAvLyB3ZSBkb24ndCBzb3J0IG9yIG1hbmFnZSBleGNlcHRpb25zIGRpcmVjdGx5XG4gICAgICAvLyBoZXJlIHRoZSByZWN1cnJlbmNlIGV4cGFuZGVyIGhhbmRsZXMgdGhhdC5cbiAgICAgIHRoaXMuZXhjZXB0aW9uc1tpZF0gPSBvYmo7XG5cbiAgICAgIC8vIGluZGV4IFJBTkdFPVRISVNBTkRGVVRVUkUgZXhjZXB0aW9ucyBzbyB3ZSBjYW5cbiAgICAgIC8vIGxvb2sgdGhlbSB1cCBsYXRlciBpbiBnZXRPY2N1cnJlbmNlRGV0YWlscy5cbiAgICAgIGlmIChvYmoubW9kaWZpZXNGdXR1cmUoKSkge1xuICAgICAgICB2YXIgaXRlbSA9IFtcbiAgICAgICAgICBvYmoucmVjdXJyZW5jZUlkLnRvVW5peFRpbWUoKSwgaWRcbiAgICAgICAgXTtcblxuICAgICAgICAvLyB3ZSBrZWVwIHRoZW0gc29ydGVkIHNvIHdlIGNhbiBmaW5kIHRoZSBuZWFyZXN0XG4gICAgICAgIC8vIHZhbHVlIGxhdGVyIG9uLi4uXG4gICAgICAgIHZhciBpZHggPSBJQ0FMLmhlbHBlcnMuYmluc2VhcmNoSW5zZXJ0KFxuICAgICAgICAgIHRoaXMucmFuZ2VFeGNlcHRpb25zLFxuICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgY29tcGFyZVJhbmdlRXhjZXB0aW9uXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5yYW5nZUV4Y2VwdGlvbnMuc3BsaWNlKGlkeCwgMCwgaXRlbSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGlzIHJlY29yZCBpcyBhbiBleGNlcHRpb24gYW5kIGhhcyB0aGUgUkFOR0U9VEhJU0FOREZVVFVSRVxuICAgICAqIHZhbHVlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgIFRydWUsIHdoZW4gZXhjZXB0aW9uIGlzIHdpdGhpbiByYW5nZVxuICAgICAqL1xuICAgIG1vZGlmaWVzRnV0dXJlOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5jb21wb25lbnQuaGFzUHJvcGVydHkoJ3JlY3VycmVuY2UtaWQnKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciByYW5nZSA9IHRoaXMuY29tcG9uZW50LmdldEZpcnN0UHJvcGVydHkoJ3JlY3VycmVuY2UtaWQnKS5nZXRQYXJhbWV0ZXIoJ3JhbmdlJyk7XG4gICAgICByZXR1cm4gcmFuZ2UgPT09IHRoaXMuVEhJU0FOREZVVFVSRTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIHJhbmdlIGV4Y2VwdGlvbiBuZWFyZXN0IHRvIHRoZSBnaXZlbiBkYXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWV9IHRpbWUgdXN1YWxseSBhbiBvY2N1cnJlbmNlIHRpbWUgb2YgYW4gZXZlbnRcbiAgICAgKiBAcmV0dXJuIHs/SUNBTC5FdmVudH0gdGhlIHJlbGF0ZWQgZXZlbnQvZXhjZXB0aW9uIG9yIG51bGxcbiAgICAgKi9cbiAgICBmaW5kUmFuZ2VFeGNlcHRpb246IGZ1bmN0aW9uKHRpbWUpIHtcbiAgICAgIGlmICghdGhpcy5yYW5nZUV4Y2VwdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgdXRjID0gdGltZS50b1VuaXhUaW1lKCk7XG4gICAgICB2YXIgaWR4ID0gSUNBTC5oZWxwZXJzLmJpbnNlYXJjaEluc2VydChcbiAgICAgICAgdGhpcy5yYW5nZUV4Y2VwdGlvbnMsXG4gICAgICAgIFt1dGNdLFxuICAgICAgICBjb21wYXJlUmFuZ2VFeGNlcHRpb25cbiAgICAgICk7XG5cbiAgICAgIGlkeCAtPSAxO1xuXG4gICAgICAvLyBvY2N1cnMgYmVmb3JlXG4gICAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJhbmdlSXRlbSA9IHRoaXMucmFuZ2VFeGNlcHRpb25zW2lkeF07XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBzYW5pdHkgY2hlY2sgb25seSAqL1xuICAgICAgaWYgKHV0YyA8IHJhbmdlSXRlbVswXSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJhbmdlSXRlbVsxXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBvYmplY3QgaXMgcmV0dXJuZWQgYnkge0BsaW5rIElDQUwuRXZlbnQjZ2V0T2NjdXJyZW5jZURldGFpbHMgZ2V0T2NjdXJyZW5jZURldGFpbHN9XG4gICAgICpcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBvY2N1cnJlbmNlRGV0YWlsc1xuICAgICAqIEBtZW1iZXJvZiBJQ0FMLkV2ZW50XG4gICAgICogQHByb3BlcnR5IHtJQ0FMLlRpbWV9IHJlY3VycmVuY2VJZCAgICAgICBUaGUgcGFzc2VkIGluIHJlY3VycmVuY2UgaWRcbiAgICAgKiBAcHJvcGVydHkge0lDQUwuRXZlbnR9IGl0ZW0gICAgICAgICAgICAgIFRoZSBvY2N1cnJlbmNlXG4gICAgICogQHByb3BlcnR5IHtJQ0FMLlRpbWV9IHN0YXJ0RGF0ZSAgICAgICAgICBUaGUgc3RhcnQgb2YgdGhlIG9jY3VycmVuY2VcbiAgICAgKiBAcHJvcGVydHkge0lDQUwuVGltZX0gZW5kRGF0ZSAgICAgICAgICAgIFRoZSBlbmQgb2YgdGhlIG9jY3VycmVuY2VcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG9jY3VycmVuY2UgZGV0YWlscyBiYXNlZCBvbiBpdHMgc3RhcnQgdGltZS4gIElmIHRoZVxuICAgICAqIG9jY3VycmVuY2UgaGFzIGFuIGV4Y2VwdGlvbiB3aWxsIHJldHVybiB0aGUgZGV0YWlscyBmb3IgdGhhdCBleGNlcHRpb24uXG4gICAgICpcbiAgICAgKiBOT1RFOiB0aGlzIG1ldGhvZCBpcyBpbnRlbmQgdG8gYmUgdXNlZCBpbiBjb25qdW5jdGlvblxuICAgICAqICAgICAgIHdpdGggdGhlIHtAbGluayBJQ0FMLkV2ZW50I2l0ZXJhdG9yIGl0ZXJhdG9yfSBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZX0gb2NjdXJyZW5jZSB0aW1lIG9jY3VycmVuY2VcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLkV2ZW50Lm9jY3VycmVuY2VEZXRhaWxzfSBJbmZvcm1hdGlvbiBhYm91dCB0aGUgb2NjdXJyZW5jZVxuICAgICAqL1xuICAgIGdldE9jY3VycmVuY2VEZXRhaWxzOiBmdW5jdGlvbihvY2N1cnJlbmNlKSB7XG4gICAgICB2YXIgaWQgPSBvY2N1cnJlbmNlLnRvU3RyaW5nKCk7XG4gICAgICB2YXIgdXRjSWQgPSBvY2N1cnJlbmNlLmNvbnZlcnRUb1pvbmUoSUNBTC5UaW1lem9uZS51dGNUaW1lem9uZSkudG9TdHJpbmcoKTtcbiAgICAgIHZhciBpdGVtO1xuICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgLy9YWFg6IENsb25lP1xuICAgICAgICByZWN1cnJlbmNlSWQ6IG9jY3VycmVuY2VcbiAgICAgIH07XG5cbiAgICAgIGlmIChpZCBpbiB0aGlzLmV4Y2VwdGlvbnMpIHtcbiAgICAgICAgaXRlbSA9IHJlc3VsdC5pdGVtID0gdGhpcy5leGNlcHRpb25zW2lkXTtcbiAgICAgICAgcmVzdWx0LnN0YXJ0RGF0ZSA9IGl0ZW0uc3RhcnREYXRlO1xuICAgICAgICByZXN1bHQuZW5kRGF0ZSA9IGl0ZW0uZW5kRGF0ZTtcbiAgICAgICAgcmVzdWx0Lml0ZW0gPSBpdGVtO1xuICAgICAgfSBlbHNlIGlmICh1dGNJZCBpbiB0aGlzLmV4Y2VwdGlvbnMpIHtcbiAgICAgICAgaXRlbSA9IHRoaXMuZXhjZXB0aW9uc1t1dGNJZF07XG4gICAgICAgIHJlc3VsdC5zdGFydERhdGUgPSBpdGVtLnN0YXJ0RGF0ZTtcbiAgICAgICAgcmVzdWx0LmVuZERhdGUgPSBpdGVtLmVuZERhdGU7XG4gICAgICAgIHJlc3VsdC5pdGVtID0gaXRlbTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJhbmdlIGV4Y2VwdGlvbnMgKFJBTkdFPVRISVNBTkRGVVRVUkUpIGhhdmUgYVxuICAgICAgICAvLyBsb3dlciBwcmlvcml0eSB0aGVuIGRpcmVjdCBleGNlcHRpb25zIGJ1dFxuICAgICAgICAvLyBtdXN0IGJlIGFjY291bnRlZCBmb3IgZmlyc3QuIFRoZWlyIGl0ZW0gaXNcbiAgICAgICAgLy8gYWx3YXlzIHRoZSBmaXJzdCBleGNlcHRpb24gd2l0aCB0aGUgcmFuZ2UgcHJvcC5cbiAgICAgICAgdmFyIHJhbmdlRXhjZXB0aW9uSWQgPSB0aGlzLmZpbmRSYW5nZUV4Y2VwdGlvbihcbiAgICAgICAgICBvY2N1cnJlbmNlXG4gICAgICAgICk7XG4gICAgICAgIHZhciBlbmQ7XG5cbiAgICAgICAgaWYgKHJhbmdlRXhjZXB0aW9uSWQpIHtcbiAgICAgICAgICB2YXIgZXhjZXB0aW9uID0gdGhpcy5leGNlcHRpb25zW3JhbmdlRXhjZXB0aW9uSWRdO1xuXG4gICAgICAgICAgLy8gcmFuZ2UgZXhjZXB0aW9uIG11c3QgbW9kaWZ5IHN0YW5kYXJkIHRpbWVcbiAgICAgICAgICAvLyBieSB0aGUgZGlmZmVyZW5jZSAoaWYgYW55KSBpbiBzdGFydC9lbmQgdGltZXMuXG4gICAgICAgICAgcmVzdWx0Lml0ZW0gPSBleGNlcHRpb247XG5cbiAgICAgICAgICB2YXIgc3RhcnREaWZmID0gdGhpcy5fcmFuZ2VFeGNlcHRpb25DYWNoZVtyYW5nZUV4Y2VwdGlvbklkXTtcblxuICAgICAgICAgIGlmICghc3RhcnREaWZmKSB7XG4gICAgICAgICAgICB2YXIgb3JpZ2luYWwgPSBleGNlcHRpb24ucmVjdXJyZW5jZUlkLmNsb25lKCk7XG4gICAgICAgICAgICB2YXIgbmV3U3RhcnQgPSBleGNlcHRpb24uc3RhcnREYXRlLmNsb25lKCk7XG5cbiAgICAgICAgICAgIC8vIHpvbmVzIG11c3QgYmUgc2FtZSBvdGhlcndpc2Ugc3VidHJhY3QgbWF5IGJlIGluY29ycmVjdC5cbiAgICAgICAgICAgIG9yaWdpbmFsLnpvbmUgPSBuZXdTdGFydC56b25lO1xuICAgICAgICAgICAgc3RhcnREaWZmID0gbmV3U3RhcnQuc3VidHJhY3REYXRlKG9yaWdpbmFsKTtcblxuICAgICAgICAgICAgdGhpcy5fcmFuZ2VFeGNlcHRpb25DYWNoZVtyYW5nZUV4Y2VwdGlvbklkXSA9IHN0YXJ0RGlmZjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc3RhcnQgPSBvY2N1cnJlbmNlLmNsb25lKCk7XG4gICAgICAgICAgc3RhcnQuem9uZSA9IGV4Y2VwdGlvbi5zdGFydERhdGUuem9uZTtcbiAgICAgICAgICBzdGFydC5hZGREdXJhdGlvbihzdGFydERpZmYpO1xuXG4gICAgICAgICAgZW5kID0gc3RhcnQuY2xvbmUoKTtcbiAgICAgICAgICBlbmQuYWRkRHVyYXRpb24oZXhjZXB0aW9uLmR1cmF0aW9uKTtcblxuICAgICAgICAgIHJlc3VsdC5zdGFydERhdGUgPSBzdGFydDtcbiAgICAgICAgICByZXN1bHQuZW5kRGF0ZSA9IGVuZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBubyByYW5nZSBleGNlcHRpb24gc3RhbmRhcmQgZXhwYW5zaW9uXG4gICAgICAgICAgZW5kID0gb2NjdXJyZW5jZS5jbG9uZSgpO1xuICAgICAgICAgIGVuZC5hZGREdXJhdGlvbih0aGlzLmR1cmF0aW9uKTtcblxuICAgICAgICAgIHJlc3VsdC5lbmREYXRlID0gZW5kO1xuICAgICAgICAgIHJlc3VsdC5zdGFydERhdGUgPSBvY2N1cnJlbmNlO1xuICAgICAgICAgIHJlc3VsdC5pdGVtID0gdGhpcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgYSByZWN1ciBleHBhbnNpb24gaW5zdGFuY2UgZm9yIGEgc3BlY2lmaWMgcG9pbnQgaW4gdGltZSAoZGVmYXVsdHNcbiAgICAgKiB0byBzdGFydERhdGUpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWV9IHN0YXJ0VGltZSAgICAgU3RhcnRpbmcgcG9pbnQgZm9yIGV4cGFuc2lvblxuICAgICAqIEByZXR1cm4ge0lDQUwuUmVjdXJFeHBhbnNpb259ICAgIEV4cGFuc2lvbiBvYmplY3RcbiAgICAgKi9cbiAgICBpdGVyYXRvcjogZnVuY3Rpb24oc3RhcnRUaW1lKSB7XG4gICAgICByZXR1cm4gbmV3IElDQUwuUmVjdXJFeHBhbnNpb24oe1xuICAgICAgICBjb21wb25lbnQ6IHRoaXMuY29tcG9uZW50LFxuICAgICAgICBkdHN0YXJ0OiBzdGFydFRpbWUgfHwgdGhpcy5zdGFydERhdGVcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGV2ZW50IGlzIHJlY3VycmluZ1xuICAgICAqXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgIFRydWUsIGlmIGV2ZW50IGlzIHJlY3VycmluZ1xuICAgICAqL1xuICAgIGlzUmVjdXJyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjb21wID0gdGhpcy5jb21wb25lbnQ7XG4gICAgICByZXR1cm4gY29tcC5oYXNQcm9wZXJ0eSgncnJ1bGUnKSB8fCBjb21wLmhhc1Byb3BlcnR5KCdyZGF0ZScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGV2ZW50IGRlc2NyaWJlcyBhIHJlY3VycmVuY2UgZXhjZXB0aW9uLiBTZWVcbiAgICAgKiB7QHR1dG9yaWFsIHRlcm1pbm9sb2d5fSBmb3IgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgIFRydWUsIGlmIHRoZSBldmVudCBkZXNjcmliZXMgYSByZWN1cnJlbmNlIGV4Y2VwdGlvblxuICAgICAqL1xuICAgIGlzUmVjdXJyZW5jZUV4Y2VwdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21wb25lbnQuaGFzUHJvcGVydHkoJ3JlY3VycmVuY2UtaWQnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdHlwZXMgb2YgcmVjdXJyZW5jZXMgdGhpcyBldmVudCBtYXkgaGF2ZS5cbiAgICAgKlxuICAgICAqIFJldHVybmVkIGFzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcG9zc2libGUga2V5czpcbiAgICAgKlxuICAgICAqICAgIC0gWUVBUkxZXG4gICAgICogICAgLSBNT05USExZXG4gICAgICogICAgLSBXRUVLTFlcbiAgICAgKiAgICAtIERBSUxZXG4gICAgICogICAgLSBNSU5VVEVMWVxuICAgICAqICAgIC0gU0VDT05ETFlcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge09iamVjdC48SUNBTC5SZWN1ci5mcmVxdWVuY3lWYWx1ZXMsIEJvb2xlYW4+fVxuICAgICAqICAgICAgICAgIE9iamVjdCBvZiByZWN1cnJlbmNlIGZsYWdzXG4gICAgICovXG4gICAgZ2V0UmVjdXJyZW5jZVR5cGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBydWxlcyA9IHRoaXMuY29tcG9uZW50LmdldEFsbFByb3BlcnRpZXMoJ3JydWxlJyk7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgbGVuID0gcnVsZXMubGVuZ3RoO1xuICAgICAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcnVsZXNbaV0uZ2V0Rmlyc3RWYWx1ZSgpO1xuICAgICAgICByZXN1bHRbdmFsdWUuZnJlcV0gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdWlkIG9mIHRoaXMgZXZlbnRcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldCB1aWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmlyc3RQcm9wKCd1aWQnKTtcbiAgICB9LFxuXG4gICAgc2V0IHVpZCh2YWx1ZSkge1xuICAgICAgdGhpcy5fc2V0UHJvcCgndWlkJywgdmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RhcnQgZGF0ZVxuICAgICAqIEB0eXBlIHtJQ0FMLlRpbWV9XG4gICAgICovXG4gICAgZ2V0IHN0YXJ0RGF0ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9maXJzdFByb3AoJ2R0c3RhcnQnKTtcbiAgICB9LFxuXG4gICAgc2V0IHN0YXJ0RGF0ZSh2YWx1ZSkge1xuICAgICAgdGhpcy5fc2V0VGltZSgnZHRzdGFydCcsIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVuZCBkYXRlLiBUaGlzIGNhbiBiZSB0aGUgcmVzdWx0IGRpcmVjdGx5IGZyb20gdGhlIHByb3BlcnR5LCBvciB0aGVcbiAgICAgKiBlbmQgZGF0ZSBjYWxjdWxhdGVkIGZyb20gc3RhcnQgZGF0ZSBhbmQgZHVyYXRpb24uIFNldHRpbmcgdGhlIHByb3BlcnR5XG4gICAgICogd2lsbCByZW1vdmUgYW55IGR1cmF0aW9uIHByb3BlcnRpZXMuXG4gICAgICogQHR5cGUge0lDQUwuVGltZX1cbiAgICAgKi9cbiAgICBnZXQgZW5kRGF0ZSgpIHtcbiAgICAgIHZhciBlbmREYXRlID0gdGhpcy5fZmlyc3RQcm9wKCdkdGVuZCcpO1xuICAgICAgaWYgKCFlbmREYXRlKSB7XG4gICAgICAgICAgdmFyIGR1cmF0aW9uID0gdGhpcy5fZmlyc3RQcm9wKCdkdXJhdGlvbicpO1xuICAgICAgICAgIGVuZERhdGUgPSB0aGlzLnN0YXJ0RGF0ZS5jbG9uZSgpO1xuICAgICAgICAgIGlmIChkdXJhdGlvbikge1xuICAgICAgICAgICAgICBlbmREYXRlLmFkZER1cmF0aW9uKGR1cmF0aW9uKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVuZERhdGUuaXNEYXRlKSB7XG4gICAgICAgICAgICAgIGVuZERhdGUuZGF5ICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGVuZERhdGU7XG4gICAgfSxcblxuICAgIHNldCBlbmREYXRlKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5jb21wb25lbnQuaGFzUHJvcGVydHkoJ2R1cmF0aW9uJykpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnQucmVtb3ZlUHJvcGVydHkoJ2R1cmF0aW9uJyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zZXRUaW1lKCdkdGVuZCcsIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGR1cmF0aW9uLiBUaGlzIGNhbiBiZSB0aGUgcmVzdWx0IGRpcmVjdGx5IGZyb20gdGhlIHByb3BlcnR5LCBvciB0aGVcbiAgICAgKiBkdXJhdGlvbiBjYWxjdWxhdGVkIGZyb20gc3RhcnQgZGF0ZSBhbmQgZW5kIGRhdGUuIFNldHRpbmcgdGhlIHByb3BlcnR5XG4gICAgICogd2lsbCByZW1vdmUgYW55IGBkdGVuZGAgcHJvcGVydGllcy5cbiAgICAgKiBAdHlwZSB7SUNBTC5EdXJhdGlvbn1cbiAgICAgKi9cbiAgICBnZXQgZHVyYXRpb24oKSB7XG4gICAgICB2YXIgZHVyYXRpb24gPSB0aGlzLl9maXJzdFByb3AoJ2R1cmF0aW9uJyk7XG4gICAgICBpZiAoIWR1cmF0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuZERhdGUuc3VidHJhY3REYXRlVHoodGhpcy5zdGFydERhdGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGR1cmF0aW9uO1xuICAgIH0sXG5cbiAgICBzZXQgZHVyYXRpb24odmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLmNvbXBvbmVudC5oYXNQcm9wZXJ0eSgnZHRlbmQnKSkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudC5yZW1vdmVQcm9wZXJ0eSgnZHRlbmQnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2V0UHJvcCgnZHVyYXRpb24nLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBsb2NhdGlvbiBvZiB0aGUgZXZlbnQuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgbG9jYXRpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmlyc3RQcm9wKCdsb2NhdGlvbicpO1xuICAgIH0sXG5cbiAgICBzZXQgbG9jYXRpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZXRQcm9wKCdsb2NhdGlvbicsIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGF0dGVuZGVlcyBpbiB0aGUgZXZlbnRcbiAgICAgKiBAdHlwZSB7SUNBTC5Qcm9wZXJ0eVtdfVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIGdldCBhdHRlbmRlZXMoKSB7XG4gICAgICAvL1hYWDogVGhpcyBpcyB3YXkgbGFtZSB3ZSBzaG91bGQgaGF2ZSBhIGJldHRlclxuICAgICAgLy8gICAgIGRhdGEgc3RydWN0dXJlIGZvciB0aGlzIGxhdGVyLlxuICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50LmdldEFsbFByb3BlcnRpZXMoJ2F0dGVuZGVlJyk7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogVGhlIGV2ZW50IHN1bW1hcnlcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBzdW1tYXJ5KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpcnN0UHJvcCgnc3VtbWFyeScpO1xuICAgIH0sXG5cbiAgICBzZXQgc3VtbWFyeSh2YWx1ZSkge1xuICAgICAgdGhpcy5fc2V0UHJvcCgnc3VtbWFyeScsIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGV2ZW50IGRlc2NyaXB0aW9uLlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpcnN0UHJvcCgnZGVzY3JpcHRpb24nKTtcbiAgICB9LFxuXG4gICAgc2V0IGRlc2NyaXB0aW9uKHZhbHVlKSB7XG4gICAgICB0aGlzLl9zZXRQcm9wKCdkZXNjcmlwdGlvbicsIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGV2ZW50IGNvbG9yIGZyb20gW3JmYzc5ODZdKGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNzk4NilcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBjb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9maXJzdFByb3AoJ2NvbG9yJyk7XG4gICAgfSxcblxuICAgIHNldCBjb2xvcih2YWx1ZSkge1xuICAgICAgdGhpcy5fc2V0UHJvcCgnY29sb3InLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcmdhbml6ZXIgdmFsdWUgYXMgYW4gdXJpLiBJbiBtb3N0IGNhc2VzIHRoaXMgaXMgYSBtYWlsdG86IHVyaSwgYnV0XG4gICAgICogaXQgY2FuIGFsc28gYmUgc29tZXRoaW5nIGVsc2UsIGxpa2UgdXJuOnV1aWQ6Li4uXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgb3JnYW5pemVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpcnN0UHJvcCgnb3JnYW5pemVyJyk7XG4gICAgfSxcblxuICAgIHNldCBvcmdhbml6ZXIodmFsdWUpIHtcbiAgICAgIHRoaXMuX3NldFByb3AoJ29yZ2FuaXplcicsIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHNlcXVlbmNlIHZhbHVlIGZvciB0aGlzIGV2ZW50LiBVc2VkIGZvciBzY2hlZHVsaW5nXG4gICAgICogc2VlIHtAdHV0b3JpYWwgdGVybWlub2xvZ3l9LlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHNlcXVlbmNlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpcnN0UHJvcCgnc2VxdWVuY2UnKTtcbiAgICB9LFxuXG4gICAgc2V0IHNlcXVlbmNlKHZhbHVlKSB7XG4gICAgICB0aGlzLl9zZXRQcm9wKCdzZXF1ZW5jZScsIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHJlY3VycmVuY2UgaWQgZm9yIHRoaXMgZXZlbnQuIFNlZSB7QHR1dG9yaWFsIHRlcm1pbm9sb2d5fSBmb3IgZGV0YWlscy5cbiAgICAgKiBAdHlwZSB7SUNBTC5UaW1lfVxuICAgICAqL1xuICAgIGdldCByZWN1cnJlbmNlSWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmlyc3RQcm9wKCdyZWN1cnJlbmNlLWlkJyk7XG4gICAgfSxcblxuICAgIHNldCByZWN1cnJlbmNlSWQodmFsdWUpIHtcbiAgICAgIHRoaXMuX3NldFRpbWUoJ3JlY3VycmVuY2UtaWQnLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldC91cGRhdGUgYSB0aW1lIHByb3BlcnR5J3MgdmFsdWUuXG4gICAgICogVGhpcyB3aWxsIGFsc28gdXBkYXRlIHRoZSBUWklEIG9mIHRoZSBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIFRPRE86IHRoaXMgbWV0aG9kIGhhbmRsZXMgdGhlIGNhc2Ugd2hlcmUgd2UgYXJlIHN3aXRjaGluZ1xuICAgICAqIGZyb20gYSBrbm93biB0aW1lem9uZSB0byBhbiBpbXBsaWVkIHRpbWV6b25lIChvbmUgd2l0aG91dCBUWklEKS5cbiAgICAgKiBUaGlzIGRvZXMgX25vdF8gaGFuZGxlIHRoZSBjYXNlIG9mIG1vdmluZyBiZXR3ZWVuIGEga25vd25cbiAgICAgKiAgKGJ5IFRpbWV6b25lU2VydmljZSkgdGltZXpvbmUgdG8gYW4gdW5rbm93biB0aW1lem9uZS4uLlxuICAgICAqXG4gICAgICogV2Ugd2lsbCBub3QgYWRkL3JlbW92ZS91cGRhdGUgdGhlIFZUSU1FWk9ORSBzdWJjb21wb25lbnRzXG4gICAgICogIGxlYWRpbmcgdG8gaW52YWxpZCBJQ0FMIGRhdGEuLi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wTmFtZSAgICAgVGhlIHByb3BlcnR5IG5hbWVcbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZX0gdGltZSAgICAgIFRoZSB0aW1lIHRvIHNldFxuICAgICAqL1xuICAgIF9zZXRUaW1lOiBmdW5jdGlvbihwcm9wTmFtZSwgdGltZSkge1xuICAgICAgdmFyIHByb3AgPSB0aGlzLmNvbXBvbmVudC5nZXRGaXJzdFByb3BlcnR5KHByb3BOYW1lKTtcblxuICAgICAgaWYgKCFwcm9wKSB7XG4gICAgICAgIHByb3AgPSBuZXcgSUNBTC5Qcm9wZXJ0eShwcm9wTmFtZSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50LmFkZFByb3BlcnR5KHByb3ApO1xuICAgICAgfVxuXG4gICAgICAvLyB1dGMgYW5kIGxvY2FsIGRvbid0IGdldCBhIHR6aWRcbiAgICAgIGlmIChcbiAgICAgICAgdGltZS56b25lID09PSBJQ0FMLlRpbWV6b25lLmxvY2FsVGltZXpvbmUgfHxcbiAgICAgICAgdGltZS56b25lID09PSBJQ0FMLlRpbWV6b25lLnV0Y1RpbWV6b25lXG4gICAgICApIHtcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSB0emlkXG4gICAgICAgIHByb3AucmVtb3ZlUGFyYW1ldGVyKCd0emlkJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wLnNldFBhcmFtZXRlcigndHppZCcsIHRpbWUuem9uZS50emlkKTtcbiAgICAgIH1cblxuICAgICAgcHJvcC5zZXRWYWx1ZSh0aW1lKTtcbiAgICB9LFxuXG4gICAgX3NldFByb3A6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICB0aGlzLmNvbXBvbmVudC51cGRhdGVQcm9wZXJ0eVdpdGhWYWx1ZShuYW1lLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIF9maXJzdFByb3A6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudC5nZXRGaXJzdFByb3BlcnR5VmFsdWUobmFtZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBldmVudC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50LnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gIH07XG5cbiAgZnVuY3Rpb24gY29tcGFyZVJhbmdlRXhjZXB0aW9uKGEsIGIpIHtcbiAgICBpZiAoYVswXSA+IGJbMF0pIHJldHVybiAxO1xuICAgIGlmIChiWzBdID4gYVswXSkgcmV0dXJuIC0xO1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIEV2ZW50O1xufSgpKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAxMS0yMDE1ICovXG5cblxuLyoqXG4gKiBUaGlzIHN5bWJvbCBpcyBmdXJ0aGVyIGRlc2NyaWJlZCBsYXRlciBvblxuICogQGlnbm9yZVxuICovXG5JQ0FMLkNvbXBvbmVudFBhcnNlciA9IChmdW5jdGlvbigpIHtcbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogVGhlIENvbXBvbmVudFBhcnNlciBpcyB1c2VkIHRvIHByb2Nlc3MgYSBTdHJpbmcgb3IgakNhbCBPYmplY3QsXG4gICAqIGZpcmluZyBjYWxsYmFja3MgZm9yIHZhcmlvdXMgZm91bmQgY29tcG9uZW50cywgYXMgd2VsbCBhcyBjb21wbGV0aW9uLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgb3B0aW9ucyA9IHtcbiAgICogICAvLyB3aGVuIGZhbHNlIG5vIGV2ZW50cyB3aWxsIGJlIGVtaXR0ZWQgZm9yIHR5cGVcbiAgICogICBwYXJzZUV2ZW50OiB0cnVlLFxuICAgKiAgIHBhcnNlVGltZXpvbmU6IHRydWVcbiAgICogfTtcbiAgICpcbiAgICogdmFyIHBhcnNlciA9IG5ldyBJQ0FMLkNvbXBvbmVudFBhcnNlcihvcHRpb25zKTtcbiAgICpcbiAgICogcGFyc2VyLm9uZXZlbnQoZXZlbnRDb21wb25lbnQpIHtcbiAgICogICAvLy4uLlxuICAgKiB9XG4gICAqXG4gICAqIC8vIG9udGltZXpvbmUsIGV0Yy4uLlxuICAgKlxuICAgKiBwYXJzZXIub25jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuICAgKlxuICAgKiB9O1xuICAgKlxuICAgKiBwYXJzZXIucHJvY2VzcyhzdHJpbmdPckNvbXBvbmVudCk7XG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAYWxpYXMgSUNBTC5Db21wb25lbnRQYXJzZXJcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zICAgICAgICBDb21wb25lbnQgcGFyc2VyIG9wdGlvbnNcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLnBhcnNlRXZlbnQgICAgICAgIFdoZXRoZXIgZXZlbnRzIHNob3VsZCBiZSBwYXJzZWRcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLnBhcnNlVGltZXplb25lICAgIFdoZXRoZXIgdGltZXpvbmVzIHNob3VsZCBiZSBwYXJzZWRcbiAgICovXG4gIGZ1bmN0aW9uIENvbXBvbmVudFBhcnNlcihvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZihvcHRpb25zKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIga2V5O1xuICAgIGZvciAoa2V5IGluIG9wdGlvbnMpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHRoaXNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBDb21wb25lbnRQYXJzZXIucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCBwYXJzZSBldmVudHNcbiAgICAgKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHBhcnNlRXZlbnQ6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIHBhcnNlIHRpbWV6b25lc1xuICAgICAqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgcGFyc2VUaW1lem9uZTogdHJ1ZSxcblxuXG4gICAgLyogU0FYIGxpa2UgZXZlbnRzIGhlcmUgZm9yIHJlZmVyZW5jZSAqL1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiBwYXJzaW5nIGlzIGNvbXBsZXRlXG4gICAgICogQGNhbGxiYWNrXG4gICAgICovXG4gICAgb25jb21wbGV0ZTogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZnVuY3Rpb24oKSB7fSxcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIGlmIGFuIGVycm9yIG9jY3VycyBkdXJpbmcgcGFyc2luZy5cbiAgICAgKlxuICAgICAqIEBjYWxsYmFja1xuICAgICAqIEBwYXJhbSB7RXJyb3J9IGVyciBkZXRhaWxzIG9mIGVycm9yXG4gICAgICovXG4gICAgb25lcnJvcjogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZnVuY3Rpb24oZXJyKSB7fSxcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gYSB0b3AgbGV2ZWwgY29tcG9uZW50IChWVElNRVpPTkUpIGlzIGZvdW5kXG4gICAgICpcbiAgICAgKiBAY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZXpvbmV9IGNvbXBvbmVudCAgICAgVGltZXpvbmUgb2JqZWN0XG4gICAgICovXG4gICAgb250aW1lem9uZTogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZnVuY3Rpb24oY29tcG9uZW50KSB7fSxcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gYSB0b3AgbGV2ZWwgY29tcG9uZW50IChWRVZFTlQpIGlzIGZvdW5kLlxuICAgICAqXG4gICAgICogQGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHtJQ0FMLkV2ZW50fSBjb21wb25lbnQgICAgVG9wIGxldmVsIGNvbXBvbmVudFxuICAgICAqL1xuICAgIG9uZXZlbnQ6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uKGNvbXBvbmVudCkge30sXG5cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGEgc3RyaW5nIG9yIHBhcnNlIGljYWwgb2JqZWN0LiAgVGhpcyBmdW5jdGlvbiBpdHNlbGYgd2lsbCByZXR1cm5cbiAgICAgKiBub3RoaW5nIGJ1dCB3aWxsIHN0YXJ0IHRoZSBwYXJzaW5nIHByb2Nlc3MuXG4gICAgICpcbiAgICAgKiBFdmVudHMgbXVzdCBiZSByZWdpc3RlcmVkIHByaW9yIHRvIGNhbGxpbmcgdGhpcyBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuQ29tcG9uZW50fFN0cmluZ3xPYmplY3R9IGljYWwgICAgICBUaGUgY29tcG9uZW50IHRvIHByb2Nlc3MsXG4gICAgICogICAgICAgIGVpdGhlciBpbiBpdHMgZmluYWwgZm9ybSwgYXMgYSBqQ2FsIE9iamVjdCwgb3Igc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAgICovXG4gICAgcHJvY2VzczogZnVuY3Rpb24oaWNhbCkge1xuICAgICAgLy9UT0RPOiB0aGlzIGlzIHN5bmMgbm93IGluIHRoZSBmdXR1cmUgd2Ugd2lsbCBoYXZlIGEgaW5jcmVtZW50YWwgcGFyc2VyLlxuICAgICAgaWYgKHR5cGVvZihpY2FsKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWNhbCA9IElDQUwucGFyc2UoaWNhbCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghKGljYWwgaW5zdGFuY2VvZiBJQ0FMLkNvbXBvbmVudCkpIHtcbiAgICAgICAgaWNhbCA9IG5ldyBJQ0FMLkNvbXBvbmVudChpY2FsKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbXBvbmVudHMgPSBpY2FsLmdldEFsbFN1YmNvbXBvbmVudHMoKTtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBsZW4gPSBjb21wb25lbnRzLmxlbmd0aDtcbiAgICAgIHZhciBjb21wb25lbnQ7XG5cbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29tcG9uZW50ID0gY29tcG9uZW50c1tpXTtcblxuICAgICAgICBzd2l0Y2ggKGNvbXBvbmVudC5uYW1lKSB7XG4gICAgICAgICAgY2FzZSAndnRpbWV6b25lJzpcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcnNlVGltZXpvbmUpIHtcbiAgICAgICAgICAgICAgdmFyIHR6aWQgPSBjb21wb25lbnQuZ2V0Rmlyc3RQcm9wZXJ0eVZhbHVlKCd0emlkJyk7XG4gICAgICAgICAgICAgIGlmICh0emlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbnRpbWV6b25lKG5ldyBJQ0FMLlRpbWV6b25lKHtcbiAgICAgICAgICAgICAgICAgIHR6aWQ6IHR6aWQsXG4gICAgICAgICAgICAgICAgICBjb21wb25lbnQ6IGNvbXBvbmVudFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndmV2ZW50JzpcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcnNlRXZlbnQpIHtcbiAgICAgICAgICAgICAgdGhpcy5vbmV2ZW50KG5ldyBJQ0FMLkV2ZW50KGNvbXBvbmVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vWFhYOiBpZGVhbGx5IHdlIHNob3VsZCBkbyBhIFwibmV4dFRpY2tcIiBoZXJlXG4gICAgICAvLyAgICAgc28gaW4gYWxsIGNhc2VzIHRoaXMgaXMgYWN0dWFsbHkgYXN5bmMuXG4gICAgICB0aGlzLm9uY29tcGxldGUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIENvbXBvbmVudFBhcnNlcjtcbn0oKSk7XG4iLCAiLy8gaW1wb3J0IHsgQXBwLCBFZGl0b3IsIE1hcmtkb3duVmlldywgTW9kYWwsIE5vdGljZSwgUGx1Z2luLCBQbHVnaW5TZXR0aW5nVGFiLCBTZXR0aW5nLCBJdGVtVmlldywgUGxhdGZvcm0sIFdvcmtzcGFjZUxlYWYgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBBcHAsIE5vdGljZSwgUGx1Z2luLCBQbHVnaW5NYW5pZmVzdCwgVEZpbGUsIFdvcmtzcGFjZUxlYWYgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBDYWxlbmRhclZpZXd9IGZyb20gXCIuL3ZpZXdzL0NhbGVuZGFyVmlld1wiXG5pbXBvcnQgeyBDYWNoZSB9IGZyb20gXCIuL2NhY2hlXCJcbmltcG9ydCB7IFBsdWdpblNldHRpbmdzIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBNeVNldHRpbmdUYWIgfSBmcm9tICcuL3NldHRpbmcnO1xuaW1wb3J0IHsgREVGQVVMVF9TRVRUSU5HUywgQ0FDSEVfSUQsIE1TR19QTEdfTkFNRSwgVklFV19UWVBFIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IFN0YXR1c0NvcnJlY3RvciBmcm9tICcuL3ZpZXdzL3N0YXR1c0NvcnJlY3Rvcic7XG5pbXBvcnQgeyBUaWNrQ2hlY2tlciB9IGZyb20gJy4vdmlld3MvVGlja0NoZWtlcic7XG5pbXBvcnQgTm90ZU1hbmFnZXIgZnJvbSAnLi9Ob3RlTWFuYWdlcic7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTXlQbHVnaW4gZXh0ZW5kcyBQbHVnaW4ge1xuICBwcml2YXRlIG5vdGVNYW5hZ2VyOiBOb3RlTWFuYWdlclxuXG4gIHByaXZhdGUgY2FjaGU6IENhY2hlXG5cbiAgcHJpdmF0ZSBzdGF0dXNDb3JyZWN0b3I6IFN0YXR1c0NvcnJlY3RvclxuXG4gIHByaXZhdGUgc2V0dGluZ3M6IFBsdWdpblNldHRpbmdzXG5cbiAgcHJpdmF0ZSB0aWNrQ2hlY2tlcjogVGlja0NoZWNrZXIgfCB2b2lkXG5cbiAgcHJpdmF0ZSBjYWxlbmRhcjogQ2FsZW5kYXJWaWV3IHwgdm9pZFxuXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBtYW5pZmVzdDogUGx1Z2luTWFuaWZlc3QpIHtcbiAgICBzdXBlcihhcHAsIG1hbmlmZXN0KVxuXG4gICAgY29uc3Qgbm90ZU1hbmFnZXIgPSBuZXcgTm90ZU1hbmFnZXIoXG4gICAgICB0aGlzLmFwcC52YXVsdCxcbiAgICAgIHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUsXG4gICAgICB0aGlzLmFwcC5maWxlTWFuYWdlcixcbiAgICAgIHRoaXMuYXBwLndvcmtzcGFjZVxuICAgIClcbiAgICB0aGlzLm5vdGVNYW5hZ2VyID0gbm90ZU1hbmFnZXJcblxuICAgIC8vIFx1MDQ0MVx1MDQzRVx1MDQzN1x1MDQzNFx1MDQzMFx1MDQzMlx1MDQzMFx1MDQ0Mlx1MDQ0QyBcdTA0M0ZcdTA0NDBcdTA0Mzggb25sb2FkIFx1MDQzOCBcdTA0NDJcdTA0M0VcdTA0MzNcdTA0MzRcdTA0MzAgXHUwNDM2XHUwNDM1IFx1MDQzN1x1MDQzMFx1MDQzRlx1MDQ0M1x1MDQ0MVx1MDQzQVx1MDQzMFx1MDQ0Mlx1MDQ0QyBpbml0U3RvcmFnZVxuICAgIHRoaXMuY2FjaGUgPSBuZXcgQ2FjaGUodGhpcy5ub3RlTWFuYWdlciwgdGhpcy5hcHAudmF1bHQpXG4gIH1cblxuICBwdWJsaWMgYXN5bmMgb25sb2FkKCkge1xuICAgIGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKClcblxuICAgIHRoaXMuaW5pdFJlZ2lzdGVyKClcblxuXG4gICAgdGhpcy50aWNrQ2hlY2tlciA9IG5ldyBUaWNrQ2hlY2tlcihcbiAgICAgIENBQ0hFX0lELlRJQ0tfQ0hFQ0tFUixcbiAgICAgIHRoaXMuc2V0dGluZ3Muc291cmNlLm5vdGVTb3VyY2VzLFxuICAgICAgdGhpcy5jYWNoZSxcbiAgICAgIHRoaXMubm90ZU1hbmFnZXJcbiAgICApXG5cbiAgICBpZiAodGhpcy5zZXR0aW5ncy5zdGF0dXNDb3JyZWN0b3IuaXNPbikge1xuICAgICAgdGhpcy5zdGF0dXNDb3JyZWN0b3IgPSBuZXcgU3RhdHVzQ29ycmVjdG9yKFxuICAgICAgICBDQUNIRV9JRC5TVEFUVVNfQ09SUkVDVE9SLFxuICAgICAgICB0aGlzLnNldHRpbmdzLnNvdXJjZS5ub3RlU291cmNlcyxcbiAgICAgICAgdGhpcy5jYWNoZSxcbiAgICAgICAgdGhpcy5ub3RlTWFuYWdlclxuICAgICAgKVxuXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5zdGF0dXNDb3JyZWN0b3Iuc3RhcnRPblN0YXJ0VXApXG4gICAgICAgIHRoaXMuc3RhdHVzQ29ycmVjdG9yLmNvcnJlY3RBbGxOb3RlcygpXG5cbiAgICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICAgIGlkOiAnZnVsbFN0YXR1c0NvcnJlY3QnLFxuICAgICAgICBuYW1lOiBNU0dfUExHX05BTUUgKyAnRnVsbCBTdGF0dXNDb3JyZWN0b3InLFxuICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgIHRoaXMuc3RhdHVzQ29ycmVjdG9yLmNvcnJlY3RBbGxOb3RlcygpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuYXBwLndvcmtzcGFjZS5vbkxheW91dFJlYWR5KCgpID0+IHRoaXMuaW5pdCgpKVxuXG4gICAgdGhpcy5yZWdpc3RlclZpZXcoXG4gICAgICAgIFZJRVdfVFlQRSxcbiAgICAgICAgKGxlYWY6IFdvcmtzcGFjZUxlYWYpID0+IHtcbiAgICAgICAgICB0aGlzLmNhbGVuZGFyID0gbmV3IENhbGVuZGFyVmlldyhcbiAgICAgICAgICAgIGxlYWYsXG4gICAgICAgICAgICBDQUNIRV9JRC5DQUxFTkRBUixcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3Muc291cmNlLm5vdGVTb3VyY2VzLFxuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5jYWxlbmRhcixcbiAgICAgICAgICAgIHRoaXMuY2FjaGUsXG4gICAgICAgICAgICB0aGlzLm5vdGVNYW5hZ2VyLFxuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5zb3VyY2UuZGVmYXVsdENyZWF0ZVBhdGhcbiAgICAgICAgICApXG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclxuICAgICAgICB9XG4gICAgKVxuXG4gICAgdGhpcy5hZGRSaWJib25JY29uKFwiaW5mb1wiLCBNU0dfUExHX05BTUUgKyBcIk9wZW4gQ2FsZW5kYXJcIiwgKCkgPT4gdGhpcy5hY3RpdmF0ZVZpZXcoKSlcblxuICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICBpZDogJ3Jlc2V0LWNhY2hlJyxcbiAgICAgIG5hbWU6IE1TR19QTEdfTkFNRSArICdSZXNldCBDYWNoZScsXG4gICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICB0aGlzLmNhY2hlLnJlc2V0KClcbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICBpZDogJ2xvZy1jYWNoZScsXG4gICAgICBuYW1lOiBNU0dfUExHX05BTUUgKyAnTG9nIENhY2hlJyxcbiAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuY2FjaGUubG9nKClcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBvbnVubG9hZCgpIHtcbiAgICAvLyBUT0RPIFx1MDQzQVx1MDQzMFx1MDQzQSBcdTA0MzFcdTA0NDNcdTA0MzRcdTA0NDJcdTA0M0UgXHUwNDM0XHUwNDQwXHUwNDQzXHUwNDMzXHUwNDM4XHUwNDQ1IFx1MDQzRFx1MDQzNSBcdTA0NDVcdTA0MzJcdTA0MzBcdTA0NDJcdTA0MzBcdTA0MzVcdTA0NDIgZGVzdG95XG5cbiAgICAvLyBpZiAodGhpcy5zZXR0aW5ncz8uc3RhdHVzQ29ycmVjdG9yLmlzT24pXG4gICAgICB0aGlzLnN0YXR1c0NvcnJlY3Rvcj8uZGVzdHJveSgpXG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGluaXQoKSB7XG4gICAgYXdhaXQgdGhpcy5jYWNoZS5pbml0KClcblxuICAgIHRoaXMudGlja0NoZWNrZXI/LmluaXQoKVxuICAgIHRoaXMuc3RhdHVzQ29ycmVjdG9yPy5pbml0KClcbiAgfVxuXG4gIHByaXZhdGUgaW5pdFJlZ2lzdGVyKCkge1xuICAgIHRoaXMucmVnaXN0ZXJFdmVudChcbiAgICAgIHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUub24oXCJjaGFuZ2VkXCIsIGZpbGUgPT4ge1xuICAgICAgICB0aGlzLmNhY2hlLmNoYW5nZUZpbGUoZmlsZSlcbiAgICAgIH0pXG4gICAgKVxuXG4gICAgdGhpcy5yZWdpc3RlckV2ZW50KFxuICAgICAgdGhpcy5hcHAudmF1bHQub24oXG4gICAgICAgIFwicmVuYW1lXCIsXG4gICAgICAgIChmaWxlLCBvbGRQYXRoKSA9PiB7XG4gICAgICAgICAgLy8gXHUwNDNGXHUwNDQwXHUwNDNFXHUwNDMyXHUwNDM1XHUwNDQwXHUwNDNBXHUwNDMwIFx1MDQzRFx1MDQzMCBcdTA0NDJcdTA0M0UsIFx1MDQ0N1x1MDQ0Mlx1MDQzRSBcdTA0NERcdTA0NDJcdTA0M0UgXHUwNDQ0XHUwNDMwXHUwNDM5XHUwNDNCLCBcdTA0MzAgXHUwNDNEXHUwNDM1IFx1MDQzRlx1MDQzMFx1MDQzRlx1MDQzQVx1MDQzMFxuICAgICAgICAgIGlmICghKGZpbGUgYXMgVEZpbGUpLmJhc2VuYW1lKVxuICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgICB0aGlzLmNhY2hlLnJlbmFtZUZpbGUoZmlsZSBhcyBURmlsZSwgb2xkUGF0aClcbiAgICAgICAgfVxuICAgICAgKVxuICAgIClcblxuICAgIHRoaXMucmVnaXN0ZXJFdmVudChcbiAgICAgIHRoaXMuYXBwLnZhdWx0Lm9uKFxuICAgICAgICBcImRlbGV0ZVwiLFxuICAgICAgICBmaWxlID0+IHRoaXMuY2FjaGUuZGVsZXRlRmlsZShmaWxlKVxuICAgICAgKVxuICAgIClcblxuICAgIHRoaXMucmVnaXN0ZXJFdmVudChcbiAgICAgIHRoaXMuYXBwLnZhdWx0Lm9uKFxuICAgICAgICBcImNyZWF0ZVwiLFxuICAgICAgICBmaWxlID0+IHtcbiAgICAgICAgICAvLyBcdTA0M0ZcdTA0NDBcdTA0M0VcdTA0MzJcdTA0MzVcdTA0NDBcdTA0M0FcdTA0MzAgXHUwNDNEXHUwNDMwIFx1MDQ0Mlx1MDQzRSwgXHUwNDQ3XHUwNDQyXHUwNDNFIFx1MDQ0RFx1MDQ0Mlx1MDQzRSBcdTA0NDRcdTA0MzBcdTA0MzlcdTA0M0IsIFx1MDQzMCBcdTA0M0RcdTA0MzUgXHUwNDNGXHUwNDMwXHUwNDNGXHUwNDNBXHUwNDMwXG4gICAgICAgICAgaWYgKCEoZmlsZSBhcyBURmlsZSkuYmFzZW5hbWUpXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICAgIHRoaXMuY2FjaGUuYWRkRmlsZShmaWxlIGFzIFRGaWxlKVxuICAgICAgICB9XG4gICAgICApXG4gICAgKVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBhY3RpdmF0ZVZpZXcoKSB7XG4gICAgY29uc3QgbGVhdmVzID0gdGhpcy5hcHAud29ya3NwYWNlLmdldExlYXZlc09mVHlwZShWSUVXX1RZUEUpXG4gICAgaWYgKGxlYXZlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnN0IGxlYWYgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0TGVhZihmYWxzZSk7XG4gICAgICBhd2FpdCBsZWFmLnNldFZpZXdTdGF0ZSh7XG4gICAgICAgIHR5cGU6IFZJRVdfVFlQRSxcbiAgICAgICAgYWN0aXZlOiB0cnVlLFxuICAgICAgfSlcbiAgICB9XG4gICAgZWxzZSBpZiAobGVhdmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgKGxlYXZlc1swXS52aWV3IGFzIENhbGVuZGFyVmlldykub25PcGVuKClcbiAgICAgIHRoaXMuYXBwLndvcmtzcGFjZS5zZXRBY3RpdmVMZWFmKGxlYXZlc1swXSlcbiAgICB9XG4gICAgZWxzZSBmb3IgKGxldCBsZWFmIG9mIGxlYXZlcylcbiAgICAgIGxlYWYuZGV0YWNoKClcbiAgfVxuXG5cbiAgLy8gU2V0dGluZ3NcblxuICBwdWJsaWMgZ2V0U2V0dGluZ3MoKTogUGx1Z2luU2V0dGluZ3Mge1xuICAgIC8vIE5PVEU6IGZ1bGwgY29weVxuICAgIHJldHVybiBKU09OLnBhcnNlKFxuICAgICAgSlNPTi5zdHJpbmdpZnkodGhpcy5zZXR0aW5ncylcbiAgICApXG4gIH1cblxuICBwdWJsaWMgYXN5bmMgc2F2ZVNldHRpbmdzKHNldHRpbmdzOiBQbHVnaW5TZXR0aW5ncykge1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5nc1xuICAgIGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncyk7XG4gIH1cblxuXG5cbiAgcHJpdmF0ZSBhc3luYyBsb2FkU2V0dGluZ3MoKSB7XG4gICAgdGhpcy5zZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfU0VUVElOR1MsIGF3YWl0IHRoaXMubG9hZERhdGEoKSlcblxuICAgIHRoaXMuYWRkU2V0dGluZ1RhYihuZXcgTXlTZXR0aW5nVGFiKHRoaXMuYXBwLCB0aGlzKSk7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBJdGVtVmlldywgUGxhdGZvcm0sIFdvcmtzcGFjZUxlYWYsIE5vdGljZSwgTW9kYWwsIEFwcCwgU2V0dGluZywgTWVudSwgQ29tcG9uZW50IH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IE15UGx1Z2luIGZyb20gXCIuLi9tYWluXCJcbmltcG9ydCB7IE1TR19QTEdfTkFNRSwgVEVYVF9ET05FLCBWSUVXX1RZUEUgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgQ2FsZW5kYXJFdmVudCwgQ2FsZW5kYXJTZXR0aW5ncywgSUV2ZW50LCBJUGFnZSwgSVN1YnNjcmliZXIsIFNyYyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IENhbGVuZGFyRXZlbnRUb0lEYXRlLCBnZXRDb2xvdXJGcm9tUGF0aCwgSURhdGVUb0NhbGVuZGFyRXZlbnQsIG1pbGxpc2VjVG9TdHJpbmcsIHRlbXBsYXRlSURUaWNrLCB0ZW1wbGF0ZU5hbWVUaWNrLCB0aW1lQWRkIH0gZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgeyByZW5kZXJDYWxlbmRhciB9IGZyb20gJ2xpYi9vYnNpZGlhbi1mdWxsLWNhbGVuZGFyL2NhbGVuZGFyJztcbmltcG9ydCB7IENhbGVuZGFyIH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb3JlJztcbmltcG9ydCB7IENhY2hlIH0gZnJvbSAnc3JjL2NhY2hlJztcbmltcG9ydCBOb3RlTWFuYWdlciBmcm9tICdzcmMvTm90ZU1hbmFnZXInO1xuXG5leHBvcnQgY2xhc3MgQ2FsZW5kYXJWaWV3IGV4dGVuZHMgSXRlbVZpZXcgaW1wbGVtZW50cyBJU3Vic2NyaWJlciB7XG4gIC8vIHByaXZhdGUgcGFycmVudFBvaW50ZXI6IE15UGx1Z2luXG5cbiAgcHJpdmF0ZSBjYWNoZTogQ2FjaGVcblxuICBwcml2YXRlIGNhbGVuZGFyOiBDYWxlbmRhciB8IG51bGwgPSBudWxsXG5cbiAgcHJpdmF0ZSBpZEZvckNhY2hlOiBudW1iZXJcblxuICBwcml2YXRlIGV2ZW50U3JjOiBTcmNbXVxuXG4gIHByaXZhdGUgc2VsZWN0ZWRTcmNQYXRoczogU2V0PHN0cmluZz4gPSBuZXcgU2V0KClcblxuICBwcml2YXRlIG5vdGVNYW5hZ2VyOiBOb3RlTWFuYWdlclxuXG4gIHByaXZhdGUgY2FsZW5kYXJTZXR0aW5nczogQ2FsZW5kYXJTZXR0aW5nc1xuXG4gIHByaXZhdGUgbG9jYWxTdG9yYWdlOiBJUGFnZVtdXG5cbiAgLy8gcHJpdmF0ZSBzcmNDaGVja2JveENvbnRhaW5lcjogSFRNTEVsZW1lbnQgfCBudWxsID0gbnVsbFxuICBwcml2YXRlIHBsYWNlRm9yQ3JlYXRpbmdOb3RlOiBzdHJpbmdcblxuICBjb25zdHJ1Y3RvcihcbiAgICBsZWFmOiBXb3Jrc3BhY2VMZWFmLFxuICAgIGlkRm9yQ2FjaGU6IG51bWJlcixcbiAgICBldmVudFNyYzogU3JjW10sXG4gICAgY2FsZW5kYXJTZXR0aW5nczogQ2FsZW5kYXJTZXR0aW5ncyxcbiAgICBjYWNoZTogQ2FjaGUsXG4gICAgbm90ZU1hbmFnZXI6IE5vdGVNYW5hZ2VyLFxuICAgIHBsYWNlRm9yQ3JlYXRpbmdOb3RlOiBzdHJpbmcsXG4gICkge1xuICAgIHN1cGVyKGxlYWYpXG5cbiAgICB0aGlzLmNhY2hlID0gY2FjaGVcbiAgICB0aGlzLmlkRm9yQ2FjaGUgPSBpZEZvckNhY2hlXG4gICAgdGhpcy5ldmVudFNyYyA9IGV2ZW50U3JjXG4gICAgdGhpcy5ub3RlTWFuYWdlciA9IG5vdGVNYW5hZ2VyXG4gICAgdGhpcy5jYWxlbmRhclNldHRpbmdzID0gY2FsZW5kYXJTZXR0aW5nc1xuICAgIHRoaXMucGxhY2VGb3JDcmVhdGluZ05vdGUgPSBwbGFjZUZvckNyZWF0aW5nTm90ZVxuXG4gICAgZm9yIChsZXQgc3JjIG9mIGV2ZW50U3JjKSB7XG4gICAgICB0aGlzLnNlbGVjdGVkU3JjUGF0aHMuYWRkKHNyYy5wYXRoKVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXRWaWV3VHlwZSgpIHtyZXR1cm4gVklFV19UWVBFfVxuXG4gIHB1YmxpYyBnZXREaXNwbGF5VGV4dCgpIHtyZXR1cm4gXCJDYWxlbmRhclwifVxuXG4gIHB1YmxpYyBhc3luYyBvbk9wZW4oKSB7XG4gICAgaWYgKFBsYXRmb3JtLmlzTW9iaWxlKVxuICAgICAgdGhpcy5jb250YWluZXJFbC5zdHlsZS5oZWlnaHQgPSBcIjk1dmhcIlxuXG4gICAgY29uc3QgeyBjb250YWluZXJFbCB9ID0gdGhpc1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGNvbnRhaW5lckVsLmNoaWxkcmVuWzFdXG4gICAgY29udGFpbmVyLmVtcHR5KClcbiAgICBjb25zdCBjYWxlbmRhckNvbnRhaW5lciA9IGNvbnRhaW5lci5jcmVhdGVEaXYoLyp7Y2xzOiAnY2xhc3MnfSovKVxuICAgIGNvbnN0IGNoZWNrQm94Q29udGFpbmVyID0gY29udGFpbmVyLmNyZWF0ZURpdih7Y2xzOiAnY2FsZW5kYXItc3JjLWNoZWNrYm94ZXMnfSlcblxuICAgIHRoaXMucmVuZGVyKGNhbGVuZGFyQ29udGFpbmVyKVxuICAgICAgLnRoZW4oXG4gICAgICAgICgpID0+IHRoaXMucmVuZGVyU3JjQ2hlY2tib3hlcyhjaGVja0JveENvbnRhaW5lcilcbiAgICAgIClcbiAgfVxuXG4gIHB1YmxpYyBvblJlc2l6ZSgpIHtcbiAgICB0aGlzLmNhbGVuZGFyPy5yZW5kZXIoKTtcbiAgfVxuXG4gIHB1YmxpYyBhZGRGaWxlKGRhdGE6IElQYWdlKTogdm9pZCB7XG4gICAgdGhpcy5sb2NhbFN0b3JhZ2UucHVzaChkYXRhKVxuICAgIGlmICghdGhpcy5pc1BhdGhJbkFjdGl2ZVNyYyhkYXRhLmZpbGUucGF0aCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGV2ZW50cyA9IHRoaXMucGFnZVRvRXZlbnRzKGRhdGEpXG5cbiAgICBmb3IgKGxldCBldmVudCBvZiBldmVudHMpXG4gICAgICB0aGlzLmNhbGVuZGFyPy5hZGRFdmVudChldmVudClcbiAgfVxuXG4gIHB1YmxpYyBjaGFuZ2VGaWxlKG5ld1BhZ2U6IElQYWdlLCBvbGRQYWdlOiBJUGFnZSk6IHZvaWQge1xuICAgIHRoaXMuY2FsZW5kYXI/LnBhdXNlUmVuZGVyaW5nKClcbiAgICB0aGlzLmRlbGV0ZUZpbGUob2xkUGFnZSlcbiAgICB0aGlzLmFkZEZpbGUobmV3UGFnZSlcbiAgICB0aGlzLmNhbGVuZGFyPy5yZXN1bWVSZW5kZXJpbmcoKVxuICB9XG5cbiAgcHVibGljIHJlbmFtZUZpbGUobmV3UGFnZTogSVBhZ2UsIG9sZFBhZ2U6IElQYWdlKTogdm9pZCB7XG4gICAgdGhpcy5jaGFuZ2VGaWxlKG5ld1BhZ2UsIG9sZFBhZ2UpXG4gIH1cblxuICBwdWJsaWMgZGVsZXRlRmlsZShwYWdlOiBJUGFnZSk6IHZvaWQge1xuICAgIGNvbnN0IGVsID0gdGhpcy5sb2NhbFN0b3JhZ2UuZmluZChcbiAgICAgIHZhbHVlID0+IHBhZ2UuZmlsZS5wYXRoID09IHZhbHVlLmZpbGUucGF0aFxuICAgIClcbiAgICBpZiAoZWwpXG4gICAgICB0aGlzLmxvY2FsU3RvcmFnZS5yZW1vdmUoZWwpXG5cbiAgICBpZiAoIXRoaXMuY2FsZW5kYXIpXG4gICAgICByZXR1cm5cblxuICAgIGlmICghdGhpcy5pc1BhdGhJbkFjdGl2ZVNyYyhwYWdlLmZpbGUucGF0aCkpXG4gICAgICByZXR1cm5cblxuICAgIHRoaXMuY2FsZW5kYXIuZ2V0RXZlbnRCeUlkKHBhZ2UuZmlsZS5wYXRoKT8ucmVtb3ZlKClcblxuICAgIGZvciAobGV0IHRpY2sgb2YgcGFnZS50aWNrcykge1xuICAgICAgdGhpcy5jYWxlbmRhci5nZXRFdmVudEJ5SWQoXG4gICAgICAgIHRlbXBsYXRlSURUaWNrKHBhZ2UuZmlsZS5wYXRoLCB0aWNrLm5hbWUpXG4gICAgICApPy5yZW1vdmUoKVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByZXNldCgpIHtcbiAgICB0aGlzLm9udW5sb2FkKClcbiAgICB0aGlzLm9uT3BlbigpXG4gIH1cblxuICBvbnVubG9hZCgpIHtcbiAgICBpZiAoIXRoaXMuY2FsZW5kYXIpXG4gICAgICByZXR1cm5cblxuICAgIHRoaXMuY2FsZW5kYXIuZGVzdHJveSgpO1xuICAgIHRoaXMuY2FsZW5kYXIgPSBudWxsO1xuICAgIHRoaXMuY2FjaGUudW5zdWJzY3JpYmUodGhpcy5pZEZvckNhY2hlKVxuICB9XG5cbiAgcHVibGljIHBhZ2VUb0V2ZW50cyhwYWdlOiBJUGFnZSk6IElFdmVudFtdIHtcbiAgICBjb25zdCByZXN1bHQ6IElFdmVudFtdID0gW11cblxuICAgIGNvbnN0IGNvbG91cnMgPSB0aGlzLmNhbGVuZGFyU2V0dGluZ3MuY29sb3Vyc1xuXG4gICAgY29uc3Qgc3RydWN0dXJlVGVtcGxhdGUgPSB7XG4gICAgICBpZDogXCJcIixcbiAgICAgIHRpdGxlOiBcIlwiLFxuICAgICAgYm9yZGVyQ29sb3I6IGNvbG91cnMuZGVmYXVsdCxcbiAgICAgIGNvbG9yOiBnZXRDb2xvdXJGcm9tUGF0aChwYWdlLmZpbGUucGF0aCksXG4gICAgICBlZGl0YWJsZTogdHJ1ZSxcbiAgICB9XG5cbiAgICBpZiAocGFnZS5mZl9kYXRlKSB7XG4gICAgICBjb25zdCBzdHJ1Y3R1cmU6IElFdmVudCA9IHtcbiAgICAgICAgLi4uc3RydWN0dXJlVGVtcGxhdGUsXG4gICAgICAgIGlkOiBwYWdlLmZpbGUucGF0aCxcbiAgICAgICAgdGl0bGU6IHBhZ2UuZmlsZS5uYW1lLFxuICAgICAgICAuLi5JRGF0ZVRvQ2FsZW5kYXJFdmVudChwYWdlKVxuICAgICAgfVxuICAgICAgaWYgKHBhZ2UuZmZfZnJlcXVlbmN5KVxuICAgICAgICBzdHJ1Y3R1cmUuYm9yZGVyQ29sb3IgPSBjb2xvdXJzLmZyZXF1ZW5jeVxuICAgICAgaWYgKHBhZ2UuZmZfc3RhdHVzID09IFRFWFRfRE9ORSlcbiAgICAgICAgc3RydWN0dXJlLmJvcmRlckNvbG9yID0gY29sb3Vycy5kb25lXG5cbiAgICAgIHJlc3VsdC5wdXNoKHN0cnVjdHVyZSlcbiAgICB9XG4gICAgZm9yIChsZXQgdGljayBvZiBwYWdlLnRpY2tzKSB7XG4gICAgICBjb25zdCBzdHJ1Y3R1cmU6IElFdmVudCA9IHtcbiAgICAgICAgLi4uc3RydWN0dXJlVGVtcGxhdGUsXG4gICAgICAgIGlkOiB0ZW1wbGF0ZUlEVGljayhwYWdlLmZpbGUucGF0aCwgdGljay5uYW1lKSxcbiAgICAgICAgdGl0bGU6IHRlbXBsYXRlTmFtZVRpY2socGFnZS5maWxlLm5hbWUsIHRpY2submFtZSksXG4gICAgICAgIGJvcmRlckNvbG9yOiBjb2xvdXJzLnRpY2ssXG4gICAgICAgIGV4dGVuZGVkUHJvcHM6IHtcbiAgICAgICAgICB0aWNrTmFtZTogdGljay5uYW1lLFxuICAgICAgICAgIG5vdGVQYXRoOiBwYWdlLmZpbGUucGF0aFxuICAgICAgICB9LFxuICAgICAgICAuLi5JRGF0ZVRvQ2FsZW5kYXJFdmVudCh0aWNrKVxuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2goc3RydWN0dXJlKVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG5cbiAgcHJpdmF0ZSByZW5kZXJTcmNDaGVja2JveGVzKHNyY0NoZWNrYm94Q29udGFpbmVyOiBIVE1MRWxlbWVudCkge1xuICAgIHNyY0NoZWNrYm94Q29udGFpbmVyLmVtcHR5KClcbiAgICBzcmNDaGVja2JveENvbnRhaW5lci5hZGRDbGFzcyhcImNhbGVuZGFyLXNyYy1jaGVja2JveGVzXCIpXG5cbiAgICBmb3IgKGxldCBzcmMgb2YgdGhpcy5ldmVudFNyYykge1xuICAgICAgY29uc3QgY2hlY2tib3hDb250YWluZXIgPSBzcmNDaGVja2JveENvbnRhaW5lciEuY3JlYXRlRGl2KHtjbHM6ICdzcmMtY2hlY2tib3gtaXRlbSd9KVxuXG4gICAgICBjb25zdCBjaGVja2JveCA9IGNoZWNrYm94Q29udGFpbmVyLmNyZWF0ZUVsKCdpbnB1dCcsIHtcbiAgICAgICAgdHlwZTogJ2NoZWNrYm94JyxcbiAgICAgICAgYXR0cjoge1xuICAgICAgICAgIGlkOiBgc3JjLWNoZWNrYm94LSR7c3JjLnBhdGh9YCxcbiAgICAgICAgICBjaGVja2VkOiB0aGlzLnNlbGVjdGVkU3JjUGF0aHMuaGFzKHNyYy5wYXRoKSA/ICdjaGVja2VkJyA6IG51bGxcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgY2hlY2tib3guYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICBpZiAoY2hlY2tib3guY2hlY2tlZCkge1xuICAgICAgICAgIHRoaXMuc2VsZWN0ZWRTcmNQYXRocy5hZGQoc3JjLnBhdGgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3RlZFNyY1BhdGhzLmRlbGV0ZShzcmMucGF0aClcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZnJlc2hDYWxlbmRhcigpXG4gICAgICB9KVxuXG4gICAgICBjaGVja2JveENvbnRhaW5lci5jcmVhdGVFbCgnbGFiZWwnLCB7XG4gICAgICAgIHRleHQ6IHNyYy5wYXRoLFxuICAgICAgICBhdHRyOiB7Zm9yOiBgc3JjLWNoZWNrYm94LSR7c3JjLnBhdGh9YH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBpc1BhdGhJbkFjdGl2ZVNyYyhwYWdlUGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZXZlbnRTcmMuc29tZShcbiAgICAgIHNyYyA9PiBzcmMuaW5jbHVkZXMocGFnZVBhdGgpXG4gICAgKVxuICB9XG5cbiAgcHJpdmF0ZSByZWZyZXNoQ2FsZW5kYXIoKSB7XG4gICAgaWYgKCF0aGlzLmNhbGVuZGFyKVxuICAgICAgcmV0dXJuXG5cbiAgICB0aGlzLmNhbGVuZGFyLnJlbW92ZUFsbEV2ZW50cygpXG5cbiAgICBjb25zdCBldmVudHM6IElFdmVudFtdID0gW11cbiAgICBmb3IgKGxldCBwYWdlIG9mIHRoaXMubG9jYWxTdG9yYWdlKSB7XG4gICAgICBpZiAoICF0aGlzLmlzUGF0aEluQWN0aXZlU3JjKHBhZ2UuZmlsZS5wYXRoKSApXG4gICAgICAgIGNvbnRpbnVlXG5cbiAgICAgIGV2ZW50cy5wdXNoKCAuLi50aGlzLnBhZ2VUb0V2ZW50cyhwYWdlKSApXG4gICAgfVxuXG4gICAgZm9yIChsZXQgZXZlbnQgb2YgZXZlbnRzKSB7XG4gICAgICB0aGlzLmNhbGVuZGFyLmFkZEV2ZW50KGV2ZW50KVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgcmVuZGVyKGNvbnRhaW5lcjogRWxlbWVudCkgIHtcbiAgICBjb25zdCBzdWJzY3JpYmVkRGF0YSA9IGF3YWl0IHRoaXMuY2FjaGUuc3Vic2NyaWJlKHRoaXMuaWRGb3JDYWNoZSwgdGhpcy5ldmVudFNyYywgdGhpcylcbiAgICB0aGlzLmxvY2FsU3RvcmFnZSA9IHN1YnNjcmliZWREYXRhXG5cbiAgICBjb25zdCBldmVudHM6IElFdmVudFtdID0gW11cbiAgICBmb3IgKGNvbnN0IHBhZ2Ugb2Ygc3Vic2NyaWJlZERhdGEpIHtcbiAgICAgIGlmICghdGhpcy5zZWxlY3RlZFNyY1BhdGhzLmhhcyhwYWdlLmZpbGUucGF0aCkpXG4gICAgICAgIGNvbnRpbnVlXG5cbiAgICAgIGV2ZW50cy5wdXNoKCAuLi50aGlzLnBhZ2VUb0V2ZW50cyhwYWdlKSApXG4gICAgfVxuXG4gICAgdGhpcy5jYWxlbmRhciA9IHJlbmRlckNhbGVuZGFyKFxuICAgICAgY29udGFpbmVyIGFzIEhUTUxFbGVtZW50LFxuICAgICAge1xuICAgICAgICAvL0B0cy1pZ25vcmUgLy8gVE9ETyByZW1vdmVcbiAgICAgICAgZXZlbnRzOiBbXG4gICAgICAgICAgLi4udGhpcy5jYWxlbmRhclNldHRpbmdzLnJlc3RUaW1lLFxuICAgICAgICAgIC4uLmV2ZW50c1xuICAgICAgICBdXG4gICAgICB9LC8vIGFzIEV2ZW50U291cmNlLFxuICAgICAgICB0aGlzLmdldFNldHRpbmdzQ2FsZW5kYXIoKSxcbiAgICApXG4gICAgdGhpcy5jYWxlbmRhci5zZXRPcHRpb24oJ3dlZWtOdW1iZXJzJywgdHJ1ZSlcblxuICAgIC8vIE5PVEUgdG8gZml4IGJ1ZyBmaXJzdCByZW5kZXJcbiAgICB3aW5kb3cuc2V0VGltZW91dChcbiAgICAgIChfOiBhbnkpID0+IHtcbiAgICAgICAgaWYgKFBsYXRmb3JtLmlzTW9iaWxlKVxuICAgICAgICAgIHRoaXMuY2FsZW5kYXI/LmNoYW5nZVZpZXcoJ3RpbWVHcmlkM0RheXMnKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgdGhpcy5jYWxlbmRhcj8uY2hhbmdlVmlldygndGltZUdyaWRXZWVrJylcbiAgICAgIH0sIDFcbiAgICApXG4gICAgdGhpcy5jYWxlbmRhci5yZW5kZXIoKVxuICB9XG5cbiAgcHJpdmF0ZSBnZXRTZXR0aW5nc0NhbGVuZGFyKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIGZpcnN0RGF5OiAxLFxuICAgICAgd2Vla051bWJlcnM6IHRydWUsXG4gICAgICB0aW1lRm9ybWF0MjRoOiB0cnVlLFxuXG4gICAgICAvLyBUT0RPIHJlbW92ZSBhbnlcbiAgICAgIGV2ZW50Q2xpY2s6IChhcmc6IGFueSkgPT4ge1xuICAgICAgICBjb25zdCB7ZXZlbnQsIGpzRXZlbnR9ID0gYXJnXG4gICAgICAgIHRoaXMubm90ZU1hbmFnZXIub3Blbk5vdGUoZXZlbnQpXG4gICAgICB9LFxuXG4gICAgICAvLyBUT0RPIHJlbW92ZSBhbnlcbiAgICAgIG1vZGlmeUV2ZW50OiBhc3luYyAobmV3UG9zOiBhbnksIG9sZFBvczogYW55KSA9PiB7XG4gICAgICAgIGNvbnN0IHByb3BzID0gbmV3UG9zLmV4dGVuZGVkUHJvcHNcblxuICAgICAgICBjb25zdCBldmVudDogQ2FsZW5kYXJFdmVudCA9IHtcbiAgICAgICAgICBzdGFydDogbmV3UG9zLnN0YXJ0LFxuICAgICAgICAgIGVuZDogbmV3UG9zLmVuZCxcbiAgICAgICAgICBhbGxEYXk6IG5ld1Bvcy5hbGxEYXlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9wcy5ub3RlUGF0aCkge1xuICAgICAgICAgIGNvbnN0IHBhZ2UgPSB0aGlzLmNhY2hlLmdldFBhZ2UocHJvcHMubm90ZVBhdGgpXG5cbiAgICAgICAgICBpZiAoIXBhZ2UpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHtNU0dfUExHX05BTUV9OiBjYW4ndCBmaW5kIHBhZ2UgYnkgRXZlbnQuIGV2ZW50SUQ6ICR7cHJvcHMubm90ZVBhdGh9YClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHRpY2sgPSBwYWdlLnRpY2tzLmZpbmQoXG4gICAgICAgICAgICBlbCA9PiBlbC5uYW1lID09IHByb3BzLnRpY2tOYW1lXG4gICAgICAgICAgKVxuICAgICAgICAgIGlmICghdGljaykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGAke01TR19QTEdfTkFNRX06IGNhbid0IGZpbmQgdGljayBieSBwYWdlLiBQYWdlIC0gdGlja05hbWU6ICR7cHJvcHMubm90ZVBhdGh9IC0gJHtwcm9wcy50aWNrTmFtZX1gKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRpY2suZmZfZHVyYXRpb24gJiYgb2xkUG9zLmFsbERheSAmJiAhbmV3UG9zLmFsbERheSkge1xuICAgICAgICAgICAgZXZlbnQuZW5kID0gdGltZUFkZChuZXdQb3Muc3RhcnQsIHRpY2suZmZfZHVyYXRpb24pXG4gICAgICAgICAgICBuZXdQb3Muc2V0RW5kKGV2ZW50LmVuZClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBuZXdQcm9wID0gQ2FsZW5kYXJFdmVudFRvSURhdGUoZXZlbnQpXG4gICAgICAgICAgaWYgKG5ld1Bvcy5hbGxEYXkpIHtcbiAgICAgICAgICAgIG5ld1Byb3BbJ2ZmX2R1cmF0aW9uJ10gPSBtaWxsaXNlY1RvU3RyaW5nKFxuICAgICAgICAgICAgICB0aWNrLmZmX2R1cmF0aW9uPy5hcyhcIm1pbGxpc2Vjb25kc1wiKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMubm90ZU1hbmFnZXIuY2hhbmdlVGlja0ZpbGUocHJvcHMubm90ZVBhdGgsIHByb3BzLnRpY2tOYW1lLCBuZXdQcm9wKVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHBhZ2UgPSB0aGlzLmNhY2hlLmdldFBhZ2UobmV3UG9zLmlkKVxuXG4gICAgICAgICAgaWYgKCFwYWdlKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7TVNHX1BMR19OQU1FfTogY2FuJ3QgZmluZCBwYWdlIGJ5IEV2ZW50LiBldmVudElEOiAke25ld1Bvcy5pZH1gKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHBhZ2UuZmZfZHVyYXRpb24gJiYgb2xkUG9zLmFsbERheSAmJiAhbmV3UG9zLmFsbERheSkge1xuICAgICAgICAgICAgZXZlbnQuZW5kID0gdGltZUFkZChuZXdQb3Muc3RhcnQsIHBhZ2UuZmZfZHVyYXRpb24pXG4gICAgICAgICAgICBuZXdQb3Muc2V0RW5kKGV2ZW50LmVuZClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBuZXdQcm9wID0gQ2FsZW5kYXJFdmVudFRvSURhdGUoZXZlbnQpXG4gICAgICAgICAgaWYgKG5ld1Bvcy5hbGxEYXkpIHtcbiAgICAgICAgICAgIG5ld1Byb3BbJ2ZmX2R1cmF0aW9uJ10gPSBtaWxsaXNlY1RvU3RyaW5nKFxuICAgICAgICAgICAgICBwYWdlLmZmX2R1cmF0aW9uPy5hcyhcIm1pbGxpc2Vjb25kc1wiKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMubm90ZU1hbmFnZXIuY2hhbmdlUHJvcGVydHlGaWxlKG5ld1Bvcy5pZCwgbmV3UHJvcClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9LFxuICAgICAgc2VsZWN0OiAoc3RhcnQ6IERhdGUsIGVuZDogRGF0ZSwgYWxsRGF5OiBib29sZWFuLCBfX3ZpZXdNb2RlOiBhbnkpID0+IHtcbiAgICAgICAgbmV3IG5hbWVNb2RhbChcbiAgICAgICAgICB0aGlzLmFwcCxcbiAgICAgICAgICBhc3luYyAobmFtZU9mRmlsZTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoIW5hbWVPZkZpbGUpXG4gICAgICAgICAgICAgICAgdGhyb3cgMVxuXG4gICAgICAgICAgICAgIGNvbnN0IHBhdGhPZkZpbGUgPSB0aGlzLnBsYWNlRm9yQ3JlYXRpbmdOb3RlICsgYC8ke25hbWVPZkZpbGV9Lm1kYFxuICAgICAgICAgICAgICBhd2FpdCB0aGlzLm5vdGVNYW5hZ2VyLmNyZWF0ZUZpbGUocGF0aE9mRmlsZSlcblxuICAgICAgICAgICAgICBzZXRUaW1lb3V0KFxuICAgICAgICAgICAgICAgICgpID0+IHRoaXMubm90ZU1hbmFnZXIuY2hhbmdlUHJvcGVydHlGaWxlKFxuICAgICAgICAgICAgICAgICAgcGF0aE9mRmlsZSxcbiAgICAgICAgICAgICAgICAgIENhbGVuZGFyRXZlbnRUb0lEYXRlKHtzdGFydCwgZW5kLCBhbGxEYXl9KVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgMTUwMFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpXG4gICAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJIbS4uLiBlcnJvci4uLlwiKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKS5vcGVuKClcbiAgICAgIH0sXG4gICAgICBvcGVuQ29udGV4dE1lbnVGb3JFdmVudDogKGU6IElFdmVudCwgbW91c2VFdmVudDogTW91c2VFdmVudCkgPT4ge1xuICAgICAgICB0aGlzLmNvbnRleHRNZW51Rm9yRXZlbnQoZSwgbW91c2VFdmVudClcbiAgICAgIH0sXG4gICAgICBzbG90RHVyYXRpb246IHRoaXMuY2FsZW5kYXJTZXR0aW5ncy5zbG90RHVyYXRpb25cbiAgICB9XG5cbiAgICBpZiAoUGxhdGZvcm0uaXNNb2JpbGUpIHtcbiAgICAgIHJlc3VsdC5ldmVudENsaWNrID0gKGFyZzogYW55KSA9PiB7XG4gICAgICAgIGNvbnN0IHtldmVudCwganNFdmVudH0gPSBhcmdcbiAgICAgICAgdGhpcy5jb250ZXh0TWVudUZvckV2ZW50KGV2ZW50LCBqc0V2ZW50KVxuICAgICAgfVxuICAgICAgcmVzdWx0Lm9wZW5Db250ZXh0TWVudUZvckV2ZW50ID0gKF86SUV2ZW50LCBfXzpNb3VzZUV2ZW50KSA9PiB7fVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIHByaXZhdGUgY29udGV4dE1lbnVGb3JFdmVudChldmVudDogSUV2ZW50LCBtb3VzZUV2ZW50OiBNb3VzZUV2ZW50KSB7XG4gICAgY29uc3QgbWVudSA9IG5ldyBNZW51XG5cbiAgICBtZW51LmFkZEl0ZW0oXG4gICAgICAoaXRlbSkgPT4gaXRlbS5zZXRUaXRsZShldmVudC5pZClcbiAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4gdGhpcy5ub3RlTWFuYWdlci5vcGVuTm90ZShldmVudCkpXG4gICAgKVxuXG4gICAgbWVudS5zaG93QXRNb3VzZUV2ZW50KG1vdXNlRXZlbnQpXG4gIH1cbn1cblxuY2xhc3MgbmFtZU1vZGFsIGV4dGVuZHMgTW9kYWwge1xuICBwcml2YXRlIHJlc3VsdDogc3RyaW5nXG4gIHByaXZhdGUgb25TdWJtaXQ6IEZ1bmN0aW9uXG5cbiAgY29uc3RydWN0b3IoYXBwOiBBcHAsIG9uU3VibWl0OiBGdW5jdGlvbikge1xuICAgIHN1cGVyKGFwcCk7XG4gICAgdGhpcy5vblN1Ym1pdCA9IG9uU3VibWl0O1xuICB9XG5cbiAgb25PcGVuKCkge1xuICAgIGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzXG5cbiAgICBjb250ZW50RWwuY3JlYXRlRWwoXCJoMVwiLCB7IHRleHQ6IFwiTmFtZSBvZiB0YXNrXCIgfSlcblxuICAgIG5ldyBTZXR0aW5nKGNvbnRlbnRFbClcbiAgICAuc2V0TmFtZShcIk5hbWVcIilcbiAgICAuYWRkVGV4dChcbiAgICAgIHRleHQgPT4gdGV4dC5vbkNoYW5nZSh2YWx1ZSA9PiB0aGlzLnJlc3VsdCA9IHZhbHVlKVxuICAgIClcblxuICAgIG5ldyBTZXR0aW5nKGNvbnRlbnRFbClcbiAgICAuYWRkQnV0dG9uKFxuICAgICAgKGJ0bikgPT4gYnRuLnNldEJ1dHRvblRleHQoXCJTdWJtaXRcIilcbiAgICAgICAgLnNldEN0YSgpXG4gICAgICAgIC5vbkNsaWNrKCgpID0+IHtcbiAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgdGhpcy5vblN1Ym1pdCh0aGlzLnJlc3VsdCk7XG4gICAgICAgIH0pKTtcbiAgfVxuXG4gIG9uQ2xvc2UoKSB7XG4gICAgdGhpcy5jb250ZW50RWwuZW1wdHkoKTtcbiAgfVxufVxuIiwgImltcG9ydCB7IERVUkFUSU9OX1RZUEVTIH0gZnJvbSBcIm9ic2lkaWFuLWRhdGF2aWV3XCJcblxuZXhwb3J0IGNsYXNzIFNyYyB7XG4gIGNvbnN0cnVjdG9yKHBhdGg6IHN0cmluZykge1xuICAgIHRoaXMuX3BhdGggPSBwYXRoO1xuICAgIHRoaXMuX2V4Y2x1ZGVzID0gW107XG4gIH1cblxuICBwdWJsaWMgYWRkRXhjbHVkZXMoZXhjbHVkZXM6IHN0cmluZ1tdKTogYm9vbGVhbiB7XG4gICAgY29uc3QgaXNPayA9IGV4Y2x1ZGVzLmV2ZXJ5KFxuICAgICAgZXhjbHVkZSA9PiB7XG4gICAgICAgIGlmICghZXhjbHVkZS5zdGFydHNXaXRoKHRoaXMuX3BhdGgpKVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuXG4gICAgICAgIGlmIChleGNsdWRlICE9PSB0aGlzLl9wYXRoKVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgKVxuXG4gICAgaWYgKCFpc09rKVxuICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgICB0aGlzLl9leGNsdWRlcy5wdXNoKC4uLmV4Y2x1ZGVzKVxuICAgIHRoaXMuX2V4Y2x1ZGVzID0gdGhpcy5fZXhjbHVkZXMudW5pcXVlKClcblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBwdWJsaWMgaW5jbHVkZXMocGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgaWYgKCAhcGF0aC5zdGFydHNXaXRoKHRoaXMuX3BhdGgpICkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9leGNsdWRlcy5sZW5ndGgpXG4gICAgICByZXR1cm4gdHJ1ZVxuXG4gICAgcmV0dXJuIHRoaXMuX2V4Y2x1ZGVzLnNvbWUoXG4gICAgICBleGNsdWRlID0+IHtcbiAgICAgICAgcGF0aC5zdGFydHNXaXRoKGV4Y2x1ZGUpXG4gICAgICB9XG4gICAgKVxuICB9XG5cbiAgcHJpdmF0ZSBfcGF0aDogc3RyaW5nO1xuXG4gIGdldCBwYXRoKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX3BhdGg7XG4gIH1cblxuICBwcml2YXRlIF9leGNsdWRlczogc3RyaW5nW107XG5cbiAgZ2V0IGV4Y2x1ZGVzKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gc3RydWN0dXJlZENsb25lKHRoaXMuX2V4Y2x1ZGVzKTtcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBDYWxlbmRhclNldHRpbmdzID0ge1xuICAgIHNsb3REdXJhdGlvbjogc3RyaW5nLFxuICAgIGNvbG91cnM6IHtcbiAgICAgIGZyZXF1ZW5jeTogc3RyaW5nLFxuICAgICAgZG9uZSAgICAgOiBzdHJpbmcsXG4gICAgICB0aWNrICAgICA6IHN0cmluZyxcbiAgICAgIGRlZmF1bHQgIDogc3RyaW5nLFxuICAgIH0sXG4gICAgcmVzdFRpbWU6IHtcbiAgICAgICAgc3RhcnRUaW1lOiBzdHJpbmcsXG4gICAgICAgIGVuZFRpbWU6IHN0cmluZyxcbiAgICAgICAgY29sb3I6IHN0cmluZyxcblxuICAgICAgICAvLyBUT0RPIHJlbW92ZSBhbnlcbiAgICAgICAgZGF5c09mV2VlazphbnksZGlzcGxheTphbnksXG4gICAgfVtdXG4gIH1cblxuZXhwb3J0IHR5cGUgUGx1Z2luU2V0dGluZ3MgPSB7XG4gIHN0YXR1c0NvcnJlY3Rvcjoge1xuICAgIGlzT246IGJvb2xlYW4sXG4gICAgc3RhcnRPblN0YXJ0VXA6IGJvb2xlYW5cbiAgfSxcbiAgY2FsZW5kYXI6IENhbGVuZGFyU2V0dGluZ3MsXG4gIHNvdXJjZToge1xuICAgIG5vdGVTb3VyY2VzOiBTcmNbXSxcblxuICAgIC8vIE5PVEUgZGVmYXVsdCBwYXRoIHdoZXJlIG5vdGUgd2lsbCBiZSBjcmVhdGVkXG4gICAgZGVmYXVsdENyZWF0ZVBhdGg6IHN0cmluZ1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSURhdGUge1xuICAvLyBUT0RPIGRhdGUgXHUwNDNDXHUwNDNFXHUwNDM2XHUwNDM1XHUwNDQyIFx1MDQzOCBcdTA0M0RcdTA0MzUgXHUwNDMxXHUwNDRCXHUwNDQyXHUwNDRDIChcdTA0NDFcdTA0M0MuIGZpbGVNYW5hZ2VyLnRzL2dldFBhZ2UpXG4gIGZmX2RhdGU6IERhdGVcbiAgZmZfdGltZVN0YXJ0OiBEVVJBVElPTl9UWVBFU1xuICBmZl9kdXJhdGlvbjogRFVSQVRJT05fVFlQRVNcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJVGljayBleHRlbmRzIElEYXRlIHtcbiAgbmFtZTogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVBhZ2UgZXh0ZW5kcyBJRGF0ZSB7XG4gIGZpbGU6IHtcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgbmFtZTogc3RyaW5nXG4gIH0sXG4gIHRpY2tzOiBJVGlja1tdXG4gIGZmX2ZyZXF1ZW5jeT86IHN0cmluZ1xuICBmZl9zdGF0dXM/OiBzdHJpbmdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJRXZlbnQge1xuICBzdGFydDogRGF0ZVxuICBlbmQ/OiBEYXRlXG4gIGlkOiBzdHJpbmdcbiAgdGl0bGU6IHN0cmluZ1xuICBhbGxEYXk6IGJvb2xlYW5cbiAgY29sb3I/OiBzdHJpbmdcbiAgYm9yZGVyQ29sb3I6IHN0cmluZ1xuICBlZGl0YWJsZTogYm9vbGVhblxuICBleHRlbmRlZFByb3BzPzoge1xuICAgIHRpY2tOYW1lOiBzdHJpbmdcbiAgICBub3RlUGF0aDogc3RyaW5nXG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDYWxlbmRhckV2ZW50IHtcbiAgc3RhcnQ6IERhdGVcbiAgYWxsRGF5OiBib29sZWFuXG4gIGVuZD86IERhdGVcbn1cblxuLy8gSU5GTyBcdTA0NERcdTA0NDJcdTA0M0UgXHUwNDM4XHUwNDNEXHUwNDQyXHUwNDM1XHUwNDQwXHUwNDQ0XHUwNDM1XHUwNDM5XHUwNDQxIFx1MDQzNFx1MDQzQlx1MDQ0RiBDYWNoZVxuZXhwb3J0IGludGVyZmFjZSBJU3Vic2NyaWJlciB7XG4gIHJlc2V0KCk6IHZvaWRcbiAgYWRkRmlsZShfOiBJUGFnZSk6IHZvaWRcbiAgZGVsZXRlRmlsZShfOiBJUGFnZSk6IHZvaWRcbiAgY2hhbmdlRmlsZShuZXdQYWdlOiBJUGFnZSwgb2xkUGFnZTogSVBhZ2UpOiB2b2lkXG4gIHJlbmFtZUZpbGUobmV3UGFnZTogSVBhZ2UsIG9sZFBhZ2U6IElQYWdlKTogdm9pZFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIElUYXNrcyB7XG4gIGRvbmU6IG51bWJlcixcbiAgYWxsOiBudW1iZXJcbn1cbiIsICJpbXBvcnQgeyBQbHVnaW5TZXR0aW5ncywgU3JjIH0gZnJvbSBcIi4vdHlwZXNcIlxuXG5leHBvcnQgY29uc3QgTVNHX1BMR19OQU1FID0gXCJNeUNhbGVuZGFyXCJcblxuY29uc3QgRVZFTlRfU1JDID0gXCJkYXRhYmFzZXNcIlxuY29uc3QgUExBQ0VfRk9SX0NSRUFUSU5HX05PVEUgPSBcImRhdGFiYXNlc1wiXG5cbmNvbnN0IGRheXNPZldlZWsgPSBbICcxJywnMicsJzMnLCc0JywnNScsJzYnLCcwJyBdIC8vIHRoZXNlIHJlY3VycmVudCBldmVudHMgbW92ZSBzZXBhcmF0ZWx5XG5jb25zdCBkaXNwbGF5ID0gJ2JhY2tncm91bmQnXG5leHBvcnQgY29uc3QgQ09MT1VSX1JFU1QgID0gJyMzMDVCNjAnXG5leHBvcnQgY29uc3QgQ09MT1VSX1NMRUVQID0gJyNjYzAwMDAnXG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX1NFVFRJTkdTOiBQbHVnaW5TZXR0aW5ncyA9IHtcbiAgc3RhdHVzQ29ycmVjdG9yOiB7XG4gICAgaXNPbjogdHJ1ZSxcbiAgICBzdGFydE9uU3RhcnRVcDogdHJ1ZVxuICB9LFxuICBjYWxlbmRhcjoge1xuICAgIHNsb3REdXJhdGlvbjogXCIwMDozMDowMFwiLFxuICAgIGNvbG91cnM6IHtcbiAgICAgIGZyZXF1ZW5jeTogXCIjOEExNzE3XCIsXG4gICAgICBkb25lICAgICA6IFwiIzAwOEUwNFwiLFxuICAgICAgdGljayAgICAgOiBcIiM0NTdFN0VcIixcbiAgICAgIGRlZmF1bHQgIDogXCIjNWUzZmE4XCIsXG4gICAgfSxcbiAgICByZXN0VGltZTogW1xuICAgICAge2RheXNPZldlZWssZGlzcGxheSxcbiAgICAgICAgICBzdGFydFRpbWU6ICcwOjAwOjAwJyxcbiAgICAgICAgICBlbmRUaW1lOiAnODowMDowMCcsXG4gICAgICAgICAgY29sb3I6IENPTE9VUl9TTEVFUCxcbiAgICAgIH0sXG4gICAgICB7ZGF5c09mV2VlayxkaXNwbGF5LFxuICAgICAgICAgIHN0YXJ0VGltZTogJzI0OjAwOjAwJyxcbiAgICAgICAgICBlbmRUaW1lOiAnMjQ6MDA6MDAnLFxuICAgICAgICAgIGNvbG9yOiBDT0xPVVJfU0xFRVAsXG4gICAgICB9LFxuICAgICAge2RheXNPZldlZWssZGlzcGxheSxcbiAgICAgICAgICBzdGFydFRpbWU6ICcwOjAwOjAwJyxcbiAgICAgICAgICBlbmRUaW1lOiAnODozMDowMCcsXG4gICAgICAgICAgY29sb3I6IENPTE9VUl9SRVNULFxuICAgICAgfSxcbiAgICAgIHtkYXlzT2ZXZWVrLGRpc3BsYXksXG4gICAgICAgICAgc3RhcnRUaW1lOiAnMjM6MDA6MDAnLFxuICAgICAgICAgIGVuZFRpbWU6ICcyNDowMDowMCcsXG4gICAgICAgICAgY29sb3I6IENPTE9VUl9SRVNULFxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAgc291cmNlOiB7XG4gICAgbm90ZVNvdXJjZXM6IFtuZXcgU3JjKEVWRU5UX1NSQyldLFxuXG4gICAgLy8gTk9URSBkZWZhdWx0IHBhdGggd2hlcmUgbm90ZSB3aWxsIGJlIGNyZWF0ZWRcbiAgICBkZWZhdWx0Q3JlYXRlUGF0aDogUExBQ0VfRk9SX0NSRUFUSU5HX05PVEVcbiAgfVxuXG59XG5cbmV4cG9ydCBlbnVtIENBQ0hFX0lEIHtcbiAgQ0FMRU5EQVIgPSAxLFxuICBTVEFUVVNfQ09SUkVDVE9SLFxuICBUSUNLX0NIRUNLRVJcbn1cblxuZXhwb3J0IGNvbnN0IFZJRVdfVFlQRSA9IFwibXktb2JzaWRpYW4tY2FsZW5kYXItcGx1Z2luXCJcblxuXG4vLyBUT0RPIFx1MDQzRlx1MDQzNVx1MDQ0MFx1MDQzNVx1MDQzNFx1MDQzNVx1MDQzQlx1MDQzMFx1MDQ0Mlx1MDQ0QyBcdTA0MzIgVEVYVCA9IHtET05FLi4uQkxPQ0tFRH1cbmV4cG9ydCBjb25zdCBURVhUX0RPTkUgPSBcIlx1RDgzRFx1REZFMmRvbmVcIlxuZXhwb3J0IGNvbnN0IFRFWFRfSU5fUFJPR1JFU1MgPSBcIlx1RDgzRFx1REQzNWluIHByb2dyZXNzXCJcbmV4cG9ydCBjb25zdCBURVhUX1NPT04gPSBcIlx1RDgzRFx1REZFM3Nvb25cIlxuZXhwb3J0IGNvbnN0IFRFWFRfQ0hJTERfSU5fUFJPR1JFU1MgPSBcIlx1RDgzRFx1REZFMVx1RDgzRFx1REZFNmNoaWxkIGluIHByb2dyZXNzXCJcbmV4cG9ydCBjb25zdCBURVhUX0JMT0NLRUQgPSBcIlx1RDgzRFx1REZFMWJsb2NrZWRcIlxuXG5leHBvcnQgY29uc3QgRk9STUFUX0RBWSA9ICdkJ1xuZXhwb3J0IGNvbnN0IEZPUk1BVF9IT1VSID0gJ2gnXG5leHBvcnQgY29uc3QgRk9STUFUX01JTlVURSA9ICdtJ1xuXG5leHBvcnQgY29uc3QgQkFDS0dST1VORF9DT0xPVVIgPSB7XG4gICAgaHVlOiB7XG4gICAgICAgIHNoaWZ0OiAwLFxuICAgICAgICBtaW46IDAsXG4gICAgICAgIG1heDogMzYwXG4gICAgfSxcbiAgICBzYXR1cmF0aW9uOiB7XG4gICAgICAgIHNoaWZ0OiAwLFxuICAgICAgICBtaW46IDcwLFxuICAgICAgICBtYXg6IDkwXG4gICAgfSxcbiAgICBsaWdodG5lc3M6IHtcbiAgICAgICAgc2hpZnQ6IDAsXG4gICAgICAgIG1pbjogMzAsXG4gICAgICAgIG1heDogNTBcbiAgICB9XG59XG5cblxuY29uc3QgTWlsbGlzZWNzSW5TZWNvbmQgPSAxMDAwXG5jb25zdCBTZWNzSW5NaW51dGUgPSA2MFxuY29uc3QgTWludXRlc0luSG91ciA9IDYwXG5leHBvcnQgY29uc3QgSG91cnNJbkRheSA9IDI0XG5leHBvcnQgY29uc3QgTWlsbGlzZWNzSW5NaW51dGUgPSBNaWxsaXNlY3NJblNlY29uZCAqIFNlY3NJbk1pbnV0ZVxuZXhwb3J0IGNvbnN0IE1pbGxpc2Vjc0luSG91ciA9IE1pbGxpc2Vjc0luTWludXRlICogTWludXRlc0luSG91clxuZXhwb3J0IGNvbnN0IE1pbGxpc2Vjc0luRGF5ID0gTWlsbGlzZWNzSW5Ib3VyICogSG91cnNJbkRheVxuIiwgImltcG9ydCB7IElQYWdlLCBJVGljaywgSURhdGUsIENhbGVuZGFyRXZlbnQsIElUYXNrcywgSUV2ZW50IH0gZnJvbSBcIi4vdHlwZXNcIjtcbmltcG9ydCB7IERhdGF2aWV3QXBpIH0gZnJvbSBcIm9ic2lkaWFuLWRhdGF2aWV3L2xpYi9hcGkvcGx1Z2luLWFwaVwiXG5pbXBvcnQgeyBnZXRBUEkgfSBmcm9tIFwib2JzaWRpYW4tZGF0YXZpZXdcIlxuaW1wb3J0IHsgRFVSQVRJT05fVFlQRVMgfSBmcm9tIFwib2JzaWRpYW4tZGF0YXZpZXdcIlxuXG5pbXBvcnQge1xuICBURVhUX0RPTkUsXG4gIE1pbGxpc2Vjc0luSG91cixcbiAgTWlsbGlzZWNzSW5EYXksXG4gIE1pbGxpc2Vjc0luTWludXRlLFxuICBGT1JNQVRfREFZLFxuICBGT1JNQVRfSE9VUixcbiAgRk9STUFUX01JTlVURSxcbiAgQkFDS0dST1VORF9DT0xPVVIsXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5pbXBvcnQgTXlQbHVnaW4gZnJvbSBcIi4vbWFpblwiO1xuaW1wb3J0IHsgQ2FjaGUgfSBmcm9tIFwiLi9jYWNoZVwiO1xuaW1wb3J0IE5vdGVNYW5hZ2VyIGZyb20gXCIuL05vdGVNYW5hZ2VyXCI7XG5cbmNvbnN0IFNMRUVQX1RJTUUgPSAxMDAwIC8vIG1zXG5cbmV4cG9ydCBjb25zdCBkdiA9IGdldEFQSSgpIGFzIERhdGF2aWV3QXBpXG5cbmZ1bmN0aW9uIHBhdGhUb0ZpbGVXaXRob3V0RmlsZU5hbWUocGF0aDogc3RyaW5nKSB7XG4gIGNvbnN0IHBhdGhfc2VwYXJhdG9yID0gcGF0aC5sYXN0SW5kZXhPZihcIi9cIik7XG4gIGlmIChwYXRoX3NlcGFyYXRvciAhPT0gLTEpXG4gICAgcmV0dXJuIHBhdGguc2xpY2UoMCwgcGF0aF9zZXBhcmF0b3IpO1xuICByZXR1cm4gXCJcIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIElEYXRlVG9DYWxlbmRhckV2ZW50KGFyZ3M6IElEYXRlKTogQ2FsZW5kYXJFdmVudCB7XG4gIGNvbnN0IHN0cnVjdHVyZTogQ2FsZW5kYXJFdmVudCA9IHtcbiAgICBzdGFydDogbmV3IERhdGUoYXJncy5mZl9kYXRlKSxcbiAgICBhbGxEYXk6IGZhbHNlLFxuICB9XG5cbiAgaWYgKGFyZ3MuZmZfZHVyYXRpb24pIHtcbiAgICBzdHJ1Y3R1cmUuc3RhcnQuc2V0SG91cnMgIChhcmdzLmZmX3RpbWVTdGFydD8udmFsdWVzPy5ob3VycyAgIHx8IDApXG4gICAgc3RydWN0dXJlLnN0YXJ0LnNldE1pbnV0ZXMoYXJncy5mZl90aW1lU3RhcnQ/LnZhbHVlcz8ubWludXRlcyB8fCAwKVxuXG4gICAgbGV0IHRtcFRpbWUgPSBuZXcgRGF0ZShzdHJ1Y3R1cmUuc3RhcnQpXG4gICAgaWYgKGFyZ3MuZmZfZHVyYXRpb24/LnZhbHVlcz8ubWludXRlcyB8fCBhcmdzLmZmX2R1cmF0aW9uPy52YWx1ZXM/LmhvdXJzIHx8IGFyZ3MuZmZfZHVyYXRpb24/LnZhbHVlcz8uZGF5cykge1xuICAgICAgY29uc3QgZHVyYXRpb24gPSBhcmdzLmZmX2R1cmF0aW9uLnZhbHVlc1xuXG4gICAgICB0bXBUaW1lLnNldE1pbnV0ZXMoXG4gICAgICAgIHRtcFRpbWUuZ2V0TWludXRlcygpICsgKGR1cmF0aW9uLm1pbnV0ZXMgfHwgMClcbiAgICAgIClcbiAgICAgIHRtcFRpbWUuc2V0SG91cnMoXG4gICAgICAgIHRtcFRpbWUuZ2V0SG91cnMoKSArIChkdXJhdGlvbi5ob3VycyB8fCAwKVxuICAgICAgKVxuICAgICAgdG1wVGltZS5zZXREYXRlKFxuICAgICAgICB0bXBUaW1lLmdldERhdGUoKSArIChkdXJhdGlvbi5kYXlzIHx8IDApXG4gICAgICApXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc3RydWN0dXJlLmFsbERheSA9IHRydWVcbiAgICB9XG5cbiAgICBpZiAoIWFyZ3MuZmZfdGltZVN0YXJ0Py52YWx1ZXMpXG4gICAgICBzdHJ1Y3R1cmUuYWxsRGF5ID0gdHJ1ZVxuXG4gICAgc3RydWN0dXJlLmVuZCA9IHRtcFRpbWVcbiAgfVxuICBlbHNlIGlmIChhcmdzLmZmX2R1cmF0aW9uKSB7XG4gICAgc3RydWN0dXJlLmFsbERheSA9IHRydWVcbiAgfVxuICBlbHNlIHN0cnVjdHVyZS5hbGxEYXkgPSB0cnVlXG5cbiAgcmV0dXJuIHN0cnVjdHVyZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gQ2FsZW5kYXJFdmVudFRvSURhdGUoZXZlbnQ6IENhbGVuZGFyRXZlbnQpOiBJRGF0ZSB7XG4gIGNvbnN0IHtzdGFydCwgZW5kLCBhbGxEYXl9ID0gZXZlbnRcbiAgLy8gISBcdTA0MzRcdTA0M0JcdTA0NEYgSVNPIChcdTA0M0VcdTA0M0QgXHUwNDNGXHUwNDM1XHUwNDQwXHUwNDM1XHUwNDMyXHUwNDNFXHUwNDM0XHUwNDM4XHUwNDQyIFx1MDQzMiBcdTA0MzNcdTA0NDBcdTA0MzhcdTA0M0RcdTA0MzJcdTA0MzhcdTA0NDcgXHUwNDNDXHUwNDNFXHUwNDM1IFx1MDQzMlx1MDQ0MFx1MDQzNVx1MDQzQ1x1MDQ0RilcbiAgLy8gXHUwNDRGIFx1MDQ0Mlx1MDQ0M1x1MDQ0MiBcdTA0MzNcdTA0M0VcdTA0MzJcdTA0M0VcdTA0NDBcdTA0NEUsIFx1MDQ0N1x1MDQ0Mlx1MDQzRSBcdTA0NEYgXHUwNDMyIFx1MDQzM1x1MDQ0MFx1MDQzOFx1MDQzRFx1MDQzMlx1MDQzOFx1MDQ0N1x1MDQzNVxuICBzdGFydC5zZXRNaW51dGVzKFxuICAgIHN0YXJ0LmdldE1pbnV0ZXMoKSAtIHN0YXJ0LmdldFRpbWV6b25lT2Zmc2V0KClcbiAgKVxuXG4gIGNvbnN0IHJlc3VsdDogSURhdGUgPSB7XG4gICAgZmZfZHVyYXRpb246IFwiXCIsXG4gICAgZmZfdGltZVN0YXJ0OiBcIlwiLFxuICAgIGZmX2RhdGU6IG5ldyBEYXRlKHN0YXJ0KVxuICB9XG5cbiAgLy8gISBcdTA0NDJcdTA0NDNcdTA0NDIgXHUwNDQzXHUwNDMxXHUwNDM4XHUwNDQwXHUwNDMwXHUwNDRFIFx1MDQzM1x1MDQ0MFx1MDQzOFx1MDQzRFx1MDQzMlx1MDQzOFx1MDQ0NyBcdTA0MzRcdTA0M0JcdTA0NEYgZ2V0J1x1MDQzNVx1MDQ0MFx1MDQzRVx1MDQzMiBcdTA0MzJcdTA0M0RcdTA0MzhcdTA0MzdcdTA0NDNcbiAgc3RhcnQuc2V0TWludXRlcyhcbiAgICBzdGFydC5nZXRNaW51dGVzKCkgKyBzdGFydC5nZXRUaW1lem9uZU9mZnNldCgpXG4gIClcblxuICBsZXQgc3JjTWlsbGlzZWMgPSBlbmRcbiAgLy8gQHRzLWlnbm9yZVxuICA/IGVuZCAtIHN0YXJ0XG4gIDogTWlsbGlzZWNzSW5Ib3VyXG5cbiAgaWYgKGFsbERheSkge1xuICAgIHJlc3VsdFsnZmZfdGltZVN0YXJ0J10gPSBcIlwiXG4gICAgaWYgKHNyY01pbGxpc2VjIDw9IE1pbGxpc2Vjc0luRGF5KVxuICAgICAgc3JjTWlsbGlzZWMgPSAwXG4gIH1cbiAgZWxzZVxuICAgIHJlc3VsdFsnZmZfdGltZVN0YXJ0J10gPSBzdGFydC5nZXRIb3VycygpICsgJ2gnICsgc3RhcnQuZ2V0TWludXRlcygpICsgJ20nXG5cbiAgcmVzdWx0WydmZl9kdXJhdGlvbiddID0gbWlsbGlzZWNUb1N0cmluZyhzcmNNaWxsaXNlYylcblxuICByZXR1cm4gcmVzdWx0XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUaWNrc0Zyb21UZXh0KHRleHQ6IHN0cmluZyk6IElUaWNrW10ge1xuICBjb25zdCByZXN1bHQgPSBbXVxuICBjb25zdCByZWdFeHBUaWNrcyA9IC9cXFt0OjouK1xcXS9nbVxuICBjb25zdCBtYXRjaGVzID0gdGV4dC5tYXRjaChyZWdFeHBUaWNrcylcblxuICBpZiAobWF0Y2hlcykgZm9yIChsZXQgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgIGNvbnN0IGFyZ3MgPSBtYXRjaC5zbGljZSgxLCAtMSkuc3BsaXQoXCI6OlwiKVsxXS5zcGxpdCgnLCcpXG4gICAgaWYgKCFhcmdzKVxuICAgICAgY29udGludWVcblxuICAgIGNvbnN0IG5hbWUgPSBhcmdzWzBdPy50cmltKClcbiAgICBjb25zdCBmZl9kYXRlID0gZHYuZGF0ZShhcmdzWzFdPy50cmltKCkpXG4gICAgY29uc3QgZmZfdGltZVN0YXJ0ID0gZHYuZHVyYXRpb24oYXJnc1syXT8udHJpbSgpKVxuXG4gICAgY29uc3QgdGVtcER1cmF0aW9uID0gYXJnc1szXT8udHJpbSgpXG4gICAgY29uc3QgZmZfZHVyYXRpb24gPSB0ZW1wRHVyYXRpb24gPT0gJ3gnXG4gICAgPyAneCdcbiAgICA6IGR2LmR1cmF0aW9uKGFyZ3NbM10/LnRyaW0oKSlcblxuICAgIGlmIChuYW1lID09ICcnKVxuICAgICAgY29udGludWVcblxuICAgIHJlc3VsdC5wdXNoKFxuICAgICAge25hbWUsIGZmX2RhdGUsIGZmX3RpbWVTdGFydCwgZmZfZHVyYXRpb259XG4gICAgKVxuXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWlsbGlzZWNUb1N0cmluZyhtaWxsaXNlYzpudW1iZXIpOiBzdHJpbmcge1xuICBjb25zdCBkYXlzID0gTWF0aC5mbG9vcihcbiAgICAgIG1pbGxpc2VjIC8gKE1pbGxpc2Vjc0luRGF5KVxuICApXG4gIG1pbGxpc2VjIC09IGRheXMgKiBNaWxsaXNlY3NJbkRheVxuXG4gIGNvbnN0IGhvdXJzID0gTWF0aC5mbG9vcihcbiAgICAgIG1pbGxpc2VjIC8gKE1pbGxpc2Vjc0luSG91cilcbiAgKVxuICBtaWxsaXNlYyAtPSBob3VycyAqIE1pbGxpc2Vjc0luSG91clxuXG4gIGNvbnN0IG1pbnV0ZXMgPSBNYXRoLmZsb29yKFxuICAgICAgbWlsbGlzZWMgLyAoTWlsbGlzZWNzSW5NaW51dGUpXG4gIClcbiAgbWlsbGlzZWMgLT0gbWludXRlcyAqIE1pbGxpc2Vjc0luTWludXRlXG5cbiAgbGV0IHJlc1N0cmluZyA9ICcnXG4gIGlmIChkYXlzKVxuICAgIHJlc1N0cmluZyArPSBkYXlzLnRvU3RyaW5nKCkgKyBGT1JNQVRfREFZXG4gIGlmIChob3VycylcbiAgICByZXNTdHJpbmcgKz0gaG91cnMudG9TdHJpbmcoKSArIEZPUk1BVF9IT1VSXG4gIGlmIChtaW51dGVzKVxuICAgIHJlc1N0cmluZyArPSBtaW51dGVzLnRvU3RyaW5nKCkgKyBGT1JNQVRfTUlOVVRFXG5cbiAgcmV0dXJuIHJlc1N0cmluZ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNFcXVhbE9iaihvYmplY3QxOmFueSwgb2JqZWN0MjphbnkpIHtcbiAgY29uc3Qga2V5czEgPSBPYmplY3Qua2V5cyhvYmplY3QxKTtcbiAgY29uc3Qga2V5czIgPSBPYmplY3Qua2V5cyhvYmplY3QyKTtcblxuICBpZiAoa2V5czEubGVuZ3RoICE9PSBrZXlzMi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzMSkge1xuICAgIGNvbnN0IHZhbDEgPSBvYmplY3QxW2tleV07XG4gICAgY29uc3QgdmFsMiA9IG9iamVjdDJba2V5XTtcbiAgICBjb25zdCBhcmVPYmplY3RzID0gaXNPYmplY3QodmFsMSkgJiYgaXNPYmplY3QodmFsMik7XG4gICAgaWYgKFxuICAgICAgYXJlT2JqZWN0cyAmJiAhaXNFcXVhbE9iaih2YWwxLCB2YWwyKSB8fFxuICAgICAgIWFyZU9iamVjdHMgJiYgdmFsMSAhPT0gdmFsMlxuICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChvYmplY3Q6IGFueSkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCc7XG59XG5cbi8vIFx1MDQzQVx1MDQzMFx1MDQzQVx1MDQzOFx1MDQzQyBcdTA0MzFcdTA0NDNcdTA0MzRcdTA0MzVcdTA0NDIgSUQgXHUwNDMyIFx1MDQzQVx1MDQzMFx1MDQzQlx1MDQzNVx1MDQzRFx1MDQzNFx1MDQzMFx1MDQ0MFx1MDQzNSBcdTA0NDJcdTA0MzhcdTA0M0FcbmV4cG9ydCBmdW5jdGlvbiB0ZW1wbGF0ZUlEVGljayhwYXRoOiBzdHJpbmcsIHRpY2tOYW1lOnN0cmluZykge1xuICByZXR1cm4gcGF0aCArIHRpY2tOYW1lXG59XG5cbi8vIFx1MDQzQVx1MDQzMFx1MDQzQSBcdTA0MzFcdTA0NDNcdTA0MzRcdTA0MzVcdTA0NDIgXHUwNDNFXHUwNDQyXHUwNDNFXHUwNDMxXHUwNDQwXHUwNDMwXHUwNDM2XHUwNDMwXHUwNDQyXHUwNDRDXHUwNDQxXHUwNDRGIFx1MDQzMiBcdTA0M0FcdTA0MzBcdTA0M0JcdTA0MzVcdTA0M0RcdTA0MzRcdTA0MzBcdTA0NDBcdTA0MzUgXHUwNDQyXHUwNDM4XHUwNDNBXG5leHBvcnQgZnVuY3Rpb24gdGVtcGxhdGVOYW1lVGljayhmaWxlTmFtZTogc3RyaW5nLCB0aWNrTmFtZTpzdHJpbmcpIHtcbiAgcmV0dXJuIFwiKFwiK2ZpbGVOYW1lK1wiKVwiICsgdGlja05hbWVcbn1cblxuZnVuY3Rpb24gaGFzaFN0cmluZyhzdHI6IHN0cmluZykge1xuICBsZXQgaGFzaCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgaGFzaCA9IChoYXNoIDw8IDUpIC0gaGFzaCArIHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gIH1cbiAgcmV0dXJuIGhhc2g7XG59XG5cbi8vIFRPRE8gXHUwNDNEXHUwNDM1IFx1MDQ0MFx1MDQzMFx1MDQzMVx1MDQzRVx1MDQ0Mlx1MDQzMFx1MDQzNVx1MDQ0MiBcdTA0M0RcdTA0MzAgXHUwNDNFXHUwNDQyXHUwNDQwXHUwNDM4XHUwNDQ2XHUwNDMwXHUwNDQyXHUwNDM1XHUwNDNCXHUwNDRDXHUwNDNEXHUwNDRCXHUwNDQ1IFx1MDQ0N1x1MDQzOFx1MDQ0MVx1MDQzQlx1MDQzMFx1MDQ0NVxuLy8gXHUwNDM4IFx1MDQzRlx1MDQ0MFx1MDQzOCBtaW4gPiBtYXhcbmZ1bmN0aW9uIHRvUmFuZ2Uoc3JjOiBudW1iZXIsIG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcikge1xuICBtYXggLT0gbWluXG4gIHNyYyAlPSBtYXgrMVxuXG4gIHJldHVybiAoc3JjICsgbWluKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29sb3VyRnJvbVBhdGgocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3Qgc3RyID0gcGF0aFRvRmlsZVdpdGhvdXRGaWxlTmFtZShwYXRoKVxuXG4gIC8vIE5PVEUgXHUwNDQyXHUwNDM4XHUwNDNGXHUwNDMwIFx1MDQzQVx1MDQzMFx1MDQzNlx1MDQzNFx1MDQ0Qlx1MDQzOSBcdTA0M0ZcdTA0MzVcdTA0NDBcdTA0MzJcdTA0NEJcdTA0MzksIFx1MDQzMlx1MDQ0Mlx1MDQzRVx1MDQ0MFx1MDQzRVx1MDQzOSBcdTA0MzhcdTA0M0JcdTA0MzggXHUwNDQyXHUwNDQwXHUwNDM1XHUwNDQyXHUwNDM4XHUwNDM5IFx1MDQ0MVx1MDQzOFx1MDQzQ1x1MDQzMlx1MDQzRVx1MDQzQiBcdTA0NDFcdTA0NDJcdTA0NDBcdTA0M0VcdTA0M0FcdTA0MzhcbiAgY29uc3Qgc3RyMSA9IGhhc2hTdHJpbmcoWy4uLnN0cl0uZmlsdGVyKChfLCBpbmRleCkgPT4gKGluZGV4ICsgMSkgJSAzICE9PSAwKS5qb2luKFwiXCIpKVxuICBjb25zdCBzdHIyID0gaGFzaFN0cmluZyhbLi4uc3RyXS5maWx0ZXIoKF8sIGluZGV4KSA9PiAoaW5kZXggKyAyKSAlIDMgIT09IDApLmpvaW4oXCJcIikpXG4gIGNvbnN0IHN0cjMgPSBoYXNoU3RyaW5nKFsuLi5zdHJdLmZpbHRlcigoXywgaW5kZXgpID0+IChpbmRleCArIDMpICUgMyAhPT0gMCkuam9pbihcIlwiKSlcblxuICBjb25zdCBodWUgPSB0b1JhbmdlKHN0cjEgKyBCQUNLR1JPVU5EX0NPTE9VUi5odWUuc2hpZnQsXG4gICAgQkFDS0dST1VORF9DT0xPVVIuaHVlLm1pbixcbiAgICBCQUNLR1JPVU5EX0NPTE9VUi5odWUubWF4XG4gIClcbiAgY29uc3Qgc2F0dXJhdGlvbiA9IHRvUmFuZ2Uoc3RyMiArIEJBQ0tHUk9VTkRfQ09MT1VSLnNhdHVyYXRpb24uc2hpZnQsXG4gICAgQkFDS0dST1VORF9DT0xPVVIuc2F0dXJhdGlvbi5taW4sXG4gICAgQkFDS0dST1VORF9DT0xPVVIuc2F0dXJhdGlvbi5tYXgpXG4gIGNvbnN0IGxpZ2h0bmVzcyAgPSB0b1JhbmdlKHN0cjMgKyBCQUNLR1JPVU5EX0NPTE9VUi5saWdodG5lc3Muc2hpZnQsXG4gICAgQkFDS0dST1VORF9DT0xPVVIubGlnaHRuZXNzLm1pbixcbiAgICBCQUNLR1JPVU5EX0NPTE9VUi5saWdodG5lc3MubWF4XG4gIClcbiAgcmV0dXJuIGBoc2woJHtodWV9LCAke3NhdHVyYXRpb259JSwgJHtsaWdodG5lc3N9JSlgXG59XG5cbmFzeW5jIGZ1bmN0aW9uIHdhaXREdkluaXQoKSB7XG4gIHdoaWxlICghZHYuaW5kZXguaW5pdGlhbGl6ZWQpXG4gICAgYXdhaXQgc2xlZXAoU0xFRVBfVElNRSlcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE5vdGVzV2l0aG91dFBhcmVudChzcmM6IHN0cmluZyk6IFByb21pc2U8SVBhZ2VbXT4ge1xuICBhd2FpdCB3YWl0RHZJbml0KClcblxuICBjb25zdCBjaGlsZCA9IGR2LnBhZ2VzKGBcIiR7c3JjfVwiYCkud2hlcmUoXG4gICAgKHBhZ2U6IGFueSkgPT4gIXBhZ2UuZmZfcGFyZW50XG4gICkuYXJyYXkoKVxuXG4gIHJldHVybiBjaGlsZCBhcyBJUGFnZVtdXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQcm9ncmVzcyhjYWNoZTogQ2FjaGUsIG5vdGVNYW5hZ2VyOiBOb3RlTWFuYWdlciwgcGFnZTogSVBhZ2UpOiBQcm9taXNlPElUYXNrcz4ge1xuICBjb25zdCByZXN1bHQgPSB7ZG9uZTowLCBhbGw6MH1cblxuICBhd2FpdCB3YWl0RHZJbml0KClcblxuICBjb25zdCBwYWdlcyA9IG5ldyBTZXQoKVxuICBjb25zdCBzdGFjayA9IFtwYWdlLmZpbGUucGF0aF1cbiAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBwYXRoID0gc3RhY2sucG9wKCkgYXMgc3RyaW5nXG4gICAgY29uc3QgcGFnZSA9IGNhY2hlLmdldFBhZ2UocGF0aClcbiAgICBjb25zdCBtZXRhID0gZHYucGFnZShwYXRoKVxuXG4gICAgaWYgKCFwYWdlIHx8ICFtZXRhKVxuICAgICAgY29udGludWVcblxuICAgIGNvbnN0IHRhc2tzID0gbm90ZU1hbmFnZXIuZ2V0VGFza0NvdW50KHBhZ2UpXG5cbiAgICByZXN1bHQuYWxsICArPSAgdGFza3MuYWxsXG4gICAgcmVzdWx0LmRvbmUgICs9ICB0YXNrcy5kb25lXG5cblxuICAgIGNvbnN0IGlubGlua3MgPSBtZXRhLmZpbGUuaW5saW5rcy5hcnJheSgpXG4gICAgLy8gaWYgKGlubGlua3MubGVuZ3RoID09IDApIHtcbiAgICBpZiAocGFnZS5mZl9zdGF0dXMpIHtcbiAgICAgICsrcmVzdWx0LmFsbFxuXG4gICAgICBpZiAocGFnZS5mZl9zdGF0dXMgPT0gVEVYVF9ET05FKVxuICAgICAgICArK3Jlc3VsdC5kb25lXG4gICAgfVxuICAgIC8vIH1cblxuICAgIGZvciAobGV0IGlubGluayBvZiBpbmxpbmtzICkge1xuICAgICAgaWYgKHBhZ2VzLmhhcyhpbmxpbmsucGF0aCkpXG4gICAgICAgIGNvbnRpbnVlXG5cbiAgICAgIHBhZ2VzLmFkZChpbmxpbmsucGF0aClcbiAgICAgIHN0YWNrLnB1c2goaW5saW5rLnBhdGgpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q2hpbGROb3RlUGF0aHMocGF0aDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICBhd2FpdCB3YWl0RHZJbml0KClcblxuICBjb25zdCBtZXRhID0gZHYucGFnZShwYXRoKVxuICBjb25zdCBpbmxpbmtzID0gbWV0YT8uZmlsZS5pbmxpbmtzLmFycmF5KClcblxuICBjb25zdCByZXN1bHQ6IHN0cmluZ1tdID0gW11cbiAgZm9yIChsZXQgaW5saW5rIG9mIGlubGlua3MpIHtcbiAgICByZXN1bHQucHVzaCggaW5saW5rLnBhdGggKVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UGFyZW50Tm90ZShwYWdlOiBJUGFnZSk6IFByb21pc2U8KElQYWdlfHVuZGVmaW5lZClbXT4ge1xuICBhd2FpdCB3YWl0RHZJbml0KClcblxuICBjb25zdCBtZXRhID0gZHYucGFnZShwYWdlLmZpbGUucGF0aClcbiAgY29uc3Qgb3V0bGlua3MgPSBtZXRhPy5maWxlLm91dGxpbmtzLmFycmF5KClcblxuICBjb25zdCByZXN1bHQ6IElQYWdlW10gPSBbXVxuICBmb3IgKGxldCBvdXRsaW5rIG9mIG91dGxpbmtzKSB7XG4gICAgcmVzdWx0LnB1c2goIGR2LnBhZ2Uob3V0bGluay5wYXRoKSBhcyBJUGFnZSApXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzYWZlUGFyc2VJbnQoc3RyOiBzdHJpbmcpOiBudW1iZXIge1xuICBjb25zdCBudW0gPSBOdW1iZXIoc3RyKTtcbiAgcmV0dXJuIE51bWJlci5pc0ludGVnZXIobnVtKSA/IG51bSA6IE5hTjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRpbWVBZGQoc3RhcnQ6IERhdGUsIGR1cmF0aW9uOiBEVVJBVElPTl9UWVBFUyk6IERhdGUge1xuICBjb25zdCBkdXIgPSBkdXJhdGlvbi5hcyhcIm1pbnV0ZXNcIilcblxuICBjb25zdCByZXN1bHQgPSBuZXcgRGF0ZShzdGFydClcbiAgcmVzdWx0LnNldE1pbnV0ZXMocmVzdWx0LmdldE1pbnV0ZXMoKSArIGR1cilcblxuICByZXR1cm4gcmVzdWx0XG59XG5cbiIsICJpbXBvcnQgeyBFTVBUWV9BUlIgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcblxuLyoqXG4gKiBBc3NpZ24gcHJvcGVydGllcyBmcm9tIGBwcm9wc2AgdG8gYG9iamBcbiAqIEB0ZW1wbGF0ZSBPLCBQIFRoZSBvYmogYW5kIHByb3BzIHR5cGVzXG4gKiBAcGFyYW0ge099IG9iaiBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0b1xuICogQHBhcmFtIHtQfSBwcm9wcyBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBAcmV0dXJucyB7TyAmIFB9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ24ob2JqLCBwcm9wcykge1xuXHQvLyBAdHMtaWdub3JlIFdlIGNoYW5nZSB0aGUgdHlwZSBvZiBgb2JqYCB0byBiZSBgTyAmIFBgXG5cdGZvciAobGV0IGkgaW4gcHJvcHMpIG9ialtpXSA9IHByb3BzW2ldO1xuXHRyZXR1cm4gLyoqIEB0eXBlIHtPICYgUH0gKi8gKG9iaik7XG59XG5cbi8qKlxuICogUmVtb3ZlIGEgY2hpbGQgbm9kZSBmcm9tIGl0cyBwYXJlbnQgaWYgYXR0YWNoZWQuIFRoaXMgaXMgYSB3b3JrYXJvdW5kIGZvclxuICogSUUxMSB3aGljaCBkb2Vzbid0IHN1cHBvcnQgYEVsZW1lbnQucHJvdG90eXBlLnJlbW92ZSgpYC4gVXNpbmcgdGhpcyBmdW5jdGlvblxuICogaXMgc21hbGxlciB0aGFuIGluY2x1ZGluZyBhIGRlZGljYXRlZCBwb2x5ZmlsbC5cbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBUaGUgbm9kZSB0byByZW1vdmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZU5vZGUobm9kZSkge1xuXHRsZXQgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcblx0aWYgKHBhcmVudE5vZGUpIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG59XG5cbmV4cG9ydCBjb25zdCBzbGljZSA9IEVNUFRZX0FSUi5zbGljZTtcbiIsICJpbXBvcnQgeyBfY2F0Y2hFcnJvciB9IGZyb20gJy4vZGlmZi9jYXRjaC1lcnJvcic7XG5cbi8qKlxuICogVGhlIGBvcHRpb25gIG9iamVjdCBjYW4gcG90ZW50aWFsbHkgY29udGFpbiBjYWxsYmFjayBmdW5jdGlvbnNcbiAqIHRoYXQgYXJlIGNhbGxlZCBkdXJpbmcgdmFyaW91cyBzdGFnZXMgb2Ygb3VyIHJlbmRlcmVyLiBUaGlzIGlzIHRoZVxuICogZm91bmRhdGlvbiBvbiB3aGljaCBhbGwgb3VyIGFkZG9ucyBsaWtlIGBwcmVhY3QvZGVidWdgLCBgcHJlYWN0L2NvbXBhdGAsXG4gKiBhbmQgYHByZWFjdC9ob29rc2AgYXJlIGJhc2VkIG9uLiBTZWUgdGhlIGBPcHRpb25zYCB0eXBlIGluIGBpbnRlcm5hbC5kLnRzYFxuICogZm9yIGEgZnVsbCBsaXN0IG9mIGF2YWlsYWJsZSBvcHRpb24gaG9va3MgKG1vc3QgZWRpdG9ycy9JREVzIGFsbG93IHlvdSB0b1xuICogY3RybCtjbGljayBvciBjbWQrY2xpY2sgb24gbWFjIHRoZSB0eXBlIGRlZmluaXRpb24gYmVsb3cpLlxuICogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLk9wdGlvbnN9XG4gKi9cbmNvbnN0IG9wdGlvbnMgPSB7XG5cdF9jYXRjaEVycm9yXG59O1xuXG5leHBvcnQgZGVmYXVsdCBvcHRpb25zO1xuIiwgImltcG9ydCB7IHNsaWNlIH0gZnJvbSAnLi91dGlsJztcbmltcG9ydCBvcHRpb25zIGZyb20gJy4vb3B0aW9ucyc7XG5cbmxldCB2bm9kZUlkID0gMDtcblxuLyoqXG4gKiBDcmVhdGUgYW4gdmlydHVhbCBub2RlICh1c2VkIGZvciBKU1gpXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlW1widHlwZVwiXX0gdHlwZSBUaGUgbm9kZSBuYW1lIG9yIENvbXBvbmVudFxuICogY29uc3RydWN0b3IgZm9yIHRoaXMgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge29iamVjdCB8IG51bGwgfCB1bmRlZmluZWR9IFtwcm9wc10gVGhlIHByb3BlcnRpZXMgb2YgdGhlIHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4nKS5Db21wb25lbnRDaGlsZHJlbj59IFtjaGlsZHJlbl0gVGhlIGNoaWxkcmVuIG9mIHRoZSB2aXJ0dWFsIG5vZGVcbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodHlwZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG5cdGxldCBub3JtYWxpemVkUHJvcHMgPSB7fSxcblx0XHRrZXksXG5cdFx0cmVmLFxuXHRcdGk7XG5cdGZvciAoaSBpbiBwcm9wcykge1xuXHRcdGlmIChpID09ICdrZXknKSBrZXkgPSBwcm9wc1tpXTtcblx0XHRlbHNlIGlmIChpID09ICdyZWYnKSByZWYgPSBwcm9wc1tpXTtcblx0XHRlbHNlIG5vcm1hbGl6ZWRQcm9wc1tpXSA9IHByb3BzW2ldO1xuXHR9XG5cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG5cdFx0bm9ybWFsaXplZFByb3BzLmNoaWxkcmVuID1cblx0XHRcdGFyZ3VtZW50cy5sZW5ndGggPiAzID8gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpIDogY2hpbGRyZW47XG5cdH1cblxuXHQvLyBJZiBhIENvbXBvbmVudCBWTm9kZSwgY2hlY2sgZm9yIGFuZCBhcHBseSBkZWZhdWx0UHJvcHNcblx0Ly8gTm90ZTogdHlwZSBtYXkgYmUgdW5kZWZpbmVkIGluIGRldmVsb3BtZW50LCBtdXN0IG5ldmVyIGVycm9yIGhlcmUuXG5cdGlmICh0eXBlb2YgdHlwZSA9PSAnZnVuY3Rpb24nICYmIHR5cGUuZGVmYXVsdFByb3BzICE9IG51bGwpIHtcblx0XHRmb3IgKGkgaW4gdHlwZS5kZWZhdWx0UHJvcHMpIHtcblx0XHRcdGlmIChub3JtYWxpemVkUHJvcHNbaV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRub3JtYWxpemVkUHJvcHNbaV0gPSB0eXBlLmRlZmF1bHRQcm9wc1tpXTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY3JlYXRlVk5vZGUodHlwZSwgbm9ybWFsaXplZFByb3BzLCBrZXksIHJlZiwgbnVsbCk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgVk5vZGUgKHVzZWQgaW50ZXJuYWxseSBieSBQcmVhY3QpXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlW1widHlwZVwiXX0gdHlwZSBUaGUgbm9kZSBuYW1lIG9yIENvbXBvbmVudFxuICogQ29uc3RydWN0b3IgZm9yIHRoaXMgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge29iamVjdCB8IHN0cmluZyB8IG51bWJlciB8IG51bGx9IHByb3BzIFRoZSBwcm9wZXJ0aWVzIG9mIHRoaXMgdmlydHVhbCBub2RlLlxuICogSWYgdGhpcyB2aXJ0dWFsIG5vZGUgcmVwcmVzZW50cyBhIHRleHQgbm9kZSwgdGhpcyBpcyB0aGUgdGV4dCBvZiB0aGUgbm9kZSAoc3RyaW5nIG9yIG51bWJlcikuXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlciB8IG51bGx9IGtleSBUaGUga2V5IGZvciB0aGlzIHZpcnR1YWwgbm9kZSwgdXNlZCB3aGVuXG4gKiBkaWZmaW5nIGl0IGFnYWluc3QgaXRzIGNoaWxkcmVuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlW1wicmVmXCJdfSByZWYgVGhlIHJlZiBwcm9wZXJ0eSB0aGF0IHdpbGxcbiAqIHJlY2VpdmUgYSByZWZlcmVuY2UgdG8gaXRzIGNyZWF0ZWQgY2hpbGRcbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVZOb2RlKHR5cGUsIHByb3BzLCBrZXksIHJlZiwgb3JpZ2luYWwpIHtcblx0Ly8gVjggc2VlbXMgdG8gYmUgYmV0dGVyIGF0IGRldGVjdGluZyB0eXBlIHNoYXBlcyBpZiB0aGUgb2JqZWN0IGlzIGFsbG9jYXRlZCBmcm9tIHRoZSBzYW1lIGNhbGwgc2l0ZVxuXHQvLyBEbyBub3QgaW5saW5lIGludG8gY3JlYXRlRWxlbWVudCBhbmQgY29lcmNlVG9WTm9kZSFcblx0Y29uc3Qgdm5vZGUgPSB7XG5cdFx0dHlwZSxcblx0XHRwcm9wcyxcblx0XHRrZXksXG5cdFx0cmVmLFxuXHRcdF9jaGlsZHJlbjogbnVsbCxcblx0XHRfcGFyZW50OiBudWxsLFxuXHRcdF9kZXB0aDogMCxcblx0XHRfZG9tOiBudWxsLFxuXHRcdC8vIF9uZXh0RG9tIG11c3QgYmUgaW5pdGlhbGl6ZWQgdG8gdW5kZWZpbmVkIGIvYyBpdCB3aWxsIGV2ZW50dWFsbHlcblx0XHQvLyBiZSBzZXQgdG8gZG9tLm5leHRTaWJsaW5nIHdoaWNoIGNhbiByZXR1cm4gYG51bGxgIGFuZCBpdCBpcyBpbXBvcnRhbnRcblx0XHQvLyB0byBiZSBhYmxlIHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gYW4gdW5pbml0aWFsaXplZCBfbmV4dERvbSBhbmRcblx0XHQvLyBhIF9uZXh0RG9tIHRoYXQgaGFzIGJlZW4gc2V0IHRvIGBudWxsYFxuXHRcdF9uZXh0RG9tOiB1bmRlZmluZWQsXG5cdFx0X2NvbXBvbmVudDogbnVsbCxcblx0XHRfaHlkcmF0aW5nOiBudWxsLFxuXHRcdGNvbnN0cnVjdG9yOiB1bmRlZmluZWQsXG5cdFx0X29yaWdpbmFsOiBvcmlnaW5hbCA9PSBudWxsID8gKyt2bm9kZUlkIDogb3JpZ2luYWxcblx0fTtcblxuXHQvLyBPbmx5IGludm9rZSB0aGUgdm5vZGUgaG9vayBpZiB0aGlzIHdhcyAqbm90KiBhIGRpcmVjdCBjb3B5OlxuXHRpZiAob3JpZ2luYWwgPT0gbnVsbCAmJiBvcHRpb25zLnZub2RlICE9IG51bGwpIG9wdGlvbnMudm5vZGUodm5vZGUpO1xuXG5cdHJldHVybiB2bm9kZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJlZigpIHtcblx0cmV0dXJuIHsgY3VycmVudDogbnVsbCB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gRnJhZ21lbnQocHJvcHMpIHtcblx0cmV0dXJuIHByb3BzLmNoaWxkcmVuO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdGhlIGFyZ3VtZW50IGlzIGEgdmFsaWQgUHJlYWN0IFZOb2RlLlxuICogQHBhcmFtIHsqfSB2bm9kZVxuICogQHJldHVybnMge3Zub2RlIGlzIGltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfVxuICovXG5leHBvcnQgY29uc3QgaXNWYWxpZEVsZW1lbnQgPSB2bm9kZSA9PlxuXHR2bm9kZSAhPSBudWxsICYmIHZub2RlLmNvbnN0cnVjdG9yID09PSB1bmRlZmluZWQ7XG4iLCAiaW1wb3J0IHsgSVNfTk9OX0RJTUVOU0lPTkFMIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCBvcHRpb25zIGZyb20gJy4uL29wdGlvbnMnO1xuXG4vKipcbiAqIERpZmYgdGhlIG9sZCBhbmQgbmV3IHByb3BlcnRpZXMgb2YgYSBWTm9kZSBhbmQgYXBwbHkgY2hhbmdlcyB0byB0aGUgRE9NIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IGRvbSBUaGUgRE9NIG5vZGUgdG8gYXBwbHlcbiAqIGNoYW5nZXMgdG9cbiAqIEBwYXJhbSB7b2JqZWN0fSBuZXdQcm9wcyBUaGUgbmV3IHByb3BzXG4gKiBAcGFyYW0ge29iamVjdH0gb2xkUHJvcHMgVGhlIG9sZCBwcm9wc1xuICogQHBhcmFtIHtib29sZWFufSBpc1N2ZyBXaGV0aGVyIG9yIG5vdCB0aGlzIG5vZGUgaXMgYW4gU1ZHIG5vZGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaHlkcmF0ZSBXaGV0aGVyIG9yIG5vdCB3ZSBhcmUgaW4gaHlkcmF0aW9uIG1vZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpZmZQcm9wcyhkb20sIG5ld1Byb3BzLCBvbGRQcm9wcywgaXNTdmcsIGh5ZHJhdGUpIHtcblx0bGV0IGk7XG5cblx0Zm9yIChpIGluIG9sZFByb3BzKSB7XG5cdFx0aWYgKGkgIT09ICdjaGlsZHJlbicgJiYgaSAhPT0gJ2tleScgJiYgIShpIGluIG5ld1Byb3BzKSkge1xuXHRcdFx0c2V0UHJvcGVydHkoZG9tLCBpLCBudWxsLCBvbGRQcm9wc1tpXSwgaXNTdmcpO1xuXHRcdH1cblx0fVxuXG5cdGZvciAoaSBpbiBuZXdQcm9wcykge1xuXHRcdGlmIChcblx0XHRcdCghaHlkcmF0ZSB8fCB0eXBlb2YgbmV3UHJvcHNbaV0gPT0gJ2Z1bmN0aW9uJykgJiZcblx0XHRcdGkgIT09ICdjaGlsZHJlbicgJiZcblx0XHRcdGkgIT09ICdrZXknICYmXG5cdFx0XHRpICE9PSAndmFsdWUnICYmXG5cdFx0XHRpICE9PSAnY2hlY2tlZCcgJiZcblx0XHRcdG9sZFByb3BzW2ldICE9PSBuZXdQcm9wc1tpXVxuXHRcdCkge1xuXHRcdFx0c2V0UHJvcGVydHkoZG9tLCBpLCBuZXdQcm9wc1tpXSwgb2xkUHJvcHNbaV0sIGlzU3ZnKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gc2V0U3R5bGUoc3R5bGUsIGtleSwgdmFsdWUpIHtcblx0aWYgKGtleVswXSA9PT0gJy0nKSB7XG5cdFx0c3R5bGUuc2V0UHJvcGVydHkoa2V5LCB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZSk7XG5cdH0gZWxzZSBpZiAodmFsdWUgPT0gbnVsbCkge1xuXHRcdHN0eWxlW2tleV0gPSAnJztcblx0fSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgIT0gJ251bWJlcicgfHwgSVNfTk9OX0RJTUVOU0lPTkFMLnRlc3Qoa2V5KSkge1xuXHRcdHN0eWxlW2tleV0gPSB2YWx1ZTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZVtrZXldID0gdmFsdWUgKyAncHgnO1xuXHR9XG59XG5cbi8qKlxuICogU2V0IGEgcHJvcGVydHkgdmFsdWUgb24gYSBET00gbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gZG9tIFRoZSBET00gbm9kZSB0byBtb2RpZnlcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXRcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldCB0aGUgcHJvcGVydHkgdG9cbiAqIEBwYXJhbSB7Kn0gb2xkVmFsdWUgVGhlIG9sZCB2YWx1ZSB0aGUgcHJvcGVydHkgaGFkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3ZnIFdoZXRoZXIgb3Igbm90IHRoaXMgRE9NIG5vZGUgaXMgYW4gU1ZHIG5vZGUgb3Igbm90XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRQcm9wZXJ0eShkb20sIG5hbWUsIHZhbHVlLCBvbGRWYWx1ZSwgaXNTdmcpIHtcblx0bGV0IHVzZUNhcHR1cmU7XG5cblx0bzogaWYgKG5hbWUgPT09ICdzdHlsZScpIHtcblx0XHRpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG5cdFx0XHRkb20uc3R5bGUuY3NzVGV4dCA9IHZhbHVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAodHlwZW9mIG9sZFZhbHVlID09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdGRvbS5zdHlsZS5jc3NUZXh0ID0gb2xkVmFsdWUgPSAnJztcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9sZFZhbHVlKSB7XG5cdFx0XHRcdGZvciAobmFtZSBpbiBvbGRWYWx1ZSkge1xuXHRcdFx0XHRcdGlmICghKHZhbHVlICYmIG5hbWUgaW4gdmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRzZXRTdHlsZShkb20uc3R5bGUsIG5hbWUsICcnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHZhbHVlKSB7XG5cdFx0XHRcdGZvciAobmFtZSBpbiB2YWx1ZSkge1xuXHRcdFx0XHRcdGlmICghb2xkVmFsdWUgfHwgdmFsdWVbbmFtZV0gIT09IG9sZFZhbHVlW25hbWVdKSB7XG5cdFx0XHRcdFx0XHRzZXRTdHlsZShkb20uc3R5bGUsIG5hbWUsIHZhbHVlW25hbWVdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Ly8gQmVuY2htYXJrIGZvciBjb21wYXJpc29uOiBodHRwczovL2VzYmVuY2guY29tL2JlbmNoLzU3NGM5NTRiZGI5NjViOWEwMDk2NWFjNlxuXHRlbHNlIGlmIChuYW1lWzBdID09PSAnbycgJiYgbmFtZVsxXSA9PT0gJ24nKSB7XG5cdFx0dXNlQ2FwdHVyZSA9IG5hbWUgIT09IChuYW1lID0gbmFtZS5yZXBsYWNlKC9DYXB0dXJlJC8sICcnKSk7XG5cblx0XHQvLyBJbmZlciBjb3JyZWN0IGNhc2luZyBmb3IgRE9NIGJ1aWx0LWluIGV2ZW50czpcblx0XHRpZiAobmFtZS50b0xvd2VyQ2FzZSgpIGluIGRvbSkgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKS5zbGljZSgyKTtcblx0XHRlbHNlIG5hbWUgPSBuYW1lLnNsaWNlKDIpO1xuXG5cdFx0aWYgKCFkb20uX2xpc3RlbmVycykgZG9tLl9saXN0ZW5lcnMgPSB7fTtcblx0XHRkb20uX2xpc3RlbmVyc1tuYW1lICsgdXNlQ2FwdHVyZV0gPSB2YWx1ZTtcblxuXHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0aWYgKCFvbGRWYWx1ZSkge1xuXHRcdFx0XHRjb25zdCBoYW5kbGVyID0gdXNlQ2FwdHVyZSA/IGV2ZW50UHJveHlDYXB0dXJlIDogZXZlbnRQcm94eTtcblx0XHRcdFx0ZG9tLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlciwgdXNlQ2FwdHVyZSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnN0IGhhbmRsZXIgPSB1c2VDYXB0dXJlID8gZXZlbnRQcm94eUNhcHR1cmUgOiBldmVudFByb3h5O1xuXHRcdFx0ZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlciwgdXNlQ2FwdHVyZSk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKG5hbWUgIT09ICdkYW5nZXJvdXNseVNldElubmVySFRNTCcpIHtcblx0XHRpZiAoaXNTdmcpIHtcblx0XHRcdC8vIE5vcm1hbGl6ZSBpbmNvcnJlY3QgcHJvcCB1c2FnZSBmb3IgU1ZHOlxuXHRcdFx0Ly8gLSB4bGluazpocmVmIC8geGxpbmtIcmVmIC0tPiBocmVmICh4bGluazpocmVmIHdhcyByZW1vdmVkIGZyb20gU1ZHIGFuZCBpc24ndCBuZWVkZWQpXG5cdFx0XHQvLyAtIGNsYXNzTmFtZSAtLT4gY2xhc3Ncblx0XHRcdG5hbWUgPSBuYW1lLnJlcGxhY2UoL3hsaW5rKEh8OmgpLywgJ2gnKS5yZXBsYWNlKC9zTmFtZSQvLCAncycpO1xuXHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRuYW1lICE9PSAnd2lkdGgnICYmXG5cdFx0XHRuYW1lICE9PSAnaGVpZ2h0JyAmJlxuXHRcdFx0bmFtZSAhPT0gJ2hyZWYnICYmXG5cdFx0XHRuYW1lICE9PSAnbGlzdCcgJiZcblx0XHRcdG5hbWUgIT09ICdmb3JtJyAmJlxuXHRcdFx0Ly8gRGVmYXVsdCB2YWx1ZSBpbiBicm93c2VycyBpcyBgLTFgIGFuZCBhbiBlbXB0eSBzdHJpbmcgaXNcblx0XHRcdC8vIGNhc3QgdG8gYDBgIGluc3RlYWRcblx0XHRcdG5hbWUgIT09ICd0YWJJbmRleCcgJiZcblx0XHRcdG5hbWUgIT09ICdkb3dubG9hZCcgJiZcblx0XHRcdG5hbWUgaW4gZG9tXG5cdFx0KSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkb21bbmFtZV0gPSB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcblx0XHRcdFx0Ly8gbGFiZWxsZWQgYnJlYWsgaXMgMWIgc21hbGxlciBoZXJlIHRoYW4gYSByZXR1cm4gc3RhdGVtZW50IChzb3JyeSlcblx0XHRcdFx0YnJlYWsgbztcblx0XHRcdH0gY2F0Y2ggKGUpIHt9XG5cdFx0fVxuXG5cdFx0Ly8gQVJJQS1hdHRyaWJ1dGVzIGhhdmUgYSBkaWZmZXJlbnQgbm90aW9uIG9mIGJvb2xlYW4gdmFsdWVzLlxuXHRcdC8vIFRoZSB2YWx1ZSBgZmFsc2VgIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBhdHRyaWJ1dGUgbm90XG5cdFx0Ly8gZXhpc3Rpbmcgb24gdGhlIERPTSwgc28gd2UgY2FuJ3QgcmVtb3ZlIGl0LiBGb3Igbm9uLWJvb2xlYW5cblx0XHQvLyBBUklBLWF0dHJpYnV0ZXMgd2UgY291bGQgdHJlYXQgZmFsc2UgYXMgYSByZW1vdmFsLCBidXQgdGhlXG5cdFx0Ly8gYW1vdW50IG9mIGV4Y2VwdGlvbnMgd291bGQgY29zdCB1cyB0b28gbWFueSBieXRlcy4gT24gdG9wIG9mXG5cdFx0Ly8gdGhhdCBvdGhlciBWRE9NIGZyYW1ld29ya3MgYWxzbyBhbHdheXMgc3RyaW5naWZ5IGBmYWxzZWAuXG5cblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHQvLyBuZXZlciBzZXJpYWxpemUgZnVuY3Rpb25zIGFzIGF0dHJpYnV0ZSB2YWx1ZXNcblx0XHR9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwgJiYgKHZhbHVlICE9PSBmYWxzZSB8fCBuYW1lLmluZGV4T2YoJy0nKSAhPSAtMSkpIHtcblx0XHRcdGRvbS5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkb20ucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuXHRcdH1cblx0fVxufVxuXG5leHBvcnQgbGV0IGluRXZlbnQgPSBmYWxzZTtcblxuLyoqXG4gKiBQcm94eSBhbiBldmVudCB0byBob29rZWQgZXZlbnQgaGFuZGxlcnNcbiAqIEBwYXJhbSB7RXZlbnR9IGUgVGhlIGV2ZW50IG9iamVjdCBmcm9tIHRoZSBicm93c2VyXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBldmVudFByb3h5KGUpIHtcblx0aW5FdmVudCA9IHRydWU7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xpc3RlbmVyc1tlLnR5cGUgKyBmYWxzZV0oXG5cdFx0XHRvcHRpb25zLmV2ZW50ID8gb3B0aW9ucy5ldmVudChlKSA6IGVcblx0XHQpO1xuXHR9IGZpbmFsbHkge1xuXHRcdGluRXZlbnQgPSBmYWxzZTtcblx0fVxufVxuXG5mdW5jdGlvbiBldmVudFByb3h5Q2FwdHVyZShlKSB7XG5cdGluRXZlbnQgPSB0cnVlO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzLl9saXN0ZW5lcnNbZS50eXBlICsgdHJ1ZV0ob3B0aW9ucy5ldmVudCA/IG9wdGlvbnMuZXZlbnQoZSkgOiBlKTtcblx0fSBmaW5hbGx5IHtcblx0XHRpbkV2ZW50ID0gZmFsc2U7XG5cdH1cbn1cbiIsICJpbXBvcnQgeyBhc3NpZ24gfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsgZGlmZiwgY29tbWl0Um9vdCB9IGZyb20gJy4vZGlmZi9pbmRleCc7XG5pbXBvcnQgb3B0aW9ucyBmcm9tICcuL29wdGlvbnMnO1xuaW1wb3J0IHsgRnJhZ21lbnQgfSBmcm9tICcuL2NyZWF0ZS1lbGVtZW50JztcbmltcG9ydCB7IGluRXZlbnQgfSBmcm9tICcuL2RpZmYvcHJvcHMnO1xuXG4vKipcbiAqIEJhc2UgQ29tcG9uZW50IGNsYXNzLiBQcm92aWRlcyBgc2V0U3RhdGUoKWAgYW5kIGBmb3JjZVVwZGF0ZSgpYCwgd2hpY2hcbiAqIHRyaWdnZXIgcmVuZGVyaW5nXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgVGhlIGluaXRpYWwgY29tcG9uZW50IHByb3BzXG4gKiBAcGFyYW0ge29iamVjdH0gY29udGV4dCBUaGUgaW5pdGlhbCBjb250ZXh0IGZyb20gcGFyZW50IGNvbXBvbmVudHMnXG4gKiBnZXRDaGlsZENvbnRleHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIENvbXBvbmVudChwcm9wcywgY29udGV4dCkge1xuXHR0aGlzLnByb3BzID0gcHJvcHM7XG5cdHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbi8qKlxuICogVXBkYXRlIGNvbXBvbmVudCBzdGF0ZSBhbmQgc2NoZWR1bGUgYSByZS1yZW5kZXIuXG4gKiBAdGhpcyB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fVxuICogQHBhcmFtIHtvYmplY3QgfCAoKHM6IG9iamVjdCwgcDogb2JqZWN0KSA9PiBvYmplY3QpfSB1cGRhdGUgQSBoYXNoIG9mIHN0YXRlXG4gKiBwcm9wZXJ0aWVzIHRvIHVwZGF0ZSB3aXRoIG5ldyB2YWx1ZXMgb3IgYSBmdW5jdGlvbiB0aGF0IGdpdmVuIHRoZSBjdXJyZW50XG4gKiBzdGF0ZSBhbmQgcHJvcHMgcmV0dXJucyBhIG5ldyBwYXJ0aWFsIHN0YXRlXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IFtjYWxsYmFja10gQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb25jZSBjb21wb25lbnQgc3RhdGUgaXNcbiAqIHVwZGF0ZWRcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uKHVwZGF0ZSwgY2FsbGJhY2spIHtcblx0Ly8gb25seSBjbG9uZSBzdGF0ZSB3aGVuIGNvcHlpbmcgdG8gbmV4dFN0YXRlIHRoZSBmaXJzdCB0aW1lLlxuXHRsZXQgcztcblx0aWYgKHRoaXMuX25leHRTdGF0ZSAhPSBudWxsICYmIHRoaXMuX25leHRTdGF0ZSAhPT0gdGhpcy5zdGF0ZSkge1xuXHRcdHMgPSB0aGlzLl9uZXh0U3RhdGU7XG5cdH0gZWxzZSB7XG5cdFx0cyA9IHRoaXMuX25leHRTdGF0ZSA9IGFzc2lnbih7fSwgdGhpcy5zdGF0ZSk7XG5cdH1cblxuXHRpZiAodHlwZW9mIHVwZGF0ZSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0Ly8gU29tZSBsaWJyYXJpZXMgbGlrZSBgaW1tZXJgIG1hcmsgdGhlIGN1cnJlbnQgc3RhdGUgYXMgcmVhZG9ubHksXG5cdFx0Ly8gcHJldmVudGluZyB1cyBmcm9tIG11dGF0aW5nIGl0LCBzbyB3ZSBuZWVkIHRvIGNsb25lIGl0LiBTZWUgIzI3MTZcblx0XHR1cGRhdGUgPSB1cGRhdGUoYXNzaWduKHt9LCBzKSwgdGhpcy5wcm9wcyk7XG5cdH1cblxuXHRpZiAodXBkYXRlKSB7XG5cdFx0YXNzaWduKHMsIHVwZGF0ZSk7XG5cdH1cblxuXHQvLyBTa2lwIHVwZGF0ZSBpZiB1cGRhdGVyIGZ1bmN0aW9uIHJldHVybmVkIG51bGxcblx0aWYgKHVwZGF0ZSA9PSBudWxsKSByZXR1cm47XG5cblx0aWYgKHRoaXMuX3Zub2RlKSB7XG5cdFx0aWYgKGNhbGxiYWNrKSB7XG5cdFx0XHR0aGlzLl9zdGF0ZUNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcblx0XHR9XG5cdFx0ZW5xdWV1ZVJlbmRlcih0aGlzKTtcblx0fVxufTtcblxuLyoqXG4gKiBJbW1lZGlhdGVseSBwZXJmb3JtIGEgc3luY2hyb25vdXMgcmUtcmVuZGVyIG9mIHRoZSBjb21wb25lbnRcbiAqIEB0aGlzIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9XG4gKiBAcGFyYW0geygpID0+IHZvaWR9IFtjYWxsYmFja10gQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzXG4gKiByZS1yZW5kZXJlZFxuICovXG5Db21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0aWYgKHRoaXMuX3Zub2RlKSB7XG5cdFx0Ly8gU2V0IHJlbmRlciBtb2RlIHNvIHRoYXQgd2UgY2FuIGRpZmZlcmVudGlhdGUgd2hlcmUgdGhlIHJlbmRlciByZXF1ZXN0XG5cdFx0Ly8gaXMgY29taW5nIGZyb20uIFdlIG5lZWQgdGhpcyBiZWNhdXNlIGZvcmNlVXBkYXRlIHNob3VsZCBuZXZlciBjYWxsXG5cdFx0Ly8gc2hvdWxkQ29tcG9uZW50VXBkYXRlXG5cdFx0dGhpcy5fZm9yY2UgPSB0cnVlO1xuXHRcdGlmIChjYWxsYmFjaykgdGhpcy5fcmVuZGVyQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuXHRcdGVucXVldWVSZW5kZXIodGhpcyk7XG5cdH1cbn07XG5cbi8qKlxuICogQWNjZXB0cyBgcHJvcHNgIGFuZCBgc3RhdGVgLCBhbmQgcmV0dXJucyBhIG5ldyBWaXJ0dWFsIERPTSB0cmVlIHRvIGJ1aWxkLlxuICogVmlydHVhbCBET00gaXMgZ2VuZXJhbGx5IGNvbnN0cnVjdGVkIHZpYSBbSlNYXShodHRwOi8vamFzb25mb3JtYXQuY29tL3d0Zi1pcy1qc3gpLlxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzIFByb3BzIChlZzogSlNYIGF0dHJpYnV0ZXMpIHJlY2VpdmVkIGZyb20gcGFyZW50XG4gKiBlbGVtZW50L2NvbXBvbmVudFxuICogQHBhcmFtIHtvYmplY3R9IHN0YXRlIFRoZSBjb21wb25lbnQncyBjdXJyZW50IHN0YXRlXG4gKiBAcGFyYW0ge29iamVjdH0gY29udGV4dCBDb250ZXh0IG9iamVjdCwgYXMgcmV0dXJuZWQgYnkgdGhlIG5lYXJlc3RcbiAqIGFuY2VzdG9yJ3MgYGdldENoaWxkQ29udGV4dCgpYFxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbmRleCcpLkNvbXBvbmVudENoaWxkcmVuIHwgdm9pZH1cbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXIgPSBGcmFnbWVudDtcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICogQHBhcmFtIHtudW1iZXIgfCBudWxsfSBbY2hpbGRJbmRleF1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERvbVNpYmxpbmcodm5vZGUsIGNoaWxkSW5kZXgpIHtcblx0aWYgKGNoaWxkSW5kZXggPT0gbnVsbCkge1xuXHRcdC8vIFVzZSBjaGlsZEluZGV4PT1udWxsIGFzIGEgc2lnbmFsIHRvIHJlc3VtZSB0aGUgc2VhcmNoIGZyb20gdGhlIHZub2RlJ3Mgc2libGluZ1xuXHRcdHJldHVybiB2bm9kZS5fcGFyZW50XG5cdFx0XHQ/IGdldERvbVNpYmxpbmcodm5vZGUuX3BhcmVudCwgdm5vZGUuX3BhcmVudC5fY2hpbGRyZW4uaW5kZXhPZih2bm9kZSkgKyAxKVxuXHRcdFx0OiBudWxsO1xuXHR9XG5cblx0bGV0IHNpYmxpbmc7XG5cdGZvciAoOyBjaGlsZEluZGV4IDwgdm5vZGUuX2NoaWxkcmVuLmxlbmd0aDsgY2hpbGRJbmRleCsrKSB7XG5cdFx0c2libGluZyA9IHZub2RlLl9jaGlsZHJlbltjaGlsZEluZGV4XTtcblxuXHRcdGlmIChzaWJsaW5nICE9IG51bGwgJiYgc2libGluZy5fZG9tICE9IG51bGwpIHtcblx0XHRcdC8vIFNpbmNlIHVwZGF0ZVBhcmVudERvbVBvaW50ZXJzIGtlZXBzIF9kb20gcG9pbnRlciBjb3JyZWN0LFxuXHRcdFx0Ly8gd2UgY2FuIHJlbHkgb24gX2RvbSB0byB0ZWxsIHVzIGlmIHRoaXMgc3VidHJlZSBjb250YWlucyBhXG5cdFx0XHQvLyByZW5kZXJlZCBET00gbm9kZSwgYW5kIHdoYXQgdGhlIGZpcnN0IHJlbmRlcmVkIERPTSBub2RlIGlzXG5cdFx0XHRyZXR1cm4gc2libGluZy5fZG9tO1xuXHRcdH1cblx0fVxuXG5cdC8vIElmIHdlIGdldCBoZXJlLCB3ZSBoYXZlIG5vdCBmb3VuZCBhIERPTSBub2RlIGluIHRoaXMgdm5vZGUncyBjaGlsZHJlbi5cblx0Ly8gV2UgbXVzdCByZXN1bWUgZnJvbSB0aGlzIHZub2RlJ3Mgc2libGluZyAoaW4gaXQncyBwYXJlbnQgX2NoaWxkcmVuIGFycmF5KVxuXHQvLyBPbmx5IGNsaW1iIHVwIGFuZCBzZWFyY2ggdGhlIHBhcmVudCBpZiB3ZSBhcmVuJ3Qgc2VhcmNoaW5nIHRocm91Z2ggYSBET01cblx0Ly8gVk5vZGUgKG1lYW5pbmcgd2UgcmVhY2hlZCB0aGUgRE9NIHBhcmVudCBvZiB0aGUgb3JpZ2luYWwgdm5vZGUgdGhhdCBiZWdhblxuXHQvLyB0aGUgc2VhcmNoKVxuXHRyZXR1cm4gdHlwZW9mIHZub2RlLnR5cGUgPT0gJ2Z1bmN0aW9uJyA/IGdldERvbVNpYmxpbmcodm5vZGUpIDogbnVsbDtcbn1cblxuLyoqXG4gKiBUcmlnZ2VyIGluLXBsYWNlIHJlLXJlbmRlcmluZyBvZiBhIGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSBjb21wb25lbnQgVGhlIGNvbXBvbmVudCB0byByZXJlbmRlclxuICovXG5mdW5jdGlvbiByZW5kZXJDb21wb25lbnQoY29tcG9uZW50KSB7XG5cdGxldCB2bm9kZSA9IGNvbXBvbmVudC5fdm5vZGUsXG5cdFx0b2xkRG9tID0gdm5vZGUuX2RvbSxcblx0XHRwYXJlbnREb20gPSBjb21wb25lbnQuX3BhcmVudERvbTtcblxuXHRpZiAocGFyZW50RG9tKSB7XG5cdFx0bGV0IGNvbW1pdFF1ZXVlID0gW107XG5cdFx0Y29uc3Qgb2xkVk5vZGUgPSBhc3NpZ24oe30sIHZub2RlKTtcblx0XHRvbGRWTm9kZS5fb3JpZ2luYWwgPSB2bm9kZS5fb3JpZ2luYWwgKyAxO1xuXG5cdFx0ZGlmZihcblx0XHRcdHBhcmVudERvbSxcblx0XHRcdHZub2RlLFxuXHRcdFx0b2xkVk5vZGUsXG5cdFx0XHRjb21wb25lbnQuX2dsb2JhbENvbnRleHQsXG5cdFx0XHRwYXJlbnREb20ub3duZXJTVkdFbGVtZW50ICE9PSB1bmRlZmluZWQsXG5cdFx0XHR2bm9kZS5faHlkcmF0aW5nICE9IG51bGwgPyBbb2xkRG9tXSA6IG51bGwsXG5cdFx0XHRjb21taXRRdWV1ZSxcblx0XHRcdG9sZERvbSA9PSBudWxsID8gZ2V0RG9tU2libGluZyh2bm9kZSkgOiBvbGREb20sXG5cdFx0XHR2bm9kZS5faHlkcmF0aW5nXG5cdFx0KTtcblx0XHRjb21taXRSb290KGNvbW1pdFF1ZXVlLCB2bm9kZSk7XG5cblx0XHRpZiAodm5vZGUuX2RvbSAhPSBvbGREb20pIHtcblx0XHRcdHVwZGF0ZVBhcmVudERvbVBvaW50ZXJzKHZub2RlKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICovXG5mdW5jdGlvbiB1cGRhdGVQYXJlbnREb21Qb2ludGVycyh2bm9kZSkge1xuXHRpZiAoKHZub2RlID0gdm5vZGUuX3BhcmVudCkgIT0gbnVsbCAmJiB2bm9kZS5fY29tcG9uZW50ICE9IG51bGwpIHtcblx0XHR2bm9kZS5fZG9tID0gdm5vZGUuX2NvbXBvbmVudC5iYXNlID0gbnVsbDtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHZub2RlLl9jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0bGV0IGNoaWxkID0gdm5vZGUuX2NoaWxkcmVuW2ldO1xuXHRcdFx0aWYgKGNoaWxkICE9IG51bGwgJiYgY2hpbGQuX2RvbSAhPSBudWxsKSB7XG5cdFx0XHRcdHZub2RlLl9kb20gPSB2bm9kZS5fY29tcG9uZW50LmJhc2UgPSBjaGlsZC5fZG9tO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdXBkYXRlUGFyZW50RG9tUG9pbnRlcnModm5vZGUpO1xuXHR9XG59XG5cbi8qKlxuICogVGhlIHJlbmRlciBxdWV1ZVxuICogQHR5cGUge0FycmF5PGltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59XG4gKi9cbmxldCByZXJlbmRlclF1ZXVlID0gW107XG5cbi8qXG4gKiBUaGUgdmFsdWUgb2YgYENvbXBvbmVudC5kZWJvdW5jZWAgbXVzdCBhc3luY2hyb25vdXNseSBpbnZva2UgdGhlIHBhc3NlZCBpbiBjYWxsYmFjay4gSXQgaXNcbiAqIGltcG9ydGFudCB0aGF0IGNvbnRyaWJ1dG9ycyB0byBQcmVhY3QgY2FuIGNvbnNpc3RlbnRseSByZWFzb24gYWJvdXQgd2hhdCBjYWxscyB0byBgc2V0U3RhdGVgLCBldGMuXG4gKiBkbywgYW5kIHdoZW4gdGhlaXIgZWZmZWN0cyB3aWxsIGJlIGFwcGxpZWQuIFNlZSB0aGUgbGlua3MgYmVsb3cgZm9yIHNvbWUgZnVydGhlciByZWFkaW5nIG9uIGRlc2lnbmluZ1xuICogYXN5bmNocm9ub3VzIEFQSXMuXG4gKiAqIFtEZXNpZ25pbmcgQVBJcyBmb3IgQXN5bmNocm9ueV0oaHR0cHM6Ly9ibG9nLml6cy5tZS8yMDEzLzA4L2Rlc2lnbmluZy1hcGlzLWZvci1hc3luY2hyb255KVxuICogKiBbQ2FsbGJhY2tzIHN5bmNocm9ub3VzIGFuZCBhc3luY2hyb25vdXNdKGh0dHBzOi8vYmxvZy5vbWV0ZXIuY29tLzIwMTEvMDcvMjQvY2FsbGJhY2tzLXN5bmNocm9ub3VzLWFuZC1hc3luY2hyb25vdXMvKVxuICovXG5cbmxldCBwcmV2RGVib3VuY2U7XG5cbmNvbnN0IG1pY3JvVGljayA9XG5cdHR5cGVvZiBQcm9taXNlID09ICdmdW5jdGlvbidcblx0XHQ/IFByb21pc2UucHJvdG90eXBlLnRoZW4uYmluZChQcm9taXNlLnJlc29sdmUoKSlcblx0XHQ6IHNldFRpbWVvdXQ7XG5mdW5jdGlvbiBkZWZlcihjYikge1xuXHRpZiAoaW5FdmVudCkge1xuXHRcdHNldFRpbWVvdXQoY2IpO1xuXHR9IGVsc2Uge1xuXHRcdG1pY3JvVGljayhjYik7XG5cdH1cbn1cblxuLyoqXG4gKiBFbnF1ZXVlIGEgcmVyZW5kZXIgb2YgYSBjb21wb25lbnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSBjIFRoZSBjb21wb25lbnQgdG8gcmVyZW5kZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVucXVldWVSZW5kZXIoYykge1xuXHRpZiAoXG5cdFx0KCFjLl9kaXJ0eSAmJlxuXHRcdFx0KGMuX2RpcnR5ID0gdHJ1ZSkgJiZcblx0XHRcdHJlcmVuZGVyUXVldWUucHVzaChjKSAmJlxuXHRcdFx0IXByb2Nlc3MuX3JlcmVuZGVyQ291bnQrKykgfHxcblx0XHRwcmV2RGVib3VuY2UgIT09IG9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmdcblx0KSB7XG5cdFx0cHJldkRlYm91bmNlID0gb3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZztcblx0XHQocHJldkRlYm91bmNlIHx8IGRlZmVyKShwcm9jZXNzKTtcblx0fVxufVxuXG4vKiogRmx1c2ggdGhlIHJlbmRlciBxdWV1ZSBieSByZXJlbmRlcmluZyBhbGwgcXVldWVkIGNvbXBvbmVudHMgKi9cbmZ1bmN0aW9uIHByb2Nlc3MoKSB7XG5cdGxldCBjO1xuXHRyZXJlbmRlclF1ZXVlLnNvcnQoKGEsIGIpID0+IGEuX3Zub2RlLl9kZXB0aCAtIGIuX3Zub2RlLl9kZXB0aCk7XG5cdC8vIERvbid0IHVwZGF0ZSBgcmVuZGVyQ291bnRgIHlldC4gS2VlcCBpdHMgdmFsdWUgbm9uLXplcm8gdG8gcHJldmVudCB1bm5lY2Vzc2FyeVxuXHQvLyBwcm9jZXNzKCkgY2FsbHMgZnJvbSBnZXR0aW5nIHNjaGVkdWxlZCB3aGlsZSBgcXVldWVgIGlzIHN0aWxsIGJlaW5nIGNvbnN1bWVkLlxuXHR3aGlsZSAoKGMgPSByZXJlbmRlclF1ZXVlLnNoaWZ0KCkpKSB7XG5cdFx0aWYgKGMuX2RpcnR5KSB7XG5cdFx0XHRsZXQgcmVuZGVyUXVldWVMZW5ndGggPSByZXJlbmRlclF1ZXVlLmxlbmd0aDtcblx0XHRcdHJlbmRlckNvbXBvbmVudChjKTtcblx0XHRcdGlmIChyZXJlbmRlclF1ZXVlLmxlbmd0aCA+IHJlbmRlclF1ZXVlTGVuZ3RoKSB7XG5cdFx0XHRcdC8vIFdoZW4gaS5lLiByZXJlbmRlcmluZyBhIHByb3ZpZGVyIGFkZGl0aW9uYWwgbmV3IGl0ZW1zIGNhbiBiZSBpbmplY3RlZCwgd2Ugd2FudCB0b1xuXHRcdFx0XHQvLyBrZWVwIHRoZSBvcmRlciBmcm9tIHRvcCB0byBib3R0b20gd2l0aCB0aG9zZSBuZXcgaXRlbXMgc28gd2UgY2FuIGhhbmRsZSB0aGVtIGluIGFcblx0XHRcdFx0Ly8gc2luZ2xlIHBhc3Ncblx0XHRcdFx0cmVyZW5kZXJRdWV1ZS5zb3J0KChhLCBiKSA9PiBhLl92bm9kZS5fZGVwdGggLSBiLl92bm9kZS5fZGVwdGgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRwcm9jZXNzLl9yZXJlbmRlckNvdW50ID0gMDtcbn1cblxucHJvY2Vzcy5fcmVyZW5kZXJDb3VudCA9IDA7XG4iLCAiaW1wb3J0IHsgZW5xdWV1ZVJlbmRlciB9IGZyb20gJy4vY29tcG9uZW50JztcblxuZXhwb3J0IGxldCBpID0gMDtcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQoZGVmYXVsdFZhbHVlLCBjb250ZXh0SWQpIHtcblx0Y29udGV4dElkID0gJ19fY0MnICsgaSsrO1xuXG5cdGNvbnN0IGNvbnRleHQgPSB7XG5cdFx0X2lkOiBjb250ZXh0SWQsXG5cdFx0X2RlZmF1bHRWYWx1ZTogZGVmYXVsdFZhbHVlLFxuXHRcdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuRnVuY3Rpb25Db21wb25lbnR9ICovXG5cdFx0Q29uc3VtZXIocHJvcHMsIGNvbnRleHRWYWx1ZSkge1xuXHRcdFx0Ly8gcmV0dXJuIHByb3BzLmNoaWxkcmVuKFxuXHRcdFx0Ly8gXHRjb250ZXh0W2NvbnRleHRJZF0gPyBjb250ZXh0W2NvbnRleHRJZF0ucHJvcHMudmFsdWUgOiBkZWZhdWx0VmFsdWVcblx0XHRcdC8vICk7XG5cdFx0XHRyZXR1cm4gcHJvcHMuY2hpbGRyZW4oY29udGV4dFZhbHVlKTtcblx0XHR9LFxuXHRcdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuRnVuY3Rpb25Db21wb25lbnR9ICovXG5cdFx0UHJvdmlkZXIocHJvcHMpIHtcblx0XHRcdGlmICghdGhpcy5nZXRDaGlsZENvbnRleHQpIHtcblx0XHRcdFx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnRbXX0gKi9cblx0XHRcdFx0bGV0IHN1YnMgPSBbXTtcblx0XHRcdFx0bGV0IGN0eCA9IHt9O1xuXHRcdFx0XHRjdHhbY29udGV4dElkXSA9IHRoaXM7XG5cblx0XHRcdFx0dGhpcy5nZXRDaGlsZENvbnRleHQgPSAoKSA9PiBjdHg7XG5cblx0XHRcdFx0dGhpcy5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbihfcHJvcHMpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5wcm9wcy52YWx1ZSAhPT0gX3Byb3BzLnZhbHVlKSB7XG5cdFx0XHRcdFx0XHQvLyBJIHRoaW5rIHRoZSBmb3JjZWQgdmFsdWUgcHJvcGFnYXRpb24gaGVyZSB3YXMgb25seSBuZWVkZWQgd2hlbiBgb3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZ2Agd2FzIGJlaW5nIGJ5cGFzc2VkOlxuXHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3ByZWFjdGpzL3ByZWFjdC9jb21taXQvNGQzMzlmYjgwM2JlYTA5ZTlmMTk4YWJmMzhjYTFiZjhlYTRiNzc3MSNkaWZmLTU0NjgyY2UzODA5MzVhNzE3ZTQxYjhiZmM1NDczN2Y2UjM1OFxuXHRcdFx0XHRcdFx0Ly8gSW4gdGhvc2UgY2FzZXMgdGhvdWdoLCBldmVuIHdpdGggdGhlIHZhbHVlIGNvcnJlY3RlZCwgd2UncmUgZG91YmxlLXJlbmRlcmluZyBhbGwgbm9kZXMuXG5cdFx0XHRcdFx0XHQvLyBJdCBtaWdodCBiZSBiZXR0ZXIgdG8ganVzdCB0ZWxsIGZvbGtzIG5vdCB0byB1c2UgZm9yY2Utc3luYyBtb2RlLlxuXHRcdFx0XHRcdFx0Ly8gQ3VycmVudGx5LCB1c2luZyBgdXNlQ29udGV4dCgpYCBpbiBhIGNsYXNzIGNvbXBvbmVudCB3aWxsIG92ZXJ3cml0ZSBpdHMgYHRoaXMuY29udGV4dGAgdmFsdWUuXG5cdFx0XHRcdFx0XHQvLyBzdWJzLnNvbWUoYyA9PiB7XG5cdFx0XHRcdFx0XHQvLyBcdGMuY29udGV4dCA9IF9wcm9wcy52YWx1ZTtcblx0XHRcdFx0XHRcdC8vIFx0ZW5xdWV1ZVJlbmRlcihjKTtcblx0XHRcdFx0XHRcdC8vIH0pO1xuXG5cdFx0XHRcdFx0XHQvLyBzdWJzLnNvbWUoYyA9PiB7XG5cdFx0XHRcdFx0XHQvLyBcdGMuY29udGV4dFtjb250ZXh0SWRdID0gX3Byb3BzLnZhbHVlO1xuXHRcdFx0XHRcdFx0Ly8gXHRlbnF1ZXVlUmVuZGVyKGMpO1xuXHRcdFx0XHRcdFx0Ly8gfSk7XG5cdFx0XHRcdFx0XHRzdWJzLnNvbWUoYyA9PiB7XG5cdFx0XHRcdFx0XHRcdGMuX2ZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0ZW5xdWV1ZVJlbmRlcihjKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblxuXHRcdFx0XHR0aGlzLnN1YiA9IGMgPT4ge1xuXHRcdFx0XHRcdHN1YnMucHVzaChjKTtcblx0XHRcdFx0XHRsZXQgb2xkID0gYy5jb21wb25lbnRXaWxsVW5tb3VudDtcblx0XHRcdFx0XHRjLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gKCkgPT4ge1xuXHRcdFx0XHRcdFx0c3Vicy5zcGxpY2Uoc3Vicy5pbmRleE9mKGMpLCAxKTtcblx0XHRcdFx0XHRcdGlmIChvbGQpIG9sZC5jYWxsKGMpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwcm9wcy5jaGlsZHJlbjtcblx0XHR9XG5cdH07XG5cblx0Ly8gRGV2dG9vbHMgbmVlZHMgYWNjZXNzIHRvIHRoZSBjb250ZXh0IG9iamVjdCB3aGVuIGl0XG5cdC8vIGVuY291bnRlcnMgYSBQcm92aWRlci4gVGhpcyBpcyBuZWNlc3NhcnkgdG8gc3VwcG9ydFxuXHQvLyBzZXR0aW5nIGBkaXNwbGF5TmFtZWAgb24gdGhlIGNvbnRleHQgb2JqZWN0IGluc3RlYWRcblx0Ly8gb2Ygb24gdGhlIGNvbXBvbmVudCBpdHNlbGYuIFNlZTpcblx0Ly8gaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL2NvbnRleHQuaHRtbCNjb250ZXh0ZGlzcGxheW5hbWVcblxuXHRyZXR1cm4gKGNvbnRleHQuUHJvdmlkZXIuX2NvbnRleHRSZWYgPSBjb250ZXh0LkNvbnN1bWVyLmNvbnRleHRUeXBlID0gY29udGV4dCk7XG59XG4iLCAiZXhwb3J0IGNvbnN0IEVNUFRZX09CSiA9IHt9O1xuZXhwb3J0IGNvbnN0IEVNUFRZX0FSUiA9IFtdO1xuZXhwb3J0IGNvbnN0IElTX05PTl9ESU1FTlNJT05BTCA9IC9hY2l0fGV4KD86c3xnfG58cHwkKXxycGh8Z3JpZHxvd3N8bW5jfG50d3xpbmVbY2hdfHpvb3xeb3JkfGl0ZXJhL2k7XG4iLCAiaW1wb3J0IHsgZGlmZiwgdW5tb3VudCwgYXBwbHlSZWYgfSBmcm9tICcuL2luZGV4JztcbmltcG9ydCB7IGNyZWF0ZVZOb2RlLCBGcmFnbWVudCB9IGZyb20gJy4uL2NyZWF0ZS1lbGVtZW50JztcbmltcG9ydCB7IEVNUFRZX09CSiwgRU1QVFlfQVJSIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IGdldERvbVNpYmxpbmcgfSBmcm9tICcuLi9jb21wb25lbnQnO1xuXG4vKipcbiAqIERpZmYgdGhlIGNoaWxkcmVuIG9mIGEgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBwYXJlbnREb20gVGhlIERPTSBlbGVtZW50IHdob3NlXG4gKiBjaGlsZHJlbiBhcmUgYmVpbmcgZGlmZmVkXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5Db21wb25lbnRDaGlsZHJlbltdfSByZW5kZXJSZXN1bHRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBuZXdQYXJlbnRWTm9kZSBUaGUgbmV3IHZpcnR1YWxcbiAqIG5vZGUgd2hvc2UgY2hpbGRyZW4gc2hvdWxkIGJlIGRpZmYnZWQgYWdhaW5zdCBvbGRQYXJlbnRWTm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IG9sZFBhcmVudFZOb2RlIFRoZSBvbGQgdmlydHVhbFxuICogbm9kZSB3aG9zZSBjaGlsZHJlbiBzaG91bGQgYmUgZGlmZidlZCBhZ2FpbnN0IG5ld1BhcmVudFZOb2RlXG4gKiBAcGFyYW0ge29iamVjdH0gZ2xvYmFsQ29udGV4dCBUaGUgY3VycmVudCBjb250ZXh0IG9iamVjdCAtIG1vZGlmaWVkIGJ5IGdldENoaWxkQ29udGV4dFxuICogQHBhcmFtIHtib29sZWFufSBpc1N2ZyBXaGV0aGVyIG9yIG5vdCB0aGlzIERPTSBub2RlIGlzIGFuIFNWRyBub2RlXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50Pn0gZXhjZXNzRG9tQ2hpbGRyZW5cbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59IGNvbW1pdFF1ZXVlIExpc3Qgb2YgY29tcG9uZW50c1xuICogd2hpY2ggaGF2ZSBjYWxsYmFja3MgdG8gaW52b2tlIGluIGNvbW1pdFJvb3RcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IG9sZERvbSBUaGUgY3VycmVudCBhdHRhY2hlZCBET01cbiAqIGVsZW1lbnQgYW55IG5ldyBkb20gZWxlbWVudHMgc2hvdWxkIGJlIHBsYWNlZCBhcm91bmQuIExpa2VseSBgbnVsbGAgb24gZmlyc3RcbiAqIHJlbmRlciAoZXhjZXB0IHdoZW4gaHlkcmF0aW5nKS4gQ2FuIGJlIGEgc2libGluZyBET00gZWxlbWVudCB3aGVuIGRpZmZpbmdcbiAqIEZyYWdtZW50cyB0aGF0IGhhdmUgc2libGluZ3MuIEluIG1vc3QgY2FzZXMsIGl0IHN0YXJ0cyBvdXQgYXMgYG9sZENoaWxkcmVuWzBdLl9kb21gLlxuICogQHBhcmFtIHtib29sZWFufSBpc0h5ZHJhdGluZyBXaGV0aGVyIG9yIG5vdCB3ZSBhcmUgaW4gaHlkcmF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaWZmQ2hpbGRyZW4oXG5cdHBhcmVudERvbSxcblx0cmVuZGVyUmVzdWx0LFxuXHRuZXdQYXJlbnRWTm9kZSxcblx0b2xkUGFyZW50Vk5vZGUsXG5cdGdsb2JhbENvbnRleHQsXG5cdGlzU3ZnLFxuXHRleGNlc3NEb21DaGlsZHJlbixcblx0Y29tbWl0UXVldWUsXG5cdG9sZERvbSxcblx0aXNIeWRyYXRpbmdcbikge1xuXHRsZXQgaSwgaiwgb2xkVk5vZGUsIGNoaWxkVk5vZGUsIG5ld0RvbSwgZmlyc3RDaGlsZERvbSwgcmVmcztcblxuXHQvLyBUaGlzIGlzIGEgY29tcHJlc3Npb24gb2Ygb2xkUGFyZW50Vk5vZGUhPW51bGwgJiYgb2xkUGFyZW50Vk5vZGUgIT0gRU1QVFlfT0JKICYmIG9sZFBhcmVudFZOb2RlLl9jaGlsZHJlbiB8fCBFTVBUWV9BUlJcblx0Ly8gYXMgRU1QVFlfT0JKLl9jaGlsZHJlbiBzaG91bGQgYmUgYHVuZGVmaW5lZGAuXG5cdGxldCBvbGRDaGlsZHJlbiA9IChvbGRQYXJlbnRWTm9kZSAmJiBvbGRQYXJlbnRWTm9kZS5fY2hpbGRyZW4pIHx8IEVNUFRZX0FSUjtcblxuXHRsZXQgb2xkQ2hpbGRyZW5MZW5ndGggPSBvbGRDaGlsZHJlbi5sZW5ndGg7XG5cblx0bmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuID0gW107XG5cdGZvciAoaSA9IDA7IGkgPCByZW5kZXJSZXN1bHQubGVuZ3RoOyBpKyspIHtcblx0XHRjaGlsZFZOb2RlID0gcmVuZGVyUmVzdWx0W2ldO1xuXG5cdFx0aWYgKGNoaWxkVk5vZGUgPT0gbnVsbCB8fCB0eXBlb2YgY2hpbGRWTm9kZSA9PSAnYm9vbGVhbicpIHtcblx0XHRcdGNoaWxkVk5vZGUgPSBuZXdQYXJlbnRWTm9kZS5fY2hpbGRyZW5baV0gPSBudWxsO1xuXHRcdH1cblx0XHQvLyBJZiB0aGlzIG5ld1ZOb2RlIGlzIGJlaW5nIHJldXNlZCAoZS5nLiA8ZGl2PntyZXVzZX17cmV1c2V9PC9kaXY+KSBpbiB0aGUgc2FtZSBkaWZmLFxuXHRcdC8vIG9yIHdlIGFyZSByZW5kZXJpbmcgYSBjb21wb25lbnQgKGUuZy4gc2V0U3RhdGUpIGNvcHkgdGhlIG9sZFZOb2RlcyBzbyBpdCBjYW4gaGF2ZVxuXHRcdC8vIGl0J3Mgb3duIERPTSAmIGV0Yy4gcG9pbnRlcnNcblx0XHRlbHNlIGlmIChcblx0XHRcdHR5cGVvZiBjaGlsZFZOb2RlID09ICdzdHJpbmcnIHx8XG5cdFx0XHR0eXBlb2YgY2hpbGRWTm9kZSA9PSAnbnVtYmVyJyB8fFxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHZhbGlkLXR5cGVvZlxuXHRcdFx0dHlwZW9mIGNoaWxkVk5vZGUgPT0gJ2JpZ2ludCdcblx0XHQpIHtcblx0XHRcdGNoaWxkVk5vZGUgPSBuZXdQYXJlbnRWTm9kZS5fY2hpbGRyZW5baV0gPSBjcmVhdGVWTm9kZShcblx0XHRcdFx0bnVsbCxcblx0XHRcdFx0Y2hpbGRWTm9kZSxcblx0XHRcdFx0bnVsbCxcblx0XHRcdFx0bnVsbCxcblx0XHRcdFx0Y2hpbGRWTm9kZVxuXHRcdFx0KTtcblx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRWTm9kZSkpIHtcblx0XHRcdGNoaWxkVk5vZGUgPSBuZXdQYXJlbnRWTm9kZS5fY2hpbGRyZW5baV0gPSBjcmVhdGVWTm9kZShcblx0XHRcdFx0RnJhZ21lbnQsXG5cdFx0XHRcdHsgY2hpbGRyZW46IGNoaWxkVk5vZGUgfSxcblx0XHRcdFx0bnVsbCxcblx0XHRcdFx0bnVsbCxcblx0XHRcdFx0bnVsbFxuXHRcdFx0KTtcblx0XHR9IGVsc2UgaWYgKGNoaWxkVk5vZGUuX2RlcHRoID4gMCkge1xuXHRcdFx0Ly8gVk5vZGUgaXMgYWxyZWFkeSBpbiB1c2UsIGNsb25lIGl0LiBUaGlzIGNhbiBoYXBwZW4gaW4gdGhlIGZvbGxvd2luZ1xuXHRcdFx0Ly8gc2NlbmFyaW86XG5cdFx0XHQvLyAgIGNvbnN0IHJldXNlID0gPGRpdiAvPlxuXHRcdFx0Ly8gICA8ZGl2PntyZXVzZX08c3BhbiAvPntyZXVzZX08L2Rpdj5cblx0XHRcdGNoaWxkVk5vZGUgPSBuZXdQYXJlbnRWTm9kZS5fY2hpbGRyZW5baV0gPSBjcmVhdGVWTm9kZShcblx0XHRcdFx0Y2hpbGRWTm9kZS50eXBlLFxuXHRcdFx0XHRjaGlsZFZOb2RlLnByb3BzLFxuXHRcdFx0XHRjaGlsZFZOb2RlLmtleSxcblx0XHRcdFx0Y2hpbGRWTm9kZS5yZWYgPyBjaGlsZFZOb2RlLnJlZiA6IG51bGwsXG5cdFx0XHRcdGNoaWxkVk5vZGUuX29yaWdpbmFsXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjaGlsZFZOb2RlID0gbmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuW2ldID0gY2hpbGRWTm9kZTtcblx0XHR9XG5cblx0XHQvLyBUZXJzZXIgcmVtb3ZlcyB0aGUgYGNvbnRpbnVlYCBoZXJlIGFuZCB3cmFwcyB0aGUgbG9vcCBib2R5XG5cdFx0Ly8gaW4gYSBgaWYgKGNoaWxkVk5vZGUpIHsgLi4uIH0gY29uZGl0aW9uXG5cdFx0aWYgKGNoaWxkVk5vZGUgPT0gbnVsbCkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0Y2hpbGRWTm9kZS5fcGFyZW50ID0gbmV3UGFyZW50Vk5vZGU7XG5cdFx0Y2hpbGRWTm9kZS5fZGVwdGggPSBuZXdQYXJlbnRWTm9kZS5fZGVwdGggKyAxO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UgZmluZCBhIGNvcnJlc3BvbmRpbmcgZWxlbWVudCBpbiBvbGRDaGlsZHJlbi5cblx0XHQvLyBJZiBmb3VuZCwgZGVsZXRlIHRoZSBhcnJheSBpdGVtIGJ5IHNldHRpbmcgdG8gYHVuZGVmaW5lZGAuXG5cdFx0Ly8gV2UgdXNlIGB1bmRlZmluZWRgLCBhcyBgbnVsbGAgaXMgcmVzZXJ2ZWQgZm9yIGVtcHR5IHBsYWNlaG9sZGVyc1xuXHRcdC8vIChob2xlcykuXG5cdFx0b2xkVk5vZGUgPSBvbGRDaGlsZHJlbltpXTtcblxuXHRcdGlmIChcblx0XHRcdG9sZFZOb2RlID09PSBudWxsIHx8XG5cdFx0XHQob2xkVk5vZGUgJiZcblx0XHRcdFx0Y2hpbGRWTm9kZS5rZXkgPT0gb2xkVk5vZGUua2V5ICYmXG5cdFx0XHRcdGNoaWxkVk5vZGUudHlwZSA9PT0gb2xkVk5vZGUudHlwZSlcblx0XHQpIHtcblx0XHRcdG9sZENoaWxkcmVuW2ldID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBFaXRoZXIgb2xkVk5vZGUgPT09IHVuZGVmaW5lZCBvciBvbGRDaGlsZHJlbkxlbmd0aCA+IDAsXG5cdFx0XHQvLyBzbyBhZnRlciB0aGlzIGxvb3Agb2xkVk5vZGUgPT0gbnVsbCBvciBvbGRWTm9kZSBpcyBhIHZhbGlkIHZhbHVlLlxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IG9sZENoaWxkcmVuTGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0b2xkVk5vZGUgPSBvbGRDaGlsZHJlbltqXTtcblx0XHRcdFx0Ly8gSWYgY2hpbGRWTm9kZSBpcyB1bmtleWVkLCB3ZSBvbmx5IG1hdGNoIHNpbWlsYXJseSB1bmtleWVkIG5vZGVzLCBvdGhlcndpc2Ugd2UgbWF0Y2ggYnkga2V5LlxuXHRcdFx0XHQvLyBXZSBhbHdheXMgbWF0Y2ggYnkgdHlwZSAoaW4gZWl0aGVyIGNhc2UpLlxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0b2xkVk5vZGUgJiZcblx0XHRcdFx0XHRjaGlsZFZOb2RlLmtleSA9PSBvbGRWTm9kZS5rZXkgJiZcblx0XHRcdFx0XHRjaGlsZFZOb2RlLnR5cGUgPT09IG9sZFZOb2RlLnR5cGVcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0b2xkQ2hpbGRyZW5bal0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0b2xkVk5vZGUgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdG9sZFZOb2RlID0gb2xkVk5vZGUgfHwgRU1QVFlfT0JKO1xuXG5cdFx0Ly8gTW9ycGggdGhlIG9sZCBlbGVtZW50IGludG8gdGhlIG5ldyBvbmUsIGJ1dCBkb24ndCBhcHBlbmQgaXQgdG8gdGhlIGRvbSB5ZXRcblx0XHRkaWZmKFxuXHRcdFx0cGFyZW50RG9tLFxuXHRcdFx0Y2hpbGRWTm9kZSxcblx0XHRcdG9sZFZOb2RlLFxuXHRcdFx0Z2xvYmFsQ29udGV4dCxcblx0XHRcdGlzU3ZnLFxuXHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdFx0XHRjb21taXRRdWV1ZSxcblx0XHRcdG9sZERvbSxcblx0XHRcdGlzSHlkcmF0aW5nXG5cdFx0KTtcblxuXHRcdG5ld0RvbSA9IGNoaWxkVk5vZGUuX2RvbTtcblxuXHRcdGlmICgoaiA9IGNoaWxkVk5vZGUucmVmKSAmJiBvbGRWTm9kZS5yZWYgIT0gaikge1xuXHRcdFx0aWYgKCFyZWZzKSByZWZzID0gW107XG5cdFx0XHRpZiAob2xkVk5vZGUucmVmKSByZWZzLnB1c2gob2xkVk5vZGUucmVmLCBudWxsLCBjaGlsZFZOb2RlKTtcblx0XHRcdHJlZnMucHVzaChqLCBjaGlsZFZOb2RlLl9jb21wb25lbnQgfHwgbmV3RG9tLCBjaGlsZFZOb2RlKTtcblx0XHR9XG5cblx0XHRpZiAobmV3RG9tICE9IG51bGwpIHtcblx0XHRcdGlmIChmaXJzdENoaWxkRG9tID09IG51bGwpIHtcblx0XHRcdFx0Zmlyc3RDaGlsZERvbSA9IG5ld0RvbTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKFxuXHRcdFx0XHR0eXBlb2YgY2hpbGRWTm9kZS50eXBlID09ICdmdW5jdGlvbicgJiZcblx0XHRcdFx0Y2hpbGRWTm9kZS5fY2hpbGRyZW4gPT09IG9sZFZOb2RlLl9jaGlsZHJlblxuXHRcdFx0KSB7XG5cdFx0XHRcdGNoaWxkVk5vZGUuX25leHREb20gPSBvbGREb20gPSByZW9yZGVyQ2hpbGRyZW4oXG5cdFx0XHRcdFx0Y2hpbGRWTm9kZSxcblx0XHRcdFx0XHRvbGREb20sXG5cdFx0XHRcdFx0cGFyZW50RG9tXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvbGREb20gPSBwbGFjZUNoaWxkKFxuXHRcdFx0XHRcdHBhcmVudERvbSxcblx0XHRcdFx0XHRjaGlsZFZOb2RlLFxuXHRcdFx0XHRcdG9sZFZOb2RlLFxuXHRcdFx0XHRcdG9sZENoaWxkcmVuLFxuXHRcdFx0XHRcdG5ld0RvbSxcblx0XHRcdFx0XHRvbGREb21cblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHR5cGVvZiBuZXdQYXJlbnRWTm9kZS50eXBlID09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0Ly8gQmVjYXVzZSB0aGUgbmV3UGFyZW50Vk5vZGUgaXMgRnJhZ21lbnQtbGlrZSwgd2UgbmVlZCB0byBzZXQgaXQnc1xuXHRcdFx0XHQvLyBfbmV4dERvbSBwcm9wZXJ0eSB0byB0aGUgbmV4dFNpYmxpbmcgb2YgaXRzIGxhc3QgY2hpbGQgRE9NIG5vZGUuXG5cdFx0XHRcdC8vXG5cdFx0XHRcdC8vIGBvbGREb21gIGNvbnRhaW5zIHRoZSBjb3JyZWN0IHZhbHVlIGhlcmUgYmVjYXVzZSBpZiB0aGUgbGFzdCBjaGlsZFxuXHRcdFx0XHQvLyBpcyBhIEZyYWdtZW50LWxpa2UsIHRoZW4gb2xkRG9tIGhhcyBhbHJlYWR5IGJlZW4gc2V0IHRvIHRoYXQgY2hpbGQncyBfbmV4dERvbS5cblx0XHRcdFx0Ly8gSWYgdGhlIGxhc3QgY2hpbGQgaXMgYSBET00gVk5vZGUsIHRoZW4gb2xkRG9tIHdpbGwgYmUgc2V0IHRvIHRoYXQgRE9NXG5cdFx0XHRcdC8vIG5vZGUncyBuZXh0U2libGluZy5cblx0XHRcdFx0bmV3UGFyZW50Vk5vZGUuX25leHREb20gPSBvbGREb207XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChcblx0XHRcdG9sZERvbSAmJlxuXHRcdFx0b2xkVk5vZGUuX2RvbSA9PSBvbGREb20gJiZcblx0XHRcdG9sZERvbS5wYXJlbnROb2RlICE9IHBhcmVudERvbVxuXHRcdCkge1xuXHRcdFx0Ly8gVGhlIGFib3ZlIGNvbmRpdGlvbiBpcyB0byBoYW5kbGUgbnVsbCBwbGFjZWhvbGRlcnMuIFNlZSB0ZXN0IGluIHBsYWNlaG9sZGVyLnRlc3QuanM6XG5cdFx0XHQvLyBgZWZmaWNpZW50bHkgcmVwbGFjZSBudWxsIHBsYWNlaG9sZGVycyBpbiBwYXJlbnQgcmVyZW5kZXJzYFxuXHRcdFx0b2xkRG9tID0gZ2V0RG9tU2libGluZyhvbGRWTm9kZSk7XG5cdFx0fVxuXHR9XG5cblx0bmV3UGFyZW50Vk5vZGUuX2RvbSA9IGZpcnN0Q2hpbGREb207XG5cblx0Ly8gUmVtb3ZlIHJlbWFpbmluZyBvbGRDaGlsZHJlbiBpZiB0aGVyZSBhcmUgYW55LlxuXHRmb3IgKGkgPSBvbGRDaGlsZHJlbkxlbmd0aDsgaS0tOyApIHtcblx0XHRpZiAob2xkQ2hpbGRyZW5baV0gIT0gbnVsbCkge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHR0eXBlb2YgbmV3UGFyZW50Vk5vZGUudHlwZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0XHRcdG9sZENoaWxkcmVuW2ldLl9kb20gIT0gbnVsbCAmJlxuXHRcdFx0XHRvbGRDaGlsZHJlbltpXS5fZG9tID09IG5ld1BhcmVudFZOb2RlLl9uZXh0RG9tXG5cdFx0XHQpIHtcblx0XHRcdFx0Ly8gSWYgdGhlIG5ld1BhcmVudFZOb2RlLl9fbmV4dERvbSBwb2ludHMgdG8gYSBkb20gbm9kZSB0aGF0IGlzIGFib3V0IHRvXG5cdFx0XHRcdC8vIGJlIHVubW91bnRlZCwgdGhlbiBnZXQgdGhlIG5leHQgc2libGluZyBvZiB0aGF0IHZub2RlIGFuZCBzZXRcblx0XHRcdFx0Ly8gX25leHREb20gdG8gaXRcblx0XHRcdFx0bmV3UGFyZW50Vk5vZGUuX25leHREb20gPSBnZXRMYXN0RG9tKG9sZFBhcmVudFZOb2RlKS5uZXh0U2libGluZztcblx0XHRcdH1cblxuXHRcdFx0dW5tb3VudChvbGRDaGlsZHJlbltpXSwgb2xkQ2hpbGRyZW5baV0pO1xuXHRcdH1cblx0fVxuXG5cdC8vIFNldCByZWZzIG9ubHkgYWZ0ZXIgdW5tb3VudFxuXHRpZiAocmVmcykge1xuXHRcdGZvciAoaSA9IDA7IGkgPCByZWZzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRhcHBseVJlZihyZWZzW2ldLCByZWZzWysraV0sIHJlZnNbKytpXSk7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHJlb3JkZXJDaGlsZHJlbihjaGlsZFZOb2RlLCBvbGREb20sIHBhcmVudERvbSkge1xuXHQvLyBOb3RlOiBWTm9kZXMgaW4gbmVzdGVkIHN1c3BlbmRlZCB0cmVlcyBtYXkgYmUgbWlzc2luZyBfY2hpbGRyZW4uXG5cdGxldCBjID0gY2hpbGRWTm9kZS5fY2hpbGRyZW47XG5cdGxldCB0bXAgPSAwO1xuXHRmb3IgKDsgYyAmJiB0bXAgPCBjLmxlbmd0aDsgdG1wKyspIHtcblx0XHRsZXQgdm5vZGUgPSBjW3RtcF07XG5cdFx0aWYgKHZub2RlKSB7XG5cdFx0XHQvLyBXZSB0eXBpY2FsbHkgZW50ZXIgdGhpcyBjb2RlIHBhdGggb24gc0NVIGJhaWxvdXQsIHdoZXJlIHdlIGNvcHlcblx0XHRcdC8vIG9sZFZOb2RlLl9jaGlsZHJlbiB0byBuZXdWTm9kZS5fY2hpbGRyZW4uIElmIHRoYXQgaXMgdGhlIGNhc2UsIHdlIG5lZWRcblx0XHRcdC8vIHRvIHVwZGF0ZSB0aGUgb2xkIGNoaWxkcmVuJ3MgX3BhcmVudCBwb2ludGVyIHRvIHBvaW50IHRvIHRoZSBuZXdWTm9kZVxuXHRcdFx0Ly8gKGNoaWxkVk5vZGUgaGVyZSkuXG5cdFx0XHR2bm9kZS5fcGFyZW50ID0gY2hpbGRWTm9kZTtcblxuXHRcdFx0aWYgKHR5cGVvZiB2bm9kZS50eXBlID09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0b2xkRG9tID0gcmVvcmRlckNoaWxkcmVuKHZub2RlLCBvbGREb20sIHBhcmVudERvbSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvbGREb20gPSBwbGFjZUNoaWxkKHBhcmVudERvbSwgdm5vZGUsIHZub2RlLCBjLCB2bm9kZS5fZG9tLCBvbGREb20pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBvbGREb207XG59XG5cbi8qKlxuICogRmxhdHRlbiBhbmQgbG9vcCB0aHJvdWdoIHRoZSBjaGlsZHJlbiBvZiBhIHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2luZGV4JykuQ29tcG9uZW50Q2hpbGRyZW59IGNoaWxkcmVuIFRoZSB1bmZsYXR0ZW5lZFxuICogY2hpbGRyZW4gb2YgYSB2aXJ0dWFsIG5vZGVcbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGVbXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQ2hpbGRBcnJheShjaGlsZHJlbiwgb3V0KSB7XG5cdG91dCA9IG91dCB8fCBbXTtcblx0aWYgKGNoaWxkcmVuID09IG51bGwgfHwgdHlwZW9mIGNoaWxkcmVuID09ICdib29sZWFuJykge1xuXHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG5cdFx0Y2hpbGRyZW4uc29tZShjaGlsZCA9PiB7XG5cdFx0XHR0b0NoaWxkQXJyYXkoY2hpbGQsIG91dCk7XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0b3V0LnB1c2goY2hpbGRyZW4pO1xuXHR9XG5cdHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIHBsYWNlQ2hpbGQoXG5cdHBhcmVudERvbSxcblx0Y2hpbGRWTm9kZSxcblx0b2xkVk5vZGUsXG5cdG9sZENoaWxkcmVuLFxuXHRuZXdEb20sXG5cdG9sZERvbVxuKSB7XG5cdGxldCBuZXh0RG9tO1xuXHRpZiAoY2hpbGRWTm9kZS5fbmV4dERvbSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0Ly8gT25seSBGcmFnbWVudHMgb3IgY29tcG9uZW50cyB0aGF0IHJldHVybiBGcmFnbWVudCBsaWtlIFZOb2RlcyB3aWxsXG5cdFx0Ly8gaGF2ZSBhIG5vbi11bmRlZmluZWQgX25leHREb20uIENvbnRpbnVlIHRoZSBkaWZmIGZyb20gdGhlIHNpYmxpbmdcblx0XHQvLyBvZiBsYXN0IERPTSBjaGlsZCBvZiB0aGlzIGNoaWxkIFZOb2RlXG5cdFx0bmV4dERvbSA9IGNoaWxkVk5vZGUuX25leHREb207XG5cblx0XHQvLyBFYWdlcmx5IGNsZWFudXAgX25leHREb20uIFdlIGRvbid0IG5lZWQgdG8gcGVyc2lzdCB0aGUgdmFsdWUgYmVjYXVzZVxuXHRcdC8vIGl0IGlzIG9ubHkgdXNlZCBieSBgZGlmZkNoaWxkcmVuYCB0byBkZXRlcm1pbmUgd2hlcmUgdG8gcmVzdW1lIHRoZSBkaWZmIGFmdGVyXG5cdFx0Ly8gZGlmZmluZyBDb21wb25lbnRzIGFuZCBGcmFnbWVudHMuIE9uY2Ugd2Ugc3RvcmUgaXQgdGhlIG5leHRET00gbG9jYWwgdmFyLCB3ZVxuXHRcdC8vIGNhbiBjbGVhbiB1cCB0aGUgcHJvcGVydHlcblx0XHRjaGlsZFZOb2RlLl9uZXh0RG9tID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKFxuXHRcdG9sZFZOb2RlID09IG51bGwgfHxcblx0XHRuZXdEb20gIT0gb2xkRG9tIHx8XG5cdFx0bmV3RG9tLnBhcmVudE5vZGUgPT0gbnVsbFxuXHQpIHtcblx0XHRvdXRlcjogaWYgKG9sZERvbSA9PSBudWxsIHx8IG9sZERvbS5wYXJlbnROb2RlICE9PSBwYXJlbnREb20pIHtcblx0XHRcdHBhcmVudERvbS5hcHBlbmRDaGlsZChuZXdEb20pO1xuXHRcdFx0bmV4dERvbSA9IG51bGw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGBqPG9sZENoaWxkcmVuTGVuZ3RoOyBqKz0yYCBpcyBhbiBhbHRlcm5hdGl2ZSB0byBgaisrPG9sZENoaWxkcmVuTGVuZ3RoLzJgXG5cdFx0XHRmb3IgKFxuXHRcdFx0XHRsZXQgc2liRG9tID0gb2xkRG9tLCBqID0gMDtcblx0XHRcdFx0KHNpYkRvbSA9IHNpYkRvbS5uZXh0U2libGluZykgJiYgaiA8IG9sZENoaWxkcmVuLmxlbmd0aDtcblx0XHRcdFx0aiArPSAxXG5cdFx0XHQpIHtcblx0XHRcdFx0aWYgKHNpYkRvbSA9PSBuZXdEb20pIHtcblx0XHRcdFx0XHRicmVhayBvdXRlcjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cGFyZW50RG9tLmluc2VydEJlZm9yZShuZXdEb20sIG9sZERvbSk7XG5cdFx0XHRuZXh0RG9tID0gb2xkRG9tO1xuXHRcdH1cblx0fVxuXG5cdC8vIElmIHdlIGhhdmUgcHJlLWNhbGN1bGF0ZWQgdGhlIG5leHRET00gbm9kZSwgdXNlIGl0LiBFbHNlIGNhbGN1bGF0ZSBpdCBub3dcblx0Ly8gU3RyaWN0bHkgY2hlY2sgZm9yIGB1bmRlZmluZWRgIGhlcmUgY3V6IGBudWxsYCBpcyBhIHZhbGlkIHZhbHVlIG9mIGBuZXh0RG9tYC5cblx0Ly8gU2VlIG1vcmUgZGV0YWlsIGluIGNyZWF0ZS1lbGVtZW50LmpzOmNyZWF0ZVZOb2RlXG5cdGlmIChuZXh0RG9tICE9PSB1bmRlZmluZWQpIHtcblx0XHRvbGREb20gPSBuZXh0RG9tO1xuXHR9IGVsc2Uge1xuXHRcdG9sZERvbSA9IG5ld0RvbS5uZXh0U2libGluZztcblx0fVxuXG5cdHJldHVybiBvbGREb207XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IHZub2RlXG4gKi9cbmZ1bmN0aW9uIGdldExhc3REb20odm5vZGUpIHtcblx0aWYgKHZub2RlLnR5cGUgPT0gbnVsbCB8fCB0eXBlb2Ygdm5vZGUudHlwZSA9PT0gJ3N0cmluZycpIHtcblx0XHRyZXR1cm4gdm5vZGUuX2RvbTtcblx0fVxuXG5cdGlmICh2bm9kZS5fY2hpbGRyZW4pIHtcblx0XHRmb3IgKGxldCBpID0gdm5vZGUuX2NoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRsZXQgY2hpbGQgPSB2bm9kZS5fY2hpbGRyZW5baV07XG5cdFx0XHRpZiAoY2hpbGQpIHtcblx0XHRcdFx0bGV0IGxhc3REb20gPSBnZXRMYXN0RG9tKGNoaWxkKTtcblx0XHRcdFx0aWYgKGxhc3REb20pIHtcblx0XHRcdFx0XHRyZXR1cm4gbGFzdERvbTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBudWxsO1xufVxuIiwgImltcG9ydCB7IEVNUFRZX09CSiB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBDb21wb25lbnQsIGdldERvbVNpYmxpbmcgfSBmcm9tICcuLi9jb21wb25lbnQnO1xuaW1wb3J0IHsgRnJhZ21lbnQgfSBmcm9tICcuLi9jcmVhdGUtZWxlbWVudCc7XG5pbXBvcnQgeyBkaWZmQ2hpbGRyZW4gfSBmcm9tICcuL2NoaWxkcmVuJztcbmltcG9ydCB7IGRpZmZQcm9wcywgc2V0UHJvcGVydHkgfSBmcm9tICcuL3Byb3BzJztcbmltcG9ydCB7IGFzc2lnbiwgcmVtb3ZlTm9kZSwgc2xpY2UgfSBmcm9tICcuLi91dGlsJztcbmltcG9ydCBvcHRpb25zIGZyb20gJy4uL29wdGlvbnMnO1xuXG4vKipcbiAqIERpZmYgdHdvIHZpcnR1YWwgbm9kZXMgYW5kIGFwcGx5IHByb3BlciBjaGFuZ2VzIHRvIHRoZSBET01cbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IHBhcmVudERvbSBUaGUgcGFyZW50IG9mIHRoZSBET00gZWxlbWVudFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IG5ld1ZOb2RlIFRoZSBuZXcgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gb2xkVk5vZGUgVGhlIG9sZCB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBnbG9iYWxDb250ZXh0IFRoZSBjdXJyZW50IGNvbnRleHQgb2JqZWN0LiBNb2RpZmllZCBieSBnZXRDaGlsZENvbnRleHRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdmcgV2hldGhlciBvciBub3QgdGhpcyBlbGVtZW50IGlzIGFuIFNWRyBub2RlXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50Pn0gZXhjZXNzRG9tQ2hpbGRyZW5cbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59IGNvbW1pdFF1ZXVlIExpc3Qgb2YgY29tcG9uZW50c1xuICogd2hpY2ggaGF2ZSBjYWxsYmFja3MgdG8gaW52b2tlIGluIGNvbW1pdFJvb3RcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IG9sZERvbSBUaGUgY3VycmVudCBhdHRhY2hlZCBET01cbiAqIGVsZW1lbnQgYW55IG5ldyBkb20gZWxlbWVudHMgc2hvdWxkIGJlIHBsYWNlZCBhcm91bmQuIExpa2VseSBgbnVsbGAgb24gZmlyc3RcbiAqIHJlbmRlciAoZXhjZXB0IHdoZW4gaHlkcmF0aW5nKS4gQ2FuIGJlIGEgc2libGluZyBET00gZWxlbWVudCB3aGVuIGRpZmZpbmdcbiAqIEZyYWdtZW50cyB0aGF0IGhhdmUgc2libGluZ3MuIEluIG1vc3QgY2FzZXMsIGl0IHN0YXJ0cyBvdXQgYXMgYG9sZENoaWxkcmVuWzBdLl9kb21gLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNIeWRyYXRpbmddIFdoZXRoZXIgb3Igbm90IHdlIGFyZSBpbiBoeWRyYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpZmYoXG5cdHBhcmVudERvbSxcblx0bmV3Vk5vZGUsXG5cdG9sZFZOb2RlLFxuXHRnbG9iYWxDb250ZXh0LFxuXHRpc1N2Zyxcblx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdGNvbW1pdFF1ZXVlLFxuXHRvbGREb20sXG5cdGlzSHlkcmF0aW5nXG4pIHtcblx0bGV0IHRtcCxcblx0XHRuZXdUeXBlID0gbmV3Vk5vZGUudHlwZTtcblxuXHQvLyBXaGVuIHBhc3NpbmcgdGhyb3VnaCBjcmVhdGVFbGVtZW50IGl0IGFzc2lnbnMgdGhlIG9iamVjdFxuXHQvLyBjb25zdHJ1Y3RvciBhcyB1bmRlZmluZWQuIFRoaXMgdG8gcHJldmVudCBKU09OLWluamVjdGlvbi5cblx0aWYgKG5ld1ZOb2RlLmNvbnN0cnVjdG9yICE9PSB1bmRlZmluZWQpIHJldHVybiBudWxsO1xuXG5cdC8vIElmIHRoZSBwcmV2aW91cyBkaWZmIGJhaWxlZCBvdXQsIHJlc3VtZSBjcmVhdGluZy9oeWRyYXRpbmcuXG5cdGlmIChvbGRWTm9kZS5faHlkcmF0aW5nICE9IG51bGwpIHtcblx0XHRpc0h5ZHJhdGluZyA9IG9sZFZOb2RlLl9oeWRyYXRpbmc7XG5cdFx0b2xkRG9tID0gbmV3Vk5vZGUuX2RvbSA9IG9sZFZOb2RlLl9kb207XG5cdFx0Ly8gaWYgd2UgcmVzdW1lLCB3ZSB3YW50IHRoZSB0cmVlIHRvIGJlIFwidW5sb2NrZWRcIlxuXHRcdG5ld1ZOb2RlLl9oeWRyYXRpbmcgPSBudWxsO1xuXHRcdGV4Y2Vzc0RvbUNoaWxkcmVuID0gW29sZERvbV07XG5cdH1cblxuXHRpZiAoKHRtcCA9IG9wdGlvbnMuX2RpZmYpKSB0bXAobmV3Vk5vZGUpO1xuXG5cdHRyeSB7XG5cdFx0b3V0ZXI6IGlmICh0eXBlb2YgbmV3VHlwZSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRsZXQgYywgaXNOZXcsIG9sZFByb3BzLCBvbGRTdGF0ZSwgc25hcHNob3QsIGNsZWFyUHJvY2Vzc2luZ0V4Y2VwdGlvbjtcblx0XHRcdGxldCBuZXdQcm9wcyA9IG5ld1ZOb2RlLnByb3BzO1xuXG5cdFx0XHQvLyBOZWNlc3NhcnkgZm9yIGNyZWF0ZUNvbnRleHQgYXBpLiBTZXR0aW5nIHRoaXMgcHJvcGVydHkgd2lsbCBwYXNzXG5cdFx0XHQvLyB0aGUgY29udGV4dCB2YWx1ZSBhcyBgdGhpcy5jb250ZXh0YCBqdXN0IGZvciB0aGlzIGNvbXBvbmVudC5cblx0XHRcdHRtcCA9IG5ld1R5cGUuY29udGV4dFR5cGU7XG5cdFx0XHRsZXQgcHJvdmlkZXIgPSB0bXAgJiYgZ2xvYmFsQ29udGV4dFt0bXAuX2lkXTtcblx0XHRcdGxldCBjb21wb25lbnRDb250ZXh0ID0gdG1wXG5cdFx0XHRcdD8gcHJvdmlkZXJcblx0XHRcdFx0XHQ/IHByb3ZpZGVyLnByb3BzLnZhbHVlXG5cdFx0XHRcdFx0OiB0bXAuX2RlZmF1bHRWYWx1ZVxuXHRcdFx0XHQ6IGdsb2JhbENvbnRleHQ7XG5cblx0XHRcdC8vIEdldCBjb21wb25lbnQgYW5kIHNldCBpdCB0byBgY2Bcblx0XHRcdGlmIChvbGRWTm9kZS5fY29tcG9uZW50KSB7XG5cdFx0XHRcdGMgPSBuZXdWTm9kZS5fY29tcG9uZW50ID0gb2xkVk5vZGUuX2NvbXBvbmVudDtcblx0XHRcdFx0Y2xlYXJQcm9jZXNzaW5nRXhjZXB0aW9uID0gYy5fcHJvY2Vzc2luZ0V4Y2VwdGlvbiA9IGMuX3BlbmRpbmdFcnJvcjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEluc3RhbnRpYXRlIHRoZSBuZXcgY29tcG9uZW50XG5cdFx0XHRcdGlmICgncHJvdG90eXBlJyBpbiBuZXdUeXBlICYmIG5ld1R5cGUucHJvdG90eXBlLnJlbmRlcikge1xuXHRcdFx0XHRcdC8vIEB0cy1pZ25vcmUgVGhlIGNoZWNrIGFib3ZlIHZlcmlmaWVzIHRoYXQgbmV3VHlwZSBpcyBzdXBwb3NlIHRvIGJlIGNvbnN0cnVjdGVkXG5cdFx0XHRcdFx0bmV3Vk5vZGUuX2NvbXBvbmVudCA9IGMgPSBuZXcgbmV3VHlwZShuZXdQcm9wcywgY29tcG9uZW50Q29udGV4dCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbmV3LWNhcFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIEB0cy1pZ25vcmUgVHJ1c3QgbWUsIENvbXBvbmVudCBpbXBsZW1lbnRzIHRoZSBpbnRlcmZhY2Ugd2Ugd2FudFxuXHRcdFx0XHRcdG5ld1ZOb2RlLl9jb21wb25lbnQgPSBjID0gbmV3IENvbXBvbmVudChuZXdQcm9wcywgY29tcG9uZW50Q29udGV4dCk7XG5cdFx0XHRcdFx0Yy5jb25zdHJ1Y3RvciA9IG5ld1R5cGU7XG5cdFx0XHRcdFx0Yy5yZW5kZXIgPSBkb1JlbmRlcjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocHJvdmlkZXIpIHByb3ZpZGVyLnN1YihjKTtcblxuXHRcdFx0XHRjLnByb3BzID0gbmV3UHJvcHM7XG5cdFx0XHRcdGlmICghYy5zdGF0ZSkgYy5zdGF0ZSA9IHt9O1xuXHRcdFx0XHRjLmNvbnRleHQgPSBjb21wb25lbnRDb250ZXh0O1xuXHRcdFx0XHRjLl9nbG9iYWxDb250ZXh0ID0gZ2xvYmFsQ29udGV4dDtcblx0XHRcdFx0aXNOZXcgPSBjLl9kaXJ0eSA9IHRydWU7XG5cdFx0XHRcdGMuX3JlbmRlckNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0XHRjLl9zdGF0ZUNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbnZva2UgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzXG5cdFx0XHRpZiAoYy5fbmV4dFN0YXRlID09IG51bGwpIHtcblx0XHRcdFx0Yy5fbmV4dFN0YXRlID0gYy5zdGF0ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG5ld1R5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICE9IG51bGwpIHtcblx0XHRcdFx0aWYgKGMuX25leHRTdGF0ZSA9PSBjLnN0YXRlKSB7XG5cdFx0XHRcdFx0Yy5fbmV4dFN0YXRlID0gYXNzaWduKHt9LCBjLl9uZXh0U3RhdGUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YXNzaWduKFxuXHRcdFx0XHRcdGMuX25leHRTdGF0ZSxcblx0XHRcdFx0XHRuZXdUeXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXdQcm9wcywgYy5fbmV4dFN0YXRlKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHRvbGRQcm9wcyA9IGMucHJvcHM7XG5cdFx0XHRvbGRTdGF0ZSA9IGMuc3RhdGU7XG5cdFx0XHRjLl92bm9kZSA9IG5ld1ZOb2RlO1xuXG5cdFx0XHQvLyBJbnZva2UgcHJlLXJlbmRlciBsaWZlY3ljbGUgbWV0aG9kc1xuXHRcdFx0aWYgKGlzTmV3KSB7XG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRuZXdUeXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PSBudWxsICYmXG5cdFx0XHRcdFx0Yy5jb21wb25lbnRXaWxsTW91bnQgIT0gbnVsbFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRjLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGMuY29tcG9uZW50RGlkTW91bnQgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGMuX3JlbmRlckNhbGxiYWNrcy5wdXNoKGMuY29tcG9uZW50RGlkTW91bnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0bmV3VHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT0gbnVsbCAmJlxuXHRcdFx0XHRcdG5ld1Byb3BzICE9PSBvbGRQcm9wcyAmJlxuXHRcdFx0XHRcdGMuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAhPSBudWxsXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGMuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcywgY29tcG9uZW50Q29udGV4dCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0KCFjLl9mb3JjZSAmJlxuXHRcdFx0XHRcdFx0Yy5zaG91bGRDb21wb25lbnRVcGRhdGUgIT0gbnVsbCAmJlxuXHRcdFx0XHRcdFx0Yy5zaG91bGRDb21wb25lbnRVcGRhdGUoXG5cdFx0XHRcdFx0XHRcdG5ld1Byb3BzLFxuXHRcdFx0XHRcdFx0XHRjLl9uZXh0U3RhdGUsXG5cdFx0XHRcdFx0XHRcdGNvbXBvbmVudENvbnRleHRcblx0XHRcdFx0XHRcdCkgPT09IGZhbHNlKSB8fFxuXHRcdFx0XHRcdG5ld1ZOb2RlLl9vcmlnaW5hbCA9PT0gb2xkVk5vZGUuX29yaWdpbmFsXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdC8vIE1vcmUgaW5mbyBhYm91dCB0aGlzIGhlcmU6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0pvdmlEZUNyb29jay9iZWM1ZjJjZTkzNTQ0ZDJlNjA3MGVmOGUwMDM2ZTRlOFxuXHRcdFx0XHRcdGlmIChuZXdWTm9kZS5fb3JpZ2luYWwgIT09IG9sZFZOb2RlLl9vcmlnaW5hbCkge1xuXHRcdFx0XHRcdFx0Ly8gV2hlbiB3ZSBhcmUgZGVhbGluZyB3aXRoIGEgYmFpbCBiZWNhdXNlIG9mIHNDVSB3ZSBoYXZlIHRvIHVwZGF0ZVxuXHRcdFx0XHRcdFx0Ly8gdGhlIHByb3BzLCBzdGF0ZSBhbmQgZGlydHktc3RhdGUuXG5cdFx0XHRcdFx0XHQvLyB3aGVuIHdlIGFyZSBkZWFsaW5nIHdpdGggc3RyaWN0LWVxdWFsaXR5IHdlIGRvbid0IGFzIHRoZSBjaGlsZCBjb3VsZCBzdGlsbFxuXHRcdFx0XHRcdFx0Ly8gYmUgZGlydGllZCBzZWUgIzM4ODNcblx0XHRcdFx0XHRcdGMucHJvcHMgPSBuZXdQcm9wcztcblx0XHRcdFx0XHRcdGMuc3RhdGUgPSBjLl9uZXh0U3RhdGU7XG5cdFx0XHRcdFx0XHRjLl9kaXJ0eSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRuZXdWTm9kZS5fZG9tID0gb2xkVk5vZGUuX2RvbTtcblx0XHRcdFx0XHRuZXdWTm9kZS5fY2hpbGRyZW4gPSBvbGRWTm9kZS5fY2hpbGRyZW47XG5cdFx0XHRcdFx0bmV3Vk5vZGUuX2NoaWxkcmVuLmZvckVhY2godm5vZGUgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKHZub2RlKSB2bm9kZS5fcGFyZW50ID0gbmV3Vk5vZGU7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGMuX3N0YXRlQ2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRjLl9yZW5kZXJDYWxsYmFja3MucHVzaChjLl9zdGF0ZUNhbGxiYWNrc1tpXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGMuX3N0YXRlQ2FsbGJhY2tzID0gW107XG5cblx0XHRcdFx0XHRpZiAoYy5fcmVuZGVyQ2FsbGJhY2tzLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0Y29tbWl0UXVldWUucHVzaChjKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhayBvdXRlcjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjLmNvbXBvbmVudFdpbGxVcGRhdGUgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGMuY29tcG9uZW50V2lsbFVwZGF0ZShuZXdQcm9wcywgYy5fbmV4dFN0YXRlLCBjb21wb25lbnRDb250ZXh0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjLmNvbXBvbmVudERpZFVwZGF0ZSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0Yy5fcmVuZGVyQ2FsbGJhY2tzLnB1c2goKCkgPT4ge1xuXHRcdFx0XHRcdFx0Yy5jb21wb25lbnREaWRVcGRhdGUob2xkUHJvcHMsIG9sZFN0YXRlLCBzbmFwc2hvdCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Yy5jb250ZXh0ID0gY29tcG9uZW50Q29udGV4dDtcblx0XHRcdGMucHJvcHMgPSBuZXdQcm9wcztcblx0XHRcdGMuX3BhcmVudERvbSA9IHBhcmVudERvbTtcblxuXHRcdFx0bGV0IHJlbmRlckhvb2sgPSBvcHRpb25zLl9yZW5kZXIsXG5cdFx0XHRcdGNvdW50ID0gMDtcblx0XHRcdGlmICgncHJvdG90eXBlJyBpbiBuZXdUeXBlICYmIG5ld1R5cGUucHJvdG90eXBlLnJlbmRlcikge1xuXHRcdFx0XHRjLnN0YXRlID0gYy5fbmV4dFN0YXRlO1xuXHRcdFx0XHRjLl9kaXJ0eSA9IGZhbHNlO1xuXG5cdFx0XHRcdGlmIChyZW5kZXJIb29rKSByZW5kZXJIb29rKG5ld1ZOb2RlKTtcblxuXHRcdFx0XHR0bXAgPSBjLnJlbmRlcihjLnByb3BzLCBjLnN0YXRlLCBjLmNvbnRleHQpO1xuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYy5fc3RhdGVDYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRjLl9yZW5kZXJDYWxsYmFja3MucHVzaChjLl9zdGF0ZUNhbGxiYWNrc1tpXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Yy5fc3RhdGVDYWxsYmFja3MgPSBbXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRjLl9kaXJ0eSA9IGZhbHNlO1xuXHRcdFx0XHRcdGlmIChyZW5kZXJIb29rKSByZW5kZXJIb29rKG5ld1ZOb2RlKTtcblxuXHRcdFx0XHRcdHRtcCA9IGMucmVuZGVyKGMucHJvcHMsIGMuc3RhdGUsIGMuY29udGV4dCk7XG5cblx0XHRcdFx0XHQvLyBIYW5kbGUgc2V0U3RhdGUgY2FsbGVkIGluIHJlbmRlciwgc2VlICMyNTUzXG5cdFx0XHRcdFx0Yy5zdGF0ZSA9IGMuX25leHRTdGF0ZTtcblx0XHRcdFx0fSB3aGlsZSAoYy5fZGlydHkgJiYgKytjb3VudCA8IDI1KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSGFuZGxlIHNldFN0YXRlIGNhbGxlZCBpbiByZW5kZXIsIHNlZSAjMjU1M1xuXHRcdFx0Yy5zdGF0ZSA9IGMuX25leHRTdGF0ZTtcblxuXHRcdFx0aWYgKGMuZ2V0Q2hpbGRDb250ZXh0ICE9IG51bGwpIHtcblx0XHRcdFx0Z2xvYmFsQ29udGV4dCA9IGFzc2lnbihhc3NpZ24oe30sIGdsb2JhbENvbnRleHQpLCBjLmdldENoaWxkQ29udGV4dCgpKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFpc05ldyAmJiBjLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlICE9IG51bGwpIHtcblx0XHRcdFx0c25hcHNob3QgPSBjLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKG9sZFByb3BzLCBvbGRTdGF0ZSk7XG5cdFx0XHR9XG5cblx0XHRcdGxldCBpc1RvcExldmVsRnJhZ21lbnQgPVxuXHRcdFx0XHR0bXAgIT0gbnVsbCAmJiB0bXAudHlwZSA9PT0gRnJhZ21lbnQgJiYgdG1wLmtleSA9PSBudWxsO1xuXHRcdFx0bGV0IHJlbmRlclJlc3VsdCA9IGlzVG9wTGV2ZWxGcmFnbWVudCA/IHRtcC5wcm9wcy5jaGlsZHJlbiA6IHRtcDtcblxuXHRcdFx0ZGlmZkNoaWxkcmVuKFxuXHRcdFx0XHRwYXJlbnREb20sXG5cdFx0XHRcdEFycmF5LmlzQXJyYXkocmVuZGVyUmVzdWx0KSA/IHJlbmRlclJlc3VsdCA6IFtyZW5kZXJSZXN1bHRdLFxuXHRcdFx0XHRuZXdWTm9kZSxcblx0XHRcdFx0b2xkVk5vZGUsXG5cdFx0XHRcdGdsb2JhbENvbnRleHQsXG5cdFx0XHRcdGlzU3ZnLFxuXHRcdFx0XHRleGNlc3NEb21DaGlsZHJlbixcblx0XHRcdFx0Y29tbWl0UXVldWUsXG5cdFx0XHRcdG9sZERvbSxcblx0XHRcdFx0aXNIeWRyYXRpbmdcblx0XHRcdCk7XG5cblx0XHRcdGMuYmFzZSA9IG5ld1ZOb2RlLl9kb207XG5cblx0XHRcdC8vIFdlIHN1Y2Nlc3NmdWxseSByZW5kZXJlZCB0aGlzIFZOb2RlLCB1bnNldCBhbnkgc3RvcmVkIGh5ZHJhdGlvbi9iYWlsb3V0IHN0YXRlOlxuXHRcdFx0bmV3Vk5vZGUuX2h5ZHJhdGluZyA9IG51bGw7XG5cblx0XHRcdGlmIChjLl9yZW5kZXJDYWxsYmFja3MubGVuZ3RoKSB7XG5cdFx0XHRcdGNvbW1pdFF1ZXVlLnB1c2goYyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjbGVhclByb2Nlc3NpbmdFeGNlcHRpb24pIHtcblx0XHRcdFx0Yy5fcGVuZGluZ0Vycm9yID0gYy5fcHJvY2Vzc2luZ0V4Y2VwdGlvbiA9IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGMuX2ZvcmNlID0gZmFsc2U7XG5cdFx0fSBlbHNlIGlmIChcblx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuID09IG51bGwgJiZcblx0XHRcdG5ld1ZOb2RlLl9vcmlnaW5hbCA9PT0gb2xkVk5vZGUuX29yaWdpbmFsXG5cdFx0KSB7XG5cdFx0XHRuZXdWTm9kZS5fY2hpbGRyZW4gPSBvbGRWTm9kZS5fY2hpbGRyZW47XG5cdFx0XHRuZXdWTm9kZS5fZG9tID0gb2xkVk5vZGUuX2RvbTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bmV3Vk5vZGUuX2RvbSA9IGRpZmZFbGVtZW50Tm9kZXMoXG5cdFx0XHRcdG9sZFZOb2RlLl9kb20sXG5cdFx0XHRcdG5ld1ZOb2RlLFxuXHRcdFx0XHRvbGRWTm9kZSxcblx0XHRcdFx0Z2xvYmFsQ29udGV4dCxcblx0XHRcdFx0aXNTdmcsXG5cdFx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuLFxuXHRcdFx0XHRjb21taXRRdWV1ZSxcblx0XHRcdFx0aXNIeWRyYXRpbmdcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0aWYgKCh0bXAgPSBvcHRpb25zLmRpZmZlZCkpIHRtcChuZXdWTm9kZSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRuZXdWTm9kZS5fb3JpZ2luYWwgPSBudWxsO1xuXHRcdC8vIGlmIGh5ZHJhdGluZyBvciBjcmVhdGluZyBpbml0aWFsIHRyZWUsIGJhaWxvdXQgcHJlc2VydmVzIERPTTpcblx0XHRpZiAoaXNIeWRyYXRpbmcgfHwgZXhjZXNzRG9tQ2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0bmV3Vk5vZGUuX2RvbSA9IG9sZERvbTtcblx0XHRcdG5ld1ZOb2RlLl9oeWRyYXRpbmcgPSAhIWlzSHlkcmF0aW5nO1xuXHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW5bZXhjZXNzRG9tQ2hpbGRyZW4uaW5kZXhPZihvbGREb20pXSA9IG51bGw7XG5cdFx0XHQvLyBeIGNvdWxkIHBvc3NpYmx5IGJlIHNpbXBsaWZpZWQgdG86XG5cdFx0XHQvLyBleGNlc3NEb21DaGlsZHJlbi5sZW5ndGggPSAwO1xuXHRcdH1cblx0XHRvcHRpb25zLl9jYXRjaEVycm9yKGUsIG5ld1ZOb2RlLCBvbGRWTm9kZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5Db21wb25lbnQ+fSBjb21taXRRdWV1ZSBMaXN0IG9mIGNvbXBvbmVudHNcbiAqIHdoaWNoIGhhdmUgY2FsbGJhY2tzIHRvIGludm9rZSBpbiBjb21taXRSb290XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gcm9vdFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tbWl0Um9vdChjb21taXRRdWV1ZSwgcm9vdCkge1xuXHRpZiAob3B0aW9ucy5fY29tbWl0KSBvcHRpb25zLl9jb21taXQocm9vdCwgY29tbWl0UXVldWUpO1xuXG5cdGNvbW1pdFF1ZXVlLnNvbWUoYyA9PiB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIEB0cy1pZ25vcmUgUmV1c2UgdGhlIGNvbW1pdFF1ZXVlIHZhcmlhYmxlIGhlcmUgc28gdGhlIHR5cGUgY2hhbmdlc1xuXHRcdFx0Y29tbWl0UXVldWUgPSBjLl9yZW5kZXJDYWxsYmFja3M7XG5cdFx0XHRjLl9yZW5kZXJDYWxsYmFja3MgPSBbXTtcblx0XHRcdGNvbW1pdFF1ZXVlLnNvbWUoY2IgPT4ge1xuXHRcdFx0XHQvLyBAdHMtaWdub3JlIFNlZSBhYm92ZSB0cy1pZ25vcmUgb24gY29tbWl0UXVldWVcblx0XHRcdFx0Y2IuY2FsbChjKTtcblx0XHRcdH0pO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdG9wdGlvbnMuX2NhdGNoRXJyb3IoZSwgYy5fdm5vZGUpO1xuXHRcdH1cblx0fSk7XG59XG5cbi8qKlxuICogRGlmZiB0d28gdmlydHVhbCBub2RlcyByZXByZXNlbnRpbmcgRE9NIGVsZW1lbnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IGRvbSBUaGUgRE9NIGVsZW1lbnQgcmVwcmVzZW50aW5nXG4gKiB0aGUgdmlydHVhbCBub2RlcyBiZWluZyBkaWZmZWRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBuZXdWTm9kZSBUaGUgbmV3IHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IG9sZFZOb2RlIFRoZSBvbGQgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gZ2xvYmFsQ29udGV4dCBUaGUgY3VycmVudCBjb250ZXh0IG9iamVjdFxuICogQHBhcmFtIHtib29sZWFufSBpc1N2ZyBXaGV0aGVyIG9yIG5vdCB0aGlzIERPTSBub2RlIGlzIGFuIFNWRyBub2RlXG4gKiBAcGFyYW0geyp9IGV4Y2Vzc0RvbUNoaWxkcmVuXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5Db21wb25lbnQ+fSBjb21taXRRdWV1ZSBMaXN0IG9mIGNvbXBvbmVudHNcbiAqIHdoaWNoIGhhdmUgY2FsbGJhY2tzIHRvIGludm9rZSBpbiBjb21taXRSb290XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzSHlkcmF0aW5nIFdoZXRoZXIgb3Igbm90IHdlIGFyZSBpbiBoeWRyYXRpb25cbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH1cbiAqL1xuZnVuY3Rpb24gZGlmZkVsZW1lbnROb2Rlcyhcblx0ZG9tLFxuXHRuZXdWTm9kZSxcblx0b2xkVk5vZGUsXG5cdGdsb2JhbENvbnRleHQsXG5cdGlzU3ZnLFxuXHRleGNlc3NEb21DaGlsZHJlbixcblx0Y29tbWl0UXVldWUsXG5cdGlzSHlkcmF0aW5nXG4pIHtcblx0bGV0IG9sZFByb3BzID0gb2xkVk5vZGUucHJvcHM7XG5cdGxldCBuZXdQcm9wcyA9IG5ld1ZOb2RlLnByb3BzO1xuXHRsZXQgbm9kZVR5cGUgPSBuZXdWTm9kZS50eXBlO1xuXHRsZXQgaSA9IDA7XG5cblx0Ly8gVHJhY2tzIGVudGVyaW5nIGFuZCBleGl0aW5nIFNWRyBuYW1lc3BhY2Ugd2hlbiBkZXNjZW5kaW5nIHRocm91Z2ggdGhlIHRyZWUuXG5cdGlmIChub2RlVHlwZSA9PT0gJ3N2ZycpIGlzU3ZnID0gdHJ1ZTtcblxuXHRpZiAoZXhjZXNzRG9tQ2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdGZvciAoOyBpIDwgZXhjZXNzRG9tQ2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IGNoaWxkID0gZXhjZXNzRG9tQ2hpbGRyZW5baV07XG5cblx0XHRcdC8vIGlmIG5ld1ZOb2RlIG1hdGNoZXMgYW4gZWxlbWVudCBpbiBleGNlc3NEb21DaGlsZHJlbiBvciB0aGUgYGRvbWBcblx0XHRcdC8vIGFyZ3VtZW50IG1hdGNoZXMgYW4gZWxlbWVudCBpbiBleGNlc3NEb21DaGlsZHJlbiwgcmVtb3ZlIGl0IGZyb21cblx0XHRcdC8vIGV4Y2Vzc0RvbUNoaWxkcmVuIHNvIGl0IGlzbid0IGxhdGVyIHJlbW92ZWQgaW4gZGlmZkNoaWxkcmVuXG5cdFx0XHRpZiAoXG5cdFx0XHRcdGNoaWxkICYmXG5cdFx0XHRcdCdzZXRBdHRyaWJ1dGUnIGluIGNoaWxkID09PSAhIW5vZGVUeXBlICYmXG5cdFx0XHRcdChub2RlVHlwZSA/IGNoaWxkLmxvY2FsTmFtZSA9PT0gbm9kZVR5cGUgOiBjaGlsZC5ub2RlVHlwZSA9PT0gMylcblx0XHRcdCkge1xuXHRcdFx0XHRkb20gPSBjaGlsZDtcblx0XHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW5baV0gPSBudWxsO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoZG9tID09IG51bGwpIHtcblx0XHRpZiAobm9kZVR5cGUgPT09IG51bGwpIHtcblx0XHRcdC8vIEB0cy1pZ25vcmUgY3JlYXRlVGV4dE5vZGUgcmV0dXJucyBUZXh0LCB3ZSBleHBlY3QgUHJlYWN0RWxlbWVudFxuXHRcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5ld1Byb3BzKTtcblx0XHR9XG5cblx0XHRpZiAoaXNTdmcpIHtcblx0XHRcdGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcblx0XHRcdFx0J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZSBXZSBrbm93IGBuZXdWTm9kZS50eXBlYCBpcyBhIHN0cmluZ1xuXHRcdFx0XHRub2RlVHlwZVxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZSBXZSBrbm93IGBuZXdWTm9kZS50eXBlYCBpcyBhIHN0cmluZ1xuXHRcdFx0XHRub2RlVHlwZSxcblx0XHRcdFx0bmV3UHJvcHMuaXMgJiYgbmV3UHJvcHNcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Ly8gd2UgY3JlYXRlZCBhIG5ldyBwYXJlbnQsIHNvIG5vbmUgb2YgdGhlIHByZXZpb3VzbHkgYXR0YWNoZWQgY2hpbGRyZW4gY2FuIGJlIHJldXNlZDpcblx0XHRleGNlc3NEb21DaGlsZHJlbiA9IG51bGw7XG5cdFx0Ly8gd2UgYXJlIGNyZWF0aW5nIGEgbmV3IG5vZGUsIHNvIHdlIGNhbiBhc3N1bWUgdGhpcyBpcyBhIG5ldyBzdWJ0cmVlIChpbiBjYXNlIHdlIGFyZSBoeWRyYXRpbmcpLCB0aGlzIGRlb3B0cyB0aGUgaHlkcmF0ZVxuXHRcdGlzSHlkcmF0aW5nID0gZmFsc2U7XG5cdH1cblxuXHRpZiAobm9kZVR5cGUgPT09IG51bGwpIHtcblx0XHQvLyBEdXJpbmcgaHlkcmF0aW9uLCB3ZSBzdGlsbCBoYXZlIHRvIHNwbGl0IG1lcmdlZCB0ZXh0IGZyb20gU1NSJ2QgSFRNTC5cblx0XHRpZiAob2xkUHJvcHMgIT09IG5ld1Byb3BzICYmICghaXNIeWRyYXRpbmcgfHwgZG9tLmRhdGEgIT09IG5ld1Byb3BzKSkge1xuXHRcdFx0ZG9tLmRhdGEgPSBuZXdQcm9wcztcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Ly8gSWYgZXhjZXNzRG9tQ2hpbGRyZW4gd2FzIG5vdCBudWxsLCByZXBvcHVsYXRlIGl0IHdpdGggdGhlIGN1cnJlbnQgZWxlbWVudCdzIGNoaWxkcmVuOlxuXHRcdGV4Y2Vzc0RvbUNoaWxkcmVuID0gZXhjZXNzRG9tQ2hpbGRyZW4gJiYgc2xpY2UuY2FsbChkb20uY2hpbGROb2Rlcyk7XG5cblx0XHRvbGRQcm9wcyA9IG9sZFZOb2RlLnByb3BzIHx8IEVNUFRZX09CSjtcblxuXHRcdGxldCBvbGRIdG1sID0gb2xkUHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw7XG5cdFx0bGV0IG5ld0h0bWwgPSBuZXdQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTDtcblxuXHRcdC8vIER1cmluZyBoeWRyYXRpb24sIHByb3BzIGFyZSBub3QgZGlmZmVkIGF0IGFsbCAoaW5jbHVkaW5nIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKVxuXHRcdC8vIEBUT0RPIHdlIHNob3VsZCB3YXJuIGluIGRlYnVnIG1vZGUgd2hlbiBwcm9wcyBkb24ndCBtYXRjaCBoZXJlLlxuXHRcdGlmICghaXNIeWRyYXRpbmcpIHtcblx0XHRcdC8vIEJ1dCwgaWYgd2UgYXJlIGluIGEgc2l0dWF0aW9uIHdoZXJlIHdlIGFyZSB1c2luZyBleGlzdGluZyBET00gKGUuZy4gcmVwbGFjZU5vZGUpXG5cdFx0XHQvLyB3ZSBzaG91bGQgcmVhZCB0aGUgZXhpc3RpbmcgRE9NIGF0dHJpYnV0ZXMgdG8gZGlmZiB0aGVtXG5cdFx0XHRpZiAoZXhjZXNzRG9tQ2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0XHRvbGRQcm9wcyA9IHt9O1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgZG9tLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRvbGRQcm9wc1tkb20uYXR0cmlidXRlc1tpXS5uYW1lXSA9IGRvbS5hdHRyaWJ1dGVzW2ldLnZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChuZXdIdG1sIHx8IG9sZEh0bWwpIHtcblx0XHRcdFx0Ly8gQXZvaWQgcmUtYXBwbHlpbmcgdGhlIHNhbWUgJ19faHRtbCcgaWYgaXQgZGlkIG5vdCBjaGFuZ2VkIGJldHdlZW4gcmUtcmVuZGVyXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHQhbmV3SHRtbCB8fFxuXHRcdFx0XHRcdCgoIW9sZEh0bWwgfHwgbmV3SHRtbC5fX2h0bWwgIT0gb2xkSHRtbC5fX2h0bWwpICYmXG5cdFx0XHRcdFx0XHRuZXdIdG1sLl9faHRtbCAhPT0gZG9tLmlubmVySFRNTClcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0ZG9tLmlubmVySFRNTCA9IChuZXdIdG1sICYmIG5ld0h0bWwuX19odG1sKSB8fCAnJztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGRpZmZQcm9wcyhkb20sIG5ld1Byb3BzLCBvbGRQcm9wcywgaXNTdmcsIGlzSHlkcmF0aW5nKTtcblxuXHRcdC8vIElmIHRoZSBuZXcgdm5vZGUgZGlkbid0IGhhdmUgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwsIGRpZmYgaXRzIGNoaWxkcmVuXG5cdFx0aWYgKG5ld0h0bWwpIHtcblx0XHRcdG5ld1ZOb2RlLl9jaGlsZHJlbiA9IFtdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpID0gbmV3Vk5vZGUucHJvcHMuY2hpbGRyZW47XG5cdFx0XHRkaWZmQ2hpbGRyZW4oXG5cdFx0XHRcdGRvbSxcblx0XHRcdFx0QXJyYXkuaXNBcnJheShpKSA/IGkgOiBbaV0sXG5cdFx0XHRcdG5ld1ZOb2RlLFxuXHRcdFx0XHRvbGRWTm9kZSxcblx0XHRcdFx0Z2xvYmFsQ29udGV4dCxcblx0XHRcdFx0aXNTdmcgJiYgbm9kZVR5cGUgIT09ICdmb3JlaWduT2JqZWN0Jyxcblx0XHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdFx0XHRcdGNvbW1pdFF1ZXVlLFxuXHRcdFx0XHRleGNlc3NEb21DaGlsZHJlblxuXHRcdFx0XHRcdD8gZXhjZXNzRG9tQ2hpbGRyZW5bMF1cblx0XHRcdFx0XHQ6IG9sZFZOb2RlLl9jaGlsZHJlbiAmJiBnZXREb21TaWJsaW5nKG9sZFZOb2RlLCAwKSxcblx0XHRcdFx0aXNIeWRyYXRpbmdcblx0XHRcdCk7XG5cblx0XHRcdC8vIFJlbW92ZSBjaGlsZHJlbiB0aGF0IGFyZSBub3QgcGFydCBvZiBhbnkgdm5vZGUuXG5cdFx0XHRpZiAoZXhjZXNzRG9tQ2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0XHRmb3IgKGkgPSBleGNlc3NEb21DaGlsZHJlbi5sZW5ndGg7IGktLTsgKSB7XG5cdFx0XHRcdFx0aWYgKGV4Y2Vzc0RvbUNoaWxkcmVuW2ldICE9IG51bGwpIHJlbW92ZU5vZGUoZXhjZXNzRG9tQ2hpbGRyZW5baV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gKGFzIGFib3ZlLCBkb24ndCBkaWZmIHByb3BzIGR1cmluZyBoeWRyYXRpb24pXG5cdFx0aWYgKCFpc0h5ZHJhdGluZykge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHQndmFsdWUnIGluIG5ld1Byb3BzICYmXG5cdFx0XHRcdChpID0gbmV3UHJvcHMudmFsdWUpICE9PSB1bmRlZmluZWQgJiZcblx0XHRcdFx0Ly8gIzI3NTYgRm9yIHRoZSA8cHJvZ3Jlc3M+LWVsZW1lbnQgdGhlIGluaXRpYWwgdmFsdWUgaXMgMCxcblx0XHRcdFx0Ly8gZGVzcGl0ZSB0aGUgYXR0cmlidXRlIG5vdCBiZWluZyBwcmVzZW50LiBXaGVuIHRoZSBhdHRyaWJ1dGVcblx0XHRcdFx0Ly8gaXMgbWlzc2luZyB0aGUgcHJvZ3Jlc3MgYmFyIGlzIHRyZWF0ZWQgYXMgaW5kZXRlcm1pbmF0ZS5cblx0XHRcdFx0Ly8gVG8gZml4IHRoYXQgd2UnbGwgYWx3YXlzIHVwZGF0ZSBpdCB3aGVuIGl0IGlzIDAgZm9yIHByb2dyZXNzIGVsZW1lbnRzXG5cdFx0XHRcdChpICE9PSBkb20udmFsdWUgfHxcblx0XHRcdFx0XHQobm9kZVR5cGUgPT09ICdwcm9ncmVzcycgJiYgIWkpIHx8XG5cdFx0XHRcdFx0Ly8gVGhpcyBpcyBvbmx5IGZvciBJRSAxMSB0byBmaXggPHNlbGVjdD4gdmFsdWUgbm90IGJlaW5nIHVwZGF0ZWQuXG5cdFx0XHRcdFx0Ly8gVG8gYXZvaWQgYSBzdGFsZSBzZWxlY3QgdmFsdWUgd2UgbmVlZCB0byBzZXQgdGhlIG9wdGlvbi52YWx1ZVxuXHRcdFx0XHRcdC8vIGFnYWluLCB3aGljaCB0cmlnZ2VycyBJRTExIHRvIHJlLWV2YWx1YXRlIHRoZSBzZWxlY3QgdmFsdWVcblx0XHRcdFx0XHQobm9kZVR5cGUgPT09ICdvcHRpb24nICYmIGkgIT09IG9sZFByb3BzLnZhbHVlKSlcblx0XHRcdCkge1xuXHRcdFx0XHRzZXRQcm9wZXJ0eShkb20sICd2YWx1ZScsIGksIG9sZFByb3BzLnZhbHVlLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoXG5cdFx0XHRcdCdjaGVja2VkJyBpbiBuZXdQcm9wcyAmJlxuXHRcdFx0XHQoaSA9IG5ld1Byb3BzLmNoZWNrZWQpICE9PSB1bmRlZmluZWQgJiZcblx0XHRcdFx0aSAhPT0gZG9tLmNoZWNrZWRcblx0XHRcdCkge1xuXHRcdFx0XHRzZXRQcm9wZXJ0eShkb20sICdjaGVja2VkJywgaSwgb2xkUHJvcHMuY2hlY2tlZCwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBkb207XG59XG5cbi8qKlxuICogSW52b2tlIG9yIHVwZGF0ZSBhIHJlZiwgZGVwZW5kaW5nIG9uIHdoZXRoZXIgaXQgaXMgYSBmdW5jdGlvbiBvciBvYmplY3QgcmVmLlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHJlZlxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5UmVmKHJlZiwgdmFsdWUsIHZub2RlKSB7XG5cdHRyeSB7XG5cdFx0aWYgKHR5cGVvZiByZWYgPT0gJ2Z1bmN0aW9uJykgcmVmKHZhbHVlKTtcblx0XHRlbHNlIHJlZi5jdXJyZW50ID0gdmFsdWU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRvcHRpb25zLl9jYXRjaEVycm9yKGUsIHZub2RlKTtcblx0fVxufVxuXG4vKipcbiAqIFVubW91bnQgYSB2aXJ0dWFsIG5vZGUgZnJvbSB0aGUgdHJlZSBhbmQgYXBwbHkgRE9NIGNoYW5nZXNcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZSBUaGUgdmlydHVhbCBub2RlIHRvIHVubW91bnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBwYXJlbnRWTm9kZSBUaGUgcGFyZW50IG9mIHRoZSBWTm9kZSB0aGF0XG4gKiBpbml0aWF0ZWQgdGhlIHVubW91bnRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBSZW1vdmVdIEZsYWcgdGhhdCBpbmRpY2F0ZXMgdGhhdCBhIHBhcmVudCBub2RlIG9mIHRoZVxuICogY3VycmVudCBlbGVtZW50IGlzIGFscmVhZHkgZGV0YWNoZWQgZnJvbSB0aGUgRE9NLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5tb3VudCh2bm9kZSwgcGFyZW50Vk5vZGUsIHNraXBSZW1vdmUpIHtcblx0bGV0IHI7XG5cdGlmIChvcHRpb25zLnVubW91bnQpIG9wdGlvbnMudW5tb3VudCh2bm9kZSk7XG5cblx0aWYgKChyID0gdm5vZGUucmVmKSkge1xuXHRcdGlmICghci5jdXJyZW50IHx8IHIuY3VycmVudCA9PT0gdm5vZGUuX2RvbSkge1xuXHRcdFx0YXBwbHlSZWYociwgbnVsbCwgcGFyZW50Vk5vZGUpO1xuXHRcdH1cblx0fVxuXG5cdGlmICgociA9IHZub2RlLl9jb21wb25lbnQpICE9IG51bGwpIHtcblx0XHRpZiAoci5jb21wb25lbnRXaWxsVW5tb3VudCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ci5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRvcHRpb25zLl9jYXRjaEVycm9yKGUsIHBhcmVudFZOb2RlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyLmJhc2UgPSByLl9wYXJlbnREb20gPSBudWxsO1xuXHRcdHZub2RlLl9jb21wb25lbnQgPSB1bmRlZmluZWQ7XG5cdH1cblxuXHRpZiAoKHIgPSB2bm9kZS5fY2hpbGRyZW4pKSB7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCByLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAocltpXSkge1xuXHRcdFx0XHR1bm1vdW50KFxuXHRcdFx0XHRcdHJbaV0sXG5cdFx0XHRcdFx0cGFyZW50Vk5vZGUsXG5cdFx0XHRcdFx0c2tpcFJlbW92ZSB8fCB0eXBlb2Ygdm5vZGUudHlwZSAhPT0gJ2Z1bmN0aW9uJ1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICghc2tpcFJlbW92ZSAmJiB2bm9kZS5fZG9tICE9IG51bGwpIHtcblx0XHRyZW1vdmVOb2RlKHZub2RlLl9kb20pO1xuXHR9XG5cblx0Ly8gTXVzdCBiZSBzZXQgdG8gYHVuZGVmaW5lZGAgdG8gcHJvcGVybHkgY2xlYW4gdXAgYF9uZXh0RG9tYFxuXHQvLyBmb3Igd2hpY2ggYG51bGxgIGlzIGEgdmFsaWQgdmFsdWUuIFNlZSBjb21tZW50IGluIGBjcmVhdGUtZWxlbWVudC5qc2Bcblx0dm5vZGUuX3BhcmVudCA9IHZub2RlLl9kb20gPSB2bm9kZS5fbmV4dERvbSA9IHVuZGVmaW5lZDtcbn1cblxuLyoqIFRoZSBgLnJlbmRlcigpYCBtZXRob2QgZm9yIGEgUEZDIGJhY2tpbmcgaW5zdGFuY2UuICovXG5mdW5jdGlvbiBkb1JlbmRlcihwcm9wcywgc3RhdGUsIGNvbnRleHQpIHtcblx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IocHJvcHMsIGNvbnRleHQpO1xufVxuIiwgImltcG9ydCB7IEVNUFRZX09CSiB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IGNvbW1pdFJvb3QsIGRpZmYgfSBmcm9tICcuL2RpZmYvaW5kZXgnO1xuaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgRnJhZ21lbnQgfSBmcm9tICcuL2NyZWF0ZS1lbGVtZW50JztcbmltcG9ydCBvcHRpb25zIGZyb20gJy4vb3B0aW9ucyc7XG5pbXBvcnQgeyBzbGljZSB9IGZyb20gJy4vdXRpbCc7XG5cbi8qKlxuICogUmVuZGVyIGEgUHJlYWN0IHZpcnR1YWwgbm9kZSBpbnRvIGEgRE9NIGVsZW1lbnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50Q2hpbGR9IHZub2RlIFRoZSB2aXJ0dWFsIG5vZGUgdG8gcmVuZGVyXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IHBhcmVudERvbSBUaGUgRE9NIGVsZW1lbnQgdG9cbiAqIHJlbmRlciBpbnRvXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnQgfCBvYmplY3R9IFtyZXBsYWNlTm9kZV0gT3B0aW9uYWw6IEF0dGVtcHQgdG8gcmUtdXNlIGFuXG4gKiBleGlzdGluZyBET00gdHJlZSByb290ZWQgYXQgYHJlcGxhY2VOb2RlYFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyKHZub2RlLCBwYXJlbnREb20sIHJlcGxhY2VOb2RlKSB7XG5cdGlmIChvcHRpb25zLl9yb290KSBvcHRpb25zLl9yb290KHZub2RlLCBwYXJlbnREb20pO1xuXG5cdC8vIFdlIGFidXNlIHRoZSBgcmVwbGFjZU5vZGVgIHBhcmFtZXRlciBpbiBgaHlkcmF0ZSgpYCB0byBzaWduYWwgaWYgd2UgYXJlIGluXG5cdC8vIGh5ZHJhdGlvbiBtb2RlIG9yIG5vdCBieSBwYXNzaW5nIHRoZSBgaHlkcmF0ZWAgZnVuY3Rpb24gaW5zdGVhZCBvZiBhIERPTVxuXHQvLyBlbGVtZW50Li5cblx0bGV0IGlzSHlkcmF0aW5nID0gdHlwZW9mIHJlcGxhY2VOb2RlID09PSAnZnVuY3Rpb24nO1xuXG5cdC8vIFRvIGJlIGFibGUgdG8gc3VwcG9ydCBjYWxsaW5nIGByZW5kZXIoKWAgbXVsdGlwbGUgdGltZXMgb24gdGhlIHNhbWVcblx0Ly8gRE9NIG5vZGUsIHdlIG5lZWQgdG8gb2J0YWluIGEgcmVmZXJlbmNlIHRvIHRoZSBwcmV2aW91cyB0cmVlLiBXZSBkb1xuXHQvLyB0aGlzIGJ5IGFzc2lnbmluZyBhIG5ldyBgX2NoaWxkcmVuYCBwcm9wZXJ0eSB0byBET00gbm9kZXMgd2hpY2ggcG9pbnRzXG5cdC8vIHRvIHRoZSBsYXN0IHJlbmRlcmVkIHRyZWUuIEJ5IGRlZmF1bHQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgcHJlc2VudCwgd2hpY2hcblx0Ly8gbWVhbnMgdGhhdCB3ZSBhcmUgbW91bnRpbmcgYSBuZXcgdHJlZSBmb3IgdGhlIGZpcnN0IHRpbWUuXG5cdGxldCBvbGRWTm9kZSA9IGlzSHlkcmF0aW5nXG5cdFx0PyBudWxsXG5cdFx0OiAocmVwbGFjZU5vZGUgJiYgcmVwbGFjZU5vZGUuX2NoaWxkcmVuKSB8fCBwYXJlbnREb20uX2NoaWxkcmVuO1xuXG5cdHZub2RlID0gKFxuXHRcdCghaXNIeWRyYXRpbmcgJiYgcmVwbGFjZU5vZGUpIHx8XG5cdFx0cGFyZW50RG9tXG5cdCkuX2NoaWxkcmVuID0gY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCwgW3Zub2RlXSk7XG5cblx0Ly8gTGlzdCBvZiBlZmZlY3RzIHRoYXQgbmVlZCB0byBiZSBjYWxsZWQgYWZ0ZXIgZGlmZmluZy5cblx0bGV0IGNvbW1pdFF1ZXVlID0gW107XG5cdGRpZmYoXG5cdFx0cGFyZW50RG9tLFxuXHRcdC8vIERldGVybWluZSB0aGUgbmV3IHZub2RlIHRyZWUgYW5kIHN0b3JlIGl0IG9uIHRoZSBET00gZWxlbWVudCBvblxuXHRcdC8vIG91ciBjdXN0b20gYF9jaGlsZHJlbmAgcHJvcGVydHkuXG5cdFx0dm5vZGUsXG5cdFx0b2xkVk5vZGUgfHwgRU1QVFlfT0JKLFxuXHRcdEVNUFRZX09CSixcblx0XHRwYXJlbnREb20ub3duZXJTVkdFbGVtZW50ICE9PSB1bmRlZmluZWQsXG5cdFx0IWlzSHlkcmF0aW5nICYmIHJlcGxhY2VOb2RlXG5cdFx0XHQ/IFtyZXBsYWNlTm9kZV1cblx0XHRcdDogb2xkVk5vZGVcblx0XHRcdD8gbnVsbFxuXHRcdFx0OiBwYXJlbnREb20uZmlyc3RDaGlsZFxuXHRcdFx0PyBzbGljZS5jYWxsKHBhcmVudERvbS5jaGlsZE5vZGVzKVxuXHRcdFx0OiBudWxsLFxuXHRcdGNvbW1pdFF1ZXVlLFxuXHRcdCFpc0h5ZHJhdGluZyAmJiByZXBsYWNlTm9kZVxuXHRcdFx0PyByZXBsYWNlTm9kZVxuXHRcdFx0OiBvbGRWTm9kZVxuXHRcdFx0PyBvbGRWTm9kZS5fZG9tXG5cdFx0XHQ6IHBhcmVudERvbS5maXJzdENoaWxkLFxuXHRcdGlzSHlkcmF0aW5nXG5cdCk7XG5cblx0Ly8gRmx1c2ggYWxsIHF1ZXVlZCBlZmZlY3RzXG5cdGNvbW1pdFJvb3QoY29tbWl0UXVldWUsIHZub2RlKTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgYW4gZXhpc3RpbmcgRE9NIGVsZW1lbnQgd2l0aCBkYXRhIGZyb20gYSBQcmVhY3QgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudENoaWxkfSB2bm9kZSBUaGUgdmlydHVhbCBub2RlIHRvIHJlbmRlclxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBwYXJlbnREb20gVGhlIERPTSBlbGVtZW50IHRvXG4gKiB1cGRhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGh5ZHJhdGUodm5vZGUsIHBhcmVudERvbSkge1xuXHRyZW5kZXIodm5vZGUsIHBhcmVudERvbSwgaHlkcmF0ZSk7XG59XG4iLCAiaW1wb3J0IHsgYXNzaWduLCBzbGljZSB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgeyBjcmVhdGVWTm9kZSB9IGZyb20gJy4vY3JlYXRlLWVsZW1lbnQnO1xuXG4vKipcbiAqIENsb25lcyB0aGUgZ2l2ZW4gVk5vZGUsIG9wdGlvbmFsbHkgYWRkaW5nIGF0dHJpYnV0ZXMvcHJvcHMgYW5kIHJlcGxhY2luZyBpdHMgY2hpbGRyZW4uXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZSBUaGUgdmlydHVhbCBET00gZWxlbWVudCB0byBjbG9uZVxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzIEF0dHJpYnV0ZXMvcHJvcHMgdG8gYWRkIHdoZW4gY2xvbmluZ1xuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnRDaGlsZHJlbj59IHJlc3QgQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHdpbGwgYmUgdXNlZCBhcyByZXBsYWNlbWVudCBjaGlsZHJlbi5cbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lRWxlbWVudCh2bm9kZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG5cdGxldCBub3JtYWxpemVkUHJvcHMgPSBhc3NpZ24oe30sIHZub2RlLnByb3BzKSxcblx0XHRrZXksXG5cdFx0cmVmLFxuXHRcdGk7XG5cdGZvciAoaSBpbiBwcm9wcykge1xuXHRcdGlmIChpID09ICdrZXknKSBrZXkgPSBwcm9wc1tpXTtcblx0XHRlbHNlIGlmIChpID09ICdyZWYnKSByZWYgPSBwcm9wc1tpXTtcblx0XHRlbHNlIG5vcm1hbGl6ZWRQcm9wc1tpXSA9IHByb3BzW2ldO1xuXHR9XG5cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG5cdFx0bm9ybWFsaXplZFByb3BzLmNoaWxkcmVuID1cblx0XHRcdGFyZ3VtZW50cy5sZW5ndGggPiAzID8gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpIDogY2hpbGRyZW47XG5cdH1cblxuXHRyZXR1cm4gY3JlYXRlVk5vZGUoXG5cdFx0dm5vZGUudHlwZSxcblx0XHRub3JtYWxpemVkUHJvcHMsXG5cdFx0a2V5IHx8IHZub2RlLmtleSxcblx0XHRyZWYgfHwgdm5vZGUucmVmLFxuXHRcdG51bGxcblx0KTtcbn1cbiIsICIvKipcbiAqIEZpbmQgdGhlIGNsb3Nlc3QgZXJyb3IgYm91bmRhcnkgdG8gYSB0aHJvd24gZXJyb3IgYW5kIGNhbGwgaXRcbiAqIEBwYXJhbSB7b2JqZWN0fSBlcnJvciBUaGUgdGhyb3duIHZhbHVlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGUgVGhlIHZub2RlIHRoYXQgdGhyZXdcbiAqIHRoZSBlcnJvciB0aGF0IHdhcyBjYXVnaHQgKGV4Y2VwdCBmb3IgdW5tb3VudGluZyB3aGVuIHRoaXMgcGFyYW1ldGVyXG4gKiBpcyB0aGUgaGlnaGVzdCBwYXJlbnQgdGhhdCB3YXMgYmVpbmcgdW5tb3VudGVkKVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IFtvbGRWTm9kZV1cbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLkVycm9ySW5mb30gW2Vycm9ySW5mb11cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9jYXRjaEVycm9yKGVycm9yLCB2bm9kZSwgb2xkVk5vZGUsIGVycm9ySW5mbykge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5Db21wb25lbnR9ICovXG5cdGxldCBjb21wb25lbnQsIGN0b3IsIGhhbmRsZWQ7XG5cblx0Zm9yICg7ICh2bm9kZSA9IHZub2RlLl9wYXJlbnQpOyApIHtcblx0XHRpZiAoKGNvbXBvbmVudCA9IHZub2RlLl9jb21wb25lbnQpICYmICFjb21wb25lbnQuX3Byb2Nlc3NpbmdFeGNlcHRpb24pIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGN0b3IgPSBjb21wb25lbnQuY29uc3RydWN0b3I7XG5cblx0XHRcdFx0aWYgKGN0b3IgJiYgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGNvbXBvbmVudC5zZXRTdGF0ZShjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcikpO1xuXHRcdFx0XHRcdGhhbmRsZWQgPSBjb21wb25lbnQuX2RpcnR5O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGNvbXBvbmVudC5jb21wb25lbnREaWRDYXRjaCAhPSBudWxsKSB7XG5cdFx0XHRcdFx0Y29tcG9uZW50LmNvbXBvbmVudERpZENhdGNoKGVycm9yLCBlcnJvckluZm8gfHwge30pO1xuXHRcdFx0XHRcdGhhbmRsZWQgPSBjb21wb25lbnQuX2RpcnR5O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVGhpcyBpcyBhbiBlcnJvciBib3VuZGFyeS4gTWFyayBpdCBhcyBoYXZpbmcgYmFpbGVkIG91dCwgYW5kIHdoZXRoZXIgaXQgd2FzIG1pZC1oeWRyYXRpb24uXG5cdFx0XHRcdGlmIChoYW5kbGVkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIChjb21wb25lbnQuX3BlbmRpbmdFcnJvciA9IGNvbXBvbmVudCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0ZXJyb3IgPSBlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHRocm93IGVycm9yO1xufVxuIiwgImltcG9ydCB7IG9wdGlvbnMgfSBmcm9tICdwcmVhY3QnO1xuXG4vKiogQHR5cGUge251bWJlcn0gKi9cbmxldCBjdXJyZW50SW5kZXg7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSAqL1xubGV0IGN1cnJlbnRDb21wb25lbnQ7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSAqL1xubGV0IHByZXZpb3VzQ29tcG9uZW50O1xuXG4vKiogQHR5cGUge251bWJlcn0gKi9cbmxldCBjdXJyZW50SG9vayA9IDA7XG5cbi8qKiBAdHlwZSB7QXJyYXk8aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50Pn0gKi9cbmxldCBhZnRlclBhaW50RWZmZWN0cyA9IFtdO1xuXG5sZXQgRU1QVFkgPSBbXTtcblxubGV0IG9sZEJlZm9yZURpZmYgPSBvcHRpb25zLl9kaWZmO1xubGV0IG9sZEJlZm9yZVJlbmRlciA9IG9wdGlvbnMuX3JlbmRlcjtcbmxldCBvbGRBZnRlckRpZmYgPSBvcHRpb25zLmRpZmZlZDtcbmxldCBvbGRDb21taXQgPSBvcHRpb25zLl9jb21taXQ7XG5sZXQgb2xkQmVmb3JlVW5tb3VudCA9IG9wdGlvbnMudW5tb3VudDtcblxuY29uc3QgUkFGX1RJTUVPVVQgPSAxMDA7XG5sZXQgcHJldlJhZjtcblxub3B0aW9ucy5fZGlmZiA9IHZub2RlID0+IHtcblx0Y3VycmVudENvbXBvbmVudCA9IG51bGw7XG5cdGlmIChvbGRCZWZvcmVEaWZmKSBvbGRCZWZvcmVEaWZmKHZub2RlKTtcbn07XG5cbm9wdGlvbnMuX3JlbmRlciA9IHZub2RlID0+IHtcblx0aWYgKG9sZEJlZm9yZVJlbmRlcikgb2xkQmVmb3JlUmVuZGVyKHZub2RlKTtcblxuXHRjdXJyZW50Q29tcG9uZW50ID0gdm5vZGUuX2NvbXBvbmVudDtcblx0Y3VycmVudEluZGV4ID0gMDtcblxuXHRjb25zdCBob29rcyA9IGN1cnJlbnRDb21wb25lbnQuX19ob29rcztcblx0aWYgKGhvb2tzKSB7XG5cdFx0aWYgKHByZXZpb3VzQ29tcG9uZW50ID09PSBjdXJyZW50Q29tcG9uZW50KSB7XG5cdFx0XHRob29rcy5fcGVuZGluZ0VmZmVjdHMgPSBbXTtcblx0XHRcdGN1cnJlbnRDb21wb25lbnQuX3JlbmRlckNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0aG9va3MuX2xpc3QuZm9yRWFjaChob29rSXRlbSA9PiB7XG5cdFx0XHRcdGlmIChob29rSXRlbS5fbmV4dFZhbHVlKSB7XG5cdFx0XHRcdFx0aG9va0l0ZW0uX3ZhbHVlID0gaG9va0l0ZW0uX25leHRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRob29rSXRlbS5fcGVuZGluZ1ZhbHVlID0gRU1QVFk7XG5cdFx0XHRcdGhvb2tJdGVtLl9uZXh0VmFsdWUgPSBob29rSXRlbS5fcGVuZGluZ0FyZ3MgPSB1bmRlZmluZWQ7XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aG9va3MuX3BlbmRpbmdFZmZlY3RzLmZvckVhY2goaW52b2tlQ2xlYW51cCk7XG5cdFx0XHRob29rcy5fcGVuZGluZ0VmZmVjdHMuZm9yRWFjaChpbnZva2VFZmZlY3QpO1xuXHRcdFx0aG9va3MuX3BlbmRpbmdFZmZlY3RzID0gW107XG5cdFx0fVxuXHR9XG5cdHByZXZpb3VzQ29tcG9uZW50ID0gY3VycmVudENvbXBvbmVudDtcbn07XG5cbm9wdGlvbnMuZGlmZmVkID0gdm5vZGUgPT4ge1xuXHRpZiAob2xkQWZ0ZXJEaWZmKSBvbGRBZnRlckRpZmYodm5vZGUpO1xuXG5cdGNvbnN0IGMgPSB2bm9kZS5fY29tcG9uZW50O1xuXHRpZiAoYyAmJiBjLl9faG9va3MpIHtcblx0XHRpZiAoYy5fX2hvb2tzLl9wZW5kaW5nRWZmZWN0cy5sZW5ndGgpIGFmdGVyUGFpbnQoYWZ0ZXJQYWludEVmZmVjdHMucHVzaChjKSk7XG5cdFx0Yy5fX2hvb2tzLl9saXN0LmZvckVhY2goaG9va0l0ZW0gPT4ge1xuXHRcdFx0aWYgKGhvb2tJdGVtLl9wZW5kaW5nQXJncykge1xuXHRcdFx0XHRob29rSXRlbS5fYXJncyA9IGhvb2tJdGVtLl9wZW5kaW5nQXJncztcblx0XHRcdH1cblx0XHRcdGlmIChob29rSXRlbS5fcGVuZGluZ1ZhbHVlICE9PSBFTVBUWSkge1xuXHRcdFx0XHRob29rSXRlbS5fdmFsdWUgPSBob29rSXRlbS5fcGVuZGluZ1ZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0aG9va0l0ZW0uX3BlbmRpbmdBcmdzID0gdW5kZWZpbmVkO1xuXHRcdFx0aG9va0l0ZW0uX3BlbmRpbmdWYWx1ZSA9IEVNUFRZO1xuXHRcdH0pO1xuXHR9XG5cdHByZXZpb3VzQ29tcG9uZW50ID0gY3VycmVudENvbXBvbmVudCA9IG51bGw7XG59O1xuXG5vcHRpb25zLl9jb21taXQgPSAodm5vZGUsIGNvbW1pdFF1ZXVlKSA9PiB7XG5cdGNvbW1pdFF1ZXVlLnNvbWUoY29tcG9uZW50ID0+IHtcblx0XHR0cnkge1xuXHRcdFx0Y29tcG9uZW50Ll9yZW5kZXJDYWxsYmFja3MuZm9yRWFjaChpbnZva2VDbGVhbnVwKTtcblx0XHRcdGNvbXBvbmVudC5fcmVuZGVyQ2FsbGJhY2tzID0gY29tcG9uZW50Ll9yZW5kZXJDYWxsYmFja3MuZmlsdGVyKGNiID0+XG5cdFx0XHRcdGNiLl92YWx1ZSA/IGludm9rZUVmZmVjdChjYikgOiB0cnVlXG5cdFx0XHQpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGNvbW1pdFF1ZXVlLnNvbWUoYyA9PiB7XG5cdFx0XHRcdGlmIChjLl9yZW5kZXJDYWxsYmFja3MpIGMuX3JlbmRlckNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0fSk7XG5cdFx0XHRjb21taXRRdWV1ZSA9IFtdO1xuXHRcdFx0b3B0aW9ucy5fY2F0Y2hFcnJvcihlLCBjb21wb25lbnQuX3Zub2RlKTtcblx0XHR9XG5cdH0pO1xuXG5cdGlmIChvbGRDb21taXQpIG9sZENvbW1pdCh2bm9kZSwgY29tbWl0UXVldWUpO1xufTtcblxub3B0aW9ucy51bm1vdW50ID0gdm5vZGUgPT4ge1xuXHRpZiAob2xkQmVmb3JlVW5tb3VudCkgb2xkQmVmb3JlVW5tb3VudCh2bm9kZSk7XG5cblx0Y29uc3QgYyA9IHZub2RlLl9jb21wb25lbnQ7XG5cdGlmIChjICYmIGMuX19ob29rcykge1xuXHRcdGxldCBoYXNFcnJvcmVkO1xuXHRcdGMuX19ob29rcy5fbGlzdC5mb3JFYWNoKHMgPT4ge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aW52b2tlQ2xlYW51cChzKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0aGFzRXJyb3JlZCA9IGU7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0Yy5fX2hvb2tzID0gdW5kZWZpbmVkO1xuXHRcdGlmIChoYXNFcnJvcmVkKSBvcHRpb25zLl9jYXRjaEVycm9yKGhhc0Vycm9yZWQsIGMuX3Zub2RlKTtcblx0fVxufTtcblxuLyoqXG4gKiBHZXQgYSBob29rJ3Mgc3RhdGUgZnJvbSB0aGUgY3VycmVudENvbXBvbmVudFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgaG9vayB0byBnZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlIFRoZSBpbmRleCBvZiB0aGUgaG9vayB0byBnZXRcbiAqIEByZXR1cm5zIHthbnl9XG4gKi9cbmZ1bmN0aW9uIGdldEhvb2tTdGF0ZShpbmRleCwgdHlwZSkge1xuXHRpZiAob3B0aW9ucy5faG9vaykge1xuXHRcdG9wdGlvbnMuX2hvb2soY3VycmVudENvbXBvbmVudCwgaW5kZXgsIGN1cnJlbnRIb29rIHx8IHR5cGUpO1xuXHR9XG5cdGN1cnJlbnRIb29rID0gMDtcblxuXHQvLyBMYXJnZWx5IGluc3BpcmVkIGJ5OlxuXHQvLyAqIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNoYWVsLWtsZWluL2Z1bmN5LmpzL2Jsb2IvZjZiZTczNDY4ZTZlYzQ2YjBmZjVhYTNjYzRjOWJhZjcyYTI5MDI1YS9zcmMvaG9va3MvY29yZV9ob29rcy5tanNcblx0Ly8gKiBodHRwczovL2dpdGh1Yi5jb20vbWljaGFlbC1rbGVpbi9mdW5jeS5qcy9ibG9iLzY1MGJlYWE1OGM0M2MzM2E3NDgyMGEzYzk4YjNjNzA3OWNmMmUzMzMvc3JjL3JlbmRlcmVyLm1qc1xuXHQvLyBPdGhlciBpbXBsZW1lbnRhdGlvbnMgdG8gbG9vayBhdDpcblx0Ly8gKiBodHRwczovL2NvZGVzYW5kYm94LmlvL3MvbW5veDA1cXA4XG5cdGNvbnN0IGhvb2tzID1cblx0XHRjdXJyZW50Q29tcG9uZW50Ll9faG9va3MgfHxcblx0XHQoY3VycmVudENvbXBvbmVudC5fX2hvb2tzID0ge1xuXHRcdFx0X2xpc3Q6IFtdLFxuXHRcdFx0X3BlbmRpbmdFZmZlY3RzOiBbXVxuXHRcdH0pO1xuXG5cdGlmIChpbmRleCA+PSBob29rcy5fbGlzdC5sZW5ndGgpIHtcblx0XHRob29rcy5fbGlzdC5wdXNoKHsgX3BlbmRpbmdWYWx1ZTogRU1QVFkgfSk7XG5cdH1cblx0cmV0dXJuIGhvb2tzLl9saXN0W2luZGV4XTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbmRleCcpLlN0YXRlVXBkYXRlcjxhbnk+fSBbaW5pdGlhbFN0YXRlXVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG5cdGN1cnJlbnRIb29rID0gMTtcblx0cmV0dXJuIHVzZVJlZHVjZXIoaW52b2tlT3JSZXR1cm4sIGluaXRpYWxTdGF0ZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW5kZXgnKS5SZWR1Y2VyPGFueSwgYW55Pn0gcmVkdWNlclxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW5kZXgnKS5TdGF0ZVVwZGF0ZXI8YW55Pn0gaW5pdGlhbFN0YXRlXG4gKiBAcGFyYW0geyhpbml0aWFsU3RhdGU6IGFueSkgPT4gdm9pZH0gW2luaXRdXG4gKiBAcmV0dXJucyB7WyBhbnksIChzdGF0ZTogYW55KSA9PiB2b2lkIF19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxTdGF0ZSwgaW5pdCkge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlJlZHVjZXJIb29rU3RhdGV9ICovXG5cdGNvbnN0IGhvb2tTdGF0ZSA9IGdldEhvb2tTdGF0ZShjdXJyZW50SW5kZXgrKywgMik7XG5cdGhvb2tTdGF0ZS5fcmVkdWNlciA9IHJlZHVjZXI7XG5cdGlmICghaG9va1N0YXRlLl9jb21wb25lbnQpIHtcblx0XHRob29rU3RhdGUuX3ZhbHVlID0gW1xuXHRcdFx0IWluaXQgPyBpbnZva2VPclJldHVybih1bmRlZmluZWQsIGluaXRpYWxTdGF0ZSkgOiBpbml0KGluaXRpYWxTdGF0ZSksXG5cblx0XHRcdGFjdGlvbiA9PiB7XG5cdFx0XHRcdGNvbnN0IGN1cnJlbnRWYWx1ZSA9IGhvb2tTdGF0ZS5fbmV4dFZhbHVlXG5cdFx0XHRcdFx0PyBob29rU3RhdGUuX25leHRWYWx1ZVswXVxuXHRcdFx0XHRcdDogaG9va1N0YXRlLl92YWx1ZVswXTtcblx0XHRcdFx0Y29uc3QgbmV4dFZhbHVlID0gaG9va1N0YXRlLl9yZWR1Y2VyKGN1cnJlbnRWYWx1ZSwgYWN0aW9uKTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlICE9PSBuZXh0VmFsdWUpIHtcblx0XHRcdFx0XHRob29rU3RhdGUuX25leHRWYWx1ZSA9IFtuZXh0VmFsdWUsIGhvb2tTdGF0ZS5fdmFsdWVbMV1dO1xuXHRcdFx0XHRcdGhvb2tTdGF0ZS5fY29tcG9uZW50LnNldFN0YXRlKHt9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdF07XG5cblx0XHRob29rU3RhdGUuX2NvbXBvbmVudCA9IGN1cnJlbnRDb21wb25lbnQ7XG5cblx0XHRpZiAoIWN1cnJlbnRDb21wb25lbnQuX2hhc1NjdUZyb21Ib29rcykge1xuXHRcdFx0Y3VycmVudENvbXBvbmVudC5faGFzU2N1RnJvbUhvb2tzID0gdHJ1ZTtcblx0XHRcdGNvbnN0IHByZXZTY3UgPSBjdXJyZW50Q29tcG9uZW50LnNob3VsZENvbXBvbmVudFVwZGF0ZTtcblxuXHRcdFx0Ly8gVGhpcyBTQ1UgaGFzIHRoZSBwdXJwb3NlIG9mIGJhaWxpbmcgb3V0IGFmdGVyIHJlcGVhdGVkIHVwZGF0ZXNcblx0XHRcdC8vIHRvIHN0YXRlZnVsIGhvb2tzLlxuXHRcdFx0Ly8gd2Ugc3RvcmUgdGhlIG5leHQgdmFsdWUgaW4gX25leHRWYWx1ZVswXSBhbmQga2VlcCBkb2luZyB0aGF0IGZvciBhbGxcblx0XHRcdC8vIHN0YXRlIHNldHRlcnMsIGlmIHdlIGhhdmUgbmV4dCBzdGF0ZXMgYW5kXG5cdFx0XHQvLyBhbGwgbmV4dCBzdGF0ZXMgd2l0aGluIGEgY29tcG9uZW50IGVuZCB1cCBiZWluZyBlcXVhbCB0byB0aGVpciBvcmlnaW5hbCBzdGF0ZVxuXHRcdFx0Ly8gd2UgYXJlIHNhZmUgdG8gYmFpbCBvdXQgZm9yIHRoaXMgc3BlY2lmaWMgY29tcG9uZW50LlxuXHRcdFx0Y3VycmVudENvbXBvbmVudC5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbihwLCBzLCBjKSB7XG5cdFx0XHRcdGlmICghaG9va1N0YXRlLl9jb21wb25lbnQuX19ob29rcykgcmV0dXJuIHRydWU7XG5cblx0XHRcdFx0Y29uc3Qgc3RhdGVIb29rcyA9IGhvb2tTdGF0ZS5fY29tcG9uZW50Ll9faG9va3MuX2xpc3QuZmlsdGVyKFxuXHRcdFx0XHRcdHggPT4geC5fY29tcG9uZW50XG5cdFx0XHRcdCk7XG5cdFx0XHRcdGNvbnN0IGFsbEhvb2tzRW1wdHkgPSBzdGF0ZUhvb2tzLmV2ZXJ5KHggPT4gIXguX25leHRWYWx1ZSk7XG5cdFx0XHRcdC8vIFdoZW4gd2UgaGF2ZSBubyB1cGRhdGVkIGhvb2tzIGluIHRoZSBjb21wb25lbnQgd2UgaW52b2tlIHRoZSBwcmV2aW91cyBTQ1Ugb3Jcblx0XHRcdFx0Ly8gdHJhdmVyc2UgdGhlIFZET00gdHJlZSBmdXJ0aGVyLlxuXHRcdFx0XHRpZiAoYWxsSG9va3NFbXB0eSkge1xuXHRcdFx0XHRcdHJldHVybiBwcmV2U2N1ID8gcHJldlNjdS5jYWxsKHRoaXMsIHAsIHMsIGMpIDogdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFdlIGNoZWNrIHdoZXRoZXIgd2UgaGF2ZSBjb21wb25lbnRzIHdpdGggYSBuZXh0VmFsdWUgc2V0IHRoYXRcblx0XHRcdFx0Ly8gaGF2ZSB2YWx1ZXMgdGhhdCBhcmVuJ3QgZXF1YWwgdG8gb25lIGFub3RoZXIgdGhpcyBwdXNoZXNcblx0XHRcdFx0Ly8gdXMgdG8gdXBkYXRlIGZ1cnRoZXIgZG93biB0aGUgdHJlZVxuXHRcdFx0XHRsZXQgc2hvdWxkVXBkYXRlID0gZmFsc2U7XG5cdFx0XHRcdHN0YXRlSG9va3MuZm9yRWFjaChob29rSXRlbSA9PiB7XG5cdFx0XHRcdFx0aWYgKGhvb2tJdGVtLl9uZXh0VmFsdWUpIHtcblx0XHRcdFx0XHRcdGNvbnN0IGN1cnJlbnRWYWx1ZSA9IGhvb2tJdGVtLl92YWx1ZVswXTtcblx0XHRcdFx0XHRcdGhvb2tJdGVtLl92YWx1ZSA9IGhvb2tJdGVtLl9uZXh0VmFsdWU7XG5cdFx0XHRcdFx0XHRob29rSXRlbS5fbmV4dFZhbHVlID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSAhPT0gaG9va0l0ZW0uX3ZhbHVlWzBdKSBzaG91bGRVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0cmV0dXJuIHNob3VsZFVwZGF0ZSB8fCBob29rU3RhdGUuX2NvbXBvbmVudC5wcm9wcyAhPT0gcFxuXHRcdFx0XHRcdD8gcHJldlNjdVxuXHRcdFx0XHRcdFx0PyBwcmV2U2N1LmNhbGwodGhpcywgcCwgcywgYylcblx0XHRcdFx0XHRcdDogdHJ1ZVxuXHRcdFx0XHRcdDogZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBob29rU3RhdGUuX25leHRWYWx1ZSB8fCBob29rU3RhdGUuX3ZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuRWZmZWN0fSBjYWxsYmFja1xuICogQHBhcmFtIHthbnlbXX0gYXJnc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRWZmZWN0KGNhbGxiYWNrLCBhcmdzKSB7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuRWZmZWN0SG9va1N0YXRlfSAqL1xuXHRjb25zdCBzdGF0ZSA9IGdldEhvb2tTdGF0ZShjdXJyZW50SW5kZXgrKywgMyk7XG5cdGlmICghb3B0aW9ucy5fc2tpcEVmZmVjdHMgJiYgYXJnc0NoYW5nZWQoc3RhdGUuX2FyZ3MsIGFyZ3MpKSB7XG5cdFx0c3RhdGUuX3ZhbHVlID0gY2FsbGJhY2s7XG5cdFx0c3RhdGUuX3BlbmRpbmdBcmdzID0gYXJncztcblxuXHRcdGN1cnJlbnRDb21wb25lbnQuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMucHVzaChzdGF0ZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdH0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUxheW91dEVmZmVjdChjYWxsYmFjaywgYXJncykge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdEhvb2tTdGF0ZX0gKi9cblx0Y29uc3Qgc3RhdGUgPSBnZXRIb29rU3RhdGUoY3VycmVudEluZGV4KyssIDQpO1xuXHRpZiAoIW9wdGlvbnMuX3NraXBFZmZlY3RzICYmIGFyZ3NDaGFuZ2VkKHN0YXRlLl9hcmdzLCBhcmdzKSkge1xuXHRcdHN0YXRlLl92YWx1ZSA9IGNhbGxiYWNrO1xuXHRcdHN0YXRlLl9wZW5kaW5nQXJncyA9IGFyZ3M7XG5cblx0XHRjdXJyZW50Q29tcG9uZW50Ll9yZW5kZXJDYWxsYmFja3MucHVzaChzdGF0ZSk7XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVJlZihpbml0aWFsVmFsdWUpIHtcblx0Y3VycmVudEhvb2sgPSA1O1xuXHRyZXR1cm4gdXNlTWVtbygoKSA9PiAoeyBjdXJyZW50OiBpbml0aWFsVmFsdWUgfSksIFtdKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gcmVmXG4gKiBAcGFyYW0geygpID0+IG9iamVjdH0gY3JlYXRlSGFuZGxlXG4gKiBAcGFyYW0ge2FueVtdfSBhcmdzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlSGFuZGxlLCBhcmdzKSB7XG5cdGN1cnJlbnRIb29rID0gNjtcblx0dXNlTGF5b3V0RWZmZWN0KFxuXHRcdCgpID0+IHtcblx0XHRcdGlmICh0eXBlb2YgcmVmID09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0cmVmKGNyZWF0ZUhhbmRsZSgpKTtcblx0XHRcdFx0cmV0dXJuICgpID0+IHJlZihudWxsKTtcblx0XHRcdH0gZWxzZSBpZiAocmVmKSB7XG5cdFx0XHRcdHJlZi5jdXJyZW50ID0gY3JlYXRlSGFuZGxlKCk7XG5cdFx0XHRcdHJldHVybiAoKSA9PiAocmVmLmN1cnJlbnQgPSBudWxsKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGFyZ3MgPT0gbnVsbCA/IGFyZ3MgOiBhcmdzLmNvbmNhdChyZWYpXG5cdCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHsoKSA9PiBhbnl9IGZhY3RvcnlcbiAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lbW8oZmFjdG9yeSwgYXJncykge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLk1lbW9Ib29rU3RhdGV9ICovXG5cdGNvbnN0IHN0YXRlID0gZ2V0SG9va1N0YXRlKGN1cnJlbnRJbmRleCsrLCA3KTtcblx0aWYgKGFyZ3NDaGFuZ2VkKHN0YXRlLl9hcmdzLCBhcmdzKSkge1xuXHRcdHN0YXRlLl9wZW5kaW5nVmFsdWUgPSBmYWN0b3J5KCk7XG5cdFx0c3RhdGUuX3BlbmRpbmdBcmdzID0gYXJncztcblx0XHRzdGF0ZS5fZmFjdG9yeSA9IGZhY3Rvcnk7XG5cdFx0cmV0dXJuIHN0YXRlLl9wZW5kaW5nVmFsdWU7XG5cdH1cblxuXHRyZXR1cm4gc3RhdGUuX3ZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNhbGxiYWNrKGNhbGxiYWNrLCBhcmdzKSB7XG5cdGN1cnJlbnRIb29rID0gODtcblx0cmV0dXJuIHVzZU1lbW8oKCkgPT4gY2FsbGJhY2ssIGFyZ3MpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuUHJlYWN0Q29udGV4dH0gY29udGV4dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQ29udGV4dChjb250ZXh0KSB7XG5cdGNvbnN0IHByb3ZpZGVyID0gY3VycmVudENvbXBvbmVudC5jb250ZXh0W2NvbnRleHQuX2lkXTtcblx0Ly8gV2UgY291bGQgc2tpcCB0aGlzIGNhbGwgaGVyZSwgYnV0IHRoYW4gd2UnZCBub3QgY2FsbFxuXHQvLyBgb3B0aW9ucy5faG9va2AuIFdlIG5lZWQgdG8gZG8gdGhhdCBpbiBvcmRlciB0byBtYWtlXG5cdC8vIHRoZSBkZXZ0b29scyBhd2FyZSBvZiB0aGlzIGhvb2suXG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29udGV4dEhvb2tTdGF0ZX0gKi9cblx0Y29uc3Qgc3RhdGUgPSBnZXRIb29rU3RhdGUoY3VycmVudEluZGV4KyssIDkpO1xuXHQvLyBUaGUgZGV2dG9vbHMgbmVlZHMgYWNjZXNzIHRvIHRoZSBjb250ZXh0IG9iamVjdCB0b1xuXHQvLyBiZSBhYmxlIHRvIHB1bGwgb2YgdGhlIGRlZmF1bHQgdmFsdWUgd2hlbiBubyBwcm92aWRlclxuXHQvLyBpcyBwcmVzZW50IGluIHRoZSB0cmVlLlxuXHRzdGF0ZS5fY29udGV4dCA9IGNvbnRleHQ7XG5cdGlmICghcHJvdmlkZXIpIHJldHVybiBjb250ZXh0Ll9kZWZhdWx0VmFsdWU7XG5cdC8vIFRoaXMgaXMgcHJvYmFibHkgbm90IHNhZmUgdG8gY29udmVydCB0byBcIiFcIlxuXHRpZiAoc3RhdGUuX3ZhbHVlID09IG51bGwpIHtcblx0XHRzdGF0ZS5fdmFsdWUgPSB0cnVlO1xuXHRcdHByb3ZpZGVyLnN1YihjdXJyZW50Q29tcG9uZW50KTtcblx0fVxuXHRyZXR1cm4gcHJvdmlkZXIucHJvcHMudmFsdWU7XG59XG5cbi8qKlxuICogRGlzcGxheSBhIGN1c3RvbSBsYWJlbCBmb3IgYSBjdXN0b20gaG9vayBmb3IgdGhlIGRldnRvb2xzIHBhbmVsXG4gKiBAdHlwZSB7PFQ+KHZhbHVlOiBULCBjYj86ICh2YWx1ZTogVCkgPT4gc3RyaW5nIHwgbnVtYmVyKSA9PiB2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRGVidWdWYWx1ZSh2YWx1ZSwgZm9ybWF0dGVyKSB7XG5cdGlmIChvcHRpb25zLnVzZURlYnVnVmFsdWUpIHtcblx0XHRvcHRpb25zLnVzZURlYnVnVmFsdWUoZm9ybWF0dGVyID8gZm9ybWF0dGVyKHZhbHVlKSA6IHZhbHVlKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7KGVycm9yOiBhbnksIGVycm9ySW5mbzogaW1wb3J0KCdwcmVhY3QnKS5FcnJvckluZm8pID0+IHZvaWR9IGNiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VFcnJvckJvdW5kYXJ5KGNiKSB7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuRXJyb3JCb3VuZGFyeUhvb2tTdGF0ZX0gKi9cblx0Y29uc3Qgc3RhdGUgPSBnZXRIb29rU3RhdGUoY3VycmVudEluZGV4KyssIDEwKTtcblx0Y29uc3QgZXJyU3RhdGUgPSB1c2VTdGF0ZSgpO1xuXHRzdGF0ZS5fdmFsdWUgPSBjYjtcblx0aWYgKCFjdXJyZW50Q29tcG9uZW50LmNvbXBvbmVudERpZENhdGNoKSB7XG5cdFx0Y3VycmVudENvbXBvbmVudC5jb21wb25lbnREaWRDYXRjaCA9IChlcnIsIGVycm9ySW5mbykgPT4ge1xuXHRcdFx0aWYgKHN0YXRlLl92YWx1ZSkgc3RhdGUuX3ZhbHVlKGVyciwgZXJyb3JJbmZvKTtcblx0XHRcdGVyclN0YXRlWzFdKGVycik7XG5cdFx0fTtcblx0fVxuXHRyZXR1cm4gW1xuXHRcdGVyclN0YXRlWzBdLFxuXHRcdCgpID0+IHtcblx0XHRcdGVyclN0YXRlWzFdKHVuZGVmaW5lZCk7XG5cdFx0fVxuXHRdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlSWQoKSB7XG5cdGNvbnN0IHN0YXRlID0gZ2V0SG9va1N0YXRlKGN1cnJlbnRJbmRleCsrLCAxMSk7XG5cdGlmICghc3RhdGUuX3ZhbHVlKSB7XG5cdFx0Ly8gR3JhYiBlaXRoZXIgdGhlIHJvb3Qgbm9kZSBvciB0aGUgbmVhcmVzdCBhc3luYyBib3VuZGFyeSBub2RlLlxuXHRcdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsLmQnKS5WTm9kZX0gKi9cblx0XHRsZXQgcm9vdCA9IGN1cnJlbnRDb21wb25lbnQuX3Zub2RlO1xuXHRcdHdoaWxlIChyb290ICE9PSBudWxsICYmICFyb290Ll9tYXNrICYmIHJvb3QuX3BhcmVudCAhPT0gbnVsbCkge1xuXHRcdFx0cm9vdCA9IHJvb3QuX3BhcmVudDtcblx0XHR9XG5cblx0XHRsZXQgbWFzayA9IHJvb3QuX21hc2sgfHwgKHJvb3QuX21hc2sgPSBbMCwgMF0pO1xuXHRcdHN0YXRlLl92YWx1ZSA9ICdQJyArIG1hc2tbMF0gKyAnLScgKyBtYXNrWzFdKys7XG5cdH1cblxuXHRyZXR1cm4gc3RhdGUuX3ZhbHVlO1xufVxuLyoqXG4gKiBBZnRlciBwYWludCBlZmZlY3RzIGNvbnN1bWVyLlxuICovXG5mdW5jdGlvbiBmbHVzaEFmdGVyUGFpbnRFZmZlY3RzKCkge1xuXHRsZXQgY29tcG9uZW50O1xuXHR3aGlsZSAoKGNvbXBvbmVudCA9IGFmdGVyUGFpbnRFZmZlY3RzLnNoaWZ0KCkpKSB7XG5cdFx0aWYgKCFjb21wb25lbnQuX3BhcmVudERvbSB8fCAhY29tcG9uZW50Ll9faG9va3MpIGNvbnRpbnVlO1xuXHRcdHRyeSB7XG5cdFx0XHRjb21wb25lbnQuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMuZm9yRWFjaChpbnZva2VDbGVhbnVwKTtcblx0XHRcdGNvbXBvbmVudC5fX2hvb2tzLl9wZW5kaW5nRWZmZWN0cy5mb3JFYWNoKGludm9rZUVmZmVjdCk7XG5cdFx0XHRjb21wb25lbnQuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMgPSBbXTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRjb21wb25lbnQuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMgPSBbXTtcblx0XHRcdG9wdGlvbnMuX2NhdGNoRXJyb3IoZSwgY29tcG9uZW50Ll92bm9kZSk7XG5cdFx0fVxuXHR9XG59XG5cbmxldCBIQVNfUkFGID0gdHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9PSAnZnVuY3Rpb24nO1xuXG4vKipcbiAqIFNjaGVkdWxlIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCBhZnRlciB0aGUgYnJvd3NlciBoYXMgYSBjaGFuY2UgdG8gcGFpbnQgYSBuZXcgZnJhbWUuXG4gKiBEbyB0aGlzIGJ5IGNvbWJpbmluZyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKHJBRikgKyBzZXRUaW1lb3V0IHRvIGludm9rZSBhIGNhbGxiYWNrIGFmdGVyXG4gKiB0aGUgbmV4dCBicm93c2VyIGZyYW1lLlxuICpcbiAqIEFsc28sIHNjaGVkdWxlIGEgdGltZW91dCBpbiBwYXJhbGxlbCB0byB0aGUgdGhlIHJBRiB0byBlbnN1cmUgdGhlIGNhbGxiYWNrIGlzIGludm9rZWRcbiAqIGV2ZW4gaWYgUkFGIGRvZXNuJ3QgZmlyZSAoZm9yIGV4YW1wbGUgaWYgdGhlIGJyb3dzZXIgdGFiIGlzIG5vdCB2aXNpYmxlKVxuICpcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gY2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gYWZ0ZXJOZXh0RnJhbWUoY2FsbGJhY2spIHtcblx0Y29uc3QgZG9uZSA9ICgpID0+IHtcblx0XHRjbGVhclRpbWVvdXQodGltZW91dCk7XG5cdFx0aWYgKEhBU19SQUYpIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZik7XG5cdFx0c2V0VGltZW91dChjYWxsYmFjayk7XG5cdH07XG5cdGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KGRvbmUsIFJBRl9USU1FT1VUKTtcblxuXHRsZXQgcmFmO1xuXHRpZiAoSEFTX1JBRikge1xuXHRcdHJhZiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShkb25lKTtcblx0fVxufVxuXG4vLyBOb3RlOiBpZiBzb21lb25lIHVzZWQgb3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSxcbi8vIHRoZW4gZWZmZWN0cyB3aWxsIEFMV0FZUyBydW4gb24gdGhlIE5FWFQgZnJhbWUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBvbmUsIGluY3VycmluZyBhIH4xNm1zIGRlbGF5LlxuLy8gUGVyaGFwcyB0aGlzIGlzIG5vdCBzdWNoIGEgYmlnIGRlYWwuXG4vKipcbiAqIFNjaGVkdWxlIGFmdGVyUGFpbnRFZmZlY3RzIGZsdXNoIGFmdGVyIHRoZSBicm93c2VyIHBhaW50c1xuICogQHBhcmFtIHtudW1iZXJ9IG5ld1F1ZXVlTGVuZ3RoXG4gKi9cbmZ1bmN0aW9uIGFmdGVyUGFpbnQobmV3UXVldWVMZW5ndGgpIHtcblx0aWYgKG5ld1F1ZXVlTGVuZ3RoID09PSAxIHx8IHByZXZSYWYgIT09IG9wdGlvbnMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG5cdFx0cHJldlJhZiA9IG9wdGlvbnMucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuXHRcdChwcmV2UmFmIHx8IGFmdGVyTmV4dEZyYW1lKShmbHVzaEFmdGVyUGFpbnRFZmZlY3RzKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuRWZmZWN0SG9va1N0YXRlfSBob29rXG4gKi9cbmZ1bmN0aW9uIGludm9rZUNsZWFudXAoaG9vaykge1xuXHQvLyBBIGhvb2sgY2xlYW51cCBjYW4gaW50cm9kdWNlIGEgY2FsbCB0byByZW5kZXIgd2hpY2ggY3JlYXRlcyBhIG5ldyByb290LCB0aGlzIHdpbGwgY2FsbCBvcHRpb25zLnZub2RlXG5cdC8vIGFuZCBtb3ZlIHRoZSBjdXJyZW50Q29tcG9uZW50IGF3YXkuXG5cdGNvbnN0IGNvbXAgPSBjdXJyZW50Q29tcG9uZW50O1xuXHRsZXQgY2xlYW51cCA9IGhvb2suX2NsZWFudXA7XG5cdGlmICh0eXBlb2YgY2xlYW51cCA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0aG9vay5fY2xlYW51cCA9IHVuZGVmaW5lZDtcblx0XHRjbGVhbnVwKCk7XG5cdH1cblxuXHRjdXJyZW50Q29tcG9uZW50ID0gY29tcDtcbn1cblxuLyoqXG4gKiBJbnZva2UgYSBIb29rJ3MgZWZmZWN0XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdEhvb2tTdGF0ZX0gaG9va1xuICovXG5mdW5jdGlvbiBpbnZva2VFZmZlY3QoaG9vaykge1xuXHQvLyBBIGhvb2sgY2FsbCBjYW4gaW50cm9kdWNlIGEgY2FsbCB0byByZW5kZXIgd2hpY2ggY3JlYXRlcyBhIG5ldyByb290LCB0aGlzIHdpbGwgY2FsbCBvcHRpb25zLnZub2RlXG5cdC8vIGFuZCBtb3ZlIHRoZSBjdXJyZW50Q29tcG9uZW50IGF3YXkuXG5cdGNvbnN0IGNvbXAgPSBjdXJyZW50Q29tcG9uZW50O1xuXHRob29rLl9jbGVhbnVwID0gaG9vay5fdmFsdWUoKTtcblx0Y3VycmVudENvbXBvbmVudCA9IGNvbXA7XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnlbXX0gb2xkQXJnc1xuICogQHBhcmFtIHthbnlbXX0gbmV3QXJnc1xuICovXG5mdW5jdGlvbiBhcmdzQ2hhbmdlZChvbGRBcmdzLCBuZXdBcmdzKSB7XG5cdHJldHVybiAoXG5cdFx0IW9sZEFyZ3MgfHxcblx0XHRvbGRBcmdzLmxlbmd0aCAhPT0gbmV3QXJncy5sZW5ndGggfHxcblx0XHRuZXdBcmdzLnNvbWUoKGFyZywgaW5kZXgpID0+IGFyZyAhPT0gb2xkQXJnc1tpbmRleF0pXG5cdCk7XG59XG5cbmZ1bmN0aW9uIGludm9rZU9yUmV0dXJuKGFyZywgZikge1xuXHRyZXR1cm4gdHlwZW9mIGYgPT0gJ2Z1bmN0aW9uJyA/IGYoYXJnKSA6IGY7XG59XG4iLCAiLyoqXG4gKiBBc3NpZ24gcHJvcGVydGllcyBmcm9tIGBwcm9wc2AgdG8gYG9iamBcbiAqIEB0ZW1wbGF0ZSBPLCBQIFRoZSBvYmogYW5kIHByb3BzIHR5cGVzXG4gKiBAcGFyYW0ge099IG9iaiBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0b1xuICogQHBhcmFtIHtQfSBwcm9wcyBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBAcmV0dXJucyB7TyAmIFB9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ24ob2JqLCBwcm9wcykge1xuXHRmb3IgKGxldCBpIGluIHByb3BzKSBvYmpbaV0gPSBwcm9wc1tpXTtcblx0cmV0dXJuIC8qKiBAdHlwZSB7TyAmIFB9ICovIChvYmopO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHR3byBvYmplY3RzIGhhdmUgYSBkaWZmZXJlbnQgc2hhcGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBhXG4gKiBAcGFyYW0ge29iamVjdH0gYlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaGFsbG93RGlmZmVycyhhLCBiKSB7XG5cdGZvciAobGV0IGkgaW4gYSkgaWYgKGkgIT09ICdfX3NvdXJjZScgJiYgIShpIGluIGIpKSByZXR1cm4gdHJ1ZTtcblx0Zm9yIChsZXQgaSBpbiBiKSBpZiAoaSAhPT0gJ19fc291cmNlJyAmJiBhW2ldICE9PSBiW2ldKSByZXR1cm4gdHJ1ZTtcblx0cmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlTm9kZShub2RlKSB7XG5cdGxldCBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuXHRpZiAocGFyZW50Tm9kZSkgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSB0aGUgc2FtZSB2YWx1ZVxuICogQHBhcmFtIHsqfSB4XG4gKiBAcGFyYW0geyp9IHlcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXMoeCwgeSkge1xuXHRyZXR1cm4gKHggPT09IHkgJiYgKHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5KSkgfHwgKHggIT09IHggJiYgeSAhPT0geSk7XG59XG4iLCAiaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCB7IHNoYWxsb3dEaWZmZXJzIH0gZnJvbSAnLi91dGlsJztcblxuLyoqXG4gKiBDb21wb25lbnQgY2xhc3Mgd2l0aCBhIHByZWRlZmluZWQgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAgaW1wbGVtZW50YXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFB1cmVDb21wb25lbnQocCkge1xuXHR0aGlzLnByb3BzID0gcDtcbn1cblB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudCgpO1xuLy8gU29tZSB0aGlyZC1wYXJ0eSBsaWJyYXJpZXMgY2hlY2sgaWYgdGhpcyBwcm9wZXJ0eSBpcyBwcmVzZW50XG5QdXJlQ29tcG9uZW50LnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCA9IHRydWU7XG5QdXJlQ29tcG9uZW50LnByb3RvdHlwZS5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbihwcm9wcywgc3RhdGUpIHtcblx0cmV0dXJuIHNoYWxsb3dEaWZmZXJzKHRoaXMucHJvcHMsIHByb3BzKSB8fCBzaGFsbG93RGlmZmVycyh0aGlzLnN0YXRlLCBzdGF0ZSk7XG59O1xuIiwgImltcG9ydCB7IGNyZWF0ZUVsZW1lbnQgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgc2hhbGxvd0RpZmZlcnMgfSBmcm9tICcuL3V0aWwnO1xuXG4vKipcbiAqIE1lbW9pemUgYSBjb21wb25lbnQsIHNvIHRoYXQgaXQgb25seSB1cGRhdGVzIHdoZW4gdGhlIHByb3BzIGFjdHVhbGx5IGhhdmVcbiAqIGNoYW5nZWQuIFRoaXMgd2FzIHByZXZpb3VzbHkga25vd24gYXMgYFJlYWN0LnB1cmVgLlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5GdW5jdGlvbkNvbXBvbmVudH0gYyBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICogQHBhcmFtIHsocHJldjogb2JqZWN0LCBuZXh0OiBvYmplY3QpID0+IGJvb2xlYW59IFtjb21wYXJlcl0gQ3VzdG9tIGVxdWFsaXR5IGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL2ludGVybmFsJykuRnVuY3Rpb25Db21wb25lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZW1vKGMsIGNvbXBhcmVyKSB7XG5cdGZ1bmN0aW9uIHNob3VsZFVwZGF0ZShuZXh0UHJvcHMpIHtcblx0XHRsZXQgcmVmID0gdGhpcy5wcm9wcy5yZWY7XG5cdFx0bGV0IHVwZGF0ZVJlZiA9IHJlZiA9PSBuZXh0UHJvcHMucmVmO1xuXHRcdGlmICghdXBkYXRlUmVmICYmIHJlZikge1xuXHRcdFx0cmVmLmNhbGwgPyByZWYobnVsbCkgOiAocmVmLmN1cnJlbnQgPSBudWxsKTtcblx0XHR9XG5cblx0XHRpZiAoIWNvbXBhcmVyKSB7XG5cdFx0XHRyZXR1cm4gc2hhbGxvd0RpZmZlcnModGhpcy5wcm9wcywgbmV4dFByb3BzKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gIWNvbXBhcmVyKHRoaXMucHJvcHMsIG5leHRQcm9wcykgfHwgIXVwZGF0ZVJlZjtcblx0fVxuXG5cdGZ1bmN0aW9uIE1lbW9lZChwcm9wcykge1xuXHRcdHRoaXMuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gc2hvdWxkVXBkYXRlO1xuXHRcdHJldHVybiBjcmVhdGVFbGVtZW50KGMsIHByb3BzKTtcblx0fVxuXHRNZW1vZWQuZGlzcGxheU5hbWUgPSAnTWVtbygnICsgKGMuZGlzcGxheU5hbWUgfHwgYy5uYW1lKSArICcpJztcblx0TWVtb2VkLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0gdHJ1ZTtcblx0TWVtb2VkLl9mb3J3YXJkZWQgPSB0cnVlO1xuXHRyZXR1cm4gTWVtb2VkO1xufVxuIiwgImltcG9ydCB7IG9wdGlvbnMgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgYXNzaWduIH0gZnJvbSAnLi91dGlsJztcblxubGV0IG9sZERpZmZIb29rID0gb3B0aW9ucy5fZGlmZjtcbm9wdGlvbnMuX2RpZmYgPSB2bm9kZSA9PiB7XG5cdGlmICh2bm9kZS50eXBlICYmIHZub2RlLnR5cGUuX2ZvcndhcmRlZCAmJiB2bm9kZS5yZWYpIHtcblx0XHR2bm9kZS5wcm9wcy5yZWYgPSB2bm9kZS5yZWY7XG5cdFx0dm5vZGUucmVmID0gbnVsbDtcblx0fVxuXHRpZiAob2xkRGlmZkhvb2spIG9sZERpZmZIb29rKHZub2RlKTtcbn07XG5cbmV4cG9ydCBjb25zdCBSRUFDVF9GT1JXQVJEX1NZTUJPTCA9XG5cdCh0eXBlb2YgU3ltYm9sICE9ICd1bmRlZmluZWQnICYmXG5cdFx0U3ltYm9sLmZvciAmJlxuXHRcdFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJykpIHx8XG5cdDB4ZjQ3O1xuXG4vKipcbiAqIFBhc3MgcmVmIGRvd24gdG8gYSBjaGlsZC4gVGhpcyBpcyBtYWlubHkgdXNlZCBpbiBsaWJyYXJpZXMgd2l0aCBIT0NzIHRoYXRcbiAqIHdyYXAgY29tcG9uZW50cy4gVXNpbmcgYGZvcndhcmRSZWZgIHRoZXJlIGlzIGFuIGVhc3kgd2F5IHRvIGdldCBhIHJlZmVyZW5jZVxuICogb2YgdGhlIHdyYXBwZWQgY29tcG9uZW50IGluc3RlYWQgb2Ygb25lIG9mIHRoZSB3cmFwcGVyIGl0c2VsZi5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2luZGV4JykuRm9yd2FyZEZufSBmblxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkZ1bmN0aW9uQ29tcG9uZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZFJlZihmbikge1xuXHRmdW5jdGlvbiBGb3J3YXJkZWQocHJvcHMpIHtcblx0XHRsZXQgY2xvbmUgPSBhc3NpZ24oe30sIHByb3BzKTtcblx0XHRkZWxldGUgY2xvbmUucmVmO1xuXHRcdHJldHVybiBmbihjbG9uZSwgcHJvcHMucmVmIHx8IG51bGwpO1xuXHR9XG5cblx0Ly8gbW9ieC1yZWFjdCBjaGVja3MgZm9yIHRoaXMgYmVpbmcgcHJlc2VudFxuXHRGb3J3YXJkZWQuJCR0eXBlb2YgPSBSRUFDVF9GT1JXQVJEX1NZTUJPTDtcblx0Ly8gbW9ieC1yZWFjdCBoZWF2aWx5IHJlbGllcyBvbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzLlxuXHQvLyBJdCBleHBlY3RzIGFuIG9iamVjdCBoZXJlIHdpdGggYSBgcmVuZGVyYCBwcm9wZXJ0eSxcblx0Ly8gYW5kIHByb3RvdHlwZS5yZW5kZXIgd2lsbCBmYWlsLiBXaXRob3V0IHRoaXNcblx0Ly8gbW9ieC1yZWFjdCB0aHJvd3MuXG5cdEZvcndhcmRlZC5yZW5kZXIgPSBGb3J3YXJkZWQ7XG5cblx0Rm9yd2FyZGVkLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0gRm9yd2FyZGVkLl9mb3J3YXJkZWQgPSB0cnVlO1xuXHRGb3J3YXJkZWQuZGlzcGxheU5hbWUgPSAnRm9yd2FyZFJlZignICsgKGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUpICsgJyknO1xuXHRyZXR1cm4gRm9yd2FyZGVkO1xufVxuIiwgImltcG9ydCB7IHRvQ2hpbGRBcnJheSB9IGZyb20gJ3ByZWFjdCc7XG5cbmNvbnN0IG1hcEZuID0gKGNoaWxkcmVuLCBmbikgPT4ge1xuXHRpZiAoY2hpbGRyZW4gPT0gbnVsbCkgcmV0dXJuIG51bGw7XG5cdHJldHVybiB0b0NoaWxkQXJyYXkodG9DaGlsZEFycmF5KGNoaWxkcmVuKS5tYXAoZm4pKTtcbn07XG5cbi8vIFRoaXMgQVBJIGlzIGNvbXBsZXRlbHkgdW5uZWNlc3NhcnkgZm9yIFByZWFjdCwgc28gaXQncyBiYXNpY2FsbHkgcGFzc3Rocm91Z2guXG5leHBvcnQgY29uc3QgQ2hpbGRyZW4gPSB7XG5cdG1hcDogbWFwRm4sXG5cdGZvckVhY2g6IG1hcEZuLFxuXHRjb3VudChjaGlsZHJlbikge1xuXHRcdHJldHVybiBjaGlsZHJlbiA/IHRvQ2hpbGRBcnJheShjaGlsZHJlbikubGVuZ3RoIDogMDtcblx0fSxcblx0b25seShjaGlsZHJlbikge1xuXHRcdGNvbnN0IG5vcm1hbGl6ZWQgPSB0b0NoaWxkQXJyYXkoY2hpbGRyZW4pO1xuXHRcdGlmIChub3JtYWxpemVkLmxlbmd0aCAhPT0gMSkgdGhyb3cgJ0NoaWxkcmVuLm9ubHknO1xuXHRcdHJldHVybiBub3JtYWxpemVkWzBdO1xuXHR9LFxuXHR0b0FycmF5OiB0b0NoaWxkQXJyYXlcbn07XG4iLCAiaW1wb3J0IHsgQ29tcG9uZW50LCBjcmVhdGVFbGVtZW50LCBvcHRpb25zLCBGcmFnbWVudCB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgeyBhc3NpZ24gfSBmcm9tICcuL3V0aWwnO1xuXG5jb25zdCBvbGRDYXRjaEVycm9yID0gb3B0aW9ucy5fY2F0Y2hFcnJvcjtcbm9wdGlvbnMuX2NhdGNoRXJyb3IgPSBmdW5jdGlvbihlcnJvciwgbmV3Vk5vZGUsIG9sZFZOb2RlLCBlcnJvckluZm8pIHtcblx0aWYgKGVycm9yLnRoZW4pIHtcblx0XHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gKi9cblx0XHRsZXQgY29tcG9uZW50O1xuXHRcdGxldCB2bm9kZSA9IG5ld1ZOb2RlO1xuXG5cdFx0Zm9yICg7ICh2bm9kZSA9IHZub2RlLl9wYXJlbnQpOyApIHtcblx0XHRcdGlmICgoY29tcG9uZW50ID0gdm5vZGUuX2NvbXBvbmVudCkgJiYgY29tcG9uZW50Ll9jaGlsZERpZFN1c3BlbmQpIHtcblx0XHRcdFx0aWYgKG5ld1ZOb2RlLl9kb20gPT0gbnVsbCkge1xuXHRcdFx0XHRcdG5ld1ZOb2RlLl9kb20gPSBvbGRWTm9kZS5fZG9tO1xuXHRcdFx0XHRcdG5ld1ZOb2RlLl9jaGlsZHJlbiA9IG9sZFZOb2RlLl9jaGlsZHJlbjtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBEb24ndCBjYWxsIG9sZENhdGNoRXJyb3IgaWYgd2UgZm91bmQgYSBTdXNwZW5zZVxuXHRcdFx0XHRyZXR1cm4gY29tcG9uZW50Ll9jaGlsZERpZFN1c3BlbmQoZXJyb3IsIG5ld1ZOb2RlKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0b2xkQ2F0Y2hFcnJvcihlcnJvciwgbmV3Vk5vZGUsIG9sZFZOb2RlLCBlcnJvckluZm8pO1xufTtcblxuY29uc3Qgb2xkVW5tb3VudCA9IG9wdGlvbnMudW5tb3VudDtcbm9wdGlvbnMudW5tb3VudCA9IGZ1bmN0aW9uKHZub2RlKSB7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSAqL1xuXHRjb25zdCBjb21wb25lbnQgPSB2bm9kZS5fY29tcG9uZW50O1xuXHRpZiAoY29tcG9uZW50ICYmIGNvbXBvbmVudC5fb25SZXNvbHZlKSB7XG5cdFx0Y29tcG9uZW50Ll9vblJlc29sdmUoKTtcblx0fVxuXG5cdC8vIGlmIHRoZSBjb21wb25lbnQgaXMgc3RpbGwgaHlkcmF0aW5nXG5cdC8vIG1vc3QgbGlrZWx5IGl0IGlzIGJlY2F1c2UgdGhlIGNvbXBvbmVudCBpcyBzdXNwZW5kZWRcblx0Ly8gd2Ugc2V0IHRoZSB2bm9kZS50eXBlIGFzIGBudWxsYCBzbyB0aGF0IGl0IGlzIG5vdCBhIHR5cGVvZiBmdW5jdGlvblxuXHQvLyBzbyB0aGUgdW5tb3VudCB3aWxsIHJlbW92ZSB0aGUgdm5vZGUuX2RvbVxuXHRpZiAoY29tcG9uZW50ICYmIHZub2RlLl9oeWRyYXRpbmcgPT09IHRydWUpIHtcblx0XHR2bm9kZS50eXBlID0gbnVsbDtcblx0fVxuXG5cdGlmIChvbGRVbm1vdW50KSBvbGRVbm1vdW50KHZub2RlKTtcbn07XG5cbmZ1bmN0aW9uIGRldGFjaGVkQ2xvbmUodm5vZGUsIGRldGFjaGVkUGFyZW50LCBwYXJlbnREb20pIHtcblx0aWYgKHZub2RlKSB7XG5cdFx0aWYgKHZub2RlLl9jb21wb25lbnQgJiYgdm5vZGUuX2NvbXBvbmVudC5fX2hvb2tzKSB7XG5cdFx0XHR2bm9kZS5fY29tcG9uZW50Ll9faG9va3MuX2xpc3QuZm9yRWFjaChlZmZlY3QgPT4ge1xuXHRcdFx0XHRpZiAodHlwZW9mIGVmZmVjdC5fY2xlYW51cCA9PSAnZnVuY3Rpb24nKSBlZmZlY3QuX2NsZWFudXAoKTtcblx0XHRcdH0pO1xuXG5cdFx0XHR2bm9kZS5fY29tcG9uZW50Ll9faG9va3MgPSBudWxsO1xuXHRcdH1cblxuXHRcdHZub2RlID0gYXNzaWduKHt9LCB2bm9kZSk7XG5cdFx0aWYgKHZub2RlLl9jb21wb25lbnQgIT0gbnVsbCkge1xuXHRcdFx0aWYgKHZub2RlLl9jb21wb25lbnQuX3BhcmVudERvbSA9PT0gcGFyZW50RG9tKSB7XG5cdFx0XHRcdHZub2RlLl9jb21wb25lbnQuX3BhcmVudERvbSA9IGRldGFjaGVkUGFyZW50O1xuXHRcdFx0fVxuXHRcdFx0dm5vZGUuX2NvbXBvbmVudCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0dm5vZGUuX2NoaWxkcmVuID1cblx0XHRcdHZub2RlLl9jaGlsZHJlbiAmJlxuXHRcdFx0dm5vZGUuX2NoaWxkcmVuLm1hcChjaGlsZCA9PlxuXHRcdFx0XHRkZXRhY2hlZENsb25lKGNoaWxkLCBkZXRhY2hlZFBhcmVudCwgcGFyZW50RG9tKVxuXHRcdFx0KTtcblx0fVxuXG5cdHJldHVybiB2bm9kZTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlT3JpZ2luYWwodm5vZGUsIGRldGFjaGVkUGFyZW50LCBvcmlnaW5hbFBhcmVudCkge1xuXHRpZiAodm5vZGUpIHtcblx0XHR2bm9kZS5fb3JpZ2luYWwgPSBudWxsO1xuXHRcdHZub2RlLl9jaGlsZHJlbiA9XG5cdFx0XHR2bm9kZS5fY2hpbGRyZW4gJiZcblx0XHRcdHZub2RlLl9jaGlsZHJlbi5tYXAoY2hpbGQgPT5cblx0XHRcdFx0cmVtb3ZlT3JpZ2luYWwoY2hpbGQsIGRldGFjaGVkUGFyZW50LCBvcmlnaW5hbFBhcmVudClcblx0XHRcdCk7XG5cblx0XHRpZiAodm5vZGUuX2NvbXBvbmVudCkge1xuXHRcdFx0aWYgKHZub2RlLl9jb21wb25lbnQuX3BhcmVudERvbSA9PT0gZGV0YWNoZWRQYXJlbnQpIHtcblx0XHRcdFx0aWYgKHZub2RlLl9kb20pIHtcblx0XHRcdFx0XHRvcmlnaW5hbFBhcmVudC5pbnNlcnRCZWZvcmUodm5vZGUuX2RvbSwgdm5vZGUuX25leHREb20pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZub2RlLl9jb21wb25lbnQuX2ZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0dm5vZGUuX2NvbXBvbmVudC5fcGFyZW50RG9tID0gb3JpZ2luYWxQYXJlbnQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHZub2RlO1xufVxuXG4vLyBoYXZpbmcgY3VzdG9tIGluaGVyaXRhbmNlIGluc3RlYWQgb2YgYSBjbGFzcyBoZXJlIHNhdmVzIGEgbG90IG9mIGJ5dGVzXG5leHBvcnQgZnVuY3Rpb24gU3VzcGVuc2UoKSB7XG5cdC8vIHdlIGRvIG5vdCBjYWxsIHN1cGVyIGhlcmUgdG8gZ29sZiBzb21lIGJ5dGVzLi4uXG5cdHRoaXMuX3BlbmRpbmdTdXNwZW5zaW9uQ291bnQgPSAwO1xuXHR0aGlzLl9zdXNwZW5kZXJzID0gbnVsbDtcblx0dGhpcy5fZGV0YWNoT25OZXh0UmVuZGVyID0gbnVsbDtcbn1cblxuLy8gVGhpbmdzIHdlIGRvIGhlcmUgdG8gc2F2ZSBzb21lIGJ5dGVzIGJ1dCBhcmUgbm90IHByb3BlciBKUyBpbmhlcml0YW5jZTpcbi8vIC0gY2FsbCBgbmV3IENvbXBvbmVudCgpYCBhcyB0aGUgcHJvdG90eXBlXG4vLyAtIGRvIG5vdCBzZXQgYFN1c3BlbnNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvcmAgdG8gYFN1c3BlbnNlYFxuU3VzcGVuc2UucHJvdG90eXBlID0gbmV3IENvbXBvbmVudCgpO1xuXG4vKipcbiAqIEB0aGlzIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5TdXNwZW5zZUNvbXBvbmVudH1cbiAqIEBwYXJhbSB7UHJvbWlzZX0gcHJvbWlzZSBUaGUgdGhyb3duIHByb21pc2VcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGU8YW55LCBhbnk+fSBzdXNwZW5kaW5nVk5vZGUgVGhlIHN1c3BlbmRpbmcgY29tcG9uZW50XG4gKi9cblN1c3BlbnNlLnByb3RvdHlwZS5fY2hpbGREaWRTdXNwZW5kID0gZnVuY3Rpb24ocHJvbWlzZSwgc3VzcGVuZGluZ1ZOb2RlKSB7XG5cdGNvbnN0IHN1c3BlbmRpbmdDb21wb25lbnQgPSBzdXNwZW5kaW5nVk5vZGUuX2NvbXBvbmVudDtcblxuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlN1c3BlbnNlQ29tcG9uZW50fSAqL1xuXHRjb25zdCBjID0gdGhpcztcblxuXHRpZiAoYy5fc3VzcGVuZGVycyA9PSBudWxsKSB7XG5cdFx0Yy5fc3VzcGVuZGVycyA9IFtdO1xuXHR9XG5cdGMuX3N1c3BlbmRlcnMucHVzaChzdXNwZW5kaW5nQ29tcG9uZW50KTtcblxuXHRjb25zdCByZXNvbHZlID0gc3VzcGVuZGVkKGMuX3Zub2RlKTtcblxuXHRsZXQgcmVzb2x2ZWQgPSBmYWxzZTtcblx0Y29uc3Qgb25SZXNvbHZlZCA9ICgpID0+IHtcblx0XHRpZiAocmVzb2x2ZWQpIHJldHVybjtcblxuXHRcdHJlc29sdmVkID0gdHJ1ZTtcblx0XHRzdXNwZW5kaW5nQ29tcG9uZW50Ll9vblJlc29sdmUgPSBudWxsO1xuXG5cdFx0aWYgKHJlc29sdmUpIHtcblx0XHRcdHJlc29sdmUob25TdXNwZW5zaW9uQ29tcGxldGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRvblN1c3BlbnNpb25Db21wbGV0ZSgpO1xuXHRcdH1cblx0fTtcblxuXHRzdXNwZW5kaW5nQ29tcG9uZW50Ll9vblJlc29sdmUgPSBvblJlc29sdmVkO1xuXG5cdGNvbnN0IG9uU3VzcGVuc2lvbkNvbXBsZXRlID0gKCkgPT4ge1xuXHRcdGlmICghLS1jLl9wZW5kaW5nU3VzcGVuc2lvbkNvdW50KSB7XG5cdFx0XHQvLyBJZiB0aGUgc3VzcGVuc2lvbiB3YXMgZHVyaW5nIGh5ZHJhdGlvbiB3ZSBkb24ndCBuZWVkIHRvIHJlc3RvcmUgdGhlXG5cdFx0XHQvLyBzdXNwZW5kZWQgY2hpbGRyZW4gaW50byB0aGUgX2NoaWxkcmVuIGFycmF5XG5cdFx0XHRpZiAoYy5zdGF0ZS5fc3VzcGVuZGVkKSB7XG5cdFx0XHRcdGNvbnN0IHN1c3BlbmRlZFZOb2RlID0gYy5zdGF0ZS5fc3VzcGVuZGVkO1xuXHRcdFx0XHRjLl92bm9kZS5fY2hpbGRyZW5bMF0gPSByZW1vdmVPcmlnaW5hbChcblx0XHRcdFx0XHRzdXNwZW5kZWRWTm9kZSxcblx0XHRcdFx0XHRzdXNwZW5kZWRWTm9kZS5fY29tcG9uZW50Ll9wYXJlbnREb20sXG5cdFx0XHRcdFx0c3VzcGVuZGVkVk5vZGUuX2NvbXBvbmVudC5fb3JpZ2luYWxQYXJlbnREb21cblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Yy5zZXRTdGF0ZSh7IF9zdXNwZW5kZWQ6IChjLl9kZXRhY2hPbk5leHRSZW5kZXIgPSBudWxsKSB9KTtcblxuXHRcdFx0bGV0IHN1c3BlbmRlZDtcblx0XHRcdHdoaWxlICgoc3VzcGVuZGVkID0gYy5fc3VzcGVuZGVycy5wb3AoKSkpIHtcblx0XHRcdFx0c3VzcGVuZGVkLmZvcmNlVXBkYXRlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBXZSBkbyBub3Qgc2V0IGBzdXNwZW5kZWQ6IHRydWVgIGR1cmluZyBoeWRyYXRpb24gYmVjYXVzZSB3ZSB3YW50IHRoZSBhY3R1YWwgbWFya3VwXG5cdCAqIHRvIHJlbWFpbiBvbiBzY3JlZW4gYW5kIGh5ZHJhdGUgaXQgd2hlbiB0aGUgc3VzcGVuc2UgYWN0dWFsbHkgZ2V0cyByZXNvbHZlZC5cblx0ICogV2hpbGUgaW4gbm9uLWh5ZHJhdGlvbiBjYXNlcyB0aGUgdXN1YWwgZmFsbGJhY2sgLT4gY29tcG9uZW50IGZsb3cgd291bGQgb2Njb3VyLlxuXHQgKi9cblx0Y29uc3Qgd2FzSHlkcmF0aW5nID0gc3VzcGVuZGluZ1ZOb2RlLl9oeWRyYXRpbmcgPT09IHRydWU7XG5cdGlmICghYy5fcGVuZGluZ1N1c3BlbnNpb25Db3VudCsrICYmICF3YXNIeWRyYXRpbmcpIHtcblx0XHRjLnNldFN0YXRlKHsgX3N1c3BlbmRlZDogKGMuX2RldGFjaE9uTmV4dFJlbmRlciA9IGMuX3Zub2RlLl9jaGlsZHJlblswXSkgfSk7XG5cdH1cblx0cHJvbWlzZS50aGVuKG9uUmVzb2x2ZWQsIG9uUmVzb2x2ZWQpO1xufTtcblxuU3VzcGVuc2UucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMuX3N1c3BlbmRlcnMgPSBbXTtcbn07XG5cbi8qKlxuICogQHRoaXMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlN1c3BlbnNlQ29tcG9uZW50fVxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5TdXNwZW5zZUNvbXBvbmVudFtcInByb3BzXCJdfSBwcm9wc1xuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5TdXNwZW5zZVN0YXRlfSBzdGF0ZVxuICovXG5TdXNwZW5zZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24ocHJvcHMsIHN0YXRlKSB7XG5cdGlmICh0aGlzLl9kZXRhY2hPbk5leHRSZW5kZXIpIHtcblx0XHQvLyBXaGVuIHRoZSBTdXNwZW5zZSdzIF92bm9kZSB3YXMgY3JlYXRlZCBieSBhIGNhbGwgdG8gY3JlYXRlVk5vZGVcblx0XHQvLyAoaS5lLiBkdWUgdG8gYSBzZXRTdGF0ZSBmdXJ0aGVyIHVwIGluIHRoZSB0cmVlKVxuXHRcdC8vIGl0J3MgX2NoaWxkcmVuIHByb3AgaXMgbnVsbCwgaW4gdGhpcyBjYXNlIHdlIFwiZm9yZ2V0XCIgYWJvdXQgdGhlIHBhcmtlZCB2bm9kZXMgdG8gZGV0YWNoXG5cdFx0aWYgKHRoaXMuX3Zub2RlLl9jaGlsZHJlbikge1xuXHRcdFx0Y29uc3QgZGV0YWNoZWRQYXJlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHRcdGNvbnN0IGRldGFjaGVkQ29tcG9uZW50ID0gdGhpcy5fdm5vZGUuX2NoaWxkcmVuWzBdLl9jb21wb25lbnQ7XG5cdFx0XHR0aGlzLl92bm9kZS5fY2hpbGRyZW5bMF0gPSBkZXRhY2hlZENsb25lKFxuXHRcdFx0XHR0aGlzLl9kZXRhY2hPbk5leHRSZW5kZXIsXG5cdFx0XHRcdGRldGFjaGVkUGFyZW50LFxuXHRcdFx0XHQoZGV0YWNoZWRDb21wb25lbnQuX29yaWdpbmFsUGFyZW50RG9tID0gZGV0YWNoZWRDb21wb25lbnQuX3BhcmVudERvbSlcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fZGV0YWNoT25OZXh0UmVuZGVyID0gbnVsbDtcblx0fVxuXG5cdC8vIFdyYXAgZmFsbGJhY2sgdHJlZSBpbiBhIFZOb2RlIHRoYXQgcHJldmVudHMgaXRzZWxmIGZyb20gYmVpbmcgbWFya2VkIGFzIGFib3J0aW5nIG1pZC1oeWRyYXRpb246XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9ICovXG5cdGNvbnN0IGZhbGxiYWNrID1cblx0XHRzdGF0ZS5fc3VzcGVuZGVkICYmIGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIHByb3BzLmZhbGxiYWNrKTtcblx0aWYgKGZhbGxiYWNrKSBmYWxsYmFjay5faHlkcmF0aW5nID0gbnVsbDtcblxuXHRyZXR1cm4gW1xuXHRcdGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIHN0YXRlLl9zdXNwZW5kZWQgPyBudWxsIDogcHJvcHMuY2hpbGRyZW4pLFxuXHRcdGZhbGxiYWNrXG5cdF07XG59O1xuXG4vKipcbiAqIENoZWNrcyBhbmQgY2FsbHMgdGhlIHBhcmVudCBjb21wb25lbnQncyBfc3VzcGVuZGVkIG1ldGhvZCwgcGFzc2luZyBpbiB0aGVcbiAqIHN1c3BlbmRlZCB2bm9kZS4gVGhpcyBpcyBhIHdheSBmb3IgYSBwYXJlbnQgKGUuZy4gU3VzcGVuc2VMaXN0KSB0byBnZXQgbm90aWZpZWRcbiAqIHRoYXQgb25lIG9mIGl0cyBjaGlsZHJlbi9kZXNjZW5kYW50cyBzdXNwZW5kZWQuXG4gKlxuICogVGhlIHBhcmVudCBNQVkgcmV0dXJuIGEgY2FsbGJhY2suIFRoZSBjYWxsYmFjayB3aWxsIGdldCBjYWxsZWQgd2hlbiB0aGVcbiAqIHN1c3BlbnNpb24gcmVzb2x2ZXMsIG5vdGlmeWluZyB0aGUgcGFyZW50IG9mIHRoZSBmYWN0LlxuICogTW9yZW92ZXIsIHRoZSBjYWxsYmFjayBnZXRzIGZ1bmN0aW9uIGB1bnN1c3BlbmRgIGFzIGEgcGFyYW1ldGVyLiBUaGUgcmVzb2x2ZWRcbiAqIGNoaWxkIGRlc2NlbmRhbnQgd2lsbCBub3QgYWN0dWFsbHkgZ2V0IHVuc3VzcGVuZGVkIHVudGlsIGB1bnN1c3BlbmRgIGdldHMgY2FsbGVkLlxuICogVGhpcyBpcyBhIHdheSBmb3IgdGhlIHBhcmVudCB0byBkZWxheSB1bnN1c3BlbmRpbmcuXG4gKlxuICogSWYgdGhlIHBhcmVudCBkb2VzIG5vdCByZXR1cm4gYSBjYWxsYmFjayB0aGVuIHRoZSByZXNvbHZlZCB2bm9kZVxuICogZ2V0cyB1bnN1c3BlbmRlZCBpbW1lZGlhdGVseSB3aGVuIGl0IHJlc29sdmVzLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9IHZub2RlXG4gKiBAcmV0dXJucyB7KCh1bnN1c3BlbmQ6ICgpID0+IHZvaWQpID0+IHZvaWQpP31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN1c3BlbmRlZCh2bm9kZSkge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gKi9cblx0bGV0IGNvbXBvbmVudCA9IHZub2RlLl9wYXJlbnQuX2NvbXBvbmVudDtcblx0cmV0dXJuIGNvbXBvbmVudCAmJiBjb21wb25lbnQuX3N1c3BlbmRlZCAmJiBjb21wb25lbnQuX3N1c3BlbmRlZCh2bm9kZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsYXp5KGxvYWRlcikge1xuXHRsZXQgcHJvbTtcblx0bGV0IGNvbXBvbmVudDtcblx0bGV0IGVycm9yO1xuXG5cdGZ1bmN0aW9uIExhenkocHJvcHMpIHtcblx0XHRpZiAoIXByb20pIHtcblx0XHRcdHByb20gPSBsb2FkZXIoKTtcblx0XHRcdHByb20udGhlbihcblx0XHRcdFx0ZXhwb3J0cyA9PiB7XG5cdFx0XHRcdFx0Y29tcG9uZW50ID0gZXhwb3J0cy5kZWZhdWx0IHx8IGV4cG9ydHM7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGUgPT4ge1xuXHRcdFx0XHRcdGVycm9yID0gZTtcblx0XHRcdFx0fVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblxuXHRcdGlmICghY29tcG9uZW50KSB7XG5cdFx0XHR0aHJvdyBwcm9tO1xuXHRcdH1cblxuXHRcdHJldHVybiBjcmVhdGVFbGVtZW50KGNvbXBvbmVudCwgcHJvcHMpO1xuXHR9XG5cblx0TGF6eS5kaXNwbGF5TmFtZSA9ICdMYXp5Jztcblx0TGF6eS5fZm9yd2FyZGVkID0gdHJ1ZTtcblx0cmV0dXJuIExhenk7XG59XG4iLCAiaW1wb3J0IHsgQ29tcG9uZW50LCB0b0NoaWxkQXJyYXkgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgc3VzcGVuZGVkIH0gZnJvbSAnLi9zdXNwZW5zZS5qcyc7XG5cbi8vIEluZGV4ZXMgdG8gbGlua2VkIGxpc3Qgbm9kZXMgKG5vZGVzIGFyZSBzdG9yZWQgYXMgYXJyYXlzIHRvIHNhdmUgYnl0ZXMpLlxuY29uc3QgU1VTUEVOREVEX0NPVU5UID0gMDtcbmNvbnN0IFJFU09MVkVEX0NPVU5UID0gMTtcbmNvbnN0IE5FWFRfTk9ERSA9IDI7XG5cbi8vIEhhdmluZyBjdXN0b20gaW5oZXJpdGFuY2UgaW5zdGVhZCBvZiBhIGNsYXNzIGhlcmUgc2F2ZXMgYSBsb3Qgb2YgYnl0ZXMuXG5leHBvcnQgZnVuY3Rpb24gU3VzcGVuc2VMaXN0KCkge1xuXHR0aGlzLl9uZXh0ID0gbnVsbDtcblx0dGhpcy5fbWFwID0gbnVsbDtcbn1cblxuLy8gTWFyayBvbmUgb2YgY2hpbGQncyBlYXJsaWVyIHN1c3BlbnNpb25zIGFzIHJlc29sdmVkLlxuLy8gU29tZSBwZW5kaW5nIGNhbGxiYWNrcyBtYXkgYmVjb21lIGNhbGxhYmxlIGR1ZSB0byB0aGlzXG4vLyAoZS5nLiB0aGUgbGFzdCBzdXNwZW5kZWQgZGVzY2VuZGFudCBnZXRzIHJlc29sdmVkIHdoZW5cbi8vIHJldmVhbE9yZGVyID09PSAndG9nZXRoZXInKS4gUHJvY2VzcyB0aG9zZSBjYWxsYmFja3MgYXMgd2VsbC5cbmNvbnN0IHJlc29sdmUgPSAobGlzdCwgY2hpbGQsIG5vZGUpID0+IHtcblx0aWYgKCsrbm9kZVtSRVNPTFZFRF9DT1VOVF0gPT09IG5vZGVbU1VTUEVOREVEX0NPVU5UXSkge1xuXHRcdC8vIFRoZSBudW1iZXIgYSBjaGlsZCAob3IgYW55IG9mIGl0cyBkZXNjZW5kYW50cykgaGFzIGJlZW4gc3VzcGVuZGVkXG5cdFx0Ly8gbWF0Y2hlcyB0aGUgbnVtYmVyIG9mIHRpbWVzIGl0J3MgYmVlbiByZXNvbHZlZC4gVGhlcmVmb3JlIHdlXG5cdFx0Ly8gbWFyayB0aGUgY2hpbGQgYXMgY29tcGxldGVseSByZXNvbHZlZCBieSBkZWxldGluZyBpdCBmcm9tIC5fbWFwLlxuXHRcdC8vIFRoaXMgaXMgdXNlZCB0byBmaWd1cmUgb3V0IHdoZW4gKmFsbCogY2hpbGRyZW4gaGF2ZSBiZWVuIGNvbXBsZXRlbHlcblx0XHQvLyByZXNvbHZlZCB3aGVuIHJldmVhbE9yZGVyIGlzICd0b2dldGhlcicuXG5cdFx0bGlzdC5fbWFwLmRlbGV0ZShjaGlsZCk7XG5cdH1cblxuXHQvLyBJZiByZXZlYWxPcmRlciBpcyBmYWxzeSB0aGVuIHdlIGNhbiBkbyBhbiBlYXJseSBleGl0LCBhcyB0aGVcblx0Ly8gY2FsbGJhY2tzIHdvbid0IGdldCBxdWV1ZWQgaW4gdGhlIG5vZGUgYW55d2F5LlxuXHQvLyBJZiByZXZlYWxPcmRlciBpcyAndG9nZXRoZXInIHRoZW4gYWxzbyBkbyBhbiBlYXJseSBleGl0XG5cdC8vIGlmIGFsbCBzdXNwZW5kZWQgZGVzY2VuZGFudHMgaGF2ZSBub3QgeWV0IGJlZW4gcmVzb2x2ZWQuXG5cdGlmIChcblx0XHQhbGlzdC5wcm9wcy5yZXZlYWxPcmRlciB8fFxuXHRcdChsaXN0LnByb3BzLnJldmVhbE9yZGVyWzBdID09PSAndCcgJiYgbGlzdC5fbWFwLnNpemUpXG5cdCkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFdhbGsgdGhlIGN1cnJlbnRseSBzdXNwZW5kZWQgY2hpbGRyZW4gaW4gb3JkZXIsIGNhbGxpbmcgdGhlaXJcblx0Ly8gc3RvcmVkIGNhbGxiYWNrcyBvbiB0aGUgd2F5LiBTdG9wIGlmIHdlIGVuY291bnRlciBhIGNoaWxkIHRoYXRcblx0Ly8gaGFzIG5vdCBiZWVuIGNvbXBsZXRlbHkgcmVzb2x2ZWQgeWV0LlxuXHRub2RlID0gbGlzdC5fbmV4dDtcblx0d2hpbGUgKG5vZGUpIHtcblx0XHR3aGlsZSAobm9kZS5sZW5ndGggPiAzKSB7XG5cdFx0XHRub2RlLnBvcCgpKCk7XG5cdFx0fVxuXHRcdGlmIChub2RlW1JFU09MVkVEX0NPVU5UXSA8IG5vZGVbU1VTUEVOREVEX0NPVU5UXSkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdGxpc3QuX25leHQgPSBub2RlID0gbm9kZVtORVhUX05PREVdO1xuXHR9XG59O1xuXG4vLyBUaGluZ3Mgd2UgZG8gaGVyZSB0byBzYXZlIHNvbWUgYnl0ZXMgYnV0IGFyZSBub3QgcHJvcGVyIEpTIGluaGVyaXRhbmNlOlxuLy8gLSBjYWxsIGBuZXcgQ29tcG9uZW50KClgIGFzIHRoZSBwcm90b3R5cGVcbi8vIC0gZG8gbm90IHNldCBgU3VzcGVuc2UucHJvdG90eXBlLmNvbnN0cnVjdG9yYCB0byBgU3VzcGVuc2VgXG5TdXNwZW5zZUxpc3QucHJvdG90eXBlID0gbmV3IENvbXBvbmVudCgpO1xuXG5TdXNwZW5zZUxpc3QucHJvdG90eXBlLl9zdXNwZW5kZWQgPSBmdW5jdGlvbihjaGlsZCkge1xuXHRjb25zdCBsaXN0ID0gdGhpcztcblx0Y29uc3QgZGVsZWdhdGVkID0gc3VzcGVuZGVkKGxpc3QuX3Zub2RlKTtcblxuXHRsZXQgbm9kZSA9IGxpc3QuX21hcC5nZXQoY2hpbGQpO1xuXHRub2RlW1NVU1BFTkRFRF9DT1VOVF0rKztcblxuXHRyZXR1cm4gdW5zdXNwZW5kID0+IHtcblx0XHRjb25zdCB3cmFwcGVkVW5zdXNwZW5kID0gKCkgPT4ge1xuXHRcdFx0aWYgKCFsaXN0LnByb3BzLnJldmVhbE9yZGVyKSB7XG5cdFx0XHRcdC8vIFNwZWNpYWwgY2FzZSB0aGUgdW5kZWZpbmVkIChmYWxzeSkgcmV2ZWFsT3JkZXIsIGFzIHRoZXJlXG5cdFx0XHRcdC8vIGlzIG5vIG5lZWQgdG8gY29vcmRpbmF0ZSBhIHNwZWNpZmljIG9yZGVyIG9yIHVuc3VzcGVuZHMuXG5cdFx0XHRcdHVuc3VzcGVuZCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bm9kZS5wdXNoKHVuc3VzcGVuZCk7XG5cdFx0XHRcdHJlc29sdmUobGlzdCwgY2hpbGQsIG5vZGUpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0aWYgKGRlbGVnYXRlZCkge1xuXHRcdFx0ZGVsZWdhdGVkKHdyYXBwZWRVbnN1c3BlbmQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR3cmFwcGVkVW5zdXNwZW5kKCk7XG5cdFx0fVxuXHR9O1xufTtcblxuU3VzcGVuc2VMaXN0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihwcm9wcykge1xuXHR0aGlzLl9uZXh0ID0gbnVsbDtcblx0dGhpcy5fbWFwID0gbmV3IE1hcCgpO1xuXG5cdGNvbnN0IGNoaWxkcmVuID0gdG9DaGlsZEFycmF5KHByb3BzLmNoaWxkcmVuKTtcblx0aWYgKHByb3BzLnJldmVhbE9yZGVyICYmIHByb3BzLnJldmVhbE9yZGVyWzBdID09PSAnYicpIHtcblx0XHQvLyBJZiBvcmRlciA9PT0gJ2JhY2t3YXJkcycgKG9yLCB3ZWxsLCBhbnl0aGluZyBzdGFydGluZyB3aXRoIGEgJ2InKVxuXHRcdC8vIHRoZW4gZmxpcCB0aGUgY2hpbGQgbGlzdCBhcm91bmQgc28gdGhhdCB0aGUgbGFzdCBjaGlsZCB3aWxsIGJlXG5cdFx0Ly8gdGhlIGZpcnN0IGluIHRoZSBsaW5rZWQgbGlzdC5cblx0XHRjaGlsZHJlbi5yZXZlcnNlKCk7XG5cdH1cblx0Ly8gQnVpbGQgdGhlIGxpbmtlZCBsaXN0LiBJdGVyYXRlIHRocm91Z2ggdGhlIGNoaWxkcmVuIGluIHJldmVyc2Ugb3JkZXJcblx0Ly8gc28gdGhhdCBgX25leHRgIHBvaW50cyB0byB0aGUgZmlyc3QgbGlua2VkIGxpc3Qgbm9kZSB0byBiZSByZXNvbHZlZC5cblx0Zm9yIChsZXQgaSA9IGNoaWxkcmVuLmxlbmd0aDsgaS0tOyApIHtcblx0XHQvLyBDcmVhdGUgYSBuZXcgbGlua2VkIGxpc3Qgbm9kZSBhcyBhbiBhcnJheSBvZiBmb3JtOlxuXHRcdC8vIFx0W3N1c3BlbmRlZF9jb3VudCwgcmVzb2x2ZWRfY291bnQsIG5leHRfbm9kZV1cblx0XHQvLyB3aGVyZSBzdXNwZW5kZWRfY291bnQgYW5kIHJlc29sdmVkX2NvdW50IGFyZSBudW1lcmljIGNvdW50ZXJzIGZvclxuXHRcdC8vIGtlZXBpbmcgdHJhY2sgaG93IG1hbnkgdGltZXMgYSBub2RlIGhhcyBiZWVuIHN1c3BlbmRlZCBhbmQgcmVzb2x2ZWQuXG5cdFx0Ly9cblx0XHQvLyBOb3RlIHRoYXQgc3VzcGVuZGVkX2NvdW50IHN0YXJ0cyBmcm9tIDEgaW5zdGVhZCBvZiAwLCBzbyB3ZSBjYW4gYmxvY2tcblx0XHQvLyBwcm9jZXNzaW5nIGNhbGxiYWNrcyB1bnRpbCBjb21wb25lbnREaWRNb3VudCBoYXMgYmVlbiBjYWxsZWQuIEluIGEgc2Vuc2Vcblx0XHQvLyBub2RlIGlzIHN1c3BlbmRlZCBhdCBsZWFzdCB1bnRpbCBjb21wb25lbnREaWRNb3VudCBnZXRzIGNhbGxlZCFcblx0XHQvL1xuXHRcdC8vIFBlbmRpbmcgY2FsbGJhY2tzIGFyZSBhZGRlZCB0byB0aGUgZW5kIG9mIHRoZSBub2RlOlxuXHRcdC8vIFx0W3N1c3BlbmRlZF9jb3VudCwgcmVzb2x2ZWRfY291bnQsIG5leHRfbm9kZSwgY2FsbGJhY2tfMCwgY2FsbGJhY2tfMSwgLi4uXVxuXHRcdHRoaXMuX21hcC5zZXQoY2hpbGRyZW5baV0sICh0aGlzLl9uZXh0ID0gWzEsIDAsIHRoaXMuX25leHRdKSk7XG5cdH1cblx0cmV0dXJuIHByb3BzLmNoaWxkcmVuO1xufTtcblxuU3VzcGVuc2VMaXN0LnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBTdXNwZW5zZUxpc3QucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24oKSB7XG5cdC8vIEl0ZXJhdGUgdGhyb3VnaCBhbGwgY2hpbGRyZW4gYWZ0ZXIgbW91bnRpbmcgZm9yIHR3byByZWFzb25zOlxuXHQvLyAxLiBBcyBlYWNoIG5vZGVbU1VTUEVOREVEX0NPVU5UXSBzdGFydHMgZnJvbSAxLCB0aGlzIGl0ZXJhdGlvbiBpbmNyZWFzZXNcblx0Ly8gICAgZWFjaCBub2RlW1JFTEVBU0VEX0NPVU5UXSBieSAxLCB0aGVyZWZvcmUgYmFsYW5jaW5nIHRoZSBjb3VudGVycy5cblx0Ly8gICAgVGhlIG5vZGVzIGNhbiBub3cgYmUgY29tcGxldGVseSBjb25zdW1lZCBmcm9tIHRoZSBsaW5rZWQgbGlzdC5cblx0Ly8gMi4gSGFuZGxlIG5vZGVzIHRoYXQgbWlnaHQgaGF2ZSBnb3R0ZW4gcmVzb2x2ZWQgYmV0d2VlbiByZW5kZXIgYW5kXG5cdC8vICAgIGNvbXBvbmVudERpZE1vdW50LlxuXHR0aGlzLl9tYXAuZm9yRWFjaCgobm9kZSwgY2hpbGQpID0+IHtcblx0XHRyZXNvbHZlKHRoaXMsIGNoaWxkLCBub2RlKTtcblx0fSk7XG59O1xuIiwgImltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIHJlbmRlciB9IGZyb20gJ3ByZWFjdCc7XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3NyYy9pbmRleCcpLlJlbmRlcmFibGVQcm9wczx7IGNvbnRleHQ6IGFueSB9Pn0gcHJvcHNcbiAqL1xuZnVuY3Rpb24gQ29udGV4dFByb3ZpZGVyKHByb3BzKSB7XG5cdHRoaXMuZ2V0Q2hpbGRDb250ZXh0ID0gKCkgPT4gcHJvcHMuY29udGV4dDtcblx0cmV0dXJuIHByb3BzLmNoaWxkcmVuO1xufVxuXG4vKipcbiAqIFBvcnRhbCBjb21wb25lbnRcbiAqIEB0aGlzIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9XG4gKiBAcGFyYW0ge29iamVjdCB8IG51bGwgfCB1bmRlZmluZWR9IHByb3BzXG4gKlxuICogVE9ETzogdXNlIGNyZWF0ZVJvb3QoKSBpbnN0ZWFkIG9mIGZha2Ugcm9vdFxuICovXG5mdW5jdGlvbiBQb3J0YWwocHJvcHMpIHtcblx0Y29uc3QgX3RoaXMgPSB0aGlzO1xuXHRsZXQgY29udGFpbmVyID0gcHJvcHMuX2NvbnRhaW5lcjtcblxuXHRfdGhpcy5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJlbmRlcihudWxsLCBfdGhpcy5fdGVtcCk7XG5cdFx0X3RoaXMuX3RlbXAgPSBudWxsO1xuXHRcdF90aGlzLl9jb250YWluZXIgPSBudWxsO1xuXHR9O1xuXG5cdC8vIFdoZW4gd2UgY2hhbmdlIGNvbnRhaW5lciB3ZSBzaG91bGQgY2xlYXIgb3VyIG9sZCBjb250YWluZXIgYW5kXG5cdC8vIGluZGljYXRlIGEgbmV3IG1vdW50LlxuXHRpZiAoX3RoaXMuX2NvbnRhaW5lciAmJiBfdGhpcy5fY29udGFpbmVyICE9PSBjb250YWluZXIpIHtcblx0XHRfdGhpcy5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuXHR9XG5cblx0Ly8gV2hlbiBwcm9wcy52bm9kZSBpcyB1bmRlZmluZWQvZmFsc2UvbnVsbCB3ZSBhcmUgZGVhbGluZyB3aXRoIHNvbWUga2luZCBvZlxuXHQvLyBjb25kaXRpb25hbCB2bm9kZS4gVGhpcyBzaG91bGQgbm90IHRyaWdnZXIgYSByZW5kZXIuXG5cdGlmIChwcm9wcy5fdm5vZGUpIHtcblx0XHRpZiAoIV90aGlzLl90ZW1wKSB7XG5cdFx0XHRfdGhpcy5fY29udGFpbmVyID0gY29udGFpbmVyO1xuXG5cdFx0XHQvLyBDcmVhdGUgYSBmYWtlIERPTSBwYXJlbnQgbm9kZSB0aGF0IG1hbmFnZXMgYSBzdWJzZXQgb2YgYGNvbnRhaW5lcmAncyBjaGlsZHJlbjpcblx0XHRcdF90aGlzLl90ZW1wID0ge1xuXHRcdFx0XHRub2RlVHlwZTogMSxcblx0XHRcdFx0cGFyZW50Tm9kZTogY29udGFpbmVyLFxuXHRcdFx0XHRjaGlsZE5vZGVzOiBbXSxcblx0XHRcdFx0YXBwZW5kQ2hpbGQoY2hpbGQpIHtcblx0XHRcdFx0XHR0aGlzLmNoaWxkTm9kZXMucHVzaChjaGlsZCk7XG5cdFx0XHRcdFx0X3RoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZChjaGlsZCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGluc2VydEJlZm9yZShjaGlsZCwgYmVmb3JlKSB7XG5cdFx0XHRcdFx0dGhpcy5jaGlsZE5vZGVzLnB1c2goY2hpbGQpO1xuXHRcdFx0XHRcdF90aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRyZW1vdmVDaGlsZChjaGlsZCkge1xuXHRcdFx0XHRcdHRoaXMuY2hpbGROb2Rlcy5zcGxpY2UodGhpcy5jaGlsZE5vZGVzLmluZGV4T2YoY2hpbGQpID4+PiAxLCAxKTtcblx0XHRcdFx0XHRfdGhpcy5fY29udGFpbmVyLnJlbW92ZUNoaWxkKGNoaWxkKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBSZW5kZXIgb3VyIHdyYXBwaW5nIGVsZW1lbnQgaW50byB0ZW1wLlxuXHRcdHJlbmRlcihcblx0XHRcdGNyZWF0ZUVsZW1lbnQoQ29udGV4dFByb3ZpZGVyLCB7IGNvbnRleHQ6IF90aGlzLmNvbnRleHQgfSwgcHJvcHMuX3Zub2RlKSxcblx0XHRcdF90aGlzLl90ZW1wXG5cdFx0KTtcblx0fVxuXHQvLyBXaGVuIHdlIGNvbWUgZnJvbSBhIGNvbmRpdGlvbmFsIHJlbmRlciwgb24gYSBtb3VudGVkXG5cdC8vIHBvcnRhbCB3ZSBzaG91bGQgY2xlYXIgdGhlIERPTS5cblx0ZWxzZSBpZiAoX3RoaXMuX3RlbXApIHtcblx0XHRfdGhpcy5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuXHR9XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYFBvcnRhbGAgdG8gY29udGludWUgcmVuZGVyaW5nIHRoZSB2bm9kZSB0cmVlIGF0IGEgZGlmZmVyZW50IERPTSBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZSBUaGUgdm5vZGUgdG8gcmVuZGVyXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IGNvbnRhaW5lciBUaGUgRE9NIG5vZGUgdG8gY29udGludWUgcmVuZGVyaW5nIGluIHRvLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUG9ydGFsKHZub2RlLCBjb250YWluZXIpIHtcblx0Y29uc3QgZWwgPSBjcmVhdGVFbGVtZW50KFBvcnRhbCwgeyBfdm5vZGU6IHZub2RlLCBfY29udGFpbmVyOiBjb250YWluZXIgfSk7XG5cdGVsLmNvbnRhaW5lckluZm8gPSBjb250YWluZXI7XG5cdHJldHVybiBlbDtcbn1cbiIsICJpbXBvcnQge1xuXHRyZW5kZXIgYXMgcHJlYWN0UmVuZGVyLFxuXHRoeWRyYXRlIGFzIHByZWFjdEh5ZHJhdGUsXG5cdG9wdGlvbnMsXG5cdHRvQ2hpbGRBcnJheSxcblx0Q29tcG9uZW50XG59IGZyb20gJ3ByZWFjdCc7XG5cbmV4cG9ydCBjb25zdCBSRUFDVF9FTEVNRU5UX1RZUEUgPVxuXHQodHlwZW9mIFN5bWJvbCAhPSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuZm9yICYmIFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSkgfHxcblx0MHhlYWM3O1xuXG5jb25zdCBDQU1FTF9QUk9QUyA9IC9eKD86YWNjZW50fGFsaWdubWVudHxhcmFiaWN8YmFzZWxpbmV8Y2FwfGNsaXAoPyFQYXRoVSl8Y29sb3J8ZG9taW5hbnR8ZmlsbHxmbG9vZHxmb250fGdseXBoKD8hUil8aG9yaXp8aW1hZ2V8bGV0dGVyfGxpZ2h0aW5nfG1hcmtlcig/IUh8V3xVKXxvdmVybGluZXxwYWludHxwb2ludGVyfHNoYXBlfHN0b3B8c3RyaWtldGhyb3VnaHxzdHJva2V8dGV4dCg/IUwpfHRyYW5zZm9ybXx1bmRlcmxpbmV8dW5pY29kZXx1bml0c3x2fHZlY3Rvcnx2ZXJ0fHdvcmR8d3JpdGluZ3x4KD8hQykpW0EtWl0vO1xuXG5jb25zdCBJU19ET00gPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG4vLyBJbnB1dCB0eXBlcyBmb3Igd2hpY2ggb25jaGFuZ2Ugc2hvdWxkIG5vdCBiZSBjb252ZXJ0ZWQgdG8gb25pbnB1dC5cbi8vIHR5cGU9XCJmaWxlfGNoZWNrYm94fHJhZGlvXCIsIHBsdXMgXCJyYW5nZVwiIGluIElFMTEuXG4vLyAoSUUxMSBkb2Vzbid0IHN1cHBvcnQgU3ltYm9sLCB3aGljaCB3ZSB1c2UgaGVyZSB0byB0dXJuIGByYWRgIGludG8gYHJhYCB3aGljaCBtYXRjaGVzIFwicmFuZ2VcIilcbmNvbnN0IG9uQ2hhbmdlSW5wdXRUeXBlID0gdHlwZSA9PlxuXHQodHlwZW9mIFN5bWJvbCAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgU3ltYm9sKCkgPT0gJ3N5bWJvbCdcblx0XHQ/IC9maWx8Y2hlfHJhZC9pXG5cdFx0OiAvZmlsfGNoZXxyYS9pXG5cdCkudGVzdCh0eXBlKTtcblxuLy8gU29tZSBsaWJyYXJpZXMgbGlrZSBgcmVhY3QtdmlydHVhbGl6ZWRgIGV4cGxpY2l0bHkgY2hlY2sgZm9yIHRoaXMuXG5Db21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcblxuLy8gYFVOU0FGRV8qYCBsaWZlY3ljbGUgaG9va3Ncbi8vIFByZWFjdCBvbmx5IGV2ZXIgaW52b2tlcyB0aGUgdW5wcmVmaXhlZCBtZXRob2RzLlxuLy8gSGVyZSB3ZSBwcm92aWRlIGEgYmFzZSBcImZhbGxiYWNrXCIgaW1wbGVtZW50YXRpb24gdGhhdCBjYWxscyBhbnkgZGVmaW5lZCBVTlNBRkVfIHByZWZpeGVkIG1ldGhvZC5cbi8vIC0gSWYgYSBjb21wb25lbnQgZGVmaW5lcyBpdHMgb3duIGBjb21wb25lbnREaWRNb3VudCgpYCAoaW5jbHVkaW5nIHZpYSBkZWZpbmVQcm9wZXJ0eSksIHVzZSB0aGF0LlxuLy8gLSBJZiBhIGNvbXBvbmVudCBkZWZpbmVzIGBVTlNBRkVfY29tcG9uZW50RGlkTW91bnQoKWAsIGBjb21wb25lbnREaWRNb3VudGAgaXMgdGhlIGFsaWFzIGdldHRlci9zZXR0ZXIuXG4vLyAtIElmIGFueXRoaW5nIGFzc2lnbnMgdG8gYW4gYFVOU0FGRV8qYCBwcm9wZXJ0eSwgdGhlIGFzc2lnbm1lbnQgaXMgZm9yd2FyZGVkIHRvIHRoZSB1bnByZWZpeGVkIHByb3BlcnR5LlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmVhY3Rqcy9wcmVhY3QvaXNzdWVzLzE5NDFcbltcblx0J2NvbXBvbmVudFdpbGxNb3VudCcsXG5cdCdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJyxcblx0J2NvbXBvbmVudFdpbGxVcGRhdGUnXG5dLmZvckVhY2goa2V5ID0+IHtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudC5wcm90b3R5cGUsIGtleSwge1xuXHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRnZXQoKSB7XG5cdFx0XHRyZXR1cm4gdGhpc1snVU5TQUZFXycgKyBrZXldO1xuXHRcdH0sXG5cdFx0c2V0KHYpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIHtcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHZcblx0XHRcdH0pO1xuXHRcdH1cblx0fSk7XG59KTtcblxuLyoqXG4gKiBQcm94eSByZW5kZXIoKSBzaW5jZSBSZWFjdCByZXR1cm5zIGEgQ29tcG9uZW50IHJlZmVyZW5jZS5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9IHZub2RlIFZOb2RlIHRyZWUgdG8gcmVuZGVyXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IHBhcmVudCBET00gbm9kZSB0byByZW5kZXIgdm5vZGUgdHJlZSBpbnRvXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IFtjYWxsYmFja10gT3B0aW9uYWwgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGNhbGxlZCBhZnRlciByZW5kZXJpbmdcbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnQgfCBudWxsfSBUaGUgcm9vdCBjb21wb25lbnQgcmVmZXJlbmNlIG9yIG51bGxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcih2bm9kZSwgcGFyZW50LCBjYWxsYmFjaykge1xuXHQvLyBSZWFjdCBkZXN0cm95cyBhbnkgZXhpc3RpbmcgRE9NIG5vZGVzLCBzZWUgIzE3Mjdcblx0Ly8gLi4uYnV0IG9ubHkgb24gdGhlIGZpcnN0IHJlbmRlciwgc2VlICMxODI4XG5cdGlmIChwYXJlbnQuX2NoaWxkcmVuID09IG51bGwpIHtcblx0XHRwYXJlbnQudGV4dENvbnRlbnQgPSAnJztcblx0fVxuXG5cdHByZWFjdFJlbmRlcih2bm9kZSwgcGFyZW50KTtcblx0aWYgKHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nKSBjYWxsYmFjaygpO1xuXG5cdHJldHVybiB2bm9kZSA/IHZub2RlLl9jb21wb25lbnQgOiBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaHlkcmF0ZSh2bm9kZSwgcGFyZW50LCBjYWxsYmFjaykge1xuXHRwcmVhY3RIeWRyYXRlKHZub2RlLCBwYXJlbnQpO1xuXHRpZiAodHlwZW9mIGNhbGxiYWNrID09ICdmdW5jdGlvbicpIGNhbGxiYWNrKCk7XG5cblx0cmV0dXJuIHZub2RlID8gdm5vZGUuX2NvbXBvbmVudCA6IG51bGw7XG59XG5cbmxldCBvbGRFdmVudEhvb2sgPSBvcHRpb25zLmV2ZW50O1xub3B0aW9ucy5ldmVudCA9IGUgPT4ge1xuXHRpZiAob2xkRXZlbnRIb29rKSBlID0gb2xkRXZlbnRIb29rKGUpO1xuXHRlLnBlcnNpc3QgPSBlbXB0eTtcblx0ZS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGlzUHJvcGFnYXRpb25TdG9wcGVkO1xuXHRlLmlzRGVmYXVsdFByZXZlbnRlZCA9IGlzRGVmYXVsdFByZXZlbnRlZDtcblx0cmV0dXJuIChlLm5hdGl2ZUV2ZW50ID0gZSk7XG59O1xuXG5mdW5jdGlvbiBlbXB0eSgpIHt9XG5cbmZ1bmN0aW9uIGlzUHJvcGFnYXRpb25TdG9wcGVkKCkge1xuXHRyZXR1cm4gdGhpcy5jYW5jZWxCdWJibGU7XG59XG5cbmZ1bmN0aW9uIGlzRGVmYXVsdFByZXZlbnRlZCgpIHtcblx0cmV0dXJuIHRoaXMuZGVmYXVsdFByZXZlbnRlZDtcbn1cblxubGV0IGNsYXNzTmFtZURlc2NyaXB0b3IgPSB7XG5cdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0Z2V0KCkge1xuXHRcdHJldHVybiB0aGlzLmNsYXNzO1xuXHR9XG59O1xuXG5sZXQgb2xkVk5vZGVIb29rID0gb3B0aW9ucy52bm9kZTtcbm9wdGlvbnMudm5vZGUgPSB2bm9kZSA9PiB7XG5cdGxldCB0eXBlID0gdm5vZGUudHlwZTtcblx0bGV0IHByb3BzID0gdm5vZGUucHJvcHM7XG5cdGxldCBub3JtYWxpemVkUHJvcHMgPSBwcm9wcztcblxuXHQvLyBvbmx5IG5vcm1hbGl6ZSBwcm9wcyBvbiBFbGVtZW50IG5vZGVzXG5cdGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcblx0XHRjb25zdCBub25DdXN0b21FbGVtZW50ID0gdHlwZS5pbmRleE9mKCctJykgPT09IC0xO1xuXHRcdG5vcm1hbGl6ZWRQcm9wcyA9IHt9O1xuXG5cdFx0Zm9yIChsZXQgaSBpbiBwcm9wcykge1xuXHRcdFx0bGV0IHZhbHVlID0gcHJvcHNbaV07XG5cblx0XHRcdGlmIChJU19ET00gJiYgaSA9PT0gJ2NoaWxkcmVuJyAmJiB0eXBlID09PSAnbm9zY3JpcHQnKSB7XG5cdFx0XHRcdC8vIEVtdWxhdGUgUmVhY3QncyBiZWhhdmlvciBvZiBub3QgcmVuZGVyaW5nIHRoZSBjb250ZW50cyBvZiBub3NjcmlwdCB0YWdzIG9uIHRoZSBjbGllbnQuXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fSBlbHNlIGlmIChpID09PSAndmFsdWUnICYmICdkZWZhdWx0VmFsdWUnIGluIHByb3BzICYmIHZhbHVlID09IG51bGwpIHtcblx0XHRcdFx0Ly8gU2tpcCBhcHBseWluZyB2YWx1ZSBpZiBpdCBpcyBudWxsL3VuZGVmaW5lZCBhbmQgd2UgYWxyZWFkeSBzZXRcblx0XHRcdFx0Ly8gYSBkZWZhdWx0IHZhbHVlXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fSBlbHNlIGlmIChcblx0XHRcdFx0aSA9PT0gJ2RlZmF1bHRWYWx1ZScgJiZcblx0XHRcdFx0J3ZhbHVlJyBpbiBwcm9wcyAmJlxuXHRcdFx0XHRwcm9wcy52YWx1ZSA9PSBudWxsXG5cdFx0XHQpIHtcblx0XHRcdFx0Ly8gYGRlZmF1bHRWYWx1ZWAgaXMgdHJlYXRlZCBhcyBhIGZhbGxiYWNrIGB2YWx1ZWAgd2hlbiBhIHZhbHVlIHByb3AgaXMgcHJlc2VudCBidXQgbnVsbC91bmRlZmluZWQuXG5cdFx0XHRcdC8vIGBkZWZhdWx0VmFsdWVgIGZvciBFbGVtZW50cyB3aXRoIG5vIHZhbHVlIHByb3AgaXMgdGhlIHNhbWUgYXMgdGhlIERPTSBkZWZhdWx0VmFsdWUgcHJvcGVydHkuXG5cdFx0XHRcdGkgPSAndmFsdWUnO1xuXHRcdFx0fSBlbHNlIGlmIChpID09PSAnZG93bmxvYWQnICYmIHZhbHVlID09PSB0cnVlKSB7XG5cdFx0XHRcdC8vIENhbGxpbmcgYHNldEF0dHJpYnV0ZWAgd2l0aCBhIHRydXRoeSB2YWx1ZSB3aWxsIGxlYWQgdG8gaXQgYmVpbmdcblx0XHRcdFx0Ly8gcGFzc2VkIGFzIGEgc3RyaW5naWZpZWQgdmFsdWUsIGUuZy4gYGRvd25sb2FkPVwidHJ1ZVwiYC4gUmVhY3Rcblx0XHRcdFx0Ly8gY29udmVydHMgaXQgdG8gYW4gZW1wdHkgc3RyaW5nIGluc3RlYWQsIG90aGVyd2lzZSB0aGUgYXR0cmlidXRlXG5cdFx0XHRcdC8vIHZhbHVlIHdpbGwgYmUgdXNlZCBhcyB0aGUgZmlsZSBuYW1lIGFuZCB0aGUgZmlsZSB3aWxsIGJlIGNhbGxlZFxuXHRcdFx0XHQvLyBcInRydWVcIiB1cG9uIGRvd25sb2FkaW5nIGl0LlxuXHRcdFx0XHR2YWx1ZSA9ICcnO1xuXHRcdFx0fSBlbHNlIGlmICgvb25kb3VibGVjbGljay9pLnRlc3QoaSkpIHtcblx0XHRcdFx0aSA9ICdvbmRibGNsaWNrJztcblx0XHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRcdC9eb25jaGFuZ2UodGV4dGFyZWF8aW5wdXQpL2kudGVzdChpICsgdHlwZSkgJiZcblx0XHRcdFx0IW9uQ2hhbmdlSW5wdXRUeXBlKHByb3BzLnR5cGUpXG5cdFx0XHQpIHtcblx0XHRcdFx0aSA9ICdvbmlucHV0Jztcblx0XHRcdH0gZWxzZSBpZiAoL15vbmZvY3VzJC9pLnRlc3QoaSkpIHtcblx0XHRcdFx0aSA9ICdvbmZvY3VzaW4nO1xuXHRcdFx0fSBlbHNlIGlmICgvXm9uYmx1ciQvaS50ZXN0KGkpKSB7XG5cdFx0XHRcdGkgPSAnb25mb2N1c291dCc7XG5cdFx0XHR9IGVsc2UgaWYgKC9eb24oQW5pfFRyYXxUb3V8QmVmb3JlSW5wfENvbXBvKS8udGVzdChpKSkge1xuXHRcdFx0XHRpID0gaS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0fSBlbHNlIGlmIChub25DdXN0b21FbGVtZW50ICYmIENBTUVMX1BST1BTLnRlc3QoaSkpIHtcblx0XHRcdFx0aSA9IGkucmVwbGFjZSgvW0EtWjAtOV0vZywgJy0kJicpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHR9IGVsc2UgaWYgKHZhbHVlID09PSBudWxsKSB7XG5cdFx0XHRcdHZhbHVlID0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgc3VwcG9ydCBmb3Igb25JbnB1dCBhbmQgb25DaGFuZ2UsIHNlZSAjMzU2MVxuXHRcdFx0Ly8gaWYgd2UgaGF2ZSBhbiBvbmlucHV0IHByb3AgYWxyZWFkeSBjaGFuZ2UgaXQgdG8gb25pbnB1dENhcHR1cmVcblx0XHRcdGlmICgvXm9uaW5wdXQkL2kudGVzdChpKSkge1xuXHRcdFx0XHRpID0gaS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRpZiAobm9ybWFsaXplZFByb3BzW2ldKSB7XG5cdFx0XHRcdFx0aSA9ICdvbmlucHV0Q2FwdHVyZSc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0bm9ybWFsaXplZFByb3BzW2ldID0gdmFsdWU7XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHN1cHBvcnQgZm9yIGFycmF5IHNlbGVjdCB2YWx1ZXM6IDxzZWxlY3QgbXVsdGlwbGUgdmFsdWU9e1tdfSAvPlxuXHRcdGlmIChcblx0XHRcdHR5cGUgPT0gJ3NlbGVjdCcgJiZcblx0XHRcdG5vcm1hbGl6ZWRQcm9wcy5tdWx0aXBsZSAmJlxuXHRcdFx0QXJyYXkuaXNBcnJheShub3JtYWxpemVkUHJvcHMudmFsdWUpXG5cdFx0KSB7XG5cdFx0XHQvLyBmb3JFYWNoKCkgYWx3YXlzIHJldHVybnMgdW5kZWZpbmVkLCB3aGljaCB3ZSBhYnVzZSBoZXJlIHRvIHVuc2V0IHRoZSB2YWx1ZSBwcm9wLlxuXHRcdFx0bm9ybWFsaXplZFByb3BzLnZhbHVlID0gdG9DaGlsZEFycmF5KHByb3BzLmNoaWxkcmVuKS5mb3JFYWNoKGNoaWxkID0+IHtcblx0XHRcdFx0Y2hpbGQucHJvcHMuc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdG5vcm1hbGl6ZWRQcm9wcy52YWx1ZS5pbmRleE9mKGNoaWxkLnByb3BzLnZhbHVlKSAhPSAtMTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8vIEFkZGluZyBzdXBwb3J0IGZvciBkZWZhdWx0VmFsdWUgaW4gc2VsZWN0IHRhZ1xuXHRcdGlmICh0eXBlID09ICdzZWxlY3QnICYmIG5vcm1hbGl6ZWRQcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuXHRcdFx0bm9ybWFsaXplZFByb3BzLnZhbHVlID0gdG9DaGlsZEFycmF5KHByb3BzLmNoaWxkcmVuKS5mb3JFYWNoKGNoaWxkID0+IHtcblx0XHRcdFx0aWYgKG5vcm1hbGl6ZWRQcm9wcy5tdWx0aXBsZSkge1xuXHRcdFx0XHRcdGNoaWxkLnByb3BzLnNlbGVjdGVkID1cblx0XHRcdFx0XHRcdG5vcm1hbGl6ZWRQcm9wcy5kZWZhdWx0VmFsdWUuaW5kZXhPZihjaGlsZC5wcm9wcy52YWx1ZSkgIT0gLTE7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y2hpbGQucHJvcHMuc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdFx0bm9ybWFsaXplZFByb3BzLmRlZmF1bHRWYWx1ZSA9PSBjaGlsZC5wcm9wcy52YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dm5vZGUucHJvcHMgPSBub3JtYWxpemVkUHJvcHM7XG5cblx0XHRpZiAocHJvcHMuY2xhc3MgIT0gcHJvcHMuY2xhc3NOYW1lKSB7XG5cdFx0XHRjbGFzc05hbWVEZXNjcmlwdG9yLmVudW1lcmFibGUgPSAnY2xhc3NOYW1lJyBpbiBwcm9wcztcblx0XHRcdGlmIChwcm9wcy5jbGFzc05hbWUgIT0gbnVsbCkgbm9ybWFsaXplZFByb3BzLmNsYXNzID0gcHJvcHMuY2xhc3NOYW1lO1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5vcm1hbGl6ZWRQcm9wcywgJ2NsYXNzTmFtZScsIGNsYXNzTmFtZURlc2NyaXB0b3IpO1xuXHRcdH1cblx0fVxuXG5cdHZub2RlLiQkdHlwZW9mID0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuXG5cdGlmIChvbGRWTm9kZUhvb2spIG9sZFZOb2RlSG9vayh2bm9kZSk7XG59O1xuXG4vLyBPbmx5IG5lZWRlZCBmb3IgcmVhY3QtcmVsYXlcbmxldCBjdXJyZW50Q29tcG9uZW50O1xuY29uc3Qgb2xkQmVmb3JlUmVuZGVyID0gb3B0aW9ucy5fcmVuZGVyO1xub3B0aW9ucy5fcmVuZGVyID0gZnVuY3Rpb24odm5vZGUpIHtcblx0aWYgKG9sZEJlZm9yZVJlbmRlcikge1xuXHRcdG9sZEJlZm9yZVJlbmRlcih2bm9kZSk7XG5cdH1cblx0Y3VycmVudENvbXBvbmVudCA9IHZub2RlLl9jb21wb25lbnQ7XG59O1xuXG4vLyBUaGlzIGlzIGEgdmVyeSB2ZXJ5IHByaXZhdGUgaW50ZXJuYWwgZnVuY3Rpb24gZm9yIFJlYWN0IGl0XG4vLyBpcyB1c2VkIHRvIHNvcnQtb2YgZG8gcnVudGltZSBkZXBlbmRlbmN5IGluamVjdGlvbi4gU28gZmFyXG4vLyBvbmx5IGByZWFjdC1yZWxheWAgbWFrZXMgdXNlIG9mIGl0LiBJdCB1c2VzIGl0IHRvIHJlYWQgdGhlXG4vLyBjb250ZXh0IHZhbHVlLlxuZXhwb3J0IGNvbnN0IF9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEID0ge1xuXHRSZWFjdEN1cnJlbnREaXNwYXRjaGVyOiB7XG5cdFx0Y3VycmVudDoge1xuXHRcdFx0cmVhZENvbnRleHQoY29udGV4dCkge1xuXHRcdFx0XHRyZXR1cm4gY3VycmVudENvbXBvbmVudC5fZ2xvYmFsQ29udGV4dFtjb250ZXh0Ll9pZF0ucHJvcHMudmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuIiwgImltcG9ydCB7XG5cdGNyZWF0ZUVsZW1lbnQsXG5cdHJlbmRlciBhcyBwcmVhY3RSZW5kZXIsXG5cdGNsb25lRWxlbWVudCBhcyBwcmVhY3RDbG9uZUVsZW1lbnQsXG5cdGNyZWF0ZVJlZixcblx0Q29tcG9uZW50LFxuXHRjcmVhdGVDb250ZXh0LFxuXHRGcmFnbWVudFxufSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHtcblx0dXNlU3RhdGUsXG5cdHVzZUlkLFxuXHR1c2VSZWR1Y2VyLFxuXHR1c2VFZmZlY3QsXG5cdHVzZUxheW91dEVmZmVjdCxcblx0dXNlUmVmLFxuXHR1c2VJbXBlcmF0aXZlSGFuZGxlLFxuXHR1c2VNZW1vLFxuXHR1c2VDYWxsYmFjayxcblx0dXNlQ29udGV4dCxcblx0dXNlRGVidWdWYWx1ZVxufSBmcm9tICdwcmVhY3QvaG9va3MnO1xuaW1wb3J0IHsgUHVyZUNvbXBvbmVudCB9IGZyb20gJy4vUHVyZUNvbXBvbmVudCc7XG5pbXBvcnQgeyBtZW1vIH0gZnJvbSAnLi9tZW1vJztcbmltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICcuL2ZvcndhcmRSZWYnO1xuaW1wb3J0IHsgQ2hpbGRyZW4gfSBmcm9tICcuL0NoaWxkcmVuJztcbmltcG9ydCB7IFN1c3BlbnNlLCBsYXp5IH0gZnJvbSAnLi9zdXNwZW5zZSc7XG5pbXBvcnQgeyBTdXNwZW5zZUxpc3QgfSBmcm9tICcuL3N1c3BlbnNlLWxpc3QnO1xuaW1wb3J0IHsgY3JlYXRlUG9ydGFsIH0gZnJvbSAnLi9wb3J0YWxzJztcbmltcG9ydCB7IGlzIH0gZnJvbSAnLi91dGlsJztcbmltcG9ydCB7XG5cdGh5ZHJhdGUsXG5cdHJlbmRlcixcblx0UkVBQ1RfRUxFTUVOVF9UWVBFLFxuXHRfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRFxufSBmcm9tICcuL3JlbmRlcic7XG5cbmNvbnN0IHZlcnNpb24gPSAnMTcuMC4yJzsgLy8gdHJpY2sgbGlicmFyaWVzIHRvIHRoaW5rIHdlIGFyZSByZWFjdFxuXG4vKipcbiAqIExlZ2FjeSB2ZXJzaW9uIG9mIGNyZWF0ZUVsZW1lbnQuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlW1widHlwZVwiXX0gdHlwZSBUaGUgbm9kZSBuYW1lIG9yIENvbXBvbmVudCBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBjcmVhdGVGYWN0b3J5KHR5cGUpIHtcblx0cmV0dXJuIGNyZWF0ZUVsZW1lbnQuYmluZChudWxsLCB0eXBlKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgcGFzc2VkIGVsZW1lbnQgaXMgYSB2YWxpZCAocClyZWFjdCBub2RlLlxuICogQHBhcmFtIHsqfSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkge1xuXHRyZXR1cm4gISFlbGVtZW50ICYmIGVsZW1lbnQuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cblxuLyoqXG4gKiBXcmFwIGBjbG9uZUVsZW1lbnRgIHRvIGFib3J0IGlmIHRoZSBwYXNzZWQgZWxlbWVudCBpcyBub3QgYSB2YWxpZCBlbGVtZW50IGFuZCBhcHBseVxuICogYWxsIHZub2RlIG5vcm1hbGl6YXRpb25zLlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gZWxlbWVudCBUaGUgdm5vZGUgdG8gY2xvbmVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcyBQcm9wcyB0byBhZGQgd2hlbiBjbG9uaW5nXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudENoaWxkcmVuPn0gcmVzdCBPcHRpb25hbCBjb21wb25lbnQgY2hpbGRyZW5cbiAqL1xuZnVuY3Rpb24gY2xvbmVFbGVtZW50KGVsZW1lbnQpIHtcblx0aWYgKCFpc1ZhbGlkRWxlbWVudChlbGVtZW50KSkgcmV0dXJuIGVsZW1lbnQ7XG5cdHJldHVybiBwcmVhY3RDbG9uZUVsZW1lbnQuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYSBjb21wb25lbnQgdHJlZSBmcm9tIHRoZSBET00sIGluY2x1ZGluZyBzdGF0ZSBhbmQgZXZlbnQgaGFuZGxlcnMuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IGNvbnRhaW5lclxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHVubW91bnRDb21wb25lbnRBdE5vZGUoY29udGFpbmVyKSB7XG5cdGlmIChjb250YWluZXIuX2NoaWxkcmVuKSB7XG5cdFx0cHJlYWN0UmVuZGVyKG51bGwsIGNvbnRhaW5lcik7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbWF0Y2hpbmcgRE9NIG5vZGUgZm9yIGEgY29tcG9uZW50XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gY29tcG9uZW50XG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL2ludGVybmFsJykuUHJlYWN0RWxlbWVudCB8IG51bGx9XG4gKi9cbmZ1bmN0aW9uIGZpbmRET01Ob2RlKGNvbXBvbmVudCkge1xuXHRyZXR1cm4gKFxuXHRcdChjb21wb25lbnQgJiZcblx0XHRcdChjb21wb25lbnQuYmFzZSB8fCAoY29tcG9uZW50Lm5vZGVUeXBlID09PSAxICYmIGNvbXBvbmVudCkpKSB8fFxuXHRcdG51bGxcblx0KTtcbn1cblxuLyoqXG4gKiBEZXByZWNhdGVkIHdheSB0byBjb250cm9sIGJhdGNoZWQgcmVuZGVyaW5nIGluc2lkZSB0aGUgcmVjb25jaWxlciwgYnV0IHdlXG4gKiBhbHJlYWR5IHNjaGVkdWxlIGluIGJhdGNoZXMgaW5zaWRlIG91ciByZW5kZXJpbmcgY29kZVxuICogQHRlbXBsYXRlIEFyZ1xuICogQHBhcmFtIHsoYXJnOiBBcmcpID0+IHZvaWR9IGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgdHJpZ2dlcnMgdGhlIHVwZGF0ZWRcbiAqIEBwYXJhbSB7QXJnfSBbYXJnXSBPcHRpb25hbCBhcmd1bWVudCB0aGF0IGNhbiBiZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjYW1lbGNhc2VcbmNvbnN0IHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzID0gKGNhbGxiYWNrLCBhcmcpID0+IGNhbGxiYWNrKGFyZyk7XG5cbi8qKlxuICogSW4gUmVhY3QsIGBmbHVzaFN5bmNgIGZsdXNoZXMgdGhlIGVudGlyZSB0cmVlIGFuZCBmb3JjZXMgYSByZXJlbmRlci4gSXQnc1xuICogaW1wbG1lbnRlZCBoZXJlIGFzIGEgbm8tb3AuXG4gKiBAdGVtcGxhdGUgQXJnXG4gKiBAdGVtcGxhdGUgUmVzdWx0XG4gKiBAcGFyYW0geyhhcmc6IEFyZykgPT4gUmVzdWx0fSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHJ1bnMgYmVmb3JlIHRoZSBmbHVzaFxuICogQHBhcmFtIHtBcmd9IFthcmddIE9wdGlvbmFsIGFyZ3VtZW50IHRoYXQgY2FuIGJlIHBhc3NlZCB0byB0aGUgY2FsbGJhY2tcbiAqIEByZXR1cm5zXG4gKi9cbmNvbnN0IGZsdXNoU3luYyA9IChjYWxsYmFjaywgYXJnKSA9PiBjYWxsYmFjayhhcmcpO1xuXG4vKipcbiAqIFN0cmljdCBNb2RlIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiBQcmVhY3QsIHNvIHdlIHByb3ZpZGUgYSBzdGFuZC1pbiBmb3IgaXRcbiAqIHRoYXQganVzdCByZW5kZXJzIGl0cyBjaGlsZHJlbiB3aXRob3V0IGltcG9zaW5nIGFueSByZXN0cmljdGlvbnMuXG4gKi9cbmNvbnN0IFN0cmljdE1vZGUgPSBGcmFnbWVudDtcblxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0VHJhbnNpdGlvbihjYikge1xuXHRjYigpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlRGVmZXJyZWRWYWx1ZSh2YWwpIHtcblx0cmV0dXJuIHZhbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVRyYW5zaXRpb24oKSB7XG5cdHJldHVybiBbZmFsc2UsIHN0YXJ0VHJhbnNpdGlvbl07XG59XG5cbi8vIFRPRE86IGluIHRoZW9yeSB0aGlzIHNob3VsZCBiZSBkb25lIGFmdGVyIGEgVk5vZGUgaXMgZGlmZmVkIGFzIHdlIHdhbnQgdG8gaW5zZXJ0XG4vLyBzdHlsZXMvLi4uIGJlZm9yZSBpdCBhdHRhY2hlc1xuZXhwb3J0IGNvbnN0IHVzZUluc2VydGlvbkVmZmVjdCA9IHVzZUxheW91dEVmZmVjdDtcblxuLyoqXG4gKiBUaGlzIGlzIHRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvbWFpbi9wYWNrYWdlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zcmMvdXNlU3luY0V4dGVybmFsU3RvcmVTaGltQ2xpZW50LmpzI0w4NFxuICogb24gYSBoaWdoIGxldmVsIHRoaXMgY3V0cyBvdXQgdGhlIHdhcm5pbmdzLCAuLi4gYW5kIGF0dGVtcHRzIGEgc21hbGxlciBpbXBsZW1lbnRhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCkge1xuXHRjb25zdCB2YWx1ZSA9IGdldFNuYXBzaG90KCk7XG5cblx0Y29uc3QgW3sgX2luc3RhbmNlIH0sIGZvcmNlVXBkYXRlXSA9IHVzZVN0YXRlKHtcblx0XHRfaW5zdGFuY2U6IHsgX3ZhbHVlOiB2YWx1ZSwgX2dldFNuYXBzaG90OiBnZXRTbmFwc2hvdCB9XG5cdH0pO1xuXG5cdHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG5cdFx0X2luc3RhbmNlLl92YWx1ZSA9IHZhbHVlO1xuXHRcdF9pbnN0YW5jZS5fZ2V0U25hcHNob3QgPSBnZXRTbmFwc2hvdDtcblxuXHRcdGlmICghaXMoX2luc3RhbmNlLl92YWx1ZSwgZ2V0U25hcHNob3QoKSkpIHtcblx0XHRcdGZvcmNlVXBkYXRlKHsgX2luc3RhbmNlIH0pO1xuXHRcdH1cblx0fSwgW3N1YnNjcmliZSwgdmFsdWUsIGdldFNuYXBzaG90XSk7XG5cblx0dXNlRWZmZWN0KCgpID0+IHtcblx0XHRpZiAoIWlzKF9pbnN0YW5jZS5fdmFsdWUsIF9pbnN0YW5jZS5fZ2V0U25hcHNob3QoKSkpIHtcblx0XHRcdGZvcmNlVXBkYXRlKHsgX2luc3RhbmNlIH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBzdWJzY3JpYmUoKCkgPT4ge1xuXHRcdFx0aWYgKCFpcyhfaW5zdGFuY2UuX3ZhbHVlLCBfaW5zdGFuY2UuX2dldFNuYXBzaG90KCkpKSB7XG5cdFx0XHRcdGZvcmNlVXBkYXRlKHsgX2luc3RhbmNlIH0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LCBbc3Vic2NyaWJlXSk7XG5cblx0cmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgKiBmcm9tICdwcmVhY3QvaG9va3MnO1xuZXhwb3J0IHtcblx0dmVyc2lvbixcblx0Q2hpbGRyZW4sXG5cdHJlbmRlcixcblx0aHlkcmF0ZSxcblx0dW5tb3VudENvbXBvbmVudEF0Tm9kZSxcblx0Y3JlYXRlUG9ydGFsLFxuXHRjcmVhdGVFbGVtZW50LFxuXHRjcmVhdGVDb250ZXh0LFxuXHRjcmVhdGVGYWN0b3J5LFxuXHRjbG9uZUVsZW1lbnQsXG5cdGNyZWF0ZVJlZixcblx0RnJhZ21lbnQsXG5cdGlzVmFsaWRFbGVtZW50LFxuXHRmaW5kRE9NTm9kZSxcblx0Q29tcG9uZW50LFxuXHRQdXJlQ29tcG9uZW50LFxuXHRtZW1vLFxuXHRmb3J3YXJkUmVmLFxuXHRmbHVzaFN5bmMsXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjYW1lbGNhc2Vcblx0dW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMsXG5cdFN0cmljdE1vZGUsXG5cdFN1c3BlbnNlLFxuXHRTdXNwZW5zZUxpc3QsXG5cdGxhenksXG5cdF9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEXG59O1xuXG4vLyBSZWFjdCBjb3BpZXMgdGhlIG5hbWVkIGV4cG9ydHMgdG8gdGhlIGRlZmF1bHQgb25lLlxuZXhwb3J0IGRlZmF1bHQge1xuXHR1c2VTdGF0ZSxcblx0dXNlSWQsXG5cdHVzZVJlZHVjZXIsXG5cdHVzZUVmZmVjdCxcblx0dXNlTGF5b3V0RWZmZWN0LFxuXHR1c2VJbnNlcnRpb25FZmZlY3QsXG5cdHVzZVRyYW5zaXRpb24sXG5cdHVzZURlZmVycmVkVmFsdWUsXG5cdHVzZVN5bmNFeHRlcm5hbFN0b3JlLFxuXHRzdGFydFRyYW5zaXRpb24sXG5cdHVzZVJlZixcblx0dXNlSW1wZXJhdGl2ZUhhbmRsZSxcblx0dXNlTWVtbyxcblx0dXNlQ2FsbGJhY2ssXG5cdHVzZUNvbnRleHQsXG5cdHVzZURlYnVnVmFsdWUsXG5cdHZlcnNpb24sXG5cdENoaWxkcmVuLFxuXHRyZW5kZXIsXG5cdGh5ZHJhdGUsXG5cdHVubW91bnRDb21wb25lbnRBdE5vZGUsXG5cdGNyZWF0ZVBvcnRhbCxcblx0Y3JlYXRlRWxlbWVudCxcblx0Y3JlYXRlQ29udGV4dCxcblx0Y3JlYXRlRmFjdG9yeSxcblx0Y2xvbmVFbGVtZW50LFxuXHRjcmVhdGVSZWYsXG5cdEZyYWdtZW50LFxuXHRpc1ZhbGlkRWxlbWVudCxcblx0ZmluZERPTU5vZGUsXG5cdENvbXBvbmVudCxcblx0UHVyZUNvbXBvbmVudCxcblx0bWVtbyxcblx0Zm9yd2FyZFJlZixcblx0Zmx1c2hTeW5jLFxuXHR1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyxcblx0U3RyaWN0TW9kZSxcblx0U3VzcGVuc2UsXG5cdFN1c3BlbnNlTGlzdCxcblx0bGF6eSxcblx0X19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRURcbn07XG4iLCAiaW1wb3J0ICogYXMgcHJlYWN0IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgeyBDb21wb25lbnQsIGNyZWF0ZUVsZW1lbnQsIGlzVmFsaWRFbGVtZW50LCBGcmFnbWVudCB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgeyBjcmVhdGVQb3J0YWwgfSBmcm9tICdwcmVhY3QvY29tcGF0JztcblxuY29uc3Qgc3R5bGVUZXh0cyA9IFtdO1xuY29uc3Qgc3R5bGVFbHMgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBpbmplY3RTdHlsZXMoc3R5bGVUZXh0KSB7XG4gICAgc3R5bGVUZXh0cy5wdXNoKHN0eWxlVGV4dCk7XG4gICAgc3R5bGVFbHMuZm9yRWFjaCgoc3R5bGVFbCkgPT4ge1xuICAgICAgICBhcHBlbmRTdHlsZXNUbyhzdHlsZUVsLCBzdHlsZVRleHQpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZW5zdXJlRWxIYXNTdHlsZXMoZWwpIHtcbiAgICBpZiAoZWwuaXNDb25uZWN0ZWQgJiYgLy8gc29tZXRpbWVzIHRydWUgaWYgU1NSIHN5c3RlbSBzaW11bGF0ZXMgRE9NXG4gICAgICAgIGVsLmdldFJvb3ROb2RlIC8vIHNvbWV0aW1lcyB1bmRlZmluZWQgaWYgU1NSIHN5c3RlbSBzaW11bGF0ZXMgRE9NXG4gICAgKSB7XG4gICAgICAgIHJlZ2lzdGVyU3R5bGVzUm9vdChlbC5nZXRSb290Tm9kZSgpKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZWdpc3RlclN0eWxlc1Jvb3Qocm9vdE5vZGUpIHtcbiAgICBsZXQgc3R5bGVFbCA9IHN0eWxlRWxzLmdldChyb290Tm9kZSk7XG4gICAgaWYgKCFzdHlsZUVsIHx8ICFzdHlsZUVsLmlzQ29ubmVjdGVkKSB7XG4gICAgICAgIHN0eWxlRWwgPSByb290Tm9kZS5xdWVyeVNlbGVjdG9yKCdzdHlsZVtkYXRhLWZ1bGxjYWxlbmRhcl0nKTtcbiAgICAgICAgaWYgKCFzdHlsZUVsKSB7XG4gICAgICAgICAgICBzdHlsZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgICAgIHN0eWxlRWwuc2V0QXR0cmlidXRlKCdkYXRhLWZ1bGxjYWxlbmRhcicsICcnKTtcbiAgICAgICAgICAgIGNvbnN0IG5vbmNlID0gZ2V0Tm9uY2VWYWx1ZSgpO1xuICAgICAgICAgICAgaWYgKG5vbmNlKSB7XG4gICAgICAgICAgICAgICAgc3R5bGVFbC5ub25jZSA9IG5vbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFyZW50RWwgPSByb290Tm9kZSA9PT0gZG9jdW1lbnQgPyBkb2N1bWVudC5oZWFkIDogcm9vdE5vZGU7XG4gICAgICAgICAgICBjb25zdCBpbnNlcnRCZWZvcmUgPSByb290Tm9kZSA9PT0gZG9jdW1lbnRcbiAgICAgICAgICAgICAgICA/IHBhcmVudEVsLnF1ZXJ5U2VsZWN0b3IoJ3NjcmlwdCxsaW5rW3JlbD1zdHlsZXNoZWV0XSxsaW5rW2FzPXN0eWxlXSxzdHlsZScpXG4gICAgICAgICAgICAgICAgOiBwYXJlbnRFbC5maXJzdENoaWxkO1xuICAgICAgICAgICAgcGFyZW50RWwuaW5zZXJ0QmVmb3JlKHN0eWxlRWwsIGluc2VydEJlZm9yZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3R5bGVFbHMuc2V0KHJvb3ROb2RlLCBzdHlsZUVsKTtcbiAgICAgICAgaHlkcmF0ZVN0eWxlc1Jvb3Qoc3R5bGVFbCk7XG4gICAgfVxufVxuZnVuY3Rpb24gaHlkcmF0ZVN0eWxlc1Jvb3Qoc3R5bGVFbCkge1xuICAgIGZvciAoY29uc3Qgc3R5bGVUZXh0IG9mIHN0eWxlVGV4dHMpIHtcbiAgICAgICAgYXBwZW5kU3R5bGVzVG8oc3R5bGVFbCwgc3R5bGVUZXh0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBlbmRTdHlsZXNUbyhzdHlsZUVsLCBzdHlsZVRleHQpIHtcbiAgICBjb25zdCB7IHNoZWV0IH0gPSBzdHlsZUVsO1xuICAgIGNvbnN0IHJ1bGVDbnQgPSBzaGVldC5jc3NSdWxlcy5sZW5ndGg7XG4gICAgc3R5bGVUZXh0LnNwbGl0KCd9JykuZm9yRWFjaCgoc3R5bGVTdHIsIGkpID0+IHtcbiAgICAgICAgc3R5bGVTdHIgPSBzdHlsZVN0ci50cmltKCk7XG4gICAgICAgIGlmIChzdHlsZVN0cikge1xuICAgICAgICAgICAgc2hlZXQuaW5zZXJ0UnVsZShzdHlsZVN0ciArICd9JywgcnVsZUNudCArIGkpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vLyBub25jZVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxubGV0IHF1ZXJpZWROb25jZVZhbHVlO1xuZnVuY3Rpb24gZ2V0Tm9uY2VWYWx1ZSgpIHtcbiAgICBpZiAocXVlcmllZE5vbmNlVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBxdWVyaWVkTm9uY2VWYWx1ZSA9IHF1ZXJ5Tm9uY2VWYWx1ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gcXVlcmllZE5vbmNlVmFsdWU7XG59XG4vKlxuVE9ETzogZGlzY291cmFnZSBtZXRhIHRhZyBhbmQgaW5zdGVhZCBwdXQgbm9uY2UgYXR0cmlidXRlIG9uIHBsYWNlaG9sZGVyIDxzdHlsZT4gdGFnXG4qL1xuZnVuY3Rpb24gcXVlcnlOb25jZVZhbHVlKCkge1xuICAgIGNvbnN0IG1ldGFXaXRoTm9uY2UgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9XCJjc3Atbm9uY2VcIl0nKTtcbiAgICBpZiAobWV0YVdpdGhOb25jZSAmJiBtZXRhV2l0aE5vbmNlLmhhc0F0dHJpYnV0ZSgnY29udGVudCcpKSB7XG4gICAgICAgIHJldHVybiBtZXRhV2l0aE5vbmNlLmdldEF0dHJpYnV0ZSgnY29udGVudCcpO1xuICAgIH1cbiAgICBjb25zdCBlbFdpdGhOb25jZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3NjcmlwdFtub25jZV0nKTtcbiAgICBpZiAoZWxXaXRoTm9uY2UpIHtcbiAgICAgICAgcmV0dXJuIGVsV2l0aE5vbmNlLm5vbmNlIHx8ICcnO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG59XG4vLyBtYWluXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJlZ2lzdGVyU3R5bGVzUm9vdChkb2N1bWVudCk7XG59XG5cbnZhciBjc3NfMjQ4eiA9IFwiOnJvb3R7LS1mYy1zbWFsbC1mb250LXNpemU6Ljg1ZW07LS1mYy1wYWdlLWJnLWNvbG9yOiNmZmY7LS1mYy1uZXV0cmFsLWJnLWNvbG9yOmhzbGEoMCwwJSw4MiUsLjMpOy0tZmMtbmV1dHJhbC10ZXh0LWNvbG9yOmdyZXk7LS1mYy1ib3JkZXItY29sb3I6I2RkZDstLWZjLWJ1dHRvbi10ZXh0LWNvbG9yOiNmZmY7LS1mYy1idXR0b24tYmctY29sb3I6IzJjM2U1MDstLWZjLWJ1dHRvbi1ib3JkZXItY29sb3I6IzJjM2U1MDstLWZjLWJ1dHRvbi1ob3Zlci1iZy1jb2xvcjojMWUyYjM3Oy0tZmMtYnV0dG9uLWhvdmVyLWJvcmRlci1jb2xvcjojMWEyNTJmOy0tZmMtYnV0dG9uLWFjdGl2ZS1iZy1jb2xvcjojMWEyNTJmOy0tZmMtYnV0dG9uLWFjdGl2ZS1ib3JkZXItY29sb3I6IzE1MWUyNzstLWZjLWV2ZW50LWJnLWNvbG9yOiMzNzg4ZDg7LS1mYy1ldmVudC1ib3JkZXItY29sb3I6IzM3ODhkODstLWZjLWV2ZW50LXRleHQtY29sb3I6I2ZmZjstLWZjLWV2ZW50LXNlbGVjdGVkLW92ZXJsYXktY29sb3I6cmdiYSgwLDAsMCwuMjUpOy0tZmMtbW9yZS1saW5rLWJnLWNvbG9yOiNkMGQwZDA7LS1mYy1tb3JlLWxpbmstdGV4dC1jb2xvcjppbmhlcml0Oy0tZmMtZXZlbnQtcmVzaXplci10aGlja25lc3M6OHB4Oy0tZmMtZXZlbnQtcmVzaXplci1kb3QtdG90YWwtd2lkdGg6OHB4Oy0tZmMtZXZlbnQtcmVzaXplci1kb3QtYm9yZGVyLXdpZHRoOjFweDstLWZjLW5vbi1idXNpbmVzcy1jb2xvcjpoc2xhKDAsMCUsODQlLC4zKTstLWZjLWJnLWV2ZW50LWNvbG9yOiM4ZmRmODI7LS1mYy1iZy1ldmVudC1vcGFjaXR5OjAuMzstLWZjLWhpZ2hsaWdodC1jb2xvcjpyZ2JhKDE4OCwyMzIsMjQxLC4zKTstLWZjLXRvZGF5LWJnLWNvbG9yOnJnYmEoMjU1LDIyMCw0MCwuMTUpOy0tZmMtbm93LWluZGljYXRvci1jb2xvcjpyZWR9LmZjLW5vdC1hbGxvd2VkLC5mYy1ub3QtYWxsb3dlZCAuZmMtZXZlbnR7Y3Vyc29yOm5vdC1hbGxvd2VkfS5mY3tkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1uO2ZvbnQtc2l6ZToxZW19LmZjLC5mYyAqLC5mYyA6YWZ0ZXIsLmZjIDpiZWZvcmV7Ym94LXNpemluZzpib3JkZXItYm94fS5mYyB0YWJsZXtib3JkZXItY29sbGFwc2U6Y29sbGFwc2U7Ym9yZGVyLXNwYWNpbmc6MDtmb250LXNpemU6MWVtfS5mYyB0aHt0ZXh0LWFsaWduOmNlbnRlcn0uZmMgdGQsLmZjIHRoe3BhZGRpbmc6MDt2ZXJ0aWNhbC1hbGlnbjp0b3B9LmZjIGFbZGF0YS1uYXZsaW5rXXtjdXJzb3I6cG9pbnRlcn0uZmMgYVtkYXRhLW5hdmxpbmtdOmhvdmVye3RleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmV9LmZjLWRpcmVjdGlvbi1sdHJ7ZGlyZWN0aW9uOmx0cjt0ZXh0LWFsaWduOmxlZnR9LmZjLWRpcmVjdGlvbi1ydGx7ZGlyZWN0aW9uOnJ0bDt0ZXh0LWFsaWduOnJpZ2h0fS5mYy10aGVtZS1zdGFuZGFyZCB0ZCwuZmMtdGhlbWUtc3RhbmRhcmQgdGh7Ym9yZGVyOjFweCBzb2xpZCB2YXIoLS1mYy1ib3JkZXItY29sb3IpfS5mYy1saXF1aWQtaGFjayB0ZCwuZmMtbGlxdWlkLWhhY2sgdGh7cG9zaXRpb246cmVsYXRpdmV9QGZvbnQtZmFjZXtmb250LWZhbWlseTpmY2ljb25zO2ZvbnQtc3R5bGU6bm9ybWFsO2ZvbnQtd2VpZ2h0OjQwMDtzcmM6dXJsKFxcXCJkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC10dGY7Y2hhcnNldD11dGYtODtiYXNlNjQsQUFFQUFBQUxBSUFBQXdBd1QxTXZNZzhTQmZBQUFBQzhBQUFBWUdOdFlYQVhWdEtOQUFBQkhBQUFBRlJuWVhOd0FBQUFFQUFBQVhBQUFBQUlaMng1WmdZeWR4SUFBQUY0QUFBRk5HaGxZV1FVSjdjSUFBQUdyQUFBQURab2FHVmhCMjBEekFBQUJ1UUFBQUFrYUcxMGVDSUFCaFFBQUFjSUFBQUFMR3h2WTJFRDRBVTZBQUFITkFBQUFCaHRZWGh3QUE4QWpBQUFCMHdBQUFBZ2JtRnRaWHNyNjkwQUFBZHNBQUFCaG5CdmMzUUFBd0FBQUFBSTlBQUFBQ0FBQXdQQUFaQUFCUUFBQXBrQ3pBQUFBSThDbVFMTUFBQUI2d0F6QVFrQUFBQUFBQUFBQUFBQUFBQUFBQUFCRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJBQUFEcEJnUEEvOEFBUUFQQUFFQUFBQUFCQUFBQUFBQUFBQUFBQUFBZ0FBQUFBQUFEQUFBQUF3QUFBQndBQVFBREFBQUFIQUFEQUFFQUFBQWNBQVFBT0FBQUFBb0FDQUFDQUFJQUFRQWc2UWIvL2YvL0FBQUFBQUFnNlFELy9mLy9BQUgvNHhjRUFBTUFBUUFBQUFBQUFBQUFBQUFBQVFBQi8vOEFEd0FCQUFBQUFBQUFBQUFBQWdBQU56a0JBQUFBQUFFQUFBQUFBQUFBQUFBQ0FBQTNPUUVBQUFBQUFRQUFBQUFBQUFBQUFBSUFBRGM1QVFBQUFBQUJBV0lBalFLZUFza0FFd0FBSlNjM05qUW5KaUlIQVFZVUZ3RVdNamMyTkNjQ251TGlEUTBNSkF6L0FBME5BUUFNSkF3TkRjbmk0Z3dqRFF3TS93QU5Jd3ovQUEwTkRDTU5BQUFBQVFGaUFJMENuZ0xKQUJNQUFDVUJOalFuQVNZaUJ3WVVId0VIQmhRWEZqSTNBWjRCQUEwTi93QU1KQXdORGVMaURRME1KQXlOQVFBTUl3MEJBQXdNRFNNTTR1SU5Jd3dORFFBQUFBSUE0Z0MzQXg0Q25nQVRBQ2NBQUNVbk56WTBKeVlpRHdFR0ZCOEJGakkzTmpRbklTYzNOalFuSmlJUEFRWVVId0VXTWpjMk5DY0I4N2UzRFEwTUl3M1ZEUTNWRFNNTURRMEJLN2UzRFEwTUpBelZEUTNWRENRTURRM3p1TGNNSkF3TkRkVU5Jd3pXREF3Tkl3eTR0d3drREEwTjFRMGpETllNREEwakRBQUFBZ0RpQUxjREhnS2VBQk1BSndBQUpUYzJOQzhCSmlJSEJoUWZBUWNHRkJjV01qY2hOelkwTHdFbUlnY0dGQjhCQndZVUZ4WXlOd0pKMVEwTjFRMGpEQTBOdDdjTkRRd2pEZjdWMVEwTjFRd2tEQTBOdDdjTkRRd2tETGZXRENNTjFRME5EQ1FNdDdnTUl3ME1ETllNSXczVkRRME1KQXkzdUF3akRRd01BQUFEQUZVQUFBT3JBMVVBTXdCb0FIY0FBQk1pQmdjT0FRY09BUWNPQVJVUkZCWVhIZ0VYSGdFWEhnRXpJVEkyTno0Qk56NEJOejRCTlJFMEppY3VBU2N1QVNjdUFTTUZJVElXRng0QkZ4NEJGeDRCRlJFVUJnY09BUWNPQVFjT0FTTWhJaVluTGdFbkxnRW5MZ0UxRVRRMk56NEJOejRCTno0Qk14TWhNalkxTkNZaklTSUdGUlFXTTlVTkdBd0xGUWtKRGdVRkJRVUZCUTRKQ1JVTERCZ05BbFlOR0F3TEZRa0pEZ1VGQlFVRkJRNEpDUlVMREJnTi9hb0NWZ1FJQkFRSEF3TUZBUUlCQVFJQkJRTURCd1FFQ0FUOXFnUUlCQVFIQXdNRkFRSUJBUUlCQlFNREJ3UUVDQVNBQVZZUkdSa1IvcW9SR1JrUkExVUZCQVVPQ1FrVkRBc1pEZjJyRFJrTERCVUpDQTRGQlFVRkJRVU9DUWdWREFzWkRRSlZEUmtMREJVSkNRNEZCQVZWQWdFQ0JRTUNCd1FFQ0FYOXF3UUpBd1FIQXdNRkFRSUNBZ0lCQlFNREJ3UURDUVFDVlFVSUJBUUhBZ01GQWdFQy9vQVpFaEVaR1JFU0dRQUFBQUFEQUZVQUFBT3JBMVVBTXdCb0FJa0FBQk1pQmdjT0FRY09BUWNPQVJVUkZCWVhIZ0VYSGdFWEhnRXpJVEkyTno0Qk56NEJOejRCTlJFMEppY3VBU2N1QVNjdUFTTUZJVElXRng0QkZ4NEJGeDRCRlJFVUJnY09BUWNPQVFjT0FTTWhJaVluTGdFbkxnRW5MZ0UxRVRRMk56NEJOejRCTno0Qk14TXpGUlFXTXpJMlBRRXpNalkxTkNZckFUVTBKaU1pQmgwQkl5SUdGUlFXTTlVTkdBd0xGUWtKRGdVRkJRVUZCUTRKQ1JVTERCZ05BbFlOR0F3TEZRa0pEZ1VGQlFVRkJRNEpDUlVMREJnTi9hb0NWZ1FJQkFRSEF3TUZBUUlCQVFJQkJRTURCd1FFQ0FUOXFnUUlCQVFIQXdNRkFRSUJBUUlCQlFNREJ3UUVDQVNBZ0JrU0VobUFFUmtaRVlBWkVoSVpnQkVaR1JFRFZRVUVCUTRKQ1JVTUN4a04vYXNOR1FzTUZRa0lEZ1VGQlFVRkJRNEpDQlVNQ3hrTkFsVU5HUXNNRlFrSkRnVUVCVlVDQVFJRkF3SUhCQVFJQmYyckJBa0RCQWNEQXdVQkFnSUNBZ0VGQXdNSEJBTUpCQUpWQlFnRUJBY0NBd1VDQVFMK2dJQVNHUmtTZ0JrU0VSbUFFaGtaRW9BWkVSSVpBQUFCQU9JQWpRTWVBc2tBSUFBQUV4Y0hCaFFYRmpJL0FSY1dNamMyTkM4Qk56WTBKeVlpRHdFbkppSUhCaFFYNHVMaURRME1KQXppNGd3a0RBME40dUlORFF3a0RPTGlEQ1FNRFEwQ2plTGlEU01NRFEzaDRRME5EQ01ONHVJTUl3ME1ET0xpREF3Tkl3d0FBQUFCQUFBQUFRQUFhNW4weTE4UFBQVUFDd1FBQUFBQUFOaXZPVnNBQUFBQTJLODVXd0FBQUFBRHF3TlZBQUFBQ0FBQ0FBQUFBQUFBQUFFQUFBUEEvOEFBQUFRQUFBQUFBQU9yQUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFMQkFBQUFBQUFBQUFBQUFBQUFnQUFBQVFBQVdJRUFBRmlCQUFBNGdRQUFPSUVBQUJWQkFBQVZRUUFBT0lBQUFBQUFBb0FGQUFlQUVRQWFnQ3FBT29CbmdKa0Fwb0FBUUFBQUFzQWlnQURBQUFBQUFBQ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBNEFyZ0FCQUFBQUFBQUJBQWNBQUFBQkFBQUFBQUFDQUFjQVlBQUJBQUFBQUFBREFBY0FOZ0FCQUFBQUFBQUVBQWNBZFFBQkFBQUFBQUFGQUFzQUZRQUJBQUFBQUFBR0FBY0FTd0FCQUFBQUFBQUtBQm9BaWdBREFBRUVDUUFCQUE0QUJ3QURBQUVFQ1FBQ0FBNEFad0FEQUFFRUNRQURBQTRBUFFBREFBRUVDUUFFQUE0QWZBQURBQUVFQ1FBRkFCWUFJQUFEQUFFRUNRQUdBQTRBVWdBREFBRUVDUUFLQURRQXBHWmphV052Ym5NQVpnQmpBR2tBWXdCdkFHNEFjMVpsY25OcGIyNGdNUzR3QUZZQVpRQnlBSE1BYVFCdkFHNEFJQUF4QUM0QU1HWmphV052Ym5NQVpnQmpBR2tBWXdCdkFHNEFjMlpqYVdOdmJuTUFaZ0JqQUdrQVl3QnZBRzRBYzFKbFozVnNZWElBVWdCbEFHY0FkUUJzQUdFQWNtWmphV052Ym5NQVpnQmpBR2tBWXdCdkFHNEFjMFp2Ym5RZ1oyVnVaWEpoZEdWa0lHSjVJRWxqYjAxdmIyNHVBRVlBYndCdUFIUUFJQUJuQUdVQWJnQmxBSElBWVFCMEFHVUFaQUFnQUdJQWVRQWdBRWtBWXdCdkFFMEFid0J2QUc0QUxnQUFBQU1BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBPVxcXCIpIGZvcm1hdChcXFwidHJ1ZXR5cGVcXFwiKX0uZmMtaWNvbntzcGVhazpub25lOy13ZWJraXQtZm9udC1zbW9vdGhpbmc6YW50aWFsaWFzZWQ7LW1vei1vc3gtZm9udC1zbW9vdGhpbmc6Z3JheXNjYWxlO2Rpc3BsYXk6aW5saW5lLWJsb2NrO2ZvbnQtZmFtaWx5OmZjaWNvbnMhaW1wb3J0YW50O2ZvbnQtc3R5bGU6bm9ybWFsO2ZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6NDAwO2hlaWdodDoxZW07bGluZS1oZWlnaHQ6MTt0ZXh0LWFsaWduOmNlbnRlcjt0ZXh0LXRyYW5zZm9ybTpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lO3dpZHRoOjFlbX0uZmMtaWNvbi1jaGV2cm9uLWxlZnQ6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxlOTAwXFxcIn0uZmMtaWNvbi1jaGV2cm9uLXJpZ2h0OmJlZm9yZXtjb250ZW50OlxcXCJcXFxcZTkwMVxcXCJ9LmZjLWljb24tY2hldnJvbnMtbGVmdDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXGU5MDJcXFwifS5mYy1pY29uLWNoZXZyb25zLXJpZ2h0OmJlZm9yZXtjb250ZW50OlxcXCJcXFxcZTkwM1xcXCJ9LmZjLWljb24tbWludXMtc3F1YXJlOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcZTkwNFxcXCJ9LmZjLWljb24tcGx1cy1zcXVhcmU6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxlOTA1XFxcIn0uZmMtaWNvbi14OmJlZm9yZXtjb250ZW50OlxcXCJcXFxcZTkwNlxcXCJ9LmZjIC5mYy1idXR0b257Ym9yZGVyLXJhZGl1czowO2ZvbnQtZmFtaWx5OmluaGVyaXQ7Zm9udC1zaXplOmluaGVyaXQ7bGluZS1oZWlnaHQ6aW5oZXJpdDttYXJnaW46MDtvdmVyZmxvdzp2aXNpYmxlO3RleHQtdHJhbnNmb3JtOm5vbmV9LmZjIC5mYy1idXR0b246Zm9jdXN7b3V0bGluZToxcHggZG90dGVkO291dGxpbmU6NXB4IGF1dG8gLXdlYmtpdC1mb2N1cy1yaW5nLWNvbG9yfS5mYyAuZmMtYnV0dG9uey13ZWJraXQtYXBwZWFyYW5jZTpidXR0b259LmZjIC5mYy1idXR0b246bm90KDpkaXNhYmxlZCl7Y3Vyc29yOnBvaW50ZXJ9LmZjIC5mYy1idXR0b257YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudDtib3JkZXI6MXB4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1yYWRpdXM6LjI1ZW07ZGlzcGxheTppbmxpbmUtYmxvY2s7Zm9udC1zaXplOjFlbTtmb250LXdlaWdodDo0MDA7bGluZS1oZWlnaHQ6MS41O3BhZGRpbmc6LjRlbSAuNjVlbTt0ZXh0LWFsaWduOmNlbnRlcjstbW96LXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZTt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9LmZjIC5mYy1idXR0b246aG92ZXJ7dGV4dC1kZWNvcmF0aW9uOm5vbmV9LmZjIC5mYy1idXR0b246Zm9jdXN7Ym94LXNoYWRvdzowIDAgMCAuMnJlbSByZ2JhKDQ0LDYyLDgwLC4yNSk7b3V0bGluZTowfS5mYyAuZmMtYnV0dG9uOmRpc2FibGVke29wYWNpdHk6LjY1fS5mYyAuZmMtYnV0dG9uLXByaW1hcnl7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1mYy1idXR0b24tYmctY29sb3IpO2JvcmRlci1jb2xvcjp2YXIoLS1mYy1idXR0b24tYm9yZGVyLWNvbG9yKTtjb2xvcjp2YXIoLS1mYy1idXR0b24tdGV4dC1jb2xvcil9LmZjIC5mYy1idXR0b24tcHJpbWFyeTpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWZjLWJ1dHRvbi1ob3Zlci1iZy1jb2xvcik7Ym9yZGVyLWNvbG9yOnZhcigtLWZjLWJ1dHRvbi1ob3Zlci1ib3JkZXItY29sb3IpO2NvbG9yOnZhcigtLWZjLWJ1dHRvbi10ZXh0LWNvbG9yKX0uZmMgLmZjLWJ1dHRvbi1wcmltYXJ5OmRpc2FibGVke2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmMtYnV0dG9uLWJnLWNvbG9yKTtib3JkZXItY29sb3I6dmFyKC0tZmMtYnV0dG9uLWJvcmRlci1jb2xvcik7Y29sb3I6dmFyKC0tZmMtYnV0dG9uLXRleHQtY29sb3IpfS5mYyAuZmMtYnV0dG9uLXByaW1hcnk6Zm9jdXN7Ym94LXNoYWRvdzowIDAgMCAuMnJlbSByZ2JhKDc2LDkxLDEwNiwuNSl9LmZjIC5mYy1idXR0b24tcHJpbWFyeTpub3QoOmRpc2FibGVkKS5mYy1idXR0b24tYWN0aXZlLC5mYyAuZmMtYnV0dG9uLXByaW1hcnk6bm90KDpkaXNhYmxlZCk6YWN0aXZle2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmMtYnV0dG9uLWFjdGl2ZS1iZy1jb2xvcik7Ym9yZGVyLWNvbG9yOnZhcigtLWZjLWJ1dHRvbi1hY3RpdmUtYm9yZGVyLWNvbG9yKTtjb2xvcjp2YXIoLS1mYy1idXR0b24tdGV4dC1jb2xvcil9LmZjIC5mYy1idXR0b24tcHJpbWFyeTpub3QoOmRpc2FibGVkKS5mYy1idXR0b24tYWN0aXZlOmZvY3VzLC5mYyAuZmMtYnV0dG9uLXByaW1hcnk6bm90KDpkaXNhYmxlZCk6YWN0aXZlOmZvY3Vze2JveC1zaGFkb3c6MCAwIDAgLjJyZW0gcmdiYSg3Niw5MSwxMDYsLjUpfS5mYyAuZmMtYnV0dG9uIC5mYy1pY29ue2ZvbnQtc2l6ZToxLjVlbTt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9LmZjIC5mYy1idXR0b24tZ3JvdXB7ZGlzcGxheTppbmxpbmUtZmxleDtwb3NpdGlvbjpyZWxhdGl2ZTt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9LmZjIC5mYy1idXR0b24tZ3JvdXA+LmZjLWJ1dHRvbntmbGV4OjEgMSBhdXRvO3Bvc2l0aW9uOnJlbGF0aXZlfS5mYyAuZmMtYnV0dG9uLWdyb3VwPi5mYy1idXR0b24uZmMtYnV0dG9uLWFjdGl2ZSwuZmMgLmZjLWJ1dHRvbi1ncm91cD4uZmMtYnV0dG9uOmFjdGl2ZSwuZmMgLmZjLWJ1dHRvbi1ncm91cD4uZmMtYnV0dG9uOmZvY3VzLC5mYyAuZmMtYnV0dG9uLWdyb3VwPi5mYy1idXR0b246aG92ZXJ7ei1pbmRleDoxfS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1idXR0b24tZ3JvdXA+LmZjLWJ1dHRvbjpub3QoOmZpcnN0LWNoaWxkKXtib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOjA7Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czowO21hcmdpbi1sZWZ0Oi0xcHh9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLWJ1dHRvbi1ncm91cD4uZmMtYnV0dG9uOm5vdCg6bGFzdC1jaGlsZCl7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6MDtib3JkZXItdG9wLXJpZ2h0LXJhZGl1czowfS5mYy1kaXJlY3Rpb24tcnRsIC5mYy1idXR0b24tZ3JvdXA+LmZjLWJ1dHRvbjpub3QoOmZpcnN0LWNoaWxkKXtib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czowO2JvcmRlci10b3AtcmlnaHQtcmFkaXVzOjA7bWFyZ2luLXJpZ2h0Oi0xcHh9LmZjLWRpcmVjdGlvbi1ydGwgLmZjLWJ1dHRvbi1ncm91cD4uZmMtYnV0dG9uOm5vdCg6bGFzdC1jaGlsZCl7Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czowO2JvcmRlci10b3AtbGVmdC1yYWRpdXM6MH0uZmMgLmZjLXRvb2xiYXJ7YWxpZ24taXRlbXM6Y2VudGVyO2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2Vlbn0uZmMgLmZjLXRvb2xiYXIuZmMtaGVhZGVyLXRvb2xiYXJ7bWFyZ2luLWJvdHRvbToxLjVlbX0uZmMgLmZjLXRvb2xiYXIuZmMtZm9vdGVyLXRvb2xiYXJ7bWFyZ2luLXRvcDoxLjVlbX0uZmMgLmZjLXRvb2xiYXItdGl0bGV7Zm9udC1zaXplOjEuNzVlbTttYXJnaW46MH0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtdG9vbGJhcj4qPjpub3QoOmZpcnN0LWNoaWxkKXttYXJnaW4tbGVmdDouNzVlbX0uZmMtZGlyZWN0aW9uLXJ0bCAuZmMtdG9vbGJhcj4qPjpub3QoOmZpcnN0LWNoaWxkKXttYXJnaW4tcmlnaHQ6Ljc1ZW19LmZjLWRpcmVjdGlvbi1ydGwgLmZjLXRvb2xiYXItbHRye2ZsZXgtZGlyZWN0aW9uOnJvdy1yZXZlcnNlfS5mYyAuZmMtc2Nyb2xsZXJ7LXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6dG91Y2g7cG9zaXRpb246cmVsYXRpdmV9LmZjIC5mYy1zY3JvbGxlci1saXF1aWR7aGVpZ2h0OjEwMCV9LmZjIC5mYy1zY3JvbGxlci1saXF1aWQtYWJzb2x1dGV7Ym90dG9tOjA7bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7dG9wOjB9LmZjIC5mYy1zY3JvbGxlci1oYXJuZXNze2RpcmVjdGlvbjpsdHI7b3ZlcmZsb3c6aGlkZGVuO3Bvc2l0aW9uOnJlbGF0aXZlfS5mYyAuZmMtc2Nyb2xsZXItaGFybmVzcy1saXF1aWR7aGVpZ2h0OjEwMCV9LmZjLWRpcmVjdGlvbi1ydGwgLmZjLXNjcm9sbGVyLWhhcm5lc3M+LmZjLXNjcm9sbGVye2RpcmVjdGlvbjpydGx9LmZjLXRoZW1lLXN0YW5kYXJkIC5mYy1zY3JvbGxncmlke2JvcmRlcjoxcHggc29saWQgdmFyKC0tZmMtYm9yZGVyLWNvbG9yKX0uZmMgLmZjLXNjcm9sbGdyaWQsLmZjIC5mYy1zY3JvbGxncmlkIHRhYmxle3RhYmxlLWxheW91dDpmaXhlZDt3aWR0aDoxMDAlfS5mYyAuZmMtc2Nyb2xsZ3JpZCB0YWJsZXtib3JkZXItbGVmdC1zdHlsZTpoaWRkZW47Ym9yZGVyLXJpZ2h0LXN0eWxlOmhpZGRlbjtib3JkZXItdG9wLXN0eWxlOmhpZGRlbn0uZmMgLmZjLXNjcm9sbGdyaWR7Ym9yZGVyLWJvdHRvbS13aWR0aDowO2JvcmRlci1jb2xsYXBzZTpzZXBhcmF0ZTtib3JkZXItcmlnaHQtd2lkdGg6MH0uZmMgLmZjLXNjcm9sbGdyaWQtbGlxdWlke2hlaWdodDoxMDAlfS5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLC5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uIHRhYmxlLC5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uPnRke2hlaWdodDoxcHh9LmZjIC5mYy1zY3JvbGxncmlkLXNlY3Rpb24tbGlxdWlkPnRke2hlaWdodDoxMDAlfS5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uPip7Ym9yZGVyLWxlZnQtd2lkdGg6MDtib3JkZXItdG9wLXdpZHRoOjB9LmZjIC5mYy1zY3JvbGxncmlkLXNlY3Rpb24tZm9vdGVyPiosLmZjIC5mYy1zY3JvbGxncmlkLXNlY3Rpb24taGVhZGVyPip7Ym9yZGVyLWJvdHRvbS13aWR0aDowfS5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLWJvZHkgdGFibGUsLmZjIC5mYy1zY3JvbGxncmlkLXNlY3Rpb24tZm9vdGVyIHRhYmxle2JvcmRlci1ib3R0b20tc3R5bGU6aGlkZGVufS5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLXN0aWNreT4qe2JhY2tncm91bmQ6dmFyKC0tZmMtcGFnZS1iZy1jb2xvcik7cG9zaXRpb246c3RpY2t5O3otaW5kZXg6M30uZmMgLmZjLXNjcm9sbGdyaWQtc2VjdGlvbi1oZWFkZXIuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLXN0aWNreT4qe3RvcDowfS5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLWZvb3Rlci5mYy1zY3JvbGxncmlkLXNlY3Rpb24tc3RpY2t5Pip7Ym90dG9tOjB9LmZjIC5mYy1zY3JvbGxncmlkLXN0aWNreS1zaGlte2hlaWdodDoxcHg7bWFyZ2luLWJvdHRvbTotMXB4fS5mYy1zdGlja3l7cG9zaXRpb246c3RpY2t5fS5mYyAuZmMtdmlldy1oYXJuZXNze2ZsZXgtZ3JvdzoxO3Bvc2l0aW9uOnJlbGF0aXZlfS5mYyAuZmMtdmlldy1oYXJuZXNzLWFjdGl2ZT4uZmMtdmlld3tib3R0b206MDtsZWZ0OjA7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MDt0b3A6MH0uZmMgLmZjLWNvbC1oZWFkZXItY2VsbC1jdXNoaW9ue2Rpc3BsYXk6aW5saW5lLWJsb2NrO3BhZGRpbmc6MnB4IDRweH0uZmMgLmZjLWJnLWV2ZW50LC5mYyAuZmMtaGlnaGxpZ2h0LC5mYyAuZmMtbm9uLWJ1c2luZXNze2JvdHRvbTowO2xlZnQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO3RvcDowfS5mYyAuZmMtbm9uLWJ1c2luZXNze2JhY2tncm91bmQ6dmFyKC0tZmMtbm9uLWJ1c2luZXNzLWNvbG9yKX0uZmMgLmZjLWJnLWV2ZW50e2JhY2tncm91bmQ6dmFyKC0tZmMtYmctZXZlbnQtY29sb3IpO29wYWNpdHk6dmFyKC0tZmMtYmctZXZlbnQtb3BhY2l0eSl9LmZjIC5mYy1iZy1ldmVudCAuZmMtZXZlbnQtdGl0bGV7Zm9udC1zaXplOnZhcigtLWZjLXNtYWxsLWZvbnQtc2l6ZSk7Zm9udC1zdHlsZTppdGFsaWM7bWFyZ2luOi41ZW19LmZjIC5mYy1oaWdobGlnaHR7YmFja2dyb3VuZDp2YXIoLS1mYy1oaWdobGlnaHQtY29sb3IpfS5mYyAuZmMtY2VsbC1zaGFkZWQsLmZjIC5mYy1kYXktZGlzYWJsZWR7YmFja2dyb3VuZDp2YXIoLS1mYy1uZXV0cmFsLWJnLWNvbG9yKX1hLmZjLWV2ZW50LGEuZmMtZXZlbnQ6aG92ZXJ7dGV4dC1kZWNvcmF0aW9uOm5vbmV9LmZjLWV2ZW50LmZjLWV2ZW50LWRyYWdnYWJsZSwuZmMtZXZlbnRbaHJlZl17Y3Vyc29yOnBvaW50ZXJ9LmZjLWV2ZW50IC5mYy1ldmVudC1tYWlue3Bvc2l0aW9uOnJlbGF0aXZlO3otaW5kZXg6Mn0uZmMtZXZlbnQtZHJhZ2dpbmc6bm90KC5mYy1ldmVudC1zZWxlY3RlZCl7b3BhY2l0eTouNzV9LmZjLWV2ZW50LWRyYWdnaW5nLmZjLWV2ZW50LXNlbGVjdGVke2JveC1zaGFkb3c6MCAycHggN3B4IHJnYmEoMCwwLDAsLjMpfS5mYy1ldmVudCAuZmMtZXZlbnQtcmVzaXplcntkaXNwbGF5Om5vbmU7cG9zaXRpb246YWJzb2x1dGU7ei1pbmRleDo0fS5mYy1ldmVudC1zZWxlY3RlZCAuZmMtZXZlbnQtcmVzaXplciwuZmMtZXZlbnQ6aG92ZXIgLmZjLWV2ZW50LXJlc2l6ZXJ7ZGlzcGxheTpibG9ja30uZmMtZXZlbnQtc2VsZWN0ZWQgLmZjLWV2ZW50LXJlc2l6ZXJ7YmFja2dyb3VuZDp2YXIoLS1mYy1wYWdlLWJnLWNvbG9yKTtib3JkZXItY29sb3I6aW5oZXJpdDtib3JkZXItcmFkaXVzOmNhbGModmFyKC0tZmMtZXZlbnQtcmVzaXplci1kb3QtdG90YWwtd2lkdGgpLzIpO2JvcmRlci1zdHlsZTpzb2xpZDtib3JkZXItd2lkdGg6dmFyKC0tZmMtZXZlbnQtcmVzaXplci1kb3QtYm9yZGVyLXdpZHRoKTtoZWlnaHQ6dmFyKC0tZmMtZXZlbnQtcmVzaXplci1kb3QtdG90YWwtd2lkdGgpO3dpZHRoOnZhcigtLWZjLWV2ZW50LXJlc2l6ZXItZG90LXRvdGFsLXdpZHRoKX0uZmMtZXZlbnQtc2VsZWN0ZWQgLmZjLWV2ZW50LXJlc2l6ZXI6YmVmb3Jle2JvdHRvbTotMjBweDtjb250ZW50OlxcXCJcXFwiO2xlZnQ6LTIwcHg7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6LTIwcHg7dG9wOi0yMHB4fS5mYy1ldmVudC1zZWxlY3RlZCwuZmMtZXZlbnQ6Zm9jdXN7Ym94LXNoYWRvdzowIDJweCA1cHggcmdiYSgwLDAsMCwuMil9LmZjLWV2ZW50LXNlbGVjdGVkOmJlZm9yZSwuZmMtZXZlbnQ6Zm9jdXM6YmVmb3Jle2JvdHRvbTowO2NvbnRlbnQ6XFxcIlxcXCI7bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7dG9wOjA7ei1pbmRleDozfS5mYy1ldmVudC1zZWxlY3RlZDphZnRlciwuZmMtZXZlbnQ6Zm9jdXM6YWZ0ZXJ7YmFja2dyb3VuZDp2YXIoLS1mYy1ldmVudC1zZWxlY3RlZC1vdmVybGF5LWNvbG9yKTtib3R0b206LTFweDtjb250ZW50OlxcXCJcXFwiO2xlZnQ6LTFweDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDotMXB4O3RvcDotMXB4O3otaW5kZXg6MX0uZmMtaC1ldmVudHtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWZjLWV2ZW50LWJnLWNvbG9yKTtib3JkZXI6MXB4IHNvbGlkIHZhcigtLWZjLWV2ZW50LWJvcmRlci1jb2xvcik7ZGlzcGxheTpibG9ja30uZmMtaC1ldmVudCAuZmMtZXZlbnQtbWFpbntjb2xvcjp2YXIoLS1mYy1ldmVudC10ZXh0LWNvbG9yKX0uZmMtaC1ldmVudCAuZmMtZXZlbnQtbWFpbi1mcmFtZXtkaXNwbGF5OmZsZXh9LmZjLWgtZXZlbnQgLmZjLWV2ZW50LXRpbWV7bWF4LXdpZHRoOjEwMCU7b3ZlcmZsb3c6aGlkZGVufS5mYy1oLWV2ZW50IC5mYy1ldmVudC10aXRsZS1jb250YWluZXJ7ZmxleC1ncm93OjE7ZmxleC1zaHJpbms6MTttaW4td2lkdGg6MH0uZmMtaC1ldmVudCAuZmMtZXZlbnQtdGl0bGV7ZGlzcGxheTppbmxpbmUtYmxvY2s7bGVmdDowO21heC13aWR0aDoxMDAlO292ZXJmbG93OmhpZGRlbjtyaWdodDowO3ZlcnRpY2FsLWFsaWduOnRvcH0uZmMtaC1ldmVudC5mYy1ldmVudC1zZWxlY3RlZDpiZWZvcmV7Ym90dG9tOi0xMHB4O3RvcDotMTBweH0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtZGF5Z3JpZC1ibG9jay1ldmVudDpub3QoLmZjLWV2ZW50LXN0YXJ0KSwuZmMtZGlyZWN0aW9uLXJ0bCAuZmMtZGF5Z3JpZC1ibG9jay1ldmVudDpub3QoLmZjLWV2ZW50LWVuZCl7Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czowO2JvcmRlci1sZWZ0LXdpZHRoOjA7Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czowfS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1kYXlncmlkLWJsb2NrLWV2ZW50Om5vdCguZmMtZXZlbnQtZW5kKSwuZmMtZGlyZWN0aW9uLXJ0bCAuZmMtZGF5Z3JpZC1ibG9jay1ldmVudDpub3QoLmZjLWV2ZW50LXN0YXJ0KXtib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czowO2JvcmRlci1yaWdodC13aWR0aDowO2JvcmRlci10b3AtcmlnaHQtcmFkaXVzOjB9LmZjLWgtZXZlbnQ6bm90KC5mYy1ldmVudC1zZWxlY3RlZCkgLmZjLWV2ZW50LXJlc2l6ZXJ7Ym90dG9tOjA7dG9wOjA7d2lkdGg6dmFyKC0tZmMtZXZlbnQtcmVzaXplci10aGlja25lc3MpfS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1oLWV2ZW50Om5vdCguZmMtZXZlbnQtc2VsZWN0ZWQpIC5mYy1ldmVudC1yZXNpemVyLXN0YXJ0LC5mYy1kaXJlY3Rpb24tcnRsIC5mYy1oLWV2ZW50Om5vdCguZmMtZXZlbnQtc2VsZWN0ZWQpIC5mYy1ldmVudC1yZXNpemVyLWVuZHtjdXJzb3I6dy1yZXNpemU7bGVmdDpjYWxjKHZhcigtLWZjLWV2ZW50LXJlc2l6ZXItdGhpY2tuZXNzKSotLjUpfS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1oLWV2ZW50Om5vdCguZmMtZXZlbnQtc2VsZWN0ZWQpIC5mYy1ldmVudC1yZXNpemVyLWVuZCwuZmMtZGlyZWN0aW9uLXJ0bCAuZmMtaC1ldmVudDpub3QoLmZjLWV2ZW50LXNlbGVjdGVkKSAuZmMtZXZlbnQtcmVzaXplci1zdGFydHtjdXJzb3I6ZS1yZXNpemU7cmlnaHQ6Y2FsYyh2YXIoLS1mYy1ldmVudC1yZXNpemVyLXRoaWNrbmVzcykqLS41KX0uZmMtaC1ldmVudC5mYy1ldmVudC1zZWxlY3RlZCAuZmMtZXZlbnQtcmVzaXplcnttYXJnaW4tdG9wOmNhbGModmFyKC0tZmMtZXZlbnQtcmVzaXplci1kb3QtdG90YWwtd2lkdGgpKi0uNSk7dG9wOjUwJX0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtaC1ldmVudC5mYy1ldmVudC1zZWxlY3RlZCAuZmMtZXZlbnQtcmVzaXplci1zdGFydCwuZmMtZGlyZWN0aW9uLXJ0bCAuZmMtaC1ldmVudC5mYy1ldmVudC1zZWxlY3RlZCAuZmMtZXZlbnQtcmVzaXplci1lbmR7bGVmdDpjYWxjKHZhcigtLWZjLWV2ZW50LXJlc2l6ZXItZG90LXRvdGFsLXdpZHRoKSotLjUpfS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1oLWV2ZW50LmZjLWV2ZW50LXNlbGVjdGVkIC5mYy1ldmVudC1yZXNpemVyLWVuZCwuZmMtZGlyZWN0aW9uLXJ0bCAuZmMtaC1ldmVudC5mYy1ldmVudC1zZWxlY3RlZCAuZmMtZXZlbnQtcmVzaXplci1zdGFydHtyaWdodDpjYWxjKHZhcigtLWZjLWV2ZW50LXJlc2l6ZXItZG90LXRvdGFsLXdpZHRoKSotLjUpfS5mYyAuZmMtcG9wb3Zlcntib3gtc2hhZG93OjAgMnB4IDZweCByZ2JhKDAsMCwwLC4xNSk7cG9zaXRpb246YWJzb2x1dGU7ei1pbmRleDo5OTk5fS5mYyAuZmMtcG9wb3Zlci1oZWFkZXJ7YWxpZ24taXRlbXM6Y2VudGVyO2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpyb3c7anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW47cGFkZGluZzozcHggNHB4fS5mYyAuZmMtcG9wb3Zlci10aXRsZXttYXJnaW46MCAycHh9LmZjIC5mYy1wb3BvdmVyLWNsb3Nle2N1cnNvcjpwb2ludGVyO2ZvbnQtc2l6ZToxLjFlbTtvcGFjaXR5Oi42NX0uZmMtdGhlbWUtc3RhbmRhcmQgLmZjLXBvcG92ZXJ7YmFja2dyb3VuZDp2YXIoLS1mYy1wYWdlLWJnLWNvbG9yKTtib3JkZXI6MXB4IHNvbGlkIHZhcigtLWZjLWJvcmRlci1jb2xvcil9LmZjLXRoZW1lLXN0YW5kYXJkIC5mYy1wb3BvdmVyLWhlYWRlcntiYWNrZ3JvdW5kOnZhcigtLWZjLW5ldXRyYWwtYmctY29sb3IpfVwiO1xuaW5qZWN0U3R5bGVzKGNzc18yNDh6KTtcblxuY2xhc3MgRGVsYXllZFJ1bm5lciB7XG4gICAgY29uc3RydWN0b3IoZHJhaW5lZE9wdGlvbikge1xuICAgICAgICB0aGlzLmRyYWluZWRPcHRpb24gPSBkcmFpbmVkT3B0aW9uO1xuICAgICAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzRGlydHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wYXVzZURlcHRocyA9IHt9O1xuICAgICAgICB0aGlzLnRpbWVvdXRJZCA9IDA7XG4gICAgfVxuICAgIHJlcXVlc3QoZGVsYXkpIHtcbiAgICAgICAgdGhpcy5pc0RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLmlzUGF1c2VkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJUaW1lb3V0KCk7XG4gICAgICAgICAgICBpZiAoZGVsYXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJ5RHJhaW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudGltZW91dElkID0gc2V0VGltZW91dCgvLyBOT1QgT1BUSU1BTCEgVE9ETzogbG9vayBhdCBkZWJvdW5jZVxuICAgICAgICAgICAgICAgIHRoaXMudHJ5RHJhaW4uYmluZCh0aGlzKSwgZGVsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHBhdXNlKHNjb3BlID0gJycpIHtcbiAgICAgICAgbGV0IHsgcGF1c2VEZXB0aHMgfSA9IHRoaXM7XG4gICAgICAgIHBhdXNlRGVwdGhzW3Njb3BlXSA9IChwYXVzZURlcHRoc1tzY29wZV0gfHwgMCkgKyAxO1xuICAgICAgICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICAgIH1cbiAgICByZXN1bWUoc2NvcGUgPSAnJywgZm9yY2UpIHtcbiAgICAgICAgbGV0IHsgcGF1c2VEZXB0aHMgfSA9IHRoaXM7XG4gICAgICAgIGlmIChzY29wZSBpbiBwYXVzZURlcHRocykge1xuICAgICAgICAgICAgaWYgKGZvcmNlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHBhdXNlRGVwdGhzW3Njb3BlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhdXNlRGVwdGhzW3Njb3BlXSAtPSAxO1xuICAgICAgICAgICAgICAgIGxldCBkZXB0aCA9IHBhdXNlRGVwdGhzW3Njb3BlXTtcbiAgICAgICAgICAgICAgICBpZiAoZGVwdGggPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcGF1c2VEZXB0aHNbc2NvcGVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHJ5RHJhaW4oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc1BhdXNlZCgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMucGF1c2VEZXB0aHMpLmxlbmd0aDtcbiAgICB9XG4gICAgdHJ5RHJhaW4oKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1J1bm5pbmcgJiYgIXRoaXMuaXNQYXVzZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuaXNEaXJ0eSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNEaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhaW5lZCgpOyAvLyBtaWdodCBzZXQgaXNEaXJ0eSB0byB0cnVlIGFnYWluXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICAgICAgICB0aGlzLmlzRGlydHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wYXVzZURlcHRocyA9IHt9O1xuICAgIH1cbiAgICBjbGVhclRpbWVvdXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVvdXRJZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dElkKTtcbiAgICAgICAgICAgIHRoaXMudGltZW91dElkID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkcmFpbmVkKCkge1xuICAgICAgICBpZiAodGhpcy5kcmFpbmVkT3B0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWluZWRPcHRpb24oKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlRWxlbWVudChlbCkge1xuICAgIGlmIChlbC5wYXJlbnROb2RlKSB7XG4gICAgICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgIH1cbn1cbi8vIFF1ZXJ5aW5nXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBlbGVtZW50Q2xvc2VzdChlbCwgc2VsZWN0b3IpIHtcbiAgICBpZiAoZWwuY2xvc2VzdCkge1xuICAgICAgICByZXR1cm4gZWwuY2xvc2VzdChzZWxlY3Rvcik7XG4gICAgICAgIC8vIHJlYWxseSBiYWQgZmFsbGJhY2sgZm9yIElFXG4gICAgICAgIC8vIGZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvY2xvc2VzdFxuICAgIH1cbiAgICBpZiAoIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyhlbCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGRvIHtcbiAgICAgICAgaWYgKGVsZW1lbnRNYXRjaGVzKGVsLCBzZWxlY3RvcikpIHtcbiAgICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgfVxuICAgICAgICBlbCA9IChlbC5wYXJlbnRFbGVtZW50IHx8IGVsLnBhcmVudE5vZGUpO1xuICAgIH0gd2hpbGUgKGVsICE9PSBudWxsICYmIGVsLm5vZGVUeXBlID09PSAxKTtcbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVzKGVsLCBzZWxlY3Rvcikge1xuICAgIGxldCBtZXRob2QgPSBlbC5tYXRjaGVzIHx8IGVsLm1hdGNoZXNTZWxlY3RvciB8fCBlbC5tc01hdGNoZXNTZWxlY3RvcjtcbiAgICByZXR1cm4gbWV0aG9kLmNhbGwoZWwsIHNlbGVjdG9yKTtcbn1cbi8vIGFjY2VwdHMgbXVsdGlwbGUgc3ViamVjdCBlbHNcbi8vIHJldHVybnMgYSByZWFsIGFycmF5LiBnb29kIGZvciBtZXRob2RzIGxpa2UgZm9yRWFjaFxuLy8gVE9ETzogYWNjZXB0IHRoZSBkb2N1bWVudFxuZnVuY3Rpb24gZmluZEVsZW1lbnRzKGNvbnRhaW5lciwgc2VsZWN0b3IpIHtcbiAgICBsZXQgY29udGFpbmVycyA9IGNvbnRhaW5lciBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ID8gW2NvbnRhaW5lcl0gOiBjb250YWluZXI7XG4gICAgbGV0IGFsbE1hdGNoZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRhaW5lcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgbGV0IG1hdGNoZXMgPSBjb250YWluZXJzW2ldLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1hdGNoZXMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgIGFsbE1hdGNoZXMucHVzaChtYXRjaGVzW2pdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYWxsTWF0Y2hlcztcbn1cbi8vIGFjY2VwdHMgbXVsdGlwbGUgc3ViamVjdCBlbHNcbi8vIG9ubHkgcXVlcmllcyBkaXJlY3QgY2hpbGQgZWxlbWVudHMgLy8gVE9ETzogcmVuYW1lIHRvIGZpbmREaXJlY3RDaGlsZHJlbiFcbmZ1bmN0aW9uIGZpbmREaXJlY3RDaGlsZHJlbihwYXJlbnQsIHNlbGVjdG9yKSB7XG4gICAgbGV0IHBhcmVudHMgPSBwYXJlbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCA/IFtwYXJlbnRdIDogcGFyZW50O1xuICAgIGxldCBhbGxNYXRjaGVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJlbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGxldCBjaGlsZE5vZGVzID0gcGFyZW50c1tpXS5jaGlsZHJlbjsgLy8gb25seSBldmVyIGVsZW1lbnRzXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2hpbGROb2Rlcy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgbGV0IGNoaWxkTm9kZSA9IGNoaWxkTm9kZXNbal07XG4gICAgICAgICAgICBpZiAoIXNlbGVjdG9yIHx8IGVsZW1lbnRNYXRjaGVzKGNoaWxkTm9kZSwgc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgYWxsTWF0Y2hlcy5wdXNoKGNoaWxkTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFsbE1hdGNoZXM7XG59XG4vLyBTdHlsZVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuY29uc3QgUElYRUxfUFJPUF9SRSA9IC8odG9wfGxlZnR8cmlnaHR8Ym90dG9tfHdpZHRofGhlaWdodCkkL2k7XG5mdW5jdGlvbiBhcHBseVN0eWxlKGVsLCBwcm9wcykge1xuICAgIGZvciAobGV0IHByb3BOYW1lIGluIHByb3BzKSB7XG4gICAgICAgIGFwcGx5U3R5bGVQcm9wKGVsLCBwcm9wTmFtZSwgcHJvcHNbcHJvcE5hbWVdKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBseVN0eWxlUHJvcChlbCwgbmFtZSwgdmFsKSB7XG4gICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgIGVsLnN0eWxlW25hbWVdID0gJyc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmIFBJWEVMX1BST1BfUkUudGVzdChuYW1lKSkge1xuICAgICAgICBlbC5zdHlsZVtuYW1lXSA9IGAke3ZhbH1weGA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlbC5zdHlsZVtuYW1lXSA9IHZhbDtcbiAgICB9XG59XG4vLyBFdmVudCBIYW5kbGluZ1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gaWYgaW50ZXJjZXB0aW5nIGJ1YmJsZWQgZXZlbnRzIGF0IHRoZSBkb2N1bWVudC93aW5kb3cvYm9keSBsZXZlbCxcbi8vIGFuZCB3YW50IHRvIHNlZSBvcmlnaW5hdGluZyBlbGVtZW50ICh0aGUgJ3RhcmdldCcpLCB1c2UgdGhpcyB1dGlsIGluc3RlYWRcbi8vIG9mIGBldi50YXJnZXRgIGJlY2F1c2UgaXQgZ29lcyB3aXRoaW4gd2ViLWNvbXBvbmVudCBib3VuZGFyaWVzLlxuZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXRWaWFSb290KGV2KSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gZXYuY29tcG9zZWRQYXRoKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChldilbMF0pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGV2LnRhcmdldDtcbn1cbi8vIFVuaXF1ZSBJRCBmb3IgRE9NIGF0dHJpYnV0ZVxubGV0IGd1aWQkMSA9IDA7XG5mdW5jdGlvbiBnZXRVbmlxdWVEb21JZCgpIHtcbiAgICBndWlkJDEgKz0gMTtcbiAgICByZXR1cm4gJ2ZjLWRvbS0nICsgZ3VpZCQxO1xufVxuXG4vLyBTdG9wcyBhIG1vdXNlL3RvdWNoIGV2ZW50IGZyb20gZG9pbmcgaXQncyBuYXRpdmUgYnJvd3NlciBhY3Rpb25cbmZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGV2KSB7XG4gICAgZXYucHJldmVudERlZmF1bHQoKTtcbn1cbi8vIEV2ZW50IERlbGVnYXRpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGJ1aWxkRGVsZWdhdGlvbkhhbmRsZXIoc2VsZWN0b3IsIGhhbmRsZXIpIHtcbiAgICByZXR1cm4gKGV2KSA9PiB7XG4gICAgICAgIGxldCBtYXRjaGVkQ2hpbGQgPSBlbGVtZW50Q2xvc2VzdChldi50YXJnZXQsIHNlbGVjdG9yKTtcbiAgICAgICAgaWYgKG1hdGNoZWRDaGlsZCkge1xuICAgICAgICAgICAgaGFuZGxlci5jYWxsKG1hdGNoZWRDaGlsZCwgZXYsIG1hdGNoZWRDaGlsZCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gbGlzdGVuQnlTZWxlY3Rvcihjb250YWluZXIsIGV2ZW50VHlwZSwgc2VsZWN0b3IsIGhhbmRsZXIpIHtcbiAgICBsZXQgYXR0YWNoZWRIYW5kbGVyID0gYnVpbGREZWxlZ2F0aW9uSGFuZGxlcihzZWxlY3RvciwgaGFuZGxlcik7XG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBhdHRhY2hlZEhhbmRsZXIpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgYXR0YWNoZWRIYW5kbGVyKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbGlzdGVuVG9Ib3ZlckJ5U2VsZWN0b3IoY29udGFpbmVyLCBzZWxlY3Rvciwgb25Nb3VzZUVudGVyLCBvbk1vdXNlTGVhdmUpIHtcbiAgICBsZXQgY3VycmVudE1hdGNoZWRDaGlsZDtcbiAgICByZXR1cm4gbGlzdGVuQnlTZWxlY3Rvcihjb250YWluZXIsICdtb3VzZW92ZXInLCBzZWxlY3RvciwgKG1vdXNlT3ZlckV2LCBtYXRjaGVkQ2hpbGQpID0+IHtcbiAgICAgICAgaWYgKG1hdGNoZWRDaGlsZCAhPT0gY3VycmVudE1hdGNoZWRDaGlsZCkge1xuICAgICAgICAgICAgY3VycmVudE1hdGNoZWRDaGlsZCA9IG1hdGNoZWRDaGlsZDtcbiAgICAgICAgICAgIG9uTW91c2VFbnRlcihtb3VzZU92ZXJFdiwgbWF0Y2hlZENoaWxkKTtcbiAgICAgICAgICAgIGxldCByZWFsT25Nb3VzZUxlYXZlID0gKG1vdXNlTGVhdmVFdikgPT4ge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRNYXRjaGVkQ2hpbGQgPSBudWxsO1xuICAgICAgICAgICAgICAgIG9uTW91c2VMZWF2ZShtb3VzZUxlYXZlRXYsIG1hdGNoZWRDaGlsZCk7XG4gICAgICAgICAgICAgICAgbWF0Y2hlZENoaWxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCByZWFsT25Nb3VzZUxlYXZlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBsaXN0ZW4gdG8gdGhlIG5leHQgbW91c2VsZWF2ZSwgYW5kIHRoZW4gdW5hdHRhY2hcbiAgICAgICAgICAgIG1hdGNoZWRDaGlsZC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgcmVhbE9uTW91c2VMZWF2ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8vIEFuaW1hdGlvblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuY29uc3QgdHJhbnNpdGlvbkV2ZW50TmFtZXMgPSBbXG4gICAgJ3dlYmtpdFRyYW5zaXRpb25FbmQnLFxuICAgICdvdHJhbnNpdGlvbmVuZCcsXG4gICAgJ29UcmFuc2l0aW9uRW5kJyxcbiAgICAnbXNUcmFuc2l0aW9uRW5kJyxcbiAgICAndHJhbnNpdGlvbmVuZCcsXG5dO1xuLy8gdHJpZ2dlcmVkIG9ubHkgd2hlbiB0aGUgbmV4dCBzaW5nbGUgc3Vic2VxdWVudCB0cmFuc2l0aW9uIGZpbmlzaGVzXG5mdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkRvbmUoZWwsIGNhbGxiYWNrKSB7XG4gICAgbGV0IHJlYWxDYWxsYmFjayA9IChldikgPT4ge1xuICAgICAgICBjYWxsYmFjayhldik7XG4gICAgICAgIHRyYW5zaXRpb25FdmVudE5hbWVzLmZvckVhY2goKGV2ZW50TmFtZSkgPT4ge1xuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHJlYWxDYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdHJhbnNpdGlvbkV2ZW50TmFtZXMuZm9yRWFjaCgoZXZlbnROYW1lKSA9PiB7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCByZWFsQ2FsbGJhY2spOyAvLyBjcm9zcy1icm93c2VyIHdheSB0byBkZXRlcm1pbmUgd2hlbiB0aGUgdHJhbnNpdGlvbiBmaW5pc2hlc1xuICAgIH0pO1xufVxuLy8gQVJJQSB3b3JrYXJvdW5kc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gY3JlYXRlQXJpYUNsaWNrQXR0cnMoaGFuZGxlcikge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgb25DbGljazogaGFuZGxlciB9LCBjcmVhdGVBcmlhS2V5Ym9hcmRBdHRycyhoYW5kbGVyKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVBcmlhS2V5Ym9hcmRBdHRycyhoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGFiSW5kZXg6IDAsXG4gICAgICAgIG9uS2V5RG93bihldikge1xuICAgICAgICAgICAgaWYgKGV2LmtleSA9PT0gJ0VudGVyJyB8fCBldi5rZXkgPT09ICcgJykge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIoZXYpO1xuICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7IC8vIGlmIHNwYWNlLCBkb24ndCBzY3JvbGwgZG93biBwYWdlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcbn1cblxubGV0IGd1aWROdW1iZXIgPSAwO1xuZnVuY3Rpb24gZ3VpZCgpIHtcbiAgICBndWlkTnVtYmVyICs9IDE7XG4gICAgcmV0dXJuIFN0cmluZyhndWlkTnVtYmVyKTtcbn1cbi8qIEZ1bGxDYWxlbmRhci1zcGVjaWZpYyBET00gVXRpbGl0aWVzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8vIE1ha2UgdGhlIG1vdXNlIGN1cnNvciBleHByZXNzIHRoYXQgYW4gZXZlbnQgaXMgbm90IGFsbG93ZWQgaW4gdGhlIGN1cnJlbnQgYXJlYVxuZnVuY3Rpb24gZGlzYWJsZUN1cnNvcigpIHtcbiAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoJ2ZjLW5vdC1hbGxvd2VkJyk7XG59XG4vLyBSZXR1cm5zIHRoZSBtb3VzZSBjdXJzb3IgdG8gaXRzIG9yaWdpbmFsIGxvb2tcbmZ1bmN0aW9uIGVuYWJsZUN1cnNvcigpIHtcbiAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoJ2ZjLW5vdC1hbGxvd2VkJyk7XG59XG4vKiBTZWxlY3Rpb25cbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZnVuY3Rpb24gcHJldmVudFNlbGVjdGlvbihlbCkge1xuICAgIGVsLnN0eWxlLnVzZXJTZWxlY3QgPSAnbm9uZSc7XG4gICAgZWwuc3R5bGUud2Via2l0VXNlclNlbGVjdCA9ICdub25lJztcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIHByZXZlbnREZWZhdWx0KTtcbn1cbmZ1bmN0aW9uIGFsbG93U2VsZWN0aW9uKGVsKSB7XG4gICAgZWwuc3R5bGUudXNlclNlbGVjdCA9ICcnO1xuICAgIGVsLnN0eWxlLndlYmtpdFVzZXJTZWxlY3QgPSAnJztcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIHByZXZlbnREZWZhdWx0KTtcbn1cbi8qIENvbnRleHQgTWVudVxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5mdW5jdGlvbiBwcmV2ZW50Q29udGV4dE1lbnUoZWwpIHtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHByZXZlbnREZWZhdWx0KTtcbn1cbmZ1bmN0aW9uIGFsbG93Q29udGV4dE1lbnUoZWwpIHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHByZXZlbnREZWZhdWx0KTtcbn1cbmZ1bmN0aW9uIHBhcnNlRmllbGRTcGVjcyhpbnB1dCkge1xuICAgIGxldCBzcGVjcyA9IFtdO1xuICAgIGxldCB0b2tlbnMgPSBbXTtcbiAgICBsZXQgaTtcbiAgICBsZXQgdG9rZW47XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdG9rZW5zID0gaW5wdXQuc3BsaXQoL1xccyosXFxzKi8pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdG9rZW5zID0gW2lucHV0XTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgdG9rZW5zID0gaW5wdXQ7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzcGVjcy5wdXNoKHRva2VuLmNoYXJBdCgwKSA9PT0gJy0nID9cbiAgICAgICAgICAgICAgICB7IGZpZWxkOiB0b2tlbi5zdWJzdHJpbmcoMSksIG9yZGVyOiAtMSB9IDpcbiAgICAgICAgICAgICAgICB7IGZpZWxkOiB0b2tlbiwgb3JkZXI6IDEgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHRva2VuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzcGVjcy5wdXNoKHsgZnVuYzogdG9rZW4gfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNwZWNzO1xufVxuZnVuY3Rpb24gY29tcGFyZUJ5RmllbGRTcGVjcyhvYmowLCBvYmoxLCBmaWVsZFNwZWNzKSB7XG4gICAgbGV0IGk7XG4gICAgbGV0IGNtcDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmllbGRTcGVjcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjbXAgPSBjb21wYXJlQnlGaWVsZFNwZWMob2JqMCwgb2JqMSwgZmllbGRTcGVjc1tpXSk7XG4gICAgICAgIGlmIChjbXApIHtcbiAgICAgICAgICAgIHJldHVybiBjbXA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBjb21wYXJlQnlGaWVsZFNwZWMob2JqMCwgb2JqMSwgZmllbGRTcGVjKSB7XG4gICAgaWYgKGZpZWxkU3BlYy5mdW5jKSB7XG4gICAgICAgIHJldHVybiBmaWVsZFNwZWMuZnVuYyhvYmowLCBvYmoxKTtcbiAgICB9XG4gICAgcmV0dXJuIGZsZXhpYmxlQ29tcGFyZShvYmowW2ZpZWxkU3BlYy5maWVsZF0sIG9iajFbZmllbGRTcGVjLmZpZWxkXSlcbiAgICAgICAgKiAoZmllbGRTcGVjLm9yZGVyIHx8IDEpO1xufVxuZnVuY3Rpb24gZmxleGlibGVDb21wYXJlKGEsIGIpIHtcbiAgICBpZiAoIWEgJiYgIWIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmIChiID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBpZiAoYSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGEgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBiID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gU3RyaW5nKGEpLmxvY2FsZUNvbXBhcmUoU3RyaW5nKGIpKTtcbiAgICB9XG4gICAgcmV0dXJuIGEgLSBiO1xufVxuLyogU3RyaW5nIFV0aWxpdGllc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5mdW5jdGlvbiBwYWRTdGFydCh2YWwsIGxlbikge1xuICAgIGxldCBzID0gU3RyaW5nKHZhbCk7XG4gICAgcmV0dXJuICcwMDAnLnN1YnN0cigwLCBsZW4gLSBzLmxlbmd0aCkgKyBzO1xufVxuZnVuY3Rpb24gZm9ybWF0V2l0aE9yZGluYWxzKGZvcm1hdHRlciwgYXJncywgZmFsbGJhY2tUZXh0KSB7XG4gICAgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlciguLi5hcmdzKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdzdHJpbmcnKSB7IC8vIG5vbi1ibGFuayBzdHJpbmdcbiAgICAgICAgcmV0dXJuIGFyZ3MucmVkdWNlKChzdHIsIGFyZywgaW5kZXgpID0+IChzdHIucmVwbGFjZSgnJCcgKyBpbmRleCwgYXJnIHx8ICcnKSksIGZvcm1hdHRlcik7XG4gICAgfVxuICAgIHJldHVybiBmYWxsYmFja1RleHQ7XG59XG4vKiBOdW1iZXIgVXRpbGl0aWVzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmZ1bmN0aW9uIGNvbXBhcmVOdW1iZXJzKGEsIGIpIHtcbiAgICByZXR1cm4gYSAtIGI7XG59XG5mdW5jdGlvbiBpc0ludChuKSB7XG4gICAgcmV0dXJuIG4gJSAxID09PSAwO1xufVxuLyogRkMtc3BlY2lmaWMgRE9NIGRpbWVuc2lvbiBzdHVmZlxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5mdW5jdGlvbiBjb21wdXRlU21hbGxlc3RDZWxsV2lkdGgoY2VsbEVsKSB7XG4gICAgbGV0IGFsbFdpZHRoRWwgPSBjZWxsRWwucXVlcnlTZWxlY3RvcignLmZjLXNjcm9sbGdyaWQtc2hyaW5rLWZyYW1lJyk7XG4gICAgbGV0IGNvbnRlbnRXaWR0aEVsID0gY2VsbEVsLnF1ZXJ5U2VsZWN0b3IoJy5mYy1zY3JvbGxncmlkLXNocmluay1jdXNoaW9uJyk7XG4gICAgaWYgKCFhbGxXaWR0aEVsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbmVlZHMgZmMtc2Nyb2xsZ3JpZC1zaHJpbmstZnJhbWUgY2xhc3NOYW1lJyk7IC8vIFRPRE86IHVzZSBjb25zdFxuICAgIH1cbiAgICBpZiAoIWNvbnRlbnRXaWR0aEVsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbmVlZHMgZmMtc2Nyb2xsZ3JpZC1zaHJpbmstY3VzaGlvbiBjbGFzc05hbWUnKTtcbiAgICB9XG4gICAgcmV0dXJuIGNlbGxFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCAtIGFsbFdpZHRoRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKyAvLyB0aGUgY2VsbCBwYWRkaW5nK2JvcmRlclxuICAgICAgICBjb250ZW50V2lkdGhFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbn1cblxuY29uc3QgSU5URVJOQUxfVU5JVFMgPSBbJ3llYXJzJywgJ21vbnRocycsICdkYXlzJywgJ21pbGxpc2Vjb25kcyddO1xuY29uc3QgUEFSU0VfUkUgPSAvXigtPykoPzooXFxkKylcXC4pPyhcXGQrKTooXFxkXFxkKSg/OjooXFxkXFxkKSg/OlxcLihcXGRcXGRcXGQpKT8pPy87XG4vLyBQYXJzaW5nIGFuZCBDcmVhdGlvblxuZnVuY3Rpb24gY3JlYXRlRHVyYXRpb24oaW5wdXQsIHVuaXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gcGFyc2VTdHJpbmcoaW5wdXQpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiBpbnB1dCkgeyAvLyBub24tbnVsbCBvYmplY3RcbiAgICAgICAgcmV0dXJuIHBhcnNlT2JqZWN0KGlucHV0KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlT2JqZWN0KHsgW3VuaXQgfHwgJ21pbGxpc2Vjb25kcyddOiBpbnB1dCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBwYXJzZVN0cmluZyhzKSB7XG4gICAgbGV0IG0gPSBQQVJTRV9SRS5leGVjKHMpO1xuICAgIGlmIChtKSB7XG4gICAgICAgIGxldCBzaWduID0gbVsxXSA/IC0xIDogMTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXJzOiAwLFxuICAgICAgICAgICAgbW9udGhzOiAwLFxuICAgICAgICAgICAgZGF5czogc2lnbiAqIChtWzJdID8gcGFyc2VJbnQobVsyXSwgMTApIDogMCksXG4gICAgICAgICAgICBtaWxsaXNlY29uZHM6IHNpZ24gKiAoKG1bM10gPyBwYXJzZUludChtWzNdLCAxMCkgOiAwKSAqIDYwICogNjAgKiAxMDAwICsgLy8gaG91cnNcbiAgICAgICAgICAgICAgICAobVs0XSA/IHBhcnNlSW50KG1bNF0sIDEwKSA6IDApICogNjAgKiAxMDAwICsgLy8gbWludXRlc1xuICAgICAgICAgICAgICAgIChtWzVdID8gcGFyc2VJbnQobVs1XSwgMTApIDogMCkgKiAxMDAwICsgLy8gc2Vjb25kc1xuICAgICAgICAgICAgICAgIChtWzZdID8gcGFyc2VJbnQobVs2XSwgMTApIDogMCkgLy8gbXNcbiAgICAgICAgICAgICksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcGFyc2VPYmplY3Qob2JqKSB7XG4gICAgbGV0IGR1cmF0aW9uID0ge1xuICAgICAgICB5ZWFyczogb2JqLnllYXJzIHx8IG9iai55ZWFyIHx8IDAsXG4gICAgICAgIG1vbnRoczogb2JqLm1vbnRocyB8fCBvYmoubW9udGggfHwgMCxcbiAgICAgICAgZGF5czogb2JqLmRheXMgfHwgb2JqLmRheSB8fCAwLFxuICAgICAgICBtaWxsaXNlY29uZHM6IChvYmouaG91cnMgfHwgb2JqLmhvdXIgfHwgMCkgKiA2MCAqIDYwICogMTAwMCArIC8vIGhvdXJzXG4gICAgICAgICAgICAob2JqLm1pbnV0ZXMgfHwgb2JqLm1pbnV0ZSB8fCAwKSAqIDYwICogMTAwMCArIC8vIG1pbnV0ZXNcbiAgICAgICAgICAgIChvYmouc2Vjb25kcyB8fCBvYmouc2Vjb25kIHx8IDApICogMTAwMCArIC8vIHNlY29uZHNcbiAgICAgICAgICAgIChvYmoubWlsbGlzZWNvbmRzIHx8IG9iai5taWxsaXNlY29uZCB8fCBvYmoubXMgfHwgMCksIC8vIG1zXG4gICAgfTtcbiAgICBsZXQgd2Vla3MgPSBvYmoud2Vla3MgfHwgb2JqLndlZWs7XG4gICAgaWYgKHdlZWtzKSB7XG4gICAgICAgIGR1cmF0aW9uLmRheXMgKz0gd2Vla3MgKiA3O1xuICAgICAgICBkdXJhdGlvbi5zcGVjaWZpZWRXZWVrcyA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBkdXJhdGlvbjtcbn1cbi8vIEVxdWFsaXR5XG5mdW5jdGlvbiBkdXJhdGlvbnNFcXVhbChkMCwgZDEpIHtcbiAgICByZXR1cm4gZDAueWVhcnMgPT09IGQxLnllYXJzICYmXG4gICAgICAgIGQwLm1vbnRocyA9PT0gZDEubW9udGhzICYmXG4gICAgICAgIGQwLmRheXMgPT09IGQxLmRheXMgJiZcbiAgICAgICAgZDAubWlsbGlzZWNvbmRzID09PSBkMS5taWxsaXNlY29uZHM7XG59XG5mdW5jdGlvbiBhc0NsZWFuRGF5cyhkdXIpIHtcbiAgICBpZiAoIWR1ci55ZWFycyAmJiAhZHVyLm1vbnRocyAmJiAhZHVyLm1pbGxpc2Vjb25kcykge1xuICAgICAgICByZXR1cm4gZHVyLmRheXM7XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuLy8gU2ltcGxlIE1hdGhcbmZ1bmN0aW9uIGFkZER1cmF0aW9ucyhkMCwgZDEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB5ZWFyczogZDAueWVhcnMgKyBkMS55ZWFycyxcbiAgICAgICAgbW9udGhzOiBkMC5tb250aHMgKyBkMS5tb250aHMsXG4gICAgICAgIGRheXM6IGQwLmRheXMgKyBkMS5kYXlzLFxuICAgICAgICBtaWxsaXNlY29uZHM6IGQwLm1pbGxpc2Vjb25kcyArIGQxLm1pbGxpc2Vjb25kcyxcbiAgICB9O1xufVxuZnVuY3Rpb24gc3VidHJhY3REdXJhdGlvbnMoZDEsIGQwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcnM6IGQxLnllYXJzIC0gZDAueWVhcnMsXG4gICAgICAgIG1vbnRoczogZDEubW9udGhzIC0gZDAubW9udGhzLFxuICAgICAgICBkYXlzOiBkMS5kYXlzIC0gZDAuZGF5cyxcbiAgICAgICAgbWlsbGlzZWNvbmRzOiBkMS5taWxsaXNlY29uZHMgLSBkMC5taWxsaXNlY29uZHMsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIG11bHRpcGx5RHVyYXRpb24oZCwgbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHllYXJzOiBkLnllYXJzICogbixcbiAgICAgICAgbW9udGhzOiBkLm1vbnRocyAqIG4sXG4gICAgICAgIGRheXM6IGQuZGF5cyAqIG4sXG4gICAgICAgIG1pbGxpc2Vjb25kczogZC5taWxsaXNlY29uZHMgKiBuLFxuICAgIH07XG59XG4vLyBDb252ZXJzaW9uc1xuLy8gXCJSb3VnaFwiIGJlY2F1c2UgdGhleSBhcmUgYmFzZWQgb24gYXZlcmFnZS1jYXNlIEdyZWdvcmlhbiBtb250aHMveWVhcnNcbmZ1bmN0aW9uIGFzUm91Z2hZZWFycyhkdXIpIHtcbiAgICByZXR1cm4gYXNSb3VnaERheXMoZHVyKSAvIDM2NTtcbn1cbmZ1bmN0aW9uIGFzUm91Z2hNb250aHMoZHVyKSB7XG4gICAgcmV0dXJuIGFzUm91Z2hEYXlzKGR1cikgLyAzMDtcbn1cbmZ1bmN0aW9uIGFzUm91Z2hEYXlzKGR1cikge1xuICAgIHJldHVybiBhc1JvdWdoTXMoZHVyKSAvIDg2NGU1O1xufVxuZnVuY3Rpb24gYXNSb3VnaE1pbnV0ZXMoZHVyKSB7XG4gICAgcmV0dXJuIGFzUm91Z2hNcyhkdXIpIC8gKDEwMDAgKiA2MCk7XG59XG5mdW5jdGlvbiBhc1JvdWdoU2Vjb25kcyhkdXIpIHtcbiAgICByZXR1cm4gYXNSb3VnaE1zKGR1cikgLyAxMDAwO1xufVxuZnVuY3Rpb24gYXNSb3VnaE1zKGR1cikge1xuICAgIHJldHVybiBkdXIueWVhcnMgKiAoMzY1ICogODY0ZTUpICtcbiAgICAgICAgZHVyLm1vbnRocyAqICgzMCAqIDg2NGU1KSArXG4gICAgICAgIGR1ci5kYXlzICogODY0ZTUgK1xuICAgICAgICBkdXIubWlsbGlzZWNvbmRzO1xufVxuLy8gQWR2YW5jZWQgTWF0aFxuZnVuY3Rpb24gd2hvbGVEaXZpZGVEdXJhdGlvbnMobnVtZXJhdG9yLCBkZW5vbWluYXRvcikge1xuICAgIGxldCByZXMgPSBudWxsO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgSU5URVJOQUxfVU5JVFMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgbGV0IHVuaXQgPSBJTlRFUk5BTF9VTklUU1tpXTtcbiAgICAgICAgaWYgKGRlbm9taW5hdG9yW3VuaXRdKSB7XG4gICAgICAgICAgICBsZXQgbG9jYWxSZXMgPSBudW1lcmF0b3JbdW5pdF0gLyBkZW5vbWluYXRvclt1bml0XTtcbiAgICAgICAgICAgIGlmICghaXNJbnQobG9jYWxSZXMpIHx8IChyZXMgIT09IG51bGwgJiYgcmVzICE9PSBsb2NhbFJlcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcyA9IGxvY2FsUmVzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG51bWVyYXRvclt1bml0XSkge1xuICAgICAgICAgICAgLy8gbmVlZHMgdG8gZGl2aWRlIGJ5IHNvbWV0aGluZyBidXQgY2FuJ3QhXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yKGR1cikge1xuICAgIGxldCBtcyA9IGR1ci5taWxsaXNlY29uZHM7XG4gICAgaWYgKG1zKSB7XG4gICAgICAgIGlmIChtcyAlIDEwMDAgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdtaWxsaXNlY29uZCcsIHZhbHVlOiBtcyB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChtcyAlICgxMDAwICogNjApICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnc2Vjb25kJywgdmFsdWU6IG1zIC8gMTAwMCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChtcyAlICgxMDAwICogNjAgKiA2MCkgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdtaW51dGUnLCB2YWx1ZTogbXMgLyAoMTAwMCAqIDYwKSB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChtcykge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ2hvdXInLCB2YWx1ZTogbXMgLyAoMTAwMCAqIDYwICogNjApIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGR1ci5kYXlzKSB7XG4gICAgICAgIGlmIChkdXIuc3BlY2lmaWVkV2Vla3MgJiYgZHVyLmRheXMgJSA3ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnd2VlaycsIHZhbHVlOiBkdXIuZGF5cyAvIDcgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB1bml0OiAnZGF5JywgdmFsdWU6IGR1ci5kYXlzIH07XG4gICAgfVxuICAgIGlmIChkdXIubW9udGhzKSB7XG4gICAgICAgIHJldHVybiB7IHVuaXQ6ICdtb250aCcsIHZhbHVlOiBkdXIubW9udGhzIH07XG4gICAgfVxuICAgIGlmIChkdXIueWVhcnMpIHtcbiAgICAgICAgcmV0dXJuIHsgdW5pdDogJ3llYXInLCB2YWx1ZTogZHVyLnllYXJzIH07XG4gICAgfVxuICAgIHJldHVybiB7IHVuaXQ6ICdtaWxsaXNlY29uZCcsIHZhbHVlOiAwIH07XG59XG5cbi8vIFRPRE86IG5ldyB1dGlsIGFycmF5aWZ5P1xuZnVuY3Rpb24gcmVtb3ZlRXhhY3QoYXJyYXksIGV4YWN0VmFsKSB7XG4gICAgbGV0IHJlbW92ZUNudCA9IDA7XG4gICAgbGV0IGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIGlmIChhcnJheVtpXSA9PT0gZXhhY3RWYWwpIHtcbiAgICAgICAgICAgIGFycmF5LnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIHJlbW92ZUNudCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZW1vdmVDbnQ7XG59XG5mdW5jdGlvbiBpc0FycmF5c0VxdWFsKGEwLCBhMSwgZXF1YWxpdHlGdW5jKSB7XG4gICAgaWYgKGEwID09PSBhMSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IGxlbiA9IGEwLmxlbmd0aDtcbiAgICBsZXQgaTtcbiAgICBpZiAobGVuICE9PSBhMS5sZW5ndGgpIHsgLy8gbm90IGFycmF5PyBvciBub3Qgc2FtZSBsZW5ndGg/XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGlmICghKGVxdWFsaXR5RnVuYyA/IGVxdWFsaXR5RnVuYyhhMFtpXSwgYTFbaV0pIDogYTBbaV0gPT09IGExW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5jb25zdCBEQVlfSURTID0gWydzdW4nLCAnbW9uJywgJ3R1ZScsICd3ZWQnLCAndGh1JywgJ2ZyaScsICdzYXQnXTtcbi8vIEFkZGluZ1xuZnVuY3Rpb24gYWRkV2Vla3MobSwgbikge1xuICAgIGxldCBhID0gZGF0ZVRvVXRjQXJyYXkobSk7XG4gICAgYVsyXSArPSBuICogNztcbiAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoYSk7XG59XG5mdW5jdGlvbiBhZGREYXlzKG0sIG4pIHtcbiAgICBsZXQgYSA9IGRhdGVUb1V0Y0FycmF5KG0pO1xuICAgIGFbMl0gKz0gbjtcbiAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoYSk7XG59XG5mdW5jdGlvbiBhZGRNcyhtLCBuKSB7XG4gICAgbGV0IGEgPSBkYXRlVG9VdGNBcnJheShtKTtcbiAgICBhWzZdICs9IG47XG4gICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKGEpO1xufVxuLy8gRGlmZmluZyAoYWxsIHJldHVybiBmbG9hdHMpXG4vLyBUT0RPOiB3aHkgbm90IHVzZSByYW5nZXM/XG5mdW5jdGlvbiBkaWZmV2Vla3MobTAsIG0xKSB7XG4gICAgcmV0dXJuIGRpZmZEYXlzKG0wLCBtMSkgLyA3O1xufVxuZnVuY3Rpb24gZGlmZkRheXMobTAsIG0xKSB7XG4gICAgcmV0dXJuIChtMS52YWx1ZU9mKCkgLSBtMC52YWx1ZU9mKCkpIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpO1xufVxuZnVuY3Rpb24gZGlmZkhvdXJzKG0wLCBtMSkge1xuICAgIHJldHVybiAobTEudmFsdWVPZigpIC0gbTAudmFsdWVPZigpKSAvICgxMDAwICogNjAgKiA2MCk7XG59XG5mdW5jdGlvbiBkaWZmTWludXRlcyhtMCwgbTEpIHtcbiAgICByZXR1cm4gKG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSkgLyAoMTAwMCAqIDYwKTtcbn1cbmZ1bmN0aW9uIGRpZmZTZWNvbmRzKG0wLCBtMSkge1xuICAgIHJldHVybiAobTEudmFsdWVPZigpIC0gbTAudmFsdWVPZigpKSAvIDEwMDA7XG59XG5mdW5jdGlvbiBkaWZmRGF5QW5kVGltZShtMCwgbTEpIHtcbiAgICBsZXQgbTBkYXkgPSBzdGFydE9mRGF5KG0wKTtcbiAgICBsZXQgbTFkYXkgPSBzdGFydE9mRGF5KG0xKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB5ZWFyczogMCxcbiAgICAgICAgbW9udGhzOiAwLFxuICAgICAgICBkYXlzOiBNYXRoLnJvdW5kKGRpZmZEYXlzKG0wZGF5LCBtMWRheSkpLFxuICAgICAgICBtaWxsaXNlY29uZHM6IChtMS52YWx1ZU9mKCkgLSBtMWRheS52YWx1ZU9mKCkpIC0gKG0wLnZhbHVlT2YoKSAtIG0wZGF5LnZhbHVlT2YoKSksXG4gICAgfTtcbn1cbi8vIERpZmZpbmcgV2hvbGUgVW5pdHNcbmZ1bmN0aW9uIGRpZmZXaG9sZVdlZWtzKG0wLCBtMSkge1xuICAgIGxldCBkID0gZGlmZldob2xlRGF5cyhtMCwgbTEpO1xuICAgIGlmIChkICE9PSBudWxsICYmIGQgJSA3ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBkIC8gNztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBkaWZmV2hvbGVEYXlzKG0wLCBtMSkge1xuICAgIGlmICh0aW1lQXNNcyhtMCkgPT09IHRpbWVBc01zKG0xKSkge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChkaWZmRGF5cyhtMCwgbTEpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vLyBTdGFydC1PZlxuZnVuY3Rpb24gc3RhcnRPZkRheShtKSB7XG4gICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKFtcbiAgICAgICAgbS5nZXRVVENGdWxsWWVhcigpLFxuICAgICAgICBtLmdldFVUQ01vbnRoKCksXG4gICAgICAgIG0uZ2V0VVRDRGF0ZSgpLFxuICAgIF0pO1xufVxuZnVuY3Rpb24gc3RhcnRPZkhvdXIobSkge1xuICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShbXG4gICAgICAgIG0uZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgbS5nZXRVVENNb250aCgpLFxuICAgICAgICBtLmdldFVUQ0RhdGUoKSxcbiAgICAgICAgbS5nZXRVVENIb3VycygpLFxuICAgIF0pO1xufVxuZnVuY3Rpb24gc3RhcnRPZk1pbnV0ZShtKSB7XG4gICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKFtcbiAgICAgICAgbS5nZXRVVENGdWxsWWVhcigpLFxuICAgICAgICBtLmdldFVUQ01vbnRoKCksXG4gICAgICAgIG0uZ2V0VVRDRGF0ZSgpLFxuICAgICAgICBtLmdldFVUQ0hvdXJzKCksXG4gICAgICAgIG0uZ2V0VVRDTWludXRlcygpLFxuICAgIF0pO1xufVxuZnVuY3Rpb24gc3RhcnRPZlNlY29uZChtKSB7XG4gICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKFtcbiAgICAgICAgbS5nZXRVVENGdWxsWWVhcigpLFxuICAgICAgICBtLmdldFVUQ01vbnRoKCksXG4gICAgICAgIG0uZ2V0VVRDRGF0ZSgpLFxuICAgICAgICBtLmdldFVUQ0hvdXJzKCksXG4gICAgICAgIG0uZ2V0VVRDTWludXRlcygpLFxuICAgICAgICBtLmdldFVUQ1NlY29uZHMoKSxcbiAgICBdKTtcbn1cbi8vIFdlZWsgQ29tcHV0YXRpb25cbmZ1bmN0aW9uIHdlZWtPZlllYXIobWFya2VyLCBkb3csIGRveSkge1xuICAgIGxldCB5ID0gbWFya2VyLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgbGV0IHcgPSB3ZWVrT2ZHaXZlblllYXIobWFya2VyLCB5LCBkb3csIGRveSk7XG4gICAgaWYgKHcgPCAxKSB7XG4gICAgICAgIHJldHVybiB3ZWVrT2ZHaXZlblllYXIobWFya2VyLCB5IC0gMSwgZG93LCBkb3kpO1xuICAgIH1cbiAgICBsZXQgbmV4dFcgPSB3ZWVrT2ZHaXZlblllYXIobWFya2VyLCB5ICsgMSwgZG93LCBkb3kpO1xuICAgIGlmIChuZXh0VyA+PSAxKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1pbih3LCBuZXh0Vyk7XG4gICAgfVxuICAgIHJldHVybiB3O1xufVxuZnVuY3Rpb24gd2Vla09mR2l2ZW5ZZWFyKG1hcmtlciwgeWVhciwgZG93LCBkb3kpIHtcbiAgICBsZXQgZmlyc3RXZWVrU3RhcnQgPSBhcnJheVRvVXRjRGF0ZShbeWVhciwgMCwgMSArIGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSldKTtcbiAgICBsZXQgZGF5U3RhcnQgPSBzdGFydE9mRGF5KG1hcmtlcik7XG4gICAgbGV0IGRheXMgPSBNYXRoLnJvdW5kKGRpZmZEYXlzKGZpcnN0V2Vla1N0YXJ0LCBkYXlTdGFydCkpO1xuICAgIHJldHVybiBNYXRoLmZsb29yKGRheXMgLyA3KSArIDE7IC8vIHplcm8taW5kZXhlZFxufVxuLy8gc3RhcnQtb2YtZmlyc3Qtd2VlayAtIHN0YXJ0LW9mLXllYXJcbmZ1bmN0aW9uIGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSkge1xuICAgIC8vIGZpcnN0LXdlZWsgZGF5IC0tIHdoaWNoIGphbnVhcnkgaXMgYWx3YXlzIGluIHRoZSBmaXJzdCB3ZWVrICg0IGZvciBpc28sIDEgZm9yIG90aGVyKVxuICAgIGxldCBmd2QgPSA3ICsgZG93IC0gZG95O1xuICAgIC8vIGZpcnN0LXdlZWsgZGF5IGxvY2FsIHdlZWtkYXkgLS0gd2hpY2ggbG9jYWwgd2Vla2RheSBpcyBmd2RcbiAgICBsZXQgZndkbHcgPSAoNyArIGFycmF5VG9VdGNEYXRlKFt5ZWFyLCAwLCBmd2RdKS5nZXRVVENEYXkoKSAtIGRvdykgJSA3O1xuICAgIHJldHVybiAtZndkbHcgKyBmd2QgLSAxO1xufVxuLy8gQXJyYXkgQ29udmVyc2lvblxuZnVuY3Rpb24gZGF0ZVRvTG9jYWxBcnJheShkYXRlKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgZGF0ZS5nZXRGdWxsWWVhcigpLFxuICAgICAgICBkYXRlLmdldE1vbnRoKCksXG4gICAgICAgIGRhdGUuZ2V0RGF0ZSgpLFxuICAgICAgICBkYXRlLmdldEhvdXJzKCksXG4gICAgICAgIGRhdGUuZ2V0TWludXRlcygpLFxuICAgICAgICBkYXRlLmdldFNlY29uZHMoKSxcbiAgICAgICAgZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSxcbiAgICBdO1xufVxuZnVuY3Rpb24gYXJyYXlUb0xvY2FsRGF0ZShhKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKGFbMF0sIGFbMV0gfHwgMCwgYVsyXSA9PSBudWxsID8gMSA6IGFbMl0sIC8vIGRheSBvZiBtb250aFxuICAgIGFbM10gfHwgMCwgYVs0XSB8fCAwLCBhWzVdIHx8IDApO1xufVxuZnVuY3Rpb24gZGF0ZVRvVXRjQXJyYXkoZGF0ZSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGRhdGUuZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgZGF0ZS5nZXRVVENNb250aCgpLFxuICAgICAgICBkYXRlLmdldFVUQ0RhdGUoKSxcbiAgICAgICAgZGF0ZS5nZXRVVENIb3VycygpLFxuICAgICAgICBkYXRlLmdldFVUQ01pbnV0ZXMoKSxcbiAgICAgICAgZGF0ZS5nZXRVVENTZWNvbmRzKCksXG4gICAgICAgIGRhdGUuZ2V0VVRDTWlsbGlzZWNvbmRzKCksXG4gICAgXTtcbn1cbmZ1bmN0aW9uIGFycmF5VG9VdGNEYXRlKGEpIHtcbiAgICAvLyBhY2NvcmRpbmcgdG8gd2ViIHN0YW5kYXJkcyAoYW5kIFNhZmFyaSksIGEgbW9udGggaW5kZXggaXMgcmVxdWlyZWQuXG4gICAgLy8gbWFzc2FnZSBpZiBvbmx5IGdpdmVuIGEgeWVhci5cbiAgICBpZiAoYS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgYSA9IGEuY29uY2F0KFswXSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyguLi5hKSk7XG59XG4vLyBPdGhlciBVdGlsc1xuZnVuY3Rpb24gaXNWYWxpZERhdGUobSkge1xuICAgIHJldHVybiAhaXNOYU4obS52YWx1ZU9mKCkpO1xufVxuZnVuY3Rpb24gdGltZUFzTXMobSkge1xuICAgIHJldHVybiBtLmdldFVUQ0hvdXJzKCkgKiAxMDAwICogNjAgKiA2MCArXG4gICAgICAgIG0uZ2V0VVRDTWludXRlcygpICogMTAwMCAqIDYwICtcbiAgICAgICAgbS5nZXRVVENTZWNvbmRzKCkgKiAxMDAwICtcbiAgICAgICAgbS5nZXRVVENNaWxsaXNlY29uZHMoKTtcbn1cblxuLy8gdGltZVpvbmVPZmZzZXQgaXMgaW4gbWludXRlc1xuZnVuY3Rpb24gYnVpbGRJc29TdHJpbmcobWFya2VyLCB0aW1lWm9uZU9mZnNldCwgc3RyaXBaZXJvVGltZSA9IGZhbHNlKSB7XG4gICAgbGV0IHMgPSBtYXJrZXIudG9JU09TdHJpbmcoKTtcbiAgICBzID0gcy5yZXBsYWNlKCcuMDAwJywgJycpO1xuICAgIGlmIChzdHJpcFplcm9UaW1lKSB7XG4gICAgICAgIHMgPSBzLnJlcGxhY2UoJ1QwMDowMDowMFonLCAnJyk7XG4gICAgfVxuICAgIGlmIChzLmxlbmd0aCA+IDEwKSB7IC8vIHRpbWUgcGFydCB3YXNuJ3Qgc3RyaXBwZWQsIGNhbiBhZGQgdGltZXpvbmUgaW5mb1xuICAgICAgICBpZiAodGltZVpvbmVPZmZzZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcyA9IHMucmVwbGFjZSgnWicsICcnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aW1lWm9uZU9mZnNldCAhPT0gMCkge1xuICAgICAgICAgICAgcyA9IHMucmVwbGFjZSgnWicsIGZvcm1hdFRpbWVab25lT2Zmc2V0KHRpbWVab25lT2Zmc2V0LCB0cnVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3RoZXJ3aXNlLCBpdHMgVVRDLTAgYW5kIHdlIHdhbnQgdG8ga2VlcCB0aGUgWlxuICAgIH1cbiAgICByZXR1cm4gcztcbn1cbi8vIGZvcm1hdHMgdGhlIGRhdGUsIGJ1dCB3aXRoIG5vIHRpbWUgcGFydFxuLy8gVE9ETzogc29tZWhvdyBtZXJnZSB3aXRoIGJ1aWxkSXNvU3RyaW5nIGFuZCBzdHJpcFplcm9UaW1lXG4vLyBUT0RPOiByZW5hbWUuIG9taXQgXCJzdHJpbmdcIlxuZnVuY3Rpb24gZm9ybWF0RGF5U3RyaW5nKG1hcmtlcikge1xuICAgIHJldHVybiBtYXJrZXIudG9JU09TdHJpbmcoKS5yZXBsYWNlKC9ULiokLywgJycpO1xufVxuZnVuY3Rpb24gZm9ybWF0SXNvTW9udGhTdHIobWFya2VyKSB7XG4gICAgcmV0dXJuIG1hcmtlci50b0lTT1N0cmluZygpLm1hdGNoKC9eXFxkezR9LVxcZHsyfS8pWzBdO1xufVxuLy8gVE9ETzogdXNlIERhdGU6OnRvSVNPU3RyaW5nIGFuZCB1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgVD9cbmZ1bmN0aW9uIGZvcm1hdElzb1RpbWVTdHJpbmcobWFya2VyKSB7XG4gICAgcmV0dXJuIHBhZFN0YXJ0KG1hcmtlci5nZXRVVENIb3VycygpLCAyKSArICc6JyArXG4gICAgICAgIHBhZFN0YXJ0KG1hcmtlci5nZXRVVENNaW51dGVzKCksIDIpICsgJzonICtcbiAgICAgICAgcGFkU3RhcnQobWFya2VyLmdldFVUQ1NlY29uZHMoKSwgMik7XG59XG5mdW5jdGlvbiBmb3JtYXRUaW1lWm9uZU9mZnNldChtaW51dGVzLCBkb0lzbyA9IGZhbHNlKSB7XG4gICAgbGV0IHNpZ24gPSBtaW51dGVzIDwgMCA/ICctJyA6ICcrJztcbiAgICBsZXQgYWJzID0gTWF0aC5hYnMobWludXRlcyk7XG4gICAgbGV0IGhvdXJzID0gTWF0aC5mbG9vcihhYnMgLyA2MCk7XG4gICAgbGV0IG1pbnMgPSBNYXRoLnJvdW5kKGFicyAlIDYwKTtcbiAgICBpZiAoZG9Jc28pIHtcbiAgICAgICAgcmV0dXJuIGAke3NpZ24gKyBwYWRTdGFydChob3VycywgMil9OiR7cGFkU3RhcnQobWlucywgMil9YDtcbiAgICB9XG4gICAgcmV0dXJuIGBHTVQke3NpZ259JHtob3Vyc30ke21pbnMgPyBgOiR7cGFkU3RhcnQobWlucywgMil9YCA6ICcnfWA7XG59XG5cbmZ1bmN0aW9uIG1lbW9pemUod29ya2VyRnVuYywgcmVzRXF1YWxpdHksIHRlYXJkb3duRnVuYykge1xuICAgIGxldCBjdXJyZW50QXJncztcbiAgICBsZXQgY3VycmVudFJlcztcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLm5ld0FyZ3MpIHtcbiAgICAgICAgaWYgKCFjdXJyZW50QXJncykge1xuICAgICAgICAgICAgY3VycmVudFJlcyA9IHdvcmtlckZ1bmMuYXBwbHkodGhpcywgbmV3QXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWlzQXJyYXlzRXF1YWwoY3VycmVudEFyZ3MsIG5ld0FyZ3MpKSB7XG4gICAgICAgICAgICBpZiAodGVhcmRvd25GdW5jKSB7XG4gICAgICAgICAgICAgICAgdGVhcmRvd25GdW5jKGN1cnJlbnRSZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlcyA9IHdvcmtlckZ1bmMuYXBwbHkodGhpcywgbmV3QXJncyk7XG4gICAgICAgICAgICBpZiAoIXJlc0VxdWFsaXR5IHx8ICFyZXNFcXVhbGl0eShyZXMsIGN1cnJlbnRSZXMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFJlcyA9IHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50QXJncyA9IG5ld0FyZ3M7XG4gICAgICAgIHJldHVybiBjdXJyZW50UmVzO1xuICAgIH07XG59XG5mdW5jdGlvbiBtZW1vaXplT2JqQXJnKHdvcmtlckZ1bmMsIHJlc0VxdWFsaXR5LCB0ZWFyZG93bkZ1bmMpIHtcbiAgICBsZXQgY3VycmVudEFyZztcbiAgICBsZXQgY3VycmVudFJlcztcbiAgICByZXR1cm4gKG5ld0FyZykgPT4ge1xuICAgICAgICBpZiAoIWN1cnJlbnRBcmcpIHtcbiAgICAgICAgICAgIGN1cnJlbnRSZXMgPSB3b3JrZXJGdW5jLmNhbGwodGhpcywgbmV3QXJnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaXNQcm9wc0VxdWFsKGN1cnJlbnRBcmcsIG5ld0FyZykpIHtcbiAgICAgICAgICAgIGlmICh0ZWFyZG93bkZ1bmMpIHtcbiAgICAgICAgICAgICAgICB0ZWFyZG93bkZ1bmMoY3VycmVudFJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzID0gd29ya2VyRnVuYy5jYWxsKHRoaXMsIG5ld0FyZyk7XG4gICAgICAgICAgICBpZiAoIXJlc0VxdWFsaXR5IHx8ICFyZXNFcXVhbGl0eShyZXMsIGN1cnJlbnRSZXMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFJlcyA9IHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50QXJnID0gbmV3QXJnO1xuICAgICAgICByZXR1cm4gY3VycmVudFJlcztcbiAgICB9O1xufVxuZnVuY3Rpb24gbWVtb2l6ZUFycmF5bGlrZSgvLyB1c2VkIGF0IGFsbD9cbndvcmtlckZ1bmMsIHJlc0VxdWFsaXR5LCB0ZWFyZG93bkZ1bmMpIHtcbiAgICBsZXQgY3VycmVudEFyZ1NldHMgPSBbXTtcbiAgICBsZXQgY3VycmVudFJlc3VsdHMgPSBbXTtcbiAgICByZXR1cm4gKG5ld0FyZ1NldHMpID0+IHtcbiAgICAgICAgbGV0IGN1cnJlbnRMZW4gPSBjdXJyZW50QXJnU2V0cy5sZW5ndGg7XG4gICAgICAgIGxldCBuZXdMZW4gPSBuZXdBcmdTZXRzLmxlbmd0aDtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBmb3IgKDsgaSA8IGN1cnJlbnRMZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKCFuZXdBcmdTZXRzW2ldKSB7IC8vIG9uZSBvZiB0aGUgb2xkIHNldHMgbm8gbG9uZ2VyIGV4aXN0c1xuICAgICAgICAgICAgICAgIGlmICh0ZWFyZG93bkZ1bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVhcmRvd25GdW5jKGN1cnJlbnRSZXN1bHRzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghaXNBcnJheXNFcXVhbChjdXJyZW50QXJnU2V0c1tpXSwgbmV3QXJnU2V0c1tpXSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGVhcmRvd25GdW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlYXJkb3duRnVuYyhjdXJyZW50UmVzdWx0c1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByZXMgPSB3b3JrZXJGdW5jLmFwcGx5KHRoaXMsIG5ld0FyZ1NldHNbaV0pO1xuICAgICAgICAgICAgICAgIGlmICghcmVzRXF1YWxpdHkgfHwgIXJlc0VxdWFsaXR5KHJlcywgY3VycmVudFJlc3VsdHNbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZXN1bHRzW2ldID0gcmVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgaSA8IG5ld0xlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVzdWx0c1tpXSA9IHdvcmtlckZ1bmMuYXBwbHkodGhpcywgbmV3QXJnU2V0c1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEFyZ1NldHMgPSBuZXdBcmdTZXRzO1xuICAgICAgICBjdXJyZW50UmVzdWx0cy5zcGxpY2UobmV3TGVuKTsgLy8gcmVtb3ZlIGV4Y2Vzc1xuICAgICAgICByZXR1cm4gY3VycmVudFJlc3VsdHM7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1lbW9pemVIYXNobGlrZSh3b3JrZXJGdW5jLCByZXNFcXVhbGl0eSwgdGVhcmRvd25GdW5jKSB7XG4gICAgbGV0IGN1cnJlbnRBcmdIYXNoID0ge307XG4gICAgbGV0IGN1cnJlbnRSZXNIYXNoID0ge307XG4gICAgcmV0dXJuIChuZXdBcmdIYXNoKSA9PiB7XG4gICAgICAgIGxldCBuZXdSZXNIYXNoID0ge307XG4gICAgICAgIGZvciAobGV0IGtleSBpbiBuZXdBcmdIYXNoKSB7XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRSZXNIYXNoW2tleV0pIHtcbiAgICAgICAgICAgICAgICBuZXdSZXNIYXNoW2tleV0gPSB3b3JrZXJGdW5jLmFwcGx5KHRoaXMsIG5ld0FyZ0hhc2hba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghaXNBcnJheXNFcXVhbChjdXJyZW50QXJnSGFzaFtrZXldLCBuZXdBcmdIYXNoW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRlYXJkb3duRnVuYykge1xuICAgICAgICAgICAgICAgICAgICB0ZWFyZG93bkZ1bmMoY3VycmVudFJlc0hhc2hba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByZXMgPSB3b3JrZXJGdW5jLmFwcGx5KHRoaXMsIG5ld0FyZ0hhc2hba2V5XSk7XG4gICAgICAgICAgICAgICAgbmV3UmVzSGFzaFtrZXldID0gKHJlc0VxdWFsaXR5ICYmIHJlc0VxdWFsaXR5KHJlcywgY3VycmVudFJlc0hhc2hba2V5XSkpXG4gICAgICAgICAgICAgICAgICAgID8gY3VycmVudFJlc0hhc2hba2V5XVxuICAgICAgICAgICAgICAgICAgICA6IHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1Jlc0hhc2hba2V5XSA9IGN1cnJlbnRSZXNIYXNoW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEFyZ0hhc2ggPSBuZXdBcmdIYXNoO1xuICAgICAgICBjdXJyZW50UmVzSGFzaCA9IG5ld1Jlc0hhc2g7XG4gICAgICAgIHJldHVybiBuZXdSZXNIYXNoO1xuICAgIH07XG59XG5cbmNvbnN0IEVYVEVOREVEX1NFVFRJTkdTX0FORF9TRVZFUklUSUVTID0ge1xuICAgIHdlZWs6IDMsXG4gICAgc2VwYXJhdG9yOiAwLFxuICAgIG9taXRaZXJvTWludXRlOiAwLFxuICAgIG1lcmlkaWVtOiAwLFxuICAgIG9taXRDb21tYXM6IDAsXG59O1xuY29uc3QgU1RBTkRBUkRfREFURV9QUk9QX1NFVkVSSVRJRVMgPSB7XG4gICAgdGltZVpvbmVOYW1lOiA3LFxuICAgIGVyYTogNixcbiAgICB5ZWFyOiA1LFxuICAgIG1vbnRoOiA0LFxuICAgIGRheTogMixcbiAgICB3ZWVrZGF5OiAyLFxuICAgIGhvdXI6IDEsXG4gICAgbWludXRlOiAxLFxuICAgIHNlY29uZDogMSxcbn07XG5jb25zdCBNRVJJRElFTV9SRSA9IC9cXHMqKFthcF0pXFwuP21cXC4/L2k7IC8vIGVhdHMgdXAgbGVhZGluZyBzcGFjZXMgdG9vXG5jb25zdCBDT01NQV9SRSA9IC8sL2c7IC8vIHdlIG5lZWQgcmUgZm9yIGdsb2JhbG5lc3NcbmNvbnN0IE1VTFRJX1NQQUNFX1JFID0gL1xccysvZztcbmNvbnN0IExUUl9SRSA9IC9cXHUyMDBlL2c7IC8vIGNvbnRyb2wgY2hhcmFjdGVyXG5jb25zdCBVVENfUkUgPSAvVVRDfEdNVC87XG5jbGFzcyBOYXRpdmVGb3JtYXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGZvcm1hdFNldHRpbmdzKSB7XG4gICAgICAgIGxldCBzdGFuZGFyZERhdGVQcm9wcyA9IHt9O1xuICAgICAgICBsZXQgZXh0ZW5kZWRTZXR0aW5ncyA9IHt9O1xuICAgICAgICBsZXQgc2V2ZXJpdHkgPSAwO1xuICAgICAgICBmb3IgKGxldCBuYW1lIGluIGZvcm1hdFNldHRpbmdzKSB7XG4gICAgICAgICAgICBpZiAobmFtZSBpbiBFWFRFTkRFRF9TRVRUSU5HU19BTkRfU0VWRVJJVElFUykge1xuICAgICAgICAgICAgICAgIGV4dGVuZGVkU2V0dGluZ3NbbmFtZV0gPSBmb3JtYXRTZXR0aW5nc1tuYW1lXTtcbiAgICAgICAgICAgICAgICBzZXZlcml0eSA9IE1hdGgubWF4KEVYVEVOREVEX1NFVFRJTkdTX0FORF9TRVZFUklUSUVTW25hbWVdLCBzZXZlcml0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGFuZGFyZERhdGVQcm9wc1tuYW1lXSA9IGZvcm1hdFNldHRpbmdzW25hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lIGluIFNUQU5EQVJEX0RBVEVfUFJPUF9TRVZFUklUSUVTKSB7IC8vIFRPRE86IHdoYXQgYWJvdXQgaG91cjEyPyBubyBzZXZlcml0eVxuICAgICAgICAgICAgICAgICAgICBzZXZlcml0eSA9IE1hdGgubWF4KFNUQU5EQVJEX0RBVEVfUFJPUF9TRVZFUklUSUVTW25hbWVdLCBzZXZlcml0eSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhbmRhcmREYXRlUHJvcHMgPSBzdGFuZGFyZERhdGVQcm9wcztcbiAgICAgICAgdGhpcy5leHRlbmRlZFNldHRpbmdzID0gZXh0ZW5kZWRTZXR0aW5ncztcbiAgICAgICAgdGhpcy5zZXZlcml0eSA9IHNldmVyaXR5O1xuICAgICAgICB0aGlzLmJ1aWxkRm9ybWF0dGluZ0Z1bmMgPSBtZW1vaXplKGJ1aWxkRm9ybWF0dGluZ0Z1bmMpO1xuICAgIH1cbiAgICBmb3JtYXQoZGF0ZSwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWlsZEZvcm1hdHRpbmdGdW5jKHRoaXMuc3RhbmRhcmREYXRlUHJvcHMsIHRoaXMuZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCkoZGF0ZSk7XG4gICAgfVxuICAgIGZvcm1hdFJhbmdlKHN0YXJ0LCBlbmQsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpIHtcbiAgICAgICAgbGV0IHsgc3RhbmRhcmREYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MgfSA9IHRoaXM7XG4gICAgICAgIGxldCBkaWZmU2V2ZXJpdHkgPSBjb21wdXRlTWFya2VyRGlmZlNldmVyaXR5KHN0YXJ0Lm1hcmtlciwgZW5kLm1hcmtlciwgY29udGV4dC5jYWxlbmRhclN5c3RlbSk7XG4gICAgICAgIGlmICghZGlmZlNldmVyaXR5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQoc3RhcnQsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBiaWdnZXN0VW5pdEZvclBhcnRpYWwgPSBkaWZmU2V2ZXJpdHk7XG4gICAgICAgIGlmIChiaWdnZXN0VW5pdEZvclBhcnRpYWwgPiAxICYmIC8vIHRoZSB0d28gZGF0ZXMgYXJlIGRpZmZlcmVudCBpbiBhIHdheSB0aGF0J3MgbGFyZ2VyIHNjYWxlIHRoYW4gdGltZVxuICAgICAgICAgICAgKHN0YW5kYXJkRGF0ZVByb3BzLnllYXIgPT09ICdudW1lcmljJyB8fCBzdGFuZGFyZERhdGVQcm9wcy55ZWFyID09PSAnMi1kaWdpdCcpICYmXG4gICAgICAgICAgICAoc3RhbmRhcmREYXRlUHJvcHMubW9udGggPT09ICdudW1lcmljJyB8fCBzdGFuZGFyZERhdGVQcm9wcy5tb250aCA9PT0gJzItZGlnaXQnKSAmJlxuICAgICAgICAgICAgKHN0YW5kYXJkRGF0ZVByb3BzLmRheSA9PT0gJ251bWVyaWMnIHx8IHN0YW5kYXJkRGF0ZVByb3BzLmRheSA9PT0gJzItZGlnaXQnKSkge1xuICAgICAgICAgICAgYmlnZ2VzdFVuaXRGb3JQYXJ0aWFsID0gMTsgLy8gbWFrZSBpdCBsb29rIGxpa2UgdGhlIGRhdGVzIGFyZSBvbmx5IGRpZmZlcmVudCBpbiB0ZXJtcyBvZiB0aW1lXG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZ1bGwwID0gdGhpcy5mb3JtYXQoc3RhcnQsIGNvbnRleHQpO1xuICAgICAgICBsZXQgZnVsbDEgPSB0aGlzLmZvcm1hdChlbmQsIGNvbnRleHQpO1xuICAgICAgICBpZiAoZnVsbDAgPT09IGZ1bGwxKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVsbDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcnRpYWxEYXRlUHJvcHMgPSBjb21wdXRlUGFydGlhbEZvcm1hdHRpbmdPcHRpb25zKHN0YW5kYXJkRGF0ZVByb3BzLCBiaWdnZXN0VW5pdEZvclBhcnRpYWwpO1xuICAgICAgICBsZXQgcGFydGlhbEZvcm1hdHRpbmdGdW5jID0gYnVpbGRGb3JtYXR0aW5nRnVuYyhwYXJ0aWFsRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzLCBjb250ZXh0KTtcbiAgICAgICAgbGV0IHBhcnRpYWwwID0gcGFydGlhbEZvcm1hdHRpbmdGdW5jKHN0YXJ0KTtcbiAgICAgICAgbGV0IHBhcnRpYWwxID0gcGFydGlhbEZvcm1hdHRpbmdGdW5jKGVuZCk7XG4gICAgICAgIGxldCBpbnNlcnRpb24gPSBmaW5kQ29tbW9uSW5zZXJ0aW9uKGZ1bGwwLCBwYXJ0aWFsMCwgZnVsbDEsIHBhcnRpYWwxKTtcbiAgICAgICAgbGV0IHNlcGFyYXRvciA9IGV4dGVuZGVkU2V0dGluZ3Muc2VwYXJhdG9yIHx8IGJldHRlckRlZmF1bHRTZXBhcmF0b3IgfHwgY29udGV4dC5kZWZhdWx0U2VwYXJhdG9yIHx8ICcnO1xuICAgICAgICBpZiAoaW5zZXJ0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zZXJ0aW9uLmJlZm9yZSArIHBhcnRpYWwwICsgc2VwYXJhdG9yICsgcGFydGlhbDEgKyBpbnNlcnRpb24uYWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bGwwICsgc2VwYXJhdG9yICsgZnVsbDE7XG4gICAgfVxuICAgIGdldExhcmdlc3RVbml0KCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuc2V2ZXJpdHkpIHtcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3llYXInO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHJldHVybiAnbW9udGgnO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHJldHVybiAnd2Vlayc7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdkYXknO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RpbWUnOyAvLyByZWFsbHk/XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBidWlsZEZvcm1hdHRpbmdGdW5jKHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzLCBjb250ZXh0KSB7XG4gICAgbGV0IHN0YW5kYXJkRGF0ZVByb3BDbnQgPSBPYmplY3Qua2V5cyhzdGFuZGFyZERhdGVQcm9wcykubGVuZ3RoO1xuICAgIGlmIChzdGFuZGFyZERhdGVQcm9wQ250ID09PSAxICYmIHN0YW5kYXJkRGF0ZVByb3BzLnRpbWVab25lTmFtZSA9PT0gJ3Nob3J0Jykge1xuICAgICAgICByZXR1cm4gKGRhdGUpID0+IChmb3JtYXRUaW1lWm9uZU9mZnNldChkYXRlLnRpbWVab25lT2Zmc2V0KSk7XG4gICAgfVxuICAgIGlmIChzdGFuZGFyZERhdGVQcm9wQ250ID09PSAwICYmIGV4dGVuZGVkU2V0dGluZ3Mud2Vlaykge1xuICAgICAgICByZXR1cm4gKGRhdGUpID0+IChmb3JtYXRXZWVrTnVtYmVyKGNvbnRleHQuY29tcHV0ZVdlZWtOdW1iZXIoZGF0ZS5tYXJrZXIpLCBjb250ZXh0LndlZWtUZXh0LCBjb250ZXh0LndlZWtUZXh0TG9uZywgY29udGV4dC5sb2NhbGUsIGV4dGVuZGVkU2V0dGluZ3Mud2VlaykpO1xuICAgIH1cbiAgICByZXR1cm4gYnVpbGROYXRpdmVGb3JtYXR0aW5nRnVuYyhzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCk7XG59XG5mdW5jdGlvbiBidWlsZE5hdGl2ZUZvcm1hdHRpbmdGdW5jKHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzLCBjb250ZXh0KSB7XG4gICAgc3RhbmRhcmREYXRlUHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBzdGFuZGFyZERhdGVQcm9wcyk7IC8vIGNvcHlcbiAgICBleHRlbmRlZFNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgZXh0ZW5kZWRTZXR0aW5ncyk7IC8vIGNvcHlcbiAgICBzYW5pdGl6ZVNldHRpbmdzKHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzKTtcbiAgICBzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZSA9ICdVVEMnOyAvLyB3ZSBsZXZlcmFnZSB0aGUgb25seSBndWFyYW50ZWVkIHRpbWVab25lIGZvciBvdXIgVVRDIG1hcmtlcnNcbiAgICBsZXQgbm9ybWFsRm9ybWF0ID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoY29udGV4dC5sb2NhbGUuY29kZXMsIHN0YW5kYXJkRGF0ZVByb3BzKTtcbiAgICBsZXQgemVyb0Zvcm1hdDsgLy8gbmVlZGVkP1xuICAgIGlmIChleHRlbmRlZFNldHRpbmdzLm9taXRaZXJvTWludXRlKSB7XG4gICAgICAgIGxldCB6ZXJvUHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBzdGFuZGFyZERhdGVQcm9wcyk7XG4gICAgICAgIGRlbGV0ZSB6ZXJvUHJvcHMubWludXRlOyAvLyBzZWNvbmRzIGFuZCBtcyB3ZXJlIGFscmVhZHkgY29uc2lkZXJlZCBpbiBzYW5pdGl6ZVNldHRpbmdzXG4gICAgICAgIHplcm9Gb3JtYXQgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChjb250ZXh0LmxvY2FsZS5jb2RlcywgemVyb1Byb3BzKTtcbiAgICB9XG4gICAgcmV0dXJuIChkYXRlKSA9PiB7XG4gICAgICAgIGxldCB7IG1hcmtlciB9ID0gZGF0ZTtcbiAgICAgICAgbGV0IGZvcm1hdDtcbiAgICAgICAgaWYgKHplcm9Gb3JtYXQgJiYgIW1hcmtlci5nZXRVVENNaW51dGVzKCkpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IHplcm9Gb3JtYXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBub3JtYWxGb3JtYXQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHMgPSBmb3JtYXQuZm9ybWF0KG1hcmtlcik7XG4gICAgICAgIHJldHVybiBwb3N0UHJvY2VzcyhzLCBkYXRlLCBzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHNhbml0aXplU2V0dGluZ3Moc3RhbmRhcmREYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MpIHtcbiAgICAvLyBkZWFsIHdpdGggYSBicm93c2VyIGluY29uc2lzdGVuY3kgd2hlcmUgZm9ybWF0dGluZyB0aGUgdGltZXpvbmVcbiAgICAvLyByZXF1aXJlcyB0aGF0IHRoZSBob3VyL21pbnV0ZSBiZSBwcmVzZW50LlxuICAgIGlmIChzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZU5hbWUpIHtcbiAgICAgICAgaWYgKCFzdGFuZGFyZERhdGVQcm9wcy5ob3VyKSB7XG4gICAgICAgICAgICBzdGFuZGFyZERhdGVQcm9wcy5ob3VyID0gJzItZGlnaXQnO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RhbmRhcmREYXRlUHJvcHMubWludXRlKSB7XG4gICAgICAgICAgICBzdGFuZGFyZERhdGVQcm9wcy5taW51dGUgPSAnMi1kaWdpdCc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gb25seSBzdXBwb3J0IHNob3J0IHRpbWV6b25lIG5hbWVzXG4gICAgaWYgKHN0YW5kYXJkRGF0ZVByb3BzLnRpbWVab25lTmFtZSA9PT0gJ2xvbmcnKSB7XG4gICAgICAgIHN0YW5kYXJkRGF0ZVByb3BzLnRpbWVab25lTmFtZSA9ICdzaG9ydCc7XG4gICAgfVxuICAgIC8vIGlmIHJlcXVlc3RpbmcgdG8gZGlzcGxheSBzZWNvbmRzLCBNVVNUIGRpc3BsYXkgbWludXRlc1xuICAgIGlmIChleHRlbmRlZFNldHRpbmdzLm9taXRaZXJvTWludXRlICYmIChzdGFuZGFyZERhdGVQcm9wcy5zZWNvbmQgfHwgc3RhbmRhcmREYXRlUHJvcHMubWlsbGlzZWNvbmQpKSB7XG4gICAgICAgIGRlbGV0ZSBleHRlbmRlZFNldHRpbmdzLm9taXRaZXJvTWludXRlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBvc3RQcm9jZXNzKHMsIGRhdGUsIHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzLCBjb250ZXh0KSB7XG4gICAgcyA9IHMucmVwbGFjZShMVFJfUkUsICcnKTsgLy8gcmVtb3ZlIGxlZnQtdG8tcmlnaHQgY29udHJvbCBjaGFycy4gZG8gZmlyc3QuIGdvb2QgZm9yIG90aGVyIHJlZ2V4ZXNcbiAgICBpZiAoc3RhbmRhcmREYXRlUHJvcHMudGltZVpvbmVOYW1lID09PSAnc2hvcnQnKSB7XG4gICAgICAgIHMgPSBpbmplY3RUem9TdHIocywgKGNvbnRleHQudGltZVpvbmUgPT09ICdVVEMnIHx8IGRhdGUudGltZVpvbmVPZmZzZXQgPT0gbnVsbCkgP1xuICAgICAgICAgICAgJ1VUQycgOiAvLyBpbXBvcnRhbnQgdG8gbm9ybWFsaXplIGZvciBJRSwgd2hpY2ggZG9lcyBcIkdNVFwiXG4gICAgICAgICAgICBmb3JtYXRUaW1lWm9uZU9mZnNldChkYXRlLnRpbWVab25lT2Zmc2V0KSk7XG4gICAgfVxuICAgIGlmIChleHRlbmRlZFNldHRpbmdzLm9taXRDb21tYXMpIHtcbiAgICAgICAgcyA9IHMucmVwbGFjZShDT01NQV9SRSwgJycpLnRyaW0oKTtcbiAgICB9XG4gICAgaWYgKGV4dGVuZGVkU2V0dGluZ3Mub21pdFplcm9NaW51dGUpIHtcbiAgICAgICAgcyA9IHMucmVwbGFjZSgnOjAwJywgJycpOyAvLyB6ZXJvRm9ybWF0IGRvZXNuJ3QgYWx3YXlzIGFjaGlldmUgdGhpc1xuICAgIH1cbiAgICAvLyBeIGRvIGFueXRoaW5nIHRoYXQgbWlnaHQgY3JlYXRlIGFkamFjZW50IHNwYWNlcyBiZWZvcmUgdGhpcyBwb2ludCxcbiAgICAvLyBiZWNhdXNlIE1FUklESUVNX1JFIGxpa2VzIHRvIGVhdCB1cCBsb2FkaW5nIHNwYWNlc1xuICAgIGlmIChleHRlbmRlZFNldHRpbmdzLm1lcmlkaWVtID09PSBmYWxzZSkge1xuICAgICAgICBzID0gcy5yZXBsYWNlKE1FUklESUVNX1JFLCAnJykudHJpbSgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHRlbmRlZFNldHRpbmdzLm1lcmlkaWVtID09PSAnbmFycm93JykgeyAvLyBhL3BcbiAgICAgICAgcyA9IHMucmVwbGFjZShNRVJJRElFTV9SRSwgKG0wLCBtMSkgPT4gbTEudG9Mb2NhbGVMb3dlckNhc2UoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4dGVuZGVkU2V0dGluZ3MubWVyaWRpZW0gPT09ICdzaG9ydCcpIHsgLy8gYW0vcG1cbiAgICAgICAgcyA9IHMucmVwbGFjZShNRVJJRElFTV9SRSwgKG0wLCBtMSkgPT4gYCR7bTEudG9Mb2NhbGVMb3dlckNhc2UoKX1tYCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4dGVuZGVkU2V0dGluZ3MubWVyaWRpZW0gPT09ICdsb3dlcmNhc2UnKSB7IC8vIG90aGVyIG1lcmlkaWVtIHRyYW5zZm9ybWVycyBhbHJlYWR5IGNvbnZlcnRlZCB0byBsb3dlcmNhc2VcbiAgICAgICAgcyA9IHMucmVwbGFjZShNRVJJRElFTV9SRSwgKG0wKSA9PiBtMC50b0xvY2FsZUxvd2VyQ2FzZSgpKTtcbiAgICB9XG4gICAgcyA9IHMucmVwbGFjZShNVUxUSV9TUEFDRV9SRSwgJyAnKTtcbiAgICBzID0gcy50cmltKCk7XG4gICAgcmV0dXJuIHM7XG59XG5mdW5jdGlvbiBpbmplY3RUem9TdHIocywgdHpvU3RyKSB7XG4gICAgbGV0IHJlcGxhY2VkID0gZmFsc2U7XG4gICAgcyA9IHMucmVwbGFjZShVVENfUkUsICgpID0+IHtcbiAgICAgICAgcmVwbGFjZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHpvU3RyO1xuICAgIH0pO1xuICAgIC8vIElFMTEgZG9lc24ndCBpbmNsdWRlIFVUQy9HTVQgaW4gdGhlIG9yaWdpbmFsIHN0cmluZywgc28gYXBwZW5kIHRvIGVuZFxuICAgIGlmICghcmVwbGFjZWQpIHtcbiAgICAgICAgcyArPSBgICR7dHpvU3RyfWA7XG4gICAgfVxuICAgIHJldHVybiBzO1xufVxuZnVuY3Rpb24gZm9ybWF0V2Vla051bWJlcihudW0sIHdlZWtUZXh0LCB3ZWVrVGV4dExvbmcsIGxvY2FsZSwgZGlzcGxheSkge1xuICAgIGxldCBwYXJ0cyA9IFtdO1xuICAgIGlmIChkaXNwbGF5ID09PSAnbG9uZycpIHtcbiAgICAgICAgcGFydHMucHVzaCh3ZWVrVGV4dExvbmcpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkaXNwbGF5ID09PSAnc2hvcnQnIHx8IGRpc3BsYXkgPT09ICduYXJyb3cnKSB7XG4gICAgICAgIHBhcnRzLnB1c2god2Vla1RleHQpO1xuICAgIH1cbiAgICBpZiAoZGlzcGxheSA9PT0gJ2xvbmcnIHx8IGRpc3BsYXkgPT09ICdzaG9ydCcpIHtcbiAgICAgICAgcGFydHMucHVzaCgnICcpO1xuICAgIH1cbiAgICBwYXJ0cy5wdXNoKGxvY2FsZS5zaW1wbGVOdW1iZXJGb3JtYXQuZm9ybWF0KG51bSkpO1xuICAgIGlmIChsb2NhbGUub3B0aW9ucy5kaXJlY3Rpb24gPT09ICdydGwnKSB7IC8vIFRPRE86IHVzZSBjb250cm9sIGNoYXJhY3RlcnMgaW5zdGVhZD9cbiAgICAgICAgcGFydHMucmV2ZXJzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gcGFydHMuam9pbignJyk7XG59XG4vLyBSYW5nZSBGb3JtYXR0aW5nIFV0aWxzXG4vLyAwID0gZXhhY3RseSB0aGUgc2FtZVxuLy8gMSA9IGRpZmZlcmVudCBieSB0aW1lXG4vLyBhbmQgYmlnZ2VyXG5mdW5jdGlvbiBjb21wdXRlTWFya2VyRGlmZlNldmVyaXR5KGQwLCBkMSwgY2EpIHtcbiAgICBpZiAoY2EuZ2V0TWFya2VyWWVhcihkMCkgIT09IGNhLmdldE1hcmtlclllYXIoZDEpKSB7XG4gICAgICAgIHJldHVybiA1O1xuICAgIH1cbiAgICBpZiAoY2EuZ2V0TWFya2VyTW9udGgoZDApICE9PSBjYS5nZXRNYXJrZXJNb250aChkMSkpIHtcbiAgICAgICAgcmV0dXJuIDQ7XG4gICAgfVxuICAgIGlmIChjYS5nZXRNYXJrZXJEYXkoZDApICE9PSBjYS5nZXRNYXJrZXJEYXkoZDEpKSB7XG4gICAgICAgIHJldHVybiAyO1xuICAgIH1cbiAgICBpZiAodGltZUFzTXMoZDApICE9PSB0aW1lQXNNcyhkMSkpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuZnVuY3Rpb24gY29tcHV0ZVBhcnRpYWxGb3JtYXR0aW5nT3B0aW9ucyhvcHRpb25zLCBiaWdnZXN0VW5pdCkge1xuICAgIGxldCBwYXJ0aWFsT3B0aW9ucyA9IHt9O1xuICAgIGZvciAobGV0IG5hbWUgaW4gb3B0aW9ucykge1xuICAgICAgICBpZiAoIShuYW1lIGluIFNUQU5EQVJEX0RBVEVfUFJPUF9TRVZFUklUSUVTKSB8fCAvLyBub3QgYSBkYXRlIHBhcnQgcHJvcCAobGlrZSB0aW1lWm9uZSlcbiAgICAgICAgICAgIFNUQU5EQVJEX0RBVEVfUFJPUF9TRVZFUklUSUVTW25hbWVdIDw9IGJpZ2dlc3RVbml0KSB7XG4gICAgICAgICAgICBwYXJ0aWFsT3B0aW9uc1tuYW1lXSA9IG9wdGlvbnNbbmFtZV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnRpYWxPcHRpb25zO1xufVxuZnVuY3Rpb24gZmluZENvbW1vbkluc2VydGlvbihmdWxsMCwgcGFydGlhbDAsIGZ1bGwxLCBwYXJ0aWFsMSkge1xuICAgIGxldCBpMCA9IDA7XG4gICAgd2hpbGUgKGkwIDwgZnVsbDAubGVuZ3RoKSB7XG4gICAgICAgIGxldCBmb3VuZDAgPSBmdWxsMC5pbmRleE9mKHBhcnRpYWwwLCBpMCk7XG4gICAgICAgIGlmIChmb3VuZDAgPT09IC0xKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBsZXQgYmVmb3JlMCA9IGZ1bGwwLnN1YnN0cigwLCBmb3VuZDApO1xuICAgICAgICBpMCA9IGZvdW5kMCArIHBhcnRpYWwwLmxlbmd0aDtcbiAgICAgICAgbGV0IGFmdGVyMCA9IGZ1bGwwLnN1YnN0cihpMCk7XG4gICAgICAgIGxldCBpMSA9IDA7XG4gICAgICAgIHdoaWxlIChpMSA8IGZ1bGwxLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGZvdW5kMSA9IGZ1bGwxLmluZGV4T2YocGFydGlhbDEsIGkxKTtcbiAgICAgICAgICAgIGlmIChmb3VuZDEgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYmVmb3JlMSA9IGZ1bGwxLnN1YnN0cigwLCBmb3VuZDEpO1xuICAgICAgICAgICAgaTEgPSBmb3VuZDEgKyBwYXJ0aWFsMS5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgYWZ0ZXIxID0gZnVsbDEuc3Vic3RyKGkxKTtcbiAgICAgICAgICAgIGlmIChiZWZvcmUwID09PSBiZWZvcmUxICYmIGFmdGVyMCA9PT0gYWZ0ZXIxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlOiBiZWZvcmUwLFxuICAgICAgICAgICAgICAgICAgICBhZnRlcjogYWZ0ZXIwLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGV4cGFuZFpvbmVkTWFya2VyKGRhdGVJbmZvLCBjYWxlbmRhclN5c3RlbSkge1xuICAgIGxldCBhID0gY2FsZW5kYXJTeXN0ZW0ubWFya2VyVG9BcnJheShkYXRlSW5mby5tYXJrZXIpO1xuICAgIHJldHVybiB7XG4gICAgICAgIG1hcmtlcjogZGF0ZUluZm8ubWFya2VyLFxuICAgICAgICB0aW1lWm9uZU9mZnNldDogZGF0ZUluZm8udGltZVpvbmVPZmZzZXQsXG4gICAgICAgIGFycmF5OiBhLFxuICAgICAgICB5ZWFyOiBhWzBdLFxuICAgICAgICBtb250aDogYVsxXSxcbiAgICAgICAgZGF5OiBhWzJdLFxuICAgICAgICBob3VyOiBhWzNdLFxuICAgICAgICBtaW51dGU6IGFbNF0sXG4gICAgICAgIHNlY29uZDogYVs1XSxcbiAgICAgICAgbWlsbGlzZWNvbmQ6IGFbNl0sXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVmVyYm9zZUZvcm1hdHRpbmdBcmcoc3RhcnQsIGVuZCwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikge1xuICAgIGxldCBzdGFydEluZm8gPSBleHBhbmRab25lZE1hcmtlcihzdGFydCwgY29udGV4dC5jYWxlbmRhclN5c3RlbSk7XG4gICAgbGV0IGVuZEluZm8gPSBlbmQgPyBleHBhbmRab25lZE1hcmtlcihlbmQsIGNvbnRleHQuY2FsZW5kYXJTeXN0ZW0pIDogbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICBkYXRlOiBzdGFydEluZm8sXG4gICAgICAgIHN0YXJ0OiBzdGFydEluZm8sXG4gICAgICAgIGVuZDogZW5kSW5mbyxcbiAgICAgICAgdGltZVpvbmU6IGNvbnRleHQudGltZVpvbmUsXG4gICAgICAgIGxvY2FsZUNvZGVzOiBjb250ZXh0LmxvY2FsZS5jb2RlcyxcbiAgICAgICAgZGVmYXVsdFNlcGFyYXRvcjogYmV0dGVyRGVmYXVsdFNlcGFyYXRvciB8fCBjb250ZXh0LmRlZmF1bHRTZXBhcmF0b3IsXG4gICAgfTtcbn1cblxuLypcblRPRE86IGZpeCB0aGUgdGVybWlub2xvZ3kgb2YgXCJmb3JtYXR0ZXJcIiB2cyBcImZvcm1hdHRpbmcgZnVuY1wiXG4qL1xuLypcbkF0IHRoZSB0aW1lIG9mIGluc3RhbnRpYXRpb24sIHRoaXMgb2JqZWN0IGRvZXMgbm90IGtub3cgd2hpY2ggY21kLWZvcm1hdHRpbmcgc3lzdGVtIGl0IHdpbGwgdXNlLlxuSXQgcmVjZWl2ZXMgdGhpcyBhdCB0aGUgdGltZSBvZiBmb3JtYXR0aW5nLCBhcyBhIHNldHRpbmcuXG4qL1xuY2xhc3MgQ21kRm9ybWF0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihjbWRTdHIpIHtcbiAgICAgICAgdGhpcy5jbWRTdHIgPSBjbWRTdHI7XG4gICAgfVxuICAgIGZvcm1hdChkYXRlLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmNtZEZvcm1hdHRlcih0aGlzLmNtZFN0ciwgY3JlYXRlVmVyYm9zZUZvcm1hdHRpbmdBcmcoZGF0ZSwgbnVsbCwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikpO1xuICAgIH1cbiAgICBmb3JtYXRSYW5nZShzdGFydCwgZW5kLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmNtZEZvcm1hdHRlcih0aGlzLmNtZFN0ciwgY3JlYXRlVmVyYm9zZUZvcm1hdHRpbmdBcmcoc3RhcnQsIGVuZCwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikpO1xuICAgIH1cbn1cblxuY2xhc3MgRnVuY0Zvcm1hdHRlciB7XG4gICAgY29uc3RydWN0b3IoZnVuYykge1xuICAgICAgICB0aGlzLmZ1bmMgPSBmdW5jO1xuICAgIH1cbiAgICBmb3JtYXQoZGF0ZSwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5mdW5jKGNyZWF0ZVZlcmJvc2VGb3JtYXR0aW5nQXJnKGRhdGUsIG51bGwsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpKTtcbiAgICB9XG4gICAgZm9ybWF0UmFuZ2Uoc3RhcnQsIGVuZCwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5mdW5jKGNyZWF0ZVZlcmJvc2VGb3JtYXR0aW5nQXJnKHN0YXJ0LCBlbmQsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZvcm1hdHRlcihpbnB1dCkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmIGlucHV0KSB7IC8vIG5vbi1udWxsIG9iamVjdFxuICAgICAgICByZXR1cm4gbmV3IE5hdGl2ZUZvcm1hdHRlcihpbnB1dCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ21kRm9ybWF0dGVyKGlucHV0KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IEZ1bmNGb3JtYXR0ZXIoaW5wdXQpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuLy8gYmFzZSBvcHRpb25zXG4vLyAtLS0tLS0tLS0tLS1cbmNvbnN0IEJBU0VfT1BUSU9OX1JFRklORVJTID0ge1xuICAgIG5hdkxpbmtEYXlDbGljazogaWRlbnRpdHksXG4gICAgbmF2TGlua1dlZWtDbGljazogaWRlbnRpdHksXG4gICAgZHVyYXRpb246IGNyZWF0ZUR1cmF0aW9uLFxuICAgIGJvb3RzdHJhcEZvbnRBd2Vzb21lOiBpZGVudGl0eSxcbiAgICBidXR0b25JY29uczogaWRlbnRpdHksXG4gICAgY3VzdG9tQnV0dG9uczogaWRlbnRpdHksXG4gICAgZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb246IGNyZWF0ZUR1cmF0aW9uLFxuICAgIGRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb246IGNyZWF0ZUR1cmF0aW9uLFxuICAgIG5leHREYXlUaHJlc2hvbGQ6IGNyZWF0ZUR1cmF0aW9uLFxuICAgIHNjcm9sbFRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxuICAgIHNjcm9sbFRpbWVSZXNldDogQm9vbGVhbixcbiAgICBzbG90TWluVGltZTogY3JlYXRlRHVyYXRpb24sXG4gICAgc2xvdE1heFRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxuICAgIGRheVBvcG92ZXJGb3JtYXQ6IGNyZWF0ZUZvcm1hdHRlcixcbiAgICBzbG90RHVyYXRpb246IGNyZWF0ZUR1cmF0aW9uLFxuICAgIHNuYXBEdXJhdGlvbjogY3JlYXRlRHVyYXRpb24sXG4gICAgaGVhZGVyVG9vbGJhcjogaWRlbnRpdHksXG4gICAgZm9vdGVyVG9vbGJhcjogaWRlbnRpdHksXG4gICAgZGVmYXVsdFJhbmdlU2VwYXJhdG9yOiBTdHJpbmcsXG4gICAgdGl0bGVSYW5nZVNlcGFyYXRvcjogU3RyaW5nLFxuICAgIGZvcmNlRXZlbnREdXJhdGlvbjogQm9vbGVhbixcbiAgICBkYXlIZWFkZXJzOiBCb29sZWFuLFxuICAgIGRheUhlYWRlckZvcm1hdDogY3JlYXRlRm9ybWF0dGVyLFxuICAgIGRheUhlYWRlckNsYXNzTmFtZXM6IGlkZW50aXR5LFxuICAgIGRheUhlYWRlckNvbnRlbnQ6IGlkZW50aXR5LFxuICAgIGRheUhlYWRlckRpZE1vdW50OiBpZGVudGl0eSxcbiAgICBkYXlIZWFkZXJXaWxsVW5tb3VudDogaWRlbnRpdHksXG4gICAgZGF5Q2VsbENsYXNzTmFtZXM6IGlkZW50aXR5LFxuICAgIGRheUNlbGxDb250ZW50OiBpZGVudGl0eSxcbiAgICBkYXlDZWxsRGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIGRheUNlbGxXaWxsVW5tb3VudDogaWRlbnRpdHksXG4gICAgaW5pdGlhbFZpZXc6IFN0cmluZyxcbiAgICBhc3BlY3RSYXRpbzogTnVtYmVyLFxuICAgIHdlZWtlbmRzOiBCb29sZWFuLFxuICAgIHdlZWtOdW1iZXJDYWxjdWxhdGlvbjogaWRlbnRpdHksXG4gICAgd2Vla051bWJlcnM6IEJvb2xlYW4sXG4gICAgd2Vla051bWJlckNsYXNzTmFtZXM6IGlkZW50aXR5LFxuICAgIHdlZWtOdW1iZXJDb250ZW50OiBpZGVudGl0eSxcbiAgICB3ZWVrTnVtYmVyRGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIHdlZWtOdW1iZXJXaWxsVW5tb3VudDogaWRlbnRpdHksXG4gICAgZWRpdGFibGU6IEJvb2xlYW4sXG4gICAgdmlld0NsYXNzTmFtZXM6IGlkZW50aXR5LFxuICAgIHZpZXdEaWRNb3VudDogaWRlbnRpdHksXG4gICAgdmlld1dpbGxVbm1vdW50OiBpZGVudGl0eSxcbiAgICBub3dJbmRpY2F0b3I6IEJvb2xlYW4sXG4gICAgbm93SW5kaWNhdG9yQ2xhc3NOYW1lczogaWRlbnRpdHksXG4gICAgbm93SW5kaWNhdG9yQ29udGVudDogaWRlbnRpdHksXG4gICAgbm93SW5kaWNhdG9yRGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIG5vd0luZGljYXRvcldpbGxVbm1vdW50OiBpZGVudGl0eSxcbiAgICBzaG93Tm9uQ3VycmVudERhdGVzOiBCb29sZWFuLFxuICAgIGxhenlGZXRjaGluZzogQm9vbGVhbixcbiAgICBzdGFydFBhcmFtOiBTdHJpbmcsXG4gICAgZW5kUGFyYW06IFN0cmluZyxcbiAgICB0aW1lWm9uZVBhcmFtOiBTdHJpbmcsXG4gICAgdGltZVpvbmU6IFN0cmluZyxcbiAgICBsb2NhbGVzOiBpZGVudGl0eSxcbiAgICBsb2NhbGU6IGlkZW50aXR5LFxuICAgIHRoZW1lU3lzdGVtOiBTdHJpbmcsXG4gICAgZHJhZ1JldmVydER1cmF0aW9uOiBOdW1iZXIsXG4gICAgZHJhZ1Njcm9sbDogQm9vbGVhbixcbiAgICBhbGxEYXlNYWludGFpbkR1cmF0aW9uOiBCb29sZWFuLFxuICAgIHVuc2VsZWN0QXV0bzogQm9vbGVhbixcbiAgICBkcm9wQWNjZXB0OiBpZGVudGl0eSxcbiAgICBldmVudE9yZGVyOiBwYXJzZUZpZWxkU3BlY3MsXG4gICAgZXZlbnRPcmRlclN0cmljdDogQm9vbGVhbixcbiAgICBoYW5kbGVXaW5kb3dSZXNpemU6IEJvb2xlYW4sXG4gICAgd2luZG93UmVzaXplRGVsYXk6IE51bWJlcixcbiAgICBsb25nUHJlc3NEZWxheTogTnVtYmVyLFxuICAgIGV2ZW50RHJhZ01pbkRpc3RhbmNlOiBOdW1iZXIsXG4gICAgZXhwYW5kUm93czogQm9vbGVhbixcbiAgICBoZWlnaHQ6IGlkZW50aXR5LFxuICAgIGNvbnRlbnRIZWlnaHQ6IGlkZW50aXR5LFxuICAgIGRpcmVjdGlvbjogU3RyaW5nLFxuICAgIHdlZWtOdW1iZXJGb3JtYXQ6IGNyZWF0ZUZvcm1hdHRlcixcbiAgICBldmVudFJlc2l6YWJsZUZyb21TdGFydDogQm9vbGVhbixcbiAgICBkaXNwbGF5RXZlbnRUaW1lOiBCb29sZWFuLFxuICAgIGRpc3BsYXlFdmVudEVuZDogQm9vbGVhbixcbiAgICB3ZWVrVGV4dDogU3RyaW5nLFxuICAgIHdlZWtUZXh0TG9uZzogU3RyaW5nLFxuICAgIHByb2dyZXNzaXZlRXZlbnRSZW5kZXJpbmc6IEJvb2xlYW4sXG4gICAgYnVzaW5lc3NIb3VyczogaWRlbnRpdHksXG4gICAgaW5pdGlhbERhdGU6IGlkZW50aXR5LFxuICAgIG5vdzogaWRlbnRpdHksXG4gICAgZXZlbnREYXRhVHJhbnNmb3JtOiBpZGVudGl0eSxcbiAgICBzdGlja3lIZWFkZXJEYXRlczogaWRlbnRpdHksXG4gICAgc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyOiBpZGVudGl0eSxcbiAgICB2aWV3SGVpZ2h0OiBpZGVudGl0eSxcbiAgICBkZWZhdWx0QWxsRGF5OiBCb29sZWFuLFxuICAgIGV2ZW50U291cmNlRmFpbHVyZTogaWRlbnRpdHksXG4gICAgZXZlbnRTb3VyY2VTdWNjZXNzOiBpZGVudGl0eSxcbiAgICBldmVudERpc3BsYXk6IFN0cmluZyxcbiAgICBldmVudFN0YXJ0RWRpdGFibGU6IEJvb2xlYW4sXG4gICAgZXZlbnREdXJhdGlvbkVkaXRhYmxlOiBCb29sZWFuLFxuICAgIGV2ZW50T3ZlcmxhcDogaWRlbnRpdHksXG4gICAgZXZlbnRDb25zdHJhaW50OiBpZGVudGl0eSxcbiAgICBldmVudEFsbG93OiBpZGVudGl0eSxcbiAgICBldmVudEJhY2tncm91bmRDb2xvcjogU3RyaW5nLFxuICAgIGV2ZW50Qm9yZGVyQ29sb3I6IFN0cmluZyxcbiAgICBldmVudFRleHRDb2xvcjogU3RyaW5nLFxuICAgIGV2ZW50Q29sb3I6IFN0cmluZyxcbiAgICBldmVudENsYXNzTmFtZXM6IGlkZW50aXR5LFxuICAgIGV2ZW50Q29udGVudDogaWRlbnRpdHksXG4gICAgZXZlbnREaWRNb3VudDogaWRlbnRpdHksXG4gICAgZXZlbnRXaWxsVW5tb3VudDogaWRlbnRpdHksXG4gICAgc2VsZWN0Q29uc3RyYWludDogaWRlbnRpdHksXG4gICAgc2VsZWN0T3ZlcmxhcDogaWRlbnRpdHksXG4gICAgc2VsZWN0QWxsb3c6IGlkZW50aXR5LFxuICAgIGRyb3BwYWJsZTogQm9vbGVhbixcbiAgICB1bnNlbGVjdENhbmNlbDogU3RyaW5nLFxuICAgIHNsb3RMYWJlbEZvcm1hdDogaWRlbnRpdHksXG4gICAgc2xvdExhbmVDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBzbG90TGFuZUNvbnRlbnQ6IGlkZW50aXR5LFxuICAgIHNsb3RMYW5lRGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIHNsb3RMYW5lV2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIHNsb3RMYWJlbENsYXNzTmFtZXM6IGlkZW50aXR5LFxuICAgIHNsb3RMYWJlbENvbnRlbnQ6IGlkZW50aXR5LFxuICAgIHNsb3RMYWJlbERpZE1vdW50OiBpZGVudGl0eSxcbiAgICBzbG90TGFiZWxXaWxsVW5tb3VudDogaWRlbnRpdHksXG4gICAgZGF5TWF4RXZlbnRzOiBpZGVudGl0eSxcbiAgICBkYXlNYXhFdmVudFJvd3M6IGlkZW50aXR5LFxuICAgIGRheU1pbldpZHRoOiBOdW1iZXIsXG4gICAgc2xvdExhYmVsSW50ZXJ2YWw6IGNyZWF0ZUR1cmF0aW9uLFxuICAgIGFsbERheVRleHQ6IFN0cmluZyxcbiAgICBhbGxEYXlDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBhbGxEYXlDb250ZW50OiBpZGVudGl0eSxcbiAgICBhbGxEYXlEaWRNb3VudDogaWRlbnRpdHksXG4gICAgYWxsRGF5V2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIHNsb3RNaW5XaWR0aDogTnVtYmVyLFxuICAgIG5hdkxpbmtzOiBCb29sZWFuLFxuICAgIGV2ZW50VGltZUZvcm1hdDogY3JlYXRlRm9ybWF0dGVyLFxuICAgIHJlcmVuZGVyRGVsYXk6IE51bWJlcixcbiAgICBtb3JlTGlua1RleHQ6IGlkZW50aXR5LFxuICAgIG1vcmVMaW5rSGludDogaWRlbnRpdHksXG4gICAgc2VsZWN0TWluRGlzdGFuY2U6IE51bWJlcixcbiAgICBzZWxlY3RhYmxlOiBCb29sZWFuLFxuICAgIHNlbGVjdExvbmdQcmVzc0RlbGF5OiBOdW1iZXIsXG4gICAgZXZlbnRMb25nUHJlc3NEZWxheTogTnVtYmVyLFxuICAgIHNlbGVjdE1pcnJvcjogQm9vbGVhbixcbiAgICBldmVudE1heFN0YWNrOiBOdW1iZXIsXG4gICAgZXZlbnRNaW5IZWlnaHQ6IE51bWJlcixcbiAgICBldmVudE1pbldpZHRoOiBOdW1iZXIsXG4gICAgZXZlbnRTaG9ydEhlaWdodDogTnVtYmVyLFxuICAgIHNsb3RFdmVudE92ZXJsYXA6IEJvb2xlYW4sXG4gICAgcGx1Z2luczogaWRlbnRpdHksXG4gICAgZmlyc3REYXk6IE51bWJlcixcbiAgICBkYXlDb3VudDogTnVtYmVyLFxuICAgIGRhdGVBbGlnbm1lbnQ6IFN0cmluZyxcbiAgICBkYXRlSW5jcmVtZW50OiBjcmVhdGVEdXJhdGlvbixcbiAgICBoaWRkZW5EYXlzOiBpZGVudGl0eSxcbiAgICBmaXhlZFdlZWtDb3VudDogQm9vbGVhbixcbiAgICB2YWxpZFJhbmdlOiBpZGVudGl0eSxcbiAgICB2aXNpYmxlUmFuZ2U6IGlkZW50aXR5LFxuICAgIHRpdGxlRm9ybWF0OiBpZGVudGl0eSxcbiAgICBldmVudEludGVyYWN0aXZlOiBCb29sZWFuLFxuICAgIC8vIG9ubHkgdXNlZCBieSBsaXN0LXZpZXcsIGJ1dCBsYW5ndWFnZXMgZGVmaW5lIHRoZSB2YWx1ZSwgc28gd2UgbmVlZCBpdCBpbiBiYXNlIG9wdGlvbnNcbiAgICBub0V2ZW50c1RleHQ6IFN0cmluZyxcbiAgICB2aWV3SGludDogaWRlbnRpdHksXG4gICAgbmF2TGlua0hpbnQ6IGlkZW50aXR5LFxuICAgIGNsb3NlSGludDogU3RyaW5nLFxuICAgIHRpbWVIaW50OiBTdHJpbmcsXG4gICAgZXZlbnRIaW50OiBTdHJpbmcsXG4gICAgbW9yZUxpbmtDbGljazogaWRlbnRpdHksXG4gICAgbW9yZUxpbmtDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBtb3JlTGlua0NvbnRlbnQ6IGlkZW50aXR5LFxuICAgIG1vcmVMaW5rRGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIG1vcmVMaW5rV2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIG1vbnRoU3RhcnRGb3JtYXQ6IGNyZWF0ZUZvcm1hdHRlcixcbiAgICAvLyBmb3IgY29ubmVjdG9yc1xuICAgIC8vIChjYW4ndCBiZSBwYXJ0IG9mIHBsdWdpbiBzeXN0ZW0gYi9jIG11c3QgYmUgcHJvdmlkZWQgYXQgcnVudGltZSlcbiAgICBoYW5kbGVDdXN0b21SZW5kZXJpbmc6IGlkZW50aXR5LFxuICAgIGN1c3RvbVJlbmRlcmluZ01ldGFNYXA6IGlkZW50aXR5LFxuICAgIGN1c3RvbVJlbmRlcmluZ1JlcGxhY2VzOiBCb29sZWFuLFxufTtcbi8vIGRvIE5PVCBnaXZlIGEgdHlwZSBoZXJlLiBuZWVkIGB0eXBlb2YgQkFTRV9PUFRJT05fREVGQVVMVFNgIHRvIGdpdmUgcmVhbCByZXN1bHRzLlxuLy8gcmF3IHZhbHVlcy5cbmNvbnN0IEJBU0VfT1BUSU9OX0RFRkFVTFRTID0ge1xuICAgIGV2ZW50RGlzcGxheTogJ2F1dG8nLFxuICAgIGRlZmF1bHRSYW5nZVNlcGFyYXRvcjogJyAtICcsXG4gICAgdGl0bGVSYW5nZVNlcGFyYXRvcjogJyBcXHUyMDEzICcsXG4gICAgZGVmYXVsdFRpbWVkRXZlbnREdXJhdGlvbjogJzAxOjAwOjAwJyxcbiAgICBkZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbjogeyBkYXk6IDEgfSxcbiAgICBmb3JjZUV2ZW50RHVyYXRpb246IGZhbHNlLFxuICAgIG5leHREYXlUaHJlc2hvbGQ6ICcwMDowMDowMCcsXG4gICAgZGF5SGVhZGVyczogdHJ1ZSxcbiAgICBpbml0aWFsVmlldzogJycsXG4gICAgYXNwZWN0UmF0aW86IDEuMzUsXG4gICAgaGVhZGVyVG9vbGJhcjoge1xuICAgICAgICBzdGFydDogJ3RpdGxlJyxcbiAgICAgICAgY2VudGVyOiAnJyxcbiAgICAgICAgZW5kOiAndG9kYXkgcHJldixuZXh0JyxcbiAgICB9LFxuICAgIHdlZWtlbmRzOiB0cnVlLFxuICAgIHdlZWtOdW1iZXJzOiBmYWxzZSxcbiAgICB3ZWVrTnVtYmVyQ2FsY3VsYXRpb246ICdsb2NhbCcsXG4gICAgZWRpdGFibGU6IGZhbHNlLFxuICAgIG5vd0luZGljYXRvcjogZmFsc2UsXG4gICAgc2Nyb2xsVGltZTogJzA2OjAwOjAwJyxcbiAgICBzY3JvbGxUaW1lUmVzZXQ6IHRydWUsXG4gICAgc2xvdE1pblRpbWU6ICcwMDowMDowMCcsXG4gICAgc2xvdE1heFRpbWU6ICcyNDowMDowMCcsXG4gICAgc2hvd05vbkN1cnJlbnREYXRlczogdHJ1ZSxcbiAgICBsYXp5RmV0Y2hpbmc6IHRydWUsXG4gICAgc3RhcnRQYXJhbTogJ3N0YXJ0JyxcbiAgICBlbmRQYXJhbTogJ2VuZCcsXG4gICAgdGltZVpvbmVQYXJhbTogJ3RpbWVab25lJyxcbiAgICB0aW1lWm9uZTogJ2xvY2FsJyxcbiAgICBsb2NhbGVzOiBbXSxcbiAgICBsb2NhbGU6ICcnLFxuICAgIHRoZW1lU3lzdGVtOiAnc3RhbmRhcmQnLFxuICAgIGRyYWdSZXZlcnREdXJhdGlvbjogNTAwLFxuICAgIGRyYWdTY3JvbGw6IHRydWUsXG4gICAgYWxsRGF5TWFpbnRhaW5EdXJhdGlvbjogZmFsc2UsXG4gICAgdW5zZWxlY3RBdXRvOiB0cnVlLFxuICAgIGRyb3BBY2NlcHQ6ICcqJyxcbiAgICBldmVudE9yZGVyOiAnc3RhcnQsLWR1cmF0aW9uLGFsbERheSx0aXRsZScsXG4gICAgZGF5UG9wb3ZlckZvcm1hdDogeyBtb250aDogJ2xvbmcnLCBkYXk6ICdudW1lcmljJywgeWVhcjogJ251bWVyaWMnIH0sXG4gICAgaGFuZGxlV2luZG93UmVzaXplOiB0cnVlLFxuICAgIHdpbmRvd1Jlc2l6ZURlbGF5OiAxMDAsXG4gICAgbG9uZ1ByZXNzRGVsYXk6IDEwMDAsXG4gICAgZXZlbnREcmFnTWluRGlzdGFuY2U6IDUsXG4gICAgZXhwYW5kUm93czogZmFsc2UsXG4gICAgbmF2TGlua3M6IGZhbHNlLFxuICAgIHNlbGVjdGFibGU6IGZhbHNlLFxuICAgIGV2ZW50TWluSGVpZ2h0OiAxNSxcbiAgICBldmVudE1pbldpZHRoOiAzMCxcbiAgICBldmVudFNob3J0SGVpZ2h0OiAzMCxcbiAgICBtb250aFN0YXJ0Rm9ybWF0OiB7IG1vbnRoOiAnbG9uZycsIGRheTogJ251bWVyaWMnIH0sXG59O1xuLy8gY2FsZW5kYXIgbGlzdGVuZXJzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS1cbmNvbnN0IENBTEVOREFSX0xJU1RFTkVSX1JFRklORVJTID0ge1xuICAgIGRhdGVzU2V0OiBpZGVudGl0eSxcbiAgICBldmVudHNTZXQ6IGlkZW50aXR5LFxuICAgIGV2ZW50QWRkOiBpZGVudGl0eSxcbiAgICBldmVudENoYW5nZTogaWRlbnRpdHksXG4gICAgZXZlbnRSZW1vdmU6IGlkZW50aXR5LFxuICAgIHdpbmRvd1Jlc2l6ZTogaWRlbnRpdHksXG4gICAgZXZlbnRDbGljazogaWRlbnRpdHksXG4gICAgZXZlbnRNb3VzZUVudGVyOiBpZGVudGl0eSxcbiAgICBldmVudE1vdXNlTGVhdmU6IGlkZW50aXR5LFxuICAgIHNlbGVjdDogaWRlbnRpdHksXG4gICAgdW5zZWxlY3Q6IGlkZW50aXR5LFxuICAgIGxvYWRpbmc6IGlkZW50aXR5LFxuICAgIC8vIGludGVybmFsXG4gICAgX3VubW91bnQ6IGlkZW50aXR5LFxuICAgIF9iZWZvcmVwcmludDogaWRlbnRpdHksXG4gICAgX2FmdGVycHJpbnQ6IGlkZW50aXR5LFxuICAgIF9ub0V2ZW50RHJvcDogaWRlbnRpdHksXG4gICAgX25vRXZlbnRSZXNpemU6IGlkZW50aXR5LFxuICAgIF9yZXNpemU6IGlkZW50aXR5LFxuICAgIF9zY3JvbGxSZXF1ZXN0OiBpZGVudGl0eSxcbn07XG4vLyBjYWxlbmRhci1zcGVjaWZpYyBvcHRpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5jb25zdCBDQUxFTkRBUl9PUFRJT05fUkVGSU5FUlMgPSB7XG4gICAgYnV0dG9uVGV4dDogaWRlbnRpdHksXG4gICAgYnV0dG9uSGludHM6IGlkZW50aXR5LFxuICAgIHZpZXdzOiBpZGVudGl0eSxcbiAgICBwbHVnaW5zOiBpZGVudGl0eSxcbiAgICBpbml0aWFsRXZlbnRzOiBpZGVudGl0eSxcbiAgICBldmVudHM6IGlkZW50aXR5LFxuICAgIGV2ZW50U291cmNlczogaWRlbnRpdHksXG59O1xuY29uc3QgQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlMgPSB7XG4gICAgaGVhZGVyVG9vbGJhcjogaXNNYXliZU9iamVjdHNFcXVhbCxcbiAgICBmb290ZXJUb29sYmFyOiBpc01heWJlT2JqZWN0c0VxdWFsLFxuICAgIGJ1dHRvblRleHQ6IGlzTWF5YmVPYmplY3RzRXF1YWwsXG4gICAgYnV0dG9uSGludHM6IGlzTWF5YmVPYmplY3RzRXF1YWwsXG4gICAgYnV0dG9uSWNvbnM6IGlzTWF5YmVPYmplY3RzRXF1YWwsXG4gICAgZGF0ZUluY3JlbWVudDogaXNNYXliZU9iamVjdHNFcXVhbCxcbiAgICBwbHVnaW5zOiBpc01heWJlQXJyYXlzRXF1YWwsXG4gICAgZXZlbnRzOiBpc01heWJlQXJyYXlzRXF1YWwsXG4gICAgZXZlbnRTb3VyY2VzOiBpc01heWJlQXJyYXlzRXF1YWwsXG4gICAgWydyZXNvdXJjZXMnXTogaXNNYXliZUFycmF5c0VxdWFsLFxufTtcbmZ1bmN0aW9uIGlzTWF5YmVPYmplY3RzRXF1YWwoYSwgYikge1xuICAgIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGIgPT09ICdvYmplY3QnICYmIGEgJiYgYikgeyAvLyBib3RoIG5vbi1udWxsIG9iamVjdHNcbiAgICAgICAgcmV0dXJuIGlzUHJvcHNFcXVhbChhLCBiKTtcbiAgICB9XG4gICAgcmV0dXJuIGEgPT09IGI7XG59XG5mdW5jdGlvbiBpc01heWJlQXJyYXlzRXF1YWwoYSwgYikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGEpICYmIEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICAgICAgcmV0dXJuIGlzQXJyYXlzRXF1YWwoYSwgYik7XG4gICAgfVxuICAgIHJldHVybiBhID09PSBiO1xufVxuLy8gdmlldy1zcGVjaWZpYyBvcHRpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmNvbnN0IFZJRVdfT1BUSU9OX1JFRklORVJTID0ge1xuICAgIHR5cGU6IFN0cmluZyxcbiAgICBjb21wb25lbnQ6IGlkZW50aXR5LFxuICAgIGJ1dHRvblRleHQ6IFN0cmluZyxcbiAgICBidXR0b25UZXh0S2V5OiBTdHJpbmcsXG4gICAgZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzczogaWRlbnRpdHksXG4gICAgdXNlc01pbk1heFRpbWU6IEJvb2xlYW4sXG4gICAgY2xhc3NOYW1lczogaWRlbnRpdHksXG4gICAgY29udGVudDogaWRlbnRpdHksXG4gICAgZGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIHdpbGxVbm1vdW50OiBpZGVudGl0eSxcbn07XG4vLyB1dGlsIGZ1bmNzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBtZXJnZVJhd09wdGlvbnMob3B0aW9uU2V0cykge1xuICAgIHJldHVybiBtZXJnZVByb3BzKG9wdGlvblNldHMsIENPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTKTtcbn1cbmZ1bmN0aW9uIHJlZmluZVByb3BzKGlucHV0LCByZWZpbmVycykge1xuICAgIGxldCByZWZpbmVkID0ge307XG4gICAgbGV0IGV4dHJhID0ge307XG4gICAgZm9yIChsZXQgcHJvcE5hbWUgaW4gcmVmaW5lcnMpIHtcbiAgICAgICAgaWYgKHByb3BOYW1lIGluIGlucHV0KSB7XG4gICAgICAgICAgICByZWZpbmVkW3Byb3BOYW1lXSA9IHJlZmluZXJzW3Byb3BOYW1lXShpbnB1dFtwcm9wTmFtZV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IHByb3BOYW1lIGluIGlucHV0KSB7XG4gICAgICAgIGlmICghKHByb3BOYW1lIGluIHJlZmluZXJzKSkge1xuICAgICAgICAgICAgZXh0cmFbcHJvcE5hbWVdID0gaW5wdXRbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHJlZmluZWQsIGV4dHJhIH07XG59XG5mdW5jdGlvbiBpZGVudGl0eShyYXcpIHtcbiAgICByZXR1cm4gcmF3O1xufVxuXG5jb25zdCB7IGhhc093blByb3BlcnR5IH0gPSBPYmplY3QucHJvdG90eXBlO1xuLy8gTWVyZ2VzIGFuIGFycmF5IG9mIG9iamVjdHMgaW50byBhIHNpbmdsZSBvYmplY3QuXG4vLyBUaGUgc2Vjb25kIGFyZ3VtZW50IGFsbG93cyBmb3IgYW4gYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgd2hvJ3Mgb2JqZWN0IHZhbHVlcyB3aWxsIGJlIG1lcmdlZCB0b2dldGhlci5cbmZ1bmN0aW9uIG1lcmdlUHJvcHMocHJvcE9ianMsIGNvbXBsZXhQcm9wc01hcCkge1xuICAgIGxldCBkZXN0ID0ge307XG4gICAgaWYgKGNvbXBsZXhQcm9wc01hcCkge1xuICAgICAgICBmb3IgKGxldCBuYW1lIGluIGNvbXBsZXhQcm9wc01hcCkge1xuICAgICAgICAgICAgaWYgKGNvbXBsZXhQcm9wc01hcFtuYW1lXSA9PT0gaXNNYXliZU9iamVjdHNFcXVhbCkgeyAvLyBpbXBsaWVzIHRoYXQgaXQncyBvYmplY3QtbWVyZ2VhYmxlXG4gICAgICAgICAgICAgICAgbGV0IGNvbXBsZXhPYmpzID0gW107XG4gICAgICAgICAgICAgICAgLy8gY29sbGVjdCB0aGUgdHJhaWxpbmcgb2JqZWN0IHZhbHVlcywgc3RvcHBpbmcgd2hlbiBhIG5vbi1vYmplY3QgaXMgZGlzY292ZXJlZFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBwcm9wT2Jqcy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsID0gcHJvcE9ianNbaV1bbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiB2YWwpIHsgLy8gbm9uLW51bGwgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV4T2Jqcy51bnNoaWZ0KHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RbbmFtZV0gPSB2YWw7IC8vIGlmIHRoZXJlIHdlcmUgbm8gb2JqZWN0cywgdGhpcyB2YWx1ZSB3aWxsIGJlIHVzZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSB0cmFpbGluZyB2YWx1ZXMgd2VyZSBvYmplY3RzLCB1c2UgdGhlIG1lcmdlZCB2YWx1ZVxuICAgICAgICAgICAgICAgIGlmIChjb21wbGV4T2Jqcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzdFtuYW1lXSA9IG1lcmdlUHJvcHMoY29tcGxleE9ianMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBjb3B5IHZhbHVlcyBpbnRvIHRoZSBkZXN0aW5hdGlvbiwgZ29pbmcgZnJvbSBsYXN0IHRvIGZpcnN0XG4gICAgZm9yIChsZXQgaSA9IHByb3BPYmpzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgIGxldCBwcm9wcyA9IHByb3BPYmpzW2ldO1xuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHByb3BzKSB7XG4gICAgICAgICAgICBpZiAoIShuYW1lIGluIGRlc3QpKSB7IC8vIGlmIGFscmVhZHkgYXNzaWduZWQgYnkgcHJldmlvdXMgcHJvcHMgb3IgY29tcGxleCBwcm9wcywgZG9uJ3QgcmVhc3NpZ25cbiAgICAgICAgICAgICAgICBkZXN0W25hbWVdID0gcHJvcHNbbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG59XG5mdW5jdGlvbiBmaWx0ZXJIYXNoKGhhc2gsIGZ1bmMpIHtcbiAgICBsZXQgZmlsdGVyZWQgPSB7fTtcbiAgICBmb3IgKGxldCBrZXkgaW4gaGFzaCkge1xuICAgICAgICBpZiAoZnVuYyhoYXNoW2tleV0sIGtleSkpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkW2tleV0gPSBoYXNoW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpbHRlcmVkO1xufVxuZnVuY3Rpb24gbWFwSGFzaChoYXNoLCBmdW5jKSB7XG4gICAgbGV0IG5ld0hhc2ggPSB7fTtcbiAgICBmb3IgKGxldCBrZXkgaW4gaGFzaCkge1xuICAgICAgICBuZXdIYXNoW2tleV0gPSBmdW5jKGhhc2hba2V5XSwga2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0hhc2g7XG59XG5mdW5jdGlvbiBhcnJheVRvSGFzaChhKSB7XG4gICAgbGV0IGhhc2ggPSB7fTtcbiAgICBmb3IgKGxldCBpdGVtIG9mIGEpIHtcbiAgICAgICAgaGFzaFtpdGVtXSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBoYXNoO1xufVxuLy8gVE9ETzogcmVhc3Nlc3MgYnJvd3NlciBzdXBwb3J0XG4vLyBodHRwczovL2Nhbml1c2UuY29tLz9zZWFyY2g9b2JqZWN0LnZhbHVlc1xuZnVuY3Rpb24gaGFzaFZhbHVlc1RvQXJyYXkob2JqKSB7XG4gICAgbGV0IGEgPSBbXTtcbiAgICBmb3IgKGxldCBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGEucHVzaChvYmpba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiBhO1xufVxuZnVuY3Rpb24gaXNQcm9wc0VxdWFsKG9iajAsIG9iajEpIHtcbiAgICBpZiAob2JqMCA9PT0gb2JqMSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZm9yIChsZXQga2V5IGluIG9iajApIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqMCwga2V5KSkge1xuICAgICAgICAgICAgaWYgKCEoa2V5IGluIG9iajEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGtleSBpbiBvYmoxKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iajEsIGtleSkpIHtcbiAgICAgICAgICAgIGlmIChvYmowW2tleV0gIT09IG9iajFba2V5XSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNvbnN0IEhBTkRMRVJfUkUgPSAvXm9uW0EtWl0vO1xuZnVuY3Rpb24gaXNOb25IYW5kbGVyUHJvcHNFcXVhbChvYmowLCBvYmoxKSB7XG4gICAgY29uc3Qga2V5cyA9IGdldFVuZXF1YWxQcm9wcyhvYmowLCBvYmoxKTtcbiAgICBmb3IgKGxldCBrZXkgb2Yga2V5cykge1xuICAgICAgICBpZiAoIUhBTkRMRVJfUkUudGVzdChrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBnZXRVbmVxdWFsUHJvcHMob2JqMCwgb2JqMSkge1xuICAgIGxldCBrZXlzID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG9iajApIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqMCwga2V5KSkge1xuICAgICAgICAgICAgaWYgKCEoa2V5IGluIG9iajEpKSB7XG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQga2V5IGluIG9iajEpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqMSwga2V5KSkge1xuICAgICAgICAgICAgaWYgKG9iajBba2V5XSAhPT0gb2JqMVtrZXldKSB7XG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtleXM7XG59XG5mdW5jdGlvbiBjb21wYXJlT2JqcyhvbGRQcm9wcywgbmV3UHJvcHMsIGVxdWFsaXR5RnVuY3MgPSB7fSkge1xuICAgIGlmIChvbGRQcm9wcyA9PT0gbmV3UHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZvciAobGV0IGtleSBpbiBuZXdQcm9wcykge1xuICAgICAgICBpZiAoa2V5IGluIG9sZFByb3BzICYmIGlzT2JqVmFsc0VxdWFsKG9sZFByb3BzW2tleV0sIG5ld1Byb3BzW2tleV0sIGVxdWFsaXR5RnVuY3Nba2V5XSkpIDtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gY2hlY2sgZm9yIHByb3BzIHRoYXQgd2VyZSBvbWl0dGVkIGluIHRoZSBuZXdcbiAgICBmb3IgKGxldCBrZXkgaW4gb2xkUHJvcHMpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIG5ld1Byb3BzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLypcbmFzc3VtZWQgXCJ0cnVlXCIgZXF1YWxpdHkgZm9yIGhhbmRsZXIgbmFtZXMgbGlrZSBcIm9uUmVjZWl2ZVNvbWV0aGluZ1wiXG4qL1xuZnVuY3Rpb24gaXNPYmpWYWxzRXF1YWwodmFsMCwgdmFsMSwgY29tcGFyYXRvcikge1xuICAgIGlmICh2YWwwID09PSB2YWwxIHx8IGNvbXBhcmF0b3IgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChjb21wYXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBjb21wYXJhdG9yKHZhbDAsIHZhbDEpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjb2xsZWN0RnJvbUhhc2goaGFzaCwgc3RhcnRJbmRleCA9IDAsIGVuZEluZGV4LCBzdGVwID0gMSkge1xuICAgIGxldCByZXMgPSBbXTtcbiAgICBpZiAoZW5kSW5kZXggPT0gbnVsbCkge1xuICAgICAgICBlbmRJbmRleCA9IE9iamVjdC5rZXlzKGhhc2gpLmxlbmd0aDtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleDsgaSArPSBzdGVwKSB7XG4gICAgICAgIGxldCB2YWwgPSBoYXNoW2ldO1xuICAgICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHsgLy8gd2lsbCBkaXNyZWdhcmQgdW5kZWZpbmVkIGZvciBzcGFyc2UgYXJyYXlzXG4gICAgICAgICAgICByZXMucHVzaCh2YWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbmxldCBjYWxlbmRhclN5c3RlbUNsYXNzTWFwID0ge307XG5mdW5jdGlvbiByZWdpc3RlckNhbGVuZGFyU3lzdGVtKG5hbWUsIHRoZUNsYXNzKSB7XG4gICAgY2FsZW5kYXJTeXN0ZW1DbGFzc01hcFtuYW1lXSA9IHRoZUNsYXNzO1xufVxuZnVuY3Rpb24gY3JlYXRlQ2FsZW5kYXJTeXN0ZW0obmFtZSkge1xuICAgIHJldHVybiBuZXcgY2FsZW5kYXJTeXN0ZW1DbGFzc01hcFtuYW1lXSgpO1xufVxuY2xhc3MgR3JlZ29yaWFuQ2FsZW5kYXJTeXN0ZW0ge1xuICAgIGdldE1hcmtlclllYXIoZCkge1xuICAgICAgICByZXR1cm4gZC5nZXRVVENGdWxsWWVhcigpO1xuICAgIH1cbiAgICBnZXRNYXJrZXJNb250aChkKSB7XG4gICAgICAgIHJldHVybiBkLmdldFVUQ01vbnRoKCk7XG4gICAgfVxuICAgIGdldE1hcmtlckRheShkKSB7XG4gICAgICAgIHJldHVybiBkLmdldFVUQ0RhdGUoKTtcbiAgICB9XG4gICAgYXJyYXlUb01hcmtlcihhcnIpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKGFycik7XG4gICAgfVxuICAgIG1hcmtlclRvQXJyYXkobWFya2VyKSB7XG4gICAgICAgIHJldHVybiBkYXRlVG9VdGNBcnJheShtYXJrZXIpO1xuICAgIH1cbn1cbnJlZ2lzdGVyQ2FsZW5kYXJTeXN0ZW0oJ2dyZWdvcnknLCBHcmVnb3JpYW5DYWxlbmRhclN5c3RlbSk7XG5cbmNvbnN0IElTT19SRSA9IC9eXFxzKihcXGR7NH0pKC0/KFxcZHsyfSkoLT8oXFxkezJ9KShbVCBdKFxcZHsyfSk6PyhcXGR7Mn0pKDo/KFxcZHsyfSkoXFwuKFxcZCspKT8pPyhafCgoWy0rXSkoXFxkezJ9KSg6PyhcXGR7Mn0pKT8pKT8pPyk/KT8kLztcbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICAgIGxldCBtID0gSVNPX1JFLmV4ZWMoc3RyKTtcbiAgICBpZiAobSkge1xuICAgICAgICBsZXQgbWFya2VyID0gbmV3IERhdGUoRGF0ZS5VVEMoTnVtYmVyKG1bMV0pLCBtWzNdID8gTnVtYmVyKG1bM10pIC0gMSA6IDAsIE51bWJlcihtWzVdIHx8IDEpLCBOdW1iZXIobVs3XSB8fCAwKSwgTnVtYmVyKG1bOF0gfHwgMCksIE51bWJlcihtWzEwXSB8fCAwKSwgbVsxMl0gPyBOdW1iZXIoYDAuJHttWzEyXX1gKSAqIDEwMDAgOiAwKSk7XG4gICAgICAgIGlmIChpc1ZhbGlkRGF0ZShtYXJrZXIpKSB7XG4gICAgICAgICAgICBsZXQgdGltZVpvbmVPZmZzZXQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKG1bMTNdKSB7XG4gICAgICAgICAgICAgICAgdGltZVpvbmVPZmZzZXQgPSAobVsxNV0gPT09ICctJyA/IC0xIDogMSkgKiAoTnVtYmVyKG1bMTZdIHx8IDApICogNjAgK1xuICAgICAgICAgICAgICAgICAgICBOdW1iZXIobVsxOF0gfHwgMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtYXJrZXIsXG4gICAgICAgICAgICAgICAgaXNUaW1lVW5zcGVjaWZpZWQ6ICFtWzZdLFxuICAgICAgICAgICAgICAgIHRpbWVab25lT2Zmc2V0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuY2xhc3MgRGF0ZUVudiB7XG4gICAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICAgICAgbGV0IHRpbWVab25lID0gdGhpcy50aW1lWm9uZSA9IHNldHRpbmdzLnRpbWVab25lO1xuICAgICAgICBsZXQgaXNOYW1lZFRpbWVab25lID0gdGltZVpvbmUgIT09ICdsb2NhbCcgJiYgdGltZVpvbmUgIT09ICdVVEMnO1xuICAgICAgICBpZiAoc2V0dGluZ3MubmFtZWRUaW1lWm9uZUltcGwgJiYgaXNOYW1lZFRpbWVab25lKSB7XG4gICAgICAgICAgICB0aGlzLm5hbWVkVGltZVpvbmVJbXBsID0gbmV3IHNldHRpbmdzLm5hbWVkVGltZVpvbmVJbXBsKHRpbWVab25lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbkNvbXB1dGVPZmZzZXQgPSBCb29sZWFuKCFpc05hbWVkVGltZVpvbmUgfHwgdGhpcy5uYW1lZFRpbWVab25lSW1wbCk7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJTeXN0ZW0gPSBjcmVhdGVDYWxlbmRhclN5c3RlbShzZXR0aW5ncy5jYWxlbmRhclN5c3RlbSk7XG4gICAgICAgIHRoaXMubG9jYWxlID0gc2V0dGluZ3MubG9jYWxlO1xuICAgICAgICB0aGlzLndlZWtEb3cgPSBzZXR0aW5ncy5sb2NhbGUud2Vlay5kb3c7XG4gICAgICAgIHRoaXMud2Vla0RveSA9IHNldHRpbmdzLmxvY2FsZS53ZWVrLmRveTtcbiAgICAgICAgaWYgKHNldHRpbmdzLndlZWtOdW1iZXJDYWxjdWxhdGlvbiA9PT0gJ0lTTycpIHtcbiAgICAgICAgICAgIHRoaXMud2Vla0RvdyA9IDE7XG4gICAgICAgICAgICB0aGlzLndlZWtEb3kgPSA0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MuZmlyc3REYXkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLndlZWtEb3cgPSBzZXR0aW5ncy5maXJzdERheTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLndlZWtOdW1iZXJDYWxjdWxhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy53ZWVrTnVtYmVyRnVuYyA9IHNldHRpbmdzLndlZWtOdW1iZXJDYWxjdWxhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndlZWtUZXh0ID0gc2V0dGluZ3Mud2Vla1RleHQgIT0gbnVsbCA/IHNldHRpbmdzLndlZWtUZXh0IDogc2V0dGluZ3MubG9jYWxlLm9wdGlvbnMud2Vla1RleHQ7XG4gICAgICAgIHRoaXMud2Vla1RleHRMb25nID0gKHNldHRpbmdzLndlZWtUZXh0TG9uZyAhPSBudWxsID8gc2V0dGluZ3Mud2Vla1RleHRMb25nIDogc2V0dGluZ3MubG9jYWxlLm9wdGlvbnMud2Vla1RleHRMb25nKSB8fCB0aGlzLndlZWtUZXh0O1xuICAgICAgICB0aGlzLmNtZEZvcm1hdHRlciA9IHNldHRpbmdzLmNtZEZvcm1hdHRlcjtcbiAgICAgICAgdGhpcy5kZWZhdWx0U2VwYXJhdG9yID0gc2V0dGluZ3MuZGVmYXVsdFNlcGFyYXRvcjtcbiAgICB9XG4gICAgLy8gQ3JlYXRpbmcgLyBQYXJzaW5nXG4gICAgY3JlYXRlTWFya2VyKGlucHV0KSB7XG4gICAgICAgIGxldCBtZXRhID0gdGhpcy5jcmVhdGVNYXJrZXJNZXRhKGlucHV0KTtcbiAgICAgICAgaWYgKG1ldGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXRhLm1hcmtlcjtcbiAgICB9XG4gICAgY3JlYXRlTm93TWFya2VyKCkge1xuICAgICAgICBpZiAodGhpcy5jYW5Db21wdXRlT2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50aW1lc3RhbXBUb01hcmtlcihuZXcgRGF0ZSgpLnZhbHVlT2YoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2UgY2FuJ3QgY29tcHV0ZSB0aGUgY3VycmVudCBkYXRlIHZhbCBmb3IgYSB0aW1lem9uZSxcbiAgICAgICAgLy8gYmV0dGVyIHRvIGdpdmUgdGhlIGN1cnJlbnQgbG9jYWwgZGF0ZSB2YWxzIHRoYW4gVVRDXG4gICAgICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShkYXRlVG9Mb2NhbEFycmF5KG5ldyBEYXRlKCkpKTtcbiAgICB9XG4gICAgY3JlYXRlTWFya2VyTWV0YShpbnB1dCkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2UoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtYXJrZXIgPSBudWxsO1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgbWFya2VyID0gdGhpcy50aW1lc3RhbXBUb01hcmtlcihpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5wdXQgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICBpbnB1dCA9IGlucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgICAgIGlmICghaXNOYU4oaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgbWFya2VyID0gdGhpcy50aW1lc3RhbXBUb01hcmtlcihpbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgIG1hcmtlciA9IGFycmF5VG9VdGNEYXRlKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFya2VyID09PSBudWxsIHx8ICFpc1ZhbGlkRGF0ZShtYXJrZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtYXJrZXIsIGlzVGltZVVuc3BlY2lmaWVkOiBmYWxzZSwgZm9yY2VkVHpvOiBudWxsIH07XG4gICAgfVxuICAgIHBhcnNlKHMpIHtcbiAgICAgICAgbGV0IHBhcnRzID0gcGFyc2Uocyk7XG4gICAgICAgIGlmIChwYXJ0cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgbWFya2VyIH0gPSBwYXJ0cztcbiAgICAgICAgbGV0IGZvcmNlZFR6byA9IG51bGw7XG4gICAgICAgIGlmIChwYXJ0cy50aW1lWm9uZU9mZnNldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FuQ29tcHV0ZU9mZnNldCkge1xuICAgICAgICAgICAgICAgIG1hcmtlciA9IHRoaXMudGltZXN0YW1wVG9NYXJrZXIobWFya2VyLnZhbHVlT2YoKSAtIHBhcnRzLnRpbWVab25lT2Zmc2V0ICogNjAgKiAxMDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvcmNlZFR6byA9IHBhcnRzLnRpbWVab25lT2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG1hcmtlciwgaXNUaW1lVW5zcGVjaWZpZWQ6IHBhcnRzLmlzVGltZVVuc3BlY2lmaWVkLCBmb3JjZWRUem8gfTtcbiAgICB9XG4gICAgLy8gQWNjZXNzb3JzXG4gICAgZ2V0WWVhcihtYXJrZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtYXJrZXIpO1xuICAgIH1cbiAgICBnZXRNb250aChtYXJrZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyTW9udGgobWFya2VyKTtcbiAgICB9XG4gICAgZ2V0RGF5KG1hcmtlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJEYXkobWFya2VyKTtcbiAgICB9XG4gICAgLy8gQWRkaW5nIC8gU3VidHJhY3RpbmdcbiAgICBhZGQobWFya2VyLCBkdXIpIHtcbiAgICAgICAgbGV0IGEgPSB0aGlzLmNhbGVuZGFyU3lzdGVtLm1hcmtlclRvQXJyYXkobWFya2VyKTtcbiAgICAgICAgYVswXSArPSBkdXIueWVhcnM7XG4gICAgICAgIGFbMV0gKz0gZHVyLm1vbnRocztcbiAgICAgICAgYVsyXSArPSBkdXIuZGF5cztcbiAgICAgICAgYVs2XSArPSBkdXIubWlsbGlzZWNvbmRzO1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5hcnJheVRvTWFya2VyKGEpO1xuICAgIH1cbiAgICBzdWJ0cmFjdChtYXJrZXIsIGR1cikge1xuICAgICAgICBsZXQgYSA9IHRoaXMuY2FsZW5kYXJTeXN0ZW0ubWFya2VyVG9BcnJheShtYXJrZXIpO1xuICAgICAgICBhWzBdIC09IGR1ci55ZWFycztcbiAgICAgICAgYVsxXSAtPSBkdXIubW9udGhzO1xuICAgICAgICBhWzJdIC09IGR1ci5kYXlzO1xuICAgICAgICBhWzZdIC09IGR1ci5taWxsaXNlY29uZHM7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoYSk7XG4gICAgfVxuICAgIGFkZFllYXJzKG1hcmtlciwgbikge1xuICAgICAgICBsZXQgYSA9IHRoaXMuY2FsZW5kYXJTeXN0ZW0ubWFya2VyVG9BcnJheShtYXJrZXIpO1xuICAgICAgICBhWzBdICs9IG47XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoYSk7XG4gICAgfVxuICAgIGFkZE1vbnRocyhtYXJrZXIsIG4pIHtcbiAgICAgICAgbGV0IGEgPSB0aGlzLmNhbGVuZGFyU3lzdGVtLm1hcmtlclRvQXJyYXkobWFya2VyKTtcbiAgICAgICAgYVsxXSArPSBuO1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5hcnJheVRvTWFya2VyKGEpO1xuICAgIH1cbiAgICAvLyBEaWZmaW5nIFdob2xlIFVuaXRzXG4gICAgZGlmZldob2xlWWVhcnMobTAsIG0xKSB7XG4gICAgICAgIGxldCB7IGNhbGVuZGFyU3lzdGVtIH0gPSB0aGlzO1xuICAgICAgICBpZiAodGltZUFzTXMobTApID09PSB0aW1lQXNNcyhtMSkgJiZcbiAgICAgICAgICAgIGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlckRheShtMCkgPT09IGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlckRheShtMSkgJiZcbiAgICAgICAgICAgIGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG0wKSA9PT0gY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyTW9udGgobTEpKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtMSkgLSBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG0wKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZGlmZldob2xlTW9udGhzKG0wLCBtMSkge1xuICAgICAgICBsZXQgeyBjYWxlbmRhclN5c3RlbSB9ID0gdGhpcztcbiAgICAgICAgaWYgKHRpbWVBc01zKG0wKSA9PT0gdGltZUFzTXMobTEpICYmXG4gICAgICAgICAgICBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJEYXkobTApID09PSBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJEYXkobTEpKSB7XG4gICAgICAgICAgICByZXR1cm4gKGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG0xKSAtIGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG0wKSkgK1xuICAgICAgICAgICAgICAgIChjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG0xKSAtIGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobTApKSAqIDEyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBSYW5nZSAvIER1cmF0aW9uXG4gICAgZ3JlYXRlc3RXaG9sZVVuaXQobTAsIG0xKSB7XG4gICAgICAgIGxldCBuID0gdGhpcy5kaWZmV2hvbGVZZWFycyhtMCwgbTEpO1xuICAgICAgICBpZiAobiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ3llYXInLCB2YWx1ZTogbiB9O1xuICAgICAgICB9XG4gICAgICAgIG4gPSB0aGlzLmRpZmZXaG9sZU1vbnRocyhtMCwgbTEpO1xuICAgICAgICBpZiAobiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ21vbnRoJywgdmFsdWU6IG4gfTtcbiAgICAgICAgfVxuICAgICAgICBuID0gZGlmZldob2xlV2Vla3MobTAsIG0xKTtcbiAgICAgICAgaWYgKG4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICd3ZWVrJywgdmFsdWU6IG4gfTtcbiAgICAgICAgfVxuICAgICAgICBuID0gZGlmZldob2xlRGF5cyhtMCwgbTEpO1xuICAgICAgICBpZiAobiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ2RheScsIHZhbHVlOiBuIH07XG4gICAgICAgIH1cbiAgICAgICAgbiA9IGRpZmZIb3VycyhtMCwgbTEpO1xuICAgICAgICBpZiAoaXNJbnQobikpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdob3VyJywgdmFsdWU6IG4gfTtcbiAgICAgICAgfVxuICAgICAgICBuID0gZGlmZk1pbnV0ZXMobTAsIG0xKTtcbiAgICAgICAgaWYgKGlzSW50KG4pKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnbWludXRlJywgdmFsdWU6IG4gfTtcbiAgICAgICAgfVxuICAgICAgICBuID0gZGlmZlNlY29uZHMobTAsIG0xKTtcbiAgICAgICAgaWYgKGlzSW50KG4pKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnc2Vjb25kJywgdmFsdWU6IG4gfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB1bml0OiAnbWlsbGlzZWNvbmQnLCB2YWx1ZTogbTEudmFsdWVPZigpIC0gbTAudmFsdWVPZigpIH07XG4gICAgfVxuICAgIGNvdW50RHVyYXRpb25zQmV0d2VlbihtMCwgbTEsIGQpIHtcbiAgICAgICAgLy8gVE9ETzogY2FuIHVzZSBncmVhdGVzdFdob2xlVW5pdFxuICAgICAgICBsZXQgZGlmZjtcbiAgICAgICAgaWYgKGQueWVhcnMpIHtcbiAgICAgICAgICAgIGRpZmYgPSB0aGlzLmRpZmZXaG9sZVllYXJzKG0wLCBtMSk7XG4gICAgICAgICAgICBpZiAoZGlmZiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkaWZmIC8gYXNSb3VnaFllYXJzKGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkLm1vbnRocykge1xuICAgICAgICAgICAgZGlmZiA9IHRoaXMuZGlmZldob2xlTW9udGhzKG0wLCBtMSk7XG4gICAgICAgICAgICBpZiAoZGlmZiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkaWZmIC8gYXNSb3VnaE1vbnRocyhkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZC5kYXlzKSB7XG4gICAgICAgICAgICBkaWZmID0gZGlmZldob2xlRGF5cyhtMCwgbTEpO1xuICAgICAgICAgICAgaWYgKGRpZmYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlmZiAvIGFzUm91Z2hEYXlzKGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAobTEudmFsdWVPZigpIC0gbTAudmFsdWVPZigpKSAvIGFzUm91Z2hNcyhkKTtcbiAgICB9XG4gICAgLy8gU3RhcnQtT2ZcbiAgICAvLyB0aGVzZSBET04nVCByZXR1cm4gem9uZWQtZGF0ZXMuIG9ubHkgVVRDIHN0YXJ0LW9mIGRhdGVzXG4gICAgc3RhcnRPZihtLCB1bml0KSB7XG4gICAgICAgIGlmICh1bml0ID09PSAneWVhcicpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0T2ZZZWFyKG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0ID09PSAnbW9udGgnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydE9mTW9udGgobSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuaXQgPT09ICd3ZWVrJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRPZldlZWsobSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuaXQgPT09ICdkYXknKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnRPZkRheShtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5pdCA9PT0gJ2hvdXInKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnRPZkhvdXIobSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuaXQgPT09ICdtaW51dGUnKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnRPZk1pbnV0ZShtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5pdCA9PT0gJ3NlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFydE9mU2Vjb25kKG0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzdGFydE9mWWVhcihtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoW1xuICAgICAgICAgICAgdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG0pLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgc3RhcnRPZk1vbnRoKG0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihbXG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobSksXG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG0pLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgc3RhcnRPZldlZWsobSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5hcnJheVRvTWFya2VyKFtcbiAgICAgICAgICAgIHRoaXMuY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtKSxcbiAgICAgICAgICAgIHRoaXMuY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyTW9udGgobSksXG4gICAgICAgICAgICBtLmdldFVUQ0RhdGUoKSAtICgobS5nZXRVVENEYXkoKSAtIHRoaXMud2Vla0RvdyArIDcpICUgNyksXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICAvLyBXZWVrIE51bWJlclxuICAgIGNvbXB1dGVXZWVrTnVtYmVyKG1hcmtlcikge1xuICAgICAgICBpZiAodGhpcy53ZWVrTnVtYmVyRnVuYykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2Vla051bWJlckZ1bmModGhpcy50b0RhdGUobWFya2VyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdlZWtPZlllYXIobWFya2VyLCB0aGlzLndlZWtEb3csIHRoaXMud2Vla0RveSk7XG4gICAgfVxuICAgIC8vIFRPRE86IGNob2tlIG9uIHRpbWVab25lTmFtZTogbG9uZ1xuICAgIGZvcm1hdChtYXJrZXIsIGZvcm1hdHRlciwgZGF0ZU9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdCh7XG4gICAgICAgICAgICBtYXJrZXIsXG4gICAgICAgICAgICB0aW1lWm9uZU9mZnNldDogZGF0ZU9wdGlvbnMuZm9yY2VkVHpvICE9IG51bGwgP1xuICAgICAgICAgICAgICAgIGRhdGVPcHRpb25zLmZvcmNlZFR6byA6XG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRGb3JNYXJrZXIobWFya2VyKSxcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICAgIGZvcm1hdFJhbmdlKHN0YXJ0LCBlbmQsIGZvcm1hdHRlciwgZGF0ZU9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAoZGF0ZU9wdGlvbnMuaXNFbmRFeGNsdXNpdmUpIHtcbiAgICAgICAgICAgIGVuZCA9IGFkZE1zKGVuZCwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0UmFuZ2Uoe1xuICAgICAgICAgICAgbWFya2VyOiBzdGFydCxcbiAgICAgICAgICAgIHRpbWVab25lT2Zmc2V0OiBkYXRlT3B0aW9ucy5mb3JjZWRTdGFydFR6byAhPSBudWxsID9cbiAgICAgICAgICAgICAgICBkYXRlT3B0aW9ucy5mb3JjZWRTdGFydFR6byA6XG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRGb3JNYXJrZXIoc3RhcnQpLFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtYXJrZXI6IGVuZCxcbiAgICAgICAgICAgIHRpbWVab25lT2Zmc2V0OiBkYXRlT3B0aW9ucy5mb3JjZWRFbmRUem8gIT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgZGF0ZU9wdGlvbnMuZm9yY2VkRW5kVHpvIDpcbiAgICAgICAgICAgICAgICB0aGlzLm9mZnNldEZvck1hcmtlcihlbmQpLFxuICAgICAgICB9LCB0aGlzLCBkYXRlT3B0aW9ucy5kZWZhdWx0U2VwYXJhdG9yKTtcbiAgICB9XG4gICAgLypcbiAgICBEVU1COiB0aGUgb21pdFRpbWUgYXJnIGlzIGR1bWIuIGlmIHdlIG9taXQgdGhlIHRpbWUsIHdlIHdhbnQgdG8gb21pdCB0aGUgdGltZXpvbmUgb2Zmc2V0LiBhbmQgaWYgd2UgZG8gdGhhdCxcbiAgICBtaWdodCBhcyB3ZWxsIHVzZSBidWlsZElzb1N0cmluZyBvciBzb21lIG90aGVyIHV0aWwgZGlyZWN0bHlcbiAgICAqL1xuICAgIGZvcm1hdElzbyhtYXJrZXIsIGV4dHJhT3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCB0aW1lWm9uZU9mZnNldCA9IG51bGw7XG4gICAgICAgIGlmICghZXh0cmFPcHRpb25zLm9taXRUaW1lWm9uZU9mZnNldCkge1xuICAgICAgICAgICAgaWYgKGV4dHJhT3B0aW9ucy5mb3JjZWRUem8gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRpbWVab25lT2Zmc2V0ID0gZXh0cmFPcHRpb25zLmZvcmNlZFR6bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRpbWVab25lT2Zmc2V0ID0gdGhpcy5vZmZzZXRGb3JNYXJrZXIobWFya2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVpbGRJc29TdHJpbmcobWFya2VyLCB0aW1lWm9uZU9mZnNldCwgZXh0cmFPcHRpb25zLm9taXRUaW1lKTtcbiAgICB9XG4gICAgLy8gVGltZVpvbmVcbiAgICB0aW1lc3RhbXBUb01hcmtlcihtcykge1xuICAgICAgICBpZiAodGhpcy50aW1lWm9uZSA9PT0gJ2xvY2FsJykge1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKGRhdGVUb0xvY2FsQXJyYXkobmV3IERhdGUobXMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudGltZVpvbmUgPT09ICdVVEMnIHx8ICF0aGlzLm5hbWVkVGltZVpvbmVJbXBsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUobXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZSh0aGlzLm5hbWVkVGltZVpvbmVJbXBsLnRpbWVzdGFtcFRvQXJyYXkobXMpKTtcbiAgICB9XG4gICAgb2Zmc2V0Rm9yTWFya2VyKG0pIHtcbiAgICAgICAgaWYgKHRoaXMudGltZVpvbmUgPT09ICdsb2NhbCcpIHtcbiAgICAgICAgICAgIHJldHVybiAtYXJyYXlUb0xvY2FsRGF0ZShkYXRlVG9VdGNBcnJheShtKSkuZ2V0VGltZXpvbmVPZmZzZXQoKTsgLy8gY29udmVydCBcImludmVyc2VcIiBvZmZzZXQgdG8gXCJub3JtYWxcIiBvZmZzZXRcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50aW1lWm9uZSA9PT0gJ1VUQycpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm5hbWVkVGltZVpvbmVJbXBsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lZFRpbWVab25lSW1wbC5vZmZzZXRGb3JBcnJheShkYXRlVG9VdGNBcnJheShtKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIENvbnZlcnNpb25cbiAgICB0b0RhdGUobSwgZm9yY2VkVHpvKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVab25lID09PSAnbG9jYWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXlUb0xvY2FsRGF0ZShkYXRlVG9VdGNBcnJheShtKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudGltZVpvbmUgPT09ICdVVEMnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUobS52YWx1ZU9mKCkpOyAvLyBtYWtlIHN1cmUgaXQncyBhIGNvcHlcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMubmFtZWRUaW1lWm9uZUltcGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShtLnZhbHVlT2YoKSAtIChmb3JjZWRUem8gfHwgMCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShtLnZhbHVlT2YoKSAtXG4gICAgICAgICAgICB0aGlzLm5hbWVkVGltZVpvbmVJbXBsLm9mZnNldEZvckFycmF5KGRhdGVUb1V0Y0FycmF5KG0pKSAqIDEwMDAgKiA2MCk7XG4gICAgfVxufVxuXG5jbGFzcyBUaGVtZSB7XG4gICAgY29uc3RydWN0b3IoY2FsZW5kYXJPcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLmljb25PdmVycmlkZU9wdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zZXRJY29uT3ZlcnJpZGUoY2FsZW5kYXJPcHRpb25zW3RoaXMuaWNvbk92ZXJyaWRlT3B0aW9uXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0SWNvbk92ZXJyaWRlKGljb25PdmVycmlkZUhhc2gpIHtcbiAgICAgICAgbGV0IGljb25DbGFzc2VzQ29weTtcbiAgICAgICAgbGV0IGJ1dHRvbk5hbWU7XG4gICAgICAgIGlmICh0eXBlb2YgaWNvbk92ZXJyaWRlSGFzaCA9PT0gJ29iamVjdCcgJiYgaWNvbk92ZXJyaWRlSGFzaCkgeyAvLyBub24tbnVsbCBvYmplY3RcbiAgICAgICAgICAgIGljb25DbGFzc2VzQ29weSA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuaWNvbkNsYXNzZXMpO1xuICAgICAgICAgICAgZm9yIChidXR0b25OYW1lIGluIGljb25PdmVycmlkZUhhc2gpIHtcbiAgICAgICAgICAgICAgICBpY29uQ2xhc3Nlc0NvcHlbYnV0dG9uTmFtZV0gPSB0aGlzLmFwcGx5SWNvbk92ZXJyaWRlUHJlZml4KGljb25PdmVycmlkZUhhc2hbYnV0dG9uTmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pY29uQ2xhc3NlcyA9IGljb25DbGFzc2VzQ29weTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpY29uT3ZlcnJpZGVIYXNoID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5pY29uQ2xhc3NlcyA9IHt9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGFwcGx5SWNvbk92ZXJyaWRlUHJlZml4KGNsYXNzTmFtZSkge1xuICAgICAgICBsZXQgcHJlZml4ID0gdGhpcy5pY29uT3ZlcnJpZGVQcmVmaXg7XG4gICAgICAgIGlmIChwcmVmaXggJiYgY2xhc3NOYW1lLmluZGV4T2YocHJlZml4KSAhPT0gMCkgeyAvLyBpZiBub3QgYWxyZWFkeSBwcmVzZW50XG4gICAgICAgICAgICBjbGFzc05hbWUgPSBwcmVmaXggKyBjbGFzc05hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgICB9XG4gICAgZ2V0Q2xhc3Moa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsYXNzZXNba2V5XSB8fCAnJztcbiAgICB9XG4gICAgZ2V0SWNvbkNsYXNzKGJ1dHRvbk5hbWUsIGlzUnRsKSB7XG4gICAgICAgIGxldCBjbGFzc05hbWU7XG4gICAgICAgIGlmIChpc1J0bCAmJiB0aGlzLnJ0bEljb25DbGFzc2VzKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgPSB0aGlzLnJ0bEljb25DbGFzc2VzW2J1dHRvbk5hbWVdIHx8IHRoaXMuaWNvbkNsYXNzZXNbYnV0dG9uTmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgPSB0aGlzLmljb25DbGFzc2VzW2J1dHRvbk5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLmJhc2VJY29uQ2xhc3N9ICR7Y2xhc3NOYW1lfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBnZXRDdXN0b21CdXR0b25JY29uQ2xhc3MoY3VzdG9tQnV0dG9uUHJvcHMpIHtcbiAgICAgICAgbGV0IGNsYXNzTmFtZTtcbiAgICAgICAgaWYgKHRoaXMuaWNvbk92ZXJyaWRlQ3VzdG9tQnV0dG9uT3B0aW9uKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgPSBjdXN0b21CdXR0b25Qcm9wc1t0aGlzLmljb25PdmVycmlkZUN1c3RvbUJ1dHRvbk9wdGlvbl07XG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMuYmFzZUljb25DbGFzc30gJHt0aGlzLmFwcGx5SWNvbk92ZXJyaWRlUHJlZml4KGNsYXNzTmFtZSl9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxufVxuVGhlbWUucHJvdG90eXBlLmNsYXNzZXMgPSB7fTtcblRoZW1lLnByb3RvdHlwZS5pY29uQ2xhc3NlcyA9IHt9O1xuVGhlbWUucHJvdG90eXBlLmJhc2VJY29uQ2xhc3MgPSAnJztcblRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVQcmVmaXggPSAnJztcblxuLypcbk5PVEU6IHRoaXMgY2FuIGJlIGEgcHVibGljIEFQSSwgZXNwZWNpYWxseSBjcmVhdGVFbGVtZW50IGZvciBob29rcy5cblNlZSBleGFtcGxlcy90eXBlc2NyaXB0LXNjaGVkdWxlci9zcmMvaW5kZXgudHNcbiovXG5mdW5jdGlvbiBmbHVzaFN5bmMocnVuQmVmb3JlRmx1c2gpIHtcbiAgICBydW5CZWZvcmVGbHVzaCgpO1xuICAgIGxldCBvbGREZWJvdW5jZVJlbmRlcmluZyA9IHByZWFjdC5vcHRpb25zLmRlYm91bmNlUmVuZGVyaW5nOyAvLyBvcmlnXG4gICAgbGV0IGNhbGxiYWNrUSA9IFtdO1xuICAgIGZ1bmN0aW9uIGV4ZWNDYWxsYmFja1N5bmMoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2tRLnB1c2goY2FsbGJhY2spO1xuICAgIH1cbiAgICBwcmVhY3Qub3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZyA9IGV4ZWNDYWxsYmFja1N5bmM7XG4gICAgcHJlYWN0LnJlbmRlcihwcmVhY3QuY3JlYXRlRWxlbWVudChGYWtlQ29tcG9uZW50LCB7fSksIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKTtcbiAgICB3aGlsZSAoY2FsbGJhY2tRLmxlbmd0aCkge1xuICAgICAgICBjYWxsYmFja1Euc2hpZnQoKSgpO1xuICAgIH1cbiAgICBwcmVhY3Qub3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZyA9IG9sZERlYm91bmNlUmVuZGVyaW5nO1xufVxuY2xhc3MgRmFrZUNvbXBvbmVudCBleHRlbmRzIHByZWFjdC5Db21wb25lbnQge1xuICAgIHJlbmRlcigpIHsgcmV0dXJuIHByZWFjdC5jcmVhdGVFbGVtZW50KCdkaXYnLCB7fSk7IH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHsgdGhpcy5zZXRTdGF0ZSh7fSk7IH1cbn1cbi8vIFRPRE86IHVzZSBwcmVhY3QvY29tcGF0IGluc3RlYWQ/XG5mdW5jdGlvbiBjcmVhdGVDb250ZXh0KGRlZmF1bHRWYWx1ZSkge1xuICAgIGxldCBDb250ZXh0VHlwZSA9IHByZWFjdC5jcmVhdGVDb250ZXh0KGRlZmF1bHRWYWx1ZSk7XG4gICAgbGV0IG9yaWdQcm92aWRlciA9IENvbnRleHRUeXBlLlByb3ZpZGVyO1xuICAgIENvbnRleHRUeXBlLlByb3ZpZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsZXQgaXNOZXcgPSAhdGhpcy5nZXRDaGlsZENvbnRleHQ7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IG9yaWdQcm92aWRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByZWZlci1yZXN0LXBhcmFtc1xuICAgICAgICBpZiAoaXNOZXcpIHtcbiAgICAgICAgICAgIGxldCBzdWJzID0gW107XG4gICAgICAgICAgICB0aGlzLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IChfcHJvcHMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9wcy52YWx1ZSAhPT0gX3Byb3BzLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnMuZm9yRWFjaCgoYykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYy5jb250ZXh0ID0gX3Byb3BzLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYy5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5zdWIgPSAoYykgPT4ge1xuICAgICAgICAgICAgICAgIHN1YnMucHVzaChjKTtcbiAgICAgICAgICAgICAgICBsZXQgb2xkID0gYy5jb21wb25lbnRXaWxsVW5tb3VudDtcbiAgICAgICAgICAgICAgICBjLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzdWJzLnNwbGljZShzdWJzLmluZGV4T2YoYyksIDEpO1xuICAgICAgICAgICAgICAgICAgICBvbGQgJiYgb2xkLmNhbGwoYyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH07XG4gICAgcmV0dXJuIENvbnRleHRUeXBlO1xufVxuXG5jbGFzcyBTY3JvbGxSZXNwb25kZXIge1xuICAgIGNvbnN0cnVjdG9yKGV4ZWNGdW5jLCBlbWl0dGVyLCBzY3JvbGxUaW1lLCBzY3JvbGxUaW1lUmVzZXQpIHtcbiAgICAgICAgdGhpcy5leGVjRnVuYyA9IGV4ZWNGdW5jO1xuICAgICAgICB0aGlzLmVtaXR0ZXIgPSBlbWl0dGVyO1xuICAgICAgICB0aGlzLnNjcm9sbFRpbWUgPSBzY3JvbGxUaW1lO1xuICAgICAgICB0aGlzLnNjcm9sbFRpbWVSZXNldCA9IHNjcm9sbFRpbWVSZXNldDtcbiAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGxSZXF1ZXN0ID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMucXVldWVkUmVxdWVzdCA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMucXVldWVkUmVxdWVzdCB8fCB7fSwgcmVxdWVzdCk7XG4gICAgICAgICAgICB0aGlzLmRyYWluKCk7XG4gICAgICAgIH07XG4gICAgICAgIGVtaXR0ZXIub24oJ19zY3JvbGxSZXF1ZXN0JywgdGhpcy5oYW5kbGVTY3JvbGxSZXF1ZXN0KTtcbiAgICAgICAgdGhpcy5maXJlSW5pdGlhbFNjcm9sbCgpO1xuICAgIH1cbiAgICBkZXRhY2goKSB7XG4gICAgICAgIHRoaXMuZW1pdHRlci5vZmYoJ19zY3JvbGxSZXF1ZXN0JywgdGhpcy5oYW5kbGVTY3JvbGxSZXF1ZXN0KTtcbiAgICB9XG4gICAgdXBkYXRlKGlzRGF0ZXNOZXcpIHtcbiAgICAgICAgaWYgKGlzRGF0ZXNOZXcgJiYgdGhpcy5zY3JvbGxUaW1lUmVzZXQpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZUluaXRpYWxTY3JvbGwoKTsgLy8gd2lsbCBkcmFpblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kcmFpbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpcmVJbml0aWFsU2Nyb2xsKCkge1xuICAgICAgICB0aGlzLmhhbmRsZVNjcm9sbFJlcXVlc3Qoe1xuICAgICAgICAgICAgdGltZTogdGhpcy5zY3JvbGxUaW1lLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZHJhaW4oKSB7XG4gICAgICAgIGlmICh0aGlzLnF1ZXVlZFJlcXVlc3QgJiYgdGhpcy5leGVjRnVuYyh0aGlzLnF1ZXVlZFJlcXVlc3QpKSB7XG4gICAgICAgICAgICB0aGlzLnF1ZXVlZFJlcXVlc3QgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBWaWV3Q29udGV4dFR5cGUgPSBjcmVhdGVDb250ZXh0KHt9KTsgLy8gZm9yIENvbXBvbmVudHNcbmZ1bmN0aW9uIGJ1aWxkVmlld0NvbnRleHQodmlld1NwZWMsIHZpZXdBcGksIHZpZXdPcHRpb25zLCBkYXRlUHJvZmlsZUdlbmVyYXRvciwgZGF0ZUVudiwgdGhlbWUsIHBsdWdpbkhvb2tzLCBkaXNwYXRjaCwgZ2V0Q3VycmVudERhdGEsIGVtaXR0ZXIsIGNhbGVuZGFyQXBpLCByZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50LCB1bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBkYXRlRW52LFxuICAgICAgICBvcHRpb25zOiB2aWV3T3B0aW9ucyxcbiAgICAgICAgcGx1Z2luSG9va3MsXG4gICAgICAgIGVtaXR0ZXIsXG4gICAgICAgIGRpc3BhdGNoLFxuICAgICAgICBnZXRDdXJyZW50RGF0YSxcbiAgICAgICAgY2FsZW5kYXJBcGksXG4gICAgICAgIHZpZXdTcGVjLFxuICAgICAgICB2aWV3QXBpLFxuICAgICAgICBkYXRlUHJvZmlsZUdlbmVyYXRvcixcbiAgICAgICAgdGhlbWUsXG4gICAgICAgIGlzUnRsOiB2aWV3T3B0aW9ucy5kaXJlY3Rpb24gPT09ICdydGwnLFxuICAgICAgICBhZGRSZXNpemVIYW5kbGVyKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGVtaXR0ZXIub24oJ19yZXNpemUnLCBoYW5kbGVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlUmVzaXplSGFuZGxlcihoYW5kbGVyKSB7XG4gICAgICAgICAgICBlbWl0dGVyLm9mZignX3Jlc2l6ZScsIGhhbmRsZXIpO1xuICAgICAgICB9LFxuICAgICAgICBjcmVhdGVTY3JvbGxSZXNwb25kZXIoZXhlY0Z1bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2Nyb2xsUmVzcG9uZGVyKGV4ZWNGdW5jLCBlbWl0dGVyLCBjcmVhdGVEdXJhdGlvbih2aWV3T3B0aW9ucy5zY3JvbGxUaW1lKSwgdmlld09wdGlvbnMuc2Nyb2xsVGltZVJlc2V0KTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCxcbiAgICAgICAgdW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50LFxuICAgIH07XG59XG5cbi8qIGVzbGludCBtYXgtY2xhc3Nlcy1wZXItZmlsZTogb2ZmICovXG5jbGFzcyBQdXJlQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhnZXRVbmVxdWFsUHJvcHMobmV4dFByb3BzLCB0aGlzLnByb3BzKSwgZ2V0VW5lcXVhbFByb3BzKG5leHRTdGF0ZSwgdGhpcy5zdGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhY29tcGFyZU9ianModGhpcy5wcm9wcywgbmV4dFByb3BzLCB0aGlzLnByb3BFcXVhbGl0eSkgfHxcbiAgICAgICAgICAgICFjb21wYXJlT2Jqcyh0aGlzLnN0YXRlLCBuZXh0U3RhdGUsIHRoaXMuc3RhdGVFcXVhbGl0eSk7XG4gICAgfVxuICAgIC8vIEhBQ0sgZm9yIGZyZWFraW4nIFJlYWN0IFN0cmljdE1vZGVcbiAgICBzYWZlU2V0U3RhdGUobmV3U3RhdGUpIHtcbiAgICAgICAgaWYgKCFjb21wYXJlT2Jqcyh0aGlzLnN0YXRlLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuc3RhdGUpLCBuZXdTdGF0ZSksIHRoaXMuc3RhdGVFcXVhbGl0eSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUobmV3U3RhdGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuUHVyZUNvbXBvbmVudC5hZGRQcm9wc0VxdWFsaXR5ID0gYWRkUHJvcHNFcXVhbGl0eTtcblB1cmVDb21wb25lbnQuYWRkU3RhdGVFcXVhbGl0eSA9IGFkZFN0YXRlRXF1YWxpdHk7XG5QdXJlQ29tcG9uZW50LmNvbnRleHRUeXBlID0gVmlld0NvbnRleHRUeXBlO1xuUHVyZUNvbXBvbmVudC5wcm90b3R5cGUucHJvcEVxdWFsaXR5ID0ge307XG5QdXJlQ29tcG9uZW50LnByb3RvdHlwZS5zdGF0ZUVxdWFsaXR5ID0ge307XG5jbGFzcyBCYXNlQ29tcG9uZW50IGV4dGVuZHMgUHVyZUNvbXBvbmVudCB7XG59XG5CYXNlQ29tcG9uZW50LmNvbnRleHRUeXBlID0gVmlld0NvbnRleHRUeXBlO1xuZnVuY3Rpb24gYWRkUHJvcHNFcXVhbGl0eShwcm9wRXF1YWxpdHkpIHtcbiAgICBsZXQgaGFzaCA9IE9iamVjdC5jcmVhdGUodGhpcy5wcm90b3R5cGUucHJvcEVxdWFsaXR5KTtcbiAgICBPYmplY3QuYXNzaWduKGhhc2gsIHByb3BFcXVhbGl0eSk7XG4gICAgdGhpcy5wcm90b3R5cGUucHJvcEVxdWFsaXR5ID0gaGFzaDtcbn1cbmZ1bmN0aW9uIGFkZFN0YXRlRXF1YWxpdHkoc3RhdGVFcXVhbGl0eSkge1xuICAgIGxldCBoYXNoID0gT2JqZWN0LmNyZWF0ZSh0aGlzLnByb3RvdHlwZS5zdGF0ZUVxdWFsaXR5KTtcbiAgICBPYmplY3QuYXNzaWduKGhhc2gsIHN0YXRlRXF1YWxpdHkpO1xuICAgIHRoaXMucHJvdG90eXBlLnN0YXRlRXF1YWxpdHkgPSBoYXNoO1xufVxuLy8gdXNlIG90aGVyIG9uZVxuZnVuY3Rpb24gc2V0UmVmKHJlZiwgY3VycmVudCkge1xuICAgIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJlZihjdXJyZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAocmVmKSB7XG4gICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzMDI5XG4gICAgICAgIHJlZi5jdXJyZW50ID0gY3VycmVudDtcbiAgICB9XG59XG5cbmNsYXNzIENvbnRlbnRJbmplY3RvciBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmlkID0gZ3VpZCgpO1xuICAgICAgICB0aGlzLnF1ZXVlZERvbU5vZGVzID0gW107XG4gICAgICAgIHRoaXMuY3VycmVudERvbU5vZGVzID0gW107XG4gICAgICAgIHRoaXMuaGFuZGxlRWwgPSAoZWwpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICAgICAgY29uc3QgeyBnZW5lcmF0b3JOYW1lIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmN1c3RvbVJlbmRlcmluZ1JlcGxhY2VzIHx8ICFoYXNDdXN0b21SZW5kZXJpbmdIYW5kbGVyKGdlbmVyYXRvck5hbWUsIG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVFbFJlZihlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlRWxSZWYgPSAoZWwpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLmVsUmVmKSB7XG4gICAgICAgICAgICAgICAgc2V0UmVmKHRoaXMucHJvcHMuZWxSZWYsIGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgICAgIGNvbnN0IHsgY3VzdG9tR2VuZXJhdG9yLCBkZWZhdWx0R2VuZXJhdG9yLCByZW5kZXJQcm9wcyB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IGF0dHJzID0gYnVpbGRFbEF0dHJzKHByb3BzLCBbXSwgdGhpcy5oYW5kbGVFbCk7XG4gICAgICAgIGxldCB1c2VEZWZhdWx0ID0gZmFsc2U7XG4gICAgICAgIGxldCBpbm5lckNvbnRlbnQ7XG4gICAgICAgIGxldCBxdWV1ZWREb21Ob2RlcyA9IFtdO1xuICAgICAgICBsZXQgY3VycmVudEdlbmVyYXRvck1ldGE7XG4gICAgICAgIGlmIChjdXN0b21HZW5lcmF0b3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgY3VzdG9tR2VuZXJhdG9yUmVzID0gdHlwZW9mIGN1c3RvbUdlbmVyYXRvciA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICAgICAgY3VzdG9tR2VuZXJhdG9yKHJlbmRlclByb3BzLCBjcmVhdGVFbGVtZW50KSA6XG4gICAgICAgICAgICAgICAgY3VzdG9tR2VuZXJhdG9yO1xuICAgICAgICAgICAgaWYgKGN1c3RvbUdlbmVyYXRvclJlcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHVzZURlZmF1bHQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNPYmplY3QgPSBjdXN0b21HZW5lcmF0b3JSZXMgJiYgdHlwZW9mIGN1c3RvbUdlbmVyYXRvclJlcyA9PT0gJ29iamVjdCc7IC8vIG5vbi1udWxsXG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0ICYmICgnaHRtbCcgaW4gY3VzdG9tR2VuZXJhdG9yUmVzKSkge1xuICAgICAgICAgICAgICAgICAgICBhdHRycy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9IHsgX19odG1sOiBjdXN0b21HZW5lcmF0b3JSZXMuaHRtbCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc09iamVjdCAmJiAoJ2RvbU5vZGVzJyBpbiBjdXN0b21HZW5lcmF0b3JSZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlZERvbU5vZGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoY3VzdG9tR2VuZXJhdG9yUmVzLmRvbU5vZGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNPYmplY3RcbiAgICAgICAgICAgICAgICAgICAgPyBpc1ZhbGlkRWxlbWVudChjdXN0b21HZW5lcmF0b3JSZXMpIC8vIHZkb20gbm9kZVxuICAgICAgICAgICAgICAgICAgICA6IHR5cGVvZiBjdXN0b21HZW5lcmF0b3JSZXMgIT09ICdmdW5jdGlvbicgLy8gcHJpbWl0aXZlIHZhbHVlIChsaWtlIHN0cmluZyBvciBudW1iZXIpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVzZSBpbiB2ZG9tXG4gICAgICAgICAgICAgICAgICAgIGlubmVyQ29udGVudCA9IGN1c3RvbUdlbmVyYXRvclJlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFuIGV4b3RpYyBvYmplY3QgZm9yIGhhbmRsZUN1c3RvbVJlbmRlcmluZ1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50R2VuZXJhdG9yTWV0YSA9IGN1c3RvbUdlbmVyYXRvclJlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1c2VEZWZhdWx0ID0gIWhhc0N1c3RvbVJlbmRlcmluZ0hhbmRsZXIocHJvcHMuZ2VuZXJhdG9yTmFtZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVzZURlZmF1bHQgJiYgZGVmYXVsdEdlbmVyYXRvcikge1xuICAgICAgICAgICAgaW5uZXJDb250ZW50ID0gZGVmYXVsdEdlbmVyYXRvcihyZW5kZXJQcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5xdWV1ZWREb21Ob2RlcyA9IHF1ZXVlZERvbU5vZGVzO1xuICAgICAgICB0aGlzLmN1cnJlbnRHZW5lcmF0b3JNZXRhID0gY3VycmVudEdlbmVyYXRvck1ldGE7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHByb3BzLmVsVGFnLCBhdHRycywgaW5uZXJDb250ZW50KTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMuYXBwbHlRdWV1ZXVkRG9tTm9kZXMoKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyQ3VzdG9tUmVuZGVyaW5nKHRydWUpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgIHRoaXMuYXBwbHlRdWV1ZXVkRG9tTm9kZXMoKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyQ3VzdG9tUmVuZGVyaW5nKHRydWUpO1xuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyQ3VzdG9tUmVuZGVyaW5nKGZhbHNlKTsgLy8gVE9ETzogZGlmZmVyZW50IEFQSSBmb3IgcmVtb3ZhbD9cbiAgICB9XG4gICAgdHJpZ2dlckN1c3RvbVJlbmRlcmluZyhpc0FjdGl2ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgaGFuZGxlQ3VzdG9tUmVuZGVyaW5nLCBjdXN0b21SZW5kZXJpbmdNZXRhTWFwIH0gPSBjb250ZXh0Lm9wdGlvbnM7XG4gICAgICAgIGlmIChoYW5kbGVDdXN0b21SZW5kZXJpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IGdlbmVyYXRvck1ldGEgPSAoX2EgPSB0aGlzLmN1cnJlbnRHZW5lcmF0b3JNZXRhKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjdXN0b21SZW5kZXJpbmdNZXRhTWFwID09PSBudWxsIHx8IGN1c3RvbVJlbmRlcmluZ01ldGFNYXAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1c3RvbVJlbmRlcmluZ01ldGFNYXBbcHJvcHMuZ2VuZXJhdG9yTmFtZV07XG4gICAgICAgICAgICBpZiAoZ2VuZXJhdG9yTWV0YSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUN1c3RvbVJlbmRlcmluZyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBpZDogdGhpcy5pZCwgaXNBY3RpdmUsIGNvbnRhaW5lckVsOiB0aGlzLmJhc2UsIHJlcG9ydE5ld0NvbnRhaW5lckVsOiB0aGlzLnVwZGF0ZUVsUmVmLCAvLyBmcm9udC1lbmQgZnJhbWV3b3JrIHRlbGxzIHVzIGFib3V0IG5ldyBjb250YWluZXIgZWxzXG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRvck1ldGEgfSwgcHJvcHMpLCB7IGVsQ2xhc3NlczogKHByb3BzLmVsQ2xhc3NlcyB8fCBbXSkuZmlsdGVyKGlzVHJ1dGh5KSB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXBwbHlRdWV1ZXVkRG9tTm9kZXMoKSB7XG4gICAgICAgIGNvbnN0IHsgcXVldWVkRG9tTm9kZXMsIGN1cnJlbnREb21Ob2RlcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgZWwgPSB0aGlzLmJhc2U7XG4gICAgICAgIGlmICghaXNBcnJheXNFcXVhbChxdWV1ZWREb21Ob2RlcywgY3VycmVudERvbU5vZGVzKSkge1xuICAgICAgICAgICAgY3VycmVudERvbU5vZGVzLmZvckVhY2gocmVtb3ZlRWxlbWVudCk7XG4gICAgICAgICAgICBmb3IgKGxldCBuZXdOb2RlIG9mIHF1ZXVlZERvbU5vZGVzKSB7XG4gICAgICAgICAgICAgICAgZWwuYXBwZW5kQ2hpbGQobmV3Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREb21Ob2RlcyA9IHF1ZXVlZERvbU5vZGVzO1xuICAgICAgICB9XG4gICAgfVxufVxuQ29udGVudEluamVjdG9yLmFkZFByb3BzRXF1YWxpdHkoe1xuICAgIGVsQ2xhc3NlczogaXNBcnJheXNFcXVhbCxcbiAgICBlbFN0eWxlOiBpc1Byb3BzRXF1YWwsXG4gICAgZWxBdHRyczogaXNOb25IYW5kbGVyUHJvcHNFcXVhbCxcbiAgICByZW5kZXJQcm9wczogaXNQcm9wc0VxdWFsLFxufSk7XG4vLyBVdGlsXG4vKlxuRG9lcyBVSS1mcmFtZXdvcmsgcHJvdmlkZSBjdXN0b20gd2F5IG9mIHJlbmRlcmluZyB0aGF0IGRvZXMgbm90IHVzZSBQcmVhY3QgVkRPTVxuQU5EIGRvZXMgdGhlIGNhbGVuZGFyJ3Mgb3B0aW9ucyBkZWZpbmUgY3VzdG9tIHJlbmRlcmluZz9cbkFLQS4gU2hvdWxkIHdlIE5PVCByZW5kZXIgdGhlIGRlZmF1bHQgY29udGVudD9cbiovXG5mdW5jdGlvbiBoYXNDdXN0b21SZW5kZXJpbmdIYW5kbGVyKGdlbmVyYXRvck5hbWUsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIEJvb2xlYW4ob3B0aW9ucy5oYW5kbGVDdXN0b21SZW5kZXJpbmcgJiZcbiAgICAgICAgZ2VuZXJhdG9yTmFtZSAmJlxuICAgICAgICAoKF9hID0gb3B0aW9ucy5jdXN0b21SZW5kZXJpbmdNZXRhTWFwKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbZ2VuZXJhdG9yTmFtZV0pKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRWxBdHRycyhwcm9wcywgZXh0cmFDbGFzc05hbWVzLCBlbFJlZikge1xuICAgIGNvbnN0IGF0dHJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcm9wcy5lbEF0dHJzKSwgeyByZWY6IGVsUmVmIH0pO1xuICAgIGlmIChwcm9wcy5lbENsYXNzZXMgfHwgZXh0cmFDbGFzc05hbWVzKSB7XG4gICAgICAgIGF0dHJzLmNsYXNzTmFtZSA9IChwcm9wcy5lbENsYXNzZXMgfHwgW10pXG4gICAgICAgICAgICAuY29uY2F0KGV4dHJhQ2xhc3NOYW1lcyB8fCBbXSlcbiAgICAgICAgICAgIC5jb25jYXQoYXR0cnMuY2xhc3NOYW1lIHx8IFtdKVxuICAgICAgICAgICAgLmZpbHRlcihCb29sZWFuKVxuICAgICAgICAgICAgLmpvaW4oJyAnKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmVsU3R5bGUpIHtcbiAgICAgICAgYXR0cnMuc3R5bGUgPSBwcm9wcy5lbFN0eWxlO1xuICAgIH1cbiAgICByZXR1cm4gYXR0cnM7XG59XG5mdW5jdGlvbiBpc1RydXRoeSh2YWwpIHtcbiAgICByZXR1cm4gQm9vbGVhbih2YWwpO1xufVxuXG5jb25zdCBSZW5kZXJJZCA9IGNyZWF0ZUNvbnRleHQoMCk7XG5cbmNsYXNzIENvbnRlbnRDb250YWluZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLklubmVyQ29udGVudCA9IElubmVyQ29udGVudEluamVjdG9yLmJpbmQodW5kZWZpbmVkLCB0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVFbCA9IChlbCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMuZWxSZWYpIHtcbiAgICAgICAgICAgICAgICBzZXRSZWYodGhpcy5wcm9wcy5lbFJlZiwgZWwpO1xuICAgICAgICAgICAgICAgIGlmIChlbCAmJiB0aGlzLmRpZE1vdW50TWlzZmlyZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudERpZE1vdW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRlZENsYXNzTmFtZXMgPSBnZW5lcmF0ZUNsYXNzTmFtZXMocHJvcHMuY2xhc3NOYW1lR2VuZXJhdG9yLCBwcm9wcy5yZW5kZXJQcm9wcyk7XG4gICAgICAgIGlmIChwcm9wcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgY29uc3QgZWxBdHRycyA9IGJ1aWxkRWxBdHRycyhwcm9wcywgZ2VuZXJhdGVkQ2xhc3NOYW1lcywgdGhpcy5oYW5kbGVFbCk7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuKHRoaXMuSW5uZXJDb250ZW50LCBwcm9wcy5yZW5kZXJQcm9wcywgZWxBdHRycyk7XG4gICAgICAgICAgICBpZiAocHJvcHMuZWxUYWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChwcm9wcy5lbFRhZywgZWxBdHRycywgY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoKENvbnRlbnRJbmplY3RvciksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpLCB7IGVsUmVmOiB0aGlzLmhhbmRsZUVsLCBlbFRhZzogcHJvcHMuZWxUYWcgfHwgJ2RpdicsIGVsQ2xhc3NlczogKHByb3BzLmVsQ2xhc3NlcyB8fCBbXSkuY29uY2F0KGdlbmVyYXRlZENsYXNzTmFtZXMpLCByZW5kZXJJZDogdGhpcy5jb250ZXh0IH0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKHRoaXMuZWwpIHtcbiAgICAgICAgICAgIChfYiA9IChfYSA9IHRoaXMucHJvcHMpLmRpZE1vdW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb3BzLnJlbmRlclByb3BzKSwgeyBlbDogdGhpcy5lbCB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRpZE1vdW50TWlzZmlyZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMucHJvcHMpLndpbGxVbm1vdW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb3BzLnJlbmRlclByb3BzKSwgeyBlbDogdGhpcy5lbCB9KSk7XG4gICAgfVxufVxuQ29udGVudENvbnRhaW5lci5jb250ZXh0VHlwZSA9IFJlbmRlcklkO1xuZnVuY3Rpb24gSW5uZXJDb250ZW50SW5qZWN0b3IoY29udGFpbmVyQ29tcG9uZW50LCBwcm9wcykge1xuICAgIGNvbnN0IHBhcmVudFByb3BzID0gY29udGFpbmVyQ29tcG9uZW50LnByb3BzO1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KChDb250ZW50SW5qZWN0b3IpLCBPYmplY3QuYXNzaWduKHsgcmVuZGVyUHJvcHM6IHBhcmVudFByb3BzLnJlbmRlclByb3BzLCBnZW5lcmF0b3JOYW1lOiBwYXJlbnRQcm9wcy5nZW5lcmF0b3JOYW1lLCBjdXN0b21HZW5lcmF0b3I6IHBhcmVudFByb3BzLmN1c3RvbUdlbmVyYXRvciwgZGVmYXVsdEdlbmVyYXRvcjogcGFyZW50UHJvcHMuZGVmYXVsdEdlbmVyYXRvciwgcmVuZGVySWQ6IGNvbnRhaW5lckNvbXBvbmVudC5jb250ZXh0IH0sIHByb3BzKSk7XG59XG4vLyBVdGlsc1xuZnVuY3Rpb24gZ2VuZXJhdGVDbGFzc05hbWVzKGNsYXNzTmFtZUdlbmVyYXRvciwgcmVuZGVyUHJvcHMpIHtcbiAgICBjb25zdCBjbGFzc05hbWVzID0gdHlwZW9mIGNsYXNzTmFtZUdlbmVyYXRvciA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgIGNsYXNzTmFtZUdlbmVyYXRvcihyZW5kZXJQcm9wcykgOlxuICAgICAgICBjbGFzc05hbWVHZW5lcmF0b3IgfHwgW107XG4gICAgcmV0dXJuIHR5cGVvZiBjbGFzc05hbWVzID09PSAnc3RyaW5nJyA/IFtjbGFzc05hbWVzXSA6IGNsYXNzTmFtZXM7XG59XG5cbmNsYXNzIFZpZXdDb250YWluZXIgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSBjb250ZXh0O1xuICAgICAgICBsZXQgcmVuZGVyUHJvcHMgPSB7IHZpZXc6IGNvbnRleHQudmlld0FwaSB9O1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoQ29udGVudENvbnRhaW5lciwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMsIHsgZWxUYWc6IHByb3BzLmVsVGFnIHx8ICdkaXYnLCBlbENsYXNzZXM6IFtcbiAgICAgICAgICAgICAgICAuLi5idWlsZFZpZXdDbGFzc05hbWVzKHByb3BzLnZpZXdTcGVjKSxcbiAgICAgICAgICAgICAgICAuLi4ocHJvcHMuZWxDbGFzc2VzIHx8IFtdKSxcbiAgICAgICAgICAgIF0sIHJlbmRlclByb3BzOiByZW5kZXJQcm9wcywgY2xhc3NOYW1lR2VuZXJhdG9yOiBvcHRpb25zLnZpZXdDbGFzc05hbWVzLCBnZW5lcmF0b3JOYW1lOiB1bmRlZmluZWQsIGRpZE1vdW50OiBvcHRpb25zLnZpZXdEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMudmlld1dpbGxVbm1vdW50IH0pLCAoKSA9PiBwcm9wcy5jaGlsZHJlbikpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkVmlld0NsYXNzTmFtZXModmlld1NwZWMpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBgZmMtJHt2aWV3U3BlYy50eXBlfS12aWV3YCxcbiAgICAgICAgJ2ZjLXZpZXcnLFxuICAgIF07XG59XG5cbmZ1bmN0aW9uIHBhcnNlUmFuZ2UoaW5wdXQsIGRhdGVFbnYpIHtcbiAgICBsZXQgc3RhcnQgPSBudWxsO1xuICAgIGxldCBlbmQgPSBudWxsO1xuICAgIGlmIChpbnB1dC5zdGFydCkge1xuICAgICAgICBzdGFydCA9IGRhdGVFbnYuY3JlYXRlTWFya2VyKGlucHV0LnN0YXJ0KTtcbiAgICB9XG4gICAgaWYgKGlucHV0LmVuZCkge1xuICAgICAgICBlbmQgPSBkYXRlRW52LmNyZWF0ZU1hcmtlcihpbnB1dC5lbmQpO1xuICAgIH1cbiAgICBpZiAoIXN0YXJ0ICYmICFlbmQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChzdGFydCAmJiBlbmQgJiYgZW5kIDwgc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7IHN0YXJ0LCBlbmQgfTtcbn1cbi8vIFNJREUtRUZGRUNUOiB3aWxsIG11dGF0ZSByYW5nZXMuXG4vLyBXaWxsIHJldHVybiBhIG5ldyBhcnJheSByZXN1bHQuXG5mdW5jdGlvbiBpbnZlcnRSYW5nZXMocmFuZ2VzLCBjb25zdHJhaW50UmFuZ2UpIHtcbiAgICBsZXQgaW52ZXJ0ZWRSYW5nZXMgPSBbXTtcbiAgICBsZXQgeyBzdGFydCB9ID0gY29uc3RyYWludFJhbmdlOyAvLyB0aGUgZW5kIG9mIHRoZSBwcmV2aW91cyByYW5nZS4gdGhlIHN0YXJ0IG9mIHRoZSBuZXcgcmFuZ2VcbiAgICBsZXQgaTtcbiAgICBsZXQgZGF0ZVJhbmdlO1xuICAgIC8vIHJhbmdlcyBuZWVkIHRvIGJlIGluIG9yZGVyLiByZXF1aXJlZCBmb3Igb3VyIGRhdGUtd2Fsa2luZyBhbGdvcml0aG1cbiAgICByYW5nZXMuc29ydChjb21wYXJlUmFuZ2VzKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGRhdGVSYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgICAgLy8gYWRkIHRoZSBzcGFuIG9mIHRpbWUgYmVmb3JlIHRoZSBldmVudCAoaWYgdGhlcmUgaXMgYW55KVxuICAgICAgICBpZiAoZGF0ZVJhbmdlLnN0YXJ0ID4gc3RhcnQpIHsgLy8gY29tcGFyZSBtaWxsaXNlY29uZCB0aW1lIChza2lwIGFueSBhbWJpZyBsb2dpYylcbiAgICAgICAgICAgIGludmVydGVkUmFuZ2VzLnB1c2goeyBzdGFydCwgZW5kOiBkYXRlUmFuZ2Uuc3RhcnQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGVSYW5nZS5lbmQgPiBzdGFydCkge1xuICAgICAgICAgICAgc3RhcnQgPSBkYXRlUmFuZ2UuZW5kO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGFkZCB0aGUgc3BhbiBvZiB0aW1lIGFmdGVyIHRoZSBsYXN0IGV2ZW50IChpZiB0aGVyZSBpcyBhbnkpXG4gICAgaWYgKHN0YXJ0IDwgY29uc3RyYWludFJhbmdlLmVuZCkgeyAvLyBjb21wYXJlIG1pbGxpc2Vjb25kIHRpbWUgKHNraXAgYW55IGFtYmlnIGxvZ2ljKVxuICAgICAgICBpbnZlcnRlZFJhbmdlcy5wdXNoKHsgc3RhcnQsIGVuZDogY29uc3RyYWludFJhbmdlLmVuZCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGludmVydGVkUmFuZ2VzO1xufVxuZnVuY3Rpb24gY29tcGFyZVJhbmdlcyhyYW5nZTAsIHJhbmdlMSkge1xuICAgIHJldHVybiByYW5nZTAuc3RhcnQudmFsdWVPZigpIC0gcmFuZ2UxLnN0YXJ0LnZhbHVlT2YoKTsgLy8gZWFybGllciByYW5nZXMgZ28gZmlyc3Rcbn1cbmZ1bmN0aW9uIGludGVyc2VjdFJhbmdlcyhyYW5nZTAsIHJhbmdlMSkge1xuICAgIGxldCB7IHN0YXJ0LCBlbmQgfSA9IHJhbmdlMDtcbiAgICBsZXQgbmV3UmFuZ2UgPSBudWxsO1xuICAgIGlmIChyYW5nZTEuc3RhcnQgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSBudWxsKSB7XG4gICAgICAgICAgICBzdGFydCA9IHJhbmdlMS5zdGFydDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gbmV3IERhdGUoTWF0aC5tYXgoc3RhcnQudmFsdWVPZigpLCByYW5nZTEuc3RhcnQudmFsdWVPZigpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJhbmdlMS5lbmQgIT0gbnVsbCkge1xuICAgICAgICBpZiAoZW5kID09PSBudWxsKSB7XG4gICAgICAgICAgICBlbmQgPSByYW5nZTEuZW5kO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZW5kID0gbmV3IERhdGUoTWF0aC5taW4oZW5kLnZhbHVlT2YoKSwgcmFuZ2UxLmVuZC52YWx1ZU9mKCkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhcnQgPT09IG51bGwgfHwgZW5kID09PSBudWxsIHx8IHN0YXJ0IDwgZW5kKSB7XG4gICAgICAgIG5ld1JhbmdlID0geyBzdGFydCwgZW5kIH07XG4gICAgfVxuICAgIHJldHVybiBuZXdSYW5nZTtcbn1cbmZ1bmN0aW9uIHJhbmdlc0VxdWFsKHJhbmdlMCwgcmFuZ2UxKSB7XG4gICAgcmV0dXJuIChyYW5nZTAuc3RhcnQgPT09IG51bGwgPyBudWxsIDogcmFuZ2UwLnN0YXJ0LnZhbHVlT2YoKSkgPT09IChyYW5nZTEuc3RhcnQgPT09IG51bGwgPyBudWxsIDogcmFuZ2UxLnN0YXJ0LnZhbHVlT2YoKSkgJiZcbiAgICAgICAgKHJhbmdlMC5lbmQgPT09IG51bGwgPyBudWxsIDogcmFuZ2UwLmVuZC52YWx1ZU9mKCkpID09PSAocmFuZ2UxLmVuZCA9PT0gbnVsbCA/IG51bGwgOiByYW5nZTEuZW5kLnZhbHVlT2YoKSk7XG59XG5mdW5jdGlvbiByYW5nZXNJbnRlcnNlY3QocmFuZ2UwLCByYW5nZTEpIHtcbiAgICByZXR1cm4gKHJhbmdlMC5lbmQgPT09IG51bGwgfHwgcmFuZ2UxLnN0YXJ0ID09PSBudWxsIHx8IHJhbmdlMC5lbmQgPiByYW5nZTEuc3RhcnQpICYmXG4gICAgICAgIChyYW5nZTAuc3RhcnQgPT09IG51bGwgfHwgcmFuZ2UxLmVuZCA9PT0gbnVsbCB8fCByYW5nZTAuc3RhcnQgPCByYW5nZTEuZW5kKTtcbn1cbmZ1bmN0aW9uIHJhbmdlQ29udGFpbnNSYW5nZShvdXRlclJhbmdlLCBpbm5lclJhbmdlKSB7XG4gICAgcmV0dXJuIChvdXRlclJhbmdlLnN0YXJ0ID09PSBudWxsIHx8IChpbm5lclJhbmdlLnN0YXJ0ICE9PSBudWxsICYmIGlubmVyUmFuZ2Uuc3RhcnQgPj0gb3V0ZXJSYW5nZS5zdGFydCkpICYmXG4gICAgICAgIChvdXRlclJhbmdlLmVuZCA9PT0gbnVsbCB8fCAoaW5uZXJSYW5nZS5lbmQgIT09IG51bGwgJiYgaW5uZXJSYW5nZS5lbmQgPD0gb3V0ZXJSYW5nZS5lbmQpKTtcbn1cbmZ1bmN0aW9uIHJhbmdlQ29udGFpbnNNYXJrZXIocmFuZ2UsIGRhdGUpIHtcbiAgICByZXR1cm4gKHJhbmdlLnN0YXJ0ID09PSBudWxsIHx8IGRhdGUgPj0gcmFuZ2Uuc3RhcnQpICYmXG4gICAgICAgIChyYW5nZS5lbmQgPT09IG51bGwgfHwgZGF0ZSA8IHJhbmdlLmVuZCk7XG59XG4vLyBJZiB0aGUgZ2l2ZW4gZGF0ZSBpcyBub3Qgd2l0aGluIHRoZSBnaXZlbiByYW5nZSwgbW92ZSBpdCBpbnNpZGUuXG4vLyAoSWYgaXQncyBwYXN0IHRoZSBlbmQsIG1ha2UgaXQgb25lIG1pbGxpc2Vjb25kIGJlZm9yZSB0aGUgZW5kKS5cbmZ1bmN0aW9uIGNvbnN0cmFpbk1hcmtlclRvUmFuZ2UoZGF0ZSwgcmFuZ2UpIHtcbiAgICBpZiAocmFuZ2Uuc3RhcnQgIT0gbnVsbCAmJiBkYXRlIDwgcmFuZ2Uuc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlLnN0YXJ0O1xuICAgIH1cbiAgICBpZiAocmFuZ2UuZW5kICE9IG51bGwgJiYgZGF0ZSA+PSByYW5nZS5lbmQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHJhbmdlLmVuZC52YWx1ZU9mKCkgLSAxKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGU7XG59XG5cbi8qIERhdGUgc3R1ZmYgdGhhdCBkb2Vzbid0IGJlbG9uZyBpbiBkYXRlbGliIGNvcmVcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLy8gZ2l2ZW4gYSB0aW1lZCByYW5nZSwgY29tcHV0ZXMgYW4gYWxsLWRheSByYW5nZSB0aGF0IGhhcyB0aGUgc2FtZSBleGFjdCBkdXJhdGlvbixcbi8vIGJ1dCB3aG9zZSBzdGFydCB0aW1lIGlzIGFsaWduZWQgd2l0aCB0aGUgc3RhcnQgb2YgdGhlIGRheS5cbmZ1bmN0aW9uIGNvbXB1dGVBbGlnbmVkRGF5UmFuZ2UodGltZWRSYW5nZSkge1xuICAgIGxldCBkYXlDbnQgPSBNYXRoLmZsb29yKGRpZmZEYXlzKHRpbWVkUmFuZ2Uuc3RhcnQsIHRpbWVkUmFuZ2UuZW5kKSkgfHwgMTtcbiAgICBsZXQgc3RhcnQgPSBzdGFydE9mRGF5KHRpbWVkUmFuZ2Uuc3RhcnQpO1xuICAgIGxldCBlbmQgPSBhZGREYXlzKHN0YXJ0LCBkYXlDbnQpO1xuICAgIHJldHVybiB7IHN0YXJ0LCBlbmQgfTtcbn1cbi8vIGdpdmVuIGEgdGltZWQgcmFuZ2UsIGNvbXB1dGVzIGFuIGFsbC1kYXkgcmFuZ2UgYmFzZWQgb24gaG93IGZvciB0aGUgZW5kIGRhdGUgYmxlZWRzIGludG8gdGhlIG5leHQgZGF5XG4vLyBUT0RPOiBnaXZlIG5leHREYXlUaHJlc2hvbGQgYSBkZWZhdWx0IGFyZ1xuZnVuY3Rpb24gY29tcHV0ZVZpc2libGVEYXlSYW5nZSh0aW1lZFJhbmdlLCBuZXh0RGF5VGhyZXNob2xkID0gY3JlYXRlRHVyYXRpb24oMCkpIHtcbiAgICBsZXQgc3RhcnREYXkgPSBudWxsO1xuICAgIGxldCBlbmREYXkgPSBudWxsO1xuICAgIGlmICh0aW1lZFJhbmdlLmVuZCkge1xuICAgICAgICBlbmREYXkgPSBzdGFydE9mRGF5KHRpbWVkUmFuZ2UuZW5kKTtcbiAgICAgICAgbGV0IGVuZFRpbWVNUyA9IHRpbWVkUmFuZ2UuZW5kLnZhbHVlT2YoKSAtIGVuZERheS52YWx1ZU9mKCk7IC8vICMgb2YgbWlsbGlzZWNvbmRzIGludG8gYGVuZERheWBcbiAgICAgICAgLy8gSWYgdGhlIGVuZCB0aW1lIGlzIGFjdHVhbGx5IGluY2x1c2l2ZWx5IHBhcnQgb2YgdGhlIG5leHQgZGF5IGFuZCBpcyBlcXVhbCB0byBvclxuICAgICAgICAvLyBiZXlvbmQgdGhlIG5leHQgZGF5IHRocmVzaG9sZCwgYWRqdXN0IHRoZSBlbmQgdG8gYmUgdGhlIGV4Y2x1c2l2ZSBlbmQgb2YgYGVuZERheWAuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgbGVhdmluZyBpdCBhcyBpbmNsdXNpdmUgd2lsbCBjYXVzZSBpdCB0byBleGNsdWRlIGBlbmREYXlgLlxuICAgICAgICBpZiAoZW5kVGltZU1TICYmIGVuZFRpbWVNUyA+PSBhc1JvdWdoTXMobmV4dERheVRocmVzaG9sZCkpIHtcbiAgICAgICAgICAgIGVuZERheSA9IGFkZERheXMoZW5kRGF5LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodGltZWRSYW5nZS5zdGFydCkge1xuICAgICAgICBzdGFydERheSA9IHN0YXJ0T2ZEYXkodGltZWRSYW5nZS5zdGFydCk7IC8vIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRheSB0aGUgcmFuZ2Ugc3RhcnRzXG4gICAgICAgIC8vIElmIGVuZCBpcyB3aXRoaW4gYHN0YXJ0RGF5YCBidXQgbm90IHBhc3QgbmV4dERheVRocmVzaG9sZCwgYXNzaWduIHRoZSBkZWZhdWx0IGR1cmF0aW9uIG9mIG9uZSBkYXkuXG4gICAgICAgIGlmIChlbmREYXkgJiYgZW5kRGF5IDw9IHN0YXJ0RGF5KSB7XG4gICAgICAgICAgICBlbmREYXkgPSBhZGREYXlzKHN0YXJ0RGF5LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBzdGFydDogc3RhcnREYXksIGVuZDogZW5kRGF5IH07XG59XG4vLyBzcGFucyBmcm9tIG9uZSBkYXkgaW50byBhbm90aGVyP1xuZnVuY3Rpb24gaXNNdWx0aURheVJhbmdlKHJhbmdlKSB7XG4gICAgbGV0IHZpc2libGVSYW5nZSA9IGNvbXB1dGVWaXNpYmxlRGF5UmFuZ2UocmFuZ2UpO1xuICAgIHJldHVybiBkaWZmRGF5cyh2aXNpYmxlUmFuZ2Uuc3RhcnQsIHZpc2libGVSYW5nZS5lbmQpID4gMTtcbn1cbmZ1bmN0aW9uIGRpZmZEYXRlcyhkYXRlMCwgZGF0ZTEsIGRhdGVFbnYsIGxhcmdlVW5pdCkge1xuICAgIGlmIChsYXJnZVVuaXQgPT09ICd5ZWFyJykge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oZGF0ZUVudi5kaWZmV2hvbGVZZWFycyhkYXRlMCwgZGF0ZTEpLCAneWVhcicpO1xuICAgIH1cbiAgICBpZiAobGFyZ2VVbml0ID09PSAnbW9udGgnKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbihkYXRlRW52LmRpZmZXaG9sZU1vbnRocyhkYXRlMCwgZGF0ZTEpLCAnbW9udGgnKTtcbiAgICB9XG4gICAgcmV0dXJuIGRpZmZEYXlBbmRUaW1lKGRhdGUwLCBkYXRlMSk7IC8vIHJldHVybnMgYSBkdXJhdGlvblxufVxuXG5mdW5jdGlvbiByZWR1Y2VDdXJyZW50RGF0ZShjdXJyZW50RGF0ZSwgYWN0aW9uKSB7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdDSEFOR0VfREFURSc6XG4gICAgICAgICAgICByZXR1cm4gYWN0aW9uLmRhdGVNYXJrZXI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudERhdGU7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0SW5pdGlhbERhdGUob3B0aW9ucywgZGF0ZUVudikge1xuICAgIGxldCBpbml0aWFsRGF0ZUlucHV0ID0gb3B0aW9ucy5pbml0aWFsRGF0ZTtcbiAgICAvLyBjb21wdXRlIHRoZSBpbml0aWFsIGFtYmlnLXRpbWV6b25lIGRhdGVcbiAgICBpZiAoaW5pdGlhbERhdGVJbnB1dCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBkYXRlRW52LmNyZWF0ZU1hcmtlcihpbml0aWFsRGF0ZUlucHV0KTtcbiAgICB9XG4gICAgcmV0dXJuIGdldE5vdyhvcHRpb25zLm5vdywgZGF0ZUVudik7IC8vIGdldE5vdyBhbHJlYWR5IHJldHVybnMgdW56b25lZFxufVxuZnVuY3Rpb24gZ2V0Tm93KG5vd0lucHV0LCBkYXRlRW52KSB7XG4gICAgaWYgKHR5cGVvZiBub3dJbnB1dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBub3dJbnB1dCA9IG5vd0lucHV0KCk7XG4gICAgfVxuICAgIGlmIChub3dJbnB1dCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBkYXRlRW52LmNyZWF0ZU5vd01hcmtlcigpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZUVudi5jcmVhdGVNYXJrZXIobm93SW5wdXQpO1xufVxuXG5jbGFzcyBEYXRlUHJvZmlsZUdlbmVyYXRvciB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgICB0aGlzLm5vd0RhdGUgPSBnZXROb3cocHJvcHMubm93SW5wdXQsIHByb3BzLmRhdGVFbnYpO1xuICAgICAgICB0aGlzLmluaXRIaWRkZW5EYXlzKCk7XG4gICAgfVxuICAgIC8qIERhdGUgUmFuZ2UgQ29tcHV0YXRpb25cbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICAgIC8vIEJ1aWxkcyBhIHN0cnVjdHVyZSB3aXRoIGluZm8gYWJvdXQgd2hhdCB0aGUgZGF0ZXMvcmFuZ2VzIHdpbGwgYmUgZm9yIHRoZSBcInByZXZcIiB2aWV3LlxuICAgIGJ1aWxkUHJldihjdXJyZW50RGF0ZVByb2ZpbGUsIGN1cnJlbnREYXRlLCBmb3JjZVRvVmFsaWQpIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IHByZXZEYXRlID0gZGF0ZUVudi5zdWJ0cmFjdChkYXRlRW52LnN0YXJ0T2YoY3VycmVudERhdGUsIGN1cnJlbnREYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2VVbml0KSwgLy8gaW1wb3J0YW50IGZvciBzdGFydC1vZi1tb250aFxuICAgICAgICBjdXJyZW50RGF0ZVByb2ZpbGUuZGF0ZUluY3JlbWVudCk7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1aWxkKHByZXZEYXRlLCAtMSwgZm9yY2VUb1ZhbGlkKTtcbiAgICB9XG4gICAgLy8gQnVpbGRzIGEgc3RydWN0dXJlIHdpdGggaW5mbyBhYm91dCB3aGF0IHRoZSBkYXRlcy9yYW5nZXMgd2lsbCBiZSBmb3IgdGhlIFwibmV4dFwiIHZpZXcuXG4gICAgYnVpbGROZXh0KGN1cnJlbnREYXRlUHJvZmlsZSwgY3VycmVudERhdGUsIGZvcmNlVG9WYWxpZCkge1xuICAgICAgICBsZXQgeyBkYXRlRW52IH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBsZXQgbmV4dERhdGUgPSBkYXRlRW52LmFkZChkYXRlRW52LnN0YXJ0T2YoY3VycmVudERhdGUsIGN1cnJlbnREYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2VVbml0KSwgLy8gaW1wb3J0YW50IGZvciBzdGFydC1vZi1tb250aFxuICAgICAgICBjdXJyZW50RGF0ZVByb2ZpbGUuZGF0ZUluY3JlbWVudCk7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1aWxkKG5leHREYXRlLCAxLCBmb3JjZVRvVmFsaWQpO1xuICAgIH1cbiAgICAvLyBCdWlsZHMgYSBzdHJ1Y3R1cmUgaG9sZGluZyBkYXRlcy9yYW5nZXMgZm9yIHJlbmRlcmluZyBhcm91bmQgdGhlIGdpdmVuIGRhdGUuXG4gICAgLy8gT3B0aW9uYWwgZGlyZWN0aW9uIHBhcmFtIGluZGljYXRlcyB3aGV0aGVyIHRoZSBkYXRlIGlzIGJlaW5nIGluY3JlbWVudGVkL2RlY3JlbWVudGVkXG4gICAgLy8gZnJvbSBpdHMgcHJldmlvdXMgdmFsdWUuIGRlY3JlbWVudGVkID0gLTEsIGluY3JlbWVudGVkID0gMSAoZGVmYXVsdCkuXG4gICAgYnVpbGQoY3VycmVudERhdGUsIGRpcmVjdGlvbiwgZm9yY2VUb1ZhbGlkID0gdHJ1ZSkge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHZhbGlkUmFuZ2U7XG4gICAgICAgIGxldCBjdXJyZW50SW5mbztcbiAgICAgICAgbGV0IGlzUmFuZ2VBbGxEYXk7XG4gICAgICAgIGxldCByZW5kZXJSYW5nZTtcbiAgICAgICAgbGV0IGFjdGl2ZVJhbmdlO1xuICAgICAgICBsZXQgaXNWYWxpZDtcbiAgICAgICAgdmFsaWRSYW5nZSA9IHRoaXMuYnVpbGRWYWxpZFJhbmdlKCk7XG4gICAgICAgIHZhbGlkUmFuZ2UgPSB0aGlzLnRyaW1IaWRkZW5EYXlzKHZhbGlkUmFuZ2UpO1xuICAgICAgICBpZiAoZm9yY2VUb1ZhbGlkKSB7XG4gICAgICAgICAgICBjdXJyZW50RGF0ZSA9IGNvbnN0cmFpbk1hcmtlclRvUmFuZ2UoY3VycmVudERhdGUsIHZhbGlkUmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRJbmZvID0gdGhpcy5idWlsZEN1cnJlbnRSYW5nZUluZm8oY3VycmVudERhdGUsIGRpcmVjdGlvbik7XG4gICAgICAgIGlzUmFuZ2VBbGxEYXkgPSAvXih5ZWFyfG1vbnRofHdlZWt8ZGF5KSQvLnRlc3QoY3VycmVudEluZm8udW5pdCk7XG4gICAgICAgIHJlbmRlclJhbmdlID0gdGhpcy5idWlsZFJlbmRlclJhbmdlKHRoaXMudHJpbUhpZGRlbkRheXMoY3VycmVudEluZm8ucmFuZ2UpLCBjdXJyZW50SW5mby51bml0LCBpc1JhbmdlQWxsRGF5KTtcbiAgICAgICAgcmVuZGVyUmFuZ2UgPSB0aGlzLnRyaW1IaWRkZW5EYXlzKHJlbmRlclJhbmdlKTtcbiAgICAgICAgYWN0aXZlUmFuZ2UgPSByZW5kZXJSYW5nZTtcbiAgICAgICAgaWYgKCFwcm9wcy5zaG93Tm9uQ3VycmVudERhdGVzKSB7XG4gICAgICAgICAgICBhY3RpdmVSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhhY3RpdmVSYW5nZSwgY3VycmVudEluZm8ucmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGFjdGl2ZVJhbmdlID0gdGhpcy5hZGp1c3RBY3RpdmVSYW5nZShhY3RpdmVSYW5nZSk7XG4gICAgICAgIGFjdGl2ZVJhbmdlID0gaW50ZXJzZWN0UmFuZ2VzKGFjdGl2ZVJhbmdlLCB2YWxpZFJhbmdlKTsgLy8gbWlnaHQgcmV0dXJuIG51bGxcbiAgICAgICAgLy8gaXQncyBpbnZhbGlkIGlmIHRoZSBvcmlnaW5hbGx5IHJlcXVlc3RlZCBkYXRlIGlzIG5vdCBjb250YWluZWQsXG4gICAgICAgIC8vIG9yIGlmIHRoZSByYW5nZSBpcyBjb21wbGV0ZWx5IG91dHNpZGUgb2YgdGhlIHZhbGlkIHJhbmdlLlxuICAgICAgICBpc1ZhbGlkID0gcmFuZ2VzSW50ZXJzZWN0KGN1cnJlbnRJbmZvLnJhbmdlLCB2YWxpZFJhbmdlKTtcbiAgICAgICAgLy8gSEFDSzogY29uc3RyYWluIHRvIHJlbmRlci1yYW5nZSBzbyBgY3VycmVudERhdGVgIGlzIG1vcmUgdXNlZnVsIHRvIHZpZXcgcmVuZGVyaW5nXG4gICAgICAgIGlmICghcmFuZ2VDb250YWluc01hcmtlcihyZW5kZXJSYW5nZSwgY3VycmVudERhdGUpKSB7XG4gICAgICAgICAgICBjdXJyZW50RGF0ZSA9IHJlbmRlclJhbmdlLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjdXJyZW50RGF0ZSxcbiAgICAgICAgICAgIC8vIGNvbnN0cmFpbnQgZm9yIHdoZXJlIHByZXYvbmV4dCBvcGVyYXRpb25zIGNhbiBnbyBhbmQgd2hlcmUgZXZlbnRzIGNhbiBiZSBkcmFnZ2VkL3Jlc2l6ZWQgdG8uXG4gICAgICAgICAgICAvLyBhbiBvYmplY3Qgd2l0aCBvcHRpb25hbCBzdGFydCBhbmQgZW5kIHByb3BlcnRpZXMuXG4gICAgICAgICAgICB2YWxpZFJhbmdlLFxuICAgICAgICAgICAgLy8gcmFuZ2UgdGhlIHZpZXcgaXMgZm9ybWFsbHkgcmVzcG9uc2libGUgZm9yLlxuICAgICAgICAgICAgLy8gZm9yIGV4YW1wbGUsIGEgbW9udGggdmlldyBtaWdodCBoYXZlIDFzdC0zMXN0LCBleGNsdWRpbmcgcGFkZGVkIGRhdGVzXG4gICAgICAgICAgICBjdXJyZW50UmFuZ2U6IGN1cnJlbnRJbmZvLnJhbmdlLFxuICAgICAgICAgICAgLy8gbmFtZSBvZiBsYXJnZXN0IHVuaXQgYmVpbmcgZGlzcGxheWVkLCBsaWtlIFwibW9udGhcIiBvciBcIndlZWtcIlxuICAgICAgICAgICAgY3VycmVudFJhbmdlVW5pdDogY3VycmVudEluZm8udW5pdCxcbiAgICAgICAgICAgIGlzUmFuZ2VBbGxEYXksXG4gICAgICAgICAgICAvLyBkYXRlcyB0aGF0IGRpc3BsYXkgZXZlbnRzIGFuZCBhY2NlcHQgZHJhZy1uLWRyb3BcbiAgICAgICAgICAgIC8vIHdpbGwgYmUgYG51bGxgIGlmIG5vIGRhdGVzIGFjY2VwdCBldmVudHNcbiAgICAgICAgICAgIGFjdGl2ZVJhbmdlLFxuICAgICAgICAgICAgLy8gZGF0ZSByYW5nZSB3aXRoIGEgcmVuZGVyZWQgc2tlbGV0b25cbiAgICAgICAgICAgIC8vIGluY2x1ZGVzIG5vdC1hY3RpdmUgZGF5cyB0aGF0IG5lZWQgc29tZSBzb3J0IG9mIERPTVxuICAgICAgICAgICAgcmVuZGVyUmFuZ2UsXG4gICAgICAgICAgICAvLyBEdXJhdGlvbiBvYmplY3QgdGhhdCBkZW5vdGVzIHRoZSBmaXJzdCB2aXNpYmxlIHRpbWUgb2YgYW55IGdpdmVuIGRheVxuICAgICAgICAgICAgc2xvdE1pblRpbWU6IHByb3BzLnNsb3RNaW5UaW1lLFxuICAgICAgICAgICAgLy8gRHVyYXRpb24gb2JqZWN0IHRoYXQgZGVub3RlcyB0aGUgZXhjbHVzaXZlIHZpc2libGUgZW5kIHRpbWUgb2YgYW55IGdpdmVuIGRheVxuICAgICAgICAgICAgc2xvdE1heFRpbWU6IHByb3BzLnNsb3RNYXhUaW1lLFxuICAgICAgICAgICAgaXNWYWxpZCxcbiAgICAgICAgICAgIC8vIGhvdyBmYXIgdGhlIGN1cnJlbnQgZGF0ZSB3aWxsIG1vdmUgZm9yIGEgcHJldi9uZXh0IG9wZXJhdGlvblxuICAgICAgICAgICAgZGF0ZUluY3JlbWVudDogdGhpcy5idWlsZERhdGVJbmNyZW1lbnQoY3VycmVudEluZm8uZHVyYXRpb24pLFxuICAgICAgICAgICAgLy8gcGFzcyBhIGZhbGxiYWNrIChtaWdodCBiZSBudWxsKSBeXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIEJ1aWxkcyBhbiBvYmplY3Qgd2l0aCBvcHRpb25hbCBzdGFydC9lbmQgcHJvcGVydGllcy5cbiAgICAvLyBJbmRpY2F0ZXMgdGhlIG1pbmltdW0vbWF4aW11bSBkYXRlcyB0byBkaXNwbGF5LlxuICAgIC8vIG5vdCByZXNwb25zaWJsZSBmb3IgdHJpbW1pbmcgaGlkZGVuIGRheXMuXG4gICAgYnVpbGRWYWxpZFJhbmdlKCkge1xuICAgICAgICBsZXQgaW5wdXQgPSB0aGlzLnByb3BzLnZhbGlkUmFuZ2VJbnB1dDtcbiAgICAgICAgbGV0IHNpbXBsZUlucHV0ID0gdHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IGlucHV0LmNhbGwodGhpcy5wcm9wcy5jYWxlbmRhckFwaSwgdGhpcy5ub3dEYXRlKVxuICAgICAgICAgICAgOiBpbnB1dDtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVmaW5lUmFuZ2Uoc2ltcGxlSW5wdXQpIHx8XG4gICAgICAgICAgICB7IHN0YXJ0OiBudWxsLCBlbmQ6IG51bGwgfTsgLy8gY29tcGxldGVseSBvcGVuLWVuZGVkXG4gICAgfVxuICAgIC8vIEJ1aWxkcyBhIHN0cnVjdHVyZSB3aXRoIGluZm8gYWJvdXQgdGhlIFwiY3VycmVudFwiIHJhbmdlLCB0aGUgcmFuZ2UgdGhhdCBpc1xuICAgIC8vIGhpZ2hsaWdodGVkIGFzIGJlaW5nIHRoZSBjdXJyZW50IG1vbnRoIGZvciBleGFtcGxlLlxuICAgIC8vIFNlZSBidWlsZCgpIGZvciBhIGRlc2NyaXB0aW9uIG9mIGBkaXJlY3Rpb25gLlxuICAgIC8vIEd1YXJhbnRlZWQgdG8gaGF2ZSBgcmFuZ2VgIGFuZCBgdW5pdGAgcHJvcGVydGllcy4gYGR1cmF0aW9uYCBpcyBvcHRpb25hbC5cbiAgICBidWlsZEN1cnJlbnRSYW5nZUluZm8oZGF0ZSwgZGlyZWN0aW9uKSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgZHVyYXRpb24gPSBudWxsO1xuICAgICAgICBsZXQgdW5pdCA9IG51bGw7XG4gICAgICAgIGxldCByYW5nZSA9IG51bGw7XG4gICAgICAgIGxldCBkYXlDb3VudDtcbiAgICAgICAgaWYgKHByb3BzLmR1cmF0aW9uKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHByb3BzLmR1cmF0aW9uO1xuICAgICAgICAgICAgdW5pdCA9IHByb3BzLmR1cmF0aW9uVW5pdDtcbiAgICAgICAgICAgIHJhbmdlID0gdGhpcy5idWlsZFJhbmdlRnJvbUR1cmF0aW9uKGRhdGUsIGRpcmVjdGlvbiwgZHVyYXRpb24sIHVuaXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChkYXlDb3VudCA9IHRoaXMucHJvcHMuZGF5Q291bnQpKSB7XG4gICAgICAgICAgICB1bml0ID0gJ2RheSc7XG4gICAgICAgICAgICByYW5nZSA9IHRoaXMuYnVpbGRSYW5nZUZyb21EYXlDb3VudChkYXRlLCBkaXJlY3Rpb24sIGRheUNvdW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgocmFuZ2UgPSB0aGlzLmJ1aWxkQ3VzdG9tVmlzaWJsZVJhbmdlKGRhdGUpKSkge1xuICAgICAgICAgICAgdW5pdCA9IHByb3BzLmRhdGVFbnYuZ3JlYXRlc3RXaG9sZVVuaXQocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCkudW5pdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gdGhpcy5nZXRGYWxsYmFja0R1cmF0aW9uKCk7XG4gICAgICAgICAgICB1bml0ID0gZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yKGR1cmF0aW9uKS51bml0O1xuICAgICAgICAgICAgcmFuZ2UgPSB0aGlzLmJ1aWxkUmFuZ2VGcm9tRHVyYXRpb24oZGF0ZSwgZGlyZWN0aW9uLCBkdXJhdGlvbiwgdW5pdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZHVyYXRpb24sIHVuaXQsIHJhbmdlIH07XG4gICAgfVxuICAgIGdldEZhbGxiYWNrRHVyYXRpb24oKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7IGRheTogMSB9KTtcbiAgICB9XG4gICAgLy8gUmV0dXJucyBhIG5ldyBhY3RpdmVSYW5nZSB0byBoYXZlIHRpbWUgdmFsdWVzICh1bi1hbWJpZ3VhdGUpXG4gICAgLy8gc2xvdE1pblRpbWUgb3Igc2xvdE1heFRpbWUgY2F1c2VzIHRoZSByYW5nZSB0byBleHBhbmQuXG4gICAgYWRqdXN0QWN0aXZlUmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiwgdXNlc01pbk1heFRpbWUsIHNsb3RNaW5UaW1lLCBzbG90TWF4VGltZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IHsgc3RhcnQsIGVuZCB9ID0gcmFuZ2U7XG4gICAgICAgIGlmICh1c2VzTWluTWF4VGltZSkge1xuICAgICAgICAgICAgLy8gZXhwYW5kIGFjdGl2ZSByYW5nZSBpZiBzbG90TWluVGltZSBpcyBuZWdhdGl2ZSAod2h5IG5vdCB3aGVuIHBvc2l0aXZlPylcbiAgICAgICAgICAgIGlmIChhc1JvdWdoRGF5cyhzbG90TWluVGltZSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBzdGFydE9mRGF5KHN0YXJ0KTsgLy8gbmVjZXNzYXJ5P1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gZGF0ZUVudi5hZGQoc3RhcnQsIHNsb3RNaW5UaW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGV4cGFuZCBhY3RpdmUgcmFuZ2UgaWYgc2xvdE1heFRpbWUgaXMgYmV5b25kIG9uZSBkYXkgKHdoeSBub3Qgd2hlbiBuZWdhdGl2ZT8pXG4gICAgICAgICAgICBpZiAoYXNSb3VnaERheXMoc2xvdE1heFRpbWUpID4gMSkge1xuICAgICAgICAgICAgICAgIGVuZCA9IHN0YXJ0T2ZEYXkoZW5kKTsgLy8gbmVjZXNzYXJ5P1xuICAgICAgICAgICAgICAgIGVuZCA9IGFkZERheXMoZW5kLCAtMSk7XG4gICAgICAgICAgICAgICAgZW5kID0gZGF0ZUVudi5hZGQoZW5kLCBzbG90TWF4VGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhcnQsIGVuZCB9O1xuICAgIH1cbiAgICAvLyBCdWlsZHMgdGhlIFwiY3VycmVudFwiIHJhbmdlIHdoZW4gaXQgaXMgc3BlY2lmaWVkIGFzIGFuIGV4cGxpY2l0IGR1cmF0aW9uLlxuICAgIC8vIGB1bml0YCBpcyB0aGUgYWxyZWFkeS1jb21wdXRlZCBncmVhdGVzdER1cmF0aW9uRGVub21pbmF0b3IgdW5pdCBvZiBkdXJhdGlvbi5cbiAgICBidWlsZFJhbmdlRnJvbUR1cmF0aW9uKGRhdGUsIGRpcmVjdGlvbiwgZHVyYXRpb24sIHVuaXQpIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiwgZGF0ZUFsaWdubWVudCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IHN0YXJ0O1xuICAgICAgICBsZXQgZW5kO1xuICAgICAgICBsZXQgcmVzO1xuICAgICAgICAvLyBjb21wdXRlIHdoYXQgdGhlIGFsaWdubWVudCBzaG91bGQgYmVcbiAgICAgICAgaWYgKCFkYXRlQWxpZ25tZW50KSB7XG4gICAgICAgICAgICBsZXQgeyBkYXRlSW5jcmVtZW50IH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgaWYgKGRhdGVJbmNyZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAvLyB1c2UgdGhlIHNtYWxsZXIgb2YgdGhlIHR3byB1bml0c1xuICAgICAgICAgICAgICAgIGlmIChhc1JvdWdoTXMoZGF0ZUluY3JlbWVudCkgPCBhc1JvdWdoTXMoZHVyYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGVBbGlnbm1lbnQgPSBncmVhdGVzdER1cmF0aW9uRGVub21pbmF0b3IoZGF0ZUluY3JlbWVudCkudW5pdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGVBbGlnbm1lbnQgPSB1bml0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGVBbGlnbm1lbnQgPSB1bml0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZSB2aWV3IGRpc3BsYXlzIGEgc2luZ2xlIGRheSBvciBzbWFsbGVyXG4gICAgICAgIGlmIChhc1JvdWdoRGF5cyhkdXJhdGlvbikgPD0gMSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNIaWRkZW5EYXkoc3RhcnQpKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLnNraXBIaWRkZW5EYXlzKHN0YXJ0LCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnRPZkRheShzdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY29tcHV0ZVJlcygpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gZGF0ZUVudi5zdGFydE9mKGRhdGUsIGRhdGVBbGlnbm1lbnQpO1xuICAgICAgICAgICAgZW5kID0gZGF0ZUVudi5hZGQoc3RhcnQsIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIHJlcyA9IHsgc3RhcnQsIGVuZCB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbXB1dGVSZXMoKTtcbiAgICAgICAgLy8gaWYgcmFuZ2UgaXMgY29tcGxldGVseSBlbnZlbG9wZWQgYnkgaGlkZGVuIGRheXMsIGdvIHBhc3QgdGhlIGhpZGRlbiBkYXlzXG4gICAgICAgIGlmICghdGhpcy50cmltSGlkZGVuRGF5cyhyZXMpKSB7XG4gICAgICAgICAgICBkYXRlID0gdGhpcy5za2lwSGlkZGVuRGF5cyhkYXRlLCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgY29tcHV0ZVJlcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIC8vIEJ1aWxkcyB0aGUgXCJjdXJyZW50XCIgcmFuZ2Ugd2hlbiBhIGRheUNvdW50IGlzIHNwZWNpZmllZC5cbiAgICBidWlsZFJhbmdlRnJvbURheUNvdW50KGRhdGUsIGRpcmVjdGlvbiwgZGF5Q291bnQpIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiwgZGF0ZUFsaWdubWVudCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IHJ1bm5pbmdDb3VudCA9IDA7XG4gICAgICAgIGxldCBzdGFydCA9IGRhdGU7XG4gICAgICAgIGxldCBlbmQ7XG4gICAgICAgIGlmIChkYXRlQWxpZ25tZW50KSB7XG4gICAgICAgICAgICBzdGFydCA9IGRhdGVFbnYuc3RhcnRPZihzdGFydCwgZGF0ZUFsaWdubWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhcnQgPSBzdGFydE9mRGF5KHN0YXJ0KTtcbiAgICAgICAgc3RhcnQgPSB0aGlzLnNraXBIaWRkZW5EYXlzKHN0YXJ0LCBkaXJlY3Rpb24pO1xuICAgICAgICBlbmQgPSBzdGFydDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgZW5kID0gYWRkRGF5cyhlbmQsIDEpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzSGlkZGVuRGF5KGVuZCkpIHtcbiAgICAgICAgICAgICAgICBydW5uaW5nQ291bnQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAocnVubmluZ0NvdW50IDwgZGF5Q291bnQpO1xuICAgICAgICByZXR1cm4geyBzdGFydCwgZW5kIH07XG4gICAgfVxuICAgIC8vIEJ1aWxkcyBhIG5vcm1hbGl6ZWQgcmFuZ2Ugb2JqZWN0IGZvciB0aGUgXCJ2aXNpYmxlXCIgcmFuZ2UsXG4gICAgLy8gd2hpY2ggaXMgYSB3YXkgdG8gZGVmaW5lIHRoZSBjdXJyZW50UmFuZ2UgYW5kIGFjdGl2ZVJhbmdlIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgYnVpbGRDdXN0b21WaXNpYmxlUmFuZ2UoZGF0ZSkge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGlucHV0ID0gcHJvcHMudmlzaWJsZVJhbmdlSW5wdXQ7XG4gICAgICAgIGxldCBzaW1wbGVJbnB1dCA9IHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBpbnB1dC5jYWxsKHByb3BzLmNhbGVuZGFyQXBpLCBwcm9wcy5kYXRlRW52LnRvRGF0ZShkYXRlKSlcbiAgICAgICAgICAgIDogaW5wdXQ7XG4gICAgICAgIGxldCByYW5nZSA9IHRoaXMucmVmaW5lUmFuZ2Uoc2ltcGxlSW5wdXQpO1xuICAgICAgICBpZiAocmFuZ2UgJiYgKHJhbmdlLnN0YXJ0ID09IG51bGwgfHwgcmFuZ2UuZW5kID09IG51bGwpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfVxuICAgIC8vIENvbXB1dGVzIHRoZSByYW5nZSB0aGF0IHdpbGwgcmVwcmVzZW50IHRoZSBlbGVtZW50L2NlbGxzIGZvciAqcmVuZGVyaW5nKixcbiAgICAvLyBidXQgd2hpY2ggbWF5IGhhdmUgdm9pZGVkIGRheXMvdGltZXMuXG4gICAgLy8gbm90IHJlc3BvbnNpYmxlIGZvciB0cmltbWluZyBoaWRkZW4gZGF5cy5cbiAgICBidWlsZFJlbmRlclJhbmdlKGN1cnJlbnRSYW5nZSwgY3VycmVudFJhbmdlVW5pdCwgaXNSYW5nZUFsbERheSkge1xuICAgICAgICByZXR1cm4gY3VycmVudFJhbmdlO1xuICAgIH1cbiAgICAvLyBDb21wdXRlIHRoZSBkdXJhdGlvbiB2YWx1ZSB0aGF0IHNob3VsZCBiZSBhZGRlZC9zdWJzdHJhY3RlZCB0byB0aGUgY3VycmVudCBkYXRlXG4gICAgLy8gd2hlbiBhIHByZXYvbmV4dCBvcGVyYXRpb24gaGFwcGVucy5cbiAgICBidWlsZERhdGVJbmNyZW1lbnQoZmFsbGJhY2spIHtcbiAgICAgICAgbGV0IHsgZGF0ZUluY3JlbWVudCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IGN1c3RvbUFsaWdubWVudDtcbiAgICAgICAgaWYgKGRhdGVJbmNyZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRlSW5jcmVtZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICgoY3VzdG9tQWxpZ25tZW50ID0gdGhpcy5wcm9wcy5kYXRlQWxpZ25tZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKDEsIGN1c3RvbUFsaWdubWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHsgZGF5czogMSB9KTtcbiAgICB9XG4gICAgcmVmaW5lUmFuZ2UocmFuZ2VJbnB1dCkge1xuICAgICAgICBpZiAocmFuZ2VJbnB1dCkge1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gcGFyc2VSYW5nZShyYW5nZUlucHV0LCB0aGlzLnByb3BzLmRhdGVFbnYpO1xuICAgICAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBjb21wdXRlVmlzaWJsZURheVJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyogSGlkZGVuIERheXNcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICAgIC8vIEluaXRpYWxpemVzIGludGVybmFsIHZhcmlhYmxlcyByZWxhdGVkIHRvIGNhbGN1bGF0aW5nIGhpZGRlbiBkYXlzLW9mLXdlZWtcbiAgICBpbml0SGlkZGVuRGF5cygpIHtcbiAgICAgICAgbGV0IGhpZGRlbkRheXMgPSB0aGlzLnByb3BzLmhpZGRlbkRheXMgfHwgW107IC8vIGFycmF5IG9mIGRheS1vZi13ZWVrIGluZGljZXMgdGhhdCBhcmUgaGlkZGVuXG4gICAgICAgIGxldCBpc0hpZGRlbkRheUhhc2ggPSBbXTsgLy8gaXMgdGhlIGRheS1vZi13ZWVrIGhpZGRlbj8gKGhhc2ggd2l0aCBkYXktb2Ytd2Vlay1pbmRleCAtPiBib29sKVxuICAgICAgICBsZXQgZGF5Q250ID0gMDtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLndlZWtlbmRzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgaGlkZGVuRGF5cy5wdXNoKDAsIDYpOyAvLyAwPXN1bmRheSwgNj1zYXR1cmRheVxuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmICghKGlzSGlkZGVuRGF5SGFzaFtpXSA9IGhpZGRlbkRheXMuaW5kZXhPZihpKSAhPT0gLTEpKSB7XG4gICAgICAgICAgICAgICAgZGF5Q250ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXlDbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBoaWRkZW5EYXlzJyk7IC8vIGFsbCBkYXlzIHdlcmUgaGlkZGVuPyBiYWQuXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0hpZGRlbkRheUhhc2ggPSBpc0hpZGRlbkRheUhhc2g7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBkYXlzIGZyb20gdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIHRoZSByYW5nZSB0aGF0IGFyZSBjb21wdXRlZCBhcyBoaWRkZW4uXG4gICAgLy8gSWYgdGhlIHdob2xlIHJhbmdlIGlzIHRyaW1tZWQgb2ZmLCByZXR1cm5zIG51bGxcbiAgICB0cmltSGlkZGVuRGF5cyhyYW5nZSkge1xuICAgICAgICBsZXQgeyBzdGFydCwgZW5kIH0gPSByYW5nZTtcbiAgICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgICAgICBzdGFydCA9IHRoaXMuc2tpcEhpZGRlbkRheXMoc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgICAgIGVuZCA9IHRoaXMuc2tpcEhpZGRlbkRheXMoZW5kLCAtMSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0ID09IG51bGwgfHwgZW5kID09IG51bGwgfHwgc3RhcnQgPCBlbmQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0LCBlbmQgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gSXMgdGhlIGN1cnJlbnQgZGF5IGhpZGRlbj9cbiAgICAvLyBgZGF5YCBpcyBhIGRheS1vZi13ZWVrIGluZGV4ICgwLTYpLCBvciBhIERhdGUgKHVzZWQgZm9yIFVUQylcbiAgICBpc0hpZGRlbkRheShkYXkpIHtcbiAgICAgICAgaWYgKGRheSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgIGRheSA9IGRheS5nZXRVVENEYXkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pc0hpZGRlbkRheUhhc2hbZGF5XTtcbiAgICB9XG4gICAgLy8gSW5jcmVtZW50aW5nIHRoZSBjdXJyZW50IGRheSB1bnRpbCBpdCBpcyBubyBsb25nZXIgYSBoaWRkZW4gZGF5LCByZXR1cm5pbmcgYSBjb3B5LlxuICAgIC8vIERPRVMgTk9UIENPTlNJREVSIHZhbGlkUmFuZ2UhXG4gICAgLy8gSWYgdGhlIGluaXRpYWwgdmFsdWUgb2YgYGRhdGVgIGlzIG5vdCBhIGhpZGRlbiBkYXksIGRvbid0IGRvIGFueXRoaW5nLlxuICAgIC8vIFBhc3MgYGlzRXhjbHVzaXZlYCBhcyBgdHJ1ZWAgaWYgeW91IGFyZSBkZWFsaW5nIHdpdGggYW4gZW5kIGRhdGUuXG4gICAgLy8gYGluY2AgZGVmYXVsdHMgdG8gYDFgIChpbmNyZW1lbnQgb25lIGRheSBmb3J3YXJkIGVhY2ggdGltZSlcbiAgICBza2lwSGlkZGVuRGF5cyhkYXRlLCBpbmMgPSAxLCBpc0V4Y2x1c2l2ZSA9IGZhbHNlKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmlzSGlkZGVuRGF5SGFzaFsoZGF0ZS5nZXRVVENEYXkoKSArIChpc0V4Y2x1c2l2ZSA/IGluYyA6IDApICsgNykgJSA3XSkge1xuICAgICAgICAgICAgZGF0ZSA9IGFkZERheXMoZGF0ZSwgaW5jKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50SW5zdGFuY2UoZGVmSWQsIHJhbmdlLCBmb3JjZWRTdGFydFR6bywgZm9yY2VkRW5kVHpvKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5zdGFuY2VJZDogZ3VpZCgpLFxuICAgICAgICBkZWZJZCxcbiAgICAgICAgcmFuZ2UsXG4gICAgICAgIGZvcmNlZFN0YXJ0VHpvOiBmb3JjZWRTdGFydFR6byA9PSBudWxsID8gbnVsbCA6IGZvcmNlZFN0YXJ0VHpvLFxuICAgICAgICBmb3JjZWRFbmRUem86IGZvcmNlZEVuZFR6byA9PSBudWxsID8gbnVsbCA6IGZvcmNlZEVuZFR6byxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZVJlY3VycmluZyhyZWZpbmVkLCBkZWZhdWx0QWxsRGF5LCBkYXRlRW52LCByZWN1cnJpbmdUeXBlcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjdXJyaW5nVHlwZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgbGV0IHBhcnNlZCA9IHJlY3VycmluZ1R5cGVzW2ldLnBhcnNlKHJlZmluZWQsIGRhdGVFbnYpO1xuICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgICBsZXQgeyBhbGxEYXkgfSA9IHJlZmluZWQ7XG4gICAgICAgICAgICBpZiAoYWxsRGF5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhbGxEYXkgPSBkZWZhdWx0QWxsRGF5O1xuICAgICAgICAgICAgICAgIGlmIChhbGxEYXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBhbGxEYXkgPSBwYXJzZWQuYWxsRGF5R3Vlc3M7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGxEYXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsRGF5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFsbERheSxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogcGFyc2VkLmR1cmF0aW9uLFxuICAgICAgICAgICAgICAgIHR5cGVEYXRhOiBwYXJzZWQudHlwZURhdGEsXG4gICAgICAgICAgICAgICAgdHlwZUlkOiBpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGV4cGFuZFJlY3VycmluZyhldmVudFN0b3JlLCBmcmFtaW5nUmFuZ2UsIGNvbnRleHQpIHtcbiAgICBsZXQgeyBkYXRlRW52LCBwbHVnaW5Ib29rcywgb3B0aW9ucyB9ID0gY29udGV4dDtcbiAgICBsZXQgeyBkZWZzLCBpbnN0YW5jZXMgfSA9IGV2ZW50U3RvcmU7XG4gICAgLy8gcmVtb3ZlIGV4aXN0aW5nIHJlY3VycmluZyBpbnN0YW5jZXNcbiAgICAvLyBUT0RPOiBiYWQuIGFsd2F5cyBleHBhbmQgZXZlbnRzIGFzIGEgc2Vjb25kIHN0ZXBcbiAgICBpbnN0YW5jZXMgPSBmaWx0ZXJIYXNoKGluc3RhbmNlcywgKGluc3RhbmNlKSA9PiAhZGVmc1tpbnN0YW5jZS5kZWZJZF0ucmVjdXJyaW5nRGVmKTtcbiAgICBmb3IgKGxldCBkZWZJZCBpbiBkZWZzKSB7XG4gICAgICAgIGxldCBkZWYgPSBkZWZzW2RlZklkXTtcbiAgICAgICAgaWYgKGRlZi5yZWN1cnJpbmdEZWYpIHtcbiAgICAgICAgICAgIGxldCB7IGR1cmF0aW9uIH0gPSBkZWYucmVjdXJyaW5nRGVmO1xuICAgICAgICAgICAgaWYgKCFkdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gZGVmLmFsbERheSA/XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb24gOlxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc3RhcnRzID0gZXhwYW5kUmVjdXJyaW5nUmFuZ2VzKGRlZiwgZHVyYXRpb24sIGZyYW1pbmdSYW5nZSwgZGF0ZUVudiwgcGx1Z2luSG9va3MucmVjdXJyaW5nVHlwZXMpO1xuICAgICAgICAgICAgZm9yIChsZXQgc3RhcnQgb2Ygc3RhcnRzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGluc3RhbmNlID0gY3JlYXRlRXZlbnRJbnN0YW5jZShkZWZJZCwge1xuICAgICAgICAgICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBkYXRlRW52LmFkZChzdGFydCwgZHVyYXRpb24pLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGluc3RhbmNlc1tpbnN0YW5jZS5pbnN0YW5jZUlkXSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGRlZnMsIGluc3RhbmNlcyB9O1xufVxuLypcbkV2ZW50IE1VU1QgaGF2ZSBhIHJlY3VycmluZ0RlZlxuKi9cbmZ1bmN0aW9uIGV4cGFuZFJlY3VycmluZ1JhbmdlcyhldmVudERlZiwgZHVyYXRpb24sIGZyYW1pbmdSYW5nZSwgZGF0ZUVudiwgcmVjdXJyaW5nVHlwZXMpIHtcbiAgICBsZXQgdHlwZURlZiA9IHJlY3VycmluZ1R5cGVzW2V2ZW50RGVmLnJlY3VycmluZ0RlZi50eXBlSWRdO1xuICAgIGxldCBtYXJrZXJzID0gdHlwZURlZi5leHBhbmQoZXZlbnREZWYucmVjdXJyaW5nRGVmLnR5cGVEYXRhLCB7XG4gICAgICAgIHN0YXJ0OiBkYXRlRW52LnN1YnRyYWN0KGZyYW1pbmdSYW5nZS5zdGFydCwgZHVyYXRpb24pLFxuICAgICAgICBlbmQ6IGZyYW1pbmdSYW5nZS5lbmQsXG4gICAgfSwgZGF0ZUVudik7XG4gICAgLy8gdGhlIHJlY3VycmVuY2UgcGx1Z2lucyBkb24ndCBndWFyYW50ZWUgdGhhdCBhbGwtZGF5IGV2ZW50cyBhcmUgc3RhcnQtb2YtZGF5LCBzbyB3ZSBoYXZlIHRvXG4gICAgaWYgKGV2ZW50RGVmLmFsbERheSkge1xuICAgICAgICBtYXJrZXJzID0gbWFya2Vycy5tYXAoc3RhcnRPZkRheSk7XG4gICAgfVxuICAgIHJldHVybiBtYXJrZXJzO1xufVxuXG5jb25zdCBFVkVOVF9OT05fREFURV9SRUZJTkVSUyA9IHtcbiAgICBpZDogU3RyaW5nLFxuICAgIGdyb3VwSWQ6IFN0cmluZyxcbiAgICB0aXRsZTogU3RyaW5nLFxuICAgIHVybDogU3RyaW5nLFxuICAgIGludGVyYWN0aXZlOiBCb29sZWFuLFxufTtcbmNvbnN0IEVWRU5UX0RBVEVfUkVGSU5FUlMgPSB7XG4gICAgc3RhcnQ6IGlkZW50aXR5LFxuICAgIGVuZDogaWRlbnRpdHksXG4gICAgZGF0ZTogaWRlbnRpdHksXG4gICAgYWxsRGF5OiBCb29sZWFuLFxufTtcbmNvbnN0IEVWRU5UX1JFRklORVJTID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIEVWRU5UX05PTl9EQVRFX1JFRklORVJTKSwgRVZFTlRfREFURV9SRUZJTkVSUyksIHsgZXh0ZW5kZWRQcm9wczogaWRlbnRpdHkgfSk7XG5mdW5jdGlvbiBwYXJzZUV2ZW50KHJhdywgZXZlbnRTb3VyY2UsIGNvbnRleHQsIGFsbG93T3BlblJhbmdlLCByZWZpbmVycyA9IGJ1aWxkRXZlbnRSZWZpbmVycyhjb250ZXh0KSwgZGVmSWRNYXAsIGluc3RhbmNlSWRNYXApIHtcbiAgICBsZXQgeyByZWZpbmVkLCBleHRyYSB9ID0gcmVmaW5lRXZlbnREZWYocmF3LCBjb250ZXh0LCByZWZpbmVycyk7XG4gICAgbGV0IGRlZmF1bHRBbGxEYXkgPSBjb21wdXRlSXNEZWZhdWx0QWxsRGF5KGV2ZW50U291cmNlLCBjb250ZXh0KTtcbiAgICBsZXQgcmVjdXJyaW5nUmVzID0gcGFyc2VSZWN1cnJpbmcocmVmaW5lZCwgZGVmYXVsdEFsbERheSwgY29udGV4dC5kYXRlRW52LCBjb250ZXh0LnBsdWdpbkhvb2tzLnJlY3VycmluZ1R5cGVzKTtcbiAgICBpZiAocmVjdXJyaW5nUmVzKSB7XG4gICAgICAgIGxldCBkZWYgPSBwYXJzZUV2ZW50RGVmKHJlZmluZWQsIGV4dHJhLCBldmVudFNvdXJjZSA/IGV2ZW50U291cmNlLnNvdXJjZUlkIDogJycsIHJlY3VycmluZ1Jlcy5hbGxEYXksIEJvb2xlYW4ocmVjdXJyaW5nUmVzLmR1cmF0aW9uKSwgY29udGV4dCwgZGVmSWRNYXApO1xuICAgICAgICBkZWYucmVjdXJyaW5nRGVmID0ge1xuICAgICAgICAgICAgdHlwZUlkOiByZWN1cnJpbmdSZXMudHlwZUlkLFxuICAgICAgICAgICAgdHlwZURhdGE6IHJlY3VycmluZ1Jlcy50eXBlRGF0YSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiByZWN1cnJpbmdSZXMuZHVyYXRpb24sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7IGRlZiwgaW5zdGFuY2U6IG51bGwgfTtcbiAgICB9XG4gICAgbGV0IHNpbmdsZVJlcyA9IHBhcnNlU2luZ2xlKHJlZmluZWQsIGRlZmF1bHRBbGxEYXksIGNvbnRleHQsIGFsbG93T3BlblJhbmdlKTtcbiAgICBpZiAoc2luZ2xlUmVzKSB7XG4gICAgICAgIGxldCBkZWYgPSBwYXJzZUV2ZW50RGVmKHJlZmluZWQsIGV4dHJhLCBldmVudFNvdXJjZSA/IGV2ZW50U291cmNlLnNvdXJjZUlkIDogJycsIHNpbmdsZVJlcy5hbGxEYXksIHNpbmdsZVJlcy5oYXNFbmQsIGNvbnRleHQsIGRlZklkTWFwKTtcbiAgICAgICAgbGV0IGluc3RhbmNlID0gY3JlYXRlRXZlbnRJbnN0YW5jZShkZWYuZGVmSWQsIHNpbmdsZVJlcy5yYW5nZSwgc2luZ2xlUmVzLmZvcmNlZFN0YXJ0VHpvLCBzaW5nbGVSZXMuZm9yY2VkRW5kVHpvKTtcbiAgICAgICAgaWYgKGluc3RhbmNlSWRNYXAgJiYgZGVmLnB1YmxpY0lkICYmIGluc3RhbmNlSWRNYXBbZGVmLnB1YmxpY0lkXSkge1xuICAgICAgICAgICAgaW5zdGFuY2UuaW5zdGFuY2VJZCA9IGluc3RhbmNlSWRNYXBbZGVmLnB1YmxpY0lkXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkZWYsIGluc3RhbmNlIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcmVmaW5lRXZlbnREZWYocmF3LCBjb250ZXh0LCByZWZpbmVycyA9IGJ1aWxkRXZlbnRSZWZpbmVycyhjb250ZXh0KSkge1xuICAgIHJldHVybiByZWZpbmVQcm9wcyhyYXcsIHJlZmluZXJzKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRXZlbnRSZWZpbmVycyhjb250ZXh0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBFVkVOVF9VSV9SRUZJTkVSUyksIEVWRU5UX1JFRklORVJTKSwgY29udGV4dC5wbHVnaW5Ib29rcy5ldmVudFJlZmluZXJzKTtcbn1cbi8qXG5XaWxsIE5PVCBwb3B1bGF0ZSBleHRlbmRlZFByb3BzIHdpdGggdGhlIGxlZnRvdmVyIHByb3BlcnRpZXMuXG5XaWxsIE5PVCBwb3B1bGF0ZSBkYXRlLXJlbGF0ZWQgcHJvcHMuXG4qL1xuZnVuY3Rpb24gcGFyc2VFdmVudERlZihyZWZpbmVkLCBleHRyYSwgc291cmNlSWQsIGFsbERheSwgaGFzRW5kLCBjb250ZXh0LCBkZWZJZE1hcCkge1xuICAgIGxldCBkZWYgPSB7XG4gICAgICAgIHRpdGxlOiByZWZpbmVkLnRpdGxlIHx8ICcnLFxuICAgICAgICBncm91cElkOiByZWZpbmVkLmdyb3VwSWQgfHwgJycsXG4gICAgICAgIHB1YmxpY0lkOiByZWZpbmVkLmlkIHx8ICcnLFxuICAgICAgICB1cmw6IHJlZmluZWQudXJsIHx8ICcnLFxuICAgICAgICByZWN1cnJpbmdEZWY6IG51bGwsXG4gICAgICAgIGRlZklkOiAoKGRlZklkTWFwICYmIHJlZmluZWQuaWQpID8gZGVmSWRNYXBbcmVmaW5lZC5pZF0gOiAnJykgfHwgZ3VpZCgpLFxuICAgICAgICBzb3VyY2VJZCxcbiAgICAgICAgYWxsRGF5LFxuICAgICAgICBoYXNFbmQsXG4gICAgICAgIGludGVyYWN0aXZlOiByZWZpbmVkLmludGVyYWN0aXZlLFxuICAgICAgICB1aTogY3JlYXRlRXZlbnRVaShyZWZpbmVkLCBjb250ZXh0KSxcbiAgICAgICAgZXh0ZW5kZWRQcm9wczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAocmVmaW5lZC5leHRlbmRlZFByb3BzIHx8IHt9KSksIGV4dHJhKSxcbiAgICB9O1xuICAgIGZvciAobGV0IG1lbWJlckFkZGVyIG9mIGNvbnRleHQucGx1Z2luSG9va3MuZXZlbnREZWZNZW1iZXJBZGRlcnMpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihkZWYsIG1lbWJlckFkZGVyKHJlZmluZWQpKTtcbiAgICB9XG4gICAgLy8gaGVscCBvdXQgRXZlbnRJbXBsIGZyb20gaGF2aW5nIHVzZXIgbW9kaWZ5IHByb3BzXG4gICAgT2JqZWN0LmZyZWV6ZShkZWYudWkuY2xhc3NOYW1lcyk7XG4gICAgT2JqZWN0LmZyZWV6ZShkZWYuZXh0ZW5kZWRQcm9wcyk7XG4gICAgcmV0dXJuIGRlZjtcbn1cbmZ1bmN0aW9uIHBhcnNlU2luZ2xlKHJlZmluZWQsIGRlZmF1bHRBbGxEYXksIGNvbnRleHQsIGFsbG93T3BlblJhbmdlKSB7XG4gICAgbGV0IHsgYWxsRGF5IH0gPSByZWZpbmVkO1xuICAgIGxldCBzdGFydE1ldGE7XG4gICAgbGV0IHN0YXJ0TWFya2VyID0gbnVsbDtcbiAgICBsZXQgaGFzRW5kID0gZmFsc2U7XG4gICAgbGV0IGVuZE1ldGE7XG4gICAgbGV0IGVuZE1hcmtlciA9IG51bGw7XG4gICAgbGV0IHN0YXJ0SW5wdXQgPSByZWZpbmVkLnN0YXJ0ICE9IG51bGwgPyByZWZpbmVkLnN0YXJ0IDogcmVmaW5lZC5kYXRlO1xuICAgIHN0YXJ0TWV0YSA9IGNvbnRleHQuZGF0ZUVudi5jcmVhdGVNYXJrZXJNZXRhKHN0YXJ0SW5wdXQpO1xuICAgIGlmIChzdGFydE1ldGEpIHtcbiAgICAgICAgc3RhcnRNYXJrZXIgPSBzdGFydE1ldGEubWFya2VyO1xuICAgIH1cbiAgICBlbHNlIGlmICghYWxsb3dPcGVuUmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChyZWZpbmVkLmVuZCAhPSBudWxsKSB7XG4gICAgICAgIGVuZE1ldGEgPSBjb250ZXh0LmRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShyZWZpbmVkLmVuZCk7XG4gICAgfVxuICAgIGlmIChhbGxEYXkgPT0gbnVsbCkge1xuICAgICAgICBpZiAoZGVmYXVsdEFsbERheSAhPSBudWxsKSB7XG4gICAgICAgICAgICBhbGxEYXkgPSBkZWZhdWx0QWxsRGF5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZmFsbCBiYWNrIHRvIHRoZSBkYXRlIHByb3BzIExBU1RcbiAgICAgICAgICAgIGFsbERheSA9ICghc3RhcnRNZXRhIHx8IHN0YXJ0TWV0YS5pc1RpbWVVbnNwZWNpZmllZCkgJiZcbiAgICAgICAgICAgICAgICAoIWVuZE1ldGEgfHwgZW5kTWV0YS5pc1RpbWVVbnNwZWNpZmllZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFsbERheSAmJiBzdGFydE1hcmtlcikge1xuICAgICAgICBzdGFydE1hcmtlciA9IHN0YXJ0T2ZEYXkoc3RhcnRNYXJrZXIpO1xuICAgIH1cbiAgICBpZiAoZW5kTWV0YSkge1xuICAgICAgICBlbmRNYXJrZXIgPSBlbmRNZXRhLm1hcmtlcjtcbiAgICAgICAgaWYgKGFsbERheSkge1xuICAgICAgICAgICAgZW5kTWFya2VyID0gc3RhcnRPZkRheShlbmRNYXJrZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydE1hcmtlciAmJiBlbmRNYXJrZXIgPD0gc3RhcnRNYXJrZXIpIHtcbiAgICAgICAgICAgIGVuZE1hcmtlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuZE1hcmtlcikge1xuICAgICAgICBoYXNFbmQgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmICghYWxsb3dPcGVuUmFuZ2UpIHtcbiAgICAgICAgaGFzRW5kID0gY29udGV4dC5vcHRpb25zLmZvcmNlRXZlbnREdXJhdGlvbiB8fCBmYWxzZTtcbiAgICAgICAgZW5kTWFya2VyID0gY29udGV4dC5kYXRlRW52LmFkZChzdGFydE1hcmtlciwgYWxsRGF5ID9cbiAgICAgICAgICAgIGNvbnRleHQub3B0aW9ucy5kZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbiA6XG4gICAgICAgICAgICBjb250ZXh0Lm9wdGlvbnMuZGVmYXVsdFRpbWVkRXZlbnREdXJhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGFsbERheSxcbiAgICAgICAgaGFzRW5kLFxuICAgICAgICByYW5nZTogeyBzdGFydDogc3RhcnRNYXJrZXIsIGVuZDogZW5kTWFya2VyIH0sXG4gICAgICAgIGZvcmNlZFN0YXJ0VHpvOiBzdGFydE1ldGEgPyBzdGFydE1ldGEuZm9yY2VkVHpvIDogbnVsbCxcbiAgICAgICAgZm9yY2VkRW5kVHpvOiBlbmRNZXRhID8gZW5kTWV0YS5mb3JjZWRUem8gOiBudWxsLFxuICAgIH07XG59XG5mdW5jdGlvbiBjb21wdXRlSXNEZWZhdWx0QWxsRGF5KGV2ZW50U291cmNlLCBjb250ZXh0KSB7XG4gICAgbGV0IHJlcyA9IG51bGw7XG4gICAgaWYgKGV2ZW50U291cmNlKSB7XG4gICAgICAgIHJlcyA9IGV2ZW50U291cmNlLmRlZmF1bHRBbGxEYXk7XG4gICAgfVxuICAgIGlmIChyZXMgPT0gbnVsbCkge1xuICAgICAgICByZXMgPSBjb250ZXh0Lm9wdGlvbnMuZGVmYXVsdEFsbERheTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gcGFyc2VFdmVudHMocmF3RXZlbnRzLCBldmVudFNvdXJjZSwgY29udGV4dCwgYWxsb3dPcGVuUmFuZ2UsIGRlZklkTWFwLCBpbnN0YW5jZUlkTWFwKSB7XG4gICAgbGV0IGV2ZW50U3RvcmUgPSBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTtcbiAgICBsZXQgZXZlbnRSZWZpbmVycyA9IGJ1aWxkRXZlbnRSZWZpbmVycyhjb250ZXh0KTtcbiAgICBmb3IgKGxldCByYXdFdmVudCBvZiByYXdFdmVudHMpIHtcbiAgICAgICAgbGV0IHR1cGxlID0gcGFyc2VFdmVudChyYXdFdmVudCwgZXZlbnRTb3VyY2UsIGNvbnRleHQsIGFsbG93T3BlblJhbmdlLCBldmVudFJlZmluZXJzLCBkZWZJZE1hcCwgaW5zdGFuY2VJZE1hcCk7XG4gICAgICAgIGlmICh0dXBsZSkge1xuICAgICAgICAgICAgZXZlbnRUdXBsZVRvU3RvcmUodHVwbGUsIGV2ZW50U3RvcmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBldmVudFN0b3JlO1xufVxuZnVuY3Rpb24gZXZlbnRUdXBsZVRvU3RvcmUodHVwbGUsIGV2ZW50U3RvcmUgPSBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSkge1xuICAgIGV2ZW50U3RvcmUuZGVmc1t0dXBsZS5kZWYuZGVmSWRdID0gdHVwbGUuZGVmO1xuICAgIGlmICh0dXBsZS5pbnN0YW5jZSkge1xuICAgICAgICBldmVudFN0b3JlLmluc3RhbmNlc1t0dXBsZS5pbnN0YW5jZS5pbnN0YW5jZUlkXSA9IHR1cGxlLmluc3RhbmNlO1xuICAgIH1cbiAgICByZXR1cm4gZXZlbnRTdG9yZTtcbn1cbi8vIHJldHJpZXZlcyBldmVudHMgdGhhdCBoYXZlIHRoZSBzYW1lIGdyb3VwSWQgYXMgdGhlIGluc3RhbmNlIHNwZWNpZmllZCBieSBgaW5zdGFuY2VJZGBcbi8vIG9yIHRoZXkgYXJlIHRoZSBzYW1lIGFzIHRoZSBpbnN0YW5jZS5cbi8vIHdoeSBtaWdodCBpbnN0YW5jZUlkIG5vdCBiZSBpbiB0aGUgc3RvcmU/IGFuIGV2ZW50IGZyb20gYW5vdGhlciBjYWxlbmRhcj9cbmZ1bmN0aW9uIGdldFJlbGV2YW50RXZlbnRzKGV2ZW50U3RvcmUsIGluc3RhbmNlSWQpIHtcbiAgICBsZXQgaW5zdGFuY2UgPSBldmVudFN0b3JlLmluc3RhbmNlc1tpbnN0YW5jZUlkXTtcbiAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgbGV0IGRlZiA9IGV2ZW50U3RvcmUuZGVmc1tpbnN0YW5jZS5kZWZJZF07XG4gICAgICAgIC8vIGdldCBldmVudHMvaW5zdGFuY2VzIHdpdGggc2FtZSBncm91cFxuICAgICAgICBsZXQgbmV3U3RvcmUgPSBmaWx0ZXJFdmVudFN0b3JlRGVmcyhldmVudFN0b3JlLCAobG9va0RlZikgPT4gaXNFdmVudERlZnNHcm91cGVkKGRlZiwgbG9va0RlZikpO1xuICAgICAgICAvLyBhZGQgdGhlIG9yaWdpbmFsXG4gICAgICAgIC8vIFRPRE86IHdpc2ggd2UgY291bGQgdXNlIGV2ZW50VHVwbGVUb1N0b3JlIG9yIHNvbWV0aGluZyBsaWtlIGl0XG4gICAgICAgIG5ld1N0b3JlLmRlZnNbZGVmLmRlZklkXSA9IGRlZjtcbiAgICAgICAgbmV3U3RvcmUuaW5zdGFuY2VzW2luc3RhbmNlLmluc3RhbmNlSWRdID0gaW5zdGFuY2U7XG4gICAgICAgIHJldHVybiBuZXdTdG9yZTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpO1xufVxuZnVuY3Rpb24gaXNFdmVudERlZnNHcm91cGVkKGRlZjAsIGRlZjEpIHtcbiAgICByZXR1cm4gQm9vbGVhbihkZWYwLmdyb3VwSWQgJiYgZGVmMC5ncm91cElkID09PSBkZWYxLmdyb3VwSWQpO1xufVxuZnVuY3Rpb24gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCkge1xuICAgIHJldHVybiB7IGRlZnM6IHt9LCBpbnN0YW5jZXM6IHt9IH07XG59XG5mdW5jdGlvbiBtZXJnZUV2ZW50U3RvcmVzKHN0b3JlMCwgc3RvcmUxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVmczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdG9yZTAuZGVmcyksIHN0b3JlMS5kZWZzKSxcbiAgICAgICAgaW5zdGFuY2VzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0b3JlMC5pbnN0YW5jZXMpLCBzdG9yZTEuaW5zdGFuY2VzKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZmlsdGVyRXZlbnRTdG9yZURlZnMoZXZlbnRTdG9yZSwgZmlsdGVyRnVuYykge1xuICAgIGxldCBkZWZzID0gZmlsdGVySGFzaChldmVudFN0b3JlLmRlZnMsIGZpbHRlckZ1bmMpO1xuICAgIGxldCBpbnN0YW5jZXMgPSBmaWx0ZXJIYXNoKGV2ZW50U3RvcmUuaW5zdGFuY2VzLCAoaW5zdGFuY2UpID0+IChkZWZzW2luc3RhbmNlLmRlZklkXSAvLyBzdGlsbCBleGlzdHM/XG4gICAgKSk7XG4gICAgcmV0dXJuIHsgZGVmcywgaW5zdGFuY2VzIH07XG59XG5mdW5jdGlvbiBleGNsdWRlU3ViRXZlbnRTdG9yZShtYXN0ZXIsIHN1Yikge1xuICAgIGxldCB7IGRlZnMsIGluc3RhbmNlcyB9ID0gbWFzdGVyO1xuICAgIGxldCBmaWx0ZXJlZERlZnMgPSB7fTtcbiAgICBsZXQgZmlsdGVyZWRJbnN0YW5jZXMgPSB7fTtcbiAgICBmb3IgKGxldCBkZWZJZCBpbiBkZWZzKSB7XG4gICAgICAgIGlmICghc3ViLmRlZnNbZGVmSWRdKSB7IC8vIG5vdCBleHBsaWNpdGx5IGV4Y2x1ZGVkXG4gICAgICAgICAgICBmaWx0ZXJlZERlZnNbZGVmSWRdID0gZGVmc1tkZWZJZF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaW5zdGFuY2VJZCBpbiBpbnN0YW5jZXMpIHtcbiAgICAgICAgaWYgKCFzdWIuaW5zdGFuY2VzW2luc3RhbmNlSWRdICYmIC8vIG5vdCBleHBsaWNpdGx5IGV4Y2x1ZGVkXG4gICAgICAgICAgICBmaWx0ZXJlZERlZnNbaW5zdGFuY2VzW2luc3RhbmNlSWRdLmRlZklkXSAvLyBkZWYgd2Fzbid0IGZpbHRlcmVkIGF3YXlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBmaWx0ZXJlZEluc3RhbmNlc1tpbnN0YW5jZUlkXSA9IGluc3RhbmNlc1tpbnN0YW5jZUlkXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBkZWZzOiBmaWx0ZXJlZERlZnMsXG4gICAgICAgIGluc3RhbmNlczogZmlsdGVyZWRJbnN0YW5jZXMsXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplQ29uc3RyYWludChpbnB1dCwgY29udGV4dCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gcGFyc2VFdmVudHMoaW5wdXQsIG51bGwsIGNvbnRleHQsIHRydWUpOyAvLyBhbGxvd09wZW5SYW5nZT10cnVlXG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmIGlucHV0KSB7IC8vIG5vbi1udWxsIG9iamVjdFxuICAgICAgICByZXR1cm4gcGFyc2VFdmVudHMoW2lucHV0XSwgbnVsbCwgY29udGV4dCwgdHJ1ZSk7IC8vIGFsbG93T3BlblJhbmdlPXRydWVcbiAgICB9XG4gICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhpbnB1dCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBwYXJzZUNsYXNzTmFtZXMocmF3KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmF3KSkge1xuICAgICAgICByZXR1cm4gcmF3O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHJhdyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHJhdy5zcGxpdCgvXFxzKy8pO1xuICAgIH1cbiAgICByZXR1cm4gW107XG59XG5cbi8vIFRPRE86IGJldHRlciBjYWxsZWQgXCJFdmVudFNldHRpbmdzXCIgb3IgXCJFdmVudENvbmZpZ1wiXG4vLyBUT0RPOiBtb3ZlIHRoaXMgZmlsZSBpbnRvIHN0cnVjdHNcbi8vIFRPRE86IHNlcGFyYXRlIGNvbnN0cmFpbnQvb3ZlcmxhcC9hbGxvdywgYmVjYXVzZSBzZWxlY3Rpb24gdXNlcyBvbmx5IHRoYXQsIG5vdCBvdGhlciBwcm9wc1xuY29uc3QgRVZFTlRfVUlfUkVGSU5FUlMgPSB7XG4gICAgZGlzcGxheTogU3RyaW5nLFxuICAgIGVkaXRhYmxlOiBCb29sZWFuLFxuICAgIHN0YXJ0RWRpdGFibGU6IEJvb2xlYW4sXG4gICAgZHVyYXRpb25FZGl0YWJsZTogQm9vbGVhbixcbiAgICBjb25zdHJhaW50OiBpZGVudGl0eSxcbiAgICBvdmVybGFwOiBpZGVudGl0eSxcbiAgICBhbGxvdzogaWRlbnRpdHksXG4gICAgY2xhc3NOYW1lOiBwYXJzZUNsYXNzTmFtZXMsXG4gICAgY2xhc3NOYW1lczogcGFyc2VDbGFzc05hbWVzLFxuICAgIGNvbG9yOiBTdHJpbmcsXG4gICAgYmFja2dyb3VuZENvbG9yOiBTdHJpbmcsXG4gICAgYm9yZGVyQ29sb3I6IFN0cmluZyxcbiAgICB0ZXh0Q29sb3I6IFN0cmluZyxcbn07XG5jb25zdCBFTVBUWV9FVkVOVF9VSSA9IHtcbiAgICBkaXNwbGF5OiBudWxsLFxuICAgIHN0YXJ0RWRpdGFibGU6IG51bGwsXG4gICAgZHVyYXRpb25FZGl0YWJsZTogbnVsbCxcbiAgICBjb25zdHJhaW50czogW10sXG4gICAgb3ZlcmxhcDogbnVsbCxcbiAgICBhbGxvd3M6IFtdLFxuICAgIGJhY2tncm91bmRDb2xvcjogJycsXG4gICAgYm9yZGVyQ29sb3I6ICcnLFxuICAgIHRleHRDb2xvcjogJycsXG4gICAgY2xhc3NOYW1lczogW10sXG59O1xuZnVuY3Rpb24gY3JlYXRlRXZlbnRVaShyZWZpbmVkLCBjb250ZXh0KSB7XG4gICAgbGV0IGNvbnN0cmFpbnQgPSBub3JtYWxpemVDb25zdHJhaW50KHJlZmluZWQuY29uc3RyYWludCwgY29udGV4dCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGlzcGxheTogcmVmaW5lZC5kaXNwbGF5IHx8IG51bGwsXG4gICAgICAgIHN0YXJ0RWRpdGFibGU6IHJlZmluZWQuc3RhcnRFZGl0YWJsZSAhPSBudWxsID8gcmVmaW5lZC5zdGFydEVkaXRhYmxlIDogcmVmaW5lZC5lZGl0YWJsZSxcbiAgICAgICAgZHVyYXRpb25FZGl0YWJsZTogcmVmaW5lZC5kdXJhdGlvbkVkaXRhYmxlICE9IG51bGwgPyByZWZpbmVkLmR1cmF0aW9uRWRpdGFibGUgOiByZWZpbmVkLmVkaXRhYmxlLFxuICAgICAgICBjb25zdHJhaW50czogY29uc3RyYWludCAhPSBudWxsID8gW2NvbnN0cmFpbnRdIDogW10sXG4gICAgICAgIG92ZXJsYXA6IHJlZmluZWQub3ZlcmxhcCAhPSBudWxsID8gcmVmaW5lZC5vdmVybGFwIDogbnVsbCxcbiAgICAgICAgYWxsb3dzOiByZWZpbmVkLmFsbG93ICE9IG51bGwgPyBbcmVmaW5lZC5hbGxvd10gOiBbXSxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiByZWZpbmVkLmJhY2tncm91bmRDb2xvciB8fCByZWZpbmVkLmNvbG9yIHx8ICcnLFxuICAgICAgICBib3JkZXJDb2xvcjogcmVmaW5lZC5ib3JkZXJDb2xvciB8fCByZWZpbmVkLmNvbG9yIHx8ICcnLFxuICAgICAgICB0ZXh0Q29sb3I6IHJlZmluZWQudGV4dENvbG9yIHx8ICcnLFxuICAgICAgICBjbGFzc05hbWVzOiAocmVmaW5lZC5jbGFzc05hbWUgfHwgW10pLmNvbmNhdChyZWZpbmVkLmNsYXNzTmFtZXMgfHwgW10pLCAvLyBqb2luIHNpbmd1bGFyIGFuZCBwbHVyYWxcbiAgICB9O1xufVxuLy8gVE9ETzogcHJldmVudCBhZ2FpbnN0IHByb2JsZW1zIHdpdGggPDIgYXJncyFcbmZ1bmN0aW9uIGNvbWJpbmVFdmVudFVpcyh1aXMpIHtcbiAgICByZXR1cm4gdWlzLnJlZHVjZShjb21iaW5lVHdvRXZlbnRVaXMsIEVNUFRZX0VWRU5UX1VJKTtcbn1cbmZ1bmN0aW9uIGNvbWJpbmVUd29FdmVudFVpcyhpdGVtMCwgaXRlbTEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBkaXNwbGF5OiBpdGVtMS5kaXNwbGF5ICE9IG51bGwgPyBpdGVtMS5kaXNwbGF5IDogaXRlbTAuZGlzcGxheSxcbiAgICAgICAgc3RhcnRFZGl0YWJsZTogaXRlbTEuc3RhcnRFZGl0YWJsZSAhPSBudWxsID8gaXRlbTEuc3RhcnRFZGl0YWJsZSA6IGl0ZW0wLnN0YXJ0RWRpdGFibGUsXG4gICAgICAgIGR1cmF0aW9uRWRpdGFibGU6IGl0ZW0xLmR1cmF0aW9uRWRpdGFibGUgIT0gbnVsbCA/IGl0ZW0xLmR1cmF0aW9uRWRpdGFibGUgOiBpdGVtMC5kdXJhdGlvbkVkaXRhYmxlLFxuICAgICAgICBjb25zdHJhaW50czogaXRlbTAuY29uc3RyYWludHMuY29uY2F0KGl0ZW0xLmNvbnN0cmFpbnRzKSxcbiAgICAgICAgb3ZlcmxhcDogdHlwZW9mIGl0ZW0xLm92ZXJsYXAgPT09ICdib29sZWFuJyA/IGl0ZW0xLm92ZXJsYXAgOiBpdGVtMC5vdmVybGFwLFxuICAgICAgICBhbGxvd3M6IGl0ZW0wLmFsbG93cy5jb25jYXQoaXRlbTEuYWxsb3dzKSxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBpdGVtMS5iYWNrZ3JvdW5kQ29sb3IgfHwgaXRlbTAuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICBib3JkZXJDb2xvcjogaXRlbTEuYm9yZGVyQ29sb3IgfHwgaXRlbTAuYm9yZGVyQ29sb3IsXG4gICAgICAgIHRleHRDb2xvcjogaXRlbTEudGV4dENvbG9yIHx8IGl0ZW0wLnRleHRDb2xvcixcbiAgICAgICAgY2xhc3NOYW1lczogaXRlbTAuY2xhc3NOYW1lcy5jb25jYXQoaXRlbTEuY2xhc3NOYW1lcyksXG4gICAgfTtcbn1cblxuY29uc3QgRVZFTlRfU09VUkNFX1JFRklORVJTID0ge1xuICAgIGlkOiBTdHJpbmcsXG4gICAgZGVmYXVsdEFsbERheTogQm9vbGVhbixcbiAgICB1cmw6IFN0cmluZyxcbiAgICBmb3JtYXQ6IFN0cmluZyxcbiAgICBldmVudHM6IGlkZW50aXR5LFxuICAgIGV2ZW50RGF0YVRyYW5zZm9ybTogaWRlbnRpdHksXG4gICAgLy8gZm9yIGFueSBuZXR3b3JrLXJlbGF0ZWQgc291cmNlc1xuICAgIHN1Y2Nlc3M6IGlkZW50aXR5LFxuICAgIGZhaWx1cmU6IGlkZW50aXR5LFxufTtcbmZ1bmN0aW9uIHBhcnNlRXZlbnRTb3VyY2UocmF3LCBjb250ZXh0LCByZWZpbmVycyA9IGJ1aWxkRXZlbnRTb3VyY2VSZWZpbmVycyhjb250ZXh0KSkge1xuICAgIGxldCByYXdPYmo7XG4gICAgaWYgKHR5cGVvZiByYXcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJhd09iaiA9IHsgdXJsOiByYXcgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHJhdyA9PT0gJ2Z1bmN0aW9uJyB8fCBBcnJheS5pc0FycmF5KHJhdykpIHtcbiAgICAgICAgcmF3T2JqID0geyBldmVudHM6IHJhdyB9O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgcmF3ID09PSAnb2JqZWN0JyAmJiByYXcpIHsgLy8gbm90IG51bGxcbiAgICAgICAgcmF3T2JqID0gcmF3O1xuICAgIH1cbiAgICBpZiAocmF3T2JqKSB7XG4gICAgICAgIGxldCB7IHJlZmluZWQsIGV4dHJhIH0gPSByZWZpbmVQcm9wcyhyYXdPYmosIHJlZmluZXJzKTtcbiAgICAgICAgbGV0IG1ldGFSZXMgPSBidWlsZEV2ZW50U291cmNlTWV0YShyZWZpbmVkLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKG1ldGFSZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgX3JhdzogcmF3LFxuICAgICAgICAgICAgICAgIGlzRmV0Y2hpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGxhdGVzdEZldGNoSWQ6ICcnLFxuICAgICAgICAgICAgICAgIGZldGNoUmFuZ2U6IG51bGwsXG4gICAgICAgICAgICAgICAgZGVmYXVsdEFsbERheTogcmVmaW5lZC5kZWZhdWx0QWxsRGF5LFxuICAgICAgICAgICAgICAgIGV2ZW50RGF0YVRyYW5zZm9ybTogcmVmaW5lZC5ldmVudERhdGFUcmFuc2Zvcm0sXG4gICAgICAgICAgICAgICAgc3VjY2VzczogcmVmaW5lZC5zdWNjZXNzLFxuICAgICAgICAgICAgICAgIGZhaWx1cmU6IHJlZmluZWQuZmFpbHVyZSxcbiAgICAgICAgICAgICAgICBwdWJsaWNJZDogcmVmaW5lZC5pZCB8fCAnJyxcbiAgICAgICAgICAgICAgICBzb3VyY2VJZDogZ3VpZCgpLFxuICAgICAgICAgICAgICAgIHNvdXJjZURlZklkOiBtZXRhUmVzLnNvdXJjZURlZklkLFxuICAgICAgICAgICAgICAgIG1ldGE6IG1ldGFSZXMubWV0YSxcbiAgICAgICAgICAgICAgICB1aTogY3JlYXRlRXZlbnRVaShyZWZpbmVkLCBjb250ZXh0KSxcbiAgICAgICAgICAgICAgICBleHRlbmRlZFByb3BzOiBleHRyYSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBidWlsZEV2ZW50U291cmNlUmVmaW5lcnMoY29udGV4dCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgRVZFTlRfVUlfUkVGSU5FUlMpLCBFVkVOVF9TT1VSQ0VfUkVGSU5FUlMpLCBjb250ZXh0LnBsdWdpbkhvb2tzLmV2ZW50U291cmNlUmVmaW5lcnMpO1xufVxuZnVuY3Rpb24gYnVpbGRFdmVudFNvdXJjZU1ldGEocmF3LCBjb250ZXh0KSB7XG4gICAgbGV0IGRlZnMgPSBjb250ZXh0LnBsdWdpbkhvb2tzLmV2ZW50U291cmNlRGVmcztcbiAgICBmb3IgKGxldCBpID0gZGVmcy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkgeyAvLyBsYXRlci1hZGRlZCBwbHVnaW5zIHRha2UgcHJlY2VkZW5jZVxuICAgICAgICBsZXQgZGVmID0gZGVmc1tpXTtcbiAgICAgICAgbGV0IG1ldGEgPSBkZWYucGFyc2VNZXRhKHJhdyk7XG4gICAgICAgIGlmIChtZXRhKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzb3VyY2VEZWZJZDogaSwgbWV0YSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiByZWR1Y2VFdmVudFN0b3JlKGV2ZW50U3RvcmUsIGFjdGlvbiwgZXZlbnRTb3VyY2VzLCBkYXRlUHJvZmlsZSwgY29udGV4dCkge1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnUkVDRUlWRV9FVkVOVFMnOiAvLyByYXdcbiAgICAgICAgICAgIHJldHVybiByZWNlaXZlUmF3RXZlbnRzKGV2ZW50U3RvcmUsIGV2ZW50U291cmNlc1thY3Rpb24uc291cmNlSWRdLCBhY3Rpb24uZmV0Y2hJZCwgYWN0aW9uLmZldGNoUmFuZ2UsIGFjdGlvbi5yYXdFdmVudHMsIGNvbnRleHQpO1xuICAgICAgICBjYXNlICdSRVNFVF9SQVdfRVZFTlRTJzpcbiAgICAgICAgICAgIHJldHVybiByZXNldFJhd0V2ZW50cyhldmVudFN0b3JlLCBldmVudFNvdXJjZXNbYWN0aW9uLnNvdXJjZUlkXSwgYWN0aW9uLnJhd0V2ZW50cywgZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UsIGNvbnRleHQpO1xuICAgICAgICBjYXNlICdBRERfRVZFTlRTJzogLy8gYWxyZWFkeSBwYXJzZWQsIGJ1dCBub3QgZXhwYW5kZWRcbiAgICAgICAgICAgIHJldHVybiBhZGRFdmVudChldmVudFN0b3JlLCBhY3Rpb24uZXZlbnRTdG9yZSwgLy8gbmV3IG9uZXNcbiAgICAgICAgICAgIGRhdGVQcm9maWxlID8gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UgOiBudWxsLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSAnUkVTRVRfRVZFTlRTJzpcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb24uZXZlbnRTdG9yZTtcbiAgICAgICAgY2FzZSAnTUVSR0VfRVZFTlRTJzogLy8gYWxyZWFkeSBwYXJzZWQgYW5kIGV4cGFuZGVkXG4gICAgICAgICAgICByZXR1cm4gbWVyZ2VFdmVudFN0b3JlcyhldmVudFN0b3JlLCBhY3Rpb24uZXZlbnRTdG9yZSk7XG4gICAgICAgIGNhc2UgJ1BSRVYnOiAvLyBUT0RPOiBob3cgZG8gd2UgdHJhY2sgYWxsIGFjdGlvbnMgdGhhdCBhZmZlY3QgZGF0ZVByb2ZpbGUgOihcbiAgICAgICAgY2FzZSAnTkVYVCc6XG4gICAgICAgIGNhc2UgJ0NIQU5HRV9EQVRFJzpcbiAgICAgICAgY2FzZSAnQ0hBTkdFX1ZJRVdfVFlQRSc6XG4gICAgICAgICAgICBpZiAoZGF0ZVByb2ZpbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwYW5kUmVjdXJyaW5nKGV2ZW50U3RvcmUsIGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBldmVudFN0b3JlO1xuICAgICAgICBjYXNlICdSRU1PVkVfRVZFTlRTJzpcbiAgICAgICAgICAgIHJldHVybiBleGNsdWRlU3ViRXZlbnRTdG9yZShldmVudFN0b3JlLCBhY3Rpb24uZXZlbnRTdG9yZSk7XG4gICAgICAgIGNhc2UgJ1JFTU9WRV9FVkVOVF9TT1VSQ0UnOlxuICAgICAgICAgICAgcmV0dXJuIGV4Y2x1ZGVFdmVudHNCeVNvdXJjZUlkKGV2ZW50U3RvcmUsIGFjdGlvbi5zb3VyY2VJZCk7XG4gICAgICAgIGNhc2UgJ1JFTU9WRV9BTExfRVZFTlRfU09VUkNFUyc6XG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyRXZlbnRTdG9yZURlZnMoZXZlbnRTdG9yZSwgKGV2ZW50RGVmKSA9PiAoIWV2ZW50RGVmLnNvdXJjZUlkIC8vIG9ubHkga2VlcCBldmVudHMgd2l0aCBubyBzb3VyY2UgaWRcbiAgICAgICAgICAgICkpO1xuICAgICAgICBjYXNlICdSRU1PVkVfQUxMX0VWRU5UUyc6XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRTdG9yZTtcbiAgICB9XG59XG5mdW5jdGlvbiByZWNlaXZlUmF3RXZlbnRzKGV2ZW50U3RvcmUsIGV2ZW50U291cmNlLCBmZXRjaElkLCBmZXRjaFJhbmdlLCByYXdFdmVudHMsIGNvbnRleHQpIHtcbiAgICBpZiAoZXZlbnRTb3VyY2UgJiYgLy8gbm90IGFscmVhZHkgcmVtb3ZlZFxuICAgICAgICBmZXRjaElkID09PSBldmVudFNvdXJjZS5sYXRlc3RGZXRjaElkIC8vIFRPRE86IHdpc2ggdGhpcyBsb2dpYyB3YXMgYWx3YXlzIGluIGV2ZW50LXNvdXJjZXNcbiAgICApIHtcbiAgICAgICAgbGV0IHN1YnNldCA9IHBhcnNlRXZlbnRzKHRyYW5zZm9ybVJhd0V2ZW50cyhyYXdFdmVudHMsIGV2ZW50U291cmNlLCBjb250ZXh0KSwgZXZlbnRTb3VyY2UsIGNvbnRleHQpO1xuICAgICAgICBpZiAoZmV0Y2hSYW5nZSkge1xuICAgICAgICAgICAgc3Vic2V0ID0gZXhwYW5kUmVjdXJyaW5nKHN1YnNldCwgZmV0Y2hSYW5nZSwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lcmdlRXZlbnRTdG9yZXMoZXhjbHVkZUV2ZW50c0J5U291cmNlSWQoZXZlbnRTdG9yZSwgZXZlbnRTb3VyY2Uuc291cmNlSWQpLCBzdWJzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gZXZlbnRTdG9yZTtcbn1cbmZ1bmN0aW9uIHJlc2V0UmF3RXZlbnRzKGV4aXN0aW5nRXZlbnRTdG9yZSwgZXZlbnRTb3VyY2UsIHJhd0V2ZW50cywgYWN0aXZlUmFuZ2UsIGNvbnRleHQpIHtcbiAgICBjb25zdCB7IGRlZklkTWFwLCBpbnN0YW5jZUlkTWFwIH0gPSBidWlsZFB1YmxpY0lkTWFwcyhleGlzdGluZ0V2ZW50U3RvcmUpO1xuICAgIGxldCBuZXdFdmVudFN0b3JlID0gcGFyc2VFdmVudHModHJhbnNmb3JtUmF3RXZlbnRzKHJhd0V2ZW50cywgZXZlbnRTb3VyY2UsIGNvbnRleHQpLCBldmVudFNvdXJjZSwgY29udGV4dCwgZmFsc2UsIGRlZklkTWFwLCBpbnN0YW5jZUlkTWFwKTtcbiAgICByZXR1cm4gZXhwYW5kUmVjdXJyaW5nKG5ld0V2ZW50U3RvcmUsIGFjdGl2ZVJhbmdlLCBjb250ZXh0KTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybVJhd0V2ZW50cyhyYXdFdmVudHMsIGV2ZW50U291cmNlLCBjb250ZXh0KSB7XG4gICAgbGV0IGNhbEVhY2hUcmFuc2Zvcm0gPSBjb250ZXh0Lm9wdGlvbnMuZXZlbnREYXRhVHJhbnNmb3JtO1xuICAgIGxldCBzb3VyY2VFYWNoVHJhbnNmb3JtID0gZXZlbnRTb3VyY2UgPyBldmVudFNvdXJjZS5ldmVudERhdGFUcmFuc2Zvcm0gOiBudWxsO1xuICAgIGlmIChzb3VyY2VFYWNoVHJhbnNmb3JtKSB7XG4gICAgICAgIHJhd0V2ZW50cyA9IHRyYW5zZm9ybUVhY2hSYXdFdmVudChyYXdFdmVudHMsIHNvdXJjZUVhY2hUcmFuc2Zvcm0pO1xuICAgIH1cbiAgICBpZiAoY2FsRWFjaFRyYW5zZm9ybSkge1xuICAgICAgICByYXdFdmVudHMgPSB0cmFuc2Zvcm1FYWNoUmF3RXZlbnQocmF3RXZlbnRzLCBjYWxFYWNoVHJhbnNmb3JtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJhd0V2ZW50cztcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybUVhY2hSYXdFdmVudChyYXdFdmVudHMsIGZ1bmMpIHtcbiAgICBsZXQgcmVmaW5lZEV2ZW50cztcbiAgICBpZiAoIWZ1bmMpIHtcbiAgICAgICAgcmVmaW5lZEV2ZW50cyA9IHJhd0V2ZW50cztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlZmluZWRFdmVudHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcmF3RXZlbnQgb2YgcmF3RXZlbnRzKSB7XG4gICAgICAgICAgICBsZXQgcmVmaW5lZEV2ZW50ID0gZnVuYyhyYXdFdmVudCk7XG4gICAgICAgICAgICBpZiAocmVmaW5lZEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgcmVmaW5lZEV2ZW50cy5wdXNoKHJlZmluZWRFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZWZpbmVkRXZlbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlZmluZWRFdmVudHMucHVzaChyYXdFdmVudCk7XG4gICAgICAgICAgICB9IC8vIGlmIGEgZGlmZmVyZW50IGZhbHN5IHZhbHVlLCBkbyBub3RoaW5nXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlZmluZWRFdmVudHM7XG59XG5mdW5jdGlvbiBhZGRFdmVudChldmVudFN0b3JlLCBzdWJzZXQsIGV4cGFuZFJhbmdlLCBjb250ZXh0KSB7XG4gICAgaWYgKGV4cGFuZFJhbmdlKSB7XG4gICAgICAgIHN1YnNldCA9IGV4cGFuZFJlY3VycmluZyhzdWJzZXQsIGV4cGFuZFJhbmdlLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlRXZlbnRTdG9yZXMoZXZlbnRTdG9yZSwgc3Vic2V0KTtcbn1cbmZ1bmN0aW9uIHJlem9uZUV2ZW50U3RvcmVEYXRlcyhldmVudFN0b3JlLCBvbGREYXRlRW52LCBuZXdEYXRlRW52KSB7XG4gICAgbGV0IHsgZGVmcyB9ID0gZXZlbnRTdG9yZTtcbiAgICBsZXQgaW5zdGFuY2VzID0gbWFwSGFzaChldmVudFN0b3JlLmluc3RhbmNlcywgKGluc3RhbmNlKSA9PiB7XG4gICAgICAgIGxldCBkZWYgPSBkZWZzW2luc3RhbmNlLmRlZklkXTtcbiAgICAgICAgaWYgKGRlZi5hbGxEYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTsgLy8gaXNuJ3QgZGVwZW5kZW50IG9uIHRpbWV6b25lXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaW5zdGFuY2UpLCB7IHJhbmdlOiB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IG5ld0RhdGVFbnYuY3JlYXRlTWFya2VyKG9sZERhdGVFbnYudG9EYXRlKGluc3RhbmNlLnJhbmdlLnN0YXJ0LCBpbnN0YW5jZS5mb3JjZWRTdGFydFR6bykpLFxuICAgICAgICAgICAgICAgIGVuZDogbmV3RGF0ZUVudi5jcmVhdGVNYXJrZXIob2xkRGF0ZUVudi50b0RhdGUoaW5zdGFuY2UucmFuZ2UuZW5kLCBpbnN0YW5jZS5mb3JjZWRFbmRUem8pKSxcbiAgICAgICAgICAgIH0sIGZvcmNlZFN0YXJ0VHpvOiBuZXdEYXRlRW52LmNhbkNvbXB1dGVPZmZzZXQgPyBudWxsIDogaW5zdGFuY2UuZm9yY2VkU3RhcnRUem8sIGZvcmNlZEVuZFR6bzogbmV3RGF0ZUVudi5jYW5Db21wdXRlT2Zmc2V0ID8gbnVsbCA6IGluc3RhbmNlLmZvcmNlZEVuZFR6byB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4geyBkZWZzLCBpbnN0YW5jZXMgfTtcbn1cbmZ1bmN0aW9uIGV4Y2x1ZGVFdmVudHNCeVNvdXJjZUlkKGV2ZW50U3RvcmUsIHNvdXJjZUlkKSB7XG4gICAgcmV0dXJuIGZpbHRlckV2ZW50U3RvcmVEZWZzKGV2ZW50U3RvcmUsIChldmVudERlZikgPT4gZXZlbnREZWYuc291cmNlSWQgIT09IHNvdXJjZUlkKTtcbn1cbi8vIFFVRVNUSU9OOiB3aHkgbm90IGp1c3QgcmV0dXJuIGluc3RhbmNlcz8gZG8gYSBnZW5lcmFsIG9iamVjdC1wcm9wZXJ0eS1leGNsdXNpb24gdXRpbFxuZnVuY3Rpb24gZXhjbHVkZUluc3RhbmNlcyhldmVudFN0b3JlLCByZW1vdmFscykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlZnM6IGV2ZW50U3RvcmUuZGVmcyxcbiAgICAgICAgaW5zdGFuY2VzOiBmaWx0ZXJIYXNoKGV2ZW50U3RvcmUuaW5zdGFuY2VzLCAoaW5zdGFuY2UpID0+ICFyZW1vdmFsc1tpbnN0YW5jZS5pbnN0YW5jZUlkXSksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkUHVibGljSWRNYXBzKGV2ZW50U3RvcmUpIHtcbiAgICBjb25zdCB7IGRlZnMsIGluc3RhbmNlcyB9ID0gZXZlbnRTdG9yZTtcbiAgICBjb25zdCBkZWZJZE1hcCA9IHt9O1xuICAgIGNvbnN0IGluc3RhbmNlSWRNYXAgPSB7fTtcbiAgICBmb3IgKGxldCBkZWZJZCBpbiBkZWZzKSB7XG4gICAgICAgIGNvbnN0IGRlZiA9IGRlZnNbZGVmSWRdO1xuICAgICAgICBjb25zdCB7IHB1YmxpY0lkIH0gPSBkZWY7XG4gICAgICAgIGlmIChwdWJsaWNJZCkge1xuICAgICAgICAgICAgZGVmSWRNYXBbcHVibGljSWRdID0gZGVmSWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaW5zdGFuY2VJZCBpbiBpbnN0YW5jZXMpIHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBpbnN0YW5jZXNbaW5zdGFuY2VJZF07XG4gICAgICAgIGNvbnN0IGRlZiA9IGRlZnNbaW5zdGFuY2UuZGVmSWRdO1xuICAgICAgICBjb25zdCB7IHB1YmxpY0lkIH0gPSBkZWY7XG4gICAgICAgIGlmIChwdWJsaWNJZCkge1xuICAgICAgICAgICAgaW5zdGFuY2VJZE1hcFtwdWJsaWNJZF0gPSBpbnN0YW5jZUlkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGRlZklkTWFwLCBpbnN0YW5jZUlkTWFwIH07XG59XG5cbmNsYXNzIEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0ge307XG4gICAgICAgIHRoaXMudGhpc0NvbnRleHQgPSBudWxsO1xuICAgIH1cbiAgICBzZXRUaGlzQ29udGV4dCh0aGlzQ29udGV4dCkge1xuICAgICAgICB0aGlzLnRoaXNDb250ZXh0ID0gdGhpc0NvbnRleHQ7XG4gICAgfVxuICAgIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICBvbih0eXBlLCBoYW5kbGVyKSB7XG4gICAgICAgIGFkZFRvSGFzaCh0aGlzLmhhbmRsZXJzLCB0eXBlLCBoYW5kbGVyKTtcbiAgICB9XG4gICAgb2ZmKHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgcmVtb3ZlRnJvbUhhc2godGhpcy5oYW5kbGVycywgdHlwZSwgaGFuZGxlcik7XG4gICAgfVxuICAgIHRyaWdnZXIodHlwZSwgLi4uYXJncykge1xuICAgICAgICBsZXQgYXR0YWNoZWRIYW5kbGVycyA9IHRoaXMuaGFuZGxlcnNbdHlwZV0gfHwgW107XG4gICAgICAgIGxldCBvcHRpb25IYW5kbGVyID0gdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9uc1t0eXBlXTtcbiAgICAgICAgbGV0IGhhbmRsZXJzID0gW10uY29uY2F0KG9wdGlvbkhhbmRsZXIgfHwgW10sIGF0dGFjaGVkSGFuZGxlcnMpO1xuICAgICAgICBmb3IgKGxldCBoYW5kbGVyIG9mIGhhbmRsZXJzKSB7XG4gICAgICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMudGhpc0NvbnRleHQsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhc0hhbmRsZXJzKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oKHRoaXMuaGFuZGxlcnNbdHlwZV0gJiYgdGhpcy5oYW5kbGVyc1t0eXBlXS5sZW5ndGgpIHx8XG4gICAgICAgICAgICAodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9uc1t0eXBlXSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZFRvSGFzaChoYXNoLCB0eXBlLCBoYW5kbGVyKSB7XG4gICAgKGhhc2hbdHlwZV0gfHwgKGhhc2hbdHlwZV0gPSBbXSkpXG4gICAgICAgIC5wdXNoKGhhbmRsZXIpO1xufVxuZnVuY3Rpb24gcmVtb3ZlRnJvbUhhc2goaGFzaCwgdHlwZSwgaGFuZGxlcikge1xuICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgIGlmIChoYXNoW3R5cGVdKSB7XG4gICAgICAgICAgICBoYXNoW3R5cGVdID0gaGFzaFt0eXBlXS5maWx0ZXIoKGZ1bmMpID0+IGZ1bmMgIT09IGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkZWxldGUgaGFzaFt0eXBlXTsgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyIGZ1bmNzIGZvciB0aGlzIHR5cGVcbiAgICB9XG59XG5cbmNvbnN0IERFRl9ERUZBVUxUUyA9IHtcbiAgICBzdGFydFRpbWU6ICcwOTowMCcsXG4gICAgZW5kVGltZTogJzE3OjAwJyxcbiAgICBkYXlzT2ZXZWVrOiBbMSwgMiwgMywgNCwgNV0sXG4gICAgZGlzcGxheTogJ2ludmVyc2UtYmFja2dyb3VuZCcsXG4gICAgY2xhc3NOYW1lczogJ2ZjLW5vbi1idXNpbmVzcycsXG4gICAgZ3JvdXBJZDogJ19idXNpbmVzc0hvdXJzJywgLy8gc28gbXVsdGlwbGUgZGVmcyBnZXQgZ3JvdXBlZFxufTtcbi8qXG5UT0RPOiBwYXNzIGFyb3VuZCBhcyBFdmVudERlZkhhc2ghISFcbiovXG5mdW5jdGlvbiBwYXJzZUJ1c2luZXNzSG91cnMoaW5wdXQsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gcGFyc2VFdmVudHMocmVmaW5lSW5wdXRzKGlucHV0KSwgbnVsbCwgY29udGV4dCk7XG59XG5mdW5jdGlvbiByZWZpbmVJbnB1dHMoaW5wdXQpIHtcbiAgICBsZXQgcmF3RGVmcztcbiAgICBpZiAoaW5wdXQgPT09IHRydWUpIHtcbiAgICAgICAgcmF3RGVmcyA9IFt7fV07IC8vIHdpbGwgZ2V0IERFRl9ERUZBVUxUUyB2ZXJiYXRpbVxuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICAvLyBpZiBzcGVjaWZ5aW5nIGFuIGFycmF5LCBldmVyeSBzdWItZGVmaW5pdGlvbiBORUVEUyBhIGRheS1vZi13ZWVrXG4gICAgICAgIHJhd0RlZnMgPSBpbnB1dC5maWx0ZXIoKHJhd0RlZikgPT4gcmF3RGVmLmRheXNPZldlZWspO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmIGlucHV0KSB7IC8vIG5vbi1udWxsIG9iamVjdFxuICAgICAgICByYXdEZWZzID0gW2lucHV0XTtcbiAgICB9XG4gICAgZWxzZSB7IC8vIGlzIHByb2JhYmx5IGZhbHNlXG4gICAgICAgIHJhd0RlZnMgPSBbXTtcbiAgICB9XG4gICAgcmF3RGVmcyA9IHJhd0RlZnMubWFwKChyYXdEZWYpID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIERFRl9ERUZBVUxUUyksIHJhd0RlZikpKTtcbiAgICByZXR1cm4gcmF3RGVmcztcbn1cblxuZnVuY3Rpb24gdHJpZ2dlckRhdGVTZWxlY3Qoc2VsZWN0aW9uLCBwZXYsIGNvbnRleHQpIHtcbiAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignc2VsZWN0JywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBidWlsZERhdGVTcGFuQXBpV2l0aENvbnRleHQoc2VsZWN0aW9uLCBjb250ZXh0KSksIHsganNFdmVudDogcGV2ID8gcGV2Lm9yaWdFdmVudCA6IG51bGwsIHZpZXc6IGNvbnRleHQudmlld0FwaSB8fCBjb250ZXh0LmNhbGVuZGFyQXBpLnZpZXcgfSkpO1xufVxuZnVuY3Rpb24gdHJpZ2dlckRhdGVVbnNlbGVjdChwZXYsIGNvbnRleHQpIHtcbiAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcigndW5zZWxlY3QnLCB7XG4gICAgICAgIGpzRXZlbnQ6IHBldiA/IHBldi5vcmlnRXZlbnQgOiBudWxsLFxuICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGkgfHwgY29udGV4dC5jYWxlbmRhckFwaS52aWV3LFxuICAgIH0pO1xufVxuZnVuY3Rpb24gYnVpbGREYXRlU3BhbkFwaVdpdGhDb250ZXh0KGRhdGVTcGFuLCBjb250ZXh0KSB7XG4gICAgbGV0IHByb3BzID0ge307XG4gICAgZm9yIChsZXQgdHJhbnNmb3JtIG9mIGNvbnRleHQucGx1Z2luSG9va3MuZGF0ZVNwYW5UcmFuc2Zvcm1zKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24ocHJvcHMsIHRyYW5zZm9ybShkYXRlU3BhbiwgY29udGV4dCkpO1xuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKHByb3BzLCBidWlsZERhdGVTcGFuQXBpKGRhdGVTcGFuLCBjb250ZXh0LmRhdGVFbnYpKTtcbiAgICByZXR1cm4gcHJvcHM7XG59XG4vLyBHaXZlbiBhbiBldmVudCdzIGFsbERheSBzdGF0dXMgYW5kIHN0YXJ0IGRhdGUsIHJldHVybiB3aGF0IGl0cyBmYWxsYmFjayBlbmQgZGF0ZSBzaG91bGQgYmUuXG4vLyBUT0RPOiByZW5hbWUgdG8gY29tcHV0ZURlZmF1bHRFdmVudEVuZFxuZnVuY3Rpb24gZ2V0RGVmYXVsdEV2ZW50RW5kKGFsbERheSwgbWFya2VyLCBjb250ZXh0KSB7XG4gICAgbGV0IHsgZGF0ZUVudiwgb3B0aW9ucyB9ID0gY29udGV4dDtcbiAgICBsZXQgZW5kID0gbWFya2VyO1xuICAgIGlmIChhbGxEYXkpIHtcbiAgICAgICAgZW5kID0gc3RhcnRPZkRheShlbmQpO1xuICAgICAgICBlbmQgPSBkYXRlRW52LmFkZChlbmQsIG9wdGlvbnMuZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb24pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZW5kID0gZGF0ZUVudi5hZGQoZW5kLCBvcHRpb25zLmRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gZW5kO1xufVxuXG4vLyBhcHBsaWVzIHRoZSBtdXRhdGlvbiB0byBBTEwgZGVmcy9pbnN0YW5jZXMgd2l0aGluIHRoZSBldmVudCBzdG9yZVxuZnVuY3Rpb24gYXBwbHlNdXRhdGlvblRvRXZlbnRTdG9yZShldmVudFN0b3JlLCBldmVudENvbmZpZ0Jhc2UsIG11dGF0aW9uLCBjb250ZXh0KSB7XG4gICAgbGV0IGV2ZW50Q29uZmlncyA9IGNvbXBpbGVFdmVudFVpcyhldmVudFN0b3JlLmRlZnMsIGV2ZW50Q29uZmlnQmFzZSk7XG4gICAgbGV0IGRlc3QgPSBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTtcbiAgICBmb3IgKGxldCBkZWZJZCBpbiBldmVudFN0b3JlLmRlZnMpIHtcbiAgICAgICAgbGV0IGRlZiA9IGV2ZW50U3RvcmUuZGVmc1tkZWZJZF07XG4gICAgICAgIGRlc3QuZGVmc1tkZWZJZF0gPSBhcHBseU11dGF0aW9uVG9FdmVudERlZihkZWYsIGV2ZW50Q29uZmlnc1tkZWZJZF0sIG11dGF0aW9uLCBjb250ZXh0KTtcbiAgICB9XG4gICAgZm9yIChsZXQgaW5zdGFuY2VJZCBpbiBldmVudFN0b3JlLmluc3RhbmNlcykge1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSBldmVudFN0b3JlLmluc3RhbmNlc1tpbnN0YW5jZUlkXTtcbiAgICAgICAgbGV0IGRlZiA9IGRlc3QuZGVmc1tpbnN0YW5jZS5kZWZJZF07IC8vIGltcG9ydGFudCB0byBncmFiIHRoZSBuZXdseSBtb2RpZmllZCBkZWZcbiAgICAgICAgZGVzdC5pbnN0YW5jZXNbaW5zdGFuY2VJZF0gPSBhcHBseU11dGF0aW9uVG9FdmVudEluc3RhbmNlKGluc3RhbmNlLCBkZWYsIGV2ZW50Q29uZmlnc1tpbnN0YW5jZS5kZWZJZF0sIG11dGF0aW9uLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG59XG5mdW5jdGlvbiBhcHBseU11dGF0aW9uVG9FdmVudERlZihldmVudERlZiwgZXZlbnRDb25maWcsIG11dGF0aW9uLCBjb250ZXh0KSB7XG4gICAgbGV0IHN0YW5kYXJkUHJvcHMgPSBtdXRhdGlvbi5zdGFuZGFyZFByb3BzIHx8IHt9O1xuICAgIC8vIGlmIGhhc0VuZCBoYXMgbm90IGJlZW4gc3BlY2lmaWVkLCBndWVzcyBhIGdvb2QgdmFsdWUgYmFzZWQgb24gZGVsdGFzLlxuICAgIC8vIGlmIGR1cmF0aW9uIHdpbGwgY2hhbmdlLCB0aGVyZSdzIG5vIHdheSB0aGUgZGVmYXVsdCBkdXJhdGlvbiB3aWxsIHBlcnNpc3QsXG4gICAgLy8gYW5kIHRodXMsIHdlIG5lZWQgdG8gbWFyayB0aGUgZXZlbnQgYXMgaGF2aW5nIGEgcmVhbCBlbmRcbiAgICBpZiAoc3RhbmRhcmRQcm9wcy5oYXNFbmQgPT0gbnVsbCAmJlxuICAgICAgICBldmVudENvbmZpZy5kdXJhdGlvbkVkaXRhYmxlICYmXG4gICAgICAgIChtdXRhdGlvbi5zdGFydERlbHRhIHx8IG11dGF0aW9uLmVuZERlbHRhKSkge1xuICAgICAgICBzdGFuZGFyZFByb3BzLmhhc0VuZCA9IHRydWU7IC8vIFRPRE86IGlzIHRoaXMgbXV0YXRpb24gb2theT9cbiAgICB9XG4gICAgbGV0IGNvcHkgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXZlbnREZWYpLCBzdGFuZGFyZFByb3BzKSwgeyB1aTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBldmVudERlZi51aSksIHN0YW5kYXJkUHJvcHMudWkpIH0pO1xuICAgIGlmIChtdXRhdGlvbi5leHRlbmRlZFByb3BzKSB7XG4gICAgICAgIGNvcHkuZXh0ZW5kZWRQcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29weS5leHRlbmRlZFByb3BzKSwgbXV0YXRpb24uZXh0ZW5kZWRQcm9wcyk7XG4gICAgfVxuICAgIGZvciAobGV0IGFwcGxpZXIgb2YgY29udGV4dC5wbHVnaW5Ib29rcy5ldmVudERlZk11dGF0aW9uQXBwbGllcnMpIHtcbiAgICAgICAgYXBwbGllcihjb3B5LCBtdXRhdGlvbiwgY29udGV4dCk7XG4gICAgfVxuICAgIGlmICghY29weS5oYXNFbmQgJiYgY29udGV4dC5vcHRpb25zLmZvcmNlRXZlbnREdXJhdGlvbikge1xuICAgICAgICBjb3B5Lmhhc0VuZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBjb3B5O1xufVxuZnVuY3Rpb24gYXBwbHlNdXRhdGlvblRvRXZlbnRJbnN0YW5jZShldmVudEluc3RhbmNlLCBldmVudERlZiwgLy8gbXVzdCBmaXJzdCBiZSBtb2RpZmllZCBieSBhcHBseU11dGF0aW9uVG9FdmVudERlZlxuZXZlbnRDb25maWcsIG11dGF0aW9uLCBjb250ZXh0KSB7XG4gICAgbGV0IHsgZGF0ZUVudiB9ID0gY29udGV4dDtcbiAgICBsZXQgZm9yY2VBbGxEYXkgPSBtdXRhdGlvbi5zdGFuZGFyZFByb3BzICYmIG11dGF0aW9uLnN0YW5kYXJkUHJvcHMuYWxsRGF5ID09PSB0cnVlO1xuICAgIGxldCBjbGVhckVuZCA9IG11dGF0aW9uLnN0YW5kYXJkUHJvcHMgJiYgbXV0YXRpb24uc3RhbmRhcmRQcm9wcy5oYXNFbmQgPT09IGZhbHNlO1xuICAgIGxldCBjb3B5ID0gT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRJbnN0YW5jZSk7XG4gICAgaWYgKGZvcmNlQWxsRGF5KSB7XG4gICAgICAgIGNvcHkucmFuZ2UgPSBjb21wdXRlQWxpZ25lZERheVJhbmdlKGNvcHkucmFuZ2UpO1xuICAgIH1cbiAgICBpZiAobXV0YXRpb24uZGF0ZXNEZWx0YSAmJiBldmVudENvbmZpZy5zdGFydEVkaXRhYmxlKSB7XG4gICAgICAgIGNvcHkucmFuZ2UgPSB7XG4gICAgICAgICAgICBzdGFydDogZGF0ZUVudi5hZGQoY29weS5yYW5nZS5zdGFydCwgbXV0YXRpb24uZGF0ZXNEZWx0YSksXG4gICAgICAgICAgICBlbmQ6IGRhdGVFbnYuYWRkKGNvcHkucmFuZ2UuZW5kLCBtdXRhdGlvbi5kYXRlc0RlbHRhKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKG11dGF0aW9uLnN0YXJ0RGVsdGEgJiYgZXZlbnRDb25maWcuZHVyYXRpb25FZGl0YWJsZSkge1xuICAgICAgICBjb3B5LnJhbmdlID0ge1xuICAgICAgICAgICAgc3RhcnQ6IGRhdGVFbnYuYWRkKGNvcHkucmFuZ2Uuc3RhcnQsIG11dGF0aW9uLnN0YXJ0RGVsdGEpLFxuICAgICAgICAgICAgZW5kOiBjb3B5LnJhbmdlLmVuZCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKG11dGF0aW9uLmVuZERlbHRhICYmIGV2ZW50Q29uZmlnLmR1cmF0aW9uRWRpdGFibGUpIHtcbiAgICAgICAgY29weS5yYW5nZSA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiBjb3B5LnJhbmdlLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBkYXRlRW52LmFkZChjb3B5LnJhbmdlLmVuZCwgbXV0YXRpb24uZW5kRGVsdGEpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoY2xlYXJFbmQpIHtcbiAgICAgICAgY29weS5yYW5nZSA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiBjb3B5LnJhbmdlLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBnZXREZWZhdWx0RXZlbnRFbmQoZXZlbnREZWYuYWxsRGF5LCBjb3B5LnJhbmdlLnN0YXJ0LCBjb250ZXh0KSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gaW4gY2FzZSBldmVudCB3YXMgYWxsLWRheSBidXQgdGhlIHN1cHBsaWVkIGRlbHRhcyB3ZXJlIG5vdFxuICAgIC8vIGJldHRlciB1dGlsIGZvciB0aGlzP1xuICAgIGlmIChldmVudERlZi5hbGxEYXkpIHtcbiAgICAgICAgY29weS5yYW5nZSA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydE9mRGF5KGNvcHkucmFuZ2Uuc3RhcnQpLFxuICAgICAgICAgICAgZW5kOiBzdGFydE9mRGF5KGNvcHkucmFuZ2UuZW5kKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gaGFuZGxlIGludmFsaWQgZHVyYXRpb25zXG4gICAgaWYgKGNvcHkucmFuZ2UuZW5kIDwgY29weS5yYW5nZS5zdGFydCkge1xuICAgICAgICBjb3B5LnJhbmdlLmVuZCA9IGdldERlZmF1bHRFdmVudEVuZChldmVudERlZi5hbGxEYXksIGNvcHkucmFuZ2Uuc3RhcnQsIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gY29weTtcbn1cblxuY2xhc3MgRXZlbnRTb3VyY2VJbXBsIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBpbnRlcm5hbEV2ZW50U291cmNlKSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxFdmVudFNvdXJjZSA9IGludGVybmFsRXZlbnRTb3VyY2U7XG4gICAgfVxuICAgIHJlbW92ZSgpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdSRU1PVkVfRVZFTlRfU09VUkNFJyxcbiAgICAgICAgICAgIHNvdXJjZUlkOiB0aGlzLmludGVybmFsRXZlbnRTb3VyY2Uuc291cmNlSWQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZWZldGNoKCkge1xuICAgICAgICB0aGlzLmNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ0ZFVENIX0VWRU5UX1NPVVJDRVMnLFxuICAgICAgICAgICAgc291cmNlSWRzOiBbdGhpcy5pbnRlcm5hbEV2ZW50U291cmNlLnNvdXJjZUlkXSxcbiAgICAgICAgICAgIGlzUmVmZXRjaDogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxFdmVudFNvdXJjZS5wdWJsaWNJZDtcbiAgICB9XG4gICAgZ2V0IHVybCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxFdmVudFNvdXJjZS5tZXRhLnVybDtcbiAgICB9XG4gICAgZ2V0IGZvcm1hdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxFdmVudFNvdXJjZS5tZXRhLmZvcm1hdDsgLy8gVE9ETzogYmFkLiBub3QgZ3VhcmFudGVlZFxuICAgIH1cbn1cblxuY2xhc3MgRXZlbnRJbXBsIHtcbiAgICAvLyBpbnN0YW5jZSB3aWxsIGJlIG51bGwgaWYgZXhwcmVzc2luZyBhIHJlY3VycmluZyBldmVudCB0aGF0IGhhcyBubyBjdXJyZW50IGluc3RhbmNlcyxcbiAgICAvLyBPUiBpZiB0cnlpbmcgdG8gdmFsaWRhdGUgYW4gaW5jb21pbmcgZXh0ZXJuYWwgZXZlbnQgdGhhdCBoYXMgbm8gZGF0ZXMgYXNzaWduZWRcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBkZWYsIGluc3RhbmNlKSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLl9kZWYgPSBkZWY7XG4gICAgICAgIHRoaXMuX2luc3RhbmNlID0gaW5zdGFuY2UgfHwgbnVsbDtcbiAgICB9XG4gICAgLypcbiAgICBUT0RPOiBtYWtlIGV2ZW50IHN0cnVjdCBtb3JlIHJlc3BvbnNpYmxlIGZvciB0aGlzXG4gICAgKi9cbiAgICBzZXRQcm9wKG5hbWUsIHZhbCkge1xuICAgICAgICBpZiAobmFtZSBpbiBFVkVOVF9EQVRFX1JFRklORVJTKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0NvdWxkIG5vdCBzZXQgZGF0ZS1yZWxhdGVkIHByb3AgXFwnbmFtZVxcJy4gVXNlIG9uZSBvZiB0aGUgZGF0ZS1yZWxhdGVkIG1ldGhvZHMgaW5zdGVhZC4nKTtcbiAgICAgICAgICAgIC8vIFRPRE86IG1ha2UgcHJvcGVyIGFsaWFzaW5nIHN5c3RlbT9cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnaWQnKSB7XG4gICAgICAgICAgICB2YWwgPSBFVkVOVF9OT05fREFURV9SRUZJTkVSU1tuYW1lXSh2YWwpO1xuICAgICAgICAgICAgdGhpcy5tdXRhdGUoe1xuICAgICAgICAgICAgICAgIHN0YW5kYXJkUHJvcHM6IHsgcHVibGljSWQ6IHZhbCB9LCAvLyBoYXJkY29kZWQgaW50ZXJuYWwgbmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmFtZSBpbiBFVkVOVF9OT05fREFURV9SRUZJTkVSUykge1xuICAgICAgICAgICAgdmFsID0gRVZFTlRfTk9OX0RBVEVfUkVGSU5FUlNbbmFtZV0odmFsKTtcbiAgICAgICAgICAgIHRoaXMubXV0YXRlKHtcbiAgICAgICAgICAgICAgICBzdGFuZGFyZFByb3BzOiB7IFtuYW1lXTogdmFsIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lIGluIEVWRU5UX1VJX1JFRklORVJTKSB7XG4gICAgICAgICAgICBsZXQgdWkgPSBFVkVOVF9VSV9SRUZJTkVSU1tuYW1lXSh2YWwpO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdjb2xvcicpIHtcbiAgICAgICAgICAgICAgICB1aSA9IHsgYmFja2dyb3VuZENvbG9yOiB2YWwsIGJvcmRlckNvbG9yOiB2YWwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgPT09ICdlZGl0YWJsZScpIHtcbiAgICAgICAgICAgICAgICB1aSA9IHsgc3RhcnRFZGl0YWJsZTogdmFsLCBkdXJhdGlvbkVkaXRhYmxlOiB2YWwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHVpID0geyBbbmFtZV06IHZhbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tdXRhdGUoe1xuICAgICAgICAgICAgICAgIHN0YW5kYXJkUHJvcHM6IHsgdWkgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBDb3VsZCBub3Qgc2V0IHByb3AgJyR7bmFtZX0nLiBVc2Ugc2V0RXh0ZW5kZWRQcm9wIGluc3RlYWQuYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0RXh0ZW5kZWRQcm9wKG5hbWUsIHZhbCkge1xuICAgICAgICB0aGlzLm11dGF0ZSh7XG4gICAgICAgICAgICBleHRlbmRlZFByb3BzOiB7IFtuYW1lXTogdmFsIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZXRTdGFydChzdGFydElucHV0LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5fY29udGV4dDtcbiAgICAgICAgbGV0IHN0YXJ0ID0gZGF0ZUVudi5jcmVhdGVNYXJrZXIoc3RhcnRJbnB1dCk7XG4gICAgICAgIGlmIChzdGFydCAmJiB0aGlzLl9pbnN0YW5jZSkgeyAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcbiAgICAgICAgICAgIGxldCBpbnN0YW5jZVJhbmdlID0gdGhpcy5faW5zdGFuY2UucmFuZ2U7XG4gICAgICAgICAgICBsZXQgc3RhcnREZWx0YSA9IGRpZmZEYXRlcyhpbnN0YW5jZVJhbmdlLnN0YXJ0LCBzdGFydCwgZGF0ZUVudiwgb3B0aW9ucy5ncmFudWxhcml0eSk7IC8vIHdoYXQgaWYgcGFyc2VkIGJhZCE/XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5tYWludGFpbkR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tdXRhdGUoeyBkYXRlc0RlbHRhOiBzdGFydERlbHRhIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tdXRhdGUoeyBzdGFydERlbHRhIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNldEVuZChlbmRJbnB1dCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCB7IGRhdGVFbnYgfSA9IHRoaXMuX2NvbnRleHQ7XG4gICAgICAgIGxldCBlbmQ7XG4gICAgICAgIGlmIChlbmRJbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBlbmQgPSBkYXRlRW52LmNyZWF0ZU1hcmtlcihlbmRJbnB1dCk7XG4gICAgICAgICAgICBpZiAoIWVuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2luc3RhbmNlKSB7XG4gICAgICAgICAgICBpZiAoZW5kKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZERlbHRhID0gZGlmZkRhdGVzKHRoaXMuX2luc3RhbmNlLnJhbmdlLmVuZCwgZW5kLCBkYXRlRW52LCBvcHRpb25zLmdyYW51bGFyaXR5KTtcbiAgICAgICAgICAgICAgICB0aGlzLm11dGF0ZSh7IGVuZERlbHRhIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tdXRhdGUoeyBzdGFuZGFyZFByb3BzOiB7IGhhc0VuZDogZmFsc2UgfSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXREYXRlcyhzdGFydElucHV0LCBlbmRJbnB1dCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCB7IGRhdGVFbnYgfSA9IHRoaXMuX2NvbnRleHQ7XG4gICAgICAgIGxldCBzdGFuZGFyZFByb3BzID0geyBhbGxEYXk6IG9wdGlvbnMuYWxsRGF5IH07XG4gICAgICAgIGxldCBzdGFydCA9IGRhdGVFbnYuY3JlYXRlTWFya2VyKHN0YXJ0SW5wdXQpO1xuICAgICAgICBsZXQgZW5kO1xuICAgICAgICBpZiAoIXN0YXJ0KSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIFRPRE86IHdhcm5pbmcgaWYgcGFyc2VkIGJhZFxuICAgICAgICB9XG4gICAgICAgIGlmIChlbmRJbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBlbmQgPSBkYXRlRW52LmNyZWF0ZU1hcmtlcihlbmRJbnB1dCk7XG4gICAgICAgICAgICBpZiAoIWVuZCkgeyAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2luc3RhbmNlKSB7XG4gICAgICAgICAgICBsZXQgaW5zdGFuY2VSYW5nZSA9IHRoaXMuX2luc3RhbmNlLnJhbmdlO1xuICAgICAgICAgICAgLy8gd2hlbiBjb21wdXRpbmcgdGhlIGRpZmYgZm9yIGFuIGV2ZW50IGJlaW5nIGNvbnZlcnRlZCB0byBhbGwtZGF5LFxuICAgICAgICAgICAgLy8gY29tcHV0ZSBkaWZmIG9mZiBvZiB0aGUgYWxsLWRheSB2YWx1ZXMgdGhlIHdheSBldmVudC1tdXRhdGlvbiBkb2VzLlxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWxsRGF5ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2VSYW5nZSA9IGNvbXB1dGVBbGlnbmVkRGF5UmFuZ2UoaW5zdGFuY2VSYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc3RhcnREZWx0YSA9IGRpZmZEYXRlcyhpbnN0YW5jZVJhbmdlLnN0YXJ0LCBzdGFydCwgZGF0ZUVudiwgb3B0aW9ucy5ncmFudWxhcml0eSk7XG4gICAgICAgICAgICBpZiAoZW5kKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZERlbHRhID0gZGlmZkRhdGVzKGluc3RhbmNlUmFuZ2UuZW5kLCBlbmQsIGRhdGVFbnYsIG9wdGlvbnMuZ3JhbnVsYXJpdHkpO1xuICAgICAgICAgICAgICAgIGlmIChkdXJhdGlvbnNFcXVhbChzdGFydERlbHRhLCBlbmREZWx0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tdXRhdGUoeyBkYXRlc0RlbHRhOiBzdGFydERlbHRhLCBzdGFuZGFyZFByb3BzIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tdXRhdGUoeyBzdGFydERlbHRhLCBlbmREZWx0YSwgc3RhbmRhcmRQcm9wcyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHsgLy8gbWVhbnMgXCJjbGVhciB0aGUgZW5kXCJcbiAgICAgICAgICAgICAgICBzdGFuZGFyZFByb3BzLmhhc0VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgZGF0ZXNEZWx0YTogc3RhcnREZWx0YSwgc3RhbmRhcmRQcm9wcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBtb3ZlU3RhcnQoZGVsdGFJbnB1dCkge1xuICAgICAgICBsZXQgZGVsdGEgPSBjcmVhdGVEdXJhdGlvbihkZWx0YUlucHV0KTtcbiAgICAgICAgaWYgKGRlbHRhKSB7IC8vIFRPRE86IHdhcm5pbmcgaWYgcGFyc2VkIGJhZFxuICAgICAgICAgICAgdGhpcy5tdXRhdGUoeyBzdGFydERlbHRhOiBkZWx0YSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtb3ZlRW5kKGRlbHRhSW5wdXQpIHtcbiAgICAgICAgbGV0IGRlbHRhID0gY3JlYXRlRHVyYXRpb24oZGVsdGFJbnB1dCk7XG4gICAgICAgIGlmIChkZWx0YSkgeyAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcbiAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgZW5kRGVsdGE6IGRlbHRhIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1vdmVEYXRlcyhkZWx0YUlucHV0KSB7XG4gICAgICAgIGxldCBkZWx0YSA9IGNyZWF0ZUR1cmF0aW9uKGRlbHRhSW5wdXQpO1xuICAgICAgICBpZiAoZGVsdGEpIHsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXG4gICAgICAgICAgICB0aGlzLm11dGF0ZSh7IGRhdGVzRGVsdGE6IGRlbHRhIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldEFsbERheShhbGxEYXksIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgc3RhbmRhcmRQcm9wcyA9IHsgYWxsRGF5IH07XG4gICAgICAgIGxldCB7IG1haW50YWluRHVyYXRpb24gfSA9IG9wdGlvbnM7XG4gICAgICAgIGlmIChtYWludGFpbkR1cmF0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIG1haW50YWluRHVyYXRpb24gPSB0aGlzLl9jb250ZXh0Lm9wdGlvbnMuYWxsRGF5TWFpbnRhaW5EdXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZGVmLmFsbERheSAhPT0gYWxsRGF5KSB7XG4gICAgICAgICAgICBzdGFuZGFyZFByb3BzLmhhc0VuZCA9IG1haW50YWluRHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tdXRhdGUoeyBzdGFuZGFyZFByb3BzIH0pO1xuICAgIH1cbiAgICBmb3JtYXRSYW5nZShmb3JtYXRJbnB1dCkge1xuICAgICAgICBsZXQgeyBkYXRlRW52IH0gPSB0aGlzLl9jb250ZXh0O1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICAgICAgbGV0IGZvcm1hdHRlciA9IGNyZWF0ZUZvcm1hdHRlcihmb3JtYXRJbnB1dCk7XG4gICAgICAgIGlmICh0aGlzLl9kZWYuaGFzRW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXRSYW5nZShpbnN0YW5jZS5yYW5nZS5zdGFydCwgaW5zdGFuY2UucmFuZ2UuZW5kLCBmb3JtYXR0ZXIsIHtcbiAgICAgICAgICAgICAgICBmb3JjZWRTdGFydFR6bzogaW5zdGFuY2UuZm9yY2VkU3RhcnRUem8sXG4gICAgICAgICAgICAgICAgZm9yY2VkRW5kVHpvOiBpbnN0YW5jZS5mb3JjZWRFbmRUem8sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXQoaW5zdGFuY2UucmFuZ2Uuc3RhcnQsIGZvcm1hdHRlciwge1xuICAgICAgICAgICAgZm9yY2VkVHpvOiBpbnN0YW5jZS5mb3JjZWRTdGFydFR6byxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG11dGF0ZShtdXRhdGlvbikge1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgICAgICBsZXQgZGVmID0gdGhpcy5fZGVmO1xuICAgICAgICAgICAgbGV0IGNvbnRleHQgPSB0aGlzLl9jb250ZXh0O1xuICAgICAgICAgICAgbGV0IHsgZXZlbnRTdG9yZSB9ID0gY29udGV4dC5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICAgICAgbGV0IHJlbGV2YW50RXZlbnRzID0gZ2V0UmVsZXZhbnRFdmVudHMoZXZlbnRTdG9yZSwgaW5zdGFuY2UuaW5zdGFuY2VJZCk7XG4gICAgICAgICAgICBsZXQgZXZlbnRDb25maWdCYXNlID0ge1xuICAgICAgICAgICAgICAgICcnOiB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6ICcnLFxuICAgICAgICAgICAgICAgICAgICBzdGFydEVkaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbkVkaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50czogW10sXG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93czogW10sXG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJycsXG4gICAgICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgdGV4dENvbG9yOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lczogW10sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZWxldmFudEV2ZW50cyA9IGFwcGx5TXV0YXRpb25Ub0V2ZW50U3RvcmUocmVsZXZhbnRFdmVudHMsIGV2ZW50Q29uZmlnQmFzZSwgbXV0YXRpb24sIGNvbnRleHQpO1xuICAgICAgICAgICAgbGV0IG9sZEV2ZW50ID0gbmV3IEV2ZW50SW1wbChjb250ZXh0LCBkZWYsIGluc3RhbmNlKTsgLy8gc25hcHNob3RcbiAgICAgICAgICAgIHRoaXMuX2RlZiA9IHJlbGV2YW50RXZlbnRzLmRlZnNbZGVmLmRlZklkXTtcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlID0gcmVsZXZhbnRFdmVudHMuaW5zdGFuY2VzW2luc3RhbmNlLmluc3RhbmNlSWRdO1xuICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ01FUkdFX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogcmVsZXZhbnRFdmVudHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudENoYW5nZScsIHtcbiAgICAgICAgICAgICAgICBvbGRFdmVudCxcbiAgICAgICAgICAgICAgICBldmVudDogdGhpcyxcbiAgICAgICAgICAgICAgICByZWxhdGVkRXZlbnRzOiBidWlsZEV2ZW50QXBpcyhyZWxldmFudEV2ZW50cywgY29udGV4dCwgaW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgIHJldmVydCgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnUkVTRVRfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmUsIC8vIHRoZSBPUklHSU5BTCBzdG9yZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlKCkge1xuICAgICAgICBsZXQgY29udGV4dCA9IHRoaXMuX2NvbnRleHQ7XG4gICAgICAgIGxldCBhc1N0b3JlID0gZXZlbnRBcGlUb1N0b3JlKHRoaXMpO1xuICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdSRU1PVkVfRVZFTlRTJyxcbiAgICAgICAgICAgIGV2ZW50U3RvcmU6IGFzU3RvcmUsXG4gICAgICAgIH0pO1xuICAgICAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRSZW1vdmUnLCB7XG4gICAgICAgICAgICBldmVudDogdGhpcyxcbiAgICAgICAgICAgIHJlbGF0ZWRFdmVudHM6IFtdLFxuICAgICAgICAgICAgcmV2ZXJ0KCkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTUVSR0VfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogYXNTdG9yZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgc291cmNlKCkge1xuICAgICAgICBsZXQgeyBzb3VyY2VJZCB9ID0gdGhpcy5fZGVmO1xuICAgICAgICBpZiAoc291cmNlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRTb3VyY2VJbXBsKHRoaXMuX2NvbnRleHQsIHRoaXMuX2NvbnRleHQuZ2V0Q3VycmVudERhdGEoKS5ldmVudFNvdXJjZXNbc291cmNlSWRdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZ2V0IHN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zdGFuY2UgP1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5kYXRlRW52LnRvRGF0ZSh0aGlzLl9pbnN0YW5jZS5yYW5nZS5zdGFydCkgOlxuICAgICAgICAgICAgbnVsbDtcbiAgICB9XG4gICAgZ2V0IGVuZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9pbnN0YW5jZSAmJiB0aGlzLl9kZWYuaGFzRW5kKSA/XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmRhdGVFbnYudG9EYXRlKHRoaXMuX2luc3RhbmNlLnJhbmdlLmVuZCkgOlxuICAgICAgICAgICAgbnVsbDtcbiAgICB9XG4gICAgZ2V0IHN0YXJ0U3RyKCkge1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5kYXRlRW52LmZvcm1hdElzbyhpbnN0YW5jZS5yYW5nZS5zdGFydCwge1xuICAgICAgICAgICAgICAgIG9taXRUaW1lOiB0aGlzLl9kZWYuYWxsRGF5LFxuICAgICAgICAgICAgICAgIGZvcmNlZFR6bzogaW5zdGFuY2UuZm9yY2VkU3RhcnRUem8sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGdldCBlbmRTdHIoKSB7XG4gICAgICAgIGxldCBpbnN0YW5jZSA9IHRoaXMuX2luc3RhbmNlO1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgdGhpcy5fZGVmLmhhc0VuZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuZGF0ZUVudi5mb3JtYXRJc28oaW5zdGFuY2UucmFuZ2UuZW5kLCB7XG4gICAgICAgICAgICAgICAgb21pdFRpbWU6IHRoaXMuX2RlZi5hbGxEYXksXG4gICAgICAgICAgICAgICAgZm9yY2VkVHpvOiBpbnN0YW5jZS5mb3JjZWRFbmRUem8sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIC8vIGNvbXB1dGFibGUgcHJvcHMgdGhhdCBhbGwgYWNjZXNzIHRoZSBkZWZcbiAgICAvLyBUT0RPOiBmaW5kIGEgVHlwZVNjcmlwdC1jb21wYXRpYmxlIHdheSB0byBkbyB0aGlzIGF0IHNjYWxlXG4gICAgZ2V0IGlkKCkgeyByZXR1cm4gdGhpcy5fZGVmLnB1YmxpY0lkOyB9XG4gICAgZ2V0IGdyb3VwSWQoKSB7IHJldHVybiB0aGlzLl9kZWYuZ3JvdXBJZDsgfVxuICAgIGdldCBhbGxEYXkoKSB7IHJldHVybiB0aGlzLl9kZWYuYWxsRGF5OyB9XG4gICAgZ2V0IHRpdGxlKCkgeyByZXR1cm4gdGhpcy5fZGVmLnRpdGxlOyB9XG4gICAgZ2V0IHVybCgpIHsgcmV0dXJuIHRoaXMuX2RlZi51cmw7IH1cbiAgICBnZXQgZGlzcGxheSgpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5kaXNwbGF5IHx8ICdhdXRvJzsgfSAvLyBiYWQuIGp1c3Qgbm9ybWFsaXplIHRoZSB0eXBlIGVhcmxpZXJcbiAgICBnZXQgc3RhcnRFZGl0YWJsZSgpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5zdGFydEVkaXRhYmxlOyB9XG4gICAgZ2V0IGR1cmF0aW9uRWRpdGFibGUoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuZHVyYXRpb25FZGl0YWJsZTsgfVxuICAgIGdldCBjb25zdHJhaW50KCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmNvbnN0cmFpbnRzWzBdIHx8IG51bGw7IH1cbiAgICBnZXQgb3ZlcmxhcCgpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5vdmVybGFwOyB9XG4gICAgZ2V0IGFsbG93KCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmFsbG93c1swXSB8fCBudWxsOyB9XG4gICAgZ2V0IGJhY2tncm91bmRDb2xvcigpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5iYWNrZ3JvdW5kQ29sb3I7IH1cbiAgICBnZXQgYm9yZGVyQ29sb3IoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuYm9yZGVyQ29sb3I7IH1cbiAgICBnZXQgdGV4dENvbG9yKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLnRleHRDb2xvcjsgfVxuICAgIC8vIE5PVEU6IHVzZXIgY2FuJ3QgbW9kaWZ5IHRoZXNlIGJlY2F1c2UgT2JqZWN0LmZyZWV6ZSB3YXMgY2FsbGVkIGluIGV2ZW50LWRlZiBwYXJzaW5nXG4gICAgZ2V0IGNsYXNzTmFtZXMoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuY2xhc3NOYW1lczsgfVxuICAgIGdldCBleHRlbmRlZFByb3BzKCkgeyByZXR1cm4gdGhpcy5fZGVmLmV4dGVuZGVkUHJvcHM7IH1cbiAgICB0b1BsYWluT2JqZWN0KHNldHRpbmdzID0ge30pIHtcbiAgICAgICAgbGV0IGRlZiA9IHRoaXMuX2RlZjtcbiAgICAgICAgbGV0IHsgdWkgfSA9IGRlZjtcbiAgICAgICAgbGV0IHsgc3RhcnRTdHIsIGVuZFN0ciB9ID0gdGhpcztcbiAgICAgICAgbGV0IHJlcyA9IHtcbiAgICAgICAgICAgIGFsbERheTogZGVmLmFsbERheSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGRlZi50aXRsZSkge1xuICAgICAgICAgICAgcmVzLnRpdGxlID0gZGVmLnRpdGxlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydFN0cikge1xuICAgICAgICAgICAgcmVzLnN0YXJ0ID0gc3RhcnRTdHI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZFN0cikge1xuICAgICAgICAgICAgcmVzLmVuZCA9IGVuZFN0cjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmLnB1YmxpY0lkKSB7XG4gICAgICAgICAgICByZXMuaWQgPSBkZWYucHVibGljSWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi5ncm91cElkKSB7XG4gICAgICAgICAgICByZXMuZ3JvdXBJZCA9IGRlZi5ncm91cElkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYudXJsKSB7XG4gICAgICAgICAgICByZXMudXJsID0gZGVmLnVybDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodWkuZGlzcGxheSAmJiB1aS5kaXNwbGF5ICE9PSAnYXV0bycpIHtcbiAgICAgICAgICAgIHJlcy5kaXNwbGF5ID0gdWkuZGlzcGxheTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiB3aGF0IGFib3V0IHJlY3VycmluZy1ldmVudCBwcm9wZXJ0aWVzPz8/XG4gICAgICAgIC8vIFRPRE86IGluY2x1ZGUgc3RhcnRFZGl0YWJsZS9kdXJhdGlvbkVkaXRhYmxlL2NvbnN0cmFpbnQvb3ZlcmxhcC9hbGxvd1xuICAgICAgICBpZiAoc2V0dGluZ3MuY29sbGFwc2VDb2xvciAmJiB1aS5iYWNrZ3JvdW5kQ29sb3IgJiYgdWkuYmFja2dyb3VuZENvbG9yID09PSB1aS5ib3JkZXJDb2xvcikge1xuICAgICAgICAgICAgcmVzLmNvbG9yID0gdWkuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHVpLmJhY2tncm91bmRDb2xvcikge1xuICAgICAgICAgICAgICAgIHJlcy5iYWNrZ3JvdW5kQ29sb3IgPSB1aS5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodWkuYm9yZGVyQ29sb3IpIHtcbiAgICAgICAgICAgICAgICByZXMuYm9yZGVyQ29sb3IgPSB1aS5ib3JkZXJDb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodWkudGV4dENvbG9yKSB7XG4gICAgICAgICAgICByZXMudGV4dENvbG9yID0gdWkudGV4dENvbG9yO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1aS5jbGFzc05hbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVzLmNsYXNzTmFtZXMgPSB1aS5jbGFzc05hbWVzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhkZWYuZXh0ZW5kZWRQcm9wcykubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuY29sbGFwc2VFeHRlbmRlZFByb3BzKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihyZXMsIGRlZi5leHRlbmRlZFByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcy5leHRlbmRlZFByb3BzID0gZGVmLmV4dGVuZGVkUHJvcHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b1BsYWluT2JqZWN0KCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZXZlbnRBcGlUb1N0b3JlKGV2ZW50QXBpKSB7XG4gICAgbGV0IGRlZiA9IGV2ZW50QXBpLl9kZWY7XG4gICAgbGV0IGluc3RhbmNlID0gZXZlbnRBcGkuX2luc3RhbmNlO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlZnM6IHsgW2RlZi5kZWZJZF06IGRlZiB9LFxuICAgICAgICBpbnN0YW5jZXM6IGluc3RhbmNlXG4gICAgICAgICAgICA/IHsgW2luc3RhbmNlLmluc3RhbmNlSWRdOiBpbnN0YW5jZSB9XG4gICAgICAgICAgICA6IHt9LFxuICAgIH07XG59XG5mdW5jdGlvbiBidWlsZEV2ZW50QXBpcyhldmVudFN0b3JlLCBjb250ZXh0LCBleGNsdWRlSW5zdGFuY2UpIHtcbiAgICBsZXQgeyBkZWZzLCBpbnN0YW5jZXMgfSA9IGV2ZW50U3RvcmU7XG4gICAgbGV0IGV2ZW50QXBpcyA9IFtdO1xuICAgIGxldCBleGNsdWRlSW5zdGFuY2VJZCA9IGV4Y2x1ZGVJbnN0YW5jZSA/IGV4Y2x1ZGVJbnN0YW5jZS5pbnN0YW5jZUlkIDogJyc7XG4gICAgZm9yIChsZXQgaWQgaW4gaW5zdGFuY2VzKSB7XG4gICAgICAgIGxldCBpbnN0YW5jZSA9IGluc3RhbmNlc1tpZF07XG4gICAgICAgIGxldCBkZWYgPSBkZWZzW2luc3RhbmNlLmRlZklkXTtcbiAgICAgICAgaWYgKGluc3RhbmNlLmluc3RhbmNlSWQgIT09IGV4Y2x1ZGVJbnN0YW5jZUlkKSB7XG4gICAgICAgICAgICBldmVudEFwaXMucHVzaChuZXcgRXZlbnRJbXBsKGNvbnRleHQsIGRlZiwgaW5zdGFuY2UpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXZlbnRBcGlzO1xufVxuXG4vKlxuU3BlY2lmeWluZyBuZXh0RGF5VGhyZXNob2xkIHNpZ25hbHMgdGhhdCBhbGwtZGF5IHJhbmdlcyBzaG91bGQgYmUgc2xpY2VkLlxuKi9cbmZ1bmN0aW9uIHNsaWNlRXZlbnRTdG9yZShldmVudFN0b3JlLCBldmVudFVpQmFzZXMsIGZyYW1pbmdSYW5nZSwgbmV4dERheVRocmVzaG9sZCkge1xuICAgIGxldCBpbnZlcnNlQmdCeUdyb3VwSWQgPSB7fTtcbiAgICBsZXQgaW52ZXJzZUJnQnlEZWZJZCA9IHt9O1xuICAgIGxldCBkZWZCeUdyb3VwSWQgPSB7fTtcbiAgICBsZXQgYmdSYW5nZXMgPSBbXTtcbiAgICBsZXQgZmdSYW5nZXMgPSBbXTtcbiAgICBsZXQgZXZlbnRVaXMgPSBjb21waWxlRXZlbnRVaXMoZXZlbnRTdG9yZS5kZWZzLCBldmVudFVpQmFzZXMpO1xuICAgIGZvciAobGV0IGRlZklkIGluIGV2ZW50U3RvcmUuZGVmcykge1xuICAgICAgICBsZXQgZGVmID0gZXZlbnRTdG9yZS5kZWZzW2RlZklkXTtcbiAgICAgICAgbGV0IHVpID0gZXZlbnRVaXNbZGVmLmRlZklkXTtcbiAgICAgICAgaWYgKHVpLmRpc3BsYXkgPT09ICdpbnZlcnNlLWJhY2tncm91bmQnKSB7XG4gICAgICAgICAgICBpZiAoZGVmLmdyb3VwSWQpIHtcbiAgICAgICAgICAgICAgICBpbnZlcnNlQmdCeUdyb3VwSWRbZGVmLmdyb3VwSWRdID0gW107XG4gICAgICAgICAgICAgICAgaWYgKCFkZWZCeUdyb3VwSWRbZGVmLmdyb3VwSWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZkJ5R3JvdXBJZFtkZWYuZ3JvdXBJZF0gPSBkZWY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW52ZXJzZUJnQnlEZWZJZFtkZWZJZF0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpbnN0YW5jZUlkIGluIGV2ZW50U3RvcmUuaW5zdGFuY2VzKSB7XG4gICAgICAgIGxldCBpbnN0YW5jZSA9IGV2ZW50U3RvcmUuaW5zdGFuY2VzW2luc3RhbmNlSWRdO1xuICAgICAgICBsZXQgZGVmID0gZXZlbnRTdG9yZS5kZWZzW2luc3RhbmNlLmRlZklkXTtcbiAgICAgICAgbGV0IHVpID0gZXZlbnRVaXNbZGVmLmRlZklkXTtcbiAgICAgICAgbGV0IG9yaWdSYW5nZSA9IGluc3RhbmNlLnJhbmdlO1xuICAgICAgICBsZXQgbm9ybWFsUmFuZ2UgPSAoIWRlZi5hbGxEYXkgJiYgbmV4dERheVRocmVzaG9sZCkgP1xuICAgICAgICAgICAgY29tcHV0ZVZpc2libGVEYXlSYW5nZShvcmlnUmFuZ2UsIG5leHREYXlUaHJlc2hvbGQpIDpcbiAgICAgICAgICAgIG9yaWdSYW5nZTtcbiAgICAgICAgbGV0IHNsaWNlZFJhbmdlID0gaW50ZXJzZWN0UmFuZ2VzKG5vcm1hbFJhbmdlLCBmcmFtaW5nUmFuZ2UpO1xuICAgICAgICBpZiAoc2xpY2VkUmFuZ2UpIHtcbiAgICAgICAgICAgIGlmICh1aS5kaXNwbGF5ID09PSAnaW52ZXJzZS1iYWNrZ3JvdW5kJykge1xuICAgICAgICAgICAgICAgIGlmIChkZWYuZ3JvdXBJZCkge1xuICAgICAgICAgICAgICAgICAgICBpbnZlcnNlQmdCeUdyb3VwSWRbZGVmLmdyb3VwSWRdLnB1c2goc2xpY2VkUmFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW52ZXJzZUJnQnlEZWZJZFtpbnN0YW5jZS5kZWZJZF0ucHVzaChzbGljZWRSYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodWkuZGlzcGxheSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgKHVpLmRpc3BsYXkgPT09ICdiYWNrZ3JvdW5kJyA/IGJnUmFuZ2VzIDogZmdSYW5nZXMpLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBkZWYsXG4gICAgICAgICAgICAgICAgICAgIHVpLFxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHNsaWNlZFJhbmdlLFxuICAgICAgICAgICAgICAgICAgICBpc1N0YXJ0OiBub3JtYWxSYW5nZS5zdGFydCAmJiBub3JtYWxSYW5nZS5zdGFydC52YWx1ZU9mKCkgPT09IHNsaWNlZFJhbmdlLnN0YXJ0LnZhbHVlT2YoKSxcbiAgICAgICAgICAgICAgICAgICAgaXNFbmQ6IG5vcm1hbFJhbmdlLmVuZCAmJiBub3JtYWxSYW5nZS5lbmQudmFsdWVPZigpID09PSBzbGljZWRSYW5nZS5lbmQudmFsdWVPZigpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGdyb3VwSWQgaW4gaW52ZXJzZUJnQnlHcm91cElkKSB7IC8vIEJZIEdST1VQXG4gICAgICAgIGxldCByYW5nZXMgPSBpbnZlcnNlQmdCeUdyb3VwSWRbZ3JvdXBJZF07XG4gICAgICAgIGxldCBpbnZlcnRlZFJhbmdlcyA9IGludmVydFJhbmdlcyhyYW5nZXMsIGZyYW1pbmdSYW5nZSk7XG4gICAgICAgIGZvciAobGV0IGludmVydGVkUmFuZ2Ugb2YgaW52ZXJ0ZWRSYW5nZXMpIHtcbiAgICAgICAgICAgIGxldCBkZWYgPSBkZWZCeUdyb3VwSWRbZ3JvdXBJZF07XG4gICAgICAgICAgICBsZXQgdWkgPSBldmVudFVpc1tkZWYuZGVmSWRdO1xuICAgICAgICAgICAgYmdSYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgZGVmLFxuICAgICAgICAgICAgICAgIHVpLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlOiBudWxsLFxuICAgICAgICAgICAgICAgIHJhbmdlOiBpbnZlcnRlZFJhbmdlLFxuICAgICAgICAgICAgICAgIGlzU3RhcnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzRW5kOiBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGRlZklkIGluIGludmVyc2VCZ0J5RGVmSWQpIHtcbiAgICAgICAgbGV0IHJhbmdlcyA9IGludmVyc2VCZ0J5RGVmSWRbZGVmSWRdO1xuICAgICAgICBsZXQgaW52ZXJ0ZWRSYW5nZXMgPSBpbnZlcnRSYW5nZXMocmFuZ2VzLCBmcmFtaW5nUmFuZ2UpO1xuICAgICAgICBmb3IgKGxldCBpbnZlcnRlZFJhbmdlIG9mIGludmVydGVkUmFuZ2VzKSB7XG4gICAgICAgICAgICBiZ1Jhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBkZWY6IGV2ZW50U3RvcmUuZGVmc1tkZWZJZF0sXG4gICAgICAgICAgICAgICAgdWk6IGV2ZW50VWlzW2RlZklkXSxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTogbnVsbCxcbiAgICAgICAgICAgICAgICByYW5nZTogaW52ZXJ0ZWRSYW5nZSxcbiAgICAgICAgICAgICAgICBpc1N0YXJ0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc0VuZDogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBiZzogYmdSYW5nZXMsIGZnOiBmZ1JhbmdlcyB9O1xufVxuZnVuY3Rpb24gaGFzQmdSZW5kZXJpbmcoZGVmKSB7XG4gICAgcmV0dXJuIGRlZi51aS5kaXNwbGF5ID09PSAnYmFja2dyb3VuZCcgfHwgZGVmLnVpLmRpc3BsYXkgPT09ICdpbnZlcnNlLWJhY2tncm91bmQnO1xufVxuZnVuY3Rpb24gc2V0RWxTZWcoZWwsIHNlZykge1xuICAgIGVsLmZjU2VnID0gc2VnO1xufVxuZnVuY3Rpb24gZ2V0RWxTZWcoZWwpIHtcbiAgICByZXR1cm4gZWwuZmNTZWcgfHxcbiAgICAgICAgZWwucGFyZW50Tm9kZS5mY1NlZyB8fCAvLyBmb3IgdGhlIGhhcm5lc3NcbiAgICAgICAgbnVsbDtcbn1cbi8vIGV2ZW50IHVpIGNvbXB1dGF0aW9uXG5mdW5jdGlvbiBjb21waWxlRXZlbnRVaXMoZXZlbnREZWZzLCBldmVudFVpQmFzZXMpIHtcbiAgICByZXR1cm4gbWFwSGFzaChldmVudERlZnMsIChldmVudERlZikgPT4gY29tcGlsZUV2ZW50VWkoZXZlbnREZWYsIGV2ZW50VWlCYXNlcykpO1xufVxuZnVuY3Rpb24gY29tcGlsZUV2ZW50VWkoZXZlbnREZWYsIGV2ZW50VWlCYXNlcykge1xuICAgIGxldCB1aXMgPSBbXTtcbiAgICBpZiAoZXZlbnRVaUJhc2VzWycnXSkge1xuICAgICAgICB1aXMucHVzaChldmVudFVpQmFzZXNbJyddKTtcbiAgICB9XG4gICAgaWYgKGV2ZW50VWlCYXNlc1tldmVudERlZi5kZWZJZF0pIHtcbiAgICAgICAgdWlzLnB1c2goZXZlbnRVaUJhc2VzW2V2ZW50RGVmLmRlZklkXSk7XG4gICAgfVxuICAgIHVpcy5wdXNoKGV2ZW50RGVmLnVpKTtcbiAgICByZXR1cm4gY29tYmluZUV2ZW50VWlzKHVpcyk7XG59XG5mdW5jdGlvbiBzb3J0RXZlbnRTZWdzKHNlZ3MsIGV2ZW50T3JkZXJTcGVjcykge1xuICAgIGxldCBvYmpzID0gc2Vncy5tYXAoYnVpbGRTZWdDb21wYXJlT2JqKTtcbiAgICBvYmpzLnNvcnQoKG9iajAsIG9iajEpID0+IGNvbXBhcmVCeUZpZWxkU3BlY3Mob2JqMCwgb2JqMSwgZXZlbnRPcmRlclNwZWNzKSk7XG4gICAgcmV0dXJuIG9ianMubWFwKChjKSA9PiBjLl9zZWcpO1xufVxuLy8gcmV0dXJucyBhIG9iamVjdCB3aXRoIGFsbCBwcmltaXRpdmUgcHJvcHMgdGhhdCBjYW4gYmUgY29tcGFyZWRcbmZ1bmN0aW9uIGJ1aWxkU2VnQ29tcGFyZU9iaihzZWcpIHtcbiAgICBsZXQgeyBldmVudFJhbmdlIH0gPSBzZWc7XG4gICAgbGV0IGV2ZW50RGVmID0gZXZlbnRSYW5nZS5kZWY7XG4gICAgbGV0IHJhbmdlID0gZXZlbnRSYW5nZS5pbnN0YW5jZSA/IGV2ZW50UmFuZ2UuaW5zdGFuY2UucmFuZ2UgOiBldmVudFJhbmdlLnJhbmdlO1xuICAgIGxldCBzdGFydCA9IHJhbmdlLnN0YXJ0ID8gcmFuZ2Uuc3RhcnQudmFsdWVPZigpIDogMDsgLy8gVE9ETzogYmV0dGVyIHN1cHBvcnQgZm9yIG9wZW4tcmFuZ2UgZXZlbnRzXG4gICAgbGV0IGVuZCA9IHJhbmdlLmVuZCA/IHJhbmdlLmVuZC52YWx1ZU9mKCkgOiAwOyAvLyBcIlxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXZlbnREZWYuZXh0ZW5kZWRQcm9wcyksIGV2ZW50RGVmKSwgeyBpZDogZXZlbnREZWYucHVibGljSWQsIHN0YXJ0LFxuICAgICAgICBlbmQsIGR1cmF0aW9uOiBlbmQgLSBzdGFydCwgYWxsRGF5OiBOdW1iZXIoZXZlbnREZWYuYWxsRGF5KSwgX3NlZzogc2VnIH0pO1xufVxuZnVuY3Rpb24gY29tcHV0ZVNlZ0RyYWdnYWJsZShzZWcsIGNvbnRleHQpIHtcbiAgICBsZXQgeyBwbHVnaW5Ib29rcyB9ID0gY29udGV4dDtcbiAgICBsZXQgdHJhbnNmb3JtZXJzID0gcGx1Z2luSG9va3MuaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnM7XG4gICAgbGV0IHsgZGVmLCB1aSB9ID0gc2VnLmV2ZW50UmFuZ2U7XG4gICAgbGV0IHZhbCA9IHVpLnN0YXJ0RWRpdGFibGU7XG4gICAgZm9yIChsZXQgdHJhbnNmb3JtZXIgb2YgdHJhbnNmb3JtZXJzKSB7XG4gICAgICAgIHZhbCA9IHRyYW5zZm9ybWVyKHZhbCwgZGVmLCB1aSwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59XG5mdW5jdGlvbiBjb21wdXRlU2VnU3RhcnRSZXNpemFibGUoc2VnLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHNlZy5pc1N0YXJ0ICYmIHNlZy5ldmVudFJhbmdlLnVpLmR1cmF0aW9uRWRpdGFibGUgJiYgY29udGV4dC5vcHRpb25zLmV2ZW50UmVzaXphYmxlRnJvbVN0YXJ0O1xufVxuZnVuY3Rpb24gY29tcHV0ZVNlZ0VuZFJlc2l6YWJsZShzZWcsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gc2VnLmlzRW5kICYmIHNlZy5ldmVudFJhbmdlLnVpLmR1cmF0aW9uRWRpdGFibGU7XG59XG5mdW5jdGlvbiBidWlsZFNlZ1RpbWVUZXh0KHNlZywgdGltZUZvcm1hdCwgY29udGV4dCwgZGVmYXVsdERpc3BsYXlFdmVudFRpbWUsIC8vIGRlZmF1bHRzIHRvIHRydWVcbmRlZmF1bHREaXNwbGF5RXZlbnRFbmQsIC8vIGRlZmF1bHRzIHRvIHRydWVcbnN0YXJ0T3ZlcnJpZGUsIGVuZE92ZXJyaWRlKSB7XG4gICAgbGV0IHsgZGF0ZUVudiwgb3B0aW9ucyB9ID0gY29udGV4dDtcbiAgICBsZXQgeyBkaXNwbGF5RXZlbnRUaW1lLCBkaXNwbGF5RXZlbnRFbmQgfSA9IG9wdGlvbnM7XG4gICAgbGV0IGV2ZW50RGVmID0gc2VnLmV2ZW50UmFuZ2UuZGVmO1xuICAgIGxldCBldmVudEluc3RhbmNlID0gc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2U7XG4gICAgaWYgKGRpc3BsYXlFdmVudFRpbWUgPT0gbnVsbCkge1xuICAgICAgICBkaXNwbGF5RXZlbnRUaW1lID0gZGVmYXVsdERpc3BsYXlFdmVudFRpbWUgIT09IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZGlzcGxheUV2ZW50RW5kID09IG51bGwpIHtcbiAgICAgICAgZGlzcGxheUV2ZW50RW5kID0gZGVmYXVsdERpc3BsYXlFdmVudEVuZCAhPT0gZmFsc2U7XG4gICAgfVxuICAgIGxldCB3aG9sZUV2ZW50U3RhcnQgPSBldmVudEluc3RhbmNlLnJhbmdlLnN0YXJ0O1xuICAgIGxldCB3aG9sZUV2ZW50RW5kID0gZXZlbnRJbnN0YW5jZS5yYW5nZS5lbmQ7XG4gICAgbGV0IHNlZ1N0YXJ0ID0gc3RhcnRPdmVycmlkZSB8fCBzZWcuc3RhcnQgfHwgc2VnLmV2ZW50UmFuZ2UucmFuZ2Uuc3RhcnQ7XG4gICAgbGV0IHNlZ0VuZCA9IGVuZE92ZXJyaWRlIHx8IHNlZy5lbmQgfHwgc2VnLmV2ZW50UmFuZ2UucmFuZ2UuZW5kO1xuICAgIGxldCBpc1N0YXJ0RGF5ID0gc3RhcnRPZkRheSh3aG9sZUV2ZW50U3RhcnQpLnZhbHVlT2YoKSA9PT0gc3RhcnRPZkRheShzZWdTdGFydCkudmFsdWVPZigpO1xuICAgIGxldCBpc0VuZERheSA9IHN0YXJ0T2ZEYXkoYWRkTXMod2hvbGVFdmVudEVuZCwgLTEpKS52YWx1ZU9mKCkgPT09IHN0YXJ0T2ZEYXkoYWRkTXMoc2VnRW5kLCAtMSkpLnZhbHVlT2YoKTtcbiAgICBpZiAoZGlzcGxheUV2ZW50VGltZSAmJiAhZXZlbnREZWYuYWxsRGF5ICYmIChpc1N0YXJ0RGF5IHx8IGlzRW5kRGF5KSkge1xuICAgICAgICBzZWdTdGFydCA9IGlzU3RhcnREYXkgPyB3aG9sZUV2ZW50U3RhcnQgOiBzZWdTdGFydDtcbiAgICAgICAgc2VnRW5kID0gaXNFbmREYXkgPyB3aG9sZUV2ZW50RW5kIDogc2VnRW5kO1xuICAgICAgICBpZiAoZGlzcGxheUV2ZW50RW5kICYmIGV2ZW50RGVmLmhhc0VuZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0UmFuZ2Uoc2VnU3RhcnQsIHNlZ0VuZCwgdGltZUZvcm1hdCwge1xuICAgICAgICAgICAgICAgIGZvcmNlZFN0YXJ0VHpvOiBzdGFydE92ZXJyaWRlID8gbnVsbCA6IGV2ZW50SW5zdGFuY2UuZm9yY2VkU3RhcnRUem8sXG4gICAgICAgICAgICAgICAgZm9yY2VkRW5kVHpvOiBlbmRPdmVycmlkZSA/IG51bGwgOiBldmVudEluc3RhbmNlLmZvcmNlZEVuZFR6byxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdChzZWdTdGFydCwgdGltZUZvcm1hdCwge1xuICAgICAgICAgICAgZm9yY2VkVHpvOiBzdGFydE92ZXJyaWRlID8gbnVsbCA6IGV2ZW50SW5zdGFuY2UuZm9yY2VkU3RhcnRUem8sIC8vIG5vb29vbywgc2FtZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xufVxuZnVuY3Rpb24gZ2V0U2VnTWV0YShzZWcsIHRvZGF5UmFuZ2UsIG5vd0RhdGUpIHtcbiAgICBsZXQgc2VnUmFuZ2UgPSBzZWcuZXZlbnRSYW5nZS5yYW5nZTtcbiAgICByZXR1cm4ge1xuICAgICAgICBpc1Bhc3Q6IHNlZ1JhbmdlLmVuZCA8PSAobm93RGF0ZSB8fCB0b2RheVJhbmdlLnN0YXJ0KSxcbiAgICAgICAgaXNGdXR1cmU6IHNlZ1JhbmdlLnN0YXJ0ID49IChub3dEYXRlIHx8IHRvZGF5UmFuZ2UuZW5kKSxcbiAgICAgICAgaXNUb2RheTogdG9kYXlSYW5nZSAmJiByYW5nZUNvbnRhaW5zTWFya2VyKHRvZGF5UmFuZ2UsIHNlZ1JhbmdlLnN0YXJ0KSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0RXZlbnRDbGFzc05hbWVzKHByb3BzKSB7XG4gICAgbGV0IGNsYXNzTmFtZXMgPSBbJ2ZjLWV2ZW50J107XG4gICAgaWYgKHByb3BzLmlzTWlycm9yKSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtbWlycm9yJyk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pc0RyYWdnYWJsZSkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LWRyYWdnYWJsZScpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNTdGFydFJlc2l6YWJsZSB8fCBwcm9wcy5pc0VuZFJlc2l6YWJsZSkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LXJlc2l6YWJsZScpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNEcmFnZ2luZykge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LWRyYWdnaW5nJyk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pc1Jlc2l6aW5nKSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtcmVzaXppbmcnKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmlzU2VsZWN0ZWQpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1zZWxlY3RlZCcpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNTdGFydCkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LXN0YXJ0Jyk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pc0VuZCkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LWVuZCcpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNQYXN0KSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtcGFzdCcpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNUb2RheSkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LXRvZGF5Jyk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pc0Z1dHVyZSkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LWZ1dHVyZScpO1xuICAgIH1cbiAgICByZXR1cm4gY2xhc3NOYW1lcztcbn1cbmZ1bmN0aW9uIGJ1aWxkRXZlbnRSYW5nZUtleShldmVudFJhbmdlKSB7XG4gICAgcmV0dXJuIGV2ZW50UmFuZ2UuaW5zdGFuY2VcbiAgICAgICAgPyBldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWRcbiAgICAgICAgOiBgJHtldmVudFJhbmdlLmRlZi5kZWZJZH06JHtldmVudFJhbmdlLnJhbmdlLnN0YXJ0LnRvSVNPU3RyaW5nKCl9YDtcbiAgICAvLyBpbnZlcnNlLWJhY2tncm91bmQgZXZlbnRzIGRvbid0IGhhdmUgc3BlY2lmaWMgaW5zdGFuY2VzLiBUT0RPOiBiZXR0ZXIgc29sdXRpb25cbn1cbmZ1bmN0aW9uIGdldFNlZ0FuY2hvckF0dHJzKHNlZywgY29udGV4dCkge1xuICAgIGxldCB7IGRlZiwgaW5zdGFuY2UgfSA9IHNlZy5ldmVudFJhbmdlO1xuICAgIGxldCB7IHVybCB9ID0gZGVmO1xuICAgIGlmICh1cmwpIHtcbiAgICAgICAgcmV0dXJuIHsgaHJlZjogdXJsIH07XG4gICAgfVxuICAgIGxldCB7IGVtaXR0ZXIsIG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgbGV0IHsgZXZlbnRJbnRlcmFjdGl2ZSB9ID0gb3B0aW9ucztcbiAgICBpZiAoZXZlbnRJbnRlcmFjdGl2ZSA9PSBudWxsKSB7XG4gICAgICAgIGV2ZW50SW50ZXJhY3RpdmUgPSBkZWYuaW50ZXJhY3RpdmU7XG4gICAgICAgIGlmIChldmVudEludGVyYWN0aXZlID09IG51bGwpIHtcbiAgICAgICAgICAgIGV2ZW50SW50ZXJhY3RpdmUgPSBCb29sZWFuKGVtaXR0ZXIuaGFzSGFuZGxlcnMoJ2V2ZW50Q2xpY2snKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gbW9jayB3aGF0IGhhcHBlbnMgaW4gRXZlbnRDbGlja2luZ1xuICAgIGlmIChldmVudEludGVyYWN0aXZlKSB7XG4gICAgICAgIC8vIG9ubHkgYXR0YWNoIGtleWJvYXJkLXJlbGF0ZWQgaGFuZGxlcnMgYmVjYXVzZSBjbGljayBoYW5kbGVyIGlzIGFscmVhZHkgZG9uZSBpbiBFdmVudENsaWNraW5nXG4gICAgICAgIHJldHVybiBjcmVhdGVBcmlhS2V5Ym9hcmRBdHRycygoZXYpID0+IHtcbiAgICAgICAgICAgIGVtaXR0ZXIudHJpZ2dlcignZXZlbnRDbGljaycsIHtcbiAgICAgICAgICAgICAgICBlbDogZXYudGFyZ2V0LFxuICAgICAgICAgICAgICAgIGV2ZW50OiBuZXcgRXZlbnRJbXBsKGNvbnRleHQsIGRlZiwgaW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgIGpzRXZlbnQ6IGV2LFxuICAgICAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHt9O1xufVxuXG5jb25zdCBTVEFOREFSRF9QUk9QUyA9IHtcbiAgICBzdGFydDogaWRlbnRpdHksXG4gICAgZW5kOiBpZGVudGl0eSxcbiAgICBhbGxEYXk6IEJvb2xlYW4sXG59O1xuZnVuY3Rpb24gcGFyc2VEYXRlU3BhbihyYXcsIGRhdGVFbnYsIGRlZmF1bHREdXJhdGlvbikge1xuICAgIGxldCBzcGFuID0gcGFyc2VPcGVuRGF0ZVNwYW4ocmF3LCBkYXRlRW52KTtcbiAgICBsZXQgeyByYW5nZSB9ID0gc3BhbjtcbiAgICBpZiAoIXJhbmdlLnN0YXJ0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoIXJhbmdlLmVuZCkge1xuICAgICAgICBpZiAoZGVmYXVsdER1cmF0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJhbmdlLmVuZCA9IGRhdGVFbnYuYWRkKHJhbmdlLnN0YXJ0LCBkZWZhdWx0RHVyYXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gc3Bhbjtcbn1cbi8qXG5UT0RPOiBzb21laG93IGNvbWJpbmUgd2l0aCBwYXJzZVJhbmdlP1xuV2lsbCByZXR1cm4gbnVsbCBpZiB0aGUgc3RhcnQvZW5kIHByb3BzIHdlcmUgcHJlc2VudCBidXQgcGFyc2VkIGludmFsaWRseS5cbiovXG5mdW5jdGlvbiBwYXJzZU9wZW5EYXRlU3BhbihyYXcsIGRhdGVFbnYpIHtcbiAgICBsZXQgeyByZWZpbmVkOiBzdGFuZGFyZFByb3BzLCBleHRyYSB9ID0gcmVmaW5lUHJvcHMocmF3LCBTVEFOREFSRF9QUk9QUyk7XG4gICAgbGV0IHN0YXJ0TWV0YSA9IHN0YW5kYXJkUHJvcHMuc3RhcnQgPyBkYXRlRW52LmNyZWF0ZU1hcmtlck1ldGEoc3RhbmRhcmRQcm9wcy5zdGFydCkgOiBudWxsO1xuICAgIGxldCBlbmRNZXRhID0gc3RhbmRhcmRQcm9wcy5lbmQgPyBkYXRlRW52LmNyZWF0ZU1hcmtlck1ldGEoc3RhbmRhcmRQcm9wcy5lbmQpIDogbnVsbDtcbiAgICBsZXQgeyBhbGxEYXkgfSA9IHN0YW5kYXJkUHJvcHM7XG4gICAgaWYgKGFsbERheSA9PSBudWxsKSB7XG4gICAgICAgIGFsbERheSA9IChzdGFydE1ldGEgJiYgc3RhcnRNZXRhLmlzVGltZVVuc3BlY2lmaWVkKSAmJlxuICAgICAgICAgICAgKCFlbmRNZXRhIHx8IGVuZE1ldGEuaXNUaW1lVW5zcGVjaWZpZWQpO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IHJhbmdlOiB7XG4gICAgICAgICAgICBzdGFydDogc3RhcnRNZXRhID8gc3RhcnRNZXRhLm1hcmtlciA6IG51bGwsXG4gICAgICAgICAgICBlbmQ6IGVuZE1ldGEgPyBlbmRNZXRhLm1hcmtlciA6IG51bGwsXG4gICAgICAgIH0sIGFsbERheSB9LCBleHRyYSk7XG59XG5mdW5jdGlvbiBpc0RhdGVTcGFuc0VxdWFsKHNwYW4wLCBzcGFuMSkge1xuICAgIHJldHVybiByYW5nZXNFcXVhbChzcGFuMC5yYW5nZSwgc3BhbjEucmFuZ2UpICYmXG4gICAgICAgIHNwYW4wLmFsbERheSA9PT0gc3BhbjEuYWxsRGF5ICYmXG4gICAgICAgIGlzU3BhblByb3BzRXF1YWwoc3BhbjAsIHNwYW4xKTtcbn1cbi8vIHRoZSBOT04tREFURS1SRUxBVEVEIHByb3BzXG5mdW5jdGlvbiBpc1NwYW5Qcm9wc0VxdWFsKHNwYW4wLCBzcGFuMSkge1xuICAgIGZvciAobGV0IHByb3BOYW1lIGluIHNwYW4xKSB7XG4gICAgICAgIGlmIChwcm9wTmFtZSAhPT0gJ3JhbmdlJyAmJiBwcm9wTmFtZSAhPT0gJ2FsbERheScpIHtcbiAgICAgICAgICAgIGlmIChzcGFuMFtwcm9wTmFtZV0gIT09IHNwYW4xW3Byb3BOYW1lXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBhcmUgdGhlcmUgYW55IHByb3BzIHRoYXQgc3BhbjAgaGFzIHRoYXQgc3BhbjEgRE9FU04nVCBoYXZlP1xuICAgIC8vIGJvdGggaGF2ZSByYW5nZS9hbGxEYXksIHNvIG5vIG5lZWQgdG8gc3BlY2lhbC1jYXNlLlxuICAgIGZvciAobGV0IHByb3BOYW1lIGluIHNwYW4wKSB7XG4gICAgICAgIGlmICghKHByb3BOYW1lIGluIHNwYW4xKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gYnVpbGREYXRlU3BhbkFwaShzcGFuLCBkYXRlRW52KSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYnVpbGRSYW5nZUFwaShzcGFuLnJhbmdlLCBkYXRlRW52LCBzcGFuLmFsbERheSkpLCB7IGFsbERheTogc3Bhbi5hbGxEYXkgfSk7XG59XG5mdW5jdGlvbiBidWlsZFJhbmdlQXBpV2l0aFRpbWVab25lKHJhbmdlLCBkYXRlRW52LCBvbWl0VGltZSkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJ1aWxkUmFuZ2VBcGkocmFuZ2UsIGRhdGVFbnYsIG9taXRUaW1lKSksIHsgdGltZVpvbmU6IGRhdGVFbnYudGltZVpvbmUgfSk7XG59XG5mdW5jdGlvbiBidWlsZFJhbmdlQXBpKHJhbmdlLCBkYXRlRW52LCBvbWl0VGltZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiBkYXRlRW52LnRvRGF0ZShyYW5nZS5zdGFydCksXG4gICAgICAgIGVuZDogZGF0ZUVudi50b0RhdGUocmFuZ2UuZW5kKSxcbiAgICAgICAgc3RhcnRTdHI6IGRhdGVFbnYuZm9ybWF0SXNvKHJhbmdlLnN0YXJ0LCB7IG9taXRUaW1lIH0pLFxuICAgICAgICBlbmRTdHI6IGRhdGVFbnYuZm9ybWF0SXNvKHJhbmdlLmVuZCwgeyBvbWl0VGltZSB9KSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZmFicmljYXRlRXZlbnRSYW5nZShkYXRlU3BhbiwgZXZlbnRVaUJhc2VzLCBjb250ZXh0KSB7XG4gICAgbGV0IHJlcyA9IHJlZmluZUV2ZW50RGVmKHsgZWRpdGFibGU6IGZhbHNlIH0sIGNvbnRleHQpO1xuICAgIGxldCBkZWYgPSBwYXJzZUV2ZW50RGVmKHJlcy5yZWZpbmVkLCByZXMuZXh0cmEsICcnLCAvLyBzb3VyY2VJZFxuICAgIGRhdGVTcGFuLmFsbERheSwgdHJ1ZSwgLy8gaGFzRW5kXG4gICAgY29udGV4dCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVmLFxuICAgICAgICB1aTogY29tcGlsZUV2ZW50VWkoZGVmLCBldmVudFVpQmFzZXMpLFxuICAgICAgICBpbnN0YW5jZTogY3JlYXRlRXZlbnRJbnN0YW5jZShkZWYuZGVmSWQsIGRhdGVTcGFuLnJhbmdlKSxcbiAgICAgICAgcmFuZ2U6IGRhdGVTcGFuLnJhbmdlLFxuICAgICAgICBpc1N0YXJ0OiB0cnVlLFxuICAgICAgICBpc0VuZDogdHJ1ZSxcbiAgICB9O1xufVxuXG4vKlxuZ2l2ZW4gYSBmdW5jdGlvbiB0aGF0IHJlc29sdmVzIGEgcmVzdWx0IGFzeW5jaHJvbm91c2x5LlxudGhlIGZ1bmN0aW9uIGNhbiBlaXRoZXIgY2FsbCBwYXNzZWQtaW4gc3VjY2VzcyBhbmQgZmFpbHVyZSBjYWxsYmFja3MsXG5vciBpdCBjYW4gcmV0dXJuIGEgcHJvbWlzZS5cbmlmIHlvdSBuZWVkIHRvIHBhc3MgYWRkaXRpb25hbCBwYXJhbXMgdG8gZnVuYywgYmluZCB0aGVtIGZpcnN0LlxuKi9cbmZ1bmN0aW9uIHVucHJvbWlzaWZ5KGZ1bmMsIG5vcm1hbGl6ZWRTdWNjZXNzQ2FsbGJhY2ssIG5vcm1hbGl6ZWRGYWlsdXJlQ2FsbGJhY2spIHtcbiAgICAvLyBndWFyZCBhZ2FpbnN0IHN1Y2Nlc3MvZmFpbHVyZSBjYWxsYmFja3MgYmVpbmcgY2FsbGVkIG1vcmUgdGhhbiBvbmNlXG4gICAgLy8gYW5kIGd1YXJkIGFnYWluc3QgYSBwcm9taXNlIEFORCBjYWxsYmFjayBiZWluZyB1c2VkIHRvZ2V0aGVyLlxuICAgIGxldCBpc1Jlc29sdmVkID0gZmFsc2U7XG4gICAgbGV0IHdyYXBwZWRTdWNjZXNzID0gZnVuY3Rpb24gKHJlcykge1xuICAgICAgICBpZiAoIWlzUmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIGlzUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgbm9ybWFsaXplZFN1Y2Nlc3NDYWxsYmFjayhyZXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBsZXQgd3JhcHBlZEZhaWx1cmUgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKCFpc1Jlc29sdmVkKSB7XG4gICAgICAgICAgICBpc1Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRGYWlsdXJlQ2FsbGJhY2soZXJyb3IpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBsZXQgcmVzID0gZnVuYyh3cmFwcGVkU3VjY2Vzcywgd3JhcHBlZEZhaWx1cmUpO1xuICAgIGlmIChyZXMgJiYgdHlwZW9mIHJlcy50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJlcy50aGVuKHdyYXBwZWRTdWNjZXNzLCB3cmFwcGVkRmFpbHVyZSk7XG4gICAgfVxufVxuXG5jbGFzcyBKc29uUmVxdWVzdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHJlc3BvbnNlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVxdWVzdEpzb24obWV0aG9kLCB1cmwsIHBhcmFtcykge1xuICAgIG1ldGhvZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICAgIGNvbnN0IGZldGNoT3B0aW9ucyA9IHtcbiAgICAgICAgbWV0aG9kLFxuICAgIH07XG4gICAgaWYgKG1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICAgICAgdXJsICs9ICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgK1xuICAgICAgICAgICAgbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbXMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZmV0Y2hPcHRpb25zLmJvZHkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtcyk7XG4gICAgICAgIGZldGNoT3B0aW9ucy5oZWFkZXJzID0ge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZmV0Y2godXJsLCBmZXRjaE9wdGlvbnMpLnRoZW4oKGZldGNoUmVzKSA9PiB7XG4gICAgICAgIGlmIChmZXRjaFJlcy5vaykge1xuICAgICAgICAgICAgcmV0dXJuIGZldGNoUmVzLmpzb24oKS50aGVuKChwYXJzZWRSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBbcGFyc2VkUmVzcG9uc2UsIGZldGNoUmVzXTtcbiAgICAgICAgICAgIH0sICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSnNvblJlcXVlc3RFcnJvcignRmFpbHVyZSBwYXJzaW5nIEpTT04nLCBmZXRjaFJlcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBKc29uUmVxdWVzdEVycm9yKCdSZXF1ZXN0IGZhaWxlZCcsIGZldGNoUmVzKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5sZXQgY2FuVkdyb3dXaXRoaW5DZWxsO1xuZnVuY3Rpb24gZ2V0Q2FuVkdyb3dXaXRoaW5DZWxsKCkge1xuICAgIGlmIChjYW5WR3Jvd1dpdGhpbkNlbGwgPT0gbnVsbCkge1xuICAgICAgICBjYW5WR3Jvd1dpdGhpbkNlbGwgPSBjb21wdXRlQ2FuVkdyb3dXaXRoaW5DZWxsKCk7XG4gICAgfVxuICAgIHJldHVybiBjYW5WR3Jvd1dpdGhpbkNlbGw7XG59XG5mdW5jdGlvbiBjb21wdXRlQ2FuVkdyb3dXaXRoaW5DZWxsKCkge1xuICAgIC8vIGZvciBTU1IsIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBpcyBjYWxsIGltbWVkaWF0ZWx5IGF0IHRvcC1sZXZlbFxuICAgIC8vIFRPRE86IGp1c3QgbWFrZSB0aGlzIGxvZ2ljIGV4ZWN1dGUgdG9wLWxldmVsLCBpbW1lZGlhdGVseSwgaW5zdGVhZCBvZiBkb2luZyBsYXppbHlcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWwuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGVsLnN0eWxlLnRvcCA9ICcwcHgnO1xuICAgIGVsLnN0eWxlLmxlZnQgPSAnMHB4JztcbiAgICBlbC5pbm5lckhUTUwgPSAnPHRhYmxlPjx0cj48dGQ+PGRpdj48L2Rpdj48L3RkPjwvdHI+PC90YWJsZT4nO1xuICAgIGVsLnF1ZXJ5U2VsZWN0b3IoJ3RhYmxlJykuc3R5bGUuaGVpZ2h0ID0gJzEwMHB4JztcbiAgICBlbC5xdWVyeVNlbGVjdG9yKCdkaXYnKS5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbCk7XG4gICAgbGV0IGRpdiA9IGVsLnF1ZXJ5U2VsZWN0b3IoJ2RpdicpO1xuICAgIGxldCBwb3NzaWJsZSA9IGRpdi5vZmZzZXRIZWlnaHQgPiAwO1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZWwpO1xuICAgIHJldHVybiBwb3NzaWJsZTtcbn1cblxuY2xhc3MgQ2FsZW5kYXJSb290IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBmb3JQcmludDogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlQmVmb3JlUHJpbnQgPSAoKSA9PiB7XG4gICAgICAgICAgICBmbHVzaFN5bmMoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBmb3JQcmludDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUFmdGVyUHJpbnQgPSAoKSA9PiB7XG4gICAgICAgICAgICBmbHVzaFN5bmMoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBmb3JQcmludDogZmFsc2UgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgb3B0aW9ucyB9ID0gcHJvcHM7XG4gICAgICAgIGxldCB7IGZvclByaW50IH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBsZXQgaXNIZWlnaHRBdXRvID0gZm9yUHJpbnQgfHwgb3B0aW9ucy5oZWlnaHQgPT09ICdhdXRvJyB8fCBvcHRpb25zLmNvbnRlbnRIZWlnaHQgPT09ICdhdXRvJztcbiAgICAgICAgbGV0IGhlaWdodCA9ICghaXNIZWlnaHRBdXRvICYmIG9wdGlvbnMuaGVpZ2h0ICE9IG51bGwpID8gb3B0aW9ucy5oZWlnaHQgOiAnJztcbiAgICAgICAgbGV0IGNsYXNzTmFtZXMgPSBbXG4gICAgICAgICAgICAnZmMnLFxuICAgICAgICAgICAgZm9yUHJpbnQgPyAnZmMtbWVkaWEtcHJpbnQnIDogJ2ZjLW1lZGlhLXNjcmVlbicsXG4gICAgICAgICAgICBgZmMtZGlyZWN0aW9uLSR7b3B0aW9ucy5kaXJlY3Rpb259YCxcbiAgICAgICAgICAgIHByb3BzLnRoZW1lLmdldENsYXNzKCdyb290JyksXG4gICAgICAgIF07XG4gICAgICAgIGlmICghZ2V0Q2FuVkdyb3dXaXRoaW5DZWxsKCkpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtbGlxdWlkLWhhY2snKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvcHMuY2hpbGRyZW4oY2xhc3NOYW1lcywgaGVpZ2h0LCBpc0hlaWdodEF1dG8sIGZvclByaW50KTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIGxldCB7IGVtaXR0ZXIgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGVtaXR0ZXIub24oJ19iZWZvcmVwcmludCcsIHRoaXMuaGFuZGxlQmVmb3JlUHJpbnQpO1xuICAgICAgICBlbWl0dGVyLm9uKCdfYWZ0ZXJwcmludCcsIHRoaXMuaGFuZGxlQWZ0ZXJQcmludCk7XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICBsZXQgeyBlbWl0dGVyIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBlbWl0dGVyLm9mZignX2JlZm9yZXByaW50JywgdGhpcy5oYW5kbGVCZWZvcmVQcmludCk7XG4gICAgICAgIGVtaXR0ZXIub2ZmKCdfYWZ0ZXJwcmludCcsIHRoaXMuaGFuZGxlQWZ0ZXJQcmludCk7XG4gICAgfVxufVxuXG5jbGFzcyBJbnRlcmFjdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBzZXR0aW5ncy5jb21wb25lbnQ7XG4gICAgICAgIHRoaXMuaXNIaXRDb21ib0FsbG93ZWQgPSBzZXR0aW5ncy5pc0hpdENvbWJvQWxsb3dlZCB8fCBudWxsO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlSW50ZXJhY3Rpb25TZXR0aW5ncyhjb21wb25lbnQsIGlucHV0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29tcG9uZW50LFxuICAgICAgICBlbDogaW5wdXQuZWwsXG4gICAgICAgIHVzZUV2ZW50Q2VudGVyOiBpbnB1dC51c2VFdmVudENlbnRlciAhPSBudWxsID8gaW5wdXQudXNlRXZlbnRDZW50ZXIgOiB0cnVlLFxuICAgICAgICBpc0hpdENvbWJvQWxsb3dlZDogaW5wdXQuaXNIaXRDb21ib0FsbG93ZWQgfHwgbnVsbCxcbiAgICB9O1xufVxuZnVuY3Rpb24gaW50ZXJhY3Rpb25TZXR0aW5nc1RvU3RvcmUoc2V0dGluZ3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBbc2V0dGluZ3MuY29tcG9uZW50LnVpZF06IHNldHRpbmdzLFxuICAgIH07XG59XG4vLyBnbG9iYWwgc3RhdGVcbmNvbnN0IGludGVyYWN0aW9uU2V0dGluZ3NTdG9yZSA9IHt9O1xuXG5jbGFzcyBDYWxlbmRhckltcGwge1xuICAgIGdldEN1cnJlbnREYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50RGF0YU1hbmFnZXIuZ2V0Q3VycmVudERhdGEoKTtcbiAgICB9XG4gICAgZGlzcGF0Y2goYWN0aW9uKSB7XG4gICAgICAgIHRoaXMuY3VycmVudERhdGFNYW5hZ2VyLmRpc3BhdGNoKGFjdGlvbik7XG4gICAgfVxuICAgIGdldCB2aWV3KCkgeyByZXR1cm4gdGhpcy5nZXRDdXJyZW50RGF0YSgpLnZpZXdBcGk7IH1cbiAgICBiYXRjaFJlbmRlcmluZyhjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgICB1cGRhdGVTaXplKCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ19yZXNpemUnLCB0cnVlKTtcbiAgICB9XG4gICAgLy8gT3B0aW9uc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgc2V0T3B0aW9uKG5hbWUsIHZhbCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdTRVRfT1BUSU9OJyxcbiAgICAgICAgICAgIG9wdGlvbk5hbWU6IG5hbWUsXG4gICAgICAgICAgICByYXdPcHRpb25WYWx1ZTogdmFsLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0T3B0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudERhdGFNYW5hZ2VyLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dFtuYW1lXTtcbiAgICB9XG4gICAgZ2V0QXZhaWxhYmxlTG9jYWxlQ29kZXMoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmdldEN1cnJlbnREYXRhKCkuYXZhaWxhYmxlUmF3TG9jYWxlcyk7XG4gICAgfVxuICAgIC8vIFRyaWdnZXJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIG9uKGhhbmRsZXJOYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgIGxldCB7IGN1cnJlbnREYXRhTWFuYWdlciB9ID0gdGhpcztcbiAgICAgICAgaWYgKGN1cnJlbnREYXRhTWFuYWdlci5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lcnNbaGFuZGxlck5hbWVdKSB7XG4gICAgICAgICAgICBjdXJyZW50RGF0YU1hbmFnZXIuZW1pdHRlci5vbihoYW5kbGVyTmFtZSwgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFVua25vd24gbGlzdGVuZXIgbmFtZSAnJHtoYW5kbGVyTmFtZX0nYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb2ZmKGhhbmRsZXJOYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuY3VycmVudERhdGFNYW5hZ2VyLmVtaXR0ZXIub2ZmKGhhbmRsZXJOYW1lLCBoYW5kbGVyKTtcbiAgICB9XG4gICAgLy8gbm90IG1lYW50IGZvciBwdWJsaWMgdXNlXG4gICAgdHJpZ2dlcihoYW5kbGVyTmFtZSwgLi4uYXJncykge1xuICAgICAgICB0aGlzLmN1cnJlbnREYXRhTWFuYWdlci5lbWl0dGVyLnRyaWdnZXIoaGFuZGxlck5hbWUsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICAvLyBWaWV3XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBjaGFuZ2VWaWV3KHZpZXdUeXBlLCBkYXRlT3JSYW5nZSkge1xuICAgICAgICB0aGlzLmJhdGNoUmVuZGVyaW5nKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgICAgIGlmIChkYXRlT3JSYW5nZSkge1xuICAgICAgICAgICAgICAgIGlmIChkYXRlT3JSYW5nZS5zdGFydCAmJiBkYXRlT3JSYW5nZS5lbmQpIHsgLy8gYSByYW5nZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfVklFV19UWVBFJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdUeXBlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnU0VUX09QVElPTicsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25OYW1lOiAndmlzaWJsZVJhbmdlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhd09wdGlvblZhbHVlOiBkYXRlT3JSYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeyBkYXRlRW52IH0gPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0NIQU5HRV9WSUVXX1RZUEUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld1R5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlTWFya2VyOiBkYXRlRW52LmNyZWF0ZU1hcmtlcihkYXRlT3JSYW5nZSksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX1ZJRVdfVFlQRScsXG4gICAgICAgICAgICAgICAgICAgIHZpZXdUeXBlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gRm9yY2VzIG5hdmlnYXRpb24gdG8gYSB2aWV3IGZvciB0aGUgZ2l2ZW4gZGF0ZS5cbiAgICAvLyBgdmlld1R5cGVgIGNhbiBiZSBhIHNwZWNpZmljIHZpZXcgbmFtZSBvciBhIGdlbmVyaWMgb25lIGxpa2UgXCJ3ZWVrXCIgb3IgXCJkYXlcIi5cbiAgICAvLyBuZWVkcyB0byBjaGFuZ2VcbiAgICB6b29tVG8oZGF0ZU1hcmtlciwgdmlld1R5cGUpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICBsZXQgc3BlYztcbiAgICAgICAgdmlld1R5cGUgPSB2aWV3VHlwZSB8fCAnZGF5JzsgLy8gZGF5IGlzIGRlZmF1bHQgem9vbVxuICAgICAgICBzcGVjID0gc3RhdGUudmlld1NwZWNzW3ZpZXdUeXBlXSB8fCB0aGlzLmdldFVuaXRWaWV3U3BlYyh2aWV3VHlwZSk7XG4gICAgICAgIHRoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgaWYgKHNwZWMpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfVklFV19UWVBFJyxcbiAgICAgICAgICAgICAgICB2aWV3VHlwZTogc3BlYy50eXBlLFxuICAgICAgICAgICAgICAgIGRhdGVNYXJrZXIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfREFURScsXG4gICAgICAgICAgICAgICAgZGF0ZU1hcmtlcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEdpdmVuIGEgZHVyYXRpb24gc2luZ3VsYXIgdW5pdCwgbGlrZSBcIndlZWtcIiBvciBcImRheVwiLCBmaW5kcyBhIG1hdGNoaW5nIHZpZXcgc3BlYy5cbiAgICAvLyBQcmVmZXJlbmNlIGlzIGdpdmVuIHRvIHZpZXdzIHRoYXQgaGF2ZSBjb3JyZXNwb25kaW5nIGJ1dHRvbnMuXG4gICAgZ2V0VW5pdFZpZXdTcGVjKHVuaXQpIHtcbiAgICAgICAgbGV0IHsgdmlld1NwZWNzLCB0b29sYmFyQ29uZmlnIH0gPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIGxldCB2aWV3VHlwZXMgPSBbXS5jb25jYXQodG9vbGJhckNvbmZpZy5oZWFkZXIgPyB0b29sYmFyQ29uZmlnLmhlYWRlci52aWV3c1dpdGhCdXR0b25zIDogW10sIHRvb2xiYXJDb25maWcuZm9vdGVyID8gdG9vbGJhckNvbmZpZy5mb290ZXIudmlld3NXaXRoQnV0dG9ucyA6IFtdKTtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGxldCBzcGVjO1xuICAgICAgICBmb3IgKGxldCB2aWV3VHlwZSBpbiB2aWV3U3BlY3MpIHtcbiAgICAgICAgICAgIHZpZXdUeXBlcy5wdXNoKHZpZXdUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmlld1R5cGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBzcGVjID0gdmlld1NwZWNzW3ZpZXdUeXBlc1tpXV07XG4gICAgICAgICAgICBpZiAoc3BlYykge1xuICAgICAgICAgICAgICAgIGlmIChzcGVjLnNpbmdsZVVuaXQgPT09IHVuaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNwZWM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBDdXJyZW50IERhdGVcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHByZXYoKSB7XG4gICAgICAgIHRoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdQUkVWJyB9KTtcbiAgICB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgdGhpcy51bnNlbGVjdCgpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHsgdHlwZTogJ05FWFQnIH0pO1xuICAgIH1cbiAgICBwcmV2WWVhcigpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ0NIQU5HRV9EQVRFJyxcbiAgICAgICAgICAgIGRhdGVNYXJrZXI6IHN0YXRlLmRhdGVFbnYuYWRkWWVhcnMoc3RhdGUuY3VycmVudERhdGUsIC0xKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5leHRZZWFyKCkge1xuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIHRoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX0RBVEUnLFxuICAgICAgICAgICAgZGF0ZU1hcmtlcjogc3RhdGUuZGF0ZUVudi5hZGRZZWFycyhzdGF0ZS5jdXJyZW50RGF0ZSwgMSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0b2RheSgpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ0NIQU5HRV9EQVRFJyxcbiAgICAgICAgICAgIGRhdGVNYXJrZXI6IGdldE5vdyhzdGF0ZS5jYWxlbmRhck9wdGlvbnMubm93LCBzdGF0ZS5kYXRlRW52KSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdvdG9EYXRlKHpvbmVkRGF0ZUlucHV0KSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgdGhpcy51bnNlbGVjdCgpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfREFURScsXG4gICAgICAgICAgICBkYXRlTWFya2VyOiBzdGF0ZS5kYXRlRW52LmNyZWF0ZU1hcmtlcih6b25lZERhdGVJbnB1dCksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbmNyZW1lbnREYXRlKGRlbHRhSW5wdXQpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICBsZXQgZGVsdGEgPSBjcmVhdGVEdXJhdGlvbihkZWx0YUlucHV0KTtcbiAgICAgICAgaWYgKGRlbHRhKSB7IC8vIGVsc2UsIHdhcm4gYWJvdXQgaW52YWxpZCBpbnB1dD9cbiAgICAgICAgICAgIHRoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfREFURScsXG4gICAgICAgICAgICAgICAgZGF0ZU1hcmtlcjogc3RhdGUuZGF0ZUVudi5hZGQoc3RhdGUuY3VycmVudERhdGUsIGRlbHRhKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldERhdGUoKSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlLmRhdGVFbnYudG9EYXRlKHN0YXRlLmN1cnJlbnREYXRlKTtcbiAgICB9XG4gICAgLy8gRGF0ZSBGb3JtYXR0aW5nIFV0aWxzXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmb3JtYXREYXRlKGQsIGZvcm1hdHRlcikge1xuICAgICAgICBsZXQgeyBkYXRlRW52IH0gPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdChkYXRlRW52LmNyZWF0ZU1hcmtlcihkKSwgY3JlYXRlRm9ybWF0dGVyKGZvcm1hdHRlcikpO1xuICAgIH1cbiAgICAvLyBgc2V0dGluZ3NgIGlzIGZvciBmb3JtYXR0ZXIgQU5EIGlzRW5kRXhjbHVzaXZlXG4gICAgZm9ybWF0UmFuZ2UoZDAsIGQxLCBzZXR0aW5ncykge1xuICAgICAgICBsZXQgeyBkYXRlRW52IH0gPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdFJhbmdlKGRhdGVFbnYuY3JlYXRlTWFya2VyKGQwKSwgZGF0ZUVudi5jcmVhdGVNYXJrZXIoZDEpLCBjcmVhdGVGb3JtYXR0ZXIoc2V0dGluZ3MpLCBzZXR0aW5ncyk7XG4gICAgfVxuICAgIGZvcm1hdElzbyhkLCBvbWl0VGltZSkge1xuICAgICAgICBsZXQgeyBkYXRlRW52IH0gPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdElzbyhkYXRlRW52LmNyZWF0ZU1hcmtlcihkKSwgeyBvbWl0VGltZSB9KTtcbiAgICB9XG4gICAgLy8gRGF0ZSBTZWxlY3Rpb24gLyBFdmVudCBTZWxlY3Rpb24gLyBEYXlDbGlja1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgc2VsZWN0KGRhdGVPck9iaiwgZW5kRGF0ZSkge1xuICAgICAgICBsZXQgc2VsZWN0aW9uSW5wdXQ7XG4gICAgICAgIGlmIChlbmREYXRlID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChkYXRlT3JPYmouc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbklucHV0ID0gZGF0ZU9yT2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uSW5wdXQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBkYXRlT3JPYmosXG4gICAgICAgICAgICAgICAgICAgIGVuZDogbnVsbCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VsZWN0aW9uSW5wdXQgPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IGRhdGVPck9iaixcbiAgICAgICAgICAgICAgICBlbmQ6IGVuZERhdGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgbGV0IHNlbGVjdGlvbiA9IHBhcnNlRGF0ZVNwYW4oc2VsZWN0aW9uSW5wdXQsIHN0YXRlLmRhdGVFbnYsIGNyZWF0ZUR1cmF0aW9uKHsgZGF5czogMSB9KSk7XG4gICAgICAgIGlmIChzZWxlY3Rpb24pIHsgLy8gdGhyb3cgcGFyc2UgZXJyb3Igb3RoZXJ3aXNlP1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdTRUxFQ1RfREFURVMnLCBzZWxlY3Rpb24gfSk7XG4gICAgICAgICAgICB0cmlnZ2VyRGF0ZVNlbGVjdChzZWxlY3Rpb24sIG51bGwsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1bnNlbGVjdChwZXYpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICBpZiAoc3RhdGUuZGF0ZVNlbGVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFTEVDVF9EQVRFUycgfSk7XG4gICAgICAgICAgICB0cmlnZ2VyRGF0ZVVuc2VsZWN0KHBldiwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFB1YmxpYyBFdmVudHMgQVBJXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBhZGRFdmVudChldmVudElucHV0LCBzb3VyY2VJbnB1dCkge1xuICAgICAgICBpZiAoZXZlbnRJbnB1dCBpbnN0YW5jZW9mIEV2ZW50SW1wbCkge1xuICAgICAgICAgICAgbGV0IGRlZiA9IGV2ZW50SW5wdXQuX2RlZjtcbiAgICAgICAgICAgIGxldCBpbnN0YW5jZSA9IGV2ZW50SW5wdXQuX2luc3RhbmNlO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnREYXRhID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICAgICAgLy8gbm90IGFscmVhZHkgcHJlc2VudD8gZG9uJ3Qgd2FudCB0byBhZGQgYW4gb2xkIHNuYXBzaG90XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnREYXRhLmV2ZW50U3RvcmUuZGVmc1tkZWYuZGVmSWRdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdBRERfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogZXZlbnRUdXBsZVRvU3RvcmUoeyBkZWYsIGluc3RhbmNlIH0pLCAvLyBUT0RPOiBiZXR0ZXIgdXRpbCBmb3IgdHdvIGFyZ3M/XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnRBZGQoZXZlbnRJbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRJbnB1dDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIGxldCBldmVudFNvdXJjZTtcbiAgICAgICAgaWYgKHNvdXJjZUlucHV0IGluc3RhbmNlb2YgRXZlbnRTb3VyY2VJbXBsKSB7XG4gICAgICAgICAgICBldmVudFNvdXJjZSA9IHNvdXJjZUlucHV0LmludGVybmFsRXZlbnRTb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHNvdXJjZUlucHV0ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2VJbnB1dCkgeyAvLyB0cnVlLiBwYXJ0IG9mIHRoZSBmaXJzdCBldmVudCBzb3VyY2VcbiAgICAgICAgICAgICAgICBbZXZlbnRTb3VyY2VdID0gaGFzaFZhbHVlc1RvQXJyYXkoc3RhdGUuZXZlbnRTb3VyY2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzb3VyY2VJbnB1dCAhPSBudWxsKSB7IC8vIGFuIElELiBhY2NlcHRzIGEgbnVtYmVyIHRvb1xuICAgICAgICAgICAgbGV0IHNvdXJjZUFwaSA9IHRoaXMuZ2V0RXZlbnRTb3VyY2VCeUlkKHNvdXJjZUlucHV0KTsgLy8gVE9ETzogdXNlIGFuIGludGVybmFsIGZ1bmN0aW9uXG4gICAgICAgICAgICBpZiAoIXNvdXJjZUFwaSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgQ291bGQgbm90IGZpbmQgYW4gZXZlbnQgc291cmNlIHdpdGggSUQgXCIke3NvdXJjZUlucHV0fVwiYCk7IC8vIFRPRE86IHRlc3RcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50U291cmNlID0gc291cmNlQXBpLmludGVybmFsRXZlbnRTb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHR1cGxlID0gcGFyc2VFdmVudChldmVudElucHV0LCBldmVudFNvdXJjZSwgc3RhdGUsIGZhbHNlKTtcbiAgICAgICAgaWYgKHR1cGxlKSB7XG4gICAgICAgICAgICBsZXQgbmV3RXZlbnRBcGkgPSBuZXcgRXZlbnRJbXBsKHN0YXRlLCB0dXBsZS5kZWYsIHR1cGxlLmRlZi5yZWN1cnJpbmdEZWYgPyBudWxsIDogdHVwbGUuaW5zdGFuY2UpO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0FERF9FVkVOVFMnLFxuICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IGV2ZW50VHVwbGVUb1N0b3JlKHR1cGxlKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnRBZGQobmV3RXZlbnRBcGkpO1xuICAgICAgICAgICAgcmV0dXJuIG5ld0V2ZW50QXBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0cmlnZ2VyRXZlbnRBZGQoZXZlbnRBcGkpIHtcbiAgICAgICAgbGV0IHsgZW1pdHRlciB9ID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICBlbWl0dGVyLnRyaWdnZXIoJ2V2ZW50QWRkJywge1xuICAgICAgICAgICAgZXZlbnQ6IGV2ZW50QXBpLFxuICAgICAgICAgICAgcmVsYXRlZEV2ZW50czogW10sXG4gICAgICAgICAgICByZXZlcnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1JFTU9WRV9FVkVOVFMnLFxuICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlOiBldmVudEFwaVRvU3RvcmUoZXZlbnRBcGkpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFRPRE86IG9wdGltaXplXG4gICAgZ2V0RXZlbnRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgbGV0IHsgZGVmcywgaW5zdGFuY2VzIH0gPSBzdGF0ZS5ldmVudFN0b3JlO1xuICAgICAgICBpZCA9IFN0cmluZyhpZCk7XG4gICAgICAgIGZvciAobGV0IGRlZklkIGluIGRlZnMpIHtcbiAgICAgICAgICAgIGxldCBkZWYgPSBkZWZzW2RlZklkXTtcbiAgICAgICAgICAgIGlmIChkZWYucHVibGljSWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlZi5yZWN1cnJpbmdEZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudEltcGwoc3RhdGUsIGRlZiwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGluc3RhbmNlSWQgaW4gaW5zdGFuY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbnN0YW5jZSA9IGluc3RhbmNlc1tpbnN0YW5jZUlkXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLmRlZklkID09PSBkZWYuZGVmSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRJbXBsKHN0YXRlLCBkZWYsIGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZ2V0RXZlbnRzKCkge1xuICAgICAgICBsZXQgY3VycmVudERhdGEgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIHJldHVybiBidWlsZEV2ZW50QXBpcyhjdXJyZW50RGF0YS5ldmVudFN0b3JlLCBjdXJyZW50RGF0YSk7XG4gICAgfVxuICAgIHJlbW92ZUFsbEV2ZW50cygpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdSRU1PVkVfQUxMX0VWRU5UUycgfSk7XG4gICAgfVxuICAgIC8vIFB1YmxpYyBFdmVudCBTb3VyY2VzIEFQSVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZ2V0RXZlbnRTb3VyY2VzKCkge1xuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIGxldCBzb3VyY2VIYXNoID0gc3RhdGUuZXZlbnRTb3VyY2VzO1xuICAgICAgICBsZXQgc291cmNlQXBpcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpbnRlcm5hbElkIGluIHNvdXJjZUhhc2gpIHtcbiAgICAgICAgICAgIHNvdXJjZUFwaXMucHVzaChuZXcgRXZlbnRTb3VyY2VJbXBsKHN0YXRlLCBzb3VyY2VIYXNoW2ludGVybmFsSWRdKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNvdXJjZUFwaXM7XG4gICAgfVxuICAgIGdldEV2ZW50U291cmNlQnlJZChpZCkge1xuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIGxldCBzb3VyY2VIYXNoID0gc3RhdGUuZXZlbnRTb3VyY2VzO1xuICAgICAgICBpZCA9IFN0cmluZyhpZCk7XG4gICAgICAgIGZvciAobGV0IHNvdXJjZUlkIGluIHNvdXJjZUhhc2gpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2VIYXNoW3NvdXJjZUlkXS5wdWJsaWNJZCA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50U291cmNlSW1wbChzdGF0ZSwgc291cmNlSGFzaFtzb3VyY2VJZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhZGRFdmVudFNvdXJjZShzb3VyY2VJbnB1dCkge1xuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIGlmIChzb3VyY2VJbnB1dCBpbnN0YW5jZW9mIEV2ZW50U291cmNlSW1wbCkge1xuICAgICAgICAgICAgLy8gbm90IGFscmVhZHkgcHJlc2VudD8gZG9uJ3Qgd2FudCB0byBhZGQgYW4gb2xkIHNuYXBzaG90XG4gICAgICAgICAgICBpZiAoIXN0YXRlLmV2ZW50U291cmNlc1tzb3VyY2VJbnB1dC5pbnRlcm5hbEV2ZW50U291cmNlLnNvdXJjZUlkXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQUREX0VWRU5UX1NPVVJDRVMnLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VzOiBbc291cmNlSW5wdXQuaW50ZXJuYWxFdmVudFNvdXJjZV0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc291cmNlSW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGV2ZW50U291cmNlID0gcGFyc2VFdmVudFNvdXJjZShzb3VyY2VJbnB1dCwgc3RhdGUpO1xuICAgICAgICBpZiAoZXZlbnRTb3VyY2UpIHsgLy8gVE9ETzogZXJyb3Igb3RoZXJ3aXNlP1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdBRERfRVZFTlRfU09VUkNFUycsIHNvdXJjZXM6IFtldmVudFNvdXJjZV0gfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50U291cmNlSW1wbChzdGF0ZSwgZXZlbnRTb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZW1vdmVBbGxFdmVudFNvdXJjZXMoKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnUkVNT1ZFX0FMTF9FVkVOVF9TT1VSQ0VTJyB9KTtcbiAgICB9XG4gICAgcmVmZXRjaEV2ZW50cygpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdGRVRDSF9FVkVOVF9TT1VSQ0VTJywgaXNSZWZldGNoOiB0cnVlIH0pO1xuICAgIH1cbiAgICAvLyBTY3JvbGxcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHNjcm9sbFRvVGltZSh0aW1lSW5wdXQpIHtcbiAgICAgICAgbGV0IHRpbWUgPSBjcmVhdGVEdXJhdGlvbih0aW1lSW5wdXQpO1xuICAgICAgICBpZiAodGltZSkge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdfc2Nyb2xsUmVxdWVzdCcsIHsgdGltZSB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gcG9pbnRJbnNpZGVSZWN0KHBvaW50LCByZWN0KSB7XG4gICAgcmV0dXJuIHBvaW50LmxlZnQgPj0gcmVjdC5sZWZ0ICYmXG4gICAgICAgIHBvaW50LmxlZnQgPCByZWN0LnJpZ2h0ICYmXG4gICAgICAgIHBvaW50LnRvcCA+PSByZWN0LnRvcCAmJlxuICAgICAgICBwb2ludC50b3AgPCByZWN0LmJvdHRvbTtcbn1cbi8vIFJldHVybnMgYSBuZXcgcmVjdGFuZ2xlIHRoYXQgaXMgdGhlIGludGVyc2VjdGlvbiBvZiB0aGUgdHdvIHJlY3RhbmdsZXMuIElmIHRoZXkgZG9uJ3QgaW50ZXJzZWN0LCByZXR1cm5zIGZhbHNlXG5mdW5jdGlvbiBpbnRlcnNlY3RSZWN0cyhyZWN0MSwgcmVjdDIpIHtcbiAgICBsZXQgcmVzID0ge1xuICAgICAgICBsZWZ0OiBNYXRoLm1heChyZWN0MS5sZWZ0LCByZWN0Mi5sZWZ0KSxcbiAgICAgICAgcmlnaHQ6IE1hdGgubWluKHJlY3QxLnJpZ2h0LCByZWN0Mi5yaWdodCksXG4gICAgICAgIHRvcDogTWF0aC5tYXgocmVjdDEudG9wLCByZWN0Mi50b3ApLFxuICAgICAgICBib3R0b206IE1hdGgubWluKHJlY3QxLmJvdHRvbSwgcmVjdDIuYm90dG9tKSxcbiAgICB9O1xuICAgIGlmIChyZXMubGVmdCA8IHJlcy5yaWdodCAmJiByZXMudG9wIDwgcmVzLmJvdHRvbSkge1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiB0cmFuc2xhdGVSZWN0KHJlY3QsIGRlbHRhWCwgZGVsdGFZKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogcmVjdC5sZWZ0ICsgZGVsdGFYLFxuICAgICAgICByaWdodDogcmVjdC5yaWdodCArIGRlbHRhWCxcbiAgICAgICAgdG9wOiByZWN0LnRvcCArIGRlbHRhWSxcbiAgICAgICAgYm90dG9tOiByZWN0LmJvdHRvbSArIGRlbHRhWSxcbiAgICB9O1xufVxuLy8gUmV0dXJucyBhIG5ldyBwb2ludCB0aGF0IHdpbGwgaGF2ZSBiZWVuIG1vdmVkIHRvIHJlc2lkZSB3aXRoaW4gdGhlIGdpdmVuIHJlY3RhbmdsZVxuZnVuY3Rpb24gY29uc3RyYWluUG9pbnQocG9pbnQsIHJlY3QpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBNYXRoLm1pbihNYXRoLm1heChwb2ludC5sZWZ0LCByZWN0LmxlZnQpLCByZWN0LnJpZ2h0KSxcbiAgICAgICAgdG9wOiBNYXRoLm1pbihNYXRoLm1heChwb2ludC50b3AsIHJlY3QudG9wKSwgcmVjdC5ib3R0b20pLFxuICAgIH07XG59XG4vLyBSZXR1cm5zIGEgcG9pbnQgdGhhdCBpcyB0aGUgY2VudGVyIG9mIHRoZSBnaXZlbiByZWN0YW5nbGVcbmZ1bmN0aW9uIGdldFJlY3RDZW50ZXIocmVjdCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDIsXG4gICAgICAgIHRvcDogKHJlY3QudG9wICsgcmVjdC5ib3R0b20pIC8gMixcbiAgICB9O1xufVxuLy8gU3VidHJhY3RzIHBvaW50MidzIGNvb3JkaW5hdGVzIGZyb20gcG9pbnQxJ3MgY29vcmRpbmF0ZXMsIHJldHVybmluZyBhIGRlbHRhXG5mdW5jdGlvbiBkaWZmUG9pbnRzKHBvaW50MSwgcG9pbnQyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogcG9pbnQxLmxlZnQgLSBwb2ludDIubGVmdCxcbiAgICAgICAgdG9wOiBwb2ludDEudG9wIC0gcG9pbnQyLnRvcCxcbiAgICB9O1xufVxuXG5jb25zdCBFTVBUWV9FVkVOVF9TVE9SRSA9IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpOyAvLyBmb3IgcHVyZWNvbXBvbmVudHMuIFRPRE86IGtlZXAgZWxzZXdoZXJlXG5jbGFzcyBTcGxpdHRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZ2V0S2V5c0ZvckV2ZW50RGVmcyA9IG1lbW9pemUodGhpcy5fZ2V0S2V5c0ZvckV2ZW50RGVmcyk7XG4gICAgICAgIHRoaXMuc3BsaXREYXRlU2VsZWN0aW9uID0gbWVtb2l6ZSh0aGlzLl9zcGxpdERhdGVTcGFuKTtcbiAgICAgICAgdGhpcy5zcGxpdEV2ZW50U3RvcmUgPSBtZW1vaXplKHRoaXMuX3NwbGl0RXZlbnRTdG9yZSk7XG4gICAgICAgIHRoaXMuc3BsaXRJbmRpdmlkdWFsVWkgPSBtZW1vaXplKHRoaXMuX3NwbGl0SW5kaXZpZHVhbFVpKTtcbiAgICAgICAgdGhpcy5zcGxpdEV2ZW50RHJhZyA9IG1lbW9pemUodGhpcy5fc3BsaXRJbnRlcmFjdGlvbik7XG4gICAgICAgIHRoaXMuc3BsaXRFdmVudFJlc2l6ZSA9IG1lbW9pemUodGhpcy5fc3BsaXRJbnRlcmFjdGlvbik7XG4gICAgICAgIHRoaXMuZXZlbnRVaUJ1aWxkZXJzID0ge307IC8vIFRPRE86IHR5cGVzY3JpcHQgcHJvdGVjdGlvblxuICAgIH1cbiAgICBzcGxpdFByb3BzKHByb3BzKSB7XG4gICAgICAgIGxldCBrZXlJbmZvcyA9IHRoaXMuZ2V0S2V5SW5mbyhwcm9wcyk7XG4gICAgICAgIGxldCBkZWZLZXlzID0gdGhpcy5nZXRLZXlzRm9yRXZlbnREZWZzKHByb3BzLmV2ZW50U3RvcmUpO1xuICAgICAgICBsZXQgZGF0ZVNlbGVjdGlvbnMgPSB0aGlzLnNwbGl0RGF0ZVNlbGVjdGlvbihwcm9wcy5kYXRlU2VsZWN0aW9uKTtcbiAgICAgICAgbGV0IGluZGl2aWR1YWxVaSA9IHRoaXMuc3BsaXRJbmRpdmlkdWFsVWkocHJvcHMuZXZlbnRVaUJhc2VzLCBkZWZLZXlzKTsgLy8gdGhlIGluZGl2aWR1YWwgKmJhc2VzKlxuICAgICAgICBsZXQgZXZlbnRTdG9yZXMgPSB0aGlzLnNwbGl0RXZlbnRTdG9yZShwcm9wcy5ldmVudFN0b3JlLCBkZWZLZXlzKTtcbiAgICAgICAgbGV0IGV2ZW50RHJhZ3MgPSB0aGlzLnNwbGl0RXZlbnREcmFnKHByb3BzLmV2ZW50RHJhZyk7XG4gICAgICAgIGxldCBldmVudFJlc2l6ZXMgPSB0aGlzLnNwbGl0RXZlbnRSZXNpemUocHJvcHMuZXZlbnRSZXNpemUpO1xuICAgICAgICBsZXQgc3BsaXRQcm9wcyA9IHt9O1xuICAgICAgICB0aGlzLmV2ZW50VWlCdWlsZGVycyA9IG1hcEhhc2goa2V5SW5mb3MsIChpbmZvLCBrZXkpID0+IHRoaXMuZXZlbnRVaUJ1aWxkZXJzW2tleV0gfHwgbWVtb2l6ZShidWlsZEV2ZW50VWlGb3JLZXkpKTtcbiAgICAgICAgZm9yIChsZXQga2V5IGluIGtleUluZm9zKSB7XG4gICAgICAgICAgICBsZXQga2V5SW5mbyA9IGtleUluZm9zW2tleV07XG4gICAgICAgICAgICBsZXQgZXZlbnRTdG9yZSA9IGV2ZW50U3RvcmVzW2tleV0gfHwgRU1QVFlfRVZFTlRfU1RPUkU7XG4gICAgICAgICAgICBsZXQgYnVpbGRFdmVudFVpID0gdGhpcy5ldmVudFVpQnVpbGRlcnNba2V5XTtcbiAgICAgICAgICAgIHNwbGl0UHJvcHNba2V5XSA9IHtcbiAgICAgICAgICAgICAgICBidXNpbmVzc0hvdXJzOiBrZXlJbmZvLmJ1c2luZXNzSG91cnMgfHwgcHJvcHMuYnVzaW5lc3NIb3VycyxcbiAgICAgICAgICAgICAgICBkYXRlU2VsZWN0aW9uOiBkYXRlU2VsZWN0aW9uc1trZXldIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgZXZlbnRTdG9yZSxcbiAgICAgICAgICAgICAgICBldmVudFVpQmFzZXM6IGJ1aWxkRXZlbnRVaShwcm9wcy5ldmVudFVpQmFzZXNbJyddLCBrZXlJbmZvLnVpLCBpbmRpdmlkdWFsVWlba2V5XSksXG4gICAgICAgICAgICAgICAgZXZlbnRTZWxlY3Rpb246IGV2ZW50U3RvcmUuaW5zdGFuY2VzW3Byb3BzLmV2ZW50U2VsZWN0aW9uXSA/IHByb3BzLmV2ZW50U2VsZWN0aW9uIDogJycsXG4gICAgICAgICAgICAgICAgZXZlbnREcmFnOiBldmVudERyYWdzW2tleV0gfHwgbnVsbCxcbiAgICAgICAgICAgICAgICBldmVudFJlc2l6ZTogZXZlbnRSZXNpemVzW2tleV0gfHwgbnVsbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwbGl0UHJvcHM7XG4gICAgfVxuICAgIF9zcGxpdERhdGVTcGFuKGRhdGVTcGFuKSB7XG4gICAgICAgIGxldCBkYXRlU3BhbnMgPSB7fTtcbiAgICAgICAgaWYgKGRhdGVTcGFuKSB7XG4gICAgICAgICAgICBsZXQga2V5cyA9IHRoaXMuZ2V0S2V5c0ZvckRhdGVTcGFuKGRhdGVTcGFuKTtcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgICAgICAgICAgZGF0ZVNwYW5zW2tleV0gPSBkYXRlU3BhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZVNwYW5zO1xuICAgIH1cbiAgICBfZ2V0S2V5c0ZvckV2ZW50RGVmcyhldmVudFN0b3JlKSB7XG4gICAgICAgIHJldHVybiBtYXBIYXNoKGV2ZW50U3RvcmUuZGVmcywgKGV2ZW50RGVmKSA9PiB0aGlzLmdldEtleXNGb3JFdmVudERlZihldmVudERlZikpO1xuICAgIH1cbiAgICBfc3BsaXRFdmVudFN0b3JlKGV2ZW50U3RvcmUsIGRlZktleXMpIHtcbiAgICAgICAgbGV0IHsgZGVmcywgaW5zdGFuY2VzIH0gPSBldmVudFN0b3JlO1xuICAgICAgICBsZXQgc3BsaXRTdG9yZXMgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgZGVmSWQgaW4gZGVmcykge1xuICAgICAgICAgICAgZm9yIChsZXQga2V5IG9mIGRlZktleXNbZGVmSWRdKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzcGxpdFN0b3Jlc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwbGl0U3RvcmVzW2tleV0gPSBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3BsaXRTdG9yZXNba2V5XS5kZWZzW2RlZklkXSA9IGRlZnNbZGVmSWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGluc3RhbmNlSWQgaW4gaW5zdGFuY2VzKSB7XG4gICAgICAgICAgICBsZXQgaW5zdGFuY2UgPSBpbnN0YW5jZXNbaW5zdGFuY2VJZF07XG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgb2YgZGVmS2V5c1tpbnN0YW5jZS5kZWZJZF0pIHtcbiAgICAgICAgICAgICAgICBpZiAoc3BsaXRTdG9yZXNba2V5XSkgeyAvLyBtdXN0IGhhdmUgYWxyZWFkeSBiZWVuIGNyZWF0ZWRcbiAgICAgICAgICAgICAgICAgICAgc3BsaXRTdG9yZXNba2V5XS5pbnN0YW5jZXNbaW5zdGFuY2VJZF0gPSBpbnN0YW5jZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwbGl0U3RvcmVzO1xuICAgIH1cbiAgICBfc3BsaXRJbmRpdmlkdWFsVWkoZXZlbnRVaUJhc2VzLCBkZWZLZXlzKSB7XG4gICAgICAgIGxldCBzcGxpdEhhc2hlcyA9IHt9O1xuICAgICAgICBmb3IgKGxldCBkZWZJZCBpbiBldmVudFVpQmFzZXMpIHtcbiAgICAgICAgICAgIGlmIChkZWZJZCkgeyAvLyBub3QgdGhlICcnIGtleVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGtleSBvZiBkZWZLZXlzW2RlZklkXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNwbGl0SGFzaGVzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwbGl0SGFzaGVzW2tleV0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzcGxpdEhhc2hlc1trZXldW2RlZklkXSA9IGV2ZW50VWlCYXNlc1tkZWZJZF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGxpdEhhc2hlcztcbiAgICB9XG4gICAgX3NwbGl0SW50ZXJhY3Rpb24oaW50ZXJhY3Rpb24pIHtcbiAgICAgICAgbGV0IHNwbGl0U3RhdGVzID0ge307XG4gICAgICAgIGlmIChpbnRlcmFjdGlvbikge1xuICAgICAgICAgICAgbGV0IGFmZmVjdGVkU3RvcmVzID0gdGhpcy5fc3BsaXRFdmVudFN0b3JlKGludGVyYWN0aW9uLmFmZmVjdGVkRXZlbnRzLCB0aGlzLl9nZXRLZXlzRm9yRXZlbnREZWZzKGludGVyYWN0aW9uLmFmZmVjdGVkRXZlbnRzKSk7XG4gICAgICAgICAgICAvLyBjYW4ndCByZWx5IG9uIGRlZktleXMgYmVjYXVzZSBldmVudCBkYXRhIGlzIG11dGF0ZWRcbiAgICAgICAgICAgIGxldCBtdXRhdGVkS2V5c0J5RGVmSWQgPSB0aGlzLl9nZXRLZXlzRm9yRXZlbnREZWZzKGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMpO1xuICAgICAgICAgICAgbGV0IG11dGF0ZWRTdG9yZXMgPSB0aGlzLl9zcGxpdEV2ZW50U3RvcmUoaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cywgbXV0YXRlZEtleXNCeURlZklkKTtcbiAgICAgICAgICAgIGxldCBwb3B1bGF0ZSA9IChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXNwbGl0U3RhdGVzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgc3BsaXRTdGF0ZXNba2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmZmVjdGVkRXZlbnRzOiBhZmZlY3RlZFN0b3Jlc1trZXldIHx8IEVNUFRZX0VWRU5UX1NUT1JFLFxuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRlZEV2ZW50czogbXV0YXRlZFN0b3Jlc1trZXldIHx8IEVNUFRZX0VWRU5UX1NUT1JFLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNFdmVudDogaW50ZXJhY3Rpb24uaXNFdmVudCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIGFmZmVjdGVkU3RvcmVzKSB7XG4gICAgICAgICAgICAgICAgcG9wdWxhdGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBtdXRhdGVkU3RvcmVzKSB7XG4gICAgICAgICAgICAgICAgcG9wdWxhdGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BsaXRTdGF0ZXM7XG4gICAgfVxufVxuZnVuY3Rpb24gYnVpbGRFdmVudFVpRm9yS2V5KGFsbFVpLCBldmVudFVpRm9yS2V5LCBpbmRpdmlkdWFsVWkpIHtcbiAgICBsZXQgYmFzZVBhcnRzID0gW107XG4gICAgaWYgKGFsbFVpKSB7XG4gICAgICAgIGJhc2VQYXJ0cy5wdXNoKGFsbFVpKTtcbiAgICB9XG4gICAgaWYgKGV2ZW50VWlGb3JLZXkpIHtcbiAgICAgICAgYmFzZVBhcnRzLnB1c2goZXZlbnRVaUZvcktleSk7XG4gICAgfVxuICAgIGxldCBzdHVmZiA9IHtcbiAgICAgICAgJyc6IGNvbWJpbmVFdmVudFVpcyhiYXNlUGFydHMpLFxuICAgIH07XG4gICAgaWYgKGluZGl2aWR1YWxVaSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKHN0dWZmLCBpbmRpdmlkdWFsVWkpO1xuICAgIH1cbiAgICByZXR1cm4gc3R1ZmY7XG59XG5cbmZ1bmN0aW9uIGdldERhdGVNZXRhKGRhdGUsIHRvZGF5UmFuZ2UsIG5vd0RhdGUsIGRhdGVQcm9maWxlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZG93OiBkYXRlLmdldFVUQ0RheSgpLFxuICAgICAgICBpc0Rpc2FibGVkOiBCb29sZWFuKGRhdGVQcm9maWxlICYmICFyYW5nZUNvbnRhaW5zTWFya2VyKGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLCBkYXRlKSksXG4gICAgICAgIGlzT3RoZXI6IEJvb2xlYW4oZGF0ZVByb2ZpbGUgJiYgIXJhbmdlQ29udGFpbnNNYXJrZXIoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLCBkYXRlKSksXG4gICAgICAgIGlzVG9kYXk6IEJvb2xlYW4odG9kYXlSYW5nZSAmJiByYW5nZUNvbnRhaW5zTWFya2VyKHRvZGF5UmFuZ2UsIGRhdGUpKSxcbiAgICAgICAgaXNQYXN0OiBCb29sZWFuKG5vd0RhdGUgPyAoZGF0ZSA8IG5vd0RhdGUpIDogdG9kYXlSYW5nZSA/IChkYXRlIDwgdG9kYXlSYW5nZS5zdGFydCkgOiBmYWxzZSksXG4gICAgICAgIGlzRnV0dXJlOiBCb29sZWFuKG5vd0RhdGUgPyAoZGF0ZSA+IG5vd0RhdGUpIDogdG9kYXlSYW5nZSA/IChkYXRlID49IHRvZGF5UmFuZ2UuZW5kKSA6IGZhbHNlKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0RGF5Q2xhc3NOYW1lcyhtZXRhLCB0aGVtZSkge1xuICAgIGxldCBjbGFzc05hbWVzID0gW1xuICAgICAgICAnZmMtZGF5JyxcbiAgICAgICAgYGZjLWRheS0ke0RBWV9JRFNbbWV0YS5kb3ddfWAsXG4gICAgXTtcbiAgICBpZiAobWV0YS5pc0Rpc2FibGVkKSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZGF5LWRpc2FibGVkJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAobWV0YS5pc1RvZGF5KSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWRheS10b2RheScpO1xuICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKHRoZW1lLmdldENsYXNzKCd0b2RheScpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YS5pc1Bhc3QpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZGF5LXBhc3QnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YS5pc0Z1dHVyZSkge1xuICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1kYXktZnV0dXJlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuaXNPdGhlcikge1xuICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1kYXktb3RoZXInKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2xhc3NOYW1lcztcbn1cbmZ1bmN0aW9uIGdldFNsb3RDbGFzc05hbWVzKG1ldGEsIHRoZW1lKSB7XG4gICAgbGV0IGNsYXNzTmFtZXMgPSBbXG4gICAgICAgICdmYy1zbG90JyxcbiAgICAgICAgYGZjLXNsb3QtJHtEQVlfSURTW21ldGEuZG93XX1gLFxuICAgIF07XG4gICAgaWYgKG1ldGEuaXNEaXNhYmxlZCkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNsb3QtZGlzYWJsZWQnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChtZXRhLmlzVG9kYXkpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtc2xvdC10b2RheScpO1xuICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKHRoZW1lLmdldENsYXNzKCd0b2RheScpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YS5pc1Bhc3QpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtc2xvdC1wYXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuaXNGdXR1cmUpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtc2xvdC1mdXR1cmUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2xhc3NOYW1lcztcbn1cblxuY29uc3QgREFZX0ZPUk1BVCA9IGNyZWF0ZUZvcm1hdHRlcih7IHllYXI6ICdudW1lcmljJywgbW9udGg6ICdsb25nJywgZGF5OiAnbnVtZXJpYycgfSk7XG5jb25zdCBXRUVLX0ZPUk1BVCA9IGNyZWF0ZUZvcm1hdHRlcih7IHdlZWs6ICdsb25nJyB9KTtcbmZ1bmN0aW9uIGJ1aWxkTmF2TGlua0F0dHJzKGNvbnRleHQsIGRhdGVNYXJrZXIsIHZpZXdUeXBlID0gJ2RheScsIGlzVGFiYmFibGUgPSB0cnVlKSB7XG4gICAgY29uc3QgeyBkYXRlRW52LCBvcHRpb25zLCBjYWxlbmRhckFwaSB9ID0gY29udGV4dDtcbiAgICBsZXQgZGF0ZVN0ciA9IGRhdGVFbnYuZm9ybWF0KGRhdGVNYXJrZXIsIHZpZXdUeXBlID09PSAnd2VlaycgPyBXRUVLX0ZPUk1BVCA6IERBWV9GT1JNQVQpO1xuICAgIGlmIChvcHRpb25zLm5hdkxpbmtzKSB7XG4gICAgICAgIGxldCB6b25lZERhdGUgPSBkYXRlRW52LnRvRGF0ZShkYXRlTWFya2VyKTtcbiAgICAgICAgY29uc3QgaGFuZGxlSW50ZXJhY3Rpb24gPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGxldCBjdXN0b21BY3Rpb24gPSB2aWV3VHlwZSA9PT0gJ2RheScgPyBvcHRpb25zLm5hdkxpbmtEYXlDbGljayA6XG4gICAgICAgICAgICAgICAgdmlld1R5cGUgPT09ICd3ZWVrJyA/IG9wdGlvbnMubmF2TGlua1dlZWtDbGljayA6IG51bGw7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGN1c3RvbUFjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGN1c3RvbUFjdGlvbi5jYWxsKGNhbGVuZGFyQXBpLCBkYXRlRW52LnRvRGF0ZShkYXRlTWFya2VyKSwgZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXN0b21BY3Rpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdUeXBlID0gY3VzdG9tQWN0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxlbmRhckFwaS56b29tVG8oZGF0ZU1hcmtlciwgdmlld1R5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IHRpdGxlOiBmb3JtYXRXaXRoT3JkaW5hbHMob3B0aW9ucy5uYXZMaW5rSGludCwgW2RhdGVTdHIsIHpvbmVkRGF0ZV0sIGRhdGVTdHIpLCAnZGF0YS1uYXZsaW5rJzogJycgfSwgKGlzVGFiYmFibGVcbiAgICAgICAgICAgID8gY3JlYXRlQXJpYUNsaWNrQXR0cnMoaGFuZGxlSW50ZXJhY3Rpb24pXG4gICAgICAgICAgICA6IHsgb25DbGljazogaGFuZGxlSW50ZXJhY3Rpb24gfSkpO1xuICAgIH1cbiAgICByZXR1cm4geyAnYXJpYS1sYWJlbCc6IGRhdGVTdHIgfTtcbn1cblxubGV0IF9pc1J0bFNjcm9sbGJhck9uTGVmdCA9IG51bGw7XG5mdW5jdGlvbiBnZXRJc1J0bFNjcm9sbGJhck9uTGVmdCgpIHtcbiAgICBpZiAoX2lzUnRsU2Nyb2xsYmFyT25MZWZ0ID09PSBudWxsKSB7XG4gICAgICAgIF9pc1J0bFNjcm9sbGJhck9uTGVmdCA9IGNvbXB1dGVJc1J0bFNjcm9sbGJhck9uTGVmdCgpO1xuICAgIH1cbiAgICByZXR1cm4gX2lzUnRsU2Nyb2xsYmFyT25MZWZ0O1xufVxuZnVuY3Rpb24gY29tcHV0ZUlzUnRsU2Nyb2xsYmFyT25MZWZ0KCkge1xuICAgIGxldCBvdXRlckVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgYXBwbHlTdHlsZShvdXRlckVsLCB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICB0b3A6IC0xMDAwLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICBib3JkZXI6IDAsXG4gICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgIG92ZXJmbG93OiAnc2Nyb2xsJyxcbiAgICAgICAgZGlyZWN0aW9uOiAncnRsJyxcbiAgICB9KTtcbiAgICBvdXRlckVsLmlubmVySFRNTCA9ICc8ZGl2PjwvZGl2Pic7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChvdXRlckVsKTtcbiAgICBsZXQgaW5uZXJFbCA9IG91dGVyRWwuZmlyc3RDaGlsZDtcbiAgICBsZXQgcmVzID0gaW5uZXJFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0ID4gb3V0ZXJFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuICAgIHJlbW92ZUVsZW1lbnQob3V0ZXJFbCk7XG4gICAgcmV0dXJuIHJlcztcbn1cblxubGV0IF9zY3JvbGxiYXJXaWR0aHM7XG5mdW5jdGlvbiBnZXRTY3JvbGxiYXJXaWR0aHMoKSB7XG4gICAgaWYgKCFfc2Nyb2xsYmFyV2lkdGhzKSB7XG4gICAgICAgIF9zY3JvbGxiYXJXaWR0aHMgPSBjb21wdXRlU2Nyb2xsYmFyV2lkdGhzKCk7XG4gICAgfVxuICAgIHJldHVybiBfc2Nyb2xsYmFyV2lkdGhzO1xufVxuZnVuY3Rpb24gY29tcHV0ZVNjcm9sbGJhcldpZHRocygpIHtcbiAgICBsZXQgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBlbC5zdHlsZS5vdmVyZmxvdyA9ICdzY3JvbGwnO1xuICAgIGVsLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBlbC5zdHlsZS50b3AgPSAnLTk5OTlweCc7XG4gICAgZWwuc3R5bGUubGVmdCA9ICctOTk5OXB4JztcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsKTtcbiAgICBsZXQgcmVzID0gY29tcHV0ZVNjcm9sbGJhcldpZHRoc0ZvckVsKGVsKTtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsKTtcbiAgICByZXR1cm4gcmVzO1xufVxuLy8gV0FSTklORzogd2lsbCBpbmNsdWRlIGJvcmRlclxuZnVuY3Rpb24gY29tcHV0ZVNjcm9sbGJhcldpZHRoc0ZvckVsKGVsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogZWwub2Zmc2V0SGVpZ2h0IC0gZWwuY2xpZW50SGVpZ2h0LFxuICAgICAgICB5OiBlbC5vZmZzZXRXaWR0aCAtIGVsLmNsaWVudFdpZHRoLFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVFZGdlcyhlbCwgZ2V0UGFkZGluZyA9IGZhbHNlKSB7XG4gICAgbGV0IGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgbGV0IGJvcmRlckxlZnQgPSBwYXJzZUludChjb21wdXRlZFN0eWxlLmJvcmRlckxlZnRXaWR0aCwgMTApIHx8IDA7XG4gICAgbGV0IGJvcmRlclJpZ2h0ID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5ib3JkZXJSaWdodFdpZHRoLCAxMCkgfHwgMDtcbiAgICBsZXQgYm9yZGVyVG9wID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5ib3JkZXJUb3BXaWR0aCwgMTApIHx8IDA7XG4gICAgbGV0IGJvcmRlckJvdHRvbSA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuYm9yZGVyQm90dG9tV2lkdGgsIDEwKSB8fCAwO1xuICAgIGxldCBiYWRTY3JvbGxiYXJXaWR0aHMgPSBjb21wdXRlU2Nyb2xsYmFyV2lkdGhzRm9yRWwoZWwpOyAvLyBpbmNsdWRlcyBib3JkZXIhXG4gICAgbGV0IHNjcm9sbGJhckxlZnRSaWdodCA9IGJhZFNjcm9sbGJhcldpZHRocy55IC0gYm9yZGVyTGVmdCAtIGJvcmRlclJpZ2h0O1xuICAgIGxldCBzY3JvbGxiYXJCb3R0b20gPSBiYWRTY3JvbGxiYXJXaWR0aHMueCAtIGJvcmRlclRvcCAtIGJvcmRlckJvdHRvbTtcbiAgICBsZXQgcmVzID0ge1xuICAgICAgICBib3JkZXJMZWZ0LFxuICAgICAgICBib3JkZXJSaWdodCxcbiAgICAgICAgYm9yZGVyVG9wLFxuICAgICAgICBib3JkZXJCb3R0b20sXG4gICAgICAgIHNjcm9sbGJhckJvdHRvbSxcbiAgICAgICAgc2Nyb2xsYmFyTGVmdDogMCxcbiAgICAgICAgc2Nyb2xsYmFyUmlnaHQ6IDAsXG4gICAgfTtcbiAgICBpZiAoZ2V0SXNSdGxTY3JvbGxiYXJPbkxlZnQoKSAmJiBjb21wdXRlZFN0eWxlLmRpcmVjdGlvbiA9PT0gJ3J0bCcpIHsgLy8gaXMgdGhlIHNjcm9sbGJhciBvbiB0aGUgbGVmdCBzaWRlP1xuICAgICAgICByZXMuc2Nyb2xsYmFyTGVmdCA9IHNjcm9sbGJhckxlZnRSaWdodDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlcy5zY3JvbGxiYXJSaWdodCA9IHNjcm9sbGJhckxlZnRSaWdodDtcbiAgICB9XG4gICAgaWYgKGdldFBhZGRpbmcpIHtcbiAgICAgICAgcmVzLnBhZGRpbmdMZWZ0ID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nTGVmdCwgMTApIHx8IDA7XG4gICAgICAgIHJlcy5wYWRkaW5nUmlnaHQgPSBwYXJzZUludChjb21wdXRlZFN0eWxlLnBhZGRpbmdSaWdodCwgMTApIHx8IDA7XG4gICAgICAgIHJlcy5wYWRkaW5nVG9wID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nVG9wLCAxMCkgfHwgMDtcbiAgICAgICAgcmVzLnBhZGRpbmdCb3R0b20gPSBwYXJzZUludChjb21wdXRlZFN0eWxlLnBhZGRpbmdCb3R0b20sIDEwKSB8fCAwO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gY29tcHV0ZUlubmVyUmVjdChlbCwgZ29XaXRoaW5QYWRkaW5nID0gZmFsc2UsIGRvRnJvbVdpbmRvd1ZpZXdwb3J0KSB7XG4gICAgbGV0IG91dGVyUmVjdCA9IGRvRnJvbVdpbmRvd1ZpZXdwb3J0ID8gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiBjb21wdXRlUmVjdChlbCk7XG4gICAgbGV0IGVkZ2VzID0gY29tcHV0ZUVkZ2VzKGVsLCBnb1dpdGhpblBhZGRpbmcpO1xuICAgIGxldCByZXMgPSB7XG4gICAgICAgIGxlZnQ6IG91dGVyUmVjdC5sZWZ0ICsgZWRnZXMuYm9yZGVyTGVmdCArIGVkZ2VzLnNjcm9sbGJhckxlZnQsXG4gICAgICAgIHJpZ2h0OiBvdXRlclJlY3QucmlnaHQgLSBlZGdlcy5ib3JkZXJSaWdodCAtIGVkZ2VzLnNjcm9sbGJhclJpZ2h0LFxuICAgICAgICB0b3A6IG91dGVyUmVjdC50b3AgKyBlZGdlcy5ib3JkZXJUb3AsXG4gICAgICAgIGJvdHRvbTogb3V0ZXJSZWN0LmJvdHRvbSAtIGVkZ2VzLmJvcmRlckJvdHRvbSAtIGVkZ2VzLnNjcm9sbGJhckJvdHRvbSxcbiAgICB9O1xuICAgIGlmIChnb1dpdGhpblBhZGRpbmcpIHtcbiAgICAgICAgcmVzLmxlZnQgKz0gZWRnZXMucGFkZGluZ0xlZnQ7XG4gICAgICAgIHJlcy5yaWdodCAtPSBlZGdlcy5wYWRkaW5nUmlnaHQ7XG4gICAgICAgIHJlcy50b3AgKz0gZWRnZXMucGFkZGluZ1RvcDtcbiAgICAgICAgcmVzLmJvdHRvbSAtPSBlZGdlcy5wYWRkaW5nQm90dG9tO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gY29tcHV0ZVJlY3QoZWwpIHtcbiAgICBsZXQgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IHJlY3QubGVmdCArIHdpbmRvdy5zY3JvbGxYLFxuICAgICAgICB0b3A6IHJlY3QudG9wICsgd2luZG93LnNjcm9sbFksXG4gICAgICAgIHJpZ2h0OiByZWN0LnJpZ2h0ICsgd2luZG93LnNjcm9sbFgsXG4gICAgICAgIGJvdHRvbTogcmVjdC5ib3R0b20gKyB3aW5kb3cuc2Nyb2xsWSxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcHV0ZUNsaXBwZWRDbGllbnRSZWN0KGVsKSB7XG4gICAgbGV0IGNsaXBwaW5nUGFyZW50cyA9IGdldENsaXBwaW5nUGFyZW50cyhlbCk7XG4gICAgbGV0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBmb3IgKGxldCBjbGlwcGluZ1BhcmVudCBvZiBjbGlwcGluZ1BhcmVudHMpIHtcbiAgICAgICAgbGV0IGludGVyc2VjdGlvbiA9IGludGVyc2VjdFJlY3RzKHJlY3QsIGNsaXBwaW5nUGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcbiAgICAgICAgaWYgKGludGVyc2VjdGlvbikge1xuICAgICAgICAgICAgcmVjdCA9IGludGVyc2VjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZWN0O1xufVxuLy8gZG9lcyBub3QgcmV0dXJuIHdpbmRvd1xuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsKSB7XG4gICAgbGV0IHBhcmVudHMgPSBbXTtcbiAgICB3aGlsZSAoZWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkgeyAvLyB3aWxsIHN0b3Agd2hlbiBnZXRzIHRvIGRvY3VtZW50IG9yIG51bGxcbiAgICAgICAgbGV0IGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgICAgIGlmIChjb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoKC8oYXV0b3xzY3JvbGwpLykudGVzdChjb21wdXRlZFN0eWxlLm92ZXJmbG93ICsgY29tcHV0ZWRTdHlsZS5vdmVyZmxvd1kgKyBjb21wdXRlZFN0eWxlLm92ZXJmbG93WCkpIHtcbiAgICAgICAgICAgIHBhcmVudHMucHVzaChlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWwgPSBlbC5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gcGFyZW50cztcbn1cblxuLypcblJlY29yZHMgb2Zmc2V0IGluZm9ybWF0aW9uIGZvciBhIHNldCBvZiBlbGVtZW50cywgcmVsYXRpdmUgdG8gYW4gb3JpZ2luIGVsZW1lbnQuXG5DYW4gcmVjb3JkIHRoZSBsZWZ0L3JpZ2h0IE9SIHRoZSB0b3AvYm90dG9tIE9SIGJvdGguXG5Qcm92aWRlcyBtZXRob2RzIGZvciBxdWVyeWluZyB0aGUgY2FjaGUgYnkgcG9zaXRpb24uXG4qL1xuY2xhc3MgUG9zaXRpb25DYWNoZSB7XG4gICAgY29uc3RydWN0b3Iob3JpZ2luRWwsIGVscywgaXNIb3Jpem9udGFsLCBpc1ZlcnRpY2FsKSB7XG4gICAgICAgIHRoaXMuZWxzID0gZWxzO1xuICAgICAgICBsZXQgb3JpZ2luQ2xpZW50UmVjdCA9IHRoaXMub3JpZ2luQ2xpZW50UmVjdCA9IG9yaWdpbkVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyAvLyByZWxhdGl2ZSB0byB2aWV3cG9ydCB0b3AtbGVmdFxuICAgICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkRWxIb3Jpem9udGFscyhvcmlnaW5DbGllbnRSZWN0LmxlZnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1ZlcnRpY2FsKSB7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkRWxWZXJ0aWNhbHMob3JpZ2luQ2xpZW50UmVjdC50b3ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFBvcHVsYXRlcyB0aGUgbGVmdC9yaWdodCBpbnRlcm5hbCBjb29yZGluYXRlIGFycmF5c1xuICAgIGJ1aWxkRWxIb3Jpem9udGFscyhvcmlnaW5DbGllbnRMZWZ0KSB7XG4gICAgICAgIGxldCBsZWZ0cyA9IFtdO1xuICAgICAgICBsZXQgcmlnaHRzID0gW107XG4gICAgICAgIGZvciAobGV0IGVsIG9mIHRoaXMuZWxzKSB7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgbGVmdHMucHVzaChyZWN0LmxlZnQgLSBvcmlnaW5DbGllbnRMZWZ0KTtcbiAgICAgICAgICAgIHJpZ2h0cy5wdXNoKHJlY3QucmlnaHQgLSBvcmlnaW5DbGllbnRMZWZ0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlZnRzID0gbGVmdHM7XG4gICAgICAgIHRoaXMucmlnaHRzID0gcmlnaHRzO1xuICAgIH1cbiAgICAvLyBQb3B1bGF0ZXMgdGhlIHRvcC9ib3R0b20gaW50ZXJuYWwgY29vcmRpbmF0ZSBhcnJheXNcbiAgICBidWlsZEVsVmVydGljYWxzKG9yaWdpbkNsaWVudFRvcCkge1xuICAgICAgICBsZXQgdG9wcyA9IFtdO1xuICAgICAgICBsZXQgYm90dG9tcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBlbCBvZiB0aGlzLmVscykge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHRvcHMucHVzaChyZWN0LnRvcCAtIG9yaWdpbkNsaWVudFRvcCk7XG4gICAgICAgICAgICBib3R0b21zLnB1c2gocmVjdC5ib3R0b20gLSBvcmlnaW5DbGllbnRUb3ApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG9wcyA9IHRvcHM7XG4gICAgICAgIHRoaXMuYm90dG9tcyA9IGJvdHRvbXM7XG4gICAgfVxuICAgIC8vIEdpdmVuIGEgbGVmdCBvZmZzZXQgKGZyb20gZG9jdW1lbnQgbGVmdCksIHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBlbCB0aGF0IGl0IGhvcml6b250YWxseSBpbnRlcnNlY3RzLlxuICAgIC8vIElmIG5vIGludGVyc2VjdGlvbiBpcyBtYWRlLCByZXR1cm5zIHVuZGVmaW5lZC5cbiAgICBsZWZ0VG9JbmRleChsZWZ0UG9zaXRpb24pIHtcbiAgICAgICAgbGV0IHsgbGVmdHMsIHJpZ2h0cyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGxlbiA9IGxlZnRzLmxlbmd0aDtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKGxlZnRQb3NpdGlvbiA+PSBsZWZ0c1tpXSAmJiBsZWZ0UG9zaXRpb24gPCByaWdodHNbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkOyAvLyBUT0RPOiBiZXR0ZXJcbiAgICB9XG4gICAgLy8gR2l2ZW4gYSB0b3Agb2Zmc2V0IChmcm9tIGRvY3VtZW50IHRvcCksIHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBlbCB0aGF0IGl0IHZlcnRpY2FsbHkgaW50ZXJzZWN0cy5cbiAgICAvLyBJZiBubyBpbnRlcnNlY3Rpb24gaXMgbWFkZSwgcmV0dXJucyB1bmRlZmluZWQuXG4gICAgdG9wVG9JbmRleCh0b3BQb3NpdGlvbikge1xuICAgICAgICBsZXQgeyB0b3BzLCBib3R0b21zIH0gPSB0aGlzO1xuICAgICAgICBsZXQgbGVuID0gdG9wcy5sZW5ndGg7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmICh0b3BQb3NpdGlvbiA+PSB0b3BzW2ldICYmIHRvcFBvc2l0aW9uIDwgYm90dG9tc1tpXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7IC8vIFRPRE86IGJldHRlclxuICAgIH1cbiAgICAvLyBHZXRzIHRoZSB3aWR0aCBvZiB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXhcbiAgICBnZXRXaWR0aChsZWZ0SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmlnaHRzW2xlZnRJbmRleF0gLSB0aGlzLmxlZnRzW2xlZnRJbmRleF07XG4gICAgfVxuICAgIC8vIEdldHMgdGhlIGhlaWdodCBvZiB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXhcbiAgICBnZXRIZWlnaHQodG9wSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm90dG9tc1t0b3BJbmRleF0gLSB0aGlzLnRvcHNbdG9wSW5kZXhdO1xuICAgIH1cbiAgICBzaW1pbGFyVG8ob3RoZXJDYWNoZSkge1xuICAgICAgICByZXR1cm4gc2ltaWxhck51bUFycmF5cyh0aGlzLnRvcHMgfHwgW10sIG90aGVyQ2FjaGUudG9wcyB8fCBbXSkgJiZcbiAgICAgICAgICAgIHNpbWlsYXJOdW1BcnJheXModGhpcy5ib3R0b21zIHx8IFtdLCBvdGhlckNhY2hlLmJvdHRvbXMgfHwgW10pICYmXG4gICAgICAgICAgICBzaW1pbGFyTnVtQXJyYXlzKHRoaXMubGVmdHMgfHwgW10sIG90aGVyQ2FjaGUubGVmdHMgfHwgW10pICYmXG4gICAgICAgICAgICBzaW1pbGFyTnVtQXJyYXlzKHRoaXMucmlnaHRzIHx8IFtdLCBvdGhlckNhY2hlLnJpZ2h0cyB8fCBbXSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2ltaWxhck51bUFycmF5cyhhLCBiKSB7XG4gICAgY29uc3QgbGVuID0gYS5sZW5ndGg7XG4gICAgaWYgKGxlbiAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChNYXRoLnJvdW5kKGFbaV0pICE9PSBNYXRoLnJvdW5kKGJbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qIGVzbGludCBtYXgtY2xhc3Nlcy1wZXItZmlsZTogXCJvZmZcIiAqL1xuLypcbkFuIG9iamVjdCBmb3IgZ2V0dGluZy9zZXR0aW5nIHNjcm9sbC1yZWxhdGVkIGluZm9ybWF0aW9uIGZvciBhbiBlbGVtZW50LlxuSW50ZXJuYWxseSwgdGhpcyBpcyBkb25lIHZlcnkgZGlmZmVyZW50bHkgZm9yIHdpbmRvdyB2ZXJzdXMgRE9NIGVsZW1lbnQsXG5zbyB0aGlzIG9iamVjdCBzZXJ2ZXMgYXMgYSBjb21tb24gaW50ZXJmYWNlLlxuKi9cbmNsYXNzIFNjcm9sbENvbnRyb2xsZXIge1xuICAgIGdldE1heFNjcm9sbFRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2Nyb2xsSGVpZ2h0KCkgLSB0aGlzLmdldENsaWVudEhlaWdodCgpO1xuICAgIH1cbiAgICBnZXRNYXhTY3JvbGxMZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTY3JvbGxXaWR0aCgpIC0gdGhpcy5nZXRDbGllbnRXaWR0aCgpO1xuICAgIH1cbiAgICBjYW5TY3JvbGxWZXJ0aWNhbGx5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRNYXhTY3JvbGxUb3AoKSA+IDA7XG4gICAgfVxuICAgIGNhblNjcm9sbEhvcml6b250YWxseSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWF4U2Nyb2xsTGVmdCgpID4gMDtcbiAgICB9XG4gICAgY2FuU2Nyb2xsVXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNjcm9sbFRvcCgpID4gMDtcbiAgICB9XG4gICAgY2FuU2Nyb2xsRG93bigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2Nyb2xsVG9wKCkgPCB0aGlzLmdldE1heFNjcm9sbFRvcCgpO1xuICAgIH1cbiAgICBjYW5TY3JvbGxMZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTY3JvbGxMZWZ0KCkgPiAwO1xuICAgIH1cbiAgICBjYW5TY3JvbGxSaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2Nyb2xsTGVmdCgpIDwgdGhpcy5nZXRNYXhTY3JvbGxMZWZ0KCk7XG4gICAgfVxufVxuY2xhc3MgRWxlbWVudFNjcm9sbENvbnRyb2xsZXIgZXh0ZW5kcyBTY3JvbGxDb250cm9sbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihlbCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgfVxuICAgIGdldFNjcm9sbFRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuc2Nyb2xsVG9wO1xuICAgIH1cbiAgICBnZXRTY3JvbGxMZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zY3JvbGxMZWZ0O1xuICAgIH1cbiAgICBzZXRTY3JvbGxUb3AodG9wKSB7XG4gICAgICAgIHRoaXMuZWwuc2Nyb2xsVG9wID0gdG9wO1xuICAgIH1cbiAgICBzZXRTY3JvbGxMZWZ0KGxlZnQpIHtcbiAgICAgICAgdGhpcy5lbC5zY3JvbGxMZWZ0ID0gbGVmdDtcbiAgICB9XG4gICAgZ2V0U2Nyb2xsV2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnNjcm9sbFdpZHRoO1xuICAgIH1cbiAgICBnZXRTY3JvbGxIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnNjcm9sbEhlaWdodDtcbiAgICB9XG4gICAgZ2V0Q2xpZW50SGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5jbGllbnRIZWlnaHQ7XG4gICAgfVxuICAgIGdldENsaWVudFdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5jbGllbnRXaWR0aDtcbiAgICB9XG59XG5jbGFzcyBXaW5kb3dTY3JvbGxDb250cm9sbGVyIGV4dGVuZHMgU2Nyb2xsQ29udHJvbGxlciB7XG4gICAgZ2V0U2Nyb2xsVG9wKCkge1xuICAgICAgICByZXR1cm4gd2luZG93LnNjcm9sbFk7XG4gICAgfVxuICAgIGdldFNjcm9sbExlZnQoKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuc2Nyb2xsWDtcbiAgICB9XG4gICAgc2V0U2Nyb2xsVG9wKG4pIHtcbiAgICAgICAgd2luZG93LnNjcm9sbCh3aW5kb3cuc2Nyb2xsWCwgbik7XG4gICAgfVxuICAgIHNldFNjcm9sbExlZnQobikge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsKG4sIHdpbmRvdy5zY3JvbGxZKTtcbiAgICB9XG4gICAgZ2V0U2Nyb2xsV2lkdGgoKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsV2lkdGg7XG4gICAgfVxuICAgIGdldFNjcm9sbEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQ7XG4gICAgfVxuICAgIGdldENsaWVudEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgfVxuICAgIGdldENsaWVudFdpZHRoKCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuICAgIH1cbn1cblxuLypcbmFuIElOVEVSQUNUQUJMRSBkYXRlIGNvbXBvbmVudFxuXG5QVVJQT1NFUzpcbi0gaG9vayB1cCB0byBmZywgZmlsbCwgYW5kIG1pcnJvciByZW5kZXJlcnNcbi0gaW50ZXJmYWNlIGZvciBkcmFnZ2luZyBhbmQgaGl0c1xuKi9cbmNsYXNzIERhdGVDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy51aWQgPSBndWlkKCk7XG4gICAgfVxuICAgIC8vIEhpdCBTeXN0ZW1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHByZXBhcmVIaXRzKCkge1xuICAgIH1cbiAgICBxdWVyeUhpdChwb3NpdGlvbkxlZnQsIHBvc2l0aW9uVG9wLCBlbFdpZHRoLCBlbEhlaWdodCkge1xuICAgICAgICByZXR1cm4gbnVsbDsgLy8gdGhpcyBzaG91bGQgYmUgYWJzdHJhY3RcbiAgICB9XG4gICAgLy8gUG9pbnRlciBJbnRlcmFjdGlvbiBVdGlsc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgaXNWYWxpZFNlZ0Rvd25FbChlbCkge1xuICAgICAgICByZXR1cm4gIXRoaXMucHJvcHMuZXZlbnREcmFnICYmIC8vIEhBQ0tcbiAgICAgICAgICAgICF0aGlzLnByb3BzLmV2ZW50UmVzaXplICYmIC8vIEhBQ0tcbiAgICAgICAgICAgICFlbGVtZW50Q2xvc2VzdChlbCwgJy5mYy1ldmVudC1taXJyb3InKTtcbiAgICB9XG4gICAgaXNWYWxpZERhdGVEb3duRWwoZWwpIHtcbiAgICAgICAgcmV0dXJuICFlbGVtZW50Q2xvc2VzdChlbCwgJy5mYy1ldmVudDpub3QoLmZjLWJnLWV2ZW50KScpICYmXG4gICAgICAgICAgICAhZWxlbWVudENsb3Nlc3QoZWwsICcuZmMtbW9yZS1saW5rJykgJiYgLy8gYSBcIm1vcmUuLlwiIGxpbmtcbiAgICAgICAgICAgICFlbGVtZW50Q2xvc2VzdChlbCwgJ2FbZGF0YS1uYXZsaW5rXScpICYmIC8vIGEgY2xpY2thYmxlIG5hdiBsaW5rXG4gICAgICAgICAgICAhZWxlbWVudENsb3Nlc3QoZWwsICcuZmMtcG9wb3ZlcicpOyAvLyBoYWNrXG4gICAgfVxufVxuXG5jbGFzcyBOYW1lZFRpbWVab25lSW1wbCB7XG4gICAgY29uc3RydWN0b3IodGltZVpvbmVOYW1lKSB7XG4gICAgICAgIHRoaXMudGltZVpvbmVOYW1lID0gdGltZVpvbmVOYW1lO1xuICAgIH1cbn1cblxuY2xhc3MgU2VnSGllcmFyY2h5IHtcbiAgICBjb25zdHJ1Y3RvcihnZXRFbnRyeVRoaWNrbmVzcyA9IChlbnRyeSkgPT4ge1xuICAgICAgICAvLyBpZiBubyB0aGlja25lc3Mga25vd24sIGFzc3VtZSAxIChpZiAwLCBzbyBzbWFsbCBpdCBhbHdheXMgZml0cylcbiAgICAgICAgcmV0dXJuIGVudHJ5LnRoaWNrbmVzcyB8fCAxO1xuICAgIH0pIHtcbiAgICAgICAgdGhpcy5nZXRFbnRyeVRoaWNrbmVzcyA9IGdldEVudHJ5VGhpY2tuZXNzO1xuICAgICAgICAvLyBzZXR0aW5nc1xuICAgICAgICB0aGlzLnN0cmljdE9yZGVyID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWxsb3dSZXNsaWNpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tYXhDb29yZCA9IC0xOyAvLyAtMSBtZWFucyBubyBtYXhcbiAgICAgICAgdGhpcy5tYXhTdGFja0NudCA9IC0xOyAvLyAtMSBtZWFucyBubyBtYXhcbiAgICAgICAgdGhpcy5sZXZlbENvb3JkcyA9IFtdOyAvLyBvcmRlcmVkXG4gICAgICAgIHRoaXMuZW50cmllc0J5TGV2ZWwgPSBbXTsgLy8gcGFyYWxsZWwgd2l0aCBsZXZlbENvb3Jkc1xuICAgICAgICB0aGlzLnN0YWNrQ250cyA9IHt9OyAvLyBUT0RPOiB1c2UgYmV0dGVyIHRlY2huaXF1ZSE/XG4gICAgfVxuICAgIGFkZFNlZ3MoaW5wdXRzKSB7XG4gICAgICAgIGxldCBoaWRkZW5FbnRyaWVzID0gW107XG4gICAgICAgIGZvciAobGV0IGlucHV0IG9mIGlucHV0cykge1xuICAgICAgICAgICAgdGhpcy5pbnNlcnRFbnRyeShpbnB1dCwgaGlkZGVuRW50cmllcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhpZGRlbkVudHJpZXM7XG4gICAgfVxuICAgIGluc2VydEVudHJ5KGVudHJ5LCBoaWRkZW5FbnRyaWVzKSB7XG4gICAgICAgIGxldCBpbnNlcnRpb24gPSB0aGlzLmZpbmRJbnNlcnRpb24oZW50cnkpO1xuICAgICAgICBpZiAodGhpcy5pc0luc2VydGlvblZhbGlkKGluc2VydGlvbiwgZW50cnkpKSB7XG4gICAgICAgICAgICB0aGlzLmluc2VydEVudHJ5QXQoZW50cnksIGluc2VydGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUludmFsaWRJbnNlcnRpb24oaW5zZXJ0aW9uLCBlbnRyeSwgaGlkZGVuRW50cmllcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNJbnNlcnRpb25WYWxpZChpbnNlcnRpb24sIGVudHJ5KSB7XG4gICAgICAgIHJldHVybiAodGhpcy5tYXhDb29yZCA9PT0gLTEgfHwgaW5zZXJ0aW9uLmxldmVsQ29vcmQgKyB0aGlzLmdldEVudHJ5VGhpY2tuZXNzKGVudHJ5KSA8PSB0aGlzLm1heENvb3JkKSAmJlxuICAgICAgICAgICAgKHRoaXMubWF4U3RhY2tDbnQgPT09IC0xIHx8IGluc2VydGlvbi5zdGFja0NudCA8IHRoaXMubWF4U3RhY2tDbnQpO1xuICAgIH1cbiAgICBoYW5kbGVJbnZhbGlkSW5zZXJ0aW9uKGluc2VydGlvbiwgZW50cnksIGhpZGRlbkVudHJpZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuYWxsb3dSZXNsaWNpbmcgJiYgaW5zZXJ0aW9uLnRvdWNoaW5nRW50cnkpIHtcbiAgICAgICAgICAgIGNvbnN0IGhpZGRlbkVudHJ5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBlbnRyeSksIHsgc3BhbjogaW50ZXJzZWN0U3BhbnMoZW50cnkuc3BhbiwgaW5zZXJ0aW9uLnRvdWNoaW5nRW50cnkuc3BhbikgfSk7XG4gICAgICAgICAgICBoaWRkZW5FbnRyaWVzLnB1c2goaGlkZGVuRW50cnkpO1xuICAgICAgICAgICAgdGhpcy5zcGxpdEVudHJ5KGVudHJ5LCBpbnNlcnRpb24udG91Y2hpbmdFbnRyeSwgaGlkZGVuRW50cmllcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoaWRkZW5FbnRyaWVzLnB1c2goZW50cnkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qXG4gICAgRG9lcyBOT1QgYWRkIHdoYXQgaGl0IHRoZSBgYmFycmllcmAgaW50byBoaWRkZW5FbnRyaWVzLiBTaG91bGQgYWxyZWFkeSBiZSBkb25lLlxuICAgICovXG4gICAgc3BsaXRFbnRyeShlbnRyeSwgYmFycmllciwgaGlkZGVuRW50cmllcykge1xuICAgICAgICBsZXQgZW50cnlTcGFuID0gZW50cnkuc3BhbjtcbiAgICAgICAgbGV0IGJhcnJpZXJTcGFuID0gYmFycmllci5zcGFuO1xuICAgICAgICBpZiAoZW50cnlTcGFuLnN0YXJ0IDwgYmFycmllclNwYW4uc3RhcnQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0RW50cnkoe1xuICAgICAgICAgICAgICAgIGluZGV4OiBlbnRyeS5pbmRleCxcbiAgICAgICAgICAgICAgICB0aGlja25lc3M6IGVudHJ5LnRoaWNrbmVzcyxcbiAgICAgICAgICAgICAgICBzcGFuOiB7IHN0YXJ0OiBlbnRyeVNwYW4uc3RhcnQsIGVuZDogYmFycmllclNwYW4uc3RhcnQgfSxcbiAgICAgICAgICAgIH0sIGhpZGRlbkVudHJpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbnRyeVNwYW4uZW5kID4gYmFycmllclNwYW4uZW5kKSB7XG4gICAgICAgICAgICB0aGlzLmluc2VydEVudHJ5KHtcbiAgICAgICAgICAgICAgICBpbmRleDogZW50cnkuaW5kZXgsXG4gICAgICAgICAgICAgICAgdGhpY2tuZXNzOiBlbnRyeS50aGlja25lc3MsXG4gICAgICAgICAgICAgICAgc3BhbjogeyBzdGFydDogYmFycmllclNwYW4uZW5kLCBlbmQ6IGVudHJ5U3Bhbi5lbmQgfSxcbiAgICAgICAgICAgIH0sIGhpZGRlbkVudHJpZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluc2VydEVudHJ5QXQoZW50cnksIGluc2VydGlvbikge1xuICAgICAgICBsZXQgeyBlbnRyaWVzQnlMZXZlbCwgbGV2ZWxDb29yZHMgfSA9IHRoaXM7XG4gICAgICAgIGlmIChpbnNlcnRpb24ubGF0ZXJhbCA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhIG5ldyBsZXZlbFxuICAgICAgICAgICAgaW5zZXJ0QXQobGV2ZWxDb29yZHMsIGluc2VydGlvbi5sZXZlbCwgaW5zZXJ0aW9uLmxldmVsQ29vcmQpO1xuICAgICAgICAgICAgaW5zZXJ0QXQoZW50cmllc0J5TGV2ZWwsIGluc2VydGlvbi5sZXZlbCwgW2VudHJ5XSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBpbnNlcnQgaW50byBleGlzdGluZyBsZXZlbFxuICAgICAgICAgICAgaW5zZXJ0QXQoZW50cmllc0J5TGV2ZWxbaW5zZXJ0aW9uLmxldmVsXSwgaW5zZXJ0aW9uLmxhdGVyYWwsIGVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YWNrQ250c1tidWlsZEVudHJ5S2V5KGVudHJ5KV0gPSBpbnNlcnRpb24uc3RhY2tDbnQ7XG4gICAgfVxuICAgIC8qXG4gICAgZG9lcyBub3QgY2FyZSBhYm91dCBsaW1pdHNcbiAgICAqL1xuICAgIGZpbmRJbnNlcnRpb24obmV3RW50cnkpIHtcbiAgICAgICAgbGV0IHsgbGV2ZWxDb29yZHMsIGVudHJpZXNCeUxldmVsLCBzdHJpY3RPcmRlciwgc3RhY2tDbnRzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgbGV2ZWxDbnQgPSBsZXZlbENvb3Jkcy5sZW5ndGg7XG4gICAgICAgIGxldCBjYW5kaWRhdGVDb29yZCA9IDA7XG4gICAgICAgIGxldCB0b3VjaGluZ0xldmVsID0gLTE7XG4gICAgICAgIGxldCB0b3VjaGluZ0xhdGVyYWwgPSAtMTtcbiAgICAgICAgbGV0IHRvdWNoaW5nRW50cnkgPSBudWxsO1xuICAgICAgICBsZXQgc3RhY2tDbnQgPSAwO1xuICAgICAgICBmb3IgKGxldCB0cmFja2luZ0xldmVsID0gMDsgdHJhY2tpbmdMZXZlbCA8IGxldmVsQ250OyB0cmFja2luZ0xldmVsICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHRyYWNraW5nQ29vcmQgPSBsZXZlbENvb3Jkc1t0cmFja2luZ0xldmVsXTtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBjdXJyZW50IGxldmVsIGlzIHBhc3QgdGhlIHBsYWNlZCBlbnRyeSwgd2UgaGF2ZSBmb3VuZCBhIGdvb2QgZW1wdHkgc3BhY2UgYW5kIGNhbiBzdG9wLlxuICAgICAgICAgICAgLy8gaWYgc3RyaWN0T3JkZXIsIGtlZXAgZmluZGluZyBtb3JlIGxhdGVyYWwgaW50ZXJzZWN0aW9ucy5cbiAgICAgICAgICAgIGlmICghc3RyaWN0T3JkZXIgJiYgdHJhY2tpbmdDb29yZCA+PSBjYW5kaWRhdGVDb29yZCArIHRoaXMuZ2V0RW50cnlUaGlja25lc3MobmV3RW50cnkpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdHJhY2tpbmdFbnRyaWVzID0gZW50cmllc0J5TGV2ZWxbdHJhY2tpbmdMZXZlbF07XG4gICAgICAgICAgICBsZXQgdHJhY2tpbmdFbnRyeTtcbiAgICAgICAgICAgIGxldCBzZWFyY2hSZXMgPSBiaW5hcnlTZWFyY2godHJhY2tpbmdFbnRyaWVzLCBuZXdFbnRyeS5zcGFuLnN0YXJ0LCBnZXRFbnRyeVNwYW5FbmQpOyAvLyBmaW5kIGZpcnN0IGVudHJ5IGFmdGVyIG5ld0VudHJ5J3MgZW5kXG4gICAgICAgICAgICBsZXQgbGF0ZXJhbEluZGV4ID0gc2VhcmNoUmVzWzBdICsgc2VhcmNoUmVzWzFdOyAvLyBpZiBleGFjdCBtYXRjaCAod2hpY2ggZG9lc24ndCBjb2xsaWRlKSwgZ28gdG8gbmV4dCBvbmVcbiAgICAgICAgICAgIHdoaWxlICggLy8gbG9vcCB0aHJvdWdoIGVudHJpZXMgdGhhdCBob3Jpem9udGFsbHkgaW50ZXJzZWN0XG4gICAgICAgICAgICAodHJhY2tpbmdFbnRyeSA9IHRyYWNraW5nRW50cmllc1tsYXRlcmFsSW5kZXhdKSAmJiAvLyBidXQgbm90IHBhc3QgdGhlIHdob2xlIGVudHJ5IGxpc3RcbiAgICAgICAgICAgICAgICB0cmFja2luZ0VudHJ5LnNwYW4uc3RhcnQgPCBuZXdFbnRyeS5zcGFuLmVuZCAvLyBhbmQgbm90IGVudGlyZWx5IHBhc3QgbmV3RW50cnlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGxldCB0cmFja2luZ0VudHJ5Qm90dG9tID0gdHJhY2tpbmdDb29yZCArIHRoaXMuZ2V0RW50cnlUaGlja25lc3ModHJhY2tpbmdFbnRyeSk7XG4gICAgICAgICAgICAgICAgLy8gaW50ZXJzZWN0cyBpbnRvIHRoZSB0b3Agb2YgdGhlIGNhbmRpZGF0ZT9cbiAgICAgICAgICAgICAgICBpZiAodHJhY2tpbmdFbnRyeUJvdHRvbSA+IGNhbmRpZGF0ZUNvb3JkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZUNvb3JkID0gdHJhY2tpbmdFbnRyeUJvdHRvbTtcbiAgICAgICAgICAgICAgICAgICAgdG91Y2hpbmdFbnRyeSA9IHRyYWNraW5nRW50cnk7XG4gICAgICAgICAgICAgICAgICAgIHRvdWNoaW5nTGV2ZWwgPSB0cmFja2luZ0xldmVsO1xuICAgICAgICAgICAgICAgICAgICB0b3VjaGluZ0xhdGVyYWwgPSBsYXRlcmFsSW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGJ1dHRzIHVwIGFnYWluc3QgdG9wIG9mIGNhbmRpZGF0ZT8gKHdpbGwgaGFwcGVuIGlmIGp1c3QgaW50ZXJzZWN0ZWQgYXMgd2VsbClcbiAgICAgICAgICAgICAgICBpZiAodHJhY2tpbmdFbnRyeUJvdHRvbSA9PT0gY2FuZGlkYXRlQ29vcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWNjdW11bGF0ZSB0aGUgaGlnaGVzdCBwb3NzaWJsZSBzdGFja0NudCBvZiB0aGUgdHJhY2tpbmdFbnRyaWVzIHRoYXQgYnV0dCB1cFxuICAgICAgICAgICAgICAgICAgICBzdGFja0NudCA9IE1hdGgubWF4KHN0YWNrQ250LCBzdGFja0NudHNbYnVpbGRFbnRyeUtleSh0cmFja2luZ0VudHJ5KV0gKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGF0ZXJhbEluZGV4ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlIGRlc3RpbmF0aW9uIGxldmVsIHdpbGwgYmUgYWZ0ZXIgdG91Y2hpbmdFbnRyeSdzIGxldmVsLiBmaW5kIGl0XG4gICAgICAgIGxldCBkZXN0TGV2ZWwgPSAwO1xuICAgICAgICBpZiAodG91Y2hpbmdFbnRyeSkge1xuICAgICAgICAgICAgZGVzdExldmVsID0gdG91Y2hpbmdMZXZlbCArIDE7XG4gICAgICAgICAgICB3aGlsZSAoZGVzdExldmVsIDwgbGV2ZWxDbnQgJiYgbGV2ZWxDb29yZHNbZGVzdExldmVsXSA8IGNhbmRpZGF0ZUNvb3JkKSB7XG4gICAgICAgICAgICAgICAgZGVzdExldmVsICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgYWRkaW5nIHRvIGFuIGV4aXN0aW5nIGxldmVsLCBmaW5kIHdoZXJlIHRvIGluc2VydFxuICAgICAgICBsZXQgZGVzdExhdGVyYWwgPSAtMTtcbiAgICAgICAgaWYgKGRlc3RMZXZlbCA8IGxldmVsQ250ICYmIGxldmVsQ29vcmRzW2Rlc3RMZXZlbF0gPT09IGNhbmRpZGF0ZUNvb3JkKSB7XG4gICAgICAgICAgICBkZXN0TGF0ZXJhbCA9IGJpbmFyeVNlYXJjaChlbnRyaWVzQnlMZXZlbFtkZXN0TGV2ZWxdLCBuZXdFbnRyeS5zcGFuLmVuZCwgZ2V0RW50cnlTcGFuRW5kKVswXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG91Y2hpbmdMZXZlbCxcbiAgICAgICAgICAgIHRvdWNoaW5nTGF0ZXJhbCxcbiAgICAgICAgICAgIHRvdWNoaW5nRW50cnksXG4gICAgICAgICAgICBzdGFja0NudCxcbiAgICAgICAgICAgIGxldmVsQ29vcmQ6IGNhbmRpZGF0ZUNvb3JkLFxuICAgICAgICAgICAgbGV2ZWw6IGRlc3RMZXZlbCxcbiAgICAgICAgICAgIGxhdGVyYWw6IGRlc3RMYXRlcmFsLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBzb3J0ZWQgYnkgbGV2ZWxDb29yZCAobG93ZXN0IHRvIGhpZ2hlc3QpXG4gICAgdG9SZWN0cygpIHtcbiAgICAgICAgbGV0IHsgZW50cmllc0J5TGV2ZWwsIGxldmVsQ29vcmRzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgbGV2ZWxDbnQgPSBlbnRyaWVzQnlMZXZlbC5sZW5ndGg7XG4gICAgICAgIGxldCByZWN0cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBsZXZlbCA9IDA7IGxldmVsIDwgbGV2ZWxDbnQ7IGxldmVsICs9IDEpIHtcbiAgICAgICAgICAgIGxldCBlbnRyaWVzID0gZW50cmllc0J5TGV2ZWxbbGV2ZWxdO1xuICAgICAgICAgICAgbGV0IGxldmVsQ29vcmQgPSBsZXZlbENvb3Jkc1tsZXZlbF07XG4gICAgICAgICAgICBmb3IgKGxldCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgcmVjdHMucHVzaChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGVudHJ5KSwgeyB0aGlja25lc3M6IHRoaXMuZ2V0RW50cnlUaGlja25lc3MoZW50cnkpLCBsZXZlbENvb3JkIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVjdHM7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0RW50cnlTcGFuRW5kKGVudHJ5KSB7XG4gICAgcmV0dXJuIGVudHJ5LnNwYW4uZW5kO1xufVxuZnVuY3Rpb24gYnVpbGRFbnRyeUtleShlbnRyeSkge1xuICAgIHJldHVybiBlbnRyeS5pbmRleCArICc6JyArIGVudHJ5LnNwYW4uc3RhcnQ7XG59XG4vLyByZXR1cm5zIGdyb3VwcyB3aXRoIGVudHJpZXMgc29ydGVkIGJ5IGlucHV0IG9yZGVyXG5mdW5jdGlvbiBncm91cEludGVyc2VjdGluZ0VudHJpZXMoZW50cmllcykge1xuICAgIGxldCBtZXJnZXMgPSBbXTtcbiAgICBmb3IgKGxldCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICAgIGxldCBmaWx0ZXJlZE1lcmdlcyA9IFtdO1xuICAgICAgICBsZXQgaHVuZ3J5TWVyZ2UgPSB7XG4gICAgICAgICAgICBzcGFuOiBlbnRyeS5zcGFuLFxuICAgICAgICAgICAgZW50cmllczogW2VudHJ5XSxcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgbWVyZ2Ugb2YgbWVyZ2VzKSB7XG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0U3BhbnMobWVyZ2Uuc3BhbiwgaHVuZ3J5TWVyZ2Uuc3BhbikpIHtcbiAgICAgICAgICAgICAgICBodW5ncnlNZXJnZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgZW50cmllczogbWVyZ2UuZW50cmllcy5jb25jYXQoaHVuZ3J5TWVyZ2UuZW50cmllcyksXG4gICAgICAgICAgICAgICAgICAgIHNwYW46IGpvaW5TcGFucyhtZXJnZS5zcGFuLCBodW5ncnlNZXJnZS5zcGFuKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyZWRNZXJnZXMucHVzaChtZXJnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmlsdGVyZWRNZXJnZXMucHVzaChodW5ncnlNZXJnZSk7XG4gICAgICAgIG1lcmdlcyA9IGZpbHRlcmVkTWVyZ2VzO1xuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VzO1xufVxuZnVuY3Rpb24gam9pblNwYW5zKHNwYW4wLCBzcGFuMSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiBNYXRoLm1pbihzcGFuMC5zdGFydCwgc3BhbjEuc3RhcnQpLFxuICAgICAgICBlbmQ6IE1hdGgubWF4KHNwYW4wLmVuZCwgc3BhbjEuZW5kKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gaW50ZXJzZWN0U3BhbnMoc3BhbjAsIHNwYW4xKSB7XG4gICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgoc3BhbjAuc3RhcnQsIHNwYW4xLnN0YXJ0KTtcbiAgICBsZXQgZW5kID0gTWF0aC5taW4oc3BhbjAuZW5kLCBzcGFuMS5lbmQpO1xuICAgIGlmIChzdGFydCA8IGVuZCkge1xuICAgICAgICByZXR1cm4geyBzdGFydCwgZW5kIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLy8gZ2VuZXJhbCB1dGlsXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGluc2VydEF0KGFyciwgaW5kZXgsIGl0ZW0pIHtcbiAgICBhcnIuc3BsaWNlKGluZGV4LCAwLCBpdGVtKTtcbn1cbmZ1bmN0aW9uIGJpbmFyeVNlYXJjaChhLCBzZWFyY2hWYWwsIGdldEl0ZW1WYWwpIHtcbiAgICBsZXQgc3RhcnRJbmRleCA9IDA7XG4gICAgbGV0IGVuZEluZGV4ID0gYS5sZW5ndGg7IC8vIGV4Y2x1c2l2ZVxuICAgIGlmICghZW5kSW5kZXggfHwgc2VhcmNoVmFsIDwgZ2V0SXRlbVZhbChhW3N0YXJ0SW5kZXhdKSkgeyAvLyBubyBpdGVtcyBPUiBiZWZvcmUgZmlyc3QgaXRlbVxuICAgICAgICByZXR1cm4gWzAsIDBdO1xuICAgIH1cbiAgICBpZiAoc2VhcmNoVmFsID4gZ2V0SXRlbVZhbChhW2VuZEluZGV4IC0gMV0pKSB7IC8vIGFmdGVyIGxhc3QgaXRlbVxuICAgICAgICByZXR1cm4gW2VuZEluZGV4LCAwXTtcbiAgICB9XG4gICAgd2hpbGUgKHN0YXJ0SW5kZXggPCBlbmRJbmRleCkge1xuICAgICAgICBsZXQgbWlkZGxlSW5kZXggPSBNYXRoLmZsb29yKHN0YXJ0SW5kZXggKyAoZW5kSW5kZXggLSBzdGFydEluZGV4KSAvIDIpO1xuICAgICAgICBsZXQgbWlkZGxlVmFsID0gZ2V0SXRlbVZhbChhW21pZGRsZUluZGV4XSk7XG4gICAgICAgIGlmIChzZWFyY2hWYWwgPCBtaWRkbGVWYWwpIHtcbiAgICAgICAgICAgIGVuZEluZGV4ID0gbWlkZGxlSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2VhcmNoVmFsID4gbWlkZGxlVmFsKSB7XG4gICAgICAgICAgICBzdGFydEluZGV4ID0gbWlkZGxlSW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBlcXVhbCFcbiAgICAgICAgICAgIHJldHVybiBbbWlkZGxlSW5kZXgsIDFdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbc3RhcnRJbmRleCwgMF07XG59XG5cbi8qXG5BbiBhYnN0cmFjdGlvbiBmb3IgYSBkcmFnZ2luZyBpbnRlcmFjdGlvbiBvcmlnaW5hdGluZyBvbiBhbiBldmVudC5cbkRvZXMgaGlnaGVyLWxldmVsIHRoaW5ncyB0aGFuIFBvaW50ZXJEcmFnZ2VyLCBzdWNoIGFzIHBvc3NpYmx5OlxuLSBhIFwibWlycm9yXCIgdGhhdCBtb3ZlcyB3aXRoIHRoZSBwb2ludGVyXG4tIGEgbWluaW11bSBudW1iZXIgb2YgcGl4ZWxzIG9yIG90aGVyIGNyaXRlcmlhIGZvciBhIHRydWUgZHJhZyB0byBiZWdpblxuXG5zdWJjbGFzc2VzIG11c3QgZW1pdDpcbi0gcG9pbnRlcmRvd25cbi0gZHJhZ3N0YXJ0XG4tIGRyYWdtb3ZlXG4tIHBvaW50ZXJ1cFxuLSBkcmFnZW5kXG4qL1xuY2xhc3MgRWxlbWVudERyYWdnaW5nIHtcbiAgICBjb25zdHJ1Y3RvcihlbCwgc2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICB9XG4gICAgc2V0TWlycm9ySXNWaXNpYmxlKGJvb2wpIHtcbiAgICAgICAgLy8gb3B0aW9uYWwgaWYgc3ViY2xhc3MgZG9lc24ndCB3YW50IHRvIHN1cHBvcnQgYSBtaXJyb3JcbiAgICB9XG4gICAgc2V0TWlycm9yTmVlZHNSZXZlcnQoYm9vbCkge1xuICAgICAgICAvLyBvcHRpb25hbCBpZiBzdWJjbGFzcyBkb2Vzbid0IHdhbnQgdG8gc3VwcG9ydCBhIG1pcnJvclxuICAgIH1cbiAgICBzZXRBdXRvU2Nyb2xsRW5hYmxlZChib29sKSB7XG4gICAgICAgIC8vIG9wdGlvbmFsXG4gICAgfVxufVxuXG4vLyBUT0RPOiBnZXQgcmlkIG9mIHRoaXMgaW4gZmF2b3Igb2Ygb3B0aW9ucyBzeXN0ZW0sXG4vLyB0aG8gaXQncyByZWFsbHkgZWFzeSB0byBhY2Nlc3MgdGhpcyBnbG9iYWxseSByYXRoZXIgdGhhbiBwYXNzIHRocnUgb3B0aW9ucy5cbmNvbnN0IGNvbmZpZyA9IHt9O1xuXG4vKlxuSW5mb3JtYXRpb24gYWJvdXQgd2hhdCB3aWxsIGhhcHBlbiB3aGVuIGFuIGV4dGVybmFsIGVsZW1lbnQgaXMgZHJhZ2dlZC1hbmQtZHJvcHBlZFxub250byBhIGNhbGVuZGFyLiBDb250YWlucyBpbmZvcm1hdGlvbiBmb3IgY3JlYXRpbmcgYW4gZXZlbnQuXG4qL1xuY29uc3QgRFJBR19NRVRBX1JFRklORVJTID0ge1xuICAgIHN0YXJ0VGltZTogY3JlYXRlRHVyYXRpb24sXG4gICAgZHVyYXRpb246IGNyZWF0ZUR1cmF0aW9uLFxuICAgIGNyZWF0ZTogQm9vbGVhbixcbiAgICBzb3VyY2VJZDogU3RyaW5nLFxufTtcbmZ1bmN0aW9uIHBhcnNlRHJhZ01ldGEocmF3KSB7XG4gICAgbGV0IHsgcmVmaW5lZCwgZXh0cmEgfSA9IHJlZmluZVByb3BzKHJhdywgRFJBR19NRVRBX1JFRklORVJTKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydFRpbWU6IHJlZmluZWQuc3RhcnRUaW1lIHx8IG51bGwsXG4gICAgICAgIGR1cmF0aW9uOiByZWZpbmVkLmR1cmF0aW9uIHx8IG51bGwsXG4gICAgICAgIGNyZWF0ZTogcmVmaW5lZC5jcmVhdGUgIT0gbnVsbCA/IHJlZmluZWQuY3JlYXRlIDogdHJ1ZSxcbiAgICAgICAgc291cmNlSWQ6IHJlZmluZWQuc291cmNlSWQsXG4gICAgICAgIGxlZnRvdmVyUHJvcHM6IGV4dHJhLFxuICAgIH07XG59XG5cbi8vIENvbXB1dGVzIGEgZGVmYXVsdCBjb2x1bW4gaGVhZGVyIGZvcm1hdHRpbmcgc3RyaW5nIGlmIGBjb2xGb3JtYXRgIGlzIG5vdCBleHBsaWNpdGx5IGRlZmluZWRcbmZ1bmN0aW9uIGNvbXB1dGVGYWxsYmFja0hlYWRlckZvcm1hdChkYXRlc1JlcERpc3RpbmN0RGF5cywgZGF5Q250KSB7XG4gICAgLy8gaWYgbW9yZSB0aGFuIG9uZSB3ZWVrIHJvdywgb3IgaWYgdGhlcmUgYXJlIGEgbG90IG9mIGNvbHVtbnMgd2l0aCBub3QgbXVjaCBzcGFjZSxcbiAgICAvLyBwdXQganVzdCB0aGUgZGF5IG51bWJlcnMgd2lsbCBiZSBpbiBlYWNoIGNlbGxcbiAgICBpZiAoIWRhdGVzUmVwRGlzdGluY3REYXlzIHx8IGRheUNudCA+IDEwKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVGb3JtYXR0ZXIoeyB3ZWVrZGF5OiAnc2hvcnQnIH0pOyAvLyBcIlNhdFwiXG4gICAgfVxuICAgIGlmIChkYXlDbnQgPiAxKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVGb3JtYXR0ZXIoeyB3ZWVrZGF5OiAnc2hvcnQnLCBtb250aDogJ251bWVyaWMnLCBkYXk6ICdudW1lcmljJywgb21pdENvbW1hczogdHJ1ZSB9KTsgLy8gXCJTYXQgMTEvMTJcIlxuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlRm9ybWF0dGVyKHsgd2Vla2RheTogJ2xvbmcnIH0pOyAvLyBcIlNhdHVyZGF5XCJcbn1cblxuY29uc3QgQ0xBU1NfTkFNRSA9ICdmYy1jb2wtaGVhZGVyLWNlbGwnOyAvLyBkbyB0aGUgY3VzaGlvbiB0b28/IG5vXG5mdW5jdGlvbiByZW5kZXJJbm5lciQxKHJlbmRlclByb3BzKSB7XG4gICAgcmV0dXJuIHJlbmRlclByb3BzLnRleHQ7XG59XG5cbi8vIEJBRCBuYW1lIGZvciB0aGlzIGNsYXNzIG5vdy4gdXNlZCBpbiB0aGUgSGVhZGVyXG5jbGFzcyBUYWJsZURhdGVDZWxsIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBkYXRlRW52LCBvcHRpb25zLCB0aGVtZSwgdmlld0FwaSB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgZGF0ZSwgZGF0ZVByb2ZpbGUgfSA9IHByb3BzO1xuICAgICAgICBsZXQgZGF5TWV0YSA9IGdldERhdGVNZXRhKGRhdGUsIHByb3BzLnRvZGF5UmFuZ2UsIG51bGwsIGRhdGVQcm9maWxlKTtcbiAgICAgICAgbGV0IGNsYXNzTmFtZXMgPSBbQ0xBU1NfTkFNRV0uY29uY2F0KGdldERheUNsYXNzTmFtZXMoZGF5TWV0YSwgdGhlbWUpKTtcbiAgICAgICAgbGV0IHRleHQgPSBkYXRlRW52LmZvcm1hdChkYXRlLCBwcm9wcy5kYXlIZWFkZXJGb3JtYXQpO1xuICAgICAgICAvLyBpZiBjb2xDbnQgaXMgMSwgd2UgYXJlIGFscmVhZHkgaW4gYSBkYXktdmlldyBhbmQgZG9uJ3QgbmVlZCBhIG5hdmxpbmtcbiAgICAgICAgbGV0IG5hdkxpbmtBdHRycyA9ICghZGF5TWV0YS5pc0Rpc2FibGVkICYmIHByb3BzLmNvbENudCA+IDEpXG4gICAgICAgICAgICA/IGJ1aWxkTmF2TGlua0F0dHJzKHRoaXMuY29udGV4dCwgZGF0ZSlcbiAgICAgICAgICAgIDoge307XG4gICAgICAgIGxldCByZW5kZXJQcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgZGF0ZTogZGF0ZUVudi50b0RhdGUoZGF0ZSksIHZpZXc6IHZpZXdBcGkgfSwgcHJvcHMuZXh0cmFSZW5kZXJQcm9wcyksIHsgdGV4dCB9KSwgZGF5TWV0YSk7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChDb250ZW50Q29udGFpbmVyLCB7IGVsVGFnOiBcInRoXCIsIGVsQ2xhc3NlczogY2xhc3NOYW1lcywgZWxBdHRyczogT2JqZWN0LmFzc2lnbih7IHJvbGU6ICdjb2x1bW5oZWFkZXInLCBjb2xTcGFuOiBwcm9wcy5jb2xTcGFuLCAnZGF0YS1kYXRlJzogIWRheU1ldGEuaXNEaXNhYmxlZCA/IGZvcm1hdERheVN0cmluZyhkYXRlKSA6IHVuZGVmaW5lZCB9LCBwcm9wcy5leHRyYURhdGFBdHRycyksIHJlbmRlclByb3BzOiByZW5kZXJQcm9wcywgZ2VuZXJhdG9yTmFtZTogXCJkYXlIZWFkZXJDb250ZW50XCIsIGN1c3RvbUdlbmVyYXRvcjogb3B0aW9ucy5kYXlIZWFkZXJDb250ZW50LCBkZWZhdWx0R2VuZXJhdG9yOiByZW5kZXJJbm5lciQxLCBjbGFzc05hbWVHZW5lcmF0b3I6IG9wdGlvbnMuZGF5SGVhZGVyQ2xhc3NOYW1lcywgZGlkTW91bnQ6IG9wdGlvbnMuZGF5SGVhZGVyRGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLmRheUhlYWRlcldpbGxVbm1vdW50IH0sIChJbm5lckNvbnRhaW5lcikgPT4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtc2Nyb2xsZ3JpZC1zeW5jLWlubmVyXCIgfSwgIWRheU1ldGEuaXNEaXNhYmxlZCAmJiAoY3JlYXRlRWxlbWVudChJbm5lckNvbnRhaW5lciwgeyBlbFRhZzogXCJhXCIsIGVsQXR0cnM6IG5hdkxpbmtBdHRycywgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgJ2ZjLWNvbC1oZWFkZXItY2VsbC1jdXNoaW9uJyxcbiAgICAgICAgICAgICAgICBwcm9wcy5pc1N0aWNreSAmJiAnZmMtc3RpY2t5JyxcbiAgICAgICAgICAgIF0gfSkpKSkpKTtcbiAgICB9XG59XG5cbmNvbnN0IFdFRUtEQVlfRk9STUFUID0gY3JlYXRlRm9ybWF0dGVyKHsgd2Vla2RheTogJ2xvbmcnIH0pO1xuY2xhc3MgVGFibGVEb3dDZWxsIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgZGF0ZUVudiwgdGhlbWUsIHZpZXdBcGksIG9wdGlvbnMgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IGRhdGUgPSBhZGREYXlzKG5ldyBEYXRlKDI1OTIwMDAwMCksIHByb3BzLmRvdyk7IC8vIHN0YXJ0IHdpdGggU3VuLCAwNCBKYW4gMTk3MCAwMDowMDowMCBHTVRcbiAgICAgICAgbGV0IGRhdGVNZXRhID0ge1xuICAgICAgICAgICAgZG93OiBwcm9wcy5kb3csXG4gICAgICAgICAgICBpc0Rpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGlzRnV0dXJlOiBmYWxzZSxcbiAgICAgICAgICAgIGlzUGFzdDogZmFsc2UsXG4gICAgICAgICAgICBpc1RvZGF5OiBmYWxzZSxcbiAgICAgICAgICAgIGlzT3RoZXI6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgdGV4dCA9IGRhdGVFbnYuZm9ybWF0KGRhdGUsIHByb3BzLmRheUhlYWRlckZvcm1hdCk7XG4gICAgICAgIGxldCByZW5kZXJQcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyAvLyBUT0RPOiBtYWtlIHRoaXMgcHVibGljP1xuICAgICAgICAgICAgZGF0ZSB9LCBkYXRlTWV0YSksIHsgdmlldzogdmlld0FwaSB9KSwgcHJvcHMuZXh0cmFSZW5kZXJQcm9wcyksIHsgdGV4dCB9KTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KENvbnRlbnRDb250YWluZXIsIHsgZWxUYWc6IFwidGhcIiwgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgQ0xBU1NfTkFNRSxcbiAgICAgICAgICAgICAgICAuLi5nZXREYXlDbGFzc05hbWVzKGRhdGVNZXRhLCB0aGVtZSksXG4gICAgICAgICAgICAgICAgLi4uKHByb3BzLmV4dHJhQ2xhc3NOYW1lcyB8fCBbXSksXG4gICAgICAgICAgICBdLCBlbEF0dHJzOiBPYmplY3QuYXNzaWduKHsgcm9sZTogJ2NvbHVtbmhlYWRlcicsIGNvbFNwYW46IHByb3BzLmNvbFNwYW4gfSwgcHJvcHMuZXh0cmFEYXRhQXR0cnMpLCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGdlbmVyYXRvck5hbWU6IFwiZGF5SGVhZGVyQ29udGVudFwiLCBjdXN0b21HZW5lcmF0b3I6IG9wdGlvbnMuZGF5SGVhZGVyQ29udGVudCwgZGVmYXVsdEdlbmVyYXRvcjogcmVuZGVySW5uZXIkMSwgY2xhc3NOYW1lR2VuZXJhdG9yOiBvcHRpb25zLmRheUhlYWRlckNsYXNzTmFtZXMsIGRpZE1vdW50OiBvcHRpb25zLmRheUhlYWRlckRpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy5kYXlIZWFkZXJXaWxsVW5tb3VudCB9LCAoSW5uZXJDb250ZW50KSA9PiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1zY3JvbGxncmlkLXN5bmMtaW5uZXJcIiB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChJbm5lckNvbnRlbnQsIHsgZWxUYWc6IFwiYVwiLCBlbENsYXNzZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2ZjLWNvbC1oZWFkZXItY2VsbC1jdXNoaW9uJyxcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuaXNTdGlja3kgJiYgJ2ZjLXN0aWNreScsXG4gICAgICAgICAgICAgICAgXSwgZWxBdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAnYXJpYS1sYWJlbCc6IGRhdGVFbnYuZm9ybWF0KGRhdGUsIFdFRUtEQVlfRk9STUFUKSxcbiAgICAgICAgICAgICAgICB9IH0pKSkpKTtcbiAgICB9XG59XG5cbmNsYXNzIE5vd1RpbWVyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcywgY29udGV4dCkge1xuICAgICAgICBzdXBlcihwcm9wcywgY29udGV4dCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbE5vd0RhdGUgPSBnZXROb3coY29udGV4dC5vcHRpb25zLm5vdywgY29udGV4dC5kYXRlRW52KTtcbiAgICAgICAgdGhpcy5pbml0aWFsTm93UXVlcmllZE1zID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLmNvbXB1dGVUaW1pbmcoKS5jdXJyZW50U3RhdGU7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIHN0YXRlIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gcHJvcHMuY2hpbGRyZW4oc3RhdGUubm93RGF0ZSwgc3RhdGUudG9kYXlSYW5nZSk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLnNldFRpbWVvdXQoKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgICBpZiAocHJldlByb3BzLnVuaXQgIT09IHRoaXMucHJvcHMudW5pdCkge1xuICAgICAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0VGltZW91dCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICAgIH1cbiAgICBjb21wdXRlVGltaW5nKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHVucm91bmRlZE5vdyA9IGFkZE1zKHRoaXMuaW5pdGlhbE5vd0RhdGUsIG5ldyBEYXRlKCkudmFsdWVPZigpIC0gdGhpcy5pbml0aWFsTm93UXVlcmllZE1zKTtcbiAgICAgICAgbGV0IGN1cnJlbnRVbml0U3RhcnQgPSBjb250ZXh0LmRhdGVFbnYuc3RhcnRPZih1bnJvdW5kZWROb3csIHByb3BzLnVuaXQpO1xuICAgICAgICBsZXQgbmV4dFVuaXRTdGFydCA9IGNvbnRleHQuZGF0ZUVudi5hZGQoY3VycmVudFVuaXRTdGFydCwgY3JlYXRlRHVyYXRpb24oMSwgcHJvcHMudW5pdCkpO1xuICAgICAgICBsZXQgd2FpdE1zID0gbmV4dFVuaXRTdGFydC52YWx1ZU9mKCkgLSB1bnJvdW5kZWROb3cudmFsdWVPZigpO1xuICAgICAgICAvLyB0aGVyZSBpcyBhIG1heCBzZXRUaW1lb3V0IG1zIHZhbHVlIChodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzQ2ODY1MC85NjM0MilcbiAgICAgICAgLy8gZW5zdXJlIG5vIGxvbmdlciB0aGFuIGEgZGF5XG4gICAgICAgIHdhaXRNcyA9IE1hdGgubWluKDEwMDAgKiA2MCAqIDYwICogMjQsIHdhaXRNcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjdXJyZW50U3RhdGU6IHsgbm93RGF0ZTogY3VycmVudFVuaXRTdGFydCwgdG9kYXlSYW5nZTogYnVpbGREYXlSYW5nZShjdXJyZW50VW5pdFN0YXJ0KSB9LFxuICAgICAgICAgICAgbmV4dFN0YXRlOiB7IG5vd0RhdGU6IG5leHRVbml0U3RhcnQsIHRvZGF5UmFuZ2U6IGJ1aWxkRGF5UmFuZ2UobmV4dFVuaXRTdGFydCkgfSxcbiAgICAgICAgICAgIHdhaXRNcyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc2V0VGltZW91dCgpIHtcbiAgICAgICAgbGV0IHsgbmV4dFN0YXRlLCB3YWl0TXMgfSA9IHRoaXMuY29tcHV0ZVRpbWluZygpO1xuICAgICAgICB0aGlzLnRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZShuZXh0U3RhdGUsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFRpbWVvdXQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCB3YWl0TXMpO1xuICAgIH1cbiAgICBjbGVhclRpbWVvdXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVvdXRJZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dElkKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbk5vd1RpbWVyLmNvbnRleHRUeXBlID0gVmlld0NvbnRleHRUeXBlO1xuZnVuY3Rpb24gYnVpbGREYXlSYW5nZShkYXRlKSB7XG4gICAgbGV0IHN0YXJ0ID0gc3RhcnRPZkRheShkYXRlKTtcbiAgICBsZXQgZW5kID0gYWRkRGF5cyhzdGFydCwgMSk7XG4gICAgcmV0dXJuIHsgc3RhcnQsIGVuZCB9O1xufVxuXG5jbGFzcyBEYXlIZWFkZXIgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5jcmVhdGVEYXlIZWFkZXJGb3JtYXR0ZXIgPSBtZW1vaXplKGNyZWF0ZURheUhlYWRlckZvcm1hdHRlcik7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgZGF0ZXMsIGRhdGVQcm9maWxlLCBkYXRlc1JlcERpc3RpbmN0RGF5cywgcmVuZGVySW50cm8gfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCBkYXlIZWFkZXJGb3JtYXQgPSB0aGlzLmNyZWF0ZURheUhlYWRlckZvcm1hdHRlcihjb250ZXh0Lm9wdGlvbnMuZGF5SGVhZGVyRm9ybWF0LCBkYXRlc1JlcERpc3RpbmN0RGF5cywgZGF0ZXMubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KE5vd1RpbWVyLCB7IHVuaXQ6IFwiZGF5XCIgfSwgKG5vd0RhdGUsIHRvZGF5UmFuZ2UpID0+IChjcmVhdGVFbGVtZW50KFwidHJcIiwgeyByb2xlOiBcInJvd1wiIH0sXG4gICAgICAgICAgICByZW5kZXJJbnRybyAmJiByZW5kZXJJbnRybygnZGF5JyksXG4gICAgICAgICAgICBkYXRlcy5tYXAoKGRhdGUpID0+IChkYXRlc1JlcERpc3RpbmN0RGF5cyA/IChjcmVhdGVFbGVtZW50KFRhYmxlRGF0ZUNlbGwsIHsga2V5OiBkYXRlLnRvSVNPU3RyaW5nKCksIGRhdGU6IGRhdGUsIGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogdG9kYXlSYW5nZSwgY29sQ250OiBkYXRlcy5sZW5ndGgsIGRheUhlYWRlckZvcm1hdDogZGF5SGVhZGVyRm9ybWF0IH0pKSA6IChjcmVhdGVFbGVtZW50KFRhYmxlRG93Q2VsbCwgeyBrZXk6IGRhdGUuZ2V0VVRDRGF5KCksIGRvdzogZGF0ZS5nZXRVVENEYXkoKSwgZGF5SGVhZGVyRm9ybWF0OiBkYXlIZWFkZXJGb3JtYXQgfSkpKSkpKSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZURheUhlYWRlckZvcm1hdHRlcihleHBsaWNpdEZvcm1hdCwgZGF0ZXNSZXBEaXN0aW5jdERheXMsIGRhdGVDbnQpIHtcbiAgICByZXR1cm4gZXhwbGljaXRGb3JtYXQgfHwgY29tcHV0ZUZhbGxiYWNrSGVhZGVyRm9ybWF0KGRhdGVzUmVwRGlzdGluY3REYXlzLCBkYXRlQ250KTtcbn1cblxuY2xhc3MgRGF5U2VyaWVzTW9kZWwge1xuICAgIGNvbnN0cnVjdG9yKHJhbmdlLCBkYXRlUHJvZmlsZUdlbmVyYXRvcikge1xuICAgICAgICBsZXQgZGF0ZSA9IHJhbmdlLnN0YXJ0O1xuICAgICAgICBsZXQgeyBlbmQgfSA9IHJhbmdlO1xuICAgICAgICBsZXQgaW5kaWNlcyA9IFtdO1xuICAgICAgICBsZXQgZGF0ZXMgPSBbXTtcbiAgICAgICAgbGV0IGRheUluZGV4ID0gLTE7XG4gICAgICAgIHdoaWxlIChkYXRlIDwgZW5kKSB7IC8vIGxvb3AgZWFjaCBkYXkgZnJvbSBzdGFydCB0byBlbmRcbiAgICAgICAgICAgIGlmIChkYXRlUHJvZmlsZUdlbmVyYXRvci5pc0hpZGRlbkRheShkYXRlKSkge1xuICAgICAgICAgICAgICAgIGluZGljZXMucHVzaChkYXlJbmRleCArIDAuNSk7IC8vIG1hcmsgdGhhdCBpdCdzIGJldHdlZW4gaW5kaWNlc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF5SW5kZXggKz0gMTtcbiAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2goZGF5SW5kZXgpO1xuICAgICAgICAgICAgICAgIGRhdGVzLnB1c2goZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRlID0gYWRkRGF5cyhkYXRlLCAxKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGVzID0gZGF0ZXM7XG4gICAgICAgIHRoaXMuaW5kaWNlcyA9IGluZGljZXM7XG4gICAgICAgIHRoaXMuY250ID0gZGF0ZXMubGVuZ3RoO1xuICAgIH1cbiAgICBzbGljZVJhbmdlKHJhbmdlKSB7XG4gICAgICAgIGxldCBmaXJzdEluZGV4ID0gdGhpcy5nZXREYXRlRGF5SW5kZXgocmFuZ2Uuc3RhcnQpOyAvLyBpbmNsdXNpdmUgZmlyc3QgaW5kZXhcbiAgICAgICAgbGV0IGxhc3RJbmRleCA9IHRoaXMuZ2V0RGF0ZURheUluZGV4KGFkZERheXMocmFuZ2UuZW5kLCAtMSkpOyAvLyBpbmNsdXNpdmUgbGFzdCBpbmRleFxuICAgICAgICBsZXQgY2xpcHBlZEZpcnN0SW5kZXggPSBNYXRoLm1heCgwLCBmaXJzdEluZGV4KTtcbiAgICAgICAgbGV0IGNsaXBwZWRMYXN0SW5kZXggPSBNYXRoLm1pbih0aGlzLmNudCAtIDEsIGxhc3RJbmRleCk7XG4gICAgICAgIC8vIGRlYWwgd2l0aCBpbi1iZXR3ZWVuIGluZGljZXNcbiAgICAgICAgY2xpcHBlZEZpcnN0SW5kZXggPSBNYXRoLmNlaWwoY2xpcHBlZEZpcnN0SW5kZXgpOyAvLyBpbi1iZXR3ZWVuIHN0YXJ0cyByb3VuZCB0byBuZXh0IGNlbGxcbiAgICAgICAgY2xpcHBlZExhc3RJbmRleCA9IE1hdGguZmxvb3IoY2xpcHBlZExhc3RJbmRleCk7IC8vIGluLWJldHdlZW4gZW5kcyByb3VuZCB0byBwcmV2IGNlbGxcbiAgICAgICAgaWYgKGNsaXBwZWRGaXJzdEluZGV4IDw9IGNsaXBwZWRMYXN0SW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZmlyc3RJbmRleDogY2xpcHBlZEZpcnN0SW5kZXgsXG4gICAgICAgICAgICAgICAgbGFzdEluZGV4OiBjbGlwcGVkTGFzdEluZGV4LFxuICAgICAgICAgICAgICAgIGlzU3RhcnQ6IGZpcnN0SW5kZXggPT09IGNsaXBwZWRGaXJzdEluZGV4LFxuICAgICAgICAgICAgICAgIGlzRW5kOiBsYXN0SW5kZXggPT09IGNsaXBwZWRMYXN0SW5kZXgsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBHaXZlbiBhIGRhdGUsIHJldHVybnMgaXRzIGNocm9ub2xvY2lhbCBjZWxsLWluZGV4IGZyb20gdGhlIGZpcnN0IGNlbGwgb2YgdGhlIGdyaWQuXG4gICAgLy8gSWYgdGhlIGRhdGUgbGllcyBiZXR3ZWVuIGNlbGxzIChiZWNhdXNlIG9mIGhpZGRlbkRheXMpLCByZXR1cm5zIGEgZmxvYXRpbmctcG9pbnQgdmFsdWUgYmV0d2VlbiBvZmZzZXRzLlxuICAgIC8vIElmIGJlZm9yZSB0aGUgZmlyc3Qgb2Zmc2V0LCByZXR1cm5zIGEgbmVnYXRpdmUgbnVtYmVyLlxuICAgIC8vIElmIGFmdGVyIHRoZSBsYXN0IG9mZnNldCwgcmV0dXJucyBhbiBvZmZzZXQgcGFzdCB0aGUgbGFzdCBjZWxsIG9mZnNldC5cbiAgICAvLyBPbmx5IHdvcmtzIGZvciAqc3RhcnQqIGRhdGVzIG9mIGNlbGxzLiBXaWxsIG5vdCB3b3JrIGZvciBleGNsdXNpdmUgZW5kIGRhdGVzIGZvciBjZWxscy5cbiAgICBnZXREYXRlRGF5SW5kZXgoZGF0ZSkge1xuICAgICAgICBsZXQgeyBpbmRpY2VzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgZGF5T2Zmc2V0ID0gTWF0aC5mbG9vcihkaWZmRGF5cyh0aGlzLmRhdGVzWzBdLCBkYXRlKSk7XG4gICAgICAgIGlmIChkYXlPZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5kaWNlc1swXSAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRheU9mZnNldCA+PSBpbmRpY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSAxXSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGljZXNbZGF5T2Zmc2V0XTtcbiAgICB9XG59XG5cbmNsYXNzIERheVRhYmxlTW9kZWwge1xuICAgIGNvbnN0cnVjdG9yKGRheVNlcmllcywgYnJlYWtPbldlZWtzKSB7XG4gICAgICAgIGxldCB7IGRhdGVzIH0gPSBkYXlTZXJpZXM7XG4gICAgICAgIGxldCBkYXlzUGVyUm93O1xuICAgICAgICBsZXQgZmlyc3REYXk7XG4gICAgICAgIGxldCByb3dDbnQ7XG4gICAgICAgIGlmIChicmVha09uV2Vla3MpIHtcbiAgICAgICAgICAgIC8vIGNvdW50IGNvbHVtbnMgdW50aWwgdGhlIGRheS1vZi13ZWVrIHJlcGVhdHNcbiAgICAgICAgICAgIGZpcnN0RGF5ID0gZGF0ZXNbMF0uZ2V0VVRDRGF5KCk7XG4gICAgICAgICAgICBmb3IgKGRheXNQZXJSb3cgPSAxOyBkYXlzUGVyUm93IDwgZGF0ZXMubGVuZ3RoOyBkYXlzUGVyUm93ICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0ZXNbZGF5c1BlclJvd10uZ2V0VVRDRGF5KCkgPT09IGZpcnN0RGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvd0NudCA9IE1hdGguY2VpbChkYXRlcy5sZW5ndGggLyBkYXlzUGVyUm93KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJvd0NudCA9IDE7XG4gICAgICAgICAgICBkYXlzUGVyUm93ID0gZGF0ZXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucm93Q250ID0gcm93Q250O1xuICAgICAgICB0aGlzLmNvbENudCA9IGRheXNQZXJSb3c7XG4gICAgICAgIHRoaXMuZGF5U2VyaWVzID0gZGF5U2VyaWVzO1xuICAgICAgICB0aGlzLmNlbGxzID0gdGhpcy5idWlsZENlbGxzKCk7XG4gICAgICAgIHRoaXMuaGVhZGVyRGF0ZXMgPSB0aGlzLmJ1aWxkSGVhZGVyRGF0ZXMoKTtcbiAgICB9XG4gICAgYnVpbGRDZWxscygpIHtcbiAgICAgICAgbGV0IHJvd3MgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgdGhpcy5yb3dDbnQ7IHJvdyArPSAxKSB7XG4gICAgICAgICAgICBsZXQgY2VsbHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IHRoaXMuY29sQ250OyBjb2wgKz0gMSkge1xuICAgICAgICAgICAgICAgIGNlbGxzLnB1c2godGhpcy5idWlsZENlbGwocm93LCBjb2wpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvd3MucHVzaChjZWxscyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvd3M7XG4gICAgfVxuICAgIGJ1aWxkQ2VsbChyb3csIGNvbCkge1xuICAgICAgICBsZXQgZGF0ZSA9IHRoaXMuZGF5U2VyaWVzLmRhdGVzW3JvdyAqIHRoaXMuY29sQ250ICsgY29sXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleTogZGF0ZS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgZGF0ZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYnVpbGRIZWFkZXJEYXRlcygpIHtcbiAgICAgICAgbGV0IGRhdGVzID0gW107XG4gICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IHRoaXMuY29sQ250OyBjb2wgKz0gMSkge1xuICAgICAgICAgICAgZGF0ZXMucHVzaCh0aGlzLmNlbGxzWzBdW2NvbF0uZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGVzO1xuICAgIH1cbiAgICBzbGljZVJhbmdlKHJhbmdlKSB7XG4gICAgICAgIGxldCB7IGNvbENudCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHNlcmllc1NlZyA9IHRoaXMuZGF5U2VyaWVzLnNsaWNlUmFuZ2UocmFuZ2UpO1xuICAgICAgICBsZXQgc2VncyA9IFtdO1xuICAgICAgICBpZiAoc2VyaWVzU2VnKSB7XG4gICAgICAgICAgICBsZXQgeyBmaXJzdEluZGV4LCBsYXN0SW5kZXggfSA9IHNlcmllc1NlZztcbiAgICAgICAgICAgIGxldCBpbmRleCA9IGZpcnN0SW5kZXg7XG4gICAgICAgICAgICB3aGlsZSAoaW5kZXggPD0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgbGV0IHJvdyA9IE1hdGguZmxvb3IoaW5kZXggLyBjb2xDbnQpO1xuICAgICAgICAgICAgICAgIGxldCBuZXh0SW5kZXggPSBNYXRoLm1pbigocm93ICsgMSkgKiBjb2xDbnQsIGxhc3RJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIHNlZ3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHJvdyxcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RDb2w6IGluZGV4ICUgY29sQ250LFxuICAgICAgICAgICAgICAgICAgICBsYXN0Q29sOiAobmV4dEluZGV4IC0gMSkgJSBjb2xDbnQsXG4gICAgICAgICAgICAgICAgICAgIGlzU3RhcnQ6IHNlcmllc1NlZy5pc1N0YXJ0ICYmIGluZGV4ID09PSBmaXJzdEluZGV4LFxuICAgICAgICAgICAgICAgICAgICBpc0VuZDogc2VyaWVzU2VnLmlzRW5kICYmIChuZXh0SW5kZXggLSAxKSA9PT0gbGFzdEluZGV4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGluZGV4ID0gbmV4dEluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWdzO1xuICAgIH1cbn1cblxuY2xhc3MgU2xpY2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zbGljZUJ1c2luZXNzSG91cnMgPSBtZW1vaXplKHRoaXMuX3NsaWNlQnVzaW5lc3NIb3Vycyk7XG4gICAgICAgIHRoaXMuc2xpY2VEYXRlU2VsZWN0aW9uID0gbWVtb2l6ZSh0aGlzLl9zbGljZURhdGVTcGFuKTtcbiAgICAgICAgdGhpcy5zbGljZUV2ZW50U3RvcmUgPSBtZW1vaXplKHRoaXMuX3NsaWNlRXZlbnRTdG9yZSk7XG4gICAgICAgIHRoaXMuc2xpY2VFdmVudERyYWcgPSBtZW1vaXplKHRoaXMuX3NsaWNlSW50ZXJhY3Rpb24pO1xuICAgICAgICB0aGlzLnNsaWNlRXZlbnRSZXNpemUgPSBtZW1vaXplKHRoaXMuX3NsaWNlSW50ZXJhY3Rpb24pO1xuICAgICAgICB0aGlzLmZvcmNlRGF5SWZMaXN0SXRlbSA9IGZhbHNlOyAvLyBoYWNrXG4gICAgfVxuICAgIHNsaWNlUHJvcHMocHJvcHMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCBjb250ZXh0LCAuLi5leHRyYUFyZ3MpIHtcbiAgICAgICAgbGV0IHsgZXZlbnRVaUJhc2VzIH0gPSBwcm9wcztcbiAgICAgICAgbGV0IGV2ZW50U2VncyA9IHRoaXMuc2xpY2VFdmVudFN0b3JlKHByb3BzLmV2ZW50U3RvcmUsIGV2ZW50VWlCYXNlcywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIC4uLmV4dHJhQXJncyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRlU2VsZWN0aW9uU2VnczogdGhpcy5zbGljZURhdGVTZWxlY3Rpb24ocHJvcHMuZGF0ZVNlbGVjdGlvbiwgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIGV2ZW50VWlCYXNlcywgY29udGV4dCwgLi4uZXh0cmFBcmdzKSxcbiAgICAgICAgICAgIGJ1c2luZXNzSG91clNlZ3M6IHRoaXMuc2xpY2VCdXNpbmVzc0hvdXJzKHByb3BzLmJ1c2luZXNzSG91cnMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCBjb250ZXh0LCAuLi5leHRyYUFyZ3MpLFxuICAgICAgICAgICAgZmdFdmVudFNlZ3M6IGV2ZW50U2Vncy5mZyxcbiAgICAgICAgICAgIGJnRXZlbnRTZWdzOiBldmVudFNlZ3MuYmcsXG4gICAgICAgICAgICBldmVudERyYWc6IHRoaXMuc2xpY2VFdmVudERyYWcocHJvcHMuZXZlbnREcmFnLCBldmVudFVpQmFzZXMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCAuLi5leHRyYUFyZ3MpLFxuICAgICAgICAgICAgZXZlbnRSZXNpemU6IHRoaXMuc2xpY2VFdmVudFJlc2l6ZShwcm9wcy5ldmVudFJlc2l6ZSwgZXZlbnRVaUJhc2VzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgLi4uZXh0cmFBcmdzKSxcbiAgICAgICAgICAgIGV2ZW50U2VsZWN0aW9uOiBwcm9wcy5ldmVudFNlbGVjdGlvbixcbiAgICAgICAgfTsgLy8gVE9ETzogZ2l2ZSBpbnRlcmFjdGlvblNlZ3M/XG4gICAgfVxuICAgIHNsaWNlTm93RGF0ZSgvLyBkb2VzIG5vdCBtZW1vaXplXG4gICAgZGF0ZSwgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIGNvbnRleHQsIC4uLmV4dHJhQXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2xpY2VEYXRlU3Bhbih7IHJhbmdlOiB7IHN0YXJ0OiBkYXRlLCBlbmQ6IGFkZE1zKGRhdGUsIDEpIH0sIGFsbERheTogZmFsc2UgfSwgLy8gYWRkIDEgbXMsIHByb3RlY3QgYWdhaW5zdCBudWxsIHJhbmdlXG4gICAgICAgIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCB7fSwgY29udGV4dCwgLi4uZXh0cmFBcmdzKTtcbiAgICB9XG4gICAgX3NsaWNlQnVzaW5lc3NIb3VycyhidXNpbmVzc0hvdXJzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgY29udGV4dCwgLi4uZXh0cmFBcmdzKSB7XG4gICAgICAgIGlmICghYnVzaW5lc3NIb3Vycykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zbGljZUV2ZW50U3RvcmUoZXhwYW5kUmVjdXJyaW5nKGJ1c2luZXNzSG91cnMsIGNvbXB1dGVBY3RpdmVSYW5nZShkYXRlUHJvZmlsZSwgQm9vbGVhbihuZXh0RGF5VGhyZXNob2xkKSksIGNvbnRleHQpLCB7fSwgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIC4uLmV4dHJhQXJncykuYmc7XG4gICAgfVxuICAgIF9zbGljZUV2ZW50U3RvcmUoZXZlbnRTdG9yZSwgZXZlbnRVaUJhc2VzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgLi4uZXh0cmFBcmdzKSB7XG4gICAgICAgIGlmIChldmVudFN0b3JlKSB7XG4gICAgICAgICAgICBsZXQgcmFuZ2VSZXMgPSBzbGljZUV2ZW50U3RvcmUoZXZlbnRTdG9yZSwgZXZlbnRVaUJhc2VzLCBjb21wdXRlQWN0aXZlUmFuZ2UoZGF0ZVByb2ZpbGUsIEJvb2xlYW4obmV4dERheVRocmVzaG9sZCkpLCBuZXh0RGF5VGhyZXNob2xkKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYmc6IHRoaXMuc2xpY2VFdmVudFJhbmdlcyhyYW5nZVJlcy5iZywgZXh0cmFBcmdzKSxcbiAgICAgICAgICAgICAgICBmZzogdGhpcy5zbGljZUV2ZW50UmFuZ2VzKHJhbmdlUmVzLmZnLCBleHRyYUFyZ3MpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBiZzogW10sIGZnOiBbXSB9O1xuICAgIH1cbiAgICBfc2xpY2VJbnRlcmFjdGlvbihpbnRlcmFjdGlvbiwgZXZlbnRVaUJhc2VzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgLi4uZXh0cmFBcmdzKSB7XG4gICAgICAgIGlmICghaW50ZXJhY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCByYW5nZVJlcyA9IHNsaWNlRXZlbnRTdG9yZShpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzLCBldmVudFVpQmFzZXMsIGNvbXB1dGVBY3RpdmVSYW5nZShkYXRlUHJvZmlsZSwgQm9vbGVhbihuZXh0RGF5VGhyZXNob2xkKSksIG5leHREYXlUaHJlc2hvbGQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2VnczogdGhpcy5zbGljZUV2ZW50UmFuZ2VzKHJhbmdlUmVzLmZnLCBleHRyYUFyZ3MpLFxuICAgICAgICAgICAgYWZmZWN0ZWRJbnN0YW5jZXM6IGludGVyYWN0aW9uLmFmZmVjdGVkRXZlbnRzLmluc3RhbmNlcyxcbiAgICAgICAgICAgIGlzRXZlbnQ6IGludGVyYWN0aW9uLmlzRXZlbnQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9zbGljZURhdGVTcGFuKGRhdGVTcGFuLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgZXZlbnRVaUJhc2VzLCBjb250ZXh0LCAuLi5leHRyYUFyZ3MpIHtcbiAgICAgICAgaWYgKCFkYXRlU3Bhbikge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhY3RpdmVSYW5nZSA9IGNvbXB1dGVBY3RpdmVSYW5nZShkYXRlUHJvZmlsZSwgQm9vbGVhbihuZXh0RGF5VGhyZXNob2xkKSk7XG4gICAgICAgIGxldCBhY3RpdmVEYXRlU3BhblJhbmdlID0gaW50ZXJzZWN0UmFuZ2VzKGRhdGVTcGFuLnJhbmdlLCBhY3RpdmVSYW5nZSk7XG4gICAgICAgIGlmIChhY3RpdmVEYXRlU3BhblJhbmdlKSB7XG4gICAgICAgICAgICBkYXRlU3BhbiA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGF0ZVNwYW4pLCB7IHJhbmdlOiBhY3RpdmVEYXRlU3BhblJhbmdlIH0pO1xuICAgICAgICAgICAgbGV0IGV2ZW50UmFuZ2UgPSBmYWJyaWNhdGVFdmVudFJhbmdlKGRhdGVTcGFuLCBldmVudFVpQmFzZXMsIGNvbnRleHQpO1xuICAgICAgICAgICAgbGV0IHNlZ3MgPSB0aGlzLnNsaWNlUmFuZ2UoZGF0ZVNwYW4ucmFuZ2UsIC4uLmV4dHJhQXJncyk7XG4gICAgICAgICAgICBmb3IgKGxldCBzZWcgb2Ygc2Vncykge1xuICAgICAgICAgICAgICAgIHNlZy5ldmVudFJhbmdlID0gZXZlbnRSYW5nZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZWdzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgLypcbiAgICBcImNvbXBsZXRlXCIgc2VnIG1lYW5zIGl0IGhhcyBjb21wb25lbnQgYW5kIGV2ZW50UmFuZ2VcbiAgICAqL1xuICAgIHNsaWNlRXZlbnRSYW5nZXMoZXZlbnRSYW5nZXMsIGV4dHJhQXJncykge1xuICAgICAgICBsZXQgc2VncyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBldmVudFJhbmdlIG9mIGV2ZW50UmFuZ2VzKSB7XG4gICAgICAgICAgICBzZWdzLnB1c2goLi4udGhpcy5zbGljZUV2ZW50UmFuZ2UoZXZlbnRSYW5nZSwgZXh0cmFBcmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlZ3M7XG4gICAgfVxuICAgIC8qXG4gICAgXCJjb21wbGV0ZVwiIHNlZyBtZWFucyBpdCBoYXMgY29tcG9uZW50IGFuZCBldmVudFJhbmdlXG4gICAgKi9cbiAgICBzbGljZUV2ZW50UmFuZ2UoZXZlbnRSYW5nZSwgZXh0cmFBcmdzKSB7XG4gICAgICAgIGxldCBkYXRlUmFuZ2UgPSBldmVudFJhbmdlLnJhbmdlO1xuICAgICAgICAvLyBoYWNrIHRvIG1ha2UgbXVsdGktZGF5IGV2ZW50cyB0aGF0IGFyZSBiZWluZyBmb3JjZS1kaXNwbGF5ZWQgYXMgbGlzdC1pdGVtcyB0byB0YWtlIHVwIG9ubHkgb25lIGRheVxuICAgICAgICBpZiAodGhpcy5mb3JjZURheUlmTGlzdEl0ZW0gJiYgZXZlbnRSYW5nZS51aS5kaXNwbGF5ID09PSAnbGlzdC1pdGVtJykge1xuICAgICAgICAgICAgZGF0ZVJhbmdlID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBkYXRlUmFuZ2Uuc3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kOiBhZGREYXlzKGRhdGVSYW5nZS5zdGFydCwgMSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBzZWdzID0gdGhpcy5zbGljZVJhbmdlKGRhdGVSYW5nZSwgLi4uZXh0cmFBcmdzKTtcbiAgICAgICAgZm9yIChsZXQgc2VnIG9mIHNlZ3MpIHtcbiAgICAgICAgICAgIHNlZy5ldmVudFJhbmdlID0gZXZlbnRSYW5nZTtcbiAgICAgICAgICAgIHNlZy5pc1N0YXJ0ID0gZXZlbnRSYW5nZS5pc1N0YXJ0ICYmIHNlZy5pc1N0YXJ0O1xuICAgICAgICAgICAgc2VnLmlzRW5kID0gZXZlbnRSYW5nZS5pc0VuZCAmJiBzZWcuaXNFbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlZ3M7XG4gICAgfVxufVxuLypcbmZvciBpbmNvcnBvcmF0aW5nIHNsb3RNaW5UaW1lL3Nsb3RNYXhUaW1lIGlmIGFwcHJvcHJpYXRlXG5UT0RPOiBzaG91bGQgYmUgcGFydCBvZiBEYXRlUHJvZmlsZSFcblRpbWVsaW5lRGF0ZVByb2ZpbGUgYWxyZWFkeSBkb2VzIHRoaXMgYnR3XG4qL1xuZnVuY3Rpb24gY29tcHV0ZUFjdGl2ZVJhbmdlKGRhdGVQcm9maWxlLCBpc0NvbXBvbmVudEFsbERheSkge1xuICAgIGxldCByYW5nZSA9IGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlO1xuICAgIGlmIChpc0NvbXBvbmVudEFsbERheSkge1xuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiBhZGRNcyhyYW5nZS5zdGFydCwgZGF0ZVByb2ZpbGUuc2xvdE1pblRpbWUubWlsbGlzZWNvbmRzKSxcbiAgICAgICAgZW5kOiBhZGRNcyhyYW5nZS5lbmQsIGRhdGVQcm9maWxlLnNsb3RNYXhUaW1lLm1pbGxpc2Vjb25kcyAtIDg2NGU1KSwgLy8gODY0ZTUgPSBtcyBpbiBhIGRheVxuICAgIH07XG59XG5cbi8vIGhpZ2gtbGV2ZWwgc2VnbWVudGluZy1hd2FyZSB0ZXN0ZXIgZnVuY3Rpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGlzSW50ZXJhY3Rpb25WYWxpZChpbnRlcmFjdGlvbiwgZGF0ZVByb2ZpbGUsIGNvbnRleHQpIHtcbiAgICBsZXQgeyBpbnN0YW5jZXMgfSA9IGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHM7XG4gICAgZm9yIChsZXQgaW5zdGFuY2VJZCBpbiBpbnN0YW5jZXMpIHtcbiAgICAgICAgaWYgKCFyYW5nZUNvbnRhaW5zUmFuZ2UoZGF0ZVByb2ZpbGUudmFsaWRSYW5nZSwgaW5zdGFuY2VzW2luc3RhbmNlSWRdLnJhbmdlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpc05ld1Byb3BzVmFsaWQoeyBldmVudERyYWc6IGludGVyYWN0aW9uIH0sIGNvbnRleHQpOyAvLyBIQUNLOiB0aGUgZXZlbnREcmFnIHByb3BzIGlzIHVzZWQgZm9yIEFMTCBpbnRlcmFjdGlvbnNcbn1cbmZ1bmN0aW9uIGlzRGF0ZVNlbGVjdGlvblZhbGlkKGRhdGVTZWxlY3Rpb24sIGRhdGVQcm9maWxlLCBjb250ZXh0KSB7XG4gICAgaWYgKCFyYW5nZUNvbnRhaW5zUmFuZ2UoZGF0ZVByb2ZpbGUudmFsaWRSYW5nZSwgZGF0ZVNlbGVjdGlvbi5yYW5nZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gaXNOZXdQcm9wc1ZhbGlkKHsgZGF0ZVNlbGVjdGlvbiB9LCBjb250ZXh0KTtcbn1cbmZ1bmN0aW9uIGlzTmV3UHJvcHNWYWxpZChuZXdQcm9wcywgY29udGV4dCkge1xuICAgIGxldCBjYWxlbmRhclN0YXRlID0gY29udGV4dC5nZXRDdXJyZW50RGF0YSgpO1xuICAgIGxldCBwcm9wcyA9IE9iamVjdC5hc3NpZ24oeyBidXNpbmVzc0hvdXJzOiBjYWxlbmRhclN0YXRlLmJ1c2luZXNzSG91cnMsIGRhdGVTZWxlY3Rpb246ICcnLCBldmVudFN0b3JlOiBjYWxlbmRhclN0YXRlLmV2ZW50U3RvcmUsIGV2ZW50VWlCYXNlczogY2FsZW5kYXJTdGF0ZS5ldmVudFVpQmFzZXMsIGV2ZW50U2VsZWN0aW9uOiAnJywgZXZlbnREcmFnOiBudWxsLCBldmVudFJlc2l6ZTogbnVsbCB9LCBuZXdQcm9wcyk7XG4gICAgcmV0dXJuIChjb250ZXh0LnBsdWdpbkhvb2tzLmlzUHJvcHNWYWxpZCB8fCBpc1Byb3BzVmFsaWQpKHByb3BzLCBjb250ZXh0KTtcbn1cbmZ1bmN0aW9uIGlzUHJvcHNWYWxpZChzdGF0ZSwgY29udGV4dCwgZGF0ZVNwYW5NZXRhID0ge30sIGZpbHRlckNvbmZpZykge1xuICAgIGlmIChzdGF0ZS5ldmVudERyYWcgJiYgIWlzSW50ZXJhY3Rpb25Qcm9wc1ZhbGlkKHN0YXRlLCBjb250ZXh0LCBkYXRlU3Bhbk1ldGEsIGZpbHRlckNvbmZpZykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuZGF0ZVNlbGVjdGlvbiAmJiAhaXNEYXRlU2VsZWN0aW9uUHJvcHNWYWxpZChzdGF0ZSwgY29udGV4dCwgZGF0ZVNwYW5NZXRhLCBmaWx0ZXJDb25maWcpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyBNb3ZpbmcgRXZlbnQgVmFsaWRhdGlvblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBpc0ludGVyYWN0aW9uUHJvcHNWYWxpZChzdGF0ZSwgY29udGV4dCwgZGF0ZVNwYW5NZXRhLCBmaWx0ZXJDb25maWcpIHtcbiAgICBsZXQgY3VycmVudFN0YXRlID0gY29udGV4dC5nZXRDdXJyZW50RGF0YSgpO1xuICAgIGxldCBpbnRlcmFjdGlvbiA9IHN0YXRlLmV2ZW50RHJhZzsgLy8gSEFDSzogdGhlIGV2ZW50RHJhZyBwcm9wcyBpcyB1c2VkIGZvciBBTEwgaW50ZXJhY3Rpb25zXG4gICAgbGV0IHN1YmplY3RFdmVudFN0b3JlID0gaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cztcbiAgICBsZXQgc3ViamVjdERlZnMgPSBzdWJqZWN0RXZlbnRTdG9yZS5kZWZzO1xuICAgIGxldCBzdWJqZWN0SW5zdGFuY2VzID0gc3ViamVjdEV2ZW50U3RvcmUuaW5zdGFuY2VzO1xuICAgIGxldCBzdWJqZWN0Q29uZmlncyA9IGNvbXBpbGVFdmVudFVpcyhzdWJqZWN0RGVmcywgaW50ZXJhY3Rpb24uaXNFdmVudCA/XG4gICAgICAgIHN0YXRlLmV2ZW50VWlCYXNlcyA6XG4gICAgICAgIHsgJyc6IGN1cnJlbnRTdGF0ZS5zZWxlY3Rpb25Db25maWcgfSk7XG4gICAgaWYgKGZpbHRlckNvbmZpZykge1xuICAgICAgICBzdWJqZWN0Q29uZmlncyA9IG1hcEhhc2goc3ViamVjdENvbmZpZ3MsIGZpbHRlckNvbmZpZyk7XG4gICAgfVxuICAgIC8vIGV4Y2x1ZGUgdGhlIHN1YmplY3QgZXZlbnRzLiBUT0RPOiBleGNsdWRlIGRlZnMgdG9vP1xuICAgIGxldCBvdGhlckV2ZW50U3RvcmUgPSBleGNsdWRlSW5zdGFuY2VzKHN0YXRlLmV2ZW50U3RvcmUsIGludGVyYWN0aW9uLmFmZmVjdGVkRXZlbnRzLmluc3RhbmNlcyk7XG4gICAgbGV0IG90aGVyRGVmcyA9IG90aGVyRXZlbnRTdG9yZS5kZWZzO1xuICAgIGxldCBvdGhlckluc3RhbmNlcyA9IG90aGVyRXZlbnRTdG9yZS5pbnN0YW5jZXM7XG4gICAgbGV0IG90aGVyQ29uZmlncyA9IGNvbXBpbGVFdmVudFVpcyhvdGhlckRlZnMsIHN0YXRlLmV2ZW50VWlCYXNlcyk7XG4gICAgZm9yIChsZXQgc3ViamVjdEluc3RhbmNlSWQgaW4gc3ViamVjdEluc3RhbmNlcykge1xuICAgICAgICBsZXQgc3ViamVjdEluc3RhbmNlID0gc3ViamVjdEluc3RhbmNlc1tzdWJqZWN0SW5zdGFuY2VJZF07XG4gICAgICAgIGxldCBzdWJqZWN0UmFuZ2UgPSBzdWJqZWN0SW5zdGFuY2UucmFuZ2U7XG4gICAgICAgIGxldCBzdWJqZWN0Q29uZmlnID0gc3ViamVjdENvbmZpZ3Nbc3ViamVjdEluc3RhbmNlLmRlZklkXTtcbiAgICAgICAgbGV0IHN1YmplY3REZWYgPSBzdWJqZWN0RGVmc1tzdWJqZWN0SW5zdGFuY2UuZGVmSWRdO1xuICAgICAgICAvLyBjb25zdHJhaW50XG4gICAgICAgIGlmICghYWxsQ29uc3RyYWludHNQYXNzKHN1YmplY3RDb25maWcuY29uc3RyYWludHMsIHN1YmplY3RSYW5nZSwgb3RoZXJFdmVudFN0b3JlLCBzdGF0ZS5idXNpbmVzc0hvdXJzLCBjb250ZXh0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIG92ZXJsYXBcbiAgICAgICAgbGV0IHsgZXZlbnRPdmVybGFwIH0gPSBjb250ZXh0Lm9wdGlvbnM7XG4gICAgICAgIGxldCBldmVudE92ZXJsYXBGdW5jID0gdHlwZW9mIGV2ZW50T3ZlcmxhcCA9PT0gJ2Z1bmN0aW9uJyA/IGV2ZW50T3ZlcmxhcCA6IG51bGw7XG4gICAgICAgIGZvciAobGV0IG90aGVySW5zdGFuY2VJZCBpbiBvdGhlckluc3RhbmNlcykge1xuICAgICAgICAgICAgbGV0IG90aGVySW5zdGFuY2UgPSBvdGhlckluc3RhbmNlc1tvdGhlckluc3RhbmNlSWRdO1xuICAgICAgICAgICAgLy8gaW50ZXJzZWN0ISBldmFsdWF0ZVxuICAgICAgICAgICAgaWYgKHJhbmdlc0ludGVyc2VjdChzdWJqZWN0UmFuZ2UsIG90aGVySW5zdGFuY2UucmFuZ2UpKSB7XG4gICAgICAgICAgICAgICAgbGV0IG90aGVyT3ZlcmxhcCA9IG90aGVyQ29uZmlnc1tvdGhlckluc3RhbmNlLmRlZklkXS5vdmVybGFwO1xuICAgICAgICAgICAgICAgIC8vIGNvbnNpZGVyIHRoZSBvdGhlciBldmVudCdzIG92ZXJsYXAuIG9ubHkgZG8gdGhpcyBpZiB0aGUgc3ViamVjdCBldmVudCBpcyBhIFwicmVhbFwiIGV2ZW50XG4gICAgICAgICAgICAgICAgaWYgKG90aGVyT3ZlcmxhcCA9PT0gZmFsc2UgJiYgaW50ZXJhY3Rpb24uaXNFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdWJqZWN0Q29uZmlnLm92ZXJsYXAgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50T3ZlcmxhcEZ1bmMgJiYgIWV2ZW50T3ZlcmxhcEZ1bmMobmV3IEV2ZW50SW1wbChjb250ZXh0LCBvdGhlckRlZnNbb3RoZXJJbnN0YW5jZS5kZWZJZF0sIG90aGVySW5zdGFuY2UpLCAvLyBzdGlsbCBldmVudFxuICAgICAgICAgICAgICAgIG5ldyBFdmVudEltcGwoY29udGV4dCwgc3ViamVjdERlZiwgc3ViamVjdEluc3RhbmNlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBhbGxvdyAoYSBmdW5jdGlvbilcbiAgICAgICAgbGV0IGNhbGVuZGFyRXZlbnRTdG9yZSA9IGN1cnJlbnRTdGF0ZS5ldmVudFN0b3JlOyAvLyBuZWVkIGdsb2JhbC10by1jYWxlbmRhciwgbm90IGxvY2FsIHRvIGNvbXBvbmVudCAoc3BsaXR0YWJsZSlzdGF0ZVxuICAgICAgICBmb3IgKGxldCBzdWJqZWN0QWxsb3cgb2Ygc3ViamVjdENvbmZpZy5hbGxvd3MpIHtcbiAgICAgICAgICAgIGxldCBzdWJqZWN0RGF0ZVNwYW4gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRhdGVTcGFuTWV0YSksIHsgcmFuZ2U6IHN1YmplY3RJbnN0YW5jZS5yYW5nZSwgYWxsRGF5OiBzdWJqZWN0RGVmLmFsbERheSB9KTtcbiAgICAgICAgICAgIGxldCBvcmlnRGVmID0gY2FsZW5kYXJFdmVudFN0b3JlLmRlZnNbc3ViamVjdERlZi5kZWZJZF07XG4gICAgICAgICAgICBsZXQgb3JpZ0luc3RhbmNlID0gY2FsZW5kYXJFdmVudFN0b3JlLmluc3RhbmNlc1tzdWJqZWN0SW5zdGFuY2VJZF07XG4gICAgICAgICAgICBsZXQgZXZlbnRBcGk7XG4gICAgICAgICAgICBpZiAob3JpZ0RlZikgeyAvLyB3YXMgcHJldmlvdXNseSBpbiB0aGUgY2FsZW5kYXJcbiAgICAgICAgICAgICAgICBldmVudEFwaSA9IG5ldyBFdmVudEltcGwoY29udGV4dCwgb3JpZ0RlZiwgb3JpZ0luc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyAvLyB3YXMgYW4gZXh0ZXJuYWwgZXZlbnRcbiAgICAgICAgICAgICAgICBldmVudEFwaSA9IG5ldyBFdmVudEltcGwoY29udGV4dCwgc3ViamVjdERlZik7IC8vIG5vIGluc3RhbmNlLCBiZWNhdXNlIGhhZCBubyBkYXRlc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzdWJqZWN0QWxsb3coYnVpbGREYXRlU3BhbkFwaVdpdGhDb250ZXh0KHN1YmplY3REYXRlU3BhbiwgY29udGV4dCksIGV2ZW50QXBpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8vIERhdGUgU2VsZWN0aW9uIFZhbGlkYXRpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gaXNEYXRlU2VsZWN0aW9uUHJvcHNWYWxpZChzdGF0ZSwgY29udGV4dCwgZGF0ZVNwYW5NZXRhLCBmaWx0ZXJDb25maWcpIHtcbiAgICBsZXQgcmVsZXZhbnRFdmVudFN0b3JlID0gc3RhdGUuZXZlbnRTdG9yZTtcbiAgICBsZXQgcmVsZXZhbnREZWZzID0gcmVsZXZhbnRFdmVudFN0b3JlLmRlZnM7XG4gICAgbGV0IHJlbGV2YW50SW5zdGFuY2VzID0gcmVsZXZhbnRFdmVudFN0b3JlLmluc3RhbmNlcztcbiAgICBsZXQgc2VsZWN0aW9uID0gc3RhdGUuZGF0ZVNlbGVjdGlvbjtcbiAgICBsZXQgc2VsZWN0aW9uUmFuZ2UgPSBzZWxlY3Rpb24ucmFuZ2U7XG4gICAgbGV0IHsgc2VsZWN0aW9uQ29uZmlnIH0gPSBjb250ZXh0LmdldEN1cnJlbnREYXRhKCk7XG4gICAgaWYgKGZpbHRlckNvbmZpZykge1xuICAgICAgICBzZWxlY3Rpb25Db25maWcgPSBmaWx0ZXJDb25maWcoc2VsZWN0aW9uQ29uZmlnKTtcbiAgICB9XG4gICAgLy8gY29uc3RyYWludFxuICAgIGlmICghYWxsQ29uc3RyYWludHNQYXNzKHNlbGVjdGlvbkNvbmZpZy5jb25zdHJhaW50cywgc2VsZWN0aW9uUmFuZ2UsIHJlbGV2YW50RXZlbnRTdG9yZSwgc3RhdGUuYnVzaW5lc3NIb3VycywgY29udGV4dCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBvdmVybGFwXG4gICAgbGV0IHsgc2VsZWN0T3ZlcmxhcCB9ID0gY29udGV4dC5vcHRpb25zO1xuICAgIGxldCBzZWxlY3RPdmVybGFwRnVuYyA9IHR5cGVvZiBzZWxlY3RPdmVybGFwID09PSAnZnVuY3Rpb24nID8gc2VsZWN0T3ZlcmxhcCA6IG51bGw7XG4gICAgZm9yIChsZXQgcmVsZXZhbnRJbnN0YW5jZUlkIGluIHJlbGV2YW50SW5zdGFuY2VzKSB7XG4gICAgICAgIGxldCByZWxldmFudEluc3RhbmNlID0gcmVsZXZhbnRJbnN0YW5jZXNbcmVsZXZhbnRJbnN0YW5jZUlkXTtcbiAgICAgICAgLy8gaW50ZXJzZWN0ISBldmFsdWF0ZVxuICAgICAgICBpZiAocmFuZ2VzSW50ZXJzZWN0KHNlbGVjdGlvblJhbmdlLCByZWxldmFudEluc3RhbmNlLnJhbmdlKSkge1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbkNvbmZpZy5vdmVybGFwID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxlY3RPdmVybGFwRnVuYyAmJiAhc2VsZWN0T3ZlcmxhcEZ1bmMobmV3IEV2ZW50SW1wbChjb250ZXh0LCByZWxldmFudERlZnNbcmVsZXZhbnRJbnN0YW5jZS5kZWZJZF0sIHJlbGV2YW50SW5zdGFuY2UpLCBudWxsKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBhbGxvdyAoYSBmdW5jdGlvbilcbiAgICBmb3IgKGxldCBzZWxlY3Rpb25BbGxvdyBvZiBzZWxlY3Rpb25Db25maWcuYWxsb3dzKSB7XG4gICAgICAgIGxldCBmdWxsRGF0ZVNwYW4gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRhdGVTcGFuTWV0YSksIHNlbGVjdGlvbik7XG4gICAgICAgIGlmICghc2VsZWN0aW9uQWxsb3coYnVpbGREYXRlU3BhbkFwaVdpdGhDb250ZXh0KGZ1bGxEYXRlU3BhbiwgY29udGV4dCksIG51bGwpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyBDb25zdHJhaW50IFV0aWxzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGFsbENvbnN0cmFpbnRzUGFzcyhjb25zdHJhaW50cywgc3ViamVjdFJhbmdlLCBvdGhlckV2ZW50U3RvcmUsIGJ1c2luZXNzSG91cnNVbmV4cGFuZGVkLCBjb250ZXh0KSB7XG4gICAgZm9yIChsZXQgY29uc3RyYWludCBvZiBjb25zdHJhaW50cykge1xuICAgICAgICBpZiAoIWFueVJhbmdlc0NvbnRhaW5SYW5nZShjb25zdHJhaW50VG9SYW5nZXMoY29uc3RyYWludCwgc3ViamVjdFJhbmdlLCBvdGhlckV2ZW50U3RvcmUsIGJ1c2luZXNzSG91cnNVbmV4cGFuZGVkLCBjb250ZXh0KSwgc3ViamVjdFJhbmdlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gY29uc3RyYWludFRvUmFuZ2VzKGNvbnN0cmFpbnQsIHN1YmplY3RSYW5nZSwgLy8gZm9yIGV4cGFuZGluZyBhIHJlY3VycmluZyBjb25zdHJhaW50LCBvciBleHBhbmRpbmcgYnVzaW5lc3MgaG91cnNcbm90aGVyRXZlbnRTdG9yZSwgLy8gZm9yIGlmIGNvbnN0cmFpbnQgaXMgYW4gZXZlbiBncm91cCBJRFxuYnVzaW5lc3NIb3Vyc1VuZXhwYW5kZWQsIC8vIGZvciBpZiBjb25zdHJhaW50IGlzICdidXNpbmVzc0hvdXJzJ1xuY29udGV4dCkge1xuICAgIGlmIChjb25zdHJhaW50ID09PSAnYnVzaW5lc3NIb3VycycpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50U3RvcmVUb1JhbmdlcyhleHBhbmRSZWN1cnJpbmcoYnVzaW5lc3NIb3Vyc1VuZXhwYW5kZWQsIHN1YmplY3RSYW5nZSwgY29udGV4dCkpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbnN0cmFpbnQgPT09ICdzdHJpbmcnKSB7IC8vIGFuIGdyb3VwIElEXG4gICAgICAgIHJldHVybiBldmVudFN0b3JlVG9SYW5nZXMoZmlsdGVyRXZlbnRTdG9yZURlZnMob3RoZXJFdmVudFN0b3JlLCAoZXZlbnREZWYpID0+IGV2ZW50RGVmLmdyb3VwSWQgPT09IGNvbnN0cmFpbnQpKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb25zdHJhaW50ID09PSAnb2JqZWN0JyAmJiBjb25zdHJhaW50KSB7IC8vIG5vbi1udWxsIG9iamVjdFxuICAgICAgICByZXR1cm4gZXZlbnRTdG9yZVRvUmFuZ2VzKGV4cGFuZFJlY3VycmluZyhjb25zdHJhaW50LCBzdWJqZWN0UmFuZ2UsIGNvbnRleHQpKTtcbiAgICB9XG4gICAgcmV0dXJuIFtdOyAvLyBpZiBpdCdzIGZhbHNlXG59XG4vLyBUT0RPOiBtb3ZlIHRvIGV2ZW50LXN0b3JlIGZpbGU/XG5mdW5jdGlvbiBldmVudFN0b3JlVG9SYW5nZXMoZXZlbnRTdG9yZSkge1xuICAgIGxldCB7IGluc3RhbmNlcyB9ID0gZXZlbnRTdG9yZTtcbiAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgZm9yIChsZXQgaW5zdGFuY2VJZCBpbiBpbnN0YW5jZXMpIHtcbiAgICAgICAgcmFuZ2VzLnB1c2goaW5zdGFuY2VzW2luc3RhbmNlSWRdLnJhbmdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlcztcbn1cbi8vIFRPRE86IG1vdmUgdG8gZ2VvbSBmaWxlP1xuZnVuY3Rpb24gYW55UmFuZ2VzQ29udGFpblJhbmdlKG91dGVyUmFuZ2VzLCBpbm5lclJhbmdlKSB7XG4gICAgZm9yIChsZXQgb3V0ZXJSYW5nZSBvZiBvdXRlclJhbmdlcykge1xuICAgICAgICBpZiAocmFuZ2VDb250YWluc1JhbmdlKG91dGVyUmFuZ2UsIGlubmVyUmFuZ2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmNvbnN0IFZJU0lCTEVfSElEREVOX1JFID0gL14odmlzaWJsZXxoaWRkZW4pJC87XG5jbGFzcyBTY3JvbGxlciBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmhhbmRsZUVsID0gKGVsKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgICAgICBzZXRSZWYodGhpcy5wcm9wcy5lbFJlZiwgZWwpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBsaXF1aWQsIGxpcXVpZElzQWJzb2x1dGUgfSA9IHByb3BzO1xuICAgICAgICBsZXQgaXNBYnNvbHV0ZSA9IGxpcXVpZCAmJiBsaXF1aWRJc0Fic29sdXRlO1xuICAgICAgICBsZXQgY2xhc3NOYW1lID0gWydmYy1zY3JvbGxlciddO1xuICAgICAgICBpZiAobGlxdWlkKSB7XG4gICAgICAgICAgICBpZiAobGlxdWlkSXNBYnNvbHV0ZSkge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZS5wdXNoKCdmYy1zY3JvbGxlci1saXF1aWQtYWJzb2x1dGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZS5wdXNoKCdmYy1zY3JvbGxlci1saXF1aWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IHRoaXMuaGFuZGxlRWwsIGNsYXNzTmFtZTogY2xhc3NOYW1lLmpvaW4oJyAnKSwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvd1g6IHByb3BzLm92ZXJmbG93WCxcbiAgICAgICAgICAgICAgICBvdmVyZmxvd1k6IHByb3BzLm92ZXJmbG93WSxcbiAgICAgICAgICAgICAgICBsZWZ0OiAoaXNBYnNvbHV0ZSAmJiAtKHByb3BzLm92ZXJjb21lTGVmdCB8fCAwKSkgfHwgJycsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IChpc0Fic29sdXRlICYmIC0ocHJvcHMub3ZlcmNvbWVSaWdodCB8fCAwKSkgfHwgJycsXG4gICAgICAgICAgICAgICAgYm90dG9tOiAoaXNBYnNvbHV0ZSAmJiAtKHByb3BzLm92ZXJjb21lQm90dG9tIHx8IDApKSB8fCAnJyxcbiAgICAgICAgICAgICAgICBtYXJnaW5MZWZ0OiAoIWlzQWJzb2x1dGUgJiYgLShwcm9wcy5vdmVyY29tZUxlZnQgfHwgMCkpIHx8ICcnLFxuICAgICAgICAgICAgICAgIG1hcmdpblJpZ2h0OiAoIWlzQWJzb2x1dGUgJiYgLShwcm9wcy5vdmVyY29tZVJpZ2h0IHx8IDApKSB8fCAnJyxcbiAgICAgICAgICAgICAgICBtYXJnaW5Cb3R0b206ICghaXNBYnNvbHV0ZSAmJiAtKHByb3BzLm92ZXJjb21lQm90dG9tIHx8IDApKSB8fCAnJyxcbiAgICAgICAgICAgICAgICBtYXhIZWlnaHQ6IHByb3BzLm1heEhlaWdodCB8fCAnJyxcbiAgICAgICAgICAgIH0gfSwgcHJvcHMuY2hpbGRyZW4pKTtcbiAgICB9XG4gICAgbmVlZHNYU2Nyb2xsaW5nKCkge1xuICAgICAgICBpZiAoVklTSUJMRV9ISURERU5fUkUudGVzdCh0aGlzLnByb3BzLm92ZXJmbG93WCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0ZXN0aW5nIHNjcm9sbFdpZHRoPmNsaWVudFdpZHRoIGlzIHVucmVsaWFibGUgY3Jvc3MtYnJvd3NlciB3aGVuIHBpeGVsIGhlaWdodHMgYXJlbid0IGludGVnZXJzLlxuICAgICAgICAvLyBtdWNoIG1vcmUgcmVsaWFibGUgdG8gc2VlIGlmIGNoaWxkcmVuIGFyZSB0YWxsZXIgdGhhbiB0aGUgc2Nyb2xsZXIsIGV2ZW4gdGhvIGRvZXNuJ3QgYWNjb3VudCBmb3JcbiAgICAgICAgLy8gaW5uZXItY2hpbGQgbWFyZ2lucyBhbmQgYWJzb2x1dGUgcG9zaXRpb25pbmdcbiAgICAgICAgbGV0IHsgZWwgfSA9IHRoaXM7XG4gICAgICAgIGxldCByZWFsQ2xpZW50V2lkdGggPSB0aGlzLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC0gdGhpcy5nZXRZU2Nyb2xsYmFyV2lkdGgoKTtcbiAgICAgICAgbGV0IHsgY2hpbGRyZW4gfSA9IGVsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGRFbCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKGNoaWxkRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggPiByZWFsQ2xpZW50V2lkdGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG5lZWRzWVNjcm9sbGluZygpIHtcbiAgICAgICAgaWYgKFZJU0lCTEVfSElEREVOX1JFLnRlc3QodGhpcy5wcm9wcy5vdmVyZmxvd1kpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGVzdGluZyBzY3JvbGxIZWlnaHQ+Y2xpZW50SGVpZ2h0IGlzIHVucmVsaWFibGUgY3Jvc3MtYnJvd3NlciB3aGVuIHBpeGVsIGhlaWdodHMgYXJlbid0IGludGVnZXJzLlxuICAgICAgICAvLyBtdWNoIG1vcmUgcmVsaWFibGUgdG8gc2VlIGlmIGNoaWxkcmVuIGFyZSB0YWxsZXIgdGhhbiB0aGUgc2Nyb2xsZXIsIGV2ZW4gdGhvIGRvZXNuJ3QgYWNjb3VudCBmb3JcbiAgICAgICAgLy8gaW5uZXItY2hpbGQgbWFyZ2lucyBhbmQgYWJzb2x1dGUgcG9zaXRpb25pbmdcbiAgICAgICAgbGV0IHsgZWwgfSA9IHRoaXM7XG4gICAgICAgIGxldCByZWFsQ2xpZW50SGVpZ2h0ID0gdGhpcy5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgLSB0aGlzLmdldFhTY3JvbGxiYXJXaWR0aCgpO1xuICAgICAgICBsZXQgeyBjaGlsZHJlbiB9ID0gZWw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGxldCBjaGlsZEVsID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAoY2hpbGRFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgPiByZWFsQ2xpZW50SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBnZXRYU2Nyb2xsYmFyV2lkdGgoKSB7XG4gICAgICAgIGlmIChWSVNJQkxFX0hJRERFTl9SRS50ZXN0KHRoaXMucHJvcHMub3ZlcmZsb3dYKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZWwub2Zmc2V0SGVpZ2h0IC0gdGhpcy5lbC5jbGllbnRIZWlnaHQ7IC8vIG9ubHkgd29ya3MgYmVjYXVzZSB3ZSBndWFyYW50ZWUgbm8gYm9yZGVycy4gVE9ETzogYWRkIHRvIENTUyB3aXRoIGltcG9ydGFudD9cbiAgICB9XG4gICAgZ2V0WVNjcm9sbGJhcldpZHRoKCkge1xuICAgICAgICBpZiAoVklTSUJMRV9ISURERU5fUkUudGVzdCh0aGlzLnByb3BzLm92ZXJmbG93WSkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVsLm9mZnNldFdpZHRoIC0gdGhpcy5lbC5jbGllbnRXaWR0aDsgLy8gb25seSB3b3JrcyBiZWNhdXNlIHdlIGd1YXJhbnRlZSBubyBib3JkZXJzLiBUT0RPOiBhZGQgdG8gQ1NTIHdpdGggaW1wb3J0YW50P1xuICAgIH1cbn1cblxuLypcblRPRE86IHNvbWVob3cgaW5mZXIgT3RoZXJBcmdzIGZyb20gbWFzdGVyQ2FsbGJhY2s/XG5UT0RPOiBpbmZlciBSZWZUeXBlIGZyb20gbWFzdGVyQ2FsbGJhY2sgaWYgcHJvdmlkZWRcbiovXG5jbGFzcyBSZWZNYXAge1xuICAgIGNvbnN0cnVjdG9yKG1hc3RlckNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMubWFzdGVyQ2FsbGJhY2sgPSBtYXN0ZXJDYWxsYmFjaztcbiAgICAgICAgdGhpcy5jdXJyZW50TWFwID0ge307XG4gICAgICAgIHRoaXMuZGVwdGhzID0ge307XG4gICAgICAgIHRoaXMuY2FsbGJhY2tNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5oYW5kbGVWYWx1ZSA9ICh2YWwsIGtleSkgPT4ge1xuICAgICAgICAgICAgbGV0IHsgZGVwdGhzLCBjdXJyZW50TWFwIH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IHJlbW92ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBhZGRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHZhbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIGZvciBidWcuLi4gQUNUVUFMTFk6IGNhbiBwcm9iYWJseSBkbyBhd2F5IHdpdGggdGhpcyBub3cgdGhhdCBjYWxsZXJzIGRvbid0IHNoYXJlIG51bWVyaWMgaW5kaWNlcyBhbnltb3JlXG4gICAgICAgICAgICAgICAgcmVtb3ZlZCA9IChrZXkgaW4gY3VycmVudE1hcCk7XG4gICAgICAgICAgICAgICAgY3VycmVudE1hcFtrZXldID0gdmFsO1xuICAgICAgICAgICAgICAgIGRlcHRoc1trZXldID0gKGRlcHRoc1trZXldIHx8IDApICsgMTtcbiAgICAgICAgICAgICAgICBhZGRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZXB0aHNba2V5XSAtPSAxO1xuICAgICAgICAgICAgICAgIGlmICghZGVwdGhzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGN1cnJlbnRNYXBba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuY2FsbGJhY2tNYXBba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubWFzdGVyQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hc3RlckNhbGxiYWNrKG51bGwsIFN0cmluZyhrZXkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFkZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFzdGVyQ2FsbGJhY2sodmFsLCBTdHJpbmcoa2V5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjcmVhdGVSZWYoa2V5KSB7XG4gICAgICAgIGxldCByZWZDYWxsYmFjayA9IHRoaXMuY2FsbGJhY2tNYXBba2V5XTtcbiAgICAgICAgaWYgKCFyZWZDYWxsYmFjaykge1xuICAgICAgICAgICAgcmVmQ2FsbGJhY2sgPSB0aGlzLmNhbGxiYWNrTWFwW2tleV0gPSAodmFsKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVWYWx1ZSh2YWwsIFN0cmluZyhrZXkpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlZkNhbGxiYWNrO1xuICAgIH1cbiAgICAvLyBUT0RPOiBjaGVjayBjYWxsZXJzIHRoYXQgZG9uJ3QgY2FyZSBhYm91dCBvcmRlci4gc2hvdWxkIHVzZSBnZXRBbGwgaW5zdGVhZFxuICAgIC8vIE5PVEU6IHRoaXMgbWV0aG9kIGhhcyBiZWNvbWUgbGVzcyB2YWx1YWJsZSBub3cgdGhhdCB3ZSBhcmUgZW5jb3VyYWdlZCB0byBtYXAgb3JkZXIgYnkgc29tZSBvdGhlciBpbmRleFxuICAgIC8vIFRPRE86IHByb3ZpZGUgT05FIGFycmF5LWV4cG9ydCBmdW5jdGlvbiwgYnVpbGRBcnJheSwgd2hpY2ggZmFpbHMgb24gbm9uLW51bWVyaWMgaW5kZXhlcy4gY2FsbGVyIGNhbiBtYW5pcHVsYXRlIGFuZCBcImNvbGxlY3RcIlxuICAgIGNvbGxlY3Qoc3RhcnRJbmRleCwgZW5kSW5kZXgsIHN0ZXApIHtcbiAgICAgICAgcmV0dXJuIGNvbGxlY3RGcm9tSGFzaCh0aGlzLmN1cnJlbnRNYXAsIHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBzdGVwKTtcbiAgICB9XG4gICAgZ2V0QWxsKCkge1xuICAgICAgICByZXR1cm4gaGFzaFZhbHVlc1RvQXJyYXkodGhpcy5jdXJyZW50TWFwKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVTaHJpbmtXaWR0aChjaHVua0Vscykge1xuICAgIGxldCBzaHJpbmtDZWxscyA9IGZpbmRFbGVtZW50cyhjaHVua0VscywgJy5mYy1zY3JvbGxncmlkLXNocmluaycpO1xuICAgIGxldCBsYXJnZXN0V2lkdGggPSAwO1xuICAgIGZvciAobGV0IHNocmlua0NlbGwgb2Ygc2hyaW5rQ2VsbHMpIHtcbiAgICAgICAgbGFyZ2VzdFdpZHRoID0gTWF0aC5tYXgobGFyZ2VzdFdpZHRoLCBjb21wdXRlU21hbGxlc3RDZWxsV2lkdGgoc2hyaW5rQ2VsbCkpO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5jZWlsKGxhcmdlc3RXaWR0aCk7IC8vIDx0YWJsZT4gZWxlbWVudHMgd29yayBiZXN0IHdpdGggaW50ZWdlcnMuIHJvdW5kIHVwIHRvIGVuc3VyZSBjb250ZW50cyBmaXRzXG59XG5mdW5jdGlvbiBnZXRTZWN0aW9uSGFzTGlxdWlkSGVpZ2h0KHByb3BzLCBzZWN0aW9uQ29uZmlnKSB7XG4gICAgcmV0dXJuIHByb3BzLmxpcXVpZCAmJiBzZWN0aW9uQ29uZmlnLmxpcXVpZDsgLy8gZG9lcyB0aGUgc2VjdGlvbiBkbyBsaXF1aWQtaGVpZ2h0PyAobmVlZCB0byBoYXZlIHdob2xlIHNjcm9sbGdyaWQgbGlxdWlkLWhlaWdodCBhcyB3ZWxsKVxufVxuZnVuY3Rpb24gZ2V0QWxsb3dZU2Nyb2xsaW5nKHByb3BzLCBzZWN0aW9uQ29uZmlnKSB7XG4gICAgcmV0dXJuIHNlY3Rpb25Db25maWcubWF4SGVpZ2h0ICE9IG51bGwgfHwgLy8gaWYgaXRzIHBvc3NpYmxlIGZvciB0aGUgaGVpZ2h0IHRvIG1heCBvdXQsIHdlIG1pZ2h0IG5lZWQgc2Nyb2xsYmFyc1xuICAgICAgICBnZXRTZWN0aW9uSGFzTGlxdWlkSGVpZ2h0KHByb3BzLCBzZWN0aW9uQ29uZmlnKTsgLy8gaWYgdGhlIHNlY3Rpb24gaXMgbGlxdWlkIGhlaWdodCwgaXQgbWlnaHQgY29uZGVuc2UgZW5vdWdoIHRvIHJlcXVpcmUgc2Nyb2xsYmFyc1xufVxuLy8gVE9ETzogT05MWSB1c2UgYGFyZ2AuIGZvcmNlIG91dCBpbnRlcm5hbCBmdW5jdGlvbiB0byB1c2Ugc2FtZSBBUElcbmZ1bmN0aW9uIHJlbmRlckNodW5rQ29udGVudChzZWN0aW9uQ29uZmlnLCBjaHVua0NvbmZpZywgYXJnLCBpc0hlYWRlcikge1xuICAgIGxldCB7IGV4cGFuZFJvd3MgfSA9IGFyZztcbiAgICBsZXQgY29udGVudCA9IHR5cGVvZiBjaHVua0NvbmZpZy5jb250ZW50ID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgY2h1bmtDb25maWcuY29udGVudChhcmcpIDpcbiAgICAgICAgY3JlYXRlRWxlbWVudCgndGFibGUnLCB7XG4gICAgICAgICAgICByb2xlOiAncHJlc2VudGF0aW9uJyxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogW1xuICAgICAgICAgICAgICAgIGNodW5rQ29uZmlnLnRhYmxlQ2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgIHNlY3Rpb25Db25maWcuc3luY1Jvd0hlaWdodHMgPyAnZmMtc2Nyb2xsZ3JpZC1zeW5jLXRhYmxlJyA6ICcnLFxuICAgICAgICAgICAgXS5qb2luKCcgJyksXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIG1pbldpZHRoOiBhcmcudGFibGVNaW5XaWR0aCxcbiAgICAgICAgICAgICAgICB3aWR0aDogYXJnLmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogZXhwYW5kUm93cyA/IGFyZy5jbGllbnRIZWlnaHQgOiAnJywgLy8gY3NzIGBoZWlnaHRgIG9uIGEgPHRhYmxlPiBzZXJ2ZXMgYXMgYSBtaW4taGVpZ2h0XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LCBhcmcudGFibGVDb2xHcm91cE5vZGUsIGNyZWF0ZUVsZW1lbnQoaXNIZWFkZXIgPyAndGhlYWQnIDogJ3Rib2R5Jywge1xuICAgICAgICAgICAgcm9sZTogJ3ByZXNlbnRhdGlvbicsXG4gICAgICAgIH0sIHR5cGVvZiBjaHVua0NvbmZpZy5yb3dDb250ZW50ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IGNodW5rQ29uZmlnLnJvd0NvbnRlbnQoYXJnKVxuICAgICAgICAgICAgOiBjaHVua0NvbmZpZy5yb3dDb250ZW50KSk7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG59XG5mdW5jdGlvbiBpc0NvbFByb3BzRXF1YWwoY29sczAsIGNvbHMxKSB7XG4gICAgcmV0dXJuIGlzQXJyYXlzRXF1YWwoY29sczAsIGNvbHMxLCBpc1Byb3BzRXF1YWwpO1xufVxuZnVuY3Rpb24gcmVuZGVyTWljcm9Db2xHcm91cChjb2xzLCBzaHJpbmtXaWR0aCkge1xuICAgIGxldCBjb2xOb2RlcyA9IFtdO1xuICAgIC8qXG4gICAgZm9yIENvbFByb3BzIHdpdGggc3BhbnMsIGl0IHdvdWxkIGhhdmUgYmVlbiBncmVhdCB0byBtYWtlIGEgc2luZ2xlIDxjb2wgc3Bhbj1cIlwiPlxuICAgIEhPV0VWRVIsIENocm9tZSB3YXMgZ2V0dGluZyBtZXNzaW5nIHVwIGRpc3RyaWJ1dGluZyB0aGUgd2lkdGggdG8gPHRkPi88dGg+IGVsZW1lbnRzIHdpdGggY29sc3BhbnMuXG4gICAgU09MVVRJT046IG1ha2luZyBpbmRpdmlkdWFsIDxjb2w+IGVsZW1lbnRzIG1ha2VzIENocm9tZSBiZWhhdmUuXG4gICAgKi9cbiAgICBmb3IgKGxldCBjb2xQcm9wcyBvZiBjb2xzKSB7XG4gICAgICAgIGxldCBzcGFuID0gY29sUHJvcHMuc3BhbiB8fCAxO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNwYW47IGkgKz0gMSkge1xuICAgICAgICAgICAgY29sTm9kZXMucHVzaChjcmVhdGVFbGVtZW50KFwiY29sXCIsIHsgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGNvbFByb3BzLndpZHRoID09PSAnc2hyaW5rJyA/IHNhbml0aXplU2hyaW5rV2lkdGgoc2hyaW5rV2lkdGgpIDogKGNvbFByb3BzLndpZHRoIHx8ICcnKSxcbiAgICAgICAgICAgICAgICAgICAgbWluV2lkdGg6IGNvbFByb3BzLm1pbldpZHRoIHx8ICcnLFxuICAgICAgICAgICAgICAgIH0gfSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCdjb2xncm91cCcsIHt9LCAuLi5jb2xOb2Rlcyk7XG59XG5mdW5jdGlvbiBzYW5pdGl6ZVNocmlua1dpZHRoKHNocmlua1dpZHRoKSB7XG4gICAgLyogd2h5IDQ/IGlmIHdlIGRvIDAsIGl0IHdpbGwga2lsbCBhbnkgYm9yZGVyLCB3aGljaCBhcmUgbmVlZGVkIGZvciBjb21wdXRlU21hbGxlc3RDZWxsV2lkdGhcbiAgICA0IGFjY291bnRzIGZvciAyIDItcGl4ZWwgYm9yZGVycy4gVE9ETzogYmV0dGVyIHNvbHV0aW9uPyAqL1xuICAgIHJldHVybiBzaHJpbmtXaWR0aCA9PSBudWxsID8gNCA6IHNocmlua1dpZHRoO1xufVxuZnVuY3Rpb24gaGFzU2hyaW5rV2lkdGgoY29scykge1xuICAgIGZvciAobGV0IGNvbCBvZiBjb2xzKSB7XG4gICAgICAgIGlmIChjb2wud2lkdGggPT09ICdzaHJpbmsnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRTY3JvbGxHcmlkQ2xhc3NOYW1lcyhsaXF1aWQsIGNvbnRleHQpIHtcbiAgICBsZXQgY2xhc3NOYW1lcyA9IFtcbiAgICAgICAgJ2ZjLXNjcm9sbGdyaWQnLFxuICAgICAgICBjb250ZXh0LnRoZW1lLmdldENsYXNzKCd0YWJsZScpLFxuICAgIF07XG4gICAgaWYgKGxpcXVpZCkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNjcm9sbGdyaWQtbGlxdWlkJyk7XG4gICAgfVxuICAgIHJldHVybiBjbGFzc05hbWVzO1xufVxuZnVuY3Rpb24gZ2V0U2VjdGlvbkNsYXNzTmFtZXMoc2VjdGlvbkNvbmZpZywgd2hvbGVUYWJsZVZHcm93KSB7XG4gICAgbGV0IGNsYXNzTmFtZXMgPSBbXG4gICAgICAgICdmYy1zY3JvbGxncmlkLXNlY3Rpb24nLFxuICAgICAgICBgZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLSR7c2VjdGlvbkNvbmZpZy50eXBlfWAsXG4gICAgICAgIHNlY3Rpb25Db25maWcuY2xhc3NOYW1lLCAvLyB1c2VkP1xuICAgIF07XG4gICAgaWYgKHdob2xlVGFibGVWR3JvdyAmJiBzZWN0aW9uQ29uZmlnLmxpcXVpZCAmJiBzZWN0aW9uQ29uZmlnLm1heEhlaWdodCA9PSBudWxsKSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLWxpcXVpZCcpO1xuICAgIH1cbiAgICBpZiAoc2VjdGlvbkNvbmZpZy5pc1N0aWNreSkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNjcm9sbGdyaWQtc2VjdGlvbi1zdGlja3knKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzTmFtZXM7XG59XG5mdW5jdGlvbiByZW5kZXJTY3JvbGxTaGltKGFyZykge1xuICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1zY3JvbGxncmlkLXN0aWNreS1zaGltXCIsIHN0eWxlOiB7XG4gICAgICAgICAgICB3aWR0aDogYXJnLmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgbWluV2lkdGg6IGFyZy50YWJsZU1pbldpZHRoLFxuICAgICAgICB9IH0pKTtcbn1cbmZ1bmN0aW9uIGdldFN0aWNreUhlYWRlckRhdGVzKG9wdGlvbnMpIHtcbiAgICBsZXQgeyBzdGlja3lIZWFkZXJEYXRlcyB9ID0gb3B0aW9ucztcbiAgICBpZiAoc3RpY2t5SGVhZGVyRGF0ZXMgPT0gbnVsbCB8fCBzdGlja3lIZWFkZXJEYXRlcyA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIHN0aWNreUhlYWRlckRhdGVzID0gb3B0aW9ucy5oZWlnaHQgPT09ICdhdXRvJyB8fCBvcHRpb25zLnZpZXdIZWlnaHQgPT09ICdhdXRvJztcbiAgICB9XG4gICAgcmV0dXJuIHN0aWNreUhlYWRlckRhdGVzO1xufVxuZnVuY3Rpb24gZ2V0U3RpY2t5Rm9vdGVyU2Nyb2xsYmFyKG9wdGlvbnMpIHtcbiAgICBsZXQgeyBzdGlja3lGb290ZXJTY3JvbGxiYXIgfSA9IG9wdGlvbnM7XG4gICAgaWYgKHN0aWNreUZvb3RlclNjcm9sbGJhciA9PSBudWxsIHx8IHN0aWNreUZvb3RlclNjcm9sbGJhciA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIHN0aWNreUZvb3RlclNjcm9sbGJhciA9IG9wdGlvbnMuaGVpZ2h0ID09PSAnYXV0bycgfHwgb3B0aW9ucy52aWV3SGVpZ2h0ID09PSAnYXV0byc7XG4gICAgfVxuICAgIHJldHVybiBzdGlja3lGb290ZXJTY3JvbGxiYXI7XG59XG5cbmNsYXNzIFNpbXBsZVNjcm9sbEdyaWQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzQ29scyA9IG1lbW9pemUoKGEpID0+IGEsIGlzQ29sUHJvcHNFcXVhbCk7IC8vIHNvIHdlIGdldCBzYW1lIGBjb2xzYCBwcm9wcyBldmVyeSB0aW1lXG4gICAgICAgIC8vIHl1Y2t5IHRvIG1lbW9pemUgVk5vZGVzLCBidXQgbXVjaCBtb3JlIGVmZmljaWVudCBmb3IgY29uc3VtZXJzXG4gICAgICAgIHRoaXMucmVuZGVyTWljcm9Db2xHcm91cCA9IG1lbW9pemUocmVuZGVyTWljcm9Db2xHcm91cCk7XG4gICAgICAgIHRoaXMuc2Nyb2xsZXJSZWZzID0gbmV3IFJlZk1hcCgpO1xuICAgICAgICB0aGlzLnNjcm9sbGVyRWxSZWZzID0gbmV3IFJlZk1hcCh0aGlzLl9oYW5kbGVTY3JvbGxlckVsLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgc2hyaW5rV2lkdGg6IG51bGwsXG4gICAgICAgICAgICBmb3JjZVlTY3JvbGxiYXJzOiBmYWxzZSxcbiAgICAgICAgICAgIHNjcm9sbGVyQ2xpZW50V2lkdGhzOiB7fSxcbiAgICAgICAgICAgIHNjcm9sbGVyQ2xpZW50SGVpZ2h0czoge30sXG4gICAgICAgIH07XG4gICAgICAgIC8vIFRPRE86IGNhbiBkbyBhIHJlYWxseSBzaW1wbGUgcHJpbnQtdmlldy4gZG9udCBuZWVkIHRvIGpvaW4gcm93c1xuICAgICAgICB0aGlzLmhhbmRsZVNpemluZyA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2FmZVNldFN0YXRlKE9iamVjdC5hc3NpZ24oeyBzaHJpbmtXaWR0aDogdGhpcy5jb21wdXRlU2hyaW5rV2lkdGgoKSB9LCB0aGlzLmNvbXB1dGVTY3JvbGxlckRpbXMoKSkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBzdGF0ZSwgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHNlY3Rpb25Db25maWdzID0gcHJvcHMuc2VjdGlvbnMgfHwgW107XG4gICAgICAgIGxldCBjb2xzID0gdGhpcy5wcm9jZXNzQ29scyhwcm9wcy5jb2xzKTtcbiAgICAgICAgbGV0IG1pY3JvQ29sR3JvdXBOb2RlID0gdGhpcy5yZW5kZXJNaWNyb0NvbEdyb3VwKGNvbHMsIHN0YXRlLnNocmlua1dpZHRoKTtcbiAgICAgICAgbGV0IGNsYXNzTmFtZXMgPSBnZXRTY3JvbGxHcmlkQ2xhc3NOYW1lcyhwcm9wcy5saXF1aWQsIGNvbnRleHQpO1xuICAgICAgICBpZiAocHJvcHMuY29sbGFwc2libGVXaWR0aCkge1xuICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1zY3JvbGxncmlkLWNvbGxhcHNpYmxlJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogbWFrZSBEUllcbiAgICAgICAgbGV0IGNvbmZpZ0NudCA9IHNlY3Rpb25Db25maWdzLmxlbmd0aDtcbiAgICAgICAgbGV0IGNvbmZpZ0kgPSAwO1xuICAgICAgICBsZXQgY3VycmVudENvbmZpZztcbiAgICAgICAgbGV0IGhlYWRTZWN0aW9uTm9kZXMgPSBbXTtcbiAgICAgICAgbGV0IGJvZHlTZWN0aW9uTm9kZXMgPSBbXTtcbiAgICAgICAgbGV0IGZvb3RTZWN0aW9uTm9kZXMgPSBbXTtcbiAgICAgICAgd2hpbGUgKGNvbmZpZ0kgPCBjb25maWdDbnQgJiYgKGN1cnJlbnRDb25maWcgPSBzZWN0aW9uQ29uZmlnc1tjb25maWdJXSkudHlwZSA9PT0gJ2hlYWRlcicpIHtcbiAgICAgICAgICAgIGhlYWRTZWN0aW9uTm9kZXMucHVzaCh0aGlzLnJlbmRlclNlY3Rpb24oY3VycmVudENvbmZpZywgbWljcm9Db2xHcm91cE5vZGUsIHRydWUpKTtcbiAgICAgICAgICAgIGNvbmZpZ0kgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoY29uZmlnSSA8IGNvbmZpZ0NudCAmJiAoY3VycmVudENvbmZpZyA9IHNlY3Rpb25Db25maWdzW2NvbmZpZ0ldKS50eXBlID09PSAnYm9keScpIHtcbiAgICAgICAgICAgIGJvZHlTZWN0aW9uTm9kZXMucHVzaCh0aGlzLnJlbmRlclNlY3Rpb24oY3VycmVudENvbmZpZywgbWljcm9Db2xHcm91cE5vZGUsIGZhbHNlKSk7XG4gICAgICAgICAgICBjb25maWdJICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGNvbmZpZ0kgPCBjb25maWdDbnQgJiYgKGN1cnJlbnRDb25maWcgPSBzZWN0aW9uQ29uZmlnc1tjb25maWdJXSkudHlwZSA9PT0gJ2Zvb3RlcicpIHtcbiAgICAgICAgICAgIGZvb3RTZWN0aW9uTm9kZXMucHVzaCh0aGlzLnJlbmRlclNlY3Rpb24oY3VycmVudENvbmZpZywgbWljcm9Db2xHcm91cE5vZGUsIHRydWUpKTtcbiAgICAgICAgICAgIGNvbmZpZ0kgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBmaXJlZm94IGJ1Zzogd2hlbiBzZXR0aW5nIGhlaWdodCBvbiB0YWJsZSBhbmQgdGhlcmUgaXMgYSB0aGVhZCBvciB0Zm9vdCxcbiAgICAgICAgLy8gdGhlIG5lY2Vzc2FyeSBoZWlnaHQ6MTAwJSBvbiB0aGUgbGlxdWlkLWhlaWdodCBib2R5IHNlY3Rpb24gZm9yY2VzIHRoZSAqd2hvbGUqIHRhYmxlIHRvIGJlIHRhbGxlci4gKGJ1ZyAjNTUyNClcbiAgICAgICAgLy8gdXNlIGdldENhblZHcm93V2l0aGluQ2VsbCBhcyBhIHdheSB0byBkZXRlY3QgdGFibGUtc3R1cGlkIGZpcmVmb3guXG4gICAgICAgIC8vIGlmIHNvLCB1c2UgYSBzaW1wbGVyIGRvbSBzdHJ1Y3R1cmUsIGphbSBldmVyeXRoaW5nIGludG8gYSBsb25lIHRib2R5LlxuICAgICAgICBsZXQgaXNCdWdneSA9ICFnZXRDYW5WR3Jvd1dpdGhpbkNlbGwoKTtcbiAgICAgICAgY29uc3Qgcm9sZUF0dHJzID0geyByb2xlOiAncm93Z3JvdXAnIH07XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCd0YWJsZScsIHtcbiAgICAgICAgICAgIHJvbGU6ICdncmlkJyxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lcy5qb2luKCcgJyksXG4gICAgICAgICAgICBzdHlsZTogeyBoZWlnaHQ6IHByb3BzLmhlaWdodCB9LFxuICAgICAgICB9LCBCb29sZWFuKCFpc0J1Z2d5ICYmIGhlYWRTZWN0aW9uTm9kZXMubGVuZ3RoKSAmJiBjcmVhdGVFbGVtZW50KCd0aGVhZCcsIHJvbGVBdHRycywgLi4uaGVhZFNlY3Rpb25Ob2RlcyksIEJvb2xlYW4oIWlzQnVnZ3kgJiYgYm9keVNlY3Rpb25Ob2Rlcy5sZW5ndGgpICYmIGNyZWF0ZUVsZW1lbnQoJ3Rib2R5Jywgcm9sZUF0dHJzLCAuLi5ib2R5U2VjdGlvbk5vZGVzKSwgQm9vbGVhbighaXNCdWdneSAmJiBmb290U2VjdGlvbk5vZGVzLmxlbmd0aCkgJiYgY3JlYXRlRWxlbWVudCgndGZvb3QnLCByb2xlQXR0cnMsIC4uLmZvb3RTZWN0aW9uTm9kZXMpLCBpc0J1Z2d5ICYmIGNyZWF0ZUVsZW1lbnQoJ3Rib2R5Jywgcm9sZUF0dHJzLCAuLi5oZWFkU2VjdGlvbk5vZGVzLCAuLi5ib2R5U2VjdGlvbk5vZGVzLCAuLi5mb290U2VjdGlvbk5vZGVzKSk7XG4gICAgfVxuICAgIHJlbmRlclNlY3Rpb24oc2VjdGlvbkNvbmZpZywgbWljcm9Db2xHcm91cE5vZGUsIGlzSGVhZGVyKSB7XG4gICAgICAgIGlmICgnb3V0ZXJDb250ZW50JyBpbiBzZWN0aW9uQ29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIHsga2V5OiBzZWN0aW9uQ29uZmlnLmtleSB9LCBzZWN0aW9uQ29uZmlnLm91dGVyQ29udGVudCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcInRyXCIsIHsga2V5OiBzZWN0aW9uQ29uZmlnLmtleSwgcm9sZTogXCJwcmVzZW50YXRpb25cIiwgY2xhc3NOYW1lOiBnZXRTZWN0aW9uQ2xhc3NOYW1lcyhzZWN0aW9uQ29uZmlnLCB0aGlzLnByb3BzLmxpcXVpZCkuam9pbignICcpIH0sIHRoaXMucmVuZGVyQ2h1bmtUZChzZWN0aW9uQ29uZmlnLCBtaWNyb0NvbEdyb3VwTm9kZSwgc2VjdGlvbkNvbmZpZy5jaHVuaywgaXNIZWFkZXIpKSk7XG4gICAgfVxuICAgIHJlbmRlckNodW5rVGQoc2VjdGlvbkNvbmZpZywgbWljcm9Db2xHcm91cE5vZGUsIGNodW5rQ29uZmlnLCBpc0hlYWRlcikge1xuICAgICAgICBpZiAoJ291dGVyQ29udGVudCcgaW4gY2h1bmtDb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybiBjaHVua0NvbmZpZy5vdXRlckNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IGZvcmNlWVNjcm9sbGJhcnMsIHNjcm9sbGVyQ2xpZW50V2lkdGhzLCBzY3JvbGxlckNsaWVudEhlaWdodHMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGxldCBuZWVkc1lTY3JvbGxpbmcgPSBnZXRBbGxvd1lTY3JvbGxpbmcocHJvcHMsIHNlY3Rpb25Db25maWcpOyAvLyBUT0RPOiBkbyBsYXppbHkuIGRvIGluIHNlY3Rpb24gY29uZmlnP1xuICAgICAgICBsZXQgaXNMaXF1aWQgPSBnZXRTZWN0aW9uSGFzTGlxdWlkSGVpZ2h0KHByb3BzLCBzZWN0aW9uQ29uZmlnKTtcbiAgICAgICAgLy8gZm9yIGAhcHJvcHMubGlxdWlkYCAtIGlzIFdIT0xFIHNjcm9sbGdyaWQgbmF0dXJhbCBoZWlnaHQ/XG4gICAgICAgIC8vIFRPRE86IGRvIHNhbWUgdGhpbmcgaW4gYWR2YW5jZWQgc2Nyb2xsZ3JpZD8gcHJvbGx5IG5vdCBiL2MgYWx3YXlzIGhhcyBob3Jpem9udGFsIHNjcm9sbGJhcnNcbiAgICAgICAgbGV0IG92ZXJmbG93WSA9ICFwcm9wcy5saXF1aWQgPyAndmlzaWJsZScgOlxuICAgICAgICAgICAgZm9yY2VZU2Nyb2xsYmFycyA/ICdzY3JvbGwnIDpcbiAgICAgICAgICAgICAgICAhbmVlZHNZU2Nyb2xsaW5nID8gJ2hpZGRlbicgOlxuICAgICAgICAgICAgICAgICAgICAnYXV0byc7XG4gICAgICAgIGxldCBzZWN0aW9uS2V5ID0gc2VjdGlvbkNvbmZpZy5rZXk7XG4gICAgICAgIGxldCBjb250ZW50ID0gcmVuZGVyQ2h1bmtDb250ZW50KHNlY3Rpb25Db25maWcsIGNodW5rQ29uZmlnLCB7XG4gICAgICAgICAgICB0YWJsZUNvbEdyb3VwTm9kZTogbWljcm9Db2xHcm91cE5vZGUsXG4gICAgICAgICAgICB0YWJsZU1pbldpZHRoOiAnJyxcbiAgICAgICAgICAgIGNsaWVudFdpZHRoOiAoIXByb3BzLmNvbGxhcHNpYmxlV2lkdGggJiYgc2Nyb2xsZXJDbGllbnRXaWR0aHNbc2VjdGlvbktleV0gIT09IHVuZGVmaW5lZCkgPyBzY3JvbGxlckNsaWVudFdpZHRoc1tzZWN0aW9uS2V5XSA6IG51bGwsXG4gICAgICAgICAgICBjbGllbnRIZWlnaHQ6IHNjcm9sbGVyQ2xpZW50SGVpZ2h0c1tzZWN0aW9uS2V5XSAhPT0gdW5kZWZpbmVkID8gc2Nyb2xsZXJDbGllbnRIZWlnaHRzW3NlY3Rpb25LZXldIDogbnVsbCxcbiAgICAgICAgICAgIGV4cGFuZFJvd3M6IHNlY3Rpb25Db25maWcuZXhwYW5kUm93cyxcbiAgICAgICAgICAgIHN5bmNSb3dIZWlnaHRzOiBmYWxzZSxcbiAgICAgICAgICAgIHJvd1N5bmNIZWlnaHRzOiBbXSxcbiAgICAgICAgICAgIHJlcG9ydFJvd0hlaWdodENoYW5nZTogKCkgPT4geyB9LFxuICAgICAgICB9LCBpc0hlYWRlcik7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KGlzSGVhZGVyID8gJ3RoJyA6ICd0ZCcsIHtcbiAgICAgICAgICAgIHJlZjogY2h1bmtDb25maWcuZWxSZWYsXG4gICAgICAgICAgICByb2xlOiAncHJlc2VudGF0aW9uJyxcbiAgICAgICAgfSwgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogYGZjLXNjcm9sbGVyLWhhcm5lc3Mke2lzTGlxdWlkID8gJyBmYy1zY3JvbGxlci1oYXJuZXNzLWxpcXVpZCcgOiAnJ31gIH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFNjcm9sbGVyLCB7IHJlZjogdGhpcy5zY3JvbGxlclJlZnMuY3JlYXRlUmVmKHNlY3Rpb25LZXkpLCBlbFJlZjogdGhpcy5zY3JvbGxlckVsUmVmcy5jcmVhdGVSZWYoc2VjdGlvbktleSksIG92ZXJmbG93WTogb3ZlcmZsb3dZLCBvdmVyZmxvd1g6ICFwcm9wcy5saXF1aWQgPyAndmlzaWJsZScgOiAnaGlkZGVuJyAvKiBuYXR1cmFsIGhlaWdodD8gKi8sIG1heEhlaWdodDogc2VjdGlvbkNvbmZpZy5tYXhIZWlnaHQsIGxpcXVpZDogaXNMaXF1aWQsIGxpcXVpZElzQWJzb2x1dGUgLy8gYmVjYXVzZSBpdHMgd2l0aGluIGEgaGFybmVzc1xuICAgICAgICAgICAgICAgIDogdHJ1ZSB9LCBjb250ZW50KSkpO1xuICAgIH1cbiAgICBfaGFuZGxlU2Nyb2xsZXJFbChzY3JvbGxlckVsLCBrZXkpIHtcbiAgICAgICAgbGV0IHNlY3Rpb24gPSBnZXRTZWN0aW9uQnlLZXkodGhpcy5wcm9wcy5zZWN0aW9ucywga2V5KTtcbiAgICAgICAgaWYgKHNlY3Rpb24pIHtcbiAgICAgICAgICAgIHNldFJlZihzZWN0aW9uLmNodW5rLnNjcm9sbGVyRWxSZWYsIHNjcm9sbGVyRWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLmhhbmRsZVNpemluZygpO1xuICAgICAgICB0aGlzLmNvbnRleHQuYWRkUmVzaXplSGFuZGxlcih0aGlzLmhhbmRsZVNpemluZyk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgLy8gVE9ETzogbmVlZCBiZXR0ZXIgc29sdXRpb24gd2hlbiBzdGF0ZSBjb250YWlucyBub24tc2l6aW5nIHRoaW5nc1xuICAgICAgICB0aGlzLmhhbmRsZVNpemluZygpO1xuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LnJlbW92ZVJlc2l6ZUhhbmRsZXIodGhpcy5oYW5kbGVTaXppbmcpO1xuICAgIH1cbiAgICBjb21wdXRlU2hyaW5rV2lkdGgoKSB7XG4gICAgICAgIHJldHVybiBoYXNTaHJpbmtXaWR0aCh0aGlzLnByb3BzLmNvbHMpXG4gICAgICAgICAgICA/IGNvbXB1dGVTaHJpbmtXaWR0aCh0aGlzLnNjcm9sbGVyRWxSZWZzLmdldEFsbCgpKVxuICAgICAgICAgICAgOiAwO1xuICAgIH1cbiAgICBjb21wdXRlU2Nyb2xsZXJEaW1zKCkge1xuICAgICAgICBsZXQgc2Nyb2xsYmFyV2lkdGggPSBnZXRTY3JvbGxiYXJXaWR0aHMoKTtcbiAgICAgICAgbGV0IHsgc2Nyb2xsZXJSZWZzLCBzY3JvbGxlckVsUmVmcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGZvcmNlWVNjcm9sbGJhcnMgPSBmYWxzZTtcbiAgICAgICAgbGV0IHNjcm9sbGVyQ2xpZW50V2lkdGhzID0ge307XG4gICAgICAgIGxldCBzY3JvbGxlckNsaWVudEhlaWdodHMgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgc2VjdGlvbktleSBpbiBzY3JvbGxlclJlZnMuY3VycmVudE1hcCkge1xuICAgICAgICAgICAgbGV0IHNjcm9sbGVyID0gc2Nyb2xsZXJSZWZzLmN1cnJlbnRNYXBbc2VjdGlvbktleV07XG4gICAgICAgICAgICBpZiAoc2Nyb2xsZXIgJiYgc2Nyb2xsZXIubmVlZHNZU2Nyb2xsaW5nKCkpIHtcbiAgICAgICAgICAgICAgICBmb3JjZVlTY3JvbGxiYXJzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBzZWN0aW9uIG9mIHRoaXMucHJvcHMuc2VjdGlvbnMpIHtcbiAgICAgICAgICAgIGxldCBzZWN0aW9uS2V5ID0gc2VjdGlvbi5rZXk7XG4gICAgICAgICAgICBsZXQgc2Nyb2xsZXJFbCA9IHNjcm9sbGVyRWxSZWZzLmN1cnJlbnRNYXBbc2VjdGlvbktleV07XG4gICAgICAgICAgICBpZiAoc2Nyb2xsZXJFbCkge1xuICAgICAgICAgICAgICAgIGxldCBoYXJuZXNzRWwgPSBzY3JvbGxlckVsLnBhcmVudE5vZGU7IC8vIFRPRE86IHdlaXJkIHdheSB0byBnZXQgdGhpcy4gbmVlZCBoYXJuZXNzIGIvYyBkb2Vzbid0IGluY2x1ZGUgdGFibGUgYm9yZGVyc1xuICAgICAgICAgICAgICAgIHNjcm9sbGVyQ2xpZW50V2lkdGhzW3NlY3Rpb25LZXldID0gTWF0aC5mbG9vcihoYXJuZXNzRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggLSAoZm9yY2VZU2Nyb2xsYmFyc1xuICAgICAgICAgICAgICAgICAgICA/IHNjcm9sbGJhcldpZHRoLnkgLy8gdXNlIGdsb2JhbCBiZWNhdXNlIHNjcm9sbGVyIG1pZ2h0IG5vdCBoYXZlIHNjcm9sbGJhcnMgeWV0IGJ1dCB3aWxsIG5lZWQgdGhlbSBpbiBmdXR1cmVcbiAgICAgICAgICAgICAgICAgICAgOiAwKSk7XG4gICAgICAgICAgICAgICAgc2Nyb2xsZXJDbGllbnRIZWlnaHRzW3NlY3Rpb25LZXldID0gTWF0aC5mbG9vcihoYXJuZXNzRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmb3JjZVlTY3JvbGxiYXJzLCBzY3JvbGxlckNsaWVudFdpZHRocywgc2Nyb2xsZXJDbGllbnRIZWlnaHRzIH07XG4gICAgfVxufVxuU2ltcGxlU2Nyb2xsR3JpZC5hZGRTdGF0ZUVxdWFsaXR5KHtcbiAgICBzY3JvbGxlckNsaWVudFdpZHRoczogaXNQcm9wc0VxdWFsLFxuICAgIHNjcm9sbGVyQ2xpZW50SGVpZ2h0czogaXNQcm9wc0VxdWFsLFxufSk7XG5mdW5jdGlvbiBnZXRTZWN0aW9uQnlLZXkoc2VjdGlvbnMsIGtleSkge1xuICAgIGZvciAobGV0IHNlY3Rpb24gb2Ygc2VjdGlvbnMpIHtcbiAgICAgICAgaWYgKHNlY3Rpb24ua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWN0aW9uO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5jbGFzcyBFdmVudENvbnRhaW5lciBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmhhbmRsZUVsID0gKGVsKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgICAgICBzZXRFbFNlZyhlbCwgdGhpcy5wcm9wcy5zZWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gY29udGV4dDtcbiAgICAgICAgY29uc3QgeyBzZWcgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCB7IGV2ZW50UmFuZ2UgfSA9IHNlZztcbiAgICAgICAgY29uc3QgeyB1aSB9ID0gZXZlbnRSYW5nZTtcbiAgICAgICAgY29uc3QgcmVuZGVyUHJvcHMgPSB7XG4gICAgICAgICAgICBldmVudDogbmV3IEV2ZW50SW1wbChjb250ZXh0LCBldmVudFJhbmdlLmRlZiwgZXZlbnRSYW5nZS5pbnN0YW5jZSksXG4gICAgICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXG4gICAgICAgICAgICB0aW1lVGV4dDogcHJvcHMudGltZVRleHQsXG4gICAgICAgICAgICB0ZXh0Q29sb3I6IHVpLnRleHRDb2xvcixcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdWkuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IHVpLmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgaXNEcmFnZ2FibGU6ICFwcm9wcy5kaXNhYmxlRHJhZ2dpbmcgJiYgY29tcHV0ZVNlZ0RyYWdnYWJsZShzZWcsIGNvbnRleHQpLFxuICAgICAgICAgICAgaXNTdGFydFJlc2l6YWJsZTogIXByb3BzLmRpc2FibGVSZXNpemluZyAmJiBjb21wdXRlU2VnU3RhcnRSZXNpemFibGUoc2VnLCBjb250ZXh0KSxcbiAgICAgICAgICAgIGlzRW5kUmVzaXphYmxlOiAhcHJvcHMuZGlzYWJsZVJlc2l6aW5nICYmIGNvbXB1dGVTZWdFbmRSZXNpemFibGUoc2VnKSxcbiAgICAgICAgICAgIGlzTWlycm9yOiBCb29sZWFuKHByb3BzLmlzRHJhZ2dpbmcgfHwgcHJvcHMuaXNSZXNpemluZyB8fCBwcm9wcy5pc0RhdGVTZWxlY3RpbmcpLFxuICAgICAgICAgICAgaXNTdGFydDogQm9vbGVhbihzZWcuaXNTdGFydCksXG4gICAgICAgICAgICBpc0VuZDogQm9vbGVhbihzZWcuaXNFbmQpLFxuICAgICAgICAgICAgaXNQYXN0OiBCb29sZWFuKHByb3BzLmlzUGFzdCksXG4gICAgICAgICAgICBpc0Z1dHVyZTogQm9vbGVhbihwcm9wcy5pc0Z1dHVyZSksXG4gICAgICAgICAgICBpc1RvZGF5OiBCb29sZWFuKHByb3BzLmlzVG9kYXkpLFxuICAgICAgICAgICAgaXNTZWxlY3RlZDogQm9vbGVhbihwcm9wcy5pc1NlbGVjdGVkKSxcbiAgICAgICAgICAgIGlzRHJhZ2dpbmc6IEJvb2xlYW4ocHJvcHMuaXNEcmFnZ2luZyksXG4gICAgICAgICAgICBpc1Jlc2l6aW5nOiBCb29sZWFuKHByb3BzLmlzUmVzaXppbmcpLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoQ29udGVudENvbnRhaW5lciwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMgLyogY29udGFpbnMgY2hpbGRyZW4gKi8sIHsgZWxSZWY6IHRoaXMuaGFuZGxlRWwsIGVsQ2xhc3NlczogW1xuICAgICAgICAgICAgICAgIC4uLmdldEV2ZW50Q2xhc3NOYW1lcyhyZW5kZXJQcm9wcyksXG4gICAgICAgICAgICAgICAgLi4uc2VnLmV2ZW50UmFuZ2UudWkuY2xhc3NOYW1lcyxcbiAgICAgICAgICAgICAgICAuLi4ocHJvcHMuZWxDbGFzc2VzIHx8IFtdKSxcbiAgICAgICAgICAgIF0sIHJlbmRlclByb3BzOiByZW5kZXJQcm9wcywgZ2VuZXJhdG9yTmFtZTogXCJldmVudENvbnRlbnRcIiwgY3VzdG9tR2VuZXJhdG9yOiBvcHRpb25zLmV2ZW50Q29udGVudCwgZGVmYXVsdEdlbmVyYXRvcjogcHJvcHMuZGVmYXVsdEdlbmVyYXRvciwgY2xhc3NOYW1lR2VuZXJhdG9yOiBvcHRpb25zLmV2ZW50Q2xhc3NOYW1lcywgZGlkTW91bnQ6IG9wdGlvbnMuZXZlbnREaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMuZXZlbnRXaWxsVW5tb3VudCB9KSkpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICAgIGlmICh0aGlzLmVsICYmIHRoaXMucHJvcHMuc2VnICE9PSBwcmV2UHJvcHMuc2VnKSB7XG4gICAgICAgICAgICBzZXRFbFNlZyh0aGlzLmVsLCB0aGlzLnByb3BzLnNlZyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIHNob3VsZCBub3QgYmUgYSBwdXJlY29tcG9uZW50XG5jbGFzcyBTdGFuZGFyZEV2ZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgb3B0aW9ucyB9ID0gY29udGV4dDtcbiAgICAgICAgbGV0IHsgc2VnIH0gPSBwcm9wcztcbiAgICAgICAgbGV0IHsgdWkgfSA9IHNlZy5ldmVudFJhbmdlO1xuICAgICAgICBsZXQgdGltZUZvcm1hdCA9IG9wdGlvbnMuZXZlbnRUaW1lRm9ybWF0IHx8IHByb3BzLmRlZmF1bHRUaW1lRm9ybWF0O1xuICAgICAgICBsZXQgdGltZVRleHQgPSBidWlsZFNlZ1RpbWVUZXh0KHNlZywgdGltZUZvcm1hdCwgY29udGV4dCwgcHJvcHMuZGVmYXVsdERpc3BsYXlFdmVudFRpbWUsIHByb3BzLmRlZmF1bHREaXNwbGF5RXZlbnRFbmQpO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRXZlbnRDb250YWluZXIsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzIC8qIGluY2x1ZGVzIGVsUmVmICovLCB7IGVsVGFnOiBcImFcIiwgZWxTdHlsZToge1xuICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiB1aS5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHVpLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgIH0sIGVsQXR0cnM6IGdldFNlZ0FuY2hvckF0dHJzKHNlZywgY29udGV4dCksIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlcklubmVyQ29udGVudCQxLCB0aW1lVGV4dDogdGltZVRleHQgfSksIChJbm5lckNvbnRlbnQsIGV2ZW50Q29udGVudEFyZykgPT4gKGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KElubmVyQ29udGVudCwgeyBlbFRhZzogXCJkaXZcIiwgZWxDbGFzc2VzOiBbJ2ZjLWV2ZW50LW1haW4nXSwgZWxTdHlsZTogeyBjb2xvcjogZXZlbnRDb250ZW50QXJnLnRleHRDb2xvciB9IH0pLFxuICAgICAgICAgICAgQm9vbGVhbihldmVudENvbnRlbnRBcmcuaXNTdGFydFJlc2l6YWJsZSkgJiYgKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZXZlbnQtcmVzaXplciBmYy1ldmVudC1yZXNpemVyLXN0YXJ0XCIgfSkpLFxuICAgICAgICAgICAgQm9vbGVhbihldmVudENvbnRlbnRBcmcuaXNFbmRSZXNpemFibGUpICYmIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXJlc2l6ZXIgZmMtZXZlbnQtcmVzaXplci1lbmRcIiB9KSkpKSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbmRlcklubmVyQ29udGVudCQxKGlubmVyUHJvcHMpIHtcbiAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZXZlbnQtbWFpbi1mcmFtZVwiIH0sXG4gICAgICAgIGlubmVyUHJvcHMudGltZVRleHQgJiYgKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZXZlbnQtdGltZVwiIH0sIGlubmVyUHJvcHMudGltZVRleHQpKSxcbiAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1ldmVudC10aXRsZS1jb250YWluZXJcIiB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1ldmVudC10aXRsZSBmYy1zdGlja3lcIiB9LCBpbm5lclByb3BzLmV2ZW50LnRpdGxlIHx8IGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIFwiXFx1MDBBMFwiKSkpKSk7XG59XG5cbmNvbnN0IE5vd0luZGljYXRvckNvbnRhaW5lciA9IChwcm9wcykgPT4gKGNyZWF0ZUVsZW1lbnQoVmlld0NvbnRleHRUeXBlLkNvbnN1bWVyLCBudWxsLCAoY29udGV4dCkgPT4ge1xuICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgbGV0IHJlbmRlclByb3BzID0ge1xuICAgICAgICBpc0F4aXM6IHByb3BzLmlzQXhpcyxcbiAgICAgICAgZGF0ZTogY29udGV4dC5kYXRlRW52LnRvRGF0ZShwcm9wcy5kYXRlKSxcbiAgICAgICAgdmlldzogY29udGV4dC52aWV3QXBpLFxuICAgIH07XG4gICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KENvbnRlbnRDb250YWluZXIsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzIC8qIGluY2x1ZGVzIGNoaWxkcmVuICovLCB7IGVsVGFnOiBwcm9wcy5lbFRhZyB8fCAnZGl2JywgcmVuZGVyUHJvcHM6IHJlbmRlclByb3BzLCBnZW5lcmF0b3JOYW1lOiBcIm5vd0luZGljYXRvckNvbnRlbnRcIiwgY3VzdG9tR2VuZXJhdG9yOiBvcHRpb25zLm5vd0luZGljYXRvckNvbnRlbnQsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy5ub3dJbmRpY2F0b3JDbGFzc05hbWVzLCBkaWRNb3VudDogb3B0aW9ucy5ub3dJbmRpY2F0b3JEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMubm93SW5kaWNhdG9yV2lsbFVubW91bnQgfSkpKTtcbn0pKTtcblxuY29uc3QgREFZX05VTV9GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoeyBkYXk6ICdudW1lcmljJyB9KTtcbmNsYXNzIERheUNlbGxDb250YWluZXIgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5yZWZpbmVSZW5kZXJQcm9wcyA9IG1lbW9pemVPYmpBcmcocmVmaW5lUmVuZGVyUHJvcHMpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSBjb250ZXh0O1xuICAgICAgICBsZXQgcmVuZGVyUHJvcHMgPSB0aGlzLnJlZmluZVJlbmRlclByb3BzKHtcbiAgICAgICAgICAgIGRhdGU6IHByb3BzLmRhdGUsXG4gICAgICAgICAgICBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsXG4gICAgICAgICAgICB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlLFxuICAgICAgICAgICAgaXNNb250aFN0YXJ0OiBwcm9wcy5pc01vbnRoU3RhcnQgfHwgZmFsc2UsXG4gICAgICAgICAgICBzaG93RGF5TnVtYmVyOiBwcm9wcy5zaG93RGF5TnVtYmVyLFxuICAgICAgICAgICAgZXh0cmFSZW5kZXJQcm9wczogcHJvcHMuZXh0cmFSZW5kZXJQcm9wcyxcbiAgICAgICAgICAgIHZpZXdBcGk6IGNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICAgIGRhdGVFbnY6IGNvbnRleHQuZGF0ZUVudixcbiAgICAgICAgICAgIG1vbnRoU3RhcnRGb3JtYXQ6IG9wdGlvbnMubW9udGhTdGFydEZvcm1hdCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChDb250ZW50Q29udGFpbmVyLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcyAvKiBpbmNsdWRlcyBjaGlsZHJlbiAqLywgeyBlbENsYXNzZXM6IFtcbiAgICAgICAgICAgICAgICAuLi5nZXREYXlDbGFzc05hbWVzKHJlbmRlclByb3BzLCBjb250ZXh0LnRoZW1lKSxcbiAgICAgICAgICAgICAgICAuLi4ocHJvcHMuZWxDbGFzc2VzIHx8IFtdKSxcbiAgICAgICAgICAgIF0sIGVsQXR0cnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMuZWxBdHRycyksIChyZW5kZXJQcm9wcy5pc0Rpc2FibGVkID8ge30gOiB7ICdkYXRhLWRhdGUnOiBmb3JtYXREYXlTdHJpbmcocHJvcHMuZGF0ZSkgfSkpLCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGdlbmVyYXRvck5hbWU6IFwiZGF5Q2VsbENvbnRlbnRcIiwgY3VzdG9tR2VuZXJhdG9yOiBvcHRpb25zLmRheUNlbGxDb250ZW50LCBkZWZhdWx0R2VuZXJhdG9yOiBwcm9wcy5kZWZhdWx0R2VuZXJhdG9yLCBjbGFzc05hbWVHZW5lcmF0b3I6IFxuICAgICAgICAgICAgLy8gZG9uJ3QgdXNlIGN1c3RvbSBjbGFzc05hbWVzIGlmIGRpc2FibGVkXG4gICAgICAgICAgICByZW5kZXJQcm9wcy5pc0Rpc2FibGVkID8gdW5kZWZpbmVkIDogb3B0aW9ucy5kYXlDZWxsQ2xhc3NOYW1lcywgZGlkTW91bnQ6IG9wdGlvbnMuZGF5Q2VsbERpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy5kYXlDZWxsV2lsbFVubW91bnQgfSkpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYXNDdXN0b21EYXlDZWxsQ29udGVudChvcHRpb25zKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4ob3B0aW9ucy5kYXlDZWxsQ29udGVudCB8fCBoYXNDdXN0b21SZW5kZXJpbmdIYW5kbGVyKCdkYXlDZWxsQ29udGVudCcsIG9wdGlvbnMpKTtcbn1cbmZ1bmN0aW9uIHJlZmluZVJlbmRlclByb3BzKHJhdykge1xuICAgIGxldCB7IGRhdGUsIGRhdGVFbnYsIGRhdGVQcm9maWxlLCBpc01vbnRoU3RhcnQgfSA9IHJhdztcbiAgICBsZXQgZGF5TWV0YSA9IGdldERhdGVNZXRhKGRhdGUsIHJhdy50b2RheVJhbmdlLCBudWxsLCBkYXRlUHJvZmlsZSk7XG4gICAgbGV0IGRheU51bWJlclRleHQgPSByYXcuc2hvd0RheU51bWJlciA/IChkYXRlRW52LmZvcm1hdChkYXRlLCBpc01vbnRoU3RhcnQgPyByYXcubW9udGhTdGFydEZvcm1hdCA6IERBWV9OVU1fRk9STUFUKSkgOiAnJztcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBkYXRlOiBkYXRlRW52LnRvRGF0ZShkYXRlKSwgdmlldzogcmF3LnZpZXdBcGkgfSwgZGF5TWV0YSksIHsgaXNNb250aFN0YXJ0LFxuICAgICAgICBkYXlOdW1iZXJUZXh0IH0pLCByYXcuZXh0cmFSZW5kZXJQcm9wcyk7XG59XG5cbmNsYXNzIEJnRXZlbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBzZWcgfSA9IHByb3BzO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRXZlbnRDb250YWluZXIsIHsgZWxUYWc6IFwiZGl2XCIsIGVsQ2xhc3NlczogWydmYy1iZy1ldmVudCddLCBlbFN0eWxlOiB7IGJhY2tncm91bmRDb2xvcjogc2VnLmV2ZW50UmFuZ2UudWkuYmFja2dyb3VuZENvbG9yIH0sIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlcklubmVyQ29udGVudCwgc2VnOiBzZWcsIHRpbWVUZXh0OiBcIlwiLCBpc0RyYWdnaW5nOiBmYWxzZSwgaXNSZXNpemluZzogZmFsc2UsIGlzRGF0ZVNlbGVjdGluZzogZmFsc2UsIGlzU2VsZWN0ZWQ6IGZhbHNlLCBpc1Bhc3Q6IHByb3BzLmlzUGFzdCwgaXNGdXR1cmU6IHByb3BzLmlzRnV0dXJlLCBpc1RvZGF5OiBwcm9wcy5pc1RvZGF5LCBkaXNhYmxlRHJhZ2dpbmc6IHRydWUsIGRpc2FibGVSZXNpemluZzogdHJ1ZSB9KSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVuZGVySW5uZXJDb250ZW50KHByb3BzKSB7XG4gICAgbGV0IHsgdGl0bGUgfSA9IHByb3BzLmV2ZW50O1xuICAgIHJldHVybiB0aXRsZSAmJiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1ldmVudC10aXRsZVwiIH0sIHByb3BzLmV2ZW50LnRpdGxlKSk7XG59XG5mdW5jdGlvbiByZW5kZXJGaWxsKGZpbGxUeXBlKSB7XG4gICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBgZmMtJHtmaWxsVHlwZX1gIH0pKTtcbn1cblxuY29uc3QgV2Vla051bWJlckNvbnRhaW5lciA9IChwcm9wcykgPT4gKGNyZWF0ZUVsZW1lbnQoVmlld0NvbnRleHRUeXBlLkNvbnN1bWVyLCBudWxsLCAoY29udGV4dCkgPT4ge1xuICAgIGxldCB7IGRhdGVFbnYsIG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgbGV0IHsgZGF0ZSB9ID0gcHJvcHM7XG4gICAgbGV0IGZvcm1hdCA9IG9wdGlvbnMud2Vla051bWJlckZvcm1hdCB8fCBwcm9wcy5kZWZhdWx0Rm9ybWF0O1xuICAgIGxldCBudW0gPSBkYXRlRW52LmNvbXB1dGVXZWVrTnVtYmVyKGRhdGUpOyAvLyBUT0RPOiBzb21laG93IHVzZSBmb3IgZm9ybWF0dGluZyBhcyB3ZWxsP1xuICAgIGxldCB0ZXh0ID0gZGF0ZUVudi5mb3JtYXQoZGF0ZSwgZm9ybWF0KTtcbiAgICBsZXQgcmVuZGVyUHJvcHMgPSB7IG51bSwgdGV4dCwgZGF0ZSB9O1xuICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChDb250ZW50Q29udGFpbmVyIC8vIHdoeSBpc24ndCBXZWVrTnVtYmVyQ29udGVudEFyZyBiZWluZyBhdXRvLWRldGVjdGVkP1xuICAgICwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMgLyogaW5jbHVkZXMgY2hpbGRyZW4gKi8sIHsgcmVuZGVyUHJvcHM6IHJlbmRlclByb3BzLCBnZW5lcmF0b3JOYW1lOiBcIndlZWtOdW1iZXJDb250ZW50XCIsIGN1c3RvbUdlbmVyYXRvcjogb3B0aW9ucy53ZWVrTnVtYmVyQ29udGVudCwgZGVmYXVsdEdlbmVyYXRvcjogcmVuZGVySW5uZXIsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy53ZWVrTnVtYmVyQ2xhc3NOYW1lcywgZGlkTW91bnQ6IG9wdGlvbnMud2Vla051bWJlckRpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy53ZWVrTnVtYmVyV2lsbFVubW91bnQgfSkpKTtcbn0pKTtcbmZ1bmN0aW9uIHJlbmRlcklubmVyKGlubmVyUHJvcHMpIHtcbiAgICByZXR1cm4gaW5uZXJQcm9wcy50ZXh0O1xufVxuXG5jb25zdCBQQURESU5HX0ZST01fVklFV1BPUlQgPSAxMDtcbmNsYXNzIFBvcG92ZXIgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHRpdGxlSWQ6IGdldFVuaXF1ZURvbUlkKCksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUm9vdEVsID0gKGVsKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJvb3RFbCA9IGVsO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMuZWxSZWYpIHtcbiAgICAgICAgICAgICAgICBzZXRSZWYodGhpcy5wcm9wcy5lbFJlZiwgZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBUcmlnZ2VyZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgKmFueXdoZXJlKiBpbiB0aGUgZG9jdW1lbnQsIGZvciB0aGUgYXV0b0hpZGUgZmVhdHVyZVxuICAgICAgICB0aGlzLmhhbmRsZURvY3VtZW50TW91c2VEb3duID0gKGV2KSA9PiB7XG4gICAgICAgICAgICAvLyBvbmx5IGhpZGUgdGhlIHBvcG92ZXIgaWYgdGhlIGNsaWNrIGhhcHBlbmVkIG91dHNpZGUgdGhlIHBvcG92ZXJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0VmlhUm9vdChldik7XG4gICAgICAgICAgICBpZiAoIXRoaXMucm9vdEVsLmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNsb3NlQ2xpY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVEb2N1bWVudEtleURvd24gPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGlmIChldi5rZXkgPT09ICdFc2NhcGUnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVDbG9zZUNsaWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlQ2xvc2VDbGljayA9ICgpID0+IHtcbiAgICAgICAgICAgIGxldCB7IG9uQ2xvc2UgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBpZiAob25DbG9zZSkge1xuICAgICAgICAgICAgICAgIG9uQ2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyB0aGVtZSwgb3B0aW9ucyB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgeyBwcm9wcywgc3RhdGUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBjbGFzc05hbWVzID0gW1xuICAgICAgICAgICAgJ2ZjLXBvcG92ZXInLFxuICAgICAgICAgICAgdGhlbWUuZ2V0Q2xhc3MoJ3BvcG92ZXInKSxcbiAgICAgICAgXS5jb25jYXQocHJvcHMuZXh0cmFDbGFzc05hbWVzIHx8IFtdKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVBvcnRhbChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzLmV4dHJhQXR0cnMsIHsgaWQ6IHByb3BzLmlkLCBjbGFzc05hbWU6IGNsYXNzTmFtZXMuam9pbignICcpLCBcImFyaWEtbGFiZWxsZWRieVwiOiBzdGF0ZS50aXRsZUlkLCByZWY6IHRoaXMuaGFuZGxlUm9vdEVsIH0pLFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogJ2ZjLXBvcG92ZXItaGVhZGVyICcgKyB0aGVtZS5nZXRDbGFzcygncG9wb3ZlckhlYWRlcicpIH0sXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwiZmMtcG9wb3Zlci10aXRsZVwiLCBpZDogc3RhdGUudGl0bGVJZCB9LCBwcm9wcy50aXRsZSksXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6ICdmYy1wb3BvdmVyLWNsb3NlICcgKyB0aGVtZS5nZXRJY29uQ2xhc3MoJ2Nsb3NlJyksIHRpdGxlOiBvcHRpb25zLmNsb3NlSGludCwgb25DbGljazogdGhpcy5oYW5kbGVDbG9zZUNsaWNrIH0pKSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6ICdmYy1wb3BvdmVyLWJvZHkgJyArIHRoZW1lLmdldENsYXNzKCdwb3BvdmVyQ29udGVudCcpIH0sIHByb3BzLmNoaWxkcmVuKSksIHByb3BzLnBhcmVudEVsKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlRG9jdW1lbnRNb3VzZURvd24pO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVEb2N1bWVudEtleURvd24pO1xuICAgICAgICB0aGlzLnVwZGF0ZVNpemUoKTtcbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlRG9jdW1lbnRNb3VzZURvd24pO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVEb2N1bWVudEtleURvd24pO1xuICAgIH1cbiAgICB1cGRhdGVTaXplKCkge1xuICAgICAgICBsZXQgeyBpc1J0bCB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgeyBhbGlnbm1lbnRFbCwgYWxpZ25HcmlkVG9wIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBsZXQgeyByb290RWwgfSA9IHRoaXM7XG4gICAgICAgIGxldCBhbGlnbm1lbnRSZWN0ID0gY29tcHV0ZUNsaXBwZWRDbGllbnRSZWN0KGFsaWdubWVudEVsKTtcbiAgICAgICAgaWYgKGFsaWdubWVudFJlY3QpIHtcbiAgICAgICAgICAgIGxldCBwb3BvdmVyRGltcyA9IHJvb3RFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIC8vIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHZpZXdwb3J0XG4gICAgICAgICAgICBsZXQgcG9wb3ZlclRvcCA9IGFsaWduR3JpZFRvcFxuICAgICAgICAgICAgICAgID8gZWxlbWVudENsb3Nlc3QoYWxpZ25tZW50RWwsICcuZmMtc2Nyb2xsZ3JpZCcpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcFxuICAgICAgICAgICAgICAgIDogYWxpZ25tZW50UmVjdC50b3A7XG4gICAgICAgICAgICBsZXQgcG9wb3ZlckxlZnQgPSBpc1J0bCA/IGFsaWdubWVudFJlY3QucmlnaHQgLSBwb3BvdmVyRGltcy53aWR0aCA6IGFsaWdubWVudFJlY3QubGVmdDtcbiAgICAgICAgICAgIC8vIGNvbnN0cmFpblxuICAgICAgICAgICAgcG9wb3ZlclRvcCA9IE1hdGgubWF4KHBvcG92ZXJUb3AsIFBBRERJTkdfRlJPTV9WSUVXUE9SVCk7XG4gICAgICAgICAgICBwb3BvdmVyTGVmdCA9IE1hdGgubWluKHBvcG92ZXJMZWZ0LCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggLSBQQURESU5HX0ZST01fVklFV1BPUlQgLSBwb3BvdmVyRGltcy53aWR0aCk7XG4gICAgICAgICAgICBwb3BvdmVyTGVmdCA9IE1hdGgubWF4KHBvcG92ZXJMZWZ0LCBQQURESU5HX0ZST01fVklFV1BPUlQpO1xuICAgICAgICAgICAgbGV0IG9yaWdpbiA9IHJvb3RFbC5vZmZzZXRQYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBhcHBseVN0eWxlKHJvb3RFbCwge1xuICAgICAgICAgICAgICAgIHRvcDogcG9wb3ZlclRvcCAtIG9yaWdpbi50b3AsXG4gICAgICAgICAgICAgICAgbGVmdDogcG9wb3ZlckxlZnQgLSBvcmlnaW4ubGVmdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBNb3JlUG9wb3ZlciBleHRlbmRzIERhdGVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmhhbmRsZVJvb3RFbCA9IChyb290RWwpID0+IHtcbiAgICAgICAgICAgIHRoaXMucm9vdEVsID0gcm9vdEVsO1xuICAgICAgICAgICAgaWYgKHJvb3RFbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgZWw6IHJvb3RFbCxcbiAgICAgICAgICAgICAgICAgICAgdXNlRXZlbnRDZW50ZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LnVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBvcHRpb25zLCBkYXRlRW52IH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBzdGFydERhdGUsIHRvZGF5UmFuZ2UsIGRhdGVQcm9maWxlIH0gPSBwcm9wcztcbiAgICAgICAgbGV0IHRpdGxlID0gZGF0ZUVudi5mb3JtYXQoc3RhcnREYXRlLCBvcHRpb25zLmRheVBvcG92ZXJGb3JtYXQpO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRGF5Q2VsbENvbnRhaW5lciwgeyBlbFJlZjogdGhpcy5oYW5kbGVSb290RWwsIGRhdGU6IHN0YXJ0RGF0ZSwgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLCB0b2RheVJhbmdlOiB0b2RheVJhbmdlIH0sIChJbm5lckNvbnRlbnQsIHJlbmRlclByb3BzLCBlbEF0dHJzKSA9PiAoY3JlYXRlRWxlbWVudChQb3BvdmVyLCB7IGVsUmVmOiBlbEF0dHJzLnJlZiwgaWQ6IHByb3BzLmlkLCB0aXRsZTogdGl0bGUsIGV4dHJhQ2xhc3NOYW1lczogWydmYy1tb3JlLXBvcG92ZXInXS5jb25jYXQoZWxBdHRycy5jbGFzc05hbWUgfHwgW10pLCBleHRyYUF0dHJzOiBlbEF0dHJzIC8qIFRPRE86IG1ha2UgdGhlc2UgdGltZS1iYXNlZCB3aGVuIG5vdCB3aG9sZS1kYXk/ICovLCBwYXJlbnRFbDogcHJvcHMucGFyZW50RWwsIGFsaWdubWVudEVsOiBwcm9wcy5hbGlnbm1lbnRFbCwgYWxpZ25HcmlkVG9wOiBwcm9wcy5hbGlnbkdyaWRUb3AsIG9uQ2xvc2U6IHByb3BzLm9uQ2xvc2UgfSxcbiAgICAgICAgICAgIGhhc0N1c3RvbURheUNlbGxDb250ZW50KG9wdGlvbnMpICYmIChjcmVhdGVFbGVtZW50KElubmVyQ29udGVudCwgeyBlbFRhZzogXCJkaXZcIiwgZWxDbGFzc2VzOiBbJ2ZjLW1vcmUtcG9wb3Zlci1taXNjJ10gfSkpLFxuICAgICAgICAgICAgcHJvcHMuY2hpbGRyZW4pKSkpO1xuICAgIH1cbiAgICBxdWVyeUhpdChwb3NpdGlvbkxlZnQsIHBvc2l0aW9uVG9wLCBlbFdpZHRoLCBlbEhlaWdodCkge1xuICAgICAgICBsZXQgeyByb290RWwsIHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBpZiAocG9zaXRpb25MZWZ0ID49IDAgJiYgcG9zaXRpb25MZWZ0IDwgZWxXaWR0aCAmJlxuICAgICAgICAgICAgcG9zaXRpb25Ub3AgPj0gMCAmJiBwb3NpdGlvblRvcCA8IGVsSGVpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSxcbiAgICAgICAgICAgICAgICBkYXRlU3BhbjogT2JqZWN0LmFzc2lnbih7IGFsbERheTogIXByb3BzLmZvcmNlVGltZWQsIHJhbmdlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogcHJvcHMuc3RhcnREYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBwcm9wcy5lbmREYXRlLFxuICAgICAgICAgICAgICAgICAgICB9IH0sIHByb3BzLmV4dHJhRGF0ZVNwYW4pLFxuICAgICAgICAgICAgICAgIGRheUVsOiByb290RWwsXG4gICAgICAgICAgICAgICAgcmVjdDoge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBlbFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBib3R0b206IGVsSGVpZ2h0LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbGF5ZXI6IDEsIC8vIGltcG9ydGFudCB3aGVuIGNvbXBhcmluZyB3aXRoIGhpdHMgZnJvbSBvdGhlciBjb21wb25lbnRzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuY2xhc3MgTW9yZUxpbmtDb250YWluZXIgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGlzUG9wb3Zlck9wZW46IGZhbHNlLFxuICAgICAgICAgICAgcG9wb3ZlcklkOiBnZXRVbmlxdWVEb21JZCgpLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUxpbmtFbCA9IChsaW5rRWwpID0+IHtcbiAgICAgICAgICAgIHRoaXMubGlua0VsID0gbGlua0VsO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMuZWxSZWYpIHtcbiAgICAgICAgICAgICAgICBzZXRSZWYodGhpcy5wcm9wcy5lbFJlZiwgbGlua0VsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVDbGljayA9IChldikgPT4ge1xuICAgICAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgICAgICBsZXQgeyBtb3JlTGlua0NsaWNrIH0gPSBjb250ZXh0Lm9wdGlvbnM7XG4gICAgICAgICAgICBsZXQgZGF0ZSA9IGNvbXB1dGVSYW5nZShwcm9wcykuc3RhcnQ7XG4gICAgICAgICAgICBmdW5jdGlvbiBidWlsZFB1YmxpY1NlZyhzZWcpIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBkZWYsIGluc3RhbmNlLCByYW5nZSB9ID0gc2VnLmV2ZW50UmFuZ2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IG5ldyBFdmVudEltcGwoY29udGV4dCwgZGVmLCBpbnN0YW5jZSksXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBjb250ZXh0LmRhdGVFbnYudG9EYXRlKHJhbmdlLnN0YXJ0KSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBjb250ZXh0LmRhdGVFbnYudG9EYXRlKHJhbmdlLmVuZCksXG4gICAgICAgICAgICAgICAgICAgIGlzU3RhcnQ6IHNlZy5pc1N0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBpc0VuZDogc2VnLmlzRW5kLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1vcmVMaW5rQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBtb3JlTGlua0NsaWNrID0gbW9yZUxpbmtDbGljayh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGUsXG4gICAgICAgICAgICAgICAgICAgIGFsbERheTogQm9vbGVhbihwcm9wcy5hbGxEYXlEYXRlKSxcbiAgICAgICAgICAgICAgICAgICAgYWxsU2VnczogcHJvcHMuYWxsU2Vncy5tYXAoYnVpbGRQdWJsaWNTZWcpLFxuICAgICAgICAgICAgICAgICAgICBoaWRkZW5TZWdzOiBwcm9wcy5oaWRkZW5TZWdzLm1hcChidWlsZFB1YmxpY1NlZyksXG4gICAgICAgICAgICAgICAgICAgIGpzRXZlbnQ6IGV2LFxuICAgICAgICAgICAgICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW1vcmVMaW5rQ2xpY2sgfHwgbW9yZUxpbmtDbGljayA9PT0gJ3BvcG92ZXInKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGlzUG9wb3Zlck9wZW46IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgbW9yZUxpbmtDbGljayA9PT0gJ3N0cmluZycpIHsgLy8gYSB2aWV3IG5hbWVcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNhbGVuZGFyQXBpLnpvb21UbyhkYXRlLCBtb3JlTGlua0NsaWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVQb3BvdmVyQ2xvc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgaXNQb3BvdmVyT3BlbjogZmFsc2UgfSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIHN0YXRlIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVmlld0NvbnRleHRUeXBlLkNvbnN1bWVyLCBudWxsLCAoY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgbGV0IHsgdmlld0FwaSwgb3B0aW9ucywgY2FsZW5kYXJBcGkgfSA9IGNvbnRleHQ7XG4gICAgICAgICAgICBsZXQgeyBtb3JlTGlua1RleHQgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBsZXQgeyBtb3JlQ250IH0gPSBwcm9wcztcbiAgICAgICAgICAgIGxldCByYW5nZSA9IGNvbXB1dGVSYW5nZShwcm9wcyk7XG4gICAgICAgICAgICBsZXQgdGV4dCA9IHR5cGVvZiBtb3JlTGlua1RleHQgPT09ICdmdW5jdGlvbicgLy8gVE9ETzogZXZlbnR1YWxseSB1c2UgZm9ybWF0V2l0aE9yZGluYWxzXG4gICAgICAgICAgICAgICAgPyBtb3JlTGlua1RleHQuY2FsbChjYWxlbmRhckFwaSwgbW9yZUNudClcbiAgICAgICAgICAgICAgICA6IGArJHttb3JlQ250fSAke21vcmVMaW5rVGV4dH1gO1xuICAgICAgICAgICAgbGV0IGhpbnQgPSBmb3JtYXRXaXRoT3JkaW5hbHMob3B0aW9ucy5tb3JlTGlua0hpbnQsIFttb3JlQ250XSwgdGV4dCk7XG4gICAgICAgICAgICBsZXQgcmVuZGVyUHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgbnVtOiBtb3JlQ250LFxuICAgICAgICAgICAgICAgIHNob3J0VGV4dDogYCske21vcmVDbnR9YCxcbiAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgIHZpZXc6IHZpZXdBcGksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgICAgIEJvb2xlYW4ocHJvcHMubW9yZUNudCkgJiYgKGNyZWF0ZUVsZW1lbnQoQ29udGVudENvbnRhaW5lciwgeyBlbFRhZzogcHJvcHMuZWxUYWcgfHwgJ2EnLCBlbFJlZjogdGhpcy5oYW5kbGVMaW5rRWwsIGVsQ2xhc3NlczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uKHByb3BzLmVsQ2xhc3NlcyB8fCBbXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmMtbW9yZS1saW5rJyxcbiAgICAgICAgICAgICAgICAgICAgXSwgZWxTdHlsZTogcHJvcHMuZWxTdHlsZSwgZWxBdHRyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByb3BzLmVsQXR0cnMpLCBjcmVhdGVBcmlhQ2xpY2tBdHRycyh0aGlzLmhhbmRsZUNsaWNrKSksIHsgdGl0bGU6IGhpbnQsICdhcmlhLWV4cGFuZGVkJzogc3RhdGUuaXNQb3BvdmVyT3BlbiwgJ2FyaWEtY29udHJvbHMnOiBzdGF0ZS5pc1BvcG92ZXJPcGVuID8gc3RhdGUucG9wb3ZlcklkIDogJycgfSksIHJlbmRlclByb3BzOiByZW5kZXJQcm9wcywgZ2VuZXJhdG9yTmFtZTogXCJtb3JlTGlua0NvbnRlbnRcIiwgY3VzdG9tR2VuZXJhdG9yOiBvcHRpb25zLm1vcmVMaW5rQ29udGVudCwgZGVmYXVsdEdlbmVyYXRvcjogcHJvcHMuZGVmYXVsdEdlbmVyYXRvciB8fCByZW5kZXJNb3JlTGlua0lubmVyLCBjbGFzc05hbWVHZW5lcmF0b3I6IG9wdGlvbnMubW9yZUxpbmtDbGFzc05hbWVzLCBkaWRNb3VudDogb3B0aW9ucy5tb3JlTGlua0RpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy5tb3JlTGlua1dpbGxVbm1vdW50IH0sIHByb3BzLmNoaWxkcmVuKSksXG4gICAgICAgICAgICAgICAgc3RhdGUuaXNQb3BvdmVyT3BlbiAmJiAoY3JlYXRlRWxlbWVudChNb3JlUG9wb3ZlciwgeyBpZDogc3RhdGUucG9wb3ZlcklkLCBzdGFydERhdGU6IHJhbmdlLnN0YXJ0LCBlbmREYXRlOiByYW5nZS5lbmQsIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSwgZXh0cmFEYXRlU3BhbjogcHJvcHMuZXh0cmFEYXRlU3BhbiwgcGFyZW50RWw6IHRoaXMucGFyZW50RWwsIGFsaWdubWVudEVsOiBwcm9wcy5hbGlnbm1lbnRFbFJlZiA/XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5hbGlnbm1lbnRFbFJlZi5jdXJyZW50IDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGlua0VsLCBhbGlnbkdyaWRUb3A6IHByb3BzLmFsaWduR3JpZFRvcCwgZm9yY2VUaW1lZDogcHJvcHMuZm9yY2VUaW1lZCwgb25DbG9zZTogdGhpcy5oYW5kbGVQb3BvdmVyQ2xvc2UgfSwgcHJvcHMucG9wb3ZlckNvbnRlbnQoKSkpKSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlUGFyZW50RWwoKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVBhcmVudEVsKCk7XG4gICAgfVxuICAgIHVwZGF0ZVBhcmVudEVsKCkge1xuICAgICAgICBpZiAodGhpcy5saW5rRWwpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50RWwgPSBlbGVtZW50Q2xvc2VzdCh0aGlzLmxpbmtFbCwgJy5mYy12aWV3LWhhcm5lc3MnKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbmRlck1vcmVMaW5rSW5uZXIocHJvcHMpIHtcbiAgICByZXR1cm4gcHJvcHMudGV4dDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVSYW5nZShwcm9wcykge1xuICAgIGlmIChwcm9wcy5hbGxEYXlEYXRlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGFydDogcHJvcHMuYWxsRGF5RGF0ZSxcbiAgICAgICAgICAgIGVuZDogYWRkRGF5cyhwcm9wcy5hbGxEYXlEYXRlLCAxKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgbGV0IHsgaGlkZGVuU2VncyB9ID0gcHJvcHM7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IGNvbXB1dGVFYXJsaWVzdFNlZ1N0YXJ0KGhpZGRlblNlZ3MpLFxuICAgICAgICBlbmQ6IGNvbXB1dGVMYXRlc3RTZWdFbmQoaGlkZGVuU2VncyksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVFYXJsaWVzdFNlZ1N0YXJ0KHNlZ3MpIHtcbiAgICByZXR1cm4gc2Vncy5yZWR1Y2UocGlja0VhcmxpZXN0U3RhcnQpLmV2ZW50UmFuZ2UucmFuZ2Uuc3RhcnQ7XG59XG5mdW5jdGlvbiBwaWNrRWFybGllc3RTdGFydChzZWcwLCBzZWcxKSB7XG4gICAgcmV0dXJuIHNlZzAuZXZlbnRSYW5nZS5yYW5nZS5zdGFydCA8IHNlZzEuZXZlbnRSYW5nZS5yYW5nZS5zdGFydCA/IHNlZzAgOiBzZWcxO1xufVxuZnVuY3Rpb24gY29tcHV0ZUxhdGVzdFNlZ0VuZChzZWdzKSB7XG4gICAgcmV0dXJuIHNlZ3MucmVkdWNlKHBpY2tMYXRlc3RFbmQpLmV2ZW50UmFuZ2UucmFuZ2UuZW5kO1xufVxuZnVuY3Rpb24gcGlja0xhdGVzdEVuZChzZWcwLCBzZWcxKSB7XG4gICAgcmV0dXJuIHNlZzAuZXZlbnRSYW5nZS5yYW5nZS5lbmQgPiBzZWcxLmV2ZW50UmFuZ2UucmFuZ2UuZW5kID8gc2VnMCA6IHNlZzE7XG59XG5cbmNsYXNzIFN0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IFtdO1xuICAgIH1cbiAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgZm9yIChsZXQgaGFuZGxlciBvZiB0aGlzLmhhbmRsZXJzKSB7XG4gICAgICAgICAgICBoYW5kbGVyKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdWJzY3JpYmUoaGFuZGxlcikge1xuICAgICAgICB0aGlzLmhhbmRsZXJzLnB1c2goaGFuZGxlcik7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBoYW5kbGVyKHRoaXMuY3VycmVudFZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLypcblN1YnNjcmliZXJzIHdpbGwgZ2V0IGEgTElTVCBvZiBDdXN0b21SZW5kZXJpbmdzXG4qL1xuY2xhc3MgQ3VzdG9tUmVuZGVyaW5nU3RvcmUgZXh0ZW5kcyBTdG9yZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubWFwID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICAvLyBmb3IgY29uc2lzdGVudCBvcmRlclxuICAgIGhhbmRsZShjdXN0b21SZW5kZXJpbmcpIHtcbiAgICAgICAgY29uc3QgeyBtYXAgfSA9IHRoaXM7XG4gICAgICAgIGxldCB1cGRhdGVkID0gZmFsc2U7XG4gICAgICAgIGlmIChjdXN0b21SZW5kZXJpbmcuaXNBY3RpdmUpIHtcbiAgICAgICAgICAgIG1hcC5zZXQoY3VzdG9tUmVuZGVyaW5nLmlkLCBjdXN0b21SZW5kZXJpbmcpO1xuICAgICAgICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWFwLmhhcyhjdXN0b21SZW5kZXJpbmcuaWQpKSB7XG4gICAgICAgICAgICBtYXAuZGVsZXRlKGN1c3RvbVJlbmRlcmluZy5pZCk7XG4gICAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlZCkge1xuICAgICAgICAgICAgdGhpcy5zZXQobWFwKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IHsgZWxlbWVudENsb3Nlc3QgYXMgJCwgbWVtb2l6ZU9iakFyZyBhcyBBLCBCYXNlQ29tcG9uZW50IGFzIEIsIENvbnRlbnRDb250YWluZXIgYXMgQywgRGVsYXllZFJ1bm5lciBhcyBELCBpc1Byb3BzRXF1YWwgYXMgRSwgRW1pdHRlciBhcyBGLCBnZXRJbml0aWFsRGF0ZSBhcyBHLCByYW5nZUNvbnRhaW5zTWFya2VyIGFzIEgsIGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSBhcyBJLCByZWR1Y2VDdXJyZW50RGF0ZSBhcyBKLCByZWR1Y2VFdmVudFN0b3JlIGFzIEssIHJlem9uZUV2ZW50U3RvcmVEYXRlcyBhcyBMLCBtZXJnZVJhd09wdGlvbnMgYXMgTSwgQkFTRV9PUFRJT05fUkVGSU5FUlMgYXMgTiwgQ0FMRU5EQVJfTElTVEVORVJfUkVGSU5FUlMgYXMgTywgQ0FMRU5EQVJfT1BUSU9OX1JFRklORVJTIGFzIFAsIENPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTIGFzIFEsIFZJRVdfT1BUSU9OX1JFRklORVJTIGFzIFIsIERhdGVFbnYgYXMgUywgVGhlbWUgYXMgVCwgRGF0ZVByb2ZpbGVHZW5lcmF0b3IgYXMgVSwgVmlld0NvbnRleHRUeXBlIGFzIFYsIGNyZWF0ZUV2ZW50VWkgYXMgVywgcGFyc2VCdXNpbmVzc0hvdXJzIGFzIFgsIHNldFJlZiBhcyBZLCBJbnRlcmFjdGlvbiBhcyBaLCBnZXRFbFNlZyBhcyBfLCBtYXBIYXNoIGFzIGEsIGdldFNsb3RDbGFzc05hbWVzIGFzIGEkLCBFdmVudEltcGwgYXMgYTAsIGxpc3RlbkJ5U2VsZWN0b3IgYXMgYTEsIGxpc3RlblRvSG92ZXJCeVNlbGVjdG9yIGFzIGEyLCBQdXJlQ29tcG9uZW50IGFzIGEzLCBidWlsZFZpZXdDb250ZXh0IGFzIGE0LCBnZXRVbmlxdWVEb21JZCBhcyBhNSwgcGFyc2VJbnRlcmFjdGlvblNldHRpbmdzIGFzIGE2LCBpbnRlcmFjdGlvblNldHRpbmdzU3RvcmUgYXMgYTcsIGdldE5vdyBhcyBhOCwgQ2FsZW5kYXJJbXBsIGFzIGE5LCBkaWZmRGF0ZXMgYXMgYUEsIHJlbW92ZUV4YWN0IGFzIGFCLCBtZW1vaXplQXJyYXlsaWtlIGFzIGFDLCBtZW1vaXplSGFzaGxpa2UgYXMgYUQsIGludGVyc2VjdFJlY3RzIGFzIGFFLCBwb2ludEluc2lkZVJlY3QgYXMgYUYsIGNvbnN0cmFpblBvaW50IGFzIGFHLCBnZXRSZWN0Q2VudGVyIGFzIGFILCBkaWZmUG9pbnRzIGFzIGFJLCB0cmFuc2xhdGVSZWN0IGFzIGFKLCBjb21wYXJlT2JqcyBhcyBhSywgY29sbGVjdEZyb21IYXNoIGFzIGFMLCBmaW5kRWxlbWVudHMgYXMgYU0sIGZpbmREaXJlY3RDaGlsZHJlbiBhcyBhTiwgcmVtb3ZlRWxlbWVudCBhcyBhTywgYXBwbHlTdHlsZSBhcyBhUCwgZWxlbWVudE1hdGNoZXMgYXMgYVEsIGdldEV2ZW50VGFyZ2V0VmlhUm9vdCBhcyBhUiwgcGFyc2VDbGFzc05hbWVzIGFzIGFTLCBnZXRDYW5WR3Jvd1dpdGhpbkNlbGwgYXMgYVQsIG1lcmdlRXZlbnRTdG9yZXMgYXMgYVUsIGdldFJlbGV2YW50RXZlbnRzIGFzIGFWLCBldmVudFR1cGxlVG9TdG9yZSBhcyBhVywgY29tYmluZUV2ZW50VWlzIGFzIGFYLCBTcGxpdHRlciBhcyBhWSwgZ2V0RGF5Q2xhc3NOYW1lcyBhcyBhWiwgZ2V0RGF0ZU1ldGEgYXMgYV8sIGZsdXNoU3luYyBhcyBhYSwgQ2FsZW5kYXJSb290IGFzIGFiLCBSZW5kZXJJZCBhcyBhYywgZW5zdXJlRWxIYXNTdHlsZXMgYXMgYWQsIGFwcGx5U3R5bGVQcm9wIGFzIGFlLCBzbGljZUV2ZW50U3RvcmUgYXMgYWYsIEpzb25SZXF1ZXN0RXJyb3IgYXMgYWcsIGNyZWF0ZUNvbnRleHQgYXMgYWgsIHJlZmluZVByb3BzIGFzIGFpLCBjcmVhdGVFdmVudEluc3RhbmNlIGFzIGFqLCBwYXJzZUV2ZW50RGVmIGFzIGFrLCByZWZpbmVFdmVudERlZiBhcyBhbCwgcGFkU3RhcnQgYXMgYW0sIGlzSW50IGFzIGFuLCBwYXJzZUZpZWxkU3BlY3MgYXMgYW8sIGNvbXBhcmVCeUZpZWxkU3BlY3MgYXMgYXAsIGZsZXhpYmxlQ29tcGFyZSBhcyBhcSwgcHJldmVudFNlbGVjdGlvbiBhcyBhciwgYWxsb3dTZWxlY3Rpb24gYXMgYXMsIHByZXZlbnRDb250ZXh0TWVudSBhcyBhdCwgYWxsb3dDb250ZXh0TWVudSBhcyBhdSwgY29tcGFyZU51bWJlcnMgYXMgYXYsIGVuYWJsZUN1cnNvciBhcyBhdywgZGlzYWJsZUN1cnNvciBhcyBheCwgY29tcHV0ZVZpc2libGVEYXlSYW5nZSBhcyBheSwgaXNNdWx0aURheVJhbmdlIGFzIGF6LCBidWlsZFZpZXdDbGFzc05hbWVzIGFzIGIsIFNpbXBsZVNjcm9sbEdyaWQgYXMgYiQsIGJ1aWxkTmF2TGlua0F0dHJzIGFzIGIwLCBwcmV2ZW50RGVmYXVsdCBhcyBiMSwgd2hlblRyYW5zaXRpb25Eb25lIGFzIGIyLCBjb21wdXRlSW5uZXJSZWN0IGFzIGIzLCBjb21wdXRlRWRnZXMgYXMgYjQsIGdldENsaXBwaW5nUGFyZW50cyBhcyBiNSwgY29tcHV0ZVJlY3QgYXMgYjYsIHJhbmdlc0VxdWFsIGFzIGI3LCByYW5nZXNJbnRlcnNlY3QgYXMgYjgsIHJhbmdlQ29udGFpbnNSYW5nZSBhcyBiOSwgU2VnSGllcmFyY2h5IGFzIGJBLCBidWlsZEVudHJ5S2V5IGFzIGJCLCBnZXRFbnRyeVNwYW5FbmQgYXMgYkMsIGJpbmFyeVNlYXJjaCBhcyBiRCwgZ3JvdXBJbnRlcnNlY3RpbmdFbnRyaWVzIGFzIGJFLCBpbnRlcnNlY3RTcGFucyBhcyBiRiwgaW50ZXJhY3Rpb25TZXR0aW5nc1RvU3RvcmUgYXMgYkcsIEVsZW1lbnREcmFnZ2luZyBhcyBiSCwgY29uZmlnIGFzIGJJLCBwYXJzZURyYWdNZXRhIGFzIGJKLCBEYXlIZWFkZXIgYXMgYkssIGNvbXB1dGVGYWxsYmFja0hlYWRlckZvcm1hdCBhcyBiTCwgVGFibGVEYXRlQ2VsbCBhcyBiTSwgVGFibGVEb3dDZWxsIGFzIGJOLCBEYXlTZXJpZXNNb2RlbCBhcyBiTywgaGFzQmdSZW5kZXJpbmcgYXMgYlAsIGJ1aWxkU2VnVGltZVRleHQgYXMgYlEsIHNvcnRFdmVudFNlZ3MgYXMgYlIsIGdldFNlZ01ldGEgYXMgYlMsIGJ1aWxkRXZlbnRSYW5nZUtleSBhcyBiVCwgZ2V0U2VnQW5jaG9yQXR0cnMgYXMgYlUsIERheVRhYmxlTW9kZWwgYXMgYlYsIFNsaWNlciBhcyBiVywgYXBwbHlNdXRhdGlvblRvRXZlbnRTdG9yZSBhcyBiWCwgaXNQcm9wc1ZhbGlkIGFzIGJZLCBpc0ludGVyYWN0aW9uVmFsaWQgYXMgYlosIGlzRGF0ZVNlbGVjdGlvblZhbGlkIGFzIGJfLCBQb3NpdGlvbkNhY2hlIGFzIGJhLCBTY3JvbGxDb250cm9sbGVyIGFzIGJiLCBFbGVtZW50U2Nyb2xsQ29udHJvbGxlciBhcyBiYywgV2luZG93U2Nyb2xsQ29udHJvbGxlciBhcyBiZCwgRGF0ZUNvbXBvbmVudCBhcyBiZSwgaXNEYXRlU3BhbnNFcXVhbCBhcyBiZiwgYWRkTXMgYXMgYmcsIGFkZFdlZWtzIGFzIGJoLCBkaWZmV2Vla3MgYXMgYmksIGRpZmZXaG9sZVdlZWtzIGFzIGJqLCBkaWZmRGF5QW5kVGltZSBhcyBiaywgZGlmZkRheXMgYXMgYmwsIGlzVmFsaWREYXRlIGFzIGJtLCBhc0NsZWFuRGF5cyBhcyBibiwgbXVsdGlwbHlEdXJhdGlvbiBhcyBibywgYWRkRHVyYXRpb25zIGFzIGJwLCBhc1JvdWdoTWludXRlcyBhcyBicSwgYXNSb3VnaFNlY29uZHMgYXMgYnIsIGFzUm91Z2hNcyBhcyBicywgd2hvbGVEaXZpZGVEdXJhdGlvbnMgYXMgYnQsIGZvcm1hdElzb1RpbWVTdHJpbmcgYXMgYnUsIGZvcm1hdERheVN0cmluZyBhcyBidiwgYnVpbGRJc29TdHJpbmcgYXMgYncsIGZvcm1hdElzb01vbnRoU3RyIGFzIGJ4LCBOYW1lZFRpbWVab25lSW1wbCBhcyBieSwgcGFyc2UgYXMgYnosIGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvciBhcyBjLCBoYXNTaHJpbmtXaWR0aCBhcyBjMCwgcmVuZGVyTWljcm9Db2xHcm91cCBhcyBjMSwgZ2V0U2Nyb2xsR3JpZENsYXNzTmFtZXMgYXMgYzIsIGdldFNlY3Rpb25DbGFzc05hbWVzIGFzIGMzLCBnZXRTZWN0aW9uSGFzTGlxdWlkSGVpZ2h0IGFzIGM0LCBnZXRBbGxvd1lTY3JvbGxpbmcgYXMgYzUsIHJlbmRlckNodW5rQ29udGVudCBhcyBjNiwgY29tcHV0ZVNocmlua1dpZHRoIGFzIGM3LCBzYW5pdGl6ZVNocmlua1dpZHRoIGFzIGM4LCBpc0NvbFByb3BzRXF1YWwgYXMgYzksIHJlbmRlclNjcm9sbFNoaW0gYXMgY2EsIGdldFN0aWNreUZvb3RlclNjcm9sbGJhciBhcyBjYiwgZ2V0U3RpY2t5SGVhZGVyRGF0ZXMgYXMgY2MsIFNjcm9sbGVyIGFzIGNkLCBnZXRTY3JvbGxiYXJXaWR0aHMgYXMgY2UsIFJlZk1hcCBhcyBjZiwgZ2V0SXNSdGxTY3JvbGxiYXJPbkxlZnQgYXMgY2csIE5vd1RpbWVyIGFzIGNoLCBTY3JvbGxSZXNwb25kZXIgYXMgY2ksIFN0YW5kYXJkRXZlbnQgYXMgY2osIE5vd0luZGljYXRvckNvbnRhaW5lciBhcyBjaywgRGF5Q2VsbENvbnRhaW5lciBhcyBjbCwgaGFzQ3VzdG9tRGF5Q2VsbENvbnRlbnQgYXMgY20sIEV2ZW50Q29udGFpbmVyIGFzIGNuLCByZW5kZXJGaWxsIGFzIGNvLCBCZ0V2ZW50IGFzIGNwLCBXZWVrTnVtYmVyQ29udGFpbmVyIGFzIGNxLCBNb3JlTGlua0NvbnRhaW5lciBhcyBjciwgY29tcHV0ZUVhcmxpZXN0U2VnU3RhcnQgYXMgY3MsIFZpZXdDb250YWluZXIgYXMgY3QsIHRyaWdnZXJEYXRlU2VsZWN0IGFzIGN1LCBnZXREZWZhdWx0RXZlbnRFbmQgYXMgY3YsIGluamVjdFN0eWxlcyBhcyBjdywgYnVpbGRFbEF0dHJzIGFzIGN4LCBDdXN0b21SZW5kZXJpbmdTdG9yZSBhcyBjeSwgY3JlYXRlRHVyYXRpb24gYXMgZCwgQkFTRV9PUFRJT05fREVGQVVMVFMgYXMgZSwgYXJyYXlUb0hhc2ggYXMgZiwgZ3VpZCBhcyBnLCBmaWx0ZXJIYXNoIGFzIGgsIGlzQXJyYXlzRXF1YWwgYXMgaSwgYnVpbGRFdmVudFNvdXJjZVJlZmluZXJzIGFzIGosIGZvcm1hdFdpdGhPcmRpbmFscyBhcyBrLCBidWlsZFJhbmdlQXBpV2l0aFRpbWVab25lIGFzIGwsIG1lcmdlUHJvcHMgYXMgbSwgaWRlbnRpdHkgYXMgbiwgaW50ZXJzZWN0UmFuZ2VzIGFzIG8sIHBhcnNlRXZlbnRTb3VyY2UgYXMgcCwgc3RhcnRPZkRheSBhcyBxLCByZXF1ZXN0SnNvbiBhcyByLCBzdWJ0cmFjdER1cmF0aW9ucyBhcyBzLCBhZGREYXlzIGFzIHQsIHVucHJvbWlzaWZ5IGFzIHUsIGhhc2hWYWx1ZXNUb0FycmF5IGFzIHYsIGJ1aWxkRXZlbnRBcGlzIGFzIHcsIGNyZWF0ZUZvcm1hdHRlciBhcyB4LCBkaWZmV2hvbGVEYXlzIGFzIHksIG1lbW9pemUgYXMgeiB9O1xuIiwgImltcG9ydCB7IG0gYXMgbWVyZ2VQcm9wcywgZyBhcyBndWlkLCBpIGFzIGlzQXJyYXlzRXF1YWwsIFQgYXMgVGhlbWUsIGEgYXMgbWFwSGFzaCwgQiBhcyBCYXNlQ29tcG9uZW50LCBWIGFzIFZpZXdDb250ZXh0VHlwZSwgQyBhcyBDb250ZW50Q29udGFpbmVyLCBiIGFzIGJ1aWxkVmlld0NsYXNzTmFtZXMsIGMgYXMgZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yLCBkIGFzIGNyZWF0ZUR1cmF0aW9uLCBlIGFzIEJBU0VfT1BUSU9OX0RFRkFVTFRTLCBmIGFzIGFycmF5VG9IYXNoLCBoIGFzIGZpbHRlckhhc2gsIGogYXMgYnVpbGRFdmVudFNvdXJjZVJlZmluZXJzLCBwIGFzIHBhcnNlRXZlbnRTb3VyY2UsIGsgYXMgZm9ybWF0V2l0aE9yZGluYWxzLCB1IGFzIHVucHJvbWlzaWZ5LCBsIGFzIGJ1aWxkUmFuZ2VBcGlXaXRoVGltZVpvbmUsIG4gYXMgaWRlbnRpdHksIHIgYXMgcmVxdWVzdEpzb24sIHMgYXMgc3VidHJhY3REdXJhdGlvbnMsIG8gYXMgaW50ZXJzZWN0UmFuZ2VzLCBxIGFzIHN0YXJ0T2ZEYXksIHQgYXMgYWRkRGF5cywgdiBhcyBoYXNoVmFsdWVzVG9BcnJheSwgdyBhcyBidWlsZEV2ZW50QXBpcywgRCBhcyBEZWxheWVkUnVubmVyLCB4IGFzIGNyZWF0ZUZvcm1hdHRlciwgeSBhcyBkaWZmV2hvbGVEYXlzLCB6IGFzIG1lbW9pemUsIEEgYXMgbWVtb2l6ZU9iakFyZywgRSBhcyBpc1Byb3BzRXF1YWwsIEYgYXMgRW1pdHRlciwgRyBhcyBnZXRJbml0aWFsRGF0ZSwgSCBhcyByYW5nZUNvbnRhaW5zTWFya2VyLCBJIGFzIGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSwgSiBhcyByZWR1Y2VDdXJyZW50RGF0ZSwgSyBhcyByZWR1Y2VFdmVudFN0b3JlLCBMIGFzIHJlem9uZUV2ZW50U3RvcmVEYXRlcywgTSBhcyBtZXJnZVJhd09wdGlvbnMsIE4gYXMgQkFTRV9PUFRJT05fUkVGSU5FUlMsIE8gYXMgQ0FMRU5EQVJfTElTVEVORVJfUkVGSU5FUlMsIFAgYXMgQ0FMRU5EQVJfT1BUSU9OX1JFRklORVJTLCBRIGFzIENPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTLCBSIGFzIFZJRVdfT1BUSU9OX1JFRklORVJTLCBTIGFzIERhdGVFbnYsIFUgYXMgRGF0ZVByb2ZpbGVHZW5lcmF0b3IsIFcgYXMgY3JlYXRlRXZlbnRVaSwgWCBhcyBwYXJzZUJ1c2luZXNzSG91cnMsIFkgYXMgc2V0UmVmLCBaIGFzIEludGVyYWN0aW9uLCBfIGFzIGdldEVsU2VnLCAkIGFzIGVsZW1lbnRDbG9zZXN0LCBhMCBhcyBFdmVudEltcGwsIGExIGFzIGxpc3RlbkJ5U2VsZWN0b3IsIGEyIGFzIGxpc3RlblRvSG92ZXJCeVNlbGVjdG9yLCBhMyBhcyBQdXJlQ29tcG9uZW50LCBhNCBhcyBidWlsZFZpZXdDb250ZXh0LCBhNSBhcyBnZXRVbmlxdWVEb21JZCwgYTYgYXMgcGFyc2VJbnRlcmFjdGlvblNldHRpbmdzLCBhNyBhcyBpbnRlcmFjdGlvblNldHRpbmdzU3RvcmUsIGE4IGFzIGdldE5vdywgYTkgYXMgQ2FsZW5kYXJJbXBsLCBhYSBhcyBmbHVzaFN5bmMsIGFiIGFzIENhbGVuZGFyUm9vdCwgYWMgYXMgUmVuZGVySWQsIGFkIGFzIGVuc3VyZUVsSGFzU3R5bGVzLCBhZSBhcyBhcHBseVN0eWxlUHJvcCwgYWYgYXMgc2xpY2VFdmVudFN0b3JlIH0gZnJvbSAnLi9pbnRlcm5hbC1jb21tb24uanMnO1xuZXhwb3J0IHsgYWcgYXMgSnNvblJlcXVlc3RFcnJvciB9IGZyb20gJy4vaW50ZXJuYWwtY29tbW9uLmpzJztcbmltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIGNyZWF0ZVJlZiwgRnJhZ21lbnQsIHJlbmRlciB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgJ3ByZWFjdC9jb21wYXQnO1xuXG5jb25zdCBnbG9iYWxMb2NhbGVzID0gW107XG5cbmNvbnN0IE1JTklNQUxfUkFXX0VOX0xPQ0FMRSA9IHtcbiAgICBjb2RlOiAnZW4nLFxuICAgIHdlZWs6IHtcbiAgICAgICAgZG93OiAwLFxuICAgICAgICBkb3k6IDQsIC8vIDQgZGF5cyBuZWVkIHRvIGJlIHdpdGhpbiB0aGUgeWVhciB0byBiZSBjb25zaWRlcmVkIHRoZSBmaXJzdCB3ZWVrXG4gICAgfSxcbiAgICBkaXJlY3Rpb246ICdsdHInLFxuICAgIGJ1dHRvblRleHQ6IHtcbiAgICAgICAgcHJldjogJ3ByZXYnLFxuICAgICAgICBuZXh0OiAnbmV4dCcsXG4gICAgICAgIHByZXZZZWFyOiAncHJldiB5ZWFyJyxcbiAgICAgICAgbmV4dFllYXI6ICduZXh0IHllYXInLFxuICAgICAgICB5ZWFyOiAneWVhcicsXG4gICAgICAgIHRvZGF5OiAndG9kYXknLFxuICAgICAgICBtb250aDogJ21vbnRoJyxcbiAgICAgICAgd2VlazogJ3dlZWsnLFxuICAgICAgICBkYXk6ICdkYXknLFxuICAgICAgICBsaXN0OiAnbGlzdCcsXG4gICAgfSxcbiAgICB3ZWVrVGV4dDogJ1cnLFxuICAgIHdlZWtUZXh0TG9uZzogJ1dlZWsnLFxuICAgIGNsb3NlSGludDogJ0Nsb3NlJyxcbiAgICB0aW1lSGludDogJ1RpbWUnLFxuICAgIGV2ZW50SGludDogJ0V2ZW50JyxcbiAgICBhbGxEYXlUZXh0OiAnYWxsLWRheScsXG4gICAgbW9yZUxpbmtUZXh0OiAnbW9yZScsXG4gICAgbm9FdmVudHNUZXh0OiAnTm8gZXZlbnRzIHRvIGRpc3BsYXknLFxufTtcbmNvbnN0IFJBV19FTl9MT0NBTEUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIE1JTklNQUxfUkFXX0VOX0xPQ0FMRSksIHsgXG4gICAgLy8gSW5jbHVkZXMgdGhpbmdzIHdlIGRvbid0IHdhbnQgb3RoZXIgbG9jYWxlcyB0byBpbmhlcml0LFxuICAgIC8vIHRoaW5ncyB0aGF0IGRlcml2ZSBmcm9tIG90aGVyIHRyYW5zbGF0YWJsZSBzdHJpbmdzLlxuICAgIGJ1dHRvbkhpbnRzOiB7XG4gICAgICAgIHByZXY6ICdQcmV2aW91cyAkMCcsXG4gICAgICAgIG5leHQ6ICdOZXh0ICQwJyxcbiAgICAgICAgdG9kYXkoYnV0dG9uVGV4dCwgdW5pdCkge1xuICAgICAgICAgICAgcmV0dXJuICh1bml0ID09PSAnZGF5JylcbiAgICAgICAgICAgICAgICA/ICdUb2RheSdcbiAgICAgICAgICAgICAgICA6IGBUaGlzICR7YnV0dG9uVGV4dH1gO1xuICAgICAgICB9LFxuICAgIH0sIHZpZXdIaW50OiAnJDAgdmlldycsIG5hdkxpbmtIaW50OiAnR28gdG8gJDAnLCBtb3JlTGlua0hpbnQoZXZlbnRDbnQpIHtcbiAgICAgICAgcmV0dXJuIGBTaG93ICR7ZXZlbnRDbnR9IG1vcmUgZXZlbnQke2V2ZW50Q250ID09PSAxID8gJycgOiAncyd9YDtcbiAgICB9IH0pO1xuZnVuY3Rpb24gb3JnYW5pemVSYXdMb2NhbGVzKGV4cGxpY2l0UmF3TG9jYWxlcykge1xuICAgIGxldCBkZWZhdWx0Q29kZSA9IGV4cGxpY2l0UmF3TG9jYWxlcy5sZW5ndGggPiAwID8gZXhwbGljaXRSYXdMb2NhbGVzWzBdLmNvZGUgOiAnZW4nO1xuICAgIGxldCBhbGxSYXdMb2NhbGVzID0gZ2xvYmFsTG9jYWxlcy5jb25jYXQoZXhwbGljaXRSYXdMb2NhbGVzKTtcbiAgICBsZXQgcmF3TG9jYWxlTWFwID0ge1xuICAgICAgICBlbjogUkFXX0VOX0xPQ0FMRSxcbiAgICB9O1xuICAgIGZvciAobGV0IHJhd0xvY2FsZSBvZiBhbGxSYXdMb2NhbGVzKSB7XG4gICAgICAgIHJhd0xvY2FsZU1hcFtyYXdMb2NhbGUuY29kZV0gPSByYXdMb2NhbGU7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG1hcDogcmF3TG9jYWxlTWFwLFxuICAgICAgICBkZWZhdWx0Q29kZSxcbiAgICB9O1xufVxuZnVuY3Rpb24gYnVpbGRMb2NhbGUoaW5wdXRTaW5ndWxhciwgYXZhaWxhYmxlKSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dFNpbmd1bGFyID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShpbnB1dFNpbmd1bGFyKSkge1xuICAgICAgICByZXR1cm4gcGFyc2VMb2NhbGUoaW5wdXRTaW5ndWxhci5jb2RlLCBbaW5wdXRTaW5ndWxhci5jb2RlXSwgaW5wdXRTaW5ndWxhcik7XG4gICAgfVxuICAgIHJldHVybiBxdWVyeUxvY2FsZShpbnB1dFNpbmd1bGFyLCBhdmFpbGFibGUpO1xufVxuZnVuY3Rpb24gcXVlcnlMb2NhbGUoY29kZUFyZywgYXZhaWxhYmxlKSB7XG4gICAgbGV0IGNvZGVzID0gW10uY29uY2F0KGNvZGVBcmcgfHwgW10pOyAvLyB3aWxsIGNvbnZlcnQgdG8gYXJyYXlcbiAgICBsZXQgcmF3ID0gcXVlcnlSYXdMb2NhbGUoY29kZXMsIGF2YWlsYWJsZSkgfHwgUkFXX0VOX0xPQ0FMRTtcbiAgICByZXR1cm4gcGFyc2VMb2NhbGUoY29kZUFyZywgY29kZXMsIHJhdyk7XG59XG5mdW5jdGlvbiBxdWVyeVJhd0xvY2FsZShjb2RlcywgYXZhaWxhYmxlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2Rlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBsZXQgcGFydHMgPSBjb2Rlc1tpXS50b0xvY2FsZUxvd2VyQ2FzZSgpLnNwbGl0KCctJyk7XG4gICAgICAgIGZvciAobGV0IGogPSBwYXJ0cy5sZW5ndGg7IGogPiAwOyBqIC09IDEpIHtcbiAgICAgICAgICAgIGxldCBzaW1wbGVJZCA9IHBhcnRzLnNsaWNlKDAsIGopLmpvaW4oJy0nKTtcbiAgICAgICAgICAgIGlmIChhdmFpbGFibGVbc2ltcGxlSWRdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF2YWlsYWJsZVtzaW1wbGVJZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBwYXJzZUxvY2FsZShjb2RlQXJnLCBjb2RlcywgcmF3KSB7XG4gICAgbGV0IG1lcmdlZCA9IG1lcmdlUHJvcHMoW01JTklNQUxfUkFXX0VOX0xPQ0FMRSwgcmF3XSwgWydidXR0b25UZXh0J10pO1xuICAgIGRlbGV0ZSBtZXJnZWQuY29kZTsgLy8gZG9uJ3Qgd2FudCB0aGlzIHBhcnQgb2YgdGhlIG9wdGlvbnNcbiAgICBsZXQgeyB3ZWVrIH0gPSBtZXJnZWQ7XG4gICAgZGVsZXRlIG1lcmdlZC53ZWVrO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvZGVBcmcsXG4gICAgICAgIGNvZGVzLFxuICAgICAgICB3ZWVrLFxuICAgICAgICBzaW1wbGVOdW1iZXJGb3JtYXQ6IG5ldyBJbnRsLk51bWJlckZvcm1hdChjb2RlQXJnKSxcbiAgICAgICAgb3B0aW9uczogbWVyZ2VkLFxuICAgIH07XG59XG5cbi8vIFRPRE86IGVhc2llciB3YXkgdG8gYWRkIG5ldyBob29rcz8gbmVlZCB0byB1cGRhdGUgYSBtaWxsaW9uIHRoaW5nc1xuZnVuY3Rpb24gY3JlYXRlUGx1Z2luKGlucHV0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IGd1aWQoKSxcbiAgICAgICAgbmFtZTogaW5wdXQubmFtZSxcbiAgICAgICAgcHJlbWl1bVJlbGVhc2VEYXRlOiBpbnB1dC5wcmVtaXVtUmVsZWFzZURhdGUgPyBuZXcgRGF0ZShpbnB1dC5wcmVtaXVtUmVsZWFzZURhdGUpIDogdW5kZWZpbmVkLFxuICAgICAgICBkZXBzOiBpbnB1dC5kZXBzIHx8IFtdLFxuICAgICAgICByZWR1Y2VyczogaW5wdXQucmVkdWNlcnMgfHwgW10sXG4gICAgICAgIGlzTG9hZGluZ0Z1bmNzOiBpbnB1dC5pc0xvYWRpbmdGdW5jcyB8fCBbXSxcbiAgICAgICAgY29udGV4dEluaXQ6IFtdLmNvbmNhdChpbnB1dC5jb250ZXh0SW5pdCB8fCBbXSksXG4gICAgICAgIGV2ZW50UmVmaW5lcnM6IGlucHV0LmV2ZW50UmVmaW5lcnMgfHwge30sXG4gICAgICAgIGV2ZW50RGVmTWVtYmVyQWRkZXJzOiBpbnB1dC5ldmVudERlZk1lbWJlckFkZGVycyB8fCBbXSxcbiAgICAgICAgZXZlbnRTb3VyY2VSZWZpbmVyczogaW5wdXQuZXZlbnRTb3VyY2VSZWZpbmVycyB8fCB7fSxcbiAgICAgICAgaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnM6IGlucHV0LmlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzIHx8IFtdLFxuICAgICAgICBldmVudERyYWdNdXRhdGlvbk1hc3NhZ2VyczogaW5wdXQuZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnMgfHwgW10sXG4gICAgICAgIGV2ZW50RGVmTXV0YXRpb25BcHBsaWVyczogaW5wdXQuZXZlbnREZWZNdXRhdGlvbkFwcGxpZXJzIHx8IFtdLFxuICAgICAgICBkYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzOiBpbnB1dC5kYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzIHx8IFtdLFxuICAgICAgICBkYXRlUG9pbnRUcmFuc2Zvcm1zOiBpbnB1dC5kYXRlUG9pbnRUcmFuc2Zvcm1zIHx8IFtdLFxuICAgICAgICBkYXRlU3BhblRyYW5zZm9ybXM6IGlucHV0LmRhdGVTcGFuVHJhbnNmb3JtcyB8fCBbXSxcbiAgICAgICAgdmlld3M6IGlucHV0LnZpZXdzIHx8IHt9LFxuICAgICAgICB2aWV3UHJvcHNUcmFuc2Zvcm1lcnM6IGlucHV0LnZpZXdQcm9wc1RyYW5zZm9ybWVycyB8fCBbXSxcbiAgICAgICAgaXNQcm9wc1ZhbGlkOiBpbnB1dC5pc1Byb3BzVmFsaWQgfHwgbnVsbCxcbiAgICAgICAgZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zOiBpbnB1dC5leHRlcm5hbERlZlRyYW5zZm9ybXMgfHwgW10sXG4gICAgICAgIHZpZXdDb250YWluZXJBcHBlbmRzOiBpbnB1dC52aWV3Q29udGFpbmVyQXBwZW5kcyB8fCBbXSxcbiAgICAgICAgZXZlbnREcm9wVHJhbnNmb3JtZXJzOiBpbnB1dC5ldmVudERyb3BUcmFuc2Zvcm1lcnMgfHwgW10sXG4gICAgICAgIGNvbXBvbmVudEludGVyYWN0aW9uczogaW5wdXQuY29tcG9uZW50SW50ZXJhY3Rpb25zIHx8IFtdLFxuICAgICAgICBjYWxlbmRhckludGVyYWN0aW9uczogaW5wdXQuY2FsZW5kYXJJbnRlcmFjdGlvbnMgfHwgW10sXG4gICAgICAgIHRoZW1lQ2xhc3NlczogaW5wdXQudGhlbWVDbGFzc2VzIHx8IHt9LFxuICAgICAgICBldmVudFNvdXJjZURlZnM6IGlucHV0LmV2ZW50U291cmNlRGVmcyB8fCBbXSxcbiAgICAgICAgY21kRm9ybWF0dGVyOiBpbnB1dC5jbWRGb3JtYXR0ZXIsXG4gICAgICAgIHJlY3VycmluZ1R5cGVzOiBpbnB1dC5yZWN1cnJpbmdUeXBlcyB8fCBbXSxcbiAgICAgICAgbmFtZWRUaW1lWm9uZWRJbXBsOiBpbnB1dC5uYW1lZFRpbWVab25lZEltcGwsXG4gICAgICAgIGluaXRpYWxWaWV3OiBpbnB1dC5pbml0aWFsVmlldyB8fCAnJyxcbiAgICAgICAgZWxlbWVudERyYWdnaW5nSW1wbDogaW5wdXQuZWxlbWVudERyYWdnaW5nSW1wbCxcbiAgICAgICAgb3B0aW9uQ2hhbmdlSGFuZGxlcnM6IGlucHV0Lm9wdGlvbkNoYW5nZUhhbmRsZXJzIHx8IHt9LFxuICAgICAgICBzY3JvbGxHcmlkSW1wbDogaW5wdXQuc2Nyb2xsR3JpZEltcGwgfHwgbnVsbCxcbiAgICAgICAgbGlzdGVuZXJSZWZpbmVyczogaW5wdXQubGlzdGVuZXJSZWZpbmVycyB8fCB7fSxcbiAgICAgICAgb3B0aW9uUmVmaW5lcnM6IGlucHV0Lm9wdGlvblJlZmluZXJzIHx8IHt9LFxuICAgICAgICBwcm9wU2V0SGFuZGxlcnM6IGlucHV0LnByb3BTZXRIYW5kbGVycyB8fCB7fSxcbiAgICB9O1xufVxuZnVuY3Rpb24gYnVpbGRQbHVnaW5Ib29rcyhwbHVnaW5EZWZzLCBnbG9iYWxEZWZzKSB7XG4gICAgbGV0IGN1cnJlbnRQbHVnaW5JZHMgPSB7fTtcbiAgICBsZXQgaG9va3MgPSB7XG4gICAgICAgIHByZW1pdW1SZWxlYXNlRGF0ZTogdW5kZWZpbmVkLFxuICAgICAgICByZWR1Y2VyczogW10sXG4gICAgICAgIGlzTG9hZGluZ0Z1bmNzOiBbXSxcbiAgICAgICAgY29udGV4dEluaXQ6IFtdLFxuICAgICAgICBldmVudFJlZmluZXJzOiB7fSxcbiAgICAgICAgZXZlbnREZWZNZW1iZXJBZGRlcnM6IFtdLFxuICAgICAgICBldmVudFNvdXJjZVJlZmluZXJzOiB7fSxcbiAgICAgICAgaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnM6IFtdLFxuICAgICAgICBldmVudERyYWdNdXRhdGlvbk1hc3NhZ2VyczogW10sXG4gICAgICAgIGV2ZW50RGVmTXV0YXRpb25BcHBsaWVyczogW10sXG4gICAgICAgIGRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnM6IFtdLFxuICAgICAgICBkYXRlUG9pbnRUcmFuc2Zvcm1zOiBbXSxcbiAgICAgICAgZGF0ZVNwYW5UcmFuc2Zvcm1zOiBbXSxcbiAgICAgICAgdmlld3M6IHt9LFxuICAgICAgICB2aWV3UHJvcHNUcmFuc2Zvcm1lcnM6IFtdLFxuICAgICAgICBpc1Byb3BzVmFsaWQ6IG51bGwsXG4gICAgICAgIGV4dGVybmFsRGVmVHJhbnNmb3JtczogW10sXG4gICAgICAgIHZpZXdDb250YWluZXJBcHBlbmRzOiBbXSxcbiAgICAgICAgZXZlbnREcm9wVHJhbnNmb3JtZXJzOiBbXSxcbiAgICAgICAgY29tcG9uZW50SW50ZXJhY3Rpb25zOiBbXSxcbiAgICAgICAgY2FsZW5kYXJJbnRlcmFjdGlvbnM6IFtdLFxuICAgICAgICB0aGVtZUNsYXNzZXM6IHt9LFxuICAgICAgICBldmVudFNvdXJjZURlZnM6IFtdLFxuICAgICAgICBjbWRGb3JtYXR0ZXI6IG51bGwsXG4gICAgICAgIHJlY3VycmluZ1R5cGVzOiBbXSxcbiAgICAgICAgbmFtZWRUaW1lWm9uZWRJbXBsOiBudWxsLFxuICAgICAgICBpbml0aWFsVmlldzogJycsXG4gICAgICAgIGVsZW1lbnREcmFnZ2luZ0ltcGw6IG51bGwsXG4gICAgICAgIG9wdGlvbkNoYW5nZUhhbmRsZXJzOiB7fSxcbiAgICAgICAgc2Nyb2xsR3JpZEltcGw6IG51bGwsXG4gICAgICAgIGxpc3RlbmVyUmVmaW5lcnM6IHt9LFxuICAgICAgICBvcHRpb25SZWZpbmVyczoge30sXG4gICAgICAgIHByb3BTZXRIYW5kbGVyczoge30sXG4gICAgfTtcbiAgICBmdW5jdGlvbiBhZGREZWZzKGRlZnMpIHtcbiAgICAgICAgZm9yIChsZXQgZGVmIG9mIGRlZnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBsdWdpbk5hbWUgPSBkZWYubmFtZTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRJZCA9IGN1cnJlbnRQbHVnaW5JZHNbcGx1Z2luTmFtZV07XG4gICAgICAgICAgICBpZiAoY3VycmVudElkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UGx1Z2luSWRzW3BsdWdpbk5hbWVdID0gZGVmLmlkO1xuICAgICAgICAgICAgICAgIGFkZERlZnMoZGVmLmRlcHMpO1xuICAgICAgICAgICAgICAgIGhvb2tzID0gY29tYmluZUhvb2tzKGhvb2tzLCBkZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudElkICE9PSBkZWYuaWQpIHtcbiAgICAgICAgICAgICAgICAvLyBkaWZmZXJlbnQgSUQgdGhhbiB0aGUgb25lIGFscmVhZHkgYWRkZWRcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYER1cGxpY2F0ZSBwbHVnaW4gJyR7cGx1Z2luTmFtZX0nYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBsdWdpbkRlZnMpIHtcbiAgICAgICAgYWRkRGVmcyhwbHVnaW5EZWZzKTtcbiAgICB9XG4gICAgYWRkRGVmcyhnbG9iYWxEZWZzKTtcbiAgICByZXR1cm4gaG9va3M7XG59XG5mdW5jdGlvbiBidWlsZEJ1aWxkUGx1Z2luSG9va3MoKSB7XG4gICAgbGV0IGN1cnJlbnRPdmVycmlkZURlZnMgPSBbXTtcbiAgICBsZXQgY3VycmVudEdsb2JhbERlZnMgPSBbXTtcbiAgICBsZXQgY3VycmVudEhvb2tzO1xuICAgIHJldHVybiAob3ZlcnJpZGVEZWZzLCBnbG9iYWxEZWZzKSA9PiB7XG4gICAgICAgIGlmICghY3VycmVudEhvb2tzIHx8ICFpc0FycmF5c0VxdWFsKG92ZXJyaWRlRGVmcywgY3VycmVudE92ZXJyaWRlRGVmcykgfHwgIWlzQXJyYXlzRXF1YWwoZ2xvYmFsRGVmcywgY3VycmVudEdsb2JhbERlZnMpKSB7XG4gICAgICAgICAgICBjdXJyZW50SG9va3MgPSBidWlsZFBsdWdpbkhvb2tzKG92ZXJyaWRlRGVmcywgZ2xvYmFsRGVmcyk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudE92ZXJyaWRlRGVmcyA9IG92ZXJyaWRlRGVmcztcbiAgICAgICAgY3VycmVudEdsb2JhbERlZnMgPSBnbG9iYWxEZWZzO1xuICAgICAgICByZXR1cm4gY3VycmVudEhvb2tzO1xuICAgIH07XG59XG5mdW5jdGlvbiBjb21iaW5lSG9va3MoaG9va3MwLCBob29rczEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcmVtaXVtUmVsZWFzZURhdGU6IGNvbXBhcmVPcHRpb25hbERhdGVzKGhvb2tzMC5wcmVtaXVtUmVsZWFzZURhdGUsIGhvb2tzMS5wcmVtaXVtUmVsZWFzZURhdGUpLFxuICAgICAgICByZWR1Y2VyczogaG9va3MwLnJlZHVjZXJzLmNvbmNhdChob29rczEucmVkdWNlcnMpLFxuICAgICAgICBpc0xvYWRpbmdGdW5jczogaG9va3MwLmlzTG9hZGluZ0Z1bmNzLmNvbmNhdChob29rczEuaXNMb2FkaW5nRnVuY3MpLFxuICAgICAgICBjb250ZXh0SW5pdDogaG9va3MwLmNvbnRleHRJbml0LmNvbmNhdChob29rczEuY29udGV4dEluaXQpLFxuICAgICAgICBldmVudFJlZmluZXJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGhvb2tzMC5ldmVudFJlZmluZXJzKSwgaG9va3MxLmV2ZW50UmVmaW5lcnMpLFxuICAgICAgICBldmVudERlZk1lbWJlckFkZGVyczogaG9va3MwLmV2ZW50RGVmTWVtYmVyQWRkZXJzLmNvbmNhdChob29rczEuZXZlbnREZWZNZW1iZXJBZGRlcnMpLFxuICAgICAgICBldmVudFNvdXJjZVJlZmluZXJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGhvb2tzMC5ldmVudFNvdXJjZVJlZmluZXJzKSwgaG9va3MxLmV2ZW50U291cmNlUmVmaW5lcnMpLFxuICAgICAgICBpc0RyYWdnYWJsZVRyYW5zZm9ybWVyczogaG9va3MwLmlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzLmNvbmNhdChob29rczEuaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnMpLFxuICAgICAgICBldmVudERyYWdNdXRhdGlvbk1hc3NhZ2VyczogaG9va3MwLmV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzLmNvbmNhdChob29rczEuZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnMpLFxuICAgICAgICBldmVudERlZk11dGF0aW9uQXBwbGllcnM6IGhvb2tzMC5ldmVudERlZk11dGF0aW9uQXBwbGllcnMuY29uY2F0KGhvb2tzMS5ldmVudERlZk11dGF0aW9uQXBwbGllcnMpLFxuICAgICAgICBkYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzOiBob29rczAuZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVycy5jb25jYXQoaG9va3MxLmRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnMpLFxuICAgICAgICBkYXRlUG9pbnRUcmFuc2Zvcm1zOiBob29rczAuZGF0ZVBvaW50VHJhbnNmb3Jtcy5jb25jYXQoaG9va3MxLmRhdGVQb2ludFRyYW5zZm9ybXMpLFxuICAgICAgICBkYXRlU3BhblRyYW5zZm9ybXM6IGhvb2tzMC5kYXRlU3BhblRyYW5zZm9ybXMuY29uY2F0KGhvb2tzMS5kYXRlU3BhblRyYW5zZm9ybXMpLFxuICAgICAgICB2aWV3czogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBob29rczAudmlld3MpLCBob29rczEudmlld3MpLFxuICAgICAgICB2aWV3UHJvcHNUcmFuc2Zvcm1lcnM6IGhvb2tzMC52aWV3UHJvcHNUcmFuc2Zvcm1lcnMuY29uY2F0KGhvb2tzMS52aWV3UHJvcHNUcmFuc2Zvcm1lcnMpLFxuICAgICAgICBpc1Byb3BzVmFsaWQ6IGhvb2tzMS5pc1Byb3BzVmFsaWQgfHwgaG9va3MwLmlzUHJvcHNWYWxpZCxcbiAgICAgICAgZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zOiBob29rczAuZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zLmNvbmNhdChob29rczEuZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zKSxcbiAgICAgICAgdmlld0NvbnRhaW5lckFwcGVuZHM6IGhvb2tzMC52aWV3Q29udGFpbmVyQXBwZW5kcy5jb25jYXQoaG9va3MxLnZpZXdDb250YWluZXJBcHBlbmRzKSxcbiAgICAgICAgZXZlbnREcm9wVHJhbnNmb3JtZXJzOiBob29rczAuZXZlbnREcm9wVHJhbnNmb3JtZXJzLmNvbmNhdChob29rczEuZXZlbnREcm9wVHJhbnNmb3JtZXJzKSxcbiAgICAgICAgY2FsZW5kYXJJbnRlcmFjdGlvbnM6IGhvb2tzMC5jYWxlbmRhckludGVyYWN0aW9ucy5jb25jYXQoaG9va3MxLmNhbGVuZGFySW50ZXJhY3Rpb25zKSxcbiAgICAgICAgY29tcG9uZW50SW50ZXJhY3Rpb25zOiBob29rczAuY29tcG9uZW50SW50ZXJhY3Rpb25zLmNvbmNhdChob29rczEuY29tcG9uZW50SW50ZXJhY3Rpb25zKSxcbiAgICAgICAgdGhlbWVDbGFzc2VzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGhvb2tzMC50aGVtZUNsYXNzZXMpLCBob29rczEudGhlbWVDbGFzc2VzKSxcbiAgICAgICAgZXZlbnRTb3VyY2VEZWZzOiBob29rczAuZXZlbnRTb3VyY2VEZWZzLmNvbmNhdChob29rczEuZXZlbnRTb3VyY2VEZWZzKSxcbiAgICAgICAgY21kRm9ybWF0dGVyOiBob29rczEuY21kRm9ybWF0dGVyIHx8IGhvb2tzMC5jbWRGb3JtYXR0ZXIsXG4gICAgICAgIHJlY3VycmluZ1R5cGVzOiBob29rczAucmVjdXJyaW5nVHlwZXMuY29uY2F0KGhvb2tzMS5yZWN1cnJpbmdUeXBlcyksXG4gICAgICAgIG5hbWVkVGltZVpvbmVkSW1wbDogaG9va3MxLm5hbWVkVGltZVpvbmVkSW1wbCB8fCBob29rczAubmFtZWRUaW1lWm9uZWRJbXBsLFxuICAgICAgICBpbml0aWFsVmlldzogaG9va3MwLmluaXRpYWxWaWV3IHx8IGhvb2tzMS5pbml0aWFsVmlldyxcbiAgICAgICAgZWxlbWVudERyYWdnaW5nSW1wbDogaG9va3MwLmVsZW1lbnREcmFnZ2luZ0ltcGwgfHwgaG9va3MxLmVsZW1lbnREcmFnZ2luZ0ltcGwsXG4gICAgICAgIG9wdGlvbkNoYW5nZUhhbmRsZXJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGhvb2tzMC5vcHRpb25DaGFuZ2VIYW5kbGVycyksIGhvb2tzMS5vcHRpb25DaGFuZ2VIYW5kbGVycyksXG4gICAgICAgIHNjcm9sbEdyaWRJbXBsOiBob29rczEuc2Nyb2xsR3JpZEltcGwgfHwgaG9va3MwLnNjcm9sbEdyaWRJbXBsLFxuICAgICAgICBsaXN0ZW5lclJlZmluZXJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGhvb2tzMC5saXN0ZW5lclJlZmluZXJzKSwgaG9va3MxLmxpc3RlbmVyUmVmaW5lcnMpLFxuICAgICAgICBvcHRpb25SZWZpbmVyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBob29rczAub3B0aW9uUmVmaW5lcnMpLCBob29rczEub3B0aW9uUmVmaW5lcnMpLFxuICAgICAgICBwcm9wU2V0SGFuZGxlcnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaG9va3MwLnByb3BTZXRIYW5kbGVycyksIGhvb2tzMS5wcm9wU2V0SGFuZGxlcnMpLFxuICAgIH07XG59XG5mdW5jdGlvbiBjb21wYXJlT3B0aW9uYWxEYXRlcyhkYXRlMCwgZGF0ZTEpIHtcbiAgICBpZiAoZGF0ZTAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZGF0ZTE7XG4gICAgfVxuICAgIGlmIChkYXRlMSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBkYXRlMDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEYXRlKE1hdGgubWF4KGRhdGUwLnZhbHVlT2YoKSwgZGF0ZTEudmFsdWVPZigpKSk7XG59XG5cbmNsYXNzIFN0YW5kYXJkVGhlbWUgZXh0ZW5kcyBUaGVtZSB7XG59XG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5jbGFzc2VzID0ge1xuICAgIHJvb3Q6ICdmYy10aGVtZS1zdGFuZGFyZCcsXG4gICAgdGFibGVDZWxsU2hhZGVkOiAnZmMtY2VsbC1zaGFkZWQnLFxuICAgIGJ1dHRvbkdyb3VwOiAnZmMtYnV0dG9uLWdyb3VwJyxcbiAgICBidXR0b246ICdmYy1idXR0b24gZmMtYnV0dG9uLXByaW1hcnknLFxuICAgIGJ1dHRvbkFjdGl2ZTogJ2ZjLWJ1dHRvbi1hY3RpdmUnLFxufTtcblN0YW5kYXJkVGhlbWUucHJvdG90eXBlLmJhc2VJY29uQ2xhc3MgPSAnZmMtaWNvbic7XG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5pY29uQ2xhc3NlcyA9IHtcbiAgICBjbG9zZTogJ2ZjLWljb24teCcsXG4gICAgcHJldjogJ2ZjLWljb24tY2hldnJvbi1sZWZ0JyxcbiAgICBuZXh0OiAnZmMtaWNvbi1jaGV2cm9uLXJpZ2h0JyxcbiAgICBwcmV2WWVhcjogJ2ZjLWljb24tY2hldnJvbnMtbGVmdCcsXG4gICAgbmV4dFllYXI6ICdmYy1pY29uLWNoZXZyb25zLXJpZ2h0Jyxcbn07XG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5ydGxJY29uQ2xhc3NlcyA9IHtcbiAgICBwcmV2OiAnZmMtaWNvbi1jaGV2cm9uLXJpZ2h0JyxcbiAgICBuZXh0OiAnZmMtaWNvbi1jaGV2cm9uLWxlZnQnLFxuICAgIHByZXZZZWFyOiAnZmMtaWNvbi1jaGV2cm9ucy1yaWdodCcsXG4gICAgbmV4dFllYXI6ICdmYy1pY29uLWNoZXZyb25zLWxlZnQnLFxufTtcblN0YW5kYXJkVGhlbWUucHJvdG90eXBlLmljb25PdmVycmlkZU9wdGlvbiA9ICdidXR0b25JY29ucyc7IC8vIFRPRE86IG1ha2UgVFMtZnJpZW5kbHlcblN0YW5kYXJkVGhlbWUucHJvdG90eXBlLmljb25PdmVycmlkZUN1c3RvbUJ1dHRvbk9wdGlvbiA9ICdpY29uJztcblN0YW5kYXJkVGhlbWUucHJvdG90eXBlLmljb25PdmVycmlkZVByZWZpeCA9ICdmYy1pY29uLSc7XG5cbmZ1bmN0aW9uIGNvbXBpbGVWaWV3RGVmcyhkZWZhdWx0Q29uZmlncywgb3ZlcnJpZGVDb25maWdzKSB7XG4gICAgbGV0IGhhc2ggPSB7fTtcbiAgICBsZXQgdmlld1R5cGU7XG4gICAgZm9yICh2aWV3VHlwZSBpbiBkZWZhdWx0Q29uZmlncykge1xuICAgICAgICBlbnN1cmVWaWV3RGVmKHZpZXdUeXBlLCBoYXNoLCBkZWZhdWx0Q29uZmlncywgb3ZlcnJpZGVDb25maWdzKTtcbiAgICB9XG4gICAgZm9yICh2aWV3VHlwZSBpbiBvdmVycmlkZUNvbmZpZ3MpIHtcbiAgICAgICAgZW5zdXJlVmlld0RlZih2aWV3VHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncyk7XG4gICAgfVxuICAgIHJldHVybiBoYXNoO1xufVxuZnVuY3Rpb24gZW5zdXJlVmlld0RlZih2aWV3VHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncykge1xuICAgIGlmIChoYXNoW3ZpZXdUeXBlXSkge1xuICAgICAgICByZXR1cm4gaGFzaFt2aWV3VHlwZV07XG4gICAgfVxuICAgIGxldCB2aWV3RGVmID0gYnVpbGRWaWV3RGVmKHZpZXdUeXBlLCBoYXNoLCBkZWZhdWx0Q29uZmlncywgb3ZlcnJpZGVDb25maWdzKTtcbiAgICBpZiAodmlld0RlZikge1xuICAgICAgICBoYXNoW3ZpZXdUeXBlXSA9IHZpZXdEZWY7XG4gICAgfVxuICAgIHJldHVybiB2aWV3RGVmO1xufVxuZnVuY3Rpb24gYnVpbGRWaWV3RGVmKHZpZXdUeXBlLCBoYXNoLCBkZWZhdWx0Q29uZmlncywgb3ZlcnJpZGVDb25maWdzKSB7XG4gICAgbGV0IGRlZmF1bHRDb25maWcgPSBkZWZhdWx0Q29uZmlnc1t2aWV3VHlwZV07XG4gICAgbGV0IG92ZXJyaWRlQ29uZmlnID0gb3ZlcnJpZGVDb25maWdzW3ZpZXdUeXBlXTtcbiAgICBsZXQgcXVlcnlQcm9wID0gKG5hbWUpID0+ICgoZGVmYXVsdENvbmZpZyAmJiBkZWZhdWx0Q29uZmlnW25hbWVdICE9PSBudWxsKSA/IGRlZmF1bHRDb25maWdbbmFtZV0gOlxuICAgICAgICAoKG92ZXJyaWRlQ29uZmlnICYmIG92ZXJyaWRlQ29uZmlnW25hbWVdICE9PSBudWxsKSA/IG92ZXJyaWRlQ29uZmlnW25hbWVdIDogbnVsbCkpO1xuICAgIGxldCB0aGVDb21wb25lbnQgPSBxdWVyeVByb3AoJ2NvbXBvbmVudCcpO1xuICAgIGxldCBzdXBlclR5cGUgPSBxdWVyeVByb3AoJ3N1cGVyVHlwZScpO1xuICAgIGxldCBzdXBlckRlZiA9IG51bGw7XG4gICAgaWYgKHN1cGVyVHlwZSkge1xuICAgICAgICBpZiAoc3VwZXJUeXBlID09PSB2aWV3VHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IGhhdmUgYSBjdXN0b20gdmlldyB0eXBlIHRoYXQgcmVmZXJlbmNlcyBpdHNlbGYnKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlckRlZiA9IGVuc3VyZVZpZXdEZWYoc3VwZXJUeXBlLCBoYXNoLCBkZWZhdWx0Q29uZmlncywgb3ZlcnJpZGVDb25maWdzKTtcbiAgICB9XG4gICAgaWYgKCF0aGVDb21wb25lbnQgJiYgc3VwZXJEZWYpIHtcbiAgICAgICAgdGhlQ29tcG9uZW50ID0gc3VwZXJEZWYuY29tcG9uZW50O1xuICAgIH1cbiAgICBpZiAoIXRoZUNvbXBvbmVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDsgLy8gZG9uJ3QgdGhyb3cgYSB3YXJuaW5nLCBtaWdodCBiZSBzZXR0aW5ncyBmb3IgYSBzaW5nbGUtdW5pdCB2aWV3XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHZpZXdUeXBlLFxuICAgICAgICBjb21wb25lbnQ6IHRoZUNvbXBvbmVudCxcbiAgICAgICAgZGVmYXVsdHM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKHN1cGVyRGVmID8gc3VwZXJEZWYuZGVmYXVsdHMgOiB7fSkpLCAoZGVmYXVsdENvbmZpZyA/IGRlZmF1bHRDb25maWcucmF3T3B0aW9ucyA6IHt9KSksXG4gICAgICAgIG92ZXJyaWRlczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoc3VwZXJEZWYgPyBzdXBlckRlZi5vdmVycmlkZXMgOiB7fSkpLCAob3ZlcnJpZGVDb25maWcgPyBvdmVycmlkZUNvbmZpZy5yYXdPcHRpb25zIDoge30pKSxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZVZpZXdDb25maWdzKGlucHV0cykge1xuICAgIHJldHVybiBtYXBIYXNoKGlucHV0cywgcGFyc2VWaWV3Q29uZmlnKTtcbn1cbmZ1bmN0aW9uIHBhcnNlVmlld0NvbmZpZyhpbnB1dCkge1xuICAgIGxldCByYXdPcHRpb25zID0gdHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgeyBjb21wb25lbnQ6IGlucHV0IH0gOlxuICAgICAgICBpbnB1dDtcbiAgICBsZXQgeyBjb21wb25lbnQgfSA9IHJhd09wdGlvbnM7XG4gICAgaWYgKHJhd09wdGlvbnMuY29udGVudCkge1xuICAgICAgICAvLyBUT0RPOiByZW1vdmUgY29udGVudC9jbGFzc05hbWVzL2RpZE1vdW50L2V0YyBmcm9tIG9wdGlvbnM/XG4gICAgICAgIGNvbXBvbmVudCA9IGNyZWF0ZVZpZXdIb29rQ29tcG9uZW50KHJhd09wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb21wb25lbnQgJiYgIShjb21wb25lbnQucHJvdG90eXBlIGluc3RhbmNlb2YgQmFzZUNvbXBvbmVudCkpIHtcbiAgICAgICAgLy8gV0hZPzogcGVvcGxlIHdlcmUgdXNpbmcgYGNvbXBvbmVudGAgcHJvcGVydHkgZm9yIGBjb250ZW50YFxuICAgICAgICAvLyBUT0RPOiBjb252ZXJnZSBvbiBvbmUgc2V0dGluZyBuYW1lXG4gICAgICAgIGNvbXBvbmVudCA9IGNyZWF0ZVZpZXdIb29rQ29tcG9uZW50KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmF3T3B0aW9ucyksIHsgY29udGVudDogY29tcG9uZW50IH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3VwZXJUeXBlOiByYXdPcHRpb25zLnR5cGUsXG4gICAgICAgIGNvbXBvbmVudDogY29tcG9uZW50LFxuICAgICAgICByYXdPcHRpb25zLCAvLyBpbmNsdWRlcyB0eXBlIGFuZCBjb21wb25lbnQgdG9vIDooXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVZpZXdIb29rQ29tcG9uZW50KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKHZpZXdQcm9wcykgPT4gKGNyZWF0ZUVsZW1lbnQoVmlld0NvbnRleHRUeXBlLkNvbnN1bWVyLCBudWxsLCAoY29udGV4dCkgPT4gKGNyZWF0ZUVsZW1lbnQoQ29udGVudENvbnRhaW5lciwgeyBlbFRhZzogXCJkaXZcIiwgZWxDbGFzc2VzOiBidWlsZFZpZXdDbGFzc05hbWVzKGNvbnRleHQudmlld1NwZWMpLCByZW5kZXJQcm9wczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB2aWV3UHJvcHMpLCB7IG5leHREYXlUaHJlc2hvbGQ6IGNvbnRleHQub3B0aW9ucy5uZXh0RGF5VGhyZXNob2xkIH0pLCBnZW5lcmF0b3JOYW1lOiB1bmRlZmluZWQsIGN1c3RvbUdlbmVyYXRvcjogb3B0aW9ucy5jb250ZW50LCBjbGFzc05hbWVHZW5lcmF0b3I6IG9wdGlvbnMuY2xhc3NOYW1lcywgZGlkTW91bnQ6IG9wdGlvbnMuZGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLndpbGxVbm1vdW50IH0pKSkpO1xufVxuXG5mdW5jdGlvbiBidWlsZFZpZXdTcGVjcyhkZWZhdWx0SW5wdXRzLCBvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsIGxvY2FsZURlZmF1bHRzKSB7XG4gICAgbGV0IGRlZmF1bHRDb25maWdzID0gcGFyc2VWaWV3Q29uZmlncyhkZWZhdWx0SW5wdXRzKTtcbiAgICBsZXQgb3ZlcnJpZGVDb25maWdzID0gcGFyc2VWaWV3Q29uZmlncyhvcHRpb25PdmVycmlkZXMudmlld3MpO1xuICAgIGxldCB2aWV3RGVmcyA9IGNvbXBpbGVWaWV3RGVmcyhkZWZhdWx0Q29uZmlncywgb3ZlcnJpZGVDb25maWdzKTtcbiAgICByZXR1cm4gbWFwSGFzaCh2aWV3RGVmcywgKHZpZXdEZWYpID0+IGJ1aWxkVmlld1NwZWModmlld0RlZiwgb3ZlcnJpZGVDb25maWdzLCBvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsIGxvY2FsZURlZmF1bHRzKSk7XG59XG5mdW5jdGlvbiBidWlsZFZpZXdTcGVjKHZpZXdEZWYsIG92ZXJyaWRlQ29uZmlncywgb3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBsb2NhbGVEZWZhdWx0cykge1xuICAgIGxldCBkdXJhdGlvbklucHV0ID0gdmlld0RlZi5vdmVycmlkZXMuZHVyYXRpb24gfHxcbiAgICAgICAgdmlld0RlZi5kZWZhdWx0cy5kdXJhdGlvbiB8fFxuICAgICAgICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLmR1cmF0aW9uIHx8XG4gICAgICAgIG9wdGlvbk92ZXJyaWRlcy5kdXJhdGlvbjtcbiAgICBsZXQgZHVyYXRpb24gPSBudWxsO1xuICAgIGxldCBkdXJhdGlvblVuaXQgPSAnJztcbiAgICBsZXQgc2luZ2xlVW5pdCA9ICcnO1xuICAgIGxldCBzaW5nbGVVbml0T3ZlcnJpZGVzID0ge307XG4gICAgaWYgKGR1cmF0aW9uSW5wdXQpIHtcbiAgICAgICAgZHVyYXRpb24gPSBjcmVhdGVEdXJhdGlvbkNhY2hlZChkdXJhdGlvbklucHV0KTtcbiAgICAgICAgaWYgKGR1cmF0aW9uKSB7IC8vIHZhbGlkP1xuICAgICAgICAgICAgbGV0IGRlbm9tID0gZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yKGR1cmF0aW9uKTtcbiAgICAgICAgICAgIGR1cmF0aW9uVW5pdCA9IGRlbm9tLnVuaXQ7XG4gICAgICAgICAgICBpZiAoZGVub20udmFsdWUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBzaW5nbGVVbml0ID0gZHVyYXRpb25Vbml0O1xuICAgICAgICAgICAgICAgIHNpbmdsZVVuaXRPdmVycmlkZXMgPSBvdmVycmlkZUNvbmZpZ3NbZHVyYXRpb25Vbml0XSA/IG92ZXJyaWRlQ29uZmlnc1tkdXJhdGlvblVuaXRdLnJhd09wdGlvbnMgOiB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgcXVlcnlCdXR0b25UZXh0ID0gKG9wdGlvbnNTdWJzZXQpID0+IHtcbiAgICAgICAgbGV0IGJ1dHRvblRleHRNYXAgPSBvcHRpb25zU3Vic2V0LmJ1dHRvblRleHQgfHwge307XG4gICAgICAgIGxldCBidXR0b25UZXh0S2V5ID0gdmlld0RlZi5kZWZhdWx0cy5idXR0b25UZXh0S2V5O1xuICAgICAgICBpZiAoYnV0dG9uVGV4dEtleSAhPSBudWxsICYmIGJ1dHRvblRleHRNYXBbYnV0dG9uVGV4dEtleV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1dHRvblRleHRNYXBbYnV0dG9uVGV4dEtleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1dHRvblRleHRNYXBbdmlld0RlZi50eXBlXSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYnV0dG9uVGV4dE1hcFt2aWV3RGVmLnR5cGVdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidXR0b25UZXh0TWFwW3NpbmdsZVVuaXRdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBidXR0b25UZXh0TWFwW3NpbmdsZVVuaXRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgbGV0IHF1ZXJ5QnV0dG9uVGl0bGUgPSAob3B0aW9uc1N1YnNldCkgPT4ge1xuICAgICAgICBsZXQgYnV0dG9uSGludHMgPSBvcHRpb25zU3Vic2V0LmJ1dHRvbkhpbnRzIHx8IHt9O1xuICAgICAgICBsZXQgYnV0dG9uS2V5ID0gdmlld0RlZi5kZWZhdWx0cy5idXR0b25UZXh0S2V5OyAvLyB1c2Ugc2FtZSBrZXkgYXMgdGV4dFxuICAgICAgICBpZiAoYnV0dG9uS2V5ICE9IG51bGwgJiYgYnV0dG9uSGludHNbYnV0dG9uS2V5XSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYnV0dG9uSGludHNbYnV0dG9uS2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnV0dG9uSGludHNbdmlld0RlZi50eXBlXSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYnV0dG9uSGludHNbdmlld0RlZi50eXBlXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnV0dG9uSGludHNbc2luZ2xlVW5pdF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1dHRvbkhpbnRzW3NpbmdsZVVuaXRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogdmlld0RlZi50eXBlLFxuICAgICAgICBjb21wb25lbnQ6IHZpZXdEZWYuY29tcG9uZW50LFxuICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgZHVyYXRpb25Vbml0LFxuICAgICAgICBzaW5nbGVVbml0LFxuICAgICAgICBvcHRpb25EZWZhdWx0czogdmlld0RlZi5kZWZhdWx0cyxcbiAgICAgICAgb3B0aW9uT3ZlcnJpZGVzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNpbmdsZVVuaXRPdmVycmlkZXMpLCB2aWV3RGVmLm92ZXJyaWRlcyksXG4gICAgICAgIGJ1dHRvblRleHRPdmVycmlkZTogcXVlcnlCdXR0b25UZXh0KGR5bmFtaWNPcHRpb25PdmVycmlkZXMpIHx8XG4gICAgICAgICAgICBxdWVyeUJ1dHRvblRleHQob3B0aW9uT3ZlcnJpZGVzKSB8fCAvLyBjb25zdHJ1Y3Rvci1zcGVjaWZpZWQgYnV0dG9uVGV4dCBsb29rdXAgaGFzaCB0YWtlcyBwcmVjZWRlbmNlXG4gICAgICAgICAgICB2aWV3RGVmLm92ZXJyaWRlcy5idXR0b25UZXh0LFxuICAgICAgICBidXR0b25UZXh0RGVmYXVsdDogcXVlcnlCdXR0b25UZXh0KGxvY2FsZURlZmF1bHRzKSB8fFxuICAgICAgICAgICAgdmlld0RlZi5kZWZhdWx0cy5idXR0b25UZXh0IHx8XG4gICAgICAgICAgICBxdWVyeUJ1dHRvblRleHQoQkFTRV9PUFRJT05fREVGQVVMVFMpIHx8XG4gICAgICAgICAgICB2aWV3RGVmLnR5cGUsXG4gICAgICAgIC8vIG5vdCBEUllcbiAgICAgICAgYnV0dG9uVGl0bGVPdmVycmlkZTogcXVlcnlCdXR0b25UaXRsZShkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKSB8fFxuICAgICAgICAgICAgcXVlcnlCdXR0b25UaXRsZShvcHRpb25PdmVycmlkZXMpIHx8XG4gICAgICAgICAgICB2aWV3RGVmLm92ZXJyaWRlcy5idXR0b25IaW50LFxuICAgICAgICBidXR0b25UaXRsZURlZmF1bHQ6IHF1ZXJ5QnV0dG9uVGl0bGUobG9jYWxlRGVmYXVsdHMpIHx8XG4gICAgICAgICAgICB2aWV3RGVmLmRlZmF1bHRzLmJ1dHRvbkhpbnQgfHxcbiAgICAgICAgICAgIHF1ZXJ5QnV0dG9uVGl0bGUoQkFTRV9PUFRJT05fREVGQVVMVFMpLFxuICAgICAgICAvLyB3aWxsIGV2ZW50dWFsbHkgZmFsbCBiYWNrIHRvIGJ1dHRvblRleHRcbiAgICB9O1xufVxuLy8gaGFjayB0byBnZXQgbWVtb2l6YXRpb24gd29ya2luZ1xubGV0IGR1cmF0aW9uSW5wdXRNYXAgPSB7fTtcbmZ1bmN0aW9uIGNyZWF0ZUR1cmF0aW9uQ2FjaGVkKGR1cmF0aW9uSW5wdXQpIHtcbiAgICBsZXQganNvbiA9IEpTT04uc3RyaW5naWZ5KGR1cmF0aW9uSW5wdXQpO1xuICAgIGxldCByZXMgPSBkdXJhdGlvbklucHV0TWFwW2pzb25dO1xuICAgIGlmIChyZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXMgPSBjcmVhdGVEdXJhdGlvbihkdXJhdGlvbklucHV0KTtcbiAgICAgICAgZHVyYXRpb25JbnB1dE1hcFtqc29uXSA9IHJlcztcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gcmVkdWNlVmlld1R5cGUodmlld1R5cGUsIGFjdGlvbikge1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnQ0hBTkdFX1ZJRVdfVFlQRSc6XG4gICAgICAgICAgICB2aWV3VHlwZSA9IGFjdGlvbi52aWV3VHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIHZpZXdUeXBlO1xufVxuXG5mdW5jdGlvbiByZWR1Y2VEeW5hbWljT3B0aW9uT3ZlcnJpZGVzKGR5bmFtaWNPcHRpb25PdmVycmlkZXMsIGFjdGlvbikge1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnU0VUX09QVElPTic6XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKSwgeyBbYWN0aW9uLm9wdGlvbk5hbWVdOiBhY3Rpb24ucmF3T3B0aW9uVmFsdWUgfSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZHluYW1pY09wdGlvbk92ZXJyaWRlcztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlZHVjZURhdGVQcm9maWxlKGN1cnJlbnREYXRlUHJvZmlsZSwgYWN0aW9uLCBjdXJyZW50RGF0ZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IpIHtcbiAgICBsZXQgZHA7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdDSEFOR0VfVklFV19UWVBFJzpcbiAgICAgICAgICAgIHJldHVybiBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZChhY3Rpb24uZGF0ZU1hcmtlciB8fCBjdXJyZW50RGF0ZSk7XG4gICAgICAgIGNhc2UgJ0NIQU5HRV9EQVRFJzpcbiAgICAgICAgICAgIHJldHVybiBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZChhY3Rpb24uZGF0ZU1hcmtlcik7XG4gICAgICAgIGNhc2UgJ1BSRVYnOlxuICAgICAgICAgICAgZHAgPSBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZFByZXYoY3VycmVudERhdGVQcm9maWxlLCBjdXJyZW50RGF0ZSk7XG4gICAgICAgICAgICBpZiAoZHAuaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdORVhUJzpcbiAgICAgICAgICAgIGRwID0gZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGROZXh0KGN1cnJlbnREYXRlUHJvZmlsZSwgY3VycmVudERhdGUpO1xuICAgICAgICAgICAgaWYgKGRwLmlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZHA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnREYXRlUHJvZmlsZTtcbn1cblxuZnVuY3Rpb24gaW5pdEV2ZW50U291cmNlcyhjYWxlbmRhck9wdGlvbnMsIGRhdGVQcm9maWxlLCBjb250ZXh0KSB7XG4gICAgbGV0IGFjdGl2ZVJhbmdlID0gZGF0ZVByb2ZpbGUgPyBkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSA6IG51bGw7XG4gICAgcmV0dXJuIGFkZFNvdXJjZXMoe30sIHBhcnNlSW5pdGlhbFNvdXJjZXMoY2FsZW5kYXJPcHRpb25zLCBjb250ZXh0KSwgYWN0aXZlUmFuZ2UsIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gcmVkdWNlRXZlbnRTb3VyY2VzKGV2ZW50U291cmNlcywgYWN0aW9uLCBkYXRlUHJvZmlsZSwgY29udGV4dCkge1xuICAgIGxldCBhY3RpdmVSYW5nZSA9IGRhdGVQcm9maWxlID8gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UgOiBudWxsOyAvLyBuZWVkIHRoaXMgY2hlY2s/XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdBRERfRVZFTlRfU09VUkNFUyc6IC8vIGFscmVhZHkgcGFyc2VkXG4gICAgICAgICAgICByZXR1cm4gYWRkU291cmNlcyhldmVudFNvdXJjZXMsIGFjdGlvbi5zb3VyY2VzLCBhY3RpdmVSYW5nZSwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgJ1JFTU9WRV9FVkVOVF9TT1VSQ0UnOlxuICAgICAgICAgICAgcmV0dXJuIHJlbW92ZVNvdXJjZShldmVudFNvdXJjZXMsIGFjdGlvbi5zb3VyY2VJZCk7XG4gICAgICAgIGNhc2UgJ1BSRVYnOiAvLyBUT0RPOiBob3cgZG8gd2UgdHJhY2sgYWxsIGFjdGlvbnMgdGhhdCBhZmZlY3QgZGF0ZVByb2ZpbGUgOihcbiAgICAgICAgY2FzZSAnTkVYVCc6XG4gICAgICAgIGNhc2UgJ0NIQU5HRV9EQVRFJzpcbiAgICAgICAgY2FzZSAnQ0hBTkdFX1ZJRVdfVFlQRSc6XG4gICAgICAgICAgICBpZiAoZGF0ZVByb2ZpbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmV0Y2hEaXJ0eVNvdXJjZXMoZXZlbnRTb3VyY2VzLCBhY3RpdmVSYW5nZSwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRTb3VyY2VzO1xuICAgICAgICBjYXNlICdGRVRDSF9FVkVOVF9TT1VSQ0VTJzpcbiAgICAgICAgICAgIHJldHVybiBmZXRjaFNvdXJjZXNCeUlkcyhldmVudFNvdXJjZXMsIGFjdGlvbi5zb3VyY2VJZHMgPyAvLyB3aHkgbm8gdHlwZT9cbiAgICAgICAgICAgICAgICBhcnJheVRvSGFzaChhY3Rpb24uc291cmNlSWRzKSA6XG4gICAgICAgICAgICAgICAgZXhjbHVkZVN0YXRpY1NvdXJjZXMoZXZlbnRTb3VyY2VzLCBjb250ZXh0KSwgYWN0aXZlUmFuZ2UsIGFjdGlvbi5pc1JlZmV0Y2ggfHwgZmFsc2UsIGNvbnRleHQpO1xuICAgICAgICBjYXNlICdSRUNFSVZFX0VWRU5UUyc6XG4gICAgICAgIGNhc2UgJ1JFQ0VJVkVfRVZFTlRfRVJST1InOlxuICAgICAgICAgICAgcmV0dXJuIHJlY2VpdmVSZXNwb25zZShldmVudFNvdXJjZXMsIGFjdGlvbi5zb3VyY2VJZCwgYWN0aW9uLmZldGNoSWQsIGFjdGlvbi5mZXRjaFJhbmdlKTtcbiAgICAgICAgY2FzZSAnUkVNT1ZFX0FMTF9FVkVOVF9TT1VSQ0VTJzpcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBldmVudFNvdXJjZXM7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVkdWNlRXZlbnRTb3VyY2VzTmV3VGltZVpvbmUoZXZlbnRTb3VyY2VzLCBkYXRlUHJvZmlsZSwgY29udGV4dCkge1xuICAgIGxldCBhY3RpdmVSYW5nZSA9IGRhdGVQcm9maWxlID8gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UgOiBudWxsOyAvLyBuZWVkIHRoaXMgY2hlY2s/XG4gICAgcmV0dXJuIGZldGNoU291cmNlc0J5SWRzKGV2ZW50U291cmNlcywgZXhjbHVkZVN0YXRpY1NvdXJjZXMoZXZlbnRTb3VyY2VzLCBjb250ZXh0KSwgYWN0aXZlUmFuZ2UsIHRydWUsIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gY29tcHV0ZUV2ZW50U291cmNlc0xvYWRpbmcoZXZlbnRTb3VyY2VzKSB7XG4gICAgZm9yIChsZXQgc291cmNlSWQgaW4gZXZlbnRTb3VyY2VzKSB7XG4gICAgICAgIGlmIChldmVudFNvdXJjZXNbc291cmNlSWRdLmlzRmV0Y2hpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGFkZFNvdXJjZXMoZXZlbnRTb3VyY2VIYXNoLCBzb3VyY2VzLCBmZXRjaFJhbmdlLCBjb250ZXh0KSB7XG4gICAgbGV0IGhhc2ggPSB7fTtcbiAgICBmb3IgKGxldCBzb3VyY2Ugb2Ygc291cmNlcykge1xuICAgICAgICBoYXNoW3NvdXJjZS5zb3VyY2VJZF0gPSBzb3VyY2U7XG4gICAgfVxuICAgIGlmIChmZXRjaFJhbmdlKSB7XG4gICAgICAgIGhhc2ggPSBmZXRjaERpcnR5U291cmNlcyhoYXNoLCBmZXRjaFJhbmdlLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRTb3VyY2VIYXNoKSwgaGFzaCk7XG59XG5mdW5jdGlvbiByZW1vdmVTb3VyY2UoZXZlbnRTb3VyY2VIYXNoLCBzb3VyY2VJZCkge1xuICAgIHJldHVybiBmaWx0ZXJIYXNoKGV2ZW50U291cmNlSGFzaCwgKGV2ZW50U291cmNlKSA9PiBldmVudFNvdXJjZS5zb3VyY2VJZCAhPT0gc291cmNlSWQpO1xufVxuZnVuY3Rpb24gZmV0Y2hEaXJ0eVNvdXJjZXMoc291cmNlSGFzaCwgZmV0Y2hSYW5nZSwgY29udGV4dCkge1xuICAgIHJldHVybiBmZXRjaFNvdXJjZXNCeUlkcyhzb3VyY2VIYXNoLCBmaWx0ZXJIYXNoKHNvdXJjZUhhc2gsIChldmVudFNvdXJjZSkgPT4gaXNTb3VyY2VEaXJ0eShldmVudFNvdXJjZSwgZmV0Y2hSYW5nZSwgY29udGV4dCkpLCBmZXRjaFJhbmdlLCBmYWxzZSwgY29udGV4dCk7XG59XG5mdW5jdGlvbiBpc1NvdXJjZURpcnR5KGV2ZW50U291cmNlLCBmZXRjaFJhbmdlLCBjb250ZXh0KSB7XG4gICAgaWYgKCFkb2VzU291cmNlTmVlZFJhbmdlKGV2ZW50U291cmNlLCBjb250ZXh0KSkge1xuICAgICAgICByZXR1cm4gIWV2ZW50U291cmNlLmxhdGVzdEZldGNoSWQ7XG4gICAgfVxuICAgIHJldHVybiAhY29udGV4dC5vcHRpb25zLmxhenlGZXRjaGluZyB8fFxuICAgICAgICAhZXZlbnRTb3VyY2UuZmV0Y2hSYW5nZSB8fFxuICAgICAgICBldmVudFNvdXJjZS5pc0ZldGNoaW5nIHx8IC8vIGFsd2F5cyBjYW5jZWwgb3V0ZGF0ZWQgaW4tcHJvZ3Jlc3MgZmV0Y2hlc1xuICAgICAgICBmZXRjaFJhbmdlLnN0YXJ0IDwgZXZlbnRTb3VyY2UuZmV0Y2hSYW5nZS5zdGFydCB8fFxuICAgICAgICBmZXRjaFJhbmdlLmVuZCA+IGV2ZW50U291cmNlLmZldGNoUmFuZ2UuZW5kO1xufVxuZnVuY3Rpb24gZmV0Y2hTb3VyY2VzQnlJZHMocHJldlNvdXJjZXMsIHNvdXJjZUlkSGFzaCwgZmV0Y2hSYW5nZSwgaXNSZWZldGNoLCBjb250ZXh0KSB7XG4gICAgbGV0IG5leHRTb3VyY2VzID0ge307XG4gICAgZm9yIChsZXQgc291cmNlSWQgaW4gcHJldlNvdXJjZXMpIHtcbiAgICAgICAgbGV0IHNvdXJjZSA9IHByZXZTb3VyY2VzW3NvdXJjZUlkXTtcbiAgICAgICAgaWYgKHNvdXJjZUlkSGFzaFtzb3VyY2VJZF0pIHtcbiAgICAgICAgICAgIG5leHRTb3VyY2VzW3NvdXJjZUlkXSA9IGZldGNoU291cmNlKHNvdXJjZSwgZmV0Y2hSYW5nZSwgaXNSZWZldGNoLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5leHRTb3VyY2VzW3NvdXJjZUlkXSA9IHNvdXJjZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV4dFNvdXJjZXM7XG59XG5mdW5jdGlvbiBmZXRjaFNvdXJjZShldmVudFNvdXJjZSwgZmV0Y2hSYW5nZSwgaXNSZWZldGNoLCBjb250ZXh0KSB7XG4gICAgbGV0IHsgb3B0aW9ucywgY2FsZW5kYXJBcGkgfSA9IGNvbnRleHQ7XG4gICAgbGV0IHNvdXJjZURlZiA9IGNvbnRleHQucGx1Z2luSG9va3MuZXZlbnRTb3VyY2VEZWZzW2V2ZW50U291cmNlLnNvdXJjZURlZklkXTtcbiAgICBsZXQgZmV0Y2hJZCA9IGd1aWQoKTtcbiAgICBzb3VyY2VEZWYuZmV0Y2goe1xuICAgICAgICBldmVudFNvdXJjZSxcbiAgICAgICAgcmFuZ2U6IGZldGNoUmFuZ2UsXG4gICAgICAgIGlzUmVmZXRjaCxcbiAgICAgICAgY29udGV4dCxcbiAgICB9LCAocmVzKSA9PiB7XG4gICAgICAgIGxldCB7IHJhd0V2ZW50cyB9ID0gcmVzO1xuICAgICAgICBpZiAob3B0aW9ucy5ldmVudFNvdXJjZVN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHJhd0V2ZW50cyA9IG9wdGlvbnMuZXZlbnRTb3VyY2VTdWNjZXNzLmNhbGwoY2FsZW5kYXJBcGksIHJhd0V2ZW50cywgcmVzLnJlc3BvbnNlKSB8fCByYXdFdmVudHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50U291cmNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHJhd0V2ZW50cyA9IGV2ZW50U291cmNlLnN1Y2Nlc3MuY2FsbChjYWxlbmRhckFwaSwgcmF3RXZlbnRzLCByZXMucmVzcG9uc2UpIHx8IHJhd0V2ZW50cztcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdSRUNFSVZFX0VWRU5UUycsXG4gICAgICAgICAgICBzb3VyY2VJZDogZXZlbnRTb3VyY2Uuc291cmNlSWQsXG4gICAgICAgICAgICBmZXRjaElkLFxuICAgICAgICAgICAgZmV0Y2hSYW5nZSxcbiAgICAgICAgICAgIHJhd0V2ZW50cyxcbiAgICAgICAgfSk7XG4gICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgIGxldCBlcnJvckhhbmRsZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZXZlbnRTb3VyY2VGYWlsdXJlKSB7XG4gICAgICAgICAgICBvcHRpb25zLmV2ZW50U291cmNlRmFpbHVyZS5jYWxsKGNhbGVuZGFyQXBpLCBlcnJvcik7XG4gICAgICAgICAgICBlcnJvckhhbmRsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudFNvdXJjZS5mYWlsdXJlKSB7XG4gICAgICAgICAgICBldmVudFNvdXJjZS5mYWlsdXJlKGVycm9yKTtcbiAgICAgICAgICAgIGVycm9ySGFuZGxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFlcnJvckhhbmRsZWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihlcnJvci5tZXNzYWdlLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnUkVDRUlWRV9FVkVOVF9FUlJPUicsXG4gICAgICAgICAgICBzb3VyY2VJZDogZXZlbnRTb3VyY2Uuc291cmNlSWQsXG4gICAgICAgICAgICBmZXRjaElkLFxuICAgICAgICAgICAgZmV0Y2hSYW5nZSxcbiAgICAgICAgICAgIGVycm9yLFxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBldmVudFNvdXJjZSksIHsgaXNGZXRjaGluZzogdHJ1ZSwgbGF0ZXN0RmV0Y2hJZDogZmV0Y2hJZCB9KTtcbn1cbmZ1bmN0aW9uIHJlY2VpdmVSZXNwb25zZShzb3VyY2VIYXNoLCBzb3VyY2VJZCwgZmV0Y2hJZCwgZmV0Y2hSYW5nZSkge1xuICAgIGxldCBldmVudFNvdXJjZSA9IHNvdXJjZUhhc2hbc291cmNlSWRdO1xuICAgIGlmIChldmVudFNvdXJjZSAmJiAvLyBub3QgYWxyZWFkeSByZW1vdmVkXG4gICAgICAgIGZldGNoSWQgPT09IGV2ZW50U291cmNlLmxhdGVzdEZldGNoSWQpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc291cmNlSGFzaCksIHsgW3NvdXJjZUlkXTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBldmVudFNvdXJjZSksIHsgaXNGZXRjaGluZzogZmFsc2UsIGZldGNoUmFuZ2UgfSkgfSk7XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2VIYXNoO1xufVxuZnVuY3Rpb24gZXhjbHVkZVN0YXRpY1NvdXJjZXMoZXZlbnRTb3VyY2VzLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGZpbHRlckhhc2goZXZlbnRTb3VyY2VzLCAoZXZlbnRTb3VyY2UpID0+IGRvZXNTb3VyY2VOZWVkUmFuZ2UoZXZlbnRTb3VyY2UsIGNvbnRleHQpKTtcbn1cbmZ1bmN0aW9uIHBhcnNlSW5pdGlhbFNvdXJjZXMocmF3T3B0aW9ucywgY29udGV4dCkge1xuICAgIGxldCByZWZpbmVycyA9IGJ1aWxkRXZlbnRTb3VyY2VSZWZpbmVycyhjb250ZXh0KTtcbiAgICBsZXQgcmF3U291cmNlcyA9IFtdLmNvbmNhdChyYXdPcHRpb25zLmV2ZW50U291cmNlcyB8fCBbXSk7XG4gICAgbGV0IHNvdXJjZXMgPSBbXTsgLy8gcGFyc2VkXG4gICAgaWYgKHJhd09wdGlvbnMuaW5pdGlhbEV2ZW50cykge1xuICAgICAgICByYXdTb3VyY2VzLnVuc2hpZnQocmF3T3B0aW9ucy5pbml0aWFsRXZlbnRzKTtcbiAgICB9XG4gICAgaWYgKHJhd09wdGlvbnMuZXZlbnRzKSB7XG4gICAgICAgIHJhd1NvdXJjZXMudW5zaGlmdChyYXdPcHRpb25zLmV2ZW50cyk7XG4gICAgfVxuICAgIGZvciAobGV0IHJhd1NvdXJjZSBvZiByYXdTb3VyY2VzKSB7XG4gICAgICAgIGxldCBzb3VyY2UgPSBwYXJzZUV2ZW50U291cmNlKHJhd1NvdXJjZSwgY29udGV4dCwgcmVmaW5lcnMpO1xuICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICBzb3VyY2VzLnB1c2goc291cmNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc291cmNlcztcbn1cbmZ1bmN0aW9uIGRvZXNTb3VyY2VOZWVkUmFuZ2UoZXZlbnRTb3VyY2UsIGNvbnRleHQpIHtcbiAgICBsZXQgZGVmcyA9IGNvbnRleHQucGx1Z2luSG9va3MuZXZlbnRTb3VyY2VEZWZzO1xuICAgIHJldHVybiAhZGVmc1tldmVudFNvdXJjZS5zb3VyY2VEZWZJZF0uaWdub3JlUmFuZ2U7XG59XG5cbmZ1bmN0aW9uIHJlZHVjZURhdGVTZWxlY3Rpb24oY3VycmVudFNlbGVjdGlvbiwgYWN0aW9uKSB7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdVTlNFTEVDVF9EQVRFUyc6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSAnU0VMRUNUX0RBVEVTJzpcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb24uc2VsZWN0aW9uO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRTZWxlY3Rpb247XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWR1Y2VTZWxlY3RlZEV2ZW50KGN1cnJlbnRJbnN0YW5jZUlkLCBhY3Rpb24pIHtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ1VOU0VMRUNUX0VWRU5UJzpcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgY2FzZSAnU0VMRUNUX0VWRU5UJzpcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb24uZXZlbnRJbnN0YW5jZUlkO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRJbnN0YW5jZUlkO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVkdWNlRXZlbnREcmFnKGN1cnJlbnREcmFnLCBhY3Rpb24pIHtcbiAgICBsZXQgbmV3RHJhZztcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ1VOU0VUX0VWRU5UX0RSQUcnOlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgJ1NFVF9FVkVOVF9EUkFHJzpcbiAgICAgICAgICAgIG5ld0RyYWcgPSBhY3Rpb24uc3RhdGU7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFmZmVjdGVkRXZlbnRzOiBuZXdEcmFnLmFmZmVjdGVkRXZlbnRzLFxuICAgICAgICAgICAgICAgIG11dGF0ZWRFdmVudHM6IG5ld0RyYWcubXV0YXRlZEV2ZW50cyxcbiAgICAgICAgICAgICAgICBpc0V2ZW50OiBuZXdEcmFnLmlzRXZlbnQsXG4gICAgICAgICAgICB9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnREcmFnO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVkdWNlRXZlbnRSZXNpemUoY3VycmVudFJlc2l6ZSwgYWN0aW9uKSB7XG4gICAgbGV0IG5ld1Jlc2l6ZTtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ1VOU0VUX0VWRU5UX1JFU0laRSc6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSAnU0VUX0VWRU5UX1JFU0laRSc6XG4gICAgICAgICAgICBuZXdSZXNpemUgPSBhY3Rpb24uc3RhdGU7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFmZmVjdGVkRXZlbnRzOiBuZXdSZXNpemUuYWZmZWN0ZWRFdmVudHMsXG4gICAgICAgICAgICAgICAgbXV0YXRlZEV2ZW50czogbmV3UmVzaXplLm11dGF0ZWRFdmVudHMsXG4gICAgICAgICAgICAgICAgaXNFdmVudDogbmV3UmVzaXplLmlzRXZlbnQsXG4gICAgICAgICAgICB9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRSZXNpemU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZVRvb2xiYXJzKGNhbGVuZGFyT3B0aW9ucywgY2FsZW5kYXJPcHRpb25PdmVycmlkZXMsIHRoZW1lLCB2aWV3U3BlY3MsIGNhbGVuZGFyQXBpKSB7XG4gICAgbGV0IGhlYWRlciA9IGNhbGVuZGFyT3B0aW9ucy5oZWFkZXJUb29sYmFyID8gcGFyc2VUb29sYmFyKGNhbGVuZGFyT3B0aW9ucy5oZWFkZXJUb29sYmFyLCBjYWxlbmRhck9wdGlvbnMsIGNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzLCB0aGVtZSwgdmlld1NwZWNzLCBjYWxlbmRhckFwaSkgOiBudWxsO1xuICAgIGxldCBmb290ZXIgPSBjYWxlbmRhck9wdGlvbnMuZm9vdGVyVG9vbGJhciA/IHBhcnNlVG9vbGJhcihjYWxlbmRhck9wdGlvbnMuZm9vdGVyVG9vbGJhciwgY2FsZW5kYXJPcHRpb25zLCBjYWxlbmRhck9wdGlvbk92ZXJyaWRlcywgdGhlbWUsIHZpZXdTcGVjcywgY2FsZW5kYXJBcGkpIDogbnVsbDtcbiAgICByZXR1cm4geyBoZWFkZXIsIGZvb3RlciB9O1xufVxuZnVuY3Rpb24gcGFyc2VUb29sYmFyKHNlY3Rpb25TdHJIYXNoLCBjYWxlbmRhck9wdGlvbnMsIGNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzLCB0aGVtZSwgdmlld1NwZWNzLCBjYWxlbmRhckFwaSkge1xuICAgIGxldCBzZWN0aW9uV2lkZ2V0cyA9IHt9O1xuICAgIGxldCB2aWV3c1dpdGhCdXR0b25zID0gW107XG4gICAgbGV0IGhhc1RpdGxlID0gZmFsc2U7XG4gICAgZm9yIChsZXQgc2VjdGlvbk5hbWUgaW4gc2VjdGlvblN0ckhhc2gpIHtcbiAgICAgICAgbGV0IHNlY3Rpb25TdHIgPSBzZWN0aW9uU3RySGFzaFtzZWN0aW9uTmFtZV07XG4gICAgICAgIGxldCBzZWN0aW9uUmVzID0gcGFyc2VTZWN0aW9uKHNlY3Rpb25TdHIsIGNhbGVuZGFyT3B0aW9ucywgY2FsZW5kYXJPcHRpb25PdmVycmlkZXMsIHRoZW1lLCB2aWV3U3BlY3MsIGNhbGVuZGFyQXBpKTtcbiAgICAgICAgc2VjdGlvbldpZGdldHNbc2VjdGlvbk5hbWVdID0gc2VjdGlvblJlcy53aWRnZXRzO1xuICAgICAgICB2aWV3c1dpdGhCdXR0b25zLnB1c2goLi4uc2VjdGlvblJlcy52aWV3c1dpdGhCdXR0b25zKTtcbiAgICAgICAgaGFzVGl0bGUgPSBoYXNUaXRsZSB8fCBzZWN0aW9uUmVzLmhhc1RpdGxlO1xuICAgIH1cbiAgICByZXR1cm4geyBzZWN0aW9uV2lkZ2V0cywgdmlld3NXaXRoQnV0dG9ucywgaGFzVGl0bGUgfTtcbn1cbi8qXG5CQUQ6IHF1ZXJ5aW5nIGljb25zIGFuZCB0ZXh0IGhlcmUuIHNob3VsZCBiZSBkb25lIGF0IHJlbmRlciB0aW1lXG4qL1xuZnVuY3Rpb24gcGFyc2VTZWN0aW9uKHNlY3Rpb25TdHIsIGNhbGVuZGFyT3B0aW9ucywgLy8gZGVmYXVsdHMrb3ZlcnJpZGVzLCB0aGVuIHJlZmluZWRcbmNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzLCAvLyBvdmVycmlkZXMgb25seSEsIHVucmVmaW5lZCA6KFxudGhlbWUsIHZpZXdTcGVjcywgY2FsZW5kYXJBcGkpIHtcbiAgICBsZXQgaXNSdGwgPSBjYWxlbmRhck9wdGlvbnMuZGlyZWN0aW9uID09PSAncnRsJztcbiAgICBsZXQgY2FsZW5kYXJDdXN0b21CdXR0b25zID0gY2FsZW5kYXJPcHRpb25zLmN1c3RvbUJ1dHRvbnMgfHwge307XG4gICAgbGV0IGNhbGVuZGFyQnV0dG9uVGV4dE92ZXJyaWRlcyA9IGNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzLmJ1dHRvblRleHQgfHwge307XG4gICAgbGV0IGNhbGVuZGFyQnV0dG9uVGV4dCA9IGNhbGVuZGFyT3B0aW9ucy5idXR0b25UZXh0IHx8IHt9O1xuICAgIGxldCBjYWxlbmRhckJ1dHRvbkhpbnRPdmVycmlkZXMgPSBjYWxlbmRhck9wdGlvbk92ZXJyaWRlcy5idXR0b25IaW50cyB8fCB7fTtcbiAgICBsZXQgY2FsZW5kYXJCdXR0b25IaW50cyA9IGNhbGVuZGFyT3B0aW9ucy5idXR0b25IaW50cyB8fCB7fTtcbiAgICBsZXQgc2VjdGlvblN1YnN0cnMgPSBzZWN0aW9uU3RyID8gc2VjdGlvblN0ci5zcGxpdCgnICcpIDogW107XG4gICAgbGV0IHZpZXdzV2l0aEJ1dHRvbnMgPSBbXTtcbiAgICBsZXQgaGFzVGl0bGUgPSBmYWxzZTtcbiAgICBsZXQgd2lkZ2V0cyA9IHNlY3Rpb25TdWJzdHJzLm1hcCgoYnV0dG9uR3JvdXBTdHIpID0+IChidXR0b25Hcm91cFN0ci5zcGxpdCgnLCcpLm1hcCgoYnV0dG9uTmFtZSkgPT4ge1xuICAgICAgICBpZiAoYnV0dG9uTmFtZSA9PT0gJ3RpdGxlJykge1xuICAgICAgICAgICAgaGFzVGl0bGUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHsgYnV0dG9uTmFtZSB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXN0b21CdXR0b25Qcm9wcztcbiAgICAgICAgbGV0IHZpZXdTcGVjO1xuICAgICAgICBsZXQgYnV0dG9uQ2xpY2s7XG4gICAgICAgIGxldCBidXR0b25JY29uOyAvLyBvbmx5IG9uZSBvZiB0aGVzZSB3aWxsIGJlIHNldFxuICAgICAgICBsZXQgYnV0dG9uVGV4dDsgLy8gXCJcbiAgICAgICAgbGV0IGJ1dHRvbkhpbnQ7XG4gICAgICAgIC8vIF4gZm9yIHRoZSB0aXRsZT1cIlwiIGF0dHJpYnV0ZSwgZm9yIGFjY2Vzc2liaWxpdHlcbiAgICAgICAgaWYgKChjdXN0b21CdXR0b25Qcm9wcyA9IGNhbGVuZGFyQ3VzdG9tQnV0dG9uc1tidXR0b25OYW1lXSkpIHtcbiAgICAgICAgICAgIGJ1dHRvbkNsaWNrID0gKGV2KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGN1c3RvbUJ1dHRvblByb3BzLmNsaWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbUJ1dHRvblByb3BzLmNsaWNrLmNhbGwoZXYudGFyZ2V0LCBldiwgZXYudGFyZ2V0KTsgLy8gVE9ETzogdXNlIENhbGVuZGFyIHRoaXMgY29udGV4dD9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgKGJ1dHRvbkljb24gPSB0aGVtZS5nZXRDdXN0b21CdXR0b25JY29uQ2xhc3MoY3VzdG9tQnV0dG9uUHJvcHMpKSB8fFxuICAgICAgICAgICAgICAgIChidXR0b25JY29uID0gdGhlbWUuZ2V0SWNvbkNsYXNzKGJ1dHRvbk5hbWUsIGlzUnRsKSkgfHxcbiAgICAgICAgICAgICAgICAoYnV0dG9uVGV4dCA9IGN1c3RvbUJ1dHRvblByb3BzLnRleHQpO1xuICAgICAgICAgICAgYnV0dG9uSGludCA9IGN1c3RvbUJ1dHRvblByb3BzLmhpbnQgfHwgY3VzdG9tQnV0dG9uUHJvcHMudGV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgodmlld1NwZWMgPSB2aWV3U3BlY3NbYnV0dG9uTmFtZV0pKSB7XG4gICAgICAgICAgICB2aWV3c1dpdGhCdXR0b25zLnB1c2goYnV0dG9uTmFtZSk7XG4gICAgICAgICAgICBidXR0b25DbGljayA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjYWxlbmRhckFwaS5jaGFuZ2VWaWV3KGJ1dHRvbk5hbWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIChidXR0b25UZXh0ID0gdmlld1NwZWMuYnV0dG9uVGV4dE92ZXJyaWRlKSB8fFxuICAgICAgICAgICAgICAgIChidXR0b25JY29uID0gdGhlbWUuZ2V0SWNvbkNsYXNzKGJ1dHRvbk5hbWUsIGlzUnRsKSkgfHxcbiAgICAgICAgICAgICAgICAoYnV0dG9uVGV4dCA9IHZpZXdTcGVjLmJ1dHRvblRleHREZWZhdWx0KTtcbiAgICAgICAgICAgIGxldCB0ZXh0RmFsbGJhY2sgPSB2aWV3U3BlYy5idXR0b25UZXh0T3ZlcnJpZGUgfHxcbiAgICAgICAgICAgICAgICB2aWV3U3BlYy5idXR0b25UZXh0RGVmYXVsdDtcbiAgICAgICAgICAgIGJ1dHRvbkhpbnQgPSBmb3JtYXRXaXRoT3JkaW5hbHModmlld1NwZWMuYnV0dG9uVGl0bGVPdmVycmlkZSB8fFxuICAgICAgICAgICAgICAgIHZpZXdTcGVjLmJ1dHRvblRpdGxlRGVmYXVsdCB8fFxuICAgICAgICAgICAgICAgIGNhbGVuZGFyT3B0aW9ucy52aWV3SGludCwgW3RleHRGYWxsYmFjaywgYnV0dG9uTmFtZV0sIC8vIHZpZXctbmFtZSA9IGJ1dHRvbk5hbWVcbiAgICAgICAgICAgIHRleHRGYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2FsZW5kYXJBcGlbYnV0dG9uTmFtZV0pIHsgLy8gYSBjYWxlbmRhckFwaSBtZXRob2RcbiAgICAgICAgICAgIGJ1dHRvbkNsaWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGVuZGFyQXBpW2J1dHRvbk5hbWVdKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgKGJ1dHRvblRleHQgPSBjYWxlbmRhckJ1dHRvblRleHRPdmVycmlkZXNbYnV0dG9uTmFtZV0pIHx8XG4gICAgICAgICAgICAgICAgKGJ1dHRvbkljb24gPSB0aGVtZS5nZXRJY29uQ2xhc3MoYnV0dG9uTmFtZSwgaXNSdGwpKSB8fFxuICAgICAgICAgICAgICAgIChidXR0b25UZXh0ID0gY2FsZW5kYXJCdXR0b25UZXh0W2J1dHRvbk5hbWVdKTsgLy8gZXZlcnl0aGluZyBlbHNlIGlzIGNvbnNpZGVyZWQgZGVmYXVsdFxuICAgICAgICAgICAgaWYgKGJ1dHRvbk5hbWUgPT09ICdwcmV2WWVhcicgfHwgYnV0dG9uTmFtZSA9PT0gJ25leHRZZWFyJykge1xuICAgICAgICAgICAgICAgIGxldCBwcmV2T3JOZXh0ID0gYnV0dG9uTmFtZSA9PT0gJ3ByZXZZZWFyJyA/ICdwcmV2JyA6ICduZXh0JztcbiAgICAgICAgICAgICAgICBidXR0b25IaW50ID0gZm9ybWF0V2l0aE9yZGluYWxzKGNhbGVuZGFyQnV0dG9uSGludE92ZXJyaWRlc1twcmV2T3JOZXh0XSB8fFxuICAgICAgICAgICAgICAgICAgICBjYWxlbmRhckJ1dHRvbkhpbnRzW3ByZXZPck5leHRdLCBbXG4gICAgICAgICAgICAgICAgICAgIGNhbGVuZGFyQnV0dG9uVGV4dC55ZWFyIHx8ICd5ZWFyJyxcbiAgICAgICAgICAgICAgICAgICAgJ3llYXInLFxuICAgICAgICAgICAgICAgIF0sIGNhbGVuZGFyQnV0dG9uVGV4dFtidXR0b25OYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBidXR0b25IaW50ID0gKG5hdlVuaXQpID0+IGZvcm1hdFdpdGhPcmRpbmFscyhjYWxlbmRhckJ1dHRvbkhpbnRPdmVycmlkZXNbYnV0dG9uTmFtZV0gfHxcbiAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXJCdXR0b25IaW50c1tidXR0b25OYW1lXSwgW1xuICAgICAgICAgICAgICAgICAgICBjYWxlbmRhckJ1dHRvblRleHRbbmF2VW5pdF0gfHwgbmF2VW5pdCxcbiAgICAgICAgICAgICAgICAgICAgbmF2VW5pdCxcbiAgICAgICAgICAgICAgICBdLCBjYWxlbmRhckJ1dHRvblRleHRbYnV0dG9uTmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGJ1dHRvbk5hbWUsIGJ1dHRvbkNsaWNrLCBidXR0b25JY29uLCBidXR0b25UZXh0LCBidXR0b25IaW50IH07XG4gICAgfSkpKTtcbiAgICByZXR1cm4geyB3aWRnZXRzLCB2aWV3c1dpdGhCdXR0b25zLCBoYXNUaXRsZSB9O1xufVxuXG4vLyBhbHdheXMgcmVwcmVzZW50cyB0aGUgY3VycmVudCB2aWV3LiBvdGhlcndpc2UsIGl0J2QgbmVlZCB0byBjaGFuZ2UgdmFsdWUgZXZlcnkgdGltZSBkYXRlIGNoYW5nZXNcbmNsYXNzIFZpZXdJbXBsIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBnZXRDdXJyZW50RGF0YSwgZGF0ZUVudikge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmdldEN1cnJlbnREYXRhID0gZ2V0Q3VycmVudERhdGE7XG4gICAgICAgIHRoaXMuZGF0ZUVudiA9IGRhdGVFbnY7XG4gICAgfVxuICAgIGdldCBjYWxlbmRhcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudERhdGEoKS5jYWxlbmRhckFwaTtcbiAgICB9XG4gICAgZ2V0IHRpdGxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50RGF0YSgpLnZpZXdUaXRsZTtcbiAgICB9XG4gICAgZ2V0IGFjdGl2ZVN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlRW52LnRvRGF0ZSh0aGlzLmdldEN1cnJlbnREYXRhKCkuZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2Uuc3RhcnQpO1xuICAgIH1cbiAgICBnZXQgYWN0aXZlRW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlRW52LnRvRGF0ZSh0aGlzLmdldEN1cnJlbnREYXRhKCkuZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UuZW5kKTtcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRTdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZUVudi50b0RhdGUodGhpcy5nZXRDdXJyZW50RGF0YSgpLmRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5zdGFydCk7XG4gICAgfVxuICAgIGdldCBjdXJyZW50RW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlRW52LnRvRGF0ZSh0aGlzLmdldEN1cnJlbnREYXRhKCkuZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLmVuZCk7XG4gICAgfVxuICAgIGdldE9wdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnREYXRhKCkub3B0aW9uc1tuYW1lXTsgLy8gYXJlIHRoZSB2aWV3LXNwZWNpZmljIG9wdGlvbnNcbiAgICB9XG59XG5cbmxldCBldmVudFNvdXJjZURlZiQyID0ge1xuICAgIGlnbm9yZVJhbmdlOiB0cnVlLFxuICAgIHBhcnNlTWV0YShyZWZpbmVkKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlZmluZWQuZXZlbnRzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlZmluZWQuZXZlbnRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgZmV0Y2goYXJnLCBzdWNjZXNzQ2FsbGJhY2spIHtcbiAgICAgICAgc3VjY2Vzc0NhbGxiYWNrKHtcbiAgICAgICAgICAgIHJhd0V2ZW50czogYXJnLmV2ZW50U291cmNlLm1ldGEsXG4gICAgICAgIH0pO1xuICAgIH0sXG59O1xuY29uc3QgYXJyYXlFdmVudFNvdXJjZVBsdWdpbiA9IGNyZWF0ZVBsdWdpbih7XG4gICAgbmFtZTogJ2FycmF5LWV2ZW50LXNvdXJjZScsXG4gICAgZXZlbnRTb3VyY2VEZWZzOiBbZXZlbnRTb3VyY2VEZWYkMl0sXG59KTtcblxubGV0IGV2ZW50U291cmNlRGVmJDEgPSB7XG4gICAgcGFyc2VNZXRhKHJlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZWZpbmVkLmV2ZW50cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIHJlZmluZWQuZXZlbnRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgZmV0Y2goYXJnLCBzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgeyBkYXRlRW52IH0gPSBhcmcuY29udGV4dDtcbiAgICAgICAgY29uc3QgZnVuYyA9IGFyZy5ldmVudFNvdXJjZS5tZXRhO1xuICAgICAgICB1bnByb21pc2lmeShmdW5jLmJpbmQobnVsbCwgYnVpbGRSYW5nZUFwaVdpdGhUaW1lWm9uZShhcmcucmFuZ2UsIGRhdGVFbnYpKSwgKHJhd0V2ZW50cykgPT4gc3VjY2Vzc0NhbGxiYWNrKHsgcmF3RXZlbnRzIH0pLCBlcnJvckNhbGxiYWNrKTtcbiAgICB9LFxufTtcbmNvbnN0IGZ1bmNFdmVudFNvdXJjZVBsdWdpbiA9IGNyZWF0ZVBsdWdpbih7XG4gICAgbmFtZTogJ2Z1bmMtZXZlbnQtc291cmNlJyxcbiAgICBldmVudFNvdXJjZURlZnM6IFtldmVudFNvdXJjZURlZiQxXSxcbn0pO1xuXG5jb25zdCBKU09OX0ZFRURfRVZFTlRfU09VUkNFX1JFRklORVJTID0ge1xuICAgIG1ldGhvZDogU3RyaW5nLFxuICAgIGV4dHJhUGFyYW1zOiBpZGVudGl0eSxcbiAgICBzdGFydFBhcmFtOiBTdHJpbmcsXG4gICAgZW5kUGFyYW06IFN0cmluZyxcbiAgICB0aW1lWm9uZVBhcmFtOiBTdHJpbmcsXG59O1xuXG5sZXQgZXZlbnRTb3VyY2VEZWYgPSB7XG4gICAgcGFyc2VNZXRhKHJlZmluZWQpIHtcbiAgICAgICAgaWYgKHJlZmluZWQudXJsICYmIChyZWZpbmVkLmZvcm1hdCA9PT0gJ2pzb24nIHx8ICFyZWZpbmVkLmZvcm1hdCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiByZWZpbmVkLnVybCxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICdqc29uJyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IChyZWZpbmVkLm1ldGhvZCB8fCAnR0VUJykudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICAgICAgICBleHRyYVBhcmFtczogcmVmaW5lZC5leHRyYVBhcmFtcyxcbiAgICAgICAgICAgICAgICBzdGFydFBhcmFtOiByZWZpbmVkLnN0YXJ0UGFyYW0sXG4gICAgICAgICAgICAgICAgZW5kUGFyYW06IHJlZmluZWQuZW5kUGFyYW0sXG4gICAgICAgICAgICAgICAgdGltZVpvbmVQYXJhbTogcmVmaW5lZC50aW1lWm9uZVBhcmFtLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGZldGNoKGFyZywgc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHsgbWV0YSB9ID0gYXJnLmV2ZW50U291cmNlO1xuICAgICAgICBjb25zdCByZXF1ZXN0UGFyYW1zID0gYnVpbGRSZXF1ZXN0UGFyYW1zKG1ldGEsIGFyZy5yYW5nZSwgYXJnLmNvbnRleHQpO1xuICAgICAgICByZXF1ZXN0SnNvbihtZXRhLm1ldGhvZCwgbWV0YS51cmwsIHJlcXVlc3RQYXJhbXMpLnRoZW4oKFtyYXdFdmVudHMsIHJlc3BvbnNlXSkgPT4ge1xuICAgICAgICAgICAgc3VjY2Vzc0NhbGxiYWNrKHsgcmF3RXZlbnRzLCByZXNwb25zZSB9KTtcbiAgICAgICAgfSwgZXJyb3JDYWxsYmFjayk7XG4gICAgfSxcbn07XG5jb25zdCBqc29uRmVlZEV2ZW50U291cmNlUGx1Z2luID0gY3JlYXRlUGx1Z2luKHtcbiAgICBuYW1lOiAnanNvbi1ldmVudC1zb3VyY2UnLFxuICAgIGV2ZW50U291cmNlUmVmaW5lcnM6IEpTT05fRkVFRF9FVkVOVF9TT1VSQ0VfUkVGSU5FUlMsXG4gICAgZXZlbnRTb3VyY2VEZWZzOiBbZXZlbnRTb3VyY2VEZWZdLFxufSk7XG5mdW5jdGlvbiBidWlsZFJlcXVlc3RQYXJhbXMobWV0YSwgcmFuZ2UsIGNvbnRleHQpIHtcbiAgICBsZXQgeyBkYXRlRW52LCBvcHRpb25zIH0gPSBjb250ZXh0O1xuICAgIGxldCBzdGFydFBhcmFtO1xuICAgIGxldCBlbmRQYXJhbTtcbiAgICBsZXQgdGltZVpvbmVQYXJhbTtcbiAgICBsZXQgY3VzdG9tUmVxdWVzdFBhcmFtcztcbiAgICBsZXQgcGFyYW1zID0ge307XG4gICAgc3RhcnRQYXJhbSA9IG1ldGEuc3RhcnRQYXJhbTtcbiAgICBpZiAoc3RhcnRQYXJhbSA9PSBudWxsKSB7XG4gICAgICAgIHN0YXJ0UGFyYW0gPSBvcHRpb25zLnN0YXJ0UGFyYW07XG4gICAgfVxuICAgIGVuZFBhcmFtID0gbWV0YS5lbmRQYXJhbTtcbiAgICBpZiAoZW5kUGFyYW0gPT0gbnVsbCkge1xuICAgICAgICBlbmRQYXJhbSA9IG9wdGlvbnMuZW5kUGFyYW07XG4gICAgfVxuICAgIHRpbWVab25lUGFyYW0gPSBtZXRhLnRpbWVab25lUGFyYW07XG4gICAgaWYgKHRpbWVab25lUGFyYW0gPT0gbnVsbCkge1xuICAgICAgICB0aW1lWm9uZVBhcmFtID0gb3B0aW9ucy50aW1lWm9uZVBhcmFtO1xuICAgIH1cbiAgICAvLyByZXRyaWV2ZSBhbnkgb3V0Ym91bmQgR0VUL1BPU1QgZGF0YSBmcm9tIHRoZSBvcHRpb25zXG4gICAgaWYgKHR5cGVvZiBtZXRhLmV4dHJhUGFyYW1zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIHN1cHBsaWVkIGFzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEga2V5L3ZhbHVlIG9iamVjdFxuICAgICAgICBjdXN0b21SZXF1ZXN0UGFyYW1zID0gbWV0YS5leHRyYVBhcmFtcygpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gcHJvYmFibHkgc3VwcGxpZWQgYXMgYSBzdHJhaWdodCBrZXkvdmFsdWUgb2JqZWN0XG4gICAgICAgIGN1c3RvbVJlcXVlc3RQYXJhbXMgPSBtZXRhLmV4dHJhUGFyYW1zIHx8IHt9O1xuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKHBhcmFtcywgY3VzdG9tUmVxdWVzdFBhcmFtcyk7XG4gICAgcGFyYW1zW3N0YXJ0UGFyYW1dID0gZGF0ZUVudi5mb3JtYXRJc28ocmFuZ2Uuc3RhcnQpO1xuICAgIHBhcmFtc1tlbmRQYXJhbV0gPSBkYXRlRW52LmZvcm1hdElzbyhyYW5nZS5lbmQpO1xuICAgIGlmIChkYXRlRW52LnRpbWVab25lICE9PSAnbG9jYWwnKSB7XG4gICAgICAgIHBhcmFtc1t0aW1lWm9uZVBhcmFtXSA9IGRhdGVFbnYudGltZVpvbmU7XG4gICAgfVxuICAgIHJldHVybiBwYXJhbXM7XG59XG5cbmNvbnN0IFNJTVBMRV9SRUNVUlJJTkdfUkVGSU5FUlMgPSB7XG4gICAgZGF5c09mV2VlazogaWRlbnRpdHksXG4gICAgc3RhcnRUaW1lOiBjcmVhdGVEdXJhdGlvbixcbiAgICBlbmRUaW1lOiBjcmVhdGVEdXJhdGlvbixcbiAgICBkdXJhdGlvbjogY3JlYXRlRHVyYXRpb24sXG4gICAgc3RhcnRSZWN1cjogaWRlbnRpdHksXG4gICAgZW5kUmVjdXI6IGlkZW50aXR5LFxufTtcblxubGV0IHJlY3VycmluZyA9IHtcbiAgICBwYXJzZShyZWZpbmVkLCBkYXRlRW52KSB7XG4gICAgICAgIGlmIChyZWZpbmVkLmRheXNPZldlZWsgfHwgcmVmaW5lZC5zdGFydFRpbWUgfHwgcmVmaW5lZC5lbmRUaW1lIHx8IHJlZmluZWQuc3RhcnRSZWN1ciB8fCByZWZpbmVkLmVuZFJlY3VyKSB7XG4gICAgICAgICAgICBsZXQgcmVjdXJyaW5nRGF0YSA9IHtcbiAgICAgICAgICAgICAgICBkYXlzT2ZXZWVrOiByZWZpbmVkLmRheXNPZldlZWsgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICBzdGFydFRpbWU6IHJlZmluZWQuc3RhcnRUaW1lIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgZW5kVGltZTogcmVmaW5lZC5lbmRUaW1lIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgc3RhcnRSZWN1cjogcmVmaW5lZC5zdGFydFJlY3VyID8gZGF0ZUVudi5jcmVhdGVNYXJrZXIocmVmaW5lZC5zdGFydFJlY3VyKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgZW5kUmVjdXI6IHJlZmluZWQuZW5kUmVjdXIgPyBkYXRlRW52LmNyZWF0ZU1hcmtlcihyZWZpbmVkLmVuZFJlY3VyKSA6IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IGR1cmF0aW9uO1xuICAgICAgICAgICAgaWYgKHJlZmluZWQuZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IHJlZmluZWQuZHVyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWR1cmF0aW9uICYmIHJlZmluZWQuc3RhcnRUaW1lICYmIHJlZmluZWQuZW5kVGltZSkge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gc3VidHJhY3REdXJhdGlvbnMocmVmaW5lZC5lbmRUaW1lLCByZWZpbmVkLnN0YXJ0VGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFsbERheUd1ZXNzOiBCb29sZWFuKCFyZWZpbmVkLnN0YXJ0VGltZSAmJiAhcmVmaW5lZC5lbmRUaW1lKSxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgICAgICAgICB0eXBlRGF0YTogcmVjdXJyaW5nRGF0YSwgLy8gZG9lc24ndCBuZWVkIGVuZFRpbWUgYW55bW9yZSBidXQgb2ggd2VsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGV4cGFuZCh0eXBlRGF0YSwgZnJhbWluZ1JhbmdlLCBkYXRlRW52KSB7XG4gICAgICAgIGxldCBjbGlwcGVkRnJhbWluZ1JhbmdlID0gaW50ZXJzZWN0UmFuZ2VzKGZyYW1pbmdSYW5nZSwgeyBzdGFydDogdHlwZURhdGEuc3RhcnRSZWN1ciwgZW5kOiB0eXBlRGF0YS5lbmRSZWN1ciB9KTtcbiAgICAgICAgaWYgKGNsaXBwZWRGcmFtaW5nUmFuZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBleHBhbmRSYW5nZXModHlwZURhdGEuZGF5c09mV2VlaywgdHlwZURhdGEuc3RhcnRUaW1lLCBjbGlwcGVkRnJhbWluZ1JhbmdlLCBkYXRlRW52KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfSxcbn07XG5jb25zdCBzaW1wbGVSZWN1cnJpbmdFdmVudHNQbHVnaW4gPSBjcmVhdGVQbHVnaW4oe1xuICAgIG5hbWU6ICdzaW1wbGUtcmVjdXJyaW5nLWV2ZW50JyxcbiAgICByZWN1cnJpbmdUeXBlczogW3JlY3VycmluZ10sXG4gICAgZXZlbnRSZWZpbmVyczogU0lNUExFX1JFQ1VSUklOR19SRUZJTkVSUyxcbn0pO1xuZnVuY3Rpb24gZXhwYW5kUmFuZ2VzKGRheXNPZldlZWssIHN0YXJ0VGltZSwgZnJhbWluZ1JhbmdlLCBkYXRlRW52KSB7XG4gICAgbGV0IGRvd0hhc2ggPSBkYXlzT2ZXZWVrID8gYXJyYXlUb0hhc2goZGF5c09mV2VlaykgOiBudWxsO1xuICAgIGxldCBkYXlNYXJrZXIgPSBzdGFydE9mRGF5KGZyYW1pbmdSYW5nZS5zdGFydCk7XG4gICAgbGV0IGVuZE1hcmtlciA9IGZyYW1pbmdSYW5nZS5lbmQ7XG4gICAgbGV0IGluc3RhbmNlU3RhcnRzID0gW107XG4gICAgd2hpbGUgKGRheU1hcmtlciA8IGVuZE1hcmtlcikge1xuICAgICAgICBsZXQgaW5zdGFuY2VTdGFydDtcbiAgICAgICAgLy8gaWYgZXZlcnlkYXksIG9yIHRoaXMgcGFydGljdWxhciBkYXktb2Ytd2Vla1xuICAgICAgICBpZiAoIWRvd0hhc2ggfHwgZG93SGFzaFtkYXlNYXJrZXIuZ2V0VVRDRGF5KCldKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnRUaW1lKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2VTdGFydCA9IGRhdGVFbnYuYWRkKGRheU1hcmtlciwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlU3RhcnQgPSBkYXlNYXJrZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnN0YW5jZVN0YXJ0cy5wdXNoKGluc3RhbmNlU3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGRheU1hcmtlciA9IGFkZERheXMoZGF5TWFya2VyLCAxKTtcbiAgICB9XG4gICAgcmV0dXJuIGluc3RhbmNlU3RhcnRzO1xufVxuXG5jb25zdCBjaGFuZ2VIYW5kbGVyUGx1Z2luID0gY3JlYXRlUGx1Z2luKHtcbiAgICBuYW1lOiAnY2hhbmdlLWhhbmRsZXInLFxuICAgIG9wdGlvbkNoYW5nZUhhbmRsZXJzOiB7XG4gICAgICAgIGV2ZW50cyhldmVudHMsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGhhbmRsZUV2ZW50U291cmNlcyhbZXZlbnRzXSwgY29udGV4dCk7XG4gICAgICAgIH0sXG4gICAgICAgIGV2ZW50U291cmNlczogaGFuZGxlRXZlbnRTb3VyY2VzLFxuICAgIH0sXG59KTtcbi8qXG5CVUc6IGlmIGBldmVudGAgd2FzIHN1cHBsaWVkLCBhbGwgcHJldmlvdXNseS1naXZlbiBgZXZlbnRTb3VyY2VzYCB3aWxsIGJlIHdpcGVkIG91dFxuKi9cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50U291cmNlcyhpbnB1dHMsIGNvbnRleHQpIHtcbiAgICBsZXQgdW5mb3VuZFNvdXJjZXMgPSBoYXNoVmFsdWVzVG9BcnJheShjb250ZXh0LmdldEN1cnJlbnREYXRhKCkuZXZlbnRTb3VyY2VzKTtcbiAgICBpZiAodW5mb3VuZFNvdXJjZXMubGVuZ3RoID09PSAxICYmXG4gICAgICAgIGlucHV0cy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgQXJyYXkuaXNBcnJheSh1bmZvdW5kU291cmNlc1swXS5fcmF3KSAmJlxuICAgICAgICBBcnJheS5pc0FycmF5KGlucHV0c1swXSkpIHtcbiAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnUkVTRVRfUkFXX0VWRU5UUycsXG4gICAgICAgICAgICBzb3VyY2VJZDogdW5mb3VuZFNvdXJjZXNbMF0uc291cmNlSWQsXG4gICAgICAgICAgICByYXdFdmVudHM6IGlucHV0c1swXSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IG5ld0lucHV0cyA9IFtdO1xuICAgIGZvciAobGV0IGlucHV0IG9mIGlucHV0cykge1xuICAgICAgICBsZXQgaW5wdXRGb3VuZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVuZm91bmRTb3VyY2VzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAodW5mb3VuZFNvdXJjZXNbaV0uX3JhdyA9PT0gaW5wdXQpIHtcbiAgICAgICAgICAgICAgICB1bmZvdW5kU291cmNlcy5zcGxpY2UoaSwgMSk7IC8vIGRlbGV0ZVxuICAgICAgICAgICAgICAgIGlucHV0Rm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaW5wdXRGb3VuZCkge1xuICAgICAgICAgICAgbmV3SW5wdXRzLnB1c2goaW5wdXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IHVuZm91bmRTb3VyY2Ugb2YgdW5mb3VuZFNvdXJjZXMpIHtcbiAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnUkVNT1ZFX0VWRU5UX1NPVVJDRScsXG4gICAgICAgICAgICBzb3VyY2VJZDogdW5mb3VuZFNvdXJjZS5zb3VyY2VJZCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZvciAobGV0IG5ld0lucHV0IG9mIG5ld0lucHV0cykge1xuICAgICAgICBjb250ZXh0LmNhbGVuZGFyQXBpLmFkZEV2ZW50U291cmNlKG5ld0lucHV0KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZURhdGVQcm9maWxlKGRhdGVQcm9maWxlLCBjb250ZXh0KSB7XG4gICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2RhdGVzU2V0JywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBidWlsZFJhbmdlQXBpV2l0aFRpbWVab25lKGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLCBjb250ZXh0LmRhdGVFbnYpKSwgeyB2aWV3OiBjb250ZXh0LnZpZXdBcGkgfSkpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVFdmVudFN0b3JlKGV2ZW50U3RvcmUsIGNvbnRleHQpIHtcbiAgICBsZXQgeyBlbWl0dGVyIH0gPSBjb250ZXh0O1xuICAgIGlmIChlbWl0dGVyLmhhc0hhbmRsZXJzKCdldmVudHNTZXQnKSkge1xuICAgICAgICBlbWl0dGVyLnRyaWdnZXIoJ2V2ZW50c1NldCcsIGJ1aWxkRXZlbnRBcGlzKGV2ZW50U3RvcmUsIGNvbnRleHQpKTtcbiAgICB9XG59XG5cbi8qXG50aGlzIGFycmF5IGlzIGV4cG9zZWQgb24gdGhlIHJvb3QgbmFtZXNwYWNlIHNvIHRoYXQgVU1EIHBsdWdpbnMgY2FuIGFkZCB0byBpdC5cbnNlZSB0aGUgcm9sbHVwLWJ1bmRsZXMgc2NyaXB0LlxuKi9cbmNvbnN0IGdsb2JhbFBsdWdpbnMgPSBbXG4gICAgYXJyYXlFdmVudFNvdXJjZVBsdWdpbixcbiAgICBmdW5jRXZlbnRTb3VyY2VQbHVnaW4sXG4gICAganNvbkZlZWRFdmVudFNvdXJjZVBsdWdpbixcbiAgICBzaW1wbGVSZWN1cnJpbmdFdmVudHNQbHVnaW4sXG4gICAgY2hhbmdlSGFuZGxlclBsdWdpbixcbiAgICBjcmVhdGVQbHVnaW4oe1xuICAgICAgICBuYW1lOiAnbWlzYycsXG4gICAgICAgIGlzTG9hZGluZ0Z1bmNzOiBbXG4gICAgICAgICAgICAoc3RhdGUpID0+IGNvbXB1dGVFdmVudFNvdXJjZXNMb2FkaW5nKHN0YXRlLmV2ZW50U291cmNlcyksXG4gICAgICAgIF0sXG4gICAgICAgIHByb3BTZXRIYW5kbGVyczoge1xuICAgICAgICAgICAgZGF0ZVByb2ZpbGU6IGhhbmRsZURhdGVQcm9maWxlLFxuICAgICAgICAgICAgZXZlbnRTdG9yZTogaGFuZGxlRXZlbnRTdG9yZSxcbiAgICAgICAgfSxcbiAgICB9KSxcbl07XG5cbmNsYXNzIFRhc2tSdW5uZXIge1xuICAgIGNvbnN0cnVjdG9yKHJ1blRhc2tPcHRpb24sIGRyYWluZWRPcHRpb24pIHtcbiAgICAgICAgdGhpcy5ydW5UYXNrT3B0aW9uID0gcnVuVGFza09wdGlvbjtcbiAgICAgICAgdGhpcy5kcmFpbmVkT3B0aW9uID0gZHJhaW5lZE9wdGlvbjtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLmRlbGF5ZWRSdW5uZXIgPSBuZXcgRGVsYXllZFJ1bm5lcih0aGlzLmRyYWluLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICByZXF1ZXN0KHRhc2ssIGRlbGF5KSB7XG4gICAgICAgIHRoaXMucXVldWUucHVzaCh0YXNrKTtcbiAgICAgICAgdGhpcy5kZWxheWVkUnVubmVyLnJlcXVlc3QoZGVsYXkpO1xuICAgIH1cbiAgICBwYXVzZShzY29wZSkge1xuICAgICAgICB0aGlzLmRlbGF5ZWRSdW5uZXIucGF1c2Uoc2NvcGUpO1xuICAgIH1cbiAgICByZXN1bWUoc2NvcGUsIGZvcmNlKSB7XG4gICAgICAgIHRoaXMuZGVsYXllZFJ1bm5lci5yZXN1bWUoc2NvcGUsIGZvcmNlKTtcbiAgICB9XG4gICAgZHJhaW4oKSB7XG4gICAgICAgIGxldCB7IHF1ZXVlIH0gPSB0aGlzO1xuICAgICAgICB3aGlsZSAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgY29tcGxldGVkVGFza3MgPSBbXTtcbiAgICAgICAgICAgIGxldCB0YXNrO1xuICAgICAgICAgICAgd2hpbGUgKCh0YXNrID0gcXVldWUuc2hpZnQoKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1blRhc2sodGFzayk7XG4gICAgICAgICAgICAgICAgY29tcGxldGVkVGFza3MucHVzaCh0YXNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZHJhaW5lZChjb21wbGV0ZWRUYXNrcyk7XG4gICAgICAgIH0gLy8ga2VlcCBnb2luZywgaW4gY2FzZSBuZXcgdGFza3Mgd2VyZSBhZGRlZCBpbiB0aGUgZHJhaW5lZCBoYW5kbGVyXG4gICAgfVxuICAgIHJ1blRhc2sodGFzaykge1xuICAgICAgICBpZiAodGhpcy5ydW5UYXNrT3B0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnJ1blRhc2tPcHRpb24odGFzayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZHJhaW5lZChjb21wbGV0ZWRUYXNrcykge1xuICAgICAgICBpZiAodGhpcy5kcmFpbmVkT3B0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWluZWRPcHRpb24oY29tcGxldGVkVGFza3MpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBDb21wdXRlcyB3aGF0IHRoZSB0aXRsZSBhdCB0aGUgdG9wIG9mIHRoZSBjYWxlbmRhckFwaSBzaG91bGQgYmUgZm9yIHRoaXMgdmlld1xuZnVuY3Rpb24gYnVpbGRUaXRsZShkYXRlUHJvZmlsZSwgdmlld09wdGlvbnMsIGRhdGVFbnYpIHtcbiAgICBsZXQgcmFuZ2U7XG4gICAgLy8gZm9yIHZpZXdzIHRoYXQgc3BhbiBhIGxhcmdlIHVuaXQgb2YgdGltZSwgc2hvdyB0aGUgcHJvcGVyIGludGVydmFsLCBpZ25vcmluZyBzdHJheSBkYXlzIGJlZm9yZSBhbmQgYWZ0ZXJcbiAgICBpZiAoL14oeWVhcnxtb250aCkkLy50ZXN0KGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZVVuaXQpKSB7XG4gICAgICAgIHJhbmdlID0gZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlO1xuICAgIH1cbiAgICBlbHNlIHsgLy8gZm9yIGRheSB1bml0cyBvciBzbWFsbGVyLCB1c2UgdGhlIGFjdHVhbCBkYXkgcmFuZ2VcbiAgICAgICAgcmFuZ2UgPSBkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0UmFuZ2UocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCwgY3JlYXRlRm9ybWF0dGVyKHZpZXdPcHRpb25zLnRpdGxlRm9ybWF0IHx8IGJ1aWxkVGl0bGVGb3JtYXQoZGF0ZVByb2ZpbGUpKSwge1xuICAgICAgICBpc0VuZEV4Y2x1c2l2ZTogZGF0ZVByb2ZpbGUuaXNSYW5nZUFsbERheSxcbiAgICAgICAgZGVmYXVsdFNlcGFyYXRvcjogdmlld09wdGlvbnMudGl0bGVSYW5nZVNlcGFyYXRvcixcbiAgICB9KTtcbn1cbi8vIEdlbmVyYXRlcyB0aGUgZm9ybWF0IHN0cmluZyB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIGdlbmVyYXRlIHRoZSB0aXRsZSBmb3IgdGhlIGN1cnJlbnQgZGF0ZSByYW5nZS5cbi8vIEF0dGVtcHRzIHRvIGNvbXB1dGUgdGhlIG1vc3QgYXBwcm9wcmlhdGUgZm9ybWF0IGlmIG5vdCBleHBsaWNpdGx5IHNwZWNpZmllZCB3aXRoIGB0aXRsZUZvcm1hdGAuXG5mdW5jdGlvbiBidWlsZFRpdGxlRm9ybWF0KGRhdGVQcm9maWxlKSB7XG4gICAgbGV0IHsgY3VycmVudFJhbmdlVW5pdCB9ID0gZGF0ZVByb2ZpbGU7XG4gICAgaWYgKGN1cnJlbnRSYW5nZVVuaXQgPT09ICd5ZWFyJykge1xuICAgICAgICByZXR1cm4geyB5ZWFyOiAnbnVtZXJpYycgfTtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRSYW5nZVVuaXQgPT09ICdtb250aCcpIHtcbiAgICAgICAgcmV0dXJuIHsgeWVhcjogJ251bWVyaWMnLCBtb250aDogJ2xvbmcnIH07IC8vIGxpa2UgXCJTZXB0ZW1iZXIgMjAxNFwiXG4gICAgfVxuICAgIGxldCBkYXlzID0gZGlmZldob2xlRGF5cyhkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2Uuc3RhcnQsIGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5lbmQpO1xuICAgIGlmIChkYXlzICE9PSBudWxsICYmIGRheXMgPiAxKSB7XG4gICAgICAgIC8vIG11bHRpLWRheSByYW5nZS4gc2hvcnRlciwgbGlrZSBcIlNlcCA5IC0gMTAgMjAxNFwiXG4gICAgICAgIHJldHVybiB7IHllYXI6ICdudW1lcmljJywgbW9udGg6ICdzaG9ydCcsIGRheTogJ251bWVyaWMnIH07XG4gICAgfVxuICAgIC8vIG9uZSBkYXkuIGxvbmdlciwgbGlrZSBcIlNlcHRlbWJlciA5IDIwMTRcIlxuICAgIHJldHVybiB7IHllYXI6ICdudW1lcmljJywgbW9udGg6ICdsb25nJywgZGF5OiAnbnVtZXJpYycgfTtcbn1cblxuLy8gaW4gZnV0dXJlIHJlZmFjdG9yLCBkbyB0aGUgcmVkdXgtc3R5bGUgZnVuY3Rpb24oc3RhdGU9aW5pdGlhbCkgZm9yIGluaXRpYWwtc3RhdGVcbi8vIGFsc28sIHdoYXRldmVyIGlzIGhhcHBlbmluZyBpbiBjb25zdHJ1Y3RvciwgaGF2ZSBpdCBoYXBwZW4gaW4gYWN0aW9uIHF1ZXVlIHRvb1xuY2xhc3MgQ2FsZW5kYXJEYXRhTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgdGhpcy5jb21wdXRlQ3VycmVudFZpZXdEYXRhID0gbWVtb2l6ZSh0aGlzLl9jb21wdXRlQ3VycmVudFZpZXdEYXRhKTtcbiAgICAgICAgdGhpcy5vcmdhbml6ZVJhd0xvY2FsZXMgPSBtZW1vaXplKG9yZ2FuaXplUmF3TG9jYWxlcyk7XG4gICAgICAgIHRoaXMuYnVpbGRMb2NhbGUgPSBtZW1vaXplKGJ1aWxkTG9jYWxlKTtcbiAgICAgICAgdGhpcy5idWlsZFBsdWdpbkhvb2tzID0gYnVpbGRCdWlsZFBsdWdpbkhvb2tzKCk7XG4gICAgICAgIHRoaXMuYnVpbGREYXRlRW52ID0gbWVtb2l6ZShidWlsZERhdGVFbnYkMSk7XG4gICAgICAgIHRoaXMuYnVpbGRUaGVtZSA9IG1lbW9pemUoYnVpbGRUaGVtZSk7XG4gICAgICAgIHRoaXMucGFyc2VUb29sYmFycyA9IG1lbW9pemUocGFyc2VUb29sYmFycyk7XG4gICAgICAgIHRoaXMuYnVpbGRWaWV3U3BlY3MgPSBtZW1vaXplKGJ1aWxkVmlld1NwZWNzKTtcbiAgICAgICAgdGhpcy5idWlsZERhdGVQcm9maWxlR2VuZXJhdG9yID0gbWVtb2l6ZU9iakFyZyhidWlsZERhdGVQcm9maWxlR2VuZXJhdG9yKTtcbiAgICAgICAgdGhpcy5idWlsZFZpZXdBcGkgPSBtZW1vaXplKGJ1aWxkVmlld0FwaSk7XG4gICAgICAgIHRoaXMuYnVpbGRWaWV3VWlQcm9wcyA9IG1lbW9pemVPYmpBcmcoYnVpbGRWaWV3VWlQcm9wcyk7XG4gICAgICAgIHRoaXMuYnVpbGRFdmVudFVpQnlTb3VyY2UgPSBtZW1vaXplKGJ1aWxkRXZlbnRVaUJ5U291cmNlLCBpc1Byb3BzRXF1YWwpO1xuICAgICAgICB0aGlzLmJ1aWxkRXZlbnRVaUJhc2VzID0gbWVtb2l6ZShidWlsZEV2ZW50VWlCYXNlcyk7XG4gICAgICAgIHRoaXMucGFyc2VDb250ZXh0QnVzaW5lc3NIb3VycyA9IG1lbW9pemVPYmpBcmcocGFyc2VDb250ZXh0QnVzaW5lc3NIb3Vycyk7XG4gICAgICAgIHRoaXMuYnVpbGRUaXRsZSA9IG1lbW9pemUoYnVpbGRUaXRsZSk7XG4gICAgICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuYWN0aW9uUnVubmVyID0gbmV3IFRhc2tSdW5uZXIodGhpcy5faGFuZGxlQWN0aW9uLmJpbmQodGhpcyksIHRoaXMudXBkYXRlRGF0YS5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXQgPSB7fTtcbiAgICAgICAgdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lZCA9IHt9O1xuICAgICAgICB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc0lucHV0ID0ge307XG4gICAgICAgIHRoaXMuY3VycmVudFZpZXdPcHRpb25zUmVmaW5lZCA9IHt9O1xuICAgICAgICB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVycyA9IHt9O1xuICAgICAgICB0aGlzLm9wdGlvbnNGb3JSZWZpbmluZyA9IFtdO1xuICAgICAgICB0aGlzLm9wdGlvbnNGb3JIYW5kbGluZyA9IFtdO1xuICAgICAgICB0aGlzLmdldEN1cnJlbnREYXRhID0gKCkgPT4gdGhpcy5kYXRhO1xuICAgICAgICB0aGlzLmRpc3BhdGNoID0gKGFjdGlvbikgPT4ge1xuICAgICAgICAgICAgdGhpcy5hY3Rpb25SdW5uZXIucmVxdWVzdChhY3Rpb24pOyAvLyBwcm90ZWN0cyBhZ2FpbnN0IHJlY3Vyc2l2ZSBjYWxscyB0byBfaGFuZGxlQWN0aW9uXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgICAgdGhpcy5hY3Rpb25SdW5uZXIucGF1c2UoKTtcbiAgICAgICAgbGV0IGR5bmFtaWNPcHRpb25PdmVycmlkZXMgPSB7fTtcbiAgICAgICAgbGV0IG9wdGlvbnNEYXRhID0gdGhpcy5jb21wdXRlT3B0aW9uc0RhdGEocHJvcHMub3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBwcm9wcy5jYWxlbmRhckFwaSk7XG4gICAgICAgIGxldCBjdXJyZW50Vmlld1R5cGUgPSBvcHRpb25zRGF0YS5jYWxlbmRhck9wdGlvbnMuaW5pdGlhbFZpZXcgfHwgb3B0aW9uc0RhdGEucGx1Z2luSG9va3MuaW5pdGlhbFZpZXc7XG4gICAgICAgIGxldCBjdXJyZW50Vmlld0RhdGEgPSB0aGlzLmNvbXB1dGVDdXJyZW50Vmlld0RhdGEoY3VycmVudFZpZXdUeXBlLCBvcHRpb25zRGF0YSwgcHJvcHMub3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKTtcbiAgICAgICAgLy8gd2lyZSB0aGluZ3MgdXBcbiAgICAgICAgLy8gVE9ETzogbm90IERSWVxuICAgICAgICBwcm9wcy5jYWxlbmRhckFwaS5jdXJyZW50RGF0YU1hbmFnZXIgPSB0aGlzO1xuICAgICAgICB0aGlzLmVtaXR0ZXIuc2V0VGhpc0NvbnRleHQocHJvcHMuY2FsZW5kYXJBcGkpO1xuICAgICAgICB0aGlzLmVtaXR0ZXIuc2V0T3B0aW9ucyhjdXJyZW50Vmlld0RhdGEub3B0aW9ucyk7XG4gICAgICAgIGxldCBjdXJyZW50RGF0ZSA9IGdldEluaXRpYWxEYXRlKG9wdGlvbnNEYXRhLmNhbGVuZGFyT3B0aW9ucywgb3B0aW9uc0RhdGEuZGF0ZUVudik7XG4gICAgICAgIGxldCBkYXRlUHJvZmlsZSA9IGN1cnJlbnRWaWV3RGF0YS5kYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZChjdXJyZW50RGF0ZSk7XG4gICAgICAgIGlmICghcmFuZ2VDb250YWluc01hcmtlcihkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgY3VycmVudERhdGUpKSB7XG4gICAgICAgICAgICBjdXJyZW50RGF0ZSA9IGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5zdGFydDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2FsZW5kYXJDb250ZXh0ID0ge1xuICAgICAgICAgICAgZGF0ZUVudjogb3B0aW9uc0RhdGEuZGF0ZUVudixcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNEYXRhLmNhbGVuZGFyT3B0aW9ucyxcbiAgICAgICAgICAgIHBsdWdpbkhvb2tzOiBvcHRpb25zRGF0YS5wbHVnaW5Ib29rcyxcbiAgICAgICAgICAgIGNhbGVuZGFyQXBpOiBwcm9wcy5jYWxlbmRhckFwaSxcbiAgICAgICAgICAgIGRpc3BhdGNoOiB0aGlzLmRpc3BhdGNoLFxuICAgICAgICAgICAgZW1pdHRlcjogdGhpcy5lbWl0dGVyLFxuICAgICAgICAgICAgZ2V0Q3VycmVudERhdGE6IHRoaXMuZ2V0Q3VycmVudERhdGEsXG4gICAgICAgIH07XG4gICAgICAgIC8vIG5lZWRzIHRvIGJlIGFmdGVyIHNldFRoaXNDb250ZXh0XG4gICAgICAgIGZvciAobGV0IGNhbGxiYWNrIG9mIG9wdGlvbnNEYXRhLnBsdWdpbkhvb2tzLmNvbnRleHRJbml0KSB7XG4gICAgICAgICAgICBjYWxsYmFjayhjYWxlbmRhckNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5PVCBEUllcbiAgICAgICAgbGV0IGV2ZW50U291cmNlcyA9IGluaXRFdmVudFNvdXJjZXMob3B0aW9uc0RhdGEuY2FsZW5kYXJPcHRpb25zLCBkYXRlUHJvZmlsZSwgY2FsZW5kYXJDb250ZXh0KTtcbiAgICAgICAgbGV0IGluaXRpYWxTdGF0ZSA9IHtcbiAgICAgICAgICAgIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsXG4gICAgICAgICAgICBjdXJyZW50Vmlld1R5cGUsXG4gICAgICAgICAgICBjdXJyZW50RGF0ZSxcbiAgICAgICAgICAgIGRhdGVQcm9maWxlLFxuICAgICAgICAgICAgYnVzaW5lc3NIb3VyczogdGhpcy5wYXJzZUNvbnRleHRCdXNpbmVzc0hvdXJzKGNhbGVuZGFyQ29udGV4dCksXG4gICAgICAgICAgICBldmVudFNvdXJjZXMsXG4gICAgICAgICAgICBldmVudFVpQmFzZXM6IHt9LFxuICAgICAgICAgICAgZXZlbnRTdG9yZTogY3JlYXRlRW1wdHlFdmVudFN0b3JlKCksXG4gICAgICAgICAgICByZW5kZXJhYmxlRXZlbnRTdG9yZTogY3JlYXRlRW1wdHlFdmVudFN0b3JlKCksXG4gICAgICAgICAgICBkYXRlU2VsZWN0aW9uOiBudWxsLFxuICAgICAgICAgICAgZXZlbnRTZWxlY3Rpb246ICcnLFxuICAgICAgICAgICAgZXZlbnREcmFnOiBudWxsLFxuICAgICAgICAgICAgZXZlbnRSZXNpemU6IG51bGwsXG4gICAgICAgICAgICBzZWxlY3Rpb25Db25maWc6IHRoaXMuYnVpbGRWaWV3VWlQcm9wcyhjYWxlbmRhckNvbnRleHQpLnNlbGVjdGlvbkNvbmZpZyxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGNvbnRleHRBbmRTdGF0ZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY2FsZW5kYXJDb250ZXh0KSwgaW5pdGlhbFN0YXRlKTtcbiAgICAgICAgZm9yIChsZXQgcmVkdWNlciBvZiBvcHRpb25zRGF0YS5wbHVnaW5Ib29rcy5yZWR1Y2Vycykge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihpbml0aWFsU3RhdGUsIHJlZHVjZXIobnVsbCwgbnVsbCwgY29udGV4dEFuZFN0YXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXB1dGVJc0xvYWRpbmcoaW5pdGlhbFN0YXRlLCBjYWxlbmRhckNvbnRleHQpKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcignbG9hZGluZycsIHRydWUpOyAvLyBOT1QgRFJZXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgICAgICAgdGhpcy51cGRhdGVEYXRhKCk7XG4gICAgICAgIHRoaXMuYWN0aW9uUnVubmVyLnJlc3VtZSgpO1xuICAgIH1cbiAgICByZXNldE9wdGlvbnMob3B0aW9uT3ZlcnJpZGVzLCBjaGFuZ2VkT3B0aW9uTmFtZXMpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGlmIChjaGFuZ2VkT3B0aW9uTmFtZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcHJvcHMub3B0aW9uT3ZlcnJpZGVzID0gb3B0aW9uT3ZlcnJpZGVzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJvcHMub3B0aW9uT3ZlcnJpZGVzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAocHJvcHMub3B0aW9uT3ZlcnJpZGVzIHx8IHt9KSksIG9wdGlvbk92ZXJyaWRlcyk7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNGb3JSZWZpbmluZy5wdXNoKC4uLmNoYW5nZWRPcHRpb25OYW1lcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZWRPcHRpb25OYW1lcyA9PT0gdW5kZWZpbmVkIHx8IGNoYW5nZWRPcHRpb25OYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uUnVubmVyLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdOT1RISU5HJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9oYW5kbGVBY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBzdGF0ZSwgZW1pdHRlciB9ID0gdGhpcztcbiAgICAgICAgbGV0IGR5bmFtaWNPcHRpb25PdmVycmlkZXMgPSByZWR1Y2VEeW5hbWljT3B0aW9uT3ZlcnJpZGVzKHN0YXRlLmR5bmFtaWNPcHRpb25PdmVycmlkZXMsIGFjdGlvbik7XG4gICAgICAgIGxldCBvcHRpb25zRGF0YSA9IHRoaXMuY29tcHV0ZU9wdGlvbnNEYXRhKHByb3BzLm9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcywgcHJvcHMuY2FsZW5kYXJBcGkpO1xuICAgICAgICBsZXQgY3VycmVudFZpZXdUeXBlID0gcmVkdWNlVmlld1R5cGUoc3RhdGUuY3VycmVudFZpZXdUeXBlLCBhY3Rpb24pO1xuICAgICAgICBsZXQgY3VycmVudFZpZXdEYXRhID0gdGhpcy5jb21wdXRlQ3VycmVudFZpZXdEYXRhKGN1cnJlbnRWaWV3VHlwZSwgb3B0aW9uc0RhdGEsIHByb3BzLm9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcyk7XG4gICAgICAgIC8vIHdpcmUgdGhpbmdzIHVwXG4gICAgICAgIC8vIFRPRE86IG5vdCBEUllcbiAgICAgICAgcHJvcHMuY2FsZW5kYXJBcGkuY3VycmVudERhdGFNYW5hZ2VyID0gdGhpcztcbiAgICAgICAgZW1pdHRlci5zZXRUaGlzQ29udGV4dChwcm9wcy5jYWxlbmRhckFwaSk7XG4gICAgICAgIGVtaXR0ZXIuc2V0T3B0aW9ucyhjdXJyZW50Vmlld0RhdGEub3B0aW9ucyk7XG4gICAgICAgIGxldCBjYWxlbmRhckNvbnRleHQgPSB7XG4gICAgICAgICAgICBkYXRlRW52OiBvcHRpb25zRGF0YS5kYXRlRW52LFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc0RhdGEuY2FsZW5kYXJPcHRpb25zLFxuICAgICAgICAgICAgcGx1Z2luSG9va3M6IG9wdGlvbnNEYXRhLnBsdWdpbkhvb2tzLFxuICAgICAgICAgICAgY2FsZW5kYXJBcGk6IHByb3BzLmNhbGVuZGFyQXBpLFxuICAgICAgICAgICAgZGlzcGF0Y2g6IHRoaXMuZGlzcGF0Y2gsXG4gICAgICAgICAgICBlbWl0dGVyLFxuICAgICAgICAgICAgZ2V0Q3VycmVudERhdGE6IHRoaXMuZ2V0Q3VycmVudERhdGEsXG4gICAgICAgIH07XG4gICAgICAgIGxldCB7IGN1cnJlbnREYXRlLCBkYXRlUHJvZmlsZSB9ID0gc3RhdGU7XG4gICAgICAgIGlmICh0aGlzLmRhdGEgJiYgdGhpcy5kYXRhLmRhdGVQcm9maWxlR2VuZXJhdG9yICE9PSBjdXJyZW50Vmlld0RhdGEuZGF0ZVByb2ZpbGVHZW5lcmF0b3IpIHsgLy8gaGFja1xuICAgICAgICAgICAgZGF0ZVByb2ZpbGUgPSBjdXJyZW50Vmlld0RhdGEuZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGQoY3VycmVudERhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnREYXRlID0gcmVkdWNlQ3VycmVudERhdGUoY3VycmVudERhdGUsIGFjdGlvbik7XG4gICAgICAgIGRhdGVQcm9maWxlID0gcmVkdWNlRGF0ZVByb2ZpbGUoZGF0ZVByb2ZpbGUsIGFjdGlvbiwgY3VycmVudERhdGUsIGN1cnJlbnRWaWV3RGF0YS5kYXRlUHJvZmlsZUdlbmVyYXRvcik7XG4gICAgICAgIGlmIChhY3Rpb24udHlwZSA9PT0gJ1BSRVYnIHx8IC8vIFRPRE86IG1vdmUgdGhpcyBsb2dpYyBpbnRvIERhdGVQcm9maWxlR2VuZXJhdG9yXG4gICAgICAgICAgICBhY3Rpb24udHlwZSA9PT0gJ05FWFQnIHx8IC8vIFwiXG4gICAgICAgICAgICAhcmFuZ2VDb250YWluc01hcmtlcihkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2UsIGN1cnJlbnREYXRlKSkge1xuICAgICAgICAgICAgY3VycmVudERhdGUgPSBkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2Uuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGV2ZW50U291cmNlcyA9IHJlZHVjZUV2ZW50U291cmNlcyhzdGF0ZS5ldmVudFNvdXJjZXMsIGFjdGlvbiwgZGF0ZVByb2ZpbGUsIGNhbGVuZGFyQ29udGV4dCk7XG4gICAgICAgIGxldCBldmVudFN0b3JlID0gcmVkdWNlRXZlbnRTdG9yZShzdGF0ZS5ldmVudFN0b3JlLCBhY3Rpb24sIGV2ZW50U291cmNlcywgZGF0ZVByb2ZpbGUsIGNhbGVuZGFyQ29udGV4dCk7XG4gICAgICAgIGxldCBpc0V2ZW50c0xvYWRpbmcgPSBjb21wdXRlRXZlbnRTb3VyY2VzTG9hZGluZyhldmVudFNvdXJjZXMpOyAvLyBCQUQuIGFsc28gY2FsbGVkIGluIHRoaXMgZnVuYyBpbiBjb21wdXRlSXNMb2FkaW5nXG4gICAgICAgIGxldCByZW5kZXJhYmxlRXZlbnRTdG9yZSA9IChpc0V2ZW50c0xvYWRpbmcgJiYgIWN1cnJlbnRWaWV3RGF0YS5vcHRpb25zLnByb2dyZXNzaXZlRXZlbnRSZW5kZXJpbmcpID9cbiAgICAgICAgICAgIChzdGF0ZS5yZW5kZXJhYmxlRXZlbnRTdG9yZSB8fCBldmVudFN0b3JlKSA6IC8vIHRyeSBmcm9tIHByZXZpb3VzIHN0YXRlXG4gICAgICAgICAgICBldmVudFN0b3JlO1xuICAgICAgICBsZXQgeyBldmVudFVpU2luZ2xlQmFzZSwgc2VsZWN0aW9uQ29uZmlnIH0gPSB0aGlzLmJ1aWxkVmlld1VpUHJvcHMoY2FsZW5kYXJDb250ZXh0KTsgLy8gd2lsbCBtZW1vaXplIG9ialxuICAgICAgICBsZXQgZXZlbnRVaUJ5U291cmNlID0gdGhpcy5idWlsZEV2ZW50VWlCeVNvdXJjZShldmVudFNvdXJjZXMpO1xuICAgICAgICBsZXQgZXZlbnRVaUJhc2VzID0gdGhpcy5idWlsZEV2ZW50VWlCYXNlcyhyZW5kZXJhYmxlRXZlbnRTdG9yZS5kZWZzLCBldmVudFVpU2luZ2xlQmFzZSwgZXZlbnRVaUJ5U291cmNlKTtcbiAgICAgICAgbGV0IG5ld1N0YXRlID0ge1xuICAgICAgICAgICAgZHluYW1pY09wdGlvbk92ZXJyaWRlcyxcbiAgICAgICAgICAgIGN1cnJlbnRWaWV3VHlwZSxcbiAgICAgICAgICAgIGN1cnJlbnREYXRlLFxuICAgICAgICAgICAgZGF0ZVByb2ZpbGUsXG4gICAgICAgICAgICBldmVudFNvdXJjZXMsXG4gICAgICAgICAgICBldmVudFN0b3JlLFxuICAgICAgICAgICAgcmVuZGVyYWJsZUV2ZW50U3RvcmUsXG4gICAgICAgICAgICBzZWxlY3Rpb25Db25maWcsXG4gICAgICAgICAgICBldmVudFVpQmFzZXMsXG4gICAgICAgICAgICBidXNpbmVzc0hvdXJzOiB0aGlzLnBhcnNlQ29udGV4dEJ1c2luZXNzSG91cnMoY2FsZW5kYXJDb250ZXh0KSxcbiAgICAgICAgICAgIGRhdGVTZWxlY3Rpb246IHJlZHVjZURhdGVTZWxlY3Rpb24oc3RhdGUuZGF0ZVNlbGVjdGlvbiwgYWN0aW9uKSxcbiAgICAgICAgICAgIGV2ZW50U2VsZWN0aW9uOiByZWR1Y2VTZWxlY3RlZEV2ZW50KHN0YXRlLmV2ZW50U2VsZWN0aW9uLCBhY3Rpb24pLFxuICAgICAgICAgICAgZXZlbnREcmFnOiByZWR1Y2VFdmVudERyYWcoc3RhdGUuZXZlbnREcmFnLCBhY3Rpb24pLFxuICAgICAgICAgICAgZXZlbnRSZXNpemU6IHJlZHVjZUV2ZW50UmVzaXplKHN0YXRlLmV2ZW50UmVzaXplLCBhY3Rpb24pLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgY29udGV4dEFuZFN0YXRlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjYWxlbmRhckNvbnRleHQpLCBuZXdTdGF0ZSk7XG4gICAgICAgIGZvciAobGV0IHJlZHVjZXIgb2Ygb3B0aW9uc0RhdGEucGx1Z2luSG9va3MucmVkdWNlcnMpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obmV3U3RhdGUsIHJlZHVjZXIoc3RhdGUsIGFjdGlvbiwgY29udGV4dEFuZFN0YXRlKSk7IC8vIGdpdmUgdGhlIE9MRCBzdGF0ZSwgZm9yIG9sZCB2YWx1ZVxuICAgICAgICB9XG4gICAgICAgIGxldCB3YXNMb2FkaW5nID0gY29tcHV0ZUlzTG9hZGluZyhzdGF0ZSwgY2FsZW5kYXJDb250ZXh0KTtcbiAgICAgICAgbGV0IGlzTG9hZGluZyA9IGNvbXB1dGVJc0xvYWRpbmcobmV3U3RhdGUsIGNhbGVuZGFyQ29udGV4dCk7XG4gICAgICAgIC8vIFRPRE86IHVzZSBwcm9wU2V0SGFuZGxlcnMgaW4gcGx1Z2luIHN5c3RlbVxuICAgICAgICBpZiAoIXdhc0xvYWRpbmcgJiYgaXNMb2FkaW5nKSB7XG4gICAgICAgICAgICBlbWl0dGVyLnRyaWdnZXIoJ2xvYWRpbmcnLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh3YXNMb2FkaW5nICYmICFpc0xvYWRpbmcpIHtcbiAgICAgICAgICAgIGVtaXR0ZXIudHJpZ2dlcignbG9hZGluZycsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIGlmIChwcm9wcy5vbkFjdGlvbikge1xuICAgICAgICAgICAgcHJvcHMub25BY3Rpb24oYWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVEYXRhKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgc3RhdGUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBvbGREYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICBsZXQgb3B0aW9uc0RhdGEgPSB0aGlzLmNvbXB1dGVPcHRpb25zRGF0YShwcm9wcy5vcHRpb25PdmVycmlkZXMsIHN0YXRlLmR5bmFtaWNPcHRpb25PdmVycmlkZXMsIHByb3BzLmNhbGVuZGFyQXBpKTtcbiAgICAgICAgbGV0IGN1cnJlbnRWaWV3RGF0YSA9IHRoaXMuY29tcHV0ZUN1cnJlbnRWaWV3RGF0YShzdGF0ZS5jdXJyZW50Vmlld1R5cGUsIG9wdGlvbnNEYXRhLCBwcm9wcy5vcHRpb25PdmVycmlkZXMsIHN0YXRlLmR5bmFtaWNPcHRpb25PdmVycmlkZXMpO1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuZGF0YSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgdmlld1RpdGxlOiB0aGlzLmJ1aWxkVGl0bGUoc3RhdGUuZGF0ZVByb2ZpbGUsIGN1cnJlbnRWaWV3RGF0YS5vcHRpb25zLCBvcHRpb25zRGF0YS5kYXRlRW52KSwgY2FsZW5kYXJBcGk6IHByb3BzLmNhbGVuZGFyQXBpLCBkaXNwYXRjaDogdGhpcy5kaXNwYXRjaCwgZW1pdHRlcjogdGhpcy5lbWl0dGVyLCBnZXRDdXJyZW50RGF0YTogdGhpcy5nZXRDdXJyZW50RGF0YSB9LCBvcHRpb25zRGF0YSksIGN1cnJlbnRWaWV3RGF0YSksIHN0YXRlKTtcbiAgICAgICAgbGV0IGNoYW5nZUhhbmRsZXJzID0gb3B0aW9uc0RhdGEucGx1Z2luSG9va3Mub3B0aW9uQ2hhbmdlSGFuZGxlcnM7XG4gICAgICAgIGxldCBvbGRDYWxlbmRhck9wdGlvbnMgPSBvbGREYXRhICYmIG9sZERhdGEuY2FsZW5kYXJPcHRpb25zO1xuICAgICAgICBsZXQgbmV3Q2FsZW5kYXJPcHRpb25zID0gb3B0aW9uc0RhdGEuY2FsZW5kYXJPcHRpb25zO1xuICAgICAgICBpZiAob2xkQ2FsZW5kYXJPcHRpb25zICYmIG9sZENhbGVuZGFyT3B0aW9ucyAhPT0gbmV3Q2FsZW5kYXJPcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAob2xkQ2FsZW5kYXJPcHRpb25zLnRpbWVab25lICE9PSBuZXdDYWxlbmRhck9wdGlvbnMudGltZVpvbmUpIHtcbiAgICAgICAgICAgICAgICAvLyBoYWNrXG4gICAgICAgICAgICAgICAgc3RhdGUuZXZlbnRTb3VyY2VzID0gZGF0YS5ldmVudFNvdXJjZXMgPSByZWR1Y2VFdmVudFNvdXJjZXNOZXdUaW1lWm9uZShkYXRhLmV2ZW50U291cmNlcywgc3RhdGUuZGF0ZVByb2ZpbGUsIGRhdGEpO1xuICAgICAgICAgICAgICAgIHN0YXRlLmV2ZW50U3RvcmUgPSBkYXRhLmV2ZW50U3RvcmUgPSByZXpvbmVFdmVudFN0b3JlRGF0ZXMoZGF0YS5ldmVudFN0b3JlLCBvbGREYXRhLmRhdGVFbnYsIGRhdGEuZGF0ZUVudik7XG4gICAgICAgICAgICAgICAgc3RhdGUucmVuZGVyYWJsZUV2ZW50U3RvcmUgPSBkYXRhLnJlbmRlcmFibGVFdmVudFN0b3JlID0gcmV6b25lRXZlbnRTdG9yZURhdGVzKGRhdGEucmVuZGVyYWJsZUV2ZW50U3RvcmUsIG9sZERhdGEuZGF0ZUVudiwgZGF0YS5kYXRlRW52KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IG9wdGlvbk5hbWUgaW4gY2hhbmdlSGFuZGxlcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zRm9ySGFuZGxpbmcuaW5kZXhPZihvcHRpb25OYW1lKSAhPT0gLTEgfHxcbiAgICAgICAgICAgICAgICAgICAgb2xkQ2FsZW5kYXJPcHRpb25zW29wdGlvbk5hbWVdICE9PSBuZXdDYWxlbmRhck9wdGlvbnNbb3B0aW9uTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlSGFuZGxlcnNbb3B0aW9uTmFtZV0obmV3Q2FsZW5kYXJPcHRpb25zW29wdGlvbk5hbWVdLCBkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zRm9ySGFuZGxpbmcgPSBbXTtcbiAgICAgICAgaWYgKHByb3BzLm9uRGF0YSkge1xuICAgICAgICAgICAgcHJvcHMub25EYXRhKGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXB1dGVPcHRpb25zRGF0YShvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsIGNhbGVuZGFyQXBpKSB7XG4gICAgICAgIC8vIFRPRE86IGJsYWNrbGlzdCBvcHRpb25zIHRoYXQgYXJlIGhhbmRsZWQgYnkgb3B0aW9uQ2hhbmdlSGFuZGxlcnNcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnNGb3JSZWZpbmluZy5sZW5ndGggJiZcbiAgICAgICAgICAgIG9wdGlvbk92ZXJyaWRlcyA9PT0gdGhpcy5zdGFibGVPcHRpb25PdmVycmlkZXMgJiZcbiAgICAgICAgICAgIGR5bmFtaWNPcHRpb25PdmVycmlkZXMgPT09IHRoaXMuc3RhYmxlRHluYW1pY09wdGlvbk92ZXJyaWRlcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhYmxlQ2FsZW5kYXJPcHRpb25zRGF0YTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyByZWZpbmVkT3B0aW9ucywgcGx1Z2luSG9va3MsIGxvY2FsZURlZmF1bHRzLCBhdmFpbGFibGVMb2NhbGVEYXRhLCBleHRyYSwgfSA9IHRoaXMucHJvY2Vzc1Jhd0NhbGVuZGFyT3B0aW9ucyhvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMpO1xuICAgICAgICB3YXJuVW5rbm93bk9wdGlvbnMoZXh0cmEpO1xuICAgICAgICBsZXQgZGF0ZUVudiA9IHRoaXMuYnVpbGREYXRlRW52KHJlZmluZWRPcHRpb25zLnRpbWVab25lLCByZWZpbmVkT3B0aW9ucy5sb2NhbGUsIHJlZmluZWRPcHRpb25zLndlZWtOdW1iZXJDYWxjdWxhdGlvbiwgcmVmaW5lZE9wdGlvbnMuZmlyc3REYXksIHJlZmluZWRPcHRpb25zLndlZWtUZXh0LCBwbHVnaW5Ib29rcywgYXZhaWxhYmxlTG9jYWxlRGF0YSwgcmVmaW5lZE9wdGlvbnMuZGVmYXVsdFJhbmdlU2VwYXJhdG9yKTtcbiAgICAgICAgbGV0IHZpZXdTcGVjcyA9IHRoaXMuYnVpbGRWaWV3U3BlY3MocGx1Z2luSG9va3Mudmlld3MsIHRoaXMuc3RhYmxlT3B0aW9uT3ZlcnJpZGVzLCB0aGlzLnN0YWJsZUR5bmFtaWNPcHRpb25PdmVycmlkZXMsIGxvY2FsZURlZmF1bHRzKTtcbiAgICAgICAgbGV0IHRoZW1lID0gdGhpcy5idWlsZFRoZW1lKHJlZmluZWRPcHRpb25zLCBwbHVnaW5Ib29rcyk7XG4gICAgICAgIGxldCB0b29sYmFyQ29uZmlnID0gdGhpcy5wYXJzZVRvb2xiYXJzKHJlZmluZWRPcHRpb25zLCB0aGlzLnN0YWJsZU9wdGlvbk92ZXJyaWRlcywgdGhlbWUsIHZpZXdTcGVjcywgY2FsZW5kYXJBcGkpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFibGVDYWxlbmRhck9wdGlvbnNEYXRhID0ge1xuICAgICAgICAgICAgY2FsZW5kYXJPcHRpb25zOiByZWZpbmVkT3B0aW9ucyxcbiAgICAgICAgICAgIHBsdWdpbkhvb2tzLFxuICAgICAgICAgICAgZGF0ZUVudixcbiAgICAgICAgICAgIHZpZXdTcGVjcyxcbiAgICAgICAgICAgIHRoZW1lLFxuICAgICAgICAgICAgdG9vbGJhckNvbmZpZyxcbiAgICAgICAgICAgIGxvY2FsZURlZmF1bHRzLFxuICAgICAgICAgICAgYXZhaWxhYmxlUmF3TG9jYWxlczogYXZhaWxhYmxlTG9jYWxlRGF0YS5tYXAsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIGFsd2F5cyBjYWxsZWQgZnJvbSBiZWhpbmQgYSBtZW1vaXplclxuICAgIHByb2Nlc3NSYXdDYWxlbmRhck9wdGlvbnMob3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKSB7XG4gICAgICAgIGxldCB7IGxvY2FsZXMsIGxvY2FsZSB9ID0gbWVyZ2VSYXdPcHRpb25zKFtcbiAgICAgICAgICAgIEJBU0VfT1BUSU9OX0RFRkFVTFRTLFxuICAgICAgICAgICAgb3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICAgICAgZHluYW1pY09wdGlvbk92ZXJyaWRlcyxcbiAgICAgICAgXSk7XG4gICAgICAgIGxldCBhdmFpbGFibGVMb2NhbGVEYXRhID0gdGhpcy5vcmdhbml6ZVJhd0xvY2FsZXMobG9jYWxlcyk7XG4gICAgICAgIGxldCBhdmFpbGFibGVSYXdMb2NhbGVzID0gYXZhaWxhYmxlTG9jYWxlRGF0YS5tYXA7XG4gICAgICAgIGxldCBsb2NhbGVEZWZhdWx0cyA9IHRoaXMuYnVpbGRMb2NhbGUobG9jYWxlIHx8IGF2YWlsYWJsZUxvY2FsZURhdGEuZGVmYXVsdENvZGUsIGF2YWlsYWJsZVJhd0xvY2FsZXMpLm9wdGlvbnM7XG4gICAgICAgIGxldCBwbHVnaW5Ib29rcyA9IHRoaXMuYnVpbGRQbHVnaW5Ib29rcyhvcHRpb25PdmVycmlkZXMucGx1Z2lucyB8fCBbXSwgZ2xvYmFsUGx1Z2lucyk7XG4gICAgICAgIGxldCByZWZpbmVycyA9IHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBCQVNFX09QVElPTl9SRUZJTkVSUyksIENBTEVOREFSX0xJU1RFTkVSX1JFRklORVJTKSwgQ0FMRU5EQVJfT1BUSU9OX1JFRklORVJTKSwgcGx1Z2luSG9va3MubGlzdGVuZXJSZWZpbmVycyksIHBsdWdpbkhvb2tzLm9wdGlvblJlZmluZXJzKTtcbiAgICAgICAgbGV0IGV4dHJhID0ge307XG4gICAgICAgIGxldCByYXcgPSBtZXJnZVJhd09wdGlvbnMoW1xuICAgICAgICAgICAgQkFTRV9PUFRJT05fREVGQVVMVFMsXG4gICAgICAgICAgICBsb2NhbGVEZWZhdWx0cyxcbiAgICAgICAgICAgIG9wdGlvbk92ZXJyaWRlcyxcbiAgICAgICAgICAgIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsXG4gICAgICAgIF0pO1xuICAgICAgICBsZXQgcmVmaW5lZCA9IHt9O1xuICAgICAgICBsZXQgY3VycmVudFJhdyA9IHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc0lucHV0O1xuICAgICAgICBsZXQgY3VycmVudFJlZmluZWQgPSB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVkO1xuICAgICAgICBsZXQgYW55Q2hhbmdlcyA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBvcHRpb25OYW1lIGluIHJhdykge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uc0ZvclJlZmluaW5nLmluZGV4T2Yob3B0aW9uTmFtZSkgPT09IC0xICYmIChyYXdbb3B0aW9uTmFtZV0gPT09IGN1cnJlbnRSYXdbb3B0aW9uTmFtZV0gfHwgKENPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTW29wdGlvbk5hbWVdICYmXG4gICAgICAgICAgICAgICAgKG9wdGlvbk5hbWUgaW4gY3VycmVudFJhdykgJiZcbiAgICAgICAgICAgICAgICBDT01QTEVYX09QVElPTl9DT01QQVJBVE9SU1tvcHRpb25OYW1lXShjdXJyZW50UmF3W29wdGlvbk5hbWVdLCByYXdbb3B0aW9uTmFtZV0pKSkpIHtcbiAgICAgICAgICAgICAgICByZWZpbmVkW29wdGlvbk5hbWVdID0gY3VycmVudFJlZmluZWRbb3B0aW9uTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZWZpbmVyc1tvcHRpb25OYW1lXSkge1xuICAgICAgICAgICAgICAgIHJlZmluZWRbb3B0aW9uTmFtZV0gPSByZWZpbmVyc1tvcHRpb25OYW1lXShyYXdbb3B0aW9uTmFtZV0pO1xuICAgICAgICAgICAgICAgIGFueUNoYW5nZXMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZXh0cmFbb3B0aW9uTmFtZV0gPSBjdXJyZW50UmF3W29wdGlvbk5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhbnlDaGFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dCA9IHJhdztcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZWQgPSByZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5zdGFibGVPcHRpb25PdmVycmlkZXMgPSBvcHRpb25PdmVycmlkZXM7XG4gICAgICAgICAgICB0aGlzLnN0YWJsZUR5bmFtaWNPcHRpb25PdmVycmlkZXMgPSBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9uc0ZvckhhbmRsaW5nLnB1c2goLi4udGhpcy5vcHRpb25zRm9yUmVmaW5pbmcpO1xuICAgICAgICB0aGlzLm9wdGlvbnNGb3JSZWZpbmluZyA9IFtdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmF3T3B0aW9uczogdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXQsXG4gICAgICAgICAgICByZWZpbmVkT3B0aW9uczogdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lZCxcbiAgICAgICAgICAgIHBsdWdpbkhvb2tzLFxuICAgICAgICAgICAgYXZhaWxhYmxlTG9jYWxlRGF0YSxcbiAgICAgICAgICAgIGxvY2FsZURlZmF1bHRzLFxuICAgICAgICAgICAgZXh0cmEsXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9jb21wdXRlQ3VycmVudFZpZXdEYXRhKHZpZXdUeXBlLCBvcHRpb25zRGF0YSwgb3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKSB7XG4gICAgICAgIGxldCB2aWV3U3BlYyA9IG9wdGlvbnNEYXRhLnZpZXdTcGVjc1t2aWV3VHlwZV07XG4gICAgICAgIGlmICghdmlld1NwZWMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdmlld1R5cGUgXCIke3ZpZXdUeXBlfVwiIGlzIG5vdCBhdmFpbGFibGUuIFBsZWFzZSBtYWtlIHN1cmUgeW91J3ZlIGxvYWRlZCBhbGwgbmVjY2Vzc2FyeSBwbHVnaW5zYCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgcmVmaW5lZE9wdGlvbnMsIGV4dHJhIH0gPSB0aGlzLnByb2Nlc3NSYXdWaWV3T3B0aW9ucyh2aWV3U3BlYywgb3B0aW9uc0RhdGEucGx1Z2luSG9va3MsIG9wdGlvbnNEYXRhLmxvY2FsZURlZmF1bHRzLCBvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMpO1xuICAgICAgICB3YXJuVW5rbm93bk9wdGlvbnMoZXh0cmEpO1xuICAgICAgICBsZXQgZGF0ZVByb2ZpbGVHZW5lcmF0b3IgPSB0aGlzLmJ1aWxkRGF0ZVByb2ZpbGVHZW5lcmF0b3Ioe1xuICAgICAgICAgICAgZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzczogdmlld1NwZWMub3B0aW9uRGVmYXVsdHMuZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB2aWV3U3BlYy5kdXJhdGlvbixcbiAgICAgICAgICAgIGR1cmF0aW9uVW5pdDogdmlld1NwZWMuZHVyYXRpb25Vbml0LFxuICAgICAgICAgICAgdXNlc01pbk1heFRpbWU6IHZpZXdTcGVjLm9wdGlvbkRlZmF1bHRzLnVzZXNNaW5NYXhUaW1lLFxuICAgICAgICAgICAgZGF0ZUVudjogb3B0aW9uc0RhdGEuZGF0ZUVudixcbiAgICAgICAgICAgIGNhbGVuZGFyQXBpOiB0aGlzLnByb3BzLmNhbGVuZGFyQXBpLFxuICAgICAgICAgICAgc2xvdE1pblRpbWU6IHJlZmluZWRPcHRpb25zLnNsb3RNaW5UaW1lLFxuICAgICAgICAgICAgc2xvdE1heFRpbWU6IHJlZmluZWRPcHRpb25zLnNsb3RNYXhUaW1lLFxuICAgICAgICAgICAgc2hvd05vbkN1cnJlbnREYXRlczogcmVmaW5lZE9wdGlvbnMuc2hvd05vbkN1cnJlbnREYXRlcyxcbiAgICAgICAgICAgIGRheUNvdW50OiByZWZpbmVkT3B0aW9ucy5kYXlDb3VudCxcbiAgICAgICAgICAgIGRhdGVBbGlnbm1lbnQ6IHJlZmluZWRPcHRpb25zLmRhdGVBbGlnbm1lbnQsXG4gICAgICAgICAgICBkYXRlSW5jcmVtZW50OiByZWZpbmVkT3B0aW9ucy5kYXRlSW5jcmVtZW50LFxuICAgICAgICAgICAgaGlkZGVuRGF5czogcmVmaW5lZE9wdGlvbnMuaGlkZGVuRGF5cyxcbiAgICAgICAgICAgIHdlZWtlbmRzOiByZWZpbmVkT3B0aW9ucy53ZWVrZW5kcyxcbiAgICAgICAgICAgIG5vd0lucHV0OiByZWZpbmVkT3B0aW9ucy5ub3csXG4gICAgICAgICAgICB2YWxpZFJhbmdlSW5wdXQ6IHJlZmluZWRPcHRpb25zLnZhbGlkUmFuZ2UsXG4gICAgICAgICAgICB2aXNpYmxlUmFuZ2VJbnB1dDogcmVmaW5lZE9wdGlvbnMudmlzaWJsZVJhbmdlLFxuICAgICAgICAgICAgZml4ZWRXZWVrQ291bnQ6IHJlZmluZWRPcHRpb25zLmZpeGVkV2Vla0NvdW50LFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHZpZXdBcGkgPSB0aGlzLmJ1aWxkVmlld0FwaSh2aWV3VHlwZSwgdGhpcy5nZXRDdXJyZW50RGF0YSwgb3B0aW9uc0RhdGEuZGF0ZUVudik7XG4gICAgICAgIHJldHVybiB7IHZpZXdTcGVjLCBvcHRpb25zOiByZWZpbmVkT3B0aW9ucywgZGF0ZVByb2ZpbGVHZW5lcmF0b3IsIHZpZXdBcGkgfTtcbiAgICB9XG4gICAgcHJvY2Vzc1Jhd1ZpZXdPcHRpb25zKHZpZXdTcGVjLCBwbHVnaW5Ib29rcywgbG9jYWxlRGVmYXVsdHMsIG9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcykge1xuICAgICAgICBsZXQgcmF3ID0gbWVyZ2VSYXdPcHRpb25zKFtcbiAgICAgICAgICAgIEJBU0VfT1BUSU9OX0RFRkFVTFRTLFxuICAgICAgICAgICAgdmlld1NwZWMub3B0aW9uRGVmYXVsdHMsXG4gICAgICAgICAgICBsb2NhbGVEZWZhdWx0cyxcbiAgICAgICAgICAgIG9wdGlvbk92ZXJyaWRlcyxcbiAgICAgICAgICAgIHZpZXdTcGVjLm9wdGlvbk92ZXJyaWRlcyxcbiAgICAgICAgICAgIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsXG4gICAgICAgIF0pO1xuICAgICAgICBsZXQgcmVmaW5lcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgQkFTRV9PUFRJT05fUkVGSU5FUlMpLCBDQUxFTkRBUl9MSVNURU5FUl9SRUZJTkVSUyksIENBTEVOREFSX09QVElPTl9SRUZJTkVSUyksIFZJRVdfT1BUSU9OX1JFRklORVJTKSwgcGx1Z2luSG9va3MubGlzdGVuZXJSZWZpbmVycyksIHBsdWdpbkhvb2tzLm9wdGlvblJlZmluZXJzKTtcbiAgICAgICAgbGV0IHJlZmluZWQgPSB7fTtcbiAgICAgICAgbGV0IGN1cnJlbnRSYXcgPSB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc0lucHV0O1xuICAgICAgICBsZXQgY3VycmVudFJlZmluZWQgPSB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc1JlZmluZWQ7XG4gICAgICAgIGxldCBhbnlDaGFuZ2VzID0gZmFsc2U7XG4gICAgICAgIGxldCBleHRyYSA9IHt9O1xuICAgICAgICBmb3IgKGxldCBvcHRpb25OYW1lIGluIHJhdykge1xuICAgICAgICAgICAgaWYgKHJhd1tvcHRpb25OYW1lXSA9PT0gY3VycmVudFJhd1tvcHRpb25OYW1lXSB8fFxuICAgICAgICAgICAgICAgIChDT01QTEVYX09QVElPTl9DT01QQVJBVE9SU1tvcHRpb25OYW1lXSAmJlxuICAgICAgICAgICAgICAgICAgICBDT01QTEVYX09QVElPTl9DT01QQVJBVE9SU1tvcHRpb25OYW1lXShyYXdbb3B0aW9uTmFtZV0sIGN1cnJlbnRSYXdbb3B0aW9uTmFtZV0pKSkge1xuICAgICAgICAgICAgICAgIHJlZmluZWRbb3B0aW9uTmFtZV0gPSBjdXJyZW50UmVmaW5lZFtvcHRpb25OYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChyYXdbb3B0aW9uTmFtZV0gPT09IHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc0lucHV0W29wdGlvbk5hbWVdIHx8XG4gICAgICAgICAgICAgICAgICAgIChDT01QTEVYX09QVElPTl9DT01QQVJBVE9SU1tvcHRpb25OYW1lXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlNbb3B0aW9uTmFtZV0ocmF3W29wdGlvbk5hbWVdLCB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dFtvcHRpb25OYW1lXSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25OYW1lIGluIHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZWQpIHsgLy8gbWlnaHQgYmUgYW4gXCJleHRyYVwiIHByb3BcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZmluZWRbb3B0aW9uTmFtZV0gPSB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVkW29wdGlvbk5hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlZmluZXJzW29wdGlvbk5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZmluZWRbb3B0aW9uTmFtZV0gPSByZWZpbmVyc1tvcHRpb25OYW1lXShyYXdbb3B0aW9uTmFtZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFbb3B0aW9uTmFtZV0gPSByYXdbb3B0aW9uTmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFueUNoYW5nZXMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhbnlDaGFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc0lucHV0ID0gcmF3O1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Vmlld09wdGlvbnNSZWZpbmVkID0gcmVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmF3T3B0aW9uczogdGhpcy5jdXJyZW50Vmlld09wdGlvbnNJbnB1dCxcbiAgICAgICAgICAgIHJlZmluZWRPcHRpb25zOiB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc1JlZmluZWQsXG4gICAgICAgICAgICBleHRyYSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBidWlsZERhdGVFbnYkMSh0aW1lWm9uZSwgZXhwbGljaXRMb2NhbGUsIHdlZWtOdW1iZXJDYWxjdWxhdGlvbiwgZmlyc3REYXksIHdlZWtUZXh0LCBwbHVnaW5Ib29rcywgYXZhaWxhYmxlTG9jYWxlRGF0YSwgZGVmYXVsdFNlcGFyYXRvcikge1xuICAgIGxldCBsb2NhbGUgPSBidWlsZExvY2FsZShleHBsaWNpdExvY2FsZSB8fCBhdmFpbGFibGVMb2NhbGVEYXRhLmRlZmF1bHRDb2RlLCBhdmFpbGFibGVMb2NhbGVEYXRhLm1hcCk7XG4gICAgcmV0dXJuIG5ldyBEYXRlRW52KHtcbiAgICAgICAgY2FsZW5kYXJTeXN0ZW06ICdncmVnb3J5JyxcbiAgICAgICAgdGltZVpvbmUsXG4gICAgICAgIG5hbWVkVGltZVpvbmVJbXBsOiBwbHVnaW5Ib29rcy5uYW1lZFRpbWVab25lZEltcGwsXG4gICAgICAgIGxvY2FsZSxcbiAgICAgICAgd2Vla051bWJlckNhbGN1bGF0aW9uLFxuICAgICAgICBmaXJzdERheSxcbiAgICAgICAgd2Vla1RleHQsXG4gICAgICAgIGNtZEZvcm1hdHRlcjogcGx1Z2luSG9va3MuY21kRm9ybWF0dGVyLFxuICAgICAgICBkZWZhdWx0U2VwYXJhdG9yLFxuICAgIH0pO1xufVxuZnVuY3Rpb24gYnVpbGRUaGVtZShvcHRpb25zLCBwbHVnaW5Ib29rcykge1xuICAgIGxldCBUaGVtZUNsYXNzID0gcGx1Z2luSG9va3MudGhlbWVDbGFzc2VzW29wdGlvbnMudGhlbWVTeXN0ZW1dIHx8IFN0YW5kYXJkVGhlbWU7XG4gICAgcmV0dXJuIG5ldyBUaGVtZUNsYXNzKG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gYnVpbGREYXRlUHJvZmlsZUdlbmVyYXRvcihwcm9wcykge1xuICAgIGxldCBEYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzID0gcHJvcHMuZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyB8fCBEYXRlUHJvZmlsZUdlbmVyYXRvcjtcbiAgICByZXR1cm4gbmV3IERhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3MocHJvcHMpO1xufVxuZnVuY3Rpb24gYnVpbGRWaWV3QXBpKHR5cGUsIGdldEN1cnJlbnREYXRhLCBkYXRlRW52KSB7XG4gICAgcmV0dXJuIG5ldyBWaWV3SW1wbCh0eXBlLCBnZXRDdXJyZW50RGF0YSwgZGF0ZUVudik7XG59XG5mdW5jdGlvbiBidWlsZEV2ZW50VWlCeVNvdXJjZShldmVudFNvdXJjZXMpIHtcbiAgICByZXR1cm4gbWFwSGFzaChldmVudFNvdXJjZXMsIChldmVudFNvdXJjZSkgPT4gZXZlbnRTb3VyY2UudWkpO1xufVxuZnVuY3Rpb24gYnVpbGRFdmVudFVpQmFzZXMoZXZlbnREZWZzLCBldmVudFVpU2luZ2xlQmFzZSwgZXZlbnRVaUJ5U291cmNlKSB7XG4gICAgbGV0IGV2ZW50VWlCYXNlcyA9IHsgJyc6IGV2ZW50VWlTaW5nbGVCYXNlIH07XG4gICAgZm9yIChsZXQgZGVmSWQgaW4gZXZlbnREZWZzKSB7XG4gICAgICAgIGxldCBkZWYgPSBldmVudERlZnNbZGVmSWRdO1xuICAgICAgICBpZiAoZGVmLnNvdXJjZUlkICYmIGV2ZW50VWlCeVNvdXJjZVtkZWYuc291cmNlSWRdKSB7XG4gICAgICAgICAgICBldmVudFVpQmFzZXNbZGVmSWRdID0gZXZlbnRVaUJ5U291cmNlW2RlZi5zb3VyY2VJZF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50VWlCYXNlcztcbn1cbmZ1bmN0aW9uIGJ1aWxkVmlld1VpUHJvcHMoY2FsZW5kYXJDb250ZXh0KSB7XG4gICAgbGV0IHsgb3B0aW9ucyB9ID0gY2FsZW5kYXJDb250ZXh0O1xuICAgIHJldHVybiB7XG4gICAgICAgIGV2ZW50VWlTaW5nbGVCYXNlOiBjcmVhdGVFdmVudFVpKHtcbiAgICAgICAgICAgIGRpc3BsYXk6IG9wdGlvbnMuZXZlbnREaXNwbGF5LFxuICAgICAgICAgICAgZWRpdGFibGU6IG9wdGlvbnMuZWRpdGFibGUsXG4gICAgICAgICAgICBzdGFydEVkaXRhYmxlOiBvcHRpb25zLmV2ZW50U3RhcnRFZGl0YWJsZSxcbiAgICAgICAgICAgIGR1cmF0aW9uRWRpdGFibGU6IG9wdGlvbnMuZXZlbnREdXJhdGlvbkVkaXRhYmxlLFxuICAgICAgICAgICAgY29uc3RyYWludDogb3B0aW9ucy5ldmVudENvbnN0cmFpbnQsXG4gICAgICAgICAgICBvdmVybGFwOiB0eXBlb2Ygb3B0aW9ucy5ldmVudE92ZXJsYXAgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuZXZlbnRPdmVybGFwIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgYWxsb3c6IG9wdGlvbnMuZXZlbnRBbGxvdyxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5ldmVudEJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiBvcHRpb25zLmV2ZW50Qm9yZGVyQ29sb3IsXG4gICAgICAgICAgICB0ZXh0Q29sb3I6IG9wdGlvbnMuZXZlbnRUZXh0Q29sb3IsXG4gICAgICAgICAgICBjb2xvcjogb3B0aW9ucy5ldmVudENvbG9yLFxuICAgICAgICAgICAgLy8gY2xhc3NOYW1lczogb3B0aW9ucy5ldmVudENsYXNzTmFtZXMgLy8gcmVuZGVyIGhvb2sgd2lsbCBoYW5kbGUgdGhpc1xuICAgICAgICB9LCBjYWxlbmRhckNvbnRleHQpLFxuICAgICAgICBzZWxlY3Rpb25Db25maWc6IGNyZWF0ZUV2ZW50VWkoe1xuICAgICAgICAgICAgY29uc3RyYWludDogb3B0aW9ucy5zZWxlY3RDb25zdHJhaW50LFxuICAgICAgICAgICAgb3ZlcmxhcDogdHlwZW9mIG9wdGlvbnMuc2VsZWN0T3ZlcmxhcCA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5zZWxlY3RPdmVybGFwIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgYWxsb3c6IG9wdGlvbnMuc2VsZWN0QWxsb3csXG4gICAgICAgIH0sIGNhbGVuZGFyQ29udGV4dCksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVJc0xvYWRpbmcoc3RhdGUsIGNvbnRleHQpIHtcbiAgICBmb3IgKGxldCBpc0xvYWRpbmdGdW5jIG9mIGNvbnRleHQucGx1Z2luSG9va3MuaXNMb2FkaW5nRnVuY3MpIHtcbiAgICAgICAgaWYgKGlzTG9hZGluZ0Z1bmMoc3RhdGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBwYXJzZUNvbnRleHRCdXNpbmVzc0hvdXJzKGNhbGVuZGFyQ29udGV4dCkge1xuICAgIHJldHVybiBwYXJzZUJ1c2luZXNzSG91cnMoY2FsZW5kYXJDb250ZXh0Lm9wdGlvbnMuYnVzaW5lc3NIb3VycywgY2FsZW5kYXJDb250ZXh0KTtcbn1cbmZ1bmN0aW9uIHdhcm5Vbmtub3duT3B0aW9ucyhvcHRpb25zLCB2aWV3TmFtZSkge1xuICAgIGZvciAobGV0IG9wdGlvbk5hbWUgaW4gb3B0aW9ucykge1xuICAgICAgICBjb25zb2xlLndhcm4oYFVua25vd24gb3B0aW9uICcke29wdGlvbk5hbWV9J2AgK1xuICAgICAgICAgICAgKHZpZXdOYW1lID8gYCBmb3IgdmlldyAnJHt2aWV3TmFtZX0nYCA6ICcnKSk7XG4gICAgfVxufVxuXG5jbGFzcyBUb29sYmFyU2VjdGlvbiBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gdGhpcy5wcm9wcy53aWRnZXRHcm91cHMubWFwKCh3aWRnZXRHcm91cCkgPT4gdGhpcy5yZW5kZXJXaWRnZXRHcm91cCh3aWRnZXRHcm91cCkpO1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgnZGl2JywgeyBjbGFzc05hbWU6ICdmYy10b29sYmFyLWNodW5rJyB9LCAuLi5jaGlsZHJlbik7XG4gICAgfVxuICAgIHJlbmRlcldpZGdldEdyb3VwKHdpZGdldEdyb3VwKSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyB0aGVtZSB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgbGV0IGlzT25seUJ1dHRvbnMgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCB3aWRnZXQgb2Ygd2lkZ2V0R3JvdXApIHtcbiAgICAgICAgICAgIGxldCB7IGJ1dHRvbk5hbWUsIGJ1dHRvbkNsaWNrLCBidXR0b25UZXh0LCBidXR0b25JY29uLCBidXR0b25IaW50IH0gPSB3aWRnZXQ7XG4gICAgICAgICAgICBpZiAoYnV0dG9uTmFtZSA9PT0gJ3RpdGxlJykge1xuICAgICAgICAgICAgICAgIGlzT25seUJ1dHRvbnMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNyZWF0ZUVsZW1lbnQoXCJoMlwiLCB7IGNsYXNzTmFtZTogXCJmYy10b29sYmFyLXRpdGxlXCIsIGlkOiBwcm9wcy50aXRsZUlkIH0sIHByb3BzLnRpdGxlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgaXNQcmVzc2VkID0gYnV0dG9uTmFtZSA9PT0gcHJvcHMuYWN0aXZlQnV0dG9uO1xuICAgICAgICAgICAgICAgIGxldCBpc0Rpc2FibGVkID0gKCFwcm9wcy5pc1RvZGF5RW5hYmxlZCAmJiBidXR0b25OYW1lID09PSAndG9kYXknKSB8fFxuICAgICAgICAgICAgICAgICAgICAoIXByb3BzLmlzUHJldkVuYWJsZWQgJiYgYnV0dG9uTmFtZSA9PT0gJ3ByZXYnKSB8fFxuICAgICAgICAgICAgICAgICAgICAoIXByb3BzLmlzTmV4dEVuYWJsZWQgJiYgYnV0dG9uTmFtZSA9PT0gJ25leHQnKTtcbiAgICAgICAgICAgICAgICBsZXQgYnV0dG9uQ2xhc3NlcyA9IFtgZmMtJHtidXR0b25OYW1lfS1idXR0b25gLCB0aGVtZS5nZXRDbGFzcygnYnV0dG9uJyldO1xuICAgICAgICAgICAgICAgIGlmIChpc1ByZXNzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uQ2xhc3Nlcy5wdXNoKHRoZW1lLmdldENsYXNzKCdidXR0b25BY3RpdmUnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7IHR5cGU6IFwiYnV0dG9uXCIsIHRpdGxlOiB0eXBlb2YgYnV0dG9uSGludCA9PT0gJ2Z1bmN0aW9uJyA/IGJ1dHRvbkhpbnQocHJvcHMubmF2VW5pdCkgOiBidXR0b25IaW50LCBkaXNhYmxlZDogaXNEaXNhYmxlZCwgXCJhcmlhLXByZXNzZWRcIjogaXNQcmVzc2VkLCBjbGFzc05hbWU6IGJ1dHRvbkNsYXNzZXMuam9pbignICcpLCBvbkNsaWNrOiBidXR0b25DbGljayB9LCBidXR0b25UZXh0IHx8IChidXR0b25JY29uID8gY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6IGJ1dHRvbkljb24sIHJvbGU6IFwiaW1nXCIgfSkgOiAnJykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgbGV0IGdyb3VwQ2xhc3NOYW1lID0gKGlzT25seUJ1dHRvbnMgJiYgdGhlbWUuZ2V0Q2xhc3MoJ2J1dHRvbkdyb3VwJykpIHx8ICcnO1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHsgY2xhc3NOYW1lOiBncm91cENsYXNzTmFtZSB9LCAuLi5jaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuWzBdO1xuICAgIH1cbn1cblxuY2xhc3MgVG9vbGJhciBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgbW9kZWwsIGV4dHJhQ2xhc3NOYW1lIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBsZXQgZm9yY2VMdHIgPSBmYWxzZTtcbiAgICAgICAgbGV0IHN0YXJ0Q29udGVudDtcbiAgICAgICAgbGV0IGVuZENvbnRlbnQ7XG4gICAgICAgIGxldCBzZWN0aW9uV2lkZ2V0cyA9IG1vZGVsLnNlY3Rpb25XaWRnZXRzO1xuICAgICAgICBsZXQgY2VudGVyQ29udGVudCA9IHNlY3Rpb25XaWRnZXRzLmNlbnRlcjtcbiAgICAgICAgaWYgKHNlY3Rpb25XaWRnZXRzLmxlZnQpIHtcbiAgICAgICAgICAgIGZvcmNlTHRyID0gdHJ1ZTtcbiAgICAgICAgICAgIHN0YXJ0Q29udGVudCA9IHNlY3Rpb25XaWRnZXRzLmxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFydENvbnRlbnQgPSBzZWN0aW9uV2lkZ2V0cy5zdGFydDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VjdGlvbldpZGdldHMucmlnaHQpIHtcbiAgICAgICAgICAgIGZvcmNlTHRyID0gdHJ1ZTtcbiAgICAgICAgICAgIGVuZENvbnRlbnQgPSBzZWN0aW9uV2lkZ2V0cy5yaWdodDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVuZENvbnRlbnQgPSBzZWN0aW9uV2lkZ2V0cy5lbmQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNsYXNzTmFtZXMgPSBbXG4gICAgICAgICAgICBleHRyYUNsYXNzTmFtZSB8fCAnJyxcbiAgICAgICAgICAgICdmYy10b29sYmFyJyxcbiAgICAgICAgICAgIGZvcmNlTHRyID8gJ2ZjLXRvb2xiYXItbHRyJyA6ICcnLFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMuam9pbignICcpIH0sXG4gICAgICAgICAgICB0aGlzLnJlbmRlclNlY3Rpb24oJ3N0YXJ0Jywgc3RhcnRDb250ZW50IHx8IFtdKSxcbiAgICAgICAgICAgIHRoaXMucmVuZGVyU2VjdGlvbignY2VudGVyJywgY2VudGVyQ29udGVudCB8fCBbXSksXG4gICAgICAgICAgICB0aGlzLnJlbmRlclNlY3Rpb24oJ2VuZCcsIGVuZENvbnRlbnQgfHwgW10pKSk7XG4gICAgfVxuICAgIHJlbmRlclNlY3Rpb24oa2V5LCB3aWRnZXRHcm91cHMpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChUb29sYmFyU2VjdGlvbiwgeyBrZXk6IGtleSwgd2lkZ2V0R3JvdXBzOiB3aWRnZXRHcm91cHMsIHRpdGxlOiBwcm9wcy50aXRsZSwgbmF2VW5pdDogcHJvcHMubmF2VW5pdCwgYWN0aXZlQnV0dG9uOiBwcm9wcy5hY3RpdmVCdXR0b24sIGlzVG9kYXlFbmFibGVkOiBwcm9wcy5pc1RvZGF5RW5hYmxlZCwgaXNQcmV2RW5hYmxlZDogcHJvcHMuaXNQcmV2RW5hYmxlZCwgaXNOZXh0RW5hYmxlZDogcHJvcHMuaXNOZXh0RW5hYmxlZCwgdGl0bGVJZDogcHJvcHMudGl0bGVJZCB9KSk7XG4gICAgfVxufVxuXG5jbGFzcyBWaWV3SGFybmVzcyBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgYXZhaWxhYmxlV2lkdGg6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlRWwgPSAoZWwpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgICAgICAgIHNldFJlZih0aGlzLnByb3BzLmVsUmVmLCBlbCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUF2YWlsYWJsZVdpZHRoKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUmVzaXplID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVBdmFpbGFibGVXaWR0aCgpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBzdGF0ZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgYXNwZWN0UmF0aW8gfSA9IHByb3BzO1xuICAgICAgICBsZXQgY2xhc3NOYW1lcyA9IFtcbiAgICAgICAgICAgICdmYy12aWV3LWhhcm5lc3MnLFxuICAgICAgICAgICAgKGFzcGVjdFJhdGlvIHx8IHByb3BzLmxpcXVpZCB8fCBwcm9wcy5oZWlnaHQpXG4gICAgICAgICAgICAgICAgPyAnZmMtdmlldy1oYXJuZXNzLWFjdGl2ZScgLy8gaGFybmVzcyBjb250cm9scyB0aGUgaGVpZ2h0XG4gICAgICAgICAgICAgICAgOiAnZmMtdmlldy1oYXJuZXNzLXBhc3NpdmUnLCAvLyBsZXQgdGhlIHZpZXcgZG8gdGhlIGhlaWdodFxuICAgICAgICBdO1xuICAgICAgICBsZXQgaGVpZ2h0ID0gJyc7XG4gICAgICAgIGxldCBwYWRkaW5nQm90dG9tID0gJyc7XG4gICAgICAgIGlmIChhc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmF2YWlsYWJsZVdpZHRoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gc3RhdGUuYXZhaWxhYmxlV2lkdGggLyBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHdoaWxlIHdhaXRpbmcgdG8ga25vdyBhdmFpbGFibGVXaWR0aCwgd2UgY2FuJ3Qgc2V0IGhlaWdodCB0byAqemVybypcbiAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIHdpbGwgY2F1c2UgbG90cyBvZiB1bm5lY2Vzc2FyeSBzY3JvbGxiYXJzIHdpdGhpbiBzY3JvbGxncmlkLlxuICAgICAgICAgICAgICAgIC8vIEJFVFRFUjogZG9uJ3Qgc3RhcnQgcmVuZGVyaW5nIEFOWVRISU5HIHlldCB1bnRpbCB3ZSBrbm93IGNvbnRhaW5lciB3aWR0aFxuICAgICAgICAgICAgICAgIC8vIE5PVEU6IHdoeSBub3QgYWx3YXlzIHVzZSBwYWRkaW5nQm90dG9tPyBDYXVzZXMgaGVpZ2h0IG9zY2lsbGF0aW9uIChpc3N1ZSA1NjA2KVxuICAgICAgICAgICAgICAgIHBhZGRpbmdCb3R0b20gPSBgJHsoMSAvIGFzcGVjdFJhdGlvKSAqIDEwMH0lYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhlaWdodCA9IHByb3BzLmhlaWdodCB8fCAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBcImFyaWEtbGFiZWxsZWRieVwiOiBwcm9wcy5sYWJlbGVkQnlJZCwgcmVmOiB0aGlzLmhhbmRsZUVsLCBjbGFzc05hbWU6IGNsYXNzTmFtZXMuam9pbignICcpLCBzdHlsZTogeyBoZWlnaHQsIHBhZGRpbmdCb3R0b20gfSB9LCBwcm9wcy5jaGlsZHJlbikpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LmFkZFJlc2l6ZUhhbmRsZXIodGhpcy5oYW5kbGVSZXNpemUpO1xuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LnJlbW92ZVJlc2l6ZUhhbmRsZXIodGhpcy5oYW5kbGVSZXNpemUpO1xuICAgIH1cbiAgICB1cGRhdGVBdmFpbGFibGVXaWR0aCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZWwgJiYgLy8gbmVlZGVkLiBidXQgd2h5P1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5hc3BlY3RSYXRpbyAvLyBhc3BlY3RSYXRpbyBpcyB0aGUgb25seSBoZWlnaHQgc2V0dGluZyB0aGF0IG5lZWRzIGF2YWlsYWJsZVdpZHRoXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGF2YWlsYWJsZVdpZHRoOiB0aGlzLmVsLm9mZnNldFdpZHRoIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKlxuRGV0ZWN0cyB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiBhbiBldmVudCB3aXRoaW4gYSBEYXRlQ29tcG9uZW50XG4qL1xuY2xhc3MgRXZlbnRDbGlja2luZyBleHRlbmRzIEludGVyYWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgICAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgICAgIHRoaXMuaGFuZGxlU2VnQ2xpY2sgPSAoZXYsIHNlZ0VsKSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBjb21wb25lbnQgfSA9IHRoaXM7XG4gICAgICAgICAgICBsZXQgeyBjb250ZXh0IH0gPSBjb21wb25lbnQ7XG4gICAgICAgICAgICBsZXQgc2VnID0gZ2V0RWxTZWcoc2VnRWwpO1xuICAgICAgICAgICAgaWYgKHNlZyAmJiAvLyBtaWdodCBiZSB0aGUgPGRpdj4gc3Vycm91bmRpbmcgdGhlIG1vcmUgbGlua1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5pc1ZhbGlkU2VnRG93bkVsKGV2LnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAvLyBvdXIgd2F5IHRvIHNpbXVsYXRlIGEgbGluayBjbGljayBmb3IgZWxlbWVudHMgdGhhdCBjYW4ndCBiZSA8YT4gdGFnc1xuICAgICAgICAgICAgICAgIC8vIGdyYWIgYmVmb3JlIHRyaWdnZXIgZmlyZWQgaW4gY2FzZSB0cmlnZ2VyIHRyYXNoZXMgRE9NIHRocnUgcmVyZW5kZXJpbmdcbiAgICAgICAgICAgICAgICBsZXQgaGFzVXJsQ29udGFpbmVyID0gZWxlbWVudENsb3Nlc3QoZXYudGFyZ2V0LCAnLmZjLWV2ZW50LWZvcmNlZC11cmwnKTtcbiAgICAgICAgICAgICAgICBsZXQgdXJsID0gaGFzVXJsQ29udGFpbmVyID8gaGFzVXJsQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJ2FbaHJlZl0nKS5ocmVmIDogJyc7XG4gICAgICAgICAgICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50Q2xpY2snLCB7XG4gICAgICAgICAgICAgICAgICAgIGVsOiBzZWdFbCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IG5ldyBFdmVudEltcGwoY29tcG9uZW50LmNvbnRleHQsIHNlZy5ldmVudFJhbmdlLmRlZiwgc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgICAgICBqc0V2ZW50OiBldixcbiAgICAgICAgICAgICAgICAgICAgdmlldzogY29udGV4dC52aWV3QXBpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh1cmwgJiYgIWV2LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRlc3Ryb3kgPSBsaXN0ZW5CeVNlbGVjdG9yKHNldHRpbmdzLmVsLCAnY2xpY2snLCAnLmZjLWV2ZW50JywgLy8gb24gYm90aCBmZyBhbmQgYmcgZXZlbnRzXG4gICAgICAgIHRoaXMuaGFuZGxlU2VnQ2xpY2spO1xuICAgIH1cbn1cblxuLypcblRyaWdnZXJzIGV2ZW50cyBhbmQgYWRkcy9yZW1vdmVzIGNvcmUgY2xhc3NOYW1lcyB3aGVuIHRoZSB1c2VyJ3MgcG9pbnRlclxuZW50ZXJzL2xlYXZlcyBldmVudC1lbGVtZW50cyBvZiBhIGNvbXBvbmVudC5cbiovXG5jbGFzcyBFdmVudEhvdmVyaW5nIGV4dGVuZHMgSW50ZXJhY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICAgICAgLy8gZm9yIHNpbXVsYXRpbmcgYW4gZXZlbnRNb3VzZUxlYXZlIHdoZW4gdGhlIGV2ZW50IGVsIGlzIGRlc3Ryb3llZCB3aGlsZSBtb3VzZSBpcyBvdmVyIGl0XG4gICAgICAgIHRoaXMuaGFuZGxlRXZlbnRFbFJlbW92ZSA9IChlbCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVsID09PSB0aGlzLmN1cnJlbnRTZWdFbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlU2VnTGVhdmUobnVsbCwgdGhpcy5jdXJyZW50U2VnRWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVNlZ0VudGVyID0gKGV2LCBzZWdFbCkgPT4ge1xuICAgICAgICAgICAgaWYgKGdldEVsU2VnKHNlZ0VsKSkgeyAvLyBUT0RPOiBiZXR0ZXIgd2F5IHRvIG1ha2Ugc3VyZSBub3QgaG92ZXJpbmcgb3ZlciBtb3JlKyBsaW5rIG9yIGl0cyB3cmFwcGVyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U2VnRWwgPSBzZWdFbDtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJFdmVudCgnZXZlbnRNb3VzZUVudGVyJywgZXYsIHNlZ0VsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVTZWdMZWF2ZSA9IChldiwgc2VnRWwpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRTZWdFbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNlZ0VsID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJFdmVudCgnZXZlbnRNb3VzZUxlYXZlJywgZXYsIHNlZ0VsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZW1vdmVIb3Zlckxpc3RlbmVycyA9IGxpc3RlblRvSG92ZXJCeVNlbGVjdG9yKHNldHRpbmdzLmVsLCAnLmZjLWV2ZW50JywgLy8gb24gYm90aCBmZyBhbmQgYmcgZXZlbnRzXG4gICAgICAgIHRoaXMuaGFuZGxlU2VnRW50ZXIsIHRoaXMuaGFuZGxlU2VnTGVhdmUpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnJlbW92ZUhvdmVyTGlzdGVuZXJzKCk7XG4gICAgfVxuICAgIHRyaWdnZXJFdmVudChwdWJsaWNFdk5hbWUsIGV2LCBzZWdFbCkge1xuICAgICAgICBsZXQgeyBjb21wb25lbnQgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IGNvbnRleHQgfSA9IGNvbXBvbmVudDtcbiAgICAgICAgbGV0IHNlZyA9IGdldEVsU2VnKHNlZ0VsKTtcbiAgICAgICAgaWYgKCFldiB8fCBjb21wb25lbnQuaXNWYWxpZFNlZ0Rvd25FbChldi50YXJnZXQpKSB7XG4gICAgICAgICAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcihwdWJsaWNFdk5hbWUsIHtcbiAgICAgICAgICAgICAgICBlbDogc2VnRWwsXG4gICAgICAgICAgICAgICAgZXZlbnQ6IG5ldyBFdmVudEltcGwoY29udGV4dCwgc2VnLmV2ZW50UmFuZ2UuZGVmLCBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZSksXG4gICAgICAgICAgICAgICAganNFdmVudDogZXYsXG4gICAgICAgICAgICAgICAgdmlldzogY29udGV4dC52aWV3QXBpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIENhbGVuZGFyQ29udGVudCBleHRlbmRzIFB1cmVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmJ1aWxkVmlld0NvbnRleHQgPSBtZW1vaXplKGJ1aWxkVmlld0NvbnRleHQpO1xuICAgICAgICB0aGlzLmJ1aWxkVmlld1Byb3BUcmFuc2Zvcm1lcnMgPSBtZW1vaXplKGJ1aWxkVmlld1Byb3BUcmFuc2Zvcm1lcnMpO1xuICAgICAgICB0aGlzLmJ1aWxkVG9vbGJhclByb3BzID0gbWVtb2l6ZShidWlsZFRvb2xiYXJQcm9wcyk7XG4gICAgICAgIHRoaXMuaGVhZGVyUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIHRoaXMuZm9vdGVyUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpb25zU3RvcmUgPSB7fTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICB2aWV3TGFiZWxJZDogZ2V0VW5pcXVlRG9tSWQoKSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQ29tcG9uZW50IFJlZ2lzdHJhdGlvblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICB0aGlzLnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQgPSAoY29tcG9uZW50LCBzZXR0aW5nc0lucHV0KSA9PiB7XG4gICAgICAgICAgICBsZXQgc2V0dGluZ3MgPSBwYXJzZUludGVyYWN0aW9uU2V0dGluZ3MoY29tcG9uZW50LCBzZXR0aW5nc0lucHV0KTtcbiAgICAgICAgICAgIGxldCBERUZBVUxUX0lOVEVSQUNUSU9OUyA9IFtcbiAgICAgICAgICAgICAgICBFdmVudENsaWNraW5nLFxuICAgICAgICAgICAgICAgIEV2ZW50SG92ZXJpbmcsXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgbGV0IGludGVyYWN0aW9uQ2xhc3NlcyA9IERFRkFVTFRfSU5URVJBQ1RJT05TLmNvbmNhdCh0aGlzLnByb3BzLnBsdWdpbkhvb2tzLmNvbXBvbmVudEludGVyYWN0aW9ucyk7XG4gICAgICAgICAgICBsZXQgaW50ZXJhY3Rpb25zID0gaW50ZXJhY3Rpb25DbGFzc2VzLm1hcCgoVGhlSW50ZXJhY3Rpb25DbGFzcykgPT4gbmV3IFRoZUludGVyYWN0aW9uQ2xhc3Moc2V0dGluZ3MpKTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25zU3RvcmVbY29tcG9uZW50LnVpZF0gPSBpbnRlcmFjdGlvbnM7XG4gICAgICAgICAgICBpbnRlcmFjdGlvblNldHRpbmdzU3RvcmVbY29tcG9uZW50LnVpZF0gPSBzZXR0aW5ncztcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQgPSAoY29tcG9uZW50KSA9PiB7XG4gICAgICAgICAgICBsZXQgbGlzdGVuZXJzID0gdGhpcy5pbnRlcmFjdGlvbnNTdG9yZVtjb21wb25lbnQudWlkXTtcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiBsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5pbnRlcmFjdGlvbnNTdG9yZVtjb21wb25lbnQudWlkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSBpbnRlcmFjdGlvblNldHRpbmdzU3RvcmVbY29tcG9uZW50LnVpZF07XG4gICAgICAgIH07XG4gICAgICAgIC8vIFJlc2l6aW5nXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHRoaXMucmVzaXplUnVubmVyID0gbmV3IERlbGF5ZWRSdW5uZXIoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5lbWl0dGVyLnRyaWdnZXIoJ19yZXNpemUnLCB0cnVlKTsgLy8gc2hvdWxkIHdpbmRvdyByZXNpemVzIGJlIGNvbnNpZGVyZWQgXCJmb3JjZWRcIiA/XG4gICAgICAgICAgICB0aGlzLnByb3BzLmVtaXR0ZXIudHJpZ2dlcignd2luZG93UmVzaXplJywgeyB2aWV3OiB0aGlzLnByb3BzLnZpZXdBcGkgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhhbmRsZVdpbmRvd1Jlc2l6ZSA9IChldikgPT4ge1xuICAgICAgICAgICAgbGV0IHsgb3B0aW9ucyB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmhhbmRsZVdpbmRvd1Jlc2l6ZSAmJlxuICAgICAgICAgICAgICAgIGV2LnRhcmdldCA9PT0gd2luZG93IC8vIGF2b2lkIGpxdWkgZXZlbnRzXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZVJ1bm5lci5yZXF1ZXN0KG9wdGlvbnMud2luZG93UmVzaXplRGVsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKlxuICAgIHJlbmRlcnMgSU5TSURFIG9mIGFuIG91dGVyIGRpdlxuICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgdG9vbGJhckNvbmZpZywgb3B0aW9ucyB9ID0gcHJvcHM7XG4gICAgICAgIGxldCB0b29sYmFyUHJvcHMgPSB0aGlzLmJ1aWxkVG9vbGJhclByb3BzKHByb3BzLnZpZXdTcGVjLCBwcm9wcy5kYXRlUHJvZmlsZSwgcHJvcHMuZGF0ZVByb2ZpbGVHZW5lcmF0b3IsIHByb3BzLmN1cnJlbnREYXRlLCBnZXROb3cocHJvcHMub3B0aW9ucy5ub3csIHByb3BzLmRhdGVFbnYpLCAvLyBUT0RPOiB1c2UgTm93VGltZXI/Pz8/XG4gICAgICAgIHByb3BzLnZpZXdUaXRsZSk7XG4gICAgICAgIGxldCB2aWV3Vkdyb3cgPSBmYWxzZTtcbiAgICAgICAgbGV0IHZpZXdIZWlnaHQgPSAnJztcbiAgICAgICAgbGV0IHZpZXdBc3BlY3RSYXRpbztcbiAgICAgICAgaWYgKHByb3BzLmlzSGVpZ2h0QXV0byB8fCBwcm9wcy5mb3JQcmludCkge1xuICAgICAgICAgICAgdmlld0hlaWdodCA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuaGVpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZpZXdWR3JvdyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5jb250ZW50SGVpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZpZXdIZWlnaHQgPSBvcHRpb25zLmNvbnRlbnRIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2aWV3QXNwZWN0UmF0aW8gPSBNYXRoLm1heChvcHRpb25zLmFzcGVjdFJhdGlvLCAwLjUpOyAvLyBwcmV2ZW50IGZyb20gZ2V0dGluZyB0b28gdGFsbFxuICAgICAgICB9XG4gICAgICAgIGxldCB2aWV3Q29udGV4dCA9IHRoaXMuYnVpbGRWaWV3Q29udGV4dChwcm9wcy52aWV3U3BlYywgcHJvcHMudmlld0FwaSwgcHJvcHMub3B0aW9ucywgcHJvcHMuZGF0ZVByb2ZpbGVHZW5lcmF0b3IsIHByb3BzLmRhdGVFbnYsIHByb3BzLnRoZW1lLCBwcm9wcy5wbHVnaW5Ib29rcywgcHJvcHMuZGlzcGF0Y2gsIHByb3BzLmdldEN1cnJlbnREYXRhLCBwcm9wcy5lbWl0dGVyLCBwcm9wcy5jYWxlbmRhckFwaSwgdGhpcy5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50LCB0aGlzLnVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCk7XG4gICAgICAgIGxldCB2aWV3TGFiZWxJZCA9ICh0b29sYmFyQ29uZmlnLmhlYWRlciAmJiB0b29sYmFyQ29uZmlnLmhlYWRlci5oYXNUaXRsZSlcbiAgICAgICAgICAgID8gdGhpcy5zdGF0ZS52aWV3TGFiZWxJZFxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChWaWV3Q29udGV4dFR5cGUuUHJvdmlkZXIsIHsgdmFsdWU6IHZpZXdDb250ZXh0IH0sXG4gICAgICAgICAgICB0b29sYmFyQ29uZmlnLmhlYWRlciAmJiAoY3JlYXRlRWxlbWVudChUb29sYmFyLCBPYmplY3QuYXNzaWduKHsgcmVmOiB0aGlzLmhlYWRlclJlZiwgZXh0cmFDbGFzc05hbWU6IFwiZmMtaGVhZGVyLXRvb2xiYXJcIiwgbW9kZWw6IHRvb2xiYXJDb25maWcuaGVhZGVyLCB0aXRsZUlkOiB2aWV3TGFiZWxJZCB9LCB0b29sYmFyUHJvcHMpKSksXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFZpZXdIYXJuZXNzLCB7IGxpcXVpZDogdmlld1ZHcm93LCBoZWlnaHQ6IHZpZXdIZWlnaHQsIGFzcGVjdFJhdGlvOiB2aWV3QXNwZWN0UmF0aW8sIGxhYmVsZWRCeUlkOiB2aWV3TGFiZWxJZCB9LFxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyVmlldyhwcm9wcyksXG4gICAgICAgICAgICAgICAgdGhpcy5idWlsZEFwcGVuZENvbnRlbnQoKSksXG4gICAgICAgICAgICB0b29sYmFyQ29uZmlnLmZvb3RlciAmJiAoY3JlYXRlRWxlbWVudChUb29sYmFyLCBPYmplY3QuYXNzaWduKHsgcmVmOiB0aGlzLmZvb3RlclJlZiwgZXh0cmFDbGFzc05hbWU6IFwiZmMtZm9vdGVyLXRvb2xiYXJcIiwgbW9kZWw6IHRvb2xiYXJDb25maWcuZm9vdGVyLCB0aXRsZUlkOiBcIlwiIH0sIHRvb2xiYXJQcm9wcykpKSkpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJJbnRlcmFjdGlvbnMgPSBwcm9wcy5wbHVnaW5Ib29rcy5jYWxlbmRhckludGVyYWN0aW9uc1xuICAgICAgICAgICAgLm1hcCgoQ2FsZW5kYXJJbnRlcmFjdGlvbkNsYXNzKSA9PiBuZXcgQ2FsZW5kYXJJbnRlcmFjdGlvbkNsYXNzKHByb3BzKSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLmhhbmRsZVdpbmRvd1Jlc2l6ZSk7XG4gICAgICAgIGxldCB7IHByb3BTZXRIYW5kbGVycyB9ID0gcHJvcHMucGx1Z2luSG9va3M7XG4gICAgICAgIGZvciAobGV0IHByb3BOYW1lIGluIHByb3BTZXRIYW5kbGVycykge1xuICAgICAgICAgICAgcHJvcFNldEhhbmRsZXJzW3Byb3BOYW1lXShwcm9wc1twcm9wTmFtZV0sIHByb3BzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBwcm9wU2V0SGFuZGxlcnMgfSA9IHByb3BzLnBsdWdpbkhvb2tzO1xuICAgICAgICBmb3IgKGxldCBwcm9wTmFtZSBpbiBwcm9wU2V0SGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gIT09IHByZXZQcm9wc1twcm9wTmFtZV0pIHtcbiAgICAgICAgICAgICAgICBwcm9wU2V0SGFuZGxlcnNbcHJvcE5hbWVdKHByb3BzW3Byb3BOYW1lXSwgcHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5oYW5kbGVXaW5kb3dSZXNpemUpO1xuICAgICAgICB0aGlzLnJlc2l6ZVJ1bm5lci5jbGVhcigpO1xuICAgICAgICBmb3IgKGxldCBpbnRlcmFjdGlvbiBvZiB0aGlzLmNhbGVuZGFySW50ZXJhY3Rpb25zKSB7XG4gICAgICAgICAgICBpbnRlcmFjdGlvbi5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm9wcy5lbWl0dGVyLnRyaWdnZXIoJ191bm1vdW50Jyk7XG4gICAgfVxuICAgIGJ1aWxkQXBwZW5kQ29udGVudCgpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IHByb3BzLnBsdWdpbkhvb2tzLnZpZXdDb250YWluZXJBcHBlbmRzLm1hcCgoYnVpbGRBcHBlbmRDb250ZW50KSA9PiBidWlsZEFwcGVuZENvbnRlbnQocHJvcHMpKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIHt9LCAuLi5jaGlsZHJlbik7XG4gICAgfVxuICAgIHJlbmRlclZpZXcocHJvcHMpIHtcbiAgICAgICAgbGV0IHsgcGx1Z2luSG9va3MgfSA9IHByb3BzO1xuICAgICAgICBsZXQgeyB2aWV3U3BlYyB9ID0gcHJvcHM7XG4gICAgICAgIGxldCB2aWV3UHJvcHMgPSB7XG4gICAgICAgICAgICBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsXG4gICAgICAgICAgICBidXNpbmVzc0hvdXJzOiBwcm9wcy5idXNpbmVzc0hvdXJzLFxuICAgICAgICAgICAgZXZlbnRTdG9yZTogcHJvcHMucmVuZGVyYWJsZUV2ZW50U3RvcmUsXG4gICAgICAgICAgICBldmVudFVpQmFzZXM6IHByb3BzLmV2ZW50VWlCYXNlcyxcbiAgICAgICAgICAgIGRhdGVTZWxlY3Rpb246IHByb3BzLmRhdGVTZWxlY3Rpb24sXG4gICAgICAgICAgICBldmVudFNlbGVjdGlvbjogcHJvcHMuZXZlbnRTZWxlY3Rpb24sXG4gICAgICAgICAgICBldmVudERyYWc6IHByb3BzLmV2ZW50RHJhZyxcbiAgICAgICAgICAgIGV2ZW50UmVzaXplOiBwcm9wcy5ldmVudFJlc2l6ZSxcbiAgICAgICAgICAgIGlzSGVpZ2h0QXV0bzogcHJvcHMuaXNIZWlnaHRBdXRvLFxuICAgICAgICAgICAgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50LFxuICAgICAgICB9O1xuICAgICAgICBsZXQgdHJhbnNmb3JtZXJzID0gdGhpcy5idWlsZFZpZXdQcm9wVHJhbnNmb3JtZXJzKHBsdWdpbkhvb2tzLnZpZXdQcm9wc1RyYW5zZm9ybWVycyk7XG4gICAgICAgIGZvciAobGV0IHRyYW5zZm9ybWVyIG9mIHRyYW5zZm9ybWVycykge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih2aWV3UHJvcHMsIHRyYW5zZm9ybWVyLnRyYW5zZm9ybSh2aWV3UHJvcHMsIHByb3BzKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IFZpZXdDb21wb25lbnQgPSB2aWV3U3BlYy5jb21wb25lbnQ7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChWaWV3Q29tcG9uZW50LCBPYmplY3QuYXNzaWduKHt9LCB2aWV3UHJvcHMpKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gYnVpbGRUb29sYmFyUHJvcHModmlld1NwZWMsIGRhdGVQcm9maWxlLCBkYXRlUHJvZmlsZUdlbmVyYXRvciwgY3VycmVudERhdGUsIG5vdywgdGl0bGUpIHtcbiAgICAvLyBkb24ndCBmb3JjZSBhbnkgZGF0ZS1wcm9maWxlcyB0byB2YWxpZCBkYXRlIHByb2ZpbGVzICh0aGUgYGZhbHNlYCkgc28gdGhhdCB3ZSBjYW4gdGVsbCBpZiBpdCdzIGludmFsaWRcbiAgICBsZXQgdG9kYXlJbmZvID0gZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGQobm93LCB1bmRlZmluZWQsIGZhbHNlKTsgLy8gVE9ETzogbmVlZCBgdW5kZWZpbmVkYCBvciBlbHNlIElORklOSVRFIExPT1AgZm9yIHNvbWUgcmVhc29uXG4gICAgbGV0IHByZXZJbmZvID0gZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGRQcmV2KGRhdGVQcm9maWxlLCBjdXJyZW50RGF0ZSwgZmFsc2UpO1xuICAgIGxldCBuZXh0SW5mbyA9IGRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkTmV4dChkYXRlUHJvZmlsZSwgY3VycmVudERhdGUsIGZhbHNlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0aXRsZSxcbiAgICAgICAgYWN0aXZlQnV0dG9uOiB2aWV3U3BlYy50eXBlLFxuICAgICAgICBuYXZVbml0OiB2aWV3U3BlYy5zaW5nbGVVbml0LFxuICAgICAgICBpc1RvZGF5RW5hYmxlZDogdG9kYXlJbmZvLmlzVmFsaWQgJiYgIXJhbmdlQ29udGFpbnNNYXJrZXIoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLCBub3cpLFxuICAgICAgICBpc1ByZXZFbmFibGVkOiBwcmV2SW5mby5pc1ZhbGlkLFxuICAgICAgICBpc05leHRFbmFibGVkOiBuZXh0SW5mby5pc1ZhbGlkLFxuICAgIH07XG59XG4vLyBQbHVnaW5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBidWlsZFZpZXdQcm9wVHJhbnNmb3JtZXJzKHRoZUNsYXNzZXMpIHtcbiAgICByZXR1cm4gdGhlQ2xhc3Nlcy5tYXAoKFRoZUNsYXNzKSA9PiBuZXcgVGhlQ2xhc3MoKSk7XG59XG5cbmNsYXNzIENhbGVuZGFyIGV4dGVuZHMgQ2FsZW5kYXJJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihlbCwgb3B0aW9uT3ZlcnJpZGVzID0ge30pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pc1JlbmRlcmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzUmVuZGVyZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJyZW50Q2xhc3NOYW1lcyA9IFtdO1xuICAgICAgICB0aGlzLmN1c3RvbUNvbnRlbnRSZW5kZXJJZCA9IDA7XG4gICAgICAgIHRoaXMuaGFuZGxlQWN0aW9uID0gKGFjdGlvbikgPT4ge1xuICAgICAgICAgICAgLy8gYWN0aW9ucyB3ZSBrbm93IHdlIHdhbnQgdG8gcmVuZGVyIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnU0VUX0VWRU5UX0RSQUcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ1NFVF9FVkVOVF9SRVNJWkUnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclJ1bm5lci50cnlEcmFpbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZURhdGEgPSAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50RGF0YSA9IGRhdGE7XG4gICAgICAgICAgICB0aGlzLnJlbmRlclJ1bm5lci5yZXF1ZXN0KGRhdGEuY2FsZW5kYXJPcHRpb25zLnJlcmVuZGVyRGVsYXkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVJlbmRlclJlcXVlc3QgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1JlbmRlcmluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNSZW5kZXJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgbGV0IHsgY3VycmVudERhdGEgfSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgZmx1c2hTeW5jKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyKGNyZWF0ZUVsZW1lbnQoQ2FsZW5kYXJSb290LCB7IG9wdGlvbnM6IGN1cnJlbnREYXRhLmNhbGVuZGFyT3B0aW9ucywgdGhlbWU6IGN1cnJlbnREYXRhLnRoZW1lLCBlbWl0dGVyOiBjdXJyZW50RGF0YS5lbWl0dGVyIH0sIChjbGFzc05hbWVzLCBoZWlnaHQsIGlzSGVpZ2h0QXV0bywgZm9yUHJpbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Q2xhc3NOYW1lcyhjbGFzc05hbWVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0SGVpZ2h0KGhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoUmVuZGVySWQuUHJvdmlkZXIsIHsgdmFsdWU6IHRoaXMuY3VzdG9tQ29udGVudFJlbmRlcklkIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChDYWxlbmRhckNvbnRlbnQsIE9iamVjdC5hc3NpZ24oeyBpc0hlaWdodEF1dG86IGlzSGVpZ2h0QXV0bywgZm9yUHJpbnQ6IGZvclByaW50IH0sIGN1cnJlbnREYXRhKSkpKTtcbiAgICAgICAgICAgICAgICAgICAgfSksIHRoaXMuZWwpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pc1JlbmRlcmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc1JlbmRlcmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmVuZGVyKG51bGwsIHRoaXMuZWwpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q2xhc3NOYW1lcyhbXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRIZWlnaHQoJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBlbnN1cmVFbEhhc1N0eWxlcyhlbCk7XG4gICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgICAgdGhpcy5yZW5kZXJSdW5uZXIgPSBuZXcgRGVsYXllZFJ1bm5lcih0aGlzLmhhbmRsZVJlbmRlclJlcXVlc3QpO1xuICAgICAgICBuZXcgQ2FsZW5kYXJEYXRhTWFuYWdlcih7XG4gICAgICAgICAgICBvcHRpb25PdmVycmlkZXMsXG4gICAgICAgICAgICBjYWxlbmRhckFwaTogdGhpcyxcbiAgICAgICAgICAgIG9uQWN0aW9uOiB0aGlzLmhhbmRsZUFjdGlvbixcbiAgICAgICAgICAgIG9uRGF0YTogdGhpcy5oYW5kbGVEYXRhLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgd2FzUmVuZGVyaW5nID0gdGhpcy5pc1JlbmRlcmluZztcbiAgICAgICAgaWYgKCF3YXNSZW5kZXJpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuaXNSZW5kZXJpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXN0b21Db250ZW50UmVuZGVySWQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbmRlclJ1bm5lci5yZXF1ZXN0KCk7XG4gICAgICAgIGlmICh3YXNSZW5kZXJpbmcpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2l6ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmlzUmVuZGVyaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmlzUmVuZGVyaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnJlbmRlclJ1bm5lci5yZXF1ZXN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlU2l6ZSgpIHtcbiAgICAgICAgZmx1c2hTeW5jKCgpID0+IHtcbiAgICAgICAgICAgIHN1cGVyLnVwZGF0ZVNpemUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGJhdGNoUmVuZGVyaW5nKGZ1bmMpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJSdW5uZXIucGF1c2UoJ2JhdGNoUmVuZGVyaW5nJyk7XG4gICAgICAgIGZ1bmMoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJSdW5uZXIucmVzdW1lKCdiYXRjaFJlbmRlcmluZycpO1xuICAgIH1cbiAgICBwYXVzZVJlbmRlcmluZygpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJSdW5uZXIucGF1c2UoJ3BhdXNlUmVuZGVyaW5nJyk7XG4gICAgfVxuICAgIHJlc3VtZVJlbmRlcmluZygpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJSdW5uZXIucmVzdW1lKCdwYXVzZVJlbmRlcmluZycsIHRydWUpO1xuICAgIH1cbiAgICByZXNldE9wdGlvbnMob3B0aW9uT3ZlcnJpZGVzLCBjaGFuZ2VkT3B0aW9uTmFtZXMpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50RGF0YU1hbmFnZXIucmVzZXRPcHRpb25zKG9wdGlvbk92ZXJyaWRlcywgY2hhbmdlZE9wdGlvbk5hbWVzKTtcbiAgICB9XG4gICAgc2V0Q2xhc3NOYW1lcyhjbGFzc05hbWVzKSB7XG4gICAgICAgIGlmICghaXNBcnJheXNFcXVhbChjbGFzc05hbWVzLCB0aGlzLmN1cnJlbnRDbGFzc05hbWVzKSkge1xuICAgICAgICAgICAgbGV0IHsgY2xhc3NMaXN0IH0gPSB0aGlzLmVsO1xuICAgICAgICAgICAgZm9yIChsZXQgY2xhc3NOYW1lIG9mIHRoaXMuY3VycmVudENsYXNzTmFtZXMpIHtcbiAgICAgICAgICAgICAgICBjbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBjbGFzc05hbWUgb2YgY2xhc3NOYW1lcykge1xuICAgICAgICAgICAgICAgIGNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY3VycmVudENsYXNzTmFtZXMgPSBjbGFzc05hbWVzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldEhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgYXBwbHlTdHlsZVByb3AodGhpcy5lbCwgJ2hlaWdodCcsIGhlaWdodCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmb3JtYXREYXRlKGRhdGVJbnB1dCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IGRhdGVFbnYgPSBidWlsZERhdGVFbnYob3B0aW9ucyk7XG4gICAgbGV0IGZvcm1hdHRlciA9IGNyZWF0ZUZvcm1hdHRlcihvcHRpb25zKTtcbiAgICBsZXQgZGF0ZU1ldGEgPSBkYXRlRW52LmNyZWF0ZU1hcmtlck1ldGEoZGF0ZUlucHV0KTtcbiAgICBpZiAoIWRhdGVNZXRhKSB7IC8vIFRPRE86IHdhcm5pbmc/XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0KGRhdGVNZXRhLm1hcmtlciwgZm9ybWF0dGVyLCB7XG4gICAgICAgIGZvcmNlZFR6bzogZGF0ZU1ldGEuZm9yY2VkVHpvLFxuICAgIH0pO1xufVxuZnVuY3Rpb24gZm9ybWF0UmFuZ2Uoc3RhcnRJbnB1dCwgZW5kSW5wdXQsIG9wdGlvbnMpIHtcbiAgICBsZXQgZGF0ZUVudiA9IGJ1aWxkRGF0ZUVudih0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgJiYgb3B0aW9ucyA/IG9wdGlvbnMgOiB7fSk7IC8vIHBhc3MgaW4gaWYgbm9uLW51bGwgb2JqZWN0XG4gICAgbGV0IGZvcm1hdHRlciA9IGNyZWF0ZUZvcm1hdHRlcihvcHRpb25zKTtcbiAgICBsZXQgc3RhcnRNZXRhID0gZGF0ZUVudi5jcmVhdGVNYXJrZXJNZXRhKHN0YXJ0SW5wdXQpO1xuICAgIGxldCBlbmRNZXRhID0gZGF0ZUVudi5jcmVhdGVNYXJrZXJNZXRhKGVuZElucHV0KTtcbiAgICBpZiAoIXN0YXJ0TWV0YSB8fCAhZW5kTWV0YSkgeyAvLyBUT0RPOiB3YXJuaW5nP1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBkYXRlRW52LmZvcm1hdFJhbmdlKHN0YXJ0TWV0YS5tYXJrZXIsIGVuZE1ldGEubWFya2VyLCBmb3JtYXR0ZXIsIHtcbiAgICAgICAgZm9yY2VkU3RhcnRUem86IHN0YXJ0TWV0YS5mb3JjZWRUem8sXG4gICAgICAgIGZvcmNlZEVuZFR6bzogZW5kTWV0YS5mb3JjZWRUem8sXG4gICAgICAgIGlzRW5kRXhjbHVzaXZlOiBvcHRpb25zLmlzRW5kRXhjbHVzaXZlLFxuICAgICAgICBkZWZhdWx0U2VwYXJhdG9yOiBCQVNFX09QVElPTl9ERUZBVUxUUy5kZWZhdWx0UmFuZ2VTZXBhcmF0b3IsXG4gICAgfSk7XG59XG4vLyBUT0RPOiBtb3JlIERSWSBhbmQgb3B0aW1pemVkXG5mdW5jdGlvbiBidWlsZERhdGVFbnYoc2V0dGluZ3MpIHtcbiAgICBsZXQgbG9jYWxlID0gYnVpbGRMb2NhbGUoc2V0dGluZ3MubG9jYWxlIHx8ICdlbicsIG9yZ2FuaXplUmF3TG9jYWxlcyhbXSkubWFwKTsgLy8gVE9ETzogZG9uJ3QgaGFyZGNvZGUgJ2VuJyBldmVyeXdoZXJlXG4gICAgcmV0dXJuIG5ldyBEYXRlRW52KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IHRpbWVab25lOiBCQVNFX09QVElPTl9ERUZBVUxUUy50aW1lWm9uZSwgY2FsZW5kYXJTeXN0ZW06ICdncmVnb3J5JyB9LCBzZXR0aW5ncyksIHsgbG9jYWxlIH0pKTtcbn1cblxuLy8gSEVMUEVSU1xuLypcbmlmIG5leHREYXlUaHJlc2hvbGQgaXMgc3BlY2lmaWVkLCBzbGljaW5nIGlzIGRvbmUgaW4gYW4gYWxsLWRheSBmYXNoaW9uLlxueW91IGNhbiBnZXQgbmV4dERheVRocmVzaG9sZCBmcm9tIGNvbnRleHQubmV4dERheVRocmVzaG9sZFxuKi9cbmZ1bmN0aW9uIHNsaWNlRXZlbnRzKHByb3BzLCBhbGxEYXkpIHtcbiAgICByZXR1cm4gc2xpY2VFdmVudFN0b3JlKHByb3BzLmV2ZW50U3RvcmUsIHByb3BzLmV2ZW50VWlCYXNlcywgcHJvcHMuZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UsIGFsbERheSA/IHByb3BzLm5leHREYXlUaHJlc2hvbGQgOiBudWxsKS5mZztcbn1cblxuY29uc3QgdmVyc2lvbiA9ICc2LjEuMTUnO1xuXG5leHBvcnQgeyBDYWxlbmRhciwgY3JlYXRlUGx1Z2luLCBmb3JtYXREYXRlLCBmb3JtYXRSYW5nZSwgZ2xvYmFsTG9jYWxlcywgZ2xvYmFsUGx1Z2lucywgc2xpY2VFdmVudHMsIHZlcnNpb24gfTtcbiIsICJpbXBvcnQgeyBEYXRlQ29tcG9uZW50LCBnZXRTdGlja3lIZWFkZXJEYXRlcywgVmlld0NvbnRhaW5lciwgU2ltcGxlU2Nyb2xsR3JpZCwgZ2V0U3RpY2t5Rm9vdGVyU2Nyb2xsYmFyLCByZW5kZXJTY3JvbGxTaGltLCBjcmVhdGVGb3JtYXR0ZXIsIEJhc2VDb21wb25lbnQsIFN0YW5kYXJkRXZlbnQsIGJ1aWxkU2VnVGltZVRleHQsIEV2ZW50Q29udGFpbmVyLCBnZXRTZWdBbmNob3JBdHRycywgbWVtb2l6ZSwgTW9yZUxpbmtDb250YWluZXIsIGdldFNlZ01ldGEsIGdldFVuaXF1ZURvbUlkLCBzZXRSZWYsIERheUNlbGxDb250YWluZXIsIFdlZWtOdW1iZXJDb250YWluZXIsIGJ1aWxkTmF2TGlua0F0dHJzLCBoYXNDdXN0b21EYXlDZWxsQ29udGVudCwgYWRkTXMsIGludGVyc2VjdFJhbmdlcywgYWRkRGF5cywgU2VnSGllcmFyY2h5LCBidWlsZEVudHJ5S2V5LCBpbnRlcnNlY3RTcGFucywgUmVmTWFwLCBzb3J0RXZlbnRTZWdzLCBpc1Byb3BzRXF1YWwsIGJ1aWxkRXZlbnRSYW5nZUtleSwgQmdFdmVudCwgcmVuZGVyRmlsbCwgUG9zaXRpb25DYWNoZSwgTm93VGltZXIsIGZvcm1hdElzb01vbnRoU3RyLCBmb3JtYXREYXlTdHJpbmcsIFNsaWNlciwgRGF5SGVhZGVyLCBEYXlTZXJpZXNNb2RlbCwgRGF5VGFibGVNb2RlbCwgRGF0ZVByb2ZpbGVHZW5lcmF0b3IsIGFkZFdlZWtzLCBkaWZmV2Vla3MsIGluamVjdFN0eWxlcyB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29yZS9pbnRlcm5hbC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVSZWYsIGNyZWF0ZUVsZW1lbnQsIEZyYWdtZW50IH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb3JlL3ByZWFjdC5qcyc7XG5cbi8qIEFuIGFic3RyYWN0IGNsYXNzIGZvciB0aGUgZGF5Z3JpZCB2aWV3cywgYXMgd2VsbCBhcyBtb250aCB2aWV3LiBSZW5kZXJzIG9uZSBvciBtb3JlIHJvd3Mgb2YgZGF5IGNlbGxzLlxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vLyBJdCBpcyBhIG1hbmFnZXIgZm9yIGEgVGFibGUgc3ViY29tcG9uZW50LCB3aGljaCBkb2VzIG1vc3Qgb2YgdGhlIGhlYXZ5IGxpZnRpbmcuXG4vLyBJdCBpcyByZXNwb25zaWJsZSBmb3IgbWFuYWdpbmcgd2lkdGgvaGVpZ2h0LlxuY2xhc3MgVGFibGVWaWV3IGV4dGVuZHMgRGF0ZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuaGVhZGVyRWxSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICB9XG4gICAgcmVuZGVyU2ltcGxlTGF5b3V0KGhlYWRlclJvd0NvbnRlbnQsIGJvZHlDb250ZW50KSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBsZXQgc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgbGV0IHN0aWNreUhlYWRlckRhdGVzID0gZ2V0U3RpY2t5SGVhZGVyRGF0ZXMoY29udGV4dC5vcHRpb25zKTtcbiAgICAgICAgaWYgKGhlYWRlclJvd0NvbnRlbnQpIHtcbiAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdoZWFkZXInLFxuICAgICAgICAgICAgICAgIGtleTogJ2hlYWRlcicsXG4gICAgICAgICAgICAgICAgaXNTdGlja3k6IHN0aWNreUhlYWRlckRhdGVzLFxuICAgICAgICAgICAgICAgIGNodW5rOiB7XG4gICAgICAgICAgICAgICAgICAgIGVsUmVmOiB0aGlzLmhlYWRlckVsUmVmLFxuICAgICAgICAgICAgICAgICAgICB0YWJsZUNsYXNzTmFtZTogJ2ZjLWNvbC1oZWFkZXInLFxuICAgICAgICAgICAgICAgICAgICByb3dDb250ZW50OiBoZWFkZXJSb3dDb250ZW50LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdib2R5JyxcbiAgICAgICAgICAgIGtleTogJ2JvZHknLFxuICAgICAgICAgICAgbGlxdWlkOiB0cnVlLFxuICAgICAgICAgICAgY2h1bms6IHsgY29udGVudDogYm9keUNvbnRlbnQgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChWaWV3Q29udGFpbmVyLCB7IGVsQ2xhc3NlczogWydmYy1kYXlncmlkJ10sIHZpZXdTcGVjOiBjb250ZXh0LnZpZXdTcGVjIH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFNpbXBsZVNjcm9sbEdyaWQsIHsgbGlxdWlkOiAhcHJvcHMuaXNIZWlnaHRBdXRvICYmICFwcm9wcy5mb3JQcmludCwgY29sbGFwc2libGVXaWR0aDogcHJvcHMuZm9yUHJpbnQsIGNvbHM6IFtdIC8qIFRPRE86IG1ha2Ugb3B0aW9uYWw/ICovLCBzZWN0aW9uczogc2VjdGlvbnMgfSkpKTtcbiAgICB9XG4gICAgcmVuZGVySFNjcm9sbExheW91dChoZWFkZXJSb3dDb250ZW50LCBib2R5Q29udGVudCwgY29sQ250LCBkYXlNaW5XaWR0aCkge1xuICAgICAgICBsZXQgU2Nyb2xsR3JpZCA9IHRoaXMuY29udGV4dC5wbHVnaW5Ib29rcy5zY3JvbGxHcmlkSW1wbDtcbiAgICAgICAgaWYgKCFTY3JvbGxHcmlkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIFNjcm9sbEdyaWQgaW1wbGVtZW50YXRpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHN0aWNreUhlYWRlckRhdGVzID0gIXByb3BzLmZvclByaW50ICYmIGdldFN0aWNreUhlYWRlckRhdGVzKGNvbnRleHQub3B0aW9ucyk7XG4gICAgICAgIGxldCBzdGlja3lGb290ZXJTY3JvbGxiYXIgPSAhcHJvcHMuZm9yUHJpbnQgJiYgZ2V0U3RpY2t5Rm9vdGVyU2Nyb2xsYmFyKGNvbnRleHQub3B0aW9ucyk7XG4gICAgICAgIGxldCBzZWN0aW9ucyA9IFtdO1xuICAgICAgICBpZiAoaGVhZGVyUm93Q29udGVudCkge1xuICAgICAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2hlYWRlcicsXG4gICAgICAgICAgICAgICAga2V5OiAnaGVhZGVyJyxcbiAgICAgICAgICAgICAgICBpc1N0aWNreTogc3RpY2t5SGVhZGVyRGF0ZXMsXG4gICAgICAgICAgICAgICAgY2h1bmtzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAnbWFpbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbFJlZjogdGhpcy5oZWFkZXJFbFJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlQ2xhc3NOYW1lOiAnZmMtY29sLWhlYWRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dDb250ZW50OiBoZWFkZXJSb3dDb250ZW50LFxuICAgICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ2JvZHknLFxuICAgICAgICAgICAga2V5OiAnYm9keScsXG4gICAgICAgICAgICBsaXF1aWQ6IHRydWUsXG4gICAgICAgICAgICBjaHVua3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIGtleTogJ21haW4nLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBib2R5Q29udGVudCxcbiAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzdGlja3lGb290ZXJTY3JvbGxiYXIpIHtcbiAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdmb290ZXInLFxuICAgICAgICAgICAgICAgIGtleTogJ2Zvb3RlcicsXG4gICAgICAgICAgICAgICAgaXNTdGlja3k6IHRydWUsXG4gICAgICAgICAgICAgICAgY2h1bmtzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAnbWFpbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiByZW5kZXJTY3JvbGxTaGltLFxuICAgICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChWaWV3Q29udGFpbmVyLCB7IGVsQ2xhc3NlczogWydmYy1kYXlncmlkJ10sIHZpZXdTcGVjOiBjb250ZXh0LnZpZXdTcGVjIH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFNjcm9sbEdyaWQsIHsgbGlxdWlkOiAhcHJvcHMuaXNIZWlnaHRBdXRvICYmICFwcm9wcy5mb3JQcmludCwgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50LCBjb2xsYXBzaWJsZVdpZHRoOiBwcm9wcy5mb3JQcmludCwgY29sR3JvdXBzOiBbeyBjb2xzOiBbeyBzcGFuOiBjb2xDbnQsIG1pbldpZHRoOiBkYXlNaW5XaWR0aCB9XSB9XSwgc2VjdGlvbnM6IHNlY3Rpb25zIH0pKSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzcGxpdFNlZ3NCeVJvdyhzZWdzLCByb3dDbnQpIHtcbiAgICBsZXQgYnlSb3cgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd0NudDsgaSArPSAxKSB7XG4gICAgICAgIGJ5Um93W2ldID0gW107XG4gICAgfVxuICAgIGZvciAobGV0IHNlZyBvZiBzZWdzKSB7XG4gICAgICAgIGJ5Um93W3NlZy5yb3ddLnB1c2goc2VnKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5Um93O1xufVxuZnVuY3Rpb24gc3BsaXRTZWdzQnlGaXJzdENvbChzZWdzLCBjb2xDbnQpIHtcbiAgICBsZXQgYnlDb2wgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbENudDsgaSArPSAxKSB7XG4gICAgICAgIGJ5Q29sW2ldID0gW107XG4gICAgfVxuICAgIGZvciAobGV0IHNlZyBvZiBzZWdzKSB7XG4gICAgICAgIGJ5Q29sW3NlZy5maXJzdENvbF0ucHVzaChzZWcpO1xuICAgIH1cbiAgICByZXR1cm4gYnlDb2w7XG59XG5mdW5jdGlvbiBzcGxpdEludGVyYWN0aW9uQnlSb3codWksIHJvd0NudCkge1xuICAgIGxldCBieVJvdyA9IFtdO1xuICAgIGlmICghdWkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dDbnQ7IGkgKz0gMSkge1xuICAgICAgICAgICAgYnlSb3dbaV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd0NudDsgaSArPSAxKSB7XG4gICAgICAgICAgICBieVJvd1tpXSA9IHtcbiAgICAgICAgICAgICAgICBhZmZlY3RlZEluc3RhbmNlczogdWkuYWZmZWN0ZWRJbnN0YW5jZXMsXG4gICAgICAgICAgICAgICAgaXNFdmVudDogdWkuaXNFdmVudCxcbiAgICAgICAgICAgICAgICBzZWdzOiBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgc2VnIG9mIHVpLnNlZ3MpIHtcbiAgICAgICAgICAgIGJ5Um93W3NlZy5yb3ddLnNlZ3MucHVzaChzZWcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBieVJvdztcbn1cblxuY29uc3QgREVGQVVMVF9UQUJMRV9FVkVOVF9USU1FX0ZPUk1BVCA9IGNyZWF0ZUZvcm1hdHRlcih7XG4gICAgaG91cjogJ251bWVyaWMnLFxuICAgIG1pbnV0ZTogJzItZGlnaXQnLFxuICAgIG9taXRaZXJvTWludXRlOiB0cnVlLFxuICAgIG1lcmlkaWVtOiAnbmFycm93Jyxcbn0pO1xuZnVuY3Rpb24gaGFzTGlzdEl0ZW1EaXNwbGF5KHNlZykge1xuICAgIGxldCB7IGRpc3BsYXkgfSA9IHNlZy5ldmVudFJhbmdlLnVpO1xuICAgIHJldHVybiBkaXNwbGF5ID09PSAnbGlzdC1pdGVtJyB8fCAoZGlzcGxheSA9PT0gJ2F1dG8nICYmXG4gICAgICAgICFzZWcuZXZlbnRSYW5nZS5kZWYuYWxsRGF5ICYmXG4gICAgICAgIHNlZy5maXJzdENvbCA9PT0gc2VnLmxhc3RDb2wgJiYgLy8gY2FuJ3QgYmUgbXVsdGktZGF5XG4gICAgICAgIHNlZy5pc1N0YXJ0ICYmIC8vIFwiXG4gICAgICAgIHNlZy5pc0VuZCAvLyBcIlxuICAgICk7XG59XG5cbmNsYXNzIFRhYmxlQmxvY2tFdmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChTdGFuZGFyZEV2ZW50LCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcywgeyBlbENsYXNzZXM6IFsnZmMtZGF5Z3JpZC1ldmVudCcsICdmYy1kYXlncmlkLWJsb2NrLWV2ZW50JywgJ2ZjLWgtZXZlbnQnXSwgZGVmYXVsdFRpbWVGb3JtYXQ6IERFRkFVTFRfVEFCTEVfRVZFTlRfVElNRV9GT1JNQVQsIGRlZmF1bHREaXNwbGF5RXZlbnRFbmQ6IHByb3BzLmRlZmF1bHREaXNwbGF5RXZlbnRFbmQsIGRpc2FibGVSZXNpemluZzogIXByb3BzLnNlZy5ldmVudFJhbmdlLmRlZi5hbGxEYXkgfSkpKTtcbiAgICB9XG59XG5cbmNsYXNzIFRhYmxlTGlzdEl0ZW1FdmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgICAgIGxldCB7IHNlZyB9ID0gcHJvcHM7XG4gICAgICAgIGxldCB0aW1lRm9ybWF0ID0gb3B0aW9ucy5ldmVudFRpbWVGb3JtYXQgfHwgREVGQVVMVF9UQUJMRV9FVkVOVF9USU1FX0ZPUk1BVDtcbiAgICAgICAgbGV0IHRpbWVUZXh0ID0gYnVpbGRTZWdUaW1lVGV4dChzZWcsIHRpbWVGb3JtYXQsIGNvbnRleHQsIHRydWUsIHByb3BzLmRlZmF1bHREaXNwbGF5RXZlbnRFbmQpO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRXZlbnRDb250YWluZXIsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCB7IGVsVGFnOiBcImFcIiwgZWxDbGFzc2VzOiBbJ2ZjLWRheWdyaWQtZXZlbnQnLCAnZmMtZGF5Z3JpZC1kb3QtZXZlbnQnXSwgZWxBdHRyczogZ2V0U2VnQW5jaG9yQXR0cnMocHJvcHMuc2VnLCBjb250ZXh0KSwgZGVmYXVsdEdlbmVyYXRvcjogcmVuZGVySW5uZXJDb250ZW50LCB0aW1lVGV4dDogdGltZVRleHQsIGlzUmVzaXppbmc6IGZhbHNlLCBpc0RhdGVTZWxlY3Rpbmc6IGZhbHNlIH0pKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVuZGVySW5uZXJDb250ZW50KHJlbmRlclByb3BzKSB7XG4gICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLFxuICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZXZlbnQtZG90XCIsIHN0eWxlOiB7IGJvcmRlckNvbG9yOiByZW5kZXJQcm9wcy5ib3JkZXJDb2xvciB8fCByZW5kZXJQcm9wcy5iYWNrZ3JvdW5kQ29sb3IgfSB9KSxcbiAgICAgICAgcmVuZGVyUHJvcHMudGltZVRleHQgJiYgKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZXZlbnQtdGltZVwiIH0sIHJlbmRlclByb3BzLnRpbWVUZXh0KSksXG4gICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZXZlbnQtdGl0bGVcIiB9LCByZW5kZXJQcm9wcy5ldmVudC50aXRsZSB8fCBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBcIlxcdTAwQTBcIikpKSk7XG59XG5cbmNsYXNzIFRhYmxlQ2VsbE1vcmVMaW5rIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuY29tcGlsZVNlZ3MgPSBtZW1vaXplKGNvbXBpbGVTZWdzKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgYWxsU2VncywgaW52aXNpYmxlU2VncyB9ID0gdGhpcy5jb21waWxlU2Vncyhwcm9wcy5zaW5nbGVQbGFjZW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KE1vcmVMaW5rQ29udGFpbmVyLCB7IGVsQ2xhc3NlczogWydmYy1kYXlncmlkLW1vcmUtbGluayddLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsIGFsbERheURhdGU6IHByb3BzLmFsbERheURhdGUsIG1vcmVDbnQ6IHByb3BzLm1vcmVDbnQsIGFsbFNlZ3M6IGFsbFNlZ3MsIGhpZGRlblNlZ3M6IGludmlzaWJsZVNlZ3MsIGFsaWdubWVudEVsUmVmOiBwcm9wcy5hbGlnbm1lbnRFbFJlZiwgYWxpZ25HcmlkVG9wOiBwcm9wcy5hbGlnbkdyaWRUb3AsIGV4dHJhRGF0ZVNwYW46IHByb3BzLmV4dHJhRGF0ZVNwYW4sIHBvcG92ZXJDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGlzRm9yY2VkSW52aXNpYmxlID0gKHByb3BzLmV2ZW50RHJhZyA/IHByb3BzLmV2ZW50RHJhZy5hZmZlY3RlZEluc3RhbmNlcyA6IG51bGwpIHx8XG4gICAgICAgICAgICAgICAgICAgIChwcm9wcy5ldmVudFJlc2l6ZSA/IHByb3BzLmV2ZW50UmVzaXplLmFmZmVjdGVkSW5zdGFuY2VzIDogbnVsbCkgfHxcbiAgICAgICAgICAgICAgICAgICAge307XG4gICAgICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBhbGxTZWdzLm1hcCgoc2VnKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbnN0YW5jZUlkID0gc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZXZlbnQtaGFybmVzc1wiLCBrZXk6IGluc3RhbmNlSWQsIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogaXNGb3JjZWRJbnZpc2libGVbaW5zdGFuY2VJZF0gPyAnaGlkZGVuJyA6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSB9LCBoYXNMaXN0SXRlbURpc3BsYXkoc2VnKSA/IChjcmVhdGVFbGVtZW50KFRhYmxlTGlzdEl0ZW1FdmVudCwgT2JqZWN0LmFzc2lnbih7IHNlZzogc2VnLCBpc0RyYWdnaW5nOiBmYWxzZSwgaXNTZWxlY3RlZDogaW5zdGFuY2VJZCA9PT0gcHJvcHMuZXZlbnRTZWxlY3Rpb24sIGRlZmF1bHREaXNwbGF5RXZlbnRFbmQ6IGZhbHNlIH0sIGdldFNlZ01ldGEoc2VnLCBwcm9wcy50b2RheVJhbmdlKSkpKSA6IChjcmVhdGVFbGVtZW50KFRhYmxlQmxvY2tFdmVudCwgT2JqZWN0LmFzc2lnbih7IHNlZzogc2VnLCBpc0RyYWdnaW5nOiBmYWxzZSwgaXNSZXNpemluZzogZmFsc2UsIGlzRGF0ZVNlbGVjdGluZzogZmFsc2UsIGlzU2VsZWN0ZWQ6IGluc3RhbmNlSWQgPT09IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBkZWZhdWx0RGlzcGxheUV2ZW50RW5kOiBmYWxzZSB9LCBnZXRTZWdNZXRhKHNlZywgcHJvcHMudG9kYXlSYW5nZSkpKSkpKTtcbiAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgfSB9KSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcGlsZVNlZ3Moc2luZ2xlUGxhY2VtZW50cykge1xuICAgIGxldCBhbGxTZWdzID0gW107XG4gICAgbGV0IGludmlzaWJsZVNlZ3MgPSBbXTtcbiAgICBmb3IgKGxldCBwbGFjZW1lbnQgb2Ygc2luZ2xlUGxhY2VtZW50cykge1xuICAgICAgICBhbGxTZWdzLnB1c2gocGxhY2VtZW50LnNlZyk7XG4gICAgICAgIGlmICghcGxhY2VtZW50LmlzVmlzaWJsZSkge1xuICAgICAgICAgICAgaW52aXNpYmxlU2Vncy5wdXNoKHBsYWNlbWVudC5zZWcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGFsbFNlZ3MsIGludmlzaWJsZVNlZ3MgfTtcbn1cblxuY29uc3QgREVGQVVMVF9XRUVLX05VTV9GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoeyB3ZWVrOiAnbmFycm93JyB9KTtcbmNsYXNzIFRhYmxlQ2VsbCBleHRlbmRzIERhdGVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnJvb3RFbFJlZiA9IGNyZWF0ZVJlZigpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgZGF5TnVtYmVySWQ6IGdldFVuaXF1ZURvbUlkKCksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUm9vdEVsID0gKGVsKSA9PiB7XG4gICAgICAgICAgICBzZXRSZWYodGhpcy5yb290RWxSZWYsIGVsKTtcbiAgICAgICAgICAgIHNldFJlZih0aGlzLnByb3BzLmVsUmVmLCBlbCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgY29udGV4dCwgcHJvcHMsIHN0YXRlLCByb290RWxSZWYgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IG9wdGlvbnMsIGRhdGVFbnYgfSA9IGNvbnRleHQ7XG4gICAgICAgIGxldCB7IGRhdGUsIGRhdGVQcm9maWxlIH0gPSBwcm9wcztcbiAgICAgICAgLy8gVE9ETzogbWVtb2l6ZSB0aGlzP1xuICAgICAgICBjb25zdCBpc01vbnRoU3RhcnQgPSBwcm9wcy5zaG93RGF5TnVtYmVyICYmXG4gICAgICAgICAgICBzaG91bGREaXNwbGF5TW9udGhTdGFydChkYXRlLCBkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2UsIGRhdGVFbnYpO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRGF5Q2VsbENvbnRhaW5lciwgeyBlbFRhZzogXCJ0ZFwiLCBlbFJlZjogdGhpcy5oYW5kbGVSb290RWwsIGVsQ2xhc3NlczogW1xuICAgICAgICAgICAgICAgICdmYy1kYXlncmlkLWRheScsXG4gICAgICAgICAgICAgICAgLi4uKHByb3BzLmV4dHJhQ2xhc3NOYW1lcyB8fCBbXSksXG4gICAgICAgICAgICBdLCBlbEF0dHJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMuZXh0cmFEYXRhQXR0cnMpLCAocHJvcHMuc2hvd0RheU51bWJlciA/IHsgJ2FyaWEtbGFiZWxsZWRieSc6IHN0YXRlLmRheU51bWJlcklkIH0gOiB7fSkpLCB7IHJvbGU6ICdncmlkY2VsbCcgfSksIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlclRvcElubmVyLCBkYXRlOiBkYXRlLCBkYXRlUHJvZmlsZTogZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsIHNob3dEYXlOdW1iZXI6IHByb3BzLnNob3dEYXlOdW1iZXIsIGlzTW9udGhTdGFydDogaXNNb250aFN0YXJ0LCBleHRyYVJlbmRlclByb3BzOiBwcm9wcy5leHRyYVJlbmRlclByb3BzIH0sIChJbm5lckNvbnRlbnQsIHJlbmRlclByb3BzKSA9PiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogcHJvcHMuaW5uZXJFbFJlZiwgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZGF5LWZyYW1lIGZjLXNjcm9sbGdyaWQtc3luYy1pbm5lclwiLCBzdHlsZTogeyBtaW5IZWlnaHQ6IHByb3BzLm1pbkhlaWdodCB9IH0sXG4gICAgICAgICAgICBwcm9wcy5zaG93V2Vla051bWJlciAmJiAoY3JlYXRlRWxlbWVudChXZWVrTnVtYmVyQ29udGFpbmVyLCB7IGVsVGFnOiBcImFcIiwgZWxDbGFzc2VzOiBbJ2ZjLWRheWdyaWQtd2Vlay1udW1iZXInXSwgZWxBdHRyczogYnVpbGROYXZMaW5rQXR0cnMoY29udGV4dCwgZGF0ZSwgJ3dlZWsnKSwgZGF0ZTogZGF0ZSwgZGVmYXVsdEZvcm1hdDogREVGQVVMVF9XRUVLX05VTV9GT1JNQVQgfSkpLFxuICAgICAgICAgICAgIXJlbmRlclByb3BzLmlzRGlzYWJsZWQgJiZcbiAgICAgICAgICAgICAgICAocHJvcHMuc2hvd0RheU51bWJlciB8fCBoYXNDdXN0b21EYXlDZWxsQ29udGVudChvcHRpb25zKSB8fCBwcm9wcy5mb3JjZURheVRvcCkgPyAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWRheS10b3BcIiB9LFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoSW5uZXJDb250ZW50LCB7IGVsVGFnOiBcImFcIiwgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmMtZGF5Z3JpZC1kYXktbnVtYmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzTW9udGhTdGFydCAmJiAnZmMtZGF5Z3JpZC1tb250aC1zdGFydCcsXG4gICAgICAgICAgICAgICAgICAgIF0sIGVsQXR0cnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYnVpbGROYXZMaW5rQXR0cnMoY29udGV4dCwgZGF0ZSkpLCB7IGlkOiBzdGF0ZS5kYXlOdW1iZXJJZCB9KSB9KSkpIDogcHJvcHMuc2hvd0RheU51bWJlciA/IChcbiAgICAgICAgICAgIC8vIGZvciBjcmVhdGluZyBjb3JyZWN0IGFtb3VudCBvZiBzcGFjZSAoc2VlIGlzc3VlICM3MTYyKVxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWRheS10b3BcIiwgc3R5bGU6IHsgdmlzaWJpbGl0eTogJ2hpZGRlbicgfSB9LFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJhXCIsIHsgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZGF5LW51bWJlclwiIH0sIFwiXFx1MDBBMFwiKSkpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWRheS1ldmVudHNcIiwgcmVmOiBwcm9wcy5mZ0NvbnRlbnRFbFJlZiB9LFxuICAgICAgICAgICAgICAgIHByb3BzLmZnQ29udGVudCxcbiAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZGF5LWJvdHRvbVwiLCBzdHlsZTogeyBtYXJnaW5Ub3A6IHByb3BzLm1vcmVNYXJnaW5Ub3AgfSB9LFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFRhYmxlQ2VsbE1vcmVMaW5rLCB7IGFsbERheURhdGU6IGRhdGUsIHNpbmdsZVBsYWNlbWVudHM6IHByb3BzLnNpbmdsZVBsYWNlbWVudHMsIG1vcmVDbnQ6IHByb3BzLm1vcmVDbnQsIGFsaWdubWVudEVsUmVmOiByb290RWxSZWYsIGFsaWduR3JpZFRvcDogIXByb3BzLnNob3dEYXlOdW1iZXIsIGV4dHJhRGF0ZVNwYW46IHByb3BzLmV4dHJhRGF0ZVNwYW4sIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBldmVudERyYWc6IHByb3BzLmV2ZW50RHJhZywgZXZlbnRSZXNpemU6IHByb3BzLmV2ZW50UmVzaXplLCB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlIH0pKSksXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZGF5LWJnXCIgfSwgcHJvcHMuYmdDb250ZW50KSkpKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVuZGVyVG9wSW5uZXIocHJvcHMpIHtcbiAgICByZXR1cm4gcHJvcHMuZGF5TnVtYmVyVGV4dCB8fCBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBcIlxcdTAwQTBcIik7XG59XG5mdW5jdGlvbiBzaG91bGREaXNwbGF5TW9udGhTdGFydChkYXRlLCBjdXJyZW50UmFuZ2UsIGRhdGVFbnYpIHtcbiAgICBjb25zdCB7IHN0YXJ0OiBjdXJyZW50U3RhcnQsIGVuZDogY3VycmVudEVuZCB9ID0gY3VycmVudFJhbmdlO1xuICAgIGNvbnN0IGN1cnJlbnRFbmRJbmNsID0gYWRkTXMoY3VycmVudEVuZCwgLTEpO1xuICAgIGNvbnN0IGN1cnJlbnRGaXJzdFllYXIgPSBkYXRlRW52LmdldFllYXIoY3VycmVudFN0YXJ0KTtcbiAgICBjb25zdCBjdXJyZW50Rmlyc3RNb250aCA9IGRhdGVFbnYuZ2V0TW9udGgoY3VycmVudFN0YXJ0KTtcbiAgICBjb25zdCBjdXJyZW50TGFzdFllYXIgPSBkYXRlRW52LmdldFllYXIoY3VycmVudEVuZEluY2wpO1xuICAgIGNvbnN0IGN1cnJlbnRMYXN0TW9udGggPSBkYXRlRW52LmdldE1vbnRoKGN1cnJlbnRFbmRJbmNsKTtcbiAgICAvLyBzcGFucyBtb3JlIHRoYW4gb25lIG1vbnRoP1xuICAgIHJldHVybiAhKGN1cnJlbnRGaXJzdFllYXIgPT09IGN1cnJlbnRMYXN0WWVhciAmJiBjdXJyZW50Rmlyc3RNb250aCA9PT0gY3VycmVudExhc3RNb250aCkgJiZcbiAgICAgICAgQm9vbGVhbihcbiAgICAgICAgLy8gZmlyc3QgZGF0ZSBpbiBjdXJyZW50IHZpZXc/XG4gICAgICAgIGRhdGUudmFsdWVPZigpID09PSBjdXJyZW50U3RhcnQudmFsdWVPZigpIHx8XG4gICAgICAgICAgICAvLyBhIG1vbnRoLXN0YXJ0IHRoYXQncyB3aXRoaW4gdGhlIGN1cnJlbnQgcmFuZ2U/XG4gICAgICAgICAgICAoZGF0ZUVudi5nZXREYXkoZGF0ZSkgPT09IDEgJiYgZGF0ZS52YWx1ZU9mKCkgPCBjdXJyZW50RW5kLnZhbHVlT2YoKSkpO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVNlZ0tleShzZWcpIHtcbiAgICByZXR1cm4gc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZCArICc6JyArIHNlZy5maXJzdENvbDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlU2VnVWlkKHNlZykge1xuICAgIHJldHVybiBnZW5lcmF0ZVNlZ0tleShzZWcpICsgJzonICsgc2VnLmxhc3RDb2w7XG59XG5mdW5jdGlvbiBjb21wdXRlRmdTZWdQbGFjZW1lbnQoc2VncywgLy8gYXNzdW1lZCBhbHJlYWR5IHNvcnRlZFxuZGF5TWF4RXZlbnRzLCBkYXlNYXhFdmVudFJvd3MsIHN0cmljdE9yZGVyLCBzZWdIZWlnaHRzLCBtYXhDb250ZW50SGVpZ2h0LCBjZWxscykge1xuICAgIGxldCBoaWVyYXJjaHkgPSBuZXcgRGF5R3JpZFNlZ0hpZXJhcmNoeSgoc2VnRW50cnkpID0+IHtcbiAgICAgICAgLy8gVE9ETzogbW9yZSBEUlkgd2l0aCBnZW5lcmF0ZVNlZ1VpZFxuICAgICAgICBsZXQgc2VnVWlkID0gc2Vnc1tzZWdFbnRyeS5pbmRleF0uZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkICtcbiAgICAgICAgICAgICc6JyArIHNlZ0VudHJ5LnNwYW4uc3RhcnQgK1xuICAgICAgICAgICAgJzonICsgKHNlZ0VudHJ5LnNwYW4uZW5kIC0gMSk7XG4gICAgICAgIC8vIGlmIG5vIHRoaWNrbmVzcyBrbm93biwgYXNzdW1lIDEgKGlmIDAsIHNvIHNtYWxsIGl0IGFsd2F5cyBmaXRzKVxuICAgICAgICByZXR1cm4gc2VnSGVpZ2h0c1tzZWdVaWRdIHx8IDE7XG4gICAgfSk7XG4gICAgaGllcmFyY2h5LmFsbG93UmVzbGljaW5nID0gdHJ1ZTtcbiAgICBoaWVyYXJjaHkuc3RyaWN0T3JkZXIgPSBzdHJpY3RPcmRlcjtcbiAgICBpZiAoZGF5TWF4RXZlbnRzID09PSB0cnVlIHx8IGRheU1heEV2ZW50Um93cyA9PT0gdHJ1ZSkge1xuICAgICAgICBoaWVyYXJjaHkubWF4Q29vcmQgPSBtYXhDb250ZW50SGVpZ2h0O1xuICAgICAgICBoaWVyYXJjaHkuaGlkZGVuQ29uc3VtZXMgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGF5TWF4RXZlbnRzID09PSAnbnVtYmVyJykge1xuICAgICAgICBoaWVyYXJjaHkubWF4U3RhY2tDbnQgPSBkYXlNYXhFdmVudHM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkYXlNYXhFdmVudFJvd3MgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGhpZXJhcmNoeS5tYXhTdGFja0NudCA9IGRheU1heEV2ZW50Um93cztcbiAgICAgICAgaGllcmFyY2h5LmhpZGRlbkNvbnN1bWVzID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gY3JlYXRlIHNlZ0lucHV0cyBvbmx5IGZvciBzZWdzIHdpdGgga25vd24gaGVpZ2h0c1xuICAgIGxldCBzZWdJbnB1dHMgPSBbXTtcbiAgICBsZXQgdW5rbm93bkhlaWdodFNlZ3MgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgbGV0IHNlZyA9IHNlZ3NbaV07XG4gICAgICAgIGxldCBzZWdVaWQgPSBnZW5lcmF0ZVNlZ1VpZChzZWcpO1xuICAgICAgICBsZXQgZXZlbnRIZWlnaHQgPSBzZWdIZWlnaHRzW3NlZ1VpZF07XG4gICAgICAgIGlmIChldmVudEhlaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZWdJbnB1dHMucHVzaCh7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgc3Bhbjoge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogc2VnLmZpcnN0Q29sLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IHNlZy5sYXN0Q29sICsgMSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1bmtub3duSGVpZ2h0U2Vncy5wdXNoKHNlZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGhpZGRlbkVudHJpZXMgPSBoaWVyYXJjaHkuYWRkU2VncyhzZWdJbnB1dHMpO1xuICAgIGxldCBzZWdSZWN0cyA9IGhpZXJhcmNoeS50b1JlY3RzKCk7XG4gICAgbGV0IHsgc2luZ2xlQ29sUGxhY2VtZW50cywgbXVsdGlDb2xQbGFjZW1lbnRzLCBsZWZ0b3Zlck1hcmdpbnMgfSA9IHBsYWNlUmVjdHMoc2VnUmVjdHMsIHNlZ3MsIGNlbGxzKTtcbiAgICBsZXQgbW9yZUNudHMgPSBbXTtcbiAgICBsZXQgbW9yZU1hcmdpblRvcHMgPSBbXTtcbiAgICAvLyBhZGQgc2VncyB3aXRoIHVua25vd24gaGVpZ2h0c1xuICAgIGZvciAobGV0IHNlZyBvZiB1bmtub3duSGVpZ2h0U2Vncykge1xuICAgICAgICBtdWx0aUNvbFBsYWNlbWVudHNbc2VnLmZpcnN0Q29sXS5wdXNoKHtcbiAgICAgICAgICAgIHNlZyxcbiAgICAgICAgICAgIGlzVmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICBpc0Fic29sdXRlOiB0cnVlLFxuICAgICAgICAgICAgYWJzb2x1dGVUb3A6IDAsXG4gICAgICAgICAgICBtYXJnaW5Ub3A6IDAsXG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGxldCBjb2wgPSBzZWcuZmlyc3RDb2w7IGNvbCA8PSBzZWcubGFzdENvbDsgY29sICs9IDEpIHtcbiAgICAgICAgICAgIHNpbmdsZUNvbFBsYWNlbWVudHNbY29sXS5wdXNoKHtcbiAgICAgICAgICAgICAgICBzZWc6IHJlc2xpY2VTZWcoc2VnLCBjb2wsIGNvbCArIDEsIGNlbGxzKSxcbiAgICAgICAgICAgICAgICBpc1Zpc2libGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzQWJzb2x1dGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGFic29sdXRlVG9wOiAwLFxuICAgICAgICAgICAgICAgIG1hcmdpblRvcDogMCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGFkZCB0aGUgaGlkZGVuIGVudHJpZXNcbiAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjZWxscy5sZW5ndGg7IGNvbCArPSAxKSB7XG4gICAgICAgIG1vcmVDbnRzLnB1c2goMCk7XG4gICAgfVxuICAgIGZvciAobGV0IGhpZGRlbkVudHJ5IG9mIGhpZGRlbkVudHJpZXMpIHtcbiAgICAgICAgbGV0IHNlZyA9IHNlZ3NbaGlkZGVuRW50cnkuaW5kZXhdO1xuICAgICAgICBsZXQgaGlkZGVuU3BhbiA9IGhpZGRlbkVudHJ5LnNwYW47XG4gICAgICAgIG11bHRpQ29sUGxhY2VtZW50c1toaWRkZW5TcGFuLnN0YXJ0XS5wdXNoKHtcbiAgICAgICAgICAgIHNlZzogcmVzbGljZVNlZyhzZWcsIGhpZGRlblNwYW4uc3RhcnQsIGhpZGRlblNwYW4uZW5kLCBjZWxscyksXG4gICAgICAgICAgICBpc1Zpc2libGU6IGZhbHNlLFxuICAgICAgICAgICAgaXNBYnNvbHV0ZTogdHJ1ZSxcbiAgICAgICAgICAgIGFic29sdXRlVG9wOiAwLFxuICAgICAgICAgICAgbWFyZ2luVG9wOiAwLFxuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChsZXQgY29sID0gaGlkZGVuU3Bhbi5zdGFydDsgY29sIDwgaGlkZGVuU3Bhbi5lbmQ7IGNvbCArPSAxKSB7XG4gICAgICAgICAgICBtb3JlQ250c1tjb2xdICs9IDE7XG4gICAgICAgICAgICBzaW5nbGVDb2xQbGFjZW1lbnRzW2NvbF0ucHVzaCh7XG4gICAgICAgICAgICAgICAgc2VnOiByZXNsaWNlU2VnKHNlZywgY29sLCBjb2wgKyAxLCBjZWxscyksXG4gICAgICAgICAgICAgICAgaXNWaXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc0Fic29sdXRlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhYnNvbHV0ZVRvcDogMCxcbiAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6IDAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBkZWFsIHdpdGggbGVmdG92ZXIgbWFyZ2luc1xuICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNlbGxzLmxlbmd0aDsgY29sICs9IDEpIHtcbiAgICAgICAgbW9yZU1hcmdpblRvcHMucHVzaChsZWZ0b3Zlck1hcmdpbnNbY29sXSk7XG4gICAgfVxuICAgIHJldHVybiB7IHNpbmdsZUNvbFBsYWNlbWVudHMsIG11bHRpQ29sUGxhY2VtZW50cywgbW9yZUNudHMsIG1vcmVNYXJnaW5Ub3BzIH07XG59XG4vLyByZWN0cyBvcmRlcmVkIGJ5IHRvcCBjb29yZCwgdGhlbiBsZWZ0XG5mdW5jdGlvbiBwbGFjZVJlY3RzKGFsbFJlY3RzLCBzZWdzLCBjZWxscykge1xuICAgIGxldCByZWN0c0J5RWFjaENvbCA9IGdyb3VwUmVjdHNCeUVhY2hDb2woYWxsUmVjdHMsIGNlbGxzLmxlbmd0aCk7XG4gICAgbGV0IHNpbmdsZUNvbFBsYWNlbWVudHMgPSBbXTtcbiAgICBsZXQgbXVsdGlDb2xQbGFjZW1lbnRzID0gW107XG4gICAgbGV0IGxlZnRvdmVyTWFyZ2lucyA9IFtdO1xuICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNlbGxzLmxlbmd0aDsgY29sICs9IDEpIHtcbiAgICAgICAgbGV0IHJlY3RzID0gcmVjdHNCeUVhY2hDb2xbY29sXTtcbiAgICAgICAgLy8gY29tcHV0ZSBhbGwgc3RhdGljIHNlZ3MgaW4gc2luZ2xlUGxhY2VtZW50c1xuICAgICAgICBsZXQgc2luZ2xlUGxhY2VtZW50cyA9IFtdO1xuICAgICAgICBsZXQgY3VycmVudEhlaWdodCA9IDA7XG4gICAgICAgIGxldCBjdXJyZW50TWFyZ2luVG9wID0gMDtcbiAgICAgICAgZm9yIChsZXQgcmVjdCBvZiByZWN0cykge1xuICAgICAgICAgICAgbGV0IHNlZyA9IHNlZ3NbcmVjdC5pbmRleF07XG4gICAgICAgICAgICBzaW5nbGVQbGFjZW1lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHNlZzogcmVzbGljZVNlZyhzZWcsIGNvbCwgY29sICsgMSwgY2VsbHMpLFxuICAgICAgICAgICAgICAgIGlzVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpc0Fic29sdXRlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhYnNvbHV0ZVRvcDogcmVjdC5sZXZlbENvb3JkLFxuICAgICAgICAgICAgICAgIG1hcmdpblRvcDogcmVjdC5sZXZlbENvb3JkIC0gY3VycmVudEhlaWdodCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY3VycmVudEhlaWdodCA9IHJlY3QubGV2ZWxDb29yZCArIHJlY3QudGhpY2tuZXNzO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbXB1dGUgbWl4ZWQgc3RhdGljL2Fic29sdXRlIHNlZ3MgaW4gbXVsdGlQbGFjZW1lbnRzXG4gICAgICAgIGxldCBtdWx0aVBsYWNlbWVudHMgPSBbXTtcbiAgICAgICAgY3VycmVudEhlaWdodCA9IDA7XG4gICAgICAgIGN1cnJlbnRNYXJnaW5Ub3AgPSAwO1xuICAgICAgICBmb3IgKGxldCByZWN0IG9mIHJlY3RzKSB7XG4gICAgICAgICAgICBsZXQgc2VnID0gc2Vnc1tyZWN0LmluZGV4XTtcbiAgICAgICAgICAgIGxldCBpc0Fic29sdXRlID0gcmVjdC5zcGFuLmVuZCAtIHJlY3Quc3Bhbi5zdGFydCA+IDE7IC8vIG11bHRpLWNvbHVtbj9cbiAgICAgICAgICAgIGxldCBpc0ZpcnN0Q29sID0gcmVjdC5zcGFuLnN0YXJ0ID09PSBjb2w7XG4gICAgICAgICAgICBjdXJyZW50TWFyZ2luVG9wICs9IHJlY3QubGV2ZWxDb29yZCAtIGN1cnJlbnRIZWlnaHQ7IC8vIGFtb3VudCBvZiBzcGFjZSBzaW5jZSBib3R0b20gb2YgcHJldmlvdXMgc2VnXG4gICAgICAgICAgICBjdXJyZW50SGVpZ2h0ID0gcmVjdC5sZXZlbENvb3JkICsgcmVjdC50aGlja25lc3M7IC8vIGhlaWdodCB3aWxsIG5vdyBiZSBib3R0b20gb2YgY3VycmVudCBzZWdcbiAgICAgICAgICAgIGlmIChpc0Fic29sdXRlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudE1hcmdpblRvcCArPSByZWN0LnRoaWNrbmVzcztcbiAgICAgICAgICAgICAgICBpZiAoaXNGaXJzdENvbCkge1xuICAgICAgICAgICAgICAgICAgICBtdWx0aVBsYWNlbWVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWc6IHJlc2xpY2VTZWcoc2VnLCByZWN0LnNwYW4uc3RhcnQsIHJlY3Quc3Bhbi5lbmQsIGNlbGxzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQWJzb2x1dGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhYnNvbHV0ZVRvcDogcmVjdC5sZXZlbENvb3JkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luVG9wOiAwLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0ZpcnN0Q29sKSB7XG4gICAgICAgICAgICAgICAgbXVsdGlQbGFjZW1lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBzZWc6IHJlc2xpY2VTZWcoc2VnLCByZWN0LnNwYW4uc3RhcnQsIHJlY3Quc3Bhbi5lbmQsIGNlbGxzKSxcbiAgICAgICAgICAgICAgICAgICAgaXNWaXNpYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBpc0Fic29sdXRlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgYWJzb2x1dGVUb3A6IHJlY3QubGV2ZWxDb29yZCxcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luVG9wOiBjdXJyZW50TWFyZ2luVG9wLCAvLyBjbGFpbSB0aGUgbWFyZ2luXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY3VycmVudE1hcmdpblRvcCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2luZ2xlQ29sUGxhY2VtZW50cy5wdXNoKHNpbmdsZVBsYWNlbWVudHMpO1xuICAgICAgICBtdWx0aUNvbFBsYWNlbWVudHMucHVzaChtdWx0aVBsYWNlbWVudHMpO1xuICAgICAgICBsZWZ0b3Zlck1hcmdpbnMucHVzaChjdXJyZW50TWFyZ2luVG9wKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc2luZ2xlQ29sUGxhY2VtZW50cywgbXVsdGlDb2xQbGFjZW1lbnRzLCBsZWZ0b3Zlck1hcmdpbnMgfTtcbn1cbmZ1bmN0aW9uIGdyb3VwUmVjdHNCeUVhY2hDb2wocmVjdHMsIGNvbENudCkge1xuICAgIGxldCByZWN0c0J5RWFjaENvbCA9IFtdO1xuICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNvbENudDsgY29sICs9IDEpIHtcbiAgICAgICAgcmVjdHNCeUVhY2hDb2wucHVzaChbXSk7XG4gICAgfVxuICAgIGZvciAobGV0IHJlY3Qgb2YgcmVjdHMpIHtcbiAgICAgICAgZm9yIChsZXQgY29sID0gcmVjdC5zcGFuLnN0YXJ0OyBjb2wgPCByZWN0LnNwYW4uZW5kOyBjb2wgKz0gMSkge1xuICAgICAgICAgICAgcmVjdHNCeUVhY2hDb2xbY29sXS5wdXNoKHJlY3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZWN0c0J5RWFjaENvbDtcbn1cbmZ1bmN0aW9uIHJlc2xpY2VTZWcoc2VnLCBzcGFuU3RhcnQsIHNwYW5FbmQsIGNlbGxzKSB7XG4gICAgaWYgKHNlZy5maXJzdENvbCA9PT0gc3BhblN0YXJ0ICYmIHNlZy5sYXN0Q29sID09PSBzcGFuRW5kIC0gMSkge1xuICAgICAgICByZXR1cm4gc2VnO1xuICAgIH1cbiAgICBsZXQgZXZlbnRSYW5nZSA9IHNlZy5ldmVudFJhbmdlO1xuICAgIGxldCBvcmlnUmFuZ2UgPSBldmVudFJhbmdlLnJhbmdlO1xuICAgIGxldCBzbGljZWRSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhvcmlnUmFuZ2UsIHtcbiAgICAgICAgc3RhcnQ6IGNlbGxzW3NwYW5TdGFydF0uZGF0ZSxcbiAgICAgICAgZW5kOiBhZGREYXlzKGNlbGxzW3NwYW5FbmQgLSAxXS5kYXRlLCAxKSxcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzZWcpLCB7IGZpcnN0Q29sOiBzcGFuU3RhcnQsIGxhc3RDb2w6IHNwYW5FbmQgLSAxLCBldmVudFJhbmdlOiB7XG4gICAgICAgICAgICBkZWY6IGV2ZW50UmFuZ2UuZGVmLFxuICAgICAgICAgICAgdWk6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRSYW5nZS51aSksIHsgZHVyYXRpb25FZGl0YWJsZTogZmFsc2UgfSksXG4gICAgICAgICAgICBpbnN0YW5jZTogZXZlbnRSYW5nZS5pbnN0YW5jZSxcbiAgICAgICAgICAgIHJhbmdlOiBzbGljZWRSYW5nZSxcbiAgICAgICAgfSwgaXNTdGFydDogc2VnLmlzU3RhcnQgJiYgc2xpY2VkUmFuZ2Uuc3RhcnQudmFsdWVPZigpID09PSBvcmlnUmFuZ2Uuc3RhcnQudmFsdWVPZigpLCBpc0VuZDogc2VnLmlzRW5kICYmIHNsaWNlZFJhbmdlLmVuZC52YWx1ZU9mKCkgPT09IG9yaWdSYW5nZS5lbmQudmFsdWVPZigpIH0pO1xufVxuY2xhc3MgRGF5R3JpZFNlZ0hpZXJhcmNoeSBleHRlbmRzIFNlZ0hpZXJhcmNoeSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIC8vIGNvbmZpZ1xuICAgICAgICB0aGlzLmhpZGRlbkNvbnN1bWVzID0gZmFsc2U7XG4gICAgICAgIC8vIGFsbG93cyB1cyB0byBrZWVwIGhpZGRlbiBlbnRyaWVzIGluIHRoZSBoaWVyYXJjaHkgc28gdGhleSB0YWtlIHVwIHNwYWNlXG4gICAgICAgIHRoaXMuZm9yY2VIaWRkZW4gPSB7fTtcbiAgICB9XG4gICAgYWRkU2VncyhzZWdJbnB1dHMpIHtcbiAgICAgICAgY29uc3QgaGlkZGVuU2VncyA9IHN1cGVyLmFkZFNlZ3Moc2VnSW5wdXRzKTtcbiAgICAgICAgY29uc3QgeyBlbnRyaWVzQnlMZXZlbCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgZXhjbHVkZUhpZGRlbiA9IChlbnRyeSkgPT4gIXRoaXMuZm9yY2VIaWRkZW5bYnVpbGRFbnRyeUtleShlbnRyeSldO1xuICAgICAgICAvLyByZW1vdmUgdGhlIGZvcmNlZC1oaWRkZW4gc2Vnc1xuICAgICAgICBmb3IgKGxldCBsZXZlbCA9IDA7IGxldmVsIDwgZW50cmllc0J5TGV2ZWwubGVuZ3RoOyBsZXZlbCArPSAxKSB7XG4gICAgICAgICAgICBlbnRyaWVzQnlMZXZlbFtsZXZlbF0gPSBlbnRyaWVzQnlMZXZlbFtsZXZlbF0uZmlsdGVyKGV4Y2x1ZGVIaWRkZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoaWRkZW5TZWdzO1xuICAgIH1cbiAgICBoYW5kbGVJbnZhbGlkSW5zZXJ0aW9uKGluc2VydGlvbiwgZW50cnksIGhpZGRlbkVudHJpZXMpIHtcbiAgICAgICAgY29uc3QgeyBlbnRyaWVzQnlMZXZlbCwgZm9yY2VIaWRkZW4gfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgdG91Y2hpbmdFbnRyeSwgdG91Y2hpbmdMZXZlbCwgdG91Y2hpbmdMYXRlcmFsIH0gPSBpbnNlcnRpb247XG4gICAgICAgIC8vIHRoZSBlbnRyeSB0aGF0IHRoZSBuZXcgaW5zZXJ0aW9uIGlzIHRvdWNoaW5nIG11c3QgYmUgaGlkZGVuXG4gICAgICAgIGlmICh0aGlzLmhpZGRlbkNvbnN1bWVzICYmIHRvdWNoaW5nRW50cnkpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvdWNoaW5nRW50cnlJZCA9IGJ1aWxkRW50cnlLZXkodG91Y2hpbmdFbnRyeSk7XG4gICAgICAgICAgICBpZiAoIWZvcmNlSGlkZGVuW3RvdWNoaW5nRW50cnlJZF0pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hbGxvd1Jlc2xpY2luZykge1xuICAgICAgICAgICAgICAgICAgICAvLyBzcGxpdCB1cCB0aGUgdG91Y2hpbmdFbnRyeSwgcmVpbnNlcnQgaXRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGlkZGVuRW50cnkgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRvdWNoaW5nRW50cnkpLCB7IHNwYW46IGludGVyc2VjdFNwYW5zKHRvdWNoaW5nRW50cnkuc3BhbiwgZW50cnkuc3BhbikgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlaW5zZXJ0IHRoZSBhcmVhIHRoYXQgdHVybmVkIGludG8gYSBcIm1vcmVcIiBsaW5rIChzbyBubyBvdGhlciBlbnRyaWVzIHRyeSB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBvY2N1cHkgdGhlIHNwYWNlKSBidXQgbWFyayBpdCBmb3JjZWQtaGlkZGVuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhpZGRlbkVudHJ5SWQgPSBidWlsZEVudHJ5S2V5KGhpZGRlbkVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VIaWRkZW5baGlkZGVuRW50cnlJZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBlbnRyaWVzQnlMZXZlbFt0b3VjaGluZ0xldmVsXVt0b3VjaGluZ0xhdGVyYWxdID0gaGlkZGVuRW50cnk7XG4gICAgICAgICAgICAgICAgICAgIGhpZGRlbkVudHJpZXMucHVzaChoaWRkZW5FbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3BsaXRFbnRyeSh0b3VjaGluZ0VudHJ5LCBlbnRyeSwgaGlkZGVuRW50cmllcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3JjZUhpZGRlblt0b3VjaGluZ0VudHJ5SWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuRW50cmllcy5wdXNoKHRvdWNoaW5nRW50cnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB3aWxsIHRyeSB0byByZXNsaWNlLi4uXG4gICAgICAgIHN1cGVyLmhhbmRsZUludmFsaWRJbnNlcnRpb24oaW5zZXJ0aW9uLCBlbnRyeSwgaGlkZGVuRW50cmllcyk7XG4gICAgfVxufVxuXG5jbGFzcyBUYWJsZVJvdyBleHRlbmRzIERhdGVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmNlbGxFbFJlZnMgPSBuZXcgUmVmTWFwKCk7IC8vIHRoZSA8dGQ+XG4gICAgICAgIHRoaXMuZnJhbWVFbFJlZnMgPSBuZXcgUmVmTWFwKCk7IC8vIHRoZSBmYy1kYXlncmlkLWRheS1mcmFtZVxuICAgICAgICB0aGlzLmZnRWxSZWZzID0gbmV3IFJlZk1hcCgpOyAvLyB0aGUgZmMtZGF5Z3JpZC1kYXktZXZlbnRzXG4gICAgICAgIHRoaXMuc2VnSGFybmVzc1JlZnMgPSBuZXcgUmVmTWFwKCk7IC8vIGluZGV4ZWQgYnkgXCJpbnN0YW5jZUlkOmZpcnN0Q29sXCJcbiAgICAgICAgdGhpcy5yb290RWxSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGZyYW1lUG9zaXRpb25zOiBudWxsLFxuICAgICAgICAgICAgbWF4Q29udGVudEhlaWdodDogbnVsbCxcbiAgICAgICAgICAgIHNlZ0hlaWdodHM6IHt9LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVJlc2l6ZSA9IChpc0ZvcmNlZCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzRm9yY2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTaXppbmcodHJ1ZSk7IC8vIGlzRXh0ZXJuYWw9dHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBzdGF0ZSwgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgb3B0aW9ucyB9ID0gY29udGV4dDtcbiAgICAgICAgbGV0IGNvbENudCA9IHByb3BzLmNlbGxzLmxlbmd0aDtcbiAgICAgICAgbGV0IGJ1c2luZXNzSG91cnNCeUNvbCA9IHNwbGl0U2Vnc0J5Rmlyc3RDb2wocHJvcHMuYnVzaW5lc3NIb3VyU2VncywgY29sQ250KTtcbiAgICAgICAgbGV0IGJnRXZlbnRTZWdzQnlDb2wgPSBzcGxpdFNlZ3NCeUZpcnN0Q29sKHByb3BzLmJnRXZlbnRTZWdzLCBjb2xDbnQpO1xuICAgICAgICBsZXQgaGlnaGxpZ2h0U2Vnc0J5Q29sID0gc3BsaXRTZWdzQnlGaXJzdENvbCh0aGlzLmdldEhpZ2hsaWdodFNlZ3MoKSwgY29sQ250KTtcbiAgICAgICAgbGV0IG1pcnJvclNlZ3NCeUNvbCA9IHNwbGl0U2Vnc0J5Rmlyc3RDb2wodGhpcy5nZXRNaXJyb3JTZWdzKCksIGNvbENudCk7XG4gICAgICAgIGxldCB7IHNpbmdsZUNvbFBsYWNlbWVudHMsIG11bHRpQ29sUGxhY2VtZW50cywgbW9yZUNudHMsIG1vcmVNYXJnaW5Ub3BzIH0gPSBjb21wdXRlRmdTZWdQbGFjZW1lbnQoc29ydEV2ZW50U2Vncyhwcm9wcy5mZ0V2ZW50U2Vncywgb3B0aW9ucy5ldmVudE9yZGVyKSwgcHJvcHMuZGF5TWF4RXZlbnRzLCBwcm9wcy5kYXlNYXhFdmVudFJvd3MsIG9wdGlvbnMuZXZlbnRPcmRlclN0cmljdCwgc3RhdGUuc2VnSGVpZ2h0cywgc3RhdGUubWF4Q29udGVudEhlaWdodCwgcHJvcHMuY2VsbHMpO1xuICAgICAgICBsZXQgaXNGb3JjZWRJbnZpc2libGUgPSAvLyBUT0RPOiBtZXNzeSB3YXkgdG8gY29tcHV0ZSB0aGlzXG4gICAgICAgICAocHJvcHMuZXZlbnREcmFnICYmIHByb3BzLmV2ZW50RHJhZy5hZmZlY3RlZEluc3RhbmNlcykgfHxcbiAgICAgICAgICAgIChwcm9wcy5ldmVudFJlc2l6ZSAmJiBwcm9wcy5ldmVudFJlc2l6ZS5hZmZlY3RlZEluc3RhbmNlcykgfHxcbiAgICAgICAgICAgIHt9O1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IHJlZjogdGhpcy5yb290RWxSZWYsIHJvbGU6IFwicm93XCIgfSxcbiAgICAgICAgICAgIHByb3BzLnJlbmRlckludHJvICYmIHByb3BzLnJlbmRlckludHJvKCksXG4gICAgICAgICAgICBwcm9wcy5jZWxscy5tYXAoKGNlbGwsIGNvbCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBub3JtYWxGZ05vZGVzID0gdGhpcy5yZW5kZXJGZ1NlZ3MoY29sLCBwcm9wcy5mb3JQcmludCA/IHNpbmdsZUNvbFBsYWNlbWVudHNbY29sXSA6IG11bHRpQ29sUGxhY2VtZW50c1tjb2xdLCBwcm9wcy50b2RheVJhbmdlLCBpc0ZvcmNlZEludmlzaWJsZSk7XG4gICAgICAgICAgICAgICAgbGV0IG1pcnJvckZnTm9kZXMgPSB0aGlzLnJlbmRlckZnU2Vncyhjb2wsIGJ1aWxkTWlycm9yUGxhY2VtZW50cyhtaXJyb3JTZWdzQnlDb2xbY29sXSwgbXVsdGlDb2xQbGFjZW1lbnRzKSwgcHJvcHMudG9kYXlSYW5nZSwge30sIEJvb2xlYW4ocHJvcHMuZXZlbnREcmFnKSwgQm9vbGVhbihwcm9wcy5ldmVudFJlc2l6ZSksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVGFibGVDZWxsLCB7IGtleTogY2VsbC5rZXksIGVsUmVmOiB0aGlzLmNlbGxFbFJlZnMuY3JlYXRlUmVmKGNlbGwua2V5KSwgaW5uZXJFbFJlZjogdGhpcy5mcmFtZUVsUmVmcy5jcmVhdGVSZWYoY2VsbC5rZXkpIC8qIEZGIDx0ZD4gcHJvYmxlbSwgYnV0IG9rYXkgdG8gdXNlIGZvciBsZWZ0L3JpZ2h0LiBUT0RPOiByZW5hbWUgcHJvcCAqLywgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCBkYXRlOiBjZWxsLmRhdGUsIHNob3dEYXlOdW1iZXI6IHByb3BzLnNob3dEYXlOdW1iZXJzLCBzaG93V2Vla051bWJlcjogcHJvcHMuc2hvd1dlZWtOdW1iZXJzICYmIGNvbCA9PT0gMCwgZm9yY2VEYXlUb3A6IHByb3BzLnNob3dXZWVrTnVtYmVycyAvKiBldmVuIGRpc3BsYXlpbmcgd2Vla251bSBmb3Igcm93LCBub3QgbmVjZXNzYXJpbHkgZGF5ICovLCB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlLCBldmVudFNlbGVjdGlvbjogcHJvcHMuZXZlbnRTZWxlY3Rpb24sIGV2ZW50RHJhZzogcHJvcHMuZXZlbnREcmFnLCBldmVudFJlc2l6ZTogcHJvcHMuZXZlbnRSZXNpemUsIGV4dHJhUmVuZGVyUHJvcHM6IGNlbGwuZXh0cmFSZW5kZXJQcm9wcywgZXh0cmFEYXRhQXR0cnM6IGNlbGwuZXh0cmFEYXRhQXR0cnMsIGV4dHJhQ2xhc3NOYW1lczogY2VsbC5leHRyYUNsYXNzTmFtZXMsIGV4dHJhRGF0ZVNwYW46IGNlbGwuZXh0cmFEYXRlU3BhbiwgbW9yZUNudDogbW9yZUNudHNbY29sXSwgbW9yZU1hcmdpblRvcDogbW9yZU1hcmdpblRvcHNbY29sXSwgc2luZ2xlUGxhY2VtZW50czogc2luZ2xlQ29sUGxhY2VtZW50c1tjb2xdLCBmZ0NvbnRlbnRFbFJlZjogdGhpcy5mZ0VsUmVmcy5jcmVhdGVSZWYoY2VsbC5rZXkpLCBmZ0NvbnRlbnQ6ICggLy8gRnJhZ21lbnQgc2NvcGVzIHRoZSBrZXlzXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBub3JtYWxGZ05vZGVzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIG1pcnJvckZnTm9kZXMpKSksIGJnQ29udGVudDogKCAvLyBGcmFnbWVudCBzY29wZXMgdGhlIGtleXNcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRmlsbFNlZ3MoaGlnaGxpZ2h0U2Vnc0J5Q29sW2NvbF0sICdoaWdobGlnaHQnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRmlsbFNlZ3MoYnVzaW5lc3NIb3Vyc0J5Q29sW2NvbF0sICdub24tYnVzaW5lc3MnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRmlsbFNlZ3MoYmdFdmVudFNlZ3NCeUNvbFtjb2xdLCAnYmctZXZlbnQnKSkpLCBtaW5IZWlnaHQ6IHByb3BzLmNlbGxNaW5IZWlnaHQgfSkpO1xuICAgICAgICAgICAgfSkpKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU2l6aW5nKHRydWUpO1xuICAgICAgICB0aGlzLmNvbnRleHQuYWRkUmVzaXplSGFuZGxlcih0aGlzLmhhbmRsZVJlc2l6ZSk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSkge1xuICAgICAgICBsZXQgY3VycmVudFByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdGhpcy51cGRhdGVTaXppbmcoIWlzUHJvcHNFcXVhbChwcmV2UHJvcHMsIGN1cnJlbnRQcm9wcykpO1xuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LnJlbW92ZVJlc2l6ZUhhbmRsZXIodGhpcy5oYW5kbGVSZXNpemUpO1xuICAgIH1cbiAgICBnZXRIaWdobGlnaHRTZWdzKCkge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgaWYgKHByb3BzLmV2ZW50RHJhZyAmJiBwcm9wcy5ldmVudERyYWcuc2Vncy5sZW5ndGgpIHsgLy8gbWVzc3kgY2hlY2tcbiAgICAgICAgICAgIHJldHVybiBwcm9wcy5ldmVudERyYWcuc2VncztcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcHMuZXZlbnRSZXNpemUgJiYgcHJvcHMuZXZlbnRSZXNpemUuc2Vncy5sZW5ndGgpIHsgLy8gbWVzc3kgY2hlY2tcbiAgICAgICAgICAgIHJldHVybiBwcm9wcy5ldmVudFJlc2l6ZS5zZWdzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9wcy5kYXRlU2VsZWN0aW9uU2VncztcbiAgICB9XG4gICAgZ2V0TWlycm9yU2VncygpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGlmIChwcm9wcy5ldmVudFJlc2l6ZSAmJiBwcm9wcy5ldmVudFJlc2l6ZS5zZWdzLmxlbmd0aCkgeyAvLyBtZXNzeSBjaGVja1xuICAgICAgICAgICAgcmV0dXJuIHByb3BzLmV2ZW50UmVzaXplLnNlZ3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZW5kZXJGZ1NlZ3MoY29sLCBzZWdQbGFjZW1lbnRzLCB0b2RheVJhbmdlLCBpc0ZvcmNlZEludmlzaWJsZSwgaXNEcmFnZ2luZywgaXNSZXNpemluZywgaXNEYXRlU2VsZWN0aW5nKSB7XG4gICAgICAgIGxldCB7IGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IGV2ZW50U2VsZWN0aW9uIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBsZXQgeyBmcmFtZVBvc2l0aW9ucyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgbGV0IGRlZmF1bHREaXNwbGF5RXZlbnRFbmQgPSB0aGlzLnByb3BzLmNlbGxzLmxlbmd0aCA9PT0gMTsgLy8gY29sQ250ID09PSAxXG4gICAgICAgIGxldCBpc01pcnJvciA9IGlzRHJhZ2dpbmcgfHwgaXNSZXNpemluZyB8fCBpc0RhdGVTZWxlY3Rpbmc7XG4gICAgICAgIGxldCBub2RlcyA9IFtdO1xuICAgICAgICBpZiAoZnJhbWVQb3NpdGlvbnMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHBsYWNlbWVudCBvZiBzZWdQbGFjZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgc2VnIH0gPSBwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgICAgbGV0IHsgaW5zdGFuY2VJZCB9ID0gc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgbGV0IGlzVmlzaWJsZSA9IHBsYWNlbWVudC5pc1Zpc2libGUgJiYgIWlzRm9yY2VkSW52aXNpYmxlW2luc3RhbmNlSWRdO1xuICAgICAgICAgICAgICAgIGxldCBpc0Fic29sdXRlID0gcGxhY2VtZW50LmlzQWJzb2x1dGU7XG4gICAgICAgICAgICAgICAgbGV0IGxlZnQgPSAnJztcbiAgICAgICAgICAgICAgICBsZXQgcmlnaHQgPSAnJztcbiAgICAgICAgICAgICAgICBpZiAoaXNBYnNvbHV0ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5pc1J0bCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGZyYW1lUG9zaXRpb25zLmxlZnRzW3NlZy5sYXN0Q29sXSAtIGZyYW1lUG9zaXRpb25zLmxlZnRzW3NlZy5maXJzdENvbF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gZnJhbWVQb3NpdGlvbnMucmlnaHRzW3NlZy5maXJzdENvbF0gLSBmcmFtZVBvc2l0aW9ucy5yaWdodHNbc2VnLmxhc3RDb2xdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAga25vd24gYnVnOiBldmVudHMgdGhhdCBhcmUgZm9yY2UgdG8gYmUgbGlzdC1pdGVtIGJ1dCBzcGFuIG11bHRpcGxlIGRheXMgc3RpbGwgdGFrZSB1cCBzcGFjZSBpbiBsYXRlciBjb2x1bW5zXG4gICAgICAgICAgICAgICAgdG9kbzogaW4gcHJpbnQgdmlldywgZm9yIG11bHRpLWRheSBldmVudHMsIGRvbid0IGRpc3BsYXkgdGl0bGUgd2l0aGluIG5vbi1zdGFydC9lbmQgc2Vnc1xuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiAnZmMtZGF5Z3JpZC1ldmVudC1oYXJuZXNzJyArIChpc0Fic29sdXRlID8gJyBmYy1kYXlncmlkLWV2ZW50LWhhcm5lc3MtYWJzJyA6ICcnKSwga2V5OiBnZW5lcmF0ZVNlZ0tleShzZWcpLCByZWY6IGlzTWlycm9yID8gbnVsbCA6IHRoaXMuc2VnSGFybmVzc1JlZnMuY3JlYXRlUmVmKGdlbmVyYXRlU2VnVWlkKHNlZykpLCBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogaXNWaXNpYmxlID8gJycgOiAnaGlkZGVuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpblRvcDogaXNBYnNvbHV0ZSA/ICcnIDogcGxhY2VtZW50Lm1hcmdpblRvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogaXNBYnNvbHV0ZSA/IHBsYWNlbWVudC5hYnNvbHV0ZVRvcCA6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0LFxuICAgICAgICAgICAgICAgICAgICB9IH0sIGhhc0xpc3RJdGVtRGlzcGxheShzZWcpID8gKGNyZWF0ZUVsZW1lbnQoVGFibGVMaXN0SXRlbUV2ZW50LCBPYmplY3QuYXNzaWduKHsgc2VnOiBzZWcsIGlzRHJhZ2dpbmc6IGlzRHJhZ2dpbmcsIGlzU2VsZWN0ZWQ6IGluc3RhbmNlSWQgPT09IGV2ZW50U2VsZWN0aW9uLCBkZWZhdWx0RGlzcGxheUV2ZW50RW5kOiBkZWZhdWx0RGlzcGxheUV2ZW50RW5kIH0sIGdldFNlZ01ldGEoc2VnLCB0b2RheVJhbmdlKSkpKSA6IChjcmVhdGVFbGVtZW50KFRhYmxlQmxvY2tFdmVudCwgT2JqZWN0LmFzc2lnbih7IHNlZzogc2VnLCBpc0RyYWdnaW5nOiBpc0RyYWdnaW5nLCBpc1Jlc2l6aW5nOiBpc1Jlc2l6aW5nLCBpc0RhdGVTZWxlY3Rpbmc6IGlzRGF0ZVNlbGVjdGluZywgaXNTZWxlY3RlZDogaW5zdGFuY2VJZCA9PT0gZXZlbnRTZWxlY3Rpb24sIGRlZmF1bHREaXNwbGF5RXZlbnRFbmQ6IGRlZmF1bHREaXNwbGF5RXZlbnRFbmQgfSwgZ2V0U2VnTWV0YShzZWcsIHRvZGF5UmFuZ2UpKSkpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cbiAgICByZW5kZXJGaWxsU2VncyhzZWdzLCBmaWxsVHlwZSkge1xuICAgICAgICBsZXQgeyBpc1J0bCB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgeyB0b2RheVJhbmdlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBsZXQgeyBmcmFtZVBvc2l0aW9ucyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgbGV0IG5vZGVzID0gW107XG4gICAgICAgIGlmIChmcmFtZVBvc2l0aW9ucykge1xuICAgICAgICAgICAgZm9yIChsZXQgc2VnIG9mIHNlZ3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgbGVmdFJpZ2h0Q3NzID0gaXNSdGwgPyB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBmcmFtZVBvc2l0aW9ucy5sZWZ0c1tzZWcubGFzdENvbF0gLSBmcmFtZVBvc2l0aW9ucy5sZWZ0c1tzZWcuZmlyc3RDb2xdLFxuICAgICAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBmcmFtZVBvc2l0aW9ucy5yaWdodHNbc2VnLmZpcnN0Q29sXSAtIGZyYW1lUG9zaXRpb25zLnJpZ2h0c1tzZWcubGFzdENvbF0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBrZXk6IGJ1aWxkRXZlbnRSYW5nZUtleShzZWcuZXZlbnRSYW5nZSksIGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWJnLWhhcm5lc3NcIiwgc3R5bGU6IGxlZnRSaWdodENzcyB9LCBmaWxsVHlwZSA9PT0gJ2JnLWV2ZW50JyA/XG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoQmdFdmVudCwgT2JqZWN0LmFzc2lnbih7IHNlZzogc2VnIH0sIGdldFNlZ01ldGEoc2VnLCB0b2RheVJhbmdlKSkpIDpcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyRmlsbChmaWxsVHlwZSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChGcmFnbWVudCwge30sIC4uLm5vZGVzKTtcbiAgICB9XG4gICAgdXBkYXRlU2l6aW5nKGlzRXh0ZXJuYWxTaXppbmdDaGFuZ2UpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIHN0YXRlLCBmcmFtZUVsUmVmcyB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFwcm9wcy5mb3JQcmludCAmJlxuICAgICAgICAgICAgcHJvcHMuY2xpZW50V2lkdGggIT09IG51bGwgLy8gcG9zaXRpb25pbmcgcmVhZHk/XG4gICAgICAgICkge1xuICAgICAgICAgICAgaWYgKGlzRXh0ZXJuYWxTaXppbmdDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJhbWVFbHMgPSBwcm9wcy5jZWxscy5tYXAoKGNlbGwpID0+IGZyYW1lRWxSZWZzLmN1cnJlbnRNYXBbY2VsbC5rZXldKTtcbiAgICAgICAgICAgICAgICBpZiAoZnJhbWVFbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvcmlnaW5FbCA9IHRoaXMucm9vdEVsUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdQb3NpdGlvbkNhY2hlID0gbmV3IFBvc2l0aW9uQ2FjaGUob3JpZ2luRWwsIGZyYW1lRWxzLCB0cnVlLCAvLyBpc0hvcml6b250YWxcbiAgICAgICAgICAgICAgICAgICAgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLmZyYW1lUG9zaXRpb25zIHx8ICFzdGF0ZS5mcmFtZVBvc2l0aW9ucy5zaW1pbGFyVG8obmV3UG9zaXRpb25DYWNoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lUG9zaXRpb25zOiBuZXcgUG9zaXRpb25DYWNoZShvcmlnaW5FbCwgZnJhbWVFbHMsIHRydWUsIC8vIGlzSG9yaXpvbnRhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb2xkU2VnSGVpZ2h0cyA9IHRoaXMuc3RhdGUuc2VnSGVpZ2h0cztcbiAgICAgICAgICAgIGNvbnN0IG5ld1NlZ0hlaWdodHMgPSB0aGlzLnF1ZXJ5U2VnSGVpZ2h0cygpO1xuICAgICAgICAgICAgY29uc3QgbGltaXRCeUNvbnRlbnRIZWlnaHQgPSBwcm9wcy5kYXlNYXhFdmVudHMgPT09IHRydWUgfHwgcHJvcHMuZGF5TWF4RXZlbnRSb3dzID09PSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zYWZlU2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIC8vIEhBQ0sgdG8gcHJldmVudCBvc2NpbGxhdGlvbnMgb2YgZXZlbnRzIGJlaW5nIHNob3duL2hpZGRlbiBmcm9tIG1heC1ldmVudC1yb3dzXG4gICAgICAgICAgICAgICAgLy8gRXNzZW50aWFsbHksIG9uY2UgeW91IGNvbXB1dGUgYW4gZWxlbWVudCdzIGhlaWdodCwgbmV2ZXIgbnVsbC1vdXQuXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogYWx3YXlzIGRpc3BsYXkgYWxsIGV2ZW50cywgYXMgdmlzaWJpbGl0eTpoaWRkZW4/XG4gICAgICAgICAgICAgICAgc2VnSGVpZ2h0czogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvbGRTZWdIZWlnaHRzKSwgbmV3U2VnSGVpZ2h0cyksXG4gICAgICAgICAgICAgICAgbWF4Q29udGVudEhlaWdodDogbGltaXRCeUNvbnRlbnRIZWlnaHQgPyB0aGlzLmNvbXB1dGVNYXhDb250ZW50SGVpZ2h0KCkgOiBudWxsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVlcnlTZWdIZWlnaHRzKCkge1xuICAgICAgICBsZXQgc2VnRWxNYXAgPSB0aGlzLnNlZ0hhcm5lc3NSZWZzLmN1cnJlbnRNYXA7XG4gICAgICAgIGxldCBzZWdIZWlnaHRzID0ge307XG4gICAgICAgIC8vIGdldCB0aGUgbWF4IGhlaWdodCBhbW9uZ3N0IGluc3RhbmNlIHNlZ3NcbiAgICAgICAgZm9yIChsZXQgc2VnVWlkIGluIHNlZ0VsTWFwKSB7XG4gICAgICAgICAgICBsZXQgaGVpZ2h0ID0gTWF0aC5yb3VuZChzZWdFbE1hcFtzZWdVaWRdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCk7XG4gICAgICAgICAgICBzZWdIZWlnaHRzW3NlZ1VpZF0gPSBNYXRoLm1heChzZWdIZWlnaHRzW3NlZ1VpZF0gfHwgMCwgaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VnSGVpZ2h0cztcbiAgICB9XG4gICAgY29tcHV0ZU1heENvbnRlbnRIZWlnaHQoKSB7XG4gICAgICAgIGxldCBmaXJzdEtleSA9IHRoaXMucHJvcHMuY2VsbHNbMF0ua2V5O1xuICAgICAgICBsZXQgY2VsbEVsID0gdGhpcy5jZWxsRWxSZWZzLmN1cnJlbnRNYXBbZmlyc3RLZXldO1xuICAgICAgICBsZXQgZmNDb250YWluZXJFbCA9IHRoaXMuZmdFbFJlZnMuY3VycmVudE1hcFtmaXJzdEtleV07XG4gICAgICAgIHJldHVybiBjZWxsRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tIC0gZmNDb250YWluZXJFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG4gICAgfVxuICAgIGdldENlbGxFbHMoKSB7XG4gICAgICAgIGxldCBlbE1hcCA9IHRoaXMuY2VsbEVsUmVmcy5jdXJyZW50TWFwO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5jZWxscy5tYXAoKGNlbGwpID0+IGVsTWFwW2NlbGwua2V5XSk7XG4gICAgfVxufVxuVGFibGVSb3cuYWRkU3RhdGVFcXVhbGl0eSh7XG4gICAgc2VnSGVpZ2h0czogaXNQcm9wc0VxdWFsLFxufSk7XG5mdW5jdGlvbiBidWlsZE1pcnJvclBsYWNlbWVudHMobWlycm9yU2VncywgY29sUGxhY2VtZW50cykge1xuICAgIGlmICghbWlycm9yU2Vncy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBsZXQgdG9wc0J5SW5zdGFuY2VJZCA9IGJ1aWxkQWJzb2x1dGVUb3BIYXNoKGNvbFBsYWNlbWVudHMpOyAvLyBUT0RPOiBjYWNoZSB0aGlzIGF0IGZpcnN0IHJlbmRlcj9cbiAgICByZXR1cm4gbWlycm9yU2Vncy5tYXAoKHNlZykgPT4gKHtcbiAgICAgICAgc2VnLFxuICAgICAgICBpc1Zpc2libGU6IHRydWUsXG4gICAgICAgIGlzQWJzb2x1dGU6IHRydWUsXG4gICAgICAgIGFic29sdXRlVG9wOiB0b3BzQnlJbnN0YW5jZUlkW3NlZy5ldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWRdLFxuICAgICAgICBtYXJnaW5Ub3A6IDAsXG4gICAgfSkpO1xufVxuZnVuY3Rpb24gYnVpbGRBYnNvbHV0ZVRvcEhhc2goY29sUGxhY2VtZW50cykge1xuICAgIGxldCB0b3BzQnlJbnN0YW5jZUlkID0ge307XG4gICAgZm9yIChsZXQgcGxhY2VtZW50cyBvZiBjb2xQbGFjZW1lbnRzKSB7XG4gICAgICAgIGZvciAobGV0IHBsYWNlbWVudCBvZiBwbGFjZW1lbnRzKSB7XG4gICAgICAgICAgICB0b3BzQnlJbnN0YW5jZUlkW3BsYWNlbWVudC5zZWcuZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkXSA9IHBsYWNlbWVudC5hYnNvbHV0ZVRvcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG9wc0J5SW5zdGFuY2VJZDtcbn1cblxuY2xhc3MgVGFibGVSb3dzIGV4dGVuZHMgRGF0ZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuc3BsaXRCdXNpbmVzc0hvdXJTZWdzID0gbWVtb2l6ZShzcGxpdFNlZ3NCeVJvdyk7XG4gICAgICAgIHRoaXMuc3BsaXRCZ0V2ZW50U2VncyA9IG1lbW9pemUoc3BsaXRTZWdzQnlSb3cpO1xuICAgICAgICB0aGlzLnNwbGl0RmdFdmVudFNlZ3MgPSBtZW1vaXplKHNwbGl0U2Vnc0J5Um93KTtcbiAgICAgICAgdGhpcy5zcGxpdERhdGVTZWxlY3Rpb25TZWdzID0gbWVtb2l6ZShzcGxpdFNlZ3NCeVJvdyk7XG4gICAgICAgIHRoaXMuc3BsaXRFdmVudERyYWcgPSBtZW1vaXplKHNwbGl0SW50ZXJhY3Rpb25CeVJvdyk7XG4gICAgICAgIHRoaXMuc3BsaXRFdmVudFJlc2l6ZSA9IG1lbW9pemUoc3BsaXRJbnRlcmFjdGlvbkJ5Um93KTtcbiAgICAgICAgdGhpcy5yb3dSZWZzID0gbmV3IFJlZk1hcCgpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBsZXQgcm93Q250ID0gcHJvcHMuY2VsbHMubGVuZ3RoO1xuICAgICAgICBsZXQgYnVzaW5lc3NIb3VyU2Vnc0J5Um93ID0gdGhpcy5zcGxpdEJ1c2luZXNzSG91clNlZ3MocHJvcHMuYnVzaW5lc3NIb3VyU2Vncywgcm93Q250KTtcbiAgICAgICAgbGV0IGJnRXZlbnRTZWdzQnlSb3cgPSB0aGlzLnNwbGl0QmdFdmVudFNlZ3MocHJvcHMuYmdFdmVudFNlZ3MsIHJvd0NudCk7XG4gICAgICAgIGxldCBmZ0V2ZW50U2Vnc0J5Um93ID0gdGhpcy5zcGxpdEZnRXZlbnRTZWdzKHByb3BzLmZnRXZlbnRTZWdzLCByb3dDbnQpO1xuICAgICAgICBsZXQgZGF0ZVNlbGVjdGlvblNlZ3NCeVJvdyA9IHRoaXMuc3BsaXREYXRlU2VsZWN0aW9uU2Vncyhwcm9wcy5kYXRlU2VsZWN0aW9uU2Vncywgcm93Q250KTtcbiAgICAgICAgbGV0IGV2ZW50RHJhZ0J5Um93ID0gdGhpcy5zcGxpdEV2ZW50RHJhZyhwcm9wcy5ldmVudERyYWcsIHJvd0NudCk7XG4gICAgICAgIGxldCBldmVudFJlc2l6ZUJ5Um93ID0gdGhpcy5zcGxpdEV2ZW50UmVzaXplKHByb3BzLmV2ZW50UmVzaXplLCByb3dDbnQpO1xuICAgICAgICAvLyBmb3IgRGF5R3JpZCB2aWV3IHdpdGggbWFueSByb3dzLCBmb3JjZSBhIG1pbi1oZWlnaHQgb24gY2VsbHMgc28gZG9lc24ndCBhcHBlYXIgc3F1aXNoZWRcbiAgICAgICAgLy8gY2hvb3NlIDcgYmVjYXVzZSBhIG1vbnRoIHZpZXcgd2lsbCBoYXZlIG1heCA2IHJvd3NcbiAgICAgICAgbGV0IGNlbGxNaW5IZWlnaHQgPSAocm93Q250ID49IDcgJiYgcHJvcHMuY2xpZW50V2lkdGgpID9cbiAgICAgICAgICAgIHByb3BzLmNsaWVudFdpZHRoIC8gY29udGV4dC5vcHRpb25zLmFzcGVjdFJhdGlvIC8gNiA6XG4gICAgICAgICAgICBudWxsO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoTm93VGltZXIsIHsgdW5pdDogXCJkYXlcIiB9LCAobm93RGF0ZSwgdG9kYXlSYW5nZSkgPT4gKGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIHByb3BzLmNlbGxzLm1hcCgoY2VsbHMsIHJvdykgPT4gKGNyZWF0ZUVsZW1lbnQoVGFibGVSb3csIHsgcmVmOiB0aGlzLnJvd1JlZnMuY3JlYXRlUmVmKHJvdyksIGtleTogY2VsbHMubGVuZ3RoXG4gICAgICAgICAgICAgICAgPyBjZWxsc1swXS5kYXRlLnRvSVNPU3RyaW5nKCkgLyogYmVzdD8gb3IgcHV0IGtleSBvbiBjZWxsPyBvciB1c2UgZGlmZiBmb3JtYXR0ZXI/ICovXG4gICAgICAgICAgICAgICAgOiByb3cgLy8gaW4gY2FzZSB0aGVyZSBhcmUgbm8gY2VsbHMgKGxpa2Ugd2hlbiByZXNvdXJjZSB2aWV3IGlzIGxvYWRpbmcpXG4gICAgICAgICAgICAsIHNob3dEYXlOdW1iZXJzOiByb3dDbnQgPiAxLCBzaG93V2Vla051bWJlcnM6IHByb3BzLnNob3dXZWVrTnVtYmVycywgdG9kYXlSYW5nZTogdG9kYXlSYW5nZSwgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCBjZWxsczogY2VsbHMsIHJlbmRlckludHJvOiBwcm9wcy5yZW5kZXJSb3dJbnRybywgYnVzaW5lc3NIb3VyU2VnczogYnVzaW5lc3NIb3VyU2Vnc0J5Um93W3Jvd10sIGV2ZW50U2VsZWN0aW9uOiBwcm9wcy5ldmVudFNlbGVjdGlvbiwgYmdFdmVudFNlZ3M6IGJnRXZlbnRTZWdzQnlSb3dbcm93XS5maWx0ZXIoaXNTZWdBbGxEYXkpIC8qIGhhY2sgKi8sIGZnRXZlbnRTZWdzOiBmZ0V2ZW50U2Vnc0J5Um93W3Jvd10sIGRhdGVTZWxlY3Rpb25TZWdzOiBkYXRlU2VsZWN0aW9uU2Vnc0J5Um93W3Jvd10sIGV2ZW50RHJhZzogZXZlbnREcmFnQnlSb3dbcm93XSwgZXZlbnRSZXNpemU6IGV2ZW50UmVzaXplQnlSb3dbcm93XSwgZGF5TWF4RXZlbnRzOiBwcm9wcy5kYXlNYXhFdmVudHMsIGRheU1heEV2ZW50Um93czogcHJvcHMuZGF5TWF4RXZlbnRSb3dzLCBjbGllbnRXaWR0aDogcHJvcHMuY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodDogcHJvcHMuY2xpZW50SGVpZ2h0LCBjZWxsTWluSGVpZ2h0OiBjZWxsTWluSGVpZ2h0LCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQgfSkpKSkpKSk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQoKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICAvLyBmb3IgaWYgc3RhcnRlZCB3aXRoIHplcm8gY2VsbHNcbiAgICAgICAgdGhpcy5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KCk7XG4gICAgfVxuICAgIHJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5yb290RWwpIHtcbiAgICAgICAgICAgIC8vIEhBQ0s6IG5lZWQgYSBkYXlncmlkIHdyYXBwZXIgcGFyZW50IHRvIGRvIHBvc2l0aW9uaW5nXG4gICAgICAgICAgICAvLyBOT1RFOiBhIGRheWdyaWQgcmVzb3VyY2UgdmlldyB3L28gcmVzb3VyY2VzIGNhbiBoYXZlIHplcm8gY2VsbHNcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0Q2VsbEVsID0gdGhpcy5yb3dSZWZzLmN1cnJlbnRNYXBbMF0uZ2V0Q2VsbEVscygpWzBdO1xuICAgICAgICAgICAgY29uc3Qgcm9vdEVsID0gZmlyc3RDZWxsRWwgPyBmaXJzdENlbGxFbC5jbG9zZXN0KCcuZmMtZGF5Z3JpZC1ib2R5JykgOiBudWxsO1xuICAgICAgICAgICAgaWYgKHJvb3RFbCkge1xuICAgICAgICAgICAgICAgIHRoaXMucm9vdEVsID0gcm9vdEVsO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgZWw6IHJvb3RFbCxcbiAgICAgICAgICAgICAgICAgICAgaXNIaXRDb21ib0FsbG93ZWQ6IHRoaXMucHJvcHMuaXNIaXRDb21ib0FsbG93ZWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGlmICh0aGlzLnJvb3RFbCkge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMucm9vdEVsID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBIaXQgU3lzdGVtXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHByZXBhcmVIaXRzKCkge1xuICAgICAgICB0aGlzLnJvd1Bvc2l0aW9ucyA9IG5ldyBQb3NpdGlvbkNhY2hlKHRoaXMucm9vdEVsLCB0aGlzLnJvd1JlZnMuY29sbGVjdCgpLm1hcCgocm93T2JqKSA9PiByb3dPYmouZ2V0Q2VsbEVscygpWzBdKSwgLy8gZmlyc3QgY2VsbCBlbCBpbiBlYWNoIHJvdy4gVE9ETzogbm90IG9wdGltYWxcbiAgICAgICAgZmFsc2UsIHRydWUpO1xuICAgICAgICB0aGlzLmNvbFBvc2l0aW9ucyA9IG5ldyBQb3NpdGlvbkNhY2hlKHRoaXMucm9vdEVsLCB0aGlzLnJvd1JlZnMuY3VycmVudE1hcFswXS5nZXRDZWxsRWxzKCksIC8vIGNlbGwgZWxzIGluIGZpcnN0IHJvd1xuICAgICAgICB0cnVlLCAvLyBob3Jpem9udGFsXG4gICAgICAgIGZhbHNlKTtcbiAgICB9XG4gICAgcXVlcnlIaXQocG9zaXRpb25MZWZ0LCBwb3NpdGlvblRvcCkge1xuICAgICAgICBsZXQgeyBjb2xQb3NpdGlvbnMsIHJvd1Bvc2l0aW9ucyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGNvbCA9IGNvbFBvc2l0aW9ucy5sZWZ0VG9JbmRleChwb3NpdGlvbkxlZnQpO1xuICAgICAgICBsZXQgcm93ID0gcm93UG9zaXRpb25zLnRvcFRvSW5kZXgocG9zaXRpb25Ub3ApO1xuICAgICAgICBpZiAocm93ICE9IG51bGwgJiYgY29sICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBjZWxsID0gdGhpcy5wcm9wcy5jZWxsc1tyb3ddW2NvbF07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGVQcm9maWxlOiB0aGlzLnByb3BzLmRhdGVQcm9maWxlLFxuICAgICAgICAgICAgICAgIGRhdGVTcGFuOiBPYmplY3QuYXNzaWduKHsgcmFuZ2U6IHRoaXMuZ2V0Q2VsbFJhbmdlKHJvdywgY29sKSwgYWxsRGF5OiB0cnVlIH0sIGNlbGwuZXh0cmFEYXRlU3BhbiksXG4gICAgICAgICAgICAgICAgZGF5RWw6IHRoaXMuZ2V0Q2VsbEVsKHJvdywgY29sKSxcbiAgICAgICAgICAgICAgICByZWN0OiB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IGNvbFBvc2l0aW9ucy5sZWZ0c1tjb2xdLFxuICAgICAgICAgICAgICAgICAgICByaWdodDogY29sUG9zaXRpb25zLnJpZ2h0c1tjb2xdLFxuICAgICAgICAgICAgICAgICAgICB0b3A6IHJvd1Bvc2l0aW9ucy50b3BzW3Jvd10sXG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbTogcm93UG9zaXRpb25zLmJvdHRvbXNbcm93XSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGxheWVyOiAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZ2V0Q2VsbEVsKHJvdywgY29sKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvd1JlZnMuY3VycmVudE1hcFtyb3ddLmdldENlbGxFbHMoKVtjb2xdOyAvLyBUT0RPOiBub3Qgb3B0aW1hbFxuICAgIH1cbiAgICBnZXRDZWxsUmFuZ2Uocm93LCBjb2wpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5wcm9wcy5jZWxsc1tyb3ddW2NvbF0uZGF0ZTtcbiAgICAgICAgbGV0IGVuZCA9IGFkZERheXMoc3RhcnQsIDEpO1xuICAgICAgICByZXR1cm4geyBzdGFydCwgZW5kIH07XG4gICAgfVxufVxuZnVuY3Rpb24gaXNTZWdBbGxEYXkoc2VnKSB7XG4gICAgcmV0dXJuIHNlZy5ldmVudFJhbmdlLmRlZi5hbGxEYXk7XG59XG5cbmNsYXNzIFRhYmxlIGV4dGVuZHMgRGF0ZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuZWxSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICAgICAgdGhpcy5uZWVkc1Njcm9sbFJlc2V0ID0gZmFsc2U7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IGRheU1heEV2ZW50Um93cywgZGF5TWF4RXZlbnRzLCBleHBhbmRSb3dzIH0gPSBwcm9wcztcbiAgICAgICAgbGV0IGxpbWl0VmlhQmFsYW5jZWQgPSBkYXlNYXhFdmVudHMgPT09IHRydWUgfHwgZGF5TWF4RXZlbnRSb3dzID09PSB0cnVlO1xuICAgICAgICAvLyBpZiByb3dzIGNhbid0IGV4cGFuZCB0byBmaWxsIGZpeGVkIGhlaWdodCwgY2FuJ3QgZG8gYmFsYW5jZWQtaGVpZ2h0IGV2ZW50IGxpbWl0XG4gICAgICAgIC8vIFRPRE86IGJlc3QgcGxhY2UgdG8gbm9ybWFsaXplIHRoZXNlIG9wdGlvbnM/XG4gICAgICAgIGlmIChsaW1pdFZpYUJhbGFuY2VkICYmICFleHBhbmRSb3dzKSB7XG4gICAgICAgICAgICBsaW1pdFZpYUJhbGFuY2VkID0gZmFsc2U7XG4gICAgICAgICAgICBkYXlNYXhFdmVudFJvd3MgPSBudWxsO1xuICAgICAgICAgICAgZGF5TWF4RXZlbnRzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2xhc3NOYW1lcyA9IFtcbiAgICAgICAgICAgICdmYy1kYXlncmlkLWJvZHknLFxuICAgICAgICAgICAgbGltaXRWaWFCYWxhbmNlZCA/ICdmYy1kYXlncmlkLWJvZHktYmFsYW5jZWQnIDogJ2ZjLWRheWdyaWQtYm9keS11bmJhbGFuY2VkJyxcbiAgICAgICAgICAgIGV4cGFuZFJvd3MgPyAnJyA6ICdmYy1kYXlncmlkLWJvZHktbmF0dXJhbCcsIC8vIHdpbGwgaGVpZ2h0IG9mIG9uZSByb3cgZGVwZW5kIG9uIHRoZSBvdGhlcnM/XG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogdGhpcy5lbFJlZiwgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmpvaW4oJyAnKSwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAvLyB0aGVzZSBwcm9wcyBhcmUgaW1wb3J0YW50IHRvIGdpdmUgdGhpcyB3cmFwcGVyIGNvcnJlY3QgZGltZW5zaW9ucyBmb3IgaW50ZXJhY3Rpb25zXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogaWYgd2Ugc2V0IGl0IGhlcmUsIGNhbiB3ZSBhdm9pZCBnaXZpbmcgdG8gaW5uZXIgdGFibGVzP1xuICAgICAgICAgICAgICAgIHdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgICBtaW5XaWR0aDogcHJvcHMudGFibGVNaW5XaWR0aCxcbiAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJ0YWJsZVwiLCB7IHJvbGU6IFwicHJlc2VudGF0aW9uXCIsIGNsYXNzTmFtZTogXCJmYy1zY3JvbGxncmlkLXN5bmMtdGFibGVcIiwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBtaW5XaWR0aDogcHJvcHMudGFibGVNaW5XaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBleHBhbmRSb3dzID8gcHJvcHMuY2xpZW50SGVpZ2h0IDogJycsXG4gICAgICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgICAgIHByb3BzLmNvbEdyb3VwTm9kZSxcbiAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwidGJvZHlcIiwgeyByb2xlOiBcInByZXNlbnRhdGlvblwiIH0sXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoVGFibGVSb3dzLCB7IGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgY2VsbHM6IHByb3BzLmNlbGxzLCByZW5kZXJSb3dJbnRybzogcHJvcHMucmVuZGVyUm93SW50cm8sIHNob3dXZWVrTnVtYmVyczogcHJvcHMuc2hvd1dlZWtOdW1iZXJzLCBjbGllbnRXaWR0aDogcHJvcHMuY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodDogcHJvcHMuY2xpZW50SGVpZ2h0LCBidXNpbmVzc0hvdXJTZWdzOiBwcm9wcy5idXNpbmVzc0hvdXJTZWdzLCBiZ0V2ZW50U2VnczogcHJvcHMuYmdFdmVudFNlZ3MsIGZnRXZlbnRTZWdzOiBwcm9wcy5mZ0V2ZW50U2VncywgZGF0ZVNlbGVjdGlvblNlZ3M6IHByb3BzLmRhdGVTZWxlY3Rpb25TZWdzLCBldmVudFNlbGVjdGlvbjogcHJvcHMuZXZlbnRTZWxlY3Rpb24sIGV2ZW50RHJhZzogcHJvcHMuZXZlbnREcmFnLCBldmVudFJlc2l6ZTogcHJvcHMuZXZlbnRSZXNpemUsIGRheU1heEV2ZW50czogZGF5TWF4RXZlbnRzLCBkYXlNYXhFdmVudFJvd3M6IGRheU1heEV2ZW50Um93cywgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50LCBpc0hpdENvbWJvQWxsb3dlZDogcHJvcHMuaXNIaXRDb21ib0FsbG93ZWQgfSkpKSkpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0U2Nyb2xsUmVzZXQoKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgICBpZiAocHJldlByb3BzLmRhdGVQcm9maWxlICE9PSB0aGlzLnByb3BzLmRhdGVQcm9maWxlKSB7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RTY3JvbGxSZXNldCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5mbHVzaFNjcm9sbFJlc2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVxdWVzdFNjcm9sbFJlc2V0KCkge1xuICAgICAgICB0aGlzLm5lZWRzU2Nyb2xsUmVzZXQgPSB0cnVlO1xuICAgICAgICB0aGlzLmZsdXNoU2Nyb2xsUmVzZXQoKTtcbiAgICB9XG4gICAgZmx1c2hTY3JvbGxSZXNldCgpIHtcbiAgICAgICAgaWYgKHRoaXMubmVlZHNTY3JvbGxSZXNldCAmJlxuICAgICAgICAgICAgdGhpcy5wcm9wcy5jbGllbnRXaWR0aCAvLyBzaXplcyBjb21wdXRlZD9cbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJqZWN0RWwgPSBnZXRTY3JvbGxTdWJqZWN0RWwodGhpcy5lbFJlZi5jdXJyZW50LCB0aGlzLnByb3BzLmRhdGVQcm9maWxlKTtcbiAgICAgICAgICAgIGlmIChzdWJqZWN0RWwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5FbCA9IHN1YmplY3RFbC5jbG9zZXN0KCcuZmMtZGF5Z3JpZC1ib2R5Jyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2Nyb2xsRWwgPSBvcmlnaW5FbC5jbG9zZXN0KCcuZmMtc2Nyb2xsZXInKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzY3JvbGxUb3AgPSBzdWJqZWN0RWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wIC1cbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xuICAgICAgICAgICAgICAgIHNjcm9sbEVsLnNjcm9sbFRvcCA9IHNjcm9sbFRvcCA/IChzY3JvbGxUb3AgKyAxKSA6IDA7IC8vIG92ZXJjb21lIGJvcmRlclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5uZWVkc1Njcm9sbFJlc2V0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBnZXRTY3JvbGxTdWJqZWN0RWwoY29udGFpbmVyRWwsIGRhdGVQcm9maWxlKSB7XG4gICAgbGV0IGVsO1xuICAgIGlmIChkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2VVbml0Lm1hdGNoKC95ZWFyfG1vbnRoLykpIHtcbiAgICAgICAgZWwgPSBjb250YWluZXJFbC5xdWVyeVNlbGVjdG9yKGBbZGF0YS1kYXRlPVwiJHtmb3JtYXRJc29Nb250aFN0cihkYXRlUHJvZmlsZS5jdXJyZW50RGF0ZSl9LTAxXCJdYCk7XG4gICAgICAgIC8vIGV2ZW4gaWYgdmlldyBpcyBtb250aC1iYXNlZCwgZmlyc3Qtb2YtbW9udGggbWlnaHQgYmUgaGlkZGVuLi4uXG4gICAgfVxuICAgIGlmICghZWwpIHtcbiAgICAgICAgZWwgPSBjb250YWluZXJFbC5xdWVyeVNlbGVjdG9yKGBbZGF0YS1kYXRlPVwiJHtmb3JtYXREYXlTdHJpbmcoZGF0ZVByb2ZpbGUuY3VycmVudERhdGUpfVwiXWApO1xuICAgICAgICAvLyBjb3VsZCBzdGlsbCBiZSBoaWRkZW4gaWYgYW4gaW50ZXJpb3ItdmlldyBoaWRkZW4gZGF5XG4gICAgfVxuICAgIHJldHVybiBlbDtcbn1cblxuY2xhc3MgRGF5VGFibGVTbGljZXIgZXh0ZW5kcyBTbGljZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmZvcmNlRGF5SWZMaXN0SXRlbSA9IHRydWU7XG4gICAgfVxuICAgIHNsaWNlUmFuZ2UoZGF0ZVJhbmdlLCBkYXlUYWJsZU1vZGVsKSB7XG4gICAgICAgIHJldHVybiBkYXlUYWJsZU1vZGVsLnNsaWNlUmFuZ2UoZGF0ZVJhbmdlKTtcbiAgICB9XG59XG5cbmNsYXNzIERheVRhYmxlIGV4dGVuZHMgRGF0ZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuc2xpY2VyID0gbmV3IERheVRhYmxlU2xpY2VyKCk7XG4gICAgICAgIHRoaXMudGFibGVSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFRhYmxlLCBPYmplY3QuYXNzaWduKHsgcmVmOiB0aGlzLnRhYmxlUmVmIH0sIHRoaXMuc2xpY2VyLnNsaWNlUHJvcHMocHJvcHMsIHByb3BzLmRhdGVQcm9maWxlLCBwcm9wcy5uZXh0RGF5VGhyZXNob2xkLCBjb250ZXh0LCBwcm9wcy5kYXlUYWJsZU1vZGVsKSwgeyBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIGNlbGxzOiBwcm9wcy5kYXlUYWJsZU1vZGVsLmNlbGxzLCBjb2xHcm91cE5vZGU6IHByb3BzLmNvbEdyb3VwTm9kZSwgdGFibGVNaW5XaWR0aDogcHJvcHMudGFibGVNaW5XaWR0aCwgcmVuZGVyUm93SW50cm86IHByb3BzLnJlbmRlclJvd0ludHJvLCBkYXlNYXhFdmVudHM6IHByb3BzLmRheU1heEV2ZW50cywgZGF5TWF4RXZlbnRSb3dzOiBwcm9wcy5kYXlNYXhFdmVudFJvd3MsIHNob3dXZWVrTnVtYmVyczogcHJvcHMuc2hvd1dlZWtOdW1iZXJzLCBleHBhbmRSb3dzOiBwcm9wcy5leHBhbmRSb3dzLCBoZWFkZXJBbGlnbkVsUmVmOiBwcm9wcy5oZWFkZXJBbGlnbkVsUmVmLCBjbGllbnRXaWR0aDogcHJvcHMuY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodDogcHJvcHMuY2xpZW50SGVpZ2h0LCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQgfSkpKTtcbiAgICB9XG59XG5cbmNsYXNzIERheVRhYmxlVmlldyBleHRlbmRzIFRhYmxlVmlldyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuYnVpbGREYXlUYWJsZU1vZGVsID0gbWVtb2l6ZShidWlsZERheVRhYmxlTW9kZWwpO1xuICAgICAgICB0aGlzLmhlYWRlclJlZiA9IGNyZWF0ZVJlZigpO1xuICAgICAgICB0aGlzLnRhYmxlUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIC8vIGNhbid0IG92ZXJyaWRlIGFueSBsaWZlY3ljbGUgbWV0aG9kcyBmcm9tIHBhcmVudFxuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IG9wdGlvbnMsIGRhdGVQcm9maWxlR2VuZXJhdG9yIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgZGF5VGFibGVNb2RlbCA9IHRoaXMuYnVpbGREYXlUYWJsZU1vZGVsKHByb3BzLmRhdGVQcm9maWxlLCBkYXRlUHJvZmlsZUdlbmVyYXRvcik7XG4gICAgICAgIGxldCBoZWFkZXJDb250ZW50ID0gb3B0aW9ucy5kYXlIZWFkZXJzICYmIChjcmVhdGVFbGVtZW50KERheUhlYWRlciwgeyByZWY6IHRoaXMuaGVhZGVyUmVmLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIGRhdGVzOiBkYXlUYWJsZU1vZGVsLmhlYWRlckRhdGVzLCBkYXRlc1JlcERpc3RpbmN0RGF5czogZGF5VGFibGVNb2RlbC5yb3dDbnQgPT09IDEgfSkpO1xuICAgICAgICBsZXQgYm9keUNvbnRlbnQgPSAoY29udGVudEFyZykgPT4gKGNyZWF0ZUVsZW1lbnQoRGF5VGFibGUsIHsgcmVmOiB0aGlzLnRhYmxlUmVmLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIGRheVRhYmxlTW9kZWw6IGRheVRhYmxlTW9kZWwsIGJ1c2luZXNzSG91cnM6IHByb3BzLmJ1c2luZXNzSG91cnMsIGRhdGVTZWxlY3Rpb246IHByb3BzLmRhdGVTZWxlY3Rpb24sIGV2ZW50U3RvcmU6IHByb3BzLmV2ZW50U3RvcmUsIGV2ZW50VWlCYXNlczogcHJvcHMuZXZlbnRVaUJhc2VzLCBldmVudFNlbGVjdGlvbjogcHJvcHMuZXZlbnRTZWxlY3Rpb24sIGV2ZW50RHJhZzogcHJvcHMuZXZlbnREcmFnLCBldmVudFJlc2l6ZTogcHJvcHMuZXZlbnRSZXNpemUsIG5leHREYXlUaHJlc2hvbGQ6IG9wdGlvbnMubmV4dERheVRocmVzaG9sZCwgY29sR3JvdXBOb2RlOiBjb250ZW50QXJnLnRhYmxlQ29sR3JvdXBOb2RlLCB0YWJsZU1pbldpZHRoOiBjb250ZW50QXJnLnRhYmxlTWluV2lkdGgsIGRheU1heEV2ZW50czogb3B0aW9ucy5kYXlNYXhFdmVudHMsIGRheU1heEV2ZW50Um93czogb3B0aW9ucy5kYXlNYXhFdmVudFJvd3MsIHNob3dXZWVrTnVtYmVyczogb3B0aW9ucy53ZWVrTnVtYmVycywgZXhwYW5kUm93czogIXByb3BzLmlzSGVpZ2h0QXV0bywgaGVhZGVyQWxpZ25FbFJlZjogdGhpcy5oZWFkZXJFbFJlZiwgY2xpZW50V2lkdGg6IGNvbnRlbnRBcmcuY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodDogY29udGVudEFyZy5jbGllbnRIZWlnaHQsIGZvclByaW50OiBwcm9wcy5mb3JQcmludCB9KSk7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmRheU1pbldpZHRoXG4gICAgICAgICAgICA/IHRoaXMucmVuZGVySFNjcm9sbExheW91dChoZWFkZXJDb250ZW50LCBib2R5Q29udGVudCwgZGF5VGFibGVNb2RlbC5jb2xDbnQsIG9wdGlvbnMuZGF5TWluV2lkdGgpXG4gICAgICAgICAgICA6IHRoaXMucmVuZGVyU2ltcGxlTGF5b3V0KGhlYWRlckNvbnRlbnQsIGJvZHlDb250ZW50KTtcbiAgICB9XG59XG5mdW5jdGlvbiBidWlsZERheVRhYmxlTW9kZWwoZGF0ZVByb2ZpbGUsIGRhdGVQcm9maWxlR2VuZXJhdG9yKSB7XG4gICAgbGV0IGRheVNlcmllcyA9IG5ldyBEYXlTZXJpZXNNb2RlbChkYXRlUHJvZmlsZS5yZW5kZXJSYW5nZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IpO1xuICAgIHJldHVybiBuZXcgRGF5VGFibGVNb2RlbChkYXlTZXJpZXMsIC95ZWFyfG1vbnRofHdlZWsvLnRlc3QoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdCkpO1xufVxuXG5jbGFzcyBUYWJsZURhdGVQcm9maWxlR2VuZXJhdG9yIGV4dGVuZHMgRGF0ZVByb2ZpbGVHZW5lcmF0b3Ige1xuICAgIC8vIENvbXB1dGVzIHRoZSBkYXRlIHJhbmdlIHRoYXQgd2lsbCBiZSByZW5kZXJlZFxuICAgIGJ1aWxkUmVuZGVyUmFuZ2UoY3VycmVudFJhbmdlLCBjdXJyZW50UmFuZ2VVbml0LCBpc1JhbmdlQWxsRGF5KSB7XG4gICAgICAgIGxldCByZW5kZXJSYW5nZSA9IHN1cGVyLmJ1aWxkUmVuZGVyUmFuZ2UoY3VycmVudFJhbmdlLCBjdXJyZW50UmFuZ2VVbml0LCBpc1JhbmdlQWxsRGF5KTtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBidWlsZERheVRhYmxlUmVuZGVyUmFuZ2Uoe1xuICAgICAgICAgICAgY3VycmVudFJhbmdlOiByZW5kZXJSYW5nZSxcbiAgICAgICAgICAgIHNuYXBUb1dlZWs6IC9eKHllYXJ8bW9udGgpJC8udGVzdChjdXJyZW50UmFuZ2VVbml0KSxcbiAgICAgICAgICAgIGZpeGVkV2Vla0NvdW50OiBwcm9wcy5maXhlZFdlZWtDb3VudCxcbiAgICAgICAgICAgIGRhdGVFbnY6IHByb3BzLmRhdGVFbnYsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkRGF5VGFibGVSZW5kZXJSYW5nZShwcm9wcykge1xuICAgIGxldCB7IGRhdGVFbnYsIGN1cnJlbnRSYW5nZSB9ID0gcHJvcHM7XG4gICAgbGV0IHsgc3RhcnQsIGVuZCB9ID0gY3VycmVudFJhbmdlO1xuICAgIGxldCBlbmRPZldlZWs7XG4gICAgLy8geWVhciBhbmQgbW9udGggdmlld3Mgc2hvdWxkIGJlIGFsaWduZWQgd2l0aCB3ZWVrcy4gdGhpcyBpcyBhbHJlYWR5IGRvbmUgZm9yIHdlZWtcbiAgICBpZiAocHJvcHMuc25hcFRvV2Vlaykge1xuICAgICAgICBzdGFydCA9IGRhdGVFbnYuc3RhcnRPZldlZWsoc3RhcnQpO1xuICAgICAgICAvLyBtYWtlIGVuZC1vZi13ZWVrIGlmIG5vdCBhbHJlYWR5XG4gICAgICAgIGVuZE9mV2VlayA9IGRhdGVFbnYuc3RhcnRPZldlZWsoZW5kKTtcbiAgICAgICAgaWYgKGVuZE9mV2Vlay52YWx1ZU9mKCkgIT09IGVuZC52YWx1ZU9mKCkpIHtcbiAgICAgICAgICAgIGVuZCA9IGFkZFdlZWtzKGVuZE9mV2VlaywgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZW5zdXJlIDYgd2Vla3NcbiAgICBpZiAocHJvcHMuZml4ZWRXZWVrQ291bnQpIHtcbiAgICAgICAgLy8gVE9ETzogaW5zdGVhZCBvZiB0aGVzZSBkYXRlLW1hdGggZ3ltbmFzdGljcyAoZm9yIG11bHRpbW9udGggdmlldyksXG4gICAgICAgIC8vIGNvbXB1dGUgZGF0ZXByb2ZpbGVzIG9mIGFsbCBtb250aHMsIHRoZW4gdXNlIHN0YXJ0IG9mIGZpcnN0IGFuZCBlbmQgb2YgbGFzdC5cbiAgICAgICAgbGV0IGxhc3RNb250aFJlbmRlclN0YXJ0ID0gZGF0ZUVudi5zdGFydE9mV2VlayhkYXRlRW52LnN0YXJ0T2ZNb250aChhZGREYXlzKGN1cnJlbnRSYW5nZS5lbmQsIC0xKSkpO1xuICAgICAgICBsZXQgcm93Q250ID0gTWF0aC5jZWlsKC8vIGNvdWxkIGJlIHBhcnRpYWwgd2Vla3MgZHVlIHRvIGhpZGRlbkRheXNcbiAgICAgICAgZGlmZldlZWtzKGxhc3RNb250aFJlbmRlclN0YXJ0LCBlbmQpKTtcbiAgICAgICAgZW5kID0gYWRkV2Vla3MoZW5kLCA2IC0gcm93Q250KTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhcnQsIGVuZCB9O1xufVxuXG52YXIgY3NzXzI0OHogPSBcIjpyb290ey0tZmMtZGF5Z3JpZC1ldmVudC1kb3Qtd2lkdGg6OHB4fS5mYy1kYXlncmlkLWRheS1ldmVudHM6YWZ0ZXIsLmZjLWRheWdyaWQtZGF5LWV2ZW50czpiZWZvcmUsLmZjLWRheWdyaWQtZGF5LWZyYW1lOmFmdGVyLC5mYy1kYXlncmlkLWRheS1mcmFtZTpiZWZvcmUsLmZjLWRheWdyaWQtZXZlbnQtaGFybmVzczphZnRlciwuZmMtZGF5Z3JpZC1ldmVudC1oYXJuZXNzOmJlZm9yZXtjbGVhcjpib3RoO2NvbnRlbnQ6XFxcIlxcXCI7ZGlzcGxheTp0YWJsZX0uZmMgLmZjLWRheWdyaWQtYm9keXtwb3NpdGlvbjpyZWxhdGl2ZTt6LWluZGV4OjF9LmZjIC5mYy1kYXlncmlkLWRheS5mYy1kYXktdG9kYXl7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1mYy10b2RheS1iZy1jb2xvcil9LmZjIC5mYy1kYXlncmlkLWRheS1mcmFtZXttaW4taGVpZ2h0OjEwMCU7cG9zaXRpb246cmVsYXRpdmV9LmZjIC5mYy1kYXlncmlkLWRheS10b3B7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOnJvdy1yZXZlcnNlfS5mYyAuZmMtZGF5LW90aGVyIC5mYy1kYXlncmlkLWRheS10b3B7b3BhY2l0eTouM30uZmMgLmZjLWRheWdyaWQtZGF5LW51bWJlcntwYWRkaW5nOjRweDtwb3NpdGlvbjpyZWxhdGl2ZTt6LWluZGV4OjR9LmZjIC5mYy1kYXlncmlkLW1vbnRoLXN0YXJ0e2ZvbnQtc2l6ZToxLjFlbTtmb250LXdlaWdodDo3MDB9LmZjIC5mYy1kYXlncmlkLWRheS1ldmVudHN7bWFyZ2luLXRvcDoxcHh9LmZjIC5mYy1kYXlncmlkLWJvZHktYmFsYW5jZWQgLmZjLWRheWdyaWQtZGF5LWV2ZW50c3tsZWZ0OjA7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MH0uZmMgLmZjLWRheWdyaWQtYm9keS11bmJhbGFuY2VkIC5mYy1kYXlncmlkLWRheS1ldmVudHN7bWluLWhlaWdodDoyZW07cG9zaXRpb246cmVsYXRpdmV9LmZjIC5mYy1kYXlncmlkLWJvZHktbmF0dXJhbCAuZmMtZGF5Z3JpZC1kYXktZXZlbnRze21hcmdpbi1ib3R0b206MWVtfS5mYyAuZmMtZGF5Z3JpZC1ldmVudC1oYXJuZXNze3Bvc2l0aW9uOnJlbGF0aXZlfS5mYyAuZmMtZGF5Z3JpZC1ldmVudC1oYXJuZXNzLWFic3tsZWZ0OjA7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MDt0b3A6MH0uZmMgLmZjLWRheWdyaWQtYmctaGFybmVzc3tib3R0b206MDtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MH0uZmMgLmZjLWRheWdyaWQtZGF5LWJnIC5mYy1ub24tYnVzaW5lc3N7ei1pbmRleDoxfS5mYyAuZmMtZGF5Z3JpZC1kYXktYmcgLmZjLWJnLWV2ZW50e3otaW5kZXg6Mn0uZmMgLmZjLWRheWdyaWQtZGF5LWJnIC5mYy1oaWdobGlnaHR7ei1pbmRleDozfS5mYyAuZmMtZGF5Z3JpZC1ldmVudHttYXJnaW4tdG9wOjFweDt6LWluZGV4OjZ9LmZjIC5mYy1kYXlncmlkLWV2ZW50LmZjLWV2ZW50LW1pcnJvcnt6LWluZGV4Ojd9LmZjIC5mYy1kYXlncmlkLWRheS1ib3R0b217Zm9udC1zaXplOi44NWVtO21hcmdpbjowIDJweH0uZmMgLmZjLWRheWdyaWQtZGF5LWJvdHRvbTphZnRlciwuZmMgLmZjLWRheWdyaWQtZGF5LWJvdHRvbTpiZWZvcmV7Y2xlYXI6Ym90aDtjb250ZW50OlxcXCJcXFwiO2Rpc3BsYXk6dGFibGV9LmZjIC5mYy1kYXlncmlkLW1vcmUtbGlua3tib3JkZXItcmFkaXVzOjNweDtjdXJzb3I6cG9pbnRlcjtsaW5lLWhlaWdodDoxO21hcmdpbi10b3A6MXB4O21heC13aWR0aDoxMDAlO292ZXJmbG93OmhpZGRlbjtwYWRkaW5nOjJweDtwb3NpdGlvbjpyZWxhdGl2ZTt3aGl0ZS1zcGFjZTpub3dyYXA7ei1pbmRleDo0fS5mYyAuZmMtZGF5Z3JpZC1tb3JlLWxpbms6aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDAsMCwwLC4xKX0uZmMgLmZjLWRheWdyaWQtd2Vlay1udW1iZXJ7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1mYy1uZXV0cmFsLWJnLWNvbG9yKTtjb2xvcjp2YXIoLS1mYy1uZXV0cmFsLXRleHQtY29sb3IpO21pbi13aWR0aDoxLjVlbTtwYWRkaW5nOjJweDtwb3NpdGlvbjphYnNvbHV0ZTt0ZXh0LWFsaWduOmNlbnRlcjt0b3A6MDt6LWluZGV4OjV9LmZjIC5mYy1tb3JlLXBvcG92ZXIgLmZjLXBvcG92ZXItYm9keXttaW4td2lkdGg6MjIwcHg7cGFkZGluZzoxMHB4fS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1kYXlncmlkLWV2ZW50LmZjLWV2ZW50LXN0YXJ0LC5mYy1kaXJlY3Rpb24tcnRsIC5mYy1kYXlncmlkLWV2ZW50LmZjLWV2ZW50LWVuZHttYXJnaW4tbGVmdDoycHh9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLWRheWdyaWQtZXZlbnQuZmMtZXZlbnQtZW5kLC5mYy1kaXJlY3Rpb24tcnRsIC5mYy1kYXlncmlkLWV2ZW50LmZjLWV2ZW50LXN0YXJ0e21hcmdpbi1yaWdodDoycHh9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLWRheWdyaWQtbW9yZS1saW5re2Zsb2F0OmxlZnR9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLWRheWdyaWQtd2Vlay1udW1iZXJ7Ym9yZGVyLXJhZGl1czowIDAgM3B4IDA7bGVmdDowfS5mYy1kaXJlY3Rpb24tcnRsIC5mYy1kYXlncmlkLW1vcmUtbGlua3tmbG9hdDpyaWdodH0uZmMtZGlyZWN0aW9uLXJ0bCAuZmMtZGF5Z3JpZC13ZWVrLW51bWJlcntib3JkZXItcmFkaXVzOjAgMCAwIDNweDtyaWdodDowfS5mYy1saXF1aWQtaGFjayAuZmMtZGF5Z3JpZC1kYXktZnJhbWV7cG9zaXRpb246c3RhdGljfS5mYy1kYXlncmlkLWV2ZW50e2JvcmRlci1yYWRpdXM6M3B4O2ZvbnQtc2l6ZTp2YXIoLS1mYy1zbWFsbC1mb250LXNpemUpO3Bvc2l0aW9uOnJlbGF0aXZlO3doaXRlLXNwYWNlOm5vd3JhcH0uZmMtZGF5Z3JpZC1ibG9jay1ldmVudCAuZmMtZXZlbnQtdGltZXtmb250LXdlaWdodDo3MDB9LmZjLWRheWdyaWQtYmxvY2stZXZlbnQgLmZjLWV2ZW50LXRpbWUsLmZjLWRheWdyaWQtYmxvY2stZXZlbnQgLmZjLWV2ZW50LXRpdGxle3BhZGRpbmc6MXB4fS5mYy1kYXlncmlkLWRvdC1ldmVudHthbGlnbi1pdGVtczpjZW50ZXI7ZGlzcGxheTpmbGV4O3BhZGRpbmc6MnB4IDB9LmZjLWRheWdyaWQtZG90LWV2ZW50IC5mYy1ldmVudC10aXRsZXtmbGV4LWdyb3c6MTtmbGV4LXNocmluazoxO2ZvbnQtd2VpZ2h0OjcwMDttaW4td2lkdGg6MDtvdmVyZmxvdzpoaWRkZW59LmZjLWRheWdyaWQtZG90LWV2ZW50LmZjLWV2ZW50LW1pcnJvciwuZmMtZGF5Z3JpZC1kb3QtZXZlbnQ6aG92ZXJ7YmFja2dyb3VuZDpyZ2JhKDAsMCwwLC4xKX0uZmMtZGF5Z3JpZC1kb3QtZXZlbnQuZmMtZXZlbnQtc2VsZWN0ZWQ6YmVmb3Jle2JvdHRvbTotMTBweDt0b3A6LTEwcHh9LmZjLWRheWdyaWQtZXZlbnQtZG90e2JvcmRlcjpjYWxjKHZhcigtLWZjLWRheWdyaWQtZXZlbnQtZG90LXdpZHRoKS8yKSBzb2xpZCB2YXIoLS1mYy1ldmVudC1ib3JkZXItY29sb3IpO2JvcmRlci1yYWRpdXM6Y2FsYyh2YXIoLS1mYy1kYXlncmlkLWV2ZW50LWRvdC13aWR0aCkvMik7Ym94LXNpemluZzpjb250ZW50LWJveDtoZWlnaHQ6MDttYXJnaW46MCA0cHg7d2lkdGg6MH0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtZGF5Z3JpZC1ldmVudCAuZmMtZXZlbnQtdGltZXttYXJnaW4tcmlnaHQ6M3B4fS5mYy1kaXJlY3Rpb24tcnRsIC5mYy1kYXlncmlkLWV2ZW50IC5mYy1ldmVudC10aW1le21hcmdpbi1sZWZ0OjNweH1cIjtcbmluamVjdFN0eWxlcyhjc3NfMjQ4eik7XG5cbmV4cG9ydCB7IERheVRhYmxlVmlldyBhcyBEYXlHcmlkVmlldywgRGF5VGFibGUsIERheVRhYmxlU2xpY2VyLCBUYWJsZSwgVGFibGVEYXRlUHJvZmlsZUdlbmVyYXRvciwgVGFibGVSb3dzLCBUYWJsZVZpZXcsIGJ1aWxkRGF5VGFibGVNb2RlbCwgYnVpbGREYXlUYWJsZVJlbmRlclJhbmdlIH07XG4iLCAiaW1wb3J0IHsgY3JlYXRlUGx1Z2luIH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb3JlL2luZGV4LmpzJztcbmltcG9ydCB7IERheUdyaWRWaWV3IGFzIERheVRhYmxlVmlldywgVGFibGVEYXRlUHJvZmlsZUdlbmVyYXRvciB9IGZyb20gJy4vaW50ZXJuYWwuanMnO1xuaW1wb3J0ICdAZnVsbGNhbGVuZGFyL2NvcmUvaW50ZXJuYWwuanMnO1xuaW1wb3J0ICdAZnVsbGNhbGVuZGFyL2NvcmUvcHJlYWN0LmpzJztcblxudmFyIGluZGV4ID0gY3JlYXRlUGx1Z2luKHtcbiAgICBuYW1lOiAnQGZ1bGxjYWxlbmRhci9kYXlncmlkJyxcbiAgICBpbml0aWFsVmlldzogJ2RheUdyaWRNb250aCcsXG4gICAgdmlld3M6IHtcbiAgICAgICAgZGF5R3JpZDoge1xuICAgICAgICAgICAgY29tcG9uZW50OiBEYXlUYWJsZVZpZXcsXG4gICAgICAgICAgICBkYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzOiBUYWJsZURhdGVQcm9maWxlR2VuZXJhdG9yLFxuICAgICAgICB9LFxuICAgICAgICBkYXlHcmlkRGF5OiB7XG4gICAgICAgICAgICB0eXBlOiAnZGF5R3JpZCcsXG4gICAgICAgICAgICBkdXJhdGlvbjogeyBkYXlzOiAxIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGRheUdyaWRXZWVrOiB7XG4gICAgICAgICAgICB0eXBlOiAnZGF5R3JpZCcsXG4gICAgICAgICAgICBkdXJhdGlvbjogeyB3ZWVrczogMSB9LFxuICAgICAgICB9LFxuICAgICAgICBkYXlHcmlkTW9udGg6IHtcbiAgICAgICAgICAgIHR5cGU6ICdkYXlHcmlkJyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB7IG1vbnRoczogMSB9LFxuICAgICAgICAgICAgZml4ZWRXZWVrQ291bnQ6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIGRheUdyaWRZZWFyOiB7XG4gICAgICAgICAgICB0eXBlOiAnZGF5R3JpZCcsXG4gICAgICAgICAgICBkdXJhdGlvbjogeyB5ZWFyczogMSB9LFxuICAgICAgICB9LFxuICAgIH0sXG59KTtcblxuZXhwb3J0IHsgaW5kZXggYXMgZGVmYXVsdCB9O1xuIiwgImltcG9ydCB7IFNwbGl0dGVyLCBoYXNCZ1JlbmRlcmluZywgY3JlYXRlRm9ybWF0dGVyLCBWaWV3Q29udGV4dFR5cGUsIENvbnRlbnRDb250YWluZXIsIEJhc2VDb21wb25lbnQsIERhdGVDb21wb25lbnQsIGRpZmZEYXlzLCBidWlsZE5hdkxpbmtBdHRycywgV2Vla051bWJlckNvbnRhaW5lciwgZ2V0U3RpY2t5SGVhZGVyRGF0ZXMsIFZpZXdDb250YWluZXIsIFNpbXBsZVNjcm9sbEdyaWQsIGdldFN0aWNreUZvb3RlclNjcm9sbGJhciwgTm93VGltZXIsIE5vd0luZGljYXRvckNvbnRhaW5lciwgcmVuZGVyU2Nyb2xsU2hpbSwgcmFuZ2VDb250YWluc01hcmtlciwgc3RhcnRPZkRheSwgYXNSb3VnaE1zLCBjcmVhdGVEdXJhdGlvbiwgUmVmTWFwLCBQb3NpdGlvbkNhY2hlLCBNb3JlTGlua0NvbnRhaW5lciwgU2VnSGllcmFyY2h5LCBncm91cEludGVyc2VjdGluZ0VudHJpZXMsIGJpbmFyeVNlYXJjaCwgZ2V0RW50cnlTcGFuRW5kLCBidWlsZEVudHJ5S2V5LCBTdGFuZGFyZEV2ZW50LCBtZW1vaXplLCBzb3J0RXZlbnRTZWdzLCBEYXlDZWxsQ29udGFpbmVyLCBoYXNDdXN0b21EYXlDZWxsQ29udGVudCwgZ2V0U2VnTWV0YSwgYnVpbGRJc29TdHJpbmcsIGNvbXB1dGVFYXJsaWVzdFNlZ1N0YXJ0LCBidWlsZEV2ZW50UmFuZ2VLZXksIEJnRXZlbnQsIHJlbmRlckZpbGwsIGFkZER1cmF0aW9ucywgbXVsdGlwbHlEdXJhdGlvbiwgd2hvbGVEaXZpZGVEdXJhdGlvbnMsIFNsaWNlciwgaW50ZXJzZWN0UmFuZ2VzLCBmb3JtYXRJc29UaW1lU3RyaW5nLCBEYXlIZWFkZXIsIERheVNlcmllc01vZGVsLCBEYXlUYWJsZU1vZGVsLCBpbmplY3RTdHlsZXMgfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvcmUvaW50ZXJuYWwuanMnO1xuaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgY3JlYXRlUmVmLCBGcmFnbWVudCB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29yZS9wcmVhY3QuanMnO1xuaW1wb3J0IHsgRGF5VGFibGUgfSBmcm9tICdAZnVsbGNhbGVuZGFyL2RheWdyaWQvaW50ZXJuYWwuanMnO1xuXG5jbGFzcyBBbGxEYXlTcGxpdHRlciBleHRlbmRzIFNwbGl0dGVyIHtcbiAgICBnZXRLZXlJbmZvKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWxsRGF5OiB7fSxcbiAgICAgICAgICAgIHRpbWVkOiB7fSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0S2V5c0ZvckRhdGVTcGFuKGRhdGVTcGFuKSB7XG4gICAgICAgIGlmIChkYXRlU3Bhbi5hbGxEYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBbJ2FsbERheSddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbJ3RpbWVkJ107XG4gICAgfVxuICAgIGdldEtleXNGb3JFdmVudERlZihldmVudERlZikge1xuICAgICAgICBpZiAoIWV2ZW50RGVmLmFsbERheSkge1xuICAgICAgICAgICAgcmV0dXJuIFsndGltZWQnXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzQmdSZW5kZXJpbmcoZXZlbnREZWYpKSB7XG4gICAgICAgICAgICByZXR1cm4gWyd0aW1lZCcsICdhbGxEYXknXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWydhbGxEYXknXTtcbiAgICB9XG59XG5cbmNvbnN0IERFRkFVTFRfU0xBVF9MQUJFTF9GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoe1xuICAgIGhvdXI6ICdudW1lcmljJyxcbiAgICBtaW51dGU6ICcyLWRpZ2l0JyxcbiAgICBvbWl0WmVyb01pbnV0ZTogdHJ1ZSxcbiAgICBtZXJpZGllbTogJ3Nob3J0Jyxcbn0pO1xuZnVuY3Rpb24gVGltZUNvbHNBeGlzQ2VsbChwcm9wcykge1xuICAgIGxldCBjbGFzc05hbWVzID0gW1xuICAgICAgICAnZmMtdGltZWdyaWQtc2xvdCcsXG4gICAgICAgICdmYy10aW1lZ3JpZC1zbG90LWxhYmVsJyxcbiAgICAgICAgcHJvcHMuaXNMYWJlbGVkID8gJ2ZjLXNjcm9sbGdyaWQtc2hyaW5rJyA6ICdmYy10aW1lZ3JpZC1zbG90LW1pbm9yJyxcbiAgICBdO1xuICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChWaWV3Q29udGV4dFR5cGUuQ29uc3VtZXIsIG51bGwsIChjb250ZXh0KSA9PiB7XG4gICAgICAgIGlmICghcHJvcHMuaXNMYWJlbGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcy5qb2luKCcgJyksIFwiZGF0YS10aW1lXCI6IHByb3BzLmlzb1RpbWVTdHIgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IGRhdGVFbnYsIG9wdGlvbnMsIHZpZXdBcGkgfSA9IGNvbnRleHQ7XG4gICAgICAgIGxldCBsYWJlbEZvcm1hdCA9IC8vIFRPRE86IGZ1bGx5IHByZS1wYXJzZVxuICAgICAgICAgb3B0aW9ucy5zbG90TGFiZWxGb3JtYXQgPT0gbnVsbCA/IERFRkFVTFRfU0xBVF9MQUJFTF9GT1JNQVQgOlxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheShvcHRpb25zLnNsb3RMYWJlbEZvcm1hdCkgPyBjcmVhdGVGb3JtYXR0ZXIob3B0aW9ucy5zbG90TGFiZWxGb3JtYXRbMF0pIDpcbiAgICAgICAgICAgICAgICBjcmVhdGVGb3JtYXR0ZXIob3B0aW9ucy5zbG90TGFiZWxGb3JtYXQpO1xuICAgICAgICBsZXQgcmVuZGVyUHJvcHMgPSB7XG4gICAgICAgICAgICBsZXZlbDogMCxcbiAgICAgICAgICAgIHRpbWU6IHByb3BzLnRpbWUsXG4gICAgICAgICAgICBkYXRlOiBkYXRlRW52LnRvRGF0ZShwcm9wcy5kYXRlKSxcbiAgICAgICAgICAgIHZpZXc6IHZpZXdBcGksXG4gICAgICAgICAgICB0ZXh0OiBkYXRlRW52LmZvcm1hdChwcm9wcy5kYXRlLCBsYWJlbEZvcm1hdCksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChDb250ZW50Q29udGFpbmVyLCB7IGVsVGFnOiBcInRkXCIsIGVsQ2xhc3NlczogY2xhc3NOYW1lcywgZWxBdHRyczoge1xuICAgICAgICAgICAgICAgICdkYXRhLXRpbWUnOiBwcm9wcy5pc29UaW1lU3RyLFxuICAgICAgICAgICAgfSwgcmVuZGVyUHJvcHM6IHJlbmRlclByb3BzLCBnZW5lcmF0b3JOYW1lOiBcInNsb3RMYWJlbENvbnRlbnRcIiwgY3VzdG9tR2VuZXJhdG9yOiBvcHRpb25zLnNsb3RMYWJlbENvbnRlbnQsIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlcklubmVyQ29udGVudCwgY2xhc3NOYW1lR2VuZXJhdG9yOiBvcHRpb25zLnNsb3RMYWJlbENsYXNzTmFtZXMsIGRpZE1vdW50OiBvcHRpb25zLnNsb3RMYWJlbERpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy5zbG90TGFiZWxXaWxsVW5tb3VudCB9LCAoSW5uZXJDb250ZW50KSA9PiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1zbG90LWxhYmVsLWZyYW1lIGZjLXNjcm9sbGdyaWQtc2hyaW5rLWZyYW1lXCIgfSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoSW5uZXJDb250ZW50LCB7IGVsVGFnOiBcImRpdlwiLCBlbENsYXNzZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2ZjLXRpbWVncmlkLXNsb3QtbGFiZWwtY3VzaGlvbicsXG4gICAgICAgICAgICAgICAgICAgICdmYy1zY3JvbGxncmlkLXNocmluay1jdXNoaW9uJyxcbiAgICAgICAgICAgICAgICBdIH0pKSkpKTtcbiAgICB9KSk7XG59XG5mdW5jdGlvbiByZW5kZXJJbm5lckNvbnRlbnQocHJvcHMpIHtcbiAgICByZXR1cm4gcHJvcHMudGV4dDtcbn1cblxuY2xhc3MgVGltZUJvZHlBeGlzIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5zbGF0TWV0YXMubWFwKChzbGF0TWV0YSkgPT4gKGNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IGtleTogc2xhdE1ldGEua2V5IH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFRpbWVDb2xzQXhpc0NlbGwsIE9iamVjdC5hc3NpZ24oe30sIHNsYXRNZXRhKSkpKSk7XG4gICAgfVxufVxuXG5jb25zdCBERUZBVUxUX1dFRUtfTlVNX0ZPUk1BVCA9IGNyZWF0ZUZvcm1hdHRlcih7IHdlZWs6ICdzaG9ydCcgfSk7XG5jb25zdCBBVVRPX0FMTF9EQVlfTUFYX0VWRU5UX1JPV1MgPSA1O1xuY2xhc3MgVGltZUNvbHNWaWV3IGV4dGVuZHMgRGF0ZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuYWxsRGF5U3BsaXR0ZXIgPSBuZXcgQWxsRGF5U3BsaXR0ZXIoKTsgLy8gZm9yIHVzZSBieSBzdWJjbGFzc2VzXG4gICAgICAgIHRoaXMuaGVhZGVyRWxSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICAgICAgdGhpcy5yb290RWxSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICAgICAgdGhpcy5zY3JvbGxlckVsUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBzbGF0Q29vcmRzOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVNjcm9sbFRvcFJlcXVlc3QgPSAoc2Nyb2xsVG9wKSA9PiB7XG4gICAgICAgICAgICBsZXQgc2Nyb2xsZXJFbCA9IHRoaXMuc2Nyb2xsZXJFbFJlZi5jdXJyZW50O1xuICAgICAgICAgICAgaWYgKHNjcm9sbGVyRWwpIHsgLy8gVE9ETzogbm90IHN1cmUgaG93IHRoaXMgY291bGQgZXZlciBiZSBudWxsLiB3ZWlyZG5lc3Mgd2l0aCB0aGUgcmVkdWNlclxuICAgICAgICAgICAgICAgIHNjcm9sbGVyRWwuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiBIZWFkZXIgUmVuZGVyIE1ldGhvZHNcbiAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgICAgICAgdGhpcy5yZW5kZXJIZWFkQXhpcyA9IChyb3dLZXksIGZyYW1lSGVpZ2h0ID0gJycpID0+IHtcbiAgICAgICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgICAgIGxldCB7IGRhdGVQcm9maWxlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gZGF0ZVByb2ZpbGUucmVuZGVyUmFuZ2U7XG4gICAgICAgICAgICBsZXQgZGF5Q250ID0gZGlmZkRheXMocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCk7XG4gICAgICAgICAgICAvLyBvbmx5IGRvIGluIGRheSB2aWV3cyAodG8gYXZvaWQgZG9pbmcgaW4gd2VlayB2aWV3cyB0aGF0IGRvbnQgbmVlZCBpdClcbiAgICAgICAgICAgIGxldCBuYXZMaW5rQXR0cnMgPSAoZGF5Q250ID09PSAxKVxuICAgICAgICAgICAgICAgID8gYnVpbGROYXZMaW5rQXR0cnModGhpcy5jb250ZXh0LCByYW5nZS5zdGFydCwgJ3dlZWsnKVxuICAgICAgICAgICAgICAgIDoge307XG4gICAgICAgICAgICBpZiAob3B0aW9ucy53ZWVrTnVtYmVycyAmJiByb3dLZXkgPT09ICdkYXknKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFdlZWtOdW1iZXJDb250YWluZXIsIHsgZWxUYWc6IFwidGhcIiwgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmMtdGltZWdyaWQtYXhpcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmMtc2Nyb2xsZ3JpZC1zaHJpbmsnLFxuICAgICAgICAgICAgICAgICAgICBdLCBlbEF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnYXJpYS1oaWRkZW4nOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9LCBkYXRlOiByYW5nZS5zdGFydCwgZGVmYXVsdEZvcm1hdDogREVGQVVMVF9XRUVLX05VTV9GT1JNQVQgfSwgKElubmVyQ29udGVudCkgPT4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdmYy10aW1lZ3JpZC1heGlzLWZyYW1lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmYy1zY3JvbGxncmlkLXNocmluay1mcmFtZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmMtdGltZWdyaWQtYXhpcy1mcmFtZS1saXF1aWQnLFxuICAgICAgICAgICAgICAgICAgICBdLmpvaW4oJyAnKSwgc3R5bGU6IHsgaGVpZ2h0OiBmcmFtZUhlaWdodCB9IH0sXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoSW5uZXJDb250ZW50LCB7IGVsVGFnOiBcImFcIiwgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLXRpbWVncmlkLWF4aXMtY3VzaGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLXNjcm9sbGdyaWQtc2hyaW5rLWN1c2hpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdmYy1zY3JvbGxncmlkLXN5bmMtaW5uZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgXSwgZWxBdHRyczogbmF2TGlua0F0dHJzIH0pKSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcInRoXCIsIHsgXCJhcmlhLWhpZGRlblwiOiB0cnVlLCBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtYXhpc1wiIH0sXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1heGlzLWZyYW1lXCIsIHN0eWxlOiB7IGhlaWdodDogZnJhbWVIZWlnaHQgfSB9KSkpO1xuICAgICAgICB9O1xuICAgICAgICAvKiBUYWJsZSBDb21wb25lbnQgUmVuZGVyIE1ldGhvZHNcbiAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgICAgICAgLy8gb25seSBhIG9uZS13YXkgaGVpZ2h0IHN5bmMuIHdlIGRvbid0IHNlbmQgdGhlIGF4aXMgaW5uZXItY29udGVudCBoZWlnaHQgdG8gdGhlIERheUdyaWQsXG4gICAgICAgIC8vIGJ1dCBEYXlHcmlkIHN0aWxsIG5lZWRzIHRvIGhhdmUgY2xhc3NOYW1lcyBvbiBpbm5lciBlbGVtZW50cyBpbiBvcmRlciB0byBtZWFzdXJlLlxuICAgICAgICB0aGlzLnJlbmRlclRhYmxlUm93QXhpcyA9IChyb3dIZWlnaHQpID0+IHtcbiAgICAgICAgICAgIGxldCB7IG9wdGlvbnMsIHZpZXdBcGkgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgICAgIGxldCByZW5kZXJQcm9wcyA9IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBvcHRpb25zLmFsbERheVRleHQsXG4gICAgICAgICAgICAgICAgdmlldzogdmlld0FwaSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgLy8gVE9ETzogbWFrZSByZXVzYWJsZSBob29rLiB1c2VkIGluIGxpc3QgdmlldyB0b29cbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoQ29udGVudENvbnRhaW5lciwgeyBlbFRhZzogXCJ0ZFwiLCBlbENsYXNzZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2ZjLXRpbWVncmlkLWF4aXMnLFxuICAgICAgICAgICAgICAgICAgICAnZmMtc2Nyb2xsZ3JpZC1zaHJpbmsnLFxuICAgICAgICAgICAgICAgIF0sIGVsQXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2FyaWEtaGlkZGVuJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9LCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGdlbmVyYXRvck5hbWU6IFwiYWxsRGF5Q29udGVudFwiLCBjdXN0b21HZW5lcmF0b3I6IG9wdGlvbnMuYWxsRGF5Q29udGVudCwgZGVmYXVsdEdlbmVyYXRvcjogcmVuZGVyQWxsRGF5SW5uZXIsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy5hbGxEYXlDbGFzc05hbWVzLCBkaWRNb3VudDogb3B0aW9ucy5hbGxEYXlEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMuYWxsRGF5V2lsbFVubW91bnQgfSwgKElubmVyQ29udGVudCkgPT4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2ZjLXRpbWVncmlkLWF4aXMtZnJhbWUnLFxuICAgICAgICAgICAgICAgICAgICAnZmMtc2Nyb2xsZ3JpZC1zaHJpbmstZnJhbWUnLFxuICAgICAgICAgICAgICAgICAgICByb3dIZWlnaHQgPT0gbnVsbCA/ICcgZmMtdGltZWdyaWQtYXhpcy1mcmFtZS1saXF1aWQnIDogJycsXG4gICAgICAgICAgICAgICAgXS5qb2luKCcgJyksIHN0eWxlOiB7IGhlaWdodDogcm93SGVpZ2h0IH0gfSxcbiAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KElubmVyQ29udGVudCwgeyBlbFRhZzogXCJzcGFuXCIsIGVsQ2xhc3NlczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLXRpbWVncmlkLWF4aXMtY3VzaGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmMtc2Nyb2xsZ3JpZC1zaHJpbmstY3VzaGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmMtc2Nyb2xsZ3JpZC1zeW5jLWlubmVyJyxcbiAgICAgICAgICAgICAgICAgICAgXSB9KSkpKSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlU2xhdENvb3JkcyA9IChzbGF0Q29vcmRzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgc2xhdENvb3JkcyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gcmVuZGVyaW5nXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHJlbmRlclNpbXBsZUxheW91dChoZWFkZXJSb3dDb250ZW50LCBhbGxEYXlDb250ZW50LCB0aW1lQ29udGVudCkge1xuICAgICAgICBsZXQgeyBjb250ZXh0LCBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHNlY3Rpb25zID0gW107XG4gICAgICAgIGxldCBzdGlja3lIZWFkZXJEYXRlcyA9IGdldFN0aWNreUhlYWRlckRhdGVzKGNvbnRleHQub3B0aW9ucyk7XG4gICAgICAgIGlmIChoZWFkZXJSb3dDb250ZW50KSB7XG4gICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaGVhZGVyJyxcbiAgICAgICAgICAgICAgICBrZXk6ICdoZWFkZXInLFxuICAgICAgICAgICAgICAgIGlzU3RpY2t5OiBzdGlja3lIZWFkZXJEYXRlcyxcbiAgICAgICAgICAgICAgICBjaHVuazoge1xuICAgICAgICAgICAgICAgICAgICBlbFJlZjogdGhpcy5oZWFkZXJFbFJlZixcbiAgICAgICAgICAgICAgICAgICAgdGFibGVDbGFzc05hbWU6ICdmYy1jb2wtaGVhZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgcm93Q29udGVudDogaGVhZGVyUm93Q29udGVudCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsbERheUNvbnRlbnQpIHtcbiAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdib2R5JyxcbiAgICAgICAgICAgICAgICBrZXk6ICdhbGwtZGF5JyxcbiAgICAgICAgICAgICAgICBjaHVuazogeyBjb250ZW50OiBhbGxEYXlDb250ZW50IH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdib2R5JyxcbiAgICAgICAgICAgICAgICBrZXk6ICdhbGwtZGF5LWRpdmlkZXInLFxuICAgICAgICAgICAgICAgIG91dGVyQ29udGVudDogKCAvLyBUT0RPOiByZW5hbWUgdG8gY2VsbENvbnRlbnQgc28gZG9uJ3QgbmVlZCB0byBkZWZpbmUgPHRyPj9cbiAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwidHJcIiwgeyByb2xlOiBcInByZXNlbnRhdGlvblwiLCBjbGFzc05hbWU6IFwiZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRkXCIsIHsgY2xhc3NOYW1lOiAnZmMtdGltZWdyaWQtZGl2aWRlciAnICsgY29udGV4dC50aGVtZS5nZXRDbGFzcygndGFibGVDZWxsU2hhZGVkJykgfSkpKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ2JvZHknLFxuICAgICAgICAgICAga2V5OiAnYm9keScsXG4gICAgICAgICAgICBsaXF1aWQ6IHRydWUsXG4gICAgICAgICAgICBleHBhbmRSb3dzOiBCb29sZWFuKGNvbnRleHQub3B0aW9ucy5leHBhbmRSb3dzKSxcbiAgICAgICAgICAgIGNodW5rOiB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsZXJFbFJlZjogdGhpcy5zY3JvbGxlckVsUmVmLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRpbWVDb250ZW50LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChWaWV3Q29udGFpbmVyLCB7IGVsUmVmOiB0aGlzLnJvb3RFbFJlZiwgZWxDbGFzc2VzOiBbJ2ZjLXRpbWVncmlkJ10sIHZpZXdTcGVjOiBjb250ZXh0LnZpZXdTcGVjIH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFNpbXBsZVNjcm9sbEdyaWQsIHsgbGlxdWlkOiAhcHJvcHMuaXNIZWlnaHRBdXRvICYmICFwcm9wcy5mb3JQcmludCwgY29sbGFwc2libGVXaWR0aDogcHJvcHMuZm9yUHJpbnQsIGNvbHM6IFt7IHdpZHRoOiAnc2hyaW5rJyB9XSwgc2VjdGlvbnM6IHNlY3Rpb25zIH0pKSk7XG4gICAgfVxuICAgIHJlbmRlckhTY3JvbGxMYXlvdXQoaGVhZGVyUm93Q29udGVudCwgYWxsRGF5Q29udGVudCwgdGltZUNvbnRlbnQsIGNvbENudCwgZGF5TWluV2lkdGgsIHNsYXRNZXRhcywgc2xhdENvb3Jkcykge1xuICAgICAgICBsZXQgU2Nyb2xsR3JpZCA9IHRoaXMuY29udGV4dC5wbHVnaW5Ib29rcy5zY3JvbGxHcmlkSW1wbDtcbiAgICAgICAgaWYgKCFTY3JvbGxHcmlkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIFNjcm9sbEdyaWQgaW1wbGVtZW50YXRpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBjb250ZXh0LCBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHN0aWNreUhlYWRlckRhdGVzID0gIXByb3BzLmZvclByaW50ICYmIGdldFN0aWNreUhlYWRlckRhdGVzKGNvbnRleHQub3B0aW9ucyk7XG4gICAgICAgIGxldCBzdGlja3lGb290ZXJTY3JvbGxiYXIgPSAhcHJvcHMuZm9yUHJpbnQgJiYgZ2V0U3RpY2t5Rm9vdGVyU2Nyb2xsYmFyKGNvbnRleHQub3B0aW9ucyk7XG4gICAgICAgIGxldCBzZWN0aW9ucyA9IFtdO1xuICAgICAgICBpZiAoaGVhZGVyUm93Q29udGVudCkge1xuICAgICAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2hlYWRlcicsXG4gICAgICAgICAgICAgICAga2V5OiAnaGVhZGVyJyxcbiAgICAgICAgICAgICAgICBpc1N0aWNreTogc3RpY2t5SGVhZGVyRGF0ZXMsXG4gICAgICAgICAgICAgICAgc3luY1Jvd0hlaWdodHM6IHRydWUsXG4gICAgICAgICAgICAgICAgY2h1bmtzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ2F4aXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm93Q29udGVudDogKGFyZykgPT4gKGNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IHJvbGU6IFwicHJlc2VudGF0aW9uXCIgfSwgdGhpcy5yZW5kZXJIZWFkQXhpcygnZGF5JywgYXJnLnJvd1N5bmNIZWlnaHRzWzBdKSkpLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdjb2xzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsUmVmOiB0aGlzLmhlYWRlckVsUmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVDbGFzc05hbWU6ICdmYy1jb2wtaGVhZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0NvbnRlbnQ6IGhlYWRlclJvd0NvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbGxEYXlDb250ZW50KSB7XG4gICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYm9keScsXG4gICAgICAgICAgICAgICAga2V5OiAnYWxsLWRheScsXG4gICAgICAgICAgICAgICAgc3luY1Jvd0hlaWdodHM6IHRydWUsXG4gICAgICAgICAgICAgICAgY2h1bmtzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ2F4aXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm93Q29udGVudDogKGNvbnRlbnRBcmcpID0+IChjcmVhdGVFbGVtZW50KFwidHJcIiwgeyByb2xlOiBcInByZXNlbnRhdGlvblwiIH0sIHRoaXMucmVuZGVyVGFibGVSb3dBeGlzKGNvbnRlbnRBcmcucm93U3luY0hlaWdodHNbMF0pKSksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ2NvbHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogYWxsRGF5Q29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICBrZXk6ICdhbGwtZGF5LWRpdmlkZXInLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdib2R5JyxcbiAgICAgICAgICAgICAgICBvdXRlckNvbnRlbnQ6ICggLy8gVE9ETzogcmVuYW1lIHRvIGNlbGxDb250ZW50IHNvIGRvbid0IG5lZWQgdG8gZGVmaW5lIDx0cj4/XG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRyXCIsIHsgcm9sZTogXCJwcmVzZW50YXRpb25cIiwgY2xhc3NOYW1lOiBcImZjLXNjcm9sbGdyaWQtc2VjdGlvblwiIH0sXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IGNvbFNwYW46IDIsIGNsYXNzTmFtZTogJ2ZjLXRpbWVncmlkLWRpdmlkZXIgJyArIGNvbnRleHQudGhlbWUuZ2V0Q2xhc3MoJ3RhYmxlQ2VsbFNoYWRlZCcpIH0pKSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaXNOb3dJbmRpY2F0b3IgPSBjb250ZXh0Lm9wdGlvbnMubm93SW5kaWNhdG9yO1xuICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdib2R5JyxcbiAgICAgICAgICAgIGtleTogJ2JvZHknLFxuICAgICAgICAgICAgbGlxdWlkOiB0cnVlLFxuICAgICAgICAgICAgZXhwYW5kUm93czogQm9vbGVhbihjb250ZXh0Lm9wdGlvbnMuZXhwYW5kUm93cyksXG4gICAgICAgICAgICBjaHVua3M6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogJ2F4aXMnLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAoYXJnKSA9PiAoXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IG1ha2UgdGhpcyBub3ctaW5kaWNhdG9yIGFycm93IG1vcmUgRFJZIHdpdGggVGltZUNvbHNDb250ZW50XG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtYXhpcy1jaHVua1wiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwidGFibGVcIiwgeyBcImFyaWEtaGlkZGVuXCI6IHRydWUsIHN0eWxlOiB7IGhlaWdodDogYXJnLmV4cGFuZFJvd3MgPyBhcmcuY2xpZW50SGVpZ2h0IDogJycgfSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZy50YWJsZUNvbEdyb3VwTm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwidGJvZHlcIiwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChUaW1lQm9keUF4aXMsIHsgc2xhdE1ldGFzOiBzbGF0TWV0YXMgfSkpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtbm93LWluZGljYXRvci1jb250YWluZXJcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoTm93VGltZXIsIHsgdW5pdDogaXNOb3dJbmRpY2F0b3IgPyAnbWludXRlJyA6ICdkYXknIC8qIGhhY2t5ICovIH0sIChub3dEYXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub3dJbmRpY2F0b3JUb3AgPSBpc05vd0luZGljYXRvciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xhdENvb3JkcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xhdENvb3Jkcy5zYWZlQ29tcHV0ZVRvcChub3dEYXRlKTsgLy8gbWlnaHQgcmV0dXJuIHZvaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBub3dJbmRpY2F0b3JUb3AgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoTm93SW5kaWNhdG9yQ29udGFpbmVyLCB7IGVsQ2xhc3NlczogWydmYy10aW1lZ3JpZC1ub3ctaW5kaWNhdG9yLWFycm93J10sIGVsU3R5bGU6IHsgdG9wOiBub3dJbmRpY2F0b3JUb3AgfSwgaXNBeGlzOiB0cnVlLCBkYXRlOiBub3dEYXRlIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkpKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiAnY29scycsXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbGVyRWxSZWY6IHRoaXMuc2Nyb2xsZXJFbFJlZixcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogdGltZUNvbnRlbnQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyKSB7XG4gICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICBrZXk6ICdmb290ZXInLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdmb290ZXInLFxuICAgICAgICAgICAgICAgIGlzU3RpY2t5OiB0cnVlLFxuICAgICAgICAgICAgICAgIGNodW5rczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdheGlzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHJlbmRlclNjcm9sbFNoaW0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ2NvbHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogcmVuZGVyU2Nyb2xsU2hpbSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFZpZXdDb250YWluZXIsIHsgZWxSZWY6IHRoaXMucm9vdEVsUmVmLCBlbENsYXNzZXM6IFsnZmMtdGltZWdyaWQnXSwgdmlld1NwZWM6IGNvbnRleHQudmlld1NwZWMgfSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoU2Nyb2xsR3JpZCwgeyBsaXF1aWQ6ICFwcm9wcy5pc0hlaWdodEF1dG8gJiYgIXByb3BzLmZvclByaW50LCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQsIGNvbGxhcHNpYmxlV2lkdGg6IGZhbHNlLCBjb2xHcm91cHM6IFtcbiAgICAgICAgICAgICAgICAgICAgeyB3aWR0aDogJ3NocmluaycsIGNvbHM6IFt7IHdpZHRoOiAnc2hyaW5rJyB9XSB9LFxuICAgICAgICAgICAgICAgICAgICB7IGNvbHM6IFt7IHNwYW46IGNvbENudCwgbWluV2lkdGg6IGRheU1pbldpZHRoIH1dIH0sXG4gICAgICAgICAgICAgICAgXSwgc2VjdGlvbnM6IHNlY3Rpb25zIH0pKSk7XG4gICAgfVxuICAgIC8qIERpbWVuc2lvbnNcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICAgIGdldEFsbERheU1heEV2ZW50UHJvcHMoKSB7XG4gICAgICAgIGxldCB7IGRheU1heEV2ZW50cywgZGF5TWF4RXZlbnRSb3dzIH0gPSB0aGlzLmNvbnRleHQub3B0aW9ucztcbiAgICAgICAgaWYgKGRheU1heEV2ZW50cyA9PT0gdHJ1ZSB8fCBkYXlNYXhFdmVudFJvd3MgPT09IHRydWUpIHsgLy8gaXMgYXV0bz9cbiAgICAgICAgICAgIGRheU1heEV2ZW50cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGRheU1heEV2ZW50Um93cyA9IEFVVE9fQUxMX0RBWV9NQVhfRVZFTlRfUk9XUzsgLy8gbWFrZSBzdXJlIFwiYXV0b1wiIGdvZXMgdG8gYSByZWFsIG51bWJlclxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRheU1heEV2ZW50cywgZGF5TWF4RXZlbnRSb3dzIH07XG4gICAgfVxufVxuZnVuY3Rpb24gcmVuZGVyQWxsRGF5SW5uZXIocmVuZGVyUHJvcHMpIHtcbiAgICByZXR1cm4gcmVuZGVyUHJvcHMudGV4dDtcbn1cblxuY2xhc3MgVGltZUNvbHNTbGF0c0Nvb3JkcyB7XG4gICAgY29uc3RydWN0b3IocG9zaXRpb25zLCBkYXRlUHJvZmlsZSwgc2xvdER1cmF0aW9uKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb25zID0gcG9zaXRpb25zO1xuICAgICAgICB0aGlzLmRhdGVQcm9maWxlID0gZGF0ZVByb2ZpbGU7XG4gICAgICAgIHRoaXMuc2xvdER1cmF0aW9uID0gc2xvdER1cmF0aW9uO1xuICAgIH1cbiAgICBzYWZlQ29tcHV0ZVRvcChkYXRlKSB7XG4gICAgICAgIGxldCB7IGRhdGVQcm9maWxlIH0gPSB0aGlzO1xuICAgICAgICBpZiAocmFuZ2VDb250YWluc01hcmtlcihkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2UsIGRhdGUpKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnRPZkRheURhdGUgPSBzdGFydE9mRGF5KGRhdGUpO1xuICAgICAgICAgICAgbGV0IHRpbWVNcyA9IGRhdGUudmFsdWVPZigpIC0gc3RhcnRPZkRheURhdGUudmFsdWVPZigpO1xuICAgICAgICAgICAgaWYgKHRpbWVNcyA+PSBhc1JvdWdoTXMoZGF0ZVByb2ZpbGUuc2xvdE1pblRpbWUpICYmXG4gICAgICAgICAgICAgICAgdGltZU1zIDwgYXNSb3VnaE1zKGRhdGVQcm9maWxlLnNsb3RNYXhUaW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVUaW1lVG9wKGNyZWF0ZUR1cmF0aW9uKHRpbWVNcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBDb21wdXRlcyB0aGUgdG9wIGNvb3JkaW5hdGUsIHJlbGF0aXZlIHRvIHRoZSBib3VuZHMgb2YgdGhlIGdyaWQsIG9mIHRoZSBnaXZlbiBkYXRlLlxuICAgIC8vIEEgYHN0YXJ0T2ZEYXlEYXRlYCBtdXN0IGJlIGdpdmVuIGZvciBhdm9pZGluZyBhbWJpZ3VpdHkgb3ZlciBob3cgdG8gdHJlYXQgbWlkbmlnaHQuXG4gICAgY29tcHV0ZURhdGVUb3Aod2hlbiwgc3RhcnRPZkRheURhdGUpIHtcbiAgICAgICAgaWYgKCFzdGFydE9mRGF5RGF0ZSkge1xuICAgICAgICAgICAgc3RhcnRPZkRheURhdGUgPSBzdGFydE9mRGF5KHdoZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVUaW1lVG9wKGNyZWF0ZUR1cmF0aW9uKHdoZW4udmFsdWVPZigpIC0gc3RhcnRPZkRheURhdGUudmFsdWVPZigpKSk7XG4gICAgfVxuICAgIC8vIENvbXB1dGVzIHRoZSB0b3AgY29vcmRpbmF0ZSwgcmVsYXRpdmUgdG8gdGhlIGJvdW5kcyBvZiB0aGUgZ3JpZCwgb2YgdGhlIGdpdmVuIHRpbWUgKGEgRHVyYXRpb24pLlxuICAgIC8vIFRoaXMgaXMgYSBtYWtlc2hpZnkgd2F5IHRvIGNvbXB1dGUgdGhlIHRpbWUtdG9wLiBBc3N1bWVzIGFsbCBzbGF0TWV0YXMgZGF0ZXMgYXJlIHVuaWZvcm0uXG4gICAgLy8gRXZlbnR1YWxseSBhbGxvdyBjb21wdXRhdGlvbiB3aXRoIGFyYmlyYXJ5IHNsYXQgZGF0ZXMuXG4gICAgY29tcHV0ZVRpbWVUb3AoZHVyYXRpb24pIHtcbiAgICAgICAgbGV0IHsgcG9zaXRpb25zLCBkYXRlUHJvZmlsZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IGxlbiA9IHBvc2l0aW9ucy5lbHMubGVuZ3RoO1xuICAgICAgICAvLyBmbG9hdGluZy1wb2ludCB2YWx1ZSBvZiAjIG9mIHNsb3RzIGNvdmVyZWRcbiAgICAgICAgbGV0IHNsYXRDb3ZlcmFnZSA9IChkdXJhdGlvbi5taWxsaXNlY29uZHMgLSBhc1JvdWdoTXMoZGF0ZVByb2ZpbGUuc2xvdE1pblRpbWUpKSAvIGFzUm91Z2hNcyh0aGlzLnNsb3REdXJhdGlvbik7XG4gICAgICAgIGxldCBzbGF0SW5kZXg7XG4gICAgICAgIGxldCBzbGF0UmVtYWluZGVyO1xuICAgICAgICAvLyBjb21wdXRlIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGZvciBob3cgbWFueSBzbGF0cyBzaG91bGQgYmUgcHJvZ3Jlc3NlZCB0aHJvdWdoLlxuICAgICAgICAvLyBmcm9tIDAgdG8gbnVtYmVyIG9mIHNsYXRzIChpbmNsdXNpdmUpXG4gICAgICAgIC8vIGNvbnN0cmFpbmVkIGJlY2F1c2Ugc2xvdE1pblRpbWUvc2xvdE1heFRpbWUgbWlnaHQgYmUgY3VzdG9taXplZC5cbiAgICAgICAgc2xhdENvdmVyYWdlID0gTWF0aC5tYXgoMCwgc2xhdENvdmVyYWdlKTtcbiAgICAgICAgc2xhdENvdmVyYWdlID0gTWF0aC5taW4obGVuLCBzbGF0Q292ZXJhZ2UpO1xuICAgICAgICAvLyBhbiBpbnRlZ2VyIGluZGV4IG9mIHRoZSBmdXJ0aGVzdCB3aG9sZSBzbGF0XG4gICAgICAgIC8vIGZyb20gMCB0byBudW1iZXIgc2xhdHMgKCpleGNsdXNpdmUqLCBzbyBsZW4tMSlcbiAgICAgICAgc2xhdEluZGV4ID0gTWF0aC5mbG9vcihzbGF0Q292ZXJhZ2UpO1xuICAgICAgICBzbGF0SW5kZXggPSBNYXRoLm1pbihzbGF0SW5kZXgsIGxlbiAtIDEpO1xuICAgICAgICAvLyBob3cgbXVjaCBmdXJ0aGVyIHRocm91Z2ggdGhlIHNsYXRJbmRleCBzbGF0IChmcm9tIDAuMC0xLjApIG11c3QgYmUgY292ZXJlZCBpbiBhZGRpdGlvbi5cbiAgICAgICAgLy8gY291bGQgYmUgMS4wIGlmIHNsYXRDb3ZlcmFnZSBpcyBjb3ZlcmluZyAqYWxsKiB0aGUgc2xvdHNcbiAgICAgICAgc2xhdFJlbWFpbmRlciA9IHNsYXRDb3ZlcmFnZSAtIHNsYXRJbmRleDtcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9ucy50b3BzW3NsYXRJbmRleF0gK1xuICAgICAgICAgICAgcG9zaXRpb25zLmdldEhlaWdodChzbGF0SW5kZXgpICogc2xhdFJlbWFpbmRlcjtcbiAgICB9XG59XG5cbmNsYXNzIFRpbWVDb2xzU2xhdHNCb2R5IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgb3B0aW9ucyB9ID0gY29udGV4dDtcbiAgICAgICAgbGV0IHsgc2xhdEVsUmVmcyB9ID0gcHJvcHM7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcInRib2R5XCIsIG51bGwsIHByb3BzLnNsYXRNZXRhcy5tYXAoKHNsYXRNZXRhLCBpKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVuZGVyUHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgdGltZTogc2xhdE1ldGEudGltZSxcbiAgICAgICAgICAgICAgICBkYXRlOiBjb250ZXh0LmRhdGVFbnYudG9EYXRlKHNsYXRNZXRhLmRhdGUpLFxuICAgICAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IGtleTogc2xhdE1ldGEua2V5LCByZWY6IHNsYXRFbFJlZnMuY3JlYXRlUmVmKHNsYXRNZXRhLmtleSkgfSxcbiAgICAgICAgICAgICAgICBwcm9wcy5heGlzICYmIChjcmVhdGVFbGVtZW50KFRpbWVDb2xzQXhpc0NlbGwsIE9iamVjdC5hc3NpZ24oe30sIHNsYXRNZXRhKSkpLFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoQ29udGVudENvbnRhaW5lciwgeyBlbFRhZzogXCJ0ZFwiLCBlbENsYXNzZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdmYy10aW1lZ3JpZC1zbG90JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmYy10aW1lZ3JpZC1zbG90LWxhbmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgIXNsYXRNZXRhLmlzTGFiZWxlZCAmJiAnZmMtdGltZWdyaWQtc2xvdC1taW5vcicsXG4gICAgICAgICAgICAgICAgICAgIF0sIGVsQXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLXRpbWUnOiBzbGF0TWV0YS5pc29UaW1lU3RyLFxuICAgICAgICAgICAgICAgICAgICB9LCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGdlbmVyYXRvck5hbWU6IFwic2xvdExhbmVDb250ZW50XCIsIGN1c3RvbUdlbmVyYXRvcjogb3B0aW9ucy5zbG90TGFuZUNvbnRlbnQsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy5zbG90TGFuZUNsYXNzTmFtZXMsIGRpZE1vdW50OiBvcHRpb25zLnNsb3RMYW5lRGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLnNsb3RMYW5lV2lsbFVubW91bnQgfSkpKTtcbiAgICAgICAgfSkpKTtcbiAgICB9XG59XG5cbi8qXG5mb3IgdGhlIGhvcml6b250YWwgXCJzbGF0c1wiIHRoYXQgcnVuIHdpZHRoLXdpc2UuIEhhcyBhIHRpbWUgYXhpcyBvbiBhIHNpZGUuIERlcGVuZHMgb24gUlRMLlxuKi9cbmNsYXNzIFRpbWVDb2xzU2xhdHMgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5yb290RWxSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICAgICAgdGhpcy5zbGF0RWxSZWZzID0gbmV3IFJlZk1hcCgpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IHRoaXMucm9vdEVsUmVmLCBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtc2xvdHNcIiB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRhYmxlXCIsIHsgXCJhcmlhLWhpZGRlblwiOiB0cnVlLCBjbGFzc05hbWU6IGNvbnRleHQudGhlbWUuZ2V0Q2xhc3MoJ3RhYmxlJyksIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIG1pbldpZHRoOiBwcm9wcy50YWJsZU1pbldpZHRoLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogcHJvcHMuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogcHJvcHMubWluSGVpZ2h0LFxuICAgICAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgICAgICBwcm9wcy50YWJsZUNvbEdyb3VwTm9kZSAvKiByZWxpZXMgb24gdGhlcmUgb25seSBiZWluZyBhIHNpbmdsZSA8Y29sPiBmb3IgdGhlIGF4aXMgKi8sXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChUaW1lQ29sc1NsYXRzQm9keSwgeyBzbGF0RWxSZWZzOiB0aGlzLnNsYXRFbFJlZnMsIGF4aXM6IHByb3BzLmF4aXMsIHNsYXRNZXRhczogcHJvcHMuc2xhdE1ldGFzIH0pKSkpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVTaXppbmcoKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVNpemluZygpO1xuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMub25Db29yZHMpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25Db29yZHMobnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlU2l6aW5nKCkge1xuICAgICAgICBsZXQgeyBjb250ZXh0LCBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgaWYgKHByb3BzLm9uQ29vcmRzICYmXG4gICAgICAgICAgICBwcm9wcy5jbGllbnRXaWR0aCAhPT0gbnVsbCAvLyBtZWFucyBzaXppbmcgaGFzIHN0YWJpbGl6ZWRcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBsZXQgcm9vdEVsID0gdGhpcy5yb290RWxSZWYuY3VycmVudDtcbiAgICAgICAgICAgIGlmIChyb290RWwub2Zmc2V0SGVpZ2h0KSB7IC8vIG5vdCBoaWRkZW4gYnkgY3NzXG4gICAgICAgICAgICAgICAgcHJvcHMub25Db29yZHMobmV3IFRpbWVDb2xzU2xhdHNDb29yZHMobmV3IFBvc2l0aW9uQ2FjaGUodGhpcy5yb290RWxSZWYuY3VycmVudCwgY29sbGVjdFNsYXRFbHModGhpcy5zbGF0RWxSZWZzLmN1cnJlbnRNYXAsIHByb3BzLnNsYXRNZXRhcyksIGZhbHNlLCB0cnVlKSwgdGhpcy5wcm9wcy5kYXRlUHJvZmlsZSwgY29udGV4dC5vcHRpb25zLnNsb3REdXJhdGlvbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY29sbGVjdFNsYXRFbHMoZWxNYXAsIHNsYXRNZXRhcykge1xuICAgIHJldHVybiBzbGF0TWV0YXMubWFwKChzbGF0TWV0YSkgPT4gZWxNYXBbc2xhdE1ldGEua2V5XSk7XG59XG5cbmZ1bmN0aW9uIHNwbGl0U2Vnc0J5Q29sKHNlZ3MsIGNvbENudCkge1xuICAgIGxldCBzZWdzQnlDb2wgPSBbXTtcbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgY29sQ250OyBpICs9IDEpIHtcbiAgICAgICAgc2Vnc0J5Q29sLnB1c2goW10pO1xuICAgIH1cbiAgICBpZiAoc2Vncykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgc2Vnc0J5Q29sW3NlZ3NbaV0uY29sXS5wdXNoKHNlZ3NbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWdzQnlDb2w7XG59XG5mdW5jdGlvbiBzcGxpdEludGVyYWN0aW9uQnlDb2wodWksIGNvbENudCkge1xuICAgIGxldCBieVJvdyA9IFtdO1xuICAgIGlmICghdWkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xDbnQ7IGkgKz0gMSkge1xuICAgICAgICAgICAgYnlSb3dbaV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbENudDsgaSArPSAxKSB7XG4gICAgICAgICAgICBieVJvd1tpXSA9IHtcbiAgICAgICAgICAgICAgICBhZmZlY3RlZEluc3RhbmNlczogdWkuYWZmZWN0ZWRJbnN0YW5jZXMsXG4gICAgICAgICAgICAgICAgaXNFdmVudDogdWkuaXNFdmVudCxcbiAgICAgICAgICAgICAgICBzZWdzOiBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgc2VnIG9mIHVpLnNlZ3MpIHtcbiAgICAgICAgICAgIGJ5Um93W3NlZy5jb2xdLnNlZ3MucHVzaChzZWcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBieVJvdztcbn1cblxuY2xhc3MgVGltZUNvbE1vcmVMaW5rIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KE1vcmVMaW5rQ29udGFpbmVyLCB7IGVsQ2xhc3NlczogWydmYy10aW1lZ3JpZC1tb3JlLWxpbmsnXSwgZWxTdHlsZToge1xuICAgICAgICAgICAgICAgIHRvcDogcHJvcHMudG9wLFxuICAgICAgICAgICAgICAgIGJvdHRvbTogcHJvcHMuYm90dG9tLFxuICAgICAgICAgICAgfSwgYWxsRGF5RGF0ZTogbnVsbCwgbW9yZUNudDogcHJvcHMuaGlkZGVuU2Vncy5sZW5ndGgsIGFsbFNlZ3M6IHByb3BzLmhpZGRlblNlZ3MsIGhpZGRlblNlZ3M6IHByb3BzLmhpZGRlblNlZ3MsIGV4dHJhRGF0ZVNwYW46IHByb3BzLmV4dHJhRGF0ZVNwYW4sIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSwgcG9wb3ZlckNvbnRlbnQ6ICgpID0+IHJlbmRlclBsYWluRmdTZWdzKHByb3BzLmhpZGRlblNlZ3MsIHByb3BzKSwgZGVmYXVsdEdlbmVyYXRvcjogcmVuZGVyTW9yZUxpbmtJbm5lciwgZm9yY2VUaW1lZDogdHJ1ZSB9LCAoSW5uZXJDb250ZW50KSA9PiAoY3JlYXRlRWxlbWVudChJbm5lckNvbnRlbnQsIHsgZWxUYWc6IFwiZGl2XCIsIGVsQ2xhc3NlczogWydmYy10aW1lZ3JpZC1tb3JlLWxpbmstaW5uZXInLCAnZmMtc3RpY2t5J10gfSkpKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVuZGVyTW9yZUxpbmtJbm5lcihwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy5zaG9ydFRleHQ7XG59XG5cbi8vIHNlZ0lucHV0cyBhc3N1bWVkIHNvcnRlZFxuZnVuY3Rpb24gYnVpbGRQb3NpdGlvbmluZyhzZWdJbnB1dHMsIHN0cmljdE9yZGVyLCBtYXhTdGFja0NudCkge1xuICAgIGxldCBoaWVyYXJjaHkgPSBuZXcgU2VnSGllcmFyY2h5KCk7XG4gICAgaWYgKHN0cmljdE9yZGVyICE9IG51bGwpIHtcbiAgICAgICAgaGllcmFyY2h5LnN0cmljdE9yZGVyID0gc3RyaWN0T3JkZXI7XG4gICAgfVxuICAgIGlmIChtYXhTdGFja0NudCAhPSBudWxsKSB7XG4gICAgICAgIGhpZXJhcmNoeS5tYXhTdGFja0NudCA9IG1heFN0YWNrQ250O1xuICAgIH1cbiAgICBsZXQgaGlkZGVuRW50cmllcyA9IGhpZXJhcmNoeS5hZGRTZWdzKHNlZ0lucHV0cyk7XG4gICAgbGV0IGhpZGRlbkdyb3VwcyA9IGdyb3VwSW50ZXJzZWN0aW5nRW50cmllcyhoaWRkZW5FbnRyaWVzKTtcbiAgICBsZXQgd2ViID0gYnVpbGRXZWIoaGllcmFyY2h5KTtcbiAgICB3ZWIgPSBzdHJldGNoV2ViKHdlYiwgMSk7IC8vIGFsbCBsZXZlbENvb3Jkcy90aGlja25lc3Mgd2lsbCBoYXZlIDAuMC0xLjBcbiAgICBsZXQgc2VnUmVjdHMgPSB3ZWJUb1JlY3RzKHdlYik7XG4gICAgcmV0dXJuIHsgc2VnUmVjdHMsIGhpZGRlbkdyb3VwcyB9O1xufVxuZnVuY3Rpb24gYnVpbGRXZWIoaGllcmFyY2h5KSB7XG4gICAgY29uc3QgeyBlbnRyaWVzQnlMZXZlbCB9ID0gaGllcmFyY2h5O1xuICAgIGNvbnN0IGJ1aWxkTm9kZSA9IGNhY2hlYWJsZSgobGV2ZWwsIGxhdGVyYWwpID0+IGxldmVsICsgJzonICsgbGF0ZXJhbCwgKGxldmVsLCBsYXRlcmFsKSA9PiB7XG4gICAgICAgIGxldCBzaWJsaW5nUmFuZ2UgPSBmaW5kTmV4dExldmVsU2VncyhoaWVyYXJjaHksIGxldmVsLCBsYXRlcmFsKTtcbiAgICAgICAgbGV0IG5leHRMZXZlbFJlcyA9IGJ1aWxkTm9kZXMoc2libGluZ1JhbmdlLCBidWlsZE5vZGUpO1xuICAgICAgICBsZXQgZW50cnkgPSBlbnRyaWVzQnlMZXZlbFtsZXZlbF1bbGF0ZXJhbF07XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGVudHJ5KSwgeyBuZXh0TGV2ZWxOb2RlczogbmV4dExldmVsUmVzWzBdIH0pLFxuICAgICAgICAgICAgZW50cnkudGhpY2tuZXNzICsgbmV4dExldmVsUmVzWzFdLCAvLyB0aGUgcHJlc3N1cmUgYnVpbGRzXG4gICAgICAgIF07XG4gICAgfSk7XG4gICAgcmV0dXJuIGJ1aWxkTm9kZXMoZW50cmllc0J5TGV2ZWwubGVuZ3RoXG4gICAgICAgID8geyBsZXZlbDogMCwgbGF0ZXJhbFN0YXJ0OiAwLCBsYXRlcmFsRW5kOiBlbnRyaWVzQnlMZXZlbFswXS5sZW5ndGggfVxuICAgICAgICA6IG51bGwsIGJ1aWxkTm9kZSlbMF07XG59XG5mdW5jdGlvbiBidWlsZE5vZGVzKHNpYmxpbmdSYW5nZSwgYnVpbGROb2RlKSB7XG4gICAgaWYgKCFzaWJsaW5nUmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIFtbXSwgMF07XG4gICAgfVxuICAgIGxldCB7IGxldmVsLCBsYXRlcmFsU3RhcnQsIGxhdGVyYWxFbmQgfSA9IHNpYmxpbmdSYW5nZTtcbiAgICBsZXQgbGF0ZXJhbCA9IGxhdGVyYWxTdGFydDtcbiAgICBsZXQgcGFpcnMgPSBbXTtcbiAgICB3aGlsZSAobGF0ZXJhbCA8IGxhdGVyYWxFbmQpIHtcbiAgICAgICAgcGFpcnMucHVzaChidWlsZE5vZGUobGV2ZWwsIGxhdGVyYWwpKTtcbiAgICAgICAgbGF0ZXJhbCArPSAxO1xuICAgIH1cbiAgICBwYWlycy5zb3J0KGNtcERlc2NQcmVzc3VyZXMpO1xuICAgIHJldHVybiBbXG4gICAgICAgIHBhaXJzLm1hcChleHRyYWN0Tm9kZSksXG4gICAgICAgIHBhaXJzWzBdWzFdLCAvLyBmaXJzdCBpdGVtJ3MgcHJlc3N1cmVcbiAgICBdO1xufVxuZnVuY3Rpb24gY21wRGVzY1ByZXNzdXJlcyhhLCBiKSB7XG4gICAgcmV0dXJuIGJbMV0gLSBhWzFdO1xufVxuZnVuY3Rpb24gZXh0cmFjdE5vZGUoYSkge1xuICAgIHJldHVybiBhWzBdO1xufVxuZnVuY3Rpb24gZmluZE5leHRMZXZlbFNlZ3MoaGllcmFyY2h5LCBzdWJqZWN0TGV2ZWwsIHN1YmplY3RMYXRlcmFsKSB7XG4gICAgbGV0IHsgbGV2ZWxDb29yZHMsIGVudHJpZXNCeUxldmVsIH0gPSBoaWVyYXJjaHk7XG4gICAgbGV0IHN1YmplY3RFbnRyeSA9IGVudHJpZXNCeUxldmVsW3N1YmplY3RMZXZlbF1bc3ViamVjdExhdGVyYWxdO1xuICAgIGxldCBhZnRlclN1YmplY3QgPSBsZXZlbENvb3Jkc1tzdWJqZWN0TGV2ZWxdICsgc3ViamVjdEVudHJ5LnRoaWNrbmVzcztcbiAgICBsZXQgbGV2ZWxDbnQgPSBsZXZlbENvb3Jkcy5sZW5ndGg7XG4gICAgbGV0IGxldmVsID0gc3ViamVjdExldmVsO1xuICAgIC8vIHNraXAgcGFzdCBsZXZlbHMgdGhhdCBhcmUgdG9vIGhpZ2ggdXBcbiAgICBmb3IgKDsgbGV2ZWwgPCBsZXZlbENudCAmJiBsZXZlbENvb3Jkc1tsZXZlbF0gPCBhZnRlclN1YmplY3Q7IGxldmVsICs9IDEpXG4gICAgICAgIDsgLy8gZG8gbm90aGluZ1xuICAgIGZvciAoOyBsZXZlbCA8IGxldmVsQ250OyBsZXZlbCArPSAxKSB7XG4gICAgICAgIGxldCBlbnRyaWVzID0gZW50cmllc0J5TGV2ZWxbbGV2ZWxdO1xuICAgICAgICBsZXQgZW50cnk7XG4gICAgICAgIGxldCBzZWFyY2hJbmRleCA9IGJpbmFyeVNlYXJjaChlbnRyaWVzLCBzdWJqZWN0RW50cnkuc3Bhbi5zdGFydCwgZ2V0RW50cnlTcGFuRW5kKTtcbiAgICAgICAgbGV0IGxhdGVyYWxTdGFydCA9IHNlYXJjaEluZGV4WzBdICsgc2VhcmNoSW5kZXhbMV07IC8vIGlmIGV4YWN0IG1hdGNoICh3aGljaCBkb2Vzbid0IGNvbGxpZGUpLCBnbyB0byBuZXh0IG9uZVxuICAgICAgICBsZXQgbGF0ZXJhbEVuZCA9IGxhdGVyYWxTdGFydDtcbiAgICAgICAgd2hpbGUgKCAvLyBsb29wIHRocm91Z2ggZW50cmllcyB0aGF0IGhvcml6b250YWxseSBpbnRlcnNlY3RcbiAgICAgICAgKGVudHJ5ID0gZW50cmllc1tsYXRlcmFsRW5kXSkgJiYgLy8gYnV0IG5vdCBwYXN0IHRoZSB3aG9sZSBzZWcgbGlzdFxuICAgICAgICAgICAgZW50cnkuc3Bhbi5zdGFydCA8IHN1YmplY3RFbnRyeS5zcGFuLmVuZCkge1xuICAgICAgICAgICAgbGF0ZXJhbEVuZCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXRlcmFsU3RhcnQgPCBsYXRlcmFsRW5kKSB7XG4gICAgICAgICAgICByZXR1cm4geyBsZXZlbCwgbGF0ZXJhbFN0YXJ0LCBsYXRlcmFsRW5kIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBzdHJldGNoV2ViKHRvcExldmVsTm9kZXMsIHRvdGFsVGhpY2tuZXNzKSB7XG4gICAgY29uc3Qgc3RyZXRjaE5vZGUgPSBjYWNoZWFibGUoKG5vZGUsIHN0YXJ0Q29vcmQsIHByZXZUaGlja25lc3MpID0+IGJ1aWxkRW50cnlLZXkobm9kZSksIChub2RlLCBzdGFydENvb3JkLCBwcmV2VGhpY2tuZXNzKSA9PiB7XG4gICAgICAgIGxldCB7IG5leHRMZXZlbE5vZGVzLCB0aGlja25lc3MgfSA9IG5vZGU7XG4gICAgICAgIGxldCBhbGxUaGlja25lc3MgPSB0aGlja25lc3MgKyBwcmV2VGhpY2tuZXNzO1xuICAgICAgICBsZXQgdGhpY2tuZXNzRnJhY3Rpb24gPSB0aGlja25lc3MgLyBhbGxUaGlja25lc3M7XG4gICAgICAgIGxldCBlbmRDb29yZDtcbiAgICAgICAgbGV0IG5ld0NoaWxkcmVuID0gW107XG4gICAgICAgIGlmICghbmV4dExldmVsTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBlbmRDb29yZCA9IHRvdGFsVGhpY2tuZXNzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgY2hpbGROb2RlIG9mIG5leHRMZXZlbE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVuZENvb3JkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlcyA9IHN0cmV0Y2hOb2RlKGNoaWxkTm9kZSwgc3RhcnRDb29yZCwgYWxsVGhpY2tuZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgZW5kQ29vcmQgPSByZXNbMF07XG4gICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuLnB1c2gocmVzWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXMgPSBzdHJldGNoTm9kZShjaGlsZE5vZGUsIGVuZENvb3JkLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGRyZW4ucHVzaChyZXNbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV3VGhpY2tuZXNzID0gKGVuZENvb3JkIC0gc3RhcnRDb29yZCkgKiB0aGlja25lc3NGcmFjdGlvbjtcbiAgICAgICAgcmV0dXJuIFtlbmRDb29yZCAtIG5ld1RoaWNrbmVzcywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBub2RlKSwgeyB0aGlja25lc3M6IG5ld1RoaWNrbmVzcywgbmV4dExldmVsTm9kZXM6IG5ld0NoaWxkcmVuIH0pXTtcbiAgICB9KTtcbiAgICByZXR1cm4gdG9wTGV2ZWxOb2Rlcy5tYXAoKG5vZGUpID0+IHN0cmV0Y2hOb2RlKG5vZGUsIDAsIDApWzFdKTtcbn1cbi8vIG5vdCBzb3J0ZWQgaW4gYW55IHBhcnRpY3VsYXIgb3JkZXJcbmZ1bmN0aW9uIHdlYlRvUmVjdHModG9wTGV2ZWxOb2Rlcykge1xuICAgIGxldCByZWN0cyA9IFtdO1xuICAgIGNvbnN0IHByb2Nlc3NOb2RlID0gY2FjaGVhYmxlKChub2RlLCBsZXZlbENvb3JkLCBzdGFja0RlcHRoKSA9PiBidWlsZEVudHJ5S2V5KG5vZGUpLCAobm9kZSwgbGV2ZWxDb29yZCwgc3RhY2tEZXB0aCkgPT4ge1xuICAgICAgICBsZXQgcmVjdCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbm9kZSksIHsgbGV2ZWxDb29yZCxcbiAgICAgICAgICAgIHN0YWNrRGVwdGgsIHN0YWNrRm9yd2FyZDogMCB9KTtcbiAgICAgICAgcmVjdHMucHVzaChyZWN0KTtcbiAgICAgICAgcmV0dXJuIChyZWN0LnN0YWNrRm9yd2FyZCA9IHByb2Nlc3NOb2Rlcyhub2RlLm5leHRMZXZlbE5vZGVzLCBsZXZlbENvb3JkICsgbm9kZS50aGlja25lc3MsIHN0YWNrRGVwdGggKyAxKSArIDEpO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIHByb2Nlc3NOb2Rlcyhub2RlcywgbGV2ZWxDb29yZCwgc3RhY2tEZXB0aCkge1xuICAgICAgICBsZXQgc3RhY2tGb3J3YXJkID0gMDtcbiAgICAgICAgZm9yIChsZXQgbm9kZSBvZiBub2Rlcykge1xuICAgICAgICAgICAgc3RhY2tGb3J3YXJkID0gTWF0aC5tYXgocHJvY2Vzc05vZGUobm9kZSwgbGV2ZWxDb29yZCwgc3RhY2tEZXB0aCksIHN0YWNrRm9yd2FyZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YWNrRm9yd2FyZDtcbiAgICB9XG4gICAgcHJvY2Vzc05vZGVzKHRvcExldmVsTm9kZXMsIDAsIDApO1xuICAgIHJldHVybiByZWN0czsgLy8gVE9ETzogc29ydCByZWN0cyBieSBsZXZlbENvb3JkIHRvIGJlIGNvbnNpc3RlbnQgd2l0aCB0b1JlY3RzP1xufVxuLy8gVE9ETzogbW92ZSB0byBnZW5lcmFsIHV0aWxcbmZ1bmN0aW9uIGNhY2hlYWJsZShrZXlGdW5jLCB3b3JrRnVuYykge1xuICAgIGNvbnN0IGNhY2hlID0ge307XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGxldCBrZXkgPSBrZXlGdW5jKC4uLmFyZ3MpO1xuICAgICAgICByZXR1cm4gKGtleSBpbiBjYWNoZSlcbiAgICAgICAgICAgID8gY2FjaGVba2V5XVxuICAgICAgICAgICAgOiAoY2FjaGVba2V5XSA9IHdvcmtGdW5jKC4uLmFyZ3MpKTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBjb21wdXRlU2VnVkNvb3JkcyhzZWdzLCBjb2xEYXRlLCBzbGF0Q29vcmRzID0gbnVsbCwgZXZlbnRNaW5IZWlnaHQgPSAwKSB7XG4gICAgbGV0IHZjb29yZHMgPSBbXTtcbiAgICBpZiAoc2xhdENvb3Jkcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGxldCBzZWcgPSBzZWdzW2ldO1xuICAgICAgICAgICAgbGV0IHNwYW5TdGFydCA9IHNsYXRDb29yZHMuY29tcHV0ZURhdGVUb3Aoc2VnLnN0YXJ0LCBjb2xEYXRlKTtcbiAgICAgICAgICAgIGxldCBzcGFuRW5kID0gTWF0aC5tYXgoc3BhblN0YXJ0ICsgKGV2ZW50TWluSGVpZ2h0IHx8IDApLCAvLyA6KFxuICAgICAgICAgICAgc2xhdENvb3Jkcy5jb21wdXRlRGF0ZVRvcChzZWcuZW5kLCBjb2xEYXRlKSk7XG4gICAgICAgICAgICB2Y29vcmRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBNYXRoLnJvdW5kKHNwYW5TdGFydCksXG4gICAgICAgICAgICAgICAgZW5kOiBNYXRoLnJvdW5kKHNwYW5FbmQpLCAvL1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZjb29yZHM7XG59XG5mdW5jdGlvbiBjb21wdXRlRmdTZWdQbGFjZW1lbnRzKHNlZ3MsIHNlZ1ZDb29yZHMsIC8vIG1pZ2h0IG5vdCBoYXZlIGZvciBldmVyeSBzZWdcbmV2ZW50T3JkZXJTdHJpY3QsIGV2ZW50TWF4U3RhY2spIHtcbiAgICBsZXQgc2VnSW5wdXRzID0gW107XG4gICAgbGV0IGR1bWJTZWdzID0gW107IC8vIHNlZ3Mgd2l0aG91dCBjb29yZHNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgbGV0IHZjb29yZHMgPSBzZWdWQ29vcmRzW2ldO1xuICAgICAgICBpZiAodmNvb3Jkcykge1xuICAgICAgICAgICAgc2VnSW5wdXRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgIHRoaWNrbmVzczogMSxcbiAgICAgICAgICAgICAgICBzcGFuOiB2Y29vcmRzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkdW1iU2Vncy5wdXNoKHNlZ3NbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCB7IHNlZ1JlY3RzLCBoaWRkZW5Hcm91cHMgfSA9IGJ1aWxkUG9zaXRpb25pbmcoc2VnSW5wdXRzLCBldmVudE9yZGVyU3RyaWN0LCBldmVudE1heFN0YWNrKTtcbiAgICBsZXQgc2VnUGxhY2VtZW50cyA9IFtdO1xuICAgIGZvciAobGV0IHNlZ1JlY3Qgb2Ygc2VnUmVjdHMpIHtcbiAgICAgICAgc2VnUGxhY2VtZW50cy5wdXNoKHtcbiAgICAgICAgICAgIHNlZzogc2Vnc1tzZWdSZWN0LmluZGV4XSxcbiAgICAgICAgICAgIHJlY3Q6IHNlZ1JlY3QsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKGxldCBkdW1iU2VnIG9mIGR1bWJTZWdzKSB7XG4gICAgICAgIHNlZ1BsYWNlbWVudHMucHVzaCh7IHNlZzogZHVtYlNlZywgcmVjdDogbnVsbCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc2VnUGxhY2VtZW50cywgaGlkZGVuR3JvdXBzIH07XG59XG5cbmNvbnN0IERFRkFVTFRfVElNRV9GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoe1xuICAgIGhvdXI6ICdudW1lcmljJyxcbiAgICBtaW51dGU6ICcyLWRpZ2l0JyxcbiAgICBtZXJpZGllbTogZmFsc2UsXG59KTtcbmNsYXNzIFRpbWVDb2xFdmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFN0YW5kYXJkRXZlbnQsIE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvcHMsIHsgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgJ2ZjLXRpbWVncmlkLWV2ZW50JyxcbiAgICAgICAgICAgICAgICAnZmMtdi1ldmVudCcsXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5pc1Nob3J0ICYmICdmYy10aW1lZ3JpZC1ldmVudC1zaG9ydCcsXG4gICAgICAgICAgICBdLCBkZWZhdWx0VGltZUZvcm1hdDogREVGQVVMVF9USU1FX0ZPUk1BVCB9KSkpO1xuICAgIH1cbn1cblxuY2xhc3MgVGltZUNvbCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnNvcnRFdmVudFNlZ3MgPSBtZW1vaXplKHNvcnRFdmVudFNlZ3MpO1xuICAgIH1cbiAgICAvLyBUT0RPOiBtZW1vaXplIGV2ZW50LXBsYWNlbWVudD9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSBjb250ZXh0O1xuICAgICAgICBsZXQgaXNTZWxlY3RNaXJyb3IgPSBvcHRpb25zLnNlbGVjdE1pcnJvcjtcbiAgICAgICAgbGV0IG1pcnJvclNlZ3MgPSAvLyB5dWNrXG4gICAgICAgICAocHJvcHMuZXZlbnREcmFnICYmIHByb3BzLmV2ZW50RHJhZy5zZWdzKSB8fFxuICAgICAgICAgICAgKHByb3BzLmV2ZW50UmVzaXplICYmIHByb3BzLmV2ZW50UmVzaXplLnNlZ3MpIHx8XG4gICAgICAgICAgICAoaXNTZWxlY3RNaXJyb3IgJiYgcHJvcHMuZGF0ZVNlbGVjdGlvblNlZ3MpIHx8XG4gICAgICAgICAgICBbXTtcbiAgICAgICAgbGV0IGludGVyYWN0aW9uQWZmZWN0ZWRJbnN0YW5jZXMgPSAvLyBUT0RPOiBtZXNzeSB3YXkgdG8gY29tcHV0ZSB0aGlzXG4gICAgICAgICAocHJvcHMuZXZlbnREcmFnICYmIHByb3BzLmV2ZW50RHJhZy5hZmZlY3RlZEluc3RhbmNlcykgfHxcbiAgICAgICAgICAgIChwcm9wcy5ldmVudFJlc2l6ZSAmJiBwcm9wcy5ldmVudFJlc2l6ZS5hZmZlY3RlZEluc3RhbmNlcykgfHxcbiAgICAgICAgICAgIHt9O1xuICAgICAgICBsZXQgc29ydGVkRmdTZWdzID0gdGhpcy5zb3J0RXZlbnRTZWdzKHByb3BzLmZnRXZlbnRTZWdzLCBvcHRpb25zLmV2ZW50T3JkZXIpO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRGF5Q2VsbENvbnRhaW5lciwgeyBlbFRhZzogXCJ0ZFwiLCBlbFJlZjogcHJvcHMuZWxSZWYsIGVsQ2xhc3NlczogW1xuICAgICAgICAgICAgICAgICdmYy10aW1lZ3JpZC1jb2wnLFxuICAgICAgICAgICAgICAgIC4uLihwcm9wcy5leHRyYUNsYXNzTmFtZXMgfHwgW10pLFxuICAgICAgICAgICAgXSwgZWxBdHRyczogT2JqZWN0LmFzc2lnbih7IHJvbGU6ICdncmlkY2VsbCcgfSwgcHJvcHMuZXh0cmFEYXRhQXR0cnMpLCBkYXRlOiBwcm9wcy5kYXRlLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsIGV4dHJhUmVuZGVyUHJvcHM6IHByb3BzLmV4dHJhUmVuZGVyUHJvcHMgfSwgKElubmVyQ29udGVudCkgPT4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtY29sLWZyYW1lXCIgfSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtY29sLWJnXCIgfSxcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckZpbGxTZWdzKHByb3BzLmJ1c2luZXNzSG91clNlZ3MsICdub24tYnVzaW5lc3MnKSxcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckZpbGxTZWdzKHByb3BzLmJnRXZlbnRTZWdzLCAnYmctZXZlbnQnKSxcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckZpbGxTZWdzKHByb3BzLmRhdGVTZWxlY3Rpb25TZWdzLCAnaGlnaGxpZ2h0JykpLFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1jb2wtZXZlbnRzXCIgfSwgdGhpcy5yZW5kZXJGZ1NlZ3Moc29ydGVkRmdTZWdzLCBpbnRlcmFjdGlvbkFmZmVjdGVkSW5zdGFuY2VzLCBmYWxzZSwgZmFsc2UsIGZhbHNlKSksXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWNvbC1ldmVudHNcIiB9LCB0aGlzLnJlbmRlckZnU2VncyhtaXJyb3JTZWdzLCB7fSwgQm9vbGVhbihwcm9wcy5ldmVudERyYWcpLCBCb29sZWFuKHByb3BzLmV2ZW50UmVzaXplKSwgQm9vbGVhbihpc1NlbGVjdE1pcnJvciksICdtaXJyb3InKSksXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItY29udGFpbmVyXCIgfSwgdGhpcy5yZW5kZXJOb3dJbmRpY2F0b3IocHJvcHMubm93SW5kaWNhdG9yU2VncykpLFxuICAgICAgICAgICAgaGFzQ3VzdG9tRGF5Q2VsbENvbnRlbnQob3B0aW9ucykgJiYgKGNyZWF0ZUVsZW1lbnQoSW5uZXJDb250ZW50LCB7IGVsVGFnOiBcImRpdlwiLCBlbENsYXNzZXM6IFsnZmMtdGltZWdyaWQtY29sLW1pc2MnXSB9KSkpKSkpO1xuICAgIH1cbiAgICByZW5kZXJGZ1NlZ3Moc29ydGVkRmdTZWdzLCBzZWdJc0ludmlzaWJsZSwgaXNEcmFnZ2luZywgaXNSZXNpemluZywgaXNEYXRlU2VsZWN0aW5nLCBmb3JjZWRLZXkpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGlmIChwcm9wcy5mb3JQcmludCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlbmRlclBsYWluRmdTZWdzKHNvcnRlZEZnU2VncywgcHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlclBvc2l0aW9uZWRGZ1NlZ3Moc29ydGVkRmdTZWdzLCBzZWdJc0ludmlzaWJsZSwgaXNEcmFnZ2luZywgaXNSZXNpemluZywgaXNEYXRlU2VsZWN0aW5nLCBmb3JjZWRLZXkpO1xuICAgIH1cbiAgICByZW5kZXJQb3NpdGlvbmVkRmdTZWdzKHNlZ3MsIC8vIGlmIG5vdCBtaXJyb3IsIG5lZWRzIHRvIGJlIHNvcnRlZFxuICAgIHNlZ0lzSW52aXNpYmxlLCBpc0RyYWdnaW5nLCBpc1Jlc2l6aW5nLCBpc0RhdGVTZWxlY3RpbmcsIGZvcmNlZEtleSkge1xuICAgICAgICBsZXQgeyBldmVudE1heFN0YWNrLCBldmVudFNob3J0SGVpZ2h0LCBldmVudE9yZGVyU3RyaWN0LCBldmVudE1pbkhlaWdodCB9ID0gdGhpcy5jb250ZXh0Lm9wdGlvbnM7XG4gICAgICAgIGxldCB7IGRhdGUsIHNsYXRDb29yZHMsIGV2ZW50U2VsZWN0aW9uLCB0b2RheVJhbmdlLCBub3dEYXRlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBsZXQgaXNNaXJyb3IgPSBpc0RyYWdnaW5nIHx8IGlzUmVzaXppbmcgfHwgaXNEYXRlU2VsZWN0aW5nO1xuICAgICAgICBsZXQgc2VnVkNvb3JkcyA9IGNvbXB1dGVTZWdWQ29vcmRzKHNlZ3MsIGRhdGUsIHNsYXRDb29yZHMsIGV2ZW50TWluSGVpZ2h0KTtcbiAgICAgICAgbGV0IHsgc2VnUGxhY2VtZW50cywgaGlkZGVuR3JvdXBzIH0gPSBjb21wdXRlRmdTZWdQbGFjZW1lbnRzKHNlZ3MsIHNlZ1ZDb29yZHMsIGV2ZW50T3JkZXJTdHJpY3QsIGV2ZW50TWF4U3RhY2spO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsXG4gICAgICAgICAgICB0aGlzLnJlbmRlckhpZGRlbkdyb3VwcyhoaWRkZW5Hcm91cHMsIHNlZ3MpLFxuICAgICAgICAgICAgc2VnUGxhY2VtZW50cy5tYXAoKHNlZ1BsYWNlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB7IHNlZywgcmVjdCB9ID0gc2VnUGxhY2VtZW50O1xuICAgICAgICAgICAgICAgIGxldCBpbnN0YW5jZUlkID0gc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZDtcbiAgICAgICAgICAgICAgICBsZXQgaXNWaXNpYmxlID0gaXNNaXJyb3IgfHwgQm9vbGVhbighc2VnSXNJbnZpc2libGVbaW5zdGFuY2VJZF0gJiYgcmVjdCk7XG4gICAgICAgICAgICAgICAgbGV0IHZTdHlsZSA9IGNvbXB1dGVTZWdWU3R5bGUocmVjdCAmJiByZWN0LnNwYW4pO1xuICAgICAgICAgICAgICAgIGxldCBoU3R5bGUgPSAoIWlzTWlycm9yICYmIHJlY3QpID8gdGhpcy5jb21wdXRlU2VnSFN0eWxlKHJlY3QpIDogeyBsZWZ0OiAwLCByaWdodDogMCB9O1xuICAgICAgICAgICAgICAgIGxldCBpc0luc2V0ID0gQm9vbGVhbihyZWN0KSAmJiByZWN0LnN0YWNrRm9yd2FyZCA+IDA7XG4gICAgICAgICAgICAgICAgbGV0IGlzU2hvcnQgPSBCb29sZWFuKHJlY3QpICYmIChyZWN0LnNwYW4uZW5kIC0gcmVjdC5zcGFuLnN0YXJ0KSA8IGV2ZW50U2hvcnRIZWlnaHQ7IC8vIGxvb2sgYXQgb3RoZXIgcGxhY2VzIGZvciB0aGlzIHByb2JsZW1cbiAgICAgICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6ICdmYy10aW1lZ3JpZC1ldmVudC1oYXJuZXNzJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAoaXNJbnNldCA/ICcgZmMtdGltZWdyaWQtZXZlbnQtaGFybmVzcy1pbnNldCcgOiAnJyksIGtleTogZm9yY2VkS2V5IHx8IGluc3RhbmNlSWQsIHN0eWxlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyB2aXNpYmlsaXR5OiBpc1Zpc2libGUgPyAnJyA6ICdoaWRkZW4nIH0sIHZTdHlsZSksIGhTdHlsZSkgfSxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChUaW1lQ29sRXZlbnQsIE9iamVjdC5hc3NpZ24oeyBzZWc6IHNlZywgaXNEcmFnZ2luZzogaXNEcmFnZ2luZywgaXNSZXNpemluZzogaXNSZXNpemluZywgaXNEYXRlU2VsZWN0aW5nOiBpc0RhdGVTZWxlY3RpbmcsIGlzU2VsZWN0ZWQ6IGluc3RhbmNlSWQgPT09IGV2ZW50U2VsZWN0aW9uLCBpc1Nob3J0OiBpc1Nob3J0IH0sIGdldFNlZ01ldGEoc2VnLCB0b2RheVJhbmdlLCBub3dEYXRlKSkpKSk7XG4gICAgICAgICAgICB9KSkpO1xuICAgIH1cbiAgICAvLyB3aWxsIGFscmVhZHkgaGF2ZSBldmVudE1pbkhlaWdodCBhcHBsaWVkIGJlY2F1c2Ugc2VnSW5wdXRzIGFscmVhZHkgaGFkIGl0XG4gICAgcmVuZGVySGlkZGVuR3JvdXBzKGhpZGRlbkdyb3Vwcywgc2Vncykge1xuICAgICAgICBsZXQgeyBleHRyYURhdGVTcGFuLCBkYXRlUHJvZmlsZSwgdG9kYXlSYW5nZSwgbm93RGF0ZSwgZXZlbnRTZWxlY3Rpb24sIGV2ZW50RHJhZywgZXZlbnRSZXNpemUgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCwgaGlkZGVuR3JvdXBzLm1hcCgoaGlkZGVuR3JvdXApID0+IHtcbiAgICAgICAgICAgIGxldCBwb3NpdGlvbkNzcyA9IGNvbXB1dGVTZWdWU3R5bGUoaGlkZGVuR3JvdXAuc3Bhbik7XG4gICAgICAgICAgICBsZXQgaGlkZGVuU2VncyA9IGNvbXBpbGVTZWdzRnJvbUVudHJpZXMoaGlkZGVuR3JvdXAuZW50cmllcywgc2Vncyk7XG4gICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVGltZUNvbE1vcmVMaW5rLCB7IGtleTogYnVpbGRJc29TdHJpbmcoY29tcHV0ZUVhcmxpZXN0U2VnU3RhcnQoaGlkZGVuU2VncykpLCBoaWRkZW5TZWdzOiBoaWRkZW5TZWdzLCB0b3A6IHBvc2l0aW9uQ3NzLnRvcCwgYm90dG9tOiBwb3NpdGlvbkNzcy5ib3R0b20sIGV4dHJhRGF0ZVNwYW46IGV4dHJhRGF0ZVNwYW4sIGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogdG9kYXlSYW5nZSwgbm93RGF0ZTogbm93RGF0ZSwgZXZlbnRTZWxlY3Rpb246IGV2ZW50U2VsZWN0aW9uLCBldmVudERyYWc6IGV2ZW50RHJhZywgZXZlbnRSZXNpemU6IGV2ZW50UmVzaXplIH0pKTtcbiAgICAgICAgfSkpKTtcbiAgICB9XG4gICAgcmVuZGVyRmlsbFNlZ3Moc2VncywgZmlsbFR5cGUpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCBzZWdWQ29vcmRzID0gY29tcHV0ZVNlZ1ZDb29yZHMoc2VncywgcHJvcHMuZGF0ZSwgcHJvcHMuc2xhdENvb3JkcywgY29udGV4dC5vcHRpb25zLmV2ZW50TWluSGVpZ2h0KTsgLy8gZG9uJ3QgYXNzdW1lIGFsbCBwb3B1bGF0ZWRcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gc2VnVkNvb3Jkcy5tYXAoKHZjb29yZHMsIGkpID0+IHtcbiAgICAgICAgICAgIGxldCBzZWcgPSBzZWdzW2ldO1xuICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsga2V5OiBidWlsZEV2ZW50UmFuZ2VLZXkoc2VnLmV2ZW50UmFuZ2UpLCBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtYmctaGFybmVzc1wiLCBzdHlsZTogY29tcHV0ZVNlZ1ZTdHlsZSh2Y29vcmRzKSB9LCBmaWxsVHlwZSA9PT0gJ2JnLWV2ZW50JyA/XG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChCZ0V2ZW50LCBPYmplY3QuYXNzaWduKHsgc2VnOiBzZWcgfSwgZ2V0U2VnTWV0YShzZWcsIHByb3BzLnRvZGF5UmFuZ2UsIHByb3BzLm5vd0RhdGUpKSkgOlxuICAgICAgICAgICAgICAgIHJlbmRlckZpbGwoZmlsbFR5cGUpKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4pO1xuICAgIH1cbiAgICByZW5kZXJOb3dJbmRpY2F0b3Ioc2Vncykge1xuICAgICAgICBsZXQgeyBzbGF0Q29vcmRzLCBkYXRlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBpZiAoIXNsYXRDb29yZHMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWdzLm1hcCgoc2VnLCBpKSA9PiAoY3JlYXRlRWxlbWVudChOb3dJbmRpY2F0b3JDb250YWluZXJcbiAgICAgICAgLy8ga2V5IGRvZXNuJ3QgbWF0dGVyLiB3aWxsIG9ubHkgZXZlciBiZSBvbmVcbiAgICAgICAgLCB7IFxuICAgICAgICAgICAgLy8ga2V5IGRvZXNuJ3QgbWF0dGVyLiB3aWxsIG9ubHkgZXZlciBiZSBvbmVcbiAgICAgICAgICAgIGtleTogaSwgZWxDbGFzc2VzOiBbJ2ZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItbGluZSddLCBlbFN0eWxlOiB7XG4gICAgICAgICAgICAgICAgdG9wOiBzbGF0Q29vcmRzLmNvbXB1dGVEYXRlVG9wKHNlZy5zdGFydCwgZGF0ZSksXG4gICAgICAgICAgICB9LCBpc0F4aXM6IGZhbHNlLCBkYXRlOiBkYXRlIH0pKSk7XG4gICAgfVxuICAgIGNvbXB1dGVTZWdIU3R5bGUoc2VnSENvb3Jkcykge1xuICAgICAgICBsZXQgeyBpc1J0bCwgb3B0aW9ucyB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgc2hvdWxkT3ZlcmxhcCA9IG9wdGlvbnMuc2xvdEV2ZW50T3ZlcmxhcDtcbiAgICAgICAgbGV0IG5lYXJDb29yZCA9IHNlZ0hDb29yZHMubGV2ZWxDb29yZDsgLy8gdGhlIGxlZnQgc2lkZSBpZiBMVFIuIHRoZSByaWdodCBzaWRlIGlmIFJUTC4gZmxvYXRpbmctcG9pbnRcbiAgICAgICAgbGV0IGZhckNvb3JkID0gc2VnSENvb3Jkcy5sZXZlbENvb3JkICsgc2VnSENvb3Jkcy50aGlja25lc3M7IC8vIHRoZSByaWdodCBzaWRlIGlmIExUUi4gdGhlIGxlZnQgc2lkZSBpZiBSVEwuIGZsb2F0aW5nLXBvaW50XG4gICAgICAgIGxldCBsZWZ0OyAvLyBhbW91bnQgb2Ygc3BhY2UgZnJvbSBsZWZ0IGVkZ2UsIGEgZnJhY3Rpb24gb2YgdGhlIHRvdGFsIHdpZHRoXG4gICAgICAgIGxldCByaWdodDsgLy8gYW1vdW50IG9mIHNwYWNlIGZyb20gcmlnaHQgZWRnZSwgYSBmcmFjdGlvbiBvZiB0aGUgdG90YWwgd2lkdGhcbiAgICAgICAgaWYgKHNob3VsZE92ZXJsYXApIHtcbiAgICAgICAgICAgIC8vIGRvdWJsZSB0aGUgd2lkdGgsIGJ1dCBkb24ndCBnbyBiZXlvbmQgdGhlIG1heGltdW0gZm9yd2FyZCBjb29yZGluYXRlICgxLjApXG4gICAgICAgICAgICBmYXJDb29yZCA9IE1hdGgubWluKDEsIG5lYXJDb29yZCArIChmYXJDb29yZCAtIG5lYXJDb29yZCkgKiAyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNSdGwpIHtcbiAgICAgICAgICAgIGxlZnQgPSAxIC0gZmFyQ29vcmQ7XG4gICAgICAgICAgICByaWdodCA9IG5lYXJDb29yZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxlZnQgPSBuZWFyQ29vcmQ7XG4gICAgICAgICAgICByaWdodCA9IDEgLSBmYXJDb29yZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHJvcHMgPSB7XG4gICAgICAgICAgICB6SW5kZXg6IHNlZ0hDb29yZHMuc3RhY2tEZXB0aCArIDEsXG4gICAgICAgICAgICBsZWZ0OiBsZWZ0ICogMTAwICsgJyUnLFxuICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0ICogMTAwICsgJyUnLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoc2hvdWxkT3ZlcmxhcCAmJiAhc2VnSENvb3Jkcy5zdGFja0ZvcndhcmQpIHtcbiAgICAgICAgICAgIC8vIGFkZCBwYWRkaW5nIHRvIHRoZSBlZGdlIHNvIHRoYXQgZm9yd2FyZCBzdGFja2VkIGV2ZW50cyBkb24ndCBjb3ZlciB0aGUgcmVzaXplcidzIGljb25cbiAgICAgICAgICAgIHByb3BzW2lzUnRsID8gJ21hcmdpbkxlZnQnIDogJ21hcmdpblJpZ2h0J10gPSAxMCAqIDI7IC8vIDEwIGlzIGEgZ3Vlc3N0aW1hdGUgb2YgdGhlIGljb24ncyB3aWR0aFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9wcztcbiAgICB9XG59XG5mdW5jdGlvbiByZW5kZXJQbGFpbkZnU2Vncyhzb3J0ZWRGZ1NlZ3MsIHsgdG9kYXlSYW5nZSwgbm93RGF0ZSwgZXZlbnRTZWxlY3Rpb24sIGV2ZW50RHJhZywgZXZlbnRSZXNpemUgfSkge1xuICAgIGxldCBoaWRkZW5JbnN0YW5jZXMgPSAoZXZlbnREcmFnID8gZXZlbnREcmFnLmFmZmVjdGVkSW5zdGFuY2VzIDogbnVsbCkgfHxcbiAgICAgICAgKGV2ZW50UmVzaXplID8gZXZlbnRSZXNpemUuYWZmZWN0ZWRJbnN0YW5jZXMgOiBudWxsKSB8fFxuICAgICAgICB7fTtcbiAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIHNvcnRlZEZnU2Vncy5tYXAoKHNlZykgPT4ge1xuICAgICAgICBsZXQgaW5zdGFuY2VJZCA9IHNlZy5ldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWQ7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGtleTogaW5zdGFuY2VJZCwgc3R5bGU6IHsgdmlzaWJpbGl0eTogaGlkZGVuSW5zdGFuY2VzW2luc3RhbmNlSWRdID8gJ2hpZGRlbicgOiAnJyB9IH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFRpbWVDb2xFdmVudCwgT2JqZWN0LmFzc2lnbih7IHNlZzogc2VnLCBpc0RyYWdnaW5nOiBmYWxzZSwgaXNSZXNpemluZzogZmFsc2UsIGlzRGF0ZVNlbGVjdGluZzogZmFsc2UsIGlzU2VsZWN0ZWQ6IGluc3RhbmNlSWQgPT09IGV2ZW50U2VsZWN0aW9uLCBpc1Nob3J0OiBmYWxzZSB9LCBnZXRTZWdNZXRhKHNlZywgdG9kYXlSYW5nZSwgbm93RGF0ZSkpKSkpO1xuICAgIH0pKSk7XG59XG5mdW5jdGlvbiBjb21wdXRlU2VnVlN0eWxlKHNlZ1ZDb29yZHMpIHtcbiAgICBpZiAoIXNlZ1ZDb29yZHMpIHtcbiAgICAgICAgcmV0dXJuIHsgdG9wOiAnJywgYm90dG9tOiAnJyB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IHNlZ1ZDb29yZHMuc3RhcnQsXG4gICAgICAgIGJvdHRvbTogLXNlZ1ZDb29yZHMuZW5kLFxuICAgIH07XG59XG5mdW5jdGlvbiBjb21waWxlU2Vnc0Zyb21FbnRyaWVzKHNlZ0VudHJpZXMsIGFsbFNlZ3MpIHtcbiAgICByZXR1cm4gc2VnRW50cmllcy5tYXAoKHNlZ0VudHJ5KSA9PiBhbGxTZWdzW3NlZ0VudHJ5LmluZGV4XSk7XG59XG5cbmNsYXNzIFRpbWVDb2xzQ29udGVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnNwbGl0RmdFdmVudFNlZ3MgPSBtZW1vaXplKHNwbGl0U2Vnc0J5Q29sKTtcbiAgICAgICAgdGhpcy5zcGxpdEJnRXZlbnRTZWdzID0gbWVtb2l6ZShzcGxpdFNlZ3NCeUNvbCk7XG4gICAgICAgIHRoaXMuc3BsaXRCdXNpbmVzc0hvdXJTZWdzID0gbWVtb2l6ZShzcGxpdFNlZ3NCeUNvbCk7XG4gICAgICAgIHRoaXMuc3BsaXROb3dJbmRpY2F0b3JTZWdzID0gbWVtb2l6ZShzcGxpdFNlZ3NCeUNvbCk7XG4gICAgICAgIHRoaXMuc3BsaXREYXRlU2VsZWN0aW9uU2VncyA9IG1lbW9pemUoc3BsaXRTZWdzQnlDb2wpO1xuICAgICAgICB0aGlzLnNwbGl0RXZlbnREcmFnID0gbWVtb2l6ZShzcGxpdEludGVyYWN0aW9uQnlDb2wpO1xuICAgICAgICB0aGlzLnNwbGl0RXZlbnRSZXNpemUgPSBtZW1vaXplKHNwbGl0SW50ZXJhY3Rpb25CeUNvbCk7XG4gICAgICAgIHRoaXMucm9vdEVsUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIHRoaXMuY2VsbEVsUmVmcyA9IG5ldyBSZWZNYXAoKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IG5vd0luZGljYXRvclRvcCA9IGNvbnRleHQub3B0aW9ucy5ub3dJbmRpY2F0b3IgJiZcbiAgICAgICAgICAgIHByb3BzLnNsYXRDb29yZHMgJiZcbiAgICAgICAgICAgIHByb3BzLnNsYXRDb29yZHMuc2FmZUNvbXB1dGVUb3AocHJvcHMubm93RGF0ZSk7IC8vIG1pZ2h0IHJldHVybiB2b2lkXG4gICAgICAgIGxldCBjb2xDbnQgPSBwcm9wcy5jZWxscy5sZW5ndGg7XG4gICAgICAgIGxldCBmZ0V2ZW50U2Vnc0J5Um93ID0gdGhpcy5zcGxpdEZnRXZlbnRTZWdzKHByb3BzLmZnRXZlbnRTZWdzLCBjb2xDbnQpO1xuICAgICAgICBsZXQgYmdFdmVudFNlZ3NCeVJvdyA9IHRoaXMuc3BsaXRCZ0V2ZW50U2Vncyhwcm9wcy5iZ0V2ZW50U2VncywgY29sQ250KTtcbiAgICAgICAgbGV0IGJ1c2luZXNzSG91clNlZ3NCeVJvdyA9IHRoaXMuc3BsaXRCdXNpbmVzc0hvdXJTZWdzKHByb3BzLmJ1c2luZXNzSG91clNlZ3MsIGNvbENudCk7XG4gICAgICAgIGxldCBub3dJbmRpY2F0b3JTZWdzQnlSb3cgPSB0aGlzLnNwbGl0Tm93SW5kaWNhdG9yU2Vncyhwcm9wcy5ub3dJbmRpY2F0b3JTZWdzLCBjb2xDbnQpO1xuICAgICAgICBsZXQgZGF0ZVNlbGVjdGlvblNlZ3NCeVJvdyA9IHRoaXMuc3BsaXREYXRlU2VsZWN0aW9uU2Vncyhwcm9wcy5kYXRlU2VsZWN0aW9uU2VncywgY29sQ250KTtcbiAgICAgICAgbGV0IGV2ZW50RHJhZ0J5Um93ID0gdGhpcy5zcGxpdEV2ZW50RHJhZyhwcm9wcy5ldmVudERyYWcsIGNvbENudCk7XG4gICAgICAgIGxldCBldmVudFJlc2l6ZUJ5Um93ID0gdGhpcy5zcGxpdEV2ZW50UmVzaXplKHByb3BzLmV2ZW50UmVzaXplLCBjb2xDbnQpO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtY29sc1wiLCByZWY6IHRoaXMucm9vdEVsUmVmIH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwidGFibGVcIiwgeyByb2xlOiBcInByZXNlbnRhdGlvblwiLCBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICBtaW5XaWR0aDogcHJvcHMudGFibGVNaW5XaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgICAgICBwcm9wcy50YWJsZUNvbEdyb3VwTm9kZSxcbiAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwidGJvZHlcIiwgeyByb2xlOiBcInByZXNlbnRhdGlvblwiIH0sXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IHJvbGU6IFwicm93XCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLmF4aXMgJiYgKGNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IFwiYXJpYS1oaWRkZW5cIjogdHJ1ZSwgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWNvbCBmYy10aW1lZ3JpZC1heGlzXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWNvbC1mcmFtZVwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtbm93LWluZGljYXRvci1jb250YWluZXJcIiB9LCB0eXBlb2Ygbm93SW5kaWNhdG9yVG9wID09PSAnbnVtYmVyJyAmJiAoY3JlYXRlRWxlbWVudChOb3dJbmRpY2F0b3JDb250YWluZXIsIHsgZWxDbGFzc2VzOiBbJ2ZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItYXJyb3cnXSwgZWxTdHlsZTogeyB0b3A6IG5vd0luZGljYXRvclRvcCB9LCBpc0F4aXM6IHRydWUsIGRhdGU6IHByb3BzLm5vd0RhdGUgfSkpKSkpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLmNlbGxzLm1hcCgoY2VsbCwgaSkgPT4gKGNyZWF0ZUVsZW1lbnQoVGltZUNvbCwgeyBrZXk6IGNlbGwua2V5LCBlbFJlZjogdGhpcy5jZWxsRWxSZWZzLmNyZWF0ZVJlZihjZWxsLmtleSksIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgZGF0ZTogY2VsbC5kYXRlLCBub3dEYXRlOiBwcm9wcy5ub3dEYXRlLCB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlLCBleHRyYVJlbmRlclByb3BzOiBjZWxsLmV4dHJhUmVuZGVyUHJvcHMsIGV4dHJhRGF0YUF0dHJzOiBjZWxsLmV4dHJhRGF0YUF0dHJzLCBleHRyYUNsYXNzTmFtZXM6IGNlbGwuZXh0cmFDbGFzc05hbWVzLCBleHRyYURhdGVTcGFuOiBjZWxsLmV4dHJhRGF0ZVNwYW4sIGZnRXZlbnRTZWdzOiBmZ0V2ZW50U2Vnc0J5Um93W2ldLCBiZ0V2ZW50U2VnczogYmdFdmVudFNlZ3NCeVJvd1tpXSwgYnVzaW5lc3NIb3VyU2VnczogYnVzaW5lc3NIb3VyU2Vnc0J5Um93W2ldLCBub3dJbmRpY2F0b3JTZWdzOiBub3dJbmRpY2F0b3JTZWdzQnlSb3dbaV0sIGRhdGVTZWxlY3Rpb25TZWdzOiBkYXRlU2VsZWN0aW9uU2Vnc0J5Um93W2ldLCBldmVudERyYWc6IGV2ZW50RHJhZ0J5Um93W2ldLCBldmVudFJlc2l6ZTogZXZlbnRSZXNpemVCeVJvd1tpXSwgc2xhdENvb3JkczogcHJvcHMuc2xhdENvb3JkcywgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQgfSkpKSkpKSkpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVDb29yZHMoKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUNvb3JkcygpO1xuICAgIH1cbiAgICB1cGRhdGVDb29yZHMoKSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBpZiAocHJvcHMub25Db2xDb29yZHMgJiZcbiAgICAgICAgICAgIHByb3BzLmNsaWVudFdpZHRoICE9PSBudWxsIC8vIG1lYW5zIHNpemluZyBoYXMgc3RhYmlsaXplZFxuICAgICAgICApIHtcbiAgICAgICAgICAgIHByb3BzLm9uQ29sQ29vcmRzKG5ldyBQb3NpdGlvbkNhY2hlKHRoaXMucm9vdEVsUmVmLmN1cnJlbnQsIGNvbGxlY3RDZWxsRWxzKHRoaXMuY2VsbEVsUmVmcy5jdXJyZW50TWFwLCBwcm9wcy5jZWxscyksIHRydWUsIC8vIGhvcml6b250YWxcbiAgICAgICAgICAgIGZhbHNlKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjb2xsZWN0Q2VsbEVscyhlbE1hcCwgY2VsbHMpIHtcbiAgICByZXR1cm4gY2VsbHMubWFwKChjZWxsKSA9PiBlbE1hcFtjZWxsLmtleV0pO1xufVxuXG4vKiBBIGNvbXBvbmVudCB0aGF0IHJlbmRlcnMgb25lIG9yIG1vcmUgY29sdW1ucyBvZiB2ZXJ0aWNhbCB0aW1lIHNsb3RzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmNsYXNzIFRpbWVDb2xzIGV4dGVuZHMgRGF0ZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMucHJvY2Vzc1Nsb3RPcHRpb25zID0gbWVtb2l6ZShwcm9jZXNzU2xvdE9wdGlvbnMpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgc2xhdENvb3JkczogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVSb290RWwgPSAoZWwpID0+IHtcbiAgICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgICAgICAgIGlzSGl0Q29tYm9BbGxvd2VkOiB0aGlzLnByb3BzLmlzSGl0Q29tYm9BbGxvd2VkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LnVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGxSZXF1ZXN0ID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIGxldCB7IG9uU2Nyb2xsVG9wUmVxdWVzdCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGxldCB7IHNsYXRDb29yZHMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICBpZiAob25TY3JvbGxUb3BSZXF1ZXN0ICYmIHNsYXRDb29yZHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC50aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0b3AgPSBzbGF0Q29vcmRzLmNvbXB1dGVUaW1lVG9wKHJlcXVlc3QudGltZSk7XG4gICAgICAgICAgICAgICAgICAgIHRvcCA9IE1hdGguY2VpbCh0b3ApOyAvLyB6b29tIGNhbiBnaXZlIHdlaXJkIGZsb2F0aW5nLXBvaW50IHZhbHVlcy4gcmF0aGVyIHNjcm9sbCBhIGxpdHRsZSBiaXQgZnVydGhlclxuICAgICAgICAgICAgICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AgKz0gMTsgLy8gdG8gb3ZlcmNvbWUgdG9wIGJvcmRlciB0aGF0IHNsb3RzIGJleW9uZCB0aGUgZmlyc3QgaGF2ZS4gbG9va3MgYmV0dGVyXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb25TY3JvbGxUb3BSZXF1ZXN0KHRvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUNvbENvb3JkcyA9IChjb2xDb29yZHMpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY29sQ29vcmRzID0gY29sQ29vcmRzO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVNsYXRDb29yZHMgPSAoc2xhdENvb3JkcykgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IHNsYXRDb29yZHMgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5vblNsYXRDb29yZHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uU2xhdENvb3JkcyhzbGF0Q29vcmRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgc3RhdGUgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1ib2R5XCIsIHJlZjogdGhpcy5oYW5kbGVSb290RWwsIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgLy8gdGhlc2UgcHJvcHMgYXJlIGltcG9ydGFudCB0byBnaXZlIHRoaXMgd3JhcHBlciBjb3JyZWN0IGRpbWVuc2lvbnMgZm9yIGludGVyYWN0aW9uc1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGlmIHdlIHNldCBpdCBoZXJlLCBjYW4gd2UgYXZvaWQgZ2l2aW5nIHRvIGlubmVyIHRhYmxlcz9cbiAgICAgICAgICAgICAgICB3aWR0aDogcHJvcHMuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICAgICAgbWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsXG4gICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFRpbWVDb2xzU2xhdHMsIHsgYXhpczogcHJvcHMuYXhpcywgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCBzbGF0TWV0YXM6IHByb3BzLnNsYXRNZXRhcywgY2xpZW50V2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLCBtaW5IZWlnaHQ6IHByb3BzLmV4cGFuZFJvd3MgPyBwcm9wcy5jbGllbnRIZWlnaHQgOiAnJywgdGFibGVNaW5XaWR0aDogcHJvcHMudGFibGVNaW5XaWR0aCwgdGFibGVDb2xHcm91cE5vZGU6IHByb3BzLmF4aXMgPyBwcm9wcy50YWJsZUNvbEdyb3VwTm9kZSA6IG51bGwgLyogYXhpcyBkZXBlbmRzIG9uIHRoZSBjb2xncm91cCdzIHNocmlua2luZyAqLywgb25Db29yZHM6IHRoaXMuaGFuZGxlU2xhdENvb3JkcyB9KSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoVGltZUNvbHNDb250ZW50LCB7IGNlbGxzOiBwcm9wcy5jZWxscywgYXhpczogcHJvcHMuYXhpcywgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCBidXNpbmVzc0hvdXJTZWdzOiBwcm9wcy5idXNpbmVzc0hvdXJTZWdzLCBiZ0V2ZW50U2VnczogcHJvcHMuYmdFdmVudFNlZ3MsIGZnRXZlbnRTZWdzOiBwcm9wcy5mZ0V2ZW50U2VncywgZGF0ZVNlbGVjdGlvblNlZ3M6IHByb3BzLmRhdGVTZWxlY3Rpb25TZWdzLCBldmVudFNlbGVjdGlvbjogcHJvcHMuZXZlbnRTZWxlY3Rpb24sIGV2ZW50RHJhZzogcHJvcHMuZXZlbnREcmFnLCBldmVudFJlc2l6ZTogcHJvcHMuZXZlbnRSZXNpemUsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsIG5vd0RhdGU6IHByb3BzLm5vd0RhdGUsIG5vd0luZGljYXRvclNlZ3M6IHByb3BzLm5vd0luZGljYXRvclNlZ3MsIGNsaWVudFdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCwgdGFibGVNaW5XaWR0aDogcHJvcHMudGFibGVNaW5XaWR0aCwgdGFibGVDb2xHcm91cE5vZGU6IHByb3BzLnRhYmxlQ29sR3JvdXBOb2RlLCBzbGF0Q29vcmRzOiBzdGF0ZS5zbGF0Q29vcmRzLCBvbkNvbENvb3JkczogdGhpcy5oYW5kbGVDb2xDb29yZHMsIGZvclByaW50OiBwcm9wcy5mb3JQcmludCB9KSkpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxSZXNwb25kZXIgPSB0aGlzLmNvbnRleHQuY3JlYXRlU2Nyb2xsUmVzcG9uZGVyKHRoaXMuaGFuZGxlU2Nyb2xsUmVxdWVzdCk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxSZXNwb25kZXIudXBkYXRlKHByZXZQcm9wcy5kYXRlUHJvZmlsZSAhPT0gdGhpcy5wcm9wcy5kYXRlUHJvZmlsZSk7XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICB0aGlzLnNjcm9sbFJlc3BvbmRlci5kZXRhY2goKTtcbiAgICB9XG4gICAgcXVlcnlIaXQocG9zaXRpb25MZWZ0LCBwb3NpdGlvblRvcCkge1xuICAgICAgICBsZXQgeyBkYXRlRW52LCBvcHRpb25zIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCB7IGNvbENvb3JkcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgZGF0ZVByb2ZpbGUgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCB7IHNsYXRDb29yZHMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGxldCB7IHNuYXBEdXJhdGlvbiwgc25hcHNQZXJTbG90IH0gPSB0aGlzLnByb2Nlc3NTbG90T3B0aW9ucyh0aGlzLnByb3BzLnNsb3REdXJhdGlvbiwgb3B0aW9ucy5zbmFwRHVyYXRpb24pO1xuICAgICAgICBsZXQgY29sSW5kZXggPSBjb2xDb29yZHMubGVmdFRvSW5kZXgocG9zaXRpb25MZWZ0KTtcbiAgICAgICAgbGV0IHNsYXRJbmRleCA9IHNsYXRDb29yZHMucG9zaXRpb25zLnRvcFRvSW5kZXgocG9zaXRpb25Ub3ApO1xuICAgICAgICBpZiAoY29sSW5kZXggIT0gbnVsbCAmJiBzbGF0SW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGNlbGwgPSB0aGlzLnByb3BzLmNlbGxzW2NvbEluZGV4XTtcbiAgICAgICAgICAgIGxldCBzbGF0VG9wID0gc2xhdENvb3Jkcy5wb3NpdGlvbnMudG9wc1tzbGF0SW5kZXhdO1xuICAgICAgICAgICAgbGV0IHNsYXRIZWlnaHQgPSBzbGF0Q29vcmRzLnBvc2l0aW9ucy5nZXRIZWlnaHQoc2xhdEluZGV4KTtcbiAgICAgICAgICAgIGxldCBwYXJ0aWFsID0gKHBvc2l0aW9uVG9wIC0gc2xhdFRvcCkgLyBzbGF0SGVpZ2h0OyAvLyBmbG9hdGluZyBwb2ludCBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICAgICAgICBsZXQgbG9jYWxTbmFwSW5kZXggPSBNYXRoLmZsb29yKHBhcnRpYWwgKiBzbmFwc1BlclNsb3QpOyAvLyB0aGUgc25hcCAjIHJlbGF0aXZlIHRvIHN0YXJ0IG9mIHNsYXRcbiAgICAgICAgICAgIGxldCBzbmFwSW5kZXggPSBzbGF0SW5kZXggKiBzbmFwc1BlclNsb3QgKyBsb2NhbFNuYXBJbmRleDtcbiAgICAgICAgICAgIGxldCBkYXlEYXRlID0gdGhpcy5wcm9wcy5jZWxsc1tjb2xJbmRleF0uZGF0ZTtcbiAgICAgICAgICAgIGxldCB0aW1lID0gYWRkRHVyYXRpb25zKGRhdGVQcm9maWxlLnNsb3RNaW5UaW1lLCBtdWx0aXBseUR1cmF0aW9uKHNuYXBEdXJhdGlvbiwgc25hcEluZGV4KSk7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBkYXRlRW52LmFkZChkYXlEYXRlLCB0aW1lKTtcbiAgICAgICAgICAgIGxldCBlbmQgPSBkYXRlRW52LmFkZChzdGFydCwgc25hcER1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0ZVByb2ZpbGUsXG4gICAgICAgICAgICAgICAgZGF0ZVNwYW46IE9iamVjdC5hc3NpZ24oeyByYW5nZTogeyBzdGFydCwgZW5kIH0sIGFsbERheTogZmFsc2UgfSwgY2VsbC5leHRyYURhdGVTcGFuKSxcbiAgICAgICAgICAgICAgICBkYXlFbDogY29sQ29vcmRzLmVsc1tjb2xJbmRleF0sXG4gICAgICAgICAgICAgICAgcmVjdDoge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBjb2xDb29yZHMubGVmdHNbY29sSW5kZXhdLFxuICAgICAgICAgICAgICAgICAgICByaWdodDogY29sQ29vcmRzLnJpZ2h0c1tjb2xJbmRleF0sXG4gICAgICAgICAgICAgICAgICAgIHRvcDogc2xhdFRvcCxcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tOiBzbGF0VG9wICsgc2xhdEhlaWdodCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGxheWVyOiAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBwcm9jZXNzU2xvdE9wdGlvbnMoc2xvdER1cmF0aW9uLCBzbmFwRHVyYXRpb25PdmVycmlkZSkge1xuICAgIGxldCBzbmFwRHVyYXRpb24gPSBzbmFwRHVyYXRpb25PdmVycmlkZSB8fCBzbG90RHVyYXRpb247XG4gICAgbGV0IHNuYXBzUGVyU2xvdCA9IHdob2xlRGl2aWRlRHVyYXRpb25zKHNsb3REdXJhdGlvbiwgc25hcER1cmF0aW9uKTtcbiAgICBpZiAoc25hcHNQZXJTbG90ID09PSBudWxsKSB7XG4gICAgICAgIHNuYXBEdXJhdGlvbiA9IHNsb3REdXJhdGlvbjtcbiAgICAgICAgc25hcHNQZXJTbG90ID0gMTtcbiAgICAgICAgLy8gVE9ETzogc2F5IHdhcm5pbmc/XG4gICAgfVxuICAgIHJldHVybiB7IHNuYXBEdXJhdGlvbiwgc25hcHNQZXJTbG90IH07XG59XG5cbmNsYXNzIERheVRpbWVDb2xzU2xpY2VyIGV4dGVuZHMgU2xpY2VyIHtcbiAgICBzbGljZVJhbmdlKHJhbmdlLCBkYXlSYW5nZXMpIHtcbiAgICAgICAgbGV0IHNlZ3MgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgZGF5UmFuZ2VzLmxlbmd0aDsgY29sICs9IDEpIHtcbiAgICAgICAgICAgIGxldCBzZWdSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhyYW5nZSwgZGF5UmFuZ2VzW2NvbF0pO1xuICAgICAgICAgICAgaWYgKHNlZ1JhbmdlKSB7XG4gICAgICAgICAgICAgICAgc2Vncy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHNlZ1JhbmdlLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IHNlZ1JhbmdlLmVuZCxcbiAgICAgICAgICAgICAgICAgICAgaXNTdGFydDogc2VnUmFuZ2Uuc3RhcnQudmFsdWVPZigpID09PSByYW5nZS5zdGFydC52YWx1ZU9mKCksXG4gICAgICAgICAgICAgICAgICAgIGlzRW5kOiBzZWdSYW5nZS5lbmQudmFsdWVPZigpID09PSByYW5nZS5lbmQudmFsdWVPZigpLFxuICAgICAgICAgICAgICAgICAgICBjb2wsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlZ3M7XG4gICAgfVxufVxuXG5jbGFzcyBEYXlUaW1lQ29scyBleHRlbmRzIERhdGVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmJ1aWxkRGF5UmFuZ2VzID0gbWVtb2l6ZShidWlsZERheVJhbmdlcyk7XG4gICAgICAgIHRoaXMuc2xpY2VyID0gbmV3IERheVRpbWVDb2xzU2xpY2VyKCk7XG4gICAgICAgIHRoaXMudGltZUNvbHNSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgZGF0ZVByb2ZpbGUsIGRheVRhYmxlTW9kZWwgfSA9IHByb3BzO1xuICAgICAgICBsZXQgeyBub3dJbmRpY2F0b3IsIG5leHREYXlUaHJlc2hvbGQgfSA9IGNvbnRleHQub3B0aW9ucztcbiAgICAgICAgbGV0IGRheVJhbmdlcyA9IHRoaXMuYnVpbGREYXlSYW5nZXMoZGF5VGFibGVNb2RlbCwgZGF0ZVByb2ZpbGUsIGNvbnRleHQuZGF0ZUVudik7XG4gICAgICAgIC8vIGdpdmUgaXQgdGhlIGZpcnN0IHJvdyBvZiBjZWxsc1xuICAgICAgICAvLyBUT0RPOiB3b3VsZCBtb3ZlIHRoaXMgZnVydGhlciBkb3duIGhpZXJhcmNoeSwgYnV0IHNsaWNlTm93RGF0ZSBuZWVkcyBpdFxuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoTm93VGltZXIsIHsgdW5pdDogbm93SW5kaWNhdG9yID8gJ21pbnV0ZScgOiAnZGF5JyB9LCAobm93RGF0ZSwgdG9kYXlSYW5nZSkgPT4gKGNyZWF0ZUVsZW1lbnQoVGltZUNvbHMsIE9iamVjdC5hc3NpZ24oeyByZWY6IHRoaXMudGltZUNvbHNSZWYgfSwgdGhpcy5zbGljZXIuc2xpY2VQcm9wcyhwcm9wcywgZGF0ZVByb2ZpbGUsIG51bGwsIGNvbnRleHQsIGRheVJhbmdlcyksIHsgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50LCBheGlzOiBwcm9wcy5heGlzLCBkYXRlUHJvZmlsZTogZGF0ZVByb2ZpbGUsIHNsYXRNZXRhczogcHJvcHMuc2xhdE1ldGFzLCBzbG90RHVyYXRpb246IHByb3BzLnNsb3REdXJhdGlvbiwgY2VsbHM6IGRheVRhYmxlTW9kZWwuY2VsbHNbMF0sIHRhYmxlQ29sR3JvdXBOb2RlOiBwcm9wcy50YWJsZUNvbEdyb3VwTm9kZSwgdGFibGVNaW5XaWR0aDogcHJvcHMudGFibGVNaW5XaWR0aCwgY2xpZW50V2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQ6IHByb3BzLmNsaWVudEhlaWdodCwgZXhwYW5kUm93czogcHJvcHMuZXhwYW5kUm93cywgbm93RGF0ZTogbm93RGF0ZSwgbm93SW5kaWNhdG9yU2Vnczogbm93SW5kaWNhdG9yICYmIHRoaXMuc2xpY2VyLnNsaWNlTm93RGF0ZShub3dEYXRlLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgY29udGV4dCwgZGF5UmFuZ2VzKSwgdG9kYXlSYW5nZTogdG9kYXlSYW5nZSwgb25TY3JvbGxUb3BSZXF1ZXN0OiBwcm9wcy5vblNjcm9sbFRvcFJlcXVlc3QsIG9uU2xhdENvb3JkczogcHJvcHMub25TbGF0Q29vcmRzIH0pKSkpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBidWlsZERheVJhbmdlcyhkYXlUYWJsZU1vZGVsLCBkYXRlUHJvZmlsZSwgZGF0ZUVudikge1xuICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICBmb3IgKGxldCBkYXRlIG9mIGRheVRhYmxlTW9kZWwuaGVhZGVyRGF0ZXMpIHtcbiAgICAgICAgcmFuZ2VzLnB1c2goe1xuICAgICAgICAgICAgc3RhcnQ6IGRhdGVFbnYuYWRkKGRhdGUsIGRhdGVQcm9maWxlLnNsb3RNaW5UaW1lKSxcbiAgICAgICAgICAgIGVuZDogZGF0ZUVudi5hZGQoZGF0ZSwgZGF0ZVByb2ZpbGUuc2xvdE1heFRpbWUpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlcztcbn1cblxuLy8gcG90ZW50aWFsIG5pY2UgdmFsdWVzIGZvciB0aGUgc2xvdC1kdXJhdGlvbiBhbmQgaW50ZXJ2YWwtZHVyYXRpb25cbi8vIGZyb20gbGFyZ2VzdCB0byBzbWFsbGVzdFxuY29uc3QgU1RPQ0tfU1VCX0RVUkFUSU9OUyA9IFtcbiAgICB7IGhvdXJzOiAxIH0sXG4gICAgeyBtaW51dGVzOiAzMCB9LFxuICAgIHsgbWludXRlczogMTUgfSxcbiAgICB7IHNlY29uZHM6IDMwIH0sXG4gICAgeyBzZWNvbmRzOiAxNSB9LFxuXTtcbmZ1bmN0aW9uIGJ1aWxkU2xhdE1ldGFzKHNsb3RNaW5UaW1lLCBzbG90TWF4VGltZSwgZXhwbGljaXRMYWJlbEludGVydmFsLCBzbG90RHVyYXRpb24sIGRhdGVFbnYpIHtcbiAgICBsZXQgZGF5U3RhcnQgPSBuZXcgRGF0ZSgwKTtcbiAgICBsZXQgc2xhdFRpbWUgPSBzbG90TWluVGltZTtcbiAgICBsZXQgc2xhdEl0ZXJhdG9yID0gY3JlYXRlRHVyYXRpb24oMCk7XG4gICAgbGV0IGxhYmVsSW50ZXJ2YWwgPSBleHBsaWNpdExhYmVsSW50ZXJ2YWwgfHwgY29tcHV0ZUxhYmVsSW50ZXJ2YWwoc2xvdER1cmF0aW9uKTtcbiAgICBsZXQgbWV0YXMgPSBbXTtcbiAgICB3aGlsZSAoYXNSb3VnaE1zKHNsYXRUaW1lKSA8IGFzUm91Z2hNcyhzbG90TWF4VGltZSkpIHtcbiAgICAgICAgbGV0IGRhdGUgPSBkYXRlRW52LmFkZChkYXlTdGFydCwgc2xhdFRpbWUpO1xuICAgICAgICBsZXQgaXNMYWJlbGVkID0gd2hvbGVEaXZpZGVEdXJhdGlvbnMoc2xhdEl0ZXJhdG9yLCBsYWJlbEludGVydmFsKSAhPT0gbnVsbDtcbiAgICAgICAgbWV0YXMucHVzaCh7XG4gICAgICAgICAgICBkYXRlLFxuICAgICAgICAgICAgdGltZTogc2xhdFRpbWUsXG4gICAgICAgICAgICBrZXk6IGRhdGUudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIGlzb1RpbWVTdHI6IGZvcm1hdElzb1RpbWVTdHJpbmcoZGF0ZSksXG4gICAgICAgICAgICBpc0xhYmVsZWQsXG4gICAgICAgIH0pO1xuICAgICAgICBzbGF0VGltZSA9IGFkZER1cmF0aW9ucyhzbGF0VGltZSwgc2xvdER1cmF0aW9uKTtcbiAgICAgICAgc2xhdEl0ZXJhdG9yID0gYWRkRHVyYXRpb25zKHNsYXRJdGVyYXRvciwgc2xvdER1cmF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIG1ldGFzO1xufVxuLy8gQ29tcHV0ZXMgYW4gYXV0b21hdGljIHZhbHVlIGZvciBzbG90TGFiZWxJbnRlcnZhbFxuZnVuY3Rpb24gY29tcHV0ZUxhYmVsSW50ZXJ2YWwoc2xvdER1cmF0aW9uKSB7XG4gICAgbGV0IGk7XG4gICAgbGV0IGxhYmVsSW50ZXJ2YWw7XG4gICAgbGV0IHNsb3RzUGVyTGFiZWw7XG4gICAgLy8gZmluZCB0aGUgc21hbGxlc3Qgc3RvY2sgbGFiZWwgaW50ZXJ2YWwgdGhhdCByZXN1bHRzIGluIG1vcmUgdGhhbiBvbmUgc2xvdHMtcGVyLWxhYmVsXG4gICAgZm9yIChpID0gU1RPQ0tfU1VCX0RVUkFUSU9OUy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICBsYWJlbEludGVydmFsID0gY3JlYXRlRHVyYXRpb24oU1RPQ0tfU1VCX0RVUkFUSU9OU1tpXSk7XG4gICAgICAgIHNsb3RzUGVyTGFiZWwgPSB3aG9sZURpdmlkZUR1cmF0aW9ucyhsYWJlbEludGVydmFsLCBzbG90RHVyYXRpb24pO1xuICAgICAgICBpZiAoc2xvdHNQZXJMYWJlbCAhPT0gbnVsbCAmJiBzbG90c1BlckxhYmVsID4gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGxhYmVsSW50ZXJ2YWw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNsb3REdXJhdGlvbjsgLy8gZmFsbCBiYWNrXG59XG5cbmNsYXNzIERheVRpbWVDb2xzVmlldyBleHRlbmRzIFRpbWVDb2xzVmlldyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuYnVpbGRUaW1lQ29sc01vZGVsID0gbWVtb2l6ZShidWlsZFRpbWVDb2xzTW9kZWwpO1xuICAgICAgICB0aGlzLmJ1aWxkU2xhdE1ldGFzID0gbWVtb2l6ZShidWlsZFNsYXRNZXRhcyk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgb3B0aW9ucywgZGF0ZUVudiwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IGRhdGVQcm9maWxlIH0gPSBwcm9wcztcbiAgICAgICAgbGV0IGRheVRhYmxlTW9kZWwgPSB0aGlzLmJ1aWxkVGltZUNvbHNNb2RlbChkYXRlUHJvZmlsZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IpO1xuICAgICAgICBsZXQgc3BsaXRQcm9wcyA9IHRoaXMuYWxsRGF5U3BsaXR0ZXIuc3BsaXRQcm9wcyhwcm9wcyk7XG4gICAgICAgIGxldCBzbGF0TWV0YXMgPSB0aGlzLmJ1aWxkU2xhdE1ldGFzKGRhdGVQcm9maWxlLnNsb3RNaW5UaW1lLCBkYXRlUHJvZmlsZS5zbG90TWF4VGltZSwgb3B0aW9ucy5zbG90TGFiZWxJbnRlcnZhbCwgb3B0aW9ucy5zbG90RHVyYXRpb24sIGRhdGVFbnYpO1xuICAgICAgICBsZXQgeyBkYXlNaW5XaWR0aCB9ID0gb3B0aW9ucztcbiAgICAgICAgbGV0IGhhc0F0dGFjaGVkQXhpcyA9ICFkYXlNaW5XaWR0aDtcbiAgICAgICAgbGV0IGhhc0RldGFjaGVkQXhpcyA9IGRheU1pbldpZHRoO1xuICAgICAgICBsZXQgaGVhZGVyQ29udGVudCA9IG9wdGlvbnMuZGF5SGVhZGVycyAmJiAoY3JlYXRlRWxlbWVudChEYXlIZWFkZXIsIHsgZGF0ZXM6IGRheVRhYmxlTW9kZWwuaGVhZGVyRGF0ZXMsIGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSwgZGF0ZXNSZXBEaXN0aW5jdERheXM6IHRydWUsIHJlbmRlckludHJvOiBoYXNBdHRhY2hlZEF4aXMgPyB0aGlzLnJlbmRlckhlYWRBeGlzIDogbnVsbCB9KSk7XG4gICAgICAgIGxldCBhbGxEYXlDb250ZW50ID0gKG9wdGlvbnMuYWxsRGF5U2xvdCAhPT0gZmFsc2UpICYmICgoY29udGVudEFyZykgPT4gKGNyZWF0ZUVsZW1lbnQoRGF5VGFibGUsIE9iamVjdC5hc3NpZ24oe30sIHNwbGl0UHJvcHMuYWxsRGF5LCB7IGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSwgZGF5VGFibGVNb2RlbDogZGF5VGFibGVNb2RlbCwgbmV4dERheVRocmVzaG9sZDogb3B0aW9ucy5uZXh0RGF5VGhyZXNob2xkLCB0YWJsZU1pbldpZHRoOiBjb250ZW50QXJnLnRhYmxlTWluV2lkdGgsIGNvbEdyb3VwTm9kZTogY29udGVudEFyZy50YWJsZUNvbEdyb3VwTm9kZSwgcmVuZGVyUm93SW50cm86IGhhc0F0dGFjaGVkQXhpcyA/IHRoaXMucmVuZGVyVGFibGVSb3dBeGlzIDogbnVsbCwgc2hvd1dlZWtOdW1iZXJzOiBmYWxzZSwgZXhwYW5kUm93czogZmFsc2UsIGhlYWRlckFsaWduRWxSZWY6IHRoaXMuaGVhZGVyRWxSZWYsIGNsaWVudFdpZHRoOiBjb250ZW50QXJnLmNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQ6IGNvbnRlbnRBcmcuY2xpZW50SGVpZ2h0LCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQgfSwgdGhpcy5nZXRBbGxEYXlNYXhFdmVudFByb3BzKCkpKSkpO1xuICAgICAgICBsZXQgdGltZUdyaWRDb250ZW50ID0gKGNvbnRlbnRBcmcpID0+IChjcmVhdGVFbGVtZW50KERheVRpbWVDb2xzLCBPYmplY3QuYXNzaWduKHt9LCBzcGxpdFByb3BzLnRpbWVkLCB7IGRheVRhYmxlTW9kZWw6IGRheVRhYmxlTW9kZWwsIGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSwgYXhpczogaGFzQXR0YWNoZWRBeGlzLCBzbG90RHVyYXRpb246IG9wdGlvbnMuc2xvdER1cmF0aW9uLCBzbGF0TWV0YXM6IHNsYXRNZXRhcywgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50LCB0YWJsZUNvbEdyb3VwTm9kZTogY29udGVudEFyZy50YWJsZUNvbEdyb3VwTm9kZSwgdGFibGVNaW5XaWR0aDogY29udGVudEFyZy50YWJsZU1pbldpZHRoLCBjbGllbnRXaWR0aDogY29udGVudEFyZy5jbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0OiBjb250ZW50QXJnLmNsaWVudEhlaWdodCwgb25TbGF0Q29vcmRzOiB0aGlzLmhhbmRsZVNsYXRDb29yZHMsIGV4cGFuZFJvd3M6IGNvbnRlbnRBcmcuZXhwYW5kUm93cywgb25TY3JvbGxUb3BSZXF1ZXN0OiB0aGlzLmhhbmRsZVNjcm9sbFRvcFJlcXVlc3QgfSkpKTtcbiAgICAgICAgcmV0dXJuIGhhc0RldGFjaGVkQXhpc1xuICAgICAgICAgICAgPyB0aGlzLnJlbmRlckhTY3JvbGxMYXlvdXQoaGVhZGVyQ29udGVudCwgYWxsRGF5Q29udGVudCwgdGltZUdyaWRDb250ZW50LCBkYXlUYWJsZU1vZGVsLmNvbENudCwgZGF5TWluV2lkdGgsIHNsYXRNZXRhcywgdGhpcy5zdGF0ZS5zbGF0Q29vcmRzKVxuICAgICAgICAgICAgOiB0aGlzLnJlbmRlclNpbXBsZUxheW91dChoZWFkZXJDb250ZW50LCBhbGxEYXlDb250ZW50LCB0aW1lR3JpZENvbnRlbnQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkVGltZUNvbHNNb2RlbChkYXRlUHJvZmlsZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IpIHtcbiAgICBsZXQgZGF5U2VyaWVzID0gbmV3IERheVNlcmllc01vZGVsKGRhdGVQcm9maWxlLnJlbmRlclJhbmdlLCBkYXRlUHJvZmlsZUdlbmVyYXRvcik7XG4gICAgcmV0dXJuIG5ldyBEYXlUYWJsZU1vZGVsKGRheVNlcmllcywgZmFsc2UpO1xufVxuXG52YXIgY3NzXzI0OHogPSBcIi5mYy12LWV2ZW50e2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmMtZXZlbnQtYmctY29sb3IpO2JvcmRlcjoxcHggc29saWQgdmFyKC0tZmMtZXZlbnQtYm9yZGVyLWNvbG9yKTtkaXNwbGF5OmJsb2NrfS5mYy12LWV2ZW50IC5mYy1ldmVudC1tYWlue2NvbG9yOnZhcigtLWZjLWV2ZW50LXRleHQtY29sb3IpO2hlaWdodDoxMDAlfS5mYy12LWV2ZW50IC5mYy1ldmVudC1tYWluLWZyYW1le2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47aGVpZ2h0OjEwMCV9LmZjLXYtZXZlbnQgLmZjLWV2ZW50LXRpbWV7ZmxleC1ncm93OjA7ZmxleC1zaHJpbms6MDttYXgtaGVpZ2h0OjEwMCU7b3ZlcmZsb3c6aGlkZGVufS5mYy12LWV2ZW50IC5mYy1ldmVudC10aXRsZS1jb250YWluZXJ7ZmxleC1ncm93OjE7ZmxleC1zaHJpbms6MTttaW4taGVpZ2h0OjB9LmZjLXYtZXZlbnQgLmZjLWV2ZW50LXRpdGxle2JvdHRvbTowO21heC1oZWlnaHQ6MTAwJTtvdmVyZmxvdzpoaWRkZW47dG9wOjB9LmZjLXYtZXZlbnQ6bm90KC5mYy1ldmVudC1zdGFydCl7Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czowO2JvcmRlci10b3AtcmlnaHQtcmFkaXVzOjA7Ym9yZGVyLXRvcC13aWR0aDowfS5mYy12LWV2ZW50Om5vdCguZmMtZXZlbnQtZW5kKXtib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOjA7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6MDtib3JkZXItYm90dG9tLXdpZHRoOjB9LmZjLXYtZXZlbnQuZmMtZXZlbnQtc2VsZWN0ZWQ6YmVmb3Jle2xlZnQ6LTEwcHg7cmlnaHQ6LTEwcHh9LmZjLXYtZXZlbnQgLmZjLWV2ZW50LXJlc2l6ZXItc3RhcnR7Y3Vyc29yOm4tcmVzaXplfS5mYy12LWV2ZW50IC5mYy1ldmVudC1yZXNpemVyLWVuZHtjdXJzb3I6cy1yZXNpemV9LmZjLXYtZXZlbnQ6bm90KC5mYy1ldmVudC1zZWxlY3RlZCkgLmZjLWV2ZW50LXJlc2l6ZXJ7aGVpZ2h0OnZhcigtLWZjLWV2ZW50LXJlc2l6ZXItdGhpY2tuZXNzKTtsZWZ0OjA7cmlnaHQ6MH0uZmMtdi1ldmVudDpub3QoLmZjLWV2ZW50LXNlbGVjdGVkKSAuZmMtZXZlbnQtcmVzaXplci1zdGFydHt0b3A6Y2FsYyh2YXIoLS1mYy1ldmVudC1yZXNpemVyLXRoaWNrbmVzcykvLTIpfS5mYy12LWV2ZW50Om5vdCguZmMtZXZlbnQtc2VsZWN0ZWQpIC5mYy1ldmVudC1yZXNpemVyLWVuZHtib3R0b206Y2FsYyh2YXIoLS1mYy1ldmVudC1yZXNpemVyLXRoaWNrbmVzcykvLTIpfS5mYy12LWV2ZW50LmZjLWV2ZW50LXNlbGVjdGVkIC5mYy1ldmVudC1yZXNpemVye2xlZnQ6NTAlO21hcmdpbi1sZWZ0OmNhbGModmFyKC0tZmMtZXZlbnQtcmVzaXplci1kb3QtdG90YWwtd2lkdGgpLy0yKX0uZmMtdi1ldmVudC5mYy1ldmVudC1zZWxlY3RlZCAuZmMtZXZlbnQtcmVzaXplci1zdGFydHt0b3A6Y2FsYyh2YXIoLS1mYy1ldmVudC1yZXNpemVyLWRvdC10b3RhbC13aWR0aCkvLTIpfS5mYy12LWV2ZW50LmZjLWV2ZW50LXNlbGVjdGVkIC5mYy1ldmVudC1yZXNpemVyLWVuZHtib3R0b206Y2FsYyh2YXIoLS1mYy1ldmVudC1yZXNpemVyLWRvdC10b3RhbC13aWR0aCkvLTIpfS5mYyAuZmMtdGltZWdyaWQgLmZjLWRheWdyaWQtYm9keXt6LWluZGV4OjJ9LmZjIC5mYy10aW1lZ3JpZC1kaXZpZGVye3BhZGRpbmc6MCAwIDJweH0uZmMgLmZjLXRpbWVncmlkLWJvZHl7bWluLWhlaWdodDoxMDAlO3Bvc2l0aW9uOnJlbGF0aXZlO3otaW5kZXg6MX0uZmMgLmZjLXRpbWVncmlkLWF4aXMtY2h1bmt7cG9zaXRpb246cmVsYXRpdmV9LmZjIC5mYy10aW1lZ3JpZC1heGlzLWNodW5rPnRhYmxlLC5mYyAuZmMtdGltZWdyaWQtc2xvdHN7cG9zaXRpb246cmVsYXRpdmU7ei1pbmRleDoxfS5mYyAuZmMtdGltZWdyaWQtc2xvdHtib3JkZXItYm90dG9tOjA7aGVpZ2h0OjEuNWVtfS5mYyAuZmMtdGltZWdyaWQtc2xvdDplbXB0eTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXDAwYTBcXFwifS5mYyAuZmMtdGltZWdyaWQtc2xvdC1taW5vcntib3JkZXItdG9wLXN0eWxlOmRvdHRlZH0uZmMgLmZjLXRpbWVncmlkLXNsb3QtbGFiZWwtY3VzaGlvbntkaXNwbGF5OmlubGluZS1ibG9jazt3aGl0ZS1zcGFjZTpub3dyYXB9LmZjIC5mYy10aW1lZ3JpZC1zbG90LWxhYmVse3ZlcnRpY2FsLWFsaWduOm1pZGRsZX0uZmMgLmZjLXRpbWVncmlkLWF4aXMtY3VzaGlvbiwuZmMgLmZjLXRpbWVncmlkLXNsb3QtbGFiZWwtY3VzaGlvbntwYWRkaW5nOjAgNHB4fS5mYyAuZmMtdGltZWdyaWQtYXhpcy1mcmFtZS1saXF1aWR7aGVpZ2h0OjEwMCV9LmZjIC5mYy10aW1lZ3JpZC1heGlzLWZyYW1le2FsaWduLWl0ZW1zOmNlbnRlcjtkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OmZsZXgtZW5kO292ZXJmbG93OmhpZGRlbn0uZmMgLmZjLXRpbWVncmlkLWF4aXMtY3VzaGlvbntmbGV4LXNocmluazowO21heC13aWR0aDo2MHB4fS5mYy1kaXJlY3Rpb24tbHRyIC5mYy10aW1lZ3JpZC1zbG90LWxhYmVsLWZyYW1le3RleHQtYWxpZ246cmlnaHR9LmZjLWRpcmVjdGlvbi1ydGwgLmZjLXRpbWVncmlkLXNsb3QtbGFiZWwtZnJhbWV7dGV4dC1hbGlnbjpsZWZ0fS5mYy1saXF1aWQtaGFjayAuZmMtdGltZWdyaWQtYXhpcy1mcmFtZS1saXF1aWR7Ym90dG9tOjA7aGVpZ2h0OmF1dG87bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7dG9wOjB9LmZjIC5mYy10aW1lZ3JpZC1jb2wuZmMtZGF5LXRvZGF5e2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmMtdG9kYXktYmctY29sb3IpfS5mYyAuZmMtdGltZWdyaWQtY29sLWZyYW1le21pbi1oZWlnaHQ6MTAwJTtwb3NpdGlvbjpyZWxhdGl2ZX0uZmMtbWVkaWEtc2NyZWVuLmZjLWxpcXVpZC1oYWNrIC5mYy10aW1lZ3JpZC1jb2wtZnJhbWV7Ym90dG9tOjA7aGVpZ2h0OmF1dG87bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7dG9wOjB9LmZjLW1lZGlhLXNjcmVlbiAuZmMtdGltZWdyaWQtY29sc3tib3R0b206MDtsZWZ0OjA7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MDt0b3A6MH0uZmMtbWVkaWEtc2NyZWVuIC5mYy10aW1lZ3JpZC1jb2xzPnRhYmxle2hlaWdodDoxMDAlfS5mYy1tZWRpYS1zY3JlZW4gLmZjLXRpbWVncmlkLWNvbC1iZywuZmMtbWVkaWEtc2NyZWVuIC5mYy10aW1lZ3JpZC1jb2wtZXZlbnRzLC5mYy1tZWRpYS1zY3JlZW4gLmZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItY29udGFpbmVye2xlZnQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO3RvcDowfS5mYyAuZmMtdGltZWdyaWQtY29sLWJne3otaW5kZXg6Mn0uZmMgLmZjLXRpbWVncmlkLWNvbC1iZyAuZmMtbm9uLWJ1c2luZXNze3otaW5kZXg6MX0uZmMgLmZjLXRpbWVncmlkLWNvbC1iZyAuZmMtYmctZXZlbnR7ei1pbmRleDoyfS5mYyAuZmMtdGltZWdyaWQtY29sLWJnIC5mYy1oaWdobGlnaHR7ei1pbmRleDozfS5mYyAuZmMtdGltZWdyaWQtYmctaGFybmVzc3tsZWZ0OjA7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MH0uZmMgLmZjLXRpbWVncmlkLWNvbC1ldmVudHN7ei1pbmRleDozfS5mYyAuZmMtdGltZWdyaWQtbm93LWluZGljYXRvci1jb250YWluZXJ7Ym90dG9tOjA7b3ZlcmZsb3c6aGlkZGVufS5mYy1kaXJlY3Rpb24tbHRyIC5mYy10aW1lZ3JpZC1jb2wtZXZlbnRze21hcmdpbjowIDIuNSUgMCAycHh9LmZjLWRpcmVjdGlvbi1ydGwgLmZjLXRpbWVncmlkLWNvbC1ldmVudHN7bWFyZ2luOjAgMnB4IDAgMi41JX0uZmMtdGltZWdyaWQtZXZlbnQtaGFybmVzc3twb3NpdGlvbjphYnNvbHV0ZX0uZmMtdGltZWdyaWQtZXZlbnQtaGFybmVzcz4uZmMtdGltZWdyaWQtZXZlbnR7Ym90dG9tOjA7bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7dG9wOjB9LmZjLXRpbWVncmlkLWV2ZW50LWhhcm5lc3MtaW5zZXQgLmZjLXRpbWVncmlkLWV2ZW50LC5mYy10aW1lZ3JpZC1ldmVudC5mYy1ldmVudC1taXJyb3IsLmZjLXRpbWVncmlkLW1vcmUtbGlua3tib3gtc2hhZG93OjAgMCAwIDFweCB2YXIoLS1mYy1wYWdlLWJnLWNvbG9yKX0uZmMtdGltZWdyaWQtZXZlbnQsLmZjLXRpbWVncmlkLW1vcmUtbGlua3tib3JkZXItcmFkaXVzOjNweDtmb250LXNpemU6dmFyKC0tZmMtc21hbGwtZm9udC1zaXplKX0uZmMtdGltZWdyaWQtZXZlbnR7bWFyZ2luLWJvdHRvbToxcHh9LmZjLXRpbWVncmlkLWV2ZW50IC5mYy1ldmVudC1tYWlue3BhZGRpbmc6MXB4IDFweCAwfS5mYy10aW1lZ3JpZC1ldmVudCAuZmMtZXZlbnQtdGltZXtmb250LXNpemU6dmFyKC0tZmMtc21hbGwtZm9udC1zaXplKTttYXJnaW4tYm90dG9tOjFweDt3aGl0ZS1zcGFjZTpub3dyYXB9LmZjLXRpbWVncmlkLWV2ZW50LXNob3J0IC5mYy1ldmVudC1tYWluLWZyYW1le2ZsZXgtZGlyZWN0aW9uOnJvdztvdmVyZmxvdzpoaWRkZW59LmZjLXRpbWVncmlkLWV2ZW50LXNob3J0IC5mYy1ldmVudC10aW1lOmFmdGVye2NvbnRlbnQ6XFxcIlxcXFwwMGEwLVxcXFwwMGEwXFxcIn0uZmMtdGltZWdyaWQtZXZlbnQtc2hvcnQgLmZjLWV2ZW50LXRpdGxle2ZvbnQtc2l6ZTp2YXIoLS1mYy1zbWFsbC1mb250LXNpemUpfS5mYy10aW1lZ3JpZC1tb3JlLWxpbmt7YmFja2dyb3VuZDp2YXIoLS1mYy1tb3JlLWxpbmstYmctY29sb3IpO2NvbG9yOnZhcigtLWZjLW1vcmUtbGluay10ZXh0LWNvbG9yKTtjdXJzb3I6cG9pbnRlcjttYXJnaW4tYm90dG9tOjFweDtwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4Ojk5OTl9LmZjLXRpbWVncmlkLW1vcmUtbGluay1pbm5lcntwYWRkaW5nOjNweCAycHg7dG9wOjB9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLXRpbWVncmlkLW1vcmUtbGlua3tyaWdodDowfS5mYy1kaXJlY3Rpb24tcnRsIC5mYy10aW1lZ3JpZC1tb3JlLWxpbmt7bGVmdDowfS5mYyAuZmMtdGltZWdyaWQtbm93LWluZGljYXRvci1hcnJvdywuZmMgLmZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItbGluZXtwb2ludGVyLWV2ZW50czpub25lfS5mYyAuZmMtdGltZWdyaWQtbm93LWluZGljYXRvci1saW5le2JvcmRlci1jb2xvcjp2YXIoLS1mYy1ub3ctaW5kaWNhdG9yLWNvbG9yKTtib3JkZXItc3R5bGU6c29saWQ7Ym9yZGVyLXdpZHRoOjFweCAwIDA7bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7ei1pbmRleDo0fS5mYyAuZmMtdGltZWdyaWQtbm93LWluZGljYXRvci1hcnJvd3tib3JkZXItY29sb3I6dmFyKC0tZmMtbm93LWluZGljYXRvci1jb2xvcik7Ym9yZGVyLXN0eWxlOnNvbGlkO21hcmdpbi10b3A6LTVweDtwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OjR9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItYXJyb3d7Ym9yZGVyLWJvdHRvbS1jb2xvcjp0cmFuc3BhcmVudDtib3JkZXItdG9wLWNvbG9yOnRyYW5zcGFyZW50O2JvcmRlci13aWR0aDo1cHggMCA1cHggNnB4O2xlZnQ6MH0uZmMtZGlyZWN0aW9uLXJ0bCAuZmMtdGltZWdyaWQtbm93LWluZGljYXRvci1hcnJvd3tib3JkZXItYm90dG9tLWNvbG9yOnRyYW5zcGFyZW50O2JvcmRlci10b3AtY29sb3I6dHJhbnNwYXJlbnQ7Ym9yZGVyLXdpZHRoOjVweCA2cHggNXB4IDA7cmlnaHQ6MH1cIjtcbmluamVjdFN0eWxlcyhjc3NfMjQ4eik7XG5cbmV4cG9ydCB7IERheVRpbWVDb2xzLCBEYXlUaW1lQ29sc1NsaWNlciwgRGF5VGltZUNvbHNWaWV3LCBUaW1lQ29scywgVGltZUNvbHNTbGF0c0Nvb3JkcywgVGltZUNvbHNWaWV3LCBidWlsZERheVJhbmdlcywgYnVpbGRTbGF0TWV0YXMsIGJ1aWxkVGltZUNvbHNNb2RlbCB9O1xuIiwgImltcG9ydCB7IGNyZWF0ZVBsdWdpbiB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29yZS9pbmRleC5qcyc7XG5pbXBvcnQgeyBEYXlUaW1lQ29sc1ZpZXcgfSBmcm9tICcuL2ludGVybmFsLmpzJztcbmltcG9ydCAnQGZ1bGxjYWxlbmRhci9jb3JlL2ludGVybmFsLmpzJztcbmltcG9ydCAnQGZ1bGxjYWxlbmRhci9jb3JlL3ByZWFjdC5qcyc7XG5pbXBvcnQgJ0BmdWxsY2FsZW5kYXIvZGF5Z3JpZC9pbnRlcm5hbC5qcyc7XG5cbmNvbnN0IE9QVElPTl9SRUZJTkVSUyA9IHtcbiAgICBhbGxEYXlTbG90OiBCb29sZWFuLFxufTtcblxudmFyIGluZGV4ID0gY3JlYXRlUGx1Z2luKHtcbiAgICBuYW1lOiAnQGZ1bGxjYWxlbmRhci90aW1lZ3JpZCcsXG4gICAgaW5pdGlhbFZpZXc6ICd0aW1lR3JpZFdlZWsnLFxuICAgIG9wdGlvblJlZmluZXJzOiBPUFRJT05fUkVGSU5FUlMsXG4gICAgdmlld3M6IHtcbiAgICAgICAgdGltZUdyaWQ6IHtcbiAgICAgICAgICAgIGNvbXBvbmVudDogRGF5VGltZUNvbHNWaWV3LFxuICAgICAgICAgICAgdXNlc01pbk1heFRpbWU6IHRydWUsXG4gICAgICAgICAgICBhbGxEYXlTbG90OiB0cnVlLFxuICAgICAgICAgICAgc2xvdER1cmF0aW9uOiAnMDA6MzA6MDAnLFxuICAgICAgICAgICAgc2xvdEV2ZW50T3ZlcmxhcDogdHJ1ZSwgLy8gYSBiYWQgbmFtZS4gY29uZnVzZWQgd2l0aCBvdmVybGFwL2NvbnN0cmFpbnQgc3lzdGVtXG4gICAgICAgIH0sXG4gICAgICAgIHRpbWVHcmlkRGF5OiB7XG4gICAgICAgICAgICB0eXBlOiAndGltZUdyaWQnLFxuICAgICAgICAgICAgZHVyYXRpb246IHsgZGF5czogMSB9LFxuICAgICAgICB9LFxuICAgICAgICB0aW1lR3JpZFdlZWs6IHtcbiAgICAgICAgICAgIHR5cGU6ICd0aW1lR3JpZCcsXG4gICAgICAgICAgICBkdXJhdGlvbjogeyB3ZWVrczogMSB9LFxuICAgICAgICB9LFxuICAgIH0sXG59KTtcblxuZXhwb3J0IHsgaW5kZXggYXMgZGVmYXVsdCB9O1xuIiwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2NyZWF0ZUJpbmRpbmcgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xyXG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcclxuICAgICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcclxufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBvW2syXSA9IG1ba107XHJcbn0pO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBvKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIHApKSBfX2NyZWF0ZUJpbmRpbmcobywgbSwgcCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbi8qKiBAZGVwcmVjYXRlZCAqL1xyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbi8qKiBAZGVwcmVjYXRlZCAqL1xyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XHJcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcclxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICByZXR1cm4gcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkodG8sIGZyb20sIHBhY2spIHtcclxuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xyXG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xyXG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xyXG4gICAgdmFyIGksIHA7XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuXHJcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcclxufSkgOiBmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcclxuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBkZWZhdWx0OiBtb2QgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRJbihzdGF0ZSwgcmVjZWl2ZXIpIHtcclxuICAgIGlmIChyZWNlaXZlciA9PT0gbnVsbCB8fCAodHlwZW9mIHJlY2VpdmVyICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiByZWNlaXZlciAhPT0gXCJmdW5jdGlvblwiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB1c2UgJ2luJyBvcGVyYXRvciBvbiBub24tb2JqZWN0XCIpO1xyXG4gICAgcmV0dXJuIHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgPT09IHN0YXRlIDogc3RhdGUuaGFzKHJlY2VpdmVyKTtcclxufVxyXG4iLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCAiaW1wb3J0IHsgY3JlYXRlUGx1Z2luIH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb3JlL2luZGV4LmpzJztcbmltcG9ydCAqIGFzIHJydWxlTGliIGZyb20gJ3JydWxlJztcbmltcG9ydCB7IHBhcnNlTWFya2VyLCBpZGVudGl0eSwgY3JlYXRlRHVyYXRpb24gfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvcmUvaW50ZXJuYWwuanMnO1xuXG5jb25zdCByZWN1cnJpbmdUeXBlID0ge1xuICAgIHBhcnNlKGV2ZW50UHJvcHMsIGRhdGVFbnYpIHtcbiAgICAgICAgaWYgKGV2ZW50UHJvcHMucnJ1bGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGV2ZW50UlJ1bGVEYXRhID0gcGFyc2VFdmVudFJSdWxlKGV2ZW50UHJvcHMsIGRhdGVFbnYpO1xuICAgICAgICAgICAgaWYgKGV2ZW50UlJ1bGVEYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZURhdGE6IHsgcnJ1bGVTZXQ6IGV2ZW50UlJ1bGVEYXRhLnJydWxlU2V0LCBpc1RpbWVab25lU3BlY2lmaWVkOiBldmVudFJSdWxlRGF0YS5pc1RpbWVab25lU3BlY2lmaWVkIH0sXG4gICAgICAgICAgICAgICAgICAgIGFsbERheUd1ZXNzOiAhZXZlbnRSUnVsZURhdGEuaXNUaW1lU3BlY2lmaWVkLFxuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogZXZlbnRQcm9wcy5kdXJhdGlvbixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgZXhwYW5kKGV2ZW50UlJ1bGVEYXRhLCBmcmFtaW5nUmFuZ2UsIGRhdGVFbnYpIHtcbiAgICAgICAgbGV0IGRhdGVzO1xuICAgICAgICBpZiAoZXZlbnRSUnVsZURhdGEuaXNUaW1lWm9uZVNwZWNpZmllZCkge1xuICAgICAgICAgICAgZGF0ZXMgPSBldmVudFJSdWxlRGF0YS5ycnVsZVNldC5iZXR3ZWVuKGRhdGVFbnYudG9EYXRlKGZyYW1pbmdSYW5nZS5zdGFydCksIC8vIHJydWxlIGxpYiB3aWxsIHRyZWF0IGFzIFVUQy16b25lZFxuICAgICAgICAgICAgZGF0ZUVudi50b0RhdGUoZnJhbWluZ1JhbmdlLmVuZCksIC8vIChzYW1lKVxuICAgICAgICAgICAgdHJ1ZSkubWFwKChkYXRlKSA9PiBkYXRlRW52LmNyZWF0ZU1hcmtlcihkYXRlKSk7IC8vIGNvbnZlcnQgVVRDLXpvbmVkLWRhdGUgdG8gbG9jYWxlIGRhdGVtYXJrZXJcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHdoZW4gbm8gdGltZXpvbmUgaW4gZ2l2ZW4gc3RhcnQvZW5kLCB0aGUgcnJ1bGUgbGliIHdpbGwgYXNzdW1lIFVUQyxcbiAgICAgICAgICAgIC8vIHdoaWNoIGlzIHNhbWUgYXMgb3VyIERhdGVNYXJrZXJzLiBubyBuZWVkIHRvIG1hbmlwdWxhdGVcbiAgICAgICAgICAgIGRhdGVzID0gZXZlbnRSUnVsZURhdGEucnJ1bGVTZXQuYmV0d2VlbihmcmFtaW5nUmFuZ2Uuc3RhcnQsIGZyYW1pbmdSYW5nZS5lbmQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlcztcbiAgICB9LFxufTtcbmZ1bmN0aW9uIHBhcnNlRXZlbnRSUnVsZShldmVudFByb3BzLCBkYXRlRW52KSB7XG4gICAgbGV0IHJydWxlU2V0O1xuICAgIGxldCBpc1RpbWVTcGVjaWZpZWQgPSBmYWxzZTtcbiAgICBsZXQgaXNUaW1lWm9uZVNwZWNpZmllZCA9IGZhbHNlO1xuICAgIGlmICh0eXBlb2YgZXZlbnRQcm9wcy5ycnVsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbGV0IHJlcyA9IHBhcnNlUlJ1bGVTdHJpbmcoZXZlbnRQcm9wcy5ycnVsZSk7XG4gICAgICAgIHJydWxlU2V0ID0gcmVzLnJydWxlU2V0O1xuICAgICAgICBpc1RpbWVTcGVjaWZpZWQgPSByZXMuaXNUaW1lU3BlY2lmaWVkO1xuICAgICAgICBpc1RpbWVab25lU3BlY2lmaWVkID0gcmVzLmlzVGltZVpvbmVTcGVjaWZpZWQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZXZlbnRQcm9wcy5ycnVsZSA9PT0gJ29iamVjdCcgJiYgZXZlbnRQcm9wcy5ycnVsZSkgeyAvLyBub24tbnVsbCBvYmplY3RcbiAgICAgICAgbGV0IHJlcyA9IHBhcnNlUlJ1bGVPYmplY3QoZXZlbnRQcm9wcy5ycnVsZSwgZGF0ZUVudik7XG4gICAgICAgIHJydWxlU2V0ID0gbmV3IHJydWxlTGliLlJSdWxlU2V0KCk7XG4gICAgICAgIHJydWxlU2V0LnJydWxlKHJlcy5ycnVsZSk7XG4gICAgICAgIGlzVGltZVNwZWNpZmllZCA9IHJlcy5pc1RpbWVTcGVjaWZpZWQ7XG4gICAgICAgIGlzVGltZVpvbmVTcGVjaWZpZWQgPSByZXMuaXNUaW1lWm9uZVNwZWNpZmllZDtcbiAgICB9XG4gICAgLy8gY29udmVyeSB0byBhcnJheXMuIFRPRE86IGdlbmVyYWwgdXRpbD9cbiAgICBsZXQgZXhkYXRlSW5wdXRzID0gW10uY29uY2F0KGV2ZW50UHJvcHMuZXhkYXRlIHx8IFtdKTtcbiAgICBsZXQgZXhydWxlSW5wdXRzID0gW10uY29uY2F0KGV2ZW50UHJvcHMuZXhydWxlIHx8IFtdKTtcbiAgICBmb3IgKGxldCBleGRhdGVJbnB1dCBvZiBleGRhdGVJbnB1dHMpIHtcbiAgICAgICAgbGV0IHJlcyA9IHBhcnNlTWFya2VyKGV4ZGF0ZUlucHV0KTtcbiAgICAgICAgaXNUaW1lU3BlY2lmaWVkID0gaXNUaW1lU3BlY2lmaWVkIHx8ICFyZXMuaXNUaW1lVW5zcGVjaWZpZWQ7XG4gICAgICAgIGlzVGltZVpvbmVTcGVjaWZpZWQgPSBpc1RpbWVab25lU3BlY2lmaWVkIHx8IHJlcy50aW1lWm9uZU9mZnNldCAhPT0gbnVsbDtcbiAgICAgICAgcnJ1bGVTZXQuZXhkYXRlKG5ldyBEYXRlKHJlcy5tYXJrZXIudmFsdWVPZigpIC0gKHJlcy50aW1lWm9uZU9mZnNldCB8fCAwKSAqIDYwICogMTAwMCkpO1xuICAgIH1cbiAgICAvLyBUT0RPOiBleHJ1bGUgaXMgZGVwcmVjYXRlZC4gd2hhdCB0byBkbz8gKGh0dHBzOi8vaWNhbGVuZGFyLm9yZy9pQ2FsZW5kYXItUkZDLTU1NDUvYS0zLWRlcHJlY2F0ZWQtZmVhdHVyZXMuaHRtbClcbiAgICBmb3IgKGxldCBleHJ1bGVJbnB1dCBvZiBleHJ1bGVJbnB1dHMpIHtcbiAgICAgICAgbGV0IHJlcyA9IHBhcnNlUlJ1bGVPYmplY3QoZXhydWxlSW5wdXQsIGRhdGVFbnYpO1xuICAgICAgICBpc1RpbWVTcGVjaWZpZWQgPSBpc1RpbWVTcGVjaWZpZWQgfHwgcmVzLmlzVGltZVNwZWNpZmllZDtcbiAgICAgICAgaXNUaW1lWm9uZVNwZWNpZmllZCA9IGlzVGltZVpvbmVTcGVjaWZpZWQgfHwgcmVzLmlzVGltZVpvbmVTcGVjaWZpZWQ7XG4gICAgICAgIHJydWxlU2V0LmV4cnVsZShyZXMucnJ1bGUpO1xuICAgIH1cbiAgICByZXR1cm4geyBycnVsZVNldCwgaXNUaW1lU3BlY2lmaWVkLCBpc1RpbWVab25lU3BlY2lmaWVkIH07XG59XG5mdW5jdGlvbiBwYXJzZVJSdWxlT2JqZWN0KHJydWxlSW5wdXQsIGRhdGVFbnYpIHtcbiAgICBsZXQgaXNUaW1lU3BlY2lmaWVkID0gZmFsc2U7XG4gICAgbGV0IGlzVGltZVpvbmVTcGVjaWZpZWQgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBwcm9jZXNzRGF0ZUlucHV0KGRhdGVJbnB1dCkge1xuICAgICAgICBpZiAodHlwZW9mIGRhdGVJbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGxldCBtYXJrZXJEYXRhID0gcGFyc2VNYXJrZXIoZGF0ZUlucHV0KTtcbiAgICAgICAgICAgIGlmIChtYXJrZXJEYXRhKSB7XG4gICAgICAgICAgICAgICAgaXNUaW1lU3BlY2lmaWVkID0gaXNUaW1lU3BlY2lmaWVkIHx8ICFtYXJrZXJEYXRhLmlzVGltZVVuc3BlY2lmaWVkO1xuICAgICAgICAgICAgICAgIGlzVGltZVpvbmVTcGVjaWZpZWQgPSBpc1RpbWVab25lU3BlY2lmaWVkIHx8IG1hcmtlckRhdGEudGltZVpvbmVPZmZzZXQgIT09IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG1hcmtlckRhdGEubWFya2VyLnZhbHVlT2YoKSAtIChtYXJrZXJEYXRhLnRpbWVab25lT2Zmc2V0IHx8IDApICogNjAgKiAxMDAwKTsgLy8gTk9UIERSWVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGVJbnB1dDsgLy8gVE9ETzogd2hhdCBhYm91dCBudW1iZXIgdGltZXN0YW1wcz9cbiAgICB9XG4gICAgbGV0IHJydWxlT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcnJ1bGVJbnB1dCksIHsgZHRzdGFydDogcHJvY2Vzc0RhdGVJbnB1dChycnVsZUlucHV0LmR0c3RhcnQpLCB1bnRpbDogcHJvY2Vzc0RhdGVJbnB1dChycnVsZUlucHV0LnVudGlsKSwgZnJlcTogY29udmVydENvbnN0YW50KHJydWxlSW5wdXQuZnJlcSksIHdrc3Q6IHJydWxlSW5wdXQud2tzdCA9PSBudWxsXG4gICAgICAgICAgICA/IChkYXRlRW52LndlZWtEb3cgLSAxICsgNykgJSA3IC8vIGNvbnZlcnQgU3VuZGF5LWZpcnN0IHRvIE1vbmRheS1maXJzdFxuICAgICAgICAgICAgOiBjb252ZXJ0Q29uc3RhbnQocnJ1bGVJbnB1dC53a3N0KSwgYnl3ZWVrZGF5OiBjb252ZXJ0Q29uc3RhbnRzKHJydWxlSW5wdXQuYnl3ZWVrZGF5KSB9KTtcbiAgICByZXR1cm4geyBycnVsZTogbmV3IHJydWxlTGliLlJSdWxlKHJydWxlT3B0aW9ucyksIGlzVGltZVNwZWNpZmllZCwgaXNUaW1lWm9uZVNwZWNpZmllZCB9O1xufVxuZnVuY3Rpb24gcGFyc2VSUnVsZVN0cmluZyhzdHIpIHtcbiAgICBsZXQgcnJ1bGVTZXQgPSBycnVsZUxpYi5ycnVsZXN0cihzdHIsIHsgZm9yY2VzZXQ6IHRydWUgfSk7XG4gICAgbGV0IGFuYWx5c2lzID0gYW5hbHl6ZVJSdWxlU3RyaW5nKHN0cik7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyBycnVsZVNldCB9LCBhbmFseXNpcyk7XG59XG5mdW5jdGlvbiBhbmFseXplUlJ1bGVTdHJpbmcoc3RyKSB7XG4gICAgbGV0IGlzVGltZVNwZWNpZmllZCA9IGZhbHNlO1xuICAgIGxldCBpc1RpbWVab25lU3BlY2lmaWVkID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gcHJvY2Vzc01hdGNoKHdob2xlLCBpbnRyb1BhcnQsIGRhdGVQYXJ0KSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBwYXJzZU1hcmtlcihkYXRlUGFydCk7XG4gICAgICAgIGlzVGltZVNwZWNpZmllZCA9IGlzVGltZVNwZWNpZmllZCB8fCAhcmVzdWx0LmlzVGltZVVuc3BlY2lmaWVkO1xuICAgICAgICBpc1RpbWVab25lU3BlY2lmaWVkID0gaXNUaW1lWm9uZVNwZWNpZmllZCB8fCByZXN1bHQudGltZVpvbmVPZmZzZXQgIT09IG51bGw7XG4gICAgfVxuICAgIHN0ci5yZXBsYWNlKC9cXGIoRFRTVEFSVDopKFteXFxuXSopLywgcHJvY2Vzc01hdGNoKTtcbiAgICBzdHIucmVwbGFjZSgvXFxiKEVYREFURTopKFteXFxuXSopLywgcHJvY2Vzc01hdGNoKTtcbiAgICBzdHIucmVwbGFjZSgvXFxiKFVOVElMPSkoW147XFxuXSopLywgcHJvY2Vzc01hdGNoKTtcbiAgICByZXR1cm4geyBpc1RpbWVTcGVjaWZpZWQsIGlzVGltZVpvbmVTcGVjaWZpZWQgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRDb25zdGFudHMoaW5wdXQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0Lm1hcChjb252ZXJ0Q29uc3RhbnQpO1xuICAgIH1cbiAgICByZXR1cm4gY29udmVydENvbnN0YW50KGlucHV0KTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRDb25zdGFudChpbnB1dCkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBycnVsZUxpYi5SUnVsZVtpbnB1dC50b1VwcGVyQ2FzZSgpXTtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0O1xufVxuXG5jb25zdCBSUlVMRV9FVkVOVF9SRUZJTkVSUyA9IHtcbiAgICBycnVsZTogaWRlbnRpdHksXG4gICAgZXhydWxlOiBpZGVudGl0eSxcbiAgICBleGRhdGU6IGlkZW50aXR5LFxuICAgIGR1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbn07XG5cbnZhciBpbmRleCA9IGNyZWF0ZVBsdWdpbih7XG4gICAgbmFtZTogJ0BmdWxsY2FsZW5kYXIvcnJ1bGUnLFxuICAgIHJlY3VycmluZ1R5cGVzOiBbcmVjdXJyaW5nVHlwZV0sXG4gICAgZXZlbnRSZWZpbmVyczogUlJVTEVfRVZFTlRfUkVGSU5FUlMsXG59KTtcblxuZXhwb3J0IHsgaW5kZXggYXMgZGVmYXVsdCB9O1xuIiwgImltcG9ydCB7IEJhc2VDb21wb25lbnQsIGdldFVuaXF1ZURvbUlkLCBnZXREYXRlTWV0YSwgYnVpbGROYXZMaW5rQXR0cnMsIENvbnRlbnRDb250YWluZXIsIGdldERheUNsYXNzTmFtZXMsIGZvcm1hdERheVN0cmluZywgY3JlYXRlRm9ybWF0dGVyLCBFdmVudENvbnRhaW5lciwgZ2V0U2VnQW5jaG9yQXR0cnMsIGlzTXVsdGlEYXlSYW5nZSwgYnVpbGRTZWdUaW1lVGV4dCwgRGF0ZUNvbXBvbmVudCwgbWVtb2l6ZSwgVmlld0NvbnRhaW5lciwgU2Nyb2xsZXIsIE5vd1RpbWVyLCBzb3J0RXZlbnRTZWdzLCBnZXRTZWdNZXRhLCBzbGljZUV2ZW50U3RvcmUsIGludGVyc2VjdFJhbmdlcywgc3RhcnRPZkRheSwgYWRkRGF5cywgaW5qZWN0U3R5bGVzIH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb3JlL2ludGVybmFsLmpzJztcbmltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIEZyYWdtZW50IH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb3JlL3ByZWFjdC5qcyc7XG5cbmNsYXNzIExpc3RWaWV3SGVhZGVyUm93IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICB0ZXh0SWQ6IGdldFVuaXF1ZURvbUlkKCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgdGhlbWUsIGRhdGVFbnYsIG9wdGlvbnMsIHZpZXdBcGkgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHsgY2VsbElkLCBkYXlEYXRlLCB0b2RheVJhbmdlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBsZXQgeyB0ZXh0SWQgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGxldCBkYXlNZXRhID0gZ2V0RGF0ZU1ldGEoZGF5RGF0ZSwgdG9kYXlSYW5nZSk7XG4gICAgICAgIC8vIHdpbGwgZXZlciBiZSBmYWxzeT9cbiAgICAgICAgbGV0IHRleHQgPSBvcHRpb25zLmxpc3REYXlGb3JtYXQgPyBkYXRlRW52LmZvcm1hdChkYXlEYXRlLCBvcHRpb25zLmxpc3REYXlGb3JtYXQpIDogJyc7XG4gICAgICAgIC8vIHdpbGwgZXZlciBiZSBmYWxzeT8gYWxzbywgQkFEIE5BTUUgXCJhbHRcIlxuICAgICAgICBsZXQgc2lkZVRleHQgPSBvcHRpb25zLmxpc3REYXlTaWRlRm9ybWF0ID8gZGF0ZUVudi5mb3JtYXQoZGF5RGF0ZSwgb3B0aW9ucy5saXN0RGF5U2lkZUZvcm1hdCkgOiAnJztcbiAgICAgICAgbGV0IHJlbmRlclByb3BzID0gT2JqZWN0LmFzc2lnbih7IGRhdGU6IGRhdGVFbnYudG9EYXRlKGRheURhdGUpLCB2aWV3OiB2aWV3QXBpLCB0ZXh0SWQsXG4gICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgc2lkZVRleHQsIG5hdkxpbmtBdHRyczogYnVpbGROYXZMaW5rQXR0cnModGhpcy5jb250ZXh0LCBkYXlEYXRlKSwgc2lkZU5hdkxpbmtBdHRyczogYnVpbGROYXZMaW5rQXR0cnModGhpcy5jb250ZXh0LCBkYXlEYXRlLCAnZGF5JywgZmFsc2UpIH0sIGRheU1ldGEpO1xuICAgICAgICAvLyBUT0RPOiBtYWtlIGEgcmV1c2FibGUgSE9DIGZvciBkYXlIZWFkZXIgKHVzZWQgaW4gZGF5Z3JpZC90aW1lZ3JpZCB0b28pXG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChDb250ZW50Q29udGFpbmVyLCB7IGVsVGFnOiBcInRyXCIsIGVsQ2xhc3NlczogW1xuICAgICAgICAgICAgICAgICdmYy1saXN0LWRheScsXG4gICAgICAgICAgICAgICAgLi4uZ2V0RGF5Q2xhc3NOYW1lcyhkYXlNZXRhLCB0aGVtZSksXG4gICAgICAgICAgICBdLCBlbEF0dHJzOiB7XG4gICAgICAgICAgICAgICAgJ2RhdGEtZGF0ZSc6IGZvcm1hdERheVN0cmluZyhkYXlEYXRlKSxcbiAgICAgICAgICAgIH0sIHJlbmRlclByb3BzOiByZW5kZXJQcm9wcywgZ2VuZXJhdG9yTmFtZTogXCJkYXlIZWFkZXJDb250ZW50XCIsIGN1c3RvbUdlbmVyYXRvcjogb3B0aW9ucy5kYXlIZWFkZXJDb250ZW50LCBkZWZhdWx0R2VuZXJhdG9yOiByZW5kZXJJbm5lckNvbnRlbnQsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy5kYXlIZWFkZXJDbGFzc05hbWVzLCBkaWRNb3VudDogb3B0aW9ucy5kYXlIZWFkZXJEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMuZGF5SGVhZGVyV2lsbFVubW91bnQgfSwgKElubmVyQ29udGVudCkgPT4gKCAvLyBUT0RPOiBmb3JjZS1oaWRlIHRvcCBib3JkZXIgYmFzZWQgb24gOmZpcnN0LWNoaWxkXG4gICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJ0aFwiLCB7IHNjb3BlOiBcImNvbGdyb3VwXCIsIGNvbFNwYW46IDMsIGlkOiBjZWxsSWQsIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IHRleHRJZCB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChJbm5lckNvbnRlbnQsIHsgZWxUYWc6IFwiZGl2XCIsIGVsQ2xhc3NlczogW1xuICAgICAgICAgICAgICAgICAgICAnZmMtbGlzdC1kYXktY3VzaGlvbicsXG4gICAgICAgICAgICAgICAgICAgIHRoZW1lLmdldENsYXNzKCd0YWJsZUNlbGxTaGFkZWQnKSxcbiAgICAgICAgICAgICAgICBdIH0pKSkpKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZW5kZXJJbm5lckNvbnRlbnQocHJvcHMpIHtcbiAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsXG4gICAgICAgIHByb3BzLnRleHQgJiYgKGNyZWF0ZUVsZW1lbnQoXCJhXCIsIE9iamVjdC5hc3NpZ24oeyBpZDogcHJvcHMudGV4dElkLCBjbGFzc05hbWU6IFwiZmMtbGlzdC1kYXktdGV4dFwiIH0sIHByb3BzLm5hdkxpbmtBdHRycyksIHByb3BzLnRleHQpKSxcbiAgICAgICAgcHJvcHMuc2lkZVRleHQgJiYgKCAvKiBub3Qga2V5Ym9hcmQgdGFiYmFibGUgKi9jcmVhdGVFbGVtZW50KFwiYVwiLCBPYmplY3QuYXNzaWduKHsgXCJhcmlhLWhpZGRlblwiOiB0cnVlLCBjbGFzc05hbWU6IFwiZmMtbGlzdC1kYXktc2lkZS10ZXh0XCIgfSwgcHJvcHMuc2lkZU5hdkxpbmtBdHRycyksIHByb3BzLnNpZGVUZXh0KSkpKTtcbn1cblxuY29uc3QgREVGQVVMVF9USU1FX0ZPUk1BVCA9IGNyZWF0ZUZvcm1hdHRlcih7XG4gICAgaG91cjogJ251bWVyaWMnLFxuICAgIG1pbnV0ZTogJzItZGlnaXQnLFxuICAgIG1lcmlkaWVtOiAnc2hvcnQnLFxufSk7XG5jbGFzcyBMaXN0Vmlld0V2ZW50Um93IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgb3B0aW9ucyB9ID0gY29udGV4dDtcbiAgICAgICAgbGV0IHsgc2VnLCB0aW1lSGVhZGVySWQsIGV2ZW50SGVhZGVySWQsIGRhdGVIZWFkZXJJZCB9ID0gcHJvcHM7XG4gICAgICAgIGxldCB0aW1lRm9ybWF0ID0gb3B0aW9ucy5ldmVudFRpbWVGb3JtYXQgfHwgREVGQVVMVF9USU1FX0ZPUk1BVDtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEV2ZW50Q29udGFpbmVyLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcywgeyBlbFRhZzogXCJ0clwiLCBlbENsYXNzZXM6IFtcbiAgICAgICAgICAgICAgICAnZmMtbGlzdC1ldmVudCcsXG4gICAgICAgICAgICAgICAgc2VnLmV2ZW50UmFuZ2UuZGVmLnVybCAmJiAnZmMtZXZlbnQtZm9yY2VkLXVybCcsXG4gICAgICAgICAgICBdLCBkZWZhdWx0R2VuZXJhdG9yOiAoKSA9PiByZW5kZXJFdmVudElubmVyQ29udGVudChzZWcsIGNvbnRleHQpIC8qIHdlaXJkICovLCBzZWc6IHNlZywgdGltZVRleHQ6IFwiXCIsIGRpc2FibGVEcmFnZ2luZzogdHJ1ZSwgZGlzYWJsZVJlc2l6aW5nOiB0cnVlIH0pLCAoSW5uZXJDb250ZW50LCBldmVudENvbnRlbnRBcmcpID0+IChjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgYnVpbGRUaW1lQ29udGVudChzZWcsIHRpbWVGb3JtYXQsIGNvbnRleHQsIHRpbWVIZWFkZXJJZCwgZGF0ZUhlYWRlcklkKSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IFwiYXJpYS1oaWRkZW5cIjogdHJ1ZSwgY2xhc3NOYW1lOiBcImZjLWxpc3QtZXZlbnQtZ3JhcGhpY1wiIH0sXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwiZmMtbGlzdC1ldmVudC1kb3RcIiwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBldmVudENvbnRlbnRBcmcuYm9yZGVyQ29sb3IgfHwgZXZlbnRDb250ZW50QXJnLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgfSB9KSksXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KElubmVyQ29udGVudCwgeyBlbFRhZzogXCJ0ZFwiLCBlbENsYXNzZXM6IFsnZmMtbGlzdC1ldmVudC10aXRsZSddLCBlbEF0dHJzOiB7IGhlYWRlcnM6IGAke2V2ZW50SGVhZGVySWR9ICR7ZGF0ZUhlYWRlcklkfWAgfSB9KSkpKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVuZGVyRXZlbnRJbm5lckNvbnRlbnQoc2VnLCBjb250ZXh0KSB7XG4gICAgbGV0IGludGVyYWN0aXZlQXR0cnMgPSBnZXRTZWdBbmNob3JBdHRycyhzZWcsIGNvbnRleHQpO1xuICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcImFcIiwgT2JqZWN0LmFzc2lnbih7fSwgaW50ZXJhY3RpdmVBdHRycyksIHNlZy5ldmVudFJhbmdlLmRlZi50aXRsZSkpO1xufVxuZnVuY3Rpb24gYnVpbGRUaW1lQ29udGVudChzZWcsIHRpbWVGb3JtYXQsIGNvbnRleHQsIHRpbWVIZWFkZXJJZCwgZGF0ZUhlYWRlcklkKSB7XG4gICAgbGV0IHsgb3B0aW9ucyB9ID0gY29udGV4dDtcbiAgICBpZiAob3B0aW9ucy5kaXNwbGF5RXZlbnRUaW1lICE9PSBmYWxzZSkge1xuICAgICAgICBsZXQgZXZlbnREZWYgPSBzZWcuZXZlbnRSYW5nZS5kZWY7XG4gICAgICAgIGxldCBldmVudEluc3RhbmNlID0gc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2U7XG4gICAgICAgIGxldCBkb0FsbERheSA9IGZhbHNlO1xuICAgICAgICBsZXQgdGltZVRleHQ7XG4gICAgICAgIGlmIChldmVudERlZi5hbGxEYXkpIHtcbiAgICAgICAgICAgIGRvQWxsRGF5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc011bHRpRGF5UmFuZ2Uoc2VnLmV2ZW50UmFuZ2UucmFuZ2UpKSB7IC8vIFRPRE86IHVzZSAoIWlzU3RhcnQgfHwgIWlzRW5kKSBpbnN0ZWFkP1xuICAgICAgICAgICAgaWYgKHNlZy5pc1N0YXJ0KSB7XG4gICAgICAgICAgICAgICAgdGltZVRleHQgPSBidWlsZFNlZ1RpbWVUZXh0KHNlZywgdGltZUZvcm1hdCwgY29udGV4dCwgbnVsbCwgbnVsbCwgZXZlbnRJbnN0YW5jZS5yYW5nZS5zdGFydCwgc2VnLmVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzZWcuaXNFbmQpIHtcbiAgICAgICAgICAgICAgICB0aW1lVGV4dCA9IGJ1aWxkU2VnVGltZVRleHQoc2VnLCB0aW1lRm9ybWF0LCBjb250ZXh0LCBudWxsLCBudWxsLCBzZWcuc3RhcnQsIGV2ZW50SW5zdGFuY2UucmFuZ2UuZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvQWxsRGF5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRpbWVUZXh0ID0gYnVpbGRTZWdUaW1lVGV4dChzZWcsIHRpbWVGb3JtYXQsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb0FsbERheSkge1xuICAgICAgICAgICAgbGV0IHJlbmRlclByb3BzID0ge1xuICAgICAgICAgICAgICAgIHRleHQ6IGNvbnRleHQub3B0aW9ucy5hbGxEYXlUZXh0LFxuICAgICAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoQ29udGVudENvbnRhaW5lciwgeyBlbFRhZzogXCJ0ZFwiLCBlbENsYXNzZXM6IFsnZmMtbGlzdC1ldmVudC10aW1lJ10sIGVsQXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogYCR7dGltZUhlYWRlcklkfSAke2RhdGVIZWFkZXJJZH1gLFxuICAgICAgICAgICAgICAgIH0sIHJlbmRlclByb3BzOiByZW5kZXJQcm9wcywgZ2VuZXJhdG9yTmFtZTogXCJhbGxEYXlDb250ZW50XCIsIGN1c3RvbUdlbmVyYXRvcjogb3B0aW9ucy5hbGxEYXlDb250ZW50LCBkZWZhdWx0R2VuZXJhdG9yOiByZW5kZXJBbGxEYXlJbm5lciwgY2xhc3NOYW1lR2VuZXJhdG9yOiBvcHRpb25zLmFsbERheUNsYXNzTmFtZXMsIGRpZE1vdW50OiBvcHRpb25zLmFsbERheURpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy5hbGxEYXlXaWxsVW5tb3VudCB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwidGRcIiwgeyBjbGFzc05hbWU6IFwiZmMtbGlzdC1ldmVudC10aW1lXCIgfSwgdGltZVRleHQpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiByZW5kZXJBbGxEYXlJbm5lcihyZW5kZXJQcm9wcykge1xuICAgIHJldHVybiByZW5kZXJQcm9wcy50ZXh0O1xufVxuXG4vKlxuUmVzcG9uc2libGUgZm9yIHRoZSBzY3JvbGxlciwgYW5kIGZvcndhcmRpbmcgZXZlbnQtcmVsYXRlZCBhY3Rpb25zIGludG8gdGhlIFwiZ3JpZFwiLlxuKi9cbmNsYXNzIExpc3RWaWV3IGV4dGVuZHMgRGF0ZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuY29tcHV0ZURhdGVWYXJzID0gbWVtb2l6ZShjb21wdXRlRGF0ZVZhcnMpO1xuICAgICAgICB0aGlzLmV2ZW50U3RvcmVUb1NlZ3MgPSBtZW1vaXplKHRoaXMuX2V2ZW50U3RvcmVUb1NlZ3MpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgdGltZUhlYWRlcklkOiBnZXRVbmlxdWVEb21JZCgpLFxuICAgICAgICAgICAgZXZlbnRIZWFkZXJJZDogZ2V0VW5pcXVlRG9tSWQoKSxcbiAgICAgICAgICAgIGRhdGVIZWFkZXJJZFJvb3Q6IGdldFVuaXF1ZURvbUlkKCksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2V0Um9vdEVsID0gKHJvb3RFbCkgPT4ge1xuICAgICAgICAgICAgaWYgKHJvb3RFbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgZWw6IHJvb3RFbCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC51bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IGRheURhdGVzLCBkYXlSYW5nZXMgfSA9IHRoaXMuY29tcHV0ZURhdGVWYXJzKHByb3BzLmRhdGVQcm9maWxlKTtcbiAgICAgICAgbGV0IGV2ZW50U2VncyA9IHRoaXMuZXZlbnRTdG9yZVRvU2Vncyhwcm9wcy5ldmVudFN0b3JlLCBwcm9wcy5ldmVudFVpQmFzZXMsIGRheVJhbmdlcyk7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChWaWV3Q29udGFpbmVyLCB7IGVsUmVmOiB0aGlzLnNldFJvb3RFbCwgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgJ2ZjLWxpc3QnLFxuICAgICAgICAgICAgICAgIGNvbnRleHQudGhlbWUuZ2V0Q2xhc3MoJ3RhYmxlJyksXG4gICAgICAgICAgICAgICAgY29udGV4dC5vcHRpb25zLnN0aWNreUhlYWRlckRhdGVzICE9PSBmYWxzZSA/XG4gICAgICAgICAgICAgICAgICAgICdmYy1saXN0LXN0aWNreScgOlxuICAgICAgICAgICAgICAgICAgICAnJyxcbiAgICAgICAgICAgIF0sIHZpZXdTcGVjOiBjb250ZXh0LnZpZXdTcGVjIH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFNjcm9sbGVyLCB7IGxpcXVpZDogIXByb3BzLmlzSGVpZ2h0QXV0bywgb3ZlcmZsb3dYOiBwcm9wcy5pc0hlaWdodEF1dG8gPyAndmlzaWJsZScgOiAnaGlkZGVuJywgb3ZlcmZsb3dZOiBwcm9wcy5pc0hlaWdodEF1dG8gPyAndmlzaWJsZScgOiAnYXV0bycgfSwgZXZlbnRTZWdzLmxlbmd0aCA+IDAgP1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyU2VnTGlzdChldmVudFNlZ3MsIGRheURhdGVzKSA6XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJFbXB0eU1lc3NhZ2UoKSkpKTtcbiAgICB9XG4gICAgcmVuZGVyRW1wdHlNZXNzYWdlKCkge1xuICAgICAgICBsZXQgeyBvcHRpb25zLCB2aWV3QXBpIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCByZW5kZXJQcm9wcyA9IHtcbiAgICAgICAgICAgIHRleHQ6IG9wdGlvbnMubm9FdmVudHNUZXh0LFxuICAgICAgICAgICAgdmlldzogdmlld0FwaSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KENvbnRlbnRDb250YWluZXIsIHsgZWxUYWc6IFwiZGl2XCIsIGVsQ2xhc3NlczogWydmYy1saXN0LWVtcHR5J10sIHJlbmRlclByb3BzOiByZW5kZXJQcm9wcywgZ2VuZXJhdG9yTmFtZTogXCJub0V2ZW50c0NvbnRlbnRcIiwgY3VzdG9tR2VuZXJhdG9yOiBvcHRpb25zLm5vRXZlbnRzQ29udGVudCwgZGVmYXVsdEdlbmVyYXRvcjogcmVuZGVyTm9FdmVudHNJbm5lciwgY2xhc3NOYW1lR2VuZXJhdG9yOiBvcHRpb25zLm5vRXZlbnRzQ2xhc3NOYW1lcywgZGlkTW91bnQ6IG9wdGlvbnMubm9FdmVudHNEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMubm9FdmVudHNXaWxsVW5tb3VudCB9LCAoSW5uZXJDb250ZW50KSA9PiAoY3JlYXRlRWxlbWVudChJbm5lckNvbnRlbnQsIHsgZWxUYWc6IFwiZGl2XCIsIGVsQ2xhc3NlczogWydmYy1saXN0LWVtcHR5LWN1c2hpb24nXSB9KSkpKTtcbiAgICB9XG4gICAgcmVuZGVyU2VnTGlzdChhbGxTZWdzLCBkYXlEYXRlcykge1xuICAgICAgICBsZXQgeyB0aGVtZSwgb3B0aW9ucyB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgeyB0aW1lSGVhZGVySWQsIGV2ZW50SGVhZGVySWQsIGRhdGVIZWFkZXJJZFJvb3QgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGxldCBzZWdzQnlEYXkgPSBncm91cFNlZ3NCeURheShhbGxTZWdzKTsgLy8gc3BhcnNlIGFycmF5XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChOb3dUaW1lciwgeyB1bml0OiBcImRheVwiIH0sIChub3dEYXRlLCB0b2RheVJhbmdlKSA9PiB7XG4gICAgICAgICAgICBsZXQgaW5uZXJOb2RlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgZGF5SW5kZXggPSAwOyBkYXlJbmRleCA8IHNlZ3NCeURheS5sZW5ndGg7IGRheUluZGV4ICs9IDEpIHtcbiAgICAgICAgICAgICAgICBsZXQgZGF5U2VncyA9IHNlZ3NCeURheVtkYXlJbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGRheVNlZ3MpIHsgLy8gc3BhcnNlIGFycmF5LCBzbyBtaWdodCBiZSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRheVN0ciA9IGZvcm1hdERheVN0cmluZyhkYXlEYXRlc1tkYXlJbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGF0ZUhlYWRlcklkID0gZGF0ZUhlYWRlcklkUm9vdCArICctJyArIGRheVN0cjtcbiAgICAgICAgICAgICAgICAgICAgLy8gYXBwZW5kIGEgZGF5IGhlYWRlclxuICAgICAgICAgICAgICAgICAgICBpbm5lck5vZGVzLnB1c2goY3JlYXRlRWxlbWVudChMaXN0Vmlld0hlYWRlclJvdywgeyBrZXk6IGRheVN0ciwgY2VsbElkOiBkYXRlSGVhZGVySWQsIGRheURhdGU6IGRheURhdGVzW2RheUluZGV4XSwgdG9kYXlSYW5nZTogdG9kYXlSYW5nZSB9KSk7XG4gICAgICAgICAgICAgICAgICAgIGRheVNlZ3MgPSBzb3J0RXZlbnRTZWdzKGRheVNlZ3MsIG9wdGlvbnMuZXZlbnRPcmRlcik7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHNlZyBvZiBkYXlTZWdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbm5lck5vZGVzLnB1c2goY3JlYXRlRWxlbWVudChMaXN0Vmlld0V2ZW50Um93LCBPYmplY3QuYXNzaWduKHsga2V5OiBkYXlTdHIgKyAnOicgKyBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkIC8qIGFyZSBtdWx0aXBsZSBzZWdzIGZvciBhbiBpbnN0YW5jZUlkICovLCBzZWc6IHNlZywgaXNEcmFnZ2luZzogZmFsc2UsIGlzUmVzaXppbmc6IGZhbHNlLCBpc0RhdGVTZWxlY3Rpbmc6IGZhbHNlLCBpc1NlbGVjdGVkOiBmYWxzZSwgdGltZUhlYWRlcklkOiB0aW1lSGVhZGVySWQsIGV2ZW50SGVhZGVySWQ6IGV2ZW50SGVhZGVySWQsIGRhdGVIZWFkZXJJZDogZGF0ZUhlYWRlcklkIH0sIGdldFNlZ01ldGEoc2VnLCB0b2RheVJhbmdlLCBub3dEYXRlKSkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcInRhYmxlXCIsIHsgY2xhc3NOYW1lOiAnZmMtbGlzdC10YWJsZSAnICsgdGhlbWUuZ2V0Q2xhc3MoJ3RhYmxlJykgfSxcbiAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwidGhlYWRcIiwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRyXCIsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwidGhcIiwgeyBzY29wZTogXCJjb2xcIiwgaWQ6IHRpbWVIZWFkZXJJZCB9LCBvcHRpb25zLnRpbWVIaW50KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJ0aFwiLCB7IHNjb3BlOiBcImNvbFwiLCBcImFyaWEtaGlkZGVuXCI6IHRydWUgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwidGhcIiwgeyBzY29wZTogXCJjb2xcIiwgaWQ6IGV2ZW50SGVhZGVySWQgfSwgb3B0aW9ucy5ldmVudEhpbnQpKSksXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRib2R5XCIsIG51bGwsIGlubmVyTm9kZXMpKSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgX2V2ZW50U3RvcmVUb1NlZ3MoZXZlbnRTdG9yZSwgZXZlbnRVaUJhc2VzLCBkYXlSYW5nZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRSYW5nZXNUb1NlZ3Moc2xpY2VFdmVudFN0b3JlKGV2ZW50U3RvcmUsIGV2ZW50VWlCYXNlcywgdGhpcy5wcm9wcy5kYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgdGhpcy5jb250ZXh0Lm9wdGlvbnMubmV4dERheVRocmVzaG9sZCkuZmcsIGRheVJhbmdlcyk7XG4gICAgfVxuICAgIGV2ZW50UmFuZ2VzVG9TZWdzKGV2ZW50UmFuZ2VzLCBkYXlSYW5nZXMpIHtcbiAgICAgICAgbGV0IHNlZ3MgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZXZlbnRSYW5nZSBvZiBldmVudFJhbmdlcykge1xuICAgICAgICAgICAgc2Vncy5wdXNoKC4uLnRoaXMuZXZlbnRSYW5nZVRvU2VncyhldmVudFJhbmdlLCBkYXlSYW5nZXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VncztcbiAgICB9XG4gICAgZXZlbnRSYW5nZVRvU2VncyhldmVudFJhbmdlLCBkYXlSYW5nZXMpIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgeyBuZXh0RGF5VGhyZXNob2xkIH0gPSB0aGlzLmNvbnRleHQub3B0aW9ucztcbiAgICAgICAgbGV0IHJhbmdlID0gZXZlbnRSYW5nZS5yYW5nZTtcbiAgICAgICAgbGV0IGFsbERheSA9IGV2ZW50UmFuZ2UuZGVmLmFsbERheTtcbiAgICAgICAgbGV0IGRheUluZGV4O1xuICAgICAgICBsZXQgc2VnUmFuZ2U7XG4gICAgICAgIGxldCBzZWc7XG4gICAgICAgIGxldCBzZWdzID0gW107XG4gICAgICAgIGZvciAoZGF5SW5kZXggPSAwOyBkYXlJbmRleCA8IGRheVJhbmdlcy5sZW5ndGg7IGRheUluZGV4ICs9IDEpIHtcbiAgICAgICAgICAgIHNlZ1JhbmdlID0gaW50ZXJzZWN0UmFuZ2VzKHJhbmdlLCBkYXlSYW5nZXNbZGF5SW5kZXhdKTtcbiAgICAgICAgICAgIGlmIChzZWdSYW5nZSkge1xuICAgICAgICAgICAgICAgIHNlZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50OiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBldmVudFJhbmdlLFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogc2VnUmFuZ2Uuc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogc2VnUmFuZ2UuZW5kLFxuICAgICAgICAgICAgICAgICAgICBpc1N0YXJ0OiBldmVudFJhbmdlLmlzU3RhcnQgJiYgc2VnUmFuZ2Uuc3RhcnQudmFsdWVPZigpID09PSByYW5nZS5zdGFydC52YWx1ZU9mKCksXG4gICAgICAgICAgICAgICAgICAgIGlzRW5kOiBldmVudFJhbmdlLmlzRW5kICYmIHNlZ1JhbmdlLmVuZC52YWx1ZU9mKCkgPT09IHJhbmdlLmVuZC52YWx1ZU9mKCksXG4gICAgICAgICAgICAgICAgICAgIGRheUluZGV4LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc2Vncy5wdXNoKHNlZyk7XG4gICAgICAgICAgICAgICAgLy8gZGV0ZWN0IHdoZW4gcmFuZ2Ugd29uJ3QgZ28gZnVsbHkgaW50byB0aGUgbmV4dCBkYXksXG4gICAgICAgICAgICAgICAgLy8gYW5kIG11dGF0ZSB0aGUgbGF0ZXN0IHNlZyB0byB0aGUgYmUgdGhlIGVuZC5cbiAgICAgICAgICAgICAgICBpZiAoIXNlZy5pc0VuZCAmJiAhYWxsRGF5ICYmXG4gICAgICAgICAgICAgICAgICAgIGRheUluZGV4ICsgMSA8IGRheVJhbmdlcy5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UuZW5kIDxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGVFbnYuYWRkKGRheVJhbmdlc1tkYXlJbmRleCArIDFdLnN0YXJ0LCBuZXh0RGF5VGhyZXNob2xkKSkge1xuICAgICAgICAgICAgICAgICAgICBzZWcuZW5kID0gcmFuZ2UuZW5kO1xuICAgICAgICAgICAgICAgICAgICBzZWcuaXNFbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlZ3M7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVuZGVyTm9FdmVudHNJbm5lcihyZW5kZXJQcm9wcykge1xuICAgIHJldHVybiByZW5kZXJQcm9wcy50ZXh0O1xufVxuZnVuY3Rpb24gY29tcHV0ZURhdGVWYXJzKGRhdGVQcm9maWxlKSB7XG4gICAgbGV0IGRheVN0YXJ0ID0gc3RhcnRPZkRheShkYXRlUHJvZmlsZS5yZW5kZXJSYW5nZS5zdGFydCk7XG4gICAgbGV0IHZpZXdFbmQgPSBkYXRlUHJvZmlsZS5yZW5kZXJSYW5nZS5lbmQ7XG4gICAgbGV0IGRheURhdGVzID0gW107XG4gICAgbGV0IGRheVJhbmdlcyA9IFtdO1xuICAgIHdoaWxlIChkYXlTdGFydCA8IHZpZXdFbmQpIHtcbiAgICAgICAgZGF5RGF0ZXMucHVzaChkYXlTdGFydCk7XG4gICAgICAgIGRheVJhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgIHN0YXJ0OiBkYXlTdGFydCxcbiAgICAgICAgICAgIGVuZDogYWRkRGF5cyhkYXlTdGFydCwgMSksXG4gICAgICAgIH0pO1xuICAgICAgICBkYXlTdGFydCA9IGFkZERheXMoZGF5U3RhcnQsIDEpO1xuICAgIH1cbiAgICByZXR1cm4geyBkYXlEYXRlcywgZGF5UmFuZ2VzIH07XG59XG4vLyBSZXR1cm5zIGEgc3BhcnNlIGFycmF5IG9mIGFycmF5cywgc2VncyBncm91cGVkIGJ5IHRoZWlyIGRheUluZGV4XG5mdW5jdGlvbiBncm91cFNlZ3NCeURheShzZWdzKSB7XG4gICAgbGV0IHNlZ3NCeURheSA9IFtdOyAvLyBzcGFyc2UgYXJyYXlcbiAgICBsZXQgaTtcbiAgICBsZXQgc2VnO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHNlZyA9IHNlZ3NbaV07XG4gICAgICAgIChzZWdzQnlEYXlbc2VnLmRheUluZGV4XSB8fCAoc2Vnc0J5RGF5W3NlZy5kYXlJbmRleF0gPSBbXSkpXG4gICAgICAgICAgICAucHVzaChzZWcpO1xuICAgIH1cbiAgICByZXR1cm4gc2Vnc0J5RGF5O1xufVxuXG52YXIgY3NzXzI0OHogPSBcIjpyb290ey0tZmMtbGlzdC1ldmVudC1kb3Qtd2lkdGg6MTBweDstLWZjLWxpc3QtZXZlbnQtaG92ZXItYmctY29sb3I6I2Y1ZjVmNX0uZmMtdGhlbWUtc3RhbmRhcmQgLmZjLWxpc3R7Ym9yZGVyOjFweCBzb2xpZCB2YXIoLS1mYy1ib3JkZXItY29sb3IpfS5mYyAuZmMtbGlzdC1lbXB0eXthbGlnbi1pdGVtczpjZW50ZXI7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1mYy1uZXV0cmFsLWJnLWNvbG9yKTtkaXNwbGF5OmZsZXg7aGVpZ2h0OjEwMCU7anVzdGlmeS1jb250ZW50OmNlbnRlcn0uZmMgLmZjLWxpc3QtZW1wdHktY3VzaGlvbnttYXJnaW46NWVtIDB9LmZjIC5mYy1saXN0LXRhYmxle2JvcmRlci1zdHlsZTpoaWRkZW47d2lkdGg6MTAwJX0uZmMgLmZjLWxpc3QtdGFibGUgdHI+Kntib3JkZXItbGVmdDowO2JvcmRlci1yaWdodDowfS5mYyAuZmMtbGlzdC1zdGlja3kgLmZjLWxpc3QtZGF5Pip7YmFja2dyb3VuZDp2YXIoLS1mYy1wYWdlLWJnLWNvbG9yKTtwb3NpdGlvbjpzdGlja3k7dG9wOjB9LmZjIC5mYy1saXN0LXRhYmxlIHRoZWFke2xlZnQ6LTEwMDAwcHg7cG9zaXRpb246YWJzb2x1dGV9LmZjIC5mYy1saXN0LXRhYmxlIHRib2R5PnRyOmZpcnN0LWNoaWxkIHRoe2JvcmRlci10b3A6MH0uZmMgLmZjLWxpc3QtdGFibGUgdGh7cGFkZGluZzowfS5mYyAuZmMtbGlzdC1kYXktY3VzaGlvbiwuZmMgLmZjLWxpc3QtdGFibGUgdGR7cGFkZGluZzo4cHggMTRweH0uZmMgLmZjLWxpc3QtZGF5LWN1c2hpb246YWZ0ZXJ7Y2xlYXI6Ym90aDtjb250ZW50OlxcXCJcXFwiO2Rpc3BsYXk6dGFibGV9LmZjLXRoZW1lLXN0YW5kYXJkIC5mYy1saXN0LWRheS1jdXNoaW9ue2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmMtbmV1dHJhbC1iZy1jb2xvcil9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLWxpc3QtZGF5LXRleHQsLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWxpc3QtZGF5LXNpZGUtdGV4dHtmbG9hdDpsZWZ0fS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1saXN0LWRheS1zaWRlLXRleHQsLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWxpc3QtZGF5LXRleHR7ZmxvYXQ6cmlnaHR9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLWxpc3QtdGFibGUgLmZjLWxpc3QtZXZlbnQtZ3JhcGhpY3twYWRkaW5nLXJpZ2h0OjB9LmZjLWRpcmVjdGlvbi1ydGwgLmZjLWxpc3QtdGFibGUgLmZjLWxpc3QtZXZlbnQtZ3JhcGhpY3twYWRkaW5nLWxlZnQ6MH0uZmMgLmZjLWxpc3QtZXZlbnQuZmMtZXZlbnQtZm9yY2VkLXVybHtjdXJzb3I6cG9pbnRlcn0uZmMgLmZjLWxpc3QtZXZlbnQ6aG92ZXIgdGR7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1mYy1saXN0LWV2ZW50LWhvdmVyLWJnLWNvbG9yKX0uZmMgLmZjLWxpc3QtZXZlbnQtZ3JhcGhpYywuZmMgLmZjLWxpc3QtZXZlbnQtdGltZXt3aGl0ZS1zcGFjZTpub3dyYXA7d2lkdGg6MXB4fS5mYyAuZmMtbGlzdC1ldmVudC1kb3R7Ym9yZGVyOmNhbGModmFyKC0tZmMtbGlzdC1ldmVudC1kb3Qtd2lkdGgpLzIpIHNvbGlkIHZhcigtLWZjLWV2ZW50LWJvcmRlci1jb2xvcik7Ym9yZGVyLXJhZGl1czpjYWxjKHZhcigtLWZjLWxpc3QtZXZlbnQtZG90LXdpZHRoKS8yKTtib3gtc2l6aW5nOmNvbnRlbnQtYm94O2Rpc3BsYXk6aW5saW5lLWJsb2NrO2hlaWdodDowO3dpZHRoOjB9LmZjIC5mYy1saXN0LWV2ZW50LXRpdGxlIGF7Y29sb3I6aW5oZXJpdDt0ZXh0LWRlY29yYXRpb246bm9uZX0uZmMgLmZjLWxpc3QtZXZlbnQuZmMtZXZlbnQtZm9yY2VkLXVybDpob3ZlciBhe3RleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmV9XCI7XG5pbmplY3RTdHlsZXMoY3NzXzI0OHopO1xuXG5leHBvcnQgeyBMaXN0VmlldyB9O1xuIiwgImltcG9ydCB7IGNyZWF0ZVBsdWdpbiB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29yZS9pbmRleC5qcyc7XG5pbXBvcnQgeyBMaXN0VmlldyB9IGZyb20gJy4vaW50ZXJuYWwuanMnO1xuaW1wb3J0IHsgaWRlbnRpdHksIGNyZWF0ZUZvcm1hdHRlciB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29yZS9pbnRlcm5hbC5qcyc7XG5pbXBvcnQgJ0BmdWxsY2FsZW5kYXIvY29yZS9wcmVhY3QuanMnO1xuXG5jb25zdCBPUFRJT05fUkVGSU5FUlMgPSB7XG4gICAgbGlzdERheUZvcm1hdDogY3JlYXRlRmFsc2FibGVGb3JtYXR0ZXIsXG4gICAgbGlzdERheVNpZGVGb3JtYXQ6IGNyZWF0ZUZhbHNhYmxlRm9ybWF0dGVyLFxuICAgIG5vRXZlbnRzQ2xhc3NOYW1lczogaWRlbnRpdHksXG4gICAgbm9FdmVudHNDb250ZW50OiBpZGVudGl0eSxcbiAgICBub0V2ZW50c0RpZE1vdW50OiBpZGVudGl0eSxcbiAgICBub0V2ZW50c1dpbGxVbm1vdW50OiBpZGVudGl0eSxcbiAgICAvLyBub0V2ZW50c1RleHQgaXMgZGVmaW5lZCBpbiBiYXNlIG9wdGlvbnNcbn07XG5mdW5jdGlvbiBjcmVhdGVGYWxzYWJsZUZvcm1hdHRlcihpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dCA9PT0gZmFsc2UgPyBudWxsIDogY3JlYXRlRm9ybWF0dGVyKGlucHV0KTtcbn1cblxudmFyIGluZGV4ID0gY3JlYXRlUGx1Z2luKHtcbiAgICBuYW1lOiAnQGZ1bGxjYWxlbmRhci9saXN0JyxcbiAgICBvcHRpb25SZWZpbmVyczogT1BUSU9OX1JFRklORVJTLFxuICAgIHZpZXdzOiB7XG4gICAgICAgIGxpc3Q6IHtcbiAgICAgICAgICAgIGNvbXBvbmVudDogTGlzdFZpZXcsXG4gICAgICAgICAgICBidXR0b25UZXh0S2V5OiAnbGlzdCcsXG4gICAgICAgICAgICBsaXN0RGF5Rm9ybWF0OiB7IG1vbnRoOiAnbG9uZycsIGRheTogJ251bWVyaWMnLCB5ZWFyOiAnbnVtZXJpYycgfSwgLy8gbGlrZSBcIkphbnVhcnkgMSwgMjAxNlwiXG4gICAgICAgIH0sXG4gICAgICAgIGxpc3REYXk6IHtcbiAgICAgICAgICAgIHR5cGU6ICdsaXN0JyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB7IGRheXM6IDEgfSxcbiAgICAgICAgICAgIGxpc3REYXlGb3JtYXQ6IHsgd2Vla2RheTogJ2xvbmcnIH0sIC8vIGRheS1vZi13ZWVrIGlzIGFsbCB3ZSBuZWVkLiBmdWxsIGRhdGUgaXMgcHJvYmFibHkgaW4gaGVhZGVyVG9vbGJhclxuICAgICAgICB9LFxuICAgICAgICBsaXN0V2Vlazoge1xuICAgICAgICAgICAgdHlwZTogJ2xpc3QnLFxuICAgICAgICAgICAgZHVyYXRpb246IHsgd2Vla3M6IDEgfSxcbiAgICAgICAgICAgIGxpc3REYXlGb3JtYXQ6IHsgd2Vla2RheTogJ2xvbmcnIH0sXG4gICAgICAgICAgICBsaXN0RGF5U2lkZUZvcm1hdDogeyBtb250aDogJ2xvbmcnLCBkYXk6ICdudW1lcmljJywgeWVhcjogJ251bWVyaWMnIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGxpc3RNb250aDoge1xuICAgICAgICAgICAgdHlwZTogJ2xpc3QnLFxuICAgICAgICAgICAgZHVyYXRpb246IHsgbW9udGg6IDEgfSxcbiAgICAgICAgICAgIGxpc3REYXlTaWRlRm9ybWF0OiB7IHdlZWtkYXk6ICdsb25nJyB9LCAvLyBkYXktb2Ytd2VlayBpcyBuaWNlLXRvLWhhdmVcbiAgICAgICAgfSxcbiAgICAgICAgbGlzdFllYXI6IHtcbiAgICAgICAgICAgIHR5cGU6ICdsaXN0JyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB7IHllYXI6IDEgfSxcbiAgICAgICAgICAgIGxpc3REYXlTaWRlRm9ybWF0OiB7IHdlZWtkYXk6ICdsb25nJyB9LCAvLyBkYXktb2Ytd2VlayBpcyBuaWNlLXRvLWhhdmVcbiAgICAgICAgfSxcbiAgICB9LFxufSk7XG5cbmV4cG9ydCB7IGluZGV4IGFzIGRlZmF1bHQgfTtcbiIsICJpbXBvcnQgeyBjcmVhdGVQbHVnaW4gfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvcmUvaW5kZXguanMnO1xuaW1wb3J0IHsgY29uZmlnLCBFbWl0dGVyLCBlbGVtZW50Q2xvc2VzdCwgYXBwbHlTdHlsZSwgd2hlblRyYW5zaXRpb25Eb25lLCByZW1vdmVFbGVtZW50LCBTY3JvbGxDb250cm9sbGVyLCBFbGVtZW50U2Nyb2xsQ29udHJvbGxlciwgY29tcHV0ZUlubmVyUmVjdCwgV2luZG93U2Nyb2xsQ29udHJvbGxlciwgRWxlbWVudERyYWdnaW5nLCBwcmV2ZW50U2VsZWN0aW9uLCBwcmV2ZW50Q29udGV4dE1lbnUsIGFsbG93U2VsZWN0aW9uLCBhbGxvd0NvbnRleHRNZW51LCBjb21wdXRlUmVjdCwgZ2V0Q2xpcHBpbmdQYXJlbnRzLCBwb2ludEluc2lkZVJlY3QsIGNvbnN0cmFpblBvaW50LCBpbnRlcnNlY3RSZWN0cywgZ2V0UmVjdENlbnRlciwgZGlmZlBvaW50cywgbWFwSGFzaCwgcmFuZ2VDb250YWluc1JhbmdlLCBpc0RhdGVTcGFuc0VxdWFsLCBJbnRlcmFjdGlvbiwgaW50ZXJhY3Rpb25TZXR0aW5nc1RvU3RvcmUsIGlzRGF0ZVNlbGVjdGlvblZhbGlkLCBlbmFibGVDdXJzb3IsIGRpc2FibGVDdXJzb3IsIHRyaWdnZXJEYXRlU2VsZWN0LCBjb21wYXJlTnVtYmVycywgZ2V0RWxTZWcsIGdldFJlbGV2YW50RXZlbnRzLCBFdmVudEltcGwsIGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSwgYXBwbHlNdXRhdGlvblRvRXZlbnRTdG9yZSwgaXNJbnRlcmFjdGlvblZhbGlkLCBidWlsZEV2ZW50QXBpcywgaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlLCBzdGFydE9mRGF5LCBkaWZmRGF0ZXMsIGNyZWF0ZUR1cmF0aW9uLCBnZXRFdmVudFRhcmdldFZpYVJvb3QsIGlkZW50aXR5LCBldmVudFR1cGxlVG9TdG9yZSwgcGFyc2VEcmFnTWV0YSwgZWxlbWVudE1hdGNoZXMsIHJlZmluZUV2ZW50RGVmLCBwYXJzZUV2ZW50RGVmLCBnZXREZWZhdWx0RXZlbnRFbmQsIGNyZWF0ZUV2ZW50SW5zdGFuY2UsIEJBU0VfT1BUSU9OX0RFRkFVTFRTIH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb3JlL2ludGVybmFsLmpzJztcblxuY29uZmlnLnRvdWNoTW91c2VJZ25vcmVXYWl0ID0gNTAwO1xubGV0IGlnbm9yZU1vdXNlRGVwdGggPSAwO1xubGV0IGxpc3RlbmVyQ250ID0gMDtcbmxldCBpc1dpbmRvd1RvdWNoTW92ZUNhbmNlbGxlZCA9IGZhbHNlO1xuLypcblVzZXMgYSBcInBvaW50ZXJcIiBhYnN0cmFjdGlvbiwgd2hpY2ggbW9uaXRvcnMgVUkgZXZlbnRzIGZvciBib3RoIG1vdXNlIGFuZCB0b3VjaC5cblRyYWNrcyB3aGVuIHRoZSBwb2ludGVyIFwiZHJhZ3NcIiBvbiBhIGNlcnRhaW4gZWxlbWVudCwgbWVhbmluZyBkb3duK21vdmUrdXAuXG5cbkFsc28sIHRyYWNrcyBpZiB0aGVyZSB3YXMgdG91Y2gtc2Nyb2xsaW5nLlxuQWxzbywgY2FuIHByZXZlbnQgdG91Y2gtc2Nyb2xsaW5nIGZyb20gaGFwcGVuaW5nLlxuQWxzbywgY2FuIGZpcmUgcG9pbnRlcm1vdmUgZXZlbnRzIHdoZW4gc2Nyb2xsaW5nIGhhcHBlbnMgdW5kZXJuZWF0aCwgZXZlbiB3aGVuIG5vIHJlYWwgcG9pbnRlciBtb3ZlbWVudC5cblxuZW1pdHM6XG4tIHBvaW50ZXJkb3duXG4tIHBvaW50ZXJtb3ZlXG4tIHBvaW50ZXJ1cFxuKi9cbmNsYXNzIFBvaW50ZXJEcmFnZ2luZyB7XG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyRWwpIHtcbiAgICAgICAgdGhpcy5zdWJqZWN0RWwgPSBudWxsO1xuICAgICAgICAvLyBvcHRpb25zIHRoYXQgY2FuIGJlIGRpcmVjdGx5IGFzc2lnbmVkIGJ5IGNhbGxlclxuICAgICAgICB0aGlzLnNlbGVjdG9yID0gJyc7IC8vIHdpbGwgY2F1c2Ugc3ViamVjdEVsIGluIGFsbCBlbWl0dGVkIGV2ZW50cyB0byBiZSB0aGlzIGVsZW1lbnRcbiAgICAgICAgdGhpcy5oYW5kbGVTZWxlY3RvciA9ICcnO1xuICAgICAgICB0aGlzLnNob3VsZElnbm9yZU1vdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zaG91bGRXYXRjaFNjcm9sbCA9IHRydWU7IC8vIGZvciBzaW11bGF0aW5nIHBvaW50ZXJtb3ZlIG9uIHNjcm9sbFxuICAgICAgICAvLyBpbnRlcm5hbCBzdGF0ZXNcbiAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNUb3VjaERyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMud2FzVG91Y2hTY3JvbGwgPSBmYWxzZTtcbiAgICAgICAgLy8gTW91c2VcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICB0aGlzLmhhbmRsZU1vdXNlRG93biA9IChldikgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnNob3VsZElnbm9yZU1vdXNlKCkgJiZcbiAgICAgICAgICAgICAgICBpc1ByaW1hcnlNb3VzZUJ1dHRvbihldikgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnRyeVN0YXJ0KGV2KSkge1xuICAgICAgICAgICAgICAgIGxldCBwZXYgPSB0aGlzLmNyZWF0ZUV2ZW50RnJvbU1vdXNlKGV2LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcmRvd24nLCBwZXYpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdFNjcm9sbFdhdGNoKHBldik7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNob3VsZElnbm9yZU1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5oYW5kbGVNb3VzZU1vdmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVNb3VzZU1vdmUgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGxldCBwZXYgPSB0aGlzLmNyZWF0ZUV2ZW50RnJvbU1vdXNlKGV2KTtcbiAgICAgICAgICAgIHRoaXMucmVjb3JkQ29vcmRzKHBldik7XG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcm1vdmUnLCBwZXYpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZU1vdXNlVXAgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuaGFuZGxlTW91c2VNb3ZlKTtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLmhhbmRsZU1vdXNlVXApO1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJ1cCcsIHRoaXMuY3JlYXRlRXZlbnRGcm9tTW91c2UoZXYpKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYW51cCgpOyAvLyBjYWxsIGxhc3Qgc28gdGhhdCBwb2ludGVydXAgaGFzIGFjY2VzcyB0byBwcm9wc1xuICAgICAgICB9O1xuICAgICAgICAvLyBUb3VjaFxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHRoaXMuaGFuZGxlVG91Y2hTdGFydCA9IChldikgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMudHJ5U3RhcnQoZXYpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc1RvdWNoRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGxldCBwZXYgPSB0aGlzLmNyZWF0ZUV2ZW50RnJvbVRvdWNoKGV2LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcmRvd24nLCBwZXYpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdFNjcm9sbFdhdGNoKHBldik7XG4gICAgICAgICAgICAgICAgLy8gdW5saWtlIG1vdXNlLCBuZWVkIHRvIGF0dGFjaCB0byB0YXJnZXQsIG5vdCBkb2N1bWVudFxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80NTc2MDAxNFxuICAgICAgICAgICAgICAgIGxldCB0YXJnZXRFbCA9IGV2LnRhcmdldDtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2hvdWxkSWdub3JlTW92ZSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRFbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLmhhbmRsZVRvdWNoTW92ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhcmdldEVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5oYW5kbGVUb3VjaEVuZCk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0RWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0aGlzLmhhbmRsZVRvdWNoRW5kKTsgLy8gdHJlYXQgaXQgYXMgYSB0b3VjaCBlbmRcbiAgICAgICAgICAgICAgICAvLyBhdHRhY2ggYSBoYW5kbGVyIHRvIGdldCBjYWxsZWQgd2hlbiBBTlkgc2Nyb2xsIGFjdGlvbiBoYXBwZW5zIG9uIHRoZSBwYWdlLlxuICAgICAgICAgICAgICAgIC8vIHRoaXMgd2FzIGltcG9zc2libGUgdG8gZG8gd2l0aCBub3JtYWwgb24vb2ZmIGJlY2F1c2UgJ3Njcm9sbCcgZG9lc24ndCBidWJibGUuXG4gICAgICAgICAgICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzI5NTQ1NjUvOTYzNDJcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5oYW5kbGVUb3VjaFNjcm9sbCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlVG91Y2hNb3ZlID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBsZXQgcGV2ID0gdGhpcy5jcmVhdGVFdmVudEZyb21Ub3VjaChldik7XG4gICAgICAgICAgICB0aGlzLnJlY29yZENvb3JkcyhwZXYpO1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJtb3ZlJywgcGV2KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVUb3VjaEVuZCA9IChldikgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZykgeyAvLyBkb25lIHRvIGd1YXJkIGFnYWluc3QgdG91Y2hlbmQgZm9sbG93ZWQgYnkgdG91Y2hjYW5jZWxcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0RWwgPSBldi50YXJnZXQ7XG4gICAgICAgICAgICAgICAgdGFyZ2V0RWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5oYW5kbGVUb3VjaE1vdmUpO1xuICAgICAgICAgICAgICAgIHRhcmdldEVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5oYW5kbGVUb3VjaEVuZCk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0RWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0aGlzLmhhbmRsZVRvdWNoRW5kKTtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5oYW5kbGVUb3VjaFNjcm9sbCwgdHJ1ZSk7IC8vIHVzZUNhcHR1cmVkPXRydWVcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcnVwJywgdGhpcy5jcmVhdGVFdmVudEZyb21Ub3VjaChldikpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYW51cCgpOyAvLyBjYWxsIGxhc3Qgc28gdGhhdCBwb2ludGVydXAgaGFzIGFjY2VzcyB0byBwcm9wc1xuICAgICAgICAgICAgICAgIHRoaXMuaXNUb3VjaERyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc3RhcnRJZ25vcmluZ01vdXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlVG91Y2hTY3JvbGwgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLndhc1RvdWNoU2Nyb2xsID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGwgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zaG91bGRJZ25vcmVNb3ZlKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhZ2VYID0gKHdpbmRvdy5zY3JvbGxYIC0gdGhpcy5wcmV2U2Nyb2xsWCkgKyB0aGlzLnByZXZQYWdlWDtcbiAgICAgICAgICAgICAgICBsZXQgcGFnZVkgPSAod2luZG93LnNjcm9sbFkgLSB0aGlzLnByZXZTY3JvbGxZKSArIHRoaXMucHJldlBhZ2VZO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVybW92ZScsIHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ0V2ZW50OiBldixcbiAgICAgICAgICAgICAgICAgICAgaXNUb3VjaDogdGhpcy5pc1RvdWNoRHJhZ2dpbmcsXG4gICAgICAgICAgICAgICAgICAgIHN1YmplY3RFbDogdGhpcy5zdWJqZWN0RWwsXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VYLFxuICAgICAgICAgICAgICAgICAgICBwYWdlWSxcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFYOiBwYWdlWCAtIHRoaXMub3JpZ1BhZ2VYLFxuICAgICAgICAgICAgICAgICAgICBkZWx0YVk6IHBhZ2VZIC0gdGhpcy5vcmlnUGFnZVksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY29udGFpbmVyRWwgPSBjb250YWluZXJFbDtcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcbiAgICAgICAgY29udGFpbmVyRWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5oYW5kbGVNb3VzZURvd24pO1xuICAgICAgICBjb250YWluZXJFbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5oYW5kbGVUb3VjaFN0YXJ0LCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgIGxpc3RlbmVyQ3JlYXRlZCgpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lckVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlTW91c2VEb3duKTtcbiAgICAgICAgdGhpcy5jb250YWluZXJFbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5oYW5kbGVUb3VjaFN0YXJ0LCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgIGxpc3RlbmVyRGVzdHJveWVkKCk7XG4gICAgfVxuICAgIHRyeVN0YXJ0KGV2KSB7XG4gICAgICAgIGxldCBzdWJqZWN0RWwgPSB0aGlzLnF1ZXJ5U3ViamVjdEVsKGV2KTtcbiAgICAgICAgbGV0IGRvd25FbCA9IGV2LnRhcmdldDtcbiAgICAgICAgaWYgKHN1YmplY3RFbCAmJlxuICAgICAgICAgICAgKCF0aGlzLmhhbmRsZVNlbGVjdG9yIHx8IGVsZW1lbnRDbG9zZXN0KGRvd25FbCwgdGhpcy5oYW5kbGVTZWxlY3RvcikpKSB7XG4gICAgICAgICAgICB0aGlzLnN1YmplY3RFbCA9IHN1YmplY3RFbDtcbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IHRydWU7IC8vIGRvIHRoaXMgZmlyc3Qgc28gY2FuY2VsVG91Y2hTY3JvbGwgd2lsbCB3b3JrXG4gICAgICAgICAgICB0aGlzLndhc1RvdWNoU2Nyb2xsID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNsZWFudXAoKSB7XG4gICAgICAgIGlzV2luZG93VG91Y2hNb3ZlQ2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN1YmplY3RFbCA9IG51bGw7XG4gICAgICAgIC8vIGtlZXAgd2FzVG91Y2hTY3JvbGwgYXJvdW5kIGZvciBsYXRlciBhY2Nlc3NcbiAgICAgICAgdGhpcy5kZXN0cm95U2Nyb2xsV2F0Y2goKTtcbiAgICB9XG4gICAgcXVlcnlTdWJqZWN0RWwoZXYpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50Q2xvc2VzdChldi50YXJnZXQsIHRoaXMuc2VsZWN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lckVsO1xuICAgIH1cbiAgICBzaG91bGRJZ25vcmVNb3VzZSgpIHtcbiAgICAgICAgcmV0dXJuIGlnbm9yZU1vdXNlRGVwdGggfHwgdGhpcy5pc1RvdWNoRHJhZ2dpbmc7XG4gICAgfVxuICAgIC8vIGNhbiBiZSBjYWxsZWQgYnkgdXNlciBvZiB0aGlzIGNsYXNzLCB0byBjYW5jZWwgdG91Y2gtYmFzZWQgc2Nyb2xsaW5nIGZvciB0aGUgY3VycmVudCBkcmFnXG4gICAgY2FuY2VsVG91Y2hTY3JvbGwoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIGlzV2luZG93VG91Y2hNb3ZlQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBTY3JvbGxpbmcgdGhhdCBzaW11bGF0ZXMgcG9pbnRlcm1vdmVzXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGluaXRTY3JvbGxXYXRjaChldikge1xuICAgICAgICBpZiAodGhpcy5zaG91bGRXYXRjaFNjcm9sbCkge1xuICAgICAgICAgICAgdGhpcy5yZWNvcmRDb29yZHMoZXYpO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuaGFuZGxlU2Nyb2xsLCB0cnVlKTsgLy8gdXNlQ2FwdHVyZT10cnVlXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVjb3JkQ29vcmRzKGV2KSB7XG4gICAgICAgIGlmICh0aGlzLnNob3VsZFdhdGNoU2Nyb2xsKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZQYWdlWCA9IGV2LnBhZ2VYO1xuICAgICAgICAgICAgdGhpcy5wcmV2UGFnZVkgPSBldi5wYWdlWTtcbiAgICAgICAgICAgIHRoaXMucHJldlNjcm9sbFggPSB3aW5kb3cuc2Nyb2xsWDtcbiAgICAgICAgICAgIHRoaXMucHJldlNjcm9sbFkgPSB3aW5kb3cuc2Nyb2xsWTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95U2Nyb2xsV2F0Y2goKSB7XG4gICAgICAgIGlmICh0aGlzLnNob3VsZFdhdGNoU2Nyb2xsKSB7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5oYW5kbGVTY3JvbGwsIHRydWUpOyAvLyB1c2VDYXB0dXJlZD10cnVlXG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRXZlbnQgTm9ybWFsaXphdGlvblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBjcmVhdGVFdmVudEZyb21Nb3VzZShldiwgaXNGaXJzdCkge1xuICAgICAgICBsZXQgZGVsdGFYID0gMDtcbiAgICAgICAgbGV0IGRlbHRhWSA9IDA7XG4gICAgICAgIC8vIFRPRE86IHJlcGVhdCBjb2RlXG4gICAgICAgIGlmIChpc0ZpcnN0KSB7XG4gICAgICAgICAgICB0aGlzLm9yaWdQYWdlWCA9IGV2LnBhZ2VYO1xuICAgICAgICAgICAgdGhpcy5vcmlnUGFnZVkgPSBldi5wYWdlWTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbHRhWCA9IGV2LnBhZ2VYIC0gdGhpcy5vcmlnUGFnZVg7XG4gICAgICAgICAgICBkZWx0YVkgPSBldi5wYWdlWSAtIHRoaXMub3JpZ1BhZ2VZO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvcmlnRXZlbnQ6IGV2LFxuICAgICAgICAgICAgaXNUb3VjaDogZmFsc2UsXG4gICAgICAgICAgICBzdWJqZWN0RWw6IHRoaXMuc3ViamVjdEVsLFxuICAgICAgICAgICAgcGFnZVg6IGV2LnBhZ2VYLFxuICAgICAgICAgICAgcGFnZVk6IGV2LnBhZ2VZLFxuICAgICAgICAgICAgZGVsdGFYLFxuICAgICAgICAgICAgZGVsdGFZLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjcmVhdGVFdmVudEZyb21Ub3VjaChldiwgaXNGaXJzdCkge1xuICAgICAgICBsZXQgdG91Y2hlcyA9IGV2LnRvdWNoZXM7XG4gICAgICAgIGxldCBwYWdlWDtcbiAgICAgICAgbGV0IHBhZ2VZO1xuICAgICAgICBsZXQgZGVsdGFYID0gMDtcbiAgICAgICAgbGV0IGRlbHRhWSA9IDA7XG4gICAgICAgIC8vIGlmIHRvdWNoIGNvb3JkcyBhdmFpbGFibGUsIHByZWZlcixcbiAgICAgICAgLy8gYmVjYXVzZSBGRiB3b3VsZCBnaXZlIGJhZCBldi5wYWdlWCBldi5wYWdlWVxuICAgICAgICBpZiAodG91Y2hlcyAmJiB0b3VjaGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgcGFnZVggPSB0b3VjaGVzWzBdLnBhZ2VYO1xuICAgICAgICAgICAgcGFnZVkgPSB0b3VjaGVzWzBdLnBhZ2VZO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFnZVggPSBldi5wYWdlWDtcbiAgICAgICAgICAgIHBhZ2VZID0gZXYucGFnZVk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogcmVwZWF0IGNvZGVcbiAgICAgICAgaWYgKGlzRmlyc3QpIHtcbiAgICAgICAgICAgIHRoaXMub3JpZ1BhZ2VYID0gcGFnZVg7XG4gICAgICAgICAgICB0aGlzLm9yaWdQYWdlWSA9IHBhZ2VZO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsdGFYID0gcGFnZVggLSB0aGlzLm9yaWdQYWdlWDtcbiAgICAgICAgICAgIGRlbHRhWSA9IHBhZ2VZIC0gdGhpcy5vcmlnUGFnZVk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9yaWdFdmVudDogZXYsXG4gICAgICAgICAgICBpc1RvdWNoOiB0cnVlLFxuICAgICAgICAgICAgc3ViamVjdEVsOiB0aGlzLnN1YmplY3RFbCxcbiAgICAgICAgICAgIHBhZ2VYLFxuICAgICAgICAgICAgcGFnZVksXG4gICAgICAgICAgICBkZWx0YVgsXG4gICAgICAgICAgICBkZWx0YVksXG4gICAgICAgIH07XG4gICAgfVxufVxuLy8gUmV0dXJucyBhIGJvb2xlYW4gd2hldGhlciB0aGlzIHdhcyBhIGxlZnQgbW91c2UgY2xpY2sgYW5kIG5vIGN0cmwga2V5ICh3aGljaCBtZWFucyByaWdodCBjbGljayBvbiBNYWMpXG5mdW5jdGlvbiBpc1ByaW1hcnlNb3VzZUJ1dHRvbihldikge1xuICAgIHJldHVybiBldi5idXR0b24gPT09IDAgJiYgIWV2LmN0cmxLZXk7XG59XG4vLyBJZ25vcmluZyBmYWtlIG1vdXNlIGV2ZW50cyBnZW5lcmF0ZWQgYnkgdG91Y2hcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIHN0YXJ0SWdub3JpbmdNb3VzZSgpIHtcbiAgICBpZ25vcmVNb3VzZURlcHRoICs9IDE7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlnbm9yZU1vdXNlRGVwdGggLT0gMTtcbiAgICB9LCBjb25maWcudG91Y2hNb3VzZUlnbm9yZVdhaXQpO1xufVxuLy8gV2Ugd2FudCB0byBhdHRhY2ggdG91Y2htb3ZlIGFzIGVhcmx5IGFzIHBvc3NpYmxlIGZvciBTYWZhcmlcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGxpc3RlbmVyQ3JlYXRlZCgpIHtcbiAgICBsaXN0ZW5lckNudCArPSAxO1xuICAgIGlmIChsaXN0ZW5lckNudCA9PT0gMSkge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25XaW5kb3dUb3VjaE1vdmUsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gbGlzdGVuZXJEZXN0cm95ZWQoKSB7XG4gICAgbGlzdGVuZXJDbnQgLT0gMTtcbiAgICBpZiAoIWxpc3RlbmVyQ250KSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvbldpbmRvd1RvdWNoTW92ZSwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBvbldpbmRvd1RvdWNoTW92ZShldikge1xuICAgIGlmIChpc1dpbmRvd1RvdWNoTW92ZUNhbmNlbGxlZCkge1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbn1cblxuLypcbkFuIGVmZmVjdCBpbiB3aGljaCBhbiBlbGVtZW50IGZvbGxvd3MgdGhlIG1vdmVtZW50IG9mIGEgcG9pbnRlciBhY3Jvc3MgdGhlIHNjcmVlbi5cblRoZSBtb3ZpbmcgZWxlbWVudCBpcyBhIGNsb25lIG9mIHNvbWUgb3RoZXIgZWxlbWVudC5cbk11c3QgY2FsbCBzdGFydCArIGhhbmRsZU1vdmUgKyBzdG9wLlxuKi9cbmNsYXNzIEVsZW1lbnRNaXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IGZhbHNlOyAvLyBtdXN0IGJlIGV4cGxpY2l0bHkgZW5hYmxlZFxuICAgICAgICB0aGlzLnNvdXJjZUVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5taXJyb3JFbCA9IG51bGw7XG4gICAgICAgIHRoaXMuc291cmNlRWxSZWN0ID0gbnVsbDsgLy8gc2NyZWVuIGNvb3JkcyByZWxhdGl2ZSB0byB2aWV3cG9ydFxuICAgICAgICAvLyBvcHRpb25zIHRoYXQgY2FuIGJlIHNldCBkaXJlY3RseSBieSBjYWxsZXJcbiAgICAgICAgdGhpcy5wYXJlbnROb2RlID0gZG9jdW1lbnQuYm9keTsgLy8gSElHSExZIFNVR0dFU1RFRCB0byBzZXQgdGhpcyB0byBzaWRlc3RlcCBTaGFkb3dET00gaXNzdWVzXG4gICAgICAgIHRoaXMuekluZGV4ID0gOTk5OTtcbiAgICAgICAgdGhpcy5yZXZlcnREdXJhdGlvbiA9IDA7XG4gICAgfVxuICAgIHN0YXJ0KHNvdXJjZUVsLCBwYWdlWCwgcGFnZVkpIHtcbiAgICAgICAgdGhpcy5zb3VyY2VFbCA9IHNvdXJjZUVsO1xuICAgICAgICB0aGlzLnNvdXJjZUVsUmVjdCA9IHRoaXMuc291cmNlRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHRoaXMub3JpZ1NjcmVlblggPSBwYWdlWCAtIHdpbmRvdy5zY3JvbGxYO1xuICAgICAgICB0aGlzLm9yaWdTY3JlZW5ZID0gcGFnZVkgLSB3aW5kb3cuc2Nyb2xsWTtcbiAgICAgICAgdGhpcy5kZWx0YVggPSAwO1xuICAgICAgICB0aGlzLmRlbHRhWSA9IDA7XG4gICAgICAgIHRoaXMudXBkYXRlRWxQb3NpdGlvbigpO1xuICAgIH1cbiAgICBoYW5kbGVNb3ZlKHBhZ2VYLCBwYWdlWSkge1xuICAgICAgICB0aGlzLmRlbHRhWCA9IChwYWdlWCAtIHdpbmRvdy5zY3JvbGxYKSAtIHRoaXMub3JpZ1NjcmVlblg7XG4gICAgICAgIHRoaXMuZGVsdGFZID0gKHBhZ2VZIC0gd2luZG93LnNjcm9sbFkpIC0gdGhpcy5vcmlnU2NyZWVuWTtcbiAgICAgICAgdGhpcy51cGRhdGVFbFBvc2l0aW9uKCk7XG4gICAgfVxuICAgIC8vIGNhbiBiZSBjYWxsZWQgYmVmb3JlIHN0YXJ0XG4gICAgc2V0SXNWaXNpYmxlKGJvb2wpIHtcbiAgICAgICAgaWYgKGJvb2wpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1Zpc2libGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5taXJyb3JFbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1pcnJvckVsLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5pc1Zpc2libGUgPSBib29sOyAvLyBuZWVkcyB0byBoYXBwZW4gYmVmb3JlIHVwZGF0ZUVsUG9zaXRpb25cbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUVsUG9zaXRpb24oKTsgLy8gYmVjYXVzZSB3YXMgbm90IHVwZGF0aW5nIHRoZSBwb3NpdGlvbiB3aGlsZSBpbnZpc2libGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubWlycm9yRWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1pcnJvckVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IGJvb2w7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYWx3YXlzIGFzeW5jXG4gICAgc3RvcChuZWVkc1JldmVydEFuaW1hdGlvbiwgY2FsbGJhY2spIHtcbiAgICAgICAgbGV0IGRvbmUgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChuZWVkc1JldmVydEFuaW1hdGlvbiAmJlxuICAgICAgICAgICAgdGhpcy5taXJyb3JFbCAmJlxuICAgICAgICAgICAgdGhpcy5pc1Zpc2libGUgJiZcbiAgICAgICAgICAgIHRoaXMucmV2ZXJ0RHVyYXRpb24gJiYgLy8gaWYgMCwgdHJhbnNpdGlvbiB3b24ndCB3b3JrXG4gICAgICAgICAgICAodGhpcy5kZWx0YVggfHwgdGhpcy5kZWx0YVkpIC8vIGlmIHNhbWUgY29vcmRzLCB0cmFuc2l0aW9uIHdvbid0IHdvcmtcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLmRvUmV2ZXJ0QW5pbWF0aW9uKGRvbmUsIHRoaXMucmV2ZXJ0RHVyYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0VGltZW91dChkb25lLCAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkb1JldmVydEFuaW1hdGlvbihjYWxsYmFjaywgcmV2ZXJ0RHVyYXRpb24pIHtcbiAgICAgICAgbGV0IG1pcnJvckVsID0gdGhpcy5taXJyb3JFbDtcbiAgICAgICAgbGV0IGZpbmFsU291cmNlRWxSZWN0ID0gdGhpcy5zb3VyY2VFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgLy8gYmVjYXVzZSBhdXRvc2Nyb2xsaW5nIG1pZ2h0IGhhdmUgaGFwcGVuZWRcbiAgICAgICAgbWlycm9yRWwuc3R5bGUudHJhbnNpdGlvbiA9XG4gICAgICAgICAgICAndG9wICcgKyByZXZlcnREdXJhdGlvbiArICdtcywnICtcbiAgICAgICAgICAgICAgICAnbGVmdCAnICsgcmV2ZXJ0RHVyYXRpb24gKyAnbXMnO1xuICAgICAgICBhcHBseVN0eWxlKG1pcnJvckVsLCB7XG4gICAgICAgICAgICBsZWZ0OiBmaW5hbFNvdXJjZUVsUmVjdC5sZWZ0LFxuICAgICAgICAgICAgdG9wOiBmaW5hbFNvdXJjZUVsUmVjdC50b3AsXG4gICAgICAgIH0pO1xuICAgICAgICB3aGVuVHJhbnNpdGlvbkRvbmUobWlycm9yRWwsICgpID0+IHtcbiAgICAgICAgICAgIG1pcnJvckVsLnN0eWxlLnRyYW5zaXRpb24gPSAnJztcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjbGVhbnVwKCkge1xuICAgICAgICBpZiAodGhpcy5taXJyb3JFbCkge1xuICAgICAgICAgICAgcmVtb3ZlRWxlbWVudCh0aGlzLm1pcnJvckVsKTtcbiAgICAgICAgICAgIHRoaXMubWlycm9yRWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc291cmNlRWwgPSBudWxsO1xuICAgIH1cbiAgICB1cGRhdGVFbFBvc2l0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5zb3VyY2VFbCAmJiB0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgICAgICAgYXBwbHlTdHlsZSh0aGlzLmdldE1pcnJvckVsKCksIHtcbiAgICAgICAgICAgICAgICBsZWZ0OiB0aGlzLnNvdXJjZUVsUmVjdC5sZWZ0ICsgdGhpcy5kZWx0YVgsXG4gICAgICAgICAgICAgICAgdG9wOiB0aGlzLnNvdXJjZUVsUmVjdC50b3AgKyB0aGlzLmRlbHRhWSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldE1pcnJvckVsKCkge1xuICAgICAgICBsZXQgc291cmNlRWxSZWN0ID0gdGhpcy5zb3VyY2VFbFJlY3Q7XG4gICAgICAgIGxldCBtaXJyb3JFbCA9IHRoaXMubWlycm9yRWw7XG4gICAgICAgIGlmICghbWlycm9yRWwpIHtcbiAgICAgICAgICAgIG1pcnJvckVsID0gdGhpcy5taXJyb3JFbCA9IHRoaXMuc291cmNlRWwuY2xvbmVOb2RlKHRydWUpOyAvLyBjbG9uZUNoaWxkcmVuPXRydWVcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IHdhbnQgbG9uZyB0YXBzIG9yIGFueSBtb3VzZSBpbnRlcmFjdGlvbiBjYXVzaW5nIHNlbGVjdGlvbi9tZW51cy5cbiAgICAgICAgICAgIC8vIHdvdWxkIHVzZSBwcmV2ZW50U2VsZWN0aW9uKCksIGJ1dCB0aGF0IHByZXZlbnRzIHNlbGVjdHN0YXJ0LCBjYXVzaW5nIHByb2JsZW1zLlxuICAgICAgICAgICAgbWlycm9yRWwuc3R5bGUudXNlclNlbGVjdCA9ICdub25lJztcbiAgICAgICAgICAgIG1pcnJvckVsLnN0eWxlLndlYmtpdFVzZXJTZWxlY3QgPSAnbm9uZSc7XG4gICAgICAgICAgICBtaXJyb3JFbC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgICAgICAgICAgbWlycm9yRWwuY2xhc3NMaXN0LmFkZCgnZmMtZXZlbnQtZHJhZ2dpbmcnKTtcbiAgICAgICAgICAgIGFwcGx5U3R5bGUobWlycm9yRWwsIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgICAgICAgICAgICB6SW5kZXg6IHRoaXMuekluZGV4LFxuICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6ICcnLFxuICAgICAgICAgICAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBzb3VyY2VFbFJlY3QucmlnaHQgLSBzb3VyY2VFbFJlY3QubGVmdCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHNvdXJjZUVsUmVjdC5ib3R0b20gLSBzb3VyY2VFbFJlY3QudG9wLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiAnYXV0bycsXG4gICAgICAgICAgICAgICAgYm90dG9tOiAnYXV0bycsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQobWlycm9yRWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaXJyb3JFbDtcbiAgICB9XG59XG5cbi8qXG5JcyBhIGNhY2hlIGZvciBhIGdpdmVuIGVsZW1lbnQncyBzY3JvbGwgaW5mb3JtYXRpb24gKGFsbCB0aGUgaW5mbyB0aGF0IFNjcm9sbENvbnRyb2xsZXIgc3RvcmVzKVxuaW4gYWRkaXRpb24gdGhlIFwiY2xpZW50IHJlY3RhbmdsZVwiIG9mIHRoZSBlbGVtZW50Li4gdGhlIGFyZWEgd2l0aGluIHRoZSBzY3JvbGxiYXJzLlxuXG5UaGUgY2FjaGUgY2FuIGJlIGluIG9uZSBvZiB0d28gbW9kZXM6XG4tIGRvZXNMaXN0ZW5pbmc6ZmFsc2UgLSBpZ25vcmVzIHdoZW4gdGhlIGNvbnRhaW5lciBpcyBzY3JvbGxlZCBieSBzb21lb25lIGVsc2Vcbi0gZG9lc0xpc3RlbmluZzp0cnVlIC0gd2F0Y2ggZm9yIHNjcm9sbGluZyBhbmQgdXBkYXRlIHRoZSBjYWNoZVxuKi9cbmNsYXNzIFNjcm9sbEdlb21DYWNoZSBleHRlbmRzIFNjcm9sbENvbnRyb2xsZXIge1xuICAgIGNvbnN0cnVjdG9yKHNjcm9sbENvbnRyb2xsZXIsIGRvZXNMaXN0ZW5pbmcpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGwgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRvcCA9IHRoaXMuc2Nyb2xsQ29udHJvbGxlci5nZXRTY3JvbGxUb3AoKTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsTGVmdCA9IHRoaXMuc2Nyb2xsQ29udHJvbGxlci5nZXRTY3JvbGxMZWZ0KCk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVNjcm9sbENoYW5nZSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNjcm9sbENvbnRyb2xsZXIgPSBzY3JvbGxDb250cm9sbGVyO1xuICAgICAgICB0aGlzLmRvZXNMaXN0ZW5pbmcgPSBkb2VzTGlzdGVuaW5nO1xuICAgICAgICB0aGlzLnNjcm9sbFRvcCA9IHRoaXMub3JpZ1Njcm9sbFRvcCA9IHNjcm9sbENvbnRyb2xsZXIuZ2V0U2Nyb2xsVG9wKCk7XG4gICAgICAgIHRoaXMuc2Nyb2xsTGVmdCA9IHRoaXMub3JpZ1Njcm9sbExlZnQgPSBzY3JvbGxDb250cm9sbGVyLmdldFNjcm9sbExlZnQoKTtcbiAgICAgICAgdGhpcy5zY3JvbGxXaWR0aCA9IHNjcm9sbENvbnRyb2xsZXIuZ2V0U2Nyb2xsV2lkdGgoKTtcbiAgICAgICAgdGhpcy5zY3JvbGxIZWlnaHQgPSBzY3JvbGxDb250cm9sbGVyLmdldFNjcm9sbEhlaWdodCgpO1xuICAgICAgICB0aGlzLmNsaWVudFdpZHRoID0gc2Nyb2xsQ29udHJvbGxlci5nZXRDbGllbnRXaWR0aCgpO1xuICAgICAgICB0aGlzLmNsaWVudEhlaWdodCA9IHNjcm9sbENvbnRyb2xsZXIuZ2V0Q2xpZW50SGVpZ2h0KCk7XG4gICAgICAgIHRoaXMuY2xpZW50UmVjdCA9IHRoaXMuY29tcHV0ZUNsaWVudFJlY3QoKTsgLy8gZG8gbGFzdCBpbiBjYXNlIGl0IG5lZWRzIGNhY2hlZCB2YWx1ZXNcbiAgICAgICAgaWYgKHRoaXMuZG9lc0xpc3RlbmluZykge1xuICAgICAgICAgICAgdGhpcy5nZXRFdmVudFRhcmdldCgpLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuaGFuZGxlU2Nyb2xsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5kb2VzTGlzdGVuaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmdldEV2ZW50VGFyZ2V0KCkucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5oYW5kbGVTY3JvbGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFNjcm9sbFRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsVG9wO1xuICAgIH1cbiAgICBnZXRTY3JvbGxMZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxMZWZ0O1xuICAgIH1cbiAgICBzZXRTY3JvbGxUb3AodG9wKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsQ29udHJvbGxlci5zZXRTY3JvbGxUb3AodG9wKTtcbiAgICAgICAgaWYgKCF0aGlzLmRvZXNMaXN0ZW5pbmcpIHtcbiAgICAgICAgICAgIC8vIHdlIGFyZSBub3QgcmVseWluZyBvbiB0aGUgZWxlbWVudCB0byBub3JtYWxpemUgb3V0LW9mLWJvdW5kcyBzY3JvbGwgdmFsdWVzXG4gICAgICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIHNhbml0aXplIG91cnNlbHZlc1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxUb3AgPSBNYXRoLm1heChNYXRoLm1pbih0b3AsIHRoaXMuZ2V0TWF4U2Nyb2xsVG9wKCkpLCAwKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU2Nyb2xsQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0U2Nyb2xsTGVmdCh0b3ApIHtcbiAgICAgICAgdGhpcy5zY3JvbGxDb250cm9sbGVyLnNldFNjcm9sbExlZnQodG9wKTtcbiAgICAgICAgaWYgKCF0aGlzLmRvZXNMaXN0ZW5pbmcpIHtcbiAgICAgICAgICAgIC8vIHdlIGFyZSBub3QgcmVseWluZyBvbiB0aGUgZWxlbWVudCB0byBub3JtYWxpemUgb3V0LW9mLWJvdW5kcyBzY3JvbGwgdmFsdWVzXG4gICAgICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIHNhbml0aXplIG91cnNlbHZlc1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxMZWZ0ID0gTWF0aC5tYXgoTWF0aC5taW4odG9wLCB0aGlzLmdldE1heFNjcm9sbExlZnQoKSksIDApO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGxDaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRDbGllbnRXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50V2lkdGg7XG4gICAgfVxuICAgIGdldENsaWVudEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50SGVpZ2h0O1xuICAgIH1cbiAgICBnZXRTY3JvbGxXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsV2lkdGg7XG4gICAgfVxuICAgIGdldFNjcm9sbEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsSGVpZ2h0O1xuICAgIH1cbiAgICBoYW5kbGVTY3JvbGxDaGFuZ2UoKSB7XG4gICAgfVxufVxuXG5jbGFzcyBFbGVtZW50U2Nyb2xsR2VvbUNhY2hlIGV4dGVuZHMgU2Nyb2xsR2VvbUNhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcihlbCwgZG9lc0xpc3RlbmluZykge1xuICAgICAgICBzdXBlcihuZXcgRWxlbWVudFNjcm9sbENvbnRyb2xsZXIoZWwpLCBkb2VzTGlzdGVuaW5nKTtcbiAgICB9XG4gICAgZ2V0RXZlbnRUYXJnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbENvbnRyb2xsZXIuZWw7XG4gICAgfVxuICAgIGNvbXB1dGVDbGllbnRSZWN0KCkge1xuICAgICAgICByZXR1cm4gY29tcHV0ZUlubmVyUmVjdCh0aGlzLnNjcm9sbENvbnRyb2xsZXIuZWwpO1xuICAgIH1cbn1cblxuY2xhc3MgV2luZG93U2Nyb2xsR2VvbUNhY2hlIGV4dGVuZHMgU2Nyb2xsR2VvbUNhY2hlIHtcbiAgICBjb25zdHJ1Y3Rvcihkb2VzTGlzdGVuaW5nKSB7XG4gICAgICAgIHN1cGVyKG5ldyBXaW5kb3dTY3JvbGxDb250cm9sbGVyKCksIGRvZXNMaXN0ZW5pbmcpO1xuICAgIH1cbiAgICBnZXRFdmVudFRhcmdldCgpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICB9XG4gICAgY29tcHV0ZUNsaWVudFJlY3QoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiB0aGlzLnNjcm9sbExlZnQsXG4gICAgICAgICAgICByaWdodDogdGhpcy5zY3JvbGxMZWZ0ICsgdGhpcy5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgIHRvcDogdGhpcy5zY3JvbGxUb3AsXG4gICAgICAgICAgICBib3R0b206IHRoaXMuc2Nyb2xsVG9wICsgdGhpcy5jbGllbnRIZWlnaHQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIHRoZSB3aW5kb3cgaXMgdGhlIG9ubHkgc2Nyb2xsIG9iamVjdCB0aGF0IGNoYW5nZXMgaXQncyByZWN0YW5nbGUgcmVsYXRpdmVcbiAgICAvLyB0byB0aGUgZG9jdW1lbnQncyB0b3BsZWZ0IGFzIGl0IHNjcm9sbHNcbiAgICBoYW5kbGVTY3JvbGxDaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMuY2xpZW50UmVjdCA9IHRoaXMuY29tcHV0ZUNsaWVudFJlY3QoKTtcbiAgICB9XG59XG5cbi8vIElmIGF2YWlsYWJsZSB3ZSBhcmUgdXNpbmcgbmF0aXZlIFwicGVyZm9ybWFuY2VcIiBBUEkgaW5zdGVhZCBvZiBcIkRhdGVcIlxuLy8gUmVhZCBtb3JlIGFib3V0IGl0IG9uIE1ETjpcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9QZXJmb3JtYW5jZVxuY29uc3QgZ2V0VGltZSA9IHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ2Z1bmN0aW9uJyA/IHBlcmZvcm1hbmNlLm5vdyA6IERhdGUubm93O1xuLypcbkZvciBhIHBvaW50ZXIgaW50ZXJhY3Rpb24sIGF1dG9tYXRpY2FsbHkgc2Nyb2xscyBjZXJ0YWluIHNjcm9sbCBjb250YWluZXJzIHdoZW4gdGhlIHBvaW50ZXJcbmFwcHJvYWNoZXMgdGhlIGVkZ2UuXG5cblRoZSBjYWxsZXIgbXVzdCBjYWxsIHN0YXJ0ICsgaGFuZGxlTW92ZSArIHN0b3AuXG4qL1xuY2xhc3MgQXV0b1Njcm9sbGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IGNhbiBiZSBzZXQgYnkgY2FsbGVyXG4gICAgICAgIHRoaXMuaXNFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zY3JvbGxRdWVyeSA9IFt3aW5kb3csICcuZmMtc2Nyb2xsZXInXTtcbiAgICAgICAgdGhpcy5lZGdlVGhyZXNob2xkID0gNTA7IC8vIHBpeGVsc1xuICAgICAgICB0aGlzLm1heFZlbG9jaXR5ID0gMzAwOyAvLyBwaXhlbHMgcGVyIHNlY29uZFxuICAgICAgICAvLyBpbnRlcm5hbCBzdGF0ZVxuICAgICAgICB0aGlzLnBvaW50ZXJTY3JlZW5YID0gbnVsbDtcbiAgICAgICAgdGhpcy5wb2ludGVyU2NyZWVuWSA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNBbmltYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zY3JvbGxDYWNoZXMgPSBudWxsO1xuICAgICAgICAvLyBwcm90ZWN0IGFnYWluc3QgdGhlIGluaXRpYWwgcG9pbnRlcmRvd24gYmVpbmcgdG9vIGNsb3NlIHRvIGFuIGVkZ2UgYW5kIHN0YXJ0aW5nIHRoZSBzY3JvbGxcbiAgICAgICAgdGhpcy5ldmVyTW92ZWRVcCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmV2ZXJNb3ZlZERvd24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ldmVyTW92ZWRMZWZ0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXZlck1vdmVkUmlnaHQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hbmltYXRlID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNBbmltYXRpbmcpIHsgLy8gd2Fzbid0IGNhbmNlbGxlZCBiZXR3ZWVuIGFuaW1hdGlvbiBjYWxsc1xuICAgICAgICAgICAgICAgIGxldCBlZGdlID0gdGhpcy5jb21wdXRlQmVzdEVkZ2UodGhpcy5wb2ludGVyU2NyZWVuWCArIHdpbmRvdy5zY3JvbGxYLCB0aGlzLnBvaW50ZXJTY3JlZW5ZICsgd2luZG93LnNjcm9sbFkpO1xuICAgICAgICAgICAgICAgIGlmIChlZGdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBub3cgPSBnZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlU2lkZShlZGdlLCAobm93IC0gdGhpcy5tc1NpbmNlUmVxdWVzdCkgLyAxMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0QW5pbWF0aW9uKG5vdyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzQW5pbWF0aW5nID0gZmFsc2U7IC8vIHdpbGwgc3RvcCBhbmltYXRpb25cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXJ0KHBhZ2VYLCBwYWdlWSwgc2Nyb2xsU3RhcnRFbCkge1xuICAgICAgICBpZiAodGhpcy5pc0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQ2FjaGVzID0gdGhpcy5idWlsZENhY2hlcyhzY3JvbGxTdGFydEVsKTtcbiAgICAgICAgICAgIHRoaXMucG9pbnRlclNjcmVlblggPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5wb2ludGVyU2NyZWVuWSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmV2ZXJNb3ZlZFVwID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmV2ZXJNb3ZlZERvd24gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZXZlck1vdmVkTGVmdCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5ldmVyTW92ZWRSaWdodCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVNb3ZlKHBhZ2VYLCBwYWdlWSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlTW92ZShwYWdlWCwgcGFnZVkpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbmFibGVkKSB7XG4gICAgICAgICAgICBsZXQgcG9pbnRlclNjcmVlblggPSBwYWdlWCAtIHdpbmRvdy5zY3JvbGxYO1xuICAgICAgICAgICAgbGV0IHBvaW50ZXJTY3JlZW5ZID0gcGFnZVkgLSB3aW5kb3cuc2Nyb2xsWTtcbiAgICAgICAgICAgIGxldCB5RGVsdGEgPSB0aGlzLnBvaW50ZXJTY3JlZW5ZID09PSBudWxsID8gMCA6IHBvaW50ZXJTY3JlZW5ZIC0gdGhpcy5wb2ludGVyU2NyZWVuWTtcbiAgICAgICAgICAgIGxldCB4RGVsdGEgPSB0aGlzLnBvaW50ZXJTY3JlZW5YID09PSBudWxsID8gMCA6IHBvaW50ZXJTY3JlZW5YIC0gdGhpcy5wb2ludGVyU2NyZWVuWDtcbiAgICAgICAgICAgIGlmICh5RGVsdGEgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVyTW92ZWRVcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh5RGVsdGEgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVyTW92ZWREb3duID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4RGVsdGEgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVyTW92ZWRMZWZ0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHhEZWx0YSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZXJNb3ZlZFJpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucG9pbnRlclNjcmVlblggPSBwb2ludGVyU2NyZWVuWDtcbiAgICAgICAgICAgIHRoaXMucG9pbnRlclNjcmVlblkgPSBwb2ludGVyU2NyZWVuWTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0FuaW1hdGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNBbmltYXRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbihnZXRUaW1lKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5pc0FuaW1hdGluZyA9IGZhbHNlOyAvLyB3aWxsIHN0b3AgYW5pbWF0aW9uXG4gICAgICAgICAgICBmb3IgKGxldCBzY3JvbGxDYWNoZSBvZiB0aGlzLnNjcm9sbENhY2hlcykge1xuICAgICAgICAgICAgICAgIHNjcm9sbENhY2hlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQ2FjaGVzID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXF1ZXN0QW5pbWF0aW9uKG5vdykge1xuICAgICAgICB0aGlzLm1zU2luY2VSZXF1ZXN0ID0gbm93O1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRlKTtcbiAgICB9XG4gICAgaGFuZGxlU2lkZShlZGdlLCBzZWNvbmRzKSB7XG4gICAgICAgIGxldCB7IHNjcm9sbENhY2hlIH0gPSBlZGdlO1xuICAgICAgICBsZXQgeyBlZGdlVGhyZXNob2xkIH0gPSB0aGlzO1xuICAgICAgICBsZXQgaW52RGlzdGFuY2UgPSBlZGdlVGhyZXNob2xkIC0gZWRnZS5kaXN0YW5jZTtcbiAgICAgICAgbGV0IHZlbG9jaXR5ID0gLy8gdGhlIGNsb3NlciB0byB0aGUgZWRnZSwgdGhlIGZhc3RlciB3ZSBzY3JvbGxcbiAgICAgICAgICgoaW52RGlzdGFuY2UgKiBpbnZEaXN0YW5jZSkgLyAoZWRnZVRocmVzaG9sZCAqIGVkZ2VUaHJlc2hvbGQpKSAqIC8vIHF1YWRyYXRpY1xuICAgICAgICAgICAgdGhpcy5tYXhWZWxvY2l0eSAqIHNlY29uZHM7XG4gICAgICAgIGxldCBzaWduID0gMTtcbiAgICAgICAgc3dpdGNoIChlZGdlLm5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgIHNpZ24gPSAtMTtcbiAgICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICBzY3JvbGxDYWNoZS5zZXRTY3JvbGxMZWZ0KHNjcm9sbENhY2hlLmdldFNjcm9sbExlZnQoKSArIHZlbG9jaXR5ICogc2lnbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgICAgIHNpZ24gPSAtMTtcbiAgICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgc2Nyb2xsQ2FjaGUuc2V0U2Nyb2xsVG9wKHNjcm9sbENhY2hlLmdldFNjcm9sbFRvcCgpICsgdmVsb2NpdHkgKiBzaWduKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBsZWZ0L3RvcCBhcmUgcmVsYXRpdmUgdG8gZG9jdW1lbnQgdG9wbGVmdFxuICAgIGNvbXB1dGVCZXN0RWRnZShsZWZ0LCB0b3ApIHtcbiAgICAgICAgbGV0IHsgZWRnZVRocmVzaG9sZCB9ID0gdGhpcztcbiAgICAgICAgbGV0IGJlc3RTaWRlID0gbnVsbDtcbiAgICAgICAgbGV0IHNjcm9sbENhY2hlcyA9IHRoaXMuc2Nyb2xsQ2FjaGVzIHx8IFtdO1xuICAgICAgICBmb3IgKGxldCBzY3JvbGxDYWNoZSBvZiBzY3JvbGxDYWNoZXMpIHtcbiAgICAgICAgICAgIGxldCByZWN0ID0gc2Nyb2xsQ2FjaGUuY2xpZW50UmVjdDtcbiAgICAgICAgICAgIGxldCBsZWZ0RGlzdCA9IGxlZnQgLSByZWN0LmxlZnQ7XG4gICAgICAgICAgICBsZXQgcmlnaHREaXN0ID0gcmVjdC5yaWdodCAtIGxlZnQ7XG4gICAgICAgICAgICBsZXQgdG9wRGlzdCA9IHRvcCAtIHJlY3QudG9wO1xuICAgICAgICAgICAgbGV0IGJvdHRvbURpc3QgPSByZWN0LmJvdHRvbSAtIHRvcDtcbiAgICAgICAgICAgIC8vIGNvbXBsZXRlbHkgd2l0aGluIHRoZSByZWN0P1xuICAgICAgICAgICAgaWYgKGxlZnREaXN0ID49IDAgJiYgcmlnaHREaXN0ID49IDAgJiYgdG9wRGlzdCA+PSAwICYmIGJvdHRvbURpc3QgPj0gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0b3BEaXN0IDw9IGVkZ2VUaHJlc2hvbGQgJiYgdGhpcy5ldmVyTW92ZWRVcCAmJiBzY3JvbGxDYWNoZS5jYW5TY3JvbGxVcCgpICYmXG4gICAgICAgICAgICAgICAgICAgICghYmVzdFNpZGUgfHwgYmVzdFNpZGUuZGlzdGFuY2UgPiB0b3BEaXN0KSkge1xuICAgICAgICAgICAgICAgICAgICBiZXN0U2lkZSA9IHsgc2Nyb2xsQ2FjaGUsIG5hbWU6ICd0b3AnLCBkaXN0YW5jZTogdG9wRGlzdCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYm90dG9tRGlzdCA8PSBlZGdlVGhyZXNob2xkICYmIHRoaXMuZXZlck1vdmVkRG93biAmJiBzY3JvbGxDYWNoZS5jYW5TY3JvbGxEb3duKCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFiZXN0U2lkZSB8fCBiZXN0U2lkZS5kaXN0YW5jZSA+IGJvdHRvbURpc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RTaWRlID0geyBzY3JvbGxDYWNoZSwgbmFtZTogJ2JvdHRvbScsIGRpc3RhbmNlOiBib3R0b21EaXN0IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgVE9ETzogZml4IGJyb2tlbiBSVEwgc2Nyb2xsaW5nLiBjYW5TY3JvbGxMZWZ0IGFsd2F5cyByZXR1cm5pbmcgZmFsc2VcbiAgICAgICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vZnVsbGNhbGVuZGFyL2Z1bGxjYWxlbmRhci9pc3N1ZXMvNDgzN1xuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKGxlZnREaXN0IDw9IGVkZ2VUaHJlc2hvbGQgJiYgdGhpcy5ldmVyTW92ZWRMZWZ0ICYmIHNjcm9sbENhY2hlLmNhblNjcm9sbExlZnQoKSAmJlxuICAgICAgICAgICAgICAgICAgICAoIWJlc3RTaWRlIHx8IGJlc3RTaWRlLmRpc3RhbmNlID4gbGVmdERpc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RTaWRlID0geyBzY3JvbGxDYWNoZSwgbmFtZTogJ2xlZnQnLCBkaXN0YW5jZTogbGVmdERpc3QgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0RGlzdCA8PSBlZGdlVGhyZXNob2xkICYmIHRoaXMuZXZlck1vdmVkUmlnaHQgJiYgc2Nyb2xsQ2FjaGUuY2FuU2Nyb2xsUmlnaHQoKSAmJlxuICAgICAgICAgICAgICAgICAgICAoIWJlc3RTaWRlIHx8IGJlc3RTaWRlLmRpc3RhbmNlID4gcmlnaHREaXN0KSkge1xuICAgICAgICAgICAgICAgICAgICBiZXN0U2lkZSA9IHsgc2Nyb2xsQ2FjaGUsIG5hbWU6ICdyaWdodCcsIGRpc3RhbmNlOiByaWdodERpc3QgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJlc3RTaWRlO1xuICAgIH1cbiAgICBidWlsZENhY2hlcyhzY3JvbGxTdGFydEVsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5U2Nyb2xsRWxzKHNjcm9sbFN0YXJ0RWwpLm1hcCgoZWwpID0+IHtcbiAgICAgICAgICAgIGlmIChlbCA9PT0gd2luZG93KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBXaW5kb3dTY3JvbGxHZW9tQ2FjaGUoZmFsc2UpOyAvLyBmYWxzZSA9IGRvbid0IGxpc3RlbiB0byB1c2VyLWdlbmVyYXRlZCBzY3JvbGxzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVsZW1lbnRTY3JvbGxHZW9tQ2FjaGUoZWwsIGZhbHNlKTsgLy8gZmFsc2UgPSBkb24ndCBsaXN0ZW4gdG8gdXNlci1nZW5lcmF0ZWQgc2Nyb2xsc1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcXVlcnlTY3JvbGxFbHMoc2Nyb2xsU3RhcnRFbCkge1xuICAgICAgICBsZXQgZWxzID0gW107XG4gICAgICAgIGZvciAobGV0IHF1ZXJ5IG9mIHRoaXMuc2Nyb2xsUXVlcnkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcXVlcnkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgZWxzLnB1c2gocXVlcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICBUT0RPOiBpbiB0aGUgZnV0dXJlLCBhbHdheXMgaGF2ZSBhdXRvLXNjcm9sbCBoYXBwZW4gb24gZWxlbWVudCB3aGVyZSBjdXJyZW50IEhpdCBjYW1lIGZyb21cbiAgICAgICAgICAgICAgICBUaWNrZXQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9mdWxsY2FsZW5kYXIvZnVsbGNhbGVuZGFyL2lzc3Vlcy80NTkzXG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBlbHMucHVzaCguLi5BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChzY3JvbGxTdGFydEVsLmdldFJvb3ROb2RlKCkucXVlcnlTZWxlY3RvckFsbChxdWVyeSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxzO1xuICAgIH1cbn1cblxuLypcbk1vbml0b3JzIGRyYWdnaW5nIG9uIGFuIGVsZW1lbnQuIEhhcyBhIG51bWJlciBvZiBoaWdoLWxldmVsIGZlYXR1cmVzOlxuLSBtaW5pbXVtIGRpc3RhbmNlIHJlcXVpcmVkIGJlZm9yZSBkcmFnZ2luZ1xuLSBtaW5pbXVtIHdhaXQgdGltZSAoXCJkZWxheVwiKSBiZWZvcmUgZHJhZ2dpbmdcbi0gYSBtaXJyb3IgZWxlbWVudCB0aGF0IGZvbGxvd3MgdGhlIHBvaW50ZXJcbiovXG5jbGFzcyBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nIGV4dGVuZHMgRWxlbWVudERyYWdnaW5nIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXJFbCwgc2VsZWN0b3IpIHtcbiAgICAgICAgc3VwZXIoY29udGFpbmVyRWwpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lckVsID0gY29udGFpbmVyRWw7XG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCBjYW4gYmUgZGlyZWN0bHkgc2V0IGJ5IGNhbGxlclxuICAgICAgICAvLyB0aGUgY2FsbGVyIGNhbiBhbHNvIHNldCB0aGUgUG9pbnRlckRyYWdnaW5nJ3Mgb3B0aW9ucyBhcyB3ZWxsXG4gICAgICAgIHRoaXMuZGVsYXkgPSBudWxsO1xuICAgICAgICB0aGlzLm1pbkRpc3RhbmNlID0gMDtcbiAgICAgICAgdGhpcy50b3VjaFNjcm9sbEFsbG93ZWQgPSB0cnVlOyAvLyBwcmV2ZW50cyBkcmFnIGZyb20gc3RhcnRpbmcgYW5kIGJsb2NrcyBzY3JvbGxpbmcgZHVyaW5nIGRyYWdcbiAgICAgICAgdGhpcy5taXJyb3JOZWVkc1JldmVydCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzSW50ZXJhY3RpbmcgPSBmYWxzZTsgLy8gaXMgdGhlIHVzZXIgdmFsaWRseSBtb3ZpbmcgdGhlIHBvaW50ZXI/IGxhc3RzIHVudGlsIHBvaW50ZXJ1cFxuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTsgLy8gaXMgaXQgSU5URU5URlVMTFkgZHJhZ2dpbmc/IGxhc3RzIHVudGlsIGFmdGVyIHJldmVydCBhbmltYXRpb25cbiAgICAgICAgdGhpcy5pc0RlbGF5RW5kZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0Rpc3RhbmNlU3VycGFzc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVsYXlUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgICB0aGlzLm9uUG9pbnRlckRvd24gPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0RyYWdnaW5nKSB7IC8vIHNvIG5ldyBkcmFnIGRvZXNuJ3QgaGFwcGVuIHdoaWxlIHJldmVydCBhbmltYXRpb24gaXMgZ29pbmdcbiAgICAgICAgICAgICAgICB0aGlzLmlzSW50ZXJhY3RpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNEZWxheUVuZGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0Rpc3RhbmNlU3VycGFzc2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcHJldmVudFNlbGVjdGlvbihkb2N1bWVudC5ib2R5KTtcbiAgICAgICAgICAgICAgICBwcmV2ZW50Q29udGV4dE1lbnUoZG9jdW1lbnQuYm9keSk7XG4gICAgICAgICAgICAgICAgLy8gcHJldmVudCBsaW5rcyBmcm9tIGJlaW5nIHZpc2l0ZWQgaWYgdGhlcmUncyBhbiBldmVudHVhbCBkcmFnLlxuICAgICAgICAgICAgICAgIC8vIGFsc28gcHJldmVudHMgc2VsZWN0aW9uIGluIG9sZGVyIGJyb3dzZXJzIChtYXliZT8pLlxuICAgICAgICAgICAgICAgIC8vIG5vdCBuZWNlc3NhcnkgZm9yIHRvdWNoLCBiZXNpZGVzLCBicm93c2VyIHdvdWxkIGNvbXBsYWluIGFib3V0IHBhc3NpdmVuZXNzLlxuICAgICAgICAgICAgICAgIGlmICghZXYuaXNUb3VjaCkge1xuICAgICAgICAgICAgICAgICAgICBldi5vcmlnRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJkb3duJywgZXYpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzSW50ZXJhY3RpbmcgJiYgLy8gbm90IGRlc3Ryb3llZCB2aWEgcG9pbnRlcmRvd24gaGFuZGxlclxuICAgICAgICAgICAgICAgICAgICAhdGhpcy5wb2ludGVyLnNob3VsZElnbm9yZU1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWN0aW9ucyByZWxhdGVkIHRvIGluaXRpYXRpbmcgZHJhZ3N0YXJ0K2RyYWdtb3ZlK2RyYWdlbmQuLi5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5taXJyb3Iuc2V0SXNWaXNpYmxlKGZhbHNlKTsgLy8gcmVzZXQuIGNhbGxlciBtdXN0IHNldC12aXNpYmxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWlycm9yLnN0YXJ0KGV2LnN1YmplY3RFbCwgZXYucGFnZVgsIGV2LnBhZ2VZKTsgLy8gbXVzdCBoYXBwZW4gb24gZmlyc3QgcG9pbnRlciBkb3duXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnREZWxheShldik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5taW5EaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXN0YW5jZVN1cnBhc3NlZChldik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25Qb2ludGVyTW92ZSA9IChldikgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNJbnRlcmFjdGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVybW92ZScsIGV2KTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNEaXN0YW5jZVN1cnBhc3NlZCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWluRGlzdGFuY2UgPSB0aGlzLm1pbkRpc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGlzdGFuY2VTcTsgLy8gY3VycmVudCBkaXN0YW5jZSBmcm9tIHRoZSBvcmlnaW4sIHNxdWFyZWRcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgZGVsdGFYLCBkZWx0YVkgfSA9IGV2O1xuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZVNxID0gZGVsdGFYICogZGVsdGFYICsgZGVsdGFZICogZGVsdGFZO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2VTcSA+PSBtaW5EaXN0YW5jZSAqIG1pbkRpc3RhbmNlKSB7IC8vIHVzZSBweXRoYWdvcmVhbiB0aGVvcmVtXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZURpc3RhbmNlU3VycGFzc2VkKGV2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGEgcmVhbCBwb2ludGVyIG1vdmU/IChub3Qgb25lIHNpbXVsYXRlZCBieSBzY3JvbGxpbmcpXG4gICAgICAgICAgICAgICAgICAgIGlmIChldi5vcmlnRXZlbnQudHlwZSAhPT0gJ3Njcm9sbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWlycm9yLmhhbmRsZU1vdmUoZXYucGFnZVgsIGV2LnBhZ2VZKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXV0b1Njcm9sbGVyLmhhbmRsZU1vdmUoZXYucGFnZVgsIGV2LnBhZ2VZKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcignZHJhZ21vdmUnLCBldik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uUG9pbnRlclVwID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0ludGVyYWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0ludGVyYWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYWxsb3dTZWxlY3Rpb24oZG9jdW1lbnQuYm9keSk7XG4gICAgICAgICAgICAgICAgYWxsb3dDb250ZXh0TWVudShkb2N1bWVudC5ib2R5KTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcnVwJywgZXYpOyAvLyBjYW4gcG90ZW50aWFsbHkgc2V0IG1pcnJvck5lZWRzUmV2ZXJ0XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF1dG9TY3JvbGxlci5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJ5U3RvcERyYWcoZXYpOyAvLyB3aGljaCB3aWxsIHN0b3AgdGhlIG1pcnJvclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWxheVRpbWVvdXRJZCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kZWxheVRpbWVvdXRJZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsYXlUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHBvaW50ZXIgPSB0aGlzLnBvaW50ZXIgPSBuZXcgUG9pbnRlckRyYWdnaW5nKGNvbnRhaW5lckVsKTtcbiAgICAgICAgcG9pbnRlci5lbWl0dGVyLm9uKCdwb2ludGVyZG93bicsIHRoaXMub25Qb2ludGVyRG93bik7XG4gICAgICAgIHBvaW50ZXIuZW1pdHRlci5vbigncG9pbnRlcm1vdmUnLCB0aGlzLm9uUG9pbnRlck1vdmUpO1xuICAgICAgICBwb2ludGVyLmVtaXR0ZXIub24oJ3BvaW50ZXJ1cCcsIHRoaXMub25Qb2ludGVyVXApO1xuICAgICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHBvaW50ZXIuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1pcnJvciA9IG5ldyBFbGVtZW50TWlycm9yKCk7XG4gICAgICAgIHRoaXMuYXV0b1Njcm9sbGVyID0gbmV3IEF1dG9TY3JvbGxlcigpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnBvaW50ZXIuZGVzdHJveSgpO1xuICAgICAgICAvLyBIQUNLOiBzaW11bGF0ZSBhIHBvaW50ZXItdXAgdG8gZW5kIHRoZSBjdXJyZW50IGRyYWdcbiAgICAgICAgLy8gVE9ETzogZmlyZSAnZHJhZ2VuZCcgZGlyZWN0bHkgYW5kIHN0b3AgaW50ZXJhY3Rpb24uIGRpc2NvdXJhZ2UgdXNlIG9mIHBvaW50ZXJ1cCBldmVudCAoYi9jIG1pZ2h0IG5vdCBmaXJlKVxuICAgICAgICB0aGlzLm9uUG9pbnRlclVwKHt9KTtcbiAgICB9XG4gICAgc3RhcnREZWxheShldikge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZGVsYXkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGF5VGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxheVRpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVEZWxheUVuZChldik7XG4gICAgICAgICAgICB9LCB0aGlzLmRlbGF5KTsgLy8gbm90IGFzc2lnbmFibGUgdG8gbnVtYmVyIVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVEZWxheUVuZChldik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlRGVsYXlFbmQoZXYpIHtcbiAgICAgICAgdGhpcy5pc0RlbGF5RW5kZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnRyeVN0YXJ0RHJhZyhldik7XG4gICAgfVxuICAgIGhhbmRsZURpc3RhbmNlU3VycGFzc2VkKGV2KSB7XG4gICAgICAgIHRoaXMuaXNEaXN0YW5jZVN1cnBhc3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMudHJ5U3RhcnREcmFnKGV2KTtcbiAgICB9XG4gICAgdHJ5U3RhcnREcmFnKGV2KSB7XG4gICAgICAgIGlmICh0aGlzLmlzRGVsYXlFbmRlZCAmJiB0aGlzLmlzRGlzdGFuY2VTdXJwYXNzZWQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5wb2ludGVyLndhc1RvdWNoU2Nyb2xsIHx8IHRoaXMudG91Y2hTY3JvbGxBbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm1pcnJvck5lZWRzUmV2ZXJ0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5hdXRvU2Nyb2xsZXIuc3RhcnQoZXYucGFnZVgsIGV2LnBhZ2VZLCB0aGlzLmNvbnRhaW5lckVsKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcignZHJhZ3N0YXJ0JywgZXYpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRvdWNoU2Nyb2xsQWxsb3dlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2ludGVyLmNhbmNlbFRvdWNoU2Nyb2xsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRyeVN0b3BEcmFnKGV2KSB7XG4gICAgICAgIC8vIC5zdG9wKCkgaXMgQUxXQVlTIGFzeW5jaHJvbm91cywgd2hpY2ggd2UgTkVFRCBiZWNhdXNlIHdlIHdhbnQgYWxsIHBvaW50ZXJ1cCBldmVudHNcbiAgICAgICAgLy8gdGhhdCBjb21lIGZyb20gdGhlIGRvY3VtZW50IHRvIGZpcmUgYmVmb3JlaGFuZC4gbXVjaCBtb3JlIGNvbnZlbmllbnQgdGhpcyB3YXkuXG4gICAgICAgIHRoaXMubWlycm9yLnN0b3AodGhpcy5taXJyb3JOZWVkc1JldmVydCwgdGhpcy5zdG9wRHJhZy5iaW5kKHRoaXMsIGV2KSk7XG4gICAgfVxuICAgIHN0b3BEcmFnKGV2KSB7XG4gICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcignZHJhZ2VuZCcsIGV2KTtcbiAgICB9XG4gICAgLy8gZmlsbCBpbiB0aGUgaW1wbGVtZW50YXRpb25zLi4uXG4gICAgc2V0SWdub3JlTW92ZShib29sKSB7XG4gICAgICAgIHRoaXMucG9pbnRlci5zaG91bGRJZ25vcmVNb3ZlID0gYm9vbDtcbiAgICB9XG4gICAgc2V0TWlycm9ySXNWaXNpYmxlKGJvb2wpIHtcbiAgICAgICAgdGhpcy5taXJyb3Iuc2V0SXNWaXNpYmxlKGJvb2wpO1xuICAgIH1cbiAgICBzZXRNaXJyb3JOZWVkc1JldmVydChib29sKSB7XG4gICAgICAgIHRoaXMubWlycm9yTmVlZHNSZXZlcnQgPSBib29sO1xuICAgIH1cbiAgICBzZXRBdXRvU2Nyb2xsRW5hYmxlZChib29sKSB7XG4gICAgICAgIHRoaXMuYXV0b1Njcm9sbGVyLmlzRW5hYmxlZCA9IGJvb2w7XG4gICAgfVxufVxuXG4vKlxuV2hlbiB0aGlzIGNsYXNzIGlzIGluc3RhbnRpYXRlZCwgaXQgcmVjb3JkcyB0aGUgb2Zmc2V0IG9mIGFuIGVsZW1lbnQgKHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudCB0b3BsZWZ0KSxcbmFuZCBjb250aW51ZXMgdG8gbW9uaXRvciBzY3JvbGxpbmcsIHVwZGF0aW5nIHRoZSBjYWNoZWQgY29vcmRpbmF0ZXMgaWYgaXQgbmVlZHMgdG8uXG5Eb2VzIG5vdCBhY2Nlc3MgdGhlIERPTSBhZnRlciBpbnN0YW50aWF0aW9uLCBzbyBoaWdobHkgcGVyZm9ybWFudC5cblxuQWxzbyBrZWVwcyB0cmFjayBvZiBhbGwgc2Nyb2xsaW5nL292ZXJmbG93OmhpZGRlbiBjb250YWluZXJzIHRoYXQgYXJlIHBhcmVudHMgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbmFuZCBhbiBkZXRlcm1pbmUgaWYgYSBnaXZlbiBwb2ludCBpcyBpbnNpZGUgdGhlIGNvbWJpbmVkIGNsaXBwaW5nIHJlY3RhbmdsZS5cbiovXG5jbGFzcyBPZmZzZXRUcmFja2VyIHtcbiAgICBjb25zdHJ1Y3RvcihlbCkge1xuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMub3JpZ1JlY3QgPSBjb21wdXRlUmVjdChlbCk7XG4gICAgICAgIC8vIHdpbGwgd29yayBmaW5lIGZvciBkaXZzIHRoYXQgaGF2ZSBvdmVyZmxvdzpoaWRkZW5cbiAgICAgICAgdGhpcy5zY3JvbGxDYWNoZXMgPSBnZXRDbGlwcGluZ1BhcmVudHMoZWwpLm1hcCgoc2Nyb2xsRWwpID0+IG5ldyBFbGVtZW50U2Nyb2xsR2VvbUNhY2hlKHNjcm9sbEVsLCB0cnVlKSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGZvciAobGV0IHNjcm9sbENhY2hlIG9mIHRoaXMuc2Nyb2xsQ2FjaGVzKSB7XG4gICAgICAgICAgICBzY3JvbGxDYWNoZS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcHV0ZUxlZnQoKSB7XG4gICAgICAgIGxldCBsZWZ0ID0gdGhpcy5vcmlnUmVjdC5sZWZ0O1xuICAgICAgICBmb3IgKGxldCBzY3JvbGxDYWNoZSBvZiB0aGlzLnNjcm9sbENhY2hlcykge1xuICAgICAgICAgICAgbGVmdCArPSBzY3JvbGxDYWNoZS5vcmlnU2Nyb2xsTGVmdCAtIHNjcm9sbENhY2hlLmdldFNjcm9sbExlZnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGVmdDtcbiAgICB9XG4gICAgY29tcHV0ZVRvcCgpIHtcbiAgICAgICAgbGV0IHRvcCA9IHRoaXMub3JpZ1JlY3QudG9wO1xuICAgICAgICBmb3IgKGxldCBzY3JvbGxDYWNoZSBvZiB0aGlzLnNjcm9sbENhY2hlcykge1xuICAgICAgICAgICAgdG9wICs9IHNjcm9sbENhY2hlLm9yaWdTY3JvbGxUb3AgLSBzY3JvbGxDYWNoZS5nZXRTY3JvbGxUb3AoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9wO1xuICAgIH1cbiAgICBpc1dpdGhpbkNsaXBwaW5nKHBhZ2VYLCBwYWdlWSkge1xuICAgICAgICBsZXQgcG9pbnQgPSB7IGxlZnQ6IHBhZ2VYLCB0b3A6IHBhZ2VZIH07XG4gICAgICAgIGZvciAobGV0IHNjcm9sbENhY2hlIG9mIHRoaXMuc2Nyb2xsQ2FjaGVzKSB7XG4gICAgICAgICAgICBpZiAoIWlzSWdub3JlZENsaXBwaW5nKHNjcm9sbENhY2hlLmdldEV2ZW50VGFyZ2V0KCkpICYmXG4gICAgICAgICAgICAgICAgIXBvaW50SW5zaWRlUmVjdChwb2ludCwgc2Nyb2xsQ2FjaGUuY2xpZW50UmVjdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuLy8gY2VydGFpbiBjbGlwcGluZyBjb250YWluZXJzIHNob3VsZCBuZXZlciBjb25zdHJhaW4gaW50ZXJhY3Rpb25zLCBsaWtlIDxodG1sPiBhbmQgPGJvZHk+XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZnVsbGNhbGVuZGFyL2Z1bGxjYWxlbmRhci9pc3N1ZXMvMzYxNVxuZnVuY3Rpb24gaXNJZ25vcmVkQ2xpcHBpbmcobm9kZSkge1xuICAgIGxldCB0YWdOYW1lID0gbm9kZS50YWdOYW1lO1xuICAgIHJldHVybiB0YWdOYW1lID09PSAnSFRNTCcgfHwgdGFnTmFtZSA9PT0gJ0JPRFknO1xufVxuXG4vKlxuVHJhY2tzIG1vdmVtZW50IG92ZXIgbXVsdGlwbGUgZHJvcHBhYmxlIGFyZWFzIChha2EgXCJoaXRzXCIpXG50aGF0IGV4aXN0IGluIG9uZSBvciBtb3JlIERhdGVDb21wb25lbnRzLlxuUmVsaWVzIG9uIGFuIGV4aXN0aW5nIGRyYWdnYWJsZS5cblxuZW1pdHM6XG4tIHBvaW50ZXJkb3duXG4tIGRyYWdzdGFydFxuLSBoaXRjaGFuZ2UgLSBmaXJlcyBpbml0aWFsbHksIGV2ZW4gaWYgbm90IG92ZXIgYSBoaXRcbi0gcG9pbnRlcnVwXG4tIChoaXRjaGFuZ2UgLSBhZ2FpbiwgdG8gbnVsbCwgaWYgZW5kZWQgb3ZlciBhIGhpdClcbi0gZHJhZ2VuZFxuKi9cbmNsYXNzIEhpdERyYWdnaW5nIHtcbiAgICBjb25zdHJ1Y3RvcihkcmFnZ2luZywgZHJvcHBhYmxlU3RvcmUpIHtcbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IGNhbiBiZSBzZXQgYnkgY2FsbGVyXG4gICAgICAgIHRoaXMudXNlU3ViamVjdENlbnRlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlcXVpcmVJbml0aWFsID0gdHJ1ZTsgLy8gaWYgZG9lc24ndCBzdGFydCBvdXQgb24gYSBoaXQsIHdvbid0IGVtaXQgYW55IGV2ZW50c1xuICAgICAgICB0aGlzLmRpc2FibGVQb2ludENoZWNrID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaW5pdGlhbEhpdCA9IG51bGw7XG4gICAgICAgIHRoaXMubW92aW5nSGl0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5maW5hbEhpdCA9IG51bGw7IC8vIHdvbid0IGV2ZXIgYmUgcG9wdWxhdGVkIGlmIHNob3VsZElnbm9yZU1vdmVcbiAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyRG93biA9IChldikgPT4ge1xuICAgICAgICAgICAgbGV0IHsgZHJhZ2dpbmcgfSA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxIaXQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5tb3ZpbmdIaXQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5maW5hbEhpdCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnByZXBhcmVIaXRzKCk7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NGaXJzdENvb3JkKGV2KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmluaXRpYWxIaXQgfHwgIXRoaXMucmVxdWlyZUluaXRpYWwpIHtcbiAgICAgICAgICAgICAgICBkcmFnZ2luZy5zZXRJZ25vcmVNb3ZlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBmaXJlIHRoaXMgYmVmb3JlIGNvbXB1dGluZyBwcm9jZXNzRmlyc3RDb29yZCwgc28gbGlzdGVuZXJzIGNhbiBjYW5jZWwuIHRoaXMgZ2V0cyBmaXJlZCBieSBhbG1vc3QgZXZlcnkgaGFuZGxlciA6KFxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVyZG93bicsIGV2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRyYWdnaW5nLnNldElnbm9yZU1vdmUodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0ID0gKGV2KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcignZHJhZ3N0YXJ0JywgZXYpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVNb3ZlKGV2LCB0cnVlKTsgLy8gZm9yY2UgPSBmaXJlIGV2ZW4gaWYgaW5pdGlhbGx5IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVEcmFnTW92ZSA9IChldikgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2RyYWdtb3ZlJywgZXYpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVNb3ZlKGV2KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyVXAgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVsZWFzZUhpdHMoKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVydXAnLCBldik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlRHJhZ0VuZCA9IChldikgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMubW92aW5nSGl0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2hpdHVwZGF0ZScsIG51bGwsIHRydWUsIGV2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZmluYWxIaXQgPSB0aGlzLm1vdmluZ0hpdDtcbiAgICAgICAgICAgIHRoaXMubW92aW5nSGl0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdkcmFnZW5kJywgZXYpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRyb3BwYWJsZVN0b3JlID0gZHJvcHBhYmxlU3RvcmU7XG4gICAgICAgIGRyYWdnaW5nLmVtaXR0ZXIub24oJ3BvaW50ZXJkb3duJywgdGhpcy5oYW5kbGVQb2ludGVyRG93bik7XG4gICAgICAgIGRyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdzdGFydCcsIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0KTtcbiAgICAgICAgZHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ21vdmUnLCB0aGlzLmhhbmRsZURyYWdNb3ZlKTtcbiAgICAgICAgZHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcnVwJywgdGhpcy5oYW5kbGVQb2ludGVyVXApO1xuICAgICAgICBkcmFnZ2luZy5lbWl0dGVyLm9uKCdkcmFnZW5kJywgdGhpcy5oYW5kbGVEcmFnRW5kKTtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGRyYWdnaW5nO1xuICAgICAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xuICAgIH1cbiAgICAvLyBzZXRzIGluaXRpYWxIaXRcbiAgICAvLyBzZXRzIGNvb3JkQWRqdXN0XG4gICAgcHJvY2Vzc0ZpcnN0Q29vcmQoZXYpIHtcbiAgICAgICAgbGV0IG9yaWdQb2ludCA9IHsgbGVmdDogZXYucGFnZVgsIHRvcDogZXYucGFnZVkgfTtcbiAgICAgICAgbGV0IGFkanVzdGVkUG9pbnQgPSBvcmlnUG9pbnQ7XG4gICAgICAgIGxldCBzdWJqZWN0RWwgPSBldi5zdWJqZWN0RWw7XG4gICAgICAgIGxldCBzdWJqZWN0UmVjdDtcbiAgICAgICAgaWYgKHN1YmplY3RFbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7IC8vIGkuZS4gbm90IGEgRG9jdW1lbnQvU2hhZG93Um9vdFxuICAgICAgICAgICAgc3ViamVjdFJlY3QgPSBjb21wdXRlUmVjdChzdWJqZWN0RWwpO1xuICAgICAgICAgICAgYWRqdXN0ZWRQb2ludCA9IGNvbnN0cmFpblBvaW50KGFkanVzdGVkUG9pbnQsIHN1YmplY3RSZWN0KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5pdGlhbEhpdCA9IHRoaXMuaW5pdGlhbEhpdCA9IHRoaXMucXVlcnlIaXRGb3JPZmZzZXQoYWRqdXN0ZWRQb2ludC5sZWZ0LCBhZGp1c3RlZFBvaW50LnRvcCk7XG4gICAgICAgIGlmIChpbml0aWFsSGl0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy51c2VTdWJqZWN0Q2VudGVyICYmIHN1YmplY3RSZWN0KSB7XG4gICAgICAgICAgICAgICAgbGV0IHNsaWNlZFN1YmplY3RSZWN0ID0gaW50ZXJzZWN0UmVjdHMoc3ViamVjdFJlY3QsIGluaXRpYWxIaXQucmVjdCk7XG4gICAgICAgICAgICAgICAgaWYgKHNsaWNlZFN1YmplY3RSZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGFkanVzdGVkUG9pbnQgPSBnZXRSZWN0Q2VudGVyKHNsaWNlZFN1YmplY3RSZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvb3JkQWRqdXN0ID0gZGlmZlBvaW50cyhhZGp1c3RlZFBvaW50LCBvcmlnUG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb29yZEFkanVzdCA9IHsgbGVmdDogMCwgdG9wOiAwIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlTW92ZShldiwgZm9yY2VIYW5kbGUpIHtcbiAgICAgICAgbGV0IGhpdCA9IHRoaXMucXVlcnlIaXRGb3JPZmZzZXQoZXYucGFnZVggKyB0aGlzLmNvb3JkQWRqdXN0LmxlZnQsIGV2LnBhZ2VZICsgdGhpcy5jb29yZEFkanVzdC50b3ApO1xuICAgICAgICBpZiAoZm9yY2VIYW5kbGUgfHwgIWlzSGl0c0VxdWFsKHRoaXMubW92aW5nSGl0LCBoaXQpKSB7XG4gICAgICAgICAgICB0aGlzLm1vdmluZ0hpdCA9IGhpdDtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdoaXR1cGRhdGUnLCBoaXQsIGZhbHNlLCBldik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJlcGFyZUhpdHMoKSB7XG4gICAgICAgIHRoaXMub2Zmc2V0VHJhY2tlcnMgPSBtYXBIYXNoKHRoaXMuZHJvcHBhYmxlU3RvcmUsIChpbnRlcmFjdGlvblNldHRpbmdzKSA9PiB7XG4gICAgICAgICAgICBpbnRlcmFjdGlvblNldHRpbmdzLmNvbXBvbmVudC5wcmVwYXJlSGl0cygpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBPZmZzZXRUcmFja2VyKGludGVyYWN0aW9uU2V0dGluZ3MuZWwpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVsZWFzZUhpdHMoKSB7XG4gICAgICAgIGxldCB7IG9mZnNldFRyYWNrZXJzIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpZCBpbiBvZmZzZXRUcmFja2Vycykge1xuICAgICAgICAgICAgb2Zmc2V0VHJhY2tlcnNbaWRdLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9mZnNldFRyYWNrZXJzID0ge307XG4gICAgfVxuICAgIHF1ZXJ5SGl0Rm9yT2Zmc2V0KG9mZnNldExlZnQsIG9mZnNldFRvcCkge1xuICAgICAgICBsZXQgeyBkcm9wcGFibGVTdG9yZSwgb2Zmc2V0VHJhY2tlcnMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBiZXN0SGl0ID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaWQgaW4gZHJvcHBhYmxlU3RvcmUpIHtcbiAgICAgICAgICAgIGxldCBjb21wb25lbnQgPSBkcm9wcGFibGVTdG9yZVtpZF0uY29tcG9uZW50O1xuICAgICAgICAgICAgbGV0IG9mZnNldFRyYWNrZXIgPSBvZmZzZXRUcmFja2Vyc1tpZF07XG4gICAgICAgICAgICBpZiAob2Zmc2V0VHJhY2tlciAmJiAvLyB3YXNuJ3QgZGVzdHJveWVkIG1pZC1kcmFnXG4gICAgICAgICAgICAgICAgb2Zmc2V0VHJhY2tlci5pc1dpdGhpbkNsaXBwaW5nKG9mZnNldExlZnQsIG9mZnNldFRvcCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgb3JpZ2luTGVmdCA9IG9mZnNldFRyYWNrZXIuY29tcHV0ZUxlZnQoKTtcbiAgICAgICAgICAgICAgICBsZXQgb3JpZ2luVG9wID0gb2Zmc2V0VHJhY2tlci5jb21wdXRlVG9wKCk7XG4gICAgICAgICAgICAgICAgbGV0IHBvc2l0aW9uTGVmdCA9IG9mZnNldExlZnQgLSBvcmlnaW5MZWZ0O1xuICAgICAgICAgICAgICAgIGxldCBwb3NpdGlvblRvcCA9IG9mZnNldFRvcCAtIG9yaWdpblRvcDtcbiAgICAgICAgICAgICAgICBsZXQgeyBvcmlnUmVjdCB9ID0gb2Zmc2V0VHJhY2tlcjtcbiAgICAgICAgICAgICAgICBsZXQgd2lkdGggPSBvcmlnUmVjdC5yaWdodCAtIG9yaWdSZWN0LmxlZnQ7XG4gICAgICAgICAgICAgICAgbGV0IGhlaWdodCA9IG9yaWdSZWN0LmJvdHRvbSAtIG9yaWdSZWN0LnRvcDtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgLy8gbXVzdCBiZSB3aXRoaW4gdGhlIGVsZW1lbnQncyBib3VuZHNcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkxlZnQgPj0gMCAmJiBwb3NpdGlvbkxlZnQgPCB3aWR0aCAmJlxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvblRvcCA+PSAwICYmIHBvc2l0aW9uVG9wIDwgaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBoaXQgPSBjb21wb25lbnQucXVlcnlIaXQocG9zaXRpb25MZWZ0LCBwb3NpdGlvblRvcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoaXQgJiYgKFxuICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIGhpdCBpcyB3aXRoaW4gYWN0aXZlUmFuZ2UsIG1lYW5pbmcgaXQncyBub3QgYSBkZWFkIGNlbGxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VDb250YWluc1JhbmdlKGhpdC5kYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgaGl0LmRhdGVTcGFuLnJhbmdlKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSB0aGUgY29tcG9uZW50IHdlIGFyZSBxdWVyeWluZyBmb3IgdGhlIGhpdCBpcyBhY2Nlc3NpYmx5IG15IHRoZSBwb2ludGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50cyBvYnNjdXJlZCBjYWxlbmRhcnMgKGV4OiB1bmRlciBhIG1vZGFsIGRpYWxvZykgZnJvbSBhY2NlcHRpbmcgaGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZnVsbGNhbGVuZGFyL2Z1bGxjYWxlbmRhci9pc3N1ZXMvNTAyNlxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuZGlzYWJsZVBvaW50Q2hlY2sgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRUcmFja2VyLmVsLmNvbnRhaW5zKG9mZnNldFRyYWNrZXIuZWwuZ2V0Um9vdE5vZGUoKS5lbGVtZW50RnJvbVBvaW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZC1iYWNrIG9yaWdpbnMgdG8gZ2V0IGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdG9wLWxlZnQgb2Ygd2luZG93IHZpZXdwb3J0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25MZWZ0ICsgb3JpZ2luTGVmdCAtIHdpbmRvdy5zY3JvbGxYLCBwb3NpdGlvblRvcCArIG9yaWdpblRvcCAtIHdpbmRvdy5zY3JvbGxZKSkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoIWJlc3RIaXQgfHwgaGl0LmxheWVyID4gYmVzdEhpdC5sYXllcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdC5jb21wb25lbnRJZCA9IGlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGl0LmNvbnRleHQgPSBjb21wb25lbnQuY29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGJldHRlciB3YXkgdG8gcmUtb3JpZW50IHJlY3RhbmdsZVxuICAgICAgICAgICAgICAgICAgICAgICAgaGl0LnJlY3QubGVmdCArPSBvcmlnaW5MZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaGl0LnJlY3QucmlnaHQgKz0gb3JpZ2luTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdC5yZWN0LnRvcCArPSBvcmlnaW5Ub3A7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaXQucmVjdC5ib3R0b20gKz0gb3JpZ2luVG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdEhpdCA9IGhpdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmVzdEhpdDtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0hpdHNFcXVhbChoaXQwLCBoaXQxKSB7XG4gICAgaWYgKCFoaXQwICYmICFoaXQxKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoQm9vbGVhbihoaXQwKSAhPT0gQm9vbGVhbihoaXQxKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBpc0RhdGVTcGFuc0VxdWFsKGhpdDAuZGF0ZVNwYW4sIGhpdDEuZGF0ZVNwYW4pO1xufVxuXG5mdW5jdGlvbiBidWlsZERhdGVQb2ludEFwaVdpdGhDb250ZXh0KGRhdGVTcGFuLCBjb250ZXh0KSB7XG4gICAgbGV0IHByb3BzID0ge307XG4gICAgZm9yIChsZXQgdHJhbnNmb3JtIG9mIGNvbnRleHQucGx1Z2luSG9va3MuZGF0ZVBvaW50VHJhbnNmb3Jtcykge1xuICAgICAgICBPYmplY3QuYXNzaWduKHByb3BzLCB0cmFuc2Zvcm0oZGF0ZVNwYW4sIGNvbnRleHQpKTtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbihwcm9wcywgYnVpbGREYXRlUG9pbnRBcGkoZGF0ZVNwYW4sIGNvbnRleHQuZGF0ZUVudikpO1xuICAgIHJldHVybiBwcm9wcztcbn1cbmZ1bmN0aW9uIGJ1aWxkRGF0ZVBvaW50QXBpKHNwYW4sIGRhdGVFbnYpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBkYXRlOiBkYXRlRW52LnRvRGF0ZShzcGFuLnJhbmdlLnN0YXJ0KSxcbiAgICAgICAgZGF0ZVN0cjogZGF0ZUVudi5mb3JtYXRJc28oc3Bhbi5yYW5nZS5zdGFydCwgeyBvbWl0VGltZTogc3Bhbi5hbGxEYXkgfSksXG4gICAgICAgIGFsbERheTogc3Bhbi5hbGxEYXksXG4gICAgfTtcbn1cblxuLypcbk1vbml0b3JzIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIGEgc3BlY2lmaWMgZGF0ZS90aW1lIG9mIGEgY29tcG9uZW50LlxuQSBwb2ludGVyZG93bitwb2ludGVydXAgb24gdGhlIHNhbWUgXCJoaXRcIiBjb25zdGl0dXRlcyBhIGNsaWNrLlxuKi9cbmNsYXNzIERhdGVDbGlja2luZyBleHRlbmRzIEludGVyYWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgICAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlckRvd24gPSAocGV2KSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBkcmFnZ2luZyB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCBkb3duRWwgPSBwZXYub3JpZ0V2ZW50LnRhcmdldDtcbiAgICAgICAgICAgIC8vIGRvIHRoaXMgaW4gcG9pbnRlcmRvd24gKG5vdCBkcmFnZW5kKSBiZWNhdXNlIERPTSBtaWdodCBiZSBtdXRhdGVkIGJ5IHRoZSB0aW1lIGRyYWdlbmQgaXMgZmlyZWRcbiAgICAgICAgICAgIGRyYWdnaW5nLnNldElnbm9yZU1vdmUoIXRoaXMuY29tcG9uZW50LmlzVmFsaWREYXRlRG93bkVsKGRvd25FbCkpO1xuICAgICAgICB9O1xuICAgICAgICAvLyB3b24ndCBldmVuIGZpcmUgaWYgbW92aW5nIHdhcyBpZ25vcmVkXG4gICAgICAgIHRoaXMuaGFuZGxlRHJhZ0VuZCA9IChldikgPT4ge1xuICAgICAgICAgICAgbGV0IHsgY29tcG9uZW50IH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IHsgcG9pbnRlciB9ID0gdGhpcy5kcmFnZ2luZztcbiAgICAgICAgICAgIGlmICghcG9pbnRlci53YXNUb3VjaFNjcm9sbCkge1xuICAgICAgICAgICAgICAgIGxldCB7IGluaXRpYWxIaXQsIGZpbmFsSGl0IH0gPSB0aGlzLmhpdERyYWdnaW5nO1xuICAgICAgICAgICAgICAgIGlmIChpbml0aWFsSGl0ICYmIGZpbmFsSGl0ICYmIGlzSGl0c0VxdWFsKGluaXRpYWxIaXQsIGZpbmFsSGl0KSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeyBjb250ZXh0IH0gPSBjb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhcmcgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJ1aWxkRGF0ZVBvaW50QXBpV2l0aENvbnRleHQoaW5pdGlhbEhpdC5kYXRlU3BhbiwgY29udGV4dCkpLCB7IGRheUVsOiBpbml0aWFsSGl0LmRheUVsLCBqc0V2ZW50OiBldi5vcmlnRXZlbnQsIHZpZXc6IGNvbnRleHQudmlld0FwaSB8fCBjb250ZXh0LmNhbGVuZGFyQXBpLnZpZXcgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdkYXRlQ2xpY2snLCBhcmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gd2UgRE8gd2FudCB0byB3YXRjaCBwb2ludGVyIG1vdmVzIGJlY2F1c2Ugb3RoZXJ3aXNlIGZpbmFsSGl0IHdvbid0IGdldCBwb3B1bGF0ZWRcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IG5ldyBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nKHNldHRpbmdzLmVsKTtcbiAgICAgICAgdGhpcy5kcmFnZ2luZy5hdXRvU2Nyb2xsZXIuaXNFbmFibGVkID0gZmFsc2U7XG4gICAgICAgIGxldCBoaXREcmFnZ2luZyA9IHRoaXMuaGl0RHJhZ2dpbmcgPSBuZXcgSGl0RHJhZ2dpbmcodGhpcy5kcmFnZ2luZywgaW50ZXJhY3Rpb25TZXR0aW5nc1RvU3RvcmUoc2V0dGluZ3MpKTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCB0aGlzLmhhbmRsZVBvaW50ZXJEb3duKTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ2VuZCcsIHRoaXMuaGFuZGxlRHJhZ0VuZCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcuZGVzdHJveSgpO1xuICAgIH1cbn1cblxuLypcblRyYWNrcyB3aGVuIHRoZSB1c2VyIHNlbGVjdHMgYSBwb3J0aW9uIG9mIHRpbWUgb2YgYSBjb21wb25lbnQsXG5jb25zdGl0dXRlZCBieSBhIGRyYWcgb3ZlciBkYXRlIGNlbGxzLCB3aXRoIGEgcG9zc2libGUgZGVsYXkgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgZHJhZy5cbiovXG5jbGFzcyBEYXRlU2VsZWN0aW5nIGV4dGVuZHMgSW50ZXJhY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICAgICAgdGhpcy5kcmFnU2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyRG93biA9IChldikgPT4ge1xuICAgICAgICAgICAgbGV0IHsgY29tcG9uZW50LCBkcmFnZ2luZyB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbXBvbmVudC5jb250ZXh0O1xuICAgICAgICAgICAgbGV0IGNhblNlbGVjdCA9IG9wdGlvbnMuc2VsZWN0YWJsZSAmJlxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5pc1ZhbGlkRGF0ZURvd25FbChldi5vcmlnRXZlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgIC8vIGRvbid0IGJvdGhlciB0byB3YXRjaCBleHBlbnNpdmUgbW92ZXMgaWYgY29tcG9uZW50IHdvbid0IGRvIHNlbGVjdGlvblxuICAgICAgICAgICAgZHJhZ2dpbmcuc2V0SWdub3JlTW92ZSghY2FuU2VsZWN0KTtcbiAgICAgICAgICAgIC8vIGlmIHRvdWNoLCByZXF1aXJlIHVzZXIgdG8gaG9sZCBkb3duXG4gICAgICAgICAgICBkcmFnZ2luZy5kZWxheSA9IGV2LmlzVG91Y2ggPyBnZXRDb21wb25lbnRUb3VjaERlbGF5JDEoY29tcG9uZW50KSA6IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0ID0gKGV2KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudC5jb250ZXh0LmNhbGVuZGFyQXBpLnVuc2VsZWN0KGV2KTsgLy8gdW5zZWxlY3QgcHJldmlvdXMgc2VsZWN0aW9uc1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUhpdFVwZGF0ZSA9IChoaXQsIGlzRmluYWwpID0+IHtcbiAgICAgICAgICAgIGxldCB7IGNvbnRleHQgfSA9IHRoaXMuY29tcG9uZW50O1xuICAgICAgICAgICAgbGV0IGRyYWdTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgbGV0IGlzSW52YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGhpdCkge1xuICAgICAgICAgICAgICAgIGxldCBpbml0aWFsSGl0ID0gdGhpcy5oaXREcmFnZ2luZy5pbml0aWFsSGl0O1xuICAgICAgICAgICAgICAgIGxldCBkaXNhbGxvd2VkID0gaGl0LmNvbXBvbmVudElkID09PSBpbml0aWFsSGl0LmNvbXBvbmVudElkXG4gICAgICAgICAgICAgICAgICAgICYmIHRoaXMuaXNIaXRDb21ib0FsbG93ZWRcbiAgICAgICAgICAgICAgICAgICAgJiYgIXRoaXMuaXNIaXRDb21ib0FsbG93ZWQoaW5pdGlhbEhpdCwgaGl0KTtcbiAgICAgICAgICAgICAgICBpZiAoIWRpc2FsbG93ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ1NlbGVjdGlvbiA9IGpvaW5IaXRzSW50b1NlbGVjdGlvbihpbml0aWFsSGl0LCBoaXQsIGNvbnRleHQucGx1Z2luSG9va3MuZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZHJhZ1NlbGVjdGlvbiB8fCAhaXNEYXRlU2VsZWN0aW9uVmFsaWQoZHJhZ1NlbGVjdGlvbiwgaGl0LmRhdGVQcm9maWxlLCBjb250ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICBpc0ludmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBkcmFnU2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZHJhZ1NlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnU0VMRUNUX0RBVEVTJywgc2VsZWN0aW9uOiBkcmFnU2VsZWN0aW9uIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzRmluYWwpIHsgLy8gb25seSB1bnNlbGVjdCBpZiBtb3ZlZCBhd2F5IHdoaWxlIGRyYWdnaW5nXG4gICAgICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFTEVDVF9EQVRFUycgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzSW52YWxpZCkge1xuICAgICAgICAgICAgICAgIGVuYWJsZUN1cnNvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlzYWJsZUN1cnNvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0ZpbmFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnU2VsZWN0aW9uID0gZHJhZ1NlbGVjdGlvbjsgLy8gb25seSBjbGVhciBpZiBtb3ZlZCBhd2F5IGZyb20gYWxsIGhpdHMgd2hpbGUgZHJhZ2dpbmdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyVXAgPSAocGV2KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5kcmFnU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gc2VsZWN0aW9uIGlzIGFscmVhZHkgcmVuZGVyZWQsIHNvIGp1c3QgbmVlZCB0byByZXBvcnQgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgdHJpZ2dlckRhdGVTZWxlY3QodGhpcy5kcmFnU2VsZWN0aW9uLCBwZXYsIHRoaXMuY29tcG9uZW50LmNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ1NlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGxldCB7IGNvbXBvbmVudCB9ID0gc2V0dGluZ3M7XG4gICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbXBvbmVudC5jb250ZXh0O1xuICAgICAgICBsZXQgZHJhZ2dpbmcgPSB0aGlzLmRyYWdnaW5nID0gbmV3IEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcoc2V0dGluZ3MuZWwpO1xuICAgICAgICBkcmFnZ2luZy50b3VjaFNjcm9sbEFsbG93ZWQgPSBmYWxzZTtcbiAgICAgICAgZHJhZ2dpbmcubWluRGlzdGFuY2UgPSBvcHRpb25zLnNlbGVjdE1pbkRpc3RhbmNlIHx8IDA7XG4gICAgICAgIGRyYWdnaW5nLmF1dG9TY3JvbGxlci5pc0VuYWJsZWQgPSBvcHRpb25zLmRyYWdTY3JvbGw7XG4gICAgICAgIGxldCBoaXREcmFnZ2luZyA9IHRoaXMuaGl0RHJhZ2dpbmcgPSBuZXcgSGl0RHJhZ2dpbmcodGhpcy5kcmFnZ2luZywgaW50ZXJhY3Rpb25TZXR0aW5nc1RvU3RvcmUoc2V0dGluZ3MpKTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCB0aGlzLmhhbmRsZVBvaW50ZXJEb3duKTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ3N0YXJ0JywgdGhpcy5oYW5kbGVEcmFnU3RhcnQpO1xuICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdoaXR1cGRhdGUnLCB0aGlzLmhhbmRsZUhpdFVwZGF0ZSk7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ3BvaW50ZXJ1cCcsIHRoaXMuaGFuZGxlUG9pbnRlclVwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kcmFnZ2luZy5kZXN0cm95KCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50VG91Y2hEZWxheSQxKGNvbXBvbmVudCkge1xuICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbXBvbmVudC5jb250ZXh0O1xuICAgIGxldCBkZWxheSA9IG9wdGlvbnMuc2VsZWN0TG9uZ1ByZXNzRGVsYXk7XG4gICAgaWYgKGRlbGF5ID09IG51bGwpIHtcbiAgICAgICAgZGVsYXkgPSBvcHRpb25zLmxvbmdQcmVzc0RlbGF5O1xuICAgIH1cbiAgICByZXR1cm4gZGVsYXk7XG59XG5mdW5jdGlvbiBqb2luSGl0c0ludG9TZWxlY3Rpb24oaGl0MCwgaGl0MSwgZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVycykge1xuICAgIGxldCBkYXRlU3BhbjAgPSBoaXQwLmRhdGVTcGFuO1xuICAgIGxldCBkYXRlU3BhbjEgPSBoaXQxLmRhdGVTcGFuO1xuICAgIGxldCBtcyA9IFtcbiAgICAgICAgZGF0ZVNwYW4wLnJhbmdlLnN0YXJ0LFxuICAgICAgICBkYXRlU3BhbjAucmFuZ2UuZW5kLFxuICAgICAgICBkYXRlU3BhbjEucmFuZ2Uuc3RhcnQsXG4gICAgICAgIGRhdGVTcGFuMS5yYW5nZS5lbmQsXG4gICAgXTtcbiAgICBtcy5zb3J0KGNvbXBhcmVOdW1iZXJzKTtcbiAgICBsZXQgcHJvcHMgPSB7fTtcbiAgICBmb3IgKGxldCB0cmFuc2Zvcm1lciBvZiBkYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzKSB7XG4gICAgICAgIGxldCByZXMgPSB0cmFuc2Zvcm1lcihoaXQwLCBoaXQxKTtcbiAgICAgICAgaWYgKHJlcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocHJvcHMsIHJlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvcHMucmFuZ2UgPSB7IHN0YXJ0OiBtc1swXSwgZW5kOiBtc1szXSB9O1xuICAgIHByb3BzLmFsbERheSA9IGRhdGVTcGFuMC5hbGxEYXk7XG4gICAgcmV0dXJuIHByb3BzO1xufVxuXG5jbGFzcyBFdmVudERyYWdnaW5nIGV4dGVuZHMgSW50ZXJhY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICAgICAgLy8gaW50ZXJuYWwgc3RhdGVcbiAgICAgICAgdGhpcy5zdWJqZWN0RWwgPSBudWxsO1xuICAgICAgICB0aGlzLnN1YmplY3RTZWcgPSBudWxsOyAvLyB0aGUgc2VnIGJlaW5nIHNlbGVjdGVkL2RyYWdnZWRcbiAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXZlbnRSYW5nZSA9IG51bGw7XG4gICAgICAgIHRoaXMucmVsZXZhbnRFdmVudHMgPSBudWxsOyAvLyB0aGUgZXZlbnRzIGJlaW5nIGRyYWdnZWRcbiAgICAgICAgdGhpcy5yZWNlaXZpbmdDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy52YWxpZE11dGF0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5tdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBudWxsO1xuICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJEb3duID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBsZXQgb3JpZ1RhcmdldCA9IGV2Lm9yaWdFdmVudC50YXJnZXQ7XG4gICAgICAgICAgICBsZXQgeyBjb21wb25lbnQsIGRyYWdnaW5nIH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IHsgbWlycm9yIH0gPSBkcmFnZ2luZztcbiAgICAgICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbXBvbmVudC5jb250ZXh0O1xuICAgICAgICAgICAgbGV0IGluaXRpYWxDb250ZXh0ID0gY29tcG9uZW50LmNvbnRleHQ7XG4gICAgICAgICAgICB0aGlzLnN1YmplY3RFbCA9IGV2LnN1YmplY3RFbDtcbiAgICAgICAgICAgIGxldCBzdWJqZWN0U2VnID0gdGhpcy5zdWJqZWN0U2VnID0gZ2V0RWxTZWcoZXYuc3ViamVjdEVsKTtcbiAgICAgICAgICAgIGxldCBldmVudFJhbmdlID0gdGhpcy5ldmVudFJhbmdlID0gc3ViamVjdFNlZy5ldmVudFJhbmdlO1xuICAgICAgICAgICAgbGV0IGV2ZW50SW5zdGFuY2VJZCA9IGV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZDtcbiAgICAgICAgICAgIHRoaXMucmVsZXZhbnRFdmVudHMgPSBnZXRSZWxldmFudEV2ZW50cyhpbml0aWFsQ29udGV4dC5nZXRDdXJyZW50RGF0YSgpLmV2ZW50U3RvcmUsIGV2ZW50SW5zdGFuY2VJZCk7XG4gICAgICAgICAgICBkcmFnZ2luZy5taW5EaXN0YW5jZSA9IGV2LmlzVG91Y2ggPyAwIDogb3B0aW9ucy5ldmVudERyYWdNaW5EaXN0YW5jZTtcbiAgICAgICAgICAgIGRyYWdnaW5nLmRlbGF5ID1cbiAgICAgICAgICAgICAgICAvLyBvbmx5IGRvIGEgdG91Y2ggZGVsYXkgaWYgdG91Y2ggYW5kIHRoaXMgZXZlbnQgaGFzbid0IGJlZW4gc2VsZWN0ZWQgeWV0XG4gICAgICAgICAgICAgICAgKGV2LmlzVG91Y2ggJiYgZXZlbnRJbnN0YW5jZUlkICE9PSBjb21wb25lbnQucHJvcHMuZXZlbnRTZWxlY3Rpb24pID9cbiAgICAgICAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50VG91Y2hEZWxheShjb21wb25lbnQpIDpcbiAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmZpeGVkTWlycm9yUGFyZW50KSB7XG4gICAgICAgICAgICAgICAgbWlycm9yLnBhcmVudE5vZGUgPSBvcHRpb25zLmZpeGVkTWlycm9yUGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWlycm9yLnBhcmVudE5vZGUgPSBlbGVtZW50Q2xvc2VzdChvcmlnVGFyZ2V0LCAnLmZjJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtaXJyb3IucmV2ZXJ0RHVyYXRpb24gPSBvcHRpb25zLmRyYWdSZXZlcnREdXJhdGlvbjtcbiAgICAgICAgICAgIGxldCBpc1ZhbGlkID0gY29tcG9uZW50LmlzVmFsaWRTZWdEb3duRWwob3JpZ1RhcmdldCkgJiZcbiAgICAgICAgICAgICAgICAhZWxlbWVudENsb3Nlc3Qob3JpZ1RhcmdldCwgJy5mYy1ldmVudC1yZXNpemVyJyk7IC8vIE5PVCBvbiBhIHJlc2l6ZXJcbiAgICAgICAgICAgIGRyYWdnaW5nLnNldElnbm9yZU1vdmUoIWlzVmFsaWQpO1xuICAgICAgICAgICAgLy8gZGlzYWJsZSBkcmFnZ2luZyBmb3IgZWxlbWVudHMgdGhhdCBhcmUgcmVzaXphYmxlIChpZSwgc2VsZWN0YWJsZSlcbiAgICAgICAgICAgIC8vIGJ1dCBhcmUgbm90IGRyYWdnYWJsZVxuICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gaXNWYWxpZCAmJlxuICAgICAgICAgICAgICAgIGV2LnN1YmplY3RFbC5jbGFzc0xpc3QuY29udGFpbnMoJ2ZjLWV2ZW50LWRyYWdnYWJsZScpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZURyYWdTdGFydCA9IChldikgPT4ge1xuICAgICAgICAgICAgbGV0IGluaXRpYWxDb250ZXh0ID0gdGhpcy5jb21wb25lbnQuY29udGV4dDtcbiAgICAgICAgICAgIGxldCBldmVudFJhbmdlID0gdGhpcy5ldmVudFJhbmdlO1xuICAgICAgICAgICAgbGV0IGV2ZW50SW5zdGFuY2VJZCA9IGV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZDtcbiAgICAgICAgICAgIGlmIChldi5pc1RvdWNoKSB7XG4gICAgICAgICAgICAgICAgLy8gbmVlZCB0byBzZWxlY3QgYSBkaWZmZXJlbnQgZXZlbnQ/XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50SW5zdGFuY2VJZCAhPT0gdGhpcy5jb21wb25lbnQucHJvcHMuZXZlbnRTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnU0VMRUNUX0VWRU5UJywgZXZlbnRJbnN0YW5jZUlkIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGlmIG5vdyB1c2luZyBtb3VzZSwgYnV0IHdhcyBwcmV2aW91cyB0b3VjaCBpbnRlcmFjdGlvbiwgY2xlYXIgc2VsZWN0ZWQgZXZlbnRcbiAgICAgICAgICAgICAgICBpbml0aWFsQ29udGV4dC5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFTEVDVF9FVkVOVCcgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHQuY2FsZW5kYXJBcGkudW5zZWxlY3QoZXYpOyAvLyB1bnNlbGVjdCAqZGF0ZSogc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudERyYWdTdGFydCcsIHtcbiAgICAgICAgICAgICAgICAgICAgZWw6IHRoaXMuc3ViamVjdEVsLFxuICAgICAgICAgICAgICAgICAgICBldmVudDogbmV3IEV2ZW50SW1wbChpbml0aWFsQ29udGV4dCwgZXZlbnRSYW5nZS5kZWYsIGV2ZW50UmFuZ2UuaW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgICAgICBqc0V2ZW50OiBldi5vcmlnRXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIHZpZXc6IGluaXRpYWxDb250ZXh0LnZpZXdBcGksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlSGl0VXBkYXRlID0gKGhpdCwgaXNGaW5hbCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVsZXZhbnRFdmVudHMgPSB0aGlzLnJlbGV2YW50RXZlbnRzO1xuICAgICAgICAgICAgbGV0IGluaXRpYWxIaXQgPSB0aGlzLmhpdERyYWdnaW5nLmluaXRpYWxIaXQ7XG4gICAgICAgICAgICBsZXQgaW5pdGlhbENvbnRleHQgPSB0aGlzLmNvbXBvbmVudC5jb250ZXh0O1xuICAgICAgICAgICAgLy8gc3RhdGVzIGJhc2VkIG9uIG5ldyBoaXRcbiAgICAgICAgICAgIGxldCByZWNlaXZpbmdDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBtdXRhdGlvbiA9IG51bGw7XG4gICAgICAgICAgICBsZXQgbXV0YXRlZFJlbGV2YW50RXZlbnRzID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBpc0ludmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBpbnRlcmFjdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBhZmZlY3RlZEV2ZW50czogcmVsZXZhbnRFdmVudHMsXG4gICAgICAgICAgICAgICAgbXV0YXRlZEV2ZW50czogY3JlYXRlRW1wdHlFdmVudFN0b3JlKCksXG4gICAgICAgICAgICAgICAgaXNFdmVudDogdHJ1ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoaGl0KSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dCA9IGhpdC5jb250ZXh0O1xuICAgICAgICAgICAgICAgIGxldCByZWNlaXZpbmdPcHRpb25zID0gcmVjZWl2aW5nQ29udGV4dC5vcHRpb25zO1xuICAgICAgICAgICAgICAgIGlmIChpbml0aWFsQ29udGV4dCA9PT0gcmVjZWl2aW5nQ29udGV4dCB8fFxuICAgICAgICAgICAgICAgICAgICAocmVjZWl2aW5nT3B0aW9ucy5lZGl0YWJsZSAmJiByZWNlaXZpbmdPcHRpb25zLmRyb3BwYWJsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbXV0YXRpb24gPSBjb21wdXRlRXZlbnRNdXRhdGlvbihpbml0aWFsSGl0LCBoaXQsIHRoaXMuZXZlbnRSYW5nZS5pbnN0YW5jZS5yYW5nZS5zdGFydCwgcmVjZWl2aW5nQ29udGV4dC5nZXRDdXJyZW50RGF0YSgpLnBsdWdpbkhvb2tzLmV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG11dGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBhcHBseU11dGF0aW9uVG9FdmVudFN0b3JlKHJlbGV2YW50RXZlbnRzLCByZWNlaXZpbmdDb250ZXh0LmdldEN1cnJlbnREYXRhKCkuZXZlbnRVaUJhc2VzLCBtdXRhdGlvbiwgcmVjZWl2aW5nQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzID0gbXV0YXRlZFJlbGV2YW50RXZlbnRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0ludGVyYWN0aW9uVmFsaWQoaW50ZXJhY3Rpb24sIGhpdC5kYXRlUHJvZmlsZSwgcmVjZWl2aW5nQ29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0ludmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMgPSBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kaXNwbGF5RHJhZyhyZWNlaXZpbmdDb250ZXh0LCBpbnRlcmFjdGlvbik7XG4gICAgICAgICAgICBpZiAoIWlzSW52YWxpZCkge1xuICAgICAgICAgICAgICAgIGVuYWJsZUN1cnNvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlzYWJsZUN1cnNvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0ZpbmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluaXRpYWxDb250ZXh0ID09PSByZWNlaXZpbmdDb250ZXh0ICYmIC8vIFRPRE86IHdyaXRlIHRlc3QgZm9yIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgaXNIaXRzRXF1YWwoaW5pdGlhbEhpdCwgaGl0KSkge1xuICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcuc2V0TWlycm9yTmVlZHNSZXZlcnQoIW11dGF0aW9uKTtcbiAgICAgICAgICAgICAgICAvLyByZW5kZXIgdGhlIG1pcnJvciBpZiBubyBhbHJlYWR5LXJlbmRlcmVkIG1pcnJvclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IHdpc2ggd2UgY291bGQgc29tZWhvdyB3YWl0IGZvciBkaXNwYXRjaCB0byBndWFyYW50ZWUgcmVuZGVyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZy5zZXRNaXJyb3JJc1Zpc2libGUoIWhpdCB8fCAhdGhpcy5zdWJqZWN0RWwuZ2V0Um9vdE5vZGUoKS5xdWVyeVNlbGVjdG9yKCcuZmMtZXZlbnQtbWlycm9yJykpO1xuICAgICAgICAgICAgICAgIC8vIGFzc2lnbiBzdGF0ZXMgYmFzZWQgb24gbmV3IGhpdFxuICAgICAgICAgICAgICAgIHRoaXMucmVjZWl2aW5nQ29udGV4dCA9IHJlY2VpdmluZ0NvbnRleHQ7XG4gICAgICAgICAgICAgICAgdGhpcy52YWxpZE11dGF0aW9uID0gbXV0YXRpb247XG4gICAgICAgICAgICAgICAgdGhpcy5tdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBtdXRhdGVkUmVsZXZhbnRFdmVudHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlclVwID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFudXAoKTsgLy8gYmVjYXVzZSBoYW5kbGVEcmFnRW5kIHdvbid0IGZpcmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVEcmFnRW5kID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgbGV0IGluaXRpYWxDb250ZXh0ID0gdGhpcy5jb21wb25lbnQuY29udGV4dDtcbiAgICAgICAgICAgICAgICBsZXQgaW5pdGlhbFZpZXcgPSBpbml0aWFsQ29udGV4dC52aWV3QXBpO1xuICAgICAgICAgICAgICAgIGxldCB7IHJlY2VpdmluZ0NvbnRleHQsIHZhbGlkTXV0YXRpb24gfSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgbGV0IGV2ZW50RGVmID0gdGhpcy5ldmVudFJhbmdlLmRlZjtcbiAgICAgICAgICAgICAgICBsZXQgZXZlbnRJbnN0YW5jZSA9IHRoaXMuZXZlbnRSYW5nZS5pbnN0YW5jZTtcbiAgICAgICAgICAgICAgICBsZXQgZXZlbnRBcGkgPSBuZXcgRXZlbnRJbXBsKGluaXRpYWxDb250ZXh0LCBldmVudERlZiwgZXZlbnRJbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgbGV0IHJlbGV2YW50RXZlbnRzID0gdGhpcy5yZWxldmFudEV2ZW50cztcbiAgICAgICAgICAgICAgICBsZXQgbXV0YXRlZFJlbGV2YW50RXZlbnRzID0gdGhpcy5tdXRhdGVkUmVsZXZhbnRFdmVudHM7XG4gICAgICAgICAgICAgICAgbGV0IHsgZmluYWxIaXQgfSA9IHRoaXMuaGl0RHJhZ2dpbmc7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhckRyYWcoKTsgLy8gbXVzdCBoYXBwZW4gYWZ0ZXIgcmV2ZXJ0IGFuaW1hdGlvblxuICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnREcmFnU3RvcCcsIHtcbiAgICAgICAgICAgICAgICAgICAgZWw6IHRoaXMuc3ViamVjdEVsLFxuICAgICAgICAgICAgICAgICAgICBldmVudDogZXZlbnRBcGksXG4gICAgICAgICAgICAgICAgICAgIGpzRXZlbnQ6IGV2Lm9yaWdFdmVudCxcbiAgICAgICAgICAgICAgICAgICAgdmlldzogaW5pdGlhbFZpZXcsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbGlkTXV0YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZHJvcHBlZCB3aXRoaW4gc2FtZSBjYWxlbmRhclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVjZWl2aW5nQ29udGV4dCA9PT0gaW5pdGlhbENvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB1cGRhdGVkRXZlbnRBcGkgPSBuZXcgRXZlbnRJbXBsKGluaXRpYWxDb250ZXh0LCBtdXRhdGVkUmVsZXZhbnRFdmVudHMuZGVmc1tldmVudERlZi5kZWZJZF0sIGV2ZW50SW5zdGFuY2UgPyBtdXRhdGVkUmVsZXZhbnRFdmVudHMuaW5zdGFuY2VzW2V2ZW50SW5zdGFuY2UuaW5zdGFuY2VJZF0gOiBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTUVSR0VfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlOiBtdXRhdGVkUmVsZXZhbnRFdmVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBldmVudENoYW5nZUFyZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRFdmVudDogZXZlbnRBcGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IHVwZGF0ZWRFdmVudEFwaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxhdGVkRXZlbnRzOiBidWlsZEV2ZW50QXBpcyhtdXRhdGVkUmVsZXZhbnRFdmVudHMsIGluaXRpYWxDb250ZXh0LCBldmVudEluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdNRVJHRV9FVkVOVFMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogcmVsZXZhbnRFdmVudHMsIC8vIHRoZSBwcmUtY2hhbmdlIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdHJhbnNmb3JtZWQgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHRyYW5zZm9ybWVyIG9mIGluaXRpYWxDb250ZXh0LmdldEN1cnJlbnREYXRhKCkucGx1Z2luSG9va3MuZXZlbnREcm9wVHJhbnNmb3JtZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0cmFuc2Zvcm1lZCwgdHJhbnNmb3JtZXIodmFsaWRNdXRhdGlvbiwgaW5pdGlhbENvbnRleHQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnREcm9wJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV2ZW50Q2hhbmdlQXJnKSwgdHJhbnNmb3JtZWQpLCB7IGVsOiBldi5zdWJqZWN0RWwsIGRlbHRhOiB2YWxpZE11dGF0aW9uLmRhdGVzRGVsdGEsIGpzRXZlbnQ6IGV2Lm9yaWdFdmVudCwgdmlldzogaW5pdGlhbFZpZXcgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudENoYW5nZScsIGV2ZW50Q2hhbmdlQXJnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRyb3BwZWQgaW4gZGlmZmVyZW50IGNhbGVuZGFyXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVjZWl2aW5nQ29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGV2ZW50UmVtb3ZlQXJnID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudEFwaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxhdGVkRXZlbnRzOiBidWlsZEV2ZW50QXBpcyhyZWxldmFudEV2ZW50cywgaW5pdGlhbENvbnRleHQsIGV2ZW50SW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmVydCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ01FUkdFX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlOiByZWxldmFudEV2ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsQ29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50TGVhdmUnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV2ZW50UmVtb3ZlQXJnKSwgeyBkcmFnZ2VkRWw6IGV2LnN1YmplY3RFbCwgdmlldzogaW5pdGlhbFZpZXcgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdSRU1PVkVfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlOiByZWxldmFudEV2ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudFJlbW92ZScsIGV2ZW50UmVtb3ZlQXJnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhZGRlZEV2ZW50RGVmID0gbXV0YXRlZFJlbGV2YW50RXZlbnRzLmRlZnNbZXZlbnREZWYuZGVmSWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGFkZGVkRXZlbnRJbnN0YW5jZSA9IG11dGF0ZWRSZWxldmFudEV2ZW50cy5pbnN0YW5jZXNbZXZlbnRJbnN0YW5jZS5pbnN0YW5jZUlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhZGRlZEV2ZW50QXBpID0gbmV3IEV2ZW50SW1wbChyZWNlaXZpbmdDb250ZXh0LCBhZGRlZEV2ZW50RGVmLCBhZGRlZEV2ZW50SW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ01FUkdFX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogbXV0YXRlZFJlbGV2YW50RXZlbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZXZlbnRBZGRBcmcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGFkZGVkRXZlbnRBcGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRlZEV2ZW50czogYnVpbGRFdmVudEFwaXMobXV0YXRlZFJlbGV2YW50RXZlbnRzLCByZWNlaXZpbmdDb250ZXh0LCBhZGRlZEV2ZW50SW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmVydCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnUkVNT1ZFX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlOiBtdXRhdGVkUmVsZXZhbnRFdmVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50QWRkJywgZXZlbnRBZGRBcmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2LmlzVG91Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZpbmdDb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1NFTEVDVF9FVkVOVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50SW5zdGFuY2VJZDogZXZlbnRJbnN0YW5jZS5pbnN0YW5jZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2Ryb3AnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJ1aWxkRGF0ZVBvaW50QXBpV2l0aENvbnRleHQoZmluYWxIaXQuZGF0ZVNwYW4sIHJlY2VpdmluZ0NvbnRleHQpKSwgeyBkcmFnZ2VkRWw6IGV2LnN1YmplY3RFbCwganNFdmVudDogZXYub3JpZ0V2ZW50LCB2aWV3OiBmaW5hbEhpdC5jb250ZXh0LnZpZXdBcGkgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50UmVjZWl2ZScsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRBZGRBcmcpLCB7IGRyYWdnZWRFbDogZXYuc3ViamVjdEVsLCB2aWV3OiBmaW5hbEhpdC5jb250ZXh0LnZpZXdBcGkgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbml0aWFsQ29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ19ub0V2ZW50RHJvcCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgeyBjb21wb25lbnQgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbXBvbmVudC5jb250ZXh0O1xuICAgICAgICBsZXQgZHJhZ2dpbmcgPSB0aGlzLmRyYWdnaW5nID0gbmV3IEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcoc2V0dGluZ3MuZWwpO1xuICAgICAgICBkcmFnZ2luZy5wb2ludGVyLnNlbGVjdG9yID0gRXZlbnREcmFnZ2luZy5TRUxFQ1RPUjtcbiAgICAgICAgZHJhZ2dpbmcudG91Y2hTY3JvbGxBbGxvd2VkID0gZmFsc2U7XG4gICAgICAgIGRyYWdnaW5nLmF1dG9TY3JvbGxlci5pc0VuYWJsZWQgPSBvcHRpb25zLmRyYWdTY3JvbGw7XG4gICAgICAgIGxldCBoaXREcmFnZ2luZyA9IHRoaXMuaGl0RHJhZ2dpbmcgPSBuZXcgSGl0RHJhZ2dpbmcodGhpcy5kcmFnZ2luZywgaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlKTtcbiAgICAgICAgaGl0RHJhZ2dpbmcudXNlU3ViamVjdENlbnRlciA9IHNldHRpbmdzLnVzZUV2ZW50Q2VudGVyO1xuICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdwb2ludGVyZG93bicsIHRoaXMuaGFuZGxlUG9pbnRlckRvd24pO1xuICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdkcmFnc3RhcnQnLCB0aGlzLmhhbmRsZURyYWdTdGFydCk7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2hpdHVwZGF0ZScsIHRoaXMuaGFuZGxlSGl0VXBkYXRlKTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcnVwJywgdGhpcy5oYW5kbGVQb2ludGVyVXApO1xuICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdkcmFnZW5kJywgdGhpcy5oYW5kbGVEcmFnRW5kKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kcmFnZ2luZy5kZXN0cm95KCk7XG4gICAgfVxuICAgIC8vIHJlbmRlciBhIGRyYWcgc3RhdGUgb24gdGhlIG5leHQgcmVjZWl2aW5nQ2FsZW5kYXJcbiAgICBkaXNwbGF5RHJhZyhuZXh0Q29udGV4dCwgc3RhdGUpIHtcbiAgICAgICAgbGV0IGluaXRpYWxDb250ZXh0ID0gdGhpcy5jb21wb25lbnQuY29udGV4dDtcbiAgICAgICAgbGV0IHByZXZDb250ZXh0ID0gdGhpcy5yZWNlaXZpbmdDb250ZXh0O1xuICAgICAgICAvLyBkb2VzIHRoZSBwcmV2aW91cyBjYWxlbmRhciBuZWVkIHRvIGJlIGNsZWFyZWQ/XG4gICAgICAgIGlmIChwcmV2Q29udGV4dCAmJiBwcmV2Q29udGV4dCAhPT0gbmV4dENvbnRleHQpIHtcbiAgICAgICAgICAgIC8vIGRvZXMgdGhlIGluaXRpYWwgY2FsZW5kYXIgbmVlZCB0byBiZSBjbGVhcmVkP1xuICAgICAgICAgICAgLy8gaWYgc28sIGRvbid0IGNsZWFyIGFsbCB0aGUgd2F5LiB3ZSBzdGlsbCBuZWVkIHRvIHRvIGhpZGUgdGhlIGFmZmVjdGVkRXZlbnRzXG4gICAgICAgICAgICBpZiAocHJldkNvbnRleHQgPT09IGluaXRpYWxDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgcHJldkNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnU0VUX0VWRU5UX0RSQUcnLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWZmZWN0ZWRFdmVudHM6IHN0YXRlLmFmZmVjdGVkRXZlbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRlZEV2ZW50czogY3JlYXRlRW1wdHlFdmVudFN0b3JlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0V2ZW50OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIGNvbXBsZXRlbHkgY2xlYXIgdGhlIG9sZCBjYWxlbmRhciBpZiBpdCB3YXNuJ3QgdGhlIGluaXRpYWxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZXZDb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1VOU0VUX0VWRU5UX0RSQUcnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0Q29udGV4dCkge1xuICAgICAgICAgICAgbmV4dENvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnU0VUX0VWRU5UX0RSQUcnLCBzdGF0ZSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGVhckRyYWcoKSB7XG4gICAgICAgIGxldCBpbml0aWFsQ2FsZW5kYXIgPSB0aGlzLmNvbXBvbmVudC5jb250ZXh0O1xuICAgICAgICBsZXQgeyByZWNlaXZpbmdDb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBpZiAocmVjZWl2aW5nQ29udGV4dCkge1xuICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dC5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFVF9FVkVOVF9EUkFHJyB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGUgaW5pdGlhbCBjYWxlbmRhciBtaWdodCBoYXZlIGFuIGR1bW15IGRyYWcgc3RhdGUgZnJvbSBkaXNwbGF5RHJhZ1xuICAgICAgICBpZiAoaW5pdGlhbENhbGVuZGFyICE9PSByZWNlaXZpbmdDb250ZXh0KSB7XG4gICAgICAgICAgICBpbml0aWFsQ2FsZW5kYXIuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRVRfRVZFTlRfRFJBRycgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xlYW51cCgpIHtcbiAgICAgICAgdGhpcy5zdWJqZWN0U2VnID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXZlbnRSYW5nZSA9IG51bGw7XG4gICAgICAgIHRoaXMucmVsZXZhbnRFdmVudHMgPSBudWxsO1xuICAgICAgICB0aGlzLnJlY2VpdmluZ0NvbnRleHQgPSBudWxsO1xuICAgICAgICB0aGlzLnZhbGlkTXV0YXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLm11dGF0ZWRSZWxldmFudEV2ZW50cyA9IG51bGw7XG4gICAgfVxufVxuLy8gVE9ETzogdGVzdCB0aGlzIGluIElFMTFcbi8vIFFVRVNUSU9OOiB3aHkgZG8gd2UgbmVlZCBpdCBvbiB0aGUgcmVzaXphYmxlPz8/XG5FdmVudERyYWdnaW5nLlNFTEVDVE9SID0gJy5mYy1ldmVudC1kcmFnZ2FibGUsIC5mYy1ldmVudC1yZXNpemFibGUnO1xuZnVuY3Rpb24gY29tcHV0ZUV2ZW50TXV0YXRpb24oaGl0MCwgaGl0MSwgZXZlbnRJbnN0YW5jZVN0YXJ0LCBtYXNzYWdlcnMpIHtcbiAgICBsZXQgZGF0ZVNwYW4wID0gaGl0MC5kYXRlU3BhbjtcbiAgICBsZXQgZGF0ZVNwYW4xID0gaGl0MS5kYXRlU3BhbjtcbiAgICBsZXQgZGF0ZTAgPSBkYXRlU3BhbjAucmFuZ2Uuc3RhcnQ7XG4gICAgbGV0IGRhdGUxID0gZGF0ZVNwYW4xLnJhbmdlLnN0YXJ0O1xuICAgIGxldCBzdGFuZGFyZFByb3BzID0ge307XG4gICAgaWYgKGRhdGVTcGFuMC5hbGxEYXkgIT09IGRhdGVTcGFuMS5hbGxEYXkpIHtcbiAgICAgICAgc3RhbmRhcmRQcm9wcy5hbGxEYXkgPSBkYXRlU3BhbjEuYWxsRGF5O1xuICAgICAgICBzdGFuZGFyZFByb3BzLmhhc0VuZCA9IGhpdDEuY29udGV4dC5vcHRpb25zLmFsbERheU1haW50YWluRHVyYXRpb247XG4gICAgICAgIGlmIChkYXRlU3BhbjEuYWxsRGF5KSB7XG4gICAgICAgICAgICAvLyBtZWFucyBkYXRlMSBpcyBhbHJlYWR5IHN0YXJ0LW9mLWRheSxcbiAgICAgICAgICAgIC8vIGJ1dCBkYXRlMCBuZWVkcyB0byBiZSBjb252ZXJ0ZWRcbiAgICAgICAgICAgIGRhdGUwID0gc3RhcnRPZkRheShldmVudEluc3RhbmNlU3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTW92aW5nIGZyb20gYWxsRGF0ZS0+dGltZWRcbiAgICAgICAgICAgIC8vIERvZXNuJ3QgbWF0dGVyIHdoZXJlIG9uIHRoZSBldmVudCB0aGUgZHJhZyBiZWdhbiwgbXV0YXRlIHRoZSBldmVudCdzIHN0YXJ0LWRhdGUgdG8gZGF0ZTFcbiAgICAgICAgICAgIGRhdGUwID0gZXZlbnRJbnN0YW5jZVN0YXJ0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBkZWx0YSA9IGRpZmZEYXRlcyhkYXRlMCwgZGF0ZTEsIGhpdDAuY29udGV4dC5kYXRlRW52LCBoaXQwLmNvbXBvbmVudElkID09PSBoaXQxLmNvbXBvbmVudElkID9cbiAgICAgICAgaGl0MC5sYXJnZVVuaXQgOlxuICAgICAgICBudWxsKTtcbiAgICBpZiAoZGVsdGEubWlsbGlzZWNvbmRzKSB7IC8vIGhhcyBob3Vycy9taW51dGVzL3NlY29uZHNcbiAgICAgICAgc3RhbmRhcmRQcm9wcy5hbGxEYXkgPSBmYWxzZTtcbiAgICB9XG4gICAgbGV0IG11dGF0aW9uID0ge1xuICAgICAgICBkYXRlc0RlbHRhOiBkZWx0YSxcbiAgICAgICAgc3RhbmRhcmRQcm9wcyxcbiAgICB9O1xuICAgIGZvciAobGV0IG1hc3NhZ2VyIG9mIG1hc3NhZ2Vycykge1xuICAgICAgICBtYXNzYWdlcihtdXRhdGlvbiwgaGl0MCwgaGl0MSk7XG4gICAgfVxuICAgIHJldHVybiBtdXRhdGlvbjtcbn1cbmZ1bmN0aW9uIGdldENvbXBvbmVudFRvdWNoRGVsYXkoY29tcG9uZW50KSB7XG4gICAgbGV0IHsgb3B0aW9ucyB9ID0gY29tcG9uZW50LmNvbnRleHQ7XG4gICAgbGV0IGRlbGF5ID0gb3B0aW9ucy5ldmVudExvbmdQcmVzc0RlbGF5O1xuICAgIGlmIChkZWxheSA9PSBudWxsKSB7XG4gICAgICAgIGRlbGF5ID0gb3B0aW9ucy5sb25nUHJlc3NEZWxheTtcbiAgICB9XG4gICAgcmV0dXJuIGRlbGF5O1xufVxuXG5jbGFzcyBFdmVudFJlc2l6aW5nIGV4dGVuZHMgSW50ZXJhY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICAgICAgLy8gaW50ZXJuYWwgc3RhdGVcbiAgICAgICAgdGhpcy5kcmFnZ2luZ1NlZ0VsID0gbnVsbDtcbiAgICAgICAgdGhpcy5kcmFnZ2luZ1NlZyA9IG51bGw7IC8vIFRPRE86IHJlbmFtZSB0byByZXNpemluZ1NlZz8gc3ViamVjdFNlZz9cbiAgICAgICAgdGhpcy5ldmVudFJhbmdlID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWxldmFudEV2ZW50cyA9IG51bGw7XG4gICAgICAgIHRoaXMudmFsaWRNdXRhdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMubXV0YXRlZFJlbGV2YW50RXZlbnRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyRG93biA9IChldikgPT4ge1xuICAgICAgICAgICAgbGV0IHsgY29tcG9uZW50IH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IHNlZ0VsID0gdGhpcy5xdWVyeVNlZ0VsKGV2KTtcbiAgICAgICAgICAgIGxldCBzZWcgPSBnZXRFbFNlZyhzZWdFbCk7XG4gICAgICAgICAgICBsZXQgZXZlbnRSYW5nZSA9IHRoaXMuZXZlbnRSYW5nZSA9IHNlZy5ldmVudFJhbmdlO1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZy5taW5EaXN0YW5jZSA9IGNvbXBvbmVudC5jb250ZXh0Lm9wdGlvbnMuZXZlbnREcmFnTWluRGlzdGFuY2U7XG4gICAgICAgICAgICAvLyBpZiB0b3VjaCwgbmVlZCB0byBiZSB3b3JraW5nIHdpdGggYSBzZWxlY3RlZCBldmVudFxuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZy5zZXRJZ25vcmVNb3ZlKCF0aGlzLmNvbXBvbmVudC5pc1ZhbGlkU2VnRG93bkVsKGV2Lm9yaWdFdmVudC50YXJnZXQpIHx8XG4gICAgICAgICAgICAgICAgKGV2LmlzVG91Y2ggJiYgdGhpcy5jb21wb25lbnQucHJvcHMuZXZlbnRTZWxlY3Rpb24gIT09IGV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZCkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZURyYWdTdGFydCA9IChldikgPT4ge1xuICAgICAgICAgICAgbGV0IHsgY29udGV4dCB9ID0gdGhpcy5jb21wb25lbnQ7XG4gICAgICAgICAgICBsZXQgZXZlbnRSYW5nZSA9IHRoaXMuZXZlbnRSYW5nZTtcbiAgICAgICAgICAgIHRoaXMucmVsZXZhbnRFdmVudHMgPSBnZXRSZWxldmFudEV2ZW50cyhjb250ZXh0LmdldEN1cnJlbnREYXRhKCkuZXZlbnRTdG9yZSwgdGhpcy5ldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWQpO1xuICAgICAgICAgICAgbGV0IHNlZ0VsID0gdGhpcy5xdWVyeVNlZ0VsKGV2KTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdTZWdFbCA9IHNlZ0VsO1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ1NlZyA9IGdldEVsU2VnKHNlZ0VsKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2FsZW5kYXJBcGkudW5zZWxlY3QoKTtcbiAgICAgICAgICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudFJlc2l6ZVN0YXJ0Jywge1xuICAgICAgICAgICAgICAgIGVsOiBzZWdFbCxcbiAgICAgICAgICAgICAgICBldmVudDogbmV3IEV2ZW50SW1wbChjb250ZXh0LCBldmVudFJhbmdlLmRlZiwgZXZlbnRSYW5nZS5pbnN0YW5jZSksXG4gICAgICAgICAgICAgICAganNFdmVudDogZXYub3JpZ0V2ZW50LFxuICAgICAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUhpdFVwZGF0ZSA9IChoaXQsIGlzRmluYWwsIGV2KSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBjb250ZXh0IH0gPSB0aGlzLmNvbXBvbmVudDtcbiAgICAgICAgICAgIGxldCByZWxldmFudEV2ZW50cyA9IHRoaXMucmVsZXZhbnRFdmVudHM7XG4gICAgICAgICAgICBsZXQgaW5pdGlhbEhpdCA9IHRoaXMuaGl0RHJhZ2dpbmcuaW5pdGlhbEhpdDtcbiAgICAgICAgICAgIGxldCBldmVudEluc3RhbmNlID0gdGhpcy5ldmVudFJhbmdlLmluc3RhbmNlO1xuICAgICAgICAgICAgbGV0IG11dGF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBtdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBudWxsO1xuICAgICAgICAgICAgbGV0IGlzSW52YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGludGVyYWN0aW9uID0ge1xuICAgICAgICAgICAgICAgIGFmZmVjdGVkRXZlbnRzOiByZWxldmFudEV2ZW50cyxcbiAgICAgICAgICAgICAgICBtdXRhdGVkRXZlbnRzOiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSxcbiAgICAgICAgICAgICAgICBpc0V2ZW50OiB0cnVlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChoaXQpIHtcbiAgICAgICAgICAgICAgICBsZXQgZGlzYWxsb3dlZCA9IGhpdC5jb21wb25lbnRJZCA9PT0gaW5pdGlhbEhpdC5jb21wb25lbnRJZFxuICAgICAgICAgICAgICAgICAgICAmJiB0aGlzLmlzSGl0Q29tYm9BbGxvd2VkXG4gICAgICAgICAgICAgICAgICAgICYmICF0aGlzLmlzSGl0Q29tYm9BbGxvd2VkKGluaXRpYWxIaXQsIGhpdCk7XG4gICAgICAgICAgICAgICAgaWYgKCFkaXNhbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIG11dGF0aW9uID0gY29tcHV0ZU11dGF0aW9uKGluaXRpYWxIaXQsIGhpdCwgZXYuc3ViamVjdEVsLmNsYXNzTGlzdC5jb250YWlucygnZmMtZXZlbnQtcmVzaXplci1zdGFydCcpLCBldmVudEluc3RhbmNlLnJhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobXV0YXRpb24pIHtcbiAgICAgICAgICAgICAgICBtdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBhcHBseU11dGF0aW9uVG9FdmVudFN0b3JlKHJlbGV2YW50RXZlbnRzLCBjb250ZXh0LmdldEN1cnJlbnREYXRhKCkuZXZlbnRVaUJhc2VzLCBtdXRhdGlvbiwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cyA9IG11dGF0ZWRSZWxldmFudEV2ZW50cztcbiAgICAgICAgICAgICAgICBpZiAoIWlzSW50ZXJhY3Rpb25WYWxpZChpbnRlcmFjdGlvbiwgaGl0LmRhdGVQcm9maWxlLCBjb250ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICBpc0ludmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIG11dGF0ZWRSZWxldmFudEV2ZW50cyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtdXRhdGVkUmVsZXZhbnRFdmVudHMpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1NFVF9FVkVOVF9SRVNJWkUnLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogaW50ZXJhY3Rpb24sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1VOU0VUX0VWRU5UX1JFU0laRScgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzSW52YWxpZCkge1xuICAgICAgICAgICAgICAgIGVuYWJsZUN1cnNvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlzYWJsZUN1cnNvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0ZpbmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKG11dGF0aW9uICYmIGlzSGl0c0VxdWFsKGluaXRpYWxIaXQsIGhpdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbXV0YXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnZhbGlkTXV0YXRpb24gPSBtdXRhdGlvbjtcbiAgICAgICAgICAgICAgICB0aGlzLm11dGF0ZWRSZWxldmFudEV2ZW50cyA9IG11dGF0ZWRSZWxldmFudEV2ZW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVEcmFnRW5kID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBjb250ZXh0IH0gPSB0aGlzLmNvbXBvbmVudDtcbiAgICAgICAgICAgIGxldCBldmVudERlZiA9IHRoaXMuZXZlbnRSYW5nZS5kZWY7XG4gICAgICAgICAgICBsZXQgZXZlbnRJbnN0YW5jZSA9IHRoaXMuZXZlbnRSYW5nZS5pbnN0YW5jZTtcbiAgICAgICAgICAgIGxldCBldmVudEFwaSA9IG5ldyBFdmVudEltcGwoY29udGV4dCwgZXZlbnREZWYsIGV2ZW50SW5zdGFuY2UpO1xuICAgICAgICAgICAgbGV0IHJlbGV2YW50RXZlbnRzID0gdGhpcy5yZWxldmFudEV2ZW50cztcbiAgICAgICAgICAgIGxldCBtdXRhdGVkUmVsZXZhbnRFdmVudHMgPSB0aGlzLm11dGF0ZWRSZWxldmFudEV2ZW50cztcbiAgICAgICAgICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudFJlc2l6ZVN0b3AnLCB7XG4gICAgICAgICAgICAgICAgZWw6IHRoaXMuZHJhZ2dpbmdTZWdFbCxcbiAgICAgICAgICAgICAgICBldmVudDogZXZlbnRBcGksXG4gICAgICAgICAgICAgICAganNFdmVudDogZXYub3JpZ0V2ZW50LFxuICAgICAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMudmFsaWRNdXRhdGlvbikge1xuICAgICAgICAgICAgICAgIGxldCB1cGRhdGVkRXZlbnRBcGkgPSBuZXcgRXZlbnRJbXBsKGNvbnRleHQsIG11dGF0ZWRSZWxldmFudEV2ZW50cy5kZWZzW2V2ZW50RGVmLmRlZklkXSwgZXZlbnRJbnN0YW5jZSA/IG11dGF0ZWRSZWxldmFudEV2ZW50cy5pbnN0YW5jZXNbZXZlbnRJbnN0YW5jZS5pbnN0YW5jZUlkXSA6IG51bGwpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTUVSR0VfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogbXV0YXRlZFJlbGV2YW50RXZlbnRzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGxldCBldmVudENoYW5nZUFyZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgb2xkRXZlbnQ6IGV2ZW50QXBpLFxuICAgICAgICAgICAgICAgICAgICBldmVudDogdXBkYXRlZEV2ZW50QXBpLFxuICAgICAgICAgICAgICAgICAgICByZWxhdGVkRXZlbnRzOiBidWlsZEV2ZW50QXBpcyhtdXRhdGVkUmVsZXZhbnRFdmVudHMsIGNvbnRleHQsIGV2ZW50SW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgICAgICByZXZlcnQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTUVSR0VfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlOiByZWxldmFudEV2ZW50cywgLy8gdGhlIHByZS1jaGFuZ2UgZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudFJlc2l6ZScsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRDaGFuZ2VBcmcpLCB7IGVsOiB0aGlzLmRyYWdnaW5nU2VnRWwsIHN0YXJ0RGVsdGE6IHRoaXMudmFsaWRNdXRhdGlvbi5zdGFydERlbHRhIHx8IGNyZWF0ZUR1cmF0aW9uKDApLCBlbmREZWx0YTogdGhpcy52YWxpZE11dGF0aW9uLmVuZERlbHRhIHx8IGNyZWF0ZUR1cmF0aW9uKDApLCBqc0V2ZW50OiBldi5vcmlnRXZlbnQsIHZpZXc6IGNvbnRleHQudmlld0FwaSB9KSk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50Q2hhbmdlJywgZXZlbnRDaGFuZ2VBcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ19ub0V2ZW50UmVzaXplJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZXNldCBhbGwgaW50ZXJuYWwgc3RhdGVcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdTZWcgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5yZWxldmFudEV2ZW50cyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnZhbGlkTXV0YXRpb24gPSBudWxsO1xuICAgICAgICAgICAgLy8gb2theSB0byBrZWVwIGV2ZW50SW5zdGFuY2UgYXJvdW5kLiB1c2VmdWwgdG8gc2V0IGl0IGluIGhhbmRsZVBvaW50ZXJEb3duXG4gICAgICAgIH07XG4gICAgICAgIGxldCB7IGNvbXBvbmVudCB9ID0gc2V0dGluZ3M7XG4gICAgICAgIGxldCBkcmFnZ2luZyA9IHRoaXMuZHJhZ2dpbmcgPSBuZXcgRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZyhzZXR0aW5ncy5lbCk7XG4gICAgICAgIGRyYWdnaW5nLnBvaW50ZXIuc2VsZWN0b3IgPSAnLmZjLWV2ZW50LXJlc2l6ZXInO1xuICAgICAgICBkcmFnZ2luZy50b3VjaFNjcm9sbEFsbG93ZWQgPSBmYWxzZTtcbiAgICAgICAgZHJhZ2dpbmcuYXV0b1Njcm9sbGVyLmlzRW5hYmxlZCA9IGNvbXBvbmVudC5jb250ZXh0Lm9wdGlvbnMuZHJhZ1Njcm9sbDtcbiAgICAgICAgbGV0IGhpdERyYWdnaW5nID0gdGhpcy5oaXREcmFnZ2luZyA9IG5ldyBIaXREcmFnZ2luZyh0aGlzLmRyYWdnaW5nLCBpbnRlcmFjdGlvblNldHRpbmdzVG9TdG9yZShzZXR0aW5ncykpO1xuICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdwb2ludGVyZG93bicsIHRoaXMuaGFuZGxlUG9pbnRlckRvd24pO1xuICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdkcmFnc3RhcnQnLCB0aGlzLmhhbmRsZURyYWdTdGFydCk7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2hpdHVwZGF0ZScsIHRoaXMuaGFuZGxlSGl0VXBkYXRlKTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ2VuZCcsIHRoaXMuaGFuZGxlRHJhZ0VuZCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcuZGVzdHJveSgpO1xuICAgIH1cbiAgICBxdWVyeVNlZ0VsKGV2KSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50Q2xvc2VzdChldi5zdWJqZWN0RWwsICcuZmMtZXZlbnQnKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb21wdXRlTXV0YXRpb24oaGl0MCwgaGl0MSwgaXNGcm9tU3RhcnQsIGluc3RhbmNlUmFuZ2UpIHtcbiAgICBsZXQgZGF0ZUVudiA9IGhpdDAuY29udGV4dC5kYXRlRW52O1xuICAgIGxldCBkYXRlMCA9IGhpdDAuZGF0ZVNwYW4ucmFuZ2Uuc3RhcnQ7XG4gICAgbGV0IGRhdGUxID0gaGl0MS5kYXRlU3Bhbi5yYW5nZS5zdGFydDtcbiAgICBsZXQgZGVsdGEgPSBkaWZmRGF0ZXMoZGF0ZTAsIGRhdGUxLCBkYXRlRW52LCBoaXQwLmxhcmdlVW5pdCk7XG4gICAgaWYgKGlzRnJvbVN0YXJ0KSB7XG4gICAgICAgIGlmIChkYXRlRW52LmFkZChpbnN0YW5jZVJhbmdlLnN0YXJ0LCBkZWx0YSkgPCBpbnN0YW5jZVJhbmdlLmVuZCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnREZWx0YTogZGVsdGEgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChkYXRlRW52LmFkZChpbnN0YW5jZVJhbmdlLmVuZCwgZGVsdGEpID4gaW5zdGFuY2VSYW5nZS5zdGFydCkge1xuICAgICAgICByZXR1cm4geyBlbmREZWx0YTogZGVsdGEgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmNsYXNzIFVuc2VsZWN0QXV0byB7XG4gICAgY29uc3RydWN0b3IoY29udGV4dCkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmlzUmVjZW50UG9pbnRlckRhdGVTZWxlY3QgPSBmYWxzZTsgLy8gd2lzaCB3ZSBjb3VsZCB1c2UgYSBzZWxlY3RvciB0byBkZXRlY3QgZGF0ZSBzZWxlY3Rpb24sIGJ1dCB1c2VzIGhpdCBzeXN0ZW1cbiAgICAgICAgdGhpcy5tYXRjaGVzQ2FuY2VsID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWF0Y2hlc0V2ZW50ID0gZmFsc2U7XG4gICAgICAgIHRoaXMub25TZWxlY3QgPSAoc2VsZWN0SW5mbykgPT4ge1xuICAgICAgICAgICAgaWYgKHNlbGVjdEluZm8uanNFdmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNSZWNlbnRQb2ludGVyRGF0ZVNlbGVjdCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25Eb2N1bWVudFBvaW50ZXJEb3duID0gKHBldikgPT4ge1xuICAgICAgICAgICAgbGV0IHVuc2VsZWN0Q2FuY2VsID0gdGhpcy5jb250ZXh0Lm9wdGlvbnMudW5zZWxlY3RDYW5jZWw7XG4gICAgICAgICAgICBsZXQgZG93bkVsID0gZ2V0RXZlbnRUYXJnZXRWaWFSb290KHBldi5vcmlnRXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5tYXRjaGVzQ2FuY2VsID0gISFlbGVtZW50Q2xvc2VzdChkb3duRWwsIHVuc2VsZWN0Q2FuY2VsKTtcbiAgICAgICAgICAgIHRoaXMubWF0Y2hlc0V2ZW50ID0gISFlbGVtZW50Q2xvc2VzdChkb3duRWwsIEV2ZW50RHJhZ2dpbmcuU0VMRUNUT1IpOyAvLyBpbnRlcmFjdGlvbiBzdGFydGVkIG9uIGFuIGV2ZW50P1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uRG9jdW1lbnRQb2ludGVyVXAgPSAocGV2KSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IHsgZG9jdW1lbnRQb2ludGVyIH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IGNhbGVuZGFyU3RhdGUgPSBjb250ZXh0LmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgICAgICAvLyB0b3VjaC1zY3JvbGxpbmcgc2hvdWxkIG5ldmVyIHVuZm9jdXMgYW55IHR5cGUgb2Ygc2VsZWN0aW9uXG4gICAgICAgICAgICBpZiAoIWRvY3VtZW50UG9pbnRlci53YXNUb3VjaFNjcm9sbCkge1xuICAgICAgICAgICAgICAgIGlmIChjYWxlbmRhclN0YXRlLmRhdGVTZWxlY3Rpb24gJiYgLy8gYW4gZXhpc3RpbmcgZGF0ZSBzZWxlY3Rpb24/XG4gICAgICAgICAgICAgICAgICAgICF0aGlzLmlzUmVjZW50UG9pbnRlckRhdGVTZWxlY3QgLy8gYSBuZXcgcG9pbnRlci1pbml0aWF0ZWQgZGF0ZSBzZWxlY3Rpb24gc2luY2UgbGFzdCBvbkRvY3VtZW50UG9pbnRlclVwP1xuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdW5zZWxlY3RBdXRvID0gY29udGV4dC5vcHRpb25zLnVuc2VsZWN0QXV0bztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVuc2VsZWN0QXV0byAmJiAoIXVuc2VsZWN0QXV0byB8fCAhdGhpcy5tYXRjaGVzQ2FuY2VsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5jYWxlbmRhckFwaS51bnNlbGVjdChwZXYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjYWxlbmRhclN0YXRlLmV2ZW50U2VsZWN0aW9uICYmIC8vIGFuIGV4aXN0aW5nIGV2ZW50IHNlbGVjdGVkP1xuICAgICAgICAgICAgICAgICAgICAhdGhpcy5tYXRjaGVzRXZlbnQgLy8gaW50ZXJhY3Rpb24gRElETidUIHN0YXJ0IG9uIGFuIGV2ZW50XG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRUxFQ1RfRVZFTlQnIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaXNSZWNlbnRQb2ludGVyRGF0ZVNlbGVjdCA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgZG9jdW1lbnRQb2ludGVyID0gdGhpcy5kb2N1bWVudFBvaW50ZXIgPSBuZXcgUG9pbnRlckRyYWdnaW5nKGRvY3VtZW50KTtcbiAgICAgICAgZG9jdW1lbnRQb2ludGVyLnNob3VsZElnbm9yZU1vdmUgPSB0cnVlO1xuICAgICAgICBkb2N1bWVudFBvaW50ZXIuc2hvdWxkV2F0Y2hTY3JvbGwgPSBmYWxzZTtcbiAgICAgICAgZG9jdW1lbnRQb2ludGVyLmVtaXR0ZXIub24oJ3BvaW50ZXJkb3duJywgdGhpcy5vbkRvY3VtZW50UG9pbnRlckRvd24pO1xuICAgICAgICBkb2N1bWVudFBvaW50ZXIuZW1pdHRlci5vbigncG9pbnRlcnVwJywgdGhpcy5vbkRvY3VtZW50UG9pbnRlclVwKTtcbiAgICAgICAgLypcbiAgICAgICAgVE9ETzogYmV0dGVyIHdheSB0byBrbm93IGFib3V0IHdoZXRoZXIgdGhlcmUgd2FzIGEgc2VsZWN0aW9uIHdpdGggdGhlIHBvaW50ZXJcbiAgICAgICAgKi9cbiAgICAgICAgY29udGV4dC5lbWl0dGVyLm9uKCdzZWxlY3QnLCB0aGlzLm9uU2VsZWN0KTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LmVtaXR0ZXIub2ZmKCdzZWxlY3QnLCB0aGlzLm9uU2VsZWN0KTtcbiAgICAgICAgdGhpcy5kb2N1bWVudFBvaW50ZXIuZGVzdHJveSgpO1xuICAgIH1cbn1cblxuY29uc3QgT1BUSU9OX1JFRklORVJTID0ge1xuICAgIGZpeGVkTWlycm9yUGFyZW50OiBpZGVudGl0eSxcbn07XG5jb25zdCBMSVNURU5FUl9SRUZJTkVSUyA9IHtcbiAgICBkYXRlQ2xpY2s6IGlkZW50aXR5LFxuICAgIGV2ZW50RHJhZ1N0YXJ0OiBpZGVudGl0eSxcbiAgICBldmVudERyYWdTdG9wOiBpZGVudGl0eSxcbiAgICBldmVudERyb3A6IGlkZW50aXR5LFxuICAgIGV2ZW50UmVzaXplU3RhcnQ6IGlkZW50aXR5LFxuICAgIGV2ZW50UmVzaXplU3RvcDogaWRlbnRpdHksXG4gICAgZXZlbnRSZXNpemU6IGlkZW50aXR5LFxuICAgIGRyb3A6IGlkZW50aXR5LFxuICAgIGV2ZW50UmVjZWl2ZTogaWRlbnRpdHksXG4gICAgZXZlbnRMZWF2ZTogaWRlbnRpdHksXG59O1xuXG4vKlxuR2l2ZW4gYW4gYWxyZWFkeSBpbnN0YW50aWF0ZWQgZHJhZ2dhYmxlIG9iamVjdCBmb3Igb25lLW9yLW1vcmUgZWxlbWVudHMsXG5JbnRlcnByZXRzIGFueSBkcmFnZ2luZyBhcyBhbiBhdHRlbXB0IHRvIGRyYWcgYW4gZXZlbnRzIHRoYXQgbGl2ZXMgb3V0c2lkZVxub2YgYSBjYWxlbmRhciBvbnRvIGEgY2FsZW5kYXIuXG4qL1xuY2xhc3MgRXh0ZXJuYWxFbGVtZW50RHJhZ2dpbmcge1xuICAgIGNvbnN0cnVjdG9yKGRyYWdnaW5nLCBzdXBwbGllZERyYWdNZXRhKSB7XG4gICAgICAgIHRoaXMucmVjZWl2aW5nQ29udGV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMuZHJvcHBhYmxlRXZlbnQgPSBudWxsOyAvLyB3aWxsIGV4aXN0IGZvciBhbGwgZHJhZ3MsIGV2ZW4gaWYgY3JlYXRlOmZhbHNlXG4gICAgICAgIHRoaXMuc3VwcGxpZWREcmFnTWV0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuZHJhZ01ldGEgPSBudWxsO1xuICAgICAgICB0aGlzLmhhbmRsZURyYWdTdGFydCA9IChldikgPT4ge1xuICAgICAgICAgICAgdGhpcy5kcmFnTWV0YSA9IHRoaXMuYnVpbGREcmFnTWV0YShldi5zdWJqZWN0RWwpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUhpdFVwZGF0ZSA9IChoaXQsIGlzRmluYWwsIGV2KSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBkcmFnZ2luZyB9ID0gdGhpcy5oaXREcmFnZ2luZztcbiAgICAgICAgICAgIGxldCByZWNlaXZpbmdDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBkcm9wcGFibGVFdmVudCA9IG51bGw7XG4gICAgICAgICAgICBsZXQgaXNJbnZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgaW50ZXJhY3Rpb24gPSB7XG4gICAgICAgICAgICAgICAgYWZmZWN0ZWRFdmVudHM6IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpLFxuICAgICAgICAgICAgICAgIG11dGF0ZWRFdmVudHM6IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpLFxuICAgICAgICAgICAgICAgIGlzRXZlbnQ6IHRoaXMuZHJhZ01ldGEuY3JlYXRlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChoaXQpIHtcbiAgICAgICAgICAgICAgICByZWNlaXZpbmdDb250ZXh0ID0gaGl0LmNvbnRleHQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FuRHJvcEVsT25DYWxlbmRhcihldi5zdWJqZWN0RWwsIHJlY2VpdmluZ0NvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRyb3BwYWJsZUV2ZW50ID0gY29tcHV0ZUV2ZW50Rm9yRGF0ZVNwYW4oaGl0LmRhdGVTcGFuLCB0aGlzLmRyYWdNZXRhLCByZWNlaXZpbmdDb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cyA9IGV2ZW50VHVwbGVUb1N0b3JlKGRyb3BwYWJsZUV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaXNJbnZhbGlkID0gIWlzSW50ZXJhY3Rpb25WYWxpZChpbnRlcmFjdGlvbiwgaGl0LmRhdGVQcm9maWxlLCByZWNlaXZpbmdDb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSW52YWxpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cyA9IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJvcHBhYmxlRXZlbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kaXNwbGF5RHJhZyhyZWNlaXZpbmdDb250ZXh0LCBpbnRlcmFjdGlvbik7XG4gICAgICAgICAgICAvLyBzaG93IG1pcnJvciBpZiBubyBhbHJlYWR5LXJlbmRlcmVkIG1pcnJvciBlbGVtZW50IE9SIGlmIHdlIGFyZSBzaHV0dGluZyBkb3duIHRoZSBtaXJyb3IgKD8pXG4gICAgICAgICAgICAvLyBUT0RPOiB3aXNoIHdlIGNvdWxkIHNvbWVob3cgd2FpdCBmb3IgZGlzcGF0Y2ggdG8gZ3VhcmFudGVlIHJlbmRlclxuICAgICAgICAgICAgZHJhZ2dpbmcuc2V0TWlycm9ySXNWaXNpYmxlKGlzRmluYWwgfHwgIWRyb3BwYWJsZUV2ZW50IHx8ICFkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZmMtZXZlbnQtbWlycm9yJykpO1xuICAgICAgICAgICAgaWYgKCFpc0ludmFsaWQpIHtcbiAgICAgICAgICAgICAgICBlbmFibGVDdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpc2FibGVDdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNGaW5hbCkge1xuICAgICAgICAgICAgICAgIGRyYWdnaW5nLnNldE1pcnJvck5lZWRzUmV2ZXJ0KCFkcm9wcGFibGVFdmVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNlaXZpbmdDb250ZXh0ID0gcmVjZWl2aW5nQ29udGV4dDtcbiAgICAgICAgICAgICAgICB0aGlzLmRyb3BwYWJsZUV2ZW50ID0gZHJvcHBhYmxlRXZlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlRHJhZ0VuZCA9IChwZXYpID0+IHtcbiAgICAgICAgICAgIGxldCB7IHJlY2VpdmluZ0NvbnRleHQsIGRyb3BwYWJsZUV2ZW50IH0gPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5jbGVhckRyYWcoKTtcbiAgICAgICAgICAgIGlmIChyZWNlaXZpbmdDb250ZXh0ICYmIGRyb3BwYWJsZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IGZpbmFsSGl0ID0gdGhpcy5oaXREcmFnZ2luZy5maW5hbEhpdDtcbiAgICAgICAgICAgICAgICBsZXQgZmluYWxWaWV3ID0gZmluYWxIaXQuY29udGV4dC52aWV3QXBpO1xuICAgICAgICAgICAgICAgIGxldCBkcmFnTWV0YSA9IHRoaXMuZHJhZ01ldGE7XG4gICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2Ryb3AnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJ1aWxkRGF0ZVBvaW50QXBpV2l0aENvbnRleHQoZmluYWxIaXQuZGF0ZVNwYW4sIHJlY2VpdmluZ0NvbnRleHQpKSwgeyBkcmFnZ2VkRWw6IHBldi5zdWJqZWN0RWwsIGpzRXZlbnQ6IHBldi5vcmlnRXZlbnQsIHZpZXc6IGZpbmFsVmlldyB9KSk7XG4gICAgICAgICAgICAgICAgaWYgKGRyYWdNZXRhLmNyZWF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWRkaW5nRXZlbnRzID0gZXZlbnRUdXBsZVRvU3RvcmUoZHJvcHBhYmxlRXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICByZWNlaXZpbmdDb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdNRVJHRV9FVkVOVFMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogYWRkaW5nRXZlbnRzLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBldi5pc1RvdWNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZpbmdDb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnU0VMRUNUX0VWRU5UJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudEluc3RhbmNlSWQ6IGRyb3BwYWJsZUV2ZW50Lmluc3RhbmNlLmluc3RhbmNlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBzaWduYWwgdGhhdCBhbiBleHRlcm5hbCBldmVudCBsYW5kZWRcbiAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50UmVjZWl2ZScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBuZXcgRXZlbnRJbXBsKHJlY2VpdmluZ0NvbnRleHQsIGRyb3BwYWJsZUV2ZW50LmRlZiwgZHJvcHBhYmxlRXZlbnQuaW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRlZEV2ZW50czogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICByZXZlcnQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdSRU1PVkVfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogYWRkaW5nRXZlbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdnZWRFbDogcGV2LnN1YmplY3RFbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXc6IGZpbmFsVmlldyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWNlaXZpbmdDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZHJvcHBhYmxlRXZlbnQgPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgaGl0RHJhZ2dpbmcgPSB0aGlzLmhpdERyYWdnaW5nID0gbmV3IEhpdERyYWdnaW5nKGRyYWdnaW5nLCBpbnRlcmFjdGlvblNldHRpbmdzU3RvcmUpO1xuICAgICAgICBoaXREcmFnZ2luZy5yZXF1aXJlSW5pdGlhbCA9IGZhbHNlOyAvLyB3aWxsIHN0YXJ0IG91dHNpZGUgb2YgYSBjb21wb25lbnRcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ3N0YXJ0JywgdGhpcy5oYW5kbGVEcmFnU3RhcnQpO1xuICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdoaXR1cGRhdGUnLCB0aGlzLmhhbmRsZUhpdFVwZGF0ZSk7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdlbmQnLCB0aGlzLmhhbmRsZURyYWdFbmQpO1xuICAgICAgICB0aGlzLnN1cHBsaWVkRHJhZ01ldGEgPSBzdXBwbGllZERyYWdNZXRhO1xuICAgIH1cbiAgICBidWlsZERyYWdNZXRhKHN1YmplY3RFbCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuc3VwcGxpZWREcmFnTWV0YSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZURyYWdNZXRhKHRoaXMuc3VwcGxpZWREcmFnTWV0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnN1cHBsaWVkRHJhZ01ldGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZURyYWdNZXRhKHRoaXMuc3VwcGxpZWREcmFnTWV0YShzdWJqZWN0RWwpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0RHJhZ01ldGFGcm9tRWwoc3ViamVjdEVsKTtcbiAgICB9XG4gICAgZGlzcGxheURyYWcobmV4dENvbnRleHQsIHN0YXRlKSB7XG4gICAgICAgIGxldCBwcmV2Q29udGV4dCA9IHRoaXMucmVjZWl2aW5nQ29udGV4dDtcbiAgICAgICAgaWYgKHByZXZDb250ZXh0ICYmIHByZXZDb250ZXh0ICE9PSBuZXh0Q29udGV4dCkge1xuICAgICAgICAgICAgcHJldkNvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRVRfRVZFTlRfRFJBRycgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHRDb250ZXh0KSB7XG4gICAgICAgICAgICBuZXh0Q29udGV4dC5kaXNwYXRjaCh7IHR5cGU6ICdTRVRfRVZFTlRfRFJBRycsIHN0YXRlIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsZWFyRHJhZygpIHtcbiAgICAgICAgaWYgKHRoaXMucmVjZWl2aW5nQ29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5yZWNlaXZpbmdDb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1VOU0VUX0VWRU5UX0RSQUcnIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhbkRyb3BFbE9uQ2FsZW5kYXIoZWwsIHJlY2VpdmluZ0NvbnRleHQpIHtcbiAgICAgICAgbGV0IGRyb3BBY2NlcHQgPSByZWNlaXZpbmdDb250ZXh0Lm9wdGlvbnMuZHJvcEFjY2VwdDtcbiAgICAgICAgaWYgKHR5cGVvZiBkcm9wQWNjZXB0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gZHJvcEFjY2VwdC5jYWxsKHJlY2VpdmluZ0NvbnRleHQuY2FsZW5kYXJBcGksIGVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRyb3BBY2NlcHQgPT09ICdzdHJpbmcnICYmIGRyb3BBY2NlcHQpIHtcbiAgICAgICAgICAgIHJldHVybiBCb29sZWFuKGVsZW1lbnRNYXRjaGVzKGVsLCBkcm9wQWNjZXB0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuLy8gVXRpbHMgZm9yIGNvbXB1dGluZyBldmVudCBzdG9yZSBmcm9tIHRoZSBEcmFnTWV0YVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gY29tcHV0ZUV2ZW50Rm9yRGF0ZVNwYW4oZGF0ZVNwYW4sIGRyYWdNZXRhLCBjb250ZXh0KSB7XG4gICAgbGV0IGRlZlByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgZHJhZ01ldGEubGVmdG92ZXJQcm9wcyk7XG4gICAgZm9yIChsZXQgdHJhbnNmb3JtIG9mIGNvbnRleHQucGx1Z2luSG9va3MuZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oZGVmUHJvcHMsIHRyYW5zZm9ybShkYXRlU3BhbiwgZHJhZ01ldGEpKTtcbiAgICB9XG4gICAgbGV0IHsgcmVmaW5lZCwgZXh0cmEgfSA9IHJlZmluZUV2ZW50RGVmKGRlZlByb3BzLCBjb250ZXh0KTtcbiAgICBsZXQgZGVmID0gcGFyc2VFdmVudERlZihyZWZpbmVkLCBleHRyYSwgZHJhZ01ldGEuc291cmNlSWQsIGRhdGVTcGFuLmFsbERheSwgY29udGV4dC5vcHRpb25zLmZvcmNlRXZlbnREdXJhdGlvbiB8fCBCb29sZWFuKGRyYWdNZXRhLmR1cmF0aW9uKSwgLy8gaGFzRW5kXG4gICAgY29udGV4dCk7XG4gICAgbGV0IHN0YXJ0ID0gZGF0ZVNwYW4ucmFuZ2Uuc3RhcnQ7XG4gICAgLy8gb25seSByZWx5IG9uIHRpbWUgaW5mbyBpZiBkcm9wIHpvbmUgaXMgYWxsLWRheSxcbiAgICAvLyBvdGhlcndpc2UsIHdlIGFscmVhZHkga25vdyB0aGUgdGltZVxuICAgIGlmIChkYXRlU3Bhbi5hbGxEYXkgJiYgZHJhZ01ldGEuc3RhcnRUaW1lKSB7XG4gICAgICAgIHN0YXJ0ID0gY29udGV4dC5kYXRlRW52LmFkZChzdGFydCwgZHJhZ01ldGEuc3RhcnRUaW1lKTtcbiAgICB9XG4gICAgbGV0IGVuZCA9IGRyYWdNZXRhLmR1cmF0aW9uID9cbiAgICAgICAgY29udGV4dC5kYXRlRW52LmFkZChzdGFydCwgZHJhZ01ldGEuZHVyYXRpb24pIDpcbiAgICAgICAgZ2V0RGVmYXVsdEV2ZW50RW5kKGRhdGVTcGFuLmFsbERheSwgc3RhcnQsIGNvbnRleHQpO1xuICAgIGxldCBpbnN0YW5jZSA9IGNyZWF0ZUV2ZW50SW5zdGFuY2UoZGVmLmRlZklkLCB7IHN0YXJ0LCBlbmQgfSk7XG4gICAgcmV0dXJuIHsgZGVmLCBpbnN0YW5jZSB9O1xufVxuLy8gVXRpbHMgZm9yIGV4dHJhY3RpbmcgZGF0YSBmcm9tIGVsZW1lbnRcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGdldERyYWdNZXRhRnJvbUVsKGVsKSB7XG4gICAgbGV0IHN0ciA9IGdldEVtYmVkZGVkRWxEYXRhKGVsLCAnZXZlbnQnKTtcbiAgICBsZXQgb2JqID0gc3RyID9cbiAgICAgICAgSlNPTi5wYXJzZShzdHIpIDpcbiAgICAgICAgeyBjcmVhdGU6IGZhbHNlIH07IC8vIGlmIG5vIGVtYmVkZGVkIGRhdGEsIGFzc3VtZSBubyBldmVudCBjcmVhdGlvblxuICAgIHJldHVybiBwYXJzZURyYWdNZXRhKG9iaik7XG59XG5jb25maWcuZGF0YUF0dHJQcmVmaXggPSAnJztcbmZ1bmN0aW9uIGdldEVtYmVkZGVkRWxEYXRhKGVsLCBuYW1lKSB7XG4gICAgbGV0IHByZWZpeCA9IGNvbmZpZy5kYXRhQXR0clByZWZpeDtcbiAgICBsZXQgcHJlZml4ZWROYW1lID0gKHByZWZpeCA/IHByZWZpeCArICctJyA6ICcnKSArIG5hbWU7XG4gICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZSgnZGF0YS0nICsgcHJlZml4ZWROYW1lKSB8fCAnJztcbn1cblxuLypcbk1ha2VzIGFuIGVsZW1lbnQgKHRoYXQgaXMgKmV4dGVybmFsKiB0byBhbnkgY2FsZW5kYXIpIGRyYWdnYWJsZS5cbkNhbiBwYXNzIGluIGRhdGEgdGhhdCBkZXRlcm1pbmVzIGhvdyBhbiBldmVudCB3aWxsIGJlIGNyZWF0ZWQgd2hlbiBkcm9wcGVkIG9udG8gYSBjYWxlbmRhci5cbkxldmVyYWdlcyBGdWxsQ2FsZW5kYXIncyBpbnRlcm5hbCBkcmFnLW4tZHJvcCBmdW5jdGlvbmFsaXR5IFdJVEhPVVQgYSB0aGlyZC1wYXJ0eSBkcmFnIHN5c3RlbS5cbiovXG5jbGFzcyBFeHRlcm5hbERyYWdnYWJsZSB7XG4gICAgY29uc3RydWN0b3IoZWwsIHNldHRpbmdzID0ge30pIHtcbiAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyRG93biA9IChldikgPT4ge1xuICAgICAgICAgICAgbGV0IHsgZHJhZ2dpbmcgfSA9IHRoaXM7XG4gICAgICAgICAgICBsZXQgeyBtaW5EaXN0YW5jZSwgbG9uZ1ByZXNzRGVsYXkgfSA9IHRoaXMuc2V0dGluZ3M7XG4gICAgICAgICAgICBkcmFnZ2luZy5taW5EaXN0YW5jZSA9XG4gICAgICAgICAgICAgICAgbWluRGlzdGFuY2UgIT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgICAgIG1pbkRpc3RhbmNlIDpcbiAgICAgICAgICAgICAgICAgICAgKGV2LmlzVG91Y2ggPyAwIDogQkFTRV9PUFRJT05fREVGQVVMVFMuZXZlbnREcmFnTWluRGlzdGFuY2UpO1xuICAgICAgICAgICAgZHJhZ2dpbmcuZGVsYXkgPVxuICAgICAgICAgICAgICAgIGV2LmlzVG91Y2ggPyAvLyBUT0RPOiBldmVudHVhbGx5IHJlYWQgZXZlbnRMb25nUHJlc3NEZWxheSBpbnN0ZWFkIHZ2dlxuICAgICAgICAgICAgICAgICAgICAobG9uZ1ByZXNzRGVsYXkgIT0gbnVsbCA/IGxvbmdQcmVzc0RlbGF5IDogQkFTRV9PUFRJT05fREVGQVVMVFMubG9uZ1ByZXNzRGVsYXkpIDpcbiAgICAgICAgICAgICAgICAgICAgMDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVEcmFnU3RhcnQgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGlmIChldi5pc1RvdWNoICYmXG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZy5kZWxheSAmJlxuICAgICAgICAgICAgICAgIGV2LnN1YmplY3RFbC5jbGFzc0xpc3QuY29udGFpbnMoJ2ZjLWV2ZW50JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdnaW5nLm1pcnJvci5nZXRNaXJyb3JFbCgpLmNsYXNzTGlzdC5hZGQoJ2ZjLWV2ZW50LXNlbGVjdGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICAgICAgbGV0IGRyYWdnaW5nID0gdGhpcy5kcmFnZ2luZyA9IG5ldyBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nKGVsKTtcbiAgICAgICAgZHJhZ2dpbmcudG91Y2hTY3JvbGxBbGxvd2VkID0gZmFsc2U7XG4gICAgICAgIGlmIChzZXR0aW5ncy5pdGVtU2VsZWN0b3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgZHJhZ2dpbmcucG9pbnRlci5zZWxlY3RvciA9IHNldHRpbmdzLml0ZW1TZWxlY3RvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0dGluZ3MuYXBwZW5kVG8gIT0gbnVsbCkge1xuICAgICAgICAgICAgZHJhZ2dpbmcubWlycm9yLnBhcmVudE5vZGUgPSBzZXR0aW5ncy5hcHBlbmRUbzsgLy8gVE9ETzogd3JpdGUgdGVzdHNcbiAgICAgICAgfVxuICAgICAgICBkcmFnZ2luZy5lbWl0dGVyLm9uKCdwb2ludGVyZG93bicsIHRoaXMuaGFuZGxlUG9pbnRlckRvd24pO1xuICAgICAgICBkcmFnZ2luZy5lbWl0dGVyLm9uKCdkcmFnc3RhcnQnLCB0aGlzLmhhbmRsZURyYWdTdGFydCk7XG4gICAgICAgIG5ldyBFeHRlcm5hbEVsZW1lbnREcmFnZ2luZyhkcmFnZ2luZywgc2V0dGluZ3MuZXZlbnREYXRhKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kcmFnZ2luZy5kZXN0cm95KCk7XG4gICAgfVxufVxuXG4vKlxuRGV0ZWN0cyB3aGVuIGEgKlRISVJELVBBUlRZKiBkcmFnLW4tZHJvcCBzeXN0ZW0gaW50ZXJhY3RzIHdpdGggZWxlbWVudHMuXG5UaGUgdGhpcmQtcGFydHkgc3lzdGVtIGlzIHJlc3BvbnNpYmxlIGZvciBkcmF3aW5nIHRoZSB2aXN1YWxzIGVmZmVjdHMgb2YgdGhlIGRyYWcuXG5UaGlzIGNsYXNzIHNpbXBseSBtb25pdG9ycyBmb3IgcG9pbnRlciBtb3ZlbWVudHMgYW5kIGZpcmVzIGV2ZW50cy5cbkl0IGFsc28gaGFzIHRoZSBhYmlsaXR5IHRvIGhpZGUgdGhlIG1vdmluZyBlbGVtZW50ICh0aGUgXCJtaXJyb3JcIikgZHVyaW5nIHRoZSBkcmFnLlxuKi9cbmNsYXNzIEluZmVycmVkRWxlbWVudERyYWdnaW5nIGV4dGVuZHMgRWxlbWVudERyYWdnaW5nIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXJFbCkge1xuICAgICAgICBzdXBlcihjb250YWluZXJFbCk7XG4gICAgICAgIHRoaXMuc2hvdWxkSWdub3JlTW92ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1pcnJvclNlbGVjdG9yID0gJyc7XG4gICAgICAgIHRoaXMuY3VycmVudE1pcnJvckVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyRG93biA9IChldikgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJkb3duJywgZXYpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnNob3VsZElnbm9yZU1vdmUpIHtcbiAgICAgICAgICAgICAgICAvLyBmaXJlIGRyYWdzdGFydCByaWdodCBhd2F5LiBkb2VzIG5vdCBzdXBwb3J0IGRlbGF5IG9yIG1pbi1kaXN0YW5jZVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdkcmFnc3RhcnQnLCBldik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlck1vdmUgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zaG91bGRJZ25vcmVNb3ZlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2RyYWdtb3ZlJywgZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJVcCA9IChldikgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJ1cCcsIGV2KTtcbiAgICAgICAgICAgIGlmICghdGhpcy5zaG91bGRJZ25vcmVNb3ZlKSB7XG4gICAgICAgICAgICAgICAgLy8gZmlyZSBkcmFnZW5kIHJpZ2h0IGF3YXkuIGRvZXMgbm90IHN1cHBvcnQgYSByZXZlcnQgYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2RyYWdlbmQnLCBldik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGxldCBwb2ludGVyID0gdGhpcy5wb2ludGVyID0gbmV3IFBvaW50ZXJEcmFnZ2luZyhjb250YWluZXJFbCk7XG4gICAgICAgIHBvaW50ZXIuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCB0aGlzLmhhbmRsZVBvaW50ZXJEb3duKTtcbiAgICAgICAgcG9pbnRlci5lbWl0dGVyLm9uKCdwb2ludGVybW92ZScsIHRoaXMuaGFuZGxlUG9pbnRlck1vdmUpO1xuICAgICAgICBwb2ludGVyLmVtaXR0ZXIub24oJ3BvaW50ZXJ1cCcsIHRoaXMuaGFuZGxlUG9pbnRlclVwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5wb2ludGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgc2V0SWdub3JlTW92ZShib29sKSB7XG4gICAgICAgIHRoaXMuc2hvdWxkSWdub3JlTW92ZSA9IGJvb2w7XG4gICAgfVxuICAgIHNldE1pcnJvcklzVmlzaWJsZShib29sKSB7XG4gICAgICAgIGlmIChib29sKSB7XG4gICAgICAgICAgICAvLyByZXN0b3JlIGEgcHJldmlvdXNseSBoaWRkZW4gZWxlbWVudC5cbiAgICAgICAgICAgIC8vIHVzZSB0aGUgcmVmZXJlbmNlIGluIGNhc2UgdGhlIHNlbGVjdG9yIGNsYXNzIGhhcyBhbHJlYWR5IGJlZW4gcmVtb3ZlZC5cbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRNaXJyb3JFbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudE1pcnJvckVsLnN0eWxlLnZpc2liaWxpdHkgPSAnJztcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRNaXJyb3JFbCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbWlycm9yRWwgPSB0aGlzLm1pcnJvclNlbGVjdG9yXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogc29tZWhvdyBxdWVyeSBGdWxsQ2FsZW5kYXJzIFdJVEhJTiBzaGFkb3ctcm9vdHNcbiAgICAgICAgICAgICAgICA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5taXJyb3JTZWxlY3RvcilcbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICBpZiAobWlycm9yRWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRNaXJyb3JFbCA9IG1pcnJvckVsO1xuICAgICAgICAgICAgICAgIG1pcnJvckVsLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuLypcbkJyaWRnZXMgdGhpcmQtcGFydHkgZHJhZy1uLWRyb3Agc3lzdGVtcyB3aXRoIEZ1bGxDYWxlbmRhci5cbk11c3QgYmUgaW5zdGFudGlhdGVkIGFuZCBkZXN0cm95ZWQgYnkgY2FsbGVyLlxuKi9cbmNsYXNzIFRoaXJkUGFydHlEcmFnZ2FibGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lck9yU2V0dGluZ3MsIHNldHRpbmdzKSB7XG4gICAgICAgIGxldCBjb250YWluZXJFbCA9IGRvY3VtZW50O1xuICAgICAgICBpZiAoXG4gICAgICAgIC8vIHdpc2ggd2UgY291bGQganVzdCB0ZXN0IGluc3RhbmNlb2YgRXZlbnRUYXJnZXQsIGJ1dCBkb2Vzbid0IHdvcmsgaW4gSUUxMVxuICAgICAgICBjb250YWluZXJPclNldHRpbmdzID09PSBkb2N1bWVudCB8fFxuICAgICAgICAgICAgY29udGFpbmVyT3JTZXR0aW5ncyBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lckVsID0gY29udGFpbmVyT3JTZXR0aW5ncztcbiAgICAgICAgICAgIHNldHRpbmdzID0gc2V0dGluZ3MgfHwge307XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXR0aW5ncyA9IChjb250YWluZXJPclNldHRpbmdzIHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZHJhZ2dpbmcgPSB0aGlzLmRyYWdnaW5nID0gbmV3IEluZmVycmVkRWxlbWVudERyYWdnaW5nKGNvbnRhaW5lckVsKTtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5pdGVtU2VsZWN0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBkcmFnZ2luZy5wb2ludGVyLnNlbGVjdG9yID0gc2V0dGluZ3MuaXRlbVNlbGVjdG9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbnRhaW5lckVsID09PSBkb2N1bWVudCkge1xuICAgICAgICAgICAgZHJhZ2dpbmcucG9pbnRlci5zZWxlY3RvciA9ICdbZGF0YS1ldmVudF0nO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MubWlycm9yU2VsZWN0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBkcmFnZ2luZy5taXJyb3JTZWxlY3RvciA9IHNldHRpbmdzLm1pcnJvclNlbGVjdG9yO1xuICAgICAgICB9XG4gICAgICAgIGxldCBleHRlcm5hbERyYWdnaW5nID0gbmV3IEV4dGVybmFsRWxlbWVudERyYWdnaW5nKGRyYWdnaW5nLCBzZXR0aW5ncy5ldmVudERhdGEpO1xuICAgICAgICAvLyBUaGUgaGl0LWRldGVjdGlvbiBzeXN0ZW0gcmVxdWlyZXMgdGhhdCB0aGUgZG5kLW1pcnJvci1lbGVtZW50IGJlIHBvaW50ZXItZXZlbnRzOm5vbmUsXG4gICAgICAgIC8vIGJ1dCB0aGlzIGNhbid0IGJlIGd1YXJhbnRlZWQgZm9yIHRoaXJkLXBhcnR5IGRyYWdnYWJsZXMsIHNvIGRpc2FibGVcbiAgICAgICAgZXh0ZXJuYWxEcmFnZ2luZy5oaXREcmFnZ2luZy5kaXNhYmxlUG9pbnRDaGVjayA9IHRydWU7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcuZGVzdHJveSgpO1xuICAgIH1cbn1cblxudmFyIGluZGV4ID0gY3JlYXRlUGx1Z2luKHtcbiAgICBuYW1lOiAnQGZ1bGxjYWxlbmRhci9pbnRlcmFjdGlvbicsXG4gICAgY29tcG9uZW50SW50ZXJhY3Rpb25zOiBbRGF0ZUNsaWNraW5nLCBEYXRlU2VsZWN0aW5nLCBFdmVudERyYWdnaW5nLCBFdmVudFJlc2l6aW5nXSxcbiAgICBjYWxlbmRhckludGVyYWN0aW9uczogW1Vuc2VsZWN0QXV0b10sXG4gICAgZWxlbWVudERyYWdnaW5nSW1wbDogRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZyxcbiAgICBvcHRpb25SZWZpbmVyczogT1BUSU9OX1JFRklORVJTLFxuICAgIGxpc3RlbmVyUmVmaW5lcnM6IExJU1RFTkVSX1JFRklORVJTLFxufSk7XG5cbmV4cG9ydCB7IEV4dGVybmFsRHJhZ2dhYmxlIGFzIERyYWdnYWJsZSwgVGhpcmRQYXJ0eURyYWdnYWJsZSwgaW5kZXggYXMgZGVmYXVsdCB9O1xuIiwgImltcG9ydCB7IEpzb25SZXF1ZXN0RXJyb3IsIGNyZWF0ZVBsdWdpbiB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29yZS9pbmRleC5qcyc7XG5pbXBvcnQgeyByZXF1ZXN0SnNvbiwgYWRkRGF5cywgaWRlbnRpdHkgfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvcmUvaW50ZXJuYWwuanMnO1xuXG4vLyBUT0RPOiBleHBvc2Ugc29tZWhvd1xuY29uc3QgQVBJX0JBU0UgPSAnaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vY2FsZW5kYXIvdjMvY2FsZW5kYXJzJztcbmNvbnN0IGV2ZW50U291cmNlRGVmID0ge1xuICAgIHBhcnNlTWV0YShyZWZpbmVkKSB7XG4gICAgICAgIGxldCB7IGdvb2dsZUNhbGVuZGFySWQgfSA9IHJlZmluZWQ7XG4gICAgICAgIGlmICghZ29vZ2xlQ2FsZW5kYXJJZCAmJiByZWZpbmVkLnVybCkge1xuICAgICAgICAgICAgZ29vZ2xlQ2FsZW5kYXJJZCA9IHBhcnNlR29vZ2xlQ2FsZW5kYXJJZChyZWZpbmVkLnVybCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdvb2dsZUNhbGVuZGFySWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlQ2FsZW5kYXJJZCxcbiAgICAgICAgICAgICAgICBnb29nbGVDYWxlbmRhckFwaUtleTogcmVmaW5lZC5nb29nbGVDYWxlbmRhckFwaUtleSxcbiAgICAgICAgICAgICAgICBnb29nbGVDYWxlbmRhckFwaUJhc2U6IHJlZmluZWQuZ29vZ2xlQ2FsZW5kYXJBcGlCYXNlLFxuICAgICAgICAgICAgICAgIGV4dHJhUGFyYW1zOiByZWZpbmVkLmV4dHJhUGFyYW1zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGZldGNoKGFyZywgc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgICAgIGxldCB7IGRhdGVFbnYsIG9wdGlvbnMgfSA9IGFyZy5jb250ZXh0O1xuICAgICAgICBsZXQgbWV0YSA9IGFyZy5ldmVudFNvdXJjZS5tZXRhO1xuICAgICAgICBsZXQgYXBpS2V5ID0gbWV0YS5nb29nbGVDYWxlbmRhckFwaUtleSB8fCBvcHRpb25zLmdvb2dsZUNhbGVuZGFyQXBpS2V5O1xuICAgICAgICBpZiAoIWFwaUtleSkge1xuICAgICAgICAgICAgZXJyb3JDYWxsYmFjayhuZXcgRXJyb3IoJ1NwZWNpZnkgYSBnb29nbGVDYWxlbmRhckFwaUtleS4gU2VlIGh0dHBzOi8vZnVsbGNhbGVuZGFyLmlvL2RvY3MvZ29vZ2xlLWNhbGVuZGFyJykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHVybCA9IGJ1aWxkVXJsKG1ldGEpO1xuICAgICAgICAgICAgLy8gVE9ETzogbWFrZSBEUlkgd2l0aCBqc29uLWZlZWQtZXZlbnQtc291cmNlXG4gICAgICAgICAgICBsZXQgeyBleHRyYVBhcmFtcyB9ID0gbWV0YTtcbiAgICAgICAgICAgIGxldCBleHRyYVBhcmFtc09iaiA9IHR5cGVvZiBleHRyYVBhcmFtcyA9PT0gJ2Z1bmN0aW9uJyA/IGV4dHJhUGFyYW1zKCkgOiBleHRyYVBhcmFtcztcbiAgICAgICAgICAgIGxldCByZXF1ZXN0UGFyYW1zID0gYnVpbGRSZXF1ZXN0UGFyYW1zKGFyZy5yYW5nZSwgYXBpS2V5LCBleHRyYVBhcmFtc09iaiwgZGF0ZUVudik7XG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdEpzb24oJ0dFVCcsIHVybCwgcmVxdWVzdFBhcmFtcykudGhlbigoW2JvZHksIHJlc3BvbnNlXSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChib2R5LmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yQ2FsbGJhY2sobmV3IEpzb25SZXF1ZXN0RXJyb3IoJ0dvb2dsZSBDYWxlbmRhciBBUEk6ICcgKyBib2R5LmVycm9yLm1lc3NhZ2UsIHJlc3BvbnNlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzQ2FsbGJhY2soe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmF3RXZlbnRzOiBnY2FsSXRlbXNUb1Jhd0V2ZW50RGVmcyhib2R5Lml0ZW1zLCByZXF1ZXN0UGFyYW1zLnRpbWVab25lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBlcnJvckNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZnVuY3Rpb24gcGFyc2VHb29nbGVDYWxlbmRhcklkKHVybCkge1xuICAgIGxldCBtYXRjaDtcbiAgICAvLyBkZXRlY3QgaWYgdGhlIElEIHdhcyBzcGVjaWZpZWQgYXMgYSBzaW5nbGUgc3RyaW5nLlxuICAgIC8vIHdpbGwgbWF0Y2ggY2FsZW5kYXJzIGxpa2UgXCJhc2RmMTIzNEBjYWxlbmRhci5nb29nbGUuY29tXCIgaW4gYWRkaXRpb24gdG8gcGVyc29uIGVtYWlsIGNhbGVuZGFycy5cbiAgICBpZiAoL15bXi9dK0AoW14vLl0rXFwuKSooZ29vZ2xlfGdvb2dsZW1haWx8Z21haWwpXFwuY29tJC8udGVzdCh1cmwpKSB7XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuICAgIGlmICgobWF0Y2ggPSAvXmh0dHBzOlxcL1xcL3d3dy5nb29nbGVhcGlzLmNvbVxcL2NhbGVuZGFyXFwvdjNcXC9jYWxlbmRhcnNcXC8oW14vXSopLy5leGVjKHVybCkpIHx8XG4gICAgICAgIChtYXRjaCA9IC9eaHR0cHM/OlxcL1xcL3d3dy5nb29nbGUuY29tXFwvY2FsZW5kYXJcXC9mZWVkc1xcLyhbXi9dKikvLmV4ZWModXJsKSkpIHtcbiAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFsxXSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gYnVpbGRVcmwobWV0YSkge1xuICAgIGxldCBhcGlCYXNlID0gbWV0YS5nb29nbGVDYWxlbmRhckFwaUJhc2U7XG4gICAgaWYgKCFhcGlCYXNlKSB7XG4gICAgICAgIGFwaUJhc2UgPSBBUElfQkFTRTtcbiAgICB9XG4gICAgcmV0dXJuIGFwaUJhc2UgKyAnLycgKyBlbmNvZGVVUklDb21wb25lbnQobWV0YS5nb29nbGVDYWxlbmRhcklkKSArICcvZXZlbnRzJztcbn1cbmZ1bmN0aW9uIGJ1aWxkUmVxdWVzdFBhcmFtcyhyYW5nZSwgYXBpS2V5LCBleHRyYVBhcmFtcywgZGF0ZUVudikge1xuICAgIGxldCBwYXJhbXM7XG4gICAgbGV0IHN0YXJ0U3RyO1xuICAgIGxldCBlbmRTdHI7XG4gICAgaWYgKGRhdGVFbnYuY2FuQ29tcHV0ZU9mZnNldCkge1xuICAgICAgICAvLyBzdHJpbmdzIHdpbGwgbmF0dXJhbGx5IGhhdmUgb2Zmc2V0cywgd2hpY2ggR0NhbCBuZWVkc1xuICAgICAgICBzdGFydFN0ciA9IGRhdGVFbnYuZm9ybWF0SXNvKHJhbmdlLnN0YXJ0KTtcbiAgICAgICAgZW5kU3RyID0gZGF0ZUVudi5mb3JtYXRJc28ocmFuZ2UuZW5kKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIHdoZW4gdGltZXpvbmUgaXNuJ3Qga25vd24sIHdlIGRvbid0IGtub3cgd2hhdCB0aGUgVVRDIG9mZnNldCBzaG91bGQgYmUsIHNvIGFzayBmb3IgKy8tIDEgZGF5XG4gICAgICAgIC8vIGZyb20gdGhlIFVUQyBkYXktc3RhcnQgdG8gZ3VhcmFudGVlIHdlJ3JlIGdldHRpbmcgYWxsIHRoZSBldmVudHNcbiAgICAgICAgLy8gKHN0YXJ0L2VuZCB3aWxsIGJlIFVUQy1jb2VyY2VkIGRhdGVzLCBzbyB0b0lTT1N0cmluZyBpcyBva2F5KVxuICAgICAgICBzdGFydFN0ciA9IGFkZERheXMocmFuZ2Uuc3RhcnQsIC0xKS50b0lTT1N0cmluZygpO1xuICAgICAgICBlbmRTdHIgPSBhZGREYXlzKHJhbmdlLmVuZCwgMSkudG9JU09TdHJpbmcoKTtcbiAgICB9XG4gICAgcGFyYW1zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoZXh0cmFQYXJhbXMgfHwge30pKSwgeyBrZXk6IGFwaUtleSwgdGltZU1pbjogc3RhcnRTdHIsIHRpbWVNYXg6IGVuZFN0ciwgc2luZ2xlRXZlbnRzOiB0cnVlLCBtYXhSZXN1bHRzOiA5OTk5IH0pO1xuICAgIGlmIChkYXRlRW52LnRpbWVab25lICE9PSAnbG9jYWwnKSB7XG4gICAgICAgIHBhcmFtcy50aW1lWm9uZSA9IGRhdGVFbnYudGltZVpvbmU7XG4gICAgfVxuICAgIHJldHVybiBwYXJhbXM7XG59XG5mdW5jdGlvbiBnY2FsSXRlbXNUb1Jhd0V2ZW50RGVmcyhpdGVtcywgZ2NhbFRpbWV6b25lKSB7XG4gICAgcmV0dXJuIGl0ZW1zLm1hcCgoaXRlbSkgPT4gZ2NhbEl0ZW1Ub1Jhd0V2ZW50RGVmKGl0ZW0sIGdjYWxUaW1lem9uZSkpO1xufVxuZnVuY3Rpb24gZ2NhbEl0ZW1Ub1Jhd0V2ZW50RGVmKGl0ZW0sIGdjYWxUaW1lem9uZSkge1xuICAgIGxldCB1cmwgPSBpdGVtLmh0bWxMaW5rIHx8IG51bGw7XG4gICAgLy8gbWFrZSB0aGUgVVJMcyBmb3IgZWFjaCBldmVudCBzaG93IHRpbWVzIGluIHRoZSBjb3JyZWN0IHRpbWV6b25lXG4gICAgaWYgKHVybCAmJiBnY2FsVGltZXpvbmUpIHtcbiAgICAgICAgdXJsID0gaW5qZWN0UXNDb21wb25lbnQodXJsLCAnY3R6PScgKyBnY2FsVGltZXpvbmUpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBpZDogaXRlbS5pZCxcbiAgICAgICAgdGl0bGU6IGl0ZW0uc3VtbWFyeSxcbiAgICAgICAgc3RhcnQ6IGl0ZW0uc3RhcnQuZGF0ZVRpbWUgfHwgaXRlbS5zdGFydC5kYXRlLFxuICAgICAgICBlbmQ6IGl0ZW0uZW5kLmRhdGVUaW1lIHx8IGl0ZW0uZW5kLmRhdGUsXG4gICAgICAgIHVybCxcbiAgICAgICAgbG9jYXRpb246IGl0ZW0ubG9jYXRpb24sXG4gICAgICAgIGRlc2NyaXB0aW9uOiBpdGVtLmRlc2NyaXB0aW9uLFxuICAgICAgICBhdHRhY2htZW50czogaXRlbS5hdHRhY2htZW50cyB8fCBbXSxcbiAgICAgICAgZXh0ZW5kZWRQcm9wczogKGl0ZW0uZXh0ZW5kZWRQcm9wZXJ0aWVzIHx8IHt9KS5zaGFyZWQgfHwge30sXG4gICAgfTtcbn1cbi8vIEluamVjdHMgYSBzdHJpbmcgbGlrZSBcImFyZz12YWx1ZVwiIGludG8gdGhlIHF1ZXJ5c3RyaW5nIG9mIGEgVVJMXG4vLyBUT0RPOiBtb3ZlIHRvIGEgZ2VuZXJhbCB1dGlsIGZpbGU/XG5mdW5jdGlvbiBpbmplY3RRc0NvbXBvbmVudCh1cmwsIGNvbXBvbmVudCkge1xuICAgIC8vIGluamVjdCBpdCBhZnRlciB0aGUgcXVlcnlzdHJpbmcgYnV0IGJlZm9yZSB0aGUgZnJhZ21lbnRcbiAgICByZXR1cm4gdXJsLnJlcGxhY2UoLyhcXD8uKj8pPygjfCQpLywgKHdob2xlLCBxcywgaGFzaCkgPT4gKHFzID8gcXMgKyAnJicgOiAnPycpICsgY29tcG9uZW50ICsgaGFzaCk7XG59XG5cbmNvbnN0IE9QVElPTl9SRUZJTkVSUyA9IHtcbiAgICBnb29nbGVDYWxlbmRhckFwaUtleTogU3RyaW5nLFxufTtcblxuY29uc3QgRVZFTlRfU09VUkNFX1JFRklORVJTID0ge1xuICAgIGdvb2dsZUNhbGVuZGFyQXBpS2V5OiBTdHJpbmcsXG4gICAgZ29vZ2xlQ2FsZW5kYXJJZDogU3RyaW5nLFxuICAgIGdvb2dsZUNhbGVuZGFyQXBpQmFzZTogU3RyaW5nLFxuICAgIGV4dHJhUGFyYW1zOiBpZGVudGl0eSxcbn07XG5cbnZhciBpbmRleCA9IGNyZWF0ZVBsdWdpbih7XG4gICAgbmFtZTogJ0BmdWxsY2FsZW5kYXIvZ29vZ2xlLWNhbGVuZGFyJyxcbiAgICBldmVudFNvdXJjZURlZnM6IFtldmVudFNvdXJjZURlZl0sXG4gICAgb3B0aW9uUmVmaW5lcnM6IE9QVElPTl9SRUZJTkVSUyxcbiAgICBldmVudFNvdXJjZVJlZmluZXJzOiBFVkVOVF9TT1VSQ0VfUkVGSU5FUlMsXG59KTtcblxuZXhwb3J0IHsgaW5kZXggYXMgZGVmYXVsdCB9O1xuIiwgImltcG9ydCB7IGNyZWF0ZVBsdWdpbiB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29yZS9pbmRleC5qcyc7XG5pbXBvcnQgeyBhZGREYXlzIH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb3JlL2ludGVybmFsLmpzJztcbmltcG9ydCAqIGFzIElDQUwgZnJvbSAnaWNhbC5qcyc7XG5cbi8qIGVzbGludC1kaXNhYmxlICovXG5jbGFzcyBJY2FsRXhwYW5kZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgdGhpcy5tYXhJdGVyYXRpb25zID0gb3B0cy5tYXhJdGVyYXRpb25zICE9IG51bGwgPyBvcHRzLm1heEl0ZXJhdGlvbnMgOiAxMDAwO1xuICAgICAgICB0aGlzLnNraXBJbnZhbGlkRGF0ZXMgPSBvcHRzLnNraXBJbnZhbGlkRGF0ZXMgIT0gbnVsbCA/IG9wdHMuc2tpcEludmFsaWREYXRlcyA6IGZhbHNlO1xuICAgICAgICB0aGlzLmpDYWxEYXRhID0gSUNBTC5wYXJzZShvcHRzLmljcyk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gbmV3IElDQUwuQ29tcG9uZW50KHRoaXMuakNhbERhdGEpO1xuICAgICAgICB0aGlzLmV2ZW50cyA9IHRoaXMuY29tcG9uZW50LmdldEFsbFN1YmNvbXBvbmVudHMoJ3ZldmVudCcpLm1hcCh2ZXZlbnQgPT4gbmV3IElDQUwuRXZlbnQodmV2ZW50KSk7XG4gICAgICAgIGlmICh0aGlzLnNraXBJbnZhbGlkRGF0ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzID0gdGhpcy5ldmVudHMuZmlsdGVyKChldnQpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBldnQuc3RhcnREYXRlLnRvSlNEYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGV2dC5lbmREYXRlLnRvSlNEYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNraXBwaW5nIGV2ZW50cyB3aXRoIGludmFsaWQgdGltZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYmV0d2VlbihhZnRlciwgYmVmb3JlKSB7XG4gICAgICAgIGZ1bmN0aW9uIGlzRXZlbnRXaXRoaW5SYW5nZShzdGFydFRpbWUsIGVuZFRpbWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoIWFmdGVyIHx8IGVuZFRpbWUgPj0gYWZ0ZXIuZ2V0VGltZSgpKSAmJlxuICAgICAgICAgICAgICAgICghYmVmb3JlIHx8IHN0YXJ0VGltZSA8PSBiZWZvcmUuZ2V0VGltZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRUaW1lcyhldmVudE9yT2NjdXJyZW5jZSkge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gZXZlbnRPck9jY3VycmVuY2Uuc3RhcnREYXRlLnRvSlNEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgbGV0IGVuZFRpbWUgPSBldmVudE9yT2NjdXJyZW5jZS5lbmREYXRlLnRvSlNEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgLy8gSWYgaXQgaXMgYW4gYWxsIGRheSBldmVudCwgdGhlIGVuZCBkYXRlIGlzIHNldCB0byAwMDowMCBvZiB0aGUgbmV4dCBkYXlcbiAgICAgICAgICAgIC8vIFNvIHdlIG5lZWQgdG8gbWFrZSBpdCBiZSAyMzo1OTo1OSB0byBjb21wYXJlIGNvcnJlY3RseSB3aXRoIHRoZSBnaXZlbiByYW5nZVxuICAgICAgICAgICAgaWYgKGV2ZW50T3JPY2N1cnJlbmNlLmVuZERhdGUuaXNEYXRlICYmIChlbmRUaW1lID4gc3RhcnRUaW1lKSkge1xuICAgICAgICAgICAgICAgIGVuZFRpbWUgLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0VGltZSwgZW5kVGltZSB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4Y2VwdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5ldmVudHMuZm9yRWFjaCgoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5pc1JlY3VycmVuY2VFeGNlcHRpb24oKSlcbiAgICAgICAgICAgICAgICBleGNlcHRpb25zLnB1c2goZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmV0ID0ge1xuICAgICAgICAgICAgZXZlbnRzOiBbXSxcbiAgICAgICAgICAgIG9jY3VycmVuY2VzOiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ldmVudHMuZmlsdGVyKGUgPT4gIWUuaXNSZWN1cnJlbmNlRXhjZXB0aW9uKCkpLmZvckVhY2goKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBleGRhdGVzID0gW107XG4gICAgICAgICAgICBldmVudC5jb21wb25lbnQuZ2V0QWxsUHJvcGVydGllcygnZXhkYXRlJykuZm9yRWFjaCgoZXhkYXRlUHJvcCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4ZGF0ZSA9IGV4ZGF0ZVByb3AuZ2V0Rmlyc3RWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIGV4ZGF0ZXMucHVzaChleGRhdGUudG9KU0RhdGUoKS5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBSZWN1cnJpbmcgZXZlbnQgaXMgaGFuZGxlZCBkaWZmZXJlbnRseVxuICAgICAgICAgICAgaWYgKGV2ZW50LmlzUmVjdXJyaW5nKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVyYXRvciA9IGV2ZW50Lml0ZXJhdG9yKCk7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQ7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgICAgICBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2NjdXJyZW5jZSA9IGV2ZW50LmdldE9jY3VycmVuY2VEZXRhaWxzKG5leHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBzdGFydFRpbWUsIGVuZFRpbWUgfSA9IGdldFRpbWVzKG9jY3VycmVuY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNPY2N1cnJlbmNlRXhjbHVkZWQgPSBleGRhdGVzLmluZGV4T2Yoc3RhcnRUaW1lKSAhPT0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIGNoZWNrIHRoYXQgd2l0aGluIHNhbWUgZGF5P1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhjZXB0aW9uID0gZXhjZXB0aW9ucy5maW5kKGV4ID0+IGV4LnVpZCA9PT0gZXZlbnQudWlkICYmIGV4LnJlY3VycmVuY2VJZC50b0pTRGF0ZSgpLmdldFRpbWUoKSA9PT0gb2NjdXJyZW5jZS5zdGFydERhdGUudG9KU0RhdGUoKS5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBwYXNzZWQgdGhlIG1heCBkYXRlLCBzdG9wXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmVmb3JlICYmIHN0YXJ0VGltZSA+IGJlZm9yZS5nZXRUaW1lKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGF0IHdlIGFyZSB3aXRoaW4gb3VyIHJhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNFdmVudFdpdGhpblJhbmdlKHN0YXJ0VGltZSwgZW5kVGltZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldC5ldmVudHMucHVzaChleGNlcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghaXNPY2N1cnJlbmNlRXhjbHVkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0Lm9jY3VycmVuY2VzLnB1c2gob2NjdXJyZW5jZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAobmV4dCAmJiAoIXRoaXMubWF4SXRlcmF0aW9ucyB8fCBpIDwgdGhpcy5tYXhJdGVyYXRpb25zKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm9uLXJlY3VycmluZyBldmVudDpcbiAgICAgICAgICAgIGNvbnN0IHsgc3RhcnRUaW1lLCBlbmRUaW1lIH0gPSBnZXRUaW1lcyhldmVudCk7XG4gICAgICAgICAgICBpZiAoaXNFdmVudFdpdGhpblJhbmdlKHN0YXJ0VGltZSwgZW5kVGltZSkpXG4gICAgICAgICAgICAgICAgcmV0LmV2ZW50cy5wdXNoKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGJlZm9yZShiZWZvcmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmV0d2Vlbih1bmRlZmluZWQsIGJlZm9yZSk7XG4gICAgfVxuICAgIGFmdGVyKGFmdGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJldHdlZW4oYWZ0ZXIpO1xuICAgIH1cbiAgICBhbGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJldHdlZW4oKTtcbiAgICB9XG59XG5cbmNvbnN0IGV2ZW50U291cmNlRGVmID0ge1xuICAgIHBhcnNlTWV0YShyZWZpbmVkKSB7XG4gICAgICAgIGlmIChyZWZpbmVkLnVybCAmJiByZWZpbmVkLmZvcm1hdCA9PT0gJ2ljcycpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiByZWZpbmVkLnVybCxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICdpY3MnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGZldGNoKGFyZywgc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgICAgIGxldCBtZXRhID0gYXJnLmV2ZW50U291cmNlLm1ldGE7XG4gICAgICAgIGxldCB7IGludGVybmFsU3RhdGUgfSA9IG1ldGE7XG4gICAgICAgIC8qXG4gICAgICAgIE5PVEU6IGlzUmVmZXRjaCBpcyBhIEhBQ0suIHdlIHdvdWxkIGRvIHRoZSByZWN1cnJpbmctZXhwYW5kaW5nIGluIGEgc2VwYXJhdGUgcGx1Z2luIGhvb2ssXG4gICAgICAgIGJ1dCB3ZSBjb3VsZG4ndCBsZXZlcmFnZSBidWlsdC1pbiBhbGxEYXktZ3Vlc3NpbmcsIGFtb25nIG90aGVyIHRoaW5ncy5cbiAgICAgICAgKi9cbiAgICAgICAgaWYgKCFpbnRlcm5hbFN0YXRlIHx8IGFyZy5pc1JlZmV0Y2gpIHtcbiAgICAgICAgICAgIGludGVybmFsU3RhdGUgPSBtZXRhLmludGVybmFsU3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2U6IG51bGwsXG4gICAgICAgICAgICAgICAgaUNhbEV4cGFuZGVyUHJvbWlzZTogZmV0Y2gobWV0YS51cmwsIHsgbWV0aG9kOiAnR0VUJyB9KS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpLnRoZW4oKGljc1RleHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsU3RhdGUucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSWNhbEV4cGFuZGVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY3M6IGljc1RleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2tpcEludmFsaWREYXRlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaW50ZXJuYWxTdGF0ZS5pQ2FsRXhwYW5kZXJQcm9taXNlLnRoZW4oKGlDYWxFeHBhbmRlcikgPT4ge1xuICAgICAgICAgICAgc3VjY2Vzc0NhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICByYXdFdmVudHM6IGV4cGFuZElDYWxFdmVudHMoaUNhbEV4cGFuZGVyLCBhcmcucmFuZ2UpLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlOiBpbnRlcm5hbFN0YXRlLnJlc3BvbnNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGVycm9yQ2FsbGJhY2spO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gZXhwYW5kSUNhbEV2ZW50cyhpQ2FsRXhwYW5kZXIsIHJhbmdlKSB7XG4gICAgLy8gZXhwYW5kIHRoZSByYW5nZS4gYmVjYXVzZSBvdXIgYHJhbmdlYCBpcyB0aW1lWm9uZS1hZ25vc3RpYyBVVENcbiAgICAvLyBvciBtYXliZSBiZWNhdXNlIGljYWwuanMgYWx3YXlzIHByb2R1Y2VzIGRhdGVzIGluIGxvY2FsIHRpbWU/IGkgZm9yZ2V0XG4gICAgbGV0IHJhbmdlU3RhcnQgPSBhZGREYXlzKHJhbmdlLnN0YXJ0LCAtMSk7XG4gICAgbGV0IHJhbmdlRW5kID0gYWRkRGF5cyhyYW5nZS5lbmQsIDEpO1xuICAgIGxldCBpQ2FsUmVzID0gaUNhbEV4cGFuZGVyLmJldHdlZW4ocmFuZ2VTdGFydCwgcmFuZ2VFbmQpOyAvLyBlbmQgaW5jbHVzaXZlLiB3aWxsIGdpdmUgZXh0cmEgcmVzdWx0c1xuICAgIGxldCBleHBhbmRlZCA9IFtdO1xuICAgIC8vIFRPRE86IGluc3RlYWQgb2YgdXNpbmcgc3RhcnREYXRlL2VuZERhdGUudG9TdHJpbmcgdG8gY29tbXVuaWNhdGUgYWxsRGF5LFxuICAgIC8vIHdlIGNhbiBxdWVyeSBzdGFydERhdGUvZW5kRGF0ZS5pc0RhdGUuIE1vcmUgZWZmaWNpZW50IHRvIGF2b2lkIGZvcm1hdHRpbmcvcmVwYXJzaW5nLlxuICAgIC8vIHNpbmdsZSBldmVudHNcbiAgICBmb3IgKGxldCBpQ2FsRXZlbnQgb2YgaUNhbFJlcy5ldmVudHMpIHtcbiAgICAgICAgZXhwYW5kZWQucHVzaChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJ1aWxkTm9uRGF0ZVByb3BzKGlDYWxFdmVudCkpLCB7IHN0YXJ0OiBpQ2FsRXZlbnQuc3RhcnREYXRlLnRvU3RyaW5nKCksIGVuZDogKHNwZWNpZmllc0VuZChpQ2FsRXZlbnQpICYmIGlDYWxFdmVudC5lbmREYXRlKVxuICAgICAgICAgICAgICAgID8gaUNhbEV2ZW50LmVuZERhdGUudG9TdHJpbmcoKVxuICAgICAgICAgICAgICAgIDogbnVsbCB9KSk7XG4gICAgfVxuICAgIC8vIHJlY3VycmluZyBldmVudCBpbnN0YW5jZXNcbiAgICBmb3IgKGxldCBpQ2FsT2NjdXJlbmNlIG9mIGlDYWxSZXMub2NjdXJyZW5jZXMpIHtcbiAgICAgICAgbGV0IGlDYWxFdmVudCA9IGlDYWxPY2N1cmVuY2UuaXRlbTtcbiAgICAgICAgZXhwYW5kZWQucHVzaChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJ1aWxkTm9uRGF0ZVByb3BzKGlDYWxFdmVudCkpLCB7IHN0YXJ0OiBpQ2FsT2NjdXJlbmNlLnN0YXJ0RGF0ZS50b1N0cmluZygpLCBlbmQ6IChzcGVjaWZpZXNFbmQoaUNhbEV2ZW50KSAmJiBpQ2FsT2NjdXJlbmNlLmVuZERhdGUpXG4gICAgICAgICAgICAgICAgPyBpQ2FsT2NjdXJlbmNlLmVuZERhdGUudG9TdHJpbmcoKVxuICAgICAgICAgICAgICAgIDogbnVsbCB9KSk7XG4gICAgfVxuICAgIHJldHVybiBleHBhbmRlZDtcbn1cbmZ1bmN0aW9uIGJ1aWxkTm9uRGF0ZVByb3BzKGlDYWxFdmVudCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHRpdGxlOiBpQ2FsRXZlbnQuc3VtbWFyeSxcbiAgICAgICAgdXJsOiBleHRyYWN0RXZlbnRVcmwoaUNhbEV2ZW50KSxcbiAgICAgICAgZXh0ZW5kZWRQcm9wczoge1xuICAgICAgICAgICAgbG9jYXRpb246IGlDYWxFdmVudC5sb2NhdGlvbixcbiAgICAgICAgICAgIG9yZ2FuaXplcjogaUNhbEV2ZW50Lm9yZ2FuaXplcixcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBpQ2FsRXZlbnQuZGVzY3JpcHRpb24sXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RFdmVudFVybChpQ2FsRXZlbnQpIHtcbiAgICBsZXQgdXJsUHJvcCA9IGlDYWxFdmVudC5jb21wb25lbnQuZ2V0Rmlyc3RQcm9wZXJ0eSgndXJsJyk7XG4gICAgcmV0dXJuIHVybFByb3AgPyB1cmxQcm9wLmdldEZpcnN0VmFsdWUoKSA6ICcnO1xufVxuZnVuY3Rpb24gc3BlY2lmaWVzRW5kKGlDYWxFdmVudCkge1xuICAgIHJldHVybiBCb29sZWFuKGlDYWxFdmVudC5jb21wb25lbnQuZ2V0Rmlyc3RQcm9wZXJ0eSgnZHRlbmQnKSkgfHxcbiAgICAgICAgQm9vbGVhbihpQ2FsRXZlbnQuY29tcG9uZW50LmdldEZpcnN0UHJvcGVydHkoJ2R1cmF0aW9uJykpO1xufVxuXG52YXIgaW5kZXggPSBjcmVhdGVQbHVnaW4oe1xuICAgIG5hbWU6ICdAZnVsbGNhbGVuZGFyL2ljYWxlbmRhcicsXG4gICAgZXZlbnRTb3VyY2VEZWZzOiBbZXZlbnRTb3VyY2VEZWZdLFxufSk7XG5cbmV4cG9ydCB7IGluZGV4IGFzIGRlZmF1bHQgfTtcbiIsICIvKipcbiAqIEhhbmRsZXMgcmVuZGVyaW5nIHRoZSBjYWxlbmRhciBnaXZlbiBhIGNvbnRhaW5lciBlbGVtZW50LCBldmVudFNvdXJjZXMsIGFuZCBpbnRlcmFjdGlvbiBjYWxsYmFja3MuXG4gKi9cbmltcG9ydCB7XG4gICAgQ2FsZW5kYXIsXG4gICAgRXZlbnRBcGksXG4gICAgRXZlbnRDbGlja0FyZyxcbiAgICBFdmVudEhvdmVyaW5nQXJnLFxuICAgIEV2ZW50U291cmNlSW5wdXQsXG59IGZyb20gXCJAZnVsbGNhbGVuZGFyL2NvcmVcIjtcbmltcG9ydCBkYXlHcmlkUGx1Z2luIGZyb20gXCJAZnVsbGNhbGVuZGFyL2RheWdyaWRcIjtcbi8vIGltcG9ydCBtdWx0aU1vbnRoUGx1Z2luIGZyb20gJ0BmdWxsY2FsZW5kYXIvbXVsdGltb250aCdcbmltcG9ydCB0aW1lR3JpZFBsdWdpbiBmcm9tIFwiQGZ1bGxjYWxlbmRhci90aW1lZ3JpZFwiO1xuaW1wb3J0IHJydWxlUGx1Z2luIGZyb20gXCJAZnVsbGNhbGVuZGFyL3JydWxlXCI7XG5pbXBvcnQgbGlzdFBsdWdpbiBmcm9tIFwiQGZ1bGxjYWxlbmRhci9saXN0XCI7XG5pbXBvcnQgaW50ZXJhY3Rpb25QbHVnaW4gZnJvbSBcIkBmdWxsY2FsZW5kYXIvaW50ZXJhY3Rpb25cIjtcbmltcG9ydCBnb29nbGVDYWxlbmRhclBsdWdpbiBmcm9tIFwiQGZ1bGxjYWxlbmRhci9nb29nbGUtY2FsZW5kYXJcIjtcbmltcG9ydCBpQ2FsZW5kYXJQbHVnaW4gZnJvbSBcIkBmdWxsY2FsZW5kYXIvaWNhbGVuZGFyXCI7XG5cbi8vIFRoZXJlIGlzIGFuIGlzc3VlIHdpdGggRnVsbENhbGVuZGFyIFJSdWxlIHN1cHBvcnQgYXJvdW5kIERTVCBib3VuZGFyaWVzIHdoaWNoIGlzIGZpeGVkIGJ5IHRoaXMgbW9ua2V5cGF0Y2g6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZnVsbGNhbGVuZGFyL2Z1bGxjYWxlbmRhci9pc3N1ZXMvNTI3MyNpc3N1ZWNvbW1lbnQtMTM2MDQ1OTM0MlxucnJ1bGVQbHVnaW4ucmVjdXJyaW5nVHlwZXNbMF0uZXhwYW5kID0gZnVuY3Rpb24gKGVycmQsIGZyLCBkZSkge1xuICAgIGNvbnN0IGhvdXJzID0gZXJyZC5ycnVsZVNldC5fZHRzdGFydC5nZXRIb3VycygpO1xuICAgIHJldHVybiBlcnJkLnJydWxlU2V0XG4gICAgICAgIC5iZXR3ZWVuKGRlLnRvRGF0ZShmci5zdGFydCksIGRlLnRvRGF0ZShmci5lbmQpLCB0cnVlKVxuICAgICAgICAubWFwKChkOiBEYXRlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoXG4gICAgICAgICAgICAgICAgRGF0ZS5VVEMoXG4gICAgICAgICAgICAgICAgICAgIGQuZ2V0RnVsbFllYXIoKSxcbiAgICAgICAgICAgICAgICAgICAgZC5nZXRNb250aCgpLFxuICAgICAgICAgICAgICAgICAgICBkLmdldERhdGUoKSxcbiAgICAgICAgICAgICAgICAgICAgaG91cnMsXG4gICAgICAgICAgICAgICAgICAgIGQuZ2V0TWludXRlcygpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG59O1xuXG5pbnRlcmZhY2UgRXh0cmFSZW5kZXJQcm9wcyB7XG4gICAgZXZlbnRDbGljaz86IChpbmZvOiBFdmVudENsaWNrQXJnKSA9PiB2b2lkO1xuICAgIHNlbGVjdD86IChcbiAgICAgICAgc3RhcnREYXRlOiBEYXRlLFxuICAgICAgICBlbmREYXRlOiBEYXRlLFxuICAgICAgICBhbGxEYXk6IGJvb2xlYW4sXG4gICAgICAgIHZpZXdUeXBlOiBzdHJpbmdcbiAgICApID0+IFByb21pc2U8dm9pZD47XG4gICAgbW9kaWZ5RXZlbnQ/OiAoZXZlbnQ6IEV2ZW50QXBpLCBvbGRFdmVudDogRXZlbnRBcGkpID0+IFByb21pc2U8Ym9vbGVhbj47XG4gICAgZXZlbnRNb3VzZUVudGVyPzogKGluZm86IEV2ZW50SG92ZXJpbmdBcmcpID0+IHZvaWQ7XG4gICAgZmlyc3REYXk/OiBudW1iZXI7XG4gICAgaW5pdGlhbFZpZXc/OiB7IGRlc2t0b3A6IHN0cmluZzsgbW9iaWxlOiBzdHJpbmcgfTtcbiAgICB0aW1lRm9ybWF0MjRoPzogYm9vbGVhbjtcbiAgICBvcGVuQ29udGV4dE1lbnVGb3JFdmVudD86IChcbiAgICAgICAgZXZlbnQ6IEV2ZW50QXBpLFxuICAgICAgICBtb3VzZUV2ZW50OiBNb3VzZUV2ZW50XG4gICAgKSA9PiBQcm9taXNlPHZvaWQ+O1xuICAgIHRvZ2dsZVRhc2s/OiAoZXZlbnQ6IEV2ZW50QXBpLCBpc0NvbXBsZXRlOiBib29sZWFuKSA9PiBQcm9taXNlPGJvb2xlYW4+O1xuICAgIGZvcmNlTmFycm93PzogYm9vbGVhbjtcbiAgICBzbG90RHVyYXRpb246IHN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlckNhbGVuZGFyKFxuICAgIGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCxcbiAgICBldmVudFNvdXJjZXM6IEV2ZW50U291cmNlSW5wdXRbXSxcbiAgICBzZXR0aW5ncz86IEV4dHJhUmVuZGVyUHJvcHNcbik6IENhbGVuZGFyIHtcbiAgICBjb25zdCBpc01vYmlsZSA9IHdpbmRvdy5pbm5lcldpZHRoIDwgNTAwO1xuICAgIGNvbnN0IGlzTmFycm93ID0gc2V0dGluZ3M/LmZvcmNlTmFycm93IHx8IGlzTW9iaWxlO1xuICAgIGNvbnN0IHtcbiAgICAgICAgZXZlbnRDbGljayxcbiAgICAgICAgc2VsZWN0LFxuICAgICAgICBtb2RpZnlFdmVudCxcbiAgICAgICAgZXZlbnRNb3VzZUVudGVyLFxuICAgICAgICBvcGVuQ29udGV4dE1lbnVGb3JFdmVudCxcbiAgICAgICAgdG9nZ2xlVGFzayxcbiAgICB9ID0gc2V0dGluZ3MgfHwge307XG4gICAgY29uc3QgbW9kaWZ5RXZlbnRDYWxsYmFjayA9XG4gICAgICAgIG1vZGlmeUV2ZW50ICYmXG4gICAgICAgIChhc3luYyAoe1xuICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICBvbGRFdmVudCxcbiAgICAgICAgICAgIHJldmVydCxcbiAgICAgICAgfToge1xuICAgICAgICAgICAgZXZlbnQ6IEV2ZW50QXBpO1xuICAgICAgICAgICAgb2xkRXZlbnQ6IEV2ZW50QXBpO1xuICAgICAgICAgICAgcmV2ZXJ0OiAoKSA9PiB2b2lkO1xuICAgICAgICB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdWNjZXNzID0gYXdhaXQgbW9kaWZ5RXZlbnQoZXZlbnQsIG9sZEV2ZW50KTtcbiAgICAgICAgICAgIGlmICghc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIHJldmVydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgIGNvbnN0IGNhbCA9IG5ldyBDYWxlbmRhcihjb250YWluZXJFbCwge1xuICAgICAgICBwbHVnaW5zOiBbXG4gICAgICAgICAgICAvLyBWaWV3IHBsdWdpbnNcbiAgICAgICAgICAgIGRheUdyaWRQbHVnaW4sXG4gICAgICAgICAgICB0aW1lR3JpZFBsdWdpbixcbiAgICAgICAgICAgIGxpc3RQbHVnaW4sXG4gICAgICAgICAgICAvLyBtdWx0aU1vbnRoUGx1Z2luLFxuICAgICAgICAgICAgLy8gRHJhZyArIGRyb3AgYW5kIGVkaXRpbmdcbiAgICAgICAgICAgIGludGVyYWN0aW9uUGx1Z2luLFxuICAgICAgICAgICAgLy8gUmVtb3RlIHNvdXJjZXNcbiAgICAgICAgICAgIGdvb2dsZUNhbGVuZGFyUGx1Z2luLFxuICAgICAgICAgICAgaUNhbGVuZGFyUGx1Z2luLFxuICAgICAgICAgICAgcnJ1bGVQbHVnaW4sXG4gICAgICAgIF0sXG4gICAgICAgIGdvb2dsZUNhbGVuZGFyQXBpS2V5OiBcIkFJemFTeURJaWtsRndKWGFMV3VUXzR5Nkk5WlJWVnNQdWY0eEdya1wiLFxuICAgICAgICBpbml0aWFsVmlldzpcbiAgICAgICAgICAgIHNldHRpbmdzPy5pbml0aWFsVmlldz8uW2lzTmFycm93ID8gXCJtb2JpbGVcIiA6IFwiZGVza3RvcFwiXSB8fFxuICAgICAgICAgICAgKGlzTmFycm93ID8gXCJ0aW1lR3JpZDNEYXlzXCIgOiBcInRpbWVHcmlkV2Vla1wiKSxcbiAgICAgICAgbm93SW5kaWNhdG9yOiB0cnVlLFxuICAgICAgICBzY3JvbGxUaW1lUmVzZXQ6IGZhbHNlLFxuICAgICAgICBkYXlNYXhFdmVudHM6IHRydWUsXG4gICAgICAgIGV4cGFuZFJvd3M6dHJ1ZSxcbiAgICAgICAgc2xvdER1cmF0aW9uOiBzZXR0aW5ncz8uc2xvdER1cmF0aW9uIHx8IFwiMDA6MzA6MDBcIixcbiAgICAgICAgLy8gbXVsdGlNb250aE1heENvbHVtbnM6IDEsXG5cbiAgICAgICAgaGVhZGVyVG9vbGJhcjogIWlzTmFycm93XG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgIGxlZnQ6IFwicHJldixuZXh0IHRvZGF5XCIsXG4gICAgICAgICAgICAgICAgICBjZW50ZXI6IFwidGl0bGVcIixcbiAgICAgICAgICAgICAgICAgIHJpZ2h0OiBcInRpbWVHcmlkNURheXMsdGltZUdyaWRXZWVrLGxpc3RXZWVrLGRheUdyaWRNb250aCxkYXlHcmlkWWVhclwiLFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA6ICFpc01vYmlsZVxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICByaWdodDogXCJ0b2RheSxwcmV2LG5leHRcIixcbiAgICAgICAgICAgICAgICAgIGxlZnQ6IFwiZGF5R3JpZE1vbnRoLHRpbWVHcmlkM0RheXMsbGlzdFdlZWssZGF5R3JpZFllYXJcIixcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgZm9vdGVyVG9vbGJhcjogaXNNb2JpbGVcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgcmlnaHQ6IFwidG9kYXkscHJldixuZXh0XCIsXG4gICAgICAgICAgICAgICAgICBsZWZ0OiBcInRpbWVHcmlkM0RheXMsZGF5R3JpZE1vbnRoLGRheUdyaWRZZWFyLHRpbWVHcmlkV2VlayxsaXN0V2Vla1wiLFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA6IGZhbHNlLFxuXG4gICAgICAgIHZpZXdzOiB7XG4gICAgICAgICAgICB0aW1lR3JpZDNEYXlzOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0aW1lR3JpZFwiLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiB7IGRheXM6IDMgfSxcbiAgICAgICAgICAgICAgICBidXR0b25UZXh0OiBcIjNcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aW1lR3JpZDVEYXlzOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0aW1lR3JpZFwiLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiB7IGRheXM6IDUgfSxcbiAgICAgICAgICAgICAgICBidXR0b25UZXh0OiBcIjVcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRheUdyaWRNb250aDoge1xuICAgICAgICAgICAgICBkYXlNYXhFdmVudHM6IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRheUdyaWRZZWFyOiB7XG4gICAgICAgICAgICAgIGRheU1heEV2ZW50czogZmFsc2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBmaXJzdERheTogc2V0dGluZ3M/LmZpcnN0RGF5LFxuICAgICAgICAuLi4oc2V0dGluZ3M/LnRpbWVGb3JtYXQyNGggJiYge1xuICAgICAgICAgICAgZXZlbnRUaW1lRm9ybWF0OiB7XG4gICAgICAgICAgICAgICAgaG91cjogXCJudW1lcmljXCIsXG4gICAgICAgICAgICAgICAgbWludXRlOiBcIjItZGlnaXRcIixcbiAgICAgICAgICAgICAgICBob3VyMTI6IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNsb3RMYWJlbEZvcm1hdDoge1xuICAgICAgICAgICAgICAgIGhvdXI6IFwibnVtZXJpY1wiLFxuICAgICAgICAgICAgICAgIG1pbnV0ZTogXCIyLWRpZ2l0XCIsXG4gICAgICAgICAgICAgICAgaG91cjEyOiBmYWxzZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pLFxuICAgICAgICBldmVudFNvdXJjZXMsXG4gICAgICAgIGV2ZW50Q2xpY2ssXG5cbiAgICAgICAgc2VsZWN0YWJsZTogc2VsZWN0ICYmIHRydWUsXG4gICAgICAgIHNlbGVjdE1pcnJvcjogc2VsZWN0ICYmIHRydWUsXG4gICAgICAgIHNlbGVjdDpcbiAgICAgICAgICAgIHNlbGVjdCAmJlxuICAgICAgICAgICAgKGFzeW5jIChpbmZvKSA9PiB7XG4gICAgICAgICAgICAgICAgYXdhaXQgc2VsZWN0KGluZm8uc3RhcnQsIGluZm8uZW5kLCBpbmZvLmFsbERheSwgaW5mby52aWV3LnR5cGUpO1xuICAgICAgICAgICAgICAgIGluZm8udmlldy5jYWxlbmRhci51bnNlbGVjdCgpO1xuICAgICAgICAgICAgfSksXG5cbiAgICAgICAgZWRpdGFibGU6IG1vZGlmeUV2ZW50ICYmIHRydWUsXG4gICAgICAgIGV2ZW50RHJvcDogbW9kaWZ5RXZlbnRDYWxsYmFjayxcbiAgICAgICAgZXZlbnRSZXNpemU6IG1vZGlmeUV2ZW50Q2FsbGJhY2ssXG5cbiAgICAgICAgZXZlbnRNb3VzZUVudGVyLFxuXG4gICAgICAgIGV2ZW50RGlkTW91bnQ6ICh7IGV2ZW50LCBlbCwgdGV4dENvbG9yIH0pID0+IHtcbiAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBvcGVuQ29udGV4dE1lbnVGb3JFdmVudCAmJiBvcGVuQ29udGV4dE1lbnVGb3JFdmVudChldmVudCwgZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0b2dnbGVUYXNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmV4dGVuZGVkUHJvcHMuaXNUYXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoZWNrYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgICAgICAgICAgICAgICBjaGVja2JveC50eXBlID0gXCJjaGVja2JveFwiO1xuICAgICAgICAgICAgICAgICAgICBjaGVja2JveC5jaGVja2VkID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmV4dGVuZGVkUHJvcHMudGFza0NvbXBsZXRlZCAhPT0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrYm94Lm9uY2xpY2sgPSBhc3luYyAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLnRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXQgPSBhd2FpdCB0b2dnbGVUYXNrKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGUudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQpLmNoZWNrZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlLnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50KS5jaGVja2VkID0gIShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKS5jaGVja2VkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSB0aGUgY2hlY2tib3ggbW9yZSB2aXNpYmxlIGFnYWluc3QgZGlmZmVyZW50IGNvbG9yIGV2ZW50cy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleHRDb2xvciA9PSBcImJsYWNrXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrYm94LmFkZENsYXNzKFwib2ZjLWNoZWNrYm94LWJsYWNrXCIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tib3guYWRkQ2xhc3MoXCJvZmMtY2hlY2tib3gtd2hpdGVcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2tib3guY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuYWRkQ2xhc3MoXCJvZmMtdGFzay1jb21wbGV0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBEZXBlbmRpbmcgb24gdGhlIHZpZXcsIHdlIHNob3VsZCBwdXQgdGhlIGNoZWNrYm94IGluIGEgZGlmZmVyZW50IHNwb3QuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5xdWVyeVNlbGVjdG9yKFwiLmZjLWV2ZW50LXRpbWVcIikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLnF1ZXJ5U2VsZWN0b3IoXCIuZmMtZXZlbnQtdGl0bGVcIikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLnF1ZXJ5U2VsZWN0b3IoXCIuZmMtbGlzdC1ldmVudC10aXRsZVwiKTtcblxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXI/LmFkZENsYXNzKFwib2ZjLWhhcy1jaGVja2JveFwiKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyPy5wcmVwZW5kKGNoZWNrYm94KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbG9uZ1ByZXNzRGVsYXk6IDI1MCxcbiAgICB9KTtcbiAgICBjYWwucmVuZGVyKCk7XG4gICAgcmV0dXJuIGNhbDtcbn1cbiIsICJpbXBvcnQgTXlQbHVnaW4gZnJvbSBcIi4vbWFpblwiXG5pbXBvcnQgeyBOb3RpY2UsIFRBYnN0cmFjdEZpbGUsIFRGaWxlLCBWYXVsdCB9IGZyb20gXCJvYnNpZGlhblwiXG5pbXBvcnQgeyBJUGFnZSwgSVN1YnNjcmliZXIsIFNyYyB9IGZyb20gXCIuL3R5cGVzXCJcbmltcG9ydCB7IGlzRXF1YWxPYmogfSBmcm9tIFwiLi91dGlsXCJcbmltcG9ydCBGaWxlTWFuYWdlciBmcm9tIFwiLi9Ob3RlTWFuYWdlclwiXG5pbXBvcnQgeyBNU0dfUExHX05BTUUgfSBmcm9tIFwiLi9jb25zdGFudHNcIlxuaW1wb3J0IE5vdGVNYW5hZ2VyIGZyb20gXCIuL05vdGVNYW5hZ2VyXCJcblxudHlwZSBJUGF0aFN1YnNjcmliZXIgPSB7XG4gIHBhdGhzOiBTcmNbXSxcbiAgc3Vic2NyaWJlcjogSVN1YnNjcmliZXJcbn1cblxuZXhwb3J0IGNsYXNzIENhY2hlIHtcbiAgcHJpdmF0ZSBub3RlTWFuYWdlcjogTm90ZU1hbmFnZXJcblxuICBwcml2YXRlIHZhdWx0OiBWYXVsdFxuXG4gIHByaXZhdGUgc3RvcmFnZSA9IG5ldyBNYXA8c3RyaW5nLCBJUGFnZT4oKVxuICBwcml2YXRlIHN1YnNjcmliZXJzID0gbmV3IE1hcDxOdW1iZXIsIElQYXRoU3Vic2NyaWJlcj4oKVxuXG4gIHByaXZhdGUgaW5pdFN5bmM6IFByb21pc2U8dm9pZD4gPSBuZXcgUHJvbWlzZShcbiAgICByZXNvbHZlID0+IHRoaXMuaW5pdFN5bmNSZXNvbHZlID0gcmVzb2x2ZVxuICApXG4gIHByaXZhdGUgaW5pdFN5bmNSZXNvbHZlOiAodmFsdWU6IHZvaWQgfCBQcm9taXNlTGlrZTx2b2lkPikgPT4gdm9pZFxuICBwcml2YXRlIGlzSW5pdGVkID0gZmFsc2VcblxuICBjb25zdHJ1Y3Rvcihub3RlTWFuYWdlcjogTm90ZU1hbmFnZXIsIHZhdWx0OiBWYXVsdCkge1xuICAgIHRoaXMubm90ZU1hbmFnZXIgPSBub3RlTWFuYWdlclxuICAgIHRoaXMudmF1bHQgPSB2YXVsdFxuICB9XG5cbiAgcHVibGljIGFzeW5jIGluaXQoKSB7XG4gICAgdGhpcy5pc0luaXRlZCA9IGZhbHNlXG5cbiAgICBhd2FpdCB0aGlzLmluaXRTdG9yYWdlKClcblxuICAgIHRoaXMuaW5pdFN5bmNSZXNvbHZlKClcbiAgICB0aGlzLmlzSW5pdGVkID0gdHJ1ZVxuXG4gICAgdGhpcy5pbml0U3luYyA9IG5ldyBQcm9taXNlKFxuICAgICAgcmVzb2x2ZSA9PiB0aGlzLmluaXRTeW5jUmVzb2x2ZSA9IHJlc29sdmVcbiAgICApXG4gIH1cblxuICBwdWJsaWMgZ2V0UGFnZShwYXRoOiBzdHJpbmcpOiBJUGFnZXx1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLnN0b3JhZ2UuZ2V0KHBhdGgpXG4gIH1cblxuICBwdWJsaWMgbG9nKCkge1xuICAgIGNvbnNvbGUubG9nKFwic3RvcmFnZVwiLCB0aGlzLnN0b3JhZ2UpXG4gICAgY29uc29sZS5sb2coXCJzdWJzY3JpYmVyc1wiLCB0aGlzLnN1YnNjcmliZXJzKVxuICB9XG5cbiAgcHVibGljIGFzeW5jIHN1YnNjcmliZShpZDogTnVtYmVyLCBwYXRoczogU3JjW10sIHN1YnNjcmliZXI6IElTdWJzY3JpYmVyKTogUHJvbWlzZTxJUGFnZVtdPiB7XG4gICAgdGhpcy5zdWJzY3JpYmVycy5zZXQoXG4gICAgICBpZCxcbiAgICAgIHtcbiAgICAgICAgcGF0aHMsXG4gICAgICAgIHN1YnNjcmliZXJcbiAgICAgIH1cbiAgICApXG5cbiAgICBpZiAoIXRoaXMuaXNJbml0ZWQpXG4gICAgICBhd2FpdCB0aGlzLmluaXRTeW5jXG5cbiAgICBjb25zdCByZXN1bHQ6IElQYWdlW10gPSBbXVxuICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiB0aGlzLnN0b3JhZ2UpIHtcbiAgICAgIGNvbnN0IGlzT2sgPSBwYXRocy5zb21lKFxuICAgICAgICBlbCA9PiBlbC5pbmNsdWRlcyhrZXkpXG4gICAgICApXG5cbiAgICAgIGlmIChpc09rKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIHB1YmxpYyB1bnN1YnNjcmliZShpZDogTnVtYmVyKSB7XG4gICAgdGhpcy5zdWJzY3JpYmVycy5kZWxldGUoaWQpXG4gIH1cblxuICBwdWJsaWMgYXN5bmMgcmVuYW1lRmlsZShmaWxlOiBURmlsZSwgb2xkUGF0aDogc3RyaW5nKSB7XG4gICAgaWYgKCF0aGlzLmlzSW5pdGVkKVxuICAgICAgYXdhaXQgdGhpcy5pbml0U3luY1xuXG4gICAgY29uc3Qgb2xkUGFnZSA9IHRoaXMuc3RvcmFnZS5nZXQob2xkUGF0aCkgYXMgSVBhZ2VcblxuICAgIC8vIE5PVEUgXHUwNDQyXHUwNDM4XHUwNDNGXHUwNDMwIFx1MDQ0RFx1MDQ0Mlx1MDQzRSBcdTA0NDFcdTA0NDFcdTA0NEJcdTA0M0JcdTA0M0VcdTA0NDdcdTA0M0RcdTA0NEJcdTA0MzUgXHUwNDNFXHUwNDMxXHUwNDRBXHUwNDM1XHUwNDNBXHUwNDQyXHUwNDRCXG4gICAgY29uc3QgcGFnZSA9IHsuLi5vbGRQYWdlfVxuICAgIHBhZ2UuZmlsZSA9IHsuLi5vbGRQYWdlLmZpbGV9XG4gICAgcGFnZS5maWxlLnBhdGggPSBmaWxlLnBhdGhcbiAgICBwYWdlLmZpbGUubmFtZSA9IGZpbGUuYmFzZW5hbWVcblxuICAgIHRoaXMuc3RvcmFnZS5kZWxldGUob2xkUGF0aClcbiAgICB0aGlzLnN0b3JhZ2Uuc2V0KGZpbGUucGF0aCwgcGFnZSlcblxuICAgIGZvciAobGV0IFtfLCB7cGF0aHMsIHN1YnNjcmliZXJ9XSBvZiB0aGlzLnN1YnNjcmliZXJzKSB7XG4gICAgICBjb25zdCBpc09rMSA9IHBhdGhzLnNvbWUoIGVsID0+IGVsLmluY2x1ZGVzKGZpbGUucGF0aCkgKVxuICAgICAgY29uc3QgaXNPazIgPSBwYXRocy5zb21lKCBlbCA9PiBlbC5pbmNsdWRlcyhvbGRQYXRoKSApXG5cbiAgICAgIGZvciAobGV0IHBhdGggb2YgcGF0aHMpIHtcbiAgICAgICAgaWYgKGlzT2sxICYmIGlzT2syKVxuICAgICAgICAgIHN1YnNjcmliZXIucmVuYW1lRmlsZShwYWdlLCBvbGRQYWdlKVxuICAgICAgICBlbHNlIGlmIChpc09rMilcbiAgICAgICAgICBzdWJzY3JpYmVyLmRlbGV0ZUZpbGUob2xkUGFnZSlcbiAgICAgICAgZWxzZSBpZiAoaXNPazEpXG4gICAgICAgICAgc3Vic2NyaWJlci5hZGRGaWxlKHBhZ2UpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGFkZEZpbGUoZmlsZTogVEZpbGUpIHtcbiAgICBpZiAoIXRoaXMuaXNJbml0ZWQpXG4gICAgICBhd2FpdCB0aGlzLmluaXRTeW5jXG5cbiAgICBjb25zdCBwYWdlID0gYXdhaXQgdGhpcy5ub3RlTWFuYWdlci5nZXRQYWdlKGZpbGUpXG4gICAgdGhpcy5zdG9yYWdlLnNldChmaWxlLnBhdGgsIHBhZ2UpXG5cbiAgICBmb3IgKGxldCBbXywge3BhdGhzLCBzdWJzY3JpYmVyfV0gb2YgdGhpcy5zdWJzY3JpYmVycykge1xuICAgICAgY29uc3QgaXNPayA9IHBhdGhzLnNvbWUoIGVsID0+IGVsLmluY2x1ZGVzKGZpbGUucGF0aCkgKVxuXG4gICAgICBpZiAoaXNPaylcbiAgICAgICAgc3Vic2NyaWJlci5hZGRGaWxlKHBhZ2UpXG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGNoYW5nZUZpbGUoZmlsZTogVEZpbGUpIHtcbiAgICBpZiAoIXRoaXMuaXNJbml0ZWQpXG4gICAgICBhd2FpdCB0aGlzLmluaXRTeW5jXG5cbiAgICBjb25zdCBwYWdlID0gYXdhaXQgdGhpcy5ub3RlTWFuYWdlci5nZXRQYWdlKGZpbGUpXG4gICAgY29uc3Qgb2xkUGFnZSA9IHRoaXMuc3RvcmFnZS5nZXQoZmlsZS5wYXRoKSBhcyBJUGFnZVxuICAgIGlmIChpc0VxdWFsT2JqKHBhZ2UsIG9sZFBhZ2UpKVxuICAgICAgcmV0dXJuXG5cbiAgICB0aGlzLnN0b3JhZ2Uuc2V0KGZpbGUucGF0aCwgcGFnZSlcbiAgICBmb3IgKGxldCBbXywge3BhdGhzLCBzdWJzY3JpYmVyfV0gb2YgdGhpcy5zdWJzY3JpYmVycykge1xuICAgICAgY29uc3QgaXNPayA9IHBhdGhzLnNvbWUoIGVsID0+IGVsLmluY2x1ZGVzKGZpbGUucGF0aCkgKVxuXG4gICAgICBpZiAoaXNPaylcbiAgICAgICAgc3Vic2NyaWJlci5jaGFuZ2VGaWxlKHBhZ2UsIG9sZFBhZ2UpXG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGRlbGV0ZUZpbGUoZmlsZTogVEFic3RyYWN0RmlsZSkge1xuICAgIGlmICghdGhpcy5pc0luaXRlZClcbiAgICAgIGF3YWl0IHRoaXMuaW5pdFN5bmNcblxuICAgIGNvbnN0IHBhZ2UgPSB0aGlzLnN0b3JhZ2UuZ2V0KGZpbGUucGF0aCkgYXMgSVBhZ2VcblxuICAgIHRoaXMuc3RvcmFnZS5kZWxldGUoZmlsZS5wYXRoKVxuICAgIGZvciAobGV0IFtfLCB7cGF0aHMsIHN1YnNjcmliZXJ9XSBvZiB0aGlzLnN1YnNjcmliZXJzKSB7XG4gICAgICBjb25zdCBpc09rID0gcGF0aHMuc29tZSggZWwgPT4gZWwuaW5jbHVkZXMoZmlsZS5wYXRoKSApXG5cbiAgICAgIGlmIChpc09rKVxuICAgICAgICBzdWJzY3JpYmVyLmRlbGV0ZUZpbGUocGFnZSlcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgcmVzZXQoKSB7XG4gICAgdGhpcy5pc0luaXRlZCA9IGZhbHNlXG5cbiAgICB0aGlzLnN0b3JhZ2UuY2xlYXIoKVxuXG4gICAgY29uc3QgdG1wID0gdGhpcy5zdWJzY3JpYmVyc1xuICAgIHRoaXMuc3Vic2NyaWJlcnMgPSBuZXcgTWFwKClcbiAgICBhd2FpdCB0aGlzLmluaXQoKSAvLyBUT0RPIFx1MDQ0N1x1MDQ0Mlx1MDQzRSBcdTA0NERcdTA0NDJcdTA0M0UgXHUwNDM0XHUwNDM1XHUwNDNCXHUwNDMwXHUwNDM1XHUwNDQyXG5cbiAgICBmb3IgKGxldCBbXywge3N1YnNjcmliZXJ9XSBvZiB0bXApXG4gICAgICBzdWJzY3JpYmVyLnJlc2V0KClcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaW5pdFN0b3JhZ2UoKSB7XG4gICAgY29uc3QgdEZpbGVzID0gdGhpcy52YXVsdC5nZXRNYXJrZG93bkZpbGVzKClcblxuICAgIGNvbnN0IG5vdGljZSA9IG5ldyBOb3RpY2UoXG4gICAgICBgJHtNU0dfUExHX05BTUV9OiB0aGVyZSBhcmUgJHt0RmlsZXMubGVuZ3RofSBub3Rlc2AsXG4gICAgICAxMDAwICogNjAgLy8gNjAgc2Vjb25kc1xuICAgIClcblxuICAgIGZvciAobGV0IGkgaW4gdEZpbGVzKSB7XG4gICAgICBjb25zdCB0RmlsZSA9IHRGaWxlc1tpXVxuXG4gICAgICBub3RpY2Uuc2V0TWVzc2FnZShgJHtNU0dfUExHX05BTUV9OiAoJHtpfS8ke3RGaWxlcy5sZW5ndGh9KSBhZGRlZCAke3RGaWxlLnBhdGh9YClcblxuICAgICAgdGhpcy5zdG9yYWdlLnNldChcbiAgICAgICAgdEZpbGUucGF0aCxcbiAgICAgICAgYXdhaXQgdGhpcy5ub3RlTWFuYWdlci5nZXRQYWdlKHRGaWxlKVxuICAgICAgKVxuICAgIH1cblxuICAgIG5vdGljZS5oaWRlKClcbiAgICBuZXcgTm90aWNlKGAke01TR19QTEdfTkFNRX06IGNhY2hlIGhhcyBiZWVuIGluaXRlZGApXG4gIH1cbn1cbiIsICJpbXBvcnQgeyBBcHAsIE5vdGljZSwgUGx1Z2luU2V0dGluZ1RhYiwgU2V0dGluZyB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IE15UGx1Z2luIGZyb20gXCIuL21haW5cIjtcbmltcG9ydCB7IENPTE9VUl9SRVNULCBDT0xPVVJfU0xFRVAsIERFRkFVTFRfU0VUVElOR1MsIE1TR19QTEdfTkFNRSB9IGZyb20gXCIuL2NvbnN0YW50c1wiO1xuXG5leHBvcnQgY2xhc3MgTXlTZXR0aW5nVGFiIGV4dGVuZHMgUGx1Z2luU2V0dGluZ1RhYiB7XG4gIHBsdWdpbjogTXlQbHVnaW47XG5cbiAgY29uc3RydWN0b3IoYXBwOiBBcHAsIHBsdWdpbjogTXlQbHVnaW4pIHtcbiAgICBzdXBlcihhcHAsIHBsdWdpbik7XG4gICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XG4gIH1cblxuICBkaXNwbGF5KCkge1xuICAgIGxldCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xuICAgIGNvbnRhaW5lckVsLmVtcHR5KCk7XG5cbiAgICBjb25zdCBzZXR0aW5ncyA9IHRoaXMucGx1Z2luLmdldFNldHRpbmdzKClcblxuICAgIC8vIFRPRE8gXHUwNDNGXHUwNDQwXHUwNDM4IFx1MDQ0MVx1MDQzQ1x1MDQzNVx1MDQzRFx1MDQzNSBcdTA0MzJcdTA0NEJcdTA0M0FcdTA0M0JcdTA0NEVcdTA0NDdcdTA0MzBcdTA0NDJcdTA0NEMgXHUwNDMyIFx1MDQ0Mlx1MDQzNVx1MDQzQVx1MDQ0M1x1MDQ0OVx1MDQzNVx1MDQzOSBcdTA0NDFcdTA0MzVcdTA0NDFcdTA0NDFcdTA0MzhcdTA0MzggXHUwNDM4XHUwNDNEXHUwNDQxXHUwNDQyXHUwNDQwXHUwNDQzXHUwNDNDXHUwNDM1XHUwNDNEXHUwNDQyLCBcdTA0MzAgXHUwNDNEXHUwNDM1IFx1MDQzRlx1MDQ0MFx1MDQzOCBcdTA0M0ZcdTA0MzVcdTA0NDBcdTA0MzVcdTA0MzdcdTA0MzBcdTA0MzNcdTA0NDBcdTA0NDNcdTA0MzdcdTA0M0FcdTA0MzVcbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbCkuc2V0SGVhZGluZygpLnNldE5hbWUoXCJJdCdzIHJlY29tbWVuZGVkIHRvIHJlbG9hZCBPYnNpZGlhbkFwcCBhZnRlciBjaGFuZ2luZyB0aGUgc2V0dGluZ3NcIilcbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbCkuYWRkQnV0dG9uKFxuICAgICAgYnRuID0+IHtcbiAgICAgICAgYnRuLnNldEJ1dHRvblRleHQoXCJTZXQgRGVmYXVsdCBWYWx1ZXNcIilcbiAgICAgICAgLm9uQ2xpY2soXG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKERFRkFVTFRfU0VUVElOR1MpXG4gICAgICAgICAgICBuZXcgTm90aWNlKE1TR19QTEdfTkFNRSArIFwiVGhlIGRlZmF1bHQgc2V0dGluZ3MgaGFzIGJlZW4gYXBwbGllZFwiKVxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgfVxuICAgIClcblxuICAgIC8vIENhbGVuZGFyXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpLnNldEhlYWRpbmcoKVxuXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpLnNldE5hbWUoXCJDYWxlbmRhclwiKS5zZXRIZWFkaW5nKClcblxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKS5zZXROYW1lKFwiU2xvdCBkdXJhdGlvblwiKVxuICAgIC5zZXREZXNjKGBEZWZhdWx0OiAke0RFRkFVTFRfU0VUVElOR1MuY2FsZW5kYXIuc2xvdER1cmF0aW9ufWApXG4gICAgLmFkZFRleHQoXG4gICAgICBjb21wb25lbnQgPT4ge1xuICAgICAgICBjb21wb25lbnQuc2V0UGxhY2Vob2xkZXIoXCJoaDptbTpzc1wiKVxuICAgICAgICAuc2V0VmFsdWUoc2V0dGluZ3MuY2FsZW5kYXIuc2xvdER1cmF0aW9uKVxuICAgICAgICAub25DaGFuZ2UoXG4gICAgICAgICAgdmFsdWUgPT4ge1xuICAgICAgICAgICAgLy8gQ29tbWVudGV0IGNhdXNlIEl0IGNyZWF0ZSBhIGxvdCBvZiBOb3RpY2VcbiAgICAgICAgICAgIC8vIGNvbnN0IHJlZ0V4cCA9IC9eXFxkezJ9OlxcZHsyfTpcXGR7Mn0kL1xuXG4gICAgICAgICAgICAvLyAvLyBOT1RFIFx1MDQzRlx1MDQ0MFx1MDQzRVx1MDQzMlx1MDQzNVx1MDQ0MFx1MDQ0Rlx1MDQzNVx1MDQzQyBcdTA0NDFcdTA0M0VcdTA0M0VcdTA0NDJcdTA0MzJcdTA0MzVcdTA0NDJcdTA0NDFcdTA0NDJcdTA0MzJcdTA0MzhcdTA0MzUgXHUwNDQ0XHUwNDNFXHUwNDQwXHUwNDNDXHUwNDMwXHUwNDQyXHUwNDQzXG4gICAgICAgICAgICAvLyBpZiAoIXJlZ0V4cC50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgLy8gICB2YWx1ZSA9IERFRkFVTFRfU0VUVElOR1MuY2FsZW5kYXIuc2xvdER1cmF0aW9uXG4gICAgICAgICAgICAvLyAgIG5ldyBOb3RpY2UoTVNHX1BMR19OQU1FICsgXCJpbnZhbGlkIFNsb3REdXJhdGlvbiBmb3JtYXRcIilcbiAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgc2V0dGluZ3MuY2FsZW5kYXIuc2xvdER1cmF0aW9uID0gdmFsdWVcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncyhzZXR0aW5ncylcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIH1cbiAgICApXG5cbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbCkuc2V0TmFtZShcIkNvbG91cnNcIikuc2V0SGVhZGluZygpXG4gICAgZm9yIChsZXQga2V5IG9mIE9iamVjdC5rZXlzKHNldHRpbmdzLmNhbGVuZGFyLmNvbG91cnMpIGFzIChrZXlvZiB0eXBlb2Ygc2V0dGluZ3MuY2FsZW5kYXIuY29sb3VycylbXSApIHtcbiAgICAgIHRoaXMuYWRkQ29sb3VyU2V0dGluZyhcbiAgICAgICAgY29udGFpbmVyRWwsIGtleSxcbiAgICAgICAgREVGQVVMVF9TRVRUSU5HUy5jYWxlbmRhci5jb2xvdXJzW2tleV0sXG4gICAgICAgIHNldHRpbmdzLmNhbGVuZGFyLmNvbG91cnNba2V5XSxcbiAgICAgICAgKHZhbDpzdHJpbmcpID0+IHtcbiAgICAgICAgICBzZXR0aW5ncy5jYWxlbmRhci5jb2xvdXJzW2tleV0gPSB2YWxcbiAgICAgICAgICB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3Moc2V0dGluZ3MpXG4gICAgICAgIH1cbiAgICAgIClcbiAgICB9XG5cbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbCkuc2V0TmFtZShcIlJlc3RUaW1lXCIpLnNldEhlYWRpbmcoKVxuICAgIGZvciAobGV0IGluZGV4IGluIHNldHRpbmdzLmNhbGVuZGFyLnJlc3RUaW1lKSB7XG5cbiAgICAgIGNvbnN0IGVsID0gc2V0dGluZ3MuY2FsZW5kYXIucmVzdFRpbWVbaW5kZXhdXG5cbiAgICAgIGxldCBuYW1lID0gXCJcIlxuICAgICAgaWYgKGVsLmNvbG9yID09PSBDT0xPVVJfUkVTVCkge1xuICAgICAgICBuYW1lID0gXCJSZXN0IHRpbWVcIlxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZWwuY29sb3IgPT09IENPTE9VUl9TTEVFUCkge1xuICAgICAgICBuYW1lID0gXCJTbGVlcCB0aW1lXCJcbiAgICAgIH1cbiAgICAgIGVsc2VcbiAgICAgICAgY29udGludWVcblxuICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpLnNldE5hbWUoYFN0YXJ0IG9mICR7bmFtZX0gKCR7aW5kZXh9KWApLmFkZFRleHQoXG4gICAgICAgIHRleHQgPT4ge1xuICAgICAgICAgIHRleHQuc2V0VmFsdWUoZWwuc3RhcnRUaW1lKS5zZXRQbGFjZWhvbGRlcihcImhoOm1tOnNzXCIpXG4gICAgICAgICAgLm9uQ2hhbmdlKFxuICAgICAgICAgICAgdmFsID0+IHtcbiAgICAgICAgICAgICAgc2V0dGluZ3MuY2FsZW5kYXIucmVzdFRpbWVbaW5kZXhdLnN0YXJ0VGltZSA9IHZhbFxuICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3Moc2V0dGluZ3MpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICApXG4gICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbCkuc2V0TmFtZShgRW5kIG9mICR7bmFtZX0gKCR7aW5kZXh9KWApLmFkZFRleHQoXG4gICAgICAgIHRleHQgPT4ge1xuICAgICAgICAgIHRleHQuc2V0VmFsdWUoZWwuZW5kVGltZSkuc2V0UGxhY2Vob2xkZXIoXCJoaDptbTpzc1wiKVxuICAgICAgICAgIC5vbkNoYW5nZShcbiAgICAgICAgICAgIHZhbCA9PiB7XG4gICAgICAgICAgICAgIHNldHRpbmdzLmNhbGVuZGFyLnJlc3RUaW1lW2luZGV4XS5lbmRUaW1lID0gdmFsXG4gICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncyhzZXR0aW5ncylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIClcblxuICAgIH1cblxuXG4gICAgLy8gU3RhdHVzIENvcnJlY3RvclxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKS5zZXRIZWFkaW5nKClcbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbCkuc2V0TmFtZShcIlN0YXR1c0NvcnJlY3RvclwiKS5zZXRIZWFkaW5nKClcbiAgICAvLyAuc2V0RGVzYyhcIlRoaXMgaXMgRGVzY3JpcHRpb25cIilcblxuICAgIGNvbnN0IHN0YXR1c0NvcnJlY3RvciA9IHNldHRpbmdzLnN0YXR1c0NvcnJlY3Rvci5pc09uXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAuc2V0TmFtZShcIkVuYWJsZSB0b29sXCIpXG4gICAgICAuYWRkVG9nZ2xlKFxuICAgICAgICB0b2dnbGUgPT5cbiAgICAgICAgICB0b2dnbGVcbiAgICAgICAgICAgIC5zZXRWYWx1ZShzdGF0dXNDb3JyZWN0b3IpXG4gICAgICAgICAgICAub25DaGFuZ2UoXG4gICAgICAgICAgICAgIHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5zdGF0dXNDb3JyZWN0b3IuaXNPbiA9IHZhbHVlXG4gICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKHNldHRpbmdzKVxuXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5KClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgICAgKVxuICAgIGlmIChzdGF0dXNDb3JyZWN0b3IpIHtcbiAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAuc2V0TmFtZShcIlN0YXJ0IG9uIFN0YXJ0IFVwXCIpXG4gICAgICAgIC5hZGRUb2dnbGUoXG4gICAgICAgICAgdG9nZ2xlID0+IHRvZ2dsZS5zZXRWYWx1ZShzZXR0aW5ncy5zdGF0dXNDb3JyZWN0b3Iuc3RhcnRPblN0YXJ0VXApXG4gICAgICAgICAgICAub25DaGFuZ2UoXG4gICAgICAgICAgICAgIHZhbCA9PiB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3Muc3RhdHVzQ29ycmVjdG9yLnN0YXJ0T25TdGFydFVwID0gdmFsXG4gICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKHNldHRpbmdzKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgIClcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFkZENvbG91clNldHRpbmcoY29udGFpbmVyRWw6IEhUTUxFbGVtZW50LCBuYW1lOiBzdHJpbmcsIGRlZmF1bHRWYWx1ZTogc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFZhbHVlOiBzdHJpbmcsIGNhbGxiYWNrOiBGdW5jdGlvbikge1xuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKS5zZXROYW1lKG5hbWUpLnNldERlc2MoYERlZmF1bHQ6ICR7ZGVmYXVsdFZhbHVlfWApXG4gICAgLmFkZFRleHQoXG4gICAgICBjb21wb25lbnQgPT4ge1xuICAgICAgICBjb21wb25lbnQuc2V0UGxhY2Vob2xkZXIoXCIjMGYwZjBmXCIpXG4gICAgICAgIC5zZXRWYWx1ZShjdXJyZW50VmFsdWUpLm9uQ2hhbmdlKHZhbCA9PiBjYWxsYmFjayh2YWwpKVxuICAgICAgfVxuICAgIClcbiAgfVxufVxuIiwgImltcG9ydCB7IE5vdGljZSB9IGZyb20gXCJvYnNpZGlhblwiXG5pbXBvcnQgeyBURVhUX0JMT0NLRUQsIFRFWFRfRE9ORSwgVEVYVF9TT09OLCBURVhUX0lOX1BST0dSRVNTLCBURVhUX0NISUxEX0lOX1BST0dSRVNTLCBNU0dfUExHX05BTUUgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCJcbmltcG9ydCB7IElQYWdlLCBJU3Vic2NyaWJlciwgU3JjIH0gZnJvbSBcIi4uL3R5cGVzXCJcbmltcG9ydCB7IGdldE5vdGVzV2l0aG91dFBhcmVudCwgZ2V0UGFyZW50Tm90ZSwgZ2V0Q2hpbGROb3RlUGF0aHMsIGdldFByb2dyZXNzIH0gZnJvbSBcIi4uL3V0aWxcIlxuaW1wb3J0IHsgQ2FjaGUgfSBmcm9tIFwic3JjL2NhY2hlXCJcbmltcG9ydCBOb3RlTWFuYWdlciBmcm9tIFwic3JjL05vdGVNYW5hZ2VyXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhdHVzQ29ycmVjdG9yIGltcGxlbWVudHMgSVN1YnNjcmliZXIge1xuICBwcml2YXRlIGNhY2hlOiBDYWNoZVxuXG4gIHByaXZhdGUgaWRGb3JDYWNoZTogbnVtYmVyXG5cbiAgcHJpdmF0ZSBldmVudFNyYzogU3JjW11cblxuICBwcml2YXRlIG5vdGVNYW5hZ2VyOiBOb3RlTWFuYWdlclxuXG4gIHByaXZhdGUgc3Vic2NyaWJlZCA9IGZhbHNlXG4gIHByaXZhdGUgd2hpbGVTdWJzY3JpYmluZyA9IG5ldyBQcm9taXNlKFxuICAgIChyZXNvbHZlKSA9PiB0aGlzLnJlc29sdmVTdWJzY3JpYmluZyA9IHJlc29sdmVcbiAgKVxuICBwcml2YXRlIHJlc29sdmVTdWJzY3JpYmluZzogKHZhbHVlOiB2b2lkIHwgUHJvbWlzZUxpa2U8dm9pZD4pID0+IHZvaWRcblxuICBjb25zdHJ1Y3RvcihpZEZvckNhY2hlOiBudW1iZXIsIGV2ZW50U3JjOiBTcmNbXSwgY2FjaGU6IENhY2hlLCBub3RlTWFuYWdlcjogTm90ZU1hbmFnZXIpIHtcbiAgICB0aGlzLmNhY2hlID0gY2FjaGVcbiAgICB0aGlzLmlkRm9yQ2FjaGUgPSBpZEZvckNhY2hlXG4gICAgdGhpcy5ldmVudFNyYyA9IGV2ZW50U3JjXG4gICAgdGhpcy5ub3RlTWFuYWdlciA9IG5vdGVNYW5hZ2VyXG4gIH1cblxuICBwdWJsaWMgYXN5bmMgaW5pdCgpIHtcbiAgICBhd2FpdCB0aGlzLmNhY2hlLnN1YnNjcmliZSh0aGlzLmlkRm9yQ2FjaGUsIHRoaXMuZXZlbnRTcmMsIHRoaXMpXG5cbiAgICB0aGlzLnN1YnNjcmliZWQgPSB0cnVlXG4gICAgdGhpcy5yZXNvbHZlU3Vic2NyaWJpbmcoKVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBjb3JyZWN0Tm90ZShwYWdlOiBJUGFnZSk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGxldCBzdGF0dXMgPSBwYWdlLmZmX3N0YXR1c1xuICAgIGlmICghc3RhdHVzKVxuICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgICBjaGVja1Byb2dyZXNzOiB7XG4gICAgICBjb25zdCB0YXNrcyA9IGF3YWl0IGdldFByb2dyZXNzKHRoaXMuY2FjaGUsIHRoaXMubm90ZU1hbmFnZXIsIHBhZ2UpXG4gICAgICBpZiAoc3RhdHVzID09IFRFWFRfRE9ORSAmJiB0YXNrcy5hbGwgIT0gdGFza3MuZG9uZSkge1xuICAgICAgICBzdGF0dXMgPSBURVhUX0lOX1BST0dSRVNTXG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzdGF0dXMgPT0gVEVYVF9TT09OICYmIHRhc2tzLmRvbmUgIT0gMCkge1xuICAgICAgICBzdGF0dXMgPSBURVhUX0JMT0NLRURcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHN0YXR1cyAhPSBURVhUX0lOX1BST0dSRVNTICYmIHRhc2tzLmRvbmUgPT0gMCAmJiB0YXNrcy5hbGwgIT0gMCkge1xuICAgICAgICBzdGF0dXMgPSBURVhUX1NPT047XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2hlY2tEYXRlOiB7XG4gICAgICBjb25zdCBjaGVja3MgPSBbVEVYVF9TT09OLCBURVhUX0JMT0NLRUQsIFRFWFRfQ0hJTERfSU5fUFJPR1JFU1NdXG4gICAgICBpZiAocGFnZS5mZl9kYXRlICYmIGNoZWNrcy5pbmRleE9mKHN0YXR1cyBhcyBzdHJpbmcpICE9IC0xKSB7XG4gICAgICAgIHN0YXR1cyA9IFRFWFRfSU5fUFJPR1JFU1NcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjaGVja1N0YXR1czoge1xuICAgICAgY29uc3QgY2hpbGRfID0gYXdhaXQgZ2V0Q2hpbGROb3RlUGF0aHMocGFnZS5maWxlLnBhdGgpXG4gICAgICBjb25zdCBzdGF0dXNlczogc3RyaW5nW10gPSBuZXcgQXJyYXlcblxuICAgICAgZm9yIChsZXQgY2hpbGRyZW5fIG9mIGNoaWxkXykge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9ICh0aGlzLmNhY2hlLmdldFBhZ2UoY2hpbGRyZW5fKSBhcyBJUGFnZSlcblxuICAgICAgICBpZiAoIWNoaWxkcmVuPy5mZl9zdGF0dXMpXG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBzdGF0dXNlcy5wdXNoKGNoaWxkcmVuLmZmX3N0YXR1cylcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgICAgY2FzZSBURVhUX1NPT046IHtcbiAgICAgICAgICBpZiAoc3RhdHVzZXMuaW5kZXhPZihURVhUX0lOX1BST0dSRVNTKSAhPSAtMSlcbiAgICAgICAgICAgIHN0YXR1cyA9IFRFWFRfQ0hJTERfSU5fUFJPR1JFU1NcbiAgICAgICAgICBlbHNlIGlmIChzdGF0dXNlcy5pbmRleE9mKFRFWFRfQ0hJTERfSU5fUFJPR1JFU1MpICE9IC0xKVxuICAgICAgICAgICAgc3RhdHVzID0gVEVYVF9DSElMRF9JTl9QUk9HUkVTU1xuICAgICAgICAgIGVsc2UgaWYgKHN0YXR1c2VzLmluZGV4T2YoVEVYVF9CTE9DS0VEKSAhPSAtMSlcbiAgICAgICAgICAgIHN0YXR1cyA9IFRFWFRfQkxPQ0tFRFxuICAgICAgICAgIGVsc2UgaWYgKHN0YXR1c2VzLmluZGV4T2YoVEVYVF9ET05FKSAhPSAtMSlcbiAgICAgICAgICAgIHN0YXR1cyA9IFRFWFRfQkxPQ0tFRFxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBURVhUX0JMT0NLRUQ6IHtcbiAgICAgICAgICBpZiAoc3RhdHVzZXMuaW5kZXhPZihURVhUX0lOX1BST0dSRVNTKSAhPSAtMSlcbiAgICAgICAgICAgIHN0YXR1cyA9IFRFWFRfQ0hJTERfSU5fUFJPR1JFU1NcbiAgICAgICAgICBlbHNlIGlmIChzdGF0dXNlcy5pbmRleE9mKFRFWFRfQ0hJTERfSU5fUFJPR1JFU1MpICE9IC0xKVxuICAgICAgICAgICAgc3RhdHVzID0gVEVYVF9DSElMRF9JTl9QUk9HUkVTU1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBURVhUX0NISUxEX0lOX1BST0dSRVNTOiB7XG4gICAgICAgICAgc3RhdHVzID0gVEVYVF9CTE9DS0VEXG4gICAgICAgICAgaWYgKHN0YXR1c2VzLmluZGV4T2YoVEVYVF9JTl9QUk9HUkVTUykgIT0gLTEpXG4gICAgICAgICAgICBzdGF0dXMgPSBURVhUX0NISUxEX0lOX1BST0dSRVNTXG4gICAgICAgICAgZWxzZSBpZiAoc3RhdHVzZXMuaW5kZXhPZihURVhUX0NISUxEX0lOX1BST0dSRVNTKSAhPSAtMSlcbiAgICAgICAgICAgIHN0YXR1cyA9IFRFWFRfQ0hJTERfSU5fUFJPR1JFU1NcbiAgICAgICAgICBlbHNlIGlmIChzdGF0dXNlcy5pbmRleE9mKFRFWFRfRE9ORSkgIT0gLTEpXG4gICAgICAgICAgICBzdGF0dXMgPSBURVhUX0lOX1BST0dSRVNTXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFRFWFRfRE9ORToge1xuICAgICAgICAgIGlmIChzdGF0dXNlcy5pbmRleE9mKFRFWFRfU09PTikgIT0gLTEpXG4gICAgICAgICAgICBzdGF0dXMgPSBURVhUX0JMT0NLRURcbiAgICAgICAgICBlbHNlIGlmIChzdGF0dXNlcy5pbmRleE9mKFRFWFRfQkxPQ0tFRCkgIT0gLTEpXG4gICAgICAgICAgICBzdGF0dXMgPSBURVhUX0JMT0NLRURcbiAgICAgICAgICBlbHNlIGlmIChzdGF0dXNlcy5pbmRleE9mKFRFWFRfSU5fUFJPR1JFU1MpICE9IC0xKVxuICAgICAgICAgICAgc3RhdHVzID0gVEVYVF9DSElMRF9JTl9QUk9HUkVTU1xuICAgICAgICAgIGVsc2UgaWYgKHN0YXR1c2VzLmluZGV4T2YoVEVYVF9DSElMRF9JTl9QUk9HUkVTUykgIT0gLTEpXG4gICAgICAgICAgICBzdGF0dXMgPSBURVhUX0NISUxEX0lOX1BST0dSRVNTXG5cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIC8vIGNhc2UgVEVYVF9CTE9DS0VEOiBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhdHVzID09IHBhZ2UuZmZfc3RhdHVzKVxuICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgICBwYWdlLmZmX3N0YXR1cyA9IHN0YXR1c1xuICAgIGF3YWl0IHRoaXMubm90ZU1hbmFnZXIuY2hhbmdlU3RhdHVzRmlsZShwYWdlLmZpbGUucGF0aCwgc3RhdHVzKVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBjb3JyZWN0QWxsTm90ZXMoKSB7XG4gICAgY29uc3Qgbm90aWNlID0gbmV3IE5vdGljZShcbiAgICAgIE1TR19QTEdfTkFNRSArIFwiOiBTdGFydCBjaGVja2luZyBzdGF0dXMgb2Ygbm90ZXNcIixcbiAgICAgIDEwMDAgKiA2MCAvLyA2MCBzZWNvbmRzXG4gICAgKVxuXG4gICAgaWYgKCF0aGlzLnN1YnNjcmliZWQpIHtcbiAgICAgIGF3YWl0IHRoaXMud2hpbGVTdWJzY3JpYmluZ1xuICAgIH1cblxuICAgIGNvbnN0IHF1ZXVlUGF0aHM6IHN0cmluZ1tdID0gW11cbiAgICBjb25zdCBzZXQgPSBuZXcgU2V0PHN0cmluZz4oKVxuXG4gICAgLy8gbGV0IHBhcmVudHMgPSBbXVxuICAgIGNvbnN0IGNvbXB1dGVzID0gW11cblxuICAgIGZvciAobGV0IGVsIG9mIHRoaXMuZXZlbnRTcmMpIHtcbiAgICAgIGNvbXB1dGVzLnB1c2goXG4gICAgICAgIGdldE5vdGVzV2l0aG91dFBhcmVudChlbC5wYXRoKVxuICAgICAgKVxuICAgIH1cbiAgICBsZXQgcGFyZW50c18gPSBhd2FpdCBQcm9taXNlLmFsbChjb21wdXRlcylcbiAgICBsZXQgcGFyZW50cyA9IFtdXG4gICAgZm9yIChsZXQgZWwgb2YgcGFyZW50c18pIHtcbiAgICAgIHBhcmVudHMucHVzaCguLi5lbClcbiAgICB9XG4gICAgcGFyZW50cyA9IHBhcmVudHMudW5pcXVlKClcbiAgICAgIC5maWx0ZXIoXG4gICAgICAgIGVsID0+IHRoaXMuZXZlbnRTcmMuc29tZShzcmMgPT4gc3JjLmluY2x1ZGVzKGVsLmZpbGUucGF0aCkpXG4gICAgICApXG5cbiAgICBmb3IgKGxldCBwYXJlbnQgb2YgcGFyZW50cykge1xuICAgICAgcXVldWVQYXRocy5wdXNoKHBhcmVudC5maWxlLnBhdGgpXG4gICAgICBzZXQuYWRkKHBhcmVudC5maWxlLnBhdGgpXG4gICAgfVxuXG4gICAgZm9yIChsZXQgbGVmdFBvaW50ZXIgPSAwOyBsZWZ0UG9pbnRlciA8IHF1ZXVlUGF0aHMubGVuZ3RoOyArK2xlZnRQb2ludGVyKSB7XG4gICAgICBsZXQgcGF0aCA9IHF1ZXVlUGF0aHNbbGVmdFBvaW50ZXJdXG5cbiAgICAgIGNvbnN0IGNoaWxkID0gYXdhaXQgZ2V0Q2hpbGROb3RlUGF0aHMocGF0aClcbiAgICAgIGZvciAobGV0IGNoaWxkcmVuIG9mIGNoaWxkKSB7XG4gICAgICAgIGlmIChzZXQuaGFzKGNoaWxkcmVuKSlcbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIHNldC5hZGQoY2hpbGRyZW4pXG4gICAgICAgIHF1ZXVlUGF0aHMucHVzaChjaGlsZHJlbilcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGxldCBwb2ludGVyID0gcXVldWVQYXRocy5sZW5ndGgtMTsgcG9pbnRlciA+IDA7IC0tcG9pbnRlcikge1xuICAgICAgbGV0IGkgPSBxdWV1ZVBhdGhzLmxlbmd0aCAtIHBvaW50ZXIgLSAxXG4gICAgICBub3RpY2Uuc2V0TWVzc2FnZShgJHtNU0dfUExHX05BTUV9KHN0YXR1cykgJHtpfS8ke3F1ZXVlUGF0aHMubGVuZ3RofWApXG5cbiAgICAgIGF3YWl0IHRoaXMuY29ycmVjdE5vdGUoXG4gICAgICAgIHRoaXMuY2FjaGUuZ2V0UGFnZShcbiAgICAgICAgICBxdWV1ZVBhdGhzW3BvaW50ZXJdXG4gICAgICAgICkgYXMgSVBhZ2VcbiAgICAgIClcbiAgICB9XG5cbiAgICBub3RpY2Uuc2V0TWVzc2FnZShNU0dfUExHX05BTUUgKyBcIjogU3RhdHVzIG9mIE5vdGVzIGhhcyBiZWVuIGNoZWNrZWRcIilcbiAgICBzZXRUaW1lb3V0KFxuICAgICAgKCkgPT4gbm90aWNlLmhpZGUoKSxcbiAgICAgIDMwMDBcbiAgICApXG5cbiAgICBuZXcgTm90aWNlKGAke01TR19QTEdfTkFNRX06IE5vdGVzIGhhcyBiZWVuIGNoZWNrZWRgKVxuICB9XG5cbiAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgLy8gVE9ETzogXHUwNDNGXHUwNDQwXHUwNDM4IFx1MDQzMlx1MDQ0Qlx1MDQzN1x1MDQzRVx1MDQzMlx1MDQzNSBcdTA0MzdcdTA0MzBcdTA0MzJcdTA0MzVcdTA0NDBcdTA0NDhcdTA0MzBcdTA0NDJcdTA0NEMgXHUwNDM3XHUwNDMwXHUwNDNGXHUwNDQzXHUwNDQxXHUwNDNBIHN0YXR1c0NvcnJlY3RvclxuXG4gICAgdGhpcy5jYWNoZS51bnN1YnNjcmliZSh0aGlzLmlkRm9yQ2FjaGUpXG4gIH1cblxuICBwdWJsaWMgcmVuYW1lRmlsZShuZXdQYWdlOiBJUGFnZSwgb2xkUGFnZTogSVBhZ2UpOiB2b2lkIHt9XG4gIHB1YmxpYyBkZWxldGVGaWxlKHBhZ2U6IElQYWdlKTogdm9pZCB7fVxuICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7fVxuXG4gIHB1YmxpYyBhc3luYyBhZGRGaWxlKHBhZ2U6IElQYWdlKSB7XG4gICAgYXdhaXQgdGhpcy5jaGFuZ2VGaWxlKHBhZ2UsIHBhZ2UpXG4gIH1cblxuICBwdWJsaWMgYXN5bmMgY2hhbmdlRmlsZShwYWdlOiBJUGFnZSwgb2xkUGFnZTogSVBhZ2UpIHtcbiAgICBjb25zdCBxdWV1ZVBhdGhzOiBzdHJpbmdbXSA9IFtdXG4gICAgY29uc3Qgc2V0ID0gbmV3IFNldDxzdHJpbmc+KClcblxuICAgIHF1ZXVlUGF0aHMucHVzaChwYWdlLmZpbGUucGF0aClcbiAgICBzZXQuYWRkKHBhZ2UuZmlsZS5wYXRoKVxuXG4gICAgZm9yIChsZXQgbGVmdFBvaW50ZXIgPSAwOyBsZWZ0UG9pbnRlciA8IHF1ZXVlUGF0aHMubGVuZ3RoOyArK2xlZnRQb2ludGVyKSB7XG4gICAgICBjb25zdCBwYXRoID0gcXVldWVQYXRoc1tsZWZ0UG9pbnRlcl1cbiAgICAgIGNvbnN0IHBhZ2UgPSB0aGlzLmNhY2hlLmdldFBhZ2UocGF0aCkgYXMgSVBhZ2VcbiAgICAgIGNvbnN0IG9sZFN0YXR1cyA9IHBhZ2UuZmZfc3RhdHVzXG5cbiAgICAgIGNvbnN0IGlzQ2hhbmdlZCA9IGF3YWl0IHRoaXMuY29ycmVjdE5vdGUocGFnZSlcbiAgICAgIGlmICghaXNDaGFuZ2VkICYmIHBhZ2UuZmZfc3RhdHVzID09IG9sZFBhZ2UuZmZfc3RhdHVzKVxuICAgICAgICBjb250aW51ZVxuXG4gICAgICBuZXcgTm90aWNlKFxuICAgICAgICBgJHtwYWdlLmZpbGUubmFtZX0gLSBjaGFuZ2Ugc3RhdHVzOiAke29sZFN0YXR1c30gPT4gJHtwYWdlLmZmX3N0YXR1c31gXG4gICAgICApXG5cbiAgICAgIGNvbnN0IGNoaWxkID0gYXdhaXQgZ2V0UGFyZW50Tm90ZShwYWdlKVxuICAgICAgZm9yIChsZXQgY2hpbGRyZW4gb2YgY2hpbGQpIHtcbiAgICAgICAgaWYgKCFjaGlsZHJlbilcbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNvbnN0IG5ld1BhdGggPSBjaGlsZHJlbi5maWxlLnBhdGhcbiAgICAgICAgaWYgKHNldC5oYXMobmV3UGF0aCkpXG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBzZXQuYWRkKG5ld1BhdGgpXG4gICAgICAgIHF1ZXVlUGF0aHMucHVzaChuZXdQYXRoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG59XG4iLCAiaW1wb3J0IHsgQXBwLCBOb3RpY2UgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCBNeVBsdWdpbiBmcm9tIFwiLi4vbWFpblwiO1xuaW1wb3J0IHsgSVBhZ2UsIElTdWJzY3JpYmVyLCBTcmMgfSBmcm9tIFwiLi4vdHlwZXNcIlxuaW1wb3J0IHsgTVNHX1BMR19OQU1FIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgc2FmZVBhcnNlSW50IH0gZnJvbSBcIi4uL3V0aWxcIjtcbmltcG9ydCB7IENhY2hlIH0gZnJvbSBcInNyYy9jYWNoZVwiO1xuaW1wb3J0IE5vdGVNYW5hZ2VyIGZyb20gXCJzcmMvTm90ZU1hbmFnZXJcIjtcblxuZXhwb3J0IGNsYXNzIFRpY2tDaGVja2VyIGltcGxlbWVudHMgSVN1YnNjcmliZXIge1xuICBwcml2YXRlIHBhcmVudDogTXlQbHVnaW5cblxuICBwcml2YXRlIGlkRm9yQ2FjaGU6IG51bWJlclxuXG4gIHByaXZhdGUgY2FjaGU6IENhY2hlXG5cbiAgcHJpdmF0ZSBldmVudFNyYzogU3JjW11cblxuICBwcml2YXRlIG5vdGVNYW5hZ2VyOiBOb3RlTWFuYWdlclxuXG5cbiAgY29uc3RydWN0b3IoaWRGb3JDYWNoZTogbnVtYmVyLCBldmVudFNyYzogU3JjW10sIGNhY2hlOiBDYWNoZSwgbm90ZU1hbmFnZXI6IE5vdGVNYW5hZ2VyKSB7XG4gICAgdGhpcy5jYWNoZSA9IGNhY2hlXG4gICAgdGhpcy5pZEZvckNhY2hlID0gaWRGb3JDYWNoZVxuICAgIHRoaXMuZXZlbnRTcmMgPSBldmVudFNyY1xuICAgIHRoaXMubm90ZU1hbmFnZXIgPSBub3RlTWFuYWdlclxuICB9XG5cbiAgcHVibGljIGFzeW5jIGluaXQoKSB7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuY2FjaGUuc3Vic2NyaWJlKHRoaXMuaWRGb3JDYWNoZSwgdGhpcy5ldmVudFNyYywgdGhpcylcblxuICAgIGNvbnN0IGNhbGNzID0gZGF0YS5tYXAoXG4gICAgICBlbCA9PiB0aGlzLnByb2Nlc3MoZWwpXG4gICAgKVxuICAgIGF3YWl0IFByb21pc2UuYWxsKGNhbGNzKVxuXG4gICAgdGhpcy5jYWNoZS51bnN1YnNjcmliZSh0aGlzLmlkRm9yQ2FjaGUpXG4gIH1cblxuXG4gIHByaXZhdGUgYXN5bmMgcHJvY2VzcyhwYWdlOiBJUGFnZSkge1xuICAgIGZvciAobGV0IHRpY2sgb2YgcGFnZS50aWNrcykge1xuICAgICAgaWYgKCBpc05hTihzYWZlUGFyc2VJbnQodGljay5uYW1lKSkgKVxuICAgICAgICBjb250aW51ZVxuXG5cbiAgICAgIGxldCB0ZXh0ID0gYXdhaXQgdGhpcy5ub3RlTWFuYWdlci5nZXRUZXh0KHBhZ2UuZmlsZS5wYXRoKVxuICAgICAgY29uc3QgcmVnRXhwID0gbmV3IFJlZ0V4cChgXFxcXFt0OjpcXFxccyoke3RpY2submFtZX0oLFteXFxcXF1dKnwpXFxcXF1gLCBcImdtXCIpXG5cbiAgICAgIGF3YWl0IHRoaXMubm90ZU1hbmFnZXIuc2V0VGV4dChcbiAgICAgICAgcGFnZS5maWxlLnBhdGgsXG4gICAgICAgIHRleHQucmVwbGFjZShyZWdFeHAsIGBbdDo6JHt0aWNrLm5hbWV9XyQxXWApXG4gICAgICApXG5cbiAgICAgIG5ldyBOb3RpY2UoYCR7TVNHX1BMR19OQU1FfTogY2hhbmdlIHRpY2tuYW1lIGluICR7cGFnZS5maWxlLm5hbWV9OiAke3RpY2submFtZX1gKVxuICAgIH1cblxuICB9XG5cbiAgcmVuYW1lRmlsZShuZXdQYWdlOiBJUGFnZSwgb2xkUGFnZTogSVBhZ2UpOiB2b2lkIHt9XG4gIGRlbGV0ZUZpbGUocGFnZTogSVBhZ2UpOiB2b2lkIHt9XG4gIGFkZEZpbGUocGFnZTogSVBhZ2UpOiB2b2lkIHt9XG4gIGNoYW5nZUZpbGUobmV3UGFnZTogSVBhZ2UsIG9sZFBhZ2U6IElQYWdlKTogdm9pZCB7fVxuICByZXNldCgpOiB2b2lkIHt9XG5cbn1cbiIsICJpbXBvcnQgeyBBcHAsIEZpbGVNYW5hZ2VyLCBNZXRhZGF0YUNhY2hlLCBOb3RpY2UsIFRGaWxlLCBWYXVsdCwgV29ya3NwYWNlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgTXlQbHVnaW4gZnJvbSBcIi4vbWFpblwiO1xuaW1wb3J0IHsgSUV2ZW50LCBJUGFnZSwgSVRhc2tzLCBJRGF0ZSB9IGZyb20gXCIuL3R5cGVzXCI7XG5pbXBvcnQgeyBDYWxlbmRhckV2ZW50VG9JRGF0ZSwgZHYsIGdldFRpY2tzRnJvbVRleHQgfSBmcm9tIFwiLi91dGlsXCI7XG5pbXBvcnQgeyBNU0dfUExHX05BTUUgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTm90ZU1hbmFnZXIge1xuICBwcml2YXRlIHZhdWx0OiBWYXVsdFxuXG4gIHByaXZhdGUgbWV0YWRhdGFDYWNoZTogTWV0YWRhdGFDYWNoZVxuXG4gIHByaXZhdGUgZmlsZU1hbmFnZXI6IEZpbGVNYW5hZ2VyXG5cbiAgcHJpdmF0ZSB3b3Jrc3BhY2U6IFdvcmtzcGFjZVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHZhdWx0OiBWYXVsdCxcbiAgICBtZXRhZGF0YUNhY2hlOiBNZXRhZGF0YUNhY2hlLFxuICAgIGZpbGVNYW5hZ2VyOiBGaWxlTWFuYWdlcixcbiAgICB3b3Jrc3BhY2U6IFdvcmtzcGFjZVxuICApIHtcbiAgICB0aGlzLnZhdWx0ID0gdmF1bHRcbiAgICB0aGlzLm1ldGFkYXRhQ2FjaGUgPSBtZXRhZGF0YUNhY2hlXG4gICAgdGhpcy5maWxlTWFuYWdlciA9IGZpbGVNYW5hZ2VyXG4gICAgdGhpcy53b3Jrc3BhY2UgPSB3b3Jrc3BhY2VcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBjcmVhdGVGaWxlKHBhdGg6IHN0cmluZykge1xuICAgIGF3YWl0IHRoaXMudmF1bHQuY3JlYXRlKHBhdGgsICcnKVxuICAgIG5ldyBOb3RpY2UoTVNHX1BMR19OQU1FICsgXCJjcmVhdGVkIFwiICsgcGF0aClcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBjaGFuZ2VQcm9wZXJ0eUZpbGUocGF0aDogc3RyaW5nLCBldmVudDogSURhdGUpIHtcbiAgICAvLyBOT1RFIFx1MDQ0RFx1MDQ0Mlx1MDQzRSBcdTA0M0VcdTA0NDJcdTA0M0ZcdTA0NDBcdTA0MzBcdTA0MzJcdTA0MzhcdTA0NDIgXHUwNDQxXHUwNDM4XHUwNDMzXHUwNDNEXHUwNDMwXHUwNDNCIGNhY2hlXG4gICAgY29uc3QgdEZpbGUgPSB0aGlzLm1ldGFkYXRhQ2FjaGUuZ2V0Rmlyc3RMaW5rcGF0aERlc3QocGF0aCwgJycpIGFzIFRGaWxlXG4gICAgYXdhaXQgdGhpcy5maWxlTWFuYWdlci5wcm9jZXNzRnJvbnRNYXR0ZXIoXG4gICAgICB0RmlsZSxcbiAgICAgIHByb3BlcnR5ID0+IHtcbiAgICAgICAgcHJvcGVydHlbJ2ZmX2RhdGUnXSAgICAgID0gZXZlbnRbJ2ZmX2RhdGUnXS50b0lTT1N0cmluZygpLnNsaWNlKDAsLTE0KVxuICAgICAgICBwcm9wZXJ0eVsnZmZfdGltZVN0YXJ0J10gPSBldmVudFsnZmZfdGltZVN0YXJ0J11cbiAgICAgICAgcHJvcGVydHlbJ2ZmX2R1cmF0aW9uJ10gID0gZXZlbnRbJ2ZmX2R1cmF0aW9uJ11cbiAgICAgIH1cbiAgICApXG4gIH1cblxuICBwdWJsaWMgYXN5bmMgY2hhbmdlU3RhdHVzRmlsZShwYXRoOiBzdHJpbmcsIHN0YXR1czogc3RyaW5nKSB7XG4gICAgLy8gTk9URSBcdTA0NERcdTA0NDJcdTA0M0UgXHUwNDNFXHUwNDQyXHUwNDNGXHUwNDQwXHUwNDMwXHUwNDMyXHUwNDM4XHUwNDQyIFx1MDQ0MVx1MDQzOFx1MDQzM1x1MDQzRFx1MDQzMFx1MDQzQiBjYWNoZVxuICAgIGNvbnN0IHRGaWxlID0gdGhpcy5tZXRhZGF0YUNhY2hlLmdldEZpcnN0TGlua3BhdGhEZXN0KHBhdGgsICcnKSBhcyBURmlsZVxuICAgIGF3YWl0IHRoaXMuZmlsZU1hbmFnZXIucHJvY2Vzc0Zyb250TWF0dGVyKFxuICAgICAgdEZpbGUsXG4gICAgICBwcm9wZXJ0eSA9PiB7XG4gICAgICAgIHByb3BlcnR5WydmZl9zdGF0dXMnXSA9IHN0YXR1c1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBjaGFuZ2VUaWNrRmlsZShwYXRoOiBzdHJpbmcsIHRpY2tuYW1lOnN0cmluZywgZXZlbnQ6IElEYXRlKSB7XG4gICAgLy8gTk9URSBcdTA0NERcdTA0NDJcdTA0M0UgXHUwNDNFXHUwNDQyXHUwNDNGXHUwNDQwXHUwNDMwXHUwNDMyXHUwNDM4XHUwNDQyIFx1MDQ0MVx1MDQzOFx1MDQzM1x1MDQzRFx1MDQzMFx1MDQzQiBjYWNoZVxuICAgIGNvbnN0IHRGaWxlID0gdGhpcy5tZXRhZGF0YUNhY2hlLmdldEZpcnN0TGlua3BhdGhEZXN0KHBhdGgsICcnKSBhcyBURmlsZVxuXG4gICAgLy8gISBcdTA0M0NcdTA0MzEsIFx1MDQzRlx1MDQzRVx1MDQzQ1x1MDQzNVx1MDQzRFx1MDQ0Rlx1MDQ0Mlx1MDQ0QyBcdTA0NDEgXHUwNDM4XHUwNDQxXHUwNDNGXHUwNDNFXHUwNDNCXHUwNDRDXHUwNDM3XHUwNDNFXHUwNDMyXHUwNDMwXHUwNDNEXHUwNDM4XHUwNDM1XHUwNDNDIFx1MDQzNFx1MDQ0MFx1MDQ0M1x1MDQzM1x1MDQzRVx1MDQzOSBcdTA0M0JcdTA0MzhcdTA0MzFcdTA0NEIgKFx1MDQ0MVx1MDQzQy4gXHUwNDNGXHUwNDNCXHUwNDMwXHUwNDMzXHUwNDM4XHUwNDNEIFx1MDQzNFx1MDQ0MFx1MDQ0M1x1MDQzM1x1MDQzRVx1MDQzOSBcdTA0NDEgXHUwNDMyXHUwNDM4XHUwNDM0XHUwNDNFXHUwNDQxXHUwNDMwIFlvdVR1YmUpXG4gICAgY29uc3QgdGV4dCA9IGF3YWl0IHRoaXMudmF1bHQucmVhZCh0RmlsZSlcbiAgICBjb25zdCByZWdFeHAgPSBuZXcgUmVnRXhwKGBcXFxcW3Q6OlxcXFxzKiR7dGlja25hbWV9KCxbXlxcXFxdXSp8KVxcXFxdYCwgXCJnbVwiKVxuXG4gICAgY29uc3QgZGF0ZSA9IGV2ZW50W1wiZmZfZGF0ZVwiXS50b0lTT1N0cmluZygpLnNsaWNlKDAsLTE0KVxuICAgIGNvbnN0IG5ld1N0cmluZyA9IGBbdDo6JHt0aWNrbmFtZX0sJHtkYXRlfSwke2V2ZW50W1wiZmZfdGltZVN0YXJ0XCJdfSwke2V2ZW50WydmZl9kdXJhdGlvbiddfV1gXG5cbiAgICBhd2FpdCB0aGlzLnZhdWx0Lm1vZGlmeShcbiAgICAgIHRGaWxlLFxuICAgICAgdGV4dC5yZXBsYWNlKHJlZ0V4cCwgbmV3U3RyaW5nKVxuICAgIClcbiAgfVxuXG4gIHB1YmxpYyBvcGVuTm90ZShldmVudDogSUV2ZW50KSB7XG4gICAgLy8gTk9URSBcdTA0NDFcdTA0M0RcdTA0MzBcdTA0NDdcdTA0MzBcdTA0M0JcdTA0MzAgXHUwNDNGXHUwNDQwXHUwNDNFXHUwNDMyXHUwNDM1XHUwNDQwXHUwNDRGXHUwNDM1XHUwNDQyIFx1MDQ0Mlx1MDQzOFx1MDQzQSBcdTA0M0JcdTA0MzggXHUwNDREXHUwNDQyXHUwNDNFLCBcdTA0MzAgXHUwNDNGXHUwNDNFXHUwNDQyXHUwNDNFXHUwNDNDIFx1MDQzRlx1MDQzNVx1MDQ0MFx1MDQzNVx1MDQ0NVx1MDQzRVx1MDQzNFx1MDQzOFx1MDQ0MiBcdTA0M0EgaWRcbiAgICBjb25zdCB0RmlsZSA9IHRoaXMubWV0YWRhdGFDYWNoZS5nZXRGaXJzdExpbmtwYXRoRGVzdChcbiAgICAgIGV2ZW50Py5leHRlbmRlZFByb3BzPy5ub3RlUGF0aCB8fCBldmVudC5pZCwgJydcbiAgICApXG5cbiAgICAvLyBmYWxzZSA9IG9wZW4gaW4gdGhlIGN1cnJlbnQgdGFiXG4gICAgY29uc3QgbGVhZiA9IHRoaXMud29ya3NwYWNlLmdldExlYWYodHJ1ZSlcbiAgICB0RmlsZSAmJiBsZWFmLm9wZW5GaWxlKHRGaWxlKVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGdldFBhZ2UoZmlsZTogVEZpbGUpOiBQcm9taXNlPElQYWdlPiB7XG4gICAgY29uc3QgcmVzdWx0OiBJUGFnZSA9IHtcbiAgICAgIGZpbGU6IHtcbiAgICAgICAgcGF0aDogZmlsZS5wYXRoLFxuICAgICAgICBuYW1lOiBmaWxlLmJhc2VuYW1lXG4gICAgICB9LFxuICAgICAgdGlja3M6IGdldFRpY2tzRnJvbVRleHQoYXdhaXQgdGhpcy52YXVsdC5jYWNoZWRSZWFkKGZpbGUpKSxcbiAgICAgIGZmX2R1cmF0aW9uOiBcIlwiLFxuICAgICAgZmZfdGltZVN0YXJ0OiBcIlwiLFxuXG4gICAgICAvLyBUT0RPIFx1MDQzOFx1MDQzNy1cdTA0MzdcdTA0MzAgXHUwNDQyXHUwNDNFXHUwNDMzXHUwNDNFLCBcdTA0NDdcdTA0NDJcdTA0M0UgXHUwNDNEXHUwNDM1IFx1MDQzMlx1MDQ0MVx1MDQzNSBcdTA0MzdcdTA0MzBcdTA0M0NcdTA0MzVcdTA0NDJcdTA0M0FcdTA0MzggXHUwNDM4XHUwNDNDXHUwNDM1XHUwNDRFXHUwNDQyIGZmX2RhdGUsIFx1MDQzRVx1MDQzRCBcdTA0MzRcdTA0M0VcdTA0M0JcdTA0MzZcdTA0MzVcdTA0M0QgXHUwNDMyXHUwNDNFXHUwNDM3XHUwNDMyXHUwNDQwXHUwNDMwXHUwNDQ5XHUwNDMwXHUwNDQyXHUwNDRDIG51bGwsIFx1MDQzRFx1MDQzRSBcdTA0NERcdTA0NDJcdTA0M0UgYmFkIHByYWN0aWNlXG4gICAgICAvL0B0cy1pZ25vcmVcbiAgICAgIGZmX2RhdGU6IG51bGwsXG4gICAgfVxuXG4gICAgY29uc3QgcHJvcGVydHkgPSB0aGlzLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGZpbGUpPy5mcm9udG1hdHRlclxuICAgIGlmICghcHJvcGVydHkpIHtcbiAgICAgIC8vIGJhZCB3YXksIGNhdXNlIGl0IG1heSBoYXZlbid0IGV4cGVjdGVkIGZpZWxkc1xuICAgICAgLy8gVE9ETyB0aHJvdyBFcnJvcihcInVucmVhY2hhYmxlXCIpXG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuXG4gICAgY29uc3QgYWRkZWQgPSB7XG4gICAgICBmZl9kdXJhdGlvbjogZHYuZHVyYXRpb24ocHJvcGVydHkuZmZfZHVyYXRpb24pLFxuICAgICAgZmZfdGltZVN0YXJ0OiBkdi5kdXJhdGlvbihwcm9wZXJ0eS5mZl90aW1lU3RhcnQpLFxuICAgICAgZmZfZGF0ZTogZHYuZGF0ZShwcm9wZXJ0eS5mZl9kYXRlKSxcbiAgICAgIGZmX3N0YXR1czogcHJvcGVydHkuZmZfc3RhdHVzXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlc3VsdCxcbiAgICAgIC4uLmFkZGVkXG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldFRhc2tDb3VudChwYWdlOiBJUGFnZSk6IElUYXNrcyB7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgZG9uZTogMCxcbiAgICAgIGFsbDogMFxuICAgIH1cblxuICAgIGNvbnN0IHRGaWxlID0gdGhpcy52YXVsdC5nZXRGaWxlQnlQYXRoKHBhZ2UuZmlsZS5wYXRoKVxuXG4gICAgaWYgKCF0RmlsZSlcbiAgICAgIHJldHVybiByZXN1bHRcblxuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZSh0RmlsZSk/Lmxpc3RJdGVtc1xuXG4gICAgaWYgKGl0ZW1zKSBmb3IgKGxldCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICBpZiAoaXRlbS50YXNrID09IHVuZGVmaW5lZClcbiAgICAgICAgY29udGludWVcblxuICAgICAgaWYgKGl0ZW0udGFzayA9PSAneCcpIHtcbiAgICAgICAgKytyZXN1bHQuZG9uZVxuICAgICAgfVxuICAgICAgKytyZXN1bHQuYWxsXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgcHVibGljIGFzeW5jIGdldFRleHQocGF0aDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBjb25zdCB0RmlsZSA9IHRoaXMubWV0YWRhdGFDYWNoZS5nZXRGaXJzdExpbmtwYXRoRGVzdChwYXRoLCAnJykgYXMgVEZpbGVcbiAgICBjb25zdCB0ZXh0ID0gYXdhaXQgdGhpcy52YXVsdC5yZWFkKHRGaWxlKVxuXG4gICAgcmV0dXJuIHRleHRcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBzZXRUZXh0KHBhdGg6IHN0cmluZywgdGV4dDogc3RyaW5nKSB7XG4gICAgY29uc3QgdEZpbGUgPSB0aGlzLm1ldGFkYXRhQ2FjaGUuZ2V0Rmlyc3RMaW5rcGF0aERlc3QocGF0aCwgJycpIGFzIFRGaWxlXG5cbiAgICBhd2FpdCB0aGlzLnZhdWx0Lm1vZGlmeSh0RmlsZSwgdGV4dClcbiAgfVxuXG59XG4iXSwK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QWM7QUFBQSxFQUNkLGlCQUFpQjtBQUFBLEVBQ2pCLFlBQVk7QUFBQSxFQUNaLHNCQUFzQjtBQUFBLEVBQ3RCLGtCQUFrQjtBQUFBLEVBQ2xCLGdCQUFnQjtBQUFBLEVBQ2hCLFlBQVk7QUFBQSxFQUNaLGlCQUFpQjtBQUFBLEVBQ2pCLGNBQWM7QUFBQSxFQUNkLGVBQWU7QUFBQSxFQUNmLGtCQUFrQjtBQUFBLEVBQ2xCLGtCQUFrQjtBQUFBLEVBQ2xCLGVBQWU7QUFBQSxFQUNmLGFBQWE7QUFBQSxFQUNiLFdBQVc7QUFBQSxFQUNYLGdCQUFnQjtBQUFBLEVBQ2hCLGlCQUFpQjtBQUFBLEVBQ2pCLG9CQUFvQjtBQUFBLEVBQ3BCLGlCQUFpQjtBQUFBLEVBQ2pCLGtCQUFrQjtBQUFBLEVBQ2xCLHFCQUFxQjtBQUFBLEVBQ3JCLHFCQUFxQjtBQUFBLEVBQ3JCLGtCQUFrQjtBQUFBLEVBQ2xCLG1CQUFtQjtBQUFBLEVBQ25CLHNCQUFzQjtBQUFBLEVBQ3RCLGNBQWM7QUFBQSxFQUNkLGlCQUFpQjtBQUFBLEVBQ2pCLGFBQWE7QUFBQSxFQUNiLG1CQUFtQjtBQUFBLEVBQ25CLFlBQVk7QUFBQSxFQUNaLGtCQUFrQjtBQUFBLEVBQ2xCLGVBQWU7QUFBQSxFQUNmLGdCQUFnQjtBQUFBLEVBQ2hCLG1CQUFtQjtBQUFBLEVBQ25CLGNBQWM7QUFBQSxFQUNkLFVBQVU7QUFBQSxFQUNWLGlCQUFpQjtBQUFBLEVBQ2pCLGVBQWU7QUFBQSxFQUNmLGNBQWM7QUFBQSxFQUNkLGNBQWM7QUFBQSxFQUNkLG1CQUFtQjtBQUFBLEVBQ25CLFlBQVk7QUFBQSxFQUNaLHNCQUFzQjtBQUFBLEVBQ3RCLHFCQUFxQjtBQUFBLEVBQ3JCLGNBQWM7QUFBQSxFQUNkLGVBQWU7QUFBQSxFQUNmLGdCQUFnQjtBQUFBLEVBQ2hCLGVBQWU7QUFBQSxFQUNmLGtCQUFrQjtBQUFBLEVBQ2xCLGtCQUFrQjtBQUFBLEVBQ2xCLFNBQVM7QUFBQSxFQUNULFVBQVU7QUFBQSxFQUNWLFVBQVU7QUFBQSxFQUNWLGVBQWU7QUFBQSxFQUNmLGVBQWU7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O0FBQUEsUUFDdEIsTUFBTTtBQUFBLFFBQ04sUUFBUTtBQUFBLE1BQ1YsQ0FBQztBQUFBLElBQ0gsV0FDUyxPQUFPLFdBQVcsR0FBRztBQUM1QixNQUFDLE9BQU8sQ0FBQyxFQUFFLEtBQXNCLE9BQU87QUFDeEMsV0FBSyxJQUFJLFVBQVUsY0FBYyxPQUFPLENBQUMsQ0FBQztBQUFBLElBQzVDO0FBQ0ssZUFBUyxRQUFRO0FBQ3BCLGFBQUssT0FBTztBQUFBLEVBQ2hCO0FBQUE7QUFBQSxFQUtPLGNBQThCO0FBRW5DLFdBQU8sS0FBSztBQUFBLE1BQ1YsS0FBSyxVQUFVLEtBQUssUUFBUTtBQUFBLElBQzlCO0FBQUEsRUFDRjtBQUFBLEVBRUEsTUFBYSxhQUFhLFVBQTBCO0FBQ2xELFNBQUssV0FBVztBQUNoQixVQUFNLEtBQUssU0FBUyxLQUFLLFFBQVE7QUFBQSxFQUNuQztBQUFBLEVBSUEsTUFBYyxlQUFlO0FBQzNCLFNBQUssV0FBVyxPQUFPLE9BQU8sQ0FBQyxHQUFHLGtCQUFrQixNQUFNLEtBQUssU0FBUyxDQUFDO0FBRXpFLFNBQUssY0FBYyxJQUFJLGFBQWEsS0FBSyxLQUFLLElBQUksQ0FBQztBQUFBLEVBQ3JEO0FBQ0Y7IiwKICAibmFtZXMiOiBbIm4iLCAicyIsICJsIiwgInNpbmdsZXRvbiIsICJpIiwgImUiLCAiZiIsICJEYXRlVGltZSIsICJwYWRTdGFydCIsICJ6IiwgIkVuZ2xpc2guZm9ybWF0UmVsYXRpdmVUaW1lIiwgIkVuZ2xpc2gubW9udGhzIiwgIkVuZ2xpc2gud2Vla2RheXMiLCAiRW5nbGlzaC5tZXJpZGllbXMiLCAiRW5nbGlzaC5lcmFzIiwgIm0iLCAib2Zmc2V0IiwgInIiLCAiZGVmYXVsdFpvbmUiLCAiaXNOdW1iZXIiLCAidCIsICJvIiwgImlzRGF0ZSIsICJhIiwgImsiLCAiaGFzT3duUHJvcGVydHkiLCAieCIsICJpc0xlYXBZZWFyIiwgImQiLCAicDIiLCAidSIsICJ2IiwgIkZvcm1hdHMuREFURV9TSE9SVCIsICJGb3JtYXRzLkRBVEVfTUVEIiwgIkZvcm1hdHMuREFURV9GVUxMIiwgIkZvcm1hdHMuREFURV9IVUdFIiwgIkZvcm1hdHMuVElNRV9TSU1QTEUiLCAiRm9ybWF0cy5USU1FX1dJVEhfU0VDT05EUyIsICJGb3JtYXRzLlRJTUVfV0lUSF9TSE9SVF9PRkZTRVQiLCAiRm9ybWF0cy5USU1FX1dJVEhfTE9OR19PRkZTRVQiLCAiRm9ybWF0cy5USU1FXzI0X1NJTVBMRSIsICJGb3JtYXRzLlRJTUVfMjRfV0lUSF9TRUNPTkRTIiwgIkZvcm1hdHMuVElNRV8yNF9XSVRIX1NIT1JUX09GRlNFVCIsICJGb3JtYXRzLlRJTUVfMjRfV0lUSF9MT05HX09GRlNFVCIsICJGb3JtYXRzLkRBVEVUSU1FX1NIT1JUIiwgIkZvcm1hdHMuREFURVRJTUVfTUVEIiwgIkZvcm1hdHMuREFURVRJTUVfRlVMTCIsICJGb3JtYXRzLkRBVEVUSU1FX0hVR0UiLCAiRm9ybWF0cy5EQVRFVElNRV9TSE9SVF9XSVRIX1NFQ09ORFMiLCAiRm9ybWF0cy5EQVRFVElNRV9NRURfV0lUSF9TRUNPTkRTIiwgIkZvcm1hdHMuREFURVRJTUVfRlVMTF9XSVRIX1NFQ09ORFMiLCAiRm9ybWF0cy5EQVRFVElNRV9IVUdFX1dJVEhfU0VDT05EUyIsICJjIiwgInAiLCAiZm9ybWF0T2Zmc2V0IiwgIkVuZ2xpc2gubWVyaWRpZW1Gb3JEYXRlVGltZSIsICJFbmdsaXNoLm1vbnRoRm9yRGF0ZVRpbWUiLCAiRW5nbGlzaC53ZWVrZGF5Rm9yRGF0ZVRpbWUiLCAiRW5nbGlzaC5lcmFGb3JEYXRlVGltZSIsICJwYXJzZSIsICJtYXRjaCIsICJFbmdsaXNoLm1vbnRoc1Nob3J0IiwgIkVuZ2xpc2gud2Vla2RheXNMb25nIiwgIkVuZ2xpc2gud2Vla2RheXNTaG9ydCIsICJJTlZBTElEIiwgIm9yZGVyZWRVbml0cyIsICJjbG9uZSIsICJjb25maWciLCAidjIiLCAiYiIsICJoIiwgIm8yIiwgImMyIiwgInEiLCAiRm9ybWF0cy5EQVRFX01FRF9XSVRIX1dFRUtEQVkiLCAiRm9ybWF0cy5EQVRFVElNRV9NRURfV0lUSF9XRUVLREFZIiwgIlJlc3VsdCIsICJtb2R1bGUiLCAidGhpcyIsICJnIiwgInkiLCAiRSIsICJ3IiwgIkIiLCAiaiIsICJTIiwgIl8iLCAiTCIsICJPIiwgIlAiLCAiQSIsICJJIiwgIkYiLCAiTSIsICJVIiwgIlciLCAiRCIsICJOIiwgIkciLCAiQyIsICJKIiwgIlQiLCAiViIsICJIIiwgIlgiLCAiSyIsICJRIiwgIloiLCAiJCIsICJubiIsICJ0biIsICJlbiIsICJQLmFsdCIsICJQLnJlZ2V4IiwgIlAud2hpdGVzcGFjZSIsICJQLmFueSIsICJWYWx1ZXMiLCAiaXNTdHJpbmciLCAiaXNBcnJheSIsICJpc09iamVjdCIsICJmMiIsICJpbmRleCIsICJrMiIsICJpc1RydXRoeSIsICJHcm91cGluZ3MiLCAiZGlzcGxheSIsICJzcGxpdCIsICJXaWRnZXRzIiwgIkZpZWxkcyIsICJmdW5jIiwgIlNvdXJjZXMiLCAidGFnIiwgImVtcHR5IiwgImNvbWJpbmUiLCAiUC5zZXFNYXAiLCAiUC5zZXEiLCAiUC5vcHRXaGl0ZXNwYWNlIiwgIlAuY3VzdG9tIiwgIlAuY3JlYXRlTGFuZ3VhZ2UiLCAiUC5yZWdleHAiLCAiUC5zdHJpbmciLCAiUC5ub25lT2YiLCAiUC5zdWNjZWVkIiwgIl8yIiwgIlAuZmFpbCIsICJfMyIsICJRdWVyeUZpZWxkcyIsICJQLmVvZiIsICJQLlBhcnNlciIsICJQLm1ha2VGYWlsdXJlIiwgIlAubWFrZVN1Y2Nlc3MiLCAiUC5zZXBCeSIsICJzb3J0IiwgImdldEFQSSIsICJtb2R1bGUiLCAiSUNBTCIsICJpIiwgIkYiLCAiayIsICJ4IiwgImUiLCAic3BsaXQiLCAiQ29tcG9uZW50IiwgImluZGV4IiwgInAiLCAiYSIsICJiIiwgImgyIiwgInIiLCAiYVByb3AiLCAiY2xvbmUiLCAicSIsICJtIiwgImgiLCAiZGF5c0JldHdlZW4iLCAiaXNEYXRlIiwgImlzTGVhcFllYXIiLCAidCIsICJwMiIsICJ5IiwgImQiLCAicyIsICJ2IiwgIm8iLCAiaXRlciIsICJrZXkiLCAic2VsZiIsICJ0MiIsICJ0MyIsICJqIiwgInByb3AiLCAiRXZlbnQiLCAicmFuZ2UiLCAiaW1wb3J0X29ic2lkaWFuIiwgImkiLCAiXyIsICJpbmRleCIsICJwYWdlIiwgInNsaWNlIiwgIm9wdGlvbnMiLCAidm5vZGVJZCIsICJpc1ZhbGlkRWxlbWVudCIsICJpbkV2ZW50IiwgInJlcmVuZGVyUXVldWUiLCAicHJldkRlYm91bmNlIiwgIm1pY3JvVGljayIsICJpIiwgIkVNUFRZX09CSiIsICJFTVBUWV9BUlIiLCAiSVNfTk9OX0RJTUVOU0lPTkFMIiwgImFzc2lnbiIsICJvYmoiLCAicHJvcHMiLCAicmVtb3ZlTm9kZSIsICJub2RlIiwgInBhcmVudE5vZGUiLCAicmVtb3ZlQ2hpbGQiLCAiY3JlYXRlRWxlbWVudCIsICJ0eXBlIiwgImNoaWxkcmVuIiwgImtleSIsICJyZWYiLCAibm9ybWFsaXplZFByb3BzIiwgImFyZ3VtZW50cyIsICJsZW5ndGgiLCAiY2FsbCIsICJkZWZhdWx0UHJvcHMiLCAiY3JlYXRlVk5vZGUiLCAib3JpZ2luYWwiLCAidm5vZGUiLCAiX19rIiwgIl9fIiwgIl9fYiIsICJfX2UiLCAiX19kIiwgIl9fYyIsICJfX2giLCAiY29uc3RydWN0b3IiLCAiX192IiwgImNyZWF0ZVJlZiIsICJjdXJyZW50IiwgIkZyYWdtZW50IiwgImRpZmZQcm9wcyIsICJkb20iLCAibmV3UHJvcHMiLCAib2xkUHJvcHMiLCAiaXNTdmciLCAiaHlkcmF0ZSIsICJzZXRQcm9wZXJ0eSIsICJzZXRTdHlsZSIsICJzdHlsZSIsICJ2YWx1ZSIsICJ0ZXN0IiwgIm5hbWUiLCAib2xkVmFsdWUiLCAidXNlQ2FwdHVyZSIsICJvIiwgImNzc1RleHQiLCAicmVwbGFjZSIsICJ0b0xvd2VyQ2FzZSIsICJsIiwgImFkZEV2ZW50TGlzdGVuZXIiLCAiZXZlbnRQcm94eUNhcHR1cmUiLCAiZXZlbnRQcm94eSIsICJyZW1vdmVFdmVudExpc3RlbmVyIiwgImUiLCAiaW5kZXhPZiIsICJyZW1vdmVBdHRyaWJ1dGUiLCAic2V0QXR0cmlidXRlIiwgInRoaXMiLCAiZXZlbnQiLCAiQ29tcG9uZW50IiwgImNvbnRleHQiLCAiZ2V0RG9tU2libGluZyIsICJjaGlsZEluZGV4IiwgInNpYmxpbmciLCAidXBkYXRlUGFyZW50RG9tUG9pbnRlcnMiLCAiY2hpbGQiLCAiYmFzZSIsICJkZWZlciIsICJjYiIsICJzZXRUaW1lb3V0IiwgImVucXVldWVSZW5kZXIiLCAiYyIsICJwdXNoIiwgInByb2Nlc3MiLCAiX19yIiwgImRlYm91bmNlUmVuZGVyaW5nIiwgInJlbmRlclF1ZXVlTGVuZ3RoIiwgImNvbXBvbmVudCIsICJjb21taXRRdWV1ZSIsICJvbGRWTm9kZSIsICJvbGREb20iLCAicGFyZW50RG9tIiwgInNvcnQiLCAiYSIsICJiIiwgInNoaWZ0IiwgIl9fUCIsICJkaWZmIiwgIm93bmVyU1ZHRWxlbWVudCIsICJjb21taXRSb290IiwgImRpZmZDaGlsZHJlbiIsICJyZW5kZXJSZXN1bHQiLCAibmV3UGFyZW50Vk5vZGUiLCAib2xkUGFyZW50Vk5vZGUiLCAiZ2xvYmFsQ29udGV4dCIsICJleGNlc3NEb21DaGlsZHJlbiIsICJpc0h5ZHJhdGluZyIsICJqIiwgImNoaWxkVk5vZGUiLCAibmV3RG9tIiwgImZpcnN0Q2hpbGREb20iLCAicmVmcyIsICJvbGRDaGlsZHJlbiIsICJvbGRDaGlsZHJlbkxlbmd0aCIsICJBcnJheSIsICJpc0FycmF5IiwgInJlb3JkZXJDaGlsZHJlbiIsICJwbGFjZUNoaWxkIiwgImdldExhc3REb20iLCAibmV4dFNpYmxpbmciLCAidW5tb3VudCIsICJhcHBseVJlZiIsICJ0bXAiLCAidG9DaGlsZEFycmF5IiwgIm91dCIsICJzb21lIiwgIm5leHREb20iLCAic2liRG9tIiwgIm91dGVyIiwgImFwcGVuZENoaWxkIiwgImluc2VydEJlZm9yZSIsICJsYXN0RG9tIiwgIm5ld1ZOb2RlIiwgImlzTmV3IiwgIm9sZFN0YXRlIiwgInNuYXBzaG90IiwgImNsZWFyUHJvY2Vzc2luZ0V4Y2VwdGlvbiIsICJwcm92aWRlciIsICJjb21wb25lbnRDb250ZXh0IiwgInJlbmRlckhvb2siLCAiY291bnQiLCAibmV3VHlwZSIsICJjb250ZXh0VHlwZSIsICJfX0UiLCAicHJvdG90eXBlIiwgInJlbmRlciIsICJkb1JlbmRlciIsICJzdWIiLCAic3RhdGUiLCAiX3NiIiwgIl9fcyIsICJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCAiY29tcG9uZW50V2lsbE1vdW50IiwgImNvbXBvbmVudERpZE1vdW50IiwgImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCAic2hvdWxkQ29tcG9uZW50VXBkYXRlIiwgImZvckVhY2giLCAiY29tcG9uZW50V2lsbFVwZGF0ZSIsICJjb21wb25lbnREaWRVcGRhdGUiLCAiZ2V0Q2hpbGRDb250ZXh0IiwgImdldFNuYXBzaG90QmVmb3JlVXBkYXRlIiwgImRpZmZFbGVtZW50Tm9kZXMiLCAiZGlmZmVkIiwgInJvb3QiLCAib2xkSHRtbCIsICJuZXdIdG1sIiwgIm5vZGVUeXBlIiwgImxvY2FsTmFtZSIsICJkb2N1bWVudCIsICJjcmVhdGVUZXh0Tm9kZSIsICJjcmVhdGVFbGVtZW50TlMiLCAiaXMiLCAiZGF0YSIsICJjaGlsZE5vZGVzIiwgImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwgImF0dHJpYnV0ZXMiLCAiX19odG1sIiwgImlubmVySFRNTCIsICJjaGVja2VkIiwgInBhcmVudFZOb2RlIiwgInNraXBSZW1vdmUiLCAiciIsICJjb21wb25lbnRXaWxsVW5tb3VudCIsICJyZXBsYWNlTm9kZSIsICJmaXJzdENoaWxkIiwgImNyZWF0ZUNvbnRleHQiLCAiZGVmYXVsdFZhbHVlIiwgImNvbnRleHRJZCIsICJjb250ZXh0IiwgIl9fYyIsICJpIiwgIl9fIiwgIkNvbnN1bWVyIiwgInByb3BzIiwgImNvbnRleHRWYWx1ZSIsICJjaGlsZHJlbiIsICJQcm92aWRlciIsICJzdWJzIiwgImN0eCIsICJ0aGlzIiwgImdldENoaWxkQ29udGV4dCIsICJzaG91bGRDb21wb25lbnRVcGRhdGUiLCAiX3Byb3BzIiwgInZhbHVlIiwgInNvbWUiLCAiYyIsICJfX2UiLCAiZW5xdWV1ZVJlbmRlciIsICJzdWIiLCAicHVzaCIsICJvbGQiLCAiY29tcG9uZW50V2lsbFVubW91bnQiLCAic3BsaWNlIiwgImluZGV4T2YiLCAiY2FsbCIsICJjb250ZXh0VHlwZSIsICJzbGljZSIsICJFTVBUWV9BUlIiLCAib3B0aW9ucyIsICJlcnJvciIsICJ2bm9kZSIsICJvbGRWTm9kZSIsICJlcnJvckluZm8iLCAiY29tcG9uZW50IiwgImN0b3IiLCAiaGFuZGxlZCIsICJjb25zdHJ1Y3RvciIsICJnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IiLCAic2V0U3RhdGUiLCAiX19kIiwgImNvbXBvbmVudERpZENhdGNoIiwgIl9fRSIsICJlIiwgInZub2RlSWQiLCAiaXNWYWxpZEVsZW1lbnQiLCAiaW5FdmVudCIsICJDb21wb25lbnQiLCAicHJvdG90eXBlIiwgInVwZGF0ZSIsICJjYWxsYmFjayIsICJzIiwgIl9fcyIsICJzdGF0ZSIsICJhc3NpZ24iLCAiX192IiwgIl9zYiIsICJmb3JjZVVwZGF0ZSIsICJfX2giLCAicmVuZGVyIiwgIkZyYWdtZW50IiwgInJlcmVuZGVyUXVldWUiLCAibWljcm9UaWNrIiwgIlByb21pc2UiLCAidGhlbiIsICJiaW5kIiwgInJlc29sdmUiLCAic2V0VGltZW91dCIsICJwcm9jZXNzIiwgIl9fciIsICJjdXJyZW50SW5kZXgiLCAiY3VycmVudENvbXBvbmVudCIsICJwcmV2aW91c0NvbXBvbmVudCIsICJwcmV2UmFmIiwgImFmdGVyUGFpbnRFZmZlY3RzIiwgIkVNUFRZIiwgIm9sZEJlZm9yZURpZmYiLCAib3B0aW9ucyIsICJvbGRCZWZvcmVSZW5kZXIiLCAib2xkQWZ0ZXJEaWZmIiwgImRpZmZlZCIsICJvbGRDb21taXQiLCAiX19jIiwgIm9sZEJlZm9yZVVubW91bnQiLCAidW5tb3VudCIsICJmbHVzaEFmdGVyUGFpbnRFZmZlY3RzIiwgImNvbXBvbmVudCIsICJhZnRlclBhaW50RWZmZWN0cyIsICJzaGlmdCIsICJfX0giLCAiZm9yRWFjaCIsICJpbnZva2VDbGVhbnVwIiwgImludm9rZUVmZmVjdCIsICJfX2giLCAiZSIsICJvcHRpb25zIiwgIl9fZSIsICJfX2IiLCAidm5vZGUiLCAiY3VycmVudENvbXBvbmVudCIsICJvbGRCZWZvcmVEaWZmIiwgIm9sZEJlZm9yZVJlbmRlciIsICJjdXJyZW50SW5kZXgiLCAiaG9va3MiLCAiX19jIiwgInByZXZpb3VzQ29tcG9uZW50IiwgIl9fIiwgImhvb2tJdGVtIiwgIl9fTiIsICJFTVBUWSIsICJfcGVuZGluZ0FyZ3MiLCAiZGlmZmVkIiwgIm9sZEFmdGVyRGlmZiIsICJjIiwgImxlbmd0aCIsICJwdXNoIiwgInByZXZSYWYiLCAicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwgImFmdGVyTmV4dEZyYW1lIiwgIl9fViIsICJjb21taXRRdWV1ZSIsICJzb21lIiwgImZpbHRlciIsICJjYiIsICJfX3YiLCAib2xkQ29tbWl0IiwgInVubW91bnQiLCAib2xkQmVmb3JlVW5tb3VudCIsICJoYXNFcnJvcmVkIiwgInMiLCAiSEFTX1JBRiIsICJjYWxsYmFjayIsICJyYWYiLCAiZG9uZSIsICJjbGVhclRpbWVvdXQiLCAidGltZW91dCIsICJjYW5jZWxBbmltYXRpb25GcmFtZSIsICJzZXRUaW1lb3V0IiwgImhvb2siLCAiY29tcCIsICJjbGVhbnVwIiwgImFzc2lnbiIsICJvYmoiLCAicHJvcHMiLCAiaSIsICJzaGFsbG93RGlmZmVycyIsICJhIiwgImIiLCAiUHVyZUNvbXBvbmVudCIsICJwIiwgInRoaXMiLCAicHJvcHMiLCAiUHVyZUNvbXBvbmVudCIsICJwcm90b3R5cGUiLCAiQ29tcG9uZW50IiwgImlzUHVyZVJlYWN0Q29tcG9uZW50IiwgInNob3VsZENvbXBvbmVudFVwZGF0ZSIsICJwcm9wcyIsICJzdGF0ZSIsICJzaGFsbG93RGlmZmVycyIsICJ0aGlzIiwgIm9sZERpZmZIb29rIiwgIm9wdGlvbnMiLCAiX19iIiwgInZub2RlIiwgInR5cGUiLCAiX19mIiwgInJlZiIsICJSRUFDVF9GT1JXQVJEX1NZTUJPTCIsICJTeW1ib2wiLCAiZm9yIiwgIm9sZENhdGNoRXJyb3IiLCAib3B0aW9ucyIsICJfX2UiLCAiZXJyb3IiLCAibmV3Vk5vZGUiLCAib2xkVk5vZGUiLCAiZXJyb3JJbmZvIiwgInRoZW4iLCAiY29tcG9uZW50IiwgInZub2RlIiwgIl9fYyIsICJfX2siLCAib2xkVW5tb3VudCIsICJ1bm1vdW50IiwgImRldGFjaGVkQ2xvbmUiLCAiZGV0YWNoZWRQYXJlbnQiLCAicGFyZW50RG9tIiwgImZvckVhY2giLCAiZWZmZWN0IiwgIl9fSCIsICJhc3NpZ24iLCAiX19QIiwgIm1hcCIsICJjaGlsZCIsICJyZW1vdmVPcmlnaW5hbCIsICJvcmlnaW5hbFBhcmVudCIsICJfX3YiLCAiaW5zZXJ0QmVmb3JlIiwgIl9fZCIsICJTdXNwZW5zZSIsICJ0aGlzIiwgIl9fdSIsICJfc3VzcGVuZGVycyIsICJzdXNwZW5kZWQiLCAiX18iLCAiX19hIiwgIlN1c3BlbnNlTGlzdCIsICJ0aGlzIiwgIl9uZXh0IiwgIl9tYXAiLCAib3B0aW9ucyIsICJ1bm1vdW50IiwgInZub2RlIiwgImNvbXBvbmVudCIsICJfX2MiLCAiX19SIiwgIl9faCIsICJ0eXBlIiwgIm9sZFVubW91bnQiLCAiU3VzcGVuc2UiLCAicHJvdG90eXBlIiwgIkNvbXBvbmVudCIsICJwcm9taXNlIiwgInN1c3BlbmRpbmdWTm9kZSIsICJzdXNwZW5kaW5nQ29tcG9uZW50IiwgImMiLCAiX3N1c3BlbmRlcnMiLCAicHVzaCIsICJyZXNvbHZlIiwgInN1c3BlbmRlZCIsICJfX3YiLCAicmVzb2x2ZWQiLCAib25SZXNvbHZlZCIsICJvblN1c3BlbnNpb25Db21wbGV0ZSIsICJfX3UiLCAic3RhdGUiLCAiX19hIiwgInN1c3BlbmRlZFZOb2RlIiwgIl9fayIsICJyZW1vdmVPcmlnaW5hbCIsICJzZXRTdGF0ZSIsICJfX2IiLCAicG9wIiwgImZvcmNlVXBkYXRlIiwgIndhc0h5ZHJhdGluZyIsICJ0aGVuIiwgImNvbXBvbmVudFdpbGxVbm1vdW50IiwgInJlbmRlciIsICJwcm9wcyIsICJkZXRhY2hlZFBhcmVudCIsICJkb2N1bWVudCIsICJjcmVhdGVFbGVtZW50IiwgImRldGFjaGVkQ29tcG9uZW50IiwgImRldGFjaGVkQ2xvbmUiLCAiX19PIiwgIl9fUCIsICJmYWxsYmFjayIsICJGcmFnbWVudCIsICJjaGlsZHJlbiIsICJsaXN0IiwgImNoaWxkIiwgIm5vZGUiLCAiZGVsZXRlIiwgInJldmVhbE9yZGVyIiwgInNpemUiLCAibGVuZ3RoIiwgIkNvbnRleHRQcm92aWRlciIsICJnZXRDaGlsZENvbnRleHQiLCAiY29udGV4dCIsICJQb3J0YWwiLCAiX3RoaXMiLCAiY29udGFpbmVyIiwgIl9jb250YWluZXIiLCAiX3RlbXAiLCAibm9kZVR5cGUiLCAicGFyZW50Tm9kZSIsICJjaGlsZE5vZGVzIiwgImFwcGVuZENoaWxkIiwgImluc2VydEJlZm9yZSIsICJiZWZvcmUiLCAicmVtb3ZlQ2hpbGQiLCAic3BsaWNlIiwgImluZGV4T2YiLCAiY3JlYXRlUG9ydGFsIiwgImVsIiwgImNvbnRhaW5lckluZm8iLCAiZGVsZWdhdGVkIiwgImdldCIsICJ1bnN1c3BlbmQiLCAid3JhcHBlZFVuc3VzcGVuZCIsICJNYXAiLCAidG9DaGlsZEFycmF5IiwgInJldmVyc2UiLCAiaSIsICJzZXQiLCAiY29tcG9uZW50RGlkVXBkYXRlIiwgImNvbXBvbmVudERpZE1vdW50IiwgImZvckVhY2giLCAiUkVBQ1RfRUxFTUVOVF9UWVBFIiwgIlN5bWJvbCIsICJmb3IiLCAiQ0FNRUxfUFJPUFMiLCAiSVNfRE9NIiwgIm9uQ2hhbmdlSW5wdXRUeXBlIiwgInRlc3QiLCAiQ29tcG9uZW50IiwgInByb3RvdHlwZSIsICJpc1JlYWN0Q29tcG9uZW50IiwgImZvckVhY2giLCAia2V5IiwgIk9iamVjdCIsICJkZWZpbmVQcm9wZXJ0eSIsICJjb25maWd1cmFibGUiLCAiZ2V0IiwgInRoaXMiLCAic2V0IiwgInYiLCAid3JpdGFibGUiLCAidmFsdWUiLCAib2xkRXZlbnRIb29rIiwgIm9wdGlvbnMiLCAiZXZlbnQiLCAiZW1wdHkiLCAiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCAiY2FuY2VsQnViYmxlIiwgImlzRGVmYXVsdFByZXZlbnRlZCIsICJkZWZhdWx0UHJldmVudGVkIiwgImUiLCAicGVyc2lzdCIsICJuYXRpdmVFdmVudCIsICJjdXJyZW50Q29tcG9uZW50IiwgImNsYXNzTmFtZURlc2NyaXB0b3IiLCAiY2xhc3MiLCAib2xkVk5vZGVIb29rIiwgInZub2RlIiwgInR5cGUiLCAicHJvcHMiLCAibm9ybWFsaXplZFByb3BzIiwgIm5vbkN1c3RvbUVsZW1lbnQiLCAiaW5kZXhPZiIsICJpIiwgIklTX0RPTSIsICJ0ZXN0IiwgIm9uQ2hhbmdlSW5wdXRUeXBlIiwgInRvTG93ZXJDYXNlIiwgIkNBTUVMX1BST1BTIiwgInJlcGxhY2UiLCAibXVsdGlwbGUiLCAiQXJyYXkiLCAiaXNBcnJheSIsICJ0b0NoaWxkQXJyYXkiLCAiY2hpbGRyZW4iLCAiY2hpbGQiLCAic2VsZWN0ZWQiLCAiZGVmYXVsdFZhbHVlIiwgImNsYXNzTmFtZSIsICJlbnVtZXJhYmxlIiwgIiQkdHlwZW9mIiwgIlJFQUNUX0VMRU1FTlRfVFlQRSIsICJvbGRCZWZvcmVSZW5kZXIiLCAiX19yIiwgIl9fYyIsICJpIiwgImoiLCAiaSIsICJhIiwgImIiLCAicyIsICJpbmRleCIsICJuIiwgIm0iLCAiZCIsICJuIiwgImkiLCAiaSIsICJtIiwgIm4iLCAiYSIsICJkIiwgInkiLCAidyIsICJzIiwgInMiLCAiZGlzcGxheSIsICJhIiwgImIiLCAiaSIsICJkIiwgIm0iLCAibiIsICJjIiwgImlzT2JqZWN0IiwgInJhbmdlIiwgInJlcyIsICJpIiwgImEiLCAiYiIsICJuIiwgImluZGV4IiwgImEiLCAicmFuZ2UiLCAiaW5kZXgiLCAiaSIsICJhIiwgImoiLCAiaSIsICJqIiwgInJhbmdlIiwgImRheXNPZldlZWsiLCAiaSIsICJkaXNwbGF5IiwgInJlbmRlcklubmVyQ29udGVudCIsICJjc3NfMjQ4eiIsICJyZW5kZXJJbm5lckNvbnRlbnQiLCAiREVGQVVMVF9XRUVLX05VTV9GT1JNQVQiLCAicmFuZ2UiLCAiaSIsICJyZW5kZXJNb3JlTGlua0lubmVyIiwgImEiLCAiYiIsICJjc3NfMjQ4eiIsICJpbmRleCIsICJXZWVrZGF5IiwgIm4iLCAicyIsICJpIiwgImkiLCAicGFkU3RhcnQiLCAiYSIsICJiIiwgInIiLCAieSIsICJtIiwgImQiLCAiaCIsICJpIiwgInMiLCAiaXNWYWxpZERhdGUiLCAiaSIsICJhIiwgImIiLCAicGFkU3RhcnQiLCAiSXRlclJlc3VsdCIsICJkIiwgImIiLCAicCIsICJfX2Fzc2lnbiIsICJ0IiwgInMiLCAiaSIsICJuIiwgImkiLCAibCIsICJDYWxsYmFja0l0ZXJSZXN1bHQiLCAiVG9UZXh0IiwgImEiLCAiYiIsICJuIiwgIm0iLCAicyIsICJpIiwgIm8iLCAiUGFyc2VyIiwgInYiLCAiUyIsICJuIiwgIkYiLCAibSIsICJGcmVxdWVuY3kiLCAiVGltZSIsICJEYXRlVGltZSIsICJpc1ZhbGlkRGF0ZSIsICJpIiwgInYiLCAicGFyc2VTdHJpbmciLCAieCIsICJuIiwgIkRhdGVXaXRoWm9uZSIsICJkZWZhdWx0S2V5cyIsICJpIiwgImoiLCAia2V5IiwgInZhbHVlIiwgIngiLCAiaSIsICJDYWNoZSIsICJpdGVtIiwgImkiLCAiaiIsICJuIiwgImkiLCAiayIsICJqIiwgImsiLCAiaSIsICJuIiwgInkiLCAiYSIsICJiIiwgImMiLCAiZCIsICJlIiwgImYiLCAiZyIsICJoIiwgImkiLCAiayIsICJsIiwgIm0iLCAiSXRlcmluZm8iLCAiXyIsICJpIiwgImoiLCAiaiIsICJrIiwgImkiLCAiaiIsICJrIiwgIlJSdWxlIiwgImlzVmFsaWREYXRlIiwgInBhcnNlU3RyaW5nIiwgInpvbmVkRGF0ZSIsICJpIiwgIkRFRkFVTFRfT1BUSU9OUyIsICJzIiwgInBhcnNlU3RyaW5nIiwgInZhbCIsICJpbml0aWFsaXplT3B0aW9ucyIsICJkZWZhdWx0S2V5cyIsICJpIiwgImkiLCAiUlJ1bGVTZXQiLCAiZSIsICJpbmRleCIsICJyZW5kZXJJbm5lckNvbnRlbnQiLCAiREVGQVVMVF9USU1FX0ZPUk1BVCIsICJyZW5kZXJBbGxEYXlJbm5lciIsICJyYW5nZSIsICJpIiwgImNzc18yNDh6IiwgIk9QVElPTl9SRUZJTkVSUyIsICJpbmRleCIsICJkcmFnZ2luZyIsICJjb21wb25lbnQiLCAib3B0aW9ucyIsICJjb250ZXh0IiwgImRvY3VtZW50UG9pbnRlciIsICJPUFRJT05fUkVGSU5FUlMiLCAiaW5kZXgiLCAiT1BUSU9OX1JFRklORVJTIiwgImV2ZW50U291cmNlRGVmIiwgImJ1aWxkUmVxdWVzdFBhcmFtcyIsICJyYW5nZSIsICJPUFRJT05fUkVGSU5FUlMiLCAiRVZFTlRfU09VUkNFX1JFRklORVJTIiwgImluZGV4IiwgImUiLCAiaSIsICJzdGFydFRpbWUiLCAiZW5kVGltZSIsICJldmVudFNvdXJjZURlZiIsICJyYW5nZSIsICJpbmRleCIsICJpbmRleCIsICJkIiwgImUiLCAiXyIsICJlIiwgImltcG9ydF9vYnNpZGlhbiIsICJDYWNoZSIsICJfIiwgImkiLCAiaW1wb3J0X29ic2lkaWFuIiwgImluZGV4IiwgImltcG9ydF9vYnNpZGlhbiIsICJpIiwgInBhZ2UiLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJDYWNoZSJdCn0K
